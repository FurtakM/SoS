// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 66 0 0
// PrepareAnimals ( 6 , 3 , 4 , apearea ) ;
  15: LD_INT 6
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 4
  23: PPUSH
  24: LD_INT 21
  26: PPUSH
  27: CALL 10567 0 4
// PrepareAmerican ;
  31: CALL 3957 0 0
// PrepareRussian ;
  35: CALL 277 0 0
// Action ;
  39: CALL 8298 0 0
// end ;
  43: END
// every 0 0$01 do
  44: GO 46
  46: DISABLE
// begin enable ;
  47: ENABLE
// display_strings := [ #tick , tick ] ;
  48: LD_ADDR_OWVAR 47
  52: PUSH
  53: LD_STRING #tick
  55: PUSH
  56: LD_OWVAR 1
  60: PUSH
  61: EMPTY
  62: LIST
  63: LIST
  64: ST_TO_ADDR
// end ;
  65: END
// export conv_squad , escort , medal1 , medal2 , medal3 , path , convoy_start , dest_counter ; export riv , ar_attacks , ar_force , us_force , conv_counter , crates_counter ; function Init ; begin
  66: LD_INT 0
  68: PPUSH
// medal1 := true ;
  69: LD_ADDR_EXP 3
  73: PUSH
  74: LD_INT 1
  76: ST_TO_ADDR
// medal2 := true ;
  77: LD_ADDR_EXP 4
  81: PUSH
  82: LD_INT 1
  84: ST_TO_ADDR
// medal3 := true ;
  85: LD_ADDR_EXP 5
  89: PUSH
  90: LD_INT 1
  92: ST_TO_ADDR
// path := [ pp1 , pp2 , pp3 , pp4 , conv_end ] ;
  93: LD_ADDR_EXP 6
  97: PUSH
  98: LD_INT 10
 100: PUSH
 101: LD_INT 11
 103: PUSH
 104: LD_INT 12
 106: PUSH
 107: LD_INT 13
 109: PUSH
 110: LD_INT 9
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: LIST
 118: LIST
 119: ST_TO_ADDR
// conv_squad := [ ] ;
 120: LD_ADDR_EXP 1
 124: PUSH
 125: EMPTY
 126: ST_TO_ADDR
// escort := [ ] ;
 127: LD_ADDR_EXP 2
 131: PUSH
 132: EMPTY
 133: ST_TO_ADDR
// riv := [ ] ;
 134: LD_ADDR_EXP 9
 138: PUSH
 139: EMPTY
 140: ST_TO_ADDR
// ar_force := [ ] ;
 141: LD_ADDR_EXP 11
 145: PUSH
 146: EMPTY
 147: ST_TO_ADDR
// ar_attacks := false ;
 148: LD_ADDR_EXP 10
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// us_force := [ ] ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: EMPTY
 162: ST_TO_ADDR
// convoy_start := false ;
 163: LD_ADDR_EXP 7
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// conv_counter := 0 ;
 171: LD_ADDR_EXP 13
 175: PUSH
 176: LD_INT 0
 178: ST_TO_ADDR
// dest_counter := 0 ;
 179: LD_ADDR_EXP 8
 183: PUSH
 184: LD_INT 0
 186: ST_TO_ADDR
// crates_counter := 0 0$40 ;
 187: LD_ADDR_EXP 14
 191: PUSH
 192: LD_INT 1400
 194: ST_TO_ADDR
// end ;
 195: LD_VAR 0 1
 199: RET
// every 2 2$00 do
 200: GO 202
 202: DISABLE
// begin while ( tick <= [ 47 47$00 , 44 44$00 , 41 41$00 ] [ Difficulty ] ) do
 203: LD_OWVAR 1
 207: PUSH
 208: LD_INT 98700
 210: PUSH
 211: LD_INT 92400
 213: PUSH
 214: LD_INT 86100
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: PUSH
 222: LD_OWVAR 67
 226: ARRAY
 227: LESSEQUAL
 228: IFFALSE 276
// begin Wait ( crates_counter ) ;
 230: LD_EXP 14
 234: PPUSH
 235: CALL_OW 67
// crates_counter := crates_counter + 0 0$09 ;
 239: LD_ADDR_EXP 14
 243: PUSH
 244: LD_EXP 14
 248: PUSH
 249: LD_INT 315
 251: PLUS
 252: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 5
 258: PPUSH
 259: CALL_OW 12
 263: PPUSH
 264: LD_INT 22
 266: PPUSH
 267: LD_INT 1
 269: PPUSH
 270: CALL_OW 55
// end ;
 274: GO 203
// end ; end_of_file
 276: END
// export Stolypin , Popov , Saseda ; export function PrepareRussian ; var un , force , i , c , skill , team ; begin
 277: LD_INT 0
 279: PPUSH
 280: PPUSH
 281: PPUSH
 282: PPUSH
 283: PPUSH
 284: PPUSH
 285: PPUSH
// uc_side := 6 ;
 286: LD_ADDR_OWVAR 20
 290: PUSH
 291: LD_INT 6
 293: ST_TO_ADDR
// uc_nation := 3 ;
 294: LD_ADDR_OWVAR 21
 298: PUSH
 299: LD_INT 3
 301: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
 302: LD_INT 3
 304: PPUSH
 305: LD_INT 6
 307: PPUSH
 308: CALL_OW 343
// Popov := NewCharacter ( Gaydar ) ;
 312: LD_ADDR_EXP 16
 316: PUSH
 317: LD_STRING Gaydar
 319: PPUSH
 320: CALL_OW 25
 324: ST_TO_ADDR
// uc_side := 7 ;
 325: LD_ADDR_OWVAR 20
 329: PUSH
 330: LD_INT 7
 332: ST_TO_ADDR
// hc_gallery := sandal ;
 333: LD_ADDR_OWVAR 33
 337: PUSH
 338: LD_STRING sandal
 340: ST_TO_ADDR
// hc_face_number := 9 ;
 341: LD_ADDR_OWVAR 34
 345: PUSH
 346: LD_INT 9
 348: ST_TO_ADDR
// hc_skills := [ 3 , 5 , 2 , 7 ] ;
 349: LD_ADDR_OWVAR 31
 353: PUSH
 354: LD_INT 3
 356: PUSH
 357: LD_INT 5
 359: PUSH
 360: LD_INT 2
 362: PUSH
 363: LD_INT 7
 365: PUSH
 366: EMPTY
 367: LIST
 368: LIST
 369: LIST
 370: LIST
 371: ST_TO_ADDR
// hc_sex := sex_male ;
 372: LD_ADDR_OWVAR 27
 376: PUSH
 377: LD_INT 1
 379: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 380: LD_ADDR_OWVAR 29
 384: PUSH
 385: LD_INT 10
 387: PUSH
 388: LD_INT 11
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: ST_TO_ADDR
// hc_class := 4 ;
 395: LD_ADDR_OWVAR 28
 399: PUSH
 400: LD_INT 4
 402: ST_TO_ADDR
// hc_name := Fiodor Saseda ;
 403: LD_ADDR_OWVAR 26
 407: PUSH
 408: LD_STRING Fiodor Saseda
 410: ST_TO_ADDR
// Saseda := CreateHuman ;
 411: LD_ADDR_EXP 17
 415: PUSH
 416: CALL_OW 44
 420: ST_TO_ADDR
// uc_side := 3 ;
 421: LD_ADDR_OWVAR 20
 425: PUSH
 426: LD_INT 3
 428: ST_TO_ADDR
// hc_importance := 100 ;
 429: LD_ADDR_OWVAR 32
 433: PUSH
 434: LD_INT 100
 436: ST_TO_ADDR
// hc_class := 1 ;
 437: LD_ADDR_OWVAR 28
 441: PUSH
 442: LD_INT 1
 444: ST_TO_ADDR
// hc_sex := sex_male ;
 445: LD_ADDR_OWVAR 27
 449: PUSH
 450: LD_INT 1
 452: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
 453: LD_ADDR_OWVAR 31
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 3
 463: PUSH
 464: LD_INT 4
 466: PUSH
 467: LD_INT 2
 469: PUSH
 470: EMPTY
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: ST_TO_ADDR
// hc_name := W. I. Stolypin ;
 476: LD_ADDR_OWVAR 26
 480: PUSH
 481: LD_STRING W. I. Stolypin
 483: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 484: LD_ADDR_OWVAR 29
 488: PUSH
 489: LD_INT 10
 491: PUSH
 492: LD_INT 11
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: ST_TO_ADDR
// hc_gallery := ru ;
 499: LD_ADDR_OWVAR 33
 503: PUSH
 504: LD_STRING ru
 506: ST_TO_ADDR
// hc_face_number := 15 ;
 507: LD_ADDR_OWVAR 34
 511: PUSH
 512: LD_INT 15
 514: ST_TO_ADDR
// Stolypin := CreateHuman ;
 515: LD_ADDR_EXP 15
 519: PUSH
 520: CALL_OW 44
 524: ST_TO_ADDR
// hc_importance := 0 ;
 525: LD_ADDR_OWVAR 32
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// hc_gallery :=  ;
 533: LD_ADDR_OWVAR 33
 537: PUSH
 538: LD_STRING 
 540: ST_TO_ADDR
// hc_name :=  ;
 541: LD_ADDR_OWVAR 26
 545: PUSH
 546: LD_STRING 
 548: ST_TO_ADDR
// skill := [ 6 , 5 , 5 ] [ Difficulty ] ;
 549: LD_ADDR_VAR 0 6
 553: PUSH
 554: LD_INT 6
 556: PUSH
 557: LD_INT 5
 559: PUSH
 560: LD_INT 5
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: PUSH
 568: LD_OWVAR 67
 572: ARRAY
 573: ST_TO_ADDR
// c := 1 ;
 574: LD_ADDR_VAR 0 5
 578: PUSH
 579: LD_INT 1
 581: ST_TO_ADDR
// for i = 1 to 21 do
 582: LD_ADDR_VAR 0 4
 586: PUSH
 587: DOUBLE
 588: LD_INT 1
 590: DEC
 591: ST_TO_ADDR
 592: LD_INT 21
 594: PUSH
 595: FOR_TO
 596: IFFALSE 697
// begin if i = 10 then
 598: LD_VAR 0 4
 602: PUSH
 603: LD_INT 10
 605: EQUAL
 606: IFFALSE 616
// c := 2 ;
 608: LD_ADDR_VAR 0 5
 612: PUSH
 613: LD_INT 2
 615: ST_TO_ADDR
// if i = 14 then
 616: LD_VAR 0 4
 620: PUSH
 621: LD_INT 14
 623: EQUAL
 624: IFFALSE 634
// c := 3 ;
 626: LD_ADDR_VAR 0 5
 630: PUSH
 631: LD_INT 3
 633: ST_TO_ADDR
// if i = 18 then
 634: LD_VAR 0 4
 638: PUSH
 639: LD_INT 18
 641: EQUAL
 642: IFFALSE 652
// c := 4 ;
 644: LD_ADDR_VAR 0 5
 648: PUSH
 649: LD_INT 4
 651: ST_TO_ADDR
// PrepareHuman ( false , c , skill ) ;
 652: LD_INT 0
 654: PPUSH
 655: LD_VAR 0 5
 659: PPUSH
 660: LD_VAR 0 6
 664: PPUSH
 665: CALL_OW 380
// un := CreateHuman ;
 669: LD_ADDR_VAR 0 2
 673: PUSH
 674: CALL_OW 44
 678: ST_TO_ADDR
// force := force ^ un ;
 679: LD_ADDR_VAR 0 3
 683: PUSH
 684: LD_VAR 0 3
 688: PUSH
 689: LD_VAR 0 2
 693: ADD
 694: ST_TO_ADDR
// end ;
 695: GO 595
 697: POP
 698: POP
// team := CharacterSelection ( text , [ 8 , 7 , 7 ] [ Difficulty ] , [ 8 , 7 , 7 ] [ Difficulty ] , [ sel_change_class , Stolypin , sel_changeable , sel_not_hired ] ^ force , [ [ class_soldier , 3 ] , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
 699: LD_ADDR_VAR 0 7
 703: PUSH
 704: LD_STRING text
 706: PPUSH
 707: LD_INT 8
 709: PUSH
 710: LD_INT 7
 712: PUSH
 713: LD_INT 7
 715: PUSH
 716: EMPTY
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_OWVAR 67
 725: ARRAY
 726: PPUSH
 727: LD_INT 8
 729: PUSH
 730: LD_INT 7
 732: PUSH
 733: LD_INT 7
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_OWVAR 67
 745: ARRAY
 746: PPUSH
 747: LD_INT -5
 749: PUSH
 750: LD_EXP 15
 754: PUSH
 755: LD_INT -3
 757: PUSH
 758: LD_INT -2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: LIST
 766: PUSH
 767: LD_VAR 0 3
 771: ADD
 772: PPUSH
 773: LD_INT 1
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: EMPTY
 780: LIST
 781: LIST
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 2
 788: PUSH
 789: LD_INT 1
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 4
 798: PUSH
 799: EMPTY
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PPUSH
 805: CALL_OW 42
 809: ST_TO_ADDR
// team := team ^ Stolypin ;
 810: LD_ADDR_VAR 0 7
 814: PUSH
 815: LD_VAR 0 7
 819: PUSH
 820: LD_EXP 15
 824: ADD
 825: ST_TO_ADDR
// for i = 1 to team do
 826: LD_ADDR_VAR 0 4
 830: PUSH
 831: DOUBLE
 832: LD_INT 1
 834: DEC
 835: ST_TO_ADDR
 836: LD_VAR 0 7
 840: PUSH
 841: FOR_TO
 842: IFFALSE 867
// PlaceUnitArea ( team [ i ] , rus_start , false ) ;
 844: LD_VAR 0 7
 848: PUSH
 849: LD_VAR 0 4
 853: ARRAY
 854: PPUSH
 855: LD_INT 1
 857: PPUSH
 858: LD_INT 0
 860: PPUSH
 861: CALL_OW 49
 865: GO 841
 867: POP
 868: POP
// CenterNowOnUnits ( Stolypin ) ;
 869: LD_EXP 15
 873: PPUSH
 874: CALL_OW 87
// end ;
 878: LD_VAR 0 1
 882: RET
// export conv_ready ; export function Convoy ( type ) ; var i , veh , skill ; begin
 883: LD_INT 0
 885: PPUSH
 886: PPUSH
 887: PPUSH
 888: PPUSH
// Randomize ;
 889: CALL_OW 10
// uc_side := 6 ;
 893: LD_ADDR_OWVAR 20
 897: PUSH
 898: LD_INT 6
 900: ST_TO_ADDR
// uc_nation := 3 ;
 901: LD_ADDR_OWVAR 21
 905: PUSH
 906: LD_INT 3
 908: ST_TO_ADDR
// hc_name :=  ;
 909: LD_ADDR_OWVAR 26
 913: PUSH
 914: LD_STRING 
 916: ST_TO_ADDR
// hc_gallery :=  ;
 917: LD_ADDR_OWVAR 33
 921: PUSH
 922: LD_STRING 
 924: ST_TO_ADDR
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
 925: LD_ADDR_VAR 0 5
 929: PUSH
 930: LD_INT 5
 932: PUSH
 933: LD_INT 5
 935: PUSH
 936: LD_INT 4
 938: PUSH
 939: EMPTY
 940: LIST
 941: LIST
 942: LIST
 943: PUSH
 944: LD_OWVAR 67
 948: ARRAY
 949: ST_TO_ADDR
// conv_ready := false ;
 950: LD_ADDR_EXP 18
 954: PUSH
 955: LD_INT 0
 957: ST_TO_ADDR
// case type of 1 :
 958: LD_VAR 0 1
 962: PUSH
 963: LD_INT 1
 965: DOUBLE
 966: EQUAL
 967: IFTRUE 971
 969: GO 1241
 971: POP
// begin if Rand ( 0 , 1 ) = 1 then
 972: LD_INT 0
 974: PPUSH
 975: LD_INT 1
 977: PPUSH
 978: CALL_OW 12
 982: PUSH
 983: LD_INT 1
 985: EQUAL
 986: IFFALSE 992
// AddEscort ( ) ;
 988: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
 992: LD_INT 70
 994: PPUSH
 995: CALL_OW 67
// vc_chassis := ru_medium_wheeled ;
 999: LD_ADDR_OWVAR 37
1003: PUSH
1004: LD_INT 21
1006: ST_TO_ADDR
// vc_engine := engine_combustion ;
1007: LD_ADDR_OWVAR 39
1011: PUSH
1012: LD_INT 1
1014: ST_TO_ADDR
// vc_control := control_manual ;
1015: LD_ADDR_OWVAR 38
1019: PUSH
1020: LD_INT 1
1022: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1023: LD_ADDR_OWVAR 40
1027: PUSH
1028: LD_INT 51
1030: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1031: LD_ADDR_OWVAR 41
1035: PUSH
1036: LD_INT 50
1038: PPUSH
1039: LD_INT 99
1041: PPUSH
1042: CALL_OW 12
1046: ST_TO_ADDR
// if uc_side <> 6 then
1047: LD_OWVAR 20
1051: PUSH
1052: LD_INT 6
1054: NONEQUAL
1055: IFFALSE 1065
// uc_side := 6 ;
1057: LD_ADDR_OWVAR 20
1061: PUSH
1062: LD_INT 6
1064: ST_TO_ADDR
// veh := CreateVehicle ;
1065: LD_ADDR_VAR 0 4
1069: PUSH
1070: CALL_OW 45
1074: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1075: LD_VAR 0 4
1079: PPUSH
1080: LD_INT 3
1082: PPUSH
1083: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1087: LD_VAR 0 4
1091: PPUSH
1092: LD_INT 8
1094: PPUSH
1095: LD_INT 0
1097: PPUSH
1098: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1102: LD_INT 0
1104: PPUSH
1105: LD_INT 1
1107: PPUSH
1108: LD_INT 2
1110: PPUSH
1111: CALL_OW 12
1115: PPUSH
1116: LD_VAR 0 5
1120: PPUSH
1121: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1125: CALL_OW 44
1129: PPUSH
1130: LD_VAR 0 4
1134: PPUSH
1135: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1139: LD_VAR 0 4
1143: PPUSH
1144: LD_INT 500
1146: PPUSH
1147: LD_INT 1000
1149: PPUSH
1150: CALL_OW 12
1154: PPUSH
1155: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1159: LD_VAR 0 4
1163: PPUSH
1164: LD_INT 1
1166: PPUSH
1167: LD_INT 2
1169: PPUSH
1170: CALL_OW 12
1174: PPUSH
1175: LD_INT 2
1177: PPUSH
1178: LD_INT 10
1180: PPUSH
1181: CALL_OW 12
1185: PUSH
1186: LD_INT 10
1188: MUL
1189: PPUSH
1190: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1194: LD_ADDR_EXP 1
1198: PUSH
1199: LD_EXP 1
1203: PPUSH
1204: LD_INT 1
1206: PPUSH
1207: LD_VAR 0 4
1211: PUSH
1212: LD_INT 1
1214: PUSH
1215: EMPTY
1216: LIST
1217: LIST
1218: PPUSH
1219: CALL_OW 2
1223: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
1224: LD_INT 35
1226: PPUSH
1227: CALL_OW 67
// conv_ready := true ;
1231: LD_ADDR_EXP 18
1235: PUSH
1236: LD_INT 1
1238: ST_TO_ADDR
// end ; 2 :
1239: GO 2861
1241: LD_INT 2
1243: DOUBLE
1244: EQUAL
1245: IFTRUE 1249
1247: GO 1549
1249: POP
// begin AddEscort ( ) ;
1250: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1254: LD_INT 70
1256: PPUSH
1257: CALL_OW 67
// for i = 1 to 2 do
1261: LD_ADDR_VAR 0 3
1265: PUSH
1266: DOUBLE
1267: LD_INT 1
1269: DEC
1270: ST_TO_ADDR
1271: LD_INT 2
1273: PUSH
1274: FOR_TO
1275: IFFALSE 1526
// begin vc_chassis := ru_medium_wheeled ;
1277: LD_ADDR_OWVAR 37
1281: PUSH
1282: LD_INT 21
1284: ST_TO_ADDR
// vc_engine := engine_combustion ;
1285: LD_ADDR_OWVAR 39
1289: PUSH
1290: LD_INT 1
1292: ST_TO_ADDR
// vc_control := control_manual ;
1293: LD_ADDR_OWVAR 38
1297: PUSH
1298: LD_INT 1
1300: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1301: LD_ADDR_OWVAR 40
1305: PUSH
1306: LD_INT 51
1308: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1309: LD_ADDR_OWVAR 41
1313: PUSH
1314: LD_INT 50
1316: PPUSH
1317: LD_INT 99
1319: PPUSH
1320: CALL_OW 12
1324: ST_TO_ADDR
// if uc_side <> 6 then
1325: LD_OWVAR 20
1329: PUSH
1330: LD_INT 6
1332: NONEQUAL
1333: IFFALSE 1343
// uc_side := 6 ;
1335: LD_ADDR_OWVAR 20
1339: PUSH
1340: LD_INT 6
1342: ST_TO_ADDR
// veh := CreateVehicle ;
1343: LD_ADDR_VAR 0 4
1347: PUSH
1348: CALL_OW 45
1352: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1353: LD_VAR 0 4
1357: PPUSH
1358: LD_INT 3
1360: PPUSH
1361: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1365: LD_VAR 0 4
1369: PPUSH
1370: LD_INT 8
1372: PPUSH
1373: LD_INT 0
1375: PPUSH
1376: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1380: LD_INT 0
1382: PPUSH
1383: LD_INT 1
1385: PPUSH
1386: LD_INT 2
1388: PPUSH
1389: CALL_OW 12
1393: PPUSH
1394: LD_VAR 0 5
1398: PPUSH
1399: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1403: CALL_OW 44
1407: PPUSH
1408: LD_VAR 0 4
1412: PPUSH
1413: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1417: LD_VAR 0 4
1421: PPUSH
1422: LD_INT 500
1424: PPUSH
1425: LD_INT 1000
1427: PPUSH
1428: CALL_OW 12
1432: PPUSH
1433: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1437: LD_VAR 0 4
1441: PPUSH
1442: LD_INT 1
1444: PPUSH
1445: LD_INT 2
1447: PPUSH
1448: CALL_OW 12
1452: PPUSH
1453: LD_INT 2
1455: PPUSH
1456: LD_INT 10
1458: PPUSH
1459: CALL_OW 12
1463: PUSH
1464: LD_INT 10
1466: MUL
1467: PPUSH
1468: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1472: LD_ADDR_EXP 1
1476: PUSH
1477: LD_EXP 1
1481: PPUSH
1482: LD_INT 1
1484: PPUSH
1485: LD_VAR 0 4
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: PPUSH
1497: CALL_OW 2
1501: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1502: LD_VAR 0 4
1506: PPUSH
1507: LD_INT 120
1509: PPUSH
1510: LD_INT 10
1512: PPUSH
1513: CALL_OW 111
// Wait ( 0 0$02 ) ;
1517: LD_INT 70
1519: PPUSH
1520: CALL_OW 67
// end ;
1524: GO 1274
1526: POP
1527: POP
// AddEscort ( ) ;
1528: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1532: LD_INT 70
1534: PPUSH
1535: CALL_OW 67
// conv_ready := true ;
1539: LD_ADDR_EXP 18
1543: PUSH
1544: LD_INT 1
1546: ST_TO_ADDR
// end ; 3 :
1547: GO 2861
1549: LD_INT 3
1551: DOUBLE
1552: EQUAL
1553: IFTRUE 1557
1555: GO 1976
1557: POP
// begin AddEscort ( ) ;
1558: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1562: LD_INT 70
1564: PPUSH
1565: CALL_OW 67
// for i = 1 to 2 do
1569: LD_ADDR_VAR 0 3
1573: PUSH
1574: DOUBLE
1575: LD_INT 1
1577: DEC
1578: ST_TO_ADDR
1579: LD_INT 2
1581: PUSH
1582: FOR_TO
1583: IFFALSE 1834
// begin vc_chassis := ru_medium_wheeled ;
1585: LD_ADDR_OWVAR 37
1589: PUSH
1590: LD_INT 21
1592: ST_TO_ADDR
// vc_engine := engine_combustion ;
1593: LD_ADDR_OWVAR 39
1597: PUSH
1598: LD_INT 1
1600: ST_TO_ADDR
// vc_control := control_manual ;
1601: LD_ADDR_OWVAR 38
1605: PUSH
1606: LD_INT 1
1608: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1609: LD_ADDR_OWVAR 40
1613: PUSH
1614: LD_INT 51
1616: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1617: LD_ADDR_OWVAR 41
1621: PUSH
1622: LD_INT 50
1624: PPUSH
1625: LD_INT 99
1627: PPUSH
1628: CALL_OW 12
1632: ST_TO_ADDR
// if uc_side <> 6 then
1633: LD_OWVAR 20
1637: PUSH
1638: LD_INT 6
1640: NONEQUAL
1641: IFFALSE 1651
// uc_side := 6 ;
1643: LD_ADDR_OWVAR 20
1647: PUSH
1648: LD_INT 6
1650: ST_TO_ADDR
// veh := CreateVehicle ;
1651: LD_ADDR_VAR 0 4
1655: PUSH
1656: CALL_OW 45
1660: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1661: LD_VAR 0 4
1665: PPUSH
1666: LD_INT 3
1668: PPUSH
1669: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1673: LD_VAR 0 4
1677: PPUSH
1678: LD_INT 8
1680: PPUSH
1681: LD_INT 0
1683: PPUSH
1684: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1688: LD_INT 0
1690: PPUSH
1691: LD_INT 1
1693: PPUSH
1694: LD_INT 2
1696: PPUSH
1697: CALL_OW 12
1701: PPUSH
1702: LD_VAR 0 5
1706: PPUSH
1707: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1711: CALL_OW 44
1715: PPUSH
1716: LD_VAR 0 4
1720: PPUSH
1721: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1725: LD_VAR 0 4
1729: PPUSH
1730: LD_INT 500
1732: PPUSH
1733: LD_INT 1000
1735: PPUSH
1736: CALL_OW 12
1740: PPUSH
1741: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1745: LD_VAR 0 4
1749: PPUSH
1750: LD_INT 1
1752: PPUSH
1753: LD_INT 2
1755: PPUSH
1756: CALL_OW 12
1760: PPUSH
1761: LD_INT 2
1763: PPUSH
1764: LD_INT 10
1766: PPUSH
1767: CALL_OW 12
1771: PUSH
1772: LD_INT 10
1774: MUL
1775: PPUSH
1776: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1780: LD_ADDR_EXP 1
1784: PUSH
1785: LD_EXP 1
1789: PPUSH
1790: LD_INT 1
1792: PPUSH
1793: LD_VAR 0 4
1797: PUSH
1798: LD_INT 1
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: PPUSH
1805: CALL_OW 2
1809: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1810: LD_VAR 0 4
1814: PPUSH
1815: LD_INT 120
1817: PPUSH
1818: LD_INT 10
1820: PPUSH
1821: CALL_OW 111
// Wait ( 0 0$02 ) ;
1825: LD_INT 70
1827: PPUSH
1828: CALL_OW 67
// end ;
1832: GO 1582
1834: POP
1835: POP
// for i = 1 to 2 do
1836: LD_ADDR_VAR 0 3
1840: PUSH
1841: DOUBLE
1842: LD_INT 1
1844: DEC
1845: ST_TO_ADDR
1846: LD_INT 2
1848: PUSH
1849: FOR_TO
1850: IFFALSE 1957
// begin PrepareHuman ( false , 1 , skill ) ;
1852: LD_INT 0
1854: PPUSH
1855: LD_INT 1
1857: PPUSH
1858: LD_VAR 0 5
1862: PPUSH
1863: CALL_OW 380
// if uc_side <> 6 then
1867: LD_OWVAR 20
1871: PUSH
1872: LD_INT 6
1874: NONEQUAL
1875: IFFALSE 1885
// uc_side := 6 ;
1877: LD_ADDR_OWVAR 20
1881: PUSH
1882: LD_INT 6
1884: ST_TO_ADDR
// veh := CreateHuman ;
1885: LD_ADDR_VAR 0 4
1889: PUSH
1890: CALL_OW 44
1894: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
1895: LD_VAR 0 4
1899: PPUSH
1900: LD_INT 8
1902: PPUSH
1903: LD_INT 0
1905: PPUSH
1906: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
1910: LD_ADDR_EXP 2
1914: PUSH
1915: LD_EXP 2
1919: PPUSH
1920: LD_INT 1
1922: PPUSH
1923: LD_VAR 0 4
1927: PPUSH
1928: CALL_OW 2
1932: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1933: LD_VAR 0 4
1937: PPUSH
1938: LD_INT 120
1940: PPUSH
1941: LD_INT 10
1943: PPUSH
1944: CALL_OW 111
// Wait ( 0 0$02 ) ;
1948: LD_INT 70
1950: PPUSH
1951: CALL_OW 67
// end ;
1955: GO 1849
1957: POP
1958: POP
// Wait ( 0 0$02 ) ;
1959: LD_INT 70
1961: PPUSH
1962: CALL_OW 67
// conv_ready := true ;
1966: LD_ADDR_EXP 18
1970: PUSH
1971: LD_INT 1
1973: ST_TO_ADDR
// end ; 4 :
1974: GO 2861
1976: LD_INT 4
1978: DOUBLE
1979: EQUAL
1980: IFTRUE 1984
1982: GO 2290
1984: POP
// begin if Rand ( 0 , 1 ) = 1 then
1985: LD_INT 0
1987: PPUSH
1988: LD_INT 1
1990: PPUSH
1991: CALL_OW 12
1995: PUSH
1996: LD_INT 1
1998: EQUAL
1999: IFFALSE 2005
// AddEscort ( ) ;
2001: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2005: LD_INT 70
2007: PPUSH
2008: CALL_OW 67
// for i = 1 to 5 do
2012: LD_ADDR_VAR 0 3
2016: PUSH
2017: DOUBLE
2018: LD_INT 1
2020: DEC
2021: ST_TO_ADDR
2022: LD_INT 5
2024: PUSH
2025: FOR_TO
2026: IFFALSE 2148
// begin PrepareHuman ( false , Rand ( 2 , 4 ) , skill ) ;
2028: LD_INT 0
2030: PPUSH
2031: LD_INT 2
2033: PPUSH
2034: LD_INT 4
2036: PPUSH
2037: CALL_OW 12
2041: PPUSH
2042: LD_VAR 0 5
2046: PPUSH
2047: CALL_OW 380
// if uc_side <> 6 then
2051: LD_OWVAR 20
2055: PUSH
2056: LD_INT 6
2058: NONEQUAL
2059: IFFALSE 2069
// uc_side := 6 ;
2061: LD_ADDR_OWVAR 20
2065: PUSH
2066: LD_INT 6
2068: ST_TO_ADDR
// veh := CreateHuman ;
2069: LD_ADDR_VAR 0 4
2073: PUSH
2074: CALL_OW 44
2078: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2079: LD_VAR 0 4
2083: PPUSH
2084: LD_INT 8
2086: PPUSH
2087: LD_INT 0
2089: PPUSH
2090: CALL_OW 49
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2094: LD_ADDR_EXP 1
2098: PUSH
2099: LD_EXP 1
2103: PPUSH
2104: LD_INT 1
2106: PPUSH
2107: LD_VAR 0 4
2111: PUSH
2112: LD_INT 1
2114: PUSH
2115: EMPTY
2116: LIST
2117: LIST
2118: PPUSH
2119: CALL_OW 2
2123: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2124: LD_VAR 0 4
2128: PPUSH
2129: LD_INT 120
2131: PPUSH
2132: LD_INT 10
2134: PPUSH
2135: CALL_OW 111
// Wait ( 0 0$02 ) ;
2139: LD_INT 70
2141: PPUSH
2142: CALL_OW 67
// end ;
2146: GO 2025
2148: POP
2149: POP
// for i = 1 to 2 do
2150: LD_ADDR_VAR 0 3
2154: PUSH
2155: DOUBLE
2156: LD_INT 1
2158: DEC
2159: ST_TO_ADDR
2160: LD_INT 2
2162: PUSH
2163: FOR_TO
2164: IFFALSE 2271
// begin PrepareHuman ( false , 1 , skill ) ;
2166: LD_INT 0
2168: PPUSH
2169: LD_INT 1
2171: PPUSH
2172: LD_VAR 0 5
2176: PPUSH
2177: CALL_OW 380
// if uc_side <> 6 then
2181: LD_OWVAR 20
2185: PUSH
2186: LD_INT 6
2188: NONEQUAL
2189: IFFALSE 2199
// uc_side := 6 ;
2191: LD_ADDR_OWVAR 20
2195: PUSH
2196: LD_INT 6
2198: ST_TO_ADDR
// veh := CreateHuman ;
2199: LD_ADDR_VAR 0 4
2203: PUSH
2204: CALL_OW 44
2208: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2209: LD_VAR 0 4
2213: PPUSH
2214: LD_INT 8
2216: PPUSH
2217: LD_INT 0
2219: PPUSH
2220: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
2224: LD_ADDR_EXP 2
2228: PUSH
2229: LD_EXP 2
2233: PPUSH
2234: LD_INT 1
2236: PPUSH
2237: LD_VAR 0 4
2241: PPUSH
2242: CALL_OW 2
2246: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2247: LD_VAR 0 4
2251: PPUSH
2252: LD_INT 120
2254: PPUSH
2255: LD_INT 10
2257: PPUSH
2258: CALL_OW 111
// Wait ( 0 0$02 ) ;
2262: LD_INT 70
2264: PPUSH
2265: CALL_OW 67
// end ;
2269: GO 2163
2271: POP
2272: POP
// Wait ( 0 0$02 ) ;
2273: LD_INT 70
2275: PPUSH
2276: CALL_OW 67
// conv_ready := true ;
2280: LD_ADDR_EXP 18
2284: PUSH
2285: LD_INT 1
2287: ST_TO_ADDR
// end ; 5 :
2288: GO 2861
2290: LD_INT 5
2292: DOUBLE
2293: EQUAL
2294: IFTRUE 2298
2296: GO 2860
2298: POP
// begin AddEscort ( ) ;
2299: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2303: LD_INT 70
2305: PPUSH
2306: CALL_OW 67
// AddEscort ( ) ;
2310: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2314: LD_INT 70
2316: PPUSH
2317: CALL_OW 67
// for i = 1 to 2 do
2321: LD_ADDR_VAR 0 3
2325: PUSH
2326: DOUBLE
2327: LD_INT 1
2329: DEC
2330: ST_TO_ADDR
2331: LD_INT 2
2333: PUSH
2334: FOR_TO
2335: IFFALSE 2586
// begin vc_chassis := ru_medium_wheeled ;
2337: LD_ADDR_OWVAR 37
2341: PUSH
2342: LD_INT 21
2344: ST_TO_ADDR
// vc_engine := engine_combustion ;
2345: LD_ADDR_OWVAR 39
2349: PUSH
2350: LD_INT 1
2352: ST_TO_ADDR
// vc_control := control_manual ;
2353: LD_ADDR_OWVAR 38
2357: PUSH
2358: LD_INT 1
2360: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2361: LD_ADDR_OWVAR 40
2365: PUSH
2366: LD_INT 51
2368: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2369: LD_ADDR_OWVAR 41
2373: PUSH
2374: LD_INT 50
2376: PPUSH
2377: LD_INT 99
2379: PPUSH
2380: CALL_OW 12
2384: ST_TO_ADDR
// if uc_side <> 6 then
2385: LD_OWVAR 20
2389: PUSH
2390: LD_INT 6
2392: NONEQUAL
2393: IFFALSE 2403
// uc_side := 6 ;
2395: LD_ADDR_OWVAR 20
2399: PUSH
2400: LD_INT 6
2402: ST_TO_ADDR
// veh := CreateVehicle ;
2403: LD_ADDR_VAR 0 4
2407: PUSH
2408: CALL_OW 45
2412: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2413: LD_VAR 0 4
2417: PPUSH
2418: LD_INT 3
2420: PPUSH
2421: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2425: LD_VAR 0 4
2429: PPUSH
2430: LD_INT 8
2432: PPUSH
2433: LD_INT 0
2435: PPUSH
2436: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2440: LD_INT 0
2442: PPUSH
2443: LD_INT 1
2445: PPUSH
2446: LD_INT 2
2448: PPUSH
2449: CALL_OW 12
2453: PPUSH
2454: LD_VAR 0 5
2458: PPUSH
2459: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2463: CALL_OW 44
2467: PPUSH
2468: LD_VAR 0 4
2472: PPUSH
2473: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2477: LD_VAR 0 4
2481: PPUSH
2482: LD_INT 500
2484: PPUSH
2485: LD_INT 1000
2487: PPUSH
2488: CALL_OW 12
2492: PPUSH
2493: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
2497: LD_VAR 0 4
2501: PPUSH
2502: LD_INT 1
2504: PPUSH
2505: LD_INT 2
2507: PPUSH
2508: CALL_OW 12
2512: PPUSH
2513: LD_INT 2
2515: PPUSH
2516: LD_INT 10
2518: PPUSH
2519: CALL_OW 12
2523: PUSH
2524: LD_INT 10
2526: MUL
2527: PPUSH
2528: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2532: LD_ADDR_EXP 1
2536: PUSH
2537: LD_EXP 1
2541: PPUSH
2542: LD_INT 1
2544: PPUSH
2545: LD_VAR 0 4
2549: PUSH
2550: LD_INT 1
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL_OW 2
2561: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2562: LD_VAR 0 4
2566: PPUSH
2567: LD_INT 120
2569: PPUSH
2570: LD_INT 10
2572: PPUSH
2573: CALL_OW 111
// Wait ( 0 0$02 ) ;
2577: LD_INT 70
2579: PPUSH
2580: CALL_OW 67
// end ;
2584: GO 2334
2586: POP
2587: POP
// if Rand ( 0 , 1 ) = 1 then
2588: LD_INT 0
2590: PPUSH
2591: LD_INT 1
2593: PPUSH
2594: CALL_OW 12
2598: PUSH
2599: LD_INT 1
2601: EQUAL
2602: IFFALSE 2638
// begin vc_chassis := ru_medium_tracked ;
2604: LD_ADDR_OWVAR 37
2608: PUSH
2609: LD_INT 22
2611: ST_TO_ADDR
// vc_engine := engine_combustion ;
2612: LD_ADDR_OWVAR 39
2616: PUSH
2617: LD_INT 1
2619: ST_TO_ADDR
// vc_control := control_manual ;
2620: LD_ADDR_OWVAR 38
2624: PUSH
2625: LD_INT 1
2627: ST_TO_ADDR
// vc_weapon := ru_crane ;
2628: LD_ADDR_OWVAR 40
2632: PUSH
2633: LD_INT 52
2635: ST_TO_ADDR
// end else
2636: GO 2670
// begin vc_chassis := ru_heavy_wheeled ;
2638: LD_ADDR_OWVAR 37
2642: PUSH
2643: LD_INT 23
2645: ST_TO_ADDR
// vc_engine := engine_combustion ;
2646: LD_ADDR_OWVAR 39
2650: PUSH
2651: LD_INT 1
2653: ST_TO_ADDR
// vc_control := control_manual ;
2654: LD_ADDR_OWVAR 38
2658: PUSH
2659: LD_INT 1
2661: ST_TO_ADDR
// vc_weapon := ru_bulldozer ;
2662: LD_ADDR_OWVAR 40
2666: PUSH
2667: LD_INT 53
2669: ST_TO_ADDR
// end ; vc_fuel_battery := Rand ( 50 , 99 ) ;
2670: LD_ADDR_OWVAR 41
2674: PUSH
2675: LD_INT 50
2677: PPUSH
2678: LD_INT 99
2680: PPUSH
2681: CALL_OW 12
2685: ST_TO_ADDR
// if uc_side <> 6 then
2686: LD_OWVAR 20
2690: PUSH
2691: LD_INT 6
2693: NONEQUAL
2694: IFFALSE 2704
// uc_side := 6 ;
2696: LD_ADDR_OWVAR 20
2700: PUSH
2701: LD_INT 6
2703: ST_TO_ADDR
// veh := CreateVehicle ;
2704: LD_ADDR_VAR 0 4
2708: PUSH
2709: CALL_OW 45
2713: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2714: LD_VAR 0 4
2718: PPUSH
2719: LD_INT 3
2721: PPUSH
2722: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2726: LD_VAR 0 4
2730: PPUSH
2731: LD_INT 8
2733: PPUSH
2734: LD_INT 0
2736: PPUSH
2737: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2741: LD_INT 0
2743: PPUSH
2744: LD_INT 1
2746: PPUSH
2747: LD_INT 2
2749: PPUSH
2750: CALL_OW 12
2754: PPUSH
2755: LD_VAR 0 5
2759: PPUSH
2760: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2764: CALL_OW 44
2768: PPUSH
2769: LD_VAR 0 4
2773: PPUSH
2774: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2778: LD_VAR 0 4
2782: PPUSH
2783: LD_INT 500
2785: PPUSH
2786: LD_INT 1000
2788: PPUSH
2789: CALL_OW 12
2793: PPUSH
2794: CALL_OW 234
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2798: LD_ADDR_EXP 1
2802: PUSH
2803: LD_EXP 1
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: LD_VAR 0 4
2815: PUSH
2816: LD_INT 1
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: PPUSH
2823: CALL_OW 2
2827: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2828: LD_VAR 0 4
2832: PPUSH
2833: LD_INT 120
2835: PPUSH
2836: LD_INT 10
2838: PPUSH
2839: CALL_OW 111
// Wait ( 0 0$02 ) ;
2843: LD_INT 70
2845: PPUSH
2846: CALL_OW 67
// conv_ready := true ;
2850: LD_ADDR_EXP 18
2854: PUSH
2855: LD_INT 1
2857: ST_TO_ADDR
// end ; end ;
2858: GO 2861
2860: POP
// end ;
2861: LD_VAR 0 2
2865: RET
// export function AddEscort ( ) ; var veh , skill ; begin
2866: LD_INT 0
2868: PPUSH
2869: PPUSH
2870: PPUSH
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
2871: LD_ADDR_VAR 0 3
2875: PUSH
2876: LD_INT 5
2878: PUSH
2879: LD_INT 5
2881: PUSH
2882: LD_INT 4
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: LIST
2889: PUSH
2890: LD_OWVAR 67
2894: ARRAY
2895: ST_TO_ADDR
// uc_side := 6 ;
2896: LD_ADDR_OWVAR 20
2900: PUSH
2901: LD_INT 6
2903: ST_TO_ADDR
// uc_nation := 3 ;
2904: LD_ADDR_OWVAR 21
2908: PUSH
2909: LD_INT 3
2911: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
2912: LD_ADDR_OWVAR 37
2916: PUSH
2917: LD_INT 21
2919: ST_TO_ADDR
// vc_engine := engine_combustion ;
2920: LD_ADDR_OWVAR 39
2924: PUSH
2925: LD_INT 1
2927: ST_TO_ADDR
// vc_control := control_manual ;
2928: LD_ADDR_OWVAR 38
2932: PUSH
2933: LD_INT 1
2935: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_heavy_machine_gun ] [ Rand ( 1 , 2 ) ] ;
2936: LD_ADDR_OWVAR 40
2940: PUSH
2941: LD_INT 44
2943: PUSH
2944: LD_INT 42
2946: PUSH
2947: EMPTY
2948: LIST
2949: LIST
2950: PUSH
2951: LD_INT 1
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: CALL_OW 12
2961: ARRAY
2962: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2963: LD_ADDR_OWVAR 41
2967: PUSH
2968: LD_INT 50
2970: PPUSH
2971: LD_INT 99
2973: PPUSH
2974: CALL_OW 12
2978: ST_TO_ADDR
// veh := CreateVehicle ;
2979: LD_ADDR_VAR 0 2
2983: PUSH
2984: CALL_OW 45
2988: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2989: LD_VAR 0 2
2993: PPUSH
2994: LD_INT 3
2996: PPUSH
2997: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
3001: LD_VAR 0 2
3005: PPUSH
3006: LD_INT 8
3008: PPUSH
3009: LD_INT 0
3011: PPUSH
3012: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
3016: LD_INT 0
3018: PPUSH
3019: LD_INT 3
3021: PPUSH
3022: LD_VAR 0 3
3026: PPUSH
3027: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3031: CALL_OW 44
3035: PPUSH
3036: LD_VAR 0 2
3040: PPUSH
3041: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
3045: LD_VAR 0 2
3049: PPUSH
3050: LD_INT 500
3052: PPUSH
3053: LD_INT 1000
3055: PPUSH
3056: CALL_OW 12
3060: PPUSH
3061: CALL_OW 234
// escort := Insert ( escort , 1 , veh ) ;
3065: LD_ADDR_EXP 2
3069: PUSH
3070: LD_EXP 2
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: LD_VAR 0 2
3082: PPUSH
3083: CALL_OW 2
3087: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
3088: LD_VAR 0 2
3092: PPUSH
3093: LD_INT 120
3095: PPUSH
3096: LD_INT 10
3098: PPUSH
3099: CALL_OW 111
// end ;
3103: LD_VAR 0 1
3107: RET
// every 4 trigger conv_ready and FilterAllUnits ( [ f_side , 6 ] ) do var i , j ;
3108: LD_EXP 18
3112: PUSH
3113: LD_INT 22
3115: PUSH
3116: LD_INT 6
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: PPUSH
3123: CALL_OW 69
3127: AND
3128: IFFALSE 3861
3130: GO 3132
3132: DISABLE
3133: LD_INT 0
3135: PPUSH
3136: PPUSH
// begin enable ;
3137: ENABLE
// if conv_squad then
3138: LD_EXP 1
3142: IFFALSE 3399
// for i = conv_squad downto 1 do
3144: LD_ADDR_VAR 0 1
3148: PUSH
3149: DOUBLE
3150: LD_EXP 1
3154: INC
3155: ST_TO_ADDR
3156: LD_INT 1
3158: PUSH
3159: FOR_DOWNTO
3160: IFFALSE 3397
// begin if IsInArea ( conv_squad [ i ] [ 1 ] , conv_end ) then
3162: LD_EXP 1
3166: PUSH
3167: LD_VAR 0 1
3171: ARRAY
3172: PUSH
3173: LD_INT 1
3175: ARRAY
3176: PPUSH
3177: LD_INT 9
3179: PPUSH
3180: CALL_OW 308
3184: IFFALSE 3247
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3186: LD_ADDR_VAR 0 2
3190: PUSH
3191: LD_INT 9
3193: PPUSH
3194: LD_INT 22
3196: PUSH
3197: LD_INT 6
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: PPUSH
3204: CALL_OW 70
3208: PUSH
3209: FOR_IN
3210: IFFALSE 3223
// RemoveUnit ( j ) ;
3212: LD_VAR 0 2
3216: PPUSH
3217: CALL_OW 64
3221: GO 3209
3223: POP
3224: POP
// conv_squad := Delete ( conv_squad , i ) ;
3225: LD_ADDR_EXP 1
3229: PUSH
3230: LD_EXP 1
3234: PPUSH
3235: LD_VAR 0 1
3239: PPUSH
3240: CALL_OW 3
3244: ST_TO_ADDR
// break ;
3245: GO 3397
// end ; if IsInArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) then
3247: LD_EXP 1
3251: PUSH
3252: LD_VAR 0 1
3256: ARRAY
3257: PUSH
3258: LD_INT 1
3260: ARRAY
3261: PPUSH
3262: LD_EXP 6
3266: PUSH
3267: LD_EXP 1
3271: PUSH
3272: LD_VAR 0 1
3276: ARRAY
3277: PUSH
3278: LD_INT 2
3280: ARRAY
3281: ARRAY
3282: PPUSH
3283: CALL_OW 308
3287: IFFALSE 3333
// conv_squad := Replace2 ( conv_squad , i , 2 , conv_squad [ i ] [ 2 ] + 1 ) else
3289: LD_ADDR_EXP 1
3293: PUSH
3294: LD_EXP 1
3298: PPUSH
3299: LD_VAR 0 1
3303: PPUSH
3304: LD_INT 2
3306: PPUSH
3307: LD_EXP 1
3311: PUSH
3312: LD_VAR 0 1
3316: ARRAY
3317: PUSH
3318: LD_INT 2
3320: ARRAY
3321: PUSH
3322: LD_INT 1
3324: PLUS
3325: PPUSH
3326: CALL 10135 0 4
3330: ST_TO_ADDR
3331: GO 3395
// if not HasTask ( conv_squad [ i ] [ 1 ] ) then
3333: LD_EXP 1
3337: PUSH
3338: LD_VAR 0 1
3342: ARRAY
3343: PUSH
3344: LD_INT 1
3346: ARRAY
3347: PPUSH
3348: CALL_OW 314
3352: NOT
3353: IFFALSE 3395
// ComMoveToArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) ;
3355: LD_EXP 1
3359: PUSH
3360: LD_VAR 0 1
3364: ARRAY
3365: PUSH
3366: LD_INT 1
3368: ARRAY
3369: PPUSH
3370: LD_EXP 6
3374: PUSH
3375: LD_EXP 1
3379: PUSH
3380: LD_VAR 0 1
3384: ARRAY
3385: PUSH
3386: LD_INT 2
3388: ARRAY
3389: ARRAY
3390: PPUSH
3391: CALL_OW 113
// end ;
3395: GO 3159
3397: POP
3398: POP
// if escort then
3399: LD_EXP 2
3403: IFFALSE 3728
// for i = escort downto 1 do
3405: LD_ADDR_VAR 0 1
3409: PUSH
3410: DOUBLE
3411: LD_EXP 2
3415: INC
3416: ST_TO_ADDR
3417: LD_INT 1
3419: PUSH
3420: FOR_DOWNTO
3421: IFFALSE 3726
// begin if IsInArea ( escort [ i ] , conv_end ) then
3423: LD_EXP 2
3427: PUSH
3428: LD_VAR 0 1
3432: ARRAY
3433: PPUSH
3434: LD_INT 9
3436: PPUSH
3437: CALL_OW 308
3441: IFFALSE 3504
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3443: LD_ADDR_VAR 0 2
3447: PUSH
3448: LD_INT 9
3450: PPUSH
3451: LD_INT 22
3453: PUSH
3454: LD_INT 6
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 70
3465: PUSH
3466: FOR_IN
3467: IFFALSE 3480
// RemoveUnit ( j ) ;
3469: LD_VAR 0 2
3473: PPUSH
3474: CALL_OW 64
3478: GO 3466
3480: POP
3481: POP
// escort := Delete ( escort , i ) ;
3482: LD_ADDR_EXP 2
3486: PUSH
3487: LD_EXP 2
3491: PPUSH
3492: LD_VAR 0 1
3496: PPUSH
3497: CALL_OW 3
3501: ST_TO_ADDR
// break ;
3502: GO 3726
// end ; if FindTarget ( escort [ i ] ) and GetDistUnits ( escort [ i ] , FindTarget ( escort [ i ] ) ) < 13 then
3504: LD_EXP 2
3508: PUSH
3509: LD_VAR 0 1
3513: ARRAY
3514: PPUSH
3515: CALL 10443 0 1
3519: PUSH
3520: LD_EXP 2
3524: PUSH
3525: LD_VAR 0 1
3529: ARRAY
3530: PPUSH
3531: LD_EXP 2
3535: PUSH
3536: LD_VAR 0 1
3540: ARRAY
3541: PPUSH
3542: CALL 10443 0 1
3546: PPUSH
3547: CALL_OW 296
3551: PUSH
3552: LD_INT 13
3554: LESS
3555: AND
3556: IFFALSE 3591
// ComAttackUnit ( escort [ i ] , FindTarget ( escort [ i ] ) ) else
3558: LD_EXP 2
3562: PUSH
3563: LD_VAR 0 1
3567: ARRAY
3568: PPUSH
3569: LD_EXP 2
3573: PUSH
3574: LD_VAR 0 1
3578: ARRAY
3579: PPUSH
3580: CALL 10443 0 1
3584: PPUSH
3585: CALL_OW 115
3589: GO 3724
// if conv_squad and GetDistUnitXY ( escort [ i ] , 64 , 117 ) > 35 and not HasTask ( escort [ i ] ) then
3591: LD_EXP 1
3595: PUSH
3596: LD_EXP 2
3600: PUSH
3601: LD_VAR 0 1
3605: ARRAY
3606: PPUSH
3607: LD_INT 64
3609: PPUSH
3610: LD_INT 117
3612: PPUSH
3613: CALL_OW 297
3617: PUSH
3618: LD_INT 35
3620: GREATER
3621: AND
3622: PUSH
3623: LD_EXP 2
3627: PUSH
3628: LD_VAR 0 1
3632: ARRAY
3633: PPUSH
3634: CALL_OW 314
3638: NOT
3639: AND
3640: IFFALSE 3706
// begin if GetDistUnits ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) > 6 then
3642: LD_EXP 2
3646: PUSH
3647: LD_VAR 0 1
3651: ARRAY
3652: PPUSH
3653: LD_EXP 1
3657: PUSH
3658: LD_INT 1
3660: ARRAY
3661: PUSH
3662: LD_INT 1
3664: ARRAY
3665: PPUSH
3666: CALL_OW 296
3670: PUSH
3671: LD_INT 6
3673: GREATER
3674: IFFALSE 3704
// ComMoveUnit ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) end else
3676: LD_EXP 2
3680: PUSH
3681: LD_VAR 0 1
3685: ARRAY
3686: PPUSH
3687: LD_EXP 1
3691: PUSH
3692: LD_INT 1
3694: ARRAY
3695: PUSH
3696: LD_INT 1
3698: ARRAY
3699: PPUSH
3700: CALL_OW 112
3704: GO 3724
// ComMoveToArea ( escort [ i ] , conv_end ) ;
3706: LD_EXP 2
3710: PUSH
3711: LD_VAR 0 1
3715: ARRAY
3716: PPUSH
3717: LD_INT 9
3719: PPUSH
3720: CALL_OW 113
// end ;
3724: GO 3420
3726: POP
3727: POP
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) then
3728: LD_INT 22
3730: PUSH
3731: LD_INT 6
3733: PUSH
3734: EMPTY
3735: LIST
3736: LIST
3737: PUSH
3738: LD_INT 21
3740: PUSH
3741: LD_INT 1
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PPUSH
3752: CALL_OW 69
3756: IFFALSE 3861
// for j in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) do
3758: LD_ADDR_VAR 0 2
3762: PUSH
3763: LD_INT 22
3765: PUSH
3766: LD_INT 6
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: LD_INT 21
3775: PUSH
3776: LD_INT 1
3778: PUSH
3779: EMPTY
3780: LIST
3781: LIST
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: PPUSH
3787: CALL_OW 69
3791: PUSH
3792: FOR_IN
3793: IFFALSE 3859
// begin if not HasTask ( j ) and not IsInArea ( j , conv_end ) then
3795: LD_VAR 0 2
3799: PPUSH
3800: CALL_OW 314
3804: NOT
3805: PUSH
3806: LD_VAR 0 2
3810: PPUSH
3811: LD_INT 9
3813: PPUSH
3814: CALL_OW 308
3818: NOT
3819: AND
3820: IFFALSE 3834
// ComMoveToArea ( j , conv_end ) ;
3822: LD_VAR 0 2
3826: PPUSH
3827: LD_INT 9
3829: PPUSH
3830: CALL_OW 113
// if IsInArea ( j , conv_end ) then
3834: LD_VAR 0 2
3838: PPUSH
3839: LD_INT 9
3841: PPUSH
3842: CALL_OW 308
3846: IFFALSE 3857
// RemoveUnit ( j ) ;
3848: LD_VAR 0 2
3852: PPUSH
3853: CALL_OW 64
// end ;
3857: GO 3792
3859: POP
3860: POP
// end ;
3861: PPOPN 2
3863: END
// every 0 0$01 trigger UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do var i ;
3864: LD_EXP 2
3868: PUSH
3869: LD_EXP 1
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: PPUSH
3878: LD_INT 22
3880: PUSH
3881: LD_INT 3
3883: PUSH
3884: EMPTY
3885: LIST
3886: LIST
3887: PPUSH
3888: CALL_OW 72
3892: IFFALSE 3954
3894: GO 3896
3896: DISABLE
3897: LD_INT 0
3899: PPUSH
// begin enable ;
3900: ENABLE
// for i in UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do
3901: LD_ADDR_VAR 0 1
3905: PUSH
3906: LD_EXP 2
3910: PUSH
3911: LD_EXP 1
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PPUSH
3920: LD_INT 22
3922: PUSH
3923: LD_INT 3
3925: PUSH
3926: EMPTY
3927: LIST
3928: LIST
3929: PPUSH
3930: CALL_OW 72
3934: PUSH
3935: FOR_IN
3936: IFFALSE 3952
// SetSide ( i , 6 ) ;
3938: LD_VAR 0 1
3942: PPUSH
3943: LD_INT 6
3945: PPUSH
3946: CALL_OW 235
3950: GO 3935
3952: POP
3953: POP
// end ; end_of_file
3954: PPOPN 1
3956: END
// export Collins ; export us_alert , us_retreat , us_patrol , us_count ; export function PrepareAmerican ; var i , un , skill , towers ; begin
3957: LD_INT 0
3959: PPUSH
3960: PPUSH
3961: PPUSH
3962: PPUSH
3963: PPUSH
// uc_side := 1 ;
3964: LD_ADDR_OWVAR 20
3968: PUSH
3969: LD_INT 1
3971: ST_TO_ADDR
// uc_nation := 1 ;
3972: LD_ADDR_OWVAR 21
3976: PUSH
3977: LD_INT 1
3979: ST_TO_ADDR
// us_alert := false ;
3980: LD_ADDR_EXP 20
3984: PUSH
3985: LD_INT 0
3987: ST_TO_ADDR
// us_retreat := false ;
3988: LD_ADDR_EXP 21
3992: PUSH
3993: LD_INT 0
3995: ST_TO_ADDR
// us_patrol := false ;
3996: LD_ADDR_EXP 22
4000: PUSH
4001: LD_INT 0
4003: ST_TO_ADDR
// us_count := 0 ;
4004: LD_ADDR_EXP 23
4008: PUSH
4009: LD_INT 0
4011: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4012: LD_ADDR_VAR 0 4
4016: PUSH
4017: LD_INT 5
4019: PUSH
4020: LD_INT 6
4022: PUSH
4023: LD_INT 7
4025: PUSH
4026: EMPTY
4027: LIST
4028: LIST
4029: LIST
4030: PUSH
4031: LD_OWVAR 67
4035: ARRAY
4036: ST_TO_ADDR
// hc_class := 1 ;
4037: LD_ADDR_OWVAR 28
4041: PUSH
4042: LD_INT 1
4044: ST_TO_ADDR
// hc_sex := sex_male ;
4045: LD_ADDR_OWVAR 27
4049: PUSH
4050: LD_INT 1
4052: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
4053: LD_ADDR_OWVAR 31
4057: PUSH
4058: LD_INT 6
4060: PUSH
4061: LD_INT 3
4063: PUSH
4064: LD_INT 4
4066: PUSH
4067: LD_INT 2
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: LIST
4074: LIST
4075: ST_TO_ADDR
// hc_name := Jack Collins ;
4076: LD_ADDR_OWVAR 26
4080: PUSH
4081: LD_STRING Jack Collins
4083: ST_TO_ADDR
// hc_attr := [ 11 , 11 ] ;
4084: LD_ADDR_OWVAR 29
4088: PUSH
4089: LD_INT 11
4091: PUSH
4092: LD_INT 11
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: ST_TO_ADDR
// hc_gallery :=  ;
4099: LD_ADDR_OWVAR 33
4103: PUSH
4104: LD_STRING 
4106: ST_TO_ADDR
// Collins := CreateHuman ;
4107: LD_ADDR_EXP 19
4111: PUSH
4112: CALL_OW 44
4116: ST_TO_ADDR
// PlaceHumanInUnit ( Collins , us_depot ) ;
4117: LD_EXP 19
4121: PPUSH
4122: LD_INT 50
4124: PPUSH
4125: CALL_OW 52
// hc_name :=  ;
4129: LD_ADDR_OWVAR 26
4133: PUSH
4134: LD_STRING 
4136: ST_TO_ADDR
// if Difficulty > 1 then
4137: LD_OWVAR 67
4141: PUSH
4142: LD_INT 1
4144: GREATER
4145: IFFALSE 4199
// begin bc_type := b_bunker ;
4147: LD_ADDR_OWVAR 42
4151: PUSH
4152: LD_INT 32
4154: ST_TO_ADDR
// bc_level := 5 ;
4155: LD_ADDR_OWVAR 43
4159: PUSH
4160: LD_INT 5
4162: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 40 , 33 , 2 ) ;
4163: LD_INT 40
4165: PPUSH
4166: LD_INT 33
4168: PPUSH
4169: LD_INT 2
4171: PPUSH
4172: CALL_OW 47
// if Difficulty > 2 then
4176: LD_OWVAR 67
4180: PUSH
4181: LD_INT 2
4183: GREATER
4184: IFFALSE 4199
// CreateAndPlaceBuildingXYD ( 41 , 42 , 0 ) ;
4186: LD_INT 41
4188: PPUSH
4189: LD_INT 42
4191: PPUSH
4192: LD_INT 0
4194: PPUSH
4195: CALL_OW 47
// end ; PrepareHuman ( false , 2 , skill ) ;
4199: LD_INT 0
4201: PPUSH
4202: LD_INT 2
4204: PPUSH
4205: LD_VAR 0 4
4209: PPUSH
4210: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
4214: CALL_OW 44
4218: PPUSH
4219: LD_INT 50
4221: PPUSH
4222: CALL_OW 52
// PrepareHuman ( false , 3 , skill ) ;
4226: LD_INT 0
4228: PPUSH
4229: LD_INT 3
4231: PPUSH
4232: LD_VAR 0 4
4236: PPUSH
4237: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4241: CALL_OW 44
4245: PPUSH
4246: LD_INT 56
4248: PPUSH
4249: CALL_OW 52
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4253: CALL_OW 44
4257: PPUSH
4258: LD_INT 56
4260: PPUSH
4261: CALL_OW 52
// PrepareHuman ( false , 4 , skill ) ;
4265: LD_INT 0
4267: PPUSH
4268: LD_INT 4
4270: PPUSH
4271: LD_VAR 0 4
4275: PPUSH
4276: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
4280: CALL_OW 44
4284: PPUSH
4285: LD_INT 63
4287: PPUSH
4288: CALL_OW 52
// PrepareHuman ( false , 1 , skill ) ;
4292: LD_INT 0
4294: PPUSH
4295: LD_INT 1
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: CALL_OW 380
// un := CreateHuman ;
4307: LD_ADDR_VAR 0 3
4311: PUSH
4312: CALL_OW 44
4316: ST_TO_ADDR
// SetDir ( un , 4 ) ;
4317: LD_VAR 0 3
4321: PPUSH
4322: LD_INT 4
4324: PPUSH
4325: CALL_OW 233
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
4329: LD_VAR 0 3
4333: PPUSH
4334: LD_INT 22
4336: PUSH
4337: LD_INT 1
4339: PUSH
4340: EMPTY
4341: LIST
4342: LIST
4343: PUSH
4344: LD_INT 30
4346: PUSH
4347: LD_INT 31
4349: PUSH
4350: EMPTY
4351: LIST
4352: LIST
4353: PUSH
4354: EMPTY
4355: LIST
4356: LIST
4357: PPUSH
4358: CALL_OW 69
4362: PUSH
4363: LD_INT 1
4365: ARRAY
4366: PPUSH
4367: CALL_OW 52
// towers := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) ;
4371: LD_ADDR_VAR 0 5
4375: PUSH
4376: LD_INT 22
4378: PUSH
4379: LD_INT 1
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: PUSH
4386: LD_INT 30
4388: PUSH
4389: LD_INT 32
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: PPUSH
4400: CALL_OW 69
4404: ST_TO_ADDR
// for i in towers do
4405: LD_ADDR_VAR 0 2
4409: PUSH
4410: LD_VAR 0 5
4414: PUSH
4415: FOR_IN
4416: IFFALSE 4484
// begin PrepareHuman ( false , 1 , skill ) ;
4418: LD_INT 0
4420: PPUSH
4421: LD_INT 1
4423: PPUSH
4424: LD_VAR 0 4
4428: PPUSH
4429: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4433: CALL_OW 44
4437: PPUSH
4438: LD_VAR 0 2
4442: PPUSH
4443: CALL_OW 52
// PlaceWeaponTurret ( i , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
4447: LD_VAR 0 2
4451: PPUSH
4452: LD_INT 4
4454: PUSH
4455: LD_INT 3
4457: PUSH
4458: LD_INT 5
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: LIST
4465: PUSH
4466: LD_INT 1
4468: PPUSH
4469: LD_INT 3
4471: PPUSH
4472: CALL_OW 12
4476: ARRAY
4477: PPUSH
4478: CALL_OW 431
// end ;
4482: GO 4415
4484: POP
4485: POP
// PrepareHuman ( false , 1 , skill ) ;
4486: LD_INT 0
4488: PPUSH
4489: LD_INT 1
4491: PPUSH
4492: LD_VAR 0 4
4496: PPUSH
4497: CALL_OW 380
// us_patrol := CreateHuman ;
4501: LD_ADDR_EXP 22
4505: PUSH
4506: CALL_OW 44
4510: ST_TO_ADDR
// PlaceUnitXY ( us_patrol , 12 , 5 , false ) ;
4511: LD_EXP 22
4515: PPUSH
4516: LD_INT 12
4518: PPUSH
4519: LD_INT 5
4521: PPUSH
4522: LD_INT 0
4524: PPUSH
4525: CALL_OW 48
// end ;
4529: LD_VAR 0 1
4533: RET
// every 0 0$01 trigger us_count >= [ 3 , 4 , 5 ] [ Difficulty ] do
4534: LD_EXP 23
4538: PUSH
4539: LD_INT 3
4541: PUSH
4542: LD_INT 4
4544: PUSH
4545: LD_INT 5
4547: PUSH
4548: EMPTY
4549: LIST
4550: LIST
4551: LIST
4552: PUSH
4553: LD_OWVAR 67
4557: ARRAY
4558: GREATEREQUAL
4559: IFFALSE 4584
4561: GO 4563
4563: DISABLE
// begin Say ( Collins , DPM_C2 ) ;
4564: LD_EXP 19
4568: PPUSH
4569: LD_STRING DPM_C2
4571: PPUSH
4572: CALL_OW 88
// us_retreat := true ;
4576: LD_ADDR_EXP 21
4580: PUSH
4581: LD_INT 1
4583: ST_TO_ADDR
// end ;
4584: END
// every 10 10$00 trigger not us_alert do var R ;
4585: LD_EXP 20
4589: NOT
4590: IFFALSE 4664
4592: GO 4594
4594: DISABLE
4595: LD_INT 0
4597: PPUSH
// begin uc_side := 1 ;
4598: LD_ADDR_OWVAR 20
4602: PUSH
4603: LD_INT 1
4605: ST_TO_ADDR
// uc_nation := 1 ;
4606: LD_ADDR_OWVAR 21
4610: PUSH
4611: LD_INT 1
4613: ST_TO_ADDR
// PrepareHuman ( false , 1 , 0 ) ;
4614: LD_INT 0
4616: PPUSH
4617: LD_INT 1
4619: PPUSH
4620: LD_INT 0
4622: PPUSH
4623: CALL_OW 380
// R := CreateHuman ;
4627: LD_ADDR_VAR 0 1
4631: PUSH
4632: CALL_OW 44
4636: ST_TO_ADDR
// SayRadio ( R , DPM_R1 ) ;
4637: LD_VAR 0 1
4641: PPUSH
4642: LD_STRING DPM_R1
4644: PPUSH
4645: CALL_OW 94
// Wait ( 0 0$03 ) ;
4649: LD_INT 105
4651: PPUSH
4652: CALL_OW 67
// us_retreat := true ;
4656: LD_ADDR_EXP 21
4660: PUSH
4661: LD_INT 1
4663: ST_TO_ADDR
// end ;
4664: PPOPN 1
4666: END
// every 0 0$01 trigger us_alert do var i ;
4667: LD_EXP 20
4671: IFFALSE 4931
4673: GO 4675
4675: DISABLE
4676: LD_INT 0
4678: PPUSH
// begin Say ( Collins , DPM_C1 ) ;
4679: LD_EXP 19
4683: PPUSH
4684: LD_STRING DPM_C1
4686: PPUSH
4687: CALL_OW 88
// if UnitsInside ( us_fac ) then
4691: LD_INT 56
4693: PPUSH
4694: CALL_OW 313
4698: IFFALSE 4753
// for i in UnitsInside ( us_fac ) do
4700: LD_ADDR_VAR 0 1
4704: PUSH
4705: LD_INT 56
4707: PPUSH
4708: CALL_OW 313
4712: PUSH
4713: FOR_IN
4714: IFFALSE 4751
// begin ComExitBuilding ( i ) ;
4716: LD_VAR 0 1
4720: PPUSH
4721: CALL_OW 122
// AddComEnterUnit ( i , us_arm ) ;
4725: LD_VAR 0 1
4729: PPUSH
4730: LD_INT 69
4732: PPUSH
4733: CALL_OW 180
// AddComChangeProfession ( i , 1 ) ;
4737: LD_VAR 0 1
4741: PPUSH
4742: LD_INT 1
4744: PPUSH
4745: CALL_OW 183
// end ;
4749: GO 4713
4751: POP
4752: POP
// ComExitBuilding ( Collins ) ;
4753: LD_EXP 19
4757: PPUSH
4758: CALL_OW 122
// AddComEnterUnit ( Collins , us_arm ) ;
4762: LD_EXP 19
4766: PPUSH
4767: LD_INT 69
4769: PPUSH
4770: CALL_OW 180
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] ) ;
4774: LD_INT 22
4776: PUSH
4777: LD_INT 1
4779: PUSH
4780: EMPTY
4781: LIST
4782: LIST
4783: PUSH
4784: LD_INT 25
4786: PUSH
4787: LD_INT 2
4789: PUSH
4790: EMPTY
4791: LIST
4792: LIST
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: PPUSH
4798: CALL_OW 69
4802: PUSH
4803: LD_INT 1
4805: ARRAY
4806: PPUSH
4807: CALL_OW 122
// AddComMoveXY ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , 67 , 52 ) ;
4811: LD_INT 22
4813: PUSH
4814: LD_INT 1
4816: PUSH
4817: EMPTY
4818: LIST
4819: LIST
4820: PUSH
4821: LD_INT 25
4823: PUSH
4824: LD_INT 2
4826: PUSH
4827: EMPTY
4828: LIST
4829: LIST
4830: PUSH
4831: EMPTY
4832: LIST
4833: LIST
4834: PPUSH
4835: CALL_OW 69
4839: PUSH
4840: LD_INT 1
4842: ARRAY
4843: PPUSH
4844: LD_INT 67
4846: PPUSH
4847: LD_INT 52
4849: PPUSH
4850: CALL_OW 171
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] ) ;
4854: LD_INT 22
4856: PUSH
4857: LD_INT 1
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: PUSH
4864: LD_INT 25
4866: PUSH
4867: LD_INT 4
4869: PUSH
4870: EMPTY
4871: LIST
4872: LIST
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PPUSH
4878: CALL_OW 69
4882: PUSH
4883: LD_INT 1
4885: ARRAY
4886: PPUSH
4887: CALL_OW 122
// AddComEnterUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] , us_arm ) ;
4891: LD_INT 22
4893: PUSH
4894: LD_INT 1
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: PUSH
4901: LD_INT 25
4903: PUSH
4904: LD_INT 4
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PPUSH
4915: CALL_OW 69
4919: PUSH
4920: LD_INT 1
4922: ARRAY
4923: PPUSH
4924: LD_INT 69
4926: PPUSH
4927: CALL_OW 180
// end ;
4931: PPOPN 1
4933: END
// every 3 3$00 trigger not us_alert and GetSide ( us_fac ) = 1 do
4934: LD_EXP 20
4938: NOT
4939: PUSH
4940: LD_INT 56
4942: PPUSH
4943: CALL_OW 255
4947: PUSH
4948: LD_INT 1
4950: EQUAL
4951: AND
4952: IFFALSE 4995
4954: GO 4956
4956: DISABLE
// begin AddComConstruct ( us_fac , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun ) ;
4957: LD_INT 56
4959: PPUSH
4960: LD_INT 2
4962: PPUSH
4963: LD_INT 1
4965: PPUSH
4966: LD_INT 1
4968: PPUSH
4969: LD_INT 4
4971: PPUSH
4972: CALL_OW 185
// AddComConstruct ( us_fac , us_medium_tracked , engine_solar , control_manual , us_double_gun ) ;
4976: LD_INT 56
4978: PPUSH
4979: LD_INT 3
4981: PPUSH
4982: LD_INT 2
4984: PPUSH
4985: LD_INT 1
4987: PPUSH
4988: LD_INT 5
4990: PPUSH
4991: CALL_OW 185
// end ;
4995: END
// every 0 0$01 trigger us_patrol do
4996: LD_EXP 22
5000: IFFALSE 5048
5002: GO 5004
5004: DISABLE
// SetPatrol ( us_patrol , [ 12 , 5 , 56 , 4 , 94 , 34 , 92 , 108 ] ) ;
5005: LD_EXP 22
5009: PPUSH
5010: LD_INT 12
5012: PUSH
5013: LD_INT 5
5015: PUSH
5016: LD_INT 56
5018: PUSH
5019: LD_INT 4
5021: PUSH
5022: LD_INT 94
5024: PUSH
5025: LD_INT 34
5027: PUSH
5028: LD_INT 92
5030: PUSH
5031: LD_INT 108
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: LIST
5038: LIST
5039: LIST
5040: LIST
5041: LIST
5042: LIST
5043: PPUSH
5044: CALL 5049 0 2
5048: END
// export function SetPatrol ( un , points ) ; var s , i , turn ; begin
5049: LD_INT 0
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
// s = 1 ;
5055: LD_ADDR_VAR 0 4
5059: PUSH
5060: LD_INT 1
5062: ST_TO_ADDR
// turn := true ;
5063: LD_ADDR_VAR 0 6
5067: PUSH
5068: LD_INT 1
5070: ST_TO_ADDR
// while ( un and not us_alert ) do
5071: LD_VAR 0 1
5075: PUSH
5076: LD_EXP 20
5080: NOT
5081: AND
5082: IFFALSE 5261
// begin wait ( 35 ) ;
5084: LD_INT 35
5086: PPUSH
5087: CALL_OW 67
// if not HasTask ( un ) then
5091: LD_VAR 0 1
5095: PPUSH
5096: CALL_OW 314
5100: NOT
5101: IFFALSE 5220
// begin ComMoveXY ( un , points [ s ] , points [ s + 1 ] ) ;
5103: LD_VAR 0 1
5107: PPUSH
5108: LD_VAR 0 2
5112: PUSH
5113: LD_VAR 0 4
5117: ARRAY
5118: PPUSH
5119: LD_VAR 0 2
5123: PUSH
5124: LD_VAR 0 4
5128: PUSH
5129: LD_INT 1
5131: PLUS
5132: ARRAY
5133: PPUSH
5134: CALL_OW 111
// if s + 2 > points then
5138: LD_VAR 0 4
5142: PUSH
5143: LD_INT 2
5145: PLUS
5146: PUSH
5147: LD_VAR 0 2
5151: GREATER
5152: IFFALSE 5162
// turn := false ;
5154: LD_ADDR_VAR 0 6
5158: PUSH
5159: LD_INT 0
5161: ST_TO_ADDR
// if s - 2 < 1 then
5162: LD_VAR 0 4
5166: PUSH
5167: LD_INT 2
5169: MINUS
5170: PUSH
5171: LD_INT 1
5173: LESS
5174: IFFALSE 5184
// turn := true ;
5176: LD_ADDR_VAR 0 6
5180: PUSH
5181: LD_INT 1
5183: ST_TO_ADDR
// if turn then
5184: LD_VAR 0 6
5188: IFFALSE 5206
// s := s + 2 else
5190: LD_ADDR_VAR 0 4
5194: PUSH
5195: LD_VAR 0 4
5199: PUSH
5200: LD_INT 2
5202: PLUS
5203: ST_TO_ADDR
5204: GO 5220
// s := s - 2 ;
5206: LD_ADDR_VAR 0 4
5210: PUSH
5211: LD_VAR 0 4
5215: PUSH
5216: LD_INT 2
5218: MINUS
5219: ST_TO_ADDR
// end ; if GetLives ( un ) < 1000 or See ( 3 , un ) then
5220: LD_VAR 0 1
5224: PPUSH
5225: CALL_OW 256
5229: PUSH
5230: LD_INT 1000
5232: LESS
5233: PUSH
5234: LD_INT 3
5236: PPUSH
5237: LD_VAR 0 1
5241: PPUSH
5242: CALL_OW 292
5246: OR
5247: IFFALSE 5259
// begin us_alert := true ;
5249: LD_ADDR_EXP 20
5253: PUSH
5254: LD_INT 1
5256: ST_TO_ADDR
// break ;
5257: GO 5261
// end ; end ;
5259: GO 5071
// ComEnterUnit ( un , us_arm ) ;
5261: LD_VAR 0 1
5265: PPUSH
5266: LD_INT 69
5268: PPUSH
5269: CALL_OW 120
// end ;
5273: LD_VAR 0 3
5277: RET
// every 0 0$01 trigger us_retreat do var i , point ;
5278: LD_EXP 21
5282: IFFALSE 5457
5284: GO 5286
5286: DISABLE
5287: LD_INT 0
5289: PPUSH
5290: PPUSH
// begin point := false ;
5291: LD_ADDR_VAR 0 2
5295: PUSH
5296: LD_INT 0
5298: ST_TO_ADDR
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5299: LD_INT 5
5301: PPUSH
5302: LD_INT 22
5304: PUSH
5305: LD_INT 3
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: PPUSH
5312: CALL_OW 70
5316: PUSH
5317: LD_INT 0
5319: EQUAL
5320: IFFALSE 5332
// point := us_ret1 else
5322: LD_ADDR_VAR 0 2
5326: PUSH
5327: LD_INT 3
5329: ST_TO_ADDR
5330: GO 5373
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5332: LD_INT 5
5334: PPUSH
5335: LD_INT 22
5337: PUSH
5338: LD_INT 3
5340: PUSH
5341: EMPTY
5342: LIST
5343: LIST
5344: PPUSH
5345: CALL_OW 70
5349: PUSH
5350: LD_INT 0
5352: EQUAL
5353: IFFALSE 5365
// point := us_ret2 else
5355: LD_ADDR_VAR 0 2
5359: PUSH
5360: LD_INT 2
5362: ST_TO_ADDR
5363: GO 5373
// point := us_ret3 ;
5365: LD_ADDR_VAR 0 2
5369: PUSH
5370: LD_INT 4
5372: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
5373: LD_ADDR_VAR 0 1
5377: PUSH
5378: LD_INT 22
5380: PUSH
5381: LD_INT 1
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: PUSH
5388: LD_INT 21
5390: PUSH
5391: LD_INT 1
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: PUSH
5398: EMPTY
5399: LIST
5400: LIST
5401: PPUSH
5402: CALL_OW 69
5406: PUSH
5407: FOR_IN
5408: IFFALSE 5455
// begin if IsInUnit ( i ) then
5410: LD_VAR 0 1
5414: PPUSH
5415: CALL_OW 310
5419: IFFALSE 5439
// begin ComExitBuilding ( i ) ;
5421: LD_VAR 0 1
5425: PPUSH
5426: CALL_OW 122
// ComExitVehicle ( i ) ;
5430: LD_VAR 0 1
5434: PPUSH
5435: CALL_OW 121
// end ; AddComMoveToArea ( i , point ) ;
5439: LD_VAR 0 1
5443: PPUSH
5444: LD_VAR 0 2
5448: PPUSH
5449: CALL_OW 173
// end ;
5453: GO 5407
5455: POP
5456: POP
// end ;
5457: PPOPN 2
5459: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) do
5460: LD_EXP 21
5464: PUSH
5465: LD_INT 3
5467: PPUSH
5468: LD_INT 22
5470: PUSH
5471: LD_INT 1
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: PPUSH
5478: CALL_OW 70
5482: AND
5483: IFFALSE 5529
5485: GO 5487
5487: DISABLE
// begin enable ;
5488: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) [ 1 ] ) ;
5489: LD_INT 3
5491: PPUSH
5492: LD_INT 22
5494: PUSH
5495: LD_INT 1
5497: PUSH
5498: EMPTY
5499: LIST
5500: LIST
5501: PPUSH
5502: CALL_OW 70
5506: PUSH
5507: LD_INT 1
5509: ARRAY
5510: PPUSH
5511: CALL_OW 64
// if medal1 then
5515: LD_EXP 3
5519: IFFALSE 5529
// medal1 := false ;
5521: LD_ADDR_EXP 3
5525: PUSH
5526: LD_INT 0
5528: ST_TO_ADDR
// end ;
5529: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) do
5530: LD_EXP 21
5534: PUSH
5535: LD_INT 2
5537: PPUSH
5538: LD_INT 22
5540: PUSH
5541: LD_INT 1
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: PPUSH
5548: CALL_OW 70
5552: AND
5553: IFFALSE 5599
5555: GO 5557
5557: DISABLE
// begin enable ;
5558: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) [ 1 ] ) ;
5559: LD_INT 2
5561: PPUSH
5562: LD_INT 22
5564: PUSH
5565: LD_INT 1
5567: PUSH
5568: EMPTY
5569: LIST
5570: LIST
5571: PPUSH
5572: CALL_OW 70
5576: PUSH
5577: LD_INT 1
5579: ARRAY
5580: PPUSH
5581: CALL_OW 64
// if medal1 then
5585: LD_EXP 3
5589: IFFALSE 5599
// medal1 := false ;
5591: LD_ADDR_EXP 3
5595: PUSH
5596: LD_INT 0
5598: ST_TO_ADDR
// end ;
5599: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) do
5600: LD_EXP 21
5604: PUSH
5605: LD_INT 4
5607: PPUSH
5608: LD_INT 22
5610: PUSH
5611: LD_INT 1
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PPUSH
5618: CALL_OW 70
5622: AND
5623: IFFALSE 5669
5625: GO 5627
5627: DISABLE
// begin enable ;
5628: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) [ 1 ] ) ;
5629: LD_INT 4
5631: PPUSH
5632: LD_INT 22
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: PPUSH
5642: CALL_OW 70
5646: PUSH
5647: LD_INT 1
5649: ARRAY
5650: PPUSH
5651: CALL_OW 64
// if medal1 then
5655: LD_EXP 3
5659: IFFALSE 5669
// medal1 := false ;
5661: LD_ADDR_EXP 3
5665: PUSH
5666: LD_INT 0
5668: ST_TO_ADDR
// end ;
5669: END
// every 0 0$03 trigger FilterAllUnits ( [ f_side , 1 ] ) = 0 do
5670: LD_INT 22
5672: PUSH
5673: LD_INT 1
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: PPUSH
5680: CALL_OW 69
5684: PUSH
5685: LD_INT 0
5687: EQUAL
5688: IFFALSE 5701
5690: GO 5692
5692: DISABLE
// us_retreat := false ;
5693: LD_ADDR_EXP 21
5697: PUSH
5698: LD_INT 0
5700: ST_TO_ADDR
5701: END
// export function CounterAttack ; var i , j , un , skill ; begin
5702: LD_INT 0
5704: PPUSH
5705: PPUSH
5706: PPUSH
5707: PPUSH
5708: PPUSH
// uc_side := 1 ;
5709: LD_ADDR_OWVAR 20
5713: PUSH
5714: LD_INT 1
5716: ST_TO_ADDR
// uc_nation := 1 ;
5717: LD_ADDR_OWVAR 21
5721: PUSH
5722: LD_INT 1
5724: ST_TO_ADDR
// skill := [ 4 , 5 , 5 ] [ Difficulty ] ;
5725: LD_ADDR_VAR 0 5
5729: PUSH
5730: LD_INT 4
5732: PUSH
5733: LD_INT 5
5735: PUSH
5736: LD_INT 5
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_OWVAR 67
5748: ARRAY
5749: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
5750: LD_ADDR_VAR 0 2
5754: PUSH
5755: DOUBLE
5756: LD_INT 1
5758: DEC
5759: ST_TO_ADDR
5760: LD_INT 4
5762: PUSH
5763: LD_INT 5
5765: PUSH
5766: LD_INT 6
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: PUSH
5774: LD_OWVAR 67
5778: ARRAY
5779: PUSH
5780: FOR_TO
5781: IFFALSE 5981
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 3 ) ] ;
5783: LD_ADDR_OWVAR 37
5787: PUSH
5788: LD_INT 2
5790: PUSH
5791: LD_INT 3
5793: PUSH
5794: LD_INT 4
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: LIST
5801: PUSH
5802: LD_INT 1
5804: PPUSH
5805: LD_INT 3
5807: PPUSH
5808: CALL_OW 12
5812: ARRAY
5813: ST_TO_ADDR
// vc_engine := engine_combustion ;
5814: LD_ADDR_OWVAR 39
5818: PUSH
5819: LD_INT 1
5821: ST_TO_ADDR
// vc_control := control_manual ;
5822: LD_ADDR_OWVAR 38
5826: PUSH
5827: LD_INT 1
5829: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_light_gun ] [ Rand ( 1 , 3 ) ] ;
5830: LD_ADDR_OWVAR 40
5834: PUSH
5835: LD_INT 4
5837: PUSH
5838: LD_INT 5
5840: PUSH
5841: LD_INT 3
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 1
5851: PPUSH
5852: LD_INT 3
5854: PPUSH
5855: CALL_OW 12
5859: ARRAY
5860: ST_TO_ADDR
// vc_fuel_battery := Rand ( 88 , 99 ) ;
5861: LD_ADDR_OWVAR 41
5865: PUSH
5866: LD_INT 88
5868: PPUSH
5869: LD_INT 99
5871: PPUSH
5872: CALL_OW 12
5876: ST_TO_ADDR
// un := CreateVehicle ;
5877: LD_ADDR_VAR 0 4
5881: PUSH
5882: CALL_OW 45
5886: ST_TO_ADDR
// PlaceUnitXY ( un , 64 , 117 , false ) ;
5887: LD_VAR 0 4
5891: PPUSH
5892: LD_INT 64
5894: PPUSH
5895: LD_INT 117
5897: PPUSH
5898: LD_INT 0
5900: PPUSH
5901: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
5905: LD_INT 0
5907: PPUSH
5908: LD_INT 3
5910: PPUSH
5911: LD_VAR 0 5
5915: PPUSH
5916: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5920: CALL_OW 44
5924: PPUSH
5925: LD_VAR 0 4
5929: PPUSH
5930: CALL_OW 52
// us_force := Insert ( us_force , 1 , un ) ;
5934: LD_ADDR_EXP 12
5938: PUSH
5939: LD_EXP 12
5943: PPUSH
5944: LD_INT 1
5946: PPUSH
5947: LD_VAR 0 4
5951: PPUSH
5952: CALL_OW 2
5956: ST_TO_ADDR
// ComMoveXY ( un , 60 , 109 ) ;
5957: LD_VAR 0 4
5961: PPUSH
5962: LD_INT 60
5964: PPUSH
5965: LD_INT 109
5967: PPUSH
5968: CALL_OW 111
// Wait ( 0 0$02 ) ;
5972: LD_INT 70
5974: PPUSH
5975: CALL_OW 67
// end ;
5979: GO 5780
5981: POP
5982: POP
// RemoveSeeing ( 62 , 113 , 3 ) ;
5983: LD_INT 62
5985: PPUSH
5986: LD_INT 113
5988: PPUSH
5989: LD_INT 3
5991: PPUSH
5992: CALL_OW 331
// while ( FilterAllUnits ( [ f_side , 1 ] ) ) do
5996: LD_INT 22
5998: PUSH
5999: LD_INT 1
6001: PUSH
6002: EMPTY
6003: LIST
6004: LIST
6005: PPUSH
6006: CALL_OW 69
6010: IFFALSE 6211
// begin Wait ( 0 0$01 ) ;
6012: LD_INT 35
6014: PPUSH
6015: CALL_OW 67
// for i = 1 to us_force do
6019: LD_ADDR_VAR 0 2
6023: PUSH
6024: DOUBLE
6025: LD_INT 1
6027: DEC
6028: ST_TO_ADDR
6029: LD_EXP 12
6033: PUSH
6034: FOR_TO
6035: IFFALSE 6070
// ComAttackUnit ( us_force [ i ] , FindTarget ( us_force [ i ] ) ) ;
6037: LD_EXP 12
6041: PUSH
6042: LD_VAR 0 2
6046: ARRAY
6047: PPUSH
6048: LD_EXP 12
6052: PUSH
6053: LD_VAR 0 2
6057: ARRAY
6058: PPUSH
6059: CALL 10443 0 1
6063: PPUSH
6064: CALL_OW 115
6068: GO 6034
6070: POP
6071: POP
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) then
6072: LD_INT 22
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: PUSH
6082: LD_INT 25
6084: PUSH
6085: LD_INT 3
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: PUSH
6092: LD_INT 3
6094: PUSH
6095: LD_INT 55
6097: PUSH
6098: EMPTY
6099: LIST
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: LIST
6109: PPUSH
6110: CALL_OW 69
6114: IFFALSE 6209
// for j in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) do
6116: LD_ADDR_VAR 0 3
6120: PUSH
6121: LD_INT 22
6123: PUSH
6124: LD_INT 1
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: PUSH
6131: LD_INT 25
6133: PUSH
6134: LD_INT 3
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: PUSH
6141: LD_INT 3
6143: PUSH
6144: LD_INT 55
6146: PUSH
6147: EMPTY
6148: LIST
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: PUSH
6154: EMPTY
6155: LIST
6156: LIST
6157: LIST
6158: PPUSH
6159: CALL_OW 69
6163: PUSH
6164: FOR_IN
6165: IFFALSE 6207
// if not IsInArea ( j , conv_end ) then
6167: LD_VAR 0 3
6171: PPUSH
6172: LD_INT 9
6174: PPUSH
6175: CALL_OW 308
6179: NOT
6180: IFFALSE 6196
// ComMoveToArea ( j , conv_end ) else
6182: LD_VAR 0 3
6186: PPUSH
6187: LD_INT 9
6189: PPUSH
6190: CALL_OW 113
6194: GO 6205
// RemoveUnit ( j ) ;
6196: LD_VAR 0 3
6200: PPUSH
6201: CALL_OW 64
6205: GO 6164
6207: POP
6208: POP
// end ;
6209: GO 5996
// end ; end_of_file
6211: LD_VAR 0 1
6215: RET
// export function PrepareArabian ; begin
6216: LD_INT 0
6218: PPUSH
// RobertFarmer ;
6219: CALL 6240 0 0
// PrepareHovercrafts ;
6223: CALL 7114 0 0
// ar_attacks := true ;
6227: LD_ADDR_EXP 10
6231: PUSH
6232: LD_INT 1
6234: ST_TO_ADDR
// end ;
6235: LD_VAR 0 1
6239: RET
// export Farmer ; export function RobertFarmer ; begin
6240: LD_INT 0
6242: PPUSH
// uc_side := 2 ;
6243: LD_ADDR_OWVAR 20
6247: PUSH
6248: LD_INT 2
6250: ST_TO_ADDR
// uc_nation := 2 ;
6251: LD_ADDR_OWVAR 21
6255: PUSH
6256: LD_INT 2
6258: ST_TO_ADDR
// Farmer := NewCharacter ( Farmer ) ;
6259: LD_ADDR_EXP 24
6263: PUSH
6264: LD_STRING Farmer
6266: PPUSH
6267: CALL_OW 25
6271: ST_TO_ADDR
// SayRadio ( Farmer , DPM_F1 ) ;
6272: LD_EXP 24
6276: PPUSH
6277: LD_STRING DPM_F1
6279: PPUSH
6280: CALL_OW 94
// end ;
6284: LD_VAR 0 1
6288: RET
// export function PrepareAttack ( type ) ; var i , un , veh , skill ; begin
6289: LD_INT 0
6291: PPUSH
6292: PPUSH
6293: PPUSH
6294: PPUSH
6295: PPUSH
// uc_side := 2 ;
6296: LD_ADDR_OWVAR 20
6300: PUSH
6301: LD_INT 2
6303: ST_TO_ADDR
// uc_nation := 2 ;
6304: LD_ADDR_OWVAR 21
6308: PUSH
6309: LD_INT 2
6311: ST_TO_ADDR
// skill := [ 4 , 6 , 7 ] [ Difficulty ] ;
6312: LD_ADDR_VAR 0 6
6316: PUSH
6317: LD_INT 4
6319: PUSH
6320: LD_INT 6
6322: PUSH
6323: LD_INT 7
6325: PUSH
6326: EMPTY
6327: LIST
6328: LIST
6329: LIST
6330: PUSH
6331: LD_OWVAR 67
6335: ARRAY
6336: ST_TO_ADDR
// Randomize ;
6337: CALL_OW 10
// case type of 1 :
6341: LD_VAR 0 1
6345: PUSH
6346: LD_INT 1
6348: DOUBLE
6349: EQUAL
6350: IFTRUE 6354
6352: GO 6476
6354: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
6355: LD_ADDR_VAR 0 3
6359: PUSH
6360: DOUBLE
6361: LD_INT 1
6363: DEC
6364: ST_TO_ADDR
6365: LD_INT 3
6367: PUSH
6368: LD_INT 4
6370: PUSH
6371: LD_INT 5
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: LIST
6378: PUSH
6379: LD_OWVAR 67
6383: ARRAY
6384: PUSH
6385: FOR_TO
6386: IFFALSE 6472
// begin PrepareHuman ( false , [ class_soldier , class_soldier , class_mortar ] [ Rand ( 1 , 3 ) ] , skill ) ;
6388: LD_INT 0
6390: PPUSH
6391: LD_INT 1
6393: PUSH
6394: LD_INT 1
6396: PUSH
6397: LD_INT 8
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: LIST
6404: PUSH
6405: LD_INT 1
6407: PPUSH
6408: LD_INT 3
6410: PPUSH
6411: CALL_OW 12
6415: ARRAY
6416: PPUSH
6417: LD_VAR 0 6
6421: PPUSH
6422: CALL_OW 380
// un := CreateHuman ;
6426: LD_ADDR_VAR 0 4
6430: PUSH
6431: CALL_OW 44
6435: ST_TO_ADDR
// PlaceUnitArea ( un , ar3 , false ) ;
6436: LD_VAR 0 4
6440: PPUSH
6441: LD_INT 18
6443: PPUSH
6444: LD_INT 0
6446: PPUSH
6447: CALL_OW 49
// ComMoveToArea ( un , spot3 ) ;
6451: LD_VAR 0 4
6455: PPUSH
6456: LD_INT 20
6458: PPUSH
6459: CALL_OW 113
// Wait ( 0 0$01 ) ;
6463: LD_INT 35
6465: PPUSH
6466: CALL_OW 67
// end ;
6470: GO 6385
6472: POP
6473: POP
// end ; 2 :
6474: GO 7109
6476: LD_INT 2
6478: DOUBLE
6479: EQUAL
6480: IFTRUE 6484
6482: GO 6751
6484: POP
// begin for i = 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
6485: LD_ADDR_VAR 0 3
6489: PUSH
6490: DOUBLE
6491: LD_INT 1
6493: DEC
6494: ST_TO_ADDR
6495: LD_INT 4
6497: PUSH
6498: LD_INT 5
6500: PUSH
6501: LD_INT 5
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: LIST
6508: PUSH
6509: LD_OWVAR 67
6513: ARRAY
6514: PUSH
6515: FOR_TO
6516: IFFALSE 6579
// begin PrepareHuman ( false , class_soldier , skill ) ;
6518: LD_INT 0
6520: PPUSH
6521: LD_INT 1
6523: PPUSH
6524: LD_VAR 0 6
6528: PPUSH
6529: CALL_OW 380
// un := CreateHuman ;
6533: LD_ADDR_VAR 0 4
6537: PUSH
6538: CALL_OW 44
6542: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6543: LD_VAR 0 4
6547: PPUSH
6548: LD_INT 17
6550: PPUSH
6551: LD_INT 0
6553: PPUSH
6554: CALL_OW 49
// ComMoveToArea ( un , spot2 ) ;
6558: LD_VAR 0 4
6562: PPUSH
6563: LD_INT 19
6565: PPUSH
6566: CALL_OW 113
// Wait ( 0 0$01 ) ;
6570: LD_INT 35
6572: PPUSH
6573: CALL_OW 67
// end ;
6577: GO 6515
6579: POP
6580: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
6581: LD_ADDR_VAR 0 3
6585: PUSH
6586: DOUBLE
6587: LD_INT 1
6589: DEC
6590: ST_TO_ADDR
6591: LD_INT 2
6593: PUSH
6594: LD_INT 3
6596: PUSH
6597: LD_INT 4
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: LIST
6604: PUSH
6605: LD_OWVAR 67
6609: ARRAY
6610: PUSH
6611: FOR_TO
6612: IFFALSE 6747
// begin vc_chassis := ar_medium_trike ;
6614: LD_ADDR_OWVAR 37
6618: PUSH
6619: LD_INT 13
6621: ST_TO_ADDR
// vc_engine := engine_combustion ;
6622: LD_ADDR_OWVAR 39
6626: PUSH
6627: LD_INT 1
6629: ST_TO_ADDR
// vc_control := control_manual ;
6630: LD_ADDR_OWVAR 38
6634: PUSH
6635: LD_INT 1
6637: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_light_gun , ar_gun ] [ Rand ( 1 , 3 ) ] ;
6638: LD_ADDR_OWVAR 40
6642: PUSH
6643: LD_INT 24
6645: PUSH
6646: LD_INT 23
6648: PUSH
6649: LD_INT 27
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: LIST
6656: PUSH
6657: LD_INT 1
6659: PPUSH
6660: LD_INT 3
6662: PPUSH
6663: CALL_OW 12
6667: ARRAY
6668: ST_TO_ADDR
// veh := CreateVehicle ;
6669: LD_ADDR_VAR 0 5
6673: PUSH
6674: CALL_OW 45
6678: ST_TO_ADDR
// PlaceUnitArea ( veh , ar2 , false ) ;
6679: LD_VAR 0 5
6683: PPUSH
6684: LD_INT 17
6686: PPUSH
6687: LD_INT 0
6689: PPUSH
6690: CALL_OW 49
// PrepareHuman ( false , 1 , skill ) ;
6694: LD_INT 0
6696: PPUSH
6697: LD_INT 1
6699: PPUSH
6700: LD_VAR 0 6
6704: PPUSH
6705: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6709: CALL_OW 44
6713: PPUSH
6714: LD_VAR 0 5
6718: PPUSH
6719: CALL_OW 52
// ComMoveXY ( veh , 89 , 40 ) ;
6723: LD_VAR 0 5
6727: PPUSH
6728: LD_INT 89
6730: PPUSH
6731: LD_INT 40
6733: PPUSH
6734: CALL_OW 111
// Wait ( 0 0$02 ) ;
6738: LD_INT 70
6740: PPUSH
6741: CALL_OW 67
// end ;
6745: GO 6611
6747: POP
6748: POP
// end ; 3 :
6749: GO 7109
6751: LD_INT 3
6753: DOUBLE
6754: EQUAL
6755: IFTRUE 6759
6757: GO 7108
6759: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] + ( tick div 15 15$00 ) do
6760: LD_ADDR_VAR 0 3
6764: PUSH
6765: DOUBLE
6766: LD_INT 1
6768: DEC
6769: ST_TO_ADDR
6770: LD_INT 3
6772: PUSH
6773: LD_INT 4
6775: PUSH
6776: LD_INT 5
6778: PUSH
6779: EMPTY
6780: LIST
6781: LIST
6782: LIST
6783: PUSH
6784: LD_OWVAR 67
6788: ARRAY
6789: PUSH
6790: LD_OWVAR 1
6794: PUSH
6795: LD_INT 31500
6797: DIV
6798: PLUS
6799: PUSH
6800: FOR_TO
6801: IFFALSE 6909
// begin PrepareHuman ( false , [ class_soldier , class_mortar ] [ Rand ( 1 , 2 ) ] , skill ) ;
6803: LD_INT 0
6805: PPUSH
6806: LD_INT 1
6808: PUSH
6809: LD_INT 8
6811: PUSH
6812: EMPTY
6813: LIST
6814: LIST
6815: PUSH
6816: LD_INT 1
6818: PPUSH
6819: LD_INT 2
6821: PPUSH
6822: CALL_OW 12
6826: ARRAY
6827: PPUSH
6828: LD_VAR 0 6
6832: PPUSH
6833: CALL_OW 380
// un := CreateHuman ;
6837: LD_ADDR_VAR 0 4
6841: PUSH
6842: CALL_OW 44
6846: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6847: LD_VAR 0 4
6851: PPUSH
6852: LD_INT 17
6854: PPUSH
6855: LD_INT 0
6857: PPUSH
6858: CALL_OW 49
// ar_force := Insert ( ar_force , 1 , un ) ;
6862: LD_ADDR_EXP 11
6866: PUSH
6867: LD_EXP 11
6871: PPUSH
6872: LD_INT 1
6874: PPUSH
6875: LD_VAR 0 4
6879: PPUSH
6880: CALL_OW 2
6884: ST_TO_ADDR
// ComMoveXY ( un , 17 , 9 ) ;
6885: LD_VAR 0 4
6889: PPUSH
6890: LD_INT 17
6892: PPUSH
6893: LD_INT 9
6895: PPUSH
6896: CALL_OW 111
// Wait ( 0 0$01 ) ;
6900: LD_INT 35
6902: PPUSH
6903: CALL_OW 67
// end ;
6907: GO 6800
6909: POP
6910: POP
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6911: LD_ADDR_VAR 0 3
6915: PUSH
6916: DOUBLE
6917: LD_INT 1
6919: DEC
6920: ST_TO_ADDR
6921: LD_INT 4
6923: PUSH
6924: LD_INT 5
6926: PUSH
6927: LD_INT 6
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: PUSH
6935: LD_OWVAR 67
6939: ARRAY
6940: PUSH
6941: FOR_TO
6942: IFFALSE 7104
// begin vc_chassis := ar_half_tracked ;
6944: LD_ADDR_OWVAR 37
6948: PUSH
6949: LD_INT 14
6951: ST_TO_ADDR
// vc_engine := engine_combustion ;
6952: LD_ADDR_OWVAR 39
6956: PUSH
6957: LD_INT 1
6959: ST_TO_ADDR
// vc_control := control_manual ;
6960: LD_ADDR_OWVAR 38
6964: PUSH
6965: LD_INT 1
6967: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_flame_thrower ] [ Rand ( 1 , 4 ) ] ;
6968: LD_ADDR_OWVAR 40
6972: PUSH
6973: LD_INT 25
6975: PUSH
6976: LD_INT 27
6978: PUSH
6979: LD_INT 28
6981: PUSH
6982: LD_INT 26
6984: PUSH
6985: EMPTY
6986: LIST
6987: LIST
6988: LIST
6989: LIST
6990: PUSH
6991: LD_INT 1
6993: PPUSH
6994: LD_INT 4
6996: PPUSH
6997: CALL_OW 12
7001: ARRAY
7002: ST_TO_ADDR
// veh := CreateVehicle ;
7003: LD_ADDR_VAR 0 5
7007: PUSH
7008: CALL_OW 45
7012: ST_TO_ADDR
// PlaceUnitArea ( veh , ar1 , false ) ;
7013: LD_VAR 0 5
7017: PPUSH
7018: LD_INT 16
7020: PPUSH
7021: LD_INT 0
7023: PPUSH
7024: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7028: LD_INT 0
7030: PPUSH
7031: LD_INT 3
7033: PPUSH
7034: LD_VAR 0 6
7038: PPUSH
7039: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
7043: CALL_OW 44
7047: PPUSH
7048: LD_VAR 0 5
7052: PPUSH
7053: CALL_OW 52
// ar_force := Insert ( ar_force , 1 , veh ) ;
7057: LD_ADDR_EXP 11
7061: PUSH
7062: LD_EXP 11
7066: PPUSH
7067: LD_INT 1
7069: PPUSH
7070: LD_VAR 0 5
7074: PPUSH
7075: CALL_OW 2
7079: ST_TO_ADDR
// ComMoveXY ( veh , 125 , 31 ) ;
7080: LD_VAR 0 5
7084: PPUSH
7085: LD_INT 125
7087: PPUSH
7088: LD_INT 31
7090: PPUSH
7091: CALL_OW 111
// Wait ( 0 0$02 ) ;
7095: LD_INT 70
7097: PPUSH
7098: CALL_OW 67
// end ;
7102: GO 6941
7104: POP
7105: POP
// end ; end ;
7106: GO 7109
7108: POP
// end ;
7109: LD_VAR 0 2
7113: RET
// export function PrepareHovercrafts ; var i , un , areas , skill ; begin
7114: LD_INT 0
7116: PPUSH
7117: PPUSH
7118: PPUSH
7119: PPUSH
7120: PPUSH
// areas := [ river1 , river2 ] ;
7121: LD_ADDR_VAR 0 4
7125: PUSH
7126: LD_INT 14
7128: PUSH
7129: LD_INT 15
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7136: LD_ADDR_VAR 0 5
7140: PUSH
7141: LD_INT 5
7143: PUSH
7144: LD_INT 6
7146: PUSH
7147: LD_INT 7
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: LIST
7154: PUSH
7155: LD_OWVAR 67
7159: ARRAY
7160: ST_TO_ADDR
// uc_side := 2 ;
7161: LD_ADDR_OWVAR 20
7165: PUSH
7166: LD_INT 2
7168: ST_TO_ADDR
// uc_nation := 2 ;
7169: LD_ADDR_OWVAR 21
7173: PUSH
7174: LD_INT 2
7176: ST_TO_ADDR
// hc_name :=  ;
7177: LD_ADDR_OWVAR 26
7181: PUSH
7182: LD_STRING 
7184: ST_TO_ADDR
// hc_gallery :=  ;
7185: LD_ADDR_OWVAR 33
7189: PUSH
7190: LD_STRING 
7192: ST_TO_ADDR
// for i = 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
7193: LD_ADDR_VAR 0 2
7197: PUSH
7198: DOUBLE
7199: LD_INT 1
7201: DEC
7202: ST_TO_ADDR
7203: LD_INT 1
7205: PUSH
7206: LD_INT 2
7208: PUSH
7209: LD_INT 2
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: LIST
7216: PUSH
7217: LD_OWVAR 67
7221: ARRAY
7222: PUSH
7223: FOR_TO
7224: IFFALSE 7362
// begin vc_chassis := ar_hovercraft ;
7226: LD_ADDR_OWVAR 37
7230: PUSH
7231: LD_INT 11
7233: ST_TO_ADDR
// vc_engine := engine_solar ;
7234: LD_ADDR_OWVAR 39
7238: PUSH
7239: LD_INT 2
7241: ST_TO_ADDR
// vc_control := control_manual ;
7242: LD_ADDR_OWVAR 38
7246: PUSH
7247: LD_INT 1
7249: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
7250: LD_ADDR_OWVAR 40
7254: PUSH
7255: LD_INT 24
7257: ST_TO_ADDR
// vc_fuel_battery := 100 ;
7258: LD_ADDR_OWVAR 41
7262: PUSH
7263: LD_INT 100
7265: ST_TO_ADDR
// un := CreateVehicle ;
7266: LD_ADDR_VAR 0 3
7270: PUSH
7271: CALL_OW 45
7275: ST_TO_ADDR
// PlaceUnitArea ( un , areas [ i ] , false ) ;
7276: LD_VAR 0 3
7280: PPUSH
7281: LD_VAR 0 4
7285: PUSH
7286: LD_VAR 0 2
7290: ARRAY
7291: PPUSH
7292: LD_INT 0
7294: PPUSH
7295: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7299: LD_INT 0
7301: PPUSH
7302: LD_INT 3
7304: PPUSH
7305: LD_VAR 0 5
7309: PPUSH
7310: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
7314: CALL_OW 44
7318: PPUSH
7319: LD_VAR 0 3
7323: PPUSH
7324: CALL_OW 52
// riv := Insert ( riv , 1 , [ un , i ] ) ;
7328: LD_ADDR_EXP 9
7332: PUSH
7333: LD_EXP 9
7337: PPUSH
7338: LD_INT 1
7340: PPUSH
7341: LD_VAR 0 3
7345: PUSH
7346: LD_VAR 0 2
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: PPUSH
7355: CALL_OW 2
7359: ST_TO_ADDR
// end ;
7360: GO 7223
7362: POP
7363: POP
// end ;
7364: LD_VAR 0 1
7368: RET
// every 0 0$01 trigger riv do var i , c ;
7369: LD_EXP 9
7373: IFFALSE 7808
7375: GO 7377
7377: DISABLE
7378: LD_INT 0
7380: PPUSH
7381: PPUSH
// begin enable ;
7382: ENABLE
// for i = riv downto 1 do
7383: LD_ADDR_VAR 0 1
7387: PUSH
7388: DOUBLE
7389: LD_EXP 9
7393: INC
7394: ST_TO_ADDR
7395: LD_INT 1
7397: PUSH
7398: FOR_DOWNTO
7399: IFFALSE 7806
// begin if not riv [ i ] [ 1 ] then
7401: LD_EXP 9
7405: PUSH
7406: LD_VAR 0 1
7410: ARRAY
7411: PUSH
7412: LD_INT 1
7414: ARRAY
7415: NOT
7416: IFFALSE 7438
// begin riv := Delete ( riv , 1 ) ;
7418: LD_ADDR_EXP 9
7422: PUSH
7423: LD_EXP 9
7427: PPUSH
7428: LD_INT 1
7430: PPUSH
7431: CALL_OW 3
7435: ST_TO_ADDR
// break ;
7436: GO 7806
// end ; if not HasTask ( riv [ i ] [ 1 ] ) then
7438: LD_EXP 9
7442: PUSH
7443: LD_VAR 0 1
7447: ARRAY
7448: PUSH
7449: LD_INT 1
7451: ARRAY
7452: PPUSH
7453: CALL_OW 314
7457: NOT
7458: IFFALSE 7526
// begin if riv [ i ] [ 2 ] = 1 then
7460: LD_EXP 9
7464: PUSH
7465: LD_VAR 0 1
7469: ARRAY
7470: PUSH
7471: LD_INT 2
7473: ARRAY
7474: PUSH
7475: LD_INT 1
7477: EQUAL
7478: IFFALSE 7490
// c := 2 else
7480: LD_ADDR_VAR 0 2
7484: PUSH
7485: LD_INT 2
7487: ST_TO_ADDR
7488: GO 7498
// c := 1 ;
7490: LD_ADDR_VAR 0 2
7494: PUSH
7495: LD_INT 1
7497: ST_TO_ADDR
// riv := Replace2 ( riv , i , 2 , c ) ;
7498: LD_ADDR_EXP 9
7502: PUSH
7503: LD_EXP 9
7507: PPUSH
7508: LD_VAR 0 1
7512: PPUSH
7513: LD_INT 2
7515: PPUSH
7516: LD_VAR 0 2
7520: PPUSH
7521: CALL 10135 0 4
7525: ST_TO_ADDR
// end ; if not IsInArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) then
7526: LD_EXP 9
7530: PUSH
7531: LD_VAR 0 1
7535: ARRAY
7536: PUSH
7537: LD_INT 1
7539: ARRAY
7540: PPUSH
7541: LD_INT 14
7543: PUSH
7544: LD_INT 15
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PUSH
7551: LD_EXP 9
7555: PUSH
7556: LD_VAR 0 1
7560: ARRAY
7561: PUSH
7562: LD_INT 2
7564: ARRAY
7565: ARRAY
7566: PPUSH
7567: CALL_OW 308
7571: NOT
7572: IFFALSE 7804
// begin if GetFuel ( riv [ i ] [ 1 ] ) < 50 then
7574: LD_EXP 9
7578: PUSH
7579: LD_VAR 0 1
7583: ARRAY
7584: PUSH
7585: LD_INT 1
7587: ARRAY
7588: PPUSH
7589: CALL_OW 261
7593: PUSH
7594: LD_INT 50
7596: LESS
7597: IFFALSE 7621
// SetFuel ( riv [ i ] [ 1 ] , 67 ) ;
7599: LD_EXP 9
7603: PUSH
7604: LD_VAR 0 1
7608: ARRAY
7609: PUSH
7610: LD_INT 1
7612: ARRAY
7613: PPUSH
7614: LD_INT 67
7616: PPUSH
7617: CALL_OW 240
// if GetDistUnits ( riv [ i ] [ 1 ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 3 ] ) , riv [ i ] [ 1 ] ) ) < 9 then
7621: LD_EXP 9
7625: PUSH
7626: LD_VAR 0 1
7630: ARRAY
7631: PUSH
7632: LD_INT 1
7634: ARRAY
7635: PPUSH
7636: LD_INT 22
7638: PUSH
7639: LD_INT 3
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PPUSH
7646: CALL_OW 69
7650: PPUSH
7651: LD_EXP 9
7655: PUSH
7656: LD_VAR 0 1
7660: ARRAY
7661: PUSH
7662: LD_INT 1
7664: ARRAY
7665: PPUSH
7666: CALL_OW 74
7670: PPUSH
7671: CALL_OW 296
7675: PUSH
7676: LD_INT 9
7678: LESS
7679: IFFALSE 7737
// ComAttackUnit ( riv [ i ] [ 1 ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 3 ] ) , riv [ i ] [ 1 ] ) ) else
7681: LD_EXP 9
7685: PUSH
7686: LD_VAR 0 1
7690: ARRAY
7691: PUSH
7692: LD_INT 1
7694: ARRAY
7695: PPUSH
7696: LD_INT 22
7698: PUSH
7699: LD_INT 3
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PPUSH
7706: CALL_OW 69
7710: PPUSH
7711: LD_EXP 9
7715: PUSH
7716: LD_VAR 0 1
7720: ARRAY
7721: PUSH
7722: LD_INT 1
7724: ARRAY
7725: PPUSH
7726: CALL_OW 74
7730: PPUSH
7731: CALL_OW 115
7735: GO 7804
// begin ComMoveToArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) ;
7737: LD_EXP 9
7741: PUSH
7742: LD_VAR 0 1
7746: ARRAY
7747: PUSH
7748: LD_INT 1
7750: ARRAY
7751: PPUSH
7752: LD_INT 14
7754: PUSH
7755: LD_INT 15
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: PUSH
7762: LD_EXP 9
7766: PUSH
7767: LD_VAR 0 1
7771: ARRAY
7772: PUSH
7773: LD_INT 2
7775: ARRAY
7776: ARRAY
7777: PPUSH
7778: CALL_OW 113
// AddComWait ( riv [ i ] [ 1 ] , 0 0$10 ) ;
7782: LD_EXP 9
7786: PUSH
7787: LD_VAR 0 1
7791: ARRAY
7792: PUSH
7793: LD_INT 1
7795: ARRAY
7796: PPUSH
7797: LD_INT 350
7799: PPUSH
7800: CALL_OW 202
// end ; end ; end ;
7804: GO 7398
7806: POP
7807: POP
// end ;
7808: PPOPN 2
7810: END
// every 10 10$00 trigger convoy_start do var i , un ;
7811: LD_EXP 7
7815: IFFALSE 7936
7817: GO 7819
7819: DISABLE
7820: LD_INT 0
7822: PPUSH
7823: PPUSH
// begin enable ;
7824: ENABLE
// for i = 1 to 2 do
7825: LD_ADDR_VAR 0 1
7829: PUSH
7830: DOUBLE
7831: LD_INT 1
7833: DEC
7834: ST_TO_ADDR
7835: LD_INT 2
7837: PUSH
7838: FOR_TO
7839: IFFALSE 7934
// begin uc_side := 2 ;
7841: LD_ADDR_OWVAR 20
7845: PUSH
7846: LD_INT 2
7848: ST_TO_ADDR
// uc_nation := 2 ;
7849: LD_ADDR_OWVAR 21
7853: PUSH
7854: LD_INT 2
7856: ST_TO_ADDR
// PrepareHuman ( false , 1 , 4 ) ;
7857: LD_INT 0
7859: PPUSH
7860: LD_INT 1
7862: PPUSH
7863: LD_INT 4
7865: PPUSH
7866: CALL_OW 380
// un := CreateHuman ;
7870: LD_ADDR_VAR 0 2
7874: PUSH
7875: CALL_OW 44
7879: ST_TO_ADDR
// PlaceUnitXY ( un , 10 , 2 , false ) ;
7880: LD_VAR 0 2
7884: PPUSH
7885: LD_INT 10
7887: PPUSH
7888: LD_INT 2
7890: PPUSH
7891: LD_INT 0
7893: PPUSH
7894: CALL_OW 48
// ComMoveXY ( un , 24 , 36 ) ;
7898: LD_VAR 0 2
7902: PPUSH
7903: LD_INT 24
7905: PPUSH
7906: LD_INT 36
7908: PPUSH
7909: CALL_OW 111
// AddComMoveToArea ( un , conv_end ) ;
7913: LD_VAR 0 2
7917: PPUSH
7918: LD_INT 9
7920: PPUSH
7921: CALL_OW 173
// Wait ( 0 0$02 ) ;
7925: LD_INT 70
7927: PPUSH
7928: CALL_OW 67
// end ;
7932: GO 7838
7934: POP
7935: POP
// end ;
7936: PPOPN 2
7938: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , rest ;
7939: LD_INT 22
7941: PUSH
7942: LD_INT 2
7944: PUSH
7945: EMPTY
7946: LIST
7947: LIST
7948: PPUSH
7949: CALL_OW 69
7953: IFFALSE 8264
7955: GO 7957
7957: DISABLE
7958: LD_INT 0
7960: PPUSH
7961: PPUSH
// begin enable ;
7962: ENABLE
// rest := FilterAllUnits ( [ f_side , 2 ] ) diff ar_force ;
7963: LD_ADDR_VAR 0 2
7967: PUSH
7968: LD_INT 22
7970: PUSH
7971: LD_INT 2
7973: PUSH
7974: EMPTY
7975: LIST
7976: LIST
7977: PPUSH
7978: CALL_OW 69
7982: PUSH
7983: LD_EXP 11
7987: DIFF
7988: ST_TO_ADDR
// if rest then
7989: LD_VAR 0 2
7993: IFFALSE 8065
// for i in rest do
7995: LD_ADDR_VAR 0 1
7999: PUSH
8000: LD_VAR 0 2
8004: PUSH
8005: FOR_IN
8006: IFFALSE 8063
// if GetClass ( i ) = 3 then
8008: LD_VAR 0 1
8012: PPUSH
8013: CALL_OW 257
8017: PUSH
8018: LD_INT 3
8020: EQUAL
8021: IFFALSE 8061
// begin if not IsInArea ( i , ar2 ) then
8023: LD_VAR 0 1
8027: PPUSH
8028: LD_INT 17
8030: PPUSH
8031: CALL_OW 308
8035: NOT
8036: IFFALSE 8052
// ComMoveToArea ( i , ar2 ) else
8038: LD_VAR 0 1
8042: PPUSH
8043: LD_INT 17
8045: PPUSH
8046: CALL_OW 113
8050: GO 8061
// RemoveUnit ( i ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: CALL_OW 64
// end ;
8061: GO 8005
8063: POP
8064: POP
// if ar_force then
8065: LD_EXP 11
8069: IFFALSE 8264
// for i in ar_force do
8071: LD_ADDR_VAR 0 1
8075: PUSH
8076: LD_EXP 11
8080: PUSH
8081: FOR_IN
8082: IFFALSE 8262
// begin if GetClass ( i ) = class_soldier then
8084: LD_VAR 0 1
8088: PPUSH
8089: CALL_OW 257
8093: PUSH
8094: LD_INT 1
8096: EQUAL
8097: IFFALSE 8189
// if FindTarget ( i ) in FilterAllUnits ( [ f_type , unit_building ] ) then
8099: LD_VAR 0 1
8103: PPUSH
8104: CALL 10443 0 1
8108: PUSH
8109: LD_INT 21
8111: PUSH
8112: LD_INT 3
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PPUSH
8119: CALL_OW 69
8123: IN
8124: IFFALSE 8170
// ComPlaceDelayedCharge ( i , GetX ( FindTarget ( i ) ) , GetY ( FindTarget ( i ) ) , 0 ) else
8126: LD_VAR 0 1
8130: PPUSH
8131: LD_VAR 0 1
8135: PPUSH
8136: CALL 10443 0 1
8140: PPUSH
8141: CALL_OW 250
8145: PPUSH
8146: LD_VAR 0 1
8150: PPUSH
8151: CALL 10443 0 1
8155: PPUSH
8156: CALL_OW 251
8160: PPUSH
8161: LD_INT 0
8163: PPUSH
8164: CALL_OW 132
8168: GO 8189
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8170: LD_VAR 0 1
8174: PPUSH
8175: LD_VAR 0 1
8179: PPUSH
8180: CALL 10443 0 1
8184: PPUSH
8185: CALL_OW 115
// if not GetClass ( i ) = 1 then
8189: LD_VAR 0 1
8193: PPUSH
8194: CALL_OW 257
8198: PUSH
8199: LD_INT 1
8201: EQUAL
8202: NOT
8203: IFFALSE 8224
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8205: LD_VAR 0 1
8209: PPUSH
8210: LD_VAR 0 1
8214: PPUSH
8215: CALL 10443 0 1
8219: PPUSH
8220: CALL_OW 115
// if GetDistUnitXY ( i , 65 , 118 ) < 40 then
8224: LD_VAR 0 1
8228: PPUSH
8229: LD_INT 65
8231: PPUSH
8232: LD_INT 118
8234: PPUSH
8235: CALL_OW 297
8239: PUSH
8240: LD_INT 40
8242: LESS
8243: IFFALSE 8260
// ComMoveXY ( i , 65 , 118 ) ;
8245: LD_VAR 0 1
8249: PPUSH
8250: LD_INT 65
8252: PPUSH
8253: LD_INT 118
8255: PPUSH
8256: CALL_OW 111
// end ;
8260: GO 8081
8262: POP
8263: POP
// end ;
8264: PPOPN 2
8266: END
// every 0 0$01 trigger FilterUnitsInArea ( conv_end , [ f_side , 2 ] ) do
8267: LD_INT 9
8269: PPUSH
8270: LD_INT 22
8272: PUSH
8273: LD_INT 2
8275: PUSH
8276: EMPTY
8277: LIST
8278: LIST
8279: PPUSH
8280: CALL_OW 70
8284: IFFALSE 8297
8286: GO 8288
8288: DISABLE
// medal2 := false ; end_of_file
8289: LD_ADDR_EXP 4
8293: PUSH
8294: LD_INT 0
8296: ST_TO_ADDR
8297: END
// export function Action ; begin
8298: LD_INT 0
8300: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
8301: LD_ADDR_OWVAR 67
8305: PUSH
8306: LD_INT 0
8308: PPUSH
8309: CALL_OW 426
8313: ST_TO_ADDR
// case Query ( info ) of 1 :
8314: LD_STRING info
8316: PPUSH
8317: CALL_OW 97
8321: PUSH
8322: LD_INT 1
8324: DOUBLE
8325: EQUAL
8326: IFTRUE 8330
8328: GO 8333
8330: POP
// ; end ;
8331: GO 8334
8333: POP
// ChangeMissionObjectives ( PM_1 ) ;
8334: LD_STRING PM_1
8336: PPUSH
8337: CALL_OW 337
// SaveForQuickRestart ;
8341: CALL_OW 22
// end ;
8345: LD_VAR 0 1
8349: RET
// every 0 0$01 trigger GetSide ( us_depot ) = 3 do
8350: LD_INT 50
8352: PPUSH
8353: CALL_OW 255
8357: PUSH
8358: LD_INT 3
8360: EQUAL
8361: IFFALSE 8642
8363: GO 8365
8365: DISABLE
// begin Say ( Stolypin , DPM_S1 ) ;
8366: LD_EXP 15
8370: PPUSH
8371: LD_STRING DPM_S1
8373: PPUSH
8374: CALL_OW 88
// SayRadio ( Popov , DPM_P1 ) ;
8378: LD_EXP 16
8382: PPUSH
8383: LD_STRING DPM_P1
8385: PPUSH
8386: CALL_OW 94
// Say ( Stolypin , DPM_S2 ) ;
8390: LD_EXP 15
8394: PPUSH
8395: LD_STRING DPM_S2
8397: PPUSH
8398: CALL_OW 88
// SaveForQuickRestart ;
8402: CALL_OW 22
// ChangeMissionObjectives ( PM_2 ) ;
8406: LD_STRING PM_2
8408: PPUSH
8409: CALL_OW 337
// Wait ( 2 2$30 ) ;
8413: LD_INT 5250
8415: PPUSH
8416: CALL_OW 67
// CenterOnXY ( 117 , 4 ) ;
8420: LD_INT 117
8422: PPUSH
8423: LD_INT 4
8425: PPUSH
8426: CALL_OW 84
// Convoy ( 1 ) ;
8430: LD_INT 1
8432: PPUSH
8433: CALL 883 0 1
// Wait ( 0 0$30 ) ;
8437: LD_INT 1050
8439: PPUSH
8440: CALL_OW 67
// Convoy ( 2 ) ;
8444: LD_INT 2
8446: PPUSH
8447: CALL 883 0 1
// Wait ( 1 1$30 ) ;
8451: LD_INT 3150
8453: PPUSH
8454: CALL_OW 67
// Convoy ( 3 ) ;
8458: LD_INT 3
8460: PPUSH
8461: CALL 883 0 1
// Wait ( 5 5$00 ) ;
8465: LD_INT 10500
8467: PPUSH
8468: CALL_OW 67
// convoy_start := true ;
8472: LD_ADDR_EXP 7
8476: PUSH
8477: LD_INT 1
8479: ST_TO_ADDR
// PrepareArabian ;
8480: CALL 6216 0 0
// PrepareAttack ( 1 ) ;
8484: LD_INT 1
8486: PPUSH
8487: CALL 6289 0 1
// while ( convoy_start ) do
8491: LD_EXP 7
8495: IFFALSE 8642
// begin Wait ( Rand ( 2 2$00 , 4 4$00 ) ) ;
8497: LD_INT 4200
8499: PPUSH
8500: LD_INT 8400
8502: PPUSH
8503: CALL_OW 12
8507: PPUSH
8508: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) < 20 then
8512: LD_INT 22
8514: PUSH
8515: LD_INT 2
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: PPUSH
8522: CALL_OW 69
8526: PUSH
8527: LD_INT 20
8529: LESS
8530: IFFALSE 8547
// PrepareAttack ( Rand ( 1 , 2 ) ) ;
8532: LD_INT 1
8534: PPUSH
8535: LD_INT 2
8537: PPUSH
8538: CALL_OW 12
8542: PPUSH
8543: CALL 6289 0 1
// Convoy ( Rand ( 1 , 5 ) ) ;
8547: LD_INT 1
8549: PPUSH
8550: LD_INT 5
8552: PPUSH
8553: CALL_OW 12
8557: PPUSH
8558: CALL 883 0 1
// conv_counter := conv_counter + 1 ;
8562: LD_ADDR_EXP 13
8566: PUSH
8567: LD_EXP 13
8571: PUSH
8572: LD_INT 1
8574: PLUS
8575: ST_TO_ADDR
// if conv_counter mod [ 5 , 4 , 3 ] [ Difficulty ] = 0 then
8576: LD_EXP 13
8580: PUSH
8581: LD_INT 5
8583: PUSH
8584: LD_INT 4
8586: PUSH
8587: LD_INT 3
8589: PUSH
8590: EMPTY
8591: LIST
8592: LIST
8593: LIST
8594: PUSH
8595: LD_OWVAR 67
8599: ARRAY
8600: MOD
8601: PUSH
8602: LD_INT 0
8604: EQUAL
8605: IFFALSE 8640
// begin Wait ( 1 1$20 ) ;
8607: LD_INT 2800
8609: PPUSH
8610: CALL_OW 67
// SayRadio ( Farmer , DPM_F2 ) ;
8614: LD_EXP 24
8618: PPUSH
8619: LD_STRING DPM_F2
8621: PPUSH
8622: CALL_OW 94
// PrepareAttack ( 3 ) ;
8626: LD_INT 3
8628: PPUSH
8629: CALL 6289 0 1
// Wait ( 4 4$00 ) ;
8633: LD_INT 8400
8635: PPUSH
8636: CALL_OW 67
// end ; end ;
8640: GO 8491
// end ;
8642: END
// every 1 1$30 trigger conv_counter mod 3 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8643: LD_EXP 13
8647: PUSH
8648: LD_INT 3
8650: MOD
8651: PUSH
8652: LD_INT 0
8654: EQUAL
8655: PUSH
8656: LD_INT 22
8658: PUSH
8659: LD_INT 2
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: PPUSH
8666: CALL_OW 69
8670: PUSH
8671: LD_INT 0
8673: EQUAL
8674: AND
8675: IFFALSE 8692
8677: GO 8679
8679: DISABLE
// SayRadio ( Farmer , DPM_F3 ) ;
8680: LD_EXP 24
8684: PPUSH
8685: LD_STRING DPM_F3
8687: PPUSH
8688: CALL_OW 94
8692: END
// every 1 1$30 trigger conv_counter mod 5 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8693: LD_EXP 13
8697: PUSH
8698: LD_INT 5
8700: MOD
8701: PUSH
8702: LD_INT 0
8704: EQUAL
8705: PUSH
8706: LD_INT 22
8708: PUSH
8709: LD_INT 2
8711: PUSH
8712: EMPTY
8713: LIST
8714: LIST
8715: PPUSH
8716: CALL_OW 69
8720: PUSH
8721: LD_INT 0
8723: EQUAL
8724: AND
8725: IFFALSE 8742
8727: GO 8729
8729: DISABLE
// SayRadio ( Farmer , DPM_F4 ) ;
8730: LD_EXP 24
8734: PPUSH
8735: LD_STRING DPM_F4
8737: PPUSH
8738: CALL_OW 94
8742: END
// every 0 0$10 trigger conv_counter >= 8 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
8743: LD_EXP 13
8747: PUSH
8748: LD_INT 8
8750: GREATEREQUAL
8751: PUSH
8752: LD_INT 22
8754: PUSH
8755: LD_INT 6
8757: PUSH
8758: EMPTY
8759: LIST
8760: LIST
8761: PPUSH
8762: CALL_OW 69
8766: PUSH
8767: LD_INT 0
8769: EQUAL
8770: AND
8771: IFFALSE 8870
8773: GO 8775
8775: DISABLE
// begin SayRadio ( Popov , DPM_PEnd ) ;
8776: LD_EXP 16
8780: PPUSH
8781: LD_STRING DPM_PEnd
8783: PPUSH
8784: CALL_OW 94
// AddMedal ( med1 , medal1 ) ;
8788: LD_STRING med1
8790: PPUSH
8791: LD_EXP 3
8795: PPUSH
8796: CALL_OW 101
// AddMedal ( med2 , medal2 ) ;
8800: LD_STRING med2
8802: PPUSH
8803: LD_EXP 4
8807: PPUSH
8808: CALL_OW 101
// if dest_counter >= [ 15 , 10 , 7 ] [ Difficulty ] then
8812: LD_EXP 8
8816: PUSH
8817: LD_INT 15
8819: PUSH
8820: LD_INT 10
8822: PUSH
8823: LD_INT 7
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: LIST
8830: PUSH
8831: LD_OWVAR 67
8835: ARRAY
8836: GREATEREQUAL
8837: IFFALSE 8847
// medal3 := false ;
8839: LD_ADDR_EXP 5
8843: PUSH
8844: LD_INT 0
8846: ST_TO_ADDR
// AddMedal ( med3 , medal3 ) ;
8847: LD_STRING med3
8849: PPUSH
8850: LD_EXP 5
8854: PPUSH
8855: CALL_OW 101
// GiveMedals ( MAIN ) ;
8859: LD_STRING MAIN
8861: PPUSH
8862: CALL_OW 102
// YouWin ;
8866: CALL_OW 103
// end ;
8870: END
// every 4 4$00 trigger convoy_start do var i ;
8871: LD_EXP 7
8875: IFFALSE 9233
8877: GO 8879
8879: DISABLE
8880: LD_INT 0
8882: PPUSH
// begin SayRadio ( Popov , DPM_PHelp ) ;
8883: LD_EXP 16
8887: PPUSH
8888: LD_STRING DPM_PHelp
8890: PPUSH
8891: CALL_OW 94
// Wait ( 0 0$30 ) ;
8895: LD_INT 1050
8897: PPUSH
8898: CALL_OW 67
// Randomize ;
8902: CALL_OW 10
// uc_side := 3 ;
8906: LD_ADDR_OWVAR 20
8910: PUSH
8911: LD_INT 3
8913: ST_TO_ADDR
// uc_nation := 3 ;
8914: LD_ADDR_OWVAR 21
8918: PUSH
8919: LD_INT 3
8921: ST_TO_ADDR
// for i = 1 to [ 5 , 4 , 3 ] [ Difficulty ] do
8922: LD_ADDR_VAR 0 1
8926: PUSH
8927: DOUBLE
8928: LD_INT 1
8930: DEC
8931: ST_TO_ADDR
8932: LD_INT 5
8934: PUSH
8935: LD_INT 4
8937: PUSH
8938: LD_INT 3
8940: PUSH
8941: EMPTY
8942: LIST
8943: LIST
8944: LIST
8945: PUSH
8946: LD_OWVAR 67
8950: ARRAY
8951: PUSH
8952: FOR_TO
8953: IFFALSE 8993
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , 5 ) ;
8955: LD_INT 0
8957: PPUSH
8958: LD_INT 1
8960: PPUSH
8961: LD_INT 3
8963: PPUSH
8964: CALL_OW 12
8968: PPUSH
8969: LD_INT 5
8971: PPUSH
8972: CALL_OW 380
// PlaceUnitArea ( CreateHuman , rus_start , false ) ;
8976: CALL_OW 44
8980: PPUSH
8981: LD_INT 1
8983: PPUSH
8984: LD_INT 0
8986: PPUSH
8987: CALL_OW 49
// end ;
8991: GO 8952
8993: POP
8994: POP
// vc_chassis := ru_heavy_wheeled ;
8995: LD_ADDR_OWVAR 37
8999: PUSH
9000: LD_INT 23
9002: ST_TO_ADDR
// vc_engine := engine_combustion ;
9003: LD_ADDR_OWVAR 39
9007: PUSH
9008: LD_INT 1
9010: ST_TO_ADDR
// vc_control := control_manual ;
9011: LD_ADDR_OWVAR 38
9015: PUSH
9016: LD_INT 1
9018: ST_TO_ADDR
// vc_weapon := 89 ;
9019: LD_ADDR_OWVAR 40
9023: PUSH
9024: LD_INT 89
9026: ST_TO_ADDR
// vc_fuel_battery := 88 ;
9027: LD_ADDR_OWVAR 41
9031: PUSH
9032: LD_INT 88
9034: ST_TO_ADDR
// i := CreateVehicle ;
9035: LD_ADDR_VAR 0 1
9039: PUSH
9040: CALL_OW 45
9044: ST_TO_ADDR
// SetDir ( i , 5 ) ;
9045: LD_VAR 0 1
9049: PPUSH
9050: LD_INT 5
9052: PPUSH
9053: CALL_OW 233
// PlaceUnitXY ( i , 63 , 115 , false ) ;
9057: LD_VAR 0 1
9061: PPUSH
9062: LD_INT 63
9064: PPUSH
9065: LD_INT 115
9067: PPUSH
9068: LD_INT 0
9070: PPUSH
9071: CALL_OW 48
// SetCargo ( i , mat_cans , 200 ) ;
9075: LD_VAR 0 1
9079: PPUSH
9080: LD_INT 1
9082: PPUSH
9083: LD_INT 200
9085: PPUSH
9086: CALL_OW 290
// PrepareHuman ( false , 3 , 5 ) ;
9090: LD_INT 0
9092: PPUSH
9093: LD_INT 3
9095: PPUSH
9096: LD_INT 5
9098: PPUSH
9099: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9103: CALL_OW 44
9107: PPUSH
9108: LD_VAR 0 1
9112: PPUSH
9113: CALL_OW 52
// DialogueOn ;
9117: CALL_OW 6
// CenterNowOnXY ( 169 , 115 ) ;
9121: LD_INT 169
9123: PPUSH
9124: LD_INT 115
9126: PPUSH
9127: CALL_OW 86
// DWait ( 0 0$01 ) ;
9131: LD_INT 35
9133: PPUSH
9134: CALL_OW 68
// CenterNowOnXY ( 63 , 115 ) ;
9138: LD_INT 63
9140: PPUSH
9141: LD_INT 115
9143: PPUSH
9144: CALL_OW 86
// DWait ( 0 0$01 ) ;
9148: LD_INT 35
9150: PPUSH
9151: CALL_OW 68
// DialogueOff ;
9155: CALL_OW 7
// ComMoveXY ( i , 57 , 53 ) ;
9159: LD_VAR 0 1
9163: PPUSH
9164: LD_INT 57
9166: PPUSH
9167: LD_INT 53
9169: PPUSH
9170: CALL_OW 111
// Wait ( Rand ( 3 3$00 , 7 7$00 ) ) ;
9174: LD_INT 6300
9176: PPUSH
9177: LD_INT 14700
9179: PPUSH
9180: CALL_OW 12
9184: PPUSH
9185: CALL_OW 67
// PlaceUnitXY ( Saseda , 86 , 112 , false ) ;
9189: LD_EXP 17
9193: PPUSH
9194: LD_INT 86
9196: PPUSH
9197: LD_INT 112
9199: PPUSH
9200: LD_INT 0
9202: PPUSH
9203: CALL_OW 48
// Wait ( 0 0$0.3 ) ;
9207: LD_INT 10
9209: PPUSH
9210: CALL_OW 67
// SayRadio ( Saseda , DPM_Sa1 ) ;
9214: LD_EXP 17
9218: PPUSH
9219: LD_STRING DPM_Sa1
9221: PPUSH
9222: CALL_OW 94
// ChangeMissionObjectives ( PM_3 ) ;
9226: LD_STRING PM_3
9228: PPUSH
9229: CALL_OW 337
// end ;
9233: PPOPN 1
9235: END
// every 0 0$01 trigger See ( 3 , Saseda ) do
9236: LD_INT 3
9238: PPUSH
9239: LD_EXP 17
9243: PPUSH
9244: CALL_OW 292
9248: IFFALSE 9297
9250: GO 9252
9252: DISABLE
// begin Say ( Saseda , DPM_Sa2 ) ;
9253: LD_EXP 17
9257: PPUSH
9258: LD_STRING DPM_Sa2
9260: PPUSH
9261: CALL_OW 88
// ChangeMissionObjectives ( PM_4 ) ;
9265: LD_STRING PM_4
9267: PPUSH
9268: CALL_OW 337
// SetTech ( tech_rocket , 3 , state_enabled ) ;
9272: LD_INT 40
9274: PPUSH
9275: LD_INT 3
9277: PPUSH
9278: LD_INT 1
9280: PPUSH
9281: CALL_OW 322
// SetSide ( Saseda , 3 ) ;
9285: LD_EXP 17
9289: PPUSH
9290: LD_INT 3
9292: PPUSH
9293: CALL_OW 235
// end ;
9297: END
// every 16 16$00 trigger not medal1 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
9298: LD_EXP 3
9302: NOT
9303: PUSH
9304: LD_INT 22
9306: PUSH
9307: LD_INT 6
9309: PUSH
9310: EMPTY
9311: LIST
9312: LIST
9313: PPUSH
9314: CALL_OW 69
9318: PUSH
9319: LD_INT 0
9321: EQUAL
9322: AND
9323: IFFALSE 9370
9325: GO 9327
9327: DISABLE
// begin Say ( Stolypin , DPM_S3 ) ;
9328: LD_EXP 15
9332: PPUSH
9333: LD_STRING DPM_S3
9335: PPUSH
9336: CALL_OW 88
// PlaceSeeing ( 62 , 113 , 3 , 10 ) ;
9340: LD_INT 62
9342: PPUSH
9343: LD_INT 113
9345: PPUSH
9346: LD_INT 3
9348: PPUSH
9349: LD_INT 10
9351: PPUSH
9352: CALL_OW 330
// CenterOnXY ( 62 , 113 ) ;
9356: LD_INT 62
9358: PPUSH
9359: LD_INT 113
9361: PPUSH
9362: CALL_OW 84
// CounterAttack ;
9366: CALL 5702 0 0
// end ; end_of_file
9370: END
// on LeaveBuilding ( b , h ) do begin if GetSide ( b ) = 1 then
9371: LD_VAR 0 1
9375: PPUSH
9376: CALL_OW 255
9380: PUSH
9381: LD_INT 1
9383: EQUAL
9384: IFFALSE 9420
// if not us_retreat then
9386: LD_EXP 21
9390: NOT
9391: IFFALSE 9420
// if GetClass ( h ) = 1 then
9393: LD_VAR 0 2
9397: PPUSH
9398: CALL_OW 257
9402: PUSH
9403: LD_INT 1
9405: EQUAL
9406: IFFALSE 9420
// ComEnterUnit ( h , us_arm ) ;
9408: LD_VAR 0 2
9412: PPUSH
9413: LD_INT 69
9415: PPUSH
9416: CALL_OW 120
// end ;
9420: PPOPN 2
9422: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
9423: LD_VAR 0 1
9427: PPUSH
9428: CALL 21847 0 1
// if GetSide ( un ) = 1 then
9432: LD_VAR 0 1
9436: PPUSH
9437: CALL_OW 255
9441: PUSH
9442: LD_INT 1
9444: EQUAL
9445: IFFALSE 9461
// us_count := us_count + 1 ;
9447: LD_ADDR_EXP 23
9451: PUSH
9452: LD_EXP 23
9456: PUSH
9457: LD_INT 1
9459: PLUS
9460: ST_TO_ADDR
// if un in us_force then
9461: LD_VAR 0 1
9465: PUSH
9466: LD_EXP 12
9470: IN
9471: IFFALSE 9489
// us_force := us_force diff un ;
9473: LD_ADDR_EXP 12
9477: PUSH
9478: LD_EXP 12
9482: PUSH
9483: LD_VAR 0 1
9487: DIFF
9488: ST_TO_ADDR
// if un in ar_force then
9489: LD_VAR 0 1
9493: PUSH
9494: LD_EXP 11
9498: IN
9499: IFFALSE 9517
// ar_force := ar_force diff un ;
9501: LD_ADDR_EXP 11
9505: PUSH
9506: LD_EXP 11
9510: PUSH
9511: LD_VAR 0 1
9515: DIFF
9516: ST_TO_ADDR
// if un = Stolypin then
9517: LD_VAR 0 1
9521: PUSH
9522: LD_EXP 15
9526: EQUAL
9527: IFFALSE 9536
// YouLost ( dead ) ;
9529: LD_STRING dead
9531: PPUSH
9532: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) then
9536: LD_VAR 0 1
9540: PUSH
9541: LD_INT 22
9543: PUSH
9544: LD_INT 1
9546: PUSH
9547: EMPTY
9548: LIST
9549: LIST
9550: PUSH
9551: LD_INT 30
9553: PUSH
9554: LD_INT 0
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PUSH
9561: EMPTY
9562: LIST
9563: LIST
9564: PPUSH
9565: CALL_OW 69
9569: IN
9570: IFFALSE 9579
// YouLost ( depot ) ;
9572: LD_STRING depot
9574: PPUSH
9575: CALL_OW 104
// if GetSide ( un ) = 6 then
9579: LD_VAR 0 1
9583: PPUSH
9584: CALL_OW 255
9588: PUSH
9589: LD_INT 6
9591: EQUAL
9592: IFFALSE 9608
// dest_counter := dest_counter + 1 ;
9594: LD_ADDR_EXP 8
9598: PUSH
9599: LD_EXP 8
9603: PUSH
9604: LD_INT 1
9606: PLUS
9607: ST_TO_ADDR
// end ;
9608: PPOPN 1
9610: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 1 then
9611: LD_VAR 0 1
9615: PPUSH
9616: CALL_OW 255
9620: PUSH
9621: LD_INT 1
9623: EQUAL
9624: IFFALSE 9641
// ComMoveXY ( un , 57 , 52 ) ;
9626: LD_VAR 0 1
9630: PPUSH
9631: LD_INT 57
9633: PPUSH
9634: LD_INT 52
9636: PPUSH
9637: CALL_OW 111
// end ;
9641: PPOPN 2
9643: END
// on Contact ( s1 , s2 ) do begin if not us_alert then
9644: LD_EXP 20
9648: NOT
9649: IFFALSE 9699
// if ( s1 = 3 and s2 = 1 ) or ( s1 = 1 and s2 = 3 ) then
9651: LD_VAR 0 1
9655: PUSH
9656: LD_INT 3
9658: EQUAL
9659: PUSH
9660: LD_VAR 0 2
9664: PUSH
9665: LD_INT 1
9667: EQUAL
9668: AND
9669: PUSH
9670: LD_VAR 0 1
9674: PUSH
9675: LD_INT 1
9677: EQUAL
9678: PUSH
9679: LD_VAR 0 2
9683: PUSH
9684: LD_INT 3
9686: EQUAL
9687: AND
9688: OR
9689: IFFALSE 9699
// us_alert := true ;
9691: LD_ADDR_EXP 20
9695: PUSH
9696: LD_INT 1
9698: ST_TO_ADDR
// if ( s1 = 6 and s2 = 3 ) or ( s1 = 3 and s2 = 6 ) then
9699: LD_VAR 0 1
9703: PUSH
9704: LD_INT 6
9706: EQUAL
9707: PUSH
9708: LD_VAR 0 2
9712: PUSH
9713: LD_INT 3
9715: EQUAL
9716: AND
9717: PUSH
9718: LD_VAR 0 1
9722: PUSH
9723: LD_INT 3
9725: EQUAL
9726: PUSH
9727: LD_VAR 0 2
9731: PUSH
9732: LD_INT 6
9734: EQUAL
9735: AND
9736: OR
9737: IFFALSE 9746
// YouLost ( alat ) ;
9739: LD_STRING alat
9741: PPUSH
9742: CALL_OW 104
// end ;
9746: PPOPN 2
9748: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = 2 and un in FilterAllUnits ( [ [ f_empty ] , [ f_type , unit_vehicle ] ] ) then
9749: LD_VAR 0 1
9753: PPUSH
9754: CALL_OW 255
9758: PUSH
9759: LD_INT 2
9761: EQUAL
9762: PUSH
9763: LD_VAR 0 1
9767: PUSH
9768: LD_INT 58
9770: PUSH
9771: EMPTY
9772: LIST
9773: PUSH
9774: LD_INT 21
9776: PUSH
9777: LD_INT 2
9779: PUSH
9780: EMPTY
9781: LIST
9782: LIST
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: PPUSH
9788: CALL_OW 69
9792: IN
9793: AND
9794: IFFALSE 9915
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> 2 then
9796: LD_OWVAR 3
9800: PUSH
9801: LD_VAR 0 1
9805: DIFF
9806: PPUSH
9807: LD_VAR 0 1
9811: PPUSH
9812: CALL_OW 74
9816: PPUSH
9817: CALL_OW 255
9821: PUSH
9822: LD_INT 2
9824: NONEQUAL
9825: IFFALSE 9915
// begin Wait ( 0 0$1.3 ) ;
9827: LD_INT 46
9829: PPUSH
9830: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9834: LD_VAR 0 1
9838: PPUSH
9839: CALL_OW 250
9843: PPUSH
9844: LD_VAR 0 1
9848: PPUSH
9849: CALL_OW 251
9853: PPUSH
9854: LD_INT 1
9856: PPUSH
9857: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9861: LD_VAR 0 1
9865: PPUSH
9866: CALL_OW 250
9870: PPUSH
9871: LD_VAR 0 1
9875: PPUSH
9876: CALL_OW 251
9880: PPUSH
9881: LD_INT 1
9883: PPUSH
9884: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9888: LD_VAR 0 1
9892: PPUSH
9893: CALL_OW 250
9897: PPUSH
9898: LD_VAR 0 1
9902: PPUSH
9903: CALL_OW 251
9907: PPUSH
9908: LD_INT 1
9910: PPUSH
9911: CALL_OW 453
// end ; end ;
9915: PPOPN 1
9917: END
// on EvacuateVehicle ( driver , un , c1 , c2 ) do begin if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) and not GetSide ( NearestUnit ( un ) ) = 2 then
9918: LD_VAR 0 2
9922: PUSH
9923: LD_INT 22
9925: PUSH
9926: LD_INT 2
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PUSH
9933: LD_INT 21
9935: PUSH
9936: LD_INT 2
9938: PUSH
9939: EMPTY
9940: LIST
9941: LIST
9942: PUSH
9943: EMPTY
9944: LIST
9945: LIST
9946: PPUSH
9947: CALL_OW 69
9951: IN
9952: PUSH
9953: LD_VAR 0 2
9957: PPUSH
9958: CALL 10488 0 1
9962: PPUSH
9963: CALL_OW 255
9967: PUSH
9968: LD_INT 2
9970: EQUAL
9971: NOT
9972: AND
9973: IFFALSE 10098
// begin Wait ( Rand ( 0 0$03 , 0 0$06 ) ) ;
9975: LD_INT 105
9977: PPUSH
9978: LD_INT 210
9980: PPUSH
9981: CALL_OW 12
9985: PPUSH
9986: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9990: LD_VAR 0 2
9994: PPUSH
9995: CALL_OW 250
9999: PPUSH
10000: LD_VAR 0 2
10004: PPUSH
10005: CALL_OW 251
10009: PPUSH
10010: LD_INT 3
10012: PPUSH
10013: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10017: LD_VAR 0 2
10021: PPUSH
10022: CALL_OW 250
10026: PPUSH
10027: LD_VAR 0 2
10031: PPUSH
10032: CALL_OW 251
10036: PPUSH
10037: LD_INT 3
10039: PPUSH
10040: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10044: LD_VAR 0 2
10048: PPUSH
10049: CALL_OW 250
10053: PPUSH
10054: LD_VAR 0 2
10058: PPUSH
10059: CALL_OW 251
10063: PPUSH
10064: LD_INT 3
10066: PPUSH
10067: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10071: LD_VAR 0 2
10075: PPUSH
10076: CALL_OW 250
10080: PPUSH
10081: LD_VAR 0 2
10085: PPUSH
10086: CALL_OW 251
10090: PPUSH
10091: LD_INT 3
10093: PPUSH
10094: CALL_OW 453
// end ; end ;
10098: PPOPN 4
10100: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
10101: LD_VAR 0 1
10105: PPUSH
10106: LD_VAR 0 2
10110: PPUSH
10111: LD_VAR 0 3
10115: PPUSH
10116: CALL 21945 0 3
// end ;
10120: PPOPN 3
10122: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10123: LD_VAR 0 1
10127: PPUSH
10128: CALL 21953 0 1
// end ; end_of_file
10132: PPOPN 1
10134: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
10135: LD_INT 0
10137: PPUSH
10138: PPUSH
10139: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
10140: LD_ADDR_VAR 0 7
10144: PUSH
10145: LD_VAR 0 1
10149: PUSH
10150: LD_VAR 0 2
10154: ARRAY
10155: PPUSH
10156: LD_VAR 0 3
10160: PPUSH
10161: LD_VAR 0 4
10165: PPUSH
10166: CALL_OW 1
10170: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
10171: LD_ADDR_VAR 0 1
10175: PUSH
10176: LD_VAR 0 1
10180: PPUSH
10181: LD_VAR 0 2
10185: PPUSH
10186: LD_VAR 0 7
10190: PPUSH
10191: CALL_OW 1
10195: ST_TO_ADDR
// result := tab ;
10196: LD_ADDR_VAR 0 5
10200: PUSH
10201: LD_VAR 0 1
10205: ST_TO_ADDR
// end ;
10206: LD_VAR 0 5
10210: RET
// export function IsDriver ( unit ) ; begin
10211: LD_INT 0
10213: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
10214: LD_VAR 0 1
10218: PUSH
10219: LD_INT 55
10221: PUSH
10222: EMPTY
10223: LIST
10224: PPUSH
10225: CALL_OW 69
10229: IN
10230: IFFALSE 10249
// result := IsInUnit ( unit ) else
10232: LD_ADDR_VAR 0 2
10236: PUSH
10237: LD_VAR 0 1
10241: PPUSH
10242: CALL_OW 310
10246: ST_TO_ADDR
10247: GO 10257
// result := false ;
10249: LD_ADDR_VAR 0 2
10253: PUSH
10254: LD_INT 0
10256: ST_TO_ADDR
// end ;
10257: LD_VAR 0 2
10261: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
10262: LD_INT 0
10264: PPUSH
10265: PPUSH
10266: PPUSH
// if not GetControl ( veh ) = control_manual then
10267: LD_VAR 0 1
10271: PPUSH
10272: CALL_OW 263
10276: PUSH
10277: LD_INT 1
10279: EQUAL
10280: NOT
10281: IFFALSE 10293
// result := false else
10283: LD_ADDR_VAR 0 2
10287: PUSH
10288: LD_INT 0
10290: ST_TO_ADDR
10291: GO 10438
// if veh in FilterAllUnits ( [ f_empty ] ) then
10293: LD_VAR 0 1
10297: PUSH
10298: LD_INT 58
10300: PUSH
10301: EMPTY
10302: LIST
10303: PPUSH
10304: CALL_OW 69
10308: IN
10309: IFFALSE 10321
// result := false else
10311: LD_ADDR_VAR 0 2
10315: PUSH
10316: LD_INT 0
10318: ST_TO_ADDR
10319: GO 10438
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
10321: LD_ADDR_VAR 0 4
10325: PUSH
10326: LD_INT 22
10328: PUSH
10329: LD_VAR 0 1
10333: PPUSH
10334: CALL_OW 255
10338: PUSH
10339: EMPTY
10340: LIST
10341: LIST
10342: PUSH
10343: LD_INT 55
10345: PUSH
10346: EMPTY
10347: LIST
10348: PUSH
10349: EMPTY
10350: LIST
10351: LIST
10352: PPUSH
10353: CALL_OW 69
10357: ST_TO_ADDR
// if not filter then
10358: LD_VAR 0 4
10362: NOT
10363: IFFALSE 10375
// result := false else
10365: LD_ADDR_VAR 0 2
10369: PUSH
10370: LD_INT 0
10372: ST_TO_ADDR
10373: GO 10438
// for i = 1 to filter do
10375: LD_ADDR_VAR 0 3
10379: PUSH
10380: DOUBLE
10381: LD_INT 1
10383: DEC
10384: ST_TO_ADDR
10385: LD_VAR 0 4
10389: PUSH
10390: FOR_TO
10391: IFFALSE 10436
// if IsDriver ( filter [ i ] ) = veh then
10393: LD_VAR 0 4
10397: PUSH
10398: LD_VAR 0 3
10402: ARRAY
10403: PPUSH
10404: CALL 10211 0 1
10408: PUSH
10409: LD_VAR 0 1
10413: EQUAL
10414: IFFALSE 10434
// begin result := filter [ i ] ;
10416: LD_ADDR_VAR 0 2
10420: PUSH
10421: LD_VAR 0 4
10425: PUSH
10426: LD_VAR 0 3
10430: ARRAY
10431: ST_TO_ADDR
// break ;
10432: GO 10436
// end ;
10434: GO 10390
10436: POP
10437: POP
// end ; end ;
10438: LD_VAR 0 2
10442: RET
// export function FindTarget ( unit ) ; begin
10443: LD_INT 0
10445: PPUSH
// result := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ;
10446: LD_ADDR_VAR 0 2
10450: PUSH
10451: LD_INT 81
10453: PUSH
10454: LD_VAR 0 1
10458: PPUSH
10459: CALL_OW 255
10463: PUSH
10464: EMPTY
10465: LIST
10466: LIST
10467: PPUSH
10468: CALL_OW 69
10472: PPUSH
10473: LD_VAR 0 1
10477: PPUSH
10478: CALL_OW 74
10482: ST_TO_ADDR
// end ;
10483: LD_VAR 0 2
10487: RET
// export function NearestUnit ( unit ) ; begin
10488: LD_INT 0
10490: PPUSH
// result := NearestUnitToUnit ( all_units diff unit , unit ) ;
10491: LD_ADDR_VAR 0 2
10495: PUSH
10496: LD_OWVAR 3
10500: PUSH
10501: LD_VAR 0 1
10505: DIFF
10506: PPUSH
10507: LD_VAR 0 1
10511: PPUSH
10512: CALL_OW 74
10516: ST_TO_ADDR
// end ; end_of_file
10517: LD_VAR 0 2
10521: RET
// every 12 12$00 do
10522: GO 10524
10524: DISABLE
// begin SetWeather ( 1 , 570 , 350 ) ;
10525: LD_INT 1
10527: PPUSH
10528: LD_INT 570
10530: PPUSH
10531: LD_INT 350
10533: PPUSH
10534: CALL_OW 550
// Wait ( Rand ( 5 5$00 , 10 10$00 ) ) ;
10538: LD_INT 10500
10540: PPUSH
10541: LD_INT 21000
10543: PPUSH
10544: CALL_OW 12
10548: PPUSH
10549: CALL_OW 67
// SetWeather ( 0 , 570 , 350 ) ;
10553: LD_INT 0
10555: PPUSH
10556: LD_INT 570
10558: PPUSH
10559: LD_INT 350
10561: PPUSH
10562: CALL_OW 550
// end ;
10566: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
10567: LD_INT 0
10569: PPUSH
10570: PPUSH
10571: PPUSH
10572: PPUSH
10573: PPUSH
// uc_nation = nation_nature ;
10574: LD_ADDR_OWVAR 21
10578: PUSH
10579: LD_INT 0
10581: ST_TO_ADDR
// uc_side = 0 ;
10582: LD_ADDR_OWVAR 20
10586: PUSH
10587: LD_INT 0
10589: ST_TO_ADDR
// l = 0 ;
10590: LD_ADDR_VAR 0 6
10594: PUSH
10595: LD_INT 0
10597: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
10598: LD_ADDR_OWVAR 24
10602: PUSH
10603: LD_INT 0
10605: PPUSH
10606: LD_INT 5
10608: PPUSH
10609: CALL_OW 12
10613: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
10614: LD_ADDR_OWVAR 35
10618: PUSH
10619: LD_INT 5
10621: NEG
10622: PPUSH
10623: LD_INT 5
10625: PPUSH
10626: CALL_OW 12
10630: ST_TO_ADDR
// hc_gallery =  ;
10631: LD_ADDR_OWVAR 33
10635: PUSH
10636: LD_STRING 
10638: ST_TO_ADDR
// hc_class = class_apeman ;
10639: LD_ADDR_OWVAR 28
10643: PUSH
10644: LD_INT 12
10646: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
10647: LD_ADDR_OWVAR 29
10651: PUSH
10652: LD_INT 11
10654: PPUSH
10655: LD_INT 13
10657: PPUSH
10658: CALL_OW 12
10662: PUSH
10663: LD_INT 10
10665: PPUSH
10666: LD_INT 11
10668: PPUSH
10669: CALL_OW 12
10673: PUSH
10674: EMPTY
10675: LIST
10676: LIST
10677: ST_TO_ADDR
// hc_sex = sex_male ;
10678: LD_ADDR_OWVAR 27
10682: PUSH
10683: LD_INT 1
10685: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
10686: LD_ADDR_OWVAR 31
10690: PUSH
10691: LD_INT 0
10693: PPUSH
10694: LD_INT 2
10696: PPUSH
10697: CALL_OW 12
10701: PUSH
10702: LD_INT 0
10704: PUSH
10705: LD_INT 0
10707: PUSH
10708: LD_INT 0
10710: PUSH
10711: EMPTY
10712: LIST
10713: LIST
10714: LIST
10715: LIST
10716: ST_TO_ADDR
// apeman = CreateHuman ;
10717: LD_ADDR_VAR 0 7
10721: PUSH
10722: CALL_OW 44
10726: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
10727: LD_VAR 0 7
10731: PPUSH
10732: LD_VAR 0 4
10736: PPUSH
10737: LD_INT 0
10739: PPUSH
10740: CALL_OW 49
// l = l + 1 ;
10744: LD_ADDR_VAR 0 6
10748: PUSH
10749: LD_VAR 0 6
10753: PUSH
10754: LD_INT 1
10756: PLUS
10757: ST_TO_ADDR
// end until l = num1 ;
10758: LD_VAR 0 6
10762: PUSH
10763: LD_VAR 0 1
10767: EQUAL
10768: IFFALSE 10598
// l = 0 ;
10770: LD_ADDR_VAR 0 6
10774: PUSH
10775: LD_INT 0
10777: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
10778: LD_ADDR_OWVAR 35
10782: PUSH
10783: LD_INT 0
10785: PPUSH
10786: LD_INT 25
10788: PPUSH
10789: CALL_OW 12
10793: ST_TO_ADDR
// hc_class = class_tiger ;
10794: LD_ADDR_OWVAR 28
10798: PUSH
10799: LD_INT 14
10801: ST_TO_ADDR
// hc_sex = sex_male ;
10802: LD_ADDR_OWVAR 27
10806: PUSH
10807: LD_INT 1
10809: ST_TO_ADDR
// hc_gallery = sandnature ;
10810: LD_ADDR_OWVAR 33
10814: PUSH
10815: LD_STRING sandnature
10817: ST_TO_ADDR
// hc_face_number = 3 ;
10818: LD_ADDR_OWVAR 34
10822: PUSH
10823: LD_INT 3
10825: ST_TO_ADDR
// tiger = CreateHuman ;
10826: LD_ADDR_VAR 0 8
10830: PUSH
10831: CALL_OW 44
10835: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10836: LD_VAR 0 8
10840: PPUSH
10841: LD_VAR 0 4
10845: PPUSH
10846: LD_INT 0
10848: PPUSH
10849: CALL_OW 49
// l = l + 1 ;
10853: LD_ADDR_VAR 0 6
10857: PUSH
10858: LD_VAR 0 6
10862: PUSH
10863: LD_INT 1
10865: PLUS
10866: ST_TO_ADDR
// end until l = num2 ;
10867: LD_VAR 0 6
10871: PUSH
10872: LD_VAR 0 2
10876: EQUAL
10877: IFFALSE 10778
// l = 0 ;
10879: LD_ADDR_VAR 0 6
10883: PUSH
10884: LD_INT 0
10886: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
10887: LD_ADDR_OWVAR 28
10891: PUSH
10892: LD_INT 18
10894: ST_TO_ADDR
// hc_gallery = sandnature ;
10895: LD_ADDR_OWVAR 33
10899: PUSH
10900: LD_STRING sandnature
10902: ST_TO_ADDR
// hc_face_number = 1 ;
10903: LD_ADDR_OWVAR 34
10907: PUSH
10908: LD_INT 1
10910: ST_TO_ADDR
// bird = CreateHuman ;
10911: LD_ADDR_VAR 0 9
10915: PUSH
10916: CALL_OW 44
10920: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
10921: LD_VAR 0 9
10925: PPUSH
10926: LD_INT 0
10928: PPUSH
10929: CALL_OW 51
// l = l + 1 ;
10933: LD_ADDR_VAR 0 6
10937: PUSH
10938: LD_VAR 0 6
10942: PUSH
10943: LD_INT 1
10945: PLUS
10946: ST_TO_ADDR
// end until l = num3 ;
10947: LD_VAR 0 6
10951: PUSH
10952: LD_VAR 0 3
10956: EQUAL
10957: IFFALSE 10887
// end ; end_of_file
10959: LD_VAR 0 5
10963: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
10964: GO 10966
10966: DISABLE
// begin ru_radar := 98 ;
10967: LD_ADDR_EXP 25
10971: PUSH
10972: LD_INT 98
10974: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
10975: LD_ADDR_EXP 26
10979: PUSH
10980: LD_INT 89
10982: ST_TO_ADDR
// us_hack := 99 ;
10983: LD_ADDR_EXP 27
10987: PUSH
10988: LD_INT 99
10990: ST_TO_ADDR
// us_artillery := 97 ;
10991: LD_ADDR_EXP 28
10995: PUSH
10996: LD_INT 97
10998: ST_TO_ADDR
// ar_bio_bomb := 91 ;
10999: LD_ADDR_EXP 29
11003: PUSH
11004: LD_INT 91
11006: ST_TO_ADDR
// end ; end_of_file end_of_file
11007: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
11008: GO 11010
11010: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
11011: LD_STRING initStreamRollete();
11013: PPUSH
11014: CALL_OW 559
// InitStreamMode ;
11018: CALL 11027 0 0
// DefineStreamItems ( ) ;
11022: CALL 11467 0 0
// end ;
11026: END
// function InitStreamMode ; begin
11027: LD_INT 0
11029: PPUSH
// streamModeActive := false ;
11030: LD_ADDR_EXP 30
11034: PUSH
11035: LD_INT 0
11037: ST_TO_ADDR
// normalCounter := 36 ;
11038: LD_ADDR_EXP 31
11042: PUSH
11043: LD_INT 36
11045: ST_TO_ADDR
// hardcoreCounter := 16 ;
11046: LD_ADDR_EXP 32
11050: PUSH
11051: LD_INT 16
11053: ST_TO_ADDR
// sRocket := false ;
11054: LD_ADDR_EXP 35
11058: PUSH
11059: LD_INT 0
11061: ST_TO_ADDR
// sSpeed := false ;
11062: LD_ADDR_EXP 34
11066: PUSH
11067: LD_INT 0
11069: ST_TO_ADDR
// sEngine := false ;
11070: LD_ADDR_EXP 36
11074: PUSH
11075: LD_INT 0
11077: ST_TO_ADDR
// sSpec := false ;
11078: LD_ADDR_EXP 33
11082: PUSH
11083: LD_INT 0
11085: ST_TO_ADDR
// sLevel := false ;
11086: LD_ADDR_EXP 37
11090: PUSH
11091: LD_INT 0
11093: ST_TO_ADDR
// sArmoury := false ;
11094: LD_ADDR_EXP 38
11098: PUSH
11099: LD_INT 0
11101: ST_TO_ADDR
// sRadar := false ;
11102: LD_ADDR_EXP 39
11106: PUSH
11107: LD_INT 0
11109: ST_TO_ADDR
// sBunker := false ;
11110: LD_ADDR_EXP 40
11114: PUSH
11115: LD_INT 0
11117: ST_TO_ADDR
// sHack := false ;
11118: LD_ADDR_EXP 41
11122: PUSH
11123: LD_INT 0
11125: ST_TO_ADDR
// sFire := false ;
11126: LD_ADDR_EXP 42
11130: PUSH
11131: LD_INT 0
11133: ST_TO_ADDR
// sRefresh := false ;
11134: LD_ADDR_EXP 43
11138: PUSH
11139: LD_INT 0
11141: ST_TO_ADDR
// sExp := false ;
11142: LD_ADDR_EXP 44
11146: PUSH
11147: LD_INT 0
11149: ST_TO_ADDR
// sDepot := false ;
11150: LD_ADDR_EXP 45
11154: PUSH
11155: LD_INT 0
11157: ST_TO_ADDR
// sFlag := false ;
11158: LD_ADDR_EXP 46
11162: PUSH
11163: LD_INT 0
11165: ST_TO_ADDR
// sKamikadze := false ;
11166: LD_ADDR_EXP 54
11170: PUSH
11171: LD_INT 0
11173: ST_TO_ADDR
// sTroll := false ;
11174: LD_ADDR_EXP 55
11178: PUSH
11179: LD_INT 0
11181: ST_TO_ADDR
// sSlow := false ;
11182: LD_ADDR_EXP 56
11186: PUSH
11187: LD_INT 0
11189: ST_TO_ADDR
// sLack := false ;
11190: LD_ADDR_EXP 57
11194: PUSH
11195: LD_INT 0
11197: ST_TO_ADDR
// sTank := false ;
11198: LD_ADDR_EXP 59
11202: PUSH
11203: LD_INT 0
11205: ST_TO_ADDR
// sRemote := false ;
11206: LD_ADDR_EXP 60
11210: PUSH
11211: LD_INT 0
11213: ST_TO_ADDR
// sPowell := false ;
11214: LD_ADDR_EXP 61
11218: PUSH
11219: LD_INT 0
11221: ST_TO_ADDR
// sTeleport := false ;
11222: LD_ADDR_EXP 64
11226: PUSH
11227: LD_INT 0
11229: ST_TO_ADDR
// sOilTower := false ;
11230: LD_ADDR_EXP 66
11234: PUSH
11235: LD_INT 0
11237: ST_TO_ADDR
// sShovel := false ;
11238: LD_ADDR_EXP 67
11242: PUSH
11243: LD_INT 0
11245: ST_TO_ADDR
// sSheik := false ;
11246: LD_ADDR_EXP 68
11250: PUSH
11251: LD_INT 0
11253: ST_TO_ADDR
// sEarthquake := false ;
11254: LD_ADDR_EXP 70
11258: PUSH
11259: LD_INT 0
11261: ST_TO_ADDR
// sAI := false ;
11262: LD_ADDR_EXP 71
11266: PUSH
11267: LD_INT 0
11269: ST_TO_ADDR
// sCargo := false ;
11270: LD_ADDR_EXP 74
11274: PUSH
11275: LD_INT 0
11277: ST_TO_ADDR
// sDLaser := false ;
11278: LD_ADDR_EXP 75
11282: PUSH
11283: LD_INT 0
11285: ST_TO_ADDR
// sExchange := false ;
11286: LD_ADDR_EXP 76
11290: PUSH
11291: LD_INT 0
11293: ST_TO_ADDR
// sFac := false ;
11294: LD_ADDR_EXP 77
11298: PUSH
11299: LD_INT 0
11301: ST_TO_ADDR
// sPower := false ;
11302: LD_ADDR_EXP 78
11306: PUSH
11307: LD_INT 0
11309: ST_TO_ADDR
// sRandom := false ;
11310: LD_ADDR_EXP 79
11314: PUSH
11315: LD_INT 0
11317: ST_TO_ADDR
// sShield := false ;
11318: LD_ADDR_EXP 80
11322: PUSH
11323: LD_INT 0
11325: ST_TO_ADDR
// sTime := false ;
11326: LD_ADDR_EXP 81
11330: PUSH
11331: LD_INT 0
11333: ST_TO_ADDR
// sTools := false ;
11334: LD_ADDR_EXP 82
11338: PUSH
11339: LD_INT 0
11341: ST_TO_ADDR
// sSold := false ;
11342: LD_ADDR_EXP 47
11346: PUSH
11347: LD_INT 0
11349: ST_TO_ADDR
// sDiff := false ;
11350: LD_ADDR_EXP 48
11354: PUSH
11355: LD_INT 0
11357: ST_TO_ADDR
// sFog := false ;
11358: LD_ADDR_EXP 51
11362: PUSH
11363: LD_INT 0
11365: ST_TO_ADDR
// sReset := false ;
11366: LD_ADDR_EXP 52
11370: PUSH
11371: LD_INT 0
11373: ST_TO_ADDR
// sSun := false ;
11374: LD_ADDR_EXP 53
11378: PUSH
11379: LD_INT 0
11381: ST_TO_ADDR
// sTiger := false ;
11382: LD_ADDR_EXP 49
11386: PUSH
11387: LD_INT 0
11389: ST_TO_ADDR
// sBomb := false ;
11390: LD_ADDR_EXP 50
11394: PUSH
11395: LD_INT 0
11397: ST_TO_ADDR
// sWound := false ;
11398: LD_ADDR_EXP 58
11402: PUSH
11403: LD_INT 0
11405: ST_TO_ADDR
// sBetray := false ;
11406: LD_ADDR_EXP 62
11410: PUSH
11411: LD_INT 0
11413: ST_TO_ADDR
// sContamin := false ;
11414: LD_ADDR_EXP 63
11418: PUSH
11419: LD_INT 0
11421: ST_TO_ADDR
// sOil := false ;
11422: LD_ADDR_EXP 65
11426: PUSH
11427: LD_INT 0
11429: ST_TO_ADDR
// sStu := false ;
11430: LD_ADDR_EXP 69
11434: PUSH
11435: LD_INT 0
11437: ST_TO_ADDR
// sBazooka := false ;
11438: LD_ADDR_EXP 72
11442: PUSH
11443: LD_INT 0
11445: ST_TO_ADDR
// sMortar := false ;
11446: LD_ADDR_EXP 73
11450: PUSH
11451: LD_INT 0
11453: ST_TO_ADDR
// sRanger := false ;
11454: LD_ADDR_EXP 83
11458: PUSH
11459: LD_INT 0
11461: ST_TO_ADDR
// end ;
11462: LD_VAR 0 1
11466: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
11467: LD_INT 0
11469: PPUSH
11470: PPUSH
11471: PPUSH
11472: PPUSH
11473: PPUSH
// result := [ ] ;
11474: LD_ADDR_VAR 0 1
11478: PUSH
11479: EMPTY
11480: ST_TO_ADDR
// if campaign_id = 1 then
11481: LD_OWVAR 69
11485: PUSH
11486: LD_INT 1
11488: EQUAL
11489: IFFALSE 14427
// begin case mission_number of 1 :
11491: LD_OWVAR 70
11495: PUSH
11496: LD_INT 1
11498: DOUBLE
11499: EQUAL
11500: IFTRUE 11504
11502: GO 11568
11504: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
11505: LD_ADDR_VAR 0 1
11509: PUSH
11510: LD_INT 2
11512: PUSH
11513: LD_INT 4
11515: PUSH
11516: LD_INT 11
11518: PUSH
11519: LD_INT 12
11521: PUSH
11522: LD_INT 15
11524: PUSH
11525: LD_INT 16
11527: PUSH
11528: LD_INT 22
11530: PUSH
11531: LD_INT 23
11533: PUSH
11534: LD_INT 26
11536: PUSH
11537: EMPTY
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: PUSH
11548: LD_INT 101
11550: PUSH
11551: LD_INT 102
11553: PUSH
11554: LD_INT 106
11556: PUSH
11557: EMPTY
11558: LIST
11559: LIST
11560: LIST
11561: PUSH
11562: EMPTY
11563: LIST
11564: LIST
11565: ST_TO_ADDR
11566: GO 14425
11568: LD_INT 2
11570: DOUBLE
11571: EQUAL
11572: IFTRUE 11576
11574: GO 11648
11576: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
11577: LD_ADDR_VAR 0 1
11581: PUSH
11582: LD_INT 2
11584: PUSH
11585: LD_INT 4
11587: PUSH
11588: LD_INT 11
11590: PUSH
11591: LD_INT 12
11593: PUSH
11594: LD_INT 15
11596: PUSH
11597: LD_INT 16
11599: PUSH
11600: LD_INT 22
11602: PUSH
11603: LD_INT 23
11605: PUSH
11606: LD_INT 26
11608: PUSH
11609: EMPTY
11610: LIST
11611: LIST
11612: LIST
11613: LIST
11614: LIST
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: PUSH
11620: LD_INT 101
11622: PUSH
11623: LD_INT 102
11625: PUSH
11626: LD_INT 105
11628: PUSH
11629: LD_INT 106
11631: PUSH
11632: LD_INT 108
11634: PUSH
11635: EMPTY
11636: LIST
11637: LIST
11638: LIST
11639: LIST
11640: LIST
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: ST_TO_ADDR
11646: GO 14425
11648: LD_INT 3
11650: DOUBLE
11651: EQUAL
11652: IFTRUE 11656
11654: GO 11732
11656: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
11657: LD_ADDR_VAR 0 1
11661: PUSH
11662: LD_INT 2
11664: PUSH
11665: LD_INT 4
11667: PUSH
11668: LD_INT 5
11670: PUSH
11671: LD_INT 11
11673: PUSH
11674: LD_INT 12
11676: PUSH
11677: LD_INT 15
11679: PUSH
11680: LD_INT 16
11682: PUSH
11683: LD_INT 22
11685: PUSH
11686: LD_INT 26
11688: PUSH
11689: LD_INT 36
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: LIST
11696: LIST
11697: LIST
11698: LIST
11699: LIST
11700: LIST
11701: LIST
11702: LIST
11703: PUSH
11704: LD_INT 101
11706: PUSH
11707: LD_INT 102
11709: PUSH
11710: LD_INT 105
11712: PUSH
11713: LD_INT 106
11715: PUSH
11716: LD_INT 108
11718: PUSH
11719: EMPTY
11720: LIST
11721: LIST
11722: LIST
11723: LIST
11724: LIST
11725: PUSH
11726: EMPTY
11727: LIST
11728: LIST
11729: ST_TO_ADDR
11730: GO 14425
11732: LD_INT 4
11734: DOUBLE
11735: EQUAL
11736: IFTRUE 11740
11738: GO 11824
11740: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
11741: LD_ADDR_VAR 0 1
11745: PUSH
11746: LD_INT 2
11748: PUSH
11749: LD_INT 4
11751: PUSH
11752: LD_INT 5
11754: PUSH
11755: LD_INT 8
11757: PUSH
11758: LD_INT 11
11760: PUSH
11761: LD_INT 12
11763: PUSH
11764: LD_INT 15
11766: PUSH
11767: LD_INT 16
11769: PUSH
11770: LD_INT 22
11772: PUSH
11773: LD_INT 23
11775: PUSH
11776: LD_INT 26
11778: PUSH
11779: LD_INT 36
11781: PUSH
11782: EMPTY
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: LIST
11792: LIST
11793: LIST
11794: LIST
11795: PUSH
11796: LD_INT 101
11798: PUSH
11799: LD_INT 102
11801: PUSH
11802: LD_INT 105
11804: PUSH
11805: LD_INT 106
11807: PUSH
11808: LD_INT 108
11810: PUSH
11811: EMPTY
11812: LIST
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: ST_TO_ADDR
11822: GO 14425
11824: LD_INT 5
11826: DOUBLE
11827: EQUAL
11828: IFTRUE 11832
11830: GO 11932
11832: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
11833: LD_ADDR_VAR 0 1
11837: PUSH
11838: LD_INT 2
11840: PUSH
11841: LD_INT 4
11843: PUSH
11844: LD_INT 5
11846: PUSH
11847: LD_INT 6
11849: PUSH
11850: LD_INT 8
11852: PUSH
11853: LD_INT 11
11855: PUSH
11856: LD_INT 12
11858: PUSH
11859: LD_INT 15
11861: PUSH
11862: LD_INT 16
11864: PUSH
11865: LD_INT 22
11867: PUSH
11868: LD_INT 23
11870: PUSH
11871: LD_INT 25
11873: PUSH
11874: LD_INT 26
11876: PUSH
11877: LD_INT 36
11879: PUSH
11880: EMPTY
11881: LIST
11882: LIST
11883: LIST
11884: LIST
11885: LIST
11886: LIST
11887: LIST
11888: LIST
11889: LIST
11890: LIST
11891: LIST
11892: LIST
11893: LIST
11894: LIST
11895: PUSH
11896: LD_INT 101
11898: PUSH
11899: LD_INT 102
11901: PUSH
11902: LD_INT 105
11904: PUSH
11905: LD_INT 106
11907: PUSH
11908: LD_INT 108
11910: PUSH
11911: LD_INT 109
11913: PUSH
11914: LD_INT 112
11916: PUSH
11917: EMPTY
11918: LIST
11919: LIST
11920: LIST
11921: LIST
11922: LIST
11923: LIST
11924: LIST
11925: PUSH
11926: EMPTY
11927: LIST
11928: LIST
11929: ST_TO_ADDR
11930: GO 14425
11932: LD_INT 6
11934: DOUBLE
11935: EQUAL
11936: IFTRUE 11940
11938: GO 12060
11940: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
11941: LD_ADDR_VAR 0 1
11945: PUSH
11946: LD_INT 2
11948: PUSH
11949: LD_INT 4
11951: PUSH
11952: LD_INT 5
11954: PUSH
11955: LD_INT 6
11957: PUSH
11958: LD_INT 8
11960: PUSH
11961: LD_INT 11
11963: PUSH
11964: LD_INT 12
11966: PUSH
11967: LD_INT 15
11969: PUSH
11970: LD_INT 16
11972: PUSH
11973: LD_INT 20
11975: PUSH
11976: LD_INT 21
11978: PUSH
11979: LD_INT 22
11981: PUSH
11982: LD_INT 23
11984: PUSH
11985: LD_INT 25
11987: PUSH
11988: LD_INT 26
11990: PUSH
11991: LD_INT 30
11993: PUSH
11994: LD_INT 31
11996: PUSH
11997: LD_INT 32
11999: PUSH
12000: LD_INT 36
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: LIST
12016: LIST
12017: LIST
12018: LIST
12019: LIST
12020: LIST
12021: LIST
12022: LIST
12023: PUSH
12024: LD_INT 101
12026: PUSH
12027: LD_INT 102
12029: PUSH
12030: LD_INT 105
12032: PUSH
12033: LD_INT 106
12035: PUSH
12036: LD_INT 108
12038: PUSH
12039: LD_INT 109
12041: PUSH
12042: LD_INT 112
12044: PUSH
12045: EMPTY
12046: LIST
12047: LIST
12048: LIST
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: PUSH
12054: EMPTY
12055: LIST
12056: LIST
12057: ST_TO_ADDR
12058: GO 14425
12060: LD_INT 7
12062: DOUBLE
12063: EQUAL
12064: IFTRUE 12068
12066: GO 12168
12068: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
12069: LD_ADDR_VAR 0 1
12073: PUSH
12074: LD_INT 2
12076: PUSH
12077: LD_INT 4
12079: PUSH
12080: LD_INT 5
12082: PUSH
12083: LD_INT 7
12085: PUSH
12086: LD_INT 11
12088: PUSH
12089: LD_INT 12
12091: PUSH
12092: LD_INT 15
12094: PUSH
12095: LD_INT 16
12097: PUSH
12098: LD_INT 20
12100: PUSH
12101: LD_INT 21
12103: PUSH
12104: LD_INT 22
12106: PUSH
12107: LD_INT 23
12109: PUSH
12110: LD_INT 25
12112: PUSH
12113: LD_INT 26
12115: PUSH
12116: EMPTY
12117: LIST
12118: LIST
12119: LIST
12120: LIST
12121: LIST
12122: LIST
12123: LIST
12124: LIST
12125: LIST
12126: LIST
12127: LIST
12128: LIST
12129: LIST
12130: LIST
12131: PUSH
12132: LD_INT 101
12134: PUSH
12135: LD_INT 102
12137: PUSH
12138: LD_INT 103
12140: PUSH
12141: LD_INT 105
12143: PUSH
12144: LD_INT 106
12146: PUSH
12147: LD_INT 108
12149: PUSH
12150: LD_INT 112
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: LIST
12157: LIST
12158: LIST
12159: LIST
12160: LIST
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: ST_TO_ADDR
12166: GO 14425
12168: LD_INT 8
12170: DOUBLE
12171: EQUAL
12172: IFTRUE 12176
12174: GO 12304
12176: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
12177: LD_ADDR_VAR 0 1
12181: PUSH
12182: LD_INT 2
12184: PUSH
12185: LD_INT 4
12187: PUSH
12188: LD_INT 5
12190: PUSH
12191: LD_INT 6
12193: PUSH
12194: LD_INT 7
12196: PUSH
12197: LD_INT 8
12199: PUSH
12200: LD_INT 11
12202: PUSH
12203: LD_INT 12
12205: PUSH
12206: LD_INT 15
12208: PUSH
12209: LD_INT 16
12211: PUSH
12212: LD_INT 20
12214: PUSH
12215: LD_INT 21
12217: PUSH
12218: LD_INT 22
12220: PUSH
12221: LD_INT 23
12223: PUSH
12224: LD_INT 25
12226: PUSH
12227: LD_INT 26
12229: PUSH
12230: LD_INT 30
12232: PUSH
12233: LD_INT 31
12235: PUSH
12236: LD_INT 32
12238: PUSH
12239: LD_INT 36
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: LIST
12246: LIST
12247: LIST
12248: LIST
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: LIST
12262: LIST
12263: PUSH
12264: LD_INT 101
12266: PUSH
12267: LD_INT 102
12269: PUSH
12270: LD_INT 103
12272: PUSH
12273: LD_INT 105
12275: PUSH
12276: LD_INT 106
12278: PUSH
12279: LD_INT 108
12281: PUSH
12282: LD_INT 109
12284: PUSH
12285: LD_INT 112
12287: PUSH
12288: EMPTY
12289: LIST
12290: LIST
12291: LIST
12292: LIST
12293: LIST
12294: LIST
12295: LIST
12296: LIST
12297: PUSH
12298: EMPTY
12299: LIST
12300: LIST
12301: ST_TO_ADDR
12302: GO 14425
12304: LD_INT 9
12306: DOUBLE
12307: EQUAL
12308: IFTRUE 12312
12310: GO 12448
12312: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
12313: LD_ADDR_VAR 0 1
12317: PUSH
12318: LD_INT 2
12320: PUSH
12321: LD_INT 4
12323: PUSH
12324: LD_INT 5
12326: PUSH
12327: LD_INT 6
12329: PUSH
12330: LD_INT 7
12332: PUSH
12333: LD_INT 8
12335: PUSH
12336: LD_INT 11
12338: PUSH
12339: LD_INT 12
12341: PUSH
12342: LD_INT 15
12344: PUSH
12345: LD_INT 16
12347: PUSH
12348: LD_INT 20
12350: PUSH
12351: LD_INT 21
12353: PUSH
12354: LD_INT 22
12356: PUSH
12357: LD_INT 23
12359: PUSH
12360: LD_INT 25
12362: PUSH
12363: LD_INT 26
12365: PUSH
12366: LD_INT 28
12368: PUSH
12369: LD_INT 30
12371: PUSH
12372: LD_INT 31
12374: PUSH
12375: LD_INT 32
12377: PUSH
12378: LD_INT 36
12380: PUSH
12381: EMPTY
12382: LIST
12383: LIST
12384: LIST
12385: LIST
12386: LIST
12387: LIST
12388: LIST
12389: LIST
12390: LIST
12391: LIST
12392: LIST
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: LIST
12401: LIST
12402: LIST
12403: PUSH
12404: LD_INT 101
12406: PUSH
12407: LD_INT 102
12409: PUSH
12410: LD_INT 103
12412: PUSH
12413: LD_INT 105
12415: PUSH
12416: LD_INT 106
12418: PUSH
12419: LD_INT 108
12421: PUSH
12422: LD_INT 109
12424: PUSH
12425: LD_INT 112
12427: PUSH
12428: LD_INT 114
12430: PUSH
12431: EMPTY
12432: LIST
12433: LIST
12434: LIST
12435: LIST
12436: LIST
12437: LIST
12438: LIST
12439: LIST
12440: LIST
12441: PUSH
12442: EMPTY
12443: LIST
12444: LIST
12445: ST_TO_ADDR
12446: GO 14425
12448: LD_INT 10
12450: DOUBLE
12451: EQUAL
12452: IFTRUE 12456
12454: GO 12640
12456: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
12457: LD_ADDR_VAR 0 1
12461: PUSH
12462: LD_INT 2
12464: PUSH
12465: LD_INT 4
12467: PUSH
12468: LD_INT 5
12470: PUSH
12471: LD_INT 6
12473: PUSH
12474: LD_INT 7
12476: PUSH
12477: LD_INT 8
12479: PUSH
12480: LD_INT 9
12482: PUSH
12483: LD_INT 10
12485: PUSH
12486: LD_INT 11
12488: PUSH
12489: LD_INT 12
12491: PUSH
12492: LD_INT 13
12494: PUSH
12495: LD_INT 14
12497: PUSH
12498: LD_INT 15
12500: PUSH
12501: LD_INT 16
12503: PUSH
12504: LD_INT 17
12506: PUSH
12507: LD_INT 18
12509: PUSH
12510: LD_INT 19
12512: PUSH
12513: LD_INT 20
12515: PUSH
12516: LD_INT 21
12518: PUSH
12519: LD_INT 22
12521: PUSH
12522: LD_INT 23
12524: PUSH
12525: LD_INT 24
12527: PUSH
12528: LD_INT 25
12530: PUSH
12531: LD_INT 26
12533: PUSH
12534: LD_INT 28
12536: PUSH
12537: LD_INT 30
12539: PUSH
12540: LD_INT 31
12542: PUSH
12543: LD_INT 32
12545: PUSH
12546: LD_INT 36
12548: PUSH
12549: EMPTY
12550: LIST
12551: LIST
12552: LIST
12553: LIST
12554: LIST
12555: LIST
12556: LIST
12557: LIST
12558: LIST
12559: LIST
12560: LIST
12561: LIST
12562: LIST
12563: LIST
12564: LIST
12565: LIST
12566: LIST
12567: LIST
12568: LIST
12569: LIST
12570: LIST
12571: LIST
12572: LIST
12573: LIST
12574: LIST
12575: LIST
12576: LIST
12577: LIST
12578: LIST
12579: PUSH
12580: LD_INT 101
12582: PUSH
12583: LD_INT 102
12585: PUSH
12586: LD_INT 103
12588: PUSH
12589: LD_INT 104
12591: PUSH
12592: LD_INT 105
12594: PUSH
12595: LD_INT 106
12597: PUSH
12598: LD_INT 107
12600: PUSH
12601: LD_INT 108
12603: PUSH
12604: LD_INT 109
12606: PUSH
12607: LD_INT 110
12609: PUSH
12610: LD_INT 111
12612: PUSH
12613: LD_INT 112
12615: PUSH
12616: LD_INT 114
12618: PUSH
12619: EMPTY
12620: LIST
12621: LIST
12622: LIST
12623: LIST
12624: LIST
12625: LIST
12626: LIST
12627: LIST
12628: LIST
12629: LIST
12630: LIST
12631: LIST
12632: LIST
12633: PUSH
12634: EMPTY
12635: LIST
12636: LIST
12637: ST_TO_ADDR
12638: GO 14425
12640: LD_INT 11
12642: DOUBLE
12643: EQUAL
12644: IFTRUE 12648
12646: GO 12840
12648: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
12649: LD_ADDR_VAR 0 1
12653: PUSH
12654: LD_INT 2
12656: PUSH
12657: LD_INT 3
12659: PUSH
12660: LD_INT 4
12662: PUSH
12663: LD_INT 5
12665: PUSH
12666: LD_INT 6
12668: PUSH
12669: LD_INT 7
12671: PUSH
12672: LD_INT 8
12674: PUSH
12675: LD_INT 9
12677: PUSH
12678: LD_INT 10
12680: PUSH
12681: LD_INT 11
12683: PUSH
12684: LD_INT 12
12686: PUSH
12687: LD_INT 13
12689: PUSH
12690: LD_INT 14
12692: PUSH
12693: LD_INT 15
12695: PUSH
12696: LD_INT 16
12698: PUSH
12699: LD_INT 17
12701: PUSH
12702: LD_INT 18
12704: PUSH
12705: LD_INT 19
12707: PUSH
12708: LD_INT 20
12710: PUSH
12711: LD_INT 21
12713: PUSH
12714: LD_INT 22
12716: PUSH
12717: LD_INT 23
12719: PUSH
12720: LD_INT 24
12722: PUSH
12723: LD_INT 25
12725: PUSH
12726: LD_INT 26
12728: PUSH
12729: LD_INT 28
12731: PUSH
12732: LD_INT 30
12734: PUSH
12735: LD_INT 31
12737: PUSH
12738: LD_INT 32
12740: PUSH
12741: LD_INT 34
12743: PUSH
12744: LD_INT 36
12746: PUSH
12747: EMPTY
12748: LIST
12749: LIST
12750: LIST
12751: LIST
12752: LIST
12753: LIST
12754: LIST
12755: LIST
12756: LIST
12757: LIST
12758: LIST
12759: LIST
12760: LIST
12761: LIST
12762: LIST
12763: LIST
12764: LIST
12765: LIST
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: LIST
12771: LIST
12772: LIST
12773: LIST
12774: LIST
12775: LIST
12776: LIST
12777: LIST
12778: LIST
12779: PUSH
12780: LD_INT 101
12782: PUSH
12783: LD_INT 102
12785: PUSH
12786: LD_INT 103
12788: PUSH
12789: LD_INT 104
12791: PUSH
12792: LD_INT 105
12794: PUSH
12795: LD_INT 106
12797: PUSH
12798: LD_INT 107
12800: PUSH
12801: LD_INT 108
12803: PUSH
12804: LD_INT 109
12806: PUSH
12807: LD_INT 110
12809: PUSH
12810: LD_INT 111
12812: PUSH
12813: LD_INT 112
12815: PUSH
12816: LD_INT 114
12818: PUSH
12819: EMPTY
12820: LIST
12821: LIST
12822: LIST
12823: LIST
12824: LIST
12825: LIST
12826: LIST
12827: LIST
12828: LIST
12829: LIST
12830: LIST
12831: LIST
12832: LIST
12833: PUSH
12834: EMPTY
12835: LIST
12836: LIST
12837: ST_TO_ADDR
12838: GO 14425
12840: LD_INT 12
12842: DOUBLE
12843: EQUAL
12844: IFTRUE 12848
12846: GO 13056
12848: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
12849: LD_ADDR_VAR 0 1
12853: PUSH
12854: LD_INT 1
12856: PUSH
12857: LD_INT 2
12859: PUSH
12860: LD_INT 3
12862: PUSH
12863: LD_INT 4
12865: PUSH
12866: LD_INT 5
12868: PUSH
12869: LD_INT 6
12871: PUSH
12872: LD_INT 7
12874: PUSH
12875: LD_INT 8
12877: PUSH
12878: LD_INT 9
12880: PUSH
12881: LD_INT 10
12883: PUSH
12884: LD_INT 11
12886: PUSH
12887: LD_INT 12
12889: PUSH
12890: LD_INT 13
12892: PUSH
12893: LD_INT 14
12895: PUSH
12896: LD_INT 15
12898: PUSH
12899: LD_INT 16
12901: PUSH
12902: LD_INT 17
12904: PUSH
12905: LD_INT 18
12907: PUSH
12908: LD_INT 19
12910: PUSH
12911: LD_INT 20
12913: PUSH
12914: LD_INT 21
12916: PUSH
12917: LD_INT 22
12919: PUSH
12920: LD_INT 23
12922: PUSH
12923: LD_INT 24
12925: PUSH
12926: LD_INT 25
12928: PUSH
12929: LD_INT 26
12931: PUSH
12932: LD_INT 27
12934: PUSH
12935: LD_INT 28
12937: PUSH
12938: LD_INT 30
12940: PUSH
12941: LD_INT 31
12943: PUSH
12944: LD_INT 32
12946: PUSH
12947: LD_INT 33
12949: PUSH
12950: LD_INT 34
12952: PUSH
12953: LD_INT 36
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: LIST
12964: LIST
12965: LIST
12966: LIST
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: LIST
12972: LIST
12973: LIST
12974: LIST
12975: LIST
12976: LIST
12977: LIST
12978: LIST
12979: LIST
12980: LIST
12981: LIST
12982: LIST
12983: LIST
12984: LIST
12985: LIST
12986: LIST
12987: LIST
12988: LIST
12989: LIST
12990: LIST
12991: PUSH
12992: LD_INT 101
12994: PUSH
12995: LD_INT 102
12997: PUSH
12998: LD_INT 103
13000: PUSH
13001: LD_INT 104
13003: PUSH
13004: LD_INT 105
13006: PUSH
13007: LD_INT 106
13009: PUSH
13010: LD_INT 107
13012: PUSH
13013: LD_INT 108
13015: PUSH
13016: LD_INT 109
13018: PUSH
13019: LD_INT 110
13021: PUSH
13022: LD_INT 111
13024: PUSH
13025: LD_INT 112
13027: PUSH
13028: LD_INT 113
13030: PUSH
13031: LD_INT 114
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: LIST
13038: LIST
13039: LIST
13040: LIST
13041: LIST
13042: LIST
13043: LIST
13044: LIST
13045: LIST
13046: LIST
13047: LIST
13048: LIST
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: ST_TO_ADDR
13054: GO 14425
13056: LD_INT 13
13058: DOUBLE
13059: EQUAL
13060: IFTRUE 13064
13062: GO 13260
13064: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
13065: LD_ADDR_VAR 0 1
13069: PUSH
13070: LD_INT 1
13072: PUSH
13073: LD_INT 2
13075: PUSH
13076: LD_INT 3
13078: PUSH
13079: LD_INT 4
13081: PUSH
13082: LD_INT 5
13084: PUSH
13085: LD_INT 8
13087: PUSH
13088: LD_INT 9
13090: PUSH
13091: LD_INT 10
13093: PUSH
13094: LD_INT 11
13096: PUSH
13097: LD_INT 12
13099: PUSH
13100: LD_INT 14
13102: PUSH
13103: LD_INT 15
13105: PUSH
13106: LD_INT 16
13108: PUSH
13109: LD_INT 17
13111: PUSH
13112: LD_INT 18
13114: PUSH
13115: LD_INT 19
13117: PUSH
13118: LD_INT 20
13120: PUSH
13121: LD_INT 21
13123: PUSH
13124: LD_INT 22
13126: PUSH
13127: LD_INT 23
13129: PUSH
13130: LD_INT 24
13132: PUSH
13133: LD_INT 25
13135: PUSH
13136: LD_INT 26
13138: PUSH
13139: LD_INT 27
13141: PUSH
13142: LD_INT 28
13144: PUSH
13145: LD_INT 30
13147: PUSH
13148: LD_INT 31
13150: PUSH
13151: LD_INT 32
13153: PUSH
13154: LD_INT 33
13156: PUSH
13157: LD_INT 34
13159: PUSH
13160: LD_INT 36
13162: PUSH
13163: EMPTY
13164: LIST
13165: LIST
13166: LIST
13167: LIST
13168: LIST
13169: LIST
13170: LIST
13171: LIST
13172: LIST
13173: LIST
13174: LIST
13175: LIST
13176: LIST
13177: LIST
13178: LIST
13179: LIST
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: LIST
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: LIST
13190: LIST
13191: LIST
13192: LIST
13193: LIST
13194: LIST
13195: PUSH
13196: LD_INT 101
13198: PUSH
13199: LD_INT 102
13201: PUSH
13202: LD_INT 103
13204: PUSH
13205: LD_INT 104
13207: PUSH
13208: LD_INT 105
13210: PUSH
13211: LD_INT 106
13213: PUSH
13214: LD_INT 107
13216: PUSH
13217: LD_INT 108
13219: PUSH
13220: LD_INT 109
13222: PUSH
13223: LD_INT 110
13225: PUSH
13226: LD_INT 111
13228: PUSH
13229: LD_INT 112
13231: PUSH
13232: LD_INT 113
13234: PUSH
13235: LD_INT 114
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: LIST
13242: LIST
13243: LIST
13244: LIST
13245: LIST
13246: LIST
13247: LIST
13248: LIST
13249: LIST
13250: LIST
13251: LIST
13252: LIST
13253: PUSH
13254: EMPTY
13255: LIST
13256: LIST
13257: ST_TO_ADDR
13258: GO 14425
13260: LD_INT 14
13262: DOUBLE
13263: EQUAL
13264: IFTRUE 13268
13266: GO 13480
13268: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
13269: LD_ADDR_VAR 0 1
13273: PUSH
13274: LD_INT 1
13276: PUSH
13277: LD_INT 2
13279: PUSH
13280: LD_INT 3
13282: PUSH
13283: LD_INT 4
13285: PUSH
13286: LD_INT 5
13288: PUSH
13289: LD_INT 6
13291: PUSH
13292: LD_INT 7
13294: PUSH
13295: LD_INT 8
13297: PUSH
13298: LD_INT 9
13300: PUSH
13301: LD_INT 10
13303: PUSH
13304: LD_INT 11
13306: PUSH
13307: LD_INT 12
13309: PUSH
13310: LD_INT 13
13312: PUSH
13313: LD_INT 14
13315: PUSH
13316: LD_INT 15
13318: PUSH
13319: LD_INT 16
13321: PUSH
13322: LD_INT 17
13324: PUSH
13325: LD_INT 18
13327: PUSH
13328: LD_INT 19
13330: PUSH
13331: LD_INT 20
13333: PUSH
13334: LD_INT 21
13336: PUSH
13337: LD_INT 22
13339: PUSH
13340: LD_INT 23
13342: PUSH
13343: LD_INT 24
13345: PUSH
13346: LD_INT 25
13348: PUSH
13349: LD_INT 26
13351: PUSH
13352: LD_INT 27
13354: PUSH
13355: LD_INT 28
13357: PUSH
13358: LD_INT 29
13360: PUSH
13361: LD_INT 30
13363: PUSH
13364: LD_INT 31
13366: PUSH
13367: LD_INT 32
13369: PUSH
13370: LD_INT 33
13372: PUSH
13373: LD_INT 34
13375: PUSH
13376: LD_INT 36
13378: PUSH
13379: EMPTY
13380: LIST
13381: LIST
13382: LIST
13383: LIST
13384: LIST
13385: LIST
13386: LIST
13387: LIST
13388: LIST
13389: LIST
13390: LIST
13391: LIST
13392: LIST
13393: LIST
13394: LIST
13395: LIST
13396: LIST
13397: LIST
13398: LIST
13399: LIST
13400: LIST
13401: LIST
13402: LIST
13403: LIST
13404: LIST
13405: LIST
13406: LIST
13407: LIST
13408: LIST
13409: LIST
13410: LIST
13411: LIST
13412: LIST
13413: LIST
13414: LIST
13415: PUSH
13416: LD_INT 101
13418: PUSH
13419: LD_INT 102
13421: PUSH
13422: LD_INT 103
13424: PUSH
13425: LD_INT 104
13427: PUSH
13428: LD_INT 105
13430: PUSH
13431: LD_INT 106
13433: PUSH
13434: LD_INT 107
13436: PUSH
13437: LD_INT 108
13439: PUSH
13440: LD_INT 109
13442: PUSH
13443: LD_INT 110
13445: PUSH
13446: LD_INT 111
13448: PUSH
13449: LD_INT 112
13451: PUSH
13452: LD_INT 113
13454: PUSH
13455: LD_INT 114
13457: PUSH
13458: EMPTY
13459: LIST
13460: LIST
13461: LIST
13462: LIST
13463: LIST
13464: LIST
13465: LIST
13466: LIST
13467: LIST
13468: LIST
13469: LIST
13470: LIST
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: ST_TO_ADDR
13478: GO 14425
13480: LD_INT 15
13482: DOUBLE
13483: EQUAL
13484: IFTRUE 13488
13486: GO 13700
13488: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
13489: LD_ADDR_VAR 0 1
13493: PUSH
13494: LD_INT 1
13496: PUSH
13497: LD_INT 2
13499: PUSH
13500: LD_INT 3
13502: PUSH
13503: LD_INT 4
13505: PUSH
13506: LD_INT 5
13508: PUSH
13509: LD_INT 6
13511: PUSH
13512: LD_INT 7
13514: PUSH
13515: LD_INT 8
13517: PUSH
13518: LD_INT 9
13520: PUSH
13521: LD_INT 10
13523: PUSH
13524: LD_INT 11
13526: PUSH
13527: LD_INT 12
13529: PUSH
13530: LD_INT 13
13532: PUSH
13533: LD_INT 14
13535: PUSH
13536: LD_INT 15
13538: PUSH
13539: LD_INT 16
13541: PUSH
13542: LD_INT 17
13544: PUSH
13545: LD_INT 18
13547: PUSH
13548: LD_INT 19
13550: PUSH
13551: LD_INT 20
13553: PUSH
13554: LD_INT 21
13556: PUSH
13557: LD_INT 22
13559: PUSH
13560: LD_INT 23
13562: PUSH
13563: LD_INT 24
13565: PUSH
13566: LD_INT 25
13568: PUSH
13569: LD_INT 26
13571: PUSH
13572: LD_INT 27
13574: PUSH
13575: LD_INT 28
13577: PUSH
13578: LD_INT 29
13580: PUSH
13581: LD_INT 30
13583: PUSH
13584: LD_INT 31
13586: PUSH
13587: LD_INT 32
13589: PUSH
13590: LD_INT 33
13592: PUSH
13593: LD_INT 34
13595: PUSH
13596: LD_INT 36
13598: PUSH
13599: EMPTY
13600: LIST
13601: LIST
13602: LIST
13603: LIST
13604: LIST
13605: LIST
13606: LIST
13607: LIST
13608: LIST
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: LIST
13614: LIST
13615: LIST
13616: LIST
13617: LIST
13618: LIST
13619: LIST
13620: LIST
13621: LIST
13622: LIST
13623: LIST
13624: LIST
13625: LIST
13626: LIST
13627: LIST
13628: LIST
13629: LIST
13630: LIST
13631: LIST
13632: LIST
13633: LIST
13634: LIST
13635: PUSH
13636: LD_INT 101
13638: PUSH
13639: LD_INT 102
13641: PUSH
13642: LD_INT 103
13644: PUSH
13645: LD_INT 104
13647: PUSH
13648: LD_INT 105
13650: PUSH
13651: LD_INT 106
13653: PUSH
13654: LD_INT 107
13656: PUSH
13657: LD_INT 108
13659: PUSH
13660: LD_INT 109
13662: PUSH
13663: LD_INT 110
13665: PUSH
13666: LD_INT 111
13668: PUSH
13669: LD_INT 112
13671: PUSH
13672: LD_INT 113
13674: PUSH
13675: LD_INT 114
13677: PUSH
13678: EMPTY
13679: LIST
13680: LIST
13681: LIST
13682: LIST
13683: LIST
13684: LIST
13685: LIST
13686: LIST
13687: LIST
13688: LIST
13689: LIST
13690: LIST
13691: LIST
13692: LIST
13693: PUSH
13694: EMPTY
13695: LIST
13696: LIST
13697: ST_TO_ADDR
13698: GO 14425
13700: LD_INT 16
13702: DOUBLE
13703: EQUAL
13704: IFTRUE 13708
13706: GO 13832
13708: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
13709: LD_ADDR_VAR 0 1
13713: PUSH
13714: LD_INT 2
13716: PUSH
13717: LD_INT 4
13719: PUSH
13720: LD_INT 5
13722: PUSH
13723: LD_INT 7
13725: PUSH
13726: LD_INT 11
13728: PUSH
13729: LD_INT 12
13731: PUSH
13732: LD_INT 15
13734: PUSH
13735: LD_INT 16
13737: PUSH
13738: LD_INT 20
13740: PUSH
13741: LD_INT 21
13743: PUSH
13744: LD_INT 22
13746: PUSH
13747: LD_INT 23
13749: PUSH
13750: LD_INT 25
13752: PUSH
13753: LD_INT 26
13755: PUSH
13756: LD_INT 30
13758: PUSH
13759: LD_INT 31
13761: PUSH
13762: LD_INT 32
13764: PUSH
13765: LD_INT 33
13767: PUSH
13768: LD_INT 34
13770: PUSH
13771: EMPTY
13772: LIST
13773: LIST
13774: LIST
13775: LIST
13776: LIST
13777: LIST
13778: LIST
13779: LIST
13780: LIST
13781: LIST
13782: LIST
13783: LIST
13784: LIST
13785: LIST
13786: LIST
13787: LIST
13788: LIST
13789: LIST
13790: LIST
13791: PUSH
13792: LD_INT 101
13794: PUSH
13795: LD_INT 102
13797: PUSH
13798: LD_INT 103
13800: PUSH
13801: LD_INT 106
13803: PUSH
13804: LD_INT 108
13806: PUSH
13807: LD_INT 112
13809: PUSH
13810: LD_INT 113
13812: PUSH
13813: LD_INT 114
13815: PUSH
13816: EMPTY
13817: LIST
13818: LIST
13819: LIST
13820: LIST
13821: LIST
13822: LIST
13823: LIST
13824: LIST
13825: PUSH
13826: EMPTY
13827: LIST
13828: LIST
13829: ST_TO_ADDR
13830: GO 14425
13832: LD_INT 17
13834: DOUBLE
13835: EQUAL
13836: IFTRUE 13840
13838: GO 14052
13840: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
13841: LD_ADDR_VAR 0 1
13845: PUSH
13846: LD_INT 1
13848: PUSH
13849: LD_INT 2
13851: PUSH
13852: LD_INT 3
13854: PUSH
13855: LD_INT 4
13857: PUSH
13858: LD_INT 5
13860: PUSH
13861: LD_INT 6
13863: PUSH
13864: LD_INT 7
13866: PUSH
13867: LD_INT 8
13869: PUSH
13870: LD_INT 9
13872: PUSH
13873: LD_INT 10
13875: PUSH
13876: LD_INT 11
13878: PUSH
13879: LD_INT 12
13881: PUSH
13882: LD_INT 13
13884: PUSH
13885: LD_INT 14
13887: PUSH
13888: LD_INT 15
13890: PUSH
13891: LD_INT 16
13893: PUSH
13894: LD_INT 17
13896: PUSH
13897: LD_INT 18
13899: PUSH
13900: LD_INT 19
13902: PUSH
13903: LD_INT 20
13905: PUSH
13906: LD_INT 21
13908: PUSH
13909: LD_INT 22
13911: PUSH
13912: LD_INT 23
13914: PUSH
13915: LD_INT 24
13917: PUSH
13918: LD_INT 25
13920: PUSH
13921: LD_INT 26
13923: PUSH
13924: LD_INT 27
13926: PUSH
13927: LD_INT 28
13929: PUSH
13930: LD_INT 29
13932: PUSH
13933: LD_INT 30
13935: PUSH
13936: LD_INT 31
13938: PUSH
13939: LD_INT 32
13941: PUSH
13942: LD_INT 33
13944: PUSH
13945: LD_INT 34
13947: PUSH
13948: LD_INT 36
13950: PUSH
13951: EMPTY
13952: LIST
13953: LIST
13954: LIST
13955: LIST
13956: LIST
13957: LIST
13958: LIST
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: LIST
13964: LIST
13965: LIST
13966: LIST
13967: LIST
13968: LIST
13969: LIST
13970: LIST
13971: LIST
13972: LIST
13973: LIST
13974: LIST
13975: LIST
13976: LIST
13977: LIST
13978: LIST
13979: LIST
13980: LIST
13981: LIST
13982: LIST
13983: LIST
13984: LIST
13985: LIST
13986: LIST
13987: PUSH
13988: LD_INT 101
13990: PUSH
13991: LD_INT 102
13993: PUSH
13994: LD_INT 103
13996: PUSH
13997: LD_INT 104
13999: PUSH
14000: LD_INT 105
14002: PUSH
14003: LD_INT 106
14005: PUSH
14006: LD_INT 107
14008: PUSH
14009: LD_INT 108
14011: PUSH
14012: LD_INT 109
14014: PUSH
14015: LD_INT 110
14017: PUSH
14018: LD_INT 111
14020: PUSH
14021: LD_INT 112
14023: PUSH
14024: LD_INT 113
14026: PUSH
14027: LD_INT 114
14029: PUSH
14030: EMPTY
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: LIST
14036: LIST
14037: LIST
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: LIST
14043: LIST
14044: LIST
14045: PUSH
14046: EMPTY
14047: LIST
14048: LIST
14049: ST_TO_ADDR
14050: GO 14425
14052: LD_INT 18
14054: DOUBLE
14055: EQUAL
14056: IFTRUE 14060
14058: GO 14196
14060: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
14061: LD_ADDR_VAR 0 1
14065: PUSH
14066: LD_INT 2
14068: PUSH
14069: LD_INT 4
14071: PUSH
14072: LD_INT 5
14074: PUSH
14075: LD_INT 7
14077: PUSH
14078: LD_INT 11
14080: PUSH
14081: LD_INT 12
14083: PUSH
14084: LD_INT 15
14086: PUSH
14087: LD_INT 16
14089: PUSH
14090: LD_INT 20
14092: PUSH
14093: LD_INT 21
14095: PUSH
14096: LD_INT 22
14098: PUSH
14099: LD_INT 23
14101: PUSH
14102: LD_INT 25
14104: PUSH
14105: LD_INT 26
14107: PUSH
14108: LD_INT 30
14110: PUSH
14111: LD_INT 31
14113: PUSH
14114: LD_INT 32
14116: PUSH
14117: LD_INT 33
14119: PUSH
14120: LD_INT 34
14122: PUSH
14123: LD_INT 35
14125: PUSH
14126: LD_INT 36
14128: PUSH
14129: EMPTY
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: PUSH
14152: LD_INT 101
14154: PUSH
14155: LD_INT 102
14157: PUSH
14158: LD_INT 103
14160: PUSH
14161: LD_INT 106
14163: PUSH
14164: LD_INT 108
14166: PUSH
14167: LD_INT 112
14169: PUSH
14170: LD_INT 113
14172: PUSH
14173: LD_INT 114
14175: PUSH
14176: LD_INT 115
14178: PUSH
14179: EMPTY
14180: LIST
14181: LIST
14182: LIST
14183: LIST
14184: LIST
14185: LIST
14186: LIST
14187: LIST
14188: LIST
14189: PUSH
14190: EMPTY
14191: LIST
14192: LIST
14193: ST_TO_ADDR
14194: GO 14425
14196: LD_INT 19
14198: DOUBLE
14199: EQUAL
14200: IFTRUE 14204
14202: GO 14424
14204: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
14205: LD_ADDR_VAR 0 1
14209: PUSH
14210: LD_INT 1
14212: PUSH
14213: LD_INT 2
14215: PUSH
14216: LD_INT 3
14218: PUSH
14219: LD_INT 4
14221: PUSH
14222: LD_INT 5
14224: PUSH
14225: LD_INT 6
14227: PUSH
14228: LD_INT 7
14230: PUSH
14231: LD_INT 8
14233: PUSH
14234: LD_INT 9
14236: PUSH
14237: LD_INT 10
14239: PUSH
14240: LD_INT 11
14242: PUSH
14243: LD_INT 12
14245: PUSH
14246: LD_INT 13
14248: PUSH
14249: LD_INT 14
14251: PUSH
14252: LD_INT 15
14254: PUSH
14255: LD_INT 16
14257: PUSH
14258: LD_INT 17
14260: PUSH
14261: LD_INT 18
14263: PUSH
14264: LD_INT 19
14266: PUSH
14267: LD_INT 20
14269: PUSH
14270: LD_INT 21
14272: PUSH
14273: LD_INT 22
14275: PUSH
14276: LD_INT 23
14278: PUSH
14279: LD_INT 24
14281: PUSH
14282: LD_INT 25
14284: PUSH
14285: LD_INT 26
14287: PUSH
14288: LD_INT 27
14290: PUSH
14291: LD_INT 28
14293: PUSH
14294: LD_INT 29
14296: PUSH
14297: LD_INT 30
14299: PUSH
14300: LD_INT 31
14302: PUSH
14303: LD_INT 32
14305: PUSH
14306: LD_INT 33
14308: PUSH
14309: LD_INT 34
14311: PUSH
14312: LD_INT 35
14314: PUSH
14315: LD_INT 36
14317: PUSH
14318: EMPTY
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: PUSH
14356: LD_INT 101
14358: PUSH
14359: LD_INT 102
14361: PUSH
14362: LD_INT 103
14364: PUSH
14365: LD_INT 104
14367: PUSH
14368: LD_INT 105
14370: PUSH
14371: LD_INT 106
14373: PUSH
14374: LD_INT 107
14376: PUSH
14377: LD_INT 108
14379: PUSH
14380: LD_INT 109
14382: PUSH
14383: LD_INT 110
14385: PUSH
14386: LD_INT 111
14388: PUSH
14389: LD_INT 112
14391: PUSH
14392: LD_INT 113
14394: PUSH
14395: LD_INT 114
14397: PUSH
14398: LD_INT 115
14400: PUSH
14401: EMPTY
14402: LIST
14403: LIST
14404: LIST
14405: LIST
14406: LIST
14407: LIST
14408: LIST
14409: LIST
14410: LIST
14411: LIST
14412: LIST
14413: LIST
14414: LIST
14415: LIST
14416: LIST
14417: PUSH
14418: EMPTY
14419: LIST
14420: LIST
14421: ST_TO_ADDR
14422: GO 14425
14424: POP
// end else
14425: GO 14462
// if campaign_id = 5 then
14427: LD_OWVAR 69
14431: PUSH
14432: LD_INT 5
14434: EQUAL
14435: IFFALSE 14462
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
14437: LD_ADDR_VAR 0 1
14441: PUSH
14442: LD_INT 1
14444: PUSH
14445: LD_INT 2
14447: PUSH
14448: EMPTY
14449: LIST
14450: LIST
14451: PUSH
14452: LD_INT 100
14454: PUSH
14455: EMPTY
14456: LIST
14457: PUSH
14458: EMPTY
14459: LIST
14460: LIST
14461: ST_TO_ADDR
// end ; if result then
14462: LD_VAR 0 1
14466: IFFALSE 14755
// begin normal :=  ;
14468: LD_ADDR_VAR 0 3
14472: PUSH
14473: LD_STRING 
14475: ST_TO_ADDR
// hardcore :=  ;
14476: LD_ADDR_VAR 0 4
14480: PUSH
14481: LD_STRING 
14483: ST_TO_ADDR
// for i = 1 to normalCounter do
14484: LD_ADDR_VAR 0 5
14488: PUSH
14489: DOUBLE
14490: LD_INT 1
14492: DEC
14493: ST_TO_ADDR
14494: LD_EXP 31
14498: PUSH
14499: FOR_TO
14500: IFFALSE 14601
// begin tmp := 0 ;
14502: LD_ADDR_VAR 0 2
14506: PUSH
14507: LD_STRING 0
14509: ST_TO_ADDR
// if result [ 1 ] then
14510: LD_VAR 0 1
14514: PUSH
14515: LD_INT 1
14517: ARRAY
14518: IFFALSE 14583
// if result [ 1 ] [ 1 ] = i then
14520: LD_VAR 0 1
14524: PUSH
14525: LD_INT 1
14527: ARRAY
14528: PUSH
14529: LD_INT 1
14531: ARRAY
14532: PUSH
14533: LD_VAR 0 5
14537: EQUAL
14538: IFFALSE 14583
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
14540: LD_ADDR_VAR 0 1
14544: PUSH
14545: LD_VAR 0 1
14549: PPUSH
14550: LD_INT 1
14552: PPUSH
14553: LD_VAR 0 1
14557: PUSH
14558: LD_INT 1
14560: ARRAY
14561: PPUSH
14562: LD_INT 1
14564: PPUSH
14565: CALL_OW 3
14569: PPUSH
14570: CALL_OW 1
14574: ST_TO_ADDR
// tmp := 1 ;
14575: LD_ADDR_VAR 0 2
14579: PUSH
14580: LD_STRING 1
14582: ST_TO_ADDR
// end ; normal := normal & tmp ;
14583: LD_ADDR_VAR 0 3
14587: PUSH
14588: LD_VAR 0 3
14592: PUSH
14593: LD_VAR 0 2
14597: STR
14598: ST_TO_ADDR
// end ;
14599: GO 14499
14601: POP
14602: POP
// for i = 1 to hardcoreCounter do
14603: LD_ADDR_VAR 0 5
14607: PUSH
14608: DOUBLE
14609: LD_INT 1
14611: DEC
14612: ST_TO_ADDR
14613: LD_EXP 32
14617: PUSH
14618: FOR_TO
14619: IFFALSE 14724
// begin tmp := 0 ;
14621: LD_ADDR_VAR 0 2
14625: PUSH
14626: LD_STRING 0
14628: ST_TO_ADDR
// if result [ 2 ] then
14629: LD_VAR 0 1
14633: PUSH
14634: LD_INT 2
14636: ARRAY
14637: IFFALSE 14706
// if result [ 2 ] [ 1 ] = 100 + i then
14639: LD_VAR 0 1
14643: PUSH
14644: LD_INT 2
14646: ARRAY
14647: PUSH
14648: LD_INT 1
14650: ARRAY
14651: PUSH
14652: LD_INT 100
14654: PUSH
14655: LD_VAR 0 5
14659: PLUS
14660: EQUAL
14661: IFFALSE 14706
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
14663: LD_ADDR_VAR 0 1
14667: PUSH
14668: LD_VAR 0 1
14672: PPUSH
14673: LD_INT 2
14675: PPUSH
14676: LD_VAR 0 1
14680: PUSH
14681: LD_INT 2
14683: ARRAY
14684: PPUSH
14685: LD_INT 1
14687: PPUSH
14688: CALL_OW 3
14692: PPUSH
14693: CALL_OW 1
14697: ST_TO_ADDR
// tmp := 1 ;
14698: LD_ADDR_VAR 0 2
14702: PUSH
14703: LD_STRING 1
14705: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
14706: LD_ADDR_VAR 0 4
14710: PUSH
14711: LD_VAR 0 4
14715: PUSH
14716: LD_VAR 0 2
14720: STR
14721: ST_TO_ADDR
// end ;
14722: GO 14618
14724: POP
14725: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
14726: LD_STRING getStreamItemsFromMission("
14728: PUSH
14729: LD_VAR 0 3
14733: STR
14734: PUSH
14735: LD_STRING ","
14737: STR
14738: PUSH
14739: LD_VAR 0 4
14743: STR
14744: PUSH
14745: LD_STRING ")
14747: STR
14748: PPUSH
14749: CALL_OW 559
// end else
14753: GO 14762
// ToLua ( getStreamItemsFromMission("","") ) ;
14755: LD_STRING getStreamItemsFromMission("","")
14757: PPUSH
14758: CALL_OW 559
// end ;
14762: LD_VAR 0 1
14766: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
14767: LD_VAR 0 2
14771: PUSH
14772: LD_INT 100
14774: EQUAL
14775: IFFALSE 15724
// begin if not StreamModeActive then
14777: LD_EXP 30
14781: NOT
14782: IFFALSE 14792
// StreamModeActive := true ;
14784: LD_ADDR_EXP 30
14788: PUSH
14789: LD_INT 1
14791: ST_TO_ADDR
// if p3 = 0 then
14792: LD_VAR 0 3
14796: PUSH
14797: LD_INT 0
14799: EQUAL
14800: IFFALSE 14806
// InitStreamMode ;
14802: CALL 11027 0 0
// if p3 = 1 then
14806: LD_VAR 0 3
14810: PUSH
14811: LD_INT 1
14813: EQUAL
14814: IFFALSE 14824
// sRocket := true ;
14816: LD_ADDR_EXP 35
14820: PUSH
14821: LD_INT 1
14823: ST_TO_ADDR
// if p3 = 2 then
14824: LD_VAR 0 3
14828: PUSH
14829: LD_INT 2
14831: EQUAL
14832: IFFALSE 14842
// sSpeed := true ;
14834: LD_ADDR_EXP 34
14838: PUSH
14839: LD_INT 1
14841: ST_TO_ADDR
// if p3 = 3 then
14842: LD_VAR 0 3
14846: PUSH
14847: LD_INT 3
14849: EQUAL
14850: IFFALSE 14860
// sEngine := true ;
14852: LD_ADDR_EXP 36
14856: PUSH
14857: LD_INT 1
14859: ST_TO_ADDR
// if p3 = 4 then
14860: LD_VAR 0 3
14864: PUSH
14865: LD_INT 4
14867: EQUAL
14868: IFFALSE 14878
// sSpec := true ;
14870: LD_ADDR_EXP 33
14874: PUSH
14875: LD_INT 1
14877: ST_TO_ADDR
// if p3 = 5 then
14878: LD_VAR 0 3
14882: PUSH
14883: LD_INT 5
14885: EQUAL
14886: IFFALSE 14896
// sLevel := true ;
14888: LD_ADDR_EXP 37
14892: PUSH
14893: LD_INT 1
14895: ST_TO_ADDR
// if p3 = 6 then
14896: LD_VAR 0 3
14900: PUSH
14901: LD_INT 6
14903: EQUAL
14904: IFFALSE 14914
// sArmoury := true ;
14906: LD_ADDR_EXP 38
14910: PUSH
14911: LD_INT 1
14913: ST_TO_ADDR
// if p3 = 7 then
14914: LD_VAR 0 3
14918: PUSH
14919: LD_INT 7
14921: EQUAL
14922: IFFALSE 14932
// sRadar := true ;
14924: LD_ADDR_EXP 39
14928: PUSH
14929: LD_INT 1
14931: ST_TO_ADDR
// if p3 = 8 then
14932: LD_VAR 0 3
14936: PUSH
14937: LD_INT 8
14939: EQUAL
14940: IFFALSE 14950
// sBunker := true ;
14942: LD_ADDR_EXP 40
14946: PUSH
14947: LD_INT 1
14949: ST_TO_ADDR
// if p3 = 9 then
14950: LD_VAR 0 3
14954: PUSH
14955: LD_INT 9
14957: EQUAL
14958: IFFALSE 14968
// sHack := true ;
14960: LD_ADDR_EXP 41
14964: PUSH
14965: LD_INT 1
14967: ST_TO_ADDR
// if p3 = 10 then
14968: LD_VAR 0 3
14972: PUSH
14973: LD_INT 10
14975: EQUAL
14976: IFFALSE 14986
// sFire := true ;
14978: LD_ADDR_EXP 42
14982: PUSH
14983: LD_INT 1
14985: ST_TO_ADDR
// if p3 = 11 then
14986: LD_VAR 0 3
14990: PUSH
14991: LD_INT 11
14993: EQUAL
14994: IFFALSE 15004
// sRefresh := true ;
14996: LD_ADDR_EXP 43
15000: PUSH
15001: LD_INT 1
15003: ST_TO_ADDR
// if p3 = 12 then
15004: LD_VAR 0 3
15008: PUSH
15009: LD_INT 12
15011: EQUAL
15012: IFFALSE 15022
// sExp := true ;
15014: LD_ADDR_EXP 44
15018: PUSH
15019: LD_INT 1
15021: ST_TO_ADDR
// if p3 = 13 then
15022: LD_VAR 0 3
15026: PUSH
15027: LD_INT 13
15029: EQUAL
15030: IFFALSE 15040
// sDepot := true ;
15032: LD_ADDR_EXP 45
15036: PUSH
15037: LD_INT 1
15039: ST_TO_ADDR
// if p3 = 14 then
15040: LD_VAR 0 3
15044: PUSH
15045: LD_INT 14
15047: EQUAL
15048: IFFALSE 15058
// sFlag := true ;
15050: LD_ADDR_EXP 46
15054: PUSH
15055: LD_INT 1
15057: ST_TO_ADDR
// if p3 = 15 then
15058: LD_VAR 0 3
15062: PUSH
15063: LD_INT 15
15065: EQUAL
15066: IFFALSE 15076
// sKamikadze := true ;
15068: LD_ADDR_EXP 54
15072: PUSH
15073: LD_INT 1
15075: ST_TO_ADDR
// if p3 = 16 then
15076: LD_VAR 0 3
15080: PUSH
15081: LD_INT 16
15083: EQUAL
15084: IFFALSE 15094
// sTroll := true ;
15086: LD_ADDR_EXP 55
15090: PUSH
15091: LD_INT 1
15093: ST_TO_ADDR
// if p3 = 17 then
15094: LD_VAR 0 3
15098: PUSH
15099: LD_INT 17
15101: EQUAL
15102: IFFALSE 15112
// sSlow := true ;
15104: LD_ADDR_EXP 56
15108: PUSH
15109: LD_INT 1
15111: ST_TO_ADDR
// if p3 = 18 then
15112: LD_VAR 0 3
15116: PUSH
15117: LD_INT 18
15119: EQUAL
15120: IFFALSE 15130
// sLack := true ;
15122: LD_ADDR_EXP 57
15126: PUSH
15127: LD_INT 1
15129: ST_TO_ADDR
// if p3 = 19 then
15130: LD_VAR 0 3
15134: PUSH
15135: LD_INT 19
15137: EQUAL
15138: IFFALSE 15148
// sTank := true ;
15140: LD_ADDR_EXP 59
15144: PUSH
15145: LD_INT 1
15147: ST_TO_ADDR
// if p3 = 20 then
15148: LD_VAR 0 3
15152: PUSH
15153: LD_INT 20
15155: EQUAL
15156: IFFALSE 15166
// sRemote := true ;
15158: LD_ADDR_EXP 60
15162: PUSH
15163: LD_INT 1
15165: ST_TO_ADDR
// if p3 = 21 then
15166: LD_VAR 0 3
15170: PUSH
15171: LD_INT 21
15173: EQUAL
15174: IFFALSE 15184
// sPowell := true ;
15176: LD_ADDR_EXP 61
15180: PUSH
15181: LD_INT 1
15183: ST_TO_ADDR
// if p3 = 22 then
15184: LD_VAR 0 3
15188: PUSH
15189: LD_INT 22
15191: EQUAL
15192: IFFALSE 15202
// sTeleport := true ;
15194: LD_ADDR_EXP 64
15198: PUSH
15199: LD_INT 1
15201: ST_TO_ADDR
// if p3 = 23 then
15202: LD_VAR 0 3
15206: PUSH
15207: LD_INT 23
15209: EQUAL
15210: IFFALSE 15220
// sOilTower := true ;
15212: LD_ADDR_EXP 66
15216: PUSH
15217: LD_INT 1
15219: ST_TO_ADDR
// if p3 = 24 then
15220: LD_VAR 0 3
15224: PUSH
15225: LD_INT 24
15227: EQUAL
15228: IFFALSE 15238
// sShovel := true ;
15230: LD_ADDR_EXP 67
15234: PUSH
15235: LD_INT 1
15237: ST_TO_ADDR
// if p3 = 25 then
15238: LD_VAR 0 3
15242: PUSH
15243: LD_INT 25
15245: EQUAL
15246: IFFALSE 15256
// sSheik := true ;
15248: LD_ADDR_EXP 68
15252: PUSH
15253: LD_INT 1
15255: ST_TO_ADDR
// if p3 = 26 then
15256: LD_VAR 0 3
15260: PUSH
15261: LD_INT 26
15263: EQUAL
15264: IFFALSE 15274
// sEarthquake := true ;
15266: LD_ADDR_EXP 70
15270: PUSH
15271: LD_INT 1
15273: ST_TO_ADDR
// if p3 = 27 then
15274: LD_VAR 0 3
15278: PUSH
15279: LD_INT 27
15281: EQUAL
15282: IFFALSE 15292
// sAI := true ;
15284: LD_ADDR_EXP 71
15288: PUSH
15289: LD_INT 1
15291: ST_TO_ADDR
// if p3 = 28 then
15292: LD_VAR 0 3
15296: PUSH
15297: LD_INT 28
15299: EQUAL
15300: IFFALSE 15310
// sCargo := true ;
15302: LD_ADDR_EXP 74
15306: PUSH
15307: LD_INT 1
15309: ST_TO_ADDR
// if p3 = 29 then
15310: LD_VAR 0 3
15314: PUSH
15315: LD_INT 29
15317: EQUAL
15318: IFFALSE 15328
// sDLaser := true ;
15320: LD_ADDR_EXP 75
15324: PUSH
15325: LD_INT 1
15327: ST_TO_ADDR
// if p3 = 30 then
15328: LD_VAR 0 3
15332: PUSH
15333: LD_INT 30
15335: EQUAL
15336: IFFALSE 15346
// sExchange := true ;
15338: LD_ADDR_EXP 76
15342: PUSH
15343: LD_INT 1
15345: ST_TO_ADDR
// if p3 = 31 then
15346: LD_VAR 0 3
15350: PUSH
15351: LD_INT 31
15353: EQUAL
15354: IFFALSE 15364
// sFac := true ;
15356: LD_ADDR_EXP 77
15360: PUSH
15361: LD_INT 1
15363: ST_TO_ADDR
// if p3 = 32 then
15364: LD_VAR 0 3
15368: PUSH
15369: LD_INT 32
15371: EQUAL
15372: IFFALSE 15382
// sPower := true ;
15374: LD_ADDR_EXP 78
15378: PUSH
15379: LD_INT 1
15381: ST_TO_ADDR
// if p3 = 33 then
15382: LD_VAR 0 3
15386: PUSH
15387: LD_INT 33
15389: EQUAL
15390: IFFALSE 15400
// sRandom := true ;
15392: LD_ADDR_EXP 79
15396: PUSH
15397: LD_INT 1
15399: ST_TO_ADDR
// if p3 = 34 then
15400: LD_VAR 0 3
15404: PUSH
15405: LD_INT 34
15407: EQUAL
15408: IFFALSE 15418
// sShield := true ;
15410: LD_ADDR_EXP 80
15414: PUSH
15415: LD_INT 1
15417: ST_TO_ADDR
// if p3 = 35 then
15418: LD_VAR 0 3
15422: PUSH
15423: LD_INT 35
15425: EQUAL
15426: IFFALSE 15436
// sTime := true ;
15428: LD_ADDR_EXP 81
15432: PUSH
15433: LD_INT 1
15435: ST_TO_ADDR
// if p3 = 36 then
15436: LD_VAR 0 3
15440: PUSH
15441: LD_INT 36
15443: EQUAL
15444: IFFALSE 15454
// sTools := true ;
15446: LD_ADDR_EXP 82
15450: PUSH
15451: LD_INT 1
15453: ST_TO_ADDR
// if p3 = 101 then
15454: LD_VAR 0 3
15458: PUSH
15459: LD_INT 101
15461: EQUAL
15462: IFFALSE 15472
// sSold := true ;
15464: LD_ADDR_EXP 47
15468: PUSH
15469: LD_INT 1
15471: ST_TO_ADDR
// if p3 = 102 then
15472: LD_VAR 0 3
15476: PUSH
15477: LD_INT 102
15479: EQUAL
15480: IFFALSE 15490
// sDiff := true ;
15482: LD_ADDR_EXP 48
15486: PUSH
15487: LD_INT 1
15489: ST_TO_ADDR
// if p3 = 103 then
15490: LD_VAR 0 3
15494: PUSH
15495: LD_INT 103
15497: EQUAL
15498: IFFALSE 15508
// sFog := true ;
15500: LD_ADDR_EXP 51
15504: PUSH
15505: LD_INT 1
15507: ST_TO_ADDR
// if p3 = 104 then
15508: LD_VAR 0 3
15512: PUSH
15513: LD_INT 104
15515: EQUAL
15516: IFFALSE 15526
// sReset := true ;
15518: LD_ADDR_EXP 52
15522: PUSH
15523: LD_INT 1
15525: ST_TO_ADDR
// if p3 = 105 then
15526: LD_VAR 0 3
15530: PUSH
15531: LD_INT 105
15533: EQUAL
15534: IFFALSE 15544
// sSun := true ;
15536: LD_ADDR_EXP 53
15540: PUSH
15541: LD_INT 1
15543: ST_TO_ADDR
// if p3 = 106 then
15544: LD_VAR 0 3
15548: PUSH
15549: LD_INT 106
15551: EQUAL
15552: IFFALSE 15562
// sTiger := true ;
15554: LD_ADDR_EXP 49
15558: PUSH
15559: LD_INT 1
15561: ST_TO_ADDR
// if p3 = 107 then
15562: LD_VAR 0 3
15566: PUSH
15567: LD_INT 107
15569: EQUAL
15570: IFFALSE 15580
// sBomb := true ;
15572: LD_ADDR_EXP 50
15576: PUSH
15577: LD_INT 1
15579: ST_TO_ADDR
// if p3 = 108 then
15580: LD_VAR 0 3
15584: PUSH
15585: LD_INT 108
15587: EQUAL
15588: IFFALSE 15598
// sWound := true ;
15590: LD_ADDR_EXP 58
15594: PUSH
15595: LD_INT 1
15597: ST_TO_ADDR
// if p3 = 109 then
15598: LD_VAR 0 3
15602: PUSH
15603: LD_INT 109
15605: EQUAL
15606: IFFALSE 15616
// sBetray := true ;
15608: LD_ADDR_EXP 62
15612: PUSH
15613: LD_INT 1
15615: ST_TO_ADDR
// if p3 = 110 then
15616: LD_VAR 0 3
15620: PUSH
15621: LD_INT 110
15623: EQUAL
15624: IFFALSE 15634
// sContamin := true ;
15626: LD_ADDR_EXP 63
15630: PUSH
15631: LD_INT 1
15633: ST_TO_ADDR
// if p3 = 111 then
15634: LD_VAR 0 3
15638: PUSH
15639: LD_INT 111
15641: EQUAL
15642: IFFALSE 15652
// sOil := true ;
15644: LD_ADDR_EXP 65
15648: PUSH
15649: LD_INT 1
15651: ST_TO_ADDR
// if p3 = 112 then
15652: LD_VAR 0 3
15656: PUSH
15657: LD_INT 112
15659: EQUAL
15660: IFFALSE 15670
// sStu := true ;
15662: LD_ADDR_EXP 69
15666: PUSH
15667: LD_INT 1
15669: ST_TO_ADDR
// if p3 = 113 then
15670: LD_VAR 0 3
15674: PUSH
15675: LD_INT 113
15677: EQUAL
15678: IFFALSE 15688
// sBazooka := true ;
15680: LD_ADDR_EXP 72
15684: PUSH
15685: LD_INT 1
15687: ST_TO_ADDR
// if p3 = 114 then
15688: LD_VAR 0 3
15692: PUSH
15693: LD_INT 114
15695: EQUAL
15696: IFFALSE 15706
// sMortar := true ;
15698: LD_ADDR_EXP 73
15702: PUSH
15703: LD_INT 1
15705: ST_TO_ADDR
// if p3 = 115 then
15706: LD_VAR 0 3
15710: PUSH
15711: LD_INT 115
15713: EQUAL
15714: IFFALSE 15724
// sRanger := true ;
15716: LD_ADDR_EXP 83
15720: PUSH
15721: LD_INT 1
15723: ST_TO_ADDR
// end ; end ;
15724: PPOPN 6
15726: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
15727: LD_EXP 30
15731: PUSH
15732: LD_EXP 35
15736: AND
15737: IFFALSE 15861
15739: GO 15741
15741: DISABLE
15742: LD_INT 0
15744: PPUSH
15745: PPUSH
// begin enable ;
15746: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
15747: LD_ADDR_VAR 0 2
15751: PUSH
15752: LD_INT 22
15754: PUSH
15755: LD_OWVAR 2
15759: PUSH
15760: EMPTY
15761: LIST
15762: LIST
15763: PUSH
15764: LD_INT 2
15766: PUSH
15767: LD_INT 34
15769: PUSH
15770: LD_INT 7
15772: PUSH
15773: EMPTY
15774: LIST
15775: LIST
15776: PUSH
15777: LD_INT 34
15779: PUSH
15780: LD_INT 45
15782: PUSH
15783: EMPTY
15784: LIST
15785: LIST
15786: PUSH
15787: LD_INT 34
15789: PUSH
15790: LD_INT 28
15792: PUSH
15793: EMPTY
15794: LIST
15795: LIST
15796: PUSH
15797: LD_INT 34
15799: PUSH
15800: LD_INT 47
15802: PUSH
15803: EMPTY
15804: LIST
15805: LIST
15806: PUSH
15807: EMPTY
15808: LIST
15809: LIST
15810: LIST
15811: LIST
15812: LIST
15813: PUSH
15814: EMPTY
15815: LIST
15816: LIST
15817: PPUSH
15818: CALL_OW 69
15822: ST_TO_ADDR
// if not tmp then
15823: LD_VAR 0 2
15827: NOT
15828: IFFALSE 15832
// exit ;
15830: GO 15861
// for i in tmp do
15832: LD_ADDR_VAR 0 1
15836: PUSH
15837: LD_VAR 0 2
15841: PUSH
15842: FOR_IN
15843: IFFALSE 15859
// begin SetLives ( i , 0 ) ;
15845: LD_VAR 0 1
15849: PPUSH
15850: LD_INT 0
15852: PPUSH
15853: CALL_OW 234
// end ;
15857: GO 15842
15859: POP
15860: POP
// end ;
15861: PPOPN 2
15863: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
15864: LD_EXP 30
15868: PUSH
15869: LD_EXP 36
15873: AND
15874: IFFALSE 15958
15876: GO 15878
15878: DISABLE
15879: LD_INT 0
15881: PPUSH
15882: PPUSH
// begin enable ;
15883: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
15884: LD_ADDR_VAR 0 2
15888: PUSH
15889: LD_INT 22
15891: PUSH
15892: LD_OWVAR 2
15896: PUSH
15897: EMPTY
15898: LIST
15899: LIST
15900: PUSH
15901: LD_INT 32
15903: PUSH
15904: LD_INT 3
15906: PUSH
15907: EMPTY
15908: LIST
15909: LIST
15910: PUSH
15911: EMPTY
15912: LIST
15913: LIST
15914: PPUSH
15915: CALL_OW 69
15919: ST_TO_ADDR
// if not tmp then
15920: LD_VAR 0 2
15924: NOT
15925: IFFALSE 15929
// exit ;
15927: GO 15958
// for i in tmp do
15929: LD_ADDR_VAR 0 1
15933: PUSH
15934: LD_VAR 0 2
15938: PUSH
15939: FOR_IN
15940: IFFALSE 15956
// begin SetLives ( i , 0 ) ;
15942: LD_VAR 0 1
15946: PPUSH
15947: LD_INT 0
15949: PPUSH
15950: CALL_OW 234
// end ;
15954: GO 15939
15956: POP
15957: POP
// end ;
15958: PPOPN 2
15960: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
15961: LD_EXP 30
15965: PUSH
15966: LD_EXP 33
15970: AND
15971: IFFALSE 16064
15973: GO 15975
15975: DISABLE
15976: LD_INT 0
15978: PPUSH
// begin enable ;
15979: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
15980: LD_ADDR_VAR 0 1
15984: PUSH
15985: LD_INT 22
15987: PUSH
15988: LD_OWVAR 2
15992: PUSH
15993: EMPTY
15994: LIST
15995: LIST
15996: PUSH
15997: LD_INT 2
15999: PUSH
16000: LD_INT 25
16002: PUSH
16003: LD_INT 5
16005: PUSH
16006: EMPTY
16007: LIST
16008: LIST
16009: PUSH
16010: LD_INT 25
16012: PUSH
16013: LD_INT 9
16015: PUSH
16016: EMPTY
16017: LIST
16018: LIST
16019: PUSH
16020: LD_INT 25
16022: PUSH
16023: LD_INT 8
16025: PUSH
16026: EMPTY
16027: LIST
16028: LIST
16029: PUSH
16030: EMPTY
16031: LIST
16032: LIST
16033: LIST
16034: LIST
16035: PUSH
16036: EMPTY
16037: LIST
16038: LIST
16039: PPUSH
16040: CALL_OW 69
16044: PUSH
16045: FOR_IN
16046: IFFALSE 16062
// begin SetClass ( i , 1 ) ;
16048: LD_VAR 0 1
16052: PPUSH
16053: LD_INT 1
16055: PPUSH
16056: CALL_OW 336
// end ;
16060: GO 16045
16062: POP
16063: POP
// end ;
16064: PPOPN 1
16066: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
16067: LD_EXP 30
16071: PUSH
16072: LD_EXP 34
16076: AND
16077: PUSH
16078: LD_OWVAR 65
16082: PUSH
16083: LD_INT 7
16085: LESS
16086: AND
16087: IFFALSE 16101
16089: GO 16091
16091: DISABLE
// begin enable ;
16092: ENABLE
// game_speed := 7 ;
16093: LD_ADDR_OWVAR 65
16097: PUSH
16098: LD_INT 7
16100: ST_TO_ADDR
// end ;
16101: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
16102: LD_EXP 30
16106: PUSH
16107: LD_EXP 37
16111: AND
16112: IFFALSE 16314
16114: GO 16116
16116: DISABLE
16117: LD_INT 0
16119: PPUSH
16120: PPUSH
16121: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
16122: LD_ADDR_VAR 0 3
16126: PUSH
16127: LD_INT 81
16129: PUSH
16130: LD_OWVAR 2
16134: PUSH
16135: EMPTY
16136: LIST
16137: LIST
16138: PUSH
16139: LD_INT 21
16141: PUSH
16142: LD_INT 1
16144: PUSH
16145: EMPTY
16146: LIST
16147: LIST
16148: PUSH
16149: EMPTY
16150: LIST
16151: LIST
16152: PPUSH
16153: CALL_OW 69
16157: ST_TO_ADDR
// if not tmp then
16158: LD_VAR 0 3
16162: NOT
16163: IFFALSE 16167
// exit ;
16165: GO 16314
// if tmp > 5 then
16167: LD_VAR 0 3
16171: PUSH
16172: LD_INT 5
16174: GREATER
16175: IFFALSE 16187
// k := 5 else
16177: LD_ADDR_VAR 0 2
16181: PUSH
16182: LD_INT 5
16184: ST_TO_ADDR
16185: GO 16197
// k := tmp ;
16187: LD_ADDR_VAR 0 2
16191: PUSH
16192: LD_VAR 0 3
16196: ST_TO_ADDR
// for i := 1 to k do
16197: LD_ADDR_VAR 0 1
16201: PUSH
16202: DOUBLE
16203: LD_INT 1
16205: DEC
16206: ST_TO_ADDR
16207: LD_VAR 0 2
16211: PUSH
16212: FOR_TO
16213: IFFALSE 16312
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
16215: LD_VAR 0 3
16219: PUSH
16220: LD_VAR 0 1
16224: ARRAY
16225: PPUSH
16226: LD_VAR 0 1
16230: PUSH
16231: LD_INT 4
16233: MOD
16234: PUSH
16235: LD_INT 1
16237: PLUS
16238: PPUSH
16239: CALL_OW 259
16243: PUSH
16244: LD_INT 10
16246: LESS
16247: IFFALSE 16310
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
16249: LD_VAR 0 3
16253: PUSH
16254: LD_VAR 0 1
16258: ARRAY
16259: PPUSH
16260: LD_VAR 0 1
16264: PUSH
16265: LD_INT 4
16267: MOD
16268: PUSH
16269: LD_INT 1
16271: PLUS
16272: PPUSH
16273: LD_VAR 0 3
16277: PUSH
16278: LD_VAR 0 1
16282: ARRAY
16283: PPUSH
16284: LD_VAR 0 1
16288: PUSH
16289: LD_INT 4
16291: MOD
16292: PUSH
16293: LD_INT 1
16295: PLUS
16296: PPUSH
16297: CALL_OW 259
16301: PUSH
16302: LD_INT 1
16304: PLUS
16305: PPUSH
16306: CALL_OW 237
16310: GO 16212
16312: POP
16313: POP
// end ;
16314: PPOPN 3
16316: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
16317: LD_EXP 30
16321: PUSH
16322: LD_EXP 38
16326: AND
16327: IFFALSE 16347
16329: GO 16331
16331: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
16332: LD_INT 4
16334: PPUSH
16335: LD_OWVAR 2
16339: PPUSH
16340: LD_INT 0
16342: PPUSH
16343: CALL_OW 324
16347: END
// every 0 0$1 trigger StreamModeActive and sShovel do
16348: LD_EXP 30
16352: PUSH
16353: LD_EXP 67
16357: AND
16358: IFFALSE 16378
16360: GO 16362
16362: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
16363: LD_INT 19
16365: PPUSH
16366: LD_OWVAR 2
16370: PPUSH
16371: LD_INT 0
16373: PPUSH
16374: CALL_OW 324
16378: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
16379: LD_EXP 30
16383: PUSH
16384: LD_EXP 39
16388: AND
16389: IFFALSE 16491
16391: GO 16393
16393: DISABLE
16394: LD_INT 0
16396: PPUSH
16397: PPUSH
// begin enable ;
16398: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
16399: LD_ADDR_VAR 0 2
16403: PUSH
16404: LD_INT 22
16406: PUSH
16407: LD_OWVAR 2
16411: PUSH
16412: EMPTY
16413: LIST
16414: LIST
16415: PUSH
16416: LD_INT 2
16418: PUSH
16419: LD_INT 34
16421: PUSH
16422: LD_INT 11
16424: PUSH
16425: EMPTY
16426: LIST
16427: LIST
16428: PUSH
16429: LD_INT 34
16431: PUSH
16432: LD_INT 30
16434: PUSH
16435: EMPTY
16436: LIST
16437: LIST
16438: PUSH
16439: EMPTY
16440: LIST
16441: LIST
16442: LIST
16443: PUSH
16444: EMPTY
16445: LIST
16446: LIST
16447: PPUSH
16448: CALL_OW 69
16452: ST_TO_ADDR
// if not tmp then
16453: LD_VAR 0 2
16457: NOT
16458: IFFALSE 16462
// exit ;
16460: GO 16491
// for i in tmp do
16462: LD_ADDR_VAR 0 1
16466: PUSH
16467: LD_VAR 0 2
16471: PUSH
16472: FOR_IN
16473: IFFALSE 16489
// begin SetLives ( i , 0 ) ;
16475: LD_VAR 0 1
16479: PPUSH
16480: LD_INT 0
16482: PPUSH
16483: CALL_OW 234
// end ;
16487: GO 16472
16489: POP
16490: POP
// end ;
16491: PPOPN 2
16493: END
// every 0 0$1 trigger StreamModeActive and sBunker do
16494: LD_EXP 30
16498: PUSH
16499: LD_EXP 40
16503: AND
16504: IFFALSE 16524
16506: GO 16508
16508: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
16509: LD_INT 32
16511: PPUSH
16512: LD_OWVAR 2
16516: PPUSH
16517: LD_INT 0
16519: PPUSH
16520: CALL_OW 324
16524: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
16525: LD_EXP 30
16529: PUSH
16530: LD_EXP 41
16534: AND
16535: IFFALSE 16716
16537: GO 16539
16539: DISABLE
16540: LD_INT 0
16542: PPUSH
16543: PPUSH
16544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
16545: LD_ADDR_VAR 0 2
16549: PUSH
16550: LD_INT 22
16552: PUSH
16553: LD_OWVAR 2
16557: PUSH
16558: EMPTY
16559: LIST
16560: LIST
16561: PUSH
16562: LD_INT 33
16564: PUSH
16565: LD_INT 3
16567: PUSH
16568: EMPTY
16569: LIST
16570: LIST
16571: PUSH
16572: EMPTY
16573: LIST
16574: LIST
16575: PPUSH
16576: CALL_OW 69
16580: ST_TO_ADDR
// if not tmp then
16581: LD_VAR 0 2
16585: NOT
16586: IFFALSE 16590
// exit ;
16588: GO 16716
// side := 0 ;
16590: LD_ADDR_VAR 0 3
16594: PUSH
16595: LD_INT 0
16597: ST_TO_ADDR
// for i := 1 to 8 do
16598: LD_ADDR_VAR 0 1
16602: PUSH
16603: DOUBLE
16604: LD_INT 1
16606: DEC
16607: ST_TO_ADDR
16608: LD_INT 8
16610: PUSH
16611: FOR_TO
16612: IFFALSE 16660
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
16614: LD_OWVAR 2
16618: PUSH
16619: LD_VAR 0 1
16623: NONEQUAL
16624: PUSH
16625: LD_OWVAR 2
16629: PPUSH
16630: LD_VAR 0 1
16634: PPUSH
16635: CALL_OW 81
16639: PUSH
16640: LD_INT 2
16642: EQUAL
16643: AND
16644: IFFALSE 16658
// begin side := i ;
16646: LD_ADDR_VAR 0 3
16650: PUSH
16651: LD_VAR 0 1
16655: ST_TO_ADDR
// break ;
16656: GO 16660
// end ;
16658: GO 16611
16660: POP
16661: POP
// if not side then
16662: LD_VAR 0 3
16666: NOT
16667: IFFALSE 16671
// exit ;
16669: GO 16716
// for i := 1 to tmp do
16671: LD_ADDR_VAR 0 1
16675: PUSH
16676: DOUBLE
16677: LD_INT 1
16679: DEC
16680: ST_TO_ADDR
16681: LD_VAR 0 2
16685: PUSH
16686: FOR_TO
16687: IFFALSE 16714
// if Prob ( 60 ) then
16689: LD_INT 60
16691: PPUSH
16692: CALL_OW 13
16696: IFFALSE 16712
// SetSide ( i , side ) ;
16698: LD_VAR 0 1
16702: PPUSH
16703: LD_VAR 0 3
16707: PPUSH
16708: CALL_OW 235
16712: GO 16686
16714: POP
16715: POP
// end ;
16716: PPOPN 3
16718: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
16719: LD_EXP 30
16723: PUSH
16724: LD_EXP 43
16728: AND
16729: IFFALSE 16848
16731: GO 16733
16733: DISABLE
16734: LD_INT 0
16736: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
16737: LD_ADDR_VAR 0 1
16741: PUSH
16742: LD_INT 22
16744: PUSH
16745: LD_OWVAR 2
16749: PUSH
16750: EMPTY
16751: LIST
16752: LIST
16753: PUSH
16754: LD_INT 21
16756: PUSH
16757: LD_INT 1
16759: PUSH
16760: EMPTY
16761: LIST
16762: LIST
16763: PUSH
16764: LD_INT 3
16766: PUSH
16767: LD_INT 23
16769: PUSH
16770: LD_INT 0
16772: PUSH
16773: EMPTY
16774: LIST
16775: LIST
16776: PUSH
16777: EMPTY
16778: LIST
16779: LIST
16780: PUSH
16781: EMPTY
16782: LIST
16783: LIST
16784: LIST
16785: PPUSH
16786: CALL_OW 69
16790: PUSH
16791: FOR_IN
16792: IFFALSE 16846
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
16794: LD_VAR 0 1
16798: PPUSH
16799: CALL_OW 257
16803: PUSH
16804: LD_INT 1
16806: PUSH
16807: LD_INT 2
16809: PUSH
16810: LD_INT 3
16812: PUSH
16813: LD_INT 4
16815: PUSH
16816: EMPTY
16817: LIST
16818: LIST
16819: LIST
16820: LIST
16821: IN
16822: IFFALSE 16844
// SetClass ( un , rand ( 1 , 4 ) ) ;
16824: LD_VAR 0 1
16828: PPUSH
16829: LD_INT 1
16831: PPUSH
16832: LD_INT 4
16834: PPUSH
16835: CALL_OW 12
16839: PPUSH
16840: CALL_OW 336
16844: GO 16791
16846: POP
16847: POP
// end ;
16848: PPOPN 1
16850: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
16851: LD_EXP 30
16855: PUSH
16856: LD_EXP 42
16860: AND
16861: IFFALSE 16940
16863: GO 16865
16865: DISABLE
16866: LD_INT 0
16868: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
16869: LD_ADDR_VAR 0 1
16873: PUSH
16874: LD_INT 22
16876: PUSH
16877: LD_OWVAR 2
16881: PUSH
16882: EMPTY
16883: LIST
16884: LIST
16885: PUSH
16886: LD_INT 21
16888: PUSH
16889: LD_INT 3
16891: PUSH
16892: EMPTY
16893: LIST
16894: LIST
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PPUSH
16900: CALL_OW 69
16904: ST_TO_ADDR
// if not tmp then
16905: LD_VAR 0 1
16909: NOT
16910: IFFALSE 16914
// exit ;
16912: GO 16940
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
16914: LD_VAR 0 1
16918: PUSH
16919: LD_INT 1
16921: PPUSH
16922: LD_VAR 0 1
16926: PPUSH
16927: CALL_OW 12
16931: ARRAY
16932: PPUSH
16933: LD_INT 100
16935: PPUSH
16936: CALL_OW 234
// end ;
16940: PPOPN 1
16942: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
16943: LD_EXP 30
16947: PUSH
16948: LD_EXP 44
16952: AND
16953: IFFALSE 17051
16955: GO 16957
16957: DISABLE
16958: LD_INT 0
16960: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16961: LD_ADDR_VAR 0 1
16965: PUSH
16966: LD_INT 22
16968: PUSH
16969: LD_OWVAR 2
16973: PUSH
16974: EMPTY
16975: LIST
16976: LIST
16977: PUSH
16978: LD_INT 21
16980: PUSH
16981: LD_INT 1
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: PUSH
16988: EMPTY
16989: LIST
16990: LIST
16991: PPUSH
16992: CALL_OW 69
16996: ST_TO_ADDR
// if not tmp then
16997: LD_VAR 0 1
17001: NOT
17002: IFFALSE 17006
// exit ;
17004: GO 17051
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
17006: LD_VAR 0 1
17010: PUSH
17011: LD_INT 1
17013: PPUSH
17014: LD_VAR 0 1
17018: PPUSH
17019: CALL_OW 12
17023: ARRAY
17024: PPUSH
17025: LD_INT 1
17027: PPUSH
17028: LD_INT 4
17030: PPUSH
17031: CALL_OW 12
17035: PPUSH
17036: LD_INT 3000
17038: PPUSH
17039: LD_INT 9000
17041: PPUSH
17042: CALL_OW 12
17046: PPUSH
17047: CALL_OW 492
// end ;
17051: PPOPN 1
17053: END
// every 0 0$1 trigger StreamModeActive and sDepot do
17054: LD_EXP 30
17058: PUSH
17059: LD_EXP 45
17063: AND
17064: IFFALSE 17084
17066: GO 17068
17068: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
17069: LD_INT 1
17071: PPUSH
17072: LD_OWVAR 2
17076: PPUSH
17077: LD_INT 0
17079: PPUSH
17080: CALL_OW 324
17084: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
17085: LD_EXP 30
17089: PUSH
17090: LD_EXP 46
17094: AND
17095: IFFALSE 17178
17097: GO 17099
17099: DISABLE
17100: LD_INT 0
17102: PPUSH
17103: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17104: LD_ADDR_VAR 0 2
17108: PUSH
17109: LD_INT 22
17111: PUSH
17112: LD_OWVAR 2
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: PUSH
17121: LD_INT 21
17123: PUSH
17124: LD_INT 3
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: PUSH
17131: EMPTY
17132: LIST
17133: LIST
17134: PPUSH
17135: CALL_OW 69
17139: ST_TO_ADDR
// if not tmp then
17140: LD_VAR 0 2
17144: NOT
17145: IFFALSE 17149
// exit ;
17147: GO 17178
// for i in tmp do
17149: LD_ADDR_VAR 0 1
17153: PUSH
17154: LD_VAR 0 2
17158: PUSH
17159: FOR_IN
17160: IFFALSE 17176
// SetBLevel ( i , 10 ) ;
17162: LD_VAR 0 1
17166: PPUSH
17167: LD_INT 10
17169: PPUSH
17170: CALL_OW 241
17174: GO 17159
17176: POP
17177: POP
// end ;
17178: PPOPN 2
17180: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
17181: LD_EXP 30
17185: PUSH
17186: LD_EXP 47
17190: AND
17191: IFFALSE 17302
17193: GO 17195
17195: DISABLE
17196: LD_INT 0
17198: PPUSH
17199: PPUSH
17200: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17201: LD_ADDR_VAR 0 3
17205: PUSH
17206: LD_INT 22
17208: PUSH
17209: LD_OWVAR 2
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: PUSH
17218: LD_INT 25
17220: PUSH
17221: LD_INT 1
17223: PUSH
17224: EMPTY
17225: LIST
17226: LIST
17227: PUSH
17228: EMPTY
17229: LIST
17230: LIST
17231: PPUSH
17232: CALL_OW 69
17236: ST_TO_ADDR
// if not tmp then
17237: LD_VAR 0 3
17241: NOT
17242: IFFALSE 17246
// exit ;
17244: GO 17302
// un := tmp [ rand ( 1 , tmp ) ] ;
17246: LD_ADDR_VAR 0 2
17250: PUSH
17251: LD_VAR 0 3
17255: PUSH
17256: LD_INT 1
17258: PPUSH
17259: LD_VAR 0 3
17263: PPUSH
17264: CALL_OW 12
17268: ARRAY
17269: ST_TO_ADDR
// if Crawls ( un ) then
17270: LD_VAR 0 2
17274: PPUSH
17275: CALL_OW 318
17279: IFFALSE 17290
// ComWalk ( un ) ;
17281: LD_VAR 0 2
17285: PPUSH
17286: CALL_OW 138
// SetClass ( un , class_sniper ) ;
17290: LD_VAR 0 2
17294: PPUSH
17295: LD_INT 5
17297: PPUSH
17298: CALL_OW 336
// end ;
17302: PPOPN 3
17304: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
17305: LD_EXP 30
17309: PUSH
17310: LD_EXP 48
17314: AND
17315: PUSH
17316: LD_OWVAR 67
17320: PUSH
17321: LD_INT 3
17323: LESS
17324: AND
17325: IFFALSE 17344
17327: GO 17329
17329: DISABLE
// Difficulty := Difficulty + 1 ;
17330: LD_ADDR_OWVAR 67
17334: PUSH
17335: LD_OWVAR 67
17339: PUSH
17340: LD_INT 1
17342: PLUS
17343: ST_TO_ADDR
17344: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
17345: LD_EXP 30
17349: PUSH
17350: LD_EXP 49
17354: AND
17355: IFFALSE 17458
17357: GO 17359
17359: DISABLE
17360: LD_INT 0
17362: PPUSH
// begin for i := 1 to 5 do
17363: LD_ADDR_VAR 0 1
17367: PUSH
17368: DOUBLE
17369: LD_INT 1
17371: DEC
17372: ST_TO_ADDR
17373: LD_INT 5
17375: PUSH
17376: FOR_TO
17377: IFFALSE 17456
// begin uc_nation := nation_nature ;
17379: LD_ADDR_OWVAR 21
17383: PUSH
17384: LD_INT 0
17386: ST_TO_ADDR
// uc_side := 0 ;
17387: LD_ADDR_OWVAR 20
17391: PUSH
17392: LD_INT 0
17394: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17395: LD_ADDR_OWVAR 29
17399: PUSH
17400: LD_INT 12
17402: PUSH
17403: LD_INT 12
17405: PUSH
17406: EMPTY
17407: LIST
17408: LIST
17409: ST_TO_ADDR
// hc_agressivity := 20 ;
17410: LD_ADDR_OWVAR 35
17414: PUSH
17415: LD_INT 20
17417: ST_TO_ADDR
// hc_class := class_tiger ;
17418: LD_ADDR_OWVAR 28
17422: PUSH
17423: LD_INT 14
17425: ST_TO_ADDR
// hc_gallery :=  ;
17426: LD_ADDR_OWVAR 33
17430: PUSH
17431: LD_STRING 
17433: ST_TO_ADDR
// hc_name :=  ;
17434: LD_ADDR_OWVAR 26
17438: PUSH
17439: LD_STRING 
17441: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
17442: CALL_OW 44
17446: PPUSH
17447: LD_INT 0
17449: PPUSH
17450: CALL_OW 51
// end ;
17454: GO 17376
17456: POP
17457: POP
// end ;
17458: PPOPN 1
17460: END
// every 0 0$1 trigger StreamModeActive and sBomb do
17461: LD_EXP 30
17465: PUSH
17466: LD_EXP 50
17470: AND
17471: IFFALSE 17480
17473: GO 17475
17475: DISABLE
// StreamSibBomb ;
17476: CALL 17481 0 0
17480: END
// export function StreamSibBomb ; var i , x , y ; begin
17481: LD_INT 0
17483: PPUSH
17484: PPUSH
17485: PPUSH
17486: PPUSH
// result := false ;
17487: LD_ADDR_VAR 0 1
17491: PUSH
17492: LD_INT 0
17494: ST_TO_ADDR
// for i := 1 to 16 do
17495: LD_ADDR_VAR 0 2
17499: PUSH
17500: DOUBLE
17501: LD_INT 1
17503: DEC
17504: ST_TO_ADDR
17505: LD_INT 16
17507: PUSH
17508: FOR_TO
17509: IFFALSE 17708
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17511: LD_ADDR_VAR 0 3
17515: PUSH
17516: LD_INT 10
17518: PUSH
17519: LD_INT 20
17521: PUSH
17522: LD_INT 30
17524: PUSH
17525: LD_INT 40
17527: PUSH
17528: LD_INT 50
17530: PUSH
17531: LD_INT 60
17533: PUSH
17534: LD_INT 70
17536: PUSH
17537: LD_INT 80
17539: PUSH
17540: LD_INT 90
17542: PUSH
17543: LD_INT 100
17545: PUSH
17546: LD_INT 110
17548: PUSH
17549: LD_INT 120
17551: PUSH
17552: LD_INT 130
17554: PUSH
17555: LD_INT 140
17557: PUSH
17558: LD_INT 150
17560: PUSH
17561: EMPTY
17562: LIST
17563: LIST
17564: LIST
17565: LIST
17566: LIST
17567: LIST
17568: LIST
17569: LIST
17570: LIST
17571: LIST
17572: LIST
17573: LIST
17574: LIST
17575: LIST
17576: LIST
17577: PUSH
17578: LD_INT 1
17580: PPUSH
17581: LD_INT 15
17583: PPUSH
17584: CALL_OW 12
17588: ARRAY
17589: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17590: LD_ADDR_VAR 0 4
17594: PUSH
17595: LD_INT 10
17597: PUSH
17598: LD_INT 20
17600: PUSH
17601: LD_INT 30
17603: PUSH
17604: LD_INT 40
17606: PUSH
17607: LD_INT 50
17609: PUSH
17610: LD_INT 60
17612: PUSH
17613: LD_INT 70
17615: PUSH
17616: LD_INT 80
17618: PUSH
17619: LD_INT 90
17621: PUSH
17622: LD_INT 100
17624: PUSH
17625: LD_INT 110
17627: PUSH
17628: LD_INT 120
17630: PUSH
17631: LD_INT 130
17633: PUSH
17634: LD_INT 140
17636: PUSH
17637: LD_INT 150
17639: PUSH
17640: EMPTY
17641: LIST
17642: LIST
17643: LIST
17644: LIST
17645: LIST
17646: LIST
17647: LIST
17648: LIST
17649: LIST
17650: LIST
17651: LIST
17652: LIST
17653: LIST
17654: LIST
17655: LIST
17656: PUSH
17657: LD_INT 1
17659: PPUSH
17660: LD_INT 15
17662: PPUSH
17663: CALL_OW 12
17667: ARRAY
17668: ST_TO_ADDR
// if ValidHex ( x , y ) then
17669: LD_VAR 0 3
17673: PPUSH
17674: LD_VAR 0 4
17678: PPUSH
17679: CALL_OW 488
17683: IFFALSE 17706
// begin result := [ x , y ] ;
17685: LD_ADDR_VAR 0 1
17689: PUSH
17690: LD_VAR 0 3
17694: PUSH
17695: LD_VAR 0 4
17699: PUSH
17700: EMPTY
17701: LIST
17702: LIST
17703: ST_TO_ADDR
// break ;
17704: GO 17708
// end ; end ;
17706: GO 17508
17708: POP
17709: POP
// if result then
17710: LD_VAR 0 1
17714: IFFALSE 17774
// begin ToLua ( playSibBomb() ) ;
17716: LD_STRING playSibBomb()
17718: PPUSH
17719: CALL_OW 559
// wait ( 0 0$14 ) ;
17723: LD_INT 490
17725: PPUSH
17726: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
17730: LD_VAR 0 1
17734: PUSH
17735: LD_INT 1
17737: ARRAY
17738: PPUSH
17739: LD_VAR 0 1
17743: PUSH
17744: LD_INT 2
17746: ARRAY
17747: PPUSH
17748: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
17752: LD_VAR 0 1
17756: PUSH
17757: LD_INT 1
17759: ARRAY
17760: PPUSH
17761: LD_VAR 0 1
17765: PUSH
17766: LD_INT 2
17768: ARRAY
17769: PPUSH
17770: CALL_OW 429
// end ; end ;
17774: LD_VAR 0 1
17778: RET
// every 0 0$1 trigger StreamModeActive and sReset do
17779: LD_EXP 30
17783: PUSH
17784: LD_EXP 52
17788: AND
17789: IFFALSE 17801
17791: GO 17793
17793: DISABLE
// YouLost (  ) ;
17794: LD_STRING 
17796: PPUSH
17797: CALL_OW 104
17801: END
// every 0 0$1 trigger StreamModeActive and sFog do
17802: LD_EXP 30
17806: PUSH
17807: LD_EXP 51
17811: AND
17812: IFFALSE 17826
17814: GO 17816
17816: DISABLE
// FogOff ( your_side ) ;
17817: LD_OWVAR 2
17821: PPUSH
17822: CALL_OW 344
17826: END
// every 0 0$1 trigger StreamModeActive and sSun do
17827: LD_EXP 30
17831: PUSH
17832: LD_EXP 53
17836: AND
17837: IFFALSE 17865
17839: GO 17841
17841: DISABLE
// begin solar_recharge_percent := 0 ;
17842: LD_ADDR_OWVAR 79
17846: PUSH
17847: LD_INT 0
17849: ST_TO_ADDR
// wait ( 5 5$00 ) ;
17850: LD_INT 10500
17852: PPUSH
17853: CALL_OW 67
// solar_recharge_percent := 100 ;
17857: LD_ADDR_OWVAR 79
17861: PUSH
17862: LD_INT 100
17864: ST_TO_ADDR
// end ;
17865: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
17866: LD_EXP 30
17870: PUSH
17871: LD_EXP 54
17875: AND
17876: IFFALSE 18115
17878: GO 17880
17880: DISABLE
17881: LD_INT 0
17883: PPUSH
17884: PPUSH
17885: PPUSH
// begin tmp := [ ] ;
17886: LD_ADDR_VAR 0 3
17890: PUSH
17891: EMPTY
17892: ST_TO_ADDR
// for i := 1 to 6 do
17893: LD_ADDR_VAR 0 1
17897: PUSH
17898: DOUBLE
17899: LD_INT 1
17901: DEC
17902: ST_TO_ADDR
17903: LD_INT 6
17905: PUSH
17906: FOR_TO
17907: IFFALSE 18012
// begin uc_nation := nation_nature ;
17909: LD_ADDR_OWVAR 21
17913: PUSH
17914: LD_INT 0
17916: ST_TO_ADDR
// uc_side := 0 ;
17917: LD_ADDR_OWVAR 20
17921: PUSH
17922: LD_INT 0
17924: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17925: LD_ADDR_OWVAR 29
17929: PUSH
17930: LD_INT 12
17932: PUSH
17933: LD_INT 12
17935: PUSH
17936: EMPTY
17937: LIST
17938: LIST
17939: ST_TO_ADDR
// hc_agressivity := 20 ;
17940: LD_ADDR_OWVAR 35
17944: PUSH
17945: LD_INT 20
17947: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
17948: LD_ADDR_OWVAR 28
17952: PUSH
17953: LD_INT 17
17955: ST_TO_ADDR
// hc_gallery :=  ;
17956: LD_ADDR_OWVAR 33
17960: PUSH
17961: LD_STRING 
17963: ST_TO_ADDR
// hc_name :=  ;
17964: LD_ADDR_OWVAR 26
17968: PUSH
17969: LD_STRING 
17971: ST_TO_ADDR
// un := CreateHuman ;
17972: LD_ADDR_VAR 0 2
17976: PUSH
17977: CALL_OW 44
17981: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
17982: LD_VAR 0 2
17986: PPUSH
17987: LD_INT 1
17989: PPUSH
17990: CALL_OW 51
// tmp := tmp ^ un ;
17994: LD_ADDR_VAR 0 3
17998: PUSH
17999: LD_VAR 0 3
18003: PUSH
18004: LD_VAR 0 2
18008: ADD
18009: ST_TO_ADDR
// end ;
18010: GO 17906
18012: POP
18013: POP
// repeat wait ( 0 0$1 ) ;
18014: LD_INT 35
18016: PPUSH
18017: CALL_OW 67
// for un in tmp do
18021: LD_ADDR_VAR 0 2
18025: PUSH
18026: LD_VAR 0 3
18030: PUSH
18031: FOR_IN
18032: IFFALSE 18106
// begin if IsDead ( un ) then
18034: LD_VAR 0 2
18038: PPUSH
18039: CALL_OW 301
18043: IFFALSE 18063
// begin tmp := tmp diff un ;
18045: LD_ADDR_VAR 0 3
18049: PUSH
18050: LD_VAR 0 3
18054: PUSH
18055: LD_VAR 0 2
18059: DIFF
18060: ST_TO_ADDR
// continue ;
18061: GO 18031
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
18063: LD_VAR 0 2
18067: PPUSH
18068: LD_INT 3
18070: PUSH
18071: LD_INT 22
18073: PUSH
18074: LD_INT 0
18076: PUSH
18077: EMPTY
18078: LIST
18079: LIST
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: PPUSH
18085: CALL_OW 69
18089: PPUSH
18090: LD_VAR 0 2
18094: PPUSH
18095: CALL_OW 74
18099: PPUSH
18100: CALL_OW 115
// end ;
18104: GO 18031
18106: POP
18107: POP
// until not tmp ;
18108: LD_VAR 0 3
18112: NOT
18113: IFFALSE 18014
// end ;
18115: PPOPN 3
18117: END
// every 0 0$1 trigger StreamModeActive and sTroll do
18118: LD_EXP 30
18122: PUSH
18123: LD_EXP 55
18127: AND
18128: IFFALSE 18182
18130: GO 18132
18132: DISABLE
// begin ToLua ( displayTroll(); ) ;
18133: LD_STRING displayTroll();
18135: PPUSH
18136: CALL_OW 559
// wait ( 3 3$00 ) ;
18140: LD_INT 6300
18142: PPUSH
18143: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18147: LD_STRING hideTroll();
18149: PPUSH
18150: CALL_OW 559
// wait ( 1 1$00 ) ;
18154: LD_INT 2100
18156: PPUSH
18157: CALL_OW 67
// ToLua ( displayTroll(); ) ;
18161: LD_STRING displayTroll();
18163: PPUSH
18164: CALL_OW 559
// wait ( 1 1$00 ) ;
18168: LD_INT 2100
18170: PPUSH
18171: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18175: LD_STRING hideTroll();
18177: PPUSH
18178: CALL_OW 559
// end ;
18182: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
18183: LD_EXP 30
18187: PUSH
18188: LD_EXP 56
18192: AND
18193: IFFALSE 18256
18195: GO 18197
18197: DISABLE
18198: LD_INT 0
18200: PPUSH
// begin p := 0 ;
18201: LD_ADDR_VAR 0 1
18205: PUSH
18206: LD_INT 0
18208: ST_TO_ADDR
// repeat game_speed := 1 ;
18209: LD_ADDR_OWVAR 65
18213: PUSH
18214: LD_INT 1
18216: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18217: LD_INT 35
18219: PPUSH
18220: CALL_OW 67
// p := p + 1 ;
18224: LD_ADDR_VAR 0 1
18228: PUSH
18229: LD_VAR 0 1
18233: PUSH
18234: LD_INT 1
18236: PLUS
18237: ST_TO_ADDR
// until p >= 60 ;
18238: LD_VAR 0 1
18242: PUSH
18243: LD_INT 60
18245: GREATEREQUAL
18246: IFFALSE 18209
// game_speed := 4 ;
18248: LD_ADDR_OWVAR 65
18252: PUSH
18253: LD_INT 4
18255: ST_TO_ADDR
// end ;
18256: PPOPN 1
18258: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
18259: LD_EXP 30
18263: PUSH
18264: LD_EXP 57
18268: AND
18269: IFFALSE 18415
18271: GO 18273
18273: DISABLE
18274: LD_INT 0
18276: PPUSH
18277: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
18278: LD_ADDR_VAR 0 1
18282: PUSH
18283: LD_INT 22
18285: PUSH
18286: LD_OWVAR 2
18290: PUSH
18291: EMPTY
18292: LIST
18293: LIST
18294: PUSH
18295: LD_INT 2
18297: PUSH
18298: LD_INT 30
18300: PUSH
18301: LD_INT 0
18303: PUSH
18304: EMPTY
18305: LIST
18306: LIST
18307: PUSH
18308: LD_INT 30
18310: PUSH
18311: LD_INT 1
18313: PUSH
18314: EMPTY
18315: LIST
18316: LIST
18317: PUSH
18318: EMPTY
18319: LIST
18320: LIST
18321: LIST
18322: PUSH
18323: EMPTY
18324: LIST
18325: LIST
18326: PPUSH
18327: CALL_OW 69
18331: ST_TO_ADDR
// if not depot then
18332: LD_VAR 0 1
18336: NOT
18337: IFFALSE 18341
// exit ;
18339: GO 18415
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
18341: LD_ADDR_VAR 0 2
18345: PUSH
18346: LD_VAR 0 1
18350: PUSH
18351: LD_INT 1
18353: PPUSH
18354: LD_VAR 0 1
18358: PPUSH
18359: CALL_OW 12
18363: ARRAY
18364: PPUSH
18365: CALL_OW 274
18369: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
18370: LD_VAR 0 2
18374: PPUSH
18375: LD_INT 1
18377: PPUSH
18378: LD_INT 0
18380: PPUSH
18381: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
18385: LD_VAR 0 2
18389: PPUSH
18390: LD_INT 2
18392: PPUSH
18393: LD_INT 0
18395: PPUSH
18396: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
18400: LD_VAR 0 2
18404: PPUSH
18405: LD_INT 3
18407: PPUSH
18408: LD_INT 0
18410: PPUSH
18411: CALL_OW 277
// end ;
18415: PPOPN 2
18417: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
18418: LD_EXP 30
18422: PUSH
18423: LD_EXP 58
18427: AND
18428: IFFALSE 18525
18430: GO 18432
18432: DISABLE
18433: LD_INT 0
18435: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18436: LD_ADDR_VAR 0 1
18440: PUSH
18441: LD_INT 22
18443: PUSH
18444: LD_OWVAR 2
18448: PUSH
18449: EMPTY
18450: LIST
18451: LIST
18452: PUSH
18453: LD_INT 21
18455: PUSH
18456: LD_INT 1
18458: PUSH
18459: EMPTY
18460: LIST
18461: LIST
18462: PUSH
18463: LD_INT 3
18465: PUSH
18466: LD_INT 23
18468: PUSH
18469: LD_INT 0
18471: PUSH
18472: EMPTY
18473: LIST
18474: LIST
18475: PUSH
18476: EMPTY
18477: LIST
18478: LIST
18479: PUSH
18480: EMPTY
18481: LIST
18482: LIST
18483: LIST
18484: PPUSH
18485: CALL_OW 69
18489: ST_TO_ADDR
// if not tmp then
18490: LD_VAR 0 1
18494: NOT
18495: IFFALSE 18499
// exit ;
18497: GO 18525
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
18499: LD_VAR 0 1
18503: PUSH
18504: LD_INT 1
18506: PPUSH
18507: LD_VAR 0 1
18511: PPUSH
18512: CALL_OW 12
18516: ARRAY
18517: PPUSH
18518: LD_INT 200
18520: PPUSH
18521: CALL_OW 234
// end ;
18525: PPOPN 1
18527: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
18528: LD_EXP 30
18532: PUSH
18533: LD_EXP 59
18537: AND
18538: IFFALSE 18617
18540: GO 18542
18542: DISABLE
18543: LD_INT 0
18545: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
18546: LD_ADDR_VAR 0 1
18550: PUSH
18551: LD_INT 22
18553: PUSH
18554: LD_OWVAR 2
18558: PUSH
18559: EMPTY
18560: LIST
18561: LIST
18562: PUSH
18563: LD_INT 21
18565: PUSH
18566: LD_INT 2
18568: PUSH
18569: EMPTY
18570: LIST
18571: LIST
18572: PUSH
18573: EMPTY
18574: LIST
18575: LIST
18576: PPUSH
18577: CALL_OW 69
18581: ST_TO_ADDR
// if not tmp then
18582: LD_VAR 0 1
18586: NOT
18587: IFFALSE 18591
// exit ;
18589: GO 18617
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
18591: LD_VAR 0 1
18595: PUSH
18596: LD_INT 1
18598: PPUSH
18599: LD_VAR 0 1
18603: PPUSH
18604: CALL_OW 12
18608: ARRAY
18609: PPUSH
18610: LD_INT 60
18612: PPUSH
18613: CALL_OW 234
// end ;
18617: PPOPN 1
18619: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
18620: LD_EXP 30
18624: PUSH
18625: LD_EXP 60
18629: AND
18630: IFFALSE 18729
18632: GO 18634
18634: DISABLE
18635: LD_INT 0
18637: PPUSH
18638: PPUSH
// begin enable ;
18639: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
18640: LD_ADDR_VAR 0 1
18644: PUSH
18645: LD_INT 22
18647: PUSH
18648: LD_OWVAR 2
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: PUSH
18657: LD_INT 61
18659: PUSH
18660: EMPTY
18661: LIST
18662: PUSH
18663: LD_INT 33
18665: PUSH
18666: LD_INT 2
18668: PUSH
18669: EMPTY
18670: LIST
18671: LIST
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: LIST
18677: PPUSH
18678: CALL_OW 69
18682: ST_TO_ADDR
// if not tmp then
18683: LD_VAR 0 1
18687: NOT
18688: IFFALSE 18692
// exit ;
18690: GO 18729
// for i in tmp do
18692: LD_ADDR_VAR 0 2
18696: PUSH
18697: LD_VAR 0 1
18701: PUSH
18702: FOR_IN
18703: IFFALSE 18727
// if IsControledBy ( i ) then
18705: LD_VAR 0 2
18709: PPUSH
18710: CALL_OW 312
18714: IFFALSE 18725
// ComUnlink ( i ) ;
18716: LD_VAR 0 2
18720: PPUSH
18721: CALL_OW 136
18725: GO 18702
18727: POP
18728: POP
// end ;
18729: PPOPN 2
18731: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
18732: LD_EXP 30
18736: PUSH
18737: LD_EXP 61
18741: AND
18742: IFFALSE 18882
18744: GO 18746
18746: DISABLE
18747: LD_INT 0
18749: PPUSH
18750: PPUSH
// begin ToLua ( displayPowell(); ) ;
18751: LD_STRING displayPowell();
18753: PPUSH
18754: CALL_OW 559
// uc_side := 0 ;
18758: LD_ADDR_OWVAR 20
18762: PUSH
18763: LD_INT 0
18765: ST_TO_ADDR
// uc_nation := 2 ;
18766: LD_ADDR_OWVAR 21
18770: PUSH
18771: LD_INT 2
18773: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
18774: LD_ADDR_OWVAR 37
18778: PUSH
18779: LD_INT 14
18781: ST_TO_ADDR
// vc_engine := engine_siberite ;
18782: LD_ADDR_OWVAR 39
18786: PUSH
18787: LD_INT 3
18789: ST_TO_ADDR
// vc_control := control_apeman ;
18790: LD_ADDR_OWVAR 38
18794: PUSH
18795: LD_INT 5
18797: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
18798: LD_ADDR_OWVAR 40
18802: PUSH
18803: LD_INT 29
18805: ST_TO_ADDR
// un := CreateVehicle ;
18806: LD_ADDR_VAR 0 2
18810: PUSH
18811: CALL_OW 45
18815: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18816: LD_VAR 0 2
18820: PPUSH
18821: LD_INT 1
18823: PPUSH
18824: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
18828: LD_INT 35
18830: PPUSH
18831: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
18835: LD_VAR 0 2
18839: PPUSH
18840: LD_INT 22
18842: PUSH
18843: LD_OWVAR 2
18847: PUSH
18848: EMPTY
18849: LIST
18850: LIST
18851: PPUSH
18852: CALL_OW 69
18856: PPUSH
18857: LD_VAR 0 2
18861: PPUSH
18862: CALL_OW 74
18866: PPUSH
18867: CALL_OW 115
// until IsDead ( un ) ;
18871: LD_VAR 0 2
18875: PPUSH
18876: CALL_OW 301
18880: IFFALSE 18828
// end ;
18882: PPOPN 2
18884: END
// every 0 0$1 trigger StreamModeActive and sStu do
18885: LD_EXP 30
18889: PUSH
18890: LD_EXP 69
18894: AND
18895: IFFALSE 18911
18897: GO 18899
18899: DISABLE
// begin ToLua ( displayStucuk(); ) ;
18900: LD_STRING displayStucuk();
18902: PPUSH
18903: CALL_OW 559
// ResetFog ;
18907: CALL_OW 335
// end ;
18911: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
18912: LD_EXP 30
18916: PUSH
18917: LD_EXP 62
18921: AND
18922: IFFALSE 19063
18924: GO 18926
18926: DISABLE
18927: LD_INT 0
18929: PPUSH
18930: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
18931: LD_ADDR_VAR 0 2
18935: PUSH
18936: LD_INT 22
18938: PUSH
18939: LD_OWVAR 2
18943: PUSH
18944: EMPTY
18945: LIST
18946: LIST
18947: PUSH
18948: LD_INT 21
18950: PUSH
18951: LD_INT 1
18953: PUSH
18954: EMPTY
18955: LIST
18956: LIST
18957: PUSH
18958: EMPTY
18959: LIST
18960: LIST
18961: PPUSH
18962: CALL_OW 69
18966: ST_TO_ADDR
// if not tmp then
18967: LD_VAR 0 2
18971: NOT
18972: IFFALSE 18976
// exit ;
18974: GO 19063
// un := tmp [ rand ( 1 , tmp ) ] ;
18976: LD_ADDR_VAR 0 1
18980: PUSH
18981: LD_VAR 0 2
18985: PUSH
18986: LD_INT 1
18988: PPUSH
18989: LD_VAR 0 2
18993: PPUSH
18994: CALL_OW 12
18998: ARRAY
18999: ST_TO_ADDR
// SetSide ( un , 0 ) ;
19000: LD_VAR 0 1
19004: PPUSH
19005: LD_INT 0
19007: PPUSH
19008: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
19012: LD_VAR 0 1
19016: PPUSH
19017: LD_OWVAR 3
19021: PUSH
19022: LD_VAR 0 1
19026: DIFF
19027: PPUSH
19028: LD_VAR 0 1
19032: PPUSH
19033: CALL_OW 74
19037: PPUSH
19038: CALL_OW 115
// wait ( 0 0$20 ) ;
19042: LD_INT 700
19044: PPUSH
19045: CALL_OW 67
// SetSide ( un , your_side ) ;
19049: LD_VAR 0 1
19053: PPUSH
19054: LD_OWVAR 2
19058: PPUSH
19059: CALL_OW 235
// end ;
19063: PPOPN 2
19065: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
19066: LD_EXP 30
19070: PUSH
19071: LD_EXP 63
19075: AND
19076: IFFALSE 19182
19078: GO 19080
19080: DISABLE
19081: LD_INT 0
19083: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19084: LD_ADDR_VAR 0 1
19088: PUSH
19089: LD_INT 22
19091: PUSH
19092: LD_OWVAR 2
19096: PUSH
19097: EMPTY
19098: LIST
19099: LIST
19100: PUSH
19101: LD_INT 2
19103: PUSH
19104: LD_INT 30
19106: PUSH
19107: LD_INT 0
19109: PUSH
19110: EMPTY
19111: LIST
19112: LIST
19113: PUSH
19114: LD_INT 30
19116: PUSH
19117: LD_INT 1
19119: PUSH
19120: EMPTY
19121: LIST
19122: LIST
19123: PUSH
19124: EMPTY
19125: LIST
19126: LIST
19127: LIST
19128: PUSH
19129: EMPTY
19130: LIST
19131: LIST
19132: PPUSH
19133: CALL_OW 69
19137: ST_TO_ADDR
// if not depot then
19138: LD_VAR 0 1
19142: NOT
19143: IFFALSE 19147
// exit ;
19145: GO 19182
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
19147: LD_VAR 0 1
19151: PUSH
19152: LD_INT 1
19154: ARRAY
19155: PPUSH
19156: CALL_OW 250
19160: PPUSH
19161: LD_VAR 0 1
19165: PUSH
19166: LD_INT 1
19168: ARRAY
19169: PPUSH
19170: CALL_OW 251
19174: PPUSH
19175: LD_INT 70
19177: PPUSH
19178: CALL_OW 495
// end ;
19182: PPOPN 1
19184: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
19185: LD_EXP 30
19189: PUSH
19190: LD_EXP 64
19194: AND
19195: IFFALSE 19406
19197: GO 19199
19199: DISABLE
19200: LD_INT 0
19202: PPUSH
19203: PPUSH
19204: PPUSH
19205: PPUSH
19206: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19207: LD_ADDR_VAR 0 5
19211: PUSH
19212: LD_INT 22
19214: PUSH
19215: LD_OWVAR 2
19219: PUSH
19220: EMPTY
19221: LIST
19222: LIST
19223: PUSH
19224: LD_INT 21
19226: PUSH
19227: LD_INT 1
19229: PUSH
19230: EMPTY
19231: LIST
19232: LIST
19233: PUSH
19234: EMPTY
19235: LIST
19236: LIST
19237: PPUSH
19238: CALL_OW 69
19242: ST_TO_ADDR
// if not tmp then
19243: LD_VAR 0 5
19247: NOT
19248: IFFALSE 19252
// exit ;
19250: GO 19406
// for i in tmp do
19252: LD_ADDR_VAR 0 1
19256: PUSH
19257: LD_VAR 0 5
19261: PUSH
19262: FOR_IN
19263: IFFALSE 19404
// begin d := rand ( 0 , 5 ) ;
19265: LD_ADDR_VAR 0 4
19269: PUSH
19270: LD_INT 0
19272: PPUSH
19273: LD_INT 5
19275: PPUSH
19276: CALL_OW 12
19280: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
19281: LD_ADDR_VAR 0 2
19285: PUSH
19286: LD_VAR 0 1
19290: PPUSH
19291: CALL_OW 250
19295: PPUSH
19296: LD_VAR 0 4
19300: PPUSH
19301: LD_INT 3
19303: PPUSH
19304: LD_INT 12
19306: PPUSH
19307: CALL_OW 12
19311: PPUSH
19312: CALL_OW 272
19316: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
19317: LD_ADDR_VAR 0 3
19321: PUSH
19322: LD_VAR 0 1
19326: PPUSH
19327: CALL_OW 251
19331: PPUSH
19332: LD_VAR 0 4
19336: PPUSH
19337: LD_INT 3
19339: PPUSH
19340: LD_INT 12
19342: PPUSH
19343: CALL_OW 12
19347: PPUSH
19348: CALL_OW 273
19352: ST_TO_ADDR
// if ValidHex ( x , y ) then
19353: LD_VAR 0 2
19357: PPUSH
19358: LD_VAR 0 3
19362: PPUSH
19363: CALL_OW 488
19367: IFFALSE 19402
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
19369: LD_VAR 0 1
19373: PPUSH
19374: LD_VAR 0 2
19378: PPUSH
19379: LD_VAR 0 3
19383: PPUSH
19384: LD_INT 3
19386: PPUSH
19387: LD_INT 6
19389: PPUSH
19390: CALL_OW 12
19394: PPUSH
19395: LD_INT 1
19397: PPUSH
19398: CALL_OW 483
// end ;
19402: GO 19262
19404: POP
19405: POP
// end ;
19406: PPOPN 5
19408: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
19409: LD_EXP 30
19413: PUSH
19414: LD_EXP 65
19418: AND
19419: IFFALSE 19513
19421: GO 19423
19423: DISABLE
19424: LD_INT 0
19426: PPUSH
19427: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
19428: LD_ADDR_VAR 0 2
19432: PUSH
19433: LD_INT 22
19435: PUSH
19436: LD_OWVAR 2
19440: PUSH
19441: EMPTY
19442: LIST
19443: LIST
19444: PUSH
19445: LD_INT 32
19447: PUSH
19448: LD_INT 1
19450: PUSH
19451: EMPTY
19452: LIST
19453: LIST
19454: PUSH
19455: LD_INT 21
19457: PUSH
19458: LD_INT 2
19460: PUSH
19461: EMPTY
19462: LIST
19463: LIST
19464: PUSH
19465: EMPTY
19466: LIST
19467: LIST
19468: LIST
19469: PPUSH
19470: CALL_OW 69
19474: ST_TO_ADDR
// if not tmp then
19475: LD_VAR 0 2
19479: NOT
19480: IFFALSE 19484
// exit ;
19482: GO 19513
// for i in tmp do
19484: LD_ADDR_VAR 0 1
19488: PUSH
19489: LD_VAR 0 2
19493: PUSH
19494: FOR_IN
19495: IFFALSE 19511
// SetFuel ( i , 0 ) ;
19497: LD_VAR 0 1
19501: PPUSH
19502: LD_INT 0
19504: PPUSH
19505: CALL_OW 240
19509: GO 19494
19511: POP
19512: POP
// end ;
19513: PPOPN 2
19515: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
19516: LD_EXP 30
19520: PUSH
19521: LD_EXP 66
19525: AND
19526: IFFALSE 19592
19528: GO 19530
19530: DISABLE
19531: LD_INT 0
19533: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
19534: LD_ADDR_VAR 0 1
19538: PUSH
19539: LD_INT 22
19541: PUSH
19542: LD_OWVAR 2
19546: PUSH
19547: EMPTY
19548: LIST
19549: LIST
19550: PUSH
19551: LD_INT 30
19553: PUSH
19554: LD_INT 29
19556: PUSH
19557: EMPTY
19558: LIST
19559: LIST
19560: PUSH
19561: EMPTY
19562: LIST
19563: LIST
19564: PPUSH
19565: CALL_OW 69
19569: ST_TO_ADDR
// if not tmp then
19570: LD_VAR 0 1
19574: NOT
19575: IFFALSE 19579
// exit ;
19577: GO 19592
// DestroyUnit ( tmp [ 1 ] ) ;
19579: LD_VAR 0 1
19583: PUSH
19584: LD_INT 1
19586: ARRAY
19587: PPUSH
19588: CALL_OW 65
// end ;
19592: PPOPN 1
19594: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
19595: LD_EXP 30
19599: PUSH
19600: LD_EXP 68
19604: AND
19605: IFFALSE 19734
19607: GO 19609
19609: DISABLE
19610: LD_INT 0
19612: PPUSH
// begin uc_side := 0 ;
19613: LD_ADDR_OWVAR 20
19617: PUSH
19618: LD_INT 0
19620: ST_TO_ADDR
// uc_nation := nation_arabian ;
19621: LD_ADDR_OWVAR 21
19625: PUSH
19626: LD_INT 2
19628: ST_TO_ADDR
// hc_gallery :=  ;
19629: LD_ADDR_OWVAR 33
19633: PUSH
19634: LD_STRING 
19636: ST_TO_ADDR
// hc_name :=  ;
19637: LD_ADDR_OWVAR 26
19641: PUSH
19642: LD_STRING 
19644: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
19645: LD_INT 1
19647: PPUSH
19648: LD_INT 11
19650: PPUSH
19651: LD_INT 10
19653: PPUSH
19654: CALL_OW 380
// un := CreateHuman ;
19658: LD_ADDR_VAR 0 1
19662: PUSH
19663: CALL_OW 44
19667: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19668: LD_VAR 0 1
19672: PPUSH
19673: LD_INT 1
19675: PPUSH
19676: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
19680: LD_INT 35
19682: PPUSH
19683: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
19687: LD_VAR 0 1
19691: PPUSH
19692: LD_INT 22
19694: PUSH
19695: LD_OWVAR 2
19699: PUSH
19700: EMPTY
19701: LIST
19702: LIST
19703: PPUSH
19704: CALL_OW 69
19708: PPUSH
19709: LD_VAR 0 1
19713: PPUSH
19714: CALL_OW 74
19718: PPUSH
19719: CALL_OW 115
// until IsDead ( un ) ;
19723: LD_VAR 0 1
19727: PPUSH
19728: CALL_OW 301
19732: IFFALSE 19680
// end ;
19734: PPOPN 1
19736: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
19737: LD_EXP 30
19741: PUSH
19742: LD_EXP 70
19746: AND
19747: IFFALSE 19759
19749: GO 19751
19751: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
19752: LD_STRING earthquake(getX(game), 0, 32)
19754: PPUSH
19755: CALL_OW 559
19759: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
19760: LD_EXP 30
19764: PUSH
19765: LD_EXP 71
19769: AND
19770: IFFALSE 19861
19772: GO 19774
19774: DISABLE
19775: LD_INT 0
19777: PPUSH
// begin enable ;
19778: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
19779: LD_ADDR_VAR 0 1
19783: PUSH
19784: LD_INT 22
19786: PUSH
19787: LD_OWVAR 2
19791: PUSH
19792: EMPTY
19793: LIST
19794: LIST
19795: PUSH
19796: LD_INT 21
19798: PUSH
19799: LD_INT 2
19801: PUSH
19802: EMPTY
19803: LIST
19804: LIST
19805: PUSH
19806: LD_INT 33
19808: PUSH
19809: LD_INT 3
19811: PUSH
19812: EMPTY
19813: LIST
19814: LIST
19815: PUSH
19816: EMPTY
19817: LIST
19818: LIST
19819: LIST
19820: PPUSH
19821: CALL_OW 69
19825: ST_TO_ADDR
// if not tmp then
19826: LD_VAR 0 1
19830: NOT
19831: IFFALSE 19835
// exit ;
19833: GO 19861
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
19835: LD_VAR 0 1
19839: PUSH
19840: LD_INT 1
19842: PPUSH
19843: LD_VAR 0 1
19847: PPUSH
19848: CALL_OW 12
19852: ARRAY
19853: PPUSH
19854: LD_INT 1
19856: PPUSH
19857: CALL_OW 234
// end ;
19861: PPOPN 1
19863: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
19864: LD_EXP 30
19868: PUSH
19869: LD_EXP 72
19873: AND
19874: IFFALSE 20015
19876: GO 19878
19878: DISABLE
19879: LD_INT 0
19881: PPUSH
19882: PPUSH
19883: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
19884: LD_ADDR_VAR 0 3
19888: PUSH
19889: LD_INT 22
19891: PUSH
19892: LD_OWVAR 2
19896: PUSH
19897: EMPTY
19898: LIST
19899: LIST
19900: PUSH
19901: LD_INT 25
19903: PUSH
19904: LD_INT 1
19906: PUSH
19907: EMPTY
19908: LIST
19909: LIST
19910: PUSH
19911: EMPTY
19912: LIST
19913: LIST
19914: PPUSH
19915: CALL_OW 69
19919: ST_TO_ADDR
// if not tmp then
19920: LD_VAR 0 3
19924: NOT
19925: IFFALSE 19929
// exit ;
19927: GO 20015
// un := tmp [ rand ( 1 , tmp ) ] ;
19929: LD_ADDR_VAR 0 2
19933: PUSH
19934: LD_VAR 0 3
19938: PUSH
19939: LD_INT 1
19941: PPUSH
19942: LD_VAR 0 3
19946: PPUSH
19947: CALL_OW 12
19951: ARRAY
19952: ST_TO_ADDR
// if Crawls ( un ) then
19953: LD_VAR 0 2
19957: PPUSH
19958: CALL_OW 318
19962: IFFALSE 19973
// ComWalk ( un ) ;
19964: LD_VAR 0 2
19968: PPUSH
19969: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
19973: LD_VAR 0 2
19977: PPUSH
19978: LD_INT 9
19980: PPUSH
19981: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
19985: LD_INT 28
19987: PPUSH
19988: LD_OWVAR 2
19992: PPUSH
19993: LD_INT 2
19995: PPUSH
19996: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
20000: LD_INT 29
20002: PPUSH
20003: LD_OWVAR 2
20007: PPUSH
20008: LD_INT 2
20010: PPUSH
20011: CALL_OW 322
// end ;
20015: PPOPN 3
20017: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
20018: LD_EXP 30
20022: PUSH
20023: LD_EXP 73
20027: AND
20028: IFFALSE 20139
20030: GO 20032
20032: DISABLE
20033: LD_INT 0
20035: PPUSH
20036: PPUSH
20037: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20038: LD_ADDR_VAR 0 3
20042: PUSH
20043: LD_INT 22
20045: PUSH
20046: LD_OWVAR 2
20050: PUSH
20051: EMPTY
20052: LIST
20053: LIST
20054: PUSH
20055: LD_INT 25
20057: PUSH
20058: LD_INT 1
20060: PUSH
20061: EMPTY
20062: LIST
20063: LIST
20064: PUSH
20065: EMPTY
20066: LIST
20067: LIST
20068: PPUSH
20069: CALL_OW 69
20073: ST_TO_ADDR
// if not tmp then
20074: LD_VAR 0 3
20078: NOT
20079: IFFALSE 20083
// exit ;
20081: GO 20139
// un := tmp [ rand ( 1 , tmp ) ] ;
20083: LD_ADDR_VAR 0 2
20087: PUSH
20088: LD_VAR 0 3
20092: PUSH
20093: LD_INT 1
20095: PPUSH
20096: LD_VAR 0 3
20100: PPUSH
20101: CALL_OW 12
20105: ARRAY
20106: ST_TO_ADDR
// if Crawls ( un ) then
20107: LD_VAR 0 2
20111: PPUSH
20112: CALL_OW 318
20116: IFFALSE 20127
// ComWalk ( un ) ;
20118: LD_VAR 0 2
20122: PPUSH
20123: CALL_OW 138
// SetClass ( un , class_mortar ) ;
20127: LD_VAR 0 2
20131: PPUSH
20132: LD_INT 8
20134: PPUSH
20135: CALL_OW 336
// end ;
20139: PPOPN 3
20141: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
20142: LD_EXP 30
20146: PUSH
20147: LD_EXP 74
20151: AND
20152: IFFALSE 20296
20154: GO 20156
20156: DISABLE
20157: LD_INT 0
20159: PPUSH
20160: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
20161: LD_ADDR_VAR 0 2
20165: PUSH
20166: LD_INT 22
20168: PUSH
20169: LD_OWVAR 2
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: PUSH
20178: LD_INT 21
20180: PUSH
20181: LD_INT 2
20183: PUSH
20184: EMPTY
20185: LIST
20186: LIST
20187: PUSH
20188: LD_INT 2
20190: PUSH
20191: LD_INT 34
20193: PUSH
20194: LD_INT 12
20196: PUSH
20197: EMPTY
20198: LIST
20199: LIST
20200: PUSH
20201: LD_INT 34
20203: PUSH
20204: LD_INT 51
20206: PUSH
20207: EMPTY
20208: LIST
20209: LIST
20210: PUSH
20211: LD_INT 34
20213: PUSH
20214: LD_INT 32
20216: PUSH
20217: EMPTY
20218: LIST
20219: LIST
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: LIST
20225: LIST
20226: PUSH
20227: EMPTY
20228: LIST
20229: LIST
20230: LIST
20231: PPUSH
20232: CALL_OW 69
20236: ST_TO_ADDR
// if not tmp then
20237: LD_VAR 0 2
20241: NOT
20242: IFFALSE 20246
// exit ;
20244: GO 20296
// for i in tmp do
20246: LD_ADDR_VAR 0 1
20250: PUSH
20251: LD_VAR 0 2
20255: PUSH
20256: FOR_IN
20257: IFFALSE 20294
// if GetCargo ( i , mat_artifact ) = 0 then
20259: LD_VAR 0 1
20263: PPUSH
20264: LD_INT 4
20266: PPUSH
20267: CALL_OW 289
20271: PUSH
20272: LD_INT 0
20274: EQUAL
20275: IFFALSE 20292
// SetCargo ( i , mat_siberit , 100 ) ;
20277: LD_VAR 0 1
20281: PPUSH
20282: LD_INT 3
20284: PPUSH
20285: LD_INT 100
20287: PPUSH
20288: CALL_OW 290
20292: GO 20256
20294: POP
20295: POP
// end ;
20296: PPOPN 2
20298: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
20299: LD_EXP 30
20303: PUSH
20304: LD_EXP 75
20308: AND
20309: IFFALSE 20462
20311: GO 20313
20313: DISABLE
20314: LD_INT 0
20316: PPUSH
20317: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
20318: LD_ADDR_VAR 0 2
20322: PUSH
20323: LD_INT 22
20325: PUSH
20326: LD_OWVAR 2
20330: PUSH
20331: EMPTY
20332: LIST
20333: LIST
20334: PPUSH
20335: CALL_OW 69
20339: ST_TO_ADDR
// if not tmp then
20340: LD_VAR 0 2
20344: NOT
20345: IFFALSE 20349
// exit ;
20347: GO 20462
// for i := 1 to 2 do
20349: LD_ADDR_VAR 0 1
20353: PUSH
20354: DOUBLE
20355: LD_INT 1
20357: DEC
20358: ST_TO_ADDR
20359: LD_INT 2
20361: PUSH
20362: FOR_TO
20363: IFFALSE 20460
// begin uc_side := your_side ;
20365: LD_ADDR_OWVAR 20
20369: PUSH
20370: LD_OWVAR 2
20374: ST_TO_ADDR
// uc_nation := nation_american ;
20375: LD_ADDR_OWVAR 21
20379: PUSH
20380: LD_INT 1
20382: ST_TO_ADDR
// vc_chassis := us_morphling ;
20383: LD_ADDR_OWVAR 37
20387: PUSH
20388: LD_INT 5
20390: ST_TO_ADDR
// vc_engine := engine_siberite ;
20391: LD_ADDR_OWVAR 39
20395: PUSH
20396: LD_INT 3
20398: ST_TO_ADDR
// vc_control := control_computer ;
20399: LD_ADDR_OWVAR 38
20403: PUSH
20404: LD_INT 3
20406: ST_TO_ADDR
// vc_weapon := us_double_laser ;
20407: LD_ADDR_OWVAR 40
20411: PUSH
20412: LD_INT 10
20414: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
20415: CALL_OW 45
20419: PPUSH
20420: LD_VAR 0 2
20424: PUSH
20425: LD_INT 1
20427: ARRAY
20428: PPUSH
20429: CALL_OW 250
20433: PPUSH
20434: LD_VAR 0 2
20438: PUSH
20439: LD_INT 1
20441: ARRAY
20442: PPUSH
20443: CALL_OW 251
20447: PPUSH
20448: LD_INT 12
20450: PPUSH
20451: LD_INT 1
20453: PPUSH
20454: CALL_OW 50
// end ;
20458: GO 20362
20460: POP
20461: POP
// end ;
20462: PPOPN 2
20464: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
20465: LD_EXP 30
20469: PUSH
20470: LD_EXP 76
20474: AND
20475: IFFALSE 20697
20477: GO 20479
20479: DISABLE
20480: LD_INT 0
20482: PPUSH
20483: PPUSH
20484: PPUSH
20485: PPUSH
20486: PPUSH
20487: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
20488: LD_ADDR_VAR 0 6
20492: PUSH
20493: LD_INT 22
20495: PUSH
20496: LD_OWVAR 2
20500: PUSH
20501: EMPTY
20502: LIST
20503: LIST
20504: PUSH
20505: LD_INT 21
20507: PUSH
20508: LD_INT 1
20510: PUSH
20511: EMPTY
20512: LIST
20513: LIST
20514: PUSH
20515: LD_INT 3
20517: PUSH
20518: LD_INT 23
20520: PUSH
20521: LD_INT 0
20523: PUSH
20524: EMPTY
20525: LIST
20526: LIST
20527: PUSH
20528: EMPTY
20529: LIST
20530: LIST
20531: PUSH
20532: EMPTY
20533: LIST
20534: LIST
20535: LIST
20536: PPUSH
20537: CALL_OW 69
20541: ST_TO_ADDR
// if not tmp then
20542: LD_VAR 0 6
20546: NOT
20547: IFFALSE 20551
// exit ;
20549: GO 20697
// s1 := rand ( 1 , 4 ) ;
20551: LD_ADDR_VAR 0 2
20555: PUSH
20556: LD_INT 1
20558: PPUSH
20559: LD_INT 4
20561: PPUSH
20562: CALL_OW 12
20566: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
20567: LD_ADDR_VAR 0 4
20571: PUSH
20572: LD_VAR 0 6
20576: PUSH
20577: LD_INT 1
20579: ARRAY
20580: PPUSH
20581: LD_VAR 0 2
20585: PPUSH
20586: CALL_OW 259
20590: ST_TO_ADDR
// if s1 = 1 then
20591: LD_VAR 0 2
20595: PUSH
20596: LD_INT 1
20598: EQUAL
20599: IFFALSE 20619
// s2 := rand ( 2 , 4 ) else
20601: LD_ADDR_VAR 0 3
20605: PUSH
20606: LD_INT 2
20608: PPUSH
20609: LD_INT 4
20611: PPUSH
20612: CALL_OW 12
20616: ST_TO_ADDR
20617: GO 20627
// s2 := 1 ;
20619: LD_ADDR_VAR 0 3
20623: PUSH
20624: LD_INT 1
20626: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
20627: LD_ADDR_VAR 0 5
20631: PUSH
20632: LD_VAR 0 6
20636: PUSH
20637: LD_INT 1
20639: ARRAY
20640: PPUSH
20641: LD_VAR 0 3
20645: PPUSH
20646: CALL_OW 259
20650: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
20651: LD_VAR 0 6
20655: PUSH
20656: LD_INT 1
20658: ARRAY
20659: PPUSH
20660: LD_VAR 0 2
20664: PPUSH
20665: LD_VAR 0 5
20669: PPUSH
20670: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
20674: LD_VAR 0 6
20678: PUSH
20679: LD_INT 1
20681: ARRAY
20682: PPUSH
20683: LD_VAR 0 3
20687: PPUSH
20688: LD_VAR 0 4
20692: PPUSH
20693: CALL_OW 237
// end ;
20697: PPOPN 6
20699: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
20700: LD_EXP 30
20704: PUSH
20705: LD_EXP 77
20709: AND
20710: IFFALSE 20789
20712: GO 20714
20714: DISABLE
20715: LD_INT 0
20717: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
20718: LD_ADDR_VAR 0 1
20722: PUSH
20723: LD_INT 22
20725: PUSH
20726: LD_OWVAR 2
20730: PUSH
20731: EMPTY
20732: LIST
20733: LIST
20734: PUSH
20735: LD_INT 30
20737: PUSH
20738: LD_INT 3
20740: PUSH
20741: EMPTY
20742: LIST
20743: LIST
20744: PUSH
20745: EMPTY
20746: LIST
20747: LIST
20748: PPUSH
20749: CALL_OW 69
20753: ST_TO_ADDR
// if not tmp then
20754: LD_VAR 0 1
20758: NOT
20759: IFFALSE 20763
// exit ;
20761: GO 20789
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
20763: LD_VAR 0 1
20767: PUSH
20768: LD_INT 1
20770: PPUSH
20771: LD_VAR 0 1
20775: PPUSH
20776: CALL_OW 12
20780: ARRAY
20781: PPUSH
20782: LD_INT 1
20784: PPUSH
20785: CALL_OW 234
// end ;
20789: PPOPN 1
20791: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
20792: LD_EXP 30
20796: PUSH
20797: LD_EXP 78
20801: AND
20802: IFFALSE 20914
20804: GO 20806
20806: DISABLE
20807: LD_INT 0
20809: PPUSH
20810: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
20811: LD_ADDR_VAR 0 2
20815: PUSH
20816: LD_INT 22
20818: PUSH
20819: LD_OWVAR 2
20823: PUSH
20824: EMPTY
20825: LIST
20826: LIST
20827: PUSH
20828: LD_INT 2
20830: PUSH
20831: LD_INT 30
20833: PUSH
20834: LD_INT 27
20836: PUSH
20837: EMPTY
20838: LIST
20839: LIST
20840: PUSH
20841: LD_INT 30
20843: PUSH
20844: LD_INT 26
20846: PUSH
20847: EMPTY
20848: LIST
20849: LIST
20850: PUSH
20851: LD_INT 30
20853: PUSH
20854: LD_INT 28
20856: PUSH
20857: EMPTY
20858: LIST
20859: LIST
20860: PUSH
20861: EMPTY
20862: LIST
20863: LIST
20864: LIST
20865: LIST
20866: PUSH
20867: EMPTY
20868: LIST
20869: LIST
20870: PPUSH
20871: CALL_OW 69
20875: ST_TO_ADDR
// if not tmp then
20876: LD_VAR 0 2
20880: NOT
20881: IFFALSE 20885
// exit ;
20883: GO 20914
// for i in tmp do
20885: LD_ADDR_VAR 0 1
20889: PUSH
20890: LD_VAR 0 2
20894: PUSH
20895: FOR_IN
20896: IFFALSE 20912
// SetLives ( i , 1 ) ;
20898: LD_VAR 0 1
20902: PPUSH
20903: LD_INT 1
20905: PPUSH
20906: CALL_OW 234
20910: GO 20895
20912: POP
20913: POP
// end ;
20914: PPOPN 2
20916: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
20917: LD_EXP 30
20921: PUSH
20922: LD_EXP 79
20926: AND
20927: IFFALSE 21201
20929: GO 20931
20931: DISABLE
20932: LD_INT 0
20934: PPUSH
20935: PPUSH
20936: PPUSH
// begin i := rand ( 1 , 7 ) ;
20937: LD_ADDR_VAR 0 1
20941: PUSH
20942: LD_INT 1
20944: PPUSH
20945: LD_INT 7
20947: PPUSH
20948: CALL_OW 12
20952: ST_TO_ADDR
// case i of 1 :
20953: LD_VAR 0 1
20957: PUSH
20958: LD_INT 1
20960: DOUBLE
20961: EQUAL
20962: IFTRUE 20966
20964: GO 20976
20966: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
20967: LD_STRING earthquake(getX(game), 0, 32)
20969: PPUSH
20970: CALL_OW 559
20974: GO 21201
20976: LD_INT 2
20978: DOUBLE
20979: EQUAL
20980: IFTRUE 20984
20982: GO 20998
20984: POP
// begin ToLua ( displayStucuk(); ) ;
20985: LD_STRING displayStucuk();
20987: PPUSH
20988: CALL_OW 559
// ResetFog ;
20992: CALL_OW 335
// end ; 3 :
20996: GO 21201
20998: LD_INT 3
21000: DOUBLE
21001: EQUAL
21002: IFTRUE 21006
21004: GO 21110
21006: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21007: LD_ADDR_VAR 0 2
21011: PUSH
21012: LD_INT 22
21014: PUSH
21015: LD_OWVAR 2
21019: PUSH
21020: EMPTY
21021: LIST
21022: LIST
21023: PUSH
21024: LD_INT 25
21026: PUSH
21027: LD_INT 1
21029: PUSH
21030: EMPTY
21031: LIST
21032: LIST
21033: PUSH
21034: EMPTY
21035: LIST
21036: LIST
21037: PPUSH
21038: CALL_OW 69
21042: ST_TO_ADDR
// if not tmp then
21043: LD_VAR 0 2
21047: NOT
21048: IFFALSE 21052
// exit ;
21050: GO 21201
// un := tmp [ rand ( 1 , tmp ) ] ;
21052: LD_ADDR_VAR 0 3
21056: PUSH
21057: LD_VAR 0 2
21061: PUSH
21062: LD_INT 1
21064: PPUSH
21065: LD_VAR 0 2
21069: PPUSH
21070: CALL_OW 12
21074: ARRAY
21075: ST_TO_ADDR
// if Crawls ( un ) then
21076: LD_VAR 0 3
21080: PPUSH
21081: CALL_OW 318
21085: IFFALSE 21096
// ComWalk ( un ) ;
21087: LD_VAR 0 3
21091: PPUSH
21092: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21096: LD_VAR 0 3
21100: PPUSH
21101: LD_INT 8
21103: PPUSH
21104: CALL_OW 336
// end ; 4 :
21108: GO 21201
21110: LD_INT 4
21112: DOUBLE
21113: EQUAL
21114: IFTRUE 21118
21116: GO 21179
21118: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
21119: LD_ADDR_VAR 0 2
21123: PUSH
21124: LD_INT 22
21126: PUSH
21127: LD_OWVAR 2
21131: PUSH
21132: EMPTY
21133: LIST
21134: LIST
21135: PUSH
21136: LD_INT 30
21138: PUSH
21139: LD_INT 29
21141: PUSH
21142: EMPTY
21143: LIST
21144: LIST
21145: PUSH
21146: EMPTY
21147: LIST
21148: LIST
21149: PPUSH
21150: CALL_OW 69
21154: ST_TO_ADDR
// if not tmp then
21155: LD_VAR 0 2
21159: NOT
21160: IFFALSE 21164
// exit ;
21162: GO 21201
// DestroyUnit ( tmp [ 1 ] ) ;
21164: LD_VAR 0 2
21168: PUSH
21169: LD_INT 1
21171: ARRAY
21172: PPUSH
21173: CALL_OW 65
// end ; 5 .. 7 :
21177: GO 21201
21179: LD_INT 5
21181: DOUBLE
21182: GREATEREQUAL
21183: IFFALSE 21191
21185: LD_INT 7
21187: DOUBLE
21188: LESSEQUAL
21189: IFTRUE 21193
21191: GO 21200
21193: POP
// StreamSibBomb ; end ;
21194: CALL 17481 0 0
21198: GO 21201
21200: POP
// end ;
21201: PPOPN 3
21203: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
21204: LD_EXP 30
21208: PUSH
21209: LD_EXP 80
21213: AND
21214: IFFALSE 21370
21216: GO 21218
21218: DISABLE
21219: LD_INT 0
21221: PPUSH
21222: PPUSH
21223: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
21224: LD_ADDR_VAR 0 2
21228: PUSH
21229: LD_INT 81
21231: PUSH
21232: LD_OWVAR 2
21236: PUSH
21237: EMPTY
21238: LIST
21239: LIST
21240: PUSH
21241: LD_INT 2
21243: PUSH
21244: LD_INT 21
21246: PUSH
21247: LD_INT 1
21249: PUSH
21250: EMPTY
21251: LIST
21252: LIST
21253: PUSH
21254: LD_INT 21
21256: PUSH
21257: LD_INT 2
21259: PUSH
21260: EMPTY
21261: LIST
21262: LIST
21263: PUSH
21264: EMPTY
21265: LIST
21266: LIST
21267: LIST
21268: PUSH
21269: EMPTY
21270: LIST
21271: LIST
21272: PPUSH
21273: CALL_OW 69
21277: ST_TO_ADDR
// if not tmp then
21278: LD_VAR 0 2
21282: NOT
21283: IFFALSE 21287
// exit ;
21285: GO 21370
// p := 0 ;
21287: LD_ADDR_VAR 0 3
21291: PUSH
21292: LD_INT 0
21294: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21295: LD_INT 35
21297: PPUSH
21298: CALL_OW 67
// p := p + 1 ;
21302: LD_ADDR_VAR 0 3
21306: PUSH
21307: LD_VAR 0 3
21311: PUSH
21312: LD_INT 1
21314: PLUS
21315: ST_TO_ADDR
// for i in tmp do
21316: LD_ADDR_VAR 0 1
21320: PUSH
21321: LD_VAR 0 2
21325: PUSH
21326: FOR_IN
21327: IFFALSE 21358
// if GetLives ( i ) < 1000 then
21329: LD_VAR 0 1
21333: PPUSH
21334: CALL_OW 256
21338: PUSH
21339: LD_INT 1000
21341: LESS
21342: IFFALSE 21356
// SetLives ( i , 1000 ) ;
21344: LD_VAR 0 1
21348: PPUSH
21349: LD_INT 1000
21351: PPUSH
21352: CALL_OW 234
21356: GO 21326
21358: POP
21359: POP
// until p > 20 ;
21360: LD_VAR 0 3
21364: PUSH
21365: LD_INT 20
21367: GREATER
21368: IFFALSE 21295
// end ;
21370: PPOPN 3
21372: END
// every 0 0$1 trigger StreamModeActive and sTime do
21373: LD_EXP 30
21377: PUSH
21378: LD_EXP 81
21382: AND
21383: IFFALSE 21418
21385: GO 21387
21387: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
21388: LD_INT 28
21390: PPUSH
21391: LD_OWVAR 2
21395: PPUSH
21396: LD_INT 2
21398: PPUSH
21399: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
21403: LD_INT 30
21405: PPUSH
21406: LD_OWVAR 2
21410: PPUSH
21411: LD_INT 2
21413: PPUSH
21414: CALL_OW 322
// end ;
21418: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
21419: LD_EXP 30
21423: PUSH
21424: LD_EXP 82
21428: AND
21429: IFFALSE 21550
21431: GO 21433
21433: DISABLE
21434: LD_INT 0
21436: PPUSH
21437: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21438: LD_ADDR_VAR 0 2
21442: PUSH
21443: LD_INT 22
21445: PUSH
21446: LD_OWVAR 2
21450: PUSH
21451: EMPTY
21452: LIST
21453: LIST
21454: PUSH
21455: LD_INT 21
21457: PUSH
21458: LD_INT 1
21460: PUSH
21461: EMPTY
21462: LIST
21463: LIST
21464: PUSH
21465: LD_INT 3
21467: PUSH
21468: LD_INT 23
21470: PUSH
21471: LD_INT 0
21473: PUSH
21474: EMPTY
21475: LIST
21476: LIST
21477: PUSH
21478: EMPTY
21479: LIST
21480: LIST
21481: PUSH
21482: EMPTY
21483: LIST
21484: LIST
21485: LIST
21486: PPUSH
21487: CALL_OW 69
21491: ST_TO_ADDR
// if not tmp then
21492: LD_VAR 0 2
21496: NOT
21497: IFFALSE 21501
// exit ;
21499: GO 21550
// for i in tmp do
21501: LD_ADDR_VAR 0 1
21505: PUSH
21506: LD_VAR 0 2
21510: PUSH
21511: FOR_IN
21512: IFFALSE 21548
// begin if Crawls ( i ) then
21514: LD_VAR 0 1
21518: PPUSH
21519: CALL_OW 318
21523: IFFALSE 21534
// ComWalk ( i ) ;
21525: LD_VAR 0 1
21529: PPUSH
21530: CALL_OW 138
// SetClass ( i , 2 ) ;
21534: LD_VAR 0 1
21538: PPUSH
21539: LD_INT 2
21541: PPUSH
21542: CALL_OW 336
// end ;
21546: GO 21511
21548: POP
21549: POP
// end ;
21550: PPOPN 2
21552: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
21553: LD_EXP 30
21557: PUSH
21558: LD_EXP 83
21562: AND
21563: IFFALSE 21844
21565: GO 21567
21567: DISABLE
21568: LD_INT 0
21570: PPUSH
21571: PPUSH
21572: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
21573: LD_OWVAR 2
21577: PPUSH
21578: LD_INT 9
21580: PPUSH
21581: LD_INT 1
21583: PPUSH
21584: LD_INT 1
21586: PPUSH
21587: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
21591: LD_INT 9
21593: PPUSH
21594: LD_OWVAR 2
21598: PPUSH
21599: CALL_OW 343
// uc_side := 9 ;
21603: LD_ADDR_OWVAR 20
21607: PUSH
21608: LD_INT 9
21610: ST_TO_ADDR
// uc_nation := 2 ;
21611: LD_ADDR_OWVAR 21
21615: PUSH
21616: LD_INT 2
21618: ST_TO_ADDR
// hc_name := Dark Warrior ;
21619: LD_ADDR_OWVAR 26
21623: PUSH
21624: LD_STRING Dark Warrior
21626: ST_TO_ADDR
// hc_gallery :=  ;
21627: LD_ADDR_OWVAR 33
21631: PUSH
21632: LD_STRING 
21634: ST_TO_ADDR
// hc_noskilllimit := true ;
21635: LD_ADDR_OWVAR 76
21639: PUSH
21640: LD_INT 1
21642: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
21643: LD_ADDR_OWVAR 31
21647: PUSH
21648: LD_INT 30
21650: PUSH
21651: LD_INT 30
21653: PUSH
21654: LD_INT 30
21656: PUSH
21657: LD_INT 30
21659: PUSH
21660: EMPTY
21661: LIST
21662: LIST
21663: LIST
21664: LIST
21665: ST_TO_ADDR
// un := CreateHuman ;
21666: LD_ADDR_VAR 0 3
21670: PUSH
21671: CALL_OW 44
21675: ST_TO_ADDR
// hc_noskilllimit := false ;
21676: LD_ADDR_OWVAR 76
21680: PUSH
21681: LD_INT 0
21683: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
21684: LD_VAR 0 3
21688: PPUSH
21689: LD_INT 1
21691: PPUSH
21692: CALL_OW 51
// p := 0 ;
21696: LD_ADDR_VAR 0 2
21700: PUSH
21701: LD_INT 0
21703: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21704: LD_INT 35
21706: PPUSH
21707: CALL_OW 67
// p := p + 1 ;
21711: LD_ADDR_VAR 0 2
21715: PUSH
21716: LD_VAR 0 2
21720: PUSH
21721: LD_INT 1
21723: PLUS
21724: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
21725: LD_VAR 0 3
21729: PPUSH
21730: CALL_OW 256
21734: PUSH
21735: LD_INT 1000
21737: LESS
21738: IFFALSE 21752
// SetLives ( un , 1000 ) ;
21740: LD_VAR 0 3
21744: PPUSH
21745: LD_INT 1000
21747: PPUSH
21748: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
21752: LD_VAR 0 3
21756: PPUSH
21757: LD_INT 81
21759: PUSH
21760: LD_OWVAR 2
21764: PUSH
21765: EMPTY
21766: LIST
21767: LIST
21768: PUSH
21769: LD_INT 91
21771: PUSH
21772: LD_VAR 0 3
21776: PUSH
21777: LD_INT 30
21779: PUSH
21780: EMPTY
21781: LIST
21782: LIST
21783: LIST
21784: PUSH
21785: EMPTY
21786: LIST
21787: LIST
21788: PPUSH
21789: CALL_OW 69
21793: PPUSH
21794: LD_VAR 0 3
21798: PPUSH
21799: CALL_OW 74
21803: PPUSH
21804: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
21808: LD_VAR 0 2
21812: PUSH
21813: LD_INT 60
21815: GREATER
21816: PUSH
21817: LD_VAR 0 3
21821: PPUSH
21822: CALL_OW 301
21826: OR
21827: IFFALSE 21704
// if un then
21829: LD_VAR 0 3
21833: IFFALSE 21844
// RemoveUnit ( un ) ;
21835: LD_VAR 0 3
21839: PPUSH
21840: CALL_OW 64
// end ; end_of_file
21844: PPOPN 3
21846: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
21847: LD_INT 0
21849: PPUSH
21850: PPUSH
21851: PPUSH
21852: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
21853: LD_VAR 0 1
21857: PPUSH
21858: CALL_OW 264
21862: PUSH
21863: LD_EXP 29
21867: EQUAL
21868: IFFALSE 21940
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
21870: LD_INT 68
21872: PPUSH
21873: LD_VAR 0 1
21877: PPUSH
21878: CALL_OW 255
21882: PPUSH
21883: CALL_OW 321
21887: PUSH
21888: LD_INT 2
21890: EQUAL
21891: IFFALSE 21903
// eff := 70 else
21893: LD_ADDR_VAR 0 4
21897: PUSH
21898: LD_INT 70
21900: ST_TO_ADDR
21901: GO 21911
// eff := 30 ;
21903: LD_ADDR_VAR 0 4
21907: PUSH
21908: LD_INT 30
21910: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
21911: LD_VAR 0 1
21915: PPUSH
21916: CALL_OW 250
21920: PPUSH
21921: LD_VAR 0 1
21925: PPUSH
21926: CALL_OW 251
21930: PPUSH
21931: LD_VAR 0 4
21935: PPUSH
21936: CALL_OW 495
// end ; end ;
21940: LD_VAR 0 2
21944: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
21945: LD_INT 0
21947: PPUSH
// end ;
21948: LD_VAR 0 4
21952: RET
// export function SOS_Command ( cmd ) ; begin
21953: LD_INT 0
21955: PPUSH
// end ;
21956: LD_VAR 0 2
21960: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
21961: LD_VAR 0 1
21965: PUSH
21966: LD_INT 255
21968: EQUAL
21969: PUSH
21970: LD_VAR 0 2
21974: PPUSH
21975: CALL_OW 264
21979: PUSH
21980: LD_INT 14
21982: PUSH
21983: LD_INT 53
21985: PUSH
21986: EMPTY
21987: LIST
21988: LIST
21989: IN
21990: AND
21991: PUSH
21992: LD_VAR 0 4
21996: PPUSH
21997: LD_VAR 0 5
22001: PPUSH
22002: CALL_OW 488
22006: AND
22007: IFFALSE 22031
// CutTreeXYR ( unit , x , y , 12 ) ;
22009: LD_VAR 0 2
22013: PPUSH
22014: LD_VAR 0 4
22018: PPUSH
22019: LD_VAR 0 5
22023: PPUSH
22024: LD_INT 12
22026: PPUSH
22027: CALL 22034 0 4
// end ;
22031: PPOPN 5
22033: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
22034: LD_INT 0
22036: PPUSH
22037: PPUSH
22038: PPUSH
22039: PPUSH
22040: PPUSH
22041: PPUSH
22042: PPUSH
22043: PPUSH
22044: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
22045: LD_VAR 0 1
22049: NOT
22050: PUSH
22051: LD_VAR 0 2
22055: PPUSH
22056: LD_VAR 0 3
22060: PPUSH
22061: CALL_OW 488
22065: NOT
22066: OR
22067: PUSH
22068: LD_VAR 0 4
22072: NOT
22073: OR
22074: IFFALSE 22078
// exit ;
22076: GO 22418
// list := [ ] ;
22078: LD_ADDR_VAR 0 13
22082: PUSH
22083: EMPTY
22084: ST_TO_ADDR
// if x - r < 0 then
22085: LD_VAR 0 2
22089: PUSH
22090: LD_VAR 0 4
22094: MINUS
22095: PUSH
22096: LD_INT 0
22098: LESS
22099: IFFALSE 22111
// min_x := 0 else
22101: LD_ADDR_VAR 0 7
22105: PUSH
22106: LD_INT 0
22108: ST_TO_ADDR
22109: GO 22127
// min_x := x - r ;
22111: LD_ADDR_VAR 0 7
22115: PUSH
22116: LD_VAR 0 2
22120: PUSH
22121: LD_VAR 0 4
22125: MINUS
22126: ST_TO_ADDR
// if y - r < 0 then
22127: LD_VAR 0 3
22131: PUSH
22132: LD_VAR 0 4
22136: MINUS
22137: PUSH
22138: LD_INT 0
22140: LESS
22141: IFFALSE 22153
// min_y := 0 else
22143: LD_ADDR_VAR 0 8
22147: PUSH
22148: LD_INT 0
22150: ST_TO_ADDR
22151: GO 22169
// min_y := y - r ;
22153: LD_ADDR_VAR 0 8
22157: PUSH
22158: LD_VAR 0 3
22162: PUSH
22163: LD_VAR 0 4
22167: MINUS
22168: ST_TO_ADDR
// max_x := x + r ;
22169: LD_ADDR_VAR 0 9
22173: PUSH
22174: LD_VAR 0 2
22178: PUSH
22179: LD_VAR 0 4
22183: PLUS
22184: ST_TO_ADDR
// max_y := y + r ;
22185: LD_ADDR_VAR 0 10
22189: PUSH
22190: LD_VAR 0 3
22194: PUSH
22195: LD_VAR 0 4
22199: PLUS
22200: ST_TO_ADDR
// for _x = min_x to max_x do
22201: LD_ADDR_VAR 0 11
22205: PUSH
22206: DOUBLE
22207: LD_VAR 0 7
22211: DEC
22212: ST_TO_ADDR
22213: LD_VAR 0 9
22217: PUSH
22218: FOR_TO
22219: IFFALSE 22336
// for _y = min_y to max_y do
22221: LD_ADDR_VAR 0 12
22225: PUSH
22226: DOUBLE
22227: LD_VAR 0 8
22231: DEC
22232: ST_TO_ADDR
22233: LD_VAR 0 10
22237: PUSH
22238: FOR_TO
22239: IFFALSE 22332
// begin if not ValidHex ( _x , _y ) then
22241: LD_VAR 0 11
22245: PPUSH
22246: LD_VAR 0 12
22250: PPUSH
22251: CALL_OW 488
22255: NOT
22256: IFFALSE 22260
// continue ;
22258: GO 22238
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
22260: LD_VAR 0 11
22264: PPUSH
22265: LD_VAR 0 12
22269: PPUSH
22270: CALL_OW 351
22274: PUSH
22275: LD_VAR 0 11
22279: PPUSH
22280: LD_VAR 0 12
22284: PPUSH
22285: CALL_OW 554
22289: AND
22290: IFFALSE 22330
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
22292: LD_ADDR_VAR 0 13
22296: PUSH
22297: LD_VAR 0 13
22301: PPUSH
22302: LD_VAR 0 13
22306: PUSH
22307: LD_INT 1
22309: PLUS
22310: PPUSH
22311: LD_VAR 0 11
22315: PUSH
22316: LD_VAR 0 12
22320: PUSH
22321: EMPTY
22322: LIST
22323: LIST
22324: PPUSH
22325: CALL_OW 2
22329: ST_TO_ADDR
// end ;
22330: GO 22238
22332: POP
22333: POP
22334: GO 22218
22336: POP
22337: POP
// if not list then
22338: LD_VAR 0 13
22342: NOT
22343: IFFALSE 22347
// exit ;
22345: GO 22418
// for i in list do
22347: LD_ADDR_VAR 0 6
22351: PUSH
22352: LD_VAR 0 13
22356: PUSH
22357: FOR_IN
22358: IFFALSE 22416
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
22360: LD_VAR 0 1
22364: PPUSH
22365: LD_STRING M
22367: PUSH
22368: LD_VAR 0 6
22372: PUSH
22373: LD_INT 1
22375: ARRAY
22376: PUSH
22377: LD_VAR 0 6
22381: PUSH
22382: LD_INT 2
22384: ARRAY
22385: PUSH
22386: LD_INT 0
22388: PUSH
22389: LD_INT 0
22391: PUSH
22392: LD_INT 0
22394: PUSH
22395: LD_INT 0
22397: PUSH
22398: EMPTY
22399: LIST
22400: LIST
22401: LIST
22402: LIST
22403: LIST
22404: LIST
22405: LIST
22406: PUSH
22407: EMPTY
22408: LIST
22409: PPUSH
22410: CALL_OW 447
22414: GO 22357
22416: POP
22417: POP
// end ;
22418: LD_VAR 0 5
22422: RET
