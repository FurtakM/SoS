// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 66 0 0
// Action ;
  15: CALL 8165 0 0
// PrepareAnimals ( 6 , 3 , 4 , apearea ) ;
  19: LD_INT 6
  21: PPUSH
  22: LD_INT 3
  24: PPUSH
  25: LD_INT 4
  27: PPUSH
  28: LD_INT 21
  30: PPUSH
  31: CALL 10470 0 4
// PrepareAmerican ;
  35: CALL 3957 0 0
// PrepareRussian ;
  39: CALL 277 0 0
// end ;
  43: END
// every 0 0$01 do
  44: GO 46
  46: DISABLE
// begin enable ;
  47: ENABLE
// display_strings := [ #tick , tick ] ;
  48: LD_ADDR_OWVAR 47
  52: PUSH
  53: LD_STRING #tick
  55: PUSH
  56: LD_OWVAR 1
  60: PUSH
  61: EMPTY
  62: LIST
  63: LIST
  64: ST_TO_ADDR
// end ;
  65: END
// export conv_squad , escort , medal1 , medal2 , medal3 , path , convoy_start , dest_counter ; export riv , ar_attacks , ar_force , us_force , conv_counter , crates_counter ; function Init ; begin
  66: LD_INT 0
  68: PPUSH
// medal1 := true ;
  69: LD_ADDR_EXP 3
  73: PUSH
  74: LD_INT 1
  76: ST_TO_ADDR
// medal2 := true ;
  77: LD_ADDR_EXP 4
  81: PUSH
  82: LD_INT 1
  84: ST_TO_ADDR
// medal3 := true ;
  85: LD_ADDR_EXP 5
  89: PUSH
  90: LD_INT 1
  92: ST_TO_ADDR
// path := [ p1 , p2 , p3 , p4 , conv_end ] ;
  93: LD_ADDR_EXP 6
  97: PUSH
  98: LD_INT 10
 100: PUSH
 101: LD_INT 11
 103: PUSH
 104: LD_INT 12
 106: PUSH
 107: LD_INT 13
 109: PUSH
 110: LD_INT 9
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: LIST
 118: LIST
 119: ST_TO_ADDR
// conv_squad := [ ] ;
 120: LD_ADDR_EXP 1
 124: PUSH
 125: EMPTY
 126: ST_TO_ADDR
// escort := [ ] ;
 127: LD_ADDR_EXP 2
 131: PUSH
 132: EMPTY
 133: ST_TO_ADDR
// riv := [ ] ;
 134: LD_ADDR_EXP 9
 138: PUSH
 139: EMPTY
 140: ST_TO_ADDR
// ar_force := [ ] ;
 141: LD_ADDR_EXP 11
 145: PUSH
 146: EMPTY
 147: ST_TO_ADDR
// ar_attacks := false ;
 148: LD_ADDR_EXP 10
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// us_force := [ ] ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: EMPTY
 162: ST_TO_ADDR
// convoy_start := false ;
 163: LD_ADDR_EXP 7
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// conv_counter := 0 ;
 171: LD_ADDR_EXP 13
 175: PUSH
 176: LD_INT 0
 178: ST_TO_ADDR
// dest_counter := 0 ;
 179: LD_ADDR_EXP 8
 183: PUSH
 184: LD_INT 0
 186: ST_TO_ADDR
// crates_counter := 0 0$40 ;
 187: LD_ADDR_EXP 14
 191: PUSH
 192: LD_INT 1400
 194: ST_TO_ADDR
// end ;
 195: LD_VAR 0 1
 199: RET
// every 2 2$00 do
 200: GO 202
 202: DISABLE
// begin while ( tick <= [ 47 47$00 , 44 44$00 , 41 41$00 ] [ Difficulty ] ) do
 203: LD_OWVAR 1
 207: PUSH
 208: LD_INT 98700
 210: PUSH
 211: LD_INT 92400
 213: PUSH
 214: LD_INT 86100
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: PUSH
 222: LD_OWVAR 67
 226: ARRAY
 227: LESSEQUAL
 228: IFFALSE 276
// begin Wait ( crates_counter ) ;
 230: LD_EXP 14
 234: PPUSH
 235: CALL_OW 67
// crates_counter := crates_counter + 0 0$09 ;
 239: LD_ADDR_EXP 14
 243: PUSH
 244: LD_EXP 14
 248: PUSH
 249: LD_INT 315
 251: PLUS
 252: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 5
 258: PPUSH
 259: CALL_OW 12
 263: PPUSH
 264: LD_INT 22
 266: PPUSH
 267: LD_INT 1
 269: PPUSH
 270: CALL_OW 55
// end ;
 274: GO 203
// end ; end_of_file
 276: END
// export Stolypin , Popov , Saseda ; export function PrepareRussian ; var un , force , i , c , skill , team ; begin
 277: LD_INT 0
 279: PPUSH
 280: PPUSH
 281: PPUSH
 282: PPUSH
 283: PPUSH
 284: PPUSH
 285: PPUSH
// uc_side := 6 ;
 286: LD_ADDR_OWVAR 20
 290: PUSH
 291: LD_INT 6
 293: ST_TO_ADDR
// uc_nation := 3 ;
 294: LD_ADDR_OWVAR 21
 298: PUSH
 299: LD_INT 3
 301: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
 302: LD_INT 3
 304: PPUSH
 305: LD_INT 6
 307: PPUSH
 308: CALL_OW 343
// Popov := NewCharacter ( Gaydar ) ;
 312: LD_ADDR_EXP 16
 316: PUSH
 317: LD_STRING Gaydar
 319: PPUSH
 320: CALL_OW 25
 324: ST_TO_ADDR
// uc_side := 7 ;
 325: LD_ADDR_OWVAR 20
 329: PUSH
 330: LD_INT 7
 332: ST_TO_ADDR
// hc_gallery := sandal ;
 333: LD_ADDR_OWVAR 33
 337: PUSH
 338: LD_STRING sandal
 340: ST_TO_ADDR
// hc_face_number := 9 ;
 341: LD_ADDR_OWVAR 34
 345: PUSH
 346: LD_INT 9
 348: ST_TO_ADDR
// hc_skills := [ 3 , 5 , 2 , 7 ] ;
 349: LD_ADDR_OWVAR 31
 353: PUSH
 354: LD_INT 3
 356: PUSH
 357: LD_INT 5
 359: PUSH
 360: LD_INT 2
 362: PUSH
 363: LD_INT 7
 365: PUSH
 366: EMPTY
 367: LIST
 368: LIST
 369: LIST
 370: LIST
 371: ST_TO_ADDR
// hc_sex := sex_male ;
 372: LD_ADDR_OWVAR 27
 376: PUSH
 377: LD_INT 1
 379: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 380: LD_ADDR_OWVAR 29
 384: PUSH
 385: LD_INT 10
 387: PUSH
 388: LD_INT 11
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: ST_TO_ADDR
// hc_class := 4 ;
 395: LD_ADDR_OWVAR 28
 399: PUSH
 400: LD_INT 4
 402: ST_TO_ADDR
// hc_name := Fiodor Saseda ;
 403: LD_ADDR_OWVAR 26
 407: PUSH
 408: LD_STRING Fiodor Saseda
 410: ST_TO_ADDR
// Saseda := CreateHuman ;
 411: LD_ADDR_EXP 17
 415: PUSH
 416: CALL_OW 44
 420: ST_TO_ADDR
// uc_side := 3 ;
 421: LD_ADDR_OWVAR 20
 425: PUSH
 426: LD_INT 3
 428: ST_TO_ADDR
// hc_importance := 100 ;
 429: LD_ADDR_OWVAR 32
 433: PUSH
 434: LD_INT 100
 436: ST_TO_ADDR
// hc_class := 1 ;
 437: LD_ADDR_OWVAR 28
 441: PUSH
 442: LD_INT 1
 444: ST_TO_ADDR
// hc_sex := sex_male ;
 445: LD_ADDR_OWVAR 27
 449: PUSH
 450: LD_INT 1
 452: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
 453: LD_ADDR_OWVAR 31
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 3
 463: PUSH
 464: LD_INT 4
 466: PUSH
 467: LD_INT 2
 469: PUSH
 470: EMPTY
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: ST_TO_ADDR
// hc_name := W. I. Stolypin ;
 476: LD_ADDR_OWVAR 26
 480: PUSH
 481: LD_STRING W. I. Stolypin
 483: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 484: LD_ADDR_OWVAR 29
 488: PUSH
 489: LD_INT 10
 491: PUSH
 492: LD_INT 11
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: ST_TO_ADDR
// hc_gallery := ru ;
 499: LD_ADDR_OWVAR 33
 503: PUSH
 504: LD_STRING ru
 506: ST_TO_ADDR
// hc_face_number := 15 ;
 507: LD_ADDR_OWVAR 34
 511: PUSH
 512: LD_INT 15
 514: ST_TO_ADDR
// Stolypin := CreateHuman ;
 515: LD_ADDR_EXP 15
 519: PUSH
 520: CALL_OW 44
 524: ST_TO_ADDR
// hc_importance := 0 ;
 525: LD_ADDR_OWVAR 32
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// hc_gallery :=  ;
 533: LD_ADDR_OWVAR 33
 537: PUSH
 538: LD_STRING 
 540: ST_TO_ADDR
// hc_name :=  ;
 541: LD_ADDR_OWVAR 26
 545: PUSH
 546: LD_STRING 
 548: ST_TO_ADDR
// skill := [ 6 , 5 , 5 ] [ Difficulty ] ;
 549: LD_ADDR_VAR 0 6
 553: PUSH
 554: LD_INT 6
 556: PUSH
 557: LD_INT 5
 559: PUSH
 560: LD_INT 5
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: PUSH
 568: LD_OWVAR 67
 572: ARRAY
 573: ST_TO_ADDR
// c := 1 ;
 574: LD_ADDR_VAR 0 5
 578: PUSH
 579: LD_INT 1
 581: ST_TO_ADDR
// for i = 1 to 21 do
 582: LD_ADDR_VAR 0 4
 586: PUSH
 587: DOUBLE
 588: LD_INT 1
 590: DEC
 591: ST_TO_ADDR
 592: LD_INT 21
 594: PUSH
 595: FOR_TO
 596: IFFALSE 697
// begin if i = 10 then
 598: LD_VAR 0 4
 602: PUSH
 603: LD_INT 10
 605: EQUAL
 606: IFFALSE 616
// c := 2 ;
 608: LD_ADDR_VAR 0 5
 612: PUSH
 613: LD_INT 2
 615: ST_TO_ADDR
// if i = 14 then
 616: LD_VAR 0 4
 620: PUSH
 621: LD_INT 14
 623: EQUAL
 624: IFFALSE 634
// c := 3 ;
 626: LD_ADDR_VAR 0 5
 630: PUSH
 631: LD_INT 3
 633: ST_TO_ADDR
// if i = 18 then
 634: LD_VAR 0 4
 638: PUSH
 639: LD_INT 18
 641: EQUAL
 642: IFFALSE 652
// c := 4 ;
 644: LD_ADDR_VAR 0 5
 648: PUSH
 649: LD_INT 4
 651: ST_TO_ADDR
// PrepareHuman ( false , c , skill ) ;
 652: LD_INT 0
 654: PPUSH
 655: LD_VAR 0 5
 659: PPUSH
 660: LD_VAR 0 6
 664: PPUSH
 665: CALL_OW 380
// un := CreateHuman ;
 669: LD_ADDR_VAR 0 2
 673: PUSH
 674: CALL_OW 44
 678: ST_TO_ADDR
// force := force ^ un ;
 679: LD_ADDR_VAR 0 3
 683: PUSH
 684: LD_VAR 0 3
 688: PUSH
 689: LD_VAR 0 2
 693: ADD
 694: ST_TO_ADDR
// end ;
 695: GO 595
 697: POP
 698: POP
// team := CharacterSelection ( text , [ 8 , 7 , 7 ] [ Difficulty ] , [ 8 , 7 , 7 ] [ Difficulty ] , [ sel_change_class , Stolypin , sel_changeable , sel_not_hired ] ^ force , [ [ class_soldier , 3 ] , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
 699: LD_ADDR_VAR 0 7
 703: PUSH
 704: LD_STRING text
 706: PPUSH
 707: LD_INT 8
 709: PUSH
 710: LD_INT 7
 712: PUSH
 713: LD_INT 7
 715: PUSH
 716: EMPTY
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_OWVAR 67
 725: ARRAY
 726: PPUSH
 727: LD_INT 8
 729: PUSH
 730: LD_INT 7
 732: PUSH
 733: LD_INT 7
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_OWVAR 67
 745: ARRAY
 746: PPUSH
 747: LD_INT -5
 749: PUSH
 750: LD_EXP 15
 754: PUSH
 755: LD_INT -3
 757: PUSH
 758: LD_INT -2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: LIST
 766: PUSH
 767: LD_VAR 0 3
 771: ADD
 772: PPUSH
 773: LD_INT 1
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: EMPTY
 780: LIST
 781: LIST
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 2
 788: PUSH
 789: LD_INT 1
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 4
 798: PUSH
 799: EMPTY
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PPUSH
 805: CALL_OW 42
 809: ST_TO_ADDR
// team := team ^ Stolypin ;
 810: LD_ADDR_VAR 0 7
 814: PUSH
 815: LD_VAR 0 7
 819: PUSH
 820: LD_EXP 15
 824: ADD
 825: ST_TO_ADDR
// for i = 1 to team do
 826: LD_ADDR_VAR 0 4
 830: PUSH
 831: DOUBLE
 832: LD_INT 1
 834: DEC
 835: ST_TO_ADDR
 836: LD_VAR 0 7
 840: PUSH
 841: FOR_TO
 842: IFFALSE 867
// PlaceUnitArea ( team [ i ] , rus_start , false ) ;
 844: LD_VAR 0 7
 848: PUSH
 849: LD_VAR 0 4
 853: ARRAY
 854: PPUSH
 855: LD_INT 1
 857: PPUSH
 858: LD_INT 0
 860: PPUSH
 861: CALL_OW 49
 865: GO 841
 867: POP
 868: POP
// CenterNowOnUnits ( Stolypin ) ;
 869: LD_EXP 15
 873: PPUSH
 874: CALL_OW 87
// end ;
 878: LD_VAR 0 1
 882: RET
// export conv_ready ; export function Convoy ( type ) ; var i , veh , skill ; begin
 883: LD_INT 0
 885: PPUSH
 886: PPUSH
 887: PPUSH
 888: PPUSH
// Randomize ;
 889: CALL_OW 10
// uc_side := 6 ;
 893: LD_ADDR_OWVAR 20
 897: PUSH
 898: LD_INT 6
 900: ST_TO_ADDR
// uc_nation := 3 ;
 901: LD_ADDR_OWVAR 21
 905: PUSH
 906: LD_INT 3
 908: ST_TO_ADDR
// hc_name :=  ;
 909: LD_ADDR_OWVAR 26
 913: PUSH
 914: LD_STRING 
 916: ST_TO_ADDR
// hc_gallery :=  ;
 917: LD_ADDR_OWVAR 33
 921: PUSH
 922: LD_STRING 
 924: ST_TO_ADDR
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
 925: LD_ADDR_VAR 0 5
 929: PUSH
 930: LD_INT 5
 932: PUSH
 933: LD_INT 5
 935: PUSH
 936: LD_INT 4
 938: PUSH
 939: EMPTY
 940: LIST
 941: LIST
 942: LIST
 943: PUSH
 944: LD_OWVAR 67
 948: ARRAY
 949: ST_TO_ADDR
// conv_ready := false ;
 950: LD_ADDR_EXP 18
 954: PUSH
 955: LD_INT 0
 957: ST_TO_ADDR
// case type of 1 :
 958: LD_VAR 0 1
 962: PUSH
 963: LD_INT 1
 965: DOUBLE
 966: EQUAL
 967: IFTRUE 971
 969: GO 1241
 971: POP
// begin if Rand ( 0 , 1 ) = 1 then
 972: LD_INT 0
 974: PPUSH
 975: LD_INT 1
 977: PPUSH
 978: CALL_OW 12
 982: PUSH
 983: LD_INT 1
 985: EQUAL
 986: IFFALSE 992
// AddEscort ( ) ;
 988: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
 992: LD_INT 70
 994: PPUSH
 995: CALL_OW 67
// vc_chassis := ru_medium_wheeled ;
 999: LD_ADDR_OWVAR 37
1003: PUSH
1004: LD_INT 21
1006: ST_TO_ADDR
// vc_engine := engine_combustion ;
1007: LD_ADDR_OWVAR 39
1011: PUSH
1012: LD_INT 1
1014: ST_TO_ADDR
// vc_control := control_manual ;
1015: LD_ADDR_OWVAR 38
1019: PUSH
1020: LD_INT 1
1022: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1023: LD_ADDR_OWVAR 40
1027: PUSH
1028: LD_INT 51
1030: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1031: LD_ADDR_OWVAR 41
1035: PUSH
1036: LD_INT 50
1038: PPUSH
1039: LD_INT 99
1041: PPUSH
1042: CALL_OW 12
1046: ST_TO_ADDR
// if uc_side <> 6 then
1047: LD_OWVAR 20
1051: PUSH
1052: LD_INT 6
1054: NONEQUAL
1055: IFFALSE 1065
// uc_side := 6 ;
1057: LD_ADDR_OWVAR 20
1061: PUSH
1062: LD_INT 6
1064: ST_TO_ADDR
// veh := CreateVehicle ;
1065: LD_ADDR_VAR 0 4
1069: PUSH
1070: CALL_OW 45
1074: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1075: LD_VAR 0 4
1079: PPUSH
1080: LD_INT 3
1082: PPUSH
1083: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1087: LD_VAR 0 4
1091: PPUSH
1092: LD_INT 8
1094: PPUSH
1095: LD_INT 0
1097: PPUSH
1098: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1102: LD_INT 0
1104: PPUSH
1105: LD_INT 1
1107: PPUSH
1108: LD_INT 2
1110: PPUSH
1111: CALL_OW 12
1115: PPUSH
1116: LD_VAR 0 5
1120: PPUSH
1121: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1125: CALL_OW 44
1129: PPUSH
1130: LD_VAR 0 4
1134: PPUSH
1135: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1139: LD_VAR 0 4
1143: PPUSH
1144: LD_INT 500
1146: PPUSH
1147: LD_INT 1000
1149: PPUSH
1150: CALL_OW 12
1154: PPUSH
1155: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1159: LD_VAR 0 4
1163: PPUSH
1164: LD_INT 1
1166: PPUSH
1167: LD_INT 2
1169: PPUSH
1170: CALL_OW 12
1174: PPUSH
1175: LD_INT 2
1177: PPUSH
1178: LD_INT 10
1180: PPUSH
1181: CALL_OW 12
1185: PUSH
1186: LD_INT 10
1188: MUL
1189: PPUSH
1190: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1194: LD_ADDR_EXP 1
1198: PUSH
1199: LD_EXP 1
1203: PPUSH
1204: LD_INT 1
1206: PPUSH
1207: LD_VAR 0 4
1211: PUSH
1212: LD_INT 1
1214: PUSH
1215: EMPTY
1216: LIST
1217: LIST
1218: PPUSH
1219: CALL_OW 2
1223: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
1224: LD_INT 35
1226: PPUSH
1227: CALL_OW 67
// conv_ready := true ;
1231: LD_ADDR_EXP 18
1235: PUSH
1236: LD_INT 1
1238: ST_TO_ADDR
// end ; 2 :
1239: GO 2861
1241: LD_INT 2
1243: DOUBLE
1244: EQUAL
1245: IFTRUE 1249
1247: GO 1549
1249: POP
// begin AddEscort ( ) ;
1250: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1254: LD_INT 70
1256: PPUSH
1257: CALL_OW 67
// for i = 1 to 2 do
1261: LD_ADDR_VAR 0 3
1265: PUSH
1266: DOUBLE
1267: LD_INT 1
1269: DEC
1270: ST_TO_ADDR
1271: LD_INT 2
1273: PUSH
1274: FOR_TO
1275: IFFALSE 1526
// begin vc_chassis := ru_medium_wheeled ;
1277: LD_ADDR_OWVAR 37
1281: PUSH
1282: LD_INT 21
1284: ST_TO_ADDR
// vc_engine := engine_combustion ;
1285: LD_ADDR_OWVAR 39
1289: PUSH
1290: LD_INT 1
1292: ST_TO_ADDR
// vc_control := control_manual ;
1293: LD_ADDR_OWVAR 38
1297: PUSH
1298: LD_INT 1
1300: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1301: LD_ADDR_OWVAR 40
1305: PUSH
1306: LD_INT 51
1308: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1309: LD_ADDR_OWVAR 41
1313: PUSH
1314: LD_INT 50
1316: PPUSH
1317: LD_INT 99
1319: PPUSH
1320: CALL_OW 12
1324: ST_TO_ADDR
// if uc_side <> 6 then
1325: LD_OWVAR 20
1329: PUSH
1330: LD_INT 6
1332: NONEQUAL
1333: IFFALSE 1343
// uc_side := 6 ;
1335: LD_ADDR_OWVAR 20
1339: PUSH
1340: LD_INT 6
1342: ST_TO_ADDR
// veh := CreateVehicle ;
1343: LD_ADDR_VAR 0 4
1347: PUSH
1348: CALL_OW 45
1352: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1353: LD_VAR 0 4
1357: PPUSH
1358: LD_INT 3
1360: PPUSH
1361: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1365: LD_VAR 0 4
1369: PPUSH
1370: LD_INT 8
1372: PPUSH
1373: LD_INT 0
1375: PPUSH
1376: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1380: LD_INT 0
1382: PPUSH
1383: LD_INT 1
1385: PPUSH
1386: LD_INT 2
1388: PPUSH
1389: CALL_OW 12
1393: PPUSH
1394: LD_VAR 0 5
1398: PPUSH
1399: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1403: CALL_OW 44
1407: PPUSH
1408: LD_VAR 0 4
1412: PPUSH
1413: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1417: LD_VAR 0 4
1421: PPUSH
1422: LD_INT 500
1424: PPUSH
1425: LD_INT 1000
1427: PPUSH
1428: CALL_OW 12
1432: PPUSH
1433: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1437: LD_VAR 0 4
1441: PPUSH
1442: LD_INT 1
1444: PPUSH
1445: LD_INT 2
1447: PPUSH
1448: CALL_OW 12
1452: PPUSH
1453: LD_INT 2
1455: PPUSH
1456: LD_INT 10
1458: PPUSH
1459: CALL_OW 12
1463: PUSH
1464: LD_INT 10
1466: MUL
1467: PPUSH
1468: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1472: LD_ADDR_EXP 1
1476: PUSH
1477: LD_EXP 1
1481: PPUSH
1482: LD_INT 1
1484: PPUSH
1485: LD_VAR 0 4
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: PPUSH
1497: CALL_OW 2
1501: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1502: LD_VAR 0 4
1506: PPUSH
1507: LD_INT 120
1509: PPUSH
1510: LD_INT 10
1512: PPUSH
1513: CALL_OW 111
// Wait ( 0 0$02 ) ;
1517: LD_INT 70
1519: PPUSH
1520: CALL_OW 67
// end ;
1524: GO 1274
1526: POP
1527: POP
// AddEscort ( ) ;
1528: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1532: LD_INT 70
1534: PPUSH
1535: CALL_OW 67
// conv_ready := true ;
1539: LD_ADDR_EXP 18
1543: PUSH
1544: LD_INT 1
1546: ST_TO_ADDR
// end ; 3 :
1547: GO 2861
1549: LD_INT 3
1551: DOUBLE
1552: EQUAL
1553: IFTRUE 1557
1555: GO 1976
1557: POP
// begin AddEscort ( ) ;
1558: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1562: LD_INT 70
1564: PPUSH
1565: CALL_OW 67
// for i = 1 to 2 do
1569: LD_ADDR_VAR 0 3
1573: PUSH
1574: DOUBLE
1575: LD_INT 1
1577: DEC
1578: ST_TO_ADDR
1579: LD_INT 2
1581: PUSH
1582: FOR_TO
1583: IFFALSE 1834
// begin vc_chassis := ru_medium_wheeled ;
1585: LD_ADDR_OWVAR 37
1589: PUSH
1590: LD_INT 21
1592: ST_TO_ADDR
// vc_engine := engine_combustion ;
1593: LD_ADDR_OWVAR 39
1597: PUSH
1598: LD_INT 1
1600: ST_TO_ADDR
// vc_control := control_manual ;
1601: LD_ADDR_OWVAR 38
1605: PUSH
1606: LD_INT 1
1608: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1609: LD_ADDR_OWVAR 40
1613: PUSH
1614: LD_INT 51
1616: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1617: LD_ADDR_OWVAR 41
1621: PUSH
1622: LD_INT 50
1624: PPUSH
1625: LD_INT 99
1627: PPUSH
1628: CALL_OW 12
1632: ST_TO_ADDR
// if uc_side <> 6 then
1633: LD_OWVAR 20
1637: PUSH
1638: LD_INT 6
1640: NONEQUAL
1641: IFFALSE 1651
// uc_side := 6 ;
1643: LD_ADDR_OWVAR 20
1647: PUSH
1648: LD_INT 6
1650: ST_TO_ADDR
// veh := CreateVehicle ;
1651: LD_ADDR_VAR 0 4
1655: PUSH
1656: CALL_OW 45
1660: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1661: LD_VAR 0 4
1665: PPUSH
1666: LD_INT 3
1668: PPUSH
1669: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1673: LD_VAR 0 4
1677: PPUSH
1678: LD_INT 8
1680: PPUSH
1681: LD_INT 0
1683: PPUSH
1684: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1688: LD_INT 0
1690: PPUSH
1691: LD_INT 1
1693: PPUSH
1694: LD_INT 2
1696: PPUSH
1697: CALL_OW 12
1701: PPUSH
1702: LD_VAR 0 5
1706: PPUSH
1707: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1711: CALL_OW 44
1715: PPUSH
1716: LD_VAR 0 4
1720: PPUSH
1721: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1725: LD_VAR 0 4
1729: PPUSH
1730: LD_INT 500
1732: PPUSH
1733: LD_INT 1000
1735: PPUSH
1736: CALL_OW 12
1740: PPUSH
1741: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1745: LD_VAR 0 4
1749: PPUSH
1750: LD_INT 1
1752: PPUSH
1753: LD_INT 2
1755: PPUSH
1756: CALL_OW 12
1760: PPUSH
1761: LD_INT 2
1763: PPUSH
1764: LD_INT 10
1766: PPUSH
1767: CALL_OW 12
1771: PUSH
1772: LD_INT 10
1774: MUL
1775: PPUSH
1776: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1780: LD_ADDR_EXP 1
1784: PUSH
1785: LD_EXP 1
1789: PPUSH
1790: LD_INT 1
1792: PPUSH
1793: LD_VAR 0 4
1797: PUSH
1798: LD_INT 1
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: PPUSH
1805: CALL_OW 2
1809: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1810: LD_VAR 0 4
1814: PPUSH
1815: LD_INT 120
1817: PPUSH
1818: LD_INT 10
1820: PPUSH
1821: CALL_OW 111
// Wait ( 0 0$02 ) ;
1825: LD_INT 70
1827: PPUSH
1828: CALL_OW 67
// end ;
1832: GO 1582
1834: POP
1835: POP
// for i = 1 to 2 do
1836: LD_ADDR_VAR 0 3
1840: PUSH
1841: DOUBLE
1842: LD_INT 1
1844: DEC
1845: ST_TO_ADDR
1846: LD_INT 2
1848: PUSH
1849: FOR_TO
1850: IFFALSE 1957
// begin PrepareHuman ( false , 1 , skill ) ;
1852: LD_INT 0
1854: PPUSH
1855: LD_INT 1
1857: PPUSH
1858: LD_VAR 0 5
1862: PPUSH
1863: CALL_OW 380
// if uc_side <> 6 then
1867: LD_OWVAR 20
1871: PUSH
1872: LD_INT 6
1874: NONEQUAL
1875: IFFALSE 1885
// uc_side := 6 ;
1877: LD_ADDR_OWVAR 20
1881: PUSH
1882: LD_INT 6
1884: ST_TO_ADDR
// veh := CreateHuman ;
1885: LD_ADDR_VAR 0 4
1889: PUSH
1890: CALL_OW 44
1894: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
1895: LD_VAR 0 4
1899: PPUSH
1900: LD_INT 8
1902: PPUSH
1903: LD_INT 0
1905: PPUSH
1906: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
1910: LD_ADDR_EXP 2
1914: PUSH
1915: LD_EXP 2
1919: PPUSH
1920: LD_INT 1
1922: PPUSH
1923: LD_VAR 0 4
1927: PPUSH
1928: CALL_OW 2
1932: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1933: LD_VAR 0 4
1937: PPUSH
1938: LD_INT 120
1940: PPUSH
1941: LD_INT 10
1943: PPUSH
1944: CALL_OW 111
// Wait ( 0 0$02 ) ;
1948: LD_INT 70
1950: PPUSH
1951: CALL_OW 67
// end ;
1955: GO 1849
1957: POP
1958: POP
// Wait ( 0 0$02 ) ;
1959: LD_INT 70
1961: PPUSH
1962: CALL_OW 67
// conv_ready := true ;
1966: LD_ADDR_EXP 18
1970: PUSH
1971: LD_INT 1
1973: ST_TO_ADDR
// end ; 4 :
1974: GO 2861
1976: LD_INT 4
1978: DOUBLE
1979: EQUAL
1980: IFTRUE 1984
1982: GO 2290
1984: POP
// begin if Rand ( 0 , 1 ) = 1 then
1985: LD_INT 0
1987: PPUSH
1988: LD_INT 1
1990: PPUSH
1991: CALL_OW 12
1995: PUSH
1996: LD_INT 1
1998: EQUAL
1999: IFFALSE 2005
// AddEscort ( ) ;
2001: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2005: LD_INT 70
2007: PPUSH
2008: CALL_OW 67
// for i = 1 to 5 do
2012: LD_ADDR_VAR 0 3
2016: PUSH
2017: DOUBLE
2018: LD_INT 1
2020: DEC
2021: ST_TO_ADDR
2022: LD_INT 5
2024: PUSH
2025: FOR_TO
2026: IFFALSE 2148
// begin PrepareHuman ( false , Rand ( 2 , 4 ) , skill ) ;
2028: LD_INT 0
2030: PPUSH
2031: LD_INT 2
2033: PPUSH
2034: LD_INT 4
2036: PPUSH
2037: CALL_OW 12
2041: PPUSH
2042: LD_VAR 0 5
2046: PPUSH
2047: CALL_OW 380
// if uc_side <> 6 then
2051: LD_OWVAR 20
2055: PUSH
2056: LD_INT 6
2058: NONEQUAL
2059: IFFALSE 2069
// uc_side := 6 ;
2061: LD_ADDR_OWVAR 20
2065: PUSH
2066: LD_INT 6
2068: ST_TO_ADDR
// veh := CreateHuman ;
2069: LD_ADDR_VAR 0 4
2073: PUSH
2074: CALL_OW 44
2078: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2079: LD_VAR 0 4
2083: PPUSH
2084: LD_INT 8
2086: PPUSH
2087: LD_INT 0
2089: PPUSH
2090: CALL_OW 49
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2094: LD_ADDR_EXP 1
2098: PUSH
2099: LD_EXP 1
2103: PPUSH
2104: LD_INT 1
2106: PPUSH
2107: LD_VAR 0 4
2111: PUSH
2112: LD_INT 1
2114: PUSH
2115: EMPTY
2116: LIST
2117: LIST
2118: PPUSH
2119: CALL_OW 2
2123: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2124: LD_VAR 0 4
2128: PPUSH
2129: LD_INT 120
2131: PPUSH
2132: LD_INT 10
2134: PPUSH
2135: CALL_OW 111
// Wait ( 0 0$02 ) ;
2139: LD_INT 70
2141: PPUSH
2142: CALL_OW 67
// end ;
2146: GO 2025
2148: POP
2149: POP
// for i = 1 to 2 do
2150: LD_ADDR_VAR 0 3
2154: PUSH
2155: DOUBLE
2156: LD_INT 1
2158: DEC
2159: ST_TO_ADDR
2160: LD_INT 2
2162: PUSH
2163: FOR_TO
2164: IFFALSE 2271
// begin PrepareHuman ( false , 1 , skill ) ;
2166: LD_INT 0
2168: PPUSH
2169: LD_INT 1
2171: PPUSH
2172: LD_VAR 0 5
2176: PPUSH
2177: CALL_OW 380
// if uc_side <> 6 then
2181: LD_OWVAR 20
2185: PUSH
2186: LD_INT 6
2188: NONEQUAL
2189: IFFALSE 2199
// uc_side := 6 ;
2191: LD_ADDR_OWVAR 20
2195: PUSH
2196: LD_INT 6
2198: ST_TO_ADDR
// veh := CreateHuman ;
2199: LD_ADDR_VAR 0 4
2203: PUSH
2204: CALL_OW 44
2208: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2209: LD_VAR 0 4
2213: PPUSH
2214: LD_INT 8
2216: PPUSH
2217: LD_INT 0
2219: PPUSH
2220: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
2224: LD_ADDR_EXP 2
2228: PUSH
2229: LD_EXP 2
2233: PPUSH
2234: LD_INT 1
2236: PPUSH
2237: LD_VAR 0 4
2241: PPUSH
2242: CALL_OW 2
2246: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2247: LD_VAR 0 4
2251: PPUSH
2252: LD_INT 120
2254: PPUSH
2255: LD_INT 10
2257: PPUSH
2258: CALL_OW 111
// Wait ( 0 0$02 ) ;
2262: LD_INT 70
2264: PPUSH
2265: CALL_OW 67
// end ;
2269: GO 2163
2271: POP
2272: POP
// Wait ( 0 0$02 ) ;
2273: LD_INT 70
2275: PPUSH
2276: CALL_OW 67
// conv_ready := true ;
2280: LD_ADDR_EXP 18
2284: PUSH
2285: LD_INT 1
2287: ST_TO_ADDR
// end ; 5 :
2288: GO 2861
2290: LD_INT 5
2292: DOUBLE
2293: EQUAL
2294: IFTRUE 2298
2296: GO 2860
2298: POP
// begin AddEscort ( ) ;
2299: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2303: LD_INT 70
2305: PPUSH
2306: CALL_OW 67
// AddEscort ( ) ;
2310: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2314: LD_INT 70
2316: PPUSH
2317: CALL_OW 67
// for i = 1 to 2 do
2321: LD_ADDR_VAR 0 3
2325: PUSH
2326: DOUBLE
2327: LD_INT 1
2329: DEC
2330: ST_TO_ADDR
2331: LD_INT 2
2333: PUSH
2334: FOR_TO
2335: IFFALSE 2586
// begin vc_chassis := ru_medium_wheeled ;
2337: LD_ADDR_OWVAR 37
2341: PUSH
2342: LD_INT 21
2344: ST_TO_ADDR
// vc_engine := engine_combustion ;
2345: LD_ADDR_OWVAR 39
2349: PUSH
2350: LD_INT 1
2352: ST_TO_ADDR
// vc_control := control_manual ;
2353: LD_ADDR_OWVAR 38
2357: PUSH
2358: LD_INT 1
2360: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2361: LD_ADDR_OWVAR 40
2365: PUSH
2366: LD_INT 51
2368: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2369: LD_ADDR_OWVAR 41
2373: PUSH
2374: LD_INT 50
2376: PPUSH
2377: LD_INT 99
2379: PPUSH
2380: CALL_OW 12
2384: ST_TO_ADDR
// if uc_side <> 6 then
2385: LD_OWVAR 20
2389: PUSH
2390: LD_INT 6
2392: NONEQUAL
2393: IFFALSE 2403
// uc_side := 6 ;
2395: LD_ADDR_OWVAR 20
2399: PUSH
2400: LD_INT 6
2402: ST_TO_ADDR
// veh := CreateVehicle ;
2403: LD_ADDR_VAR 0 4
2407: PUSH
2408: CALL_OW 45
2412: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2413: LD_VAR 0 4
2417: PPUSH
2418: LD_INT 3
2420: PPUSH
2421: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2425: LD_VAR 0 4
2429: PPUSH
2430: LD_INT 8
2432: PPUSH
2433: LD_INT 0
2435: PPUSH
2436: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2440: LD_INT 0
2442: PPUSH
2443: LD_INT 1
2445: PPUSH
2446: LD_INT 2
2448: PPUSH
2449: CALL_OW 12
2453: PPUSH
2454: LD_VAR 0 5
2458: PPUSH
2459: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2463: CALL_OW 44
2467: PPUSH
2468: LD_VAR 0 4
2472: PPUSH
2473: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2477: LD_VAR 0 4
2481: PPUSH
2482: LD_INT 500
2484: PPUSH
2485: LD_INT 1000
2487: PPUSH
2488: CALL_OW 12
2492: PPUSH
2493: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
2497: LD_VAR 0 4
2501: PPUSH
2502: LD_INT 1
2504: PPUSH
2505: LD_INT 2
2507: PPUSH
2508: CALL_OW 12
2512: PPUSH
2513: LD_INT 2
2515: PPUSH
2516: LD_INT 10
2518: PPUSH
2519: CALL_OW 12
2523: PUSH
2524: LD_INT 10
2526: MUL
2527: PPUSH
2528: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2532: LD_ADDR_EXP 1
2536: PUSH
2537: LD_EXP 1
2541: PPUSH
2542: LD_INT 1
2544: PPUSH
2545: LD_VAR 0 4
2549: PUSH
2550: LD_INT 1
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL_OW 2
2561: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2562: LD_VAR 0 4
2566: PPUSH
2567: LD_INT 120
2569: PPUSH
2570: LD_INT 10
2572: PPUSH
2573: CALL_OW 111
// Wait ( 0 0$02 ) ;
2577: LD_INT 70
2579: PPUSH
2580: CALL_OW 67
// end ;
2584: GO 2334
2586: POP
2587: POP
// if Rand ( 0 , 1 ) = 1 then
2588: LD_INT 0
2590: PPUSH
2591: LD_INT 1
2593: PPUSH
2594: CALL_OW 12
2598: PUSH
2599: LD_INT 1
2601: EQUAL
2602: IFFALSE 2638
// begin vc_chassis := ru_medium_tracked ;
2604: LD_ADDR_OWVAR 37
2608: PUSH
2609: LD_INT 22
2611: ST_TO_ADDR
// vc_engine := engine_combustion ;
2612: LD_ADDR_OWVAR 39
2616: PUSH
2617: LD_INT 1
2619: ST_TO_ADDR
// vc_control := control_manual ;
2620: LD_ADDR_OWVAR 38
2624: PUSH
2625: LD_INT 1
2627: ST_TO_ADDR
// vc_weapon := ru_crane ;
2628: LD_ADDR_OWVAR 40
2632: PUSH
2633: LD_INT 52
2635: ST_TO_ADDR
// end else
2636: GO 2670
// begin vc_chassis := ru_heavy_wheeled ;
2638: LD_ADDR_OWVAR 37
2642: PUSH
2643: LD_INT 23
2645: ST_TO_ADDR
// vc_engine := engine_combustion ;
2646: LD_ADDR_OWVAR 39
2650: PUSH
2651: LD_INT 1
2653: ST_TO_ADDR
// vc_control := control_manual ;
2654: LD_ADDR_OWVAR 38
2658: PUSH
2659: LD_INT 1
2661: ST_TO_ADDR
// vc_weapon := ru_bulldozer ;
2662: LD_ADDR_OWVAR 40
2666: PUSH
2667: LD_INT 53
2669: ST_TO_ADDR
// end ; vc_fuel_battery := Rand ( 50 , 99 ) ;
2670: LD_ADDR_OWVAR 41
2674: PUSH
2675: LD_INT 50
2677: PPUSH
2678: LD_INT 99
2680: PPUSH
2681: CALL_OW 12
2685: ST_TO_ADDR
// if uc_side <> 6 then
2686: LD_OWVAR 20
2690: PUSH
2691: LD_INT 6
2693: NONEQUAL
2694: IFFALSE 2704
// uc_side := 6 ;
2696: LD_ADDR_OWVAR 20
2700: PUSH
2701: LD_INT 6
2703: ST_TO_ADDR
// veh := CreateVehicle ;
2704: LD_ADDR_VAR 0 4
2708: PUSH
2709: CALL_OW 45
2713: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2714: LD_VAR 0 4
2718: PPUSH
2719: LD_INT 3
2721: PPUSH
2722: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2726: LD_VAR 0 4
2730: PPUSH
2731: LD_INT 8
2733: PPUSH
2734: LD_INT 0
2736: PPUSH
2737: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2741: LD_INT 0
2743: PPUSH
2744: LD_INT 1
2746: PPUSH
2747: LD_INT 2
2749: PPUSH
2750: CALL_OW 12
2754: PPUSH
2755: LD_VAR 0 5
2759: PPUSH
2760: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2764: CALL_OW 44
2768: PPUSH
2769: LD_VAR 0 4
2773: PPUSH
2774: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2778: LD_VAR 0 4
2782: PPUSH
2783: LD_INT 500
2785: PPUSH
2786: LD_INT 1000
2788: PPUSH
2789: CALL_OW 12
2793: PPUSH
2794: CALL_OW 234
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2798: LD_ADDR_EXP 1
2802: PUSH
2803: LD_EXP 1
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: LD_VAR 0 4
2815: PUSH
2816: LD_INT 1
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: PPUSH
2823: CALL_OW 2
2827: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2828: LD_VAR 0 4
2832: PPUSH
2833: LD_INT 120
2835: PPUSH
2836: LD_INT 10
2838: PPUSH
2839: CALL_OW 111
// Wait ( 0 0$02 ) ;
2843: LD_INT 70
2845: PPUSH
2846: CALL_OW 67
// conv_ready := true ;
2850: LD_ADDR_EXP 18
2854: PUSH
2855: LD_INT 1
2857: ST_TO_ADDR
// end ; end ;
2858: GO 2861
2860: POP
// end ;
2861: LD_VAR 0 2
2865: RET
// export function AddEscort ( ) ; var veh , skill ; begin
2866: LD_INT 0
2868: PPUSH
2869: PPUSH
2870: PPUSH
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
2871: LD_ADDR_VAR 0 3
2875: PUSH
2876: LD_INT 5
2878: PUSH
2879: LD_INT 5
2881: PUSH
2882: LD_INT 4
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: LIST
2889: PUSH
2890: LD_OWVAR 67
2894: ARRAY
2895: ST_TO_ADDR
// uc_side := 6 ;
2896: LD_ADDR_OWVAR 20
2900: PUSH
2901: LD_INT 6
2903: ST_TO_ADDR
// uc_nation := 3 ;
2904: LD_ADDR_OWVAR 21
2908: PUSH
2909: LD_INT 3
2911: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
2912: LD_ADDR_OWVAR 37
2916: PUSH
2917: LD_INT 21
2919: ST_TO_ADDR
// vc_engine := engine_combustion ;
2920: LD_ADDR_OWVAR 39
2924: PUSH
2925: LD_INT 1
2927: ST_TO_ADDR
// vc_control := control_manual ;
2928: LD_ADDR_OWVAR 38
2932: PUSH
2933: LD_INT 1
2935: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_heavy_machine_gun ] [ Rand ( 1 , 2 ) ] ;
2936: LD_ADDR_OWVAR 40
2940: PUSH
2941: LD_INT 44
2943: PUSH
2944: LD_INT 42
2946: PUSH
2947: EMPTY
2948: LIST
2949: LIST
2950: PUSH
2951: LD_INT 1
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: CALL_OW 12
2961: ARRAY
2962: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2963: LD_ADDR_OWVAR 41
2967: PUSH
2968: LD_INT 50
2970: PPUSH
2971: LD_INT 99
2973: PPUSH
2974: CALL_OW 12
2978: ST_TO_ADDR
// veh := CreateVehicle ;
2979: LD_ADDR_VAR 0 2
2983: PUSH
2984: CALL_OW 45
2988: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2989: LD_VAR 0 2
2993: PPUSH
2994: LD_INT 3
2996: PPUSH
2997: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
3001: LD_VAR 0 2
3005: PPUSH
3006: LD_INT 8
3008: PPUSH
3009: LD_INT 0
3011: PPUSH
3012: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
3016: LD_INT 0
3018: PPUSH
3019: LD_INT 3
3021: PPUSH
3022: LD_VAR 0 3
3026: PPUSH
3027: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3031: CALL_OW 44
3035: PPUSH
3036: LD_VAR 0 2
3040: PPUSH
3041: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
3045: LD_VAR 0 2
3049: PPUSH
3050: LD_INT 500
3052: PPUSH
3053: LD_INT 1000
3055: PPUSH
3056: CALL_OW 12
3060: PPUSH
3061: CALL_OW 234
// escort := Insert ( escort , 1 , veh ) ;
3065: LD_ADDR_EXP 2
3069: PUSH
3070: LD_EXP 2
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: LD_VAR 0 2
3082: PPUSH
3083: CALL_OW 2
3087: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
3088: LD_VAR 0 2
3092: PPUSH
3093: LD_INT 120
3095: PPUSH
3096: LD_INT 10
3098: PPUSH
3099: CALL_OW 111
// end ;
3103: LD_VAR 0 1
3107: RET
// every 4 trigger conv_ready and FilterAllUnits ( [ f_side , 6 ] ) do var i , j ;
3108: LD_EXP 18
3112: PUSH
3113: LD_INT 22
3115: PUSH
3116: LD_INT 6
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: PPUSH
3123: CALL_OW 69
3127: AND
3128: IFFALSE 3861
3130: GO 3132
3132: DISABLE
3133: LD_INT 0
3135: PPUSH
3136: PPUSH
// begin enable ;
3137: ENABLE
// if conv_squad then
3138: LD_EXP 1
3142: IFFALSE 3399
// for i = conv_squad downto 1 do
3144: LD_ADDR_VAR 0 1
3148: PUSH
3149: DOUBLE
3150: LD_EXP 1
3154: INC
3155: ST_TO_ADDR
3156: LD_INT 1
3158: PUSH
3159: FOR_DOWNTO
3160: IFFALSE 3397
// begin if IsInArea ( conv_squad [ i ] [ 1 ] , conv_end ) then
3162: LD_EXP 1
3166: PUSH
3167: LD_VAR 0 1
3171: ARRAY
3172: PUSH
3173: LD_INT 1
3175: ARRAY
3176: PPUSH
3177: LD_INT 9
3179: PPUSH
3180: CALL_OW 308
3184: IFFALSE 3247
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3186: LD_ADDR_VAR 0 2
3190: PUSH
3191: LD_INT 9
3193: PPUSH
3194: LD_INT 22
3196: PUSH
3197: LD_INT 6
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: PPUSH
3204: CALL_OW 70
3208: PUSH
3209: FOR_IN
3210: IFFALSE 3223
// RemoveUnit ( j ) ;
3212: LD_VAR 0 2
3216: PPUSH
3217: CALL_OW 64
3221: GO 3209
3223: POP
3224: POP
// conv_squad := Delete ( conv_squad , i ) ;
3225: LD_ADDR_EXP 1
3229: PUSH
3230: LD_EXP 1
3234: PPUSH
3235: LD_VAR 0 1
3239: PPUSH
3240: CALL_OW 3
3244: ST_TO_ADDR
// break ;
3245: GO 3397
// end ; if IsInArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) then
3247: LD_EXP 1
3251: PUSH
3252: LD_VAR 0 1
3256: ARRAY
3257: PUSH
3258: LD_INT 1
3260: ARRAY
3261: PPUSH
3262: LD_EXP 6
3266: PUSH
3267: LD_EXP 1
3271: PUSH
3272: LD_VAR 0 1
3276: ARRAY
3277: PUSH
3278: LD_INT 2
3280: ARRAY
3281: ARRAY
3282: PPUSH
3283: CALL_OW 308
3287: IFFALSE 3333
// conv_squad := Replace2 ( conv_squad , i , 2 , conv_squad [ i ] [ 2 ] + 1 ) else
3289: LD_ADDR_EXP 1
3293: PUSH
3294: LD_EXP 1
3298: PPUSH
3299: LD_VAR 0 1
3303: PPUSH
3304: LD_INT 2
3306: PPUSH
3307: LD_EXP 1
3311: PUSH
3312: LD_VAR 0 1
3316: ARRAY
3317: PUSH
3318: LD_INT 2
3320: ARRAY
3321: PUSH
3322: LD_INT 1
3324: PLUS
3325: PPUSH
3326: CALL 10038 0 4
3330: ST_TO_ADDR
3331: GO 3395
// if not HasTask ( conv_squad [ i ] [ 1 ] ) then
3333: LD_EXP 1
3337: PUSH
3338: LD_VAR 0 1
3342: ARRAY
3343: PUSH
3344: LD_INT 1
3346: ARRAY
3347: PPUSH
3348: CALL_OW 314
3352: NOT
3353: IFFALSE 3395
// ComMoveToArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) ;
3355: LD_EXP 1
3359: PUSH
3360: LD_VAR 0 1
3364: ARRAY
3365: PUSH
3366: LD_INT 1
3368: ARRAY
3369: PPUSH
3370: LD_EXP 6
3374: PUSH
3375: LD_EXP 1
3379: PUSH
3380: LD_VAR 0 1
3384: ARRAY
3385: PUSH
3386: LD_INT 2
3388: ARRAY
3389: ARRAY
3390: PPUSH
3391: CALL_OW 113
// end ;
3395: GO 3159
3397: POP
3398: POP
// if escort then
3399: LD_EXP 2
3403: IFFALSE 3728
// for i = escort downto 1 do
3405: LD_ADDR_VAR 0 1
3409: PUSH
3410: DOUBLE
3411: LD_EXP 2
3415: INC
3416: ST_TO_ADDR
3417: LD_INT 1
3419: PUSH
3420: FOR_DOWNTO
3421: IFFALSE 3726
// begin if IsInArea ( escort [ i ] , conv_end ) then
3423: LD_EXP 2
3427: PUSH
3428: LD_VAR 0 1
3432: ARRAY
3433: PPUSH
3434: LD_INT 9
3436: PPUSH
3437: CALL_OW 308
3441: IFFALSE 3504
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3443: LD_ADDR_VAR 0 2
3447: PUSH
3448: LD_INT 9
3450: PPUSH
3451: LD_INT 22
3453: PUSH
3454: LD_INT 6
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 70
3465: PUSH
3466: FOR_IN
3467: IFFALSE 3480
// RemoveUnit ( j ) ;
3469: LD_VAR 0 2
3473: PPUSH
3474: CALL_OW 64
3478: GO 3466
3480: POP
3481: POP
// escort := Delete ( escort , i ) ;
3482: LD_ADDR_EXP 2
3486: PUSH
3487: LD_EXP 2
3491: PPUSH
3492: LD_VAR 0 1
3496: PPUSH
3497: CALL_OW 3
3501: ST_TO_ADDR
// break ;
3502: GO 3726
// end ; if FindTarget ( escort [ i ] ) and GetDistUnits ( escort [ i ] , FindTarget ( escort [ i ] ) ) < 13 then
3504: LD_EXP 2
3508: PUSH
3509: LD_VAR 0 1
3513: ARRAY
3514: PPUSH
3515: CALL 10346 0 1
3519: PUSH
3520: LD_EXP 2
3524: PUSH
3525: LD_VAR 0 1
3529: ARRAY
3530: PPUSH
3531: LD_EXP 2
3535: PUSH
3536: LD_VAR 0 1
3540: ARRAY
3541: PPUSH
3542: CALL 10346 0 1
3546: PPUSH
3547: CALL_OW 296
3551: PUSH
3552: LD_INT 13
3554: LESS
3555: AND
3556: IFFALSE 3591
// ComAttackUnit ( escort [ i ] , FindTarget ( escort [ i ] ) ) else
3558: LD_EXP 2
3562: PUSH
3563: LD_VAR 0 1
3567: ARRAY
3568: PPUSH
3569: LD_EXP 2
3573: PUSH
3574: LD_VAR 0 1
3578: ARRAY
3579: PPUSH
3580: CALL 10346 0 1
3584: PPUSH
3585: CALL_OW 115
3589: GO 3724
// if conv_squad and GetDistUnitXY ( escort [ i ] , 64 , 117 ) > 35 and not HasTask ( escort [ i ] ) then
3591: LD_EXP 1
3595: PUSH
3596: LD_EXP 2
3600: PUSH
3601: LD_VAR 0 1
3605: ARRAY
3606: PPUSH
3607: LD_INT 64
3609: PPUSH
3610: LD_INT 117
3612: PPUSH
3613: CALL_OW 297
3617: PUSH
3618: LD_INT 35
3620: GREATER
3621: AND
3622: PUSH
3623: LD_EXP 2
3627: PUSH
3628: LD_VAR 0 1
3632: ARRAY
3633: PPUSH
3634: CALL_OW 314
3638: NOT
3639: AND
3640: IFFALSE 3706
// begin if GetDistUnits ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) > 6 then
3642: LD_EXP 2
3646: PUSH
3647: LD_VAR 0 1
3651: ARRAY
3652: PPUSH
3653: LD_EXP 1
3657: PUSH
3658: LD_INT 1
3660: ARRAY
3661: PUSH
3662: LD_INT 1
3664: ARRAY
3665: PPUSH
3666: CALL_OW 296
3670: PUSH
3671: LD_INT 6
3673: GREATER
3674: IFFALSE 3704
// ComMoveUnit ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) end else
3676: LD_EXP 2
3680: PUSH
3681: LD_VAR 0 1
3685: ARRAY
3686: PPUSH
3687: LD_EXP 1
3691: PUSH
3692: LD_INT 1
3694: ARRAY
3695: PUSH
3696: LD_INT 1
3698: ARRAY
3699: PPUSH
3700: CALL_OW 112
3704: GO 3724
// ComMoveToArea ( escort [ i ] , conv_end ) ;
3706: LD_EXP 2
3710: PUSH
3711: LD_VAR 0 1
3715: ARRAY
3716: PPUSH
3717: LD_INT 9
3719: PPUSH
3720: CALL_OW 113
// end ;
3724: GO 3420
3726: POP
3727: POP
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) then
3728: LD_INT 22
3730: PUSH
3731: LD_INT 6
3733: PUSH
3734: EMPTY
3735: LIST
3736: LIST
3737: PUSH
3738: LD_INT 21
3740: PUSH
3741: LD_INT 1
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PPUSH
3752: CALL_OW 69
3756: IFFALSE 3861
// for j in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) do
3758: LD_ADDR_VAR 0 2
3762: PUSH
3763: LD_INT 22
3765: PUSH
3766: LD_INT 6
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: LD_INT 21
3775: PUSH
3776: LD_INT 1
3778: PUSH
3779: EMPTY
3780: LIST
3781: LIST
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: PPUSH
3787: CALL_OW 69
3791: PUSH
3792: FOR_IN
3793: IFFALSE 3859
// begin if not HasTask ( j ) and not IsInArea ( j , conv_end ) then
3795: LD_VAR 0 2
3799: PPUSH
3800: CALL_OW 314
3804: NOT
3805: PUSH
3806: LD_VAR 0 2
3810: PPUSH
3811: LD_INT 9
3813: PPUSH
3814: CALL_OW 308
3818: NOT
3819: AND
3820: IFFALSE 3834
// ComMoveToArea ( j , conv_end ) ;
3822: LD_VAR 0 2
3826: PPUSH
3827: LD_INT 9
3829: PPUSH
3830: CALL_OW 113
// if IsInArea ( j , conv_end ) then
3834: LD_VAR 0 2
3838: PPUSH
3839: LD_INT 9
3841: PPUSH
3842: CALL_OW 308
3846: IFFALSE 3857
// RemoveUnit ( j ) ;
3848: LD_VAR 0 2
3852: PPUSH
3853: CALL_OW 64
// end ;
3857: GO 3792
3859: POP
3860: POP
// end ;
3861: PPOPN 2
3863: END
// every 0 0$01 trigger UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do var i ;
3864: LD_EXP 2
3868: PUSH
3869: LD_EXP 1
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: PPUSH
3878: LD_INT 22
3880: PUSH
3881: LD_INT 3
3883: PUSH
3884: EMPTY
3885: LIST
3886: LIST
3887: PPUSH
3888: CALL_OW 72
3892: IFFALSE 3954
3894: GO 3896
3896: DISABLE
3897: LD_INT 0
3899: PPUSH
// begin enable ;
3900: ENABLE
// for i in UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do
3901: LD_ADDR_VAR 0 1
3905: PUSH
3906: LD_EXP 2
3910: PUSH
3911: LD_EXP 1
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PPUSH
3920: LD_INT 22
3922: PUSH
3923: LD_INT 3
3925: PUSH
3926: EMPTY
3927: LIST
3928: LIST
3929: PPUSH
3930: CALL_OW 72
3934: PUSH
3935: FOR_IN
3936: IFFALSE 3952
// SetSide ( i , 6 ) ;
3938: LD_VAR 0 1
3942: PPUSH
3943: LD_INT 6
3945: PPUSH
3946: CALL_OW 235
3950: GO 3935
3952: POP
3953: POP
// end ; end_of_file
3954: PPOPN 1
3956: END
// export Collins ; export us_alert , us_retreat , us_patrol , us_count ; export function PrepareAmerican ; var i , un , skill , towers ; begin
3957: LD_INT 0
3959: PPUSH
3960: PPUSH
3961: PPUSH
3962: PPUSH
3963: PPUSH
// uc_side := 1 ;
3964: LD_ADDR_OWVAR 20
3968: PUSH
3969: LD_INT 1
3971: ST_TO_ADDR
// uc_nation := 1 ;
3972: LD_ADDR_OWVAR 21
3976: PUSH
3977: LD_INT 1
3979: ST_TO_ADDR
// us_alert := false ;
3980: LD_ADDR_EXP 20
3984: PUSH
3985: LD_INT 0
3987: ST_TO_ADDR
// us_retreat := false ;
3988: LD_ADDR_EXP 21
3992: PUSH
3993: LD_INT 0
3995: ST_TO_ADDR
// us_patrol := false ;
3996: LD_ADDR_EXP 22
4000: PUSH
4001: LD_INT 0
4003: ST_TO_ADDR
// us_count := 0 ;
4004: LD_ADDR_EXP 23
4008: PUSH
4009: LD_INT 0
4011: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4012: LD_ADDR_VAR 0 4
4016: PUSH
4017: LD_INT 5
4019: PUSH
4020: LD_INT 6
4022: PUSH
4023: LD_INT 7
4025: PUSH
4026: EMPTY
4027: LIST
4028: LIST
4029: LIST
4030: PUSH
4031: LD_OWVAR 67
4035: ARRAY
4036: ST_TO_ADDR
// hc_class := 1 ;
4037: LD_ADDR_OWVAR 28
4041: PUSH
4042: LD_INT 1
4044: ST_TO_ADDR
// hc_sex := sex_male ;
4045: LD_ADDR_OWVAR 27
4049: PUSH
4050: LD_INT 1
4052: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
4053: LD_ADDR_OWVAR 31
4057: PUSH
4058: LD_INT 6
4060: PUSH
4061: LD_INT 3
4063: PUSH
4064: LD_INT 4
4066: PUSH
4067: LD_INT 2
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: LIST
4074: LIST
4075: ST_TO_ADDR
// hc_name := Jack Collins ;
4076: LD_ADDR_OWVAR 26
4080: PUSH
4081: LD_STRING Jack Collins
4083: ST_TO_ADDR
// hc_attr := [ 11 , 11 ] ;
4084: LD_ADDR_OWVAR 29
4088: PUSH
4089: LD_INT 11
4091: PUSH
4092: LD_INT 11
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: ST_TO_ADDR
// hc_gallery :=  ;
4099: LD_ADDR_OWVAR 33
4103: PUSH
4104: LD_STRING 
4106: ST_TO_ADDR
// Collins := CreateHuman ;
4107: LD_ADDR_EXP 19
4111: PUSH
4112: CALL_OW 44
4116: ST_TO_ADDR
// PlaceHumanInUnit ( Collins , us_depot ) ;
4117: LD_EXP 19
4121: PPUSH
4122: LD_INT 50
4124: PPUSH
4125: CALL_OW 52
// hc_name :=  ;
4129: LD_ADDR_OWVAR 26
4133: PUSH
4134: LD_STRING 
4136: ST_TO_ADDR
// if Difficulty > 1 then
4137: LD_OWVAR 67
4141: PUSH
4142: LD_INT 1
4144: GREATER
4145: IFFALSE 4199
// begin bc_type := b_bunker ;
4147: LD_ADDR_OWVAR 42
4151: PUSH
4152: LD_INT 32
4154: ST_TO_ADDR
// bc_level := 5 ;
4155: LD_ADDR_OWVAR 43
4159: PUSH
4160: LD_INT 5
4162: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 40 , 33 , 2 ) ;
4163: LD_INT 40
4165: PPUSH
4166: LD_INT 33
4168: PPUSH
4169: LD_INT 2
4171: PPUSH
4172: CALL_OW 47
// if Difficulty > 2 then
4176: LD_OWVAR 67
4180: PUSH
4181: LD_INT 2
4183: GREATER
4184: IFFALSE 4199
// CreateAndPlaceBuildingXYD ( 41 , 42 , 0 ) ;
4186: LD_INT 41
4188: PPUSH
4189: LD_INT 42
4191: PPUSH
4192: LD_INT 0
4194: PPUSH
4195: CALL_OW 47
// end ; PrepareHuman ( false , 2 , skill ) ;
4199: LD_INT 0
4201: PPUSH
4202: LD_INT 2
4204: PPUSH
4205: LD_VAR 0 4
4209: PPUSH
4210: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
4214: CALL_OW 44
4218: PPUSH
4219: LD_INT 50
4221: PPUSH
4222: CALL_OW 52
// PrepareHuman ( false , 3 , skill ) ;
4226: LD_INT 0
4228: PPUSH
4229: LD_INT 3
4231: PPUSH
4232: LD_VAR 0 4
4236: PPUSH
4237: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4241: CALL_OW 44
4245: PPUSH
4246: LD_INT 56
4248: PPUSH
4249: CALL_OW 52
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4253: CALL_OW 44
4257: PPUSH
4258: LD_INT 56
4260: PPUSH
4261: CALL_OW 52
// PrepareHuman ( false , 4 , skill ) ;
4265: LD_INT 0
4267: PPUSH
4268: LD_INT 4
4270: PPUSH
4271: LD_VAR 0 4
4275: PPUSH
4276: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
4280: CALL_OW 44
4284: PPUSH
4285: LD_INT 63
4287: PPUSH
4288: CALL_OW 52
// PrepareHuman ( false , 1 , skill ) ;
4292: LD_INT 0
4294: PPUSH
4295: LD_INT 1
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: CALL_OW 380
// un := CreateHuman ;
4307: LD_ADDR_VAR 0 3
4311: PUSH
4312: CALL_OW 44
4316: ST_TO_ADDR
// SetDir ( un , 4 ) ;
4317: LD_VAR 0 3
4321: PPUSH
4322: LD_INT 4
4324: PPUSH
4325: CALL_OW 233
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
4329: LD_VAR 0 3
4333: PPUSH
4334: LD_INT 22
4336: PUSH
4337: LD_INT 1
4339: PUSH
4340: EMPTY
4341: LIST
4342: LIST
4343: PUSH
4344: LD_INT 30
4346: PUSH
4347: LD_INT 31
4349: PUSH
4350: EMPTY
4351: LIST
4352: LIST
4353: PUSH
4354: EMPTY
4355: LIST
4356: LIST
4357: PPUSH
4358: CALL_OW 69
4362: PUSH
4363: LD_INT 1
4365: ARRAY
4366: PPUSH
4367: CALL_OW 52
// towers := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) ;
4371: LD_ADDR_VAR 0 5
4375: PUSH
4376: LD_INT 22
4378: PUSH
4379: LD_INT 1
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: PUSH
4386: LD_INT 30
4388: PUSH
4389: LD_INT 32
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: PPUSH
4400: CALL_OW 69
4404: ST_TO_ADDR
// for i in towers do
4405: LD_ADDR_VAR 0 2
4409: PUSH
4410: LD_VAR 0 5
4414: PUSH
4415: FOR_IN
4416: IFFALSE 4484
// begin PrepareHuman ( false , 1 , skill ) ;
4418: LD_INT 0
4420: PPUSH
4421: LD_INT 1
4423: PPUSH
4424: LD_VAR 0 4
4428: PPUSH
4429: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4433: CALL_OW 44
4437: PPUSH
4438: LD_VAR 0 2
4442: PPUSH
4443: CALL_OW 52
// PlaceWeaponTurret ( i , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
4447: LD_VAR 0 2
4451: PPUSH
4452: LD_INT 4
4454: PUSH
4455: LD_INT 3
4457: PUSH
4458: LD_INT 5
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: LIST
4465: PUSH
4466: LD_INT 1
4468: PPUSH
4469: LD_INT 3
4471: PPUSH
4472: CALL_OW 12
4476: ARRAY
4477: PPUSH
4478: CALL_OW 431
// end ;
4482: GO 4415
4484: POP
4485: POP
// PrepareHuman ( false , 1 , skill ) ;
4486: LD_INT 0
4488: PPUSH
4489: LD_INT 1
4491: PPUSH
4492: LD_VAR 0 4
4496: PPUSH
4497: CALL_OW 380
// us_patrol := CreateHuman ;
4501: LD_ADDR_EXP 22
4505: PUSH
4506: CALL_OW 44
4510: ST_TO_ADDR
// PlaceUnitXY ( us_patrol , 12 , 5 , false ) ;
4511: LD_EXP 22
4515: PPUSH
4516: LD_INT 12
4518: PPUSH
4519: LD_INT 5
4521: PPUSH
4522: LD_INT 0
4524: PPUSH
4525: CALL_OW 48
// end ;
4529: LD_VAR 0 1
4533: RET
// every 0 0$01 trigger us_count >= [ 3 , 4 , 5 ] [ Difficulty ] do
4534: LD_EXP 23
4538: PUSH
4539: LD_INT 3
4541: PUSH
4542: LD_INT 4
4544: PUSH
4545: LD_INT 5
4547: PUSH
4548: EMPTY
4549: LIST
4550: LIST
4551: LIST
4552: PUSH
4553: LD_OWVAR 67
4557: ARRAY
4558: GREATEREQUAL
4559: IFFALSE 4584
4561: GO 4563
4563: DISABLE
// begin Say ( Collins , DPM_C2 ) ;
4564: LD_EXP 19
4568: PPUSH
4569: LD_STRING DPM_C2
4571: PPUSH
4572: CALL_OW 88
// us_retreat := true ;
4576: LD_ADDR_EXP 21
4580: PUSH
4581: LD_INT 1
4583: ST_TO_ADDR
// end ;
4584: END
// every 10 10$00 trigger not us_alert do var R ;
4585: LD_EXP 20
4589: NOT
4590: IFFALSE 4664
4592: GO 4594
4594: DISABLE
4595: LD_INT 0
4597: PPUSH
// begin uc_side := 1 ;
4598: LD_ADDR_OWVAR 20
4602: PUSH
4603: LD_INT 1
4605: ST_TO_ADDR
// uc_nation := 1 ;
4606: LD_ADDR_OWVAR 21
4610: PUSH
4611: LD_INT 1
4613: ST_TO_ADDR
// PrepareHuman ( false , 1 , 0 ) ;
4614: LD_INT 0
4616: PPUSH
4617: LD_INT 1
4619: PPUSH
4620: LD_INT 0
4622: PPUSH
4623: CALL_OW 380
// R := CreateHuman ;
4627: LD_ADDR_VAR 0 1
4631: PUSH
4632: CALL_OW 44
4636: ST_TO_ADDR
// SayRadio ( R , DPM_R1 ) ;
4637: LD_VAR 0 1
4641: PPUSH
4642: LD_STRING DPM_R1
4644: PPUSH
4645: CALL_OW 94
// Wait ( 0 0$03 ) ;
4649: LD_INT 105
4651: PPUSH
4652: CALL_OW 67
// us_retreat := true ;
4656: LD_ADDR_EXP 21
4660: PUSH
4661: LD_INT 1
4663: ST_TO_ADDR
// end ;
4664: PPOPN 1
4666: END
// every 0 0$01 trigger us_alert do var i ;
4667: LD_EXP 20
4671: IFFALSE 4931
4673: GO 4675
4675: DISABLE
4676: LD_INT 0
4678: PPUSH
// begin Say ( Collins , DPM_C1 ) ;
4679: LD_EXP 19
4683: PPUSH
4684: LD_STRING DPM_C1
4686: PPUSH
4687: CALL_OW 88
// if UnitsInside ( us_fac ) then
4691: LD_INT 56
4693: PPUSH
4694: CALL_OW 313
4698: IFFALSE 4753
// for i in UnitsInside ( us_fac ) do
4700: LD_ADDR_VAR 0 1
4704: PUSH
4705: LD_INT 56
4707: PPUSH
4708: CALL_OW 313
4712: PUSH
4713: FOR_IN
4714: IFFALSE 4751
// begin ComExitBuilding ( i ) ;
4716: LD_VAR 0 1
4720: PPUSH
4721: CALL_OW 122
// AddComEnterUnit ( i , us_arm ) ;
4725: LD_VAR 0 1
4729: PPUSH
4730: LD_INT 69
4732: PPUSH
4733: CALL_OW 180
// AddComChangeProfession ( i , 1 ) ;
4737: LD_VAR 0 1
4741: PPUSH
4742: LD_INT 1
4744: PPUSH
4745: CALL_OW 183
// end ;
4749: GO 4713
4751: POP
4752: POP
// ComExitBuilding ( Collins ) ;
4753: LD_EXP 19
4757: PPUSH
4758: CALL_OW 122
// AddComEnterUnit ( Collins , us_arm ) ;
4762: LD_EXP 19
4766: PPUSH
4767: LD_INT 69
4769: PPUSH
4770: CALL_OW 180
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] ) ;
4774: LD_INT 22
4776: PUSH
4777: LD_INT 1
4779: PUSH
4780: EMPTY
4781: LIST
4782: LIST
4783: PUSH
4784: LD_INT 25
4786: PUSH
4787: LD_INT 2
4789: PUSH
4790: EMPTY
4791: LIST
4792: LIST
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: PPUSH
4798: CALL_OW 69
4802: PUSH
4803: LD_INT 1
4805: ARRAY
4806: PPUSH
4807: CALL_OW 122
// AddComMoveXY ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , 67 , 52 ) ;
4811: LD_INT 22
4813: PUSH
4814: LD_INT 1
4816: PUSH
4817: EMPTY
4818: LIST
4819: LIST
4820: PUSH
4821: LD_INT 25
4823: PUSH
4824: LD_INT 2
4826: PUSH
4827: EMPTY
4828: LIST
4829: LIST
4830: PUSH
4831: EMPTY
4832: LIST
4833: LIST
4834: PPUSH
4835: CALL_OW 69
4839: PUSH
4840: LD_INT 1
4842: ARRAY
4843: PPUSH
4844: LD_INT 67
4846: PPUSH
4847: LD_INT 52
4849: PPUSH
4850: CALL_OW 171
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] ) ;
4854: LD_INT 22
4856: PUSH
4857: LD_INT 1
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: PUSH
4864: LD_INT 25
4866: PUSH
4867: LD_INT 4
4869: PUSH
4870: EMPTY
4871: LIST
4872: LIST
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PPUSH
4878: CALL_OW 69
4882: PUSH
4883: LD_INT 1
4885: ARRAY
4886: PPUSH
4887: CALL_OW 122
// AddComEnterUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] , us_arm ) ;
4891: LD_INT 22
4893: PUSH
4894: LD_INT 1
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: PUSH
4901: LD_INT 25
4903: PUSH
4904: LD_INT 4
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PPUSH
4915: CALL_OW 69
4919: PUSH
4920: LD_INT 1
4922: ARRAY
4923: PPUSH
4924: LD_INT 69
4926: PPUSH
4927: CALL_OW 180
// end ;
4931: PPOPN 1
4933: END
// every 3 3$00 trigger not us_alert and GetSide ( us_fac ) = 1 do
4934: LD_EXP 20
4938: NOT
4939: PUSH
4940: LD_INT 56
4942: PPUSH
4943: CALL_OW 255
4947: PUSH
4948: LD_INT 1
4950: EQUAL
4951: AND
4952: IFFALSE 4995
4954: GO 4956
4956: DISABLE
// begin AddComConstruct ( us_fac , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun ) ;
4957: LD_INT 56
4959: PPUSH
4960: LD_INT 2
4962: PPUSH
4963: LD_INT 1
4965: PPUSH
4966: LD_INT 1
4968: PPUSH
4969: LD_INT 4
4971: PPUSH
4972: CALL_OW 185
// AddComConstruct ( us_fac , us_medium_tracked , engine_solar , control_manual , us_double_gun ) ;
4976: LD_INT 56
4978: PPUSH
4979: LD_INT 3
4981: PPUSH
4982: LD_INT 2
4984: PPUSH
4985: LD_INT 1
4987: PPUSH
4988: LD_INT 5
4990: PPUSH
4991: CALL_OW 185
// end ;
4995: END
// every 0 0$01 trigger us_patrol do
4996: LD_EXP 22
5000: IFFALSE 5048
5002: GO 5004
5004: DISABLE
// SetPatrol ( us_patrol , [ 12 , 5 , 56 , 4 , 94 , 34 , 92 , 108 ] ) ;
5005: LD_EXP 22
5009: PPUSH
5010: LD_INT 12
5012: PUSH
5013: LD_INT 5
5015: PUSH
5016: LD_INT 56
5018: PUSH
5019: LD_INT 4
5021: PUSH
5022: LD_INT 94
5024: PUSH
5025: LD_INT 34
5027: PUSH
5028: LD_INT 92
5030: PUSH
5031: LD_INT 108
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: LIST
5038: LIST
5039: LIST
5040: LIST
5041: LIST
5042: LIST
5043: PPUSH
5044: CALL 5049 0 2
5048: END
// export function SetPatrol ( un , points ) ; var s , i , turn ; begin
5049: LD_INT 0
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
// s = 1 ;
5055: LD_ADDR_VAR 0 4
5059: PUSH
5060: LD_INT 1
5062: ST_TO_ADDR
// turn := true ;
5063: LD_ADDR_VAR 0 6
5067: PUSH
5068: LD_INT 1
5070: ST_TO_ADDR
// while ( un and not us_alert ) do
5071: LD_VAR 0 1
5075: PUSH
5076: LD_EXP 20
5080: NOT
5081: AND
5082: IFFALSE 5261
// begin wait ( 35 ) ;
5084: LD_INT 35
5086: PPUSH
5087: CALL_OW 67
// if not HasTask ( un ) then
5091: LD_VAR 0 1
5095: PPUSH
5096: CALL_OW 314
5100: NOT
5101: IFFALSE 5220
// begin ComMoveXY ( un , points [ s ] , points [ s + 1 ] ) ;
5103: LD_VAR 0 1
5107: PPUSH
5108: LD_VAR 0 2
5112: PUSH
5113: LD_VAR 0 4
5117: ARRAY
5118: PPUSH
5119: LD_VAR 0 2
5123: PUSH
5124: LD_VAR 0 4
5128: PUSH
5129: LD_INT 1
5131: PLUS
5132: ARRAY
5133: PPUSH
5134: CALL_OW 111
// if s + 2 > points then
5138: LD_VAR 0 4
5142: PUSH
5143: LD_INT 2
5145: PLUS
5146: PUSH
5147: LD_VAR 0 2
5151: GREATER
5152: IFFALSE 5162
// turn := false ;
5154: LD_ADDR_VAR 0 6
5158: PUSH
5159: LD_INT 0
5161: ST_TO_ADDR
// if s - 2 < 1 then
5162: LD_VAR 0 4
5166: PUSH
5167: LD_INT 2
5169: MINUS
5170: PUSH
5171: LD_INT 1
5173: LESS
5174: IFFALSE 5184
// turn := true ;
5176: LD_ADDR_VAR 0 6
5180: PUSH
5181: LD_INT 1
5183: ST_TO_ADDR
// if turn then
5184: LD_VAR 0 6
5188: IFFALSE 5206
// s := s + 2 else
5190: LD_ADDR_VAR 0 4
5194: PUSH
5195: LD_VAR 0 4
5199: PUSH
5200: LD_INT 2
5202: PLUS
5203: ST_TO_ADDR
5204: GO 5220
// s := s - 2 ;
5206: LD_ADDR_VAR 0 4
5210: PUSH
5211: LD_VAR 0 4
5215: PUSH
5216: LD_INT 2
5218: MINUS
5219: ST_TO_ADDR
// end ; if GetLives ( un ) < 1000 or See ( 3 , un ) then
5220: LD_VAR 0 1
5224: PPUSH
5225: CALL_OW 256
5229: PUSH
5230: LD_INT 1000
5232: LESS
5233: PUSH
5234: LD_INT 3
5236: PPUSH
5237: LD_VAR 0 1
5241: PPUSH
5242: CALL_OW 292
5246: OR
5247: IFFALSE 5259
// begin us_alert := true ;
5249: LD_ADDR_EXP 20
5253: PUSH
5254: LD_INT 1
5256: ST_TO_ADDR
// break ;
5257: GO 5261
// end ; end ;
5259: GO 5071
// ComEnterUnit ( un , us_arm ) ;
5261: LD_VAR 0 1
5265: PPUSH
5266: LD_INT 69
5268: PPUSH
5269: CALL_OW 120
// end ;
5273: LD_VAR 0 3
5277: RET
// every 0 0$01 trigger us_retreat do var i , point ;
5278: LD_EXP 21
5282: IFFALSE 5457
5284: GO 5286
5286: DISABLE
5287: LD_INT 0
5289: PPUSH
5290: PPUSH
// begin point := false ;
5291: LD_ADDR_VAR 0 2
5295: PUSH
5296: LD_INT 0
5298: ST_TO_ADDR
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5299: LD_INT 5
5301: PPUSH
5302: LD_INT 22
5304: PUSH
5305: LD_INT 3
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: PPUSH
5312: CALL_OW 70
5316: PUSH
5317: LD_INT 0
5319: EQUAL
5320: IFFALSE 5332
// point := us_ret1 else
5322: LD_ADDR_VAR 0 2
5326: PUSH
5327: LD_INT 3
5329: ST_TO_ADDR
5330: GO 5373
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5332: LD_INT 5
5334: PPUSH
5335: LD_INT 22
5337: PUSH
5338: LD_INT 3
5340: PUSH
5341: EMPTY
5342: LIST
5343: LIST
5344: PPUSH
5345: CALL_OW 70
5349: PUSH
5350: LD_INT 0
5352: EQUAL
5353: IFFALSE 5365
// point := us_ret2 else
5355: LD_ADDR_VAR 0 2
5359: PUSH
5360: LD_INT 2
5362: ST_TO_ADDR
5363: GO 5373
// point := us_ret3 ;
5365: LD_ADDR_VAR 0 2
5369: PUSH
5370: LD_INT 4
5372: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
5373: LD_ADDR_VAR 0 1
5377: PUSH
5378: LD_INT 22
5380: PUSH
5381: LD_INT 1
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: PUSH
5388: LD_INT 21
5390: PUSH
5391: LD_INT 1
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: PUSH
5398: EMPTY
5399: LIST
5400: LIST
5401: PPUSH
5402: CALL_OW 69
5406: PUSH
5407: FOR_IN
5408: IFFALSE 5455
// begin if IsInUnit ( i ) then
5410: LD_VAR 0 1
5414: PPUSH
5415: CALL_OW 310
5419: IFFALSE 5439
// begin ComExitBuilding ( i ) ;
5421: LD_VAR 0 1
5425: PPUSH
5426: CALL_OW 122
// ComExitVehicle ( i ) ;
5430: LD_VAR 0 1
5434: PPUSH
5435: CALL_OW 121
// end ; AddComMoveToArea ( i , point ) ;
5439: LD_VAR 0 1
5443: PPUSH
5444: LD_VAR 0 2
5448: PPUSH
5449: CALL_OW 173
// end ;
5453: GO 5407
5455: POP
5456: POP
// end ;
5457: PPOPN 2
5459: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) do
5460: LD_EXP 21
5464: PUSH
5465: LD_INT 3
5467: PPUSH
5468: LD_INT 22
5470: PUSH
5471: LD_INT 1
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: PPUSH
5478: CALL_OW 70
5482: AND
5483: IFFALSE 5529
5485: GO 5487
5487: DISABLE
// begin enable ;
5488: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) [ 1 ] ) ;
5489: LD_INT 3
5491: PPUSH
5492: LD_INT 22
5494: PUSH
5495: LD_INT 1
5497: PUSH
5498: EMPTY
5499: LIST
5500: LIST
5501: PPUSH
5502: CALL_OW 70
5506: PUSH
5507: LD_INT 1
5509: ARRAY
5510: PPUSH
5511: CALL_OW 64
// if medal1 then
5515: LD_EXP 3
5519: IFFALSE 5529
// medal1 := false ;
5521: LD_ADDR_EXP 3
5525: PUSH
5526: LD_INT 0
5528: ST_TO_ADDR
// end ;
5529: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) do
5530: LD_EXP 21
5534: PUSH
5535: LD_INT 2
5537: PPUSH
5538: LD_INT 22
5540: PUSH
5541: LD_INT 1
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: PPUSH
5548: CALL_OW 70
5552: AND
5553: IFFALSE 5599
5555: GO 5557
5557: DISABLE
// begin enable ;
5558: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) [ 1 ] ) ;
5559: LD_INT 2
5561: PPUSH
5562: LD_INT 22
5564: PUSH
5565: LD_INT 1
5567: PUSH
5568: EMPTY
5569: LIST
5570: LIST
5571: PPUSH
5572: CALL_OW 70
5576: PUSH
5577: LD_INT 1
5579: ARRAY
5580: PPUSH
5581: CALL_OW 64
// if medal1 then
5585: LD_EXP 3
5589: IFFALSE 5599
// medal1 := false ;
5591: LD_ADDR_EXP 3
5595: PUSH
5596: LD_INT 0
5598: ST_TO_ADDR
// end ;
5599: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) do
5600: LD_EXP 21
5604: PUSH
5605: LD_INT 4
5607: PPUSH
5608: LD_INT 22
5610: PUSH
5611: LD_INT 1
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PPUSH
5618: CALL_OW 70
5622: AND
5623: IFFALSE 5669
5625: GO 5627
5627: DISABLE
// begin enable ;
5628: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) [ 1 ] ) ;
5629: LD_INT 4
5631: PPUSH
5632: LD_INT 22
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: PPUSH
5642: CALL_OW 70
5646: PUSH
5647: LD_INT 1
5649: ARRAY
5650: PPUSH
5651: CALL_OW 64
// if medal1 then
5655: LD_EXP 3
5659: IFFALSE 5669
// medal1 := false ;
5661: LD_ADDR_EXP 3
5665: PUSH
5666: LD_INT 0
5668: ST_TO_ADDR
// end ;
5669: END
// every 0 0$03 trigger FilterAllUnits ( [ f_side , 1 ] ) = 0 do
5670: LD_INT 22
5672: PUSH
5673: LD_INT 1
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: PPUSH
5680: CALL_OW 69
5684: PUSH
5685: LD_INT 0
5687: EQUAL
5688: IFFALSE 5701
5690: GO 5692
5692: DISABLE
// us_retreat := false ;
5693: LD_ADDR_EXP 21
5697: PUSH
5698: LD_INT 0
5700: ST_TO_ADDR
5701: END
// export function CounterAttack ; var i , j , un , skill ; begin
5702: LD_INT 0
5704: PPUSH
5705: PPUSH
5706: PPUSH
5707: PPUSH
5708: PPUSH
// uc_side := 1 ;
5709: LD_ADDR_OWVAR 20
5713: PUSH
5714: LD_INT 1
5716: ST_TO_ADDR
// uc_nation := 1 ;
5717: LD_ADDR_OWVAR 21
5721: PUSH
5722: LD_INT 1
5724: ST_TO_ADDR
// skill := [ 4 , 5 , 5 ] [ Difficulty ] ;
5725: LD_ADDR_VAR 0 5
5729: PUSH
5730: LD_INT 4
5732: PUSH
5733: LD_INT 5
5735: PUSH
5736: LD_INT 5
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_OWVAR 67
5748: ARRAY
5749: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
5750: LD_ADDR_VAR 0 2
5754: PUSH
5755: DOUBLE
5756: LD_INT 1
5758: DEC
5759: ST_TO_ADDR
5760: LD_INT 4
5762: PUSH
5763: LD_INT 5
5765: PUSH
5766: LD_INT 6
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: PUSH
5774: LD_OWVAR 67
5778: ARRAY
5779: PUSH
5780: FOR_TO
5781: IFFALSE 5981
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 3 ) ] ;
5783: LD_ADDR_OWVAR 37
5787: PUSH
5788: LD_INT 2
5790: PUSH
5791: LD_INT 3
5793: PUSH
5794: LD_INT 4
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: LIST
5801: PUSH
5802: LD_INT 1
5804: PPUSH
5805: LD_INT 3
5807: PPUSH
5808: CALL_OW 12
5812: ARRAY
5813: ST_TO_ADDR
// vc_engine := engine_combustion ;
5814: LD_ADDR_OWVAR 39
5818: PUSH
5819: LD_INT 1
5821: ST_TO_ADDR
// vc_control := control_manual ;
5822: LD_ADDR_OWVAR 38
5826: PUSH
5827: LD_INT 1
5829: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_light_gun ] [ Rand ( 1 , 3 ) ] ;
5830: LD_ADDR_OWVAR 40
5834: PUSH
5835: LD_INT 4
5837: PUSH
5838: LD_INT 5
5840: PUSH
5841: LD_INT 3
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 1
5851: PPUSH
5852: LD_INT 3
5854: PPUSH
5855: CALL_OW 12
5859: ARRAY
5860: ST_TO_ADDR
// vc_fuel_battery := Rand ( 88 , 99 ) ;
5861: LD_ADDR_OWVAR 41
5865: PUSH
5866: LD_INT 88
5868: PPUSH
5869: LD_INT 99
5871: PPUSH
5872: CALL_OW 12
5876: ST_TO_ADDR
// un := CreateVehicle ;
5877: LD_ADDR_VAR 0 4
5881: PUSH
5882: CALL_OW 45
5886: ST_TO_ADDR
// PlaceUnitXY ( un , 64 , 117 , false ) ;
5887: LD_VAR 0 4
5891: PPUSH
5892: LD_INT 64
5894: PPUSH
5895: LD_INT 117
5897: PPUSH
5898: LD_INT 0
5900: PPUSH
5901: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
5905: LD_INT 0
5907: PPUSH
5908: LD_INT 3
5910: PPUSH
5911: LD_VAR 0 5
5915: PPUSH
5916: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5920: CALL_OW 44
5924: PPUSH
5925: LD_VAR 0 4
5929: PPUSH
5930: CALL_OW 52
// us_force := Insert ( us_force , 1 , un ) ;
5934: LD_ADDR_EXP 12
5938: PUSH
5939: LD_EXP 12
5943: PPUSH
5944: LD_INT 1
5946: PPUSH
5947: LD_VAR 0 4
5951: PPUSH
5952: CALL_OW 2
5956: ST_TO_ADDR
// ComMoveXY ( un , 60 , 109 ) ;
5957: LD_VAR 0 4
5961: PPUSH
5962: LD_INT 60
5964: PPUSH
5965: LD_INT 109
5967: PPUSH
5968: CALL_OW 111
// Wait ( 0 0$02 ) ;
5972: LD_INT 70
5974: PPUSH
5975: CALL_OW 67
// end ;
5979: GO 5780
5981: POP
5982: POP
// while ( FilterAllUnits ( [ f_side , 1 ] ) ) do
5983: LD_INT 22
5985: PUSH
5986: LD_INT 1
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: PPUSH
5993: CALL_OW 69
5997: IFFALSE 6198
// begin Wait ( 0 0$01 ) ;
5999: LD_INT 35
6001: PPUSH
6002: CALL_OW 67
// for i = 1 to us_force do
6006: LD_ADDR_VAR 0 2
6010: PUSH
6011: DOUBLE
6012: LD_INT 1
6014: DEC
6015: ST_TO_ADDR
6016: LD_EXP 12
6020: PUSH
6021: FOR_TO
6022: IFFALSE 6057
// ComAttackUnit ( us_force [ i ] , FindTarget ( us_force [ i ] ) ) ;
6024: LD_EXP 12
6028: PUSH
6029: LD_VAR 0 2
6033: ARRAY
6034: PPUSH
6035: LD_EXP 12
6039: PUSH
6040: LD_VAR 0 2
6044: ARRAY
6045: PPUSH
6046: CALL 10346 0 1
6050: PPUSH
6051: CALL_OW 115
6055: GO 6021
6057: POP
6058: POP
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) then
6059: LD_INT 22
6061: PUSH
6062: LD_INT 1
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: PUSH
6069: LD_INT 25
6071: PUSH
6072: LD_INT 3
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: PUSH
6079: LD_INT 3
6081: PUSH
6082: LD_INT 55
6084: PUSH
6085: EMPTY
6086: LIST
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: LIST
6096: PPUSH
6097: CALL_OW 69
6101: IFFALSE 6196
// for j in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) do
6103: LD_ADDR_VAR 0 3
6107: PUSH
6108: LD_INT 22
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: PUSH
6118: LD_INT 25
6120: PUSH
6121: LD_INT 3
6123: PUSH
6124: EMPTY
6125: LIST
6126: LIST
6127: PUSH
6128: LD_INT 3
6130: PUSH
6131: LD_INT 55
6133: PUSH
6134: EMPTY
6135: LIST
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: LIST
6145: PPUSH
6146: CALL_OW 69
6150: PUSH
6151: FOR_IN
6152: IFFALSE 6194
// if not IsInArea ( j , conv_end ) then
6154: LD_VAR 0 3
6158: PPUSH
6159: LD_INT 9
6161: PPUSH
6162: CALL_OW 308
6166: NOT
6167: IFFALSE 6183
// ComMoveToArea ( j , conv_end ) else
6169: LD_VAR 0 3
6173: PPUSH
6174: LD_INT 9
6176: PPUSH
6177: CALL_OW 113
6181: GO 6192
// RemoveUnit ( j ) ;
6183: LD_VAR 0 3
6187: PPUSH
6188: CALL_OW 64
6192: GO 6151
6194: POP
6195: POP
// end ;
6196: GO 5983
// end ; end_of_file
6198: LD_VAR 0 1
6202: RET
// export function PrepareArabian ; begin
6203: LD_INT 0
6205: PPUSH
// RobertFarmer ;
6206: CALL 6227 0 0
// PrepareHovercrafts ;
6210: CALL 7097 0 0
// ar_attacks := true ;
6214: LD_ADDR_EXP 10
6218: PUSH
6219: LD_INT 1
6221: ST_TO_ADDR
// end ;
6222: LD_VAR 0 1
6226: RET
// export Farmer ; export function RobertFarmer ; begin
6227: LD_INT 0
6229: PPUSH
// uc_side := 2 ;
6230: LD_ADDR_OWVAR 20
6234: PUSH
6235: LD_INT 2
6237: ST_TO_ADDR
// uc_nation := 2 ;
6238: LD_ADDR_OWVAR 21
6242: PUSH
6243: LD_INT 2
6245: ST_TO_ADDR
// Farmer := NewCharacter ( Farmer ) ;
6246: LD_ADDR_EXP 24
6250: PUSH
6251: LD_STRING Farmer
6253: PPUSH
6254: CALL_OW 25
6258: ST_TO_ADDR
// SayRadio ( Farmer , DPM_F1 ) ;
6259: LD_EXP 24
6263: PPUSH
6264: LD_STRING DPM_F1
6266: PPUSH
6267: CALL_OW 94
// end ;
6271: LD_VAR 0 1
6275: RET
// export function PrepareAttack ( type ) ; var i , un , veh , skill ; begin
6276: LD_INT 0
6278: PPUSH
6279: PPUSH
6280: PPUSH
6281: PPUSH
6282: PPUSH
// uc_side := 2 ;
6283: LD_ADDR_OWVAR 20
6287: PUSH
6288: LD_INT 2
6290: ST_TO_ADDR
// uc_nation := 2 ;
6291: LD_ADDR_OWVAR 21
6295: PUSH
6296: LD_INT 2
6298: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
6299: LD_ADDR_VAR 0 6
6303: PUSH
6304: LD_INT 4
6306: PUSH
6307: LD_INT 5
6309: PUSH
6310: LD_INT 6
6312: PUSH
6313: EMPTY
6314: LIST
6315: LIST
6316: LIST
6317: PUSH
6318: LD_OWVAR 67
6322: ARRAY
6323: ST_TO_ADDR
// Randomize ;
6324: CALL_OW 10
// case type of 1 :
6328: LD_VAR 0 1
6332: PUSH
6333: LD_INT 1
6335: DOUBLE
6336: EQUAL
6337: IFTRUE 6341
6339: GO 6463
6341: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
6342: LD_ADDR_VAR 0 3
6346: PUSH
6347: DOUBLE
6348: LD_INT 1
6350: DEC
6351: ST_TO_ADDR
6352: LD_INT 3
6354: PUSH
6355: LD_INT 4
6357: PUSH
6358: LD_INT 5
6360: PUSH
6361: EMPTY
6362: LIST
6363: LIST
6364: LIST
6365: PUSH
6366: LD_OWVAR 67
6370: ARRAY
6371: PUSH
6372: FOR_TO
6373: IFFALSE 6459
// begin PrepareHuman ( false , [ class_soldier , class_soldier , class_mortar ] [ Rand ( 1 , 3 ) ] , skill ) ;
6375: LD_INT 0
6377: PPUSH
6378: LD_INT 1
6380: PUSH
6381: LD_INT 1
6383: PUSH
6384: LD_INT 8
6386: PUSH
6387: EMPTY
6388: LIST
6389: LIST
6390: LIST
6391: PUSH
6392: LD_INT 1
6394: PPUSH
6395: LD_INT 3
6397: PPUSH
6398: CALL_OW 12
6402: ARRAY
6403: PPUSH
6404: LD_VAR 0 6
6408: PPUSH
6409: CALL_OW 380
// un := CreateHuman ;
6413: LD_ADDR_VAR 0 4
6417: PUSH
6418: CALL_OW 44
6422: ST_TO_ADDR
// PlaceUnitArea ( un , ar3 , false ) ;
6423: LD_VAR 0 4
6427: PPUSH
6428: LD_INT 18
6430: PPUSH
6431: LD_INT 0
6433: PPUSH
6434: CALL_OW 49
// ComMoveToArea ( un , spot3 ) ;
6438: LD_VAR 0 4
6442: PPUSH
6443: LD_INT 20
6445: PPUSH
6446: CALL_OW 113
// Wait ( 0 0$01 ) ;
6450: LD_INT 35
6452: PPUSH
6453: CALL_OW 67
// end ;
6457: GO 6372
6459: POP
6460: POP
// end ; 2 :
6461: GO 7092
6463: LD_INT 2
6465: DOUBLE
6466: EQUAL
6467: IFTRUE 6471
6469: GO 6734
6471: POP
// begin for i = 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
6472: LD_ADDR_VAR 0 3
6476: PUSH
6477: DOUBLE
6478: LD_INT 1
6480: DEC
6481: ST_TO_ADDR
6482: LD_INT 4
6484: PUSH
6485: LD_INT 5
6487: PUSH
6488: LD_INT 5
6490: PUSH
6491: EMPTY
6492: LIST
6493: LIST
6494: LIST
6495: PUSH
6496: LD_OWVAR 67
6500: ARRAY
6501: PUSH
6502: FOR_TO
6503: IFFALSE 6566
// begin PrepareHuman ( false , class_soldier , skill ) ;
6505: LD_INT 0
6507: PPUSH
6508: LD_INT 1
6510: PPUSH
6511: LD_VAR 0 6
6515: PPUSH
6516: CALL_OW 380
// un := CreateHuman ;
6520: LD_ADDR_VAR 0 4
6524: PUSH
6525: CALL_OW 44
6529: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6530: LD_VAR 0 4
6534: PPUSH
6535: LD_INT 17
6537: PPUSH
6538: LD_INT 0
6540: PPUSH
6541: CALL_OW 49
// ComMoveToArea ( un , spot2 ) ;
6545: LD_VAR 0 4
6549: PPUSH
6550: LD_INT 19
6552: PPUSH
6553: CALL_OW 113
// Wait ( 0 0$01 ) ;
6557: LD_INT 35
6559: PPUSH
6560: CALL_OW 67
// end ;
6564: GO 6502
6566: POP
6567: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
6568: LD_ADDR_VAR 0 3
6572: PUSH
6573: DOUBLE
6574: LD_INT 1
6576: DEC
6577: ST_TO_ADDR
6578: LD_INT 2
6580: PUSH
6581: LD_INT 3
6583: PUSH
6584: LD_INT 4
6586: PUSH
6587: EMPTY
6588: LIST
6589: LIST
6590: LIST
6591: PUSH
6592: LD_OWVAR 67
6596: ARRAY
6597: PUSH
6598: FOR_TO
6599: IFFALSE 6730
// begin vc_chassis := ar_medium_trike ;
6601: LD_ADDR_OWVAR 37
6605: PUSH
6606: LD_INT 13
6608: ST_TO_ADDR
// vc_engine := engine_combustion ;
6609: LD_ADDR_OWVAR 39
6613: PUSH
6614: LD_INT 1
6616: ST_TO_ADDR
// vc_control := control_manual ;
6617: LD_ADDR_OWVAR 38
6621: PUSH
6622: LD_INT 1
6624: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_light_gun ] [ Rand ( 1 , 2 ) ] ;
6625: LD_ADDR_OWVAR 40
6629: PUSH
6630: LD_INT 24
6632: PUSH
6633: LD_INT 23
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: PUSH
6640: LD_INT 1
6642: PPUSH
6643: LD_INT 2
6645: PPUSH
6646: CALL_OW 12
6650: ARRAY
6651: ST_TO_ADDR
// veh := CreateVehicle ;
6652: LD_ADDR_VAR 0 5
6656: PUSH
6657: CALL_OW 45
6661: ST_TO_ADDR
// PlaceUnitArea ( veh , ar2 , false ) ;
6662: LD_VAR 0 5
6666: PPUSH
6667: LD_INT 17
6669: PPUSH
6670: LD_INT 0
6672: PPUSH
6673: CALL_OW 49
// PrepareHuman ( false , 1 , skill ) ;
6677: LD_INT 0
6679: PPUSH
6680: LD_INT 1
6682: PPUSH
6683: LD_VAR 0 6
6687: PPUSH
6688: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6692: CALL_OW 44
6696: PPUSH
6697: LD_VAR 0 5
6701: PPUSH
6702: CALL_OW 52
// ComMoveXY ( veh , 89 , 40 ) ;
6706: LD_VAR 0 5
6710: PPUSH
6711: LD_INT 89
6713: PPUSH
6714: LD_INT 40
6716: PPUSH
6717: CALL_OW 111
// Wait ( 0 0$02 ) ;
6721: LD_INT 70
6723: PPUSH
6724: CALL_OW 67
// end ;
6728: GO 6598
6730: POP
6731: POP
// end ; 3 :
6732: GO 7092
6734: LD_INT 3
6736: DOUBLE
6737: EQUAL
6738: IFTRUE 6742
6740: GO 7091
6742: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] + ( tick div 15 15$00 ) do
6743: LD_ADDR_VAR 0 3
6747: PUSH
6748: DOUBLE
6749: LD_INT 1
6751: DEC
6752: ST_TO_ADDR
6753: LD_INT 4
6755: PUSH
6756: LD_INT 5
6758: PUSH
6759: LD_INT 6
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: LIST
6766: PUSH
6767: LD_OWVAR 67
6771: ARRAY
6772: PUSH
6773: LD_OWVAR 1
6777: PUSH
6778: LD_INT 31500
6780: DIV
6781: PLUS
6782: PUSH
6783: FOR_TO
6784: IFFALSE 6892
// begin PrepareHuman ( false , [ class_soldier , class_mortar ] [ Rand ( 1 , 2 ) ] , skill ) ;
6786: LD_INT 0
6788: PPUSH
6789: LD_INT 1
6791: PUSH
6792: LD_INT 8
6794: PUSH
6795: EMPTY
6796: LIST
6797: LIST
6798: PUSH
6799: LD_INT 1
6801: PPUSH
6802: LD_INT 2
6804: PPUSH
6805: CALL_OW 12
6809: ARRAY
6810: PPUSH
6811: LD_VAR 0 6
6815: PPUSH
6816: CALL_OW 380
// un := CreateHuman ;
6820: LD_ADDR_VAR 0 4
6824: PUSH
6825: CALL_OW 44
6829: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6830: LD_VAR 0 4
6834: PPUSH
6835: LD_INT 17
6837: PPUSH
6838: LD_INT 0
6840: PPUSH
6841: CALL_OW 49
// ar_force := Insert ( ar_force , 1 , un ) ;
6845: LD_ADDR_EXP 11
6849: PUSH
6850: LD_EXP 11
6854: PPUSH
6855: LD_INT 1
6857: PPUSH
6858: LD_VAR 0 4
6862: PPUSH
6863: CALL_OW 2
6867: ST_TO_ADDR
// ComMoveXY ( un , 17 , 9 ) ;
6868: LD_VAR 0 4
6872: PPUSH
6873: LD_INT 17
6875: PPUSH
6876: LD_INT 9
6878: PPUSH
6879: CALL_OW 111
// Wait ( 0 0$01 ) ;
6883: LD_INT 35
6885: PPUSH
6886: CALL_OW 67
// end ;
6890: GO 6783
6892: POP
6893: POP
// for i = 1 to [ 4 , 5 , 7 ] [ Difficulty ] do
6894: LD_ADDR_VAR 0 3
6898: PUSH
6899: DOUBLE
6900: LD_INT 1
6902: DEC
6903: ST_TO_ADDR
6904: LD_INT 4
6906: PUSH
6907: LD_INT 5
6909: PUSH
6910: LD_INT 7
6912: PUSH
6913: EMPTY
6914: LIST
6915: LIST
6916: LIST
6917: PUSH
6918: LD_OWVAR 67
6922: ARRAY
6923: PUSH
6924: FOR_TO
6925: IFFALSE 7087
// begin vc_chassis := ar_half_tracked ;
6927: LD_ADDR_OWVAR 37
6931: PUSH
6932: LD_INT 14
6934: ST_TO_ADDR
// vc_engine := engine_combustion ;
6935: LD_ADDR_OWVAR 39
6939: PUSH
6940: LD_INT 1
6942: ST_TO_ADDR
// vc_control := control_manual ;
6943: LD_ADDR_OWVAR 38
6947: PUSH
6948: LD_INT 1
6950: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_flame_thrower ] [ Rand ( 1 , 4 ) ] ;
6951: LD_ADDR_OWVAR 40
6955: PUSH
6956: LD_INT 25
6958: PUSH
6959: LD_INT 27
6961: PUSH
6962: LD_INT 28
6964: PUSH
6965: LD_INT 26
6967: PUSH
6968: EMPTY
6969: LIST
6970: LIST
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 1
6976: PPUSH
6977: LD_INT 4
6979: PPUSH
6980: CALL_OW 12
6984: ARRAY
6985: ST_TO_ADDR
// veh := CreateVehicle ;
6986: LD_ADDR_VAR 0 5
6990: PUSH
6991: CALL_OW 45
6995: ST_TO_ADDR
// PlaceUnitArea ( veh , ar1 , false ) ;
6996: LD_VAR 0 5
7000: PPUSH
7001: LD_INT 16
7003: PPUSH
7004: LD_INT 0
7006: PPUSH
7007: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7011: LD_INT 0
7013: PPUSH
7014: LD_INT 3
7016: PPUSH
7017: LD_VAR 0 6
7021: PPUSH
7022: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
7026: CALL_OW 44
7030: PPUSH
7031: LD_VAR 0 5
7035: PPUSH
7036: CALL_OW 52
// ar_force := Insert ( ar_force , 1 , veh ) ;
7040: LD_ADDR_EXP 11
7044: PUSH
7045: LD_EXP 11
7049: PPUSH
7050: LD_INT 1
7052: PPUSH
7053: LD_VAR 0 5
7057: PPUSH
7058: CALL_OW 2
7062: ST_TO_ADDR
// ComMoveXY ( veh , 125 , 31 ) ;
7063: LD_VAR 0 5
7067: PPUSH
7068: LD_INT 125
7070: PPUSH
7071: LD_INT 31
7073: PPUSH
7074: CALL_OW 111
// Wait ( 0 0$02 ) ;
7078: LD_INT 70
7080: PPUSH
7081: CALL_OW 67
// end ;
7085: GO 6924
7087: POP
7088: POP
// end ; end ;
7089: GO 7092
7091: POP
// end ;
7092: LD_VAR 0 2
7096: RET
// export function PrepareHovercrafts ; var i , un , areas , skill ; begin
7097: LD_INT 0
7099: PPUSH
7100: PPUSH
7101: PPUSH
7102: PPUSH
7103: PPUSH
// areas := [ river1 , river2 ] ;
7104: LD_ADDR_VAR 0 4
7108: PUSH
7109: LD_INT 14
7111: PUSH
7112: LD_INT 15
7114: PUSH
7115: EMPTY
7116: LIST
7117: LIST
7118: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7119: LD_ADDR_VAR 0 5
7123: PUSH
7124: LD_INT 5
7126: PUSH
7127: LD_INT 6
7129: PUSH
7130: LD_INT 7
7132: PUSH
7133: EMPTY
7134: LIST
7135: LIST
7136: LIST
7137: PUSH
7138: LD_OWVAR 67
7142: ARRAY
7143: ST_TO_ADDR
// uc_side := 2 ;
7144: LD_ADDR_OWVAR 20
7148: PUSH
7149: LD_INT 2
7151: ST_TO_ADDR
// uc_nation := 2 ;
7152: LD_ADDR_OWVAR 21
7156: PUSH
7157: LD_INT 2
7159: ST_TO_ADDR
// hc_name :=  ;
7160: LD_ADDR_OWVAR 26
7164: PUSH
7165: LD_STRING 
7167: ST_TO_ADDR
// hc_gallery :=  ;
7168: LD_ADDR_OWVAR 33
7172: PUSH
7173: LD_STRING 
7175: ST_TO_ADDR
// for i = 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
7176: LD_ADDR_VAR 0 2
7180: PUSH
7181: DOUBLE
7182: LD_INT 1
7184: DEC
7185: ST_TO_ADDR
7186: LD_INT 1
7188: PUSH
7189: LD_INT 2
7191: PUSH
7192: LD_INT 2
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_OWVAR 67
7204: ARRAY
7205: PUSH
7206: FOR_TO
7207: IFFALSE 7345
// begin vc_chassis := ar_hovercraft ;
7209: LD_ADDR_OWVAR 37
7213: PUSH
7214: LD_INT 11
7216: ST_TO_ADDR
// vc_engine := engine_solar ;
7217: LD_ADDR_OWVAR 39
7221: PUSH
7222: LD_INT 2
7224: ST_TO_ADDR
// vc_control := control_manual ;
7225: LD_ADDR_OWVAR 38
7229: PUSH
7230: LD_INT 1
7232: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
7233: LD_ADDR_OWVAR 40
7237: PUSH
7238: LD_INT 24
7240: ST_TO_ADDR
// vc_fuel_battery := 100 ;
7241: LD_ADDR_OWVAR 41
7245: PUSH
7246: LD_INT 100
7248: ST_TO_ADDR
// un := CreateVehicle ;
7249: LD_ADDR_VAR 0 3
7253: PUSH
7254: CALL_OW 45
7258: ST_TO_ADDR
// PlaceUnitArea ( un , areas [ i ] , false ) ;
7259: LD_VAR 0 3
7263: PPUSH
7264: LD_VAR 0 4
7268: PUSH
7269: LD_VAR 0 2
7273: ARRAY
7274: PPUSH
7275: LD_INT 0
7277: PPUSH
7278: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7282: LD_INT 0
7284: PPUSH
7285: LD_INT 3
7287: PPUSH
7288: LD_VAR 0 5
7292: PPUSH
7293: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
7297: CALL_OW 44
7301: PPUSH
7302: LD_VAR 0 3
7306: PPUSH
7307: CALL_OW 52
// riv := Insert ( riv , 1 , [ un , i ] ) ;
7311: LD_ADDR_EXP 9
7315: PUSH
7316: LD_EXP 9
7320: PPUSH
7321: LD_INT 1
7323: PPUSH
7324: LD_VAR 0 3
7328: PUSH
7329: LD_VAR 0 2
7333: PUSH
7334: EMPTY
7335: LIST
7336: LIST
7337: PPUSH
7338: CALL_OW 2
7342: ST_TO_ADDR
// end ;
7343: GO 7206
7345: POP
7346: POP
// end ;
7347: LD_VAR 0 1
7351: RET
// every 0 0$01 trigger riv do var i , c ;
7352: LD_EXP 9
7356: IFFALSE 7675
7358: GO 7360
7360: DISABLE
7361: LD_INT 0
7363: PPUSH
7364: PPUSH
// begin enable ;
7365: ENABLE
// for i = riv downto 1 do
7366: LD_ADDR_VAR 0 1
7370: PUSH
7371: DOUBLE
7372: LD_EXP 9
7376: INC
7377: ST_TO_ADDR
7378: LD_INT 1
7380: PUSH
7381: FOR_DOWNTO
7382: IFFALSE 7673
// begin if not riv [ i ] [ 1 ] then
7384: LD_EXP 9
7388: PUSH
7389: LD_VAR 0 1
7393: ARRAY
7394: PUSH
7395: LD_INT 1
7397: ARRAY
7398: NOT
7399: IFFALSE 7421
// begin riv := Delete ( riv , 1 ) ;
7401: LD_ADDR_EXP 9
7405: PUSH
7406: LD_EXP 9
7410: PPUSH
7411: LD_INT 1
7413: PPUSH
7414: CALL_OW 3
7418: ST_TO_ADDR
// break ;
7419: GO 7673
// end ; if not HasTask ( riv [ i ] [ 1 ] ) then
7421: LD_EXP 9
7425: PUSH
7426: LD_VAR 0 1
7430: ARRAY
7431: PUSH
7432: LD_INT 1
7434: ARRAY
7435: PPUSH
7436: CALL_OW 314
7440: NOT
7441: IFFALSE 7509
// begin if riv [ i ] [ 2 ] = 1 then
7443: LD_EXP 9
7447: PUSH
7448: LD_VAR 0 1
7452: ARRAY
7453: PUSH
7454: LD_INT 2
7456: ARRAY
7457: PUSH
7458: LD_INT 1
7460: EQUAL
7461: IFFALSE 7473
// c := 2 else
7463: LD_ADDR_VAR 0 2
7467: PUSH
7468: LD_INT 2
7470: ST_TO_ADDR
7471: GO 7481
// c := 1 ;
7473: LD_ADDR_VAR 0 2
7477: PUSH
7478: LD_INT 1
7480: ST_TO_ADDR
// riv := Replace2 ( riv , i , 2 , c ) ;
7481: LD_ADDR_EXP 9
7485: PUSH
7486: LD_EXP 9
7490: PPUSH
7491: LD_VAR 0 1
7495: PPUSH
7496: LD_INT 2
7498: PPUSH
7499: LD_VAR 0 2
7503: PPUSH
7504: CALL 10038 0 4
7508: ST_TO_ADDR
// end ; if not IsInArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) then
7509: LD_EXP 9
7513: PUSH
7514: LD_VAR 0 1
7518: ARRAY
7519: PUSH
7520: LD_INT 1
7522: ARRAY
7523: PPUSH
7524: LD_INT 14
7526: PUSH
7527: LD_INT 15
7529: PUSH
7530: EMPTY
7531: LIST
7532: LIST
7533: PUSH
7534: LD_EXP 9
7538: PUSH
7539: LD_VAR 0 1
7543: ARRAY
7544: PUSH
7545: LD_INT 2
7547: ARRAY
7548: ARRAY
7549: PPUSH
7550: CALL_OW 308
7554: NOT
7555: IFFALSE 7671
// begin if GetFuel ( riv [ i ] [ 1 ] ) < 50 then
7557: LD_EXP 9
7561: PUSH
7562: LD_VAR 0 1
7566: ARRAY
7567: PUSH
7568: LD_INT 1
7570: ARRAY
7571: PPUSH
7572: CALL_OW 261
7576: PUSH
7577: LD_INT 50
7579: LESS
7580: IFFALSE 7604
// SetFuel ( riv [ i ] [ 1 ] , 67 ) ;
7582: LD_EXP 9
7586: PUSH
7587: LD_VAR 0 1
7591: ARRAY
7592: PUSH
7593: LD_INT 1
7595: ARRAY
7596: PPUSH
7597: LD_INT 67
7599: PPUSH
7600: CALL_OW 240
// ComMoveToArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) ;
7604: LD_EXP 9
7608: PUSH
7609: LD_VAR 0 1
7613: ARRAY
7614: PUSH
7615: LD_INT 1
7617: ARRAY
7618: PPUSH
7619: LD_INT 14
7621: PUSH
7622: LD_INT 15
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: PUSH
7629: LD_EXP 9
7633: PUSH
7634: LD_VAR 0 1
7638: ARRAY
7639: PUSH
7640: LD_INT 2
7642: ARRAY
7643: ARRAY
7644: PPUSH
7645: CALL_OW 113
// AddComWait ( riv [ i ] [ 1 ] , 0 0$10 ) ;
7649: LD_EXP 9
7653: PUSH
7654: LD_VAR 0 1
7658: ARRAY
7659: PUSH
7660: LD_INT 1
7662: ARRAY
7663: PPUSH
7664: LD_INT 350
7666: PPUSH
7667: CALL_OW 202
// end ; end ;
7671: GO 7381
7673: POP
7674: POP
// end ;
7675: PPOPN 2
7677: END
// every 10 10$00 trigger convoy_start do var i , un ;
7678: LD_EXP 7
7682: IFFALSE 7803
7684: GO 7686
7686: DISABLE
7687: LD_INT 0
7689: PPUSH
7690: PPUSH
// begin enable ;
7691: ENABLE
// for i = 1 to 2 do
7692: LD_ADDR_VAR 0 1
7696: PUSH
7697: DOUBLE
7698: LD_INT 1
7700: DEC
7701: ST_TO_ADDR
7702: LD_INT 2
7704: PUSH
7705: FOR_TO
7706: IFFALSE 7801
// begin uc_side := 2 ;
7708: LD_ADDR_OWVAR 20
7712: PUSH
7713: LD_INT 2
7715: ST_TO_ADDR
// uc_nation := 2 ;
7716: LD_ADDR_OWVAR 21
7720: PUSH
7721: LD_INT 2
7723: ST_TO_ADDR
// PrepareHuman ( false , 1 , 4 ) ;
7724: LD_INT 0
7726: PPUSH
7727: LD_INT 1
7729: PPUSH
7730: LD_INT 4
7732: PPUSH
7733: CALL_OW 380
// un := CreateHuman ;
7737: LD_ADDR_VAR 0 2
7741: PUSH
7742: CALL_OW 44
7746: ST_TO_ADDR
// PlaceUnitXY ( un , 10 , 2 , false ) ;
7747: LD_VAR 0 2
7751: PPUSH
7752: LD_INT 10
7754: PPUSH
7755: LD_INT 2
7757: PPUSH
7758: LD_INT 0
7760: PPUSH
7761: CALL_OW 48
// ComMoveXY ( un , 24 , 36 ) ;
7765: LD_VAR 0 2
7769: PPUSH
7770: LD_INT 24
7772: PPUSH
7773: LD_INT 36
7775: PPUSH
7776: CALL_OW 111
// AddComMoveToArea ( un , conv_end ) ;
7780: LD_VAR 0 2
7784: PPUSH
7785: LD_INT 9
7787: PPUSH
7788: CALL_OW 173
// Wait ( 0 0$02 ) ;
7792: LD_INT 70
7794: PPUSH
7795: CALL_OW 67
// end ;
7799: GO 7705
7801: POP
7802: POP
// end ;
7803: PPOPN 2
7805: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , rest ;
7806: LD_INT 22
7808: PUSH
7809: LD_INT 2
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PPUSH
7816: CALL_OW 69
7820: IFFALSE 8131
7822: GO 7824
7824: DISABLE
7825: LD_INT 0
7827: PPUSH
7828: PPUSH
// begin enable ;
7829: ENABLE
// rest := FilterAllUnits ( [ f_side , 2 ] ) diff ar_force ;
7830: LD_ADDR_VAR 0 2
7834: PUSH
7835: LD_INT 22
7837: PUSH
7838: LD_INT 2
7840: PUSH
7841: EMPTY
7842: LIST
7843: LIST
7844: PPUSH
7845: CALL_OW 69
7849: PUSH
7850: LD_EXP 11
7854: DIFF
7855: ST_TO_ADDR
// if rest then
7856: LD_VAR 0 2
7860: IFFALSE 7932
// for i in rest do
7862: LD_ADDR_VAR 0 1
7866: PUSH
7867: LD_VAR 0 2
7871: PUSH
7872: FOR_IN
7873: IFFALSE 7930
// if GetClass ( i ) = 3 then
7875: LD_VAR 0 1
7879: PPUSH
7880: CALL_OW 257
7884: PUSH
7885: LD_INT 3
7887: EQUAL
7888: IFFALSE 7928
// begin if not IsInArea ( i , ar2 ) then
7890: LD_VAR 0 1
7894: PPUSH
7895: LD_INT 17
7897: PPUSH
7898: CALL_OW 308
7902: NOT
7903: IFFALSE 7919
// ComMoveToArea ( i , ar2 ) else
7905: LD_VAR 0 1
7909: PPUSH
7910: LD_INT 17
7912: PPUSH
7913: CALL_OW 113
7917: GO 7928
// RemoveUnit ( i ) ;
7919: LD_VAR 0 1
7923: PPUSH
7924: CALL_OW 64
// end ;
7928: GO 7872
7930: POP
7931: POP
// if ar_force then
7932: LD_EXP 11
7936: IFFALSE 8131
// for i in ar_force do
7938: LD_ADDR_VAR 0 1
7942: PUSH
7943: LD_EXP 11
7947: PUSH
7948: FOR_IN
7949: IFFALSE 8129
// begin if GetClass ( i ) = class_soldier then
7951: LD_VAR 0 1
7955: PPUSH
7956: CALL_OW 257
7960: PUSH
7961: LD_INT 1
7963: EQUAL
7964: IFFALSE 8056
// if FindTarget ( i ) in FilterAllUnits ( [ f_type , unit_building ] ) then
7966: LD_VAR 0 1
7970: PPUSH
7971: CALL 10346 0 1
7975: PUSH
7976: LD_INT 21
7978: PUSH
7979: LD_INT 3
7981: PUSH
7982: EMPTY
7983: LIST
7984: LIST
7985: PPUSH
7986: CALL_OW 69
7990: IN
7991: IFFALSE 8037
// ComPlaceDelayedCharge ( i , GetX ( FindTarget ( i ) ) , GetY ( FindTarget ( i ) ) , 0 ) else
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_VAR 0 1
8002: PPUSH
8003: CALL 10346 0 1
8007: PPUSH
8008: CALL_OW 250
8012: PPUSH
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL 10346 0 1
8022: PPUSH
8023: CALL_OW 251
8027: PPUSH
8028: LD_INT 0
8030: PPUSH
8031: CALL_OW 132
8035: GO 8056
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8037: LD_VAR 0 1
8041: PPUSH
8042: LD_VAR 0 1
8046: PPUSH
8047: CALL 10346 0 1
8051: PPUSH
8052: CALL_OW 115
// if not GetClass ( i ) = 1 then
8056: LD_VAR 0 1
8060: PPUSH
8061: CALL_OW 257
8065: PUSH
8066: LD_INT 1
8068: EQUAL
8069: NOT
8070: IFFALSE 8091
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8072: LD_VAR 0 1
8076: PPUSH
8077: LD_VAR 0 1
8081: PPUSH
8082: CALL 10346 0 1
8086: PPUSH
8087: CALL_OW 115
// if GetDistUnitXY ( i , 65 , 118 ) < 40 then
8091: LD_VAR 0 1
8095: PPUSH
8096: LD_INT 65
8098: PPUSH
8099: LD_INT 118
8101: PPUSH
8102: CALL_OW 297
8106: PUSH
8107: LD_INT 40
8109: LESS
8110: IFFALSE 8127
// ComMoveXY ( i , 65 , 118 ) ;
8112: LD_VAR 0 1
8116: PPUSH
8117: LD_INT 65
8119: PPUSH
8120: LD_INT 118
8122: PPUSH
8123: CALL_OW 111
// end ;
8127: GO 7948
8129: POP
8130: POP
// end ;
8131: PPOPN 2
8133: END
// every 0 0$01 trigger FilterUnitsInArea ( conv_end , [ f_side , 2 ] ) do
8134: LD_INT 9
8136: PPUSH
8137: LD_INT 22
8139: PUSH
8140: LD_INT 2
8142: PUSH
8143: EMPTY
8144: LIST
8145: LIST
8146: PPUSH
8147: CALL_OW 70
8151: IFFALSE 8164
8153: GO 8155
8155: DISABLE
// medal2 := false ; end_of_file
8156: LD_ADDR_EXP 4
8160: PUSH
8161: LD_INT 0
8163: ST_TO_ADDR
8164: END
// export function Action ; begin
8165: LD_INT 0
8167: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
8168: LD_ADDR_OWVAR 67
8172: PUSH
8173: LD_INT 0
8175: PPUSH
8176: CALL_OW 426
8180: ST_TO_ADDR
// case Query ( info ) of 1 :
8181: LD_STRING info
8183: PPUSH
8184: CALL_OW 97
8188: PUSH
8189: LD_INT 1
8191: DOUBLE
8192: EQUAL
8193: IFTRUE 8197
8195: GO 8200
8197: POP
// ; end ;
8198: GO 8201
8200: POP
// SaveForQuickRestart ;
8201: CALL_OW 22
// ChangeMissionObjectives ( PM_1 ) ;
8205: LD_STRING PM_1
8207: PPUSH
8208: CALL_OW 337
// end ;
8212: LD_VAR 0 1
8216: RET
// every 0 0$01 trigger GetSide ( us_depot ) = 3 do
8217: LD_INT 50
8219: PPUSH
8220: CALL_OW 255
8224: PUSH
8225: LD_INT 3
8227: EQUAL
8228: IFFALSE 8509
8230: GO 8232
8232: DISABLE
// begin Say ( Stolypin , DPM_S1 ) ;
8233: LD_EXP 15
8237: PPUSH
8238: LD_STRING DPM_S1
8240: PPUSH
8241: CALL_OW 88
// SayRadio ( Popov , DPM_P1 ) ;
8245: LD_EXP 16
8249: PPUSH
8250: LD_STRING DPM_P1
8252: PPUSH
8253: CALL_OW 94
// Say ( Stolypin , DPM_S2 ) ;
8257: LD_EXP 15
8261: PPUSH
8262: LD_STRING DPM_S2
8264: PPUSH
8265: CALL_OW 88
// SaveForQuickRestart ;
8269: CALL_OW 22
// ChangeMissionObjectives ( PM_2 ) ;
8273: LD_STRING PM_2
8275: PPUSH
8276: CALL_OW 337
// Wait ( 2 2$30 ) ;
8280: LD_INT 5250
8282: PPUSH
8283: CALL_OW 67
// CenterOnXY ( 117 , 4 ) ;
8287: LD_INT 117
8289: PPUSH
8290: LD_INT 4
8292: PPUSH
8293: CALL_OW 84
// Convoy ( 1 ) ;
8297: LD_INT 1
8299: PPUSH
8300: CALL 883 0 1
// Wait ( 0 0$30 ) ;
8304: LD_INT 1050
8306: PPUSH
8307: CALL_OW 67
// Convoy ( 2 ) ;
8311: LD_INT 2
8313: PPUSH
8314: CALL 883 0 1
// Wait ( 1 1$30 ) ;
8318: LD_INT 3150
8320: PPUSH
8321: CALL_OW 67
// Convoy ( 3 ) ;
8325: LD_INT 3
8327: PPUSH
8328: CALL 883 0 1
// Wait ( 5 5$00 ) ;
8332: LD_INT 10500
8334: PPUSH
8335: CALL_OW 67
// convoy_start := true ;
8339: LD_ADDR_EXP 7
8343: PUSH
8344: LD_INT 1
8346: ST_TO_ADDR
// PrepareArabian ;
8347: CALL 6203 0 0
// PrepareAttack ( 1 ) ;
8351: LD_INT 1
8353: PPUSH
8354: CALL 6276 0 1
// while ( convoy_start ) do
8358: LD_EXP 7
8362: IFFALSE 8509
// begin Wait ( Rand ( 2 2$00 , 4 4$00 ) ) ;
8364: LD_INT 4200
8366: PPUSH
8367: LD_INT 8400
8369: PPUSH
8370: CALL_OW 12
8374: PPUSH
8375: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) < 20 then
8379: LD_INT 22
8381: PUSH
8382: LD_INT 2
8384: PUSH
8385: EMPTY
8386: LIST
8387: LIST
8388: PPUSH
8389: CALL_OW 69
8393: PUSH
8394: LD_INT 20
8396: LESS
8397: IFFALSE 8414
// PrepareAttack ( Rand ( 1 , 2 ) ) ;
8399: LD_INT 1
8401: PPUSH
8402: LD_INT 2
8404: PPUSH
8405: CALL_OW 12
8409: PPUSH
8410: CALL 6276 0 1
// Convoy ( Rand ( 1 , 5 ) ) ;
8414: LD_INT 1
8416: PPUSH
8417: LD_INT 5
8419: PPUSH
8420: CALL_OW 12
8424: PPUSH
8425: CALL 883 0 1
// conv_counter := conv_counter + 1 ;
8429: LD_ADDR_EXP 13
8433: PUSH
8434: LD_EXP 13
8438: PUSH
8439: LD_INT 1
8441: PLUS
8442: ST_TO_ADDR
// if conv_counter mod [ 5 , 4 , 3 ] [ Difficulty ] = 0 then
8443: LD_EXP 13
8447: PUSH
8448: LD_INT 5
8450: PUSH
8451: LD_INT 4
8453: PUSH
8454: LD_INT 3
8456: PUSH
8457: EMPTY
8458: LIST
8459: LIST
8460: LIST
8461: PUSH
8462: LD_OWVAR 67
8466: ARRAY
8467: MOD
8468: PUSH
8469: LD_INT 0
8471: EQUAL
8472: IFFALSE 8507
// begin Wait ( 1 1$20 ) ;
8474: LD_INT 2800
8476: PPUSH
8477: CALL_OW 67
// SayRadio ( Farmer , DPM_F2 ) ;
8481: LD_EXP 24
8485: PPUSH
8486: LD_STRING DPM_F2
8488: PPUSH
8489: CALL_OW 94
// PrepareAttack ( 3 ) ;
8493: LD_INT 3
8495: PPUSH
8496: CALL 6276 0 1
// Wait ( 4 4$00 ) ;
8500: LD_INT 8400
8502: PPUSH
8503: CALL_OW 67
// end ; end ;
8507: GO 8358
// end ;
8509: END
// every 1 1$30 trigger conv_counter mod 3 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8510: LD_EXP 13
8514: PUSH
8515: LD_INT 3
8517: MOD
8518: PUSH
8519: LD_INT 0
8521: EQUAL
8522: PUSH
8523: LD_INT 22
8525: PUSH
8526: LD_INT 2
8528: PUSH
8529: EMPTY
8530: LIST
8531: LIST
8532: PPUSH
8533: CALL_OW 69
8537: PUSH
8538: LD_INT 0
8540: EQUAL
8541: AND
8542: IFFALSE 8559
8544: GO 8546
8546: DISABLE
// SayRadio ( Farmer , DPM_F3 ) ;
8547: LD_EXP 24
8551: PPUSH
8552: LD_STRING DPM_F3
8554: PPUSH
8555: CALL_OW 94
8559: END
// every 1 1$30 trigger conv_counter mod 5 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8560: LD_EXP 13
8564: PUSH
8565: LD_INT 5
8567: MOD
8568: PUSH
8569: LD_INT 0
8571: EQUAL
8572: PUSH
8573: LD_INT 22
8575: PUSH
8576: LD_INT 2
8578: PUSH
8579: EMPTY
8580: LIST
8581: LIST
8582: PPUSH
8583: CALL_OW 69
8587: PUSH
8588: LD_INT 0
8590: EQUAL
8591: AND
8592: IFFALSE 8609
8594: GO 8596
8596: DISABLE
// SayRadio ( Farmer , DPM_F4 ) ;
8597: LD_EXP 24
8601: PPUSH
8602: LD_STRING DPM_F4
8604: PPUSH
8605: CALL_OW 94
8609: END
// every 0 0$10 trigger conv_counter >= 8 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
8610: LD_EXP 13
8614: PUSH
8615: LD_INT 8
8617: GREATEREQUAL
8618: PUSH
8619: LD_INT 22
8621: PUSH
8622: LD_INT 6
8624: PUSH
8625: EMPTY
8626: LIST
8627: LIST
8628: PPUSH
8629: CALL_OW 69
8633: PUSH
8634: LD_INT 0
8636: EQUAL
8637: AND
8638: IFFALSE 8737
8640: GO 8642
8642: DISABLE
// begin SayRadio ( Popov , DPM_PEnd ) ;
8643: LD_EXP 16
8647: PPUSH
8648: LD_STRING DPM_PEnd
8650: PPUSH
8651: CALL_OW 94
// AddMedal ( med1 , medal1 ) ;
8655: LD_STRING med1
8657: PPUSH
8658: LD_EXP 3
8662: PPUSH
8663: CALL_OW 101
// AddMedal ( med2 , medal2 ) ;
8667: LD_STRING med2
8669: PPUSH
8670: LD_EXP 4
8674: PPUSH
8675: CALL_OW 101
// if dest_counter >= [ 15 , 10 , 7 ] [ Difficulty ] then
8679: LD_EXP 8
8683: PUSH
8684: LD_INT 15
8686: PUSH
8687: LD_INT 10
8689: PUSH
8690: LD_INT 7
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: LIST
8697: PUSH
8698: LD_OWVAR 67
8702: ARRAY
8703: GREATEREQUAL
8704: IFFALSE 8714
// medal3 := false ;
8706: LD_ADDR_EXP 5
8710: PUSH
8711: LD_INT 0
8713: ST_TO_ADDR
// AddMedal ( med3 , medal3 ) ;
8714: LD_STRING med3
8716: PPUSH
8717: LD_EXP 5
8721: PPUSH
8722: CALL_OW 101
// GiveMedals ( MAIN ) ;
8726: LD_STRING MAIN
8728: PPUSH
8729: CALL_OW 102
// YouWin ;
8733: CALL_OW 103
// end ;
8737: END
// every 4 4$00 trigger convoy_start do var i ;
8738: LD_EXP 7
8742: IFFALSE 9100
8744: GO 8746
8746: DISABLE
8747: LD_INT 0
8749: PPUSH
// begin SayRadio ( Popov , DPM_PHelp ) ;
8750: LD_EXP 16
8754: PPUSH
8755: LD_STRING DPM_PHelp
8757: PPUSH
8758: CALL_OW 94
// Wait ( 0 0$30 ) ;
8762: LD_INT 1050
8764: PPUSH
8765: CALL_OW 67
// Randomize ;
8769: CALL_OW 10
// uc_side := 3 ;
8773: LD_ADDR_OWVAR 20
8777: PUSH
8778: LD_INT 3
8780: ST_TO_ADDR
// uc_nation := 3 ;
8781: LD_ADDR_OWVAR 21
8785: PUSH
8786: LD_INT 3
8788: ST_TO_ADDR
// for i = 1 to [ 5 , 4 , 3 ] [ Difficulty ] do
8789: LD_ADDR_VAR 0 1
8793: PUSH
8794: DOUBLE
8795: LD_INT 1
8797: DEC
8798: ST_TO_ADDR
8799: LD_INT 5
8801: PUSH
8802: LD_INT 4
8804: PUSH
8805: LD_INT 3
8807: PUSH
8808: EMPTY
8809: LIST
8810: LIST
8811: LIST
8812: PUSH
8813: LD_OWVAR 67
8817: ARRAY
8818: PUSH
8819: FOR_TO
8820: IFFALSE 8860
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , 5 ) ;
8822: LD_INT 0
8824: PPUSH
8825: LD_INT 1
8827: PPUSH
8828: LD_INT 3
8830: PPUSH
8831: CALL_OW 12
8835: PPUSH
8836: LD_INT 5
8838: PPUSH
8839: CALL_OW 380
// PlaceUnitArea ( CreateHuman , rus_start , false ) ;
8843: CALL_OW 44
8847: PPUSH
8848: LD_INT 1
8850: PPUSH
8851: LD_INT 0
8853: PPUSH
8854: CALL_OW 49
// end ;
8858: GO 8819
8860: POP
8861: POP
// vc_chassis := ru_heavy_wheeled ;
8862: LD_ADDR_OWVAR 37
8866: PUSH
8867: LD_INT 23
8869: ST_TO_ADDR
// vc_engine := engine_combustion ;
8870: LD_ADDR_OWVAR 39
8874: PUSH
8875: LD_INT 1
8877: ST_TO_ADDR
// vc_control := control_manual ;
8878: LD_ADDR_OWVAR 38
8882: PUSH
8883: LD_INT 1
8885: ST_TO_ADDR
// vc_weapon := 89 ;
8886: LD_ADDR_OWVAR 40
8890: PUSH
8891: LD_INT 89
8893: ST_TO_ADDR
// vc_fuel_battery := 88 ;
8894: LD_ADDR_OWVAR 41
8898: PUSH
8899: LD_INT 88
8901: ST_TO_ADDR
// i := CreateVehicle ;
8902: LD_ADDR_VAR 0 1
8906: PUSH
8907: CALL_OW 45
8911: ST_TO_ADDR
// SetDir ( i , 5 ) ;
8912: LD_VAR 0 1
8916: PPUSH
8917: LD_INT 5
8919: PPUSH
8920: CALL_OW 233
// PlaceUnitXY ( i , 63 , 115 , false ) ;
8924: LD_VAR 0 1
8928: PPUSH
8929: LD_INT 63
8931: PPUSH
8932: LD_INT 115
8934: PPUSH
8935: LD_INT 0
8937: PPUSH
8938: CALL_OW 48
// SetCargo ( i , mat_cans , 200 ) ;
8942: LD_VAR 0 1
8946: PPUSH
8947: LD_INT 1
8949: PPUSH
8950: LD_INT 200
8952: PPUSH
8953: CALL_OW 290
// PrepareHuman ( false , 3 , 5 ) ;
8957: LD_INT 0
8959: PPUSH
8960: LD_INT 3
8962: PPUSH
8963: LD_INT 5
8965: PPUSH
8966: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
8970: CALL_OW 44
8974: PPUSH
8975: LD_VAR 0 1
8979: PPUSH
8980: CALL_OW 52
// DialogueOn ;
8984: CALL_OW 6
// CenterNowOnXY ( 169 , 115 ) ;
8988: LD_INT 169
8990: PPUSH
8991: LD_INT 115
8993: PPUSH
8994: CALL_OW 86
// DWait ( 0 0$01 ) ;
8998: LD_INT 35
9000: PPUSH
9001: CALL_OW 68
// CenterNowOnXY ( 63 , 115 ) ;
9005: LD_INT 63
9007: PPUSH
9008: LD_INT 115
9010: PPUSH
9011: CALL_OW 86
// DWait ( 0 0$01 ) ;
9015: LD_INT 35
9017: PPUSH
9018: CALL_OW 68
// DialogueOff ;
9022: CALL_OW 7
// ComMoveXY ( i , 57 , 53 ) ;
9026: LD_VAR 0 1
9030: PPUSH
9031: LD_INT 57
9033: PPUSH
9034: LD_INT 53
9036: PPUSH
9037: CALL_OW 111
// Wait ( Rand ( 1 1$00 , 4 4$00 ) ) ;
9041: LD_INT 2100
9043: PPUSH
9044: LD_INT 8400
9046: PPUSH
9047: CALL_OW 12
9051: PPUSH
9052: CALL_OW 67
// PlaceUnitXY ( Saseda , 86 , 112 , false ) ;
9056: LD_EXP 17
9060: PPUSH
9061: LD_INT 86
9063: PPUSH
9064: LD_INT 112
9066: PPUSH
9067: LD_INT 0
9069: PPUSH
9070: CALL_OW 48
// Wait ( 0 0$0.3 ) ;
9074: LD_INT 10
9076: PPUSH
9077: CALL_OW 67
// SayRadio ( Saseda , DPM_Sa1 ) ;
9081: LD_EXP 17
9085: PPUSH
9086: LD_STRING DPM_Sa1
9088: PPUSH
9089: CALL_OW 94
// ChangeMissionObjectives ( PM_3 ) ;
9093: LD_STRING PM_3
9095: PPUSH
9096: CALL_OW 337
// end ;
9100: PPOPN 1
9102: END
// every 0 0$01 trigger See ( 3 , Saseda ) do
9103: LD_INT 3
9105: PPUSH
9106: LD_EXP 17
9110: PPUSH
9111: CALL_OW 292
9115: IFFALSE 9164
9117: GO 9119
9119: DISABLE
// begin Say ( Saseda , DPM_Sa2 ) ;
9120: LD_EXP 17
9124: PPUSH
9125: LD_STRING DPM_Sa2
9127: PPUSH
9128: CALL_OW 88
// ChangeMissionObjectives ( PM_4 ) ;
9132: LD_STRING PM_4
9134: PPUSH
9135: CALL_OW 337
// SetTech ( tech_rocket , 3 , state_enabled ) ;
9139: LD_INT 40
9141: PPUSH
9142: LD_INT 3
9144: PPUSH
9145: LD_INT 1
9147: PPUSH
9148: CALL_OW 322
// SetSide ( Saseda , 3 ) ;
9152: LD_EXP 17
9156: PPUSH
9157: LD_INT 3
9159: PPUSH
9160: CALL_OW 235
// end ;
9164: END
// every 16 16$00 trigger not medal1 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
9165: LD_EXP 3
9169: NOT
9170: PUSH
9171: LD_INT 22
9173: PUSH
9174: LD_INT 6
9176: PUSH
9177: EMPTY
9178: LIST
9179: LIST
9180: PPUSH
9181: CALL_OW 69
9185: PUSH
9186: LD_INT 0
9188: EQUAL
9189: AND
9190: IFFALSE 9250
9192: GO 9194
9194: DISABLE
// begin Say ( Stolypin , DPM_S3 ) ;
9195: LD_EXP 15
9199: PPUSH
9200: LD_STRING DPM_S3
9202: PPUSH
9203: CALL_OW 88
// PlaceSeeing ( 62 , 113 , 3 , 10 ) ;
9207: LD_INT 62
9209: PPUSH
9210: LD_INT 113
9212: PPUSH
9213: LD_INT 3
9215: PPUSH
9216: LD_INT 10
9218: PPUSH
9219: CALL_OW 330
// CenterOnXY ( 62 , 113 ) ;
9223: LD_INT 62
9225: PPUSH
9226: LD_INT 113
9228: PPUSH
9229: CALL_OW 84
// CounterAttack ;
9233: CALL 5702 0 0
// RemoveSeeing ( 62 , 113 , 3 ) ;
9237: LD_INT 62
9239: PPUSH
9240: LD_INT 113
9242: PPUSH
9243: LD_INT 3
9245: PPUSH
9246: CALL_OW 331
// end ; end_of_file
9250: END
// on LeaveBuilding ( b , h ) do begin if GetSide ( b ) = 1 then
9251: LD_VAR 0 1
9255: PPUSH
9256: CALL_OW 255
9260: PUSH
9261: LD_INT 1
9263: EQUAL
9264: IFFALSE 9300
// if not us_retreat then
9266: LD_EXP 21
9270: NOT
9271: IFFALSE 9300
// if GetClass ( h ) = 1 then
9273: LD_VAR 0 2
9277: PPUSH
9278: CALL_OW 257
9282: PUSH
9283: LD_INT 1
9285: EQUAL
9286: IFFALSE 9300
// ComEnterUnit ( h , us_arm ) ;
9288: LD_VAR 0 2
9292: PPUSH
9293: LD_INT 69
9295: PPUSH
9296: CALL_OW 120
// end ;
9300: PPOPN 2
9302: END
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = 1 then
9303: LD_VAR 0 1
9307: PPUSH
9308: CALL_OW 255
9312: PUSH
9313: LD_INT 1
9315: EQUAL
9316: IFFALSE 9332
// us_count := us_count + 1 ;
9318: LD_ADDR_EXP 23
9322: PUSH
9323: LD_EXP 23
9327: PUSH
9328: LD_INT 1
9330: PLUS
9331: ST_TO_ADDR
// if un in us_force then
9332: LD_VAR 0 1
9336: PUSH
9337: LD_EXP 12
9341: IN
9342: IFFALSE 9360
// us_force := us_force diff un ;
9344: LD_ADDR_EXP 12
9348: PUSH
9349: LD_EXP 12
9353: PUSH
9354: LD_VAR 0 1
9358: DIFF
9359: ST_TO_ADDR
// if un in ar_force then
9360: LD_VAR 0 1
9364: PUSH
9365: LD_EXP 11
9369: IN
9370: IFFALSE 9388
// ar_force := ar_force diff un ;
9372: LD_ADDR_EXP 11
9376: PUSH
9377: LD_EXP 11
9381: PUSH
9382: LD_VAR 0 1
9386: DIFF
9387: ST_TO_ADDR
// if un = Stolypin then
9388: LD_VAR 0 1
9392: PUSH
9393: LD_EXP 15
9397: EQUAL
9398: IFFALSE 9407
// YouLost ( dead ) ;
9400: LD_STRING dead
9402: PPUSH
9403: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) then
9407: LD_VAR 0 1
9411: PUSH
9412: LD_INT 22
9414: PUSH
9415: LD_INT 1
9417: PUSH
9418: EMPTY
9419: LIST
9420: LIST
9421: PUSH
9422: LD_INT 30
9424: PUSH
9425: LD_INT 0
9427: PUSH
9428: EMPTY
9429: LIST
9430: LIST
9431: PUSH
9432: EMPTY
9433: LIST
9434: LIST
9435: PPUSH
9436: CALL_OW 69
9440: IN
9441: IFFALSE 9450
// YouLost ( depot ) ;
9443: LD_STRING depot
9445: PPUSH
9446: CALL_OW 104
// if GetSide ( un ) = 6 then
9450: LD_VAR 0 1
9454: PPUSH
9455: CALL_OW 255
9459: PUSH
9460: LD_INT 6
9462: EQUAL
9463: IFFALSE 9479
// dest_counter := dest_counter + 1 ;
9465: LD_ADDR_EXP 8
9469: PUSH
9470: LD_EXP 8
9474: PUSH
9475: LD_INT 1
9477: PLUS
9478: ST_TO_ADDR
// end ;
9479: PPOPN 1
9481: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 1 then
9482: LD_VAR 0 1
9486: PPUSH
9487: CALL_OW 255
9491: PUSH
9492: LD_INT 1
9494: EQUAL
9495: IFFALSE 9512
// ComMoveXY ( un , 57 , 52 ) ;
9497: LD_VAR 0 1
9501: PPUSH
9502: LD_INT 57
9504: PPUSH
9505: LD_INT 52
9507: PPUSH
9508: CALL_OW 111
// end ;
9512: PPOPN 2
9514: END
// on Contact ( s1 , s2 ) do begin if not us_alert then
9515: LD_EXP 20
9519: NOT
9520: IFFALSE 9570
// if ( s1 = 3 and s2 = 1 ) or ( s1 = 1 and s2 = 3 ) then
9522: LD_VAR 0 1
9526: PUSH
9527: LD_INT 3
9529: EQUAL
9530: PUSH
9531: LD_VAR 0 2
9535: PUSH
9536: LD_INT 1
9538: EQUAL
9539: AND
9540: PUSH
9541: LD_VAR 0 1
9545: PUSH
9546: LD_INT 1
9548: EQUAL
9549: PUSH
9550: LD_VAR 0 2
9554: PUSH
9555: LD_INT 3
9557: EQUAL
9558: AND
9559: OR
9560: IFFALSE 9570
// us_alert := true ;
9562: LD_ADDR_EXP 20
9566: PUSH
9567: LD_INT 1
9569: ST_TO_ADDR
// if ( s1 = 6 and s2 = 3 ) or ( s1 = 3 and s2 = 6 ) then
9570: LD_VAR 0 1
9574: PUSH
9575: LD_INT 6
9577: EQUAL
9578: PUSH
9579: LD_VAR 0 2
9583: PUSH
9584: LD_INT 3
9586: EQUAL
9587: AND
9588: PUSH
9589: LD_VAR 0 1
9593: PUSH
9594: LD_INT 3
9596: EQUAL
9597: PUSH
9598: LD_VAR 0 2
9602: PUSH
9603: LD_INT 6
9605: EQUAL
9606: AND
9607: OR
9608: IFFALSE 9617
// YouLost ( alat ) ;
9610: LD_STRING alat
9612: PPUSH
9613: CALL_OW 104
// end ;
9617: PPOPN 2
9619: END
// on DestinationUnreachable ( un ) do begin if GetSide ( un ) = 6 then
9620: LD_VAR 0 1
9624: PPUSH
9625: CALL_OW 255
9629: PUSH
9630: LD_INT 6
9632: EQUAL
9633: IFFALSE 9649
// display_strings := display_strings union Convoy is blocked! ;
9635: LD_ADDR_OWVAR 47
9639: PUSH
9640: LD_OWVAR 47
9644: PUSH
9645: LD_STRING Convoy is blocked!
9647: UNION
9648: ST_TO_ADDR
// end ;
9649: PPOPN 1
9651: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = 2 and un in FilterAllUnits ( [ [ f_empty ] , [ f_type , unit_vehicle ] ] ) then
9652: LD_VAR 0 1
9656: PPUSH
9657: CALL_OW 255
9661: PUSH
9662: LD_INT 2
9664: EQUAL
9665: PUSH
9666: LD_VAR 0 1
9670: PUSH
9671: LD_INT 58
9673: PUSH
9674: EMPTY
9675: LIST
9676: PUSH
9677: LD_INT 21
9679: PUSH
9680: LD_INT 2
9682: PUSH
9683: EMPTY
9684: LIST
9685: LIST
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PPUSH
9691: CALL_OW 69
9695: IN
9696: AND
9697: IFFALSE 9818
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> 2 then
9699: LD_OWVAR 3
9703: PUSH
9704: LD_VAR 0 1
9708: DIFF
9709: PPUSH
9710: LD_VAR 0 1
9714: PPUSH
9715: CALL_OW 74
9719: PPUSH
9720: CALL_OW 255
9724: PUSH
9725: LD_INT 2
9727: NONEQUAL
9728: IFFALSE 9818
// begin Wait ( 0 0$1.3 ) ;
9730: LD_INT 46
9732: PPUSH
9733: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9737: LD_VAR 0 1
9741: PPUSH
9742: CALL_OW 250
9746: PPUSH
9747: LD_VAR 0 1
9751: PPUSH
9752: CALL_OW 251
9756: PPUSH
9757: LD_INT 1
9759: PPUSH
9760: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9764: LD_VAR 0 1
9768: PPUSH
9769: CALL_OW 250
9773: PPUSH
9774: LD_VAR 0 1
9778: PPUSH
9779: CALL_OW 251
9783: PPUSH
9784: LD_INT 1
9786: PPUSH
9787: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9791: LD_VAR 0 1
9795: PPUSH
9796: CALL_OW 250
9800: PPUSH
9801: LD_VAR 0 1
9805: PPUSH
9806: CALL_OW 251
9810: PPUSH
9811: LD_INT 1
9813: PPUSH
9814: CALL_OW 453
// end ; end ;
9818: PPOPN 1
9820: END
// on EvacuateVehicle ( driver , un , c1 , c2 ) do begin if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) and not GetSide ( NearestUnit ( un ) ) = 2 then
9821: LD_VAR 0 2
9825: PUSH
9826: LD_INT 22
9828: PUSH
9829: LD_INT 2
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: PUSH
9836: LD_INT 21
9838: PUSH
9839: LD_INT 2
9841: PUSH
9842: EMPTY
9843: LIST
9844: LIST
9845: PUSH
9846: EMPTY
9847: LIST
9848: LIST
9849: PPUSH
9850: CALL_OW 69
9854: IN
9855: PUSH
9856: LD_VAR 0 2
9860: PPUSH
9861: CALL 10391 0 1
9865: PPUSH
9866: CALL_OW 255
9870: PUSH
9871: LD_INT 2
9873: EQUAL
9874: NOT
9875: AND
9876: IFFALSE 10001
// begin Wait ( Rand ( 0 0$03 , 0 0$06 ) ) ;
9878: LD_INT 105
9880: PPUSH
9881: LD_INT 210
9883: PPUSH
9884: CALL_OW 12
9888: PPUSH
9889: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9893: LD_VAR 0 2
9897: PPUSH
9898: CALL_OW 250
9902: PPUSH
9903: LD_VAR 0 2
9907: PPUSH
9908: CALL_OW 251
9912: PPUSH
9913: LD_INT 3
9915: PPUSH
9916: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9920: LD_VAR 0 2
9924: PPUSH
9925: CALL_OW 250
9929: PPUSH
9930: LD_VAR 0 2
9934: PPUSH
9935: CALL_OW 251
9939: PPUSH
9940: LD_INT 3
9942: PPUSH
9943: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9947: LD_VAR 0 2
9951: PPUSH
9952: CALL_OW 250
9956: PPUSH
9957: LD_VAR 0 2
9961: PPUSH
9962: CALL_OW 251
9966: PPUSH
9967: LD_INT 3
9969: PPUSH
9970: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9974: LD_VAR 0 2
9978: PPUSH
9979: CALL_OW 250
9983: PPUSH
9984: LD_VAR 0 2
9988: PPUSH
9989: CALL_OW 251
9993: PPUSH
9994: LD_INT 3
9996: PPUSH
9997: CALL_OW 453
// end ; end ;
10001: PPOPN 4
10003: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
10004: LD_VAR 0 1
10008: PPUSH
10009: LD_VAR 0 2
10013: PPUSH
10014: LD_VAR 0 3
10018: PPUSH
10019: CALL 10911 0 3
// end ;
10023: PPOPN 3
10025: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10026: LD_VAR 0 1
10030: PPUSH
10031: CALL 11009 0 1
// end ; end_of_file
10035: PPOPN 1
10037: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
10038: LD_INT 0
10040: PPUSH
10041: PPUSH
10042: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
10043: LD_ADDR_VAR 0 7
10047: PUSH
10048: LD_VAR 0 1
10052: PUSH
10053: LD_VAR 0 2
10057: ARRAY
10058: PPUSH
10059: LD_VAR 0 3
10063: PPUSH
10064: LD_VAR 0 4
10068: PPUSH
10069: CALL_OW 1
10073: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
10074: LD_ADDR_VAR 0 1
10078: PUSH
10079: LD_VAR 0 1
10083: PPUSH
10084: LD_VAR 0 2
10088: PPUSH
10089: LD_VAR 0 7
10093: PPUSH
10094: CALL_OW 1
10098: ST_TO_ADDR
// result := tab ;
10099: LD_ADDR_VAR 0 5
10103: PUSH
10104: LD_VAR 0 1
10108: ST_TO_ADDR
// end ;
10109: LD_VAR 0 5
10113: RET
// export function IsDriver ( unit ) ; begin
10114: LD_INT 0
10116: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
10117: LD_VAR 0 1
10121: PUSH
10122: LD_INT 55
10124: PUSH
10125: EMPTY
10126: LIST
10127: PPUSH
10128: CALL_OW 69
10132: IN
10133: IFFALSE 10152
// result := IsInUnit ( unit ) else
10135: LD_ADDR_VAR 0 2
10139: PUSH
10140: LD_VAR 0 1
10144: PPUSH
10145: CALL_OW 310
10149: ST_TO_ADDR
10150: GO 10160
// result := false ;
10152: LD_ADDR_VAR 0 2
10156: PUSH
10157: LD_INT 0
10159: ST_TO_ADDR
// end ;
10160: LD_VAR 0 2
10164: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
10165: LD_INT 0
10167: PPUSH
10168: PPUSH
10169: PPUSH
// if not GetControl ( veh ) = control_manual then
10170: LD_VAR 0 1
10174: PPUSH
10175: CALL_OW 263
10179: PUSH
10180: LD_INT 1
10182: EQUAL
10183: NOT
10184: IFFALSE 10196
// result := false else
10186: LD_ADDR_VAR 0 2
10190: PUSH
10191: LD_INT 0
10193: ST_TO_ADDR
10194: GO 10341
// if veh in FilterAllUnits ( [ f_empty ] ) then
10196: LD_VAR 0 1
10200: PUSH
10201: LD_INT 58
10203: PUSH
10204: EMPTY
10205: LIST
10206: PPUSH
10207: CALL_OW 69
10211: IN
10212: IFFALSE 10224
// result := false else
10214: LD_ADDR_VAR 0 2
10218: PUSH
10219: LD_INT 0
10221: ST_TO_ADDR
10222: GO 10341
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
10224: LD_ADDR_VAR 0 4
10228: PUSH
10229: LD_INT 22
10231: PUSH
10232: LD_VAR 0 1
10236: PPUSH
10237: CALL_OW 255
10241: PUSH
10242: EMPTY
10243: LIST
10244: LIST
10245: PUSH
10246: LD_INT 55
10248: PUSH
10249: EMPTY
10250: LIST
10251: PUSH
10252: EMPTY
10253: LIST
10254: LIST
10255: PPUSH
10256: CALL_OW 69
10260: ST_TO_ADDR
// if not filter then
10261: LD_VAR 0 4
10265: NOT
10266: IFFALSE 10278
// result := false else
10268: LD_ADDR_VAR 0 2
10272: PUSH
10273: LD_INT 0
10275: ST_TO_ADDR
10276: GO 10341
// for i = 1 to filter do
10278: LD_ADDR_VAR 0 3
10282: PUSH
10283: DOUBLE
10284: LD_INT 1
10286: DEC
10287: ST_TO_ADDR
10288: LD_VAR 0 4
10292: PUSH
10293: FOR_TO
10294: IFFALSE 10339
// if IsDriver ( filter [ i ] ) = veh then
10296: LD_VAR 0 4
10300: PUSH
10301: LD_VAR 0 3
10305: ARRAY
10306: PPUSH
10307: CALL 10114 0 1
10311: PUSH
10312: LD_VAR 0 1
10316: EQUAL
10317: IFFALSE 10337
// begin result := filter [ i ] ;
10319: LD_ADDR_VAR 0 2
10323: PUSH
10324: LD_VAR 0 4
10328: PUSH
10329: LD_VAR 0 3
10333: ARRAY
10334: ST_TO_ADDR
// break ;
10335: GO 10339
// end ;
10337: GO 10293
10339: POP
10340: POP
// end ; end ;
10341: LD_VAR 0 2
10345: RET
// export function FindTarget ( unit ) ; begin
10346: LD_INT 0
10348: PPUSH
// result := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ;
10349: LD_ADDR_VAR 0 2
10353: PUSH
10354: LD_INT 81
10356: PUSH
10357: LD_VAR 0 1
10361: PPUSH
10362: CALL_OW 255
10366: PUSH
10367: EMPTY
10368: LIST
10369: LIST
10370: PPUSH
10371: CALL_OW 69
10375: PPUSH
10376: LD_VAR 0 1
10380: PPUSH
10381: CALL_OW 74
10385: ST_TO_ADDR
// end ;
10386: LD_VAR 0 2
10390: RET
// export function NearestUnit ( unit ) ; begin
10391: LD_INT 0
10393: PPUSH
// result := NearestUnitToUnit ( all_units diff unit , unit ) ;
10394: LD_ADDR_VAR 0 2
10398: PUSH
10399: LD_OWVAR 3
10403: PUSH
10404: LD_VAR 0 1
10408: DIFF
10409: PPUSH
10410: LD_VAR 0 1
10414: PPUSH
10415: CALL_OW 74
10419: ST_TO_ADDR
// end ; end_of_file
10420: LD_VAR 0 2
10424: RET
// every 12 12$00 do
10425: GO 10427
10427: DISABLE
// begin SetWeather ( 1 , 210 , 110 ) ;
10428: LD_INT 1
10430: PPUSH
10431: LD_INT 210
10433: PPUSH
10434: LD_INT 110
10436: PPUSH
10437: CALL_OW 550
// Wait ( Rand ( 5 5$00 , 10 10$00 ) ) ;
10441: LD_INT 10500
10443: PPUSH
10444: LD_INT 21000
10446: PPUSH
10447: CALL_OW 12
10451: PPUSH
10452: CALL_OW 67
// SetWeather ( 0 , 210 , 110 ) ;
10456: LD_INT 0
10458: PPUSH
10459: LD_INT 210
10461: PPUSH
10462: LD_INT 110
10464: PPUSH
10465: CALL_OW 550
// end ;
10469: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
10470: LD_INT 0
10472: PPUSH
10473: PPUSH
10474: PPUSH
10475: PPUSH
10476: PPUSH
// uc_nation = nation_nature ;
10477: LD_ADDR_OWVAR 21
10481: PUSH
10482: LD_INT 0
10484: ST_TO_ADDR
// uc_side = 0 ;
10485: LD_ADDR_OWVAR 20
10489: PUSH
10490: LD_INT 0
10492: ST_TO_ADDR
// l = 0 ;
10493: LD_ADDR_VAR 0 6
10497: PUSH
10498: LD_INT 0
10500: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
10501: LD_ADDR_OWVAR 24
10505: PUSH
10506: LD_INT 0
10508: PPUSH
10509: LD_INT 5
10511: PPUSH
10512: CALL_OW 12
10516: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
10517: LD_ADDR_OWVAR 35
10521: PUSH
10522: LD_INT 5
10524: NEG
10525: PPUSH
10526: LD_INT 5
10528: PPUSH
10529: CALL_OW 12
10533: ST_TO_ADDR
// hc_gallery =  ;
10534: LD_ADDR_OWVAR 33
10538: PUSH
10539: LD_STRING 
10541: ST_TO_ADDR
// hc_class = class_apeman ;
10542: LD_ADDR_OWVAR 28
10546: PUSH
10547: LD_INT 12
10549: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
10550: LD_ADDR_OWVAR 29
10554: PUSH
10555: LD_INT 11
10557: PPUSH
10558: LD_INT 13
10560: PPUSH
10561: CALL_OW 12
10565: PUSH
10566: LD_INT 10
10568: PPUSH
10569: LD_INT 11
10571: PPUSH
10572: CALL_OW 12
10576: PUSH
10577: EMPTY
10578: LIST
10579: LIST
10580: ST_TO_ADDR
// hc_sex = sex_male ;
10581: LD_ADDR_OWVAR 27
10585: PUSH
10586: LD_INT 1
10588: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
10589: LD_ADDR_OWVAR 31
10593: PUSH
10594: LD_INT 0
10596: PPUSH
10597: LD_INT 2
10599: PPUSH
10600: CALL_OW 12
10604: PUSH
10605: LD_INT 0
10607: PUSH
10608: LD_INT 0
10610: PUSH
10611: LD_INT 0
10613: PUSH
10614: EMPTY
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: ST_TO_ADDR
// apeman = CreateHuman ;
10620: LD_ADDR_VAR 0 7
10624: PUSH
10625: CALL_OW 44
10629: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
10630: LD_VAR 0 7
10634: PPUSH
10635: LD_VAR 0 4
10639: PPUSH
10640: LD_INT 0
10642: PPUSH
10643: CALL_OW 49
// l = l + 1 ;
10647: LD_ADDR_VAR 0 6
10651: PUSH
10652: LD_VAR 0 6
10656: PUSH
10657: LD_INT 1
10659: PLUS
10660: ST_TO_ADDR
// end until l = num1 ;
10661: LD_VAR 0 6
10665: PUSH
10666: LD_VAR 0 1
10670: EQUAL
10671: IFFALSE 10501
// l = 0 ;
10673: LD_ADDR_VAR 0 6
10677: PUSH
10678: LD_INT 0
10680: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
10681: LD_ADDR_OWVAR 35
10685: PUSH
10686: LD_INT 0
10688: PPUSH
10689: LD_INT 25
10691: PPUSH
10692: CALL_OW 12
10696: ST_TO_ADDR
// hc_class = class_tiger ;
10697: LD_ADDR_OWVAR 28
10701: PUSH
10702: LD_INT 14
10704: ST_TO_ADDR
// hc_sex = sex_male ;
10705: LD_ADDR_OWVAR 27
10709: PUSH
10710: LD_INT 1
10712: ST_TO_ADDR
// hc_gallery = sandnature ;
10713: LD_ADDR_OWVAR 33
10717: PUSH
10718: LD_STRING sandnature
10720: ST_TO_ADDR
// hc_face_number = 3 ;
10721: LD_ADDR_OWVAR 34
10725: PUSH
10726: LD_INT 3
10728: ST_TO_ADDR
// tiger = CreateHuman ;
10729: LD_ADDR_VAR 0 8
10733: PUSH
10734: CALL_OW 44
10738: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10739: LD_VAR 0 8
10743: PPUSH
10744: LD_VAR 0 4
10748: PPUSH
10749: LD_INT 0
10751: PPUSH
10752: CALL_OW 49
// l = l + 1 ;
10756: LD_ADDR_VAR 0 6
10760: PUSH
10761: LD_VAR 0 6
10765: PUSH
10766: LD_INT 1
10768: PLUS
10769: ST_TO_ADDR
// end until l = num2 ;
10770: LD_VAR 0 6
10774: PUSH
10775: LD_VAR 0 2
10779: EQUAL
10780: IFFALSE 10681
// l = 0 ;
10782: LD_ADDR_VAR 0 6
10786: PUSH
10787: LD_INT 0
10789: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
10790: LD_ADDR_OWVAR 28
10794: PUSH
10795: LD_INT 18
10797: ST_TO_ADDR
// hc_gallery = sandnature ;
10798: LD_ADDR_OWVAR 33
10802: PUSH
10803: LD_STRING sandnature
10805: ST_TO_ADDR
// hc_face_number = 1 ;
10806: LD_ADDR_OWVAR 34
10810: PUSH
10811: LD_INT 1
10813: ST_TO_ADDR
// bird = CreateHuman ;
10814: LD_ADDR_VAR 0 9
10818: PUSH
10819: CALL_OW 44
10823: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
10824: LD_VAR 0 9
10828: PPUSH
10829: LD_INT 0
10831: PPUSH
10832: CALL_OW 51
// l = l + 1 ;
10836: LD_ADDR_VAR 0 6
10840: PUSH
10841: LD_VAR 0 6
10845: PUSH
10846: LD_INT 1
10848: PLUS
10849: ST_TO_ADDR
// end until l = num3 ;
10850: LD_VAR 0 6
10854: PUSH
10855: LD_VAR 0 3
10859: EQUAL
10860: IFFALSE 10790
// end ; end_of_file
10862: LD_VAR 0 5
10866: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
10867: GO 10869
10869: DISABLE
// begin ru_radar := 98 ;
10870: LD_ADDR_EXP 25
10874: PUSH
10875: LD_INT 98
10877: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
10878: LD_ADDR_EXP 26
10882: PUSH
10883: LD_INT 89
10885: ST_TO_ADDR
// us_hack := 99 ;
10886: LD_ADDR_EXP 27
10890: PUSH
10891: LD_INT 99
10893: ST_TO_ADDR
// us_artillery := 97 ;
10894: LD_ADDR_EXP 28
10898: PUSH
10899: LD_INT 97
10901: ST_TO_ADDR
// ar_bio_bomb := 91 ;
10902: LD_ADDR_EXP 29
10906: PUSH
10907: LD_INT 91
10909: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
10910: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
10911: LD_INT 0
10913: PPUSH
10914: PPUSH
10915: PPUSH
10916: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
10917: LD_VAR 0 1
10921: PPUSH
10922: CALL_OW 264
10926: PUSH
10927: LD_EXP 29
10931: EQUAL
10932: IFFALSE 11004
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
10934: LD_INT 68
10936: PPUSH
10937: LD_VAR 0 1
10941: PPUSH
10942: CALL_OW 255
10946: PPUSH
10947: CALL_OW 321
10951: PUSH
10952: LD_INT 2
10954: EQUAL
10955: IFFALSE 10967
// eff := 70 else
10957: LD_ADDR_VAR 0 6
10961: PUSH
10962: LD_INT 70
10964: ST_TO_ADDR
10965: GO 10975
// eff := 30 ;
10967: LD_ADDR_VAR 0 6
10971: PUSH
10972: LD_INT 30
10974: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
10975: LD_VAR 0 1
10979: PPUSH
10980: CALL_OW 250
10984: PPUSH
10985: LD_VAR 0 1
10989: PPUSH
10990: CALL_OW 251
10994: PPUSH
10995: LD_VAR 0 6
10999: PPUSH
11000: CALL_OW 495
// end ; end ;
11004: LD_VAR 0 4
11008: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
11009: LD_INT 0
11011: PPUSH
11012: PPUSH
11013: PPUSH
11014: PPUSH
11015: PPUSH
11016: PPUSH
// if cmd = 124 then
11017: LD_VAR 0 1
11021: PUSH
11022: LD_INT 124
11024: EQUAL
11025: IFFALSE 11231
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
11027: LD_ADDR_VAR 0 5
11031: PUSH
11032: LD_INT 2
11034: PUSH
11035: LD_INT 34
11037: PUSH
11038: LD_INT 53
11040: PUSH
11041: EMPTY
11042: LIST
11043: LIST
11044: PUSH
11045: LD_INT 34
11047: PUSH
11048: LD_INT 14
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: PUSH
11055: EMPTY
11056: LIST
11057: LIST
11058: LIST
11059: PPUSH
11060: CALL_OW 69
11064: ST_TO_ADDR
// if not tmp then
11065: LD_VAR 0 5
11069: NOT
11070: IFFALSE 11074
// exit ;
11072: GO 11231
// for i in tmp do
11074: LD_ADDR_VAR 0 3
11078: PUSH
11079: LD_VAR 0 5
11083: PUSH
11084: FOR_IN
11085: IFFALSE 11229
// begin taskList := GetTaskList ( i ) ;
11087: LD_ADDR_VAR 0 6
11091: PUSH
11092: LD_VAR 0 3
11096: PPUSH
11097: CALL_OW 437
11101: ST_TO_ADDR
// if not taskList then
11102: LD_VAR 0 6
11106: NOT
11107: IFFALSE 11111
// continue ;
11109: GO 11084
// for j = 1 to taskList do
11111: LD_ADDR_VAR 0 4
11115: PUSH
11116: DOUBLE
11117: LD_INT 1
11119: DEC
11120: ST_TO_ADDR
11121: LD_VAR 0 6
11125: PUSH
11126: FOR_TO
11127: IFFALSE 11225
// if taskList [ j ] [ 1 ] = | then
11129: LD_VAR 0 6
11133: PUSH
11134: LD_VAR 0 4
11138: ARRAY
11139: PUSH
11140: LD_INT 1
11142: ARRAY
11143: PUSH
11144: LD_STRING |
11146: EQUAL
11147: IFFALSE 11223
// begin _taskList := Delete ( taskList , 1 ) ;
11149: LD_ADDR_VAR 0 7
11153: PUSH
11154: LD_VAR 0 6
11158: PPUSH
11159: LD_INT 1
11161: PPUSH
11162: CALL_OW 3
11166: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
11167: LD_VAR 0 3
11171: PPUSH
11172: LD_VAR 0 7
11176: PPUSH
11177: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
11181: LD_VAR 0 3
11185: PPUSH
11186: LD_VAR 0 6
11190: PUSH
11191: LD_VAR 0 4
11195: ARRAY
11196: PUSH
11197: LD_INT 2
11199: ARRAY
11200: PPUSH
11201: LD_VAR 0 6
11205: PUSH
11206: LD_VAR 0 4
11210: ARRAY
11211: PUSH
11212: LD_INT 3
11214: ARRAY
11215: PPUSH
11216: LD_INT 8
11218: PPUSH
11219: CALL 11236 0 4
// end ;
11223: GO 11126
11225: POP
11226: POP
// end ;
11227: GO 11084
11229: POP
11230: POP
// end ; end ;
11231: LD_VAR 0 2
11235: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
11236: LD_INT 0
11238: PPUSH
11239: PPUSH
11240: PPUSH
11241: PPUSH
11242: PPUSH
11243: PPUSH
11244: PPUSH
11245: PPUSH
11246: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
11247: LD_VAR 0 1
11251: NOT
11252: PUSH
11253: LD_VAR 0 2
11257: PPUSH
11258: LD_VAR 0 3
11262: PPUSH
11263: CALL_OW 488
11267: NOT
11268: OR
11269: PUSH
11270: LD_VAR 0 4
11274: NOT
11275: OR
11276: IFFALSE 11280
// exit ;
11278: GO 11620
// list := [ ] ;
11280: LD_ADDR_VAR 0 13
11284: PUSH
11285: EMPTY
11286: ST_TO_ADDR
// if x - r < 0 then
11287: LD_VAR 0 2
11291: PUSH
11292: LD_VAR 0 4
11296: MINUS
11297: PUSH
11298: LD_INT 0
11300: LESS
11301: IFFALSE 11313
// min_x := 0 else
11303: LD_ADDR_VAR 0 7
11307: PUSH
11308: LD_INT 0
11310: ST_TO_ADDR
11311: GO 11329
// min_x := x - r ;
11313: LD_ADDR_VAR 0 7
11317: PUSH
11318: LD_VAR 0 2
11322: PUSH
11323: LD_VAR 0 4
11327: MINUS
11328: ST_TO_ADDR
// if y - r < 0 then
11329: LD_VAR 0 3
11333: PUSH
11334: LD_VAR 0 4
11338: MINUS
11339: PUSH
11340: LD_INT 0
11342: LESS
11343: IFFALSE 11355
// min_y := 0 else
11345: LD_ADDR_VAR 0 8
11349: PUSH
11350: LD_INT 0
11352: ST_TO_ADDR
11353: GO 11371
// min_y := y - r ;
11355: LD_ADDR_VAR 0 8
11359: PUSH
11360: LD_VAR 0 3
11364: PUSH
11365: LD_VAR 0 4
11369: MINUS
11370: ST_TO_ADDR
// max_x := x + r ;
11371: LD_ADDR_VAR 0 9
11375: PUSH
11376: LD_VAR 0 2
11380: PUSH
11381: LD_VAR 0 4
11385: PLUS
11386: ST_TO_ADDR
// max_y := y + r ;
11387: LD_ADDR_VAR 0 10
11391: PUSH
11392: LD_VAR 0 3
11396: PUSH
11397: LD_VAR 0 4
11401: PLUS
11402: ST_TO_ADDR
// for _x = min_x to max_x do
11403: LD_ADDR_VAR 0 11
11407: PUSH
11408: DOUBLE
11409: LD_VAR 0 7
11413: DEC
11414: ST_TO_ADDR
11415: LD_VAR 0 9
11419: PUSH
11420: FOR_TO
11421: IFFALSE 11538
// for _y = min_y to max_y do
11423: LD_ADDR_VAR 0 12
11427: PUSH
11428: DOUBLE
11429: LD_VAR 0 8
11433: DEC
11434: ST_TO_ADDR
11435: LD_VAR 0 10
11439: PUSH
11440: FOR_TO
11441: IFFALSE 11534
// begin if not ValidHex ( _x , _y ) then
11443: LD_VAR 0 11
11447: PPUSH
11448: LD_VAR 0 12
11452: PPUSH
11453: CALL_OW 488
11457: NOT
11458: IFFALSE 11462
// continue ;
11460: GO 11440
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
11462: LD_VAR 0 11
11466: PPUSH
11467: LD_VAR 0 12
11471: PPUSH
11472: CALL_OW 351
11476: PUSH
11477: LD_VAR 0 11
11481: PPUSH
11482: LD_VAR 0 12
11486: PPUSH
11487: CALL_OW 554
11491: AND
11492: IFFALSE 11532
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
11494: LD_ADDR_VAR 0 13
11498: PUSH
11499: LD_VAR 0 13
11503: PPUSH
11504: LD_VAR 0 13
11508: PUSH
11509: LD_INT 1
11511: PLUS
11512: PPUSH
11513: LD_VAR 0 11
11517: PUSH
11518: LD_VAR 0 12
11522: PUSH
11523: EMPTY
11524: LIST
11525: LIST
11526: PPUSH
11527: CALL_OW 2
11531: ST_TO_ADDR
// end ;
11532: GO 11440
11534: POP
11535: POP
11536: GO 11420
11538: POP
11539: POP
// if not list then
11540: LD_VAR 0 13
11544: NOT
11545: IFFALSE 11549
// exit ;
11547: GO 11620
// for i in list do
11549: LD_ADDR_VAR 0 6
11553: PUSH
11554: LD_VAR 0 13
11558: PUSH
11559: FOR_IN
11560: IFFALSE 11618
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
11562: LD_VAR 0 1
11566: PPUSH
11567: LD_STRING M
11569: PUSH
11570: LD_VAR 0 6
11574: PUSH
11575: LD_INT 1
11577: ARRAY
11578: PUSH
11579: LD_VAR 0 6
11583: PUSH
11584: LD_INT 2
11586: ARRAY
11587: PUSH
11588: LD_INT 0
11590: PUSH
11591: LD_INT 0
11593: PUSH
11594: LD_INT 0
11596: PUSH
11597: LD_INT 0
11599: PUSH
11600: EMPTY
11601: LIST
11602: LIST
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: PUSH
11609: EMPTY
11610: LIST
11611: PPUSH
11612: CALL_OW 447
11616: GO 11559
11618: POP
11619: POP
// end ;
11620: LD_VAR 0 5
11624: RET
