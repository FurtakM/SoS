// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 66 0 0
// PrepareAnimals ( 6 , 3 , 4 , apearea ) ;
  15: LD_INT 6
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 4
  23: PPUSH
  24: LD_INT 21
  26: PPUSH
  27: CALL 10438 0 4
// PrepareAmerican ;
  31: CALL 3957 0 0
// PrepareRussian ;
  35: CALL 277 0 0
// Action ;
  39: CALL 8165 0 0
// end ;
  43: END
// every 0 0$01 do
  44: GO 46
  46: DISABLE
// begin enable ;
  47: ENABLE
// display_strings := [ #tick , tick ] ;
  48: LD_ADDR_OWVAR 47
  52: PUSH
  53: LD_STRING #tick
  55: PUSH
  56: LD_OWVAR 1
  60: PUSH
  61: EMPTY
  62: LIST
  63: LIST
  64: ST_TO_ADDR
// end ;
  65: END
// export conv_squad , escort , medal1 , medal2 , medal3 , path , convoy_start , dest_counter ; export riv , ar_attacks , ar_force , us_force , conv_counter , crates_counter ; function Init ; begin
  66: LD_INT 0
  68: PPUSH
// medal1 := true ;
  69: LD_ADDR_EXP 3
  73: PUSH
  74: LD_INT 1
  76: ST_TO_ADDR
// medal2 := true ;
  77: LD_ADDR_EXP 4
  81: PUSH
  82: LD_INT 1
  84: ST_TO_ADDR
// medal3 := true ;
  85: LD_ADDR_EXP 5
  89: PUSH
  90: LD_INT 1
  92: ST_TO_ADDR
// path := [ pp1 , pp2 , pp3 , pp4 , conv_end ] ;
  93: LD_ADDR_EXP 6
  97: PUSH
  98: LD_INT 10
 100: PUSH
 101: LD_INT 11
 103: PUSH
 104: LD_INT 12
 106: PUSH
 107: LD_INT 13
 109: PUSH
 110: LD_INT 9
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: LIST
 118: LIST
 119: ST_TO_ADDR
// conv_squad := [ ] ;
 120: LD_ADDR_EXP 1
 124: PUSH
 125: EMPTY
 126: ST_TO_ADDR
// escort := [ ] ;
 127: LD_ADDR_EXP 2
 131: PUSH
 132: EMPTY
 133: ST_TO_ADDR
// riv := [ ] ;
 134: LD_ADDR_EXP 9
 138: PUSH
 139: EMPTY
 140: ST_TO_ADDR
// ar_force := [ ] ;
 141: LD_ADDR_EXP 11
 145: PUSH
 146: EMPTY
 147: ST_TO_ADDR
// ar_attacks := false ;
 148: LD_ADDR_EXP 10
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// us_force := [ ] ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: EMPTY
 162: ST_TO_ADDR
// convoy_start := false ;
 163: LD_ADDR_EXP 7
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// conv_counter := 0 ;
 171: LD_ADDR_EXP 13
 175: PUSH
 176: LD_INT 0
 178: ST_TO_ADDR
// dest_counter := 0 ;
 179: LD_ADDR_EXP 8
 183: PUSH
 184: LD_INT 0
 186: ST_TO_ADDR
// crates_counter := 0 0$40 ;
 187: LD_ADDR_EXP 14
 191: PUSH
 192: LD_INT 1400
 194: ST_TO_ADDR
// end ;
 195: LD_VAR 0 1
 199: RET
// every 2 2$00 do
 200: GO 202
 202: DISABLE
// begin while ( tick <= [ 47 47$00 , 44 44$00 , 41 41$00 ] [ Difficulty ] ) do
 203: LD_OWVAR 1
 207: PUSH
 208: LD_INT 98700
 210: PUSH
 211: LD_INT 92400
 213: PUSH
 214: LD_INT 86100
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: PUSH
 222: LD_OWVAR 67
 226: ARRAY
 227: LESSEQUAL
 228: IFFALSE 276
// begin Wait ( crates_counter ) ;
 230: LD_EXP 14
 234: PPUSH
 235: CALL_OW 67
// crates_counter := crates_counter + 0 0$09 ;
 239: LD_ADDR_EXP 14
 243: PUSH
 244: LD_EXP 14
 248: PUSH
 249: LD_INT 315
 251: PLUS
 252: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 5
 258: PPUSH
 259: CALL_OW 12
 263: PPUSH
 264: LD_INT 22
 266: PPUSH
 267: LD_INT 1
 269: PPUSH
 270: CALL_OW 55
// end ;
 274: GO 203
// end ; end_of_file
 276: END
// export Stolypin , Popov , Saseda ; export function PrepareRussian ; var un , force , i , c , skill , team ; begin
 277: LD_INT 0
 279: PPUSH
 280: PPUSH
 281: PPUSH
 282: PPUSH
 283: PPUSH
 284: PPUSH
 285: PPUSH
// uc_side := 6 ;
 286: LD_ADDR_OWVAR 20
 290: PUSH
 291: LD_INT 6
 293: ST_TO_ADDR
// uc_nation := 3 ;
 294: LD_ADDR_OWVAR 21
 298: PUSH
 299: LD_INT 3
 301: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
 302: LD_INT 3
 304: PPUSH
 305: LD_INT 6
 307: PPUSH
 308: CALL_OW 343
// Popov := NewCharacter ( Gaydar ) ;
 312: LD_ADDR_EXP 16
 316: PUSH
 317: LD_STRING Gaydar
 319: PPUSH
 320: CALL_OW 25
 324: ST_TO_ADDR
// uc_side := 7 ;
 325: LD_ADDR_OWVAR 20
 329: PUSH
 330: LD_INT 7
 332: ST_TO_ADDR
// hc_gallery := sandal ;
 333: LD_ADDR_OWVAR 33
 337: PUSH
 338: LD_STRING sandal
 340: ST_TO_ADDR
// hc_face_number := 9 ;
 341: LD_ADDR_OWVAR 34
 345: PUSH
 346: LD_INT 9
 348: ST_TO_ADDR
// hc_skills := [ 3 , 5 , 2 , 7 ] ;
 349: LD_ADDR_OWVAR 31
 353: PUSH
 354: LD_INT 3
 356: PUSH
 357: LD_INT 5
 359: PUSH
 360: LD_INT 2
 362: PUSH
 363: LD_INT 7
 365: PUSH
 366: EMPTY
 367: LIST
 368: LIST
 369: LIST
 370: LIST
 371: ST_TO_ADDR
// hc_sex := sex_male ;
 372: LD_ADDR_OWVAR 27
 376: PUSH
 377: LD_INT 1
 379: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 380: LD_ADDR_OWVAR 29
 384: PUSH
 385: LD_INT 10
 387: PUSH
 388: LD_INT 11
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: ST_TO_ADDR
// hc_class := 4 ;
 395: LD_ADDR_OWVAR 28
 399: PUSH
 400: LD_INT 4
 402: ST_TO_ADDR
// hc_name := Fiodor Saseda ;
 403: LD_ADDR_OWVAR 26
 407: PUSH
 408: LD_STRING Fiodor Saseda
 410: ST_TO_ADDR
// Saseda := CreateHuman ;
 411: LD_ADDR_EXP 17
 415: PUSH
 416: CALL_OW 44
 420: ST_TO_ADDR
// uc_side := 3 ;
 421: LD_ADDR_OWVAR 20
 425: PUSH
 426: LD_INT 3
 428: ST_TO_ADDR
// hc_importance := 100 ;
 429: LD_ADDR_OWVAR 32
 433: PUSH
 434: LD_INT 100
 436: ST_TO_ADDR
// hc_class := 1 ;
 437: LD_ADDR_OWVAR 28
 441: PUSH
 442: LD_INT 1
 444: ST_TO_ADDR
// hc_sex := sex_male ;
 445: LD_ADDR_OWVAR 27
 449: PUSH
 450: LD_INT 1
 452: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
 453: LD_ADDR_OWVAR 31
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 3
 463: PUSH
 464: LD_INT 4
 466: PUSH
 467: LD_INT 2
 469: PUSH
 470: EMPTY
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: ST_TO_ADDR
// hc_name := W. I. Stolypin ;
 476: LD_ADDR_OWVAR 26
 480: PUSH
 481: LD_STRING W. I. Stolypin
 483: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 484: LD_ADDR_OWVAR 29
 488: PUSH
 489: LD_INT 10
 491: PUSH
 492: LD_INT 11
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: ST_TO_ADDR
// hc_gallery := ru ;
 499: LD_ADDR_OWVAR 33
 503: PUSH
 504: LD_STRING ru
 506: ST_TO_ADDR
// hc_face_number := 15 ;
 507: LD_ADDR_OWVAR 34
 511: PUSH
 512: LD_INT 15
 514: ST_TO_ADDR
// Stolypin := CreateHuman ;
 515: LD_ADDR_EXP 15
 519: PUSH
 520: CALL_OW 44
 524: ST_TO_ADDR
// hc_importance := 0 ;
 525: LD_ADDR_OWVAR 32
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// hc_gallery :=  ;
 533: LD_ADDR_OWVAR 33
 537: PUSH
 538: LD_STRING 
 540: ST_TO_ADDR
// hc_name :=  ;
 541: LD_ADDR_OWVAR 26
 545: PUSH
 546: LD_STRING 
 548: ST_TO_ADDR
// skill := [ 6 , 5 , 5 ] [ Difficulty ] ;
 549: LD_ADDR_VAR 0 6
 553: PUSH
 554: LD_INT 6
 556: PUSH
 557: LD_INT 5
 559: PUSH
 560: LD_INT 5
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: PUSH
 568: LD_OWVAR 67
 572: ARRAY
 573: ST_TO_ADDR
// c := 1 ;
 574: LD_ADDR_VAR 0 5
 578: PUSH
 579: LD_INT 1
 581: ST_TO_ADDR
// for i = 1 to 21 do
 582: LD_ADDR_VAR 0 4
 586: PUSH
 587: DOUBLE
 588: LD_INT 1
 590: DEC
 591: ST_TO_ADDR
 592: LD_INT 21
 594: PUSH
 595: FOR_TO
 596: IFFALSE 697
// begin if i = 10 then
 598: LD_VAR 0 4
 602: PUSH
 603: LD_INT 10
 605: EQUAL
 606: IFFALSE 616
// c := 2 ;
 608: LD_ADDR_VAR 0 5
 612: PUSH
 613: LD_INT 2
 615: ST_TO_ADDR
// if i = 14 then
 616: LD_VAR 0 4
 620: PUSH
 621: LD_INT 14
 623: EQUAL
 624: IFFALSE 634
// c := 3 ;
 626: LD_ADDR_VAR 0 5
 630: PUSH
 631: LD_INT 3
 633: ST_TO_ADDR
// if i = 18 then
 634: LD_VAR 0 4
 638: PUSH
 639: LD_INT 18
 641: EQUAL
 642: IFFALSE 652
// c := 4 ;
 644: LD_ADDR_VAR 0 5
 648: PUSH
 649: LD_INT 4
 651: ST_TO_ADDR
// PrepareHuman ( false , c , skill ) ;
 652: LD_INT 0
 654: PPUSH
 655: LD_VAR 0 5
 659: PPUSH
 660: LD_VAR 0 6
 664: PPUSH
 665: CALL_OW 380
// un := CreateHuman ;
 669: LD_ADDR_VAR 0 2
 673: PUSH
 674: CALL_OW 44
 678: ST_TO_ADDR
// force := force ^ un ;
 679: LD_ADDR_VAR 0 3
 683: PUSH
 684: LD_VAR 0 3
 688: PUSH
 689: LD_VAR 0 2
 693: ADD
 694: ST_TO_ADDR
// end ;
 695: GO 595
 697: POP
 698: POP
// team := CharacterSelection ( text , [ 8 , 7 , 7 ] [ Difficulty ] , [ 8 , 7 , 7 ] [ Difficulty ] , [ sel_change_class , Stolypin , sel_changeable , sel_not_hired ] ^ force , [ [ class_soldier , 3 ] , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
 699: LD_ADDR_VAR 0 7
 703: PUSH
 704: LD_STRING text
 706: PPUSH
 707: LD_INT 8
 709: PUSH
 710: LD_INT 7
 712: PUSH
 713: LD_INT 7
 715: PUSH
 716: EMPTY
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_OWVAR 67
 725: ARRAY
 726: PPUSH
 727: LD_INT 8
 729: PUSH
 730: LD_INT 7
 732: PUSH
 733: LD_INT 7
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_OWVAR 67
 745: ARRAY
 746: PPUSH
 747: LD_INT -5
 749: PUSH
 750: LD_EXP 15
 754: PUSH
 755: LD_INT -3
 757: PUSH
 758: LD_INT -2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: LIST
 766: PUSH
 767: LD_VAR 0 3
 771: ADD
 772: PPUSH
 773: LD_INT 1
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: EMPTY
 780: LIST
 781: LIST
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 2
 788: PUSH
 789: LD_INT 1
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 4
 798: PUSH
 799: EMPTY
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PPUSH
 805: CALL_OW 42
 809: ST_TO_ADDR
// team := team ^ Stolypin ;
 810: LD_ADDR_VAR 0 7
 814: PUSH
 815: LD_VAR 0 7
 819: PUSH
 820: LD_EXP 15
 824: ADD
 825: ST_TO_ADDR
// for i = 1 to team do
 826: LD_ADDR_VAR 0 4
 830: PUSH
 831: DOUBLE
 832: LD_INT 1
 834: DEC
 835: ST_TO_ADDR
 836: LD_VAR 0 7
 840: PUSH
 841: FOR_TO
 842: IFFALSE 867
// PlaceUnitArea ( team [ i ] , rus_start , false ) ;
 844: LD_VAR 0 7
 848: PUSH
 849: LD_VAR 0 4
 853: ARRAY
 854: PPUSH
 855: LD_INT 1
 857: PPUSH
 858: LD_INT 0
 860: PPUSH
 861: CALL_OW 49
 865: GO 841
 867: POP
 868: POP
// CenterNowOnUnits ( Stolypin ) ;
 869: LD_EXP 15
 873: PPUSH
 874: CALL_OW 87
// end ;
 878: LD_VAR 0 1
 882: RET
// export conv_ready ; export function Convoy ( type ) ; var i , veh , skill ; begin
 883: LD_INT 0
 885: PPUSH
 886: PPUSH
 887: PPUSH
 888: PPUSH
// Randomize ;
 889: CALL_OW 10
// uc_side := 6 ;
 893: LD_ADDR_OWVAR 20
 897: PUSH
 898: LD_INT 6
 900: ST_TO_ADDR
// uc_nation := 3 ;
 901: LD_ADDR_OWVAR 21
 905: PUSH
 906: LD_INT 3
 908: ST_TO_ADDR
// hc_name :=  ;
 909: LD_ADDR_OWVAR 26
 913: PUSH
 914: LD_STRING 
 916: ST_TO_ADDR
// hc_gallery :=  ;
 917: LD_ADDR_OWVAR 33
 921: PUSH
 922: LD_STRING 
 924: ST_TO_ADDR
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
 925: LD_ADDR_VAR 0 5
 929: PUSH
 930: LD_INT 5
 932: PUSH
 933: LD_INT 5
 935: PUSH
 936: LD_INT 4
 938: PUSH
 939: EMPTY
 940: LIST
 941: LIST
 942: LIST
 943: PUSH
 944: LD_OWVAR 67
 948: ARRAY
 949: ST_TO_ADDR
// conv_ready := false ;
 950: LD_ADDR_EXP 18
 954: PUSH
 955: LD_INT 0
 957: ST_TO_ADDR
// case type of 1 :
 958: LD_VAR 0 1
 962: PUSH
 963: LD_INT 1
 965: DOUBLE
 966: EQUAL
 967: IFTRUE 971
 969: GO 1241
 971: POP
// begin if Rand ( 0 , 1 ) = 1 then
 972: LD_INT 0
 974: PPUSH
 975: LD_INT 1
 977: PPUSH
 978: CALL_OW 12
 982: PUSH
 983: LD_INT 1
 985: EQUAL
 986: IFFALSE 992
// AddEscort ( ) ;
 988: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
 992: LD_INT 70
 994: PPUSH
 995: CALL_OW 67
// vc_chassis := ru_medium_wheeled ;
 999: LD_ADDR_OWVAR 37
1003: PUSH
1004: LD_INT 21
1006: ST_TO_ADDR
// vc_engine := engine_combustion ;
1007: LD_ADDR_OWVAR 39
1011: PUSH
1012: LD_INT 1
1014: ST_TO_ADDR
// vc_control := control_manual ;
1015: LD_ADDR_OWVAR 38
1019: PUSH
1020: LD_INT 1
1022: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1023: LD_ADDR_OWVAR 40
1027: PUSH
1028: LD_INT 51
1030: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1031: LD_ADDR_OWVAR 41
1035: PUSH
1036: LD_INT 50
1038: PPUSH
1039: LD_INT 99
1041: PPUSH
1042: CALL_OW 12
1046: ST_TO_ADDR
// if uc_side <> 6 then
1047: LD_OWVAR 20
1051: PUSH
1052: LD_INT 6
1054: NONEQUAL
1055: IFFALSE 1065
// uc_side := 6 ;
1057: LD_ADDR_OWVAR 20
1061: PUSH
1062: LD_INT 6
1064: ST_TO_ADDR
// veh := CreateVehicle ;
1065: LD_ADDR_VAR 0 4
1069: PUSH
1070: CALL_OW 45
1074: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1075: LD_VAR 0 4
1079: PPUSH
1080: LD_INT 3
1082: PPUSH
1083: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1087: LD_VAR 0 4
1091: PPUSH
1092: LD_INT 8
1094: PPUSH
1095: LD_INT 0
1097: PPUSH
1098: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1102: LD_INT 0
1104: PPUSH
1105: LD_INT 1
1107: PPUSH
1108: LD_INT 2
1110: PPUSH
1111: CALL_OW 12
1115: PPUSH
1116: LD_VAR 0 5
1120: PPUSH
1121: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1125: CALL_OW 44
1129: PPUSH
1130: LD_VAR 0 4
1134: PPUSH
1135: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1139: LD_VAR 0 4
1143: PPUSH
1144: LD_INT 500
1146: PPUSH
1147: LD_INT 1000
1149: PPUSH
1150: CALL_OW 12
1154: PPUSH
1155: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1159: LD_VAR 0 4
1163: PPUSH
1164: LD_INT 1
1166: PPUSH
1167: LD_INT 2
1169: PPUSH
1170: CALL_OW 12
1174: PPUSH
1175: LD_INT 2
1177: PPUSH
1178: LD_INT 10
1180: PPUSH
1181: CALL_OW 12
1185: PUSH
1186: LD_INT 10
1188: MUL
1189: PPUSH
1190: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1194: LD_ADDR_EXP 1
1198: PUSH
1199: LD_EXP 1
1203: PPUSH
1204: LD_INT 1
1206: PPUSH
1207: LD_VAR 0 4
1211: PUSH
1212: LD_INT 1
1214: PUSH
1215: EMPTY
1216: LIST
1217: LIST
1218: PPUSH
1219: CALL_OW 2
1223: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
1224: LD_INT 35
1226: PPUSH
1227: CALL_OW 67
// conv_ready := true ;
1231: LD_ADDR_EXP 18
1235: PUSH
1236: LD_INT 1
1238: ST_TO_ADDR
// end ; 2 :
1239: GO 2861
1241: LD_INT 2
1243: DOUBLE
1244: EQUAL
1245: IFTRUE 1249
1247: GO 1549
1249: POP
// begin AddEscort ( ) ;
1250: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1254: LD_INT 70
1256: PPUSH
1257: CALL_OW 67
// for i = 1 to 2 do
1261: LD_ADDR_VAR 0 3
1265: PUSH
1266: DOUBLE
1267: LD_INT 1
1269: DEC
1270: ST_TO_ADDR
1271: LD_INT 2
1273: PUSH
1274: FOR_TO
1275: IFFALSE 1526
// begin vc_chassis := ru_medium_wheeled ;
1277: LD_ADDR_OWVAR 37
1281: PUSH
1282: LD_INT 21
1284: ST_TO_ADDR
// vc_engine := engine_combustion ;
1285: LD_ADDR_OWVAR 39
1289: PUSH
1290: LD_INT 1
1292: ST_TO_ADDR
// vc_control := control_manual ;
1293: LD_ADDR_OWVAR 38
1297: PUSH
1298: LD_INT 1
1300: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1301: LD_ADDR_OWVAR 40
1305: PUSH
1306: LD_INT 51
1308: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1309: LD_ADDR_OWVAR 41
1313: PUSH
1314: LD_INT 50
1316: PPUSH
1317: LD_INT 99
1319: PPUSH
1320: CALL_OW 12
1324: ST_TO_ADDR
// if uc_side <> 6 then
1325: LD_OWVAR 20
1329: PUSH
1330: LD_INT 6
1332: NONEQUAL
1333: IFFALSE 1343
// uc_side := 6 ;
1335: LD_ADDR_OWVAR 20
1339: PUSH
1340: LD_INT 6
1342: ST_TO_ADDR
// veh := CreateVehicle ;
1343: LD_ADDR_VAR 0 4
1347: PUSH
1348: CALL_OW 45
1352: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1353: LD_VAR 0 4
1357: PPUSH
1358: LD_INT 3
1360: PPUSH
1361: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1365: LD_VAR 0 4
1369: PPUSH
1370: LD_INT 8
1372: PPUSH
1373: LD_INT 0
1375: PPUSH
1376: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1380: LD_INT 0
1382: PPUSH
1383: LD_INT 1
1385: PPUSH
1386: LD_INT 2
1388: PPUSH
1389: CALL_OW 12
1393: PPUSH
1394: LD_VAR 0 5
1398: PPUSH
1399: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1403: CALL_OW 44
1407: PPUSH
1408: LD_VAR 0 4
1412: PPUSH
1413: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1417: LD_VAR 0 4
1421: PPUSH
1422: LD_INT 500
1424: PPUSH
1425: LD_INT 1000
1427: PPUSH
1428: CALL_OW 12
1432: PPUSH
1433: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1437: LD_VAR 0 4
1441: PPUSH
1442: LD_INT 1
1444: PPUSH
1445: LD_INT 2
1447: PPUSH
1448: CALL_OW 12
1452: PPUSH
1453: LD_INT 2
1455: PPUSH
1456: LD_INT 10
1458: PPUSH
1459: CALL_OW 12
1463: PUSH
1464: LD_INT 10
1466: MUL
1467: PPUSH
1468: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1472: LD_ADDR_EXP 1
1476: PUSH
1477: LD_EXP 1
1481: PPUSH
1482: LD_INT 1
1484: PPUSH
1485: LD_VAR 0 4
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: PPUSH
1497: CALL_OW 2
1501: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1502: LD_VAR 0 4
1506: PPUSH
1507: LD_INT 120
1509: PPUSH
1510: LD_INT 10
1512: PPUSH
1513: CALL_OW 111
// Wait ( 0 0$02 ) ;
1517: LD_INT 70
1519: PPUSH
1520: CALL_OW 67
// end ;
1524: GO 1274
1526: POP
1527: POP
// AddEscort ( ) ;
1528: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1532: LD_INT 70
1534: PPUSH
1535: CALL_OW 67
// conv_ready := true ;
1539: LD_ADDR_EXP 18
1543: PUSH
1544: LD_INT 1
1546: ST_TO_ADDR
// end ; 3 :
1547: GO 2861
1549: LD_INT 3
1551: DOUBLE
1552: EQUAL
1553: IFTRUE 1557
1555: GO 1976
1557: POP
// begin AddEscort ( ) ;
1558: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1562: LD_INT 70
1564: PPUSH
1565: CALL_OW 67
// for i = 1 to 2 do
1569: LD_ADDR_VAR 0 3
1573: PUSH
1574: DOUBLE
1575: LD_INT 1
1577: DEC
1578: ST_TO_ADDR
1579: LD_INT 2
1581: PUSH
1582: FOR_TO
1583: IFFALSE 1834
// begin vc_chassis := ru_medium_wheeled ;
1585: LD_ADDR_OWVAR 37
1589: PUSH
1590: LD_INT 21
1592: ST_TO_ADDR
// vc_engine := engine_combustion ;
1593: LD_ADDR_OWVAR 39
1597: PUSH
1598: LD_INT 1
1600: ST_TO_ADDR
// vc_control := control_manual ;
1601: LD_ADDR_OWVAR 38
1605: PUSH
1606: LD_INT 1
1608: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1609: LD_ADDR_OWVAR 40
1613: PUSH
1614: LD_INT 51
1616: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1617: LD_ADDR_OWVAR 41
1621: PUSH
1622: LD_INT 50
1624: PPUSH
1625: LD_INT 99
1627: PPUSH
1628: CALL_OW 12
1632: ST_TO_ADDR
// if uc_side <> 6 then
1633: LD_OWVAR 20
1637: PUSH
1638: LD_INT 6
1640: NONEQUAL
1641: IFFALSE 1651
// uc_side := 6 ;
1643: LD_ADDR_OWVAR 20
1647: PUSH
1648: LD_INT 6
1650: ST_TO_ADDR
// veh := CreateVehicle ;
1651: LD_ADDR_VAR 0 4
1655: PUSH
1656: CALL_OW 45
1660: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1661: LD_VAR 0 4
1665: PPUSH
1666: LD_INT 3
1668: PPUSH
1669: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1673: LD_VAR 0 4
1677: PPUSH
1678: LD_INT 8
1680: PPUSH
1681: LD_INT 0
1683: PPUSH
1684: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1688: LD_INT 0
1690: PPUSH
1691: LD_INT 1
1693: PPUSH
1694: LD_INT 2
1696: PPUSH
1697: CALL_OW 12
1701: PPUSH
1702: LD_VAR 0 5
1706: PPUSH
1707: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1711: CALL_OW 44
1715: PPUSH
1716: LD_VAR 0 4
1720: PPUSH
1721: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1725: LD_VAR 0 4
1729: PPUSH
1730: LD_INT 500
1732: PPUSH
1733: LD_INT 1000
1735: PPUSH
1736: CALL_OW 12
1740: PPUSH
1741: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1745: LD_VAR 0 4
1749: PPUSH
1750: LD_INT 1
1752: PPUSH
1753: LD_INT 2
1755: PPUSH
1756: CALL_OW 12
1760: PPUSH
1761: LD_INT 2
1763: PPUSH
1764: LD_INT 10
1766: PPUSH
1767: CALL_OW 12
1771: PUSH
1772: LD_INT 10
1774: MUL
1775: PPUSH
1776: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1780: LD_ADDR_EXP 1
1784: PUSH
1785: LD_EXP 1
1789: PPUSH
1790: LD_INT 1
1792: PPUSH
1793: LD_VAR 0 4
1797: PUSH
1798: LD_INT 1
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: PPUSH
1805: CALL_OW 2
1809: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1810: LD_VAR 0 4
1814: PPUSH
1815: LD_INT 120
1817: PPUSH
1818: LD_INT 10
1820: PPUSH
1821: CALL_OW 111
// Wait ( 0 0$02 ) ;
1825: LD_INT 70
1827: PPUSH
1828: CALL_OW 67
// end ;
1832: GO 1582
1834: POP
1835: POP
// for i = 1 to 2 do
1836: LD_ADDR_VAR 0 3
1840: PUSH
1841: DOUBLE
1842: LD_INT 1
1844: DEC
1845: ST_TO_ADDR
1846: LD_INT 2
1848: PUSH
1849: FOR_TO
1850: IFFALSE 1957
// begin PrepareHuman ( false , 1 , skill ) ;
1852: LD_INT 0
1854: PPUSH
1855: LD_INT 1
1857: PPUSH
1858: LD_VAR 0 5
1862: PPUSH
1863: CALL_OW 380
// if uc_side <> 6 then
1867: LD_OWVAR 20
1871: PUSH
1872: LD_INT 6
1874: NONEQUAL
1875: IFFALSE 1885
// uc_side := 6 ;
1877: LD_ADDR_OWVAR 20
1881: PUSH
1882: LD_INT 6
1884: ST_TO_ADDR
// veh := CreateHuman ;
1885: LD_ADDR_VAR 0 4
1889: PUSH
1890: CALL_OW 44
1894: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
1895: LD_VAR 0 4
1899: PPUSH
1900: LD_INT 8
1902: PPUSH
1903: LD_INT 0
1905: PPUSH
1906: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
1910: LD_ADDR_EXP 2
1914: PUSH
1915: LD_EXP 2
1919: PPUSH
1920: LD_INT 1
1922: PPUSH
1923: LD_VAR 0 4
1927: PPUSH
1928: CALL_OW 2
1932: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1933: LD_VAR 0 4
1937: PPUSH
1938: LD_INT 120
1940: PPUSH
1941: LD_INT 10
1943: PPUSH
1944: CALL_OW 111
// Wait ( 0 0$02 ) ;
1948: LD_INT 70
1950: PPUSH
1951: CALL_OW 67
// end ;
1955: GO 1849
1957: POP
1958: POP
// Wait ( 0 0$02 ) ;
1959: LD_INT 70
1961: PPUSH
1962: CALL_OW 67
// conv_ready := true ;
1966: LD_ADDR_EXP 18
1970: PUSH
1971: LD_INT 1
1973: ST_TO_ADDR
// end ; 4 :
1974: GO 2861
1976: LD_INT 4
1978: DOUBLE
1979: EQUAL
1980: IFTRUE 1984
1982: GO 2290
1984: POP
// begin if Rand ( 0 , 1 ) = 1 then
1985: LD_INT 0
1987: PPUSH
1988: LD_INT 1
1990: PPUSH
1991: CALL_OW 12
1995: PUSH
1996: LD_INT 1
1998: EQUAL
1999: IFFALSE 2005
// AddEscort ( ) ;
2001: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2005: LD_INT 70
2007: PPUSH
2008: CALL_OW 67
// for i = 1 to 5 do
2012: LD_ADDR_VAR 0 3
2016: PUSH
2017: DOUBLE
2018: LD_INT 1
2020: DEC
2021: ST_TO_ADDR
2022: LD_INT 5
2024: PUSH
2025: FOR_TO
2026: IFFALSE 2148
// begin PrepareHuman ( false , Rand ( 2 , 4 ) , skill ) ;
2028: LD_INT 0
2030: PPUSH
2031: LD_INT 2
2033: PPUSH
2034: LD_INT 4
2036: PPUSH
2037: CALL_OW 12
2041: PPUSH
2042: LD_VAR 0 5
2046: PPUSH
2047: CALL_OW 380
// if uc_side <> 6 then
2051: LD_OWVAR 20
2055: PUSH
2056: LD_INT 6
2058: NONEQUAL
2059: IFFALSE 2069
// uc_side := 6 ;
2061: LD_ADDR_OWVAR 20
2065: PUSH
2066: LD_INT 6
2068: ST_TO_ADDR
// veh := CreateHuman ;
2069: LD_ADDR_VAR 0 4
2073: PUSH
2074: CALL_OW 44
2078: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2079: LD_VAR 0 4
2083: PPUSH
2084: LD_INT 8
2086: PPUSH
2087: LD_INT 0
2089: PPUSH
2090: CALL_OW 49
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2094: LD_ADDR_EXP 1
2098: PUSH
2099: LD_EXP 1
2103: PPUSH
2104: LD_INT 1
2106: PPUSH
2107: LD_VAR 0 4
2111: PUSH
2112: LD_INT 1
2114: PUSH
2115: EMPTY
2116: LIST
2117: LIST
2118: PPUSH
2119: CALL_OW 2
2123: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2124: LD_VAR 0 4
2128: PPUSH
2129: LD_INT 120
2131: PPUSH
2132: LD_INT 10
2134: PPUSH
2135: CALL_OW 111
// Wait ( 0 0$02 ) ;
2139: LD_INT 70
2141: PPUSH
2142: CALL_OW 67
// end ;
2146: GO 2025
2148: POP
2149: POP
// for i = 1 to 2 do
2150: LD_ADDR_VAR 0 3
2154: PUSH
2155: DOUBLE
2156: LD_INT 1
2158: DEC
2159: ST_TO_ADDR
2160: LD_INT 2
2162: PUSH
2163: FOR_TO
2164: IFFALSE 2271
// begin PrepareHuman ( false , 1 , skill ) ;
2166: LD_INT 0
2168: PPUSH
2169: LD_INT 1
2171: PPUSH
2172: LD_VAR 0 5
2176: PPUSH
2177: CALL_OW 380
// if uc_side <> 6 then
2181: LD_OWVAR 20
2185: PUSH
2186: LD_INT 6
2188: NONEQUAL
2189: IFFALSE 2199
// uc_side := 6 ;
2191: LD_ADDR_OWVAR 20
2195: PUSH
2196: LD_INT 6
2198: ST_TO_ADDR
// veh := CreateHuman ;
2199: LD_ADDR_VAR 0 4
2203: PUSH
2204: CALL_OW 44
2208: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2209: LD_VAR 0 4
2213: PPUSH
2214: LD_INT 8
2216: PPUSH
2217: LD_INT 0
2219: PPUSH
2220: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
2224: LD_ADDR_EXP 2
2228: PUSH
2229: LD_EXP 2
2233: PPUSH
2234: LD_INT 1
2236: PPUSH
2237: LD_VAR 0 4
2241: PPUSH
2242: CALL_OW 2
2246: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2247: LD_VAR 0 4
2251: PPUSH
2252: LD_INT 120
2254: PPUSH
2255: LD_INT 10
2257: PPUSH
2258: CALL_OW 111
// Wait ( 0 0$02 ) ;
2262: LD_INT 70
2264: PPUSH
2265: CALL_OW 67
// end ;
2269: GO 2163
2271: POP
2272: POP
// Wait ( 0 0$02 ) ;
2273: LD_INT 70
2275: PPUSH
2276: CALL_OW 67
// conv_ready := true ;
2280: LD_ADDR_EXP 18
2284: PUSH
2285: LD_INT 1
2287: ST_TO_ADDR
// end ; 5 :
2288: GO 2861
2290: LD_INT 5
2292: DOUBLE
2293: EQUAL
2294: IFTRUE 2298
2296: GO 2860
2298: POP
// begin AddEscort ( ) ;
2299: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2303: LD_INT 70
2305: PPUSH
2306: CALL_OW 67
// AddEscort ( ) ;
2310: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2314: LD_INT 70
2316: PPUSH
2317: CALL_OW 67
// for i = 1 to 2 do
2321: LD_ADDR_VAR 0 3
2325: PUSH
2326: DOUBLE
2327: LD_INT 1
2329: DEC
2330: ST_TO_ADDR
2331: LD_INT 2
2333: PUSH
2334: FOR_TO
2335: IFFALSE 2586
// begin vc_chassis := ru_medium_wheeled ;
2337: LD_ADDR_OWVAR 37
2341: PUSH
2342: LD_INT 21
2344: ST_TO_ADDR
// vc_engine := engine_combustion ;
2345: LD_ADDR_OWVAR 39
2349: PUSH
2350: LD_INT 1
2352: ST_TO_ADDR
// vc_control := control_manual ;
2353: LD_ADDR_OWVAR 38
2357: PUSH
2358: LD_INT 1
2360: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2361: LD_ADDR_OWVAR 40
2365: PUSH
2366: LD_INT 51
2368: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2369: LD_ADDR_OWVAR 41
2373: PUSH
2374: LD_INT 50
2376: PPUSH
2377: LD_INT 99
2379: PPUSH
2380: CALL_OW 12
2384: ST_TO_ADDR
// if uc_side <> 6 then
2385: LD_OWVAR 20
2389: PUSH
2390: LD_INT 6
2392: NONEQUAL
2393: IFFALSE 2403
// uc_side := 6 ;
2395: LD_ADDR_OWVAR 20
2399: PUSH
2400: LD_INT 6
2402: ST_TO_ADDR
// veh := CreateVehicle ;
2403: LD_ADDR_VAR 0 4
2407: PUSH
2408: CALL_OW 45
2412: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2413: LD_VAR 0 4
2417: PPUSH
2418: LD_INT 3
2420: PPUSH
2421: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2425: LD_VAR 0 4
2429: PPUSH
2430: LD_INT 8
2432: PPUSH
2433: LD_INT 0
2435: PPUSH
2436: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2440: LD_INT 0
2442: PPUSH
2443: LD_INT 1
2445: PPUSH
2446: LD_INT 2
2448: PPUSH
2449: CALL_OW 12
2453: PPUSH
2454: LD_VAR 0 5
2458: PPUSH
2459: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2463: CALL_OW 44
2467: PPUSH
2468: LD_VAR 0 4
2472: PPUSH
2473: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2477: LD_VAR 0 4
2481: PPUSH
2482: LD_INT 500
2484: PPUSH
2485: LD_INT 1000
2487: PPUSH
2488: CALL_OW 12
2492: PPUSH
2493: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
2497: LD_VAR 0 4
2501: PPUSH
2502: LD_INT 1
2504: PPUSH
2505: LD_INT 2
2507: PPUSH
2508: CALL_OW 12
2512: PPUSH
2513: LD_INT 2
2515: PPUSH
2516: LD_INT 10
2518: PPUSH
2519: CALL_OW 12
2523: PUSH
2524: LD_INT 10
2526: MUL
2527: PPUSH
2528: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2532: LD_ADDR_EXP 1
2536: PUSH
2537: LD_EXP 1
2541: PPUSH
2542: LD_INT 1
2544: PPUSH
2545: LD_VAR 0 4
2549: PUSH
2550: LD_INT 1
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL_OW 2
2561: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2562: LD_VAR 0 4
2566: PPUSH
2567: LD_INT 120
2569: PPUSH
2570: LD_INT 10
2572: PPUSH
2573: CALL_OW 111
// Wait ( 0 0$02 ) ;
2577: LD_INT 70
2579: PPUSH
2580: CALL_OW 67
// end ;
2584: GO 2334
2586: POP
2587: POP
// if Rand ( 0 , 1 ) = 1 then
2588: LD_INT 0
2590: PPUSH
2591: LD_INT 1
2593: PPUSH
2594: CALL_OW 12
2598: PUSH
2599: LD_INT 1
2601: EQUAL
2602: IFFALSE 2638
// begin vc_chassis := ru_medium_tracked ;
2604: LD_ADDR_OWVAR 37
2608: PUSH
2609: LD_INT 22
2611: ST_TO_ADDR
// vc_engine := engine_combustion ;
2612: LD_ADDR_OWVAR 39
2616: PUSH
2617: LD_INT 1
2619: ST_TO_ADDR
// vc_control := control_manual ;
2620: LD_ADDR_OWVAR 38
2624: PUSH
2625: LD_INT 1
2627: ST_TO_ADDR
// vc_weapon := ru_crane ;
2628: LD_ADDR_OWVAR 40
2632: PUSH
2633: LD_INT 52
2635: ST_TO_ADDR
// end else
2636: GO 2670
// begin vc_chassis := ru_heavy_wheeled ;
2638: LD_ADDR_OWVAR 37
2642: PUSH
2643: LD_INT 23
2645: ST_TO_ADDR
// vc_engine := engine_combustion ;
2646: LD_ADDR_OWVAR 39
2650: PUSH
2651: LD_INT 1
2653: ST_TO_ADDR
// vc_control := control_manual ;
2654: LD_ADDR_OWVAR 38
2658: PUSH
2659: LD_INT 1
2661: ST_TO_ADDR
// vc_weapon := ru_bulldozer ;
2662: LD_ADDR_OWVAR 40
2666: PUSH
2667: LD_INT 53
2669: ST_TO_ADDR
// end ; vc_fuel_battery := Rand ( 50 , 99 ) ;
2670: LD_ADDR_OWVAR 41
2674: PUSH
2675: LD_INT 50
2677: PPUSH
2678: LD_INT 99
2680: PPUSH
2681: CALL_OW 12
2685: ST_TO_ADDR
// if uc_side <> 6 then
2686: LD_OWVAR 20
2690: PUSH
2691: LD_INT 6
2693: NONEQUAL
2694: IFFALSE 2704
// uc_side := 6 ;
2696: LD_ADDR_OWVAR 20
2700: PUSH
2701: LD_INT 6
2703: ST_TO_ADDR
// veh := CreateVehicle ;
2704: LD_ADDR_VAR 0 4
2708: PUSH
2709: CALL_OW 45
2713: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2714: LD_VAR 0 4
2718: PPUSH
2719: LD_INT 3
2721: PPUSH
2722: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2726: LD_VAR 0 4
2730: PPUSH
2731: LD_INT 8
2733: PPUSH
2734: LD_INT 0
2736: PPUSH
2737: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2741: LD_INT 0
2743: PPUSH
2744: LD_INT 1
2746: PPUSH
2747: LD_INT 2
2749: PPUSH
2750: CALL_OW 12
2754: PPUSH
2755: LD_VAR 0 5
2759: PPUSH
2760: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2764: CALL_OW 44
2768: PPUSH
2769: LD_VAR 0 4
2773: PPUSH
2774: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2778: LD_VAR 0 4
2782: PPUSH
2783: LD_INT 500
2785: PPUSH
2786: LD_INT 1000
2788: PPUSH
2789: CALL_OW 12
2793: PPUSH
2794: CALL_OW 234
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2798: LD_ADDR_EXP 1
2802: PUSH
2803: LD_EXP 1
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: LD_VAR 0 4
2815: PUSH
2816: LD_INT 1
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: PPUSH
2823: CALL_OW 2
2827: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2828: LD_VAR 0 4
2832: PPUSH
2833: LD_INT 120
2835: PPUSH
2836: LD_INT 10
2838: PPUSH
2839: CALL_OW 111
// Wait ( 0 0$02 ) ;
2843: LD_INT 70
2845: PPUSH
2846: CALL_OW 67
// conv_ready := true ;
2850: LD_ADDR_EXP 18
2854: PUSH
2855: LD_INT 1
2857: ST_TO_ADDR
// end ; end ;
2858: GO 2861
2860: POP
// end ;
2861: LD_VAR 0 2
2865: RET
// export function AddEscort ( ) ; var veh , skill ; begin
2866: LD_INT 0
2868: PPUSH
2869: PPUSH
2870: PPUSH
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
2871: LD_ADDR_VAR 0 3
2875: PUSH
2876: LD_INT 5
2878: PUSH
2879: LD_INT 5
2881: PUSH
2882: LD_INT 4
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: LIST
2889: PUSH
2890: LD_OWVAR 67
2894: ARRAY
2895: ST_TO_ADDR
// uc_side := 6 ;
2896: LD_ADDR_OWVAR 20
2900: PUSH
2901: LD_INT 6
2903: ST_TO_ADDR
// uc_nation := 3 ;
2904: LD_ADDR_OWVAR 21
2908: PUSH
2909: LD_INT 3
2911: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
2912: LD_ADDR_OWVAR 37
2916: PUSH
2917: LD_INT 21
2919: ST_TO_ADDR
// vc_engine := engine_combustion ;
2920: LD_ADDR_OWVAR 39
2924: PUSH
2925: LD_INT 1
2927: ST_TO_ADDR
// vc_control := control_manual ;
2928: LD_ADDR_OWVAR 38
2932: PUSH
2933: LD_INT 1
2935: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_heavy_machine_gun ] [ Rand ( 1 , 2 ) ] ;
2936: LD_ADDR_OWVAR 40
2940: PUSH
2941: LD_INT 44
2943: PUSH
2944: LD_INT 42
2946: PUSH
2947: EMPTY
2948: LIST
2949: LIST
2950: PUSH
2951: LD_INT 1
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: CALL_OW 12
2961: ARRAY
2962: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2963: LD_ADDR_OWVAR 41
2967: PUSH
2968: LD_INT 50
2970: PPUSH
2971: LD_INT 99
2973: PPUSH
2974: CALL_OW 12
2978: ST_TO_ADDR
// veh := CreateVehicle ;
2979: LD_ADDR_VAR 0 2
2983: PUSH
2984: CALL_OW 45
2988: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2989: LD_VAR 0 2
2993: PPUSH
2994: LD_INT 3
2996: PPUSH
2997: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
3001: LD_VAR 0 2
3005: PPUSH
3006: LD_INT 8
3008: PPUSH
3009: LD_INT 0
3011: PPUSH
3012: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
3016: LD_INT 0
3018: PPUSH
3019: LD_INT 3
3021: PPUSH
3022: LD_VAR 0 3
3026: PPUSH
3027: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3031: CALL_OW 44
3035: PPUSH
3036: LD_VAR 0 2
3040: PPUSH
3041: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
3045: LD_VAR 0 2
3049: PPUSH
3050: LD_INT 500
3052: PPUSH
3053: LD_INT 1000
3055: PPUSH
3056: CALL_OW 12
3060: PPUSH
3061: CALL_OW 234
// escort := Insert ( escort , 1 , veh ) ;
3065: LD_ADDR_EXP 2
3069: PUSH
3070: LD_EXP 2
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: LD_VAR 0 2
3082: PPUSH
3083: CALL_OW 2
3087: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
3088: LD_VAR 0 2
3092: PPUSH
3093: LD_INT 120
3095: PPUSH
3096: LD_INT 10
3098: PPUSH
3099: CALL_OW 111
// end ;
3103: LD_VAR 0 1
3107: RET
// every 4 trigger conv_ready and FilterAllUnits ( [ f_side , 6 ] ) do var i , j ;
3108: LD_EXP 18
3112: PUSH
3113: LD_INT 22
3115: PUSH
3116: LD_INT 6
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: PPUSH
3123: CALL_OW 69
3127: AND
3128: IFFALSE 3861
3130: GO 3132
3132: DISABLE
3133: LD_INT 0
3135: PPUSH
3136: PPUSH
// begin enable ;
3137: ENABLE
// if conv_squad then
3138: LD_EXP 1
3142: IFFALSE 3399
// for i = conv_squad downto 1 do
3144: LD_ADDR_VAR 0 1
3148: PUSH
3149: DOUBLE
3150: LD_EXP 1
3154: INC
3155: ST_TO_ADDR
3156: LD_INT 1
3158: PUSH
3159: FOR_DOWNTO
3160: IFFALSE 3397
// begin if IsInArea ( conv_squad [ i ] [ 1 ] , conv_end ) then
3162: LD_EXP 1
3166: PUSH
3167: LD_VAR 0 1
3171: ARRAY
3172: PUSH
3173: LD_INT 1
3175: ARRAY
3176: PPUSH
3177: LD_INT 9
3179: PPUSH
3180: CALL_OW 308
3184: IFFALSE 3247
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3186: LD_ADDR_VAR 0 2
3190: PUSH
3191: LD_INT 9
3193: PPUSH
3194: LD_INT 22
3196: PUSH
3197: LD_INT 6
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: PPUSH
3204: CALL_OW 70
3208: PUSH
3209: FOR_IN
3210: IFFALSE 3223
// RemoveUnit ( j ) ;
3212: LD_VAR 0 2
3216: PPUSH
3217: CALL_OW 64
3221: GO 3209
3223: POP
3224: POP
// conv_squad := Delete ( conv_squad , i ) ;
3225: LD_ADDR_EXP 1
3229: PUSH
3230: LD_EXP 1
3234: PPUSH
3235: LD_VAR 0 1
3239: PPUSH
3240: CALL_OW 3
3244: ST_TO_ADDR
// break ;
3245: GO 3397
// end ; if IsInArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) then
3247: LD_EXP 1
3251: PUSH
3252: LD_VAR 0 1
3256: ARRAY
3257: PUSH
3258: LD_INT 1
3260: ARRAY
3261: PPUSH
3262: LD_EXP 6
3266: PUSH
3267: LD_EXP 1
3271: PUSH
3272: LD_VAR 0 1
3276: ARRAY
3277: PUSH
3278: LD_INT 2
3280: ARRAY
3281: ARRAY
3282: PPUSH
3283: CALL_OW 308
3287: IFFALSE 3333
// conv_squad := Replace2 ( conv_squad , i , 2 , conv_squad [ i ] [ 2 ] + 1 ) else
3289: LD_ADDR_EXP 1
3293: PUSH
3294: LD_EXP 1
3298: PPUSH
3299: LD_VAR 0 1
3303: PPUSH
3304: LD_INT 2
3306: PPUSH
3307: LD_EXP 1
3311: PUSH
3312: LD_VAR 0 1
3316: ARRAY
3317: PUSH
3318: LD_INT 2
3320: ARRAY
3321: PUSH
3322: LD_INT 1
3324: PLUS
3325: PPUSH
3326: CALL 10006 0 4
3330: ST_TO_ADDR
3331: GO 3395
// if not HasTask ( conv_squad [ i ] [ 1 ] ) then
3333: LD_EXP 1
3337: PUSH
3338: LD_VAR 0 1
3342: ARRAY
3343: PUSH
3344: LD_INT 1
3346: ARRAY
3347: PPUSH
3348: CALL_OW 314
3352: NOT
3353: IFFALSE 3395
// ComMoveToArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) ;
3355: LD_EXP 1
3359: PUSH
3360: LD_VAR 0 1
3364: ARRAY
3365: PUSH
3366: LD_INT 1
3368: ARRAY
3369: PPUSH
3370: LD_EXP 6
3374: PUSH
3375: LD_EXP 1
3379: PUSH
3380: LD_VAR 0 1
3384: ARRAY
3385: PUSH
3386: LD_INT 2
3388: ARRAY
3389: ARRAY
3390: PPUSH
3391: CALL_OW 113
// end ;
3395: GO 3159
3397: POP
3398: POP
// if escort then
3399: LD_EXP 2
3403: IFFALSE 3728
// for i = escort downto 1 do
3405: LD_ADDR_VAR 0 1
3409: PUSH
3410: DOUBLE
3411: LD_EXP 2
3415: INC
3416: ST_TO_ADDR
3417: LD_INT 1
3419: PUSH
3420: FOR_DOWNTO
3421: IFFALSE 3726
// begin if IsInArea ( escort [ i ] , conv_end ) then
3423: LD_EXP 2
3427: PUSH
3428: LD_VAR 0 1
3432: ARRAY
3433: PPUSH
3434: LD_INT 9
3436: PPUSH
3437: CALL_OW 308
3441: IFFALSE 3504
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3443: LD_ADDR_VAR 0 2
3447: PUSH
3448: LD_INT 9
3450: PPUSH
3451: LD_INT 22
3453: PUSH
3454: LD_INT 6
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 70
3465: PUSH
3466: FOR_IN
3467: IFFALSE 3480
// RemoveUnit ( j ) ;
3469: LD_VAR 0 2
3473: PPUSH
3474: CALL_OW 64
3478: GO 3466
3480: POP
3481: POP
// escort := Delete ( escort , i ) ;
3482: LD_ADDR_EXP 2
3486: PUSH
3487: LD_EXP 2
3491: PPUSH
3492: LD_VAR 0 1
3496: PPUSH
3497: CALL_OW 3
3501: ST_TO_ADDR
// break ;
3502: GO 3726
// end ; if FindTarget ( escort [ i ] ) and GetDistUnits ( escort [ i ] , FindTarget ( escort [ i ] ) ) < 13 then
3504: LD_EXP 2
3508: PUSH
3509: LD_VAR 0 1
3513: ARRAY
3514: PPUSH
3515: CALL 10314 0 1
3519: PUSH
3520: LD_EXP 2
3524: PUSH
3525: LD_VAR 0 1
3529: ARRAY
3530: PPUSH
3531: LD_EXP 2
3535: PUSH
3536: LD_VAR 0 1
3540: ARRAY
3541: PPUSH
3542: CALL 10314 0 1
3546: PPUSH
3547: CALL_OW 296
3551: PUSH
3552: LD_INT 13
3554: LESS
3555: AND
3556: IFFALSE 3591
// ComAttackUnit ( escort [ i ] , FindTarget ( escort [ i ] ) ) else
3558: LD_EXP 2
3562: PUSH
3563: LD_VAR 0 1
3567: ARRAY
3568: PPUSH
3569: LD_EXP 2
3573: PUSH
3574: LD_VAR 0 1
3578: ARRAY
3579: PPUSH
3580: CALL 10314 0 1
3584: PPUSH
3585: CALL_OW 115
3589: GO 3724
// if conv_squad and GetDistUnitXY ( escort [ i ] , 64 , 117 ) > 35 and not HasTask ( escort [ i ] ) then
3591: LD_EXP 1
3595: PUSH
3596: LD_EXP 2
3600: PUSH
3601: LD_VAR 0 1
3605: ARRAY
3606: PPUSH
3607: LD_INT 64
3609: PPUSH
3610: LD_INT 117
3612: PPUSH
3613: CALL_OW 297
3617: PUSH
3618: LD_INT 35
3620: GREATER
3621: AND
3622: PUSH
3623: LD_EXP 2
3627: PUSH
3628: LD_VAR 0 1
3632: ARRAY
3633: PPUSH
3634: CALL_OW 314
3638: NOT
3639: AND
3640: IFFALSE 3706
// begin if GetDistUnits ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) > 6 then
3642: LD_EXP 2
3646: PUSH
3647: LD_VAR 0 1
3651: ARRAY
3652: PPUSH
3653: LD_EXP 1
3657: PUSH
3658: LD_INT 1
3660: ARRAY
3661: PUSH
3662: LD_INT 1
3664: ARRAY
3665: PPUSH
3666: CALL_OW 296
3670: PUSH
3671: LD_INT 6
3673: GREATER
3674: IFFALSE 3704
// ComMoveUnit ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) end else
3676: LD_EXP 2
3680: PUSH
3681: LD_VAR 0 1
3685: ARRAY
3686: PPUSH
3687: LD_EXP 1
3691: PUSH
3692: LD_INT 1
3694: ARRAY
3695: PUSH
3696: LD_INT 1
3698: ARRAY
3699: PPUSH
3700: CALL_OW 112
3704: GO 3724
// ComMoveToArea ( escort [ i ] , conv_end ) ;
3706: LD_EXP 2
3710: PUSH
3711: LD_VAR 0 1
3715: ARRAY
3716: PPUSH
3717: LD_INT 9
3719: PPUSH
3720: CALL_OW 113
// end ;
3724: GO 3420
3726: POP
3727: POP
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) then
3728: LD_INT 22
3730: PUSH
3731: LD_INT 6
3733: PUSH
3734: EMPTY
3735: LIST
3736: LIST
3737: PUSH
3738: LD_INT 21
3740: PUSH
3741: LD_INT 1
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PPUSH
3752: CALL_OW 69
3756: IFFALSE 3861
// for j in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) do
3758: LD_ADDR_VAR 0 2
3762: PUSH
3763: LD_INT 22
3765: PUSH
3766: LD_INT 6
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: LD_INT 21
3775: PUSH
3776: LD_INT 1
3778: PUSH
3779: EMPTY
3780: LIST
3781: LIST
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: PPUSH
3787: CALL_OW 69
3791: PUSH
3792: FOR_IN
3793: IFFALSE 3859
// begin if not HasTask ( j ) and not IsInArea ( j , conv_end ) then
3795: LD_VAR 0 2
3799: PPUSH
3800: CALL_OW 314
3804: NOT
3805: PUSH
3806: LD_VAR 0 2
3810: PPUSH
3811: LD_INT 9
3813: PPUSH
3814: CALL_OW 308
3818: NOT
3819: AND
3820: IFFALSE 3834
// ComMoveToArea ( j , conv_end ) ;
3822: LD_VAR 0 2
3826: PPUSH
3827: LD_INT 9
3829: PPUSH
3830: CALL_OW 113
// if IsInArea ( j , conv_end ) then
3834: LD_VAR 0 2
3838: PPUSH
3839: LD_INT 9
3841: PPUSH
3842: CALL_OW 308
3846: IFFALSE 3857
// RemoveUnit ( j ) ;
3848: LD_VAR 0 2
3852: PPUSH
3853: CALL_OW 64
// end ;
3857: GO 3792
3859: POP
3860: POP
// end ;
3861: PPOPN 2
3863: END
// every 0 0$01 trigger UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do var i ;
3864: LD_EXP 2
3868: PUSH
3869: LD_EXP 1
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: PPUSH
3878: LD_INT 22
3880: PUSH
3881: LD_INT 3
3883: PUSH
3884: EMPTY
3885: LIST
3886: LIST
3887: PPUSH
3888: CALL_OW 72
3892: IFFALSE 3954
3894: GO 3896
3896: DISABLE
3897: LD_INT 0
3899: PPUSH
// begin enable ;
3900: ENABLE
// for i in UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do
3901: LD_ADDR_VAR 0 1
3905: PUSH
3906: LD_EXP 2
3910: PUSH
3911: LD_EXP 1
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PPUSH
3920: LD_INT 22
3922: PUSH
3923: LD_INT 3
3925: PUSH
3926: EMPTY
3927: LIST
3928: LIST
3929: PPUSH
3930: CALL_OW 72
3934: PUSH
3935: FOR_IN
3936: IFFALSE 3952
// SetSide ( i , 6 ) ;
3938: LD_VAR 0 1
3942: PPUSH
3943: LD_INT 6
3945: PPUSH
3946: CALL_OW 235
3950: GO 3935
3952: POP
3953: POP
// end ; end_of_file
3954: PPOPN 1
3956: END
// export Collins ; export us_alert , us_retreat , us_patrol , us_count ; export function PrepareAmerican ; var i , un , skill , towers ; begin
3957: LD_INT 0
3959: PPUSH
3960: PPUSH
3961: PPUSH
3962: PPUSH
3963: PPUSH
// uc_side := 1 ;
3964: LD_ADDR_OWVAR 20
3968: PUSH
3969: LD_INT 1
3971: ST_TO_ADDR
// uc_nation := 1 ;
3972: LD_ADDR_OWVAR 21
3976: PUSH
3977: LD_INT 1
3979: ST_TO_ADDR
// us_alert := false ;
3980: LD_ADDR_EXP 20
3984: PUSH
3985: LD_INT 0
3987: ST_TO_ADDR
// us_retreat := false ;
3988: LD_ADDR_EXP 21
3992: PUSH
3993: LD_INT 0
3995: ST_TO_ADDR
// us_patrol := false ;
3996: LD_ADDR_EXP 22
4000: PUSH
4001: LD_INT 0
4003: ST_TO_ADDR
// us_count := 0 ;
4004: LD_ADDR_EXP 23
4008: PUSH
4009: LD_INT 0
4011: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4012: LD_ADDR_VAR 0 4
4016: PUSH
4017: LD_INT 5
4019: PUSH
4020: LD_INT 6
4022: PUSH
4023: LD_INT 7
4025: PUSH
4026: EMPTY
4027: LIST
4028: LIST
4029: LIST
4030: PUSH
4031: LD_OWVAR 67
4035: ARRAY
4036: ST_TO_ADDR
// hc_class := 1 ;
4037: LD_ADDR_OWVAR 28
4041: PUSH
4042: LD_INT 1
4044: ST_TO_ADDR
// hc_sex := sex_male ;
4045: LD_ADDR_OWVAR 27
4049: PUSH
4050: LD_INT 1
4052: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
4053: LD_ADDR_OWVAR 31
4057: PUSH
4058: LD_INT 6
4060: PUSH
4061: LD_INT 3
4063: PUSH
4064: LD_INT 4
4066: PUSH
4067: LD_INT 2
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: LIST
4074: LIST
4075: ST_TO_ADDR
// hc_name := Jack Collins ;
4076: LD_ADDR_OWVAR 26
4080: PUSH
4081: LD_STRING Jack Collins
4083: ST_TO_ADDR
// hc_attr := [ 11 , 11 ] ;
4084: LD_ADDR_OWVAR 29
4088: PUSH
4089: LD_INT 11
4091: PUSH
4092: LD_INT 11
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: ST_TO_ADDR
// hc_gallery :=  ;
4099: LD_ADDR_OWVAR 33
4103: PUSH
4104: LD_STRING 
4106: ST_TO_ADDR
// Collins := CreateHuman ;
4107: LD_ADDR_EXP 19
4111: PUSH
4112: CALL_OW 44
4116: ST_TO_ADDR
// PlaceHumanInUnit ( Collins , us_depot ) ;
4117: LD_EXP 19
4121: PPUSH
4122: LD_INT 50
4124: PPUSH
4125: CALL_OW 52
// hc_name :=  ;
4129: LD_ADDR_OWVAR 26
4133: PUSH
4134: LD_STRING 
4136: ST_TO_ADDR
// if Difficulty > 1 then
4137: LD_OWVAR 67
4141: PUSH
4142: LD_INT 1
4144: GREATER
4145: IFFALSE 4199
// begin bc_type := b_bunker ;
4147: LD_ADDR_OWVAR 42
4151: PUSH
4152: LD_INT 32
4154: ST_TO_ADDR
// bc_level := 5 ;
4155: LD_ADDR_OWVAR 43
4159: PUSH
4160: LD_INT 5
4162: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 40 , 33 , 2 ) ;
4163: LD_INT 40
4165: PPUSH
4166: LD_INT 33
4168: PPUSH
4169: LD_INT 2
4171: PPUSH
4172: CALL_OW 47
// if Difficulty > 2 then
4176: LD_OWVAR 67
4180: PUSH
4181: LD_INT 2
4183: GREATER
4184: IFFALSE 4199
// CreateAndPlaceBuildingXYD ( 41 , 42 , 0 ) ;
4186: LD_INT 41
4188: PPUSH
4189: LD_INT 42
4191: PPUSH
4192: LD_INT 0
4194: PPUSH
4195: CALL_OW 47
// end ; PrepareHuman ( false , 2 , skill ) ;
4199: LD_INT 0
4201: PPUSH
4202: LD_INT 2
4204: PPUSH
4205: LD_VAR 0 4
4209: PPUSH
4210: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
4214: CALL_OW 44
4218: PPUSH
4219: LD_INT 50
4221: PPUSH
4222: CALL_OW 52
// PrepareHuman ( false , 3 , skill ) ;
4226: LD_INT 0
4228: PPUSH
4229: LD_INT 3
4231: PPUSH
4232: LD_VAR 0 4
4236: PPUSH
4237: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4241: CALL_OW 44
4245: PPUSH
4246: LD_INT 56
4248: PPUSH
4249: CALL_OW 52
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4253: CALL_OW 44
4257: PPUSH
4258: LD_INT 56
4260: PPUSH
4261: CALL_OW 52
// PrepareHuman ( false , 4 , skill ) ;
4265: LD_INT 0
4267: PPUSH
4268: LD_INT 4
4270: PPUSH
4271: LD_VAR 0 4
4275: PPUSH
4276: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
4280: CALL_OW 44
4284: PPUSH
4285: LD_INT 63
4287: PPUSH
4288: CALL_OW 52
// PrepareHuman ( false , 1 , skill ) ;
4292: LD_INT 0
4294: PPUSH
4295: LD_INT 1
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: CALL_OW 380
// un := CreateHuman ;
4307: LD_ADDR_VAR 0 3
4311: PUSH
4312: CALL_OW 44
4316: ST_TO_ADDR
// SetDir ( un , 4 ) ;
4317: LD_VAR 0 3
4321: PPUSH
4322: LD_INT 4
4324: PPUSH
4325: CALL_OW 233
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
4329: LD_VAR 0 3
4333: PPUSH
4334: LD_INT 22
4336: PUSH
4337: LD_INT 1
4339: PUSH
4340: EMPTY
4341: LIST
4342: LIST
4343: PUSH
4344: LD_INT 30
4346: PUSH
4347: LD_INT 31
4349: PUSH
4350: EMPTY
4351: LIST
4352: LIST
4353: PUSH
4354: EMPTY
4355: LIST
4356: LIST
4357: PPUSH
4358: CALL_OW 69
4362: PUSH
4363: LD_INT 1
4365: ARRAY
4366: PPUSH
4367: CALL_OW 52
// towers := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) ;
4371: LD_ADDR_VAR 0 5
4375: PUSH
4376: LD_INT 22
4378: PUSH
4379: LD_INT 1
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: PUSH
4386: LD_INT 30
4388: PUSH
4389: LD_INT 32
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: PPUSH
4400: CALL_OW 69
4404: ST_TO_ADDR
// for i in towers do
4405: LD_ADDR_VAR 0 2
4409: PUSH
4410: LD_VAR 0 5
4414: PUSH
4415: FOR_IN
4416: IFFALSE 4484
// begin PrepareHuman ( false , 1 , skill ) ;
4418: LD_INT 0
4420: PPUSH
4421: LD_INT 1
4423: PPUSH
4424: LD_VAR 0 4
4428: PPUSH
4429: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4433: CALL_OW 44
4437: PPUSH
4438: LD_VAR 0 2
4442: PPUSH
4443: CALL_OW 52
// PlaceWeaponTurret ( i , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
4447: LD_VAR 0 2
4451: PPUSH
4452: LD_INT 4
4454: PUSH
4455: LD_INT 3
4457: PUSH
4458: LD_INT 5
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: LIST
4465: PUSH
4466: LD_INT 1
4468: PPUSH
4469: LD_INT 3
4471: PPUSH
4472: CALL_OW 12
4476: ARRAY
4477: PPUSH
4478: CALL_OW 431
// end ;
4482: GO 4415
4484: POP
4485: POP
// PrepareHuman ( false , 1 , skill ) ;
4486: LD_INT 0
4488: PPUSH
4489: LD_INT 1
4491: PPUSH
4492: LD_VAR 0 4
4496: PPUSH
4497: CALL_OW 380
// us_patrol := CreateHuman ;
4501: LD_ADDR_EXP 22
4505: PUSH
4506: CALL_OW 44
4510: ST_TO_ADDR
// PlaceUnitXY ( us_patrol , 12 , 5 , false ) ;
4511: LD_EXP 22
4515: PPUSH
4516: LD_INT 12
4518: PPUSH
4519: LD_INT 5
4521: PPUSH
4522: LD_INT 0
4524: PPUSH
4525: CALL_OW 48
// end ;
4529: LD_VAR 0 1
4533: RET
// every 0 0$01 trigger us_count >= [ 3 , 4 , 5 ] [ Difficulty ] do
4534: LD_EXP 23
4538: PUSH
4539: LD_INT 3
4541: PUSH
4542: LD_INT 4
4544: PUSH
4545: LD_INT 5
4547: PUSH
4548: EMPTY
4549: LIST
4550: LIST
4551: LIST
4552: PUSH
4553: LD_OWVAR 67
4557: ARRAY
4558: GREATEREQUAL
4559: IFFALSE 4584
4561: GO 4563
4563: DISABLE
// begin Say ( Collins , DPM_C2 ) ;
4564: LD_EXP 19
4568: PPUSH
4569: LD_STRING DPM_C2
4571: PPUSH
4572: CALL_OW 88
// us_retreat := true ;
4576: LD_ADDR_EXP 21
4580: PUSH
4581: LD_INT 1
4583: ST_TO_ADDR
// end ;
4584: END
// every 10 10$00 trigger not us_alert do var R ;
4585: LD_EXP 20
4589: NOT
4590: IFFALSE 4664
4592: GO 4594
4594: DISABLE
4595: LD_INT 0
4597: PPUSH
// begin uc_side := 1 ;
4598: LD_ADDR_OWVAR 20
4602: PUSH
4603: LD_INT 1
4605: ST_TO_ADDR
// uc_nation := 1 ;
4606: LD_ADDR_OWVAR 21
4610: PUSH
4611: LD_INT 1
4613: ST_TO_ADDR
// PrepareHuman ( false , 1 , 0 ) ;
4614: LD_INT 0
4616: PPUSH
4617: LD_INT 1
4619: PPUSH
4620: LD_INT 0
4622: PPUSH
4623: CALL_OW 380
// R := CreateHuman ;
4627: LD_ADDR_VAR 0 1
4631: PUSH
4632: CALL_OW 44
4636: ST_TO_ADDR
// SayRadio ( R , DPM_R1 ) ;
4637: LD_VAR 0 1
4641: PPUSH
4642: LD_STRING DPM_R1
4644: PPUSH
4645: CALL_OW 94
// Wait ( 0 0$03 ) ;
4649: LD_INT 105
4651: PPUSH
4652: CALL_OW 67
// us_retreat := true ;
4656: LD_ADDR_EXP 21
4660: PUSH
4661: LD_INT 1
4663: ST_TO_ADDR
// end ;
4664: PPOPN 1
4666: END
// every 0 0$01 trigger us_alert do var i ;
4667: LD_EXP 20
4671: IFFALSE 4931
4673: GO 4675
4675: DISABLE
4676: LD_INT 0
4678: PPUSH
// begin Say ( Collins , DPM_C1 ) ;
4679: LD_EXP 19
4683: PPUSH
4684: LD_STRING DPM_C1
4686: PPUSH
4687: CALL_OW 88
// if UnitsInside ( us_fac ) then
4691: LD_INT 56
4693: PPUSH
4694: CALL_OW 313
4698: IFFALSE 4753
// for i in UnitsInside ( us_fac ) do
4700: LD_ADDR_VAR 0 1
4704: PUSH
4705: LD_INT 56
4707: PPUSH
4708: CALL_OW 313
4712: PUSH
4713: FOR_IN
4714: IFFALSE 4751
// begin ComExitBuilding ( i ) ;
4716: LD_VAR 0 1
4720: PPUSH
4721: CALL_OW 122
// AddComEnterUnit ( i , us_arm ) ;
4725: LD_VAR 0 1
4729: PPUSH
4730: LD_INT 69
4732: PPUSH
4733: CALL_OW 180
// AddComChangeProfession ( i , 1 ) ;
4737: LD_VAR 0 1
4741: PPUSH
4742: LD_INT 1
4744: PPUSH
4745: CALL_OW 183
// end ;
4749: GO 4713
4751: POP
4752: POP
// ComExitBuilding ( Collins ) ;
4753: LD_EXP 19
4757: PPUSH
4758: CALL_OW 122
// AddComEnterUnit ( Collins , us_arm ) ;
4762: LD_EXP 19
4766: PPUSH
4767: LD_INT 69
4769: PPUSH
4770: CALL_OW 180
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] ) ;
4774: LD_INT 22
4776: PUSH
4777: LD_INT 1
4779: PUSH
4780: EMPTY
4781: LIST
4782: LIST
4783: PUSH
4784: LD_INT 25
4786: PUSH
4787: LD_INT 2
4789: PUSH
4790: EMPTY
4791: LIST
4792: LIST
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: PPUSH
4798: CALL_OW 69
4802: PUSH
4803: LD_INT 1
4805: ARRAY
4806: PPUSH
4807: CALL_OW 122
// AddComMoveXY ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , 67 , 52 ) ;
4811: LD_INT 22
4813: PUSH
4814: LD_INT 1
4816: PUSH
4817: EMPTY
4818: LIST
4819: LIST
4820: PUSH
4821: LD_INT 25
4823: PUSH
4824: LD_INT 2
4826: PUSH
4827: EMPTY
4828: LIST
4829: LIST
4830: PUSH
4831: EMPTY
4832: LIST
4833: LIST
4834: PPUSH
4835: CALL_OW 69
4839: PUSH
4840: LD_INT 1
4842: ARRAY
4843: PPUSH
4844: LD_INT 67
4846: PPUSH
4847: LD_INT 52
4849: PPUSH
4850: CALL_OW 171
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] ) ;
4854: LD_INT 22
4856: PUSH
4857: LD_INT 1
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: PUSH
4864: LD_INT 25
4866: PUSH
4867: LD_INT 4
4869: PUSH
4870: EMPTY
4871: LIST
4872: LIST
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PPUSH
4878: CALL_OW 69
4882: PUSH
4883: LD_INT 1
4885: ARRAY
4886: PPUSH
4887: CALL_OW 122
// AddComEnterUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] , us_arm ) ;
4891: LD_INT 22
4893: PUSH
4894: LD_INT 1
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: PUSH
4901: LD_INT 25
4903: PUSH
4904: LD_INT 4
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PPUSH
4915: CALL_OW 69
4919: PUSH
4920: LD_INT 1
4922: ARRAY
4923: PPUSH
4924: LD_INT 69
4926: PPUSH
4927: CALL_OW 180
// end ;
4931: PPOPN 1
4933: END
// every 3 3$00 trigger not us_alert and GetSide ( us_fac ) = 1 do
4934: LD_EXP 20
4938: NOT
4939: PUSH
4940: LD_INT 56
4942: PPUSH
4943: CALL_OW 255
4947: PUSH
4948: LD_INT 1
4950: EQUAL
4951: AND
4952: IFFALSE 4995
4954: GO 4956
4956: DISABLE
// begin AddComConstruct ( us_fac , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun ) ;
4957: LD_INT 56
4959: PPUSH
4960: LD_INT 2
4962: PPUSH
4963: LD_INT 1
4965: PPUSH
4966: LD_INT 1
4968: PPUSH
4969: LD_INT 4
4971: PPUSH
4972: CALL_OW 185
// AddComConstruct ( us_fac , us_medium_tracked , engine_solar , control_manual , us_double_gun ) ;
4976: LD_INT 56
4978: PPUSH
4979: LD_INT 3
4981: PPUSH
4982: LD_INT 2
4984: PPUSH
4985: LD_INT 1
4987: PPUSH
4988: LD_INT 5
4990: PPUSH
4991: CALL_OW 185
// end ;
4995: END
// every 0 0$01 trigger us_patrol do
4996: LD_EXP 22
5000: IFFALSE 5048
5002: GO 5004
5004: DISABLE
// SetPatrol ( us_patrol , [ 12 , 5 , 56 , 4 , 94 , 34 , 92 , 108 ] ) ;
5005: LD_EXP 22
5009: PPUSH
5010: LD_INT 12
5012: PUSH
5013: LD_INT 5
5015: PUSH
5016: LD_INT 56
5018: PUSH
5019: LD_INT 4
5021: PUSH
5022: LD_INT 94
5024: PUSH
5025: LD_INT 34
5027: PUSH
5028: LD_INT 92
5030: PUSH
5031: LD_INT 108
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: LIST
5038: LIST
5039: LIST
5040: LIST
5041: LIST
5042: LIST
5043: PPUSH
5044: CALL 5049 0 2
5048: END
// export function SetPatrol ( un , points ) ; var s , i , turn ; begin
5049: LD_INT 0
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
// s = 1 ;
5055: LD_ADDR_VAR 0 4
5059: PUSH
5060: LD_INT 1
5062: ST_TO_ADDR
// turn := true ;
5063: LD_ADDR_VAR 0 6
5067: PUSH
5068: LD_INT 1
5070: ST_TO_ADDR
// while ( un and not us_alert ) do
5071: LD_VAR 0 1
5075: PUSH
5076: LD_EXP 20
5080: NOT
5081: AND
5082: IFFALSE 5261
// begin wait ( 35 ) ;
5084: LD_INT 35
5086: PPUSH
5087: CALL_OW 67
// if not HasTask ( un ) then
5091: LD_VAR 0 1
5095: PPUSH
5096: CALL_OW 314
5100: NOT
5101: IFFALSE 5220
// begin ComMoveXY ( un , points [ s ] , points [ s + 1 ] ) ;
5103: LD_VAR 0 1
5107: PPUSH
5108: LD_VAR 0 2
5112: PUSH
5113: LD_VAR 0 4
5117: ARRAY
5118: PPUSH
5119: LD_VAR 0 2
5123: PUSH
5124: LD_VAR 0 4
5128: PUSH
5129: LD_INT 1
5131: PLUS
5132: ARRAY
5133: PPUSH
5134: CALL_OW 111
// if s + 2 > points then
5138: LD_VAR 0 4
5142: PUSH
5143: LD_INT 2
5145: PLUS
5146: PUSH
5147: LD_VAR 0 2
5151: GREATER
5152: IFFALSE 5162
// turn := false ;
5154: LD_ADDR_VAR 0 6
5158: PUSH
5159: LD_INT 0
5161: ST_TO_ADDR
// if s - 2 < 1 then
5162: LD_VAR 0 4
5166: PUSH
5167: LD_INT 2
5169: MINUS
5170: PUSH
5171: LD_INT 1
5173: LESS
5174: IFFALSE 5184
// turn := true ;
5176: LD_ADDR_VAR 0 6
5180: PUSH
5181: LD_INT 1
5183: ST_TO_ADDR
// if turn then
5184: LD_VAR 0 6
5188: IFFALSE 5206
// s := s + 2 else
5190: LD_ADDR_VAR 0 4
5194: PUSH
5195: LD_VAR 0 4
5199: PUSH
5200: LD_INT 2
5202: PLUS
5203: ST_TO_ADDR
5204: GO 5220
// s := s - 2 ;
5206: LD_ADDR_VAR 0 4
5210: PUSH
5211: LD_VAR 0 4
5215: PUSH
5216: LD_INT 2
5218: MINUS
5219: ST_TO_ADDR
// end ; if GetLives ( un ) < 1000 or See ( 3 , un ) then
5220: LD_VAR 0 1
5224: PPUSH
5225: CALL_OW 256
5229: PUSH
5230: LD_INT 1000
5232: LESS
5233: PUSH
5234: LD_INT 3
5236: PPUSH
5237: LD_VAR 0 1
5241: PPUSH
5242: CALL_OW 292
5246: OR
5247: IFFALSE 5259
// begin us_alert := true ;
5249: LD_ADDR_EXP 20
5253: PUSH
5254: LD_INT 1
5256: ST_TO_ADDR
// break ;
5257: GO 5261
// end ; end ;
5259: GO 5071
// ComEnterUnit ( un , us_arm ) ;
5261: LD_VAR 0 1
5265: PPUSH
5266: LD_INT 69
5268: PPUSH
5269: CALL_OW 120
// end ;
5273: LD_VAR 0 3
5277: RET
// every 0 0$01 trigger us_retreat do var i , point ;
5278: LD_EXP 21
5282: IFFALSE 5457
5284: GO 5286
5286: DISABLE
5287: LD_INT 0
5289: PPUSH
5290: PPUSH
// begin point := false ;
5291: LD_ADDR_VAR 0 2
5295: PUSH
5296: LD_INT 0
5298: ST_TO_ADDR
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5299: LD_INT 5
5301: PPUSH
5302: LD_INT 22
5304: PUSH
5305: LD_INT 3
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: PPUSH
5312: CALL_OW 70
5316: PUSH
5317: LD_INT 0
5319: EQUAL
5320: IFFALSE 5332
// point := us_ret1 else
5322: LD_ADDR_VAR 0 2
5326: PUSH
5327: LD_INT 3
5329: ST_TO_ADDR
5330: GO 5373
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5332: LD_INT 5
5334: PPUSH
5335: LD_INT 22
5337: PUSH
5338: LD_INT 3
5340: PUSH
5341: EMPTY
5342: LIST
5343: LIST
5344: PPUSH
5345: CALL_OW 70
5349: PUSH
5350: LD_INT 0
5352: EQUAL
5353: IFFALSE 5365
// point := us_ret2 else
5355: LD_ADDR_VAR 0 2
5359: PUSH
5360: LD_INT 2
5362: ST_TO_ADDR
5363: GO 5373
// point := us_ret3 ;
5365: LD_ADDR_VAR 0 2
5369: PUSH
5370: LD_INT 4
5372: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
5373: LD_ADDR_VAR 0 1
5377: PUSH
5378: LD_INT 22
5380: PUSH
5381: LD_INT 1
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: PUSH
5388: LD_INT 21
5390: PUSH
5391: LD_INT 1
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: PUSH
5398: EMPTY
5399: LIST
5400: LIST
5401: PPUSH
5402: CALL_OW 69
5406: PUSH
5407: FOR_IN
5408: IFFALSE 5455
// begin if IsInUnit ( i ) then
5410: LD_VAR 0 1
5414: PPUSH
5415: CALL_OW 310
5419: IFFALSE 5439
// begin ComExitBuilding ( i ) ;
5421: LD_VAR 0 1
5425: PPUSH
5426: CALL_OW 122
// ComExitVehicle ( i ) ;
5430: LD_VAR 0 1
5434: PPUSH
5435: CALL_OW 121
// end ; AddComMoveToArea ( i , point ) ;
5439: LD_VAR 0 1
5443: PPUSH
5444: LD_VAR 0 2
5448: PPUSH
5449: CALL_OW 173
// end ;
5453: GO 5407
5455: POP
5456: POP
// end ;
5457: PPOPN 2
5459: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) do
5460: LD_EXP 21
5464: PUSH
5465: LD_INT 3
5467: PPUSH
5468: LD_INT 22
5470: PUSH
5471: LD_INT 1
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: PPUSH
5478: CALL_OW 70
5482: AND
5483: IFFALSE 5529
5485: GO 5487
5487: DISABLE
// begin enable ;
5488: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) [ 1 ] ) ;
5489: LD_INT 3
5491: PPUSH
5492: LD_INT 22
5494: PUSH
5495: LD_INT 1
5497: PUSH
5498: EMPTY
5499: LIST
5500: LIST
5501: PPUSH
5502: CALL_OW 70
5506: PUSH
5507: LD_INT 1
5509: ARRAY
5510: PPUSH
5511: CALL_OW 64
// if medal1 then
5515: LD_EXP 3
5519: IFFALSE 5529
// medal1 := false ;
5521: LD_ADDR_EXP 3
5525: PUSH
5526: LD_INT 0
5528: ST_TO_ADDR
// end ;
5529: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) do
5530: LD_EXP 21
5534: PUSH
5535: LD_INT 2
5537: PPUSH
5538: LD_INT 22
5540: PUSH
5541: LD_INT 1
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: PPUSH
5548: CALL_OW 70
5552: AND
5553: IFFALSE 5599
5555: GO 5557
5557: DISABLE
// begin enable ;
5558: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) [ 1 ] ) ;
5559: LD_INT 2
5561: PPUSH
5562: LD_INT 22
5564: PUSH
5565: LD_INT 1
5567: PUSH
5568: EMPTY
5569: LIST
5570: LIST
5571: PPUSH
5572: CALL_OW 70
5576: PUSH
5577: LD_INT 1
5579: ARRAY
5580: PPUSH
5581: CALL_OW 64
// if medal1 then
5585: LD_EXP 3
5589: IFFALSE 5599
// medal1 := false ;
5591: LD_ADDR_EXP 3
5595: PUSH
5596: LD_INT 0
5598: ST_TO_ADDR
// end ;
5599: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) do
5600: LD_EXP 21
5604: PUSH
5605: LD_INT 4
5607: PPUSH
5608: LD_INT 22
5610: PUSH
5611: LD_INT 1
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PPUSH
5618: CALL_OW 70
5622: AND
5623: IFFALSE 5669
5625: GO 5627
5627: DISABLE
// begin enable ;
5628: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) [ 1 ] ) ;
5629: LD_INT 4
5631: PPUSH
5632: LD_INT 22
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: PPUSH
5642: CALL_OW 70
5646: PUSH
5647: LD_INT 1
5649: ARRAY
5650: PPUSH
5651: CALL_OW 64
// if medal1 then
5655: LD_EXP 3
5659: IFFALSE 5669
// medal1 := false ;
5661: LD_ADDR_EXP 3
5665: PUSH
5666: LD_INT 0
5668: ST_TO_ADDR
// end ;
5669: END
// every 0 0$03 trigger FilterAllUnits ( [ f_side , 1 ] ) = 0 do
5670: LD_INT 22
5672: PUSH
5673: LD_INT 1
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: PPUSH
5680: CALL_OW 69
5684: PUSH
5685: LD_INT 0
5687: EQUAL
5688: IFFALSE 5701
5690: GO 5692
5692: DISABLE
// us_retreat := false ;
5693: LD_ADDR_EXP 21
5697: PUSH
5698: LD_INT 0
5700: ST_TO_ADDR
5701: END
// export function CounterAttack ; var i , j , un , skill ; begin
5702: LD_INT 0
5704: PPUSH
5705: PPUSH
5706: PPUSH
5707: PPUSH
5708: PPUSH
// uc_side := 1 ;
5709: LD_ADDR_OWVAR 20
5713: PUSH
5714: LD_INT 1
5716: ST_TO_ADDR
// uc_nation := 1 ;
5717: LD_ADDR_OWVAR 21
5721: PUSH
5722: LD_INT 1
5724: ST_TO_ADDR
// skill := [ 4 , 5 , 5 ] [ Difficulty ] ;
5725: LD_ADDR_VAR 0 5
5729: PUSH
5730: LD_INT 4
5732: PUSH
5733: LD_INT 5
5735: PUSH
5736: LD_INT 5
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_OWVAR 67
5748: ARRAY
5749: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
5750: LD_ADDR_VAR 0 2
5754: PUSH
5755: DOUBLE
5756: LD_INT 1
5758: DEC
5759: ST_TO_ADDR
5760: LD_INT 4
5762: PUSH
5763: LD_INT 5
5765: PUSH
5766: LD_INT 6
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: PUSH
5774: LD_OWVAR 67
5778: ARRAY
5779: PUSH
5780: FOR_TO
5781: IFFALSE 5981
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 3 ) ] ;
5783: LD_ADDR_OWVAR 37
5787: PUSH
5788: LD_INT 2
5790: PUSH
5791: LD_INT 3
5793: PUSH
5794: LD_INT 4
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: LIST
5801: PUSH
5802: LD_INT 1
5804: PPUSH
5805: LD_INT 3
5807: PPUSH
5808: CALL_OW 12
5812: ARRAY
5813: ST_TO_ADDR
// vc_engine := engine_combustion ;
5814: LD_ADDR_OWVAR 39
5818: PUSH
5819: LD_INT 1
5821: ST_TO_ADDR
// vc_control := control_manual ;
5822: LD_ADDR_OWVAR 38
5826: PUSH
5827: LD_INT 1
5829: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_light_gun ] [ Rand ( 1 , 3 ) ] ;
5830: LD_ADDR_OWVAR 40
5834: PUSH
5835: LD_INT 4
5837: PUSH
5838: LD_INT 5
5840: PUSH
5841: LD_INT 3
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 1
5851: PPUSH
5852: LD_INT 3
5854: PPUSH
5855: CALL_OW 12
5859: ARRAY
5860: ST_TO_ADDR
// vc_fuel_battery := Rand ( 88 , 99 ) ;
5861: LD_ADDR_OWVAR 41
5865: PUSH
5866: LD_INT 88
5868: PPUSH
5869: LD_INT 99
5871: PPUSH
5872: CALL_OW 12
5876: ST_TO_ADDR
// un := CreateVehicle ;
5877: LD_ADDR_VAR 0 4
5881: PUSH
5882: CALL_OW 45
5886: ST_TO_ADDR
// PlaceUnitXY ( un , 64 , 117 , false ) ;
5887: LD_VAR 0 4
5891: PPUSH
5892: LD_INT 64
5894: PPUSH
5895: LD_INT 117
5897: PPUSH
5898: LD_INT 0
5900: PPUSH
5901: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
5905: LD_INT 0
5907: PPUSH
5908: LD_INT 3
5910: PPUSH
5911: LD_VAR 0 5
5915: PPUSH
5916: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5920: CALL_OW 44
5924: PPUSH
5925: LD_VAR 0 4
5929: PPUSH
5930: CALL_OW 52
// us_force := Insert ( us_force , 1 , un ) ;
5934: LD_ADDR_EXP 12
5938: PUSH
5939: LD_EXP 12
5943: PPUSH
5944: LD_INT 1
5946: PPUSH
5947: LD_VAR 0 4
5951: PPUSH
5952: CALL_OW 2
5956: ST_TO_ADDR
// ComMoveXY ( un , 60 , 109 ) ;
5957: LD_VAR 0 4
5961: PPUSH
5962: LD_INT 60
5964: PPUSH
5965: LD_INT 109
5967: PPUSH
5968: CALL_OW 111
// Wait ( 0 0$02 ) ;
5972: LD_INT 70
5974: PPUSH
5975: CALL_OW 67
// end ;
5979: GO 5780
5981: POP
5982: POP
// while ( FilterAllUnits ( [ f_side , 1 ] ) ) do
5983: LD_INT 22
5985: PUSH
5986: LD_INT 1
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: PPUSH
5993: CALL_OW 69
5997: IFFALSE 6198
// begin Wait ( 0 0$01 ) ;
5999: LD_INT 35
6001: PPUSH
6002: CALL_OW 67
// for i = 1 to us_force do
6006: LD_ADDR_VAR 0 2
6010: PUSH
6011: DOUBLE
6012: LD_INT 1
6014: DEC
6015: ST_TO_ADDR
6016: LD_EXP 12
6020: PUSH
6021: FOR_TO
6022: IFFALSE 6057
// ComAttackUnit ( us_force [ i ] , FindTarget ( us_force [ i ] ) ) ;
6024: LD_EXP 12
6028: PUSH
6029: LD_VAR 0 2
6033: ARRAY
6034: PPUSH
6035: LD_EXP 12
6039: PUSH
6040: LD_VAR 0 2
6044: ARRAY
6045: PPUSH
6046: CALL 10314 0 1
6050: PPUSH
6051: CALL_OW 115
6055: GO 6021
6057: POP
6058: POP
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) then
6059: LD_INT 22
6061: PUSH
6062: LD_INT 1
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: PUSH
6069: LD_INT 25
6071: PUSH
6072: LD_INT 3
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: PUSH
6079: LD_INT 3
6081: PUSH
6082: LD_INT 55
6084: PUSH
6085: EMPTY
6086: LIST
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: LIST
6096: PPUSH
6097: CALL_OW 69
6101: IFFALSE 6196
// for j in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) do
6103: LD_ADDR_VAR 0 3
6107: PUSH
6108: LD_INT 22
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: PUSH
6118: LD_INT 25
6120: PUSH
6121: LD_INT 3
6123: PUSH
6124: EMPTY
6125: LIST
6126: LIST
6127: PUSH
6128: LD_INT 3
6130: PUSH
6131: LD_INT 55
6133: PUSH
6134: EMPTY
6135: LIST
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: LIST
6145: PPUSH
6146: CALL_OW 69
6150: PUSH
6151: FOR_IN
6152: IFFALSE 6194
// if not IsInArea ( j , conv_end ) then
6154: LD_VAR 0 3
6158: PPUSH
6159: LD_INT 9
6161: PPUSH
6162: CALL_OW 308
6166: NOT
6167: IFFALSE 6183
// ComMoveToArea ( j , conv_end ) else
6169: LD_VAR 0 3
6173: PPUSH
6174: LD_INT 9
6176: PPUSH
6177: CALL_OW 113
6181: GO 6192
// RemoveUnit ( j ) ;
6183: LD_VAR 0 3
6187: PPUSH
6188: CALL_OW 64
6192: GO 6151
6194: POP
6195: POP
// end ;
6196: GO 5983
// end ; end_of_file
6198: LD_VAR 0 1
6202: RET
// export function PrepareArabian ; begin
6203: LD_INT 0
6205: PPUSH
// RobertFarmer ;
6206: CALL 6227 0 0
// PrepareHovercrafts ;
6210: CALL 7097 0 0
// ar_attacks := true ;
6214: LD_ADDR_EXP 10
6218: PUSH
6219: LD_INT 1
6221: ST_TO_ADDR
// end ;
6222: LD_VAR 0 1
6226: RET
// export Farmer ; export function RobertFarmer ; begin
6227: LD_INT 0
6229: PPUSH
// uc_side := 2 ;
6230: LD_ADDR_OWVAR 20
6234: PUSH
6235: LD_INT 2
6237: ST_TO_ADDR
// uc_nation := 2 ;
6238: LD_ADDR_OWVAR 21
6242: PUSH
6243: LD_INT 2
6245: ST_TO_ADDR
// Farmer := NewCharacter ( Farmer ) ;
6246: LD_ADDR_EXP 24
6250: PUSH
6251: LD_STRING Farmer
6253: PPUSH
6254: CALL_OW 25
6258: ST_TO_ADDR
// SayRadio ( Farmer , DPM_F1 ) ;
6259: LD_EXP 24
6263: PPUSH
6264: LD_STRING DPM_F1
6266: PPUSH
6267: CALL_OW 94
// end ;
6271: LD_VAR 0 1
6275: RET
// export function PrepareAttack ( type ) ; var i , un , veh , skill ; begin
6276: LD_INT 0
6278: PPUSH
6279: PPUSH
6280: PPUSH
6281: PPUSH
6282: PPUSH
// uc_side := 2 ;
6283: LD_ADDR_OWVAR 20
6287: PUSH
6288: LD_INT 2
6290: ST_TO_ADDR
// uc_nation := 2 ;
6291: LD_ADDR_OWVAR 21
6295: PUSH
6296: LD_INT 2
6298: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
6299: LD_ADDR_VAR 0 6
6303: PUSH
6304: LD_INT 4
6306: PUSH
6307: LD_INT 5
6309: PUSH
6310: LD_INT 6
6312: PUSH
6313: EMPTY
6314: LIST
6315: LIST
6316: LIST
6317: PUSH
6318: LD_OWVAR 67
6322: ARRAY
6323: ST_TO_ADDR
// Randomize ;
6324: CALL_OW 10
// case type of 1 :
6328: LD_VAR 0 1
6332: PUSH
6333: LD_INT 1
6335: DOUBLE
6336: EQUAL
6337: IFTRUE 6341
6339: GO 6463
6341: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
6342: LD_ADDR_VAR 0 3
6346: PUSH
6347: DOUBLE
6348: LD_INT 1
6350: DEC
6351: ST_TO_ADDR
6352: LD_INT 3
6354: PUSH
6355: LD_INT 4
6357: PUSH
6358: LD_INT 5
6360: PUSH
6361: EMPTY
6362: LIST
6363: LIST
6364: LIST
6365: PUSH
6366: LD_OWVAR 67
6370: ARRAY
6371: PUSH
6372: FOR_TO
6373: IFFALSE 6459
// begin PrepareHuman ( false , [ class_soldier , class_soldier , class_mortar ] [ Rand ( 1 , 3 ) ] , skill ) ;
6375: LD_INT 0
6377: PPUSH
6378: LD_INT 1
6380: PUSH
6381: LD_INT 1
6383: PUSH
6384: LD_INT 8
6386: PUSH
6387: EMPTY
6388: LIST
6389: LIST
6390: LIST
6391: PUSH
6392: LD_INT 1
6394: PPUSH
6395: LD_INT 3
6397: PPUSH
6398: CALL_OW 12
6402: ARRAY
6403: PPUSH
6404: LD_VAR 0 6
6408: PPUSH
6409: CALL_OW 380
// un := CreateHuman ;
6413: LD_ADDR_VAR 0 4
6417: PUSH
6418: CALL_OW 44
6422: ST_TO_ADDR
// PlaceUnitArea ( un , ar3 , false ) ;
6423: LD_VAR 0 4
6427: PPUSH
6428: LD_INT 18
6430: PPUSH
6431: LD_INT 0
6433: PPUSH
6434: CALL_OW 49
// ComMoveToArea ( un , spot3 ) ;
6438: LD_VAR 0 4
6442: PPUSH
6443: LD_INT 20
6445: PPUSH
6446: CALL_OW 113
// Wait ( 0 0$01 ) ;
6450: LD_INT 35
6452: PPUSH
6453: CALL_OW 67
// end ;
6457: GO 6372
6459: POP
6460: POP
// end ; 2 :
6461: GO 7092
6463: LD_INT 2
6465: DOUBLE
6466: EQUAL
6467: IFTRUE 6471
6469: GO 6734
6471: POP
// begin for i = 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
6472: LD_ADDR_VAR 0 3
6476: PUSH
6477: DOUBLE
6478: LD_INT 1
6480: DEC
6481: ST_TO_ADDR
6482: LD_INT 4
6484: PUSH
6485: LD_INT 5
6487: PUSH
6488: LD_INT 5
6490: PUSH
6491: EMPTY
6492: LIST
6493: LIST
6494: LIST
6495: PUSH
6496: LD_OWVAR 67
6500: ARRAY
6501: PUSH
6502: FOR_TO
6503: IFFALSE 6566
// begin PrepareHuman ( false , class_soldier , skill ) ;
6505: LD_INT 0
6507: PPUSH
6508: LD_INT 1
6510: PPUSH
6511: LD_VAR 0 6
6515: PPUSH
6516: CALL_OW 380
// un := CreateHuman ;
6520: LD_ADDR_VAR 0 4
6524: PUSH
6525: CALL_OW 44
6529: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6530: LD_VAR 0 4
6534: PPUSH
6535: LD_INT 17
6537: PPUSH
6538: LD_INT 0
6540: PPUSH
6541: CALL_OW 49
// ComMoveToArea ( un , spot2 ) ;
6545: LD_VAR 0 4
6549: PPUSH
6550: LD_INT 19
6552: PPUSH
6553: CALL_OW 113
// Wait ( 0 0$01 ) ;
6557: LD_INT 35
6559: PPUSH
6560: CALL_OW 67
// end ;
6564: GO 6502
6566: POP
6567: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
6568: LD_ADDR_VAR 0 3
6572: PUSH
6573: DOUBLE
6574: LD_INT 1
6576: DEC
6577: ST_TO_ADDR
6578: LD_INT 2
6580: PUSH
6581: LD_INT 3
6583: PUSH
6584: LD_INT 4
6586: PUSH
6587: EMPTY
6588: LIST
6589: LIST
6590: LIST
6591: PUSH
6592: LD_OWVAR 67
6596: ARRAY
6597: PUSH
6598: FOR_TO
6599: IFFALSE 6730
// begin vc_chassis := ar_medium_trike ;
6601: LD_ADDR_OWVAR 37
6605: PUSH
6606: LD_INT 13
6608: ST_TO_ADDR
// vc_engine := engine_combustion ;
6609: LD_ADDR_OWVAR 39
6613: PUSH
6614: LD_INT 1
6616: ST_TO_ADDR
// vc_control := control_manual ;
6617: LD_ADDR_OWVAR 38
6621: PUSH
6622: LD_INT 1
6624: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_light_gun ] [ Rand ( 1 , 2 ) ] ;
6625: LD_ADDR_OWVAR 40
6629: PUSH
6630: LD_INT 24
6632: PUSH
6633: LD_INT 23
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: PUSH
6640: LD_INT 1
6642: PPUSH
6643: LD_INT 2
6645: PPUSH
6646: CALL_OW 12
6650: ARRAY
6651: ST_TO_ADDR
// veh := CreateVehicle ;
6652: LD_ADDR_VAR 0 5
6656: PUSH
6657: CALL_OW 45
6661: ST_TO_ADDR
// PlaceUnitArea ( veh , ar2 , false ) ;
6662: LD_VAR 0 5
6666: PPUSH
6667: LD_INT 17
6669: PPUSH
6670: LD_INT 0
6672: PPUSH
6673: CALL_OW 49
// PrepareHuman ( false , 1 , skill ) ;
6677: LD_INT 0
6679: PPUSH
6680: LD_INT 1
6682: PPUSH
6683: LD_VAR 0 6
6687: PPUSH
6688: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6692: CALL_OW 44
6696: PPUSH
6697: LD_VAR 0 5
6701: PPUSH
6702: CALL_OW 52
// ComMoveXY ( veh , 89 , 40 ) ;
6706: LD_VAR 0 5
6710: PPUSH
6711: LD_INT 89
6713: PPUSH
6714: LD_INT 40
6716: PPUSH
6717: CALL_OW 111
// Wait ( 0 0$02 ) ;
6721: LD_INT 70
6723: PPUSH
6724: CALL_OW 67
// end ;
6728: GO 6598
6730: POP
6731: POP
// end ; 3 :
6732: GO 7092
6734: LD_INT 3
6736: DOUBLE
6737: EQUAL
6738: IFTRUE 6742
6740: GO 7091
6742: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] + ( tick div 15 15$00 ) do
6743: LD_ADDR_VAR 0 3
6747: PUSH
6748: DOUBLE
6749: LD_INT 1
6751: DEC
6752: ST_TO_ADDR
6753: LD_INT 4
6755: PUSH
6756: LD_INT 5
6758: PUSH
6759: LD_INT 6
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: LIST
6766: PUSH
6767: LD_OWVAR 67
6771: ARRAY
6772: PUSH
6773: LD_OWVAR 1
6777: PUSH
6778: LD_INT 31500
6780: DIV
6781: PLUS
6782: PUSH
6783: FOR_TO
6784: IFFALSE 6892
// begin PrepareHuman ( false , [ class_soldier , class_mortar ] [ Rand ( 1 , 2 ) ] , skill ) ;
6786: LD_INT 0
6788: PPUSH
6789: LD_INT 1
6791: PUSH
6792: LD_INT 8
6794: PUSH
6795: EMPTY
6796: LIST
6797: LIST
6798: PUSH
6799: LD_INT 1
6801: PPUSH
6802: LD_INT 2
6804: PPUSH
6805: CALL_OW 12
6809: ARRAY
6810: PPUSH
6811: LD_VAR 0 6
6815: PPUSH
6816: CALL_OW 380
// un := CreateHuman ;
6820: LD_ADDR_VAR 0 4
6824: PUSH
6825: CALL_OW 44
6829: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6830: LD_VAR 0 4
6834: PPUSH
6835: LD_INT 17
6837: PPUSH
6838: LD_INT 0
6840: PPUSH
6841: CALL_OW 49
// ar_force := Insert ( ar_force , 1 , un ) ;
6845: LD_ADDR_EXP 11
6849: PUSH
6850: LD_EXP 11
6854: PPUSH
6855: LD_INT 1
6857: PPUSH
6858: LD_VAR 0 4
6862: PPUSH
6863: CALL_OW 2
6867: ST_TO_ADDR
// ComMoveXY ( un , 17 , 9 ) ;
6868: LD_VAR 0 4
6872: PPUSH
6873: LD_INT 17
6875: PPUSH
6876: LD_INT 9
6878: PPUSH
6879: CALL_OW 111
// Wait ( 0 0$01 ) ;
6883: LD_INT 35
6885: PPUSH
6886: CALL_OW 67
// end ;
6890: GO 6783
6892: POP
6893: POP
// for i = 1 to [ 4 , 5 , 7 ] [ Difficulty ] do
6894: LD_ADDR_VAR 0 3
6898: PUSH
6899: DOUBLE
6900: LD_INT 1
6902: DEC
6903: ST_TO_ADDR
6904: LD_INT 4
6906: PUSH
6907: LD_INT 5
6909: PUSH
6910: LD_INT 7
6912: PUSH
6913: EMPTY
6914: LIST
6915: LIST
6916: LIST
6917: PUSH
6918: LD_OWVAR 67
6922: ARRAY
6923: PUSH
6924: FOR_TO
6925: IFFALSE 7087
// begin vc_chassis := ar_half_tracked ;
6927: LD_ADDR_OWVAR 37
6931: PUSH
6932: LD_INT 14
6934: ST_TO_ADDR
// vc_engine := engine_combustion ;
6935: LD_ADDR_OWVAR 39
6939: PUSH
6940: LD_INT 1
6942: ST_TO_ADDR
// vc_control := control_manual ;
6943: LD_ADDR_OWVAR 38
6947: PUSH
6948: LD_INT 1
6950: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_flame_thrower ] [ Rand ( 1 , 4 ) ] ;
6951: LD_ADDR_OWVAR 40
6955: PUSH
6956: LD_INT 25
6958: PUSH
6959: LD_INT 27
6961: PUSH
6962: LD_INT 28
6964: PUSH
6965: LD_INT 26
6967: PUSH
6968: EMPTY
6969: LIST
6970: LIST
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 1
6976: PPUSH
6977: LD_INT 4
6979: PPUSH
6980: CALL_OW 12
6984: ARRAY
6985: ST_TO_ADDR
// veh := CreateVehicle ;
6986: LD_ADDR_VAR 0 5
6990: PUSH
6991: CALL_OW 45
6995: ST_TO_ADDR
// PlaceUnitArea ( veh , ar1 , false ) ;
6996: LD_VAR 0 5
7000: PPUSH
7001: LD_INT 16
7003: PPUSH
7004: LD_INT 0
7006: PPUSH
7007: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7011: LD_INT 0
7013: PPUSH
7014: LD_INT 3
7016: PPUSH
7017: LD_VAR 0 6
7021: PPUSH
7022: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
7026: CALL_OW 44
7030: PPUSH
7031: LD_VAR 0 5
7035: PPUSH
7036: CALL_OW 52
// ar_force := Insert ( ar_force , 1 , veh ) ;
7040: LD_ADDR_EXP 11
7044: PUSH
7045: LD_EXP 11
7049: PPUSH
7050: LD_INT 1
7052: PPUSH
7053: LD_VAR 0 5
7057: PPUSH
7058: CALL_OW 2
7062: ST_TO_ADDR
// ComMoveXY ( veh , 125 , 31 ) ;
7063: LD_VAR 0 5
7067: PPUSH
7068: LD_INT 125
7070: PPUSH
7071: LD_INT 31
7073: PPUSH
7074: CALL_OW 111
// Wait ( 0 0$02 ) ;
7078: LD_INT 70
7080: PPUSH
7081: CALL_OW 67
// end ;
7085: GO 6924
7087: POP
7088: POP
// end ; end ;
7089: GO 7092
7091: POP
// end ;
7092: LD_VAR 0 2
7096: RET
// export function PrepareHovercrafts ; var i , un , areas , skill ; begin
7097: LD_INT 0
7099: PPUSH
7100: PPUSH
7101: PPUSH
7102: PPUSH
7103: PPUSH
// areas := [ river1 , river2 ] ;
7104: LD_ADDR_VAR 0 4
7108: PUSH
7109: LD_INT 14
7111: PUSH
7112: LD_INT 15
7114: PUSH
7115: EMPTY
7116: LIST
7117: LIST
7118: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7119: LD_ADDR_VAR 0 5
7123: PUSH
7124: LD_INT 5
7126: PUSH
7127: LD_INT 6
7129: PUSH
7130: LD_INT 7
7132: PUSH
7133: EMPTY
7134: LIST
7135: LIST
7136: LIST
7137: PUSH
7138: LD_OWVAR 67
7142: ARRAY
7143: ST_TO_ADDR
// uc_side := 2 ;
7144: LD_ADDR_OWVAR 20
7148: PUSH
7149: LD_INT 2
7151: ST_TO_ADDR
// uc_nation := 2 ;
7152: LD_ADDR_OWVAR 21
7156: PUSH
7157: LD_INT 2
7159: ST_TO_ADDR
// hc_name :=  ;
7160: LD_ADDR_OWVAR 26
7164: PUSH
7165: LD_STRING 
7167: ST_TO_ADDR
// hc_gallery :=  ;
7168: LD_ADDR_OWVAR 33
7172: PUSH
7173: LD_STRING 
7175: ST_TO_ADDR
// for i = 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
7176: LD_ADDR_VAR 0 2
7180: PUSH
7181: DOUBLE
7182: LD_INT 1
7184: DEC
7185: ST_TO_ADDR
7186: LD_INT 1
7188: PUSH
7189: LD_INT 2
7191: PUSH
7192: LD_INT 2
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_OWVAR 67
7204: ARRAY
7205: PUSH
7206: FOR_TO
7207: IFFALSE 7345
// begin vc_chassis := ar_hovercraft ;
7209: LD_ADDR_OWVAR 37
7213: PUSH
7214: LD_INT 11
7216: ST_TO_ADDR
// vc_engine := engine_solar ;
7217: LD_ADDR_OWVAR 39
7221: PUSH
7222: LD_INT 2
7224: ST_TO_ADDR
// vc_control := control_manual ;
7225: LD_ADDR_OWVAR 38
7229: PUSH
7230: LD_INT 1
7232: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
7233: LD_ADDR_OWVAR 40
7237: PUSH
7238: LD_INT 24
7240: ST_TO_ADDR
// vc_fuel_battery := 100 ;
7241: LD_ADDR_OWVAR 41
7245: PUSH
7246: LD_INT 100
7248: ST_TO_ADDR
// un := CreateVehicle ;
7249: LD_ADDR_VAR 0 3
7253: PUSH
7254: CALL_OW 45
7258: ST_TO_ADDR
// PlaceUnitArea ( un , areas [ i ] , false ) ;
7259: LD_VAR 0 3
7263: PPUSH
7264: LD_VAR 0 4
7268: PUSH
7269: LD_VAR 0 2
7273: ARRAY
7274: PPUSH
7275: LD_INT 0
7277: PPUSH
7278: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7282: LD_INT 0
7284: PPUSH
7285: LD_INT 3
7287: PPUSH
7288: LD_VAR 0 5
7292: PPUSH
7293: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
7297: CALL_OW 44
7301: PPUSH
7302: LD_VAR 0 3
7306: PPUSH
7307: CALL_OW 52
// riv := Insert ( riv , 1 , [ un , i ] ) ;
7311: LD_ADDR_EXP 9
7315: PUSH
7316: LD_EXP 9
7320: PPUSH
7321: LD_INT 1
7323: PPUSH
7324: LD_VAR 0 3
7328: PUSH
7329: LD_VAR 0 2
7333: PUSH
7334: EMPTY
7335: LIST
7336: LIST
7337: PPUSH
7338: CALL_OW 2
7342: ST_TO_ADDR
// end ;
7343: GO 7206
7345: POP
7346: POP
// end ;
7347: LD_VAR 0 1
7351: RET
// every 0 0$01 trigger riv do var i , c ;
7352: LD_EXP 9
7356: IFFALSE 7675
7358: GO 7360
7360: DISABLE
7361: LD_INT 0
7363: PPUSH
7364: PPUSH
// begin enable ;
7365: ENABLE
// for i = riv downto 1 do
7366: LD_ADDR_VAR 0 1
7370: PUSH
7371: DOUBLE
7372: LD_EXP 9
7376: INC
7377: ST_TO_ADDR
7378: LD_INT 1
7380: PUSH
7381: FOR_DOWNTO
7382: IFFALSE 7673
// begin if not riv [ i ] [ 1 ] then
7384: LD_EXP 9
7388: PUSH
7389: LD_VAR 0 1
7393: ARRAY
7394: PUSH
7395: LD_INT 1
7397: ARRAY
7398: NOT
7399: IFFALSE 7421
// begin riv := Delete ( riv , 1 ) ;
7401: LD_ADDR_EXP 9
7405: PUSH
7406: LD_EXP 9
7410: PPUSH
7411: LD_INT 1
7413: PPUSH
7414: CALL_OW 3
7418: ST_TO_ADDR
// break ;
7419: GO 7673
// end ; if not HasTask ( riv [ i ] [ 1 ] ) then
7421: LD_EXP 9
7425: PUSH
7426: LD_VAR 0 1
7430: ARRAY
7431: PUSH
7432: LD_INT 1
7434: ARRAY
7435: PPUSH
7436: CALL_OW 314
7440: NOT
7441: IFFALSE 7509
// begin if riv [ i ] [ 2 ] = 1 then
7443: LD_EXP 9
7447: PUSH
7448: LD_VAR 0 1
7452: ARRAY
7453: PUSH
7454: LD_INT 2
7456: ARRAY
7457: PUSH
7458: LD_INT 1
7460: EQUAL
7461: IFFALSE 7473
// c := 2 else
7463: LD_ADDR_VAR 0 2
7467: PUSH
7468: LD_INT 2
7470: ST_TO_ADDR
7471: GO 7481
// c := 1 ;
7473: LD_ADDR_VAR 0 2
7477: PUSH
7478: LD_INT 1
7480: ST_TO_ADDR
// riv := Replace2 ( riv , i , 2 , c ) ;
7481: LD_ADDR_EXP 9
7485: PUSH
7486: LD_EXP 9
7490: PPUSH
7491: LD_VAR 0 1
7495: PPUSH
7496: LD_INT 2
7498: PPUSH
7499: LD_VAR 0 2
7503: PPUSH
7504: CALL 10006 0 4
7508: ST_TO_ADDR
// end ; if not IsInArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) then
7509: LD_EXP 9
7513: PUSH
7514: LD_VAR 0 1
7518: ARRAY
7519: PUSH
7520: LD_INT 1
7522: ARRAY
7523: PPUSH
7524: LD_INT 14
7526: PUSH
7527: LD_INT 15
7529: PUSH
7530: EMPTY
7531: LIST
7532: LIST
7533: PUSH
7534: LD_EXP 9
7538: PUSH
7539: LD_VAR 0 1
7543: ARRAY
7544: PUSH
7545: LD_INT 2
7547: ARRAY
7548: ARRAY
7549: PPUSH
7550: CALL_OW 308
7554: NOT
7555: IFFALSE 7671
// begin if GetFuel ( riv [ i ] [ 1 ] ) < 50 then
7557: LD_EXP 9
7561: PUSH
7562: LD_VAR 0 1
7566: ARRAY
7567: PUSH
7568: LD_INT 1
7570: ARRAY
7571: PPUSH
7572: CALL_OW 261
7576: PUSH
7577: LD_INT 50
7579: LESS
7580: IFFALSE 7604
// SetFuel ( riv [ i ] [ 1 ] , 67 ) ;
7582: LD_EXP 9
7586: PUSH
7587: LD_VAR 0 1
7591: ARRAY
7592: PUSH
7593: LD_INT 1
7595: ARRAY
7596: PPUSH
7597: LD_INT 67
7599: PPUSH
7600: CALL_OW 240
// ComMoveToArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) ;
7604: LD_EXP 9
7608: PUSH
7609: LD_VAR 0 1
7613: ARRAY
7614: PUSH
7615: LD_INT 1
7617: ARRAY
7618: PPUSH
7619: LD_INT 14
7621: PUSH
7622: LD_INT 15
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: PUSH
7629: LD_EXP 9
7633: PUSH
7634: LD_VAR 0 1
7638: ARRAY
7639: PUSH
7640: LD_INT 2
7642: ARRAY
7643: ARRAY
7644: PPUSH
7645: CALL_OW 113
// AddComWait ( riv [ i ] [ 1 ] , 0 0$10 ) ;
7649: LD_EXP 9
7653: PUSH
7654: LD_VAR 0 1
7658: ARRAY
7659: PUSH
7660: LD_INT 1
7662: ARRAY
7663: PPUSH
7664: LD_INT 350
7666: PPUSH
7667: CALL_OW 202
// end ; end ;
7671: GO 7381
7673: POP
7674: POP
// end ;
7675: PPOPN 2
7677: END
// every 10 10$00 trigger convoy_start do var i , un ;
7678: LD_EXP 7
7682: IFFALSE 7803
7684: GO 7686
7686: DISABLE
7687: LD_INT 0
7689: PPUSH
7690: PPUSH
// begin enable ;
7691: ENABLE
// for i = 1 to 2 do
7692: LD_ADDR_VAR 0 1
7696: PUSH
7697: DOUBLE
7698: LD_INT 1
7700: DEC
7701: ST_TO_ADDR
7702: LD_INT 2
7704: PUSH
7705: FOR_TO
7706: IFFALSE 7801
// begin uc_side := 2 ;
7708: LD_ADDR_OWVAR 20
7712: PUSH
7713: LD_INT 2
7715: ST_TO_ADDR
// uc_nation := 2 ;
7716: LD_ADDR_OWVAR 21
7720: PUSH
7721: LD_INT 2
7723: ST_TO_ADDR
// PrepareHuman ( false , 1 , 4 ) ;
7724: LD_INT 0
7726: PPUSH
7727: LD_INT 1
7729: PPUSH
7730: LD_INT 4
7732: PPUSH
7733: CALL_OW 380
// un := CreateHuman ;
7737: LD_ADDR_VAR 0 2
7741: PUSH
7742: CALL_OW 44
7746: ST_TO_ADDR
// PlaceUnitXY ( un , 10 , 2 , false ) ;
7747: LD_VAR 0 2
7751: PPUSH
7752: LD_INT 10
7754: PPUSH
7755: LD_INT 2
7757: PPUSH
7758: LD_INT 0
7760: PPUSH
7761: CALL_OW 48
// ComMoveXY ( un , 24 , 36 ) ;
7765: LD_VAR 0 2
7769: PPUSH
7770: LD_INT 24
7772: PPUSH
7773: LD_INT 36
7775: PPUSH
7776: CALL_OW 111
// AddComMoveToArea ( un , conv_end ) ;
7780: LD_VAR 0 2
7784: PPUSH
7785: LD_INT 9
7787: PPUSH
7788: CALL_OW 173
// Wait ( 0 0$02 ) ;
7792: LD_INT 70
7794: PPUSH
7795: CALL_OW 67
// end ;
7799: GO 7705
7801: POP
7802: POP
// end ;
7803: PPOPN 2
7805: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , rest ;
7806: LD_INT 22
7808: PUSH
7809: LD_INT 2
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PPUSH
7816: CALL_OW 69
7820: IFFALSE 8131
7822: GO 7824
7824: DISABLE
7825: LD_INT 0
7827: PPUSH
7828: PPUSH
// begin enable ;
7829: ENABLE
// rest := FilterAllUnits ( [ f_side , 2 ] ) diff ar_force ;
7830: LD_ADDR_VAR 0 2
7834: PUSH
7835: LD_INT 22
7837: PUSH
7838: LD_INT 2
7840: PUSH
7841: EMPTY
7842: LIST
7843: LIST
7844: PPUSH
7845: CALL_OW 69
7849: PUSH
7850: LD_EXP 11
7854: DIFF
7855: ST_TO_ADDR
// if rest then
7856: LD_VAR 0 2
7860: IFFALSE 7932
// for i in rest do
7862: LD_ADDR_VAR 0 1
7866: PUSH
7867: LD_VAR 0 2
7871: PUSH
7872: FOR_IN
7873: IFFALSE 7930
// if GetClass ( i ) = 3 then
7875: LD_VAR 0 1
7879: PPUSH
7880: CALL_OW 257
7884: PUSH
7885: LD_INT 3
7887: EQUAL
7888: IFFALSE 7928
// begin if not IsInArea ( i , ar2 ) then
7890: LD_VAR 0 1
7894: PPUSH
7895: LD_INT 17
7897: PPUSH
7898: CALL_OW 308
7902: NOT
7903: IFFALSE 7919
// ComMoveToArea ( i , ar2 ) else
7905: LD_VAR 0 1
7909: PPUSH
7910: LD_INT 17
7912: PPUSH
7913: CALL_OW 113
7917: GO 7928
// RemoveUnit ( i ) ;
7919: LD_VAR 0 1
7923: PPUSH
7924: CALL_OW 64
// end ;
7928: GO 7872
7930: POP
7931: POP
// if ar_force then
7932: LD_EXP 11
7936: IFFALSE 8131
// for i in ar_force do
7938: LD_ADDR_VAR 0 1
7942: PUSH
7943: LD_EXP 11
7947: PUSH
7948: FOR_IN
7949: IFFALSE 8129
// begin if GetClass ( i ) = class_soldier then
7951: LD_VAR 0 1
7955: PPUSH
7956: CALL_OW 257
7960: PUSH
7961: LD_INT 1
7963: EQUAL
7964: IFFALSE 8056
// if FindTarget ( i ) in FilterAllUnits ( [ f_type , unit_building ] ) then
7966: LD_VAR 0 1
7970: PPUSH
7971: CALL 10314 0 1
7975: PUSH
7976: LD_INT 21
7978: PUSH
7979: LD_INT 3
7981: PUSH
7982: EMPTY
7983: LIST
7984: LIST
7985: PPUSH
7986: CALL_OW 69
7990: IN
7991: IFFALSE 8037
// ComPlaceDelayedCharge ( i , GetX ( FindTarget ( i ) ) , GetY ( FindTarget ( i ) ) , 0 ) else
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_VAR 0 1
8002: PPUSH
8003: CALL 10314 0 1
8007: PPUSH
8008: CALL_OW 250
8012: PPUSH
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL 10314 0 1
8022: PPUSH
8023: CALL_OW 251
8027: PPUSH
8028: LD_INT 0
8030: PPUSH
8031: CALL_OW 132
8035: GO 8056
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8037: LD_VAR 0 1
8041: PPUSH
8042: LD_VAR 0 1
8046: PPUSH
8047: CALL 10314 0 1
8051: PPUSH
8052: CALL_OW 115
// if not GetClass ( i ) = 1 then
8056: LD_VAR 0 1
8060: PPUSH
8061: CALL_OW 257
8065: PUSH
8066: LD_INT 1
8068: EQUAL
8069: NOT
8070: IFFALSE 8091
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8072: LD_VAR 0 1
8076: PPUSH
8077: LD_VAR 0 1
8081: PPUSH
8082: CALL 10314 0 1
8086: PPUSH
8087: CALL_OW 115
// if GetDistUnitXY ( i , 65 , 118 ) < 40 then
8091: LD_VAR 0 1
8095: PPUSH
8096: LD_INT 65
8098: PPUSH
8099: LD_INT 118
8101: PPUSH
8102: CALL_OW 297
8106: PUSH
8107: LD_INT 40
8109: LESS
8110: IFFALSE 8127
// ComMoveXY ( i , 65 , 118 ) ;
8112: LD_VAR 0 1
8116: PPUSH
8117: LD_INT 65
8119: PPUSH
8120: LD_INT 118
8122: PPUSH
8123: CALL_OW 111
// end ;
8127: GO 7948
8129: POP
8130: POP
// end ;
8131: PPOPN 2
8133: END
// every 0 0$01 trigger FilterUnitsInArea ( conv_end , [ f_side , 2 ] ) do
8134: LD_INT 9
8136: PPUSH
8137: LD_INT 22
8139: PUSH
8140: LD_INT 2
8142: PUSH
8143: EMPTY
8144: LIST
8145: LIST
8146: PPUSH
8147: CALL_OW 70
8151: IFFALSE 8164
8153: GO 8155
8155: DISABLE
// medal2 := false ; end_of_file
8156: LD_ADDR_EXP 4
8160: PUSH
8161: LD_INT 0
8163: ST_TO_ADDR
8164: END
// export function Action ; begin
8165: LD_INT 0
8167: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
8168: LD_ADDR_OWVAR 67
8172: PUSH
8173: LD_INT 0
8175: PPUSH
8176: CALL_OW 426
8180: ST_TO_ADDR
// case Query ( info ) of 1 :
8181: LD_STRING info
8183: PPUSH
8184: CALL_OW 97
8188: PUSH
8189: LD_INT 1
8191: DOUBLE
8192: EQUAL
8193: IFTRUE 8197
8195: GO 8200
8197: POP
// ; end ;
8198: GO 8201
8200: POP
// ChangeMissionObjectives ( PM_1 ) ;
8201: LD_STRING PM_1
8203: PPUSH
8204: CALL_OW 337
// SaveForQuickRestart ;
8208: CALL_OW 22
// end ;
8212: LD_VAR 0 1
8216: RET
// every 0 0$01 trigger GetSide ( us_depot ) = 3 do
8217: LD_INT 50
8219: PPUSH
8220: CALL_OW 255
8224: PUSH
8225: LD_INT 3
8227: EQUAL
8228: IFFALSE 8509
8230: GO 8232
8232: DISABLE
// begin Say ( Stolypin , DPM_S1 ) ;
8233: LD_EXP 15
8237: PPUSH
8238: LD_STRING DPM_S1
8240: PPUSH
8241: CALL_OW 88
// SayRadio ( Popov , DPM_P1 ) ;
8245: LD_EXP 16
8249: PPUSH
8250: LD_STRING DPM_P1
8252: PPUSH
8253: CALL_OW 94
// Say ( Stolypin , DPM_S2 ) ;
8257: LD_EXP 15
8261: PPUSH
8262: LD_STRING DPM_S2
8264: PPUSH
8265: CALL_OW 88
// SaveForQuickRestart ;
8269: CALL_OW 22
// ChangeMissionObjectives ( PM_2 ) ;
8273: LD_STRING PM_2
8275: PPUSH
8276: CALL_OW 337
// Wait ( 2 2$30 ) ;
8280: LD_INT 5250
8282: PPUSH
8283: CALL_OW 67
// CenterOnXY ( 117 , 4 ) ;
8287: LD_INT 117
8289: PPUSH
8290: LD_INT 4
8292: PPUSH
8293: CALL_OW 84
// Convoy ( 1 ) ;
8297: LD_INT 1
8299: PPUSH
8300: CALL 883 0 1
// Wait ( 0 0$30 ) ;
8304: LD_INT 1050
8306: PPUSH
8307: CALL_OW 67
// Convoy ( 2 ) ;
8311: LD_INT 2
8313: PPUSH
8314: CALL 883 0 1
// Wait ( 1 1$30 ) ;
8318: LD_INT 3150
8320: PPUSH
8321: CALL_OW 67
// Convoy ( 3 ) ;
8325: LD_INT 3
8327: PPUSH
8328: CALL 883 0 1
// Wait ( 5 5$00 ) ;
8332: LD_INT 10500
8334: PPUSH
8335: CALL_OW 67
// convoy_start := true ;
8339: LD_ADDR_EXP 7
8343: PUSH
8344: LD_INT 1
8346: ST_TO_ADDR
// PrepareArabian ;
8347: CALL 6203 0 0
// PrepareAttack ( 1 ) ;
8351: LD_INT 1
8353: PPUSH
8354: CALL 6276 0 1
// while ( convoy_start ) do
8358: LD_EXP 7
8362: IFFALSE 8509
// begin Wait ( Rand ( 2 2$00 , 4 4$00 ) ) ;
8364: LD_INT 4200
8366: PPUSH
8367: LD_INT 8400
8369: PPUSH
8370: CALL_OW 12
8374: PPUSH
8375: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) < 20 then
8379: LD_INT 22
8381: PUSH
8382: LD_INT 2
8384: PUSH
8385: EMPTY
8386: LIST
8387: LIST
8388: PPUSH
8389: CALL_OW 69
8393: PUSH
8394: LD_INT 20
8396: LESS
8397: IFFALSE 8414
// PrepareAttack ( Rand ( 1 , 2 ) ) ;
8399: LD_INT 1
8401: PPUSH
8402: LD_INT 2
8404: PPUSH
8405: CALL_OW 12
8409: PPUSH
8410: CALL 6276 0 1
// Convoy ( Rand ( 1 , 5 ) ) ;
8414: LD_INT 1
8416: PPUSH
8417: LD_INT 5
8419: PPUSH
8420: CALL_OW 12
8424: PPUSH
8425: CALL 883 0 1
// conv_counter := conv_counter + 1 ;
8429: LD_ADDR_EXP 13
8433: PUSH
8434: LD_EXP 13
8438: PUSH
8439: LD_INT 1
8441: PLUS
8442: ST_TO_ADDR
// if conv_counter mod [ 5 , 4 , 3 ] [ Difficulty ] = 0 then
8443: LD_EXP 13
8447: PUSH
8448: LD_INT 5
8450: PUSH
8451: LD_INT 4
8453: PUSH
8454: LD_INT 3
8456: PUSH
8457: EMPTY
8458: LIST
8459: LIST
8460: LIST
8461: PUSH
8462: LD_OWVAR 67
8466: ARRAY
8467: MOD
8468: PUSH
8469: LD_INT 0
8471: EQUAL
8472: IFFALSE 8507
// begin Wait ( 1 1$20 ) ;
8474: LD_INT 2800
8476: PPUSH
8477: CALL_OW 67
// SayRadio ( Farmer , DPM_F2 ) ;
8481: LD_EXP 24
8485: PPUSH
8486: LD_STRING DPM_F2
8488: PPUSH
8489: CALL_OW 94
// PrepareAttack ( 3 ) ;
8493: LD_INT 3
8495: PPUSH
8496: CALL 6276 0 1
// Wait ( 4 4$00 ) ;
8500: LD_INT 8400
8502: PPUSH
8503: CALL_OW 67
// end ; end ;
8507: GO 8358
// end ;
8509: END
// every 1 1$30 trigger conv_counter mod 3 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8510: LD_EXP 13
8514: PUSH
8515: LD_INT 3
8517: MOD
8518: PUSH
8519: LD_INT 0
8521: EQUAL
8522: PUSH
8523: LD_INT 22
8525: PUSH
8526: LD_INT 2
8528: PUSH
8529: EMPTY
8530: LIST
8531: LIST
8532: PPUSH
8533: CALL_OW 69
8537: PUSH
8538: LD_INT 0
8540: EQUAL
8541: AND
8542: IFFALSE 8559
8544: GO 8546
8546: DISABLE
// SayRadio ( Farmer , DPM_F3 ) ;
8547: LD_EXP 24
8551: PPUSH
8552: LD_STRING DPM_F3
8554: PPUSH
8555: CALL_OW 94
8559: END
// every 1 1$30 trigger conv_counter mod 5 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8560: LD_EXP 13
8564: PUSH
8565: LD_INT 5
8567: MOD
8568: PUSH
8569: LD_INT 0
8571: EQUAL
8572: PUSH
8573: LD_INT 22
8575: PUSH
8576: LD_INT 2
8578: PUSH
8579: EMPTY
8580: LIST
8581: LIST
8582: PPUSH
8583: CALL_OW 69
8587: PUSH
8588: LD_INT 0
8590: EQUAL
8591: AND
8592: IFFALSE 8609
8594: GO 8596
8596: DISABLE
// SayRadio ( Farmer , DPM_F4 ) ;
8597: LD_EXP 24
8601: PPUSH
8602: LD_STRING DPM_F4
8604: PPUSH
8605: CALL_OW 94
8609: END
// every 0 0$10 trigger conv_counter >= 8 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
8610: LD_EXP 13
8614: PUSH
8615: LD_INT 8
8617: GREATEREQUAL
8618: PUSH
8619: LD_INT 22
8621: PUSH
8622: LD_INT 6
8624: PUSH
8625: EMPTY
8626: LIST
8627: LIST
8628: PPUSH
8629: CALL_OW 69
8633: PUSH
8634: LD_INT 0
8636: EQUAL
8637: AND
8638: IFFALSE 8737
8640: GO 8642
8642: DISABLE
// begin SayRadio ( Popov , DPM_PEnd ) ;
8643: LD_EXP 16
8647: PPUSH
8648: LD_STRING DPM_PEnd
8650: PPUSH
8651: CALL_OW 94
// AddMedal ( med1 , medal1 ) ;
8655: LD_STRING med1
8657: PPUSH
8658: LD_EXP 3
8662: PPUSH
8663: CALL_OW 101
// AddMedal ( med2 , medal2 ) ;
8667: LD_STRING med2
8669: PPUSH
8670: LD_EXP 4
8674: PPUSH
8675: CALL_OW 101
// if dest_counter >= [ 15 , 10 , 7 ] [ Difficulty ] then
8679: LD_EXP 8
8683: PUSH
8684: LD_INT 15
8686: PUSH
8687: LD_INT 10
8689: PUSH
8690: LD_INT 7
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: LIST
8697: PUSH
8698: LD_OWVAR 67
8702: ARRAY
8703: GREATEREQUAL
8704: IFFALSE 8714
// medal3 := false ;
8706: LD_ADDR_EXP 5
8710: PUSH
8711: LD_INT 0
8713: ST_TO_ADDR
// AddMedal ( med3 , medal3 ) ;
8714: LD_STRING med3
8716: PPUSH
8717: LD_EXP 5
8721: PPUSH
8722: CALL_OW 101
// GiveMedals ( MAIN ) ;
8726: LD_STRING MAIN
8728: PPUSH
8729: CALL_OW 102
// YouWin ;
8733: CALL_OW 103
// end ;
8737: END
// every 4 4$00 trigger convoy_start do var i ;
8738: LD_EXP 7
8742: IFFALSE 9100
8744: GO 8746
8746: DISABLE
8747: LD_INT 0
8749: PPUSH
// begin SayRadio ( Popov , DPM_PHelp ) ;
8750: LD_EXP 16
8754: PPUSH
8755: LD_STRING DPM_PHelp
8757: PPUSH
8758: CALL_OW 94
// Wait ( 0 0$30 ) ;
8762: LD_INT 1050
8764: PPUSH
8765: CALL_OW 67
// Randomize ;
8769: CALL_OW 10
// uc_side := 3 ;
8773: LD_ADDR_OWVAR 20
8777: PUSH
8778: LD_INT 3
8780: ST_TO_ADDR
// uc_nation := 3 ;
8781: LD_ADDR_OWVAR 21
8785: PUSH
8786: LD_INT 3
8788: ST_TO_ADDR
// for i = 1 to [ 5 , 4 , 3 ] [ Difficulty ] do
8789: LD_ADDR_VAR 0 1
8793: PUSH
8794: DOUBLE
8795: LD_INT 1
8797: DEC
8798: ST_TO_ADDR
8799: LD_INT 5
8801: PUSH
8802: LD_INT 4
8804: PUSH
8805: LD_INT 3
8807: PUSH
8808: EMPTY
8809: LIST
8810: LIST
8811: LIST
8812: PUSH
8813: LD_OWVAR 67
8817: ARRAY
8818: PUSH
8819: FOR_TO
8820: IFFALSE 8860
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , 5 ) ;
8822: LD_INT 0
8824: PPUSH
8825: LD_INT 1
8827: PPUSH
8828: LD_INT 3
8830: PPUSH
8831: CALL_OW 12
8835: PPUSH
8836: LD_INT 5
8838: PPUSH
8839: CALL_OW 380
// PlaceUnitArea ( CreateHuman , rus_start , false ) ;
8843: CALL_OW 44
8847: PPUSH
8848: LD_INT 1
8850: PPUSH
8851: LD_INT 0
8853: PPUSH
8854: CALL_OW 49
// end ;
8858: GO 8819
8860: POP
8861: POP
// vc_chassis := ru_heavy_wheeled ;
8862: LD_ADDR_OWVAR 37
8866: PUSH
8867: LD_INT 23
8869: ST_TO_ADDR
// vc_engine := engine_combustion ;
8870: LD_ADDR_OWVAR 39
8874: PUSH
8875: LD_INT 1
8877: ST_TO_ADDR
// vc_control := control_manual ;
8878: LD_ADDR_OWVAR 38
8882: PUSH
8883: LD_INT 1
8885: ST_TO_ADDR
// vc_weapon := 89 ;
8886: LD_ADDR_OWVAR 40
8890: PUSH
8891: LD_INT 89
8893: ST_TO_ADDR
// vc_fuel_battery := 88 ;
8894: LD_ADDR_OWVAR 41
8898: PUSH
8899: LD_INT 88
8901: ST_TO_ADDR
// i := CreateVehicle ;
8902: LD_ADDR_VAR 0 1
8906: PUSH
8907: CALL_OW 45
8911: ST_TO_ADDR
// SetDir ( i , 5 ) ;
8912: LD_VAR 0 1
8916: PPUSH
8917: LD_INT 5
8919: PPUSH
8920: CALL_OW 233
// PlaceUnitXY ( i , 63 , 115 , false ) ;
8924: LD_VAR 0 1
8928: PPUSH
8929: LD_INT 63
8931: PPUSH
8932: LD_INT 115
8934: PPUSH
8935: LD_INT 0
8937: PPUSH
8938: CALL_OW 48
// SetCargo ( i , mat_cans , 200 ) ;
8942: LD_VAR 0 1
8946: PPUSH
8947: LD_INT 1
8949: PPUSH
8950: LD_INT 200
8952: PPUSH
8953: CALL_OW 290
// PrepareHuman ( false , 3 , 5 ) ;
8957: LD_INT 0
8959: PPUSH
8960: LD_INT 3
8962: PPUSH
8963: LD_INT 5
8965: PPUSH
8966: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
8970: CALL_OW 44
8974: PPUSH
8975: LD_VAR 0 1
8979: PPUSH
8980: CALL_OW 52
// DialogueOn ;
8984: CALL_OW 6
// CenterNowOnXY ( 169 , 115 ) ;
8988: LD_INT 169
8990: PPUSH
8991: LD_INT 115
8993: PPUSH
8994: CALL_OW 86
// DWait ( 0 0$01 ) ;
8998: LD_INT 35
9000: PPUSH
9001: CALL_OW 68
// CenterNowOnXY ( 63 , 115 ) ;
9005: LD_INT 63
9007: PPUSH
9008: LD_INT 115
9010: PPUSH
9011: CALL_OW 86
// DWait ( 0 0$01 ) ;
9015: LD_INT 35
9017: PPUSH
9018: CALL_OW 68
// DialogueOff ;
9022: CALL_OW 7
// ComMoveXY ( i , 57 , 53 ) ;
9026: LD_VAR 0 1
9030: PPUSH
9031: LD_INT 57
9033: PPUSH
9034: LD_INT 53
9036: PPUSH
9037: CALL_OW 111
// Wait ( Rand ( 1 1$00 , 4 4$00 ) ) ;
9041: LD_INT 2100
9043: PPUSH
9044: LD_INT 8400
9046: PPUSH
9047: CALL_OW 12
9051: PPUSH
9052: CALL_OW 67
// PlaceUnitXY ( Saseda , 86 , 112 , false ) ;
9056: LD_EXP 17
9060: PPUSH
9061: LD_INT 86
9063: PPUSH
9064: LD_INT 112
9066: PPUSH
9067: LD_INT 0
9069: PPUSH
9070: CALL_OW 48
// Wait ( 0 0$0.3 ) ;
9074: LD_INT 10
9076: PPUSH
9077: CALL_OW 67
// SayRadio ( Saseda , DPM_Sa1 ) ;
9081: LD_EXP 17
9085: PPUSH
9086: LD_STRING DPM_Sa1
9088: PPUSH
9089: CALL_OW 94
// ChangeMissionObjectives ( PM_3 ) ;
9093: LD_STRING PM_3
9095: PPUSH
9096: CALL_OW 337
// end ;
9100: PPOPN 1
9102: END
// every 0 0$01 trigger See ( 3 , Saseda ) do
9103: LD_INT 3
9105: PPUSH
9106: LD_EXP 17
9110: PPUSH
9111: CALL_OW 292
9115: IFFALSE 9164
9117: GO 9119
9119: DISABLE
// begin Say ( Saseda , DPM_Sa2 ) ;
9120: LD_EXP 17
9124: PPUSH
9125: LD_STRING DPM_Sa2
9127: PPUSH
9128: CALL_OW 88
// ChangeMissionObjectives ( PM_4 ) ;
9132: LD_STRING PM_4
9134: PPUSH
9135: CALL_OW 337
// SetTech ( tech_rocket , 3 , state_enabled ) ;
9139: LD_INT 40
9141: PPUSH
9142: LD_INT 3
9144: PPUSH
9145: LD_INT 1
9147: PPUSH
9148: CALL_OW 322
// SetSide ( Saseda , 3 ) ;
9152: LD_EXP 17
9156: PPUSH
9157: LD_INT 3
9159: PPUSH
9160: CALL_OW 235
// end ;
9164: END
// every 16 16$00 trigger not medal1 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
9165: LD_EXP 3
9169: NOT
9170: PUSH
9171: LD_INT 22
9173: PUSH
9174: LD_INT 6
9176: PUSH
9177: EMPTY
9178: LIST
9179: LIST
9180: PPUSH
9181: CALL_OW 69
9185: PUSH
9186: LD_INT 0
9188: EQUAL
9189: AND
9190: IFFALSE 9250
9192: GO 9194
9194: DISABLE
// begin Say ( Stolypin , DPM_S3 ) ;
9195: LD_EXP 15
9199: PPUSH
9200: LD_STRING DPM_S3
9202: PPUSH
9203: CALL_OW 88
// PlaceSeeing ( 62 , 113 , 3 , 10 ) ;
9207: LD_INT 62
9209: PPUSH
9210: LD_INT 113
9212: PPUSH
9213: LD_INT 3
9215: PPUSH
9216: LD_INT 10
9218: PPUSH
9219: CALL_OW 330
// CenterOnXY ( 62 , 113 ) ;
9223: LD_INT 62
9225: PPUSH
9226: LD_INT 113
9228: PPUSH
9229: CALL_OW 84
// CounterAttack ;
9233: CALL 5702 0 0
// RemoveSeeing ( 62 , 113 , 3 ) ;
9237: LD_INT 62
9239: PPUSH
9240: LD_INT 113
9242: PPUSH
9243: LD_INT 3
9245: PPUSH
9246: CALL_OW 331
// end ; end_of_file
9250: END
// on LeaveBuilding ( b , h ) do begin if GetSide ( b ) = 1 then
9251: LD_VAR 0 1
9255: PPUSH
9256: CALL_OW 255
9260: PUSH
9261: LD_INT 1
9263: EQUAL
9264: IFFALSE 9300
// if not us_retreat then
9266: LD_EXP 21
9270: NOT
9271: IFFALSE 9300
// if GetClass ( h ) = 1 then
9273: LD_VAR 0 2
9277: PPUSH
9278: CALL_OW 257
9282: PUSH
9283: LD_INT 1
9285: EQUAL
9286: IFFALSE 9300
// ComEnterUnit ( h , us_arm ) ;
9288: LD_VAR 0 2
9292: PPUSH
9293: LD_INT 69
9295: PPUSH
9296: CALL_OW 120
// end ;
9300: PPOPN 2
9302: END
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = 1 then
9303: LD_VAR 0 1
9307: PPUSH
9308: CALL_OW 255
9312: PUSH
9313: LD_INT 1
9315: EQUAL
9316: IFFALSE 9332
// us_count := us_count + 1 ;
9318: LD_ADDR_EXP 23
9322: PUSH
9323: LD_EXP 23
9327: PUSH
9328: LD_INT 1
9330: PLUS
9331: ST_TO_ADDR
// if un in us_force then
9332: LD_VAR 0 1
9336: PUSH
9337: LD_EXP 12
9341: IN
9342: IFFALSE 9360
// us_force := us_force diff un ;
9344: LD_ADDR_EXP 12
9348: PUSH
9349: LD_EXP 12
9353: PUSH
9354: LD_VAR 0 1
9358: DIFF
9359: ST_TO_ADDR
// if un in ar_force then
9360: LD_VAR 0 1
9364: PUSH
9365: LD_EXP 11
9369: IN
9370: IFFALSE 9388
// ar_force := ar_force diff un ;
9372: LD_ADDR_EXP 11
9376: PUSH
9377: LD_EXP 11
9381: PUSH
9382: LD_VAR 0 1
9386: DIFF
9387: ST_TO_ADDR
// if un = Stolypin then
9388: LD_VAR 0 1
9392: PUSH
9393: LD_EXP 15
9397: EQUAL
9398: IFFALSE 9407
// YouLost ( dead ) ;
9400: LD_STRING dead
9402: PPUSH
9403: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) then
9407: LD_VAR 0 1
9411: PUSH
9412: LD_INT 22
9414: PUSH
9415: LD_INT 1
9417: PUSH
9418: EMPTY
9419: LIST
9420: LIST
9421: PUSH
9422: LD_INT 30
9424: PUSH
9425: LD_INT 0
9427: PUSH
9428: EMPTY
9429: LIST
9430: LIST
9431: PUSH
9432: EMPTY
9433: LIST
9434: LIST
9435: PPUSH
9436: CALL_OW 69
9440: IN
9441: IFFALSE 9450
// YouLost ( depot ) ;
9443: LD_STRING depot
9445: PPUSH
9446: CALL_OW 104
// if GetSide ( un ) = 6 then
9450: LD_VAR 0 1
9454: PPUSH
9455: CALL_OW 255
9459: PUSH
9460: LD_INT 6
9462: EQUAL
9463: IFFALSE 9479
// dest_counter := dest_counter + 1 ;
9465: LD_ADDR_EXP 8
9469: PUSH
9470: LD_EXP 8
9474: PUSH
9475: LD_INT 1
9477: PLUS
9478: ST_TO_ADDR
// end ;
9479: PPOPN 1
9481: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 1 then
9482: LD_VAR 0 1
9486: PPUSH
9487: CALL_OW 255
9491: PUSH
9492: LD_INT 1
9494: EQUAL
9495: IFFALSE 9512
// ComMoveXY ( un , 57 , 52 ) ;
9497: LD_VAR 0 1
9501: PPUSH
9502: LD_INT 57
9504: PPUSH
9505: LD_INT 52
9507: PPUSH
9508: CALL_OW 111
// end ;
9512: PPOPN 2
9514: END
// on Contact ( s1 , s2 ) do begin if not us_alert then
9515: LD_EXP 20
9519: NOT
9520: IFFALSE 9570
// if ( s1 = 3 and s2 = 1 ) or ( s1 = 1 and s2 = 3 ) then
9522: LD_VAR 0 1
9526: PUSH
9527: LD_INT 3
9529: EQUAL
9530: PUSH
9531: LD_VAR 0 2
9535: PUSH
9536: LD_INT 1
9538: EQUAL
9539: AND
9540: PUSH
9541: LD_VAR 0 1
9545: PUSH
9546: LD_INT 1
9548: EQUAL
9549: PUSH
9550: LD_VAR 0 2
9554: PUSH
9555: LD_INT 3
9557: EQUAL
9558: AND
9559: OR
9560: IFFALSE 9570
// us_alert := true ;
9562: LD_ADDR_EXP 20
9566: PUSH
9567: LD_INT 1
9569: ST_TO_ADDR
// if ( s1 = 6 and s2 = 3 ) or ( s1 = 3 and s2 = 6 ) then
9570: LD_VAR 0 1
9574: PUSH
9575: LD_INT 6
9577: EQUAL
9578: PUSH
9579: LD_VAR 0 2
9583: PUSH
9584: LD_INT 3
9586: EQUAL
9587: AND
9588: PUSH
9589: LD_VAR 0 1
9593: PUSH
9594: LD_INT 3
9596: EQUAL
9597: PUSH
9598: LD_VAR 0 2
9602: PUSH
9603: LD_INT 6
9605: EQUAL
9606: AND
9607: OR
9608: IFFALSE 9617
// YouLost ( alat ) ;
9610: LD_STRING alat
9612: PPUSH
9613: CALL_OW 104
// end ;
9617: PPOPN 2
9619: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = 2 and un in FilterAllUnits ( [ [ f_empty ] , [ f_type , unit_vehicle ] ] ) then
9620: LD_VAR 0 1
9624: PPUSH
9625: CALL_OW 255
9629: PUSH
9630: LD_INT 2
9632: EQUAL
9633: PUSH
9634: LD_VAR 0 1
9638: PUSH
9639: LD_INT 58
9641: PUSH
9642: EMPTY
9643: LIST
9644: PUSH
9645: LD_INT 21
9647: PUSH
9648: LD_INT 2
9650: PUSH
9651: EMPTY
9652: LIST
9653: LIST
9654: PUSH
9655: EMPTY
9656: LIST
9657: LIST
9658: PPUSH
9659: CALL_OW 69
9663: IN
9664: AND
9665: IFFALSE 9786
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> 2 then
9667: LD_OWVAR 3
9671: PUSH
9672: LD_VAR 0 1
9676: DIFF
9677: PPUSH
9678: LD_VAR 0 1
9682: PPUSH
9683: CALL_OW 74
9687: PPUSH
9688: CALL_OW 255
9692: PUSH
9693: LD_INT 2
9695: NONEQUAL
9696: IFFALSE 9786
// begin Wait ( 0 0$1.3 ) ;
9698: LD_INT 46
9700: PPUSH
9701: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9705: LD_VAR 0 1
9709: PPUSH
9710: CALL_OW 250
9714: PPUSH
9715: LD_VAR 0 1
9719: PPUSH
9720: CALL_OW 251
9724: PPUSH
9725: LD_INT 1
9727: PPUSH
9728: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9732: LD_VAR 0 1
9736: PPUSH
9737: CALL_OW 250
9741: PPUSH
9742: LD_VAR 0 1
9746: PPUSH
9747: CALL_OW 251
9751: PPUSH
9752: LD_INT 1
9754: PPUSH
9755: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9759: LD_VAR 0 1
9763: PPUSH
9764: CALL_OW 250
9768: PPUSH
9769: LD_VAR 0 1
9773: PPUSH
9774: CALL_OW 251
9778: PPUSH
9779: LD_INT 1
9781: PPUSH
9782: CALL_OW 453
// end ; end ;
9786: PPOPN 1
9788: END
// on EvacuateVehicle ( driver , un , c1 , c2 ) do begin if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) and not GetSide ( NearestUnit ( un ) ) = 2 then
9789: LD_VAR 0 2
9793: PUSH
9794: LD_INT 22
9796: PUSH
9797: LD_INT 2
9799: PUSH
9800: EMPTY
9801: LIST
9802: LIST
9803: PUSH
9804: LD_INT 21
9806: PUSH
9807: LD_INT 2
9809: PUSH
9810: EMPTY
9811: LIST
9812: LIST
9813: PUSH
9814: EMPTY
9815: LIST
9816: LIST
9817: PPUSH
9818: CALL_OW 69
9822: IN
9823: PUSH
9824: LD_VAR 0 2
9828: PPUSH
9829: CALL 10359 0 1
9833: PPUSH
9834: CALL_OW 255
9838: PUSH
9839: LD_INT 2
9841: EQUAL
9842: NOT
9843: AND
9844: IFFALSE 9969
// begin Wait ( Rand ( 0 0$03 , 0 0$06 ) ) ;
9846: LD_INT 105
9848: PPUSH
9849: LD_INT 210
9851: PPUSH
9852: CALL_OW 12
9856: PPUSH
9857: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9861: LD_VAR 0 2
9865: PPUSH
9866: CALL_OW 250
9870: PPUSH
9871: LD_VAR 0 2
9875: PPUSH
9876: CALL_OW 251
9880: PPUSH
9881: LD_INT 3
9883: PPUSH
9884: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9888: LD_VAR 0 2
9892: PPUSH
9893: CALL_OW 250
9897: PPUSH
9898: LD_VAR 0 2
9902: PPUSH
9903: CALL_OW 251
9907: PPUSH
9908: LD_INT 3
9910: PPUSH
9911: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9915: LD_VAR 0 2
9919: PPUSH
9920: CALL_OW 250
9924: PPUSH
9925: LD_VAR 0 2
9929: PPUSH
9930: CALL_OW 251
9934: PPUSH
9935: LD_INT 3
9937: PPUSH
9938: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9942: LD_VAR 0 2
9946: PPUSH
9947: CALL_OW 250
9951: PPUSH
9952: LD_VAR 0 2
9956: PPUSH
9957: CALL_OW 251
9961: PPUSH
9962: LD_INT 3
9964: PPUSH
9965: CALL_OW 453
// end ; end ;
9969: PPOPN 4
9971: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
9972: LD_VAR 0 1
9976: PPUSH
9977: LD_VAR 0 2
9981: PPUSH
9982: LD_VAR 0 3
9986: PPUSH
9987: CALL 15637 0 3
// end ;
9991: PPOPN 3
9993: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
9994: LD_VAR 0 1
9998: PPUSH
9999: CALL 15735 0 1
// end ; end_of_file
10003: PPOPN 1
10005: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
10006: LD_INT 0
10008: PPUSH
10009: PPUSH
10010: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
10011: LD_ADDR_VAR 0 7
10015: PUSH
10016: LD_VAR 0 1
10020: PUSH
10021: LD_VAR 0 2
10025: ARRAY
10026: PPUSH
10027: LD_VAR 0 3
10031: PPUSH
10032: LD_VAR 0 4
10036: PPUSH
10037: CALL_OW 1
10041: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
10042: LD_ADDR_VAR 0 1
10046: PUSH
10047: LD_VAR 0 1
10051: PPUSH
10052: LD_VAR 0 2
10056: PPUSH
10057: LD_VAR 0 7
10061: PPUSH
10062: CALL_OW 1
10066: ST_TO_ADDR
// result := tab ;
10067: LD_ADDR_VAR 0 5
10071: PUSH
10072: LD_VAR 0 1
10076: ST_TO_ADDR
// end ;
10077: LD_VAR 0 5
10081: RET
// export function IsDriver ( unit ) ; begin
10082: LD_INT 0
10084: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
10085: LD_VAR 0 1
10089: PUSH
10090: LD_INT 55
10092: PUSH
10093: EMPTY
10094: LIST
10095: PPUSH
10096: CALL_OW 69
10100: IN
10101: IFFALSE 10120
// result := IsInUnit ( unit ) else
10103: LD_ADDR_VAR 0 2
10107: PUSH
10108: LD_VAR 0 1
10112: PPUSH
10113: CALL_OW 310
10117: ST_TO_ADDR
10118: GO 10128
// result := false ;
10120: LD_ADDR_VAR 0 2
10124: PUSH
10125: LD_INT 0
10127: ST_TO_ADDR
// end ;
10128: LD_VAR 0 2
10132: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
10133: LD_INT 0
10135: PPUSH
10136: PPUSH
10137: PPUSH
// if not GetControl ( veh ) = control_manual then
10138: LD_VAR 0 1
10142: PPUSH
10143: CALL_OW 263
10147: PUSH
10148: LD_INT 1
10150: EQUAL
10151: NOT
10152: IFFALSE 10164
// result := false else
10154: LD_ADDR_VAR 0 2
10158: PUSH
10159: LD_INT 0
10161: ST_TO_ADDR
10162: GO 10309
// if veh in FilterAllUnits ( [ f_empty ] ) then
10164: LD_VAR 0 1
10168: PUSH
10169: LD_INT 58
10171: PUSH
10172: EMPTY
10173: LIST
10174: PPUSH
10175: CALL_OW 69
10179: IN
10180: IFFALSE 10192
// result := false else
10182: LD_ADDR_VAR 0 2
10186: PUSH
10187: LD_INT 0
10189: ST_TO_ADDR
10190: GO 10309
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
10192: LD_ADDR_VAR 0 4
10196: PUSH
10197: LD_INT 22
10199: PUSH
10200: LD_VAR 0 1
10204: PPUSH
10205: CALL_OW 255
10209: PUSH
10210: EMPTY
10211: LIST
10212: LIST
10213: PUSH
10214: LD_INT 55
10216: PUSH
10217: EMPTY
10218: LIST
10219: PUSH
10220: EMPTY
10221: LIST
10222: LIST
10223: PPUSH
10224: CALL_OW 69
10228: ST_TO_ADDR
// if not filter then
10229: LD_VAR 0 4
10233: NOT
10234: IFFALSE 10246
// result := false else
10236: LD_ADDR_VAR 0 2
10240: PUSH
10241: LD_INT 0
10243: ST_TO_ADDR
10244: GO 10309
// for i = 1 to filter do
10246: LD_ADDR_VAR 0 3
10250: PUSH
10251: DOUBLE
10252: LD_INT 1
10254: DEC
10255: ST_TO_ADDR
10256: LD_VAR 0 4
10260: PUSH
10261: FOR_TO
10262: IFFALSE 10307
// if IsDriver ( filter [ i ] ) = veh then
10264: LD_VAR 0 4
10268: PUSH
10269: LD_VAR 0 3
10273: ARRAY
10274: PPUSH
10275: CALL 10082 0 1
10279: PUSH
10280: LD_VAR 0 1
10284: EQUAL
10285: IFFALSE 10305
// begin result := filter [ i ] ;
10287: LD_ADDR_VAR 0 2
10291: PUSH
10292: LD_VAR 0 4
10296: PUSH
10297: LD_VAR 0 3
10301: ARRAY
10302: ST_TO_ADDR
// break ;
10303: GO 10307
// end ;
10305: GO 10261
10307: POP
10308: POP
// end ; end ;
10309: LD_VAR 0 2
10313: RET
// export function FindTarget ( unit ) ; begin
10314: LD_INT 0
10316: PPUSH
// result := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ;
10317: LD_ADDR_VAR 0 2
10321: PUSH
10322: LD_INT 81
10324: PUSH
10325: LD_VAR 0 1
10329: PPUSH
10330: CALL_OW 255
10334: PUSH
10335: EMPTY
10336: LIST
10337: LIST
10338: PPUSH
10339: CALL_OW 69
10343: PPUSH
10344: LD_VAR 0 1
10348: PPUSH
10349: CALL_OW 74
10353: ST_TO_ADDR
// end ;
10354: LD_VAR 0 2
10358: RET
// export function NearestUnit ( unit ) ; begin
10359: LD_INT 0
10361: PPUSH
// result := NearestUnitToUnit ( all_units diff unit , unit ) ;
10362: LD_ADDR_VAR 0 2
10366: PUSH
10367: LD_OWVAR 3
10371: PUSH
10372: LD_VAR 0 1
10376: DIFF
10377: PPUSH
10378: LD_VAR 0 1
10382: PPUSH
10383: CALL_OW 74
10387: ST_TO_ADDR
// end ; end_of_file
10388: LD_VAR 0 2
10392: RET
// every 12 12$00 do
10393: GO 10395
10395: DISABLE
// begin SetWeather ( 1 , 210 , 110 ) ;
10396: LD_INT 1
10398: PPUSH
10399: LD_INT 210
10401: PPUSH
10402: LD_INT 110
10404: PPUSH
10405: CALL_OW 550
// Wait ( Rand ( 5 5$00 , 10 10$00 ) ) ;
10409: LD_INT 10500
10411: PPUSH
10412: LD_INT 21000
10414: PPUSH
10415: CALL_OW 12
10419: PPUSH
10420: CALL_OW 67
// SetWeather ( 0 , 210 , 110 ) ;
10424: LD_INT 0
10426: PPUSH
10427: LD_INT 210
10429: PPUSH
10430: LD_INT 110
10432: PPUSH
10433: CALL_OW 550
// end ;
10437: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
10438: LD_INT 0
10440: PPUSH
10441: PPUSH
10442: PPUSH
10443: PPUSH
10444: PPUSH
// uc_nation = nation_nature ;
10445: LD_ADDR_OWVAR 21
10449: PUSH
10450: LD_INT 0
10452: ST_TO_ADDR
// uc_side = 0 ;
10453: LD_ADDR_OWVAR 20
10457: PUSH
10458: LD_INT 0
10460: ST_TO_ADDR
// l = 0 ;
10461: LD_ADDR_VAR 0 6
10465: PUSH
10466: LD_INT 0
10468: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
10469: LD_ADDR_OWVAR 24
10473: PUSH
10474: LD_INT 0
10476: PPUSH
10477: LD_INT 5
10479: PPUSH
10480: CALL_OW 12
10484: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
10485: LD_ADDR_OWVAR 35
10489: PUSH
10490: LD_INT 5
10492: NEG
10493: PPUSH
10494: LD_INT 5
10496: PPUSH
10497: CALL_OW 12
10501: ST_TO_ADDR
// hc_gallery =  ;
10502: LD_ADDR_OWVAR 33
10506: PUSH
10507: LD_STRING 
10509: ST_TO_ADDR
// hc_class = class_apeman ;
10510: LD_ADDR_OWVAR 28
10514: PUSH
10515: LD_INT 12
10517: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
10518: LD_ADDR_OWVAR 29
10522: PUSH
10523: LD_INT 11
10525: PPUSH
10526: LD_INT 13
10528: PPUSH
10529: CALL_OW 12
10533: PUSH
10534: LD_INT 10
10536: PPUSH
10537: LD_INT 11
10539: PPUSH
10540: CALL_OW 12
10544: PUSH
10545: EMPTY
10546: LIST
10547: LIST
10548: ST_TO_ADDR
// hc_sex = sex_male ;
10549: LD_ADDR_OWVAR 27
10553: PUSH
10554: LD_INT 1
10556: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
10557: LD_ADDR_OWVAR 31
10561: PUSH
10562: LD_INT 0
10564: PPUSH
10565: LD_INT 2
10567: PPUSH
10568: CALL_OW 12
10572: PUSH
10573: LD_INT 0
10575: PUSH
10576: LD_INT 0
10578: PUSH
10579: LD_INT 0
10581: PUSH
10582: EMPTY
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: ST_TO_ADDR
// apeman = CreateHuman ;
10588: LD_ADDR_VAR 0 7
10592: PUSH
10593: CALL_OW 44
10597: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
10598: LD_VAR 0 7
10602: PPUSH
10603: LD_VAR 0 4
10607: PPUSH
10608: LD_INT 0
10610: PPUSH
10611: CALL_OW 49
// l = l + 1 ;
10615: LD_ADDR_VAR 0 6
10619: PUSH
10620: LD_VAR 0 6
10624: PUSH
10625: LD_INT 1
10627: PLUS
10628: ST_TO_ADDR
// end until l = num1 ;
10629: LD_VAR 0 6
10633: PUSH
10634: LD_VAR 0 1
10638: EQUAL
10639: IFFALSE 10469
// l = 0 ;
10641: LD_ADDR_VAR 0 6
10645: PUSH
10646: LD_INT 0
10648: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
10649: LD_ADDR_OWVAR 35
10653: PUSH
10654: LD_INT 0
10656: PPUSH
10657: LD_INT 25
10659: PPUSH
10660: CALL_OW 12
10664: ST_TO_ADDR
// hc_class = class_tiger ;
10665: LD_ADDR_OWVAR 28
10669: PUSH
10670: LD_INT 14
10672: ST_TO_ADDR
// hc_sex = sex_male ;
10673: LD_ADDR_OWVAR 27
10677: PUSH
10678: LD_INT 1
10680: ST_TO_ADDR
// hc_gallery = sandnature ;
10681: LD_ADDR_OWVAR 33
10685: PUSH
10686: LD_STRING sandnature
10688: ST_TO_ADDR
// hc_face_number = 3 ;
10689: LD_ADDR_OWVAR 34
10693: PUSH
10694: LD_INT 3
10696: ST_TO_ADDR
// tiger = CreateHuman ;
10697: LD_ADDR_VAR 0 8
10701: PUSH
10702: CALL_OW 44
10706: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10707: LD_VAR 0 8
10711: PPUSH
10712: LD_VAR 0 4
10716: PPUSH
10717: LD_INT 0
10719: PPUSH
10720: CALL_OW 49
// l = l + 1 ;
10724: LD_ADDR_VAR 0 6
10728: PUSH
10729: LD_VAR 0 6
10733: PUSH
10734: LD_INT 1
10736: PLUS
10737: ST_TO_ADDR
// end until l = num2 ;
10738: LD_VAR 0 6
10742: PUSH
10743: LD_VAR 0 2
10747: EQUAL
10748: IFFALSE 10649
// l = 0 ;
10750: LD_ADDR_VAR 0 6
10754: PUSH
10755: LD_INT 0
10757: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
10758: LD_ADDR_OWVAR 28
10762: PUSH
10763: LD_INT 18
10765: ST_TO_ADDR
// hc_gallery = sandnature ;
10766: LD_ADDR_OWVAR 33
10770: PUSH
10771: LD_STRING sandnature
10773: ST_TO_ADDR
// hc_face_number = 1 ;
10774: LD_ADDR_OWVAR 34
10778: PUSH
10779: LD_INT 1
10781: ST_TO_ADDR
// bird = CreateHuman ;
10782: LD_ADDR_VAR 0 9
10786: PUSH
10787: CALL_OW 44
10791: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
10792: LD_VAR 0 9
10796: PPUSH
10797: LD_INT 0
10799: PPUSH
10800: CALL_OW 51
// l = l + 1 ;
10804: LD_ADDR_VAR 0 6
10808: PUSH
10809: LD_VAR 0 6
10813: PUSH
10814: LD_INT 1
10816: PLUS
10817: ST_TO_ADDR
// end until l = num3 ;
10818: LD_VAR 0 6
10822: PUSH
10823: LD_VAR 0 3
10827: EQUAL
10828: IFFALSE 10758
// end ; end_of_file
10830: LD_VAR 0 5
10834: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
10835: GO 10837
10837: DISABLE
// begin ru_radar := 98 ;
10838: LD_ADDR_EXP 25
10842: PUSH
10843: LD_INT 98
10845: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
10846: LD_ADDR_EXP 26
10850: PUSH
10851: LD_INT 89
10853: ST_TO_ADDR
// us_hack := 99 ;
10854: LD_ADDR_EXP 27
10858: PUSH
10859: LD_INT 99
10861: ST_TO_ADDR
// us_artillery := 97 ;
10862: LD_ADDR_EXP 28
10866: PUSH
10867: LD_INT 97
10869: ST_TO_ADDR
// ar_bio_bomb := 91 ;
10870: LD_ADDR_EXP 29
10874: PUSH
10875: LD_INT 91
10877: ST_TO_ADDR
// end ; end_of_file end_of_file
10878: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu ; every 0 0$1 do
10879: GO 10881
10881: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
10882: LD_STRING initStreamRollete();
10884: PPUSH
10885: CALL_OW 559
// InitStreamMode ;
10889: CALL 10894 0 0
// end ;
10893: END
// function InitStreamMode ; begin
10894: LD_INT 0
10896: PPUSH
// streamModeActive := false ;
10897: LD_ADDR_EXP 30
10901: PUSH
10902: LD_INT 0
10904: ST_TO_ADDR
// sRocket := false ;
10905: LD_ADDR_EXP 33
10909: PUSH
10910: LD_INT 0
10912: ST_TO_ADDR
// sSpeed := false ;
10913: LD_ADDR_EXP 32
10917: PUSH
10918: LD_INT 0
10920: ST_TO_ADDR
// sEngine := false ;
10921: LD_ADDR_EXP 34
10925: PUSH
10926: LD_INT 0
10928: ST_TO_ADDR
// sSpec := false ;
10929: LD_ADDR_EXP 31
10933: PUSH
10934: LD_INT 0
10936: ST_TO_ADDR
// sLevel := false ;
10937: LD_ADDR_EXP 35
10941: PUSH
10942: LD_INT 0
10944: ST_TO_ADDR
// sArmoury := false ;
10945: LD_ADDR_EXP 36
10949: PUSH
10950: LD_INT 0
10952: ST_TO_ADDR
// sRadar := false ;
10953: LD_ADDR_EXP 37
10957: PUSH
10958: LD_INT 0
10960: ST_TO_ADDR
// sBunker := false ;
10961: LD_ADDR_EXP 38
10965: PUSH
10966: LD_INT 0
10968: ST_TO_ADDR
// sHack := false ;
10969: LD_ADDR_EXP 39
10973: PUSH
10974: LD_INT 0
10976: ST_TO_ADDR
// sFire := false ;
10977: LD_ADDR_EXP 40
10981: PUSH
10982: LD_INT 0
10984: ST_TO_ADDR
// sRefresh := false ;
10985: LD_ADDR_EXP 41
10989: PUSH
10990: LD_INT 0
10992: ST_TO_ADDR
// sExp := false ;
10993: LD_ADDR_EXP 42
10997: PUSH
10998: LD_INT 0
11000: ST_TO_ADDR
// sDepot := false ;
11001: LD_ADDR_EXP 43
11005: PUSH
11006: LD_INT 0
11008: ST_TO_ADDR
// sFlag := false ;
11009: LD_ADDR_EXP 44
11013: PUSH
11014: LD_INT 0
11016: ST_TO_ADDR
// sKamikadze := false ;
11017: LD_ADDR_EXP 52
11021: PUSH
11022: LD_INT 0
11024: ST_TO_ADDR
// sTroll := false ;
11025: LD_ADDR_EXP 53
11029: PUSH
11030: LD_INT 0
11032: ST_TO_ADDR
// sSlow := false ;
11033: LD_ADDR_EXP 54
11037: PUSH
11038: LD_INT 0
11040: ST_TO_ADDR
// sLack := false ;
11041: LD_ADDR_EXP 55
11045: PUSH
11046: LD_INT 0
11048: ST_TO_ADDR
// sTank := false ;
11049: LD_ADDR_EXP 57
11053: PUSH
11054: LD_INT 0
11056: ST_TO_ADDR
// sRemote := false ;
11057: LD_ADDR_EXP 58
11061: PUSH
11062: LD_INT 0
11064: ST_TO_ADDR
// sPowell := false ;
11065: LD_ADDR_EXP 59
11069: PUSH
11070: LD_INT 0
11072: ST_TO_ADDR
// sTeleport := false ;
11073: LD_ADDR_EXP 62
11077: PUSH
11078: LD_INT 0
11080: ST_TO_ADDR
// sOilTower := false ;
11081: LD_ADDR_EXP 64
11085: PUSH
11086: LD_INT 0
11088: ST_TO_ADDR
// sShovel := false ;
11089: LD_ADDR_EXP 65
11093: PUSH
11094: LD_INT 0
11096: ST_TO_ADDR
// sSheik := false ;
11097: LD_ADDR_EXP 66
11101: PUSH
11102: LD_INT 0
11104: ST_TO_ADDR
// sSold := false ;
11105: LD_ADDR_EXP 45
11109: PUSH
11110: LD_INT 0
11112: ST_TO_ADDR
// sDiff := false ;
11113: LD_ADDR_EXP 46
11117: PUSH
11118: LD_INT 0
11120: ST_TO_ADDR
// sFog := false ;
11121: LD_ADDR_EXP 49
11125: PUSH
11126: LD_INT 0
11128: ST_TO_ADDR
// sReset := false ;
11129: LD_ADDR_EXP 50
11133: PUSH
11134: LD_INT 0
11136: ST_TO_ADDR
// sSun := false ;
11137: LD_ADDR_EXP 51
11141: PUSH
11142: LD_INT 0
11144: ST_TO_ADDR
// sTiger := false ;
11145: LD_ADDR_EXP 47
11149: PUSH
11150: LD_INT 0
11152: ST_TO_ADDR
// sBomb := false ;
11153: LD_ADDR_EXP 48
11157: PUSH
11158: LD_INT 0
11160: ST_TO_ADDR
// sWound := false ;
11161: LD_ADDR_EXP 56
11165: PUSH
11166: LD_INT 0
11168: ST_TO_ADDR
// sBetray := false ;
11169: LD_ADDR_EXP 60
11173: PUSH
11174: LD_INT 0
11176: ST_TO_ADDR
// sContamin := false ;
11177: LD_ADDR_EXP 61
11181: PUSH
11182: LD_INT 0
11184: ST_TO_ADDR
// sOil := false ;
11185: LD_ADDR_EXP 63
11189: PUSH
11190: LD_INT 0
11192: ST_TO_ADDR
// sStu := false ;
11193: LD_ADDR_EXP 67
11197: PUSH
11198: LD_INT 0
11200: ST_TO_ADDR
// end ;
11201: LD_VAR 0 1
11205: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
11206: LD_VAR 0 2
11210: PUSH
11211: LD_INT 100
11213: EQUAL
11214: IFFALSE 11911
// begin if not StreamModeActive then
11216: LD_EXP 30
11220: NOT
11221: IFFALSE 11231
// StreamModeActive := true ;
11223: LD_ADDR_EXP 30
11227: PUSH
11228: LD_INT 1
11230: ST_TO_ADDR
// if p3 = 0 then
11231: LD_VAR 0 3
11235: PUSH
11236: LD_INT 0
11238: EQUAL
11239: IFFALSE 11245
// InitStreamMode ;
11241: CALL 10894 0 0
// if p3 = 1 then
11245: LD_VAR 0 3
11249: PUSH
11250: LD_INT 1
11252: EQUAL
11253: IFFALSE 11263
// sRocket := true ;
11255: LD_ADDR_EXP 33
11259: PUSH
11260: LD_INT 1
11262: ST_TO_ADDR
// if p3 = 2 then
11263: LD_VAR 0 3
11267: PUSH
11268: LD_INT 2
11270: EQUAL
11271: IFFALSE 11281
// sSpeed := true ;
11273: LD_ADDR_EXP 32
11277: PUSH
11278: LD_INT 1
11280: ST_TO_ADDR
// if p3 = 3 then
11281: LD_VAR 0 3
11285: PUSH
11286: LD_INT 3
11288: EQUAL
11289: IFFALSE 11299
// sEngine := true ;
11291: LD_ADDR_EXP 34
11295: PUSH
11296: LD_INT 1
11298: ST_TO_ADDR
// if p3 = 4 then
11299: LD_VAR 0 3
11303: PUSH
11304: LD_INT 4
11306: EQUAL
11307: IFFALSE 11317
// sSpec := true ;
11309: LD_ADDR_EXP 31
11313: PUSH
11314: LD_INT 1
11316: ST_TO_ADDR
// if p3 = 5 then
11317: LD_VAR 0 3
11321: PUSH
11322: LD_INT 5
11324: EQUAL
11325: IFFALSE 11335
// sLevel := true ;
11327: LD_ADDR_EXP 35
11331: PUSH
11332: LD_INT 1
11334: ST_TO_ADDR
// if p3 = 6 then
11335: LD_VAR 0 3
11339: PUSH
11340: LD_INT 6
11342: EQUAL
11343: IFFALSE 11353
// sArmoury := true ;
11345: LD_ADDR_EXP 36
11349: PUSH
11350: LD_INT 1
11352: ST_TO_ADDR
// if p3 = 7 then
11353: LD_VAR 0 3
11357: PUSH
11358: LD_INT 7
11360: EQUAL
11361: IFFALSE 11371
// sRadar := true ;
11363: LD_ADDR_EXP 37
11367: PUSH
11368: LD_INT 1
11370: ST_TO_ADDR
// if p3 = 8 then
11371: LD_VAR 0 3
11375: PUSH
11376: LD_INT 8
11378: EQUAL
11379: IFFALSE 11389
// sBunker := true ;
11381: LD_ADDR_EXP 38
11385: PUSH
11386: LD_INT 1
11388: ST_TO_ADDR
// if p3 = 9 then
11389: LD_VAR 0 3
11393: PUSH
11394: LD_INT 9
11396: EQUAL
11397: IFFALSE 11407
// sHack := true ;
11399: LD_ADDR_EXP 39
11403: PUSH
11404: LD_INT 1
11406: ST_TO_ADDR
// if p3 = 10 then
11407: LD_VAR 0 3
11411: PUSH
11412: LD_INT 10
11414: EQUAL
11415: IFFALSE 11425
// sFire := true ;
11417: LD_ADDR_EXP 40
11421: PUSH
11422: LD_INT 1
11424: ST_TO_ADDR
// if p3 = 11 then
11425: LD_VAR 0 3
11429: PUSH
11430: LD_INT 11
11432: EQUAL
11433: IFFALSE 11443
// sRefresh := true ;
11435: LD_ADDR_EXP 41
11439: PUSH
11440: LD_INT 1
11442: ST_TO_ADDR
// if p3 = 12 then
11443: LD_VAR 0 3
11447: PUSH
11448: LD_INT 12
11450: EQUAL
11451: IFFALSE 11461
// sExp := true ;
11453: LD_ADDR_EXP 42
11457: PUSH
11458: LD_INT 1
11460: ST_TO_ADDR
// if p3 = 13 then
11461: LD_VAR 0 3
11465: PUSH
11466: LD_INT 13
11468: EQUAL
11469: IFFALSE 11479
// sDepot := true ;
11471: LD_ADDR_EXP 43
11475: PUSH
11476: LD_INT 1
11478: ST_TO_ADDR
// if p3 = 14 then
11479: LD_VAR 0 3
11483: PUSH
11484: LD_INT 14
11486: EQUAL
11487: IFFALSE 11497
// sFlag := true ;
11489: LD_ADDR_EXP 44
11493: PUSH
11494: LD_INT 1
11496: ST_TO_ADDR
// if p3 = 15 then
11497: LD_VAR 0 3
11501: PUSH
11502: LD_INT 15
11504: EQUAL
11505: IFFALSE 11515
// sKamikadze := true ;
11507: LD_ADDR_EXP 52
11511: PUSH
11512: LD_INT 1
11514: ST_TO_ADDR
// if p3 = 16 then
11515: LD_VAR 0 3
11519: PUSH
11520: LD_INT 16
11522: EQUAL
11523: IFFALSE 11533
// sTroll := true ;
11525: LD_ADDR_EXP 53
11529: PUSH
11530: LD_INT 1
11532: ST_TO_ADDR
// if p3 = 17 then
11533: LD_VAR 0 3
11537: PUSH
11538: LD_INT 17
11540: EQUAL
11541: IFFALSE 11551
// sSlow := true ;
11543: LD_ADDR_EXP 54
11547: PUSH
11548: LD_INT 1
11550: ST_TO_ADDR
// if p3 = 18 then
11551: LD_VAR 0 3
11555: PUSH
11556: LD_INT 18
11558: EQUAL
11559: IFFALSE 11569
// sLack := true ;
11561: LD_ADDR_EXP 55
11565: PUSH
11566: LD_INT 1
11568: ST_TO_ADDR
// if p3 = 19 then
11569: LD_VAR 0 3
11573: PUSH
11574: LD_INT 19
11576: EQUAL
11577: IFFALSE 11587
// sTank := true ;
11579: LD_ADDR_EXP 57
11583: PUSH
11584: LD_INT 1
11586: ST_TO_ADDR
// if p3 = 20 then
11587: LD_VAR 0 3
11591: PUSH
11592: LD_INT 20
11594: EQUAL
11595: IFFALSE 11605
// sRemote := true ;
11597: LD_ADDR_EXP 58
11601: PUSH
11602: LD_INT 1
11604: ST_TO_ADDR
// if p3 = 21 then
11605: LD_VAR 0 3
11609: PUSH
11610: LD_INT 21
11612: EQUAL
11613: IFFALSE 11623
// sPowell := true ;
11615: LD_ADDR_EXP 59
11619: PUSH
11620: LD_INT 1
11622: ST_TO_ADDR
// if p3 = 22 then
11623: LD_VAR 0 3
11627: PUSH
11628: LD_INT 22
11630: EQUAL
11631: IFFALSE 11641
// sTeleport := true ;
11633: LD_ADDR_EXP 62
11637: PUSH
11638: LD_INT 1
11640: ST_TO_ADDR
// if p3 = 23 then
11641: LD_VAR 0 3
11645: PUSH
11646: LD_INT 23
11648: EQUAL
11649: IFFALSE 11659
// sOilTower := true ;
11651: LD_ADDR_EXP 64
11655: PUSH
11656: LD_INT 1
11658: ST_TO_ADDR
// if p3 = 24 then
11659: LD_VAR 0 3
11663: PUSH
11664: LD_INT 24
11666: EQUAL
11667: IFFALSE 11677
// sShovel := true ;
11669: LD_ADDR_EXP 65
11673: PUSH
11674: LD_INT 1
11676: ST_TO_ADDR
// if p3 = 25 then
11677: LD_VAR 0 3
11681: PUSH
11682: LD_INT 25
11684: EQUAL
11685: IFFALSE 11695
// sSheik := true ;
11687: LD_ADDR_EXP 66
11691: PUSH
11692: LD_INT 1
11694: ST_TO_ADDR
// if p3 = 101 then
11695: LD_VAR 0 3
11699: PUSH
11700: LD_INT 101
11702: EQUAL
11703: IFFALSE 11713
// sSold := true ;
11705: LD_ADDR_EXP 45
11709: PUSH
11710: LD_INT 1
11712: ST_TO_ADDR
// if p3 = 102 then
11713: LD_VAR 0 3
11717: PUSH
11718: LD_INT 102
11720: EQUAL
11721: IFFALSE 11731
// sDiff := true ;
11723: LD_ADDR_EXP 46
11727: PUSH
11728: LD_INT 1
11730: ST_TO_ADDR
// if p3 = 103 then
11731: LD_VAR 0 3
11735: PUSH
11736: LD_INT 103
11738: EQUAL
11739: IFFALSE 11749
// sFog := true ;
11741: LD_ADDR_EXP 49
11745: PUSH
11746: LD_INT 1
11748: ST_TO_ADDR
// if p3 = 104 then
11749: LD_VAR 0 3
11753: PUSH
11754: LD_INT 104
11756: EQUAL
11757: IFFALSE 11767
// sReset := true ;
11759: LD_ADDR_EXP 50
11763: PUSH
11764: LD_INT 1
11766: ST_TO_ADDR
// if p3 = 105 then
11767: LD_VAR 0 3
11771: PUSH
11772: LD_INT 105
11774: EQUAL
11775: IFFALSE 11785
// sSun := true ;
11777: LD_ADDR_EXP 51
11781: PUSH
11782: LD_INT 1
11784: ST_TO_ADDR
// if p3 = 106 then
11785: LD_VAR 0 3
11789: PUSH
11790: LD_INT 106
11792: EQUAL
11793: IFFALSE 11803
// sTiger := true ;
11795: LD_ADDR_EXP 47
11799: PUSH
11800: LD_INT 1
11802: ST_TO_ADDR
// if p3 = 107 then
11803: LD_VAR 0 3
11807: PUSH
11808: LD_INT 107
11810: EQUAL
11811: IFFALSE 11821
// sBomb := true ;
11813: LD_ADDR_EXP 48
11817: PUSH
11818: LD_INT 1
11820: ST_TO_ADDR
// if p3 = 108 then
11821: LD_VAR 0 3
11825: PUSH
11826: LD_INT 108
11828: EQUAL
11829: IFFALSE 11839
// sWound := true ;
11831: LD_ADDR_EXP 56
11835: PUSH
11836: LD_INT 1
11838: ST_TO_ADDR
// if p3 = 109 then
11839: LD_VAR 0 3
11843: PUSH
11844: LD_INT 109
11846: EQUAL
11847: IFFALSE 11857
// sBetray := true ;
11849: LD_ADDR_EXP 60
11853: PUSH
11854: LD_INT 1
11856: ST_TO_ADDR
// if p3 = 110 then
11857: LD_VAR 0 3
11861: PUSH
11862: LD_INT 110
11864: EQUAL
11865: IFFALSE 11875
// sContamin := true ;
11867: LD_ADDR_EXP 61
11871: PUSH
11872: LD_INT 1
11874: ST_TO_ADDR
// if p3 = 111 then
11875: LD_VAR 0 3
11879: PUSH
11880: LD_INT 111
11882: EQUAL
11883: IFFALSE 11893
// sOil := true ;
11885: LD_ADDR_EXP 63
11889: PUSH
11890: LD_INT 1
11892: ST_TO_ADDR
// if p3 = 112 then
11893: LD_VAR 0 3
11897: PUSH
11898: LD_INT 112
11900: EQUAL
11901: IFFALSE 11911
// sStu := true ;
11903: LD_ADDR_EXP 67
11907: PUSH
11908: LD_INT 1
11910: ST_TO_ADDR
// end ; end ;
11911: PPOPN 6
11913: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
11914: LD_EXP 30
11918: PUSH
11919: LD_EXP 33
11923: AND
11924: IFFALSE 12048
11926: GO 11928
11928: DISABLE
11929: LD_INT 0
11931: PPUSH
11932: PPUSH
// begin enable ;
11933: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
11934: LD_ADDR_VAR 0 2
11938: PUSH
11939: LD_INT 22
11941: PUSH
11942: LD_OWVAR 2
11946: PUSH
11947: EMPTY
11948: LIST
11949: LIST
11950: PUSH
11951: LD_INT 2
11953: PUSH
11954: LD_INT 34
11956: PUSH
11957: LD_INT 7
11959: PUSH
11960: EMPTY
11961: LIST
11962: LIST
11963: PUSH
11964: LD_INT 34
11966: PUSH
11967: LD_INT 45
11969: PUSH
11970: EMPTY
11971: LIST
11972: LIST
11973: PUSH
11974: LD_INT 34
11976: PUSH
11977: LD_INT 28
11979: PUSH
11980: EMPTY
11981: LIST
11982: LIST
11983: PUSH
11984: LD_INT 34
11986: PUSH
11987: LD_INT 47
11989: PUSH
11990: EMPTY
11991: LIST
11992: LIST
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: LIST
12000: PUSH
12001: EMPTY
12002: LIST
12003: LIST
12004: PPUSH
12005: CALL_OW 69
12009: ST_TO_ADDR
// if not tmp then
12010: LD_VAR 0 2
12014: NOT
12015: IFFALSE 12019
// exit ;
12017: GO 12048
// for i in tmp do
12019: LD_ADDR_VAR 0 1
12023: PUSH
12024: LD_VAR 0 2
12028: PUSH
12029: FOR_IN
12030: IFFALSE 12046
// begin SetLives ( i , 0 ) ;
12032: LD_VAR 0 1
12036: PPUSH
12037: LD_INT 0
12039: PPUSH
12040: CALL_OW 234
// end ;
12044: GO 12029
12046: POP
12047: POP
// end ;
12048: PPOPN 2
12050: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
12051: LD_EXP 30
12055: PUSH
12056: LD_EXP 34
12060: AND
12061: IFFALSE 12142
12063: GO 12065
12065: DISABLE
12066: LD_INT 0
12068: PPUSH
12069: PPUSH
// begin enable ;
12070: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
12071: LD_ADDR_VAR 0 2
12075: PUSH
12076: LD_INT 22
12078: PUSH
12079: LD_OWVAR 2
12083: PUSH
12084: EMPTY
12085: LIST
12086: LIST
12087: PUSH
12088: LD_INT 32
12090: PUSH
12091: LD_INT 3
12093: PUSH
12094: EMPTY
12095: LIST
12096: LIST
12097: PUSH
12098: EMPTY
12099: LIST
12100: LIST
12101: PPUSH
12102: CALL_OW 69
12106: ST_TO_ADDR
// if not tmp then
12107: LD_VAR 0 2
12111: NOT
12112: IFFALSE 12116
// exit ;
12114: GO 12142
// for i in tmp do
12116: LD_ADDR_VAR 0 1
12120: PUSH
12121: LD_VAR 0 2
12125: PUSH
12126: FOR_IN
12127: IFFALSE 12140
// begin DestroyUnit ( i ) ;
12129: LD_VAR 0 1
12133: PPUSH
12134: CALL_OW 65
// end ;
12138: GO 12126
12140: POP
12141: POP
// end ;
12142: PPOPN 2
12144: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
12145: LD_EXP 30
12149: PUSH
12150: LD_EXP 31
12154: AND
12155: IFFALSE 12248
12157: GO 12159
12159: DISABLE
12160: LD_INT 0
12162: PPUSH
// begin enable ;
12163: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
12164: LD_ADDR_VAR 0 1
12168: PUSH
12169: LD_INT 22
12171: PUSH
12172: LD_OWVAR 2
12176: PUSH
12177: EMPTY
12178: LIST
12179: LIST
12180: PUSH
12181: LD_INT 2
12183: PUSH
12184: LD_INT 25
12186: PUSH
12187: LD_INT 5
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: PUSH
12194: LD_INT 25
12196: PUSH
12197: LD_INT 9
12199: PUSH
12200: EMPTY
12201: LIST
12202: LIST
12203: PUSH
12204: LD_INT 25
12206: PUSH
12207: LD_INT 8
12209: PUSH
12210: EMPTY
12211: LIST
12212: LIST
12213: PUSH
12214: EMPTY
12215: LIST
12216: LIST
12217: LIST
12218: LIST
12219: PUSH
12220: EMPTY
12221: LIST
12222: LIST
12223: PPUSH
12224: CALL_OW 69
12228: PUSH
12229: FOR_IN
12230: IFFALSE 12246
// begin SetClass ( i , 1 ) ;
12232: LD_VAR 0 1
12236: PPUSH
12237: LD_INT 1
12239: PPUSH
12240: CALL_OW 336
// end ;
12244: GO 12229
12246: POP
12247: POP
// end ;
12248: PPOPN 1
12250: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
12251: LD_EXP 30
12255: PUSH
12256: LD_EXP 32
12260: AND
12261: PUSH
12262: LD_OWVAR 65
12266: PUSH
12267: LD_INT 7
12269: LESS
12270: AND
12271: IFFALSE 12285
12273: GO 12275
12275: DISABLE
// begin enable ;
12276: ENABLE
// game_speed := 7 ;
12277: LD_ADDR_OWVAR 65
12281: PUSH
12282: LD_INT 7
12284: ST_TO_ADDR
// end ;
12285: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
12286: LD_EXP 30
12290: PUSH
12291: LD_EXP 35
12295: AND
12296: IFFALSE 12498
12298: GO 12300
12300: DISABLE
12301: LD_INT 0
12303: PPUSH
12304: PPUSH
12305: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
12306: LD_ADDR_VAR 0 3
12310: PUSH
12311: LD_INT 81
12313: PUSH
12314: LD_OWVAR 2
12318: PUSH
12319: EMPTY
12320: LIST
12321: LIST
12322: PUSH
12323: LD_INT 21
12325: PUSH
12326: LD_INT 1
12328: PUSH
12329: EMPTY
12330: LIST
12331: LIST
12332: PUSH
12333: EMPTY
12334: LIST
12335: LIST
12336: PPUSH
12337: CALL_OW 69
12341: ST_TO_ADDR
// if not tmp then
12342: LD_VAR 0 3
12346: NOT
12347: IFFALSE 12351
// exit ;
12349: GO 12498
// if tmp > 5 then
12351: LD_VAR 0 3
12355: PUSH
12356: LD_INT 5
12358: GREATER
12359: IFFALSE 12371
// k := 5 else
12361: LD_ADDR_VAR 0 2
12365: PUSH
12366: LD_INT 5
12368: ST_TO_ADDR
12369: GO 12381
// k := tmp ;
12371: LD_ADDR_VAR 0 2
12375: PUSH
12376: LD_VAR 0 3
12380: ST_TO_ADDR
// for i := 1 to k do
12381: LD_ADDR_VAR 0 1
12385: PUSH
12386: DOUBLE
12387: LD_INT 1
12389: DEC
12390: ST_TO_ADDR
12391: LD_VAR 0 2
12395: PUSH
12396: FOR_TO
12397: IFFALSE 12496
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
12399: LD_VAR 0 3
12403: PUSH
12404: LD_VAR 0 1
12408: ARRAY
12409: PPUSH
12410: LD_VAR 0 1
12414: PUSH
12415: LD_INT 4
12417: MOD
12418: PUSH
12419: LD_INT 1
12421: PLUS
12422: PPUSH
12423: CALL_OW 259
12427: PUSH
12428: LD_INT 10
12430: LESS
12431: IFFALSE 12494
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
12433: LD_VAR 0 3
12437: PUSH
12438: LD_VAR 0 1
12442: ARRAY
12443: PPUSH
12444: LD_VAR 0 1
12448: PUSH
12449: LD_INT 4
12451: MOD
12452: PUSH
12453: LD_INT 1
12455: PLUS
12456: PPUSH
12457: LD_VAR 0 3
12461: PUSH
12462: LD_VAR 0 1
12466: ARRAY
12467: PPUSH
12468: LD_VAR 0 1
12472: PUSH
12473: LD_INT 4
12475: MOD
12476: PUSH
12477: LD_INT 1
12479: PLUS
12480: PPUSH
12481: CALL_OW 259
12485: PUSH
12486: LD_INT 1
12488: PLUS
12489: PPUSH
12490: CALL_OW 237
12494: GO 12396
12496: POP
12497: POP
// end ;
12498: PPOPN 3
12500: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
12501: LD_EXP 30
12505: PUSH
12506: LD_EXP 36
12510: AND
12511: IFFALSE 12531
12513: GO 12515
12515: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
12516: LD_INT 4
12518: PPUSH
12519: LD_OWVAR 2
12523: PPUSH
12524: LD_INT 0
12526: PPUSH
12527: CALL_OW 324
12531: END
// every 0 0$1 trigger StreamModeActive and sShovel do
12532: LD_EXP 30
12536: PUSH
12537: LD_EXP 65
12541: AND
12542: IFFALSE 12562
12544: GO 12546
12546: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
12547: LD_INT 19
12549: PPUSH
12550: LD_OWVAR 2
12554: PPUSH
12555: LD_INT 0
12557: PPUSH
12558: CALL_OW 324
12562: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
12563: LD_EXP 30
12567: PUSH
12568: LD_EXP 37
12572: AND
12573: IFFALSE 12672
12575: GO 12577
12577: DISABLE
12578: LD_INT 0
12580: PPUSH
12581: PPUSH
// begin enable ;
12582: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
12583: LD_ADDR_VAR 0 2
12587: PUSH
12588: LD_INT 22
12590: PUSH
12591: LD_OWVAR 2
12595: PUSH
12596: EMPTY
12597: LIST
12598: LIST
12599: PUSH
12600: LD_INT 2
12602: PUSH
12603: LD_INT 34
12605: PUSH
12606: LD_INT 11
12608: PUSH
12609: EMPTY
12610: LIST
12611: LIST
12612: PUSH
12613: LD_INT 34
12615: PUSH
12616: LD_INT 30
12618: PUSH
12619: EMPTY
12620: LIST
12621: LIST
12622: PUSH
12623: EMPTY
12624: LIST
12625: LIST
12626: LIST
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PPUSH
12632: CALL_OW 69
12636: ST_TO_ADDR
// if not tmp then
12637: LD_VAR 0 2
12641: NOT
12642: IFFALSE 12646
// exit ;
12644: GO 12672
// for i in tmp do
12646: LD_ADDR_VAR 0 1
12650: PUSH
12651: LD_VAR 0 2
12655: PUSH
12656: FOR_IN
12657: IFFALSE 12670
// begin DestroyUnit ( i ) ;
12659: LD_VAR 0 1
12663: PPUSH
12664: CALL_OW 65
// end ;
12668: GO 12656
12670: POP
12671: POP
// end ;
12672: PPOPN 2
12674: END
// every 0 0$1 trigger StreamModeActive and sBunker do
12675: LD_EXP 30
12679: PUSH
12680: LD_EXP 38
12684: AND
12685: IFFALSE 12705
12687: GO 12689
12689: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
12690: LD_INT 32
12692: PPUSH
12693: LD_OWVAR 2
12697: PPUSH
12698: LD_INT 0
12700: PPUSH
12701: CALL_OW 324
12705: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
12706: LD_EXP 30
12710: PUSH
12711: LD_EXP 39
12715: AND
12716: IFFALSE 12897
12718: GO 12720
12720: DISABLE
12721: LD_INT 0
12723: PPUSH
12724: PPUSH
12725: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
12726: LD_ADDR_VAR 0 2
12730: PUSH
12731: LD_INT 22
12733: PUSH
12734: LD_OWVAR 2
12738: PUSH
12739: EMPTY
12740: LIST
12741: LIST
12742: PUSH
12743: LD_INT 33
12745: PUSH
12746: LD_INT 3
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: PUSH
12753: EMPTY
12754: LIST
12755: LIST
12756: PPUSH
12757: CALL_OW 69
12761: ST_TO_ADDR
// if not tmp then
12762: LD_VAR 0 2
12766: NOT
12767: IFFALSE 12771
// exit ;
12769: GO 12897
// side := 0 ;
12771: LD_ADDR_VAR 0 3
12775: PUSH
12776: LD_INT 0
12778: ST_TO_ADDR
// for i := 1 to 8 do
12779: LD_ADDR_VAR 0 1
12783: PUSH
12784: DOUBLE
12785: LD_INT 1
12787: DEC
12788: ST_TO_ADDR
12789: LD_INT 8
12791: PUSH
12792: FOR_TO
12793: IFFALSE 12841
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
12795: LD_OWVAR 2
12799: PUSH
12800: LD_VAR 0 1
12804: NONEQUAL
12805: PUSH
12806: LD_OWVAR 2
12810: PPUSH
12811: LD_VAR 0 1
12815: PPUSH
12816: CALL_OW 81
12820: PUSH
12821: LD_INT 2
12823: EQUAL
12824: AND
12825: IFFALSE 12839
// begin side := i ;
12827: LD_ADDR_VAR 0 3
12831: PUSH
12832: LD_VAR 0 1
12836: ST_TO_ADDR
// break ;
12837: GO 12841
// end ;
12839: GO 12792
12841: POP
12842: POP
// if not side then
12843: LD_VAR 0 3
12847: NOT
12848: IFFALSE 12852
// exit ;
12850: GO 12897
// for i := 1 to tmp do
12852: LD_ADDR_VAR 0 1
12856: PUSH
12857: DOUBLE
12858: LD_INT 1
12860: DEC
12861: ST_TO_ADDR
12862: LD_VAR 0 2
12866: PUSH
12867: FOR_TO
12868: IFFALSE 12895
// if Prob ( 30 ) then
12870: LD_INT 30
12872: PPUSH
12873: CALL_OW 13
12877: IFFALSE 12893
// SetSide ( i , side ) ;
12879: LD_VAR 0 1
12883: PPUSH
12884: LD_VAR 0 3
12888: PPUSH
12889: CALL_OW 235
12893: GO 12867
12895: POP
12896: POP
// end ;
12897: PPOPN 3
12899: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
12900: LD_EXP 30
12904: PUSH
12905: LD_EXP 41
12909: AND
12910: IFFALSE 13029
12912: GO 12914
12914: DISABLE
12915: LD_INT 0
12917: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
12918: LD_ADDR_VAR 0 1
12922: PUSH
12923: LD_INT 22
12925: PUSH
12926: LD_OWVAR 2
12930: PUSH
12931: EMPTY
12932: LIST
12933: LIST
12934: PUSH
12935: LD_INT 21
12937: PUSH
12938: LD_INT 1
12940: PUSH
12941: EMPTY
12942: LIST
12943: LIST
12944: PUSH
12945: LD_INT 3
12947: PUSH
12948: LD_INT 23
12950: PUSH
12951: LD_INT 0
12953: PUSH
12954: EMPTY
12955: LIST
12956: LIST
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: LIST
12966: PPUSH
12967: CALL_OW 69
12971: PUSH
12972: FOR_IN
12973: IFFALSE 13027
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
12975: LD_VAR 0 1
12979: PPUSH
12980: CALL_OW 257
12984: PUSH
12985: LD_INT 1
12987: PUSH
12988: LD_INT 2
12990: PUSH
12991: LD_INT 3
12993: PUSH
12994: LD_INT 4
12996: PUSH
12997: EMPTY
12998: LIST
12999: LIST
13000: LIST
13001: LIST
13002: IN
13003: IFFALSE 13025
// SetClass ( un , rand ( 1 , 4 ) ) ;
13005: LD_VAR 0 1
13009: PPUSH
13010: LD_INT 1
13012: PPUSH
13013: LD_INT 4
13015: PPUSH
13016: CALL_OW 12
13020: PPUSH
13021: CALL_OW 336
13025: GO 12972
13027: POP
13028: POP
// end ;
13029: PPOPN 1
13031: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
13032: LD_EXP 30
13036: PUSH
13037: LD_EXP 40
13041: AND
13042: IFFALSE 13121
13044: GO 13046
13046: DISABLE
13047: LD_INT 0
13049: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13050: LD_ADDR_VAR 0 1
13054: PUSH
13055: LD_INT 22
13057: PUSH
13058: LD_OWVAR 2
13062: PUSH
13063: EMPTY
13064: LIST
13065: LIST
13066: PUSH
13067: LD_INT 21
13069: PUSH
13070: LD_INT 3
13072: PUSH
13073: EMPTY
13074: LIST
13075: LIST
13076: PUSH
13077: EMPTY
13078: LIST
13079: LIST
13080: PPUSH
13081: CALL_OW 69
13085: ST_TO_ADDR
// if not tmp then
13086: LD_VAR 0 1
13090: NOT
13091: IFFALSE 13095
// exit ;
13093: GO 13121
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
13095: LD_VAR 0 1
13099: PUSH
13100: LD_INT 1
13102: PPUSH
13103: LD_VAR 0 1
13107: PPUSH
13108: CALL_OW 12
13112: ARRAY
13113: PPUSH
13114: LD_INT 100
13116: PPUSH
13117: CALL_OW 234
// end ;
13121: PPOPN 1
13123: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
13124: LD_EXP 30
13128: PUSH
13129: LD_EXP 42
13133: AND
13134: IFFALSE 13232
13136: GO 13138
13138: DISABLE
13139: LD_INT 0
13141: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
13142: LD_ADDR_VAR 0 1
13146: PUSH
13147: LD_INT 22
13149: PUSH
13150: LD_OWVAR 2
13154: PUSH
13155: EMPTY
13156: LIST
13157: LIST
13158: PUSH
13159: LD_INT 21
13161: PUSH
13162: LD_INT 1
13164: PUSH
13165: EMPTY
13166: LIST
13167: LIST
13168: PUSH
13169: EMPTY
13170: LIST
13171: LIST
13172: PPUSH
13173: CALL_OW 69
13177: ST_TO_ADDR
// if not tmp then
13178: LD_VAR 0 1
13182: NOT
13183: IFFALSE 13187
// exit ;
13185: GO 13232
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
13187: LD_VAR 0 1
13191: PUSH
13192: LD_INT 1
13194: PPUSH
13195: LD_VAR 0 1
13199: PPUSH
13200: CALL_OW 12
13204: ARRAY
13205: PPUSH
13206: LD_INT 1
13208: PPUSH
13209: LD_INT 4
13211: PPUSH
13212: CALL_OW 12
13216: PPUSH
13217: LD_INT 3000
13219: PPUSH
13220: LD_INT 9000
13222: PPUSH
13223: CALL_OW 12
13227: PPUSH
13228: CALL_OW 492
// end ;
13232: PPOPN 1
13234: END
// every 0 0$1 trigger StreamModeActive and sDepot do
13235: LD_EXP 30
13239: PUSH
13240: LD_EXP 43
13244: AND
13245: IFFALSE 13265
13247: GO 13249
13249: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
13250: LD_INT 1
13252: PPUSH
13253: LD_OWVAR 2
13257: PPUSH
13258: LD_INT 0
13260: PPUSH
13261: CALL_OW 324
13265: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
13266: LD_EXP 30
13270: PUSH
13271: LD_EXP 44
13275: AND
13276: IFFALSE 13359
13278: GO 13280
13280: DISABLE
13281: LD_INT 0
13283: PPUSH
13284: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
13285: LD_ADDR_VAR 0 2
13289: PUSH
13290: LD_INT 22
13292: PUSH
13293: LD_OWVAR 2
13297: PUSH
13298: EMPTY
13299: LIST
13300: LIST
13301: PUSH
13302: LD_INT 21
13304: PUSH
13305: LD_INT 3
13307: PUSH
13308: EMPTY
13309: LIST
13310: LIST
13311: PUSH
13312: EMPTY
13313: LIST
13314: LIST
13315: PPUSH
13316: CALL_OW 69
13320: ST_TO_ADDR
// if not tmp then
13321: LD_VAR 0 2
13325: NOT
13326: IFFALSE 13330
// exit ;
13328: GO 13359
// for i in tmp do
13330: LD_ADDR_VAR 0 1
13334: PUSH
13335: LD_VAR 0 2
13339: PUSH
13340: FOR_IN
13341: IFFALSE 13357
// SetBLevel ( i , 10 ) ;
13343: LD_VAR 0 1
13347: PPUSH
13348: LD_INT 10
13350: PPUSH
13351: CALL_OW 241
13355: GO 13340
13357: POP
13358: POP
// end ;
13359: PPOPN 2
13361: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
13362: LD_EXP 30
13366: PUSH
13367: LD_EXP 45
13371: AND
13372: IFFALSE 13483
13374: GO 13376
13376: DISABLE
13377: LD_INT 0
13379: PPUSH
13380: PPUSH
13381: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13382: LD_ADDR_VAR 0 3
13386: PUSH
13387: LD_INT 22
13389: PUSH
13390: LD_OWVAR 2
13394: PUSH
13395: EMPTY
13396: LIST
13397: LIST
13398: PUSH
13399: LD_INT 25
13401: PUSH
13402: LD_INT 1
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: PUSH
13409: EMPTY
13410: LIST
13411: LIST
13412: PPUSH
13413: CALL_OW 69
13417: ST_TO_ADDR
// if not tmp then
13418: LD_VAR 0 3
13422: NOT
13423: IFFALSE 13427
// exit ;
13425: GO 13483
// un := tmp [ rand ( 1 , tmp ) ] ;
13427: LD_ADDR_VAR 0 2
13431: PUSH
13432: LD_VAR 0 3
13436: PUSH
13437: LD_INT 1
13439: PPUSH
13440: LD_VAR 0 3
13444: PPUSH
13445: CALL_OW 12
13449: ARRAY
13450: ST_TO_ADDR
// if Crawls ( un ) then
13451: LD_VAR 0 2
13455: PPUSH
13456: CALL_OW 318
13460: IFFALSE 13471
// ComWalk ( un ) ;
13462: LD_VAR 0 2
13466: PPUSH
13467: CALL_OW 138
// SetClass ( un , class_sniper ) ;
13471: LD_VAR 0 2
13475: PPUSH
13476: LD_INT 5
13478: PPUSH
13479: CALL_OW 336
// end ;
13483: PPOPN 3
13485: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
13486: LD_EXP 30
13490: PUSH
13491: LD_EXP 46
13495: AND
13496: PUSH
13497: LD_OWVAR 67
13501: PUSH
13502: LD_INT 3
13504: LESS
13505: AND
13506: IFFALSE 13525
13508: GO 13510
13510: DISABLE
// Difficulty := Difficulty + 1 ;
13511: LD_ADDR_OWVAR 67
13515: PUSH
13516: LD_OWVAR 67
13520: PUSH
13521: LD_INT 1
13523: PLUS
13524: ST_TO_ADDR
13525: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
13526: LD_EXP 30
13530: PUSH
13531: LD_EXP 47
13535: AND
13536: IFFALSE 13639
13538: GO 13540
13540: DISABLE
13541: LD_INT 0
13543: PPUSH
// begin for i := 1 to 5 do
13544: LD_ADDR_VAR 0 1
13548: PUSH
13549: DOUBLE
13550: LD_INT 1
13552: DEC
13553: ST_TO_ADDR
13554: LD_INT 5
13556: PUSH
13557: FOR_TO
13558: IFFALSE 13637
// begin uc_nation := nation_nature ;
13560: LD_ADDR_OWVAR 21
13564: PUSH
13565: LD_INT 0
13567: ST_TO_ADDR
// uc_side := 0 ;
13568: LD_ADDR_OWVAR 20
13572: PUSH
13573: LD_INT 0
13575: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13576: LD_ADDR_OWVAR 29
13580: PUSH
13581: LD_INT 12
13583: PUSH
13584: LD_INT 12
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: ST_TO_ADDR
// hc_agressivity := 20 ;
13591: LD_ADDR_OWVAR 35
13595: PUSH
13596: LD_INT 20
13598: ST_TO_ADDR
// hc_class := class_tiger ;
13599: LD_ADDR_OWVAR 28
13603: PUSH
13604: LD_INT 14
13606: ST_TO_ADDR
// hc_gallery :=  ;
13607: LD_ADDR_OWVAR 33
13611: PUSH
13612: LD_STRING 
13614: ST_TO_ADDR
// hc_name :=  ;
13615: LD_ADDR_OWVAR 26
13619: PUSH
13620: LD_STRING 
13622: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
13623: CALL_OW 44
13627: PPUSH
13628: LD_INT 0
13630: PPUSH
13631: CALL_OW 51
// end ;
13635: GO 13557
13637: POP
13638: POP
// end ;
13639: PPOPN 1
13641: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
13642: LD_EXP 30
13646: PUSH
13647: LD_EXP 48
13651: AND
13652: IFFALSE 13826
13654: GO 13656
13656: DISABLE
13657: LD_INT 0
13659: PPUSH
13660: PPUSH
13661: PPUSH
13662: PPUSH
// begin result := false ;
13663: LD_ADDR_VAR 0 4
13667: PUSH
13668: LD_INT 0
13670: ST_TO_ADDR
// for i := 1 to 8 do
13671: LD_ADDR_VAR 0 1
13675: PUSH
13676: DOUBLE
13677: LD_INT 1
13679: DEC
13680: ST_TO_ADDR
13681: LD_INT 8
13683: PUSH
13684: FOR_TO
13685: IFFALSE 13796
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
13687: LD_ADDR_VAR 0 2
13691: PUSH
13692: LD_INT 10
13694: PUSH
13695: LD_INT 50
13697: PUSH
13698: LD_INT 90
13700: PUSH
13701: LD_INT 140
13703: PUSH
13704: EMPTY
13705: LIST
13706: LIST
13707: LIST
13708: LIST
13709: PUSH
13710: LD_INT 1
13712: PPUSH
13713: LD_INT 4
13715: PPUSH
13716: CALL_OW 12
13720: ARRAY
13721: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
13722: LD_ADDR_VAR 0 3
13726: PUSH
13727: LD_INT 10
13729: PUSH
13730: LD_INT 50
13732: PUSH
13733: LD_INT 90
13735: PUSH
13736: LD_INT 140
13738: PUSH
13739: EMPTY
13740: LIST
13741: LIST
13742: LIST
13743: LIST
13744: PUSH
13745: LD_INT 1
13747: PPUSH
13748: LD_INT 4
13750: PPUSH
13751: CALL_OW 12
13755: ARRAY
13756: ST_TO_ADDR
// if ValidHex ( x , y ) then
13757: LD_VAR 0 2
13761: PPUSH
13762: LD_VAR 0 3
13766: PPUSH
13767: CALL_OW 488
13771: IFFALSE 13794
// begin result := [ x , y ] ;
13773: LD_ADDR_VAR 0 4
13777: PUSH
13778: LD_VAR 0 2
13782: PUSH
13783: LD_VAR 0 3
13787: PUSH
13788: EMPTY
13789: LIST
13790: LIST
13791: ST_TO_ADDR
// break ;
13792: GO 13796
// end ; end ;
13794: GO 13684
13796: POP
13797: POP
// if result then
13798: LD_VAR 0 4
13802: IFFALSE 13826
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
13804: LD_VAR 0 4
13808: PUSH
13809: LD_INT 1
13811: ARRAY
13812: PPUSH
13813: LD_VAR 0 4
13817: PUSH
13818: LD_INT 2
13820: ARRAY
13821: PPUSH
13822: CALL_OW 429
// end ;
13826: PPOPN 4
13828: END
// every 0 0$1 trigger StreamModeActive and sReset do
13829: LD_EXP 30
13833: PUSH
13834: LD_EXP 50
13838: AND
13839: IFFALSE 13851
13841: GO 13843
13843: DISABLE
// YouLost (  ) ;
13844: LD_STRING 
13846: PPUSH
13847: CALL_OW 104
13851: END
// every 0 0$1 trigger StreamModeActive and sFog do
13852: LD_EXP 30
13856: PUSH
13857: LD_EXP 49
13861: AND
13862: IFFALSE 13876
13864: GO 13866
13866: DISABLE
// FogOff ( your_side ) ;
13867: LD_OWVAR 2
13871: PPUSH
13872: CALL_OW 344
13876: END
// every 0 0$1 trigger StreamModeActive and sSun do
13877: LD_EXP 30
13881: PUSH
13882: LD_EXP 51
13886: AND
13887: IFFALSE 13915
13889: GO 13891
13891: DISABLE
// begin solar_recharge_percent := 0 ;
13892: LD_ADDR_OWVAR 79
13896: PUSH
13897: LD_INT 0
13899: ST_TO_ADDR
// wait ( 5 5$00 ) ;
13900: LD_INT 10500
13902: PPUSH
13903: CALL_OW 67
// solar_recharge_percent := 100 ;
13907: LD_ADDR_OWVAR 79
13911: PUSH
13912: LD_INT 100
13914: ST_TO_ADDR
// end ;
13915: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
13916: LD_EXP 30
13920: PUSH
13921: LD_EXP 52
13925: AND
13926: IFFALSE 14165
13928: GO 13930
13930: DISABLE
13931: LD_INT 0
13933: PPUSH
13934: PPUSH
13935: PPUSH
// begin tmp := [ ] ;
13936: LD_ADDR_VAR 0 3
13940: PUSH
13941: EMPTY
13942: ST_TO_ADDR
// for i := 1 to 6 do
13943: LD_ADDR_VAR 0 1
13947: PUSH
13948: DOUBLE
13949: LD_INT 1
13951: DEC
13952: ST_TO_ADDR
13953: LD_INT 6
13955: PUSH
13956: FOR_TO
13957: IFFALSE 14062
// begin uc_nation := nation_nature ;
13959: LD_ADDR_OWVAR 21
13963: PUSH
13964: LD_INT 0
13966: ST_TO_ADDR
// uc_side := 0 ;
13967: LD_ADDR_OWVAR 20
13971: PUSH
13972: LD_INT 0
13974: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
13975: LD_ADDR_OWVAR 29
13979: PUSH
13980: LD_INT 12
13982: PUSH
13983: LD_INT 12
13985: PUSH
13986: EMPTY
13987: LIST
13988: LIST
13989: ST_TO_ADDR
// hc_agressivity := 20 ;
13990: LD_ADDR_OWVAR 35
13994: PUSH
13995: LD_INT 20
13997: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
13998: LD_ADDR_OWVAR 28
14002: PUSH
14003: LD_INT 17
14005: ST_TO_ADDR
// hc_gallery :=  ;
14006: LD_ADDR_OWVAR 33
14010: PUSH
14011: LD_STRING 
14013: ST_TO_ADDR
// hc_name :=  ;
14014: LD_ADDR_OWVAR 26
14018: PUSH
14019: LD_STRING 
14021: ST_TO_ADDR
// un := CreateHuman ;
14022: LD_ADDR_VAR 0 2
14026: PUSH
14027: CALL_OW 44
14031: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
14032: LD_VAR 0 2
14036: PPUSH
14037: LD_INT 1
14039: PPUSH
14040: CALL_OW 51
// tmp := tmp * un ;
14044: LD_ADDR_VAR 0 3
14048: PUSH
14049: LD_VAR 0 3
14053: PUSH
14054: LD_VAR 0 2
14058: MUL
14059: ST_TO_ADDR
// end ;
14060: GO 13956
14062: POP
14063: POP
// repeat wait ( 0 0$1 ) ;
14064: LD_INT 35
14066: PPUSH
14067: CALL_OW 67
// for un in tmp do
14071: LD_ADDR_VAR 0 2
14075: PUSH
14076: LD_VAR 0 3
14080: PUSH
14081: FOR_IN
14082: IFFALSE 14156
// begin if IsDead ( un ) then
14084: LD_VAR 0 2
14088: PPUSH
14089: CALL_OW 301
14093: IFFALSE 14113
// begin tmp := tmp diff un ;
14095: LD_ADDR_VAR 0 3
14099: PUSH
14100: LD_VAR 0 3
14104: PUSH
14105: LD_VAR 0 2
14109: DIFF
14110: ST_TO_ADDR
// continue ;
14111: GO 14081
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
14113: LD_VAR 0 2
14117: PPUSH
14118: LD_INT 3
14120: PUSH
14121: LD_INT 22
14123: PUSH
14124: LD_INT 0
14126: PUSH
14127: EMPTY
14128: LIST
14129: LIST
14130: PUSH
14131: EMPTY
14132: LIST
14133: LIST
14134: PPUSH
14135: CALL_OW 69
14139: PPUSH
14140: LD_VAR 0 2
14144: PPUSH
14145: CALL_OW 74
14149: PPUSH
14150: CALL_OW 115
// end ;
14154: GO 14081
14156: POP
14157: POP
// until not tmp ;
14158: LD_VAR 0 3
14162: NOT
14163: IFFALSE 14064
// end ;
14165: PPOPN 3
14167: END
// every 0 0$1 trigger StreamModeActive and sTroll do
14168: LD_EXP 30
14172: PUSH
14173: LD_EXP 53
14177: AND
14178: IFFALSE 14204
14180: GO 14182
14182: DISABLE
// begin ToLua ( displayTroll(); ) ;
14183: LD_STRING displayTroll();
14185: PPUSH
14186: CALL_OW 559
// wait ( 3 3$00 ) ;
14190: LD_INT 6300
14192: PPUSH
14193: CALL_OW 67
// ToLua ( hideTroll(); ) ;
14197: LD_STRING hideTroll();
14199: PPUSH
14200: CALL_OW 559
// end ;
14204: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
14205: LD_EXP 30
14209: PUSH
14210: LD_EXP 54
14214: AND
14215: IFFALSE 14278
14217: GO 14219
14219: DISABLE
14220: LD_INT 0
14222: PPUSH
// begin p := 0 ;
14223: LD_ADDR_VAR 0 1
14227: PUSH
14228: LD_INT 0
14230: ST_TO_ADDR
// repeat game_speed := 1 ;
14231: LD_ADDR_OWVAR 65
14235: PUSH
14236: LD_INT 1
14238: ST_TO_ADDR
// wait ( 0 0$1 ) ;
14239: LD_INT 35
14241: PPUSH
14242: CALL_OW 67
// p := p + 1 ;
14246: LD_ADDR_VAR 0 1
14250: PUSH
14251: LD_VAR 0 1
14255: PUSH
14256: LD_INT 1
14258: PLUS
14259: ST_TO_ADDR
// until p >= 60 ;
14260: LD_VAR 0 1
14264: PUSH
14265: LD_INT 60
14267: GREATEREQUAL
14268: IFFALSE 14231
// game_speed := 4 ;
14270: LD_ADDR_OWVAR 65
14274: PUSH
14275: LD_INT 4
14277: ST_TO_ADDR
// end ;
14278: PPOPN 1
14280: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
14281: LD_EXP 30
14285: PUSH
14286: LD_EXP 55
14290: AND
14291: IFFALSE 14437
14293: GO 14295
14295: DISABLE
14296: LD_INT 0
14298: PPUSH
14299: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
14300: LD_ADDR_VAR 0 1
14304: PUSH
14305: LD_INT 22
14307: PUSH
14308: LD_OWVAR 2
14312: PUSH
14313: EMPTY
14314: LIST
14315: LIST
14316: PUSH
14317: LD_INT 2
14319: PUSH
14320: LD_INT 30
14322: PUSH
14323: LD_INT 0
14325: PUSH
14326: EMPTY
14327: LIST
14328: LIST
14329: PUSH
14330: LD_INT 30
14332: PUSH
14333: LD_INT 1
14335: PUSH
14336: EMPTY
14337: LIST
14338: LIST
14339: PUSH
14340: EMPTY
14341: LIST
14342: LIST
14343: LIST
14344: PUSH
14345: EMPTY
14346: LIST
14347: LIST
14348: PPUSH
14349: CALL_OW 69
14353: ST_TO_ADDR
// if not depot then
14354: LD_VAR 0 1
14358: NOT
14359: IFFALSE 14363
// exit ;
14361: GO 14437
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
14363: LD_ADDR_VAR 0 2
14367: PUSH
14368: LD_VAR 0 1
14372: PUSH
14373: LD_INT 1
14375: PPUSH
14376: LD_VAR 0 1
14380: PPUSH
14381: CALL_OW 12
14385: ARRAY
14386: PPUSH
14387: CALL_OW 274
14391: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
14392: LD_VAR 0 2
14396: PPUSH
14397: LD_INT 1
14399: PPUSH
14400: LD_INT 0
14402: PPUSH
14403: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
14407: LD_VAR 0 2
14411: PPUSH
14412: LD_INT 2
14414: PPUSH
14415: LD_INT 0
14417: PPUSH
14418: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
14422: LD_VAR 0 2
14426: PPUSH
14427: LD_INT 3
14429: PPUSH
14430: LD_INT 0
14432: PPUSH
14433: CALL_OW 277
// end ;
14437: PPOPN 2
14439: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
14440: LD_EXP 30
14444: PUSH
14445: LD_EXP 56
14449: AND
14450: IFFALSE 14547
14452: GO 14454
14454: DISABLE
14455: LD_INT 0
14457: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
14458: LD_ADDR_VAR 0 1
14462: PUSH
14463: LD_INT 22
14465: PUSH
14466: LD_OWVAR 2
14470: PUSH
14471: EMPTY
14472: LIST
14473: LIST
14474: PUSH
14475: LD_INT 21
14477: PUSH
14478: LD_INT 1
14480: PUSH
14481: EMPTY
14482: LIST
14483: LIST
14484: PUSH
14485: LD_INT 3
14487: PUSH
14488: LD_INT 23
14490: PUSH
14491: LD_INT 0
14493: PUSH
14494: EMPTY
14495: LIST
14496: LIST
14497: PUSH
14498: EMPTY
14499: LIST
14500: LIST
14501: PUSH
14502: EMPTY
14503: LIST
14504: LIST
14505: LIST
14506: PPUSH
14507: CALL_OW 69
14511: ST_TO_ADDR
// if not tmp then
14512: LD_VAR 0 1
14516: NOT
14517: IFFALSE 14521
// exit ;
14519: GO 14547
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
14521: LD_VAR 0 1
14525: PUSH
14526: LD_INT 1
14528: PPUSH
14529: LD_VAR 0 1
14533: PPUSH
14534: CALL_OW 12
14538: ARRAY
14539: PPUSH
14540: LD_INT 200
14542: PPUSH
14543: CALL_OW 234
// end ;
14547: PPOPN 1
14549: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
14550: LD_EXP 30
14554: PUSH
14555: LD_EXP 57
14559: AND
14560: IFFALSE 14639
14562: GO 14564
14564: DISABLE
14565: LD_INT 0
14567: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
14568: LD_ADDR_VAR 0 1
14572: PUSH
14573: LD_INT 22
14575: PUSH
14576: LD_OWVAR 2
14580: PUSH
14581: EMPTY
14582: LIST
14583: LIST
14584: PUSH
14585: LD_INT 21
14587: PUSH
14588: LD_INT 2
14590: PUSH
14591: EMPTY
14592: LIST
14593: LIST
14594: PUSH
14595: EMPTY
14596: LIST
14597: LIST
14598: PPUSH
14599: CALL_OW 69
14603: ST_TO_ADDR
// if not tmp then
14604: LD_VAR 0 1
14608: NOT
14609: IFFALSE 14613
// exit ;
14611: GO 14639
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
14613: LD_VAR 0 1
14617: PUSH
14618: LD_INT 1
14620: PPUSH
14621: LD_VAR 0 1
14625: PPUSH
14626: CALL_OW 12
14630: ARRAY
14631: PPUSH
14632: LD_INT 60
14634: PPUSH
14635: CALL_OW 234
// end ;
14639: PPOPN 1
14641: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
14642: LD_EXP 30
14646: PUSH
14647: LD_EXP 58
14651: AND
14652: IFFALSE 14751
14654: GO 14656
14656: DISABLE
14657: LD_INT 0
14659: PPUSH
14660: PPUSH
// begin enable ;
14661: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
14662: LD_ADDR_VAR 0 1
14666: PUSH
14667: LD_INT 22
14669: PUSH
14670: LD_OWVAR 2
14674: PUSH
14675: EMPTY
14676: LIST
14677: LIST
14678: PUSH
14679: LD_INT 61
14681: PUSH
14682: EMPTY
14683: LIST
14684: PUSH
14685: LD_INT 33
14687: PUSH
14688: LD_INT 2
14690: PUSH
14691: EMPTY
14692: LIST
14693: LIST
14694: PUSH
14695: EMPTY
14696: LIST
14697: LIST
14698: LIST
14699: PPUSH
14700: CALL_OW 69
14704: ST_TO_ADDR
// if not tmp then
14705: LD_VAR 0 1
14709: NOT
14710: IFFALSE 14714
// exit ;
14712: GO 14751
// for i in tmp do
14714: LD_ADDR_VAR 0 2
14718: PUSH
14719: LD_VAR 0 1
14723: PUSH
14724: FOR_IN
14725: IFFALSE 14749
// if IsControledBy ( i ) then
14727: LD_VAR 0 2
14731: PPUSH
14732: CALL_OW 312
14736: IFFALSE 14747
// ComUnlink ( i ) ;
14738: LD_VAR 0 2
14742: PPUSH
14743: CALL_OW 136
14747: GO 14724
14749: POP
14750: POP
// end ;
14751: PPOPN 2
14753: END
// every 0 0$1 trigger StreamModeActive and sPowell do
14754: LD_EXP 30
14758: PUSH
14759: LD_EXP 59
14763: AND
14764: IFFALSE 14804
14766: GO 14768
14768: DISABLE
// begin ToLua ( displayPowell(); ) ;
14769: LD_STRING displayPowell();
14771: PPUSH
14772: CALL_OW 559
// wait ( 0 0$20 ) ;
14776: LD_INT 700
14778: PPUSH
14779: CALL_OW 67
// ToLua ( displayPowell(); ) ;
14783: LD_STRING displayPowell();
14785: PPUSH
14786: CALL_OW 559
// wait ( 0 0$40 ) ;
14790: LD_INT 1400
14792: PPUSH
14793: CALL_OW 67
// ToLua ( displayPowell(); ) ;
14797: LD_STRING displayPowell();
14799: PPUSH
14800: CALL_OW 559
// end ;
14804: END
// every 0 0$1 trigger StreamModeActive and sStu do
14805: LD_EXP 30
14809: PUSH
14810: LD_EXP 67
14814: AND
14815: IFFALSE 14827
14817: GO 14819
14819: DISABLE
// begin ToLua ( displayStucuk(); ) ;
14820: LD_STRING displayStucuk();
14822: PPUSH
14823: CALL_OW 559
// end ;
14827: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
14828: LD_EXP 30
14832: PUSH
14833: LD_EXP 60
14837: AND
14838: IFFALSE 14979
14840: GO 14842
14842: DISABLE
14843: LD_INT 0
14845: PPUSH
14846: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
14847: LD_ADDR_VAR 0 2
14851: PUSH
14852: LD_INT 22
14854: PUSH
14855: LD_OWVAR 2
14859: PUSH
14860: EMPTY
14861: LIST
14862: LIST
14863: PUSH
14864: LD_INT 21
14866: PUSH
14867: LD_INT 1
14869: PUSH
14870: EMPTY
14871: LIST
14872: LIST
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PPUSH
14878: CALL_OW 69
14882: ST_TO_ADDR
// if not tmp then
14883: LD_VAR 0 2
14887: NOT
14888: IFFALSE 14892
// exit ;
14890: GO 14979
// un := tmp [ rand ( 1 , tmp ) ] ;
14892: LD_ADDR_VAR 0 1
14896: PUSH
14897: LD_VAR 0 2
14901: PUSH
14902: LD_INT 1
14904: PPUSH
14905: LD_VAR 0 2
14909: PPUSH
14910: CALL_OW 12
14914: ARRAY
14915: ST_TO_ADDR
// SetSide ( un , 0 ) ;
14916: LD_VAR 0 1
14920: PPUSH
14921: LD_INT 0
14923: PPUSH
14924: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
14928: LD_VAR 0 1
14932: PPUSH
14933: LD_OWVAR 3
14937: PUSH
14938: LD_VAR 0 1
14942: DIFF
14943: PPUSH
14944: LD_VAR 0 1
14948: PPUSH
14949: CALL_OW 74
14953: PPUSH
14954: CALL_OW 115
// wait ( 0 0$20 ) ;
14958: LD_INT 700
14960: PPUSH
14961: CALL_OW 67
// SetSide ( un , your_side ) ;
14965: LD_VAR 0 1
14969: PPUSH
14970: LD_OWVAR 2
14974: PPUSH
14975: CALL_OW 235
// end ;
14979: PPOPN 2
14981: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
14982: LD_EXP 30
14986: PUSH
14987: LD_EXP 61
14991: AND
14992: IFFALSE 15098
14994: GO 14996
14996: DISABLE
14997: LD_INT 0
14999: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
15000: LD_ADDR_VAR 0 1
15004: PUSH
15005: LD_INT 22
15007: PUSH
15008: LD_OWVAR 2
15012: PUSH
15013: EMPTY
15014: LIST
15015: LIST
15016: PUSH
15017: LD_INT 2
15019: PUSH
15020: LD_INT 30
15022: PUSH
15023: LD_INT 0
15025: PUSH
15026: EMPTY
15027: LIST
15028: LIST
15029: PUSH
15030: LD_INT 30
15032: PUSH
15033: LD_INT 1
15035: PUSH
15036: EMPTY
15037: LIST
15038: LIST
15039: PUSH
15040: EMPTY
15041: LIST
15042: LIST
15043: LIST
15044: PUSH
15045: EMPTY
15046: LIST
15047: LIST
15048: PPUSH
15049: CALL_OW 69
15053: ST_TO_ADDR
// if not depot then
15054: LD_VAR 0 1
15058: NOT
15059: IFFALSE 15063
// exit ;
15061: GO 15098
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
15063: LD_VAR 0 1
15067: PUSH
15068: LD_INT 1
15070: ARRAY
15071: PPUSH
15072: CALL_OW 250
15076: PPUSH
15077: LD_VAR 0 1
15081: PUSH
15082: LD_INT 1
15084: ARRAY
15085: PPUSH
15086: CALL_OW 251
15090: PPUSH
15091: LD_INT 70
15093: PPUSH
15094: CALL_OW 495
// end ;
15098: PPOPN 1
15100: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
15101: LD_EXP 30
15105: PUSH
15106: LD_EXP 62
15110: AND
15111: IFFALSE 15322
15113: GO 15115
15115: DISABLE
15116: LD_INT 0
15118: PPUSH
15119: PPUSH
15120: PPUSH
15121: PPUSH
15122: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
15123: LD_ADDR_VAR 0 5
15127: PUSH
15128: LD_INT 22
15130: PUSH
15131: LD_OWVAR 2
15135: PUSH
15136: EMPTY
15137: LIST
15138: LIST
15139: PUSH
15140: LD_INT 21
15142: PUSH
15143: LD_INT 1
15145: PUSH
15146: EMPTY
15147: LIST
15148: LIST
15149: PUSH
15150: EMPTY
15151: LIST
15152: LIST
15153: PPUSH
15154: CALL_OW 69
15158: ST_TO_ADDR
// if not tmp then
15159: LD_VAR 0 5
15163: NOT
15164: IFFALSE 15168
// exit ;
15166: GO 15322
// for i in tmp do
15168: LD_ADDR_VAR 0 1
15172: PUSH
15173: LD_VAR 0 5
15177: PUSH
15178: FOR_IN
15179: IFFALSE 15320
// begin d := rand ( 0 , 5 ) ;
15181: LD_ADDR_VAR 0 4
15185: PUSH
15186: LD_INT 0
15188: PPUSH
15189: LD_INT 5
15191: PPUSH
15192: CALL_OW 12
15196: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
15197: LD_ADDR_VAR 0 2
15201: PUSH
15202: LD_VAR 0 1
15206: PPUSH
15207: CALL_OW 250
15211: PPUSH
15212: LD_VAR 0 4
15216: PPUSH
15217: LD_INT 3
15219: PPUSH
15220: LD_INT 12
15222: PPUSH
15223: CALL_OW 12
15227: PPUSH
15228: CALL_OW 272
15232: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
15233: LD_ADDR_VAR 0 3
15237: PUSH
15238: LD_VAR 0 1
15242: PPUSH
15243: CALL_OW 251
15247: PPUSH
15248: LD_VAR 0 4
15252: PPUSH
15253: LD_INT 3
15255: PPUSH
15256: LD_INT 12
15258: PPUSH
15259: CALL_OW 12
15263: PPUSH
15264: CALL_OW 273
15268: ST_TO_ADDR
// if ValidHex ( x , y ) then
15269: LD_VAR 0 2
15273: PPUSH
15274: LD_VAR 0 3
15278: PPUSH
15279: CALL_OW 488
15283: IFFALSE 15318
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
15285: LD_VAR 0 1
15289: PPUSH
15290: LD_VAR 0 2
15294: PPUSH
15295: LD_VAR 0 3
15299: PPUSH
15300: LD_INT 3
15302: PPUSH
15303: LD_INT 6
15305: PPUSH
15306: CALL_OW 12
15310: PPUSH
15311: LD_INT 1
15313: PPUSH
15314: CALL_OW 483
// end ;
15318: GO 15178
15320: POP
15321: POP
// end ;
15322: PPOPN 5
15324: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
15325: LD_EXP 30
15329: PUSH
15330: LD_EXP 63
15334: AND
15335: IFFALSE 15429
15337: GO 15339
15339: DISABLE
15340: LD_INT 0
15342: PPUSH
15343: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
15344: LD_ADDR_VAR 0 2
15348: PUSH
15349: LD_INT 22
15351: PUSH
15352: LD_OWVAR 2
15356: PUSH
15357: EMPTY
15358: LIST
15359: LIST
15360: PUSH
15361: LD_INT 32
15363: PUSH
15364: LD_INT 1
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: LD_INT 21
15373: PUSH
15374: LD_INT 2
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: LIST
15385: PPUSH
15386: CALL_OW 69
15390: ST_TO_ADDR
// if not tmp then
15391: LD_VAR 0 2
15395: NOT
15396: IFFALSE 15400
// exit ;
15398: GO 15429
// for i in tmp do
15400: LD_ADDR_VAR 0 1
15404: PUSH
15405: LD_VAR 0 2
15409: PUSH
15410: FOR_IN
15411: IFFALSE 15427
// SetFuel ( i , 0 ) ;
15413: LD_VAR 0 1
15417: PPUSH
15418: LD_INT 0
15420: PPUSH
15421: CALL_OW 240
15425: GO 15410
15427: POP
15428: POP
// end ;
15429: PPOPN 2
15431: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
15432: LD_EXP 30
15436: PUSH
15437: LD_EXP 64
15441: AND
15442: IFFALSE 15508
15444: GO 15446
15446: DISABLE
15447: LD_INT 0
15449: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
15450: LD_ADDR_VAR 0 1
15454: PUSH
15455: LD_INT 22
15457: PUSH
15458: LD_OWVAR 2
15462: PUSH
15463: EMPTY
15464: LIST
15465: LIST
15466: PUSH
15467: LD_INT 30
15469: PUSH
15470: LD_INT 29
15472: PUSH
15473: EMPTY
15474: LIST
15475: LIST
15476: PUSH
15477: EMPTY
15478: LIST
15479: LIST
15480: PPUSH
15481: CALL_OW 69
15485: ST_TO_ADDR
// if not tmp then
15486: LD_VAR 0 1
15490: NOT
15491: IFFALSE 15495
// exit ;
15493: GO 15508
// DestroyUnit ( tmp [ 1 ] ) ;
15495: LD_VAR 0 1
15499: PUSH
15500: LD_INT 1
15502: ARRAY
15503: PPUSH
15504: CALL_OW 65
// end ;
15508: PPOPN 1
15510: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
15511: LD_EXP 30
15515: PUSH
15516: LD_EXP 66
15520: AND
15521: IFFALSE 15634
15523: GO 15525
15525: DISABLE
15526: LD_INT 0
15528: PPUSH
// begin uc_side := 0 ;
15529: LD_ADDR_OWVAR 20
15533: PUSH
15534: LD_INT 0
15536: ST_TO_ADDR
// uc_nation := nation_arabian ;
15537: LD_ADDR_OWVAR 21
15541: PUSH
15542: LD_INT 2
15544: ST_TO_ADDR
// PrepareHuman ( sex_male , 10 , class_desert_warior ) ;
15545: LD_INT 1
15547: PPUSH
15548: LD_INT 10
15550: PPUSH
15551: LD_INT 11
15553: PPUSH
15554: CALL_OW 380
// un := CreateHuman ;
15558: LD_ADDR_VAR 0 1
15562: PUSH
15563: CALL_OW 44
15567: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
15568: LD_VAR 0 1
15572: PPUSH
15573: LD_INT 1
15575: PPUSH
15576: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
15580: LD_INT 35
15582: PPUSH
15583: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
15587: LD_VAR 0 1
15591: PPUSH
15592: LD_INT 22
15594: PUSH
15595: LD_OWVAR 2
15599: PUSH
15600: EMPTY
15601: LIST
15602: LIST
15603: PPUSH
15604: CALL_OW 69
15608: PPUSH
15609: LD_VAR 0 1
15613: PPUSH
15614: CALL_OW 74
15618: PPUSH
15619: CALL_OW 115
// until IsDead ( un ) ;
15623: LD_VAR 0 1
15627: PPUSH
15628: CALL_OW 301
15632: IFFALSE 15580
// end ; end_of_file
15634: PPOPN 1
15636: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
15637: LD_INT 0
15639: PPUSH
15640: PPUSH
15641: PPUSH
15642: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
15643: LD_VAR 0 1
15647: PPUSH
15648: CALL_OW 264
15652: PUSH
15653: LD_EXP 29
15657: EQUAL
15658: IFFALSE 15730
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
15660: LD_INT 68
15662: PPUSH
15663: LD_VAR 0 1
15667: PPUSH
15668: CALL_OW 255
15672: PPUSH
15673: CALL_OW 321
15677: PUSH
15678: LD_INT 2
15680: EQUAL
15681: IFFALSE 15693
// eff := 70 else
15683: LD_ADDR_VAR 0 6
15687: PUSH
15688: LD_INT 70
15690: ST_TO_ADDR
15691: GO 15701
// eff := 30 ;
15693: LD_ADDR_VAR 0 6
15697: PUSH
15698: LD_INT 30
15700: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
15701: LD_VAR 0 1
15705: PPUSH
15706: CALL_OW 250
15710: PPUSH
15711: LD_VAR 0 1
15715: PPUSH
15716: CALL_OW 251
15720: PPUSH
15721: LD_VAR 0 6
15725: PPUSH
15726: CALL_OW 495
// end ; end ;
15730: LD_VAR 0 4
15734: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
15735: LD_INT 0
15737: PPUSH
15738: PPUSH
15739: PPUSH
15740: PPUSH
15741: PPUSH
15742: PPUSH
// if cmd = 124 then
15743: LD_VAR 0 1
15747: PUSH
15748: LD_INT 124
15750: EQUAL
15751: IFFALSE 15957
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
15753: LD_ADDR_VAR 0 5
15757: PUSH
15758: LD_INT 2
15760: PUSH
15761: LD_INT 34
15763: PUSH
15764: LD_INT 53
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: PUSH
15771: LD_INT 34
15773: PUSH
15774: LD_INT 14
15776: PUSH
15777: EMPTY
15778: LIST
15779: LIST
15780: PUSH
15781: EMPTY
15782: LIST
15783: LIST
15784: LIST
15785: PPUSH
15786: CALL_OW 69
15790: ST_TO_ADDR
// if not tmp then
15791: LD_VAR 0 5
15795: NOT
15796: IFFALSE 15800
// exit ;
15798: GO 15957
// for i in tmp do
15800: LD_ADDR_VAR 0 3
15804: PUSH
15805: LD_VAR 0 5
15809: PUSH
15810: FOR_IN
15811: IFFALSE 15955
// begin taskList := GetTaskList ( i ) ;
15813: LD_ADDR_VAR 0 6
15817: PUSH
15818: LD_VAR 0 3
15822: PPUSH
15823: CALL_OW 437
15827: ST_TO_ADDR
// if not taskList then
15828: LD_VAR 0 6
15832: NOT
15833: IFFALSE 15837
// continue ;
15835: GO 15810
// for j = 1 to taskList do
15837: LD_ADDR_VAR 0 4
15841: PUSH
15842: DOUBLE
15843: LD_INT 1
15845: DEC
15846: ST_TO_ADDR
15847: LD_VAR 0 6
15851: PUSH
15852: FOR_TO
15853: IFFALSE 15951
// if taskList [ j ] [ 1 ] = | then
15855: LD_VAR 0 6
15859: PUSH
15860: LD_VAR 0 4
15864: ARRAY
15865: PUSH
15866: LD_INT 1
15868: ARRAY
15869: PUSH
15870: LD_STRING |
15872: EQUAL
15873: IFFALSE 15949
// begin _taskList := Delete ( taskList , 1 ) ;
15875: LD_ADDR_VAR 0 7
15879: PUSH
15880: LD_VAR 0 6
15884: PPUSH
15885: LD_INT 1
15887: PPUSH
15888: CALL_OW 3
15892: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
15893: LD_VAR 0 3
15897: PPUSH
15898: LD_VAR 0 7
15902: PPUSH
15903: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
15907: LD_VAR 0 3
15911: PPUSH
15912: LD_VAR 0 6
15916: PUSH
15917: LD_VAR 0 4
15921: ARRAY
15922: PUSH
15923: LD_INT 2
15925: ARRAY
15926: PPUSH
15927: LD_VAR 0 6
15931: PUSH
15932: LD_VAR 0 4
15936: ARRAY
15937: PUSH
15938: LD_INT 3
15940: ARRAY
15941: PPUSH
15942: LD_INT 8
15944: PPUSH
15945: CALL 15962 0 4
// end ;
15949: GO 15852
15951: POP
15952: POP
// end ;
15953: GO 15810
15955: POP
15956: POP
// end ; end ;
15957: LD_VAR 0 2
15961: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
15962: LD_INT 0
15964: PPUSH
15965: PPUSH
15966: PPUSH
15967: PPUSH
15968: PPUSH
15969: PPUSH
15970: PPUSH
15971: PPUSH
15972: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
15973: LD_VAR 0 1
15977: NOT
15978: PUSH
15979: LD_VAR 0 2
15983: PPUSH
15984: LD_VAR 0 3
15988: PPUSH
15989: CALL_OW 488
15993: NOT
15994: OR
15995: PUSH
15996: LD_VAR 0 4
16000: NOT
16001: OR
16002: IFFALSE 16006
// exit ;
16004: GO 16346
// list := [ ] ;
16006: LD_ADDR_VAR 0 13
16010: PUSH
16011: EMPTY
16012: ST_TO_ADDR
// if x - r < 0 then
16013: LD_VAR 0 2
16017: PUSH
16018: LD_VAR 0 4
16022: MINUS
16023: PUSH
16024: LD_INT 0
16026: LESS
16027: IFFALSE 16039
// min_x := 0 else
16029: LD_ADDR_VAR 0 7
16033: PUSH
16034: LD_INT 0
16036: ST_TO_ADDR
16037: GO 16055
// min_x := x - r ;
16039: LD_ADDR_VAR 0 7
16043: PUSH
16044: LD_VAR 0 2
16048: PUSH
16049: LD_VAR 0 4
16053: MINUS
16054: ST_TO_ADDR
// if y - r < 0 then
16055: LD_VAR 0 3
16059: PUSH
16060: LD_VAR 0 4
16064: MINUS
16065: PUSH
16066: LD_INT 0
16068: LESS
16069: IFFALSE 16081
// min_y := 0 else
16071: LD_ADDR_VAR 0 8
16075: PUSH
16076: LD_INT 0
16078: ST_TO_ADDR
16079: GO 16097
// min_y := y - r ;
16081: LD_ADDR_VAR 0 8
16085: PUSH
16086: LD_VAR 0 3
16090: PUSH
16091: LD_VAR 0 4
16095: MINUS
16096: ST_TO_ADDR
// max_x := x + r ;
16097: LD_ADDR_VAR 0 9
16101: PUSH
16102: LD_VAR 0 2
16106: PUSH
16107: LD_VAR 0 4
16111: PLUS
16112: ST_TO_ADDR
// max_y := y + r ;
16113: LD_ADDR_VAR 0 10
16117: PUSH
16118: LD_VAR 0 3
16122: PUSH
16123: LD_VAR 0 4
16127: PLUS
16128: ST_TO_ADDR
// for _x = min_x to max_x do
16129: LD_ADDR_VAR 0 11
16133: PUSH
16134: DOUBLE
16135: LD_VAR 0 7
16139: DEC
16140: ST_TO_ADDR
16141: LD_VAR 0 9
16145: PUSH
16146: FOR_TO
16147: IFFALSE 16264
// for _y = min_y to max_y do
16149: LD_ADDR_VAR 0 12
16153: PUSH
16154: DOUBLE
16155: LD_VAR 0 8
16159: DEC
16160: ST_TO_ADDR
16161: LD_VAR 0 10
16165: PUSH
16166: FOR_TO
16167: IFFALSE 16260
// begin if not ValidHex ( _x , _y ) then
16169: LD_VAR 0 11
16173: PPUSH
16174: LD_VAR 0 12
16178: PPUSH
16179: CALL_OW 488
16183: NOT
16184: IFFALSE 16188
// continue ;
16186: GO 16166
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
16188: LD_VAR 0 11
16192: PPUSH
16193: LD_VAR 0 12
16197: PPUSH
16198: CALL_OW 351
16202: PUSH
16203: LD_VAR 0 11
16207: PPUSH
16208: LD_VAR 0 12
16212: PPUSH
16213: CALL_OW 554
16217: AND
16218: IFFALSE 16258
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
16220: LD_ADDR_VAR 0 13
16224: PUSH
16225: LD_VAR 0 13
16229: PPUSH
16230: LD_VAR 0 13
16234: PUSH
16235: LD_INT 1
16237: PLUS
16238: PPUSH
16239: LD_VAR 0 11
16243: PUSH
16244: LD_VAR 0 12
16248: PUSH
16249: EMPTY
16250: LIST
16251: LIST
16252: PPUSH
16253: CALL_OW 2
16257: ST_TO_ADDR
// end ;
16258: GO 16166
16260: POP
16261: POP
16262: GO 16146
16264: POP
16265: POP
// if not list then
16266: LD_VAR 0 13
16270: NOT
16271: IFFALSE 16275
// exit ;
16273: GO 16346
// for i in list do
16275: LD_ADDR_VAR 0 6
16279: PUSH
16280: LD_VAR 0 13
16284: PUSH
16285: FOR_IN
16286: IFFALSE 16344
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
16288: LD_VAR 0 1
16292: PPUSH
16293: LD_STRING M
16295: PUSH
16296: LD_VAR 0 6
16300: PUSH
16301: LD_INT 1
16303: ARRAY
16304: PUSH
16305: LD_VAR 0 6
16309: PUSH
16310: LD_INT 2
16312: ARRAY
16313: PUSH
16314: LD_INT 0
16316: PUSH
16317: LD_INT 0
16319: PUSH
16320: LD_INT 0
16322: PUSH
16323: LD_INT 0
16325: PUSH
16326: EMPTY
16327: LIST
16328: LIST
16329: LIST
16330: LIST
16331: LIST
16332: LIST
16333: LIST
16334: PUSH
16335: EMPTY
16336: LIST
16337: PPUSH
16338: CALL_OW 447
16342: GO 16285
16344: POP
16345: POP
// end ;
16346: LD_VAR 0 5
16350: RET
