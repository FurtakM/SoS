// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 66 0 0
// PrepareAnimals ( 6 , 3 , 4 , apearea ) ;
  15: LD_INT 6
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 4
  23: PPUSH
  24: LD_INT 21
  26: PPUSH
  27: CALL 10740 0 4
// PrepareAmerican ;
  31: CALL 4044 0 0
// PrepareRussian ;
  35: CALL 314 0 0
// Action ;
  39: CALL 8417 0 0
// end ;
  43: END
// every 0 0$01 do
  44: GO 46
  46: DISABLE
// begin enable ;
  47: ENABLE
// display_strings := [ #tick , tick ] ;
  48: LD_ADDR_OWVAR 47
  52: PUSH
  53: LD_STRING #tick
  55: PUSH
  56: LD_OWVAR 1
  60: PUSH
  61: EMPTY
  62: LIST
  63: LIST
  64: ST_TO_ADDR
// end ;
  65: END
// export conv_squad , escort , medal1 , medal2 , medal3 , path , convoy_start , dest_counter ; export riv , ar_attacks , ar_force , us_force , conv_counter , crates_counter , safeCounter ; function Init ; begin
  66: LD_INT 0
  68: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  69: LD_ADDR_OWVAR 67
  73: PUSH
  74: LD_INT 0
  76: PPUSH
  77: CALL_OW 426
  81: ST_TO_ADDR
// medal1 := true ;
  82: LD_ADDR_EXP 3
  86: PUSH
  87: LD_INT 1
  89: ST_TO_ADDR
// medal2 := true ;
  90: LD_ADDR_EXP 4
  94: PUSH
  95: LD_INT 1
  97: ST_TO_ADDR
// medal3 := true ;
  98: LD_ADDR_EXP 5
 102: PUSH
 103: LD_INT 1
 105: ST_TO_ADDR
// path := [ pp1 , pp2 , pp3 , pp4 , conv_end ] ;
 106: LD_ADDR_EXP 6
 110: PUSH
 111: LD_INT 10
 113: PUSH
 114: LD_INT 11
 116: PUSH
 117: LD_INT 12
 119: PUSH
 120: LD_INT 13
 122: PUSH
 123: LD_INT 9
 125: PUSH
 126: EMPTY
 127: LIST
 128: LIST
 129: LIST
 130: LIST
 131: LIST
 132: ST_TO_ADDR
// conv_squad := [ ] ;
 133: LD_ADDR_EXP 1
 137: PUSH
 138: EMPTY
 139: ST_TO_ADDR
// escort := [ ] ;
 140: LD_ADDR_EXP 2
 144: PUSH
 145: EMPTY
 146: ST_TO_ADDR
// riv := [ ] ;
 147: LD_ADDR_EXP 9
 151: PUSH
 152: EMPTY
 153: ST_TO_ADDR
// ar_force := [ ] ;
 154: LD_ADDR_EXP 11
 158: PUSH
 159: EMPTY
 160: ST_TO_ADDR
// ar_attacks := false ;
 161: LD_ADDR_EXP 10
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// us_force := [ ] ;
 169: LD_ADDR_EXP 12
 173: PUSH
 174: EMPTY
 175: ST_TO_ADDR
// convoy_start := false ;
 176: LD_ADDR_EXP 7
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// conv_counter := 0 ;
 184: LD_ADDR_EXP 13
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// dest_counter := 0 ;
 192: LD_ADDR_EXP 8
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// crates_counter := 1 1$10 ;
 200: LD_ADDR_EXP 14
 204: PUSH
 205: LD_INT 2450
 207: ST_TO_ADDR
// safeCounter := 0 ;
 208: LD_ADDR_EXP 15
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// end ;
 216: LD_VAR 0 1
 220: RET
// every 2 2$00 do
 221: GO 223
 223: DISABLE
// begin while ( tick <= [ 47 47$00 , 44 44$00 , 41 41$00 ] [ Difficulty ] ) do
 224: LD_OWVAR 1
 228: PUSH
 229: LD_INT 98700
 231: PUSH
 232: LD_INT 92400
 234: PUSH
 235: LD_INT 86100
 237: PUSH
 238: EMPTY
 239: LIST
 240: LIST
 241: LIST
 242: PUSH
 243: LD_OWVAR 67
 247: ARRAY
 248: LESSEQUAL
 249: IFFALSE 313
// begin Wait ( crates_counter ) ;
 251: LD_EXP 14
 255: PPUSH
 256: CALL_OW 67
// crates_counter := crates_counter + 0 0$09 ;
 260: LD_ADDR_EXP 14
 264: PUSH
 265: LD_EXP 14
 269: PUSH
 270: LD_INT 315
 272: PLUS
 273: ST_TO_ADDR
// if GetResourceArea ( crates_spawn , mat_cans ) < 30 then
 274: LD_INT 22
 276: PPUSH
 277: LD_INT 1
 279: PPUSH
 280: CALL_OW 287
 284: PUSH
 285: LD_INT 30
 287: LESS
 288: IFFALSE 311
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
 290: LD_INT 1
 292: PPUSH
 293: LD_INT 5
 295: PPUSH
 296: CALL_OW 12
 300: PPUSH
 301: LD_INT 22
 303: PPUSH
 304: LD_INT 1
 306: PPUSH
 307: CALL_OW 55
// end ;
 311: GO 224
// end ; end_of_file
 313: END
// export Stolypin , Popov , Saseda ; export function PrepareRussian ; var un , force , i , c , skill , team ; begin
 314: LD_INT 0
 316: PPUSH
 317: PPUSH
 318: PPUSH
 319: PPUSH
 320: PPUSH
 321: PPUSH
 322: PPUSH
// uc_side := 6 ;
 323: LD_ADDR_OWVAR 20
 327: PUSH
 328: LD_INT 6
 330: ST_TO_ADDR
// uc_nation := 3 ;
 331: LD_ADDR_OWVAR 21
 335: PUSH
 336: LD_INT 3
 338: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
 339: LD_INT 3
 341: PPUSH
 342: LD_INT 6
 344: PPUSH
 345: CALL_OW 343
// Popov := NewCharacter ( Gaydar ) ;
 349: LD_ADDR_EXP 17
 353: PUSH
 354: LD_STRING Gaydar
 356: PPUSH
 357: CALL_OW 25
 361: ST_TO_ADDR
// uc_side := 7 ;
 362: LD_ADDR_OWVAR 20
 366: PUSH
 367: LD_INT 7
 369: ST_TO_ADDR
// hc_gallery := sandal ;
 370: LD_ADDR_OWVAR 33
 374: PUSH
 375: LD_STRING sandal
 377: ST_TO_ADDR
// hc_face_number := 9 ;
 378: LD_ADDR_OWVAR 34
 382: PUSH
 383: LD_INT 9
 385: ST_TO_ADDR
// hc_skills := [ 3 , 5 , 2 , 7 ] ;
 386: LD_ADDR_OWVAR 31
 390: PUSH
 391: LD_INT 3
 393: PUSH
 394: LD_INT 5
 396: PUSH
 397: LD_INT 2
 399: PUSH
 400: LD_INT 7
 402: PUSH
 403: EMPTY
 404: LIST
 405: LIST
 406: LIST
 407: LIST
 408: ST_TO_ADDR
// hc_sex := sex_male ;
 409: LD_ADDR_OWVAR 27
 413: PUSH
 414: LD_INT 1
 416: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 417: LD_ADDR_OWVAR 29
 421: PUSH
 422: LD_INT 10
 424: PUSH
 425: LD_INT 11
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: ST_TO_ADDR
// hc_class := 4 ;
 432: LD_ADDR_OWVAR 28
 436: PUSH
 437: LD_INT 4
 439: ST_TO_ADDR
// hc_name := Fiodor Saseda ;
 440: LD_ADDR_OWVAR 26
 444: PUSH
 445: LD_STRING Fiodor Saseda
 447: ST_TO_ADDR
// Saseda := CreateHuman ;
 448: LD_ADDR_EXP 18
 452: PUSH
 453: CALL_OW 44
 457: ST_TO_ADDR
// uc_side := 3 ;
 458: LD_ADDR_OWVAR 20
 462: PUSH
 463: LD_INT 3
 465: ST_TO_ADDR
// hc_importance := 100 ;
 466: LD_ADDR_OWVAR 32
 470: PUSH
 471: LD_INT 100
 473: ST_TO_ADDR
// hc_class := 1 ;
 474: LD_ADDR_OWVAR 28
 478: PUSH
 479: LD_INT 1
 481: ST_TO_ADDR
// hc_sex := sex_male ;
 482: LD_ADDR_OWVAR 27
 486: PUSH
 487: LD_INT 1
 489: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
 490: LD_ADDR_OWVAR 31
 494: PUSH
 495: LD_INT 6
 497: PUSH
 498: LD_INT 3
 500: PUSH
 501: LD_INT 4
 503: PUSH
 504: LD_INT 2
 506: PUSH
 507: EMPTY
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: ST_TO_ADDR
// hc_name := W. I. Stolypin ;
 513: LD_ADDR_OWVAR 26
 517: PUSH
 518: LD_STRING W. I. Stolypin
 520: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 521: LD_ADDR_OWVAR 29
 525: PUSH
 526: LD_INT 10
 528: PUSH
 529: LD_INT 11
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: ST_TO_ADDR
// hc_gallery := ru ;
 536: LD_ADDR_OWVAR 33
 540: PUSH
 541: LD_STRING ru
 543: ST_TO_ADDR
// hc_face_number := 15 ;
 544: LD_ADDR_OWVAR 34
 548: PUSH
 549: LD_INT 15
 551: ST_TO_ADDR
// Stolypin := CreateHuman ;
 552: LD_ADDR_EXP 16
 556: PUSH
 557: CALL_OW 44
 561: ST_TO_ADDR
// hc_importance := 0 ;
 562: LD_ADDR_OWVAR 32
 566: PUSH
 567: LD_INT 0
 569: ST_TO_ADDR
// hc_gallery :=  ;
 570: LD_ADDR_OWVAR 33
 574: PUSH
 575: LD_STRING 
 577: ST_TO_ADDR
// hc_name :=  ;
 578: LD_ADDR_OWVAR 26
 582: PUSH
 583: LD_STRING 
 585: ST_TO_ADDR
// skill := [ 6 , 5 , 5 ] [ Difficulty ] ;
 586: LD_ADDR_VAR 0 6
 590: PUSH
 591: LD_INT 6
 593: PUSH
 594: LD_INT 5
 596: PUSH
 597: LD_INT 5
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: PUSH
 605: LD_OWVAR 67
 609: ARRAY
 610: ST_TO_ADDR
// c := 1 ;
 611: LD_ADDR_VAR 0 5
 615: PUSH
 616: LD_INT 1
 618: ST_TO_ADDR
// for i = 1 to 21 do
 619: LD_ADDR_VAR 0 4
 623: PUSH
 624: DOUBLE
 625: LD_INT 1
 627: DEC
 628: ST_TO_ADDR
 629: LD_INT 21
 631: PUSH
 632: FOR_TO
 633: IFFALSE 734
// begin if i = 10 then
 635: LD_VAR 0 4
 639: PUSH
 640: LD_INT 10
 642: EQUAL
 643: IFFALSE 653
// c := 2 ;
 645: LD_ADDR_VAR 0 5
 649: PUSH
 650: LD_INT 2
 652: ST_TO_ADDR
// if i = 14 then
 653: LD_VAR 0 4
 657: PUSH
 658: LD_INT 14
 660: EQUAL
 661: IFFALSE 671
// c := 3 ;
 663: LD_ADDR_VAR 0 5
 667: PUSH
 668: LD_INT 3
 670: ST_TO_ADDR
// if i = 18 then
 671: LD_VAR 0 4
 675: PUSH
 676: LD_INT 18
 678: EQUAL
 679: IFFALSE 689
// c := 4 ;
 681: LD_ADDR_VAR 0 5
 685: PUSH
 686: LD_INT 4
 688: ST_TO_ADDR
// PrepareHuman ( false , c , skill ) ;
 689: LD_INT 0
 691: PPUSH
 692: LD_VAR 0 5
 696: PPUSH
 697: LD_VAR 0 6
 701: PPUSH
 702: CALL_OW 380
// un := CreateHuman ;
 706: LD_ADDR_VAR 0 2
 710: PUSH
 711: CALL_OW 44
 715: ST_TO_ADDR
// force := force ^ un ;
 716: LD_ADDR_VAR 0 3
 720: PUSH
 721: LD_VAR 0 3
 725: PUSH
 726: LD_VAR 0 2
 730: ADD
 731: ST_TO_ADDR
// end ;
 732: GO 632
 734: POP
 735: POP
// team := CharacterSelection ( text , [ 7 , 6 , 6 ] [ Difficulty ] , [ 7 , 6 , 6 ] [ Difficulty ] , [ sel_change_class , Stolypin , sel_changeable , sel_not_hired ] ^ force , [ [ class_soldier , 3 ] , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
 736: LD_ADDR_VAR 0 7
 740: PUSH
 741: LD_STRING text
 743: PPUSH
 744: LD_INT 7
 746: PUSH
 747: LD_INT 6
 749: PUSH
 750: LD_INT 6
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: LIST
 757: PUSH
 758: LD_OWVAR 67
 762: ARRAY
 763: PPUSH
 764: LD_INT 7
 766: PUSH
 767: LD_INT 6
 769: PUSH
 770: LD_INT 6
 772: PUSH
 773: EMPTY
 774: LIST
 775: LIST
 776: LIST
 777: PUSH
 778: LD_OWVAR 67
 782: ARRAY
 783: PPUSH
 784: LD_INT -5
 786: PUSH
 787: LD_EXP 16
 791: PUSH
 792: LD_INT -3
 794: PUSH
 795: LD_INT -2
 797: PUSH
 798: EMPTY
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: PUSH
 804: LD_VAR 0 3
 808: ADD
 809: PPUSH
 810: LD_INT 1
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: LD_INT 2
 825: PUSH
 826: LD_INT 1
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: PUSH
 833: LD_INT 4
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: PPUSH
 842: CALL_OW 42
 846: ST_TO_ADDR
// team := team ^ Stolypin ;
 847: LD_ADDR_VAR 0 7
 851: PUSH
 852: LD_VAR 0 7
 856: PUSH
 857: LD_EXP 16
 861: ADD
 862: ST_TO_ADDR
// for i = 1 to team do
 863: LD_ADDR_VAR 0 4
 867: PUSH
 868: DOUBLE
 869: LD_INT 1
 871: DEC
 872: ST_TO_ADDR
 873: LD_VAR 0 7
 877: PUSH
 878: FOR_TO
 879: IFFALSE 904
// PlaceUnitArea ( team [ i ] , rus_start , false ) ;
 881: LD_VAR 0 7
 885: PUSH
 886: LD_VAR 0 4
 890: ARRAY
 891: PPUSH
 892: LD_INT 1
 894: PPUSH
 895: LD_INT 0
 897: PPUSH
 898: CALL_OW 49
 902: GO 878
 904: POP
 905: POP
// CenterNowOnUnits ( Stolypin ) ;
 906: LD_EXP 16
 910: PPUSH
 911: CALL_OW 87
// end ;
 915: LD_VAR 0 1
 919: RET
// export conv_ready ; export function Convoy ( type ) ; var i , veh , skill ; begin
 920: LD_INT 0
 922: PPUSH
 923: PPUSH
 924: PPUSH
 925: PPUSH
// Randomize ;
 926: CALL_OW 10
// uc_side := 6 ;
 930: LD_ADDR_OWVAR 20
 934: PUSH
 935: LD_INT 6
 937: ST_TO_ADDR
// uc_nation := 3 ;
 938: LD_ADDR_OWVAR 21
 942: PUSH
 943: LD_INT 3
 945: ST_TO_ADDR
// hc_name :=  ;
 946: LD_ADDR_OWVAR 26
 950: PUSH
 951: LD_STRING 
 953: ST_TO_ADDR
// hc_gallery :=  ;
 954: LD_ADDR_OWVAR 33
 958: PUSH
 959: LD_STRING 
 961: ST_TO_ADDR
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
 962: LD_ADDR_VAR 0 5
 966: PUSH
 967: LD_INT 5
 969: PUSH
 970: LD_INT 5
 972: PUSH
 973: LD_INT 4
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: PUSH
 981: LD_OWVAR 67
 985: ARRAY
 986: ST_TO_ADDR
// conv_ready := false ;
 987: LD_ADDR_EXP 19
 991: PUSH
 992: LD_INT 0
 994: ST_TO_ADDR
// case type of 1 :
 995: LD_VAR 0 1
 999: PUSH
1000: LD_INT 1
1002: DOUBLE
1003: EQUAL
1004: IFTRUE 1008
1006: GO 1278
1008: POP
// begin if Rand ( 0 , 1 ) = 1 then
1009: LD_INT 0
1011: PPUSH
1012: LD_INT 1
1014: PPUSH
1015: CALL_OW 12
1019: PUSH
1020: LD_INT 1
1022: EQUAL
1023: IFFALSE 1029
// AddEscort ( ) ;
1025: CALL 2911 0 0
// Wait ( 0 0$03 ) ;
1029: LD_INT 105
1031: PPUSH
1032: CALL_OW 67
// vc_chassis := ru_medium_wheeled ;
1036: LD_ADDR_OWVAR 37
1040: PUSH
1041: LD_INT 21
1043: ST_TO_ADDR
// vc_engine := engine_combustion ;
1044: LD_ADDR_OWVAR 39
1048: PUSH
1049: LD_INT 1
1051: ST_TO_ADDR
// vc_control := control_manual ;
1052: LD_ADDR_OWVAR 38
1056: PUSH
1057: LD_INT 1
1059: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1060: LD_ADDR_OWVAR 40
1064: PUSH
1065: LD_INT 51
1067: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1068: LD_ADDR_OWVAR 41
1072: PUSH
1073: LD_INT 50
1075: PPUSH
1076: LD_INT 99
1078: PPUSH
1079: CALL_OW 12
1083: ST_TO_ADDR
// if uc_side <> 6 then
1084: LD_OWVAR 20
1088: PUSH
1089: LD_INT 6
1091: NONEQUAL
1092: IFFALSE 1102
// uc_side := 6 ;
1094: LD_ADDR_OWVAR 20
1098: PUSH
1099: LD_INT 6
1101: ST_TO_ADDR
// veh := CreateVehicle ;
1102: LD_ADDR_VAR 0 4
1106: PUSH
1107: CALL_OW 45
1111: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1112: LD_VAR 0 4
1116: PPUSH
1117: LD_INT 3
1119: PPUSH
1120: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1124: LD_VAR 0 4
1128: PPUSH
1129: LD_INT 8
1131: PPUSH
1132: LD_INT 0
1134: PPUSH
1135: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1139: LD_INT 0
1141: PPUSH
1142: LD_INT 1
1144: PPUSH
1145: LD_INT 2
1147: PPUSH
1148: CALL_OW 12
1152: PPUSH
1153: LD_VAR 0 5
1157: PPUSH
1158: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1162: CALL_OW 44
1166: PPUSH
1167: LD_VAR 0 4
1171: PPUSH
1172: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1176: LD_VAR 0 4
1180: PPUSH
1181: LD_INT 500
1183: PPUSH
1184: LD_INT 1000
1186: PPUSH
1187: CALL_OW 12
1191: PPUSH
1192: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1196: LD_VAR 0 4
1200: PPUSH
1201: LD_INT 1
1203: PPUSH
1204: LD_INT 2
1206: PPUSH
1207: CALL_OW 12
1211: PPUSH
1212: LD_INT 2
1214: PPUSH
1215: LD_INT 10
1217: PPUSH
1218: CALL_OW 12
1222: PUSH
1223: LD_INT 10
1225: MUL
1226: PPUSH
1227: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1231: LD_ADDR_EXP 1
1235: PUSH
1236: LD_EXP 1
1240: PPUSH
1241: LD_INT 1
1243: PPUSH
1244: LD_VAR 0 4
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: PPUSH
1256: CALL_OW 2
1260: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
1261: LD_INT 35
1263: PPUSH
1264: CALL_OW 67
// conv_ready := true ;
1268: LD_ADDR_EXP 19
1272: PUSH
1273: LD_INT 1
1275: ST_TO_ADDR
// end ; 2 :
1276: GO 2906
1278: LD_INT 2
1280: DOUBLE
1281: EQUAL
1282: IFTRUE 1286
1284: GO 1586
1286: POP
// begin AddEscort ( ) ;
1287: CALL 2911 0 0
// Wait ( 0 0$02 ) ;
1291: LD_INT 70
1293: PPUSH
1294: CALL_OW 67
// for i = 1 to 3 do
1298: LD_ADDR_VAR 0 3
1302: PUSH
1303: DOUBLE
1304: LD_INT 1
1306: DEC
1307: ST_TO_ADDR
1308: LD_INT 3
1310: PUSH
1311: FOR_TO
1312: IFFALSE 1563
// begin vc_chassis := ru_medium_wheeled ;
1314: LD_ADDR_OWVAR 37
1318: PUSH
1319: LD_INT 21
1321: ST_TO_ADDR
// vc_engine := engine_combustion ;
1322: LD_ADDR_OWVAR 39
1326: PUSH
1327: LD_INT 1
1329: ST_TO_ADDR
// vc_control := control_manual ;
1330: LD_ADDR_OWVAR 38
1334: PUSH
1335: LD_INT 1
1337: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1338: LD_ADDR_OWVAR 40
1342: PUSH
1343: LD_INT 51
1345: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1346: LD_ADDR_OWVAR 41
1350: PUSH
1351: LD_INT 50
1353: PPUSH
1354: LD_INT 99
1356: PPUSH
1357: CALL_OW 12
1361: ST_TO_ADDR
// if uc_side <> 6 then
1362: LD_OWVAR 20
1366: PUSH
1367: LD_INT 6
1369: NONEQUAL
1370: IFFALSE 1380
// uc_side := 6 ;
1372: LD_ADDR_OWVAR 20
1376: PUSH
1377: LD_INT 6
1379: ST_TO_ADDR
// veh := CreateVehicle ;
1380: LD_ADDR_VAR 0 4
1384: PUSH
1385: CALL_OW 45
1389: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1390: LD_VAR 0 4
1394: PPUSH
1395: LD_INT 3
1397: PPUSH
1398: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1402: LD_VAR 0 4
1406: PPUSH
1407: LD_INT 8
1409: PPUSH
1410: LD_INT 0
1412: PPUSH
1413: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1417: LD_INT 0
1419: PPUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 2
1425: PPUSH
1426: CALL_OW 12
1430: PPUSH
1431: LD_VAR 0 5
1435: PPUSH
1436: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1440: CALL_OW 44
1444: PPUSH
1445: LD_VAR 0 4
1449: PPUSH
1450: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1454: LD_VAR 0 4
1458: PPUSH
1459: LD_INT 500
1461: PPUSH
1462: LD_INT 1000
1464: PPUSH
1465: CALL_OW 12
1469: PPUSH
1470: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1474: LD_VAR 0 4
1478: PPUSH
1479: LD_INT 1
1481: PPUSH
1482: LD_INT 2
1484: PPUSH
1485: CALL_OW 12
1489: PPUSH
1490: LD_INT 2
1492: PPUSH
1493: LD_INT 10
1495: PPUSH
1496: CALL_OW 12
1500: PUSH
1501: LD_INT 10
1503: MUL
1504: PPUSH
1505: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1509: LD_ADDR_EXP 1
1513: PUSH
1514: LD_EXP 1
1518: PPUSH
1519: LD_INT 1
1521: PPUSH
1522: LD_VAR 0 4
1526: PUSH
1527: LD_INT 1
1529: PUSH
1530: EMPTY
1531: LIST
1532: LIST
1533: PPUSH
1534: CALL_OW 2
1538: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1539: LD_VAR 0 4
1543: PPUSH
1544: LD_INT 120
1546: PPUSH
1547: LD_INT 10
1549: PPUSH
1550: CALL_OW 111
// Wait ( 0 0$03 ) ;
1554: LD_INT 105
1556: PPUSH
1557: CALL_OW 67
// end ;
1561: GO 1311
1563: POP
1564: POP
// AddEscort ( ) ;
1565: CALL 2911 0 0
// Wait ( 0 0$02 ) ;
1569: LD_INT 70
1571: PPUSH
1572: CALL_OW 67
// conv_ready := true ;
1576: LD_ADDR_EXP 19
1580: PUSH
1581: LD_INT 1
1583: ST_TO_ADDR
// end ; 3 :
1584: GO 2906
1586: LD_INT 3
1588: DOUBLE
1589: EQUAL
1590: IFTRUE 1594
1592: GO 2021
1594: POP
// begin AddEscort ( ) ;
1595: CALL 2911 0 0
// Wait ( 0 0$02 ) ;
1599: LD_INT 70
1601: PPUSH
1602: CALL_OW 67
// for i = 1 to 3 do
1606: LD_ADDR_VAR 0 3
1610: PUSH
1611: DOUBLE
1612: LD_INT 1
1614: DEC
1615: ST_TO_ADDR
1616: LD_INT 3
1618: PUSH
1619: FOR_TO
1620: IFFALSE 1871
// begin vc_chassis := ru_medium_wheeled ;
1622: LD_ADDR_OWVAR 37
1626: PUSH
1627: LD_INT 21
1629: ST_TO_ADDR
// vc_engine := engine_combustion ;
1630: LD_ADDR_OWVAR 39
1634: PUSH
1635: LD_INT 1
1637: ST_TO_ADDR
// vc_control := control_manual ;
1638: LD_ADDR_OWVAR 38
1642: PUSH
1643: LD_INT 1
1645: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1646: LD_ADDR_OWVAR 40
1650: PUSH
1651: LD_INT 51
1653: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1654: LD_ADDR_OWVAR 41
1658: PUSH
1659: LD_INT 50
1661: PPUSH
1662: LD_INT 99
1664: PPUSH
1665: CALL_OW 12
1669: ST_TO_ADDR
// if uc_side <> 6 then
1670: LD_OWVAR 20
1674: PUSH
1675: LD_INT 6
1677: NONEQUAL
1678: IFFALSE 1688
// uc_side := 6 ;
1680: LD_ADDR_OWVAR 20
1684: PUSH
1685: LD_INT 6
1687: ST_TO_ADDR
// veh := CreateVehicle ;
1688: LD_ADDR_VAR 0 4
1692: PUSH
1693: CALL_OW 45
1697: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1698: LD_VAR 0 4
1702: PPUSH
1703: LD_INT 3
1705: PPUSH
1706: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1710: LD_VAR 0 4
1714: PPUSH
1715: LD_INT 8
1717: PPUSH
1718: LD_INT 0
1720: PPUSH
1721: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1725: LD_INT 0
1727: PPUSH
1728: LD_INT 1
1730: PPUSH
1731: LD_INT 2
1733: PPUSH
1734: CALL_OW 12
1738: PPUSH
1739: LD_VAR 0 5
1743: PPUSH
1744: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1748: CALL_OW 44
1752: PPUSH
1753: LD_VAR 0 4
1757: PPUSH
1758: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1762: LD_VAR 0 4
1766: PPUSH
1767: LD_INT 500
1769: PPUSH
1770: LD_INT 1000
1772: PPUSH
1773: CALL_OW 12
1777: PPUSH
1778: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1782: LD_VAR 0 4
1786: PPUSH
1787: LD_INT 1
1789: PPUSH
1790: LD_INT 2
1792: PPUSH
1793: CALL_OW 12
1797: PPUSH
1798: LD_INT 2
1800: PPUSH
1801: LD_INT 10
1803: PPUSH
1804: CALL_OW 12
1808: PUSH
1809: LD_INT 10
1811: MUL
1812: PPUSH
1813: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1817: LD_ADDR_EXP 1
1821: PUSH
1822: LD_EXP 1
1826: PPUSH
1827: LD_INT 1
1829: PPUSH
1830: LD_VAR 0 4
1834: PUSH
1835: LD_INT 1
1837: PUSH
1838: EMPTY
1839: LIST
1840: LIST
1841: PPUSH
1842: CALL_OW 2
1846: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1847: LD_VAR 0 4
1851: PPUSH
1852: LD_INT 120
1854: PPUSH
1855: LD_INT 10
1857: PPUSH
1858: CALL_OW 111
// Wait ( 0 0$03 ) ;
1862: LD_INT 105
1864: PPUSH
1865: CALL_OW 67
// end ;
1869: GO 1619
1871: POP
1872: POP
// for i = 1 to rand ( 2 , 4 ) do
1873: LD_ADDR_VAR 0 3
1877: PUSH
1878: DOUBLE
1879: LD_INT 1
1881: DEC
1882: ST_TO_ADDR
1883: LD_INT 2
1885: PPUSH
1886: LD_INT 4
1888: PPUSH
1889: CALL_OW 12
1893: PUSH
1894: FOR_TO
1895: IFFALSE 2002
// begin PrepareHuman ( false , 1 , skill ) ;
1897: LD_INT 0
1899: PPUSH
1900: LD_INT 1
1902: PPUSH
1903: LD_VAR 0 5
1907: PPUSH
1908: CALL_OW 380
// if uc_side <> 6 then
1912: LD_OWVAR 20
1916: PUSH
1917: LD_INT 6
1919: NONEQUAL
1920: IFFALSE 1930
// uc_side := 6 ;
1922: LD_ADDR_OWVAR 20
1926: PUSH
1927: LD_INT 6
1929: ST_TO_ADDR
// veh := CreateHuman ;
1930: LD_ADDR_VAR 0 4
1934: PUSH
1935: CALL_OW 44
1939: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
1940: LD_VAR 0 4
1944: PPUSH
1945: LD_INT 8
1947: PPUSH
1948: LD_INT 0
1950: PPUSH
1951: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
1955: LD_ADDR_EXP 2
1959: PUSH
1960: LD_EXP 2
1964: PPUSH
1965: LD_INT 1
1967: PPUSH
1968: LD_VAR 0 4
1972: PPUSH
1973: CALL_OW 2
1977: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1978: LD_VAR 0 4
1982: PPUSH
1983: LD_INT 120
1985: PPUSH
1986: LD_INT 10
1988: PPUSH
1989: CALL_OW 111
// Wait ( 0 0$02 ) ;
1993: LD_INT 70
1995: PPUSH
1996: CALL_OW 67
// end ;
2000: GO 1894
2002: POP
2003: POP
// Wait ( 0 0$02 ) ;
2004: LD_INT 70
2006: PPUSH
2007: CALL_OW 67
// conv_ready := true ;
2011: LD_ADDR_EXP 19
2015: PUSH
2016: LD_INT 1
2018: ST_TO_ADDR
// end ; 4 :
2019: GO 2906
2021: LD_INT 4
2023: DOUBLE
2024: EQUAL
2025: IFTRUE 2029
2027: GO 2335
2029: POP
// begin if Rand ( 0 , 1 ) = 1 then
2030: LD_INT 0
2032: PPUSH
2033: LD_INT 1
2035: PPUSH
2036: CALL_OW 12
2040: PUSH
2041: LD_INT 1
2043: EQUAL
2044: IFFALSE 2050
// AddEscort ( ) ;
2046: CALL 2911 0 0
// Wait ( 0 0$02 ) ;
2050: LD_INT 70
2052: PPUSH
2053: CALL_OW 67
// for i = 1 to 5 do
2057: LD_ADDR_VAR 0 3
2061: PUSH
2062: DOUBLE
2063: LD_INT 1
2065: DEC
2066: ST_TO_ADDR
2067: LD_INT 5
2069: PUSH
2070: FOR_TO
2071: IFFALSE 2193
// begin PrepareHuman ( false , Rand ( 2 , 4 ) , skill ) ;
2073: LD_INT 0
2075: PPUSH
2076: LD_INT 2
2078: PPUSH
2079: LD_INT 4
2081: PPUSH
2082: CALL_OW 12
2086: PPUSH
2087: LD_VAR 0 5
2091: PPUSH
2092: CALL_OW 380
// if uc_side <> 6 then
2096: LD_OWVAR 20
2100: PUSH
2101: LD_INT 6
2103: NONEQUAL
2104: IFFALSE 2114
// uc_side := 6 ;
2106: LD_ADDR_OWVAR 20
2110: PUSH
2111: LD_INT 6
2113: ST_TO_ADDR
// veh := CreateHuman ;
2114: LD_ADDR_VAR 0 4
2118: PUSH
2119: CALL_OW 44
2123: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2124: LD_VAR 0 4
2128: PPUSH
2129: LD_INT 8
2131: PPUSH
2132: LD_INT 0
2134: PPUSH
2135: CALL_OW 49
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2139: LD_ADDR_EXP 1
2143: PUSH
2144: LD_EXP 1
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_VAR 0 4
2156: PUSH
2157: LD_INT 1
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: PPUSH
2164: CALL_OW 2
2168: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2169: LD_VAR 0 4
2173: PPUSH
2174: LD_INT 120
2176: PPUSH
2177: LD_INT 10
2179: PPUSH
2180: CALL_OW 111
// Wait ( 0 0$02 ) ;
2184: LD_INT 70
2186: PPUSH
2187: CALL_OW 67
// end ;
2191: GO 2070
2193: POP
2194: POP
// for i = 1 to 2 do
2195: LD_ADDR_VAR 0 3
2199: PUSH
2200: DOUBLE
2201: LD_INT 1
2203: DEC
2204: ST_TO_ADDR
2205: LD_INT 2
2207: PUSH
2208: FOR_TO
2209: IFFALSE 2316
// begin PrepareHuman ( false , 1 , skill ) ;
2211: LD_INT 0
2213: PPUSH
2214: LD_INT 1
2216: PPUSH
2217: LD_VAR 0 5
2221: PPUSH
2222: CALL_OW 380
// if uc_side <> 6 then
2226: LD_OWVAR 20
2230: PUSH
2231: LD_INT 6
2233: NONEQUAL
2234: IFFALSE 2244
// uc_side := 6 ;
2236: LD_ADDR_OWVAR 20
2240: PUSH
2241: LD_INT 6
2243: ST_TO_ADDR
// veh := CreateHuman ;
2244: LD_ADDR_VAR 0 4
2248: PUSH
2249: CALL_OW 44
2253: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2254: LD_VAR 0 4
2258: PPUSH
2259: LD_INT 8
2261: PPUSH
2262: LD_INT 0
2264: PPUSH
2265: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
2269: LD_ADDR_EXP 2
2273: PUSH
2274: LD_EXP 2
2278: PPUSH
2279: LD_INT 1
2281: PPUSH
2282: LD_VAR 0 4
2286: PPUSH
2287: CALL_OW 2
2291: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2292: LD_VAR 0 4
2296: PPUSH
2297: LD_INT 120
2299: PPUSH
2300: LD_INT 10
2302: PPUSH
2303: CALL_OW 111
// Wait ( 0 0$02 ) ;
2307: LD_INT 70
2309: PPUSH
2310: CALL_OW 67
// end ;
2314: GO 2208
2316: POP
2317: POP
// Wait ( 0 0$02 ) ;
2318: LD_INT 70
2320: PPUSH
2321: CALL_OW 67
// conv_ready := true ;
2325: LD_ADDR_EXP 19
2329: PUSH
2330: LD_INT 1
2332: ST_TO_ADDR
// end ; 5 :
2333: GO 2906
2335: LD_INT 5
2337: DOUBLE
2338: EQUAL
2339: IFTRUE 2343
2341: GO 2905
2343: POP
// begin AddEscort ( ) ;
2344: CALL 2911 0 0
// Wait ( 0 0$02 ) ;
2348: LD_INT 70
2350: PPUSH
2351: CALL_OW 67
// AddEscort ( ) ;
2355: CALL 2911 0 0
// Wait ( 0 0$02 ) ;
2359: LD_INT 70
2361: PPUSH
2362: CALL_OW 67
// for i = 1 to 3 do
2366: LD_ADDR_VAR 0 3
2370: PUSH
2371: DOUBLE
2372: LD_INT 1
2374: DEC
2375: ST_TO_ADDR
2376: LD_INT 3
2378: PUSH
2379: FOR_TO
2380: IFFALSE 2631
// begin vc_chassis := ru_medium_wheeled ;
2382: LD_ADDR_OWVAR 37
2386: PUSH
2387: LD_INT 21
2389: ST_TO_ADDR
// vc_engine := engine_combustion ;
2390: LD_ADDR_OWVAR 39
2394: PUSH
2395: LD_INT 1
2397: ST_TO_ADDR
// vc_control := control_manual ;
2398: LD_ADDR_OWVAR 38
2402: PUSH
2403: LD_INT 1
2405: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2406: LD_ADDR_OWVAR 40
2410: PUSH
2411: LD_INT 51
2413: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2414: LD_ADDR_OWVAR 41
2418: PUSH
2419: LD_INT 50
2421: PPUSH
2422: LD_INT 99
2424: PPUSH
2425: CALL_OW 12
2429: ST_TO_ADDR
// if uc_side <> 6 then
2430: LD_OWVAR 20
2434: PUSH
2435: LD_INT 6
2437: NONEQUAL
2438: IFFALSE 2448
// uc_side := 6 ;
2440: LD_ADDR_OWVAR 20
2444: PUSH
2445: LD_INT 6
2447: ST_TO_ADDR
// veh := CreateVehicle ;
2448: LD_ADDR_VAR 0 4
2452: PUSH
2453: CALL_OW 45
2457: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2458: LD_VAR 0 4
2462: PPUSH
2463: LD_INT 3
2465: PPUSH
2466: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2470: LD_VAR 0 4
2474: PPUSH
2475: LD_INT 8
2477: PPUSH
2478: LD_INT 0
2480: PPUSH
2481: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2485: LD_INT 0
2487: PPUSH
2488: LD_INT 1
2490: PPUSH
2491: LD_INT 2
2493: PPUSH
2494: CALL_OW 12
2498: PPUSH
2499: LD_VAR 0 5
2503: PPUSH
2504: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2508: CALL_OW 44
2512: PPUSH
2513: LD_VAR 0 4
2517: PPUSH
2518: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2522: LD_VAR 0 4
2526: PPUSH
2527: LD_INT 500
2529: PPUSH
2530: LD_INT 1000
2532: PPUSH
2533: CALL_OW 12
2537: PPUSH
2538: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
2542: LD_VAR 0 4
2546: PPUSH
2547: LD_INT 1
2549: PPUSH
2550: LD_INT 2
2552: PPUSH
2553: CALL_OW 12
2557: PPUSH
2558: LD_INT 2
2560: PPUSH
2561: LD_INT 10
2563: PPUSH
2564: CALL_OW 12
2568: PUSH
2569: LD_INT 10
2571: MUL
2572: PPUSH
2573: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2577: LD_ADDR_EXP 1
2581: PUSH
2582: LD_EXP 1
2586: PPUSH
2587: LD_INT 1
2589: PPUSH
2590: LD_VAR 0 4
2594: PUSH
2595: LD_INT 1
2597: PUSH
2598: EMPTY
2599: LIST
2600: LIST
2601: PPUSH
2602: CALL_OW 2
2606: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2607: LD_VAR 0 4
2611: PPUSH
2612: LD_INT 120
2614: PPUSH
2615: LD_INT 10
2617: PPUSH
2618: CALL_OW 111
// Wait ( 0 0$02 ) ;
2622: LD_INT 70
2624: PPUSH
2625: CALL_OW 67
// end ;
2629: GO 2379
2631: POP
2632: POP
// if Rand ( 0 , 1 ) = 1 then
2633: LD_INT 0
2635: PPUSH
2636: LD_INT 1
2638: PPUSH
2639: CALL_OW 12
2643: PUSH
2644: LD_INT 1
2646: EQUAL
2647: IFFALSE 2683
// begin vc_chassis := ru_medium_tracked ;
2649: LD_ADDR_OWVAR 37
2653: PUSH
2654: LD_INT 22
2656: ST_TO_ADDR
// vc_engine := engine_combustion ;
2657: LD_ADDR_OWVAR 39
2661: PUSH
2662: LD_INT 1
2664: ST_TO_ADDR
// vc_control := control_manual ;
2665: LD_ADDR_OWVAR 38
2669: PUSH
2670: LD_INT 1
2672: ST_TO_ADDR
// vc_weapon := ru_crane ;
2673: LD_ADDR_OWVAR 40
2677: PUSH
2678: LD_INT 52
2680: ST_TO_ADDR
// end else
2681: GO 2715
// begin vc_chassis := ru_heavy_wheeled ;
2683: LD_ADDR_OWVAR 37
2687: PUSH
2688: LD_INT 23
2690: ST_TO_ADDR
// vc_engine := engine_combustion ;
2691: LD_ADDR_OWVAR 39
2695: PUSH
2696: LD_INT 1
2698: ST_TO_ADDR
// vc_control := control_manual ;
2699: LD_ADDR_OWVAR 38
2703: PUSH
2704: LD_INT 1
2706: ST_TO_ADDR
// vc_weapon := ru_bulldozer ;
2707: LD_ADDR_OWVAR 40
2711: PUSH
2712: LD_INT 53
2714: ST_TO_ADDR
// end ; vc_fuel_battery := Rand ( 50 , 99 ) ;
2715: LD_ADDR_OWVAR 41
2719: PUSH
2720: LD_INT 50
2722: PPUSH
2723: LD_INT 99
2725: PPUSH
2726: CALL_OW 12
2730: ST_TO_ADDR
// if uc_side <> 6 then
2731: LD_OWVAR 20
2735: PUSH
2736: LD_INT 6
2738: NONEQUAL
2739: IFFALSE 2749
// uc_side := 6 ;
2741: LD_ADDR_OWVAR 20
2745: PUSH
2746: LD_INT 6
2748: ST_TO_ADDR
// veh := CreateVehicle ;
2749: LD_ADDR_VAR 0 4
2753: PUSH
2754: CALL_OW 45
2758: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2759: LD_VAR 0 4
2763: PPUSH
2764: LD_INT 3
2766: PPUSH
2767: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2771: LD_VAR 0 4
2775: PPUSH
2776: LD_INT 8
2778: PPUSH
2779: LD_INT 0
2781: PPUSH
2782: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2786: LD_INT 0
2788: PPUSH
2789: LD_INT 1
2791: PPUSH
2792: LD_INT 2
2794: PPUSH
2795: CALL_OW 12
2799: PPUSH
2800: LD_VAR 0 5
2804: PPUSH
2805: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2809: CALL_OW 44
2813: PPUSH
2814: LD_VAR 0 4
2818: PPUSH
2819: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2823: LD_VAR 0 4
2827: PPUSH
2828: LD_INT 500
2830: PPUSH
2831: LD_INT 1000
2833: PPUSH
2834: CALL_OW 12
2838: PPUSH
2839: CALL_OW 234
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2843: LD_ADDR_EXP 1
2847: PUSH
2848: LD_EXP 1
2852: PPUSH
2853: LD_INT 1
2855: PPUSH
2856: LD_VAR 0 4
2860: PUSH
2861: LD_INT 1
2863: PUSH
2864: EMPTY
2865: LIST
2866: LIST
2867: PPUSH
2868: CALL_OW 2
2872: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2873: LD_VAR 0 4
2877: PPUSH
2878: LD_INT 120
2880: PPUSH
2881: LD_INT 10
2883: PPUSH
2884: CALL_OW 111
// Wait ( 0 0$02 ) ;
2888: LD_INT 70
2890: PPUSH
2891: CALL_OW 67
// conv_ready := true ;
2895: LD_ADDR_EXP 19
2899: PUSH
2900: LD_INT 1
2902: ST_TO_ADDR
// end ; end ;
2903: GO 2906
2905: POP
// end ;
2906: LD_VAR 0 2
2910: RET
// export function AddEscort ( ) ; var veh , skill ; begin
2911: LD_INT 0
2913: PPUSH
2914: PPUSH
2915: PPUSH
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
2916: LD_ADDR_VAR 0 3
2920: PUSH
2921: LD_INT 5
2923: PUSH
2924: LD_INT 5
2926: PUSH
2927: LD_INT 4
2929: PUSH
2930: EMPTY
2931: LIST
2932: LIST
2933: LIST
2934: PUSH
2935: LD_OWVAR 67
2939: ARRAY
2940: ST_TO_ADDR
// uc_side := 6 ;
2941: LD_ADDR_OWVAR 20
2945: PUSH
2946: LD_INT 6
2948: ST_TO_ADDR
// uc_nation := 3 ;
2949: LD_ADDR_OWVAR 21
2953: PUSH
2954: LD_INT 3
2956: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
2957: LD_ADDR_OWVAR 37
2961: PUSH
2962: LD_INT 21
2964: ST_TO_ADDR
// vc_engine := engine_combustion ;
2965: LD_ADDR_OWVAR 39
2969: PUSH
2970: LD_INT 1
2972: ST_TO_ADDR
// vc_control := control_manual ;
2973: LD_ADDR_OWVAR 38
2977: PUSH
2978: LD_INT 1
2980: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_heavy_machine_gun ] [ Rand ( 1 , 2 ) ] ;
2981: LD_ADDR_OWVAR 40
2985: PUSH
2986: LD_INT 44
2988: PUSH
2989: LD_INT 42
2991: PUSH
2992: EMPTY
2993: LIST
2994: LIST
2995: PUSH
2996: LD_INT 1
2998: PPUSH
2999: LD_INT 2
3001: PPUSH
3002: CALL_OW 12
3006: ARRAY
3007: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
3008: LD_ADDR_OWVAR 41
3012: PUSH
3013: LD_INT 50
3015: PPUSH
3016: LD_INT 99
3018: PPUSH
3019: CALL_OW 12
3023: ST_TO_ADDR
// veh := CreateVehicle ;
3024: LD_ADDR_VAR 0 2
3028: PUSH
3029: CALL_OW 45
3033: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3034: LD_VAR 0 2
3038: PPUSH
3039: LD_INT 3
3041: PPUSH
3042: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
3046: LD_VAR 0 2
3050: PPUSH
3051: LD_INT 8
3053: PPUSH
3054: LD_INT 0
3056: PPUSH
3057: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
3061: LD_INT 0
3063: PPUSH
3064: LD_INT 3
3066: PPUSH
3067: LD_VAR 0 3
3071: PPUSH
3072: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3076: CALL_OW 44
3080: PPUSH
3081: LD_VAR 0 2
3085: PPUSH
3086: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
3090: LD_VAR 0 2
3094: PPUSH
3095: LD_INT 500
3097: PPUSH
3098: LD_INT 1000
3100: PPUSH
3101: CALL_OW 12
3105: PPUSH
3106: CALL_OW 234
// escort := Insert ( escort , 1 , veh ) ;
3110: LD_ADDR_EXP 2
3114: PUSH
3115: LD_EXP 2
3119: PPUSH
3120: LD_INT 1
3122: PPUSH
3123: LD_VAR 0 2
3127: PPUSH
3128: CALL_OW 2
3132: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
3133: LD_VAR 0 2
3137: PPUSH
3138: LD_INT 120
3140: PPUSH
3141: LD_INT 10
3143: PPUSH
3144: CALL_OW 111
// end ;
3148: LD_VAR 0 1
3152: RET
// every 4 trigger conv_ready and FilterAllUnits ( [ f_side , 6 ] ) do var i , j ;
3153: LD_EXP 19
3157: PUSH
3158: LD_INT 22
3160: PUSH
3161: LD_INT 6
3163: PUSH
3164: EMPTY
3165: LIST
3166: LIST
3167: PPUSH
3168: CALL_OW 69
3172: AND
3173: IFFALSE 3948
3175: GO 3177
3177: DISABLE
3178: LD_INT 0
3180: PPUSH
3181: PPUSH
// begin enable ;
3182: ENABLE
// if conv_squad then
3183: LD_EXP 1
3187: IFFALSE 3458
// for i = conv_squad downto 1 do
3189: LD_ADDR_VAR 0 1
3193: PUSH
3194: DOUBLE
3195: LD_EXP 1
3199: INC
3200: ST_TO_ADDR
3201: LD_INT 1
3203: PUSH
3204: FOR_DOWNTO
3205: IFFALSE 3456
// begin if IsInArea ( conv_squad [ i ] [ 1 ] , conv_end ) then
3207: LD_EXP 1
3211: PUSH
3212: LD_VAR 0 1
3216: ARRAY
3217: PUSH
3218: LD_INT 1
3220: ARRAY
3221: PPUSH
3222: LD_INT 9
3224: PPUSH
3225: CALL_OW 308
3229: IFFALSE 3306
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3231: LD_ADDR_VAR 0 2
3235: PUSH
3236: LD_INT 9
3238: PPUSH
3239: LD_INT 22
3241: PUSH
3242: LD_INT 6
3244: PUSH
3245: EMPTY
3246: LIST
3247: LIST
3248: PPUSH
3249: CALL_OW 70
3253: PUSH
3254: FOR_IN
3255: IFFALSE 3282
// begin safeCounter := safeCounter + 1 ;
3257: LD_ADDR_EXP 15
3261: PUSH
3262: LD_EXP 15
3266: PUSH
3267: LD_INT 1
3269: PLUS
3270: ST_TO_ADDR
// RemoveUnit ( j ) ;
3271: LD_VAR 0 2
3275: PPUSH
3276: CALL_OW 64
// end ;
3280: GO 3254
3282: POP
3283: POP
// conv_squad := Delete ( conv_squad , i ) ;
3284: LD_ADDR_EXP 1
3288: PUSH
3289: LD_EXP 1
3293: PPUSH
3294: LD_VAR 0 1
3298: PPUSH
3299: CALL_OW 3
3303: ST_TO_ADDR
// break ;
3304: GO 3456
// end ; if IsInArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) then
3306: LD_EXP 1
3310: PUSH
3311: LD_VAR 0 1
3315: ARRAY
3316: PUSH
3317: LD_INT 1
3319: ARRAY
3320: PPUSH
3321: LD_EXP 6
3325: PUSH
3326: LD_EXP 1
3330: PUSH
3331: LD_VAR 0 1
3335: ARRAY
3336: PUSH
3337: LD_INT 2
3339: ARRAY
3340: ARRAY
3341: PPUSH
3342: CALL_OW 308
3346: IFFALSE 3392
// conv_squad := Replace2 ( conv_squad , i , 2 , conv_squad [ i ] [ 2 ] + 1 ) else
3348: LD_ADDR_EXP 1
3352: PUSH
3353: LD_EXP 1
3357: PPUSH
3358: LD_VAR 0 1
3362: PPUSH
3363: LD_INT 2
3365: PPUSH
3366: LD_EXP 1
3370: PUSH
3371: LD_VAR 0 1
3375: ARRAY
3376: PUSH
3377: LD_INT 2
3379: ARRAY
3380: PUSH
3381: LD_INT 1
3383: PLUS
3384: PPUSH
3385: CALL 10308 0 4
3389: ST_TO_ADDR
3390: GO 3454
// if not HasTask ( conv_squad [ i ] [ 1 ] ) then
3392: LD_EXP 1
3396: PUSH
3397: LD_VAR 0 1
3401: ARRAY
3402: PUSH
3403: LD_INT 1
3405: ARRAY
3406: PPUSH
3407: CALL_OW 314
3411: NOT
3412: IFFALSE 3454
// ComMoveToArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) ;
3414: LD_EXP 1
3418: PUSH
3419: LD_VAR 0 1
3423: ARRAY
3424: PUSH
3425: LD_INT 1
3427: ARRAY
3428: PPUSH
3429: LD_EXP 6
3433: PUSH
3434: LD_EXP 1
3438: PUSH
3439: LD_VAR 0 1
3443: ARRAY
3444: PUSH
3445: LD_INT 2
3447: ARRAY
3448: ARRAY
3449: PPUSH
3450: CALL_OW 113
// end ;
3454: GO 3204
3456: POP
3457: POP
// if escort then
3458: LD_EXP 2
3462: IFFALSE 3801
// for i = escort downto 1 do
3464: LD_ADDR_VAR 0 1
3468: PUSH
3469: DOUBLE
3470: LD_EXP 2
3474: INC
3475: ST_TO_ADDR
3476: LD_INT 1
3478: PUSH
3479: FOR_DOWNTO
3480: IFFALSE 3799
// begin if IsInArea ( escort [ i ] , conv_end ) then
3482: LD_EXP 2
3486: PUSH
3487: LD_VAR 0 1
3491: ARRAY
3492: PPUSH
3493: LD_INT 9
3495: PPUSH
3496: CALL_OW 308
3500: IFFALSE 3577
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3502: LD_ADDR_VAR 0 2
3506: PUSH
3507: LD_INT 9
3509: PPUSH
3510: LD_INT 22
3512: PUSH
3513: LD_INT 6
3515: PUSH
3516: EMPTY
3517: LIST
3518: LIST
3519: PPUSH
3520: CALL_OW 70
3524: PUSH
3525: FOR_IN
3526: IFFALSE 3553
// begin safeCounter := safeCounter + 1 ;
3528: LD_ADDR_EXP 15
3532: PUSH
3533: LD_EXP 15
3537: PUSH
3538: LD_INT 1
3540: PLUS
3541: ST_TO_ADDR
// RemoveUnit ( j ) ;
3542: LD_VAR 0 2
3546: PPUSH
3547: CALL_OW 64
// end ;
3551: GO 3525
3553: POP
3554: POP
// escort := Delete ( escort , i ) ;
3555: LD_ADDR_EXP 2
3559: PUSH
3560: LD_EXP 2
3564: PPUSH
3565: LD_VAR 0 1
3569: PPUSH
3570: CALL_OW 3
3574: ST_TO_ADDR
// break ;
3575: GO 3799
// end ; if FindTarget ( escort [ i ] ) and GetDistUnits ( escort [ i ] , FindTarget ( escort [ i ] ) ) < 13 then
3577: LD_EXP 2
3581: PUSH
3582: LD_VAR 0 1
3586: ARRAY
3587: PPUSH
3588: CALL 10616 0 1
3592: PUSH
3593: LD_EXP 2
3597: PUSH
3598: LD_VAR 0 1
3602: ARRAY
3603: PPUSH
3604: LD_EXP 2
3608: PUSH
3609: LD_VAR 0 1
3613: ARRAY
3614: PPUSH
3615: CALL 10616 0 1
3619: PPUSH
3620: CALL_OW 296
3624: PUSH
3625: LD_INT 13
3627: LESS
3628: AND
3629: IFFALSE 3664
// ComAttackUnit ( escort [ i ] , FindTarget ( escort [ i ] ) ) else
3631: LD_EXP 2
3635: PUSH
3636: LD_VAR 0 1
3640: ARRAY
3641: PPUSH
3642: LD_EXP 2
3646: PUSH
3647: LD_VAR 0 1
3651: ARRAY
3652: PPUSH
3653: CALL 10616 0 1
3657: PPUSH
3658: CALL_OW 115
3662: GO 3797
// if conv_squad and GetDistUnitXY ( escort [ i ] , 64 , 117 ) > 35 and not HasTask ( escort [ i ] ) then
3664: LD_EXP 1
3668: PUSH
3669: LD_EXP 2
3673: PUSH
3674: LD_VAR 0 1
3678: ARRAY
3679: PPUSH
3680: LD_INT 64
3682: PPUSH
3683: LD_INT 117
3685: PPUSH
3686: CALL_OW 297
3690: PUSH
3691: LD_INT 35
3693: GREATER
3694: AND
3695: PUSH
3696: LD_EXP 2
3700: PUSH
3701: LD_VAR 0 1
3705: ARRAY
3706: PPUSH
3707: CALL_OW 314
3711: NOT
3712: AND
3713: IFFALSE 3779
// begin if GetDistUnits ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) > 6 then
3715: LD_EXP 2
3719: PUSH
3720: LD_VAR 0 1
3724: ARRAY
3725: PPUSH
3726: LD_EXP 1
3730: PUSH
3731: LD_INT 1
3733: ARRAY
3734: PUSH
3735: LD_INT 1
3737: ARRAY
3738: PPUSH
3739: CALL_OW 296
3743: PUSH
3744: LD_INT 6
3746: GREATER
3747: IFFALSE 3777
// ComMoveUnit ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) end else
3749: LD_EXP 2
3753: PUSH
3754: LD_VAR 0 1
3758: ARRAY
3759: PPUSH
3760: LD_EXP 1
3764: PUSH
3765: LD_INT 1
3767: ARRAY
3768: PUSH
3769: LD_INT 1
3771: ARRAY
3772: PPUSH
3773: CALL_OW 112
3777: GO 3797
// ComMoveToArea ( escort [ i ] , conv_end ) ;
3779: LD_EXP 2
3783: PUSH
3784: LD_VAR 0 1
3788: ARRAY
3789: PPUSH
3790: LD_INT 9
3792: PPUSH
3793: CALL_OW 113
// end ;
3797: GO 3479
3799: POP
3800: POP
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) then
3801: LD_INT 22
3803: PUSH
3804: LD_INT 6
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: LD_INT 21
3813: PUSH
3814: LD_INT 1
3816: PUSH
3817: EMPTY
3818: LIST
3819: LIST
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: PPUSH
3825: CALL_OW 69
3829: IFFALSE 3948
// for j in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) do
3831: LD_ADDR_VAR 0 2
3835: PUSH
3836: LD_INT 22
3838: PUSH
3839: LD_INT 6
3841: PUSH
3842: EMPTY
3843: LIST
3844: LIST
3845: PUSH
3846: LD_INT 21
3848: PUSH
3849: LD_INT 1
3851: PUSH
3852: EMPTY
3853: LIST
3854: LIST
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PPUSH
3860: CALL_OW 69
3864: PUSH
3865: FOR_IN
3866: IFFALSE 3946
// begin if not HasTask ( j ) and not IsInArea ( j , conv_end ) then
3868: LD_VAR 0 2
3872: PPUSH
3873: CALL_OW 314
3877: NOT
3878: PUSH
3879: LD_VAR 0 2
3883: PPUSH
3884: LD_INT 9
3886: PPUSH
3887: CALL_OW 308
3891: NOT
3892: AND
3893: IFFALSE 3907
// ComMoveToArea ( j , conv_end ) ;
3895: LD_VAR 0 2
3899: PPUSH
3900: LD_INT 9
3902: PPUSH
3903: CALL_OW 113
// if IsInArea ( j , conv_end ) then
3907: LD_VAR 0 2
3911: PPUSH
3912: LD_INT 9
3914: PPUSH
3915: CALL_OW 308
3919: IFFALSE 3944
// begin safeCounter := safeCounter + 1 ;
3921: LD_ADDR_EXP 15
3925: PUSH
3926: LD_EXP 15
3930: PUSH
3931: LD_INT 1
3933: PLUS
3934: ST_TO_ADDR
// RemoveUnit ( j ) ;
3935: LD_VAR 0 2
3939: PPUSH
3940: CALL_OW 64
// end ; end ;
3944: GO 3865
3946: POP
3947: POP
// end ;
3948: PPOPN 2
3950: END
// every 0 0$01 trigger UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do var i ;
3951: LD_EXP 2
3955: PUSH
3956: LD_EXP 1
3960: PUSH
3961: EMPTY
3962: LIST
3963: LIST
3964: PPUSH
3965: LD_INT 22
3967: PUSH
3968: LD_INT 3
3970: PUSH
3971: EMPTY
3972: LIST
3973: LIST
3974: PPUSH
3975: CALL_OW 72
3979: IFFALSE 4041
3981: GO 3983
3983: DISABLE
3984: LD_INT 0
3986: PPUSH
// begin enable ;
3987: ENABLE
// for i in UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do
3988: LD_ADDR_VAR 0 1
3992: PUSH
3993: LD_EXP 2
3997: PUSH
3998: LD_EXP 1
4002: PUSH
4003: EMPTY
4004: LIST
4005: LIST
4006: PPUSH
4007: LD_INT 22
4009: PUSH
4010: LD_INT 3
4012: PUSH
4013: EMPTY
4014: LIST
4015: LIST
4016: PPUSH
4017: CALL_OW 72
4021: PUSH
4022: FOR_IN
4023: IFFALSE 4039
// SetSide ( i , 6 ) ;
4025: LD_VAR 0 1
4029: PPUSH
4030: LD_INT 6
4032: PPUSH
4033: CALL_OW 235
4037: GO 4022
4039: POP
4040: POP
// end ; end_of_file
4041: PPOPN 1
4043: END
// export Collins ; export us_alert , us_retreat , us_patrol , us_count ; export function PrepareAmerican ; var i , un , skill , towers ; begin
4044: LD_INT 0
4046: PPUSH
4047: PPUSH
4048: PPUSH
4049: PPUSH
4050: PPUSH
// uc_side := 1 ;
4051: LD_ADDR_OWVAR 20
4055: PUSH
4056: LD_INT 1
4058: ST_TO_ADDR
// uc_nation := 1 ;
4059: LD_ADDR_OWVAR 21
4063: PUSH
4064: LD_INT 1
4066: ST_TO_ADDR
// us_alert := false ;
4067: LD_ADDR_EXP 21
4071: PUSH
4072: LD_INT 0
4074: ST_TO_ADDR
// us_retreat := false ;
4075: LD_ADDR_EXP 22
4079: PUSH
4080: LD_INT 0
4082: ST_TO_ADDR
// us_patrol := false ;
4083: LD_ADDR_EXP 23
4087: PUSH
4088: LD_INT 0
4090: ST_TO_ADDR
// us_count := 0 ;
4091: LD_ADDR_EXP 24
4095: PUSH
4096: LD_INT 0
4098: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4099: LD_ADDR_VAR 0 4
4103: PUSH
4104: LD_INT 5
4106: PUSH
4107: LD_INT 6
4109: PUSH
4110: LD_INT 7
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: LIST
4117: PUSH
4118: LD_OWVAR 67
4122: ARRAY
4123: ST_TO_ADDR
// hc_class := 1 ;
4124: LD_ADDR_OWVAR 28
4128: PUSH
4129: LD_INT 1
4131: ST_TO_ADDR
// hc_sex := sex_male ;
4132: LD_ADDR_OWVAR 27
4136: PUSH
4137: LD_INT 1
4139: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
4140: LD_ADDR_OWVAR 31
4144: PUSH
4145: LD_INT 6
4147: PUSH
4148: LD_INT 3
4150: PUSH
4151: LD_INT 4
4153: PUSH
4154: LD_INT 2
4156: PUSH
4157: EMPTY
4158: LIST
4159: LIST
4160: LIST
4161: LIST
4162: ST_TO_ADDR
// hc_name := Jack Collins ;
4163: LD_ADDR_OWVAR 26
4167: PUSH
4168: LD_STRING Jack Collins
4170: ST_TO_ADDR
// hc_attr := [ 11 , 11 ] ;
4171: LD_ADDR_OWVAR 29
4175: PUSH
4176: LD_INT 11
4178: PUSH
4179: LD_INT 11
4181: PUSH
4182: EMPTY
4183: LIST
4184: LIST
4185: ST_TO_ADDR
// hc_gallery :=  ;
4186: LD_ADDR_OWVAR 33
4190: PUSH
4191: LD_STRING 
4193: ST_TO_ADDR
// Collins := CreateHuman ;
4194: LD_ADDR_EXP 20
4198: PUSH
4199: CALL_OW 44
4203: ST_TO_ADDR
// PlaceHumanInUnit ( Collins , us_depot ) ;
4204: LD_EXP 20
4208: PPUSH
4209: LD_INT 50
4211: PPUSH
4212: CALL_OW 52
// hc_name :=  ;
4216: LD_ADDR_OWVAR 26
4220: PUSH
4221: LD_STRING 
4223: ST_TO_ADDR
// if Difficulty > 1 then
4224: LD_OWVAR 67
4228: PUSH
4229: LD_INT 1
4231: GREATER
4232: IFFALSE 4286
// begin bc_type := b_bunker ;
4234: LD_ADDR_OWVAR 42
4238: PUSH
4239: LD_INT 32
4241: ST_TO_ADDR
// bc_level := 5 ;
4242: LD_ADDR_OWVAR 43
4246: PUSH
4247: LD_INT 5
4249: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 40 , 33 , 2 ) ;
4250: LD_INT 40
4252: PPUSH
4253: LD_INT 33
4255: PPUSH
4256: LD_INT 2
4258: PPUSH
4259: CALL_OW 47
// if Difficulty > 2 then
4263: LD_OWVAR 67
4267: PUSH
4268: LD_INT 2
4270: GREATER
4271: IFFALSE 4286
// CreateAndPlaceBuildingXYD ( 41 , 42 , 0 ) ;
4273: LD_INT 41
4275: PPUSH
4276: LD_INT 42
4278: PPUSH
4279: LD_INT 0
4281: PPUSH
4282: CALL_OW 47
// end ; PrepareHuman ( false , 2 , skill ) ;
4286: LD_INT 0
4288: PPUSH
4289: LD_INT 2
4291: PPUSH
4292: LD_VAR 0 4
4296: PPUSH
4297: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
4301: CALL_OW 44
4305: PPUSH
4306: LD_INT 50
4308: PPUSH
4309: CALL_OW 52
// PrepareHuman ( false , 3 , skill ) ;
4313: LD_INT 0
4315: PPUSH
4316: LD_INT 3
4318: PPUSH
4319: LD_VAR 0 4
4323: PPUSH
4324: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4328: CALL_OW 44
4332: PPUSH
4333: LD_INT 56
4335: PPUSH
4336: CALL_OW 52
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4340: CALL_OW 44
4344: PPUSH
4345: LD_INT 56
4347: PPUSH
4348: CALL_OW 52
// PrepareHuman ( false , 4 , skill ) ;
4352: LD_INT 0
4354: PPUSH
4355: LD_INT 4
4357: PPUSH
4358: LD_VAR 0 4
4362: PPUSH
4363: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
4367: CALL_OW 44
4371: PPUSH
4372: LD_INT 63
4374: PPUSH
4375: CALL_OW 52
// PrepareHuman ( false , 1 , skill ) ;
4379: LD_INT 0
4381: PPUSH
4382: LD_INT 1
4384: PPUSH
4385: LD_VAR 0 4
4389: PPUSH
4390: CALL_OW 380
// un := CreateHuman ;
4394: LD_ADDR_VAR 0 3
4398: PUSH
4399: CALL_OW 44
4403: ST_TO_ADDR
// SetDir ( un , 4 ) ;
4404: LD_VAR 0 3
4408: PPUSH
4409: LD_INT 4
4411: PPUSH
4412: CALL_OW 233
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
4416: LD_VAR 0 3
4420: PPUSH
4421: LD_INT 22
4423: PUSH
4424: LD_INT 1
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: PUSH
4431: LD_INT 30
4433: PUSH
4434: LD_INT 31
4436: PUSH
4437: EMPTY
4438: LIST
4439: LIST
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: PPUSH
4445: CALL_OW 69
4449: PUSH
4450: LD_INT 1
4452: ARRAY
4453: PPUSH
4454: CALL_OW 52
// towers := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) ;
4458: LD_ADDR_VAR 0 5
4462: PUSH
4463: LD_INT 22
4465: PUSH
4466: LD_INT 1
4468: PUSH
4469: EMPTY
4470: LIST
4471: LIST
4472: PUSH
4473: LD_INT 30
4475: PUSH
4476: LD_INT 32
4478: PUSH
4479: EMPTY
4480: LIST
4481: LIST
4482: PUSH
4483: EMPTY
4484: LIST
4485: LIST
4486: PPUSH
4487: CALL_OW 69
4491: ST_TO_ADDR
// for i in towers do
4492: LD_ADDR_VAR 0 2
4496: PUSH
4497: LD_VAR 0 5
4501: PUSH
4502: FOR_IN
4503: IFFALSE 4571
// begin PrepareHuman ( false , 1 , skill ) ;
4505: LD_INT 0
4507: PPUSH
4508: LD_INT 1
4510: PPUSH
4511: LD_VAR 0 4
4515: PPUSH
4516: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4520: CALL_OW 44
4524: PPUSH
4525: LD_VAR 0 2
4529: PPUSH
4530: CALL_OW 52
// PlaceWeaponTurret ( i , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
4534: LD_VAR 0 2
4538: PPUSH
4539: LD_INT 4
4541: PUSH
4542: LD_INT 3
4544: PUSH
4545: LD_INT 5
4547: PUSH
4548: EMPTY
4549: LIST
4550: LIST
4551: LIST
4552: PUSH
4553: LD_INT 1
4555: PPUSH
4556: LD_INT 3
4558: PPUSH
4559: CALL_OW 12
4563: ARRAY
4564: PPUSH
4565: CALL_OW 431
// end ;
4569: GO 4502
4571: POP
4572: POP
// PrepareHuman ( false , 1 , skill ) ;
4573: LD_INT 0
4575: PPUSH
4576: LD_INT 1
4578: PPUSH
4579: LD_VAR 0 4
4583: PPUSH
4584: CALL_OW 380
// us_patrol := CreateHuman ;
4588: LD_ADDR_EXP 23
4592: PUSH
4593: CALL_OW 44
4597: ST_TO_ADDR
// PlaceUnitXY ( us_patrol , 12 , 5 , false ) ;
4598: LD_EXP 23
4602: PPUSH
4603: LD_INT 12
4605: PPUSH
4606: LD_INT 5
4608: PPUSH
4609: LD_INT 0
4611: PPUSH
4612: CALL_OW 48
// end ;
4616: LD_VAR 0 1
4620: RET
// every 0 0$01 trigger us_count >= [ 3 , 4 , 5 ] [ Difficulty ] do
4621: LD_EXP 24
4625: PUSH
4626: LD_INT 3
4628: PUSH
4629: LD_INT 4
4631: PUSH
4632: LD_INT 5
4634: PUSH
4635: EMPTY
4636: LIST
4637: LIST
4638: LIST
4639: PUSH
4640: LD_OWVAR 67
4644: ARRAY
4645: GREATEREQUAL
4646: IFFALSE 4671
4648: GO 4650
4650: DISABLE
// begin Say ( Collins , DPM_C2 ) ;
4651: LD_EXP 20
4655: PPUSH
4656: LD_STRING DPM_C2
4658: PPUSH
4659: CALL_OW 88
// us_retreat := true ;
4663: LD_ADDR_EXP 22
4667: PUSH
4668: LD_INT 1
4670: ST_TO_ADDR
// end ;
4671: END
// every 10 10$00 trigger not us_alert do var R ;
4672: LD_EXP 21
4676: NOT
4677: IFFALSE 4751
4679: GO 4681
4681: DISABLE
4682: LD_INT 0
4684: PPUSH
// begin uc_side := 1 ;
4685: LD_ADDR_OWVAR 20
4689: PUSH
4690: LD_INT 1
4692: ST_TO_ADDR
// uc_nation := 1 ;
4693: LD_ADDR_OWVAR 21
4697: PUSH
4698: LD_INT 1
4700: ST_TO_ADDR
// PrepareHuman ( false , 1 , 0 ) ;
4701: LD_INT 0
4703: PPUSH
4704: LD_INT 1
4706: PPUSH
4707: LD_INT 0
4709: PPUSH
4710: CALL_OW 380
// R := CreateHuman ;
4714: LD_ADDR_VAR 0 1
4718: PUSH
4719: CALL_OW 44
4723: ST_TO_ADDR
// SayRadio ( R , DPM_R1 ) ;
4724: LD_VAR 0 1
4728: PPUSH
4729: LD_STRING DPM_R1
4731: PPUSH
4732: CALL_OW 94
// Wait ( 0 0$03 ) ;
4736: LD_INT 105
4738: PPUSH
4739: CALL_OW 67
// us_retreat := true ;
4743: LD_ADDR_EXP 22
4747: PUSH
4748: LD_INT 1
4750: ST_TO_ADDR
// end ;
4751: PPOPN 1
4753: END
// every 0 0$01 trigger us_alert do var i ;
4754: LD_EXP 21
4758: IFFALSE 5018
4760: GO 4762
4762: DISABLE
4763: LD_INT 0
4765: PPUSH
// begin Say ( Collins , DPM_C1 ) ;
4766: LD_EXP 20
4770: PPUSH
4771: LD_STRING DPM_C1
4773: PPUSH
4774: CALL_OW 88
// if UnitsInside ( us_fac ) then
4778: LD_INT 56
4780: PPUSH
4781: CALL_OW 313
4785: IFFALSE 4840
// for i in UnitsInside ( us_fac ) do
4787: LD_ADDR_VAR 0 1
4791: PUSH
4792: LD_INT 56
4794: PPUSH
4795: CALL_OW 313
4799: PUSH
4800: FOR_IN
4801: IFFALSE 4838
// begin ComExitBuilding ( i ) ;
4803: LD_VAR 0 1
4807: PPUSH
4808: CALL_OW 122
// AddComEnterUnit ( i , us_arm ) ;
4812: LD_VAR 0 1
4816: PPUSH
4817: LD_INT 69
4819: PPUSH
4820: CALL_OW 180
// AddComChangeProfession ( i , 1 ) ;
4824: LD_VAR 0 1
4828: PPUSH
4829: LD_INT 1
4831: PPUSH
4832: CALL_OW 183
// end ;
4836: GO 4800
4838: POP
4839: POP
// ComExitBuilding ( Collins ) ;
4840: LD_EXP 20
4844: PPUSH
4845: CALL_OW 122
// AddComEnterUnit ( Collins , us_arm ) ;
4849: LD_EXP 20
4853: PPUSH
4854: LD_INT 69
4856: PPUSH
4857: CALL_OW 180
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] ) ;
4861: LD_INT 22
4863: PUSH
4864: LD_INT 1
4866: PUSH
4867: EMPTY
4868: LIST
4869: LIST
4870: PUSH
4871: LD_INT 25
4873: PUSH
4874: LD_INT 2
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: EMPTY
4882: LIST
4883: LIST
4884: PPUSH
4885: CALL_OW 69
4889: PUSH
4890: LD_INT 1
4892: ARRAY
4893: PPUSH
4894: CALL_OW 122
// AddComMoveXY ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , 67 , 52 ) ;
4898: LD_INT 22
4900: PUSH
4901: LD_INT 1
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: PUSH
4908: LD_INT 25
4910: PUSH
4911: LD_INT 2
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: PUSH
4918: EMPTY
4919: LIST
4920: LIST
4921: PPUSH
4922: CALL_OW 69
4926: PUSH
4927: LD_INT 1
4929: ARRAY
4930: PPUSH
4931: LD_INT 67
4933: PPUSH
4934: LD_INT 52
4936: PPUSH
4937: CALL_OW 171
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] ) ;
4941: LD_INT 22
4943: PUSH
4944: LD_INT 1
4946: PUSH
4947: EMPTY
4948: LIST
4949: LIST
4950: PUSH
4951: LD_INT 25
4953: PUSH
4954: LD_INT 4
4956: PUSH
4957: EMPTY
4958: LIST
4959: LIST
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: PPUSH
4965: CALL_OW 69
4969: PUSH
4970: LD_INT 1
4972: ARRAY
4973: PPUSH
4974: CALL_OW 122
// AddComEnterUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] , us_arm ) ;
4978: LD_INT 22
4980: PUSH
4981: LD_INT 1
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PUSH
4988: LD_INT 25
4990: PUSH
4991: LD_INT 4
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: EMPTY
4999: LIST
5000: LIST
5001: PPUSH
5002: CALL_OW 69
5006: PUSH
5007: LD_INT 1
5009: ARRAY
5010: PPUSH
5011: LD_INT 69
5013: PPUSH
5014: CALL_OW 180
// end ;
5018: PPOPN 1
5020: END
// every 3 3$00 trigger not us_alert and GetSide ( us_fac ) = 1 do
5021: LD_EXP 21
5025: NOT
5026: PUSH
5027: LD_INT 56
5029: PPUSH
5030: CALL_OW 255
5034: PUSH
5035: LD_INT 1
5037: EQUAL
5038: AND
5039: IFFALSE 5082
5041: GO 5043
5043: DISABLE
// begin AddComConstruct ( us_fac , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun ) ;
5044: LD_INT 56
5046: PPUSH
5047: LD_INT 2
5049: PPUSH
5050: LD_INT 1
5052: PPUSH
5053: LD_INT 1
5055: PPUSH
5056: LD_INT 4
5058: PPUSH
5059: CALL_OW 185
// AddComConstruct ( us_fac , us_medium_tracked , engine_solar , control_manual , us_double_gun ) ;
5063: LD_INT 56
5065: PPUSH
5066: LD_INT 3
5068: PPUSH
5069: LD_INT 2
5071: PPUSH
5072: LD_INT 1
5074: PPUSH
5075: LD_INT 5
5077: PPUSH
5078: CALL_OW 185
// end ;
5082: END
// every 0 0$01 trigger us_patrol do
5083: LD_EXP 23
5087: IFFALSE 5135
5089: GO 5091
5091: DISABLE
// SetPatrol ( us_patrol , [ 12 , 5 , 56 , 4 , 94 , 34 , 92 , 108 ] ) ;
5092: LD_EXP 23
5096: PPUSH
5097: LD_INT 12
5099: PUSH
5100: LD_INT 5
5102: PUSH
5103: LD_INT 56
5105: PUSH
5106: LD_INT 4
5108: PUSH
5109: LD_INT 94
5111: PUSH
5112: LD_INT 34
5114: PUSH
5115: LD_INT 92
5117: PUSH
5118: LD_INT 108
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: LIST
5125: LIST
5126: LIST
5127: LIST
5128: LIST
5129: LIST
5130: PPUSH
5131: CALL 5136 0 2
5135: END
// export function SetPatrol ( un , points ) ; var s , i , turn ; begin
5136: LD_INT 0
5138: PPUSH
5139: PPUSH
5140: PPUSH
5141: PPUSH
// s = 1 ;
5142: LD_ADDR_VAR 0 4
5146: PUSH
5147: LD_INT 1
5149: ST_TO_ADDR
// turn := true ;
5150: LD_ADDR_VAR 0 6
5154: PUSH
5155: LD_INT 1
5157: ST_TO_ADDR
// while ( un and not us_alert ) do
5158: LD_VAR 0 1
5162: PUSH
5163: LD_EXP 21
5167: NOT
5168: AND
5169: IFFALSE 5348
// begin wait ( 35 ) ;
5171: LD_INT 35
5173: PPUSH
5174: CALL_OW 67
// if not HasTask ( un ) then
5178: LD_VAR 0 1
5182: PPUSH
5183: CALL_OW 314
5187: NOT
5188: IFFALSE 5307
// begin ComMoveXY ( un , points [ s ] , points [ s + 1 ] ) ;
5190: LD_VAR 0 1
5194: PPUSH
5195: LD_VAR 0 2
5199: PUSH
5200: LD_VAR 0 4
5204: ARRAY
5205: PPUSH
5206: LD_VAR 0 2
5210: PUSH
5211: LD_VAR 0 4
5215: PUSH
5216: LD_INT 1
5218: PLUS
5219: ARRAY
5220: PPUSH
5221: CALL_OW 111
// if s + 2 > points then
5225: LD_VAR 0 4
5229: PUSH
5230: LD_INT 2
5232: PLUS
5233: PUSH
5234: LD_VAR 0 2
5238: GREATER
5239: IFFALSE 5249
// turn := false ;
5241: LD_ADDR_VAR 0 6
5245: PUSH
5246: LD_INT 0
5248: ST_TO_ADDR
// if s - 2 < 1 then
5249: LD_VAR 0 4
5253: PUSH
5254: LD_INT 2
5256: MINUS
5257: PUSH
5258: LD_INT 1
5260: LESS
5261: IFFALSE 5271
// turn := true ;
5263: LD_ADDR_VAR 0 6
5267: PUSH
5268: LD_INT 1
5270: ST_TO_ADDR
// if turn then
5271: LD_VAR 0 6
5275: IFFALSE 5293
// s := s + 2 else
5277: LD_ADDR_VAR 0 4
5281: PUSH
5282: LD_VAR 0 4
5286: PUSH
5287: LD_INT 2
5289: PLUS
5290: ST_TO_ADDR
5291: GO 5307
// s := s - 2 ;
5293: LD_ADDR_VAR 0 4
5297: PUSH
5298: LD_VAR 0 4
5302: PUSH
5303: LD_INT 2
5305: MINUS
5306: ST_TO_ADDR
// end ; if GetLives ( un ) < 1000 or See ( 3 , un ) then
5307: LD_VAR 0 1
5311: PPUSH
5312: CALL_OW 256
5316: PUSH
5317: LD_INT 1000
5319: LESS
5320: PUSH
5321: LD_INT 3
5323: PPUSH
5324: LD_VAR 0 1
5328: PPUSH
5329: CALL_OW 292
5333: OR
5334: IFFALSE 5346
// begin us_alert := true ;
5336: LD_ADDR_EXP 21
5340: PUSH
5341: LD_INT 1
5343: ST_TO_ADDR
// break ;
5344: GO 5348
// end ; end ;
5346: GO 5158
// ComEnterUnit ( un , us_arm ) ;
5348: LD_VAR 0 1
5352: PPUSH
5353: LD_INT 69
5355: PPUSH
5356: CALL_OW 120
// end ;
5360: LD_VAR 0 3
5364: RET
// every 0 0$01 trigger us_retreat do var i , point ;
5365: LD_EXP 22
5369: IFFALSE 5544
5371: GO 5373
5373: DISABLE
5374: LD_INT 0
5376: PPUSH
5377: PPUSH
// begin point := false ;
5378: LD_ADDR_VAR 0 2
5382: PUSH
5383: LD_INT 0
5385: ST_TO_ADDR
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5386: LD_INT 5
5388: PPUSH
5389: LD_INT 22
5391: PUSH
5392: LD_INT 3
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: PPUSH
5399: CALL_OW 70
5403: PUSH
5404: LD_INT 0
5406: EQUAL
5407: IFFALSE 5419
// point := us_ret1 else
5409: LD_ADDR_VAR 0 2
5413: PUSH
5414: LD_INT 3
5416: ST_TO_ADDR
5417: GO 5460
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5419: LD_INT 5
5421: PPUSH
5422: LD_INT 22
5424: PUSH
5425: LD_INT 3
5427: PUSH
5428: EMPTY
5429: LIST
5430: LIST
5431: PPUSH
5432: CALL_OW 70
5436: PUSH
5437: LD_INT 0
5439: EQUAL
5440: IFFALSE 5452
// point := us_ret2 else
5442: LD_ADDR_VAR 0 2
5446: PUSH
5447: LD_INT 2
5449: ST_TO_ADDR
5450: GO 5460
// point := us_ret3 ;
5452: LD_ADDR_VAR 0 2
5456: PUSH
5457: LD_INT 4
5459: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
5460: LD_ADDR_VAR 0 1
5464: PUSH
5465: LD_INT 22
5467: PUSH
5468: LD_INT 1
5470: PUSH
5471: EMPTY
5472: LIST
5473: LIST
5474: PUSH
5475: LD_INT 21
5477: PUSH
5478: LD_INT 1
5480: PUSH
5481: EMPTY
5482: LIST
5483: LIST
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: PPUSH
5489: CALL_OW 69
5493: PUSH
5494: FOR_IN
5495: IFFALSE 5542
// begin if IsInUnit ( i ) then
5497: LD_VAR 0 1
5501: PPUSH
5502: CALL_OW 310
5506: IFFALSE 5526
// begin ComExitBuilding ( i ) ;
5508: LD_VAR 0 1
5512: PPUSH
5513: CALL_OW 122
// ComExitVehicle ( i ) ;
5517: LD_VAR 0 1
5521: PPUSH
5522: CALL_OW 121
// end ; AddComMoveToArea ( i , point ) ;
5526: LD_VAR 0 1
5530: PPUSH
5531: LD_VAR 0 2
5535: PPUSH
5536: CALL_OW 173
// end ;
5540: GO 5494
5542: POP
5543: POP
// end ;
5544: PPOPN 2
5546: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) do
5547: LD_EXP 22
5551: PUSH
5552: LD_INT 3
5554: PPUSH
5555: LD_INT 22
5557: PUSH
5558: LD_INT 1
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: PPUSH
5565: CALL_OW 70
5569: AND
5570: IFFALSE 5616
5572: GO 5574
5574: DISABLE
// begin enable ;
5575: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) [ 1 ] ) ;
5576: LD_INT 3
5578: PPUSH
5579: LD_INT 22
5581: PUSH
5582: LD_INT 1
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: PPUSH
5589: CALL_OW 70
5593: PUSH
5594: LD_INT 1
5596: ARRAY
5597: PPUSH
5598: CALL_OW 64
// if medal1 then
5602: LD_EXP 3
5606: IFFALSE 5616
// medal1 := false ;
5608: LD_ADDR_EXP 3
5612: PUSH
5613: LD_INT 0
5615: ST_TO_ADDR
// end ;
5616: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) do
5617: LD_EXP 22
5621: PUSH
5622: LD_INT 2
5624: PPUSH
5625: LD_INT 22
5627: PUSH
5628: LD_INT 1
5630: PUSH
5631: EMPTY
5632: LIST
5633: LIST
5634: PPUSH
5635: CALL_OW 70
5639: AND
5640: IFFALSE 5686
5642: GO 5644
5644: DISABLE
// begin enable ;
5645: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) [ 1 ] ) ;
5646: LD_INT 2
5648: PPUSH
5649: LD_INT 22
5651: PUSH
5652: LD_INT 1
5654: PUSH
5655: EMPTY
5656: LIST
5657: LIST
5658: PPUSH
5659: CALL_OW 70
5663: PUSH
5664: LD_INT 1
5666: ARRAY
5667: PPUSH
5668: CALL_OW 64
// if medal1 then
5672: LD_EXP 3
5676: IFFALSE 5686
// medal1 := false ;
5678: LD_ADDR_EXP 3
5682: PUSH
5683: LD_INT 0
5685: ST_TO_ADDR
// end ;
5686: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) do
5687: LD_EXP 22
5691: PUSH
5692: LD_INT 4
5694: PPUSH
5695: LD_INT 22
5697: PUSH
5698: LD_INT 1
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: PPUSH
5705: CALL_OW 70
5709: AND
5710: IFFALSE 5756
5712: GO 5714
5714: DISABLE
// begin enable ;
5715: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) [ 1 ] ) ;
5716: LD_INT 4
5718: PPUSH
5719: LD_INT 22
5721: PUSH
5722: LD_INT 1
5724: PUSH
5725: EMPTY
5726: LIST
5727: LIST
5728: PPUSH
5729: CALL_OW 70
5733: PUSH
5734: LD_INT 1
5736: ARRAY
5737: PPUSH
5738: CALL_OW 64
// if medal1 then
5742: LD_EXP 3
5746: IFFALSE 5756
// medal1 := false ;
5748: LD_ADDR_EXP 3
5752: PUSH
5753: LD_INT 0
5755: ST_TO_ADDR
// end ;
5756: END
// every 0 0$03 trigger FilterAllUnits ( [ f_side , 1 ] ) = 0 do
5757: LD_INT 22
5759: PUSH
5760: LD_INT 1
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: PPUSH
5767: CALL_OW 69
5771: PUSH
5772: LD_INT 0
5774: EQUAL
5775: IFFALSE 5788
5777: GO 5779
5779: DISABLE
// us_retreat := false ;
5780: LD_ADDR_EXP 22
5784: PUSH
5785: LD_INT 0
5787: ST_TO_ADDR
5788: END
// export function CounterAttack ; var i , j , un , skill ; begin
5789: LD_INT 0
5791: PPUSH
5792: PPUSH
5793: PPUSH
5794: PPUSH
5795: PPUSH
// uc_side := 1 ;
5796: LD_ADDR_OWVAR 20
5800: PUSH
5801: LD_INT 1
5803: ST_TO_ADDR
// uc_nation := 1 ;
5804: LD_ADDR_OWVAR 21
5808: PUSH
5809: LD_INT 1
5811: ST_TO_ADDR
// skill := [ 4 , 5 , 5 ] [ Difficulty ] ;
5812: LD_ADDR_VAR 0 5
5816: PUSH
5817: LD_INT 4
5819: PUSH
5820: LD_INT 5
5822: PUSH
5823: LD_INT 5
5825: PUSH
5826: EMPTY
5827: LIST
5828: LIST
5829: LIST
5830: PUSH
5831: LD_OWVAR 67
5835: ARRAY
5836: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
5837: LD_ADDR_VAR 0 2
5841: PUSH
5842: DOUBLE
5843: LD_INT 1
5845: DEC
5846: ST_TO_ADDR
5847: LD_INT 4
5849: PUSH
5850: LD_INT 5
5852: PUSH
5853: LD_INT 6
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: LIST
5860: PUSH
5861: LD_OWVAR 67
5865: ARRAY
5866: PUSH
5867: FOR_TO
5868: IFFALSE 6068
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 3 ) ] ;
5870: LD_ADDR_OWVAR 37
5874: PUSH
5875: LD_INT 2
5877: PUSH
5878: LD_INT 3
5880: PUSH
5881: LD_INT 4
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: PUSH
5889: LD_INT 1
5891: PPUSH
5892: LD_INT 3
5894: PPUSH
5895: CALL_OW 12
5899: ARRAY
5900: ST_TO_ADDR
// vc_engine := engine_combustion ;
5901: LD_ADDR_OWVAR 39
5905: PUSH
5906: LD_INT 1
5908: ST_TO_ADDR
// vc_control := control_manual ;
5909: LD_ADDR_OWVAR 38
5913: PUSH
5914: LD_INT 1
5916: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_light_gun ] [ Rand ( 1 , 3 ) ] ;
5917: LD_ADDR_OWVAR 40
5921: PUSH
5922: LD_INT 4
5924: PUSH
5925: LD_INT 5
5927: PUSH
5928: LD_INT 3
5930: PUSH
5931: EMPTY
5932: LIST
5933: LIST
5934: LIST
5935: PUSH
5936: LD_INT 1
5938: PPUSH
5939: LD_INT 3
5941: PPUSH
5942: CALL_OW 12
5946: ARRAY
5947: ST_TO_ADDR
// vc_fuel_battery := Rand ( 88 , 99 ) ;
5948: LD_ADDR_OWVAR 41
5952: PUSH
5953: LD_INT 88
5955: PPUSH
5956: LD_INT 99
5958: PPUSH
5959: CALL_OW 12
5963: ST_TO_ADDR
// un := CreateVehicle ;
5964: LD_ADDR_VAR 0 4
5968: PUSH
5969: CALL_OW 45
5973: ST_TO_ADDR
// PlaceUnitXY ( un , 64 , 117 , false ) ;
5974: LD_VAR 0 4
5978: PPUSH
5979: LD_INT 64
5981: PPUSH
5982: LD_INT 117
5984: PPUSH
5985: LD_INT 0
5987: PPUSH
5988: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
5992: LD_INT 0
5994: PPUSH
5995: LD_INT 3
5997: PPUSH
5998: LD_VAR 0 5
6002: PPUSH
6003: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6007: CALL_OW 44
6011: PPUSH
6012: LD_VAR 0 4
6016: PPUSH
6017: CALL_OW 52
// us_force := Insert ( us_force , 1 , un ) ;
6021: LD_ADDR_EXP 12
6025: PUSH
6026: LD_EXP 12
6030: PPUSH
6031: LD_INT 1
6033: PPUSH
6034: LD_VAR 0 4
6038: PPUSH
6039: CALL_OW 2
6043: ST_TO_ADDR
// ComMoveXY ( un , 60 , 109 ) ;
6044: LD_VAR 0 4
6048: PPUSH
6049: LD_INT 60
6051: PPUSH
6052: LD_INT 109
6054: PPUSH
6055: CALL_OW 111
// Wait ( 0 0$02 ) ;
6059: LD_INT 70
6061: PPUSH
6062: CALL_OW 67
// end ;
6066: GO 5867
6068: POP
6069: POP
// RemoveSeeing ( 62 , 113 , 3 ) ;
6070: LD_INT 62
6072: PPUSH
6073: LD_INT 113
6075: PPUSH
6076: LD_INT 3
6078: PPUSH
6079: CALL_OW 331
// while ( FilterAllUnits ( [ f_side , 1 ] ) ) do
6083: LD_INT 22
6085: PUSH
6086: LD_INT 1
6088: PUSH
6089: EMPTY
6090: LIST
6091: LIST
6092: PPUSH
6093: CALL_OW 69
6097: IFFALSE 6298
// begin Wait ( 0 0$01 ) ;
6099: LD_INT 35
6101: PPUSH
6102: CALL_OW 67
// for i = 1 to us_force do
6106: LD_ADDR_VAR 0 2
6110: PUSH
6111: DOUBLE
6112: LD_INT 1
6114: DEC
6115: ST_TO_ADDR
6116: LD_EXP 12
6120: PUSH
6121: FOR_TO
6122: IFFALSE 6157
// ComAttackUnit ( us_force [ i ] , FindTarget ( us_force [ i ] ) ) ;
6124: LD_EXP 12
6128: PUSH
6129: LD_VAR 0 2
6133: ARRAY
6134: PPUSH
6135: LD_EXP 12
6139: PUSH
6140: LD_VAR 0 2
6144: ARRAY
6145: PPUSH
6146: CALL 10616 0 1
6150: PPUSH
6151: CALL_OW 115
6155: GO 6121
6157: POP
6158: POP
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) then
6159: LD_INT 22
6161: PUSH
6162: LD_INT 1
6164: PUSH
6165: EMPTY
6166: LIST
6167: LIST
6168: PUSH
6169: LD_INT 25
6171: PUSH
6172: LD_INT 3
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: PUSH
6179: LD_INT 3
6181: PUSH
6182: LD_INT 55
6184: PUSH
6185: EMPTY
6186: LIST
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: PUSH
6192: EMPTY
6193: LIST
6194: LIST
6195: LIST
6196: PPUSH
6197: CALL_OW 69
6201: IFFALSE 6296
// for j in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) do
6203: LD_ADDR_VAR 0 3
6207: PUSH
6208: LD_INT 22
6210: PUSH
6211: LD_INT 1
6213: PUSH
6214: EMPTY
6215: LIST
6216: LIST
6217: PUSH
6218: LD_INT 25
6220: PUSH
6221: LD_INT 3
6223: PUSH
6224: EMPTY
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 3
6230: PUSH
6231: LD_INT 55
6233: PUSH
6234: EMPTY
6235: LIST
6236: PUSH
6237: EMPTY
6238: LIST
6239: LIST
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: LIST
6245: PPUSH
6246: CALL_OW 69
6250: PUSH
6251: FOR_IN
6252: IFFALSE 6294
// if not IsInArea ( j , conv_end ) then
6254: LD_VAR 0 3
6258: PPUSH
6259: LD_INT 9
6261: PPUSH
6262: CALL_OW 308
6266: NOT
6267: IFFALSE 6283
// ComMoveToArea ( j , conv_end ) else
6269: LD_VAR 0 3
6273: PPUSH
6274: LD_INT 9
6276: PPUSH
6277: CALL_OW 113
6281: GO 6292
// RemoveUnit ( j ) ;
6283: LD_VAR 0 3
6287: PPUSH
6288: CALL_OW 64
6292: GO 6251
6294: POP
6295: POP
// end ;
6296: GO 6083
// end ; end_of_file
6298: LD_VAR 0 1
6302: RET
// export function PrepareArabian ; begin
6303: LD_INT 0
6305: PPUSH
// RobertFarmer ;
6306: CALL 6327 0 0
// PrepareHovercrafts ;
6310: CALL 7234 0 0
// ar_attacks := true ;
6314: LD_ADDR_EXP 10
6318: PUSH
6319: LD_INT 1
6321: ST_TO_ADDR
// end ;
6322: LD_VAR 0 1
6326: RET
// export Farmer ; export function RobertFarmer ; begin
6327: LD_INT 0
6329: PPUSH
// uc_side := 2 ;
6330: LD_ADDR_OWVAR 20
6334: PUSH
6335: LD_INT 2
6337: ST_TO_ADDR
// uc_nation := 2 ;
6338: LD_ADDR_OWVAR 21
6342: PUSH
6343: LD_INT 2
6345: ST_TO_ADDR
// Farmer := NewCharacter ( Farmer ) ;
6346: LD_ADDR_EXP 25
6350: PUSH
6351: LD_STRING Farmer
6353: PPUSH
6354: CALL_OW 25
6358: ST_TO_ADDR
// SayRadio ( Farmer , DPM_F1 ) ;
6359: LD_EXP 25
6363: PPUSH
6364: LD_STRING DPM_F1
6366: PPUSH
6367: CALL_OW 94
// end ;
6371: LD_VAR 0 1
6375: RET
// export function PrepareAttack ( type ) ; var i , un , veh , skill ; begin
6376: LD_INT 0
6378: PPUSH
6379: PPUSH
6380: PPUSH
6381: PPUSH
6382: PPUSH
// uc_side := 2 ;
6383: LD_ADDR_OWVAR 20
6387: PUSH
6388: LD_INT 2
6390: ST_TO_ADDR
// uc_nation := 2 ;
6391: LD_ADDR_OWVAR 21
6395: PUSH
6396: LD_INT 2
6398: ST_TO_ADDR
// skill := [ 4 , 6 , 7 ] [ Difficulty ] ;
6399: LD_ADDR_VAR 0 6
6403: PUSH
6404: LD_INT 4
6406: PUSH
6407: LD_INT 6
6409: PUSH
6410: LD_INT 7
6412: PUSH
6413: EMPTY
6414: LIST
6415: LIST
6416: LIST
6417: PUSH
6418: LD_OWVAR 67
6422: ARRAY
6423: ST_TO_ADDR
// Randomize ;
6424: CALL_OW 10
// case type of 1 :
6428: LD_VAR 0 1
6432: PUSH
6433: LD_INT 1
6435: DOUBLE
6436: EQUAL
6437: IFTRUE 6441
6439: GO 6563
6441: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
6442: LD_ADDR_VAR 0 3
6446: PUSH
6447: DOUBLE
6448: LD_INT 1
6450: DEC
6451: ST_TO_ADDR
6452: LD_INT 3
6454: PUSH
6455: LD_INT 4
6457: PUSH
6458: LD_INT 5
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: LIST
6465: PUSH
6466: LD_OWVAR 67
6470: ARRAY
6471: PUSH
6472: FOR_TO
6473: IFFALSE 6559
// begin PrepareHuman ( false , [ class_soldier , class_soldier , class_mortar ] [ Rand ( 1 , 3 ) ] , skill ) ;
6475: LD_INT 0
6477: PPUSH
6478: LD_INT 1
6480: PUSH
6481: LD_INT 1
6483: PUSH
6484: LD_INT 8
6486: PUSH
6487: EMPTY
6488: LIST
6489: LIST
6490: LIST
6491: PUSH
6492: LD_INT 1
6494: PPUSH
6495: LD_INT 3
6497: PPUSH
6498: CALL_OW 12
6502: ARRAY
6503: PPUSH
6504: LD_VAR 0 6
6508: PPUSH
6509: CALL_OW 380
// un := CreateHuman ;
6513: LD_ADDR_VAR 0 4
6517: PUSH
6518: CALL_OW 44
6522: ST_TO_ADDR
// PlaceUnitArea ( un , ar3 , false ) ;
6523: LD_VAR 0 4
6527: PPUSH
6528: LD_INT 18
6530: PPUSH
6531: LD_INT 0
6533: PPUSH
6534: CALL_OW 49
// ComMoveToArea ( un , spot3 ) ;
6538: LD_VAR 0 4
6542: PPUSH
6543: LD_INT 20
6545: PPUSH
6546: CALL_OW 113
// Wait ( 0 0$01 ) ;
6550: LD_INT 35
6552: PPUSH
6553: CALL_OW 67
// end ;
6557: GO 6472
6559: POP
6560: POP
// end ; 2 :
6561: GO 7229
6563: LD_INT 2
6565: DOUBLE
6566: EQUAL
6567: IFTRUE 6571
6569: GO 6865
6571: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6572: LD_ADDR_VAR 0 3
6576: PUSH
6577: DOUBLE
6578: LD_INT 1
6580: DEC
6581: ST_TO_ADDR
6582: LD_INT 4
6584: PUSH
6585: LD_INT 5
6587: PUSH
6588: LD_INT 6
6590: PUSH
6591: EMPTY
6592: LIST
6593: LIST
6594: LIST
6595: PUSH
6596: LD_OWVAR 67
6600: ARRAY
6601: PUSH
6602: FOR_TO
6603: IFFALSE 6666
// begin PrepareHuman ( false , class_soldier , skill ) ;
6605: LD_INT 0
6607: PPUSH
6608: LD_INT 1
6610: PPUSH
6611: LD_VAR 0 6
6615: PPUSH
6616: CALL_OW 380
// un := CreateHuman ;
6620: LD_ADDR_VAR 0 4
6624: PUSH
6625: CALL_OW 44
6629: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6630: LD_VAR 0 4
6634: PPUSH
6635: LD_INT 17
6637: PPUSH
6638: LD_INT 0
6640: PPUSH
6641: CALL_OW 49
// ComMoveToArea ( un , spot2 ) ;
6645: LD_VAR 0 4
6649: PPUSH
6650: LD_INT 19
6652: PPUSH
6653: CALL_OW 113
// Wait ( 0 0$01 ) ;
6657: LD_INT 35
6659: PPUSH
6660: CALL_OW 67
// end ;
6664: GO 6602
6666: POP
6667: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
6668: LD_ADDR_VAR 0 3
6672: PUSH
6673: DOUBLE
6674: LD_INT 1
6676: DEC
6677: ST_TO_ADDR
6678: LD_INT 2
6680: PUSH
6681: LD_INT 3
6683: PUSH
6684: LD_INT 4
6686: PUSH
6687: EMPTY
6688: LIST
6689: LIST
6690: LIST
6691: PUSH
6692: LD_OWVAR 67
6696: ARRAY
6697: PUSH
6698: FOR_TO
6699: IFFALSE 6861
// begin vc_chassis := [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] ;
6701: LD_ADDR_OWVAR 37
6705: PUSH
6706: LD_INT 13
6708: PUSH
6709: LD_INT 14
6711: PUSH
6712: EMPTY
6713: LIST
6714: LIST
6715: PUSH
6716: LD_INT 1
6718: PPUSH
6719: LD_INT 2
6721: PPUSH
6722: CALL_OW 12
6726: ARRAY
6727: ST_TO_ADDR
// vc_engine := engine_combustion ;
6728: LD_ADDR_OWVAR 39
6732: PUSH
6733: LD_INT 1
6735: ST_TO_ADDR
// vc_control := control_manual ;
6736: LD_ADDR_OWVAR 38
6740: PUSH
6741: LD_INT 1
6743: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_light_gun , ar_gun , ar_rocket_launcher , ar_gatling_gun ] [ Rand ( 1 , 5 ) ] ;
6744: LD_ADDR_OWVAR 40
6748: PUSH
6749: LD_INT 24
6751: PUSH
6752: LD_INT 23
6754: PUSH
6755: LD_INT 27
6757: PUSH
6758: LD_INT 28
6760: PUSH
6761: LD_INT 25
6763: PUSH
6764: EMPTY
6765: LIST
6766: LIST
6767: LIST
6768: LIST
6769: LIST
6770: PUSH
6771: LD_INT 1
6773: PPUSH
6774: LD_INT 5
6776: PPUSH
6777: CALL_OW 12
6781: ARRAY
6782: ST_TO_ADDR
// veh := CreateVehicle ;
6783: LD_ADDR_VAR 0 5
6787: PUSH
6788: CALL_OW 45
6792: ST_TO_ADDR
// PlaceUnitArea ( veh , ar2 , false ) ;
6793: LD_VAR 0 5
6797: PPUSH
6798: LD_INT 17
6800: PPUSH
6801: LD_INT 0
6803: PPUSH
6804: CALL_OW 49
// PrepareHuman ( false , 1 , skill ) ;
6808: LD_INT 0
6810: PPUSH
6811: LD_INT 1
6813: PPUSH
6814: LD_VAR 0 6
6818: PPUSH
6819: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6823: CALL_OW 44
6827: PPUSH
6828: LD_VAR 0 5
6832: PPUSH
6833: CALL_OW 52
// ComMoveXY ( veh , 89 , 40 ) ;
6837: LD_VAR 0 5
6841: PPUSH
6842: LD_INT 89
6844: PPUSH
6845: LD_INT 40
6847: PPUSH
6848: CALL_OW 111
// Wait ( 0 0$02 ) ;
6852: LD_INT 70
6854: PPUSH
6855: CALL_OW 67
// end ;
6859: GO 6698
6861: POP
6862: POP
// end ; 3 :
6863: GO 7229
6865: LD_INT 3
6867: DOUBLE
6868: EQUAL
6869: IFTRUE 6873
6871: GO 7228
6873: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] + ( tick div 15 15$00 ) do
6874: LD_ADDR_VAR 0 3
6878: PUSH
6879: DOUBLE
6880: LD_INT 1
6882: DEC
6883: ST_TO_ADDR
6884: LD_INT 3
6886: PUSH
6887: LD_INT 4
6889: PUSH
6890: LD_INT 5
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: LIST
6897: PUSH
6898: LD_OWVAR 67
6902: ARRAY
6903: PUSH
6904: LD_OWVAR 1
6908: PUSH
6909: LD_INT 31500
6911: DIV
6912: PLUS
6913: PUSH
6914: FOR_TO
6915: IFFALSE 7023
// begin PrepareHuman ( false , [ class_soldier , class_mortar ] [ Rand ( 1 , 2 ) ] , skill ) ;
6917: LD_INT 0
6919: PPUSH
6920: LD_INT 1
6922: PUSH
6923: LD_INT 8
6925: PUSH
6926: EMPTY
6927: LIST
6928: LIST
6929: PUSH
6930: LD_INT 1
6932: PPUSH
6933: LD_INT 2
6935: PPUSH
6936: CALL_OW 12
6940: ARRAY
6941: PPUSH
6942: LD_VAR 0 6
6946: PPUSH
6947: CALL_OW 380
// un := CreateHuman ;
6951: LD_ADDR_VAR 0 4
6955: PUSH
6956: CALL_OW 44
6960: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6961: LD_VAR 0 4
6965: PPUSH
6966: LD_INT 17
6968: PPUSH
6969: LD_INT 0
6971: PPUSH
6972: CALL_OW 49
// ar_force := Insert ( ar_force , 1 , un ) ;
6976: LD_ADDR_EXP 11
6980: PUSH
6981: LD_EXP 11
6985: PPUSH
6986: LD_INT 1
6988: PPUSH
6989: LD_VAR 0 4
6993: PPUSH
6994: CALL_OW 2
6998: ST_TO_ADDR
// ComMoveXY ( un , 17 , 9 ) ;
6999: LD_VAR 0 4
7003: PPUSH
7004: LD_INT 17
7006: PPUSH
7007: LD_INT 9
7009: PPUSH
7010: CALL_OW 111
// Wait ( 0 0$01 ) ;
7014: LD_INT 35
7016: PPUSH
7017: CALL_OW 67
// end ;
7021: GO 6914
7023: POP
7024: POP
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
7025: LD_ADDR_VAR 0 3
7029: PUSH
7030: DOUBLE
7031: LD_INT 1
7033: DEC
7034: ST_TO_ADDR
7035: LD_INT 4
7037: PUSH
7038: LD_INT 5
7040: PUSH
7041: LD_INT 6
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: LIST
7048: PUSH
7049: LD_OWVAR 67
7053: ARRAY
7054: PUSH
7055: FOR_TO
7056: IFFALSE 7224
// begin vc_chassis := ar_half_tracked ;
7058: LD_ADDR_OWVAR 37
7062: PUSH
7063: LD_INT 14
7065: ST_TO_ADDR
// vc_engine := engine_combustion ;
7066: LD_ADDR_OWVAR 39
7070: PUSH
7071: LD_INT 1
7073: ST_TO_ADDR
// vc_control := control_manual ;
7074: LD_ADDR_OWVAR 38
7078: PUSH
7079: LD_INT 1
7081: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_heavy_mortar ] [ Rand ( 1 , 5 ) ] ;
7082: LD_ADDR_OWVAR 40
7086: PUSH
7087: LD_INT 25
7089: PUSH
7090: LD_INT 27
7092: PUSH
7093: LD_INT 28
7095: PUSH
7096: LD_INT 26
7098: PUSH
7099: LD_EXP 31
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: LIST
7108: LIST
7109: LIST
7110: PUSH
7111: LD_INT 1
7113: PPUSH
7114: LD_INT 5
7116: PPUSH
7117: CALL_OW 12
7121: ARRAY
7122: ST_TO_ADDR
// veh := CreateVehicle ;
7123: LD_ADDR_VAR 0 5
7127: PUSH
7128: CALL_OW 45
7132: ST_TO_ADDR
// PlaceUnitArea ( veh , ar1 , false ) ;
7133: LD_VAR 0 5
7137: PPUSH
7138: LD_INT 16
7140: PPUSH
7141: LD_INT 0
7143: PPUSH
7144: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7148: LD_INT 0
7150: PPUSH
7151: LD_INT 3
7153: PPUSH
7154: LD_VAR 0 6
7158: PPUSH
7159: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
7163: CALL_OW 44
7167: PPUSH
7168: LD_VAR 0 5
7172: PPUSH
7173: CALL_OW 52
// ar_force := Insert ( ar_force , 1 , veh ) ;
7177: LD_ADDR_EXP 11
7181: PUSH
7182: LD_EXP 11
7186: PPUSH
7187: LD_INT 1
7189: PPUSH
7190: LD_VAR 0 5
7194: PPUSH
7195: CALL_OW 2
7199: ST_TO_ADDR
// ComMoveXY ( veh , 125 , 31 ) ;
7200: LD_VAR 0 5
7204: PPUSH
7205: LD_INT 125
7207: PPUSH
7208: LD_INT 31
7210: PPUSH
7211: CALL_OW 111
// Wait ( 0 0$02 ) ;
7215: LD_INT 70
7217: PPUSH
7218: CALL_OW 67
// end ;
7222: GO 7055
7224: POP
7225: POP
// end ; end ;
7226: GO 7229
7228: POP
// end ;
7229: LD_VAR 0 2
7233: RET
// export function PrepareHovercrafts ; var i , un , areas , skill ; begin
7234: LD_INT 0
7236: PPUSH
7237: PPUSH
7238: PPUSH
7239: PPUSH
7240: PPUSH
// areas := [ river1 , river2 ] ;
7241: LD_ADDR_VAR 0 4
7245: PUSH
7246: LD_INT 14
7248: PUSH
7249: LD_INT 15
7251: PUSH
7252: EMPTY
7253: LIST
7254: LIST
7255: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7256: LD_ADDR_VAR 0 5
7260: PUSH
7261: LD_INT 5
7263: PUSH
7264: LD_INT 6
7266: PUSH
7267: LD_INT 7
7269: PUSH
7270: EMPTY
7271: LIST
7272: LIST
7273: LIST
7274: PUSH
7275: LD_OWVAR 67
7279: ARRAY
7280: ST_TO_ADDR
// uc_side := 2 ;
7281: LD_ADDR_OWVAR 20
7285: PUSH
7286: LD_INT 2
7288: ST_TO_ADDR
// uc_nation := 2 ;
7289: LD_ADDR_OWVAR 21
7293: PUSH
7294: LD_INT 2
7296: ST_TO_ADDR
// hc_name :=  ;
7297: LD_ADDR_OWVAR 26
7301: PUSH
7302: LD_STRING 
7304: ST_TO_ADDR
// hc_gallery :=  ;
7305: LD_ADDR_OWVAR 33
7309: PUSH
7310: LD_STRING 
7312: ST_TO_ADDR
// for i = 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
7313: LD_ADDR_VAR 0 2
7317: PUSH
7318: DOUBLE
7319: LD_INT 1
7321: DEC
7322: ST_TO_ADDR
7323: LD_INT 1
7325: PUSH
7326: LD_INT 2
7328: PUSH
7329: LD_INT 2
7331: PUSH
7332: EMPTY
7333: LIST
7334: LIST
7335: LIST
7336: PUSH
7337: LD_OWVAR 67
7341: ARRAY
7342: PUSH
7343: FOR_TO
7344: IFFALSE 7480
// begin vc_chassis := ar_hovercraft ;
7346: LD_ADDR_OWVAR 37
7350: PUSH
7351: LD_INT 11
7353: ST_TO_ADDR
// vc_engine := engine_solar ;
7354: LD_ADDR_OWVAR 39
7358: PUSH
7359: LD_INT 2
7361: ST_TO_ADDR
// vc_control := control_manual ;
7362: LD_ADDR_OWVAR 38
7366: PUSH
7367: LD_INT 1
7369: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
7370: LD_ADDR_OWVAR 40
7374: PUSH
7375: LD_INT 24
7377: ST_TO_ADDR
// vc_fuel_battery := 100 ;
7378: LD_ADDR_OWVAR 41
7382: PUSH
7383: LD_INT 100
7385: ST_TO_ADDR
// un := CreateVehicle ;
7386: LD_ADDR_VAR 0 3
7390: PUSH
7391: CALL_OW 45
7395: ST_TO_ADDR
// PlaceUnitXYR ( un , 121 , 69 , 4 , false ) ;
7396: LD_VAR 0 3
7400: PPUSH
7401: LD_INT 121
7403: PPUSH
7404: LD_INT 69
7406: PPUSH
7407: LD_INT 4
7409: PPUSH
7410: LD_INT 0
7412: PPUSH
7413: CALL_OW 50
// PrepareHuman ( false , 3 , skill ) ;
7417: LD_INT 0
7419: PPUSH
7420: LD_INT 3
7422: PPUSH
7423: LD_VAR 0 5
7427: PPUSH
7428: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
7432: CALL_OW 44
7436: PPUSH
7437: LD_VAR 0 3
7441: PPUSH
7442: CALL_OW 52
// riv := Insert ( riv , 1 , [ un , i ] ) ;
7446: LD_ADDR_EXP 9
7450: PUSH
7451: LD_EXP 9
7455: PPUSH
7456: LD_INT 1
7458: PPUSH
7459: LD_VAR 0 3
7463: PUSH
7464: LD_VAR 0 2
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: PPUSH
7473: CALL_OW 2
7477: ST_TO_ADDR
// end ;
7478: GO 7343
7480: POP
7481: POP
// end ;
7482: LD_VAR 0 1
7486: RET
// every 0 0$01 trigger riv do var i , c ;
7487: LD_EXP 9
7491: IFFALSE 7926
7493: GO 7495
7495: DISABLE
7496: LD_INT 0
7498: PPUSH
7499: PPUSH
// begin enable ;
7500: ENABLE
// for i = riv downto 1 do
7501: LD_ADDR_VAR 0 1
7505: PUSH
7506: DOUBLE
7507: LD_EXP 9
7511: INC
7512: ST_TO_ADDR
7513: LD_INT 1
7515: PUSH
7516: FOR_DOWNTO
7517: IFFALSE 7924
// begin if not riv [ i ] [ 1 ] then
7519: LD_EXP 9
7523: PUSH
7524: LD_VAR 0 1
7528: ARRAY
7529: PUSH
7530: LD_INT 1
7532: ARRAY
7533: NOT
7534: IFFALSE 7556
// begin riv := Delete ( riv , 1 ) ;
7536: LD_ADDR_EXP 9
7540: PUSH
7541: LD_EXP 9
7545: PPUSH
7546: LD_INT 1
7548: PPUSH
7549: CALL_OW 3
7553: ST_TO_ADDR
// break ;
7554: GO 7924
// end ; if not HasTask ( riv [ i ] [ 1 ] ) then
7556: LD_EXP 9
7560: PUSH
7561: LD_VAR 0 1
7565: ARRAY
7566: PUSH
7567: LD_INT 1
7569: ARRAY
7570: PPUSH
7571: CALL_OW 314
7575: NOT
7576: IFFALSE 7644
// begin if riv [ i ] [ 2 ] = 1 then
7578: LD_EXP 9
7582: PUSH
7583: LD_VAR 0 1
7587: ARRAY
7588: PUSH
7589: LD_INT 2
7591: ARRAY
7592: PUSH
7593: LD_INT 1
7595: EQUAL
7596: IFFALSE 7608
// c := 2 else
7598: LD_ADDR_VAR 0 2
7602: PUSH
7603: LD_INT 2
7605: ST_TO_ADDR
7606: GO 7616
// c := 1 ;
7608: LD_ADDR_VAR 0 2
7612: PUSH
7613: LD_INT 1
7615: ST_TO_ADDR
// riv := Replace2 ( riv , i , 2 , c ) ;
7616: LD_ADDR_EXP 9
7620: PUSH
7621: LD_EXP 9
7625: PPUSH
7626: LD_VAR 0 1
7630: PPUSH
7631: LD_INT 2
7633: PPUSH
7634: LD_VAR 0 2
7638: PPUSH
7639: CALL 10308 0 4
7643: ST_TO_ADDR
// end ; if not IsInArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) then
7644: LD_EXP 9
7648: PUSH
7649: LD_VAR 0 1
7653: ARRAY
7654: PUSH
7655: LD_INT 1
7657: ARRAY
7658: PPUSH
7659: LD_INT 14
7661: PUSH
7662: LD_INT 15
7664: PUSH
7665: EMPTY
7666: LIST
7667: LIST
7668: PUSH
7669: LD_EXP 9
7673: PUSH
7674: LD_VAR 0 1
7678: ARRAY
7679: PUSH
7680: LD_INT 2
7682: ARRAY
7683: ARRAY
7684: PPUSH
7685: CALL_OW 308
7689: NOT
7690: IFFALSE 7922
// begin if GetFuel ( riv [ i ] [ 1 ] ) < 50 then
7692: LD_EXP 9
7696: PUSH
7697: LD_VAR 0 1
7701: ARRAY
7702: PUSH
7703: LD_INT 1
7705: ARRAY
7706: PPUSH
7707: CALL_OW 261
7711: PUSH
7712: LD_INT 50
7714: LESS
7715: IFFALSE 7739
// SetFuel ( riv [ i ] [ 1 ] , 67 ) ;
7717: LD_EXP 9
7721: PUSH
7722: LD_VAR 0 1
7726: ARRAY
7727: PUSH
7728: LD_INT 1
7730: ARRAY
7731: PPUSH
7732: LD_INT 67
7734: PPUSH
7735: CALL_OW 240
// if GetDistUnits ( riv [ i ] [ 1 ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 3 ] ) , riv [ i ] [ 1 ] ) ) < 9 then
7739: LD_EXP 9
7743: PUSH
7744: LD_VAR 0 1
7748: ARRAY
7749: PUSH
7750: LD_INT 1
7752: ARRAY
7753: PPUSH
7754: LD_INT 22
7756: PUSH
7757: LD_INT 3
7759: PUSH
7760: EMPTY
7761: LIST
7762: LIST
7763: PPUSH
7764: CALL_OW 69
7768: PPUSH
7769: LD_EXP 9
7773: PUSH
7774: LD_VAR 0 1
7778: ARRAY
7779: PUSH
7780: LD_INT 1
7782: ARRAY
7783: PPUSH
7784: CALL_OW 74
7788: PPUSH
7789: CALL_OW 296
7793: PUSH
7794: LD_INT 9
7796: LESS
7797: IFFALSE 7855
// ComAttackUnit ( riv [ i ] [ 1 ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 3 ] ) , riv [ i ] [ 1 ] ) ) else
7799: LD_EXP 9
7803: PUSH
7804: LD_VAR 0 1
7808: ARRAY
7809: PUSH
7810: LD_INT 1
7812: ARRAY
7813: PPUSH
7814: LD_INT 22
7816: PUSH
7817: LD_INT 3
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: PPUSH
7824: CALL_OW 69
7828: PPUSH
7829: LD_EXP 9
7833: PUSH
7834: LD_VAR 0 1
7838: ARRAY
7839: PUSH
7840: LD_INT 1
7842: ARRAY
7843: PPUSH
7844: CALL_OW 74
7848: PPUSH
7849: CALL_OW 115
7853: GO 7922
// begin ComMoveToArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) ;
7855: LD_EXP 9
7859: PUSH
7860: LD_VAR 0 1
7864: ARRAY
7865: PUSH
7866: LD_INT 1
7868: ARRAY
7869: PPUSH
7870: LD_INT 14
7872: PUSH
7873: LD_INT 15
7875: PUSH
7876: EMPTY
7877: LIST
7878: LIST
7879: PUSH
7880: LD_EXP 9
7884: PUSH
7885: LD_VAR 0 1
7889: ARRAY
7890: PUSH
7891: LD_INT 2
7893: ARRAY
7894: ARRAY
7895: PPUSH
7896: CALL_OW 113
// AddComWait ( riv [ i ] [ 1 ] , 0 0$10 ) ;
7900: LD_EXP 9
7904: PUSH
7905: LD_VAR 0 1
7909: ARRAY
7910: PUSH
7911: LD_INT 1
7913: ARRAY
7914: PPUSH
7915: LD_INT 350
7917: PPUSH
7918: CALL_OW 202
// end ; end ; end ;
7922: GO 7516
7924: POP
7925: POP
// end ;
7926: PPOPN 2
7928: END
// every 10 10$00 trigger convoy_start do var i , un ;
7929: LD_EXP 7
7933: IFFALSE 8054
7935: GO 7937
7937: DISABLE
7938: LD_INT 0
7940: PPUSH
7941: PPUSH
// begin enable ;
7942: ENABLE
// for i = 1 to 2 do
7943: LD_ADDR_VAR 0 1
7947: PUSH
7948: DOUBLE
7949: LD_INT 1
7951: DEC
7952: ST_TO_ADDR
7953: LD_INT 2
7955: PUSH
7956: FOR_TO
7957: IFFALSE 8052
// begin uc_side := 2 ;
7959: LD_ADDR_OWVAR 20
7963: PUSH
7964: LD_INT 2
7966: ST_TO_ADDR
// uc_nation := 2 ;
7967: LD_ADDR_OWVAR 21
7971: PUSH
7972: LD_INT 2
7974: ST_TO_ADDR
// PrepareHuman ( false , 1 , 4 ) ;
7975: LD_INT 0
7977: PPUSH
7978: LD_INT 1
7980: PPUSH
7981: LD_INT 4
7983: PPUSH
7984: CALL_OW 380
// un := CreateHuman ;
7988: LD_ADDR_VAR 0 2
7992: PUSH
7993: CALL_OW 44
7997: ST_TO_ADDR
// PlaceUnitXY ( un , 10 , 2 , false ) ;
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 10
8005: PPUSH
8006: LD_INT 2
8008: PPUSH
8009: LD_INT 0
8011: PPUSH
8012: CALL_OW 48
// ComMoveXY ( un , 24 , 36 ) ;
8016: LD_VAR 0 2
8020: PPUSH
8021: LD_INT 24
8023: PPUSH
8024: LD_INT 36
8026: PPUSH
8027: CALL_OW 111
// AddComMoveToArea ( un , conv_end ) ;
8031: LD_VAR 0 2
8035: PPUSH
8036: LD_INT 9
8038: PPUSH
8039: CALL_OW 173
// Wait ( 0 0$02 ) ;
8043: LD_INT 70
8045: PPUSH
8046: CALL_OW 67
// end ;
8050: GO 7956
8052: POP
8053: POP
// end ;
8054: PPOPN 2
8056: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , rest ;
8057: LD_INT 22
8059: PUSH
8060: LD_INT 2
8062: PUSH
8063: EMPTY
8064: LIST
8065: LIST
8066: PPUSH
8067: CALL_OW 69
8071: IFFALSE 8383
8073: GO 8075
8075: DISABLE
8076: LD_INT 0
8078: PPUSH
8079: PPUSH
// begin enable ;
8080: ENABLE
// rest := FilterAllUnits ( [ f_side , 2 ] ) diff ar_force ;
8081: LD_ADDR_VAR 0 2
8085: PUSH
8086: LD_INT 22
8088: PUSH
8089: LD_INT 2
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: PPUSH
8096: CALL_OW 69
8100: PUSH
8101: LD_EXP 11
8105: DIFF
8106: ST_TO_ADDR
// if rest then
8107: LD_VAR 0 2
8111: IFFALSE 8183
// for i in rest do
8113: LD_ADDR_VAR 0 1
8117: PUSH
8118: LD_VAR 0 2
8122: PUSH
8123: FOR_IN
8124: IFFALSE 8181
// if GetClass ( i ) = 3 then
8126: LD_VAR 0 1
8130: PPUSH
8131: CALL_OW 257
8135: PUSH
8136: LD_INT 3
8138: EQUAL
8139: IFFALSE 8179
// begin if not IsInArea ( i , ar2 ) then
8141: LD_VAR 0 1
8145: PPUSH
8146: LD_INT 17
8148: PPUSH
8149: CALL_OW 308
8153: NOT
8154: IFFALSE 8170
// ComMoveToArea ( i , ar2 ) else
8156: LD_VAR 0 1
8160: PPUSH
8161: LD_INT 17
8163: PPUSH
8164: CALL_OW 113
8168: GO 8179
// RemoveUnit ( i ) ;
8170: LD_VAR 0 1
8174: PPUSH
8175: CALL_OW 64
// end ;
8179: GO 8123
8181: POP
8182: POP
// if ar_force then
8183: LD_EXP 11
8187: IFFALSE 8383
// begin if ar_force > 15 then
8189: LD_EXP 11
8193: PUSH
8194: LD_INT 15
8196: GREATER
8197: IFFALSE 8214
// ComAgressiveMove ( ar_force , 58 , 51 ) ;
8199: LD_EXP 11
8203: PPUSH
8204: LD_INT 58
8206: PPUSH
8207: LD_INT 51
8209: PPUSH
8210: CALL_OW 114
// for i in ar_force do
8214: LD_ADDR_VAR 0 1
8218: PUSH
8219: LD_EXP 11
8223: PUSH
8224: FOR_IN
8225: IFFALSE 8381
// begin if GetClass ( i ) = class_soldier then
8227: LD_VAR 0 1
8231: PPUSH
8232: CALL_OW 257
8236: PUSH
8237: LD_INT 1
8239: EQUAL
8240: IFFALSE 8332
// if FindTarget ( i ) in FilterAllUnits ( [ f_type , unit_building ] ) then
8242: LD_VAR 0 1
8246: PPUSH
8247: CALL 10616 0 1
8251: PUSH
8252: LD_INT 21
8254: PUSH
8255: LD_INT 3
8257: PUSH
8258: EMPTY
8259: LIST
8260: LIST
8261: PPUSH
8262: CALL_OW 69
8266: IN
8267: IFFALSE 8313
// ComPlaceDelayedCharge ( i , GetX ( FindTarget ( i ) ) , GetY ( FindTarget ( i ) ) , 0 ) else
8269: LD_VAR 0 1
8273: PPUSH
8274: LD_VAR 0 1
8278: PPUSH
8279: CALL 10616 0 1
8283: PPUSH
8284: CALL_OW 250
8288: PPUSH
8289: LD_VAR 0 1
8293: PPUSH
8294: CALL 10616 0 1
8298: PPUSH
8299: CALL_OW 251
8303: PPUSH
8304: LD_INT 0
8306: PPUSH
8307: CALL_OW 132
8311: GO 8332
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8313: LD_VAR 0 1
8317: PPUSH
8318: LD_VAR 0 1
8322: PPUSH
8323: CALL 10616 0 1
8327: PPUSH
8328: CALL_OW 115
// if not GetClass ( i ) = 1 and not HasTask ( i ) then
8332: LD_VAR 0 1
8336: PPUSH
8337: CALL_OW 257
8341: PUSH
8342: LD_INT 1
8344: EQUAL
8345: NOT
8346: PUSH
8347: LD_VAR 0 1
8351: PPUSH
8352: CALL_OW 314
8356: NOT
8357: AND
8358: IFFALSE 8379
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8360: LD_VAR 0 1
8364: PPUSH
8365: LD_VAR 0 1
8369: PPUSH
8370: CALL 10616 0 1
8374: PPUSH
8375: CALL_OW 115
// end ;
8379: GO 8224
8381: POP
8382: POP
// end ; end ;
8383: PPOPN 2
8385: END
// every 0 0$01 trigger FilterUnitsInArea ( conv_end , [ f_side , 2 ] ) do
8386: LD_INT 9
8388: PPUSH
8389: LD_INT 22
8391: PUSH
8392: LD_INT 2
8394: PUSH
8395: EMPTY
8396: LIST
8397: LIST
8398: PPUSH
8399: CALL_OW 70
8403: IFFALSE 8416
8405: GO 8407
8407: DISABLE
// medal2 := false ; end_of_file
8408: LD_ADDR_EXP 4
8412: PUSH
8413: LD_INT 0
8415: ST_TO_ADDR
8416: END
// export function Action ; begin
8417: LD_INT 0
8419: PPUSH
// case Query ( info ) of 1 :
8420: LD_STRING info
8422: PPUSH
8423: CALL_OW 97
8427: PUSH
8428: LD_INT 1
8430: DOUBLE
8431: EQUAL
8432: IFTRUE 8436
8434: GO 8439
8436: POP
// ; end ;
8437: GO 8440
8439: POP
// ChangeMissionObjectives ( PM_1 ) ;
8440: LD_STRING PM_1
8442: PPUSH
8443: CALL_OW 337
// SaveForQuickRestart ;
8447: CALL_OW 22
// end ;
8451: LD_VAR 0 1
8455: RET
// every 0 0$01 trigger GetSide ( us_depot ) = 3 do
8456: LD_INT 50
8458: PPUSH
8459: CALL_OW 255
8463: PUSH
8464: LD_INT 3
8466: EQUAL
8467: IFFALSE 8748
8469: GO 8471
8471: DISABLE
// begin Say ( Stolypin , DPM_S1 ) ;
8472: LD_EXP 16
8476: PPUSH
8477: LD_STRING DPM_S1
8479: PPUSH
8480: CALL_OW 88
// SayRadio ( Popov , DPM_P1 ) ;
8484: LD_EXP 17
8488: PPUSH
8489: LD_STRING DPM_P1
8491: PPUSH
8492: CALL_OW 94
// Say ( Stolypin , DPM_S2 ) ;
8496: LD_EXP 16
8500: PPUSH
8501: LD_STRING DPM_S2
8503: PPUSH
8504: CALL_OW 88
// SaveForQuickRestart ;
8508: CALL_OW 22
// ChangeMissionObjectives ( PM_2 ) ;
8512: LD_STRING PM_2
8514: PPUSH
8515: CALL_OW 337
// Wait ( 2 2$30 ) ;
8519: LD_INT 5250
8521: PPUSH
8522: CALL_OW 67
// CenterOnXY ( 117 , 4 ) ;
8526: LD_INT 117
8528: PPUSH
8529: LD_INT 4
8531: PPUSH
8532: CALL_OW 84
// Convoy ( 1 ) ;
8536: LD_INT 1
8538: PPUSH
8539: CALL 920 0 1
// Wait ( 0 0$30 ) ;
8543: LD_INT 1050
8545: PPUSH
8546: CALL_OW 67
// Convoy ( 2 ) ;
8550: LD_INT 2
8552: PPUSH
8553: CALL 920 0 1
// Wait ( 1 1$30 ) ;
8557: LD_INT 3150
8559: PPUSH
8560: CALL_OW 67
// Convoy ( 3 ) ;
8564: LD_INT 3
8566: PPUSH
8567: CALL 920 0 1
// Wait ( 4 4$00 ) ;
8571: LD_INT 8400
8573: PPUSH
8574: CALL_OW 67
// convoy_start := true ;
8578: LD_ADDR_EXP 7
8582: PUSH
8583: LD_INT 1
8585: ST_TO_ADDR
// PrepareArabian ;
8586: CALL 6303 0 0
// PrepareAttack ( 1 ) ;
8590: LD_INT 1
8592: PPUSH
8593: CALL 6376 0 1
// while ( convoy_start ) do
8597: LD_EXP 7
8601: IFFALSE 8748
// begin Wait ( Rand ( 2 2$00 , 3 3$30 ) ) ;
8603: LD_INT 4200
8605: PPUSH
8606: LD_INT 7350
8608: PPUSH
8609: CALL_OW 12
8613: PPUSH
8614: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) < 20 then
8618: LD_INT 22
8620: PUSH
8621: LD_INT 2
8623: PUSH
8624: EMPTY
8625: LIST
8626: LIST
8627: PPUSH
8628: CALL_OW 69
8632: PUSH
8633: LD_INT 20
8635: LESS
8636: IFFALSE 8653
// PrepareAttack ( Rand ( 1 , 2 ) ) ;
8638: LD_INT 1
8640: PPUSH
8641: LD_INT 2
8643: PPUSH
8644: CALL_OW 12
8648: PPUSH
8649: CALL 6376 0 1
// Convoy ( Rand ( 1 , 5 ) ) ;
8653: LD_INT 1
8655: PPUSH
8656: LD_INT 5
8658: PPUSH
8659: CALL_OW 12
8663: PPUSH
8664: CALL 920 0 1
// conv_counter := conv_counter + 1 ;
8668: LD_ADDR_EXP 13
8672: PUSH
8673: LD_EXP 13
8677: PUSH
8678: LD_INT 1
8680: PLUS
8681: ST_TO_ADDR
// if conv_counter mod [ 4 , 3 , 3 ] [ Difficulty ] = 0 then
8682: LD_EXP 13
8686: PUSH
8687: LD_INT 4
8689: PUSH
8690: LD_INT 3
8692: PUSH
8693: LD_INT 3
8695: PUSH
8696: EMPTY
8697: LIST
8698: LIST
8699: LIST
8700: PUSH
8701: LD_OWVAR 67
8705: ARRAY
8706: MOD
8707: PUSH
8708: LD_INT 0
8710: EQUAL
8711: IFFALSE 8746
// begin Wait ( 1 1$20 ) ;
8713: LD_INT 2800
8715: PPUSH
8716: CALL_OW 67
// SayRadio ( Farmer , DPM_F2 ) ;
8720: LD_EXP 25
8724: PPUSH
8725: LD_STRING DPM_F2
8727: PPUSH
8728: CALL_OW 94
// PrepareAttack ( 3 ) ;
8732: LD_INT 3
8734: PPUSH
8735: CALL 6376 0 1
// Wait ( 3 3$00 ) ;
8739: LD_INT 6300
8741: PPUSH
8742: CALL_OW 67
// end ; end ;
8746: GO 8597
// end ;
8748: END
// every 0 0$1 trigger safeCounter > 30 do
8749: LD_EXP 15
8753: PUSH
8754: LD_INT 30
8756: GREATER
8757: IFFALSE 8769
8759: GO 8761
8761: DISABLE
// SetAchievement ( ACH_SAFE ) ;
8762: LD_STRING ACH_SAFE
8764: PPUSH
8765: CALL_OW 543
8769: END
// every 1 1$30 trigger conv_counter mod 3 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8770: LD_EXP 13
8774: PUSH
8775: LD_INT 3
8777: MOD
8778: PUSH
8779: LD_INT 0
8781: EQUAL
8782: PUSH
8783: LD_INT 22
8785: PUSH
8786: LD_INT 2
8788: PUSH
8789: EMPTY
8790: LIST
8791: LIST
8792: PPUSH
8793: CALL_OW 69
8797: PUSH
8798: LD_INT 0
8800: EQUAL
8801: AND
8802: IFFALSE 8819
8804: GO 8806
8806: DISABLE
// SayRadio ( Farmer , DPM_F3 ) ;
8807: LD_EXP 25
8811: PPUSH
8812: LD_STRING DPM_F3
8814: PPUSH
8815: CALL_OW 94
8819: END
// every 1 1$30 trigger conv_counter mod 5 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8820: LD_EXP 13
8824: PUSH
8825: LD_INT 5
8827: MOD
8828: PUSH
8829: LD_INT 0
8831: EQUAL
8832: PUSH
8833: LD_INT 22
8835: PUSH
8836: LD_INT 2
8838: PUSH
8839: EMPTY
8840: LIST
8841: LIST
8842: PPUSH
8843: CALL_OW 69
8847: PUSH
8848: LD_INT 0
8850: EQUAL
8851: AND
8852: IFFALSE 8869
8854: GO 8856
8856: DISABLE
// SayRadio ( Farmer , DPM_F4 ) ;
8857: LD_EXP 25
8861: PPUSH
8862: LD_STRING DPM_F4
8864: PPUSH
8865: CALL_OW 94
8869: END
// every 0 0$10 trigger convoy_start and conv_counter >= [ 8 , 9 , 10 ] [ Difficulty ] and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
8870: LD_EXP 7
8874: PUSH
8875: LD_EXP 13
8879: PUSH
8880: LD_INT 8
8882: PUSH
8883: LD_INT 9
8885: PUSH
8886: LD_INT 10
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: LIST
8893: PUSH
8894: LD_OWVAR 67
8898: ARRAY
8899: GREATEREQUAL
8900: AND
8901: PUSH
8902: LD_INT 22
8904: PUSH
8905: LD_INT 6
8907: PUSH
8908: EMPTY
8909: LIST
8910: LIST
8911: PPUSH
8912: CALL_OW 69
8916: PUSH
8917: LD_INT 0
8919: EQUAL
8920: AND
8921: IFFALSE 9020
8923: GO 8925
8925: DISABLE
// begin SayRadio ( Popov , DPM_PEnd ) ;
8926: LD_EXP 17
8930: PPUSH
8931: LD_STRING DPM_PEnd
8933: PPUSH
8934: CALL_OW 94
// AddMedal ( med1 , medal1 ) ;
8938: LD_STRING med1
8940: PPUSH
8941: LD_EXP 3
8945: PPUSH
8946: CALL_OW 101
// AddMedal ( med2 , medal2 ) ;
8950: LD_STRING med2
8952: PPUSH
8953: LD_EXP 4
8957: PPUSH
8958: CALL_OW 101
// if dest_counter >= [ 15 , 10 , 7 ] [ Difficulty ] then
8962: LD_EXP 8
8966: PUSH
8967: LD_INT 15
8969: PUSH
8970: LD_INT 10
8972: PUSH
8973: LD_INT 7
8975: PUSH
8976: EMPTY
8977: LIST
8978: LIST
8979: LIST
8980: PUSH
8981: LD_OWVAR 67
8985: ARRAY
8986: GREATEREQUAL
8987: IFFALSE 8997
// medal3 := false ;
8989: LD_ADDR_EXP 5
8993: PUSH
8994: LD_INT 0
8996: ST_TO_ADDR
// AddMedal ( med3 , medal3 ) ;
8997: LD_STRING med3
8999: PPUSH
9000: LD_EXP 5
9004: PPUSH
9005: CALL_OW 101
// GiveMedals ( MAIN ) ;
9009: LD_STRING MAIN
9011: PPUSH
9012: CALL_OW 102
// YouWin ;
9016: CALL_OW 103
// end ;
9020: END
// every 4 4$10 trigger convoy_start do var i ;
9021: LD_EXP 7
9025: IFFALSE 9391
9027: GO 9029
9029: DISABLE
9030: LD_INT 0
9032: PPUSH
// begin DialogueOn ;
9033: CALL_OW 6
// SayRadio ( Popov , DPM_PHelp ) ;
9037: LD_EXP 17
9041: PPUSH
9042: LD_STRING DPM_PHelp
9044: PPUSH
9045: CALL_OW 94
// DialogueOff ;
9049: CALL_OW 7
// Wait ( 0 0$30 ) ;
9053: LD_INT 1050
9055: PPUSH
9056: CALL_OW 67
// Randomize ;
9060: CALL_OW 10
// uc_side := 3 ;
9064: LD_ADDR_OWVAR 20
9068: PUSH
9069: LD_INT 3
9071: ST_TO_ADDR
// uc_nation := 3 ;
9072: LD_ADDR_OWVAR 21
9076: PUSH
9077: LD_INT 3
9079: ST_TO_ADDR
// for i = 1 to [ 5 , 4 , 3 ] [ Difficulty ] do
9080: LD_ADDR_VAR 0 1
9084: PUSH
9085: DOUBLE
9086: LD_INT 1
9088: DEC
9089: ST_TO_ADDR
9090: LD_INT 5
9092: PUSH
9093: LD_INT 4
9095: PUSH
9096: LD_INT 3
9098: PUSH
9099: EMPTY
9100: LIST
9101: LIST
9102: LIST
9103: PUSH
9104: LD_OWVAR 67
9108: ARRAY
9109: PUSH
9110: FOR_TO
9111: IFFALSE 9151
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , 5 ) ;
9113: LD_INT 0
9115: PPUSH
9116: LD_INT 1
9118: PPUSH
9119: LD_INT 3
9121: PPUSH
9122: CALL_OW 12
9126: PPUSH
9127: LD_INT 5
9129: PPUSH
9130: CALL_OW 380
// PlaceUnitArea ( CreateHuman , rus_start , false ) ;
9134: CALL_OW 44
9138: PPUSH
9139: LD_INT 1
9141: PPUSH
9142: LD_INT 0
9144: PPUSH
9145: CALL_OW 49
// end ;
9149: GO 9110
9151: POP
9152: POP
// vc_chassis := ru_heavy_wheeled ;
9153: LD_ADDR_OWVAR 37
9157: PUSH
9158: LD_INT 23
9160: ST_TO_ADDR
// vc_engine := engine_combustion ;
9161: LD_ADDR_OWVAR 39
9165: PUSH
9166: LD_INT 1
9168: ST_TO_ADDR
// vc_control := control_manual ;
9169: LD_ADDR_OWVAR 38
9173: PUSH
9174: LD_INT 1
9176: ST_TO_ADDR
// vc_weapon := 89 ;
9177: LD_ADDR_OWVAR 40
9181: PUSH
9182: LD_INT 89
9184: ST_TO_ADDR
// vc_fuel_battery := 88 ;
9185: LD_ADDR_OWVAR 41
9189: PUSH
9190: LD_INT 88
9192: ST_TO_ADDR
// i := CreateVehicle ;
9193: LD_ADDR_VAR 0 1
9197: PUSH
9198: CALL_OW 45
9202: ST_TO_ADDR
// SetDir ( i , 5 ) ;
9203: LD_VAR 0 1
9207: PPUSH
9208: LD_INT 5
9210: PPUSH
9211: CALL_OW 233
// PlaceUnitXY ( i , 63 , 115 , false ) ;
9215: LD_VAR 0 1
9219: PPUSH
9220: LD_INT 63
9222: PPUSH
9223: LD_INT 115
9225: PPUSH
9226: LD_INT 0
9228: PPUSH
9229: CALL_OW 48
// SetCargo ( i , mat_cans , 200 ) ;
9233: LD_VAR 0 1
9237: PPUSH
9238: LD_INT 1
9240: PPUSH
9241: LD_INT 200
9243: PPUSH
9244: CALL_OW 290
// PrepareHuman ( false , 3 , 5 ) ;
9248: LD_INT 0
9250: PPUSH
9251: LD_INT 3
9253: PPUSH
9254: LD_INT 5
9256: PPUSH
9257: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9261: CALL_OW 44
9265: PPUSH
9266: LD_VAR 0 1
9270: PPUSH
9271: CALL_OW 52
// DialogueOn ;
9275: CALL_OW 6
// CenterNowOnXY ( 169 , 115 ) ;
9279: LD_INT 169
9281: PPUSH
9282: LD_INT 115
9284: PPUSH
9285: CALL_OW 86
// DWait ( 0 0$01 ) ;
9289: LD_INT 35
9291: PPUSH
9292: CALL_OW 68
// CenterNowOnXY ( 63 , 115 ) ;
9296: LD_INT 63
9298: PPUSH
9299: LD_INT 115
9301: PPUSH
9302: CALL_OW 86
// DWait ( 0 0$01 ) ;
9306: LD_INT 35
9308: PPUSH
9309: CALL_OW 68
// DialogueOff ;
9313: CALL_OW 7
// ComMoveXY ( i , 57 , 53 ) ;
9317: LD_VAR 0 1
9321: PPUSH
9322: LD_INT 57
9324: PPUSH
9325: LD_INT 53
9327: PPUSH
9328: CALL_OW 111
// Wait ( Rand ( 3 3$00 , 7 7$00 ) ) ;
9332: LD_INT 6300
9334: PPUSH
9335: LD_INT 14700
9337: PPUSH
9338: CALL_OW 12
9342: PPUSH
9343: CALL_OW 67
// PlaceUnitXY ( Saseda , 86 , 112 , false ) ;
9347: LD_EXP 18
9351: PPUSH
9352: LD_INT 86
9354: PPUSH
9355: LD_INT 112
9357: PPUSH
9358: LD_INT 0
9360: PPUSH
9361: CALL_OW 48
// Wait ( 0 0$0.3 ) ;
9365: LD_INT 10
9367: PPUSH
9368: CALL_OW 67
// SayRadio ( Saseda , DPM_Sa1 ) ;
9372: LD_EXP 18
9376: PPUSH
9377: LD_STRING DPM_Sa1
9379: PPUSH
9380: CALL_OW 94
// ChangeMissionObjectives ( PM_3 ) ;
9384: LD_STRING PM_3
9386: PPUSH
9387: CALL_OW 337
// end ;
9391: PPOPN 1
9393: END
// every 0 0$01 trigger See ( 3 , Saseda ) do
9394: LD_INT 3
9396: PPUSH
9397: LD_EXP 18
9401: PPUSH
9402: CALL_OW 292
9406: IFFALSE 9455
9408: GO 9410
9410: DISABLE
// begin Say ( Saseda , DPM_Sa2 ) ;
9411: LD_EXP 18
9415: PPUSH
9416: LD_STRING DPM_Sa2
9418: PPUSH
9419: CALL_OW 88
// ChangeMissionObjectives ( PM_4 ) ;
9423: LD_STRING PM_4
9425: PPUSH
9426: CALL_OW 337
// SetTech ( tech_rocket , 3 , state_enabled ) ;
9430: LD_INT 40
9432: PPUSH
9433: LD_INT 3
9435: PPUSH
9436: LD_INT 1
9438: PPUSH
9439: CALL_OW 322
// SetSide ( Saseda , 3 ) ;
9443: LD_EXP 18
9447: PPUSH
9448: LD_INT 3
9450: PPUSH
9451: CALL_OW 235
// end ;
9455: END
// every 16 16$00 trigger not medal1 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
9456: LD_EXP 3
9460: NOT
9461: PUSH
9462: LD_INT 22
9464: PUSH
9465: LD_INT 6
9467: PUSH
9468: EMPTY
9469: LIST
9470: LIST
9471: PPUSH
9472: CALL_OW 69
9476: PUSH
9477: LD_INT 0
9479: EQUAL
9480: AND
9481: IFFALSE 9543
9483: GO 9485
9485: DISABLE
// begin DialogueOn ;
9486: CALL_OW 6
// Say ( Stolypin , DPM_S3 ) ;
9490: LD_EXP 16
9494: PPUSH
9495: LD_STRING DPM_S3
9497: PPUSH
9498: CALL_OW 88
// PlaceSeeing ( 62 , 113 , 3 , 10 ) ;
9502: LD_INT 62
9504: PPUSH
9505: LD_INT 113
9507: PPUSH
9508: LD_INT 3
9510: PPUSH
9511: LD_INT 10
9513: PPUSH
9514: CALL_OW 330
// CenterOnXY ( 62 , 113 ) ;
9518: LD_INT 62
9520: PPUSH
9521: LD_INT 113
9523: PPUSH
9524: CALL_OW 84
// dwait ( 0 0$1 ) ;
9528: LD_INT 35
9530: PPUSH
9531: CALL_OW 68
// DialogueOff ;
9535: CALL_OW 7
// CounterAttack ;
9539: CALL 5789 0 0
// end ; end_of_file
9543: END
// on LeaveBuilding ( b , h ) do begin if GetSide ( b ) = 1 then
9544: LD_VAR 0 1
9548: PPUSH
9549: CALL_OW 255
9553: PUSH
9554: LD_INT 1
9556: EQUAL
9557: IFFALSE 9593
// if not us_retreat then
9559: LD_EXP 22
9563: NOT
9564: IFFALSE 9593
// if GetClass ( h ) = 1 then
9566: LD_VAR 0 2
9570: PPUSH
9571: CALL_OW 257
9575: PUSH
9576: LD_INT 1
9578: EQUAL
9579: IFFALSE 9593
// ComEnterUnit ( h , us_arm ) ;
9581: LD_VAR 0 2
9585: PPUSH
9586: LD_INT 69
9588: PPUSH
9589: CALL_OW 120
// end ;
9593: PPOPN 2
9595: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
9596: LD_VAR 0 1
9600: PPUSH
9601: CALL 22304 0 1
// if GetSide ( un ) = 1 then
9605: LD_VAR 0 1
9609: PPUSH
9610: CALL_OW 255
9614: PUSH
9615: LD_INT 1
9617: EQUAL
9618: IFFALSE 9634
// us_count := us_count + 1 ;
9620: LD_ADDR_EXP 24
9624: PUSH
9625: LD_EXP 24
9629: PUSH
9630: LD_INT 1
9632: PLUS
9633: ST_TO_ADDR
// if un in us_force then
9634: LD_VAR 0 1
9638: PUSH
9639: LD_EXP 12
9643: IN
9644: IFFALSE 9662
// us_force := us_force diff un ;
9646: LD_ADDR_EXP 12
9650: PUSH
9651: LD_EXP 12
9655: PUSH
9656: LD_VAR 0 1
9660: DIFF
9661: ST_TO_ADDR
// if un in ar_force then
9662: LD_VAR 0 1
9666: PUSH
9667: LD_EXP 11
9671: IN
9672: IFFALSE 9690
// ar_force := ar_force diff un ;
9674: LD_ADDR_EXP 11
9678: PUSH
9679: LD_EXP 11
9683: PUSH
9684: LD_VAR 0 1
9688: DIFF
9689: ST_TO_ADDR
// if un = Stolypin then
9690: LD_VAR 0 1
9694: PUSH
9695: LD_EXP 16
9699: EQUAL
9700: IFFALSE 9709
// YouLost ( dead ) ;
9702: LD_STRING dead
9704: PPUSH
9705: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) then
9709: LD_VAR 0 1
9713: PUSH
9714: LD_INT 22
9716: PUSH
9717: LD_INT 1
9719: PUSH
9720: EMPTY
9721: LIST
9722: LIST
9723: PUSH
9724: LD_INT 30
9726: PUSH
9727: LD_INT 0
9729: PUSH
9730: EMPTY
9731: LIST
9732: LIST
9733: PUSH
9734: EMPTY
9735: LIST
9736: LIST
9737: PPUSH
9738: CALL_OW 69
9742: IN
9743: IFFALSE 9752
// YouLost ( depot ) ;
9745: LD_STRING depot
9747: PPUSH
9748: CALL_OW 104
// if GetSide ( un ) = 6 then
9752: LD_VAR 0 1
9756: PPUSH
9757: CALL_OW 255
9761: PUSH
9762: LD_INT 6
9764: EQUAL
9765: IFFALSE 9781
// dest_counter := dest_counter + 1 ;
9767: LD_ADDR_EXP 8
9771: PUSH
9772: LD_EXP 8
9776: PUSH
9777: LD_INT 1
9779: PLUS
9780: ST_TO_ADDR
// end ;
9781: PPOPN 1
9783: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 1 then
9784: LD_VAR 0 1
9788: PPUSH
9789: CALL_OW 255
9793: PUSH
9794: LD_INT 1
9796: EQUAL
9797: IFFALSE 9814
// ComMoveXY ( un , 57 , 52 ) ;
9799: LD_VAR 0 1
9803: PPUSH
9804: LD_INT 57
9806: PPUSH
9807: LD_INT 52
9809: PPUSH
9810: CALL_OW 111
// end ;
9814: PPOPN 2
9816: END
// on Contact ( s1 , s2 ) do begin if not us_alert then
9817: LD_EXP 21
9821: NOT
9822: IFFALSE 9872
// if ( s1 = 3 and s2 = 1 ) or ( s1 = 1 and s2 = 3 ) then
9824: LD_VAR 0 1
9828: PUSH
9829: LD_INT 3
9831: EQUAL
9832: PUSH
9833: LD_VAR 0 2
9837: PUSH
9838: LD_INT 1
9840: EQUAL
9841: AND
9842: PUSH
9843: LD_VAR 0 1
9847: PUSH
9848: LD_INT 1
9850: EQUAL
9851: PUSH
9852: LD_VAR 0 2
9856: PUSH
9857: LD_INT 3
9859: EQUAL
9860: AND
9861: OR
9862: IFFALSE 9872
// us_alert := true ;
9864: LD_ADDR_EXP 21
9868: PUSH
9869: LD_INT 1
9871: ST_TO_ADDR
// if ( s1 = 6 and s2 = 3 ) or ( s1 = 3 and s2 = 6 ) then
9872: LD_VAR 0 1
9876: PUSH
9877: LD_INT 6
9879: EQUAL
9880: PUSH
9881: LD_VAR 0 2
9885: PUSH
9886: LD_INT 3
9888: EQUAL
9889: AND
9890: PUSH
9891: LD_VAR 0 1
9895: PUSH
9896: LD_INT 3
9898: EQUAL
9899: PUSH
9900: LD_VAR 0 2
9904: PUSH
9905: LD_INT 6
9907: EQUAL
9908: AND
9909: OR
9910: IFFALSE 9919
// YouLost ( alat ) ;
9912: LD_STRING alat
9914: PPUSH
9915: CALL_OW 104
// end ;
9919: PPOPN 2
9921: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = 2 and un in FilterAllUnits ( [ [ f_empty ] , [ f_type , unit_vehicle ] ] ) then
9922: LD_VAR 0 1
9926: PPUSH
9927: CALL_OW 255
9931: PUSH
9932: LD_INT 2
9934: EQUAL
9935: PUSH
9936: LD_VAR 0 1
9940: PUSH
9941: LD_INT 58
9943: PUSH
9944: EMPTY
9945: LIST
9946: PUSH
9947: LD_INT 21
9949: PUSH
9950: LD_INT 2
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: PUSH
9957: EMPTY
9958: LIST
9959: LIST
9960: PPUSH
9961: CALL_OW 69
9965: IN
9966: AND
9967: IFFALSE 10088
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> 2 then
9969: LD_OWVAR 3
9973: PUSH
9974: LD_VAR 0 1
9978: DIFF
9979: PPUSH
9980: LD_VAR 0 1
9984: PPUSH
9985: CALL_OW 74
9989: PPUSH
9990: CALL_OW 255
9994: PUSH
9995: LD_INT 2
9997: NONEQUAL
9998: IFFALSE 10088
// begin Wait ( 0 0$1.3 ) ;
10000: LD_INT 46
10002: PPUSH
10003: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
10007: LD_VAR 0 1
10011: PPUSH
10012: CALL_OW 250
10016: PPUSH
10017: LD_VAR 0 1
10021: PPUSH
10022: CALL_OW 251
10026: PPUSH
10027: LD_INT 1
10029: PPUSH
10030: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
10034: LD_VAR 0 1
10038: PPUSH
10039: CALL_OW 250
10043: PPUSH
10044: LD_VAR 0 1
10048: PPUSH
10049: CALL_OW 251
10053: PPUSH
10054: LD_INT 1
10056: PPUSH
10057: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
10061: LD_VAR 0 1
10065: PPUSH
10066: CALL_OW 250
10070: PPUSH
10071: LD_VAR 0 1
10075: PPUSH
10076: CALL_OW 251
10080: PPUSH
10081: LD_INT 1
10083: PPUSH
10084: CALL_OW 453
// end ; end ;
10088: PPOPN 1
10090: END
// on EvacuateVehicle ( driver , un , c1 , c2 ) do begin if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) and not GetSide ( NearestUnit ( un ) ) = 2 then
10091: LD_VAR 0 2
10095: PUSH
10096: LD_INT 22
10098: PUSH
10099: LD_INT 2
10101: PUSH
10102: EMPTY
10103: LIST
10104: LIST
10105: PUSH
10106: LD_INT 21
10108: PUSH
10109: LD_INT 2
10111: PUSH
10112: EMPTY
10113: LIST
10114: LIST
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PPUSH
10120: CALL_OW 69
10124: IN
10125: PUSH
10126: LD_VAR 0 2
10130: PPUSH
10131: CALL 10661 0 1
10135: PPUSH
10136: CALL_OW 255
10140: PUSH
10141: LD_INT 2
10143: EQUAL
10144: NOT
10145: AND
10146: IFFALSE 10271
// begin Wait ( Rand ( 0 0$03 , 0 0$06 ) ) ;
10148: LD_INT 105
10150: PPUSH
10151: LD_INT 210
10153: PPUSH
10154: CALL_OW 12
10158: PPUSH
10159: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10163: LD_VAR 0 2
10167: PPUSH
10168: CALL_OW 250
10172: PPUSH
10173: LD_VAR 0 2
10177: PPUSH
10178: CALL_OW 251
10182: PPUSH
10183: LD_INT 3
10185: PPUSH
10186: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10190: LD_VAR 0 2
10194: PPUSH
10195: CALL_OW 250
10199: PPUSH
10200: LD_VAR 0 2
10204: PPUSH
10205: CALL_OW 251
10209: PPUSH
10210: LD_INT 3
10212: PPUSH
10213: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10217: LD_VAR 0 2
10221: PPUSH
10222: CALL_OW 250
10226: PPUSH
10227: LD_VAR 0 2
10231: PPUSH
10232: CALL_OW 251
10236: PPUSH
10237: LD_INT 3
10239: PPUSH
10240: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10244: LD_VAR 0 2
10248: PPUSH
10249: CALL_OW 250
10253: PPUSH
10254: LD_VAR 0 2
10258: PPUSH
10259: CALL_OW 251
10263: PPUSH
10264: LD_INT 3
10266: PPUSH
10267: CALL_OW 453
// end ; end ;
10271: PPOPN 4
10273: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
10274: LD_VAR 0 1
10278: PPUSH
10279: LD_VAR 0 2
10283: PPUSH
10284: LD_VAR 0 3
10288: PPUSH
10289: CALL 22402 0 3
// end ;
10293: PPOPN 3
10295: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10296: LD_VAR 0 1
10300: PPUSH
10301: CALL 22410 0 1
// end ; end_of_file
10305: PPOPN 1
10307: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
10308: LD_INT 0
10310: PPUSH
10311: PPUSH
10312: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
10313: LD_ADDR_VAR 0 7
10317: PUSH
10318: LD_VAR 0 1
10322: PUSH
10323: LD_VAR 0 2
10327: ARRAY
10328: PPUSH
10329: LD_VAR 0 3
10333: PPUSH
10334: LD_VAR 0 4
10338: PPUSH
10339: CALL_OW 1
10343: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
10344: LD_ADDR_VAR 0 1
10348: PUSH
10349: LD_VAR 0 1
10353: PPUSH
10354: LD_VAR 0 2
10358: PPUSH
10359: LD_VAR 0 7
10363: PPUSH
10364: CALL_OW 1
10368: ST_TO_ADDR
// result := tab ;
10369: LD_ADDR_VAR 0 5
10373: PUSH
10374: LD_VAR 0 1
10378: ST_TO_ADDR
// end ;
10379: LD_VAR 0 5
10383: RET
// export function IsDriver ( unit ) ; begin
10384: LD_INT 0
10386: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
10387: LD_VAR 0 1
10391: PUSH
10392: LD_INT 55
10394: PUSH
10395: EMPTY
10396: LIST
10397: PPUSH
10398: CALL_OW 69
10402: IN
10403: IFFALSE 10422
// result := IsInUnit ( unit ) else
10405: LD_ADDR_VAR 0 2
10409: PUSH
10410: LD_VAR 0 1
10414: PPUSH
10415: CALL_OW 310
10419: ST_TO_ADDR
10420: GO 10430
// result := false ;
10422: LD_ADDR_VAR 0 2
10426: PUSH
10427: LD_INT 0
10429: ST_TO_ADDR
// end ;
10430: LD_VAR 0 2
10434: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
10435: LD_INT 0
10437: PPUSH
10438: PPUSH
10439: PPUSH
// if not GetControl ( veh ) = control_manual then
10440: LD_VAR 0 1
10444: PPUSH
10445: CALL_OW 263
10449: PUSH
10450: LD_INT 1
10452: EQUAL
10453: NOT
10454: IFFALSE 10466
// result := false else
10456: LD_ADDR_VAR 0 2
10460: PUSH
10461: LD_INT 0
10463: ST_TO_ADDR
10464: GO 10611
// if veh in FilterAllUnits ( [ f_empty ] ) then
10466: LD_VAR 0 1
10470: PUSH
10471: LD_INT 58
10473: PUSH
10474: EMPTY
10475: LIST
10476: PPUSH
10477: CALL_OW 69
10481: IN
10482: IFFALSE 10494
// result := false else
10484: LD_ADDR_VAR 0 2
10488: PUSH
10489: LD_INT 0
10491: ST_TO_ADDR
10492: GO 10611
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
10494: LD_ADDR_VAR 0 4
10498: PUSH
10499: LD_INT 22
10501: PUSH
10502: LD_VAR 0 1
10506: PPUSH
10507: CALL_OW 255
10511: PUSH
10512: EMPTY
10513: LIST
10514: LIST
10515: PUSH
10516: LD_INT 55
10518: PUSH
10519: EMPTY
10520: LIST
10521: PUSH
10522: EMPTY
10523: LIST
10524: LIST
10525: PPUSH
10526: CALL_OW 69
10530: ST_TO_ADDR
// if not filter then
10531: LD_VAR 0 4
10535: NOT
10536: IFFALSE 10548
// result := false else
10538: LD_ADDR_VAR 0 2
10542: PUSH
10543: LD_INT 0
10545: ST_TO_ADDR
10546: GO 10611
// for i = 1 to filter do
10548: LD_ADDR_VAR 0 3
10552: PUSH
10553: DOUBLE
10554: LD_INT 1
10556: DEC
10557: ST_TO_ADDR
10558: LD_VAR 0 4
10562: PUSH
10563: FOR_TO
10564: IFFALSE 10609
// if IsDriver ( filter [ i ] ) = veh then
10566: LD_VAR 0 4
10570: PUSH
10571: LD_VAR 0 3
10575: ARRAY
10576: PPUSH
10577: CALL 10384 0 1
10581: PUSH
10582: LD_VAR 0 1
10586: EQUAL
10587: IFFALSE 10607
// begin result := filter [ i ] ;
10589: LD_ADDR_VAR 0 2
10593: PUSH
10594: LD_VAR 0 4
10598: PUSH
10599: LD_VAR 0 3
10603: ARRAY
10604: ST_TO_ADDR
// break ;
10605: GO 10609
// end ;
10607: GO 10563
10609: POP
10610: POP
// end ; end ;
10611: LD_VAR 0 2
10615: RET
// export function FindTarget ( unit ) ; begin
10616: LD_INT 0
10618: PPUSH
// result := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ;
10619: LD_ADDR_VAR 0 2
10623: PUSH
10624: LD_INT 81
10626: PUSH
10627: LD_VAR 0 1
10631: PPUSH
10632: CALL_OW 255
10636: PUSH
10637: EMPTY
10638: LIST
10639: LIST
10640: PPUSH
10641: CALL_OW 69
10645: PPUSH
10646: LD_VAR 0 1
10650: PPUSH
10651: CALL_OW 74
10655: ST_TO_ADDR
// end ;
10656: LD_VAR 0 2
10660: RET
// export function NearestUnit ( unit ) ; begin
10661: LD_INT 0
10663: PPUSH
// result := NearestUnitToUnit ( all_units diff unit , unit ) ;
10664: LD_ADDR_VAR 0 2
10668: PUSH
10669: LD_OWVAR 3
10673: PUSH
10674: LD_VAR 0 1
10678: DIFF
10679: PPUSH
10680: LD_VAR 0 1
10684: PPUSH
10685: CALL_OW 74
10689: ST_TO_ADDR
// end ; end_of_file
10690: LD_VAR 0 2
10694: RET
// every 12 12$00 do
10695: GO 10697
10697: DISABLE
// begin SetWeather ( 1 , 570 , 350 ) ;
10698: LD_INT 1
10700: PPUSH
10701: LD_INT 570
10703: PPUSH
10704: LD_INT 350
10706: PPUSH
10707: CALL_OW 550
// Wait ( Rand ( 5 5$00 , 10 10$00 ) ) ;
10711: LD_INT 10500
10713: PPUSH
10714: LD_INT 21000
10716: PPUSH
10717: CALL_OW 12
10721: PPUSH
10722: CALL_OW 67
// SetWeather ( 0 , 570 , 350 ) ;
10726: LD_INT 0
10728: PPUSH
10729: LD_INT 570
10731: PPUSH
10732: LD_INT 350
10734: PPUSH
10735: CALL_OW 550
// end ;
10739: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
10740: LD_INT 0
10742: PPUSH
10743: PPUSH
10744: PPUSH
10745: PPUSH
10746: PPUSH
// uc_nation = nation_nature ;
10747: LD_ADDR_OWVAR 21
10751: PUSH
10752: LD_INT 0
10754: ST_TO_ADDR
// uc_side = 0 ;
10755: LD_ADDR_OWVAR 20
10759: PUSH
10760: LD_INT 0
10762: ST_TO_ADDR
// l = 0 ;
10763: LD_ADDR_VAR 0 6
10767: PUSH
10768: LD_INT 0
10770: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
10771: LD_ADDR_OWVAR 24
10775: PUSH
10776: LD_INT 0
10778: PPUSH
10779: LD_INT 5
10781: PPUSH
10782: CALL_OW 12
10786: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
10787: LD_ADDR_OWVAR 35
10791: PUSH
10792: LD_INT 5
10794: NEG
10795: PPUSH
10796: LD_INT 5
10798: PPUSH
10799: CALL_OW 12
10803: ST_TO_ADDR
// hc_gallery =  ;
10804: LD_ADDR_OWVAR 33
10808: PUSH
10809: LD_STRING 
10811: ST_TO_ADDR
// hc_class = class_apeman ;
10812: LD_ADDR_OWVAR 28
10816: PUSH
10817: LD_INT 12
10819: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
10820: LD_ADDR_OWVAR 29
10824: PUSH
10825: LD_INT 11
10827: PPUSH
10828: LD_INT 13
10830: PPUSH
10831: CALL_OW 12
10835: PUSH
10836: LD_INT 10
10838: PPUSH
10839: LD_INT 11
10841: PPUSH
10842: CALL_OW 12
10846: PUSH
10847: EMPTY
10848: LIST
10849: LIST
10850: ST_TO_ADDR
// hc_sex = sex_male ;
10851: LD_ADDR_OWVAR 27
10855: PUSH
10856: LD_INT 1
10858: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
10859: LD_ADDR_OWVAR 31
10863: PUSH
10864: LD_INT 0
10866: PPUSH
10867: LD_INT 2
10869: PPUSH
10870: CALL_OW 12
10874: PUSH
10875: LD_INT 0
10877: PUSH
10878: LD_INT 0
10880: PUSH
10881: LD_INT 0
10883: PUSH
10884: EMPTY
10885: LIST
10886: LIST
10887: LIST
10888: LIST
10889: ST_TO_ADDR
// apeman = CreateHuman ;
10890: LD_ADDR_VAR 0 7
10894: PUSH
10895: CALL_OW 44
10899: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
10900: LD_VAR 0 7
10904: PPUSH
10905: LD_VAR 0 4
10909: PPUSH
10910: LD_INT 0
10912: PPUSH
10913: CALL_OW 49
// l = l + 1 ;
10917: LD_ADDR_VAR 0 6
10921: PUSH
10922: LD_VAR 0 6
10926: PUSH
10927: LD_INT 1
10929: PLUS
10930: ST_TO_ADDR
// end until l = num1 ;
10931: LD_VAR 0 6
10935: PUSH
10936: LD_VAR 0 1
10940: EQUAL
10941: IFFALSE 10771
// l = 0 ;
10943: LD_ADDR_VAR 0 6
10947: PUSH
10948: LD_INT 0
10950: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
10951: LD_ADDR_OWVAR 35
10955: PUSH
10956: LD_INT 0
10958: PPUSH
10959: LD_INT 25
10961: PPUSH
10962: CALL_OW 12
10966: ST_TO_ADDR
// hc_class = class_tiger ;
10967: LD_ADDR_OWVAR 28
10971: PUSH
10972: LD_INT 14
10974: ST_TO_ADDR
// hc_sex = sex_male ;
10975: LD_ADDR_OWVAR 27
10979: PUSH
10980: LD_INT 1
10982: ST_TO_ADDR
// hc_gallery = sandnature ;
10983: LD_ADDR_OWVAR 33
10987: PUSH
10988: LD_STRING sandnature
10990: ST_TO_ADDR
// hc_face_number = 3 ;
10991: LD_ADDR_OWVAR 34
10995: PUSH
10996: LD_INT 3
10998: ST_TO_ADDR
// tiger = CreateHuman ;
10999: LD_ADDR_VAR 0 8
11003: PUSH
11004: CALL_OW 44
11008: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
11009: LD_VAR 0 8
11013: PPUSH
11014: LD_VAR 0 4
11018: PPUSH
11019: LD_INT 0
11021: PPUSH
11022: CALL_OW 49
// l = l + 1 ;
11026: LD_ADDR_VAR 0 6
11030: PUSH
11031: LD_VAR 0 6
11035: PUSH
11036: LD_INT 1
11038: PLUS
11039: ST_TO_ADDR
// end until l = num2 ;
11040: LD_VAR 0 6
11044: PUSH
11045: LD_VAR 0 2
11049: EQUAL
11050: IFFALSE 10951
// l = 0 ;
11052: LD_ADDR_VAR 0 6
11056: PUSH
11057: LD_INT 0
11059: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
11060: LD_ADDR_OWVAR 28
11064: PUSH
11065: LD_INT 18
11067: ST_TO_ADDR
// hc_gallery = sandnature ;
11068: LD_ADDR_OWVAR 33
11072: PUSH
11073: LD_STRING sandnature
11075: ST_TO_ADDR
// hc_face_number = 1 ;
11076: LD_ADDR_OWVAR 34
11080: PUSH
11081: LD_INT 1
11083: ST_TO_ADDR
// bird = CreateHuman ;
11084: LD_ADDR_VAR 0 9
11088: PUSH
11089: CALL_OW 44
11093: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
11094: LD_VAR 0 9
11098: PPUSH
11099: LD_INT 0
11101: PPUSH
11102: CALL_OW 51
// l = l + 1 ;
11106: LD_ADDR_VAR 0 6
11110: PUSH
11111: LD_VAR 0 6
11115: PUSH
11116: LD_INT 1
11118: PLUS
11119: ST_TO_ADDR
// end until l = num3 ;
11120: LD_VAR 0 6
11124: PUSH
11125: LD_VAR 0 3
11129: EQUAL
11130: IFFALSE 11060
// end ; end_of_file
11132: LD_VAR 0 5
11136: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
11137: GO 11139
11139: DISABLE
// begin ru_radar := 98 ;
11140: LD_ADDR_EXP 26
11144: PUSH
11145: LD_INT 98
11147: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
11148: LD_ADDR_EXP 27
11152: PUSH
11153: LD_INT 89
11155: ST_TO_ADDR
// us_hack := 99 ;
11156: LD_ADDR_EXP 28
11160: PUSH
11161: LD_INT 99
11163: ST_TO_ADDR
// us_artillery := 97 ;
11164: LD_ADDR_EXP 29
11168: PUSH
11169: LD_INT 97
11171: ST_TO_ADDR
// ar_bio_bomb := 91 ;
11172: LD_ADDR_EXP 30
11176: PUSH
11177: LD_INT 91
11179: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
11180: LD_ADDR_EXP 31
11184: PUSH
11185: LD_INT 92
11187: ST_TO_ADDR
// tech_Artillery := 80 ;
11188: LD_ADDR_EXP 32
11192: PUSH
11193: LD_INT 80
11195: ST_TO_ADDR
// tech_RadMat := 81 ;
11196: LD_ADDR_EXP 33
11200: PUSH
11201: LD_INT 81
11203: ST_TO_ADDR
// tech_BasicTools := 82 ;
11204: LD_ADDR_EXP 34
11208: PUSH
11209: LD_INT 82
11211: ST_TO_ADDR
// tech_Cargo := 83 ;
11212: LD_ADDR_EXP 35
11216: PUSH
11217: LD_INT 83
11219: ST_TO_ADDR
// tech_Track := 84 ;
11220: LD_ADDR_EXP 36
11224: PUSH
11225: LD_INT 84
11227: ST_TO_ADDR
// tech_Crane := 85 ;
11228: LD_ADDR_EXP 37
11232: PUSH
11233: LD_INT 85
11235: ST_TO_ADDR
// tech_Bulldozer := 86 ;
11236: LD_ADDR_EXP 38
11240: PUSH
11241: LD_INT 86
11243: ST_TO_ADDR
// tech_Hovercraft := 87 ;
11244: LD_ADDR_EXP 39
11248: PUSH
11249: LD_INT 87
11251: ST_TO_ADDR
// end ; end_of_file end_of_file
11252: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
11253: GO 11255
11255: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
11256: LD_STRING initStreamRollete();
11258: PPUSH
11259: CALL_OW 559
// InitStreamMode ;
11263: CALL 11272 0 0
// DefineStreamItems ( ) ;
11267: CALL 11712 0 0
// end ;
11271: END
// function InitStreamMode ; begin
11272: LD_INT 0
11274: PPUSH
// streamModeActive := false ;
11275: LD_ADDR_EXP 40
11279: PUSH
11280: LD_INT 0
11282: ST_TO_ADDR
// normalCounter := 36 ;
11283: LD_ADDR_EXP 41
11287: PUSH
11288: LD_INT 36
11290: ST_TO_ADDR
// hardcoreCounter := 16 ;
11291: LD_ADDR_EXP 42
11295: PUSH
11296: LD_INT 16
11298: ST_TO_ADDR
// sRocket := false ;
11299: LD_ADDR_EXP 45
11303: PUSH
11304: LD_INT 0
11306: ST_TO_ADDR
// sSpeed := false ;
11307: LD_ADDR_EXP 44
11311: PUSH
11312: LD_INT 0
11314: ST_TO_ADDR
// sEngine := false ;
11315: LD_ADDR_EXP 46
11319: PUSH
11320: LD_INT 0
11322: ST_TO_ADDR
// sSpec := false ;
11323: LD_ADDR_EXP 43
11327: PUSH
11328: LD_INT 0
11330: ST_TO_ADDR
// sLevel := false ;
11331: LD_ADDR_EXP 47
11335: PUSH
11336: LD_INT 0
11338: ST_TO_ADDR
// sArmoury := false ;
11339: LD_ADDR_EXP 48
11343: PUSH
11344: LD_INT 0
11346: ST_TO_ADDR
// sRadar := false ;
11347: LD_ADDR_EXP 49
11351: PUSH
11352: LD_INT 0
11354: ST_TO_ADDR
// sBunker := false ;
11355: LD_ADDR_EXP 50
11359: PUSH
11360: LD_INT 0
11362: ST_TO_ADDR
// sHack := false ;
11363: LD_ADDR_EXP 51
11367: PUSH
11368: LD_INT 0
11370: ST_TO_ADDR
// sFire := false ;
11371: LD_ADDR_EXP 52
11375: PUSH
11376: LD_INT 0
11378: ST_TO_ADDR
// sRefresh := false ;
11379: LD_ADDR_EXP 53
11383: PUSH
11384: LD_INT 0
11386: ST_TO_ADDR
// sExp := false ;
11387: LD_ADDR_EXP 54
11391: PUSH
11392: LD_INT 0
11394: ST_TO_ADDR
// sDepot := false ;
11395: LD_ADDR_EXP 55
11399: PUSH
11400: LD_INT 0
11402: ST_TO_ADDR
// sFlag := false ;
11403: LD_ADDR_EXP 56
11407: PUSH
11408: LD_INT 0
11410: ST_TO_ADDR
// sKamikadze := false ;
11411: LD_ADDR_EXP 64
11415: PUSH
11416: LD_INT 0
11418: ST_TO_ADDR
// sTroll := false ;
11419: LD_ADDR_EXP 65
11423: PUSH
11424: LD_INT 0
11426: ST_TO_ADDR
// sSlow := false ;
11427: LD_ADDR_EXP 66
11431: PUSH
11432: LD_INT 0
11434: ST_TO_ADDR
// sLack := false ;
11435: LD_ADDR_EXP 67
11439: PUSH
11440: LD_INT 0
11442: ST_TO_ADDR
// sTank := false ;
11443: LD_ADDR_EXP 69
11447: PUSH
11448: LD_INT 0
11450: ST_TO_ADDR
// sRemote := false ;
11451: LD_ADDR_EXP 70
11455: PUSH
11456: LD_INT 0
11458: ST_TO_ADDR
// sPowell := false ;
11459: LD_ADDR_EXP 71
11463: PUSH
11464: LD_INT 0
11466: ST_TO_ADDR
// sTeleport := false ;
11467: LD_ADDR_EXP 74
11471: PUSH
11472: LD_INT 0
11474: ST_TO_ADDR
// sOilTower := false ;
11475: LD_ADDR_EXP 76
11479: PUSH
11480: LD_INT 0
11482: ST_TO_ADDR
// sShovel := false ;
11483: LD_ADDR_EXP 77
11487: PUSH
11488: LD_INT 0
11490: ST_TO_ADDR
// sSheik := false ;
11491: LD_ADDR_EXP 78
11495: PUSH
11496: LD_INT 0
11498: ST_TO_ADDR
// sEarthquake := false ;
11499: LD_ADDR_EXP 80
11503: PUSH
11504: LD_INT 0
11506: ST_TO_ADDR
// sAI := false ;
11507: LD_ADDR_EXP 81
11511: PUSH
11512: LD_INT 0
11514: ST_TO_ADDR
// sCargo := false ;
11515: LD_ADDR_EXP 84
11519: PUSH
11520: LD_INT 0
11522: ST_TO_ADDR
// sDLaser := false ;
11523: LD_ADDR_EXP 85
11527: PUSH
11528: LD_INT 0
11530: ST_TO_ADDR
// sExchange := false ;
11531: LD_ADDR_EXP 86
11535: PUSH
11536: LD_INT 0
11538: ST_TO_ADDR
// sFac := false ;
11539: LD_ADDR_EXP 87
11543: PUSH
11544: LD_INT 0
11546: ST_TO_ADDR
// sPower := false ;
11547: LD_ADDR_EXP 88
11551: PUSH
11552: LD_INT 0
11554: ST_TO_ADDR
// sRandom := false ;
11555: LD_ADDR_EXP 89
11559: PUSH
11560: LD_INT 0
11562: ST_TO_ADDR
// sShield := false ;
11563: LD_ADDR_EXP 90
11567: PUSH
11568: LD_INT 0
11570: ST_TO_ADDR
// sTime := false ;
11571: LD_ADDR_EXP 91
11575: PUSH
11576: LD_INT 0
11578: ST_TO_ADDR
// sTools := false ;
11579: LD_ADDR_EXP 92
11583: PUSH
11584: LD_INT 0
11586: ST_TO_ADDR
// sSold := false ;
11587: LD_ADDR_EXP 57
11591: PUSH
11592: LD_INT 0
11594: ST_TO_ADDR
// sDiff := false ;
11595: LD_ADDR_EXP 58
11599: PUSH
11600: LD_INT 0
11602: ST_TO_ADDR
// sFog := false ;
11603: LD_ADDR_EXP 61
11607: PUSH
11608: LD_INT 0
11610: ST_TO_ADDR
// sReset := false ;
11611: LD_ADDR_EXP 62
11615: PUSH
11616: LD_INT 0
11618: ST_TO_ADDR
// sSun := false ;
11619: LD_ADDR_EXP 63
11623: PUSH
11624: LD_INT 0
11626: ST_TO_ADDR
// sTiger := false ;
11627: LD_ADDR_EXP 59
11631: PUSH
11632: LD_INT 0
11634: ST_TO_ADDR
// sBomb := false ;
11635: LD_ADDR_EXP 60
11639: PUSH
11640: LD_INT 0
11642: ST_TO_ADDR
// sWound := false ;
11643: LD_ADDR_EXP 68
11647: PUSH
11648: LD_INT 0
11650: ST_TO_ADDR
// sBetray := false ;
11651: LD_ADDR_EXP 72
11655: PUSH
11656: LD_INT 0
11658: ST_TO_ADDR
// sContamin := false ;
11659: LD_ADDR_EXP 73
11663: PUSH
11664: LD_INT 0
11666: ST_TO_ADDR
// sOil := false ;
11667: LD_ADDR_EXP 75
11671: PUSH
11672: LD_INT 0
11674: ST_TO_ADDR
// sStu := false ;
11675: LD_ADDR_EXP 79
11679: PUSH
11680: LD_INT 0
11682: ST_TO_ADDR
// sBazooka := false ;
11683: LD_ADDR_EXP 82
11687: PUSH
11688: LD_INT 0
11690: ST_TO_ADDR
// sMortar := false ;
11691: LD_ADDR_EXP 83
11695: PUSH
11696: LD_INT 0
11698: ST_TO_ADDR
// sRanger := false ;
11699: LD_ADDR_EXP 93
11703: PUSH
11704: LD_INT 0
11706: ST_TO_ADDR
// end ;
11707: LD_VAR 0 1
11711: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
11712: LD_INT 0
11714: PPUSH
11715: PPUSH
11716: PPUSH
11717: PPUSH
11718: PPUSH
// result := [ ] ;
11719: LD_ADDR_VAR 0 1
11723: PUSH
11724: EMPTY
11725: ST_TO_ADDR
// if campaign_id = 1 then
11726: LD_OWVAR 69
11730: PUSH
11731: LD_INT 1
11733: EQUAL
11734: IFFALSE 14672
// begin case mission_number of 1 :
11736: LD_OWVAR 70
11740: PUSH
11741: LD_INT 1
11743: DOUBLE
11744: EQUAL
11745: IFTRUE 11749
11747: GO 11813
11749: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
11750: LD_ADDR_VAR 0 1
11754: PUSH
11755: LD_INT 2
11757: PUSH
11758: LD_INT 4
11760: PUSH
11761: LD_INT 11
11763: PUSH
11764: LD_INT 12
11766: PUSH
11767: LD_INT 15
11769: PUSH
11770: LD_INT 16
11772: PUSH
11773: LD_INT 22
11775: PUSH
11776: LD_INT 23
11778: PUSH
11779: LD_INT 26
11781: PUSH
11782: EMPTY
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: LIST
11792: PUSH
11793: LD_INT 101
11795: PUSH
11796: LD_INT 102
11798: PUSH
11799: LD_INT 106
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: LIST
11806: PUSH
11807: EMPTY
11808: LIST
11809: LIST
11810: ST_TO_ADDR
11811: GO 14670
11813: LD_INT 2
11815: DOUBLE
11816: EQUAL
11817: IFTRUE 11821
11819: GO 11893
11821: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
11822: LD_ADDR_VAR 0 1
11826: PUSH
11827: LD_INT 2
11829: PUSH
11830: LD_INT 4
11832: PUSH
11833: LD_INT 11
11835: PUSH
11836: LD_INT 12
11838: PUSH
11839: LD_INT 15
11841: PUSH
11842: LD_INT 16
11844: PUSH
11845: LD_INT 22
11847: PUSH
11848: LD_INT 23
11850: PUSH
11851: LD_INT 26
11853: PUSH
11854: EMPTY
11855: LIST
11856: LIST
11857: LIST
11858: LIST
11859: LIST
11860: LIST
11861: LIST
11862: LIST
11863: LIST
11864: PUSH
11865: LD_INT 101
11867: PUSH
11868: LD_INT 102
11870: PUSH
11871: LD_INT 105
11873: PUSH
11874: LD_INT 106
11876: PUSH
11877: LD_INT 108
11879: PUSH
11880: EMPTY
11881: LIST
11882: LIST
11883: LIST
11884: LIST
11885: LIST
11886: PUSH
11887: EMPTY
11888: LIST
11889: LIST
11890: ST_TO_ADDR
11891: GO 14670
11893: LD_INT 3
11895: DOUBLE
11896: EQUAL
11897: IFTRUE 11901
11899: GO 11977
11901: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
11902: LD_ADDR_VAR 0 1
11906: PUSH
11907: LD_INT 2
11909: PUSH
11910: LD_INT 4
11912: PUSH
11913: LD_INT 5
11915: PUSH
11916: LD_INT 11
11918: PUSH
11919: LD_INT 12
11921: PUSH
11922: LD_INT 15
11924: PUSH
11925: LD_INT 16
11927: PUSH
11928: LD_INT 22
11930: PUSH
11931: LD_INT 26
11933: PUSH
11934: LD_INT 36
11936: PUSH
11937: EMPTY
11938: LIST
11939: LIST
11940: LIST
11941: LIST
11942: LIST
11943: LIST
11944: LIST
11945: LIST
11946: LIST
11947: LIST
11948: PUSH
11949: LD_INT 101
11951: PUSH
11952: LD_INT 102
11954: PUSH
11955: LD_INT 105
11957: PUSH
11958: LD_INT 106
11960: PUSH
11961: LD_INT 108
11963: PUSH
11964: EMPTY
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: LIST
11970: PUSH
11971: EMPTY
11972: LIST
11973: LIST
11974: ST_TO_ADDR
11975: GO 14670
11977: LD_INT 4
11979: DOUBLE
11980: EQUAL
11981: IFTRUE 11985
11983: GO 12069
11985: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
11986: LD_ADDR_VAR 0 1
11990: PUSH
11991: LD_INT 2
11993: PUSH
11994: LD_INT 4
11996: PUSH
11997: LD_INT 5
11999: PUSH
12000: LD_INT 8
12002: PUSH
12003: LD_INT 11
12005: PUSH
12006: LD_INT 12
12008: PUSH
12009: LD_INT 15
12011: PUSH
12012: LD_INT 16
12014: PUSH
12015: LD_INT 22
12017: PUSH
12018: LD_INT 23
12020: PUSH
12021: LD_INT 26
12023: PUSH
12024: LD_INT 36
12026: PUSH
12027: EMPTY
12028: LIST
12029: LIST
12030: LIST
12031: LIST
12032: LIST
12033: LIST
12034: LIST
12035: LIST
12036: LIST
12037: LIST
12038: LIST
12039: LIST
12040: PUSH
12041: LD_INT 101
12043: PUSH
12044: LD_INT 102
12046: PUSH
12047: LD_INT 105
12049: PUSH
12050: LD_INT 106
12052: PUSH
12053: LD_INT 108
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: LIST
12060: LIST
12061: LIST
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: ST_TO_ADDR
12067: GO 14670
12069: LD_INT 5
12071: DOUBLE
12072: EQUAL
12073: IFTRUE 12077
12075: GO 12177
12077: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
12078: LD_ADDR_VAR 0 1
12082: PUSH
12083: LD_INT 2
12085: PUSH
12086: LD_INT 4
12088: PUSH
12089: LD_INT 5
12091: PUSH
12092: LD_INT 6
12094: PUSH
12095: LD_INT 8
12097: PUSH
12098: LD_INT 11
12100: PUSH
12101: LD_INT 12
12103: PUSH
12104: LD_INT 15
12106: PUSH
12107: LD_INT 16
12109: PUSH
12110: LD_INT 22
12112: PUSH
12113: LD_INT 23
12115: PUSH
12116: LD_INT 25
12118: PUSH
12119: LD_INT 26
12121: PUSH
12122: LD_INT 36
12124: PUSH
12125: EMPTY
12126: LIST
12127: LIST
12128: LIST
12129: LIST
12130: LIST
12131: LIST
12132: LIST
12133: LIST
12134: LIST
12135: LIST
12136: LIST
12137: LIST
12138: LIST
12139: LIST
12140: PUSH
12141: LD_INT 101
12143: PUSH
12144: LD_INT 102
12146: PUSH
12147: LD_INT 105
12149: PUSH
12150: LD_INT 106
12152: PUSH
12153: LD_INT 108
12155: PUSH
12156: LD_INT 109
12158: PUSH
12159: LD_INT 112
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: LIST
12166: LIST
12167: LIST
12168: LIST
12169: LIST
12170: PUSH
12171: EMPTY
12172: LIST
12173: LIST
12174: ST_TO_ADDR
12175: GO 14670
12177: LD_INT 6
12179: DOUBLE
12180: EQUAL
12181: IFTRUE 12185
12183: GO 12305
12185: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
12186: LD_ADDR_VAR 0 1
12190: PUSH
12191: LD_INT 2
12193: PUSH
12194: LD_INT 4
12196: PUSH
12197: LD_INT 5
12199: PUSH
12200: LD_INT 6
12202: PUSH
12203: LD_INT 8
12205: PUSH
12206: LD_INT 11
12208: PUSH
12209: LD_INT 12
12211: PUSH
12212: LD_INT 15
12214: PUSH
12215: LD_INT 16
12217: PUSH
12218: LD_INT 20
12220: PUSH
12221: LD_INT 21
12223: PUSH
12224: LD_INT 22
12226: PUSH
12227: LD_INT 23
12229: PUSH
12230: LD_INT 25
12232: PUSH
12233: LD_INT 26
12235: PUSH
12236: LD_INT 30
12238: PUSH
12239: LD_INT 31
12241: PUSH
12242: LD_INT 32
12244: PUSH
12245: LD_INT 36
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: LIST
12262: LIST
12263: LIST
12264: LIST
12265: LIST
12266: LIST
12267: LIST
12268: PUSH
12269: LD_INT 101
12271: PUSH
12272: LD_INT 102
12274: PUSH
12275: LD_INT 105
12277: PUSH
12278: LD_INT 106
12280: PUSH
12281: LD_INT 108
12283: PUSH
12284: LD_INT 109
12286: PUSH
12287: LD_INT 112
12289: PUSH
12290: EMPTY
12291: LIST
12292: LIST
12293: LIST
12294: LIST
12295: LIST
12296: LIST
12297: LIST
12298: PUSH
12299: EMPTY
12300: LIST
12301: LIST
12302: ST_TO_ADDR
12303: GO 14670
12305: LD_INT 7
12307: DOUBLE
12308: EQUAL
12309: IFTRUE 12313
12311: GO 12413
12313: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
12314: LD_ADDR_VAR 0 1
12318: PUSH
12319: LD_INT 2
12321: PUSH
12322: LD_INT 4
12324: PUSH
12325: LD_INT 5
12327: PUSH
12328: LD_INT 7
12330: PUSH
12331: LD_INT 11
12333: PUSH
12334: LD_INT 12
12336: PUSH
12337: LD_INT 15
12339: PUSH
12340: LD_INT 16
12342: PUSH
12343: LD_INT 20
12345: PUSH
12346: LD_INT 21
12348: PUSH
12349: LD_INT 22
12351: PUSH
12352: LD_INT 23
12354: PUSH
12355: LD_INT 25
12357: PUSH
12358: LD_INT 26
12360: PUSH
12361: EMPTY
12362: LIST
12363: LIST
12364: LIST
12365: LIST
12366: LIST
12367: LIST
12368: LIST
12369: LIST
12370: LIST
12371: LIST
12372: LIST
12373: LIST
12374: LIST
12375: LIST
12376: PUSH
12377: LD_INT 101
12379: PUSH
12380: LD_INT 102
12382: PUSH
12383: LD_INT 103
12385: PUSH
12386: LD_INT 105
12388: PUSH
12389: LD_INT 106
12391: PUSH
12392: LD_INT 108
12394: PUSH
12395: LD_INT 112
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: LIST
12402: LIST
12403: LIST
12404: LIST
12405: LIST
12406: PUSH
12407: EMPTY
12408: LIST
12409: LIST
12410: ST_TO_ADDR
12411: GO 14670
12413: LD_INT 8
12415: DOUBLE
12416: EQUAL
12417: IFTRUE 12421
12419: GO 12549
12421: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
12422: LD_ADDR_VAR 0 1
12426: PUSH
12427: LD_INT 2
12429: PUSH
12430: LD_INT 4
12432: PUSH
12433: LD_INT 5
12435: PUSH
12436: LD_INT 6
12438: PUSH
12439: LD_INT 7
12441: PUSH
12442: LD_INT 8
12444: PUSH
12445: LD_INT 11
12447: PUSH
12448: LD_INT 12
12450: PUSH
12451: LD_INT 15
12453: PUSH
12454: LD_INT 16
12456: PUSH
12457: LD_INT 20
12459: PUSH
12460: LD_INT 21
12462: PUSH
12463: LD_INT 22
12465: PUSH
12466: LD_INT 23
12468: PUSH
12469: LD_INT 25
12471: PUSH
12472: LD_INT 26
12474: PUSH
12475: LD_INT 30
12477: PUSH
12478: LD_INT 31
12480: PUSH
12481: LD_INT 32
12483: PUSH
12484: LD_INT 36
12486: PUSH
12487: EMPTY
12488: LIST
12489: LIST
12490: LIST
12491: LIST
12492: LIST
12493: LIST
12494: LIST
12495: LIST
12496: LIST
12497: LIST
12498: LIST
12499: LIST
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: LIST
12505: LIST
12506: LIST
12507: LIST
12508: PUSH
12509: LD_INT 101
12511: PUSH
12512: LD_INT 102
12514: PUSH
12515: LD_INT 103
12517: PUSH
12518: LD_INT 105
12520: PUSH
12521: LD_INT 106
12523: PUSH
12524: LD_INT 108
12526: PUSH
12527: LD_INT 109
12529: PUSH
12530: LD_INT 112
12532: PUSH
12533: EMPTY
12534: LIST
12535: LIST
12536: LIST
12537: LIST
12538: LIST
12539: LIST
12540: LIST
12541: LIST
12542: PUSH
12543: EMPTY
12544: LIST
12545: LIST
12546: ST_TO_ADDR
12547: GO 14670
12549: LD_INT 9
12551: DOUBLE
12552: EQUAL
12553: IFTRUE 12557
12555: GO 12693
12557: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
12558: LD_ADDR_VAR 0 1
12562: PUSH
12563: LD_INT 2
12565: PUSH
12566: LD_INT 4
12568: PUSH
12569: LD_INT 5
12571: PUSH
12572: LD_INT 6
12574: PUSH
12575: LD_INT 7
12577: PUSH
12578: LD_INT 8
12580: PUSH
12581: LD_INT 11
12583: PUSH
12584: LD_INT 12
12586: PUSH
12587: LD_INT 15
12589: PUSH
12590: LD_INT 16
12592: PUSH
12593: LD_INT 20
12595: PUSH
12596: LD_INT 21
12598: PUSH
12599: LD_INT 22
12601: PUSH
12602: LD_INT 23
12604: PUSH
12605: LD_INT 25
12607: PUSH
12608: LD_INT 26
12610: PUSH
12611: LD_INT 28
12613: PUSH
12614: LD_INT 30
12616: PUSH
12617: LD_INT 31
12619: PUSH
12620: LD_INT 32
12622: PUSH
12623: LD_INT 36
12625: PUSH
12626: EMPTY
12627: LIST
12628: LIST
12629: LIST
12630: LIST
12631: LIST
12632: LIST
12633: LIST
12634: LIST
12635: LIST
12636: LIST
12637: LIST
12638: LIST
12639: LIST
12640: LIST
12641: LIST
12642: LIST
12643: LIST
12644: LIST
12645: LIST
12646: LIST
12647: LIST
12648: PUSH
12649: LD_INT 101
12651: PUSH
12652: LD_INT 102
12654: PUSH
12655: LD_INT 103
12657: PUSH
12658: LD_INT 105
12660: PUSH
12661: LD_INT 106
12663: PUSH
12664: LD_INT 108
12666: PUSH
12667: LD_INT 109
12669: PUSH
12670: LD_INT 112
12672: PUSH
12673: LD_INT 114
12675: PUSH
12676: EMPTY
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: LIST
12686: PUSH
12687: EMPTY
12688: LIST
12689: LIST
12690: ST_TO_ADDR
12691: GO 14670
12693: LD_INT 10
12695: DOUBLE
12696: EQUAL
12697: IFTRUE 12701
12699: GO 12885
12701: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
12702: LD_ADDR_VAR 0 1
12706: PUSH
12707: LD_INT 2
12709: PUSH
12710: LD_INT 4
12712: PUSH
12713: LD_INT 5
12715: PUSH
12716: LD_INT 6
12718: PUSH
12719: LD_INT 7
12721: PUSH
12722: LD_INT 8
12724: PUSH
12725: LD_INT 9
12727: PUSH
12728: LD_INT 10
12730: PUSH
12731: LD_INT 11
12733: PUSH
12734: LD_INT 12
12736: PUSH
12737: LD_INT 13
12739: PUSH
12740: LD_INT 14
12742: PUSH
12743: LD_INT 15
12745: PUSH
12746: LD_INT 16
12748: PUSH
12749: LD_INT 17
12751: PUSH
12752: LD_INT 18
12754: PUSH
12755: LD_INT 19
12757: PUSH
12758: LD_INT 20
12760: PUSH
12761: LD_INT 21
12763: PUSH
12764: LD_INT 22
12766: PUSH
12767: LD_INT 23
12769: PUSH
12770: LD_INT 24
12772: PUSH
12773: LD_INT 25
12775: PUSH
12776: LD_INT 26
12778: PUSH
12779: LD_INT 28
12781: PUSH
12782: LD_INT 30
12784: PUSH
12785: LD_INT 31
12787: PUSH
12788: LD_INT 32
12790: PUSH
12791: LD_INT 36
12793: PUSH
12794: EMPTY
12795: LIST
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: LIST
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: LIST
12823: LIST
12824: PUSH
12825: LD_INT 101
12827: PUSH
12828: LD_INT 102
12830: PUSH
12831: LD_INT 103
12833: PUSH
12834: LD_INT 104
12836: PUSH
12837: LD_INT 105
12839: PUSH
12840: LD_INT 106
12842: PUSH
12843: LD_INT 107
12845: PUSH
12846: LD_INT 108
12848: PUSH
12849: LD_INT 109
12851: PUSH
12852: LD_INT 110
12854: PUSH
12855: LD_INT 111
12857: PUSH
12858: LD_INT 112
12860: PUSH
12861: LD_INT 114
12863: PUSH
12864: EMPTY
12865: LIST
12866: LIST
12867: LIST
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: LIST
12873: LIST
12874: LIST
12875: LIST
12876: LIST
12877: LIST
12878: PUSH
12879: EMPTY
12880: LIST
12881: LIST
12882: ST_TO_ADDR
12883: GO 14670
12885: LD_INT 11
12887: DOUBLE
12888: EQUAL
12889: IFTRUE 12893
12891: GO 13085
12893: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
12894: LD_ADDR_VAR 0 1
12898: PUSH
12899: LD_INT 2
12901: PUSH
12902: LD_INT 3
12904: PUSH
12905: LD_INT 4
12907: PUSH
12908: LD_INT 5
12910: PUSH
12911: LD_INT 6
12913: PUSH
12914: LD_INT 7
12916: PUSH
12917: LD_INT 8
12919: PUSH
12920: LD_INT 9
12922: PUSH
12923: LD_INT 10
12925: PUSH
12926: LD_INT 11
12928: PUSH
12929: LD_INT 12
12931: PUSH
12932: LD_INT 13
12934: PUSH
12935: LD_INT 14
12937: PUSH
12938: LD_INT 15
12940: PUSH
12941: LD_INT 16
12943: PUSH
12944: LD_INT 17
12946: PUSH
12947: LD_INT 18
12949: PUSH
12950: LD_INT 19
12952: PUSH
12953: LD_INT 20
12955: PUSH
12956: LD_INT 21
12958: PUSH
12959: LD_INT 22
12961: PUSH
12962: LD_INT 23
12964: PUSH
12965: LD_INT 24
12967: PUSH
12968: LD_INT 25
12970: PUSH
12971: LD_INT 26
12973: PUSH
12974: LD_INT 28
12976: PUSH
12977: LD_INT 30
12979: PUSH
12980: LD_INT 31
12982: PUSH
12983: LD_INT 32
12985: PUSH
12986: LD_INT 34
12988: PUSH
12989: LD_INT 36
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: LIST
12996: LIST
12997: LIST
12998: LIST
12999: LIST
13000: LIST
13001: LIST
13002: LIST
13003: LIST
13004: LIST
13005: LIST
13006: LIST
13007: LIST
13008: LIST
13009: LIST
13010: LIST
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: LIST
13020: LIST
13021: LIST
13022: LIST
13023: LIST
13024: PUSH
13025: LD_INT 101
13027: PUSH
13028: LD_INT 102
13030: PUSH
13031: LD_INT 103
13033: PUSH
13034: LD_INT 104
13036: PUSH
13037: LD_INT 105
13039: PUSH
13040: LD_INT 106
13042: PUSH
13043: LD_INT 107
13045: PUSH
13046: LD_INT 108
13048: PUSH
13049: LD_INT 109
13051: PUSH
13052: LD_INT 110
13054: PUSH
13055: LD_INT 111
13057: PUSH
13058: LD_INT 112
13060: PUSH
13061: LD_INT 114
13063: PUSH
13064: EMPTY
13065: LIST
13066: LIST
13067: LIST
13068: LIST
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: LIST
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: ST_TO_ADDR
13083: GO 14670
13085: LD_INT 12
13087: DOUBLE
13088: EQUAL
13089: IFTRUE 13093
13091: GO 13301
13093: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
13094: LD_ADDR_VAR 0 1
13098: PUSH
13099: LD_INT 1
13101: PUSH
13102: LD_INT 2
13104: PUSH
13105: LD_INT 3
13107: PUSH
13108: LD_INT 4
13110: PUSH
13111: LD_INT 5
13113: PUSH
13114: LD_INT 6
13116: PUSH
13117: LD_INT 7
13119: PUSH
13120: LD_INT 8
13122: PUSH
13123: LD_INT 9
13125: PUSH
13126: LD_INT 10
13128: PUSH
13129: LD_INT 11
13131: PUSH
13132: LD_INT 12
13134: PUSH
13135: LD_INT 13
13137: PUSH
13138: LD_INT 14
13140: PUSH
13141: LD_INT 15
13143: PUSH
13144: LD_INT 16
13146: PUSH
13147: LD_INT 17
13149: PUSH
13150: LD_INT 18
13152: PUSH
13153: LD_INT 19
13155: PUSH
13156: LD_INT 20
13158: PUSH
13159: LD_INT 21
13161: PUSH
13162: LD_INT 22
13164: PUSH
13165: LD_INT 23
13167: PUSH
13168: LD_INT 24
13170: PUSH
13171: LD_INT 25
13173: PUSH
13174: LD_INT 26
13176: PUSH
13177: LD_INT 27
13179: PUSH
13180: LD_INT 28
13182: PUSH
13183: LD_INT 30
13185: PUSH
13186: LD_INT 31
13188: PUSH
13189: LD_INT 32
13191: PUSH
13192: LD_INT 33
13194: PUSH
13195: LD_INT 34
13197: PUSH
13198: LD_INT 36
13200: PUSH
13201: EMPTY
13202: LIST
13203: LIST
13204: LIST
13205: LIST
13206: LIST
13207: LIST
13208: LIST
13209: LIST
13210: LIST
13211: LIST
13212: LIST
13213: LIST
13214: LIST
13215: LIST
13216: LIST
13217: LIST
13218: LIST
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: LIST
13225: LIST
13226: LIST
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: LIST
13232: LIST
13233: LIST
13234: LIST
13235: LIST
13236: PUSH
13237: LD_INT 101
13239: PUSH
13240: LD_INT 102
13242: PUSH
13243: LD_INT 103
13245: PUSH
13246: LD_INT 104
13248: PUSH
13249: LD_INT 105
13251: PUSH
13252: LD_INT 106
13254: PUSH
13255: LD_INT 107
13257: PUSH
13258: LD_INT 108
13260: PUSH
13261: LD_INT 109
13263: PUSH
13264: LD_INT 110
13266: PUSH
13267: LD_INT 111
13269: PUSH
13270: LD_INT 112
13272: PUSH
13273: LD_INT 113
13275: PUSH
13276: LD_INT 114
13278: PUSH
13279: EMPTY
13280: LIST
13281: LIST
13282: LIST
13283: LIST
13284: LIST
13285: LIST
13286: LIST
13287: LIST
13288: LIST
13289: LIST
13290: LIST
13291: LIST
13292: LIST
13293: LIST
13294: PUSH
13295: EMPTY
13296: LIST
13297: LIST
13298: ST_TO_ADDR
13299: GO 14670
13301: LD_INT 13
13303: DOUBLE
13304: EQUAL
13305: IFTRUE 13309
13307: GO 13505
13309: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
13310: LD_ADDR_VAR 0 1
13314: PUSH
13315: LD_INT 1
13317: PUSH
13318: LD_INT 2
13320: PUSH
13321: LD_INT 3
13323: PUSH
13324: LD_INT 4
13326: PUSH
13327: LD_INT 5
13329: PUSH
13330: LD_INT 8
13332: PUSH
13333: LD_INT 9
13335: PUSH
13336: LD_INT 10
13338: PUSH
13339: LD_INT 11
13341: PUSH
13342: LD_INT 12
13344: PUSH
13345: LD_INT 14
13347: PUSH
13348: LD_INT 15
13350: PUSH
13351: LD_INT 16
13353: PUSH
13354: LD_INT 17
13356: PUSH
13357: LD_INT 18
13359: PUSH
13360: LD_INT 19
13362: PUSH
13363: LD_INT 20
13365: PUSH
13366: LD_INT 21
13368: PUSH
13369: LD_INT 22
13371: PUSH
13372: LD_INT 23
13374: PUSH
13375: LD_INT 24
13377: PUSH
13378: LD_INT 25
13380: PUSH
13381: LD_INT 26
13383: PUSH
13384: LD_INT 27
13386: PUSH
13387: LD_INT 28
13389: PUSH
13390: LD_INT 30
13392: PUSH
13393: LD_INT 31
13395: PUSH
13396: LD_INT 32
13398: PUSH
13399: LD_INT 33
13401: PUSH
13402: LD_INT 34
13404: PUSH
13405: LD_INT 36
13407: PUSH
13408: EMPTY
13409: LIST
13410: LIST
13411: LIST
13412: LIST
13413: LIST
13414: LIST
13415: LIST
13416: LIST
13417: LIST
13418: LIST
13419: LIST
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: LIST
13425: LIST
13426: LIST
13427: LIST
13428: LIST
13429: LIST
13430: LIST
13431: LIST
13432: LIST
13433: LIST
13434: LIST
13435: LIST
13436: LIST
13437: LIST
13438: LIST
13439: LIST
13440: PUSH
13441: LD_INT 101
13443: PUSH
13444: LD_INT 102
13446: PUSH
13447: LD_INT 103
13449: PUSH
13450: LD_INT 104
13452: PUSH
13453: LD_INT 105
13455: PUSH
13456: LD_INT 106
13458: PUSH
13459: LD_INT 107
13461: PUSH
13462: LD_INT 108
13464: PUSH
13465: LD_INT 109
13467: PUSH
13468: LD_INT 110
13470: PUSH
13471: LD_INT 111
13473: PUSH
13474: LD_INT 112
13476: PUSH
13477: LD_INT 113
13479: PUSH
13480: LD_INT 114
13482: PUSH
13483: EMPTY
13484: LIST
13485: LIST
13486: LIST
13487: LIST
13488: LIST
13489: LIST
13490: LIST
13491: LIST
13492: LIST
13493: LIST
13494: LIST
13495: LIST
13496: LIST
13497: LIST
13498: PUSH
13499: EMPTY
13500: LIST
13501: LIST
13502: ST_TO_ADDR
13503: GO 14670
13505: LD_INT 14
13507: DOUBLE
13508: EQUAL
13509: IFTRUE 13513
13511: GO 13725
13513: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
13514: LD_ADDR_VAR 0 1
13518: PUSH
13519: LD_INT 1
13521: PUSH
13522: LD_INT 2
13524: PUSH
13525: LD_INT 3
13527: PUSH
13528: LD_INT 4
13530: PUSH
13531: LD_INT 5
13533: PUSH
13534: LD_INT 6
13536: PUSH
13537: LD_INT 7
13539: PUSH
13540: LD_INT 8
13542: PUSH
13543: LD_INT 9
13545: PUSH
13546: LD_INT 10
13548: PUSH
13549: LD_INT 11
13551: PUSH
13552: LD_INT 12
13554: PUSH
13555: LD_INT 13
13557: PUSH
13558: LD_INT 14
13560: PUSH
13561: LD_INT 15
13563: PUSH
13564: LD_INT 16
13566: PUSH
13567: LD_INT 17
13569: PUSH
13570: LD_INT 18
13572: PUSH
13573: LD_INT 19
13575: PUSH
13576: LD_INT 20
13578: PUSH
13579: LD_INT 21
13581: PUSH
13582: LD_INT 22
13584: PUSH
13585: LD_INT 23
13587: PUSH
13588: LD_INT 24
13590: PUSH
13591: LD_INT 25
13593: PUSH
13594: LD_INT 26
13596: PUSH
13597: LD_INT 27
13599: PUSH
13600: LD_INT 28
13602: PUSH
13603: LD_INT 29
13605: PUSH
13606: LD_INT 30
13608: PUSH
13609: LD_INT 31
13611: PUSH
13612: LD_INT 32
13614: PUSH
13615: LD_INT 33
13617: PUSH
13618: LD_INT 34
13620: PUSH
13621: LD_INT 36
13623: PUSH
13624: EMPTY
13625: LIST
13626: LIST
13627: LIST
13628: LIST
13629: LIST
13630: LIST
13631: LIST
13632: LIST
13633: LIST
13634: LIST
13635: LIST
13636: LIST
13637: LIST
13638: LIST
13639: LIST
13640: LIST
13641: LIST
13642: LIST
13643: LIST
13644: LIST
13645: LIST
13646: LIST
13647: LIST
13648: LIST
13649: LIST
13650: LIST
13651: LIST
13652: LIST
13653: LIST
13654: LIST
13655: LIST
13656: LIST
13657: LIST
13658: LIST
13659: LIST
13660: PUSH
13661: LD_INT 101
13663: PUSH
13664: LD_INT 102
13666: PUSH
13667: LD_INT 103
13669: PUSH
13670: LD_INT 104
13672: PUSH
13673: LD_INT 105
13675: PUSH
13676: LD_INT 106
13678: PUSH
13679: LD_INT 107
13681: PUSH
13682: LD_INT 108
13684: PUSH
13685: LD_INT 109
13687: PUSH
13688: LD_INT 110
13690: PUSH
13691: LD_INT 111
13693: PUSH
13694: LD_INT 112
13696: PUSH
13697: LD_INT 113
13699: PUSH
13700: LD_INT 114
13702: PUSH
13703: EMPTY
13704: LIST
13705: LIST
13706: LIST
13707: LIST
13708: LIST
13709: LIST
13710: LIST
13711: LIST
13712: LIST
13713: LIST
13714: LIST
13715: LIST
13716: LIST
13717: LIST
13718: PUSH
13719: EMPTY
13720: LIST
13721: LIST
13722: ST_TO_ADDR
13723: GO 14670
13725: LD_INT 15
13727: DOUBLE
13728: EQUAL
13729: IFTRUE 13733
13731: GO 13945
13733: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
13734: LD_ADDR_VAR 0 1
13738: PUSH
13739: LD_INT 1
13741: PUSH
13742: LD_INT 2
13744: PUSH
13745: LD_INT 3
13747: PUSH
13748: LD_INT 4
13750: PUSH
13751: LD_INT 5
13753: PUSH
13754: LD_INT 6
13756: PUSH
13757: LD_INT 7
13759: PUSH
13760: LD_INT 8
13762: PUSH
13763: LD_INT 9
13765: PUSH
13766: LD_INT 10
13768: PUSH
13769: LD_INT 11
13771: PUSH
13772: LD_INT 12
13774: PUSH
13775: LD_INT 13
13777: PUSH
13778: LD_INT 14
13780: PUSH
13781: LD_INT 15
13783: PUSH
13784: LD_INT 16
13786: PUSH
13787: LD_INT 17
13789: PUSH
13790: LD_INT 18
13792: PUSH
13793: LD_INT 19
13795: PUSH
13796: LD_INT 20
13798: PUSH
13799: LD_INT 21
13801: PUSH
13802: LD_INT 22
13804: PUSH
13805: LD_INT 23
13807: PUSH
13808: LD_INT 24
13810: PUSH
13811: LD_INT 25
13813: PUSH
13814: LD_INT 26
13816: PUSH
13817: LD_INT 27
13819: PUSH
13820: LD_INT 28
13822: PUSH
13823: LD_INT 29
13825: PUSH
13826: LD_INT 30
13828: PUSH
13829: LD_INT 31
13831: PUSH
13832: LD_INT 32
13834: PUSH
13835: LD_INT 33
13837: PUSH
13838: LD_INT 34
13840: PUSH
13841: LD_INT 36
13843: PUSH
13844: EMPTY
13845: LIST
13846: LIST
13847: LIST
13848: LIST
13849: LIST
13850: LIST
13851: LIST
13852: LIST
13853: LIST
13854: LIST
13855: LIST
13856: LIST
13857: LIST
13858: LIST
13859: LIST
13860: LIST
13861: LIST
13862: LIST
13863: LIST
13864: LIST
13865: LIST
13866: LIST
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: PUSH
13881: LD_INT 101
13883: PUSH
13884: LD_INT 102
13886: PUSH
13887: LD_INT 103
13889: PUSH
13890: LD_INT 104
13892: PUSH
13893: LD_INT 105
13895: PUSH
13896: LD_INT 106
13898: PUSH
13899: LD_INT 107
13901: PUSH
13902: LD_INT 108
13904: PUSH
13905: LD_INT 109
13907: PUSH
13908: LD_INT 110
13910: PUSH
13911: LD_INT 111
13913: PUSH
13914: LD_INT 112
13916: PUSH
13917: LD_INT 113
13919: PUSH
13920: LD_INT 114
13922: PUSH
13923: EMPTY
13924: LIST
13925: LIST
13926: LIST
13927: LIST
13928: LIST
13929: LIST
13930: LIST
13931: LIST
13932: LIST
13933: LIST
13934: LIST
13935: LIST
13936: LIST
13937: LIST
13938: PUSH
13939: EMPTY
13940: LIST
13941: LIST
13942: ST_TO_ADDR
13943: GO 14670
13945: LD_INT 16
13947: DOUBLE
13948: EQUAL
13949: IFTRUE 13953
13951: GO 14077
13953: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
13954: LD_ADDR_VAR 0 1
13958: PUSH
13959: LD_INT 2
13961: PUSH
13962: LD_INT 4
13964: PUSH
13965: LD_INT 5
13967: PUSH
13968: LD_INT 7
13970: PUSH
13971: LD_INT 11
13973: PUSH
13974: LD_INT 12
13976: PUSH
13977: LD_INT 15
13979: PUSH
13980: LD_INT 16
13982: PUSH
13983: LD_INT 20
13985: PUSH
13986: LD_INT 21
13988: PUSH
13989: LD_INT 22
13991: PUSH
13992: LD_INT 23
13994: PUSH
13995: LD_INT 25
13997: PUSH
13998: LD_INT 26
14000: PUSH
14001: LD_INT 30
14003: PUSH
14004: LD_INT 31
14006: PUSH
14007: LD_INT 32
14009: PUSH
14010: LD_INT 33
14012: PUSH
14013: LD_INT 34
14015: PUSH
14016: EMPTY
14017: LIST
14018: LIST
14019: LIST
14020: LIST
14021: LIST
14022: LIST
14023: LIST
14024: LIST
14025: LIST
14026: LIST
14027: LIST
14028: LIST
14029: LIST
14030: LIST
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: LIST
14036: PUSH
14037: LD_INT 101
14039: PUSH
14040: LD_INT 102
14042: PUSH
14043: LD_INT 103
14045: PUSH
14046: LD_INT 106
14048: PUSH
14049: LD_INT 108
14051: PUSH
14052: LD_INT 112
14054: PUSH
14055: LD_INT 113
14057: PUSH
14058: LD_INT 114
14060: PUSH
14061: EMPTY
14062: LIST
14063: LIST
14064: LIST
14065: LIST
14066: LIST
14067: LIST
14068: LIST
14069: LIST
14070: PUSH
14071: EMPTY
14072: LIST
14073: LIST
14074: ST_TO_ADDR
14075: GO 14670
14077: LD_INT 17
14079: DOUBLE
14080: EQUAL
14081: IFTRUE 14085
14083: GO 14297
14085: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
14086: LD_ADDR_VAR 0 1
14090: PUSH
14091: LD_INT 1
14093: PUSH
14094: LD_INT 2
14096: PUSH
14097: LD_INT 3
14099: PUSH
14100: LD_INT 4
14102: PUSH
14103: LD_INT 5
14105: PUSH
14106: LD_INT 6
14108: PUSH
14109: LD_INT 7
14111: PUSH
14112: LD_INT 8
14114: PUSH
14115: LD_INT 9
14117: PUSH
14118: LD_INT 10
14120: PUSH
14121: LD_INT 11
14123: PUSH
14124: LD_INT 12
14126: PUSH
14127: LD_INT 13
14129: PUSH
14130: LD_INT 14
14132: PUSH
14133: LD_INT 15
14135: PUSH
14136: LD_INT 16
14138: PUSH
14139: LD_INT 17
14141: PUSH
14142: LD_INT 18
14144: PUSH
14145: LD_INT 19
14147: PUSH
14148: LD_INT 20
14150: PUSH
14151: LD_INT 21
14153: PUSH
14154: LD_INT 22
14156: PUSH
14157: LD_INT 23
14159: PUSH
14160: LD_INT 24
14162: PUSH
14163: LD_INT 25
14165: PUSH
14166: LD_INT 26
14168: PUSH
14169: LD_INT 27
14171: PUSH
14172: LD_INT 28
14174: PUSH
14175: LD_INT 29
14177: PUSH
14178: LD_INT 30
14180: PUSH
14181: LD_INT 31
14183: PUSH
14184: LD_INT 32
14186: PUSH
14187: LD_INT 33
14189: PUSH
14190: LD_INT 34
14192: PUSH
14193: LD_INT 36
14195: PUSH
14196: EMPTY
14197: LIST
14198: LIST
14199: LIST
14200: LIST
14201: LIST
14202: LIST
14203: LIST
14204: LIST
14205: LIST
14206: LIST
14207: LIST
14208: LIST
14209: LIST
14210: LIST
14211: LIST
14212: LIST
14213: LIST
14214: LIST
14215: LIST
14216: LIST
14217: LIST
14218: LIST
14219: LIST
14220: LIST
14221: LIST
14222: LIST
14223: LIST
14224: LIST
14225: LIST
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: LIST
14231: LIST
14232: PUSH
14233: LD_INT 101
14235: PUSH
14236: LD_INT 102
14238: PUSH
14239: LD_INT 103
14241: PUSH
14242: LD_INT 104
14244: PUSH
14245: LD_INT 105
14247: PUSH
14248: LD_INT 106
14250: PUSH
14251: LD_INT 107
14253: PUSH
14254: LD_INT 108
14256: PUSH
14257: LD_INT 109
14259: PUSH
14260: LD_INT 110
14262: PUSH
14263: LD_INT 111
14265: PUSH
14266: LD_INT 112
14268: PUSH
14269: LD_INT 113
14271: PUSH
14272: LD_INT 114
14274: PUSH
14275: EMPTY
14276: LIST
14277: LIST
14278: LIST
14279: LIST
14280: LIST
14281: LIST
14282: LIST
14283: LIST
14284: LIST
14285: LIST
14286: LIST
14287: LIST
14288: LIST
14289: LIST
14290: PUSH
14291: EMPTY
14292: LIST
14293: LIST
14294: ST_TO_ADDR
14295: GO 14670
14297: LD_INT 18
14299: DOUBLE
14300: EQUAL
14301: IFTRUE 14305
14303: GO 14441
14305: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
14306: LD_ADDR_VAR 0 1
14310: PUSH
14311: LD_INT 2
14313: PUSH
14314: LD_INT 4
14316: PUSH
14317: LD_INT 5
14319: PUSH
14320: LD_INT 7
14322: PUSH
14323: LD_INT 11
14325: PUSH
14326: LD_INT 12
14328: PUSH
14329: LD_INT 15
14331: PUSH
14332: LD_INT 16
14334: PUSH
14335: LD_INT 20
14337: PUSH
14338: LD_INT 21
14340: PUSH
14341: LD_INT 22
14343: PUSH
14344: LD_INT 23
14346: PUSH
14347: LD_INT 25
14349: PUSH
14350: LD_INT 26
14352: PUSH
14353: LD_INT 30
14355: PUSH
14356: LD_INT 31
14358: PUSH
14359: LD_INT 32
14361: PUSH
14362: LD_INT 33
14364: PUSH
14365: LD_INT 34
14367: PUSH
14368: LD_INT 35
14370: PUSH
14371: LD_INT 36
14373: PUSH
14374: EMPTY
14375: LIST
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: LIST
14383: LIST
14384: LIST
14385: LIST
14386: LIST
14387: LIST
14388: LIST
14389: LIST
14390: LIST
14391: LIST
14392: LIST
14393: LIST
14394: LIST
14395: LIST
14396: PUSH
14397: LD_INT 101
14399: PUSH
14400: LD_INT 102
14402: PUSH
14403: LD_INT 103
14405: PUSH
14406: LD_INT 106
14408: PUSH
14409: LD_INT 108
14411: PUSH
14412: LD_INT 112
14414: PUSH
14415: LD_INT 113
14417: PUSH
14418: LD_INT 114
14420: PUSH
14421: LD_INT 115
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: LIST
14428: LIST
14429: LIST
14430: LIST
14431: LIST
14432: LIST
14433: LIST
14434: PUSH
14435: EMPTY
14436: LIST
14437: LIST
14438: ST_TO_ADDR
14439: GO 14670
14441: LD_INT 19
14443: DOUBLE
14444: EQUAL
14445: IFTRUE 14449
14447: GO 14669
14449: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
14450: LD_ADDR_VAR 0 1
14454: PUSH
14455: LD_INT 1
14457: PUSH
14458: LD_INT 2
14460: PUSH
14461: LD_INT 3
14463: PUSH
14464: LD_INT 4
14466: PUSH
14467: LD_INT 5
14469: PUSH
14470: LD_INT 6
14472: PUSH
14473: LD_INT 7
14475: PUSH
14476: LD_INT 8
14478: PUSH
14479: LD_INT 9
14481: PUSH
14482: LD_INT 10
14484: PUSH
14485: LD_INT 11
14487: PUSH
14488: LD_INT 12
14490: PUSH
14491: LD_INT 13
14493: PUSH
14494: LD_INT 14
14496: PUSH
14497: LD_INT 15
14499: PUSH
14500: LD_INT 16
14502: PUSH
14503: LD_INT 17
14505: PUSH
14506: LD_INT 18
14508: PUSH
14509: LD_INT 19
14511: PUSH
14512: LD_INT 20
14514: PUSH
14515: LD_INT 21
14517: PUSH
14518: LD_INT 22
14520: PUSH
14521: LD_INT 23
14523: PUSH
14524: LD_INT 24
14526: PUSH
14527: LD_INT 25
14529: PUSH
14530: LD_INT 26
14532: PUSH
14533: LD_INT 27
14535: PUSH
14536: LD_INT 28
14538: PUSH
14539: LD_INT 29
14541: PUSH
14542: LD_INT 30
14544: PUSH
14545: LD_INT 31
14547: PUSH
14548: LD_INT 32
14550: PUSH
14551: LD_INT 33
14553: PUSH
14554: LD_INT 34
14556: PUSH
14557: LD_INT 35
14559: PUSH
14560: LD_INT 36
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: LIST
14598: LIST
14599: LIST
14600: PUSH
14601: LD_INT 101
14603: PUSH
14604: LD_INT 102
14606: PUSH
14607: LD_INT 103
14609: PUSH
14610: LD_INT 104
14612: PUSH
14613: LD_INT 105
14615: PUSH
14616: LD_INT 106
14618: PUSH
14619: LD_INT 107
14621: PUSH
14622: LD_INT 108
14624: PUSH
14625: LD_INT 109
14627: PUSH
14628: LD_INT 110
14630: PUSH
14631: LD_INT 111
14633: PUSH
14634: LD_INT 112
14636: PUSH
14637: LD_INT 113
14639: PUSH
14640: LD_INT 114
14642: PUSH
14643: LD_INT 115
14645: PUSH
14646: EMPTY
14647: LIST
14648: LIST
14649: LIST
14650: LIST
14651: LIST
14652: LIST
14653: LIST
14654: LIST
14655: LIST
14656: LIST
14657: LIST
14658: LIST
14659: LIST
14660: LIST
14661: LIST
14662: PUSH
14663: EMPTY
14664: LIST
14665: LIST
14666: ST_TO_ADDR
14667: GO 14670
14669: POP
// end else
14670: GO 14889
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
14672: LD_ADDR_VAR 0 1
14676: PUSH
14677: LD_INT 1
14679: PUSH
14680: LD_INT 2
14682: PUSH
14683: LD_INT 3
14685: PUSH
14686: LD_INT 4
14688: PUSH
14689: LD_INT 5
14691: PUSH
14692: LD_INT 6
14694: PUSH
14695: LD_INT 7
14697: PUSH
14698: LD_INT 8
14700: PUSH
14701: LD_INT 9
14703: PUSH
14704: LD_INT 10
14706: PUSH
14707: LD_INT 11
14709: PUSH
14710: LD_INT 12
14712: PUSH
14713: LD_INT 13
14715: PUSH
14716: LD_INT 14
14718: PUSH
14719: LD_INT 15
14721: PUSH
14722: LD_INT 16
14724: PUSH
14725: LD_INT 17
14727: PUSH
14728: LD_INT 18
14730: PUSH
14731: LD_INT 19
14733: PUSH
14734: LD_INT 20
14736: PUSH
14737: LD_INT 21
14739: PUSH
14740: LD_INT 22
14742: PUSH
14743: LD_INT 23
14745: PUSH
14746: LD_INT 24
14748: PUSH
14749: LD_INT 25
14751: PUSH
14752: LD_INT 26
14754: PUSH
14755: LD_INT 27
14757: PUSH
14758: LD_INT 28
14760: PUSH
14761: LD_INT 29
14763: PUSH
14764: LD_INT 30
14766: PUSH
14767: LD_INT 31
14769: PUSH
14770: LD_INT 32
14772: PUSH
14773: LD_INT 33
14775: PUSH
14776: LD_INT 34
14778: PUSH
14779: LD_INT 35
14781: PUSH
14782: LD_INT 36
14784: PUSH
14785: EMPTY
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: LIST
14795: LIST
14796: LIST
14797: LIST
14798: LIST
14799: LIST
14800: LIST
14801: LIST
14802: LIST
14803: LIST
14804: LIST
14805: LIST
14806: LIST
14807: LIST
14808: LIST
14809: LIST
14810: LIST
14811: LIST
14812: LIST
14813: LIST
14814: LIST
14815: LIST
14816: LIST
14817: LIST
14818: LIST
14819: LIST
14820: LIST
14821: LIST
14822: PUSH
14823: LD_INT 101
14825: PUSH
14826: LD_INT 102
14828: PUSH
14829: LD_INT 103
14831: PUSH
14832: LD_INT 104
14834: PUSH
14835: LD_INT 105
14837: PUSH
14838: LD_INT 106
14840: PUSH
14841: LD_INT 107
14843: PUSH
14844: LD_INT 108
14846: PUSH
14847: LD_INT 109
14849: PUSH
14850: LD_INT 110
14852: PUSH
14853: LD_INT 111
14855: PUSH
14856: LD_INT 112
14858: PUSH
14859: LD_INT 113
14861: PUSH
14862: LD_INT 114
14864: PUSH
14865: LD_INT 115
14867: PUSH
14868: EMPTY
14869: LIST
14870: LIST
14871: LIST
14872: LIST
14873: LIST
14874: LIST
14875: LIST
14876: LIST
14877: LIST
14878: LIST
14879: LIST
14880: LIST
14881: LIST
14882: LIST
14883: LIST
14884: PUSH
14885: EMPTY
14886: LIST
14887: LIST
14888: ST_TO_ADDR
// if result then
14889: LD_VAR 0 1
14893: IFFALSE 15182
// begin normal :=  ;
14895: LD_ADDR_VAR 0 3
14899: PUSH
14900: LD_STRING 
14902: ST_TO_ADDR
// hardcore :=  ;
14903: LD_ADDR_VAR 0 4
14907: PUSH
14908: LD_STRING 
14910: ST_TO_ADDR
// for i = 1 to normalCounter do
14911: LD_ADDR_VAR 0 5
14915: PUSH
14916: DOUBLE
14917: LD_INT 1
14919: DEC
14920: ST_TO_ADDR
14921: LD_EXP 41
14925: PUSH
14926: FOR_TO
14927: IFFALSE 15028
// begin tmp := 0 ;
14929: LD_ADDR_VAR 0 2
14933: PUSH
14934: LD_STRING 0
14936: ST_TO_ADDR
// if result [ 1 ] then
14937: LD_VAR 0 1
14941: PUSH
14942: LD_INT 1
14944: ARRAY
14945: IFFALSE 15010
// if result [ 1 ] [ 1 ] = i then
14947: LD_VAR 0 1
14951: PUSH
14952: LD_INT 1
14954: ARRAY
14955: PUSH
14956: LD_INT 1
14958: ARRAY
14959: PUSH
14960: LD_VAR 0 5
14964: EQUAL
14965: IFFALSE 15010
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
14967: LD_ADDR_VAR 0 1
14971: PUSH
14972: LD_VAR 0 1
14976: PPUSH
14977: LD_INT 1
14979: PPUSH
14980: LD_VAR 0 1
14984: PUSH
14985: LD_INT 1
14987: ARRAY
14988: PPUSH
14989: LD_INT 1
14991: PPUSH
14992: CALL_OW 3
14996: PPUSH
14997: CALL_OW 1
15001: ST_TO_ADDR
// tmp := 1 ;
15002: LD_ADDR_VAR 0 2
15006: PUSH
15007: LD_STRING 1
15009: ST_TO_ADDR
// end ; normal := normal & tmp ;
15010: LD_ADDR_VAR 0 3
15014: PUSH
15015: LD_VAR 0 3
15019: PUSH
15020: LD_VAR 0 2
15024: STR
15025: ST_TO_ADDR
// end ;
15026: GO 14926
15028: POP
15029: POP
// for i = 1 to hardcoreCounter do
15030: LD_ADDR_VAR 0 5
15034: PUSH
15035: DOUBLE
15036: LD_INT 1
15038: DEC
15039: ST_TO_ADDR
15040: LD_EXP 42
15044: PUSH
15045: FOR_TO
15046: IFFALSE 15151
// begin tmp := 0 ;
15048: LD_ADDR_VAR 0 2
15052: PUSH
15053: LD_STRING 0
15055: ST_TO_ADDR
// if result [ 2 ] then
15056: LD_VAR 0 1
15060: PUSH
15061: LD_INT 2
15063: ARRAY
15064: IFFALSE 15133
// if result [ 2 ] [ 1 ] = 100 + i then
15066: LD_VAR 0 1
15070: PUSH
15071: LD_INT 2
15073: ARRAY
15074: PUSH
15075: LD_INT 1
15077: ARRAY
15078: PUSH
15079: LD_INT 100
15081: PUSH
15082: LD_VAR 0 5
15086: PLUS
15087: EQUAL
15088: IFFALSE 15133
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
15090: LD_ADDR_VAR 0 1
15094: PUSH
15095: LD_VAR 0 1
15099: PPUSH
15100: LD_INT 2
15102: PPUSH
15103: LD_VAR 0 1
15107: PUSH
15108: LD_INT 2
15110: ARRAY
15111: PPUSH
15112: LD_INT 1
15114: PPUSH
15115: CALL_OW 3
15119: PPUSH
15120: CALL_OW 1
15124: ST_TO_ADDR
// tmp := 1 ;
15125: LD_ADDR_VAR 0 2
15129: PUSH
15130: LD_STRING 1
15132: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
15133: LD_ADDR_VAR 0 4
15137: PUSH
15138: LD_VAR 0 4
15142: PUSH
15143: LD_VAR 0 2
15147: STR
15148: ST_TO_ADDR
// end ;
15149: GO 15045
15151: POP
15152: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
15153: LD_STRING getStreamItemsFromMission("
15155: PUSH
15156: LD_VAR 0 3
15160: STR
15161: PUSH
15162: LD_STRING ","
15164: STR
15165: PUSH
15166: LD_VAR 0 4
15170: STR
15171: PUSH
15172: LD_STRING ")
15174: STR
15175: PPUSH
15176: CALL_OW 559
// end else
15180: GO 15189
// ToLua ( getStreamItemsFromMission("","") ) ;
15182: LD_STRING getStreamItemsFromMission("","")
15184: PPUSH
15185: CALL_OW 559
// end ;
15189: LD_VAR 0 1
15193: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
15194: LD_VAR 0 2
15198: PUSH
15199: LD_INT 100
15201: EQUAL
15202: IFFALSE 16151
// begin if not StreamModeActive then
15204: LD_EXP 40
15208: NOT
15209: IFFALSE 15219
// StreamModeActive := true ;
15211: LD_ADDR_EXP 40
15215: PUSH
15216: LD_INT 1
15218: ST_TO_ADDR
// if p3 = 0 then
15219: LD_VAR 0 3
15223: PUSH
15224: LD_INT 0
15226: EQUAL
15227: IFFALSE 15233
// InitStreamMode ;
15229: CALL 11272 0 0
// if p3 = 1 then
15233: LD_VAR 0 3
15237: PUSH
15238: LD_INT 1
15240: EQUAL
15241: IFFALSE 15251
// sRocket := true ;
15243: LD_ADDR_EXP 45
15247: PUSH
15248: LD_INT 1
15250: ST_TO_ADDR
// if p3 = 2 then
15251: LD_VAR 0 3
15255: PUSH
15256: LD_INT 2
15258: EQUAL
15259: IFFALSE 15269
// sSpeed := true ;
15261: LD_ADDR_EXP 44
15265: PUSH
15266: LD_INT 1
15268: ST_TO_ADDR
// if p3 = 3 then
15269: LD_VAR 0 3
15273: PUSH
15274: LD_INT 3
15276: EQUAL
15277: IFFALSE 15287
// sEngine := true ;
15279: LD_ADDR_EXP 46
15283: PUSH
15284: LD_INT 1
15286: ST_TO_ADDR
// if p3 = 4 then
15287: LD_VAR 0 3
15291: PUSH
15292: LD_INT 4
15294: EQUAL
15295: IFFALSE 15305
// sSpec := true ;
15297: LD_ADDR_EXP 43
15301: PUSH
15302: LD_INT 1
15304: ST_TO_ADDR
// if p3 = 5 then
15305: LD_VAR 0 3
15309: PUSH
15310: LD_INT 5
15312: EQUAL
15313: IFFALSE 15323
// sLevel := true ;
15315: LD_ADDR_EXP 47
15319: PUSH
15320: LD_INT 1
15322: ST_TO_ADDR
// if p3 = 6 then
15323: LD_VAR 0 3
15327: PUSH
15328: LD_INT 6
15330: EQUAL
15331: IFFALSE 15341
// sArmoury := true ;
15333: LD_ADDR_EXP 48
15337: PUSH
15338: LD_INT 1
15340: ST_TO_ADDR
// if p3 = 7 then
15341: LD_VAR 0 3
15345: PUSH
15346: LD_INT 7
15348: EQUAL
15349: IFFALSE 15359
// sRadar := true ;
15351: LD_ADDR_EXP 49
15355: PUSH
15356: LD_INT 1
15358: ST_TO_ADDR
// if p3 = 8 then
15359: LD_VAR 0 3
15363: PUSH
15364: LD_INT 8
15366: EQUAL
15367: IFFALSE 15377
// sBunker := true ;
15369: LD_ADDR_EXP 50
15373: PUSH
15374: LD_INT 1
15376: ST_TO_ADDR
// if p3 = 9 then
15377: LD_VAR 0 3
15381: PUSH
15382: LD_INT 9
15384: EQUAL
15385: IFFALSE 15395
// sHack := true ;
15387: LD_ADDR_EXP 51
15391: PUSH
15392: LD_INT 1
15394: ST_TO_ADDR
// if p3 = 10 then
15395: LD_VAR 0 3
15399: PUSH
15400: LD_INT 10
15402: EQUAL
15403: IFFALSE 15413
// sFire := true ;
15405: LD_ADDR_EXP 52
15409: PUSH
15410: LD_INT 1
15412: ST_TO_ADDR
// if p3 = 11 then
15413: LD_VAR 0 3
15417: PUSH
15418: LD_INT 11
15420: EQUAL
15421: IFFALSE 15431
// sRefresh := true ;
15423: LD_ADDR_EXP 53
15427: PUSH
15428: LD_INT 1
15430: ST_TO_ADDR
// if p3 = 12 then
15431: LD_VAR 0 3
15435: PUSH
15436: LD_INT 12
15438: EQUAL
15439: IFFALSE 15449
// sExp := true ;
15441: LD_ADDR_EXP 54
15445: PUSH
15446: LD_INT 1
15448: ST_TO_ADDR
// if p3 = 13 then
15449: LD_VAR 0 3
15453: PUSH
15454: LD_INT 13
15456: EQUAL
15457: IFFALSE 15467
// sDepot := true ;
15459: LD_ADDR_EXP 55
15463: PUSH
15464: LD_INT 1
15466: ST_TO_ADDR
// if p3 = 14 then
15467: LD_VAR 0 3
15471: PUSH
15472: LD_INT 14
15474: EQUAL
15475: IFFALSE 15485
// sFlag := true ;
15477: LD_ADDR_EXP 56
15481: PUSH
15482: LD_INT 1
15484: ST_TO_ADDR
// if p3 = 15 then
15485: LD_VAR 0 3
15489: PUSH
15490: LD_INT 15
15492: EQUAL
15493: IFFALSE 15503
// sKamikadze := true ;
15495: LD_ADDR_EXP 64
15499: PUSH
15500: LD_INT 1
15502: ST_TO_ADDR
// if p3 = 16 then
15503: LD_VAR 0 3
15507: PUSH
15508: LD_INT 16
15510: EQUAL
15511: IFFALSE 15521
// sTroll := true ;
15513: LD_ADDR_EXP 65
15517: PUSH
15518: LD_INT 1
15520: ST_TO_ADDR
// if p3 = 17 then
15521: LD_VAR 0 3
15525: PUSH
15526: LD_INT 17
15528: EQUAL
15529: IFFALSE 15539
// sSlow := true ;
15531: LD_ADDR_EXP 66
15535: PUSH
15536: LD_INT 1
15538: ST_TO_ADDR
// if p3 = 18 then
15539: LD_VAR 0 3
15543: PUSH
15544: LD_INT 18
15546: EQUAL
15547: IFFALSE 15557
// sLack := true ;
15549: LD_ADDR_EXP 67
15553: PUSH
15554: LD_INT 1
15556: ST_TO_ADDR
// if p3 = 19 then
15557: LD_VAR 0 3
15561: PUSH
15562: LD_INT 19
15564: EQUAL
15565: IFFALSE 15575
// sTank := true ;
15567: LD_ADDR_EXP 69
15571: PUSH
15572: LD_INT 1
15574: ST_TO_ADDR
// if p3 = 20 then
15575: LD_VAR 0 3
15579: PUSH
15580: LD_INT 20
15582: EQUAL
15583: IFFALSE 15593
// sRemote := true ;
15585: LD_ADDR_EXP 70
15589: PUSH
15590: LD_INT 1
15592: ST_TO_ADDR
// if p3 = 21 then
15593: LD_VAR 0 3
15597: PUSH
15598: LD_INT 21
15600: EQUAL
15601: IFFALSE 15611
// sPowell := true ;
15603: LD_ADDR_EXP 71
15607: PUSH
15608: LD_INT 1
15610: ST_TO_ADDR
// if p3 = 22 then
15611: LD_VAR 0 3
15615: PUSH
15616: LD_INT 22
15618: EQUAL
15619: IFFALSE 15629
// sTeleport := true ;
15621: LD_ADDR_EXP 74
15625: PUSH
15626: LD_INT 1
15628: ST_TO_ADDR
// if p3 = 23 then
15629: LD_VAR 0 3
15633: PUSH
15634: LD_INT 23
15636: EQUAL
15637: IFFALSE 15647
// sOilTower := true ;
15639: LD_ADDR_EXP 76
15643: PUSH
15644: LD_INT 1
15646: ST_TO_ADDR
// if p3 = 24 then
15647: LD_VAR 0 3
15651: PUSH
15652: LD_INT 24
15654: EQUAL
15655: IFFALSE 15665
// sShovel := true ;
15657: LD_ADDR_EXP 77
15661: PUSH
15662: LD_INT 1
15664: ST_TO_ADDR
// if p3 = 25 then
15665: LD_VAR 0 3
15669: PUSH
15670: LD_INT 25
15672: EQUAL
15673: IFFALSE 15683
// sSheik := true ;
15675: LD_ADDR_EXP 78
15679: PUSH
15680: LD_INT 1
15682: ST_TO_ADDR
// if p3 = 26 then
15683: LD_VAR 0 3
15687: PUSH
15688: LD_INT 26
15690: EQUAL
15691: IFFALSE 15701
// sEarthquake := true ;
15693: LD_ADDR_EXP 80
15697: PUSH
15698: LD_INT 1
15700: ST_TO_ADDR
// if p3 = 27 then
15701: LD_VAR 0 3
15705: PUSH
15706: LD_INT 27
15708: EQUAL
15709: IFFALSE 15719
// sAI := true ;
15711: LD_ADDR_EXP 81
15715: PUSH
15716: LD_INT 1
15718: ST_TO_ADDR
// if p3 = 28 then
15719: LD_VAR 0 3
15723: PUSH
15724: LD_INT 28
15726: EQUAL
15727: IFFALSE 15737
// sCargo := true ;
15729: LD_ADDR_EXP 84
15733: PUSH
15734: LD_INT 1
15736: ST_TO_ADDR
// if p3 = 29 then
15737: LD_VAR 0 3
15741: PUSH
15742: LD_INT 29
15744: EQUAL
15745: IFFALSE 15755
// sDLaser := true ;
15747: LD_ADDR_EXP 85
15751: PUSH
15752: LD_INT 1
15754: ST_TO_ADDR
// if p3 = 30 then
15755: LD_VAR 0 3
15759: PUSH
15760: LD_INT 30
15762: EQUAL
15763: IFFALSE 15773
// sExchange := true ;
15765: LD_ADDR_EXP 86
15769: PUSH
15770: LD_INT 1
15772: ST_TO_ADDR
// if p3 = 31 then
15773: LD_VAR 0 3
15777: PUSH
15778: LD_INT 31
15780: EQUAL
15781: IFFALSE 15791
// sFac := true ;
15783: LD_ADDR_EXP 87
15787: PUSH
15788: LD_INT 1
15790: ST_TO_ADDR
// if p3 = 32 then
15791: LD_VAR 0 3
15795: PUSH
15796: LD_INT 32
15798: EQUAL
15799: IFFALSE 15809
// sPower := true ;
15801: LD_ADDR_EXP 88
15805: PUSH
15806: LD_INT 1
15808: ST_TO_ADDR
// if p3 = 33 then
15809: LD_VAR 0 3
15813: PUSH
15814: LD_INT 33
15816: EQUAL
15817: IFFALSE 15827
// sRandom := true ;
15819: LD_ADDR_EXP 89
15823: PUSH
15824: LD_INT 1
15826: ST_TO_ADDR
// if p3 = 34 then
15827: LD_VAR 0 3
15831: PUSH
15832: LD_INT 34
15834: EQUAL
15835: IFFALSE 15845
// sShield := true ;
15837: LD_ADDR_EXP 90
15841: PUSH
15842: LD_INT 1
15844: ST_TO_ADDR
// if p3 = 35 then
15845: LD_VAR 0 3
15849: PUSH
15850: LD_INT 35
15852: EQUAL
15853: IFFALSE 15863
// sTime := true ;
15855: LD_ADDR_EXP 91
15859: PUSH
15860: LD_INT 1
15862: ST_TO_ADDR
// if p3 = 36 then
15863: LD_VAR 0 3
15867: PUSH
15868: LD_INT 36
15870: EQUAL
15871: IFFALSE 15881
// sTools := true ;
15873: LD_ADDR_EXP 92
15877: PUSH
15878: LD_INT 1
15880: ST_TO_ADDR
// if p3 = 101 then
15881: LD_VAR 0 3
15885: PUSH
15886: LD_INT 101
15888: EQUAL
15889: IFFALSE 15899
// sSold := true ;
15891: LD_ADDR_EXP 57
15895: PUSH
15896: LD_INT 1
15898: ST_TO_ADDR
// if p3 = 102 then
15899: LD_VAR 0 3
15903: PUSH
15904: LD_INT 102
15906: EQUAL
15907: IFFALSE 15917
// sDiff := true ;
15909: LD_ADDR_EXP 58
15913: PUSH
15914: LD_INT 1
15916: ST_TO_ADDR
// if p3 = 103 then
15917: LD_VAR 0 3
15921: PUSH
15922: LD_INT 103
15924: EQUAL
15925: IFFALSE 15935
// sFog := true ;
15927: LD_ADDR_EXP 61
15931: PUSH
15932: LD_INT 1
15934: ST_TO_ADDR
// if p3 = 104 then
15935: LD_VAR 0 3
15939: PUSH
15940: LD_INT 104
15942: EQUAL
15943: IFFALSE 15953
// sReset := true ;
15945: LD_ADDR_EXP 62
15949: PUSH
15950: LD_INT 1
15952: ST_TO_ADDR
// if p3 = 105 then
15953: LD_VAR 0 3
15957: PUSH
15958: LD_INT 105
15960: EQUAL
15961: IFFALSE 15971
// sSun := true ;
15963: LD_ADDR_EXP 63
15967: PUSH
15968: LD_INT 1
15970: ST_TO_ADDR
// if p3 = 106 then
15971: LD_VAR 0 3
15975: PUSH
15976: LD_INT 106
15978: EQUAL
15979: IFFALSE 15989
// sTiger := true ;
15981: LD_ADDR_EXP 59
15985: PUSH
15986: LD_INT 1
15988: ST_TO_ADDR
// if p3 = 107 then
15989: LD_VAR 0 3
15993: PUSH
15994: LD_INT 107
15996: EQUAL
15997: IFFALSE 16007
// sBomb := true ;
15999: LD_ADDR_EXP 60
16003: PUSH
16004: LD_INT 1
16006: ST_TO_ADDR
// if p3 = 108 then
16007: LD_VAR 0 3
16011: PUSH
16012: LD_INT 108
16014: EQUAL
16015: IFFALSE 16025
// sWound := true ;
16017: LD_ADDR_EXP 68
16021: PUSH
16022: LD_INT 1
16024: ST_TO_ADDR
// if p3 = 109 then
16025: LD_VAR 0 3
16029: PUSH
16030: LD_INT 109
16032: EQUAL
16033: IFFALSE 16043
// sBetray := true ;
16035: LD_ADDR_EXP 72
16039: PUSH
16040: LD_INT 1
16042: ST_TO_ADDR
// if p3 = 110 then
16043: LD_VAR 0 3
16047: PUSH
16048: LD_INT 110
16050: EQUAL
16051: IFFALSE 16061
// sContamin := true ;
16053: LD_ADDR_EXP 73
16057: PUSH
16058: LD_INT 1
16060: ST_TO_ADDR
// if p3 = 111 then
16061: LD_VAR 0 3
16065: PUSH
16066: LD_INT 111
16068: EQUAL
16069: IFFALSE 16079
// sOil := true ;
16071: LD_ADDR_EXP 75
16075: PUSH
16076: LD_INT 1
16078: ST_TO_ADDR
// if p3 = 112 then
16079: LD_VAR 0 3
16083: PUSH
16084: LD_INT 112
16086: EQUAL
16087: IFFALSE 16097
// sStu := true ;
16089: LD_ADDR_EXP 79
16093: PUSH
16094: LD_INT 1
16096: ST_TO_ADDR
// if p3 = 113 then
16097: LD_VAR 0 3
16101: PUSH
16102: LD_INT 113
16104: EQUAL
16105: IFFALSE 16115
// sBazooka := true ;
16107: LD_ADDR_EXP 82
16111: PUSH
16112: LD_INT 1
16114: ST_TO_ADDR
// if p3 = 114 then
16115: LD_VAR 0 3
16119: PUSH
16120: LD_INT 114
16122: EQUAL
16123: IFFALSE 16133
// sMortar := true ;
16125: LD_ADDR_EXP 83
16129: PUSH
16130: LD_INT 1
16132: ST_TO_ADDR
// if p3 = 115 then
16133: LD_VAR 0 3
16137: PUSH
16138: LD_INT 115
16140: EQUAL
16141: IFFALSE 16151
// sRanger := true ;
16143: LD_ADDR_EXP 93
16147: PUSH
16148: LD_INT 1
16150: ST_TO_ADDR
// end ; end ;
16151: PPOPN 6
16153: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
16154: LD_EXP 40
16158: PUSH
16159: LD_EXP 45
16163: AND
16164: IFFALSE 16288
16166: GO 16168
16168: DISABLE
16169: LD_INT 0
16171: PPUSH
16172: PPUSH
// begin enable ;
16173: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
16174: LD_ADDR_VAR 0 2
16178: PUSH
16179: LD_INT 22
16181: PUSH
16182: LD_OWVAR 2
16186: PUSH
16187: EMPTY
16188: LIST
16189: LIST
16190: PUSH
16191: LD_INT 2
16193: PUSH
16194: LD_INT 34
16196: PUSH
16197: LD_INT 7
16199: PUSH
16200: EMPTY
16201: LIST
16202: LIST
16203: PUSH
16204: LD_INT 34
16206: PUSH
16207: LD_INT 45
16209: PUSH
16210: EMPTY
16211: LIST
16212: LIST
16213: PUSH
16214: LD_INT 34
16216: PUSH
16217: LD_INT 28
16219: PUSH
16220: EMPTY
16221: LIST
16222: LIST
16223: PUSH
16224: LD_INT 34
16226: PUSH
16227: LD_INT 47
16229: PUSH
16230: EMPTY
16231: LIST
16232: LIST
16233: PUSH
16234: EMPTY
16235: LIST
16236: LIST
16237: LIST
16238: LIST
16239: LIST
16240: PUSH
16241: EMPTY
16242: LIST
16243: LIST
16244: PPUSH
16245: CALL_OW 69
16249: ST_TO_ADDR
// if not tmp then
16250: LD_VAR 0 2
16254: NOT
16255: IFFALSE 16259
// exit ;
16257: GO 16288
// for i in tmp do
16259: LD_ADDR_VAR 0 1
16263: PUSH
16264: LD_VAR 0 2
16268: PUSH
16269: FOR_IN
16270: IFFALSE 16286
// begin SetLives ( i , 0 ) ;
16272: LD_VAR 0 1
16276: PPUSH
16277: LD_INT 0
16279: PPUSH
16280: CALL_OW 234
// end ;
16284: GO 16269
16286: POP
16287: POP
// end ;
16288: PPOPN 2
16290: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
16291: LD_EXP 40
16295: PUSH
16296: LD_EXP 46
16300: AND
16301: IFFALSE 16385
16303: GO 16305
16305: DISABLE
16306: LD_INT 0
16308: PPUSH
16309: PPUSH
// begin enable ;
16310: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
16311: LD_ADDR_VAR 0 2
16315: PUSH
16316: LD_INT 22
16318: PUSH
16319: LD_OWVAR 2
16323: PUSH
16324: EMPTY
16325: LIST
16326: LIST
16327: PUSH
16328: LD_INT 32
16330: PUSH
16331: LD_INT 3
16333: PUSH
16334: EMPTY
16335: LIST
16336: LIST
16337: PUSH
16338: EMPTY
16339: LIST
16340: LIST
16341: PPUSH
16342: CALL_OW 69
16346: ST_TO_ADDR
// if not tmp then
16347: LD_VAR 0 2
16351: NOT
16352: IFFALSE 16356
// exit ;
16354: GO 16385
// for i in tmp do
16356: LD_ADDR_VAR 0 1
16360: PUSH
16361: LD_VAR 0 2
16365: PUSH
16366: FOR_IN
16367: IFFALSE 16383
// begin SetLives ( i , 0 ) ;
16369: LD_VAR 0 1
16373: PPUSH
16374: LD_INT 0
16376: PPUSH
16377: CALL_OW 234
// end ;
16381: GO 16366
16383: POP
16384: POP
// end ;
16385: PPOPN 2
16387: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
16388: LD_EXP 40
16392: PUSH
16393: LD_EXP 43
16397: AND
16398: IFFALSE 16491
16400: GO 16402
16402: DISABLE
16403: LD_INT 0
16405: PPUSH
// begin enable ;
16406: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
16407: LD_ADDR_VAR 0 1
16411: PUSH
16412: LD_INT 22
16414: PUSH
16415: LD_OWVAR 2
16419: PUSH
16420: EMPTY
16421: LIST
16422: LIST
16423: PUSH
16424: LD_INT 2
16426: PUSH
16427: LD_INT 25
16429: PUSH
16430: LD_INT 5
16432: PUSH
16433: EMPTY
16434: LIST
16435: LIST
16436: PUSH
16437: LD_INT 25
16439: PUSH
16440: LD_INT 9
16442: PUSH
16443: EMPTY
16444: LIST
16445: LIST
16446: PUSH
16447: LD_INT 25
16449: PUSH
16450: LD_INT 8
16452: PUSH
16453: EMPTY
16454: LIST
16455: LIST
16456: PUSH
16457: EMPTY
16458: LIST
16459: LIST
16460: LIST
16461: LIST
16462: PUSH
16463: EMPTY
16464: LIST
16465: LIST
16466: PPUSH
16467: CALL_OW 69
16471: PUSH
16472: FOR_IN
16473: IFFALSE 16489
// begin SetClass ( i , 1 ) ;
16475: LD_VAR 0 1
16479: PPUSH
16480: LD_INT 1
16482: PPUSH
16483: CALL_OW 336
// end ;
16487: GO 16472
16489: POP
16490: POP
// end ;
16491: PPOPN 1
16493: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
16494: LD_EXP 40
16498: PUSH
16499: LD_EXP 44
16503: AND
16504: PUSH
16505: LD_OWVAR 65
16509: PUSH
16510: LD_INT 7
16512: LESS
16513: AND
16514: IFFALSE 16528
16516: GO 16518
16518: DISABLE
// begin enable ;
16519: ENABLE
// game_speed := 7 ;
16520: LD_ADDR_OWVAR 65
16524: PUSH
16525: LD_INT 7
16527: ST_TO_ADDR
// end ;
16528: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
16529: LD_EXP 40
16533: PUSH
16534: LD_EXP 47
16538: AND
16539: IFFALSE 16741
16541: GO 16543
16543: DISABLE
16544: LD_INT 0
16546: PPUSH
16547: PPUSH
16548: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
16549: LD_ADDR_VAR 0 3
16553: PUSH
16554: LD_INT 81
16556: PUSH
16557: LD_OWVAR 2
16561: PUSH
16562: EMPTY
16563: LIST
16564: LIST
16565: PUSH
16566: LD_INT 21
16568: PUSH
16569: LD_INT 1
16571: PUSH
16572: EMPTY
16573: LIST
16574: LIST
16575: PUSH
16576: EMPTY
16577: LIST
16578: LIST
16579: PPUSH
16580: CALL_OW 69
16584: ST_TO_ADDR
// if not tmp then
16585: LD_VAR 0 3
16589: NOT
16590: IFFALSE 16594
// exit ;
16592: GO 16741
// if tmp > 5 then
16594: LD_VAR 0 3
16598: PUSH
16599: LD_INT 5
16601: GREATER
16602: IFFALSE 16614
// k := 5 else
16604: LD_ADDR_VAR 0 2
16608: PUSH
16609: LD_INT 5
16611: ST_TO_ADDR
16612: GO 16624
// k := tmp ;
16614: LD_ADDR_VAR 0 2
16618: PUSH
16619: LD_VAR 0 3
16623: ST_TO_ADDR
// for i := 1 to k do
16624: LD_ADDR_VAR 0 1
16628: PUSH
16629: DOUBLE
16630: LD_INT 1
16632: DEC
16633: ST_TO_ADDR
16634: LD_VAR 0 2
16638: PUSH
16639: FOR_TO
16640: IFFALSE 16739
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
16642: LD_VAR 0 3
16646: PUSH
16647: LD_VAR 0 1
16651: ARRAY
16652: PPUSH
16653: LD_VAR 0 1
16657: PUSH
16658: LD_INT 4
16660: MOD
16661: PUSH
16662: LD_INT 1
16664: PLUS
16665: PPUSH
16666: CALL_OW 259
16670: PUSH
16671: LD_INT 10
16673: LESS
16674: IFFALSE 16737
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
16676: LD_VAR 0 3
16680: PUSH
16681: LD_VAR 0 1
16685: ARRAY
16686: PPUSH
16687: LD_VAR 0 1
16691: PUSH
16692: LD_INT 4
16694: MOD
16695: PUSH
16696: LD_INT 1
16698: PLUS
16699: PPUSH
16700: LD_VAR 0 3
16704: PUSH
16705: LD_VAR 0 1
16709: ARRAY
16710: PPUSH
16711: LD_VAR 0 1
16715: PUSH
16716: LD_INT 4
16718: MOD
16719: PUSH
16720: LD_INT 1
16722: PLUS
16723: PPUSH
16724: CALL_OW 259
16728: PUSH
16729: LD_INT 1
16731: PLUS
16732: PPUSH
16733: CALL_OW 237
16737: GO 16639
16739: POP
16740: POP
// end ;
16741: PPOPN 3
16743: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
16744: LD_EXP 40
16748: PUSH
16749: LD_EXP 48
16753: AND
16754: IFFALSE 16774
16756: GO 16758
16758: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
16759: LD_INT 4
16761: PPUSH
16762: LD_OWVAR 2
16766: PPUSH
16767: LD_INT 0
16769: PPUSH
16770: CALL_OW 324
16774: END
// every 0 0$1 trigger StreamModeActive and sShovel do
16775: LD_EXP 40
16779: PUSH
16780: LD_EXP 77
16784: AND
16785: IFFALSE 16805
16787: GO 16789
16789: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
16790: LD_INT 19
16792: PPUSH
16793: LD_OWVAR 2
16797: PPUSH
16798: LD_INT 0
16800: PPUSH
16801: CALL_OW 324
16805: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
16806: LD_EXP 40
16810: PUSH
16811: LD_EXP 49
16815: AND
16816: IFFALSE 16918
16818: GO 16820
16820: DISABLE
16821: LD_INT 0
16823: PPUSH
16824: PPUSH
// begin enable ;
16825: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
16826: LD_ADDR_VAR 0 2
16830: PUSH
16831: LD_INT 22
16833: PUSH
16834: LD_OWVAR 2
16838: PUSH
16839: EMPTY
16840: LIST
16841: LIST
16842: PUSH
16843: LD_INT 2
16845: PUSH
16846: LD_INT 34
16848: PUSH
16849: LD_INT 11
16851: PUSH
16852: EMPTY
16853: LIST
16854: LIST
16855: PUSH
16856: LD_INT 34
16858: PUSH
16859: LD_INT 30
16861: PUSH
16862: EMPTY
16863: LIST
16864: LIST
16865: PUSH
16866: EMPTY
16867: LIST
16868: LIST
16869: LIST
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PPUSH
16875: CALL_OW 69
16879: ST_TO_ADDR
// if not tmp then
16880: LD_VAR 0 2
16884: NOT
16885: IFFALSE 16889
// exit ;
16887: GO 16918
// for i in tmp do
16889: LD_ADDR_VAR 0 1
16893: PUSH
16894: LD_VAR 0 2
16898: PUSH
16899: FOR_IN
16900: IFFALSE 16916
// begin SetLives ( i , 0 ) ;
16902: LD_VAR 0 1
16906: PPUSH
16907: LD_INT 0
16909: PPUSH
16910: CALL_OW 234
// end ;
16914: GO 16899
16916: POP
16917: POP
// end ;
16918: PPOPN 2
16920: END
// every 0 0$1 trigger StreamModeActive and sBunker do
16921: LD_EXP 40
16925: PUSH
16926: LD_EXP 50
16930: AND
16931: IFFALSE 16951
16933: GO 16935
16935: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
16936: LD_INT 32
16938: PPUSH
16939: LD_OWVAR 2
16943: PPUSH
16944: LD_INT 0
16946: PPUSH
16947: CALL_OW 324
16951: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
16952: LD_EXP 40
16956: PUSH
16957: LD_EXP 51
16961: AND
16962: IFFALSE 17143
16964: GO 16966
16966: DISABLE
16967: LD_INT 0
16969: PPUSH
16970: PPUSH
16971: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
16972: LD_ADDR_VAR 0 2
16976: PUSH
16977: LD_INT 22
16979: PUSH
16980: LD_OWVAR 2
16984: PUSH
16985: EMPTY
16986: LIST
16987: LIST
16988: PUSH
16989: LD_INT 33
16991: PUSH
16992: LD_INT 3
16994: PUSH
16995: EMPTY
16996: LIST
16997: LIST
16998: PUSH
16999: EMPTY
17000: LIST
17001: LIST
17002: PPUSH
17003: CALL_OW 69
17007: ST_TO_ADDR
// if not tmp then
17008: LD_VAR 0 2
17012: NOT
17013: IFFALSE 17017
// exit ;
17015: GO 17143
// side := 0 ;
17017: LD_ADDR_VAR 0 3
17021: PUSH
17022: LD_INT 0
17024: ST_TO_ADDR
// for i := 1 to 8 do
17025: LD_ADDR_VAR 0 1
17029: PUSH
17030: DOUBLE
17031: LD_INT 1
17033: DEC
17034: ST_TO_ADDR
17035: LD_INT 8
17037: PUSH
17038: FOR_TO
17039: IFFALSE 17087
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
17041: LD_OWVAR 2
17045: PUSH
17046: LD_VAR 0 1
17050: NONEQUAL
17051: PUSH
17052: LD_OWVAR 2
17056: PPUSH
17057: LD_VAR 0 1
17061: PPUSH
17062: CALL_OW 81
17066: PUSH
17067: LD_INT 2
17069: EQUAL
17070: AND
17071: IFFALSE 17085
// begin side := i ;
17073: LD_ADDR_VAR 0 3
17077: PUSH
17078: LD_VAR 0 1
17082: ST_TO_ADDR
// break ;
17083: GO 17087
// end ;
17085: GO 17038
17087: POP
17088: POP
// if not side then
17089: LD_VAR 0 3
17093: NOT
17094: IFFALSE 17098
// exit ;
17096: GO 17143
// for i := 1 to tmp do
17098: LD_ADDR_VAR 0 1
17102: PUSH
17103: DOUBLE
17104: LD_INT 1
17106: DEC
17107: ST_TO_ADDR
17108: LD_VAR 0 2
17112: PUSH
17113: FOR_TO
17114: IFFALSE 17141
// if Prob ( 60 ) then
17116: LD_INT 60
17118: PPUSH
17119: CALL_OW 13
17123: IFFALSE 17139
// SetSide ( i , side ) ;
17125: LD_VAR 0 1
17129: PPUSH
17130: LD_VAR 0 3
17134: PPUSH
17135: CALL_OW 235
17139: GO 17113
17141: POP
17142: POP
// end ;
17143: PPOPN 3
17145: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
17146: LD_EXP 40
17150: PUSH
17151: LD_EXP 53
17155: AND
17156: IFFALSE 17275
17158: GO 17160
17160: DISABLE
17161: LD_INT 0
17163: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
17164: LD_ADDR_VAR 0 1
17168: PUSH
17169: LD_INT 22
17171: PUSH
17172: LD_OWVAR 2
17176: PUSH
17177: EMPTY
17178: LIST
17179: LIST
17180: PUSH
17181: LD_INT 21
17183: PUSH
17184: LD_INT 1
17186: PUSH
17187: EMPTY
17188: LIST
17189: LIST
17190: PUSH
17191: LD_INT 3
17193: PUSH
17194: LD_INT 23
17196: PUSH
17197: LD_INT 0
17199: PUSH
17200: EMPTY
17201: LIST
17202: LIST
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: LIST
17212: PPUSH
17213: CALL_OW 69
17217: PUSH
17218: FOR_IN
17219: IFFALSE 17273
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
17221: LD_VAR 0 1
17225: PPUSH
17226: CALL_OW 257
17230: PUSH
17231: LD_INT 1
17233: PUSH
17234: LD_INT 2
17236: PUSH
17237: LD_INT 3
17239: PUSH
17240: LD_INT 4
17242: PUSH
17243: EMPTY
17244: LIST
17245: LIST
17246: LIST
17247: LIST
17248: IN
17249: IFFALSE 17271
// SetClass ( un , rand ( 1 , 4 ) ) ;
17251: LD_VAR 0 1
17255: PPUSH
17256: LD_INT 1
17258: PPUSH
17259: LD_INT 4
17261: PPUSH
17262: CALL_OW 12
17266: PPUSH
17267: CALL_OW 336
17271: GO 17218
17273: POP
17274: POP
// end ;
17275: PPOPN 1
17277: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
17278: LD_EXP 40
17282: PUSH
17283: LD_EXP 52
17287: AND
17288: IFFALSE 17367
17290: GO 17292
17292: DISABLE
17293: LD_INT 0
17295: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17296: LD_ADDR_VAR 0 1
17300: PUSH
17301: LD_INT 22
17303: PUSH
17304: LD_OWVAR 2
17308: PUSH
17309: EMPTY
17310: LIST
17311: LIST
17312: PUSH
17313: LD_INT 21
17315: PUSH
17316: LD_INT 3
17318: PUSH
17319: EMPTY
17320: LIST
17321: LIST
17322: PUSH
17323: EMPTY
17324: LIST
17325: LIST
17326: PPUSH
17327: CALL_OW 69
17331: ST_TO_ADDR
// if not tmp then
17332: LD_VAR 0 1
17336: NOT
17337: IFFALSE 17341
// exit ;
17339: GO 17367
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
17341: LD_VAR 0 1
17345: PUSH
17346: LD_INT 1
17348: PPUSH
17349: LD_VAR 0 1
17353: PPUSH
17354: CALL_OW 12
17358: ARRAY
17359: PPUSH
17360: LD_INT 100
17362: PPUSH
17363: CALL_OW 234
// end ;
17367: PPOPN 1
17369: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
17370: LD_EXP 40
17374: PUSH
17375: LD_EXP 54
17379: AND
17380: IFFALSE 17478
17382: GO 17384
17384: DISABLE
17385: LD_INT 0
17387: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
17388: LD_ADDR_VAR 0 1
17392: PUSH
17393: LD_INT 22
17395: PUSH
17396: LD_OWVAR 2
17400: PUSH
17401: EMPTY
17402: LIST
17403: LIST
17404: PUSH
17405: LD_INT 21
17407: PUSH
17408: LD_INT 1
17410: PUSH
17411: EMPTY
17412: LIST
17413: LIST
17414: PUSH
17415: EMPTY
17416: LIST
17417: LIST
17418: PPUSH
17419: CALL_OW 69
17423: ST_TO_ADDR
// if not tmp then
17424: LD_VAR 0 1
17428: NOT
17429: IFFALSE 17433
// exit ;
17431: GO 17478
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
17433: LD_VAR 0 1
17437: PUSH
17438: LD_INT 1
17440: PPUSH
17441: LD_VAR 0 1
17445: PPUSH
17446: CALL_OW 12
17450: ARRAY
17451: PPUSH
17452: LD_INT 1
17454: PPUSH
17455: LD_INT 4
17457: PPUSH
17458: CALL_OW 12
17462: PPUSH
17463: LD_INT 3000
17465: PPUSH
17466: LD_INT 9000
17468: PPUSH
17469: CALL_OW 12
17473: PPUSH
17474: CALL_OW 492
// end ;
17478: PPOPN 1
17480: END
// every 0 0$1 trigger StreamModeActive and sDepot do
17481: LD_EXP 40
17485: PUSH
17486: LD_EXP 55
17490: AND
17491: IFFALSE 17511
17493: GO 17495
17495: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
17496: LD_INT 1
17498: PPUSH
17499: LD_OWVAR 2
17503: PPUSH
17504: LD_INT 0
17506: PPUSH
17507: CALL_OW 324
17511: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
17512: LD_EXP 40
17516: PUSH
17517: LD_EXP 56
17521: AND
17522: IFFALSE 17605
17524: GO 17526
17526: DISABLE
17527: LD_INT 0
17529: PPUSH
17530: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17531: LD_ADDR_VAR 0 2
17535: PUSH
17536: LD_INT 22
17538: PUSH
17539: LD_OWVAR 2
17543: PUSH
17544: EMPTY
17545: LIST
17546: LIST
17547: PUSH
17548: LD_INT 21
17550: PUSH
17551: LD_INT 3
17553: PUSH
17554: EMPTY
17555: LIST
17556: LIST
17557: PUSH
17558: EMPTY
17559: LIST
17560: LIST
17561: PPUSH
17562: CALL_OW 69
17566: ST_TO_ADDR
// if not tmp then
17567: LD_VAR 0 2
17571: NOT
17572: IFFALSE 17576
// exit ;
17574: GO 17605
// for i in tmp do
17576: LD_ADDR_VAR 0 1
17580: PUSH
17581: LD_VAR 0 2
17585: PUSH
17586: FOR_IN
17587: IFFALSE 17603
// SetBLevel ( i , 10 ) ;
17589: LD_VAR 0 1
17593: PPUSH
17594: LD_INT 10
17596: PPUSH
17597: CALL_OW 241
17601: GO 17586
17603: POP
17604: POP
// end ;
17605: PPOPN 2
17607: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
17608: LD_EXP 40
17612: PUSH
17613: LD_EXP 57
17617: AND
17618: IFFALSE 17729
17620: GO 17622
17622: DISABLE
17623: LD_INT 0
17625: PPUSH
17626: PPUSH
17627: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17628: LD_ADDR_VAR 0 3
17632: PUSH
17633: LD_INT 22
17635: PUSH
17636: LD_OWVAR 2
17640: PUSH
17641: EMPTY
17642: LIST
17643: LIST
17644: PUSH
17645: LD_INT 25
17647: PUSH
17648: LD_INT 1
17650: PUSH
17651: EMPTY
17652: LIST
17653: LIST
17654: PUSH
17655: EMPTY
17656: LIST
17657: LIST
17658: PPUSH
17659: CALL_OW 69
17663: ST_TO_ADDR
// if not tmp then
17664: LD_VAR 0 3
17668: NOT
17669: IFFALSE 17673
// exit ;
17671: GO 17729
// un := tmp [ rand ( 1 , tmp ) ] ;
17673: LD_ADDR_VAR 0 2
17677: PUSH
17678: LD_VAR 0 3
17682: PUSH
17683: LD_INT 1
17685: PPUSH
17686: LD_VAR 0 3
17690: PPUSH
17691: CALL_OW 12
17695: ARRAY
17696: ST_TO_ADDR
// if Crawls ( un ) then
17697: LD_VAR 0 2
17701: PPUSH
17702: CALL_OW 318
17706: IFFALSE 17717
// ComWalk ( un ) ;
17708: LD_VAR 0 2
17712: PPUSH
17713: CALL_OW 138
// SetClass ( un , class_sniper ) ;
17717: LD_VAR 0 2
17721: PPUSH
17722: LD_INT 5
17724: PPUSH
17725: CALL_OW 336
// end ;
17729: PPOPN 3
17731: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
17732: LD_EXP 40
17736: PUSH
17737: LD_EXP 58
17741: AND
17742: PUSH
17743: LD_OWVAR 67
17747: PUSH
17748: LD_INT 3
17750: LESS
17751: AND
17752: IFFALSE 17771
17754: GO 17756
17756: DISABLE
// Difficulty := Difficulty + 1 ;
17757: LD_ADDR_OWVAR 67
17761: PUSH
17762: LD_OWVAR 67
17766: PUSH
17767: LD_INT 1
17769: PLUS
17770: ST_TO_ADDR
17771: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
17772: LD_EXP 40
17776: PUSH
17777: LD_EXP 59
17781: AND
17782: IFFALSE 17885
17784: GO 17786
17786: DISABLE
17787: LD_INT 0
17789: PPUSH
// begin for i := 1 to 5 do
17790: LD_ADDR_VAR 0 1
17794: PUSH
17795: DOUBLE
17796: LD_INT 1
17798: DEC
17799: ST_TO_ADDR
17800: LD_INT 5
17802: PUSH
17803: FOR_TO
17804: IFFALSE 17883
// begin uc_nation := nation_nature ;
17806: LD_ADDR_OWVAR 21
17810: PUSH
17811: LD_INT 0
17813: ST_TO_ADDR
// uc_side := 0 ;
17814: LD_ADDR_OWVAR 20
17818: PUSH
17819: LD_INT 0
17821: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17822: LD_ADDR_OWVAR 29
17826: PUSH
17827: LD_INT 12
17829: PUSH
17830: LD_INT 12
17832: PUSH
17833: EMPTY
17834: LIST
17835: LIST
17836: ST_TO_ADDR
// hc_agressivity := 20 ;
17837: LD_ADDR_OWVAR 35
17841: PUSH
17842: LD_INT 20
17844: ST_TO_ADDR
// hc_class := class_tiger ;
17845: LD_ADDR_OWVAR 28
17849: PUSH
17850: LD_INT 14
17852: ST_TO_ADDR
// hc_gallery :=  ;
17853: LD_ADDR_OWVAR 33
17857: PUSH
17858: LD_STRING 
17860: ST_TO_ADDR
// hc_name :=  ;
17861: LD_ADDR_OWVAR 26
17865: PUSH
17866: LD_STRING 
17868: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
17869: CALL_OW 44
17873: PPUSH
17874: LD_INT 0
17876: PPUSH
17877: CALL_OW 51
// end ;
17881: GO 17803
17883: POP
17884: POP
// end ;
17885: PPOPN 1
17887: END
// every 0 0$1 trigger StreamModeActive and sBomb do
17888: LD_EXP 40
17892: PUSH
17893: LD_EXP 60
17897: AND
17898: IFFALSE 17907
17900: GO 17902
17902: DISABLE
// StreamSibBomb ;
17903: CALL 17908 0 0
17907: END
// export function StreamSibBomb ; var i , x , y ; begin
17908: LD_INT 0
17910: PPUSH
17911: PPUSH
17912: PPUSH
17913: PPUSH
// result := false ;
17914: LD_ADDR_VAR 0 1
17918: PUSH
17919: LD_INT 0
17921: ST_TO_ADDR
// for i := 1 to 16 do
17922: LD_ADDR_VAR 0 2
17926: PUSH
17927: DOUBLE
17928: LD_INT 1
17930: DEC
17931: ST_TO_ADDR
17932: LD_INT 16
17934: PUSH
17935: FOR_TO
17936: IFFALSE 18135
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17938: LD_ADDR_VAR 0 3
17942: PUSH
17943: LD_INT 10
17945: PUSH
17946: LD_INT 20
17948: PUSH
17949: LD_INT 30
17951: PUSH
17952: LD_INT 40
17954: PUSH
17955: LD_INT 50
17957: PUSH
17958: LD_INT 60
17960: PUSH
17961: LD_INT 70
17963: PUSH
17964: LD_INT 80
17966: PUSH
17967: LD_INT 90
17969: PUSH
17970: LD_INT 100
17972: PUSH
17973: LD_INT 110
17975: PUSH
17976: LD_INT 120
17978: PUSH
17979: LD_INT 130
17981: PUSH
17982: LD_INT 140
17984: PUSH
17985: LD_INT 150
17987: PUSH
17988: EMPTY
17989: LIST
17990: LIST
17991: LIST
17992: LIST
17993: LIST
17994: LIST
17995: LIST
17996: LIST
17997: LIST
17998: LIST
17999: LIST
18000: LIST
18001: LIST
18002: LIST
18003: LIST
18004: PUSH
18005: LD_INT 1
18007: PPUSH
18008: LD_INT 15
18010: PPUSH
18011: CALL_OW 12
18015: ARRAY
18016: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18017: LD_ADDR_VAR 0 4
18021: PUSH
18022: LD_INT 10
18024: PUSH
18025: LD_INT 20
18027: PUSH
18028: LD_INT 30
18030: PUSH
18031: LD_INT 40
18033: PUSH
18034: LD_INT 50
18036: PUSH
18037: LD_INT 60
18039: PUSH
18040: LD_INT 70
18042: PUSH
18043: LD_INT 80
18045: PUSH
18046: LD_INT 90
18048: PUSH
18049: LD_INT 100
18051: PUSH
18052: LD_INT 110
18054: PUSH
18055: LD_INT 120
18057: PUSH
18058: LD_INT 130
18060: PUSH
18061: LD_INT 140
18063: PUSH
18064: LD_INT 150
18066: PUSH
18067: EMPTY
18068: LIST
18069: LIST
18070: LIST
18071: LIST
18072: LIST
18073: LIST
18074: LIST
18075: LIST
18076: LIST
18077: LIST
18078: LIST
18079: LIST
18080: LIST
18081: LIST
18082: LIST
18083: PUSH
18084: LD_INT 1
18086: PPUSH
18087: LD_INT 15
18089: PPUSH
18090: CALL_OW 12
18094: ARRAY
18095: ST_TO_ADDR
// if ValidHex ( x , y ) then
18096: LD_VAR 0 3
18100: PPUSH
18101: LD_VAR 0 4
18105: PPUSH
18106: CALL_OW 488
18110: IFFALSE 18133
// begin result := [ x , y ] ;
18112: LD_ADDR_VAR 0 1
18116: PUSH
18117: LD_VAR 0 3
18121: PUSH
18122: LD_VAR 0 4
18126: PUSH
18127: EMPTY
18128: LIST
18129: LIST
18130: ST_TO_ADDR
// break ;
18131: GO 18135
// end ; end ;
18133: GO 17935
18135: POP
18136: POP
// if result then
18137: LD_VAR 0 1
18141: IFFALSE 18201
// begin ToLua ( playSibBomb() ) ;
18143: LD_STRING playSibBomb()
18145: PPUSH
18146: CALL_OW 559
// wait ( 0 0$14 ) ;
18150: LD_INT 490
18152: PPUSH
18153: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
18157: LD_VAR 0 1
18161: PUSH
18162: LD_INT 1
18164: ARRAY
18165: PPUSH
18166: LD_VAR 0 1
18170: PUSH
18171: LD_INT 2
18173: ARRAY
18174: PPUSH
18175: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
18179: LD_VAR 0 1
18183: PUSH
18184: LD_INT 1
18186: ARRAY
18187: PPUSH
18188: LD_VAR 0 1
18192: PUSH
18193: LD_INT 2
18195: ARRAY
18196: PPUSH
18197: CALL_OW 429
// end ; end ;
18201: LD_VAR 0 1
18205: RET
// every 0 0$1 trigger StreamModeActive and sReset do
18206: LD_EXP 40
18210: PUSH
18211: LD_EXP 62
18215: AND
18216: IFFALSE 18228
18218: GO 18220
18220: DISABLE
// YouLost (  ) ;
18221: LD_STRING 
18223: PPUSH
18224: CALL_OW 104
18228: END
// every 0 0$1 trigger StreamModeActive and sFog do
18229: LD_EXP 40
18233: PUSH
18234: LD_EXP 61
18238: AND
18239: IFFALSE 18253
18241: GO 18243
18243: DISABLE
// FogOff ( your_side ) ;
18244: LD_OWVAR 2
18248: PPUSH
18249: CALL_OW 344
18253: END
// every 0 0$1 trigger StreamModeActive and sSun do
18254: LD_EXP 40
18258: PUSH
18259: LD_EXP 63
18263: AND
18264: IFFALSE 18292
18266: GO 18268
18268: DISABLE
// begin solar_recharge_percent := 0 ;
18269: LD_ADDR_OWVAR 79
18273: PUSH
18274: LD_INT 0
18276: ST_TO_ADDR
// wait ( 5 5$00 ) ;
18277: LD_INT 10500
18279: PPUSH
18280: CALL_OW 67
// solar_recharge_percent := 100 ;
18284: LD_ADDR_OWVAR 79
18288: PUSH
18289: LD_INT 100
18291: ST_TO_ADDR
// end ;
18292: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
18293: LD_EXP 40
18297: PUSH
18298: LD_EXP 64
18302: AND
18303: IFFALSE 18542
18305: GO 18307
18307: DISABLE
18308: LD_INT 0
18310: PPUSH
18311: PPUSH
18312: PPUSH
// begin tmp := [ ] ;
18313: LD_ADDR_VAR 0 3
18317: PUSH
18318: EMPTY
18319: ST_TO_ADDR
// for i := 1 to 6 do
18320: LD_ADDR_VAR 0 1
18324: PUSH
18325: DOUBLE
18326: LD_INT 1
18328: DEC
18329: ST_TO_ADDR
18330: LD_INT 6
18332: PUSH
18333: FOR_TO
18334: IFFALSE 18439
// begin uc_nation := nation_nature ;
18336: LD_ADDR_OWVAR 21
18340: PUSH
18341: LD_INT 0
18343: ST_TO_ADDR
// uc_side := 0 ;
18344: LD_ADDR_OWVAR 20
18348: PUSH
18349: LD_INT 0
18351: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18352: LD_ADDR_OWVAR 29
18356: PUSH
18357: LD_INT 12
18359: PUSH
18360: LD_INT 12
18362: PUSH
18363: EMPTY
18364: LIST
18365: LIST
18366: ST_TO_ADDR
// hc_agressivity := 20 ;
18367: LD_ADDR_OWVAR 35
18371: PUSH
18372: LD_INT 20
18374: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
18375: LD_ADDR_OWVAR 28
18379: PUSH
18380: LD_INT 17
18382: ST_TO_ADDR
// hc_gallery :=  ;
18383: LD_ADDR_OWVAR 33
18387: PUSH
18388: LD_STRING 
18390: ST_TO_ADDR
// hc_name :=  ;
18391: LD_ADDR_OWVAR 26
18395: PUSH
18396: LD_STRING 
18398: ST_TO_ADDR
// un := CreateHuman ;
18399: LD_ADDR_VAR 0 2
18403: PUSH
18404: CALL_OW 44
18408: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
18409: LD_VAR 0 2
18413: PPUSH
18414: LD_INT 1
18416: PPUSH
18417: CALL_OW 51
// tmp := tmp ^ un ;
18421: LD_ADDR_VAR 0 3
18425: PUSH
18426: LD_VAR 0 3
18430: PUSH
18431: LD_VAR 0 2
18435: ADD
18436: ST_TO_ADDR
// end ;
18437: GO 18333
18439: POP
18440: POP
// repeat wait ( 0 0$1 ) ;
18441: LD_INT 35
18443: PPUSH
18444: CALL_OW 67
// for un in tmp do
18448: LD_ADDR_VAR 0 2
18452: PUSH
18453: LD_VAR 0 3
18457: PUSH
18458: FOR_IN
18459: IFFALSE 18533
// begin if IsDead ( un ) then
18461: LD_VAR 0 2
18465: PPUSH
18466: CALL_OW 301
18470: IFFALSE 18490
// begin tmp := tmp diff un ;
18472: LD_ADDR_VAR 0 3
18476: PUSH
18477: LD_VAR 0 3
18481: PUSH
18482: LD_VAR 0 2
18486: DIFF
18487: ST_TO_ADDR
// continue ;
18488: GO 18458
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
18490: LD_VAR 0 2
18494: PPUSH
18495: LD_INT 3
18497: PUSH
18498: LD_INT 22
18500: PUSH
18501: LD_INT 0
18503: PUSH
18504: EMPTY
18505: LIST
18506: LIST
18507: PUSH
18508: EMPTY
18509: LIST
18510: LIST
18511: PPUSH
18512: CALL_OW 69
18516: PPUSH
18517: LD_VAR 0 2
18521: PPUSH
18522: CALL_OW 74
18526: PPUSH
18527: CALL_OW 115
// end ;
18531: GO 18458
18533: POP
18534: POP
// until not tmp ;
18535: LD_VAR 0 3
18539: NOT
18540: IFFALSE 18441
// end ;
18542: PPOPN 3
18544: END
// every 0 0$1 trigger StreamModeActive and sTroll do
18545: LD_EXP 40
18549: PUSH
18550: LD_EXP 65
18554: AND
18555: IFFALSE 18609
18557: GO 18559
18559: DISABLE
// begin ToLua ( displayTroll(); ) ;
18560: LD_STRING displayTroll();
18562: PPUSH
18563: CALL_OW 559
// wait ( 3 3$00 ) ;
18567: LD_INT 6300
18569: PPUSH
18570: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18574: LD_STRING hideTroll();
18576: PPUSH
18577: CALL_OW 559
// wait ( 1 1$00 ) ;
18581: LD_INT 2100
18583: PPUSH
18584: CALL_OW 67
// ToLua ( displayTroll(); ) ;
18588: LD_STRING displayTroll();
18590: PPUSH
18591: CALL_OW 559
// wait ( 1 1$00 ) ;
18595: LD_INT 2100
18597: PPUSH
18598: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18602: LD_STRING hideTroll();
18604: PPUSH
18605: CALL_OW 559
// end ;
18609: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
18610: LD_EXP 40
18614: PUSH
18615: LD_EXP 66
18619: AND
18620: IFFALSE 18683
18622: GO 18624
18624: DISABLE
18625: LD_INT 0
18627: PPUSH
// begin p := 0 ;
18628: LD_ADDR_VAR 0 1
18632: PUSH
18633: LD_INT 0
18635: ST_TO_ADDR
// repeat game_speed := 1 ;
18636: LD_ADDR_OWVAR 65
18640: PUSH
18641: LD_INT 1
18643: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18644: LD_INT 35
18646: PPUSH
18647: CALL_OW 67
// p := p + 1 ;
18651: LD_ADDR_VAR 0 1
18655: PUSH
18656: LD_VAR 0 1
18660: PUSH
18661: LD_INT 1
18663: PLUS
18664: ST_TO_ADDR
// until p >= 60 ;
18665: LD_VAR 0 1
18669: PUSH
18670: LD_INT 60
18672: GREATEREQUAL
18673: IFFALSE 18636
// game_speed := 4 ;
18675: LD_ADDR_OWVAR 65
18679: PUSH
18680: LD_INT 4
18682: ST_TO_ADDR
// end ;
18683: PPOPN 1
18685: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
18686: LD_EXP 40
18690: PUSH
18691: LD_EXP 67
18695: AND
18696: IFFALSE 18842
18698: GO 18700
18700: DISABLE
18701: LD_INT 0
18703: PPUSH
18704: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
18705: LD_ADDR_VAR 0 1
18709: PUSH
18710: LD_INT 22
18712: PUSH
18713: LD_OWVAR 2
18717: PUSH
18718: EMPTY
18719: LIST
18720: LIST
18721: PUSH
18722: LD_INT 2
18724: PUSH
18725: LD_INT 30
18727: PUSH
18728: LD_INT 0
18730: PUSH
18731: EMPTY
18732: LIST
18733: LIST
18734: PUSH
18735: LD_INT 30
18737: PUSH
18738: LD_INT 1
18740: PUSH
18741: EMPTY
18742: LIST
18743: LIST
18744: PUSH
18745: EMPTY
18746: LIST
18747: LIST
18748: LIST
18749: PUSH
18750: EMPTY
18751: LIST
18752: LIST
18753: PPUSH
18754: CALL_OW 69
18758: ST_TO_ADDR
// if not depot then
18759: LD_VAR 0 1
18763: NOT
18764: IFFALSE 18768
// exit ;
18766: GO 18842
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
18768: LD_ADDR_VAR 0 2
18772: PUSH
18773: LD_VAR 0 1
18777: PUSH
18778: LD_INT 1
18780: PPUSH
18781: LD_VAR 0 1
18785: PPUSH
18786: CALL_OW 12
18790: ARRAY
18791: PPUSH
18792: CALL_OW 274
18796: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
18797: LD_VAR 0 2
18801: PPUSH
18802: LD_INT 1
18804: PPUSH
18805: LD_INT 0
18807: PPUSH
18808: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
18812: LD_VAR 0 2
18816: PPUSH
18817: LD_INT 2
18819: PPUSH
18820: LD_INT 0
18822: PPUSH
18823: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
18827: LD_VAR 0 2
18831: PPUSH
18832: LD_INT 3
18834: PPUSH
18835: LD_INT 0
18837: PPUSH
18838: CALL_OW 277
// end ;
18842: PPOPN 2
18844: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
18845: LD_EXP 40
18849: PUSH
18850: LD_EXP 68
18854: AND
18855: IFFALSE 18952
18857: GO 18859
18859: DISABLE
18860: LD_INT 0
18862: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18863: LD_ADDR_VAR 0 1
18867: PUSH
18868: LD_INT 22
18870: PUSH
18871: LD_OWVAR 2
18875: PUSH
18876: EMPTY
18877: LIST
18878: LIST
18879: PUSH
18880: LD_INT 21
18882: PUSH
18883: LD_INT 1
18885: PUSH
18886: EMPTY
18887: LIST
18888: LIST
18889: PUSH
18890: LD_INT 3
18892: PUSH
18893: LD_INT 23
18895: PUSH
18896: LD_INT 0
18898: PUSH
18899: EMPTY
18900: LIST
18901: LIST
18902: PUSH
18903: EMPTY
18904: LIST
18905: LIST
18906: PUSH
18907: EMPTY
18908: LIST
18909: LIST
18910: LIST
18911: PPUSH
18912: CALL_OW 69
18916: ST_TO_ADDR
// if not tmp then
18917: LD_VAR 0 1
18921: NOT
18922: IFFALSE 18926
// exit ;
18924: GO 18952
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
18926: LD_VAR 0 1
18930: PUSH
18931: LD_INT 1
18933: PPUSH
18934: LD_VAR 0 1
18938: PPUSH
18939: CALL_OW 12
18943: ARRAY
18944: PPUSH
18945: LD_INT 200
18947: PPUSH
18948: CALL_OW 234
// end ;
18952: PPOPN 1
18954: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
18955: LD_EXP 40
18959: PUSH
18960: LD_EXP 69
18964: AND
18965: IFFALSE 19044
18967: GO 18969
18969: DISABLE
18970: LD_INT 0
18972: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
18973: LD_ADDR_VAR 0 1
18977: PUSH
18978: LD_INT 22
18980: PUSH
18981: LD_OWVAR 2
18985: PUSH
18986: EMPTY
18987: LIST
18988: LIST
18989: PUSH
18990: LD_INT 21
18992: PUSH
18993: LD_INT 2
18995: PUSH
18996: EMPTY
18997: LIST
18998: LIST
18999: PUSH
19000: EMPTY
19001: LIST
19002: LIST
19003: PPUSH
19004: CALL_OW 69
19008: ST_TO_ADDR
// if not tmp then
19009: LD_VAR 0 1
19013: NOT
19014: IFFALSE 19018
// exit ;
19016: GO 19044
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
19018: LD_VAR 0 1
19022: PUSH
19023: LD_INT 1
19025: PPUSH
19026: LD_VAR 0 1
19030: PPUSH
19031: CALL_OW 12
19035: ARRAY
19036: PPUSH
19037: LD_INT 60
19039: PPUSH
19040: CALL_OW 234
// end ;
19044: PPOPN 1
19046: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
19047: LD_EXP 40
19051: PUSH
19052: LD_EXP 70
19056: AND
19057: IFFALSE 19156
19059: GO 19061
19061: DISABLE
19062: LD_INT 0
19064: PPUSH
19065: PPUSH
// begin enable ;
19066: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
19067: LD_ADDR_VAR 0 1
19071: PUSH
19072: LD_INT 22
19074: PUSH
19075: LD_OWVAR 2
19079: PUSH
19080: EMPTY
19081: LIST
19082: LIST
19083: PUSH
19084: LD_INT 61
19086: PUSH
19087: EMPTY
19088: LIST
19089: PUSH
19090: LD_INT 33
19092: PUSH
19093: LD_INT 2
19095: PUSH
19096: EMPTY
19097: LIST
19098: LIST
19099: PUSH
19100: EMPTY
19101: LIST
19102: LIST
19103: LIST
19104: PPUSH
19105: CALL_OW 69
19109: ST_TO_ADDR
// if not tmp then
19110: LD_VAR 0 1
19114: NOT
19115: IFFALSE 19119
// exit ;
19117: GO 19156
// for i in tmp do
19119: LD_ADDR_VAR 0 2
19123: PUSH
19124: LD_VAR 0 1
19128: PUSH
19129: FOR_IN
19130: IFFALSE 19154
// if IsControledBy ( i ) then
19132: LD_VAR 0 2
19136: PPUSH
19137: CALL_OW 312
19141: IFFALSE 19152
// ComUnlink ( i ) ;
19143: LD_VAR 0 2
19147: PPUSH
19148: CALL_OW 136
19152: GO 19129
19154: POP
19155: POP
// end ;
19156: PPOPN 2
19158: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
19159: LD_EXP 40
19163: PUSH
19164: LD_EXP 71
19168: AND
19169: IFFALSE 19309
19171: GO 19173
19173: DISABLE
19174: LD_INT 0
19176: PPUSH
19177: PPUSH
// begin ToLua ( displayPowell(); ) ;
19178: LD_STRING displayPowell();
19180: PPUSH
19181: CALL_OW 559
// uc_side := 0 ;
19185: LD_ADDR_OWVAR 20
19189: PUSH
19190: LD_INT 0
19192: ST_TO_ADDR
// uc_nation := 2 ;
19193: LD_ADDR_OWVAR 21
19197: PUSH
19198: LD_INT 2
19200: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
19201: LD_ADDR_OWVAR 37
19205: PUSH
19206: LD_INT 14
19208: ST_TO_ADDR
// vc_engine := engine_siberite ;
19209: LD_ADDR_OWVAR 39
19213: PUSH
19214: LD_INT 3
19216: ST_TO_ADDR
// vc_control := control_apeman ;
19217: LD_ADDR_OWVAR 38
19221: PUSH
19222: LD_INT 5
19224: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
19225: LD_ADDR_OWVAR 40
19229: PUSH
19230: LD_INT 29
19232: ST_TO_ADDR
// un := CreateVehicle ;
19233: LD_ADDR_VAR 0 2
19237: PUSH
19238: CALL_OW 45
19242: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19243: LD_VAR 0 2
19247: PPUSH
19248: LD_INT 1
19250: PPUSH
19251: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
19255: LD_INT 35
19257: PPUSH
19258: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
19262: LD_VAR 0 2
19266: PPUSH
19267: LD_INT 22
19269: PUSH
19270: LD_OWVAR 2
19274: PUSH
19275: EMPTY
19276: LIST
19277: LIST
19278: PPUSH
19279: CALL_OW 69
19283: PPUSH
19284: LD_VAR 0 2
19288: PPUSH
19289: CALL_OW 74
19293: PPUSH
19294: CALL_OW 115
// until IsDead ( un ) ;
19298: LD_VAR 0 2
19302: PPUSH
19303: CALL_OW 301
19307: IFFALSE 19255
// end ;
19309: PPOPN 2
19311: END
// every 0 0$1 trigger StreamModeActive and sStu do
19312: LD_EXP 40
19316: PUSH
19317: LD_EXP 79
19321: AND
19322: IFFALSE 19338
19324: GO 19326
19326: DISABLE
// begin ToLua ( displayStucuk(); ) ;
19327: LD_STRING displayStucuk();
19329: PPUSH
19330: CALL_OW 559
// ResetFog ;
19334: CALL_OW 335
// end ;
19338: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
19339: LD_EXP 40
19343: PUSH
19344: LD_EXP 72
19348: AND
19349: IFFALSE 19490
19351: GO 19353
19353: DISABLE
19354: LD_INT 0
19356: PPUSH
19357: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19358: LD_ADDR_VAR 0 2
19362: PUSH
19363: LD_INT 22
19365: PUSH
19366: LD_OWVAR 2
19370: PUSH
19371: EMPTY
19372: LIST
19373: LIST
19374: PUSH
19375: LD_INT 21
19377: PUSH
19378: LD_INT 1
19380: PUSH
19381: EMPTY
19382: LIST
19383: LIST
19384: PUSH
19385: EMPTY
19386: LIST
19387: LIST
19388: PPUSH
19389: CALL_OW 69
19393: ST_TO_ADDR
// if not tmp then
19394: LD_VAR 0 2
19398: NOT
19399: IFFALSE 19403
// exit ;
19401: GO 19490
// un := tmp [ rand ( 1 , tmp ) ] ;
19403: LD_ADDR_VAR 0 1
19407: PUSH
19408: LD_VAR 0 2
19412: PUSH
19413: LD_INT 1
19415: PPUSH
19416: LD_VAR 0 2
19420: PPUSH
19421: CALL_OW 12
19425: ARRAY
19426: ST_TO_ADDR
// SetSide ( un , 0 ) ;
19427: LD_VAR 0 1
19431: PPUSH
19432: LD_INT 0
19434: PPUSH
19435: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
19439: LD_VAR 0 1
19443: PPUSH
19444: LD_OWVAR 3
19448: PUSH
19449: LD_VAR 0 1
19453: DIFF
19454: PPUSH
19455: LD_VAR 0 1
19459: PPUSH
19460: CALL_OW 74
19464: PPUSH
19465: CALL_OW 115
// wait ( 0 0$20 ) ;
19469: LD_INT 700
19471: PPUSH
19472: CALL_OW 67
// SetSide ( un , your_side ) ;
19476: LD_VAR 0 1
19480: PPUSH
19481: LD_OWVAR 2
19485: PPUSH
19486: CALL_OW 235
// end ;
19490: PPOPN 2
19492: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
19493: LD_EXP 40
19497: PUSH
19498: LD_EXP 73
19502: AND
19503: IFFALSE 19609
19505: GO 19507
19507: DISABLE
19508: LD_INT 0
19510: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19511: LD_ADDR_VAR 0 1
19515: PUSH
19516: LD_INT 22
19518: PUSH
19519: LD_OWVAR 2
19523: PUSH
19524: EMPTY
19525: LIST
19526: LIST
19527: PUSH
19528: LD_INT 2
19530: PUSH
19531: LD_INT 30
19533: PUSH
19534: LD_INT 0
19536: PUSH
19537: EMPTY
19538: LIST
19539: LIST
19540: PUSH
19541: LD_INT 30
19543: PUSH
19544: LD_INT 1
19546: PUSH
19547: EMPTY
19548: LIST
19549: LIST
19550: PUSH
19551: EMPTY
19552: LIST
19553: LIST
19554: LIST
19555: PUSH
19556: EMPTY
19557: LIST
19558: LIST
19559: PPUSH
19560: CALL_OW 69
19564: ST_TO_ADDR
// if not depot then
19565: LD_VAR 0 1
19569: NOT
19570: IFFALSE 19574
// exit ;
19572: GO 19609
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
19574: LD_VAR 0 1
19578: PUSH
19579: LD_INT 1
19581: ARRAY
19582: PPUSH
19583: CALL_OW 250
19587: PPUSH
19588: LD_VAR 0 1
19592: PUSH
19593: LD_INT 1
19595: ARRAY
19596: PPUSH
19597: CALL_OW 251
19601: PPUSH
19602: LD_INT 70
19604: PPUSH
19605: CALL_OW 495
// end ;
19609: PPOPN 1
19611: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
19612: LD_EXP 40
19616: PUSH
19617: LD_EXP 74
19621: AND
19622: IFFALSE 19833
19624: GO 19626
19626: DISABLE
19627: LD_INT 0
19629: PPUSH
19630: PPUSH
19631: PPUSH
19632: PPUSH
19633: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19634: LD_ADDR_VAR 0 5
19638: PUSH
19639: LD_INT 22
19641: PUSH
19642: LD_OWVAR 2
19646: PUSH
19647: EMPTY
19648: LIST
19649: LIST
19650: PUSH
19651: LD_INT 21
19653: PUSH
19654: LD_INT 1
19656: PUSH
19657: EMPTY
19658: LIST
19659: LIST
19660: PUSH
19661: EMPTY
19662: LIST
19663: LIST
19664: PPUSH
19665: CALL_OW 69
19669: ST_TO_ADDR
// if not tmp then
19670: LD_VAR 0 5
19674: NOT
19675: IFFALSE 19679
// exit ;
19677: GO 19833
// for i in tmp do
19679: LD_ADDR_VAR 0 1
19683: PUSH
19684: LD_VAR 0 5
19688: PUSH
19689: FOR_IN
19690: IFFALSE 19831
// begin d := rand ( 0 , 5 ) ;
19692: LD_ADDR_VAR 0 4
19696: PUSH
19697: LD_INT 0
19699: PPUSH
19700: LD_INT 5
19702: PPUSH
19703: CALL_OW 12
19707: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
19708: LD_ADDR_VAR 0 2
19712: PUSH
19713: LD_VAR 0 1
19717: PPUSH
19718: CALL_OW 250
19722: PPUSH
19723: LD_VAR 0 4
19727: PPUSH
19728: LD_INT 3
19730: PPUSH
19731: LD_INT 12
19733: PPUSH
19734: CALL_OW 12
19738: PPUSH
19739: CALL_OW 272
19743: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
19744: LD_ADDR_VAR 0 3
19748: PUSH
19749: LD_VAR 0 1
19753: PPUSH
19754: CALL_OW 251
19758: PPUSH
19759: LD_VAR 0 4
19763: PPUSH
19764: LD_INT 3
19766: PPUSH
19767: LD_INT 12
19769: PPUSH
19770: CALL_OW 12
19774: PPUSH
19775: CALL_OW 273
19779: ST_TO_ADDR
// if ValidHex ( x , y ) then
19780: LD_VAR 0 2
19784: PPUSH
19785: LD_VAR 0 3
19789: PPUSH
19790: CALL_OW 488
19794: IFFALSE 19829
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
19796: LD_VAR 0 1
19800: PPUSH
19801: LD_VAR 0 2
19805: PPUSH
19806: LD_VAR 0 3
19810: PPUSH
19811: LD_INT 3
19813: PPUSH
19814: LD_INT 6
19816: PPUSH
19817: CALL_OW 12
19821: PPUSH
19822: LD_INT 1
19824: PPUSH
19825: CALL_OW 483
// end ;
19829: GO 19689
19831: POP
19832: POP
// end ;
19833: PPOPN 5
19835: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
19836: LD_EXP 40
19840: PUSH
19841: LD_EXP 75
19845: AND
19846: IFFALSE 19940
19848: GO 19850
19850: DISABLE
19851: LD_INT 0
19853: PPUSH
19854: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
19855: LD_ADDR_VAR 0 2
19859: PUSH
19860: LD_INT 22
19862: PUSH
19863: LD_OWVAR 2
19867: PUSH
19868: EMPTY
19869: LIST
19870: LIST
19871: PUSH
19872: LD_INT 32
19874: PUSH
19875: LD_INT 1
19877: PUSH
19878: EMPTY
19879: LIST
19880: LIST
19881: PUSH
19882: LD_INT 21
19884: PUSH
19885: LD_INT 2
19887: PUSH
19888: EMPTY
19889: LIST
19890: LIST
19891: PUSH
19892: EMPTY
19893: LIST
19894: LIST
19895: LIST
19896: PPUSH
19897: CALL_OW 69
19901: ST_TO_ADDR
// if not tmp then
19902: LD_VAR 0 2
19906: NOT
19907: IFFALSE 19911
// exit ;
19909: GO 19940
// for i in tmp do
19911: LD_ADDR_VAR 0 1
19915: PUSH
19916: LD_VAR 0 2
19920: PUSH
19921: FOR_IN
19922: IFFALSE 19938
// SetFuel ( i , 0 ) ;
19924: LD_VAR 0 1
19928: PPUSH
19929: LD_INT 0
19931: PPUSH
19932: CALL_OW 240
19936: GO 19921
19938: POP
19939: POP
// end ;
19940: PPOPN 2
19942: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
19943: LD_EXP 40
19947: PUSH
19948: LD_EXP 76
19952: AND
19953: IFFALSE 20019
19955: GO 19957
19957: DISABLE
19958: LD_INT 0
19960: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
19961: LD_ADDR_VAR 0 1
19965: PUSH
19966: LD_INT 22
19968: PUSH
19969: LD_OWVAR 2
19973: PUSH
19974: EMPTY
19975: LIST
19976: LIST
19977: PUSH
19978: LD_INT 30
19980: PUSH
19981: LD_INT 29
19983: PUSH
19984: EMPTY
19985: LIST
19986: LIST
19987: PUSH
19988: EMPTY
19989: LIST
19990: LIST
19991: PPUSH
19992: CALL_OW 69
19996: ST_TO_ADDR
// if not tmp then
19997: LD_VAR 0 1
20001: NOT
20002: IFFALSE 20006
// exit ;
20004: GO 20019
// DestroyUnit ( tmp [ 1 ] ) ;
20006: LD_VAR 0 1
20010: PUSH
20011: LD_INT 1
20013: ARRAY
20014: PPUSH
20015: CALL_OW 65
// end ;
20019: PPOPN 1
20021: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
20022: LD_EXP 40
20026: PUSH
20027: LD_EXP 78
20031: AND
20032: IFFALSE 20161
20034: GO 20036
20036: DISABLE
20037: LD_INT 0
20039: PPUSH
// begin uc_side := 0 ;
20040: LD_ADDR_OWVAR 20
20044: PUSH
20045: LD_INT 0
20047: ST_TO_ADDR
// uc_nation := nation_arabian ;
20048: LD_ADDR_OWVAR 21
20052: PUSH
20053: LD_INT 2
20055: ST_TO_ADDR
// hc_gallery :=  ;
20056: LD_ADDR_OWVAR 33
20060: PUSH
20061: LD_STRING 
20063: ST_TO_ADDR
// hc_name :=  ;
20064: LD_ADDR_OWVAR 26
20068: PUSH
20069: LD_STRING 
20071: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
20072: LD_INT 1
20074: PPUSH
20075: LD_INT 11
20077: PPUSH
20078: LD_INT 10
20080: PPUSH
20081: CALL_OW 380
// un := CreateHuman ;
20085: LD_ADDR_VAR 0 1
20089: PUSH
20090: CALL_OW 44
20094: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20095: LD_VAR 0 1
20099: PPUSH
20100: LD_INT 1
20102: PPUSH
20103: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
20107: LD_INT 35
20109: PPUSH
20110: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
20114: LD_VAR 0 1
20118: PPUSH
20119: LD_INT 22
20121: PUSH
20122: LD_OWVAR 2
20126: PUSH
20127: EMPTY
20128: LIST
20129: LIST
20130: PPUSH
20131: CALL_OW 69
20135: PPUSH
20136: LD_VAR 0 1
20140: PPUSH
20141: CALL_OW 74
20145: PPUSH
20146: CALL_OW 115
// until IsDead ( un ) ;
20150: LD_VAR 0 1
20154: PPUSH
20155: CALL_OW 301
20159: IFFALSE 20107
// end ;
20161: PPOPN 1
20163: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
20164: LD_EXP 40
20168: PUSH
20169: LD_EXP 80
20173: AND
20174: IFFALSE 20186
20176: GO 20178
20178: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
20179: LD_STRING earthquake(getX(game), 0, 32)
20181: PPUSH
20182: CALL_OW 559
20186: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
20187: LD_EXP 40
20191: PUSH
20192: LD_EXP 81
20196: AND
20197: IFFALSE 20288
20199: GO 20201
20201: DISABLE
20202: LD_INT 0
20204: PPUSH
// begin enable ;
20205: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
20206: LD_ADDR_VAR 0 1
20210: PUSH
20211: LD_INT 22
20213: PUSH
20214: LD_OWVAR 2
20218: PUSH
20219: EMPTY
20220: LIST
20221: LIST
20222: PUSH
20223: LD_INT 21
20225: PUSH
20226: LD_INT 2
20228: PUSH
20229: EMPTY
20230: LIST
20231: LIST
20232: PUSH
20233: LD_INT 33
20235: PUSH
20236: LD_INT 3
20238: PUSH
20239: EMPTY
20240: LIST
20241: LIST
20242: PUSH
20243: EMPTY
20244: LIST
20245: LIST
20246: LIST
20247: PPUSH
20248: CALL_OW 69
20252: ST_TO_ADDR
// if not tmp then
20253: LD_VAR 0 1
20257: NOT
20258: IFFALSE 20262
// exit ;
20260: GO 20288
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
20262: LD_VAR 0 1
20266: PUSH
20267: LD_INT 1
20269: PPUSH
20270: LD_VAR 0 1
20274: PPUSH
20275: CALL_OW 12
20279: ARRAY
20280: PPUSH
20281: LD_INT 1
20283: PPUSH
20284: CALL_OW 234
// end ;
20288: PPOPN 1
20290: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
20291: LD_EXP 40
20295: PUSH
20296: LD_EXP 82
20300: AND
20301: IFFALSE 20442
20303: GO 20305
20305: DISABLE
20306: LD_INT 0
20308: PPUSH
20309: PPUSH
20310: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20311: LD_ADDR_VAR 0 3
20315: PUSH
20316: LD_INT 22
20318: PUSH
20319: LD_OWVAR 2
20323: PUSH
20324: EMPTY
20325: LIST
20326: LIST
20327: PUSH
20328: LD_INT 25
20330: PUSH
20331: LD_INT 1
20333: PUSH
20334: EMPTY
20335: LIST
20336: LIST
20337: PUSH
20338: EMPTY
20339: LIST
20340: LIST
20341: PPUSH
20342: CALL_OW 69
20346: ST_TO_ADDR
// if not tmp then
20347: LD_VAR 0 3
20351: NOT
20352: IFFALSE 20356
// exit ;
20354: GO 20442
// un := tmp [ rand ( 1 , tmp ) ] ;
20356: LD_ADDR_VAR 0 2
20360: PUSH
20361: LD_VAR 0 3
20365: PUSH
20366: LD_INT 1
20368: PPUSH
20369: LD_VAR 0 3
20373: PPUSH
20374: CALL_OW 12
20378: ARRAY
20379: ST_TO_ADDR
// if Crawls ( un ) then
20380: LD_VAR 0 2
20384: PPUSH
20385: CALL_OW 318
20389: IFFALSE 20400
// ComWalk ( un ) ;
20391: LD_VAR 0 2
20395: PPUSH
20396: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
20400: LD_VAR 0 2
20404: PPUSH
20405: LD_INT 9
20407: PPUSH
20408: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
20412: LD_INT 28
20414: PPUSH
20415: LD_OWVAR 2
20419: PPUSH
20420: LD_INT 2
20422: PPUSH
20423: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
20427: LD_INT 29
20429: PPUSH
20430: LD_OWVAR 2
20434: PPUSH
20435: LD_INT 2
20437: PPUSH
20438: CALL_OW 322
// end ;
20442: PPOPN 3
20444: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
20445: LD_EXP 40
20449: PUSH
20450: LD_EXP 83
20454: AND
20455: IFFALSE 20566
20457: GO 20459
20459: DISABLE
20460: LD_INT 0
20462: PPUSH
20463: PPUSH
20464: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20465: LD_ADDR_VAR 0 3
20469: PUSH
20470: LD_INT 22
20472: PUSH
20473: LD_OWVAR 2
20477: PUSH
20478: EMPTY
20479: LIST
20480: LIST
20481: PUSH
20482: LD_INT 25
20484: PUSH
20485: LD_INT 1
20487: PUSH
20488: EMPTY
20489: LIST
20490: LIST
20491: PUSH
20492: EMPTY
20493: LIST
20494: LIST
20495: PPUSH
20496: CALL_OW 69
20500: ST_TO_ADDR
// if not tmp then
20501: LD_VAR 0 3
20505: NOT
20506: IFFALSE 20510
// exit ;
20508: GO 20566
// un := tmp [ rand ( 1 , tmp ) ] ;
20510: LD_ADDR_VAR 0 2
20514: PUSH
20515: LD_VAR 0 3
20519: PUSH
20520: LD_INT 1
20522: PPUSH
20523: LD_VAR 0 3
20527: PPUSH
20528: CALL_OW 12
20532: ARRAY
20533: ST_TO_ADDR
// if Crawls ( un ) then
20534: LD_VAR 0 2
20538: PPUSH
20539: CALL_OW 318
20543: IFFALSE 20554
// ComWalk ( un ) ;
20545: LD_VAR 0 2
20549: PPUSH
20550: CALL_OW 138
// SetClass ( un , class_mortar ) ;
20554: LD_VAR 0 2
20558: PPUSH
20559: LD_INT 8
20561: PPUSH
20562: CALL_OW 336
// end ;
20566: PPOPN 3
20568: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
20569: LD_EXP 40
20573: PUSH
20574: LD_EXP 84
20578: AND
20579: IFFALSE 20723
20581: GO 20583
20583: DISABLE
20584: LD_INT 0
20586: PPUSH
20587: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
20588: LD_ADDR_VAR 0 2
20592: PUSH
20593: LD_INT 22
20595: PUSH
20596: LD_OWVAR 2
20600: PUSH
20601: EMPTY
20602: LIST
20603: LIST
20604: PUSH
20605: LD_INT 21
20607: PUSH
20608: LD_INT 2
20610: PUSH
20611: EMPTY
20612: LIST
20613: LIST
20614: PUSH
20615: LD_INT 2
20617: PUSH
20618: LD_INT 34
20620: PUSH
20621: LD_INT 12
20623: PUSH
20624: EMPTY
20625: LIST
20626: LIST
20627: PUSH
20628: LD_INT 34
20630: PUSH
20631: LD_INT 51
20633: PUSH
20634: EMPTY
20635: LIST
20636: LIST
20637: PUSH
20638: LD_INT 34
20640: PUSH
20641: LD_INT 32
20643: PUSH
20644: EMPTY
20645: LIST
20646: LIST
20647: PUSH
20648: EMPTY
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: PUSH
20654: EMPTY
20655: LIST
20656: LIST
20657: LIST
20658: PPUSH
20659: CALL_OW 69
20663: ST_TO_ADDR
// if not tmp then
20664: LD_VAR 0 2
20668: NOT
20669: IFFALSE 20673
// exit ;
20671: GO 20723
// for i in tmp do
20673: LD_ADDR_VAR 0 1
20677: PUSH
20678: LD_VAR 0 2
20682: PUSH
20683: FOR_IN
20684: IFFALSE 20721
// if GetCargo ( i , mat_artifact ) = 0 then
20686: LD_VAR 0 1
20690: PPUSH
20691: LD_INT 4
20693: PPUSH
20694: CALL_OW 289
20698: PUSH
20699: LD_INT 0
20701: EQUAL
20702: IFFALSE 20719
// SetCargo ( i , mat_siberit , 100 ) ;
20704: LD_VAR 0 1
20708: PPUSH
20709: LD_INT 3
20711: PPUSH
20712: LD_INT 100
20714: PPUSH
20715: CALL_OW 290
20719: GO 20683
20721: POP
20722: POP
// end ;
20723: PPOPN 2
20725: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
20726: LD_EXP 40
20730: PUSH
20731: LD_EXP 85
20735: AND
20736: IFFALSE 20919
20738: GO 20740
20740: DISABLE
20741: LD_INT 0
20743: PPUSH
20744: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
20745: LD_ADDR_VAR 0 2
20749: PUSH
20750: LD_INT 22
20752: PUSH
20753: LD_OWVAR 2
20757: PUSH
20758: EMPTY
20759: LIST
20760: LIST
20761: PPUSH
20762: CALL_OW 69
20766: ST_TO_ADDR
// if not tmp then
20767: LD_VAR 0 2
20771: NOT
20772: IFFALSE 20776
// exit ;
20774: GO 20919
// for i := 1 to 2 do
20776: LD_ADDR_VAR 0 1
20780: PUSH
20781: DOUBLE
20782: LD_INT 1
20784: DEC
20785: ST_TO_ADDR
20786: LD_INT 2
20788: PUSH
20789: FOR_TO
20790: IFFALSE 20917
// begin uc_side := your_side ;
20792: LD_ADDR_OWVAR 20
20796: PUSH
20797: LD_OWVAR 2
20801: ST_TO_ADDR
// uc_nation := nation_american ;
20802: LD_ADDR_OWVAR 21
20806: PUSH
20807: LD_INT 1
20809: ST_TO_ADDR
// vc_chassis := us_morphling ;
20810: LD_ADDR_OWVAR 37
20814: PUSH
20815: LD_INT 5
20817: ST_TO_ADDR
// vc_engine := engine_siberite ;
20818: LD_ADDR_OWVAR 39
20822: PUSH
20823: LD_INT 3
20825: ST_TO_ADDR
// vc_control := control_computer ;
20826: LD_ADDR_OWVAR 38
20830: PUSH
20831: LD_INT 3
20833: ST_TO_ADDR
// vc_weapon := us_double_laser ;
20834: LD_ADDR_OWVAR 40
20838: PUSH
20839: LD_INT 10
20841: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
20842: LD_VAR 0 2
20846: PUSH
20847: LD_INT 1
20849: ARRAY
20850: PPUSH
20851: CALL_OW 310
20855: NOT
20856: IFFALSE 20903
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
20858: CALL_OW 45
20862: PPUSH
20863: LD_VAR 0 2
20867: PUSH
20868: LD_INT 1
20870: ARRAY
20871: PPUSH
20872: CALL_OW 250
20876: PPUSH
20877: LD_VAR 0 2
20881: PUSH
20882: LD_INT 1
20884: ARRAY
20885: PPUSH
20886: CALL_OW 251
20890: PPUSH
20891: LD_INT 12
20893: PPUSH
20894: LD_INT 1
20896: PPUSH
20897: CALL_OW 50
20901: GO 20915
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
20903: CALL_OW 45
20907: PPUSH
20908: LD_INT 1
20910: PPUSH
20911: CALL_OW 51
// end ;
20915: GO 20789
20917: POP
20918: POP
// end ;
20919: PPOPN 2
20921: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
20922: LD_EXP 40
20926: PUSH
20927: LD_EXP 86
20931: AND
20932: IFFALSE 21154
20934: GO 20936
20936: DISABLE
20937: LD_INT 0
20939: PPUSH
20940: PPUSH
20941: PPUSH
20942: PPUSH
20943: PPUSH
20944: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
20945: LD_ADDR_VAR 0 6
20949: PUSH
20950: LD_INT 22
20952: PUSH
20953: LD_OWVAR 2
20957: PUSH
20958: EMPTY
20959: LIST
20960: LIST
20961: PUSH
20962: LD_INT 21
20964: PUSH
20965: LD_INT 1
20967: PUSH
20968: EMPTY
20969: LIST
20970: LIST
20971: PUSH
20972: LD_INT 3
20974: PUSH
20975: LD_INT 23
20977: PUSH
20978: LD_INT 0
20980: PUSH
20981: EMPTY
20982: LIST
20983: LIST
20984: PUSH
20985: EMPTY
20986: LIST
20987: LIST
20988: PUSH
20989: EMPTY
20990: LIST
20991: LIST
20992: LIST
20993: PPUSH
20994: CALL_OW 69
20998: ST_TO_ADDR
// if not tmp then
20999: LD_VAR 0 6
21003: NOT
21004: IFFALSE 21008
// exit ;
21006: GO 21154
// s1 := rand ( 1 , 4 ) ;
21008: LD_ADDR_VAR 0 2
21012: PUSH
21013: LD_INT 1
21015: PPUSH
21016: LD_INT 4
21018: PPUSH
21019: CALL_OW 12
21023: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
21024: LD_ADDR_VAR 0 4
21028: PUSH
21029: LD_VAR 0 6
21033: PUSH
21034: LD_INT 1
21036: ARRAY
21037: PPUSH
21038: LD_VAR 0 2
21042: PPUSH
21043: CALL_OW 259
21047: ST_TO_ADDR
// if s1 = 1 then
21048: LD_VAR 0 2
21052: PUSH
21053: LD_INT 1
21055: EQUAL
21056: IFFALSE 21076
// s2 := rand ( 2 , 4 ) else
21058: LD_ADDR_VAR 0 3
21062: PUSH
21063: LD_INT 2
21065: PPUSH
21066: LD_INT 4
21068: PPUSH
21069: CALL_OW 12
21073: ST_TO_ADDR
21074: GO 21084
// s2 := 1 ;
21076: LD_ADDR_VAR 0 3
21080: PUSH
21081: LD_INT 1
21083: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
21084: LD_ADDR_VAR 0 5
21088: PUSH
21089: LD_VAR 0 6
21093: PUSH
21094: LD_INT 1
21096: ARRAY
21097: PPUSH
21098: LD_VAR 0 3
21102: PPUSH
21103: CALL_OW 259
21107: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
21108: LD_VAR 0 6
21112: PUSH
21113: LD_INT 1
21115: ARRAY
21116: PPUSH
21117: LD_VAR 0 2
21121: PPUSH
21122: LD_VAR 0 5
21126: PPUSH
21127: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
21131: LD_VAR 0 6
21135: PUSH
21136: LD_INT 1
21138: ARRAY
21139: PPUSH
21140: LD_VAR 0 3
21144: PPUSH
21145: LD_VAR 0 4
21149: PPUSH
21150: CALL_OW 237
// end ;
21154: PPOPN 6
21156: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
21157: LD_EXP 40
21161: PUSH
21162: LD_EXP 87
21166: AND
21167: IFFALSE 21246
21169: GO 21171
21171: DISABLE
21172: LD_INT 0
21174: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
21175: LD_ADDR_VAR 0 1
21179: PUSH
21180: LD_INT 22
21182: PUSH
21183: LD_OWVAR 2
21187: PUSH
21188: EMPTY
21189: LIST
21190: LIST
21191: PUSH
21192: LD_INT 30
21194: PUSH
21195: LD_INT 3
21197: PUSH
21198: EMPTY
21199: LIST
21200: LIST
21201: PUSH
21202: EMPTY
21203: LIST
21204: LIST
21205: PPUSH
21206: CALL_OW 69
21210: ST_TO_ADDR
// if not tmp then
21211: LD_VAR 0 1
21215: NOT
21216: IFFALSE 21220
// exit ;
21218: GO 21246
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
21220: LD_VAR 0 1
21224: PUSH
21225: LD_INT 1
21227: PPUSH
21228: LD_VAR 0 1
21232: PPUSH
21233: CALL_OW 12
21237: ARRAY
21238: PPUSH
21239: LD_INT 1
21241: PPUSH
21242: CALL_OW 234
// end ;
21246: PPOPN 1
21248: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
21249: LD_EXP 40
21253: PUSH
21254: LD_EXP 88
21258: AND
21259: IFFALSE 21371
21261: GO 21263
21263: DISABLE
21264: LD_INT 0
21266: PPUSH
21267: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
21268: LD_ADDR_VAR 0 2
21272: PUSH
21273: LD_INT 22
21275: PUSH
21276: LD_OWVAR 2
21280: PUSH
21281: EMPTY
21282: LIST
21283: LIST
21284: PUSH
21285: LD_INT 2
21287: PUSH
21288: LD_INT 30
21290: PUSH
21291: LD_INT 27
21293: PUSH
21294: EMPTY
21295: LIST
21296: LIST
21297: PUSH
21298: LD_INT 30
21300: PUSH
21301: LD_INT 26
21303: PUSH
21304: EMPTY
21305: LIST
21306: LIST
21307: PUSH
21308: LD_INT 30
21310: PUSH
21311: LD_INT 28
21313: PUSH
21314: EMPTY
21315: LIST
21316: LIST
21317: PUSH
21318: EMPTY
21319: LIST
21320: LIST
21321: LIST
21322: LIST
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: PPUSH
21328: CALL_OW 69
21332: ST_TO_ADDR
// if not tmp then
21333: LD_VAR 0 2
21337: NOT
21338: IFFALSE 21342
// exit ;
21340: GO 21371
// for i in tmp do
21342: LD_ADDR_VAR 0 1
21346: PUSH
21347: LD_VAR 0 2
21351: PUSH
21352: FOR_IN
21353: IFFALSE 21369
// SetLives ( i , 1 ) ;
21355: LD_VAR 0 1
21359: PPUSH
21360: LD_INT 1
21362: PPUSH
21363: CALL_OW 234
21367: GO 21352
21369: POP
21370: POP
// end ;
21371: PPOPN 2
21373: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
21374: LD_EXP 40
21378: PUSH
21379: LD_EXP 89
21383: AND
21384: IFFALSE 21658
21386: GO 21388
21388: DISABLE
21389: LD_INT 0
21391: PPUSH
21392: PPUSH
21393: PPUSH
// begin i := rand ( 1 , 7 ) ;
21394: LD_ADDR_VAR 0 1
21398: PUSH
21399: LD_INT 1
21401: PPUSH
21402: LD_INT 7
21404: PPUSH
21405: CALL_OW 12
21409: ST_TO_ADDR
// case i of 1 :
21410: LD_VAR 0 1
21414: PUSH
21415: LD_INT 1
21417: DOUBLE
21418: EQUAL
21419: IFTRUE 21423
21421: GO 21433
21423: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
21424: LD_STRING earthquake(getX(game), 0, 32)
21426: PPUSH
21427: CALL_OW 559
21431: GO 21658
21433: LD_INT 2
21435: DOUBLE
21436: EQUAL
21437: IFTRUE 21441
21439: GO 21455
21441: POP
// begin ToLua ( displayStucuk(); ) ;
21442: LD_STRING displayStucuk();
21444: PPUSH
21445: CALL_OW 559
// ResetFog ;
21449: CALL_OW 335
// end ; 3 :
21453: GO 21658
21455: LD_INT 3
21457: DOUBLE
21458: EQUAL
21459: IFTRUE 21463
21461: GO 21567
21463: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21464: LD_ADDR_VAR 0 2
21468: PUSH
21469: LD_INT 22
21471: PUSH
21472: LD_OWVAR 2
21476: PUSH
21477: EMPTY
21478: LIST
21479: LIST
21480: PUSH
21481: LD_INT 25
21483: PUSH
21484: LD_INT 1
21486: PUSH
21487: EMPTY
21488: LIST
21489: LIST
21490: PUSH
21491: EMPTY
21492: LIST
21493: LIST
21494: PPUSH
21495: CALL_OW 69
21499: ST_TO_ADDR
// if not tmp then
21500: LD_VAR 0 2
21504: NOT
21505: IFFALSE 21509
// exit ;
21507: GO 21658
// un := tmp [ rand ( 1 , tmp ) ] ;
21509: LD_ADDR_VAR 0 3
21513: PUSH
21514: LD_VAR 0 2
21518: PUSH
21519: LD_INT 1
21521: PPUSH
21522: LD_VAR 0 2
21526: PPUSH
21527: CALL_OW 12
21531: ARRAY
21532: ST_TO_ADDR
// if Crawls ( un ) then
21533: LD_VAR 0 3
21537: PPUSH
21538: CALL_OW 318
21542: IFFALSE 21553
// ComWalk ( un ) ;
21544: LD_VAR 0 3
21548: PPUSH
21549: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21553: LD_VAR 0 3
21557: PPUSH
21558: LD_INT 8
21560: PPUSH
21561: CALL_OW 336
// end ; 4 :
21565: GO 21658
21567: LD_INT 4
21569: DOUBLE
21570: EQUAL
21571: IFTRUE 21575
21573: GO 21636
21575: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
21576: LD_ADDR_VAR 0 2
21580: PUSH
21581: LD_INT 22
21583: PUSH
21584: LD_OWVAR 2
21588: PUSH
21589: EMPTY
21590: LIST
21591: LIST
21592: PUSH
21593: LD_INT 30
21595: PUSH
21596: LD_INT 29
21598: PUSH
21599: EMPTY
21600: LIST
21601: LIST
21602: PUSH
21603: EMPTY
21604: LIST
21605: LIST
21606: PPUSH
21607: CALL_OW 69
21611: ST_TO_ADDR
// if not tmp then
21612: LD_VAR 0 2
21616: NOT
21617: IFFALSE 21621
// exit ;
21619: GO 21658
// DestroyUnit ( tmp [ 1 ] ) ;
21621: LD_VAR 0 2
21625: PUSH
21626: LD_INT 1
21628: ARRAY
21629: PPUSH
21630: CALL_OW 65
// end ; 5 .. 7 :
21634: GO 21658
21636: LD_INT 5
21638: DOUBLE
21639: GREATEREQUAL
21640: IFFALSE 21648
21642: LD_INT 7
21644: DOUBLE
21645: LESSEQUAL
21646: IFTRUE 21650
21648: GO 21657
21650: POP
// StreamSibBomb ; end ;
21651: CALL 17908 0 0
21655: GO 21658
21657: POP
// end ;
21658: PPOPN 3
21660: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
21661: LD_EXP 40
21665: PUSH
21666: LD_EXP 90
21670: AND
21671: IFFALSE 21827
21673: GO 21675
21675: DISABLE
21676: LD_INT 0
21678: PPUSH
21679: PPUSH
21680: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
21681: LD_ADDR_VAR 0 2
21685: PUSH
21686: LD_INT 81
21688: PUSH
21689: LD_OWVAR 2
21693: PUSH
21694: EMPTY
21695: LIST
21696: LIST
21697: PUSH
21698: LD_INT 2
21700: PUSH
21701: LD_INT 21
21703: PUSH
21704: LD_INT 1
21706: PUSH
21707: EMPTY
21708: LIST
21709: LIST
21710: PUSH
21711: LD_INT 21
21713: PUSH
21714: LD_INT 2
21716: PUSH
21717: EMPTY
21718: LIST
21719: LIST
21720: PUSH
21721: EMPTY
21722: LIST
21723: LIST
21724: LIST
21725: PUSH
21726: EMPTY
21727: LIST
21728: LIST
21729: PPUSH
21730: CALL_OW 69
21734: ST_TO_ADDR
// if not tmp then
21735: LD_VAR 0 2
21739: NOT
21740: IFFALSE 21744
// exit ;
21742: GO 21827
// p := 0 ;
21744: LD_ADDR_VAR 0 3
21748: PUSH
21749: LD_INT 0
21751: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21752: LD_INT 35
21754: PPUSH
21755: CALL_OW 67
// p := p + 1 ;
21759: LD_ADDR_VAR 0 3
21763: PUSH
21764: LD_VAR 0 3
21768: PUSH
21769: LD_INT 1
21771: PLUS
21772: ST_TO_ADDR
// for i in tmp do
21773: LD_ADDR_VAR 0 1
21777: PUSH
21778: LD_VAR 0 2
21782: PUSH
21783: FOR_IN
21784: IFFALSE 21815
// if GetLives ( i ) < 1000 then
21786: LD_VAR 0 1
21790: PPUSH
21791: CALL_OW 256
21795: PUSH
21796: LD_INT 1000
21798: LESS
21799: IFFALSE 21813
// SetLives ( i , 1000 ) ;
21801: LD_VAR 0 1
21805: PPUSH
21806: LD_INT 1000
21808: PPUSH
21809: CALL_OW 234
21813: GO 21783
21815: POP
21816: POP
// until p > 20 ;
21817: LD_VAR 0 3
21821: PUSH
21822: LD_INT 20
21824: GREATER
21825: IFFALSE 21752
// end ;
21827: PPOPN 3
21829: END
// every 0 0$1 trigger StreamModeActive and sTime do
21830: LD_EXP 40
21834: PUSH
21835: LD_EXP 91
21839: AND
21840: IFFALSE 21875
21842: GO 21844
21844: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
21845: LD_INT 28
21847: PPUSH
21848: LD_OWVAR 2
21852: PPUSH
21853: LD_INT 2
21855: PPUSH
21856: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
21860: LD_INT 30
21862: PPUSH
21863: LD_OWVAR 2
21867: PPUSH
21868: LD_INT 2
21870: PPUSH
21871: CALL_OW 322
// end ;
21875: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
21876: LD_EXP 40
21880: PUSH
21881: LD_EXP 92
21885: AND
21886: IFFALSE 22007
21888: GO 21890
21890: DISABLE
21891: LD_INT 0
21893: PPUSH
21894: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21895: LD_ADDR_VAR 0 2
21899: PUSH
21900: LD_INT 22
21902: PUSH
21903: LD_OWVAR 2
21907: PUSH
21908: EMPTY
21909: LIST
21910: LIST
21911: PUSH
21912: LD_INT 21
21914: PUSH
21915: LD_INT 1
21917: PUSH
21918: EMPTY
21919: LIST
21920: LIST
21921: PUSH
21922: LD_INT 3
21924: PUSH
21925: LD_INT 23
21927: PUSH
21928: LD_INT 0
21930: PUSH
21931: EMPTY
21932: LIST
21933: LIST
21934: PUSH
21935: EMPTY
21936: LIST
21937: LIST
21938: PUSH
21939: EMPTY
21940: LIST
21941: LIST
21942: LIST
21943: PPUSH
21944: CALL_OW 69
21948: ST_TO_ADDR
// if not tmp then
21949: LD_VAR 0 2
21953: NOT
21954: IFFALSE 21958
// exit ;
21956: GO 22007
// for i in tmp do
21958: LD_ADDR_VAR 0 1
21962: PUSH
21963: LD_VAR 0 2
21967: PUSH
21968: FOR_IN
21969: IFFALSE 22005
// begin if Crawls ( i ) then
21971: LD_VAR 0 1
21975: PPUSH
21976: CALL_OW 318
21980: IFFALSE 21991
// ComWalk ( i ) ;
21982: LD_VAR 0 1
21986: PPUSH
21987: CALL_OW 138
// SetClass ( i , 2 ) ;
21991: LD_VAR 0 1
21995: PPUSH
21996: LD_INT 2
21998: PPUSH
21999: CALL_OW 336
// end ;
22003: GO 21968
22005: POP
22006: POP
// end ;
22007: PPOPN 2
22009: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
22010: LD_EXP 40
22014: PUSH
22015: LD_EXP 93
22019: AND
22020: IFFALSE 22301
22022: GO 22024
22024: DISABLE
22025: LD_INT 0
22027: PPUSH
22028: PPUSH
22029: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
22030: LD_OWVAR 2
22034: PPUSH
22035: LD_INT 9
22037: PPUSH
22038: LD_INT 1
22040: PPUSH
22041: LD_INT 1
22043: PPUSH
22044: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
22048: LD_INT 9
22050: PPUSH
22051: LD_OWVAR 2
22055: PPUSH
22056: CALL_OW 343
// uc_side := 9 ;
22060: LD_ADDR_OWVAR 20
22064: PUSH
22065: LD_INT 9
22067: ST_TO_ADDR
// uc_nation := 2 ;
22068: LD_ADDR_OWVAR 21
22072: PUSH
22073: LD_INT 2
22075: ST_TO_ADDR
// hc_name := Dark Warrior ;
22076: LD_ADDR_OWVAR 26
22080: PUSH
22081: LD_STRING Dark Warrior
22083: ST_TO_ADDR
// hc_gallery :=  ;
22084: LD_ADDR_OWVAR 33
22088: PUSH
22089: LD_STRING 
22091: ST_TO_ADDR
// hc_noskilllimit := true ;
22092: LD_ADDR_OWVAR 76
22096: PUSH
22097: LD_INT 1
22099: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
22100: LD_ADDR_OWVAR 31
22104: PUSH
22105: LD_INT 30
22107: PUSH
22108: LD_INT 30
22110: PUSH
22111: LD_INT 30
22113: PUSH
22114: LD_INT 30
22116: PUSH
22117: EMPTY
22118: LIST
22119: LIST
22120: LIST
22121: LIST
22122: ST_TO_ADDR
// un := CreateHuman ;
22123: LD_ADDR_VAR 0 3
22127: PUSH
22128: CALL_OW 44
22132: ST_TO_ADDR
// hc_noskilllimit := false ;
22133: LD_ADDR_OWVAR 76
22137: PUSH
22138: LD_INT 0
22140: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
22141: LD_VAR 0 3
22145: PPUSH
22146: LD_INT 1
22148: PPUSH
22149: CALL_OW 51
// p := 0 ;
22153: LD_ADDR_VAR 0 2
22157: PUSH
22158: LD_INT 0
22160: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22161: LD_INT 35
22163: PPUSH
22164: CALL_OW 67
// p := p + 1 ;
22168: LD_ADDR_VAR 0 2
22172: PUSH
22173: LD_VAR 0 2
22177: PUSH
22178: LD_INT 1
22180: PLUS
22181: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
22182: LD_VAR 0 3
22186: PPUSH
22187: CALL_OW 256
22191: PUSH
22192: LD_INT 1000
22194: LESS
22195: IFFALSE 22209
// SetLives ( un , 1000 ) ;
22197: LD_VAR 0 3
22201: PPUSH
22202: LD_INT 1000
22204: PPUSH
22205: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
22209: LD_VAR 0 3
22213: PPUSH
22214: LD_INT 81
22216: PUSH
22217: LD_OWVAR 2
22221: PUSH
22222: EMPTY
22223: LIST
22224: LIST
22225: PUSH
22226: LD_INT 91
22228: PUSH
22229: LD_VAR 0 3
22233: PUSH
22234: LD_INT 30
22236: PUSH
22237: EMPTY
22238: LIST
22239: LIST
22240: LIST
22241: PUSH
22242: EMPTY
22243: LIST
22244: LIST
22245: PPUSH
22246: CALL_OW 69
22250: PPUSH
22251: LD_VAR 0 3
22255: PPUSH
22256: CALL_OW 74
22260: PPUSH
22261: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
22265: LD_VAR 0 2
22269: PUSH
22270: LD_INT 60
22272: GREATER
22273: PUSH
22274: LD_VAR 0 3
22278: PPUSH
22279: CALL_OW 301
22283: OR
22284: IFFALSE 22161
// if un then
22286: LD_VAR 0 3
22290: IFFALSE 22301
// RemoveUnit ( un ) ;
22292: LD_VAR 0 3
22296: PPUSH
22297: CALL_OW 64
// end ; end_of_file
22301: PPOPN 3
22303: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
22304: LD_INT 0
22306: PPUSH
22307: PPUSH
22308: PPUSH
22309: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
22310: LD_VAR 0 1
22314: PPUSH
22315: CALL_OW 264
22319: PUSH
22320: LD_EXP 30
22324: EQUAL
22325: IFFALSE 22397
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
22327: LD_INT 68
22329: PPUSH
22330: LD_VAR 0 1
22334: PPUSH
22335: CALL_OW 255
22339: PPUSH
22340: CALL_OW 321
22344: PUSH
22345: LD_INT 2
22347: EQUAL
22348: IFFALSE 22360
// eff := 70 else
22350: LD_ADDR_VAR 0 4
22354: PUSH
22355: LD_INT 70
22357: ST_TO_ADDR
22358: GO 22368
// eff := 30 ;
22360: LD_ADDR_VAR 0 4
22364: PUSH
22365: LD_INT 30
22367: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
22368: LD_VAR 0 1
22372: PPUSH
22373: CALL_OW 250
22377: PPUSH
22378: LD_VAR 0 1
22382: PPUSH
22383: CALL_OW 251
22387: PPUSH
22388: LD_VAR 0 4
22392: PPUSH
22393: CALL_OW 495
// end ; end ;
22397: LD_VAR 0 2
22401: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
22402: LD_INT 0
22404: PPUSH
// end ;
22405: LD_VAR 0 4
22409: RET
// export function SOS_Command ( cmd ) ; begin
22410: LD_INT 0
22412: PPUSH
// end ;
22413: LD_VAR 0 2
22417: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
22418: LD_VAR 0 1
22422: PUSH
22423: LD_INT 255
22425: EQUAL
22426: PUSH
22427: LD_VAR 0 2
22431: PPUSH
22432: CALL_OW 264
22436: PUSH
22437: LD_INT 14
22439: PUSH
22440: LD_INT 53
22442: PUSH
22443: EMPTY
22444: LIST
22445: LIST
22446: IN
22447: AND
22448: PUSH
22449: LD_VAR 0 4
22453: PPUSH
22454: LD_VAR 0 5
22458: PPUSH
22459: CALL_OW 488
22463: AND
22464: IFFALSE 22488
// CutTreeXYR ( unit , x , y , 12 ) ;
22466: LD_VAR 0 2
22470: PPUSH
22471: LD_VAR 0 4
22475: PPUSH
22476: LD_VAR 0 5
22480: PPUSH
22481: LD_INT 12
22483: PPUSH
22484: CALL 22491 0 4
// end ;
22488: PPOPN 5
22490: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
22491: LD_INT 0
22493: PPUSH
22494: PPUSH
22495: PPUSH
22496: PPUSH
22497: PPUSH
22498: PPUSH
22499: PPUSH
22500: PPUSH
22501: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
22502: LD_VAR 0 1
22506: NOT
22507: PUSH
22508: LD_VAR 0 2
22512: PPUSH
22513: LD_VAR 0 3
22517: PPUSH
22518: CALL_OW 488
22522: NOT
22523: OR
22524: PUSH
22525: LD_VAR 0 4
22529: NOT
22530: OR
22531: IFFALSE 22535
// exit ;
22533: GO 22875
// list := [ ] ;
22535: LD_ADDR_VAR 0 13
22539: PUSH
22540: EMPTY
22541: ST_TO_ADDR
// if x - r < 0 then
22542: LD_VAR 0 2
22546: PUSH
22547: LD_VAR 0 4
22551: MINUS
22552: PUSH
22553: LD_INT 0
22555: LESS
22556: IFFALSE 22568
// min_x := 0 else
22558: LD_ADDR_VAR 0 7
22562: PUSH
22563: LD_INT 0
22565: ST_TO_ADDR
22566: GO 22584
// min_x := x - r ;
22568: LD_ADDR_VAR 0 7
22572: PUSH
22573: LD_VAR 0 2
22577: PUSH
22578: LD_VAR 0 4
22582: MINUS
22583: ST_TO_ADDR
// if y - r < 0 then
22584: LD_VAR 0 3
22588: PUSH
22589: LD_VAR 0 4
22593: MINUS
22594: PUSH
22595: LD_INT 0
22597: LESS
22598: IFFALSE 22610
// min_y := 0 else
22600: LD_ADDR_VAR 0 8
22604: PUSH
22605: LD_INT 0
22607: ST_TO_ADDR
22608: GO 22626
// min_y := y - r ;
22610: LD_ADDR_VAR 0 8
22614: PUSH
22615: LD_VAR 0 3
22619: PUSH
22620: LD_VAR 0 4
22624: MINUS
22625: ST_TO_ADDR
// max_x := x + r ;
22626: LD_ADDR_VAR 0 9
22630: PUSH
22631: LD_VAR 0 2
22635: PUSH
22636: LD_VAR 0 4
22640: PLUS
22641: ST_TO_ADDR
// max_y := y + r ;
22642: LD_ADDR_VAR 0 10
22646: PUSH
22647: LD_VAR 0 3
22651: PUSH
22652: LD_VAR 0 4
22656: PLUS
22657: ST_TO_ADDR
// for _x = min_x to max_x do
22658: LD_ADDR_VAR 0 11
22662: PUSH
22663: DOUBLE
22664: LD_VAR 0 7
22668: DEC
22669: ST_TO_ADDR
22670: LD_VAR 0 9
22674: PUSH
22675: FOR_TO
22676: IFFALSE 22793
// for _y = min_y to max_y do
22678: LD_ADDR_VAR 0 12
22682: PUSH
22683: DOUBLE
22684: LD_VAR 0 8
22688: DEC
22689: ST_TO_ADDR
22690: LD_VAR 0 10
22694: PUSH
22695: FOR_TO
22696: IFFALSE 22789
// begin if not ValidHex ( _x , _y ) then
22698: LD_VAR 0 11
22702: PPUSH
22703: LD_VAR 0 12
22707: PPUSH
22708: CALL_OW 488
22712: NOT
22713: IFFALSE 22717
// continue ;
22715: GO 22695
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
22717: LD_VAR 0 11
22721: PPUSH
22722: LD_VAR 0 12
22726: PPUSH
22727: CALL_OW 351
22731: PUSH
22732: LD_VAR 0 11
22736: PPUSH
22737: LD_VAR 0 12
22741: PPUSH
22742: CALL_OW 554
22746: AND
22747: IFFALSE 22787
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
22749: LD_ADDR_VAR 0 13
22753: PUSH
22754: LD_VAR 0 13
22758: PPUSH
22759: LD_VAR 0 13
22763: PUSH
22764: LD_INT 1
22766: PLUS
22767: PPUSH
22768: LD_VAR 0 11
22772: PUSH
22773: LD_VAR 0 12
22777: PUSH
22778: EMPTY
22779: LIST
22780: LIST
22781: PPUSH
22782: CALL_OW 2
22786: ST_TO_ADDR
// end ;
22787: GO 22695
22789: POP
22790: POP
22791: GO 22675
22793: POP
22794: POP
// if not list then
22795: LD_VAR 0 13
22799: NOT
22800: IFFALSE 22804
// exit ;
22802: GO 22875
// for i in list do
22804: LD_ADDR_VAR 0 6
22808: PUSH
22809: LD_VAR 0 13
22813: PUSH
22814: FOR_IN
22815: IFFALSE 22873
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
22817: LD_VAR 0 1
22821: PPUSH
22822: LD_STRING M
22824: PUSH
22825: LD_VAR 0 6
22829: PUSH
22830: LD_INT 1
22832: ARRAY
22833: PUSH
22834: LD_VAR 0 6
22838: PUSH
22839: LD_INT 2
22841: ARRAY
22842: PUSH
22843: LD_INT 0
22845: PUSH
22846: LD_INT 0
22848: PUSH
22849: LD_INT 0
22851: PUSH
22852: LD_INT 0
22854: PUSH
22855: EMPTY
22856: LIST
22857: LIST
22858: LIST
22859: LIST
22860: LIST
22861: LIST
22862: LIST
22863: PUSH
22864: EMPTY
22865: LIST
22866: PPUSH
22867: CALL_OW 447
22871: GO 22814
22873: POP
22874: POP
// end ;
22875: LD_VAR 0 5
22879: RET
