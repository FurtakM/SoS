// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 66 0 0
// PrepareAnimals ( 6 , 3 , 4 , apearea ) ;
  15: LD_INT 6
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 4
  23: PPUSH
  24: LD_INT 21
  26: PPUSH
  27: CALL 10558 0 4
// PrepareAmerican ;
  31: CALL 3957 0 0
// PrepareRussian ;
  35: CALL 277 0 0
// Action ;
  39: CALL 8298 0 0
// end ;
  43: END
// every 0 0$01 do
  44: GO 46
  46: DISABLE
// begin enable ;
  47: ENABLE
// display_strings := [ #tick , tick ] ;
  48: LD_ADDR_OWVAR 47
  52: PUSH
  53: LD_STRING #tick
  55: PUSH
  56: LD_OWVAR 1
  60: PUSH
  61: EMPTY
  62: LIST
  63: LIST
  64: ST_TO_ADDR
// end ;
  65: END
// export conv_squad , escort , medal1 , medal2 , medal3 , path , convoy_start , dest_counter ; export riv , ar_attacks , ar_force , us_force , conv_counter , crates_counter ; function Init ; begin
  66: LD_INT 0
  68: PPUSH
// medal1 := true ;
  69: LD_ADDR_EXP 3
  73: PUSH
  74: LD_INT 1
  76: ST_TO_ADDR
// medal2 := true ;
  77: LD_ADDR_EXP 4
  81: PUSH
  82: LD_INT 1
  84: ST_TO_ADDR
// medal3 := true ;
  85: LD_ADDR_EXP 5
  89: PUSH
  90: LD_INT 1
  92: ST_TO_ADDR
// path := [ pp1 , pp2 , pp3 , pp4 , conv_end ] ;
  93: LD_ADDR_EXP 6
  97: PUSH
  98: LD_INT 10
 100: PUSH
 101: LD_INT 11
 103: PUSH
 104: LD_INT 12
 106: PUSH
 107: LD_INT 13
 109: PUSH
 110: LD_INT 9
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: LIST
 118: LIST
 119: ST_TO_ADDR
// conv_squad := [ ] ;
 120: LD_ADDR_EXP 1
 124: PUSH
 125: EMPTY
 126: ST_TO_ADDR
// escort := [ ] ;
 127: LD_ADDR_EXP 2
 131: PUSH
 132: EMPTY
 133: ST_TO_ADDR
// riv := [ ] ;
 134: LD_ADDR_EXP 9
 138: PUSH
 139: EMPTY
 140: ST_TO_ADDR
// ar_force := [ ] ;
 141: LD_ADDR_EXP 11
 145: PUSH
 146: EMPTY
 147: ST_TO_ADDR
// ar_attacks := false ;
 148: LD_ADDR_EXP 10
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// us_force := [ ] ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: EMPTY
 162: ST_TO_ADDR
// convoy_start := false ;
 163: LD_ADDR_EXP 7
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// conv_counter := 0 ;
 171: LD_ADDR_EXP 13
 175: PUSH
 176: LD_INT 0
 178: ST_TO_ADDR
// dest_counter := 0 ;
 179: LD_ADDR_EXP 8
 183: PUSH
 184: LD_INT 0
 186: ST_TO_ADDR
// crates_counter := 0 0$40 ;
 187: LD_ADDR_EXP 14
 191: PUSH
 192: LD_INT 1400
 194: ST_TO_ADDR
// end ;
 195: LD_VAR 0 1
 199: RET
// every 2 2$00 do
 200: GO 202
 202: DISABLE
// begin while ( tick <= [ 47 47$00 , 44 44$00 , 41 41$00 ] [ Difficulty ] ) do
 203: LD_OWVAR 1
 207: PUSH
 208: LD_INT 98700
 210: PUSH
 211: LD_INT 92400
 213: PUSH
 214: LD_INT 86100
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: PUSH
 222: LD_OWVAR 67
 226: ARRAY
 227: LESSEQUAL
 228: IFFALSE 276
// begin Wait ( crates_counter ) ;
 230: LD_EXP 14
 234: PPUSH
 235: CALL_OW 67
// crates_counter := crates_counter + 0 0$09 ;
 239: LD_ADDR_EXP 14
 243: PUSH
 244: LD_EXP 14
 248: PUSH
 249: LD_INT 315
 251: PLUS
 252: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 5
 258: PPUSH
 259: CALL_OW 12
 263: PPUSH
 264: LD_INT 22
 266: PPUSH
 267: LD_INT 1
 269: PPUSH
 270: CALL_OW 55
// end ;
 274: GO 203
// end ; end_of_file
 276: END
// export Stolypin , Popov , Saseda ; export function PrepareRussian ; var un , force , i , c , skill , team ; begin
 277: LD_INT 0
 279: PPUSH
 280: PPUSH
 281: PPUSH
 282: PPUSH
 283: PPUSH
 284: PPUSH
 285: PPUSH
// uc_side := 6 ;
 286: LD_ADDR_OWVAR 20
 290: PUSH
 291: LD_INT 6
 293: ST_TO_ADDR
// uc_nation := 3 ;
 294: LD_ADDR_OWVAR 21
 298: PUSH
 299: LD_INT 3
 301: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
 302: LD_INT 3
 304: PPUSH
 305: LD_INT 6
 307: PPUSH
 308: CALL_OW 343
// Popov := NewCharacter ( Gaydar ) ;
 312: LD_ADDR_EXP 16
 316: PUSH
 317: LD_STRING Gaydar
 319: PPUSH
 320: CALL_OW 25
 324: ST_TO_ADDR
// uc_side := 7 ;
 325: LD_ADDR_OWVAR 20
 329: PUSH
 330: LD_INT 7
 332: ST_TO_ADDR
// hc_gallery := sandal ;
 333: LD_ADDR_OWVAR 33
 337: PUSH
 338: LD_STRING sandal
 340: ST_TO_ADDR
// hc_face_number := 9 ;
 341: LD_ADDR_OWVAR 34
 345: PUSH
 346: LD_INT 9
 348: ST_TO_ADDR
// hc_skills := [ 3 , 5 , 2 , 7 ] ;
 349: LD_ADDR_OWVAR 31
 353: PUSH
 354: LD_INT 3
 356: PUSH
 357: LD_INT 5
 359: PUSH
 360: LD_INT 2
 362: PUSH
 363: LD_INT 7
 365: PUSH
 366: EMPTY
 367: LIST
 368: LIST
 369: LIST
 370: LIST
 371: ST_TO_ADDR
// hc_sex := sex_male ;
 372: LD_ADDR_OWVAR 27
 376: PUSH
 377: LD_INT 1
 379: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 380: LD_ADDR_OWVAR 29
 384: PUSH
 385: LD_INT 10
 387: PUSH
 388: LD_INT 11
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: ST_TO_ADDR
// hc_class := 4 ;
 395: LD_ADDR_OWVAR 28
 399: PUSH
 400: LD_INT 4
 402: ST_TO_ADDR
// hc_name := Fiodor Saseda ;
 403: LD_ADDR_OWVAR 26
 407: PUSH
 408: LD_STRING Fiodor Saseda
 410: ST_TO_ADDR
// Saseda := CreateHuman ;
 411: LD_ADDR_EXP 17
 415: PUSH
 416: CALL_OW 44
 420: ST_TO_ADDR
// uc_side := 3 ;
 421: LD_ADDR_OWVAR 20
 425: PUSH
 426: LD_INT 3
 428: ST_TO_ADDR
// hc_importance := 100 ;
 429: LD_ADDR_OWVAR 32
 433: PUSH
 434: LD_INT 100
 436: ST_TO_ADDR
// hc_class := 1 ;
 437: LD_ADDR_OWVAR 28
 441: PUSH
 442: LD_INT 1
 444: ST_TO_ADDR
// hc_sex := sex_male ;
 445: LD_ADDR_OWVAR 27
 449: PUSH
 450: LD_INT 1
 452: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
 453: LD_ADDR_OWVAR 31
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 3
 463: PUSH
 464: LD_INT 4
 466: PUSH
 467: LD_INT 2
 469: PUSH
 470: EMPTY
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: ST_TO_ADDR
// hc_name := W. I. Stolypin ;
 476: LD_ADDR_OWVAR 26
 480: PUSH
 481: LD_STRING W. I. Stolypin
 483: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 484: LD_ADDR_OWVAR 29
 488: PUSH
 489: LD_INT 10
 491: PUSH
 492: LD_INT 11
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: ST_TO_ADDR
// hc_gallery := ru ;
 499: LD_ADDR_OWVAR 33
 503: PUSH
 504: LD_STRING ru
 506: ST_TO_ADDR
// hc_face_number := 15 ;
 507: LD_ADDR_OWVAR 34
 511: PUSH
 512: LD_INT 15
 514: ST_TO_ADDR
// Stolypin := CreateHuman ;
 515: LD_ADDR_EXP 15
 519: PUSH
 520: CALL_OW 44
 524: ST_TO_ADDR
// hc_importance := 0 ;
 525: LD_ADDR_OWVAR 32
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// hc_gallery :=  ;
 533: LD_ADDR_OWVAR 33
 537: PUSH
 538: LD_STRING 
 540: ST_TO_ADDR
// hc_name :=  ;
 541: LD_ADDR_OWVAR 26
 545: PUSH
 546: LD_STRING 
 548: ST_TO_ADDR
// skill := [ 6 , 5 , 5 ] [ Difficulty ] ;
 549: LD_ADDR_VAR 0 6
 553: PUSH
 554: LD_INT 6
 556: PUSH
 557: LD_INT 5
 559: PUSH
 560: LD_INT 5
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: PUSH
 568: LD_OWVAR 67
 572: ARRAY
 573: ST_TO_ADDR
// c := 1 ;
 574: LD_ADDR_VAR 0 5
 578: PUSH
 579: LD_INT 1
 581: ST_TO_ADDR
// for i = 1 to 21 do
 582: LD_ADDR_VAR 0 4
 586: PUSH
 587: DOUBLE
 588: LD_INT 1
 590: DEC
 591: ST_TO_ADDR
 592: LD_INT 21
 594: PUSH
 595: FOR_TO
 596: IFFALSE 697
// begin if i = 10 then
 598: LD_VAR 0 4
 602: PUSH
 603: LD_INT 10
 605: EQUAL
 606: IFFALSE 616
// c := 2 ;
 608: LD_ADDR_VAR 0 5
 612: PUSH
 613: LD_INT 2
 615: ST_TO_ADDR
// if i = 14 then
 616: LD_VAR 0 4
 620: PUSH
 621: LD_INT 14
 623: EQUAL
 624: IFFALSE 634
// c := 3 ;
 626: LD_ADDR_VAR 0 5
 630: PUSH
 631: LD_INT 3
 633: ST_TO_ADDR
// if i = 18 then
 634: LD_VAR 0 4
 638: PUSH
 639: LD_INT 18
 641: EQUAL
 642: IFFALSE 652
// c := 4 ;
 644: LD_ADDR_VAR 0 5
 648: PUSH
 649: LD_INT 4
 651: ST_TO_ADDR
// PrepareHuman ( false , c , skill ) ;
 652: LD_INT 0
 654: PPUSH
 655: LD_VAR 0 5
 659: PPUSH
 660: LD_VAR 0 6
 664: PPUSH
 665: CALL_OW 380
// un := CreateHuman ;
 669: LD_ADDR_VAR 0 2
 673: PUSH
 674: CALL_OW 44
 678: ST_TO_ADDR
// force := force ^ un ;
 679: LD_ADDR_VAR 0 3
 683: PUSH
 684: LD_VAR 0 3
 688: PUSH
 689: LD_VAR 0 2
 693: ADD
 694: ST_TO_ADDR
// end ;
 695: GO 595
 697: POP
 698: POP
// team := CharacterSelection ( text , [ 8 , 7 , 7 ] [ Difficulty ] , [ 8 , 7 , 7 ] [ Difficulty ] , [ sel_change_class , Stolypin , sel_changeable , sel_not_hired ] ^ force , [ [ class_soldier , 3 ] , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
 699: LD_ADDR_VAR 0 7
 703: PUSH
 704: LD_STRING text
 706: PPUSH
 707: LD_INT 8
 709: PUSH
 710: LD_INT 7
 712: PUSH
 713: LD_INT 7
 715: PUSH
 716: EMPTY
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_OWVAR 67
 725: ARRAY
 726: PPUSH
 727: LD_INT 8
 729: PUSH
 730: LD_INT 7
 732: PUSH
 733: LD_INT 7
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_OWVAR 67
 745: ARRAY
 746: PPUSH
 747: LD_INT -5
 749: PUSH
 750: LD_EXP 15
 754: PUSH
 755: LD_INT -3
 757: PUSH
 758: LD_INT -2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: LIST
 766: PUSH
 767: LD_VAR 0 3
 771: ADD
 772: PPUSH
 773: LD_INT 1
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: EMPTY
 780: LIST
 781: LIST
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 2
 788: PUSH
 789: LD_INT 1
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 4
 798: PUSH
 799: EMPTY
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PPUSH
 805: CALL_OW 42
 809: ST_TO_ADDR
// team := team ^ Stolypin ;
 810: LD_ADDR_VAR 0 7
 814: PUSH
 815: LD_VAR 0 7
 819: PUSH
 820: LD_EXP 15
 824: ADD
 825: ST_TO_ADDR
// for i = 1 to team do
 826: LD_ADDR_VAR 0 4
 830: PUSH
 831: DOUBLE
 832: LD_INT 1
 834: DEC
 835: ST_TO_ADDR
 836: LD_VAR 0 7
 840: PUSH
 841: FOR_TO
 842: IFFALSE 867
// PlaceUnitArea ( team [ i ] , rus_start , false ) ;
 844: LD_VAR 0 7
 848: PUSH
 849: LD_VAR 0 4
 853: ARRAY
 854: PPUSH
 855: LD_INT 1
 857: PPUSH
 858: LD_INT 0
 860: PPUSH
 861: CALL_OW 49
 865: GO 841
 867: POP
 868: POP
// CenterNowOnUnits ( Stolypin ) ;
 869: LD_EXP 15
 873: PPUSH
 874: CALL_OW 87
// end ;
 878: LD_VAR 0 1
 882: RET
// export conv_ready ; export function Convoy ( type ) ; var i , veh , skill ; begin
 883: LD_INT 0
 885: PPUSH
 886: PPUSH
 887: PPUSH
 888: PPUSH
// Randomize ;
 889: CALL_OW 10
// uc_side := 6 ;
 893: LD_ADDR_OWVAR 20
 897: PUSH
 898: LD_INT 6
 900: ST_TO_ADDR
// uc_nation := 3 ;
 901: LD_ADDR_OWVAR 21
 905: PUSH
 906: LD_INT 3
 908: ST_TO_ADDR
// hc_name :=  ;
 909: LD_ADDR_OWVAR 26
 913: PUSH
 914: LD_STRING 
 916: ST_TO_ADDR
// hc_gallery :=  ;
 917: LD_ADDR_OWVAR 33
 921: PUSH
 922: LD_STRING 
 924: ST_TO_ADDR
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
 925: LD_ADDR_VAR 0 5
 929: PUSH
 930: LD_INT 5
 932: PUSH
 933: LD_INT 5
 935: PUSH
 936: LD_INT 4
 938: PUSH
 939: EMPTY
 940: LIST
 941: LIST
 942: LIST
 943: PUSH
 944: LD_OWVAR 67
 948: ARRAY
 949: ST_TO_ADDR
// conv_ready := false ;
 950: LD_ADDR_EXP 18
 954: PUSH
 955: LD_INT 0
 957: ST_TO_ADDR
// case type of 1 :
 958: LD_VAR 0 1
 962: PUSH
 963: LD_INT 1
 965: DOUBLE
 966: EQUAL
 967: IFTRUE 971
 969: GO 1241
 971: POP
// begin if Rand ( 0 , 1 ) = 1 then
 972: LD_INT 0
 974: PPUSH
 975: LD_INT 1
 977: PPUSH
 978: CALL_OW 12
 982: PUSH
 983: LD_INT 1
 985: EQUAL
 986: IFFALSE 992
// AddEscort ( ) ;
 988: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
 992: LD_INT 70
 994: PPUSH
 995: CALL_OW 67
// vc_chassis := ru_medium_wheeled ;
 999: LD_ADDR_OWVAR 37
1003: PUSH
1004: LD_INT 21
1006: ST_TO_ADDR
// vc_engine := engine_combustion ;
1007: LD_ADDR_OWVAR 39
1011: PUSH
1012: LD_INT 1
1014: ST_TO_ADDR
// vc_control := control_manual ;
1015: LD_ADDR_OWVAR 38
1019: PUSH
1020: LD_INT 1
1022: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1023: LD_ADDR_OWVAR 40
1027: PUSH
1028: LD_INT 51
1030: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1031: LD_ADDR_OWVAR 41
1035: PUSH
1036: LD_INT 50
1038: PPUSH
1039: LD_INT 99
1041: PPUSH
1042: CALL_OW 12
1046: ST_TO_ADDR
// if uc_side <> 6 then
1047: LD_OWVAR 20
1051: PUSH
1052: LD_INT 6
1054: NONEQUAL
1055: IFFALSE 1065
// uc_side := 6 ;
1057: LD_ADDR_OWVAR 20
1061: PUSH
1062: LD_INT 6
1064: ST_TO_ADDR
// veh := CreateVehicle ;
1065: LD_ADDR_VAR 0 4
1069: PUSH
1070: CALL_OW 45
1074: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1075: LD_VAR 0 4
1079: PPUSH
1080: LD_INT 3
1082: PPUSH
1083: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1087: LD_VAR 0 4
1091: PPUSH
1092: LD_INT 8
1094: PPUSH
1095: LD_INT 0
1097: PPUSH
1098: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1102: LD_INT 0
1104: PPUSH
1105: LD_INT 1
1107: PPUSH
1108: LD_INT 2
1110: PPUSH
1111: CALL_OW 12
1115: PPUSH
1116: LD_VAR 0 5
1120: PPUSH
1121: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1125: CALL_OW 44
1129: PPUSH
1130: LD_VAR 0 4
1134: PPUSH
1135: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1139: LD_VAR 0 4
1143: PPUSH
1144: LD_INT 500
1146: PPUSH
1147: LD_INT 1000
1149: PPUSH
1150: CALL_OW 12
1154: PPUSH
1155: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1159: LD_VAR 0 4
1163: PPUSH
1164: LD_INT 1
1166: PPUSH
1167: LD_INT 2
1169: PPUSH
1170: CALL_OW 12
1174: PPUSH
1175: LD_INT 2
1177: PPUSH
1178: LD_INT 10
1180: PPUSH
1181: CALL_OW 12
1185: PUSH
1186: LD_INT 10
1188: MUL
1189: PPUSH
1190: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1194: LD_ADDR_EXP 1
1198: PUSH
1199: LD_EXP 1
1203: PPUSH
1204: LD_INT 1
1206: PPUSH
1207: LD_VAR 0 4
1211: PUSH
1212: LD_INT 1
1214: PUSH
1215: EMPTY
1216: LIST
1217: LIST
1218: PPUSH
1219: CALL_OW 2
1223: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
1224: LD_INT 35
1226: PPUSH
1227: CALL_OW 67
// conv_ready := true ;
1231: LD_ADDR_EXP 18
1235: PUSH
1236: LD_INT 1
1238: ST_TO_ADDR
// end ; 2 :
1239: GO 2861
1241: LD_INT 2
1243: DOUBLE
1244: EQUAL
1245: IFTRUE 1249
1247: GO 1549
1249: POP
// begin AddEscort ( ) ;
1250: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1254: LD_INT 70
1256: PPUSH
1257: CALL_OW 67
// for i = 1 to 2 do
1261: LD_ADDR_VAR 0 3
1265: PUSH
1266: DOUBLE
1267: LD_INT 1
1269: DEC
1270: ST_TO_ADDR
1271: LD_INT 2
1273: PUSH
1274: FOR_TO
1275: IFFALSE 1526
// begin vc_chassis := ru_medium_wheeled ;
1277: LD_ADDR_OWVAR 37
1281: PUSH
1282: LD_INT 21
1284: ST_TO_ADDR
// vc_engine := engine_combustion ;
1285: LD_ADDR_OWVAR 39
1289: PUSH
1290: LD_INT 1
1292: ST_TO_ADDR
// vc_control := control_manual ;
1293: LD_ADDR_OWVAR 38
1297: PUSH
1298: LD_INT 1
1300: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1301: LD_ADDR_OWVAR 40
1305: PUSH
1306: LD_INT 51
1308: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1309: LD_ADDR_OWVAR 41
1313: PUSH
1314: LD_INT 50
1316: PPUSH
1317: LD_INT 99
1319: PPUSH
1320: CALL_OW 12
1324: ST_TO_ADDR
// if uc_side <> 6 then
1325: LD_OWVAR 20
1329: PUSH
1330: LD_INT 6
1332: NONEQUAL
1333: IFFALSE 1343
// uc_side := 6 ;
1335: LD_ADDR_OWVAR 20
1339: PUSH
1340: LD_INT 6
1342: ST_TO_ADDR
// veh := CreateVehicle ;
1343: LD_ADDR_VAR 0 4
1347: PUSH
1348: CALL_OW 45
1352: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1353: LD_VAR 0 4
1357: PPUSH
1358: LD_INT 3
1360: PPUSH
1361: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1365: LD_VAR 0 4
1369: PPUSH
1370: LD_INT 8
1372: PPUSH
1373: LD_INT 0
1375: PPUSH
1376: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1380: LD_INT 0
1382: PPUSH
1383: LD_INT 1
1385: PPUSH
1386: LD_INT 2
1388: PPUSH
1389: CALL_OW 12
1393: PPUSH
1394: LD_VAR 0 5
1398: PPUSH
1399: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1403: CALL_OW 44
1407: PPUSH
1408: LD_VAR 0 4
1412: PPUSH
1413: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1417: LD_VAR 0 4
1421: PPUSH
1422: LD_INT 500
1424: PPUSH
1425: LD_INT 1000
1427: PPUSH
1428: CALL_OW 12
1432: PPUSH
1433: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1437: LD_VAR 0 4
1441: PPUSH
1442: LD_INT 1
1444: PPUSH
1445: LD_INT 2
1447: PPUSH
1448: CALL_OW 12
1452: PPUSH
1453: LD_INT 2
1455: PPUSH
1456: LD_INT 10
1458: PPUSH
1459: CALL_OW 12
1463: PUSH
1464: LD_INT 10
1466: MUL
1467: PPUSH
1468: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1472: LD_ADDR_EXP 1
1476: PUSH
1477: LD_EXP 1
1481: PPUSH
1482: LD_INT 1
1484: PPUSH
1485: LD_VAR 0 4
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: PPUSH
1497: CALL_OW 2
1501: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1502: LD_VAR 0 4
1506: PPUSH
1507: LD_INT 120
1509: PPUSH
1510: LD_INT 10
1512: PPUSH
1513: CALL_OW 111
// Wait ( 0 0$02 ) ;
1517: LD_INT 70
1519: PPUSH
1520: CALL_OW 67
// end ;
1524: GO 1274
1526: POP
1527: POP
// AddEscort ( ) ;
1528: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1532: LD_INT 70
1534: PPUSH
1535: CALL_OW 67
// conv_ready := true ;
1539: LD_ADDR_EXP 18
1543: PUSH
1544: LD_INT 1
1546: ST_TO_ADDR
// end ; 3 :
1547: GO 2861
1549: LD_INT 3
1551: DOUBLE
1552: EQUAL
1553: IFTRUE 1557
1555: GO 1976
1557: POP
// begin AddEscort ( ) ;
1558: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1562: LD_INT 70
1564: PPUSH
1565: CALL_OW 67
// for i = 1 to 2 do
1569: LD_ADDR_VAR 0 3
1573: PUSH
1574: DOUBLE
1575: LD_INT 1
1577: DEC
1578: ST_TO_ADDR
1579: LD_INT 2
1581: PUSH
1582: FOR_TO
1583: IFFALSE 1834
// begin vc_chassis := ru_medium_wheeled ;
1585: LD_ADDR_OWVAR 37
1589: PUSH
1590: LD_INT 21
1592: ST_TO_ADDR
// vc_engine := engine_combustion ;
1593: LD_ADDR_OWVAR 39
1597: PUSH
1598: LD_INT 1
1600: ST_TO_ADDR
// vc_control := control_manual ;
1601: LD_ADDR_OWVAR 38
1605: PUSH
1606: LD_INT 1
1608: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1609: LD_ADDR_OWVAR 40
1613: PUSH
1614: LD_INT 51
1616: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1617: LD_ADDR_OWVAR 41
1621: PUSH
1622: LD_INT 50
1624: PPUSH
1625: LD_INT 99
1627: PPUSH
1628: CALL_OW 12
1632: ST_TO_ADDR
// if uc_side <> 6 then
1633: LD_OWVAR 20
1637: PUSH
1638: LD_INT 6
1640: NONEQUAL
1641: IFFALSE 1651
// uc_side := 6 ;
1643: LD_ADDR_OWVAR 20
1647: PUSH
1648: LD_INT 6
1650: ST_TO_ADDR
// veh := CreateVehicle ;
1651: LD_ADDR_VAR 0 4
1655: PUSH
1656: CALL_OW 45
1660: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1661: LD_VAR 0 4
1665: PPUSH
1666: LD_INT 3
1668: PPUSH
1669: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1673: LD_VAR 0 4
1677: PPUSH
1678: LD_INT 8
1680: PPUSH
1681: LD_INT 0
1683: PPUSH
1684: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1688: LD_INT 0
1690: PPUSH
1691: LD_INT 1
1693: PPUSH
1694: LD_INT 2
1696: PPUSH
1697: CALL_OW 12
1701: PPUSH
1702: LD_VAR 0 5
1706: PPUSH
1707: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1711: CALL_OW 44
1715: PPUSH
1716: LD_VAR 0 4
1720: PPUSH
1721: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1725: LD_VAR 0 4
1729: PPUSH
1730: LD_INT 500
1732: PPUSH
1733: LD_INT 1000
1735: PPUSH
1736: CALL_OW 12
1740: PPUSH
1741: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1745: LD_VAR 0 4
1749: PPUSH
1750: LD_INT 1
1752: PPUSH
1753: LD_INT 2
1755: PPUSH
1756: CALL_OW 12
1760: PPUSH
1761: LD_INT 2
1763: PPUSH
1764: LD_INT 10
1766: PPUSH
1767: CALL_OW 12
1771: PUSH
1772: LD_INT 10
1774: MUL
1775: PPUSH
1776: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1780: LD_ADDR_EXP 1
1784: PUSH
1785: LD_EXP 1
1789: PPUSH
1790: LD_INT 1
1792: PPUSH
1793: LD_VAR 0 4
1797: PUSH
1798: LD_INT 1
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: PPUSH
1805: CALL_OW 2
1809: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1810: LD_VAR 0 4
1814: PPUSH
1815: LD_INT 120
1817: PPUSH
1818: LD_INT 10
1820: PPUSH
1821: CALL_OW 111
// Wait ( 0 0$02 ) ;
1825: LD_INT 70
1827: PPUSH
1828: CALL_OW 67
// end ;
1832: GO 1582
1834: POP
1835: POP
// for i = 1 to 2 do
1836: LD_ADDR_VAR 0 3
1840: PUSH
1841: DOUBLE
1842: LD_INT 1
1844: DEC
1845: ST_TO_ADDR
1846: LD_INT 2
1848: PUSH
1849: FOR_TO
1850: IFFALSE 1957
// begin PrepareHuman ( false , 1 , skill ) ;
1852: LD_INT 0
1854: PPUSH
1855: LD_INT 1
1857: PPUSH
1858: LD_VAR 0 5
1862: PPUSH
1863: CALL_OW 380
// if uc_side <> 6 then
1867: LD_OWVAR 20
1871: PUSH
1872: LD_INT 6
1874: NONEQUAL
1875: IFFALSE 1885
// uc_side := 6 ;
1877: LD_ADDR_OWVAR 20
1881: PUSH
1882: LD_INT 6
1884: ST_TO_ADDR
// veh := CreateHuman ;
1885: LD_ADDR_VAR 0 4
1889: PUSH
1890: CALL_OW 44
1894: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
1895: LD_VAR 0 4
1899: PPUSH
1900: LD_INT 8
1902: PPUSH
1903: LD_INT 0
1905: PPUSH
1906: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
1910: LD_ADDR_EXP 2
1914: PUSH
1915: LD_EXP 2
1919: PPUSH
1920: LD_INT 1
1922: PPUSH
1923: LD_VAR 0 4
1927: PPUSH
1928: CALL_OW 2
1932: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1933: LD_VAR 0 4
1937: PPUSH
1938: LD_INT 120
1940: PPUSH
1941: LD_INT 10
1943: PPUSH
1944: CALL_OW 111
// Wait ( 0 0$02 ) ;
1948: LD_INT 70
1950: PPUSH
1951: CALL_OW 67
// end ;
1955: GO 1849
1957: POP
1958: POP
// Wait ( 0 0$02 ) ;
1959: LD_INT 70
1961: PPUSH
1962: CALL_OW 67
// conv_ready := true ;
1966: LD_ADDR_EXP 18
1970: PUSH
1971: LD_INT 1
1973: ST_TO_ADDR
// end ; 4 :
1974: GO 2861
1976: LD_INT 4
1978: DOUBLE
1979: EQUAL
1980: IFTRUE 1984
1982: GO 2290
1984: POP
// begin if Rand ( 0 , 1 ) = 1 then
1985: LD_INT 0
1987: PPUSH
1988: LD_INT 1
1990: PPUSH
1991: CALL_OW 12
1995: PUSH
1996: LD_INT 1
1998: EQUAL
1999: IFFALSE 2005
// AddEscort ( ) ;
2001: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2005: LD_INT 70
2007: PPUSH
2008: CALL_OW 67
// for i = 1 to 5 do
2012: LD_ADDR_VAR 0 3
2016: PUSH
2017: DOUBLE
2018: LD_INT 1
2020: DEC
2021: ST_TO_ADDR
2022: LD_INT 5
2024: PUSH
2025: FOR_TO
2026: IFFALSE 2148
// begin PrepareHuman ( false , Rand ( 2 , 4 ) , skill ) ;
2028: LD_INT 0
2030: PPUSH
2031: LD_INT 2
2033: PPUSH
2034: LD_INT 4
2036: PPUSH
2037: CALL_OW 12
2041: PPUSH
2042: LD_VAR 0 5
2046: PPUSH
2047: CALL_OW 380
// if uc_side <> 6 then
2051: LD_OWVAR 20
2055: PUSH
2056: LD_INT 6
2058: NONEQUAL
2059: IFFALSE 2069
// uc_side := 6 ;
2061: LD_ADDR_OWVAR 20
2065: PUSH
2066: LD_INT 6
2068: ST_TO_ADDR
// veh := CreateHuman ;
2069: LD_ADDR_VAR 0 4
2073: PUSH
2074: CALL_OW 44
2078: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2079: LD_VAR 0 4
2083: PPUSH
2084: LD_INT 8
2086: PPUSH
2087: LD_INT 0
2089: PPUSH
2090: CALL_OW 49
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2094: LD_ADDR_EXP 1
2098: PUSH
2099: LD_EXP 1
2103: PPUSH
2104: LD_INT 1
2106: PPUSH
2107: LD_VAR 0 4
2111: PUSH
2112: LD_INT 1
2114: PUSH
2115: EMPTY
2116: LIST
2117: LIST
2118: PPUSH
2119: CALL_OW 2
2123: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2124: LD_VAR 0 4
2128: PPUSH
2129: LD_INT 120
2131: PPUSH
2132: LD_INT 10
2134: PPUSH
2135: CALL_OW 111
// Wait ( 0 0$02 ) ;
2139: LD_INT 70
2141: PPUSH
2142: CALL_OW 67
// end ;
2146: GO 2025
2148: POP
2149: POP
// for i = 1 to 2 do
2150: LD_ADDR_VAR 0 3
2154: PUSH
2155: DOUBLE
2156: LD_INT 1
2158: DEC
2159: ST_TO_ADDR
2160: LD_INT 2
2162: PUSH
2163: FOR_TO
2164: IFFALSE 2271
// begin PrepareHuman ( false , 1 , skill ) ;
2166: LD_INT 0
2168: PPUSH
2169: LD_INT 1
2171: PPUSH
2172: LD_VAR 0 5
2176: PPUSH
2177: CALL_OW 380
// if uc_side <> 6 then
2181: LD_OWVAR 20
2185: PUSH
2186: LD_INT 6
2188: NONEQUAL
2189: IFFALSE 2199
// uc_side := 6 ;
2191: LD_ADDR_OWVAR 20
2195: PUSH
2196: LD_INT 6
2198: ST_TO_ADDR
// veh := CreateHuman ;
2199: LD_ADDR_VAR 0 4
2203: PUSH
2204: CALL_OW 44
2208: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2209: LD_VAR 0 4
2213: PPUSH
2214: LD_INT 8
2216: PPUSH
2217: LD_INT 0
2219: PPUSH
2220: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
2224: LD_ADDR_EXP 2
2228: PUSH
2229: LD_EXP 2
2233: PPUSH
2234: LD_INT 1
2236: PPUSH
2237: LD_VAR 0 4
2241: PPUSH
2242: CALL_OW 2
2246: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2247: LD_VAR 0 4
2251: PPUSH
2252: LD_INT 120
2254: PPUSH
2255: LD_INT 10
2257: PPUSH
2258: CALL_OW 111
// Wait ( 0 0$02 ) ;
2262: LD_INT 70
2264: PPUSH
2265: CALL_OW 67
// end ;
2269: GO 2163
2271: POP
2272: POP
// Wait ( 0 0$02 ) ;
2273: LD_INT 70
2275: PPUSH
2276: CALL_OW 67
// conv_ready := true ;
2280: LD_ADDR_EXP 18
2284: PUSH
2285: LD_INT 1
2287: ST_TO_ADDR
// end ; 5 :
2288: GO 2861
2290: LD_INT 5
2292: DOUBLE
2293: EQUAL
2294: IFTRUE 2298
2296: GO 2860
2298: POP
// begin AddEscort ( ) ;
2299: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2303: LD_INT 70
2305: PPUSH
2306: CALL_OW 67
// AddEscort ( ) ;
2310: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2314: LD_INT 70
2316: PPUSH
2317: CALL_OW 67
// for i = 1 to 2 do
2321: LD_ADDR_VAR 0 3
2325: PUSH
2326: DOUBLE
2327: LD_INT 1
2329: DEC
2330: ST_TO_ADDR
2331: LD_INT 2
2333: PUSH
2334: FOR_TO
2335: IFFALSE 2586
// begin vc_chassis := ru_medium_wheeled ;
2337: LD_ADDR_OWVAR 37
2341: PUSH
2342: LD_INT 21
2344: ST_TO_ADDR
// vc_engine := engine_combustion ;
2345: LD_ADDR_OWVAR 39
2349: PUSH
2350: LD_INT 1
2352: ST_TO_ADDR
// vc_control := control_manual ;
2353: LD_ADDR_OWVAR 38
2357: PUSH
2358: LD_INT 1
2360: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2361: LD_ADDR_OWVAR 40
2365: PUSH
2366: LD_INT 51
2368: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2369: LD_ADDR_OWVAR 41
2373: PUSH
2374: LD_INT 50
2376: PPUSH
2377: LD_INT 99
2379: PPUSH
2380: CALL_OW 12
2384: ST_TO_ADDR
// if uc_side <> 6 then
2385: LD_OWVAR 20
2389: PUSH
2390: LD_INT 6
2392: NONEQUAL
2393: IFFALSE 2403
// uc_side := 6 ;
2395: LD_ADDR_OWVAR 20
2399: PUSH
2400: LD_INT 6
2402: ST_TO_ADDR
// veh := CreateVehicle ;
2403: LD_ADDR_VAR 0 4
2407: PUSH
2408: CALL_OW 45
2412: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2413: LD_VAR 0 4
2417: PPUSH
2418: LD_INT 3
2420: PPUSH
2421: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2425: LD_VAR 0 4
2429: PPUSH
2430: LD_INT 8
2432: PPUSH
2433: LD_INT 0
2435: PPUSH
2436: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2440: LD_INT 0
2442: PPUSH
2443: LD_INT 1
2445: PPUSH
2446: LD_INT 2
2448: PPUSH
2449: CALL_OW 12
2453: PPUSH
2454: LD_VAR 0 5
2458: PPUSH
2459: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2463: CALL_OW 44
2467: PPUSH
2468: LD_VAR 0 4
2472: PPUSH
2473: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2477: LD_VAR 0 4
2481: PPUSH
2482: LD_INT 500
2484: PPUSH
2485: LD_INT 1000
2487: PPUSH
2488: CALL_OW 12
2492: PPUSH
2493: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
2497: LD_VAR 0 4
2501: PPUSH
2502: LD_INT 1
2504: PPUSH
2505: LD_INT 2
2507: PPUSH
2508: CALL_OW 12
2512: PPUSH
2513: LD_INT 2
2515: PPUSH
2516: LD_INT 10
2518: PPUSH
2519: CALL_OW 12
2523: PUSH
2524: LD_INT 10
2526: MUL
2527: PPUSH
2528: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2532: LD_ADDR_EXP 1
2536: PUSH
2537: LD_EXP 1
2541: PPUSH
2542: LD_INT 1
2544: PPUSH
2545: LD_VAR 0 4
2549: PUSH
2550: LD_INT 1
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL_OW 2
2561: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2562: LD_VAR 0 4
2566: PPUSH
2567: LD_INT 120
2569: PPUSH
2570: LD_INT 10
2572: PPUSH
2573: CALL_OW 111
// Wait ( 0 0$02 ) ;
2577: LD_INT 70
2579: PPUSH
2580: CALL_OW 67
// end ;
2584: GO 2334
2586: POP
2587: POP
// if Rand ( 0 , 1 ) = 1 then
2588: LD_INT 0
2590: PPUSH
2591: LD_INT 1
2593: PPUSH
2594: CALL_OW 12
2598: PUSH
2599: LD_INT 1
2601: EQUAL
2602: IFFALSE 2638
// begin vc_chassis := ru_medium_tracked ;
2604: LD_ADDR_OWVAR 37
2608: PUSH
2609: LD_INT 22
2611: ST_TO_ADDR
// vc_engine := engine_combustion ;
2612: LD_ADDR_OWVAR 39
2616: PUSH
2617: LD_INT 1
2619: ST_TO_ADDR
// vc_control := control_manual ;
2620: LD_ADDR_OWVAR 38
2624: PUSH
2625: LD_INT 1
2627: ST_TO_ADDR
// vc_weapon := ru_crane ;
2628: LD_ADDR_OWVAR 40
2632: PUSH
2633: LD_INT 52
2635: ST_TO_ADDR
// end else
2636: GO 2670
// begin vc_chassis := ru_heavy_wheeled ;
2638: LD_ADDR_OWVAR 37
2642: PUSH
2643: LD_INT 23
2645: ST_TO_ADDR
// vc_engine := engine_combustion ;
2646: LD_ADDR_OWVAR 39
2650: PUSH
2651: LD_INT 1
2653: ST_TO_ADDR
// vc_control := control_manual ;
2654: LD_ADDR_OWVAR 38
2658: PUSH
2659: LD_INT 1
2661: ST_TO_ADDR
// vc_weapon := ru_bulldozer ;
2662: LD_ADDR_OWVAR 40
2666: PUSH
2667: LD_INT 53
2669: ST_TO_ADDR
// end ; vc_fuel_battery := Rand ( 50 , 99 ) ;
2670: LD_ADDR_OWVAR 41
2674: PUSH
2675: LD_INT 50
2677: PPUSH
2678: LD_INT 99
2680: PPUSH
2681: CALL_OW 12
2685: ST_TO_ADDR
// if uc_side <> 6 then
2686: LD_OWVAR 20
2690: PUSH
2691: LD_INT 6
2693: NONEQUAL
2694: IFFALSE 2704
// uc_side := 6 ;
2696: LD_ADDR_OWVAR 20
2700: PUSH
2701: LD_INT 6
2703: ST_TO_ADDR
// veh := CreateVehicle ;
2704: LD_ADDR_VAR 0 4
2708: PUSH
2709: CALL_OW 45
2713: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2714: LD_VAR 0 4
2718: PPUSH
2719: LD_INT 3
2721: PPUSH
2722: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2726: LD_VAR 0 4
2730: PPUSH
2731: LD_INT 8
2733: PPUSH
2734: LD_INT 0
2736: PPUSH
2737: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2741: LD_INT 0
2743: PPUSH
2744: LD_INT 1
2746: PPUSH
2747: LD_INT 2
2749: PPUSH
2750: CALL_OW 12
2754: PPUSH
2755: LD_VAR 0 5
2759: PPUSH
2760: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2764: CALL_OW 44
2768: PPUSH
2769: LD_VAR 0 4
2773: PPUSH
2774: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2778: LD_VAR 0 4
2782: PPUSH
2783: LD_INT 500
2785: PPUSH
2786: LD_INT 1000
2788: PPUSH
2789: CALL_OW 12
2793: PPUSH
2794: CALL_OW 234
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2798: LD_ADDR_EXP 1
2802: PUSH
2803: LD_EXP 1
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: LD_VAR 0 4
2815: PUSH
2816: LD_INT 1
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: PPUSH
2823: CALL_OW 2
2827: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2828: LD_VAR 0 4
2832: PPUSH
2833: LD_INT 120
2835: PPUSH
2836: LD_INT 10
2838: PPUSH
2839: CALL_OW 111
// Wait ( 0 0$02 ) ;
2843: LD_INT 70
2845: PPUSH
2846: CALL_OW 67
// conv_ready := true ;
2850: LD_ADDR_EXP 18
2854: PUSH
2855: LD_INT 1
2857: ST_TO_ADDR
// end ; end ;
2858: GO 2861
2860: POP
// end ;
2861: LD_VAR 0 2
2865: RET
// export function AddEscort ( ) ; var veh , skill ; begin
2866: LD_INT 0
2868: PPUSH
2869: PPUSH
2870: PPUSH
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
2871: LD_ADDR_VAR 0 3
2875: PUSH
2876: LD_INT 5
2878: PUSH
2879: LD_INT 5
2881: PUSH
2882: LD_INT 4
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: LIST
2889: PUSH
2890: LD_OWVAR 67
2894: ARRAY
2895: ST_TO_ADDR
// uc_side := 6 ;
2896: LD_ADDR_OWVAR 20
2900: PUSH
2901: LD_INT 6
2903: ST_TO_ADDR
// uc_nation := 3 ;
2904: LD_ADDR_OWVAR 21
2908: PUSH
2909: LD_INT 3
2911: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
2912: LD_ADDR_OWVAR 37
2916: PUSH
2917: LD_INT 21
2919: ST_TO_ADDR
// vc_engine := engine_combustion ;
2920: LD_ADDR_OWVAR 39
2924: PUSH
2925: LD_INT 1
2927: ST_TO_ADDR
// vc_control := control_manual ;
2928: LD_ADDR_OWVAR 38
2932: PUSH
2933: LD_INT 1
2935: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_heavy_machine_gun ] [ Rand ( 1 , 2 ) ] ;
2936: LD_ADDR_OWVAR 40
2940: PUSH
2941: LD_INT 44
2943: PUSH
2944: LD_INT 42
2946: PUSH
2947: EMPTY
2948: LIST
2949: LIST
2950: PUSH
2951: LD_INT 1
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: CALL_OW 12
2961: ARRAY
2962: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2963: LD_ADDR_OWVAR 41
2967: PUSH
2968: LD_INT 50
2970: PPUSH
2971: LD_INT 99
2973: PPUSH
2974: CALL_OW 12
2978: ST_TO_ADDR
// veh := CreateVehicle ;
2979: LD_ADDR_VAR 0 2
2983: PUSH
2984: CALL_OW 45
2988: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2989: LD_VAR 0 2
2993: PPUSH
2994: LD_INT 3
2996: PPUSH
2997: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
3001: LD_VAR 0 2
3005: PPUSH
3006: LD_INT 8
3008: PPUSH
3009: LD_INT 0
3011: PPUSH
3012: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
3016: LD_INT 0
3018: PPUSH
3019: LD_INT 3
3021: PPUSH
3022: LD_VAR 0 3
3026: PPUSH
3027: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3031: CALL_OW 44
3035: PPUSH
3036: LD_VAR 0 2
3040: PPUSH
3041: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
3045: LD_VAR 0 2
3049: PPUSH
3050: LD_INT 500
3052: PPUSH
3053: LD_INT 1000
3055: PPUSH
3056: CALL_OW 12
3060: PPUSH
3061: CALL_OW 234
// escort := Insert ( escort , 1 , veh ) ;
3065: LD_ADDR_EXP 2
3069: PUSH
3070: LD_EXP 2
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: LD_VAR 0 2
3082: PPUSH
3083: CALL_OW 2
3087: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
3088: LD_VAR 0 2
3092: PPUSH
3093: LD_INT 120
3095: PPUSH
3096: LD_INT 10
3098: PPUSH
3099: CALL_OW 111
// end ;
3103: LD_VAR 0 1
3107: RET
// every 4 trigger conv_ready and FilterAllUnits ( [ f_side , 6 ] ) do var i , j ;
3108: LD_EXP 18
3112: PUSH
3113: LD_INT 22
3115: PUSH
3116: LD_INT 6
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: PPUSH
3123: CALL_OW 69
3127: AND
3128: IFFALSE 3861
3130: GO 3132
3132: DISABLE
3133: LD_INT 0
3135: PPUSH
3136: PPUSH
// begin enable ;
3137: ENABLE
// if conv_squad then
3138: LD_EXP 1
3142: IFFALSE 3399
// for i = conv_squad downto 1 do
3144: LD_ADDR_VAR 0 1
3148: PUSH
3149: DOUBLE
3150: LD_EXP 1
3154: INC
3155: ST_TO_ADDR
3156: LD_INT 1
3158: PUSH
3159: FOR_DOWNTO
3160: IFFALSE 3397
// begin if IsInArea ( conv_squad [ i ] [ 1 ] , conv_end ) then
3162: LD_EXP 1
3166: PUSH
3167: LD_VAR 0 1
3171: ARRAY
3172: PUSH
3173: LD_INT 1
3175: ARRAY
3176: PPUSH
3177: LD_INT 9
3179: PPUSH
3180: CALL_OW 308
3184: IFFALSE 3247
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3186: LD_ADDR_VAR 0 2
3190: PUSH
3191: LD_INT 9
3193: PPUSH
3194: LD_INT 22
3196: PUSH
3197: LD_INT 6
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: PPUSH
3204: CALL_OW 70
3208: PUSH
3209: FOR_IN
3210: IFFALSE 3223
// RemoveUnit ( j ) ;
3212: LD_VAR 0 2
3216: PPUSH
3217: CALL_OW 64
3221: GO 3209
3223: POP
3224: POP
// conv_squad := Delete ( conv_squad , i ) ;
3225: LD_ADDR_EXP 1
3229: PUSH
3230: LD_EXP 1
3234: PPUSH
3235: LD_VAR 0 1
3239: PPUSH
3240: CALL_OW 3
3244: ST_TO_ADDR
// break ;
3245: GO 3397
// end ; if IsInArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) then
3247: LD_EXP 1
3251: PUSH
3252: LD_VAR 0 1
3256: ARRAY
3257: PUSH
3258: LD_INT 1
3260: ARRAY
3261: PPUSH
3262: LD_EXP 6
3266: PUSH
3267: LD_EXP 1
3271: PUSH
3272: LD_VAR 0 1
3276: ARRAY
3277: PUSH
3278: LD_INT 2
3280: ARRAY
3281: ARRAY
3282: PPUSH
3283: CALL_OW 308
3287: IFFALSE 3333
// conv_squad := Replace2 ( conv_squad , i , 2 , conv_squad [ i ] [ 2 ] + 1 ) else
3289: LD_ADDR_EXP 1
3293: PUSH
3294: LD_EXP 1
3298: PPUSH
3299: LD_VAR 0 1
3303: PPUSH
3304: LD_INT 2
3306: PPUSH
3307: LD_EXP 1
3311: PUSH
3312: LD_VAR 0 1
3316: ARRAY
3317: PUSH
3318: LD_INT 2
3320: ARRAY
3321: PUSH
3322: LD_INT 1
3324: PLUS
3325: PPUSH
3326: CALL 10126 0 4
3330: ST_TO_ADDR
3331: GO 3395
// if not HasTask ( conv_squad [ i ] [ 1 ] ) then
3333: LD_EXP 1
3337: PUSH
3338: LD_VAR 0 1
3342: ARRAY
3343: PUSH
3344: LD_INT 1
3346: ARRAY
3347: PPUSH
3348: CALL_OW 314
3352: NOT
3353: IFFALSE 3395
// ComMoveToArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) ;
3355: LD_EXP 1
3359: PUSH
3360: LD_VAR 0 1
3364: ARRAY
3365: PUSH
3366: LD_INT 1
3368: ARRAY
3369: PPUSH
3370: LD_EXP 6
3374: PUSH
3375: LD_EXP 1
3379: PUSH
3380: LD_VAR 0 1
3384: ARRAY
3385: PUSH
3386: LD_INT 2
3388: ARRAY
3389: ARRAY
3390: PPUSH
3391: CALL_OW 113
// end ;
3395: GO 3159
3397: POP
3398: POP
// if escort then
3399: LD_EXP 2
3403: IFFALSE 3728
// for i = escort downto 1 do
3405: LD_ADDR_VAR 0 1
3409: PUSH
3410: DOUBLE
3411: LD_EXP 2
3415: INC
3416: ST_TO_ADDR
3417: LD_INT 1
3419: PUSH
3420: FOR_DOWNTO
3421: IFFALSE 3726
// begin if IsInArea ( escort [ i ] , conv_end ) then
3423: LD_EXP 2
3427: PUSH
3428: LD_VAR 0 1
3432: ARRAY
3433: PPUSH
3434: LD_INT 9
3436: PPUSH
3437: CALL_OW 308
3441: IFFALSE 3504
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3443: LD_ADDR_VAR 0 2
3447: PUSH
3448: LD_INT 9
3450: PPUSH
3451: LD_INT 22
3453: PUSH
3454: LD_INT 6
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 70
3465: PUSH
3466: FOR_IN
3467: IFFALSE 3480
// RemoveUnit ( j ) ;
3469: LD_VAR 0 2
3473: PPUSH
3474: CALL_OW 64
3478: GO 3466
3480: POP
3481: POP
// escort := Delete ( escort , i ) ;
3482: LD_ADDR_EXP 2
3486: PUSH
3487: LD_EXP 2
3491: PPUSH
3492: LD_VAR 0 1
3496: PPUSH
3497: CALL_OW 3
3501: ST_TO_ADDR
// break ;
3502: GO 3726
// end ; if FindTarget ( escort [ i ] ) and GetDistUnits ( escort [ i ] , FindTarget ( escort [ i ] ) ) < 13 then
3504: LD_EXP 2
3508: PUSH
3509: LD_VAR 0 1
3513: ARRAY
3514: PPUSH
3515: CALL 10434 0 1
3519: PUSH
3520: LD_EXP 2
3524: PUSH
3525: LD_VAR 0 1
3529: ARRAY
3530: PPUSH
3531: LD_EXP 2
3535: PUSH
3536: LD_VAR 0 1
3540: ARRAY
3541: PPUSH
3542: CALL 10434 0 1
3546: PPUSH
3547: CALL_OW 296
3551: PUSH
3552: LD_INT 13
3554: LESS
3555: AND
3556: IFFALSE 3591
// ComAttackUnit ( escort [ i ] , FindTarget ( escort [ i ] ) ) else
3558: LD_EXP 2
3562: PUSH
3563: LD_VAR 0 1
3567: ARRAY
3568: PPUSH
3569: LD_EXP 2
3573: PUSH
3574: LD_VAR 0 1
3578: ARRAY
3579: PPUSH
3580: CALL 10434 0 1
3584: PPUSH
3585: CALL_OW 115
3589: GO 3724
// if conv_squad and GetDistUnitXY ( escort [ i ] , 64 , 117 ) > 35 and not HasTask ( escort [ i ] ) then
3591: LD_EXP 1
3595: PUSH
3596: LD_EXP 2
3600: PUSH
3601: LD_VAR 0 1
3605: ARRAY
3606: PPUSH
3607: LD_INT 64
3609: PPUSH
3610: LD_INT 117
3612: PPUSH
3613: CALL_OW 297
3617: PUSH
3618: LD_INT 35
3620: GREATER
3621: AND
3622: PUSH
3623: LD_EXP 2
3627: PUSH
3628: LD_VAR 0 1
3632: ARRAY
3633: PPUSH
3634: CALL_OW 314
3638: NOT
3639: AND
3640: IFFALSE 3706
// begin if GetDistUnits ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) > 6 then
3642: LD_EXP 2
3646: PUSH
3647: LD_VAR 0 1
3651: ARRAY
3652: PPUSH
3653: LD_EXP 1
3657: PUSH
3658: LD_INT 1
3660: ARRAY
3661: PUSH
3662: LD_INT 1
3664: ARRAY
3665: PPUSH
3666: CALL_OW 296
3670: PUSH
3671: LD_INT 6
3673: GREATER
3674: IFFALSE 3704
// ComMoveUnit ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) end else
3676: LD_EXP 2
3680: PUSH
3681: LD_VAR 0 1
3685: ARRAY
3686: PPUSH
3687: LD_EXP 1
3691: PUSH
3692: LD_INT 1
3694: ARRAY
3695: PUSH
3696: LD_INT 1
3698: ARRAY
3699: PPUSH
3700: CALL_OW 112
3704: GO 3724
// ComMoveToArea ( escort [ i ] , conv_end ) ;
3706: LD_EXP 2
3710: PUSH
3711: LD_VAR 0 1
3715: ARRAY
3716: PPUSH
3717: LD_INT 9
3719: PPUSH
3720: CALL_OW 113
// end ;
3724: GO 3420
3726: POP
3727: POP
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) then
3728: LD_INT 22
3730: PUSH
3731: LD_INT 6
3733: PUSH
3734: EMPTY
3735: LIST
3736: LIST
3737: PUSH
3738: LD_INT 21
3740: PUSH
3741: LD_INT 1
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PPUSH
3752: CALL_OW 69
3756: IFFALSE 3861
// for j in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) do
3758: LD_ADDR_VAR 0 2
3762: PUSH
3763: LD_INT 22
3765: PUSH
3766: LD_INT 6
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: LD_INT 21
3775: PUSH
3776: LD_INT 1
3778: PUSH
3779: EMPTY
3780: LIST
3781: LIST
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: PPUSH
3787: CALL_OW 69
3791: PUSH
3792: FOR_IN
3793: IFFALSE 3859
// begin if not HasTask ( j ) and not IsInArea ( j , conv_end ) then
3795: LD_VAR 0 2
3799: PPUSH
3800: CALL_OW 314
3804: NOT
3805: PUSH
3806: LD_VAR 0 2
3810: PPUSH
3811: LD_INT 9
3813: PPUSH
3814: CALL_OW 308
3818: NOT
3819: AND
3820: IFFALSE 3834
// ComMoveToArea ( j , conv_end ) ;
3822: LD_VAR 0 2
3826: PPUSH
3827: LD_INT 9
3829: PPUSH
3830: CALL_OW 113
// if IsInArea ( j , conv_end ) then
3834: LD_VAR 0 2
3838: PPUSH
3839: LD_INT 9
3841: PPUSH
3842: CALL_OW 308
3846: IFFALSE 3857
// RemoveUnit ( j ) ;
3848: LD_VAR 0 2
3852: PPUSH
3853: CALL_OW 64
// end ;
3857: GO 3792
3859: POP
3860: POP
// end ;
3861: PPOPN 2
3863: END
// every 0 0$01 trigger UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do var i ;
3864: LD_EXP 2
3868: PUSH
3869: LD_EXP 1
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: PPUSH
3878: LD_INT 22
3880: PUSH
3881: LD_INT 3
3883: PUSH
3884: EMPTY
3885: LIST
3886: LIST
3887: PPUSH
3888: CALL_OW 72
3892: IFFALSE 3954
3894: GO 3896
3896: DISABLE
3897: LD_INT 0
3899: PPUSH
// begin enable ;
3900: ENABLE
// for i in UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do
3901: LD_ADDR_VAR 0 1
3905: PUSH
3906: LD_EXP 2
3910: PUSH
3911: LD_EXP 1
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PPUSH
3920: LD_INT 22
3922: PUSH
3923: LD_INT 3
3925: PUSH
3926: EMPTY
3927: LIST
3928: LIST
3929: PPUSH
3930: CALL_OW 72
3934: PUSH
3935: FOR_IN
3936: IFFALSE 3952
// SetSide ( i , 6 ) ;
3938: LD_VAR 0 1
3942: PPUSH
3943: LD_INT 6
3945: PPUSH
3946: CALL_OW 235
3950: GO 3935
3952: POP
3953: POP
// end ; end_of_file
3954: PPOPN 1
3956: END
// export Collins ; export us_alert , us_retreat , us_patrol , us_count ; export function PrepareAmerican ; var i , un , skill , towers ; begin
3957: LD_INT 0
3959: PPUSH
3960: PPUSH
3961: PPUSH
3962: PPUSH
3963: PPUSH
// uc_side := 1 ;
3964: LD_ADDR_OWVAR 20
3968: PUSH
3969: LD_INT 1
3971: ST_TO_ADDR
// uc_nation := 1 ;
3972: LD_ADDR_OWVAR 21
3976: PUSH
3977: LD_INT 1
3979: ST_TO_ADDR
// us_alert := false ;
3980: LD_ADDR_EXP 20
3984: PUSH
3985: LD_INT 0
3987: ST_TO_ADDR
// us_retreat := false ;
3988: LD_ADDR_EXP 21
3992: PUSH
3993: LD_INT 0
3995: ST_TO_ADDR
// us_patrol := false ;
3996: LD_ADDR_EXP 22
4000: PUSH
4001: LD_INT 0
4003: ST_TO_ADDR
// us_count := 0 ;
4004: LD_ADDR_EXP 23
4008: PUSH
4009: LD_INT 0
4011: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4012: LD_ADDR_VAR 0 4
4016: PUSH
4017: LD_INT 5
4019: PUSH
4020: LD_INT 6
4022: PUSH
4023: LD_INT 7
4025: PUSH
4026: EMPTY
4027: LIST
4028: LIST
4029: LIST
4030: PUSH
4031: LD_OWVAR 67
4035: ARRAY
4036: ST_TO_ADDR
// hc_class := 1 ;
4037: LD_ADDR_OWVAR 28
4041: PUSH
4042: LD_INT 1
4044: ST_TO_ADDR
// hc_sex := sex_male ;
4045: LD_ADDR_OWVAR 27
4049: PUSH
4050: LD_INT 1
4052: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
4053: LD_ADDR_OWVAR 31
4057: PUSH
4058: LD_INT 6
4060: PUSH
4061: LD_INT 3
4063: PUSH
4064: LD_INT 4
4066: PUSH
4067: LD_INT 2
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: LIST
4074: LIST
4075: ST_TO_ADDR
// hc_name := Jack Collins ;
4076: LD_ADDR_OWVAR 26
4080: PUSH
4081: LD_STRING Jack Collins
4083: ST_TO_ADDR
// hc_attr := [ 11 , 11 ] ;
4084: LD_ADDR_OWVAR 29
4088: PUSH
4089: LD_INT 11
4091: PUSH
4092: LD_INT 11
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: ST_TO_ADDR
// hc_gallery :=  ;
4099: LD_ADDR_OWVAR 33
4103: PUSH
4104: LD_STRING 
4106: ST_TO_ADDR
// Collins := CreateHuman ;
4107: LD_ADDR_EXP 19
4111: PUSH
4112: CALL_OW 44
4116: ST_TO_ADDR
// PlaceHumanInUnit ( Collins , us_depot ) ;
4117: LD_EXP 19
4121: PPUSH
4122: LD_INT 50
4124: PPUSH
4125: CALL_OW 52
// hc_name :=  ;
4129: LD_ADDR_OWVAR 26
4133: PUSH
4134: LD_STRING 
4136: ST_TO_ADDR
// if Difficulty > 1 then
4137: LD_OWVAR 67
4141: PUSH
4142: LD_INT 1
4144: GREATER
4145: IFFALSE 4199
// begin bc_type := b_bunker ;
4147: LD_ADDR_OWVAR 42
4151: PUSH
4152: LD_INT 32
4154: ST_TO_ADDR
// bc_level := 5 ;
4155: LD_ADDR_OWVAR 43
4159: PUSH
4160: LD_INT 5
4162: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 40 , 33 , 2 ) ;
4163: LD_INT 40
4165: PPUSH
4166: LD_INT 33
4168: PPUSH
4169: LD_INT 2
4171: PPUSH
4172: CALL_OW 47
// if Difficulty > 2 then
4176: LD_OWVAR 67
4180: PUSH
4181: LD_INT 2
4183: GREATER
4184: IFFALSE 4199
// CreateAndPlaceBuildingXYD ( 41 , 42 , 0 ) ;
4186: LD_INT 41
4188: PPUSH
4189: LD_INT 42
4191: PPUSH
4192: LD_INT 0
4194: PPUSH
4195: CALL_OW 47
// end ; PrepareHuman ( false , 2 , skill ) ;
4199: LD_INT 0
4201: PPUSH
4202: LD_INT 2
4204: PPUSH
4205: LD_VAR 0 4
4209: PPUSH
4210: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
4214: CALL_OW 44
4218: PPUSH
4219: LD_INT 50
4221: PPUSH
4222: CALL_OW 52
// PrepareHuman ( false , 3 , skill ) ;
4226: LD_INT 0
4228: PPUSH
4229: LD_INT 3
4231: PPUSH
4232: LD_VAR 0 4
4236: PPUSH
4237: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4241: CALL_OW 44
4245: PPUSH
4246: LD_INT 56
4248: PPUSH
4249: CALL_OW 52
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4253: CALL_OW 44
4257: PPUSH
4258: LD_INT 56
4260: PPUSH
4261: CALL_OW 52
// PrepareHuman ( false , 4 , skill ) ;
4265: LD_INT 0
4267: PPUSH
4268: LD_INT 4
4270: PPUSH
4271: LD_VAR 0 4
4275: PPUSH
4276: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
4280: CALL_OW 44
4284: PPUSH
4285: LD_INT 63
4287: PPUSH
4288: CALL_OW 52
// PrepareHuman ( false , 1 , skill ) ;
4292: LD_INT 0
4294: PPUSH
4295: LD_INT 1
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: CALL_OW 380
// un := CreateHuman ;
4307: LD_ADDR_VAR 0 3
4311: PUSH
4312: CALL_OW 44
4316: ST_TO_ADDR
// SetDir ( un , 4 ) ;
4317: LD_VAR 0 3
4321: PPUSH
4322: LD_INT 4
4324: PPUSH
4325: CALL_OW 233
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
4329: LD_VAR 0 3
4333: PPUSH
4334: LD_INT 22
4336: PUSH
4337: LD_INT 1
4339: PUSH
4340: EMPTY
4341: LIST
4342: LIST
4343: PUSH
4344: LD_INT 30
4346: PUSH
4347: LD_INT 31
4349: PUSH
4350: EMPTY
4351: LIST
4352: LIST
4353: PUSH
4354: EMPTY
4355: LIST
4356: LIST
4357: PPUSH
4358: CALL_OW 69
4362: PUSH
4363: LD_INT 1
4365: ARRAY
4366: PPUSH
4367: CALL_OW 52
// towers := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) ;
4371: LD_ADDR_VAR 0 5
4375: PUSH
4376: LD_INT 22
4378: PUSH
4379: LD_INT 1
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: PUSH
4386: LD_INT 30
4388: PUSH
4389: LD_INT 32
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: PPUSH
4400: CALL_OW 69
4404: ST_TO_ADDR
// for i in towers do
4405: LD_ADDR_VAR 0 2
4409: PUSH
4410: LD_VAR 0 5
4414: PUSH
4415: FOR_IN
4416: IFFALSE 4484
// begin PrepareHuman ( false , 1 , skill ) ;
4418: LD_INT 0
4420: PPUSH
4421: LD_INT 1
4423: PPUSH
4424: LD_VAR 0 4
4428: PPUSH
4429: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4433: CALL_OW 44
4437: PPUSH
4438: LD_VAR 0 2
4442: PPUSH
4443: CALL_OW 52
// PlaceWeaponTurret ( i , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
4447: LD_VAR 0 2
4451: PPUSH
4452: LD_INT 4
4454: PUSH
4455: LD_INT 3
4457: PUSH
4458: LD_INT 5
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: LIST
4465: PUSH
4466: LD_INT 1
4468: PPUSH
4469: LD_INT 3
4471: PPUSH
4472: CALL_OW 12
4476: ARRAY
4477: PPUSH
4478: CALL_OW 431
// end ;
4482: GO 4415
4484: POP
4485: POP
// PrepareHuman ( false , 1 , skill ) ;
4486: LD_INT 0
4488: PPUSH
4489: LD_INT 1
4491: PPUSH
4492: LD_VAR 0 4
4496: PPUSH
4497: CALL_OW 380
// us_patrol := CreateHuman ;
4501: LD_ADDR_EXP 22
4505: PUSH
4506: CALL_OW 44
4510: ST_TO_ADDR
// PlaceUnitXY ( us_patrol , 12 , 5 , false ) ;
4511: LD_EXP 22
4515: PPUSH
4516: LD_INT 12
4518: PPUSH
4519: LD_INT 5
4521: PPUSH
4522: LD_INT 0
4524: PPUSH
4525: CALL_OW 48
// end ;
4529: LD_VAR 0 1
4533: RET
// every 0 0$01 trigger us_count >= [ 3 , 4 , 5 ] [ Difficulty ] do
4534: LD_EXP 23
4538: PUSH
4539: LD_INT 3
4541: PUSH
4542: LD_INT 4
4544: PUSH
4545: LD_INT 5
4547: PUSH
4548: EMPTY
4549: LIST
4550: LIST
4551: LIST
4552: PUSH
4553: LD_OWVAR 67
4557: ARRAY
4558: GREATEREQUAL
4559: IFFALSE 4584
4561: GO 4563
4563: DISABLE
// begin Say ( Collins , DPM_C2 ) ;
4564: LD_EXP 19
4568: PPUSH
4569: LD_STRING DPM_C2
4571: PPUSH
4572: CALL_OW 88
// us_retreat := true ;
4576: LD_ADDR_EXP 21
4580: PUSH
4581: LD_INT 1
4583: ST_TO_ADDR
// end ;
4584: END
// every 10 10$00 trigger not us_alert do var R ;
4585: LD_EXP 20
4589: NOT
4590: IFFALSE 4664
4592: GO 4594
4594: DISABLE
4595: LD_INT 0
4597: PPUSH
// begin uc_side := 1 ;
4598: LD_ADDR_OWVAR 20
4602: PUSH
4603: LD_INT 1
4605: ST_TO_ADDR
// uc_nation := 1 ;
4606: LD_ADDR_OWVAR 21
4610: PUSH
4611: LD_INT 1
4613: ST_TO_ADDR
// PrepareHuman ( false , 1 , 0 ) ;
4614: LD_INT 0
4616: PPUSH
4617: LD_INT 1
4619: PPUSH
4620: LD_INT 0
4622: PPUSH
4623: CALL_OW 380
// R := CreateHuman ;
4627: LD_ADDR_VAR 0 1
4631: PUSH
4632: CALL_OW 44
4636: ST_TO_ADDR
// SayRadio ( R , DPM_R1 ) ;
4637: LD_VAR 0 1
4641: PPUSH
4642: LD_STRING DPM_R1
4644: PPUSH
4645: CALL_OW 94
// Wait ( 0 0$03 ) ;
4649: LD_INT 105
4651: PPUSH
4652: CALL_OW 67
// us_retreat := true ;
4656: LD_ADDR_EXP 21
4660: PUSH
4661: LD_INT 1
4663: ST_TO_ADDR
// end ;
4664: PPOPN 1
4666: END
// every 0 0$01 trigger us_alert do var i ;
4667: LD_EXP 20
4671: IFFALSE 4931
4673: GO 4675
4675: DISABLE
4676: LD_INT 0
4678: PPUSH
// begin Say ( Collins , DPM_C1 ) ;
4679: LD_EXP 19
4683: PPUSH
4684: LD_STRING DPM_C1
4686: PPUSH
4687: CALL_OW 88
// if UnitsInside ( us_fac ) then
4691: LD_INT 56
4693: PPUSH
4694: CALL_OW 313
4698: IFFALSE 4753
// for i in UnitsInside ( us_fac ) do
4700: LD_ADDR_VAR 0 1
4704: PUSH
4705: LD_INT 56
4707: PPUSH
4708: CALL_OW 313
4712: PUSH
4713: FOR_IN
4714: IFFALSE 4751
// begin ComExitBuilding ( i ) ;
4716: LD_VAR 0 1
4720: PPUSH
4721: CALL_OW 122
// AddComEnterUnit ( i , us_arm ) ;
4725: LD_VAR 0 1
4729: PPUSH
4730: LD_INT 69
4732: PPUSH
4733: CALL_OW 180
// AddComChangeProfession ( i , 1 ) ;
4737: LD_VAR 0 1
4741: PPUSH
4742: LD_INT 1
4744: PPUSH
4745: CALL_OW 183
// end ;
4749: GO 4713
4751: POP
4752: POP
// ComExitBuilding ( Collins ) ;
4753: LD_EXP 19
4757: PPUSH
4758: CALL_OW 122
// AddComEnterUnit ( Collins , us_arm ) ;
4762: LD_EXP 19
4766: PPUSH
4767: LD_INT 69
4769: PPUSH
4770: CALL_OW 180
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] ) ;
4774: LD_INT 22
4776: PUSH
4777: LD_INT 1
4779: PUSH
4780: EMPTY
4781: LIST
4782: LIST
4783: PUSH
4784: LD_INT 25
4786: PUSH
4787: LD_INT 2
4789: PUSH
4790: EMPTY
4791: LIST
4792: LIST
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: PPUSH
4798: CALL_OW 69
4802: PUSH
4803: LD_INT 1
4805: ARRAY
4806: PPUSH
4807: CALL_OW 122
// AddComMoveXY ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , 67 , 52 ) ;
4811: LD_INT 22
4813: PUSH
4814: LD_INT 1
4816: PUSH
4817: EMPTY
4818: LIST
4819: LIST
4820: PUSH
4821: LD_INT 25
4823: PUSH
4824: LD_INT 2
4826: PUSH
4827: EMPTY
4828: LIST
4829: LIST
4830: PUSH
4831: EMPTY
4832: LIST
4833: LIST
4834: PPUSH
4835: CALL_OW 69
4839: PUSH
4840: LD_INT 1
4842: ARRAY
4843: PPUSH
4844: LD_INT 67
4846: PPUSH
4847: LD_INT 52
4849: PPUSH
4850: CALL_OW 171
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] ) ;
4854: LD_INT 22
4856: PUSH
4857: LD_INT 1
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: PUSH
4864: LD_INT 25
4866: PUSH
4867: LD_INT 4
4869: PUSH
4870: EMPTY
4871: LIST
4872: LIST
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PPUSH
4878: CALL_OW 69
4882: PUSH
4883: LD_INT 1
4885: ARRAY
4886: PPUSH
4887: CALL_OW 122
// AddComEnterUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] , us_arm ) ;
4891: LD_INT 22
4893: PUSH
4894: LD_INT 1
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: PUSH
4901: LD_INT 25
4903: PUSH
4904: LD_INT 4
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PPUSH
4915: CALL_OW 69
4919: PUSH
4920: LD_INT 1
4922: ARRAY
4923: PPUSH
4924: LD_INT 69
4926: PPUSH
4927: CALL_OW 180
// end ;
4931: PPOPN 1
4933: END
// every 3 3$00 trigger not us_alert and GetSide ( us_fac ) = 1 do
4934: LD_EXP 20
4938: NOT
4939: PUSH
4940: LD_INT 56
4942: PPUSH
4943: CALL_OW 255
4947: PUSH
4948: LD_INT 1
4950: EQUAL
4951: AND
4952: IFFALSE 4995
4954: GO 4956
4956: DISABLE
// begin AddComConstruct ( us_fac , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun ) ;
4957: LD_INT 56
4959: PPUSH
4960: LD_INT 2
4962: PPUSH
4963: LD_INT 1
4965: PPUSH
4966: LD_INT 1
4968: PPUSH
4969: LD_INT 4
4971: PPUSH
4972: CALL_OW 185
// AddComConstruct ( us_fac , us_medium_tracked , engine_solar , control_manual , us_double_gun ) ;
4976: LD_INT 56
4978: PPUSH
4979: LD_INT 3
4981: PPUSH
4982: LD_INT 2
4984: PPUSH
4985: LD_INT 1
4987: PPUSH
4988: LD_INT 5
4990: PPUSH
4991: CALL_OW 185
// end ;
4995: END
// every 0 0$01 trigger us_patrol do
4996: LD_EXP 22
5000: IFFALSE 5048
5002: GO 5004
5004: DISABLE
// SetPatrol ( us_patrol , [ 12 , 5 , 56 , 4 , 94 , 34 , 92 , 108 ] ) ;
5005: LD_EXP 22
5009: PPUSH
5010: LD_INT 12
5012: PUSH
5013: LD_INT 5
5015: PUSH
5016: LD_INT 56
5018: PUSH
5019: LD_INT 4
5021: PUSH
5022: LD_INT 94
5024: PUSH
5025: LD_INT 34
5027: PUSH
5028: LD_INT 92
5030: PUSH
5031: LD_INT 108
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: LIST
5038: LIST
5039: LIST
5040: LIST
5041: LIST
5042: LIST
5043: PPUSH
5044: CALL 5049 0 2
5048: END
// export function SetPatrol ( un , points ) ; var s , i , turn ; begin
5049: LD_INT 0
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
// s = 1 ;
5055: LD_ADDR_VAR 0 4
5059: PUSH
5060: LD_INT 1
5062: ST_TO_ADDR
// turn := true ;
5063: LD_ADDR_VAR 0 6
5067: PUSH
5068: LD_INT 1
5070: ST_TO_ADDR
// while ( un and not us_alert ) do
5071: LD_VAR 0 1
5075: PUSH
5076: LD_EXP 20
5080: NOT
5081: AND
5082: IFFALSE 5261
// begin wait ( 35 ) ;
5084: LD_INT 35
5086: PPUSH
5087: CALL_OW 67
// if not HasTask ( un ) then
5091: LD_VAR 0 1
5095: PPUSH
5096: CALL_OW 314
5100: NOT
5101: IFFALSE 5220
// begin ComMoveXY ( un , points [ s ] , points [ s + 1 ] ) ;
5103: LD_VAR 0 1
5107: PPUSH
5108: LD_VAR 0 2
5112: PUSH
5113: LD_VAR 0 4
5117: ARRAY
5118: PPUSH
5119: LD_VAR 0 2
5123: PUSH
5124: LD_VAR 0 4
5128: PUSH
5129: LD_INT 1
5131: PLUS
5132: ARRAY
5133: PPUSH
5134: CALL_OW 111
// if s + 2 > points then
5138: LD_VAR 0 4
5142: PUSH
5143: LD_INT 2
5145: PLUS
5146: PUSH
5147: LD_VAR 0 2
5151: GREATER
5152: IFFALSE 5162
// turn := false ;
5154: LD_ADDR_VAR 0 6
5158: PUSH
5159: LD_INT 0
5161: ST_TO_ADDR
// if s - 2 < 1 then
5162: LD_VAR 0 4
5166: PUSH
5167: LD_INT 2
5169: MINUS
5170: PUSH
5171: LD_INT 1
5173: LESS
5174: IFFALSE 5184
// turn := true ;
5176: LD_ADDR_VAR 0 6
5180: PUSH
5181: LD_INT 1
5183: ST_TO_ADDR
// if turn then
5184: LD_VAR 0 6
5188: IFFALSE 5206
// s := s + 2 else
5190: LD_ADDR_VAR 0 4
5194: PUSH
5195: LD_VAR 0 4
5199: PUSH
5200: LD_INT 2
5202: PLUS
5203: ST_TO_ADDR
5204: GO 5220
// s := s - 2 ;
5206: LD_ADDR_VAR 0 4
5210: PUSH
5211: LD_VAR 0 4
5215: PUSH
5216: LD_INT 2
5218: MINUS
5219: ST_TO_ADDR
// end ; if GetLives ( un ) < 1000 or See ( 3 , un ) then
5220: LD_VAR 0 1
5224: PPUSH
5225: CALL_OW 256
5229: PUSH
5230: LD_INT 1000
5232: LESS
5233: PUSH
5234: LD_INT 3
5236: PPUSH
5237: LD_VAR 0 1
5241: PPUSH
5242: CALL_OW 292
5246: OR
5247: IFFALSE 5259
// begin us_alert := true ;
5249: LD_ADDR_EXP 20
5253: PUSH
5254: LD_INT 1
5256: ST_TO_ADDR
// break ;
5257: GO 5261
// end ; end ;
5259: GO 5071
// ComEnterUnit ( un , us_arm ) ;
5261: LD_VAR 0 1
5265: PPUSH
5266: LD_INT 69
5268: PPUSH
5269: CALL_OW 120
// end ;
5273: LD_VAR 0 3
5277: RET
// every 0 0$01 trigger us_retreat do var i , point ;
5278: LD_EXP 21
5282: IFFALSE 5457
5284: GO 5286
5286: DISABLE
5287: LD_INT 0
5289: PPUSH
5290: PPUSH
// begin point := false ;
5291: LD_ADDR_VAR 0 2
5295: PUSH
5296: LD_INT 0
5298: ST_TO_ADDR
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5299: LD_INT 5
5301: PPUSH
5302: LD_INT 22
5304: PUSH
5305: LD_INT 3
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: PPUSH
5312: CALL_OW 70
5316: PUSH
5317: LD_INT 0
5319: EQUAL
5320: IFFALSE 5332
// point := us_ret1 else
5322: LD_ADDR_VAR 0 2
5326: PUSH
5327: LD_INT 3
5329: ST_TO_ADDR
5330: GO 5373
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5332: LD_INT 5
5334: PPUSH
5335: LD_INT 22
5337: PUSH
5338: LD_INT 3
5340: PUSH
5341: EMPTY
5342: LIST
5343: LIST
5344: PPUSH
5345: CALL_OW 70
5349: PUSH
5350: LD_INT 0
5352: EQUAL
5353: IFFALSE 5365
// point := us_ret2 else
5355: LD_ADDR_VAR 0 2
5359: PUSH
5360: LD_INT 2
5362: ST_TO_ADDR
5363: GO 5373
// point := us_ret3 ;
5365: LD_ADDR_VAR 0 2
5369: PUSH
5370: LD_INT 4
5372: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
5373: LD_ADDR_VAR 0 1
5377: PUSH
5378: LD_INT 22
5380: PUSH
5381: LD_INT 1
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: PUSH
5388: LD_INT 21
5390: PUSH
5391: LD_INT 1
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: PUSH
5398: EMPTY
5399: LIST
5400: LIST
5401: PPUSH
5402: CALL_OW 69
5406: PUSH
5407: FOR_IN
5408: IFFALSE 5455
// begin if IsInUnit ( i ) then
5410: LD_VAR 0 1
5414: PPUSH
5415: CALL_OW 310
5419: IFFALSE 5439
// begin ComExitBuilding ( i ) ;
5421: LD_VAR 0 1
5425: PPUSH
5426: CALL_OW 122
// ComExitVehicle ( i ) ;
5430: LD_VAR 0 1
5434: PPUSH
5435: CALL_OW 121
// end ; AddComMoveToArea ( i , point ) ;
5439: LD_VAR 0 1
5443: PPUSH
5444: LD_VAR 0 2
5448: PPUSH
5449: CALL_OW 173
// end ;
5453: GO 5407
5455: POP
5456: POP
// end ;
5457: PPOPN 2
5459: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) do
5460: LD_EXP 21
5464: PUSH
5465: LD_INT 3
5467: PPUSH
5468: LD_INT 22
5470: PUSH
5471: LD_INT 1
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: PPUSH
5478: CALL_OW 70
5482: AND
5483: IFFALSE 5529
5485: GO 5487
5487: DISABLE
// begin enable ;
5488: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) [ 1 ] ) ;
5489: LD_INT 3
5491: PPUSH
5492: LD_INT 22
5494: PUSH
5495: LD_INT 1
5497: PUSH
5498: EMPTY
5499: LIST
5500: LIST
5501: PPUSH
5502: CALL_OW 70
5506: PUSH
5507: LD_INT 1
5509: ARRAY
5510: PPUSH
5511: CALL_OW 64
// if medal1 then
5515: LD_EXP 3
5519: IFFALSE 5529
// medal1 := false ;
5521: LD_ADDR_EXP 3
5525: PUSH
5526: LD_INT 0
5528: ST_TO_ADDR
// end ;
5529: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) do
5530: LD_EXP 21
5534: PUSH
5535: LD_INT 2
5537: PPUSH
5538: LD_INT 22
5540: PUSH
5541: LD_INT 1
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: PPUSH
5548: CALL_OW 70
5552: AND
5553: IFFALSE 5599
5555: GO 5557
5557: DISABLE
// begin enable ;
5558: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) [ 1 ] ) ;
5559: LD_INT 2
5561: PPUSH
5562: LD_INT 22
5564: PUSH
5565: LD_INT 1
5567: PUSH
5568: EMPTY
5569: LIST
5570: LIST
5571: PPUSH
5572: CALL_OW 70
5576: PUSH
5577: LD_INT 1
5579: ARRAY
5580: PPUSH
5581: CALL_OW 64
// if medal1 then
5585: LD_EXP 3
5589: IFFALSE 5599
// medal1 := false ;
5591: LD_ADDR_EXP 3
5595: PUSH
5596: LD_INT 0
5598: ST_TO_ADDR
// end ;
5599: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) do
5600: LD_EXP 21
5604: PUSH
5605: LD_INT 4
5607: PPUSH
5608: LD_INT 22
5610: PUSH
5611: LD_INT 1
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PPUSH
5618: CALL_OW 70
5622: AND
5623: IFFALSE 5669
5625: GO 5627
5627: DISABLE
// begin enable ;
5628: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) [ 1 ] ) ;
5629: LD_INT 4
5631: PPUSH
5632: LD_INT 22
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: PPUSH
5642: CALL_OW 70
5646: PUSH
5647: LD_INT 1
5649: ARRAY
5650: PPUSH
5651: CALL_OW 64
// if medal1 then
5655: LD_EXP 3
5659: IFFALSE 5669
// medal1 := false ;
5661: LD_ADDR_EXP 3
5665: PUSH
5666: LD_INT 0
5668: ST_TO_ADDR
// end ;
5669: END
// every 0 0$03 trigger FilterAllUnits ( [ f_side , 1 ] ) = 0 do
5670: LD_INT 22
5672: PUSH
5673: LD_INT 1
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: PPUSH
5680: CALL_OW 69
5684: PUSH
5685: LD_INT 0
5687: EQUAL
5688: IFFALSE 5701
5690: GO 5692
5692: DISABLE
// us_retreat := false ;
5693: LD_ADDR_EXP 21
5697: PUSH
5698: LD_INT 0
5700: ST_TO_ADDR
5701: END
// export function CounterAttack ; var i , j , un , skill ; begin
5702: LD_INT 0
5704: PPUSH
5705: PPUSH
5706: PPUSH
5707: PPUSH
5708: PPUSH
// uc_side := 1 ;
5709: LD_ADDR_OWVAR 20
5713: PUSH
5714: LD_INT 1
5716: ST_TO_ADDR
// uc_nation := 1 ;
5717: LD_ADDR_OWVAR 21
5721: PUSH
5722: LD_INT 1
5724: ST_TO_ADDR
// skill := [ 4 , 5 , 5 ] [ Difficulty ] ;
5725: LD_ADDR_VAR 0 5
5729: PUSH
5730: LD_INT 4
5732: PUSH
5733: LD_INT 5
5735: PUSH
5736: LD_INT 5
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_OWVAR 67
5748: ARRAY
5749: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
5750: LD_ADDR_VAR 0 2
5754: PUSH
5755: DOUBLE
5756: LD_INT 1
5758: DEC
5759: ST_TO_ADDR
5760: LD_INT 4
5762: PUSH
5763: LD_INT 5
5765: PUSH
5766: LD_INT 6
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: PUSH
5774: LD_OWVAR 67
5778: ARRAY
5779: PUSH
5780: FOR_TO
5781: IFFALSE 5981
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 3 ) ] ;
5783: LD_ADDR_OWVAR 37
5787: PUSH
5788: LD_INT 2
5790: PUSH
5791: LD_INT 3
5793: PUSH
5794: LD_INT 4
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: LIST
5801: PUSH
5802: LD_INT 1
5804: PPUSH
5805: LD_INT 3
5807: PPUSH
5808: CALL_OW 12
5812: ARRAY
5813: ST_TO_ADDR
// vc_engine := engine_combustion ;
5814: LD_ADDR_OWVAR 39
5818: PUSH
5819: LD_INT 1
5821: ST_TO_ADDR
// vc_control := control_manual ;
5822: LD_ADDR_OWVAR 38
5826: PUSH
5827: LD_INT 1
5829: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_light_gun ] [ Rand ( 1 , 3 ) ] ;
5830: LD_ADDR_OWVAR 40
5834: PUSH
5835: LD_INT 4
5837: PUSH
5838: LD_INT 5
5840: PUSH
5841: LD_INT 3
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 1
5851: PPUSH
5852: LD_INT 3
5854: PPUSH
5855: CALL_OW 12
5859: ARRAY
5860: ST_TO_ADDR
// vc_fuel_battery := Rand ( 88 , 99 ) ;
5861: LD_ADDR_OWVAR 41
5865: PUSH
5866: LD_INT 88
5868: PPUSH
5869: LD_INT 99
5871: PPUSH
5872: CALL_OW 12
5876: ST_TO_ADDR
// un := CreateVehicle ;
5877: LD_ADDR_VAR 0 4
5881: PUSH
5882: CALL_OW 45
5886: ST_TO_ADDR
// PlaceUnitXY ( un , 64 , 117 , false ) ;
5887: LD_VAR 0 4
5891: PPUSH
5892: LD_INT 64
5894: PPUSH
5895: LD_INT 117
5897: PPUSH
5898: LD_INT 0
5900: PPUSH
5901: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
5905: LD_INT 0
5907: PPUSH
5908: LD_INT 3
5910: PPUSH
5911: LD_VAR 0 5
5915: PPUSH
5916: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5920: CALL_OW 44
5924: PPUSH
5925: LD_VAR 0 4
5929: PPUSH
5930: CALL_OW 52
// us_force := Insert ( us_force , 1 , un ) ;
5934: LD_ADDR_EXP 12
5938: PUSH
5939: LD_EXP 12
5943: PPUSH
5944: LD_INT 1
5946: PPUSH
5947: LD_VAR 0 4
5951: PPUSH
5952: CALL_OW 2
5956: ST_TO_ADDR
// ComMoveXY ( un , 60 , 109 ) ;
5957: LD_VAR 0 4
5961: PPUSH
5962: LD_INT 60
5964: PPUSH
5965: LD_INT 109
5967: PPUSH
5968: CALL_OW 111
// Wait ( 0 0$02 ) ;
5972: LD_INT 70
5974: PPUSH
5975: CALL_OW 67
// end ;
5979: GO 5780
5981: POP
5982: POP
// RemoveSeeing ( 62 , 113 , 3 ) ;
5983: LD_INT 62
5985: PPUSH
5986: LD_INT 113
5988: PPUSH
5989: LD_INT 3
5991: PPUSH
5992: CALL_OW 331
// while ( FilterAllUnits ( [ f_side , 1 ] ) ) do
5996: LD_INT 22
5998: PUSH
5999: LD_INT 1
6001: PUSH
6002: EMPTY
6003: LIST
6004: LIST
6005: PPUSH
6006: CALL_OW 69
6010: IFFALSE 6211
// begin Wait ( 0 0$01 ) ;
6012: LD_INT 35
6014: PPUSH
6015: CALL_OW 67
// for i = 1 to us_force do
6019: LD_ADDR_VAR 0 2
6023: PUSH
6024: DOUBLE
6025: LD_INT 1
6027: DEC
6028: ST_TO_ADDR
6029: LD_EXP 12
6033: PUSH
6034: FOR_TO
6035: IFFALSE 6070
// ComAttackUnit ( us_force [ i ] , FindTarget ( us_force [ i ] ) ) ;
6037: LD_EXP 12
6041: PUSH
6042: LD_VAR 0 2
6046: ARRAY
6047: PPUSH
6048: LD_EXP 12
6052: PUSH
6053: LD_VAR 0 2
6057: ARRAY
6058: PPUSH
6059: CALL 10434 0 1
6063: PPUSH
6064: CALL_OW 115
6068: GO 6034
6070: POP
6071: POP
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) then
6072: LD_INT 22
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: PUSH
6082: LD_INT 25
6084: PUSH
6085: LD_INT 3
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: PUSH
6092: LD_INT 3
6094: PUSH
6095: LD_INT 55
6097: PUSH
6098: EMPTY
6099: LIST
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: LIST
6109: PPUSH
6110: CALL_OW 69
6114: IFFALSE 6209
// for j in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) do
6116: LD_ADDR_VAR 0 3
6120: PUSH
6121: LD_INT 22
6123: PUSH
6124: LD_INT 1
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: PUSH
6131: LD_INT 25
6133: PUSH
6134: LD_INT 3
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: PUSH
6141: LD_INT 3
6143: PUSH
6144: LD_INT 55
6146: PUSH
6147: EMPTY
6148: LIST
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: PUSH
6154: EMPTY
6155: LIST
6156: LIST
6157: LIST
6158: PPUSH
6159: CALL_OW 69
6163: PUSH
6164: FOR_IN
6165: IFFALSE 6207
// if not IsInArea ( j , conv_end ) then
6167: LD_VAR 0 3
6171: PPUSH
6172: LD_INT 9
6174: PPUSH
6175: CALL_OW 308
6179: NOT
6180: IFFALSE 6196
// ComMoveToArea ( j , conv_end ) else
6182: LD_VAR 0 3
6186: PPUSH
6187: LD_INT 9
6189: PPUSH
6190: CALL_OW 113
6194: GO 6205
// RemoveUnit ( j ) ;
6196: LD_VAR 0 3
6200: PPUSH
6201: CALL_OW 64
6205: GO 6164
6207: POP
6208: POP
// end ;
6209: GO 5996
// end ; end_of_file
6211: LD_VAR 0 1
6215: RET
// export function PrepareArabian ; begin
6216: LD_INT 0
6218: PPUSH
// RobertFarmer ;
6219: CALL 6240 0 0
// PrepareHovercrafts ;
6223: CALL 7114 0 0
// ar_attacks := true ;
6227: LD_ADDR_EXP 10
6231: PUSH
6232: LD_INT 1
6234: ST_TO_ADDR
// end ;
6235: LD_VAR 0 1
6239: RET
// export Farmer ; export function RobertFarmer ; begin
6240: LD_INT 0
6242: PPUSH
// uc_side := 2 ;
6243: LD_ADDR_OWVAR 20
6247: PUSH
6248: LD_INT 2
6250: ST_TO_ADDR
// uc_nation := 2 ;
6251: LD_ADDR_OWVAR 21
6255: PUSH
6256: LD_INT 2
6258: ST_TO_ADDR
// Farmer := NewCharacter ( Farmer ) ;
6259: LD_ADDR_EXP 24
6263: PUSH
6264: LD_STRING Farmer
6266: PPUSH
6267: CALL_OW 25
6271: ST_TO_ADDR
// SayRadio ( Farmer , DPM_F1 ) ;
6272: LD_EXP 24
6276: PPUSH
6277: LD_STRING DPM_F1
6279: PPUSH
6280: CALL_OW 94
// end ;
6284: LD_VAR 0 1
6288: RET
// export function PrepareAttack ( type ) ; var i , un , veh , skill ; begin
6289: LD_INT 0
6291: PPUSH
6292: PPUSH
6293: PPUSH
6294: PPUSH
6295: PPUSH
// uc_side := 2 ;
6296: LD_ADDR_OWVAR 20
6300: PUSH
6301: LD_INT 2
6303: ST_TO_ADDR
// uc_nation := 2 ;
6304: LD_ADDR_OWVAR 21
6308: PUSH
6309: LD_INT 2
6311: ST_TO_ADDR
// skill := [ 4 , 6 , 7 ] [ Difficulty ] ;
6312: LD_ADDR_VAR 0 6
6316: PUSH
6317: LD_INT 4
6319: PUSH
6320: LD_INT 6
6322: PUSH
6323: LD_INT 7
6325: PUSH
6326: EMPTY
6327: LIST
6328: LIST
6329: LIST
6330: PUSH
6331: LD_OWVAR 67
6335: ARRAY
6336: ST_TO_ADDR
// Randomize ;
6337: CALL_OW 10
// case type of 1 :
6341: LD_VAR 0 1
6345: PUSH
6346: LD_INT 1
6348: DOUBLE
6349: EQUAL
6350: IFTRUE 6354
6352: GO 6476
6354: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
6355: LD_ADDR_VAR 0 3
6359: PUSH
6360: DOUBLE
6361: LD_INT 1
6363: DEC
6364: ST_TO_ADDR
6365: LD_INT 3
6367: PUSH
6368: LD_INT 4
6370: PUSH
6371: LD_INT 5
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: LIST
6378: PUSH
6379: LD_OWVAR 67
6383: ARRAY
6384: PUSH
6385: FOR_TO
6386: IFFALSE 6472
// begin PrepareHuman ( false , [ class_soldier , class_soldier , class_mortar ] [ Rand ( 1 , 3 ) ] , skill ) ;
6388: LD_INT 0
6390: PPUSH
6391: LD_INT 1
6393: PUSH
6394: LD_INT 1
6396: PUSH
6397: LD_INT 8
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: LIST
6404: PUSH
6405: LD_INT 1
6407: PPUSH
6408: LD_INT 3
6410: PPUSH
6411: CALL_OW 12
6415: ARRAY
6416: PPUSH
6417: LD_VAR 0 6
6421: PPUSH
6422: CALL_OW 380
// un := CreateHuman ;
6426: LD_ADDR_VAR 0 4
6430: PUSH
6431: CALL_OW 44
6435: ST_TO_ADDR
// PlaceUnitArea ( un , ar3 , false ) ;
6436: LD_VAR 0 4
6440: PPUSH
6441: LD_INT 18
6443: PPUSH
6444: LD_INT 0
6446: PPUSH
6447: CALL_OW 49
// ComMoveToArea ( un , spot3 ) ;
6451: LD_VAR 0 4
6455: PPUSH
6456: LD_INT 20
6458: PPUSH
6459: CALL_OW 113
// Wait ( 0 0$01 ) ;
6463: LD_INT 35
6465: PPUSH
6466: CALL_OW 67
// end ;
6470: GO 6385
6472: POP
6473: POP
// end ; 2 :
6474: GO 7109
6476: LD_INT 2
6478: DOUBLE
6479: EQUAL
6480: IFTRUE 6484
6482: GO 6751
6484: POP
// begin for i = 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
6485: LD_ADDR_VAR 0 3
6489: PUSH
6490: DOUBLE
6491: LD_INT 1
6493: DEC
6494: ST_TO_ADDR
6495: LD_INT 4
6497: PUSH
6498: LD_INT 5
6500: PUSH
6501: LD_INT 5
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: LIST
6508: PUSH
6509: LD_OWVAR 67
6513: ARRAY
6514: PUSH
6515: FOR_TO
6516: IFFALSE 6579
// begin PrepareHuman ( false , class_soldier , skill ) ;
6518: LD_INT 0
6520: PPUSH
6521: LD_INT 1
6523: PPUSH
6524: LD_VAR 0 6
6528: PPUSH
6529: CALL_OW 380
// un := CreateHuman ;
6533: LD_ADDR_VAR 0 4
6537: PUSH
6538: CALL_OW 44
6542: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6543: LD_VAR 0 4
6547: PPUSH
6548: LD_INT 17
6550: PPUSH
6551: LD_INT 0
6553: PPUSH
6554: CALL_OW 49
// ComMoveToArea ( un , spot2 ) ;
6558: LD_VAR 0 4
6562: PPUSH
6563: LD_INT 19
6565: PPUSH
6566: CALL_OW 113
// Wait ( 0 0$01 ) ;
6570: LD_INT 35
6572: PPUSH
6573: CALL_OW 67
// end ;
6577: GO 6515
6579: POP
6580: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
6581: LD_ADDR_VAR 0 3
6585: PUSH
6586: DOUBLE
6587: LD_INT 1
6589: DEC
6590: ST_TO_ADDR
6591: LD_INT 2
6593: PUSH
6594: LD_INT 3
6596: PUSH
6597: LD_INT 4
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: LIST
6604: PUSH
6605: LD_OWVAR 67
6609: ARRAY
6610: PUSH
6611: FOR_TO
6612: IFFALSE 6747
// begin vc_chassis := ar_medium_trike ;
6614: LD_ADDR_OWVAR 37
6618: PUSH
6619: LD_INT 13
6621: ST_TO_ADDR
// vc_engine := engine_combustion ;
6622: LD_ADDR_OWVAR 39
6626: PUSH
6627: LD_INT 1
6629: ST_TO_ADDR
// vc_control := control_manual ;
6630: LD_ADDR_OWVAR 38
6634: PUSH
6635: LD_INT 1
6637: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_light_gun , ar_gun ] [ Rand ( 1 , 3 ) ] ;
6638: LD_ADDR_OWVAR 40
6642: PUSH
6643: LD_INT 24
6645: PUSH
6646: LD_INT 23
6648: PUSH
6649: LD_INT 27
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: LIST
6656: PUSH
6657: LD_INT 1
6659: PPUSH
6660: LD_INT 3
6662: PPUSH
6663: CALL_OW 12
6667: ARRAY
6668: ST_TO_ADDR
// veh := CreateVehicle ;
6669: LD_ADDR_VAR 0 5
6673: PUSH
6674: CALL_OW 45
6678: ST_TO_ADDR
// PlaceUnitArea ( veh , ar2 , false ) ;
6679: LD_VAR 0 5
6683: PPUSH
6684: LD_INT 17
6686: PPUSH
6687: LD_INT 0
6689: PPUSH
6690: CALL_OW 49
// PrepareHuman ( false , 1 , skill ) ;
6694: LD_INT 0
6696: PPUSH
6697: LD_INT 1
6699: PPUSH
6700: LD_VAR 0 6
6704: PPUSH
6705: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6709: CALL_OW 44
6713: PPUSH
6714: LD_VAR 0 5
6718: PPUSH
6719: CALL_OW 52
// ComMoveXY ( veh , 89 , 40 ) ;
6723: LD_VAR 0 5
6727: PPUSH
6728: LD_INT 89
6730: PPUSH
6731: LD_INT 40
6733: PPUSH
6734: CALL_OW 111
// Wait ( 0 0$02 ) ;
6738: LD_INT 70
6740: PPUSH
6741: CALL_OW 67
// end ;
6745: GO 6611
6747: POP
6748: POP
// end ; 3 :
6749: GO 7109
6751: LD_INT 3
6753: DOUBLE
6754: EQUAL
6755: IFTRUE 6759
6757: GO 7108
6759: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] + ( tick div 15 15$00 ) do
6760: LD_ADDR_VAR 0 3
6764: PUSH
6765: DOUBLE
6766: LD_INT 1
6768: DEC
6769: ST_TO_ADDR
6770: LD_INT 3
6772: PUSH
6773: LD_INT 4
6775: PUSH
6776: LD_INT 5
6778: PUSH
6779: EMPTY
6780: LIST
6781: LIST
6782: LIST
6783: PUSH
6784: LD_OWVAR 67
6788: ARRAY
6789: PUSH
6790: LD_OWVAR 1
6794: PUSH
6795: LD_INT 31500
6797: DIV
6798: PLUS
6799: PUSH
6800: FOR_TO
6801: IFFALSE 6909
// begin PrepareHuman ( false , [ class_soldier , class_mortar ] [ Rand ( 1 , 2 ) ] , skill ) ;
6803: LD_INT 0
6805: PPUSH
6806: LD_INT 1
6808: PUSH
6809: LD_INT 8
6811: PUSH
6812: EMPTY
6813: LIST
6814: LIST
6815: PUSH
6816: LD_INT 1
6818: PPUSH
6819: LD_INT 2
6821: PPUSH
6822: CALL_OW 12
6826: ARRAY
6827: PPUSH
6828: LD_VAR 0 6
6832: PPUSH
6833: CALL_OW 380
// un := CreateHuman ;
6837: LD_ADDR_VAR 0 4
6841: PUSH
6842: CALL_OW 44
6846: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6847: LD_VAR 0 4
6851: PPUSH
6852: LD_INT 17
6854: PPUSH
6855: LD_INT 0
6857: PPUSH
6858: CALL_OW 49
// ar_force := Insert ( ar_force , 1 , un ) ;
6862: LD_ADDR_EXP 11
6866: PUSH
6867: LD_EXP 11
6871: PPUSH
6872: LD_INT 1
6874: PPUSH
6875: LD_VAR 0 4
6879: PPUSH
6880: CALL_OW 2
6884: ST_TO_ADDR
// ComMoveXY ( un , 17 , 9 ) ;
6885: LD_VAR 0 4
6889: PPUSH
6890: LD_INT 17
6892: PPUSH
6893: LD_INT 9
6895: PPUSH
6896: CALL_OW 111
// Wait ( 0 0$01 ) ;
6900: LD_INT 35
6902: PPUSH
6903: CALL_OW 67
// end ;
6907: GO 6800
6909: POP
6910: POP
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6911: LD_ADDR_VAR 0 3
6915: PUSH
6916: DOUBLE
6917: LD_INT 1
6919: DEC
6920: ST_TO_ADDR
6921: LD_INT 4
6923: PUSH
6924: LD_INT 5
6926: PUSH
6927: LD_INT 6
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: PUSH
6935: LD_OWVAR 67
6939: ARRAY
6940: PUSH
6941: FOR_TO
6942: IFFALSE 7104
// begin vc_chassis := ar_half_tracked ;
6944: LD_ADDR_OWVAR 37
6948: PUSH
6949: LD_INT 14
6951: ST_TO_ADDR
// vc_engine := engine_combustion ;
6952: LD_ADDR_OWVAR 39
6956: PUSH
6957: LD_INT 1
6959: ST_TO_ADDR
// vc_control := control_manual ;
6960: LD_ADDR_OWVAR 38
6964: PUSH
6965: LD_INT 1
6967: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_flame_thrower ] [ Rand ( 1 , 4 ) ] ;
6968: LD_ADDR_OWVAR 40
6972: PUSH
6973: LD_INT 25
6975: PUSH
6976: LD_INT 27
6978: PUSH
6979: LD_INT 28
6981: PUSH
6982: LD_INT 26
6984: PUSH
6985: EMPTY
6986: LIST
6987: LIST
6988: LIST
6989: LIST
6990: PUSH
6991: LD_INT 1
6993: PPUSH
6994: LD_INT 4
6996: PPUSH
6997: CALL_OW 12
7001: ARRAY
7002: ST_TO_ADDR
// veh := CreateVehicle ;
7003: LD_ADDR_VAR 0 5
7007: PUSH
7008: CALL_OW 45
7012: ST_TO_ADDR
// PlaceUnitArea ( veh , ar1 , false ) ;
7013: LD_VAR 0 5
7017: PPUSH
7018: LD_INT 16
7020: PPUSH
7021: LD_INT 0
7023: PPUSH
7024: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7028: LD_INT 0
7030: PPUSH
7031: LD_INT 3
7033: PPUSH
7034: LD_VAR 0 6
7038: PPUSH
7039: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
7043: CALL_OW 44
7047: PPUSH
7048: LD_VAR 0 5
7052: PPUSH
7053: CALL_OW 52
// ar_force := Insert ( ar_force , 1 , veh ) ;
7057: LD_ADDR_EXP 11
7061: PUSH
7062: LD_EXP 11
7066: PPUSH
7067: LD_INT 1
7069: PPUSH
7070: LD_VAR 0 5
7074: PPUSH
7075: CALL_OW 2
7079: ST_TO_ADDR
// ComMoveXY ( veh , 125 , 31 ) ;
7080: LD_VAR 0 5
7084: PPUSH
7085: LD_INT 125
7087: PPUSH
7088: LD_INT 31
7090: PPUSH
7091: CALL_OW 111
// Wait ( 0 0$02 ) ;
7095: LD_INT 70
7097: PPUSH
7098: CALL_OW 67
// end ;
7102: GO 6941
7104: POP
7105: POP
// end ; end ;
7106: GO 7109
7108: POP
// end ;
7109: LD_VAR 0 2
7113: RET
// export function PrepareHovercrafts ; var i , un , areas , skill ; begin
7114: LD_INT 0
7116: PPUSH
7117: PPUSH
7118: PPUSH
7119: PPUSH
7120: PPUSH
// areas := [ river1 , river2 ] ;
7121: LD_ADDR_VAR 0 4
7125: PUSH
7126: LD_INT 14
7128: PUSH
7129: LD_INT 15
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7136: LD_ADDR_VAR 0 5
7140: PUSH
7141: LD_INT 5
7143: PUSH
7144: LD_INT 6
7146: PUSH
7147: LD_INT 7
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: LIST
7154: PUSH
7155: LD_OWVAR 67
7159: ARRAY
7160: ST_TO_ADDR
// uc_side := 2 ;
7161: LD_ADDR_OWVAR 20
7165: PUSH
7166: LD_INT 2
7168: ST_TO_ADDR
// uc_nation := 2 ;
7169: LD_ADDR_OWVAR 21
7173: PUSH
7174: LD_INT 2
7176: ST_TO_ADDR
// hc_name :=  ;
7177: LD_ADDR_OWVAR 26
7181: PUSH
7182: LD_STRING 
7184: ST_TO_ADDR
// hc_gallery :=  ;
7185: LD_ADDR_OWVAR 33
7189: PUSH
7190: LD_STRING 
7192: ST_TO_ADDR
// for i = 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
7193: LD_ADDR_VAR 0 2
7197: PUSH
7198: DOUBLE
7199: LD_INT 1
7201: DEC
7202: ST_TO_ADDR
7203: LD_INT 1
7205: PUSH
7206: LD_INT 2
7208: PUSH
7209: LD_INT 2
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: LIST
7216: PUSH
7217: LD_OWVAR 67
7221: ARRAY
7222: PUSH
7223: FOR_TO
7224: IFFALSE 7362
// begin vc_chassis := ar_hovercraft ;
7226: LD_ADDR_OWVAR 37
7230: PUSH
7231: LD_INT 11
7233: ST_TO_ADDR
// vc_engine := engine_solar ;
7234: LD_ADDR_OWVAR 39
7238: PUSH
7239: LD_INT 2
7241: ST_TO_ADDR
// vc_control := control_manual ;
7242: LD_ADDR_OWVAR 38
7246: PUSH
7247: LD_INT 1
7249: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
7250: LD_ADDR_OWVAR 40
7254: PUSH
7255: LD_INT 24
7257: ST_TO_ADDR
// vc_fuel_battery := 100 ;
7258: LD_ADDR_OWVAR 41
7262: PUSH
7263: LD_INT 100
7265: ST_TO_ADDR
// un := CreateVehicle ;
7266: LD_ADDR_VAR 0 3
7270: PUSH
7271: CALL_OW 45
7275: ST_TO_ADDR
// PlaceUnitArea ( un , areas [ i ] , false ) ;
7276: LD_VAR 0 3
7280: PPUSH
7281: LD_VAR 0 4
7285: PUSH
7286: LD_VAR 0 2
7290: ARRAY
7291: PPUSH
7292: LD_INT 0
7294: PPUSH
7295: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7299: LD_INT 0
7301: PPUSH
7302: LD_INT 3
7304: PPUSH
7305: LD_VAR 0 5
7309: PPUSH
7310: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
7314: CALL_OW 44
7318: PPUSH
7319: LD_VAR 0 3
7323: PPUSH
7324: CALL_OW 52
// riv := Insert ( riv , 1 , [ un , i ] ) ;
7328: LD_ADDR_EXP 9
7332: PUSH
7333: LD_EXP 9
7337: PPUSH
7338: LD_INT 1
7340: PPUSH
7341: LD_VAR 0 3
7345: PUSH
7346: LD_VAR 0 2
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: PPUSH
7355: CALL_OW 2
7359: ST_TO_ADDR
// end ;
7360: GO 7223
7362: POP
7363: POP
// end ;
7364: LD_VAR 0 1
7368: RET
// every 0 0$01 trigger riv do var i , c ;
7369: LD_EXP 9
7373: IFFALSE 7808
7375: GO 7377
7377: DISABLE
7378: LD_INT 0
7380: PPUSH
7381: PPUSH
// begin enable ;
7382: ENABLE
// for i = riv downto 1 do
7383: LD_ADDR_VAR 0 1
7387: PUSH
7388: DOUBLE
7389: LD_EXP 9
7393: INC
7394: ST_TO_ADDR
7395: LD_INT 1
7397: PUSH
7398: FOR_DOWNTO
7399: IFFALSE 7806
// begin if not riv [ i ] [ 1 ] then
7401: LD_EXP 9
7405: PUSH
7406: LD_VAR 0 1
7410: ARRAY
7411: PUSH
7412: LD_INT 1
7414: ARRAY
7415: NOT
7416: IFFALSE 7438
// begin riv := Delete ( riv , 1 ) ;
7418: LD_ADDR_EXP 9
7422: PUSH
7423: LD_EXP 9
7427: PPUSH
7428: LD_INT 1
7430: PPUSH
7431: CALL_OW 3
7435: ST_TO_ADDR
// break ;
7436: GO 7806
// end ; if not HasTask ( riv [ i ] [ 1 ] ) then
7438: LD_EXP 9
7442: PUSH
7443: LD_VAR 0 1
7447: ARRAY
7448: PUSH
7449: LD_INT 1
7451: ARRAY
7452: PPUSH
7453: CALL_OW 314
7457: NOT
7458: IFFALSE 7526
// begin if riv [ i ] [ 2 ] = 1 then
7460: LD_EXP 9
7464: PUSH
7465: LD_VAR 0 1
7469: ARRAY
7470: PUSH
7471: LD_INT 2
7473: ARRAY
7474: PUSH
7475: LD_INT 1
7477: EQUAL
7478: IFFALSE 7490
// c := 2 else
7480: LD_ADDR_VAR 0 2
7484: PUSH
7485: LD_INT 2
7487: ST_TO_ADDR
7488: GO 7498
// c := 1 ;
7490: LD_ADDR_VAR 0 2
7494: PUSH
7495: LD_INT 1
7497: ST_TO_ADDR
// riv := Replace2 ( riv , i , 2 , c ) ;
7498: LD_ADDR_EXP 9
7502: PUSH
7503: LD_EXP 9
7507: PPUSH
7508: LD_VAR 0 1
7512: PPUSH
7513: LD_INT 2
7515: PPUSH
7516: LD_VAR 0 2
7520: PPUSH
7521: CALL 10126 0 4
7525: ST_TO_ADDR
// end ; if not IsInArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) then
7526: LD_EXP 9
7530: PUSH
7531: LD_VAR 0 1
7535: ARRAY
7536: PUSH
7537: LD_INT 1
7539: ARRAY
7540: PPUSH
7541: LD_INT 14
7543: PUSH
7544: LD_INT 15
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PUSH
7551: LD_EXP 9
7555: PUSH
7556: LD_VAR 0 1
7560: ARRAY
7561: PUSH
7562: LD_INT 2
7564: ARRAY
7565: ARRAY
7566: PPUSH
7567: CALL_OW 308
7571: NOT
7572: IFFALSE 7804
// begin if GetFuel ( riv [ i ] [ 1 ] ) < 50 then
7574: LD_EXP 9
7578: PUSH
7579: LD_VAR 0 1
7583: ARRAY
7584: PUSH
7585: LD_INT 1
7587: ARRAY
7588: PPUSH
7589: CALL_OW 261
7593: PUSH
7594: LD_INT 50
7596: LESS
7597: IFFALSE 7621
// SetFuel ( riv [ i ] [ 1 ] , 67 ) ;
7599: LD_EXP 9
7603: PUSH
7604: LD_VAR 0 1
7608: ARRAY
7609: PUSH
7610: LD_INT 1
7612: ARRAY
7613: PPUSH
7614: LD_INT 67
7616: PPUSH
7617: CALL_OW 240
// if GetDistUnits ( riv [ i ] [ 1 ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 3 ] ) , riv [ i ] [ 1 ] ) ) < 9 then
7621: LD_EXP 9
7625: PUSH
7626: LD_VAR 0 1
7630: ARRAY
7631: PUSH
7632: LD_INT 1
7634: ARRAY
7635: PPUSH
7636: LD_INT 22
7638: PUSH
7639: LD_INT 3
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PPUSH
7646: CALL_OW 69
7650: PPUSH
7651: LD_EXP 9
7655: PUSH
7656: LD_VAR 0 1
7660: ARRAY
7661: PUSH
7662: LD_INT 1
7664: ARRAY
7665: PPUSH
7666: CALL_OW 74
7670: PPUSH
7671: CALL_OW 296
7675: PUSH
7676: LD_INT 9
7678: LESS
7679: IFFALSE 7737
// ComAttackUnit ( riv [ i ] [ 1 ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 3 ] ) , riv [ i ] [ 1 ] ) ) else
7681: LD_EXP 9
7685: PUSH
7686: LD_VAR 0 1
7690: ARRAY
7691: PUSH
7692: LD_INT 1
7694: ARRAY
7695: PPUSH
7696: LD_INT 22
7698: PUSH
7699: LD_INT 3
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PPUSH
7706: CALL_OW 69
7710: PPUSH
7711: LD_EXP 9
7715: PUSH
7716: LD_VAR 0 1
7720: ARRAY
7721: PUSH
7722: LD_INT 1
7724: ARRAY
7725: PPUSH
7726: CALL_OW 74
7730: PPUSH
7731: CALL_OW 115
7735: GO 7804
// begin ComMoveToArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) ;
7737: LD_EXP 9
7741: PUSH
7742: LD_VAR 0 1
7746: ARRAY
7747: PUSH
7748: LD_INT 1
7750: ARRAY
7751: PPUSH
7752: LD_INT 14
7754: PUSH
7755: LD_INT 15
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: PUSH
7762: LD_EXP 9
7766: PUSH
7767: LD_VAR 0 1
7771: ARRAY
7772: PUSH
7773: LD_INT 2
7775: ARRAY
7776: ARRAY
7777: PPUSH
7778: CALL_OW 113
// AddComWait ( riv [ i ] [ 1 ] , 0 0$10 ) ;
7782: LD_EXP 9
7786: PUSH
7787: LD_VAR 0 1
7791: ARRAY
7792: PUSH
7793: LD_INT 1
7795: ARRAY
7796: PPUSH
7797: LD_INT 350
7799: PPUSH
7800: CALL_OW 202
// end ; end ; end ;
7804: GO 7398
7806: POP
7807: POP
// end ;
7808: PPOPN 2
7810: END
// every 10 10$00 trigger convoy_start do var i , un ;
7811: LD_EXP 7
7815: IFFALSE 7936
7817: GO 7819
7819: DISABLE
7820: LD_INT 0
7822: PPUSH
7823: PPUSH
// begin enable ;
7824: ENABLE
// for i = 1 to 2 do
7825: LD_ADDR_VAR 0 1
7829: PUSH
7830: DOUBLE
7831: LD_INT 1
7833: DEC
7834: ST_TO_ADDR
7835: LD_INT 2
7837: PUSH
7838: FOR_TO
7839: IFFALSE 7934
// begin uc_side := 2 ;
7841: LD_ADDR_OWVAR 20
7845: PUSH
7846: LD_INT 2
7848: ST_TO_ADDR
// uc_nation := 2 ;
7849: LD_ADDR_OWVAR 21
7853: PUSH
7854: LD_INT 2
7856: ST_TO_ADDR
// PrepareHuman ( false , 1 , 4 ) ;
7857: LD_INT 0
7859: PPUSH
7860: LD_INT 1
7862: PPUSH
7863: LD_INT 4
7865: PPUSH
7866: CALL_OW 380
// un := CreateHuman ;
7870: LD_ADDR_VAR 0 2
7874: PUSH
7875: CALL_OW 44
7879: ST_TO_ADDR
// PlaceUnitXY ( un , 10 , 2 , false ) ;
7880: LD_VAR 0 2
7884: PPUSH
7885: LD_INT 10
7887: PPUSH
7888: LD_INT 2
7890: PPUSH
7891: LD_INT 0
7893: PPUSH
7894: CALL_OW 48
// ComMoveXY ( un , 24 , 36 ) ;
7898: LD_VAR 0 2
7902: PPUSH
7903: LD_INT 24
7905: PPUSH
7906: LD_INT 36
7908: PPUSH
7909: CALL_OW 111
// AddComMoveToArea ( un , conv_end ) ;
7913: LD_VAR 0 2
7917: PPUSH
7918: LD_INT 9
7920: PPUSH
7921: CALL_OW 173
// Wait ( 0 0$02 ) ;
7925: LD_INT 70
7927: PPUSH
7928: CALL_OW 67
// end ;
7932: GO 7838
7934: POP
7935: POP
// end ;
7936: PPOPN 2
7938: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , rest ;
7939: LD_INT 22
7941: PUSH
7942: LD_INT 2
7944: PUSH
7945: EMPTY
7946: LIST
7947: LIST
7948: PPUSH
7949: CALL_OW 69
7953: IFFALSE 8264
7955: GO 7957
7957: DISABLE
7958: LD_INT 0
7960: PPUSH
7961: PPUSH
// begin enable ;
7962: ENABLE
// rest := FilterAllUnits ( [ f_side , 2 ] ) diff ar_force ;
7963: LD_ADDR_VAR 0 2
7967: PUSH
7968: LD_INT 22
7970: PUSH
7971: LD_INT 2
7973: PUSH
7974: EMPTY
7975: LIST
7976: LIST
7977: PPUSH
7978: CALL_OW 69
7982: PUSH
7983: LD_EXP 11
7987: DIFF
7988: ST_TO_ADDR
// if rest then
7989: LD_VAR 0 2
7993: IFFALSE 8065
// for i in rest do
7995: LD_ADDR_VAR 0 1
7999: PUSH
8000: LD_VAR 0 2
8004: PUSH
8005: FOR_IN
8006: IFFALSE 8063
// if GetClass ( i ) = 3 then
8008: LD_VAR 0 1
8012: PPUSH
8013: CALL_OW 257
8017: PUSH
8018: LD_INT 3
8020: EQUAL
8021: IFFALSE 8061
// begin if not IsInArea ( i , ar2 ) then
8023: LD_VAR 0 1
8027: PPUSH
8028: LD_INT 17
8030: PPUSH
8031: CALL_OW 308
8035: NOT
8036: IFFALSE 8052
// ComMoveToArea ( i , ar2 ) else
8038: LD_VAR 0 1
8042: PPUSH
8043: LD_INT 17
8045: PPUSH
8046: CALL_OW 113
8050: GO 8061
// RemoveUnit ( i ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: CALL_OW 64
// end ;
8061: GO 8005
8063: POP
8064: POP
// if ar_force then
8065: LD_EXP 11
8069: IFFALSE 8264
// for i in ar_force do
8071: LD_ADDR_VAR 0 1
8075: PUSH
8076: LD_EXP 11
8080: PUSH
8081: FOR_IN
8082: IFFALSE 8262
// begin if GetClass ( i ) = class_soldier then
8084: LD_VAR 0 1
8088: PPUSH
8089: CALL_OW 257
8093: PUSH
8094: LD_INT 1
8096: EQUAL
8097: IFFALSE 8189
// if FindTarget ( i ) in FilterAllUnits ( [ f_type , unit_building ] ) then
8099: LD_VAR 0 1
8103: PPUSH
8104: CALL 10434 0 1
8108: PUSH
8109: LD_INT 21
8111: PUSH
8112: LD_INT 3
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PPUSH
8119: CALL_OW 69
8123: IN
8124: IFFALSE 8170
// ComPlaceDelayedCharge ( i , GetX ( FindTarget ( i ) ) , GetY ( FindTarget ( i ) ) , 0 ) else
8126: LD_VAR 0 1
8130: PPUSH
8131: LD_VAR 0 1
8135: PPUSH
8136: CALL 10434 0 1
8140: PPUSH
8141: CALL_OW 250
8145: PPUSH
8146: LD_VAR 0 1
8150: PPUSH
8151: CALL 10434 0 1
8155: PPUSH
8156: CALL_OW 251
8160: PPUSH
8161: LD_INT 0
8163: PPUSH
8164: CALL_OW 132
8168: GO 8189
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8170: LD_VAR 0 1
8174: PPUSH
8175: LD_VAR 0 1
8179: PPUSH
8180: CALL 10434 0 1
8184: PPUSH
8185: CALL_OW 115
// if not GetClass ( i ) = 1 then
8189: LD_VAR 0 1
8193: PPUSH
8194: CALL_OW 257
8198: PUSH
8199: LD_INT 1
8201: EQUAL
8202: NOT
8203: IFFALSE 8224
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8205: LD_VAR 0 1
8209: PPUSH
8210: LD_VAR 0 1
8214: PPUSH
8215: CALL 10434 0 1
8219: PPUSH
8220: CALL_OW 115
// if GetDistUnitXY ( i , 65 , 118 ) < 40 then
8224: LD_VAR 0 1
8228: PPUSH
8229: LD_INT 65
8231: PPUSH
8232: LD_INT 118
8234: PPUSH
8235: CALL_OW 297
8239: PUSH
8240: LD_INT 40
8242: LESS
8243: IFFALSE 8260
// ComMoveXY ( i , 65 , 118 ) ;
8245: LD_VAR 0 1
8249: PPUSH
8250: LD_INT 65
8252: PPUSH
8253: LD_INT 118
8255: PPUSH
8256: CALL_OW 111
// end ;
8260: GO 8081
8262: POP
8263: POP
// end ;
8264: PPOPN 2
8266: END
// every 0 0$01 trigger FilterUnitsInArea ( conv_end , [ f_side , 2 ] ) do
8267: LD_INT 9
8269: PPUSH
8270: LD_INT 22
8272: PUSH
8273: LD_INT 2
8275: PUSH
8276: EMPTY
8277: LIST
8278: LIST
8279: PPUSH
8280: CALL_OW 70
8284: IFFALSE 8297
8286: GO 8288
8288: DISABLE
// medal2 := false ; end_of_file
8289: LD_ADDR_EXP 4
8293: PUSH
8294: LD_INT 0
8296: ST_TO_ADDR
8297: END
// export function Action ; begin
8298: LD_INT 0
8300: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
8301: LD_ADDR_OWVAR 67
8305: PUSH
8306: LD_INT 0
8308: PPUSH
8309: CALL_OW 426
8313: ST_TO_ADDR
// case Query ( info ) of 1 :
8314: LD_STRING info
8316: PPUSH
8317: CALL_OW 97
8321: PUSH
8322: LD_INT 1
8324: DOUBLE
8325: EQUAL
8326: IFTRUE 8330
8328: GO 8333
8330: POP
// ; end ;
8331: GO 8334
8333: POP
// ChangeMissionObjectives ( PM_1 ) ;
8334: LD_STRING PM_1
8336: PPUSH
8337: CALL_OW 337
// SaveForQuickRestart ;
8341: CALL_OW 22
// end ;
8345: LD_VAR 0 1
8349: RET
// every 0 0$01 trigger GetSide ( us_depot ) = 3 do
8350: LD_INT 50
8352: PPUSH
8353: CALL_OW 255
8357: PUSH
8358: LD_INT 3
8360: EQUAL
8361: IFFALSE 8642
8363: GO 8365
8365: DISABLE
// begin Say ( Stolypin , DPM_S1 ) ;
8366: LD_EXP 15
8370: PPUSH
8371: LD_STRING DPM_S1
8373: PPUSH
8374: CALL_OW 88
// SayRadio ( Popov , DPM_P1 ) ;
8378: LD_EXP 16
8382: PPUSH
8383: LD_STRING DPM_P1
8385: PPUSH
8386: CALL_OW 94
// Say ( Stolypin , DPM_S2 ) ;
8390: LD_EXP 15
8394: PPUSH
8395: LD_STRING DPM_S2
8397: PPUSH
8398: CALL_OW 88
// SaveForQuickRestart ;
8402: CALL_OW 22
// ChangeMissionObjectives ( PM_2 ) ;
8406: LD_STRING PM_2
8408: PPUSH
8409: CALL_OW 337
// Wait ( 2 2$30 ) ;
8413: LD_INT 5250
8415: PPUSH
8416: CALL_OW 67
// CenterOnXY ( 117 , 4 ) ;
8420: LD_INT 117
8422: PPUSH
8423: LD_INT 4
8425: PPUSH
8426: CALL_OW 84
// Convoy ( 1 ) ;
8430: LD_INT 1
8432: PPUSH
8433: CALL 883 0 1
// Wait ( 0 0$30 ) ;
8437: LD_INT 1050
8439: PPUSH
8440: CALL_OW 67
// Convoy ( 2 ) ;
8444: LD_INT 2
8446: PPUSH
8447: CALL 883 0 1
// Wait ( 1 1$30 ) ;
8451: LD_INT 3150
8453: PPUSH
8454: CALL_OW 67
// Convoy ( 3 ) ;
8458: LD_INT 3
8460: PPUSH
8461: CALL 883 0 1
// Wait ( 5 5$00 ) ;
8465: LD_INT 10500
8467: PPUSH
8468: CALL_OW 67
// convoy_start := true ;
8472: LD_ADDR_EXP 7
8476: PUSH
8477: LD_INT 1
8479: ST_TO_ADDR
// PrepareArabian ;
8480: CALL 6216 0 0
// PrepareAttack ( 1 ) ;
8484: LD_INT 1
8486: PPUSH
8487: CALL 6289 0 1
// while ( convoy_start ) do
8491: LD_EXP 7
8495: IFFALSE 8642
// begin Wait ( Rand ( 2 2$00 , 4 4$00 ) ) ;
8497: LD_INT 4200
8499: PPUSH
8500: LD_INT 8400
8502: PPUSH
8503: CALL_OW 12
8507: PPUSH
8508: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) < 20 then
8512: LD_INT 22
8514: PUSH
8515: LD_INT 2
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: PPUSH
8522: CALL_OW 69
8526: PUSH
8527: LD_INT 20
8529: LESS
8530: IFFALSE 8547
// PrepareAttack ( Rand ( 1 , 2 ) ) ;
8532: LD_INT 1
8534: PPUSH
8535: LD_INT 2
8537: PPUSH
8538: CALL_OW 12
8542: PPUSH
8543: CALL 6289 0 1
// Convoy ( Rand ( 1 , 5 ) ) ;
8547: LD_INT 1
8549: PPUSH
8550: LD_INT 5
8552: PPUSH
8553: CALL_OW 12
8557: PPUSH
8558: CALL 883 0 1
// conv_counter := conv_counter + 1 ;
8562: LD_ADDR_EXP 13
8566: PUSH
8567: LD_EXP 13
8571: PUSH
8572: LD_INT 1
8574: PLUS
8575: ST_TO_ADDR
// if conv_counter mod [ 5 , 4 , 3 ] [ Difficulty ] = 0 then
8576: LD_EXP 13
8580: PUSH
8581: LD_INT 5
8583: PUSH
8584: LD_INT 4
8586: PUSH
8587: LD_INT 3
8589: PUSH
8590: EMPTY
8591: LIST
8592: LIST
8593: LIST
8594: PUSH
8595: LD_OWVAR 67
8599: ARRAY
8600: MOD
8601: PUSH
8602: LD_INT 0
8604: EQUAL
8605: IFFALSE 8640
// begin Wait ( 1 1$20 ) ;
8607: LD_INT 2800
8609: PPUSH
8610: CALL_OW 67
// SayRadio ( Farmer , DPM_F2 ) ;
8614: LD_EXP 24
8618: PPUSH
8619: LD_STRING DPM_F2
8621: PPUSH
8622: CALL_OW 94
// PrepareAttack ( 3 ) ;
8626: LD_INT 3
8628: PPUSH
8629: CALL 6289 0 1
// Wait ( 4 4$00 ) ;
8633: LD_INT 8400
8635: PPUSH
8636: CALL_OW 67
// end ; end ;
8640: GO 8491
// end ;
8642: END
// every 1 1$30 trigger conv_counter mod 3 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8643: LD_EXP 13
8647: PUSH
8648: LD_INT 3
8650: MOD
8651: PUSH
8652: LD_INT 0
8654: EQUAL
8655: PUSH
8656: LD_INT 22
8658: PUSH
8659: LD_INT 2
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: PPUSH
8666: CALL_OW 69
8670: PUSH
8671: LD_INT 0
8673: EQUAL
8674: AND
8675: IFFALSE 8692
8677: GO 8679
8679: DISABLE
// SayRadio ( Farmer , DPM_F3 ) ;
8680: LD_EXP 24
8684: PPUSH
8685: LD_STRING DPM_F3
8687: PPUSH
8688: CALL_OW 94
8692: END
// every 1 1$30 trigger conv_counter mod 5 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8693: LD_EXP 13
8697: PUSH
8698: LD_INT 5
8700: MOD
8701: PUSH
8702: LD_INT 0
8704: EQUAL
8705: PUSH
8706: LD_INT 22
8708: PUSH
8709: LD_INT 2
8711: PUSH
8712: EMPTY
8713: LIST
8714: LIST
8715: PPUSH
8716: CALL_OW 69
8720: PUSH
8721: LD_INT 0
8723: EQUAL
8724: AND
8725: IFFALSE 8742
8727: GO 8729
8729: DISABLE
// SayRadio ( Farmer , DPM_F4 ) ;
8730: LD_EXP 24
8734: PPUSH
8735: LD_STRING DPM_F4
8737: PPUSH
8738: CALL_OW 94
8742: END
// every 0 0$10 trigger conv_counter >= 8 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
8743: LD_EXP 13
8747: PUSH
8748: LD_INT 8
8750: GREATEREQUAL
8751: PUSH
8752: LD_INT 22
8754: PUSH
8755: LD_INT 6
8757: PUSH
8758: EMPTY
8759: LIST
8760: LIST
8761: PPUSH
8762: CALL_OW 69
8766: PUSH
8767: LD_INT 0
8769: EQUAL
8770: AND
8771: IFFALSE 8870
8773: GO 8775
8775: DISABLE
// begin SayRadio ( Popov , DPM_PEnd ) ;
8776: LD_EXP 16
8780: PPUSH
8781: LD_STRING DPM_PEnd
8783: PPUSH
8784: CALL_OW 94
// AddMedal ( med1 , medal1 ) ;
8788: LD_STRING med1
8790: PPUSH
8791: LD_EXP 3
8795: PPUSH
8796: CALL_OW 101
// AddMedal ( med2 , medal2 ) ;
8800: LD_STRING med2
8802: PPUSH
8803: LD_EXP 4
8807: PPUSH
8808: CALL_OW 101
// if dest_counter >= [ 15 , 10 , 7 ] [ Difficulty ] then
8812: LD_EXP 8
8816: PUSH
8817: LD_INT 15
8819: PUSH
8820: LD_INT 10
8822: PUSH
8823: LD_INT 7
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: LIST
8830: PUSH
8831: LD_OWVAR 67
8835: ARRAY
8836: GREATEREQUAL
8837: IFFALSE 8847
// medal3 := false ;
8839: LD_ADDR_EXP 5
8843: PUSH
8844: LD_INT 0
8846: ST_TO_ADDR
// AddMedal ( med3 , medal3 ) ;
8847: LD_STRING med3
8849: PPUSH
8850: LD_EXP 5
8854: PPUSH
8855: CALL_OW 101
// GiveMedals ( MAIN ) ;
8859: LD_STRING MAIN
8861: PPUSH
8862: CALL_OW 102
// YouWin ;
8866: CALL_OW 103
// end ;
8870: END
// every 4 4$00 trigger convoy_start do var i ;
8871: LD_EXP 7
8875: IFFALSE 9233
8877: GO 8879
8879: DISABLE
8880: LD_INT 0
8882: PPUSH
// begin SayRadio ( Popov , DPM_PHelp ) ;
8883: LD_EXP 16
8887: PPUSH
8888: LD_STRING DPM_PHelp
8890: PPUSH
8891: CALL_OW 94
// Wait ( 0 0$30 ) ;
8895: LD_INT 1050
8897: PPUSH
8898: CALL_OW 67
// Randomize ;
8902: CALL_OW 10
// uc_side := 3 ;
8906: LD_ADDR_OWVAR 20
8910: PUSH
8911: LD_INT 3
8913: ST_TO_ADDR
// uc_nation := 3 ;
8914: LD_ADDR_OWVAR 21
8918: PUSH
8919: LD_INT 3
8921: ST_TO_ADDR
// for i = 1 to [ 5 , 4 , 3 ] [ Difficulty ] do
8922: LD_ADDR_VAR 0 1
8926: PUSH
8927: DOUBLE
8928: LD_INT 1
8930: DEC
8931: ST_TO_ADDR
8932: LD_INT 5
8934: PUSH
8935: LD_INT 4
8937: PUSH
8938: LD_INT 3
8940: PUSH
8941: EMPTY
8942: LIST
8943: LIST
8944: LIST
8945: PUSH
8946: LD_OWVAR 67
8950: ARRAY
8951: PUSH
8952: FOR_TO
8953: IFFALSE 8993
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , 5 ) ;
8955: LD_INT 0
8957: PPUSH
8958: LD_INT 1
8960: PPUSH
8961: LD_INT 3
8963: PPUSH
8964: CALL_OW 12
8968: PPUSH
8969: LD_INT 5
8971: PPUSH
8972: CALL_OW 380
// PlaceUnitArea ( CreateHuman , rus_start , false ) ;
8976: CALL_OW 44
8980: PPUSH
8981: LD_INT 1
8983: PPUSH
8984: LD_INT 0
8986: PPUSH
8987: CALL_OW 49
// end ;
8991: GO 8952
8993: POP
8994: POP
// vc_chassis := ru_heavy_wheeled ;
8995: LD_ADDR_OWVAR 37
8999: PUSH
9000: LD_INT 23
9002: ST_TO_ADDR
// vc_engine := engine_combustion ;
9003: LD_ADDR_OWVAR 39
9007: PUSH
9008: LD_INT 1
9010: ST_TO_ADDR
// vc_control := control_manual ;
9011: LD_ADDR_OWVAR 38
9015: PUSH
9016: LD_INT 1
9018: ST_TO_ADDR
// vc_weapon := 89 ;
9019: LD_ADDR_OWVAR 40
9023: PUSH
9024: LD_INT 89
9026: ST_TO_ADDR
// vc_fuel_battery := 88 ;
9027: LD_ADDR_OWVAR 41
9031: PUSH
9032: LD_INT 88
9034: ST_TO_ADDR
// i := CreateVehicle ;
9035: LD_ADDR_VAR 0 1
9039: PUSH
9040: CALL_OW 45
9044: ST_TO_ADDR
// SetDir ( i , 5 ) ;
9045: LD_VAR 0 1
9049: PPUSH
9050: LD_INT 5
9052: PPUSH
9053: CALL_OW 233
// PlaceUnitXY ( i , 63 , 115 , false ) ;
9057: LD_VAR 0 1
9061: PPUSH
9062: LD_INT 63
9064: PPUSH
9065: LD_INT 115
9067: PPUSH
9068: LD_INT 0
9070: PPUSH
9071: CALL_OW 48
// SetCargo ( i , mat_cans , 200 ) ;
9075: LD_VAR 0 1
9079: PPUSH
9080: LD_INT 1
9082: PPUSH
9083: LD_INT 200
9085: PPUSH
9086: CALL_OW 290
// PrepareHuman ( false , 3 , 5 ) ;
9090: LD_INT 0
9092: PPUSH
9093: LD_INT 3
9095: PPUSH
9096: LD_INT 5
9098: PPUSH
9099: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9103: CALL_OW 44
9107: PPUSH
9108: LD_VAR 0 1
9112: PPUSH
9113: CALL_OW 52
// DialogueOn ;
9117: CALL_OW 6
// CenterNowOnXY ( 169 , 115 ) ;
9121: LD_INT 169
9123: PPUSH
9124: LD_INT 115
9126: PPUSH
9127: CALL_OW 86
// DWait ( 0 0$01 ) ;
9131: LD_INT 35
9133: PPUSH
9134: CALL_OW 68
// CenterNowOnXY ( 63 , 115 ) ;
9138: LD_INT 63
9140: PPUSH
9141: LD_INT 115
9143: PPUSH
9144: CALL_OW 86
// DWait ( 0 0$01 ) ;
9148: LD_INT 35
9150: PPUSH
9151: CALL_OW 68
// DialogueOff ;
9155: CALL_OW 7
// ComMoveXY ( i , 57 , 53 ) ;
9159: LD_VAR 0 1
9163: PPUSH
9164: LD_INT 57
9166: PPUSH
9167: LD_INT 53
9169: PPUSH
9170: CALL_OW 111
// Wait ( Rand ( 3 3$00 , 7 7$00 ) ) ;
9174: LD_INT 6300
9176: PPUSH
9177: LD_INT 14700
9179: PPUSH
9180: CALL_OW 12
9184: PPUSH
9185: CALL_OW 67
// PlaceUnitXY ( Saseda , 86 , 112 , false ) ;
9189: LD_EXP 17
9193: PPUSH
9194: LD_INT 86
9196: PPUSH
9197: LD_INT 112
9199: PPUSH
9200: LD_INT 0
9202: PPUSH
9203: CALL_OW 48
// Wait ( 0 0$0.3 ) ;
9207: LD_INT 10
9209: PPUSH
9210: CALL_OW 67
// SayRadio ( Saseda , DPM_Sa1 ) ;
9214: LD_EXP 17
9218: PPUSH
9219: LD_STRING DPM_Sa1
9221: PPUSH
9222: CALL_OW 94
// ChangeMissionObjectives ( PM_3 ) ;
9226: LD_STRING PM_3
9228: PPUSH
9229: CALL_OW 337
// end ;
9233: PPOPN 1
9235: END
// every 0 0$01 trigger See ( 3 , Saseda ) do
9236: LD_INT 3
9238: PPUSH
9239: LD_EXP 17
9243: PPUSH
9244: CALL_OW 292
9248: IFFALSE 9297
9250: GO 9252
9252: DISABLE
// begin Say ( Saseda , DPM_Sa2 ) ;
9253: LD_EXP 17
9257: PPUSH
9258: LD_STRING DPM_Sa2
9260: PPUSH
9261: CALL_OW 88
// ChangeMissionObjectives ( PM_4 ) ;
9265: LD_STRING PM_4
9267: PPUSH
9268: CALL_OW 337
// SetTech ( tech_rocket , 3 , state_enabled ) ;
9272: LD_INT 40
9274: PPUSH
9275: LD_INT 3
9277: PPUSH
9278: LD_INT 1
9280: PPUSH
9281: CALL_OW 322
// SetSide ( Saseda , 3 ) ;
9285: LD_EXP 17
9289: PPUSH
9290: LD_INT 3
9292: PPUSH
9293: CALL_OW 235
// end ;
9297: END
// every 16 16$00 trigger not medal1 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
9298: LD_EXP 3
9302: NOT
9303: PUSH
9304: LD_INT 22
9306: PUSH
9307: LD_INT 6
9309: PUSH
9310: EMPTY
9311: LIST
9312: LIST
9313: PPUSH
9314: CALL_OW 69
9318: PUSH
9319: LD_INT 0
9321: EQUAL
9322: AND
9323: IFFALSE 9370
9325: GO 9327
9327: DISABLE
// begin Say ( Stolypin , DPM_S3 ) ;
9328: LD_EXP 15
9332: PPUSH
9333: LD_STRING DPM_S3
9335: PPUSH
9336: CALL_OW 88
// PlaceSeeing ( 62 , 113 , 3 , 10 ) ;
9340: LD_INT 62
9342: PPUSH
9343: LD_INT 113
9345: PPUSH
9346: LD_INT 3
9348: PPUSH
9349: LD_INT 10
9351: PPUSH
9352: CALL_OW 330
// CenterOnXY ( 62 , 113 ) ;
9356: LD_INT 62
9358: PPUSH
9359: LD_INT 113
9361: PPUSH
9362: CALL_OW 84
// CounterAttack ;
9366: CALL 5702 0 0
// end ; end_of_file
9370: END
// on LeaveBuilding ( b , h ) do begin if GetSide ( b ) = 1 then
9371: LD_VAR 0 1
9375: PPUSH
9376: CALL_OW 255
9380: PUSH
9381: LD_INT 1
9383: EQUAL
9384: IFFALSE 9420
// if not us_retreat then
9386: LD_EXP 21
9390: NOT
9391: IFFALSE 9420
// if GetClass ( h ) = 1 then
9393: LD_VAR 0 2
9397: PPUSH
9398: CALL_OW 257
9402: PUSH
9403: LD_INT 1
9405: EQUAL
9406: IFFALSE 9420
// ComEnterUnit ( h , us_arm ) ;
9408: LD_VAR 0 2
9412: PPUSH
9413: LD_INT 69
9415: PPUSH
9416: CALL_OW 120
// end ;
9420: PPOPN 2
9422: END
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = 1 then
9423: LD_VAR 0 1
9427: PPUSH
9428: CALL_OW 255
9432: PUSH
9433: LD_INT 1
9435: EQUAL
9436: IFFALSE 9452
// us_count := us_count + 1 ;
9438: LD_ADDR_EXP 23
9442: PUSH
9443: LD_EXP 23
9447: PUSH
9448: LD_INT 1
9450: PLUS
9451: ST_TO_ADDR
// if un in us_force then
9452: LD_VAR 0 1
9456: PUSH
9457: LD_EXP 12
9461: IN
9462: IFFALSE 9480
// us_force := us_force diff un ;
9464: LD_ADDR_EXP 12
9468: PUSH
9469: LD_EXP 12
9473: PUSH
9474: LD_VAR 0 1
9478: DIFF
9479: ST_TO_ADDR
// if un in ar_force then
9480: LD_VAR 0 1
9484: PUSH
9485: LD_EXP 11
9489: IN
9490: IFFALSE 9508
// ar_force := ar_force diff un ;
9492: LD_ADDR_EXP 11
9496: PUSH
9497: LD_EXP 11
9501: PUSH
9502: LD_VAR 0 1
9506: DIFF
9507: ST_TO_ADDR
// if un = Stolypin then
9508: LD_VAR 0 1
9512: PUSH
9513: LD_EXP 15
9517: EQUAL
9518: IFFALSE 9527
// YouLost ( dead ) ;
9520: LD_STRING dead
9522: PPUSH
9523: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) then
9527: LD_VAR 0 1
9531: PUSH
9532: LD_INT 22
9534: PUSH
9535: LD_INT 1
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: PUSH
9542: LD_INT 30
9544: PUSH
9545: LD_INT 0
9547: PUSH
9548: EMPTY
9549: LIST
9550: LIST
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: PPUSH
9556: CALL_OW 69
9560: IN
9561: IFFALSE 9570
// YouLost ( depot ) ;
9563: LD_STRING depot
9565: PPUSH
9566: CALL_OW 104
// if GetSide ( un ) = 6 then
9570: LD_VAR 0 1
9574: PPUSH
9575: CALL_OW 255
9579: PUSH
9580: LD_INT 6
9582: EQUAL
9583: IFFALSE 9599
// dest_counter := dest_counter + 1 ;
9585: LD_ADDR_EXP 8
9589: PUSH
9590: LD_EXP 8
9594: PUSH
9595: LD_INT 1
9597: PLUS
9598: ST_TO_ADDR
// end ;
9599: PPOPN 1
9601: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 1 then
9602: LD_VAR 0 1
9606: PPUSH
9607: CALL_OW 255
9611: PUSH
9612: LD_INT 1
9614: EQUAL
9615: IFFALSE 9632
// ComMoveXY ( un , 57 , 52 ) ;
9617: LD_VAR 0 1
9621: PPUSH
9622: LD_INT 57
9624: PPUSH
9625: LD_INT 52
9627: PPUSH
9628: CALL_OW 111
// end ;
9632: PPOPN 2
9634: END
// on Contact ( s1 , s2 ) do begin if not us_alert then
9635: LD_EXP 20
9639: NOT
9640: IFFALSE 9690
// if ( s1 = 3 and s2 = 1 ) or ( s1 = 1 and s2 = 3 ) then
9642: LD_VAR 0 1
9646: PUSH
9647: LD_INT 3
9649: EQUAL
9650: PUSH
9651: LD_VAR 0 2
9655: PUSH
9656: LD_INT 1
9658: EQUAL
9659: AND
9660: PUSH
9661: LD_VAR 0 1
9665: PUSH
9666: LD_INT 1
9668: EQUAL
9669: PUSH
9670: LD_VAR 0 2
9674: PUSH
9675: LD_INT 3
9677: EQUAL
9678: AND
9679: OR
9680: IFFALSE 9690
// us_alert := true ;
9682: LD_ADDR_EXP 20
9686: PUSH
9687: LD_INT 1
9689: ST_TO_ADDR
// if ( s1 = 6 and s2 = 3 ) or ( s1 = 3 and s2 = 6 ) then
9690: LD_VAR 0 1
9694: PUSH
9695: LD_INT 6
9697: EQUAL
9698: PUSH
9699: LD_VAR 0 2
9703: PUSH
9704: LD_INT 3
9706: EQUAL
9707: AND
9708: PUSH
9709: LD_VAR 0 1
9713: PUSH
9714: LD_INT 3
9716: EQUAL
9717: PUSH
9718: LD_VAR 0 2
9722: PUSH
9723: LD_INT 6
9725: EQUAL
9726: AND
9727: OR
9728: IFFALSE 9737
// YouLost ( alat ) ;
9730: LD_STRING alat
9732: PPUSH
9733: CALL_OW 104
// end ;
9737: PPOPN 2
9739: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = 2 and un in FilterAllUnits ( [ [ f_empty ] , [ f_type , unit_vehicle ] ] ) then
9740: LD_VAR 0 1
9744: PPUSH
9745: CALL_OW 255
9749: PUSH
9750: LD_INT 2
9752: EQUAL
9753: PUSH
9754: LD_VAR 0 1
9758: PUSH
9759: LD_INT 58
9761: PUSH
9762: EMPTY
9763: LIST
9764: PUSH
9765: LD_INT 21
9767: PUSH
9768: LD_INT 2
9770: PUSH
9771: EMPTY
9772: LIST
9773: LIST
9774: PUSH
9775: EMPTY
9776: LIST
9777: LIST
9778: PPUSH
9779: CALL_OW 69
9783: IN
9784: AND
9785: IFFALSE 9906
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> 2 then
9787: LD_OWVAR 3
9791: PUSH
9792: LD_VAR 0 1
9796: DIFF
9797: PPUSH
9798: LD_VAR 0 1
9802: PPUSH
9803: CALL_OW 74
9807: PPUSH
9808: CALL_OW 255
9812: PUSH
9813: LD_INT 2
9815: NONEQUAL
9816: IFFALSE 9906
// begin Wait ( 0 0$1.3 ) ;
9818: LD_INT 46
9820: PPUSH
9821: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9825: LD_VAR 0 1
9829: PPUSH
9830: CALL_OW 250
9834: PPUSH
9835: LD_VAR 0 1
9839: PPUSH
9840: CALL_OW 251
9844: PPUSH
9845: LD_INT 1
9847: PPUSH
9848: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9852: LD_VAR 0 1
9856: PPUSH
9857: CALL_OW 250
9861: PPUSH
9862: LD_VAR 0 1
9866: PPUSH
9867: CALL_OW 251
9871: PPUSH
9872: LD_INT 1
9874: PPUSH
9875: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9879: LD_VAR 0 1
9883: PPUSH
9884: CALL_OW 250
9888: PPUSH
9889: LD_VAR 0 1
9893: PPUSH
9894: CALL_OW 251
9898: PPUSH
9899: LD_INT 1
9901: PPUSH
9902: CALL_OW 453
// end ; end ;
9906: PPOPN 1
9908: END
// on EvacuateVehicle ( driver , un , c1 , c2 ) do begin if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) and not GetSide ( NearestUnit ( un ) ) = 2 then
9909: LD_VAR 0 2
9913: PUSH
9914: LD_INT 22
9916: PUSH
9917: LD_INT 2
9919: PUSH
9920: EMPTY
9921: LIST
9922: LIST
9923: PUSH
9924: LD_INT 21
9926: PUSH
9927: LD_INT 2
9929: PUSH
9930: EMPTY
9931: LIST
9932: LIST
9933: PUSH
9934: EMPTY
9935: LIST
9936: LIST
9937: PPUSH
9938: CALL_OW 69
9942: IN
9943: PUSH
9944: LD_VAR 0 2
9948: PPUSH
9949: CALL 10479 0 1
9953: PPUSH
9954: CALL_OW 255
9958: PUSH
9959: LD_INT 2
9961: EQUAL
9962: NOT
9963: AND
9964: IFFALSE 10089
// begin Wait ( Rand ( 0 0$03 , 0 0$06 ) ) ;
9966: LD_INT 105
9968: PPUSH
9969: LD_INT 210
9971: PPUSH
9972: CALL_OW 12
9976: PPUSH
9977: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9981: LD_VAR 0 2
9985: PPUSH
9986: CALL_OW 250
9990: PPUSH
9991: LD_VAR 0 2
9995: PPUSH
9996: CALL_OW 251
10000: PPUSH
10001: LD_INT 3
10003: PPUSH
10004: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10008: LD_VAR 0 2
10012: PPUSH
10013: CALL_OW 250
10017: PPUSH
10018: LD_VAR 0 2
10022: PPUSH
10023: CALL_OW 251
10027: PPUSH
10028: LD_INT 3
10030: PPUSH
10031: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10035: LD_VAR 0 2
10039: PPUSH
10040: CALL_OW 250
10044: PPUSH
10045: LD_VAR 0 2
10049: PPUSH
10050: CALL_OW 251
10054: PPUSH
10055: LD_INT 3
10057: PPUSH
10058: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10062: LD_VAR 0 2
10066: PPUSH
10067: CALL_OW 250
10071: PPUSH
10072: LD_VAR 0 2
10076: PPUSH
10077: CALL_OW 251
10081: PPUSH
10082: LD_INT 3
10084: PPUSH
10085: CALL_OW 453
// end ; end ;
10089: PPOPN 4
10091: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
10092: LD_VAR 0 1
10096: PPUSH
10097: LD_VAR 0 2
10101: PPUSH
10102: LD_VAR 0 3
10106: PPUSH
10107: CALL 21723 0 3
// end ;
10111: PPOPN 3
10113: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10114: LD_VAR 0 1
10118: PPUSH
10119: CALL 21821 0 1
// end ; end_of_file
10123: PPOPN 1
10125: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
10126: LD_INT 0
10128: PPUSH
10129: PPUSH
10130: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
10131: LD_ADDR_VAR 0 7
10135: PUSH
10136: LD_VAR 0 1
10140: PUSH
10141: LD_VAR 0 2
10145: ARRAY
10146: PPUSH
10147: LD_VAR 0 3
10151: PPUSH
10152: LD_VAR 0 4
10156: PPUSH
10157: CALL_OW 1
10161: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
10162: LD_ADDR_VAR 0 1
10166: PUSH
10167: LD_VAR 0 1
10171: PPUSH
10172: LD_VAR 0 2
10176: PPUSH
10177: LD_VAR 0 7
10181: PPUSH
10182: CALL_OW 1
10186: ST_TO_ADDR
// result := tab ;
10187: LD_ADDR_VAR 0 5
10191: PUSH
10192: LD_VAR 0 1
10196: ST_TO_ADDR
// end ;
10197: LD_VAR 0 5
10201: RET
// export function IsDriver ( unit ) ; begin
10202: LD_INT 0
10204: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
10205: LD_VAR 0 1
10209: PUSH
10210: LD_INT 55
10212: PUSH
10213: EMPTY
10214: LIST
10215: PPUSH
10216: CALL_OW 69
10220: IN
10221: IFFALSE 10240
// result := IsInUnit ( unit ) else
10223: LD_ADDR_VAR 0 2
10227: PUSH
10228: LD_VAR 0 1
10232: PPUSH
10233: CALL_OW 310
10237: ST_TO_ADDR
10238: GO 10248
// result := false ;
10240: LD_ADDR_VAR 0 2
10244: PUSH
10245: LD_INT 0
10247: ST_TO_ADDR
// end ;
10248: LD_VAR 0 2
10252: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
10253: LD_INT 0
10255: PPUSH
10256: PPUSH
10257: PPUSH
// if not GetControl ( veh ) = control_manual then
10258: LD_VAR 0 1
10262: PPUSH
10263: CALL_OW 263
10267: PUSH
10268: LD_INT 1
10270: EQUAL
10271: NOT
10272: IFFALSE 10284
// result := false else
10274: LD_ADDR_VAR 0 2
10278: PUSH
10279: LD_INT 0
10281: ST_TO_ADDR
10282: GO 10429
// if veh in FilterAllUnits ( [ f_empty ] ) then
10284: LD_VAR 0 1
10288: PUSH
10289: LD_INT 58
10291: PUSH
10292: EMPTY
10293: LIST
10294: PPUSH
10295: CALL_OW 69
10299: IN
10300: IFFALSE 10312
// result := false else
10302: LD_ADDR_VAR 0 2
10306: PUSH
10307: LD_INT 0
10309: ST_TO_ADDR
10310: GO 10429
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
10312: LD_ADDR_VAR 0 4
10316: PUSH
10317: LD_INT 22
10319: PUSH
10320: LD_VAR 0 1
10324: PPUSH
10325: CALL_OW 255
10329: PUSH
10330: EMPTY
10331: LIST
10332: LIST
10333: PUSH
10334: LD_INT 55
10336: PUSH
10337: EMPTY
10338: LIST
10339: PUSH
10340: EMPTY
10341: LIST
10342: LIST
10343: PPUSH
10344: CALL_OW 69
10348: ST_TO_ADDR
// if not filter then
10349: LD_VAR 0 4
10353: NOT
10354: IFFALSE 10366
// result := false else
10356: LD_ADDR_VAR 0 2
10360: PUSH
10361: LD_INT 0
10363: ST_TO_ADDR
10364: GO 10429
// for i = 1 to filter do
10366: LD_ADDR_VAR 0 3
10370: PUSH
10371: DOUBLE
10372: LD_INT 1
10374: DEC
10375: ST_TO_ADDR
10376: LD_VAR 0 4
10380: PUSH
10381: FOR_TO
10382: IFFALSE 10427
// if IsDriver ( filter [ i ] ) = veh then
10384: LD_VAR 0 4
10388: PUSH
10389: LD_VAR 0 3
10393: ARRAY
10394: PPUSH
10395: CALL 10202 0 1
10399: PUSH
10400: LD_VAR 0 1
10404: EQUAL
10405: IFFALSE 10425
// begin result := filter [ i ] ;
10407: LD_ADDR_VAR 0 2
10411: PUSH
10412: LD_VAR 0 4
10416: PUSH
10417: LD_VAR 0 3
10421: ARRAY
10422: ST_TO_ADDR
// break ;
10423: GO 10427
// end ;
10425: GO 10381
10427: POP
10428: POP
// end ; end ;
10429: LD_VAR 0 2
10433: RET
// export function FindTarget ( unit ) ; begin
10434: LD_INT 0
10436: PPUSH
// result := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ;
10437: LD_ADDR_VAR 0 2
10441: PUSH
10442: LD_INT 81
10444: PUSH
10445: LD_VAR 0 1
10449: PPUSH
10450: CALL_OW 255
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: PPUSH
10459: CALL_OW 69
10463: PPUSH
10464: LD_VAR 0 1
10468: PPUSH
10469: CALL_OW 74
10473: ST_TO_ADDR
// end ;
10474: LD_VAR 0 2
10478: RET
// export function NearestUnit ( unit ) ; begin
10479: LD_INT 0
10481: PPUSH
// result := NearestUnitToUnit ( all_units diff unit , unit ) ;
10482: LD_ADDR_VAR 0 2
10486: PUSH
10487: LD_OWVAR 3
10491: PUSH
10492: LD_VAR 0 1
10496: DIFF
10497: PPUSH
10498: LD_VAR 0 1
10502: PPUSH
10503: CALL_OW 74
10507: ST_TO_ADDR
// end ; end_of_file
10508: LD_VAR 0 2
10512: RET
// every 12 12$00 do
10513: GO 10515
10515: DISABLE
// begin SetWeather ( 1 , 210 , 110 ) ;
10516: LD_INT 1
10518: PPUSH
10519: LD_INT 210
10521: PPUSH
10522: LD_INT 110
10524: PPUSH
10525: CALL_OW 550
// Wait ( Rand ( 5 5$00 , 10 10$00 ) ) ;
10529: LD_INT 10500
10531: PPUSH
10532: LD_INT 21000
10534: PPUSH
10535: CALL_OW 12
10539: PPUSH
10540: CALL_OW 67
// SetWeather ( 0 , 210 , 110 ) ;
10544: LD_INT 0
10546: PPUSH
10547: LD_INT 210
10549: PPUSH
10550: LD_INT 110
10552: PPUSH
10553: CALL_OW 550
// end ;
10557: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
10558: LD_INT 0
10560: PPUSH
10561: PPUSH
10562: PPUSH
10563: PPUSH
10564: PPUSH
// uc_nation = nation_nature ;
10565: LD_ADDR_OWVAR 21
10569: PUSH
10570: LD_INT 0
10572: ST_TO_ADDR
// uc_side = 0 ;
10573: LD_ADDR_OWVAR 20
10577: PUSH
10578: LD_INT 0
10580: ST_TO_ADDR
// l = 0 ;
10581: LD_ADDR_VAR 0 6
10585: PUSH
10586: LD_INT 0
10588: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
10589: LD_ADDR_OWVAR 24
10593: PUSH
10594: LD_INT 0
10596: PPUSH
10597: LD_INT 5
10599: PPUSH
10600: CALL_OW 12
10604: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
10605: LD_ADDR_OWVAR 35
10609: PUSH
10610: LD_INT 5
10612: NEG
10613: PPUSH
10614: LD_INT 5
10616: PPUSH
10617: CALL_OW 12
10621: ST_TO_ADDR
// hc_gallery =  ;
10622: LD_ADDR_OWVAR 33
10626: PUSH
10627: LD_STRING 
10629: ST_TO_ADDR
// hc_class = class_apeman ;
10630: LD_ADDR_OWVAR 28
10634: PUSH
10635: LD_INT 12
10637: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
10638: LD_ADDR_OWVAR 29
10642: PUSH
10643: LD_INT 11
10645: PPUSH
10646: LD_INT 13
10648: PPUSH
10649: CALL_OW 12
10653: PUSH
10654: LD_INT 10
10656: PPUSH
10657: LD_INT 11
10659: PPUSH
10660: CALL_OW 12
10664: PUSH
10665: EMPTY
10666: LIST
10667: LIST
10668: ST_TO_ADDR
// hc_sex = sex_male ;
10669: LD_ADDR_OWVAR 27
10673: PUSH
10674: LD_INT 1
10676: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
10677: LD_ADDR_OWVAR 31
10681: PUSH
10682: LD_INT 0
10684: PPUSH
10685: LD_INT 2
10687: PPUSH
10688: CALL_OW 12
10692: PUSH
10693: LD_INT 0
10695: PUSH
10696: LD_INT 0
10698: PUSH
10699: LD_INT 0
10701: PUSH
10702: EMPTY
10703: LIST
10704: LIST
10705: LIST
10706: LIST
10707: ST_TO_ADDR
// apeman = CreateHuman ;
10708: LD_ADDR_VAR 0 7
10712: PUSH
10713: CALL_OW 44
10717: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
10718: LD_VAR 0 7
10722: PPUSH
10723: LD_VAR 0 4
10727: PPUSH
10728: LD_INT 0
10730: PPUSH
10731: CALL_OW 49
// l = l + 1 ;
10735: LD_ADDR_VAR 0 6
10739: PUSH
10740: LD_VAR 0 6
10744: PUSH
10745: LD_INT 1
10747: PLUS
10748: ST_TO_ADDR
// end until l = num1 ;
10749: LD_VAR 0 6
10753: PUSH
10754: LD_VAR 0 1
10758: EQUAL
10759: IFFALSE 10589
// l = 0 ;
10761: LD_ADDR_VAR 0 6
10765: PUSH
10766: LD_INT 0
10768: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
10769: LD_ADDR_OWVAR 35
10773: PUSH
10774: LD_INT 0
10776: PPUSH
10777: LD_INT 25
10779: PPUSH
10780: CALL_OW 12
10784: ST_TO_ADDR
// hc_class = class_tiger ;
10785: LD_ADDR_OWVAR 28
10789: PUSH
10790: LD_INT 14
10792: ST_TO_ADDR
// hc_sex = sex_male ;
10793: LD_ADDR_OWVAR 27
10797: PUSH
10798: LD_INT 1
10800: ST_TO_ADDR
// hc_gallery = sandnature ;
10801: LD_ADDR_OWVAR 33
10805: PUSH
10806: LD_STRING sandnature
10808: ST_TO_ADDR
// hc_face_number = 3 ;
10809: LD_ADDR_OWVAR 34
10813: PUSH
10814: LD_INT 3
10816: ST_TO_ADDR
// tiger = CreateHuman ;
10817: LD_ADDR_VAR 0 8
10821: PUSH
10822: CALL_OW 44
10826: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10827: LD_VAR 0 8
10831: PPUSH
10832: LD_VAR 0 4
10836: PPUSH
10837: LD_INT 0
10839: PPUSH
10840: CALL_OW 49
// l = l + 1 ;
10844: LD_ADDR_VAR 0 6
10848: PUSH
10849: LD_VAR 0 6
10853: PUSH
10854: LD_INT 1
10856: PLUS
10857: ST_TO_ADDR
// end until l = num2 ;
10858: LD_VAR 0 6
10862: PUSH
10863: LD_VAR 0 2
10867: EQUAL
10868: IFFALSE 10769
// l = 0 ;
10870: LD_ADDR_VAR 0 6
10874: PUSH
10875: LD_INT 0
10877: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
10878: LD_ADDR_OWVAR 28
10882: PUSH
10883: LD_INT 18
10885: ST_TO_ADDR
// hc_gallery = sandnature ;
10886: LD_ADDR_OWVAR 33
10890: PUSH
10891: LD_STRING sandnature
10893: ST_TO_ADDR
// hc_face_number = 1 ;
10894: LD_ADDR_OWVAR 34
10898: PUSH
10899: LD_INT 1
10901: ST_TO_ADDR
// bird = CreateHuman ;
10902: LD_ADDR_VAR 0 9
10906: PUSH
10907: CALL_OW 44
10911: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
10912: LD_VAR 0 9
10916: PPUSH
10917: LD_INT 0
10919: PPUSH
10920: CALL_OW 51
// l = l + 1 ;
10924: LD_ADDR_VAR 0 6
10928: PUSH
10929: LD_VAR 0 6
10933: PUSH
10934: LD_INT 1
10936: PLUS
10937: ST_TO_ADDR
// end until l = num3 ;
10938: LD_VAR 0 6
10942: PUSH
10943: LD_VAR 0 3
10947: EQUAL
10948: IFFALSE 10878
// end ; end_of_file
10950: LD_VAR 0 5
10954: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
10955: GO 10957
10957: DISABLE
// begin ru_radar := 98 ;
10958: LD_ADDR_EXP 25
10962: PUSH
10963: LD_INT 98
10965: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
10966: LD_ADDR_EXP 26
10970: PUSH
10971: LD_INT 89
10973: ST_TO_ADDR
// us_hack := 99 ;
10974: LD_ADDR_EXP 27
10978: PUSH
10979: LD_INT 99
10981: ST_TO_ADDR
// us_artillery := 97 ;
10982: LD_ADDR_EXP 28
10986: PUSH
10987: LD_INT 97
10989: ST_TO_ADDR
// ar_bio_bomb := 91 ;
10990: LD_ADDR_EXP 29
10994: PUSH
10995: LD_INT 91
10997: ST_TO_ADDR
// end ; end_of_file end_of_file
10998: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
10999: GO 11001
11001: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
11002: LD_STRING initStreamRollete();
11004: PPUSH
11005: CALL_OW 559
// InitStreamMode ;
11009: CALL 11018 0 0
// DefineStreamItems ( ) ;
11013: CALL 11458 0 0
// end ;
11017: END
// function InitStreamMode ; begin
11018: LD_INT 0
11020: PPUSH
// streamModeActive := false ;
11021: LD_ADDR_EXP 30
11025: PUSH
11026: LD_INT 0
11028: ST_TO_ADDR
// normalCounter := 26 ;
11029: LD_ADDR_EXP 31
11033: PUSH
11034: LD_INT 26
11036: ST_TO_ADDR
// hardcoreCounter := 12 ;
11037: LD_ADDR_EXP 32
11041: PUSH
11042: LD_INT 12
11044: ST_TO_ADDR
// sRocket := false ;
11045: LD_ADDR_EXP 35
11049: PUSH
11050: LD_INT 0
11052: ST_TO_ADDR
// sSpeed := false ;
11053: LD_ADDR_EXP 34
11057: PUSH
11058: LD_INT 0
11060: ST_TO_ADDR
// sEngine := false ;
11061: LD_ADDR_EXP 36
11065: PUSH
11066: LD_INT 0
11068: ST_TO_ADDR
// sSpec := false ;
11069: LD_ADDR_EXP 33
11073: PUSH
11074: LD_INT 0
11076: ST_TO_ADDR
// sLevel := false ;
11077: LD_ADDR_EXP 37
11081: PUSH
11082: LD_INT 0
11084: ST_TO_ADDR
// sArmoury := false ;
11085: LD_ADDR_EXP 38
11089: PUSH
11090: LD_INT 0
11092: ST_TO_ADDR
// sRadar := false ;
11093: LD_ADDR_EXP 39
11097: PUSH
11098: LD_INT 0
11100: ST_TO_ADDR
// sBunker := false ;
11101: LD_ADDR_EXP 40
11105: PUSH
11106: LD_INT 0
11108: ST_TO_ADDR
// sHack := false ;
11109: LD_ADDR_EXP 41
11113: PUSH
11114: LD_INT 0
11116: ST_TO_ADDR
// sFire := false ;
11117: LD_ADDR_EXP 42
11121: PUSH
11122: LD_INT 0
11124: ST_TO_ADDR
// sRefresh := false ;
11125: LD_ADDR_EXP 43
11129: PUSH
11130: LD_INT 0
11132: ST_TO_ADDR
// sExp := false ;
11133: LD_ADDR_EXP 44
11137: PUSH
11138: LD_INT 0
11140: ST_TO_ADDR
// sDepot := false ;
11141: LD_ADDR_EXP 45
11145: PUSH
11146: LD_INT 0
11148: ST_TO_ADDR
// sFlag := false ;
11149: LD_ADDR_EXP 46
11153: PUSH
11154: LD_INT 0
11156: ST_TO_ADDR
// sKamikadze := false ;
11157: LD_ADDR_EXP 54
11161: PUSH
11162: LD_INT 0
11164: ST_TO_ADDR
// sTroll := false ;
11165: LD_ADDR_EXP 55
11169: PUSH
11170: LD_INT 0
11172: ST_TO_ADDR
// sSlow := false ;
11173: LD_ADDR_EXP 56
11177: PUSH
11178: LD_INT 0
11180: ST_TO_ADDR
// sLack := false ;
11181: LD_ADDR_EXP 57
11185: PUSH
11186: LD_INT 0
11188: ST_TO_ADDR
// sTank := false ;
11189: LD_ADDR_EXP 59
11193: PUSH
11194: LD_INT 0
11196: ST_TO_ADDR
// sRemote := false ;
11197: LD_ADDR_EXP 60
11201: PUSH
11202: LD_INT 0
11204: ST_TO_ADDR
// sPowell := false ;
11205: LD_ADDR_EXP 61
11209: PUSH
11210: LD_INT 0
11212: ST_TO_ADDR
// sTeleport := false ;
11213: LD_ADDR_EXP 64
11217: PUSH
11218: LD_INT 0
11220: ST_TO_ADDR
// sOilTower := false ;
11221: LD_ADDR_EXP 66
11225: PUSH
11226: LD_INT 0
11228: ST_TO_ADDR
// sShovel := false ;
11229: LD_ADDR_EXP 67
11233: PUSH
11234: LD_INT 0
11236: ST_TO_ADDR
// sSheik := false ;
11237: LD_ADDR_EXP 68
11241: PUSH
11242: LD_INT 0
11244: ST_TO_ADDR
// sEarthquake := false ;
11245: LD_ADDR_EXP 70
11249: PUSH
11250: LD_INT 0
11252: ST_TO_ADDR
// sAI := false ;
11253: LD_ADDR_EXP 71
11257: PUSH
11258: LD_INT 0
11260: ST_TO_ADDR
// sCargo := false ;
11261: LD_ADDR_EXP 74
11265: PUSH
11266: LD_INT 0
11268: ST_TO_ADDR
// sDLaser := false ;
11269: LD_ADDR_EXP 75
11273: PUSH
11274: LD_INT 0
11276: ST_TO_ADDR
// sExchange := false ;
11277: LD_ADDR_EXP 76
11281: PUSH
11282: LD_INT 0
11284: ST_TO_ADDR
// sFac := false ;
11285: LD_ADDR_EXP 77
11289: PUSH
11290: LD_INT 0
11292: ST_TO_ADDR
// sPower := false ;
11293: LD_ADDR_EXP 78
11297: PUSH
11298: LD_INT 0
11300: ST_TO_ADDR
// sRandom := false ;
11301: LD_ADDR_EXP 79
11305: PUSH
11306: LD_INT 0
11308: ST_TO_ADDR
// sShield := false ;
11309: LD_ADDR_EXP 80
11313: PUSH
11314: LD_INT 0
11316: ST_TO_ADDR
// sTime := false ;
11317: LD_ADDR_EXP 81
11321: PUSH
11322: LD_INT 0
11324: ST_TO_ADDR
// sTools := false ;
11325: LD_ADDR_EXP 82
11329: PUSH
11330: LD_INT 0
11332: ST_TO_ADDR
// sSold := false ;
11333: LD_ADDR_EXP 47
11337: PUSH
11338: LD_INT 0
11340: ST_TO_ADDR
// sDiff := false ;
11341: LD_ADDR_EXP 48
11345: PUSH
11346: LD_INT 0
11348: ST_TO_ADDR
// sFog := false ;
11349: LD_ADDR_EXP 51
11353: PUSH
11354: LD_INT 0
11356: ST_TO_ADDR
// sReset := false ;
11357: LD_ADDR_EXP 52
11361: PUSH
11362: LD_INT 0
11364: ST_TO_ADDR
// sSun := false ;
11365: LD_ADDR_EXP 53
11369: PUSH
11370: LD_INT 0
11372: ST_TO_ADDR
// sTiger := false ;
11373: LD_ADDR_EXP 49
11377: PUSH
11378: LD_INT 0
11380: ST_TO_ADDR
// sBomb := false ;
11381: LD_ADDR_EXP 50
11385: PUSH
11386: LD_INT 0
11388: ST_TO_ADDR
// sWound := false ;
11389: LD_ADDR_EXP 58
11393: PUSH
11394: LD_INT 0
11396: ST_TO_ADDR
// sBetray := false ;
11397: LD_ADDR_EXP 62
11401: PUSH
11402: LD_INT 0
11404: ST_TO_ADDR
// sContamin := false ;
11405: LD_ADDR_EXP 63
11409: PUSH
11410: LD_INT 0
11412: ST_TO_ADDR
// sOil := false ;
11413: LD_ADDR_EXP 65
11417: PUSH
11418: LD_INT 0
11420: ST_TO_ADDR
// sStu := false ;
11421: LD_ADDR_EXP 69
11425: PUSH
11426: LD_INT 0
11428: ST_TO_ADDR
// sBazooka := false ;
11429: LD_ADDR_EXP 72
11433: PUSH
11434: LD_INT 0
11436: ST_TO_ADDR
// sMortar := false ;
11437: LD_ADDR_EXP 73
11441: PUSH
11442: LD_INT 0
11444: ST_TO_ADDR
// sRanger := false ;
11445: LD_ADDR_EXP 83
11449: PUSH
11450: LD_INT 0
11452: ST_TO_ADDR
// end ;
11453: LD_VAR 0 1
11457: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
11458: LD_INT 0
11460: PPUSH
11461: PPUSH
11462: PPUSH
11463: PPUSH
11464: PPUSH
// result := [ ] ;
11465: LD_ADDR_VAR 0 1
11469: PUSH
11470: EMPTY
11471: ST_TO_ADDR
// if campaign_id = 1 then
11472: LD_OWVAR 69
11476: PUSH
11477: LD_INT 1
11479: EQUAL
11480: IFFALSE 14428
// begin case mission_number of 1 :
11482: LD_OWVAR 70
11486: PUSH
11487: LD_INT 1
11489: DOUBLE
11490: EQUAL
11491: IFTRUE 11495
11493: GO 11559
11495: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
11496: LD_ADDR_VAR 0 1
11500: PUSH
11501: LD_INT 2
11503: PUSH
11504: LD_INT 4
11506: PUSH
11507: LD_INT 11
11509: PUSH
11510: LD_INT 12
11512: PUSH
11513: LD_INT 15
11515: PUSH
11516: LD_INT 16
11518: PUSH
11519: LD_INT 22
11521: PUSH
11522: LD_INT 23
11524: PUSH
11525: LD_INT 26
11527: PUSH
11528: EMPTY
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: PUSH
11539: LD_INT 101
11541: PUSH
11542: LD_INT 102
11544: PUSH
11545: LD_INT 106
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: LIST
11552: PUSH
11553: EMPTY
11554: LIST
11555: LIST
11556: ST_TO_ADDR
11557: GO 14428
11559: LD_INT 2
11561: DOUBLE
11562: EQUAL
11563: IFTRUE 11567
11565: GO 11639
11567: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
11568: LD_ADDR_VAR 0 1
11572: PUSH
11573: LD_INT 2
11575: PUSH
11576: LD_INT 4
11578: PUSH
11579: LD_INT 11
11581: PUSH
11582: LD_INT 12
11584: PUSH
11585: LD_INT 15
11587: PUSH
11588: LD_INT 16
11590: PUSH
11591: LD_INT 22
11593: PUSH
11594: LD_INT 23
11596: PUSH
11597: LD_INT 26
11599: PUSH
11600: EMPTY
11601: LIST
11602: LIST
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: PUSH
11611: LD_INT 101
11613: PUSH
11614: LD_INT 102
11616: PUSH
11617: LD_INT 105
11619: PUSH
11620: LD_INT 106
11622: PUSH
11623: LD_INT 108
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: LIST
11630: LIST
11631: LIST
11632: PUSH
11633: EMPTY
11634: LIST
11635: LIST
11636: ST_TO_ADDR
11637: GO 14428
11639: LD_INT 3
11641: DOUBLE
11642: EQUAL
11643: IFTRUE 11647
11645: GO 11723
11647: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
11648: LD_ADDR_VAR 0 1
11652: PUSH
11653: LD_INT 2
11655: PUSH
11656: LD_INT 4
11658: PUSH
11659: LD_INT 5
11661: PUSH
11662: LD_INT 11
11664: PUSH
11665: LD_INT 12
11667: PUSH
11668: LD_INT 15
11670: PUSH
11671: LD_INT 16
11673: PUSH
11674: LD_INT 22
11676: PUSH
11677: LD_INT 26
11679: PUSH
11680: LD_INT 36
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: LIST
11687: LIST
11688: LIST
11689: LIST
11690: LIST
11691: LIST
11692: LIST
11693: LIST
11694: PUSH
11695: LD_INT 101
11697: PUSH
11698: LD_INT 102
11700: PUSH
11701: LD_INT 105
11703: PUSH
11704: LD_INT 106
11706: PUSH
11707: LD_INT 108
11709: PUSH
11710: EMPTY
11711: LIST
11712: LIST
11713: LIST
11714: LIST
11715: LIST
11716: PUSH
11717: EMPTY
11718: LIST
11719: LIST
11720: ST_TO_ADDR
11721: GO 14428
11723: LD_INT 4
11725: DOUBLE
11726: EQUAL
11727: IFTRUE 11731
11729: GO 11815
11731: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
11732: LD_ADDR_VAR 0 1
11736: PUSH
11737: LD_INT 2
11739: PUSH
11740: LD_INT 4
11742: PUSH
11743: LD_INT 5
11745: PUSH
11746: LD_INT 8
11748: PUSH
11749: LD_INT 11
11751: PUSH
11752: LD_INT 12
11754: PUSH
11755: LD_INT 15
11757: PUSH
11758: LD_INT 16
11760: PUSH
11761: LD_INT 22
11763: PUSH
11764: LD_INT 23
11766: PUSH
11767: LD_INT 26
11769: PUSH
11770: LD_INT 36
11772: PUSH
11773: EMPTY
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: PUSH
11787: LD_INT 101
11789: PUSH
11790: LD_INT 102
11792: PUSH
11793: LD_INT 105
11795: PUSH
11796: LD_INT 106
11798: PUSH
11799: LD_INT 108
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: PUSH
11809: EMPTY
11810: LIST
11811: LIST
11812: ST_TO_ADDR
11813: GO 14428
11815: LD_INT 5
11817: DOUBLE
11818: EQUAL
11819: IFTRUE 11823
11821: GO 11923
11823: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
11824: LD_ADDR_VAR 0 1
11828: PUSH
11829: LD_INT 2
11831: PUSH
11832: LD_INT 4
11834: PUSH
11835: LD_INT 5
11837: PUSH
11838: LD_INT 6
11840: PUSH
11841: LD_INT 8
11843: PUSH
11844: LD_INT 11
11846: PUSH
11847: LD_INT 12
11849: PUSH
11850: LD_INT 15
11852: PUSH
11853: LD_INT 16
11855: PUSH
11856: LD_INT 22
11858: PUSH
11859: LD_INT 23
11861: PUSH
11862: LD_INT 25
11864: PUSH
11865: LD_INT 26
11867: PUSH
11868: LD_INT 36
11870: PUSH
11871: EMPTY
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: LIST
11881: LIST
11882: LIST
11883: LIST
11884: LIST
11885: LIST
11886: PUSH
11887: LD_INT 101
11889: PUSH
11890: LD_INT 102
11892: PUSH
11893: LD_INT 105
11895: PUSH
11896: LD_INT 106
11898: PUSH
11899: LD_INT 108
11901: PUSH
11902: LD_INT 109
11904: PUSH
11905: LD_INT 112
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: LIST
11912: LIST
11913: LIST
11914: LIST
11915: LIST
11916: PUSH
11917: EMPTY
11918: LIST
11919: LIST
11920: ST_TO_ADDR
11921: GO 14428
11923: LD_INT 6
11925: DOUBLE
11926: EQUAL
11927: IFTRUE 11931
11929: GO 12051
11931: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
11932: LD_ADDR_VAR 0 1
11936: PUSH
11937: LD_INT 2
11939: PUSH
11940: LD_INT 4
11942: PUSH
11943: LD_INT 5
11945: PUSH
11946: LD_INT 6
11948: PUSH
11949: LD_INT 8
11951: PUSH
11952: LD_INT 11
11954: PUSH
11955: LD_INT 12
11957: PUSH
11958: LD_INT 15
11960: PUSH
11961: LD_INT 16
11963: PUSH
11964: LD_INT 20
11966: PUSH
11967: LD_INT 21
11969: PUSH
11970: LD_INT 22
11972: PUSH
11973: LD_INT 23
11975: PUSH
11976: LD_INT 25
11978: PUSH
11979: LD_INT 26
11981: PUSH
11982: LD_INT 30
11984: PUSH
11985: LD_INT 31
11987: PUSH
11988: LD_INT 32
11990: PUSH
11991: LD_INT 36
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: LIST
12000: LIST
12001: LIST
12002: LIST
12003: LIST
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: PUSH
12015: LD_INT 101
12017: PUSH
12018: LD_INT 102
12020: PUSH
12021: LD_INT 105
12023: PUSH
12024: LD_INT 106
12026: PUSH
12027: LD_INT 108
12029: PUSH
12030: LD_INT 109
12032: PUSH
12033: LD_INT 112
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: LIST
12040: LIST
12041: LIST
12042: LIST
12043: LIST
12044: PUSH
12045: EMPTY
12046: LIST
12047: LIST
12048: ST_TO_ADDR
12049: GO 14428
12051: LD_INT 7
12053: DOUBLE
12054: EQUAL
12055: IFTRUE 12059
12057: GO 12159
12059: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
12060: LD_ADDR_VAR 0 1
12064: PUSH
12065: LD_INT 2
12067: PUSH
12068: LD_INT 4
12070: PUSH
12071: LD_INT 5
12073: PUSH
12074: LD_INT 7
12076: PUSH
12077: LD_INT 11
12079: PUSH
12080: LD_INT 12
12082: PUSH
12083: LD_INT 15
12085: PUSH
12086: LD_INT 16
12088: PUSH
12089: LD_INT 20
12091: PUSH
12092: LD_INT 21
12094: PUSH
12095: LD_INT 22
12097: PUSH
12098: LD_INT 23
12100: PUSH
12101: LD_INT 25
12103: PUSH
12104: LD_INT 26
12106: PUSH
12107: EMPTY
12108: LIST
12109: LIST
12110: LIST
12111: LIST
12112: LIST
12113: LIST
12114: LIST
12115: LIST
12116: LIST
12117: LIST
12118: LIST
12119: LIST
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 101
12125: PUSH
12126: LD_INT 102
12128: PUSH
12129: LD_INT 103
12131: PUSH
12132: LD_INT 105
12134: PUSH
12135: LD_INT 106
12137: PUSH
12138: LD_INT 108
12140: PUSH
12141: LD_INT 112
12143: PUSH
12144: EMPTY
12145: LIST
12146: LIST
12147: LIST
12148: LIST
12149: LIST
12150: LIST
12151: LIST
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: ST_TO_ADDR
12157: GO 14428
12159: LD_INT 8
12161: DOUBLE
12162: EQUAL
12163: IFTRUE 12167
12165: GO 12295
12167: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
12168: LD_ADDR_VAR 0 1
12172: PUSH
12173: LD_INT 2
12175: PUSH
12176: LD_INT 4
12178: PUSH
12179: LD_INT 5
12181: PUSH
12182: LD_INT 6
12184: PUSH
12185: LD_INT 7
12187: PUSH
12188: LD_INT 8
12190: PUSH
12191: LD_INT 11
12193: PUSH
12194: LD_INT 12
12196: PUSH
12197: LD_INT 15
12199: PUSH
12200: LD_INT 16
12202: PUSH
12203: LD_INT 20
12205: PUSH
12206: LD_INT 21
12208: PUSH
12209: LD_INT 22
12211: PUSH
12212: LD_INT 23
12214: PUSH
12215: LD_INT 25
12217: PUSH
12218: LD_INT 26
12220: PUSH
12221: LD_INT 30
12223: PUSH
12224: LD_INT 31
12226: PUSH
12227: LD_INT 32
12229: PUSH
12230: LD_INT 36
12232: PUSH
12233: EMPTY
12234: LIST
12235: LIST
12236: LIST
12237: LIST
12238: LIST
12239: LIST
12240: LIST
12241: LIST
12242: LIST
12243: LIST
12244: LIST
12245: LIST
12246: LIST
12247: LIST
12248: LIST
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: PUSH
12255: LD_INT 101
12257: PUSH
12258: LD_INT 102
12260: PUSH
12261: LD_INT 103
12263: PUSH
12264: LD_INT 105
12266: PUSH
12267: LD_INT 106
12269: PUSH
12270: LD_INT 108
12272: PUSH
12273: LD_INT 109
12275: PUSH
12276: LD_INT 112
12278: PUSH
12279: EMPTY
12280: LIST
12281: LIST
12282: LIST
12283: LIST
12284: LIST
12285: LIST
12286: LIST
12287: LIST
12288: PUSH
12289: EMPTY
12290: LIST
12291: LIST
12292: ST_TO_ADDR
12293: GO 14428
12295: LD_INT 9
12297: DOUBLE
12298: EQUAL
12299: IFTRUE 12303
12301: GO 12439
12303: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
12304: LD_ADDR_VAR 0 1
12308: PUSH
12309: LD_INT 2
12311: PUSH
12312: LD_INT 4
12314: PUSH
12315: LD_INT 5
12317: PUSH
12318: LD_INT 6
12320: PUSH
12321: LD_INT 7
12323: PUSH
12324: LD_INT 8
12326: PUSH
12327: LD_INT 11
12329: PUSH
12330: LD_INT 12
12332: PUSH
12333: LD_INT 15
12335: PUSH
12336: LD_INT 16
12338: PUSH
12339: LD_INT 20
12341: PUSH
12342: LD_INT 21
12344: PUSH
12345: LD_INT 22
12347: PUSH
12348: LD_INT 23
12350: PUSH
12351: LD_INT 25
12353: PUSH
12354: LD_INT 26
12356: PUSH
12357: LD_INT 28
12359: PUSH
12360: LD_INT 30
12362: PUSH
12363: LD_INT 31
12365: PUSH
12366: LD_INT 32
12368: PUSH
12369: LD_INT 36
12371: PUSH
12372: EMPTY
12373: LIST
12374: LIST
12375: LIST
12376: LIST
12377: LIST
12378: LIST
12379: LIST
12380: LIST
12381: LIST
12382: LIST
12383: LIST
12384: LIST
12385: LIST
12386: LIST
12387: LIST
12388: LIST
12389: LIST
12390: LIST
12391: LIST
12392: LIST
12393: LIST
12394: PUSH
12395: LD_INT 101
12397: PUSH
12398: LD_INT 102
12400: PUSH
12401: LD_INT 103
12403: PUSH
12404: LD_INT 105
12406: PUSH
12407: LD_INT 106
12409: PUSH
12410: LD_INT 108
12412: PUSH
12413: LD_INT 109
12415: PUSH
12416: LD_INT 112
12418: PUSH
12419: LD_INT 114
12421: PUSH
12422: EMPTY
12423: LIST
12424: LIST
12425: LIST
12426: LIST
12427: LIST
12428: LIST
12429: LIST
12430: LIST
12431: LIST
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: ST_TO_ADDR
12437: GO 14428
12439: LD_INT 10
12441: DOUBLE
12442: EQUAL
12443: IFTRUE 12447
12445: GO 12631
12447: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
12448: LD_ADDR_VAR 0 1
12452: PUSH
12453: LD_INT 2
12455: PUSH
12456: LD_INT 4
12458: PUSH
12459: LD_INT 5
12461: PUSH
12462: LD_INT 6
12464: PUSH
12465: LD_INT 7
12467: PUSH
12468: LD_INT 8
12470: PUSH
12471: LD_INT 9
12473: PUSH
12474: LD_INT 10
12476: PUSH
12477: LD_INT 11
12479: PUSH
12480: LD_INT 12
12482: PUSH
12483: LD_INT 13
12485: PUSH
12486: LD_INT 14
12488: PUSH
12489: LD_INT 15
12491: PUSH
12492: LD_INT 16
12494: PUSH
12495: LD_INT 17
12497: PUSH
12498: LD_INT 18
12500: PUSH
12501: LD_INT 19
12503: PUSH
12504: LD_INT 20
12506: PUSH
12507: LD_INT 21
12509: PUSH
12510: LD_INT 22
12512: PUSH
12513: LD_INT 23
12515: PUSH
12516: LD_INT 24
12518: PUSH
12519: LD_INT 25
12521: PUSH
12522: LD_INT 26
12524: PUSH
12525: LD_INT 28
12527: PUSH
12528: LD_INT 30
12530: PUSH
12531: LD_INT 31
12533: PUSH
12534: LD_INT 32
12536: PUSH
12537: LD_INT 36
12539: PUSH
12540: EMPTY
12541: LIST
12542: LIST
12543: LIST
12544: LIST
12545: LIST
12546: LIST
12547: LIST
12548: LIST
12549: LIST
12550: LIST
12551: LIST
12552: LIST
12553: LIST
12554: LIST
12555: LIST
12556: LIST
12557: LIST
12558: LIST
12559: LIST
12560: LIST
12561: LIST
12562: LIST
12563: LIST
12564: LIST
12565: LIST
12566: LIST
12567: LIST
12568: LIST
12569: LIST
12570: PUSH
12571: LD_INT 101
12573: PUSH
12574: LD_INT 102
12576: PUSH
12577: LD_INT 103
12579: PUSH
12580: LD_INT 104
12582: PUSH
12583: LD_INT 105
12585: PUSH
12586: LD_INT 106
12588: PUSH
12589: LD_INT 107
12591: PUSH
12592: LD_INT 108
12594: PUSH
12595: LD_INT 109
12597: PUSH
12598: LD_INT 110
12600: PUSH
12601: LD_INT 111
12603: PUSH
12604: LD_INT 112
12606: PUSH
12607: LD_INT 114
12609: PUSH
12610: EMPTY
12611: LIST
12612: LIST
12613: LIST
12614: LIST
12615: LIST
12616: LIST
12617: LIST
12618: LIST
12619: LIST
12620: LIST
12621: LIST
12622: LIST
12623: LIST
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: ST_TO_ADDR
12629: GO 14428
12631: LD_INT 11
12633: DOUBLE
12634: EQUAL
12635: IFTRUE 12639
12637: GO 12831
12639: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
12640: LD_ADDR_VAR 0 1
12644: PUSH
12645: LD_INT 2
12647: PUSH
12648: LD_INT 3
12650: PUSH
12651: LD_INT 4
12653: PUSH
12654: LD_INT 5
12656: PUSH
12657: LD_INT 6
12659: PUSH
12660: LD_INT 7
12662: PUSH
12663: LD_INT 8
12665: PUSH
12666: LD_INT 9
12668: PUSH
12669: LD_INT 10
12671: PUSH
12672: LD_INT 11
12674: PUSH
12675: LD_INT 12
12677: PUSH
12678: LD_INT 13
12680: PUSH
12681: LD_INT 14
12683: PUSH
12684: LD_INT 15
12686: PUSH
12687: LD_INT 16
12689: PUSH
12690: LD_INT 17
12692: PUSH
12693: LD_INT 18
12695: PUSH
12696: LD_INT 19
12698: PUSH
12699: LD_INT 20
12701: PUSH
12702: LD_INT 21
12704: PUSH
12705: LD_INT 22
12707: PUSH
12708: LD_INT 23
12710: PUSH
12711: LD_INT 24
12713: PUSH
12714: LD_INT 25
12716: PUSH
12717: LD_INT 26
12719: PUSH
12720: LD_INT 28
12722: PUSH
12723: LD_INT 30
12725: PUSH
12726: LD_INT 31
12728: PUSH
12729: LD_INT 32
12731: PUSH
12732: LD_INT 34
12734: PUSH
12735: LD_INT 36
12737: PUSH
12738: EMPTY
12739: LIST
12740: LIST
12741: LIST
12742: LIST
12743: LIST
12744: LIST
12745: LIST
12746: LIST
12747: LIST
12748: LIST
12749: LIST
12750: LIST
12751: LIST
12752: LIST
12753: LIST
12754: LIST
12755: LIST
12756: LIST
12757: LIST
12758: LIST
12759: LIST
12760: LIST
12761: LIST
12762: LIST
12763: LIST
12764: LIST
12765: LIST
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: PUSH
12771: LD_INT 101
12773: PUSH
12774: LD_INT 102
12776: PUSH
12777: LD_INT 103
12779: PUSH
12780: LD_INT 104
12782: PUSH
12783: LD_INT 105
12785: PUSH
12786: LD_INT 106
12788: PUSH
12789: LD_INT 107
12791: PUSH
12792: LD_INT 108
12794: PUSH
12795: LD_INT 109
12797: PUSH
12798: LD_INT 110
12800: PUSH
12801: LD_INT 111
12803: PUSH
12804: LD_INT 112
12806: PUSH
12807: LD_INT 114
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: LIST
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: LIST
12823: LIST
12824: PUSH
12825: EMPTY
12826: LIST
12827: LIST
12828: ST_TO_ADDR
12829: GO 14428
12831: LD_INT 12
12833: DOUBLE
12834: EQUAL
12835: IFTRUE 12839
12837: GO 13047
12839: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
12840: LD_ADDR_VAR 0 1
12844: PUSH
12845: LD_INT 1
12847: PUSH
12848: LD_INT 2
12850: PUSH
12851: LD_INT 3
12853: PUSH
12854: LD_INT 4
12856: PUSH
12857: LD_INT 5
12859: PUSH
12860: LD_INT 6
12862: PUSH
12863: LD_INT 7
12865: PUSH
12866: LD_INT 8
12868: PUSH
12869: LD_INT 9
12871: PUSH
12872: LD_INT 10
12874: PUSH
12875: LD_INT 11
12877: PUSH
12878: LD_INT 12
12880: PUSH
12881: LD_INT 13
12883: PUSH
12884: LD_INT 14
12886: PUSH
12887: LD_INT 15
12889: PUSH
12890: LD_INT 16
12892: PUSH
12893: LD_INT 17
12895: PUSH
12896: LD_INT 18
12898: PUSH
12899: LD_INT 19
12901: PUSH
12902: LD_INT 20
12904: PUSH
12905: LD_INT 21
12907: PUSH
12908: LD_INT 22
12910: PUSH
12911: LD_INT 23
12913: PUSH
12914: LD_INT 24
12916: PUSH
12917: LD_INT 25
12919: PUSH
12920: LD_INT 26
12922: PUSH
12923: LD_INT 27
12925: PUSH
12926: LD_INT 28
12928: PUSH
12929: LD_INT 30
12931: PUSH
12932: LD_INT 31
12934: PUSH
12935: LD_INT 32
12937: PUSH
12938: LD_INT 33
12940: PUSH
12941: LD_INT 34
12943: PUSH
12944: LD_INT 36
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: LIST
12951: LIST
12952: LIST
12953: LIST
12954: LIST
12955: LIST
12956: LIST
12957: LIST
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: LIST
12964: LIST
12965: LIST
12966: LIST
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: LIST
12972: LIST
12973: LIST
12974: LIST
12975: LIST
12976: LIST
12977: LIST
12978: LIST
12979: LIST
12980: LIST
12981: LIST
12982: PUSH
12983: LD_INT 101
12985: PUSH
12986: LD_INT 102
12988: PUSH
12989: LD_INT 103
12991: PUSH
12992: LD_INT 104
12994: PUSH
12995: LD_INT 105
12997: PUSH
12998: LD_INT 106
13000: PUSH
13001: LD_INT 107
13003: PUSH
13004: LD_INT 108
13006: PUSH
13007: LD_INT 109
13009: PUSH
13010: LD_INT 110
13012: PUSH
13013: LD_INT 111
13015: PUSH
13016: LD_INT 112
13018: PUSH
13019: LD_INT 113
13021: PUSH
13022: LD_INT 114
13024: PUSH
13025: EMPTY
13026: LIST
13027: LIST
13028: LIST
13029: LIST
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: LIST
13035: LIST
13036: LIST
13037: LIST
13038: LIST
13039: LIST
13040: PUSH
13041: EMPTY
13042: LIST
13043: LIST
13044: ST_TO_ADDR
13045: GO 14428
13047: LD_INT 13
13049: DOUBLE
13050: EQUAL
13051: IFTRUE 13055
13053: GO 13263
13055: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
13056: LD_ADDR_VAR 0 1
13060: PUSH
13061: LD_INT 1
13063: PUSH
13064: LD_INT 2
13066: PUSH
13067: LD_INT 3
13069: PUSH
13070: LD_INT 4
13072: PUSH
13073: LD_INT 5
13075: PUSH
13076: LD_INT 6
13078: PUSH
13079: LD_INT 7
13081: PUSH
13082: LD_INT 8
13084: PUSH
13085: LD_INT 9
13087: PUSH
13088: LD_INT 10
13090: PUSH
13091: LD_INT 11
13093: PUSH
13094: LD_INT 12
13096: PUSH
13097: LD_INT 13
13099: PUSH
13100: LD_INT 14
13102: PUSH
13103: LD_INT 15
13105: PUSH
13106: LD_INT 16
13108: PUSH
13109: LD_INT 17
13111: PUSH
13112: LD_INT 18
13114: PUSH
13115: LD_INT 19
13117: PUSH
13118: LD_INT 20
13120: PUSH
13121: LD_INT 21
13123: PUSH
13124: LD_INT 22
13126: PUSH
13127: LD_INT 23
13129: PUSH
13130: LD_INT 24
13132: PUSH
13133: LD_INT 25
13135: PUSH
13136: LD_INT 26
13138: PUSH
13139: LD_INT 27
13141: PUSH
13142: LD_INT 28
13144: PUSH
13145: LD_INT 30
13147: PUSH
13148: LD_INT 31
13150: PUSH
13151: LD_INT 32
13153: PUSH
13154: LD_INT 33
13156: PUSH
13157: LD_INT 34
13159: PUSH
13160: LD_INT 36
13162: PUSH
13163: EMPTY
13164: LIST
13165: LIST
13166: LIST
13167: LIST
13168: LIST
13169: LIST
13170: LIST
13171: LIST
13172: LIST
13173: LIST
13174: LIST
13175: LIST
13176: LIST
13177: LIST
13178: LIST
13179: LIST
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: LIST
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: LIST
13190: LIST
13191: LIST
13192: LIST
13193: LIST
13194: LIST
13195: LIST
13196: LIST
13197: LIST
13198: PUSH
13199: LD_INT 101
13201: PUSH
13202: LD_INT 102
13204: PUSH
13205: LD_INT 103
13207: PUSH
13208: LD_INT 104
13210: PUSH
13211: LD_INT 105
13213: PUSH
13214: LD_INT 106
13216: PUSH
13217: LD_INT 107
13219: PUSH
13220: LD_INT 108
13222: PUSH
13223: LD_INT 109
13225: PUSH
13226: LD_INT 110
13228: PUSH
13229: LD_INT 111
13231: PUSH
13232: LD_INT 112
13234: PUSH
13235: LD_INT 113
13237: PUSH
13238: LD_INT 114
13240: PUSH
13241: EMPTY
13242: LIST
13243: LIST
13244: LIST
13245: LIST
13246: LIST
13247: LIST
13248: LIST
13249: LIST
13250: LIST
13251: LIST
13252: LIST
13253: LIST
13254: LIST
13255: LIST
13256: PUSH
13257: EMPTY
13258: LIST
13259: LIST
13260: ST_TO_ADDR
13261: GO 14428
13263: LD_INT 14
13265: DOUBLE
13266: EQUAL
13267: IFTRUE 13271
13269: GO 13483
13271: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
13272: LD_ADDR_VAR 0 1
13276: PUSH
13277: LD_INT 1
13279: PUSH
13280: LD_INT 2
13282: PUSH
13283: LD_INT 3
13285: PUSH
13286: LD_INT 4
13288: PUSH
13289: LD_INT 5
13291: PUSH
13292: LD_INT 6
13294: PUSH
13295: LD_INT 7
13297: PUSH
13298: LD_INT 8
13300: PUSH
13301: LD_INT 9
13303: PUSH
13304: LD_INT 10
13306: PUSH
13307: LD_INT 11
13309: PUSH
13310: LD_INT 12
13312: PUSH
13313: LD_INT 13
13315: PUSH
13316: LD_INT 14
13318: PUSH
13319: LD_INT 15
13321: PUSH
13322: LD_INT 16
13324: PUSH
13325: LD_INT 17
13327: PUSH
13328: LD_INT 18
13330: PUSH
13331: LD_INT 19
13333: PUSH
13334: LD_INT 20
13336: PUSH
13337: LD_INT 21
13339: PUSH
13340: LD_INT 22
13342: PUSH
13343: LD_INT 23
13345: PUSH
13346: LD_INT 24
13348: PUSH
13349: LD_INT 25
13351: PUSH
13352: LD_INT 26
13354: PUSH
13355: LD_INT 27
13357: PUSH
13358: LD_INT 28
13360: PUSH
13361: LD_INT 29
13363: PUSH
13364: LD_INT 30
13366: PUSH
13367: LD_INT 31
13369: PUSH
13370: LD_INT 32
13372: PUSH
13373: LD_INT 33
13375: PUSH
13376: LD_INT 34
13378: PUSH
13379: LD_INT 36
13381: PUSH
13382: EMPTY
13383: LIST
13384: LIST
13385: LIST
13386: LIST
13387: LIST
13388: LIST
13389: LIST
13390: LIST
13391: LIST
13392: LIST
13393: LIST
13394: LIST
13395: LIST
13396: LIST
13397: LIST
13398: LIST
13399: LIST
13400: LIST
13401: LIST
13402: LIST
13403: LIST
13404: LIST
13405: LIST
13406: LIST
13407: LIST
13408: LIST
13409: LIST
13410: LIST
13411: LIST
13412: LIST
13413: LIST
13414: LIST
13415: LIST
13416: LIST
13417: LIST
13418: PUSH
13419: LD_INT 101
13421: PUSH
13422: LD_INT 102
13424: PUSH
13425: LD_INT 103
13427: PUSH
13428: LD_INT 104
13430: PUSH
13431: LD_INT 105
13433: PUSH
13434: LD_INT 106
13436: PUSH
13437: LD_INT 107
13439: PUSH
13440: LD_INT 108
13442: PUSH
13443: LD_INT 109
13445: PUSH
13446: LD_INT 110
13448: PUSH
13449: LD_INT 111
13451: PUSH
13452: LD_INT 112
13454: PUSH
13455: LD_INT 113
13457: PUSH
13458: LD_INT 114
13460: PUSH
13461: EMPTY
13462: LIST
13463: LIST
13464: LIST
13465: LIST
13466: LIST
13467: LIST
13468: LIST
13469: LIST
13470: LIST
13471: LIST
13472: LIST
13473: LIST
13474: LIST
13475: LIST
13476: PUSH
13477: EMPTY
13478: LIST
13479: LIST
13480: ST_TO_ADDR
13481: GO 14428
13483: LD_INT 15
13485: DOUBLE
13486: EQUAL
13487: IFTRUE 13491
13489: GO 13703
13491: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
13492: LD_ADDR_VAR 0 1
13496: PUSH
13497: LD_INT 1
13499: PUSH
13500: LD_INT 2
13502: PUSH
13503: LD_INT 3
13505: PUSH
13506: LD_INT 4
13508: PUSH
13509: LD_INT 5
13511: PUSH
13512: LD_INT 6
13514: PUSH
13515: LD_INT 7
13517: PUSH
13518: LD_INT 8
13520: PUSH
13521: LD_INT 9
13523: PUSH
13524: LD_INT 10
13526: PUSH
13527: LD_INT 11
13529: PUSH
13530: LD_INT 12
13532: PUSH
13533: LD_INT 13
13535: PUSH
13536: LD_INT 14
13538: PUSH
13539: LD_INT 15
13541: PUSH
13542: LD_INT 16
13544: PUSH
13545: LD_INT 17
13547: PUSH
13548: LD_INT 18
13550: PUSH
13551: LD_INT 19
13553: PUSH
13554: LD_INT 20
13556: PUSH
13557: LD_INT 21
13559: PUSH
13560: LD_INT 22
13562: PUSH
13563: LD_INT 23
13565: PUSH
13566: LD_INT 24
13568: PUSH
13569: LD_INT 25
13571: PUSH
13572: LD_INT 26
13574: PUSH
13575: LD_INT 27
13577: PUSH
13578: LD_INT 28
13580: PUSH
13581: LD_INT 29
13583: PUSH
13584: LD_INT 30
13586: PUSH
13587: LD_INT 31
13589: PUSH
13590: LD_INT 32
13592: PUSH
13593: LD_INT 33
13595: PUSH
13596: LD_INT 34
13598: PUSH
13599: LD_INT 36
13601: PUSH
13602: EMPTY
13603: LIST
13604: LIST
13605: LIST
13606: LIST
13607: LIST
13608: LIST
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: LIST
13614: LIST
13615: LIST
13616: LIST
13617: LIST
13618: LIST
13619: LIST
13620: LIST
13621: LIST
13622: LIST
13623: LIST
13624: LIST
13625: LIST
13626: LIST
13627: LIST
13628: LIST
13629: LIST
13630: LIST
13631: LIST
13632: LIST
13633: LIST
13634: LIST
13635: LIST
13636: LIST
13637: LIST
13638: PUSH
13639: LD_INT 101
13641: PUSH
13642: LD_INT 102
13644: PUSH
13645: LD_INT 103
13647: PUSH
13648: LD_INT 104
13650: PUSH
13651: LD_INT 105
13653: PUSH
13654: LD_INT 106
13656: PUSH
13657: LD_INT 107
13659: PUSH
13660: LD_INT 108
13662: PUSH
13663: LD_INT 109
13665: PUSH
13666: LD_INT 110
13668: PUSH
13669: LD_INT 111
13671: PUSH
13672: LD_INT 112
13674: PUSH
13675: LD_INT 113
13677: PUSH
13678: LD_INT 114
13680: PUSH
13681: EMPTY
13682: LIST
13683: LIST
13684: LIST
13685: LIST
13686: LIST
13687: LIST
13688: LIST
13689: LIST
13690: LIST
13691: LIST
13692: LIST
13693: LIST
13694: LIST
13695: LIST
13696: PUSH
13697: EMPTY
13698: LIST
13699: LIST
13700: ST_TO_ADDR
13701: GO 14428
13703: LD_INT 16
13705: DOUBLE
13706: EQUAL
13707: IFTRUE 13711
13709: GO 13835
13711: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
13712: LD_ADDR_VAR 0 1
13716: PUSH
13717: LD_INT 2
13719: PUSH
13720: LD_INT 4
13722: PUSH
13723: LD_INT 5
13725: PUSH
13726: LD_INT 7
13728: PUSH
13729: LD_INT 11
13731: PUSH
13732: LD_INT 12
13734: PUSH
13735: LD_INT 15
13737: PUSH
13738: LD_INT 16
13740: PUSH
13741: LD_INT 20
13743: PUSH
13744: LD_INT 21
13746: PUSH
13747: LD_INT 22
13749: PUSH
13750: LD_INT 23
13752: PUSH
13753: LD_INT 25
13755: PUSH
13756: LD_INT 26
13758: PUSH
13759: LD_INT 30
13761: PUSH
13762: LD_INT 31
13764: PUSH
13765: LD_INT 32
13767: PUSH
13768: LD_INT 33
13770: PUSH
13771: LD_INT 34
13773: PUSH
13774: EMPTY
13775: LIST
13776: LIST
13777: LIST
13778: LIST
13779: LIST
13780: LIST
13781: LIST
13782: LIST
13783: LIST
13784: LIST
13785: LIST
13786: LIST
13787: LIST
13788: LIST
13789: LIST
13790: LIST
13791: LIST
13792: LIST
13793: LIST
13794: PUSH
13795: LD_INT 101
13797: PUSH
13798: LD_INT 102
13800: PUSH
13801: LD_INT 103
13803: PUSH
13804: LD_INT 106
13806: PUSH
13807: LD_INT 108
13809: PUSH
13810: LD_INT 112
13812: PUSH
13813: LD_INT 113
13815: PUSH
13816: LD_INT 114
13818: PUSH
13819: EMPTY
13820: LIST
13821: LIST
13822: LIST
13823: LIST
13824: LIST
13825: LIST
13826: LIST
13827: LIST
13828: PUSH
13829: EMPTY
13830: LIST
13831: LIST
13832: ST_TO_ADDR
13833: GO 14428
13835: LD_INT 17
13837: DOUBLE
13838: EQUAL
13839: IFTRUE 13843
13841: GO 14055
13843: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
13844: LD_ADDR_VAR 0 1
13848: PUSH
13849: LD_INT 1
13851: PUSH
13852: LD_INT 2
13854: PUSH
13855: LD_INT 3
13857: PUSH
13858: LD_INT 4
13860: PUSH
13861: LD_INT 5
13863: PUSH
13864: LD_INT 6
13866: PUSH
13867: LD_INT 7
13869: PUSH
13870: LD_INT 8
13872: PUSH
13873: LD_INT 9
13875: PUSH
13876: LD_INT 10
13878: PUSH
13879: LD_INT 11
13881: PUSH
13882: LD_INT 12
13884: PUSH
13885: LD_INT 13
13887: PUSH
13888: LD_INT 14
13890: PUSH
13891: LD_INT 15
13893: PUSH
13894: LD_INT 16
13896: PUSH
13897: LD_INT 17
13899: PUSH
13900: LD_INT 18
13902: PUSH
13903: LD_INT 19
13905: PUSH
13906: LD_INT 20
13908: PUSH
13909: LD_INT 21
13911: PUSH
13912: LD_INT 22
13914: PUSH
13915: LD_INT 23
13917: PUSH
13918: LD_INT 24
13920: PUSH
13921: LD_INT 25
13923: PUSH
13924: LD_INT 26
13926: PUSH
13927: LD_INT 27
13929: PUSH
13930: LD_INT 28
13932: PUSH
13933: LD_INT 29
13935: PUSH
13936: LD_INT 30
13938: PUSH
13939: LD_INT 31
13941: PUSH
13942: LD_INT 32
13944: PUSH
13945: LD_INT 33
13947: PUSH
13948: LD_INT 34
13950: PUSH
13951: LD_INT 36
13953: PUSH
13954: EMPTY
13955: LIST
13956: LIST
13957: LIST
13958: LIST
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: LIST
13964: LIST
13965: LIST
13966: LIST
13967: LIST
13968: LIST
13969: LIST
13970: LIST
13971: LIST
13972: LIST
13973: LIST
13974: LIST
13975: LIST
13976: LIST
13977: LIST
13978: LIST
13979: LIST
13980: LIST
13981: LIST
13982: LIST
13983: LIST
13984: LIST
13985: LIST
13986: LIST
13987: LIST
13988: LIST
13989: LIST
13990: PUSH
13991: LD_INT 101
13993: PUSH
13994: LD_INT 102
13996: PUSH
13997: LD_INT 103
13999: PUSH
14000: LD_INT 104
14002: PUSH
14003: LD_INT 105
14005: PUSH
14006: LD_INT 106
14008: PUSH
14009: LD_INT 107
14011: PUSH
14012: LD_INT 108
14014: PUSH
14015: LD_INT 109
14017: PUSH
14018: LD_INT 110
14020: PUSH
14021: LD_INT 111
14023: PUSH
14024: LD_INT 112
14026: PUSH
14027: LD_INT 113
14029: PUSH
14030: LD_INT 114
14032: PUSH
14033: EMPTY
14034: LIST
14035: LIST
14036: LIST
14037: LIST
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: LIST
14043: LIST
14044: LIST
14045: LIST
14046: LIST
14047: LIST
14048: PUSH
14049: EMPTY
14050: LIST
14051: LIST
14052: ST_TO_ADDR
14053: GO 14428
14055: LD_INT 18
14057: DOUBLE
14058: EQUAL
14059: IFTRUE 14063
14061: GO 14199
14063: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
14064: LD_ADDR_VAR 0 1
14068: PUSH
14069: LD_INT 2
14071: PUSH
14072: LD_INT 4
14074: PUSH
14075: LD_INT 5
14077: PUSH
14078: LD_INT 7
14080: PUSH
14081: LD_INT 11
14083: PUSH
14084: LD_INT 12
14086: PUSH
14087: LD_INT 15
14089: PUSH
14090: LD_INT 16
14092: PUSH
14093: LD_INT 20
14095: PUSH
14096: LD_INT 21
14098: PUSH
14099: LD_INT 22
14101: PUSH
14102: LD_INT 23
14104: PUSH
14105: LD_INT 25
14107: PUSH
14108: LD_INT 26
14110: PUSH
14111: LD_INT 30
14113: PUSH
14114: LD_INT 31
14116: PUSH
14117: LD_INT 32
14119: PUSH
14120: LD_INT 33
14122: PUSH
14123: LD_INT 34
14125: PUSH
14126: LD_INT 35
14128: PUSH
14129: LD_INT 36
14131: PUSH
14132: EMPTY
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: LIST
14153: LIST
14154: PUSH
14155: LD_INT 101
14157: PUSH
14158: LD_INT 102
14160: PUSH
14161: LD_INT 103
14163: PUSH
14164: LD_INT 106
14166: PUSH
14167: LD_INT 108
14169: PUSH
14170: LD_INT 112
14172: PUSH
14173: LD_INT 113
14175: PUSH
14176: LD_INT 114
14178: PUSH
14179: LD_INT 115
14181: PUSH
14182: EMPTY
14183: LIST
14184: LIST
14185: LIST
14186: LIST
14187: LIST
14188: LIST
14189: LIST
14190: LIST
14191: LIST
14192: PUSH
14193: EMPTY
14194: LIST
14195: LIST
14196: ST_TO_ADDR
14197: GO 14428
14199: LD_INT 19
14201: DOUBLE
14202: EQUAL
14203: IFTRUE 14207
14205: GO 14427
14207: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
14208: LD_ADDR_VAR 0 1
14212: PUSH
14213: LD_INT 1
14215: PUSH
14216: LD_INT 2
14218: PUSH
14219: LD_INT 3
14221: PUSH
14222: LD_INT 4
14224: PUSH
14225: LD_INT 5
14227: PUSH
14228: LD_INT 6
14230: PUSH
14231: LD_INT 7
14233: PUSH
14234: LD_INT 8
14236: PUSH
14237: LD_INT 9
14239: PUSH
14240: LD_INT 10
14242: PUSH
14243: LD_INT 11
14245: PUSH
14246: LD_INT 12
14248: PUSH
14249: LD_INT 13
14251: PUSH
14252: LD_INT 14
14254: PUSH
14255: LD_INT 15
14257: PUSH
14258: LD_INT 16
14260: PUSH
14261: LD_INT 17
14263: PUSH
14264: LD_INT 18
14266: PUSH
14267: LD_INT 19
14269: PUSH
14270: LD_INT 20
14272: PUSH
14273: LD_INT 21
14275: PUSH
14276: LD_INT 22
14278: PUSH
14279: LD_INT 23
14281: PUSH
14282: LD_INT 24
14284: PUSH
14285: LD_INT 25
14287: PUSH
14288: LD_INT 26
14290: PUSH
14291: LD_INT 27
14293: PUSH
14294: LD_INT 28
14296: PUSH
14297: LD_INT 29
14299: PUSH
14300: LD_INT 30
14302: PUSH
14303: LD_INT 31
14305: PUSH
14306: LD_INT 32
14308: PUSH
14309: LD_INT 33
14311: PUSH
14312: LD_INT 34
14314: PUSH
14315: LD_INT 35
14317: PUSH
14318: LD_INT 36
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: PUSH
14359: LD_INT 101
14361: PUSH
14362: LD_INT 102
14364: PUSH
14365: LD_INT 103
14367: PUSH
14368: LD_INT 104
14370: PUSH
14371: LD_INT 105
14373: PUSH
14374: LD_INT 106
14376: PUSH
14377: LD_INT 107
14379: PUSH
14380: LD_INT 108
14382: PUSH
14383: LD_INT 109
14385: PUSH
14386: LD_INT 110
14388: PUSH
14389: LD_INT 111
14391: PUSH
14392: LD_INT 112
14394: PUSH
14395: LD_INT 113
14397: PUSH
14398: LD_INT 114
14400: PUSH
14401: LD_INT 115
14403: PUSH
14404: EMPTY
14405: LIST
14406: LIST
14407: LIST
14408: LIST
14409: LIST
14410: LIST
14411: LIST
14412: LIST
14413: LIST
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: LIST
14420: PUSH
14421: EMPTY
14422: LIST
14423: LIST
14424: ST_TO_ADDR
14425: GO 14428
14427: POP
// end ; if result then
14428: LD_VAR 0 1
14432: IFFALSE 14721
// begin normal :=  ;
14434: LD_ADDR_VAR 0 3
14438: PUSH
14439: LD_STRING 
14441: ST_TO_ADDR
// hardcore :=  ;
14442: LD_ADDR_VAR 0 4
14446: PUSH
14447: LD_STRING 
14449: ST_TO_ADDR
// for i = 1 to normalCounter do
14450: LD_ADDR_VAR 0 5
14454: PUSH
14455: DOUBLE
14456: LD_INT 1
14458: DEC
14459: ST_TO_ADDR
14460: LD_EXP 31
14464: PUSH
14465: FOR_TO
14466: IFFALSE 14567
// begin tmp := 0 ;
14468: LD_ADDR_VAR 0 2
14472: PUSH
14473: LD_STRING 0
14475: ST_TO_ADDR
// if result [ 1 ] then
14476: LD_VAR 0 1
14480: PUSH
14481: LD_INT 1
14483: ARRAY
14484: IFFALSE 14549
// if result [ 1 ] [ 1 ] = i then
14486: LD_VAR 0 1
14490: PUSH
14491: LD_INT 1
14493: ARRAY
14494: PUSH
14495: LD_INT 1
14497: ARRAY
14498: PUSH
14499: LD_VAR 0 5
14503: EQUAL
14504: IFFALSE 14549
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
14506: LD_ADDR_VAR 0 1
14510: PUSH
14511: LD_VAR 0 1
14515: PPUSH
14516: LD_INT 1
14518: PPUSH
14519: LD_VAR 0 1
14523: PUSH
14524: LD_INT 1
14526: ARRAY
14527: PPUSH
14528: LD_INT 1
14530: PPUSH
14531: CALL_OW 3
14535: PPUSH
14536: CALL_OW 1
14540: ST_TO_ADDR
// tmp := 1 ;
14541: LD_ADDR_VAR 0 2
14545: PUSH
14546: LD_STRING 1
14548: ST_TO_ADDR
// end ; normal := normal & tmp ;
14549: LD_ADDR_VAR 0 3
14553: PUSH
14554: LD_VAR 0 3
14558: PUSH
14559: LD_VAR 0 2
14563: STR
14564: ST_TO_ADDR
// end ;
14565: GO 14465
14567: POP
14568: POP
// for i = 1 to hardcoreCounter do
14569: LD_ADDR_VAR 0 5
14573: PUSH
14574: DOUBLE
14575: LD_INT 1
14577: DEC
14578: ST_TO_ADDR
14579: LD_EXP 32
14583: PUSH
14584: FOR_TO
14585: IFFALSE 14690
// begin tmp := 0 ;
14587: LD_ADDR_VAR 0 2
14591: PUSH
14592: LD_STRING 0
14594: ST_TO_ADDR
// if result [ 2 ] then
14595: LD_VAR 0 1
14599: PUSH
14600: LD_INT 2
14602: ARRAY
14603: IFFALSE 14672
// if result [ 2 ] [ 1 ] = 100 + i then
14605: LD_VAR 0 1
14609: PUSH
14610: LD_INT 2
14612: ARRAY
14613: PUSH
14614: LD_INT 1
14616: ARRAY
14617: PUSH
14618: LD_INT 100
14620: PUSH
14621: LD_VAR 0 5
14625: PLUS
14626: EQUAL
14627: IFFALSE 14672
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
14629: LD_ADDR_VAR 0 1
14633: PUSH
14634: LD_VAR 0 1
14638: PPUSH
14639: LD_INT 2
14641: PPUSH
14642: LD_VAR 0 1
14646: PUSH
14647: LD_INT 2
14649: ARRAY
14650: PPUSH
14651: LD_INT 1
14653: PPUSH
14654: CALL_OW 3
14658: PPUSH
14659: CALL_OW 1
14663: ST_TO_ADDR
// tmp := 1 ;
14664: LD_ADDR_VAR 0 2
14668: PUSH
14669: LD_STRING 1
14671: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
14672: LD_ADDR_VAR 0 4
14676: PUSH
14677: LD_VAR 0 4
14681: PUSH
14682: LD_VAR 0 2
14686: STR
14687: ST_TO_ADDR
// end ;
14688: GO 14584
14690: POP
14691: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
14692: LD_STRING getStreamItemsFromMission("
14694: PUSH
14695: LD_VAR 0 3
14699: STR
14700: PUSH
14701: LD_STRING ","
14703: STR
14704: PUSH
14705: LD_VAR 0 4
14709: STR
14710: PUSH
14711: LD_STRING ")
14713: STR
14714: PPUSH
14715: CALL_OW 559
// end else
14719: GO 14728
// ToLua ( getStreamItemsFromMission("","") ) ;
14721: LD_STRING getStreamItemsFromMission("","")
14723: PPUSH
14724: CALL_OW 559
// end ;
14728: LD_VAR 0 1
14732: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
14733: LD_VAR 0 2
14737: PUSH
14738: LD_INT 100
14740: EQUAL
14741: IFFALSE 15690
// begin if not StreamModeActive then
14743: LD_EXP 30
14747: NOT
14748: IFFALSE 14758
// StreamModeActive := true ;
14750: LD_ADDR_EXP 30
14754: PUSH
14755: LD_INT 1
14757: ST_TO_ADDR
// if p3 = 0 then
14758: LD_VAR 0 3
14762: PUSH
14763: LD_INT 0
14765: EQUAL
14766: IFFALSE 14772
// InitStreamMode ;
14768: CALL 11018 0 0
// if p3 = 1 then
14772: LD_VAR 0 3
14776: PUSH
14777: LD_INT 1
14779: EQUAL
14780: IFFALSE 14790
// sRocket := true ;
14782: LD_ADDR_EXP 35
14786: PUSH
14787: LD_INT 1
14789: ST_TO_ADDR
// if p3 = 2 then
14790: LD_VAR 0 3
14794: PUSH
14795: LD_INT 2
14797: EQUAL
14798: IFFALSE 14808
// sSpeed := true ;
14800: LD_ADDR_EXP 34
14804: PUSH
14805: LD_INT 1
14807: ST_TO_ADDR
// if p3 = 3 then
14808: LD_VAR 0 3
14812: PUSH
14813: LD_INT 3
14815: EQUAL
14816: IFFALSE 14826
// sEngine := true ;
14818: LD_ADDR_EXP 36
14822: PUSH
14823: LD_INT 1
14825: ST_TO_ADDR
// if p3 = 4 then
14826: LD_VAR 0 3
14830: PUSH
14831: LD_INT 4
14833: EQUAL
14834: IFFALSE 14844
// sSpec := true ;
14836: LD_ADDR_EXP 33
14840: PUSH
14841: LD_INT 1
14843: ST_TO_ADDR
// if p3 = 5 then
14844: LD_VAR 0 3
14848: PUSH
14849: LD_INT 5
14851: EQUAL
14852: IFFALSE 14862
// sLevel := true ;
14854: LD_ADDR_EXP 37
14858: PUSH
14859: LD_INT 1
14861: ST_TO_ADDR
// if p3 = 6 then
14862: LD_VAR 0 3
14866: PUSH
14867: LD_INT 6
14869: EQUAL
14870: IFFALSE 14880
// sArmoury := true ;
14872: LD_ADDR_EXP 38
14876: PUSH
14877: LD_INT 1
14879: ST_TO_ADDR
// if p3 = 7 then
14880: LD_VAR 0 3
14884: PUSH
14885: LD_INT 7
14887: EQUAL
14888: IFFALSE 14898
// sRadar := true ;
14890: LD_ADDR_EXP 39
14894: PUSH
14895: LD_INT 1
14897: ST_TO_ADDR
// if p3 = 8 then
14898: LD_VAR 0 3
14902: PUSH
14903: LD_INT 8
14905: EQUAL
14906: IFFALSE 14916
// sBunker := true ;
14908: LD_ADDR_EXP 40
14912: PUSH
14913: LD_INT 1
14915: ST_TO_ADDR
// if p3 = 9 then
14916: LD_VAR 0 3
14920: PUSH
14921: LD_INT 9
14923: EQUAL
14924: IFFALSE 14934
// sHack := true ;
14926: LD_ADDR_EXP 41
14930: PUSH
14931: LD_INT 1
14933: ST_TO_ADDR
// if p3 = 10 then
14934: LD_VAR 0 3
14938: PUSH
14939: LD_INT 10
14941: EQUAL
14942: IFFALSE 14952
// sFire := true ;
14944: LD_ADDR_EXP 42
14948: PUSH
14949: LD_INT 1
14951: ST_TO_ADDR
// if p3 = 11 then
14952: LD_VAR 0 3
14956: PUSH
14957: LD_INT 11
14959: EQUAL
14960: IFFALSE 14970
// sRefresh := true ;
14962: LD_ADDR_EXP 43
14966: PUSH
14967: LD_INT 1
14969: ST_TO_ADDR
// if p3 = 12 then
14970: LD_VAR 0 3
14974: PUSH
14975: LD_INT 12
14977: EQUAL
14978: IFFALSE 14988
// sExp := true ;
14980: LD_ADDR_EXP 44
14984: PUSH
14985: LD_INT 1
14987: ST_TO_ADDR
// if p3 = 13 then
14988: LD_VAR 0 3
14992: PUSH
14993: LD_INT 13
14995: EQUAL
14996: IFFALSE 15006
// sDepot := true ;
14998: LD_ADDR_EXP 45
15002: PUSH
15003: LD_INT 1
15005: ST_TO_ADDR
// if p3 = 14 then
15006: LD_VAR 0 3
15010: PUSH
15011: LD_INT 14
15013: EQUAL
15014: IFFALSE 15024
// sFlag := true ;
15016: LD_ADDR_EXP 46
15020: PUSH
15021: LD_INT 1
15023: ST_TO_ADDR
// if p3 = 15 then
15024: LD_VAR 0 3
15028: PUSH
15029: LD_INT 15
15031: EQUAL
15032: IFFALSE 15042
// sKamikadze := true ;
15034: LD_ADDR_EXP 54
15038: PUSH
15039: LD_INT 1
15041: ST_TO_ADDR
// if p3 = 16 then
15042: LD_VAR 0 3
15046: PUSH
15047: LD_INT 16
15049: EQUAL
15050: IFFALSE 15060
// sTroll := true ;
15052: LD_ADDR_EXP 55
15056: PUSH
15057: LD_INT 1
15059: ST_TO_ADDR
// if p3 = 17 then
15060: LD_VAR 0 3
15064: PUSH
15065: LD_INT 17
15067: EQUAL
15068: IFFALSE 15078
// sSlow := true ;
15070: LD_ADDR_EXP 56
15074: PUSH
15075: LD_INT 1
15077: ST_TO_ADDR
// if p3 = 18 then
15078: LD_VAR 0 3
15082: PUSH
15083: LD_INT 18
15085: EQUAL
15086: IFFALSE 15096
// sLack := true ;
15088: LD_ADDR_EXP 57
15092: PUSH
15093: LD_INT 1
15095: ST_TO_ADDR
// if p3 = 19 then
15096: LD_VAR 0 3
15100: PUSH
15101: LD_INT 19
15103: EQUAL
15104: IFFALSE 15114
// sTank := true ;
15106: LD_ADDR_EXP 59
15110: PUSH
15111: LD_INT 1
15113: ST_TO_ADDR
// if p3 = 20 then
15114: LD_VAR 0 3
15118: PUSH
15119: LD_INT 20
15121: EQUAL
15122: IFFALSE 15132
// sRemote := true ;
15124: LD_ADDR_EXP 60
15128: PUSH
15129: LD_INT 1
15131: ST_TO_ADDR
// if p3 = 21 then
15132: LD_VAR 0 3
15136: PUSH
15137: LD_INT 21
15139: EQUAL
15140: IFFALSE 15150
// sPowell := true ;
15142: LD_ADDR_EXP 61
15146: PUSH
15147: LD_INT 1
15149: ST_TO_ADDR
// if p3 = 22 then
15150: LD_VAR 0 3
15154: PUSH
15155: LD_INT 22
15157: EQUAL
15158: IFFALSE 15168
// sTeleport := true ;
15160: LD_ADDR_EXP 64
15164: PUSH
15165: LD_INT 1
15167: ST_TO_ADDR
// if p3 = 23 then
15168: LD_VAR 0 3
15172: PUSH
15173: LD_INT 23
15175: EQUAL
15176: IFFALSE 15186
// sOilTower := true ;
15178: LD_ADDR_EXP 66
15182: PUSH
15183: LD_INT 1
15185: ST_TO_ADDR
// if p3 = 24 then
15186: LD_VAR 0 3
15190: PUSH
15191: LD_INT 24
15193: EQUAL
15194: IFFALSE 15204
// sShovel := true ;
15196: LD_ADDR_EXP 67
15200: PUSH
15201: LD_INT 1
15203: ST_TO_ADDR
// if p3 = 25 then
15204: LD_VAR 0 3
15208: PUSH
15209: LD_INT 25
15211: EQUAL
15212: IFFALSE 15222
// sSheik := true ;
15214: LD_ADDR_EXP 68
15218: PUSH
15219: LD_INT 1
15221: ST_TO_ADDR
// if p3 = 26 then
15222: LD_VAR 0 3
15226: PUSH
15227: LD_INT 26
15229: EQUAL
15230: IFFALSE 15240
// sEarthquake := true ;
15232: LD_ADDR_EXP 70
15236: PUSH
15237: LD_INT 1
15239: ST_TO_ADDR
// if p3 = 27 then
15240: LD_VAR 0 3
15244: PUSH
15245: LD_INT 27
15247: EQUAL
15248: IFFALSE 15258
// sAI := true ;
15250: LD_ADDR_EXP 71
15254: PUSH
15255: LD_INT 1
15257: ST_TO_ADDR
// if p3 = 28 then
15258: LD_VAR 0 3
15262: PUSH
15263: LD_INT 28
15265: EQUAL
15266: IFFALSE 15276
// sCargo := true ;
15268: LD_ADDR_EXP 74
15272: PUSH
15273: LD_INT 1
15275: ST_TO_ADDR
// if p3 = 29 then
15276: LD_VAR 0 3
15280: PUSH
15281: LD_INT 29
15283: EQUAL
15284: IFFALSE 15294
// sDLaser := true ;
15286: LD_ADDR_EXP 75
15290: PUSH
15291: LD_INT 1
15293: ST_TO_ADDR
// if p3 = 30 then
15294: LD_VAR 0 3
15298: PUSH
15299: LD_INT 30
15301: EQUAL
15302: IFFALSE 15312
// sExchange := true ;
15304: LD_ADDR_EXP 76
15308: PUSH
15309: LD_INT 1
15311: ST_TO_ADDR
// if p3 = 31 then
15312: LD_VAR 0 3
15316: PUSH
15317: LD_INT 31
15319: EQUAL
15320: IFFALSE 15330
// sFac := true ;
15322: LD_ADDR_EXP 77
15326: PUSH
15327: LD_INT 1
15329: ST_TO_ADDR
// if p3 = 32 then
15330: LD_VAR 0 3
15334: PUSH
15335: LD_INT 32
15337: EQUAL
15338: IFFALSE 15348
// sPower := true ;
15340: LD_ADDR_EXP 78
15344: PUSH
15345: LD_INT 1
15347: ST_TO_ADDR
// if p3 = 33 then
15348: LD_VAR 0 3
15352: PUSH
15353: LD_INT 33
15355: EQUAL
15356: IFFALSE 15366
// sRandom := true ;
15358: LD_ADDR_EXP 79
15362: PUSH
15363: LD_INT 1
15365: ST_TO_ADDR
// if p3 = 34 then
15366: LD_VAR 0 3
15370: PUSH
15371: LD_INT 34
15373: EQUAL
15374: IFFALSE 15384
// sShield := true ;
15376: LD_ADDR_EXP 80
15380: PUSH
15381: LD_INT 1
15383: ST_TO_ADDR
// if p3 = 35 then
15384: LD_VAR 0 3
15388: PUSH
15389: LD_INT 35
15391: EQUAL
15392: IFFALSE 15402
// sTime := true ;
15394: LD_ADDR_EXP 81
15398: PUSH
15399: LD_INT 1
15401: ST_TO_ADDR
// if p3 = 36 then
15402: LD_VAR 0 3
15406: PUSH
15407: LD_INT 36
15409: EQUAL
15410: IFFALSE 15420
// sTools := true ;
15412: LD_ADDR_EXP 82
15416: PUSH
15417: LD_INT 1
15419: ST_TO_ADDR
// if p3 = 101 then
15420: LD_VAR 0 3
15424: PUSH
15425: LD_INT 101
15427: EQUAL
15428: IFFALSE 15438
// sSold := true ;
15430: LD_ADDR_EXP 47
15434: PUSH
15435: LD_INT 1
15437: ST_TO_ADDR
// if p3 = 102 then
15438: LD_VAR 0 3
15442: PUSH
15443: LD_INT 102
15445: EQUAL
15446: IFFALSE 15456
// sDiff := true ;
15448: LD_ADDR_EXP 48
15452: PUSH
15453: LD_INT 1
15455: ST_TO_ADDR
// if p3 = 103 then
15456: LD_VAR 0 3
15460: PUSH
15461: LD_INT 103
15463: EQUAL
15464: IFFALSE 15474
// sFog := true ;
15466: LD_ADDR_EXP 51
15470: PUSH
15471: LD_INT 1
15473: ST_TO_ADDR
// if p3 = 104 then
15474: LD_VAR 0 3
15478: PUSH
15479: LD_INT 104
15481: EQUAL
15482: IFFALSE 15492
// sReset := true ;
15484: LD_ADDR_EXP 52
15488: PUSH
15489: LD_INT 1
15491: ST_TO_ADDR
// if p3 = 105 then
15492: LD_VAR 0 3
15496: PUSH
15497: LD_INT 105
15499: EQUAL
15500: IFFALSE 15510
// sSun := true ;
15502: LD_ADDR_EXP 53
15506: PUSH
15507: LD_INT 1
15509: ST_TO_ADDR
// if p3 = 106 then
15510: LD_VAR 0 3
15514: PUSH
15515: LD_INT 106
15517: EQUAL
15518: IFFALSE 15528
// sTiger := true ;
15520: LD_ADDR_EXP 49
15524: PUSH
15525: LD_INT 1
15527: ST_TO_ADDR
// if p3 = 107 then
15528: LD_VAR 0 3
15532: PUSH
15533: LD_INT 107
15535: EQUAL
15536: IFFALSE 15546
// sBomb := true ;
15538: LD_ADDR_EXP 50
15542: PUSH
15543: LD_INT 1
15545: ST_TO_ADDR
// if p3 = 108 then
15546: LD_VAR 0 3
15550: PUSH
15551: LD_INT 108
15553: EQUAL
15554: IFFALSE 15564
// sWound := true ;
15556: LD_ADDR_EXP 58
15560: PUSH
15561: LD_INT 1
15563: ST_TO_ADDR
// if p3 = 109 then
15564: LD_VAR 0 3
15568: PUSH
15569: LD_INT 109
15571: EQUAL
15572: IFFALSE 15582
// sBetray := true ;
15574: LD_ADDR_EXP 62
15578: PUSH
15579: LD_INT 1
15581: ST_TO_ADDR
// if p3 = 110 then
15582: LD_VAR 0 3
15586: PUSH
15587: LD_INT 110
15589: EQUAL
15590: IFFALSE 15600
// sContamin := true ;
15592: LD_ADDR_EXP 63
15596: PUSH
15597: LD_INT 1
15599: ST_TO_ADDR
// if p3 = 111 then
15600: LD_VAR 0 3
15604: PUSH
15605: LD_INT 111
15607: EQUAL
15608: IFFALSE 15618
// sOil := true ;
15610: LD_ADDR_EXP 65
15614: PUSH
15615: LD_INT 1
15617: ST_TO_ADDR
// if p3 = 112 then
15618: LD_VAR 0 3
15622: PUSH
15623: LD_INT 112
15625: EQUAL
15626: IFFALSE 15636
// sStu := true ;
15628: LD_ADDR_EXP 69
15632: PUSH
15633: LD_INT 1
15635: ST_TO_ADDR
// if p3 = 113 then
15636: LD_VAR 0 3
15640: PUSH
15641: LD_INT 113
15643: EQUAL
15644: IFFALSE 15654
// sBazooka := true ;
15646: LD_ADDR_EXP 72
15650: PUSH
15651: LD_INT 1
15653: ST_TO_ADDR
// if p3 = 114 then
15654: LD_VAR 0 3
15658: PUSH
15659: LD_INT 114
15661: EQUAL
15662: IFFALSE 15672
// sMortar := true ;
15664: LD_ADDR_EXP 73
15668: PUSH
15669: LD_INT 1
15671: ST_TO_ADDR
// if p3 = 115 then
15672: LD_VAR 0 3
15676: PUSH
15677: LD_INT 115
15679: EQUAL
15680: IFFALSE 15690
// sRanger := true ;
15682: LD_ADDR_EXP 83
15686: PUSH
15687: LD_INT 1
15689: ST_TO_ADDR
// end ; end ;
15690: PPOPN 6
15692: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
15693: LD_EXP 30
15697: PUSH
15698: LD_EXP 35
15702: AND
15703: IFFALSE 15827
15705: GO 15707
15707: DISABLE
15708: LD_INT 0
15710: PPUSH
15711: PPUSH
// begin enable ;
15712: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
15713: LD_ADDR_VAR 0 2
15717: PUSH
15718: LD_INT 22
15720: PUSH
15721: LD_OWVAR 2
15725: PUSH
15726: EMPTY
15727: LIST
15728: LIST
15729: PUSH
15730: LD_INT 2
15732: PUSH
15733: LD_INT 34
15735: PUSH
15736: LD_INT 7
15738: PUSH
15739: EMPTY
15740: LIST
15741: LIST
15742: PUSH
15743: LD_INT 34
15745: PUSH
15746: LD_INT 45
15748: PUSH
15749: EMPTY
15750: LIST
15751: LIST
15752: PUSH
15753: LD_INT 34
15755: PUSH
15756: LD_INT 28
15758: PUSH
15759: EMPTY
15760: LIST
15761: LIST
15762: PUSH
15763: LD_INT 34
15765: PUSH
15766: LD_INT 47
15768: PUSH
15769: EMPTY
15770: LIST
15771: LIST
15772: PUSH
15773: EMPTY
15774: LIST
15775: LIST
15776: LIST
15777: LIST
15778: LIST
15779: PUSH
15780: EMPTY
15781: LIST
15782: LIST
15783: PPUSH
15784: CALL_OW 69
15788: ST_TO_ADDR
// if not tmp then
15789: LD_VAR 0 2
15793: NOT
15794: IFFALSE 15798
// exit ;
15796: GO 15827
// for i in tmp do
15798: LD_ADDR_VAR 0 1
15802: PUSH
15803: LD_VAR 0 2
15807: PUSH
15808: FOR_IN
15809: IFFALSE 15825
// begin SetLives ( i , 0 ) ;
15811: LD_VAR 0 1
15815: PPUSH
15816: LD_INT 0
15818: PPUSH
15819: CALL_OW 234
// end ;
15823: GO 15808
15825: POP
15826: POP
// end ;
15827: PPOPN 2
15829: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
15830: LD_EXP 30
15834: PUSH
15835: LD_EXP 36
15839: AND
15840: IFFALSE 15924
15842: GO 15844
15844: DISABLE
15845: LD_INT 0
15847: PPUSH
15848: PPUSH
// begin enable ;
15849: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
15850: LD_ADDR_VAR 0 2
15854: PUSH
15855: LD_INT 22
15857: PUSH
15858: LD_OWVAR 2
15862: PUSH
15863: EMPTY
15864: LIST
15865: LIST
15866: PUSH
15867: LD_INT 32
15869: PUSH
15870: LD_INT 3
15872: PUSH
15873: EMPTY
15874: LIST
15875: LIST
15876: PUSH
15877: EMPTY
15878: LIST
15879: LIST
15880: PPUSH
15881: CALL_OW 69
15885: ST_TO_ADDR
// if not tmp then
15886: LD_VAR 0 2
15890: NOT
15891: IFFALSE 15895
// exit ;
15893: GO 15924
// for i in tmp do
15895: LD_ADDR_VAR 0 1
15899: PUSH
15900: LD_VAR 0 2
15904: PUSH
15905: FOR_IN
15906: IFFALSE 15922
// begin SetLives ( i , 0 ) ;
15908: LD_VAR 0 1
15912: PPUSH
15913: LD_INT 0
15915: PPUSH
15916: CALL_OW 234
// end ;
15920: GO 15905
15922: POP
15923: POP
// end ;
15924: PPOPN 2
15926: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
15927: LD_EXP 30
15931: PUSH
15932: LD_EXP 33
15936: AND
15937: IFFALSE 16030
15939: GO 15941
15941: DISABLE
15942: LD_INT 0
15944: PPUSH
// begin enable ;
15945: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
15946: LD_ADDR_VAR 0 1
15950: PUSH
15951: LD_INT 22
15953: PUSH
15954: LD_OWVAR 2
15958: PUSH
15959: EMPTY
15960: LIST
15961: LIST
15962: PUSH
15963: LD_INT 2
15965: PUSH
15966: LD_INT 25
15968: PUSH
15969: LD_INT 5
15971: PUSH
15972: EMPTY
15973: LIST
15974: LIST
15975: PUSH
15976: LD_INT 25
15978: PUSH
15979: LD_INT 9
15981: PUSH
15982: EMPTY
15983: LIST
15984: LIST
15985: PUSH
15986: LD_INT 25
15988: PUSH
15989: LD_INT 8
15991: PUSH
15992: EMPTY
15993: LIST
15994: LIST
15995: PUSH
15996: EMPTY
15997: LIST
15998: LIST
15999: LIST
16000: LIST
16001: PUSH
16002: EMPTY
16003: LIST
16004: LIST
16005: PPUSH
16006: CALL_OW 69
16010: PUSH
16011: FOR_IN
16012: IFFALSE 16028
// begin SetClass ( i , 1 ) ;
16014: LD_VAR 0 1
16018: PPUSH
16019: LD_INT 1
16021: PPUSH
16022: CALL_OW 336
// end ;
16026: GO 16011
16028: POP
16029: POP
// end ;
16030: PPOPN 1
16032: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
16033: LD_EXP 30
16037: PUSH
16038: LD_EXP 34
16042: AND
16043: PUSH
16044: LD_OWVAR 65
16048: PUSH
16049: LD_INT 7
16051: LESS
16052: AND
16053: IFFALSE 16067
16055: GO 16057
16057: DISABLE
// begin enable ;
16058: ENABLE
// game_speed := 7 ;
16059: LD_ADDR_OWVAR 65
16063: PUSH
16064: LD_INT 7
16066: ST_TO_ADDR
// end ;
16067: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
16068: LD_EXP 30
16072: PUSH
16073: LD_EXP 37
16077: AND
16078: IFFALSE 16280
16080: GO 16082
16082: DISABLE
16083: LD_INT 0
16085: PPUSH
16086: PPUSH
16087: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
16088: LD_ADDR_VAR 0 3
16092: PUSH
16093: LD_INT 81
16095: PUSH
16096: LD_OWVAR 2
16100: PUSH
16101: EMPTY
16102: LIST
16103: LIST
16104: PUSH
16105: LD_INT 21
16107: PUSH
16108: LD_INT 1
16110: PUSH
16111: EMPTY
16112: LIST
16113: LIST
16114: PUSH
16115: EMPTY
16116: LIST
16117: LIST
16118: PPUSH
16119: CALL_OW 69
16123: ST_TO_ADDR
// if not tmp then
16124: LD_VAR 0 3
16128: NOT
16129: IFFALSE 16133
// exit ;
16131: GO 16280
// if tmp > 5 then
16133: LD_VAR 0 3
16137: PUSH
16138: LD_INT 5
16140: GREATER
16141: IFFALSE 16153
// k := 5 else
16143: LD_ADDR_VAR 0 2
16147: PUSH
16148: LD_INT 5
16150: ST_TO_ADDR
16151: GO 16163
// k := tmp ;
16153: LD_ADDR_VAR 0 2
16157: PUSH
16158: LD_VAR 0 3
16162: ST_TO_ADDR
// for i := 1 to k do
16163: LD_ADDR_VAR 0 1
16167: PUSH
16168: DOUBLE
16169: LD_INT 1
16171: DEC
16172: ST_TO_ADDR
16173: LD_VAR 0 2
16177: PUSH
16178: FOR_TO
16179: IFFALSE 16278
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
16181: LD_VAR 0 3
16185: PUSH
16186: LD_VAR 0 1
16190: ARRAY
16191: PPUSH
16192: LD_VAR 0 1
16196: PUSH
16197: LD_INT 4
16199: MOD
16200: PUSH
16201: LD_INT 1
16203: PLUS
16204: PPUSH
16205: CALL_OW 259
16209: PUSH
16210: LD_INT 10
16212: LESS
16213: IFFALSE 16276
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
16215: LD_VAR 0 3
16219: PUSH
16220: LD_VAR 0 1
16224: ARRAY
16225: PPUSH
16226: LD_VAR 0 1
16230: PUSH
16231: LD_INT 4
16233: MOD
16234: PUSH
16235: LD_INT 1
16237: PLUS
16238: PPUSH
16239: LD_VAR 0 3
16243: PUSH
16244: LD_VAR 0 1
16248: ARRAY
16249: PPUSH
16250: LD_VAR 0 1
16254: PUSH
16255: LD_INT 4
16257: MOD
16258: PUSH
16259: LD_INT 1
16261: PLUS
16262: PPUSH
16263: CALL_OW 259
16267: PUSH
16268: LD_INT 1
16270: PLUS
16271: PPUSH
16272: CALL_OW 237
16276: GO 16178
16278: POP
16279: POP
// end ;
16280: PPOPN 3
16282: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
16283: LD_EXP 30
16287: PUSH
16288: LD_EXP 38
16292: AND
16293: IFFALSE 16313
16295: GO 16297
16297: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
16298: LD_INT 4
16300: PPUSH
16301: LD_OWVAR 2
16305: PPUSH
16306: LD_INT 0
16308: PPUSH
16309: CALL_OW 324
16313: END
// every 0 0$1 trigger StreamModeActive and sShovel do
16314: LD_EXP 30
16318: PUSH
16319: LD_EXP 67
16323: AND
16324: IFFALSE 16344
16326: GO 16328
16328: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
16329: LD_INT 19
16331: PPUSH
16332: LD_OWVAR 2
16336: PPUSH
16337: LD_INT 0
16339: PPUSH
16340: CALL_OW 324
16344: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
16345: LD_EXP 30
16349: PUSH
16350: LD_EXP 39
16354: AND
16355: IFFALSE 16457
16357: GO 16359
16359: DISABLE
16360: LD_INT 0
16362: PPUSH
16363: PPUSH
// begin enable ;
16364: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
16365: LD_ADDR_VAR 0 2
16369: PUSH
16370: LD_INT 22
16372: PUSH
16373: LD_OWVAR 2
16377: PUSH
16378: EMPTY
16379: LIST
16380: LIST
16381: PUSH
16382: LD_INT 2
16384: PUSH
16385: LD_INT 34
16387: PUSH
16388: LD_INT 11
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: PUSH
16395: LD_INT 34
16397: PUSH
16398: LD_INT 30
16400: PUSH
16401: EMPTY
16402: LIST
16403: LIST
16404: PUSH
16405: EMPTY
16406: LIST
16407: LIST
16408: LIST
16409: PUSH
16410: EMPTY
16411: LIST
16412: LIST
16413: PPUSH
16414: CALL_OW 69
16418: ST_TO_ADDR
// if not tmp then
16419: LD_VAR 0 2
16423: NOT
16424: IFFALSE 16428
// exit ;
16426: GO 16457
// for i in tmp do
16428: LD_ADDR_VAR 0 1
16432: PUSH
16433: LD_VAR 0 2
16437: PUSH
16438: FOR_IN
16439: IFFALSE 16455
// begin SetLives ( i , 0 ) ;
16441: LD_VAR 0 1
16445: PPUSH
16446: LD_INT 0
16448: PPUSH
16449: CALL_OW 234
// end ;
16453: GO 16438
16455: POP
16456: POP
// end ;
16457: PPOPN 2
16459: END
// every 0 0$1 trigger StreamModeActive and sBunker do
16460: LD_EXP 30
16464: PUSH
16465: LD_EXP 40
16469: AND
16470: IFFALSE 16490
16472: GO 16474
16474: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
16475: LD_INT 32
16477: PPUSH
16478: LD_OWVAR 2
16482: PPUSH
16483: LD_INT 0
16485: PPUSH
16486: CALL_OW 324
16490: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
16491: LD_EXP 30
16495: PUSH
16496: LD_EXP 41
16500: AND
16501: IFFALSE 16682
16503: GO 16505
16505: DISABLE
16506: LD_INT 0
16508: PPUSH
16509: PPUSH
16510: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
16511: LD_ADDR_VAR 0 2
16515: PUSH
16516: LD_INT 22
16518: PUSH
16519: LD_OWVAR 2
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: PUSH
16528: LD_INT 33
16530: PUSH
16531: LD_INT 3
16533: PUSH
16534: EMPTY
16535: LIST
16536: LIST
16537: PUSH
16538: EMPTY
16539: LIST
16540: LIST
16541: PPUSH
16542: CALL_OW 69
16546: ST_TO_ADDR
// if not tmp then
16547: LD_VAR 0 2
16551: NOT
16552: IFFALSE 16556
// exit ;
16554: GO 16682
// side := 0 ;
16556: LD_ADDR_VAR 0 3
16560: PUSH
16561: LD_INT 0
16563: ST_TO_ADDR
// for i := 1 to 8 do
16564: LD_ADDR_VAR 0 1
16568: PUSH
16569: DOUBLE
16570: LD_INT 1
16572: DEC
16573: ST_TO_ADDR
16574: LD_INT 8
16576: PUSH
16577: FOR_TO
16578: IFFALSE 16626
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
16580: LD_OWVAR 2
16584: PUSH
16585: LD_VAR 0 1
16589: NONEQUAL
16590: PUSH
16591: LD_OWVAR 2
16595: PPUSH
16596: LD_VAR 0 1
16600: PPUSH
16601: CALL_OW 81
16605: PUSH
16606: LD_INT 2
16608: EQUAL
16609: AND
16610: IFFALSE 16624
// begin side := i ;
16612: LD_ADDR_VAR 0 3
16616: PUSH
16617: LD_VAR 0 1
16621: ST_TO_ADDR
// break ;
16622: GO 16626
// end ;
16624: GO 16577
16626: POP
16627: POP
// if not side then
16628: LD_VAR 0 3
16632: NOT
16633: IFFALSE 16637
// exit ;
16635: GO 16682
// for i := 1 to tmp do
16637: LD_ADDR_VAR 0 1
16641: PUSH
16642: DOUBLE
16643: LD_INT 1
16645: DEC
16646: ST_TO_ADDR
16647: LD_VAR 0 2
16651: PUSH
16652: FOR_TO
16653: IFFALSE 16680
// if Prob ( 30 ) then
16655: LD_INT 30
16657: PPUSH
16658: CALL_OW 13
16662: IFFALSE 16678
// SetSide ( i , side ) ;
16664: LD_VAR 0 1
16668: PPUSH
16669: LD_VAR 0 3
16673: PPUSH
16674: CALL_OW 235
16678: GO 16652
16680: POP
16681: POP
// end ;
16682: PPOPN 3
16684: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
16685: LD_EXP 30
16689: PUSH
16690: LD_EXP 43
16694: AND
16695: IFFALSE 16814
16697: GO 16699
16699: DISABLE
16700: LD_INT 0
16702: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
16703: LD_ADDR_VAR 0 1
16707: PUSH
16708: LD_INT 22
16710: PUSH
16711: LD_OWVAR 2
16715: PUSH
16716: EMPTY
16717: LIST
16718: LIST
16719: PUSH
16720: LD_INT 21
16722: PUSH
16723: LD_INT 1
16725: PUSH
16726: EMPTY
16727: LIST
16728: LIST
16729: PUSH
16730: LD_INT 3
16732: PUSH
16733: LD_INT 23
16735: PUSH
16736: LD_INT 0
16738: PUSH
16739: EMPTY
16740: LIST
16741: LIST
16742: PUSH
16743: EMPTY
16744: LIST
16745: LIST
16746: PUSH
16747: EMPTY
16748: LIST
16749: LIST
16750: LIST
16751: PPUSH
16752: CALL_OW 69
16756: PUSH
16757: FOR_IN
16758: IFFALSE 16812
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
16760: LD_VAR 0 1
16764: PPUSH
16765: CALL_OW 257
16769: PUSH
16770: LD_INT 1
16772: PUSH
16773: LD_INT 2
16775: PUSH
16776: LD_INT 3
16778: PUSH
16779: LD_INT 4
16781: PUSH
16782: EMPTY
16783: LIST
16784: LIST
16785: LIST
16786: LIST
16787: IN
16788: IFFALSE 16810
// SetClass ( un , rand ( 1 , 4 ) ) ;
16790: LD_VAR 0 1
16794: PPUSH
16795: LD_INT 1
16797: PPUSH
16798: LD_INT 4
16800: PPUSH
16801: CALL_OW 12
16805: PPUSH
16806: CALL_OW 336
16810: GO 16757
16812: POP
16813: POP
// end ;
16814: PPOPN 1
16816: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
16817: LD_EXP 30
16821: PUSH
16822: LD_EXP 42
16826: AND
16827: IFFALSE 16906
16829: GO 16831
16831: DISABLE
16832: LD_INT 0
16834: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
16835: LD_ADDR_VAR 0 1
16839: PUSH
16840: LD_INT 22
16842: PUSH
16843: LD_OWVAR 2
16847: PUSH
16848: EMPTY
16849: LIST
16850: LIST
16851: PUSH
16852: LD_INT 21
16854: PUSH
16855: LD_INT 3
16857: PUSH
16858: EMPTY
16859: LIST
16860: LIST
16861: PUSH
16862: EMPTY
16863: LIST
16864: LIST
16865: PPUSH
16866: CALL_OW 69
16870: ST_TO_ADDR
// if not tmp then
16871: LD_VAR 0 1
16875: NOT
16876: IFFALSE 16880
// exit ;
16878: GO 16906
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
16880: LD_VAR 0 1
16884: PUSH
16885: LD_INT 1
16887: PPUSH
16888: LD_VAR 0 1
16892: PPUSH
16893: CALL_OW 12
16897: ARRAY
16898: PPUSH
16899: LD_INT 100
16901: PPUSH
16902: CALL_OW 234
// end ;
16906: PPOPN 1
16908: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
16909: LD_EXP 30
16913: PUSH
16914: LD_EXP 44
16918: AND
16919: IFFALSE 17017
16921: GO 16923
16923: DISABLE
16924: LD_INT 0
16926: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16927: LD_ADDR_VAR 0 1
16931: PUSH
16932: LD_INT 22
16934: PUSH
16935: LD_OWVAR 2
16939: PUSH
16940: EMPTY
16941: LIST
16942: LIST
16943: PUSH
16944: LD_INT 21
16946: PUSH
16947: LD_INT 1
16949: PUSH
16950: EMPTY
16951: LIST
16952: LIST
16953: PUSH
16954: EMPTY
16955: LIST
16956: LIST
16957: PPUSH
16958: CALL_OW 69
16962: ST_TO_ADDR
// if not tmp then
16963: LD_VAR 0 1
16967: NOT
16968: IFFALSE 16972
// exit ;
16970: GO 17017
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
16972: LD_VAR 0 1
16976: PUSH
16977: LD_INT 1
16979: PPUSH
16980: LD_VAR 0 1
16984: PPUSH
16985: CALL_OW 12
16989: ARRAY
16990: PPUSH
16991: LD_INT 1
16993: PPUSH
16994: LD_INT 4
16996: PPUSH
16997: CALL_OW 12
17001: PPUSH
17002: LD_INT 3000
17004: PPUSH
17005: LD_INT 9000
17007: PPUSH
17008: CALL_OW 12
17012: PPUSH
17013: CALL_OW 492
// end ;
17017: PPOPN 1
17019: END
// every 0 0$1 trigger StreamModeActive and sDepot do
17020: LD_EXP 30
17024: PUSH
17025: LD_EXP 45
17029: AND
17030: IFFALSE 17050
17032: GO 17034
17034: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
17035: LD_INT 1
17037: PPUSH
17038: LD_OWVAR 2
17042: PPUSH
17043: LD_INT 0
17045: PPUSH
17046: CALL_OW 324
17050: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
17051: LD_EXP 30
17055: PUSH
17056: LD_EXP 46
17060: AND
17061: IFFALSE 17144
17063: GO 17065
17065: DISABLE
17066: LD_INT 0
17068: PPUSH
17069: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17070: LD_ADDR_VAR 0 2
17074: PUSH
17075: LD_INT 22
17077: PUSH
17078: LD_OWVAR 2
17082: PUSH
17083: EMPTY
17084: LIST
17085: LIST
17086: PUSH
17087: LD_INT 21
17089: PUSH
17090: LD_INT 3
17092: PUSH
17093: EMPTY
17094: LIST
17095: LIST
17096: PUSH
17097: EMPTY
17098: LIST
17099: LIST
17100: PPUSH
17101: CALL_OW 69
17105: ST_TO_ADDR
// if not tmp then
17106: LD_VAR 0 2
17110: NOT
17111: IFFALSE 17115
// exit ;
17113: GO 17144
// for i in tmp do
17115: LD_ADDR_VAR 0 1
17119: PUSH
17120: LD_VAR 0 2
17124: PUSH
17125: FOR_IN
17126: IFFALSE 17142
// SetBLevel ( i , 10 ) ;
17128: LD_VAR 0 1
17132: PPUSH
17133: LD_INT 10
17135: PPUSH
17136: CALL_OW 241
17140: GO 17125
17142: POP
17143: POP
// end ;
17144: PPOPN 2
17146: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
17147: LD_EXP 30
17151: PUSH
17152: LD_EXP 47
17156: AND
17157: IFFALSE 17268
17159: GO 17161
17161: DISABLE
17162: LD_INT 0
17164: PPUSH
17165: PPUSH
17166: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17167: LD_ADDR_VAR 0 3
17171: PUSH
17172: LD_INT 22
17174: PUSH
17175: LD_OWVAR 2
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: PUSH
17184: LD_INT 25
17186: PUSH
17187: LD_INT 1
17189: PUSH
17190: EMPTY
17191: LIST
17192: LIST
17193: PUSH
17194: EMPTY
17195: LIST
17196: LIST
17197: PPUSH
17198: CALL_OW 69
17202: ST_TO_ADDR
// if not tmp then
17203: LD_VAR 0 3
17207: NOT
17208: IFFALSE 17212
// exit ;
17210: GO 17268
// un := tmp [ rand ( 1 , tmp ) ] ;
17212: LD_ADDR_VAR 0 2
17216: PUSH
17217: LD_VAR 0 3
17221: PUSH
17222: LD_INT 1
17224: PPUSH
17225: LD_VAR 0 3
17229: PPUSH
17230: CALL_OW 12
17234: ARRAY
17235: ST_TO_ADDR
// if Crawls ( un ) then
17236: LD_VAR 0 2
17240: PPUSH
17241: CALL_OW 318
17245: IFFALSE 17256
// ComWalk ( un ) ;
17247: LD_VAR 0 2
17251: PPUSH
17252: CALL_OW 138
// SetClass ( un , class_sniper ) ;
17256: LD_VAR 0 2
17260: PPUSH
17261: LD_INT 5
17263: PPUSH
17264: CALL_OW 336
// end ;
17268: PPOPN 3
17270: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
17271: LD_EXP 30
17275: PUSH
17276: LD_EXP 48
17280: AND
17281: PUSH
17282: LD_OWVAR 67
17286: PUSH
17287: LD_INT 3
17289: LESS
17290: AND
17291: IFFALSE 17310
17293: GO 17295
17295: DISABLE
// Difficulty := Difficulty + 1 ;
17296: LD_ADDR_OWVAR 67
17300: PUSH
17301: LD_OWVAR 67
17305: PUSH
17306: LD_INT 1
17308: PLUS
17309: ST_TO_ADDR
17310: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
17311: LD_EXP 30
17315: PUSH
17316: LD_EXP 49
17320: AND
17321: IFFALSE 17424
17323: GO 17325
17325: DISABLE
17326: LD_INT 0
17328: PPUSH
// begin for i := 1 to 5 do
17329: LD_ADDR_VAR 0 1
17333: PUSH
17334: DOUBLE
17335: LD_INT 1
17337: DEC
17338: ST_TO_ADDR
17339: LD_INT 5
17341: PUSH
17342: FOR_TO
17343: IFFALSE 17422
// begin uc_nation := nation_nature ;
17345: LD_ADDR_OWVAR 21
17349: PUSH
17350: LD_INT 0
17352: ST_TO_ADDR
// uc_side := 0 ;
17353: LD_ADDR_OWVAR 20
17357: PUSH
17358: LD_INT 0
17360: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17361: LD_ADDR_OWVAR 29
17365: PUSH
17366: LD_INT 12
17368: PUSH
17369: LD_INT 12
17371: PUSH
17372: EMPTY
17373: LIST
17374: LIST
17375: ST_TO_ADDR
// hc_agressivity := 20 ;
17376: LD_ADDR_OWVAR 35
17380: PUSH
17381: LD_INT 20
17383: ST_TO_ADDR
// hc_class := class_tiger ;
17384: LD_ADDR_OWVAR 28
17388: PUSH
17389: LD_INT 14
17391: ST_TO_ADDR
// hc_gallery :=  ;
17392: LD_ADDR_OWVAR 33
17396: PUSH
17397: LD_STRING 
17399: ST_TO_ADDR
// hc_name :=  ;
17400: LD_ADDR_OWVAR 26
17404: PUSH
17405: LD_STRING 
17407: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
17408: CALL_OW 44
17412: PPUSH
17413: LD_INT 0
17415: PPUSH
17416: CALL_OW 51
// end ;
17420: GO 17342
17422: POP
17423: POP
// end ;
17424: PPOPN 1
17426: END
// every 0 0$1 trigger StreamModeActive and sBomb do
17427: LD_EXP 30
17431: PUSH
17432: LD_EXP 50
17436: AND
17437: IFFALSE 17446
17439: GO 17441
17441: DISABLE
// StreamSibBomb ;
17442: CALL 17447 0 0
17446: END
// export function StreamSibBomb ; var i , x , y ; begin
17447: LD_INT 0
17449: PPUSH
17450: PPUSH
17451: PPUSH
17452: PPUSH
// result := false ;
17453: LD_ADDR_VAR 0 1
17457: PUSH
17458: LD_INT 0
17460: ST_TO_ADDR
// for i := 1 to 16 do
17461: LD_ADDR_VAR 0 2
17465: PUSH
17466: DOUBLE
17467: LD_INT 1
17469: DEC
17470: ST_TO_ADDR
17471: LD_INT 16
17473: PUSH
17474: FOR_TO
17475: IFFALSE 17674
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17477: LD_ADDR_VAR 0 3
17481: PUSH
17482: LD_INT 10
17484: PUSH
17485: LD_INT 20
17487: PUSH
17488: LD_INT 30
17490: PUSH
17491: LD_INT 40
17493: PUSH
17494: LD_INT 50
17496: PUSH
17497: LD_INT 60
17499: PUSH
17500: LD_INT 70
17502: PUSH
17503: LD_INT 80
17505: PUSH
17506: LD_INT 90
17508: PUSH
17509: LD_INT 100
17511: PUSH
17512: LD_INT 110
17514: PUSH
17515: LD_INT 120
17517: PUSH
17518: LD_INT 130
17520: PUSH
17521: LD_INT 140
17523: PUSH
17524: LD_INT 150
17526: PUSH
17527: EMPTY
17528: LIST
17529: LIST
17530: LIST
17531: LIST
17532: LIST
17533: LIST
17534: LIST
17535: LIST
17536: LIST
17537: LIST
17538: LIST
17539: LIST
17540: LIST
17541: LIST
17542: LIST
17543: PUSH
17544: LD_INT 1
17546: PPUSH
17547: LD_INT 15
17549: PPUSH
17550: CALL_OW 12
17554: ARRAY
17555: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17556: LD_ADDR_VAR 0 4
17560: PUSH
17561: LD_INT 10
17563: PUSH
17564: LD_INT 20
17566: PUSH
17567: LD_INT 30
17569: PUSH
17570: LD_INT 40
17572: PUSH
17573: LD_INT 50
17575: PUSH
17576: LD_INT 60
17578: PUSH
17579: LD_INT 70
17581: PUSH
17582: LD_INT 80
17584: PUSH
17585: LD_INT 90
17587: PUSH
17588: LD_INT 100
17590: PUSH
17591: LD_INT 110
17593: PUSH
17594: LD_INT 120
17596: PUSH
17597: LD_INT 130
17599: PUSH
17600: LD_INT 140
17602: PUSH
17603: LD_INT 150
17605: PUSH
17606: EMPTY
17607: LIST
17608: LIST
17609: LIST
17610: LIST
17611: LIST
17612: LIST
17613: LIST
17614: LIST
17615: LIST
17616: LIST
17617: LIST
17618: LIST
17619: LIST
17620: LIST
17621: LIST
17622: PUSH
17623: LD_INT 1
17625: PPUSH
17626: LD_INT 15
17628: PPUSH
17629: CALL_OW 12
17633: ARRAY
17634: ST_TO_ADDR
// if ValidHex ( x , y ) then
17635: LD_VAR 0 3
17639: PPUSH
17640: LD_VAR 0 4
17644: PPUSH
17645: CALL_OW 488
17649: IFFALSE 17672
// begin result := [ x , y ] ;
17651: LD_ADDR_VAR 0 1
17655: PUSH
17656: LD_VAR 0 3
17660: PUSH
17661: LD_VAR 0 4
17665: PUSH
17666: EMPTY
17667: LIST
17668: LIST
17669: ST_TO_ADDR
// break ;
17670: GO 17674
// end ; end ;
17672: GO 17474
17674: POP
17675: POP
// if result then
17676: LD_VAR 0 1
17680: IFFALSE 17740
// begin ToLua ( playSibBomb() ) ;
17682: LD_STRING playSibBomb()
17684: PPUSH
17685: CALL_OW 559
// wait ( 0 0$14 ) ;
17689: LD_INT 490
17691: PPUSH
17692: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
17696: LD_VAR 0 1
17700: PUSH
17701: LD_INT 1
17703: ARRAY
17704: PPUSH
17705: LD_VAR 0 1
17709: PUSH
17710: LD_INT 2
17712: ARRAY
17713: PPUSH
17714: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
17718: LD_VAR 0 1
17722: PUSH
17723: LD_INT 1
17725: ARRAY
17726: PPUSH
17727: LD_VAR 0 1
17731: PUSH
17732: LD_INT 2
17734: ARRAY
17735: PPUSH
17736: CALL_OW 429
// end ; end ;
17740: LD_VAR 0 1
17744: RET
// every 0 0$1 trigger StreamModeActive and sReset do
17745: LD_EXP 30
17749: PUSH
17750: LD_EXP 52
17754: AND
17755: IFFALSE 17767
17757: GO 17759
17759: DISABLE
// YouLost (  ) ;
17760: LD_STRING 
17762: PPUSH
17763: CALL_OW 104
17767: END
// every 0 0$1 trigger StreamModeActive and sFog do
17768: LD_EXP 30
17772: PUSH
17773: LD_EXP 51
17777: AND
17778: IFFALSE 17792
17780: GO 17782
17782: DISABLE
// FogOff ( your_side ) ;
17783: LD_OWVAR 2
17787: PPUSH
17788: CALL_OW 344
17792: END
// every 0 0$1 trigger StreamModeActive and sSun do
17793: LD_EXP 30
17797: PUSH
17798: LD_EXP 53
17802: AND
17803: IFFALSE 17831
17805: GO 17807
17807: DISABLE
// begin solar_recharge_percent := 0 ;
17808: LD_ADDR_OWVAR 79
17812: PUSH
17813: LD_INT 0
17815: ST_TO_ADDR
// wait ( 5 5$00 ) ;
17816: LD_INT 10500
17818: PPUSH
17819: CALL_OW 67
// solar_recharge_percent := 100 ;
17823: LD_ADDR_OWVAR 79
17827: PUSH
17828: LD_INT 100
17830: ST_TO_ADDR
// end ;
17831: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
17832: LD_EXP 30
17836: PUSH
17837: LD_EXP 54
17841: AND
17842: IFFALSE 18081
17844: GO 17846
17846: DISABLE
17847: LD_INT 0
17849: PPUSH
17850: PPUSH
17851: PPUSH
// begin tmp := [ ] ;
17852: LD_ADDR_VAR 0 3
17856: PUSH
17857: EMPTY
17858: ST_TO_ADDR
// for i := 1 to 6 do
17859: LD_ADDR_VAR 0 1
17863: PUSH
17864: DOUBLE
17865: LD_INT 1
17867: DEC
17868: ST_TO_ADDR
17869: LD_INT 6
17871: PUSH
17872: FOR_TO
17873: IFFALSE 17978
// begin uc_nation := nation_nature ;
17875: LD_ADDR_OWVAR 21
17879: PUSH
17880: LD_INT 0
17882: ST_TO_ADDR
// uc_side := 0 ;
17883: LD_ADDR_OWVAR 20
17887: PUSH
17888: LD_INT 0
17890: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17891: LD_ADDR_OWVAR 29
17895: PUSH
17896: LD_INT 12
17898: PUSH
17899: LD_INT 12
17901: PUSH
17902: EMPTY
17903: LIST
17904: LIST
17905: ST_TO_ADDR
// hc_agressivity := 20 ;
17906: LD_ADDR_OWVAR 35
17910: PUSH
17911: LD_INT 20
17913: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
17914: LD_ADDR_OWVAR 28
17918: PUSH
17919: LD_INT 17
17921: ST_TO_ADDR
// hc_gallery :=  ;
17922: LD_ADDR_OWVAR 33
17926: PUSH
17927: LD_STRING 
17929: ST_TO_ADDR
// hc_name :=  ;
17930: LD_ADDR_OWVAR 26
17934: PUSH
17935: LD_STRING 
17937: ST_TO_ADDR
// un := CreateHuman ;
17938: LD_ADDR_VAR 0 2
17942: PUSH
17943: CALL_OW 44
17947: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
17948: LD_VAR 0 2
17952: PPUSH
17953: LD_INT 1
17955: PPUSH
17956: CALL_OW 51
// tmp := tmp ^ un ;
17960: LD_ADDR_VAR 0 3
17964: PUSH
17965: LD_VAR 0 3
17969: PUSH
17970: LD_VAR 0 2
17974: ADD
17975: ST_TO_ADDR
// end ;
17976: GO 17872
17978: POP
17979: POP
// repeat wait ( 0 0$1 ) ;
17980: LD_INT 35
17982: PPUSH
17983: CALL_OW 67
// for un in tmp do
17987: LD_ADDR_VAR 0 2
17991: PUSH
17992: LD_VAR 0 3
17996: PUSH
17997: FOR_IN
17998: IFFALSE 18072
// begin if IsDead ( un ) then
18000: LD_VAR 0 2
18004: PPUSH
18005: CALL_OW 301
18009: IFFALSE 18029
// begin tmp := tmp diff un ;
18011: LD_ADDR_VAR 0 3
18015: PUSH
18016: LD_VAR 0 3
18020: PUSH
18021: LD_VAR 0 2
18025: DIFF
18026: ST_TO_ADDR
// continue ;
18027: GO 17997
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
18029: LD_VAR 0 2
18033: PPUSH
18034: LD_INT 3
18036: PUSH
18037: LD_INT 22
18039: PUSH
18040: LD_INT 0
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: PUSH
18047: EMPTY
18048: LIST
18049: LIST
18050: PPUSH
18051: CALL_OW 69
18055: PPUSH
18056: LD_VAR 0 2
18060: PPUSH
18061: CALL_OW 74
18065: PPUSH
18066: CALL_OW 115
// end ;
18070: GO 17997
18072: POP
18073: POP
// until not tmp ;
18074: LD_VAR 0 3
18078: NOT
18079: IFFALSE 17980
// end ;
18081: PPOPN 3
18083: END
// every 0 0$1 trigger StreamModeActive and sTroll do
18084: LD_EXP 30
18088: PUSH
18089: LD_EXP 55
18093: AND
18094: IFFALSE 18148
18096: GO 18098
18098: DISABLE
// begin ToLua ( displayTroll(); ) ;
18099: LD_STRING displayTroll();
18101: PPUSH
18102: CALL_OW 559
// wait ( 3 3$00 ) ;
18106: LD_INT 6300
18108: PPUSH
18109: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18113: LD_STRING hideTroll();
18115: PPUSH
18116: CALL_OW 559
// wait ( 1 1$00 ) ;
18120: LD_INT 2100
18122: PPUSH
18123: CALL_OW 67
// ToLua ( displayTroll(); ) ;
18127: LD_STRING displayTroll();
18129: PPUSH
18130: CALL_OW 559
// wait ( 1 1$00 ) ;
18134: LD_INT 2100
18136: PPUSH
18137: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18141: LD_STRING hideTroll();
18143: PPUSH
18144: CALL_OW 559
// end ;
18148: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
18149: LD_EXP 30
18153: PUSH
18154: LD_EXP 56
18158: AND
18159: IFFALSE 18222
18161: GO 18163
18163: DISABLE
18164: LD_INT 0
18166: PPUSH
// begin p := 0 ;
18167: LD_ADDR_VAR 0 1
18171: PUSH
18172: LD_INT 0
18174: ST_TO_ADDR
// repeat game_speed := 1 ;
18175: LD_ADDR_OWVAR 65
18179: PUSH
18180: LD_INT 1
18182: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18183: LD_INT 35
18185: PPUSH
18186: CALL_OW 67
// p := p + 1 ;
18190: LD_ADDR_VAR 0 1
18194: PUSH
18195: LD_VAR 0 1
18199: PUSH
18200: LD_INT 1
18202: PLUS
18203: ST_TO_ADDR
// until p >= 60 ;
18204: LD_VAR 0 1
18208: PUSH
18209: LD_INT 60
18211: GREATEREQUAL
18212: IFFALSE 18175
// game_speed := 4 ;
18214: LD_ADDR_OWVAR 65
18218: PUSH
18219: LD_INT 4
18221: ST_TO_ADDR
// end ;
18222: PPOPN 1
18224: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
18225: LD_EXP 30
18229: PUSH
18230: LD_EXP 57
18234: AND
18235: IFFALSE 18381
18237: GO 18239
18239: DISABLE
18240: LD_INT 0
18242: PPUSH
18243: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
18244: LD_ADDR_VAR 0 1
18248: PUSH
18249: LD_INT 22
18251: PUSH
18252: LD_OWVAR 2
18256: PUSH
18257: EMPTY
18258: LIST
18259: LIST
18260: PUSH
18261: LD_INT 2
18263: PUSH
18264: LD_INT 30
18266: PUSH
18267: LD_INT 0
18269: PUSH
18270: EMPTY
18271: LIST
18272: LIST
18273: PUSH
18274: LD_INT 30
18276: PUSH
18277: LD_INT 1
18279: PUSH
18280: EMPTY
18281: LIST
18282: LIST
18283: PUSH
18284: EMPTY
18285: LIST
18286: LIST
18287: LIST
18288: PUSH
18289: EMPTY
18290: LIST
18291: LIST
18292: PPUSH
18293: CALL_OW 69
18297: ST_TO_ADDR
// if not depot then
18298: LD_VAR 0 1
18302: NOT
18303: IFFALSE 18307
// exit ;
18305: GO 18381
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
18307: LD_ADDR_VAR 0 2
18311: PUSH
18312: LD_VAR 0 1
18316: PUSH
18317: LD_INT 1
18319: PPUSH
18320: LD_VAR 0 1
18324: PPUSH
18325: CALL_OW 12
18329: ARRAY
18330: PPUSH
18331: CALL_OW 274
18335: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
18336: LD_VAR 0 2
18340: PPUSH
18341: LD_INT 1
18343: PPUSH
18344: LD_INT 0
18346: PPUSH
18347: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
18351: LD_VAR 0 2
18355: PPUSH
18356: LD_INT 2
18358: PPUSH
18359: LD_INT 0
18361: PPUSH
18362: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
18366: LD_VAR 0 2
18370: PPUSH
18371: LD_INT 3
18373: PPUSH
18374: LD_INT 0
18376: PPUSH
18377: CALL_OW 277
// end ;
18381: PPOPN 2
18383: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
18384: LD_EXP 30
18388: PUSH
18389: LD_EXP 58
18393: AND
18394: IFFALSE 18491
18396: GO 18398
18398: DISABLE
18399: LD_INT 0
18401: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18402: LD_ADDR_VAR 0 1
18406: PUSH
18407: LD_INT 22
18409: PUSH
18410: LD_OWVAR 2
18414: PUSH
18415: EMPTY
18416: LIST
18417: LIST
18418: PUSH
18419: LD_INT 21
18421: PUSH
18422: LD_INT 1
18424: PUSH
18425: EMPTY
18426: LIST
18427: LIST
18428: PUSH
18429: LD_INT 3
18431: PUSH
18432: LD_INT 23
18434: PUSH
18435: LD_INT 0
18437: PUSH
18438: EMPTY
18439: LIST
18440: LIST
18441: PUSH
18442: EMPTY
18443: LIST
18444: LIST
18445: PUSH
18446: EMPTY
18447: LIST
18448: LIST
18449: LIST
18450: PPUSH
18451: CALL_OW 69
18455: ST_TO_ADDR
// if not tmp then
18456: LD_VAR 0 1
18460: NOT
18461: IFFALSE 18465
// exit ;
18463: GO 18491
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
18465: LD_VAR 0 1
18469: PUSH
18470: LD_INT 1
18472: PPUSH
18473: LD_VAR 0 1
18477: PPUSH
18478: CALL_OW 12
18482: ARRAY
18483: PPUSH
18484: LD_INT 200
18486: PPUSH
18487: CALL_OW 234
// end ;
18491: PPOPN 1
18493: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
18494: LD_EXP 30
18498: PUSH
18499: LD_EXP 59
18503: AND
18504: IFFALSE 18583
18506: GO 18508
18508: DISABLE
18509: LD_INT 0
18511: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
18512: LD_ADDR_VAR 0 1
18516: PUSH
18517: LD_INT 22
18519: PUSH
18520: LD_OWVAR 2
18524: PUSH
18525: EMPTY
18526: LIST
18527: LIST
18528: PUSH
18529: LD_INT 21
18531: PUSH
18532: LD_INT 2
18534: PUSH
18535: EMPTY
18536: LIST
18537: LIST
18538: PUSH
18539: EMPTY
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL_OW 69
18547: ST_TO_ADDR
// if not tmp then
18548: LD_VAR 0 1
18552: NOT
18553: IFFALSE 18557
// exit ;
18555: GO 18583
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
18557: LD_VAR 0 1
18561: PUSH
18562: LD_INT 1
18564: PPUSH
18565: LD_VAR 0 1
18569: PPUSH
18570: CALL_OW 12
18574: ARRAY
18575: PPUSH
18576: LD_INT 60
18578: PPUSH
18579: CALL_OW 234
// end ;
18583: PPOPN 1
18585: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
18586: LD_EXP 30
18590: PUSH
18591: LD_EXP 60
18595: AND
18596: IFFALSE 18695
18598: GO 18600
18600: DISABLE
18601: LD_INT 0
18603: PPUSH
18604: PPUSH
// begin enable ;
18605: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
18606: LD_ADDR_VAR 0 1
18610: PUSH
18611: LD_INT 22
18613: PUSH
18614: LD_OWVAR 2
18618: PUSH
18619: EMPTY
18620: LIST
18621: LIST
18622: PUSH
18623: LD_INT 61
18625: PUSH
18626: EMPTY
18627: LIST
18628: PUSH
18629: LD_INT 33
18631: PUSH
18632: LD_INT 2
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: PUSH
18639: EMPTY
18640: LIST
18641: LIST
18642: LIST
18643: PPUSH
18644: CALL_OW 69
18648: ST_TO_ADDR
// if not tmp then
18649: LD_VAR 0 1
18653: NOT
18654: IFFALSE 18658
// exit ;
18656: GO 18695
// for i in tmp do
18658: LD_ADDR_VAR 0 2
18662: PUSH
18663: LD_VAR 0 1
18667: PUSH
18668: FOR_IN
18669: IFFALSE 18693
// if IsControledBy ( i ) then
18671: LD_VAR 0 2
18675: PPUSH
18676: CALL_OW 312
18680: IFFALSE 18691
// ComUnlink ( i ) ;
18682: LD_VAR 0 2
18686: PPUSH
18687: CALL_OW 136
18691: GO 18668
18693: POP
18694: POP
// end ;
18695: PPOPN 2
18697: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
18698: LD_EXP 30
18702: PUSH
18703: LD_EXP 61
18707: AND
18708: IFFALSE 18842
18710: GO 18712
18712: DISABLE
18713: LD_INT 0
18715: PPUSH
18716: PPUSH
// begin ToLua ( displayPowell(); ) ;
18717: LD_STRING displayPowell();
18719: PPUSH
18720: CALL_OW 559
// uc_side := 0 ;
18724: LD_ADDR_OWVAR 20
18728: PUSH
18729: LD_INT 0
18731: ST_TO_ADDR
// uc_nation := 2 ;
18732: LD_ADDR_OWVAR 21
18736: PUSH
18737: LD_INT 2
18739: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
18740: LD_ADDR_OWVAR 37
18744: PUSH
18745: LD_INT 14
18747: ST_TO_ADDR
// vc_engine := engine_siberite ;
18748: LD_ADDR_OWVAR 39
18752: PUSH
18753: LD_INT 3
18755: ST_TO_ADDR
// vc_control := control_apeman ;
18756: LD_ADDR_OWVAR 38
18760: PUSH
18761: LD_INT 5
18763: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
18764: LD_ADDR_OWVAR 40
18768: PUSH
18769: LD_INT 29
18771: ST_TO_ADDR
// un := CreateVehicle ;
18772: LD_ADDR_VAR 0 2
18776: PUSH
18777: CALL_OW 45
18781: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18782: LD_VAR 0 2
18786: PPUSH
18787: LD_INT 1
18789: PPUSH
18790: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
18794: LD_INT 35
18796: PPUSH
18797: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
18801: LD_VAR 0 2
18805: PPUSH
18806: LD_OWVAR 3
18810: PUSH
18811: LD_VAR 0 2
18815: DIFF
18816: PPUSH
18817: LD_VAR 0 2
18821: PPUSH
18822: CALL_OW 74
18826: PPUSH
18827: CALL_OW 115
// until IsOk ( un ) ;
18831: LD_VAR 0 2
18835: PPUSH
18836: CALL_OW 302
18840: IFFALSE 18794
// end ;
18842: PPOPN 2
18844: END
// every 0 0$1 trigger StreamModeActive and sStu do
18845: LD_EXP 30
18849: PUSH
18850: LD_EXP 69
18854: AND
18855: IFFALSE 18867
18857: GO 18859
18859: DISABLE
// begin ToLua ( displayStucuk(); ) ;
18860: LD_STRING displayStucuk();
18862: PPUSH
18863: CALL_OW 559
// end ;
18867: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
18868: LD_EXP 30
18872: PUSH
18873: LD_EXP 62
18877: AND
18878: IFFALSE 19019
18880: GO 18882
18882: DISABLE
18883: LD_INT 0
18885: PPUSH
18886: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
18887: LD_ADDR_VAR 0 2
18891: PUSH
18892: LD_INT 22
18894: PUSH
18895: LD_OWVAR 2
18899: PUSH
18900: EMPTY
18901: LIST
18902: LIST
18903: PUSH
18904: LD_INT 21
18906: PUSH
18907: LD_INT 1
18909: PUSH
18910: EMPTY
18911: LIST
18912: LIST
18913: PUSH
18914: EMPTY
18915: LIST
18916: LIST
18917: PPUSH
18918: CALL_OW 69
18922: ST_TO_ADDR
// if not tmp then
18923: LD_VAR 0 2
18927: NOT
18928: IFFALSE 18932
// exit ;
18930: GO 19019
// un := tmp [ rand ( 1 , tmp ) ] ;
18932: LD_ADDR_VAR 0 1
18936: PUSH
18937: LD_VAR 0 2
18941: PUSH
18942: LD_INT 1
18944: PPUSH
18945: LD_VAR 0 2
18949: PPUSH
18950: CALL_OW 12
18954: ARRAY
18955: ST_TO_ADDR
// SetSide ( un , 0 ) ;
18956: LD_VAR 0 1
18960: PPUSH
18961: LD_INT 0
18963: PPUSH
18964: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
18968: LD_VAR 0 1
18972: PPUSH
18973: LD_OWVAR 3
18977: PUSH
18978: LD_VAR 0 1
18982: DIFF
18983: PPUSH
18984: LD_VAR 0 1
18988: PPUSH
18989: CALL_OW 74
18993: PPUSH
18994: CALL_OW 115
// wait ( 0 0$20 ) ;
18998: LD_INT 700
19000: PPUSH
19001: CALL_OW 67
// SetSide ( un , your_side ) ;
19005: LD_VAR 0 1
19009: PPUSH
19010: LD_OWVAR 2
19014: PPUSH
19015: CALL_OW 235
// end ;
19019: PPOPN 2
19021: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
19022: LD_EXP 30
19026: PUSH
19027: LD_EXP 63
19031: AND
19032: IFFALSE 19138
19034: GO 19036
19036: DISABLE
19037: LD_INT 0
19039: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19040: LD_ADDR_VAR 0 1
19044: PUSH
19045: LD_INT 22
19047: PUSH
19048: LD_OWVAR 2
19052: PUSH
19053: EMPTY
19054: LIST
19055: LIST
19056: PUSH
19057: LD_INT 2
19059: PUSH
19060: LD_INT 30
19062: PUSH
19063: LD_INT 0
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: PUSH
19070: LD_INT 30
19072: PUSH
19073: LD_INT 1
19075: PUSH
19076: EMPTY
19077: LIST
19078: LIST
19079: PUSH
19080: EMPTY
19081: LIST
19082: LIST
19083: LIST
19084: PUSH
19085: EMPTY
19086: LIST
19087: LIST
19088: PPUSH
19089: CALL_OW 69
19093: ST_TO_ADDR
// if not depot then
19094: LD_VAR 0 1
19098: NOT
19099: IFFALSE 19103
// exit ;
19101: GO 19138
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
19103: LD_VAR 0 1
19107: PUSH
19108: LD_INT 1
19110: ARRAY
19111: PPUSH
19112: CALL_OW 250
19116: PPUSH
19117: LD_VAR 0 1
19121: PUSH
19122: LD_INT 1
19124: ARRAY
19125: PPUSH
19126: CALL_OW 251
19130: PPUSH
19131: LD_INT 70
19133: PPUSH
19134: CALL_OW 495
// end ;
19138: PPOPN 1
19140: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
19141: LD_EXP 30
19145: PUSH
19146: LD_EXP 64
19150: AND
19151: IFFALSE 19362
19153: GO 19155
19155: DISABLE
19156: LD_INT 0
19158: PPUSH
19159: PPUSH
19160: PPUSH
19161: PPUSH
19162: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19163: LD_ADDR_VAR 0 5
19167: PUSH
19168: LD_INT 22
19170: PUSH
19171: LD_OWVAR 2
19175: PUSH
19176: EMPTY
19177: LIST
19178: LIST
19179: PUSH
19180: LD_INT 21
19182: PUSH
19183: LD_INT 1
19185: PUSH
19186: EMPTY
19187: LIST
19188: LIST
19189: PUSH
19190: EMPTY
19191: LIST
19192: LIST
19193: PPUSH
19194: CALL_OW 69
19198: ST_TO_ADDR
// if not tmp then
19199: LD_VAR 0 5
19203: NOT
19204: IFFALSE 19208
// exit ;
19206: GO 19362
// for i in tmp do
19208: LD_ADDR_VAR 0 1
19212: PUSH
19213: LD_VAR 0 5
19217: PUSH
19218: FOR_IN
19219: IFFALSE 19360
// begin d := rand ( 0 , 5 ) ;
19221: LD_ADDR_VAR 0 4
19225: PUSH
19226: LD_INT 0
19228: PPUSH
19229: LD_INT 5
19231: PPUSH
19232: CALL_OW 12
19236: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
19237: LD_ADDR_VAR 0 2
19241: PUSH
19242: LD_VAR 0 1
19246: PPUSH
19247: CALL_OW 250
19251: PPUSH
19252: LD_VAR 0 4
19256: PPUSH
19257: LD_INT 3
19259: PPUSH
19260: LD_INT 12
19262: PPUSH
19263: CALL_OW 12
19267: PPUSH
19268: CALL_OW 272
19272: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
19273: LD_ADDR_VAR 0 3
19277: PUSH
19278: LD_VAR 0 1
19282: PPUSH
19283: CALL_OW 251
19287: PPUSH
19288: LD_VAR 0 4
19292: PPUSH
19293: LD_INT 3
19295: PPUSH
19296: LD_INT 12
19298: PPUSH
19299: CALL_OW 12
19303: PPUSH
19304: CALL_OW 273
19308: ST_TO_ADDR
// if ValidHex ( x , y ) then
19309: LD_VAR 0 2
19313: PPUSH
19314: LD_VAR 0 3
19318: PPUSH
19319: CALL_OW 488
19323: IFFALSE 19358
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
19325: LD_VAR 0 1
19329: PPUSH
19330: LD_VAR 0 2
19334: PPUSH
19335: LD_VAR 0 3
19339: PPUSH
19340: LD_INT 3
19342: PPUSH
19343: LD_INT 6
19345: PPUSH
19346: CALL_OW 12
19350: PPUSH
19351: LD_INT 1
19353: PPUSH
19354: CALL_OW 483
// end ;
19358: GO 19218
19360: POP
19361: POP
// end ;
19362: PPOPN 5
19364: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
19365: LD_EXP 30
19369: PUSH
19370: LD_EXP 65
19374: AND
19375: IFFALSE 19469
19377: GO 19379
19379: DISABLE
19380: LD_INT 0
19382: PPUSH
19383: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
19384: LD_ADDR_VAR 0 2
19388: PUSH
19389: LD_INT 22
19391: PUSH
19392: LD_OWVAR 2
19396: PUSH
19397: EMPTY
19398: LIST
19399: LIST
19400: PUSH
19401: LD_INT 32
19403: PUSH
19404: LD_INT 1
19406: PUSH
19407: EMPTY
19408: LIST
19409: LIST
19410: PUSH
19411: LD_INT 21
19413: PUSH
19414: LD_INT 2
19416: PUSH
19417: EMPTY
19418: LIST
19419: LIST
19420: PUSH
19421: EMPTY
19422: LIST
19423: LIST
19424: LIST
19425: PPUSH
19426: CALL_OW 69
19430: ST_TO_ADDR
// if not tmp then
19431: LD_VAR 0 2
19435: NOT
19436: IFFALSE 19440
// exit ;
19438: GO 19469
// for i in tmp do
19440: LD_ADDR_VAR 0 1
19444: PUSH
19445: LD_VAR 0 2
19449: PUSH
19450: FOR_IN
19451: IFFALSE 19467
// SetFuel ( i , 0 ) ;
19453: LD_VAR 0 1
19457: PPUSH
19458: LD_INT 0
19460: PPUSH
19461: CALL_OW 240
19465: GO 19450
19467: POP
19468: POP
// end ;
19469: PPOPN 2
19471: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
19472: LD_EXP 30
19476: PUSH
19477: LD_EXP 66
19481: AND
19482: IFFALSE 19548
19484: GO 19486
19486: DISABLE
19487: LD_INT 0
19489: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
19490: LD_ADDR_VAR 0 1
19494: PUSH
19495: LD_INT 22
19497: PUSH
19498: LD_OWVAR 2
19502: PUSH
19503: EMPTY
19504: LIST
19505: LIST
19506: PUSH
19507: LD_INT 30
19509: PUSH
19510: LD_INT 29
19512: PUSH
19513: EMPTY
19514: LIST
19515: LIST
19516: PUSH
19517: EMPTY
19518: LIST
19519: LIST
19520: PPUSH
19521: CALL_OW 69
19525: ST_TO_ADDR
// if not tmp then
19526: LD_VAR 0 1
19530: NOT
19531: IFFALSE 19535
// exit ;
19533: GO 19548
// DestroyUnit ( tmp [ 1 ] ) ;
19535: LD_VAR 0 1
19539: PUSH
19540: LD_INT 1
19542: ARRAY
19543: PPUSH
19544: CALL_OW 65
// end ;
19548: PPOPN 1
19550: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
19551: LD_EXP 30
19555: PUSH
19556: LD_EXP 68
19560: AND
19561: IFFALSE 19690
19563: GO 19565
19565: DISABLE
19566: LD_INT 0
19568: PPUSH
// begin uc_side := 0 ;
19569: LD_ADDR_OWVAR 20
19573: PUSH
19574: LD_INT 0
19576: ST_TO_ADDR
// uc_nation := nation_arabian ;
19577: LD_ADDR_OWVAR 21
19581: PUSH
19582: LD_INT 2
19584: ST_TO_ADDR
// hc_gallery :=  ;
19585: LD_ADDR_OWVAR 33
19589: PUSH
19590: LD_STRING 
19592: ST_TO_ADDR
// hc_name :=  ;
19593: LD_ADDR_OWVAR 26
19597: PUSH
19598: LD_STRING 
19600: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
19601: LD_INT 1
19603: PPUSH
19604: LD_INT 11
19606: PPUSH
19607: LD_INT 10
19609: PPUSH
19610: CALL_OW 380
// un := CreateHuman ;
19614: LD_ADDR_VAR 0 1
19618: PUSH
19619: CALL_OW 44
19623: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19624: LD_VAR 0 1
19628: PPUSH
19629: LD_INT 1
19631: PPUSH
19632: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
19636: LD_INT 35
19638: PPUSH
19639: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
19643: LD_VAR 0 1
19647: PPUSH
19648: LD_INT 22
19650: PUSH
19651: LD_OWVAR 2
19655: PUSH
19656: EMPTY
19657: LIST
19658: LIST
19659: PPUSH
19660: CALL_OW 69
19664: PPUSH
19665: LD_VAR 0 1
19669: PPUSH
19670: CALL_OW 74
19674: PPUSH
19675: CALL_OW 115
// until IsDead ( un ) ;
19679: LD_VAR 0 1
19683: PPUSH
19684: CALL_OW 301
19688: IFFALSE 19636
// end ;
19690: PPOPN 1
19692: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
19693: LD_EXP 30
19697: PUSH
19698: LD_EXP 70
19702: AND
19703: IFFALSE 19715
19705: GO 19707
19707: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
19708: LD_STRING earthquake(getX(game), 0, 32)
19710: PPUSH
19711: CALL_OW 559
19715: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
19716: LD_EXP 30
19720: PUSH
19721: LD_EXP 71
19725: AND
19726: IFFALSE 19817
19728: GO 19730
19730: DISABLE
19731: LD_INT 0
19733: PPUSH
// begin enable ;
19734: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
19735: LD_ADDR_VAR 0 1
19739: PUSH
19740: LD_INT 22
19742: PUSH
19743: LD_OWVAR 2
19747: PUSH
19748: EMPTY
19749: LIST
19750: LIST
19751: PUSH
19752: LD_INT 21
19754: PUSH
19755: LD_INT 2
19757: PUSH
19758: EMPTY
19759: LIST
19760: LIST
19761: PUSH
19762: LD_INT 33
19764: PUSH
19765: LD_INT 3
19767: PUSH
19768: EMPTY
19769: LIST
19770: LIST
19771: PUSH
19772: EMPTY
19773: LIST
19774: LIST
19775: LIST
19776: PPUSH
19777: CALL_OW 69
19781: ST_TO_ADDR
// if not tmp then
19782: LD_VAR 0 1
19786: NOT
19787: IFFALSE 19791
// exit ;
19789: GO 19817
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
19791: LD_VAR 0 1
19795: PUSH
19796: LD_INT 1
19798: PPUSH
19799: LD_VAR 0 1
19803: PPUSH
19804: CALL_OW 12
19808: ARRAY
19809: PPUSH
19810: LD_INT 1
19812: PPUSH
19813: CALL_OW 234
// end ;
19817: PPOPN 1
19819: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
19820: LD_EXP 30
19824: PUSH
19825: LD_EXP 72
19829: AND
19830: IFFALSE 19971
19832: GO 19834
19834: DISABLE
19835: LD_INT 0
19837: PPUSH
19838: PPUSH
19839: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
19840: LD_ADDR_VAR 0 3
19844: PUSH
19845: LD_INT 22
19847: PUSH
19848: LD_OWVAR 2
19852: PUSH
19853: EMPTY
19854: LIST
19855: LIST
19856: PUSH
19857: LD_INT 25
19859: PUSH
19860: LD_INT 1
19862: PUSH
19863: EMPTY
19864: LIST
19865: LIST
19866: PUSH
19867: EMPTY
19868: LIST
19869: LIST
19870: PPUSH
19871: CALL_OW 69
19875: ST_TO_ADDR
// if not tmp then
19876: LD_VAR 0 3
19880: NOT
19881: IFFALSE 19885
// exit ;
19883: GO 19971
// un := tmp [ rand ( 1 , tmp ) ] ;
19885: LD_ADDR_VAR 0 2
19889: PUSH
19890: LD_VAR 0 3
19894: PUSH
19895: LD_INT 1
19897: PPUSH
19898: LD_VAR 0 3
19902: PPUSH
19903: CALL_OW 12
19907: ARRAY
19908: ST_TO_ADDR
// if Crawls ( un ) then
19909: LD_VAR 0 2
19913: PPUSH
19914: CALL_OW 318
19918: IFFALSE 19929
// ComWalk ( un ) ;
19920: LD_VAR 0 2
19924: PPUSH
19925: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
19929: LD_VAR 0 2
19933: PPUSH
19934: LD_INT 9
19936: PPUSH
19937: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
19941: LD_INT 28
19943: PPUSH
19944: LD_OWVAR 2
19948: PPUSH
19949: LD_INT 2
19951: PPUSH
19952: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
19956: LD_INT 29
19958: PPUSH
19959: LD_OWVAR 2
19963: PPUSH
19964: LD_INT 2
19966: PPUSH
19967: CALL_OW 322
// end ;
19971: PPOPN 3
19973: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
19974: LD_EXP 30
19978: PUSH
19979: LD_EXP 73
19983: AND
19984: IFFALSE 20095
19986: GO 19988
19988: DISABLE
19989: LD_INT 0
19991: PPUSH
19992: PPUSH
19993: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
19994: LD_ADDR_VAR 0 3
19998: PUSH
19999: LD_INT 22
20001: PUSH
20002: LD_OWVAR 2
20006: PUSH
20007: EMPTY
20008: LIST
20009: LIST
20010: PUSH
20011: LD_INT 25
20013: PUSH
20014: LD_INT 1
20016: PUSH
20017: EMPTY
20018: LIST
20019: LIST
20020: PUSH
20021: EMPTY
20022: LIST
20023: LIST
20024: PPUSH
20025: CALL_OW 69
20029: ST_TO_ADDR
// if not tmp then
20030: LD_VAR 0 3
20034: NOT
20035: IFFALSE 20039
// exit ;
20037: GO 20095
// un := tmp [ rand ( 1 , tmp ) ] ;
20039: LD_ADDR_VAR 0 2
20043: PUSH
20044: LD_VAR 0 3
20048: PUSH
20049: LD_INT 1
20051: PPUSH
20052: LD_VAR 0 3
20056: PPUSH
20057: CALL_OW 12
20061: ARRAY
20062: ST_TO_ADDR
// if Crawls ( un ) then
20063: LD_VAR 0 2
20067: PPUSH
20068: CALL_OW 318
20072: IFFALSE 20083
// ComWalk ( un ) ;
20074: LD_VAR 0 2
20078: PPUSH
20079: CALL_OW 138
// SetClass ( un , class_mortar ) ;
20083: LD_VAR 0 2
20087: PPUSH
20088: LD_INT 8
20090: PPUSH
20091: CALL_OW 336
// end ;
20095: PPOPN 3
20097: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
20098: LD_EXP 30
20102: PUSH
20103: LD_EXP 74
20107: AND
20108: IFFALSE 20252
20110: GO 20112
20112: DISABLE
20113: LD_INT 0
20115: PPUSH
20116: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
20117: LD_ADDR_VAR 0 2
20121: PUSH
20122: LD_INT 22
20124: PUSH
20125: LD_OWVAR 2
20129: PUSH
20130: EMPTY
20131: LIST
20132: LIST
20133: PUSH
20134: LD_INT 21
20136: PUSH
20137: LD_INT 2
20139: PUSH
20140: EMPTY
20141: LIST
20142: LIST
20143: PUSH
20144: LD_INT 2
20146: PUSH
20147: LD_INT 34
20149: PUSH
20150: LD_INT 12
20152: PUSH
20153: EMPTY
20154: LIST
20155: LIST
20156: PUSH
20157: LD_INT 34
20159: PUSH
20160: LD_INT 51
20162: PUSH
20163: EMPTY
20164: LIST
20165: LIST
20166: PUSH
20167: LD_INT 34
20169: PUSH
20170: LD_INT 32
20172: PUSH
20173: EMPTY
20174: LIST
20175: LIST
20176: PUSH
20177: EMPTY
20178: LIST
20179: LIST
20180: LIST
20181: LIST
20182: PUSH
20183: EMPTY
20184: LIST
20185: LIST
20186: LIST
20187: PPUSH
20188: CALL_OW 69
20192: ST_TO_ADDR
// if not tmp then
20193: LD_VAR 0 2
20197: NOT
20198: IFFALSE 20202
// exit ;
20200: GO 20252
// for i in tmp do
20202: LD_ADDR_VAR 0 1
20206: PUSH
20207: LD_VAR 0 2
20211: PUSH
20212: FOR_IN
20213: IFFALSE 20250
// if GetCargo ( i , mat_artifact ) = 0 then
20215: LD_VAR 0 1
20219: PPUSH
20220: LD_INT 4
20222: PPUSH
20223: CALL_OW 289
20227: PUSH
20228: LD_INT 0
20230: EQUAL
20231: IFFALSE 20248
// SetCargo ( i , mat_siberit , 100 ) ;
20233: LD_VAR 0 1
20237: PPUSH
20238: LD_INT 3
20240: PPUSH
20241: LD_INT 100
20243: PPUSH
20244: CALL_OW 290
20248: GO 20212
20250: POP
20251: POP
// end ;
20252: PPOPN 2
20254: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
20255: LD_EXP 30
20259: PUSH
20260: LD_EXP 75
20264: AND
20265: IFFALSE 20418
20267: GO 20269
20269: DISABLE
20270: LD_INT 0
20272: PPUSH
20273: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
20274: LD_ADDR_VAR 0 2
20278: PUSH
20279: LD_INT 22
20281: PUSH
20282: LD_OWVAR 2
20286: PUSH
20287: EMPTY
20288: LIST
20289: LIST
20290: PPUSH
20291: CALL_OW 69
20295: ST_TO_ADDR
// if not tmp then
20296: LD_VAR 0 2
20300: NOT
20301: IFFALSE 20305
// exit ;
20303: GO 20418
// for i := 1 to 2 do
20305: LD_ADDR_VAR 0 1
20309: PUSH
20310: DOUBLE
20311: LD_INT 1
20313: DEC
20314: ST_TO_ADDR
20315: LD_INT 2
20317: PUSH
20318: FOR_TO
20319: IFFALSE 20416
// begin uc_side := your_side ;
20321: LD_ADDR_OWVAR 20
20325: PUSH
20326: LD_OWVAR 2
20330: ST_TO_ADDR
// uc_nation := nation_american ;
20331: LD_ADDR_OWVAR 21
20335: PUSH
20336: LD_INT 1
20338: ST_TO_ADDR
// vc_chassis := us_morphling ;
20339: LD_ADDR_OWVAR 37
20343: PUSH
20344: LD_INT 5
20346: ST_TO_ADDR
// vc_engine := engine_siberite ;
20347: LD_ADDR_OWVAR 39
20351: PUSH
20352: LD_INT 3
20354: ST_TO_ADDR
// vc_control := control_computer ;
20355: LD_ADDR_OWVAR 38
20359: PUSH
20360: LD_INT 3
20362: ST_TO_ADDR
// vc_weapon := us_double_laser ;
20363: LD_ADDR_OWVAR 40
20367: PUSH
20368: LD_INT 10
20370: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
20371: CALL_OW 45
20375: PPUSH
20376: LD_VAR 0 2
20380: PUSH
20381: LD_INT 1
20383: ARRAY
20384: PPUSH
20385: CALL_OW 250
20389: PPUSH
20390: LD_VAR 0 2
20394: PUSH
20395: LD_INT 1
20397: ARRAY
20398: PPUSH
20399: CALL_OW 251
20403: PPUSH
20404: LD_INT 12
20406: PPUSH
20407: LD_INT 1
20409: PPUSH
20410: CALL_OW 50
// end ;
20414: GO 20318
20416: POP
20417: POP
// end ;
20418: PPOPN 2
20420: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
20421: LD_EXP 30
20425: PUSH
20426: LD_EXP 76
20430: AND
20431: IFFALSE 20653
20433: GO 20435
20435: DISABLE
20436: LD_INT 0
20438: PPUSH
20439: PPUSH
20440: PPUSH
20441: PPUSH
20442: PPUSH
20443: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
20444: LD_ADDR_VAR 0 6
20448: PUSH
20449: LD_INT 22
20451: PUSH
20452: LD_OWVAR 2
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: PUSH
20461: LD_INT 21
20463: PUSH
20464: LD_INT 1
20466: PUSH
20467: EMPTY
20468: LIST
20469: LIST
20470: PUSH
20471: LD_INT 3
20473: PUSH
20474: LD_INT 23
20476: PUSH
20477: LD_INT 0
20479: PUSH
20480: EMPTY
20481: LIST
20482: LIST
20483: PUSH
20484: EMPTY
20485: LIST
20486: LIST
20487: PUSH
20488: EMPTY
20489: LIST
20490: LIST
20491: LIST
20492: PPUSH
20493: CALL_OW 69
20497: ST_TO_ADDR
// if not tmp then
20498: LD_VAR 0 6
20502: NOT
20503: IFFALSE 20507
// exit ;
20505: GO 20653
// s1 := rand ( 1 , 4 ) ;
20507: LD_ADDR_VAR 0 2
20511: PUSH
20512: LD_INT 1
20514: PPUSH
20515: LD_INT 4
20517: PPUSH
20518: CALL_OW 12
20522: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
20523: LD_ADDR_VAR 0 4
20527: PUSH
20528: LD_VAR 0 6
20532: PUSH
20533: LD_INT 1
20535: ARRAY
20536: PPUSH
20537: LD_VAR 0 2
20541: PPUSH
20542: CALL_OW 259
20546: ST_TO_ADDR
// if s1 = 1 then
20547: LD_VAR 0 2
20551: PUSH
20552: LD_INT 1
20554: EQUAL
20555: IFFALSE 20575
// s2 := rand ( 2 , 4 ) else
20557: LD_ADDR_VAR 0 3
20561: PUSH
20562: LD_INT 2
20564: PPUSH
20565: LD_INT 4
20567: PPUSH
20568: CALL_OW 12
20572: ST_TO_ADDR
20573: GO 20583
// s2 := 1 ;
20575: LD_ADDR_VAR 0 3
20579: PUSH
20580: LD_INT 1
20582: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
20583: LD_ADDR_VAR 0 5
20587: PUSH
20588: LD_VAR 0 6
20592: PUSH
20593: LD_INT 1
20595: ARRAY
20596: PPUSH
20597: LD_VAR 0 3
20601: PPUSH
20602: CALL_OW 259
20606: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
20607: LD_VAR 0 6
20611: PUSH
20612: LD_INT 1
20614: ARRAY
20615: PPUSH
20616: LD_VAR 0 2
20620: PPUSH
20621: LD_VAR 0 5
20625: PPUSH
20626: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
20630: LD_VAR 0 6
20634: PUSH
20635: LD_INT 1
20637: ARRAY
20638: PPUSH
20639: LD_VAR 0 3
20643: PPUSH
20644: LD_VAR 0 4
20648: PPUSH
20649: CALL_OW 237
// end ;
20653: PPOPN 6
20655: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
20656: LD_EXP 30
20660: PUSH
20661: LD_EXP 77
20665: AND
20666: IFFALSE 20745
20668: GO 20670
20670: DISABLE
20671: LD_INT 0
20673: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
20674: LD_ADDR_VAR 0 1
20678: PUSH
20679: LD_INT 22
20681: PUSH
20682: LD_OWVAR 2
20686: PUSH
20687: EMPTY
20688: LIST
20689: LIST
20690: PUSH
20691: LD_INT 30
20693: PUSH
20694: LD_INT 3
20696: PUSH
20697: EMPTY
20698: LIST
20699: LIST
20700: PUSH
20701: EMPTY
20702: LIST
20703: LIST
20704: PPUSH
20705: CALL_OW 69
20709: ST_TO_ADDR
// if not tmp then
20710: LD_VAR 0 1
20714: NOT
20715: IFFALSE 20719
// exit ;
20717: GO 20745
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
20719: LD_VAR 0 1
20723: PUSH
20724: LD_INT 1
20726: PPUSH
20727: LD_VAR 0 1
20731: PPUSH
20732: CALL_OW 12
20736: ARRAY
20737: PPUSH
20738: LD_INT 1
20740: PPUSH
20741: CALL_OW 234
// end ;
20745: PPOPN 1
20747: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
20748: LD_EXP 30
20752: PUSH
20753: LD_EXP 78
20757: AND
20758: IFFALSE 20870
20760: GO 20762
20762: DISABLE
20763: LD_INT 0
20765: PPUSH
20766: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
20767: LD_ADDR_VAR 0 2
20771: PUSH
20772: LD_INT 22
20774: PUSH
20775: LD_OWVAR 2
20779: PUSH
20780: EMPTY
20781: LIST
20782: LIST
20783: PUSH
20784: LD_INT 2
20786: PUSH
20787: LD_INT 30
20789: PUSH
20790: LD_INT 27
20792: PUSH
20793: EMPTY
20794: LIST
20795: LIST
20796: PUSH
20797: LD_INT 30
20799: PUSH
20800: LD_INT 26
20802: PUSH
20803: EMPTY
20804: LIST
20805: LIST
20806: PUSH
20807: LD_INT 30
20809: PUSH
20810: LD_INT 28
20812: PUSH
20813: EMPTY
20814: LIST
20815: LIST
20816: PUSH
20817: EMPTY
20818: LIST
20819: LIST
20820: LIST
20821: LIST
20822: PUSH
20823: EMPTY
20824: LIST
20825: LIST
20826: PPUSH
20827: CALL_OW 69
20831: ST_TO_ADDR
// if not tmp then
20832: LD_VAR 0 2
20836: NOT
20837: IFFALSE 20841
// exit ;
20839: GO 20870
// for i in tmp do
20841: LD_ADDR_VAR 0 1
20845: PUSH
20846: LD_VAR 0 2
20850: PUSH
20851: FOR_IN
20852: IFFALSE 20868
// SetLives ( i , 1 ) ;
20854: LD_VAR 0 1
20858: PPUSH
20859: LD_INT 1
20861: PPUSH
20862: CALL_OW 234
20866: GO 20851
20868: POP
20869: POP
// end ;
20870: PPOPN 2
20872: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
20873: LD_EXP 30
20877: PUSH
20878: LD_EXP 79
20882: AND
20883: IFFALSE 21153
20885: GO 20887
20887: DISABLE
20888: LD_INT 0
20890: PPUSH
20891: PPUSH
20892: PPUSH
// begin i := rand ( 1 , 7 ) ;
20893: LD_ADDR_VAR 0 1
20897: PUSH
20898: LD_INT 1
20900: PPUSH
20901: LD_INT 7
20903: PPUSH
20904: CALL_OW 12
20908: ST_TO_ADDR
// case i of 1 :
20909: LD_VAR 0 1
20913: PUSH
20914: LD_INT 1
20916: DOUBLE
20917: EQUAL
20918: IFTRUE 20922
20920: GO 20932
20922: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
20923: LD_STRING earthquake(getX(game), 0, 32)
20925: PPUSH
20926: CALL_OW 559
20930: GO 21153
20932: LD_INT 2
20934: DOUBLE
20935: EQUAL
20936: IFTRUE 20940
20938: GO 20950
20940: POP
// ToLua ( displayStucuk(); ) ; 3 :
20941: LD_STRING displayStucuk();
20943: PPUSH
20944: CALL_OW 559
20948: GO 21153
20950: LD_INT 3
20952: DOUBLE
20953: EQUAL
20954: IFTRUE 20958
20956: GO 21062
20958: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20959: LD_ADDR_VAR 0 2
20963: PUSH
20964: LD_INT 22
20966: PUSH
20967: LD_OWVAR 2
20971: PUSH
20972: EMPTY
20973: LIST
20974: LIST
20975: PUSH
20976: LD_INT 25
20978: PUSH
20979: LD_INT 1
20981: PUSH
20982: EMPTY
20983: LIST
20984: LIST
20985: PUSH
20986: EMPTY
20987: LIST
20988: LIST
20989: PPUSH
20990: CALL_OW 69
20994: ST_TO_ADDR
// if not tmp then
20995: LD_VAR 0 2
20999: NOT
21000: IFFALSE 21004
// exit ;
21002: GO 21153
// un := tmp [ rand ( 1 , tmp ) ] ;
21004: LD_ADDR_VAR 0 3
21008: PUSH
21009: LD_VAR 0 2
21013: PUSH
21014: LD_INT 1
21016: PPUSH
21017: LD_VAR 0 2
21021: PPUSH
21022: CALL_OW 12
21026: ARRAY
21027: ST_TO_ADDR
// if Crawls ( un ) then
21028: LD_VAR 0 3
21032: PPUSH
21033: CALL_OW 318
21037: IFFALSE 21048
// ComWalk ( un ) ;
21039: LD_VAR 0 3
21043: PPUSH
21044: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21048: LD_VAR 0 3
21052: PPUSH
21053: LD_INT 8
21055: PPUSH
21056: CALL_OW 336
// end ; 4 :
21060: GO 21153
21062: LD_INT 4
21064: DOUBLE
21065: EQUAL
21066: IFTRUE 21070
21068: GO 21131
21070: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
21071: LD_ADDR_VAR 0 2
21075: PUSH
21076: LD_INT 22
21078: PUSH
21079: LD_OWVAR 2
21083: PUSH
21084: EMPTY
21085: LIST
21086: LIST
21087: PUSH
21088: LD_INT 30
21090: PUSH
21091: LD_INT 29
21093: PUSH
21094: EMPTY
21095: LIST
21096: LIST
21097: PUSH
21098: EMPTY
21099: LIST
21100: LIST
21101: PPUSH
21102: CALL_OW 69
21106: ST_TO_ADDR
// if not tmp then
21107: LD_VAR 0 2
21111: NOT
21112: IFFALSE 21116
// exit ;
21114: GO 21153
// DestroyUnit ( tmp [ 1 ] ) ;
21116: LD_VAR 0 2
21120: PUSH
21121: LD_INT 1
21123: ARRAY
21124: PPUSH
21125: CALL_OW 65
// end ; 5 .. 7 :
21129: GO 21153
21131: LD_INT 5
21133: DOUBLE
21134: GREATEREQUAL
21135: IFFALSE 21143
21137: LD_INT 7
21139: DOUBLE
21140: LESSEQUAL
21141: IFTRUE 21145
21143: GO 21152
21145: POP
// StreamSibBomb ; end ;
21146: CALL 17447 0 0
21150: GO 21153
21152: POP
// end ;
21153: PPOPN 3
21155: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
21156: LD_EXP 30
21160: PUSH
21161: LD_EXP 80
21165: AND
21166: IFFALSE 21322
21168: GO 21170
21170: DISABLE
21171: LD_INT 0
21173: PPUSH
21174: PPUSH
21175: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
21176: LD_ADDR_VAR 0 2
21180: PUSH
21181: LD_INT 81
21183: PUSH
21184: LD_OWVAR 2
21188: PUSH
21189: EMPTY
21190: LIST
21191: LIST
21192: PUSH
21193: LD_INT 2
21195: PUSH
21196: LD_INT 21
21198: PUSH
21199: LD_INT 1
21201: PUSH
21202: EMPTY
21203: LIST
21204: LIST
21205: PUSH
21206: LD_INT 21
21208: PUSH
21209: LD_INT 2
21211: PUSH
21212: EMPTY
21213: LIST
21214: LIST
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: LIST
21220: PUSH
21221: EMPTY
21222: LIST
21223: LIST
21224: PPUSH
21225: CALL_OW 69
21229: ST_TO_ADDR
// if not tmp then
21230: LD_VAR 0 2
21234: NOT
21235: IFFALSE 21239
// exit ;
21237: GO 21322
// p := 0 ;
21239: LD_ADDR_VAR 0 3
21243: PUSH
21244: LD_INT 0
21246: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21247: LD_INT 35
21249: PPUSH
21250: CALL_OW 67
// p := p + 1 ;
21254: LD_ADDR_VAR 0 3
21258: PUSH
21259: LD_VAR 0 3
21263: PUSH
21264: LD_INT 1
21266: PLUS
21267: ST_TO_ADDR
// for i in tmp do
21268: LD_ADDR_VAR 0 1
21272: PUSH
21273: LD_VAR 0 2
21277: PUSH
21278: FOR_IN
21279: IFFALSE 21310
// if GetLives ( i ) < 1000 then
21281: LD_VAR 0 1
21285: PPUSH
21286: CALL_OW 256
21290: PUSH
21291: LD_INT 1000
21293: LESS
21294: IFFALSE 21308
// SetLives ( i , 1000 ) ;
21296: LD_VAR 0 1
21300: PPUSH
21301: LD_INT 1000
21303: PPUSH
21304: CALL_OW 234
21308: GO 21278
21310: POP
21311: POP
// until p > 20 ;
21312: LD_VAR 0 3
21316: PUSH
21317: LD_INT 20
21319: GREATER
21320: IFFALSE 21247
// end ;
21322: PPOPN 3
21324: END
// every 0 0$1 trigger StreamModeActive and sTime do
21325: LD_EXP 30
21329: PUSH
21330: LD_EXP 81
21334: AND
21335: IFFALSE 21370
21337: GO 21339
21339: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
21340: LD_INT 28
21342: PPUSH
21343: LD_OWVAR 2
21347: PPUSH
21348: LD_INT 2
21350: PPUSH
21351: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
21355: LD_INT 30
21357: PPUSH
21358: LD_OWVAR 2
21362: PPUSH
21363: LD_INT 2
21365: PPUSH
21366: CALL_OW 322
// end ;
21370: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
21371: LD_EXP 30
21375: PUSH
21376: LD_EXP 82
21380: AND
21381: IFFALSE 21502
21383: GO 21385
21385: DISABLE
21386: LD_INT 0
21388: PPUSH
21389: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21390: LD_ADDR_VAR 0 2
21394: PUSH
21395: LD_INT 22
21397: PUSH
21398: LD_OWVAR 2
21402: PUSH
21403: EMPTY
21404: LIST
21405: LIST
21406: PUSH
21407: LD_INT 21
21409: PUSH
21410: LD_INT 1
21412: PUSH
21413: EMPTY
21414: LIST
21415: LIST
21416: PUSH
21417: LD_INT 3
21419: PUSH
21420: LD_INT 23
21422: PUSH
21423: LD_INT 0
21425: PUSH
21426: EMPTY
21427: LIST
21428: LIST
21429: PUSH
21430: EMPTY
21431: LIST
21432: LIST
21433: PUSH
21434: EMPTY
21435: LIST
21436: LIST
21437: LIST
21438: PPUSH
21439: CALL_OW 69
21443: ST_TO_ADDR
// if not tmp then
21444: LD_VAR 0 2
21448: NOT
21449: IFFALSE 21453
// exit ;
21451: GO 21502
// for i in tmp do
21453: LD_ADDR_VAR 0 1
21457: PUSH
21458: LD_VAR 0 2
21462: PUSH
21463: FOR_IN
21464: IFFALSE 21500
// begin if Crawls ( i ) then
21466: LD_VAR 0 1
21470: PPUSH
21471: CALL_OW 318
21475: IFFALSE 21486
// ComWalk ( i ) ;
21477: LD_VAR 0 1
21481: PPUSH
21482: CALL_OW 138
// SetClass ( i , 2 ) ;
21486: LD_VAR 0 1
21490: PPUSH
21491: LD_INT 2
21493: PPUSH
21494: CALL_OW 336
// end ;
21498: GO 21463
21500: POP
21501: POP
// end ;
21502: PPOPN 2
21504: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
21505: LD_EXP 30
21509: PUSH
21510: LD_EXP 83
21514: AND
21515: IFFALSE 21720
21517: GO 21519
21519: DISABLE
21520: LD_INT 0
21522: PPUSH
21523: PPUSH
21524: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
21525: LD_OWVAR 2
21529: PPUSH
21530: LD_INT 9
21532: PPUSH
21533: LD_INT 1
21535: PPUSH
21536: LD_INT 1
21538: PPUSH
21539: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
21543: LD_INT 9
21545: PPUSH
21546: LD_OWVAR 2
21550: PPUSH
21551: CALL_OW 343
// hc_name := Dark Warrior ;
21555: LD_ADDR_OWVAR 26
21559: PUSH
21560: LD_STRING Dark Warrior
21562: ST_TO_ADDR
// hc_gallery :=  ;
21563: LD_ADDR_OWVAR 33
21567: PUSH
21568: LD_STRING 
21570: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
21571: LD_INT 1
21573: PPUSH
21574: LD_INT 1
21576: PPUSH
21577: LD_INT 10
21579: PPUSH
21580: CALL_OW 380
// un := CreateHuman ;
21584: LD_ADDR_VAR 0 3
21588: PUSH
21589: CALL_OW 44
21593: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
21594: LD_VAR 0 3
21598: PPUSH
21599: LD_INT 1
21601: PPUSH
21602: CALL_OW 51
// p := 0 ;
21606: LD_ADDR_VAR 0 2
21610: PUSH
21611: LD_INT 0
21613: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21614: LD_INT 35
21616: PPUSH
21617: CALL_OW 67
// if GetLives ( un ) < 1000 then
21621: LD_VAR 0 3
21625: PPUSH
21626: CALL_OW 256
21630: PUSH
21631: LD_INT 1000
21633: LESS
21634: IFFALSE 21648
// SetLives ( un , 1000 ) ;
21636: LD_VAR 0 3
21640: PPUSH
21641: LD_INT 1000
21643: PPUSH
21644: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
21648: LD_VAR 0 3
21652: PPUSH
21653: LD_INT 81
21655: PUSH
21656: LD_OWVAR 2
21660: PUSH
21661: EMPTY
21662: LIST
21663: LIST
21664: PPUSH
21665: CALL_OW 69
21669: PPUSH
21670: LD_VAR 0 3
21674: PPUSH
21675: CALL_OW 74
21679: PPUSH
21680: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
21684: LD_VAR 0 2
21688: PUSH
21689: LD_INT 60
21691: GREATER
21692: PUSH
21693: LD_VAR 0 3
21697: PPUSH
21698: CALL_OW 301
21702: OR
21703: IFFALSE 21614
// if un then
21705: LD_VAR 0 3
21709: IFFALSE 21720
// RemoveUnit ( un ) ;
21711: LD_VAR 0 3
21715: PPUSH
21716: CALL_OW 64
// end ; end_of_file
21720: PPOPN 3
21722: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
21723: LD_INT 0
21725: PPUSH
21726: PPUSH
21727: PPUSH
21728: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
21729: LD_VAR 0 1
21733: PPUSH
21734: CALL_OW 264
21738: PUSH
21739: LD_EXP 29
21743: EQUAL
21744: IFFALSE 21816
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
21746: LD_INT 68
21748: PPUSH
21749: LD_VAR 0 1
21753: PPUSH
21754: CALL_OW 255
21758: PPUSH
21759: CALL_OW 321
21763: PUSH
21764: LD_INT 2
21766: EQUAL
21767: IFFALSE 21779
// eff := 70 else
21769: LD_ADDR_VAR 0 6
21773: PUSH
21774: LD_INT 70
21776: ST_TO_ADDR
21777: GO 21787
// eff := 30 ;
21779: LD_ADDR_VAR 0 6
21783: PUSH
21784: LD_INT 30
21786: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
21787: LD_VAR 0 1
21791: PPUSH
21792: CALL_OW 250
21796: PPUSH
21797: LD_VAR 0 1
21801: PPUSH
21802: CALL_OW 251
21806: PPUSH
21807: LD_VAR 0 6
21811: PPUSH
21812: CALL_OW 495
// end ; end ;
21816: LD_VAR 0 4
21820: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
21821: LD_INT 0
21823: PPUSH
21824: PPUSH
21825: PPUSH
21826: PPUSH
21827: PPUSH
21828: PPUSH
// if cmd = 124 then
21829: LD_VAR 0 1
21833: PUSH
21834: LD_INT 124
21836: EQUAL
21837: IFFALSE 22043
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
21839: LD_ADDR_VAR 0 5
21843: PUSH
21844: LD_INT 2
21846: PUSH
21847: LD_INT 34
21849: PUSH
21850: LD_INT 53
21852: PUSH
21853: EMPTY
21854: LIST
21855: LIST
21856: PUSH
21857: LD_INT 34
21859: PUSH
21860: LD_INT 14
21862: PUSH
21863: EMPTY
21864: LIST
21865: LIST
21866: PUSH
21867: EMPTY
21868: LIST
21869: LIST
21870: LIST
21871: PPUSH
21872: CALL_OW 69
21876: ST_TO_ADDR
// if not tmp then
21877: LD_VAR 0 5
21881: NOT
21882: IFFALSE 21886
// exit ;
21884: GO 22043
// for i in tmp do
21886: LD_ADDR_VAR 0 3
21890: PUSH
21891: LD_VAR 0 5
21895: PUSH
21896: FOR_IN
21897: IFFALSE 22041
// begin taskList := GetTaskList ( i ) ;
21899: LD_ADDR_VAR 0 6
21903: PUSH
21904: LD_VAR 0 3
21908: PPUSH
21909: CALL_OW 437
21913: ST_TO_ADDR
// if not taskList then
21914: LD_VAR 0 6
21918: NOT
21919: IFFALSE 21923
// continue ;
21921: GO 21896
// for j = 1 to taskList do
21923: LD_ADDR_VAR 0 4
21927: PUSH
21928: DOUBLE
21929: LD_INT 1
21931: DEC
21932: ST_TO_ADDR
21933: LD_VAR 0 6
21937: PUSH
21938: FOR_TO
21939: IFFALSE 22037
// if taskList [ j ] [ 1 ] = | then
21941: LD_VAR 0 6
21945: PUSH
21946: LD_VAR 0 4
21950: ARRAY
21951: PUSH
21952: LD_INT 1
21954: ARRAY
21955: PUSH
21956: LD_STRING |
21958: EQUAL
21959: IFFALSE 22035
// begin _taskList := Delete ( taskList , 1 ) ;
21961: LD_ADDR_VAR 0 7
21965: PUSH
21966: LD_VAR 0 6
21970: PPUSH
21971: LD_INT 1
21973: PPUSH
21974: CALL_OW 3
21978: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
21979: LD_VAR 0 3
21983: PPUSH
21984: LD_VAR 0 7
21988: PPUSH
21989: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
21993: LD_VAR 0 3
21997: PPUSH
21998: LD_VAR 0 6
22002: PUSH
22003: LD_VAR 0 4
22007: ARRAY
22008: PUSH
22009: LD_INT 2
22011: ARRAY
22012: PPUSH
22013: LD_VAR 0 6
22017: PUSH
22018: LD_VAR 0 4
22022: ARRAY
22023: PUSH
22024: LD_INT 3
22026: ARRAY
22027: PPUSH
22028: LD_INT 8
22030: PPUSH
22031: CALL 22048 0 4
// end ;
22035: GO 21938
22037: POP
22038: POP
// end ;
22039: GO 21896
22041: POP
22042: POP
// end ; end ;
22043: LD_VAR 0 2
22047: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
22048: LD_INT 0
22050: PPUSH
22051: PPUSH
22052: PPUSH
22053: PPUSH
22054: PPUSH
22055: PPUSH
22056: PPUSH
22057: PPUSH
22058: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
22059: LD_VAR 0 1
22063: NOT
22064: PUSH
22065: LD_VAR 0 2
22069: PPUSH
22070: LD_VAR 0 3
22074: PPUSH
22075: CALL_OW 488
22079: NOT
22080: OR
22081: PUSH
22082: LD_VAR 0 4
22086: NOT
22087: OR
22088: IFFALSE 22092
// exit ;
22090: GO 22432
// list := [ ] ;
22092: LD_ADDR_VAR 0 13
22096: PUSH
22097: EMPTY
22098: ST_TO_ADDR
// if x - r < 0 then
22099: LD_VAR 0 2
22103: PUSH
22104: LD_VAR 0 4
22108: MINUS
22109: PUSH
22110: LD_INT 0
22112: LESS
22113: IFFALSE 22125
// min_x := 0 else
22115: LD_ADDR_VAR 0 7
22119: PUSH
22120: LD_INT 0
22122: ST_TO_ADDR
22123: GO 22141
// min_x := x - r ;
22125: LD_ADDR_VAR 0 7
22129: PUSH
22130: LD_VAR 0 2
22134: PUSH
22135: LD_VAR 0 4
22139: MINUS
22140: ST_TO_ADDR
// if y - r < 0 then
22141: LD_VAR 0 3
22145: PUSH
22146: LD_VAR 0 4
22150: MINUS
22151: PUSH
22152: LD_INT 0
22154: LESS
22155: IFFALSE 22167
// min_y := 0 else
22157: LD_ADDR_VAR 0 8
22161: PUSH
22162: LD_INT 0
22164: ST_TO_ADDR
22165: GO 22183
// min_y := y - r ;
22167: LD_ADDR_VAR 0 8
22171: PUSH
22172: LD_VAR 0 3
22176: PUSH
22177: LD_VAR 0 4
22181: MINUS
22182: ST_TO_ADDR
// max_x := x + r ;
22183: LD_ADDR_VAR 0 9
22187: PUSH
22188: LD_VAR 0 2
22192: PUSH
22193: LD_VAR 0 4
22197: PLUS
22198: ST_TO_ADDR
// max_y := y + r ;
22199: LD_ADDR_VAR 0 10
22203: PUSH
22204: LD_VAR 0 3
22208: PUSH
22209: LD_VAR 0 4
22213: PLUS
22214: ST_TO_ADDR
// for _x = min_x to max_x do
22215: LD_ADDR_VAR 0 11
22219: PUSH
22220: DOUBLE
22221: LD_VAR 0 7
22225: DEC
22226: ST_TO_ADDR
22227: LD_VAR 0 9
22231: PUSH
22232: FOR_TO
22233: IFFALSE 22350
// for _y = min_y to max_y do
22235: LD_ADDR_VAR 0 12
22239: PUSH
22240: DOUBLE
22241: LD_VAR 0 8
22245: DEC
22246: ST_TO_ADDR
22247: LD_VAR 0 10
22251: PUSH
22252: FOR_TO
22253: IFFALSE 22346
// begin if not ValidHex ( _x , _y ) then
22255: LD_VAR 0 11
22259: PPUSH
22260: LD_VAR 0 12
22264: PPUSH
22265: CALL_OW 488
22269: NOT
22270: IFFALSE 22274
// continue ;
22272: GO 22252
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
22274: LD_VAR 0 11
22278: PPUSH
22279: LD_VAR 0 12
22283: PPUSH
22284: CALL_OW 351
22288: PUSH
22289: LD_VAR 0 11
22293: PPUSH
22294: LD_VAR 0 12
22298: PPUSH
22299: CALL_OW 554
22303: AND
22304: IFFALSE 22344
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
22306: LD_ADDR_VAR 0 13
22310: PUSH
22311: LD_VAR 0 13
22315: PPUSH
22316: LD_VAR 0 13
22320: PUSH
22321: LD_INT 1
22323: PLUS
22324: PPUSH
22325: LD_VAR 0 11
22329: PUSH
22330: LD_VAR 0 12
22334: PUSH
22335: EMPTY
22336: LIST
22337: LIST
22338: PPUSH
22339: CALL_OW 2
22343: ST_TO_ADDR
// end ;
22344: GO 22252
22346: POP
22347: POP
22348: GO 22232
22350: POP
22351: POP
// if not list then
22352: LD_VAR 0 13
22356: NOT
22357: IFFALSE 22361
// exit ;
22359: GO 22432
// for i in list do
22361: LD_ADDR_VAR 0 6
22365: PUSH
22366: LD_VAR 0 13
22370: PUSH
22371: FOR_IN
22372: IFFALSE 22430
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
22374: LD_VAR 0 1
22378: PPUSH
22379: LD_STRING M
22381: PUSH
22382: LD_VAR 0 6
22386: PUSH
22387: LD_INT 1
22389: ARRAY
22390: PUSH
22391: LD_VAR 0 6
22395: PUSH
22396: LD_INT 2
22398: ARRAY
22399: PUSH
22400: LD_INT 0
22402: PUSH
22403: LD_INT 0
22405: PUSH
22406: LD_INT 0
22408: PUSH
22409: LD_INT 0
22411: PUSH
22412: EMPTY
22413: LIST
22414: LIST
22415: LIST
22416: LIST
22417: LIST
22418: LIST
22419: LIST
22420: PUSH
22421: EMPTY
22422: LIST
22423: PPUSH
22424: CALL_OW 447
22428: GO 22371
22430: POP
22431: POP
// end ;
22432: LD_VAR 0 5
22436: RET
