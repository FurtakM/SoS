// starting begin ResetFog ;
   0: CALL_OW 335
// Global_Variables ;
   4: CALL 37 0 0
// PreparePlayer ;
   8: CALL 87 0 0
// PrepareCPU ;
  12: CALL 247 0 0
// CreateApemans ( 12 ) ;
  16: LD_INT 12
  18: PPUSH
  19: CALL 2031 0 1
// if debug then
  23: LD_EXP 2
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// end ;
  36: END
// export skill , debug ; function Global_Variables ; begin
  37: LD_INT 0
  39: PPUSH
// debug := true ;
  40: LD_ADDR_EXP 2
  44: PUSH
  45: LD_INT 1
  47: ST_TO_ADDR
// skill := 5 ;
  48: LD_ADDR_EXP 1
  52: PUSH
  53: LD_INT 5
  55: ST_TO_ADDR
// TeleportExit ( tel1 , 44 , 28 ) ;
  56: LD_INT 3
  58: PPUSH
  59: LD_INT 44
  61: PPUSH
  62: LD_INT 28
  64: PPUSH
  65: CALL_OW 243
// TeleportExit ( tel2 , 166 , 89 ) ;
  69: LD_INT 2
  71: PPUSH
  72: LD_INT 166
  74: PPUSH
  75: LD_INT 89
  77: PPUSH
  78: CALL_OW 243
// end ; end_of_file
  82: LD_VAR 0 1
  86: RET
// export function PreparePlayer ; var i , k ; begin
  87: LD_INT 0
  89: PPUSH
  90: PPUSH
  91: PPUSH
// uc_side := 1 ;
  92: LD_ADDR_OWVAR 20
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// uc_nation := 1 ;
 100: LD_ADDR_OWVAR 21
 104: PUSH
 105: LD_INT 1
 107: ST_TO_ADDR
// k := 1 ;
 108: LD_ADDR_VAR 0 3
 112: PUSH
 113: LD_INT 1
 115: ST_TO_ADDR
// hc_importance := 100 ;
 116: LD_ADDR_OWVAR 32
 120: PUSH
 121: LD_INT 100
 123: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 1
 129: PPUSH
 130: LD_EXP 1
 134: PPUSH
 135: CALL_OW 380
// PlaceUnitArea ( CreateHuman , PlayerArea , false ) ;
 139: CALL_OW 44
 143: PPUSH
 144: LD_INT 3
 146: PPUSH
 147: LD_INT 0
 149: PPUSH
 150: CALL_OW 49
// hc_importance := 0 ;
 154: LD_ADDR_OWVAR 32
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// for i = 1 to 8 do
 162: LD_ADDR_VAR 0 2
 166: PUSH
 167: DOUBLE
 168: LD_INT 1
 170: DEC
 171: ST_TO_ADDR
 172: LD_INT 8
 174: PUSH
 175: FOR_TO
 176: IFFALSE 240
// begin PrepareHuman ( true , k , skill ) ;
 178: LD_INT 1
 180: PPUSH
 181: LD_VAR 0 3
 185: PPUSH
 186: LD_EXP 1
 190: PPUSH
 191: CALL_OW 380
// PlaceUnitArea ( CreateHuman , PlayerArea , false ) ;
 195: CALL_OW 44
 199: PPUSH
 200: LD_INT 3
 202: PPUSH
 203: LD_INT 0
 205: PPUSH
 206: CALL_OW 49
// if ( i mod 2 = 0 ) then
 210: LD_VAR 0 2
 214: PUSH
 215: LD_INT 2
 217: MOD
 218: PUSH
 219: LD_INT 0
 221: EQUAL
 222: IFFALSE 238
// k = k + 1 ;
 224: LD_ADDR_VAR 0 3
 228: PUSH
 229: LD_VAR 0 3
 233: PUSH
 234: LD_INT 1
 236: PLUS
 237: ST_TO_ADDR
// end ;
 238: GO 175
 240: POP
 241: POP
// end ; end_of_file
 242: LD_VAR 0 1
 246: RET
// export function PrepareCPU ; var i , k ; begin
 247: LD_INT 0
 249: PPUSH
 250: PPUSH
 251: PPUSH
// uc_side := 2 ;
 252: LD_ADDR_OWVAR 20
 256: PUSH
 257: LD_INT 2
 259: ST_TO_ADDR
// uc_nation := 1 ;
 260: LD_ADDR_OWVAR 21
 264: PUSH
 265: LD_INT 1
 267: ST_TO_ADDR
// k := 1 ;
 268: LD_ADDR_VAR 0 3
 272: PUSH
 273: LD_INT 1
 275: ST_TO_ADDR
// hc_importance := 100 ;
 276: LD_ADDR_OWVAR 32
 280: PUSH
 281: LD_INT 100
 283: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 284: LD_INT 0
 286: PPUSH
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 1
 294: PPUSH
 295: CALL_OW 380
// PlaceUnitArea ( CreateHuman , CPUArea , false ) ;
 299: CALL_OW 44
 303: PPUSH
 304: LD_INT 4
 306: PPUSH
 307: LD_INT 0
 309: PPUSH
 310: CALL_OW 49
// hc_importance := 0 ;
 314: LD_ADDR_OWVAR 32
 318: PUSH
 319: LD_INT 0
 321: ST_TO_ADDR
// for i = 1 to 8 do
 322: LD_ADDR_VAR 0 2
 326: PUSH
 327: DOUBLE
 328: LD_INT 1
 330: DEC
 331: ST_TO_ADDR
 332: LD_INT 8
 334: PUSH
 335: FOR_TO
 336: IFFALSE 400
// begin PrepareHuman ( true , k , skill ) ;
 338: LD_INT 1
 340: PPUSH
 341: LD_VAR 0 3
 345: PPUSH
 346: LD_EXP 1
 350: PPUSH
 351: CALL_OW 380
// PlaceUnitArea ( CreateHuman , CPUArea , false ) ;
 355: CALL_OW 44
 359: PPUSH
 360: LD_INT 4
 362: PPUSH
 363: LD_INT 0
 365: PPUSH
 366: CALL_OW 49
// if ( i mod 2 = 0 ) then
 370: LD_VAR 0 2
 374: PUSH
 375: LD_INT 2
 377: MOD
 378: PUSH
 379: LD_INT 0
 381: EQUAL
 382: IFFALSE 398
// k = k + 1 ;
 384: LD_ADDR_VAR 0 3
 388: PUSH
 389: LD_VAR 0 3
 393: PUSH
 394: LD_INT 1
 396: PLUS
 397: ST_TO_ADDR
// end ;
 398: GO 335
 400: POP
 401: POP
// cpu_counter := 0 ;
 402: LD_ADDR_EXP 3
 406: PUSH
 407: LD_INT 0
 409: ST_TO_ADDR
// cpu_goal := 0 ;
 410: LD_ADDR_EXP 4
 414: PUSH
 415: LD_INT 0
 417: ST_TO_ADDR
// end ;
 418: LD_VAR 0 1
 422: RET
// export cpu_counter , cpu_goal ; export f_sol , f_eng , f_mech , f_sci ; export dep , lab , fac , teleport , barracks , towers ; every 0 0$01 do var i , skr , p , k , c , xy , pom ;
 423: GO 425
 425: DISABLE
 426: LD_INT 0
 428: PPUSH
 429: PPUSH
 430: PPUSH
 431: PPUSH
 432: PPUSH
 433: PPUSH
 434: PPUSH
// begin enable ;
 435: ENABLE
// f_sol := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 1 ] ] ) ;
 436: LD_ADDR_EXP 5
 440: PUSH
 441: LD_INT 22
 443: PUSH
 444: LD_INT 2
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: PUSH
 451: LD_INT 25
 453: PUSH
 454: LD_INT 1
 456: PUSH
 457: EMPTY
 458: LIST
 459: LIST
 460: PUSH
 461: EMPTY
 462: LIST
 463: LIST
 464: PPUSH
 465: CALL_OW 69
 469: ST_TO_ADDR
// f_eng := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 2 ] ] ) ;
 470: LD_ADDR_EXP 6
 474: PUSH
 475: LD_INT 22
 477: PUSH
 478: LD_INT 2
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: PUSH
 485: LD_INT 25
 487: PUSH
 488: LD_INT 2
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: PPUSH
 499: CALL_OW 69
 503: ST_TO_ADDR
// f_mech := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 3 ] ] ) ;
 504: LD_ADDR_EXP 7
 508: PUSH
 509: LD_INT 22
 511: PUSH
 512: LD_INT 2
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: PUSH
 519: LD_INT 25
 521: PUSH
 522: LD_INT 3
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL_OW 69
 537: ST_TO_ADDR
// f_sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) ;
 538: LD_ADDR_EXP 8
 542: PUSH
 543: LD_INT 22
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: PUSH
 553: LD_INT 25
 555: PUSH
 556: LD_INT 4
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: PPUSH
 567: CALL_OW 69
 571: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
 572: LD_ADDR_EXP 9
 576: PUSH
 577: LD_INT 22
 579: PUSH
 580: LD_INT 2
 582: PUSH
 583: EMPTY
 584: LIST
 585: LIST
 586: PUSH
 587: LD_INT 2
 589: PUSH
 590: LD_INT 30
 592: PUSH
 593: LD_INT 1
 595: PUSH
 596: EMPTY
 597: LIST
 598: LIST
 599: PUSH
 600: LD_INT 30
 602: PUSH
 603: LD_INT 0
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: LIST
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: PPUSH
 619: CALL_OW 69
 623: ST_TO_ADDR
// lab := scs_scan_lab ( 2 ) ;
 624: LD_ADDR_EXP 10
 628: PUSH
 629: LD_INT 2
 631: PPUSH
 632: CALL 1666 0 1
 636: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_factory ] ] ) ;
 637: LD_ADDR_EXP 11
 641: PUSH
 642: LD_INT 22
 644: PUSH
 645: LD_INT 2
 647: PUSH
 648: EMPTY
 649: LIST
 650: LIST
 651: PUSH
 652: LD_INT 30
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: PUSH
 662: EMPTY
 663: LIST
 664: LIST
 665: PPUSH
 666: CALL_OW 69
 670: ST_TO_ADDR
// if dep = 0 then
 671: LD_EXP 9
 675: PUSH
 676: LD_INT 0
 678: EQUAL
 679: IFFALSE 708
// ComBuild ( f_eng [ 1 ] , b_depot , 178 , 63 , 1 ) else
 681: LD_EXP 6
 685: PUSH
 686: LD_INT 1
 688: ARRAY
 689: PPUSH
 690: LD_INT 0
 692: PPUSH
 693: LD_INT 178
 695: PPUSH
 696: LD_INT 63
 698: PPUSH
 699: LD_INT 1
 701: PPUSH
 702: CALL_OW 145
 706: GO 1663
// begin if fac = 0 then
 708: LD_EXP 11
 712: PUSH
 713: LD_INT 0
 715: EQUAL
 716: IFFALSE 891
// begin for i = 1 to f_mech do
 718: LD_ADDR_VAR 0 1
 722: PUSH
 723: DOUBLE
 724: LD_INT 1
 726: DEC
 727: ST_TO_ADDR
 728: LD_EXP 7
 732: PUSH
 733: FOR_TO
 734: IFFALSE 889
// if IsInUnit ( f_mech [ i ] ) then
 736: LD_EXP 7
 740: PUSH
 741: LD_VAR 0 1
 745: ARRAY
 746: PPUSH
 747: CALL_OW 310
 751: IFFALSE 770
// ComExitBuilding ( f_mech [ i ] ) else
 753: LD_EXP 7
 757: PUSH
 758: LD_VAR 0 1
 762: ARRAY
 763: PPUSH
 764: CALL_OW 122
 768: GO 887
// if not HasTask ( f_mech [ i ] ) then
 770: LD_EXP 7
 774: PUSH
 775: LD_VAR 0 1
 779: ARRAY
 780: PPUSH
 781: CALL_OW 314
 785: NOT
 786: IFFALSE 887
// begin ComEnterUnit ( f_mech [ i ] , FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) [ 1 ] ) ;
 788: LD_EXP 7
 792: PUSH
 793: LD_VAR 0 1
 797: ARRAY
 798: PPUSH
 799: LD_INT 22
 801: PUSH
 802: LD_INT 2
 804: PUSH
 805: EMPTY
 806: LIST
 807: LIST
 808: PUSH
 809: LD_INT 2
 811: PUSH
 812: LD_INT 30
 814: PUSH
 815: LD_INT 0
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: PUSH
 822: LD_INT 30
 824: PUSH
 825: LD_INT 1
 827: PUSH
 828: EMPTY
 829: LIST
 830: LIST
 831: PUSH
 832: EMPTY
 833: LIST
 834: LIST
 835: LIST
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: PPUSH
 841: CALL_OW 69
 845: PUSH
 846: LD_INT 1
 848: ARRAY
 849: PPUSH
 850: CALL_OW 120
// AddComChangeProfession ( f_mech [ i ] , 2 ) ;
 854: LD_EXP 7
 858: PUSH
 859: LD_VAR 0 1
 863: ARRAY
 864: PPUSH
 865: LD_INT 2
 867: PPUSH
 868: CALL_OW 183
// AddComExitBuilding ( f_mech [ i ] ) ;
 872: LD_EXP 7
 876: PUSH
 877: LD_VAR 0 1
 881: ARRAY
 882: PPUSH
 883: CALL_OW 182
// end ;
 887: GO 733
 889: POP
 890: POP
// end ; if lab = 0 and GetResourceType ( GetBase ( dep [ 1 ] ) , mat_cans ) > 20 then
 891: LD_EXP 10
 895: PUSH
 896: LD_INT 0
 898: EQUAL
 899: PUSH
 900: LD_EXP 9
 904: PUSH
 905: LD_INT 1
 907: ARRAY
 908: PPUSH
 909: CALL_OW 274
 913: PPUSH
 914: LD_INT 1
 916: PPUSH
 917: CALL_OW 275
 921: PUSH
 922: LD_INT 20
 924: GREATER
 925: AND
 926: IFFALSE 997
// begin for i = 1 to f_eng do
 928: LD_ADDR_VAR 0 1
 932: PUSH
 933: DOUBLE
 934: LD_INT 1
 936: DEC
 937: ST_TO_ADDR
 938: LD_EXP 6
 942: PUSH
 943: FOR_TO
 944: IFFALSE 993
// if not HasTask ( f_eng [ i ] ) then
 946: LD_EXP 6
 950: PUSH
 951: LD_VAR 0 1
 955: ARRAY
 956: PPUSH
 957: CALL_OW 314
 961: NOT
 962: IFFALSE 991
// ComBuild ( f_eng [ i ] , b_lab , 180 , 51 , 3 ) ;
 964: LD_EXP 6
 968: PUSH
 969: LD_VAR 0 1
 973: ARRAY
 974: PPUSH
 975: LD_INT 6
 977: PPUSH
 978: LD_INT 180
 980: PPUSH
 981: LD_INT 51
 983: PPUSH
 984: LD_INT 3
 986: PPUSH
 987: CALL_OW 145
 991: GO 943
 993: POP
 994: POP
// end else
 995: GO 1085
// if lab then
 997: LD_EXP 10
1001: IFFALSE 1085
// begin for i = 1 to f_sci do
1003: LD_ADDR_VAR 0 1
1007: PUSH
1008: DOUBLE
1009: LD_INT 1
1011: DEC
1012: ST_TO_ADDR
1013: LD_EXP 8
1017: PUSH
1018: FOR_TO
1019: IFFALSE 1083
// begin if not IsInUnit ( f_sci [ i ] ) and not HasTask ( f_sci [ i ] ) then
1021: LD_EXP 8
1025: PUSH
1026: LD_VAR 0 1
1030: ARRAY
1031: PPUSH
1032: CALL_OW 310
1036: NOT
1037: PUSH
1038: LD_EXP 8
1042: PUSH
1043: LD_VAR 0 1
1047: ARRAY
1048: PPUSH
1049: CALL_OW 314
1053: NOT
1054: AND
1055: IFFALSE 1081
// ComEnterUnit ( f_sci [ i ] , lab [ 1 ] ) ;
1057: LD_EXP 8
1061: PUSH
1062: LD_VAR 0 1
1066: ARRAY
1067: PPUSH
1068: LD_EXP 10
1072: PUSH
1073: LD_INT 1
1075: ARRAY
1076: PPUSH
1077: CALL_OW 120
// end ;
1081: GO 1018
1083: POP
1084: POP
// end ; if GetTech ( tech_solpow , 2 ) = state_researched and GetResourceType ( GetBase ( dep [ 1 ] ) , mat_cans ) > 35 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] ] ] ) < 3 then
1085: LD_INT 35
1087: PPUSH
1088: LD_INT 2
1090: PPUSH
1091: CALL_OW 321
1095: PUSH
1096: LD_INT 2
1098: EQUAL
1099: PUSH
1100: LD_EXP 9
1104: PUSH
1105: LD_INT 1
1107: ARRAY
1108: PPUSH
1109: CALL_OW 274
1113: PPUSH
1114: LD_INT 1
1116: PPUSH
1117: CALL_OW 275
1121: PUSH
1122: LD_INT 35
1124: GREATER
1125: AND
1126: PUSH
1127: LD_INT 22
1129: PUSH
1130: LD_INT 2
1132: PUSH
1133: EMPTY
1134: LIST
1135: LIST
1136: PUSH
1137: LD_INT 2
1139: PUSH
1140: LD_INT 30
1142: PUSH
1143: LD_INT 27
1145: PUSH
1146: EMPTY
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 30
1152: PUSH
1153: LD_INT 26
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: PUSH
1160: EMPTY
1161: LIST
1162: LIST
1163: LIST
1164: PUSH
1165: EMPTY
1166: LIST
1167: LIST
1168: PPUSH
1169: CALL_OW 69
1173: PUSH
1174: LD_INT 3
1176: LESS
1177: AND
1178: IFFALSE 1560
// begin xy := [ 196 , 79 , 190 , 72 , 190 , 77 ] ;
1180: LD_ADDR_VAR 0 6
1184: PUSH
1185: LD_INT 196
1187: PUSH
1188: LD_INT 79
1190: PUSH
1191: LD_INT 190
1193: PUSH
1194: LD_INT 72
1196: PUSH
1197: LD_INT 190
1199: PUSH
1200: LD_INT 77
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: LIST
1209: LIST
1210: ST_TO_ADDR
// if HexInfo ( xy [ 1 ] , xy [ 2 ] ) = 0 then
1211: LD_VAR 0 6
1215: PUSH
1216: LD_INT 1
1218: ARRAY
1219: PPUSH
1220: LD_VAR 0 6
1224: PUSH
1225: LD_INT 2
1227: ARRAY
1228: PPUSH
1229: CALL_OW 428
1233: PUSH
1234: LD_INT 0
1236: EQUAL
1237: IFFALSE 1328
// begin for p = 1 to f_eng do
1239: LD_ADDR_VAR 0 3
1243: PUSH
1244: DOUBLE
1245: LD_INT 1
1247: DEC
1248: ST_TO_ADDR
1249: LD_EXP 6
1253: PUSH
1254: FOR_TO
1255: IFFALSE 1324
// if not HasTask ( f_eng [ p ] ) then
1257: LD_EXP 6
1261: PUSH
1262: LD_VAR 0 3
1266: ARRAY
1267: PPUSH
1268: CALL_OW 314
1272: NOT
1273: IFFALSE 1322
// ComBuild ( f_eng [ p ] , b_solar_power , xy [ 1 ] , xy [ 2 ] , Rand ( 0 , 5 ) ) ;
1275: LD_EXP 6
1279: PUSH
1280: LD_VAR 0 3
1284: ARRAY
1285: PPUSH
1286: LD_INT 27
1288: PPUSH
1289: LD_VAR 0 6
1293: PUSH
1294: LD_INT 1
1296: ARRAY
1297: PPUSH
1298: LD_VAR 0 6
1302: PUSH
1303: LD_INT 2
1305: ARRAY
1306: PPUSH
1307: LD_INT 0
1309: PPUSH
1310: LD_INT 5
1312: PPUSH
1313: CALL_OW 12
1317: PPUSH
1318: CALL_OW 145
1322: GO 1254
1324: POP
1325: POP
// end else
1326: GO 1560
// if HexInfo ( xy [ 3 ] , xy [ 4 ] ) = 0 then
1328: LD_VAR 0 6
1332: PUSH
1333: LD_INT 3
1335: ARRAY
1336: PPUSH
1337: LD_VAR 0 6
1341: PUSH
1342: LD_INT 4
1344: ARRAY
1345: PPUSH
1346: CALL_OW 428
1350: PUSH
1351: LD_INT 0
1353: EQUAL
1354: IFFALSE 1445
// begin for p = 1 to f_eng do
1356: LD_ADDR_VAR 0 3
1360: PUSH
1361: DOUBLE
1362: LD_INT 1
1364: DEC
1365: ST_TO_ADDR
1366: LD_EXP 6
1370: PUSH
1371: FOR_TO
1372: IFFALSE 1441
// if not HasTask ( f_eng [ p ] ) then
1374: LD_EXP 6
1378: PUSH
1379: LD_VAR 0 3
1383: ARRAY
1384: PPUSH
1385: CALL_OW 314
1389: NOT
1390: IFFALSE 1439
// ComBuild ( f_eng [ p ] , b_solar_power , xy [ 3 ] , xy [ 4 ] , Rand ( 0 , 5 ) ) ;
1392: LD_EXP 6
1396: PUSH
1397: LD_VAR 0 3
1401: ARRAY
1402: PPUSH
1403: LD_INT 27
1405: PPUSH
1406: LD_VAR 0 6
1410: PUSH
1411: LD_INT 3
1413: ARRAY
1414: PPUSH
1415: LD_VAR 0 6
1419: PUSH
1420: LD_INT 4
1422: ARRAY
1423: PPUSH
1424: LD_INT 0
1426: PPUSH
1427: LD_INT 5
1429: PPUSH
1430: CALL_OW 12
1434: PPUSH
1435: CALL_OW 145
1439: GO 1371
1441: POP
1442: POP
// end else
1443: GO 1560
// if HexInfo ( xy [ 5 ] , xy [ 6 ] ) = 0 then
1445: LD_VAR 0 6
1449: PUSH
1450: LD_INT 5
1452: ARRAY
1453: PPUSH
1454: LD_VAR 0 6
1458: PUSH
1459: LD_INT 6
1461: ARRAY
1462: PPUSH
1463: CALL_OW 428
1467: PUSH
1468: LD_INT 0
1470: EQUAL
1471: IFFALSE 1560
// begin for p = 1 to f_eng do
1473: LD_ADDR_VAR 0 3
1477: PUSH
1478: DOUBLE
1479: LD_INT 1
1481: DEC
1482: ST_TO_ADDR
1483: LD_EXP 6
1487: PUSH
1488: FOR_TO
1489: IFFALSE 1558
// if not HasTask ( f_eng [ p ] ) then
1491: LD_EXP 6
1495: PUSH
1496: LD_VAR 0 3
1500: ARRAY
1501: PPUSH
1502: CALL_OW 314
1506: NOT
1507: IFFALSE 1556
// ComBuild ( f_eng [ p ] , b_solar_power , xy [ 5 ] , xy [ 6 ] , Rand ( 0 , 5 ) ) ;
1509: LD_EXP 6
1513: PUSH
1514: LD_VAR 0 3
1518: ARRAY
1519: PPUSH
1520: LD_INT 27
1522: PPUSH
1523: LD_VAR 0 6
1527: PUSH
1528: LD_INT 5
1530: ARRAY
1531: PPUSH
1532: LD_VAR 0 6
1536: PUSH
1537: LD_INT 6
1539: ARRAY
1540: PPUSH
1541: LD_INT 0
1543: PPUSH
1544: LD_INT 5
1546: PPUSH
1547: CALL_OW 12
1551: PPUSH
1552: CALL_OW 145
1556: GO 1488
1558: POP
1559: POP
// end ; end ; if GetResourceType ( GetBase ( dep [ 1 ] ) , mat_cans ) < 350 then
1560: LD_EXP 9
1564: PUSH
1565: LD_INT 1
1567: ARRAY
1568: PPUSH
1569: CALL_OW 274
1573: PPUSH
1574: LD_INT 1
1576: PPUSH
1577: CALL_OW 275
1581: PUSH
1582: LD_INT 350
1584: LESS
1585: IFFALSE 1663
// begin skr = GetListOfCratesInArea ( crates_collect ) ;
1587: LD_ADDR_VAR 0 2
1591: PUSH
1592: LD_INT 6
1594: PPUSH
1595: CALL_OW 435
1599: ST_TO_ADDR
// if skr > 0 then
1600: LD_VAR 0 2
1604: PUSH
1605: LD_INT 0
1607: GREATER
1608: IFFALSE 1663
// begin for i = 1 to 2 do
1610: LD_ADDR_VAR 0 1
1614: PUSH
1615: DOUBLE
1616: LD_INT 1
1618: DEC
1619: ST_TO_ADDR
1620: LD_INT 2
1622: PUSH
1623: FOR_TO
1624: IFFALSE 1661
// ComCollect ( f_eng [ i ] , skr [ 1 ] , skr [ 2 ] ) ;
1626: LD_EXP 6
1630: PUSH
1631: LD_VAR 0 1
1635: ARRAY
1636: PPUSH
1637: LD_VAR 0 2
1641: PUSH
1642: LD_INT 1
1644: ARRAY
1645: PPUSH
1646: LD_VAR 0 2
1650: PUSH
1651: LD_INT 2
1653: ARRAY
1654: PPUSH
1655: CALL_OW 117
1659: GO 1623
1661: POP
1662: POP
// end ; end ; end ; end ;
1663: PPOPN 7
1665: END
// export function scs_scan_lab ( side ) ; begin
1666: LD_INT 0
1668: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
1669: LD_ADDR_VAR 0 2
1673: PUSH
1674: LD_INT 22
1676: PUSH
1677: LD_VAR 0 1
1681: PUSH
1682: EMPTY
1683: LIST
1684: LIST
1685: PUSH
1686: LD_INT 2
1688: PUSH
1689: LD_INT 30
1691: PUSH
1692: LD_INT 6
1694: PUSH
1695: EMPTY
1696: LIST
1697: LIST
1698: PUSH
1699: LD_INT 30
1701: PUSH
1702: LD_INT 7
1704: PUSH
1705: EMPTY
1706: LIST
1707: LIST
1708: PUSH
1709: LD_INT 30
1711: PUSH
1712: LD_INT 8
1714: PUSH
1715: EMPTY
1716: LIST
1717: LIST
1718: PUSH
1719: EMPTY
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: PUSH
1725: EMPTY
1726: LIST
1727: LIST
1728: PPUSH
1729: CALL_OW 69
1733: ST_TO_ADDR
// end ; end_of_file
1734: LD_VAR 0 2
1738: RET
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = 2 then
1739: LD_VAR 0 1
1743: PPUSH
1744: CALL_OW 255
1748: PUSH
1749: LD_INT 2
1751: EQUAL
1752: IFFALSE 1768
// cpu_counter := cpu_counter + 1 ;
1754: LD_ADDR_EXP 3
1758: PUSH
1759: LD_EXP 3
1763: PUSH
1764: LD_INT 1
1766: PLUS
1767: ST_TO_ADDR
// end ;
1768: PPOPN 1
1770: END
// on BuildingComplete ( un ) do var pom ;
1771: LD_INT 0
1773: PPUSH
// begin if GetSide ( un ) = 2 and un in FilterAllUnits ( [ [ f_btype , b_lab ] ] ) then
1774: LD_VAR 0 1
1778: PPUSH
1779: CALL_OW 255
1783: PUSH
1784: LD_INT 2
1786: EQUAL
1787: PUSH
1788: LD_VAR 0 1
1792: PUSH
1793: LD_INT 30
1795: PUSH
1796: LD_INT 6
1798: PUSH
1799: EMPTY
1800: LIST
1801: LIST
1802: PUSH
1803: EMPTY
1804: LIST
1805: PPUSH
1806: CALL_OW 69
1810: IN
1811: AND
1812: IFFALSE 1964
// begin pom := un ;
1814: LD_ADDR_VAR 0 2
1818: PUSH
1819: LD_VAR 0 1
1823: ST_TO_ADDR
// if GetTech ( tech_tech1 , 2 ) = state_enabled then
1824: LD_INT 48
1826: PPUSH
1827: LD_INT 2
1829: PPUSH
1830: CALL_OW 321
1834: PUSH
1835: LD_INT 1
1837: EQUAL
1838: IFFALSE 1852
// ComResearch ( pom , tech_tech1 ) ;
1840: LD_VAR 0 2
1844: PPUSH
1845: LD_INT 48
1847: PPUSH
1848: CALL_OW 124
// if GetTech ( tech_tech2 , 2 ) = state_enabled then
1852: LD_INT 49
1854: PPUSH
1855: LD_INT 2
1857: PPUSH
1858: CALL_OW 321
1862: PUSH
1863: LD_INT 1
1865: EQUAL
1866: IFFALSE 1880
// ComResearch ( pom , tech_tech2 ) ;
1868: LD_VAR 0 2
1872: PPUSH
1873: LD_INT 49
1875: PPUSH
1876: CALL_OW 124
// if GetTech ( tech_solpow , 2 ) = state_enabled then
1880: LD_INT 35
1882: PPUSH
1883: LD_INT 2
1885: PPUSH
1886: CALL_OW 321
1890: PUSH
1891: LD_INT 1
1893: EQUAL
1894: IFFALSE 1908
// ComResearch ( pom , tech_solpow ) ;
1896: LD_VAR 0 2
1900: PPUSH
1901: LD_INT 35
1903: PPUSH
1904: CALL_OW 124
// if GetTech ( tech_oilpow , 2 ) = state_enabled then
1908: LD_INT 46
1910: PPUSH
1911: LD_INT 2
1913: PPUSH
1914: CALL_OW 321
1918: PUSH
1919: LD_INT 1
1921: EQUAL
1922: IFFALSE 1936
// ComResearch ( pom , tech_oilpow ) ;
1924: LD_VAR 0 2
1928: PPUSH
1929: LD_INT 46
1931: PPUSH
1932: CALL_OW 124
// if GetTech ( tech_oilpow , 2 ) = state_enabled then
1936: LD_INT 46
1938: PPUSH
1939: LD_INT 2
1941: PPUSH
1942: CALL_OW 321
1946: PUSH
1947: LD_INT 1
1949: EQUAL
1950: IFFALSE 1964
// ComResearch ( pom , tech_oileng ) ;
1952: LD_VAR 0 2
1956: PPUSH
1957: LD_INT 47
1959: PPUSH
1960: CALL_OW 124
// end ; end ;
1964: PPOPN 2
1966: END
// every 0 0$33 + 0 0$07 do
1967: GO 1969
1969: DISABLE
// begin enable ;
1970: ENABLE
// Wait ( Rand ( 0 0$01 , 0 0$33 ) ) ;
1971: LD_INT 35
1973: PPUSH
1974: LD_INT 1155
1976: PPUSH
1977: CALL_OW 12
1981: PPUSH
1982: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CPUArea , true ) ;
1986: LD_INT 2
1988: PPUSH
1989: LD_INT 5
1991: PPUSH
1992: CALL_OW 12
1996: PPUSH
1997: LD_INT 4
1999: PPUSH
2000: LD_INT 1
2002: PPUSH
2003: CALL_OW 55
// end ;
2007: END
// every 1 1$55 do
2008: GO 2010
2010: DISABLE
// begin enable ;
2011: ENABLE
// CreateCratesAnyWhere ( Rand ( 1 , 5 ) , true ) ;
2012: LD_INT 1
2014: PPUSH
2015: LD_INT 5
2017: PPUSH
2018: CALL_OW 12
2022: PPUSH
2023: LD_INT 1
2025: PPUSH
2026: CALL_OW 57
// end ; end_of_file
2030: END
// export function CreateApemans ( x ) ; var i ; begin
2031: LD_INT 0
2033: PPUSH
2034: PPUSH
// uc_side := 0 ;
2035: LD_ADDR_OWVAR 20
2039: PUSH
2040: LD_INT 0
2042: ST_TO_ADDR
// uc_nation := 0 ;
2043: LD_ADDR_OWVAR 21
2047: PUSH
2048: LD_INT 0
2050: ST_TO_ADDR
// hc_class := class_apeman ;
2051: LD_ADDR_OWVAR 28
2055: PUSH
2056: LD_INT 12
2058: ST_TO_ADDR
// hc_gallery :=  ;
2059: LD_ADDR_OWVAR 33
2063: PUSH
2064: LD_STRING 
2066: ST_TO_ADDR
// hc_attr := [ Rand ( 10 , 11 ) , Rand ( 9 , 11 ) ] ;
2067: LD_ADDR_OWVAR 29
2071: PUSH
2072: LD_INT 10
2074: PPUSH
2075: LD_INT 11
2077: PPUSH
2078: CALL_OW 12
2082: PUSH
2083: LD_INT 9
2085: PPUSH
2086: LD_INT 11
2088: PPUSH
2089: CALL_OW 12
2093: PUSH
2094: EMPTY
2095: LIST
2096: LIST
2097: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
2098: LD_ADDR_OWVAR 31
2102: PUSH
2103: LD_INT 0
2105: PUSH
2106: LD_INT 0
2108: PUSH
2109: LD_INT 0
2111: PUSH
2112: LD_INT 0
2114: PUSH
2115: EMPTY
2116: LIST
2117: LIST
2118: LIST
2119: LIST
2120: ST_TO_ADDR
// for i = 1 to x do
2121: LD_ADDR_VAR 0 3
2125: PUSH
2126: DOUBLE
2127: LD_INT 1
2129: DEC
2130: ST_TO_ADDR
2131: LD_VAR 0 1
2135: PUSH
2136: FOR_TO
2137: IFFALSE 2156
// PlaceUnitArea ( CreateHuman , apeman_area , false ) ;
2139: CALL_OW 44
2143: PPUSH
2144: LD_INT 5
2146: PPUSH
2147: LD_INT 0
2149: PPUSH
2150: CALL_OW 49
2154: GO 2136
2156: POP
2157: POP
// end ;
2158: LD_VAR 0 2
2162: RET
