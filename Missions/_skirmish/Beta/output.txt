// export MissionStart ; starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  11: LD_INT 1
  13: PPUSH
  14: LD_INT 8
  16: PPUSH
  17: CALL_OW 332
// GameType ;
  21: CALL 5207 0 0
// SetBName ( BetaA , beta ) ;
  25: LD_INT 1
  27: PPUSH
  28: LD_STRING beta
  30: PPUSH
  31: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  35: LD_INT 3
  37: PPUSH
  38: LD_STRING beta
  40: PPUSH
  41: CALL_OW 500
// PrepareHeroes ;
  45: CALL 2370 0 0
// PrepareBeta ;
  49: CALL 2759 0 0
// InGameOn ;
  53: CALL_OW 8
// CenterNowOnUnits ( Brighton ) ;
  57: LD_EXP 8
  61: PPUSH
  62: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
  66: LD_EXP 10
  70: PPUSH
  71: LD_INT 50
  73: PPUSH
  74: LD_INT 42
  76: PPUSH
  77: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
  81: LD_INT 35
  83: PPUSH
  84: CALL_OW 67
  88: LD_EXP 10
  92: PPUSH
  93: LD_EXP 8
  97: PPUSH
  98: CALL_OW 296
 102: PUSH
 103: LD_INT 3
 105: LESS
 106: IFFALSE 81
// ComTurnUnit ( Megan , Brighton ) ;
 108: LD_EXP 10
 112: PPUSH
 113: LD_EXP 8
 117: PPUSH
 118: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 122: LD_EXP 10
 126: PPUSH
 127: LD_STRING DMegan-1a
 129: PPUSH
 130: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 134: LD_INT 10
 136: PPUSH
 137: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 141: LD_EXP 8
 145: PPUSH
 146: LD_EXP 10
 150: PPUSH
 151: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 155: LD_EXP 8
 159: PPUSH
 160: LD_STRING DBrighton-1a
 162: PPUSH
 163: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 167: LD_EXP 10
 171: PPUSH
 172: LD_STRING DMegan-2a
 174: PPUSH
 175: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 179: LD_EXP 8
 183: PPUSH
 184: LD_STRING DBrighton-2a
 186: PPUSH
 187: CALL_OW 88
// Say ( Megan , DMegan-3a ) ;
 191: LD_EXP 10
 195: PPUSH
 196: LD_STRING DMegan-3a
 198: PPUSH
 199: CALL_OW 88
// Say ( Brighton , DBrighton-3a ) ;
 203: LD_EXP 8
 207: PPUSH
 208: LD_STRING DBrighton-3a
 210: PPUSH
 211: CALL_OW 88
// Say ( Megan , DMegan-4a ) ;
 215: LD_EXP 10
 219: PPUSH
 220: LD_STRING DMegan-4a
 222: PPUSH
 223: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 227: LD_EXP 10
 231: PPUSH
 232: LD_INT 40
 234: PPUSH
 235: LD_INT 37
 237: PPUSH
 238: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 242: LD_EXP 10
 246: PPUSH
 247: LD_EXP 8
 251: PPUSH
 252: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 256: LD_EXP 9
 260: PPUSH
 261: LD_INT 50
 263: PPUSH
 264: LD_INT 42
 266: PPUSH
 267: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 271: LD_INT 35
 273: PPUSH
 274: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 278: LD_EXP 8
 282: PPUSH
 283: LD_EXP 9
 287: PPUSH
 288: CALL_OW 296
 292: PUSH
 293: LD_INT 6
 295: LESS
 296: IFFALSE 271
// ComTurnUnit ( Brighton , Palmer ) ;
 298: LD_EXP 8
 302: PPUSH
 303: LD_EXP 9
 307: PPUSH
 308: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 312: LD_EXP 9
 316: PPUSH
 317: LD_EXP 8
 321: PPUSH
 322: CALL_OW 119
// Say ( Megan , DMegan-5a ) ;
 326: LD_EXP 10
 330: PPUSH
 331: LD_STRING DMegan-5a
 333: PPUSH
 334: CALL_OW 88
// Say ( Palmer , DPalmer-1 ) ;
 338: LD_EXP 9
 342: PPUSH
 343: LD_STRING DPalmer-1
 345: PPUSH
 346: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 350: LD_EXP 8
 354: PPUSH
 355: LD_STRING DBrighton-1
 357: PPUSH
 358: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 362: LD_EXP 9
 366: PPUSH
 367: LD_STRING DPalmer-2
 369: PPUSH
 370: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 374: LD_EXP 8
 378: PPUSH
 379: LD_STRING DBrighton-2
 381: PPUSH
 382: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 386: LD_EXP 9
 390: PPUSH
 391: LD_STRING DPalmer-3
 393: PPUSH
 394: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 398: LD_EXP 8
 402: PPUSH
 403: LD_STRING DBrighton-3
 405: PPUSH
 406: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 410: LD_EXP 9
 414: PPUSH
 415: LD_STRING DPalmer-4
 417: PPUSH
 418: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 422: LD_EXP 9
 426: PPUSH
 427: LD_INT 6
 429: PPUSH
 430: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 434: LD_INT 35
 436: PPUSH
 437: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 441: LD_EXP 9
 445: PPUSH
 446: CALL_OW 310
 450: PUSH
 451: LD_INT 6
 453: EQUAL
 454: IFFALSE 434
// SayRadio ( Palmer , DPalmer-5 ) ;
 456: LD_EXP 9
 460: PPUSH
 461: LD_STRING DPalmer-5
 463: PPUSH
 464: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 468: LD_EXP 8
 472: PPUSH
 473: LD_INT 59
 475: PPUSH
 476: LD_INT 36
 478: PPUSH
 479: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_INT 60
 490: PPUSH
 491: LD_INT 35
 493: PPUSH
 494: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 498: LD_EXP 9
 502: PPUSH
 503: LD_INT 60
 505: PPUSH
 506: LD_INT 34
 508: PPUSH
 509: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 513: LD_EXP 8
 517: PPUSH
 518: LD_INT 99
 520: PPUSH
 521: LD_INT 37
 523: PPUSH
 524: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 528: LD_EXP 10
 532: PPUSH
 533: LD_EXP 8
 537: PPUSH
 538: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 542: LD_EXP 9
 546: PPUSH
 547: LD_EXP 8
 551: PPUSH
 552: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 556: LD_INT 64
 558: PPUSH
 559: LD_INT 40
 561: PPUSH
 562: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 566: LD_EXP 11
 570: PPUSH
 571: LD_INT 13
 573: PPUSH
 574: CALL 10936 0 2
// wait ( 0 0$30 ) ;
 578: LD_INT 1050
 580: PPUSH
 581: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 585: LD_EXP 8
 589: PPUSH
 590: LD_STRING DBrighton-4
 592: PPUSH
 593: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 597: LD_EXP 8
 601: PPUSH
 602: LD_STRING DBrighton-5
 604: PPUSH
 605: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 609: LD_EXP 8
 613: PPUSH
 614: LD_EXP 10
 618: PPUSH
 619: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 623: LD_EXP 8
 627: PPUSH
 628: LD_STRING DBrighton-6
 630: PPUSH
 631: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 635: LD_EXP 10
 639: PPUSH
 640: LD_STRING DMegan-1
 642: PPUSH
 643: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 647: LD_EXP 8
 651: PPUSH
 652: LD_STRING DBrighton-7
 654: PPUSH
 655: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 659: LD_EXP 8
 663: PPUSH
 664: LD_INT 99
 666: PPUSH
 667: LD_INT 37
 669: PPUSH
 670: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 674: LD_EXP 8
 678: PPUSH
 679: LD_STRING DBrighton-8
 681: PPUSH
 682: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 686: LD_STRING C1
 688: PPUSH
 689: CALL_OW 337
// InGameOff ;
 693: CALL_OW 9
// SaveForQuickRestart ;
 697: CALL_OW 22
// MissionStart := true ;
 701: LD_ADDR_EXP 1
 705: PUSH
 706: LD_INT 1
 708: ST_TO_ADDR
// music_nat := 1 ;
 709: LD_ADDR_OWVAR 71
 713: PUSH
 714: LD_INT 1
 716: ST_TO_ADDR
// end ;
 717: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var tmp , i ;
 718: LD_EXP 1
 722: IFFALSE 1917
 724: GO 726
 726: DISABLE
 727: LD_INT 0
 729: PPUSH
 730: PPUSH
// begin wait ( ruArrival ) ;
 731: LD_EXP 41
 735: PPUSH
 736: CALL_OW 67
// PrepareRUArmada ;
 740: CALL 3341 0 0
// wait ( 0 0$3 ) ;
 744: LD_INT 105
 746: PPUSH
 747: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 751: LD_ADDR_VAR 0 1
 755: PUSH
 756: LD_INT 15
 758: PPUSH
 759: LD_INT 0
 761: PPUSH
 762: CALL_OW 517
 766: ST_TO_ADDR
// for i = 1 to RUArmada do
 767: LD_ADDR_VAR 0 2
 771: PUSH
 772: DOUBLE
 773: LD_INT 1
 775: DEC
 776: ST_TO_ADDR
 777: LD_EXP 16
 781: PUSH
 782: FOR_TO
 783: IFFALSE 832
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 785: LD_EXP 16
 789: PUSH
 790: LD_VAR 0 2
 794: ARRAY
 795: PPUSH
 796: LD_VAR 0 1
 800: PUSH
 801: LD_INT 1
 803: ARRAY
 804: PUSH
 805: LD_VAR 0 2
 809: ARRAY
 810: PPUSH
 811: LD_VAR 0 1
 815: PUSH
 816: LD_INT 2
 818: ARRAY
 819: PUSH
 820: LD_VAR 0 2
 824: ARRAY
 825: PPUSH
 826: CALL_OW 111
 830: GO 782
 832: POP
 833: POP
// ArmadaArrived := true ;
 834: LD_ADDR_EXP 2
 838: PUSH
 839: LD_INT 1
 841: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 842: LD_EXP 9
 846: PPUSH
 847: LD_STRING DPalmer-A1
 849: PPUSH
 850: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 854: LD_EXP 8
 858: PPUSH
 859: LD_STRING DBrighton-A1
 861: PPUSH
 862: CALL_OW 88
// wait ( 0 0$20 ) ;
 866: LD_INT 700
 868: PPUSH
 869: CALL_OW 67
// PrepareRUBase ;
 873: CALL 4066 0 0
// PrepareRUBase_v2 ;
 877: CALL 4482 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 881: LD_ADDR_EXP 52
 885: PUSH
 886: LD_EXP 52
 890: PPUSH
 891: LD_INT 1
 893: PPUSH
 894: LD_INT 22
 896: PUSH
 897: LD_INT 3
 899: PUSH
 900: EMPTY
 901: LIST
 902: LIST
 903: PPUSH
 904: CALL_OW 69
 908: PPUSH
 909: CALL_OW 1
 913: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 914: LD_ADDR_EXP 52
 918: PUSH
 919: LD_EXP 52
 923: PPUSH
 924: LD_INT 2
 926: PPUSH
 927: LD_EXP 35
 931: PPUSH
 932: CALL_OW 1
 936: ST_TO_ADDR
// MC_Start ( ) ;
 937: CALL 55812 0 0
// wait ( 0 0$30 ) ;
 941: LD_INT 1050
 943: PPUSH
 944: CALL_OW 67
// PrepareRUBulldozers ;
 948: CALL 3953 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 952: LD_EXP 17
 956: PUSH
 957: LD_INT 1
 959: ARRAY
 960: PPUSH
 961: LD_INT 9
 963: PPUSH
 964: CALL 10793 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 968: LD_EXP 17
 972: PUSH
 973: LD_INT 2
 975: ARRAY
 976: PPUSH
 977: LD_INT 11
 979: PPUSH
 980: CALL 10793 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
 984: LD_INT 1
 986: PPUSH
 987: LD_EXP 17
 991: PUSH
 992: LD_INT 1
 994: ARRAY
 995: PPUSH
 996: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1000: LD_INT 1
1002: PPUSH
1003: LD_EXP 17
1007: PUSH
1008: LD_INT 2
1010: ARRAY
1011: PPUSH
1012: CALL_OW 471
// wait ( 0 0$30 ) ;
1016: LD_INT 1050
1018: PPUSH
1019: CALL_OW 67
// InGameOn ;
1023: CALL_OW 8
// PlaceSeeing ( 95 , 93 , 1 , - 30 ) ;
1027: LD_INT 95
1029: PPUSH
1030: LD_INT 93
1032: PPUSH
1033: LD_INT 1
1035: PPUSH
1036: LD_INT 30
1038: NEG
1039: PPUSH
1040: CALL_OW 330
// ComMoveXY ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) , 63 , 39 ) ;
1044: LD_INT 10
1046: PPUSH
1047: LD_INT 22
1049: PUSH
1050: LD_INT 1
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: PPUSH
1057: CALL_OW 70
1061: PPUSH
1062: LD_INT 63
1064: PPUSH
1065: LD_INT 39
1067: PPUSH
1068: CALL_OW 111
// CenterOnXY ( 95 , 93 ) ;
1072: LD_INT 95
1074: PPUSH
1075: LD_INT 93
1077: PPUSH
1078: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
1082: LD_INT 35
1084: PPUSH
1085: CALL_OW 67
// if not HasTask ( Bulldozers [ 1 ] ) then
1089: LD_EXP 17
1093: PUSH
1094: LD_INT 1
1096: ARRAY
1097: PPUSH
1098: CALL_OW 314
1102: NOT
1103: IFFALSE 1121
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
1105: LD_EXP 17
1109: PUSH
1110: LD_INT 1
1112: ARRAY
1113: PPUSH
1114: LD_INT 9
1116: PPUSH
1117: CALL 10793 0 2
// if not HasTask ( Bulldozers [ 2 ] ) then
1121: LD_EXP 17
1125: PUSH
1126: LD_INT 2
1128: ARRAY
1129: PPUSH
1130: CALL_OW 314
1134: NOT
1135: IFFALSE 1153
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
1137: LD_EXP 17
1141: PUSH
1142: LD_INT 2
1144: ARRAY
1145: PPUSH
1146: LD_INT 11
1148: PPUSH
1149: CALL 10793 0 2
// until ListEnvironmentArea ( BulldozerArea ) < 2 or ListEnvironmentArea ( BulldozerArea2 ) < 2 or IsDead ( Bulldozers [ 1 ] ) ;
1153: LD_INT 9
1155: PPUSH
1156: CALL_OW 353
1160: PUSH
1161: LD_INT 2
1163: LESS
1164: PUSH
1165: LD_INT 11
1167: PPUSH
1168: CALL_OW 353
1172: PUSH
1173: LD_INT 2
1175: LESS
1176: OR
1177: PUSH
1178: LD_EXP 17
1182: PUSH
1183: LD_INT 1
1185: ARRAY
1186: PPUSH
1187: CALL_OW 301
1191: OR
1192: IFFALSE 1082
// if UnitFilter ( Bulldozers , [ f_ok ] ) then
1194: LD_EXP 17
1198: PPUSH
1199: LD_INT 50
1201: PUSH
1202: EMPTY
1203: LIST
1204: PPUSH
1205: CALL_OW 72
1209: IFFALSE 1262
// begin wait ( 0 0$10 ) ;
1211: LD_INT 350
1213: PPUSH
1214: CALL_OW 67
// ComMoveXY ( Bulldozers , 120 , 131 ) ;
1218: LD_EXP 17
1222: PPUSH
1223: LD_INT 120
1225: PPUSH
1226: LD_INT 131
1228: PPUSH
1229: CALL_OW 111
// for i in Bulldozers do
1233: LD_ADDR_VAR 0 2
1237: PUSH
1238: LD_EXP 17
1242: PUSH
1243: FOR_IN
1244: IFFALSE 1260
// NormalAttack ( 1 , i ) ;
1246: LD_INT 1
1248: PPUSH
1249: LD_VAR 0 2
1253: PPUSH
1254: CALL_OW 472
1258: GO 1243
1260: POP
1261: POP
// end ; wait ( 0 0$10 ) ;
1262: LD_INT 350
1264: PPUSH
1265: CALL_OW 67
// RemoveSeeing ( 95 , 93 , 1 ) ;
1269: LD_INT 95
1271: PPUSH
1272: LD_INT 93
1274: PPUSH
1275: LD_INT 1
1277: PPUSH
1278: CALL_OW 331
// Say ( Yashin , DDeath-Yas-1 ) ;
1282: LD_EXP 12
1286: PPUSH
1287: LD_STRING DDeath-Yas-1
1289: PPUSH
1290: CALL_OW 88
// SayEffect ( DRuSol-A1 ) ;
1294: LD_STRING DRuSol-A1
1296: PPUSH
1297: CALL_OW 96
// wait ( 0 0$2 ) ;
1301: LD_INT 70
1303: PPUSH
1304: CALL_OW 67
// InGameOff ;
1308: CALL_OW 9
// ComMoveXY ( RUArmada , 66 , 40 ) ;
1312: LD_EXP 16
1316: PPUSH
1317: LD_INT 66
1319: PPUSH
1320: LD_INT 40
1322: PPUSH
1323: CALL_OW 111
// wait ( 0 0$2 ) ;
1327: LD_INT 70
1329: PPUSH
1330: CALL_OW 67
// Say ( Gaydar , DDeath-Gay-2 ) ;
1334: LD_EXP 14
1338: PPUSH
1339: LD_STRING DDeath-Gay-2
1341: PPUSH
1342: CALL_OW 88
// wait ( 0 0$20 ) ;
1346: LD_INT 700
1348: PPUSH
1349: CALL_OW 67
// AssaultStarted := true ;
1353: LD_ADDR_EXP 7
1357: PUSH
1358: LD_INT 1
1360: ST_TO_ADDR
// Say ( Popov , DDeath-Pop-1 ) ;
1361: LD_EXP 13
1365: PPUSH
1366: LD_STRING DDeath-Pop-1
1368: PPUSH
1369: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1373: LD_EXP 14
1377: PPUSH
1378: LD_STRING DDeath-Gay-1
1380: PPUSH
1381: CALL_OW 88
// wait ( 0 0$5 ) ;
1385: LD_INT 175
1387: PPUSH
1388: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1392: LD_EXP 15
1396: PPUSH
1397: LD_STRING DDeath-Vse-1
1399: PPUSH
1400: CALL_OW 88
// PriorityAttack ( 6 , BetaA ) ;
1404: LD_INT 6
1406: PPUSH
1407: LD_INT 1
1409: PPUSH
1410: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1414: LD_INT 6
1416: PPUSH
1417: LD_INT 3
1419: PPUSH
1420: CALL_OW 470
// repeat for i in RuArmada do
1424: LD_ADDR_VAR 0 2
1428: PUSH
1429: LD_EXP 16
1433: PUSH
1434: FOR_IN
1435: IFFALSE 1485
// if not HasTask ( i ) then
1437: LD_VAR 0 2
1441: PPUSH
1442: CALL_OW 314
1446: NOT
1447: IFFALSE 1483
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1449: LD_VAR 0 2
1453: PPUSH
1454: LD_INT 22
1456: PUSH
1457: LD_INT 1
1459: PUSH
1460: EMPTY
1461: LIST
1462: LIST
1463: PPUSH
1464: CALL_OW 69
1468: PPUSH
1469: LD_VAR 0 2
1473: PPUSH
1474: CALL_OW 74
1478: PPUSH
1479: CALL_OW 115
1483: GO 1434
1485: POP
1486: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1487: LD_INT 35
1489: PPUSH
1490: CALL_OW 67
1494: LD_INT 1
1496: PUSH
1497: LD_INT 22
1499: PUSH
1500: LD_INT 6
1502: PUSH
1503: EMPTY
1504: LIST
1505: LIST
1506: PUSH
1507: LD_INT 21
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: PPUSH
1522: CALL_OW 69
1526: PUSH
1527: LD_INT 10
1529: LESS
1530: PUSH
1531: LD_EXP 12
1535: PPUSH
1536: CALL_OW 301
1540: AND
1541: PUSH
1542: LD_EXP 13
1546: PPUSH
1547: CALL_OW 301
1551: AND
1552: PUSH
1553: LD_EXP 14
1557: PPUSH
1558: CALL_OW 301
1562: AND
1563: PUSH
1564: LD_EXP 15
1568: PPUSH
1569: CALL_OW 301
1573: AND
1574: IFFALSE 1424
// AssaultStarted := false ;
1576: LD_ADDR_EXP 7
1580: PUSH
1581: LD_INT 0
1583: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 6 ] ) , 120 , 131 ) ;
1584: LD_INT 22
1586: PUSH
1587: LD_INT 6
1589: PUSH
1590: EMPTY
1591: LIST
1592: LIST
1593: PPUSH
1594: CALL_OW 69
1598: PPUSH
1599: LD_INT 120
1601: PPUSH
1602: LD_INT 131
1604: PPUSH
1605: CALL_OW 111
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1609: LD_ADDR_EXP 4
1613: PUSH
1614: LD_INT 1
1616: PUSH
1617: LD_INT 22
1619: PUSH
1620: LD_INT 6
1622: PUSH
1623: EMPTY
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 26
1629: PUSH
1630: LD_INT 1
1632: PUSH
1633: EMPTY
1634: LIST
1635: LIST
1636: PUSH
1637: LD_INT 21
1639: PUSH
1640: LD_INT 1
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: LD_INT 24
1649: PUSH
1650: LD_INT 500
1652: PUSH
1653: EMPTY
1654: LIST
1655: LIST
1656: PUSH
1657: EMPTY
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: PPUSH
1664: CALL_OW 69
1668: ST_TO_ADDR
// if RuSpeaker then
1669: LD_EXP 4
1673: IFFALSE 1691
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1675: LD_EXP 4
1679: PUSH
1680: LD_INT 1
1682: ARRAY
1683: PPUSH
1684: LD_STRING DRuSol-A2
1686: PPUSH
1687: CALL_OW 88
// wait ( 0 0$30 ) ;
1691: LD_INT 1050
1693: PPUSH
1694: CALL_OW 67
// DialogueOn ;
1698: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1702: LD_EXP 8
1706: PPUSH
1707: LD_STRING DBrighton-B1
1709: PPUSH
1710: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1714: LD_EXP 9
1718: PPUSH
1719: LD_STRING DPalmer-B1
1721: PPUSH
1722: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1726: LD_EXP 8
1730: PPUSH
1731: LD_STRING DBrighton-B2
1733: PPUSH
1734: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1738: LD_EXP 18
1742: PPUSH
1743: LD_STRING DBurlak-B1
1745: PPUSH
1746: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1750: LD_EXP 8
1754: PPUSH
1755: LD_STRING DBrighton-B3
1757: PPUSH
1758: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1762: LD_EXP 9
1766: PPUSH
1767: LD_STRING DPalmer-B2
1769: PPUSH
1770: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1774: LD_EXP 8
1778: PPUSH
1779: LD_STRING DBrighton-B4
1781: PPUSH
1782: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1786: LD_EXP 8
1790: PPUSH
1791: LD_STRING DBrighton-B5
1793: PPUSH
1794: CALL_OW 88
// DialogueOff ;
1798: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1802: LD_STRING C2
1804: PPUSH
1805: CALL_OW 337
// FirstAssaultRepelled := true ;
1809: LD_ADDR_EXP 3
1813: PUSH
1814: LD_INT 1
1816: ST_TO_ADDR
// RemoveUnit ( Bulldozers [ 1 ] ) ;
1817: LD_EXP 17
1821: PUSH
1822: LD_INT 1
1824: ARRAY
1825: PPUSH
1826: CALL_OW 64
// RemoveUnit ( Bulldozers [ 2 ] ) ;
1830: LD_EXP 17
1834: PUSH
1835: LD_INT 2
1837: ARRAY
1838: PPUSH
1839: CALL_OW 64
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1843: LD_INT 22
1845: PUSH
1846: LD_INT 6
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: PPUSH
1853: CALL_OW 69
1857: PPUSH
1858: CALL_OW 181
// SetSide ( FilterAllUnits ( [ f_side , 6 ] ) , 3 ) ;
1862: LD_INT 22
1864: PUSH
1865: LD_INT 6
1867: PUSH
1868: EMPTY
1869: LIST
1870: LIST
1871: PPUSH
1872: CALL_OW 69
1876: PPUSH
1877: LD_INT 3
1879: PPUSH
1880: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
1884: LD_ADDR_EXP 52
1888: PUSH
1889: LD_EXP 52
1893: PPUSH
1894: LD_INT 1
1896: PPUSH
1897: LD_INT 22
1899: PUSH
1900: LD_INT 3
1902: PUSH
1903: EMPTY
1904: LIST
1905: LIST
1906: PPUSH
1907: CALL_OW 69
1911: PPUSH
1912: CALL_OW 1
1916: ST_TO_ADDR
// end ;
1917: PPOPN 2
1919: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
1920: LD_EXP 3
1924: PUSH
1925: LD_EXP 40
1929: PUSH
1930: LD_INT 0
1932: GREATER
1933: AND
1934: IFFALSE 1954
1936: GO 1938
1938: DISABLE
// begin enable ;
1939: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
1940: LD_ADDR_EXP 40
1944: PUSH
1945: LD_EXP 40
1949: PUSH
1950: LD_INT 35
1952: MINUS
1953: ST_TO_ADDR
// end ;
1954: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
1955: LD_EXP 40
1959: PUSH
1960: LD_INT 0
1962: EQUAL
1963: IFFALSE 2048
1965: GO 1967
1967: DISABLE
// begin JMMReinforcement ;
1968: CALL 4810 0 0
// DialogueOn ;
1972: CALL_OW 6
// CenterOnUnits ( JMM ) ;
1976: LD_EXP 36
1980: PPUSH
1981: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
1985: LD_EXP 36
1989: PPUSH
1990: LD_STRING DJMM-F1
1992: PPUSH
1993: CALL_OW 88
// if RussiansDefeated then
1997: LD_EXP 42
2001: IFFALSE 2017
// Say ( Brighton , DBrighton-F1a ) else
2003: LD_EXP 8
2007: PPUSH
2008: LD_STRING DBrighton-F1a
2010: PPUSH
2011: CALL_OW 88
2015: GO 2036
// begin Say ( Brighton , DBrighton-F1 ) ;
2017: LD_EXP 8
2021: PPUSH
2022: LD_STRING DBrighton-F1
2024: PPUSH
2025: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2029: LD_STRING C3
2031: PPUSH
2032: CALL_OW 337
// end ; DialogueOff ;
2036: CALL_OW 7
// JMM_Arrived := true ;
2040: LD_ADDR_EXP 5
2044: PUSH
2045: LD_INT 1
2047: ST_TO_ADDR
// end ;
2048: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2049: LD_EXP 5
2053: PUSH
2054: LD_INT 1
2056: PPUSH
2057: LD_EXP 18
2061: PPUSH
2062: CALL_OW 292
2066: AND
2067: IFFALSE 2096
2069: GO 2071
2071: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2072: LD_EXP 18
2076: PPUSH
2077: LD_STRING DBurlak
2079: PPUSH
2080: CALL_OW 88
// Say ( JMM , DJMM ) ;
2084: LD_EXP 36
2088: PPUSH
2089: LD_STRING DJMM
2091: PPUSH
2092: CALL_OW 88
// end ;
2096: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2097: LD_INT 1
2099: PUSH
2100: LD_INT 22
2102: PUSH
2103: LD_INT 1
2105: PUSH
2106: EMPTY
2107: LIST
2108: LIST
2109: PUSH
2110: LD_INT 2
2112: PUSH
2113: LD_INT 34
2115: PUSH
2116: LD_INT 9
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: PUSH
2123: LD_INT 35
2125: PUSH
2126: LD_INT 9
2128: PUSH
2129: EMPTY
2130: LIST
2131: LIST
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: LIST
2137: PUSH
2138: EMPTY
2139: LIST
2140: LIST
2141: LIST
2142: PPUSH
2143: CALL_OW 69
2147: PUSH
2148: LD_INT 1
2150: GREATER
2151: IFFALSE 2164
2153: GO 2155
2155: DISABLE
// begin LaserBuilt := true ;
2156: LD_ADDR_EXP 6
2160: PUSH
2161: LD_INT 1
2163: ST_TO_ADDR
// end ;
2164: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2165: LD_EXP 7
2169: PUSH
2170: LD_INT 6
2172: PPUSH
2173: LD_INT 1
2175: PUSH
2176: LD_INT 22
2178: PUSH
2179: LD_INT 1
2181: PUSH
2182: EMPTY
2183: LIST
2184: LIST
2185: PUSH
2186: LD_INT 35
2188: PUSH
2189: LD_INT 9
2191: PUSH
2192: EMPTY
2193: LIST
2194: LIST
2195: PUSH
2196: EMPTY
2197: LIST
2198: LIST
2199: PUSH
2200: EMPTY
2201: LIST
2202: LIST
2203: PPUSH
2204: CALL_OW 69
2208: PPUSH
2209: LD_EXP 15
2213: PPUSH
2214: CALL_OW 310
2218: PPUSH
2219: CALL_OW 74
2223: PPUSH
2224: CALL_OW 292
2228: AND
2229: IFFALSE 2265
2231: GO 2233
2233: DISABLE
// begin wait ( 0 0$5 ) ;
2234: LD_INT 175
2236: PPUSH
2237: CALL_OW 67
// Say ( Sevi , DDeath-Vse-2 ) ;
2241: LD_EXP 15
2245: PPUSH
2246: LD_STRING DDeath-Vse-2
2248: PPUSH
2249: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2253: LD_EXP 12
2257: PPUSH
2258: LD_STRING DDeath-Yas-2
2260: PPUSH
2261: CALL_OW 88
// end ;
2265: END
// every 0 0$1 trigger AssaultStarted do
2266: LD_EXP 7
2270: IFFALSE 2294
2272: GO 2274
2274: DISABLE
// begin wait ( 0 0$20 ) ;
2275: LD_INT 700
2277: PPUSH
2278: CALL_OW 67
// Say ( Popov , DDeath-Pop-2 ) ;
2282: LD_EXP 13
2286: PPUSH
2287: LD_STRING DDeath-Pop-2
2289: PPUSH
2290: CALL_OW 88
// end ;
2294: END
// every 0 0$1 trigger MissionStart do
2295: LD_EXP 1
2299: IFFALSE 2341
2301: GO 2303
2303: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2304: LD_INT 1750
2306: PPUSH
2307: LD_INT 4900
2309: PPUSH
2310: CALL_OW 12
2314: PPUSH
2315: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2319: LD_INT 2
2321: PPUSH
2322: LD_INT 5
2324: PPUSH
2325: CALL_OW 12
2329: PPUSH
2330: LD_INT 12
2332: PPUSH
2333: LD_INT 1
2335: PPUSH
2336: CALL_OW 55
// enable ;
2340: ENABLE
// end ;
2341: END
// every 0 0$1 trigger MissionStart do
2342: LD_EXP 1
2346: IFFALSE 2369
2348: GO 2350
2350: DISABLE
// begin enable ;
2351: ENABLE
// display_Strings := [ #tick , tick ] ;
2352: LD_ADDR_OWVAR 47
2356: PUSH
2357: LD_STRING #tick
2359: PUSH
2360: LD_OWVAR 1
2364: PUSH
2365: EMPTY
2366: LIST
2367: LIST
2368: ST_TO_ADDR
// end ; end_of_file
2369: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2370: LD_INT 0
2372: PPUSH
// uc_side := 1 ;
2373: LD_ADDR_OWVAR 20
2377: PUSH
2378: LD_INT 1
2380: ST_TO_ADDR
// hc_class = class_soldier ;
2381: LD_ADDR_OWVAR 28
2385: PUSH
2386: LD_INT 1
2388: ST_TO_ADDR
// uc_nation := nation_american ;
2389: LD_ADDR_OWVAR 21
2393: PUSH
2394: LD_INT 1
2396: ST_TO_ADDR
// hc_sex = sex_male ;
2397: LD_ADDR_OWVAR 27
2401: PUSH
2402: LD_INT 1
2404: ST_TO_ADDR
// hc_importance = 110 ;
2405: LD_ADDR_OWVAR 32
2409: PUSH
2410: LD_INT 110
2412: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2413: LD_ADDR_OWVAR 30
2417: PUSH
2418: LD_INT 5
2420: PUSH
2421: LD_INT 4
2423: PUSH
2424: LD_INT 5
2426: PUSH
2427: LD_INT 3
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: LIST
2434: LIST
2435: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2436: LD_ADDR_OWVAR 31
2440: PUSH
2441: LD_INT 9
2443: PUSH
2444: LD_INT 6
2446: PUSH
2447: LD_INT 7
2449: PUSH
2450: LD_INT 6
2452: PUSH
2453: EMPTY
2454: LIST
2455: LIST
2456: LIST
2457: LIST
2458: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2459: LD_ADDR_OWVAR 29
2463: PUSH
2464: LD_INT 12
2466: PUSH
2467: LD_INT 10
2469: PUSH
2470: EMPTY
2471: LIST
2472: LIST
2473: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2474: LD_ADDR_OWVAR 26
2478: PUSH
2479: LD_STRING Gerard Brighton
2481: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2482: LD_ADDR_OWVAR 33
2486: PUSH
2487: LD_STRING Beta_Skirmish
2489: ST_TO_ADDR
// hc_face_number := 1 ;
2490: LD_ADDR_OWVAR 34
2494: PUSH
2495: LD_INT 1
2497: ST_TO_ADDR
// Brighton := CreateHuman ;
2498: LD_ADDR_EXP 8
2502: PUSH
2503: CALL_OW 44
2507: ST_TO_ADDR
// uc_nation := nation_american ;
2508: LD_ADDR_OWVAR 21
2512: PUSH
2513: LD_INT 1
2515: ST_TO_ADDR
// hc_importance = 80 ;
2516: LD_ADDR_OWVAR 32
2520: PUSH
2521: LD_INT 80
2523: ST_TO_ADDR
// hc_sex = sex_male ;
2524: LD_ADDR_OWVAR 27
2528: PUSH
2529: LD_INT 1
2531: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2532: LD_ADDR_OWVAR 30
2536: PUSH
2537: LD_INT 5
2539: PUSH
2540: LD_INT 5
2542: PUSH
2543: LD_INT 3
2545: PUSH
2546: LD_INT 1
2548: PUSH
2549: EMPTY
2550: LIST
2551: LIST
2552: LIST
2553: LIST
2554: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2555: LD_ADDR_OWVAR 31
2559: PUSH
2560: LD_INT 7
2562: PUSH
2563: LD_INT 6
2565: PUSH
2566: LD_INT 5
2568: PUSH
2569: LD_INT 3
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: LIST
2576: LIST
2577: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2578: LD_ADDR_OWVAR 29
2582: PUSH
2583: LD_INT 10
2585: PUSH
2586: LD_INT 10
2588: PUSH
2589: EMPTY
2590: LIST
2591: LIST
2592: ST_TO_ADDR
// hc_name := Brian Palmer ;
2593: LD_ADDR_OWVAR 26
2597: PUSH
2598: LD_STRING Brian Palmer
2600: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2601: LD_ADDR_OWVAR 33
2605: PUSH
2606: LD_STRING Beta_Skirmish
2608: ST_TO_ADDR
// hc_face_number := 3 ;
2609: LD_ADDR_OWVAR 34
2613: PUSH
2614: LD_INT 3
2616: ST_TO_ADDR
// Palmer := CreateHuman ;
2617: LD_ADDR_EXP 9
2621: PUSH
2622: CALL_OW 44
2626: ST_TO_ADDR
// hc_class = class_scientistic ;
2627: LD_ADDR_OWVAR 28
2631: PUSH
2632: LD_INT 4
2634: ST_TO_ADDR
// uc_nation := nation_american ;
2635: LD_ADDR_OWVAR 21
2639: PUSH
2640: LD_INT 1
2642: ST_TO_ADDR
// hc_importance = 70 ;
2643: LD_ADDR_OWVAR 32
2647: PUSH
2648: LD_INT 70
2650: ST_TO_ADDR
// hc_sex = sex_female ;
2651: LD_ADDR_OWVAR 27
2655: PUSH
2656: LD_INT 2
2658: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2659: LD_ADDR_OWVAR 30
2663: PUSH
2664: LD_INT 3
2666: PUSH
2667: LD_INT 2
2669: PUSH
2670: LD_INT 4
2672: PUSH
2673: LD_INT 6
2675: PUSH
2676: EMPTY
2677: LIST
2678: LIST
2679: LIST
2680: LIST
2681: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2682: LD_ADDR_OWVAR 31
2686: PUSH
2687: LD_INT 4
2689: PUSH
2690: LD_INT 2
2692: PUSH
2693: LD_INT 5
2695: PUSH
2696: LD_INT 8
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: LIST
2703: LIST
2704: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2705: LD_ADDR_OWVAR 29
2709: PUSH
2710: LD_INT 10
2712: PUSH
2713: LD_INT 10
2715: PUSH
2716: EMPTY
2717: LIST
2718: LIST
2719: ST_TO_ADDR
// hc_name := Megan Armitage ;
2720: LD_ADDR_OWVAR 26
2724: PUSH
2725: LD_STRING Megan Armitage
2727: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2728: LD_ADDR_OWVAR 33
2732: PUSH
2733: LD_STRING Beta_Skirmish
2735: ST_TO_ADDR
// hc_face_number := 4 ;
2736: LD_ADDR_OWVAR 34
2740: PUSH
2741: LD_INT 4
2743: ST_TO_ADDR
// Megan := CreateHuman ;
2744: LD_ADDR_EXP 10
2748: PUSH
2749: CALL_OW 44
2753: ST_TO_ADDR
// end ;
2754: LD_VAR 0 1
2758: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
2759: LD_INT 0
2761: PPUSH
2762: PPUSH
2763: PPUSH
2764: PPUSH
2765: PPUSH
// uc_side := 1 ;
2766: LD_ADDR_OWVAR 20
2770: PUSH
2771: LD_INT 1
2773: ST_TO_ADDR
// uc_nation := nation_american ;
2774: LD_ADDR_OWVAR 21
2778: PUSH
2779: LD_INT 1
2781: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
2782: LD_ADDR_VAR 0 2
2786: PUSH
2787: LD_INT 22
2789: PUSH
2790: LD_INT 1
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: PUSH
2797: LD_INT 30
2799: PUSH
2800: LD_INT 32
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: PUSH
2807: EMPTY
2808: LIST
2809: LIST
2810: PPUSH
2811: CALL_OW 69
2815: PUSH
2816: FOR_IN
2817: IFFALSE 2872
// PlaceWeaponTurret ( i , [ us_machine_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 2
2826: PUSH
2827: LD_INT 3
2829: PUSH
2830: LD_INT 4
2832: PUSH
2833: LD_INT 5
2835: PUSH
2836: LD_INT 11
2838: PUSH
2839: LD_INT 3
2841: PUSH
2842: LD_INT 4
2844: PUSH
2845: EMPTY
2846: LIST
2847: LIST
2848: LIST
2849: LIST
2850: LIST
2851: LIST
2852: LIST
2853: PUSH
2854: LD_INT 1
2856: PPUSH
2857: LD_INT 7
2859: PPUSH
2860: CALL_OW 12
2864: ARRAY
2865: PPUSH
2866: CALL_OW 431
2870: GO 2816
2872: POP
2873: POP
// hc_name :=  ;
2874: LD_ADDR_OWVAR 26
2878: PUSH
2879: LD_STRING 
2881: ST_TO_ADDR
// hc_gallery :=  ;
2882: LD_ADDR_OWVAR 33
2886: PUSH
2887: LD_STRING 
2889: ST_TO_ADDR
// for i = 1 to [ 7 , 6 , 5 ] [ Difficulty ] do
2890: LD_ADDR_VAR 0 2
2894: PUSH
2895: DOUBLE
2896: LD_INT 1
2898: DEC
2899: ST_TO_ADDR
2900: LD_INT 7
2902: PUSH
2903: LD_INT 6
2905: PUSH
2906: LD_INT 5
2908: PUSH
2909: EMPTY
2910: LIST
2911: LIST
2912: LIST
2913: PUSH
2914: LD_OWVAR 67
2918: ARRAY
2919: PUSH
2920: FOR_TO
2921: IFFALSE 2979
// begin PrepareSoldier ( 1 , game_skill ) ;
2923: LD_INT 1
2925: PPUSH
2926: LD_EXP 38
2930: PPUSH
2931: CALL_OW 381
// un := CreateHuman ;
2935: LD_ADDR_VAR 0 4
2939: PUSH
2940: CALL_OW 44
2944: ST_TO_ADDR
// filter := filter ^ un ;
2945: LD_ADDR_VAR 0 3
2949: PUSH
2950: LD_VAR 0 3
2954: PUSH
2955: LD_VAR 0 4
2959: ADD
2960: ST_TO_ADDR
// soldiers := soldiers ^ un ;
2961: LD_ADDR_VAR 0 5
2965: PUSH
2966: LD_VAR 0 5
2970: PUSH
2971: LD_VAR 0 4
2975: ADD
2976: ST_TO_ADDR
// end ;
2977: GO 2920
2979: POP
2980: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
2981: LD_ADDR_VAR 0 2
2985: PUSH
2986: DOUBLE
2987: LD_INT 1
2989: DEC
2990: ST_TO_ADDR
2991: LD_INT 3
2993: PUSH
2994: LD_INT 2
2996: PUSH
2997: LD_INT 2
2999: PUSH
3000: EMPTY
3001: LIST
3002: LIST
3003: LIST
3004: PUSH
3005: LD_OWVAR 67
3009: ARRAY
3010: PUSH
3011: FOR_TO
3012: IFFALSE 3066
// begin PrepareEngineer ( 0 , game_skill ) ;
3014: LD_INT 0
3016: PPUSH
3017: LD_EXP 38
3021: PPUSH
3022: CALL_OW 382
// un := CreateHuman ;
3026: LD_ADDR_VAR 0 4
3030: PUSH
3031: CALL_OW 44
3035: ST_TO_ADDR
// filter := filter ^ un ;
3036: LD_ADDR_VAR 0 3
3040: PUSH
3041: LD_VAR 0 3
3045: PUSH
3046: LD_VAR 0 4
3050: ADD
3051: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3052: LD_VAR 0 4
3056: PPUSH
3057: LD_INT 3
3059: PPUSH
3060: CALL_OW 52
// end ;
3064: GO 3011
3066: POP
3067: POP
// for i = 1 to [ 4 , 4 , 3 ] [ Difficulty ] do
3068: LD_ADDR_VAR 0 2
3072: PUSH
3073: DOUBLE
3074: LD_INT 1
3076: DEC
3077: ST_TO_ADDR
3078: LD_INT 4
3080: PUSH
3081: LD_INT 4
3083: PUSH
3084: LD_INT 3
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: LIST
3091: PUSH
3092: LD_OWVAR 67
3096: ARRAY
3097: PUSH
3098: FOR_TO
3099: IFFALSE 3153
// begin PrepareMechanic ( 0 , game_skill ) ;
3101: LD_INT 0
3103: PPUSH
3104: LD_EXP 38
3108: PPUSH
3109: CALL_OW 383
// un := CreateHuman ;
3113: LD_ADDR_VAR 0 4
3117: PUSH
3118: CALL_OW 44
3122: ST_TO_ADDR
// filter := filter ^ un ;
3123: LD_ADDR_VAR 0 3
3127: PUSH
3128: LD_VAR 0 3
3132: PUSH
3133: LD_VAR 0 4
3137: ADD
3138: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3139: LD_VAR 0 4
3143: PPUSH
3144: LD_INT 8
3146: PPUSH
3147: CALL_OW 52
// end ;
3151: GO 3098
3153: POP
3154: POP
// for i = 1 to 3 do
3155: LD_ADDR_VAR 0 2
3159: PUSH
3160: DOUBLE
3161: LD_INT 1
3163: DEC
3164: ST_TO_ADDR
3165: LD_INT 3
3167: PUSH
3168: FOR_TO
3169: IFFALSE 3223
// begin PrepareScientist ( 0 , game_skill ) ;
3171: LD_INT 0
3173: PPUSH
3174: LD_EXP 38
3178: PPUSH
3179: CALL_OW 384
// un := CreateHuman ;
3183: LD_ADDR_VAR 0 4
3187: PUSH
3188: CALL_OW 44
3192: ST_TO_ADDR
// filter := filter ^ un ;
3193: LD_ADDR_VAR 0 3
3197: PUSH
3198: LD_VAR 0 3
3202: PUSH
3203: LD_VAR 0 4
3207: ADD
3208: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3209: LD_VAR 0 4
3213: PPUSH
3214: LD_INT 14
3216: PPUSH
3217: CALL_OW 52
// end ;
3221: GO 3168
3223: POP
3224: POP
// for i = 1 to soldiers do
3225: LD_ADDR_VAR 0 2
3229: PUSH
3230: DOUBLE
3231: LD_INT 1
3233: DEC
3234: ST_TO_ADDR
3235: LD_VAR 0 5
3239: PUSH
3240: FOR_TO
3241: IFFALSE 3266
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3243: LD_VAR 0 5
3247: PUSH
3248: LD_VAR 0 2
3252: ARRAY
3253: PPUSH
3254: LD_INT 1
3256: PPUSH
3257: LD_INT 0
3259: PPUSH
3260: CALL_OW 49
3264: GO 3240
3266: POP
3267: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3268: LD_EXP 8
3272: PPUSH
3273: LD_INT 51
3275: PPUSH
3276: LD_INT 43
3278: PPUSH
3279: LD_INT 0
3281: PPUSH
3282: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3286: LD_EXP 9
3290: PPUSH
3291: LD_INT 55
3293: PPUSH
3294: LD_INT 58
3296: PPUSH
3297: LD_INT 0
3299: PPUSH
3300: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3304: LD_EXP 10
3308: PPUSH
3309: LD_INT 39
3311: PPUSH
3312: LD_INT 36
3314: PPUSH
3315: LD_INT 0
3317: PPUSH
3318: CALL_OW 48
// BetaSquad := filter diff 0 ;
3322: LD_ADDR_EXP 11
3326: PUSH
3327: LD_VAR 0 3
3331: PUSH
3332: LD_INT 0
3334: DIFF
3335: ST_TO_ADDR
// end ;
3336: LD_VAR 0 1
3340: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3341: LD_INT 0
3343: PPUSH
3344: PPUSH
3345: PPUSH
3346: PPUSH
3347: PPUSH
3348: PPUSH
// uc_side := 6 ;
3349: LD_ADDR_OWVAR 20
3353: PUSH
3354: LD_INT 6
3356: ST_TO_ADDR
// uc_nation := nation_russian ;
3357: LD_ADDR_OWVAR 21
3361: PUSH
3362: LD_INT 3
3364: ST_TO_ADDR
// soldiers := [ ] ;
3365: LD_ADDR_VAR 0 4
3369: PUSH
3370: EMPTY
3371: ST_TO_ADDR
// vehs := [ ] ;
3372: LD_ADDR_VAR 0 6
3376: PUSH
3377: EMPTY
3378: ST_TO_ADDR
// RUArmada := [ ] ;
3379: LD_ADDR_EXP 16
3383: PUSH
3384: EMPTY
3385: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3386: LD_ADDR_EXP 12
3390: PUSH
3391: LD_STRING Yashin
3393: PPUSH
3394: CALL_OW 25
3398: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3399: LD_ADDR_EXP 13
3403: PUSH
3404: LD_STRING Popov
3406: PPUSH
3407: CALL_OW 25
3411: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3412: LD_ADDR_EXP 14
3416: PUSH
3417: LD_STRING Gaydar
3419: PPUSH
3420: CALL_OW 25
3424: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3425: LD_ADDR_EXP 15
3429: PUSH
3430: LD_STRING Vsevolod
3432: PPUSH
3433: CALL_OW 25
3437: ST_TO_ADDR
// for i = 1 to 16 do
3438: LD_ADDR_VAR 0 2
3442: PUSH
3443: DOUBLE
3444: LD_INT 1
3446: DEC
3447: ST_TO_ADDR
3448: LD_INT 16
3450: PUSH
3451: FOR_TO
3452: IFFALSE 3494
// begin PrepareSoldier ( 0 , game_eskill ) ;
3454: LD_INT 0
3456: PPUSH
3457: LD_EXP 39
3461: PPUSH
3462: CALL_OW 381
// un := CreateHuman ;
3466: LD_ADDR_VAR 0 5
3470: PUSH
3471: CALL_OW 44
3475: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3476: LD_ADDR_VAR 0 4
3480: PUSH
3481: LD_VAR 0 4
3485: PUSH
3486: LD_VAR 0 5
3490: ADD
3491: ST_TO_ADDR
// end ;
3492: GO 3451
3494: POP
3495: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3496: LD_ADDR_VAR 0 4
3500: PUSH
3501: LD_EXP 12
3505: PUSH
3506: LD_EXP 13
3510: ADD
3511: PUSH
3512: LD_EXP 14
3516: ADD
3517: PUSH
3518: LD_EXP 15
3522: ADD
3523: PUSH
3524: LD_VAR 0 4
3528: ADD
3529: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3530: LD_INT 24
3532: PPUSH
3533: LD_INT 3
3535: PPUSH
3536: LD_INT 1
3538: PPUSH
3539: LD_INT 46
3541: PPUSH
3542: LD_INT 100
3544: PPUSH
3545: CALL 17694 0 5
// for i = 1 to 8 do
3549: LD_ADDR_VAR 0 2
3553: PUSH
3554: DOUBLE
3555: LD_INT 1
3557: DEC
3558: ST_TO_ADDR
3559: LD_INT 8
3561: PUSH
3562: FOR_TO
3563: IFFALSE 3646
// begin vehicle := CreateVehicle ;
3565: LD_ADDR_VAR 0 3
3569: PUSH
3570: CALL_OW 45
3574: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3575: LD_VAR 0 4
3579: PUSH
3580: LD_INT 1
3582: ARRAY
3583: PPUSH
3584: LD_VAR 0 3
3588: PPUSH
3589: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3593: LD_ADDR_VAR 0 4
3597: PUSH
3598: LD_VAR 0 4
3602: PUSH
3603: LD_VAR 0 4
3607: PUSH
3608: LD_INT 1
3610: ARRAY
3611: DIFF
3612: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3613: LD_VAR 0 3
3617: PPUSH
3618: LD_INT 5
3620: PPUSH
3621: LD_INT 0
3623: PPUSH
3624: CALL_OW 49
// vehs := vehs ^ vehicle ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_VAR 0 6
3637: PUSH
3638: LD_VAR 0 3
3642: ADD
3643: ST_TO_ADDR
// end ;
3644: GO 3562
3646: POP
3647: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3648: LD_INT 24
3650: PPUSH
3651: LD_INT 3
3653: PPUSH
3654: LD_INT 1
3656: PPUSH
3657: LD_INT 43
3659: PPUSH
3660: LD_INT 100
3662: PPUSH
3663: CALL 17694 0 5
// for i = 1 to 8 do
3667: LD_ADDR_VAR 0 2
3671: PUSH
3672: DOUBLE
3673: LD_INT 1
3675: DEC
3676: ST_TO_ADDR
3677: LD_INT 8
3679: PUSH
3680: FOR_TO
3681: IFFALSE 3764
// begin vehicle := CreateVehicle ;
3683: LD_ADDR_VAR 0 3
3687: PUSH
3688: CALL_OW 45
3692: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3693: LD_VAR 0 4
3697: PUSH
3698: LD_INT 1
3700: ARRAY
3701: PPUSH
3702: LD_VAR 0 3
3706: PPUSH
3707: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3711: LD_ADDR_VAR 0 4
3715: PUSH
3716: LD_VAR 0 4
3720: PUSH
3721: LD_VAR 0 4
3725: PUSH
3726: LD_INT 1
3728: ARRAY
3729: DIFF
3730: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3731: LD_VAR 0 3
3735: PPUSH
3736: LD_INT 5
3738: PPUSH
3739: LD_INT 0
3741: PPUSH
3742: CALL_OW 49
// vehs := vehs ^ vehicle ;
3746: LD_ADDR_VAR 0 6
3750: PUSH
3751: LD_VAR 0 6
3755: PUSH
3756: LD_VAR 0 3
3760: ADD
3761: ST_TO_ADDR
// end ;
3762: GO 3680
3764: POP
3765: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
3766: LD_INT 22
3768: PPUSH
3769: LD_INT 3
3771: PPUSH
3772: LD_INT 1
3774: PPUSH
3775: LD_INT 44
3777: PPUSH
3778: LD_INT 100
3780: PPUSH
3781: CALL 17694 0 5
// for i = 1 to 4 do
3785: LD_ADDR_VAR 0 2
3789: PUSH
3790: DOUBLE
3791: LD_INT 1
3793: DEC
3794: ST_TO_ADDR
3795: LD_INT 4
3797: PUSH
3798: FOR_TO
3799: IFFALSE 3882
// begin vehicle := CreateVehicle ;
3801: LD_ADDR_VAR 0 3
3805: PUSH
3806: CALL_OW 45
3810: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3811: LD_VAR 0 4
3815: PUSH
3816: LD_INT 1
3818: ARRAY
3819: PPUSH
3820: LD_VAR 0 3
3824: PPUSH
3825: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3829: LD_ADDR_VAR 0 4
3833: PUSH
3834: LD_VAR 0 4
3838: PUSH
3839: LD_VAR 0 4
3843: PUSH
3844: LD_INT 1
3846: ARRAY
3847: DIFF
3848: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3849: LD_VAR 0 3
3853: PPUSH
3854: LD_INT 5
3856: PPUSH
3857: LD_INT 0
3859: PPUSH
3860: CALL_OW 49
// vehs := vehs ^ vehicle ;
3864: LD_ADDR_VAR 0 6
3868: PUSH
3869: LD_VAR 0 6
3873: PUSH
3874: LD_VAR 0 3
3878: ADD
3879: ST_TO_ADDR
// end ;
3880: GO 3798
3882: POP
3883: POP
// RUArmada := vehs ;
3884: LD_ADDR_EXP 16
3888: PUSH
3889: LD_VAR 0 6
3893: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
3894: LD_EXP 12
3898: PPUSH
3899: CALL_OW 310
3903: PUSH
3904: LD_EXP 13
3908: PPUSH
3909: CALL_OW 310
3913: PUSH
3914: LD_EXP 14
3918: PPUSH
3919: CALL_OW 310
3923: PUSH
3924: LD_EXP 15
3928: PPUSH
3929: CALL_OW 310
3933: PUSH
3934: EMPTY
3935: LIST
3936: LIST
3937: LIST
3938: LIST
3939: PPUSH
3940: LD_INT 6
3942: NEG
3943: PPUSH
3944: CALL_OW 242
// end ;
3948: LD_VAR 0 1
3952: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
3953: LD_INT 0
3955: PPUSH
3956: PPUSH
3957: PPUSH
// uc_side := 6 ;
3958: LD_ADDR_OWVAR 20
3962: PUSH
3963: LD_INT 6
3965: ST_TO_ADDR
// uc_nation := nation_russian ;
3966: LD_ADDR_OWVAR 21
3970: PUSH
3971: LD_INT 3
3973: ST_TO_ADDR
// Bulldozers := [ ] ;
3974: LD_ADDR_EXP 17
3978: PUSH
3979: EMPTY
3980: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
3981: LD_INT 24
3983: PPUSH
3984: LD_INT 3
3986: PPUSH
3987: LD_INT 3
3989: PPUSH
3990: LD_INT 53
3992: PPUSH
3993: LD_INT 100
3995: PPUSH
3996: CALL 17694 0 5
// for i = 1 to 2 do
4000: LD_ADDR_VAR 0 2
4004: PUSH
4005: DOUBLE
4006: LD_INT 1
4008: DEC
4009: ST_TO_ADDR
4010: LD_INT 2
4012: PUSH
4013: FOR_TO
4014: IFFALSE 4059
// begin vehicle := CreateVehicle ;
4016: LD_ADDR_VAR 0 3
4020: PUSH
4021: CALL_OW 45
4025: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4026: LD_VAR 0 3
4030: PPUSH
4031: LD_INT 5
4033: PPUSH
4034: LD_INT 0
4036: PPUSH
4037: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4041: LD_ADDR_EXP 17
4045: PUSH
4046: LD_EXP 17
4050: PUSH
4051: LD_VAR 0 3
4055: ADD
4056: ST_TO_ADDR
// end ;
4057: GO 4013
4059: POP
4060: POP
// end ;
4061: LD_VAR 0 1
4065: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4066: LD_INT 0
4068: PPUSH
4069: PPUSH
4070: PPUSH
4071: PPUSH
// uc_side := 3 ;
4072: LD_ADDR_OWVAR 20
4076: PUSH
4077: LD_INT 3
4079: ST_TO_ADDR
// uc_nation := nation_russian ;
4080: LD_ADDR_OWVAR 21
4084: PUSH
4085: LD_INT 3
4087: ST_TO_ADDR
// hc_name :=  ;
4088: LD_ADDR_OWVAR 26
4092: PUSH
4093: LD_STRING 
4095: ST_TO_ADDR
// hc_gallery :=  ;
4096: LD_ADDR_OWVAR 33
4100: PUSH
4101: LD_STRING 
4103: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4104: LD_ADDR_EXP 18
4108: PUSH
4109: LD_STRING Burlak
4111: PPUSH
4112: CALL_OW 25
4116: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4117: LD_ADDR_EXP 19
4121: PUSH
4122: LD_STRING Gleb
4124: PPUSH
4125: CALL_OW 25
4129: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4130: LD_ADDR_EXP 20
4134: PUSH
4135: LD_STRING Furmanov
4137: PPUSH
4138: CALL_OW 25
4142: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4143: LD_ADDR_EXP 21
4147: PUSH
4148: LD_STRING Titov
4150: PPUSH
4151: CALL_OW 25
4155: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4156: LD_ADDR_EXP 22
4160: PUSH
4161: LD_STRING Scholtze
4163: PPUSH
4164: CALL_OW 25
4168: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4169: LD_ADDR_EXP 23
4173: PUSH
4174: LD_STRING Dolgov
4176: PPUSH
4177: CALL_OW 25
4181: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4182: LD_ADDR_EXP 24
4186: PUSH
4187: LD_STRING Kapitsova
4189: PPUSH
4190: CALL_OW 25
4194: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4195: LD_ADDR_EXP 25
4199: PUSH
4200: LD_STRING Karamazov
4202: PPUSH
4203: CALL_OW 25
4207: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4208: LD_ADDR_EXP 26
4212: PUSH
4213: LD_STRING Kirlenkova
4215: PPUSH
4216: CALL_OW 25
4220: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4221: LD_ADDR_EXP 27
4225: PUSH
4226: LD_STRING Kovalyuk
4228: PPUSH
4229: CALL_OW 25
4233: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4234: LD_ADDR_EXP 28
4238: PUSH
4239: LD_STRING Kozlov
4241: PPUSH
4242: CALL_OW 25
4246: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4247: LD_ADDR_EXP 29
4251: PUSH
4252: LD_STRING Kuzmov
4254: PPUSH
4255: CALL_OW 25
4259: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4260: LD_ADDR_EXP 30
4264: PUSH
4265: LD_STRING Lipshchin
4267: PPUSH
4268: CALL_OW 25
4272: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4273: LD_ADDR_EXP 31
4277: PUSH
4278: LD_STRING Oblukov
4280: PPUSH
4281: CALL_OW 25
4285: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4286: LD_ADDR_EXP 32
4290: PUSH
4291: LD_STRING Xavier2
4293: PPUSH
4294: CALL_OW 25
4298: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4299: LD_ADDR_EXP 33
4303: PUSH
4304: LD_STRING Gnyevko
4306: PPUSH
4307: CALL_OW 25
4311: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4312: LD_ADDR_EXP 34
4316: PUSH
4317: LD_STRING Belkov
4319: PPUSH
4320: CALL_OW 25
4324: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4325: LD_ADDR_VAR 0 3
4329: PUSH
4330: LD_EXP 18
4334: PUSH
4335: LD_EXP 19
4339: PUSH
4340: LD_EXP 20
4344: PUSH
4345: LD_EXP 21
4349: PUSH
4350: LD_EXP 22
4354: PUSH
4355: LD_EXP 23
4359: PUSH
4360: LD_EXP 24
4364: PUSH
4365: LD_EXP 25
4369: PUSH
4370: LD_EXP 26
4374: PUSH
4375: LD_EXP 27
4379: PUSH
4380: LD_EXP 28
4384: PUSH
4385: LD_EXP 29
4389: PUSH
4390: LD_EXP 30
4394: PUSH
4395: LD_EXP 31
4399: PUSH
4400: LD_EXP 32
4404: PUSH
4405: LD_EXP 33
4409: PUSH
4410: LD_EXP 34
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: LIST
4424: LIST
4425: LIST
4426: LIST
4427: LIST
4428: LIST
4429: LIST
4430: LIST
4431: LIST
4432: LIST
4433: ST_TO_ADDR
// for i = 1 to filter do
4434: LD_ADDR_VAR 0 2
4438: PUSH
4439: DOUBLE
4440: LD_INT 1
4442: DEC
4443: ST_TO_ADDR
4444: LD_VAR 0 3
4448: PUSH
4449: FOR_TO
4450: IFFALSE 4475
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4452: LD_VAR 0 3
4456: PUSH
4457: LD_VAR 0 2
4461: ARRAY
4462: PPUSH
4463: LD_INT 6
4465: PPUSH
4466: LD_INT 0
4468: PPUSH
4469: CALL_OW 49
4473: GO 4449
4475: POP
4476: POP
// end ;
4477: LD_VAR 0 1
4481: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4482: LD_INT 0
4484: PPUSH
4485: PPUSH
4486: PPUSH
4487: PPUSH
// uc_side := 3 ;
4488: LD_ADDR_OWVAR 20
4492: PUSH
4493: LD_INT 3
4495: ST_TO_ADDR
// uc_nation := nation_russian ;
4496: LD_ADDR_OWVAR 21
4500: PUSH
4501: LD_INT 3
4503: ST_TO_ADDR
// hc_name :=  ;
4504: LD_ADDR_OWVAR 26
4508: PUSH
4509: LD_STRING 
4511: ST_TO_ADDR
// hc_gallery :=  ;
4512: LD_ADDR_OWVAR 33
4516: PUSH
4517: LD_STRING 
4519: ST_TO_ADDR
// for i = 1 to 8 do
4520: LD_ADDR_VAR 0 2
4524: PUSH
4525: DOUBLE
4526: LD_INT 1
4528: DEC
4529: ST_TO_ADDR
4530: LD_INT 8
4532: PUSH
4533: FOR_TO
4534: IFFALSE 4576
// begin PrepareSoldier ( 0 , game_eskill ) ;
4536: LD_INT 0
4538: PPUSH
4539: LD_EXP 39
4543: PPUSH
4544: CALL_OW 381
// un := CreateHuman ;
4548: LD_ADDR_VAR 0 4
4552: PUSH
4553: CALL_OW 44
4557: ST_TO_ADDR
// filter := filter ^ un ;
4558: LD_ADDR_VAR 0 3
4562: PUSH
4563: LD_VAR 0 3
4567: PUSH
4568: LD_VAR 0 4
4572: ADD
4573: ST_TO_ADDR
// end ;
4574: GO 4533
4576: POP
4577: POP
// for i = 1 to 4 do
4578: LD_ADDR_VAR 0 2
4582: PUSH
4583: DOUBLE
4584: LD_INT 1
4586: DEC
4587: ST_TO_ADDR
4588: LD_INT 4
4590: PUSH
4591: FOR_TO
4592: IFFALSE 4634
// begin PrepareEngineer ( 0 , game_eskill ) ;
4594: LD_INT 0
4596: PPUSH
4597: LD_EXP 39
4601: PPUSH
4602: CALL_OW 382
// un := CreateHuman ;
4606: LD_ADDR_VAR 0 4
4610: PUSH
4611: CALL_OW 44
4615: ST_TO_ADDR
// filter := filter ^ un ;
4616: LD_ADDR_VAR 0 3
4620: PUSH
4621: LD_VAR 0 3
4625: PUSH
4626: LD_VAR 0 4
4630: ADD
4631: ST_TO_ADDR
// end ;
4632: GO 4591
4634: POP
4635: POP
// for i = 1 to 6 do
4636: LD_ADDR_VAR 0 2
4640: PUSH
4641: DOUBLE
4642: LD_INT 1
4644: DEC
4645: ST_TO_ADDR
4646: LD_INT 6
4648: PUSH
4649: FOR_TO
4650: IFFALSE 4692
// begin PrepareMechanic ( 0 , game_eskill ) ;
4652: LD_INT 0
4654: PPUSH
4655: LD_EXP 39
4659: PPUSH
4660: CALL_OW 383
// un := CreateHuman ;
4664: LD_ADDR_VAR 0 4
4668: PUSH
4669: CALL_OW 44
4673: ST_TO_ADDR
// filter := filter ^ un ;
4674: LD_ADDR_VAR 0 3
4678: PUSH
4679: LD_VAR 0 3
4683: PUSH
4684: LD_VAR 0 4
4688: ADD
4689: ST_TO_ADDR
// end ;
4690: GO 4649
4692: POP
4693: POP
// for i = 1 to 4 do
4694: LD_ADDR_VAR 0 2
4698: PUSH
4699: DOUBLE
4700: LD_INT 1
4702: DEC
4703: ST_TO_ADDR
4704: LD_INT 4
4706: PUSH
4707: FOR_TO
4708: IFFALSE 4750
// begin PrepareScientist ( 0 , game_eskill ) ;
4710: LD_INT 0
4712: PPUSH
4713: LD_EXP 39
4717: PPUSH
4718: CALL_OW 384
// un := CreateHuman ;
4722: LD_ADDR_VAR 0 4
4726: PUSH
4727: CALL_OW 44
4731: ST_TO_ADDR
// filter := filter ^ un ;
4732: LD_ADDR_VAR 0 3
4736: PUSH
4737: LD_VAR 0 3
4741: PUSH
4742: LD_VAR 0 4
4746: ADD
4747: ST_TO_ADDR
// end ;
4748: GO 4707
4750: POP
4751: POP
// for i = 1 to filter do
4752: LD_ADDR_VAR 0 2
4756: PUSH
4757: DOUBLE
4758: LD_INT 1
4760: DEC
4761: ST_TO_ADDR
4762: LD_VAR 0 3
4766: PUSH
4767: FOR_TO
4768: IFFALSE 4793
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4770: LD_VAR 0 3
4774: PUSH
4775: LD_VAR 0 2
4779: ARRAY
4780: PPUSH
4781: LD_INT 6
4783: PPUSH
4784: LD_INT 0
4786: PPUSH
4787: CALL_OW 49
4791: GO 4767
4793: POP
4794: POP
// RU_SecondPersonnel := filter ;
4795: LD_ADDR_EXP 35
4799: PUSH
4800: LD_VAR 0 3
4804: ST_TO_ADDR
// end ;
4805: LD_VAR 0 1
4809: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
4810: LD_INT 0
4812: PPUSH
4813: PPUSH
4814: PPUSH
4815: PPUSH
4816: PPUSH
4817: PPUSH
4818: PPUSH
// uc_side := 1 ;
4819: LD_ADDR_OWVAR 20
4823: PUSH
4824: LD_INT 1
4826: ST_TO_ADDR
// uc_nation := nation_american ;
4827: LD_ADDR_OWVAR 21
4831: PUSH
4832: LD_INT 1
4834: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
4835: LD_ADDR_EXP 36
4839: PUSH
4840: LD_STRING JMM
4842: PPUSH
4843: CALL_OW 25
4847: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
4848: LD_EXP 36
4852: PPUSH
4853: LD_INT 1
4855: PPUSH
4856: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
4860: LD_EXP 36
4864: PPUSH
4865: LD_INT 7
4867: PPUSH
4868: LD_INT 0
4870: PPUSH
4871: CALL_OW 49
// mechs := [ ] ;
4875: LD_ADDR_VAR 0 7
4879: PUSH
4880: EMPTY
4881: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
4882: LD_ADDR_VAR 0 2
4886: PUSH
4887: DOUBLE
4888: LD_INT 1
4890: DEC
4891: ST_TO_ADDR
4892: LD_INT 4
4894: PUSH
4895: LD_INT 3
4897: PUSH
4898: LD_INT 3
4900: PUSH
4901: EMPTY
4902: LIST
4903: LIST
4904: LIST
4905: PUSH
4906: LD_OWVAR 67
4910: ARRAY
4911: PUSH
4912: FOR_TO
4913: IFFALSE 4974
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
4915: LD_INT 0
4917: PPUSH
4918: LD_EXP 38
4922: PUSH
4923: LD_INT 1
4925: PLUS
4926: PPUSH
4927: CALL_OW 381
// un := CreateHuman ;
4931: LD_ADDR_VAR 0 4
4935: PUSH
4936: CALL_OW 44
4940: ST_TO_ADDR
// soldiers := soldiers ^ un ;
4941: LD_ADDR_VAR 0 3
4945: PUSH
4946: LD_VAR 0 3
4950: PUSH
4951: LD_VAR 0 4
4955: ADD
4956: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
4957: LD_VAR 0 4
4961: PPUSH
4962: LD_INT 7
4964: PPUSH
4965: LD_INT 0
4967: PPUSH
4968: CALL_OW 49
// end ;
4972: GO 4912
4974: POP
4975: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
4976: LD_ADDR_VAR 0 2
4980: PUSH
4981: DOUBLE
4982: LD_INT 1
4984: DEC
4985: ST_TO_ADDR
4986: LD_INT 7
4988: PUSH
4989: LD_INT 6
4991: PUSH
4992: LD_INT 4
4994: PUSH
4995: EMPTY
4996: LIST
4997: LIST
4998: LIST
4999: PUSH
5000: LD_OWVAR 67
5004: ARRAY
5005: PUSH
5006: FOR_TO
5007: IFFALSE 5053
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5009: LD_INT 0
5011: PPUSH
5012: LD_EXP 38
5016: PUSH
5017: LD_INT 1
5019: PLUS
5020: PPUSH
5021: CALL_OW 383
// un := CreateHuman ;
5025: LD_ADDR_VAR 0 4
5029: PUSH
5030: CALL_OW 44
5034: ST_TO_ADDR
// mechs := mechs ^ un ;
5035: LD_ADDR_VAR 0 7
5039: PUSH
5040: LD_VAR 0 7
5044: PUSH
5045: LD_VAR 0 4
5049: ADD
5050: ST_TO_ADDR
// end ;
5051: GO 5006
5053: POP
5054: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5055: LD_INT 3
5057: PPUSH
5058: LD_INT 3
5060: PPUSH
5061: LD_INT 1
5063: PPUSH
5064: LD_INT 5
5066: PPUSH
5067: LD_INT 100
5069: PPUSH
5070: CALL 17694 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5074: LD_ADDR_VAR 0 2
5078: PUSH
5079: DOUBLE
5080: LD_INT 1
5082: DEC
5083: ST_TO_ADDR
5084: LD_INT 7
5086: PUSH
5087: LD_INT 6
5089: PUSH
5090: LD_INT 4
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: LIST
5097: PUSH
5098: LD_OWVAR 67
5102: ARRAY
5103: PUSH
5104: FOR_TO
5105: IFFALSE 5200
// begin vehicle := CreateVehicle ;
5107: LD_ADDR_VAR 0 6
5111: PUSH
5112: CALL_OW 45
5116: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5117: LD_VAR 0 7
5121: PUSH
5122: LD_INT 1
5124: ARRAY
5125: PPUSH
5126: LD_VAR 0 6
5130: PPUSH
5131: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5135: LD_ADDR_VAR 0 7
5139: PUSH
5140: LD_VAR 0 7
5144: PUSH
5145: LD_VAR 0 7
5149: PUSH
5150: LD_INT 1
5152: ARRAY
5153: DIFF
5154: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5155: LD_VAR 0 6
5159: PPUSH
5160: LD_INT 1
5162: PPUSH
5163: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5167: LD_VAR 0 6
5171: PPUSH
5172: LD_INT 7
5174: PPUSH
5175: LD_INT 0
5177: PPUSH
5178: CALL_OW 49
// vehs := vehs ^ vehicle ;
5182: LD_ADDR_VAR 0 5
5186: PUSH
5187: LD_VAR 0 5
5191: PUSH
5192: LD_VAR 0 6
5196: ADD
5197: ST_TO_ADDR
// end ;
5198: GO 5104
5200: POP
5201: POP
// end ; end_of_file
5202: LD_VAR 0 1
5206: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export function GameType ; begin
5207: LD_INT 0
5209: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5210: LD_ADDR_OWVAR 67
5214: PUSH
5215: LD_INT 0
5217: PPUSH
5218: CALL_OW 426
5222: ST_TO_ADDR
// game_diff := Difficulty ;
5223: LD_ADDR_EXP 37
5227: PUSH
5228: LD_OWVAR 67
5232: ST_TO_ADDR
// game_skill := [ 7 , 6 , 6 ] [ game_diff ] ;
5233: LD_ADDR_EXP 38
5237: PUSH
5238: LD_INT 7
5240: PUSH
5241: LD_INT 6
5243: PUSH
5244: LD_INT 6
5246: PUSH
5247: EMPTY
5248: LIST
5249: LIST
5250: LIST
5251: PUSH
5252: LD_EXP 37
5256: ARRAY
5257: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5258: LD_ADDR_EXP 39
5262: PUSH
5263: LD_INT 6
5265: PUSH
5266: LD_INT 7
5268: PUSH
5269: LD_INT 8
5271: PUSH
5272: EMPTY
5273: LIST
5274: LIST
5275: LIST
5276: PUSH
5277: LD_EXP 37
5281: ARRAY
5282: ST_TO_ADDR
// ruArrival := [ 3 3$00 , 2 2$30 , 2 2$00 ] [ game_diff ] ;
5283: LD_ADDR_EXP 41
5287: PUSH
5288: LD_INT 6300
5290: PUSH
5291: LD_INT 5250
5293: PUSH
5294: LD_INT 4200
5296: PUSH
5297: EMPTY
5298: LIST
5299: LIST
5300: LIST
5301: PUSH
5302: LD_EXP 37
5306: ARRAY
5307: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5308: LD_ADDR_EXP 40
5312: PUSH
5313: LD_INT 73500
5315: PUSH
5316: LD_INT 94500
5318: PUSH
5319: LD_INT 115500
5321: PUSH
5322: EMPTY
5323: LIST
5324: LIST
5325: LIST
5326: PUSH
5327: LD_EXP 37
5331: ARRAY
5332: ST_TO_ADDR
// end ; end_of_file
5333: LD_VAR 0 1
5337: RET
// export function CustomEvent ( event ) ; begin
5338: LD_INT 0
5340: PPUSH
// end ;
5341: LD_VAR 0 2
5345: RET
// export function CustomInitMacro ( ) ; begin
5346: LD_INT 0
5348: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5349: LD_INT 1
5351: PPUSH
5352: LD_INT 3
5354: PPUSH
5355: CALL 78131 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5359: LD_INT 1
5361: PPUSH
5362: LD_INT 4
5364: PPUSH
5365: CALL 78075 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5369: LD_INT 1
5371: PPUSH
5372: LD_INT 136
5374: PUSH
5375: LD_INT 130
5377: PUSH
5378: LD_INT 0
5380: PUSH
5381: EMPTY
5382: LIST
5383: LIST
5384: LIST
5385: PUSH
5386: LD_INT 145
5388: PUSH
5389: LD_INT 123
5391: PUSH
5392: LD_INT 0
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: LIST
5399: PUSH
5400: EMPTY
5401: LIST
5402: LIST
5403: PPUSH
5404: CALL 77197 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5408: LD_INT 1
5410: PPUSH
5411: LD_INT 43
5413: PUSH
5414: LD_INT 46
5416: PUSH
5417: LD_INT 45
5419: PUSH
5420: EMPTY
5421: LIST
5422: LIST
5423: LIST
5424: PPUSH
5425: CALL 77963 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5429: LD_INT 1
5431: PPUSH
5432: LD_INT 3
5434: PPUSH
5435: CALL 77645 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5439: LD_INT 1
5441: PPUSH
5442: LD_INT 3
5444: PPUSH
5445: CALL 77376 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5449: LD_INT 1
5451: PPUSH
5452: LD_INT 8
5454: PPUSH
5455: CALL 77058 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5459: LD_INT 1
5461: PPUSH
5462: LD_INT 22
5464: PUSH
5465: LD_INT 1
5467: PUSH
5468: LD_INT 3
5470: PUSH
5471: LD_INT 43
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 22
5482: PUSH
5483: LD_INT 1
5485: PUSH
5486: LD_INT 3
5488: PUSH
5489: LD_INT 44
5491: PUSH
5492: EMPTY
5493: LIST
5494: LIST
5495: LIST
5496: LIST
5497: PUSH
5498: LD_INT 22
5500: PUSH
5501: LD_INT 1
5503: PUSH
5504: LD_INT 3
5506: PUSH
5507: LD_INT 45
5509: PUSH
5510: EMPTY
5511: LIST
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_INT 24
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: LD_INT 3
5524: PUSH
5525: LD_INT 43
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: LIST
5532: LIST
5533: PUSH
5534: LD_INT 24
5536: PUSH
5537: LD_INT 1
5539: PUSH
5540: LD_INT 3
5542: PUSH
5543: LD_INT 43
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: LIST
5550: LIST
5551: PUSH
5552: LD_INT 24
5554: PUSH
5555: LD_INT 1
5557: PUSH
5558: LD_INT 3
5560: PUSH
5561: LD_INT 46
5563: PUSH
5564: EMPTY
5565: LIST
5566: LIST
5567: LIST
5568: LIST
5569: PUSH
5570: LD_INT 22
5572: PUSH
5573: LD_INT 1
5575: PUSH
5576: LD_INT 3
5578: PUSH
5579: LD_INT 43
5581: PUSH
5582: EMPTY
5583: LIST
5584: LIST
5585: LIST
5586: LIST
5587: PUSH
5588: LD_INT 22
5590: PUSH
5591: LD_INT 1
5593: PUSH
5594: LD_INT 3
5596: PUSH
5597: LD_INT 44
5599: PUSH
5600: EMPTY
5601: LIST
5602: LIST
5603: LIST
5604: LIST
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: PPUSH
5616: CALL 76873 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
5620: LD_INT 1
5622: PPUSH
5623: LD_INT 0
5625: PUSH
5626: LD_INT 127
5628: PUSH
5629: LD_INT 125
5631: PUSH
5632: LD_INT 5
5634: PUSH
5635: EMPTY
5636: LIST
5637: LIST
5638: LIST
5639: LIST
5640: PUSH
5641: LD_INT 6
5643: PUSH
5644: LD_INT 124
5646: PUSH
5647: LD_INT 132
5649: PUSH
5650: LD_INT 0
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: LIST
5657: LIST
5658: PUSH
5659: LD_INT 29
5661: PUSH
5662: LD_INT 136
5664: PUSH
5665: LD_INT 130
5667: PUSH
5668: LD_INT 1
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: LIST
5675: LIST
5676: PUSH
5677: LD_INT 4
5679: PUSH
5680: LD_INT 118
5682: PUSH
5683: LD_INT 114
5685: PUSH
5686: LD_INT 2
5688: PUSH
5689: EMPTY
5690: LIST
5691: LIST
5692: LIST
5693: LIST
5694: PUSH
5695: LD_INT 29
5697: PUSH
5698: LD_INT 145
5700: PUSH
5701: LD_INT 123
5703: PUSH
5704: LD_INT 1
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 26
5715: PUSH
5716: LD_INT 150
5718: PUSH
5719: LD_INT 135
5721: PUSH
5722: LD_INT 1
5724: PUSH
5725: EMPTY
5726: LIST
5727: LIST
5728: LIST
5729: LIST
5730: PUSH
5731: LD_INT 26
5733: PUSH
5734: LD_INT 140
5736: PUSH
5737: LD_INT 134
5739: PUSH
5740: LD_INT 2
5742: PUSH
5743: EMPTY
5744: LIST
5745: LIST
5746: LIST
5747: LIST
5748: PUSH
5749: LD_INT 26
5751: PUSH
5752: LD_INT 137
5754: PUSH
5755: LD_INT 121
5757: PUSH
5758: LD_INT 5
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: LIST
5765: LIST
5766: PUSH
5767: LD_INT 2
5769: PUSH
5770: LD_INT 155
5772: PUSH
5773: LD_INT 130
5775: PUSH
5776: LD_INT 0
5778: PUSH
5779: EMPTY
5780: LIST
5781: LIST
5782: LIST
5783: LIST
5784: PUSH
5785: LD_INT 32
5787: PUSH
5788: LD_INT 155
5790: PUSH
5791: LD_INT 130
5793: PUSH
5794: LD_INT 0
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: LIST
5801: LIST
5802: PUSH
5803: LD_INT 32
5805: PUSH
5806: LD_INT 130
5808: PUSH
5809: LD_INT 114
5811: PUSH
5812: LD_INT 3
5814: PUSH
5815: EMPTY
5816: LIST
5817: LIST
5818: LIST
5819: LIST
5820: PUSH
5821: LD_INT 32
5823: PUSH
5824: LD_INT 142
5826: PUSH
5827: LD_INT 115
5829: PUSH
5830: LD_INT 3
5832: PUSH
5833: EMPTY
5834: LIST
5835: LIST
5836: LIST
5837: LIST
5838: PUSH
5839: LD_INT 32
5841: PUSH
5842: LD_INT 153
5844: PUSH
5845: LD_INT 120
5847: PUSH
5848: LD_INT 3
5850: PUSH
5851: EMPTY
5852: LIST
5853: LIST
5854: LIST
5855: LIST
5856: PUSH
5857: EMPTY
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: LIST
5863: LIST
5864: LIST
5865: LIST
5866: LIST
5867: LIST
5868: LIST
5869: LIST
5870: LIST
5871: PPUSH
5872: CALL 76765 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
5876: LD_INT 1
5878: PPUSH
5879: LD_INT 10
5881: PUSH
5882: LD_INT 12
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: PPUSH
5889: CALL 77552 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
5893: LD_INT 1
5895: PPUSH
5896: LD_INT 155
5898: PPUSH
5899: LD_INT 130
5901: PPUSH
5902: LD_INT 0
5904: PPUSH
5905: LD_INT 24
5907: PUSH
5908: LD_INT 16
5910: PUSH
5911: LD_INT 17
5913: PUSH
5914: LD_INT 18
5916: PUSH
5917: LD_INT 21
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: LIST
5924: LIST
5925: LIST
5926: PPUSH
5927: CALL 77757 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
5931: LD_INT 2
5933: PPUSH
5934: LD_INT 3
5936: PPUSH
5937: CALL 78131 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
5941: LD_INT 2
5943: PPUSH
5944: LD_INT 4
5946: PPUSH
5947: CALL 78075 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
5951: LD_INT 2
5953: PPUSH
5954: LD_INT 84
5956: PUSH
5957: LD_INT 125
5959: PUSH
5960: LD_INT 1
5962: PUSH
5963: EMPTY
5964: LIST
5965: LIST
5966: LIST
5967: PUSH
5968: EMPTY
5969: LIST
5970: PPUSH
5971: CALL 77197 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5975: LD_INT 2
5977: PPUSH
5978: LD_INT 43
5980: PUSH
5981: LD_INT 46
5983: PUSH
5984: LD_INT 45
5986: PUSH
5987: EMPTY
5988: LIST
5989: LIST
5990: LIST
5991: PPUSH
5992: CALL 77963 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
5996: LD_INT 2
5998: PPUSH
5999: LD_INT 3
6001: PPUSH
6002: CALL 77645 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6006: LD_INT 2
6008: PPUSH
6009: LD_INT 3
6011: PPUSH
6012: CALL 77376 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6016: LD_INT 2
6018: PPUSH
6019: LD_INT 8
6021: PPUSH
6022: CALL 77058 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6026: LD_INT 2
6028: PPUSH
6029: LD_INT 22
6031: PUSH
6032: LD_INT 3
6034: PUSH
6035: LD_INT 3
6037: PUSH
6038: LD_INT 43
6040: PUSH
6041: EMPTY
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: PUSH
6047: LD_INT 22
6049: PUSH
6050: LD_INT 3
6052: PUSH
6053: LD_INT 3
6055: PUSH
6056: LD_INT 44
6058: PUSH
6059: EMPTY
6060: LIST
6061: LIST
6062: LIST
6063: LIST
6064: PUSH
6065: LD_INT 22
6067: PUSH
6068: LD_INT 3
6070: PUSH
6071: LD_INT 3
6073: PUSH
6074: LD_INT 45
6076: PUSH
6077: EMPTY
6078: LIST
6079: LIST
6080: LIST
6081: LIST
6082: PUSH
6083: LD_INT 24
6085: PUSH
6086: LD_INT 3
6088: PUSH
6089: LD_INT 3
6091: PUSH
6092: LD_INT 43
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: LIST
6099: LIST
6100: PUSH
6101: LD_INT 24
6103: PUSH
6104: LD_INT 3
6106: PUSH
6107: LD_INT 3
6109: PUSH
6110: LD_INT 43
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: LIST
6118: PUSH
6119: LD_INT 24
6121: PUSH
6122: LD_INT 3
6124: PUSH
6125: LD_INT 3
6127: PUSH
6128: LD_INT 46
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: LIST
6135: LIST
6136: PUSH
6137: LD_INT 22
6139: PUSH
6140: LD_INT 3
6142: PUSH
6143: LD_INT 3
6145: PUSH
6146: LD_INT 43
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: LIST
6153: LIST
6154: PUSH
6155: LD_INT 22
6157: PUSH
6158: LD_INT 3
6160: PUSH
6161: LD_INT 3
6163: PUSH
6164: LD_INT 44
6166: PUSH
6167: EMPTY
6168: LIST
6169: LIST
6170: LIST
6171: LIST
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: LIST
6177: LIST
6178: LIST
6179: LIST
6180: LIST
6181: LIST
6182: PPUSH
6183: CALL 76873 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6187: LD_INT 2
6189: PPUSH
6190: LD_INT 0
6192: PUSH
6193: LD_INT 96
6195: PUSH
6196: LD_INT 125
6198: PUSH
6199: LD_INT 0
6201: PUSH
6202: EMPTY
6203: LIST
6204: LIST
6205: LIST
6206: LIST
6207: PUSH
6208: LD_INT 6
6210: PUSH
6211: LD_INT 74
6213: PUSH
6214: LD_INT 122
6216: PUSH
6217: LD_INT 1
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: LIST
6225: PUSH
6226: LD_INT 30
6228: PUSH
6229: LD_INT 84
6231: PUSH
6232: LD_INT 125
6234: PUSH
6235: LD_INT 1
6237: PUSH
6238: EMPTY
6239: LIST
6240: LIST
6241: LIST
6242: LIST
6243: PUSH
6244: LD_INT 28
6246: PUSH
6247: LD_INT 86
6249: PUSH
6250: LD_INT 128
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: PUSH
6262: LD_INT 28
6264: PUSH
6265: LD_INT 85
6267: PUSH
6268: LD_INT 130
6270: PUSH
6271: LD_INT 2
6273: PUSH
6274: EMPTY
6275: LIST
6276: LIST
6277: LIST
6278: LIST
6279: PUSH
6280: LD_INT 28
6282: PUSH
6283: LD_INT 88
6285: PUSH
6286: LD_INT 132
6288: PUSH
6289: LD_INT 5
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: LIST
6296: LIST
6297: PUSH
6298: LD_INT 2
6300: PUSH
6301: LD_INT 106
6303: PUSH
6304: LD_INT 130
6306: PUSH
6307: LD_INT 0
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: PUSH
6316: LD_INT 4
6318: PUSH
6319: LD_INT 99
6321: PUSH
6322: LD_INT 114
6324: PUSH
6325: LD_INT 3
6327: PUSH
6328: EMPTY
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PUSH
6334: LD_INT 32
6336: PUSH
6337: LD_INT 72
6339: PUSH
6340: LD_INT 112
6342: PUSH
6343: LD_INT 2
6345: PUSH
6346: EMPTY
6347: LIST
6348: LIST
6349: LIST
6350: LIST
6351: PUSH
6352: LD_INT 32
6354: PUSH
6355: LD_INT 78
6357: PUSH
6358: LD_INT 110
6360: PUSH
6361: LD_INT 3
6363: PUSH
6364: EMPTY
6365: LIST
6366: LIST
6367: LIST
6368: LIST
6369: PUSH
6370: LD_INT 32
6372: PUSH
6373: LD_INT 84
6375: PUSH
6376: LD_INT 110
6378: PUSH
6379: LD_INT 2
6381: PUSH
6382: EMPTY
6383: LIST
6384: LIST
6385: LIST
6386: LIST
6387: PUSH
6388: LD_INT 32
6390: PUSH
6391: LD_INT 105
6393: PUSH
6394: LD_INT 117
6396: PUSH
6397: LD_INT 3
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: LIST
6404: LIST
6405: PUSH
6406: EMPTY
6407: LIST
6408: LIST
6409: LIST
6410: LIST
6411: LIST
6412: LIST
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: PPUSH
6420: CALL 76765 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6424: LD_INT 2
6426: PPUSH
6427: LD_INT 14
6429: PUSH
6430: LD_INT 11
6432: PUSH
6433: EMPTY
6434: LIST
6435: LIST
6436: PPUSH
6437: CALL 77552 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6441: LD_INT 2
6443: PPUSH
6444: LD_INT 106
6446: PPUSH
6447: LD_INT 130
6449: PPUSH
6450: LD_INT 0
6452: PPUSH
6453: LD_INT 24
6455: PUSH
6456: LD_INT 16
6458: PUSH
6459: LD_INT 17
6461: PUSH
6462: LD_INT 18
6464: PUSH
6465: LD_INT 21
6467: PUSH
6468: EMPTY
6469: LIST
6470: LIST
6471: LIST
6472: LIST
6473: LIST
6474: PPUSH
6475: CALL 77757 0 5
// end ;
6479: LD_VAR 0 1
6483: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6484: LD_INT 22
6486: PUSH
6487: LD_INT 3
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: PUSH
6494: LD_INT 30
6496: PUSH
6497: LD_INT 3
6499: PUSH
6500: EMPTY
6501: LIST
6502: LIST
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: PPUSH
6508: CALL_OW 69
6512: IFFALSE 7368
6514: GO 6516
6516: DISABLE
6517: LD_INT 0
6519: PPUSH
6520: PPUSH
6521: PPUSH
6522: PPUSH
6523: PPUSH
6524: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
6525: LD_INT 6300
6527: PUSH
6528: LD_INT 4200
6530: PUSH
6531: LD_INT 2100
6533: PUSH
6534: EMPTY
6535: LIST
6536: LIST
6537: LIST
6538: PUSH
6539: LD_OWVAR 67
6543: ARRAY
6544: PPUSH
6545: CALL_OW 67
// base := 2 ;
6549: LD_ADDR_VAR 0 2
6553: PUSH
6554: LD_INT 2
6556: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
6557: LD_INT 22
6559: PUSH
6560: LD_INT 3
6562: PUSH
6563: EMPTY
6564: LIST
6565: LIST
6566: PUSH
6567: LD_INT 30
6569: PUSH
6570: LD_INT 3
6572: PUSH
6573: EMPTY
6574: LIST
6575: LIST
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PPUSH
6581: CALL_OW 69
6585: NOT
6586: IFFALSE 6590
// continue ;
6588: GO 6525
// case Rand ( 1 , 3 ) of 1 :
6590: LD_INT 1
6592: PPUSH
6593: LD_INT 3
6595: PPUSH
6596: CALL_OW 12
6600: PUSH
6601: LD_INT 1
6603: DOUBLE
6604: EQUAL
6605: IFTRUE 6609
6607: GO 6785
6609: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
6610: LD_ADDR_VAR 0 3
6614: PUSH
6615: LD_INT 22
6617: PUSH
6618: LD_INT 3
6620: PUSH
6621: LD_INT 3
6623: PUSH
6624: LD_INT 43
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 24
6635: PUSH
6636: LD_INT 3
6638: PUSH
6639: LD_INT 3
6641: PUSH
6642: LD_INT 46
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 24
6653: PUSH
6654: LD_INT 3
6656: PUSH
6657: LD_INT 3
6659: PUSH
6660: LD_INT 43
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 24
6671: PUSH
6672: LD_INT 3
6674: PUSH
6675: LD_INT 3
6677: PUSH
6678: LD_INT 46
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 22
6689: PUSH
6690: LD_INT 3
6692: PUSH
6693: LD_INT 3
6695: PUSH
6696: LD_INT 45
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: LD_INT 22
6707: PUSH
6708: LD_INT 3
6710: PUSH
6711: LD_INT 3
6713: PUSH
6714: LD_INT 43
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 24
6725: PUSH
6726: LD_INT 3
6728: PUSH
6729: LD_INT 3
6731: PUSH
6732: LD_INT 46
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: PUSH
6741: LD_INT 22
6743: PUSH
6744: LD_INT 3
6746: PUSH
6747: LD_INT 3
6749: PUSH
6750: LD_INT 45
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: PUSH
6759: EMPTY
6760: LIST
6761: LIST
6762: LIST
6763: LIST
6764: LIST
6765: LIST
6766: LIST
6767: LIST
6768: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6769: LD_VAR 0 2
6773: PPUSH
6774: LD_VAR 0 3
6778: PPUSH
6779: CALL 76921 0 2
// end ; 2 :
6783: GO 7116
6785: LD_INT 2
6787: DOUBLE
6788: EQUAL
6789: IFTRUE 6793
6791: GO 6931
6793: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
6794: LD_ADDR_VAR 0 3
6798: PUSH
6799: LD_INT 24
6801: PUSH
6802: LD_INT 3
6804: PUSH
6805: LD_INT 3
6807: PUSH
6808: LD_INT 43
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: LIST
6816: PUSH
6817: LD_INT 24
6819: PUSH
6820: LD_INT 3
6822: PUSH
6823: LD_INT 3
6825: PUSH
6826: LD_INT 46
6828: PUSH
6829: EMPTY
6830: LIST
6831: LIST
6832: LIST
6833: LIST
6834: PUSH
6835: LD_INT 24
6837: PUSH
6838: LD_INT 3
6840: PUSH
6841: LD_INT 3
6843: PUSH
6844: LD_INT 43
6846: PUSH
6847: EMPTY
6848: LIST
6849: LIST
6850: LIST
6851: LIST
6852: PUSH
6853: LD_INT 24
6855: PUSH
6856: LD_INT 3
6858: PUSH
6859: LD_INT 3
6861: PUSH
6862: LD_INT 46
6864: PUSH
6865: EMPTY
6866: LIST
6867: LIST
6868: LIST
6869: LIST
6870: PUSH
6871: LD_INT 22
6873: PUSH
6874: LD_INT 3
6876: PUSH
6877: LD_INT 3
6879: PUSH
6880: LD_INT 45
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: LIST
6887: LIST
6888: PUSH
6889: LD_INT 22
6891: PUSH
6892: LD_INT 3
6894: PUSH
6895: LD_INT 3
6897: PUSH
6898: LD_INT 45
6900: PUSH
6901: EMPTY
6902: LIST
6903: LIST
6904: LIST
6905: LIST
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: LIST
6911: LIST
6912: LIST
6913: LIST
6914: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6915: LD_VAR 0 2
6919: PPUSH
6920: LD_VAR 0 3
6924: PPUSH
6925: CALL 76921 0 2
// end ; 3 :
6929: GO 7116
6931: LD_INT 3
6933: DOUBLE
6934: EQUAL
6935: IFTRUE 6939
6937: GO 7115
6939: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
6940: LD_ADDR_VAR 0 3
6944: PUSH
6945: LD_INT 22
6947: PUSH
6948: LD_INT 3
6950: PUSH
6951: LD_INT 3
6953: PUSH
6954: LD_INT 43
6956: PUSH
6957: EMPTY
6958: LIST
6959: LIST
6960: LIST
6961: LIST
6962: PUSH
6963: LD_INT 24
6965: PUSH
6966: LD_INT 3
6968: PUSH
6969: LD_INT 3
6971: PUSH
6972: LD_INT 46
6974: PUSH
6975: EMPTY
6976: LIST
6977: LIST
6978: LIST
6979: LIST
6980: PUSH
6981: LD_INT 22
6983: PUSH
6984: LD_INT 3
6986: PUSH
6987: LD_INT 3
6989: PUSH
6990: LD_INT 43
6992: PUSH
6993: EMPTY
6994: LIST
6995: LIST
6996: LIST
6997: LIST
6998: PUSH
6999: LD_INT 24
7001: PUSH
7002: LD_INT 3
7004: PUSH
7005: LD_INT 3
7007: PUSH
7008: LD_INT 46
7010: PUSH
7011: EMPTY
7012: LIST
7013: LIST
7014: LIST
7015: LIST
7016: PUSH
7017: LD_INT 22
7019: PUSH
7020: LD_INT 3
7022: PUSH
7023: LD_INT 3
7025: PUSH
7026: LD_INT 45
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: PUSH
7035: LD_INT 22
7037: PUSH
7038: LD_INT 3
7040: PUSH
7041: LD_INT 3
7043: PUSH
7044: LD_INT 43
7046: PUSH
7047: EMPTY
7048: LIST
7049: LIST
7050: LIST
7051: LIST
7052: PUSH
7053: LD_INT 24
7055: PUSH
7056: LD_INT 3
7058: PUSH
7059: LD_INT 3
7061: PUSH
7062: LD_INT 46
7064: PUSH
7065: EMPTY
7066: LIST
7067: LIST
7068: LIST
7069: LIST
7070: PUSH
7071: LD_INT 22
7073: PUSH
7074: LD_INT 3
7076: PUSH
7077: LD_INT 3
7079: PUSH
7080: LD_INT 45
7082: PUSH
7083: EMPTY
7084: LIST
7085: LIST
7086: LIST
7087: LIST
7088: PUSH
7089: EMPTY
7090: LIST
7091: LIST
7092: LIST
7093: LIST
7094: LIST
7095: LIST
7096: LIST
7097: LIST
7098: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7099: LD_VAR 0 2
7103: PPUSH
7104: LD_VAR 0 3
7108: PPUSH
7109: CALL 76921 0 2
// end ; end ;
7113: GO 7116
7115: POP
// repeat wait ( 0 0$1 ) ;
7116: LD_INT 35
7118: PPUSH
7119: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7123: LD_VAR 0 2
7127: PPUSH
7128: CALL 77269 0 1
7132: PUSH
7133: LD_INT 0
7135: EQUAL
7136: IFFALSE 7116
// wait ( 0 0$30 ) ;
7138: LD_INT 1050
7140: PPUSH
7141: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7145: LD_ADDR_VAR 0 5
7149: PUSH
7150: LD_INT 86
7152: PUSH
7153: LD_INT 77
7155: PUSH
7156: EMPTY
7157: LIST
7158: LIST
7159: PUSH
7160: LD_INT 63
7162: PUSH
7163: LD_INT 38
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7174: LD_ADDR_VAR 0 4
7178: PUSH
7179: LD_INT 0
7181: PUSH
7182: LD_INT 0
7184: PUSH
7185: LD_INT 0
7187: PUSH
7188: LD_INT 1
7190: PUSH
7191: LD_INT 0
7193: PUSH
7194: LD_INT 0
7196: PUSH
7197: LD_INT 0
7199: PUSH
7200: LD_INT 0
7202: PUSH
7203: LD_INT 1
7205: PUSH
7206: LD_INT 0
7208: PUSH
7209: EMPTY
7210: LIST
7211: LIST
7212: LIST
7213: LIST
7214: LIST
7215: LIST
7216: LIST
7217: LIST
7218: LIST
7219: LIST
7220: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7221: LD_ADDR_VAR 0 6
7225: PUSH
7226: LD_EXP 71
7230: PUSH
7231: LD_VAR 0 2
7235: ARRAY
7236: PUSH
7237: LD_EXP 74
7241: PUSH
7242: LD_VAR 0 2
7246: ARRAY
7247: DIFF
7248: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7249: LD_ADDR_EXP 71
7253: PUSH
7254: LD_EXP 71
7258: PPUSH
7259: LD_VAR 0 2
7263: PPUSH
7264: LD_EXP 71
7268: PUSH
7269: LD_VAR 0 2
7273: ARRAY
7274: PUSH
7275: LD_VAR 0 6
7279: DIFF
7280: PPUSH
7281: CALL_OW 1
7285: ST_TO_ADDR
// if not attackers then
7286: LD_VAR 0 6
7290: NOT
7291: IFFALSE 7295
// continue ;
7293: GO 6525
// repeat wait ( 0 0$1 ) ;
7295: LD_INT 35
7297: PPUSH
7298: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7302: LD_VAR 0 6
7306: PPUSH
7307: LD_INT 60
7309: PUSH
7310: EMPTY
7311: LIST
7312: PPUSH
7313: CALL_OW 72
7317: NOT
7318: IFFALSE 7295
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
7320: LD_VAR 0 2
7324: PPUSH
7325: LD_VAR 0 6
7329: PPUSH
7330: LD_VAR 0 5
7334: PPUSH
7335: LD_VAR 0 4
7339: PPUSH
7340: CALL 77106 0 4
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
7344: LD_EXP 52
7348: PUSH
7349: LD_VAR 0 2
7353: ARRAY
7354: PPUSH
7355: LD_INT 50
7357: PUSH
7358: EMPTY
7359: LIST
7360: PPUSH
7361: CALL_OW 72
7365: NOT
7366: IFFALSE 6525
// end ;
7368: PPOPN 6
7370: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
7371: LD_INT 22
7373: PUSH
7374: LD_INT 3
7376: PUSH
7377: EMPTY
7378: LIST
7379: LIST
7380: PUSH
7381: LD_INT 30
7383: PUSH
7384: LD_INT 3
7386: PUSH
7387: EMPTY
7388: LIST
7389: LIST
7390: PUSH
7391: EMPTY
7392: LIST
7393: LIST
7394: PPUSH
7395: CALL_OW 69
7399: IFFALSE 8296
7401: GO 7403
7403: DISABLE
7404: LD_INT 0
7406: PPUSH
7407: PPUSH
7408: PPUSH
7409: PPUSH
7410: PPUSH
7411: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
7412: LD_INT 6300
7414: PUSH
7415: LD_INT 4200
7417: PUSH
7418: LD_INT 2100
7420: PUSH
7421: EMPTY
7422: LIST
7423: LIST
7424: LIST
7425: PUSH
7426: LD_OWVAR 67
7430: ARRAY
7431: PPUSH
7432: CALL_OW 67
// base := 1 ;
7436: LD_ADDR_VAR 0 2
7440: PUSH
7441: LD_INT 1
7443: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
7444: LD_INT 22
7446: PUSH
7447: LD_INT 3
7449: PUSH
7450: EMPTY
7451: LIST
7452: LIST
7453: PUSH
7454: LD_INT 30
7456: PUSH
7457: LD_INT 3
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: PUSH
7464: EMPTY
7465: LIST
7466: LIST
7467: PPUSH
7468: CALL_OW 69
7472: NOT
7473: IFFALSE 7477
// continue ;
7475: GO 7412
// case Rand ( 1 , 3 ) of 1 :
7477: LD_INT 1
7479: PPUSH
7480: LD_INT 3
7482: PPUSH
7483: CALL_OW 12
7487: PUSH
7488: LD_INT 1
7490: DOUBLE
7491: EQUAL
7492: IFTRUE 7496
7494: GO 7672
7496: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
7497: LD_ADDR_VAR 0 3
7501: PUSH
7502: LD_INT 22
7504: PUSH
7505: LD_INT 1
7507: PUSH
7508: LD_INT 3
7510: PUSH
7511: LD_INT 43
7513: PUSH
7514: EMPTY
7515: LIST
7516: LIST
7517: LIST
7518: LIST
7519: PUSH
7520: LD_INT 24
7522: PUSH
7523: LD_INT 1
7525: PUSH
7526: LD_INT 3
7528: PUSH
7529: LD_INT 46
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: LIST
7536: LIST
7537: PUSH
7538: LD_INT 24
7540: PUSH
7541: LD_INT 1
7543: PUSH
7544: LD_INT 3
7546: PUSH
7547: LD_INT 43
7549: PUSH
7550: EMPTY
7551: LIST
7552: LIST
7553: LIST
7554: LIST
7555: PUSH
7556: LD_INT 24
7558: PUSH
7559: LD_INT 1
7561: PUSH
7562: LD_INT 3
7564: PUSH
7565: LD_INT 46
7567: PUSH
7568: EMPTY
7569: LIST
7570: LIST
7571: LIST
7572: LIST
7573: PUSH
7574: LD_INT 22
7576: PUSH
7577: LD_INT 1
7579: PUSH
7580: LD_INT 3
7582: PUSH
7583: LD_INT 45
7585: PUSH
7586: EMPTY
7587: LIST
7588: LIST
7589: LIST
7590: LIST
7591: PUSH
7592: LD_INT 22
7594: PUSH
7595: LD_INT 1
7597: PUSH
7598: LD_INT 3
7600: PUSH
7601: LD_INT 43
7603: PUSH
7604: EMPTY
7605: LIST
7606: LIST
7607: LIST
7608: LIST
7609: PUSH
7610: LD_INT 24
7612: PUSH
7613: LD_INT 1
7615: PUSH
7616: LD_INT 3
7618: PUSH
7619: LD_INT 46
7621: PUSH
7622: EMPTY
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: PUSH
7628: LD_INT 22
7630: PUSH
7631: LD_INT 1
7633: PUSH
7634: LD_INT 3
7636: PUSH
7637: LD_INT 45
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: LIST
7644: LIST
7645: PUSH
7646: EMPTY
7647: LIST
7648: LIST
7649: LIST
7650: LIST
7651: LIST
7652: LIST
7653: LIST
7654: LIST
7655: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7656: LD_VAR 0 2
7660: PPUSH
7661: LD_VAR 0 3
7665: PPUSH
7666: CALL 76921 0 2
// end ; 2 :
7670: GO 8041
7672: LD_INT 2
7674: DOUBLE
7675: EQUAL
7676: IFTRUE 7680
7678: GO 7856
7680: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
7681: LD_ADDR_VAR 0 3
7685: PUSH
7686: LD_INT 24
7688: PUSH
7689: LD_INT 1
7691: PUSH
7692: LD_INT 3
7694: PUSH
7695: LD_INT 43
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: LIST
7702: LIST
7703: PUSH
7704: LD_INT 24
7706: PUSH
7707: LD_INT 1
7709: PUSH
7710: LD_INT 3
7712: PUSH
7713: LD_INT 46
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: LIST
7720: LIST
7721: PUSH
7722: LD_INT 24
7724: PUSH
7725: LD_INT 1
7727: PUSH
7728: LD_INT 3
7730: PUSH
7731: LD_INT 43
7733: PUSH
7734: EMPTY
7735: LIST
7736: LIST
7737: LIST
7738: LIST
7739: PUSH
7740: LD_INT 24
7742: PUSH
7743: LD_INT 1
7745: PUSH
7746: LD_INT 3
7748: PUSH
7749: LD_INT 46
7751: PUSH
7752: EMPTY
7753: LIST
7754: LIST
7755: LIST
7756: LIST
7757: PUSH
7758: LD_INT 22
7760: PUSH
7761: LD_INT 1
7763: PUSH
7764: LD_INT 3
7766: PUSH
7767: LD_INT 45
7769: PUSH
7770: EMPTY
7771: LIST
7772: LIST
7773: LIST
7774: LIST
7775: PUSH
7776: LD_INT 22
7778: PUSH
7779: LD_INT 1
7781: PUSH
7782: LD_INT 3
7784: PUSH
7785: LD_INT 45
7787: PUSH
7788: EMPTY
7789: LIST
7790: LIST
7791: LIST
7792: LIST
7793: PUSH
7794: LD_INT 22
7796: PUSH
7797: LD_INT 1
7799: PUSH
7800: LD_INT 3
7802: PUSH
7803: LD_INT 45
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: LIST
7810: LIST
7811: PUSH
7812: LD_INT 22
7814: PUSH
7815: LD_INT 1
7817: PUSH
7818: LD_INT 3
7820: PUSH
7821: LD_INT 45
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: LIST
7828: LIST
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: LIST
7834: LIST
7835: LIST
7836: LIST
7837: LIST
7838: LIST
7839: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7840: LD_VAR 0 2
7844: PPUSH
7845: LD_VAR 0 3
7849: PPUSH
7850: CALL 76921 0 2
// end ; 3 :
7854: GO 8041
7856: LD_INT 3
7858: DOUBLE
7859: EQUAL
7860: IFTRUE 7864
7862: GO 8040
7864: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
7865: LD_ADDR_VAR 0 3
7869: PUSH
7870: LD_INT 22
7872: PUSH
7873: LD_INT 1
7875: PUSH
7876: LD_INT 3
7878: PUSH
7879: LD_INT 43
7881: PUSH
7882: EMPTY
7883: LIST
7884: LIST
7885: LIST
7886: LIST
7887: PUSH
7888: LD_INT 24
7890: PUSH
7891: LD_INT 1
7893: PUSH
7894: LD_INT 3
7896: PUSH
7897: LD_INT 46
7899: PUSH
7900: EMPTY
7901: LIST
7902: LIST
7903: LIST
7904: LIST
7905: PUSH
7906: LD_INT 22
7908: PUSH
7909: LD_INT 1
7911: PUSH
7912: LD_INT 3
7914: PUSH
7915: LD_INT 43
7917: PUSH
7918: EMPTY
7919: LIST
7920: LIST
7921: LIST
7922: LIST
7923: PUSH
7924: LD_INT 24
7926: PUSH
7927: LD_INT 1
7929: PUSH
7930: LD_INT 3
7932: PUSH
7933: LD_INT 46
7935: PUSH
7936: EMPTY
7937: LIST
7938: LIST
7939: LIST
7940: LIST
7941: PUSH
7942: LD_INT 22
7944: PUSH
7945: LD_INT 1
7947: PUSH
7948: LD_INT 3
7950: PUSH
7951: LD_INT 45
7953: PUSH
7954: EMPTY
7955: LIST
7956: LIST
7957: LIST
7958: LIST
7959: PUSH
7960: LD_INT 22
7962: PUSH
7963: LD_INT 1
7965: PUSH
7966: LD_INT 3
7968: PUSH
7969: LD_INT 43
7971: PUSH
7972: EMPTY
7973: LIST
7974: LIST
7975: LIST
7976: LIST
7977: PUSH
7978: LD_INT 24
7980: PUSH
7981: LD_INT 1
7983: PUSH
7984: LD_INT 3
7986: PUSH
7987: LD_INT 46
7989: PUSH
7990: EMPTY
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: PUSH
7996: LD_INT 22
7998: PUSH
7999: LD_INT 1
8001: PUSH
8002: LD_INT 3
8004: PUSH
8005: LD_INT 45
8007: PUSH
8008: EMPTY
8009: LIST
8010: LIST
8011: LIST
8012: LIST
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: LIST
8021: LIST
8022: LIST
8023: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8024: LD_VAR 0 2
8028: PPUSH
8029: LD_VAR 0 3
8033: PPUSH
8034: CALL 76921 0 2
// end ; end ;
8038: GO 8041
8040: POP
// repeat wait ( 0 0$1 ) ;
8041: LD_INT 35
8043: PPUSH
8044: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8048: LD_VAR 0 2
8052: PPUSH
8053: LD_INT 1
8055: PPUSH
8056: CALL 78276 0 2
8060: PUSH
8061: LD_INT 8
8063: GREATEREQUAL
8064: IFFALSE 8041
// wait ( 0 0$30 ) ;
8066: LD_INT 1050
8068: PPUSH
8069: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8073: LD_ADDR_VAR 0 5
8077: PUSH
8078: LD_INT 144
8080: PUSH
8081: LD_INT 65
8083: PUSH
8084: EMPTY
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 63
8090: PUSH
8091: LD_INT 38
8093: PUSH
8094: EMPTY
8095: LIST
8096: LIST
8097: PUSH
8098: EMPTY
8099: LIST
8100: LIST
8101: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8102: LD_ADDR_VAR 0 4
8106: PUSH
8107: LD_INT 0
8109: PUSH
8110: LD_INT 0
8112: PUSH
8113: LD_INT 0
8115: PUSH
8116: LD_INT 1
8118: PUSH
8119: LD_INT 0
8121: PUSH
8122: LD_INT 0
8124: PUSH
8125: LD_INT 0
8127: PUSH
8128: LD_INT 0
8130: PUSH
8131: LD_INT 1
8133: PUSH
8134: LD_INT 0
8136: PUSH
8137: EMPTY
8138: LIST
8139: LIST
8140: LIST
8141: LIST
8142: LIST
8143: LIST
8144: LIST
8145: LIST
8146: LIST
8147: LIST
8148: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8149: LD_ADDR_VAR 0 6
8153: PUSH
8154: LD_EXP 71
8158: PUSH
8159: LD_VAR 0 2
8163: ARRAY
8164: PUSH
8165: LD_EXP 74
8169: PUSH
8170: LD_VAR 0 2
8174: ARRAY
8175: DIFF
8176: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8177: LD_ADDR_EXP 71
8181: PUSH
8182: LD_EXP 71
8186: PPUSH
8187: LD_VAR 0 2
8191: PPUSH
8192: LD_EXP 71
8196: PUSH
8197: LD_VAR 0 2
8201: ARRAY
8202: PUSH
8203: LD_VAR 0 6
8207: DIFF
8208: PPUSH
8209: CALL_OW 1
8213: ST_TO_ADDR
// if not attackers then
8214: LD_VAR 0 6
8218: NOT
8219: IFFALSE 8223
// continue ;
8221: GO 7412
// repeat wait ( 0 0$1 ) ;
8223: LD_INT 35
8225: PPUSH
8226: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8230: LD_VAR 0 6
8234: PPUSH
8235: LD_INT 60
8237: PUSH
8238: EMPTY
8239: LIST
8240: PPUSH
8241: CALL_OW 72
8245: NOT
8246: IFFALSE 8223
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
8248: LD_VAR 0 2
8252: PPUSH
8253: LD_VAR 0 6
8257: PPUSH
8258: LD_VAR 0 5
8262: PPUSH
8263: LD_VAR 0 4
8267: PPUSH
8268: CALL 77106 0 4
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8272: LD_EXP 52
8276: PUSH
8277: LD_VAR 0 2
8281: ARRAY
8282: PPUSH
8283: LD_INT 50
8285: PUSH
8286: EMPTY
8287: LIST
8288: PPUSH
8289: CALL_OW 72
8293: NOT
8294: IFFALSE 7412
// end ;
8296: PPOPN 6
8298: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
8299: LD_EXP 3
8303: PUSH
8304: LD_INT 22
8306: PUSH
8307: LD_INT 3
8309: PUSH
8310: EMPTY
8311: LIST
8312: LIST
8313: PUSH
8314: LD_INT 21
8316: PUSH
8317: LD_INT 1
8319: PUSH
8320: EMPTY
8321: LIST
8322: LIST
8323: PUSH
8324: EMPTY
8325: LIST
8326: LIST
8327: PPUSH
8328: CALL_OW 69
8332: PUSH
8333: LD_INT 0
8335: EQUAL
8336: AND
8337: IFFALSE 8350
8339: GO 8341
8341: DISABLE
// begin RussiansDefeated := true ;
8342: LD_ADDR_EXP 42
8346: PUSH
8347: LD_INT 1
8349: ST_TO_ADDR
// end ;
8350: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
8351: LD_EXP 3
8355: PUSH
8356: LD_EXP 5
8360: NOT
8361: AND
8362: IFFALSE 9335
8364: GO 8366
8366: DISABLE
8367: LD_INT 0
8369: PPUSH
8370: PPUSH
8371: PPUSH
8372: PPUSH
8373: PPUSH
8374: PPUSH
8375: PPUSH
8376: PPUSH
8377: PPUSH
8378: PPUSH
8379: PPUSH
8380: PPUSH
// begin wait ( [ Rand ( 5 5$00 , 6 6$30 ) , Rand ( 4 4$30 , 5 5$30 ) , Rand ( 4 4$00 , 5 5$00 ) ] [ Difficulty ] ) ;
8381: LD_INT 10500
8383: PPUSH
8384: LD_INT 13650
8386: PPUSH
8387: CALL_OW 12
8391: PUSH
8392: LD_INT 9450
8394: PPUSH
8395: LD_INT 11550
8397: PPUSH
8398: CALL_OW 12
8402: PUSH
8403: LD_INT 8400
8405: PPUSH
8406: LD_INT 10500
8408: PPUSH
8409: CALL_OW 12
8413: PUSH
8414: EMPTY
8415: LIST
8416: LIST
8417: LIST
8418: PUSH
8419: LD_OWVAR 67
8423: ARRAY
8424: PPUSH
8425: CALL_OW 67
// filter := [ ] ;
8429: LD_ADDR_VAR 0 3
8433: PUSH
8434: EMPTY
8435: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
8436: LD_ADDR_VAR 0 4
8440: PUSH
8441: LD_INT 2
8443: PPUSH
8444: LD_INT 3
8446: PPUSH
8447: CALL_OW 12
8451: PUSH
8452: LD_INT 3
8454: PPUSH
8455: LD_INT 4
8457: PPUSH
8458: CALL_OW 12
8462: PUSH
8463: LD_INT 3
8465: PPUSH
8466: LD_INT 5
8468: PPUSH
8469: CALL_OW 12
8473: PUSH
8474: EMPTY
8475: LIST
8476: LIST
8477: LIST
8478: PUSH
8479: LD_OWVAR 67
8483: ARRAY
8484: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
8485: LD_ADDR_VAR 0 5
8489: PUSH
8490: LD_INT 1
8492: PUSH
8493: LD_INT 1
8495: PPUSH
8496: LD_INT 2
8498: PPUSH
8499: CALL_OW 12
8503: PUSH
8504: LD_INT 2
8506: PPUSH
8507: LD_INT 3
8509: PPUSH
8510: CALL_OW 12
8514: PUSH
8515: EMPTY
8516: LIST
8517: LIST
8518: LIST
8519: PUSH
8520: LD_OWVAR 67
8524: ARRAY
8525: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
8526: LD_ADDR_VAR 0 6
8530: PUSH
8531: LD_INT 2
8533: PPUSH
8534: LD_INT 3
8536: PPUSH
8537: CALL_OW 12
8541: PUSH
8542: LD_INT 2
8544: PPUSH
8545: LD_INT 4
8547: PPUSH
8548: CALL_OW 12
8552: PUSH
8553: LD_INT 3
8555: PPUSH
8556: LD_INT 5
8558: PPUSH
8559: CALL_OW 12
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: PUSH
8569: LD_OWVAR 67
8573: ARRAY
8574: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
8575: LD_ADDR_VAR 0 8
8579: PUSH
8580: LD_INT 1
8582: PUSH
8583: LD_INT 2
8585: PUSH
8586: LD_INT 2
8588: PUSH
8589: EMPTY
8590: LIST
8591: LIST
8592: LIST
8593: PUSH
8594: LD_OWVAR 67
8598: ARRAY
8599: ST_TO_ADDR
// uc_side := 3 ;
8600: LD_ADDR_OWVAR 20
8604: PUSH
8605: LD_INT 3
8607: ST_TO_ADDR
// uc_nation := nation_russian ;
8608: LD_ADDR_OWVAR 21
8612: PUSH
8613: LD_INT 3
8615: ST_TO_ADDR
// for i = 1 to soldiers do
8616: LD_ADDR_VAR 0 1
8620: PUSH
8621: DOUBLE
8622: LD_INT 1
8624: DEC
8625: ST_TO_ADDR
8626: LD_VAR 0 4
8630: PUSH
8631: FOR_TO
8632: IFFALSE 8674
// begin PrepareSoldier ( 0 , game_eskill ) ;
8634: LD_INT 0
8636: PPUSH
8637: LD_EXP 39
8641: PPUSH
8642: CALL_OW 381
// un := CreateHuman ;
8646: LD_ADDR_VAR 0 2
8650: PUSH
8651: CALL_OW 44
8655: ST_TO_ADDR
// filter := filter ^ un ;
8656: LD_ADDR_VAR 0 3
8660: PUSH
8661: LD_VAR 0 3
8665: PUSH
8666: LD_VAR 0 2
8670: ADD
8671: ST_TO_ADDR
// end ;
8672: GO 8631
8674: POP
8675: POP
// for i = 1 to bazookas do
8676: LD_ADDR_VAR 0 1
8680: PUSH
8681: DOUBLE
8682: LD_INT 1
8684: DEC
8685: ST_TO_ADDR
8686: LD_VAR 0 5
8690: PUSH
8691: FOR_TO
8692: IFFALSE 8742
// begin PrepareSoldier ( 0 , game_eskill ) ;
8694: LD_INT 0
8696: PPUSH
8697: LD_EXP 39
8701: PPUSH
8702: CALL_OW 381
// hc_class := class_bazooker ;
8706: LD_ADDR_OWVAR 28
8710: PUSH
8711: LD_INT 9
8713: ST_TO_ADDR
// un := CreateHuman ;
8714: LD_ADDR_VAR 0 2
8718: PUSH
8719: CALL_OW 44
8723: ST_TO_ADDR
// filter := filter ^ un ;
8724: LD_ADDR_VAR 0 3
8728: PUSH
8729: LD_VAR 0 3
8733: PUSH
8734: LD_VAR 0 2
8738: ADD
8739: ST_TO_ADDR
// end ;
8740: GO 8691
8742: POP
8743: POP
// for i = 1 to medics do
8744: LD_ADDR_VAR 0 1
8748: PUSH
8749: DOUBLE
8750: LD_INT 1
8752: DEC
8753: ST_TO_ADDR
8754: LD_VAR 0 8
8758: PUSH
8759: FOR_TO
8760: IFFALSE 8802
// begin PrepareScientist ( 0 , game_eskill ) ;
8762: LD_INT 0
8764: PPUSH
8765: LD_EXP 39
8769: PPUSH
8770: CALL_OW 384
// un := CreateHuman ;
8774: LD_ADDR_VAR 0 2
8778: PUSH
8779: CALL_OW 44
8783: ST_TO_ADDR
// filter := filter ^ un ;
8784: LD_ADDR_VAR 0 3
8788: PUSH
8789: LD_VAR 0 3
8793: PUSH
8794: LD_VAR 0 2
8798: ADD
8799: ST_TO_ADDR
// end ;
8800: GO 8759
8802: POP
8803: POP
// for i = 1 to vehs do
8804: LD_ADDR_VAR 0 1
8808: PUSH
8809: DOUBLE
8810: LD_INT 1
8812: DEC
8813: ST_TO_ADDR
8814: LD_VAR 0 6
8818: PUSH
8819: FOR_TO
8820: IFFALSE 9012
// begin case Rand ( 1 , 5 ) of 1 :
8822: LD_INT 1
8824: PPUSH
8825: LD_INT 5
8827: PPUSH
8828: CALL_OW 12
8832: PUSH
8833: LD_INT 1
8835: DOUBLE
8836: EQUAL
8837: IFTRUE 8841
8839: GO 8863
8841: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
8842: LD_INT 22
8844: PPUSH
8845: LD_INT 3
8847: PPUSH
8848: LD_INT 3
8850: PPUSH
8851: LD_INT 43
8853: PPUSH
8854: LD_INT 100
8856: PPUSH
8857: CALL 17694 0 5
8861: GO 8984
8863: LD_INT 2
8865: DOUBLE
8866: EQUAL
8867: IFTRUE 8871
8869: GO 8893
8871: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
8872: LD_INT 22
8874: PPUSH
8875: LD_INT 3
8877: PPUSH
8878: LD_INT 3
8880: PPUSH
8881: LD_INT 44
8883: PPUSH
8884: LD_INT 100
8886: PPUSH
8887: CALL 17694 0 5
8891: GO 8984
8893: LD_INT 3
8895: DOUBLE
8896: EQUAL
8897: IFTRUE 8901
8899: GO 8923
8901: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
8902: LD_INT 22
8904: PPUSH
8905: LD_INT 3
8907: PPUSH
8908: LD_INT 3
8910: PPUSH
8911: LD_INT 45
8913: PPUSH
8914: LD_INT 100
8916: PPUSH
8917: CALL 17694 0 5
8921: GO 8984
8923: LD_INT 4
8925: DOUBLE
8926: EQUAL
8927: IFTRUE 8931
8929: GO 8953
8931: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
8932: LD_INT 24
8934: PPUSH
8935: LD_INT 3
8937: PPUSH
8938: LD_INT 3
8940: PPUSH
8941: LD_INT 43
8943: PPUSH
8944: LD_INT 100
8946: PPUSH
8947: CALL 17694 0 5
8951: GO 8984
8953: LD_INT 5
8955: DOUBLE
8956: EQUAL
8957: IFTRUE 8961
8959: GO 8983
8961: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
8962: LD_INT 24
8964: PPUSH
8965: LD_INT 3
8967: PPUSH
8968: LD_INT 3
8970: PPUSH
8971: LD_INT 46
8973: PPUSH
8974: LD_INT 100
8976: PPUSH
8977: CALL 17694 0 5
8981: GO 8984
8983: POP
// vehicle := CreateVehicle ;
8984: LD_ADDR_VAR 0 7
8988: PUSH
8989: CALL_OW 45
8993: ST_TO_ADDR
// filter := filter ^ vehicle ;
8994: LD_ADDR_VAR 0 3
8998: PUSH
8999: LD_VAR 0 3
9003: PUSH
9004: LD_VAR 0 7
9008: ADD
9009: ST_TO_ADDR
// end ;
9010: GO 8819
9012: POP
9013: POP
// for i = 1 to filter do
9014: LD_ADDR_VAR 0 1
9018: PUSH
9019: DOUBLE
9020: LD_INT 1
9022: DEC
9023: ST_TO_ADDR
9024: LD_VAR 0 3
9028: PUSH
9029: FOR_TO
9030: IFFALSE 9055
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
9032: LD_VAR 0 3
9036: PUSH
9037: LD_VAR 0 1
9041: ARRAY
9042: PPUSH
9043: LD_INT 14
9045: PPUSH
9046: LD_INT 0
9048: PPUSH
9049: CALL_OW 49
9053: GO 9029
9055: POP
9056: POP
// case Rand ( 1 , 3 ) of 1 :
9057: LD_INT 1
9059: PPUSH
9060: LD_INT 3
9062: PPUSH
9063: CALL_OW 12
9067: PUSH
9068: LD_INT 1
9070: DOUBLE
9071: EQUAL
9072: IFTRUE 9076
9074: GO 9130
9076: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
9077: LD_ADDR_VAR 0 11
9081: PUSH
9082: LD_INT 165
9084: PUSH
9085: LD_INT 114
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: PUSH
9092: LD_INT 104
9094: PUSH
9095: LD_INT 108
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PUSH
9102: LD_INT 86
9104: PUSH
9105: LD_INT 77
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: PUSH
9112: LD_INT 63
9114: PUSH
9115: LD_INT 38
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: LIST
9126: LIST
9127: ST_TO_ADDR
9128: GO 9255
9130: LD_INT 2
9132: DOUBLE
9133: EQUAL
9134: IFTRUE 9138
9136: GO 9192
9138: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
9139: LD_ADDR_VAR 0 11
9143: PUSH
9144: LD_INT 165
9146: PUSH
9147: LD_INT 114
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: PUSH
9154: LD_INT 146
9156: PUSH
9157: LD_INT 71
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PUSH
9164: LD_INT 112
9166: PUSH
9167: LD_INT 41
9169: PUSH
9170: EMPTY
9171: LIST
9172: LIST
9173: PUSH
9174: LD_INT 63
9176: PUSH
9177: LD_INT 38
9179: PUSH
9180: EMPTY
9181: LIST
9182: LIST
9183: PUSH
9184: EMPTY
9185: LIST
9186: LIST
9187: LIST
9188: LIST
9189: ST_TO_ADDR
9190: GO 9255
9192: LD_INT 3
9194: DOUBLE
9195: EQUAL
9196: IFTRUE 9200
9198: GO 9254
9200: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
9201: LD_ADDR_VAR 0 11
9205: PUSH
9206: LD_INT 165
9208: PUSH
9209: LD_INT 114
9211: PUSH
9212: EMPTY
9213: LIST
9214: LIST
9215: PUSH
9216: LD_INT 63
9218: PUSH
9219: LD_INT 99
9221: PUSH
9222: EMPTY
9223: LIST
9224: LIST
9225: PUSH
9226: LD_INT 55
9228: PUSH
9229: LD_INT 77
9231: PUSH
9232: EMPTY
9233: LIST
9234: LIST
9235: PUSH
9236: LD_INT 63
9238: PUSH
9239: LD_INT 38
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: PUSH
9246: EMPTY
9247: LIST
9248: LIST
9249: LIST
9250: LIST
9251: ST_TO_ADDR
9252: GO 9255
9254: POP
// attackers := filter ;
9255: LD_ADDR_VAR 0 10
9259: PUSH
9260: LD_VAR 0 3
9264: ST_TO_ADDR
// flags := [ 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 ] ;
9265: LD_ADDR_VAR 0 12
9269: PUSH
9270: LD_INT 0
9272: PUSH
9273: LD_INT 1
9275: PUSH
9276: LD_INT 0
9278: PUSH
9279: LD_INT 1
9281: PUSH
9282: LD_INT 1
9284: PUSH
9285: LD_INT 0
9287: PUSH
9288: LD_INT 0
9290: PUSH
9291: LD_INT 0
9293: PUSH
9294: LD_INT 1
9296: PUSH
9297: LD_INT 1
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: LIST
9304: LIST
9305: LIST
9306: LIST
9307: LIST
9308: LIST
9309: LIST
9310: LIST
9311: ST_TO_ADDR
// MC_PrepareAttack ( 1 , attackers , _target , flags ) ;
9312: LD_INT 1
9314: PPUSH
9315: LD_VAR 0 10
9319: PPUSH
9320: LD_VAR 0 11
9324: PPUSH
9325: LD_VAR 0 12
9329: PPUSH
9330: CALL 77106 0 4
// enable ;
9334: ENABLE
// end ;
9335: PPOPN 12
9337: END
// every 0 0$1 do var i , tmp ;
9338: GO 9340
9340: DISABLE
9341: LD_INT 0
9343: PPUSH
9344: PPUSH
// begin enable ;
9345: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
9346: LD_ADDR_VAR 0 2
9350: PUSH
9351: LD_INT 3
9353: PUSH
9354: LD_INT 22
9356: PUSH
9357: LD_INT 1
9359: PUSH
9360: EMPTY
9361: LIST
9362: LIST
9363: PUSH
9364: EMPTY
9365: LIST
9366: LIST
9367: PUSH
9368: LD_INT 32
9370: PUSH
9371: LD_INT 1
9373: PUSH
9374: EMPTY
9375: LIST
9376: LIST
9377: PUSH
9378: EMPTY
9379: LIST
9380: LIST
9381: PPUSH
9382: CALL_OW 69
9386: ST_TO_ADDR
// if tmp then
9387: LD_VAR 0 2
9391: IFFALSE 9437
// for i in tmp do
9393: LD_ADDR_VAR 0 1
9397: PUSH
9398: LD_VAR 0 2
9402: PUSH
9403: FOR_IN
9404: IFFALSE 9435
// if GetFuel ( i ) < 3 then
9406: LD_VAR 0 1
9410: PPUSH
9411: CALL_OW 261
9415: PUSH
9416: LD_INT 3
9418: LESS
9419: IFFALSE 9433
// SetFuel ( i , 3 ) ;
9421: LD_VAR 0 1
9425: PPUSH
9426: LD_INT 3
9428: PPUSH
9429: CALL_OW 240
9433: GO 9403
9435: POP
9436: POP
// end ;
9437: PPOPN 2
9439: END
// every 0 0$3 trigger FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) or FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) do var i , veh , tmp ;
9440: LD_INT 3
9442: PPUSH
9443: LD_INT 22
9445: PUSH
9446: LD_INT 1
9448: PUSH
9449: EMPTY
9450: LIST
9451: LIST
9452: PPUSH
9453: CALL_OW 70
9457: PUSH
9458: LD_INT 10
9460: PPUSH
9461: LD_INT 22
9463: PUSH
9464: LD_INT 1
9466: PUSH
9467: EMPTY
9468: LIST
9469: LIST
9470: PPUSH
9471: CALL_OW 70
9475: OR
9476: IFFALSE 9742
9478: GO 9480
9480: DISABLE
9481: LD_INT 0
9483: PPUSH
9484: PPUSH
9485: PPUSH
// begin tmp := [ ] ;
9486: LD_ADDR_VAR 0 3
9490: PUSH
9491: EMPTY
9492: ST_TO_ADDR
// for i := 1 to 12 do
9493: LD_ADDR_VAR 0 1
9497: PUSH
9498: DOUBLE
9499: LD_INT 1
9501: DEC
9502: ST_TO_ADDR
9503: LD_INT 12
9505: PUSH
9506: FOR_TO
9507: IFFALSE 9646
// begin uc_side := 3 ;
9509: LD_ADDR_OWVAR 20
9513: PUSH
9514: LD_INT 3
9516: ST_TO_ADDR
// uc_nation := 3 ;
9517: LD_ADDR_OWVAR 21
9521: PUSH
9522: LD_INT 3
9524: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
9525: LD_INT 23
9527: PPUSH
9528: LD_INT 3
9530: PPUSH
9531: LD_INT 3
9533: PPUSH
9534: LD_INT 46
9536: PUSH
9537: LD_INT 43
9539: PUSH
9540: EMPTY
9541: LIST
9542: LIST
9543: PUSH
9544: LD_INT 1
9546: PPUSH
9547: LD_INT 2
9549: PPUSH
9550: CALL_OW 12
9554: ARRAY
9555: PPUSH
9556: LD_INT 100
9558: PPUSH
9559: CALL 17694 0 5
// veh := CreateVehicle ;
9563: LD_ADDR_VAR 0 2
9567: PUSH
9568: CALL_OW 45
9572: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
9573: LD_VAR 0 2
9577: PPUSH
9578: LD_INT 5
9580: PPUSH
9581: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
9585: LD_VAR 0 2
9589: PPUSH
9590: LD_INT 199
9592: PPUSH
9593: LD_INT 135
9595: PPUSH
9596: LD_INT 3
9598: PPUSH
9599: LD_INT 0
9601: PPUSH
9602: CALL_OW 50
// tmp := tmp ^ veh ;
9606: LD_ADDR_VAR 0 3
9610: PUSH
9611: LD_VAR 0 3
9615: PUSH
9616: LD_VAR 0 2
9620: ADD
9621: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
9622: LD_VAR 0 2
9626: PPUSH
9627: LD_INT 173
9629: PPUSH
9630: LD_INT 118
9632: PPUSH
9633: CALL_OW 111
// wait ( 0 0$2 ) ;
9637: LD_INT 70
9639: PPUSH
9640: CALL_OW 67
// end ;
9644: GO 9506
9646: POP
9647: POP
// repeat wait ( 0 0$1 ) ;
9648: LD_INT 35
9650: PPUSH
9651: CALL_OW 67
// for i in tmp do
9655: LD_ADDR_VAR 0 1
9659: PUSH
9660: LD_VAR 0 3
9664: PUSH
9665: FOR_IN
9666: IFFALSE 9733
// if IsDead ( i ) then
9668: LD_VAR 0 1
9672: PPUSH
9673: CALL_OW 301
9677: IFFALSE 9697
// tmp := tmp diff i else
9679: LD_ADDR_VAR 0 3
9683: PUSH
9684: LD_VAR 0 3
9688: PUSH
9689: LD_VAR 0 1
9693: DIFF
9694: ST_TO_ADDR
9695: GO 9731
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
9697: LD_VAR 0 1
9701: PPUSH
9702: LD_INT 22
9704: PUSH
9705: LD_INT 1
9707: PUSH
9708: EMPTY
9709: LIST
9710: LIST
9711: PPUSH
9712: CALL_OW 69
9716: PPUSH
9717: LD_VAR 0 1
9721: PPUSH
9722: CALL_OW 74
9726: PPUSH
9727: CALL_OW 115
9731: GO 9665
9733: POP
9734: POP
// until not tmp ;
9735: LD_VAR 0 3
9739: NOT
9740: IFFALSE 9648
// end ; end_of_file
9742: PPOPN 3
9744: END
// export Losses ; on UnitDestroyed ( un ) do begin if un = Brighton then
9745: LD_VAR 0 1
9749: PUSH
9750: LD_EXP 8
9754: EQUAL
9755: IFFALSE 9771
// begin wait ( 0 0$1 ) ;
9757: LD_INT 35
9759: PPUSH
9760: CALL_OW 67
// YouLost ( Brighton ) ;
9764: LD_STRING Brighton
9766: PPUSH
9767: CALL_OW 104
// end ; if un = JMM then
9771: LD_VAR 0 1
9775: PUSH
9776: LD_EXP 36
9780: EQUAL
9781: IFFALSE 9797
// begin wait ( 0 0$1 ) ;
9783: LD_INT 35
9785: PPUSH
9786: CALL_OW 67
// YouLost ( JMM ) ;
9790: LD_STRING JMM
9792: PPUSH
9793: CALL_OW 104
// end ; if un = Megan then
9797: LD_VAR 0 1
9801: PUSH
9802: LD_EXP 10
9806: EQUAL
9807: IFFALSE 9821
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
9809: LD_EXP 8
9813: PPUSH
9814: LD_STRING DBrighton-MeganDeath
9816: PPUSH
9817: CALL_OW 88
// end ; if un = Palmer then
9821: LD_VAR 0 1
9825: PUSH
9826: LD_EXP 9
9830: EQUAL
9831: IFFALSE 9845
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
9833: LD_EXP 8
9837: PPUSH
9838: LD_STRING DBrighton-PalmerDeath
9840: PPUSH
9841: CALL_OW 88
// end ; if un = Burlak then
9845: LD_VAR 0 1
9849: PUSH
9850: LD_EXP 18
9854: EQUAL
9855: IFFALSE 9887
// begin if JMM_Arrived then
9857: LD_EXP 5
9861: IFFALSE 9875
// Say ( JMM , DJMM-BurlakDead ) ;
9863: LD_EXP 36
9867: PPUSH
9868: LD_STRING DJMM-BurlakDead
9870: PPUSH
9871: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
9875: LD_EXP 9
9879: PPUSH
9880: LD_STRING DSol-BurlakDead
9882: PPUSH
9883: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
9887: LD_VAR 0 1
9891: PUSH
9892: LD_INT 1
9894: EQUAL
9895: PUSH
9896: LD_VAR 0 1
9900: PUSH
9901: LD_INT 3
9903: EQUAL
9904: OR
9905: IFFALSE 9921
// begin wait ( 0 0$1 ) ;
9907: LD_INT 35
9909: PPUSH
9910: CALL_OW 67
// YouLost ( Depot ) ;
9914: LD_STRING Depot
9916: PPUSH
9917: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
9921: LD_VAR 0 1
9925: PPUSH
9926: CALL_OW 255
9930: PUSH
9931: LD_INT 1
9933: EQUAL
9934: PUSH
9935: LD_VAR 0 1
9939: PPUSH
9940: CALL_OW 247
9944: PUSH
9945: LD_INT 1
9947: EQUAL
9948: AND
9949: IFFALSE 9965
// Losses := Losses + 1 ;
9951: LD_ADDR_EXP 43
9955: PUSH
9956: LD_EXP 43
9960: PUSH
9961: LD_INT 1
9963: PLUS
9964: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
9965: LD_VAR 0 1
9969: PPUSH
9970: CALL 80250 0 1
// end ;
9974: PPOPN 1
9976: END
// on UnitGoesToRed ( un ) do begin if un = Yashin then
9977: LD_VAR 0 1
9981: PUSH
9982: LD_EXP 12
9986: EQUAL
9987: IFFALSE 10001
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
9989: LD_EXP 12
9993: PPUSH
9994: LD_STRING DDeath-Yas-3
9996: PPUSH
9997: CALL_OW 91
// if un = Popov then
10001: LD_VAR 0 1
10005: PUSH
10006: LD_EXP 13
10010: EQUAL
10011: IFFALSE 10025
// ForceSay ( Popov , DDeath-Pop-3 ) ;
10013: LD_EXP 13
10017: PPUSH
10018: LD_STRING DDeath-Pop-3
10020: PPUSH
10021: CALL_OW 91
// if un = Gaydar then
10025: LD_VAR 0 1
10029: PUSH
10030: LD_EXP 14
10034: EQUAL
10035: IFFALSE 10049
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
10037: LD_EXP 14
10041: PPUSH
10042: LD_STRING DDeath-Gay-3
10044: PPUSH
10045: CALL_OW 91
// if un = Sevi then
10049: LD_VAR 0 1
10053: PUSH
10054: LD_EXP 15
10058: EQUAL
10059: IFFALSE 10073
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
10061: LD_EXP 15
10065: PPUSH
10066: LD_STRING DDeath-Vse-3
10068: PPUSH
10069: CALL_OW 91
// end ;
10073: PPOPN 1
10075: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
10076: LD_VAR 0 1
10080: PUSH
10081: LD_INT 10
10083: EQUAL
10084: IFFALSE 10122
// begin Say ( Brighton , DBrighton-C1 ) ;
10086: LD_EXP 8
10090: PPUSH
10091: LD_STRING DBrighton-C1
10093: PPUSH
10094: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
10098: LD_EXP 10
10102: PPUSH
10103: LD_STRING DMegan-C1
10105: PPUSH
10106: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
10110: LD_EXP 8
10114: PPUSH
10115: LD_STRING DBrighton-C2
10117: PPUSH
10118: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
10122: LD_VAR 0 1
10126: PPUSH
10127: LD_VAR 0 2
10131: PPUSH
10132: CALL 79946 0 2
// end ;
10136: PPOPN 2
10138: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10139: LD_VAR 0 1
10143: PPUSH
10144: LD_VAR 0 2
10148: PPUSH
10149: CALL 82305 0 2
// end ;
10153: PPOPN 2
10155: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10156: LD_VAR 0 1
10160: PPUSH
10161: CALL 81373 0 1
// end ;
10165: PPOPN 1
10167: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
10168: LD_VAR 0 1
10172: PPUSH
10173: CALL_OW 266
10177: PUSH
10178: LD_INT 0
10180: EQUAL
10181: PUSH
10182: LD_VAR 0 1
10186: PPUSH
10187: CALL_OW 255
10191: PUSH
10192: LD_INT 3
10194: EQUAL
10195: AND
10196: IFFALSE 10258
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
10198: LD_VAR 0 1
10202: PPUSH
10203: CALL_OW 274
10207: PPUSH
10208: LD_INT 1
10210: PPUSH
10211: LD_INT 10000
10213: PPUSH
10214: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
10218: LD_VAR 0 1
10222: PPUSH
10223: CALL_OW 274
10227: PPUSH
10228: LD_INT 2
10230: PPUSH
10231: LD_INT 250
10233: PPUSH
10234: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
10238: LD_VAR 0 1
10242: PPUSH
10243: CALL_OW 274
10247: PPUSH
10248: LD_INT 3
10250: PPUSH
10251: LD_INT 100
10253: PPUSH
10254: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
10258: LD_VAR 0 1
10262: PPUSH
10263: CALL 81614 0 1
// end ;
10267: PPOPN 1
10269: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10270: LD_VAR 0 1
10274: PPUSH
10275: LD_VAR 0 2
10279: PPUSH
10280: LD_VAR 0 3
10284: PPUSH
10285: LD_VAR 0 4
10289: PPUSH
10290: LD_VAR 0 5
10294: PPUSH
10295: CALL 79566 0 5
// end ;
10299: PPOPN 5
10301: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10302: LD_VAR 0 1
10306: PPUSH
10307: LD_VAR 0 2
10311: PPUSH
10312: CALL 79162 0 2
// end ;
10316: PPOPN 2
10318: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10319: LD_VAR 0 1
10323: PPUSH
10324: LD_VAR 0 2
10328: PPUSH
10329: LD_VAR 0 3
10333: PPUSH
10334: LD_VAR 0 4
10338: PPUSH
10339: CALL 79000 0 4
// end ;
10343: PPOPN 4
10345: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10346: LD_VAR 0 1
10350: PPUSH
10351: LD_VAR 0 2
10355: PPUSH
10356: LD_VAR 0 3
10360: PPUSH
10361: CALL 78775 0 3
// end ;
10365: PPOPN 3
10367: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10368: LD_VAR 0 1
10372: PPUSH
10373: LD_VAR 0 2
10377: PPUSH
10378: CALL 78660 0 2
// end ;
10382: PPOPN 2
10384: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10385: LD_VAR 0 1
10389: PPUSH
10390: LD_VAR 0 2
10394: PPUSH
10395: CALL 82566 0 2
// end ;
10399: PPOPN 2
10401: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
10402: LD_VAR 0 1
10406: PPUSH
10407: CALL_OW 255
10411: PUSH
10412: LD_INT 6
10414: EQUAL
10415: IFFALSE 10545
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
10417: LD_VAR 0 1
10421: PUSH
10422: LD_EXP 12
10426: PUSH
10427: LD_EXP 15
10431: PUSH
10432: LD_EXP 14
10436: PUSH
10437: LD_EXP 13
10441: PUSH
10442: EMPTY
10443: LIST
10444: LIST
10445: LIST
10446: LIST
10447: IN
10448: IFFALSE 10452
// exit ;
10450: GO 10569
// if AssaultStarted then
10452: LD_EXP 7
10456: IFFALSE 10530
// case Rand ( 1 , 4 ) of 1 .. 3 :
10458: LD_INT 1
10460: PPUSH
10461: LD_INT 4
10463: PPUSH
10464: CALL_OW 12
10468: PUSH
10469: LD_INT 1
10471: DOUBLE
10472: GREATEREQUAL
10473: IFFALSE 10481
10475: LD_INT 3
10477: DOUBLE
10478: LESSEQUAL
10479: IFTRUE 10483
10481: GO 10501
10483: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
10484: LD_VAR 0 1
10488: PPUSH
10489: LD_INT 67
10491: PPUSH
10492: LD_INT 37
10494: PPUSH
10495: CALL_OW 114
10499: GO 10528
10501: LD_INT 4
10503: DOUBLE
10504: EQUAL
10505: IFTRUE 10509
10507: GO 10527
10509: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
10510: LD_VAR 0 1
10514: PPUSH
10515: LD_INT 120
10517: PPUSH
10518: LD_INT 131
10520: PPUSH
10521: CALL_OW 111
10525: GO 10528
10527: POP
10528: GO 10545
// ComMoveXY ( driver , 120 , 131 ) ;
10530: LD_VAR 0 1
10534: PPUSH
10535: LD_INT 120
10537: PPUSH
10538: LD_INT 131
10540: PPUSH
10541: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10545: LD_VAR 0 1
10549: PPUSH
10550: LD_VAR 0 2
10554: PPUSH
10555: LD_VAR 0 3
10559: PPUSH
10560: LD_VAR 0 4
10564: PPUSH
10565: CALL 82782 0 4
// end ;
10569: PPOPN 4
10571: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10572: LD_VAR 0 1
10576: PPUSH
10577: LD_VAR 0 2
10581: PPUSH
10582: CALL 78469 0 2
// end ;
10586: PPOPN 2
10588: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10589: LD_VAR 0 1
10593: PPUSH
10594: CALL 83021 0 1
// end ; end_of_file
10598: PPOPN 1
10600: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
10601: LD_EXP 5
10605: PUSH
10606: LD_EXP 42
10610: AND
10611: IFFALSE 10792
10613: GO 10615
10615: DISABLE
// begin wait ( 0 0$2 ) ;
10616: LD_INT 70
10618: PPUSH
10619: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
10623: LD_EXP 8
10627: PPUSH
10628: LD_STRING DBrighton-G1
10630: PPUSH
10631: CALL_OW 88
// if Losses < 1 then
10635: LD_EXP 43
10639: PUSH
10640: LD_INT 1
10642: LESS
10643: IFFALSE 10657
// AddMedal ( Losses , 1 ) else
10645: LD_STRING Losses
10647: PPUSH
10648: LD_INT 1
10650: PPUSH
10651: CALL_OW 101
10655: GO 10690
// if Losses < 5 then
10657: LD_EXP 43
10661: PUSH
10662: LD_INT 5
10664: LESS
10665: IFFALSE 10679
// AddMedal ( Losses , 2 ) else
10667: LD_STRING Losses
10669: PPUSH
10670: LD_INT 2
10672: PPUSH
10673: CALL_OW 101
10677: GO 10690
// AddMedal ( Losses , - 1 ) ;
10679: LD_STRING Losses
10681: PPUSH
10682: LD_INT 1
10684: NEG
10685: PPUSH
10686: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
10690: LD_EXP 6
10694: PUSH
10695: LD_INT 10
10697: PPUSH
10698: LD_INT 1
10700: PPUSH
10701: CALL_OW 321
10705: PUSH
10706: LD_INT 2
10708: EQUAL
10709: AND
10710: IFFALSE 10724
// AddMedal ( Laser , 1 ) else
10712: LD_STRING Laser
10714: PPUSH
10715: LD_INT 1
10717: PPUSH
10718: CALL_OW 101
10722: GO 10771
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
10724: LD_EXP 6
10728: NOT
10729: PUSH
10730: LD_INT 10
10732: PPUSH
10733: LD_INT 1
10735: PPUSH
10736: CALL_OW 321
10740: PUSH
10741: LD_INT 2
10743: EQUAL
10744: AND
10745: IFFALSE 10760
// AddMedal ( Laser , - 1 ) else
10747: LD_STRING Laser
10749: PPUSH
10750: LD_INT 1
10752: NEG
10753: PPUSH
10754: CALL_OW 101
10758: GO 10771
// AddMedal ( Laser , - 2 ) ;
10760: LD_STRING Laser
10762: PPUSH
10763: LD_INT 2
10765: NEG
10766: PPUSH
10767: CALL_OW 101
// AddMedal ( med3 , 1 ) ;
10771: LD_STRING med3
10773: PPUSH
10774: LD_INT 1
10776: PPUSH
10777: CALL_OW 101
// GiveMedals ( BaseMain ) ;
10781: LD_STRING BaseMain
10783: PPUSH
10784: CALL_OW 102
// YouWin ;
10788: CALL_OW 103
// end ; end_of_file
10792: END
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
10793: LD_INT 0
10795: PPUSH
10796: PPUSH
// area = ListEnvironmentArea ( area ) ;
10797: LD_ADDR_VAR 0 2
10801: PUSH
10802: LD_VAR 0 2
10806: PPUSH
10807: CALL_OW 353
10811: ST_TO_ADDR
// if bulldozer > 0 then
10812: LD_VAR 0 1
10816: PUSH
10817: LD_INT 0
10819: GREATER
10820: IFFALSE 10931
// for i = area downto 1 do
10822: LD_ADDR_VAR 0 4
10826: PUSH
10827: DOUBLE
10828: LD_VAR 0 2
10832: INC
10833: ST_TO_ADDR
10834: LD_INT 1
10836: PUSH
10837: FOR_DOWNTO
10838: IFFALSE 10929
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
10840: LD_VAR 0 2
10844: PUSH
10845: LD_VAR 0 4
10849: ARRAY
10850: PUSH
10851: LD_INT 1
10853: ARRAY
10854: PPUSH
10855: LD_VAR 0 2
10859: PUSH
10860: LD_VAR 0 4
10864: ARRAY
10865: PUSH
10866: LD_INT 2
10868: ARRAY
10869: PPUSH
10870: CALL_OW 351
10874: IFFALSE 10927
// if not HasTask ( bulldozer ) then
10876: LD_VAR 0 1
10880: PPUSH
10881: CALL_OW 314
10885: NOT
10886: IFFALSE 10927
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
10888: LD_VAR 0 1
10892: PPUSH
10893: LD_VAR 0 2
10897: PUSH
10898: LD_VAR 0 4
10902: ARRAY
10903: PUSH
10904: LD_INT 1
10906: ARRAY
10907: PPUSH
10908: LD_VAR 0 2
10912: PUSH
10913: LD_VAR 0 4
10917: ARRAY
10918: PUSH
10919: LD_INT 2
10921: ARRAY
10922: PPUSH
10923: CALL_OW 171
10927: GO 10837
10929: POP
10930: POP
// end ;
10931: LD_VAR 0 3
10935: RET
// export function ComMeeting ( team , area ) ; var i , tmp ; begin
10936: LD_INT 0
10938: PPUSH
10939: PPUSH
10940: PPUSH
// tmp := AreaToList ( area , 0 ) ;
10941: LD_ADDR_VAR 0 5
10945: PUSH
10946: LD_VAR 0 2
10950: PPUSH
10951: LD_INT 0
10953: PPUSH
10954: CALL_OW 517
10958: ST_TO_ADDR
// for i = 1 to team do
10959: LD_ADDR_VAR 0 4
10963: PUSH
10964: DOUBLE
10965: LD_INT 1
10967: DEC
10968: ST_TO_ADDR
10969: LD_VAR 0 1
10973: PUSH
10974: FOR_TO
10975: IFFALSE 11076
// begin if IsInUnit ( team [ i ] ) then
10977: LD_VAR 0 1
10981: PUSH
10982: LD_VAR 0 4
10986: ARRAY
10987: PPUSH
10988: CALL_OW 310
10992: IFFALSE 11009
// ComExitBuilding ( team [ i ] ) ;
10994: LD_VAR 0 1
10998: PUSH
10999: LD_VAR 0 4
11003: ARRAY
11004: PPUSH
11005: CALL_OW 122
// AddComMoveXY ( team [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
11009: LD_VAR 0 1
11013: PUSH
11014: LD_VAR 0 4
11018: ARRAY
11019: PPUSH
11020: LD_VAR 0 5
11024: PUSH
11025: LD_INT 1
11027: ARRAY
11028: PUSH
11029: LD_VAR 0 4
11033: ARRAY
11034: PPUSH
11035: LD_VAR 0 5
11039: PUSH
11040: LD_INT 2
11042: ARRAY
11043: PUSH
11044: LD_VAR 0 4
11048: ARRAY
11049: PPUSH
11050: CALL_OW 171
// AddComTurnUnit ( team [ i ] , Brighton ) ;
11054: LD_VAR 0 1
11058: PUSH
11059: LD_VAR 0 4
11063: ARRAY
11064: PPUSH
11065: LD_EXP 8
11069: PPUSH
11070: CALL_OW 179
// end ;
11074: GO 10974
11076: POP
11077: POP
// end ; end_of_file
11078: LD_VAR 0 3
11082: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11083: LD_INT 0
11085: PPUSH
11086: PPUSH
// if exist_mode then
11087: LD_VAR 0 2
11091: IFFALSE 11116
// unit := CreateCharacter ( prefix & ident ) else
11093: LD_ADDR_VAR 0 5
11097: PUSH
11098: LD_VAR 0 3
11102: PUSH
11103: LD_VAR 0 1
11107: STR
11108: PPUSH
11109: CALL_OW 34
11113: ST_TO_ADDR
11114: GO 11131
// unit := NewCharacter ( ident ) ;
11116: LD_ADDR_VAR 0 5
11120: PUSH
11121: LD_VAR 0 1
11125: PPUSH
11126: CALL_OW 25
11130: ST_TO_ADDR
// result := unit ;
11131: LD_ADDR_VAR 0 4
11135: PUSH
11136: LD_VAR 0 5
11140: ST_TO_ADDR
// end ;
11141: LD_VAR 0 4
11145: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11146: LD_INT 0
11148: PPUSH
11149: PPUSH
// if not side or not nation then
11150: LD_VAR 0 1
11154: NOT
11155: PUSH
11156: LD_VAR 0 2
11160: NOT
11161: OR
11162: IFFALSE 11166
// exit ;
11164: GO 11810
// case nation of nation_american :
11166: LD_VAR 0 2
11170: PUSH
11171: LD_INT 1
11173: DOUBLE
11174: EQUAL
11175: IFTRUE 11179
11177: GO 11353
11179: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
11180: LD_ADDR_VAR 0 4
11184: PUSH
11185: LD_INT 35
11187: PUSH
11188: LD_INT 45
11190: PUSH
11191: LD_INT 46
11193: PUSH
11194: LD_INT 47
11196: PUSH
11197: LD_INT 1
11199: PUSH
11200: LD_INT 2
11202: PUSH
11203: LD_INT 6
11205: PUSH
11206: LD_INT 15
11208: PUSH
11209: LD_INT 16
11211: PUSH
11212: LD_INT 7
11214: PUSH
11215: LD_INT 12
11217: PUSH
11218: LD_INT 13
11220: PUSH
11221: LD_INT 10
11223: PUSH
11224: LD_INT 14
11226: PUSH
11227: LD_INT 20
11229: PUSH
11230: LD_INT 21
11232: PUSH
11233: LD_INT 22
11235: PUSH
11236: LD_INT 25
11238: PUSH
11239: LD_INT 32
11241: PUSH
11242: LD_INT 27
11244: PUSH
11245: LD_INT 36
11247: PUSH
11248: LD_INT 69
11250: PUSH
11251: LD_INT 39
11253: PUSH
11254: LD_INT 34
11256: PUSH
11257: LD_INT 40
11259: PUSH
11260: LD_INT 48
11262: PUSH
11263: LD_INT 49
11265: PUSH
11266: LD_INT 50
11268: PUSH
11269: LD_INT 51
11271: PUSH
11272: LD_INT 52
11274: PUSH
11275: LD_INT 53
11277: PUSH
11278: LD_INT 54
11280: PUSH
11281: LD_INT 55
11283: PUSH
11284: LD_INT 56
11286: PUSH
11287: LD_INT 57
11289: PUSH
11290: LD_INT 58
11292: PUSH
11293: LD_INT 59
11295: PUSH
11296: LD_INT 60
11298: PUSH
11299: LD_INT 61
11301: PUSH
11302: LD_INT 62
11304: PUSH
11305: LD_INT 80
11307: PUSH
11308: EMPTY
11309: LIST
11310: LIST
11311: LIST
11312: LIST
11313: LIST
11314: LIST
11315: LIST
11316: LIST
11317: LIST
11318: LIST
11319: LIST
11320: LIST
11321: LIST
11322: LIST
11323: LIST
11324: LIST
11325: LIST
11326: LIST
11327: LIST
11328: LIST
11329: LIST
11330: LIST
11331: LIST
11332: LIST
11333: LIST
11334: LIST
11335: LIST
11336: LIST
11337: LIST
11338: LIST
11339: LIST
11340: LIST
11341: LIST
11342: LIST
11343: LIST
11344: LIST
11345: LIST
11346: LIST
11347: LIST
11348: LIST
11349: LIST
11350: ST_TO_ADDR
11351: GO 11734
11353: LD_INT 2
11355: DOUBLE
11356: EQUAL
11357: IFTRUE 11361
11359: GO 11543
11361: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
11362: LD_ADDR_VAR 0 4
11366: PUSH
11367: LD_INT 35
11369: PUSH
11370: LD_INT 45
11372: PUSH
11373: LD_INT 46
11375: PUSH
11376: LD_INT 47
11378: PUSH
11379: LD_INT 70
11381: PUSH
11382: LD_INT 1
11384: PUSH
11385: LD_INT 11
11387: PUSH
11388: LD_INT 3
11390: PUSH
11391: LD_INT 4
11393: PUSH
11394: LD_INT 5
11396: PUSH
11397: LD_INT 6
11399: PUSH
11400: LD_INT 15
11402: PUSH
11403: LD_INT 18
11405: PUSH
11406: LD_INT 7
11408: PUSH
11409: LD_INT 17
11411: PUSH
11412: LD_INT 8
11414: PUSH
11415: LD_INT 20
11417: PUSH
11418: LD_INT 21
11420: PUSH
11421: LD_INT 22
11423: PUSH
11424: LD_INT 72
11426: PUSH
11427: LD_INT 26
11429: PUSH
11430: LD_INT 69
11432: PUSH
11433: LD_INT 39
11435: PUSH
11436: LD_INT 40
11438: PUSH
11439: LD_INT 41
11441: PUSH
11442: LD_INT 42
11444: PUSH
11445: LD_INT 43
11447: PUSH
11448: LD_INT 48
11450: PUSH
11451: LD_INT 49
11453: PUSH
11454: LD_INT 50
11456: PUSH
11457: LD_INT 51
11459: PUSH
11460: LD_INT 52
11462: PUSH
11463: LD_INT 53
11465: PUSH
11466: LD_INT 54
11468: PUSH
11469: LD_INT 55
11471: PUSH
11472: LD_INT 56
11474: PUSH
11475: LD_INT 60
11477: PUSH
11478: LD_INT 61
11480: PUSH
11481: LD_INT 62
11483: PUSH
11484: LD_INT 66
11486: PUSH
11487: LD_INT 67
11489: PUSH
11490: LD_INT 68
11492: PUSH
11493: LD_INT 81
11495: PUSH
11496: EMPTY
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: ST_TO_ADDR
11541: GO 11734
11543: LD_INT 3
11545: DOUBLE
11546: EQUAL
11547: IFTRUE 11551
11549: GO 11733
11551: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
11552: LD_ADDR_VAR 0 4
11556: PUSH
11557: LD_INT 46
11559: PUSH
11560: LD_INT 47
11562: PUSH
11563: LD_INT 1
11565: PUSH
11566: LD_INT 2
11568: PUSH
11569: LD_INT 11
11571: PUSH
11572: LD_INT 9
11574: PUSH
11575: LD_INT 20
11577: PUSH
11578: LD_INT 19
11580: PUSH
11581: LD_INT 21
11583: PUSH
11584: LD_INT 24
11586: PUSH
11587: LD_INT 22
11589: PUSH
11590: LD_INT 25
11592: PUSH
11593: LD_INT 28
11595: PUSH
11596: LD_INT 29
11598: PUSH
11599: LD_INT 30
11601: PUSH
11602: LD_INT 31
11604: PUSH
11605: LD_INT 37
11607: PUSH
11608: LD_INT 38
11610: PUSH
11611: LD_INT 32
11613: PUSH
11614: LD_INT 27
11616: PUSH
11617: LD_INT 33
11619: PUSH
11620: LD_INT 69
11622: PUSH
11623: LD_INT 39
11625: PUSH
11626: LD_INT 34
11628: PUSH
11629: LD_INT 40
11631: PUSH
11632: LD_INT 71
11634: PUSH
11635: LD_INT 23
11637: PUSH
11638: LD_INT 44
11640: PUSH
11641: LD_INT 48
11643: PUSH
11644: LD_INT 49
11646: PUSH
11647: LD_INT 50
11649: PUSH
11650: LD_INT 51
11652: PUSH
11653: LD_INT 52
11655: PUSH
11656: LD_INT 53
11658: PUSH
11659: LD_INT 54
11661: PUSH
11662: LD_INT 55
11664: PUSH
11665: LD_INT 56
11667: PUSH
11668: LD_INT 57
11670: PUSH
11671: LD_INT 58
11673: PUSH
11674: LD_INT 59
11676: PUSH
11677: LD_INT 63
11679: PUSH
11680: LD_INT 64
11682: PUSH
11683: LD_INT 65
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: LIST
11690: LIST
11691: LIST
11692: LIST
11693: LIST
11694: LIST
11695: LIST
11696: LIST
11697: LIST
11698: LIST
11699: LIST
11700: LIST
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: LIST
11712: LIST
11713: LIST
11714: LIST
11715: LIST
11716: LIST
11717: LIST
11718: LIST
11719: LIST
11720: LIST
11721: LIST
11722: LIST
11723: LIST
11724: LIST
11725: LIST
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: ST_TO_ADDR
11731: GO 11734
11733: POP
// if state > - 1 and state < 3 then
11734: LD_VAR 0 3
11738: PUSH
11739: LD_INT 1
11741: NEG
11742: GREATER
11743: PUSH
11744: LD_VAR 0 3
11748: PUSH
11749: LD_INT 3
11751: LESS
11752: AND
11753: IFFALSE 11810
// for i in result do
11755: LD_ADDR_VAR 0 5
11759: PUSH
11760: LD_VAR 0 4
11764: PUSH
11765: FOR_IN
11766: IFFALSE 11808
// if GetTech ( i , side ) <> state then
11768: LD_VAR 0 5
11772: PPUSH
11773: LD_VAR 0 1
11777: PPUSH
11778: CALL_OW 321
11782: PUSH
11783: LD_VAR 0 3
11787: NONEQUAL
11788: IFFALSE 11806
// result := result diff i ;
11790: LD_ADDR_VAR 0 4
11794: PUSH
11795: LD_VAR 0 4
11799: PUSH
11800: LD_VAR 0 5
11804: DIFF
11805: ST_TO_ADDR
11806: GO 11765
11808: POP
11809: POP
// end ;
11810: LD_VAR 0 4
11814: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11815: LD_INT 0
11817: PPUSH
11818: PPUSH
11819: PPUSH
// result := true ;
11820: LD_ADDR_VAR 0 3
11824: PUSH
11825: LD_INT 1
11827: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11828: LD_ADDR_VAR 0 5
11832: PUSH
11833: LD_VAR 0 2
11837: PPUSH
11838: CALL_OW 480
11842: ST_TO_ADDR
// if not tmp then
11843: LD_VAR 0 5
11847: NOT
11848: IFFALSE 11852
// exit ;
11850: GO 11901
// for i in tmp do
11852: LD_ADDR_VAR 0 4
11856: PUSH
11857: LD_VAR 0 5
11861: PUSH
11862: FOR_IN
11863: IFFALSE 11899
// if GetTech ( i , side ) <> state_researched then
11865: LD_VAR 0 4
11869: PPUSH
11870: LD_VAR 0 1
11874: PPUSH
11875: CALL_OW 321
11879: PUSH
11880: LD_INT 2
11882: NONEQUAL
11883: IFFALSE 11897
// begin result := false ;
11885: LD_ADDR_VAR 0 3
11889: PUSH
11890: LD_INT 0
11892: ST_TO_ADDR
// exit ;
11893: POP
11894: POP
11895: GO 11901
// end ;
11897: GO 11862
11899: POP
11900: POP
// end ;
11901: LD_VAR 0 3
11905: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
11906: LD_INT 0
11908: PPUSH
11909: PPUSH
11910: PPUSH
11911: PPUSH
11912: PPUSH
11913: PPUSH
11914: PPUSH
11915: PPUSH
11916: PPUSH
11917: PPUSH
11918: PPUSH
11919: PPUSH
11920: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
11921: LD_VAR 0 1
11925: NOT
11926: PUSH
11927: LD_VAR 0 1
11931: PPUSH
11932: CALL_OW 257
11936: PUSH
11937: LD_INT 9
11939: NONEQUAL
11940: OR
11941: IFFALSE 11945
// exit ;
11943: GO 12518
// side := GetSide ( unit ) ;
11945: LD_ADDR_VAR 0 9
11949: PUSH
11950: LD_VAR 0 1
11954: PPUSH
11955: CALL_OW 255
11959: ST_TO_ADDR
// tech_space := tech_spacanom ;
11960: LD_ADDR_VAR 0 12
11964: PUSH
11965: LD_INT 29
11967: ST_TO_ADDR
// tech_time := tech_taurad ;
11968: LD_ADDR_VAR 0 13
11972: PUSH
11973: LD_INT 28
11975: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
11976: LD_ADDR_VAR 0 11
11980: PUSH
11981: LD_VAR 0 1
11985: PPUSH
11986: CALL_OW 310
11990: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
11991: LD_VAR 0 11
11995: PPUSH
11996: CALL_OW 247
12000: PUSH
12001: LD_INT 2
12003: EQUAL
12004: IFFALSE 12008
// exit ;
12006: GO 12518
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12008: LD_ADDR_VAR 0 8
12012: PUSH
12013: LD_INT 81
12015: PUSH
12016: LD_VAR 0 9
12020: PUSH
12021: EMPTY
12022: LIST
12023: LIST
12024: PUSH
12025: LD_INT 3
12027: PUSH
12028: LD_INT 21
12030: PUSH
12031: LD_INT 3
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: EMPTY
12039: LIST
12040: LIST
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PPUSH
12046: CALL_OW 69
12050: ST_TO_ADDR
// if not tmp then
12051: LD_VAR 0 8
12055: NOT
12056: IFFALSE 12060
// exit ;
12058: GO 12518
// if in_unit then
12060: LD_VAR 0 11
12064: IFFALSE 12088
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12066: LD_ADDR_VAR 0 10
12070: PUSH
12071: LD_VAR 0 8
12075: PPUSH
12076: LD_VAR 0 11
12080: PPUSH
12081: CALL_OW 74
12085: ST_TO_ADDR
12086: GO 12108
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12088: LD_ADDR_VAR 0 10
12092: PUSH
12093: LD_VAR 0 8
12097: PPUSH
12098: LD_VAR 0 1
12102: PPUSH
12103: CALL_OW 74
12107: ST_TO_ADDR
// if not enemy then
12108: LD_VAR 0 10
12112: NOT
12113: IFFALSE 12117
// exit ;
12115: GO 12518
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12117: LD_VAR 0 11
12121: PUSH
12122: LD_VAR 0 11
12126: PPUSH
12127: LD_VAR 0 10
12131: PPUSH
12132: CALL_OW 296
12136: PUSH
12137: LD_INT 13
12139: GREATER
12140: AND
12141: PUSH
12142: LD_VAR 0 1
12146: PPUSH
12147: LD_VAR 0 10
12151: PPUSH
12152: CALL_OW 296
12156: PUSH
12157: LD_INT 12
12159: GREATER
12160: OR
12161: IFFALSE 12165
// exit ;
12163: GO 12518
// missile := [ 1 ] ;
12165: LD_ADDR_VAR 0 14
12169: PUSH
12170: LD_INT 1
12172: PUSH
12173: EMPTY
12174: LIST
12175: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12176: LD_VAR 0 9
12180: PPUSH
12181: LD_VAR 0 12
12185: PPUSH
12186: CALL_OW 325
12190: IFFALSE 12219
// missile := Insert ( missile , missile + 1 , 2 ) ;
12192: LD_ADDR_VAR 0 14
12196: PUSH
12197: LD_VAR 0 14
12201: PPUSH
12202: LD_VAR 0 14
12206: PUSH
12207: LD_INT 1
12209: PLUS
12210: PPUSH
12211: LD_INT 2
12213: PPUSH
12214: CALL_OW 2
12218: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12219: LD_VAR 0 9
12223: PPUSH
12224: LD_VAR 0 13
12228: PPUSH
12229: CALL_OW 325
12233: PUSH
12234: LD_VAR 0 10
12238: PPUSH
12239: CALL_OW 255
12243: PPUSH
12244: LD_VAR 0 13
12248: PPUSH
12249: CALL_OW 325
12253: NOT
12254: AND
12255: IFFALSE 12284
// missile := Insert ( missile , missile + 1 , 3 ) ;
12257: LD_ADDR_VAR 0 14
12261: PUSH
12262: LD_VAR 0 14
12266: PPUSH
12267: LD_VAR 0 14
12271: PUSH
12272: LD_INT 1
12274: PLUS
12275: PPUSH
12276: LD_INT 3
12278: PPUSH
12279: CALL_OW 2
12283: ST_TO_ADDR
// if missile < 2 then
12284: LD_VAR 0 14
12288: PUSH
12289: LD_INT 2
12291: LESS
12292: IFFALSE 12296
// exit ;
12294: GO 12518
// x := GetX ( enemy ) ;
12296: LD_ADDR_VAR 0 4
12300: PUSH
12301: LD_VAR 0 10
12305: PPUSH
12306: CALL_OW 250
12310: ST_TO_ADDR
// y := GetY ( enemy ) ;
12311: LD_ADDR_VAR 0 5
12315: PUSH
12316: LD_VAR 0 10
12320: PPUSH
12321: CALL_OW 251
12325: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12326: LD_ADDR_VAR 0 6
12330: PUSH
12331: LD_VAR 0 4
12335: PUSH
12336: LD_INT 1
12338: NEG
12339: PPUSH
12340: LD_INT 1
12342: PPUSH
12343: CALL_OW 12
12347: PLUS
12348: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12349: LD_ADDR_VAR 0 7
12353: PUSH
12354: LD_VAR 0 5
12358: PUSH
12359: LD_INT 1
12361: NEG
12362: PPUSH
12363: LD_INT 1
12365: PPUSH
12366: CALL_OW 12
12370: PLUS
12371: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12372: LD_VAR 0 6
12376: PPUSH
12377: LD_VAR 0 7
12381: PPUSH
12382: CALL_OW 488
12386: NOT
12387: IFFALSE 12409
// begin _x := x ;
12389: LD_ADDR_VAR 0 6
12393: PUSH
12394: LD_VAR 0 4
12398: ST_TO_ADDR
// _y := y ;
12399: LD_ADDR_VAR 0 7
12403: PUSH
12404: LD_VAR 0 5
12408: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12409: LD_ADDR_VAR 0 3
12413: PUSH
12414: LD_INT 1
12416: PPUSH
12417: LD_VAR 0 14
12421: PPUSH
12422: CALL_OW 12
12426: ST_TO_ADDR
// case i of 1 :
12427: LD_VAR 0 3
12431: PUSH
12432: LD_INT 1
12434: DOUBLE
12435: EQUAL
12436: IFTRUE 12440
12438: GO 12457
12440: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12441: LD_VAR 0 1
12445: PPUSH
12446: LD_VAR 0 10
12450: PPUSH
12451: CALL_OW 115
12455: GO 12518
12457: LD_INT 2
12459: DOUBLE
12460: EQUAL
12461: IFTRUE 12465
12463: GO 12487
12465: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12466: LD_VAR 0 1
12470: PPUSH
12471: LD_VAR 0 6
12475: PPUSH
12476: LD_VAR 0 7
12480: PPUSH
12481: CALL_OW 153
12485: GO 12518
12487: LD_INT 3
12489: DOUBLE
12490: EQUAL
12491: IFTRUE 12495
12493: GO 12517
12495: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12496: LD_VAR 0 1
12500: PPUSH
12501: LD_VAR 0 6
12505: PPUSH
12506: LD_VAR 0 7
12510: PPUSH
12511: CALL_OW 154
12515: GO 12518
12517: POP
// end ;
12518: LD_VAR 0 2
12522: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12523: LD_INT 0
12525: PPUSH
12526: PPUSH
12527: PPUSH
12528: PPUSH
12529: PPUSH
12530: PPUSH
// if not unit or not building then
12531: LD_VAR 0 1
12535: NOT
12536: PUSH
12537: LD_VAR 0 2
12541: NOT
12542: OR
12543: IFFALSE 12547
// exit ;
12545: GO 12705
// x := GetX ( building ) ;
12547: LD_ADDR_VAR 0 5
12551: PUSH
12552: LD_VAR 0 2
12556: PPUSH
12557: CALL_OW 250
12561: ST_TO_ADDR
// y := GetY ( building ) ;
12562: LD_ADDR_VAR 0 6
12566: PUSH
12567: LD_VAR 0 2
12571: PPUSH
12572: CALL_OW 251
12576: ST_TO_ADDR
// for i = 0 to 5 do
12577: LD_ADDR_VAR 0 4
12581: PUSH
12582: DOUBLE
12583: LD_INT 0
12585: DEC
12586: ST_TO_ADDR
12587: LD_INT 5
12589: PUSH
12590: FOR_TO
12591: IFFALSE 12703
// begin _x := ShiftX ( x , i , 3 ) ;
12593: LD_ADDR_VAR 0 7
12597: PUSH
12598: LD_VAR 0 5
12602: PPUSH
12603: LD_VAR 0 4
12607: PPUSH
12608: LD_INT 3
12610: PPUSH
12611: CALL_OW 272
12615: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12616: LD_ADDR_VAR 0 8
12620: PUSH
12621: LD_VAR 0 6
12625: PPUSH
12626: LD_VAR 0 4
12630: PPUSH
12631: LD_INT 3
12633: PPUSH
12634: CALL_OW 273
12638: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12639: LD_VAR 0 7
12643: PPUSH
12644: LD_VAR 0 8
12648: PPUSH
12649: CALL_OW 488
12653: NOT
12654: IFFALSE 12658
// continue ;
12656: GO 12590
// if HexInfo ( _x , _y ) = 0 then
12658: LD_VAR 0 7
12662: PPUSH
12663: LD_VAR 0 8
12667: PPUSH
12668: CALL_OW 428
12672: PUSH
12673: LD_INT 0
12675: EQUAL
12676: IFFALSE 12701
// begin ComMoveXY ( unit , _x , _y ) ;
12678: LD_VAR 0 1
12682: PPUSH
12683: LD_VAR 0 7
12687: PPUSH
12688: LD_VAR 0 8
12692: PPUSH
12693: CALL_OW 111
// exit ;
12697: POP
12698: POP
12699: GO 12705
// end ; end ;
12701: GO 12590
12703: POP
12704: POP
// end ;
12705: LD_VAR 0 3
12709: RET
// export function ScanBase ( side , base_area ) ; begin
12710: LD_INT 0
12712: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12713: LD_ADDR_VAR 0 3
12717: PUSH
12718: LD_VAR 0 2
12722: PPUSH
12723: LD_INT 81
12725: PUSH
12726: LD_VAR 0 1
12730: PUSH
12731: EMPTY
12732: LIST
12733: LIST
12734: PPUSH
12735: CALL_OW 70
12739: ST_TO_ADDR
// end ;
12740: LD_VAR 0 3
12744: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
12745: LD_INT 0
12747: PPUSH
12748: PPUSH
12749: PPUSH
12750: PPUSH
12751: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
12752: LD_VAR 0 1
12756: NOT
12757: PUSH
12758: LD_EXP 52
12762: PUSH
12763: LD_VAR 0 1
12767: ARRAY
12768: NOT
12769: OR
12770: PUSH
12771: LD_VAR 0 2
12775: NOT
12776: OR
12777: PUSH
12778: LD_VAR 0 3
12782: NOT
12783: OR
12784: IFFALSE 12788
// exit ;
12786: GO 13238
// side := mc_sides [ base ] ;
12788: LD_ADDR_VAR 0 6
12792: PUSH
12793: LD_EXP 78
12797: PUSH
12798: LD_VAR 0 1
12802: ARRAY
12803: ST_TO_ADDR
// if not side then
12804: LD_VAR 0 6
12808: NOT
12809: IFFALSE 12813
// exit ;
12811: GO 13238
// for i in solds do
12813: LD_ADDR_VAR 0 7
12817: PUSH
12818: LD_VAR 0 2
12822: PUSH
12823: FOR_IN
12824: IFFALSE 12885
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
12826: LD_VAR 0 7
12830: PPUSH
12831: CALL_OW 310
12835: PPUSH
12836: CALL_OW 266
12840: PUSH
12841: LD_INT 32
12843: PUSH
12844: LD_INT 31
12846: PUSH
12847: EMPTY
12848: LIST
12849: LIST
12850: IN
12851: IFFALSE 12871
// solds := solds diff i else
12853: LD_ADDR_VAR 0 2
12857: PUSH
12858: LD_VAR 0 2
12862: PUSH
12863: LD_VAR 0 7
12867: DIFF
12868: ST_TO_ADDR
12869: GO 12883
// SetTag ( i , 18 ) ;
12871: LD_VAR 0 7
12875: PPUSH
12876: LD_INT 18
12878: PPUSH
12879: CALL_OW 109
12883: GO 12823
12885: POP
12886: POP
// if not solds then
12887: LD_VAR 0 2
12891: NOT
12892: IFFALSE 12896
// exit ;
12894: GO 13238
// repeat wait ( 0 0$1 ) ;
12896: LD_INT 35
12898: PPUSH
12899: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
12903: LD_ADDR_VAR 0 5
12907: PUSH
12908: LD_VAR 0 6
12912: PPUSH
12913: LD_VAR 0 3
12917: PPUSH
12918: CALL 12710 0 2
12922: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
12923: LD_VAR 0 5
12927: NOT
12928: PUSH
12929: LD_VAR 0 5
12933: PUSH
12934: LD_INT 3
12936: GREATER
12937: OR
12938: PUSH
12939: LD_EXP 74
12943: PUSH
12944: LD_VAR 0 1
12948: ARRAY
12949: OR
12950: IFFALSE 12991
// begin for i in solds do
12952: LD_ADDR_VAR 0 7
12956: PUSH
12957: LD_VAR 0 2
12961: PUSH
12962: FOR_IN
12963: IFFALSE 12987
// if HasTask ( i ) then
12965: LD_VAR 0 7
12969: PPUSH
12970: CALL_OW 314
12974: IFFALSE 12985
// ComStop ( i ) ;
12976: LD_VAR 0 7
12980: PPUSH
12981: CALL_OW 141
12985: GO 12962
12987: POP
12988: POP
// break ;
12989: GO 13226
// end ; for i in solds do
12991: LD_ADDR_VAR 0 7
12995: PUSH
12996: LD_VAR 0 2
13000: PUSH
13001: FOR_IN
13002: IFFALSE 13218
// begin if IsInUnit ( i ) then
13004: LD_VAR 0 7
13008: PPUSH
13009: CALL_OW 310
13013: IFFALSE 13024
// ComExitBuilding ( i ) ;
13015: LD_VAR 0 7
13019: PPUSH
13020: CALL_OW 122
// if GetLives ( i ) > 333 then
13024: LD_VAR 0 7
13028: PPUSH
13029: CALL_OW 256
13033: PUSH
13034: LD_INT 333
13036: GREATER
13037: IFFALSE 13065
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
13039: LD_VAR 0 7
13043: PPUSH
13044: LD_VAR 0 5
13048: PPUSH
13049: LD_VAR 0 7
13053: PPUSH
13054: CALL_OW 74
13058: PPUSH
13059: CALL_OW 115
13063: GO 13216
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
13065: LD_ADDR_VAR 0 8
13069: PUSH
13070: LD_EXP 52
13074: PUSH
13075: LD_VAR 0 1
13079: ARRAY
13080: PPUSH
13081: LD_INT 2
13083: PUSH
13084: LD_INT 30
13086: PUSH
13087: LD_INT 0
13089: PUSH
13090: EMPTY
13091: LIST
13092: LIST
13093: PUSH
13094: LD_INT 30
13096: PUSH
13097: LD_INT 1
13099: PUSH
13100: EMPTY
13101: LIST
13102: LIST
13103: PUSH
13104: LD_INT 30
13106: PUSH
13107: LD_INT 6
13109: PUSH
13110: EMPTY
13111: LIST
13112: LIST
13113: PUSH
13114: EMPTY
13115: LIST
13116: LIST
13117: LIST
13118: LIST
13119: PPUSH
13120: CALL_OW 72
13124: PPUSH
13125: LD_VAR 0 7
13129: PPUSH
13130: CALL_OW 74
13134: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
13135: LD_VAR 0 7
13139: PPUSH
13140: LD_VAR 0 8
13144: PPUSH
13145: CALL_OW 250
13149: PPUSH
13150: LD_INT 3
13152: PPUSH
13153: LD_INT 5
13155: PPUSH
13156: CALL_OW 272
13160: PPUSH
13161: LD_VAR 0 8
13165: PPUSH
13166: CALL_OW 251
13170: PPUSH
13171: LD_INT 3
13173: PPUSH
13174: LD_INT 5
13176: PPUSH
13177: CALL_OW 273
13181: PPUSH
13182: CALL_OW 111
// SetTag ( i , 0 ) ;
13186: LD_VAR 0 7
13190: PPUSH
13191: LD_INT 0
13193: PPUSH
13194: CALL_OW 109
// solds := solds diff i ;
13198: LD_ADDR_VAR 0 2
13202: PUSH
13203: LD_VAR 0 2
13207: PUSH
13208: LD_VAR 0 7
13212: DIFF
13213: ST_TO_ADDR
// continue ;
13214: GO 13001
// end ; end ;
13216: GO 13001
13218: POP
13219: POP
// until solds ;
13220: LD_VAR 0 2
13224: IFFALSE 12896
// MC_Reset ( base , 18 ) ;
13226: LD_VAR 0 1
13230: PPUSH
13231: LD_INT 18
13233: PPUSH
13234: CALL 57778 0 2
// end ;
13238: LD_VAR 0 4
13242: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
13243: LD_INT 0
13245: PPUSH
13246: PPUSH
13247: PPUSH
13248: PPUSH
13249: PPUSH
13250: PPUSH
13251: PPUSH
13252: PPUSH
13253: PPUSH
13254: PPUSH
13255: PPUSH
13256: PPUSH
13257: PPUSH
13258: PPUSH
13259: PPUSH
13260: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
13261: LD_ADDR_VAR 0 12
13265: PUSH
13266: LD_EXP 52
13270: PUSH
13271: LD_VAR 0 1
13275: ARRAY
13276: PPUSH
13277: LD_INT 25
13279: PUSH
13280: LD_INT 3
13282: PUSH
13283: EMPTY
13284: LIST
13285: LIST
13286: PPUSH
13287: CALL_OW 72
13291: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
13292: LD_ADDR_VAR 0 8
13296: PUSH
13297: LD_EXP 52
13301: PUSH
13302: LD_VAR 0 1
13306: ARRAY
13307: PPUSH
13308: LD_INT 2
13310: PUSH
13311: LD_INT 25
13313: PUSH
13314: LD_INT 1
13316: PUSH
13317: EMPTY
13318: LIST
13319: LIST
13320: PUSH
13321: LD_INT 25
13323: PUSH
13324: LD_INT 5
13326: PUSH
13327: EMPTY
13328: LIST
13329: LIST
13330: PUSH
13331: LD_INT 25
13333: PUSH
13334: LD_INT 8
13336: PUSH
13337: EMPTY
13338: LIST
13339: LIST
13340: PUSH
13341: LD_INT 25
13343: PUSH
13344: LD_INT 9
13346: PUSH
13347: EMPTY
13348: LIST
13349: LIST
13350: PUSH
13351: EMPTY
13352: LIST
13353: LIST
13354: LIST
13355: LIST
13356: LIST
13357: PPUSH
13358: CALL_OW 72
13362: ST_TO_ADDR
// if not defenders and not solds then
13363: LD_VAR 0 2
13367: NOT
13368: PUSH
13369: LD_VAR 0 8
13373: NOT
13374: AND
13375: IFFALSE 13379
// exit ;
13377: GO 14708
// depot_under_attack := false ;
13379: LD_ADDR_VAR 0 16
13383: PUSH
13384: LD_INT 0
13386: ST_TO_ADDR
// sold_defenders := [ ] ;
13387: LD_ADDR_VAR 0 17
13391: PUSH
13392: EMPTY
13393: ST_TO_ADDR
// if mechs then
13394: LD_VAR 0 12
13398: IFFALSE 13527
// for i in defenders do
13400: LD_ADDR_VAR 0 5
13404: PUSH
13405: LD_VAR 0 2
13409: PUSH
13410: FOR_IN
13411: IFFALSE 13525
// begin SetTag ( i , 20 ) ;
13413: LD_VAR 0 5
13417: PPUSH
13418: LD_INT 20
13420: PPUSH
13421: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
13425: LD_VAR 0 5
13429: PPUSH
13430: CALL_OW 263
13434: PUSH
13435: LD_INT 1
13437: EQUAL
13438: PUSH
13439: LD_VAR 0 5
13443: PPUSH
13444: CALL_OW 311
13448: NOT
13449: AND
13450: PUSH
13451: LD_VAR 0 12
13455: AND
13456: IFFALSE 13523
// begin un := mechs [ 1 ] ;
13458: LD_ADDR_VAR 0 10
13462: PUSH
13463: LD_VAR 0 12
13467: PUSH
13468: LD_INT 1
13470: ARRAY
13471: ST_TO_ADDR
// ComExitBuilding ( un ) ;
13472: LD_VAR 0 10
13476: PPUSH
13477: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
13481: LD_VAR 0 10
13485: PPUSH
13486: LD_VAR 0 5
13490: PPUSH
13491: CALL_OW 180
// SetTag ( un , 19 ) ;
13495: LD_VAR 0 10
13499: PPUSH
13500: LD_INT 19
13502: PPUSH
13503: CALL_OW 109
// mechs := mechs diff un ;
13507: LD_ADDR_VAR 0 12
13511: PUSH
13512: LD_VAR 0 12
13516: PUSH
13517: LD_VAR 0 10
13521: DIFF
13522: ST_TO_ADDR
// end ; end ;
13523: GO 13410
13525: POP
13526: POP
// if solds then
13527: LD_VAR 0 8
13531: IFFALSE 13590
// for i in solds do
13533: LD_ADDR_VAR 0 5
13537: PUSH
13538: LD_VAR 0 8
13542: PUSH
13543: FOR_IN
13544: IFFALSE 13588
// if not GetTag ( i ) then
13546: LD_VAR 0 5
13550: PPUSH
13551: CALL_OW 110
13555: NOT
13556: IFFALSE 13586
// begin defenders := defenders union i ;
13558: LD_ADDR_VAR 0 2
13562: PUSH
13563: LD_VAR 0 2
13567: PUSH
13568: LD_VAR 0 5
13572: UNION
13573: ST_TO_ADDR
// SetTag ( i , 18 ) ;
13574: LD_VAR 0 5
13578: PPUSH
13579: LD_INT 18
13581: PPUSH
13582: CALL_OW 109
// end ;
13586: GO 13543
13588: POP
13589: POP
// repeat wait ( 0 0$1 ) ;
13590: LD_INT 35
13592: PPUSH
13593: CALL_OW 67
// enemy := mc_scan [ base ] ;
13597: LD_ADDR_VAR 0 3
13601: PUSH
13602: LD_EXP 75
13606: PUSH
13607: LD_VAR 0 1
13611: ARRAY
13612: ST_TO_ADDR
// for i in defenders do
13613: LD_ADDR_VAR 0 5
13617: PUSH
13618: LD_VAR 0 2
13622: PUSH
13623: FOR_IN
13624: IFFALSE 14309
// begin e := NearestUnitToUnit ( enemy , i ) ;
13626: LD_ADDR_VAR 0 13
13630: PUSH
13631: LD_VAR 0 3
13635: PPUSH
13636: LD_VAR 0 5
13640: PPUSH
13641: CALL_OW 74
13645: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
13646: LD_ADDR_VAR 0 16
13650: PUSH
13651: LD_EXP 52
13655: PUSH
13656: LD_VAR 0 1
13660: ARRAY
13661: PPUSH
13662: LD_INT 2
13664: PUSH
13665: LD_INT 30
13667: PUSH
13668: LD_INT 0
13670: PUSH
13671: EMPTY
13672: LIST
13673: LIST
13674: PUSH
13675: LD_INT 30
13677: PUSH
13678: LD_INT 1
13680: PUSH
13681: EMPTY
13682: LIST
13683: LIST
13684: PUSH
13685: EMPTY
13686: LIST
13687: LIST
13688: LIST
13689: PPUSH
13690: CALL_OW 72
13694: NOT
13695: PUSH
13696: LD_EXP 52
13700: PUSH
13701: LD_VAR 0 1
13705: ARRAY
13706: PPUSH
13707: LD_INT 2
13709: PUSH
13710: LD_INT 30
13712: PUSH
13713: LD_INT 0
13715: PUSH
13716: EMPTY
13717: LIST
13718: LIST
13719: PUSH
13720: LD_INT 30
13722: PUSH
13723: LD_INT 1
13725: PUSH
13726: EMPTY
13727: LIST
13728: LIST
13729: PUSH
13730: EMPTY
13731: LIST
13732: LIST
13733: LIST
13734: PPUSH
13735: CALL_OW 72
13739: PPUSH
13740: CALL_OW 256
13744: PUSH
13745: LD_INT 600
13747: LESS
13748: OR
13749: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
13750: LD_VAR 0 5
13754: PPUSH
13755: CALL_OW 247
13759: PUSH
13760: LD_INT 2
13762: DOUBLE
13763: EQUAL
13764: IFTRUE 13768
13766: GO 14015
13768: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
13769: LD_VAR 0 5
13773: PPUSH
13774: CALL_OW 256
13778: PUSH
13779: LD_INT 650
13781: GREATER
13782: PUSH
13783: LD_VAR 0 5
13787: PPUSH
13788: LD_VAR 0 13
13792: PPUSH
13793: CALL_OW 296
13797: PUSH
13798: LD_INT 40
13800: LESS
13801: AND
13802: IFFALSE 13820
// ComAttackUnit ( i , e ) else
13804: LD_VAR 0 5
13808: PPUSH
13809: LD_VAR 0 13
13813: PPUSH
13814: CALL_OW 115
13818: GO 13898
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
13820: LD_VAR 0 5
13824: PPUSH
13825: LD_VAR 0 13
13829: PPUSH
13830: CALL_OW 296
13834: PUSH
13835: LD_INT 30
13837: GREATEREQUAL
13838: PUSH
13839: LD_VAR 0 5
13843: PPUSH
13844: CALL_OW 256
13848: PUSH
13849: LD_INT 650
13851: LESSEQUAL
13852: OR
13853: PUSH
13854: LD_VAR 0 5
13858: PPUSH
13859: LD_EXP 76
13863: PUSH
13864: LD_VAR 0 1
13868: ARRAY
13869: PPUSH
13870: CALL_OW 308
13874: NOT
13875: AND
13876: IFFALSE 13898
// ComMoveToArea ( i , mc_parking [ base ] ) ;
13878: LD_VAR 0 5
13882: PPUSH
13883: LD_EXP 76
13887: PUSH
13888: LD_VAR 0 1
13892: ARRAY
13893: PPUSH
13894: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
13898: LD_VAR 0 5
13902: PPUSH
13903: CALL_OW 256
13907: PUSH
13908: LD_INT 998
13910: LESS
13911: PUSH
13912: LD_VAR 0 5
13916: PPUSH
13917: CALL_OW 263
13921: PUSH
13922: LD_INT 1
13924: EQUAL
13925: AND
13926: PUSH
13927: LD_VAR 0 5
13931: PPUSH
13932: CALL_OW 311
13936: AND
13937: PUSH
13938: LD_VAR 0 5
13942: PPUSH
13943: LD_EXP 76
13947: PUSH
13948: LD_VAR 0 1
13952: ARRAY
13953: PPUSH
13954: CALL_OW 308
13958: AND
13959: IFFALSE 14013
// begin mech := IsDrivenBy ( i ) ;
13961: LD_ADDR_VAR 0 9
13965: PUSH
13966: LD_VAR 0 5
13970: PPUSH
13971: CALL_OW 311
13975: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
13976: LD_VAR 0 9
13980: PPUSH
13981: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
13985: LD_VAR 0 9
13989: PPUSH
13990: LD_VAR 0 5
13994: PPUSH
13995: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
13999: LD_VAR 0 9
14003: PPUSH
14004: LD_VAR 0 5
14008: PPUSH
14009: CALL_OW 180
// end ; end ; unit_human :
14013: GO 14280
14015: LD_INT 1
14017: DOUBLE
14018: EQUAL
14019: IFTRUE 14023
14021: GO 14279
14023: POP
// begin b := IsInUnit ( i ) ;
14024: LD_ADDR_VAR 0 18
14028: PUSH
14029: LD_VAR 0 5
14033: PPUSH
14034: CALL_OW 310
14038: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
14039: LD_ADDR_VAR 0 19
14043: PUSH
14044: LD_VAR 0 18
14048: NOT
14049: PUSH
14050: LD_VAR 0 18
14054: PPUSH
14055: CALL_OW 266
14059: PUSH
14060: LD_INT 32
14062: PUSH
14063: LD_INT 31
14065: PUSH
14066: EMPTY
14067: LIST
14068: LIST
14069: IN
14070: OR
14071: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
14072: LD_VAR 0 16
14076: PUSH
14077: LD_VAR 0 2
14081: PPUSH
14082: LD_INT 21
14084: PUSH
14085: LD_INT 2
14087: PUSH
14088: EMPTY
14089: LIST
14090: LIST
14091: PPUSH
14092: CALL_OW 72
14096: PUSH
14097: LD_INT 1
14099: LESSEQUAL
14100: OR
14101: PUSH
14102: LD_VAR 0 19
14106: AND
14107: PUSH
14108: LD_VAR 0 5
14112: PUSH
14113: LD_VAR 0 17
14117: IN
14118: NOT
14119: AND
14120: IFFALSE 14213
// begin if b then
14122: LD_VAR 0 18
14126: IFFALSE 14175
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
14128: LD_VAR 0 18
14132: PPUSH
14133: LD_VAR 0 3
14137: PPUSH
14138: LD_VAR 0 18
14142: PPUSH
14143: CALL_OW 74
14147: PPUSH
14148: CALL_OW 296
14152: PUSH
14153: LD_INT 10
14155: LESS
14156: PUSH
14157: LD_VAR 0 18
14161: PPUSH
14162: CALL_OW 461
14166: PUSH
14167: LD_INT 7
14169: NONEQUAL
14170: AND
14171: IFFALSE 14175
// continue ;
14173: GO 13623
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
14175: LD_ADDR_VAR 0 17
14179: PUSH
14180: LD_VAR 0 17
14184: PPUSH
14185: LD_VAR 0 17
14189: PUSH
14190: LD_INT 1
14192: PLUS
14193: PPUSH
14194: LD_VAR 0 5
14198: PPUSH
14199: CALL_OW 1
14203: ST_TO_ADDR
// ComExitBuilding ( i ) ;
14204: LD_VAR 0 5
14208: PPUSH
14209: CALL_OW 122
// end ; if sold_defenders then
14213: LD_VAR 0 17
14217: IFFALSE 14277
// if i in sold_defenders then
14219: LD_VAR 0 5
14223: PUSH
14224: LD_VAR 0 17
14228: IN
14229: IFFALSE 14277
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
14231: LD_VAR 0 5
14235: PPUSH
14236: CALL_OW 314
14240: NOT
14241: PUSH
14242: LD_VAR 0 5
14246: PPUSH
14247: LD_VAR 0 13
14251: PPUSH
14252: CALL_OW 296
14256: PUSH
14257: LD_INT 30
14259: LESS
14260: AND
14261: IFFALSE 14277
// ComAttackUnit ( i , e ) ;
14263: LD_VAR 0 5
14267: PPUSH
14268: LD_VAR 0 13
14272: PPUSH
14273: CALL_OW 115
// end ; end ; end ;
14277: GO 14280
14279: POP
// if IsDead ( i ) then
14280: LD_VAR 0 5
14284: PPUSH
14285: CALL_OW 301
14289: IFFALSE 14307
// defenders := defenders diff i ;
14291: LD_ADDR_VAR 0 2
14295: PUSH
14296: LD_VAR 0 2
14300: PUSH
14301: LD_VAR 0 5
14305: DIFF
14306: ST_TO_ADDR
// end ;
14307: GO 13623
14309: POP
14310: POP
// until not enemy or not defenders ;
14311: LD_VAR 0 3
14315: NOT
14316: PUSH
14317: LD_VAR 0 2
14321: NOT
14322: OR
14323: IFFALSE 13590
// MC_Reset ( base , 18 ) ;
14325: LD_VAR 0 1
14329: PPUSH
14330: LD_INT 18
14332: PPUSH
14333: CALL 57778 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
14337: LD_ADDR_VAR 0 2
14341: PUSH
14342: LD_VAR 0 2
14346: PUSH
14347: LD_VAR 0 2
14351: PPUSH
14352: LD_INT 2
14354: PUSH
14355: LD_INT 25
14357: PUSH
14358: LD_INT 1
14360: PUSH
14361: EMPTY
14362: LIST
14363: LIST
14364: PUSH
14365: LD_INT 25
14367: PUSH
14368: LD_INT 5
14370: PUSH
14371: EMPTY
14372: LIST
14373: LIST
14374: PUSH
14375: LD_INT 25
14377: PUSH
14378: LD_INT 8
14380: PUSH
14381: EMPTY
14382: LIST
14383: LIST
14384: PUSH
14385: LD_INT 25
14387: PUSH
14388: LD_INT 9
14390: PUSH
14391: EMPTY
14392: LIST
14393: LIST
14394: PUSH
14395: EMPTY
14396: LIST
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: PPUSH
14402: CALL_OW 72
14406: DIFF
14407: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
14408: LD_VAR 0 3
14412: NOT
14413: PUSH
14414: LD_VAR 0 2
14418: PPUSH
14419: LD_INT 21
14421: PUSH
14422: LD_INT 2
14424: PUSH
14425: EMPTY
14426: LIST
14427: LIST
14428: PPUSH
14429: CALL_OW 72
14433: AND
14434: IFFALSE 14696
// begin tmp := FilterByTag ( defenders , 19 ) ;
14436: LD_ADDR_VAR 0 11
14440: PUSH
14441: LD_VAR 0 2
14445: PPUSH
14446: LD_INT 19
14448: PPUSH
14449: CALL 51076 0 2
14453: ST_TO_ADDR
// if tmp then
14454: LD_VAR 0 11
14458: IFFALSE 14528
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
14460: LD_ADDR_VAR 0 11
14464: PUSH
14465: LD_VAR 0 11
14469: PPUSH
14470: LD_INT 25
14472: PUSH
14473: LD_INT 3
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: PPUSH
14480: CALL_OW 72
14484: ST_TO_ADDR
// if tmp then
14485: LD_VAR 0 11
14489: IFFALSE 14528
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
14491: LD_ADDR_EXP 64
14495: PUSH
14496: LD_EXP 64
14500: PPUSH
14501: LD_VAR 0 1
14505: PPUSH
14506: LD_EXP 64
14510: PUSH
14511: LD_VAR 0 1
14515: ARRAY
14516: PUSH
14517: LD_VAR 0 11
14521: UNION
14522: PPUSH
14523: CALL_OW 1
14527: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
14528: LD_VAR 0 1
14532: PPUSH
14533: LD_INT 19
14535: PPUSH
14536: CALL 57778 0 2
// repeat wait ( 0 0$1 ) ;
14540: LD_INT 35
14542: PPUSH
14543: CALL_OW 67
// for i in defenders do
14547: LD_ADDR_VAR 0 5
14551: PUSH
14552: LD_VAR 0 2
14556: PUSH
14557: FOR_IN
14558: IFFALSE 14647
// begin if not IsInArea ( i , mc_parking [ base ] ) then
14560: LD_VAR 0 5
14564: PPUSH
14565: LD_EXP 76
14569: PUSH
14570: LD_VAR 0 1
14574: ARRAY
14575: PPUSH
14576: CALL_OW 308
14580: NOT
14581: IFFALSE 14605
// ComMoveToArea ( i , mc_parking [ base ] ) else
14583: LD_VAR 0 5
14587: PPUSH
14588: LD_EXP 76
14592: PUSH
14593: LD_VAR 0 1
14597: ARRAY
14598: PPUSH
14599: CALL_OW 113
14603: GO 14645
// if GetControl ( i ) = control_manual then
14605: LD_VAR 0 5
14609: PPUSH
14610: CALL_OW 263
14614: PUSH
14615: LD_INT 1
14617: EQUAL
14618: IFFALSE 14645
// if IsDrivenBy ( i ) then
14620: LD_VAR 0 5
14624: PPUSH
14625: CALL_OW 311
14629: IFFALSE 14645
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
14631: LD_VAR 0 5
14635: PPUSH
14636: CALL_OW 311
14640: PPUSH
14641: CALL_OW 121
// end ;
14645: GO 14557
14647: POP
14648: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
14649: LD_VAR 0 2
14653: PPUSH
14654: LD_INT 95
14656: PUSH
14657: LD_EXP 76
14661: PUSH
14662: LD_VAR 0 1
14666: ARRAY
14667: PUSH
14668: EMPTY
14669: LIST
14670: LIST
14671: PPUSH
14672: CALL_OW 72
14676: PUSH
14677: LD_VAR 0 2
14681: EQUAL
14682: PUSH
14683: LD_EXP 75
14687: PUSH
14688: LD_VAR 0 1
14692: ARRAY
14693: OR
14694: IFFALSE 14540
// end ; MC_Reset ( base , 20 ) ;
14696: LD_VAR 0 1
14700: PPUSH
14701: LD_INT 20
14703: PPUSH
14704: CALL 57778 0 2
// end ;
14708: LD_VAR 0 4
14712: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
14713: LD_INT 0
14715: PPUSH
14716: PPUSH
14717: PPUSH
14718: PPUSH
// result := false ;
14719: LD_ADDR_VAR 0 2
14723: PUSH
14724: LD_INT 0
14726: ST_TO_ADDR
// side := GetSide ( unit ) ;
14727: LD_ADDR_VAR 0 3
14731: PUSH
14732: LD_VAR 0 1
14736: PPUSH
14737: CALL_OW 255
14741: ST_TO_ADDR
// nat := GetNation ( unit ) ;
14742: LD_ADDR_VAR 0 4
14746: PUSH
14747: LD_VAR 0 1
14751: PPUSH
14752: CALL_OW 248
14756: ST_TO_ADDR
// case nat of 1 :
14757: LD_VAR 0 4
14761: PUSH
14762: LD_INT 1
14764: DOUBLE
14765: EQUAL
14766: IFTRUE 14770
14768: GO 14781
14770: POP
// tech := tech_lassight ; 2 :
14771: LD_ADDR_VAR 0 5
14775: PUSH
14776: LD_INT 12
14778: ST_TO_ADDR
14779: GO 14820
14781: LD_INT 2
14783: DOUBLE
14784: EQUAL
14785: IFTRUE 14789
14787: GO 14800
14789: POP
// tech := tech_mortar ; 3 :
14790: LD_ADDR_VAR 0 5
14794: PUSH
14795: LD_INT 41
14797: ST_TO_ADDR
14798: GO 14820
14800: LD_INT 3
14802: DOUBLE
14803: EQUAL
14804: IFTRUE 14808
14806: GO 14819
14808: POP
// tech := tech_bazooka ; end ;
14809: LD_ADDR_VAR 0 5
14813: PUSH
14814: LD_INT 44
14816: ST_TO_ADDR
14817: GO 14820
14819: POP
// if Researched ( side , tech ) then
14820: LD_VAR 0 3
14824: PPUSH
14825: LD_VAR 0 5
14829: PPUSH
14830: CALL_OW 325
14834: IFFALSE 14861
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
14836: LD_ADDR_VAR 0 2
14840: PUSH
14841: LD_INT 5
14843: PUSH
14844: LD_INT 8
14846: PUSH
14847: LD_INT 9
14849: PUSH
14850: EMPTY
14851: LIST
14852: LIST
14853: LIST
14854: PUSH
14855: LD_VAR 0 4
14859: ARRAY
14860: ST_TO_ADDR
// end ;
14861: LD_VAR 0 2
14865: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
14866: LD_INT 0
14868: PPUSH
14869: PPUSH
14870: PPUSH
// if not mines then
14871: LD_VAR 0 2
14875: NOT
14876: IFFALSE 14880
// exit ;
14878: GO 15024
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14880: LD_ADDR_VAR 0 5
14884: PUSH
14885: LD_INT 81
14887: PUSH
14888: LD_VAR 0 1
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: PUSH
14897: LD_INT 3
14899: PUSH
14900: LD_INT 21
14902: PUSH
14903: LD_INT 3
14905: PUSH
14906: EMPTY
14907: LIST
14908: LIST
14909: PUSH
14910: EMPTY
14911: LIST
14912: LIST
14913: PUSH
14914: EMPTY
14915: LIST
14916: LIST
14917: PPUSH
14918: CALL_OW 69
14922: ST_TO_ADDR
// for i in mines do
14923: LD_ADDR_VAR 0 4
14927: PUSH
14928: LD_VAR 0 2
14932: PUSH
14933: FOR_IN
14934: IFFALSE 15022
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
14936: LD_VAR 0 4
14940: PUSH
14941: LD_INT 1
14943: ARRAY
14944: PPUSH
14945: LD_VAR 0 4
14949: PUSH
14950: LD_INT 2
14952: ARRAY
14953: PPUSH
14954: CALL_OW 458
14958: NOT
14959: IFFALSE 14963
// continue ;
14961: GO 14933
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
14963: LD_VAR 0 4
14967: PUSH
14968: LD_INT 1
14970: ARRAY
14971: PPUSH
14972: LD_VAR 0 4
14976: PUSH
14977: LD_INT 2
14979: ARRAY
14980: PPUSH
14981: CALL_OW 428
14985: PUSH
14986: LD_VAR 0 5
14990: IN
14991: IFFALSE 15020
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
14993: LD_VAR 0 4
14997: PUSH
14998: LD_INT 1
15000: ARRAY
15001: PPUSH
15002: LD_VAR 0 4
15006: PUSH
15007: LD_INT 2
15009: ARRAY
15010: PPUSH
15011: LD_VAR 0 1
15015: PPUSH
15016: CALL_OW 456
// end ;
15020: GO 14933
15022: POP
15023: POP
// end ;
15024: LD_VAR 0 3
15028: RET
// export function Count ( array ) ; var i ; begin
15029: LD_INT 0
15031: PPUSH
15032: PPUSH
// result := 0 ;
15033: LD_ADDR_VAR 0 2
15037: PUSH
15038: LD_INT 0
15040: ST_TO_ADDR
// for i in array do
15041: LD_ADDR_VAR 0 3
15045: PUSH
15046: LD_VAR 0 1
15050: PUSH
15051: FOR_IN
15052: IFFALSE 15076
// if i then
15054: LD_VAR 0 3
15058: IFFALSE 15074
// result := result + 1 ;
15060: LD_ADDR_VAR 0 2
15064: PUSH
15065: LD_VAR 0 2
15069: PUSH
15070: LD_INT 1
15072: PLUS
15073: ST_TO_ADDR
15074: GO 15051
15076: POP
15077: POP
// end ;
15078: LD_VAR 0 2
15082: RET
// export function IsEmpty ( building ) ; begin
15083: LD_INT 0
15085: PPUSH
// if not building then
15086: LD_VAR 0 1
15090: NOT
15091: IFFALSE 15095
// exit ;
15093: GO 15138
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15095: LD_ADDR_VAR 0 2
15099: PUSH
15100: LD_VAR 0 1
15104: PUSH
15105: LD_INT 22
15107: PUSH
15108: LD_VAR 0 1
15112: PPUSH
15113: CALL_OW 255
15117: PUSH
15118: EMPTY
15119: LIST
15120: LIST
15121: PUSH
15122: LD_INT 58
15124: PUSH
15125: EMPTY
15126: LIST
15127: PUSH
15128: EMPTY
15129: LIST
15130: LIST
15131: PPUSH
15132: CALL_OW 69
15136: IN
15137: ST_TO_ADDR
// end ;
15138: LD_VAR 0 2
15142: RET
// export function IsNotFull ( building ) ; begin
15143: LD_INT 0
15145: PPUSH
// if not building then
15146: LD_VAR 0 1
15150: NOT
15151: IFFALSE 15155
// exit ;
15153: GO 15174
// result := UnitsInside ( building ) < 6 ;
15155: LD_ADDR_VAR 0 2
15159: PUSH
15160: LD_VAR 0 1
15164: PPUSH
15165: CALL_OW 313
15169: PUSH
15170: LD_INT 6
15172: LESS
15173: ST_TO_ADDR
// end ;
15174: LD_VAR 0 2
15178: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
15179: LD_INT 0
15181: PPUSH
15182: PPUSH
15183: PPUSH
15184: PPUSH
// tmp := [ ] ;
15185: LD_ADDR_VAR 0 3
15189: PUSH
15190: EMPTY
15191: ST_TO_ADDR
// list := [ ] ;
15192: LD_ADDR_VAR 0 5
15196: PUSH
15197: EMPTY
15198: ST_TO_ADDR
// for i = 16 to 25 do
15199: LD_ADDR_VAR 0 4
15203: PUSH
15204: DOUBLE
15205: LD_INT 16
15207: DEC
15208: ST_TO_ADDR
15209: LD_INT 25
15211: PUSH
15212: FOR_TO
15213: IFFALSE 15286
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
15215: LD_ADDR_VAR 0 3
15219: PUSH
15220: LD_VAR 0 3
15224: PUSH
15225: LD_INT 22
15227: PUSH
15228: LD_VAR 0 1
15232: PPUSH
15233: CALL_OW 255
15237: PUSH
15238: EMPTY
15239: LIST
15240: LIST
15241: PUSH
15242: LD_INT 91
15244: PUSH
15245: LD_VAR 0 1
15249: PUSH
15250: LD_INT 6
15252: PUSH
15253: EMPTY
15254: LIST
15255: LIST
15256: LIST
15257: PUSH
15258: LD_INT 30
15260: PUSH
15261: LD_VAR 0 4
15265: PUSH
15266: EMPTY
15267: LIST
15268: LIST
15269: PUSH
15270: EMPTY
15271: LIST
15272: LIST
15273: LIST
15274: PUSH
15275: EMPTY
15276: LIST
15277: PPUSH
15278: CALL_OW 69
15282: ADD
15283: ST_TO_ADDR
15284: GO 15212
15286: POP
15287: POP
// for i = 1 to tmp do
15288: LD_ADDR_VAR 0 4
15292: PUSH
15293: DOUBLE
15294: LD_INT 1
15296: DEC
15297: ST_TO_ADDR
15298: LD_VAR 0 3
15302: PUSH
15303: FOR_TO
15304: IFFALSE 15392
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
15306: LD_ADDR_VAR 0 5
15310: PUSH
15311: LD_VAR 0 5
15315: PUSH
15316: LD_VAR 0 3
15320: PUSH
15321: LD_VAR 0 4
15325: ARRAY
15326: PPUSH
15327: CALL_OW 266
15331: PUSH
15332: LD_VAR 0 3
15336: PUSH
15337: LD_VAR 0 4
15341: ARRAY
15342: PPUSH
15343: CALL_OW 250
15347: PUSH
15348: LD_VAR 0 3
15352: PUSH
15353: LD_VAR 0 4
15357: ARRAY
15358: PPUSH
15359: CALL_OW 251
15363: PUSH
15364: LD_VAR 0 3
15368: PUSH
15369: LD_VAR 0 4
15373: ARRAY
15374: PPUSH
15375: CALL_OW 254
15379: PUSH
15380: EMPTY
15381: LIST
15382: LIST
15383: LIST
15384: LIST
15385: PUSH
15386: EMPTY
15387: LIST
15388: ADD
15389: ST_TO_ADDR
15390: GO 15303
15392: POP
15393: POP
// result := list ;
15394: LD_ADDR_VAR 0 2
15398: PUSH
15399: LD_VAR 0 5
15403: ST_TO_ADDR
// end ;
15404: LD_VAR 0 2
15408: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
15409: LD_INT 0
15411: PPUSH
15412: PPUSH
15413: PPUSH
15414: PPUSH
15415: PPUSH
15416: PPUSH
15417: PPUSH
// if not factory then
15418: LD_VAR 0 1
15422: NOT
15423: IFFALSE 15427
// exit ;
15425: GO 15959
// if control = control_apeman then
15427: LD_VAR 0 4
15431: PUSH
15432: LD_INT 5
15434: EQUAL
15435: IFFALSE 15544
// begin tmp := UnitsInside ( factory ) ;
15437: LD_ADDR_VAR 0 8
15441: PUSH
15442: LD_VAR 0 1
15446: PPUSH
15447: CALL_OW 313
15451: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
15452: LD_VAR 0 8
15456: PPUSH
15457: LD_INT 25
15459: PUSH
15460: LD_INT 12
15462: PUSH
15463: EMPTY
15464: LIST
15465: LIST
15466: PPUSH
15467: CALL_OW 72
15471: NOT
15472: IFFALSE 15482
// control := control_manual ;
15474: LD_ADDR_VAR 0 4
15478: PUSH
15479: LD_INT 1
15481: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
15482: LD_ADDR_VAR 0 8
15486: PUSH
15487: LD_VAR 0 1
15491: PPUSH
15492: CALL 15179 0 1
15496: ST_TO_ADDR
// if tmp then
15497: LD_VAR 0 8
15501: IFFALSE 15544
// begin for i in tmp do
15503: LD_ADDR_VAR 0 7
15507: PUSH
15508: LD_VAR 0 8
15512: PUSH
15513: FOR_IN
15514: IFFALSE 15542
// if i [ 1 ] = b_ext_radio then
15516: LD_VAR 0 7
15520: PUSH
15521: LD_INT 1
15523: ARRAY
15524: PUSH
15525: LD_INT 22
15527: EQUAL
15528: IFFALSE 15540
// begin control := control_remote ;
15530: LD_ADDR_VAR 0 4
15534: PUSH
15535: LD_INT 2
15537: ST_TO_ADDR
// break ;
15538: GO 15542
// end ;
15540: GO 15513
15542: POP
15543: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
15544: LD_VAR 0 1
15548: PPUSH
15549: LD_VAR 0 2
15553: PPUSH
15554: LD_VAR 0 3
15558: PPUSH
15559: LD_VAR 0 4
15563: PPUSH
15564: LD_VAR 0 5
15568: PPUSH
15569: CALL_OW 448
15573: IFFALSE 15608
// begin result := [ chassis , engine , control , weapon ] ;
15575: LD_ADDR_VAR 0 6
15579: PUSH
15580: LD_VAR 0 2
15584: PUSH
15585: LD_VAR 0 3
15589: PUSH
15590: LD_VAR 0 4
15594: PUSH
15595: LD_VAR 0 5
15599: PUSH
15600: EMPTY
15601: LIST
15602: LIST
15603: LIST
15604: LIST
15605: ST_TO_ADDR
// exit ;
15606: GO 15959
// end ; _chassis := AvailableChassisList ( factory ) ;
15608: LD_ADDR_VAR 0 9
15612: PUSH
15613: LD_VAR 0 1
15617: PPUSH
15618: CALL_OW 475
15622: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
15623: LD_ADDR_VAR 0 11
15627: PUSH
15628: LD_VAR 0 1
15632: PPUSH
15633: CALL_OW 476
15637: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
15638: LD_ADDR_VAR 0 12
15642: PUSH
15643: LD_VAR 0 1
15647: PPUSH
15648: CALL_OW 477
15652: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
15653: LD_ADDR_VAR 0 10
15657: PUSH
15658: LD_VAR 0 1
15662: PPUSH
15663: CALL_OW 478
15667: ST_TO_ADDR
// if not chassis in _chassis then
15668: LD_VAR 0 2
15672: PUSH
15673: LD_VAR 0 9
15677: IN
15678: NOT
15679: IFFALSE 15705
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
15681: LD_ADDR_VAR 0 2
15685: PUSH
15686: LD_VAR 0 9
15690: PUSH
15691: LD_INT 1
15693: PPUSH
15694: LD_VAR 0 9
15698: PPUSH
15699: CALL_OW 12
15703: ARRAY
15704: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
15705: LD_VAR 0 2
15709: PPUSH
15710: LD_VAR 0 3
15714: PPUSH
15715: CALL 15964 0 2
15719: NOT
15720: IFFALSE 15779
// repeat engine := _engine [ 1 ] ;
15722: LD_ADDR_VAR 0 3
15726: PUSH
15727: LD_VAR 0 11
15731: PUSH
15732: LD_INT 1
15734: ARRAY
15735: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
15736: LD_ADDR_VAR 0 11
15740: PUSH
15741: LD_VAR 0 11
15745: PPUSH
15746: LD_INT 1
15748: PPUSH
15749: CALL_OW 3
15753: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
15754: LD_VAR 0 2
15758: PPUSH
15759: LD_VAR 0 3
15763: PPUSH
15764: CALL 15964 0 2
15768: PUSH
15769: LD_VAR 0 11
15773: PUSH
15774: EMPTY
15775: EQUAL
15776: OR
15777: IFFALSE 15722
// if not control in _control then
15779: LD_VAR 0 4
15783: PUSH
15784: LD_VAR 0 12
15788: IN
15789: NOT
15790: IFFALSE 15816
// control := _control [ rand ( 1 , _control ) ] ;
15792: LD_ADDR_VAR 0 4
15796: PUSH
15797: LD_VAR 0 12
15801: PUSH
15802: LD_INT 1
15804: PPUSH
15805: LD_VAR 0 12
15809: PPUSH
15810: CALL_OW 12
15814: ARRAY
15815: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
15816: LD_VAR 0 2
15820: PPUSH
15821: LD_VAR 0 5
15825: PPUSH
15826: CALL 16184 0 2
15830: NOT
15831: IFFALSE 15890
// repeat weapon := _weapon [ 1 ] ;
15833: LD_ADDR_VAR 0 5
15837: PUSH
15838: LD_VAR 0 10
15842: PUSH
15843: LD_INT 1
15845: ARRAY
15846: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
15847: LD_ADDR_VAR 0 10
15851: PUSH
15852: LD_VAR 0 10
15856: PPUSH
15857: LD_INT 1
15859: PPUSH
15860: CALL_OW 3
15864: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
15865: LD_VAR 0 2
15869: PPUSH
15870: LD_VAR 0 5
15874: PPUSH
15875: CALL 16184 0 2
15879: PUSH
15880: LD_VAR 0 10
15884: PUSH
15885: EMPTY
15886: EQUAL
15887: OR
15888: IFFALSE 15833
// result := [ ] ;
15890: LD_ADDR_VAR 0 6
15894: PUSH
15895: EMPTY
15896: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
15897: LD_VAR 0 1
15901: PPUSH
15902: LD_VAR 0 2
15906: PPUSH
15907: LD_VAR 0 3
15911: PPUSH
15912: LD_VAR 0 4
15916: PPUSH
15917: LD_VAR 0 5
15921: PPUSH
15922: CALL_OW 448
15926: IFFALSE 15959
// result := [ chassis , engine , control , weapon ] ;
15928: LD_ADDR_VAR 0 6
15932: PUSH
15933: LD_VAR 0 2
15937: PUSH
15938: LD_VAR 0 3
15942: PUSH
15943: LD_VAR 0 4
15947: PUSH
15948: LD_VAR 0 5
15952: PUSH
15953: EMPTY
15954: LIST
15955: LIST
15956: LIST
15957: LIST
15958: ST_TO_ADDR
// end ;
15959: LD_VAR 0 6
15963: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
15964: LD_INT 0
15966: PPUSH
// if not chassis or not engine then
15967: LD_VAR 0 1
15971: NOT
15972: PUSH
15973: LD_VAR 0 2
15977: NOT
15978: OR
15979: IFFALSE 15983
// exit ;
15981: GO 16179
// case engine of engine_solar :
15983: LD_VAR 0 2
15987: PUSH
15988: LD_INT 2
15990: DOUBLE
15991: EQUAL
15992: IFTRUE 15996
15994: GO 16034
15996: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
15997: LD_ADDR_VAR 0 3
16001: PUSH
16002: LD_INT 11
16004: PUSH
16005: LD_INT 12
16007: PUSH
16008: LD_INT 13
16010: PUSH
16011: LD_INT 14
16013: PUSH
16014: LD_INT 1
16016: PUSH
16017: LD_INT 2
16019: PUSH
16020: LD_INT 3
16022: PUSH
16023: EMPTY
16024: LIST
16025: LIST
16026: LIST
16027: LIST
16028: LIST
16029: LIST
16030: LIST
16031: ST_TO_ADDR
16032: GO 16163
16034: LD_INT 1
16036: DOUBLE
16037: EQUAL
16038: IFTRUE 16042
16040: GO 16104
16042: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16043: LD_ADDR_VAR 0 3
16047: PUSH
16048: LD_INT 11
16050: PUSH
16051: LD_INT 12
16053: PUSH
16054: LD_INT 13
16056: PUSH
16057: LD_INT 14
16059: PUSH
16060: LD_INT 1
16062: PUSH
16063: LD_INT 2
16065: PUSH
16066: LD_INT 3
16068: PUSH
16069: LD_INT 4
16071: PUSH
16072: LD_INT 5
16074: PUSH
16075: LD_INT 21
16077: PUSH
16078: LD_INT 23
16080: PUSH
16081: LD_INT 22
16083: PUSH
16084: LD_INT 24
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: LIST
16091: LIST
16092: LIST
16093: LIST
16094: LIST
16095: LIST
16096: LIST
16097: LIST
16098: LIST
16099: LIST
16100: LIST
16101: ST_TO_ADDR
16102: GO 16163
16104: LD_INT 3
16106: DOUBLE
16107: EQUAL
16108: IFTRUE 16112
16110: GO 16162
16112: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
16113: LD_ADDR_VAR 0 3
16117: PUSH
16118: LD_INT 13
16120: PUSH
16121: LD_INT 14
16123: PUSH
16124: LD_INT 2
16126: PUSH
16127: LD_INT 3
16129: PUSH
16130: LD_INT 4
16132: PUSH
16133: LD_INT 5
16135: PUSH
16136: LD_INT 21
16138: PUSH
16139: LD_INT 22
16141: PUSH
16142: LD_INT 23
16144: PUSH
16145: LD_INT 24
16147: PUSH
16148: EMPTY
16149: LIST
16150: LIST
16151: LIST
16152: LIST
16153: LIST
16154: LIST
16155: LIST
16156: LIST
16157: LIST
16158: LIST
16159: ST_TO_ADDR
16160: GO 16163
16162: POP
// result := ( chassis in result ) ;
16163: LD_ADDR_VAR 0 3
16167: PUSH
16168: LD_VAR 0 1
16172: PUSH
16173: LD_VAR 0 3
16177: IN
16178: ST_TO_ADDR
// end ;
16179: LD_VAR 0 3
16183: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
16184: LD_INT 0
16186: PPUSH
// if not chassis or not weapon then
16187: LD_VAR 0 1
16191: NOT
16192: PUSH
16193: LD_VAR 0 2
16197: NOT
16198: OR
16199: IFFALSE 16203
// exit ;
16201: GO 17229
// case weapon of us_machine_gun :
16203: LD_VAR 0 2
16207: PUSH
16208: LD_INT 2
16210: DOUBLE
16211: EQUAL
16212: IFTRUE 16216
16214: GO 16246
16216: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
16217: LD_ADDR_VAR 0 3
16221: PUSH
16222: LD_INT 1
16224: PUSH
16225: LD_INT 2
16227: PUSH
16228: LD_INT 3
16230: PUSH
16231: LD_INT 4
16233: PUSH
16234: LD_INT 5
16236: PUSH
16237: EMPTY
16238: LIST
16239: LIST
16240: LIST
16241: LIST
16242: LIST
16243: ST_TO_ADDR
16244: GO 17213
16246: LD_INT 3
16248: DOUBLE
16249: EQUAL
16250: IFTRUE 16254
16252: GO 16284
16254: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
16255: LD_ADDR_VAR 0 3
16259: PUSH
16260: LD_INT 1
16262: PUSH
16263: LD_INT 2
16265: PUSH
16266: LD_INT 3
16268: PUSH
16269: LD_INT 4
16271: PUSH
16272: LD_INT 5
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: LIST
16279: LIST
16280: LIST
16281: ST_TO_ADDR
16282: GO 17213
16284: LD_INT 11
16286: DOUBLE
16287: EQUAL
16288: IFTRUE 16292
16290: GO 16322
16292: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
16293: LD_ADDR_VAR 0 3
16297: PUSH
16298: LD_INT 1
16300: PUSH
16301: LD_INT 2
16303: PUSH
16304: LD_INT 3
16306: PUSH
16307: LD_INT 4
16309: PUSH
16310: LD_INT 5
16312: PUSH
16313: EMPTY
16314: LIST
16315: LIST
16316: LIST
16317: LIST
16318: LIST
16319: ST_TO_ADDR
16320: GO 17213
16322: LD_INT 4
16324: DOUBLE
16325: EQUAL
16326: IFTRUE 16330
16328: GO 16356
16330: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
16331: LD_ADDR_VAR 0 3
16335: PUSH
16336: LD_INT 2
16338: PUSH
16339: LD_INT 3
16341: PUSH
16342: LD_INT 4
16344: PUSH
16345: LD_INT 5
16347: PUSH
16348: EMPTY
16349: LIST
16350: LIST
16351: LIST
16352: LIST
16353: ST_TO_ADDR
16354: GO 17213
16356: LD_INT 5
16358: DOUBLE
16359: EQUAL
16360: IFTRUE 16364
16362: GO 16390
16364: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
16365: LD_ADDR_VAR 0 3
16369: PUSH
16370: LD_INT 2
16372: PUSH
16373: LD_INT 3
16375: PUSH
16376: LD_INT 4
16378: PUSH
16379: LD_INT 5
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: LIST
16386: LIST
16387: ST_TO_ADDR
16388: GO 17213
16390: LD_INT 9
16392: DOUBLE
16393: EQUAL
16394: IFTRUE 16398
16396: GO 16424
16398: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
16399: LD_ADDR_VAR 0 3
16403: PUSH
16404: LD_INT 2
16406: PUSH
16407: LD_INT 3
16409: PUSH
16410: LD_INT 4
16412: PUSH
16413: LD_INT 5
16415: PUSH
16416: EMPTY
16417: LIST
16418: LIST
16419: LIST
16420: LIST
16421: ST_TO_ADDR
16422: GO 17213
16424: LD_INT 7
16426: DOUBLE
16427: EQUAL
16428: IFTRUE 16432
16430: GO 16458
16432: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
16433: LD_ADDR_VAR 0 3
16437: PUSH
16438: LD_INT 2
16440: PUSH
16441: LD_INT 3
16443: PUSH
16444: LD_INT 4
16446: PUSH
16447: LD_INT 5
16449: PUSH
16450: EMPTY
16451: LIST
16452: LIST
16453: LIST
16454: LIST
16455: ST_TO_ADDR
16456: GO 17213
16458: LD_INT 12
16460: DOUBLE
16461: EQUAL
16462: IFTRUE 16466
16464: GO 16492
16466: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
16467: LD_ADDR_VAR 0 3
16471: PUSH
16472: LD_INT 2
16474: PUSH
16475: LD_INT 3
16477: PUSH
16478: LD_INT 4
16480: PUSH
16481: LD_INT 5
16483: PUSH
16484: EMPTY
16485: LIST
16486: LIST
16487: LIST
16488: LIST
16489: ST_TO_ADDR
16490: GO 17213
16492: LD_INT 13
16494: DOUBLE
16495: EQUAL
16496: IFTRUE 16500
16498: GO 16526
16500: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
16501: LD_ADDR_VAR 0 3
16505: PUSH
16506: LD_INT 2
16508: PUSH
16509: LD_INT 3
16511: PUSH
16512: LD_INT 4
16514: PUSH
16515: LD_INT 5
16517: PUSH
16518: EMPTY
16519: LIST
16520: LIST
16521: LIST
16522: LIST
16523: ST_TO_ADDR
16524: GO 17213
16526: LD_INT 14
16528: DOUBLE
16529: EQUAL
16530: IFTRUE 16534
16532: GO 16552
16534: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
16535: LD_ADDR_VAR 0 3
16539: PUSH
16540: LD_INT 4
16542: PUSH
16543: LD_INT 5
16545: PUSH
16546: EMPTY
16547: LIST
16548: LIST
16549: ST_TO_ADDR
16550: GO 17213
16552: LD_INT 6
16554: DOUBLE
16555: EQUAL
16556: IFTRUE 16560
16558: GO 16578
16560: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
16561: LD_ADDR_VAR 0 3
16565: PUSH
16566: LD_INT 4
16568: PUSH
16569: LD_INT 5
16571: PUSH
16572: EMPTY
16573: LIST
16574: LIST
16575: ST_TO_ADDR
16576: GO 17213
16578: LD_INT 10
16580: DOUBLE
16581: EQUAL
16582: IFTRUE 16586
16584: GO 16604
16586: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
16587: LD_ADDR_VAR 0 3
16591: PUSH
16592: LD_INT 4
16594: PUSH
16595: LD_INT 5
16597: PUSH
16598: EMPTY
16599: LIST
16600: LIST
16601: ST_TO_ADDR
16602: GO 17213
16604: LD_INT 22
16606: DOUBLE
16607: EQUAL
16608: IFTRUE 16612
16610: GO 16638
16612: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
16613: LD_ADDR_VAR 0 3
16617: PUSH
16618: LD_INT 11
16620: PUSH
16621: LD_INT 12
16623: PUSH
16624: LD_INT 13
16626: PUSH
16627: LD_INT 14
16629: PUSH
16630: EMPTY
16631: LIST
16632: LIST
16633: LIST
16634: LIST
16635: ST_TO_ADDR
16636: GO 17213
16638: LD_INT 23
16640: DOUBLE
16641: EQUAL
16642: IFTRUE 16646
16644: GO 16672
16646: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
16647: LD_ADDR_VAR 0 3
16651: PUSH
16652: LD_INT 11
16654: PUSH
16655: LD_INT 12
16657: PUSH
16658: LD_INT 13
16660: PUSH
16661: LD_INT 14
16663: PUSH
16664: EMPTY
16665: LIST
16666: LIST
16667: LIST
16668: LIST
16669: ST_TO_ADDR
16670: GO 17213
16672: LD_INT 24
16674: DOUBLE
16675: EQUAL
16676: IFTRUE 16680
16678: GO 16706
16680: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
16681: LD_ADDR_VAR 0 3
16685: PUSH
16686: LD_INT 11
16688: PUSH
16689: LD_INT 12
16691: PUSH
16692: LD_INT 13
16694: PUSH
16695: LD_INT 14
16697: PUSH
16698: EMPTY
16699: LIST
16700: LIST
16701: LIST
16702: LIST
16703: ST_TO_ADDR
16704: GO 17213
16706: LD_INT 30
16708: DOUBLE
16709: EQUAL
16710: IFTRUE 16714
16712: GO 16740
16714: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
16715: LD_ADDR_VAR 0 3
16719: PUSH
16720: LD_INT 11
16722: PUSH
16723: LD_INT 12
16725: PUSH
16726: LD_INT 13
16728: PUSH
16729: LD_INT 14
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: LIST
16736: LIST
16737: ST_TO_ADDR
16738: GO 17213
16740: LD_INT 25
16742: DOUBLE
16743: EQUAL
16744: IFTRUE 16748
16746: GO 16766
16748: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
16749: LD_ADDR_VAR 0 3
16753: PUSH
16754: LD_INT 13
16756: PUSH
16757: LD_INT 14
16759: PUSH
16760: EMPTY
16761: LIST
16762: LIST
16763: ST_TO_ADDR
16764: GO 17213
16766: LD_INT 27
16768: DOUBLE
16769: EQUAL
16770: IFTRUE 16774
16772: GO 16792
16774: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
16775: LD_ADDR_VAR 0 3
16779: PUSH
16780: LD_INT 13
16782: PUSH
16783: LD_INT 14
16785: PUSH
16786: EMPTY
16787: LIST
16788: LIST
16789: ST_TO_ADDR
16790: GO 17213
16792: LD_INT 28
16794: DOUBLE
16795: EQUAL
16796: IFTRUE 16800
16798: GO 16818
16800: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
16801: LD_ADDR_VAR 0 3
16805: PUSH
16806: LD_INT 13
16808: PUSH
16809: LD_INT 14
16811: PUSH
16812: EMPTY
16813: LIST
16814: LIST
16815: ST_TO_ADDR
16816: GO 17213
16818: LD_INT 29
16820: DOUBLE
16821: EQUAL
16822: IFTRUE 16826
16824: GO 16844
16826: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
16827: LD_ADDR_VAR 0 3
16831: PUSH
16832: LD_INT 13
16834: PUSH
16835: LD_INT 14
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: ST_TO_ADDR
16842: GO 17213
16844: LD_INT 31
16846: DOUBLE
16847: EQUAL
16848: IFTRUE 16852
16850: GO 16870
16852: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
16853: LD_ADDR_VAR 0 3
16857: PUSH
16858: LD_INT 13
16860: PUSH
16861: LD_INT 14
16863: PUSH
16864: EMPTY
16865: LIST
16866: LIST
16867: ST_TO_ADDR
16868: GO 17213
16870: LD_INT 26
16872: DOUBLE
16873: EQUAL
16874: IFTRUE 16878
16876: GO 16896
16878: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
16879: LD_ADDR_VAR 0 3
16883: PUSH
16884: LD_INT 13
16886: PUSH
16887: LD_INT 14
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: ST_TO_ADDR
16894: GO 17213
16896: LD_INT 42
16898: DOUBLE
16899: EQUAL
16900: IFTRUE 16904
16902: GO 16930
16904: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
16905: LD_ADDR_VAR 0 3
16909: PUSH
16910: LD_INT 21
16912: PUSH
16913: LD_INT 22
16915: PUSH
16916: LD_INT 23
16918: PUSH
16919: LD_INT 24
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: LIST
16926: LIST
16927: ST_TO_ADDR
16928: GO 17213
16930: LD_INT 43
16932: DOUBLE
16933: EQUAL
16934: IFTRUE 16938
16936: GO 16964
16938: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
16939: LD_ADDR_VAR 0 3
16943: PUSH
16944: LD_INT 21
16946: PUSH
16947: LD_INT 22
16949: PUSH
16950: LD_INT 23
16952: PUSH
16953: LD_INT 24
16955: PUSH
16956: EMPTY
16957: LIST
16958: LIST
16959: LIST
16960: LIST
16961: ST_TO_ADDR
16962: GO 17213
16964: LD_INT 44
16966: DOUBLE
16967: EQUAL
16968: IFTRUE 16972
16970: GO 16998
16972: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
16973: LD_ADDR_VAR 0 3
16977: PUSH
16978: LD_INT 21
16980: PUSH
16981: LD_INT 22
16983: PUSH
16984: LD_INT 23
16986: PUSH
16987: LD_INT 24
16989: PUSH
16990: EMPTY
16991: LIST
16992: LIST
16993: LIST
16994: LIST
16995: ST_TO_ADDR
16996: GO 17213
16998: LD_INT 45
17000: DOUBLE
17001: EQUAL
17002: IFTRUE 17006
17004: GO 17032
17006: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17007: LD_ADDR_VAR 0 3
17011: PUSH
17012: LD_INT 21
17014: PUSH
17015: LD_INT 22
17017: PUSH
17018: LD_INT 23
17020: PUSH
17021: LD_INT 24
17023: PUSH
17024: EMPTY
17025: LIST
17026: LIST
17027: LIST
17028: LIST
17029: ST_TO_ADDR
17030: GO 17213
17032: LD_INT 49
17034: DOUBLE
17035: EQUAL
17036: IFTRUE 17040
17038: GO 17066
17040: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17041: LD_ADDR_VAR 0 3
17045: PUSH
17046: LD_INT 21
17048: PUSH
17049: LD_INT 22
17051: PUSH
17052: LD_INT 23
17054: PUSH
17055: LD_INT 24
17057: PUSH
17058: EMPTY
17059: LIST
17060: LIST
17061: LIST
17062: LIST
17063: ST_TO_ADDR
17064: GO 17213
17066: LD_INT 51
17068: DOUBLE
17069: EQUAL
17070: IFTRUE 17074
17072: GO 17100
17074: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
17075: LD_ADDR_VAR 0 3
17079: PUSH
17080: LD_INT 21
17082: PUSH
17083: LD_INT 22
17085: PUSH
17086: LD_INT 23
17088: PUSH
17089: LD_INT 24
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: LIST
17096: LIST
17097: ST_TO_ADDR
17098: GO 17213
17100: LD_INT 52
17102: DOUBLE
17103: EQUAL
17104: IFTRUE 17108
17106: GO 17134
17108: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
17109: LD_ADDR_VAR 0 3
17113: PUSH
17114: LD_INT 21
17116: PUSH
17117: LD_INT 22
17119: PUSH
17120: LD_INT 23
17122: PUSH
17123: LD_INT 24
17125: PUSH
17126: EMPTY
17127: LIST
17128: LIST
17129: LIST
17130: LIST
17131: ST_TO_ADDR
17132: GO 17213
17134: LD_INT 53
17136: DOUBLE
17137: EQUAL
17138: IFTRUE 17142
17140: GO 17160
17142: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
17143: LD_ADDR_VAR 0 3
17147: PUSH
17148: LD_INT 23
17150: PUSH
17151: LD_INT 24
17153: PUSH
17154: EMPTY
17155: LIST
17156: LIST
17157: ST_TO_ADDR
17158: GO 17213
17160: LD_INT 46
17162: DOUBLE
17163: EQUAL
17164: IFTRUE 17168
17166: GO 17186
17168: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
17169: LD_ADDR_VAR 0 3
17173: PUSH
17174: LD_INT 23
17176: PUSH
17177: LD_INT 24
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: ST_TO_ADDR
17184: GO 17213
17186: LD_INT 47
17188: DOUBLE
17189: EQUAL
17190: IFTRUE 17194
17192: GO 17212
17194: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17195: LD_ADDR_VAR 0 3
17199: PUSH
17200: LD_INT 23
17202: PUSH
17203: LD_INT 24
17205: PUSH
17206: EMPTY
17207: LIST
17208: LIST
17209: ST_TO_ADDR
17210: GO 17213
17212: POP
// result := ( chassis in result ) ;
17213: LD_ADDR_VAR 0 3
17217: PUSH
17218: LD_VAR 0 1
17222: PUSH
17223: LD_VAR 0 3
17227: IN
17228: ST_TO_ADDR
// end ;
17229: LD_VAR 0 3
17233: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
17234: LD_INT 0
17236: PPUSH
17237: PPUSH
17238: PPUSH
17239: PPUSH
17240: PPUSH
17241: PPUSH
17242: PPUSH
// result := array ;
17243: LD_ADDR_VAR 0 5
17247: PUSH
17248: LD_VAR 0 1
17252: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
17253: LD_VAR 0 1
17257: NOT
17258: PUSH
17259: LD_VAR 0 2
17263: NOT
17264: OR
17265: PUSH
17266: LD_VAR 0 3
17270: NOT
17271: OR
17272: PUSH
17273: LD_VAR 0 2
17277: PUSH
17278: LD_VAR 0 1
17282: GREATER
17283: OR
17284: PUSH
17285: LD_VAR 0 3
17289: PUSH
17290: LD_VAR 0 1
17294: GREATER
17295: OR
17296: IFFALSE 17300
// exit ;
17298: GO 17596
// if direction then
17300: LD_VAR 0 4
17304: IFFALSE 17368
// begin d := 1 ;
17306: LD_ADDR_VAR 0 9
17310: PUSH
17311: LD_INT 1
17313: ST_TO_ADDR
// if i_from > i_to then
17314: LD_VAR 0 2
17318: PUSH
17319: LD_VAR 0 3
17323: GREATER
17324: IFFALSE 17350
// length := ( array - i_from ) + i_to else
17326: LD_ADDR_VAR 0 11
17330: PUSH
17331: LD_VAR 0 1
17335: PUSH
17336: LD_VAR 0 2
17340: MINUS
17341: PUSH
17342: LD_VAR 0 3
17346: PLUS
17347: ST_TO_ADDR
17348: GO 17366
// length := i_to - i_from ;
17350: LD_ADDR_VAR 0 11
17354: PUSH
17355: LD_VAR 0 3
17359: PUSH
17360: LD_VAR 0 2
17364: MINUS
17365: ST_TO_ADDR
// end else
17366: GO 17429
// begin d := - 1 ;
17368: LD_ADDR_VAR 0 9
17372: PUSH
17373: LD_INT 1
17375: NEG
17376: ST_TO_ADDR
// if i_from > i_to then
17377: LD_VAR 0 2
17381: PUSH
17382: LD_VAR 0 3
17386: GREATER
17387: IFFALSE 17407
// length := i_from - i_to else
17389: LD_ADDR_VAR 0 11
17393: PUSH
17394: LD_VAR 0 2
17398: PUSH
17399: LD_VAR 0 3
17403: MINUS
17404: ST_TO_ADDR
17405: GO 17429
// length := ( array - i_to ) + i_from ;
17407: LD_ADDR_VAR 0 11
17411: PUSH
17412: LD_VAR 0 1
17416: PUSH
17417: LD_VAR 0 3
17421: MINUS
17422: PUSH
17423: LD_VAR 0 2
17427: PLUS
17428: ST_TO_ADDR
// end ; if not length then
17429: LD_VAR 0 11
17433: NOT
17434: IFFALSE 17438
// exit ;
17436: GO 17596
// tmp := array ;
17438: LD_ADDR_VAR 0 10
17442: PUSH
17443: LD_VAR 0 1
17447: ST_TO_ADDR
// for i = 1 to length do
17448: LD_ADDR_VAR 0 6
17452: PUSH
17453: DOUBLE
17454: LD_INT 1
17456: DEC
17457: ST_TO_ADDR
17458: LD_VAR 0 11
17462: PUSH
17463: FOR_TO
17464: IFFALSE 17584
// begin for j = 1 to array do
17466: LD_ADDR_VAR 0 7
17470: PUSH
17471: DOUBLE
17472: LD_INT 1
17474: DEC
17475: ST_TO_ADDR
17476: LD_VAR 0 1
17480: PUSH
17481: FOR_TO
17482: IFFALSE 17570
// begin k := j + d ;
17484: LD_ADDR_VAR 0 8
17488: PUSH
17489: LD_VAR 0 7
17493: PUSH
17494: LD_VAR 0 9
17498: PLUS
17499: ST_TO_ADDR
// if k > array then
17500: LD_VAR 0 8
17504: PUSH
17505: LD_VAR 0 1
17509: GREATER
17510: IFFALSE 17520
// k := 1 ;
17512: LD_ADDR_VAR 0 8
17516: PUSH
17517: LD_INT 1
17519: ST_TO_ADDR
// if not k then
17520: LD_VAR 0 8
17524: NOT
17525: IFFALSE 17537
// k := array ;
17527: LD_ADDR_VAR 0 8
17531: PUSH
17532: LD_VAR 0 1
17536: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
17537: LD_ADDR_VAR 0 10
17541: PUSH
17542: LD_VAR 0 10
17546: PPUSH
17547: LD_VAR 0 8
17551: PPUSH
17552: LD_VAR 0 1
17556: PUSH
17557: LD_VAR 0 7
17561: ARRAY
17562: PPUSH
17563: CALL_OW 1
17567: ST_TO_ADDR
// end ;
17568: GO 17481
17570: POP
17571: POP
// array := tmp ;
17572: LD_ADDR_VAR 0 1
17576: PUSH
17577: LD_VAR 0 10
17581: ST_TO_ADDR
// end ;
17582: GO 17463
17584: POP
17585: POP
// result := array ;
17586: LD_ADDR_VAR 0 5
17590: PUSH
17591: LD_VAR 0 1
17595: ST_TO_ADDR
// end ;
17596: LD_VAR 0 5
17600: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
17601: LD_INT 0
17603: PPUSH
17604: PPUSH
// result := 0 ;
17605: LD_ADDR_VAR 0 3
17609: PUSH
17610: LD_INT 0
17612: ST_TO_ADDR
// if not array or not value in array then
17613: LD_VAR 0 1
17617: NOT
17618: PUSH
17619: LD_VAR 0 2
17623: PUSH
17624: LD_VAR 0 1
17628: IN
17629: NOT
17630: OR
17631: IFFALSE 17635
// exit ;
17633: GO 17689
// for i = 1 to array do
17635: LD_ADDR_VAR 0 4
17639: PUSH
17640: DOUBLE
17641: LD_INT 1
17643: DEC
17644: ST_TO_ADDR
17645: LD_VAR 0 1
17649: PUSH
17650: FOR_TO
17651: IFFALSE 17687
// if value = array [ i ] then
17653: LD_VAR 0 2
17657: PUSH
17658: LD_VAR 0 1
17662: PUSH
17663: LD_VAR 0 4
17667: ARRAY
17668: EQUAL
17669: IFFALSE 17685
// begin result := i ;
17671: LD_ADDR_VAR 0 3
17675: PUSH
17676: LD_VAR 0 4
17680: ST_TO_ADDR
// exit ;
17681: POP
17682: POP
17683: GO 17689
// end ;
17685: GO 17650
17687: POP
17688: POP
// end ;
17689: LD_VAR 0 3
17693: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
17694: LD_INT 0
17696: PPUSH
// vc_chassis := chassis ;
17697: LD_ADDR_OWVAR 37
17701: PUSH
17702: LD_VAR 0 1
17706: ST_TO_ADDR
// vc_engine := engine ;
17707: LD_ADDR_OWVAR 39
17711: PUSH
17712: LD_VAR 0 2
17716: ST_TO_ADDR
// vc_control := control ;
17717: LD_ADDR_OWVAR 38
17721: PUSH
17722: LD_VAR 0 3
17726: ST_TO_ADDR
// vc_weapon := weapon ;
17727: LD_ADDR_OWVAR 40
17731: PUSH
17732: LD_VAR 0 4
17736: ST_TO_ADDR
// vc_fuel_battery := fuel ;
17737: LD_ADDR_OWVAR 41
17741: PUSH
17742: LD_VAR 0 5
17746: ST_TO_ADDR
// end ;
17747: LD_VAR 0 6
17751: RET
// export function WantPlant ( unit ) ; var task ; begin
17752: LD_INT 0
17754: PPUSH
17755: PPUSH
// result := false ;
17756: LD_ADDR_VAR 0 2
17760: PUSH
17761: LD_INT 0
17763: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
17764: LD_ADDR_VAR 0 3
17768: PUSH
17769: LD_VAR 0 1
17773: PPUSH
17774: CALL_OW 437
17778: ST_TO_ADDR
// if task then
17779: LD_VAR 0 3
17783: IFFALSE 17811
// if task [ 1 ] [ 1 ] = p then
17785: LD_VAR 0 3
17789: PUSH
17790: LD_INT 1
17792: ARRAY
17793: PUSH
17794: LD_INT 1
17796: ARRAY
17797: PUSH
17798: LD_STRING p
17800: EQUAL
17801: IFFALSE 17811
// result := true ;
17803: LD_ADDR_VAR 0 2
17807: PUSH
17808: LD_INT 1
17810: ST_TO_ADDR
// end ;
17811: LD_VAR 0 2
17815: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
17816: LD_INT 0
17818: PPUSH
17819: PPUSH
17820: PPUSH
17821: PPUSH
// if pos < 1 then
17822: LD_VAR 0 2
17826: PUSH
17827: LD_INT 1
17829: LESS
17830: IFFALSE 17834
// exit ;
17832: GO 18137
// if pos = 1 then
17834: LD_VAR 0 2
17838: PUSH
17839: LD_INT 1
17841: EQUAL
17842: IFFALSE 17875
// result := Replace ( arr , pos [ 1 ] , value ) else
17844: LD_ADDR_VAR 0 4
17848: PUSH
17849: LD_VAR 0 1
17853: PPUSH
17854: LD_VAR 0 2
17858: PUSH
17859: LD_INT 1
17861: ARRAY
17862: PPUSH
17863: LD_VAR 0 3
17867: PPUSH
17868: CALL_OW 1
17872: ST_TO_ADDR
17873: GO 18137
// begin tmp := arr ;
17875: LD_ADDR_VAR 0 6
17879: PUSH
17880: LD_VAR 0 1
17884: ST_TO_ADDR
// s_arr := [ tmp ] ;
17885: LD_ADDR_VAR 0 7
17889: PUSH
17890: LD_VAR 0 6
17894: PUSH
17895: EMPTY
17896: LIST
17897: ST_TO_ADDR
// for i = 1 to pos - 1 do
17898: LD_ADDR_VAR 0 5
17902: PUSH
17903: DOUBLE
17904: LD_INT 1
17906: DEC
17907: ST_TO_ADDR
17908: LD_VAR 0 2
17912: PUSH
17913: LD_INT 1
17915: MINUS
17916: PUSH
17917: FOR_TO
17918: IFFALSE 17963
// begin tmp := tmp [ pos [ i ] ] ;
17920: LD_ADDR_VAR 0 6
17924: PUSH
17925: LD_VAR 0 6
17929: PUSH
17930: LD_VAR 0 2
17934: PUSH
17935: LD_VAR 0 5
17939: ARRAY
17940: ARRAY
17941: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
17942: LD_ADDR_VAR 0 7
17946: PUSH
17947: LD_VAR 0 7
17951: PUSH
17952: LD_VAR 0 6
17956: PUSH
17957: EMPTY
17958: LIST
17959: ADD
17960: ST_TO_ADDR
// end ;
17961: GO 17917
17963: POP
17964: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
17965: LD_ADDR_VAR 0 6
17969: PUSH
17970: LD_VAR 0 6
17974: PPUSH
17975: LD_VAR 0 2
17979: PUSH
17980: LD_VAR 0 2
17984: ARRAY
17985: PPUSH
17986: LD_VAR 0 3
17990: PPUSH
17991: CALL_OW 1
17995: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
17996: LD_ADDR_VAR 0 7
18000: PUSH
18001: LD_VAR 0 7
18005: PPUSH
18006: LD_VAR 0 7
18010: PPUSH
18011: LD_VAR 0 6
18015: PPUSH
18016: CALL_OW 1
18020: ST_TO_ADDR
// for i = s_arr downto 2 do
18021: LD_ADDR_VAR 0 5
18025: PUSH
18026: DOUBLE
18027: LD_VAR 0 7
18031: INC
18032: ST_TO_ADDR
18033: LD_INT 2
18035: PUSH
18036: FOR_DOWNTO
18037: IFFALSE 18121
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18039: LD_ADDR_VAR 0 6
18043: PUSH
18044: LD_VAR 0 7
18048: PUSH
18049: LD_VAR 0 5
18053: PUSH
18054: LD_INT 1
18056: MINUS
18057: ARRAY
18058: PPUSH
18059: LD_VAR 0 2
18063: PUSH
18064: LD_VAR 0 5
18068: PUSH
18069: LD_INT 1
18071: MINUS
18072: ARRAY
18073: PPUSH
18074: LD_VAR 0 7
18078: PUSH
18079: LD_VAR 0 5
18083: ARRAY
18084: PPUSH
18085: CALL_OW 1
18089: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
18090: LD_ADDR_VAR 0 7
18094: PUSH
18095: LD_VAR 0 7
18099: PPUSH
18100: LD_VAR 0 5
18104: PUSH
18105: LD_INT 1
18107: MINUS
18108: PPUSH
18109: LD_VAR 0 6
18113: PPUSH
18114: CALL_OW 1
18118: ST_TO_ADDR
// end ;
18119: GO 18036
18121: POP
18122: POP
// result := s_arr [ 1 ] ;
18123: LD_ADDR_VAR 0 4
18127: PUSH
18128: LD_VAR 0 7
18132: PUSH
18133: LD_INT 1
18135: ARRAY
18136: ST_TO_ADDR
// end ; end ;
18137: LD_VAR 0 4
18141: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
18142: LD_INT 0
18144: PPUSH
18145: PPUSH
// if not list then
18146: LD_VAR 0 1
18150: NOT
18151: IFFALSE 18155
// exit ;
18153: GO 18246
// i := list [ pos1 ] ;
18155: LD_ADDR_VAR 0 5
18159: PUSH
18160: LD_VAR 0 1
18164: PUSH
18165: LD_VAR 0 2
18169: ARRAY
18170: ST_TO_ADDR
// if not i then
18171: LD_VAR 0 5
18175: NOT
18176: IFFALSE 18180
// exit ;
18178: GO 18246
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
18180: LD_ADDR_VAR 0 1
18184: PUSH
18185: LD_VAR 0 1
18189: PPUSH
18190: LD_VAR 0 2
18194: PPUSH
18195: LD_VAR 0 1
18199: PUSH
18200: LD_VAR 0 3
18204: ARRAY
18205: PPUSH
18206: CALL_OW 1
18210: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
18211: LD_ADDR_VAR 0 1
18215: PUSH
18216: LD_VAR 0 1
18220: PPUSH
18221: LD_VAR 0 3
18225: PPUSH
18226: LD_VAR 0 5
18230: PPUSH
18231: CALL_OW 1
18235: ST_TO_ADDR
// result := list ;
18236: LD_ADDR_VAR 0 4
18240: PUSH
18241: LD_VAR 0 1
18245: ST_TO_ADDR
// end ;
18246: LD_VAR 0 4
18250: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
18251: LD_INT 0
18253: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
18254: LD_ADDR_VAR 0 5
18258: PUSH
18259: LD_VAR 0 1
18263: PPUSH
18264: CALL_OW 250
18268: PPUSH
18269: LD_VAR 0 1
18273: PPUSH
18274: CALL_OW 251
18278: PPUSH
18279: LD_VAR 0 2
18283: PPUSH
18284: LD_VAR 0 3
18288: PPUSH
18289: LD_VAR 0 4
18293: PPUSH
18294: CALL 18304 0 5
18298: ST_TO_ADDR
// end ;
18299: LD_VAR 0 5
18303: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
18304: LD_INT 0
18306: PPUSH
18307: PPUSH
18308: PPUSH
18309: PPUSH
// if not list then
18310: LD_VAR 0 3
18314: NOT
18315: IFFALSE 18319
// exit ;
18317: GO 18707
// result := [ ] ;
18319: LD_ADDR_VAR 0 6
18323: PUSH
18324: EMPTY
18325: ST_TO_ADDR
// for i in list do
18326: LD_ADDR_VAR 0 7
18330: PUSH
18331: LD_VAR 0 3
18335: PUSH
18336: FOR_IN
18337: IFFALSE 18539
// begin tmp := GetDistUnitXY ( i , x , y ) ;
18339: LD_ADDR_VAR 0 9
18343: PUSH
18344: LD_VAR 0 7
18348: PPUSH
18349: LD_VAR 0 1
18353: PPUSH
18354: LD_VAR 0 2
18358: PPUSH
18359: CALL_OW 297
18363: ST_TO_ADDR
// if not result then
18364: LD_VAR 0 6
18368: NOT
18369: IFFALSE 18395
// result := [ [ i , tmp ] ] else
18371: LD_ADDR_VAR 0 6
18375: PUSH
18376: LD_VAR 0 7
18380: PUSH
18381: LD_VAR 0 9
18385: PUSH
18386: EMPTY
18387: LIST
18388: LIST
18389: PUSH
18390: EMPTY
18391: LIST
18392: ST_TO_ADDR
18393: GO 18537
// begin if result [ result ] [ 2 ] < tmp then
18395: LD_VAR 0 6
18399: PUSH
18400: LD_VAR 0 6
18404: ARRAY
18405: PUSH
18406: LD_INT 2
18408: ARRAY
18409: PUSH
18410: LD_VAR 0 9
18414: LESS
18415: IFFALSE 18457
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
18417: LD_ADDR_VAR 0 6
18421: PUSH
18422: LD_VAR 0 6
18426: PPUSH
18427: LD_VAR 0 6
18431: PUSH
18432: LD_INT 1
18434: PLUS
18435: PPUSH
18436: LD_VAR 0 7
18440: PUSH
18441: LD_VAR 0 9
18445: PUSH
18446: EMPTY
18447: LIST
18448: LIST
18449: PPUSH
18450: CALL_OW 2
18454: ST_TO_ADDR
18455: GO 18537
// for j = 1 to result do
18457: LD_ADDR_VAR 0 8
18461: PUSH
18462: DOUBLE
18463: LD_INT 1
18465: DEC
18466: ST_TO_ADDR
18467: LD_VAR 0 6
18471: PUSH
18472: FOR_TO
18473: IFFALSE 18535
// begin if tmp < result [ j ] [ 2 ] then
18475: LD_VAR 0 9
18479: PUSH
18480: LD_VAR 0 6
18484: PUSH
18485: LD_VAR 0 8
18489: ARRAY
18490: PUSH
18491: LD_INT 2
18493: ARRAY
18494: LESS
18495: IFFALSE 18533
// begin result := Insert ( result , j , [ i , tmp ] ) ;
18497: LD_ADDR_VAR 0 6
18501: PUSH
18502: LD_VAR 0 6
18506: PPUSH
18507: LD_VAR 0 8
18511: PPUSH
18512: LD_VAR 0 7
18516: PUSH
18517: LD_VAR 0 9
18521: PUSH
18522: EMPTY
18523: LIST
18524: LIST
18525: PPUSH
18526: CALL_OW 2
18530: ST_TO_ADDR
// break ;
18531: GO 18535
// end ; end ;
18533: GO 18472
18535: POP
18536: POP
// end ; end ;
18537: GO 18336
18539: POP
18540: POP
// if result and not asc then
18541: LD_VAR 0 6
18545: PUSH
18546: LD_VAR 0 4
18550: NOT
18551: AND
18552: IFFALSE 18627
// begin tmp := result ;
18554: LD_ADDR_VAR 0 9
18558: PUSH
18559: LD_VAR 0 6
18563: ST_TO_ADDR
// for i = tmp downto 1 do
18564: LD_ADDR_VAR 0 7
18568: PUSH
18569: DOUBLE
18570: LD_VAR 0 9
18574: INC
18575: ST_TO_ADDR
18576: LD_INT 1
18578: PUSH
18579: FOR_DOWNTO
18580: IFFALSE 18625
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
18582: LD_ADDR_VAR 0 6
18586: PUSH
18587: LD_VAR 0 6
18591: PPUSH
18592: LD_VAR 0 9
18596: PUSH
18597: LD_VAR 0 7
18601: MINUS
18602: PUSH
18603: LD_INT 1
18605: PLUS
18606: PPUSH
18607: LD_VAR 0 9
18611: PUSH
18612: LD_VAR 0 7
18616: ARRAY
18617: PPUSH
18618: CALL_OW 1
18622: ST_TO_ADDR
18623: GO 18579
18625: POP
18626: POP
// end ; tmp := [ ] ;
18627: LD_ADDR_VAR 0 9
18631: PUSH
18632: EMPTY
18633: ST_TO_ADDR
// if mode then
18634: LD_VAR 0 5
18638: IFFALSE 18707
// begin for i = 1 to result do
18640: LD_ADDR_VAR 0 7
18644: PUSH
18645: DOUBLE
18646: LD_INT 1
18648: DEC
18649: ST_TO_ADDR
18650: LD_VAR 0 6
18654: PUSH
18655: FOR_TO
18656: IFFALSE 18695
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
18658: LD_ADDR_VAR 0 9
18662: PUSH
18663: LD_VAR 0 9
18667: PPUSH
18668: LD_VAR 0 7
18672: PPUSH
18673: LD_VAR 0 6
18677: PUSH
18678: LD_VAR 0 7
18682: ARRAY
18683: PUSH
18684: LD_INT 1
18686: ARRAY
18687: PPUSH
18688: CALL_OW 1
18692: ST_TO_ADDR
18693: GO 18655
18695: POP
18696: POP
// result := tmp ;
18697: LD_ADDR_VAR 0 6
18701: PUSH
18702: LD_VAR 0 9
18706: ST_TO_ADDR
// end ; end ;
18707: LD_VAR 0 6
18711: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
18712: LD_INT 0
18714: PPUSH
18715: PPUSH
18716: PPUSH
18717: PPUSH
18718: PPUSH
18719: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
18720: LD_ADDR_VAR 0 5
18724: PUSH
18725: LD_INT 0
18727: PUSH
18728: LD_INT 0
18730: PUSH
18731: LD_INT 0
18733: PUSH
18734: EMPTY
18735: PUSH
18736: EMPTY
18737: LIST
18738: LIST
18739: LIST
18740: LIST
18741: ST_TO_ADDR
// if not x or not y then
18742: LD_VAR 0 2
18746: NOT
18747: PUSH
18748: LD_VAR 0 3
18752: NOT
18753: OR
18754: IFFALSE 18758
// exit ;
18756: GO 20404
// if not range then
18758: LD_VAR 0 4
18762: NOT
18763: IFFALSE 18773
// range := 10 ;
18765: LD_ADDR_VAR 0 4
18769: PUSH
18770: LD_INT 10
18772: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18773: LD_ADDR_VAR 0 8
18777: PUSH
18778: LD_INT 81
18780: PUSH
18781: LD_VAR 0 1
18785: PUSH
18786: EMPTY
18787: LIST
18788: LIST
18789: PUSH
18790: LD_INT 92
18792: PUSH
18793: LD_VAR 0 2
18797: PUSH
18798: LD_VAR 0 3
18802: PUSH
18803: LD_VAR 0 4
18807: PUSH
18808: EMPTY
18809: LIST
18810: LIST
18811: LIST
18812: LIST
18813: PUSH
18814: LD_INT 3
18816: PUSH
18817: LD_INT 21
18819: PUSH
18820: LD_INT 3
18822: PUSH
18823: EMPTY
18824: LIST
18825: LIST
18826: PUSH
18827: EMPTY
18828: LIST
18829: LIST
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: LIST
18835: PPUSH
18836: CALL_OW 69
18840: ST_TO_ADDR
// if not tmp then
18841: LD_VAR 0 8
18845: NOT
18846: IFFALSE 18850
// exit ;
18848: GO 20404
// for i in tmp do
18850: LD_ADDR_VAR 0 6
18854: PUSH
18855: LD_VAR 0 8
18859: PUSH
18860: FOR_IN
18861: IFFALSE 20379
// begin points := [ 0 , 0 , 0 ] ;
18863: LD_ADDR_VAR 0 9
18867: PUSH
18868: LD_INT 0
18870: PUSH
18871: LD_INT 0
18873: PUSH
18874: LD_INT 0
18876: PUSH
18877: EMPTY
18878: LIST
18879: LIST
18880: LIST
18881: ST_TO_ADDR
// bpoints := 1 ;
18882: LD_ADDR_VAR 0 10
18886: PUSH
18887: LD_INT 1
18889: ST_TO_ADDR
// case GetType ( i ) of unit_human :
18890: LD_VAR 0 6
18894: PPUSH
18895: CALL_OW 247
18899: PUSH
18900: LD_INT 1
18902: DOUBLE
18903: EQUAL
18904: IFTRUE 18908
18906: GO 19486
18908: POP
// begin if GetClass ( i ) = 1 then
18909: LD_VAR 0 6
18913: PPUSH
18914: CALL_OW 257
18918: PUSH
18919: LD_INT 1
18921: EQUAL
18922: IFFALSE 18943
// points := [ 10 , 5 , 3 ] ;
18924: LD_ADDR_VAR 0 9
18928: PUSH
18929: LD_INT 10
18931: PUSH
18932: LD_INT 5
18934: PUSH
18935: LD_INT 3
18937: PUSH
18938: EMPTY
18939: LIST
18940: LIST
18941: LIST
18942: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
18943: LD_VAR 0 6
18947: PPUSH
18948: CALL_OW 257
18952: PUSH
18953: LD_INT 2
18955: PUSH
18956: LD_INT 3
18958: PUSH
18959: LD_INT 4
18961: PUSH
18962: EMPTY
18963: LIST
18964: LIST
18965: LIST
18966: IN
18967: IFFALSE 18988
// points := [ 3 , 2 , 1 ] ;
18969: LD_ADDR_VAR 0 9
18973: PUSH
18974: LD_INT 3
18976: PUSH
18977: LD_INT 2
18979: PUSH
18980: LD_INT 1
18982: PUSH
18983: EMPTY
18984: LIST
18985: LIST
18986: LIST
18987: ST_TO_ADDR
// if GetClass ( i ) = 5 then
18988: LD_VAR 0 6
18992: PPUSH
18993: CALL_OW 257
18997: PUSH
18998: LD_INT 5
19000: EQUAL
19001: IFFALSE 19022
// points := [ 130 , 5 , 2 ] ;
19003: LD_ADDR_VAR 0 9
19007: PUSH
19008: LD_INT 130
19010: PUSH
19011: LD_INT 5
19013: PUSH
19014: LD_INT 2
19016: PUSH
19017: EMPTY
19018: LIST
19019: LIST
19020: LIST
19021: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19022: LD_VAR 0 6
19026: PPUSH
19027: CALL_OW 257
19031: PUSH
19032: LD_INT 8
19034: EQUAL
19035: IFFALSE 19056
// points := [ 35 , 35 , 30 ] ;
19037: LD_ADDR_VAR 0 9
19041: PUSH
19042: LD_INT 35
19044: PUSH
19045: LD_INT 35
19047: PUSH
19048: LD_INT 30
19050: PUSH
19051: EMPTY
19052: LIST
19053: LIST
19054: LIST
19055: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19056: LD_VAR 0 6
19060: PPUSH
19061: CALL_OW 257
19065: PUSH
19066: LD_INT 9
19068: EQUAL
19069: IFFALSE 19090
// points := [ 20 , 55 , 40 ] ;
19071: LD_ADDR_VAR 0 9
19075: PUSH
19076: LD_INT 20
19078: PUSH
19079: LD_INT 55
19081: PUSH
19082: LD_INT 40
19084: PUSH
19085: EMPTY
19086: LIST
19087: LIST
19088: LIST
19089: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
19090: LD_VAR 0 6
19094: PPUSH
19095: CALL_OW 257
19099: PUSH
19100: LD_INT 12
19102: PUSH
19103: LD_INT 16
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: IN
19110: IFFALSE 19131
// points := [ 5 , 3 , 2 ] ;
19112: LD_ADDR_VAR 0 9
19116: PUSH
19117: LD_INT 5
19119: PUSH
19120: LD_INT 3
19122: PUSH
19123: LD_INT 2
19125: PUSH
19126: EMPTY
19127: LIST
19128: LIST
19129: LIST
19130: ST_TO_ADDR
// if GetClass ( i ) = 17 then
19131: LD_VAR 0 6
19135: PPUSH
19136: CALL_OW 257
19140: PUSH
19141: LD_INT 17
19143: EQUAL
19144: IFFALSE 19165
// points := [ 100 , 50 , 75 ] ;
19146: LD_ADDR_VAR 0 9
19150: PUSH
19151: LD_INT 100
19153: PUSH
19154: LD_INT 50
19156: PUSH
19157: LD_INT 75
19159: PUSH
19160: EMPTY
19161: LIST
19162: LIST
19163: LIST
19164: ST_TO_ADDR
// if GetClass ( i ) = 15 then
19165: LD_VAR 0 6
19169: PPUSH
19170: CALL_OW 257
19174: PUSH
19175: LD_INT 15
19177: EQUAL
19178: IFFALSE 19199
// points := [ 10 , 5 , 3 ] ;
19180: LD_ADDR_VAR 0 9
19184: PUSH
19185: LD_INT 10
19187: PUSH
19188: LD_INT 5
19190: PUSH
19191: LD_INT 3
19193: PUSH
19194: EMPTY
19195: LIST
19196: LIST
19197: LIST
19198: ST_TO_ADDR
// if GetClass ( i ) = 14 then
19199: LD_VAR 0 6
19203: PPUSH
19204: CALL_OW 257
19208: PUSH
19209: LD_INT 14
19211: EQUAL
19212: IFFALSE 19233
// points := [ 10 , 0 , 0 ] ;
19214: LD_ADDR_VAR 0 9
19218: PUSH
19219: LD_INT 10
19221: PUSH
19222: LD_INT 0
19224: PUSH
19225: LD_INT 0
19227: PUSH
19228: EMPTY
19229: LIST
19230: LIST
19231: LIST
19232: ST_TO_ADDR
// if GetClass ( i ) = 11 then
19233: LD_VAR 0 6
19237: PPUSH
19238: CALL_OW 257
19242: PUSH
19243: LD_INT 11
19245: EQUAL
19246: IFFALSE 19267
// points := [ 30 , 10 , 5 ] ;
19248: LD_ADDR_VAR 0 9
19252: PUSH
19253: LD_INT 30
19255: PUSH
19256: LD_INT 10
19258: PUSH
19259: LD_INT 5
19261: PUSH
19262: EMPTY
19263: LIST
19264: LIST
19265: LIST
19266: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
19267: LD_VAR 0 1
19271: PPUSH
19272: LD_INT 5
19274: PPUSH
19275: CALL_OW 321
19279: PUSH
19280: LD_INT 2
19282: EQUAL
19283: IFFALSE 19300
// bpoints := bpoints * 1.8 ;
19285: LD_ADDR_VAR 0 10
19289: PUSH
19290: LD_VAR 0 10
19294: PUSH
19295: LD_REAL  1.80000000000000E+0000
19298: MUL
19299: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
19300: LD_VAR 0 6
19304: PPUSH
19305: CALL_OW 257
19309: PUSH
19310: LD_INT 1
19312: PUSH
19313: LD_INT 2
19315: PUSH
19316: LD_INT 3
19318: PUSH
19319: LD_INT 4
19321: PUSH
19322: EMPTY
19323: LIST
19324: LIST
19325: LIST
19326: LIST
19327: IN
19328: PUSH
19329: LD_VAR 0 1
19333: PPUSH
19334: LD_INT 51
19336: PPUSH
19337: CALL_OW 321
19341: PUSH
19342: LD_INT 2
19344: EQUAL
19345: AND
19346: IFFALSE 19363
// bpoints := bpoints * 1.2 ;
19348: LD_ADDR_VAR 0 10
19352: PUSH
19353: LD_VAR 0 10
19357: PUSH
19358: LD_REAL  1.20000000000000E+0000
19361: MUL
19362: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
19363: LD_VAR 0 6
19367: PPUSH
19368: CALL_OW 257
19372: PUSH
19373: LD_INT 5
19375: PUSH
19376: LD_INT 7
19378: PUSH
19379: LD_INT 9
19381: PUSH
19382: EMPTY
19383: LIST
19384: LIST
19385: LIST
19386: IN
19387: PUSH
19388: LD_VAR 0 1
19392: PPUSH
19393: LD_INT 52
19395: PPUSH
19396: CALL_OW 321
19400: PUSH
19401: LD_INT 2
19403: EQUAL
19404: AND
19405: IFFALSE 19422
// bpoints := bpoints * 1.5 ;
19407: LD_ADDR_VAR 0 10
19411: PUSH
19412: LD_VAR 0 10
19416: PUSH
19417: LD_REAL  1.50000000000000E+0000
19420: MUL
19421: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
19422: LD_VAR 0 1
19426: PPUSH
19427: LD_INT 66
19429: PPUSH
19430: CALL_OW 321
19434: PUSH
19435: LD_INT 2
19437: EQUAL
19438: IFFALSE 19455
// bpoints := bpoints * 1.1 ;
19440: LD_ADDR_VAR 0 10
19444: PUSH
19445: LD_VAR 0 10
19449: PUSH
19450: LD_REAL  1.10000000000000E+0000
19453: MUL
19454: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
19455: LD_ADDR_VAR 0 10
19459: PUSH
19460: LD_VAR 0 10
19464: PUSH
19465: LD_VAR 0 6
19469: PPUSH
19470: LD_INT 1
19472: PPUSH
19473: CALL_OW 259
19477: PUSH
19478: LD_REAL  1.15000000000000E+0000
19481: MUL
19482: MUL
19483: ST_TO_ADDR
// end ; unit_vehicle :
19484: GO 20308
19486: LD_INT 2
19488: DOUBLE
19489: EQUAL
19490: IFTRUE 19494
19492: GO 20296
19494: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
19495: LD_VAR 0 6
19499: PPUSH
19500: CALL_OW 264
19504: PUSH
19505: LD_INT 2
19507: PUSH
19508: LD_INT 42
19510: PUSH
19511: LD_INT 24
19513: PUSH
19514: EMPTY
19515: LIST
19516: LIST
19517: LIST
19518: IN
19519: IFFALSE 19540
// points := [ 25 , 5 , 3 ] ;
19521: LD_ADDR_VAR 0 9
19525: PUSH
19526: LD_INT 25
19528: PUSH
19529: LD_INT 5
19531: PUSH
19532: LD_INT 3
19534: PUSH
19535: EMPTY
19536: LIST
19537: LIST
19538: LIST
19539: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
19540: LD_VAR 0 6
19544: PPUSH
19545: CALL_OW 264
19549: PUSH
19550: LD_INT 4
19552: PUSH
19553: LD_INT 43
19555: PUSH
19556: LD_INT 25
19558: PUSH
19559: EMPTY
19560: LIST
19561: LIST
19562: LIST
19563: IN
19564: IFFALSE 19585
// points := [ 40 , 15 , 5 ] ;
19566: LD_ADDR_VAR 0 9
19570: PUSH
19571: LD_INT 40
19573: PUSH
19574: LD_INT 15
19576: PUSH
19577: LD_INT 5
19579: PUSH
19580: EMPTY
19581: LIST
19582: LIST
19583: LIST
19584: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
19585: LD_VAR 0 6
19589: PPUSH
19590: CALL_OW 264
19594: PUSH
19595: LD_INT 3
19597: PUSH
19598: LD_INT 23
19600: PUSH
19601: EMPTY
19602: LIST
19603: LIST
19604: IN
19605: IFFALSE 19626
// points := [ 7 , 25 , 8 ] ;
19607: LD_ADDR_VAR 0 9
19611: PUSH
19612: LD_INT 7
19614: PUSH
19615: LD_INT 25
19617: PUSH
19618: LD_INT 8
19620: PUSH
19621: EMPTY
19622: LIST
19623: LIST
19624: LIST
19625: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
19626: LD_VAR 0 6
19630: PPUSH
19631: CALL_OW 264
19635: PUSH
19636: LD_INT 5
19638: PUSH
19639: LD_INT 27
19641: PUSH
19642: LD_INT 44
19644: PUSH
19645: EMPTY
19646: LIST
19647: LIST
19648: LIST
19649: IN
19650: IFFALSE 19671
// points := [ 14 , 50 , 16 ] ;
19652: LD_ADDR_VAR 0 9
19656: PUSH
19657: LD_INT 14
19659: PUSH
19660: LD_INT 50
19662: PUSH
19663: LD_INT 16
19665: PUSH
19666: EMPTY
19667: LIST
19668: LIST
19669: LIST
19670: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
19671: LD_VAR 0 6
19675: PPUSH
19676: CALL_OW 264
19680: PUSH
19681: LD_INT 6
19683: PUSH
19684: LD_INT 46
19686: PUSH
19687: EMPTY
19688: LIST
19689: LIST
19690: IN
19691: IFFALSE 19712
// points := [ 32 , 120 , 70 ] ;
19693: LD_ADDR_VAR 0 9
19697: PUSH
19698: LD_INT 32
19700: PUSH
19701: LD_INT 120
19703: PUSH
19704: LD_INT 70
19706: PUSH
19707: EMPTY
19708: LIST
19709: LIST
19710: LIST
19711: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
19712: LD_VAR 0 6
19716: PPUSH
19717: CALL_OW 264
19721: PUSH
19722: LD_INT 7
19724: PUSH
19725: LD_INT 28
19727: PUSH
19728: LD_INT 45
19730: PUSH
19731: EMPTY
19732: LIST
19733: LIST
19734: LIST
19735: IN
19736: IFFALSE 19757
// points := [ 35 , 20 , 45 ] ;
19738: LD_ADDR_VAR 0 9
19742: PUSH
19743: LD_INT 35
19745: PUSH
19746: LD_INT 20
19748: PUSH
19749: LD_INT 45
19751: PUSH
19752: EMPTY
19753: LIST
19754: LIST
19755: LIST
19756: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
19757: LD_VAR 0 6
19761: PPUSH
19762: CALL_OW 264
19766: PUSH
19767: LD_INT 47
19769: PUSH
19770: EMPTY
19771: LIST
19772: IN
19773: IFFALSE 19794
// points := [ 67 , 45 , 75 ] ;
19775: LD_ADDR_VAR 0 9
19779: PUSH
19780: LD_INT 67
19782: PUSH
19783: LD_INT 45
19785: PUSH
19786: LD_INT 75
19788: PUSH
19789: EMPTY
19790: LIST
19791: LIST
19792: LIST
19793: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
19794: LD_VAR 0 6
19798: PPUSH
19799: CALL_OW 264
19803: PUSH
19804: LD_INT 26
19806: PUSH
19807: EMPTY
19808: LIST
19809: IN
19810: IFFALSE 19831
// points := [ 120 , 30 , 80 ] ;
19812: LD_ADDR_VAR 0 9
19816: PUSH
19817: LD_INT 120
19819: PUSH
19820: LD_INT 30
19822: PUSH
19823: LD_INT 80
19825: PUSH
19826: EMPTY
19827: LIST
19828: LIST
19829: LIST
19830: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
19831: LD_VAR 0 6
19835: PPUSH
19836: CALL_OW 264
19840: PUSH
19841: LD_INT 22
19843: PUSH
19844: EMPTY
19845: LIST
19846: IN
19847: IFFALSE 19868
// points := [ 40 , 1 , 1 ] ;
19849: LD_ADDR_VAR 0 9
19853: PUSH
19854: LD_INT 40
19856: PUSH
19857: LD_INT 1
19859: PUSH
19860: LD_INT 1
19862: PUSH
19863: EMPTY
19864: LIST
19865: LIST
19866: LIST
19867: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
19868: LD_VAR 0 6
19872: PPUSH
19873: CALL_OW 264
19877: PUSH
19878: LD_INT 29
19880: PUSH
19881: EMPTY
19882: LIST
19883: IN
19884: IFFALSE 19905
// points := [ 70 , 200 , 400 ] ;
19886: LD_ADDR_VAR 0 9
19890: PUSH
19891: LD_INT 70
19893: PUSH
19894: LD_INT 200
19896: PUSH
19897: LD_INT 400
19899: PUSH
19900: EMPTY
19901: LIST
19902: LIST
19903: LIST
19904: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
19905: LD_VAR 0 6
19909: PPUSH
19910: CALL_OW 264
19914: PUSH
19915: LD_INT 14
19917: PUSH
19918: LD_INT 53
19920: PUSH
19921: EMPTY
19922: LIST
19923: LIST
19924: IN
19925: IFFALSE 19946
// points := [ 40 , 10 , 20 ] ;
19927: LD_ADDR_VAR 0 9
19931: PUSH
19932: LD_INT 40
19934: PUSH
19935: LD_INT 10
19937: PUSH
19938: LD_INT 20
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: LIST
19945: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
19946: LD_VAR 0 6
19950: PPUSH
19951: CALL_OW 264
19955: PUSH
19956: LD_INT 9
19958: PUSH
19959: EMPTY
19960: LIST
19961: IN
19962: IFFALSE 19983
// points := [ 5 , 70 , 20 ] ;
19964: LD_ADDR_VAR 0 9
19968: PUSH
19969: LD_INT 5
19971: PUSH
19972: LD_INT 70
19974: PUSH
19975: LD_INT 20
19977: PUSH
19978: EMPTY
19979: LIST
19980: LIST
19981: LIST
19982: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
19983: LD_VAR 0 6
19987: PPUSH
19988: CALL_OW 264
19992: PUSH
19993: LD_INT 10
19995: PUSH
19996: EMPTY
19997: LIST
19998: IN
19999: IFFALSE 20020
// points := [ 35 , 110 , 70 ] ;
20001: LD_ADDR_VAR 0 9
20005: PUSH
20006: LD_INT 35
20008: PUSH
20009: LD_INT 110
20011: PUSH
20012: LD_INT 70
20014: PUSH
20015: EMPTY
20016: LIST
20017: LIST
20018: LIST
20019: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20020: LD_VAR 0 6
20024: PPUSH
20025: CALL_OW 265
20029: PUSH
20030: LD_INT 25
20032: EQUAL
20033: IFFALSE 20054
// points := [ 80 , 65 , 100 ] ;
20035: LD_ADDR_VAR 0 9
20039: PUSH
20040: LD_INT 80
20042: PUSH
20043: LD_INT 65
20045: PUSH
20046: LD_INT 100
20048: PUSH
20049: EMPTY
20050: LIST
20051: LIST
20052: LIST
20053: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20054: LD_VAR 0 6
20058: PPUSH
20059: CALL_OW 263
20063: PUSH
20064: LD_INT 1
20066: EQUAL
20067: IFFALSE 20102
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
20069: LD_ADDR_VAR 0 10
20073: PUSH
20074: LD_VAR 0 10
20078: PUSH
20079: LD_VAR 0 6
20083: PPUSH
20084: CALL_OW 311
20088: PPUSH
20089: LD_INT 3
20091: PPUSH
20092: CALL_OW 259
20096: PUSH
20097: LD_INT 4
20099: MUL
20100: MUL
20101: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
20102: LD_VAR 0 6
20106: PPUSH
20107: CALL_OW 263
20111: PUSH
20112: LD_INT 2
20114: EQUAL
20115: IFFALSE 20166
// begin j := IsControledBy ( i ) ;
20117: LD_ADDR_VAR 0 7
20121: PUSH
20122: LD_VAR 0 6
20126: PPUSH
20127: CALL_OW 312
20131: ST_TO_ADDR
// if j then
20132: LD_VAR 0 7
20136: IFFALSE 20166
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
20138: LD_ADDR_VAR 0 10
20142: PUSH
20143: LD_VAR 0 10
20147: PUSH
20148: LD_VAR 0 7
20152: PPUSH
20153: LD_INT 3
20155: PPUSH
20156: CALL_OW 259
20160: PUSH
20161: LD_INT 3
20163: MUL
20164: MUL
20165: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
20166: LD_VAR 0 6
20170: PPUSH
20171: CALL_OW 264
20175: PUSH
20176: LD_INT 5
20178: PUSH
20179: LD_INT 6
20181: PUSH
20182: LD_INT 46
20184: PUSH
20185: LD_INT 44
20187: PUSH
20188: LD_INT 47
20190: PUSH
20191: LD_INT 45
20193: PUSH
20194: LD_INT 28
20196: PUSH
20197: LD_INT 7
20199: PUSH
20200: LD_INT 27
20202: PUSH
20203: LD_INT 29
20205: PUSH
20206: EMPTY
20207: LIST
20208: LIST
20209: LIST
20210: LIST
20211: LIST
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: LIST
20217: IN
20218: PUSH
20219: LD_VAR 0 1
20223: PPUSH
20224: LD_INT 52
20226: PPUSH
20227: CALL_OW 321
20231: PUSH
20232: LD_INT 2
20234: EQUAL
20235: AND
20236: IFFALSE 20253
// bpoints := bpoints * 1.2 ;
20238: LD_ADDR_VAR 0 10
20242: PUSH
20243: LD_VAR 0 10
20247: PUSH
20248: LD_REAL  1.20000000000000E+0000
20251: MUL
20252: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
20253: LD_VAR 0 6
20257: PPUSH
20258: CALL_OW 264
20262: PUSH
20263: LD_INT 6
20265: PUSH
20266: LD_INT 46
20268: PUSH
20269: LD_INT 47
20271: PUSH
20272: EMPTY
20273: LIST
20274: LIST
20275: LIST
20276: IN
20277: IFFALSE 20294
// bpoints := bpoints * 1.2 ;
20279: LD_ADDR_VAR 0 10
20283: PUSH
20284: LD_VAR 0 10
20288: PUSH
20289: LD_REAL  1.20000000000000E+0000
20292: MUL
20293: ST_TO_ADDR
// end ; unit_building :
20294: GO 20308
20296: LD_INT 3
20298: DOUBLE
20299: EQUAL
20300: IFTRUE 20304
20302: GO 20307
20304: POP
// ; end ;
20305: GO 20308
20307: POP
// for j = 1 to 3 do
20308: LD_ADDR_VAR 0 7
20312: PUSH
20313: DOUBLE
20314: LD_INT 1
20316: DEC
20317: ST_TO_ADDR
20318: LD_INT 3
20320: PUSH
20321: FOR_TO
20322: IFFALSE 20375
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
20324: LD_ADDR_VAR 0 5
20328: PUSH
20329: LD_VAR 0 5
20333: PPUSH
20334: LD_VAR 0 7
20338: PPUSH
20339: LD_VAR 0 5
20343: PUSH
20344: LD_VAR 0 7
20348: ARRAY
20349: PUSH
20350: LD_VAR 0 9
20354: PUSH
20355: LD_VAR 0 7
20359: ARRAY
20360: PUSH
20361: LD_VAR 0 10
20365: MUL
20366: PLUS
20367: PPUSH
20368: CALL_OW 1
20372: ST_TO_ADDR
20373: GO 20321
20375: POP
20376: POP
// end ;
20377: GO 18860
20379: POP
20380: POP
// result := Replace ( result , 4 , tmp ) ;
20381: LD_ADDR_VAR 0 5
20385: PUSH
20386: LD_VAR 0 5
20390: PPUSH
20391: LD_INT 4
20393: PPUSH
20394: LD_VAR 0 8
20398: PPUSH
20399: CALL_OW 1
20403: ST_TO_ADDR
// end ;
20404: LD_VAR 0 5
20408: RET
// export function DangerAtRange ( unit , range ) ; begin
20409: LD_INT 0
20411: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
20412: LD_ADDR_VAR 0 3
20416: PUSH
20417: LD_VAR 0 1
20421: PPUSH
20422: CALL_OW 255
20426: PPUSH
20427: LD_VAR 0 1
20431: PPUSH
20432: CALL_OW 250
20436: PPUSH
20437: LD_VAR 0 1
20441: PPUSH
20442: CALL_OW 251
20446: PPUSH
20447: LD_VAR 0 2
20451: PPUSH
20452: CALL 18712 0 4
20456: ST_TO_ADDR
// end ;
20457: LD_VAR 0 3
20461: RET
// export function DangerInArea ( side , area ) ; begin
20462: LD_INT 0
20464: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
20465: LD_ADDR_VAR 0 3
20469: PUSH
20470: LD_VAR 0 2
20474: PPUSH
20475: LD_INT 81
20477: PUSH
20478: LD_VAR 0 1
20482: PUSH
20483: EMPTY
20484: LIST
20485: LIST
20486: PPUSH
20487: CALL_OW 70
20491: ST_TO_ADDR
// end ;
20492: LD_VAR 0 3
20496: RET
// export function IsExtension ( b ) ; begin
20497: LD_INT 0
20499: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
20500: LD_ADDR_VAR 0 2
20504: PUSH
20505: LD_VAR 0 1
20509: PUSH
20510: LD_INT 23
20512: PUSH
20513: LD_INT 20
20515: PUSH
20516: LD_INT 22
20518: PUSH
20519: LD_INT 17
20521: PUSH
20522: LD_INT 24
20524: PUSH
20525: LD_INT 21
20527: PUSH
20528: LD_INT 19
20530: PUSH
20531: LD_INT 16
20533: PUSH
20534: LD_INT 25
20536: PUSH
20537: LD_INT 18
20539: PUSH
20540: EMPTY
20541: LIST
20542: LIST
20543: LIST
20544: LIST
20545: LIST
20546: LIST
20547: LIST
20548: LIST
20549: LIST
20550: LIST
20551: IN
20552: ST_TO_ADDR
// end ;
20553: LD_VAR 0 2
20557: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
20558: LD_INT 0
20560: PPUSH
20561: PPUSH
20562: PPUSH
// result := [ ] ;
20563: LD_ADDR_VAR 0 3
20567: PUSH
20568: EMPTY
20569: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
20570: LD_ADDR_VAR 0 4
20574: PUSH
20575: LD_VAR 0 2
20579: PPUSH
20580: LD_INT 21
20582: PUSH
20583: LD_INT 3
20585: PUSH
20586: EMPTY
20587: LIST
20588: LIST
20589: PPUSH
20590: CALL_OW 70
20594: ST_TO_ADDR
// if not tmp then
20595: LD_VAR 0 4
20599: NOT
20600: IFFALSE 20604
// exit ;
20602: GO 20662
// for i in tmp do
20604: LD_ADDR_VAR 0 5
20608: PUSH
20609: LD_VAR 0 4
20613: PUSH
20614: FOR_IN
20615: IFFALSE 20650
// if GetBase ( i ) <> base then
20617: LD_VAR 0 5
20621: PPUSH
20622: CALL_OW 274
20626: PUSH
20627: LD_VAR 0 1
20631: NONEQUAL
20632: IFFALSE 20648
// ComLinkToBase ( base , i ) ;
20634: LD_VAR 0 1
20638: PPUSH
20639: LD_VAR 0 5
20643: PPUSH
20644: CALL_OW 169
20648: GO 20614
20650: POP
20651: POP
// result := tmp ;
20652: LD_ADDR_VAR 0 3
20656: PUSH
20657: LD_VAR 0 4
20661: ST_TO_ADDR
// end ;
20662: LD_VAR 0 3
20666: RET
// export function ComComplete ( unit , b ) ; var i ; begin
20667: LD_INT 0
20669: PPUSH
20670: PPUSH
// if BuildingStatus ( b ) = bs_build then
20671: LD_VAR 0 2
20675: PPUSH
20676: CALL_OW 461
20680: PUSH
20681: LD_INT 1
20683: EQUAL
20684: IFFALSE 20744
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
20686: LD_VAR 0 1
20690: PPUSH
20691: LD_STRING h
20693: PUSH
20694: LD_VAR 0 2
20698: PPUSH
20699: CALL_OW 250
20703: PUSH
20704: LD_VAR 0 2
20708: PPUSH
20709: CALL_OW 251
20713: PUSH
20714: LD_VAR 0 2
20718: PUSH
20719: LD_INT 0
20721: PUSH
20722: LD_INT 0
20724: PUSH
20725: LD_INT 0
20727: PUSH
20728: EMPTY
20729: LIST
20730: LIST
20731: LIST
20732: LIST
20733: LIST
20734: LIST
20735: LIST
20736: PUSH
20737: EMPTY
20738: LIST
20739: PPUSH
20740: CALL_OW 446
// end ;
20744: LD_VAR 0 3
20748: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
20749: LD_INT 0
20751: PPUSH
20752: PPUSH
20753: PPUSH
20754: PPUSH
20755: PPUSH
20756: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
20757: LD_VAR 0 1
20761: NOT
20762: PUSH
20763: LD_VAR 0 1
20767: PPUSH
20768: CALL_OW 263
20772: PUSH
20773: LD_INT 2
20775: EQUAL
20776: NOT
20777: OR
20778: IFFALSE 20782
// exit ;
20780: GO 21098
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
20782: LD_ADDR_VAR 0 6
20786: PUSH
20787: LD_INT 22
20789: PUSH
20790: LD_VAR 0 1
20794: PPUSH
20795: CALL_OW 255
20799: PUSH
20800: EMPTY
20801: LIST
20802: LIST
20803: PUSH
20804: LD_INT 2
20806: PUSH
20807: LD_INT 30
20809: PUSH
20810: LD_INT 36
20812: PUSH
20813: EMPTY
20814: LIST
20815: LIST
20816: PUSH
20817: LD_INT 34
20819: PUSH
20820: LD_INT 31
20822: PUSH
20823: EMPTY
20824: LIST
20825: LIST
20826: PUSH
20827: EMPTY
20828: LIST
20829: LIST
20830: LIST
20831: PUSH
20832: EMPTY
20833: LIST
20834: LIST
20835: PPUSH
20836: CALL_OW 69
20840: ST_TO_ADDR
// if not tmp then
20841: LD_VAR 0 6
20845: NOT
20846: IFFALSE 20850
// exit ;
20848: GO 21098
// result := [ ] ;
20850: LD_ADDR_VAR 0 2
20854: PUSH
20855: EMPTY
20856: ST_TO_ADDR
// for i in tmp do
20857: LD_ADDR_VAR 0 3
20861: PUSH
20862: LD_VAR 0 6
20866: PUSH
20867: FOR_IN
20868: IFFALSE 20939
// begin t := UnitsInside ( i ) ;
20870: LD_ADDR_VAR 0 4
20874: PUSH
20875: LD_VAR 0 3
20879: PPUSH
20880: CALL_OW 313
20884: ST_TO_ADDR
// if t then
20885: LD_VAR 0 4
20889: IFFALSE 20937
// for j in t do
20891: LD_ADDR_VAR 0 7
20895: PUSH
20896: LD_VAR 0 4
20900: PUSH
20901: FOR_IN
20902: IFFALSE 20935
// result := Insert ( result , result + 1 , j ) ;
20904: LD_ADDR_VAR 0 2
20908: PUSH
20909: LD_VAR 0 2
20913: PPUSH
20914: LD_VAR 0 2
20918: PUSH
20919: LD_INT 1
20921: PLUS
20922: PPUSH
20923: LD_VAR 0 7
20927: PPUSH
20928: CALL_OW 2
20932: ST_TO_ADDR
20933: GO 20901
20935: POP
20936: POP
// end ;
20937: GO 20867
20939: POP
20940: POP
// if not result then
20941: LD_VAR 0 2
20945: NOT
20946: IFFALSE 20950
// exit ;
20948: GO 21098
// mech := result [ 1 ] ;
20950: LD_ADDR_VAR 0 5
20954: PUSH
20955: LD_VAR 0 2
20959: PUSH
20960: LD_INT 1
20962: ARRAY
20963: ST_TO_ADDR
// if result > 1 then
20964: LD_VAR 0 2
20968: PUSH
20969: LD_INT 1
20971: GREATER
20972: IFFALSE 21084
// for i = 2 to result do
20974: LD_ADDR_VAR 0 3
20978: PUSH
20979: DOUBLE
20980: LD_INT 2
20982: DEC
20983: ST_TO_ADDR
20984: LD_VAR 0 2
20988: PUSH
20989: FOR_TO
20990: IFFALSE 21082
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
20992: LD_ADDR_VAR 0 4
20996: PUSH
20997: LD_VAR 0 2
21001: PUSH
21002: LD_VAR 0 3
21006: ARRAY
21007: PPUSH
21008: LD_INT 3
21010: PPUSH
21011: CALL_OW 259
21015: PUSH
21016: LD_VAR 0 2
21020: PUSH
21021: LD_VAR 0 3
21025: ARRAY
21026: PPUSH
21027: CALL_OW 432
21031: MINUS
21032: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
21033: LD_VAR 0 4
21037: PUSH
21038: LD_VAR 0 5
21042: PPUSH
21043: LD_INT 3
21045: PPUSH
21046: CALL_OW 259
21050: PUSH
21051: LD_VAR 0 5
21055: PPUSH
21056: CALL_OW 432
21060: MINUS
21061: GREATEREQUAL
21062: IFFALSE 21080
// mech := result [ i ] ;
21064: LD_ADDR_VAR 0 5
21068: PUSH
21069: LD_VAR 0 2
21073: PUSH
21074: LD_VAR 0 3
21078: ARRAY
21079: ST_TO_ADDR
// end ;
21080: GO 20989
21082: POP
21083: POP
// ComLinkTo ( vehicle , mech ) ;
21084: LD_VAR 0 1
21088: PPUSH
21089: LD_VAR 0 5
21093: PPUSH
21094: CALL_OW 135
// end ;
21098: LD_VAR 0 2
21102: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
21103: LD_INT 0
21105: PPUSH
21106: PPUSH
21107: PPUSH
21108: PPUSH
21109: PPUSH
21110: PPUSH
21111: PPUSH
21112: PPUSH
21113: PPUSH
21114: PPUSH
21115: PPUSH
21116: PPUSH
21117: PPUSH
// result := [ ] ;
21118: LD_ADDR_VAR 0 7
21122: PUSH
21123: EMPTY
21124: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
21125: LD_VAR 0 1
21129: PPUSH
21130: CALL_OW 266
21134: PUSH
21135: LD_INT 0
21137: PUSH
21138: LD_INT 1
21140: PUSH
21141: EMPTY
21142: LIST
21143: LIST
21144: IN
21145: NOT
21146: IFFALSE 21150
// exit ;
21148: GO 22781
// if name then
21150: LD_VAR 0 3
21154: IFFALSE 21170
// SetBName ( base_dep , name ) ;
21156: LD_VAR 0 1
21160: PPUSH
21161: LD_VAR 0 3
21165: PPUSH
21166: CALL_OW 500
// base := GetBase ( base_dep ) ;
21170: LD_ADDR_VAR 0 15
21174: PUSH
21175: LD_VAR 0 1
21179: PPUSH
21180: CALL_OW 274
21184: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
21185: LD_ADDR_VAR 0 16
21189: PUSH
21190: LD_VAR 0 1
21194: PPUSH
21195: CALL_OW 255
21199: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
21200: LD_ADDR_VAR 0 17
21204: PUSH
21205: LD_VAR 0 1
21209: PPUSH
21210: CALL_OW 248
21214: ST_TO_ADDR
// if sources then
21215: LD_VAR 0 5
21219: IFFALSE 21266
// for i = 1 to 3 do
21221: LD_ADDR_VAR 0 8
21225: PUSH
21226: DOUBLE
21227: LD_INT 1
21229: DEC
21230: ST_TO_ADDR
21231: LD_INT 3
21233: PUSH
21234: FOR_TO
21235: IFFALSE 21264
// AddResourceType ( base , i , sources [ i ] ) ;
21237: LD_VAR 0 15
21241: PPUSH
21242: LD_VAR 0 8
21246: PPUSH
21247: LD_VAR 0 5
21251: PUSH
21252: LD_VAR 0 8
21256: ARRAY
21257: PPUSH
21258: CALL_OW 276
21262: GO 21234
21264: POP
21265: POP
// buildings := GetBaseBuildings ( base , area ) ;
21266: LD_ADDR_VAR 0 18
21270: PUSH
21271: LD_VAR 0 15
21275: PPUSH
21276: LD_VAR 0 2
21280: PPUSH
21281: CALL 20558 0 2
21285: ST_TO_ADDR
// InitHc ;
21286: CALL_OW 19
// InitUc ;
21290: CALL_OW 18
// uc_side := side ;
21294: LD_ADDR_OWVAR 20
21298: PUSH
21299: LD_VAR 0 16
21303: ST_TO_ADDR
// uc_nation := nation ;
21304: LD_ADDR_OWVAR 21
21308: PUSH
21309: LD_VAR 0 17
21313: ST_TO_ADDR
// if buildings then
21314: LD_VAR 0 18
21318: IFFALSE 22640
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
21320: LD_ADDR_VAR 0 19
21324: PUSH
21325: LD_VAR 0 18
21329: PPUSH
21330: LD_INT 2
21332: PUSH
21333: LD_INT 30
21335: PUSH
21336: LD_INT 29
21338: PUSH
21339: EMPTY
21340: LIST
21341: LIST
21342: PUSH
21343: LD_INT 30
21345: PUSH
21346: LD_INT 30
21348: PUSH
21349: EMPTY
21350: LIST
21351: LIST
21352: PUSH
21353: EMPTY
21354: LIST
21355: LIST
21356: LIST
21357: PPUSH
21358: CALL_OW 72
21362: ST_TO_ADDR
// if tmp then
21363: LD_VAR 0 19
21367: IFFALSE 21415
// for i in tmp do
21369: LD_ADDR_VAR 0 8
21373: PUSH
21374: LD_VAR 0 19
21378: PUSH
21379: FOR_IN
21380: IFFALSE 21413
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
21382: LD_VAR 0 8
21386: PPUSH
21387: CALL_OW 250
21391: PPUSH
21392: LD_VAR 0 8
21396: PPUSH
21397: CALL_OW 251
21401: PPUSH
21402: LD_VAR 0 16
21406: PPUSH
21407: CALL_OW 441
21411: GO 21379
21413: POP
21414: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
21415: LD_VAR 0 18
21419: PPUSH
21420: LD_INT 2
21422: PUSH
21423: LD_INT 30
21425: PUSH
21426: LD_INT 32
21428: PUSH
21429: EMPTY
21430: LIST
21431: LIST
21432: PUSH
21433: LD_INT 30
21435: PUSH
21436: LD_INT 33
21438: PUSH
21439: EMPTY
21440: LIST
21441: LIST
21442: PUSH
21443: EMPTY
21444: LIST
21445: LIST
21446: LIST
21447: PPUSH
21448: CALL_OW 72
21452: IFFALSE 21540
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
21454: LD_ADDR_VAR 0 8
21458: PUSH
21459: LD_VAR 0 18
21463: PPUSH
21464: LD_INT 2
21466: PUSH
21467: LD_INT 30
21469: PUSH
21470: LD_INT 32
21472: PUSH
21473: EMPTY
21474: LIST
21475: LIST
21476: PUSH
21477: LD_INT 30
21479: PUSH
21480: LD_INT 33
21482: PUSH
21483: EMPTY
21484: LIST
21485: LIST
21486: PUSH
21487: EMPTY
21488: LIST
21489: LIST
21490: LIST
21491: PPUSH
21492: CALL_OW 72
21496: PUSH
21497: FOR_IN
21498: IFFALSE 21538
// begin if not GetBWeapon ( i ) then
21500: LD_VAR 0 8
21504: PPUSH
21505: CALL_OW 269
21509: NOT
21510: IFFALSE 21536
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
21512: LD_VAR 0 8
21516: PPUSH
21517: LD_VAR 0 8
21521: PPUSH
21522: LD_VAR 0 2
21526: PPUSH
21527: CALL 22786 0 2
21531: PPUSH
21532: CALL_OW 431
// end ;
21536: GO 21497
21538: POP
21539: POP
// end ; for i = 1 to personel do
21540: LD_ADDR_VAR 0 8
21544: PUSH
21545: DOUBLE
21546: LD_INT 1
21548: DEC
21549: ST_TO_ADDR
21550: LD_VAR 0 6
21554: PUSH
21555: FOR_TO
21556: IFFALSE 22620
// begin if i > 4 then
21558: LD_VAR 0 8
21562: PUSH
21563: LD_INT 4
21565: GREATER
21566: IFFALSE 21570
// break ;
21568: GO 22620
// case i of 1 :
21570: LD_VAR 0 8
21574: PUSH
21575: LD_INT 1
21577: DOUBLE
21578: EQUAL
21579: IFTRUE 21583
21581: GO 21663
21583: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
21584: LD_ADDR_VAR 0 12
21588: PUSH
21589: LD_VAR 0 18
21593: PPUSH
21594: LD_INT 22
21596: PUSH
21597: LD_VAR 0 16
21601: PUSH
21602: EMPTY
21603: LIST
21604: LIST
21605: PUSH
21606: LD_INT 58
21608: PUSH
21609: EMPTY
21610: LIST
21611: PUSH
21612: LD_INT 2
21614: PUSH
21615: LD_INT 30
21617: PUSH
21618: LD_INT 32
21620: PUSH
21621: EMPTY
21622: LIST
21623: LIST
21624: PUSH
21625: LD_INT 30
21627: PUSH
21628: LD_INT 4
21630: PUSH
21631: EMPTY
21632: LIST
21633: LIST
21634: PUSH
21635: LD_INT 30
21637: PUSH
21638: LD_INT 5
21640: PUSH
21641: EMPTY
21642: LIST
21643: LIST
21644: PUSH
21645: EMPTY
21646: LIST
21647: LIST
21648: LIST
21649: LIST
21650: PUSH
21651: EMPTY
21652: LIST
21653: LIST
21654: LIST
21655: PPUSH
21656: CALL_OW 72
21660: ST_TO_ADDR
21661: GO 21885
21663: LD_INT 2
21665: DOUBLE
21666: EQUAL
21667: IFTRUE 21671
21669: GO 21733
21671: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
21672: LD_ADDR_VAR 0 12
21676: PUSH
21677: LD_VAR 0 18
21681: PPUSH
21682: LD_INT 22
21684: PUSH
21685: LD_VAR 0 16
21689: PUSH
21690: EMPTY
21691: LIST
21692: LIST
21693: PUSH
21694: LD_INT 2
21696: PUSH
21697: LD_INT 30
21699: PUSH
21700: LD_INT 0
21702: PUSH
21703: EMPTY
21704: LIST
21705: LIST
21706: PUSH
21707: LD_INT 30
21709: PUSH
21710: LD_INT 1
21712: PUSH
21713: EMPTY
21714: LIST
21715: LIST
21716: PUSH
21717: EMPTY
21718: LIST
21719: LIST
21720: LIST
21721: PUSH
21722: EMPTY
21723: LIST
21724: LIST
21725: PPUSH
21726: CALL_OW 72
21730: ST_TO_ADDR
21731: GO 21885
21733: LD_INT 3
21735: DOUBLE
21736: EQUAL
21737: IFTRUE 21741
21739: GO 21803
21741: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
21742: LD_ADDR_VAR 0 12
21746: PUSH
21747: LD_VAR 0 18
21751: PPUSH
21752: LD_INT 22
21754: PUSH
21755: LD_VAR 0 16
21759: PUSH
21760: EMPTY
21761: LIST
21762: LIST
21763: PUSH
21764: LD_INT 2
21766: PUSH
21767: LD_INT 30
21769: PUSH
21770: LD_INT 2
21772: PUSH
21773: EMPTY
21774: LIST
21775: LIST
21776: PUSH
21777: LD_INT 30
21779: PUSH
21780: LD_INT 3
21782: PUSH
21783: EMPTY
21784: LIST
21785: LIST
21786: PUSH
21787: EMPTY
21788: LIST
21789: LIST
21790: LIST
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: PPUSH
21796: CALL_OW 72
21800: ST_TO_ADDR
21801: GO 21885
21803: LD_INT 4
21805: DOUBLE
21806: EQUAL
21807: IFTRUE 21811
21809: GO 21884
21811: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
21812: LD_ADDR_VAR 0 12
21816: PUSH
21817: LD_VAR 0 18
21821: PPUSH
21822: LD_INT 22
21824: PUSH
21825: LD_VAR 0 16
21829: PUSH
21830: EMPTY
21831: LIST
21832: LIST
21833: PUSH
21834: LD_INT 2
21836: PUSH
21837: LD_INT 30
21839: PUSH
21840: LD_INT 6
21842: PUSH
21843: EMPTY
21844: LIST
21845: LIST
21846: PUSH
21847: LD_INT 30
21849: PUSH
21850: LD_INT 7
21852: PUSH
21853: EMPTY
21854: LIST
21855: LIST
21856: PUSH
21857: LD_INT 30
21859: PUSH
21860: LD_INT 8
21862: PUSH
21863: EMPTY
21864: LIST
21865: LIST
21866: PUSH
21867: EMPTY
21868: LIST
21869: LIST
21870: LIST
21871: LIST
21872: PUSH
21873: EMPTY
21874: LIST
21875: LIST
21876: PPUSH
21877: CALL_OW 72
21881: ST_TO_ADDR
21882: GO 21885
21884: POP
// if i = 1 then
21885: LD_VAR 0 8
21889: PUSH
21890: LD_INT 1
21892: EQUAL
21893: IFFALSE 22004
// begin tmp := [ ] ;
21895: LD_ADDR_VAR 0 19
21899: PUSH
21900: EMPTY
21901: ST_TO_ADDR
// for j in f do
21902: LD_ADDR_VAR 0 9
21906: PUSH
21907: LD_VAR 0 12
21911: PUSH
21912: FOR_IN
21913: IFFALSE 21986
// if GetBType ( j ) = b_bunker then
21915: LD_VAR 0 9
21919: PPUSH
21920: CALL_OW 266
21924: PUSH
21925: LD_INT 32
21927: EQUAL
21928: IFFALSE 21955
// tmp := Insert ( tmp , 1 , j ) else
21930: LD_ADDR_VAR 0 19
21934: PUSH
21935: LD_VAR 0 19
21939: PPUSH
21940: LD_INT 1
21942: PPUSH
21943: LD_VAR 0 9
21947: PPUSH
21948: CALL_OW 2
21952: ST_TO_ADDR
21953: GO 21984
// tmp := Insert ( tmp , tmp + 1 , j ) ;
21955: LD_ADDR_VAR 0 19
21959: PUSH
21960: LD_VAR 0 19
21964: PPUSH
21965: LD_VAR 0 19
21969: PUSH
21970: LD_INT 1
21972: PLUS
21973: PPUSH
21974: LD_VAR 0 9
21978: PPUSH
21979: CALL_OW 2
21983: ST_TO_ADDR
21984: GO 21912
21986: POP
21987: POP
// if tmp then
21988: LD_VAR 0 19
21992: IFFALSE 22004
// f := tmp ;
21994: LD_ADDR_VAR 0 12
21998: PUSH
21999: LD_VAR 0 19
22003: ST_TO_ADDR
// end ; x := personel [ i ] ;
22004: LD_ADDR_VAR 0 13
22008: PUSH
22009: LD_VAR 0 6
22013: PUSH
22014: LD_VAR 0 8
22018: ARRAY
22019: ST_TO_ADDR
// if x = - 1 then
22020: LD_VAR 0 13
22024: PUSH
22025: LD_INT 1
22027: NEG
22028: EQUAL
22029: IFFALSE 22238
// begin for j in f do
22031: LD_ADDR_VAR 0 9
22035: PUSH
22036: LD_VAR 0 12
22040: PUSH
22041: FOR_IN
22042: IFFALSE 22234
// repeat InitHc ;
22044: CALL_OW 19
// if GetBType ( j ) = b_barracks then
22048: LD_VAR 0 9
22052: PPUSH
22053: CALL_OW 266
22057: PUSH
22058: LD_INT 5
22060: EQUAL
22061: IFFALSE 22131
// begin if UnitsInside ( j ) < 3 then
22063: LD_VAR 0 9
22067: PPUSH
22068: CALL_OW 313
22072: PUSH
22073: LD_INT 3
22075: LESS
22076: IFFALSE 22112
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22078: LD_INT 0
22080: PPUSH
22081: LD_INT 5
22083: PUSH
22084: LD_INT 8
22086: PUSH
22087: LD_INT 9
22089: PUSH
22090: EMPTY
22091: LIST
22092: LIST
22093: LIST
22094: PUSH
22095: LD_VAR 0 17
22099: ARRAY
22100: PPUSH
22101: LD_VAR 0 4
22105: PPUSH
22106: CALL_OW 380
22110: GO 22129
// PrepareHuman ( false , i , skill ) ;
22112: LD_INT 0
22114: PPUSH
22115: LD_VAR 0 8
22119: PPUSH
22120: LD_VAR 0 4
22124: PPUSH
22125: CALL_OW 380
// end else
22129: GO 22148
// PrepareHuman ( false , i , skill ) ;
22131: LD_INT 0
22133: PPUSH
22134: LD_VAR 0 8
22138: PPUSH
22139: LD_VAR 0 4
22143: PPUSH
22144: CALL_OW 380
// un := CreateHuman ;
22148: LD_ADDR_VAR 0 14
22152: PUSH
22153: CALL_OW 44
22157: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22158: LD_ADDR_VAR 0 7
22162: PUSH
22163: LD_VAR 0 7
22167: PPUSH
22168: LD_INT 1
22170: PPUSH
22171: LD_VAR 0 14
22175: PPUSH
22176: CALL_OW 2
22180: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
22181: LD_VAR 0 14
22185: PPUSH
22186: LD_VAR 0 9
22190: PPUSH
22191: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
22195: LD_VAR 0 9
22199: PPUSH
22200: CALL_OW 313
22204: PUSH
22205: LD_INT 6
22207: EQUAL
22208: PUSH
22209: LD_VAR 0 9
22213: PPUSH
22214: CALL_OW 266
22218: PUSH
22219: LD_INT 32
22221: PUSH
22222: LD_INT 31
22224: PUSH
22225: EMPTY
22226: LIST
22227: LIST
22228: IN
22229: OR
22230: IFFALSE 22044
22232: GO 22041
22234: POP
22235: POP
// end else
22236: GO 22618
// for j = 1 to x do
22238: LD_ADDR_VAR 0 9
22242: PUSH
22243: DOUBLE
22244: LD_INT 1
22246: DEC
22247: ST_TO_ADDR
22248: LD_VAR 0 13
22252: PUSH
22253: FOR_TO
22254: IFFALSE 22616
// begin InitHc ;
22256: CALL_OW 19
// if not f then
22260: LD_VAR 0 12
22264: NOT
22265: IFFALSE 22354
// begin PrepareHuman ( false , i , skill ) ;
22267: LD_INT 0
22269: PPUSH
22270: LD_VAR 0 8
22274: PPUSH
22275: LD_VAR 0 4
22279: PPUSH
22280: CALL_OW 380
// un := CreateHuman ;
22284: LD_ADDR_VAR 0 14
22288: PUSH
22289: CALL_OW 44
22293: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22294: LD_ADDR_VAR 0 7
22298: PUSH
22299: LD_VAR 0 7
22303: PPUSH
22304: LD_INT 1
22306: PPUSH
22307: LD_VAR 0 14
22311: PPUSH
22312: CALL_OW 2
22316: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
22317: LD_VAR 0 14
22321: PPUSH
22322: LD_VAR 0 1
22326: PPUSH
22327: CALL_OW 250
22331: PPUSH
22332: LD_VAR 0 1
22336: PPUSH
22337: CALL_OW 251
22341: PPUSH
22342: LD_INT 10
22344: PPUSH
22345: LD_INT 0
22347: PPUSH
22348: CALL_OW 50
// continue ;
22352: GO 22253
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
22354: LD_VAR 0 12
22358: PUSH
22359: LD_INT 1
22361: ARRAY
22362: PPUSH
22363: CALL_OW 313
22367: PUSH
22368: LD_VAR 0 12
22372: PUSH
22373: LD_INT 1
22375: ARRAY
22376: PPUSH
22377: CALL_OW 266
22381: PUSH
22382: LD_INT 32
22384: PUSH
22385: LD_INT 31
22387: PUSH
22388: EMPTY
22389: LIST
22390: LIST
22391: IN
22392: AND
22393: PUSH
22394: LD_VAR 0 12
22398: PUSH
22399: LD_INT 1
22401: ARRAY
22402: PPUSH
22403: CALL_OW 313
22407: PUSH
22408: LD_INT 6
22410: EQUAL
22411: OR
22412: IFFALSE 22432
// f := Delete ( f , 1 ) ;
22414: LD_ADDR_VAR 0 12
22418: PUSH
22419: LD_VAR 0 12
22423: PPUSH
22424: LD_INT 1
22426: PPUSH
22427: CALL_OW 3
22431: ST_TO_ADDR
// if not f then
22432: LD_VAR 0 12
22436: NOT
22437: IFFALSE 22455
// begin x := x + 2 ;
22439: LD_ADDR_VAR 0 13
22443: PUSH
22444: LD_VAR 0 13
22448: PUSH
22449: LD_INT 2
22451: PLUS
22452: ST_TO_ADDR
// continue ;
22453: GO 22253
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
22455: LD_VAR 0 12
22459: PUSH
22460: LD_INT 1
22462: ARRAY
22463: PPUSH
22464: CALL_OW 266
22468: PUSH
22469: LD_INT 5
22471: EQUAL
22472: IFFALSE 22546
// begin if UnitsInside ( f [ 1 ] ) < 3 then
22474: LD_VAR 0 12
22478: PUSH
22479: LD_INT 1
22481: ARRAY
22482: PPUSH
22483: CALL_OW 313
22487: PUSH
22488: LD_INT 3
22490: LESS
22491: IFFALSE 22527
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22493: LD_INT 0
22495: PPUSH
22496: LD_INT 5
22498: PUSH
22499: LD_INT 8
22501: PUSH
22502: LD_INT 9
22504: PUSH
22505: EMPTY
22506: LIST
22507: LIST
22508: LIST
22509: PUSH
22510: LD_VAR 0 17
22514: ARRAY
22515: PPUSH
22516: LD_VAR 0 4
22520: PPUSH
22521: CALL_OW 380
22525: GO 22544
// PrepareHuman ( false , i , skill ) ;
22527: LD_INT 0
22529: PPUSH
22530: LD_VAR 0 8
22534: PPUSH
22535: LD_VAR 0 4
22539: PPUSH
22540: CALL_OW 380
// end else
22544: GO 22563
// PrepareHuman ( false , i , skill ) ;
22546: LD_INT 0
22548: PPUSH
22549: LD_VAR 0 8
22553: PPUSH
22554: LD_VAR 0 4
22558: PPUSH
22559: CALL_OW 380
// un := CreateHuman ;
22563: LD_ADDR_VAR 0 14
22567: PUSH
22568: CALL_OW 44
22572: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22573: LD_ADDR_VAR 0 7
22577: PUSH
22578: LD_VAR 0 7
22582: PPUSH
22583: LD_INT 1
22585: PPUSH
22586: LD_VAR 0 14
22590: PPUSH
22591: CALL_OW 2
22595: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
22596: LD_VAR 0 14
22600: PPUSH
22601: LD_VAR 0 12
22605: PUSH
22606: LD_INT 1
22608: ARRAY
22609: PPUSH
22610: CALL_OW 52
// end ;
22614: GO 22253
22616: POP
22617: POP
// end ;
22618: GO 21555
22620: POP
22621: POP
// result := result ^ buildings ;
22622: LD_ADDR_VAR 0 7
22626: PUSH
22627: LD_VAR 0 7
22631: PUSH
22632: LD_VAR 0 18
22636: ADD
22637: ST_TO_ADDR
// end else
22638: GO 22781
// begin for i = 1 to personel do
22640: LD_ADDR_VAR 0 8
22644: PUSH
22645: DOUBLE
22646: LD_INT 1
22648: DEC
22649: ST_TO_ADDR
22650: LD_VAR 0 6
22654: PUSH
22655: FOR_TO
22656: IFFALSE 22779
// begin if i > 4 then
22658: LD_VAR 0 8
22662: PUSH
22663: LD_INT 4
22665: GREATER
22666: IFFALSE 22670
// break ;
22668: GO 22779
// x := personel [ i ] ;
22670: LD_ADDR_VAR 0 13
22674: PUSH
22675: LD_VAR 0 6
22679: PUSH
22680: LD_VAR 0 8
22684: ARRAY
22685: ST_TO_ADDR
// if x = - 1 then
22686: LD_VAR 0 13
22690: PUSH
22691: LD_INT 1
22693: NEG
22694: EQUAL
22695: IFFALSE 22699
// continue ;
22697: GO 22655
// PrepareHuman ( false , i , skill ) ;
22699: LD_INT 0
22701: PPUSH
22702: LD_VAR 0 8
22706: PPUSH
22707: LD_VAR 0 4
22711: PPUSH
22712: CALL_OW 380
// un := CreateHuman ;
22716: LD_ADDR_VAR 0 14
22720: PUSH
22721: CALL_OW 44
22725: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
22726: LD_VAR 0 14
22730: PPUSH
22731: LD_VAR 0 1
22735: PPUSH
22736: CALL_OW 250
22740: PPUSH
22741: LD_VAR 0 1
22745: PPUSH
22746: CALL_OW 251
22750: PPUSH
22751: LD_INT 10
22753: PPUSH
22754: LD_INT 0
22756: PPUSH
22757: CALL_OW 50
// result := result ^ un ;
22761: LD_ADDR_VAR 0 7
22765: PUSH
22766: LD_VAR 0 7
22770: PUSH
22771: LD_VAR 0 14
22775: ADD
22776: ST_TO_ADDR
// end ;
22777: GO 22655
22779: POP
22780: POP
// end ; end ;
22781: LD_VAR 0 7
22785: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
22786: LD_INT 0
22788: PPUSH
22789: PPUSH
22790: PPUSH
22791: PPUSH
22792: PPUSH
22793: PPUSH
22794: PPUSH
22795: PPUSH
22796: PPUSH
22797: PPUSH
22798: PPUSH
22799: PPUSH
22800: PPUSH
22801: PPUSH
22802: PPUSH
22803: PPUSH
// result := false ;
22804: LD_ADDR_VAR 0 3
22808: PUSH
22809: LD_INT 0
22811: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
22812: LD_VAR 0 1
22816: NOT
22817: PUSH
22818: LD_VAR 0 1
22822: PPUSH
22823: CALL_OW 266
22827: PUSH
22828: LD_INT 32
22830: PUSH
22831: LD_INT 33
22833: PUSH
22834: EMPTY
22835: LIST
22836: LIST
22837: IN
22838: NOT
22839: OR
22840: IFFALSE 22844
// exit ;
22842: GO 23980
// nat := GetNation ( tower ) ;
22844: LD_ADDR_VAR 0 12
22848: PUSH
22849: LD_VAR 0 1
22853: PPUSH
22854: CALL_OW 248
22858: ST_TO_ADDR
// side := GetSide ( tower ) ;
22859: LD_ADDR_VAR 0 16
22863: PUSH
22864: LD_VAR 0 1
22868: PPUSH
22869: CALL_OW 255
22873: ST_TO_ADDR
// x := GetX ( tower ) ;
22874: LD_ADDR_VAR 0 10
22878: PUSH
22879: LD_VAR 0 1
22883: PPUSH
22884: CALL_OW 250
22888: ST_TO_ADDR
// y := GetY ( tower ) ;
22889: LD_ADDR_VAR 0 11
22893: PUSH
22894: LD_VAR 0 1
22898: PPUSH
22899: CALL_OW 251
22903: ST_TO_ADDR
// if not x or not y then
22904: LD_VAR 0 10
22908: NOT
22909: PUSH
22910: LD_VAR 0 11
22914: NOT
22915: OR
22916: IFFALSE 22920
// exit ;
22918: GO 23980
// weapon := 0 ;
22920: LD_ADDR_VAR 0 18
22924: PUSH
22925: LD_INT 0
22927: ST_TO_ADDR
// fac_list := [ ] ;
22928: LD_ADDR_VAR 0 17
22932: PUSH
22933: EMPTY
22934: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
22935: LD_ADDR_VAR 0 6
22939: PUSH
22940: LD_VAR 0 1
22944: PPUSH
22945: CALL_OW 274
22949: PPUSH
22950: LD_VAR 0 2
22954: PPUSH
22955: CALL 20558 0 2
22959: PPUSH
22960: LD_INT 30
22962: PUSH
22963: LD_INT 3
22965: PUSH
22966: EMPTY
22967: LIST
22968: LIST
22969: PPUSH
22970: CALL_OW 72
22974: ST_TO_ADDR
// if not factories then
22975: LD_VAR 0 6
22979: NOT
22980: IFFALSE 22984
// exit ;
22982: GO 23980
// for i in factories do
22984: LD_ADDR_VAR 0 8
22988: PUSH
22989: LD_VAR 0 6
22993: PUSH
22994: FOR_IN
22995: IFFALSE 23020
// fac_list := fac_list union AvailableWeaponList ( i ) ;
22997: LD_ADDR_VAR 0 17
23001: PUSH
23002: LD_VAR 0 17
23006: PUSH
23007: LD_VAR 0 8
23011: PPUSH
23012: CALL_OW 478
23016: UNION
23017: ST_TO_ADDR
23018: GO 22994
23020: POP
23021: POP
// if not fac_list then
23022: LD_VAR 0 17
23026: NOT
23027: IFFALSE 23031
// exit ;
23029: GO 23980
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
23031: LD_ADDR_VAR 0 5
23035: PUSH
23036: LD_INT 4
23038: PUSH
23039: LD_INT 5
23041: PUSH
23042: LD_INT 9
23044: PUSH
23045: LD_INT 10
23047: PUSH
23048: LD_INT 6
23050: PUSH
23051: LD_INT 7
23053: PUSH
23054: LD_INT 11
23056: PUSH
23057: EMPTY
23058: LIST
23059: LIST
23060: LIST
23061: LIST
23062: LIST
23063: LIST
23064: LIST
23065: PUSH
23066: LD_INT 27
23068: PUSH
23069: LD_INT 28
23071: PUSH
23072: LD_INT 26
23074: PUSH
23075: LD_INT 30
23077: PUSH
23078: EMPTY
23079: LIST
23080: LIST
23081: LIST
23082: LIST
23083: PUSH
23084: LD_INT 43
23086: PUSH
23087: LD_INT 44
23089: PUSH
23090: LD_INT 46
23092: PUSH
23093: LD_INT 45
23095: PUSH
23096: LD_INT 47
23098: PUSH
23099: LD_INT 49
23101: PUSH
23102: EMPTY
23103: LIST
23104: LIST
23105: LIST
23106: LIST
23107: LIST
23108: LIST
23109: PUSH
23110: EMPTY
23111: LIST
23112: LIST
23113: LIST
23114: PUSH
23115: LD_VAR 0 12
23119: ARRAY
23120: ST_TO_ADDR
// for i in list do
23121: LD_ADDR_VAR 0 8
23125: PUSH
23126: LD_VAR 0 5
23130: PUSH
23131: FOR_IN
23132: IFFALSE 23165
// if not i in fac_list then
23134: LD_VAR 0 8
23138: PUSH
23139: LD_VAR 0 17
23143: IN
23144: NOT
23145: IFFALSE 23163
// list := list diff i ;
23147: LD_ADDR_VAR 0 5
23151: PUSH
23152: LD_VAR 0 5
23156: PUSH
23157: LD_VAR 0 8
23161: DIFF
23162: ST_TO_ADDR
23163: GO 23131
23165: POP
23166: POP
// if not list then
23167: LD_VAR 0 5
23171: NOT
23172: IFFALSE 23176
// exit ;
23174: GO 23980
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
23176: LD_VAR 0 12
23180: PUSH
23181: LD_INT 3
23183: EQUAL
23184: PUSH
23185: LD_INT 49
23187: PUSH
23188: LD_VAR 0 5
23192: IN
23193: AND
23194: PUSH
23195: LD_INT 31
23197: PPUSH
23198: LD_VAR 0 16
23202: PPUSH
23203: CALL_OW 321
23207: PUSH
23208: LD_INT 2
23210: EQUAL
23211: AND
23212: IFFALSE 23272
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
23214: LD_INT 22
23216: PUSH
23217: LD_VAR 0 16
23221: PUSH
23222: EMPTY
23223: LIST
23224: LIST
23225: PUSH
23226: LD_INT 35
23228: PUSH
23229: LD_INT 49
23231: PUSH
23232: EMPTY
23233: LIST
23234: LIST
23235: PUSH
23236: LD_INT 91
23238: PUSH
23239: LD_VAR 0 1
23243: PUSH
23244: LD_INT 10
23246: PUSH
23247: EMPTY
23248: LIST
23249: LIST
23250: LIST
23251: PUSH
23252: EMPTY
23253: LIST
23254: LIST
23255: LIST
23256: PPUSH
23257: CALL_OW 69
23261: NOT
23262: IFFALSE 23272
// weapon := ru_time_lapser ;
23264: LD_ADDR_VAR 0 18
23268: PUSH
23269: LD_INT 49
23271: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
23272: LD_VAR 0 12
23276: PUSH
23277: LD_INT 1
23279: PUSH
23280: LD_INT 2
23282: PUSH
23283: EMPTY
23284: LIST
23285: LIST
23286: IN
23287: PUSH
23288: LD_INT 11
23290: PUSH
23291: LD_VAR 0 5
23295: IN
23296: PUSH
23297: LD_INT 30
23299: PUSH
23300: LD_VAR 0 5
23304: IN
23305: OR
23306: AND
23307: PUSH
23308: LD_INT 6
23310: PPUSH
23311: LD_VAR 0 16
23315: PPUSH
23316: CALL_OW 321
23320: PUSH
23321: LD_INT 2
23323: EQUAL
23324: AND
23325: IFFALSE 23490
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
23327: LD_INT 22
23329: PUSH
23330: LD_VAR 0 16
23334: PUSH
23335: EMPTY
23336: LIST
23337: LIST
23338: PUSH
23339: LD_INT 2
23341: PUSH
23342: LD_INT 35
23344: PUSH
23345: LD_INT 11
23347: PUSH
23348: EMPTY
23349: LIST
23350: LIST
23351: PUSH
23352: LD_INT 35
23354: PUSH
23355: LD_INT 30
23357: PUSH
23358: EMPTY
23359: LIST
23360: LIST
23361: PUSH
23362: EMPTY
23363: LIST
23364: LIST
23365: LIST
23366: PUSH
23367: LD_INT 91
23369: PUSH
23370: LD_VAR 0 1
23374: PUSH
23375: LD_INT 18
23377: PUSH
23378: EMPTY
23379: LIST
23380: LIST
23381: LIST
23382: PUSH
23383: EMPTY
23384: LIST
23385: LIST
23386: LIST
23387: PPUSH
23388: CALL_OW 69
23392: NOT
23393: PUSH
23394: LD_INT 22
23396: PUSH
23397: LD_VAR 0 16
23401: PUSH
23402: EMPTY
23403: LIST
23404: LIST
23405: PUSH
23406: LD_INT 2
23408: PUSH
23409: LD_INT 30
23411: PUSH
23412: LD_INT 32
23414: PUSH
23415: EMPTY
23416: LIST
23417: LIST
23418: PUSH
23419: LD_INT 30
23421: PUSH
23422: LD_INT 33
23424: PUSH
23425: EMPTY
23426: LIST
23427: LIST
23428: PUSH
23429: EMPTY
23430: LIST
23431: LIST
23432: LIST
23433: PUSH
23434: LD_INT 91
23436: PUSH
23437: LD_VAR 0 1
23441: PUSH
23442: LD_INT 12
23444: PUSH
23445: EMPTY
23446: LIST
23447: LIST
23448: LIST
23449: PUSH
23450: EMPTY
23451: LIST
23452: LIST
23453: LIST
23454: PUSH
23455: EMPTY
23456: LIST
23457: PPUSH
23458: CALL_OW 69
23462: PUSH
23463: LD_INT 2
23465: GREATER
23466: AND
23467: IFFALSE 23490
// weapon := [ us_radar , ar_radar ] [ nat ] ;
23469: LD_ADDR_VAR 0 18
23473: PUSH
23474: LD_INT 11
23476: PUSH
23477: LD_INT 30
23479: PUSH
23480: EMPTY
23481: LIST
23482: LIST
23483: PUSH
23484: LD_VAR 0 12
23488: ARRAY
23489: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
23490: LD_VAR 0 18
23494: NOT
23495: PUSH
23496: LD_INT 40
23498: PPUSH
23499: LD_VAR 0 16
23503: PPUSH
23504: CALL_OW 321
23508: PUSH
23509: LD_INT 2
23511: EQUAL
23512: AND
23513: PUSH
23514: LD_INT 7
23516: PUSH
23517: LD_VAR 0 5
23521: IN
23522: PUSH
23523: LD_INT 28
23525: PUSH
23526: LD_VAR 0 5
23530: IN
23531: OR
23532: PUSH
23533: LD_INT 45
23535: PUSH
23536: LD_VAR 0 5
23540: IN
23541: OR
23542: AND
23543: IFFALSE 23797
// begin hex := GetHexInfo ( x , y ) ;
23545: LD_ADDR_VAR 0 4
23549: PUSH
23550: LD_VAR 0 10
23554: PPUSH
23555: LD_VAR 0 11
23559: PPUSH
23560: CALL_OW 546
23564: ST_TO_ADDR
// if hex [ 1 ] then
23565: LD_VAR 0 4
23569: PUSH
23570: LD_INT 1
23572: ARRAY
23573: IFFALSE 23577
// exit ;
23575: GO 23980
// height := hex [ 2 ] ;
23577: LD_ADDR_VAR 0 15
23581: PUSH
23582: LD_VAR 0 4
23586: PUSH
23587: LD_INT 2
23589: ARRAY
23590: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
23591: LD_ADDR_VAR 0 14
23595: PUSH
23596: LD_INT 0
23598: PUSH
23599: LD_INT 2
23601: PUSH
23602: LD_INT 3
23604: PUSH
23605: LD_INT 5
23607: PUSH
23608: EMPTY
23609: LIST
23610: LIST
23611: LIST
23612: LIST
23613: ST_TO_ADDR
// for i in tmp do
23614: LD_ADDR_VAR 0 8
23618: PUSH
23619: LD_VAR 0 14
23623: PUSH
23624: FOR_IN
23625: IFFALSE 23795
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
23627: LD_ADDR_VAR 0 9
23631: PUSH
23632: LD_VAR 0 10
23636: PPUSH
23637: LD_VAR 0 8
23641: PPUSH
23642: LD_INT 5
23644: PPUSH
23645: CALL_OW 272
23649: PUSH
23650: LD_VAR 0 11
23654: PPUSH
23655: LD_VAR 0 8
23659: PPUSH
23660: LD_INT 5
23662: PPUSH
23663: CALL_OW 273
23667: PUSH
23668: EMPTY
23669: LIST
23670: LIST
23671: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
23672: LD_VAR 0 9
23676: PUSH
23677: LD_INT 1
23679: ARRAY
23680: PPUSH
23681: LD_VAR 0 9
23685: PUSH
23686: LD_INT 2
23688: ARRAY
23689: PPUSH
23690: CALL_OW 488
23694: IFFALSE 23793
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
23696: LD_ADDR_VAR 0 4
23700: PUSH
23701: LD_VAR 0 9
23705: PUSH
23706: LD_INT 1
23708: ARRAY
23709: PPUSH
23710: LD_VAR 0 9
23714: PUSH
23715: LD_INT 2
23717: ARRAY
23718: PPUSH
23719: CALL_OW 546
23723: ST_TO_ADDR
// if hex [ 1 ] then
23724: LD_VAR 0 4
23728: PUSH
23729: LD_INT 1
23731: ARRAY
23732: IFFALSE 23736
// continue ;
23734: GO 23624
// h := hex [ 2 ] ;
23736: LD_ADDR_VAR 0 13
23740: PUSH
23741: LD_VAR 0 4
23745: PUSH
23746: LD_INT 2
23748: ARRAY
23749: ST_TO_ADDR
// if h + 7 < height then
23750: LD_VAR 0 13
23754: PUSH
23755: LD_INT 7
23757: PLUS
23758: PUSH
23759: LD_VAR 0 15
23763: LESS
23764: IFFALSE 23793
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
23766: LD_ADDR_VAR 0 18
23770: PUSH
23771: LD_INT 7
23773: PUSH
23774: LD_INT 28
23776: PUSH
23777: LD_INT 45
23779: PUSH
23780: EMPTY
23781: LIST
23782: LIST
23783: LIST
23784: PUSH
23785: LD_VAR 0 12
23789: ARRAY
23790: ST_TO_ADDR
// break ;
23791: GO 23795
// end ; end ; end ;
23793: GO 23624
23795: POP
23796: POP
// end ; if not weapon then
23797: LD_VAR 0 18
23801: NOT
23802: IFFALSE 23862
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
23804: LD_ADDR_VAR 0 5
23808: PUSH
23809: LD_VAR 0 5
23813: PUSH
23814: LD_INT 11
23816: PUSH
23817: LD_INT 30
23819: PUSH
23820: LD_INT 49
23822: PUSH
23823: EMPTY
23824: LIST
23825: LIST
23826: LIST
23827: DIFF
23828: ST_TO_ADDR
// if not list then
23829: LD_VAR 0 5
23833: NOT
23834: IFFALSE 23838
// exit ;
23836: GO 23980
// weapon := list [ rand ( 1 , list ) ] ;
23838: LD_ADDR_VAR 0 18
23842: PUSH
23843: LD_VAR 0 5
23847: PUSH
23848: LD_INT 1
23850: PPUSH
23851: LD_VAR 0 5
23855: PPUSH
23856: CALL_OW 12
23860: ARRAY
23861: ST_TO_ADDR
// end ; if weapon then
23862: LD_VAR 0 18
23866: IFFALSE 23980
// begin tmp := CostOfWeapon ( weapon ) ;
23868: LD_ADDR_VAR 0 14
23872: PUSH
23873: LD_VAR 0 18
23877: PPUSH
23878: CALL_OW 451
23882: ST_TO_ADDR
// j := GetBase ( tower ) ;
23883: LD_ADDR_VAR 0 9
23887: PUSH
23888: LD_VAR 0 1
23892: PPUSH
23893: CALL_OW 274
23897: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
23898: LD_VAR 0 9
23902: PPUSH
23903: LD_INT 1
23905: PPUSH
23906: CALL_OW 275
23910: PUSH
23911: LD_VAR 0 14
23915: PUSH
23916: LD_INT 1
23918: ARRAY
23919: GREATEREQUAL
23920: PUSH
23921: LD_VAR 0 9
23925: PPUSH
23926: LD_INT 2
23928: PPUSH
23929: CALL_OW 275
23933: PUSH
23934: LD_VAR 0 14
23938: PUSH
23939: LD_INT 2
23941: ARRAY
23942: GREATEREQUAL
23943: AND
23944: PUSH
23945: LD_VAR 0 9
23949: PPUSH
23950: LD_INT 3
23952: PPUSH
23953: CALL_OW 275
23957: PUSH
23958: LD_VAR 0 14
23962: PUSH
23963: LD_INT 3
23965: ARRAY
23966: GREATEREQUAL
23967: AND
23968: IFFALSE 23980
// result := weapon ;
23970: LD_ADDR_VAR 0 3
23974: PUSH
23975: LD_VAR 0 18
23979: ST_TO_ADDR
// end ; end ;
23980: LD_VAR 0 3
23984: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
23985: LD_INT 0
23987: PPUSH
23988: PPUSH
// result := true ;
23989: LD_ADDR_VAR 0 3
23993: PUSH
23994: LD_INT 1
23996: ST_TO_ADDR
// if array1 = array2 then
23997: LD_VAR 0 1
24001: PUSH
24002: LD_VAR 0 2
24006: EQUAL
24007: IFFALSE 24067
// begin for i = 1 to array1 do
24009: LD_ADDR_VAR 0 4
24013: PUSH
24014: DOUBLE
24015: LD_INT 1
24017: DEC
24018: ST_TO_ADDR
24019: LD_VAR 0 1
24023: PUSH
24024: FOR_TO
24025: IFFALSE 24063
// if array1 [ i ] <> array2 [ i ] then
24027: LD_VAR 0 1
24031: PUSH
24032: LD_VAR 0 4
24036: ARRAY
24037: PUSH
24038: LD_VAR 0 2
24042: PUSH
24043: LD_VAR 0 4
24047: ARRAY
24048: NONEQUAL
24049: IFFALSE 24061
// begin result := false ;
24051: LD_ADDR_VAR 0 3
24055: PUSH
24056: LD_INT 0
24058: ST_TO_ADDR
// break ;
24059: GO 24063
// end ;
24061: GO 24024
24063: POP
24064: POP
// end else
24065: GO 24075
// result := false ;
24067: LD_ADDR_VAR 0 3
24071: PUSH
24072: LD_INT 0
24074: ST_TO_ADDR
// end ;
24075: LD_VAR 0 3
24079: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
24080: LD_INT 0
24082: PPUSH
24083: PPUSH
24084: PPUSH
// pom := GetBase ( fac ) ;
24085: LD_ADDR_VAR 0 5
24089: PUSH
24090: LD_VAR 0 1
24094: PPUSH
24095: CALL_OW 274
24099: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24100: LD_ADDR_VAR 0 4
24104: PUSH
24105: LD_VAR 0 2
24109: PUSH
24110: LD_INT 1
24112: ARRAY
24113: PPUSH
24114: LD_VAR 0 2
24118: PUSH
24119: LD_INT 2
24121: ARRAY
24122: PPUSH
24123: LD_VAR 0 2
24127: PUSH
24128: LD_INT 3
24130: ARRAY
24131: PPUSH
24132: LD_VAR 0 2
24136: PUSH
24137: LD_INT 4
24139: ARRAY
24140: PPUSH
24141: CALL_OW 449
24145: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
24146: LD_ADDR_VAR 0 3
24150: PUSH
24151: LD_VAR 0 5
24155: PPUSH
24156: LD_INT 1
24158: PPUSH
24159: CALL_OW 275
24163: PUSH
24164: LD_VAR 0 4
24168: PUSH
24169: LD_INT 1
24171: ARRAY
24172: GREATEREQUAL
24173: PUSH
24174: LD_VAR 0 5
24178: PPUSH
24179: LD_INT 2
24181: PPUSH
24182: CALL_OW 275
24186: PUSH
24187: LD_VAR 0 4
24191: PUSH
24192: LD_INT 2
24194: ARRAY
24195: GREATEREQUAL
24196: AND
24197: PUSH
24198: LD_VAR 0 5
24202: PPUSH
24203: LD_INT 3
24205: PPUSH
24206: CALL_OW 275
24210: PUSH
24211: LD_VAR 0 4
24215: PUSH
24216: LD_INT 3
24218: ARRAY
24219: GREATEREQUAL
24220: AND
24221: ST_TO_ADDR
// end ;
24222: LD_VAR 0 3
24226: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
24227: LD_INT 0
24229: PPUSH
24230: PPUSH
24231: PPUSH
24232: PPUSH
// pom := GetBase ( building ) ;
24233: LD_ADDR_VAR 0 3
24237: PUSH
24238: LD_VAR 0 1
24242: PPUSH
24243: CALL_OW 274
24247: ST_TO_ADDR
// if not pom then
24248: LD_VAR 0 3
24252: NOT
24253: IFFALSE 24257
// exit ;
24255: GO 24427
// btype := GetBType ( building ) ;
24257: LD_ADDR_VAR 0 5
24261: PUSH
24262: LD_VAR 0 1
24266: PPUSH
24267: CALL_OW 266
24271: ST_TO_ADDR
// if btype = b_armoury then
24272: LD_VAR 0 5
24276: PUSH
24277: LD_INT 4
24279: EQUAL
24280: IFFALSE 24290
// btype := b_barracks ;
24282: LD_ADDR_VAR 0 5
24286: PUSH
24287: LD_INT 5
24289: ST_TO_ADDR
// if btype = b_depot then
24290: LD_VAR 0 5
24294: PUSH
24295: LD_INT 0
24297: EQUAL
24298: IFFALSE 24308
// btype := b_warehouse ;
24300: LD_ADDR_VAR 0 5
24304: PUSH
24305: LD_INT 1
24307: ST_TO_ADDR
// if btype = b_workshop then
24308: LD_VAR 0 5
24312: PUSH
24313: LD_INT 2
24315: EQUAL
24316: IFFALSE 24326
// btype := b_factory ;
24318: LD_ADDR_VAR 0 5
24322: PUSH
24323: LD_INT 3
24325: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
24326: LD_ADDR_VAR 0 4
24330: PUSH
24331: LD_VAR 0 5
24335: PPUSH
24336: LD_VAR 0 1
24340: PPUSH
24341: CALL_OW 248
24345: PPUSH
24346: CALL_OW 450
24350: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
24351: LD_ADDR_VAR 0 2
24355: PUSH
24356: LD_VAR 0 3
24360: PPUSH
24361: LD_INT 1
24363: PPUSH
24364: CALL_OW 275
24368: PUSH
24369: LD_VAR 0 4
24373: PUSH
24374: LD_INT 1
24376: ARRAY
24377: GREATEREQUAL
24378: PUSH
24379: LD_VAR 0 3
24383: PPUSH
24384: LD_INT 2
24386: PPUSH
24387: CALL_OW 275
24391: PUSH
24392: LD_VAR 0 4
24396: PUSH
24397: LD_INT 2
24399: ARRAY
24400: GREATEREQUAL
24401: AND
24402: PUSH
24403: LD_VAR 0 3
24407: PPUSH
24408: LD_INT 3
24410: PPUSH
24411: CALL_OW 275
24415: PUSH
24416: LD_VAR 0 4
24420: PUSH
24421: LD_INT 3
24423: ARRAY
24424: GREATEREQUAL
24425: AND
24426: ST_TO_ADDR
// end ;
24427: LD_VAR 0 2
24431: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
24432: LD_INT 0
24434: PPUSH
24435: PPUSH
24436: PPUSH
// pom := GetBase ( building ) ;
24437: LD_ADDR_VAR 0 4
24441: PUSH
24442: LD_VAR 0 1
24446: PPUSH
24447: CALL_OW 274
24451: ST_TO_ADDR
// if not pom then
24452: LD_VAR 0 4
24456: NOT
24457: IFFALSE 24461
// exit ;
24459: GO 24562
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
24461: LD_ADDR_VAR 0 5
24465: PUSH
24466: LD_VAR 0 2
24470: PPUSH
24471: LD_VAR 0 1
24475: PPUSH
24476: CALL_OW 248
24480: PPUSH
24481: CALL_OW 450
24485: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
24486: LD_ADDR_VAR 0 3
24490: PUSH
24491: LD_VAR 0 4
24495: PPUSH
24496: LD_INT 1
24498: PPUSH
24499: CALL_OW 275
24503: PUSH
24504: LD_VAR 0 5
24508: PUSH
24509: LD_INT 1
24511: ARRAY
24512: GREATEREQUAL
24513: PUSH
24514: LD_VAR 0 4
24518: PPUSH
24519: LD_INT 2
24521: PPUSH
24522: CALL_OW 275
24526: PUSH
24527: LD_VAR 0 5
24531: PUSH
24532: LD_INT 2
24534: ARRAY
24535: GREATEREQUAL
24536: AND
24537: PUSH
24538: LD_VAR 0 4
24542: PPUSH
24543: LD_INT 3
24545: PPUSH
24546: CALL_OW 275
24550: PUSH
24551: LD_VAR 0 5
24555: PUSH
24556: LD_INT 3
24558: ARRAY
24559: GREATEREQUAL
24560: AND
24561: ST_TO_ADDR
// end ;
24562: LD_VAR 0 3
24566: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
24567: LD_INT 0
24569: PPUSH
24570: PPUSH
24571: PPUSH
24572: PPUSH
24573: PPUSH
24574: PPUSH
24575: PPUSH
24576: PPUSH
24577: PPUSH
24578: PPUSH
// result := false ;
24579: LD_ADDR_VAR 0 6
24583: PUSH
24584: LD_INT 0
24586: ST_TO_ADDR
// if not base or not btype or not x or not y then
24587: LD_VAR 0 1
24591: NOT
24592: PUSH
24593: LD_VAR 0 2
24597: NOT
24598: OR
24599: PUSH
24600: LD_VAR 0 3
24604: NOT
24605: OR
24606: PUSH
24607: LD_VAR 0 4
24611: NOT
24612: OR
24613: IFFALSE 24617
// exit ;
24615: GO 25226
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
24617: LD_ADDR_VAR 0 12
24621: PUSH
24622: LD_VAR 0 2
24626: PPUSH
24627: LD_VAR 0 3
24631: PPUSH
24632: LD_VAR 0 4
24636: PPUSH
24637: LD_VAR 0 5
24641: PPUSH
24642: LD_VAR 0 1
24646: PUSH
24647: LD_INT 1
24649: ARRAY
24650: PPUSH
24651: CALL_OW 248
24655: PPUSH
24656: LD_INT 0
24658: PPUSH
24659: CALL 26063 0 6
24663: ST_TO_ADDR
// if not hexes then
24664: LD_VAR 0 12
24668: NOT
24669: IFFALSE 24673
// exit ;
24671: GO 25226
// for i = 1 to hexes do
24673: LD_ADDR_VAR 0 7
24677: PUSH
24678: DOUBLE
24679: LD_INT 1
24681: DEC
24682: ST_TO_ADDR
24683: LD_VAR 0 12
24687: PUSH
24688: FOR_TO
24689: IFFALSE 25224
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
24691: LD_ADDR_VAR 0 11
24695: PUSH
24696: LD_VAR 0 12
24700: PUSH
24701: LD_VAR 0 7
24705: ARRAY
24706: PUSH
24707: LD_INT 1
24709: ARRAY
24710: PPUSH
24711: LD_VAR 0 12
24715: PUSH
24716: LD_VAR 0 7
24720: ARRAY
24721: PUSH
24722: LD_INT 2
24724: ARRAY
24725: PPUSH
24726: CALL_OW 428
24730: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
24731: LD_VAR 0 12
24735: PUSH
24736: LD_VAR 0 7
24740: ARRAY
24741: PUSH
24742: LD_INT 1
24744: ARRAY
24745: PPUSH
24746: LD_VAR 0 12
24750: PUSH
24751: LD_VAR 0 7
24755: ARRAY
24756: PUSH
24757: LD_INT 2
24759: ARRAY
24760: PPUSH
24761: CALL_OW 351
24765: PUSH
24766: LD_VAR 0 12
24770: PUSH
24771: LD_VAR 0 7
24775: ARRAY
24776: PUSH
24777: LD_INT 1
24779: ARRAY
24780: PPUSH
24781: LD_VAR 0 12
24785: PUSH
24786: LD_VAR 0 7
24790: ARRAY
24791: PUSH
24792: LD_INT 2
24794: ARRAY
24795: PPUSH
24796: CALL_OW 488
24800: NOT
24801: OR
24802: PUSH
24803: LD_VAR 0 11
24807: PPUSH
24808: CALL_OW 247
24812: PUSH
24813: LD_INT 3
24815: EQUAL
24816: OR
24817: IFFALSE 24823
// exit ;
24819: POP
24820: POP
24821: GO 25226
// if not tmp or not tmp in base then
24823: LD_VAR 0 11
24827: NOT
24828: PUSH
24829: LD_VAR 0 11
24833: PUSH
24834: LD_VAR 0 1
24838: IN
24839: NOT
24840: OR
24841: IFFALSE 24845
// continue ;
24843: GO 24688
// result := true ;
24845: LD_ADDR_VAR 0 6
24849: PUSH
24850: LD_INT 1
24852: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
24853: LD_ADDR_VAR 0 15
24857: PUSH
24858: LD_VAR 0 1
24862: PPUSH
24863: LD_INT 22
24865: PUSH
24866: LD_VAR 0 11
24870: PPUSH
24871: CALL_OW 255
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: PUSH
24880: LD_INT 2
24882: PUSH
24883: LD_INT 30
24885: PUSH
24886: LD_INT 0
24888: PUSH
24889: EMPTY
24890: LIST
24891: LIST
24892: PUSH
24893: LD_INT 30
24895: PUSH
24896: LD_INT 1
24898: PUSH
24899: EMPTY
24900: LIST
24901: LIST
24902: PUSH
24903: EMPTY
24904: LIST
24905: LIST
24906: LIST
24907: PUSH
24908: EMPTY
24909: LIST
24910: LIST
24911: PPUSH
24912: CALL_OW 72
24916: ST_TO_ADDR
// if dep then
24917: LD_VAR 0 15
24921: IFFALSE 25057
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
24923: LD_ADDR_VAR 0 14
24927: PUSH
24928: LD_VAR 0 15
24932: PUSH
24933: LD_INT 1
24935: ARRAY
24936: PPUSH
24937: CALL_OW 250
24941: PPUSH
24942: LD_VAR 0 15
24946: PUSH
24947: LD_INT 1
24949: ARRAY
24950: PPUSH
24951: CALL_OW 254
24955: PPUSH
24956: LD_INT 5
24958: PPUSH
24959: CALL_OW 272
24963: PUSH
24964: LD_VAR 0 15
24968: PUSH
24969: LD_INT 1
24971: ARRAY
24972: PPUSH
24973: CALL_OW 251
24977: PPUSH
24978: LD_VAR 0 15
24982: PUSH
24983: LD_INT 1
24985: ARRAY
24986: PPUSH
24987: CALL_OW 254
24991: PPUSH
24992: LD_INT 5
24994: PPUSH
24995: CALL_OW 273
24999: PUSH
25000: EMPTY
25001: LIST
25002: LIST
25003: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
25004: LD_VAR 0 14
25008: PUSH
25009: LD_INT 1
25011: ARRAY
25012: PPUSH
25013: LD_VAR 0 14
25017: PUSH
25018: LD_INT 2
25020: ARRAY
25021: PPUSH
25022: CALL_OW 488
25026: IFFALSE 25057
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
25028: LD_VAR 0 11
25032: PPUSH
25033: LD_VAR 0 14
25037: PUSH
25038: LD_INT 1
25040: ARRAY
25041: PPUSH
25042: LD_VAR 0 14
25046: PUSH
25047: LD_INT 2
25049: ARRAY
25050: PPUSH
25051: CALL_OW 111
// continue ;
25055: GO 24688
// end ; end ; r := GetDir ( tmp ) ;
25057: LD_ADDR_VAR 0 13
25061: PUSH
25062: LD_VAR 0 11
25066: PPUSH
25067: CALL_OW 254
25071: ST_TO_ADDR
// if r = 5 then
25072: LD_VAR 0 13
25076: PUSH
25077: LD_INT 5
25079: EQUAL
25080: IFFALSE 25090
// r := 0 ;
25082: LD_ADDR_VAR 0 13
25086: PUSH
25087: LD_INT 0
25089: ST_TO_ADDR
// for j = r to 5 do
25090: LD_ADDR_VAR 0 8
25094: PUSH
25095: DOUBLE
25096: LD_VAR 0 13
25100: DEC
25101: ST_TO_ADDR
25102: LD_INT 5
25104: PUSH
25105: FOR_TO
25106: IFFALSE 25220
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
25108: LD_ADDR_VAR 0 9
25112: PUSH
25113: LD_VAR 0 11
25117: PPUSH
25118: CALL_OW 250
25122: PPUSH
25123: LD_VAR 0 8
25127: PPUSH
25128: LD_INT 2
25130: PPUSH
25131: CALL_OW 272
25135: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
25136: LD_ADDR_VAR 0 10
25140: PUSH
25141: LD_VAR 0 11
25145: PPUSH
25146: CALL_OW 251
25150: PPUSH
25151: LD_VAR 0 8
25155: PPUSH
25156: LD_INT 2
25158: PPUSH
25159: CALL_OW 273
25163: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
25164: LD_VAR 0 9
25168: PPUSH
25169: LD_VAR 0 10
25173: PPUSH
25174: CALL_OW 488
25178: PUSH
25179: LD_VAR 0 9
25183: PPUSH
25184: LD_VAR 0 10
25188: PPUSH
25189: CALL_OW 428
25193: NOT
25194: AND
25195: IFFALSE 25218
// begin ComMoveXY ( tmp , _x , _y ) ;
25197: LD_VAR 0 11
25201: PPUSH
25202: LD_VAR 0 9
25206: PPUSH
25207: LD_VAR 0 10
25211: PPUSH
25212: CALL_OW 111
// break ;
25216: GO 25220
// end ; end ;
25218: GO 25105
25220: POP
25221: POP
// end ;
25222: GO 24688
25224: POP
25225: POP
// end ;
25226: LD_VAR 0 6
25230: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
25231: LD_INT 0
25233: PPUSH
25234: PPUSH
25235: PPUSH
25236: PPUSH
25237: PPUSH
25238: PPUSH
25239: PPUSH
25240: PPUSH
25241: PPUSH
25242: PPUSH
// result := false ;
25243: LD_ADDR_VAR 0 6
25247: PUSH
25248: LD_INT 0
25250: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
25251: LD_VAR 0 1
25255: NOT
25256: PUSH
25257: LD_VAR 0 1
25261: PPUSH
25262: CALL_OW 266
25266: PUSH
25267: LD_INT 0
25269: PUSH
25270: LD_INT 1
25272: PUSH
25273: EMPTY
25274: LIST
25275: LIST
25276: IN
25277: NOT
25278: OR
25279: PUSH
25280: LD_VAR 0 2
25284: NOT
25285: OR
25286: PUSH
25287: LD_VAR 0 5
25291: PUSH
25292: LD_INT 0
25294: PUSH
25295: LD_INT 1
25297: PUSH
25298: LD_INT 2
25300: PUSH
25301: LD_INT 3
25303: PUSH
25304: LD_INT 4
25306: PUSH
25307: LD_INT 5
25309: PUSH
25310: EMPTY
25311: LIST
25312: LIST
25313: LIST
25314: LIST
25315: LIST
25316: LIST
25317: IN
25318: NOT
25319: OR
25320: PUSH
25321: LD_VAR 0 3
25325: PPUSH
25326: LD_VAR 0 4
25330: PPUSH
25331: CALL_OW 488
25335: NOT
25336: OR
25337: IFFALSE 25341
// exit ;
25339: GO 26058
// pom := GetBase ( depot ) ;
25341: LD_ADDR_VAR 0 10
25345: PUSH
25346: LD_VAR 0 1
25350: PPUSH
25351: CALL_OW 274
25355: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
25356: LD_ADDR_VAR 0 11
25360: PUSH
25361: LD_VAR 0 2
25365: PPUSH
25366: LD_VAR 0 1
25370: PPUSH
25371: CALL_OW 248
25375: PPUSH
25376: CALL_OW 450
25380: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
25381: LD_VAR 0 10
25385: PPUSH
25386: LD_INT 1
25388: PPUSH
25389: CALL_OW 275
25393: PUSH
25394: LD_VAR 0 11
25398: PUSH
25399: LD_INT 1
25401: ARRAY
25402: GREATEREQUAL
25403: PUSH
25404: LD_VAR 0 10
25408: PPUSH
25409: LD_INT 2
25411: PPUSH
25412: CALL_OW 275
25416: PUSH
25417: LD_VAR 0 11
25421: PUSH
25422: LD_INT 2
25424: ARRAY
25425: GREATEREQUAL
25426: AND
25427: PUSH
25428: LD_VAR 0 10
25432: PPUSH
25433: LD_INT 3
25435: PPUSH
25436: CALL_OW 275
25440: PUSH
25441: LD_VAR 0 11
25445: PUSH
25446: LD_INT 3
25448: ARRAY
25449: GREATEREQUAL
25450: AND
25451: NOT
25452: IFFALSE 25456
// exit ;
25454: GO 26058
// if GetBType ( depot ) = b_depot then
25456: LD_VAR 0 1
25460: PPUSH
25461: CALL_OW 266
25465: PUSH
25466: LD_INT 0
25468: EQUAL
25469: IFFALSE 25481
// dist := 28 else
25471: LD_ADDR_VAR 0 14
25475: PUSH
25476: LD_INT 28
25478: ST_TO_ADDR
25479: GO 25489
// dist := 36 ;
25481: LD_ADDR_VAR 0 14
25485: PUSH
25486: LD_INT 36
25488: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
25489: LD_VAR 0 1
25493: PPUSH
25494: LD_VAR 0 3
25498: PPUSH
25499: LD_VAR 0 4
25503: PPUSH
25504: CALL_OW 297
25508: PUSH
25509: LD_VAR 0 14
25513: GREATER
25514: IFFALSE 25518
// exit ;
25516: GO 26058
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
25518: LD_ADDR_VAR 0 12
25522: PUSH
25523: LD_VAR 0 2
25527: PPUSH
25528: LD_VAR 0 3
25532: PPUSH
25533: LD_VAR 0 4
25537: PPUSH
25538: LD_VAR 0 5
25542: PPUSH
25543: LD_VAR 0 1
25547: PPUSH
25548: CALL_OW 248
25552: PPUSH
25553: LD_INT 0
25555: PPUSH
25556: CALL 26063 0 6
25560: ST_TO_ADDR
// if not hexes then
25561: LD_VAR 0 12
25565: NOT
25566: IFFALSE 25570
// exit ;
25568: GO 26058
// hex := GetHexInfo ( x , y ) ;
25570: LD_ADDR_VAR 0 15
25574: PUSH
25575: LD_VAR 0 3
25579: PPUSH
25580: LD_VAR 0 4
25584: PPUSH
25585: CALL_OW 546
25589: ST_TO_ADDR
// if hex [ 1 ] then
25590: LD_VAR 0 15
25594: PUSH
25595: LD_INT 1
25597: ARRAY
25598: IFFALSE 25602
// exit ;
25600: GO 26058
// height := hex [ 2 ] ;
25602: LD_ADDR_VAR 0 13
25606: PUSH
25607: LD_VAR 0 15
25611: PUSH
25612: LD_INT 2
25614: ARRAY
25615: ST_TO_ADDR
// for i = 1 to hexes do
25616: LD_ADDR_VAR 0 7
25620: PUSH
25621: DOUBLE
25622: LD_INT 1
25624: DEC
25625: ST_TO_ADDR
25626: LD_VAR 0 12
25630: PUSH
25631: FOR_TO
25632: IFFALSE 25962
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
25634: LD_VAR 0 12
25638: PUSH
25639: LD_VAR 0 7
25643: ARRAY
25644: PUSH
25645: LD_INT 1
25647: ARRAY
25648: PPUSH
25649: LD_VAR 0 12
25653: PUSH
25654: LD_VAR 0 7
25658: ARRAY
25659: PUSH
25660: LD_INT 2
25662: ARRAY
25663: PPUSH
25664: CALL_OW 488
25668: NOT
25669: PUSH
25670: LD_VAR 0 12
25674: PUSH
25675: LD_VAR 0 7
25679: ARRAY
25680: PUSH
25681: LD_INT 1
25683: ARRAY
25684: PPUSH
25685: LD_VAR 0 12
25689: PUSH
25690: LD_VAR 0 7
25694: ARRAY
25695: PUSH
25696: LD_INT 2
25698: ARRAY
25699: PPUSH
25700: CALL_OW 428
25704: PUSH
25705: LD_INT 0
25707: GREATER
25708: OR
25709: PUSH
25710: LD_VAR 0 12
25714: PUSH
25715: LD_VAR 0 7
25719: ARRAY
25720: PUSH
25721: LD_INT 1
25723: ARRAY
25724: PPUSH
25725: LD_VAR 0 12
25729: PUSH
25730: LD_VAR 0 7
25734: ARRAY
25735: PUSH
25736: LD_INT 2
25738: ARRAY
25739: PPUSH
25740: CALL_OW 351
25744: OR
25745: IFFALSE 25751
// exit ;
25747: POP
25748: POP
25749: GO 26058
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25751: LD_ADDR_VAR 0 8
25755: PUSH
25756: LD_VAR 0 12
25760: PUSH
25761: LD_VAR 0 7
25765: ARRAY
25766: PUSH
25767: LD_INT 1
25769: ARRAY
25770: PPUSH
25771: LD_VAR 0 12
25775: PUSH
25776: LD_VAR 0 7
25780: ARRAY
25781: PUSH
25782: LD_INT 2
25784: ARRAY
25785: PPUSH
25786: CALL_OW 546
25790: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
25791: LD_VAR 0 8
25795: PUSH
25796: LD_INT 1
25798: ARRAY
25799: PUSH
25800: LD_VAR 0 8
25804: PUSH
25805: LD_INT 2
25807: ARRAY
25808: PUSH
25809: LD_VAR 0 13
25813: PUSH
25814: LD_INT 2
25816: PLUS
25817: GREATER
25818: OR
25819: PUSH
25820: LD_VAR 0 8
25824: PUSH
25825: LD_INT 2
25827: ARRAY
25828: PUSH
25829: LD_VAR 0 13
25833: PUSH
25834: LD_INT 2
25836: MINUS
25837: LESS
25838: OR
25839: PUSH
25840: LD_VAR 0 8
25844: PUSH
25845: LD_INT 3
25847: ARRAY
25848: PUSH
25849: LD_INT 0
25851: PUSH
25852: LD_INT 8
25854: PUSH
25855: LD_INT 9
25857: PUSH
25858: LD_INT 10
25860: PUSH
25861: LD_INT 11
25863: PUSH
25864: LD_INT 12
25866: PUSH
25867: LD_INT 13
25869: PUSH
25870: LD_INT 16
25872: PUSH
25873: LD_INT 17
25875: PUSH
25876: LD_INT 18
25878: PUSH
25879: LD_INT 19
25881: PUSH
25882: LD_INT 20
25884: PUSH
25885: LD_INT 21
25887: PUSH
25888: EMPTY
25889: LIST
25890: LIST
25891: LIST
25892: LIST
25893: LIST
25894: LIST
25895: LIST
25896: LIST
25897: LIST
25898: LIST
25899: LIST
25900: LIST
25901: LIST
25902: IN
25903: NOT
25904: OR
25905: PUSH
25906: LD_VAR 0 8
25910: PUSH
25911: LD_INT 5
25913: ARRAY
25914: NOT
25915: OR
25916: PUSH
25917: LD_VAR 0 8
25921: PUSH
25922: LD_INT 6
25924: ARRAY
25925: PUSH
25926: LD_INT 1
25928: PUSH
25929: LD_INT 2
25931: PUSH
25932: LD_INT 7
25934: PUSH
25935: LD_INT 9
25937: PUSH
25938: LD_INT 10
25940: PUSH
25941: LD_INT 11
25943: PUSH
25944: EMPTY
25945: LIST
25946: LIST
25947: LIST
25948: LIST
25949: LIST
25950: LIST
25951: IN
25952: NOT
25953: OR
25954: IFFALSE 25960
// exit ;
25956: POP
25957: POP
25958: GO 26058
// end ;
25960: GO 25631
25962: POP
25963: POP
// side := GetSide ( depot ) ;
25964: LD_ADDR_VAR 0 9
25968: PUSH
25969: LD_VAR 0 1
25973: PPUSH
25974: CALL_OW 255
25978: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
25979: LD_VAR 0 9
25983: PPUSH
25984: LD_VAR 0 3
25988: PPUSH
25989: LD_VAR 0 4
25993: PPUSH
25994: LD_INT 20
25996: PPUSH
25997: CALL 18712 0 4
26001: PUSH
26002: LD_INT 4
26004: ARRAY
26005: IFFALSE 26009
// exit ;
26007: GO 26058
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
26009: LD_VAR 0 2
26013: PUSH
26014: LD_INT 29
26016: PUSH
26017: LD_INT 30
26019: PUSH
26020: EMPTY
26021: LIST
26022: LIST
26023: IN
26024: PUSH
26025: LD_VAR 0 3
26029: PPUSH
26030: LD_VAR 0 4
26034: PPUSH
26035: LD_VAR 0 9
26039: PPUSH
26040: CALL_OW 440
26044: NOT
26045: AND
26046: IFFALSE 26050
// exit ;
26048: GO 26058
// result := true ;
26050: LD_ADDR_VAR 0 6
26054: PUSH
26055: LD_INT 1
26057: ST_TO_ADDR
// end ;
26058: LD_VAR 0 6
26062: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
26063: LD_INT 0
26065: PPUSH
26066: PPUSH
26067: PPUSH
26068: PPUSH
26069: PPUSH
26070: PPUSH
26071: PPUSH
26072: PPUSH
26073: PPUSH
26074: PPUSH
26075: PPUSH
26076: PPUSH
26077: PPUSH
26078: PPUSH
26079: PPUSH
26080: PPUSH
26081: PPUSH
26082: PPUSH
26083: PPUSH
26084: PPUSH
26085: PPUSH
26086: PPUSH
26087: PPUSH
26088: PPUSH
26089: PPUSH
26090: PPUSH
26091: PPUSH
26092: PPUSH
26093: PPUSH
26094: PPUSH
26095: PPUSH
26096: PPUSH
26097: PPUSH
26098: PPUSH
26099: PPUSH
26100: PPUSH
26101: PPUSH
26102: PPUSH
26103: PPUSH
26104: PPUSH
26105: PPUSH
26106: PPUSH
26107: PPUSH
26108: PPUSH
26109: PPUSH
26110: PPUSH
26111: PPUSH
26112: PPUSH
26113: PPUSH
26114: PPUSH
26115: PPUSH
26116: PPUSH
26117: PPUSH
26118: PPUSH
26119: PPUSH
26120: PPUSH
26121: PPUSH
26122: PPUSH
// result = [ ] ;
26123: LD_ADDR_VAR 0 7
26127: PUSH
26128: EMPTY
26129: ST_TO_ADDR
// temp_list = [ ] ;
26130: LD_ADDR_VAR 0 9
26134: PUSH
26135: EMPTY
26136: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
26137: LD_VAR 0 4
26141: PUSH
26142: LD_INT 0
26144: PUSH
26145: LD_INT 1
26147: PUSH
26148: LD_INT 2
26150: PUSH
26151: LD_INT 3
26153: PUSH
26154: LD_INT 4
26156: PUSH
26157: LD_INT 5
26159: PUSH
26160: EMPTY
26161: LIST
26162: LIST
26163: LIST
26164: LIST
26165: LIST
26166: LIST
26167: IN
26168: NOT
26169: PUSH
26170: LD_VAR 0 1
26174: PUSH
26175: LD_INT 0
26177: PUSH
26178: LD_INT 1
26180: PUSH
26181: EMPTY
26182: LIST
26183: LIST
26184: IN
26185: PUSH
26186: LD_VAR 0 5
26190: PUSH
26191: LD_INT 1
26193: PUSH
26194: LD_INT 2
26196: PUSH
26197: LD_INT 3
26199: PUSH
26200: EMPTY
26201: LIST
26202: LIST
26203: LIST
26204: IN
26205: NOT
26206: AND
26207: OR
26208: IFFALSE 26212
// exit ;
26210: GO 44603
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
26212: LD_VAR 0 1
26216: PUSH
26217: LD_INT 6
26219: PUSH
26220: LD_INT 7
26222: PUSH
26223: LD_INT 8
26225: PUSH
26226: LD_INT 13
26228: PUSH
26229: LD_INT 12
26231: PUSH
26232: LD_INT 15
26234: PUSH
26235: LD_INT 11
26237: PUSH
26238: LD_INT 14
26240: PUSH
26241: LD_INT 10
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: LIST
26248: LIST
26249: LIST
26250: LIST
26251: LIST
26252: LIST
26253: LIST
26254: IN
26255: IFFALSE 26265
// btype = b_lab ;
26257: LD_ADDR_VAR 0 1
26261: PUSH
26262: LD_INT 6
26264: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
26265: LD_VAR 0 6
26269: PUSH
26270: LD_INT 0
26272: PUSH
26273: LD_INT 1
26275: PUSH
26276: LD_INT 2
26278: PUSH
26279: EMPTY
26280: LIST
26281: LIST
26282: LIST
26283: IN
26284: NOT
26285: PUSH
26286: LD_VAR 0 1
26290: PUSH
26291: LD_INT 0
26293: PUSH
26294: LD_INT 1
26296: PUSH
26297: LD_INT 2
26299: PUSH
26300: LD_INT 3
26302: PUSH
26303: LD_INT 6
26305: PUSH
26306: LD_INT 36
26308: PUSH
26309: LD_INT 4
26311: PUSH
26312: LD_INT 5
26314: PUSH
26315: LD_INT 31
26317: PUSH
26318: LD_INT 32
26320: PUSH
26321: LD_INT 33
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: LIST
26328: LIST
26329: LIST
26330: LIST
26331: LIST
26332: LIST
26333: LIST
26334: LIST
26335: LIST
26336: IN
26337: NOT
26338: PUSH
26339: LD_VAR 0 6
26343: PUSH
26344: LD_INT 1
26346: EQUAL
26347: AND
26348: OR
26349: PUSH
26350: LD_VAR 0 1
26354: PUSH
26355: LD_INT 2
26357: PUSH
26358: LD_INT 3
26360: PUSH
26361: EMPTY
26362: LIST
26363: LIST
26364: IN
26365: NOT
26366: PUSH
26367: LD_VAR 0 6
26371: PUSH
26372: LD_INT 2
26374: EQUAL
26375: AND
26376: OR
26377: IFFALSE 26387
// mode = 0 ;
26379: LD_ADDR_VAR 0 6
26383: PUSH
26384: LD_INT 0
26386: ST_TO_ADDR
// case mode of 0 :
26387: LD_VAR 0 6
26391: PUSH
26392: LD_INT 0
26394: DOUBLE
26395: EQUAL
26396: IFTRUE 26400
26398: GO 37853
26400: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
26401: LD_ADDR_VAR 0 11
26405: PUSH
26406: LD_INT 0
26408: PUSH
26409: LD_INT 0
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: PUSH
26416: LD_INT 0
26418: PUSH
26419: LD_INT 1
26421: NEG
26422: PUSH
26423: EMPTY
26424: LIST
26425: LIST
26426: PUSH
26427: LD_INT 1
26429: PUSH
26430: LD_INT 0
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: PUSH
26437: LD_INT 1
26439: PUSH
26440: LD_INT 1
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: PUSH
26447: LD_INT 0
26449: PUSH
26450: LD_INT 1
26452: PUSH
26453: EMPTY
26454: LIST
26455: LIST
26456: PUSH
26457: LD_INT 1
26459: NEG
26460: PUSH
26461: LD_INT 0
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: PUSH
26468: LD_INT 1
26470: NEG
26471: PUSH
26472: LD_INT 1
26474: NEG
26475: PUSH
26476: EMPTY
26477: LIST
26478: LIST
26479: PUSH
26480: LD_INT 1
26482: NEG
26483: PUSH
26484: LD_INT 2
26486: NEG
26487: PUSH
26488: EMPTY
26489: LIST
26490: LIST
26491: PUSH
26492: LD_INT 0
26494: PUSH
26495: LD_INT 2
26497: NEG
26498: PUSH
26499: EMPTY
26500: LIST
26501: LIST
26502: PUSH
26503: LD_INT 1
26505: PUSH
26506: LD_INT 1
26508: NEG
26509: PUSH
26510: EMPTY
26511: LIST
26512: LIST
26513: PUSH
26514: LD_INT 1
26516: PUSH
26517: LD_INT 2
26519: PUSH
26520: EMPTY
26521: LIST
26522: LIST
26523: PUSH
26524: LD_INT 0
26526: PUSH
26527: LD_INT 2
26529: PUSH
26530: EMPTY
26531: LIST
26532: LIST
26533: PUSH
26534: LD_INT 1
26536: NEG
26537: PUSH
26538: LD_INT 1
26540: PUSH
26541: EMPTY
26542: LIST
26543: LIST
26544: PUSH
26545: LD_INT 1
26547: PUSH
26548: LD_INT 3
26550: PUSH
26551: EMPTY
26552: LIST
26553: LIST
26554: PUSH
26555: LD_INT 0
26557: PUSH
26558: LD_INT 3
26560: PUSH
26561: EMPTY
26562: LIST
26563: LIST
26564: PUSH
26565: LD_INT 1
26567: NEG
26568: PUSH
26569: LD_INT 2
26571: PUSH
26572: EMPTY
26573: LIST
26574: LIST
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: LIST
26580: LIST
26581: LIST
26582: LIST
26583: LIST
26584: LIST
26585: LIST
26586: LIST
26587: LIST
26588: LIST
26589: LIST
26590: LIST
26591: LIST
26592: LIST
26593: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
26594: LD_ADDR_VAR 0 12
26598: PUSH
26599: LD_INT 0
26601: PUSH
26602: LD_INT 0
26604: PUSH
26605: EMPTY
26606: LIST
26607: LIST
26608: PUSH
26609: LD_INT 0
26611: PUSH
26612: LD_INT 1
26614: NEG
26615: PUSH
26616: EMPTY
26617: LIST
26618: LIST
26619: PUSH
26620: LD_INT 1
26622: PUSH
26623: LD_INT 0
26625: PUSH
26626: EMPTY
26627: LIST
26628: LIST
26629: PUSH
26630: LD_INT 1
26632: PUSH
26633: LD_INT 1
26635: PUSH
26636: EMPTY
26637: LIST
26638: LIST
26639: PUSH
26640: LD_INT 0
26642: PUSH
26643: LD_INT 1
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PUSH
26650: LD_INT 1
26652: NEG
26653: PUSH
26654: LD_INT 0
26656: PUSH
26657: EMPTY
26658: LIST
26659: LIST
26660: PUSH
26661: LD_INT 1
26663: NEG
26664: PUSH
26665: LD_INT 1
26667: NEG
26668: PUSH
26669: EMPTY
26670: LIST
26671: LIST
26672: PUSH
26673: LD_INT 1
26675: PUSH
26676: LD_INT 1
26678: NEG
26679: PUSH
26680: EMPTY
26681: LIST
26682: LIST
26683: PUSH
26684: LD_INT 2
26686: PUSH
26687: LD_INT 0
26689: PUSH
26690: EMPTY
26691: LIST
26692: LIST
26693: PUSH
26694: LD_INT 2
26696: PUSH
26697: LD_INT 1
26699: PUSH
26700: EMPTY
26701: LIST
26702: LIST
26703: PUSH
26704: LD_INT 1
26706: NEG
26707: PUSH
26708: LD_INT 1
26710: PUSH
26711: EMPTY
26712: LIST
26713: LIST
26714: PUSH
26715: LD_INT 2
26717: NEG
26718: PUSH
26719: LD_INT 0
26721: PUSH
26722: EMPTY
26723: LIST
26724: LIST
26725: PUSH
26726: LD_INT 2
26728: NEG
26729: PUSH
26730: LD_INT 1
26732: NEG
26733: PUSH
26734: EMPTY
26735: LIST
26736: LIST
26737: PUSH
26738: LD_INT 2
26740: NEG
26741: PUSH
26742: LD_INT 1
26744: PUSH
26745: EMPTY
26746: LIST
26747: LIST
26748: PUSH
26749: LD_INT 3
26751: NEG
26752: PUSH
26753: LD_INT 0
26755: PUSH
26756: EMPTY
26757: LIST
26758: LIST
26759: PUSH
26760: LD_INT 3
26762: NEG
26763: PUSH
26764: LD_INT 1
26766: NEG
26767: PUSH
26768: EMPTY
26769: LIST
26770: LIST
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: LIST
26776: LIST
26777: LIST
26778: LIST
26779: LIST
26780: LIST
26781: LIST
26782: LIST
26783: LIST
26784: LIST
26785: LIST
26786: LIST
26787: LIST
26788: LIST
26789: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
26790: LD_ADDR_VAR 0 13
26794: PUSH
26795: LD_INT 0
26797: PUSH
26798: LD_INT 0
26800: PUSH
26801: EMPTY
26802: LIST
26803: LIST
26804: PUSH
26805: LD_INT 0
26807: PUSH
26808: LD_INT 1
26810: NEG
26811: PUSH
26812: EMPTY
26813: LIST
26814: LIST
26815: PUSH
26816: LD_INT 1
26818: PUSH
26819: LD_INT 0
26821: PUSH
26822: EMPTY
26823: LIST
26824: LIST
26825: PUSH
26826: LD_INT 1
26828: PUSH
26829: LD_INT 1
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PUSH
26836: LD_INT 0
26838: PUSH
26839: LD_INT 1
26841: PUSH
26842: EMPTY
26843: LIST
26844: LIST
26845: PUSH
26846: LD_INT 1
26848: NEG
26849: PUSH
26850: LD_INT 0
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: LD_INT 1
26859: NEG
26860: PUSH
26861: LD_INT 1
26863: NEG
26864: PUSH
26865: EMPTY
26866: LIST
26867: LIST
26868: PUSH
26869: LD_INT 1
26871: NEG
26872: PUSH
26873: LD_INT 2
26875: NEG
26876: PUSH
26877: EMPTY
26878: LIST
26879: LIST
26880: PUSH
26881: LD_INT 2
26883: PUSH
26884: LD_INT 1
26886: PUSH
26887: EMPTY
26888: LIST
26889: LIST
26890: PUSH
26891: LD_INT 2
26893: PUSH
26894: LD_INT 2
26896: PUSH
26897: EMPTY
26898: LIST
26899: LIST
26900: PUSH
26901: LD_INT 1
26903: PUSH
26904: LD_INT 2
26906: PUSH
26907: EMPTY
26908: LIST
26909: LIST
26910: PUSH
26911: LD_INT 2
26913: NEG
26914: PUSH
26915: LD_INT 1
26917: NEG
26918: PUSH
26919: EMPTY
26920: LIST
26921: LIST
26922: PUSH
26923: LD_INT 2
26925: NEG
26926: PUSH
26927: LD_INT 2
26929: NEG
26930: PUSH
26931: EMPTY
26932: LIST
26933: LIST
26934: PUSH
26935: LD_INT 2
26937: NEG
26938: PUSH
26939: LD_INT 3
26941: NEG
26942: PUSH
26943: EMPTY
26944: LIST
26945: LIST
26946: PUSH
26947: LD_INT 3
26949: NEG
26950: PUSH
26951: LD_INT 2
26953: NEG
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: PUSH
26959: LD_INT 3
26961: NEG
26962: PUSH
26963: LD_INT 3
26965: NEG
26966: PUSH
26967: EMPTY
26968: LIST
26969: LIST
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: LIST
26975: LIST
26976: LIST
26977: LIST
26978: LIST
26979: LIST
26980: LIST
26981: LIST
26982: LIST
26983: LIST
26984: LIST
26985: LIST
26986: LIST
26987: LIST
26988: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
26989: LD_ADDR_VAR 0 14
26993: PUSH
26994: LD_INT 0
26996: PUSH
26997: LD_INT 0
26999: PUSH
27000: EMPTY
27001: LIST
27002: LIST
27003: PUSH
27004: LD_INT 0
27006: PUSH
27007: LD_INT 1
27009: NEG
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: PUSH
27015: LD_INT 1
27017: PUSH
27018: LD_INT 0
27020: PUSH
27021: EMPTY
27022: LIST
27023: LIST
27024: PUSH
27025: LD_INT 1
27027: PUSH
27028: LD_INT 1
27030: PUSH
27031: EMPTY
27032: LIST
27033: LIST
27034: PUSH
27035: LD_INT 0
27037: PUSH
27038: LD_INT 1
27040: PUSH
27041: EMPTY
27042: LIST
27043: LIST
27044: PUSH
27045: LD_INT 1
27047: NEG
27048: PUSH
27049: LD_INT 0
27051: PUSH
27052: EMPTY
27053: LIST
27054: LIST
27055: PUSH
27056: LD_INT 1
27058: NEG
27059: PUSH
27060: LD_INT 1
27062: NEG
27063: PUSH
27064: EMPTY
27065: LIST
27066: LIST
27067: PUSH
27068: LD_INT 1
27070: NEG
27071: PUSH
27072: LD_INT 2
27074: NEG
27075: PUSH
27076: EMPTY
27077: LIST
27078: LIST
27079: PUSH
27080: LD_INT 0
27082: PUSH
27083: LD_INT 2
27085: NEG
27086: PUSH
27087: EMPTY
27088: LIST
27089: LIST
27090: PUSH
27091: LD_INT 1
27093: PUSH
27094: LD_INT 1
27096: NEG
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: PUSH
27102: LD_INT 1
27104: PUSH
27105: LD_INT 2
27107: PUSH
27108: EMPTY
27109: LIST
27110: LIST
27111: PUSH
27112: LD_INT 0
27114: PUSH
27115: LD_INT 2
27117: PUSH
27118: EMPTY
27119: LIST
27120: LIST
27121: PUSH
27122: LD_INT 1
27124: NEG
27125: PUSH
27126: LD_INT 1
27128: PUSH
27129: EMPTY
27130: LIST
27131: LIST
27132: PUSH
27133: LD_INT 1
27135: NEG
27136: PUSH
27137: LD_INT 3
27139: NEG
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: PUSH
27145: LD_INT 0
27147: PUSH
27148: LD_INT 3
27150: NEG
27151: PUSH
27152: EMPTY
27153: LIST
27154: LIST
27155: PUSH
27156: LD_INT 1
27158: PUSH
27159: LD_INT 2
27161: NEG
27162: PUSH
27163: EMPTY
27164: LIST
27165: LIST
27166: PUSH
27167: EMPTY
27168: LIST
27169: LIST
27170: LIST
27171: LIST
27172: LIST
27173: LIST
27174: LIST
27175: LIST
27176: LIST
27177: LIST
27178: LIST
27179: LIST
27180: LIST
27181: LIST
27182: LIST
27183: LIST
27184: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
27185: LD_ADDR_VAR 0 15
27189: PUSH
27190: LD_INT 0
27192: PUSH
27193: LD_INT 0
27195: PUSH
27196: EMPTY
27197: LIST
27198: LIST
27199: PUSH
27200: LD_INT 0
27202: PUSH
27203: LD_INT 1
27205: NEG
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: PUSH
27211: LD_INT 1
27213: PUSH
27214: LD_INT 0
27216: PUSH
27217: EMPTY
27218: LIST
27219: LIST
27220: PUSH
27221: LD_INT 1
27223: PUSH
27224: LD_INT 1
27226: PUSH
27227: EMPTY
27228: LIST
27229: LIST
27230: PUSH
27231: LD_INT 0
27233: PUSH
27234: LD_INT 1
27236: PUSH
27237: EMPTY
27238: LIST
27239: LIST
27240: PUSH
27241: LD_INT 1
27243: NEG
27244: PUSH
27245: LD_INT 0
27247: PUSH
27248: EMPTY
27249: LIST
27250: LIST
27251: PUSH
27252: LD_INT 1
27254: NEG
27255: PUSH
27256: LD_INT 1
27258: NEG
27259: PUSH
27260: EMPTY
27261: LIST
27262: LIST
27263: PUSH
27264: LD_INT 1
27266: PUSH
27267: LD_INT 1
27269: NEG
27270: PUSH
27271: EMPTY
27272: LIST
27273: LIST
27274: PUSH
27275: LD_INT 2
27277: PUSH
27278: LD_INT 0
27280: PUSH
27281: EMPTY
27282: LIST
27283: LIST
27284: PUSH
27285: LD_INT 2
27287: PUSH
27288: LD_INT 1
27290: PUSH
27291: EMPTY
27292: LIST
27293: LIST
27294: PUSH
27295: LD_INT 1
27297: NEG
27298: PUSH
27299: LD_INT 1
27301: PUSH
27302: EMPTY
27303: LIST
27304: LIST
27305: PUSH
27306: LD_INT 2
27308: NEG
27309: PUSH
27310: LD_INT 0
27312: PUSH
27313: EMPTY
27314: LIST
27315: LIST
27316: PUSH
27317: LD_INT 2
27319: NEG
27320: PUSH
27321: LD_INT 1
27323: NEG
27324: PUSH
27325: EMPTY
27326: LIST
27327: LIST
27328: PUSH
27329: LD_INT 2
27331: PUSH
27332: LD_INT 1
27334: NEG
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: PUSH
27340: LD_INT 3
27342: PUSH
27343: LD_INT 0
27345: PUSH
27346: EMPTY
27347: LIST
27348: LIST
27349: PUSH
27350: LD_INT 3
27352: PUSH
27353: LD_INT 1
27355: PUSH
27356: EMPTY
27357: LIST
27358: LIST
27359: PUSH
27360: EMPTY
27361: LIST
27362: LIST
27363: LIST
27364: LIST
27365: LIST
27366: LIST
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: LIST
27372: LIST
27373: LIST
27374: LIST
27375: LIST
27376: LIST
27377: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
27378: LD_ADDR_VAR 0 16
27382: PUSH
27383: LD_INT 0
27385: PUSH
27386: LD_INT 0
27388: PUSH
27389: EMPTY
27390: LIST
27391: LIST
27392: PUSH
27393: LD_INT 0
27395: PUSH
27396: LD_INT 1
27398: NEG
27399: PUSH
27400: EMPTY
27401: LIST
27402: LIST
27403: PUSH
27404: LD_INT 1
27406: PUSH
27407: LD_INT 0
27409: PUSH
27410: EMPTY
27411: LIST
27412: LIST
27413: PUSH
27414: LD_INT 1
27416: PUSH
27417: LD_INT 1
27419: PUSH
27420: EMPTY
27421: LIST
27422: LIST
27423: PUSH
27424: LD_INT 0
27426: PUSH
27427: LD_INT 1
27429: PUSH
27430: EMPTY
27431: LIST
27432: LIST
27433: PUSH
27434: LD_INT 1
27436: NEG
27437: PUSH
27438: LD_INT 0
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: LD_INT 1
27447: NEG
27448: PUSH
27449: LD_INT 1
27451: NEG
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: PUSH
27457: LD_INT 1
27459: NEG
27460: PUSH
27461: LD_INT 2
27463: NEG
27464: PUSH
27465: EMPTY
27466: LIST
27467: LIST
27468: PUSH
27469: LD_INT 2
27471: PUSH
27472: LD_INT 1
27474: PUSH
27475: EMPTY
27476: LIST
27477: LIST
27478: PUSH
27479: LD_INT 2
27481: PUSH
27482: LD_INT 2
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: PUSH
27489: LD_INT 1
27491: PUSH
27492: LD_INT 2
27494: PUSH
27495: EMPTY
27496: LIST
27497: LIST
27498: PUSH
27499: LD_INT 2
27501: NEG
27502: PUSH
27503: LD_INT 1
27505: NEG
27506: PUSH
27507: EMPTY
27508: LIST
27509: LIST
27510: PUSH
27511: LD_INT 2
27513: NEG
27514: PUSH
27515: LD_INT 2
27517: NEG
27518: PUSH
27519: EMPTY
27520: LIST
27521: LIST
27522: PUSH
27523: LD_INT 3
27525: PUSH
27526: LD_INT 2
27528: PUSH
27529: EMPTY
27530: LIST
27531: LIST
27532: PUSH
27533: LD_INT 3
27535: PUSH
27536: LD_INT 3
27538: PUSH
27539: EMPTY
27540: LIST
27541: LIST
27542: PUSH
27543: LD_INT 2
27545: PUSH
27546: LD_INT 3
27548: PUSH
27549: EMPTY
27550: LIST
27551: LIST
27552: PUSH
27553: EMPTY
27554: LIST
27555: LIST
27556: LIST
27557: LIST
27558: LIST
27559: LIST
27560: LIST
27561: LIST
27562: LIST
27563: LIST
27564: LIST
27565: LIST
27566: LIST
27567: LIST
27568: LIST
27569: LIST
27570: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27571: LD_ADDR_VAR 0 17
27575: PUSH
27576: LD_INT 0
27578: PUSH
27579: LD_INT 0
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: PUSH
27586: LD_INT 0
27588: PUSH
27589: LD_INT 1
27591: NEG
27592: PUSH
27593: EMPTY
27594: LIST
27595: LIST
27596: PUSH
27597: LD_INT 1
27599: PUSH
27600: LD_INT 0
27602: PUSH
27603: EMPTY
27604: LIST
27605: LIST
27606: PUSH
27607: LD_INT 1
27609: PUSH
27610: LD_INT 1
27612: PUSH
27613: EMPTY
27614: LIST
27615: LIST
27616: PUSH
27617: LD_INT 0
27619: PUSH
27620: LD_INT 1
27622: PUSH
27623: EMPTY
27624: LIST
27625: LIST
27626: PUSH
27627: LD_INT 1
27629: NEG
27630: PUSH
27631: LD_INT 0
27633: PUSH
27634: EMPTY
27635: LIST
27636: LIST
27637: PUSH
27638: LD_INT 1
27640: NEG
27641: PUSH
27642: LD_INT 1
27644: NEG
27645: PUSH
27646: EMPTY
27647: LIST
27648: LIST
27649: PUSH
27650: LD_INT 1
27652: NEG
27653: PUSH
27654: LD_INT 2
27656: NEG
27657: PUSH
27658: EMPTY
27659: LIST
27660: LIST
27661: PUSH
27662: LD_INT 0
27664: PUSH
27665: LD_INT 2
27667: NEG
27668: PUSH
27669: EMPTY
27670: LIST
27671: LIST
27672: PUSH
27673: LD_INT 1
27675: PUSH
27676: LD_INT 1
27678: NEG
27679: PUSH
27680: EMPTY
27681: LIST
27682: LIST
27683: PUSH
27684: LD_INT 2
27686: PUSH
27687: LD_INT 0
27689: PUSH
27690: EMPTY
27691: LIST
27692: LIST
27693: PUSH
27694: LD_INT 2
27696: PUSH
27697: LD_INT 1
27699: PUSH
27700: EMPTY
27701: LIST
27702: LIST
27703: PUSH
27704: LD_INT 2
27706: PUSH
27707: LD_INT 2
27709: PUSH
27710: EMPTY
27711: LIST
27712: LIST
27713: PUSH
27714: LD_INT 1
27716: PUSH
27717: LD_INT 2
27719: PUSH
27720: EMPTY
27721: LIST
27722: LIST
27723: PUSH
27724: LD_INT 0
27726: PUSH
27727: LD_INT 2
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: PUSH
27734: LD_INT 1
27736: NEG
27737: PUSH
27738: LD_INT 1
27740: PUSH
27741: EMPTY
27742: LIST
27743: LIST
27744: PUSH
27745: LD_INT 2
27747: NEG
27748: PUSH
27749: LD_INT 0
27751: PUSH
27752: EMPTY
27753: LIST
27754: LIST
27755: PUSH
27756: LD_INT 2
27758: NEG
27759: PUSH
27760: LD_INT 1
27762: NEG
27763: PUSH
27764: EMPTY
27765: LIST
27766: LIST
27767: PUSH
27768: LD_INT 2
27770: NEG
27771: PUSH
27772: LD_INT 2
27774: NEG
27775: PUSH
27776: EMPTY
27777: LIST
27778: LIST
27779: PUSH
27780: EMPTY
27781: LIST
27782: LIST
27783: LIST
27784: LIST
27785: LIST
27786: LIST
27787: LIST
27788: LIST
27789: LIST
27790: LIST
27791: LIST
27792: LIST
27793: LIST
27794: LIST
27795: LIST
27796: LIST
27797: LIST
27798: LIST
27799: LIST
27800: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27801: LD_ADDR_VAR 0 18
27805: PUSH
27806: LD_INT 0
27808: PUSH
27809: LD_INT 0
27811: PUSH
27812: EMPTY
27813: LIST
27814: LIST
27815: PUSH
27816: LD_INT 0
27818: PUSH
27819: LD_INT 1
27821: NEG
27822: PUSH
27823: EMPTY
27824: LIST
27825: LIST
27826: PUSH
27827: LD_INT 1
27829: PUSH
27830: LD_INT 0
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PUSH
27837: LD_INT 1
27839: PUSH
27840: LD_INT 1
27842: PUSH
27843: EMPTY
27844: LIST
27845: LIST
27846: PUSH
27847: LD_INT 0
27849: PUSH
27850: LD_INT 1
27852: PUSH
27853: EMPTY
27854: LIST
27855: LIST
27856: PUSH
27857: LD_INT 1
27859: NEG
27860: PUSH
27861: LD_INT 0
27863: PUSH
27864: EMPTY
27865: LIST
27866: LIST
27867: PUSH
27868: LD_INT 1
27870: NEG
27871: PUSH
27872: LD_INT 1
27874: NEG
27875: PUSH
27876: EMPTY
27877: LIST
27878: LIST
27879: PUSH
27880: LD_INT 1
27882: NEG
27883: PUSH
27884: LD_INT 2
27886: NEG
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: PUSH
27892: LD_INT 0
27894: PUSH
27895: LD_INT 2
27897: NEG
27898: PUSH
27899: EMPTY
27900: LIST
27901: LIST
27902: PUSH
27903: LD_INT 1
27905: PUSH
27906: LD_INT 1
27908: NEG
27909: PUSH
27910: EMPTY
27911: LIST
27912: LIST
27913: PUSH
27914: LD_INT 2
27916: PUSH
27917: LD_INT 0
27919: PUSH
27920: EMPTY
27921: LIST
27922: LIST
27923: PUSH
27924: LD_INT 2
27926: PUSH
27927: LD_INT 1
27929: PUSH
27930: EMPTY
27931: LIST
27932: LIST
27933: PUSH
27934: LD_INT 2
27936: PUSH
27937: LD_INT 2
27939: PUSH
27940: EMPTY
27941: LIST
27942: LIST
27943: PUSH
27944: LD_INT 1
27946: PUSH
27947: LD_INT 2
27949: PUSH
27950: EMPTY
27951: LIST
27952: LIST
27953: PUSH
27954: LD_INT 0
27956: PUSH
27957: LD_INT 2
27959: PUSH
27960: EMPTY
27961: LIST
27962: LIST
27963: PUSH
27964: LD_INT 1
27966: NEG
27967: PUSH
27968: LD_INT 1
27970: PUSH
27971: EMPTY
27972: LIST
27973: LIST
27974: PUSH
27975: LD_INT 2
27977: NEG
27978: PUSH
27979: LD_INT 0
27981: PUSH
27982: EMPTY
27983: LIST
27984: LIST
27985: PUSH
27986: LD_INT 2
27988: NEG
27989: PUSH
27990: LD_INT 1
27992: NEG
27993: PUSH
27994: EMPTY
27995: LIST
27996: LIST
27997: PUSH
27998: LD_INT 2
28000: NEG
28001: PUSH
28002: LD_INT 2
28004: NEG
28005: PUSH
28006: EMPTY
28007: LIST
28008: LIST
28009: PUSH
28010: EMPTY
28011: LIST
28012: LIST
28013: LIST
28014: LIST
28015: LIST
28016: LIST
28017: LIST
28018: LIST
28019: LIST
28020: LIST
28021: LIST
28022: LIST
28023: LIST
28024: LIST
28025: LIST
28026: LIST
28027: LIST
28028: LIST
28029: LIST
28030: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28031: LD_ADDR_VAR 0 19
28035: PUSH
28036: LD_INT 0
28038: PUSH
28039: LD_INT 0
28041: PUSH
28042: EMPTY
28043: LIST
28044: LIST
28045: PUSH
28046: LD_INT 0
28048: PUSH
28049: LD_INT 1
28051: NEG
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: PUSH
28057: LD_INT 1
28059: PUSH
28060: LD_INT 0
28062: PUSH
28063: EMPTY
28064: LIST
28065: LIST
28066: PUSH
28067: LD_INT 1
28069: PUSH
28070: LD_INT 1
28072: PUSH
28073: EMPTY
28074: LIST
28075: LIST
28076: PUSH
28077: LD_INT 0
28079: PUSH
28080: LD_INT 1
28082: PUSH
28083: EMPTY
28084: LIST
28085: LIST
28086: PUSH
28087: LD_INT 1
28089: NEG
28090: PUSH
28091: LD_INT 0
28093: PUSH
28094: EMPTY
28095: LIST
28096: LIST
28097: PUSH
28098: LD_INT 1
28100: NEG
28101: PUSH
28102: LD_INT 1
28104: NEG
28105: PUSH
28106: EMPTY
28107: LIST
28108: LIST
28109: PUSH
28110: LD_INT 1
28112: NEG
28113: PUSH
28114: LD_INT 2
28116: NEG
28117: PUSH
28118: EMPTY
28119: LIST
28120: LIST
28121: PUSH
28122: LD_INT 0
28124: PUSH
28125: LD_INT 2
28127: NEG
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: PUSH
28133: LD_INT 1
28135: PUSH
28136: LD_INT 1
28138: NEG
28139: PUSH
28140: EMPTY
28141: LIST
28142: LIST
28143: PUSH
28144: LD_INT 2
28146: PUSH
28147: LD_INT 0
28149: PUSH
28150: EMPTY
28151: LIST
28152: LIST
28153: PUSH
28154: LD_INT 2
28156: PUSH
28157: LD_INT 1
28159: PUSH
28160: EMPTY
28161: LIST
28162: LIST
28163: PUSH
28164: LD_INT 2
28166: PUSH
28167: LD_INT 2
28169: PUSH
28170: EMPTY
28171: LIST
28172: LIST
28173: PUSH
28174: LD_INT 1
28176: PUSH
28177: LD_INT 2
28179: PUSH
28180: EMPTY
28181: LIST
28182: LIST
28183: PUSH
28184: LD_INT 0
28186: PUSH
28187: LD_INT 2
28189: PUSH
28190: EMPTY
28191: LIST
28192: LIST
28193: PUSH
28194: LD_INT 1
28196: NEG
28197: PUSH
28198: LD_INT 1
28200: PUSH
28201: EMPTY
28202: LIST
28203: LIST
28204: PUSH
28205: LD_INT 2
28207: NEG
28208: PUSH
28209: LD_INT 0
28211: PUSH
28212: EMPTY
28213: LIST
28214: LIST
28215: PUSH
28216: LD_INT 2
28218: NEG
28219: PUSH
28220: LD_INT 1
28222: NEG
28223: PUSH
28224: EMPTY
28225: LIST
28226: LIST
28227: PUSH
28228: LD_INT 2
28230: NEG
28231: PUSH
28232: LD_INT 2
28234: NEG
28235: PUSH
28236: EMPTY
28237: LIST
28238: LIST
28239: PUSH
28240: EMPTY
28241: LIST
28242: LIST
28243: LIST
28244: LIST
28245: LIST
28246: LIST
28247: LIST
28248: LIST
28249: LIST
28250: LIST
28251: LIST
28252: LIST
28253: LIST
28254: LIST
28255: LIST
28256: LIST
28257: LIST
28258: LIST
28259: LIST
28260: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28261: LD_ADDR_VAR 0 20
28265: PUSH
28266: LD_INT 0
28268: PUSH
28269: LD_INT 0
28271: PUSH
28272: EMPTY
28273: LIST
28274: LIST
28275: PUSH
28276: LD_INT 0
28278: PUSH
28279: LD_INT 1
28281: NEG
28282: PUSH
28283: EMPTY
28284: LIST
28285: LIST
28286: PUSH
28287: LD_INT 1
28289: PUSH
28290: LD_INT 0
28292: PUSH
28293: EMPTY
28294: LIST
28295: LIST
28296: PUSH
28297: LD_INT 1
28299: PUSH
28300: LD_INT 1
28302: PUSH
28303: EMPTY
28304: LIST
28305: LIST
28306: PUSH
28307: LD_INT 0
28309: PUSH
28310: LD_INT 1
28312: PUSH
28313: EMPTY
28314: LIST
28315: LIST
28316: PUSH
28317: LD_INT 1
28319: NEG
28320: PUSH
28321: LD_INT 0
28323: PUSH
28324: EMPTY
28325: LIST
28326: LIST
28327: PUSH
28328: LD_INT 1
28330: NEG
28331: PUSH
28332: LD_INT 1
28334: NEG
28335: PUSH
28336: EMPTY
28337: LIST
28338: LIST
28339: PUSH
28340: LD_INT 1
28342: NEG
28343: PUSH
28344: LD_INT 2
28346: NEG
28347: PUSH
28348: EMPTY
28349: LIST
28350: LIST
28351: PUSH
28352: LD_INT 0
28354: PUSH
28355: LD_INT 2
28357: NEG
28358: PUSH
28359: EMPTY
28360: LIST
28361: LIST
28362: PUSH
28363: LD_INT 1
28365: PUSH
28366: LD_INT 1
28368: NEG
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: PUSH
28374: LD_INT 2
28376: PUSH
28377: LD_INT 0
28379: PUSH
28380: EMPTY
28381: LIST
28382: LIST
28383: PUSH
28384: LD_INT 2
28386: PUSH
28387: LD_INT 1
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PUSH
28394: LD_INT 2
28396: PUSH
28397: LD_INT 2
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: PUSH
28404: LD_INT 1
28406: PUSH
28407: LD_INT 2
28409: PUSH
28410: EMPTY
28411: LIST
28412: LIST
28413: PUSH
28414: LD_INT 0
28416: PUSH
28417: LD_INT 2
28419: PUSH
28420: EMPTY
28421: LIST
28422: LIST
28423: PUSH
28424: LD_INT 1
28426: NEG
28427: PUSH
28428: LD_INT 1
28430: PUSH
28431: EMPTY
28432: LIST
28433: LIST
28434: PUSH
28435: LD_INT 2
28437: NEG
28438: PUSH
28439: LD_INT 0
28441: PUSH
28442: EMPTY
28443: LIST
28444: LIST
28445: PUSH
28446: LD_INT 2
28448: NEG
28449: PUSH
28450: LD_INT 1
28452: NEG
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: PUSH
28458: LD_INT 2
28460: NEG
28461: PUSH
28462: LD_INT 2
28464: NEG
28465: PUSH
28466: EMPTY
28467: LIST
28468: LIST
28469: PUSH
28470: EMPTY
28471: LIST
28472: LIST
28473: LIST
28474: LIST
28475: LIST
28476: LIST
28477: LIST
28478: LIST
28479: LIST
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: LIST
28489: LIST
28490: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28491: LD_ADDR_VAR 0 21
28495: PUSH
28496: LD_INT 0
28498: PUSH
28499: LD_INT 0
28501: PUSH
28502: EMPTY
28503: LIST
28504: LIST
28505: PUSH
28506: LD_INT 0
28508: PUSH
28509: LD_INT 1
28511: NEG
28512: PUSH
28513: EMPTY
28514: LIST
28515: LIST
28516: PUSH
28517: LD_INT 1
28519: PUSH
28520: LD_INT 0
28522: PUSH
28523: EMPTY
28524: LIST
28525: LIST
28526: PUSH
28527: LD_INT 1
28529: PUSH
28530: LD_INT 1
28532: PUSH
28533: EMPTY
28534: LIST
28535: LIST
28536: PUSH
28537: LD_INT 0
28539: PUSH
28540: LD_INT 1
28542: PUSH
28543: EMPTY
28544: LIST
28545: LIST
28546: PUSH
28547: LD_INT 1
28549: NEG
28550: PUSH
28551: LD_INT 0
28553: PUSH
28554: EMPTY
28555: LIST
28556: LIST
28557: PUSH
28558: LD_INT 1
28560: NEG
28561: PUSH
28562: LD_INT 1
28564: NEG
28565: PUSH
28566: EMPTY
28567: LIST
28568: LIST
28569: PUSH
28570: LD_INT 1
28572: NEG
28573: PUSH
28574: LD_INT 2
28576: NEG
28577: PUSH
28578: EMPTY
28579: LIST
28580: LIST
28581: PUSH
28582: LD_INT 0
28584: PUSH
28585: LD_INT 2
28587: NEG
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: PUSH
28593: LD_INT 1
28595: PUSH
28596: LD_INT 1
28598: NEG
28599: PUSH
28600: EMPTY
28601: LIST
28602: LIST
28603: PUSH
28604: LD_INT 2
28606: PUSH
28607: LD_INT 0
28609: PUSH
28610: EMPTY
28611: LIST
28612: LIST
28613: PUSH
28614: LD_INT 2
28616: PUSH
28617: LD_INT 1
28619: PUSH
28620: EMPTY
28621: LIST
28622: LIST
28623: PUSH
28624: LD_INT 2
28626: PUSH
28627: LD_INT 2
28629: PUSH
28630: EMPTY
28631: LIST
28632: LIST
28633: PUSH
28634: LD_INT 1
28636: PUSH
28637: LD_INT 2
28639: PUSH
28640: EMPTY
28641: LIST
28642: LIST
28643: PUSH
28644: LD_INT 0
28646: PUSH
28647: LD_INT 2
28649: PUSH
28650: EMPTY
28651: LIST
28652: LIST
28653: PUSH
28654: LD_INT 1
28656: NEG
28657: PUSH
28658: LD_INT 1
28660: PUSH
28661: EMPTY
28662: LIST
28663: LIST
28664: PUSH
28665: LD_INT 2
28667: NEG
28668: PUSH
28669: LD_INT 0
28671: PUSH
28672: EMPTY
28673: LIST
28674: LIST
28675: PUSH
28676: LD_INT 2
28678: NEG
28679: PUSH
28680: LD_INT 1
28682: NEG
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: LD_INT 2
28690: NEG
28691: PUSH
28692: LD_INT 2
28694: NEG
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: EMPTY
28701: LIST
28702: LIST
28703: LIST
28704: LIST
28705: LIST
28706: LIST
28707: LIST
28708: LIST
28709: LIST
28710: LIST
28711: LIST
28712: LIST
28713: LIST
28714: LIST
28715: LIST
28716: LIST
28717: LIST
28718: LIST
28719: LIST
28720: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28721: LD_ADDR_VAR 0 22
28725: PUSH
28726: LD_INT 0
28728: PUSH
28729: LD_INT 0
28731: PUSH
28732: EMPTY
28733: LIST
28734: LIST
28735: PUSH
28736: LD_INT 0
28738: PUSH
28739: LD_INT 1
28741: NEG
28742: PUSH
28743: EMPTY
28744: LIST
28745: LIST
28746: PUSH
28747: LD_INT 1
28749: PUSH
28750: LD_INT 0
28752: PUSH
28753: EMPTY
28754: LIST
28755: LIST
28756: PUSH
28757: LD_INT 1
28759: PUSH
28760: LD_INT 1
28762: PUSH
28763: EMPTY
28764: LIST
28765: LIST
28766: PUSH
28767: LD_INT 0
28769: PUSH
28770: LD_INT 1
28772: PUSH
28773: EMPTY
28774: LIST
28775: LIST
28776: PUSH
28777: LD_INT 1
28779: NEG
28780: PUSH
28781: LD_INT 0
28783: PUSH
28784: EMPTY
28785: LIST
28786: LIST
28787: PUSH
28788: LD_INT 1
28790: NEG
28791: PUSH
28792: LD_INT 1
28794: NEG
28795: PUSH
28796: EMPTY
28797: LIST
28798: LIST
28799: PUSH
28800: LD_INT 1
28802: NEG
28803: PUSH
28804: LD_INT 2
28806: NEG
28807: PUSH
28808: EMPTY
28809: LIST
28810: LIST
28811: PUSH
28812: LD_INT 0
28814: PUSH
28815: LD_INT 2
28817: NEG
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: PUSH
28823: LD_INT 1
28825: PUSH
28826: LD_INT 1
28828: NEG
28829: PUSH
28830: EMPTY
28831: LIST
28832: LIST
28833: PUSH
28834: LD_INT 2
28836: PUSH
28837: LD_INT 0
28839: PUSH
28840: EMPTY
28841: LIST
28842: LIST
28843: PUSH
28844: LD_INT 2
28846: PUSH
28847: LD_INT 1
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: PUSH
28854: LD_INT 2
28856: PUSH
28857: LD_INT 2
28859: PUSH
28860: EMPTY
28861: LIST
28862: LIST
28863: PUSH
28864: LD_INT 1
28866: PUSH
28867: LD_INT 2
28869: PUSH
28870: EMPTY
28871: LIST
28872: LIST
28873: PUSH
28874: LD_INT 0
28876: PUSH
28877: LD_INT 2
28879: PUSH
28880: EMPTY
28881: LIST
28882: LIST
28883: PUSH
28884: LD_INT 1
28886: NEG
28887: PUSH
28888: LD_INT 1
28890: PUSH
28891: EMPTY
28892: LIST
28893: LIST
28894: PUSH
28895: LD_INT 2
28897: NEG
28898: PUSH
28899: LD_INT 0
28901: PUSH
28902: EMPTY
28903: LIST
28904: LIST
28905: PUSH
28906: LD_INT 2
28908: NEG
28909: PUSH
28910: LD_INT 1
28912: NEG
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: PUSH
28918: LD_INT 2
28920: NEG
28921: PUSH
28922: LD_INT 2
28924: NEG
28925: PUSH
28926: EMPTY
28927: LIST
28928: LIST
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: LIST
28934: LIST
28935: LIST
28936: LIST
28937: LIST
28938: LIST
28939: LIST
28940: LIST
28941: LIST
28942: LIST
28943: LIST
28944: LIST
28945: LIST
28946: LIST
28947: LIST
28948: LIST
28949: LIST
28950: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
28951: LD_ADDR_VAR 0 23
28955: PUSH
28956: LD_INT 0
28958: PUSH
28959: LD_INT 0
28961: PUSH
28962: EMPTY
28963: LIST
28964: LIST
28965: PUSH
28966: LD_INT 0
28968: PUSH
28969: LD_INT 1
28971: NEG
28972: PUSH
28973: EMPTY
28974: LIST
28975: LIST
28976: PUSH
28977: LD_INT 1
28979: PUSH
28980: LD_INT 0
28982: PUSH
28983: EMPTY
28984: LIST
28985: LIST
28986: PUSH
28987: LD_INT 1
28989: PUSH
28990: LD_INT 1
28992: PUSH
28993: EMPTY
28994: LIST
28995: LIST
28996: PUSH
28997: LD_INT 0
28999: PUSH
29000: LD_INT 1
29002: PUSH
29003: EMPTY
29004: LIST
29005: LIST
29006: PUSH
29007: LD_INT 1
29009: NEG
29010: PUSH
29011: LD_INT 0
29013: PUSH
29014: EMPTY
29015: LIST
29016: LIST
29017: PUSH
29018: LD_INT 1
29020: NEG
29021: PUSH
29022: LD_INT 1
29024: NEG
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: LD_INT 1
29032: NEG
29033: PUSH
29034: LD_INT 2
29036: NEG
29037: PUSH
29038: EMPTY
29039: LIST
29040: LIST
29041: PUSH
29042: LD_INT 0
29044: PUSH
29045: LD_INT 2
29047: NEG
29048: PUSH
29049: EMPTY
29050: LIST
29051: LIST
29052: PUSH
29053: LD_INT 1
29055: PUSH
29056: LD_INT 1
29058: NEG
29059: PUSH
29060: EMPTY
29061: LIST
29062: LIST
29063: PUSH
29064: LD_INT 2
29066: PUSH
29067: LD_INT 0
29069: PUSH
29070: EMPTY
29071: LIST
29072: LIST
29073: PUSH
29074: LD_INT 2
29076: PUSH
29077: LD_INT 1
29079: PUSH
29080: EMPTY
29081: LIST
29082: LIST
29083: PUSH
29084: LD_INT 2
29086: PUSH
29087: LD_INT 2
29089: PUSH
29090: EMPTY
29091: LIST
29092: LIST
29093: PUSH
29094: LD_INT 1
29096: PUSH
29097: LD_INT 2
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PUSH
29104: LD_INT 0
29106: PUSH
29107: LD_INT 2
29109: PUSH
29110: EMPTY
29111: LIST
29112: LIST
29113: PUSH
29114: LD_INT 1
29116: NEG
29117: PUSH
29118: LD_INT 1
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: PUSH
29125: LD_INT 2
29127: NEG
29128: PUSH
29129: LD_INT 0
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: PUSH
29136: LD_INT 2
29138: NEG
29139: PUSH
29140: LD_INT 1
29142: NEG
29143: PUSH
29144: EMPTY
29145: LIST
29146: LIST
29147: PUSH
29148: LD_INT 2
29150: NEG
29151: PUSH
29152: LD_INT 2
29154: NEG
29155: PUSH
29156: EMPTY
29157: LIST
29158: LIST
29159: PUSH
29160: LD_INT 2
29162: NEG
29163: PUSH
29164: LD_INT 3
29166: NEG
29167: PUSH
29168: EMPTY
29169: LIST
29170: LIST
29171: PUSH
29172: LD_INT 1
29174: NEG
29175: PUSH
29176: LD_INT 3
29178: NEG
29179: PUSH
29180: EMPTY
29181: LIST
29182: LIST
29183: PUSH
29184: LD_INT 1
29186: PUSH
29187: LD_INT 2
29189: NEG
29190: PUSH
29191: EMPTY
29192: LIST
29193: LIST
29194: PUSH
29195: LD_INT 2
29197: PUSH
29198: LD_INT 1
29200: NEG
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: LIST
29220: LIST
29221: LIST
29222: LIST
29223: LIST
29224: LIST
29225: LIST
29226: LIST
29227: LIST
29228: LIST
29229: LIST
29230: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
29231: LD_ADDR_VAR 0 24
29235: PUSH
29236: LD_INT 0
29238: PUSH
29239: LD_INT 0
29241: PUSH
29242: EMPTY
29243: LIST
29244: LIST
29245: PUSH
29246: LD_INT 0
29248: PUSH
29249: LD_INT 1
29251: NEG
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: LD_INT 1
29259: PUSH
29260: LD_INT 0
29262: PUSH
29263: EMPTY
29264: LIST
29265: LIST
29266: PUSH
29267: LD_INT 1
29269: PUSH
29270: LD_INT 1
29272: PUSH
29273: EMPTY
29274: LIST
29275: LIST
29276: PUSH
29277: LD_INT 0
29279: PUSH
29280: LD_INT 1
29282: PUSH
29283: EMPTY
29284: LIST
29285: LIST
29286: PUSH
29287: LD_INT 1
29289: NEG
29290: PUSH
29291: LD_INT 0
29293: PUSH
29294: EMPTY
29295: LIST
29296: LIST
29297: PUSH
29298: LD_INT 1
29300: NEG
29301: PUSH
29302: LD_INT 1
29304: NEG
29305: PUSH
29306: EMPTY
29307: LIST
29308: LIST
29309: PUSH
29310: LD_INT 1
29312: NEG
29313: PUSH
29314: LD_INT 2
29316: NEG
29317: PUSH
29318: EMPTY
29319: LIST
29320: LIST
29321: PUSH
29322: LD_INT 0
29324: PUSH
29325: LD_INT 2
29327: NEG
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: PUSH
29333: LD_INT 1
29335: PUSH
29336: LD_INT 1
29338: NEG
29339: PUSH
29340: EMPTY
29341: LIST
29342: LIST
29343: PUSH
29344: LD_INT 2
29346: PUSH
29347: LD_INT 0
29349: PUSH
29350: EMPTY
29351: LIST
29352: LIST
29353: PUSH
29354: LD_INT 2
29356: PUSH
29357: LD_INT 1
29359: PUSH
29360: EMPTY
29361: LIST
29362: LIST
29363: PUSH
29364: LD_INT 2
29366: PUSH
29367: LD_INT 2
29369: PUSH
29370: EMPTY
29371: LIST
29372: LIST
29373: PUSH
29374: LD_INT 1
29376: PUSH
29377: LD_INT 2
29379: PUSH
29380: EMPTY
29381: LIST
29382: LIST
29383: PUSH
29384: LD_INT 0
29386: PUSH
29387: LD_INT 2
29389: PUSH
29390: EMPTY
29391: LIST
29392: LIST
29393: PUSH
29394: LD_INT 1
29396: NEG
29397: PUSH
29398: LD_INT 1
29400: PUSH
29401: EMPTY
29402: LIST
29403: LIST
29404: PUSH
29405: LD_INT 2
29407: NEG
29408: PUSH
29409: LD_INT 0
29411: PUSH
29412: EMPTY
29413: LIST
29414: LIST
29415: PUSH
29416: LD_INT 2
29418: NEG
29419: PUSH
29420: LD_INT 1
29422: NEG
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: LD_INT 2
29430: NEG
29431: PUSH
29432: LD_INT 2
29434: NEG
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 1
29442: PUSH
29443: LD_INT 2
29445: NEG
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 2
29453: PUSH
29454: LD_INT 1
29456: NEG
29457: PUSH
29458: EMPTY
29459: LIST
29460: LIST
29461: PUSH
29462: LD_INT 3
29464: PUSH
29465: LD_INT 1
29467: PUSH
29468: EMPTY
29469: LIST
29470: LIST
29471: PUSH
29472: LD_INT 3
29474: PUSH
29475: LD_INT 2
29477: PUSH
29478: EMPTY
29479: LIST
29480: LIST
29481: PUSH
29482: EMPTY
29483: LIST
29484: LIST
29485: LIST
29486: LIST
29487: LIST
29488: LIST
29489: LIST
29490: LIST
29491: LIST
29492: LIST
29493: LIST
29494: LIST
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: LIST
29501: LIST
29502: LIST
29503: LIST
29504: LIST
29505: LIST
29506: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
29507: LD_ADDR_VAR 0 25
29511: PUSH
29512: LD_INT 0
29514: PUSH
29515: LD_INT 0
29517: PUSH
29518: EMPTY
29519: LIST
29520: LIST
29521: PUSH
29522: LD_INT 0
29524: PUSH
29525: LD_INT 1
29527: NEG
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PUSH
29533: LD_INT 1
29535: PUSH
29536: LD_INT 0
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: PUSH
29543: LD_INT 1
29545: PUSH
29546: LD_INT 1
29548: PUSH
29549: EMPTY
29550: LIST
29551: LIST
29552: PUSH
29553: LD_INT 0
29555: PUSH
29556: LD_INT 1
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: PUSH
29563: LD_INT 1
29565: NEG
29566: PUSH
29567: LD_INT 0
29569: PUSH
29570: EMPTY
29571: LIST
29572: LIST
29573: PUSH
29574: LD_INT 1
29576: NEG
29577: PUSH
29578: LD_INT 1
29580: NEG
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 1
29588: NEG
29589: PUSH
29590: LD_INT 2
29592: NEG
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: PUSH
29598: LD_INT 0
29600: PUSH
29601: LD_INT 2
29603: NEG
29604: PUSH
29605: EMPTY
29606: LIST
29607: LIST
29608: PUSH
29609: LD_INT 1
29611: PUSH
29612: LD_INT 1
29614: NEG
29615: PUSH
29616: EMPTY
29617: LIST
29618: LIST
29619: PUSH
29620: LD_INT 2
29622: PUSH
29623: LD_INT 0
29625: PUSH
29626: EMPTY
29627: LIST
29628: LIST
29629: PUSH
29630: LD_INT 2
29632: PUSH
29633: LD_INT 1
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: PUSH
29640: LD_INT 2
29642: PUSH
29643: LD_INT 2
29645: PUSH
29646: EMPTY
29647: LIST
29648: LIST
29649: PUSH
29650: LD_INT 1
29652: PUSH
29653: LD_INT 2
29655: PUSH
29656: EMPTY
29657: LIST
29658: LIST
29659: PUSH
29660: LD_INT 0
29662: PUSH
29663: LD_INT 2
29665: PUSH
29666: EMPTY
29667: LIST
29668: LIST
29669: PUSH
29670: LD_INT 1
29672: NEG
29673: PUSH
29674: LD_INT 1
29676: PUSH
29677: EMPTY
29678: LIST
29679: LIST
29680: PUSH
29681: LD_INT 2
29683: NEG
29684: PUSH
29685: LD_INT 0
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: PUSH
29692: LD_INT 2
29694: NEG
29695: PUSH
29696: LD_INT 1
29698: NEG
29699: PUSH
29700: EMPTY
29701: LIST
29702: LIST
29703: PUSH
29704: LD_INT 2
29706: NEG
29707: PUSH
29708: LD_INT 2
29710: NEG
29711: PUSH
29712: EMPTY
29713: LIST
29714: LIST
29715: PUSH
29716: LD_INT 3
29718: PUSH
29719: LD_INT 1
29721: PUSH
29722: EMPTY
29723: LIST
29724: LIST
29725: PUSH
29726: LD_INT 3
29728: PUSH
29729: LD_INT 2
29731: PUSH
29732: EMPTY
29733: LIST
29734: LIST
29735: PUSH
29736: LD_INT 2
29738: PUSH
29739: LD_INT 3
29741: PUSH
29742: EMPTY
29743: LIST
29744: LIST
29745: PUSH
29746: LD_INT 1
29748: PUSH
29749: LD_INT 3
29751: PUSH
29752: EMPTY
29753: LIST
29754: LIST
29755: PUSH
29756: EMPTY
29757: LIST
29758: LIST
29759: LIST
29760: LIST
29761: LIST
29762: LIST
29763: LIST
29764: LIST
29765: LIST
29766: LIST
29767: LIST
29768: LIST
29769: LIST
29770: LIST
29771: LIST
29772: LIST
29773: LIST
29774: LIST
29775: LIST
29776: LIST
29777: LIST
29778: LIST
29779: LIST
29780: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
29781: LD_ADDR_VAR 0 26
29785: PUSH
29786: LD_INT 0
29788: PUSH
29789: LD_INT 0
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 0
29798: PUSH
29799: LD_INT 1
29801: NEG
29802: PUSH
29803: EMPTY
29804: LIST
29805: LIST
29806: PUSH
29807: LD_INT 1
29809: PUSH
29810: LD_INT 0
29812: PUSH
29813: EMPTY
29814: LIST
29815: LIST
29816: PUSH
29817: LD_INT 1
29819: PUSH
29820: LD_INT 1
29822: PUSH
29823: EMPTY
29824: LIST
29825: LIST
29826: PUSH
29827: LD_INT 0
29829: PUSH
29830: LD_INT 1
29832: PUSH
29833: EMPTY
29834: LIST
29835: LIST
29836: PUSH
29837: LD_INT 1
29839: NEG
29840: PUSH
29841: LD_INT 0
29843: PUSH
29844: EMPTY
29845: LIST
29846: LIST
29847: PUSH
29848: LD_INT 1
29850: NEG
29851: PUSH
29852: LD_INT 1
29854: NEG
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: LD_INT 1
29862: NEG
29863: PUSH
29864: LD_INT 2
29866: NEG
29867: PUSH
29868: EMPTY
29869: LIST
29870: LIST
29871: PUSH
29872: LD_INT 0
29874: PUSH
29875: LD_INT 2
29877: NEG
29878: PUSH
29879: EMPTY
29880: LIST
29881: LIST
29882: PUSH
29883: LD_INT 1
29885: PUSH
29886: LD_INT 1
29888: NEG
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 2
29896: PUSH
29897: LD_INT 0
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 2
29906: PUSH
29907: LD_INT 1
29909: PUSH
29910: EMPTY
29911: LIST
29912: LIST
29913: PUSH
29914: LD_INT 2
29916: PUSH
29917: LD_INT 2
29919: PUSH
29920: EMPTY
29921: LIST
29922: LIST
29923: PUSH
29924: LD_INT 1
29926: PUSH
29927: LD_INT 2
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PUSH
29934: LD_INT 0
29936: PUSH
29937: LD_INT 2
29939: PUSH
29940: EMPTY
29941: LIST
29942: LIST
29943: PUSH
29944: LD_INT 1
29946: NEG
29947: PUSH
29948: LD_INT 1
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 2
29957: NEG
29958: PUSH
29959: LD_INT 0
29961: PUSH
29962: EMPTY
29963: LIST
29964: LIST
29965: PUSH
29966: LD_INT 2
29968: NEG
29969: PUSH
29970: LD_INT 1
29972: NEG
29973: PUSH
29974: EMPTY
29975: LIST
29976: LIST
29977: PUSH
29978: LD_INT 2
29980: NEG
29981: PUSH
29982: LD_INT 2
29984: NEG
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: PUSH
29990: LD_INT 2
29992: PUSH
29993: LD_INT 3
29995: PUSH
29996: EMPTY
29997: LIST
29998: LIST
29999: PUSH
30000: LD_INT 1
30002: PUSH
30003: LD_INT 3
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: PUSH
30010: LD_INT 1
30012: NEG
30013: PUSH
30014: LD_INT 2
30016: PUSH
30017: EMPTY
30018: LIST
30019: LIST
30020: PUSH
30021: LD_INT 2
30023: NEG
30024: PUSH
30025: LD_INT 1
30027: PUSH
30028: EMPTY
30029: LIST
30030: LIST
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: LIST
30036: LIST
30037: LIST
30038: LIST
30039: LIST
30040: LIST
30041: LIST
30042: LIST
30043: LIST
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: LIST
30053: LIST
30054: LIST
30055: LIST
30056: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
30057: LD_ADDR_VAR 0 27
30061: PUSH
30062: LD_INT 0
30064: PUSH
30065: LD_INT 0
30067: PUSH
30068: EMPTY
30069: LIST
30070: LIST
30071: PUSH
30072: LD_INT 0
30074: PUSH
30075: LD_INT 1
30077: NEG
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PUSH
30083: LD_INT 1
30085: PUSH
30086: LD_INT 0
30088: PUSH
30089: EMPTY
30090: LIST
30091: LIST
30092: PUSH
30093: LD_INT 1
30095: PUSH
30096: LD_INT 1
30098: PUSH
30099: EMPTY
30100: LIST
30101: LIST
30102: PUSH
30103: LD_INT 0
30105: PUSH
30106: LD_INT 1
30108: PUSH
30109: EMPTY
30110: LIST
30111: LIST
30112: PUSH
30113: LD_INT 1
30115: NEG
30116: PUSH
30117: LD_INT 0
30119: PUSH
30120: EMPTY
30121: LIST
30122: LIST
30123: PUSH
30124: LD_INT 1
30126: NEG
30127: PUSH
30128: LD_INT 1
30130: NEG
30131: PUSH
30132: EMPTY
30133: LIST
30134: LIST
30135: PUSH
30136: LD_INT 1
30138: NEG
30139: PUSH
30140: LD_INT 2
30142: NEG
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: LD_INT 0
30150: PUSH
30151: LD_INT 2
30153: NEG
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: LD_INT 1
30161: PUSH
30162: LD_INT 1
30164: NEG
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 2
30172: PUSH
30173: LD_INT 0
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 2
30182: PUSH
30183: LD_INT 1
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 2
30192: PUSH
30193: LD_INT 2
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 1
30202: PUSH
30203: LD_INT 2
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 0
30212: PUSH
30213: LD_INT 2
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: PUSH
30220: LD_INT 1
30222: NEG
30223: PUSH
30224: LD_INT 1
30226: PUSH
30227: EMPTY
30228: LIST
30229: LIST
30230: PUSH
30231: LD_INT 2
30233: NEG
30234: PUSH
30235: LD_INT 0
30237: PUSH
30238: EMPTY
30239: LIST
30240: LIST
30241: PUSH
30242: LD_INT 2
30244: NEG
30245: PUSH
30246: LD_INT 1
30248: NEG
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: LD_INT 2
30256: NEG
30257: PUSH
30258: LD_INT 2
30260: NEG
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: LD_INT 1
30268: NEG
30269: PUSH
30270: LD_INT 2
30272: PUSH
30273: EMPTY
30274: LIST
30275: LIST
30276: PUSH
30277: LD_INT 2
30279: NEG
30280: PUSH
30281: LD_INT 1
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: LD_INT 3
30290: NEG
30291: PUSH
30292: LD_INT 1
30294: NEG
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 3
30302: NEG
30303: PUSH
30304: LD_INT 2
30306: NEG
30307: PUSH
30308: EMPTY
30309: LIST
30310: LIST
30311: PUSH
30312: EMPTY
30313: LIST
30314: LIST
30315: LIST
30316: LIST
30317: LIST
30318: LIST
30319: LIST
30320: LIST
30321: LIST
30322: LIST
30323: LIST
30324: LIST
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: LIST
30336: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
30337: LD_ADDR_VAR 0 28
30341: PUSH
30342: LD_INT 0
30344: PUSH
30345: LD_INT 0
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 0
30354: PUSH
30355: LD_INT 1
30357: NEG
30358: PUSH
30359: EMPTY
30360: LIST
30361: LIST
30362: PUSH
30363: LD_INT 1
30365: PUSH
30366: LD_INT 0
30368: PUSH
30369: EMPTY
30370: LIST
30371: LIST
30372: PUSH
30373: LD_INT 1
30375: PUSH
30376: LD_INT 1
30378: PUSH
30379: EMPTY
30380: LIST
30381: LIST
30382: PUSH
30383: LD_INT 0
30385: PUSH
30386: LD_INT 1
30388: PUSH
30389: EMPTY
30390: LIST
30391: LIST
30392: PUSH
30393: LD_INT 1
30395: NEG
30396: PUSH
30397: LD_INT 0
30399: PUSH
30400: EMPTY
30401: LIST
30402: LIST
30403: PUSH
30404: LD_INT 1
30406: NEG
30407: PUSH
30408: LD_INT 1
30410: NEG
30411: PUSH
30412: EMPTY
30413: LIST
30414: LIST
30415: PUSH
30416: LD_INT 1
30418: NEG
30419: PUSH
30420: LD_INT 2
30422: NEG
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PUSH
30428: LD_INT 0
30430: PUSH
30431: LD_INT 2
30433: NEG
30434: PUSH
30435: EMPTY
30436: LIST
30437: LIST
30438: PUSH
30439: LD_INT 1
30441: PUSH
30442: LD_INT 1
30444: NEG
30445: PUSH
30446: EMPTY
30447: LIST
30448: LIST
30449: PUSH
30450: LD_INT 2
30452: PUSH
30453: LD_INT 0
30455: PUSH
30456: EMPTY
30457: LIST
30458: LIST
30459: PUSH
30460: LD_INT 2
30462: PUSH
30463: LD_INT 1
30465: PUSH
30466: EMPTY
30467: LIST
30468: LIST
30469: PUSH
30470: LD_INT 2
30472: PUSH
30473: LD_INT 2
30475: PUSH
30476: EMPTY
30477: LIST
30478: LIST
30479: PUSH
30480: LD_INT 1
30482: PUSH
30483: LD_INT 2
30485: PUSH
30486: EMPTY
30487: LIST
30488: LIST
30489: PUSH
30490: LD_INT 0
30492: PUSH
30493: LD_INT 2
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 1
30502: NEG
30503: PUSH
30504: LD_INT 1
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 2
30513: NEG
30514: PUSH
30515: LD_INT 0
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: PUSH
30522: LD_INT 2
30524: NEG
30525: PUSH
30526: LD_INT 1
30528: NEG
30529: PUSH
30530: EMPTY
30531: LIST
30532: LIST
30533: PUSH
30534: LD_INT 2
30536: NEG
30537: PUSH
30538: LD_INT 2
30540: NEG
30541: PUSH
30542: EMPTY
30543: LIST
30544: LIST
30545: PUSH
30546: LD_INT 2
30548: NEG
30549: PUSH
30550: LD_INT 3
30552: NEG
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: LD_INT 1
30560: NEG
30561: PUSH
30562: LD_INT 3
30564: NEG
30565: PUSH
30566: EMPTY
30567: LIST
30568: LIST
30569: PUSH
30570: LD_INT 3
30572: NEG
30573: PUSH
30574: LD_INT 1
30576: NEG
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 3
30584: NEG
30585: PUSH
30586: LD_INT 2
30588: NEG
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: LIST
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: LIST
30605: LIST
30606: LIST
30607: LIST
30608: LIST
30609: LIST
30610: LIST
30611: LIST
30612: LIST
30613: LIST
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30619: LD_ADDR_VAR 0 29
30623: PUSH
30624: LD_INT 0
30626: PUSH
30627: LD_INT 0
30629: PUSH
30630: EMPTY
30631: LIST
30632: LIST
30633: PUSH
30634: LD_INT 0
30636: PUSH
30637: LD_INT 1
30639: NEG
30640: PUSH
30641: EMPTY
30642: LIST
30643: LIST
30644: PUSH
30645: LD_INT 1
30647: PUSH
30648: LD_INT 0
30650: PUSH
30651: EMPTY
30652: LIST
30653: LIST
30654: PUSH
30655: LD_INT 1
30657: PUSH
30658: LD_INT 1
30660: PUSH
30661: EMPTY
30662: LIST
30663: LIST
30664: PUSH
30665: LD_INT 0
30667: PUSH
30668: LD_INT 1
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: PUSH
30675: LD_INT 1
30677: NEG
30678: PUSH
30679: LD_INT 0
30681: PUSH
30682: EMPTY
30683: LIST
30684: LIST
30685: PUSH
30686: LD_INT 1
30688: NEG
30689: PUSH
30690: LD_INT 1
30692: NEG
30693: PUSH
30694: EMPTY
30695: LIST
30696: LIST
30697: PUSH
30698: LD_INT 1
30700: NEG
30701: PUSH
30702: LD_INT 2
30704: NEG
30705: PUSH
30706: EMPTY
30707: LIST
30708: LIST
30709: PUSH
30710: LD_INT 0
30712: PUSH
30713: LD_INT 2
30715: NEG
30716: PUSH
30717: EMPTY
30718: LIST
30719: LIST
30720: PUSH
30721: LD_INT 1
30723: PUSH
30724: LD_INT 1
30726: NEG
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 2
30734: PUSH
30735: LD_INT 0
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 2
30744: PUSH
30745: LD_INT 1
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: LD_INT 1
30754: PUSH
30755: LD_INT 2
30757: PUSH
30758: EMPTY
30759: LIST
30760: LIST
30761: PUSH
30762: LD_INT 0
30764: PUSH
30765: LD_INT 2
30767: PUSH
30768: EMPTY
30769: LIST
30770: LIST
30771: PUSH
30772: LD_INT 1
30774: NEG
30775: PUSH
30776: LD_INT 1
30778: PUSH
30779: EMPTY
30780: LIST
30781: LIST
30782: PUSH
30783: LD_INT 2
30785: NEG
30786: PUSH
30787: LD_INT 1
30789: NEG
30790: PUSH
30791: EMPTY
30792: LIST
30793: LIST
30794: PUSH
30795: LD_INT 2
30797: NEG
30798: PUSH
30799: LD_INT 2
30801: NEG
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PUSH
30807: LD_INT 2
30809: NEG
30810: PUSH
30811: LD_INT 3
30813: NEG
30814: PUSH
30815: EMPTY
30816: LIST
30817: LIST
30818: PUSH
30819: LD_INT 2
30821: PUSH
30822: LD_INT 1
30824: NEG
30825: PUSH
30826: EMPTY
30827: LIST
30828: LIST
30829: PUSH
30830: LD_INT 3
30832: PUSH
30833: LD_INT 1
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: PUSH
30840: LD_INT 1
30842: PUSH
30843: LD_INT 3
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 1
30852: NEG
30853: PUSH
30854: LD_INT 2
30856: PUSH
30857: EMPTY
30858: LIST
30859: LIST
30860: PUSH
30861: LD_INT 3
30863: NEG
30864: PUSH
30865: LD_INT 2
30867: NEG
30868: PUSH
30869: EMPTY
30870: LIST
30871: LIST
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: LIST
30877: LIST
30878: LIST
30879: LIST
30880: LIST
30881: LIST
30882: LIST
30883: LIST
30884: LIST
30885: LIST
30886: LIST
30887: LIST
30888: LIST
30889: LIST
30890: LIST
30891: LIST
30892: LIST
30893: LIST
30894: LIST
30895: LIST
30896: LIST
30897: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30898: LD_ADDR_VAR 0 30
30902: PUSH
30903: LD_INT 0
30905: PUSH
30906: LD_INT 0
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 0
30915: PUSH
30916: LD_INT 1
30918: NEG
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: PUSH
30924: LD_INT 1
30926: PUSH
30927: LD_INT 0
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: LD_INT 1
30936: PUSH
30937: LD_INT 1
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 0
30946: PUSH
30947: LD_INT 1
30949: PUSH
30950: EMPTY
30951: LIST
30952: LIST
30953: PUSH
30954: LD_INT 1
30956: NEG
30957: PUSH
30958: LD_INT 0
30960: PUSH
30961: EMPTY
30962: LIST
30963: LIST
30964: PUSH
30965: LD_INT 1
30967: NEG
30968: PUSH
30969: LD_INT 1
30971: NEG
30972: PUSH
30973: EMPTY
30974: LIST
30975: LIST
30976: PUSH
30977: LD_INT 1
30979: NEG
30980: PUSH
30981: LD_INT 2
30983: NEG
30984: PUSH
30985: EMPTY
30986: LIST
30987: LIST
30988: PUSH
30989: LD_INT 0
30991: PUSH
30992: LD_INT 2
30994: NEG
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: LD_INT 1
31002: PUSH
31003: LD_INT 1
31005: NEG
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: PUSH
31011: LD_INT 2
31013: PUSH
31014: LD_INT 0
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PUSH
31021: LD_INT 2
31023: PUSH
31024: LD_INT 1
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 2
31033: PUSH
31034: LD_INT 2
31036: PUSH
31037: EMPTY
31038: LIST
31039: LIST
31040: PUSH
31041: LD_INT 1
31043: PUSH
31044: LD_INT 2
31046: PUSH
31047: EMPTY
31048: LIST
31049: LIST
31050: PUSH
31051: LD_INT 1
31053: NEG
31054: PUSH
31055: LD_INT 1
31057: PUSH
31058: EMPTY
31059: LIST
31060: LIST
31061: PUSH
31062: LD_INT 2
31064: NEG
31065: PUSH
31066: LD_INT 0
31068: PUSH
31069: EMPTY
31070: LIST
31071: LIST
31072: PUSH
31073: LD_INT 2
31075: NEG
31076: PUSH
31077: LD_INT 1
31079: NEG
31080: PUSH
31081: EMPTY
31082: LIST
31083: LIST
31084: PUSH
31085: LD_INT 1
31087: NEG
31088: PUSH
31089: LD_INT 3
31091: NEG
31092: PUSH
31093: EMPTY
31094: LIST
31095: LIST
31096: PUSH
31097: LD_INT 1
31099: PUSH
31100: LD_INT 2
31102: NEG
31103: PUSH
31104: EMPTY
31105: LIST
31106: LIST
31107: PUSH
31108: LD_INT 3
31110: PUSH
31111: LD_INT 2
31113: PUSH
31114: EMPTY
31115: LIST
31116: LIST
31117: PUSH
31118: LD_INT 2
31120: PUSH
31121: LD_INT 3
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 2
31130: NEG
31131: PUSH
31132: LD_INT 1
31134: PUSH
31135: EMPTY
31136: LIST
31137: LIST
31138: PUSH
31139: LD_INT 3
31141: NEG
31142: PUSH
31143: LD_INT 1
31145: NEG
31146: PUSH
31147: EMPTY
31148: LIST
31149: LIST
31150: PUSH
31151: EMPTY
31152: LIST
31153: LIST
31154: LIST
31155: LIST
31156: LIST
31157: LIST
31158: LIST
31159: LIST
31160: LIST
31161: LIST
31162: LIST
31163: LIST
31164: LIST
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: LIST
31170: LIST
31171: LIST
31172: LIST
31173: LIST
31174: LIST
31175: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31176: LD_ADDR_VAR 0 31
31180: PUSH
31181: LD_INT 0
31183: PUSH
31184: LD_INT 0
31186: PUSH
31187: EMPTY
31188: LIST
31189: LIST
31190: PUSH
31191: LD_INT 0
31193: PUSH
31194: LD_INT 1
31196: NEG
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 1
31204: PUSH
31205: LD_INT 0
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: LD_INT 1
31214: PUSH
31215: LD_INT 1
31217: PUSH
31218: EMPTY
31219: LIST
31220: LIST
31221: PUSH
31222: LD_INT 0
31224: PUSH
31225: LD_INT 1
31227: PUSH
31228: EMPTY
31229: LIST
31230: LIST
31231: PUSH
31232: LD_INT 1
31234: NEG
31235: PUSH
31236: LD_INT 0
31238: PUSH
31239: EMPTY
31240: LIST
31241: LIST
31242: PUSH
31243: LD_INT 1
31245: NEG
31246: PUSH
31247: LD_INT 1
31249: NEG
31250: PUSH
31251: EMPTY
31252: LIST
31253: LIST
31254: PUSH
31255: LD_INT 1
31257: NEG
31258: PUSH
31259: LD_INT 2
31261: NEG
31262: PUSH
31263: EMPTY
31264: LIST
31265: LIST
31266: PUSH
31267: LD_INT 1
31269: PUSH
31270: LD_INT 1
31272: NEG
31273: PUSH
31274: EMPTY
31275: LIST
31276: LIST
31277: PUSH
31278: LD_INT 2
31280: PUSH
31281: LD_INT 0
31283: PUSH
31284: EMPTY
31285: LIST
31286: LIST
31287: PUSH
31288: LD_INT 2
31290: PUSH
31291: LD_INT 1
31293: PUSH
31294: EMPTY
31295: LIST
31296: LIST
31297: PUSH
31298: LD_INT 2
31300: PUSH
31301: LD_INT 2
31303: PUSH
31304: EMPTY
31305: LIST
31306: LIST
31307: PUSH
31308: LD_INT 1
31310: PUSH
31311: LD_INT 2
31313: PUSH
31314: EMPTY
31315: LIST
31316: LIST
31317: PUSH
31318: LD_INT 0
31320: PUSH
31321: LD_INT 2
31323: PUSH
31324: EMPTY
31325: LIST
31326: LIST
31327: PUSH
31328: LD_INT 1
31330: NEG
31331: PUSH
31332: LD_INT 1
31334: PUSH
31335: EMPTY
31336: LIST
31337: LIST
31338: PUSH
31339: LD_INT 2
31341: NEG
31342: PUSH
31343: LD_INT 1
31345: NEG
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 2
31353: NEG
31354: PUSH
31355: LD_INT 2
31357: NEG
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 2
31365: NEG
31366: PUSH
31367: LD_INT 3
31369: NEG
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 2
31377: PUSH
31378: LD_INT 1
31380: NEG
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: LD_INT 3
31388: PUSH
31389: LD_INT 1
31391: PUSH
31392: EMPTY
31393: LIST
31394: LIST
31395: PUSH
31396: LD_INT 1
31398: PUSH
31399: LD_INT 3
31401: PUSH
31402: EMPTY
31403: LIST
31404: LIST
31405: PUSH
31406: LD_INT 1
31408: NEG
31409: PUSH
31410: LD_INT 2
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: PUSH
31417: LD_INT 3
31419: NEG
31420: PUSH
31421: LD_INT 2
31423: NEG
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: LIST
31433: LIST
31434: LIST
31435: LIST
31436: LIST
31437: LIST
31438: LIST
31439: LIST
31440: LIST
31441: LIST
31442: LIST
31443: LIST
31444: LIST
31445: LIST
31446: LIST
31447: LIST
31448: LIST
31449: LIST
31450: LIST
31451: LIST
31452: LIST
31453: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31454: LD_ADDR_VAR 0 32
31458: PUSH
31459: LD_INT 0
31461: PUSH
31462: LD_INT 0
31464: PUSH
31465: EMPTY
31466: LIST
31467: LIST
31468: PUSH
31469: LD_INT 0
31471: PUSH
31472: LD_INT 1
31474: NEG
31475: PUSH
31476: EMPTY
31477: LIST
31478: LIST
31479: PUSH
31480: LD_INT 1
31482: PUSH
31483: LD_INT 0
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: PUSH
31490: LD_INT 1
31492: PUSH
31493: LD_INT 1
31495: PUSH
31496: EMPTY
31497: LIST
31498: LIST
31499: PUSH
31500: LD_INT 0
31502: PUSH
31503: LD_INT 1
31505: PUSH
31506: EMPTY
31507: LIST
31508: LIST
31509: PUSH
31510: LD_INT 1
31512: NEG
31513: PUSH
31514: LD_INT 0
31516: PUSH
31517: EMPTY
31518: LIST
31519: LIST
31520: PUSH
31521: LD_INT 1
31523: NEG
31524: PUSH
31525: LD_INT 1
31527: NEG
31528: PUSH
31529: EMPTY
31530: LIST
31531: LIST
31532: PUSH
31533: LD_INT 1
31535: NEG
31536: PUSH
31537: LD_INT 2
31539: NEG
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 0
31547: PUSH
31548: LD_INT 2
31550: NEG
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: LD_INT 1
31558: PUSH
31559: LD_INT 1
31561: NEG
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 2
31569: PUSH
31570: LD_INT 1
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: LD_INT 2
31579: PUSH
31580: LD_INT 2
31582: PUSH
31583: EMPTY
31584: LIST
31585: LIST
31586: PUSH
31587: LD_INT 1
31589: PUSH
31590: LD_INT 2
31592: PUSH
31593: EMPTY
31594: LIST
31595: LIST
31596: PUSH
31597: LD_INT 0
31599: PUSH
31600: LD_INT 2
31602: PUSH
31603: EMPTY
31604: LIST
31605: LIST
31606: PUSH
31607: LD_INT 1
31609: NEG
31610: PUSH
31611: LD_INT 1
31613: PUSH
31614: EMPTY
31615: LIST
31616: LIST
31617: PUSH
31618: LD_INT 2
31620: NEG
31621: PUSH
31622: LD_INT 0
31624: PUSH
31625: EMPTY
31626: LIST
31627: LIST
31628: PUSH
31629: LD_INT 2
31631: NEG
31632: PUSH
31633: LD_INT 1
31635: NEG
31636: PUSH
31637: EMPTY
31638: LIST
31639: LIST
31640: PUSH
31641: LD_INT 1
31643: NEG
31644: PUSH
31645: LD_INT 3
31647: NEG
31648: PUSH
31649: EMPTY
31650: LIST
31651: LIST
31652: PUSH
31653: LD_INT 1
31655: PUSH
31656: LD_INT 2
31658: NEG
31659: PUSH
31660: EMPTY
31661: LIST
31662: LIST
31663: PUSH
31664: LD_INT 3
31666: PUSH
31667: LD_INT 2
31669: PUSH
31670: EMPTY
31671: LIST
31672: LIST
31673: PUSH
31674: LD_INT 2
31676: PUSH
31677: LD_INT 3
31679: PUSH
31680: EMPTY
31681: LIST
31682: LIST
31683: PUSH
31684: LD_INT 2
31686: NEG
31687: PUSH
31688: LD_INT 1
31690: PUSH
31691: EMPTY
31692: LIST
31693: LIST
31694: PUSH
31695: LD_INT 3
31697: NEG
31698: PUSH
31699: LD_INT 1
31701: NEG
31702: PUSH
31703: EMPTY
31704: LIST
31705: LIST
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: LIST
31711: LIST
31712: LIST
31713: LIST
31714: LIST
31715: LIST
31716: LIST
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31732: LD_ADDR_VAR 0 33
31736: PUSH
31737: LD_INT 0
31739: PUSH
31740: LD_INT 0
31742: PUSH
31743: EMPTY
31744: LIST
31745: LIST
31746: PUSH
31747: LD_INT 0
31749: PUSH
31750: LD_INT 1
31752: NEG
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 1
31760: PUSH
31761: LD_INT 0
31763: PUSH
31764: EMPTY
31765: LIST
31766: LIST
31767: PUSH
31768: LD_INT 1
31770: PUSH
31771: LD_INT 1
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: LD_INT 0
31780: PUSH
31781: LD_INT 1
31783: PUSH
31784: EMPTY
31785: LIST
31786: LIST
31787: PUSH
31788: LD_INT 1
31790: NEG
31791: PUSH
31792: LD_INT 0
31794: PUSH
31795: EMPTY
31796: LIST
31797: LIST
31798: PUSH
31799: LD_INT 1
31801: NEG
31802: PUSH
31803: LD_INT 1
31805: NEG
31806: PUSH
31807: EMPTY
31808: LIST
31809: LIST
31810: PUSH
31811: LD_INT 1
31813: NEG
31814: PUSH
31815: LD_INT 2
31817: NEG
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 1
31825: PUSH
31826: LD_INT 1
31828: NEG
31829: PUSH
31830: EMPTY
31831: LIST
31832: LIST
31833: PUSH
31834: LD_INT 2
31836: PUSH
31837: LD_INT 0
31839: PUSH
31840: EMPTY
31841: LIST
31842: LIST
31843: PUSH
31844: LD_INT 2
31846: PUSH
31847: LD_INT 1
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 1
31856: PUSH
31857: LD_INT 2
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PUSH
31864: LD_INT 0
31866: PUSH
31867: LD_INT 2
31869: PUSH
31870: EMPTY
31871: LIST
31872: LIST
31873: PUSH
31874: LD_INT 1
31876: NEG
31877: PUSH
31878: LD_INT 1
31880: PUSH
31881: EMPTY
31882: LIST
31883: LIST
31884: PUSH
31885: LD_INT 2
31887: NEG
31888: PUSH
31889: LD_INT 0
31891: PUSH
31892: EMPTY
31893: LIST
31894: LIST
31895: PUSH
31896: LD_INT 2
31898: NEG
31899: PUSH
31900: LD_INT 1
31902: NEG
31903: PUSH
31904: EMPTY
31905: LIST
31906: LIST
31907: PUSH
31908: LD_INT 2
31910: NEG
31911: PUSH
31912: LD_INT 2
31914: NEG
31915: PUSH
31916: EMPTY
31917: LIST
31918: LIST
31919: PUSH
31920: LD_INT 2
31922: NEG
31923: PUSH
31924: LD_INT 3
31926: NEG
31927: PUSH
31928: EMPTY
31929: LIST
31930: LIST
31931: PUSH
31932: LD_INT 2
31934: PUSH
31935: LD_INT 1
31937: NEG
31938: PUSH
31939: EMPTY
31940: LIST
31941: LIST
31942: PUSH
31943: LD_INT 3
31945: PUSH
31946: LD_INT 1
31948: PUSH
31949: EMPTY
31950: LIST
31951: LIST
31952: PUSH
31953: LD_INT 1
31955: PUSH
31956: LD_INT 3
31958: PUSH
31959: EMPTY
31960: LIST
31961: LIST
31962: PUSH
31963: LD_INT 1
31965: NEG
31966: PUSH
31967: LD_INT 2
31969: PUSH
31970: EMPTY
31971: LIST
31972: LIST
31973: PUSH
31974: LD_INT 3
31976: NEG
31977: PUSH
31978: LD_INT 2
31980: NEG
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: EMPTY
31987: LIST
31988: LIST
31989: LIST
31990: LIST
31991: LIST
31992: LIST
31993: LIST
31994: LIST
31995: LIST
31996: LIST
31997: LIST
31998: LIST
31999: LIST
32000: LIST
32001: LIST
32002: LIST
32003: LIST
32004: LIST
32005: LIST
32006: LIST
32007: LIST
32008: LIST
32009: LIST
32010: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32011: LD_ADDR_VAR 0 34
32015: PUSH
32016: LD_INT 0
32018: PUSH
32019: LD_INT 0
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 0
32028: PUSH
32029: LD_INT 1
32031: NEG
32032: PUSH
32033: EMPTY
32034: LIST
32035: LIST
32036: PUSH
32037: LD_INT 1
32039: PUSH
32040: LD_INT 0
32042: PUSH
32043: EMPTY
32044: LIST
32045: LIST
32046: PUSH
32047: LD_INT 1
32049: PUSH
32050: LD_INT 1
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: PUSH
32057: LD_INT 0
32059: PUSH
32060: LD_INT 1
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 1
32069: NEG
32070: PUSH
32071: LD_INT 0
32073: PUSH
32074: EMPTY
32075: LIST
32076: LIST
32077: PUSH
32078: LD_INT 1
32080: NEG
32081: PUSH
32082: LD_INT 1
32084: NEG
32085: PUSH
32086: EMPTY
32087: LIST
32088: LIST
32089: PUSH
32090: LD_INT 1
32092: NEG
32093: PUSH
32094: LD_INT 2
32096: NEG
32097: PUSH
32098: EMPTY
32099: LIST
32100: LIST
32101: PUSH
32102: LD_INT 0
32104: PUSH
32105: LD_INT 2
32107: NEG
32108: PUSH
32109: EMPTY
32110: LIST
32111: LIST
32112: PUSH
32113: LD_INT 1
32115: PUSH
32116: LD_INT 1
32118: NEG
32119: PUSH
32120: EMPTY
32121: LIST
32122: LIST
32123: PUSH
32124: LD_INT 2
32126: PUSH
32127: LD_INT 1
32129: PUSH
32130: EMPTY
32131: LIST
32132: LIST
32133: PUSH
32134: LD_INT 2
32136: PUSH
32137: LD_INT 2
32139: PUSH
32140: EMPTY
32141: LIST
32142: LIST
32143: PUSH
32144: LD_INT 1
32146: PUSH
32147: LD_INT 2
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: LD_INT 1
32156: NEG
32157: PUSH
32158: LD_INT 1
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: PUSH
32165: LD_INT 2
32167: NEG
32168: PUSH
32169: LD_INT 0
32171: PUSH
32172: EMPTY
32173: LIST
32174: LIST
32175: PUSH
32176: LD_INT 2
32178: NEG
32179: PUSH
32180: LD_INT 1
32182: NEG
32183: PUSH
32184: EMPTY
32185: LIST
32186: LIST
32187: PUSH
32188: LD_INT 2
32190: NEG
32191: PUSH
32192: LD_INT 2
32194: NEG
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 1
32202: NEG
32203: PUSH
32204: LD_INT 3
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 1
32214: PUSH
32215: LD_INT 2
32217: NEG
32218: PUSH
32219: EMPTY
32220: LIST
32221: LIST
32222: PUSH
32223: LD_INT 3
32225: PUSH
32226: LD_INT 2
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: PUSH
32233: LD_INT 2
32235: PUSH
32236: LD_INT 3
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 2
32245: NEG
32246: PUSH
32247: LD_INT 1
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 3
32256: NEG
32257: PUSH
32258: LD_INT 1
32260: NEG
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: LIST
32270: LIST
32271: LIST
32272: LIST
32273: LIST
32274: LIST
32275: LIST
32276: LIST
32277: LIST
32278: LIST
32279: LIST
32280: LIST
32281: LIST
32282: LIST
32283: LIST
32284: LIST
32285: LIST
32286: LIST
32287: LIST
32288: LIST
32289: LIST
32290: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
32291: LD_ADDR_VAR 0 35
32295: PUSH
32296: LD_INT 0
32298: PUSH
32299: LD_INT 0
32301: PUSH
32302: EMPTY
32303: LIST
32304: LIST
32305: PUSH
32306: LD_INT 0
32308: PUSH
32309: LD_INT 1
32311: NEG
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: PUSH
32317: LD_INT 1
32319: PUSH
32320: LD_INT 0
32322: PUSH
32323: EMPTY
32324: LIST
32325: LIST
32326: PUSH
32327: LD_INT 1
32329: PUSH
32330: LD_INT 1
32332: PUSH
32333: EMPTY
32334: LIST
32335: LIST
32336: PUSH
32337: LD_INT 0
32339: PUSH
32340: LD_INT 1
32342: PUSH
32343: EMPTY
32344: LIST
32345: LIST
32346: PUSH
32347: LD_INT 1
32349: NEG
32350: PUSH
32351: LD_INT 0
32353: PUSH
32354: EMPTY
32355: LIST
32356: LIST
32357: PUSH
32358: LD_INT 1
32360: NEG
32361: PUSH
32362: LD_INT 1
32364: NEG
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 2
32372: PUSH
32373: LD_INT 1
32375: PUSH
32376: EMPTY
32377: LIST
32378: LIST
32379: PUSH
32380: LD_INT 2
32382: NEG
32383: PUSH
32384: LD_INT 1
32386: NEG
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: LIST
32401: LIST
32402: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
32403: LD_ADDR_VAR 0 36
32407: PUSH
32408: LD_INT 0
32410: PUSH
32411: LD_INT 0
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 0
32420: PUSH
32421: LD_INT 1
32423: NEG
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 1
32431: PUSH
32432: LD_INT 0
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: LD_INT 1
32441: PUSH
32442: LD_INT 1
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: LD_INT 0
32451: PUSH
32452: LD_INT 1
32454: PUSH
32455: EMPTY
32456: LIST
32457: LIST
32458: PUSH
32459: LD_INT 1
32461: NEG
32462: PUSH
32463: LD_INT 0
32465: PUSH
32466: EMPTY
32467: LIST
32468: LIST
32469: PUSH
32470: LD_INT 1
32472: NEG
32473: PUSH
32474: LD_INT 1
32476: NEG
32477: PUSH
32478: EMPTY
32479: LIST
32480: LIST
32481: PUSH
32482: LD_INT 1
32484: NEG
32485: PUSH
32486: LD_INT 2
32488: NEG
32489: PUSH
32490: EMPTY
32491: LIST
32492: LIST
32493: PUSH
32494: LD_INT 1
32496: PUSH
32497: LD_INT 2
32499: PUSH
32500: EMPTY
32501: LIST
32502: LIST
32503: PUSH
32504: EMPTY
32505: LIST
32506: LIST
32507: LIST
32508: LIST
32509: LIST
32510: LIST
32511: LIST
32512: LIST
32513: LIST
32514: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
32515: LD_ADDR_VAR 0 37
32519: PUSH
32520: LD_INT 0
32522: PUSH
32523: LD_INT 0
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 0
32532: PUSH
32533: LD_INT 1
32535: NEG
32536: PUSH
32537: EMPTY
32538: LIST
32539: LIST
32540: PUSH
32541: LD_INT 1
32543: PUSH
32544: LD_INT 0
32546: PUSH
32547: EMPTY
32548: LIST
32549: LIST
32550: PUSH
32551: LD_INT 1
32553: PUSH
32554: LD_INT 1
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 0
32563: PUSH
32564: LD_INT 1
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PUSH
32571: LD_INT 1
32573: NEG
32574: PUSH
32575: LD_INT 0
32577: PUSH
32578: EMPTY
32579: LIST
32580: LIST
32581: PUSH
32582: LD_INT 1
32584: NEG
32585: PUSH
32586: LD_INT 1
32588: NEG
32589: PUSH
32590: EMPTY
32591: LIST
32592: LIST
32593: PUSH
32594: LD_INT 1
32596: PUSH
32597: LD_INT 1
32599: NEG
32600: PUSH
32601: EMPTY
32602: LIST
32603: LIST
32604: PUSH
32605: LD_INT 1
32607: NEG
32608: PUSH
32609: LD_INT 1
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PUSH
32616: EMPTY
32617: LIST
32618: LIST
32619: LIST
32620: LIST
32621: LIST
32622: LIST
32623: LIST
32624: LIST
32625: LIST
32626: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
32627: LD_ADDR_VAR 0 38
32631: PUSH
32632: LD_INT 0
32634: PUSH
32635: LD_INT 0
32637: PUSH
32638: EMPTY
32639: LIST
32640: LIST
32641: PUSH
32642: LD_INT 0
32644: PUSH
32645: LD_INT 1
32647: NEG
32648: PUSH
32649: EMPTY
32650: LIST
32651: LIST
32652: PUSH
32653: LD_INT 1
32655: PUSH
32656: LD_INT 0
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: PUSH
32663: LD_INT 1
32665: PUSH
32666: LD_INT 1
32668: PUSH
32669: EMPTY
32670: LIST
32671: LIST
32672: PUSH
32673: LD_INT 0
32675: PUSH
32676: LD_INT 1
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PUSH
32683: LD_INT 1
32685: NEG
32686: PUSH
32687: LD_INT 0
32689: PUSH
32690: EMPTY
32691: LIST
32692: LIST
32693: PUSH
32694: LD_INT 1
32696: NEG
32697: PUSH
32698: LD_INT 1
32700: NEG
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PUSH
32706: LD_INT 2
32708: PUSH
32709: LD_INT 1
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: PUSH
32716: LD_INT 2
32718: NEG
32719: PUSH
32720: LD_INT 1
32722: NEG
32723: PUSH
32724: EMPTY
32725: LIST
32726: LIST
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: LIST
32732: LIST
32733: LIST
32734: LIST
32735: LIST
32736: LIST
32737: LIST
32738: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
32739: LD_ADDR_VAR 0 39
32743: PUSH
32744: LD_INT 0
32746: PUSH
32747: LD_INT 0
32749: PUSH
32750: EMPTY
32751: LIST
32752: LIST
32753: PUSH
32754: LD_INT 0
32756: PUSH
32757: LD_INT 1
32759: NEG
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: PUSH
32765: LD_INT 1
32767: PUSH
32768: LD_INT 0
32770: PUSH
32771: EMPTY
32772: LIST
32773: LIST
32774: PUSH
32775: LD_INT 1
32777: PUSH
32778: LD_INT 1
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: LD_INT 0
32787: PUSH
32788: LD_INT 1
32790: PUSH
32791: EMPTY
32792: LIST
32793: LIST
32794: PUSH
32795: LD_INT 1
32797: NEG
32798: PUSH
32799: LD_INT 0
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: PUSH
32806: LD_INT 1
32808: NEG
32809: PUSH
32810: LD_INT 1
32812: NEG
32813: PUSH
32814: EMPTY
32815: LIST
32816: LIST
32817: PUSH
32818: LD_INT 1
32820: NEG
32821: PUSH
32822: LD_INT 2
32824: NEG
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 1
32832: PUSH
32833: LD_INT 2
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: LIST
32844: LIST
32845: LIST
32846: LIST
32847: LIST
32848: LIST
32849: LIST
32850: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
32851: LD_ADDR_VAR 0 40
32855: PUSH
32856: LD_INT 0
32858: PUSH
32859: LD_INT 0
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: PUSH
32866: LD_INT 0
32868: PUSH
32869: LD_INT 1
32871: NEG
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: LD_INT 1
32879: PUSH
32880: LD_INT 0
32882: PUSH
32883: EMPTY
32884: LIST
32885: LIST
32886: PUSH
32887: LD_INT 1
32889: PUSH
32890: LD_INT 1
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 0
32899: PUSH
32900: LD_INT 1
32902: PUSH
32903: EMPTY
32904: LIST
32905: LIST
32906: PUSH
32907: LD_INT 1
32909: NEG
32910: PUSH
32911: LD_INT 0
32913: PUSH
32914: EMPTY
32915: LIST
32916: LIST
32917: PUSH
32918: LD_INT 1
32920: NEG
32921: PUSH
32922: LD_INT 1
32924: NEG
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PUSH
32930: LD_INT 1
32932: PUSH
32933: LD_INT 1
32935: NEG
32936: PUSH
32937: EMPTY
32938: LIST
32939: LIST
32940: PUSH
32941: LD_INT 1
32943: NEG
32944: PUSH
32945: LD_INT 1
32947: PUSH
32948: EMPTY
32949: LIST
32950: LIST
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: LIST
32956: LIST
32957: LIST
32958: LIST
32959: LIST
32960: LIST
32961: LIST
32962: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32963: LD_ADDR_VAR 0 41
32967: PUSH
32968: LD_INT 0
32970: PUSH
32971: LD_INT 0
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 0
32980: PUSH
32981: LD_INT 1
32983: NEG
32984: PUSH
32985: EMPTY
32986: LIST
32987: LIST
32988: PUSH
32989: LD_INT 1
32991: PUSH
32992: LD_INT 0
32994: PUSH
32995: EMPTY
32996: LIST
32997: LIST
32998: PUSH
32999: LD_INT 1
33001: PUSH
33002: LD_INT 1
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: PUSH
33009: LD_INT 0
33011: PUSH
33012: LD_INT 1
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: PUSH
33019: LD_INT 1
33021: NEG
33022: PUSH
33023: LD_INT 0
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: LD_INT 1
33032: NEG
33033: PUSH
33034: LD_INT 1
33036: NEG
33037: PUSH
33038: EMPTY
33039: LIST
33040: LIST
33041: PUSH
33042: LD_INT 1
33044: NEG
33045: PUSH
33046: LD_INT 2
33048: NEG
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PUSH
33054: LD_INT 1
33056: PUSH
33057: LD_INT 1
33059: NEG
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: PUSH
33065: LD_INT 2
33067: PUSH
33068: LD_INT 0
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 2
33077: PUSH
33078: LD_INT 1
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: LD_INT 2
33087: PUSH
33088: LD_INT 2
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: PUSH
33095: LD_INT 1
33097: PUSH
33098: LD_INT 2
33100: PUSH
33101: EMPTY
33102: LIST
33103: LIST
33104: PUSH
33105: LD_INT 1
33107: NEG
33108: PUSH
33109: LD_INT 1
33111: PUSH
33112: EMPTY
33113: LIST
33114: LIST
33115: PUSH
33116: LD_INT 2
33118: NEG
33119: PUSH
33120: LD_INT 0
33122: PUSH
33123: EMPTY
33124: LIST
33125: LIST
33126: PUSH
33127: LD_INT 2
33129: NEG
33130: PUSH
33131: LD_INT 1
33133: NEG
33134: PUSH
33135: EMPTY
33136: LIST
33137: LIST
33138: PUSH
33139: LD_INT 2
33141: NEG
33142: PUSH
33143: LD_INT 2
33145: NEG
33146: PUSH
33147: EMPTY
33148: LIST
33149: LIST
33150: PUSH
33151: LD_INT 2
33153: NEG
33154: PUSH
33155: LD_INT 3
33157: NEG
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 2
33165: PUSH
33166: LD_INT 1
33168: NEG
33169: PUSH
33170: EMPTY
33171: LIST
33172: LIST
33173: PUSH
33174: LD_INT 3
33176: PUSH
33177: LD_INT 0
33179: PUSH
33180: EMPTY
33181: LIST
33182: LIST
33183: PUSH
33184: LD_INT 3
33186: PUSH
33187: LD_INT 1
33189: PUSH
33190: EMPTY
33191: LIST
33192: LIST
33193: PUSH
33194: LD_INT 3
33196: PUSH
33197: LD_INT 2
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: PUSH
33204: LD_INT 3
33206: PUSH
33207: LD_INT 3
33209: PUSH
33210: EMPTY
33211: LIST
33212: LIST
33213: PUSH
33214: LD_INT 2
33216: PUSH
33217: LD_INT 3
33219: PUSH
33220: EMPTY
33221: LIST
33222: LIST
33223: PUSH
33224: LD_INT 2
33226: NEG
33227: PUSH
33228: LD_INT 1
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: LD_INT 3
33237: NEG
33238: PUSH
33239: LD_INT 0
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: PUSH
33246: LD_INT 3
33248: NEG
33249: PUSH
33250: LD_INT 1
33252: NEG
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 3
33260: NEG
33261: PUSH
33262: LD_INT 2
33264: NEG
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 3
33272: NEG
33273: PUSH
33274: LD_INT 3
33276: NEG
33277: PUSH
33278: EMPTY
33279: LIST
33280: LIST
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: LIST
33286: LIST
33287: LIST
33288: LIST
33289: LIST
33290: LIST
33291: LIST
33292: LIST
33293: LIST
33294: LIST
33295: LIST
33296: LIST
33297: LIST
33298: LIST
33299: LIST
33300: LIST
33301: LIST
33302: LIST
33303: LIST
33304: LIST
33305: LIST
33306: LIST
33307: LIST
33308: LIST
33309: LIST
33310: LIST
33311: LIST
33312: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33313: LD_ADDR_VAR 0 42
33317: PUSH
33318: LD_INT 0
33320: PUSH
33321: LD_INT 0
33323: PUSH
33324: EMPTY
33325: LIST
33326: LIST
33327: PUSH
33328: LD_INT 0
33330: PUSH
33331: LD_INT 1
33333: NEG
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 1
33341: PUSH
33342: LD_INT 0
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 1
33351: PUSH
33352: LD_INT 1
33354: PUSH
33355: EMPTY
33356: LIST
33357: LIST
33358: PUSH
33359: LD_INT 0
33361: PUSH
33362: LD_INT 1
33364: PUSH
33365: EMPTY
33366: LIST
33367: LIST
33368: PUSH
33369: LD_INT 1
33371: NEG
33372: PUSH
33373: LD_INT 0
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 1
33382: NEG
33383: PUSH
33384: LD_INT 1
33386: NEG
33387: PUSH
33388: EMPTY
33389: LIST
33390: LIST
33391: PUSH
33392: LD_INT 1
33394: NEG
33395: PUSH
33396: LD_INT 2
33398: NEG
33399: PUSH
33400: EMPTY
33401: LIST
33402: LIST
33403: PUSH
33404: LD_INT 0
33406: PUSH
33407: LD_INT 2
33409: NEG
33410: PUSH
33411: EMPTY
33412: LIST
33413: LIST
33414: PUSH
33415: LD_INT 1
33417: PUSH
33418: LD_INT 1
33420: NEG
33421: PUSH
33422: EMPTY
33423: LIST
33424: LIST
33425: PUSH
33426: LD_INT 2
33428: PUSH
33429: LD_INT 1
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 2
33438: PUSH
33439: LD_INT 2
33441: PUSH
33442: EMPTY
33443: LIST
33444: LIST
33445: PUSH
33446: LD_INT 1
33448: PUSH
33449: LD_INT 2
33451: PUSH
33452: EMPTY
33453: LIST
33454: LIST
33455: PUSH
33456: LD_INT 0
33458: PUSH
33459: LD_INT 2
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: LD_INT 1
33468: NEG
33469: PUSH
33470: LD_INT 1
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: PUSH
33477: LD_INT 2
33479: NEG
33480: PUSH
33481: LD_INT 1
33483: NEG
33484: PUSH
33485: EMPTY
33486: LIST
33487: LIST
33488: PUSH
33489: LD_INT 2
33491: NEG
33492: PUSH
33493: LD_INT 2
33495: NEG
33496: PUSH
33497: EMPTY
33498: LIST
33499: LIST
33500: PUSH
33501: LD_INT 2
33503: NEG
33504: PUSH
33505: LD_INT 3
33507: NEG
33508: PUSH
33509: EMPTY
33510: LIST
33511: LIST
33512: PUSH
33513: LD_INT 1
33515: NEG
33516: PUSH
33517: LD_INT 3
33519: NEG
33520: PUSH
33521: EMPTY
33522: LIST
33523: LIST
33524: PUSH
33525: LD_INT 0
33527: PUSH
33528: LD_INT 3
33530: NEG
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: LD_INT 1
33538: PUSH
33539: LD_INT 2
33541: NEG
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 3
33549: PUSH
33550: LD_INT 2
33552: PUSH
33553: EMPTY
33554: LIST
33555: LIST
33556: PUSH
33557: LD_INT 3
33559: PUSH
33560: LD_INT 3
33562: PUSH
33563: EMPTY
33564: LIST
33565: LIST
33566: PUSH
33567: LD_INT 2
33569: PUSH
33570: LD_INT 3
33572: PUSH
33573: EMPTY
33574: LIST
33575: LIST
33576: PUSH
33577: LD_INT 1
33579: PUSH
33580: LD_INT 3
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: LD_INT 0
33589: PUSH
33590: LD_INT 3
33592: PUSH
33593: EMPTY
33594: LIST
33595: LIST
33596: PUSH
33597: LD_INT 1
33599: NEG
33600: PUSH
33601: LD_INT 2
33603: PUSH
33604: EMPTY
33605: LIST
33606: LIST
33607: PUSH
33608: LD_INT 3
33610: NEG
33611: PUSH
33612: LD_INT 2
33614: NEG
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PUSH
33620: LD_INT 3
33622: NEG
33623: PUSH
33624: LD_INT 3
33626: NEG
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: PUSH
33632: EMPTY
33633: LIST
33634: LIST
33635: LIST
33636: LIST
33637: LIST
33638: LIST
33639: LIST
33640: LIST
33641: LIST
33642: LIST
33643: LIST
33644: LIST
33645: LIST
33646: LIST
33647: LIST
33648: LIST
33649: LIST
33650: LIST
33651: LIST
33652: LIST
33653: LIST
33654: LIST
33655: LIST
33656: LIST
33657: LIST
33658: LIST
33659: LIST
33660: LIST
33661: LIST
33662: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33663: LD_ADDR_VAR 0 43
33667: PUSH
33668: LD_INT 0
33670: PUSH
33671: LD_INT 0
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: LD_INT 0
33680: PUSH
33681: LD_INT 1
33683: NEG
33684: PUSH
33685: EMPTY
33686: LIST
33687: LIST
33688: PUSH
33689: LD_INT 1
33691: PUSH
33692: LD_INT 0
33694: PUSH
33695: EMPTY
33696: LIST
33697: LIST
33698: PUSH
33699: LD_INT 1
33701: PUSH
33702: LD_INT 1
33704: PUSH
33705: EMPTY
33706: LIST
33707: LIST
33708: PUSH
33709: LD_INT 0
33711: PUSH
33712: LD_INT 1
33714: PUSH
33715: EMPTY
33716: LIST
33717: LIST
33718: PUSH
33719: LD_INT 1
33721: NEG
33722: PUSH
33723: LD_INT 0
33725: PUSH
33726: EMPTY
33727: LIST
33728: LIST
33729: PUSH
33730: LD_INT 1
33732: NEG
33733: PUSH
33734: LD_INT 1
33736: NEG
33737: PUSH
33738: EMPTY
33739: LIST
33740: LIST
33741: PUSH
33742: LD_INT 1
33744: NEG
33745: PUSH
33746: LD_INT 2
33748: NEG
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: LD_INT 0
33756: PUSH
33757: LD_INT 2
33759: NEG
33760: PUSH
33761: EMPTY
33762: LIST
33763: LIST
33764: PUSH
33765: LD_INT 1
33767: PUSH
33768: LD_INT 1
33770: NEG
33771: PUSH
33772: EMPTY
33773: LIST
33774: LIST
33775: PUSH
33776: LD_INT 2
33778: PUSH
33779: LD_INT 0
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 2
33788: PUSH
33789: LD_INT 1
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 1
33798: PUSH
33799: LD_INT 2
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 0
33808: PUSH
33809: LD_INT 2
33811: PUSH
33812: EMPTY
33813: LIST
33814: LIST
33815: PUSH
33816: LD_INT 1
33818: NEG
33819: PUSH
33820: LD_INT 1
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 2
33829: NEG
33830: PUSH
33831: LD_INT 0
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 2
33840: NEG
33841: PUSH
33842: LD_INT 1
33844: NEG
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 1
33852: NEG
33853: PUSH
33854: LD_INT 3
33856: NEG
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 0
33864: PUSH
33865: LD_INT 3
33867: NEG
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: PUSH
33873: LD_INT 1
33875: PUSH
33876: LD_INT 2
33878: NEG
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: PUSH
33884: LD_INT 2
33886: PUSH
33887: LD_INT 1
33889: NEG
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 3
33897: PUSH
33898: LD_INT 0
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 3
33907: PUSH
33908: LD_INT 1
33910: PUSH
33911: EMPTY
33912: LIST
33913: LIST
33914: PUSH
33915: LD_INT 1
33917: PUSH
33918: LD_INT 3
33920: PUSH
33921: EMPTY
33922: LIST
33923: LIST
33924: PUSH
33925: LD_INT 0
33927: PUSH
33928: LD_INT 3
33930: PUSH
33931: EMPTY
33932: LIST
33933: LIST
33934: PUSH
33935: LD_INT 1
33937: NEG
33938: PUSH
33939: LD_INT 2
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 2
33948: NEG
33949: PUSH
33950: LD_INT 1
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 3
33959: NEG
33960: PUSH
33961: LD_INT 0
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PUSH
33968: LD_INT 3
33970: NEG
33971: PUSH
33972: LD_INT 1
33974: NEG
33975: PUSH
33976: EMPTY
33977: LIST
33978: LIST
33979: PUSH
33980: EMPTY
33981: LIST
33982: LIST
33983: LIST
33984: LIST
33985: LIST
33986: LIST
33987: LIST
33988: LIST
33989: LIST
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: LIST
34003: LIST
34004: LIST
34005: LIST
34006: LIST
34007: LIST
34008: LIST
34009: LIST
34010: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34011: LD_ADDR_VAR 0 44
34015: PUSH
34016: LD_INT 0
34018: PUSH
34019: LD_INT 0
34021: PUSH
34022: EMPTY
34023: LIST
34024: LIST
34025: PUSH
34026: LD_INT 0
34028: PUSH
34029: LD_INT 1
34031: NEG
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: PUSH
34037: LD_INT 1
34039: PUSH
34040: LD_INT 0
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: PUSH
34047: LD_INT 1
34049: PUSH
34050: LD_INT 1
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: PUSH
34057: LD_INT 0
34059: PUSH
34060: LD_INT 1
34062: PUSH
34063: EMPTY
34064: LIST
34065: LIST
34066: PUSH
34067: LD_INT 1
34069: NEG
34070: PUSH
34071: LD_INT 0
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PUSH
34078: LD_INT 1
34080: NEG
34081: PUSH
34082: LD_INT 1
34084: NEG
34085: PUSH
34086: EMPTY
34087: LIST
34088: LIST
34089: PUSH
34090: LD_INT 1
34092: NEG
34093: PUSH
34094: LD_INT 2
34096: NEG
34097: PUSH
34098: EMPTY
34099: LIST
34100: LIST
34101: PUSH
34102: LD_INT 1
34104: PUSH
34105: LD_INT 1
34107: NEG
34108: PUSH
34109: EMPTY
34110: LIST
34111: LIST
34112: PUSH
34113: LD_INT 2
34115: PUSH
34116: LD_INT 0
34118: PUSH
34119: EMPTY
34120: LIST
34121: LIST
34122: PUSH
34123: LD_INT 2
34125: PUSH
34126: LD_INT 1
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 2
34135: PUSH
34136: LD_INT 2
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: LD_INT 1
34145: PUSH
34146: LD_INT 2
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 1
34155: NEG
34156: PUSH
34157: LD_INT 1
34159: PUSH
34160: EMPTY
34161: LIST
34162: LIST
34163: PUSH
34164: LD_INT 2
34166: NEG
34167: PUSH
34168: LD_INT 0
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PUSH
34175: LD_INT 2
34177: NEG
34178: PUSH
34179: LD_INT 1
34181: NEG
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 2
34189: NEG
34190: PUSH
34191: LD_INT 2
34193: NEG
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 2
34201: NEG
34202: PUSH
34203: LD_INT 3
34205: NEG
34206: PUSH
34207: EMPTY
34208: LIST
34209: LIST
34210: PUSH
34211: LD_INT 2
34213: PUSH
34214: LD_INT 1
34216: NEG
34217: PUSH
34218: EMPTY
34219: LIST
34220: LIST
34221: PUSH
34222: LD_INT 3
34224: PUSH
34225: LD_INT 0
34227: PUSH
34228: EMPTY
34229: LIST
34230: LIST
34231: PUSH
34232: LD_INT 3
34234: PUSH
34235: LD_INT 1
34237: PUSH
34238: EMPTY
34239: LIST
34240: LIST
34241: PUSH
34242: LD_INT 3
34244: PUSH
34245: LD_INT 2
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: PUSH
34252: LD_INT 3
34254: PUSH
34255: LD_INT 3
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PUSH
34262: LD_INT 2
34264: PUSH
34265: LD_INT 3
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: PUSH
34272: LD_INT 2
34274: NEG
34275: PUSH
34276: LD_INT 1
34278: PUSH
34279: EMPTY
34280: LIST
34281: LIST
34282: PUSH
34283: LD_INT 3
34285: NEG
34286: PUSH
34287: LD_INT 0
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: PUSH
34294: LD_INT 3
34296: NEG
34297: PUSH
34298: LD_INT 1
34300: NEG
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: LD_INT 3
34308: NEG
34309: PUSH
34310: LD_INT 2
34312: NEG
34313: PUSH
34314: EMPTY
34315: LIST
34316: LIST
34317: PUSH
34318: LD_INT 3
34320: NEG
34321: PUSH
34322: LD_INT 3
34324: NEG
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: PUSH
34330: EMPTY
34331: LIST
34332: LIST
34333: LIST
34334: LIST
34335: LIST
34336: LIST
34337: LIST
34338: LIST
34339: LIST
34340: LIST
34341: LIST
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: LIST
34349: LIST
34350: LIST
34351: LIST
34352: LIST
34353: LIST
34354: LIST
34355: LIST
34356: LIST
34357: LIST
34358: LIST
34359: LIST
34360: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34361: LD_ADDR_VAR 0 45
34365: PUSH
34366: LD_INT 0
34368: PUSH
34369: LD_INT 0
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: PUSH
34376: LD_INT 0
34378: PUSH
34379: LD_INT 1
34381: NEG
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: PUSH
34390: LD_INT 0
34392: PUSH
34393: EMPTY
34394: LIST
34395: LIST
34396: PUSH
34397: LD_INT 1
34399: PUSH
34400: LD_INT 1
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PUSH
34407: LD_INT 0
34409: PUSH
34410: LD_INT 1
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: PUSH
34417: LD_INT 1
34419: NEG
34420: PUSH
34421: LD_INT 0
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: PUSH
34428: LD_INT 1
34430: NEG
34431: PUSH
34432: LD_INT 1
34434: NEG
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 1
34442: NEG
34443: PUSH
34444: LD_INT 2
34446: NEG
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 0
34454: PUSH
34455: LD_INT 2
34457: NEG
34458: PUSH
34459: EMPTY
34460: LIST
34461: LIST
34462: PUSH
34463: LD_INT 1
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 2
34476: PUSH
34477: LD_INT 1
34479: PUSH
34480: EMPTY
34481: LIST
34482: LIST
34483: PUSH
34484: LD_INT 2
34486: PUSH
34487: LD_INT 2
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: PUSH
34494: LD_INT 1
34496: PUSH
34497: LD_INT 2
34499: PUSH
34500: EMPTY
34501: LIST
34502: LIST
34503: PUSH
34504: LD_INT 0
34506: PUSH
34507: LD_INT 2
34509: PUSH
34510: EMPTY
34511: LIST
34512: LIST
34513: PUSH
34514: LD_INT 1
34516: NEG
34517: PUSH
34518: LD_INT 1
34520: PUSH
34521: EMPTY
34522: LIST
34523: LIST
34524: PUSH
34525: LD_INT 2
34527: NEG
34528: PUSH
34529: LD_INT 1
34531: NEG
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: LD_INT 2
34539: NEG
34540: PUSH
34541: LD_INT 2
34543: NEG
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 2
34551: NEG
34552: PUSH
34553: LD_INT 3
34555: NEG
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 1
34563: NEG
34564: PUSH
34565: LD_INT 3
34567: NEG
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 0
34575: PUSH
34576: LD_INT 3
34578: NEG
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: LD_INT 1
34586: PUSH
34587: LD_INT 2
34589: NEG
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 3
34597: PUSH
34598: LD_INT 2
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: LD_INT 3
34607: PUSH
34608: LD_INT 3
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: PUSH
34615: LD_INT 2
34617: PUSH
34618: LD_INT 3
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: LD_INT 1
34627: PUSH
34628: LD_INT 3
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 0
34637: PUSH
34638: LD_INT 3
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 1
34647: NEG
34648: PUSH
34649: LD_INT 2
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 3
34658: NEG
34659: PUSH
34660: LD_INT 2
34662: NEG
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: LD_INT 3
34670: NEG
34671: PUSH
34672: LD_INT 3
34674: NEG
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: LIST
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: LIST
34697: LIST
34698: LIST
34699: LIST
34700: LIST
34701: LIST
34702: LIST
34703: LIST
34704: LIST
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34711: LD_ADDR_VAR 0 46
34715: PUSH
34716: LD_INT 0
34718: PUSH
34719: LD_INT 0
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PUSH
34726: LD_INT 0
34728: PUSH
34729: LD_INT 1
34731: NEG
34732: PUSH
34733: EMPTY
34734: LIST
34735: LIST
34736: PUSH
34737: LD_INT 1
34739: PUSH
34740: LD_INT 0
34742: PUSH
34743: EMPTY
34744: LIST
34745: LIST
34746: PUSH
34747: LD_INT 1
34749: PUSH
34750: LD_INT 1
34752: PUSH
34753: EMPTY
34754: LIST
34755: LIST
34756: PUSH
34757: LD_INT 0
34759: PUSH
34760: LD_INT 1
34762: PUSH
34763: EMPTY
34764: LIST
34765: LIST
34766: PUSH
34767: LD_INT 1
34769: NEG
34770: PUSH
34771: LD_INT 0
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: PUSH
34778: LD_INT 1
34780: NEG
34781: PUSH
34782: LD_INT 1
34784: NEG
34785: PUSH
34786: EMPTY
34787: LIST
34788: LIST
34789: PUSH
34790: LD_INT 1
34792: NEG
34793: PUSH
34794: LD_INT 2
34796: NEG
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: PUSH
34802: LD_INT 0
34804: PUSH
34805: LD_INT 2
34807: NEG
34808: PUSH
34809: EMPTY
34810: LIST
34811: LIST
34812: PUSH
34813: LD_INT 1
34815: PUSH
34816: LD_INT 1
34818: NEG
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PUSH
34824: LD_INT 2
34826: PUSH
34827: LD_INT 0
34829: PUSH
34830: EMPTY
34831: LIST
34832: LIST
34833: PUSH
34834: LD_INT 2
34836: PUSH
34837: LD_INT 1
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 1
34846: PUSH
34847: LD_INT 2
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 0
34856: PUSH
34857: LD_INT 2
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: LD_INT 1
34866: NEG
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 2
34877: NEG
34878: PUSH
34879: LD_INT 0
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: PUSH
34886: LD_INT 2
34888: NEG
34889: PUSH
34890: LD_INT 1
34892: NEG
34893: PUSH
34894: EMPTY
34895: LIST
34896: LIST
34897: PUSH
34898: LD_INT 1
34900: NEG
34901: PUSH
34902: LD_INT 3
34904: NEG
34905: PUSH
34906: EMPTY
34907: LIST
34908: LIST
34909: PUSH
34910: LD_INT 0
34912: PUSH
34913: LD_INT 3
34915: NEG
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: PUSH
34921: LD_INT 1
34923: PUSH
34924: LD_INT 2
34926: NEG
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 2
34934: PUSH
34935: LD_INT 1
34937: NEG
34938: PUSH
34939: EMPTY
34940: LIST
34941: LIST
34942: PUSH
34943: LD_INT 3
34945: PUSH
34946: LD_INT 0
34948: PUSH
34949: EMPTY
34950: LIST
34951: LIST
34952: PUSH
34953: LD_INT 3
34955: PUSH
34956: LD_INT 1
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: PUSH
34963: LD_INT 1
34965: PUSH
34966: LD_INT 3
34968: PUSH
34969: EMPTY
34970: LIST
34971: LIST
34972: PUSH
34973: LD_INT 0
34975: PUSH
34976: LD_INT 3
34978: PUSH
34979: EMPTY
34980: LIST
34981: LIST
34982: PUSH
34983: LD_INT 1
34985: NEG
34986: PUSH
34987: LD_INT 2
34989: PUSH
34990: EMPTY
34991: LIST
34992: LIST
34993: PUSH
34994: LD_INT 2
34996: NEG
34997: PUSH
34998: LD_INT 1
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: LD_INT 3
35007: NEG
35008: PUSH
35009: LD_INT 0
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: LD_INT 3
35018: NEG
35019: PUSH
35020: LD_INT 1
35022: NEG
35023: PUSH
35024: EMPTY
35025: LIST
35026: LIST
35027: PUSH
35028: EMPTY
35029: LIST
35030: LIST
35031: LIST
35032: LIST
35033: LIST
35034: LIST
35035: LIST
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: LIST
35052: LIST
35053: LIST
35054: LIST
35055: LIST
35056: LIST
35057: LIST
35058: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35059: LD_ADDR_VAR 0 47
35063: PUSH
35064: LD_INT 0
35066: PUSH
35067: LD_INT 0
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: LD_INT 0
35076: PUSH
35077: LD_INT 1
35079: NEG
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PUSH
35085: LD_INT 1
35087: PUSH
35088: LD_INT 0
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PUSH
35095: LD_INT 1
35097: PUSH
35098: LD_INT 1
35100: PUSH
35101: EMPTY
35102: LIST
35103: LIST
35104: PUSH
35105: LD_INT 0
35107: PUSH
35108: LD_INT 1
35110: PUSH
35111: EMPTY
35112: LIST
35113: LIST
35114: PUSH
35115: LD_INT 1
35117: NEG
35118: PUSH
35119: LD_INT 0
35121: PUSH
35122: EMPTY
35123: LIST
35124: LIST
35125: PUSH
35126: LD_INT 1
35128: NEG
35129: PUSH
35130: LD_INT 1
35132: NEG
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 1
35140: NEG
35141: PUSH
35142: LD_INT 2
35144: NEG
35145: PUSH
35146: EMPTY
35147: LIST
35148: LIST
35149: PUSH
35150: LD_INT 0
35152: PUSH
35153: LD_INT 2
35155: NEG
35156: PUSH
35157: EMPTY
35158: LIST
35159: LIST
35160: PUSH
35161: LD_INT 1
35163: PUSH
35164: LD_INT 1
35166: NEG
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: PUSH
35172: LD_INT 2
35174: NEG
35175: PUSH
35176: LD_INT 1
35178: NEG
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: LD_INT 2
35186: NEG
35187: PUSH
35188: LD_INT 2
35190: NEG
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: EMPTY
35197: LIST
35198: LIST
35199: LIST
35200: LIST
35201: LIST
35202: LIST
35203: LIST
35204: LIST
35205: LIST
35206: LIST
35207: LIST
35208: LIST
35209: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
35210: LD_ADDR_VAR 0 48
35214: PUSH
35215: LD_INT 0
35217: PUSH
35218: LD_INT 0
35220: PUSH
35221: EMPTY
35222: LIST
35223: LIST
35224: PUSH
35225: LD_INT 0
35227: PUSH
35228: LD_INT 1
35230: NEG
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 1
35238: PUSH
35239: LD_INT 0
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 1
35248: PUSH
35249: LD_INT 1
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 0
35258: PUSH
35259: LD_INT 1
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 1
35268: NEG
35269: PUSH
35270: LD_INT 0
35272: PUSH
35273: EMPTY
35274: LIST
35275: LIST
35276: PUSH
35277: LD_INT 1
35279: NEG
35280: PUSH
35281: LD_INT 1
35283: NEG
35284: PUSH
35285: EMPTY
35286: LIST
35287: LIST
35288: PUSH
35289: LD_INT 1
35291: NEG
35292: PUSH
35293: LD_INT 2
35295: NEG
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: PUSH
35301: LD_INT 0
35303: PUSH
35304: LD_INT 2
35306: NEG
35307: PUSH
35308: EMPTY
35309: LIST
35310: LIST
35311: PUSH
35312: LD_INT 1
35314: PUSH
35315: LD_INT 1
35317: NEG
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: PUSH
35323: LD_INT 2
35325: PUSH
35326: LD_INT 0
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 2
35335: PUSH
35336: LD_INT 1
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: LIST
35347: LIST
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: LIST
35353: LIST
35354: LIST
35355: LIST
35356: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
35357: LD_ADDR_VAR 0 49
35361: PUSH
35362: LD_INT 0
35364: PUSH
35365: LD_INT 0
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 0
35374: PUSH
35375: LD_INT 1
35377: NEG
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 1
35385: PUSH
35386: LD_INT 0
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: LD_INT 1
35395: PUSH
35396: LD_INT 1
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 0
35405: PUSH
35406: LD_INT 1
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: LD_INT 1
35415: NEG
35416: PUSH
35417: LD_INT 0
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: PUSH
35424: LD_INT 1
35426: NEG
35427: PUSH
35428: LD_INT 1
35430: NEG
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 1
35438: PUSH
35439: LD_INT 1
35441: NEG
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: LD_INT 2
35449: PUSH
35450: LD_INT 0
35452: PUSH
35453: EMPTY
35454: LIST
35455: LIST
35456: PUSH
35457: LD_INT 2
35459: PUSH
35460: LD_INT 1
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PUSH
35467: LD_INT 2
35469: PUSH
35470: LD_INT 2
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 1
35479: PUSH
35480: LD_INT 2
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: EMPTY
35488: LIST
35489: LIST
35490: LIST
35491: LIST
35492: LIST
35493: LIST
35494: LIST
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: LIST
35500: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
35501: LD_ADDR_VAR 0 50
35505: PUSH
35506: LD_INT 0
35508: PUSH
35509: LD_INT 0
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: PUSH
35516: LD_INT 0
35518: PUSH
35519: LD_INT 1
35521: NEG
35522: PUSH
35523: EMPTY
35524: LIST
35525: LIST
35526: PUSH
35527: LD_INT 1
35529: PUSH
35530: LD_INT 0
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 1
35539: PUSH
35540: LD_INT 1
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 0
35549: PUSH
35550: LD_INT 1
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: LD_INT 1
35559: NEG
35560: PUSH
35561: LD_INT 0
35563: PUSH
35564: EMPTY
35565: LIST
35566: LIST
35567: PUSH
35568: LD_INT 1
35570: NEG
35571: PUSH
35572: LD_INT 1
35574: NEG
35575: PUSH
35576: EMPTY
35577: LIST
35578: LIST
35579: PUSH
35580: LD_INT 2
35582: PUSH
35583: LD_INT 1
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 2
35592: PUSH
35593: LD_INT 2
35595: PUSH
35596: EMPTY
35597: LIST
35598: LIST
35599: PUSH
35600: LD_INT 1
35602: PUSH
35603: LD_INT 2
35605: PUSH
35606: EMPTY
35607: LIST
35608: LIST
35609: PUSH
35610: LD_INT 0
35612: PUSH
35613: LD_INT 2
35615: PUSH
35616: EMPTY
35617: LIST
35618: LIST
35619: PUSH
35620: LD_INT 1
35622: NEG
35623: PUSH
35624: LD_INT 1
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: EMPTY
35632: LIST
35633: LIST
35634: LIST
35635: LIST
35636: LIST
35637: LIST
35638: LIST
35639: LIST
35640: LIST
35641: LIST
35642: LIST
35643: LIST
35644: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
35645: LD_ADDR_VAR 0 51
35649: PUSH
35650: LD_INT 0
35652: PUSH
35653: LD_INT 0
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 0
35662: PUSH
35663: LD_INT 1
35665: NEG
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 1
35673: PUSH
35674: LD_INT 0
35676: PUSH
35677: EMPTY
35678: LIST
35679: LIST
35680: PUSH
35681: LD_INT 1
35683: PUSH
35684: LD_INT 1
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 0
35693: PUSH
35694: LD_INT 1
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 1
35703: NEG
35704: PUSH
35705: LD_INT 0
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 1
35714: NEG
35715: PUSH
35716: LD_INT 1
35718: NEG
35719: PUSH
35720: EMPTY
35721: LIST
35722: LIST
35723: PUSH
35724: LD_INT 1
35726: PUSH
35727: LD_INT 2
35729: PUSH
35730: EMPTY
35731: LIST
35732: LIST
35733: PUSH
35734: LD_INT 0
35736: PUSH
35737: LD_INT 2
35739: PUSH
35740: EMPTY
35741: LIST
35742: LIST
35743: PUSH
35744: LD_INT 1
35746: NEG
35747: PUSH
35748: LD_INT 1
35750: PUSH
35751: EMPTY
35752: LIST
35753: LIST
35754: PUSH
35755: LD_INT 2
35757: NEG
35758: PUSH
35759: LD_INT 0
35761: PUSH
35762: EMPTY
35763: LIST
35764: LIST
35765: PUSH
35766: LD_INT 2
35768: NEG
35769: PUSH
35770: LD_INT 1
35772: NEG
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: EMPTY
35779: LIST
35780: LIST
35781: LIST
35782: LIST
35783: LIST
35784: LIST
35785: LIST
35786: LIST
35787: LIST
35788: LIST
35789: LIST
35790: LIST
35791: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35792: LD_ADDR_VAR 0 52
35796: PUSH
35797: LD_INT 0
35799: PUSH
35800: LD_INT 0
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 0
35809: PUSH
35810: LD_INT 1
35812: NEG
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: LD_INT 1
35820: PUSH
35821: LD_INT 0
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: PUSH
35828: LD_INT 1
35830: PUSH
35831: LD_INT 1
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: PUSH
35838: LD_INT 0
35840: PUSH
35841: LD_INT 1
35843: PUSH
35844: EMPTY
35845: LIST
35846: LIST
35847: PUSH
35848: LD_INT 1
35850: NEG
35851: PUSH
35852: LD_INT 0
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 1
35861: NEG
35862: PUSH
35863: LD_INT 1
35865: NEG
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 1
35873: NEG
35874: PUSH
35875: LD_INT 2
35877: NEG
35878: PUSH
35879: EMPTY
35880: LIST
35881: LIST
35882: PUSH
35883: LD_INT 1
35885: NEG
35886: PUSH
35887: LD_INT 1
35889: PUSH
35890: EMPTY
35891: LIST
35892: LIST
35893: PUSH
35894: LD_INT 2
35896: NEG
35897: PUSH
35898: LD_INT 0
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: LD_INT 2
35907: NEG
35908: PUSH
35909: LD_INT 1
35911: NEG
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 2
35919: NEG
35920: PUSH
35921: LD_INT 2
35923: NEG
35924: PUSH
35925: EMPTY
35926: LIST
35927: LIST
35928: PUSH
35929: EMPTY
35930: LIST
35931: LIST
35932: LIST
35933: LIST
35934: LIST
35935: LIST
35936: LIST
35937: LIST
35938: LIST
35939: LIST
35940: LIST
35941: LIST
35942: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35943: LD_ADDR_VAR 0 53
35947: PUSH
35948: LD_INT 0
35950: PUSH
35951: LD_INT 0
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: PUSH
35958: LD_INT 0
35960: PUSH
35961: LD_INT 1
35963: NEG
35964: PUSH
35965: EMPTY
35966: LIST
35967: LIST
35968: PUSH
35969: LD_INT 1
35971: PUSH
35972: LD_INT 0
35974: PUSH
35975: EMPTY
35976: LIST
35977: LIST
35978: PUSH
35979: LD_INT 1
35981: PUSH
35982: LD_INT 1
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: LD_INT 0
35991: PUSH
35992: LD_INT 1
35994: PUSH
35995: EMPTY
35996: LIST
35997: LIST
35998: PUSH
35999: LD_INT 1
36001: NEG
36002: PUSH
36003: LD_INT 0
36005: PUSH
36006: EMPTY
36007: LIST
36008: LIST
36009: PUSH
36010: LD_INT 1
36012: NEG
36013: PUSH
36014: LD_INT 1
36016: NEG
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 1
36024: NEG
36025: PUSH
36026: LD_INT 2
36028: NEG
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PUSH
36034: LD_INT 0
36036: PUSH
36037: LD_INT 2
36039: NEG
36040: PUSH
36041: EMPTY
36042: LIST
36043: LIST
36044: PUSH
36045: LD_INT 1
36047: PUSH
36048: LD_INT 1
36050: NEG
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: PUSH
36056: LD_INT 2
36058: PUSH
36059: LD_INT 0
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 2
36068: PUSH
36069: LD_INT 1
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: PUSH
36076: LD_INT 2
36078: PUSH
36079: LD_INT 2
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: LD_INT 1
36088: PUSH
36089: LD_INT 2
36091: PUSH
36092: EMPTY
36093: LIST
36094: LIST
36095: PUSH
36096: LD_INT 0
36098: PUSH
36099: LD_INT 2
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: PUSH
36106: LD_INT 1
36108: NEG
36109: PUSH
36110: LD_INT 1
36112: PUSH
36113: EMPTY
36114: LIST
36115: LIST
36116: PUSH
36117: LD_INT 2
36119: NEG
36120: PUSH
36121: LD_INT 0
36123: PUSH
36124: EMPTY
36125: LIST
36126: LIST
36127: PUSH
36128: LD_INT 2
36130: NEG
36131: PUSH
36132: LD_INT 1
36134: NEG
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: PUSH
36140: LD_INT 2
36142: NEG
36143: PUSH
36144: LD_INT 2
36146: NEG
36147: PUSH
36148: EMPTY
36149: LIST
36150: LIST
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: LIST
36156: LIST
36157: LIST
36158: LIST
36159: LIST
36160: LIST
36161: LIST
36162: LIST
36163: LIST
36164: LIST
36165: LIST
36166: LIST
36167: LIST
36168: LIST
36169: LIST
36170: LIST
36171: LIST
36172: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36173: LD_ADDR_VAR 0 54
36177: PUSH
36178: LD_INT 0
36180: PUSH
36181: LD_INT 0
36183: PUSH
36184: EMPTY
36185: LIST
36186: LIST
36187: PUSH
36188: LD_INT 0
36190: PUSH
36191: LD_INT 1
36193: NEG
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 1
36201: PUSH
36202: LD_INT 0
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: PUSH
36209: LD_INT 1
36211: PUSH
36212: LD_INT 1
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: LD_INT 0
36221: PUSH
36222: LD_INT 1
36224: PUSH
36225: EMPTY
36226: LIST
36227: LIST
36228: PUSH
36229: LD_INT 1
36231: NEG
36232: PUSH
36233: LD_INT 0
36235: PUSH
36236: EMPTY
36237: LIST
36238: LIST
36239: PUSH
36240: LD_INT 1
36242: NEG
36243: PUSH
36244: LD_INT 1
36246: NEG
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 1
36254: NEG
36255: PUSH
36256: LD_INT 2
36258: NEG
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 0
36266: PUSH
36267: LD_INT 2
36269: NEG
36270: PUSH
36271: EMPTY
36272: LIST
36273: LIST
36274: PUSH
36275: LD_INT 1
36277: PUSH
36278: LD_INT 1
36280: NEG
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 2
36288: PUSH
36289: LD_INT 0
36291: PUSH
36292: EMPTY
36293: LIST
36294: LIST
36295: PUSH
36296: LD_INT 2
36298: PUSH
36299: LD_INT 1
36301: PUSH
36302: EMPTY
36303: LIST
36304: LIST
36305: PUSH
36306: LD_INT 2
36308: PUSH
36309: LD_INT 2
36311: PUSH
36312: EMPTY
36313: LIST
36314: LIST
36315: PUSH
36316: LD_INT 1
36318: PUSH
36319: LD_INT 2
36321: PUSH
36322: EMPTY
36323: LIST
36324: LIST
36325: PUSH
36326: LD_INT 0
36328: PUSH
36329: LD_INT 2
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: LD_INT 1
36338: NEG
36339: PUSH
36340: LD_INT 1
36342: PUSH
36343: EMPTY
36344: LIST
36345: LIST
36346: PUSH
36347: LD_INT 2
36349: NEG
36350: PUSH
36351: LD_INT 0
36353: PUSH
36354: EMPTY
36355: LIST
36356: LIST
36357: PUSH
36358: LD_INT 2
36360: NEG
36361: PUSH
36362: LD_INT 1
36364: NEG
36365: PUSH
36366: EMPTY
36367: LIST
36368: LIST
36369: PUSH
36370: LD_INT 2
36372: NEG
36373: PUSH
36374: LD_INT 2
36376: NEG
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: EMPTY
36383: LIST
36384: LIST
36385: LIST
36386: LIST
36387: LIST
36388: LIST
36389: LIST
36390: LIST
36391: LIST
36392: LIST
36393: LIST
36394: LIST
36395: LIST
36396: LIST
36397: LIST
36398: LIST
36399: LIST
36400: LIST
36401: LIST
36402: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36403: LD_ADDR_VAR 0 55
36407: PUSH
36408: LD_INT 0
36410: PUSH
36411: LD_INT 0
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: PUSH
36418: LD_INT 0
36420: PUSH
36421: LD_INT 1
36423: NEG
36424: PUSH
36425: EMPTY
36426: LIST
36427: LIST
36428: PUSH
36429: LD_INT 1
36431: PUSH
36432: LD_INT 0
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: PUSH
36439: LD_INT 1
36441: PUSH
36442: LD_INT 1
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: LD_INT 0
36451: PUSH
36452: LD_INT 1
36454: PUSH
36455: EMPTY
36456: LIST
36457: LIST
36458: PUSH
36459: LD_INT 1
36461: NEG
36462: PUSH
36463: LD_INT 0
36465: PUSH
36466: EMPTY
36467: LIST
36468: LIST
36469: PUSH
36470: LD_INT 1
36472: NEG
36473: PUSH
36474: LD_INT 1
36476: NEG
36477: PUSH
36478: EMPTY
36479: LIST
36480: LIST
36481: PUSH
36482: LD_INT 1
36484: NEG
36485: PUSH
36486: LD_INT 2
36488: NEG
36489: PUSH
36490: EMPTY
36491: LIST
36492: LIST
36493: PUSH
36494: LD_INT 0
36496: PUSH
36497: LD_INT 2
36499: NEG
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 1
36507: PUSH
36508: LD_INT 1
36510: NEG
36511: PUSH
36512: EMPTY
36513: LIST
36514: LIST
36515: PUSH
36516: LD_INT 2
36518: PUSH
36519: LD_INT 0
36521: PUSH
36522: EMPTY
36523: LIST
36524: LIST
36525: PUSH
36526: LD_INT 2
36528: PUSH
36529: LD_INT 1
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: PUSH
36536: LD_INT 2
36538: PUSH
36539: LD_INT 2
36541: PUSH
36542: EMPTY
36543: LIST
36544: LIST
36545: PUSH
36546: LD_INT 1
36548: PUSH
36549: LD_INT 2
36551: PUSH
36552: EMPTY
36553: LIST
36554: LIST
36555: PUSH
36556: LD_INT 0
36558: PUSH
36559: LD_INT 2
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 1
36568: NEG
36569: PUSH
36570: LD_INT 1
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: LD_INT 2
36579: NEG
36580: PUSH
36581: LD_INT 0
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: PUSH
36588: LD_INT 2
36590: NEG
36591: PUSH
36592: LD_INT 1
36594: NEG
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: PUSH
36600: LD_INT 2
36602: NEG
36603: PUSH
36604: LD_INT 2
36606: NEG
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: EMPTY
36613: LIST
36614: LIST
36615: LIST
36616: LIST
36617: LIST
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: LIST
36629: LIST
36630: LIST
36631: LIST
36632: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36633: LD_ADDR_VAR 0 56
36637: PUSH
36638: LD_INT 0
36640: PUSH
36641: LD_INT 0
36643: PUSH
36644: EMPTY
36645: LIST
36646: LIST
36647: PUSH
36648: LD_INT 0
36650: PUSH
36651: LD_INT 1
36653: NEG
36654: PUSH
36655: EMPTY
36656: LIST
36657: LIST
36658: PUSH
36659: LD_INT 1
36661: PUSH
36662: LD_INT 0
36664: PUSH
36665: EMPTY
36666: LIST
36667: LIST
36668: PUSH
36669: LD_INT 1
36671: PUSH
36672: LD_INT 1
36674: PUSH
36675: EMPTY
36676: LIST
36677: LIST
36678: PUSH
36679: LD_INT 0
36681: PUSH
36682: LD_INT 1
36684: PUSH
36685: EMPTY
36686: LIST
36687: LIST
36688: PUSH
36689: LD_INT 1
36691: NEG
36692: PUSH
36693: LD_INT 0
36695: PUSH
36696: EMPTY
36697: LIST
36698: LIST
36699: PUSH
36700: LD_INT 1
36702: NEG
36703: PUSH
36704: LD_INT 1
36706: NEG
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 1
36714: NEG
36715: PUSH
36716: LD_INT 2
36718: NEG
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: LD_INT 0
36726: PUSH
36727: LD_INT 2
36729: NEG
36730: PUSH
36731: EMPTY
36732: LIST
36733: LIST
36734: PUSH
36735: LD_INT 1
36737: PUSH
36738: LD_INT 1
36740: NEG
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: PUSH
36746: LD_INT 2
36748: PUSH
36749: LD_INT 0
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 2
36758: PUSH
36759: LD_INT 1
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: LD_INT 2
36768: PUSH
36769: LD_INT 2
36771: PUSH
36772: EMPTY
36773: LIST
36774: LIST
36775: PUSH
36776: LD_INT 1
36778: PUSH
36779: LD_INT 2
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: PUSH
36786: LD_INT 0
36788: PUSH
36789: LD_INT 2
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: LD_INT 1
36798: NEG
36799: PUSH
36800: LD_INT 1
36802: PUSH
36803: EMPTY
36804: LIST
36805: LIST
36806: PUSH
36807: LD_INT 2
36809: NEG
36810: PUSH
36811: LD_INT 0
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 2
36820: NEG
36821: PUSH
36822: LD_INT 1
36824: NEG
36825: PUSH
36826: EMPTY
36827: LIST
36828: LIST
36829: PUSH
36830: LD_INT 2
36832: NEG
36833: PUSH
36834: LD_INT 2
36836: NEG
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: LIST
36849: LIST
36850: LIST
36851: LIST
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: LIST
36857: LIST
36858: LIST
36859: LIST
36860: LIST
36861: LIST
36862: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36863: LD_ADDR_VAR 0 57
36867: PUSH
36868: LD_INT 0
36870: PUSH
36871: LD_INT 0
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 0
36880: PUSH
36881: LD_INT 1
36883: NEG
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 1
36891: PUSH
36892: LD_INT 0
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 1
36901: PUSH
36902: LD_INT 1
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 0
36911: PUSH
36912: LD_INT 1
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: LD_INT 1
36921: NEG
36922: PUSH
36923: LD_INT 0
36925: PUSH
36926: EMPTY
36927: LIST
36928: LIST
36929: PUSH
36930: LD_INT 1
36932: NEG
36933: PUSH
36934: LD_INT 1
36936: NEG
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: PUSH
36942: LD_INT 1
36944: NEG
36945: PUSH
36946: LD_INT 2
36948: NEG
36949: PUSH
36950: EMPTY
36951: LIST
36952: LIST
36953: PUSH
36954: LD_INT 0
36956: PUSH
36957: LD_INT 2
36959: NEG
36960: PUSH
36961: EMPTY
36962: LIST
36963: LIST
36964: PUSH
36965: LD_INT 1
36967: PUSH
36968: LD_INT 1
36970: NEG
36971: PUSH
36972: EMPTY
36973: LIST
36974: LIST
36975: PUSH
36976: LD_INT 2
36978: PUSH
36979: LD_INT 0
36981: PUSH
36982: EMPTY
36983: LIST
36984: LIST
36985: PUSH
36986: LD_INT 2
36988: PUSH
36989: LD_INT 1
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 2
36998: PUSH
36999: LD_INT 2
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: PUSH
37006: LD_INT 1
37008: PUSH
37009: LD_INT 2
37011: PUSH
37012: EMPTY
37013: LIST
37014: LIST
37015: PUSH
37016: LD_INT 0
37018: PUSH
37019: LD_INT 2
37021: PUSH
37022: EMPTY
37023: LIST
37024: LIST
37025: PUSH
37026: LD_INT 1
37028: NEG
37029: PUSH
37030: LD_INT 1
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 2
37039: NEG
37040: PUSH
37041: LD_INT 0
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 2
37050: NEG
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 2
37062: NEG
37063: PUSH
37064: LD_INT 2
37066: NEG
37067: PUSH
37068: EMPTY
37069: LIST
37070: LIST
37071: PUSH
37072: EMPTY
37073: LIST
37074: LIST
37075: LIST
37076: LIST
37077: LIST
37078: LIST
37079: LIST
37080: LIST
37081: LIST
37082: LIST
37083: LIST
37084: LIST
37085: LIST
37086: LIST
37087: LIST
37088: LIST
37089: LIST
37090: LIST
37091: LIST
37092: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37093: LD_ADDR_VAR 0 58
37097: PUSH
37098: LD_INT 0
37100: PUSH
37101: LD_INT 0
37103: PUSH
37104: EMPTY
37105: LIST
37106: LIST
37107: PUSH
37108: LD_INT 0
37110: PUSH
37111: LD_INT 1
37113: NEG
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 1
37121: PUSH
37122: LD_INT 0
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: PUSH
37129: LD_INT 1
37131: PUSH
37132: LD_INT 1
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 0
37141: PUSH
37142: LD_INT 1
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 1
37151: NEG
37152: PUSH
37153: LD_INT 0
37155: PUSH
37156: EMPTY
37157: LIST
37158: LIST
37159: PUSH
37160: LD_INT 1
37162: NEG
37163: PUSH
37164: LD_INT 1
37166: NEG
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: PUSH
37172: LD_INT 1
37174: NEG
37175: PUSH
37176: LD_INT 2
37178: NEG
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 0
37186: PUSH
37187: LD_INT 2
37189: NEG
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: LD_INT 1
37200: NEG
37201: PUSH
37202: EMPTY
37203: LIST
37204: LIST
37205: PUSH
37206: LD_INT 2
37208: PUSH
37209: LD_INT 0
37211: PUSH
37212: EMPTY
37213: LIST
37214: LIST
37215: PUSH
37216: LD_INT 2
37218: PUSH
37219: LD_INT 1
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 2
37228: PUSH
37229: LD_INT 2
37231: PUSH
37232: EMPTY
37233: LIST
37234: LIST
37235: PUSH
37236: LD_INT 1
37238: PUSH
37239: LD_INT 2
37241: PUSH
37242: EMPTY
37243: LIST
37244: LIST
37245: PUSH
37246: LD_INT 0
37248: PUSH
37249: LD_INT 2
37251: PUSH
37252: EMPTY
37253: LIST
37254: LIST
37255: PUSH
37256: LD_INT 1
37258: NEG
37259: PUSH
37260: LD_INT 1
37262: PUSH
37263: EMPTY
37264: LIST
37265: LIST
37266: PUSH
37267: LD_INT 2
37269: NEG
37270: PUSH
37271: LD_INT 0
37273: PUSH
37274: EMPTY
37275: LIST
37276: LIST
37277: PUSH
37278: LD_INT 2
37280: NEG
37281: PUSH
37282: LD_INT 1
37284: NEG
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: PUSH
37290: LD_INT 2
37292: NEG
37293: PUSH
37294: LD_INT 2
37296: NEG
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: LIST
37306: LIST
37307: LIST
37308: LIST
37309: LIST
37310: LIST
37311: LIST
37312: LIST
37313: LIST
37314: LIST
37315: LIST
37316: LIST
37317: LIST
37318: LIST
37319: LIST
37320: LIST
37321: LIST
37322: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37323: LD_ADDR_VAR 0 59
37327: PUSH
37328: LD_INT 0
37330: PUSH
37331: LD_INT 0
37333: PUSH
37334: EMPTY
37335: LIST
37336: LIST
37337: PUSH
37338: LD_INT 0
37340: PUSH
37341: LD_INT 1
37343: NEG
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: PUSH
37349: LD_INT 1
37351: PUSH
37352: LD_INT 0
37354: PUSH
37355: EMPTY
37356: LIST
37357: LIST
37358: PUSH
37359: LD_INT 1
37361: PUSH
37362: LD_INT 1
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: LD_INT 0
37371: PUSH
37372: LD_INT 1
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 1
37381: NEG
37382: PUSH
37383: LD_INT 0
37385: PUSH
37386: EMPTY
37387: LIST
37388: LIST
37389: PUSH
37390: LD_INT 1
37392: NEG
37393: PUSH
37394: LD_INT 1
37396: NEG
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: LIST
37406: LIST
37407: LIST
37408: LIST
37409: LIST
37410: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37411: LD_ADDR_VAR 0 60
37415: PUSH
37416: LD_INT 0
37418: PUSH
37419: LD_INT 0
37421: PUSH
37422: EMPTY
37423: LIST
37424: LIST
37425: PUSH
37426: LD_INT 0
37428: PUSH
37429: LD_INT 1
37431: NEG
37432: PUSH
37433: EMPTY
37434: LIST
37435: LIST
37436: PUSH
37437: LD_INT 1
37439: PUSH
37440: LD_INT 0
37442: PUSH
37443: EMPTY
37444: LIST
37445: LIST
37446: PUSH
37447: LD_INT 1
37449: PUSH
37450: LD_INT 1
37452: PUSH
37453: EMPTY
37454: LIST
37455: LIST
37456: PUSH
37457: LD_INT 0
37459: PUSH
37460: LD_INT 1
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 1
37469: NEG
37470: PUSH
37471: LD_INT 0
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 1
37480: NEG
37481: PUSH
37482: LD_INT 1
37484: NEG
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: EMPTY
37491: LIST
37492: LIST
37493: LIST
37494: LIST
37495: LIST
37496: LIST
37497: LIST
37498: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37499: LD_ADDR_VAR 0 61
37503: PUSH
37504: LD_INT 0
37506: PUSH
37507: LD_INT 0
37509: PUSH
37510: EMPTY
37511: LIST
37512: LIST
37513: PUSH
37514: LD_INT 0
37516: PUSH
37517: LD_INT 1
37519: NEG
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: PUSH
37525: LD_INT 1
37527: PUSH
37528: LD_INT 0
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: PUSH
37535: LD_INT 1
37537: PUSH
37538: LD_INT 1
37540: PUSH
37541: EMPTY
37542: LIST
37543: LIST
37544: PUSH
37545: LD_INT 0
37547: PUSH
37548: LD_INT 1
37550: PUSH
37551: EMPTY
37552: LIST
37553: LIST
37554: PUSH
37555: LD_INT 1
37557: NEG
37558: PUSH
37559: LD_INT 0
37561: PUSH
37562: EMPTY
37563: LIST
37564: LIST
37565: PUSH
37566: LD_INT 1
37568: NEG
37569: PUSH
37570: LD_INT 1
37572: NEG
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37587: LD_ADDR_VAR 0 62
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: LD_INT 0
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: LD_INT 0
37604: PUSH
37605: LD_INT 1
37607: NEG
37608: PUSH
37609: EMPTY
37610: LIST
37611: LIST
37612: PUSH
37613: LD_INT 1
37615: PUSH
37616: LD_INT 0
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: PUSH
37623: LD_INT 1
37625: PUSH
37626: LD_INT 1
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 0
37635: PUSH
37636: LD_INT 1
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PUSH
37643: LD_INT 1
37645: NEG
37646: PUSH
37647: LD_INT 0
37649: PUSH
37650: EMPTY
37651: LIST
37652: LIST
37653: PUSH
37654: LD_INT 1
37656: NEG
37657: PUSH
37658: LD_INT 1
37660: NEG
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: PUSH
37666: EMPTY
37667: LIST
37668: LIST
37669: LIST
37670: LIST
37671: LIST
37672: LIST
37673: LIST
37674: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37675: LD_ADDR_VAR 0 63
37679: PUSH
37680: LD_INT 0
37682: PUSH
37683: LD_INT 0
37685: PUSH
37686: EMPTY
37687: LIST
37688: LIST
37689: PUSH
37690: LD_INT 0
37692: PUSH
37693: LD_INT 1
37695: NEG
37696: PUSH
37697: EMPTY
37698: LIST
37699: LIST
37700: PUSH
37701: LD_INT 1
37703: PUSH
37704: LD_INT 0
37706: PUSH
37707: EMPTY
37708: LIST
37709: LIST
37710: PUSH
37711: LD_INT 1
37713: PUSH
37714: LD_INT 1
37716: PUSH
37717: EMPTY
37718: LIST
37719: LIST
37720: PUSH
37721: LD_INT 0
37723: PUSH
37724: LD_INT 1
37726: PUSH
37727: EMPTY
37728: LIST
37729: LIST
37730: PUSH
37731: LD_INT 1
37733: NEG
37734: PUSH
37735: LD_INT 0
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: PUSH
37742: LD_INT 1
37744: NEG
37745: PUSH
37746: LD_INT 1
37748: NEG
37749: PUSH
37750: EMPTY
37751: LIST
37752: LIST
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: LIST
37758: LIST
37759: LIST
37760: LIST
37761: LIST
37762: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37763: LD_ADDR_VAR 0 64
37767: PUSH
37768: LD_INT 0
37770: PUSH
37771: LD_INT 0
37773: PUSH
37774: EMPTY
37775: LIST
37776: LIST
37777: PUSH
37778: LD_INT 0
37780: PUSH
37781: LD_INT 1
37783: NEG
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 1
37791: PUSH
37792: LD_INT 0
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: LD_INT 1
37801: PUSH
37802: LD_INT 1
37804: PUSH
37805: EMPTY
37806: LIST
37807: LIST
37808: PUSH
37809: LD_INT 0
37811: PUSH
37812: LD_INT 1
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 1
37821: NEG
37822: PUSH
37823: LD_INT 0
37825: PUSH
37826: EMPTY
37827: LIST
37828: LIST
37829: PUSH
37830: LD_INT 1
37832: NEG
37833: PUSH
37834: LD_INT 1
37836: NEG
37837: PUSH
37838: EMPTY
37839: LIST
37840: LIST
37841: PUSH
37842: EMPTY
37843: LIST
37844: LIST
37845: LIST
37846: LIST
37847: LIST
37848: LIST
37849: LIST
37850: ST_TO_ADDR
// end ; 1 :
37851: GO 43748
37853: LD_INT 1
37855: DOUBLE
37856: EQUAL
37857: IFTRUE 37861
37859: GO 40484
37861: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37862: LD_ADDR_VAR 0 11
37866: PUSH
37867: LD_INT 1
37869: NEG
37870: PUSH
37871: LD_INT 3
37873: NEG
37874: PUSH
37875: EMPTY
37876: LIST
37877: LIST
37878: PUSH
37879: LD_INT 0
37881: PUSH
37882: LD_INT 3
37884: NEG
37885: PUSH
37886: EMPTY
37887: LIST
37888: LIST
37889: PUSH
37890: LD_INT 1
37892: PUSH
37893: LD_INT 2
37895: NEG
37896: PUSH
37897: EMPTY
37898: LIST
37899: LIST
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: LIST
37905: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37906: LD_ADDR_VAR 0 12
37910: PUSH
37911: LD_INT 2
37913: PUSH
37914: LD_INT 1
37916: NEG
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: PUSH
37922: LD_INT 3
37924: PUSH
37925: LD_INT 0
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: LD_INT 3
37934: PUSH
37935: LD_INT 1
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PUSH
37942: EMPTY
37943: LIST
37944: LIST
37945: LIST
37946: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37947: LD_ADDR_VAR 0 13
37951: PUSH
37952: LD_INT 3
37954: PUSH
37955: LD_INT 2
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 3
37964: PUSH
37965: LD_INT 3
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: LD_INT 2
37974: PUSH
37975: LD_INT 3
37977: PUSH
37978: EMPTY
37979: LIST
37980: LIST
37981: PUSH
37982: EMPTY
37983: LIST
37984: LIST
37985: LIST
37986: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37987: LD_ADDR_VAR 0 14
37991: PUSH
37992: LD_INT 1
37994: PUSH
37995: LD_INT 3
37997: PUSH
37998: EMPTY
37999: LIST
38000: LIST
38001: PUSH
38002: LD_INT 0
38004: PUSH
38005: LD_INT 3
38007: PUSH
38008: EMPTY
38009: LIST
38010: LIST
38011: PUSH
38012: LD_INT 1
38014: NEG
38015: PUSH
38016: LD_INT 2
38018: PUSH
38019: EMPTY
38020: LIST
38021: LIST
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: LIST
38027: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38028: LD_ADDR_VAR 0 15
38032: PUSH
38033: LD_INT 2
38035: NEG
38036: PUSH
38037: LD_INT 1
38039: PUSH
38040: EMPTY
38041: LIST
38042: LIST
38043: PUSH
38044: LD_INT 3
38046: NEG
38047: PUSH
38048: LD_INT 0
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 3
38057: NEG
38058: PUSH
38059: LD_INT 1
38061: NEG
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: LIST
38071: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38072: LD_ADDR_VAR 0 16
38076: PUSH
38077: LD_INT 2
38079: NEG
38080: PUSH
38081: LD_INT 3
38083: NEG
38084: PUSH
38085: EMPTY
38086: LIST
38087: LIST
38088: PUSH
38089: LD_INT 3
38091: NEG
38092: PUSH
38093: LD_INT 2
38095: NEG
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: LD_INT 3
38103: NEG
38104: PUSH
38105: LD_INT 3
38107: NEG
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: LIST
38117: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38118: LD_ADDR_VAR 0 17
38122: PUSH
38123: LD_INT 1
38125: NEG
38126: PUSH
38127: LD_INT 3
38129: NEG
38130: PUSH
38131: EMPTY
38132: LIST
38133: LIST
38134: PUSH
38135: LD_INT 0
38137: PUSH
38138: LD_INT 3
38140: NEG
38141: PUSH
38142: EMPTY
38143: LIST
38144: LIST
38145: PUSH
38146: LD_INT 1
38148: PUSH
38149: LD_INT 2
38151: NEG
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: LIST
38161: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38162: LD_ADDR_VAR 0 18
38166: PUSH
38167: LD_INT 2
38169: PUSH
38170: LD_INT 1
38172: NEG
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 3
38180: PUSH
38181: LD_INT 0
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: LD_INT 3
38190: PUSH
38191: LD_INT 1
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: LIST
38202: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38203: LD_ADDR_VAR 0 19
38207: PUSH
38208: LD_INT 3
38210: PUSH
38211: LD_INT 2
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 3
38220: PUSH
38221: LD_INT 3
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: LD_INT 2
38230: PUSH
38231: LD_INT 3
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: EMPTY
38239: LIST
38240: LIST
38241: LIST
38242: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38243: LD_ADDR_VAR 0 20
38247: PUSH
38248: LD_INT 1
38250: PUSH
38251: LD_INT 3
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: PUSH
38258: LD_INT 0
38260: PUSH
38261: LD_INT 3
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 1
38270: NEG
38271: PUSH
38272: LD_INT 2
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: EMPTY
38280: LIST
38281: LIST
38282: LIST
38283: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38284: LD_ADDR_VAR 0 21
38288: PUSH
38289: LD_INT 2
38291: NEG
38292: PUSH
38293: LD_INT 1
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 3
38302: NEG
38303: PUSH
38304: LD_INT 0
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 3
38313: NEG
38314: PUSH
38315: LD_INT 1
38317: NEG
38318: PUSH
38319: EMPTY
38320: LIST
38321: LIST
38322: PUSH
38323: EMPTY
38324: LIST
38325: LIST
38326: LIST
38327: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38328: LD_ADDR_VAR 0 22
38332: PUSH
38333: LD_INT 2
38335: NEG
38336: PUSH
38337: LD_INT 3
38339: NEG
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: PUSH
38345: LD_INT 3
38347: NEG
38348: PUSH
38349: LD_INT 2
38351: NEG
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: PUSH
38357: LD_INT 3
38359: NEG
38360: PUSH
38361: LD_INT 3
38363: NEG
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: EMPTY
38370: LIST
38371: LIST
38372: LIST
38373: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
38374: LD_ADDR_VAR 0 23
38378: PUSH
38379: LD_INT 0
38381: PUSH
38382: LD_INT 3
38384: NEG
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 1
38392: NEG
38393: PUSH
38394: LD_INT 4
38396: NEG
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: PUSH
38402: LD_INT 1
38404: PUSH
38405: LD_INT 3
38407: NEG
38408: PUSH
38409: EMPTY
38410: LIST
38411: LIST
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: LIST
38417: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
38418: LD_ADDR_VAR 0 24
38422: PUSH
38423: LD_INT 3
38425: PUSH
38426: LD_INT 0
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: PUSH
38433: LD_INT 3
38435: PUSH
38436: LD_INT 1
38438: NEG
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: PUSH
38444: LD_INT 4
38446: PUSH
38447: LD_INT 1
38449: PUSH
38450: EMPTY
38451: LIST
38452: LIST
38453: PUSH
38454: EMPTY
38455: LIST
38456: LIST
38457: LIST
38458: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
38459: LD_ADDR_VAR 0 25
38463: PUSH
38464: LD_INT 3
38466: PUSH
38467: LD_INT 3
38469: PUSH
38470: EMPTY
38471: LIST
38472: LIST
38473: PUSH
38474: LD_INT 4
38476: PUSH
38477: LD_INT 3
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PUSH
38484: LD_INT 3
38486: PUSH
38487: LD_INT 4
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: LIST
38498: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
38499: LD_ADDR_VAR 0 26
38503: PUSH
38504: LD_INT 0
38506: PUSH
38507: LD_INT 3
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: LD_INT 1
38516: PUSH
38517: LD_INT 4
38519: PUSH
38520: EMPTY
38521: LIST
38522: LIST
38523: PUSH
38524: LD_INT 1
38526: NEG
38527: PUSH
38528: LD_INT 3
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: PUSH
38535: EMPTY
38536: LIST
38537: LIST
38538: LIST
38539: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
38540: LD_ADDR_VAR 0 27
38544: PUSH
38545: LD_INT 3
38547: NEG
38548: PUSH
38549: LD_INT 0
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 3
38558: NEG
38559: PUSH
38560: LD_INT 1
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: PUSH
38567: LD_INT 4
38569: NEG
38570: PUSH
38571: LD_INT 1
38573: NEG
38574: PUSH
38575: EMPTY
38576: LIST
38577: LIST
38578: PUSH
38579: EMPTY
38580: LIST
38581: LIST
38582: LIST
38583: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
38584: LD_ADDR_VAR 0 28
38588: PUSH
38589: LD_INT 3
38591: NEG
38592: PUSH
38593: LD_INT 3
38595: NEG
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: PUSH
38601: LD_INT 3
38603: NEG
38604: PUSH
38605: LD_INT 4
38607: NEG
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: PUSH
38613: LD_INT 4
38615: NEG
38616: PUSH
38617: LD_INT 3
38619: NEG
38620: PUSH
38621: EMPTY
38622: LIST
38623: LIST
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: LIST
38629: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
38630: LD_ADDR_VAR 0 29
38634: PUSH
38635: LD_INT 1
38637: NEG
38638: PUSH
38639: LD_INT 3
38641: NEG
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 0
38649: PUSH
38650: LD_INT 3
38652: NEG
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 1
38660: PUSH
38661: LD_INT 2
38663: NEG
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 1
38671: NEG
38672: PUSH
38673: LD_INT 4
38675: NEG
38676: PUSH
38677: EMPTY
38678: LIST
38679: LIST
38680: PUSH
38681: LD_INT 0
38683: PUSH
38684: LD_INT 4
38686: NEG
38687: PUSH
38688: EMPTY
38689: LIST
38690: LIST
38691: PUSH
38692: LD_INT 1
38694: PUSH
38695: LD_INT 3
38697: NEG
38698: PUSH
38699: EMPTY
38700: LIST
38701: LIST
38702: PUSH
38703: LD_INT 1
38705: NEG
38706: PUSH
38707: LD_INT 5
38709: NEG
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 0
38717: PUSH
38718: LD_INT 5
38720: NEG
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: LD_INT 1
38728: PUSH
38729: LD_INT 4
38731: NEG
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: LD_INT 1
38739: NEG
38740: PUSH
38741: LD_INT 6
38743: NEG
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: PUSH
38749: LD_INT 0
38751: PUSH
38752: LD_INT 6
38754: NEG
38755: PUSH
38756: EMPTY
38757: LIST
38758: LIST
38759: PUSH
38760: LD_INT 1
38762: PUSH
38763: LD_INT 5
38765: NEG
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: LIST
38775: LIST
38776: LIST
38777: LIST
38778: LIST
38779: LIST
38780: LIST
38781: LIST
38782: LIST
38783: LIST
38784: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
38785: LD_ADDR_VAR 0 30
38789: PUSH
38790: LD_INT 2
38792: PUSH
38793: LD_INT 1
38795: NEG
38796: PUSH
38797: EMPTY
38798: LIST
38799: LIST
38800: PUSH
38801: LD_INT 3
38803: PUSH
38804: LD_INT 0
38806: PUSH
38807: EMPTY
38808: LIST
38809: LIST
38810: PUSH
38811: LD_INT 3
38813: PUSH
38814: LD_INT 1
38816: PUSH
38817: EMPTY
38818: LIST
38819: LIST
38820: PUSH
38821: LD_INT 3
38823: PUSH
38824: LD_INT 1
38826: NEG
38827: PUSH
38828: EMPTY
38829: LIST
38830: LIST
38831: PUSH
38832: LD_INT 4
38834: PUSH
38835: LD_INT 0
38837: PUSH
38838: EMPTY
38839: LIST
38840: LIST
38841: PUSH
38842: LD_INT 4
38844: PUSH
38845: LD_INT 1
38847: PUSH
38848: EMPTY
38849: LIST
38850: LIST
38851: PUSH
38852: LD_INT 4
38854: PUSH
38855: LD_INT 1
38857: NEG
38858: PUSH
38859: EMPTY
38860: LIST
38861: LIST
38862: PUSH
38863: LD_INT 5
38865: PUSH
38866: LD_INT 0
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: PUSH
38873: LD_INT 5
38875: PUSH
38876: LD_INT 1
38878: PUSH
38879: EMPTY
38880: LIST
38881: LIST
38882: PUSH
38883: LD_INT 5
38885: PUSH
38886: LD_INT 1
38888: NEG
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: PUSH
38894: LD_INT 6
38896: PUSH
38897: LD_INT 0
38899: PUSH
38900: EMPTY
38901: LIST
38902: LIST
38903: PUSH
38904: LD_INT 6
38906: PUSH
38907: LD_INT 1
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: LIST
38918: LIST
38919: LIST
38920: LIST
38921: LIST
38922: LIST
38923: LIST
38924: LIST
38925: LIST
38926: LIST
38927: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
38928: LD_ADDR_VAR 0 31
38932: PUSH
38933: LD_INT 3
38935: PUSH
38936: LD_INT 2
38938: PUSH
38939: EMPTY
38940: LIST
38941: LIST
38942: PUSH
38943: LD_INT 3
38945: PUSH
38946: LD_INT 3
38948: PUSH
38949: EMPTY
38950: LIST
38951: LIST
38952: PUSH
38953: LD_INT 2
38955: PUSH
38956: LD_INT 3
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PUSH
38963: LD_INT 4
38965: PUSH
38966: LD_INT 3
38968: PUSH
38969: EMPTY
38970: LIST
38971: LIST
38972: PUSH
38973: LD_INT 4
38975: PUSH
38976: LD_INT 4
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PUSH
38983: LD_INT 3
38985: PUSH
38986: LD_INT 4
38988: PUSH
38989: EMPTY
38990: LIST
38991: LIST
38992: PUSH
38993: LD_INT 5
38995: PUSH
38996: LD_INT 4
38998: PUSH
38999: EMPTY
39000: LIST
39001: LIST
39002: PUSH
39003: LD_INT 5
39005: PUSH
39006: LD_INT 5
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 4
39015: PUSH
39016: LD_INT 5
39018: PUSH
39019: EMPTY
39020: LIST
39021: LIST
39022: PUSH
39023: LD_INT 6
39025: PUSH
39026: LD_INT 5
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: PUSH
39033: LD_INT 6
39035: PUSH
39036: LD_INT 6
39038: PUSH
39039: EMPTY
39040: LIST
39041: LIST
39042: PUSH
39043: LD_INT 5
39045: PUSH
39046: LD_INT 6
39048: PUSH
39049: EMPTY
39050: LIST
39051: LIST
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: LIST
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
39067: LD_ADDR_VAR 0 32
39071: PUSH
39072: LD_INT 1
39074: PUSH
39075: LD_INT 3
39077: PUSH
39078: EMPTY
39079: LIST
39080: LIST
39081: PUSH
39082: LD_INT 0
39084: PUSH
39085: LD_INT 3
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: PUSH
39092: LD_INT 1
39094: NEG
39095: PUSH
39096: LD_INT 2
39098: PUSH
39099: EMPTY
39100: LIST
39101: LIST
39102: PUSH
39103: LD_INT 1
39105: PUSH
39106: LD_INT 4
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: LD_INT 0
39115: PUSH
39116: LD_INT 4
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PUSH
39123: LD_INT 1
39125: NEG
39126: PUSH
39127: LD_INT 3
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 1
39136: PUSH
39137: LD_INT 5
39139: PUSH
39140: EMPTY
39141: LIST
39142: LIST
39143: PUSH
39144: LD_INT 0
39146: PUSH
39147: LD_INT 5
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: LD_INT 1
39156: NEG
39157: PUSH
39158: LD_INT 4
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: PUSH
39165: LD_INT 1
39167: PUSH
39168: LD_INT 6
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: PUSH
39175: LD_INT 0
39177: PUSH
39178: LD_INT 6
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 1
39187: NEG
39188: PUSH
39189: LD_INT 5
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: LIST
39200: LIST
39201: LIST
39202: LIST
39203: LIST
39204: LIST
39205: LIST
39206: LIST
39207: LIST
39208: LIST
39209: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
39210: LD_ADDR_VAR 0 33
39214: PUSH
39215: LD_INT 2
39217: NEG
39218: PUSH
39219: LD_INT 1
39221: PUSH
39222: EMPTY
39223: LIST
39224: LIST
39225: PUSH
39226: LD_INT 3
39228: NEG
39229: PUSH
39230: LD_INT 0
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PUSH
39237: LD_INT 3
39239: NEG
39240: PUSH
39241: LD_INT 1
39243: NEG
39244: PUSH
39245: EMPTY
39246: LIST
39247: LIST
39248: PUSH
39249: LD_INT 3
39251: NEG
39252: PUSH
39253: LD_INT 1
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: LD_INT 4
39262: NEG
39263: PUSH
39264: LD_INT 0
39266: PUSH
39267: EMPTY
39268: LIST
39269: LIST
39270: PUSH
39271: LD_INT 4
39273: NEG
39274: PUSH
39275: LD_INT 1
39277: NEG
39278: PUSH
39279: EMPTY
39280: LIST
39281: LIST
39282: PUSH
39283: LD_INT 4
39285: NEG
39286: PUSH
39287: LD_INT 1
39289: PUSH
39290: EMPTY
39291: LIST
39292: LIST
39293: PUSH
39294: LD_INT 5
39296: NEG
39297: PUSH
39298: LD_INT 0
39300: PUSH
39301: EMPTY
39302: LIST
39303: LIST
39304: PUSH
39305: LD_INT 5
39307: NEG
39308: PUSH
39309: LD_INT 1
39311: NEG
39312: PUSH
39313: EMPTY
39314: LIST
39315: LIST
39316: PUSH
39317: LD_INT 5
39319: NEG
39320: PUSH
39321: LD_INT 1
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: PUSH
39328: LD_INT 6
39330: NEG
39331: PUSH
39332: LD_INT 0
39334: PUSH
39335: EMPTY
39336: LIST
39337: LIST
39338: PUSH
39339: LD_INT 6
39341: NEG
39342: PUSH
39343: LD_INT 1
39345: NEG
39346: PUSH
39347: EMPTY
39348: LIST
39349: LIST
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: LIST
39358: LIST
39359: LIST
39360: LIST
39361: LIST
39362: LIST
39363: LIST
39364: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
39365: LD_ADDR_VAR 0 34
39369: PUSH
39370: LD_INT 2
39372: NEG
39373: PUSH
39374: LD_INT 3
39376: NEG
39377: PUSH
39378: EMPTY
39379: LIST
39380: LIST
39381: PUSH
39382: LD_INT 3
39384: NEG
39385: PUSH
39386: LD_INT 2
39388: NEG
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 3
39396: NEG
39397: PUSH
39398: LD_INT 3
39400: NEG
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 3
39408: NEG
39409: PUSH
39410: LD_INT 4
39412: NEG
39413: PUSH
39414: EMPTY
39415: LIST
39416: LIST
39417: PUSH
39418: LD_INT 4
39420: NEG
39421: PUSH
39422: LD_INT 3
39424: NEG
39425: PUSH
39426: EMPTY
39427: LIST
39428: LIST
39429: PUSH
39430: LD_INT 4
39432: NEG
39433: PUSH
39434: LD_INT 4
39436: NEG
39437: PUSH
39438: EMPTY
39439: LIST
39440: LIST
39441: PUSH
39442: LD_INT 4
39444: NEG
39445: PUSH
39446: LD_INT 5
39448: NEG
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: PUSH
39454: LD_INT 5
39456: NEG
39457: PUSH
39458: LD_INT 4
39460: NEG
39461: PUSH
39462: EMPTY
39463: LIST
39464: LIST
39465: PUSH
39466: LD_INT 5
39468: NEG
39469: PUSH
39470: LD_INT 5
39472: NEG
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: LD_INT 5
39480: NEG
39481: PUSH
39482: LD_INT 6
39484: NEG
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 6
39492: NEG
39493: PUSH
39494: LD_INT 5
39496: NEG
39497: PUSH
39498: EMPTY
39499: LIST
39500: LIST
39501: PUSH
39502: LD_INT 6
39504: NEG
39505: PUSH
39506: LD_INT 6
39508: NEG
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: LIST
39520: LIST
39521: LIST
39522: LIST
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
39528: LD_ADDR_VAR 0 41
39532: PUSH
39533: LD_INT 0
39535: PUSH
39536: LD_INT 2
39538: NEG
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PUSH
39544: LD_INT 1
39546: NEG
39547: PUSH
39548: LD_INT 3
39550: NEG
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PUSH
39556: LD_INT 1
39558: PUSH
39559: LD_INT 2
39561: NEG
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: LIST
39571: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
39572: LD_ADDR_VAR 0 42
39576: PUSH
39577: LD_INT 2
39579: PUSH
39580: LD_INT 0
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 2
39589: PUSH
39590: LD_INT 1
39592: NEG
39593: PUSH
39594: EMPTY
39595: LIST
39596: LIST
39597: PUSH
39598: LD_INT 3
39600: PUSH
39601: LD_INT 1
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: PUSH
39608: EMPTY
39609: LIST
39610: LIST
39611: LIST
39612: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
39613: LD_ADDR_VAR 0 43
39617: PUSH
39618: LD_INT 2
39620: PUSH
39621: LD_INT 2
39623: PUSH
39624: EMPTY
39625: LIST
39626: LIST
39627: PUSH
39628: LD_INT 3
39630: PUSH
39631: LD_INT 2
39633: PUSH
39634: EMPTY
39635: LIST
39636: LIST
39637: PUSH
39638: LD_INT 2
39640: PUSH
39641: LD_INT 3
39643: PUSH
39644: EMPTY
39645: LIST
39646: LIST
39647: PUSH
39648: EMPTY
39649: LIST
39650: LIST
39651: LIST
39652: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
39653: LD_ADDR_VAR 0 44
39657: PUSH
39658: LD_INT 0
39660: PUSH
39661: LD_INT 2
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PUSH
39668: LD_INT 1
39670: PUSH
39671: LD_INT 3
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: LD_INT 1
39680: NEG
39681: PUSH
39682: LD_INT 2
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: EMPTY
39690: LIST
39691: LIST
39692: LIST
39693: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39694: LD_ADDR_VAR 0 45
39698: PUSH
39699: LD_INT 2
39701: NEG
39702: PUSH
39703: LD_INT 0
39705: PUSH
39706: EMPTY
39707: LIST
39708: LIST
39709: PUSH
39710: LD_INT 2
39712: NEG
39713: PUSH
39714: LD_INT 1
39716: PUSH
39717: EMPTY
39718: LIST
39719: LIST
39720: PUSH
39721: LD_INT 3
39723: NEG
39724: PUSH
39725: LD_INT 1
39727: NEG
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: LIST
39737: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
39738: LD_ADDR_VAR 0 46
39742: PUSH
39743: LD_INT 2
39745: NEG
39746: PUSH
39747: LD_INT 2
39749: NEG
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: PUSH
39755: LD_INT 2
39757: NEG
39758: PUSH
39759: LD_INT 3
39761: NEG
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PUSH
39767: LD_INT 3
39769: NEG
39770: PUSH
39771: LD_INT 2
39773: NEG
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: EMPTY
39780: LIST
39781: LIST
39782: LIST
39783: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
39784: LD_ADDR_VAR 0 47
39788: PUSH
39789: LD_INT 2
39791: NEG
39792: PUSH
39793: LD_INT 3
39795: NEG
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 1
39803: NEG
39804: PUSH
39805: LD_INT 3
39807: NEG
39808: PUSH
39809: EMPTY
39810: LIST
39811: LIST
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
39817: LD_ADDR_VAR 0 48
39821: PUSH
39822: LD_INT 1
39824: PUSH
39825: LD_INT 2
39827: NEG
39828: PUSH
39829: EMPTY
39830: LIST
39831: LIST
39832: PUSH
39833: LD_INT 2
39835: PUSH
39836: LD_INT 1
39838: NEG
39839: PUSH
39840: EMPTY
39841: LIST
39842: LIST
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
39848: LD_ADDR_VAR 0 49
39852: PUSH
39853: LD_INT 3
39855: PUSH
39856: LD_INT 1
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: LD_INT 3
39865: PUSH
39866: LD_INT 2
39868: PUSH
39869: EMPTY
39870: LIST
39871: LIST
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
39877: LD_ADDR_VAR 0 50
39881: PUSH
39882: LD_INT 2
39884: PUSH
39885: LD_INT 3
39887: PUSH
39888: EMPTY
39889: LIST
39890: LIST
39891: PUSH
39892: LD_INT 1
39894: PUSH
39895: LD_INT 3
39897: PUSH
39898: EMPTY
39899: LIST
39900: LIST
39901: PUSH
39902: EMPTY
39903: LIST
39904: LIST
39905: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
39906: LD_ADDR_VAR 0 51
39910: PUSH
39911: LD_INT 1
39913: NEG
39914: PUSH
39915: LD_INT 2
39917: PUSH
39918: EMPTY
39919: LIST
39920: LIST
39921: PUSH
39922: LD_INT 2
39924: NEG
39925: PUSH
39926: LD_INT 1
39928: PUSH
39929: EMPTY
39930: LIST
39931: LIST
39932: PUSH
39933: EMPTY
39934: LIST
39935: LIST
39936: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
39937: LD_ADDR_VAR 0 52
39941: PUSH
39942: LD_INT 3
39944: NEG
39945: PUSH
39946: LD_INT 1
39948: NEG
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: LD_INT 3
39956: NEG
39957: PUSH
39958: LD_INT 2
39960: NEG
39961: PUSH
39962: EMPTY
39963: LIST
39964: LIST
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39970: LD_ADDR_VAR 0 53
39974: PUSH
39975: LD_INT 1
39977: NEG
39978: PUSH
39979: LD_INT 3
39981: NEG
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: LD_INT 0
39989: PUSH
39990: LD_INT 3
39992: NEG
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 1
40000: PUSH
40001: LD_INT 2
40003: NEG
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: LIST
40013: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40014: LD_ADDR_VAR 0 54
40018: PUSH
40019: LD_INT 2
40021: PUSH
40022: LD_INT 1
40024: NEG
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: PUSH
40030: LD_INT 3
40032: PUSH
40033: LD_INT 0
40035: PUSH
40036: EMPTY
40037: LIST
40038: LIST
40039: PUSH
40040: LD_INT 3
40042: PUSH
40043: LD_INT 1
40045: PUSH
40046: EMPTY
40047: LIST
40048: LIST
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: LIST
40054: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40055: LD_ADDR_VAR 0 55
40059: PUSH
40060: LD_INT 3
40062: PUSH
40063: LD_INT 2
40065: PUSH
40066: EMPTY
40067: LIST
40068: LIST
40069: PUSH
40070: LD_INT 3
40072: PUSH
40073: LD_INT 3
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 2
40082: PUSH
40083: LD_INT 3
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: LIST
40094: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40095: LD_ADDR_VAR 0 56
40099: PUSH
40100: LD_INT 1
40102: PUSH
40103: LD_INT 3
40105: PUSH
40106: EMPTY
40107: LIST
40108: LIST
40109: PUSH
40110: LD_INT 0
40112: PUSH
40113: LD_INT 3
40115: PUSH
40116: EMPTY
40117: LIST
40118: LIST
40119: PUSH
40120: LD_INT 1
40122: NEG
40123: PUSH
40124: LD_INT 2
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PUSH
40131: EMPTY
40132: LIST
40133: LIST
40134: LIST
40135: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40136: LD_ADDR_VAR 0 57
40140: PUSH
40141: LD_INT 2
40143: NEG
40144: PUSH
40145: LD_INT 1
40147: PUSH
40148: EMPTY
40149: LIST
40150: LIST
40151: PUSH
40152: LD_INT 3
40154: NEG
40155: PUSH
40156: LD_INT 0
40158: PUSH
40159: EMPTY
40160: LIST
40161: LIST
40162: PUSH
40163: LD_INT 3
40165: NEG
40166: PUSH
40167: LD_INT 1
40169: NEG
40170: PUSH
40171: EMPTY
40172: LIST
40173: LIST
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: LIST
40179: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40180: LD_ADDR_VAR 0 58
40184: PUSH
40185: LD_INT 2
40187: NEG
40188: PUSH
40189: LD_INT 3
40191: NEG
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PUSH
40197: LD_INT 3
40199: NEG
40200: PUSH
40201: LD_INT 2
40203: NEG
40204: PUSH
40205: EMPTY
40206: LIST
40207: LIST
40208: PUSH
40209: LD_INT 3
40211: NEG
40212: PUSH
40213: LD_INT 3
40215: NEG
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: LIST
40225: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
40226: LD_ADDR_VAR 0 59
40230: PUSH
40231: LD_INT 1
40233: NEG
40234: PUSH
40235: LD_INT 2
40237: NEG
40238: PUSH
40239: EMPTY
40240: LIST
40241: LIST
40242: PUSH
40243: LD_INT 0
40245: PUSH
40246: LD_INT 2
40248: NEG
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 1
40256: PUSH
40257: LD_INT 1
40259: NEG
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: LIST
40269: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
40270: LD_ADDR_VAR 0 60
40274: PUSH
40275: LD_INT 1
40277: PUSH
40278: LD_INT 1
40280: NEG
40281: PUSH
40282: EMPTY
40283: LIST
40284: LIST
40285: PUSH
40286: LD_INT 2
40288: PUSH
40289: LD_INT 0
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PUSH
40296: LD_INT 2
40298: PUSH
40299: LD_INT 1
40301: PUSH
40302: EMPTY
40303: LIST
40304: LIST
40305: PUSH
40306: EMPTY
40307: LIST
40308: LIST
40309: LIST
40310: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
40311: LD_ADDR_VAR 0 61
40315: PUSH
40316: LD_INT 2
40318: PUSH
40319: LD_INT 1
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 2
40328: PUSH
40329: LD_INT 2
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 1
40338: PUSH
40339: LD_INT 2
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: EMPTY
40347: LIST
40348: LIST
40349: LIST
40350: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
40351: LD_ADDR_VAR 0 62
40355: PUSH
40356: LD_INT 1
40358: PUSH
40359: LD_INT 2
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 0
40368: PUSH
40369: LD_INT 2
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PUSH
40376: LD_INT 1
40378: NEG
40379: PUSH
40380: LD_INT 1
40382: PUSH
40383: EMPTY
40384: LIST
40385: LIST
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: LIST
40391: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
40392: LD_ADDR_VAR 0 63
40396: PUSH
40397: LD_INT 1
40399: NEG
40400: PUSH
40401: LD_INT 1
40403: PUSH
40404: EMPTY
40405: LIST
40406: LIST
40407: PUSH
40408: LD_INT 2
40410: NEG
40411: PUSH
40412: LD_INT 0
40414: PUSH
40415: EMPTY
40416: LIST
40417: LIST
40418: PUSH
40419: LD_INT 2
40421: NEG
40422: PUSH
40423: LD_INT 1
40425: NEG
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: LIST
40435: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40436: LD_ADDR_VAR 0 64
40440: PUSH
40441: LD_INT 1
40443: NEG
40444: PUSH
40445: LD_INT 2
40447: NEG
40448: PUSH
40449: EMPTY
40450: LIST
40451: LIST
40452: PUSH
40453: LD_INT 2
40455: NEG
40456: PUSH
40457: LD_INT 1
40459: NEG
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: LD_INT 2
40467: NEG
40468: PUSH
40469: LD_INT 2
40471: NEG
40472: PUSH
40473: EMPTY
40474: LIST
40475: LIST
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: LIST
40481: ST_TO_ADDR
// end ; 2 :
40482: GO 43748
40484: LD_INT 2
40486: DOUBLE
40487: EQUAL
40488: IFTRUE 40492
40490: GO 43747
40492: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
40493: LD_ADDR_VAR 0 29
40497: PUSH
40498: LD_INT 4
40500: PUSH
40501: LD_INT 0
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: PUSH
40508: LD_INT 4
40510: PUSH
40511: LD_INT 1
40513: NEG
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: PUSH
40519: LD_INT 5
40521: PUSH
40522: LD_INT 0
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: PUSH
40529: LD_INT 5
40531: PUSH
40532: LD_INT 1
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 4
40541: PUSH
40542: LD_INT 1
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 3
40551: PUSH
40552: LD_INT 0
40554: PUSH
40555: EMPTY
40556: LIST
40557: LIST
40558: PUSH
40559: LD_INT 3
40561: PUSH
40562: LD_INT 1
40564: NEG
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: LD_INT 3
40572: PUSH
40573: LD_INT 2
40575: NEG
40576: PUSH
40577: EMPTY
40578: LIST
40579: LIST
40580: PUSH
40581: LD_INT 5
40583: PUSH
40584: LD_INT 2
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 3
40593: PUSH
40594: LD_INT 3
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: PUSH
40601: LD_INT 3
40603: PUSH
40604: LD_INT 2
40606: PUSH
40607: EMPTY
40608: LIST
40609: LIST
40610: PUSH
40611: LD_INT 4
40613: PUSH
40614: LD_INT 3
40616: PUSH
40617: EMPTY
40618: LIST
40619: LIST
40620: PUSH
40621: LD_INT 4
40623: PUSH
40624: LD_INT 4
40626: PUSH
40627: EMPTY
40628: LIST
40629: LIST
40630: PUSH
40631: LD_INT 3
40633: PUSH
40634: LD_INT 4
40636: PUSH
40637: EMPTY
40638: LIST
40639: LIST
40640: PUSH
40641: LD_INT 2
40643: PUSH
40644: LD_INT 3
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 2
40653: PUSH
40654: LD_INT 2
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: LD_INT 4
40663: PUSH
40664: LD_INT 2
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PUSH
40671: LD_INT 2
40673: PUSH
40674: LD_INT 4
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: PUSH
40681: LD_INT 0
40683: PUSH
40684: LD_INT 4
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 0
40693: PUSH
40694: LD_INT 3
40696: PUSH
40697: EMPTY
40698: LIST
40699: LIST
40700: PUSH
40701: LD_INT 1
40703: PUSH
40704: LD_INT 4
40706: PUSH
40707: EMPTY
40708: LIST
40709: LIST
40710: PUSH
40711: LD_INT 1
40713: PUSH
40714: LD_INT 5
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: PUSH
40721: LD_INT 0
40723: PUSH
40724: LD_INT 5
40726: PUSH
40727: EMPTY
40728: LIST
40729: LIST
40730: PUSH
40731: LD_INT 1
40733: NEG
40734: PUSH
40735: LD_INT 4
40737: PUSH
40738: EMPTY
40739: LIST
40740: LIST
40741: PUSH
40742: LD_INT 1
40744: NEG
40745: PUSH
40746: LD_INT 3
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: PUSH
40753: LD_INT 2
40755: PUSH
40756: LD_INT 5
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 2
40765: NEG
40766: PUSH
40767: LD_INT 3
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 3
40776: NEG
40777: PUSH
40778: LD_INT 0
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: LD_INT 3
40787: NEG
40788: PUSH
40789: LD_INT 1
40791: NEG
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 2
40799: NEG
40800: PUSH
40801: LD_INT 0
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 2
40810: NEG
40811: PUSH
40812: LD_INT 1
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: PUSH
40819: LD_INT 3
40821: NEG
40822: PUSH
40823: LD_INT 1
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: PUSH
40830: LD_INT 4
40832: NEG
40833: PUSH
40834: LD_INT 0
40836: PUSH
40837: EMPTY
40838: LIST
40839: LIST
40840: PUSH
40841: LD_INT 4
40843: NEG
40844: PUSH
40845: LD_INT 1
40847: NEG
40848: PUSH
40849: EMPTY
40850: LIST
40851: LIST
40852: PUSH
40853: LD_INT 4
40855: NEG
40856: PUSH
40857: LD_INT 2
40859: NEG
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: PUSH
40865: LD_INT 2
40867: NEG
40868: PUSH
40869: LD_INT 2
40871: PUSH
40872: EMPTY
40873: LIST
40874: LIST
40875: PUSH
40876: LD_INT 4
40878: NEG
40879: PUSH
40880: LD_INT 4
40882: NEG
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 4
40890: NEG
40891: PUSH
40892: LD_INT 5
40894: NEG
40895: PUSH
40896: EMPTY
40897: LIST
40898: LIST
40899: PUSH
40900: LD_INT 3
40902: NEG
40903: PUSH
40904: LD_INT 4
40906: NEG
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: LD_INT 3
40914: NEG
40915: PUSH
40916: LD_INT 3
40918: NEG
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 4
40926: NEG
40927: PUSH
40928: LD_INT 3
40930: NEG
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: LD_INT 5
40938: NEG
40939: PUSH
40940: LD_INT 4
40942: NEG
40943: PUSH
40944: EMPTY
40945: LIST
40946: LIST
40947: PUSH
40948: LD_INT 5
40950: NEG
40951: PUSH
40952: LD_INT 5
40954: NEG
40955: PUSH
40956: EMPTY
40957: LIST
40958: LIST
40959: PUSH
40960: LD_INT 3
40962: NEG
40963: PUSH
40964: LD_INT 5
40966: NEG
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 5
40974: NEG
40975: PUSH
40976: LD_INT 3
40978: NEG
40979: PUSH
40980: EMPTY
40981: LIST
40982: LIST
40983: PUSH
40984: EMPTY
40985: LIST
40986: LIST
40987: LIST
40988: LIST
40989: LIST
40990: LIST
40991: LIST
40992: LIST
40993: LIST
40994: LIST
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: LIST
41008: LIST
41009: LIST
41010: LIST
41011: LIST
41012: LIST
41013: LIST
41014: LIST
41015: LIST
41016: LIST
41017: LIST
41018: LIST
41019: LIST
41020: LIST
41021: LIST
41022: LIST
41023: LIST
41024: LIST
41025: LIST
41026: LIST
41027: LIST
41028: LIST
41029: LIST
41030: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
41031: LD_ADDR_VAR 0 30
41035: PUSH
41036: LD_INT 4
41038: PUSH
41039: LD_INT 4
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: PUSH
41046: LD_INT 4
41048: PUSH
41049: LD_INT 3
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PUSH
41056: LD_INT 5
41058: PUSH
41059: LD_INT 4
41061: PUSH
41062: EMPTY
41063: LIST
41064: LIST
41065: PUSH
41066: LD_INT 5
41068: PUSH
41069: LD_INT 5
41071: PUSH
41072: EMPTY
41073: LIST
41074: LIST
41075: PUSH
41076: LD_INT 4
41078: PUSH
41079: LD_INT 5
41081: PUSH
41082: EMPTY
41083: LIST
41084: LIST
41085: PUSH
41086: LD_INT 3
41088: PUSH
41089: LD_INT 4
41091: PUSH
41092: EMPTY
41093: LIST
41094: LIST
41095: PUSH
41096: LD_INT 3
41098: PUSH
41099: LD_INT 3
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: PUSH
41106: LD_INT 5
41108: PUSH
41109: LD_INT 3
41111: PUSH
41112: EMPTY
41113: LIST
41114: LIST
41115: PUSH
41116: LD_INT 3
41118: PUSH
41119: LD_INT 5
41121: PUSH
41122: EMPTY
41123: LIST
41124: LIST
41125: PUSH
41126: LD_INT 0
41128: PUSH
41129: LD_INT 3
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: LD_INT 0
41138: PUSH
41139: LD_INT 2
41141: PUSH
41142: EMPTY
41143: LIST
41144: LIST
41145: PUSH
41146: LD_INT 1
41148: PUSH
41149: LD_INT 3
41151: PUSH
41152: EMPTY
41153: LIST
41154: LIST
41155: PUSH
41156: LD_INT 1
41158: PUSH
41159: LD_INT 4
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: PUSH
41166: LD_INT 0
41168: PUSH
41169: LD_INT 4
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PUSH
41176: LD_INT 1
41178: NEG
41179: PUSH
41180: LD_INT 3
41182: PUSH
41183: EMPTY
41184: LIST
41185: LIST
41186: PUSH
41187: LD_INT 1
41189: NEG
41190: PUSH
41191: LD_INT 2
41193: PUSH
41194: EMPTY
41195: LIST
41196: LIST
41197: PUSH
41198: LD_INT 2
41200: PUSH
41201: LD_INT 4
41203: PUSH
41204: EMPTY
41205: LIST
41206: LIST
41207: PUSH
41208: LD_INT 2
41210: NEG
41211: PUSH
41212: LD_INT 2
41214: PUSH
41215: EMPTY
41216: LIST
41217: LIST
41218: PUSH
41219: LD_INT 4
41221: NEG
41222: PUSH
41223: LD_INT 0
41225: PUSH
41226: EMPTY
41227: LIST
41228: LIST
41229: PUSH
41230: LD_INT 4
41232: NEG
41233: PUSH
41234: LD_INT 1
41236: NEG
41237: PUSH
41238: EMPTY
41239: LIST
41240: LIST
41241: PUSH
41242: LD_INT 3
41244: NEG
41245: PUSH
41246: LD_INT 0
41248: PUSH
41249: EMPTY
41250: LIST
41251: LIST
41252: PUSH
41253: LD_INT 3
41255: NEG
41256: PUSH
41257: LD_INT 1
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: LD_INT 4
41266: NEG
41267: PUSH
41268: LD_INT 1
41270: PUSH
41271: EMPTY
41272: LIST
41273: LIST
41274: PUSH
41275: LD_INT 5
41277: NEG
41278: PUSH
41279: LD_INT 0
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: LD_INT 5
41288: NEG
41289: PUSH
41290: LD_INT 1
41292: NEG
41293: PUSH
41294: EMPTY
41295: LIST
41296: LIST
41297: PUSH
41298: LD_INT 5
41300: NEG
41301: PUSH
41302: LD_INT 2
41304: NEG
41305: PUSH
41306: EMPTY
41307: LIST
41308: LIST
41309: PUSH
41310: LD_INT 3
41312: NEG
41313: PUSH
41314: LD_INT 2
41316: PUSH
41317: EMPTY
41318: LIST
41319: LIST
41320: PUSH
41321: LD_INT 3
41323: NEG
41324: PUSH
41325: LD_INT 3
41327: NEG
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 3
41335: NEG
41336: PUSH
41337: LD_INT 4
41339: NEG
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: PUSH
41345: LD_INT 2
41347: NEG
41348: PUSH
41349: LD_INT 3
41351: NEG
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: PUSH
41357: LD_INT 2
41359: NEG
41360: PUSH
41361: LD_INT 2
41363: NEG
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 3
41371: NEG
41372: PUSH
41373: LD_INT 2
41375: NEG
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: PUSH
41381: LD_INT 4
41383: NEG
41384: PUSH
41385: LD_INT 3
41387: NEG
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: PUSH
41393: LD_INT 4
41395: NEG
41396: PUSH
41397: LD_INT 4
41399: NEG
41400: PUSH
41401: EMPTY
41402: LIST
41403: LIST
41404: PUSH
41405: LD_INT 2
41407: NEG
41408: PUSH
41409: LD_INT 4
41411: NEG
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: LD_INT 4
41419: NEG
41420: PUSH
41421: LD_INT 2
41423: NEG
41424: PUSH
41425: EMPTY
41426: LIST
41427: LIST
41428: PUSH
41429: LD_INT 0
41431: PUSH
41432: LD_INT 4
41434: NEG
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: PUSH
41440: LD_INT 0
41442: PUSH
41443: LD_INT 5
41445: NEG
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PUSH
41451: LD_INT 1
41453: PUSH
41454: LD_INT 4
41456: NEG
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 1
41464: PUSH
41465: LD_INT 3
41467: NEG
41468: PUSH
41469: EMPTY
41470: LIST
41471: LIST
41472: PUSH
41473: LD_INT 0
41475: PUSH
41476: LD_INT 3
41478: NEG
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 1
41486: NEG
41487: PUSH
41488: LD_INT 4
41490: NEG
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: PUSH
41496: LD_INT 1
41498: NEG
41499: PUSH
41500: LD_INT 5
41502: NEG
41503: PUSH
41504: EMPTY
41505: LIST
41506: LIST
41507: PUSH
41508: LD_INT 2
41510: PUSH
41511: LD_INT 3
41513: NEG
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: PUSH
41519: LD_INT 2
41521: NEG
41522: PUSH
41523: LD_INT 5
41525: NEG
41526: PUSH
41527: EMPTY
41528: LIST
41529: LIST
41530: PUSH
41531: EMPTY
41532: LIST
41533: LIST
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: LIST
41554: LIST
41555: LIST
41556: LIST
41557: LIST
41558: LIST
41559: LIST
41560: LIST
41561: LIST
41562: LIST
41563: LIST
41564: LIST
41565: LIST
41566: LIST
41567: LIST
41568: LIST
41569: LIST
41570: LIST
41571: LIST
41572: LIST
41573: LIST
41574: LIST
41575: LIST
41576: LIST
41577: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
41578: LD_ADDR_VAR 0 31
41582: PUSH
41583: LD_INT 0
41585: PUSH
41586: LD_INT 4
41588: PUSH
41589: EMPTY
41590: LIST
41591: LIST
41592: PUSH
41593: LD_INT 0
41595: PUSH
41596: LD_INT 3
41598: PUSH
41599: EMPTY
41600: LIST
41601: LIST
41602: PUSH
41603: LD_INT 1
41605: PUSH
41606: LD_INT 4
41608: PUSH
41609: EMPTY
41610: LIST
41611: LIST
41612: PUSH
41613: LD_INT 1
41615: PUSH
41616: LD_INT 5
41618: PUSH
41619: EMPTY
41620: LIST
41621: LIST
41622: PUSH
41623: LD_INT 0
41625: PUSH
41626: LD_INT 5
41628: PUSH
41629: EMPTY
41630: LIST
41631: LIST
41632: PUSH
41633: LD_INT 1
41635: NEG
41636: PUSH
41637: LD_INT 4
41639: PUSH
41640: EMPTY
41641: LIST
41642: LIST
41643: PUSH
41644: LD_INT 1
41646: NEG
41647: PUSH
41648: LD_INT 3
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: LD_INT 2
41657: PUSH
41658: LD_INT 5
41660: PUSH
41661: EMPTY
41662: LIST
41663: LIST
41664: PUSH
41665: LD_INT 2
41667: NEG
41668: PUSH
41669: LD_INT 3
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 3
41678: NEG
41679: PUSH
41680: LD_INT 0
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: LD_INT 3
41689: NEG
41690: PUSH
41691: LD_INT 1
41693: NEG
41694: PUSH
41695: EMPTY
41696: LIST
41697: LIST
41698: PUSH
41699: LD_INT 2
41701: NEG
41702: PUSH
41703: LD_INT 0
41705: PUSH
41706: EMPTY
41707: LIST
41708: LIST
41709: PUSH
41710: LD_INT 2
41712: NEG
41713: PUSH
41714: LD_INT 1
41716: PUSH
41717: EMPTY
41718: LIST
41719: LIST
41720: PUSH
41721: LD_INT 3
41723: NEG
41724: PUSH
41725: LD_INT 1
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: PUSH
41732: LD_INT 4
41734: NEG
41735: PUSH
41736: LD_INT 0
41738: PUSH
41739: EMPTY
41740: LIST
41741: LIST
41742: PUSH
41743: LD_INT 4
41745: NEG
41746: PUSH
41747: LD_INT 1
41749: NEG
41750: PUSH
41751: EMPTY
41752: LIST
41753: LIST
41754: PUSH
41755: LD_INT 4
41757: NEG
41758: PUSH
41759: LD_INT 2
41761: NEG
41762: PUSH
41763: EMPTY
41764: LIST
41765: LIST
41766: PUSH
41767: LD_INT 2
41769: NEG
41770: PUSH
41771: LD_INT 2
41773: PUSH
41774: EMPTY
41775: LIST
41776: LIST
41777: PUSH
41778: LD_INT 4
41780: NEG
41781: PUSH
41782: LD_INT 4
41784: NEG
41785: PUSH
41786: EMPTY
41787: LIST
41788: LIST
41789: PUSH
41790: LD_INT 4
41792: NEG
41793: PUSH
41794: LD_INT 5
41796: NEG
41797: PUSH
41798: EMPTY
41799: LIST
41800: LIST
41801: PUSH
41802: LD_INT 3
41804: NEG
41805: PUSH
41806: LD_INT 4
41808: NEG
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: PUSH
41814: LD_INT 3
41816: NEG
41817: PUSH
41818: LD_INT 3
41820: NEG
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: LD_INT 4
41828: NEG
41829: PUSH
41830: LD_INT 3
41832: NEG
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: PUSH
41838: LD_INT 5
41840: NEG
41841: PUSH
41842: LD_INT 4
41844: NEG
41845: PUSH
41846: EMPTY
41847: LIST
41848: LIST
41849: PUSH
41850: LD_INT 5
41852: NEG
41853: PUSH
41854: LD_INT 5
41856: NEG
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: PUSH
41862: LD_INT 3
41864: NEG
41865: PUSH
41866: LD_INT 5
41868: NEG
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: PUSH
41874: LD_INT 5
41876: NEG
41877: PUSH
41878: LD_INT 3
41880: NEG
41881: PUSH
41882: EMPTY
41883: LIST
41884: LIST
41885: PUSH
41886: LD_INT 0
41888: PUSH
41889: LD_INT 3
41891: NEG
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: PUSH
41897: LD_INT 0
41899: PUSH
41900: LD_INT 4
41902: NEG
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PUSH
41908: LD_INT 1
41910: PUSH
41911: LD_INT 3
41913: NEG
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: LD_INT 1
41921: PUSH
41922: LD_INT 2
41924: NEG
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 0
41932: PUSH
41933: LD_INT 2
41935: NEG
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 1
41943: NEG
41944: PUSH
41945: LD_INT 3
41947: NEG
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: PUSH
41953: LD_INT 1
41955: NEG
41956: PUSH
41957: LD_INT 4
41959: NEG
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 2
41967: PUSH
41968: LD_INT 2
41970: NEG
41971: PUSH
41972: EMPTY
41973: LIST
41974: LIST
41975: PUSH
41976: LD_INT 2
41978: NEG
41979: PUSH
41980: LD_INT 4
41982: NEG
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: LD_INT 4
41990: PUSH
41991: LD_INT 0
41993: PUSH
41994: EMPTY
41995: LIST
41996: LIST
41997: PUSH
41998: LD_INT 4
42000: PUSH
42001: LD_INT 1
42003: NEG
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 5
42011: PUSH
42012: LD_INT 0
42014: PUSH
42015: EMPTY
42016: LIST
42017: LIST
42018: PUSH
42019: LD_INT 5
42021: PUSH
42022: LD_INT 1
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: LD_INT 4
42031: PUSH
42032: LD_INT 1
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 3
42041: PUSH
42042: LD_INT 0
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 3
42051: PUSH
42052: LD_INT 1
42054: NEG
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_INT 3
42062: PUSH
42063: LD_INT 2
42065: NEG
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: PUSH
42071: LD_INT 5
42073: PUSH
42074: LD_INT 2
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: EMPTY
42082: LIST
42083: LIST
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: LIST
42091: LIST
42092: LIST
42093: LIST
42094: LIST
42095: LIST
42096: LIST
42097: LIST
42098: LIST
42099: LIST
42100: LIST
42101: LIST
42102: LIST
42103: LIST
42104: LIST
42105: LIST
42106: LIST
42107: LIST
42108: LIST
42109: LIST
42110: LIST
42111: LIST
42112: LIST
42113: LIST
42114: LIST
42115: LIST
42116: LIST
42117: LIST
42118: LIST
42119: LIST
42120: LIST
42121: LIST
42122: LIST
42123: LIST
42124: LIST
42125: LIST
42126: LIST
42127: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
42128: LD_ADDR_VAR 0 32
42132: PUSH
42133: LD_INT 4
42135: NEG
42136: PUSH
42137: LD_INT 0
42139: PUSH
42140: EMPTY
42141: LIST
42142: LIST
42143: PUSH
42144: LD_INT 4
42146: NEG
42147: PUSH
42148: LD_INT 1
42150: NEG
42151: PUSH
42152: EMPTY
42153: LIST
42154: LIST
42155: PUSH
42156: LD_INT 3
42158: NEG
42159: PUSH
42160: LD_INT 0
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: PUSH
42167: LD_INT 3
42169: NEG
42170: PUSH
42171: LD_INT 1
42173: PUSH
42174: EMPTY
42175: LIST
42176: LIST
42177: PUSH
42178: LD_INT 4
42180: NEG
42181: PUSH
42182: LD_INT 1
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: PUSH
42189: LD_INT 5
42191: NEG
42192: PUSH
42193: LD_INT 0
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: LD_INT 5
42202: NEG
42203: PUSH
42204: LD_INT 1
42206: NEG
42207: PUSH
42208: EMPTY
42209: LIST
42210: LIST
42211: PUSH
42212: LD_INT 5
42214: NEG
42215: PUSH
42216: LD_INT 2
42218: NEG
42219: PUSH
42220: EMPTY
42221: LIST
42222: LIST
42223: PUSH
42224: LD_INT 3
42226: NEG
42227: PUSH
42228: LD_INT 2
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: PUSH
42235: LD_INT 3
42237: NEG
42238: PUSH
42239: LD_INT 3
42241: NEG
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: LD_INT 3
42249: NEG
42250: PUSH
42251: LD_INT 4
42253: NEG
42254: PUSH
42255: EMPTY
42256: LIST
42257: LIST
42258: PUSH
42259: LD_INT 2
42261: NEG
42262: PUSH
42263: LD_INT 3
42265: NEG
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: PUSH
42271: LD_INT 2
42273: NEG
42274: PUSH
42275: LD_INT 2
42277: NEG
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: LD_INT 3
42285: NEG
42286: PUSH
42287: LD_INT 2
42289: NEG
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: LD_INT 4
42297: NEG
42298: PUSH
42299: LD_INT 3
42301: NEG
42302: PUSH
42303: EMPTY
42304: LIST
42305: LIST
42306: PUSH
42307: LD_INT 4
42309: NEG
42310: PUSH
42311: LD_INT 4
42313: NEG
42314: PUSH
42315: EMPTY
42316: LIST
42317: LIST
42318: PUSH
42319: LD_INT 2
42321: NEG
42322: PUSH
42323: LD_INT 4
42325: NEG
42326: PUSH
42327: EMPTY
42328: LIST
42329: LIST
42330: PUSH
42331: LD_INT 4
42333: NEG
42334: PUSH
42335: LD_INT 2
42337: NEG
42338: PUSH
42339: EMPTY
42340: LIST
42341: LIST
42342: PUSH
42343: LD_INT 0
42345: PUSH
42346: LD_INT 4
42348: NEG
42349: PUSH
42350: EMPTY
42351: LIST
42352: LIST
42353: PUSH
42354: LD_INT 0
42356: PUSH
42357: LD_INT 5
42359: NEG
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: LD_INT 1
42367: PUSH
42368: LD_INT 4
42370: NEG
42371: PUSH
42372: EMPTY
42373: LIST
42374: LIST
42375: PUSH
42376: LD_INT 1
42378: PUSH
42379: LD_INT 3
42381: NEG
42382: PUSH
42383: EMPTY
42384: LIST
42385: LIST
42386: PUSH
42387: LD_INT 0
42389: PUSH
42390: LD_INT 3
42392: NEG
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: LD_INT 1
42400: NEG
42401: PUSH
42402: LD_INT 4
42404: NEG
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: PUSH
42410: LD_INT 1
42412: NEG
42413: PUSH
42414: LD_INT 5
42416: NEG
42417: PUSH
42418: EMPTY
42419: LIST
42420: LIST
42421: PUSH
42422: LD_INT 2
42424: PUSH
42425: LD_INT 3
42427: NEG
42428: PUSH
42429: EMPTY
42430: LIST
42431: LIST
42432: PUSH
42433: LD_INT 2
42435: NEG
42436: PUSH
42437: LD_INT 5
42439: NEG
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: PUSH
42445: LD_INT 3
42447: PUSH
42448: LD_INT 0
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: PUSH
42455: LD_INT 3
42457: PUSH
42458: LD_INT 1
42460: NEG
42461: PUSH
42462: EMPTY
42463: LIST
42464: LIST
42465: PUSH
42466: LD_INT 4
42468: PUSH
42469: LD_INT 0
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: LD_INT 4
42478: PUSH
42479: LD_INT 1
42481: PUSH
42482: EMPTY
42483: LIST
42484: LIST
42485: PUSH
42486: LD_INT 3
42488: PUSH
42489: LD_INT 1
42491: PUSH
42492: EMPTY
42493: LIST
42494: LIST
42495: PUSH
42496: LD_INT 2
42498: PUSH
42499: LD_INT 0
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: LD_INT 2
42508: PUSH
42509: LD_INT 1
42511: NEG
42512: PUSH
42513: EMPTY
42514: LIST
42515: LIST
42516: PUSH
42517: LD_INT 2
42519: PUSH
42520: LD_INT 2
42522: NEG
42523: PUSH
42524: EMPTY
42525: LIST
42526: LIST
42527: PUSH
42528: LD_INT 4
42530: PUSH
42531: LD_INT 2
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 4
42540: PUSH
42541: LD_INT 4
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: LD_INT 4
42550: PUSH
42551: LD_INT 3
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PUSH
42558: LD_INT 5
42560: PUSH
42561: LD_INT 4
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: PUSH
42568: LD_INT 5
42570: PUSH
42571: LD_INT 5
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: PUSH
42578: LD_INT 4
42580: PUSH
42581: LD_INT 5
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: LD_INT 3
42590: PUSH
42591: LD_INT 4
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: LD_INT 3
42600: PUSH
42601: LD_INT 3
42603: PUSH
42604: EMPTY
42605: LIST
42606: LIST
42607: PUSH
42608: LD_INT 5
42610: PUSH
42611: LD_INT 3
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PUSH
42618: LD_INT 3
42620: PUSH
42621: LD_INT 5
42623: PUSH
42624: EMPTY
42625: LIST
42626: LIST
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: LIST
42632: LIST
42633: LIST
42634: LIST
42635: LIST
42636: LIST
42637: LIST
42638: LIST
42639: LIST
42640: LIST
42641: LIST
42642: LIST
42643: LIST
42644: LIST
42645: LIST
42646: LIST
42647: LIST
42648: LIST
42649: LIST
42650: LIST
42651: LIST
42652: LIST
42653: LIST
42654: LIST
42655: LIST
42656: LIST
42657: LIST
42658: LIST
42659: LIST
42660: LIST
42661: LIST
42662: LIST
42663: LIST
42664: LIST
42665: LIST
42666: LIST
42667: LIST
42668: LIST
42669: LIST
42670: LIST
42671: LIST
42672: LIST
42673: LIST
42674: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
42675: LD_ADDR_VAR 0 33
42679: PUSH
42680: LD_INT 4
42682: NEG
42683: PUSH
42684: LD_INT 4
42686: NEG
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PUSH
42692: LD_INT 4
42694: NEG
42695: PUSH
42696: LD_INT 5
42698: NEG
42699: PUSH
42700: EMPTY
42701: LIST
42702: LIST
42703: PUSH
42704: LD_INT 3
42706: NEG
42707: PUSH
42708: LD_INT 4
42710: NEG
42711: PUSH
42712: EMPTY
42713: LIST
42714: LIST
42715: PUSH
42716: LD_INT 3
42718: NEG
42719: PUSH
42720: LD_INT 3
42722: NEG
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: LD_INT 4
42730: NEG
42731: PUSH
42732: LD_INT 3
42734: NEG
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PUSH
42740: LD_INT 5
42742: NEG
42743: PUSH
42744: LD_INT 4
42746: NEG
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: LD_INT 5
42754: NEG
42755: PUSH
42756: LD_INT 5
42758: NEG
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: LD_INT 3
42766: NEG
42767: PUSH
42768: LD_INT 5
42770: NEG
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PUSH
42776: LD_INT 5
42778: NEG
42779: PUSH
42780: LD_INT 3
42782: NEG
42783: PUSH
42784: EMPTY
42785: LIST
42786: LIST
42787: PUSH
42788: LD_INT 0
42790: PUSH
42791: LD_INT 3
42793: NEG
42794: PUSH
42795: EMPTY
42796: LIST
42797: LIST
42798: PUSH
42799: LD_INT 0
42801: PUSH
42802: LD_INT 4
42804: NEG
42805: PUSH
42806: EMPTY
42807: LIST
42808: LIST
42809: PUSH
42810: LD_INT 1
42812: PUSH
42813: LD_INT 3
42815: NEG
42816: PUSH
42817: EMPTY
42818: LIST
42819: LIST
42820: PUSH
42821: LD_INT 1
42823: PUSH
42824: LD_INT 2
42826: NEG
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: PUSH
42832: LD_INT 0
42834: PUSH
42835: LD_INT 2
42837: NEG
42838: PUSH
42839: EMPTY
42840: LIST
42841: LIST
42842: PUSH
42843: LD_INT 1
42845: NEG
42846: PUSH
42847: LD_INT 3
42849: NEG
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 1
42857: NEG
42858: PUSH
42859: LD_INT 4
42861: NEG
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: LD_INT 2
42869: PUSH
42870: LD_INT 2
42872: NEG
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: LD_INT 2
42880: NEG
42881: PUSH
42882: LD_INT 4
42884: NEG
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: LD_INT 4
42892: PUSH
42893: LD_INT 0
42895: PUSH
42896: EMPTY
42897: LIST
42898: LIST
42899: PUSH
42900: LD_INT 4
42902: PUSH
42903: LD_INT 1
42905: NEG
42906: PUSH
42907: EMPTY
42908: LIST
42909: LIST
42910: PUSH
42911: LD_INT 5
42913: PUSH
42914: LD_INT 0
42916: PUSH
42917: EMPTY
42918: LIST
42919: LIST
42920: PUSH
42921: LD_INT 5
42923: PUSH
42924: LD_INT 1
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: PUSH
42931: LD_INT 4
42933: PUSH
42934: LD_INT 1
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: PUSH
42941: LD_INT 3
42943: PUSH
42944: LD_INT 0
42946: PUSH
42947: EMPTY
42948: LIST
42949: LIST
42950: PUSH
42951: LD_INT 3
42953: PUSH
42954: LD_INT 1
42956: NEG
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: PUSH
42962: LD_INT 3
42964: PUSH
42965: LD_INT 2
42967: NEG
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: LD_INT 5
42975: PUSH
42976: LD_INT 2
42978: PUSH
42979: EMPTY
42980: LIST
42981: LIST
42982: PUSH
42983: LD_INT 3
42985: PUSH
42986: LD_INT 3
42988: PUSH
42989: EMPTY
42990: LIST
42991: LIST
42992: PUSH
42993: LD_INT 3
42995: PUSH
42996: LD_INT 2
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: LD_INT 4
43005: PUSH
43006: LD_INT 3
43008: PUSH
43009: EMPTY
43010: LIST
43011: LIST
43012: PUSH
43013: LD_INT 4
43015: PUSH
43016: LD_INT 4
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: PUSH
43023: LD_INT 3
43025: PUSH
43026: LD_INT 4
43028: PUSH
43029: EMPTY
43030: LIST
43031: LIST
43032: PUSH
43033: LD_INT 2
43035: PUSH
43036: LD_INT 3
43038: PUSH
43039: EMPTY
43040: LIST
43041: LIST
43042: PUSH
43043: LD_INT 2
43045: PUSH
43046: LD_INT 2
43048: PUSH
43049: EMPTY
43050: LIST
43051: LIST
43052: PUSH
43053: LD_INT 4
43055: PUSH
43056: LD_INT 2
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: LD_INT 2
43065: PUSH
43066: LD_INT 4
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: PUSH
43073: LD_INT 0
43075: PUSH
43076: LD_INT 4
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 0
43085: PUSH
43086: LD_INT 3
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 1
43095: PUSH
43096: LD_INT 4
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: LD_INT 1
43105: PUSH
43106: LD_INT 5
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: LD_INT 0
43115: PUSH
43116: LD_INT 5
43118: PUSH
43119: EMPTY
43120: LIST
43121: LIST
43122: PUSH
43123: LD_INT 1
43125: NEG
43126: PUSH
43127: LD_INT 4
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: LD_INT 1
43136: NEG
43137: PUSH
43138: LD_INT 3
43140: PUSH
43141: EMPTY
43142: LIST
43143: LIST
43144: PUSH
43145: LD_INT 2
43147: PUSH
43148: LD_INT 5
43150: PUSH
43151: EMPTY
43152: LIST
43153: LIST
43154: PUSH
43155: LD_INT 2
43157: NEG
43158: PUSH
43159: LD_INT 3
43161: PUSH
43162: EMPTY
43163: LIST
43164: LIST
43165: PUSH
43166: EMPTY
43167: LIST
43168: LIST
43169: LIST
43170: LIST
43171: LIST
43172: LIST
43173: LIST
43174: LIST
43175: LIST
43176: LIST
43177: LIST
43178: LIST
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: LIST
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: LIST
43190: LIST
43191: LIST
43192: LIST
43193: LIST
43194: LIST
43195: LIST
43196: LIST
43197: LIST
43198: LIST
43199: LIST
43200: LIST
43201: LIST
43202: LIST
43203: LIST
43204: LIST
43205: LIST
43206: LIST
43207: LIST
43208: LIST
43209: LIST
43210: LIST
43211: LIST
43212: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
43213: LD_ADDR_VAR 0 34
43217: PUSH
43218: LD_INT 0
43220: PUSH
43221: LD_INT 4
43223: NEG
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: PUSH
43229: LD_INT 0
43231: PUSH
43232: LD_INT 5
43234: NEG
43235: PUSH
43236: EMPTY
43237: LIST
43238: LIST
43239: PUSH
43240: LD_INT 1
43242: PUSH
43243: LD_INT 4
43245: NEG
43246: PUSH
43247: EMPTY
43248: LIST
43249: LIST
43250: PUSH
43251: LD_INT 1
43253: PUSH
43254: LD_INT 3
43256: NEG
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: PUSH
43262: LD_INT 0
43264: PUSH
43265: LD_INT 3
43267: NEG
43268: PUSH
43269: EMPTY
43270: LIST
43271: LIST
43272: PUSH
43273: LD_INT 1
43275: NEG
43276: PUSH
43277: LD_INT 4
43279: NEG
43280: PUSH
43281: EMPTY
43282: LIST
43283: LIST
43284: PUSH
43285: LD_INT 1
43287: NEG
43288: PUSH
43289: LD_INT 5
43291: NEG
43292: PUSH
43293: EMPTY
43294: LIST
43295: LIST
43296: PUSH
43297: LD_INT 2
43299: PUSH
43300: LD_INT 3
43302: NEG
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PUSH
43308: LD_INT 2
43310: NEG
43311: PUSH
43312: LD_INT 5
43314: NEG
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 3
43322: PUSH
43323: LD_INT 0
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 3
43332: PUSH
43333: LD_INT 1
43335: NEG
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 4
43343: PUSH
43344: LD_INT 0
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: PUSH
43351: LD_INT 4
43353: PUSH
43354: LD_INT 1
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: LD_INT 3
43363: PUSH
43364: LD_INT 1
43366: PUSH
43367: EMPTY
43368: LIST
43369: LIST
43370: PUSH
43371: LD_INT 2
43373: PUSH
43374: LD_INT 0
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: PUSH
43381: LD_INT 2
43383: PUSH
43384: LD_INT 1
43386: NEG
43387: PUSH
43388: EMPTY
43389: LIST
43390: LIST
43391: PUSH
43392: LD_INT 2
43394: PUSH
43395: LD_INT 2
43397: NEG
43398: PUSH
43399: EMPTY
43400: LIST
43401: LIST
43402: PUSH
43403: LD_INT 4
43405: PUSH
43406: LD_INT 2
43408: PUSH
43409: EMPTY
43410: LIST
43411: LIST
43412: PUSH
43413: LD_INT 4
43415: PUSH
43416: LD_INT 4
43418: PUSH
43419: EMPTY
43420: LIST
43421: LIST
43422: PUSH
43423: LD_INT 4
43425: PUSH
43426: LD_INT 3
43428: PUSH
43429: EMPTY
43430: LIST
43431: LIST
43432: PUSH
43433: LD_INT 5
43435: PUSH
43436: LD_INT 4
43438: PUSH
43439: EMPTY
43440: LIST
43441: LIST
43442: PUSH
43443: LD_INT 5
43445: PUSH
43446: LD_INT 5
43448: PUSH
43449: EMPTY
43450: LIST
43451: LIST
43452: PUSH
43453: LD_INT 4
43455: PUSH
43456: LD_INT 5
43458: PUSH
43459: EMPTY
43460: LIST
43461: LIST
43462: PUSH
43463: LD_INT 3
43465: PUSH
43466: LD_INT 4
43468: PUSH
43469: EMPTY
43470: LIST
43471: LIST
43472: PUSH
43473: LD_INT 3
43475: PUSH
43476: LD_INT 3
43478: PUSH
43479: EMPTY
43480: LIST
43481: LIST
43482: PUSH
43483: LD_INT 5
43485: PUSH
43486: LD_INT 3
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: PUSH
43493: LD_INT 3
43495: PUSH
43496: LD_INT 5
43498: PUSH
43499: EMPTY
43500: LIST
43501: LIST
43502: PUSH
43503: LD_INT 0
43505: PUSH
43506: LD_INT 3
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: PUSH
43513: LD_INT 0
43515: PUSH
43516: LD_INT 2
43518: PUSH
43519: EMPTY
43520: LIST
43521: LIST
43522: PUSH
43523: LD_INT 1
43525: PUSH
43526: LD_INT 3
43528: PUSH
43529: EMPTY
43530: LIST
43531: LIST
43532: PUSH
43533: LD_INT 1
43535: PUSH
43536: LD_INT 4
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: PUSH
43543: LD_INT 0
43545: PUSH
43546: LD_INT 4
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: LD_INT 1
43555: NEG
43556: PUSH
43557: LD_INT 3
43559: PUSH
43560: EMPTY
43561: LIST
43562: LIST
43563: PUSH
43564: LD_INT 1
43566: NEG
43567: PUSH
43568: LD_INT 2
43570: PUSH
43571: EMPTY
43572: LIST
43573: LIST
43574: PUSH
43575: LD_INT 2
43577: PUSH
43578: LD_INT 4
43580: PUSH
43581: EMPTY
43582: LIST
43583: LIST
43584: PUSH
43585: LD_INT 2
43587: NEG
43588: PUSH
43589: LD_INT 2
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: PUSH
43596: LD_INT 4
43598: NEG
43599: PUSH
43600: LD_INT 0
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: LD_INT 4
43609: NEG
43610: PUSH
43611: LD_INT 1
43613: NEG
43614: PUSH
43615: EMPTY
43616: LIST
43617: LIST
43618: PUSH
43619: LD_INT 3
43621: NEG
43622: PUSH
43623: LD_INT 0
43625: PUSH
43626: EMPTY
43627: LIST
43628: LIST
43629: PUSH
43630: LD_INT 3
43632: NEG
43633: PUSH
43634: LD_INT 1
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: PUSH
43641: LD_INT 4
43643: NEG
43644: PUSH
43645: LD_INT 1
43647: PUSH
43648: EMPTY
43649: LIST
43650: LIST
43651: PUSH
43652: LD_INT 5
43654: NEG
43655: PUSH
43656: LD_INT 0
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 5
43665: NEG
43666: PUSH
43667: LD_INT 1
43669: NEG
43670: PUSH
43671: EMPTY
43672: LIST
43673: LIST
43674: PUSH
43675: LD_INT 5
43677: NEG
43678: PUSH
43679: LD_INT 2
43681: NEG
43682: PUSH
43683: EMPTY
43684: LIST
43685: LIST
43686: PUSH
43687: LD_INT 3
43689: NEG
43690: PUSH
43691: LD_INT 2
43693: PUSH
43694: EMPTY
43695: LIST
43696: LIST
43697: PUSH
43698: EMPTY
43699: LIST
43700: LIST
43701: LIST
43702: LIST
43703: LIST
43704: LIST
43705: LIST
43706: LIST
43707: LIST
43708: LIST
43709: LIST
43710: LIST
43711: LIST
43712: LIST
43713: LIST
43714: LIST
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: LIST
43729: LIST
43730: LIST
43731: LIST
43732: LIST
43733: LIST
43734: LIST
43735: LIST
43736: LIST
43737: LIST
43738: LIST
43739: LIST
43740: LIST
43741: LIST
43742: LIST
43743: LIST
43744: ST_TO_ADDR
// end ; end ;
43745: GO 43748
43747: POP
// case btype of b_depot , b_warehouse :
43748: LD_VAR 0 1
43752: PUSH
43753: LD_INT 0
43755: DOUBLE
43756: EQUAL
43757: IFTRUE 43767
43759: LD_INT 1
43761: DOUBLE
43762: EQUAL
43763: IFTRUE 43767
43765: GO 43968
43767: POP
// case nation of nation_american :
43768: LD_VAR 0 5
43772: PUSH
43773: LD_INT 1
43775: DOUBLE
43776: EQUAL
43777: IFTRUE 43781
43779: GO 43837
43781: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
43782: LD_ADDR_VAR 0 9
43786: PUSH
43787: LD_VAR 0 11
43791: PUSH
43792: LD_VAR 0 12
43796: PUSH
43797: LD_VAR 0 13
43801: PUSH
43802: LD_VAR 0 14
43806: PUSH
43807: LD_VAR 0 15
43811: PUSH
43812: LD_VAR 0 16
43816: PUSH
43817: EMPTY
43818: LIST
43819: LIST
43820: LIST
43821: LIST
43822: LIST
43823: LIST
43824: PUSH
43825: LD_VAR 0 4
43829: PUSH
43830: LD_INT 1
43832: PLUS
43833: ARRAY
43834: ST_TO_ADDR
43835: GO 43966
43837: LD_INT 2
43839: DOUBLE
43840: EQUAL
43841: IFTRUE 43845
43843: GO 43901
43845: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
43846: LD_ADDR_VAR 0 9
43850: PUSH
43851: LD_VAR 0 17
43855: PUSH
43856: LD_VAR 0 18
43860: PUSH
43861: LD_VAR 0 19
43865: PUSH
43866: LD_VAR 0 20
43870: PUSH
43871: LD_VAR 0 21
43875: PUSH
43876: LD_VAR 0 22
43880: PUSH
43881: EMPTY
43882: LIST
43883: LIST
43884: LIST
43885: LIST
43886: LIST
43887: LIST
43888: PUSH
43889: LD_VAR 0 4
43893: PUSH
43894: LD_INT 1
43896: PLUS
43897: ARRAY
43898: ST_TO_ADDR
43899: GO 43966
43901: LD_INT 3
43903: DOUBLE
43904: EQUAL
43905: IFTRUE 43909
43907: GO 43965
43909: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
43910: LD_ADDR_VAR 0 9
43914: PUSH
43915: LD_VAR 0 23
43919: PUSH
43920: LD_VAR 0 24
43924: PUSH
43925: LD_VAR 0 25
43929: PUSH
43930: LD_VAR 0 26
43934: PUSH
43935: LD_VAR 0 27
43939: PUSH
43940: LD_VAR 0 28
43944: PUSH
43945: EMPTY
43946: LIST
43947: LIST
43948: LIST
43949: LIST
43950: LIST
43951: LIST
43952: PUSH
43953: LD_VAR 0 4
43957: PUSH
43958: LD_INT 1
43960: PLUS
43961: ARRAY
43962: ST_TO_ADDR
43963: GO 43966
43965: POP
43966: GO 44521
43968: LD_INT 2
43970: DOUBLE
43971: EQUAL
43972: IFTRUE 43982
43974: LD_INT 3
43976: DOUBLE
43977: EQUAL
43978: IFTRUE 43982
43980: GO 44038
43982: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
43983: LD_ADDR_VAR 0 9
43987: PUSH
43988: LD_VAR 0 29
43992: PUSH
43993: LD_VAR 0 30
43997: PUSH
43998: LD_VAR 0 31
44002: PUSH
44003: LD_VAR 0 32
44007: PUSH
44008: LD_VAR 0 33
44012: PUSH
44013: LD_VAR 0 34
44017: PUSH
44018: EMPTY
44019: LIST
44020: LIST
44021: LIST
44022: LIST
44023: LIST
44024: LIST
44025: PUSH
44026: LD_VAR 0 4
44030: PUSH
44031: LD_INT 1
44033: PLUS
44034: ARRAY
44035: ST_TO_ADDR
44036: GO 44521
44038: LD_INT 16
44040: DOUBLE
44041: EQUAL
44042: IFTRUE 44100
44044: LD_INT 17
44046: DOUBLE
44047: EQUAL
44048: IFTRUE 44100
44050: LD_INT 18
44052: DOUBLE
44053: EQUAL
44054: IFTRUE 44100
44056: LD_INT 19
44058: DOUBLE
44059: EQUAL
44060: IFTRUE 44100
44062: LD_INT 22
44064: DOUBLE
44065: EQUAL
44066: IFTRUE 44100
44068: LD_INT 20
44070: DOUBLE
44071: EQUAL
44072: IFTRUE 44100
44074: LD_INT 21
44076: DOUBLE
44077: EQUAL
44078: IFTRUE 44100
44080: LD_INT 23
44082: DOUBLE
44083: EQUAL
44084: IFTRUE 44100
44086: LD_INT 24
44088: DOUBLE
44089: EQUAL
44090: IFTRUE 44100
44092: LD_INT 25
44094: DOUBLE
44095: EQUAL
44096: IFTRUE 44100
44098: GO 44156
44100: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
44101: LD_ADDR_VAR 0 9
44105: PUSH
44106: LD_VAR 0 35
44110: PUSH
44111: LD_VAR 0 36
44115: PUSH
44116: LD_VAR 0 37
44120: PUSH
44121: LD_VAR 0 38
44125: PUSH
44126: LD_VAR 0 39
44130: PUSH
44131: LD_VAR 0 40
44135: PUSH
44136: EMPTY
44137: LIST
44138: LIST
44139: LIST
44140: LIST
44141: LIST
44142: LIST
44143: PUSH
44144: LD_VAR 0 4
44148: PUSH
44149: LD_INT 1
44151: PLUS
44152: ARRAY
44153: ST_TO_ADDR
44154: GO 44521
44156: LD_INT 6
44158: DOUBLE
44159: EQUAL
44160: IFTRUE 44212
44162: LD_INT 7
44164: DOUBLE
44165: EQUAL
44166: IFTRUE 44212
44168: LD_INT 8
44170: DOUBLE
44171: EQUAL
44172: IFTRUE 44212
44174: LD_INT 13
44176: DOUBLE
44177: EQUAL
44178: IFTRUE 44212
44180: LD_INT 12
44182: DOUBLE
44183: EQUAL
44184: IFTRUE 44212
44186: LD_INT 15
44188: DOUBLE
44189: EQUAL
44190: IFTRUE 44212
44192: LD_INT 11
44194: DOUBLE
44195: EQUAL
44196: IFTRUE 44212
44198: LD_INT 14
44200: DOUBLE
44201: EQUAL
44202: IFTRUE 44212
44204: LD_INT 10
44206: DOUBLE
44207: EQUAL
44208: IFTRUE 44212
44210: GO 44268
44212: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
44213: LD_ADDR_VAR 0 9
44217: PUSH
44218: LD_VAR 0 41
44222: PUSH
44223: LD_VAR 0 42
44227: PUSH
44228: LD_VAR 0 43
44232: PUSH
44233: LD_VAR 0 44
44237: PUSH
44238: LD_VAR 0 45
44242: PUSH
44243: LD_VAR 0 46
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: LIST
44252: LIST
44253: LIST
44254: LIST
44255: PUSH
44256: LD_VAR 0 4
44260: PUSH
44261: LD_INT 1
44263: PLUS
44264: ARRAY
44265: ST_TO_ADDR
44266: GO 44521
44268: LD_INT 36
44270: DOUBLE
44271: EQUAL
44272: IFTRUE 44276
44274: GO 44332
44276: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
44277: LD_ADDR_VAR 0 9
44281: PUSH
44282: LD_VAR 0 47
44286: PUSH
44287: LD_VAR 0 48
44291: PUSH
44292: LD_VAR 0 49
44296: PUSH
44297: LD_VAR 0 50
44301: PUSH
44302: LD_VAR 0 51
44306: PUSH
44307: LD_VAR 0 52
44311: PUSH
44312: EMPTY
44313: LIST
44314: LIST
44315: LIST
44316: LIST
44317: LIST
44318: LIST
44319: PUSH
44320: LD_VAR 0 4
44324: PUSH
44325: LD_INT 1
44327: PLUS
44328: ARRAY
44329: ST_TO_ADDR
44330: GO 44521
44332: LD_INT 4
44334: DOUBLE
44335: EQUAL
44336: IFTRUE 44358
44338: LD_INT 5
44340: DOUBLE
44341: EQUAL
44342: IFTRUE 44358
44344: LD_INT 34
44346: DOUBLE
44347: EQUAL
44348: IFTRUE 44358
44350: LD_INT 37
44352: DOUBLE
44353: EQUAL
44354: IFTRUE 44358
44356: GO 44414
44358: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
44359: LD_ADDR_VAR 0 9
44363: PUSH
44364: LD_VAR 0 53
44368: PUSH
44369: LD_VAR 0 54
44373: PUSH
44374: LD_VAR 0 55
44378: PUSH
44379: LD_VAR 0 56
44383: PUSH
44384: LD_VAR 0 57
44388: PUSH
44389: LD_VAR 0 58
44393: PUSH
44394: EMPTY
44395: LIST
44396: LIST
44397: LIST
44398: LIST
44399: LIST
44400: LIST
44401: PUSH
44402: LD_VAR 0 4
44406: PUSH
44407: LD_INT 1
44409: PLUS
44410: ARRAY
44411: ST_TO_ADDR
44412: GO 44521
44414: LD_INT 31
44416: DOUBLE
44417: EQUAL
44418: IFTRUE 44464
44420: LD_INT 32
44422: DOUBLE
44423: EQUAL
44424: IFTRUE 44464
44426: LD_INT 33
44428: DOUBLE
44429: EQUAL
44430: IFTRUE 44464
44432: LD_INT 27
44434: DOUBLE
44435: EQUAL
44436: IFTRUE 44464
44438: LD_INT 26
44440: DOUBLE
44441: EQUAL
44442: IFTRUE 44464
44444: LD_INT 28
44446: DOUBLE
44447: EQUAL
44448: IFTRUE 44464
44450: LD_INT 29
44452: DOUBLE
44453: EQUAL
44454: IFTRUE 44464
44456: LD_INT 30
44458: DOUBLE
44459: EQUAL
44460: IFTRUE 44464
44462: GO 44520
44464: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
44465: LD_ADDR_VAR 0 9
44469: PUSH
44470: LD_VAR 0 59
44474: PUSH
44475: LD_VAR 0 60
44479: PUSH
44480: LD_VAR 0 61
44484: PUSH
44485: LD_VAR 0 62
44489: PUSH
44490: LD_VAR 0 63
44494: PUSH
44495: LD_VAR 0 64
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: LIST
44504: LIST
44505: LIST
44506: LIST
44507: PUSH
44508: LD_VAR 0 4
44512: PUSH
44513: LD_INT 1
44515: PLUS
44516: ARRAY
44517: ST_TO_ADDR
44518: GO 44521
44520: POP
// temp_list2 = [ ] ;
44521: LD_ADDR_VAR 0 10
44525: PUSH
44526: EMPTY
44527: ST_TO_ADDR
// for i in temp_list do
44528: LD_ADDR_VAR 0 8
44532: PUSH
44533: LD_VAR 0 9
44537: PUSH
44538: FOR_IN
44539: IFFALSE 44591
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
44541: LD_ADDR_VAR 0 10
44545: PUSH
44546: LD_VAR 0 10
44550: PUSH
44551: LD_VAR 0 8
44555: PUSH
44556: LD_INT 1
44558: ARRAY
44559: PUSH
44560: LD_VAR 0 2
44564: PLUS
44565: PUSH
44566: LD_VAR 0 8
44570: PUSH
44571: LD_INT 2
44573: ARRAY
44574: PUSH
44575: LD_VAR 0 3
44579: PLUS
44580: PUSH
44581: EMPTY
44582: LIST
44583: LIST
44584: PUSH
44585: EMPTY
44586: LIST
44587: ADD
44588: ST_TO_ADDR
44589: GO 44538
44591: POP
44592: POP
// result = temp_list2 ;
44593: LD_ADDR_VAR 0 7
44597: PUSH
44598: LD_VAR 0 10
44602: ST_TO_ADDR
// end ;
44603: LD_VAR 0 7
44607: RET
// export function EnemyInRange ( unit , dist ) ; begin
44608: LD_INT 0
44610: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
44611: LD_ADDR_VAR 0 3
44615: PUSH
44616: LD_VAR 0 1
44620: PPUSH
44621: CALL_OW 255
44625: PPUSH
44626: LD_VAR 0 1
44630: PPUSH
44631: CALL_OW 250
44635: PPUSH
44636: LD_VAR 0 1
44640: PPUSH
44641: CALL_OW 251
44645: PPUSH
44646: LD_VAR 0 2
44650: PPUSH
44651: CALL 18712 0 4
44655: PUSH
44656: LD_INT 4
44658: ARRAY
44659: ST_TO_ADDR
// end ;
44660: LD_VAR 0 3
44664: RET
// export function PlayerSeeMe ( unit ) ; begin
44665: LD_INT 0
44667: PPUSH
// result := See ( your_side , unit ) ;
44668: LD_ADDR_VAR 0 2
44672: PUSH
44673: LD_OWVAR 2
44677: PPUSH
44678: LD_VAR 0 1
44682: PPUSH
44683: CALL_OW 292
44687: ST_TO_ADDR
// end ;
44688: LD_VAR 0 2
44692: RET
// export function ReverseDir ( unit ) ; begin
44693: LD_INT 0
44695: PPUSH
// if not unit then
44696: LD_VAR 0 1
44700: NOT
44701: IFFALSE 44705
// exit ;
44703: GO 44751
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
44705: LD_ADDR_VAR 0 2
44709: PUSH
44710: LD_INT 3
44712: PUSH
44713: LD_INT 4
44715: PUSH
44716: LD_INT 5
44718: PUSH
44719: LD_INT 0
44721: PUSH
44722: LD_INT 1
44724: PUSH
44725: LD_INT 2
44727: PUSH
44728: EMPTY
44729: LIST
44730: LIST
44731: LIST
44732: LIST
44733: LIST
44734: LIST
44735: PUSH
44736: LD_VAR 0 1
44740: PPUSH
44741: CALL_OW 254
44745: PUSH
44746: LD_INT 1
44748: PLUS
44749: ARRAY
44750: ST_TO_ADDR
// end ;
44751: LD_VAR 0 2
44755: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
44756: LD_INT 0
44758: PPUSH
44759: PPUSH
44760: PPUSH
44761: PPUSH
44762: PPUSH
// if not hexes then
44763: LD_VAR 0 2
44767: NOT
44768: IFFALSE 44772
// exit ;
44770: GO 44920
// dist := 9999 ;
44772: LD_ADDR_VAR 0 5
44776: PUSH
44777: LD_INT 9999
44779: ST_TO_ADDR
// for i = 1 to hexes do
44780: LD_ADDR_VAR 0 4
44784: PUSH
44785: DOUBLE
44786: LD_INT 1
44788: DEC
44789: ST_TO_ADDR
44790: LD_VAR 0 2
44794: PUSH
44795: FOR_TO
44796: IFFALSE 44908
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
44798: LD_VAR 0 1
44802: PPUSH
44803: LD_VAR 0 2
44807: PUSH
44808: LD_VAR 0 4
44812: ARRAY
44813: PUSH
44814: LD_INT 1
44816: ARRAY
44817: PPUSH
44818: LD_VAR 0 2
44822: PUSH
44823: LD_VAR 0 4
44827: ARRAY
44828: PUSH
44829: LD_INT 2
44831: ARRAY
44832: PPUSH
44833: CALL_OW 297
44837: PUSH
44838: LD_VAR 0 5
44842: LESS
44843: IFFALSE 44906
// begin hex := hexes [ i ] ;
44845: LD_ADDR_VAR 0 7
44849: PUSH
44850: LD_VAR 0 2
44854: PUSH
44855: LD_VAR 0 4
44859: ARRAY
44860: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
44861: LD_ADDR_VAR 0 5
44865: PUSH
44866: LD_VAR 0 1
44870: PPUSH
44871: LD_VAR 0 2
44875: PUSH
44876: LD_VAR 0 4
44880: ARRAY
44881: PUSH
44882: LD_INT 1
44884: ARRAY
44885: PPUSH
44886: LD_VAR 0 2
44890: PUSH
44891: LD_VAR 0 4
44895: ARRAY
44896: PUSH
44897: LD_INT 2
44899: ARRAY
44900: PPUSH
44901: CALL_OW 297
44905: ST_TO_ADDR
// end ; end ;
44906: GO 44795
44908: POP
44909: POP
// result := hex ;
44910: LD_ADDR_VAR 0 3
44914: PUSH
44915: LD_VAR 0 7
44919: ST_TO_ADDR
// end ;
44920: LD_VAR 0 3
44924: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
44925: LD_INT 0
44927: PPUSH
44928: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
44929: LD_VAR 0 1
44933: NOT
44934: PUSH
44935: LD_VAR 0 1
44939: PUSH
44940: LD_INT 21
44942: PUSH
44943: LD_INT 2
44945: PUSH
44946: EMPTY
44947: LIST
44948: LIST
44949: PUSH
44950: LD_INT 23
44952: PUSH
44953: LD_INT 2
44955: PUSH
44956: EMPTY
44957: LIST
44958: LIST
44959: PUSH
44960: EMPTY
44961: LIST
44962: LIST
44963: PPUSH
44964: CALL_OW 69
44968: IN
44969: NOT
44970: OR
44971: IFFALSE 44975
// exit ;
44973: GO 45022
// for i = 1 to 3 do
44975: LD_ADDR_VAR 0 3
44979: PUSH
44980: DOUBLE
44981: LD_INT 1
44983: DEC
44984: ST_TO_ADDR
44985: LD_INT 3
44987: PUSH
44988: FOR_TO
44989: IFFALSE 45020
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
44991: LD_VAR 0 1
44995: PPUSH
44996: CALL_OW 250
45000: PPUSH
45001: LD_VAR 0 1
45005: PPUSH
45006: CALL_OW 251
45010: PPUSH
45011: LD_INT 1
45013: PPUSH
45014: CALL_OW 453
45018: GO 44988
45020: POP
45021: POP
// end ;
45022: LD_VAR 0 2
45026: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
45027: LD_INT 0
45029: PPUSH
45030: PPUSH
45031: PPUSH
45032: PPUSH
45033: PPUSH
45034: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
45035: LD_VAR 0 1
45039: NOT
45040: PUSH
45041: LD_VAR 0 2
45045: NOT
45046: OR
45047: PUSH
45048: LD_VAR 0 1
45052: PPUSH
45053: CALL_OW 314
45057: OR
45058: IFFALSE 45062
// exit ;
45060: GO 45503
// x := GetX ( enemy_unit ) ;
45062: LD_ADDR_VAR 0 7
45066: PUSH
45067: LD_VAR 0 2
45071: PPUSH
45072: CALL_OW 250
45076: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
45077: LD_ADDR_VAR 0 8
45081: PUSH
45082: LD_VAR 0 2
45086: PPUSH
45087: CALL_OW 251
45091: ST_TO_ADDR
// if not x or not y then
45092: LD_VAR 0 7
45096: NOT
45097: PUSH
45098: LD_VAR 0 8
45102: NOT
45103: OR
45104: IFFALSE 45108
// exit ;
45106: GO 45503
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
45108: LD_ADDR_VAR 0 6
45112: PUSH
45113: LD_VAR 0 7
45117: PPUSH
45118: LD_INT 0
45120: PPUSH
45121: LD_INT 4
45123: PPUSH
45124: CALL_OW 272
45128: PUSH
45129: LD_VAR 0 8
45133: PPUSH
45134: LD_INT 0
45136: PPUSH
45137: LD_INT 4
45139: PPUSH
45140: CALL_OW 273
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: PUSH
45149: LD_VAR 0 7
45153: PPUSH
45154: LD_INT 1
45156: PPUSH
45157: LD_INT 4
45159: PPUSH
45160: CALL_OW 272
45164: PUSH
45165: LD_VAR 0 8
45169: PPUSH
45170: LD_INT 1
45172: PPUSH
45173: LD_INT 4
45175: PPUSH
45176: CALL_OW 273
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_VAR 0 7
45189: PPUSH
45190: LD_INT 2
45192: PPUSH
45193: LD_INT 4
45195: PPUSH
45196: CALL_OW 272
45200: PUSH
45201: LD_VAR 0 8
45205: PPUSH
45206: LD_INT 2
45208: PPUSH
45209: LD_INT 4
45211: PPUSH
45212: CALL_OW 273
45216: PUSH
45217: EMPTY
45218: LIST
45219: LIST
45220: PUSH
45221: LD_VAR 0 7
45225: PPUSH
45226: LD_INT 3
45228: PPUSH
45229: LD_INT 4
45231: PPUSH
45232: CALL_OW 272
45236: PUSH
45237: LD_VAR 0 8
45241: PPUSH
45242: LD_INT 3
45244: PPUSH
45245: LD_INT 4
45247: PPUSH
45248: CALL_OW 273
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: LD_VAR 0 7
45261: PPUSH
45262: LD_INT 4
45264: PPUSH
45265: LD_INT 4
45267: PPUSH
45268: CALL_OW 272
45272: PUSH
45273: LD_VAR 0 8
45277: PPUSH
45278: LD_INT 4
45280: PPUSH
45281: LD_INT 4
45283: PPUSH
45284: CALL_OW 273
45288: PUSH
45289: EMPTY
45290: LIST
45291: LIST
45292: PUSH
45293: LD_VAR 0 7
45297: PPUSH
45298: LD_INT 5
45300: PPUSH
45301: LD_INT 4
45303: PPUSH
45304: CALL_OW 272
45308: PUSH
45309: LD_VAR 0 8
45313: PPUSH
45314: LD_INT 5
45316: PPUSH
45317: LD_INT 4
45319: PPUSH
45320: CALL_OW 273
45324: PUSH
45325: EMPTY
45326: LIST
45327: LIST
45328: PUSH
45329: EMPTY
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: LIST
45336: ST_TO_ADDR
// for i = tmp downto 1 do
45337: LD_ADDR_VAR 0 4
45341: PUSH
45342: DOUBLE
45343: LD_VAR 0 6
45347: INC
45348: ST_TO_ADDR
45349: LD_INT 1
45351: PUSH
45352: FOR_DOWNTO
45353: IFFALSE 45454
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
45355: LD_VAR 0 6
45359: PUSH
45360: LD_VAR 0 4
45364: ARRAY
45365: PUSH
45366: LD_INT 1
45368: ARRAY
45369: PPUSH
45370: LD_VAR 0 6
45374: PUSH
45375: LD_VAR 0 4
45379: ARRAY
45380: PUSH
45381: LD_INT 2
45383: ARRAY
45384: PPUSH
45385: CALL_OW 488
45389: NOT
45390: PUSH
45391: LD_VAR 0 6
45395: PUSH
45396: LD_VAR 0 4
45400: ARRAY
45401: PUSH
45402: LD_INT 1
45404: ARRAY
45405: PPUSH
45406: LD_VAR 0 6
45410: PUSH
45411: LD_VAR 0 4
45415: ARRAY
45416: PUSH
45417: LD_INT 2
45419: ARRAY
45420: PPUSH
45421: CALL_OW 428
45425: PUSH
45426: LD_INT 0
45428: NONEQUAL
45429: OR
45430: IFFALSE 45452
// tmp := Delete ( tmp , i ) ;
45432: LD_ADDR_VAR 0 6
45436: PUSH
45437: LD_VAR 0 6
45441: PPUSH
45442: LD_VAR 0 4
45446: PPUSH
45447: CALL_OW 3
45451: ST_TO_ADDR
45452: GO 45352
45454: POP
45455: POP
// j := GetClosestHex ( unit , tmp ) ;
45456: LD_ADDR_VAR 0 5
45460: PUSH
45461: LD_VAR 0 1
45465: PPUSH
45466: LD_VAR 0 6
45470: PPUSH
45471: CALL 44756 0 2
45475: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
45476: LD_VAR 0 1
45480: PPUSH
45481: LD_VAR 0 5
45485: PUSH
45486: LD_INT 1
45488: ARRAY
45489: PPUSH
45490: LD_VAR 0 5
45494: PUSH
45495: LD_INT 2
45497: ARRAY
45498: PPUSH
45499: CALL_OW 111
// end ;
45503: LD_VAR 0 3
45507: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
45508: LD_INT 0
45510: PPUSH
45511: PPUSH
45512: PPUSH
// uc_side = 0 ;
45513: LD_ADDR_OWVAR 20
45517: PUSH
45518: LD_INT 0
45520: ST_TO_ADDR
// uc_nation = 0 ;
45521: LD_ADDR_OWVAR 21
45525: PUSH
45526: LD_INT 0
45528: ST_TO_ADDR
// InitHc ;
45529: CALL_OW 19
// InitVc ;
45533: CALL_OW 20
// if mastodonts then
45537: LD_VAR 0 6
45541: IFFALSE 45608
// for i = 1 to mastodonts do
45543: LD_ADDR_VAR 0 11
45547: PUSH
45548: DOUBLE
45549: LD_INT 1
45551: DEC
45552: ST_TO_ADDR
45553: LD_VAR 0 6
45557: PUSH
45558: FOR_TO
45559: IFFALSE 45606
// begin vc_chassis := 31 ;
45561: LD_ADDR_OWVAR 37
45565: PUSH
45566: LD_INT 31
45568: ST_TO_ADDR
// vc_control := control_rider ;
45569: LD_ADDR_OWVAR 38
45573: PUSH
45574: LD_INT 4
45576: ST_TO_ADDR
// animal := CreateVehicle ;
45577: LD_ADDR_VAR 0 12
45581: PUSH
45582: CALL_OW 45
45586: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45587: LD_VAR 0 12
45591: PPUSH
45592: LD_VAR 0 8
45596: PPUSH
45597: LD_INT 0
45599: PPUSH
45600: CALL 52353 0 3
// end ;
45604: GO 45558
45606: POP
45607: POP
// if horses then
45608: LD_VAR 0 5
45612: IFFALSE 45679
// for i = 1 to horses do
45614: LD_ADDR_VAR 0 11
45618: PUSH
45619: DOUBLE
45620: LD_INT 1
45622: DEC
45623: ST_TO_ADDR
45624: LD_VAR 0 5
45628: PUSH
45629: FOR_TO
45630: IFFALSE 45677
// begin hc_class := 21 ;
45632: LD_ADDR_OWVAR 28
45636: PUSH
45637: LD_INT 21
45639: ST_TO_ADDR
// hc_gallery :=  ;
45640: LD_ADDR_OWVAR 33
45644: PUSH
45645: LD_STRING 
45647: ST_TO_ADDR
// animal := CreateHuman ;
45648: LD_ADDR_VAR 0 12
45652: PUSH
45653: CALL_OW 44
45657: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45658: LD_VAR 0 12
45662: PPUSH
45663: LD_VAR 0 8
45667: PPUSH
45668: LD_INT 0
45670: PPUSH
45671: CALL 52353 0 3
// end ;
45675: GO 45629
45677: POP
45678: POP
// if birds then
45679: LD_VAR 0 1
45683: IFFALSE 45750
// for i = 1 to birds do
45685: LD_ADDR_VAR 0 11
45689: PUSH
45690: DOUBLE
45691: LD_INT 1
45693: DEC
45694: ST_TO_ADDR
45695: LD_VAR 0 1
45699: PUSH
45700: FOR_TO
45701: IFFALSE 45748
// begin hc_class = 18 ;
45703: LD_ADDR_OWVAR 28
45707: PUSH
45708: LD_INT 18
45710: ST_TO_ADDR
// hc_gallery =  ;
45711: LD_ADDR_OWVAR 33
45715: PUSH
45716: LD_STRING 
45718: ST_TO_ADDR
// animal := CreateHuman ;
45719: LD_ADDR_VAR 0 12
45723: PUSH
45724: CALL_OW 44
45728: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45729: LD_VAR 0 12
45733: PPUSH
45734: LD_VAR 0 8
45738: PPUSH
45739: LD_INT 0
45741: PPUSH
45742: CALL 52353 0 3
// end ;
45746: GO 45700
45748: POP
45749: POP
// if tigers then
45750: LD_VAR 0 2
45754: IFFALSE 45838
// for i = 1 to tigers do
45756: LD_ADDR_VAR 0 11
45760: PUSH
45761: DOUBLE
45762: LD_INT 1
45764: DEC
45765: ST_TO_ADDR
45766: LD_VAR 0 2
45770: PUSH
45771: FOR_TO
45772: IFFALSE 45836
// begin hc_class = class_tiger ;
45774: LD_ADDR_OWVAR 28
45778: PUSH
45779: LD_INT 14
45781: ST_TO_ADDR
// hc_gallery =  ;
45782: LD_ADDR_OWVAR 33
45786: PUSH
45787: LD_STRING 
45789: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
45790: LD_ADDR_OWVAR 35
45794: PUSH
45795: LD_INT 7
45797: NEG
45798: PPUSH
45799: LD_INT 7
45801: PPUSH
45802: CALL_OW 12
45806: ST_TO_ADDR
// animal := CreateHuman ;
45807: LD_ADDR_VAR 0 12
45811: PUSH
45812: CALL_OW 44
45816: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45817: LD_VAR 0 12
45821: PPUSH
45822: LD_VAR 0 8
45826: PPUSH
45827: LD_INT 0
45829: PPUSH
45830: CALL 52353 0 3
// end ;
45834: GO 45771
45836: POP
45837: POP
// if apemans then
45838: LD_VAR 0 3
45842: IFFALSE 45965
// for i = 1 to apemans do
45844: LD_ADDR_VAR 0 11
45848: PUSH
45849: DOUBLE
45850: LD_INT 1
45852: DEC
45853: ST_TO_ADDR
45854: LD_VAR 0 3
45858: PUSH
45859: FOR_TO
45860: IFFALSE 45963
// begin hc_class = class_apeman ;
45862: LD_ADDR_OWVAR 28
45866: PUSH
45867: LD_INT 12
45869: ST_TO_ADDR
// hc_gallery =  ;
45870: LD_ADDR_OWVAR 33
45874: PUSH
45875: LD_STRING 
45877: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
45878: LD_ADDR_OWVAR 35
45882: PUSH
45883: LD_INT 5
45885: NEG
45886: PPUSH
45887: LD_INT 5
45889: PPUSH
45890: CALL_OW 12
45894: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
45895: LD_ADDR_OWVAR 31
45899: PUSH
45900: LD_INT 1
45902: PPUSH
45903: LD_INT 3
45905: PPUSH
45906: CALL_OW 12
45910: PUSH
45911: LD_INT 1
45913: PPUSH
45914: LD_INT 3
45916: PPUSH
45917: CALL_OW 12
45921: PUSH
45922: LD_INT 0
45924: PUSH
45925: LD_INT 0
45927: PUSH
45928: EMPTY
45929: LIST
45930: LIST
45931: LIST
45932: LIST
45933: ST_TO_ADDR
// animal := CreateHuman ;
45934: LD_ADDR_VAR 0 12
45938: PUSH
45939: CALL_OW 44
45943: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45944: LD_VAR 0 12
45948: PPUSH
45949: LD_VAR 0 8
45953: PPUSH
45954: LD_INT 0
45956: PPUSH
45957: CALL 52353 0 3
// end ;
45961: GO 45859
45963: POP
45964: POP
// if enchidnas then
45965: LD_VAR 0 4
45969: IFFALSE 46036
// for i = 1 to enchidnas do
45971: LD_ADDR_VAR 0 11
45975: PUSH
45976: DOUBLE
45977: LD_INT 1
45979: DEC
45980: ST_TO_ADDR
45981: LD_VAR 0 4
45985: PUSH
45986: FOR_TO
45987: IFFALSE 46034
// begin hc_class = 13 ;
45989: LD_ADDR_OWVAR 28
45993: PUSH
45994: LD_INT 13
45996: ST_TO_ADDR
// hc_gallery =  ;
45997: LD_ADDR_OWVAR 33
46001: PUSH
46002: LD_STRING 
46004: ST_TO_ADDR
// animal := CreateHuman ;
46005: LD_ADDR_VAR 0 12
46009: PUSH
46010: CALL_OW 44
46014: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46015: LD_VAR 0 12
46019: PPUSH
46020: LD_VAR 0 8
46024: PPUSH
46025: LD_INT 0
46027: PPUSH
46028: CALL 52353 0 3
// end ;
46032: GO 45986
46034: POP
46035: POP
// if fishes then
46036: LD_VAR 0 7
46040: IFFALSE 46107
// for i = 1 to fishes do
46042: LD_ADDR_VAR 0 11
46046: PUSH
46047: DOUBLE
46048: LD_INT 1
46050: DEC
46051: ST_TO_ADDR
46052: LD_VAR 0 7
46056: PUSH
46057: FOR_TO
46058: IFFALSE 46105
// begin hc_class = 20 ;
46060: LD_ADDR_OWVAR 28
46064: PUSH
46065: LD_INT 20
46067: ST_TO_ADDR
// hc_gallery =  ;
46068: LD_ADDR_OWVAR 33
46072: PUSH
46073: LD_STRING 
46075: ST_TO_ADDR
// animal := CreateHuman ;
46076: LD_ADDR_VAR 0 12
46080: PUSH
46081: CALL_OW 44
46085: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
46086: LD_VAR 0 12
46090: PPUSH
46091: LD_VAR 0 9
46095: PPUSH
46096: LD_INT 0
46098: PPUSH
46099: CALL 52353 0 3
// end ;
46103: GO 46057
46105: POP
46106: POP
// end ;
46107: LD_VAR 0 10
46111: RET
// export function WantHeal ( sci , unit ) ; begin
46112: LD_INT 0
46114: PPUSH
// if GetTaskList ( sci ) > 0 then
46115: LD_VAR 0 1
46119: PPUSH
46120: CALL_OW 437
46124: PUSH
46125: LD_INT 0
46127: GREATER
46128: IFFALSE 46198
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
46130: LD_VAR 0 1
46134: PPUSH
46135: CALL_OW 437
46139: PUSH
46140: LD_INT 1
46142: ARRAY
46143: PUSH
46144: LD_INT 1
46146: ARRAY
46147: PUSH
46148: LD_STRING l
46150: EQUAL
46151: PUSH
46152: LD_VAR 0 1
46156: PPUSH
46157: CALL_OW 437
46161: PUSH
46162: LD_INT 1
46164: ARRAY
46165: PUSH
46166: LD_INT 4
46168: ARRAY
46169: PUSH
46170: LD_VAR 0 2
46174: EQUAL
46175: AND
46176: IFFALSE 46188
// result := true else
46178: LD_ADDR_VAR 0 3
46182: PUSH
46183: LD_INT 1
46185: ST_TO_ADDR
46186: GO 46196
// result := false ;
46188: LD_ADDR_VAR 0 3
46192: PUSH
46193: LD_INT 0
46195: ST_TO_ADDR
// end else
46196: GO 46206
// result := false ;
46198: LD_ADDR_VAR 0 3
46202: PUSH
46203: LD_INT 0
46205: ST_TO_ADDR
// end ;
46206: LD_VAR 0 3
46210: RET
// export function HealTarget ( sci ) ; begin
46211: LD_INT 0
46213: PPUSH
// if not sci then
46214: LD_VAR 0 1
46218: NOT
46219: IFFALSE 46223
// exit ;
46221: GO 46288
// result := 0 ;
46223: LD_ADDR_VAR 0 2
46227: PUSH
46228: LD_INT 0
46230: ST_TO_ADDR
// if GetTaskList ( sci ) then
46231: LD_VAR 0 1
46235: PPUSH
46236: CALL_OW 437
46240: IFFALSE 46288
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
46242: LD_VAR 0 1
46246: PPUSH
46247: CALL_OW 437
46251: PUSH
46252: LD_INT 1
46254: ARRAY
46255: PUSH
46256: LD_INT 1
46258: ARRAY
46259: PUSH
46260: LD_STRING l
46262: EQUAL
46263: IFFALSE 46288
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
46265: LD_ADDR_VAR 0 2
46269: PUSH
46270: LD_VAR 0 1
46274: PPUSH
46275: CALL_OW 437
46279: PUSH
46280: LD_INT 1
46282: ARRAY
46283: PUSH
46284: LD_INT 4
46286: ARRAY
46287: ST_TO_ADDR
// end ;
46288: LD_VAR 0 2
46292: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
46293: LD_INT 0
46295: PPUSH
46296: PPUSH
46297: PPUSH
46298: PPUSH
46299: PPUSH
46300: PPUSH
46301: PPUSH
46302: PPUSH
46303: PPUSH
46304: PPUSH
46305: PPUSH
46306: PPUSH
46307: PPUSH
46308: PPUSH
46309: PPUSH
46310: PPUSH
46311: PPUSH
46312: PPUSH
46313: PPUSH
46314: PPUSH
46315: PPUSH
46316: PPUSH
46317: PPUSH
46318: PPUSH
46319: PPUSH
46320: PPUSH
46321: PPUSH
46322: PPUSH
46323: PPUSH
46324: PPUSH
46325: PPUSH
46326: PPUSH
46327: PPUSH
46328: PPUSH
// if not list then
46329: LD_VAR 0 1
46333: NOT
46334: IFFALSE 46338
// exit ;
46336: GO 50964
// base := list [ 1 ] ;
46338: LD_ADDR_VAR 0 3
46342: PUSH
46343: LD_VAR 0 1
46347: PUSH
46348: LD_INT 1
46350: ARRAY
46351: ST_TO_ADDR
// group := list [ 2 ] ;
46352: LD_ADDR_VAR 0 4
46356: PUSH
46357: LD_VAR 0 1
46361: PUSH
46362: LD_INT 2
46364: ARRAY
46365: ST_TO_ADDR
// path := list [ 3 ] ;
46366: LD_ADDR_VAR 0 5
46370: PUSH
46371: LD_VAR 0 1
46375: PUSH
46376: LD_INT 3
46378: ARRAY
46379: ST_TO_ADDR
// flags := list [ 4 ] ;
46380: LD_ADDR_VAR 0 6
46384: PUSH
46385: LD_VAR 0 1
46389: PUSH
46390: LD_INT 4
46392: ARRAY
46393: ST_TO_ADDR
// mined := [ ] ;
46394: LD_ADDR_VAR 0 27
46398: PUSH
46399: EMPTY
46400: ST_TO_ADDR
// bombed := [ ] ;
46401: LD_ADDR_VAR 0 28
46405: PUSH
46406: EMPTY
46407: ST_TO_ADDR
// healers := [ ] ;
46408: LD_ADDR_VAR 0 31
46412: PUSH
46413: EMPTY
46414: ST_TO_ADDR
// to_heal := [ ] ;
46415: LD_ADDR_VAR 0 30
46419: PUSH
46420: EMPTY
46421: ST_TO_ADDR
// repairs := [ ] ;
46422: LD_ADDR_VAR 0 33
46426: PUSH
46427: EMPTY
46428: ST_TO_ADDR
// to_repair := [ ] ;
46429: LD_ADDR_VAR 0 32
46433: PUSH
46434: EMPTY
46435: ST_TO_ADDR
// if not group or not path then
46436: LD_VAR 0 4
46440: NOT
46441: PUSH
46442: LD_VAR 0 5
46446: NOT
46447: OR
46448: IFFALSE 46452
// exit ;
46450: GO 50964
// side := GetSide ( group [ 1 ] ) ;
46452: LD_ADDR_VAR 0 35
46456: PUSH
46457: LD_VAR 0 4
46461: PUSH
46462: LD_INT 1
46464: ARRAY
46465: PPUSH
46466: CALL_OW 255
46470: ST_TO_ADDR
// if flags then
46471: LD_VAR 0 6
46475: IFFALSE 46619
// begin f_ignore_area := flags [ 1 ] ;
46477: LD_ADDR_VAR 0 17
46481: PUSH
46482: LD_VAR 0 6
46486: PUSH
46487: LD_INT 1
46489: ARRAY
46490: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
46491: LD_ADDR_VAR 0 18
46495: PUSH
46496: LD_VAR 0 6
46500: PUSH
46501: LD_INT 2
46503: ARRAY
46504: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
46505: LD_ADDR_VAR 0 19
46509: PUSH
46510: LD_VAR 0 6
46514: PUSH
46515: LD_INT 3
46517: ARRAY
46518: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
46519: LD_ADDR_VAR 0 20
46523: PUSH
46524: LD_VAR 0 6
46528: PUSH
46529: LD_INT 4
46531: ARRAY
46532: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
46533: LD_ADDR_VAR 0 21
46537: PUSH
46538: LD_VAR 0 6
46542: PUSH
46543: LD_INT 5
46545: ARRAY
46546: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
46547: LD_ADDR_VAR 0 22
46551: PUSH
46552: LD_VAR 0 6
46556: PUSH
46557: LD_INT 6
46559: ARRAY
46560: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
46561: LD_ADDR_VAR 0 23
46565: PUSH
46566: LD_VAR 0 6
46570: PUSH
46571: LD_INT 7
46573: ARRAY
46574: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
46575: LD_ADDR_VAR 0 24
46579: PUSH
46580: LD_VAR 0 6
46584: PUSH
46585: LD_INT 8
46587: ARRAY
46588: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
46589: LD_ADDR_VAR 0 25
46593: PUSH
46594: LD_VAR 0 6
46598: PUSH
46599: LD_INT 9
46601: ARRAY
46602: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
46603: LD_ADDR_VAR 0 26
46607: PUSH
46608: LD_VAR 0 6
46612: PUSH
46613: LD_INT 10
46615: ARRAY
46616: ST_TO_ADDR
// end else
46617: GO 46699
// begin f_ignore_area := false ;
46619: LD_ADDR_VAR 0 17
46623: PUSH
46624: LD_INT 0
46626: ST_TO_ADDR
// f_capture := false ;
46627: LD_ADDR_VAR 0 18
46631: PUSH
46632: LD_INT 0
46634: ST_TO_ADDR
// f_ignore_civ := false ;
46635: LD_ADDR_VAR 0 19
46639: PUSH
46640: LD_INT 0
46642: ST_TO_ADDR
// f_murder := false ;
46643: LD_ADDR_VAR 0 20
46647: PUSH
46648: LD_INT 0
46650: ST_TO_ADDR
// f_mines := false ;
46651: LD_ADDR_VAR 0 21
46655: PUSH
46656: LD_INT 0
46658: ST_TO_ADDR
// f_repair := false ;
46659: LD_ADDR_VAR 0 22
46663: PUSH
46664: LD_INT 0
46666: ST_TO_ADDR
// f_heal := false ;
46667: LD_ADDR_VAR 0 23
46671: PUSH
46672: LD_INT 0
46674: ST_TO_ADDR
// f_spacetime := false ;
46675: LD_ADDR_VAR 0 24
46679: PUSH
46680: LD_INT 0
46682: ST_TO_ADDR
// f_attack_depot := false ;
46683: LD_ADDR_VAR 0 25
46687: PUSH
46688: LD_INT 0
46690: ST_TO_ADDR
// f_crawl := false ;
46691: LD_ADDR_VAR 0 26
46695: PUSH
46696: LD_INT 0
46698: ST_TO_ADDR
// end ; if f_heal then
46699: LD_VAR 0 23
46703: IFFALSE 46730
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
46705: LD_ADDR_VAR 0 31
46709: PUSH
46710: LD_VAR 0 4
46714: PPUSH
46715: LD_INT 25
46717: PUSH
46718: LD_INT 4
46720: PUSH
46721: EMPTY
46722: LIST
46723: LIST
46724: PPUSH
46725: CALL_OW 72
46729: ST_TO_ADDR
// if f_repair then
46730: LD_VAR 0 22
46734: IFFALSE 46761
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
46736: LD_ADDR_VAR 0 33
46740: PUSH
46741: LD_VAR 0 4
46745: PPUSH
46746: LD_INT 25
46748: PUSH
46749: LD_INT 3
46751: PUSH
46752: EMPTY
46753: LIST
46754: LIST
46755: PPUSH
46756: CALL_OW 72
46760: ST_TO_ADDR
// units_path := [ ] ;
46761: LD_ADDR_VAR 0 16
46765: PUSH
46766: EMPTY
46767: ST_TO_ADDR
// for i = 1 to group do
46768: LD_ADDR_VAR 0 7
46772: PUSH
46773: DOUBLE
46774: LD_INT 1
46776: DEC
46777: ST_TO_ADDR
46778: LD_VAR 0 4
46782: PUSH
46783: FOR_TO
46784: IFFALSE 46813
// units_path := Replace ( units_path , i , path ) ;
46786: LD_ADDR_VAR 0 16
46790: PUSH
46791: LD_VAR 0 16
46795: PPUSH
46796: LD_VAR 0 7
46800: PPUSH
46801: LD_VAR 0 5
46805: PPUSH
46806: CALL_OW 1
46810: ST_TO_ADDR
46811: GO 46783
46813: POP
46814: POP
// repeat for i = group downto 1 do
46815: LD_ADDR_VAR 0 7
46819: PUSH
46820: DOUBLE
46821: LD_VAR 0 4
46825: INC
46826: ST_TO_ADDR
46827: LD_INT 1
46829: PUSH
46830: FOR_DOWNTO
46831: IFFALSE 50927
// begin wait ( 5 ) ;
46833: LD_INT 5
46835: PPUSH
46836: CALL_OW 67
// tmp := [ ] ;
46840: LD_ADDR_VAR 0 14
46844: PUSH
46845: EMPTY
46846: ST_TO_ADDR
// attacking := false ;
46847: LD_ADDR_VAR 0 29
46851: PUSH
46852: LD_INT 0
46854: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
46855: LD_VAR 0 4
46859: PUSH
46860: LD_VAR 0 7
46864: ARRAY
46865: PPUSH
46866: CALL_OW 301
46870: PUSH
46871: LD_VAR 0 4
46875: PUSH
46876: LD_VAR 0 7
46880: ARRAY
46881: NOT
46882: OR
46883: IFFALSE 46992
// begin if GetType ( group [ i ] ) = unit_human then
46885: LD_VAR 0 4
46889: PUSH
46890: LD_VAR 0 7
46894: ARRAY
46895: PPUSH
46896: CALL_OW 247
46900: PUSH
46901: LD_INT 1
46903: EQUAL
46904: IFFALSE 46950
// begin to_heal := to_heal diff group [ i ] ;
46906: LD_ADDR_VAR 0 30
46910: PUSH
46911: LD_VAR 0 30
46915: PUSH
46916: LD_VAR 0 4
46920: PUSH
46921: LD_VAR 0 7
46925: ARRAY
46926: DIFF
46927: ST_TO_ADDR
// healers := healers diff group [ i ] ;
46928: LD_ADDR_VAR 0 31
46932: PUSH
46933: LD_VAR 0 31
46937: PUSH
46938: LD_VAR 0 4
46942: PUSH
46943: LD_VAR 0 7
46947: ARRAY
46948: DIFF
46949: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
46950: LD_ADDR_VAR 0 4
46954: PUSH
46955: LD_VAR 0 4
46959: PPUSH
46960: LD_VAR 0 7
46964: PPUSH
46965: CALL_OW 3
46969: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
46970: LD_ADDR_VAR 0 16
46974: PUSH
46975: LD_VAR 0 16
46979: PPUSH
46980: LD_VAR 0 7
46984: PPUSH
46985: CALL_OW 3
46989: ST_TO_ADDR
// continue ;
46990: GO 46830
// end ; if f_repair then
46992: LD_VAR 0 22
46996: IFFALSE 47485
// begin if GetType ( group [ i ] ) = unit_vehicle then
46998: LD_VAR 0 4
47002: PUSH
47003: LD_VAR 0 7
47007: ARRAY
47008: PPUSH
47009: CALL_OW 247
47013: PUSH
47014: LD_INT 2
47016: EQUAL
47017: IFFALSE 47207
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
47019: LD_VAR 0 4
47023: PUSH
47024: LD_VAR 0 7
47028: ARRAY
47029: PPUSH
47030: CALL_OW 256
47034: PUSH
47035: LD_INT 700
47037: LESS
47038: PUSH
47039: LD_VAR 0 4
47043: PUSH
47044: LD_VAR 0 7
47048: ARRAY
47049: PUSH
47050: LD_VAR 0 32
47054: IN
47055: NOT
47056: AND
47057: IFFALSE 47081
// to_repair := to_repair union group [ i ] ;
47059: LD_ADDR_VAR 0 32
47063: PUSH
47064: LD_VAR 0 32
47068: PUSH
47069: LD_VAR 0 4
47073: PUSH
47074: LD_VAR 0 7
47078: ARRAY
47079: UNION
47080: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
47081: LD_VAR 0 4
47085: PUSH
47086: LD_VAR 0 7
47090: ARRAY
47091: PPUSH
47092: CALL_OW 256
47096: PUSH
47097: LD_INT 1000
47099: EQUAL
47100: PUSH
47101: LD_VAR 0 4
47105: PUSH
47106: LD_VAR 0 7
47110: ARRAY
47111: PUSH
47112: LD_VAR 0 32
47116: IN
47117: AND
47118: IFFALSE 47142
// to_repair := to_repair diff group [ i ] ;
47120: LD_ADDR_VAR 0 32
47124: PUSH
47125: LD_VAR 0 32
47129: PUSH
47130: LD_VAR 0 4
47134: PUSH
47135: LD_VAR 0 7
47139: ARRAY
47140: DIFF
47141: ST_TO_ADDR
// if group [ i ] in to_repair then
47142: LD_VAR 0 4
47146: PUSH
47147: LD_VAR 0 7
47151: ARRAY
47152: PUSH
47153: LD_VAR 0 32
47157: IN
47158: IFFALSE 47205
// begin if not IsInArea ( group [ i ] , f_repair ) then
47160: LD_VAR 0 4
47164: PUSH
47165: LD_VAR 0 7
47169: ARRAY
47170: PPUSH
47171: LD_VAR 0 22
47175: PPUSH
47176: CALL_OW 308
47180: NOT
47181: IFFALSE 47203
// ComMoveToArea ( group [ i ] , f_repair ) ;
47183: LD_VAR 0 4
47187: PUSH
47188: LD_VAR 0 7
47192: ARRAY
47193: PPUSH
47194: LD_VAR 0 22
47198: PPUSH
47199: CALL_OW 113
// continue ;
47203: GO 46830
// end ; end else
47205: GO 47485
// if group [ i ] in repairs then
47207: LD_VAR 0 4
47211: PUSH
47212: LD_VAR 0 7
47216: ARRAY
47217: PUSH
47218: LD_VAR 0 33
47222: IN
47223: IFFALSE 47485
// begin if IsInUnit ( group [ i ] ) then
47225: LD_VAR 0 4
47229: PUSH
47230: LD_VAR 0 7
47234: ARRAY
47235: PPUSH
47236: CALL_OW 310
47240: IFFALSE 47308
// begin z := IsInUnit ( group [ i ] ) ;
47242: LD_ADDR_VAR 0 13
47246: PUSH
47247: LD_VAR 0 4
47251: PUSH
47252: LD_VAR 0 7
47256: ARRAY
47257: PPUSH
47258: CALL_OW 310
47262: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
47263: LD_VAR 0 13
47267: PUSH
47268: LD_VAR 0 32
47272: IN
47273: PUSH
47274: LD_VAR 0 13
47278: PPUSH
47279: LD_VAR 0 22
47283: PPUSH
47284: CALL_OW 308
47288: AND
47289: IFFALSE 47306
// ComExitVehicle ( group [ i ] ) ;
47291: LD_VAR 0 4
47295: PUSH
47296: LD_VAR 0 7
47300: ARRAY
47301: PPUSH
47302: CALL_OW 121
// end else
47306: GO 47485
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
47308: LD_ADDR_VAR 0 13
47312: PUSH
47313: LD_VAR 0 4
47317: PPUSH
47318: LD_INT 95
47320: PUSH
47321: LD_VAR 0 22
47325: PUSH
47326: EMPTY
47327: LIST
47328: LIST
47329: PUSH
47330: LD_INT 58
47332: PUSH
47333: EMPTY
47334: LIST
47335: PUSH
47336: EMPTY
47337: LIST
47338: LIST
47339: PPUSH
47340: CALL_OW 72
47344: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
47345: LD_VAR 0 4
47349: PUSH
47350: LD_VAR 0 7
47354: ARRAY
47355: PPUSH
47356: CALL_OW 314
47360: NOT
47361: IFFALSE 47483
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
47363: LD_ADDR_VAR 0 10
47367: PUSH
47368: LD_VAR 0 13
47372: PPUSH
47373: LD_VAR 0 4
47377: PUSH
47378: LD_VAR 0 7
47382: ARRAY
47383: PPUSH
47384: CALL_OW 74
47388: ST_TO_ADDR
// if not x then
47389: LD_VAR 0 10
47393: NOT
47394: IFFALSE 47398
// continue ;
47396: GO 46830
// if GetLives ( x ) < 1000 then
47398: LD_VAR 0 10
47402: PPUSH
47403: CALL_OW 256
47407: PUSH
47408: LD_INT 1000
47410: LESS
47411: IFFALSE 47435
// ComRepairVehicle ( group [ i ] , x ) else
47413: LD_VAR 0 4
47417: PUSH
47418: LD_VAR 0 7
47422: ARRAY
47423: PPUSH
47424: LD_VAR 0 10
47428: PPUSH
47429: CALL_OW 129
47433: GO 47483
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
47435: LD_VAR 0 23
47439: PUSH
47440: LD_VAR 0 4
47444: PUSH
47445: LD_VAR 0 7
47449: ARRAY
47450: PPUSH
47451: CALL_OW 256
47455: PUSH
47456: LD_INT 1000
47458: LESS
47459: AND
47460: NOT
47461: IFFALSE 47483
// ComEnterUnit ( group [ i ] , x ) ;
47463: LD_VAR 0 4
47467: PUSH
47468: LD_VAR 0 7
47472: ARRAY
47473: PPUSH
47474: LD_VAR 0 10
47478: PPUSH
47479: CALL_OW 120
// end ; continue ;
47483: GO 46830
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
47485: LD_VAR 0 23
47489: PUSH
47490: LD_VAR 0 4
47494: PUSH
47495: LD_VAR 0 7
47499: ARRAY
47500: PPUSH
47501: CALL_OW 247
47505: PUSH
47506: LD_INT 1
47508: EQUAL
47509: AND
47510: IFFALSE 47988
// begin if group [ i ] in healers then
47512: LD_VAR 0 4
47516: PUSH
47517: LD_VAR 0 7
47521: ARRAY
47522: PUSH
47523: LD_VAR 0 31
47527: IN
47528: IFFALSE 47801
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
47530: LD_VAR 0 4
47534: PUSH
47535: LD_VAR 0 7
47539: ARRAY
47540: PPUSH
47541: LD_VAR 0 23
47545: PPUSH
47546: CALL_OW 308
47550: NOT
47551: PUSH
47552: LD_VAR 0 4
47556: PUSH
47557: LD_VAR 0 7
47561: ARRAY
47562: PPUSH
47563: CALL_OW 314
47567: NOT
47568: AND
47569: IFFALSE 47593
// ComMoveToArea ( group [ i ] , f_heal ) else
47571: LD_VAR 0 4
47575: PUSH
47576: LD_VAR 0 7
47580: ARRAY
47581: PPUSH
47582: LD_VAR 0 23
47586: PPUSH
47587: CALL_OW 113
47591: GO 47799
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
47593: LD_VAR 0 4
47597: PUSH
47598: LD_VAR 0 7
47602: ARRAY
47603: PPUSH
47604: CALL 46211 0 1
47608: PPUSH
47609: CALL_OW 256
47613: PUSH
47614: LD_INT 1000
47616: EQUAL
47617: IFFALSE 47636
// ComStop ( group [ i ] ) else
47619: LD_VAR 0 4
47623: PUSH
47624: LD_VAR 0 7
47628: ARRAY
47629: PPUSH
47630: CALL_OW 141
47634: GO 47799
// if not HasTask ( group [ i ] ) and to_heal then
47636: LD_VAR 0 4
47640: PUSH
47641: LD_VAR 0 7
47645: ARRAY
47646: PPUSH
47647: CALL_OW 314
47651: NOT
47652: PUSH
47653: LD_VAR 0 30
47657: AND
47658: IFFALSE 47799
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
47660: LD_ADDR_VAR 0 13
47664: PUSH
47665: LD_VAR 0 30
47669: PPUSH
47670: LD_INT 3
47672: PUSH
47673: LD_INT 54
47675: PUSH
47676: EMPTY
47677: LIST
47678: PUSH
47679: EMPTY
47680: LIST
47681: LIST
47682: PPUSH
47683: CALL_OW 72
47687: PPUSH
47688: LD_VAR 0 4
47692: PUSH
47693: LD_VAR 0 7
47697: ARRAY
47698: PPUSH
47699: CALL_OW 74
47703: ST_TO_ADDR
// if z then
47704: LD_VAR 0 13
47708: IFFALSE 47799
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
47710: LD_INT 91
47712: PUSH
47713: LD_VAR 0 13
47717: PUSH
47718: LD_INT 10
47720: PUSH
47721: EMPTY
47722: LIST
47723: LIST
47724: LIST
47725: PUSH
47726: LD_INT 81
47728: PUSH
47729: LD_VAR 0 13
47733: PPUSH
47734: CALL_OW 255
47738: PUSH
47739: EMPTY
47740: LIST
47741: LIST
47742: PUSH
47743: EMPTY
47744: LIST
47745: LIST
47746: PPUSH
47747: CALL_OW 69
47751: PUSH
47752: LD_INT 0
47754: EQUAL
47755: IFFALSE 47779
// ComHeal ( group [ i ] , z ) else
47757: LD_VAR 0 4
47761: PUSH
47762: LD_VAR 0 7
47766: ARRAY
47767: PPUSH
47768: LD_VAR 0 13
47772: PPUSH
47773: CALL_OW 128
47777: GO 47799
// ComMoveToArea ( group [ i ] , f_heal ) ;
47779: LD_VAR 0 4
47783: PUSH
47784: LD_VAR 0 7
47788: ARRAY
47789: PPUSH
47790: LD_VAR 0 23
47794: PPUSH
47795: CALL_OW 113
// end ; continue ;
47799: GO 46830
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
47801: LD_VAR 0 4
47805: PUSH
47806: LD_VAR 0 7
47810: ARRAY
47811: PPUSH
47812: CALL_OW 256
47816: PUSH
47817: LD_INT 700
47819: LESS
47820: PUSH
47821: LD_VAR 0 4
47825: PUSH
47826: LD_VAR 0 7
47830: ARRAY
47831: PUSH
47832: LD_VAR 0 30
47836: IN
47837: NOT
47838: AND
47839: IFFALSE 47863
// to_heal := to_heal union group [ i ] ;
47841: LD_ADDR_VAR 0 30
47845: PUSH
47846: LD_VAR 0 30
47850: PUSH
47851: LD_VAR 0 4
47855: PUSH
47856: LD_VAR 0 7
47860: ARRAY
47861: UNION
47862: ST_TO_ADDR
// if group [ i ] in to_heal then
47863: LD_VAR 0 4
47867: PUSH
47868: LD_VAR 0 7
47872: ARRAY
47873: PUSH
47874: LD_VAR 0 30
47878: IN
47879: IFFALSE 47988
// begin if GetLives ( group [ i ] ) = 1000 then
47881: LD_VAR 0 4
47885: PUSH
47886: LD_VAR 0 7
47890: ARRAY
47891: PPUSH
47892: CALL_OW 256
47896: PUSH
47897: LD_INT 1000
47899: EQUAL
47900: IFFALSE 47926
// to_heal := to_heal diff group [ i ] else
47902: LD_ADDR_VAR 0 30
47906: PUSH
47907: LD_VAR 0 30
47911: PUSH
47912: LD_VAR 0 4
47916: PUSH
47917: LD_VAR 0 7
47921: ARRAY
47922: DIFF
47923: ST_TO_ADDR
47924: GO 47988
// begin if not IsInArea ( group [ i ] , to_heal ) then
47926: LD_VAR 0 4
47930: PUSH
47931: LD_VAR 0 7
47935: ARRAY
47936: PPUSH
47937: LD_VAR 0 30
47941: PPUSH
47942: CALL_OW 308
47946: NOT
47947: IFFALSE 47971
// ComMoveToArea ( group [ i ] , f_heal ) else
47949: LD_VAR 0 4
47953: PUSH
47954: LD_VAR 0 7
47958: ARRAY
47959: PPUSH
47960: LD_VAR 0 23
47964: PPUSH
47965: CALL_OW 113
47969: GO 47986
// ComHold ( group [ i ] ) ;
47971: LD_VAR 0 4
47975: PUSH
47976: LD_VAR 0 7
47980: ARRAY
47981: PPUSH
47982: CALL_OW 140
// continue ;
47986: GO 46830
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
47988: LD_VAR 0 4
47992: PUSH
47993: LD_VAR 0 7
47997: ARRAY
47998: PPUSH
47999: LD_INT 10
48001: PPUSH
48002: CALL 44608 0 2
48006: NOT
48007: PUSH
48008: LD_VAR 0 16
48012: PUSH
48013: LD_VAR 0 7
48017: ARRAY
48018: PUSH
48019: EMPTY
48020: EQUAL
48021: NOT
48022: AND
48023: IFFALSE 48289
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
48025: LD_VAR 0 4
48029: PUSH
48030: LD_VAR 0 7
48034: ARRAY
48035: PPUSH
48036: CALL_OW 262
48040: PUSH
48041: LD_INT 1
48043: PUSH
48044: LD_INT 2
48046: PUSH
48047: EMPTY
48048: LIST
48049: LIST
48050: IN
48051: IFFALSE 48092
// if GetFuel ( group [ i ] ) < 10 then
48053: LD_VAR 0 4
48057: PUSH
48058: LD_VAR 0 7
48062: ARRAY
48063: PPUSH
48064: CALL_OW 261
48068: PUSH
48069: LD_INT 10
48071: LESS
48072: IFFALSE 48092
// SetFuel ( group [ i ] , 12 ) ;
48074: LD_VAR 0 4
48078: PUSH
48079: LD_VAR 0 7
48083: ARRAY
48084: PPUSH
48085: LD_INT 12
48087: PPUSH
48088: CALL_OW 240
// if units_path [ i ] then
48092: LD_VAR 0 16
48096: PUSH
48097: LD_VAR 0 7
48101: ARRAY
48102: IFFALSE 48287
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
48104: LD_VAR 0 4
48108: PUSH
48109: LD_VAR 0 7
48113: ARRAY
48114: PPUSH
48115: LD_VAR 0 16
48119: PUSH
48120: LD_VAR 0 7
48124: ARRAY
48125: PUSH
48126: LD_INT 1
48128: ARRAY
48129: PUSH
48130: LD_INT 1
48132: ARRAY
48133: PPUSH
48134: LD_VAR 0 16
48138: PUSH
48139: LD_VAR 0 7
48143: ARRAY
48144: PUSH
48145: LD_INT 1
48147: ARRAY
48148: PUSH
48149: LD_INT 2
48151: ARRAY
48152: PPUSH
48153: CALL_OW 297
48157: PUSH
48158: LD_INT 6
48160: GREATER
48161: IFFALSE 48236
// begin if not HasTask ( group [ i ] ) then
48163: LD_VAR 0 4
48167: PUSH
48168: LD_VAR 0 7
48172: ARRAY
48173: PPUSH
48174: CALL_OW 314
48178: NOT
48179: IFFALSE 48234
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
48181: LD_VAR 0 4
48185: PUSH
48186: LD_VAR 0 7
48190: ARRAY
48191: PPUSH
48192: LD_VAR 0 16
48196: PUSH
48197: LD_VAR 0 7
48201: ARRAY
48202: PUSH
48203: LD_INT 1
48205: ARRAY
48206: PUSH
48207: LD_INT 1
48209: ARRAY
48210: PPUSH
48211: LD_VAR 0 16
48215: PUSH
48216: LD_VAR 0 7
48220: ARRAY
48221: PUSH
48222: LD_INT 1
48224: ARRAY
48225: PUSH
48226: LD_INT 2
48228: ARRAY
48229: PPUSH
48230: CALL_OW 114
// end else
48234: GO 48287
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
48236: LD_ADDR_VAR 0 15
48240: PUSH
48241: LD_VAR 0 16
48245: PUSH
48246: LD_VAR 0 7
48250: ARRAY
48251: PPUSH
48252: LD_INT 1
48254: PPUSH
48255: CALL_OW 3
48259: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
48260: LD_ADDR_VAR 0 16
48264: PUSH
48265: LD_VAR 0 16
48269: PPUSH
48270: LD_VAR 0 7
48274: PPUSH
48275: LD_VAR 0 15
48279: PPUSH
48280: CALL_OW 1
48284: ST_TO_ADDR
// continue ;
48285: GO 46830
// end ; end ; end else
48287: GO 50925
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
48289: LD_ADDR_VAR 0 14
48293: PUSH
48294: LD_INT 81
48296: PUSH
48297: LD_VAR 0 4
48301: PUSH
48302: LD_VAR 0 7
48306: ARRAY
48307: PPUSH
48308: CALL_OW 255
48312: PUSH
48313: EMPTY
48314: LIST
48315: LIST
48316: PPUSH
48317: CALL_OW 69
48321: ST_TO_ADDR
// if not tmp then
48322: LD_VAR 0 14
48326: NOT
48327: IFFALSE 48331
// continue ;
48329: GO 46830
// if f_ignore_area then
48331: LD_VAR 0 17
48335: IFFALSE 48423
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
48337: LD_ADDR_VAR 0 15
48341: PUSH
48342: LD_VAR 0 14
48346: PPUSH
48347: LD_INT 3
48349: PUSH
48350: LD_INT 92
48352: PUSH
48353: LD_VAR 0 17
48357: PUSH
48358: LD_INT 1
48360: ARRAY
48361: PUSH
48362: LD_VAR 0 17
48366: PUSH
48367: LD_INT 2
48369: ARRAY
48370: PUSH
48371: LD_VAR 0 17
48375: PUSH
48376: LD_INT 3
48378: ARRAY
48379: PUSH
48380: EMPTY
48381: LIST
48382: LIST
48383: LIST
48384: LIST
48385: PUSH
48386: EMPTY
48387: LIST
48388: LIST
48389: PPUSH
48390: CALL_OW 72
48394: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
48395: LD_VAR 0 14
48399: PUSH
48400: LD_VAR 0 15
48404: DIFF
48405: IFFALSE 48423
// tmp := tmp diff tmp2 ;
48407: LD_ADDR_VAR 0 14
48411: PUSH
48412: LD_VAR 0 14
48416: PUSH
48417: LD_VAR 0 15
48421: DIFF
48422: ST_TO_ADDR
// end ; if not f_murder then
48423: LD_VAR 0 20
48427: NOT
48428: IFFALSE 48486
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
48430: LD_ADDR_VAR 0 15
48434: PUSH
48435: LD_VAR 0 14
48439: PPUSH
48440: LD_INT 3
48442: PUSH
48443: LD_INT 50
48445: PUSH
48446: EMPTY
48447: LIST
48448: PUSH
48449: EMPTY
48450: LIST
48451: LIST
48452: PPUSH
48453: CALL_OW 72
48457: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
48458: LD_VAR 0 14
48462: PUSH
48463: LD_VAR 0 15
48467: DIFF
48468: IFFALSE 48486
// tmp := tmp diff tmp2 ;
48470: LD_ADDR_VAR 0 14
48474: PUSH
48475: LD_VAR 0 14
48479: PUSH
48480: LD_VAR 0 15
48484: DIFF
48485: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
48486: LD_ADDR_VAR 0 14
48490: PUSH
48491: LD_VAR 0 4
48495: PUSH
48496: LD_VAR 0 7
48500: ARRAY
48501: PPUSH
48502: LD_VAR 0 14
48506: PPUSH
48507: LD_INT 1
48509: PPUSH
48510: LD_INT 1
48512: PPUSH
48513: CALL 18251 0 4
48517: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
48518: LD_VAR 0 4
48522: PUSH
48523: LD_VAR 0 7
48527: ARRAY
48528: PPUSH
48529: CALL_OW 257
48533: PUSH
48534: LD_INT 1
48536: EQUAL
48537: IFFALSE 48985
// begin if WantPlant ( group [ i ] ) then
48539: LD_VAR 0 4
48543: PUSH
48544: LD_VAR 0 7
48548: ARRAY
48549: PPUSH
48550: CALL 17752 0 1
48554: IFFALSE 48558
// continue ;
48556: GO 46830
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
48558: LD_VAR 0 18
48562: PUSH
48563: LD_VAR 0 4
48567: PUSH
48568: LD_VAR 0 7
48572: ARRAY
48573: PPUSH
48574: CALL_OW 310
48578: NOT
48579: AND
48580: PUSH
48581: LD_VAR 0 14
48585: PUSH
48586: LD_INT 1
48588: ARRAY
48589: PUSH
48590: LD_VAR 0 14
48594: PPUSH
48595: LD_INT 21
48597: PUSH
48598: LD_INT 2
48600: PUSH
48601: EMPTY
48602: LIST
48603: LIST
48604: PUSH
48605: LD_INT 58
48607: PUSH
48608: EMPTY
48609: LIST
48610: PUSH
48611: EMPTY
48612: LIST
48613: LIST
48614: PPUSH
48615: CALL_OW 72
48619: IN
48620: AND
48621: IFFALSE 48657
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
48623: LD_VAR 0 4
48627: PUSH
48628: LD_VAR 0 7
48632: ARRAY
48633: PPUSH
48634: LD_VAR 0 14
48638: PUSH
48639: LD_INT 1
48641: ARRAY
48642: PPUSH
48643: CALL_OW 120
// attacking := true ;
48647: LD_ADDR_VAR 0 29
48651: PUSH
48652: LD_INT 1
48654: ST_TO_ADDR
// continue ;
48655: GO 46830
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
48657: LD_VAR 0 26
48661: PUSH
48662: LD_VAR 0 4
48666: PUSH
48667: LD_VAR 0 7
48671: ARRAY
48672: PPUSH
48673: CALL_OW 257
48677: PUSH
48678: LD_INT 1
48680: EQUAL
48681: AND
48682: PUSH
48683: LD_VAR 0 4
48687: PUSH
48688: LD_VAR 0 7
48692: ARRAY
48693: PPUSH
48694: CALL_OW 256
48698: PUSH
48699: LD_INT 800
48701: LESS
48702: AND
48703: PUSH
48704: LD_VAR 0 4
48708: PUSH
48709: LD_VAR 0 7
48713: ARRAY
48714: PPUSH
48715: CALL_OW 318
48719: NOT
48720: AND
48721: IFFALSE 48738
// ComCrawl ( group [ i ] ) ;
48723: LD_VAR 0 4
48727: PUSH
48728: LD_VAR 0 7
48732: ARRAY
48733: PPUSH
48734: CALL_OW 137
// if f_mines then
48738: LD_VAR 0 21
48742: IFFALSE 48985
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
48744: LD_VAR 0 14
48748: PUSH
48749: LD_INT 1
48751: ARRAY
48752: PPUSH
48753: CALL_OW 247
48757: PUSH
48758: LD_INT 3
48760: EQUAL
48761: PUSH
48762: LD_VAR 0 14
48766: PUSH
48767: LD_INT 1
48769: ARRAY
48770: PUSH
48771: LD_VAR 0 27
48775: IN
48776: NOT
48777: AND
48778: IFFALSE 48985
// begin x := GetX ( tmp [ 1 ] ) ;
48780: LD_ADDR_VAR 0 10
48784: PUSH
48785: LD_VAR 0 14
48789: PUSH
48790: LD_INT 1
48792: ARRAY
48793: PPUSH
48794: CALL_OW 250
48798: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
48799: LD_ADDR_VAR 0 11
48803: PUSH
48804: LD_VAR 0 14
48808: PUSH
48809: LD_INT 1
48811: ARRAY
48812: PPUSH
48813: CALL_OW 251
48817: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
48818: LD_ADDR_VAR 0 12
48822: PUSH
48823: LD_VAR 0 4
48827: PUSH
48828: LD_VAR 0 7
48832: ARRAY
48833: PPUSH
48834: CALL 44693 0 1
48838: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
48839: LD_VAR 0 4
48843: PUSH
48844: LD_VAR 0 7
48848: ARRAY
48849: PPUSH
48850: LD_VAR 0 10
48854: PPUSH
48855: LD_VAR 0 11
48859: PPUSH
48860: LD_VAR 0 14
48864: PUSH
48865: LD_INT 1
48867: ARRAY
48868: PPUSH
48869: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
48873: LD_VAR 0 4
48877: PUSH
48878: LD_VAR 0 7
48882: ARRAY
48883: PPUSH
48884: LD_VAR 0 10
48888: PPUSH
48889: LD_VAR 0 12
48893: PPUSH
48894: LD_INT 7
48896: PPUSH
48897: CALL_OW 272
48901: PPUSH
48902: LD_VAR 0 11
48906: PPUSH
48907: LD_VAR 0 12
48911: PPUSH
48912: LD_INT 7
48914: PPUSH
48915: CALL_OW 273
48919: PPUSH
48920: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
48924: LD_VAR 0 4
48928: PUSH
48929: LD_VAR 0 7
48933: ARRAY
48934: PPUSH
48935: LD_INT 71
48937: PPUSH
48938: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
48942: LD_ADDR_VAR 0 27
48946: PUSH
48947: LD_VAR 0 27
48951: PPUSH
48952: LD_VAR 0 27
48956: PUSH
48957: LD_INT 1
48959: PLUS
48960: PPUSH
48961: LD_VAR 0 14
48965: PUSH
48966: LD_INT 1
48968: ARRAY
48969: PPUSH
48970: CALL_OW 1
48974: ST_TO_ADDR
// attacking := true ;
48975: LD_ADDR_VAR 0 29
48979: PUSH
48980: LD_INT 1
48982: ST_TO_ADDR
// continue ;
48983: GO 46830
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
48985: LD_VAR 0 4
48989: PUSH
48990: LD_VAR 0 7
48994: ARRAY
48995: PPUSH
48996: CALL_OW 257
49000: PUSH
49001: LD_INT 17
49003: EQUAL
49004: PUSH
49005: LD_VAR 0 4
49009: PUSH
49010: LD_VAR 0 7
49014: ARRAY
49015: PPUSH
49016: CALL_OW 110
49020: PUSH
49021: LD_INT 71
49023: EQUAL
49024: NOT
49025: AND
49026: IFFALSE 49172
// begin attacking := false ;
49028: LD_ADDR_VAR 0 29
49032: PUSH
49033: LD_INT 0
49035: ST_TO_ADDR
// k := 5 ;
49036: LD_ADDR_VAR 0 9
49040: PUSH
49041: LD_INT 5
49043: ST_TO_ADDR
// if tmp < k then
49044: LD_VAR 0 14
49048: PUSH
49049: LD_VAR 0 9
49053: LESS
49054: IFFALSE 49066
// k := tmp ;
49056: LD_ADDR_VAR 0 9
49060: PUSH
49061: LD_VAR 0 14
49065: ST_TO_ADDR
// for j = 1 to k do
49066: LD_ADDR_VAR 0 8
49070: PUSH
49071: DOUBLE
49072: LD_INT 1
49074: DEC
49075: ST_TO_ADDR
49076: LD_VAR 0 9
49080: PUSH
49081: FOR_TO
49082: IFFALSE 49170
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
49084: LD_VAR 0 14
49088: PUSH
49089: LD_VAR 0 8
49093: ARRAY
49094: PUSH
49095: LD_VAR 0 14
49099: PPUSH
49100: LD_INT 58
49102: PUSH
49103: EMPTY
49104: LIST
49105: PPUSH
49106: CALL_OW 72
49110: IN
49111: NOT
49112: IFFALSE 49168
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
49114: LD_VAR 0 4
49118: PUSH
49119: LD_VAR 0 7
49123: ARRAY
49124: PPUSH
49125: LD_VAR 0 14
49129: PUSH
49130: LD_VAR 0 8
49134: ARRAY
49135: PPUSH
49136: CALL_OW 115
// attacking := true ;
49140: LD_ADDR_VAR 0 29
49144: PUSH
49145: LD_INT 1
49147: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
49148: LD_VAR 0 4
49152: PUSH
49153: LD_VAR 0 7
49157: ARRAY
49158: PPUSH
49159: LD_INT 71
49161: PPUSH
49162: CALL_OW 109
// continue ;
49166: GO 49081
// end ; end ;
49168: GO 49081
49170: POP
49171: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
49172: LD_VAR 0 4
49176: PUSH
49177: LD_VAR 0 7
49181: ARRAY
49182: PPUSH
49183: CALL_OW 257
49187: PUSH
49188: LD_INT 8
49190: EQUAL
49191: PUSH
49192: LD_VAR 0 4
49196: PUSH
49197: LD_VAR 0 7
49201: ARRAY
49202: PPUSH
49203: CALL_OW 264
49207: PUSH
49208: LD_INT 28
49210: PUSH
49211: LD_INT 45
49213: PUSH
49214: LD_INT 7
49216: PUSH
49217: LD_INT 47
49219: PUSH
49220: EMPTY
49221: LIST
49222: LIST
49223: LIST
49224: LIST
49225: IN
49226: OR
49227: IFFALSE 49457
// begin attacking := false ;
49229: LD_ADDR_VAR 0 29
49233: PUSH
49234: LD_INT 0
49236: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
49237: LD_VAR 0 14
49241: PUSH
49242: LD_INT 1
49244: ARRAY
49245: PPUSH
49246: CALL_OW 266
49250: PUSH
49251: LD_INT 32
49253: PUSH
49254: LD_INT 31
49256: PUSH
49257: LD_INT 33
49259: PUSH
49260: LD_INT 4
49262: PUSH
49263: LD_INT 5
49265: PUSH
49266: EMPTY
49267: LIST
49268: LIST
49269: LIST
49270: LIST
49271: LIST
49272: IN
49273: IFFALSE 49457
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
49275: LD_ADDR_VAR 0 9
49279: PUSH
49280: LD_VAR 0 14
49284: PUSH
49285: LD_INT 1
49287: ARRAY
49288: PPUSH
49289: CALL_OW 266
49293: PPUSH
49294: LD_VAR 0 14
49298: PUSH
49299: LD_INT 1
49301: ARRAY
49302: PPUSH
49303: CALL_OW 250
49307: PPUSH
49308: LD_VAR 0 14
49312: PUSH
49313: LD_INT 1
49315: ARRAY
49316: PPUSH
49317: CALL_OW 251
49321: PPUSH
49322: LD_VAR 0 14
49326: PUSH
49327: LD_INT 1
49329: ARRAY
49330: PPUSH
49331: CALL_OW 254
49335: PPUSH
49336: LD_VAR 0 14
49340: PUSH
49341: LD_INT 1
49343: ARRAY
49344: PPUSH
49345: CALL_OW 248
49349: PPUSH
49350: LD_INT 0
49352: PPUSH
49353: CALL 26063 0 6
49357: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
49358: LD_ADDR_VAR 0 8
49362: PUSH
49363: LD_VAR 0 4
49367: PUSH
49368: LD_VAR 0 7
49372: ARRAY
49373: PPUSH
49374: LD_VAR 0 9
49378: PPUSH
49379: CALL 44756 0 2
49383: ST_TO_ADDR
// if j then
49384: LD_VAR 0 8
49388: IFFALSE 49457
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
49390: LD_VAR 0 8
49394: PUSH
49395: LD_INT 1
49397: ARRAY
49398: PPUSH
49399: LD_VAR 0 8
49403: PUSH
49404: LD_INT 2
49406: ARRAY
49407: PPUSH
49408: CALL_OW 488
49412: IFFALSE 49457
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
49414: LD_VAR 0 4
49418: PUSH
49419: LD_VAR 0 7
49423: ARRAY
49424: PPUSH
49425: LD_VAR 0 8
49429: PUSH
49430: LD_INT 1
49432: ARRAY
49433: PPUSH
49434: LD_VAR 0 8
49438: PUSH
49439: LD_INT 2
49441: ARRAY
49442: PPUSH
49443: CALL_OW 116
// attacking := true ;
49447: LD_ADDR_VAR 0 29
49451: PUSH
49452: LD_INT 1
49454: ST_TO_ADDR
// continue ;
49455: GO 46830
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
49457: LD_VAR 0 4
49461: PUSH
49462: LD_VAR 0 7
49466: ARRAY
49467: PPUSH
49468: CALL_OW 265
49472: PUSH
49473: LD_INT 11
49475: EQUAL
49476: IFFALSE 49754
// begin k := 10 ;
49478: LD_ADDR_VAR 0 9
49482: PUSH
49483: LD_INT 10
49485: ST_TO_ADDR
// x := 0 ;
49486: LD_ADDR_VAR 0 10
49490: PUSH
49491: LD_INT 0
49493: ST_TO_ADDR
// if tmp < k then
49494: LD_VAR 0 14
49498: PUSH
49499: LD_VAR 0 9
49503: LESS
49504: IFFALSE 49516
// k := tmp ;
49506: LD_ADDR_VAR 0 9
49510: PUSH
49511: LD_VAR 0 14
49515: ST_TO_ADDR
// for j = k downto 1 do
49516: LD_ADDR_VAR 0 8
49520: PUSH
49521: DOUBLE
49522: LD_VAR 0 9
49526: INC
49527: ST_TO_ADDR
49528: LD_INT 1
49530: PUSH
49531: FOR_DOWNTO
49532: IFFALSE 49607
// begin if GetType ( tmp [ j ] ) = unit_human then
49534: LD_VAR 0 14
49538: PUSH
49539: LD_VAR 0 8
49543: ARRAY
49544: PPUSH
49545: CALL_OW 247
49549: PUSH
49550: LD_INT 1
49552: EQUAL
49553: IFFALSE 49605
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
49555: LD_VAR 0 4
49559: PUSH
49560: LD_VAR 0 7
49564: ARRAY
49565: PPUSH
49566: LD_VAR 0 14
49570: PUSH
49571: LD_VAR 0 8
49575: ARRAY
49576: PPUSH
49577: CALL 45027 0 2
// x := tmp [ j ] ;
49581: LD_ADDR_VAR 0 10
49585: PUSH
49586: LD_VAR 0 14
49590: PUSH
49591: LD_VAR 0 8
49595: ARRAY
49596: ST_TO_ADDR
// attacking := true ;
49597: LD_ADDR_VAR 0 29
49601: PUSH
49602: LD_INT 1
49604: ST_TO_ADDR
// end ; end ;
49605: GO 49531
49607: POP
49608: POP
// if not x then
49609: LD_VAR 0 10
49613: NOT
49614: IFFALSE 49754
// begin attacking := true ;
49616: LD_ADDR_VAR 0 29
49620: PUSH
49621: LD_INT 1
49623: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
49624: LD_VAR 0 4
49628: PUSH
49629: LD_VAR 0 7
49633: ARRAY
49634: PPUSH
49635: CALL_OW 250
49639: PPUSH
49640: LD_VAR 0 4
49644: PUSH
49645: LD_VAR 0 7
49649: ARRAY
49650: PPUSH
49651: CALL_OW 251
49655: PPUSH
49656: CALL_OW 546
49660: PUSH
49661: LD_INT 2
49663: ARRAY
49664: PUSH
49665: LD_VAR 0 14
49669: PUSH
49670: LD_INT 1
49672: ARRAY
49673: PPUSH
49674: CALL_OW 250
49678: PPUSH
49679: LD_VAR 0 14
49683: PUSH
49684: LD_INT 1
49686: ARRAY
49687: PPUSH
49688: CALL_OW 251
49692: PPUSH
49693: CALL_OW 546
49697: PUSH
49698: LD_INT 2
49700: ARRAY
49701: EQUAL
49702: IFFALSE 49730
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
49704: LD_VAR 0 4
49708: PUSH
49709: LD_VAR 0 7
49713: ARRAY
49714: PPUSH
49715: LD_VAR 0 14
49719: PUSH
49720: LD_INT 1
49722: ARRAY
49723: PPUSH
49724: CALL 45027 0 2
49728: GO 49754
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
49730: LD_VAR 0 4
49734: PUSH
49735: LD_VAR 0 7
49739: ARRAY
49740: PPUSH
49741: LD_VAR 0 14
49745: PUSH
49746: LD_INT 1
49748: ARRAY
49749: PPUSH
49750: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
49754: LD_VAR 0 4
49758: PUSH
49759: LD_VAR 0 7
49763: ARRAY
49764: PPUSH
49765: CALL_OW 264
49769: PUSH
49770: LD_INT 29
49772: EQUAL
49773: IFFALSE 50139
// begin if WantsToAttack ( group [ i ] ) in bombed then
49775: LD_VAR 0 4
49779: PUSH
49780: LD_VAR 0 7
49784: ARRAY
49785: PPUSH
49786: CALL_OW 319
49790: PUSH
49791: LD_VAR 0 28
49795: IN
49796: IFFALSE 49800
// continue ;
49798: GO 46830
// k := 8 ;
49800: LD_ADDR_VAR 0 9
49804: PUSH
49805: LD_INT 8
49807: ST_TO_ADDR
// x := 0 ;
49808: LD_ADDR_VAR 0 10
49812: PUSH
49813: LD_INT 0
49815: ST_TO_ADDR
// if tmp < k then
49816: LD_VAR 0 14
49820: PUSH
49821: LD_VAR 0 9
49825: LESS
49826: IFFALSE 49838
// k := tmp ;
49828: LD_ADDR_VAR 0 9
49832: PUSH
49833: LD_VAR 0 14
49837: ST_TO_ADDR
// for j = 1 to k do
49838: LD_ADDR_VAR 0 8
49842: PUSH
49843: DOUBLE
49844: LD_INT 1
49846: DEC
49847: ST_TO_ADDR
49848: LD_VAR 0 9
49852: PUSH
49853: FOR_TO
49854: IFFALSE 49986
// begin if GetType ( tmp [ j ] ) = unit_building then
49856: LD_VAR 0 14
49860: PUSH
49861: LD_VAR 0 8
49865: ARRAY
49866: PPUSH
49867: CALL_OW 247
49871: PUSH
49872: LD_INT 3
49874: EQUAL
49875: IFFALSE 49984
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
49877: LD_VAR 0 14
49881: PUSH
49882: LD_VAR 0 8
49886: ARRAY
49887: PUSH
49888: LD_VAR 0 28
49892: IN
49893: NOT
49894: PUSH
49895: LD_VAR 0 14
49899: PUSH
49900: LD_VAR 0 8
49904: ARRAY
49905: PPUSH
49906: CALL_OW 313
49910: AND
49911: IFFALSE 49984
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
49913: LD_VAR 0 4
49917: PUSH
49918: LD_VAR 0 7
49922: ARRAY
49923: PPUSH
49924: LD_VAR 0 14
49928: PUSH
49929: LD_VAR 0 8
49933: ARRAY
49934: PPUSH
49935: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
49939: LD_ADDR_VAR 0 28
49943: PUSH
49944: LD_VAR 0 28
49948: PPUSH
49949: LD_VAR 0 28
49953: PUSH
49954: LD_INT 1
49956: PLUS
49957: PPUSH
49958: LD_VAR 0 14
49962: PUSH
49963: LD_VAR 0 8
49967: ARRAY
49968: PPUSH
49969: CALL_OW 1
49973: ST_TO_ADDR
// attacking := true ;
49974: LD_ADDR_VAR 0 29
49978: PUSH
49979: LD_INT 1
49981: ST_TO_ADDR
// break ;
49982: GO 49986
// end ; end ;
49984: GO 49853
49986: POP
49987: POP
// if not attacking and f_attack_depot then
49988: LD_VAR 0 29
49992: NOT
49993: PUSH
49994: LD_VAR 0 25
49998: AND
49999: IFFALSE 50094
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50001: LD_ADDR_VAR 0 13
50005: PUSH
50006: LD_VAR 0 14
50010: PPUSH
50011: LD_INT 2
50013: PUSH
50014: LD_INT 30
50016: PUSH
50017: LD_INT 0
50019: PUSH
50020: EMPTY
50021: LIST
50022: LIST
50023: PUSH
50024: LD_INT 30
50026: PUSH
50027: LD_INT 1
50029: PUSH
50030: EMPTY
50031: LIST
50032: LIST
50033: PUSH
50034: EMPTY
50035: LIST
50036: LIST
50037: LIST
50038: PPUSH
50039: CALL_OW 72
50043: ST_TO_ADDR
// if z then
50044: LD_VAR 0 13
50048: IFFALSE 50094
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
50050: LD_VAR 0 4
50054: PUSH
50055: LD_VAR 0 7
50059: ARRAY
50060: PPUSH
50061: LD_VAR 0 13
50065: PPUSH
50066: LD_VAR 0 4
50070: PUSH
50071: LD_VAR 0 7
50075: ARRAY
50076: PPUSH
50077: CALL_OW 74
50081: PPUSH
50082: CALL_OW 115
// attacking := true ;
50086: LD_ADDR_VAR 0 29
50090: PUSH
50091: LD_INT 1
50093: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
50094: LD_VAR 0 4
50098: PUSH
50099: LD_VAR 0 7
50103: ARRAY
50104: PPUSH
50105: CALL_OW 256
50109: PUSH
50110: LD_INT 500
50112: LESS
50113: IFFALSE 50139
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
50115: LD_VAR 0 4
50119: PUSH
50120: LD_VAR 0 7
50124: ARRAY
50125: PPUSH
50126: LD_VAR 0 14
50130: PUSH
50131: LD_INT 1
50133: ARRAY
50134: PPUSH
50135: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
50139: LD_VAR 0 4
50143: PUSH
50144: LD_VAR 0 7
50148: ARRAY
50149: PPUSH
50150: CALL_OW 264
50154: PUSH
50155: LD_INT 49
50157: EQUAL
50158: IFFALSE 50279
// begin if not HasTask ( group [ i ] ) then
50160: LD_VAR 0 4
50164: PUSH
50165: LD_VAR 0 7
50169: ARRAY
50170: PPUSH
50171: CALL_OW 314
50175: NOT
50176: IFFALSE 50279
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
50178: LD_ADDR_VAR 0 9
50182: PUSH
50183: LD_INT 81
50185: PUSH
50186: LD_VAR 0 4
50190: PUSH
50191: LD_VAR 0 7
50195: ARRAY
50196: PPUSH
50197: CALL_OW 255
50201: PUSH
50202: EMPTY
50203: LIST
50204: LIST
50205: PPUSH
50206: CALL_OW 69
50210: PPUSH
50211: LD_VAR 0 4
50215: PUSH
50216: LD_VAR 0 7
50220: ARRAY
50221: PPUSH
50222: CALL_OW 74
50226: ST_TO_ADDR
// if k then
50227: LD_VAR 0 9
50231: IFFALSE 50279
// if GetDistUnits ( group [ i ] , k ) > 10 then
50233: LD_VAR 0 4
50237: PUSH
50238: LD_VAR 0 7
50242: ARRAY
50243: PPUSH
50244: LD_VAR 0 9
50248: PPUSH
50249: CALL_OW 296
50253: PUSH
50254: LD_INT 10
50256: GREATER
50257: IFFALSE 50279
// ComMoveUnit ( group [ i ] , k ) ;
50259: LD_VAR 0 4
50263: PUSH
50264: LD_VAR 0 7
50268: ARRAY
50269: PPUSH
50270: LD_VAR 0 9
50274: PPUSH
50275: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
50279: LD_VAR 0 4
50283: PUSH
50284: LD_VAR 0 7
50288: ARRAY
50289: PPUSH
50290: CALL_OW 256
50294: PUSH
50295: LD_INT 250
50297: LESS
50298: PUSH
50299: LD_VAR 0 4
50303: PUSH
50304: LD_VAR 0 7
50308: ARRAY
50309: PUSH
50310: LD_INT 21
50312: PUSH
50313: LD_INT 2
50315: PUSH
50316: EMPTY
50317: LIST
50318: LIST
50319: PUSH
50320: LD_INT 23
50322: PUSH
50323: LD_INT 2
50325: PUSH
50326: EMPTY
50327: LIST
50328: LIST
50329: PUSH
50330: EMPTY
50331: LIST
50332: LIST
50333: PPUSH
50334: CALL_OW 69
50338: IN
50339: AND
50340: IFFALSE 50465
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
50342: LD_ADDR_VAR 0 9
50346: PUSH
50347: LD_OWVAR 3
50351: PUSH
50352: LD_VAR 0 4
50356: PUSH
50357: LD_VAR 0 7
50361: ARRAY
50362: DIFF
50363: PPUSH
50364: LD_VAR 0 4
50368: PUSH
50369: LD_VAR 0 7
50373: ARRAY
50374: PPUSH
50375: CALL_OW 74
50379: ST_TO_ADDR
// if not k then
50380: LD_VAR 0 9
50384: NOT
50385: IFFALSE 50389
// continue ;
50387: GO 46830
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
50389: LD_VAR 0 9
50393: PUSH
50394: LD_INT 81
50396: PUSH
50397: LD_VAR 0 4
50401: PUSH
50402: LD_VAR 0 7
50406: ARRAY
50407: PPUSH
50408: CALL_OW 255
50412: PUSH
50413: EMPTY
50414: LIST
50415: LIST
50416: PPUSH
50417: CALL_OW 69
50421: IN
50422: PUSH
50423: LD_VAR 0 9
50427: PPUSH
50428: LD_VAR 0 4
50432: PUSH
50433: LD_VAR 0 7
50437: ARRAY
50438: PPUSH
50439: CALL_OW 296
50443: PUSH
50444: LD_INT 5
50446: LESS
50447: AND
50448: IFFALSE 50465
// ComAutodestruct ( group [ i ] ) ;
50450: LD_VAR 0 4
50454: PUSH
50455: LD_VAR 0 7
50459: ARRAY
50460: PPUSH
50461: CALL 44925 0 1
// end ; if f_attack_depot then
50465: LD_VAR 0 25
50469: IFFALSE 50581
// begin k := 6 ;
50471: LD_ADDR_VAR 0 9
50475: PUSH
50476: LD_INT 6
50478: ST_TO_ADDR
// if tmp < k then
50479: LD_VAR 0 14
50483: PUSH
50484: LD_VAR 0 9
50488: LESS
50489: IFFALSE 50501
// k := tmp ;
50491: LD_ADDR_VAR 0 9
50495: PUSH
50496: LD_VAR 0 14
50500: ST_TO_ADDR
// for j = 1 to k do
50501: LD_ADDR_VAR 0 8
50505: PUSH
50506: DOUBLE
50507: LD_INT 1
50509: DEC
50510: ST_TO_ADDR
50511: LD_VAR 0 9
50515: PUSH
50516: FOR_TO
50517: IFFALSE 50579
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
50519: LD_VAR 0 8
50523: PPUSH
50524: CALL_OW 266
50528: PUSH
50529: LD_INT 0
50531: PUSH
50532: LD_INT 1
50534: PUSH
50535: EMPTY
50536: LIST
50537: LIST
50538: IN
50539: IFFALSE 50577
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
50541: LD_VAR 0 4
50545: PUSH
50546: LD_VAR 0 7
50550: ARRAY
50551: PPUSH
50552: LD_VAR 0 14
50556: PUSH
50557: LD_VAR 0 8
50561: ARRAY
50562: PPUSH
50563: CALL_OW 115
// attacking := true ;
50567: LD_ADDR_VAR 0 29
50571: PUSH
50572: LD_INT 1
50574: ST_TO_ADDR
// break ;
50575: GO 50579
// end ;
50577: GO 50516
50579: POP
50580: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
50581: LD_VAR 0 4
50585: PUSH
50586: LD_VAR 0 7
50590: ARRAY
50591: PPUSH
50592: CALL_OW 302
50596: PUSH
50597: LD_VAR 0 29
50601: NOT
50602: AND
50603: IFFALSE 50925
// begin if GetTag ( group [ i ] ) = 71 then
50605: LD_VAR 0 4
50609: PUSH
50610: LD_VAR 0 7
50614: ARRAY
50615: PPUSH
50616: CALL_OW 110
50620: PUSH
50621: LD_INT 71
50623: EQUAL
50624: IFFALSE 50665
// begin if HasTask ( group [ i ] ) then
50626: LD_VAR 0 4
50630: PUSH
50631: LD_VAR 0 7
50635: ARRAY
50636: PPUSH
50637: CALL_OW 314
50641: IFFALSE 50647
// continue else
50643: GO 46830
50645: GO 50665
// SetTag ( group [ i ] , 0 ) ;
50647: LD_VAR 0 4
50651: PUSH
50652: LD_VAR 0 7
50656: ARRAY
50657: PPUSH
50658: LD_INT 0
50660: PPUSH
50661: CALL_OW 109
// end ; k := 8 ;
50665: LD_ADDR_VAR 0 9
50669: PUSH
50670: LD_INT 8
50672: ST_TO_ADDR
// x := 0 ;
50673: LD_ADDR_VAR 0 10
50677: PUSH
50678: LD_INT 0
50680: ST_TO_ADDR
// if tmp < k then
50681: LD_VAR 0 14
50685: PUSH
50686: LD_VAR 0 9
50690: LESS
50691: IFFALSE 50703
// k := tmp ;
50693: LD_ADDR_VAR 0 9
50697: PUSH
50698: LD_VAR 0 14
50702: ST_TO_ADDR
// for j = 1 to k do
50703: LD_ADDR_VAR 0 8
50707: PUSH
50708: DOUBLE
50709: LD_INT 1
50711: DEC
50712: ST_TO_ADDR
50713: LD_VAR 0 9
50717: PUSH
50718: FOR_TO
50719: IFFALSE 50817
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
50721: LD_VAR 0 14
50725: PUSH
50726: LD_VAR 0 8
50730: ARRAY
50731: PPUSH
50732: CALL_OW 247
50736: PUSH
50737: LD_INT 1
50739: EQUAL
50740: PUSH
50741: LD_VAR 0 14
50745: PUSH
50746: LD_VAR 0 8
50750: ARRAY
50751: PPUSH
50752: CALL_OW 256
50756: PUSH
50757: LD_INT 250
50759: LESS
50760: PUSH
50761: LD_VAR 0 20
50765: AND
50766: PUSH
50767: LD_VAR 0 20
50771: NOT
50772: PUSH
50773: LD_VAR 0 14
50777: PUSH
50778: LD_VAR 0 8
50782: ARRAY
50783: PPUSH
50784: CALL_OW 256
50788: PUSH
50789: LD_INT 250
50791: GREATEREQUAL
50792: AND
50793: OR
50794: AND
50795: IFFALSE 50815
// begin x := tmp [ j ] ;
50797: LD_ADDR_VAR 0 10
50801: PUSH
50802: LD_VAR 0 14
50806: PUSH
50807: LD_VAR 0 8
50811: ARRAY
50812: ST_TO_ADDR
// break ;
50813: GO 50817
// end ;
50815: GO 50718
50817: POP
50818: POP
// if x then
50819: LD_VAR 0 10
50823: IFFALSE 50847
// ComAttackUnit ( group [ i ] , x ) else
50825: LD_VAR 0 4
50829: PUSH
50830: LD_VAR 0 7
50834: ARRAY
50835: PPUSH
50836: LD_VAR 0 10
50840: PPUSH
50841: CALL_OW 115
50845: GO 50871
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
50847: LD_VAR 0 4
50851: PUSH
50852: LD_VAR 0 7
50856: ARRAY
50857: PPUSH
50858: LD_VAR 0 14
50862: PUSH
50863: LD_INT 1
50865: ARRAY
50866: PPUSH
50867: CALL_OW 115
// if not HasTask ( group [ i ] ) then
50871: LD_VAR 0 4
50875: PUSH
50876: LD_VAR 0 7
50880: ARRAY
50881: PPUSH
50882: CALL_OW 314
50886: NOT
50887: IFFALSE 50925
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
50889: LD_VAR 0 4
50893: PUSH
50894: LD_VAR 0 7
50898: ARRAY
50899: PPUSH
50900: LD_VAR 0 14
50904: PPUSH
50905: LD_VAR 0 4
50909: PUSH
50910: LD_VAR 0 7
50914: ARRAY
50915: PPUSH
50916: CALL_OW 74
50920: PPUSH
50921: CALL_OW 115
// end ; end ; end ;
50925: GO 46830
50927: POP
50928: POP
// wait ( 0 0$1 ) ;
50929: LD_INT 35
50931: PPUSH
50932: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
50936: LD_VAR 0 4
50940: PUSH
50941: EMPTY
50942: EQUAL
50943: PUSH
50944: LD_INT 81
50946: PUSH
50947: LD_VAR 0 35
50951: PUSH
50952: EMPTY
50953: LIST
50954: LIST
50955: PPUSH
50956: CALL_OW 69
50960: NOT
50961: OR
50962: IFFALSE 46815
// end ;
50964: LD_VAR 0 2
50968: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
50969: LD_INT 0
50971: PPUSH
50972: PPUSH
50973: PPUSH
50974: PPUSH
// if not base_units then
50975: LD_VAR 0 1
50979: NOT
50980: IFFALSE 50984
// exit ;
50982: GO 51071
// result := false ;
50984: LD_ADDR_VAR 0 2
50988: PUSH
50989: LD_INT 0
50991: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
50992: LD_ADDR_VAR 0 5
50996: PUSH
50997: LD_VAR 0 1
51001: PPUSH
51002: LD_INT 21
51004: PUSH
51005: LD_INT 3
51007: PUSH
51008: EMPTY
51009: LIST
51010: LIST
51011: PPUSH
51012: CALL_OW 72
51016: ST_TO_ADDR
// if not tmp then
51017: LD_VAR 0 5
51021: NOT
51022: IFFALSE 51026
// exit ;
51024: GO 51071
// for i in tmp do
51026: LD_ADDR_VAR 0 3
51030: PUSH
51031: LD_VAR 0 5
51035: PUSH
51036: FOR_IN
51037: IFFALSE 51069
// begin result := EnemyInRange ( i , 22 ) ;
51039: LD_ADDR_VAR 0 2
51043: PUSH
51044: LD_VAR 0 3
51048: PPUSH
51049: LD_INT 22
51051: PPUSH
51052: CALL 44608 0 2
51056: ST_TO_ADDR
// if result then
51057: LD_VAR 0 2
51061: IFFALSE 51067
// exit ;
51063: POP
51064: POP
51065: GO 51071
// end ;
51067: GO 51036
51069: POP
51070: POP
// end ;
51071: LD_VAR 0 2
51075: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
51076: LD_INT 0
51078: PPUSH
51079: PPUSH
// if not units then
51080: LD_VAR 0 1
51084: NOT
51085: IFFALSE 51089
// exit ;
51087: GO 51159
// result := [ ] ;
51089: LD_ADDR_VAR 0 3
51093: PUSH
51094: EMPTY
51095: ST_TO_ADDR
// for i in units do
51096: LD_ADDR_VAR 0 4
51100: PUSH
51101: LD_VAR 0 1
51105: PUSH
51106: FOR_IN
51107: IFFALSE 51157
// if GetTag ( i ) = tag then
51109: LD_VAR 0 4
51113: PPUSH
51114: CALL_OW 110
51118: PUSH
51119: LD_VAR 0 2
51123: EQUAL
51124: IFFALSE 51155
// result := Insert ( result , result + 1 , i ) ;
51126: LD_ADDR_VAR 0 3
51130: PUSH
51131: LD_VAR 0 3
51135: PPUSH
51136: LD_VAR 0 3
51140: PUSH
51141: LD_INT 1
51143: PLUS
51144: PPUSH
51145: LD_VAR 0 4
51149: PPUSH
51150: CALL_OW 2
51154: ST_TO_ADDR
51155: GO 51106
51157: POP
51158: POP
// end ;
51159: LD_VAR 0 3
51163: RET
// export function IsDriver ( un ) ; begin
51164: LD_INT 0
51166: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
51167: LD_ADDR_VAR 0 2
51171: PUSH
51172: LD_VAR 0 1
51176: PUSH
51177: LD_INT 55
51179: PUSH
51180: EMPTY
51181: LIST
51182: PPUSH
51183: CALL_OW 69
51187: IN
51188: ST_TO_ADDR
// end ;
51189: LD_VAR 0 2
51193: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
51194: LD_INT 0
51196: PPUSH
51197: PPUSH
// list := [ ] ;
51198: LD_ADDR_VAR 0 5
51202: PUSH
51203: EMPTY
51204: ST_TO_ADDR
// case d of 0 :
51205: LD_VAR 0 3
51209: PUSH
51210: LD_INT 0
51212: DOUBLE
51213: EQUAL
51214: IFTRUE 51218
51216: GO 51351
51218: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
51219: LD_ADDR_VAR 0 5
51223: PUSH
51224: LD_VAR 0 1
51228: PUSH
51229: LD_INT 4
51231: MINUS
51232: PUSH
51233: LD_VAR 0 2
51237: PUSH
51238: LD_INT 4
51240: MINUS
51241: PUSH
51242: LD_INT 2
51244: PUSH
51245: EMPTY
51246: LIST
51247: LIST
51248: LIST
51249: PUSH
51250: LD_VAR 0 1
51254: PUSH
51255: LD_INT 3
51257: MINUS
51258: PUSH
51259: LD_VAR 0 2
51263: PUSH
51264: LD_INT 1
51266: PUSH
51267: EMPTY
51268: LIST
51269: LIST
51270: LIST
51271: PUSH
51272: LD_VAR 0 1
51276: PUSH
51277: LD_INT 4
51279: PLUS
51280: PUSH
51281: LD_VAR 0 2
51285: PUSH
51286: LD_INT 4
51288: PUSH
51289: EMPTY
51290: LIST
51291: LIST
51292: LIST
51293: PUSH
51294: LD_VAR 0 1
51298: PUSH
51299: LD_INT 3
51301: PLUS
51302: PUSH
51303: LD_VAR 0 2
51307: PUSH
51308: LD_INT 3
51310: PLUS
51311: PUSH
51312: LD_INT 5
51314: PUSH
51315: EMPTY
51316: LIST
51317: LIST
51318: LIST
51319: PUSH
51320: LD_VAR 0 1
51324: PUSH
51325: LD_VAR 0 2
51329: PUSH
51330: LD_INT 4
51332: PLUS
51333: PUSH
51334: LD_INT 0
51336: PUSH
51337: EMPTY
51338: LIST
51339: LIST
51340: LIST
51341: PUSH
51342: EMPTY
51343: LIST
51344: LIST
51345: LIST
51346: LIST
51347: LIST
51348: ST_TO_ADDR
// end ; 1 :
51349: GO 52049
51351: LD_INT 1
51353: DOUBLE
51354: EQUAL
51355: IFTRUE 51359
51357: GO 51492
51359: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
51360: LD_ADDR_VAR 0 5
51364: PUSH
51365: LD_VAR 0 1
51369: PUSH
51370: LD_VAR 0 2
51374: PUSH
51375: LD_INT 4
51377: MINUS
51378: PUSH
51379: LD_INT 3
51381: PUSH
51382: EMPTY
51383: LIST
51384: LIST
51385: LIST
51386: PUSH
51387: LD_VAR 0 1
51391: PUSH
51392: LD_INT 3
51394: MINUS
51395: PUSH
51396: LD_VAR 0 2
51400: PUSH
51401: LD_INT 3
51403: MINUS
51404: PUSH
51405: LD_INT 2
51407: PUSH
51408: EMPTY
51409: LIST
51410: LIST
51411: LIST
51412: PUSH
51413: LD_VAR 0 1
51417: PUSH
51418: LD_INT 4
51420: MINUS
51421: PUSH
51422: LD_VAR 0 2
51426: PUSH
51427: LD_INT 1
51429: PUSH
51430: EMPTY
51431: LIST
51432: LIST
51433: LIST
51434: PUSH
51435: LD_VAR 0 1
51439: PUSH
51440: LD_VAR 0 2
51444: PUSH
51445: LD_INT 3
51447: PLUS
51448: PUSH
51449: LD_INT 0
51451: PUSH
51452: EMPTY
51453: LIST
51454: LIST
51455: LIST
51456: PUSH
51457: LD_VAR 0 1
51461: PUSH
51462: LD_INT 4
51464: PLUS
51465: PUSH
51466: LD_VAR 0 2
51470: PUSH
51471: LD_INT 4
51473: PLUS
51474: PUSH
51475: LD_INT 5
51477: PUSH
51478: EMPTY
51479: LIST
51480: LIST
51481: LIST
51482: PUSH
51483: EMPTY
51484: LIST
51485: LIST
51486: LIST
51487: LIST
51488: LIST
51489: ST_TO_ADDR
// end ; 2 :
51490: GO 52049
51492: LD_INT 2
51494: DOUBLE
51495: EQUAL
51496: IFTRUE 51500
51498: GO 51629
51500: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
51501: LD_ADDR_VAR 0 5
51505: PUSH
51506: LD_VAR 0 1
51510: PUSH
51511: LD_VAR 0 2
51515: PUSH
51516: LD_INT 3
51518: MINUS
51519: PUSH
51520: LD_INT 3
51522: PUSH
51523: EMPTY
51524: LIST
51525: LIST
51526: LIST
51527: PUSH
51528: LD_VAR 0 1
51532: PUSH
51533: LD_INT 4
51535: PLUS
51536: PUSH
51537: LD_VAR 0 2
51541: PUSH
51542: LD_INT 4
51544: PUSH
51545: EMPTY
51546: LIST
51547: LIST
51548: LIST
51549: PUSH
51550: LD_VAR 0 1
51554: PUSH
51555: LD_VAR 0 2
51559: PUSH
51560: LD_INT 4
51562: PLUS
51563: PUSH
51564: LD_INT 0
51566: PUSH
51567: EMPTY
51568: LIST
51569: LIST
51570: LIST
51571: PUSH
51572: LD_VAR 0 1
51576: PUSH
51577: LD_INT 3
51579: MINUS
51580: PUSH
51581: LD_VAR 0 2
51585: PUSH
51586: LD_INT 1
51588: PUSH
51589: EMPTY
51590: LIST
51591: LIST
51592: LIST
51593: PUSH
51594: LD_VAR 0 1
51598: PUSH
51599: LD_INT 4
51601: MINUS
51602: PUSH
51603: LD_VAR 0 2
51607: PUSH
51608: LD_INT 4
51610: MINUS
51611: PUSH
51612: LD_INT 2
51614: PUSH
51615: EMPTY
51616: LIST
51617: LIST
51618: LIST
51619: PUSH
51620: EMPTY
51621: LIST
51622: LIST
51623: LIST
51624: LIST
51625: LIST
51626: ST_TO_ADDR
// end ; 3 :
51627: GO 52049
51629: LD_INT 3
51631: DOUBLE
51632: EQUAL
51633: IFTRUE 51637
51635: GO 51770
51637: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
51638: LD_ADDR_VAR 0 5
51642: PUSH
51643: LD_VAR 0 1
51647: PUSH
51648: LD_INT 3
51650: PLUS
51651: PUSH
51652: LD_VAR 0 2
51656: PUSH
51657: LD_INT 4
51659: PUSH
51660: EMPTY
51661: LIST
51662: LIST
51663: LIST
51664: PUSH
51665: LD_VAR 0 1
51669: PUSH
51670: LD_INT 4
51672: PLUS
51673: PUSH
51674: LD_VAR 0 2
51678: PUSH
51679: LD_INT 4
51681: PLUS
51682: PUSH
51683: LD_INT 5
51685: PUSH
51686: EMPTY
51687: LIST
51688: LIST
51689: LIST
51690: PUSH
51691: LD_VAR 0 1
51695: PUSH
51696: LD_INT 4
51698: MINUS
51699: PUSH
51700: LD_VAR 0 2
51704: PUSH
51705: LD_INT 1
51707: PUSH
51708: EMPTY
51709: LIST
51710: LIST
51711: LIST
51712: PUSH
51713: LD_VAR 0 1
51717: PUSH
51718: LD_VAR 0 2
51722: PUSH
51723: LD_INT 4
51725: MINUS
51726: PUSH
51727: LD_INT 3
51729: PUSH
51730: EMPTY
51731: LIST
51732: LIST
51733: LIST
51734: PUSH
51735: LD_VAR 0 1
51739: PUSH
51740: LD_INT 3
51742: MINUS
51743: PUSH
51744: LD_VAR 0 2
51748: PUSH
51749: LD_INT 3
51751: MINUS
51752: PUSH
51753: LD_INT 2
51755: PUSH
51756: EMPTY
51757: LIST
51758: LIST
51759: LIST
51760: PUSH
51761: EMPTY
51762: LIST
51763: LIST
51764: LIST
51765: LIST
51766: LIST
51767: ST_TO_ADDR
// end ; 4 :
51768: GO 52049
51770: LD_INT 4
51772: DOUBLE
51773: EQUAL
51774: IFTRUE 51778
51776: GO 51911
51778: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
51779: LD_ADDR_VAR 0 5
51783: PUSH
51784: LD_VAR 0 1
51788: PUSH
51789: LD_VAR 0 2
51793: PUSH
51794: LD_INT 4
51796: PLUS
51797: PUSH
51798: LD_INT 0
51800: PUSH
51801: EMPTY
51802: LIST
51803: LIST
51804: LIST
51805: PUSH
51806: LD_VAR 0 1
51810: PUSH
51811: LD_INT 3
51813: PLUS
51814: PUSH
51815: LD_VAR 0 2
51819: PUSH
51820: LD_INT 3
51822: PLUS
51823: PUSH
51824: LD_INT 5
51826: PUSH
51827: EMPTY
51828: LIST
51829: LIST
51830: LIST
51831: PUSH
51832: LD_VAR 0 1
51836: PUSH
51837: LD_INT 4
51839: PLUS
51840: PUSH
51841: LD_VAR 0 2
51845: PUSH
51846: LD_INT 4
51848: PUSH
51849: EMPTY
51850: LIST
51851: LIST
51852: LIST
51853: PUSH
51854: LD_VAR 0 1
51858: PUSH
51859: LD_VAR 0 2
51863: PUSH
51864: LD_INT 3
51866: MINUS
51867: PUSH
51868: LD_INT 3
51870: PUSH
51871: EMPTY
51872: LIST
51873: LIST
51874: LIST
51875: PUSH
51876: LD_VAR 0 1
51880: PUSH
51881: LD_INT 4
51883: MINUS
51884: PUSH
51885: LD_VAR 0 2
51889: PUSH
51890: LD_INT 4
51892: MINUS
51893: PUSH
51894: LD_INT 2
51896: PUSH
51897: EMPTY
51898: LIST
51899: LIST
51900: LIST
51901: PUSH
51902: EMPTY
51903: LIST
51904: LIST
51905: LIST
51906: LIST
51907: LIST
51908: ST_TO_ADDR
// end ; 5 :
51909: GO 52049
51911: LD_INT 5
51913: DOUBLE
51914: EQUAL
51915: IFTRUE 51919
51917: GO 52048
51919: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
51920: LD_ADDR_VAR 0 5
51924: PUSH
51925: LD_VAR 0 1
51929: PUSH
51930: LD_INT 4
51932: MINUS
51933: PUSH
51934: LD_VAR 0 2
51938: PUSH
51939: LD_INT 1
51941: PUSH
51942: EMPTY
51943: LIST
51944: LIST
51945: LIST
51946: PUSH
51947: LD_VAR 0 1
51951: PUSH
51952: LD_VAR 0 2
51956: PUSH
51957: LD_INT 4
51959: MINUS
51960: PUSH
51961: LD_INT 3
51963: PUSH
51964: EMPTY
51965: LIST
51966: LIST
51967: LIST
51968: PUSH
51969: LD_VAR 0 1
51973: PUSH
51974: LD_INT 4
51976: PLUS
51977: PUSH
51978: LD_VAR 0 2
51982: PUSH
51983: LD_INT 4
51985: PLUS
51986: PUSH
51987: LD_INT 5
51989: PUSH
51990: EMPTY
51991: LIST
51992: LIST
51993: LIST
51994: PUSH
51995: LD_VAR 0 1
51999: PUSH
52000: LD_INT 3
52002: PLUS
52003: PUSH
52004: LD_VAR 0 2
52008: PUSH
52009: LD_INT 4
52011: PUSH
52012: EMPTY
52013: LIST
52014: LIST
52015: LIST
52016: PUSH
52017: LD_VAR 0 1
52021: PUSH
52022: LD_VAR 0 2
52026: PUSH
52027: LD_INT 3
52029: PLUS
52030: PUSH
52031: LD_INT 0
52033: PUSH
52034: EMPTY
52035: LIST
52036: LIST
52037: LIST
52038: PUSH
52039: EMPTY
52040: LIST
52041: LIST
52042: LIST
52043: LIST
52044: LIST
52045: ST_TO_ADDR
// end ; end ;
52046: GO 52049
52048: POP
// result := list ;
52049: LD_ADDR_VAR 0 4
52053: PUSH
52054: LD_VAR 0 5
52058: ST_TO_ADDR
// end ;
52059: LD_VAR 0 4
52063: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
52064: LD_INT 0
52066: PPUSH
52067: PPUSH
52068: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
52069: LD_VAR 0 1
52073: NOT
52074: PUSH
52075: LD_VAR 0 2
52079: PUSH
52080: LD_INT 1
52082: PUSH
52083: LD_INT 2
52085: PUSH
52086: LD_INT 3
52088: PUSH
52089: LD_INT 4
52091: PUSH
52092: EMPTY
52093: LIST
52094: LIST
52095: LIST
52096: LIST
52097: IN
52098: NOT
52099: OR
52100: IFFALSE 52104
// exit ;
52102: GO 52196
// tmp := [ ] ;
52104: LD_ADDR_VAR 0 5
52108: PUSH
52109: EMPTY
52110: ST_TO_ADDR
// for i in units do
52111: LD_ADDR_VAR 0 4
52115: PUSH
52116: LD_VAR 0 1
52120: PUSH
52121: FOR_IN
52122: IFFALSE 52165
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
52124: LD_ADDR_VAR 0 5
52128: PUSH
52129: LD_VAR 0 5
52133: PPUSH
52134: LD_VAR 0 5
52138: PUSH
52139: LD_INT 1
52141: PLUS
52142: PPUSH
52143: LD_VAR 0 4
52147: PPUSH
52148: LD_VAR 0 2
52152: PPUSH
52153: CALL_OW 259
52157: PPUSH
52158: CALL_OW 2
52162: ST_TO_ADDR
52163: GO 52121
52165: POP
52166: POP
// if not tmp then
52167: LD_VAR 0 5
52171: NOT
52172: IFFALSE 52176
// exit ;
52174: GO 52196
// result := SortListByListDesc ( units , tmp ) ;
52176: LD_ADDR_VAR 0 3
52180: PUSH
52181: LD_VAR 0 1
52185: PPUSH
52186: LD_VAR 0 5
52190: PPUSH
52191: CALL_OW 77
52195: ST_TO_ADDR
// end ;
52196: LD_VAR 0 3
52200: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
52201: LD_INT 0
52203: PPUSH
52204: PPUSH
52205: PPUSH
// x := GetX ( building ) ;
52206: LD_ADDR_VAR 0 4
52210: PUSH
52211: LD_VAR 0 2
52215: PPUSH
52216: CALL_OW 250
52220: ST_TO_ADDR
// y := GetY ( building ) ;
52221: LD_ADDR_VAR 0 5
52225: PUSH
52226: LD_VAR 0 2
52230: PPUSH
52231: CALL_OW 251
52235: ST_TO_ADDR
// if GetTaskList ( unit ) then
52236: LD_VAR 0 1
52240: PPUSH
52241: CALL_OW 437
52245: IFFALSE 52340
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52247: LD_STRING e
52249: PUSH
52250: LD_VAR 0 1
52254: PPUSH
52255: CALL_OW 437
52259: PUSH
52260: LD_INT 1
52262: ARRAY
52263: PUSH
52264: LD_INT 1
52266: ARRAY
52267: EQUAL
52268: PUSH
52269: LD_VAR 0 4
52273: PUSH
52274: LD_VAR 0 1
52278: PPUSH
52279: CALL_OW 437
52283: PUSH
52284: LD_INT 1
52286: ARRAY
52287: PUSH
52288: LD_INT 2
52290: ARRAY
52291: EQUAL
52292: AND
52293: PUSH
52294: LD_VAR 0 5
52298: PUSH
52299: LD_VAR 0 1
52303: PPUSH
52304: CALL_OW 437
52308: PUSH
52309: LD_INT 1
52311: ARRAY
52312: PUSH
52313: LD_INT 3
52315: ARRAY
52316: EQUAL
52317: AND
52318: IFFALSE 52330
// result := true else
52320: LD_ADDR_VAR 0 3
52324: PUSH
52325: LD_INT 1
52327: ST_TO_ADDR
52328: GO 52338
// result := false ;
52330: LD_ADDR_VAR 0 3
52334: PUSH
52335: LD_INT 0
52337: ST_TO_ADDR
// end else
52338: GO 52348
// result := false ;
52340: LD_ADDR_VAR 0 3
52344: PUSH
52345: LD_INT 0
52347: ST_TO_ADDR
// end ;
52348: LD_VAR 0 3
52352: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
52353: LD_INT 0
52355: PPUSH
52356: PPUSH
52357: PPUSH
52358: PPUSH
// if not unit or not area then
52359: LD_VAR 0 1
52363: NOT
52364: PUSH
52365: LD_VAR 0 2
52369: NOT
52370: OR
52371: IFFALSE 52375
// exit ;
52373: GO 52539
// tmp := AreaToList ( area , i ) ;
52375: LD_ADDR_VAR 0 6
52379: PUSH
52380: LD_VAR 0 2
52384: PPUSH
52385: LD_VAR 0 5
52389: PPUSH
52390: CALL_OW 517
52394: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
52395: LD_ADDR_VAR 0 5
52399: PUSH
52400: DOUBLE
52401: LD_INT 1
52403: DEC
52404: ST_TO_ADDR
52405: LD_VAR 0 6
52409: PUSH
52410: LD_INT 1
52412: ARRAY
52413: PUSH
52414: FOR_TO
52415: IFFALSE 52537
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
52417: LD_ADDR_VAR 0 7
52421: PUSH
52422: LD_VAR 0 6
52426: PUSH
52427: LD_INT 1
52429: ARRAY
52430: PUSH
52431: LD_VAR 0 5
52435: ARRAY
52436: PUSH
52437: LD_VAR 0 6
52441: PUSH
52442: LD_INT 2
52444: ARRAY
52445: PUSH
52446: LD_VAR 0 5
52450: ARRAY
52451: PUSH
52452: EMPTY
52453: LIST
52454: LIST
52455: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
52456: LD_VAR 0 7
52460: PUSH
52461: LD_INT 1
52463: ARRAY
52464: PPUSH
52465: LD_VAR 0 7
52469: PUSH
52470: LD_INT 2
52472: ARRAY
52473: PPUSH
52474: CALL_OW 428
52478: PUSH
52479: LD_INT 0
52481: EQUAL
52482: IFFALSE 52535
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
52484: LD_VAR 0 1
52488: PPUSH
52489: LD_VAR 0 7
52493: PUSH
52494: LD_INT 1
52496: ARRAY
52497: PPUSH
52498: LD_VAR 0 7
52502: PUSH
52503: LD_INT 2
52505: ARRAY
52506: PPUSH
52507: LD_VAR 0 3
52511: PPUSH
52512: CALL_OW 48
// result := IsPlaced ( unit ) ;
52516: LD_ADDR_VAR 0 4
52520: PUSH
52521: LD_VAR 0 1
52525: PPUSH
52526: CALL_OW 305
52530: ST_TO_ADDR
// exit ;
52531: POP
52532: POP
52533: GO 52539
// end ; end ;
52535: GO 52414
52537: POP
52538: POP
// end ;
52539: LD_VAR 0 4
52543: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
52544: LD_INT 0
52546: PPUSH
52547: PPUSH
52548: PPUSH
// if not side or side > 8 then
52549: LD_VAR 0 1
52553: NOT
52554: PUSH
52555: LD_VAR 0 1
52559: PUSH
52560: LD_INT 8
52562: GREATER
52563: OR
52564: IFFALSE 52568
// exit ;
52566: GO 52755
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
52568: LD_ADDR_VAR 0 4
52572: PUSH
52573: LD_INT 22
52575: PUSH
52576: LD_VAR 0 1
52580: PUSH
52581: EMPTY
52582: LIST
52583: LIST
52584: PUSH
52585: LD_INT 21
52587: PUSH
52588: LD_INT 3
52590: PUSH
52591: EMPTY
52592: LIST
52593: LIST
52594: PUSH
52595: EMPTY
52596: LIST
52597: LIST
52598: PPUSH
52599: CALL_OW 69
52603: ST_TO_ADDR
// if not tmp then
52604: LD_VAR 0 4
52608: NOT
52609: IFFALSE 52613
// exit ;
52611: GO 52755
// enable_addtolog := true ;
52613: LD_ADDR_OWVAR 81
52617: PUSH
52618: LD_INT 1
52620: ST_TO_ADDR
// AddToLog ( [ ) ;
52621: LD_STRING [
52623: PPUSH
52624: CALL_OW 561
// for i in tmp do
52628: LD_ADDR_VAR 0 3
52632: PUSH
52633: LD_VAR 0 4
52637: PUSH
52638: FOR_IN
52639: IFFALSE 52746
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
52641: LD_STRING [
52643: PUSH
52644: LD_VAR 0 3
52648: PPUSH
52649: CALL_OW 266
52653: STR
52654: PUSH
52655: LD_STRING , 
52657: STR
52658: PUSH
52659: LD_VAR 0 3
52663: PPUSH
52664: CALL_OW 250
52668: STR
52669: PUSH
52670: LD_STRING , 
52672: STR
52673: PUSH
52674: LD_VAR 0 3
52678: PPUSH
52679: CALL_OW 251
52683: STR
52684: PUSH
52685: LD_STRING , 
52687: STR
52688: PUSH
52689: LD_VAR 0 3
52693: PPUSH
52694: CALL_OW 254
52698: STR
52699: PUSH
52700: LD_STRING , 
52702: STR
52703: PUSH
52704: LD_VAR 0 3
52708: PPUSH
52709: LD_INT 1
52711: PPUSH
52712: CALL_OW 268
52716: STR
52717: PUSH
52718: LD_STRING , 
52720: STR
52721: PUSH
52722: LD_VAR 0 3
52726: PPUSH
52727: LD_INT 2
52729: PPUSH
52730: CALL_OW 268
52734: STR
52735: PUSH
52736: LD_STRING ],
52738: STR
52739: PPUSH
52740: CALL_OW 561
// end ;
52744: GO 52638
52746: POP
52747: POP
// AddToLog ( ]; ) ;
52748: LD_STRING ];
52750: PPUSH
52751: CALL_OW 561
// end ;
52755: LD_VAR 0 2
52759: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
52760: LD_INT 0
52762: PPUSH
52763: PPUSH
52764: PPUSH
52765: PPUSH
52766: PPUSH
// if not area or not rate or not max then
52767: LD_VAR 0 1
52771: NOT
52772: PUSH
52773: LD_VAR 0 2
52777: NOT
52778: OR
52779: PUSH
52780: LD_VAR 0 4
52784: NOT
52785: OR
52786: IFFALSE 52790
// exit ;
52788: GO 52982
// while 1 do
52790: LD_INT 1
52792: IFFALSE 52982
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
52794: LD_ADDR_VAR 0 9
52798: PUSH
52799: LD_VAR 0 1
52803: PPUSH
52804: LD_INT 1
52806: PPUSH
52807: CALL_OW 287
52811: PUSH
52812: LD_INT 10
52814: MUL
52815: ST_TO_ADDR
// r := rate / 10 ;
52816: LD_ADDR_VAR 0 7
52820: PUSH
52821: LD_VAR 0 2
52825: PUSH
52826: LD_INT 10
52828: DIVREAL
52829: ST_TO_ADDR
// time := 1 1$00 ;
52830: LD_ADDR_VAR 0 8
52834: PUSH
52835: LD_INT 2100
52837: ST_TO_ADDR
// if amount < min then
52838: LD_VAR 0 9
52842: PUSH
52843: LD_VAR 0 3
52847: LESS
52848: IFFALSE 52866
// r := r * 2 else
52850: LD_ADDR_VAR 0 7
52854: PUSH
52855: LD_VAR 0 7
52859: PUSH
52860: LD_INT 2
52862: MUL
52863: ST_TO_ADDR
52864: GO 52892
// if amount > max then
52866: LD_VAR 0 9
52870: PUSH
52871: LD_VAR 0 4
52875: GREATER
52876: IFFALSE 52892
// r := r / 2 ;
52878: LD_ADDR_VAR 0 7
52882: PUSH
52883: LD_VAR 0 7
52887: PUSH
52888: LD_INT 2
52890: DIVREAL
52891: ST_TO_ADDR
// time := time / r ;
52892: LD_ADDR_VAR 0 8
52896: PUSH
52897: LD_VAR 0 8
52901: PUSH
52902: LD_VAR 0 7
52906: DIVREAL
52907: ST_TO_ADDR
// if time < 0 then
52908: LD_VAR 0 8
52912: PUSH
52913: LD_INT 0
52915: LESS
52916: IFFALSE 52933
// time := time * - 1 ;
52918: LD_ADDR_VAR 0 8
52922: PUSH
52923: LD_VAR 0 8
52927: PUSH
52928: LD_INT 1
52930: NEG
52931: MUL
52932: ST_TO_ADDR
// wait ( time ) ;
52933: LD_VAR 0 8
52937: PPUSH
52938: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
52942: LD_INT 35
52944: PPUSH
52945: LD_INT 875
52947: PPUSH
52948: CALL_OW 12
52952: PPUSH
52953: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
52957: LD_INT 1
52959: PPUSH
52960: LD_INT 5
52962: PPUSH
52963: CALL_OW 12
52967: PPUSH
52968: LD_VAR 0 1
52972: PPUSH
52973: LD_INT 1
52975: PPUSH
52976: CALL_OW 55
// end ;
52980: GO 52790
// end ;
52982: LD_VAR 0 5
52986: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
52987: LD_INT 0
52989: PPUSH
52990: PPUSH
52991: PPUSH
52992: PPUSH
52993: PPUSH
52994: PPUSH
52995: PPUSH
52996: PPUSH
// if not turrets or not factories then
52997: LD_VAR 0 1
53001: NOT
53002: PUSH
53003: LD_VAR 0 2
53007: NOT
53008: OR
53009: IFFALSE 53013
// exit ;
53011: GO 53320
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
53013: LD_ADDR_VAR 0 10
53017: PUSH
53018: LD_INT 5
53020: PUSH
53021: LD_INT 6
53023: PUSH
53024: EMPTY
53025: LIST
53026: LIST
53027: PUSH
53028: LD_INT 2
53030: PUSH
53031: LD_INT 4
53033: PUSH
53034: EMPTY
53035: LIST
53036: LIST
53037: PUSH
53038: LD_INT 3
53040: PUSH
53041: LD_INT 5
53043: PUSH
53044: EMPTY
53045: LIST
53046: LIST
53047: PUSH
53048: EMPTY
53049: LIST
53050: LIST
53051: LIST
53052: PUSH
53053: LD_INT 24
53055: PUSH
53056: LD_INT 25
53058: PUSH
53059: EMPTY
53060: LIST
53061: LIST
53062: PUSH
53063: LD_INT 23
53065: PUSH
53066: LD_INT 27
53068: PUSH
53069: EMPTY
53070: LIST
53071: LIST
53072: PUSH
53073: EMPTY
53074: LIST
53075: LIST
53076: PUSH
53077: LD_INT 42
53079: PUSH
53080: LD_INT 43
53082: PUSH
53083: EMPTY
53084: LIST
53085: LIST
53086: PUSH
53087: LD_INT 44
53089: PUSH
53090: LD_INT 46
53092: PUSH
53093: EMPTY
53094: LIST
53095: LIST
53096: PUSH
53097: LD_INT 45
53099: PUSH
53100: LD_INT 47
53102: PUSH
53103: EMPTY
53104: LIST
53105: LIST
53106: PUSH
53107: EMPTY
53108: LIST
53109: LIST
53110: LIST
53111: PUSH
53112: EMPTY
53113: LIST
53114: LIST
53115: LIST
53116: ST_TO_ADDR
// result := [ ] ;
53117: LD_ADDR_VAR 0 3
53121: PUSH
53122: EMPTY
53123: ST_TO_ADDR
// for i in turrets do
53124: LD_ADDR_VAR 0 4
53128: PUSH
53129: LD_VAR 0 1
53133: PUSH
53134: FOR_IN
53135: IFFALSE 53318
// begin nat := GetNation ( i ) ;
53137: LD_ADDR_VAR 0 7
53141: PUSH
53142: LD_VAR 0 4
53146: PPUSH
53147: CALL_OW 248
53151: ST_TO_ADDR
// weapon := 0 ;
53152: LD_ADDR_VAR 0 8
53156: PUSH
53157: LD_INT 0
53159: ST_TO_ADDR
// if not nat then
53160: LD_VAR 0 7
53164: NOT
53165: IFFALSE 53169
// continue ;
53167: GO 53134
// for j in list [ nat ] do
53169: LD_ADDR_VAR 0 5
53173: PUSH
53174: LD_VAR 0 10
53178: PUSH
53179: LD_VAR 0 7
53183: ARRAY
53184: PUSH
53185: FOR_IN
53186: IFFALSE 53227
// if GetBWeapon ( i ) = j [ 1 ] then
53188: LD_VAR 0 4
53192: PPUSH
53193: CALL_OW 269
53197: PUSH
53198: LD_VAR 0 5
53202: PUSH
53203: LD_INT 1
53205: ARRAY
53206: EQUAL
53207: IFFALSE 53225
// begin weapon := j [ 2 ] ;
53209: LD_ADDR_VAR 0 8
53213: PUSH
53214: LD_VAR 0 5
53218: PUSH
53219: LD_INT 2
53221: ARRAY
53222: ST_TO_ADDR
// break ;
53223: GO 53227
// end ;
53225: GO 53185
53227: POP
53228: POP
// if not weapon then
53229: LD_VAR 0 8
53233: NOT
53234: IFFALSE 53238
// continue ;
53236: GO 53134
// for k in factories do
53238: LD_ADDR_VAR 0 6
53242: PUSH
53243: LD_VAR 0 2
53247: PUSH
53248: FOR_IN
53249: IFFALSE 53314
// begin weapons := AvailableWeaponList ( k ) ;
53251: LD_ADDR_VAR 0 9
53255: PUSH
53256: LD_VAR 0 6
53260: PPUSH
53261: CALL_OW 478
53265: ST_TO_ADDR
// if not weapons then
53266: LD_VAR 0 9
53270: NOT
53271: IFFALSE 53275
// continue ;
53273: GO 53248
// if weapon in weapons then
53275: LD_VAR 0 8
53279: PUSH
53280: LD_VAR 0 9
53284: IN
53285: IFFALSE 53312
// begin result := [ i , weapon ] ;
53287: LD_ADDR_VAR 0 3
53291: PUSH
53292: LD_VAR 0 4
53296: PUSH
53297: LD_VAR 0 8
53301: PUSH
53302: EMPTY
53303: LIST
53304: LIST
53305: ST_TO_ADDR
// exit ;
53306: POP
53307: POP
53308: POP
53309: POP
53310: GO 53320
// end ; end ;
53312: GO 53248
53314: POP
53315: POP
// end ;
53316: GO 53134
53318: POP
53319: POP
// end ;
53320: LD_VAR 0 3
53324: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
53325: LD_INT 0
53327: PPUSH
// if not side or side > 8 then
53328: LD_VAR 0 3
53332: NOT
53333: PUSH
53334: LD_VAR 0 3
53338: PUSH
53339: LD_INT 8
53341: GREATER
53342: OR
53343: IFFALSE 53347
// exit ;
53345: GO 53406
// if not range then
53347: LD_VAR 0 4
53351: NOT
53352: IFFALSE 53363
// range := - 12 ;
53354: LD_ADDR_VAR 0 4
53358: PUSH
53359: LD_INT 12
53361: NEG
53362: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
53363: LD_VAR 0 1
53367: PPUSH
53368: LD_VAR 0 2
53372: PPUSH
53373: LD_VAR 0 3
53377: PPUSH
53378: LD_VAR 0 4
53382: PPUSH
53383: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
53387: LD_VAR 0 1
53391: PPUSH
53392: LD_VAR 0 2
53396: PPUSH
53397: LD_VAR 0 3
53401: PPUSH
53402: CALL_OW 331
// end ;
53406: LD_VAR 0 5
53410: RET
// export function Video ( mode ) ; begin
53411: LD_INT 0
53413: PPUSH
// ingame_video = mode ;
53414: LD_ADDR_OWVAR 52
53418: PUSH
53419: LD_VAR 0 1
53423: ST_TO_ADDR
// interface_hidden = mode ;
53424: LD_ADDR_OWVAR 54
53428: PUSH
53429: LD_VAR 0 1
53433: ST_TO_ADDR
// end ;
53434: LD_VAR 0 2
53438: RET
// export function Join ( array , element ) ; begin
53439: LD_INT 0
53441: PPUSH
// result := array ^ element ;
53442: LD_ADDR_VAR 0 3
53446: PUSH
53447: LD_VAR 0 1
53451: PUSH
53452: LD_VAR 0 2
53456: ADD
53457: ST_TO_ADDR
// end ;
53458: LD_VAR 0 3
53462: RET
// export function JoinUnion ( array , element ) ; begin
53463: LD_INT 0
53465: PPUSH
// result := array union element ;
53466: LD_ADDR_VAR 0 3
53470: PUSH
53471: LD_VAR 0 1
53475: PUSH
53476: LD_VAR 0 2
53480: UNION
53481: ST_TO_ADDR
// end ;
53482: LD_VAR 0 3
53486: RET
// export function GetBehemoths ( side ) ; begin
53487: LD_INT 0
53489: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
53490: LD_ADDR_VAR 0 2
53494: PUSH
53495: LD_INT 22
53497: PUSH
53498: LD_VAR 0 1
53502: PUSH
53503: EMPTY
53504: LIST
53505: LIST
53506: PUSH
53507: LD_INT 31
53509: PUSH
53510: LD_INT 25
53512: PUSH
53513: EMPTY
53514: LIST
53515: LIST
53516: PUSH
53517: EMPTY
53518: LIST
53519: LIST
53520: PPUSH
53521: CALL_OW 69
53525: ST_TO_ADDR
// end ;
53526: LD_VAR 0 2
53530: RET
// export function Shuffle ( array ) ; var i , index ; begin
53531: LD_INT 0
53533: PPUSH
53534: PPUSH
53535: PPUSH
// result := [ ] ;
53536: LD_ADDR_VAR 0 2
53540: PUSH
53541: EMPTY
53542: ST_TO_ADDR
// if not array then
53543: LD_VAR 0 1
53547: NOT
53548: IFFALSE 53552
// exit ;
53550: GO 53651
// Randomize ;
53552: CALL_OW 10
// for i = array downto 1 do
53556: LD_ADDR_VAR 0 3
53560: PUSH
53561: DOUBLE
53562: LD_VAR 0 1
53566: INC
53567: ST_TO_ADDR
53568: LD_INT 1
53570: PUSH
53571: FOR_DOWNTO
53572: IFFALSE 53649
// begin index := rand ( 1 , array ) ;
53574: LD_ADDR_VAR 0 4
53578: PUSH
53579: LD_INT 1
53581: PPUSH
53582: LD_VAR 0 1
53586: PPUSH
53587: CALL_OW 12
53591: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
53592: LD_ADDR_VAR 0 2
53596: PUSH
53597: LD_VAR 0 2
53601: PPUSH
53602: LD_VAR 0 2
53606: PUSH
53607: LD_INT 1
53609: PLUS
53610: PPUSH
53611: LD_VAR 0 1
53615: PUSH
53616: LD_VAR 0 4
53620: ARRAY
53621: PPUSH
53622: CALL_OW 2
53626: ST_TO_ADDR
// array := Delete ( array , index ) ;
53627: LD_ADDR_VAR 0 1
53631: PUSH
53632: LD_VAR 0 1
53636: PPUSH
53637: LD_VAR 0 4
53641: PPUSH
53642: CALL_OW 3
53646: ST_TO_ADDR
// end ;
53647: GO 53571
53649: POP
53650: POP
// end ; end_of_file
53651: LD_VAR 0 2
53655: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
53656: GO 53658
53658: DISABLE
// begin ru_radar := 98 ;
53659: LD_ADDR_EXP 45
53663: PUSH
53664: LD_INT 98
53666: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
53667: LD_ADDR_EXP 46
53671: PUSH
53672: LD_INT 89
53674: ST_TO_ADDR
// us_hack := 99 ;
53675: LD_ADDR_EXP 47
53679: PUSH
53680: LD_INT 99
53682: ST_TO_ADDR
// us_artillery := 97 ;
53683: LD_ADDR_EXP 48
53687: PUSH
53688: LD_INT 97
53690: ST_TO_ADDR
// ar_bio_bomb := 91 ;
53691: LD_ADDR_EXP 49
53695: PUSH
53696: LD_INT 91
53698: ST_TO_ADDR
// end ; end_of_file
53699: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
53700: LD_INT 0
53702: PPUSH
53703: PPUSH
// skirmish := false ;
53704: LD_ADDR_EXP 50
53708: PUSH
53709: LD_INT 0
53711: ST_TO_ADDR
// debug_mc := false ;
53712: LD_ADDR_EXP 51
53716: PUSH
53717: LD_INT 0
53719: ST_TO_ADDR
// mc_bases := [ ] ;
53720: LD_ADDR_EXP 52
53724: PUSH
53725: EMPTY
53726: ST_TO_ADDR
// mc_sides := [ ] ;
53727: LD_ADDR_EXP 78
53731: PUSH
53732: EMPTY
53733: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
53734: LD_ADDR_EXP 53
53738: PUSH
53739: EMPTY
53740: ST_TO_ADDR
// mc_building_repairs := [ ] ;
53741: LD_ADDR_EXP 54
53745: PUSH
53746: EMPTY
53747: ST_TO_ADDR
// mc_need_heal := [ ] ;
53748: LD_ADDR_EXP 55
53752: PUSH
53753: EMPTY
53754: ST_TO_ADDR
// mc_healers := [ ] ;
53755: LD_ADDR_EXP 56
53759: PUSH
53760: EMPTY
53761: ST_TO_ADDR
// mc_build_list := [ ] ;
53762: LD_ADDR_EXP 57
53766: PUSH
53767: EMPTY
53768: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
53769: LD_ADDR_EXP 84
53773: PUSH
53774: EMPTY
53775: ST_TO_ADDR
// mc_builders := [ ] ;
53776: LD_ADDR_EXP 58
53780: PUSH
53781: EMPTY
53782: ST_TO_ADDR
// mc_construct_list := [ ] ;
53783: LD_ADDR_EXP 59
53787: PUSH
53788: EMPTY
53789: ST_TO_ADDR
// mc_turret_list := [ ] ;
53790: LD_ADDR_EXP 60
53794: PUSH
53795: EMPTY
53796: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
53797: LD_ADDR_EXP 61
53801: PUSH
53802: EMPTY
53803: ST_TO_ADDR
// mc_miners := [ ] ;
53804: LD_ADDR_EXP 66
53808: PUSH
53809: EMPTY
53810: ST_TO_ADDR
// mc_mines := [ ] ;
53811: LD_ADDR_EXP 65
53815: PUSH
53816: EMPTY
53817: ST_TO_ADDR
// mc_minefields := [ ] ;
53818: LD_ADDR_EXP 67
53822: PUSH
53823: EMPTY
53824: ST_TO_ADDR
// mc_crates := [ ] ;
53825: LD_ADDR_EXP 68
53829: PUSH
53830: EMPTY
53831: ST_TO_ADDR
// mc_crates_collector := [ ] ;
53832: LD_ADDR_EXP 69
53836: PUSH
53837: EMPTY
53838: ST_TO_ADDR
// mc_crates_area := [ ] ;
53839: LD_ADDR_EXP 70
53843: PUSH
53844: EMPTY
53845: ST_TO_ADDR
// mc_vehicles := [ ] ;
53846: LD_ADDR_EXP 71
53850: PUSH
53851: EMPTY
53852: ST_TO_ADDR
// mc_attack := [ ] ;
53853: LD_ADDR_EXP 72
53857: PUSH
53858: EMPTY
53859: ST_TO_ADDR
// mc_produce := [ ] ;
53860: LD_ADDR_EXP 73
53864: PUSH
53865: EMPTY
53866: ST_TO_ADDR
// mc_defender := [ ] ;
53867: LD_ADDR_EXP 74
53871: PUSH
53872: EMPTY
53873: ST_TO_ADDR
// mc_parking := [ ] ;
53874: LD_ADDR_EXP 76
53878: PUSH
53879: EMPTY
53880: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
53881: LD_ADDR_EXP 62
53885: PUSH
53886: EMPTY
53887: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
53888: LD_ADDR_EXP 64
53892: PUSH
53893: EMPTY
53894: ST_TO_ADDR
// mc_scan := [ ] ;
53895: LD_ADDR_EXP 75
53899: PUSH
53900: EMPTY
53901: ST_TO_ADDR
// mc_scan_area := [ ] ;
53902: LD_ADDR_EXP 77
53906: PUSH
53907: EMPTY
53908: ST_TO_ADDR
// mc_tech := [ ] ;
53909: LD_ADDR_EXP 79
53913: PUSH
53914: EMPTY
53915: ST_TO_ADDR
// mc_class := [ ] ;
53916: LD_ADDR_EXP 93
53920: PUSH
53921: EMPTY
53922: ST_TO_ADDR
// mc_class_case_use := [ ] ;
53923: LD_ADDR_EXP 94
53927: PUSH
53928: EMPTY
53929: ST_TO_ADDR
// end ;
53930: LD_VAR 0 1
53934: RET
// export function MC_Kill ( base ) ; begin
53935: LD_INT 0
53937: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
53938: LD_ADDR_EXP 52
53942: PUSH
53943: LD_EXP 52
53947: PPUSH
53948: LD_VAR 0 1
53952: PPUSH
53953: EMPTY
53954: PPUSH
53955: CALL_OW 1
53959: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53960: LD_ADDR_EXP 53
53964: PUSH
53965: LD_EXP 53
53969: PPUSH
53970: LD_VAR 0 1
53974: PPUSH
53975: EMPTY
53976: PPUSH
53977: CALL_OW 1
53981: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53982: LD_ADDR_EXP 54
53986: PUSH
53987: LD_EXP 54
53991: PPUSH
53992: LD_VAR 0 1
53996: PPUSH
53997: EMPTY
53998: PPUSH
53999: CALL_OW 1
54003: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
54004: LD_ADDR_EXP 55
54008: PUSH
54009: LD_EXP 55
54013: PPUSH
54014: LD_VAR 0 1
54018: PPUSH
54019: EMPTY
54020: PPUSH
54021: CALL_OW 1
54025: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
54026: LD_ADDR_EXP 56
54030: PUSH
54031: LD_EXP 56
54035: PPUSH
54036: LD_VAR 0 1
54040: PPUSH
54041: EMPTY
54042: PPUSH
54043: CALL_OW 1
54047: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
54048: LD_ADDR_EXP 57
54052: PUSH
54053: LD_EXP 57
54057: PPUSH
54058: LD_VAR 0 1
54062: PPUSH
54063: EMPTY
54064: PPUSH
54065: CALL_OW 1
54069: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
54070: LD_ADDR_EXP 58
54074: PUSH
54075: LD_EXP 58
54079: PPUSH
54080: LD_VAR 0 1
54084: PPUSH
54085: EMPTY
54086: PPUSH
54087: CALL_OW 1
54091: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
54092: LD_ADDR_EXP 59
54096: PUSH
54097: LD_EXP 59
54101: PPUSH
54102: LD_VAR 0 1
54106: PPUSH
54107: EMPTY
54108: PPUSH
54109: CALL_OW 1
54113: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
54114: LD_ADDR_EXP 60
54118: PUSH
54119: LD_EXP 60
54123: PPUSH
54124: LD_VAR 0 1
54128: PPUSH
54129: EMPTY
54130: PPUSH
54131: CALL_OW 1
54135: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
54136: LD_ADDR_EXP 61
54140: PUSH
54141: LD_EXP 61
54145: PPUSH
54146: LD_VAR 0 1
54150: PPUSH
54151: EMPTY
54152: PPUSH
54153: CALL_OW 1
54157: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
54158: LD_ADDR_EXP 62
54162: PUSH
54163: LD_EXP 62
54167: PPUSH
54168: LD_VAR 0 1
54172: PPUSH
54173: EMPTY
54174: PPUSH
54175: CALL_OW 1
54179: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
54180: LD_ADDR_EXP 63
54184: PUSH
54185: LD_EXP 63
54189: PPUSH
54190: LD_VAR 0 1
54194: PPUSH
54195: LD_INT 0
54197: PPUSH
54198: CALL_OW 1
54202: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
54203: LD_ADDR_EXP 64
54207: PUSH
54208: LD_EXP 64
54212: PPUSH
54213: LD_VAR 0 1
54217: PPUSH
54218: EMPTY
54219: PPUSH
54220: CALL_OW 1
54224: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
54225: LD_ADDR_EXP 65
54229: PUSH
54230: LD_EXP 65
54234: PPUSH
54235: LD_VAR 0 1
54239: PPUSH
54240: EMPTY
54241: PPUSH
54242: CALL_OW 1
54246: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
54247: LD_ADDR_EXP 66
54251: PUSH
54252: LD_EXP 66
54256: PPUSH
54257: LD_VAR 0 1
54261: PPUSH
54262: EMPTY
54263: PPUSH
54264: CALL_OW 1
54268: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
54269: LD_ADDR_EXP 67
54273: PUSH
54274: LD_EXP 67
54278: PPUSH
54279: LD_VAR 0 1
54283: PPUSH
54284: EMPTY
54285: PPUSH
54286: CALL_OW 1
54290: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
54291: LD_ADDR_EXP 68
54295: PUSH
54296: LD_EXP 68
54300: PPUSH
54301: LD_VAR 0 1
54305: PPUSH
54306: EMPTY
54307: PPUSH
54308: CALL_OW 1
54312: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
54313: LD_ADDR_EXP 69
54317: PUSH
54318: LD_EXP 69
54322: PPUSH
54323: LD_VAR 0 1
54327: PPUSH
54328: EMPTY
54329: PPUSH
54330: CALL_OW 1
54334: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
54335: LD_ADDR_EXP 70
54339: PUSH
54340: LD_EXP 70
54344: PPUSH
54345: LD_VAR 0 1
54349: PPUSH
54350: EMPTY
54351: PPUSH
54352: CALL_OW 1
54356: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54357: LD_ADDR_EXP 71
54361: PUSH
54362: LD_EXP 71
54366: PPUSH
54367: LD_VAR 0 1
54371: PPUSH
54372: EMPTY
54373: PPUSH
54374: CALL_OW 1
54378: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54379: LD_ADDR_EXP 72
54383: PUSH
54384: LD_EXP 72
54388: PPUSH
54389: LD_VAR 0 1
54393: PPUSH
54394: EMPTY
54395: PPUSH
54396: CALL_OW 1
54400: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54401: LD_ADDR_EXP 73
54405: PUSH
54406: LD_EXP 73
54410: PPUSH
54411: LD_VAR 0 1
54415: PPUSH
54416: EMPTY
54417: PPUSH
54418: CALL_OW 1
54422: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54423: LD_ADDR_EXP 74
54427: PUSH
54428: LD_EXP 74
54432: PPUSH
54433: LD_VAR 0 1
54437: PPUSH
54438: EMPTY
54439: PPUSH
54440: CALL_OW 1
54444: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54445: LD_ADDR_EXP 75
54449: PUSH
54450: LD_EXP 75
54454: PPUSH
54455: LD_VAR 0 1
54459: PPUSH
54460: EMPTY
54461: PPUSH
54462: CALL_OW 1
54466: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54467: LD_ADDR_EXP 76
54471: PUSH
54472: LD_EXP 76
54476: PPUSH
54477: LD_VAR 0 1
54481: PPUSH
54482: EMPTY
54483: PPUSH
54484: CALL_OW 1
54488: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54489: LD_ADDR_EXP 77
54493: PUSH
54494: LD_EXP 77
54498: PPUSH
54499: LD_VAR 0 1
54503: PPUSH
54504: EMPTY
54505: PPUSH
54506: CALL_OW 1
54510: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54511: LD_ADDR_EXP 79
54515: PUSH
54516: LD_EXP 79
54520: PPUSH
54521: LD_VAR 0 1
54525: PPUSH
54526: EMPTY
54527: PPUSH
54528: CALL_OW 1
54532: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54533: LD_ADDR_EXP 81
54537: PUSH
54538: LD_EXP 81
54542: PPUSH
54543: LD_VAR 0 1
54547: PPUSH
54548: EMPTY
54549: PPUSH
54550: CALL_OW 1
54554: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54555: LD_ADDR_EXP 82
54559: PUSH
54560: LD_EXP 82
54564: PPUSH
54565: LD_VAR 0 1
54569: PPUSH
54570: EMPTY
54571: PPUSH
54572: CALL_OW 1
54576: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54577: LD_ADDR_EXP 83
54581: PUSH
54582: LD_EXP 83
54586: PPUSH
54587: LD_VAR 0 1
54591: PPUSH
54592: EMPTY
54593: PPUSH
54594: CALL_OW 1
54598: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54599: LD_ADDR_EXP 84
54603: PUSH
54604: LD_EXP 84
54608: PPUSH
54609: LD_VAR 0 1
54613: PPUSH
54614: EMPTY
54615: PPUSH
54616: CALL_OW 1
54620: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54621: LD_ADDR_EXP 85
54625: PUSH
54626: LD_EXP 85
54630: PPUSH
54631: LD_VAR 0 1
54635: PPUSH
54636: EMPTY
54637: PPUSH
54638: CALL_OW 1
54642: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54643: LD_ADDR_EXP 86
54647: PUSH
54648: LD_EXP 86
54652: PPUSH
54653: LD_VAR 0 1
54657: PPUSH
54658: EMPTY
54659: PPUSH
54660: CALL_OW 1
54664: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54665: LD_ADDR_EXP 87
54669: PUSH
54670: LD_EXP 87
54674: PPUSH
54675: LD_VAR 0 1
54679: PPUSH
54680: EMPTY
54681: PPUSH
54682: CALL_OW 1
54686: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54687: LD_ADDR_EXP 88
54691: PUSH
54692: LD_EXP 88
54696: PPUSH
54697: LD_VAR 0 1
54701: PPUSH
54702: EMPTY
54703: PPUSH
54704: CALL_OW 1
54708: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54709: LD_ADDR_EXP 89
54713: PUSH
54714: LD_EXP 89
54718: PPUSH
54719: LD_VAR 0 1
54723: PPUSH
54724: EMPTY
54725: PPUSH
54726: CALL_OW 1
54730: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54731: LD_ADDR_EXP 90
54735: PUSH
54736: LD_EXP 90
54740: PPUSH
54741: LD_VAR 0 1
54745: PPUSH
54746: EMPTY
54747: PPUSH
54748: CALL_OW 1
54752: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54753: LD_ADDR_EXP 91
54757: PUSH
54758: LD_EXP 91
54762: PPUSH
54763: LD_VAR 0 1
54767: PPUSH
54768: EMPTY
54769: PPUSH
54770: CALL_OW 1
54774: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54775: LD_ADDR_EXP 92
54779: PUSH
54780: LD_EXP 92
54784: PPUSH
54785: LD_VAR 0 1
54789: PPUSH
54790: EMPTY
54791: PPUSH
54792: CALL_OW 1
54796: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54797: LD_ADDR_EXP 93
54801: PUSH
54802: LD_EXP 93
54806: PPUSH
54807: LD_VAR 0 1
54811: PPUSH
54812: EMPTY
54813: PPUSH
54814: CALL_OW 1
54818: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54819: LD_ADDR_EXP 94
54823: PUSH
54824: LD_EXP 94
54828: PPUSH
54829: LD_VAR 0 1
54833: PPUSH
54834: LD_INT 0
54836: PPUSH
54837: CALL_OW 1
54841: ST_TO_ADDR
// end ;
54842: LD_VAR 0 2
54846: RET
// export function MC_Add ( side , units ) ; var base ; begin
54847: LD_INT 0
54849: PPUSH
54850: PPUSH
// base := mc_bases + 1 ;
54851: LD_ADDR_VAR 0 4
54855: PUSH
54856: LD_EXP 52
54860: PUSH
54861: LD_INT 1
54863: PLUS
54864: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
54865: LD_ADDR_EXP 78
54869: PUSH
54870: LD_EXP 78
54874: PPUSH
54875: LD_VAR 0 4
54879: PPUSH
54880: LD_VAR 0 1
54884: PPUSH
54885: CALL_OW 1
54889: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
54890: LD_ADDR_EXP 52
54894: PUSH
54895: LD_EXP 52
54899: PPUSH
54900: LD_VAR 0 4
54904: PPUSH
54905: LD_VAR 0 2
54909: PPUSH
54910: CALL_OW 1
54914: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
54915: LD_ADDR_EXP 53
54919: PUSH
54920: LD_EXP 53
54924: PPUSH
54925: LD_VAR 0 4
54929: PPUSH
54930: EMPTY
54931: PPUSH
54932: CALL_OW 1
54936: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
54937: LD_ADDR_EXP 54
54941: PUSH
54942: LD_EXP 54
54946: PPUSH
54947: LD_VAR 0 4
54951: PPUSH
54952: EMPTY
54953: PPUSH
54954: CALL_OW 1
54958: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
54959: LD_ADDR_EXP 55
54963: PUSH
54964: LD_EXP 55
54968: PPUSH
54969: LD_VAR 0 4
54973: PPUSH
54974: EMPTY
54975: PPUSH
54976: CALL_OW 1
54980: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
54981: LD_ADDR_EXP 56
54985: PUSH
54986: LD_EXP 56
54990: PPUSH
54991: LD_VAR 0 4
54995: PPUSH
54996: EMPTY
54997: PPUSH
54998: CALL_OW 1
55002: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55003: LD_ADDR_EXP 57
55007: PUSH
55008: LD_EXP 57
55012: PPUSH
55013: LD_VAR 0 4
55017: PPUSH
55018: EMPTY
55019: PPUSH
55020: CALL_OW 1
55024: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55025: LD_ADDR_EXP 58
55029: PUSH
55030: LD_EXP 58
55034: PPUSH
55035: LD_VAR 0 4
55039: PPUSH
55040: EMPTY
55041: PPUSH
55042: CALL_OW 1
55046: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55047: LD_ADDR_EXP 59
55051: PUSH
55052: LD_EXP 59
55056: PPUSH
55057: LD_VAR 0 4
55061: PPUSH
55062: EMPTY
55063: PPUSH
55064: CALL_OW 1
55068: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55069: LD_ADDR_EXP 60
55073: PUSH
55074: LD_EXP 60
55078: PPUSH
55079: LD_VAR 0 4
55083: PPUSH
55084: EMPTY
55085: PPUSH
55086: CALL_OW 1
55090: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55091: LD_ADDR_EXP 61
55095: PUSH
55096: LD_EXP 61
55100: PPUSH
55101: LD_VAR 0 4
55105: PPUSH
55106: EMPTY
55107: PPUSH
55108: CALL_OW 1
55112: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55113: LD_ADDR_EXP 62
55117: PUSH
55118: LD_EXP 62
55122: PPUSH
55123: LD_VAR 0 4
55127: PPUSH
55128: EMPTY
55129: PPUSH
55130: CALL_OW 1
55134: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55135: LD_ADDR_EXP 63
55139: PUSH
55140: LD_EXP 63
55144: PPUSH
55145: LD_VAR 0 4
55149: PPUSH
55150: LD_INT 0
55152: PPUSH
55153: CALL_OW 1
55157: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55158: LD_ADDR_EXP 64
55162: PUSH
55163: LD_EXP 64
55167: PPUSH
55168: LD_VAR 0 4
55172: PPUSH
55173: EMPTY
55174: PPUSH
55175: CALL_OW 1
55179: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55180: LD_ADDR_EXP 65
55184: PUSH
55185: LD_EXP 65
55189: PPUSH
55190: LD_VAR 0 4
55194: PPUSH
55195: EMPTY
55196: PPUSH
55197: CALL_OW 1
55201: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55202: LD_ADDR_EXP 66
55206: PUSH
55207: LD_EXP 66
55211: PPUSH
55212: LD_VAR 0 4
55216: PPUSH
55217: EMPTY
55218: PPUSH
55219: CALL_OW 1
55223: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55224: LD_ADDR_EXP 67
55228: PUSH
55229: LD_EXP 67
55233: PPUSH
55234: LD_VAR 0 4
55238: PPUSH
55239: EMPTY
55240: PPUSH
55241: CALL_OW 1
55245: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55246: LD_ADDR_EXP 68
55250: PUSH
55251: LD_EXP 68
55255: PPUSH
55256: LD_VAR 0 4
55260: PPUSH
55261: EMPTY
55262: PPUSH
55263: CALL_OW 1
55267: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55268: LD_ADDR_EXP 69
55272: PUSH
55273: LD_EXP 69
55277: PPUSH
55278: LD_VAR 0 4
55282: PPUSH
55283: EMPTY
55284: PPUSH
55285: CALL_OW 1
55289: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55290: LD_ADDR_EXP 70
55294: PUSH
55295: LD_EXP 70
55299: PPUSH
55300: LD_VAR 0 4
55304: PPUSH
55305: EMPTY
55306: PPUSH
55307: CALL_OW 1
55311: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55312: LD_ADDR_EXP 71
55316: PUSH
55317: LD_EXP 71
55321: PPUSH
55322: LD_VAR 0 4
55326: PPUSH
55327: EMPTY
55328: PPUSH
55329: CALL_OW 1
55333: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55334: LD_ADDR_EXP 72
55338: PUSH
55339: LD_EXP 72
55343: PPUSH
55344: LD_VAR 0 4
55348: PPUSH
55349: EMPTY
55350: PPUSH
55351: CALL_OW 1
55355: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55356: LD_ADDR_EXP 73
55360: PUSH
55361: LD_EXP 73
55365: PPUSH
55366: LD_VAR 0 4
55370: PPUSH
55371: EMPTY
55372: PPUSH
55373: CALL_OW 1
55377: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55378: LD_ADDR_EXP 74
55382: PUSH
55383: LD_EXP 74
55387: PPUSH
55388: LD_VAR 0 4
55392: PPUSH
55393: EMPTY
55394: PPUSH
55395: CALL_OW 1
55399: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55400: LD_ADDR_EXP 75
55404: PUSH
55405: LD_EXP 75
55409: PPUSH
55410: LD_VAR 0 4
55414: PPUSH
55415: EMPTY
55416: PPUSH
55417: CALL_OW 1
55421: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55422: LD_ADDR_EXP 76
55426: PUSH
55427: LD_EXP 76
55431: PPUSH
55432: LD_VAR 0 4
55436: PPUSH
55437: EMPTY
55438: PPUSH
55439: CALL_OW 1
55443: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55444: LD_ADDR_EXP 77
55448: PUSH
55449: LD_EXP 77
55453: PPUSH
55454: LD_VAR 0 4
55458: PPUSH
55459: EMPTY
55460: PPUSH
55461: CALL_OW 1
55465: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55466: LD_ADDR_EXP 79
55470: PUSH
55471: LD_EXP 79
55475: PPUSH
55476: LD_VAR 0 4
55480: PPUSH
55481: EMPTY
55482: PPUSH
55483: CALL_OW 1
55487: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55488: LD_ADDR_EXP 81
55492: PUSH
55493: LD_EXP 81
55497: PPUSH
55498: LD_VAR 0 4
55502: PPUSH
55503: EMPTY
55504: PPUSH
55505: CALL_OW 1
55509: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55510: LD_ADDR_EXP 82
55514: PUSH
55515: LD_EXP 82
55519: PPUSH
55520: LD_VAR 0 4
55524: PPUSH
55525: EMPTY
55526: PPUSH
55527: CALL_OW 1
55531: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55532: LD_ADDR_EXP 83
55536: PUSH
55537: LD_EXP 83
55541: PPUSH
55542: LD_VAR 0 4
55546: PPUSH
55547: EMPTY
55548: PPUSH
55549: CALL_OW 1
55553: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55554: LD_ADDR_EXP 84
55558: PUSH
55559: LD_EXP 84
55563: PPUSH
55564: LD_VAR 0 4
55568: PPUSH
55569: EMPTY
55570: PPUSH
55571: CALL_OW 1
55575: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55576: LD_ADDR_EXP 85
55580: PUSH
55581: LD_EXP 85
55585: PPUSH
55586: LD_VAR 0 4
55590: PPUSH
55591: EMPTY
55592: PPUSH
55593: CALL_OW 1
55597: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55598: LD_ADDR_EXP 86
55602: PUSH
55603: LD_EXP 86
55607: PPUSH
55608: LD_VAR 0 4
55612: PPUSH
55613: EMPTY
55614: PPUSH
55615: CALL_OW 1
55619: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55620: LD_ADDR_EXP 87
55624: PUSH
55625: LD_EXP 87
55629: PPUSH
55630: LD_VAR 0 4
55634: PPUSH
55635: EMPTY
55636: PPUSH
55637: CALL_OW 1
55641: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55642: LD_ADDR_EXP 88
55646: PUSH
55647: LD_EXP 88
55651: PPUSH
55652: LD_VAR 0 4
55656: PPUSH
55657: EMPTY
55658: PPUSH
55659: CALL_OW 1
55663: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55664: LD_ADDR_EXP 89
55668: PUSH
55669: LD_EXP 89
55673: PPUSH
55674: LD_VAR 0 4
55678: PPUSH
55679: EMPTY
55680: PPUSH
55681: CALL_OW 1
55685: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55686: LD_ADDR_EXP 90
55690: PUSH
55691: LD_EXP 90
55695: PPUSH
55696: LD_VAR 0 4
55700: PPUSH
55701: EMPTY
55702: PPUSH
55703: CALL_OW 1
55707: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55708: LD_ADDR_EXP 91
55712: PUSH
55713: LD_EXP 91
55717: PPUSH
55718: LD_VAR 0 4
55722: PPUSH
55723: EMPTY
55724: PPUSH
55725: CALL_OW 1
55729: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55730: LD_ADDR_EXP 92
55734: PUSH
55735: LD_EXP 92
55739: PPUSH
55740: LD_VAR 0 4
55744: PPUSH
55745: EMPTY
55746: PPUSH
55747: CALL_OW 1
55751: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55752: LD_ADDR_EXP 93
55756: PUSH
55757: LD_EXP 93
55761: PPUSH
55762: LD_VAR 0 4
55766: PPUSH
55767: EMPTY
55768: PPUSH
55769: CALL_OW 1
55773: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55774: LD_ADDR_EXP 94
55778: PUSH
55779: LD_EXP 94
55783: PPUSH
55784: LD_VAR 0 4
55788: PPUSH
55789: LD_INT 0
55791: PPUSH
55792: CALL_OW 1
55796: ST_TO_ADDR
// result := base ;
55797: LD_ADDR_VAR 0 3
55801: PUSH
55802: LD_VAR 0 4
55806: ST_TO_ADDR
// end ;
55807: LD_VAR 0 3
55811: RET
// export function MC_Start ( ) ; var i ; begin
55812: LD_INT 0
55814: PPUSH
55815: PPUSH
// for i = 1 to mc_bases do
55816: LD_ADDR_VAR 0 2
55820: PUSH
55821: DOUBLE
55822: LD_INT 1
55824: DEC
55825: ST_TO_ADDR
55826: LD_EXP 52
55830: PUSH
55831: FOR_TO
55832: IFFALSE 56909
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
55834: LD_ADDR_EXP 52
55838: PUSH
55839: LD_EXP 52
55843: PPUSH
55844: LD_VAR 0 2
55848: PPUSH
55849: LD_EXP 52
55853: PUSH
55854: LD_VAR 0 2
55858: ARRAY
55859: PUSH
55860: LD_INT 0
55862: DIFF
55863: PPUSH
55864: CALL_OW 1
55868: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
55869: LD_ADDR_EXP 53
55873: PUSH
55874: LD_EXP 53
55878: PPUSH
55879: LD_VAR 0 2
55883: PPUSH
55884: EMPTY
55885: PPUSH
55886: CALL_OW 1
55890: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
55891: LD_ADDR_EXP 54
55895: PUSH
55896: LD_EXP 54
55900: PPUSH
55901: LD_VAR 0 2
55905: PPUSH
55906: EMPTY
55907: PPUSH
55908: CALL_OW 1
55912: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
55913: LD_ADDR_EXP 55
55917: PUSH
55918: LD_EXP 55
55922: PPUSH
55923: LD_VAR 0 2
55927: PPUSH
55928: EMPTY
55929: PPUSH
55930: CALL_OW 1
55934: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
55935: LD_ADDR_EXP 56
55939: PUSH
55940: LD_EXP 56
55944: PPUSH
55945: LD_VAR 0 2
55949: PPUSH
55950: EMPTY
55951: PUSH
55952: EMPTY
55953: PUSH
55954: EMPTY
55955: LIST
55956: LIST
55957: PPUSH
55958: CALL_OW 1
55962: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
55963: LD_ADDR_EXP 57
55967: PUSH
55968: LD_EXP 57
55972: PPUSH
55973: LD_VAR 0 2
55977: PPUSH
55978: EMPTY
55979: PPUSH
55980: CALL_OW 1
55984: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
55985: LD_ADDR_EXP 84
55989: PUSH
55990: LD_EXP 84
55994: PPUSH
55995: LD_VAR 0 2
55999: PPUSH
56000: EMPTY
56001: PPUSH
56002: CALL_OW 1
56006: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
56007: LD_ADDR_EXP 58
56011: PUSH
56012: LD_EXP 58
56016: PPUSH
56017: LD_VAR 0 2
56021: PPUSH
56022: EMPTY
56023: PPUSH
56024: CALL_OW 1
56028: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
56029: LD_ADDR_EXP 59
56033: PUSH
56034: LD_EXP 59
56038: PPUSH
56039: LD_VAR 0 2
56043: PPUSH
56044: EMPTY
56045: PPUSH
56046: CALL_OW 1
56050: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
56051: LD_ADDR_EXP 60
56055: PUSH
56056: LD_EXP 60
56060: PPUSH
56061: LD_VAR 0 2
56065: PPUSH
56066: LD_EXP 52
56070: PUSH
56071: LD_VAR 0 2
56075: ARRAY
56076: PPUSH
56077: LD_INT 2
56079: PUSH
56080: LD_INT 30
56082: PUSH
56083: LD_INT 32
56085: PUSH
56086: EMPTY
56087: LIST
56088: LIST
56089: PUSH
56090: LD_INT 30
56092: PUSH
56093: LD_INT 33
56095: PUSH
56096: EMPTY
56097: LIST
56098: LIST
56099: PUSH
56100: EMPTY
56101: LIST
56102: LIST
56103: LIST
56104: PPUSH
56105: CALL_OW 72
56109: PPUSH
56110: CALL_OW 1
56114: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
56115: LD_ADDR_EXP 61
56119: PUSH
56120: LD_EXP 61
56124: PPUSH
56125: LD_VAR 0 2
56129: PPUSH
56130: LD_EXP 52
56134: PUSH
56135: LD_VAR 0 2
56139: ARRAY
56140: PPUSH
56141: LD_INT 2
56143: PUSH
56144: LD_INT 30
56146: PUSH
56147: LD_INT 32
56149: PUSH
56150: EMPTY
56151: LIST
56152: LIST
56153: PUSH
56154: LD_INT 30
56156: PUSH
56157: LD_INT 31
56159: PUSH
56160: EMPTY
56161: LIST
56162: LIST
56163: PUSH
56164: EMPTY
56165: LIST
56166: LIST
56167: LIST
56168: PUSH
56169: LD_INT 58
56171: PUSH
56172: EMPTY
56173: LIST
56174: PUSH
56175: EMPTY
56176: LIST
56177: LIST
56178: PPUSH
56179: CALL_OW 72
56183: PPUSH
56184: CALL_OW 1
56188: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
56189: LD_ADDR_EXP 62
56193: PUSH
56194: LD_EXP 62
56198: PPUSH
56199: LD_VAR 0 2
56203: PPUSH
56204: EMPTY
56205: PPUSH
56206: CALL_OW 1
56210: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
56211: LD_ADDR_EXP 66
56215: PUSH
56216: LD_EXP 66
56220: PPUSH
56221: LD_VAR 0 2
56225: PPUSH
56226: EMPTY
56227: PPUSH
56228: CALL_OW 1
56232: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
56233: LD_ADDR_EXP 65
56237: PUSH
56238: LD_EXP 65
56242: PPUSH
56243: LD_VAR 0 2
56247: PPUSH
56248: EMPTY
56249: PPUSH
56250: CALL_OW 1
56254: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
56255: LD_ADDR_EXP 67
56259: PUSH
56260: LD_EXP 67
56264: PPUSH
56265: LD_VAR 0 2
56269: PPUSH
56270: EMPTY
56271: PPUSH
56272: CALL_OW 1
56276: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
56277: LD_ADDR_EXP 68
56281: PUSH
56282: LD_EXP 68
56286: PPUSH
56287: LD_VAR 0 2
56291: PPUSH
56292: EMPTY
56293: PPUSH
56294: CALL_OW 1
56298: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
56299: LD_ADDR_EXP 69
56303: PUSH
56304: LD_EXP 69
56308: PPUSH
56309: LD_VAR 0 2
56313: PPUSH
56314: EMPTY
56315: PPUSH
56316: CALL_OW 1
56320: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
56321: LD_ADDR_EXP 70
56325: PUSH
56326: LD_EXP 70
56330: PPUSH
56331: LD_VAR 0 2
56335: PPUSH
56336: EMPTY
56337: PPUSH
56338: CALL_OW 1
56342: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
56343: LD_ADDR_EXP 71
56347: PUSH
56348: LD_EXP 71
56352: PPUSH
56353: LD_VAR 0 2
56357: PPUSH
56358: EMPTY
56359: PPUSH
56360: CALL_OW 1
56364: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
56365: LD_ADDR_EXP 72
56369: PUSH
56370: LD_EXP 72
56374: PPUSH
56375: LD_VAR 0 2
56379: PPUSH
56380: EMPTY
56381: PPUSH
56382: CALL_OW 1
56386: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
56387: LD_ADDR_EXP 73
56391: PUSH
56392: LD_EXP 73
56396: PPUSH
56397: LD_VAR 0 2
56401: PPUSH
56402: EMPTY
56403: PPUSH
56404: CALL_OW 1
56408: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56409: LD_ADDR_EXP 74
56413: PUSH
56414: LD_EXP 74
56418: PPUSH
56419: LD_VAR 0 2
56423: PPUSH
56424: EMPTY
56425: PPUSH
56426: CALL_OW 1
56430: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
56431: LD_ADDR_EXP 63
56435: PUSH
56436: LD_EXP 63
56440: PPUSH
56441: LD_VAR 0 2
56445: PPUSH
56446: LD_INT 0
56448: PPUSH
56449: CALL_OW 1
56453: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
56454: LD_ADDR_EXP 76
56458: PUSH
56459: LD_EXP 76
56463: PPUSH
56464: LD_VAR 0 2
56468: PPUSH
56469: LD_INT 0
56471: PPUSH
56472: CALL_OW 1
56476: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
56477: LD_ADDR_EXP 64
56481: PUSH
56482: LD_EXP 64
56486: PPUSH
56487: LD_VAR 0 2
56491: PPUSH
56492: EMPTY
56493: PPUSH
56494: CALL_OW 1
56498: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
56499: LD_ADDR_EXP 75
56503: PUSH
56504: LD_EXP 75
56508: PPUSH
56509: LD_VAR 0 2
56513: PPUSH
56514: LD_INT 0
56516: PPUSH
56517: CALL_OW 1
56521: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
56522: LD_ADDR_EXP 77
56526: PUSH
56527: LD_EXP 77
56531: PPUSH
56532: LD_VAR 0 2
56536: PPUSH
56537: EMPTY
56538: PPUSH
56539: CALL_OW 1
56543: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
56544: LD_ADDR_EXP 80
56548: PUSH
56549: LD_EXP 80
56553: PPUSH
56554: LD_VAR 0 2
56558: PPUSH
56559: LD_INT 0
56561: PPUSH
56562: CALL_OW 1
56566: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
56567: LD_ADDR_EXP 81
56571: PUSH
56572: LD_EXP 81
56576: PPUSH
56577: LD_VAR 0 2
56581: PPUSH
56582: EMPTY
56583: PPUSH
56584: CALL_OW 1
56588: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
56589: LD_ADDR_EXP 82
56593: PUSH
56594: LD_EXP 82
56598: PPUSH
56599: LD_VAR 0 2
56603: PPUSH
56604: EMPTY
56605: PPUSH
56606: CALL_OW 1
56610: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
56611: LD_ADDR_EXP 83
56615: PUSH
56616: LD_EXP 83
56620: PPUSH
56621: LD_VAR 0 2
56625: PPUSH
56626: EMPTY
56627: PPUSH
56628: CALL_OW 1
56632: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
56633: LD_ADDR_EXP 85
56637: PUSH
56638: LD_EXP 85
56642: PPUSH
56643: LD_VAR 0 2
56647: PPUSH
56648: LD_EXP 52
56652: PUSH
56653: LD_VAR 0 2
56657: ARRAY
56658: PPUSH
56659: LD_INT 2
56661: PUSH
56662: LD_INT 30
56664: PUSH
56665: LD_INT 6
56667: PUSH
56668: EMPTY
56669: LIST
56670: LIST
56671: PUSH
56672: LD_INT 30
56674: PUSH
56675: LD_INT 7
56677: PUSH
56678: EMPTY
56679: LIST
56680: LIST
56681: PUSH
56682: LD_INT 30
56684: PUSH
56685: LD_INT 8
56687: PUSH
56688: EMPTY
56689: LIST
56690: LIST
56691: PUSH
56692: EMPTY
56693: LIST
56694: LIST
56695: LIST
56696: LIST
56697: PPUSH
56698: CALL_OW 72
56702: PPUSH
56703: CALL_OW 1
56707: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
56708: LD_ADDR_EXP 86
56712: PUSH
56713: LD_EXP 86
56717: PPUSH
56718: LD_VAR 0 2
56722: PPUSH
56723: EMPTY
56724: PPUSH
56725: CALL_OW 1
56729: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
56730: LD_ADDR_EXP 87
56734: PUSH
56735: LD_EXP 87
56739: PPUSH
56740: LD_VAR 0 2
56744: PPUSH
56745: EMPTY
56746: PPUSH
56747: CALL_OW 1
56751: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
56752: LD_ADDR_EXP 88
56756: PUSH
56757: LD_EXP 88
56761: PPUSH
56762: LD_VAR 0 2
56766: PPUSH
56767: EMPTY
56768: PPUSH
56769: CALL_OW 1
56773: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
56774: LD_ADDR_EXP 89
56778: PUSH
56779: LD_EXP 89
56783: PPUSH
56784: LD_VAR 0 2
56788: PPUSH
56789: EMPTY
56790: PPUSH
56791: CALL_OW 1
56795: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56796: LD_ADDR_EXP 90
56800: PUSH
56801: LD_EXP 90
56805: PPUSH
56806: LD_VAR 0 2
56810: PPUSH
56811: EMPTY
56812: PPUSH
56813: CALL_OW 1
56817: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
56818: LD_ADDR_EXP 91
56822: PUSH
56823: LD_EXP 91
56827: PPUSH
56828: LD_VAR 0 2
56832: PPUSH
56833: EMPTY
56834: PPUSH
56835: CALL_OW 1
56839: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
56840: LD_ADDR_EXP 92
56844: PUSH
56845: LD_EXP 92
56849: PPUSH
56850: LD_VAR 0 2
56854: PPUSH
56855: EMPTY
56856: PPUSH
56857: CALL_OW 1
56861: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
56862: LD_ADDR_EXP 93
56866: PUSH
56867: LD_EXP 93
56871: PPUSH
56872: LD_VAR 0 2
56876: PPUSH
56877: EMPTY
56878: PPUSH
56879: CALL_OW 1
56883: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
56884: LD_ADDR_EXP 94
56888: PUSH
56889: LD_EXP 94
56893: PPUSH
56894: LD_VAR 0 2
56898: PPUSH
56899: LD_INT 0
56901: PPUSH
56902: CALL_OW 1
56906: ST_TO_ADDR
// end ;
56907: GO 55831
56909: POP
56910: POP
// MC_InitSides ( ) ;
56911: CALL 57197 0 0
// MC_InitResearch ( ) ;
56915: CALL 56936 0 0
// CustomInitMacro ( ) ;
56919: CALL 5346 0 0
// skirmish := true ;
56923: LD_ADDR_EXP 50
56927: PUSH
56928: LD_INT 1
56930: ST_TO_ADDR
// end ;
56931: LD_VAR 0 1
56935: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
56936: LD_INT 0
56938: PPUSH
56939: PPUSH
56940: PPUSH
56941: PPUSH
56942: PPUSH
56943: PPUSH
// if not mc_bases then
56944: LD_EXP 52
56948: NOT
56949: IFFALSE 56953
// exit ;
56951: GO 57192
// for i = 1 to 8 do
56953: LD_ADDR_VAR 0 2
56957: PUSH
56958: DOUBLE
56959: LD_INT 1
56961: DEC
56962: ST_TO_ADDR
56963: LD_INT 8
56965: PUSH
56966: FOR_TO
56967: IFFALSE 56993
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
56969: LD_ADDR_EXP 79
56973: PUSH
56974: LD_EXP 79
56978: PPUSH
56979: LD_VAR 0 2
56983: PPUSH
56984: EMPTY
56985: PPUSH
56986: CALL_OW 1
56990: ST_TO_ADDR
56991: GO 56966
56993: POP
56994: POP
// tmp := [ ] ;
56995: LD_ADDR_VAR 0 5
56999: PUSH
57000: EMPTY
57001: ST_TO_ADDR
// for i = 1 to mc_sides do
57002: LD_ADDR_VAR 0 2
57006: PUSH
57007: DOUBLE
57008: LD_INT 1
57010: DEC
57011: ST_TO_ADDR
57012: LD_EXP 78
57016: PUSH
57017: FOR_TO
57018: IFFALSE 57076
// if not mc_sides [ i ] in tmp then
57020: LD_EXP 78
57024: PUSH
57025: LD_VAR 0 2
57029: ARRAY
57030: PUSH
57031: LD_VAR 0 5
57035: IN
57036: NOT
57037: IFFALSE 57074
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
57039: LD_ADDR_VAR 0 5
57043: PUSH
57044: LD_VAR 0 5
57048: PPUSH
57049: LD_VAR 0 5
57053: PUSH
57054: LD_INT 1
57056: PLUS
57057: PPUSH
57058: LD_EXP 78
57062: PUSH
57063: LD_VAR 0 2
57067: ARRAY
57068: PPUSH
57069: CALL_OW 2
57073: ST_TO_ADDR
57074: GO 57017
57076: POP
57077: POP
// if not tmp then
57078: LD_VAR 0 5
57082: NOT
57083: IFFALSE 57087
// exit ;
57085: GO 57192
// for j in tmp do
57087: LD_ADDR_VAR 0 3
57091: PUSH
57092: LD_VAR 0 5
57096: PUSH
57097: FOR_IN
57098: IFFALSE 57190
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
57100: LD_ADDR_VAR 0 6
57104: PUSH
57105: LD_INT 22
57107: PUSH
57108: LD_VAR 0 3
57112: PUSH
57113: EMPTY
57114: LIST
57115: LIST
57116: PPUSH
57117: CALL_OW 69
57121: ST_TO_ADDR
// if not un then
57122: LD_VAR 0 6
57126: NOT
57127: IFFALSE 57131
// continue ;
57129: GO 57097
// nation := GetNation ( un [ 1 ] ) ;
57131: LD_ADDR_VAR 0 4
57135: PUSH
57136: LD_VAR 0 6
57140: PUSH
57141: LD_INT 1
57143: ARRAY
57144: PPUSH
57145: CALL_OW 248
57149: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
57150: LD_ADDR_EXP 79
57154: PUSH
57155: LD_EXP 79
57159: PPUSH
57160: LD_VAR 0 3
57164: PPUSH
57165: LD_VAR 0 3
57169: PPUSH
57170: LD_VAR 0 4
57174: PPUSH
57175: LD_INT 1
57177: PPUSH
57178: CALL 11146 0 3
57182: PPUSH
57183: CALL_OW 1
57187: ST_TO_ADDR
// end ;
57188: GO 57097
57190: POP
57191: POP
// end ;
57192: LD_VAR 0 1
57196: RET
// export function MC_InitSides ( ) ; var i ; begin
57197: LD_INT 0
57199: PPUSH
57200: PPUSH
// if not mc_bases then
57201: LD_EXP 52
57205: NOT
57206: IFFALSE 57210
// exit ;
57208: GO 57284
// for i = 1 to mc_bases do
57210: LD_ADDR_VAR 0 2
57214: PUSH
57215: DOUBLE
57216: LD_INT 1
57218: DEC
57219: ST_TO_ADDR
57220: LD_EXP 52
57224: PUSH
57225: FOR_TO
57226: IFFALSE 57282
// if mc_bases [ i ] then
57228: LD_EXP 52
57232: PUSH
57233: LD_VAR 0 2
57237: ARRAY
57238: IFFALSE 57280
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
57240: LD_ADDR_EXP 78
57244: PUSH
57245: LD_EXP 78
57249: PPUSH
57250: LD_VAR 0 2
57254: PPUSH
57255: LD_EXP 52
57259: PUSH
57260: LD_VAR 0 2
57264: ARRAY
57265: PUSH
57266: LD_INT 1
57268: ARRAY
57269: PPUSH
57270: CALL_OW 255
57274: PPUSH
57275: CALL_OW 1
57279: ST_TO_ADDR
57280: GO 57225
57282: POP
57283: POP
// end ;
57284: LD_VAR 0 1
57288: RET
// every 0 0$01 trigger skirmish do
57289: LD_EXP 50
57293: IFFALSE 57447
57295: GO 57297
57297: DISABLE
// begin enable ;
57298: ENABLE
// MC_CheckBuildings ( ) ;
57299: CALL 61936 0 0
// MC_CheckPeopleLife ( ) ;
57303: CALL 62061 0 0
// RaiseSailEvent ( 100 ) ;
57307: LD_INT 100
57309: PPUSH
57310: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
57314: LD_INT 103
57316: PPUSH
57317: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
57321: LD_INT 104
57323: PPUSH
57324: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
57328: LD_INT 105
57330: PPUSH
57331: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
57335: LD_INT 106
57337: PPUSH
57338: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
57342: LD_INT 107
57344: PPUSH
57345: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
57349: LD_INT 108
57351: PPUSH
57352: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
57356: LD_INT 109
57358: PPUSH
57359: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
57363: LD_INT 110
57365: PPUSH
57366: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
57370: LD_INT 111
57372: PPUSH
57373: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
57377: LD_INT 112
57379: PPUSH
57380: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
57384: LD_INT 113
57386: PPUSH
57387: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
57391: LD_INT 120
57393: PPUSH
57394: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
57398: LD_INT 121
57400: PPUSH
57401: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
57405: LD_INT 122
57407: PPUSH
57408: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
57412: LD_INT 123
57414: PPUSH
57415: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
57419: LD_INT 124
57421: PPUSH
57422: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
57426: LD_INT 125
57428: PPUSH
57429: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
57433: LD_INT 126
57435: PPUSH
57436: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
57440: LD_INT 200
57442: PPUSH
57443: CALL_OW 427
// end ;
57447: END
// on SailEvent ( event ) do begin if event < 100 then
57448: LD_VAR 0 1
57452: PUSH
57453: LD_INT 100
57455: LESS
57456: IFFALSE 57467
// CustomEvent ( event ) ;
57458: LD_VAR 0 1
57462: PPUSH
57463: CALL 5338 0 1
// if event = 100 then
57467: LD_VAR 0 1
57471: PUSH
57472: LD_INT 100
57474: EQUAL
57475: IFFALSE 57481
// MC_ClassManager ( ) ;
57477: CALL 57873 0 0
// if event = 101 then
57481: LD_VAR 0 1
57485: PUSH
57486: LD_INT 101
57488: EQUAL
57489: IFFALSE 57495
// MC_RepairBuildings ( ) ;
57491: CALL 62657 0 0
// if event = 102 then
57495: LD_VAR 0 1
57499: PUSH
57500: LD_INT 102
57502: EQUAL
57503: IFFALSE 57509
// MC_Heal ( ) ;
57505: CALL 63063 0 0
// if event = 103 then
57509: LD_VAR 0 1
57513: PUSH
57514: LD_INT 103
57516: EQUAL
57517: IFFALSE 57523
// MC_Build ( ) ;
57519: CALL 63485 0 0
// if event = 104 then
57523: LD_VAR 0 1
57527: PUSH
57528: LD_INT 104
57530: EQUAL
57531: IFFALSE 57537
// MC_TurretWeapon ( ) ;
57533: CALL 65098 0 0
// if event = 105 then
57537: LD_VAR 0 1
57541: PUSH
57542: LD_INT 105
57544: EQUAL
57545: IFFALSE 57551
// MC_BuildUpgrade ( ) ;
57547: CALL 64649 0 0
// if event = 106 then
57551: LD_VAR 0 1
57555: PUSH
57556: LD_INT 106
57558: EQUAL
57559: IFFALSE 57565
// MC_PlantMines ( ) ;
57561: CALL 65528 0 0
// if event = 107 then
57565: LD_VAR 0 1
57569: PUSH
57570: LD_INT 107
57572: EQUAL
57573: IFFALSE 57579
// MC_CollectCrates ( ) ;
57575: CALL 66562 0 0
// if event = 108 then
57579: LD_VAR 0 1
57583: PUSH
57584: LD_INT 108
57586: EQUAL
57587: IFFALSE 57593
// MC_LinkRemoteControl ( ) ;
57589: CALL 68319 0 0
// if event = 109 then
57593: LD_VAR 0 1
57597: PUSH
57598: LD_INT 109
57600: EQUAL
57601: IFFALSE 57607
// MC_ProduceVehicle ( ) ;
57603: CALL 68500 0 0
// if event = 110 then
57607: LD_VAR 0 1
57611: PUSH
57612: LD_INT 110
57614: EQUAL
57615: IFFALSE 57621
// MC_SendAttack ( ) ;
57617: CALL 68981 0 0
// if event = 111 then
57621: LD_VAR 0 1
57625: PUSH
57626: LD_INT 111
57628: EQUAL
57629: IFFALSE 57635
// MC_Defend ( ) ;
57631: CALL 69089 0 0
// if event = 112 then
57635: LD_VAR 0 1
57639: PUSH
57640: LD_INT 112
57642: EQUAL
57643: IFFALSE 57649
// MC_Research ( ) ;
57645: CALL 69694 0 0
// if event = 113 then
57649: LD_VAR 0 1
57653: PUSH
57654: LD_INT 113
57656: EQUAL
57657: IFFALSE 57663
// MC_MinesTrigger ( ) ;
57659: CALL 70808 0 0
// if event = 120 then
57663: LD_VAR 0 1
57667: PUSH
57668: LD_INT 120
57670: EQUAL
57671: IFFALSE 57677
// MC_RepairVehicle ( ) ;
57673: CALL 70907 0 0
// if event = 121 then
57677: LD_VAR 0 1
57681: PUSH
57682: LD_INT 121
57684: EQUAL
57685: IFFALSE 57691
// MC_TameApe ( ) ;
57687: CALL 71614 0 0
// if event = 122 then
57691: LD_VAR 0 1
57695: PUSH
57696: LD_INT 122
57698: EQUAL
57699: IFFALSE 57705
// MC_ChangeApeClass ( ) ;
57701: CALL 72443 0 0
// if event = 123 then
57705: LD_VAR 0 1
57709: PUSH
57710: LD_INT 123
57712: EQUAL
57713: IFFALSE 57719
// MC_Bazooka ( ) ;
57715: CALL 73093 0 0
// if event = 124 then
57719: LD_VAR 0 1
57723: PUSH
57724: LD_INT 124
57726: EQUAL
57727: IFFALSE 57733
// MC_TeleportExit ( ) ;
57729: CALL 73291 0 0
// if event = 125 then
57733: LD_VAR 0 1
57737: PUSH
57738: LD_INT 125
57740: EQUAL
57741: IFFALSE 57747
// MC_Deposits ( ) ;
57743: CALL 73938 0 0
// if event = 126 then
57747: LD_VAR 0 1
57751: PUSH
57752: LD_INT 126
57754: EQUAL
57755: IFFALSE 57761
// MC_RemoteDriver ( ) ;
57757: CALL 74563 0 0
// if event = 200 then
57761: LD_VAR 0 1
57765: PUSH
57766: LD_INT 200
57768: EQUAL
57769: IFFALSE 57775
// MC_Idle ( ) ;
57771: CALL 76296 0 0
// end ;
57775: PPOPN 1
57777: END
// export function MC_Reset ( base , tag ) ; var i ; begin
57778: LD_INT 0
57780: PPUSH
57781: PPUSH
// if not mc_bases [ base ] or not tag then
57782: LD_EXP 52
57786: PUSH
57787: LD_VAR 0 1
57791: ARRAY
57792: NOT
57793: PUSH
57794: LD_VAR 0 2
57798: NOT
57799: OR
57800: IFFALSE 57804
// exit ;
57802: GO 57868
// for i in mc_bases [ base ] union mc_ape [ base ] do
57804: LD_ADDR_VAR 0 4
57808: PUSH
57809: LD_EXP 52
57813: PUSH
57814: LD_VAR 0 1
57818: ARRAY
57819: PUSH
57820: LD_EXP 81
57824: PUSH
57825: LD_VAR 0 1
57829: ARRAY
57830: UNION
57831: PUSH
57832: FOR_IN
57833: IFFALSE 57866
// if GetTag ( i ) = tag then
57835: LD_VAR 0 4
57839: PPUSH
57840: CALL_OW 110
57844: PUSH
57845: LD_VAR 0 2
57849: EQUAL
57850: IFFALSE 57864
// SetTag ( i , 0 ) ;
57852: LD_VAR 0 4
57856: PPUSH
57857: LD_INT 0
57859: PPUSH
57860: CALL_OW 109
57864: GO 57832
57866: POP
57867: POP
// end ;
57868: LD_VAR 0 3
57872: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
57873: LD_INT 0
57875: PPUSH
57876: PPUSH
57877: PPUSH
57878: PPUSH
57879: PPUSH
57880: PPUSH
57881: PPUSH
57882: PPUSH
// if not mc_bases then
57883: LD_EXP 52
57887: NOT
57888: IFFALSE 57892
// exit ;
57890: GO 58350
// for i = 1 to mc_bases do
57892: LD_ADDR_VAR 0 2
57896: PUSH
57897: DOUBLE
57898: LD_INT 1
57900: DEC
57901: ST_TO_ADDR
57902: LD_EXP 52
57906: PUSH
57907: FOR_TO
57908: IFFALSE 58348
// begin tmp := MC_ClassCheckReq ( i ) ;
57910: LD_ADDR_VAR 0 4
57914: PUSH
57915: LD_VAR 0 2
57919: PPUSH
57920: CALL 58355 0 1
57924: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
57925: LD_ADDR_EXP 93
57929: PUSH
57930: LD_EXP 93
57934: PPUSH
57935: LD_VAR 0 2
57939: PPUSH
57940: LD_VAR 0 4
57944: PPUSH
57945: CALL_OW 1
57949: ST_TO_ADDR
// if not tmp then
57950: LD_VAR 0 4
57954: NOT
57955: IFFALSE 57959
// continue ;
57957: GO 57907
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
57959: LD_ADDR_VAR 0 6
57963: PUSH
57964: LD_EXP 52
57968: PUSH
57969: LD_VAR 0 2
57973: ARRAY
57974: PPUSH
57975: LD_INT 2
57977: PUSH
57978: LD_INT 30
57980: PUSH
57981: LD_INT 4
57983: PUSH
57984: EMPTY
57985: LIST
57986: LIST
57987: PUSH
57988: LD_INT 30
57990: PUSH
57991: LD_INT 5
57993: PUSH
57994: EMPTY
57995: LIST
57996: LIST
57997: PUSH
57998: EMPTY
57999: LIST
58000: LIST
58001: LIST
58002: PPUSH
58003: CALL_OW 72
58007: PUSH
58008: LD_EXP 52
58012: PUSH
58013: LD_VAR 0 2
58017: ARRAY
58018: PPUSH
58019: LD_INT 2
58021: PUSH
58022: LD_INT 30
58024: PUSH
58025: LD_INT 0
58027: PUSH
58028: EMPTY
58029: LIST
58030: LIST
58031: PUSH
58032: LD_INT 30
58034: PUSH
58035: LD_INT 1
58037: PUSH
58038: EMPTY
58039: LIST
58040: LIST
58041: PUSH
58042: EMPTY
58043: LIST
58044: LIST
58045: LIST
58046: PPUSH
58047: CALL_OW 72
58051: PUSH
58052: LD_EXP 52
58056: PUSH
58057: LD_VAR 0 2
58061: ARRAY
58062: PPUSH
58063: LD_INT 30
58065: PUSH
58066: LD_INT 3
58068: PUSH
58069: EMPTY
58070: LIST
58071: LIST
58072: PPUSH
58073: CALL_OW 72
58077: PUSH
58078: LD_EXP 52
58082: PUSH
58083: LD_VAR 0 2
58087: ARRAY
58088: PPUSH
58089: LD_INT 2
58091: PUSH
58092: LD_INT 30
58094: PUSH
58095: LD_INT 6
58097: PUSH
58098: EMPTY
58099: LIST
58100: LIST
58101: PUSH
58102: LD_INT 30
58104: PUSH
58105: LD_INT 7
58107: PUSH
58108: EMPTY
58109: LIST
58110: LIST
58111: PUSH
58112: LD_INT 30
58114: PUSH
58115: LD_INT 8
58117: PUSH
58118: EMPTY
58119: LIST
58120: LIST
58121: PUSH
58122: EMPTY
58123: LIST
58124: LIST
58125: LIST
58126: LIST
58127: PPUSH
58128: CALL_OW 72
58132: PUSH
58133: EMPTY
58134: LIST
58135: LIST
58136: LIST
58137: LIST
58138: ST_TO_ADDR
// for j = 1 to 4 do
58139: LD_ADDR_VAR 0 3
58143: PUSH
58144: DOUBLE
58145: LD_INT 1
58147: DEC
58148: ST_TO_ADDR
58149: LD_INT 4
58151: PUSH
58152: FOR_TO
58153: IFFALSE 58344
// begin if not tmp [ j ] then
58155: LD_VAR 0 4
58159: PUSH
58160: LD_VAR 0 3
58164: ARRAY
58165: NOT
58166: IFFALSE 58170
// continue ;
58168: GO 58152
// for p in tmp [ j ] do
58170: LD_ADDR_VAR 0 5
58174: PUSH
58175: LD_VAR 0 4
58179: PUSH
58180: LD_VAR 0 3
58184: ARRAY
58185: PUSH
58186: FOR_IN
58187: IFFALSE 58340
// begin if not b [ j ] then
58189: LD_VAR 0 6
58193: PUSH
58194: LD_VAR 0 3
58198: ARRAY
58199: NOT
58200: IFFALSE 58204
// break ;
58202: GO 58340
// e := 0 ;
58204: LD_ADDR_VAR 0 7
58208: PUSH
58209: LD_INT 0
58211: ST_TO_ADDR
// for k in b [ j ] do
58212: LD_ADDR_VAR 0 8
58216: PUSH
58217: LD_VAR 0 6
58221: PUSH
58222: LD_VAR 0 3
58226: ARRAY
58227: PUSH
58228: FOR_IN
58229: IFFALSE 58256
// if IsNotFull ( k ) then
58231: LD_VAR 0 8
58235: PPUSH
58236: CALL 15143 0 1
58240: IFFALSE 58254
// begin e := k ;
58242: LD_ADDR_VAR 0 7
58246: PUSH
58247: LD_VAR 0 8
58251: ST_TO_ADDR
// break ;
58252: GO 58256
// end ;
58254: GO 58228
58256: POP
58257: POP
// if e and not UnitGoingToBuilding ( p , e ) then
58258: LD_VAR 0 7
58262: PUSH
58263: LD_VAR 0 5
58267: PPUSH
58268: LD_VAR 0 7
58272: PPUSH
58273: CALL 52201 0 2
58277: NOT
58278: AND
58279: IFFALSE 58338
// begin if IsInUnit ( p ) then
58281: LD_VAR 0 5
58285: PPUSH
58286: CALL_OW 310
58290: IFFALSE 58301
// ComExitBuilding ( p ) ;
58292: LD_VAR 0 5
58296: PPUSH
58297: CALL_OW 122
// ComEnterUnit ( p , e ) ;
58301: LD_VAR 0 5
58305: PPUSH
58306: LD_VAR 0 7
58310: PPUSH
58311: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
58315: LD_VAR 0 5
58319: PPUSH
58320: LD_VAR 0 3
58324: PPUSH
58325: CALL_OW 183
// AddComExitBuilding ( p ) ;
58329: LD_VAR 0 5
58333: PPUSH
58334: CALL_OW 182
// end ; end ;
58338: GO 58186
58340: POP
58341: POP
// end ;
58342: GO 58152
58344: POP
58345: POP
// end ;
58346: GO 57907
58348: POP
58349: POP
// end ;
58350: LD_VAR 0 1
58354: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
58355: LD_INT 0
58357: PPUSH
58358: PPUSH
58359: PPUSH
58360: PPUSH
58361: PPUSH
58362: PPUSH
58363: PPUSH
58364: PPUSH
58365: PPUSH
58366: PPUSH
58367: PPUSH
58368: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
58369: LD_VAR 0 1
58373: NOT
58374: PUSH
58375: LD_EXP 52
58379: PUSH
58380: LD_VAR 0 1
58384: ARRAY
58385: NOT
58386: OR
58387: PUSH
58388: LD_EXP 52
58392: PUSH
58393: LD_VAR 0 1
58397: ARRAY
58398: PPUSH
58399: LD_INT 2
58401: PUSH
58402: LD_INT 30
58404: PUSH
58405: LD_INT 0
58407: PUSH
58408: EMPTY
58409: LIST
58410: LIST
58411: PUSH
58412: LD_INT 30
58414: PUSH
58415: LD_INT 1
58417: PUSH
58418: EMPTY
58419: LIST
58420: LIST
58421: PUSH
58422: EMPTY
58423: LIST
58424: LIST
58425: LIST
58426: PPUSH
58427: CALL_OW 72
58431: NOT
58432: OR
58433: IFFALSE 58437
// exit ;
58435: GO 61931
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58437: LD_ADDR_VAR 0 4
58441: PUSH
58442: LD_EXP 52
58446: PUSH
58447: LD_VAR 0 1
58451: ARRAY
58452: PPUSH
58453: LD_INT 2
58455: PUSH
58456: LD_INT 25
58458: PUSH
58459: LD_INT 1
58461: PUSH
58462: EMPTY
58463: LIST
58464: LIST
58465: PUSH
58466: LD_INT 25
58468: PUSH
58469: LD_INT 2
58471: PUSH
58472: EMPTY
58473: LIST
58474: LIST
58475: PUSH
58476: LD_INT 25
58478: PUSH
58479: LD_INT 3
58481: PUSH
58482: EMPTY
58483: LIST
58484: LIST
58485: PUSH
58486: LD_INT 25
58488: PUSH
58489: LD_INT 4
58491: PUSH
58492: EMPTY
58493: LIST
58494: LIST
58495: PUSH
58496: LD_INT 25
58498: PUSH
58499: LD_INT 5
58501: PUSH
58502: EMPTY
58503: LIST
58504: LIST
58505: PUSH
58506: LD_INT 25
58508: PUSH
58509: LD_INT 8
58511: PUSH
58512: EMPTY
58513: LIST
58514: LIST
58515: PUSH
58516: LD_INT 25
58518: PUSH
58519: LD_INT 9
58521: PUSH
58522: EMPTY
58523: LIST
58524: LIST
58525: PUSH
58526: EMPTY
58527: LIST
58528: LIST
58529: LIST
58530: LIST
58531: LIST
58532: LIST
58533: LIST
58534: LIST
58535: PPUSH
58536: CALL_OW 72
58540: ST_TO_ADDR
// for i in tmp do
58541: LD_ADDR_VAR 0 3
58545: PUSH
58546: LD_VAR 0 4
58550: PUSH
58551: FOR_IN
58552: IFFALSE 58583
// if GetTag ( i ) then
58554: LD_VAR 0 3
58558: PPUSH
58559: CALL_OW 110
58563: IFFALSE 58581
// tmp := tmp diff i ;
58565: LD_ADDR_VAR 0 4
58569: PUSH
58570: LD_VAR 0 4
58574: PUSH
58575: LD_VAR 0 3
58579: DIFF
58580: ST_TO_ADDR
58581: GO 58551
58583: POP
58584: POP
// if not tmp then
58585: LD_VAR 0 4
58589: NOT
58590: IFFALSE 58594
// exit ;
58592: GO 61931
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58594: LD_ADDR_VAR 0 5
58598: PUSH
58599: LD_EXP 52
58603: PUSH
58604: LD_VAR 0 1
58608: ARRAY
58609: PPUSH
58610: LD_INT 2
58612: PUSH
58613: LD_INT 25
58615: PUSH
58616: LD_INT 1
58618: PUSH
58619: EMPTY
58620: LIST
58621: LIST
58622: PUSH
58623: LD_INT 25
58625: PUSH
58626: LD_INT 5
58628: PUSH
58629: EMPTY
58630: LIST
58631: LIST
58632: PUSH
58633: LD_INT 25
58635: PUSH
58636: LD_INT 8
58638: PUSH
58639: EMPTY
58640: LIST
58641: LIST
58642: PUSH
58643: LD_INT 25
58645: PUSH
58646: LD_INT 9
58648: PUSH
58649: EMPTY
58650: LIST
58651: LIST
58652: PUSH
58653: EMPTY
58654: LIST
58655: LIST
58656: LIST
58657: LIST
58658: LIST
58659: PPUSH
58660: CALL_OW 72
58664: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
58665: LD_ADDR_VAR 0 6
58669: PUSH
58670: LD_EXP 52
58674: PUSH
58675: LD_VAR 0 1
58679: ARRAY
58680: PPUSH
58681: LD_INT 25
58683: PUSH
58684: LD_INT 2
58686: PUSH
58687: EMPTY
58688: LIST
58689: LIST
58690: PPUSH
58691: CALL_OW 72
58695: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
58696: LD_ADDR_VAR 0 7
58700: PUSH
58701: LD_EXP 52
58705: PUSH
58706: LD_VAR 0 1
58710: ARRAY
58711: PPUSH
58712: LD_INT 25
58714: PUSH
58715: LD_INT 3
58717: PUSH
58718: EMPTY
58719: LIST
58720: LIST
58721: PPUSH
58722: CALL_OW 72
58726: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
58727: LD_ADDR_VAR 0 8
58731: PUSH
58732: LD_EXP 52
58736: PUSH
58737: LD_VAR 0 1
58741: ARRAY
58742: PPUSH
58743: LD_INT 25
58745: PUSH
58746: LD_INT 4
58748: PUSH
58749: EMPTY
58750: LIST
58751: LIST
58752: PUSH
58753: LD_INT 24
58755: PUSH
58756: LD_INT 251
58758: PUSH
58759: EMPTY
58760: LIST
58761: LIST
58762: PUSH
58763: EMPTY
58764: LIST
58765: LIST
58766: PPUSH
58767: CALL_OW 72
58771: ST_TO_ADDR
// if mc_scan [ base ] then
58772: LD_EXP 75
58776: PUSH
58777: LD_VAR 0 1
58781: ARRAY
58782: IFFALSE 59243
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
58784: LD_ADDR_EXP 94
58788: PUSH
58789: LD_EXP 94
58793: PPUSH
58794: LD_VAR 0 1
58798: PPUSH
58799: LD_INT 4
58801: PPUSH
58802: CALL_OW 1
58806: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
58807: LD_ADDR_VAR 0 12
58811: PUSH
58812: LD_EXP 52
58816: PUSH
58817: LD_VAR 0 1
58821: ARRAY
58822: PPUSH
58823: LD_INT 2
58825: PUSH
58826: LD_INT 30
58828: PUSH
58829: LD_INT 4
58831: PUSH
58832: EMPTY
58833: LIST
58834: LIST
58835: PUSH
58836: LD_INT 30
58838: PUSH
58839: LD_INT 5
58841: PUSH
58842: EMPTY
58843: LIST
58844: LIST
58845: PUSH
58846: EMPTY
58847: LIST
58848: LIST
58849: LIST
58850: PPUSH
58851: CALL_OW 72
58855: ST_TO_ADDR
// if not b then
58856: LD_VAR 0 12
58860: NOT
58861: IFFALSE 58865
// exit ;
58863: GO 61931
// p := [ ] ;
58865: LD_ADDR_VAR 0 11
58869: PUSH
58870: EMPTY
58871: ST_TO_ADDR
// if sci >= 2 then
58872: LD_VAR 0 8
58876: PUSH
58877: LD_INT 2
58879: GREATEREQUAL
58880: IFFALSE 58911
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
58882: LD_ADDR_VAR 0 8
58886: PUSH
58887: LD_VAR 0 8
58891: PUSH
58892: LD_INT 1
58894: ARRAY
58895: PUSH
58896: LD_VAR 0 8
58900: PUSH
58901: LD_INT 2
58903: ARRAY
58904: PUSH
58905: EMPTY
58906: LIST
58907: LIST
58908: ST_TO_ADDR
58909: GO 58972
// if sci = 1 then
58911: LD_VAR 0 8
58915: PUSH
58916: LD_INT 1
58918: EQUAL
58919: IFFALSE 58940
// sci := [ sci [ 1 ] ] else
58921: LD_ADDR_VAR 0 8
58925: PUSH
58926: LD_VAR 0 8
58930: PUSH
58931: LD_INT 1
58933: ARRAY
58934: PUSH
58935: EMPTY
58936: LIST
58937: ST_TO_ADDR
58938: GO 58972
// if sci = 0 then
58940: LD_VAR 0 8
58944: PUSH
58945: LD_INT 0
58947: EQUAL
58948: IFFALSE 58972
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
58950: LD_ADDR_VAR 0 11
58954: PUSH
58955: LD_VAR 0 4
58959: PPUSH
58960: LD_INT 4
58962: PPUSH
58963: CALL 52064 0 2
58967: PUSH
58968: LD_INT 1
58970: ARRAY
58971: ST_TO_ADDR
// if eng > 4 then
58972: LD_VAR 0 6
58976: PUSH
58977: LD_INT 4
58979: GREATER
58980: IFFALSE 59026
// for i = eng downto 4 do
58982: LD_ADDR_VAR 0 3
58986: PUSH
58987: DOUBLE
58988: LD_VAR 0 6
58992: INC
58993: ST_TO_ADDR
58994: LD_INT 4
58996: PUSH
58997: FOR_DOWNTO
58998: IFFALSE 59024
// eng := eng diff eng [ i ] ;
59000: LD_ADDR_VAR 0 6
59004: PUSH
59005: LD_VAR 0 6
59009: PUSH
59010: LD_VAR 0 6
59014: PUSH
59015: LD_VAR 0 3
59019: ARRAY
59020: DIFF
59021: ST_TO_ADDR
59022: GO 58997
59024: POP
59025: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
59026: LD_ADDR_VAR 0 4
59030: PUSH
59031: LD_VAR 0 4
59035: PUSH
59036: LD_VAR 0 5
59040: PUSH
59041: LD_VAR 0 6
59045: UNION
59046: PUSH
59047: LD_VAR 0 7
59051: UNION
59052: PUSH
59053: LD_VAR 0 8
59057: UNION
59058: DIFF
59059: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
59060: LD_ADDR_VAR 0 13
59064: PUSH
59065: LD_EXP 52
59069: PUSH
59070: LD_VAR 0 1
59074: ARRAY
59075: PPUSH
59076: LD_INT 2
59078: PUSH
59079: LD_INT 30
59081: PUSH
59082: LD_INT 32
59084: PUSH
59085: EMPTY
59086: LIST
59087: LIST
59088: PUSH
59089: LD_INT 30
59091: PUSH
59092: LD_INT 31
59094: PUSH
59095: EMPTY
59096: LIST
59097: LIST
59098: PUSH
59099: EMPTY
59100: LIST
59101: LIST
59102: LIST
59103: PPUSH
59104: CALL_OW 72
59108: PUSH
59109: LD_EXP 52
59113: PUSH
59114: LD_VAR 0 1
59118: ARRAY
59119: PPUSH
59120: LD_INT 2
59122: PUSH
59123: LD_INT 30
59125: PUSH
59126: LD_INT 4
59128: PUSH
59129: EMPTY
59130: LIST
59131: LIST
59132: PUSH
59133: LD_INT 30
59135: PUSH
59136: LD_INT 5
59138: PUSH
59139: EMPTY
59140: LIST
59141: LIST
59142: PUSH
59143: EMPTY
59144: LIST
59145: LIST
59146: LIST
59147: PPUSH
59148: CALL_OW 72
59152: PUSH
59153: LD_INT 6
59155: MUL
59156: PLUS
59157: ST_TO_ADDR
// if bcount < tmp then
59158: LD_VAR 0 13
59162: PUSH
59163: LD_VAR 0 4
59167: LESS
59168: IFFALSE 59214
// for i = tmp downto bcount do
59170: LD_ADDR_VAR 0 3
59174: PUSH
59175: DOUBLE
59176: LD_VAR 0 4
59180: INC
59181: ST_TO_ADDR
59182: LD_VAR 0 13
59186: PUSH
59187: FOR_DOWNTO
59188: IFFALSE 59212
// tmp := Delete ( tmp , tmp ) ;
59190: LD_ADDR_VAR 0 4
59194: PUSH
59195: LD_VAR 0 4
59199: PPUSH
59200: LD_VAR 0 4
59204: PPUSH
59205: CALL_OW 3
59209: ST_TO_ADDR
59210: GO 59187
59212: POP
59213: POP
// result := [ tmp , 0 , 0 , p ] ;
59214: LD_ADDR_VAR 0 2
59218: PUSH
59219: LD_VAR 0 4
59223: PUSH
59224: LD_INT 0
59226: PUSH
59227: LD_INT 0
59229: PUSH
59230: LD_VAR 0 11
59234: PUSH
59235: EMPTY
59236: LIST
59237: LIST
59238: LIST
59239: LIST
59240: ST_TO_ADDR
// exit ;
59241: GO 61931
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59243: LD_EXP 52
59247: PUSH
59248: LD_VAR 0 1
59252: ARRAY
59253: PPUSH
59254: LD_INT 2
59256: PUSH
59257: LD_INT 30
59259: PUSH
59260: LD_INT 6
59262: PUSH
59263: EMPTY
59264: LIST
59265: LIST
59266: PUSH
59267: LD_INT 30
59269: PUSH
59270: LD_INT 7
59272: PUSH
59273: EMPTY
59274: LIST
59275: LIST
59276: PUSH
59277: LD_INT 30
59279: PUSH
59280: LD_INT 8
59282: PUSH
59283: EMPTY
59284: LIST
59285: LIST
59286: PUSH
59287: EMPTY
59288: LIST
59289: LIST
59290: LIST
59291: LIST
59292: PPUSH
59293: CALL_OW 72
59297: NOT
59298: PUSH
59299: LD_EXP 52
59303: PUSH
59304: LD_VAR 0 1
59308: ARRAY
59309: PPUSH
59310: LD_INT 30
59312: PUSH
59313: LD_INT 3
59315: PUSH
59316: EMPTY
59317: LIST
59318: LIST
59319: PPUSH
59320: CALL_OW 72
59324: NOT
59325: AND
59326: IFFALSE 59398
// begin if eng = tmp then
59328: LD_VAR 0 6
59332: PUSH
59333: LD_VAR 0 4
59337: EQUAL
59338: IFFALSE 59342
// exit ;
59340: GO 61931
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
59342: LD_ADDR_EXP 94
59346: PUSH
59347: LD_EXP 94
59351: PPUSH
59352: LD_VAR 0 1
59356: PPUSH
59357: LD_INT 1
59359: PPUSH
59360: CALL_OW 1
59364: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
59365: LD_ADDR_VAR 0 2
59369: PUSH
59370: LD_INT 0
59372: PUSH
59373: LD_VAR 0 4
59377: PUSH
59378: LD_VAR 0 6
59382: DIFF
59383: PUSH
59384: LD_INT 0
59386: PUSH
59387: LD_INT 0
59389: PUSH
59390: EMPTY
59391: LIST
59392: LIST
59393: LIST
59394: LIST
59395: ST_TO_ADDR
// exit ;
59396: GO 61931
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59398: LD_EXP 79
59402: PUSH
59403: LD_EXP 78
59407: PUSH
59408: LD_VAR 0 1
59412: ARRAY
59413: ARRAY
59414: PUSH
59415: LD_EXP 52
59419: PUSH
59420: LD_VAR 0 1
59424: ARRAY
59425: PPUSH
59426: LD_INT 2
59428: PUSH
59429: LD_INT 30
59431: PUSH
59432: LD_INT 6
59434: PUSH
59435: EMPTY
59436: LIST
59437: LIST
59438: PUSH
59439: LD_INT 30
59441: PUSH
59442: LD_INT 7
59444: PUSH
59445: EMPTY
59446: LIST
59447: LIST
59448: PUSH
59449: LD_INT 30
59451: PUSH
59452: LD_INT 8
59454: PUSH
59455: EMPTY
59456: LIST
59457: LIST
59458: PUSH
59459: EMPTY
59460: LIST
59461: LIST
59462: LIST
59463: LIST
59464: PPUSH
59465: CALL_OW 72
59469: AND
59470: PUSH
59471: LD_EXP 52
59475: PUSH
59476: LD_VAR 0 1
59480: ARRAY
59481: PPUSH
59482: LD_INT 30
59484: PUSH
59485: LD_INT 3
59487: PUSH
59488: EMPTY
59489: LIST
59490: LIST
59491: PPUSH
59492: CALL_OW 72
59496: NOT
59497: AND
59498: IFFALSE 59712
// begin if sci >= 6 then
59500: LD_VAR 0 8
59504: PUSH
59505: LD_INT 6
59507: GREATEREQUAL
59508: IFFALSE 59512
// exit ;
59510: GO 61931
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
59512: LD_ADDR_EXP 94
59516: PUSH
59517: LD_EXP 94
59521: PPUSH
59522: LD_VAR 0 1
59526: PPUSH
59527: LD_INT 2
59529: PPUSH
59530: CALL_OW 1
59534: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
59535: LD_ADDR_VAR 0 9
59539: PUSH
59540: LD_VAR 0 4
59544: PUSH
59545: LD_VAR 0 8
59549: DIFF
59550: PPUSH
59551: LD_INT 4
59553: PPUSH
59554: CALL 52064 0 2
59558: ST_TO_ADDR
// p := [ ] ;
59559: LD_ADDR_VAR 0 11
59563: PUSH
59564: EMPTY
59565: ST_TO_ADDR
// if sci < 6 and sort > 6 then
59566: LD_VAR 0 8
59570: PUSH
59571: LD_INT 6
59573: LESS
59574: PUSH
59575: LD_VAR 0 9
59579: PUSH
59580: LD_INT 6
59582: GREATER
59583: AND
59584: IFFALSE 59665
// begin for i = 1 to 6 - sci do
59586: LD_ADDR_VAR 0 3
59590: PUSH
59591: DOUBLE
59592: LD_INT 1
59594: DEC
59595: ST_TO_ADDR
59596: LD_INT 6
59598: PUSH
59599: LD_VAR 0 8
59603: MINUS
59604: PUSH
59605: FOR_TO
59606: IFFALSE 59661
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
59608: LD_ADDR_VAR 0 11
59612: PUSH
59613: LD_VAR 0 11
59617: PPUSH
59618: LD_VAR 0 11
59622: PUSH
59623: LD_INT 1
59625: PLUS
59626: PPUSH
59627: LD_VAR 0 9
59631: PUSH
59632: LD_INT 1
59634: ARRAY
59635: PPUSH
59636: CALL_OW 2
59640: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
59641: LD_ADDR_VAR 0 9
59645: PUSH
59646: LD_VAR 0 9
59650: PPUSH
59651: LD_INT 1
59653: PPUSH
59654: CALL_OW 3
59658: ST_TO_ADDR
// end ;
59659: GO 59605
59661: POP
59662: POP
// end else
59663: GO 59685
// if sort then
59665: LD_VAR 0 9
59669: IFFALSE 59685
// p := sort [ 1 ] ;
59671: LD_ADDR_VAR 0 11
59675: PUSH
59676: LD_VAR 0 9
59680: PUSH
59681: LD_INT 1
59683: ARRAY
59684: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
59685: LD_ADDR_VAR 0 2
59689: PUSH
59690: LD_INT 0
59692: PUSH
59693: LD_INT 0
59695: PUSH
59696: LD_INT 0
59698: PUSH
59699: LD_VAR 0 11
59703: PUSH
59704: EMPTY
59705: LIST
59706: LIST
59707: LIST
59708: LIST
59709: ST_TO_ADDR
// exit ;
59710: GO 61931
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59712: LD_EXP 79
59716: PUSH
59717: LD_EXP 78
59721: PUSH
59722: LD_VAR 0 1
59726: ARRAY
59727: ARRAY
59728: PUSH
59729: LD_EXP 52
59733: PUSH
59734: LD_VAR 0 1
59738: ARRAY
59739: PPUSH
59740: LD_INT 2
59742: PUSH
59743: LD_INT 30
59745: PUSH
59746: LD_INT 6
59748: PUSH
59749: EMPTY
59750: LIST
59751: LIST
59752: PUSH
59753: LD_INT 30
59755: PUSH
59756: LD_INT 7
59758: PUSH
59759: EMPTY
59760: LIST
59761: LIST
59762: PUSH
59763: LD_INT 30
59765: PUSH
59766: LD_INT 8
59768: PUSH
59769: EMPTY
59770: LIST
59771: LIST
59772: PUSH
59773: EMPTY
59774: LIST
59775: LIST
59776: LIST
59777: LIST
59778: PPUSH
59779: CALL_OW 72
59783: AND
59784: PUSH
59785: LD_EXP 52
59789: PUSH
59790: LD_VAR 0 1
59794: ARRAY
59795: PPUSH
59796: LD_INT 30
59798: PUSH
59799: LD_INT 3
59801: PUSH
59802: EMPTY
59803: LIST
59804: LIST
59805: PPUSH
59806: CALL_OW 72
59810: AND
59811: IFFALSE 60545
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
59813: LD_ADDR_EXP 94
59817: PUSH
59818: LD_EXP 94
59822: PPUSH
59823: LD_VAR 0 1
59827: PPUSH
59828: LD_INT 3
59830: PPUSH
59831: CALL_OW 1
59835: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59836: LD_ADDR_VAR 0 2
59840: PUSH
59841: LD_INT 0
59843: PUSH
59844: LD_INT 0
59846: PUSH
59847: LD_INT 0
59849: PUSH
59850: LD_INT 0
59852: PUSH
59853: EMPTY
59854: LIST
59855: LIST
59856: LIST
59857: LIST
59858: ST_TO_ADDR
// if not eng then
59859: LD_VAR 0 6
59863: NOT
59864: IFFALSE 59927
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
59866: LD_ADDR_VAR 0 11
59870: PUSH
59871: LD_VAR 0 4
59875: PPUSH
59876: LD_INT 2
59878: PPUSH
59879: CALL 52064 0 2
59883: PUSH
59884: LD_INT 1
59886: ARRAY
59887: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
59888: LD_ADDR_VAR 0 2
59892: PUSH
59893: LD_VAR 0 2
59897: PPUSH
59898: LD_INT 2
59900: PPUSH
59901: LD_VAR 0 11
59905: PPUSH
59906: CALL_OW 1
59910: ST_TO_ADDR
// tmp := tmp diff p ;
59911: LD_ADDR_VAR 0 4
59915: PUSH
59916: LD_VAR 0 4
59920: PUSH
59921: LD_VAR 0 11
59925: DIFF
59926: ST_TO_ADDR
// end ; if tmp and sci < 6 then
59927: LD_VAR 0 4
59931: PUSH
59932: LD_VAR 0 8
59936: PUSH
59937: LD_INT 6
59939: LESS
59940: AND
59941: IFFALSE 60129
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
59943: LD_ADDR_VAR 0 9
59947: PUSH
59948: LD_VAR 0 4
59952: PUSH
59953: LD_VAR 0 8
59957: PUSH
59958: LD_VAR 0 7
59962: UNION
59963: DIFF
59964: PPUSH
59965: LD_INT 4
59967: PPUSH
59968: CALL 52064 0 2
59972: ST_TO_ADDR
// p := [ ] ;
59973: LD_ADDR_VAR 0 11
59977: PUSH
59978: EMPTY
59979: ST_TO_ADDR
// if sort then
59980: LD_VAR 0 9
59984: IFFALSE 60100
// for i = 1 to 6 - sci do
59986: LD_ADDR_VAR 0 3
59990: PUSH
59991: DOUBLE
59992: LD_INT 1
59994: DEC
59995: ST_TO_ADDR
59996: LD_INT 6
59998: PUSH
59999: LD_VAR 0 8
60003: MINUS
60004: PUSH
60005: FOR_TO
60006: IFFALSE 60098
// begin if i = sort then
60008: LD_VAR 0 3
60012: PUSH
60013: LD_VAR 0 9
60017: EQUAL
60018: IFFALSE 60022
// break ;
60020: GO 60098
// if GetClass ( i ) = 4 then
60022: LD_VAR 0 3
60026: PPUSH
60027: CALL_OW 257
60031: PUSH
60032: LD_INT 4
60034: EQUAL
60035: IFFALSE 60039
// continue ;
60037: GO 60005
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60039: LD_ADDR_VAR 0 11
60043: PUSH
60044: LD_VAR 0 11
60048: PPUSH
60049: LD_VAR 0 11
60053: PUSH
60054: LD_INT 1
60056: PLUS
60057: PPUSH
60058: LD_VAR 0 9
60062: PUSH
60063: LD_VAR 0 3
60067: ARRAY
60068: PPUSH
60069: CALL_OW 2
60073: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60074: LD_ADDR_VAR 0 4
60078: PUSH
60079: LD_VAR 0 4
60083: PUSH
60084: LD_VAR 0 9
60088: PUSH
60089: LD_VAR 0 3
60093: ARRAY
60094: DIFF
60095: ST_TO_ADDR
// end ;
60096: GO 60005
60098: POP
60099: POP
// if p then
60100: LD_VAR 0 11
60104: IFFALSE 60129
// result := Replace ( result , 4 , p ) ;
60106: LD_ADDR_VAR 0 2
60110: PUSH
60111: LD_VAR 0 2
60115: PPUSH
60116: LD_INT 4
60118: PPUSH
60119: LD_VAR 0 11
60123: PPUSH
60124: CALL_OW 1
60128: ST_TO_ADDR
// end ; if tmp and mech < 6 then
60129: LD_VAR 0 4
60133: PUSH
60134: LD_VAR 0 7
60138: PUSH
60139: LD_INT 6
60141: LESS
60142: AND
60143: IFFALSE 60331
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
60145: LD_ADDR_VAR 0 9
60149: PUSH
60150: LD_VAR 0 4
60154: PUSH
60155: LD_VAR 0 8
60159: PUSH
60160: LD_VAR 0 7
60164: UNION
60165: DIFF
60166: PPUSH
60167: LD_INT 3
60169: PPUSH
60170: CALL 52064 0 2
60174: ST_TO_ADDR
// p := [ ] ;
60175: LD_ADDR_VAR 0 11
60179: PUSH
60180: EMPTY
60181: ST_TO_ADDR
// if sort then
60182: LD_VAR 0 9
60186: IFFALSE 60302
// for i = 1 to 6 - mech do
60188: LD_ADDR_VAR 0 3
60192: PUSH
60193: DOUBLE
60194: LD_INT 1
60196: DEC
60197: ST_TO_ADDR
60198: LD_INT 6
60200: PUSH
60201: LD_VAR 0 7
60205: MINUS
60206: PUSH
60207: FOR_TO
60208: IFFALSE 60300
// begin if i = sort then
60210: LD_VAR 0 3
60214: PUSH
60215: LD_VAR 0 9
60219: EQUAL
60220: IFFALSE 60224
// break ;
60222: GO 60300
// if GetClass ( i ) = 3 then
60224: LD_VAR 0 3
60228: PPUSH
60229: CALL_OW 257
60233: PUSH
60234: LD_INT 3
60236: EQUAL
60237: IFFALSE 60241
// continue ;
60239: GO 60207
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60241: LD_ADDR_VAR 0 11
60245: PUSH
60246: LD_VAR 0 11
60250: PPUSH
60251: LD_VAR 0 11
60255: PUSH
60256: LD_INT 1
60258: PLUS
60259: PPUSH
60260: LD_VAR 0 9
60264: PUSH
60265: LD_VAR 0 3
60269: ARRAY
60270: PPUSH
60271: CALL_OW 2
60275: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60276: LD_ADDR_VAR 0 4
60280: PUSH
60281: LD_VAR 0 4
60285: PUSH
60286: LD_VAR 0 9
60290: PUSH
60291: LD_VAR 0 3
60295: ARRAY
60296: DIFF
60297: ST_TO_ADDR
// end ;
60298: GO 60207
60300: POP
60301: POP
// if p then
60302: LD_VAR 0 11
60306: IFFALSE 60331
// result := Replace ( result , 3 , p ) ;
60308: LD_ADDR_VAR 0 2
60312: PUSH
60313: LD_VAR 0 2
60317: PPUSH
60318: LD_INT 3
60320: PPUSH
60321: LD_VAR 0 11
60325: PPUSH
60326: CALL_OW 1
60330: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
60331: LD_VAR 0 4
60335: PUSH
60336: LD_INT 6
60338: GREATER
60339: PUSH
60340: LD_VAR 0 6
60344: PUSH
60345: LD_INT 6
60347: LESS
60348: AND
60349: IFFALSE 60543
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
60351: LD_ADDR_VAR 0 9
60355: PUSH
60356: LD_VAR 0 4
60360: PUSH
60361: LD_VAR 0 8
60365: PUSH
60366: LD_VAR 0 7
60370: UNION
60371: PUSH
60372: LD_VAR 0 6
60376: UNION
60377: DIFF
60378: PPUSH
60379: LD_INT 2
60381: PPUSH
60382: CALL 52064 0 2
60386: ST_TO_ADDR
// p := [ ] ;
60387: LD_ADDR_VAR 0 11
60391: PUSH
60392: EMPTY
60393: ST_TO_ADDR
// if sort then
60394: LD_VAR 0 9
60398: IFFALSE 60514
// for i = 1 to 6 - eng do
60400: LD_ADDR_VAR 0 3
60404: PUSH
60405: DOUBLE
60406: LD_INT 1
60408: DEC
60409: ST_TO_ADDR
60410: LD_INT 6
60412: PUSH
60413: LD_VAR 0 6
60417: MINUS
60418: PUSH
60419: FOR_TO
60420: IFFALSE 60512
// begin if i = sort then
60422: LD_VAR 0 3
60426: PUSH
60427: LD_VAR 0 9
60431: EQUAL
60432: IFFALSE 60436
// break ;
60434: GO 60512
// if GetClass ( i ) = 2 then
60436: LD_VAR 0 3
60440: PPUSH
60441: CALL_OW 257
60445: PUSH
60446: LD_INT 2
60448: EQUAL
60449: IFFALSE 60453
// continue ;
60451: GO 60419
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60453: LD_ADDR_VAR 0 11
60457: PUSH
60458: LD_VAR 0 11
60462: PPUSH
60463: LD_VAR 0 11
60467: PUSH
60468: LD_INT 1
60470: PLUS
60471: PPUSH
60472: LD_VAR 0 9
60476: PUSH
60477: LD_VAR 0 3
60481: ARRAY
60482: PPUSH
60483: CALL_OW 2
60487: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60488: LD_ADDR_VAR 0 4
60492: PUSH
60493: LD_VAR 0 4
60497: PUSH
60498: LD_VAR 0 9
60502: PUSH
60503: LD_VAR 0 3
60507: ARRAY
60508: DIFF
60509: ST_TO_ADDR
// end ;
60510: GO 60419
60512: POP
60513: POP
// if p then
60514: LD_VAR 0 11
60518: IFFALSE 60543
// result := Replace ( result , 2 , p ) ;
60520: LD_ADDR_VAR 0 2
60524: PUSH
60525: LD_VAR 0 2
60529: PPUSH
60530: LD_INT 2
60532: PPUSH
60533: LD_VAR 0 11
60537: PPUSH
60538: CALL_OW 1
60542: ST_TO_ADDR
// end ; exit ;
60543: GO 61931
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
60545: LD_EXP 79
60549: PUSH
60550: LD_EXP 78
60554: PUSH
60555: LD_VAR 0 1
60559: ARRAY
60560: ARRAY
60561: NOT
60562: PUSH
60563: LD_EXP 52
60567: PUSH
60568: LD_VAR 0 1
60572: ARRAY
60573: PPUSH
60574: LD_INT 30
60576: PUSH
60577: LD_INT 3
60579: PUSH
60580: EMPTY
60581: LIST
60582: LIST
60583: PPUSH
60584: CALL_OW 72
60588: AND
60589: PUSH
60590: LD_EXP 57
60594: PUSH
60595: LD_VAR 0 1
60599: ARRAY
60600: AND
60601: IFFALSE 61209
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
60603: LD_ADDR_EXP 94
60607: PUSH
60608: LD_EXP 94
60612: PPUSH
60613: LD_VAR 0 1
60617: PPUSH
60618: LD_INT 5
60620: PPUSH
60621: CALL_OW 1
60625: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60626: LD_ADDR_VAR 0 2
60630: PUSH
60631: LD_INT 0
60633: PUSH
60634: LD_INT 0
60636: PUSH
60637: LD_INT 0
60639: PUSH
60640: LD_INT 0
60642: PUSH
60643: EMPTY
60644: LIST
60645: LIST
60646: LIST
60647: LIST
60648: ST_TO_ADDR
// if sci > 1 then
60649: LD_VAR 0 8
60653: PUSH
60654: LD_INT 1
60656: GREATER
60657: IFFALSE 60685
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
60659: LD_ADDR_VAR 0 4
60663: PUSH
60664: LD_VAR 0 4
60668: PUSH
60669: LD_VAR 0 8
60673: PUSH
60674: LD_VAR 0 8
60678: PUSH
60679: LD_INT 1
60681: ARRAY
60682: DIFF
60683: DIFF
60684: ST_TO_ADDR
// if tmp and not sci then
60685: LD_VAR 0 4
60689: PUSH
60690: LD_VAR 0 8
60694: NOT
60695: AND
60696: IFFALSE 60765
// begin sort := SortBySkill ( tmp , 4 ) ;
60698: LD_ADDR_VAR 0 9
60702: PUSH
60703: LD_VAR 0 4
60707: PPUSH
60708: LD_INT 4
60710: PPUSH
60711: CALL 52064 0 2
60715: ST_TO_ADDR
// if sort then
60716: LD_VAR 0 9
60720: IFFALSE 60736
// p := sort [ 1 ] ;
60722: LD_ADDR_VAR 0 11
60726: PUSH
60727: LD_VAR 0 9
60731: PUSH
60732: LD_INT 1
60734: ARRAY
60735: ST_TO_ADDR
// if p then
60736: LD_VAR 0 11
60740: IFFALSE 60765
// result := Replace ( result , 4 , p ) ;
60742: LD_ADDR_VAR 0 2
60746: PUSH
60747: LD_VAR 0 2
60751: PPUSH
60752: LD_INT 4
60754: PPUSH
60755: LD_VAR 0 11
60759: PPUSH
60760: CALL_OW 1
60764: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60765: LD_ADDR_VAR 0 4
60769: PUSH
60770: LD_VAR 0 4
60774: PUSH
60775: LD_VAR 0 7
60779: DIFF
60780: ST_TO_ADDR
// if tmp and mech < 6 then
60781: LD_VAR 0 4
60785: PUSH
60786: LD_VAR 0 7
60790: PUSH
60791: LD_INT 6
60793: LESS
60794: AND
60795: IFFALSE 60983
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
60797: LD_ADDR_VAR 0 9
60801: PUSH
60802: LD_VAR 0 4
60806: PUSH
60807: LD_VAR 0 8
60811: PUSH
60812: LD_VAR 0 7
60816: UNION
60817: DIFF
60818: PPUSH
60819: LD_INT 3
60821: PPUSH
60822: CALL 52064 0 2
60826: ST_TO_ADDR
// p := [ ] ;
60827: LD_ADDR_VAR 0 11
60831: PUSH
60832: EMPTY
60833: ST_TO_ADDR
// if sort then
60834: LD_VAR 0 9
60838: IFFALSE 60954
// for i = 1 to 6 - mech do
60840: LD_ADDR_VAR 0 3
60844: PUSH
60845: DOUBLE
60846: LD_INT 1
60848: DEC
60849: ST_TO_ADDR
60850: LD_INT 6
60852: PUSH
60853: LD_VAR 0 7
60857: MINUS
60858: PUSH
60859: FOR_TO
60860: IFFALSE 60952
// begin if i = sort then
60862: LD_VAR 0 3
60866: PUSH
60867: LD_VAR 0 9
60871: EQUAL
60872: IFFALSE 60876
// break ;
60874: GO 60952
// if GetClass ( i ) = 3 then
60876: LD_VAR 0 3
60880: PPUSH
60881: CALL_OW 257
60885: PUSH
60886: LD_INT 3
60888: EQUAL
60889: IFFALSE 60893
// continue ;
60891: GO 60859
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60893: LD_ADDR_VAR 0 11
60897: PUSH
60898: LD_VAR 0 11
60902: PPUSH
60903: LD_VAR 0 11
60907: PUSH
60908: LD_INT 1
60910: PLUS
60911: PPUSH
60912: LD_VAR 0 9
60916: PUSH
60917: LD_VAR 0 3
60921: ARRAY
60922: PPUSH
60923: CALL_OW 2
60927: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60928: LD_ADDR_VAR 0 4
60932: PUSH
60933: LD_VAR 0 4
60937: PUSH
60938: LD_VAR 0 9
60942: PUSH
60943: LD_VAR 0 3
60947: ARRAY
60948: DIFF
60949: ST_TO_ADDR
// end ;
60950: GO 60859
60952: POP
60953: POP
// if p then
60954: LD_VAR 0 11
60958: IFFALSE 60983
// result := Replace ( result , 3 , p ) ;
60960: LD_ADDR_VAR 0 2
60964: PUSH
60965: LD_VAR 0 2
60969: PPUSH
60970: LD_INT 3
60972: PPUSH
60973: LD_VAR 0 11
60977: PPUSH
60978: CALL_OW 1
60982: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60983: LD_ADDR_VAR 0 4
60987: PUSH
60988: LD_VAR 0 4
60992: PUSH
60993: LD_VAR 0 6
60997: DIFF
60998: ST_TO_ADDR
// if tmp and eng < 6 then
60999: LD_VAR 0 4
61003: PUSH
61004: LD_VAR 0 6
61008: PUSH
61009: LD_INT 6
61011: LESS
61012: AND
61013: IFFALSE 61207
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61015: LD_ADDR_VAR 0 9
61019: PUSH
61020: LD_VAR 0 4
61024: PUSH
61025: LD_VAR 0 8
61029: PUSH
61030: LD_VAR 0 7
61034: UNION
61035: PUSH
61036: LD_VAR 0 6
61040: UNION
61041: DIFF
61042: PPUSH
61043: LD_INT 2
61045: PPUSH
61046: CALL 52064 0 2
61050: ST_TO_ADDR
// p := [ ] ;
61051: LD_ADDR_VAR 0 11
61055: PUSH
61056: EMPTY
61057: ST_TO_ADDR
// if sort then
61058: LD_VAR 0 9
61062: IFFALSE 61178
// for i = 1 to 6 - eng do
61064: LD_ADDR_VAR 0 3
61068: PUSH
61069: DOUBLE
61070: LD_INT 1
61072: DEC
61073: ST_TO_ADDR
61074: LD_INT 6
61076: PUSH
61077: LD_VAR 0 6
61081: MINUS
61082: PUSH
61083: FOR_TO
61084: IFFALSE 61176
// begin if i = sort then
61086: LD_VAR 0 3
61090: PUSH
61091: LD_VAR 0 9
61095: EQUAL
61096: IFFALSE 61100
// break ;
61098: GO 61176
// if GetClass ( i ) = 2 then
61100: LD_VAR 0 3
61104: PPUSH
61105: CALL_OW 257
61109: PUSH
61110: LD_INT 2
61112: EQUAL
61113: IFFALSE 61117
// continue ;
61115: GO 61083
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61117: LD_ADDR_VAR 0 11
61121: PUSH
61122: LD_VAR 0 11
61126: PPUSH
61127: LD_VAR 0 11
61131: PUSH
61132: LD_INT 1
61134: PLUS
61135: PPUSH
61136: LD_VAR 0 9
61140: PUSH
61141: LD_VAR 0 3
61145: ARRAY
61146: PPUSH
61147: CALL_OW 2
61151: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61152: LD_ADDR_VAR 0 4
61156: PUSH
61157: LD_VAR 0 4
61161: PUSH
61162: LD_VAR 0 9
61166: PUSH
61167: LD_VAR 0 3
61171: ARRAY
61172: DIFF
61173: ST_TO_ADDR
// end ;
61174: GO 61083
61176: POP
61177: POP
// if p then
61178: LD_VAR 0 11
61182: IFFALSE 61207
// result := Replace ( result , 2 , p ) ;
61184: LD_ADDR_VAR 0 2
61188: PUSH
61189: LD_VAR 0 2
61193: PPUSH
61194: LD_INT 2
61196: PPUSH
61197: LD_VAR 0 11
61201: PPUSH
61202: CALL_OW 1
61206: ST_TO_ADDR
// end ; exit ;
61207: GO 61931
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
61209: LD_EXP 79
61213: PUSH
61214: LD_EXP 78
61218: PUSH
61219: LD_VAR 0 1
61223: ARRAY
61224: ARRAY
61225: NOT
61226: PUSH
61227: LD_EXP 52
61231: PUSH
61232: LD_VAR 0 1
61236: ARRAY
61237: PPUSH
61238: LD_INT 30
61240: PUSH
61241: LD_INT 3
61243: PUSH
61244: EMPTY
61245: LIST
61246: LIST
61247: PPUSH
61248: CALL_OW 72
61252: AND
61253: PUSH
61254: LD_EXP 57
61258: PUSH
61259: LD_VAR 0 1
61263: ARRAY
61264: NOT
61265: AND
61266: IFFALSE 61931
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
61268: LD_ADDR_EXP 94
61272: PUSH
61273: LD_EXP 94
61277: PPUSH
61278: LD_VAR 0 1
61282: PPUSH
61283: LD_INT 6
61285: PPUSH
61286: CALL_OW 1
61290: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61291: LD_ADDR_VAR 0 2
61295: PUSH
61296: LD_INT 0
61298: PUSH
61299: LD_INT 0
61301: PUSH
61302: LD_INT 0
61304: PUSH
61305: LD_INT 0
61307: PUSH
61308: EMPTY
61309: LIST
61310: LIST
61311: LIST
61312: LIST
61313: ST_TO_ADDR
// if sci >= 1 then
61314: LD_VAR 0 8
61318: PUSH
61319: LD_INT 1
61321: GREATEREQUAL
61322: IFFALSE 61344
// tmp := tmp diff sci [ 1 ] ;
61324: LD_ADDR_VAR 0 4
61328: PUSH
61329: LD_VAR 0 4
61333: PUSH
61334: LD_VAR 0 8
61338: PUSH
61339: LD_INT 1
61341: ARRAY
61342: DIFF
61343: ST_TO_ADDR
// if tmp and not sci then
61344: LD_VAR 0 4
61348: PUSH
61349: LD_VAR 0 8
61353: NOT
61354: AND
61355: IFFALSE 61424
// begin sort := SortBySkill ( tmp , 4 ) ;
61357: LD_ADDR_VAR 0 9
61361: PUSH
61362: LD_VAR 0 4
61366: PPUSH
61367: LD_INT 4
61369: PPUSH
61370: CALL 52064 0 2
61374: ST_TO_ADDR
// if sort then
61375: LD_VAR 0 9
61379: IFFALSE 61395
// p := sort [ 1 ] ;
61381: LD_ADDR_VAR 0 11
61385: PUSH
61386: LD_VAR 0 9
61390: PUSH
61391: LD_INT 1
61393: ARRAY
61394: ST_TO_ADDR
// if p then
61395: LD_VAR 0 11
61399: IFFALSE 61424
// result := Replace ( result , 4 , p ) ;
61401: LD_ADDR_VAR 0 2
61405: PUSH
61406: LD_VAR 0 2
61410: PPUSH
61411: LD_INT 4
61413: PPUSH
61414: LD_VAR 0 11
61418: PPUSH
61419: CALL_OW 1
61423: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61424: LD_ADDR_VAR 0 4
61428: PUSH
61429: LD_VAR 0 4
61433: PUSH
61434: LD_VAR 0 7
61438: DIFF
61439: ST_TO_ADDR
// if tmp and mech < 6 then
61440: LD_VAR 0 4
61444: PUSH
61445: LD_VAR 0 7
61449: PUSH
61450: LD_INT 6
61452: LESS
61453: AND
61454: IFFALSE 61636
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
61456: LD_ADDR_VAR 0 9
61460: PUSH
61461: LD_VAR 0 4
61465: PUSH
61466: LD_VAR 0 7
61470: DIFF
61471: PPUSH
61472: LD_INT 3
61474: PPUSH
61475: CALL 52064 0 2
61479: ST_TO_ADDR
// p := [ ] ;
61480: LD_ADDR_VAR 0 11
61484: PUSH
61485: EMPTY
61486: ST_TO_ADDR
// if sort then
61487: LD_VAR 0 9
61491: IFFALSE 61607
// for i = 1 to 6 - mech do
61493: LD_ADDR_VAR 0 3
61497: PUSH
61498: DOUBLE
61499: LD_INT 1
61501: DEC
61502: ST_TO_ADDR
61503: LD_INT 6
61505: PUSH
61506: LD_VAR 0 7
61510: MINUS
61511: PUSH
61512: FOR_TO
61513: IFFALSE 61605
// begin if i = sort then
61515: LD_VAR 0 3
61519: PUSH
61520: LD_VAR 0 9
61524: EQUAL
61525: IFFALSE 61529
// break ;
61527: GO 61605
// if GetClass ( i ) = 3 then
61529: LD_VAR 0 3
61533: PPUSH
61534: CALL_OW 257
61538: PUSH
61539: LD_INT 3
61541: EQUAL
61542: IFFALSE 61546
// continue ;
61544: GO 61512
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61546: LD_ADDR_VAR 0 11
61550: PUSH
61551: LD_VAR 0 11
61555: PPUSH
61556: LD_VAR 0 11
61560: PUSH
61561: LD_INT 1
61563: PLUS
61564: PPUSH
61565: LD_VAR 0 9
61569: PUSH
61570: LD_VAR 0 3
61574: ARRAY
61575: PPUSH
61576: CALL_OW 2
61580: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61581: LD_ADDR_VAR 0 4
61585: PUSH
61586: LD_VAR 0 4
61590: PUSH
61591: LD_VAR 0 9
61595: PUSH
61596: LD_VAR 0 3
61600: ARRAY
61601: DIFF
61602: ST_TO_ADDR
// end ;
61603: GO 61512
61605: POP
61606: POP
// if p then
61607: LD_VAR 0 11
61611: IFFALSE 61636
// result := Replace ( result , 3 , p ) ;
61613: LD_ADDR_VAR 0 2
61617: PUSH
61618: LD_VAR 0 2
61622: PPUSH
61623: LD_INT 3
61625: PPUSH
61626: LD_VAR 0 11
61630: PPUSH
61631: CALL_OW 1
61635: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61636: LD_ADDR_VAR 0 4
61640: PUSH
61641: LD_VAR 0 4
61645: PUSH
61646: LD_VAR 0 6
61650: DIFF
61651: ST_TO_ADDR
// if tmp and eng < 4 then
61652: LD_VAR 0 4
61656: PUSH
61657: LD_VAR 0 6
61661: PUSH
61662: LD_INT 4
61664: LESS
61665: AND
61666: IFFALSE 61856
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
61668: LD_ADDR_VAR 0 9
61672: PUSH
61673: LD_VAR 0 4
61677: PUSH
61678: LD_VAR 0 7
61682: PUSH
61683: LD_VAR 0 6
61687: UNION
61688: DIFF
61689: PPUSH
61690: LD_INT 2
61692: PPUSH
61693: CALL 52064 0 2
61697: ST_TO_ADDR
// p := [ ] ;
61698: LD_ADDR_VAR 0 11
61702: PUSH
61703: EMPTY
61704: ST_TO_ADDR
// if sort then
61705: LD_VAR 0 9
61709: IFFALSE 61825
// for i = 1 to 4 - eng do
61711: LD_ADDR_VAR 0 3
61715: PUSH
61716: DOUBLE
61717: LD_INT 1
61719: DEC
61720: ST_TO_ADDR
61721: LD_INT 4
61723: PUSH
61724: LD_VAR 0 6
61728: MINUS
61729: PUSH
61730: FOR_TO
61731: IFFALSE 61823
// begin if i = sort then
61733: LD_VAR 0 3
61737: PUSH
61738: LD_VAR 0 9
61742: EQUAL
61743: IFFALSE 61747
// break ;
61745: GO 61823
// if GetClass ( i ) = 2 then
61747: LD_VAR 0 3
61751: PPUSH
61752: CALL_OW 257
61756: PUSH
61757: LD_INT 2
61759: EQUAL
61760: IFFALSE 61764
// continue ;
61762: GO 61730
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61764: LD_ADDR_VAR 0 11
61768: PUSH
61769: LD_VAR 0 11
61773: PPUSH
61774: LD_VAR 0 11
61778: PUSH
61779: LD_INT 1
61781: PLUS
61782: PPUSH
61783: LD_VAR 0 9
61787: PUSH
61788: LD_VAR 0 3
61792: ARRAY
61793: PPUSH
61794: CALL_OW 2
61798: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61799: LD_ADDR_VAR 0 4
61803: PUSH
61804: LD_VAR 0 4
61808: PUSH
61809: LD_VAR 0 9
61813: PUSH
61814: LD_VAR 0 3
61818: ARRAY
61819: DIFF
61820: ST_TO_ADDR
// end ;
61821: GO 61730
61823: POP
61824: POP
// if p then
61825: LD_VAR 0 11
61829: IFFALSE 61854
// result := Replace ( result , 2 , p ) ;
61831: LD_ADDR_VAR 0 2
61835: PUSH
61836: LD_VAR 0 2
61840: PPUSH
61841: LD_INT 2
61843: PPUSH
61844: LD_VAR 0 11
61848: PPUSH
61849: CALL_OW 1
61853: ST_TO_ADDR
// end else
61854: GO 61900
// for i = eng downto 5 do
61856: LD_ADDR_VAR 0 3
61860: PUSH
61861: DOUBLE
61862: LD_VAR 0 6
61866: INC
61867: ST_TO_ADDR
61868: LD_INT 5
61870: PUSH
61871: FOR_DOWNTO
61872: IFFALSE 61898
// tmp := tmp union eng [ i ] ;
61874: LD_ADDR_VAR 0 4
61878: PUSH
61879: LD_VAR 0 4
61883: PUSH
61884: LD_VAR 0 6
61888: PUSH
61889: LD_VAR 0 3
61893: ARRAY
61894: UNION
61895: ST_TO_ADDR
61896: GO 61871
61898: POP
61899: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
61900: LD_ADDR_VAR 0 2
61904: PUSH
61905: LD_VAR 0 2
61909: PPUSH
61910: LD_INT 1
61912: PPUSH
61913: LD_VAR 0 4
61917: PUSH
61918: LD_VAR 0 5
61922: DIFF
61923: PPUSH
61924: CALL_OW 1
61928: ST_TO_ADDR
// exit ;
61929: GO 61931
// end ; end ;
61931: LD_VAR 0 2
61935: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
61936: LD_INT 0
61938: PPUSH
61939: PPUSH
61940: PPUSH
// if not mc_bases then
61941: LD_EXP 52
61945: NOT
61946: IFFALSE 61950
// exit ;
61948: GO 62056
// for i = 1 to mc_bases do
61950: LD_ADDR_VAR 0 2
61954: PUSH
61955: DOUBLE
61956: LD_INT 1
61958: DEC
61959: ST_TO_ADDR
61960: LD_EXP 52
61964: PUSH
61965: FOR_TO
61966: IFFALSE 62047
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
61968: LD_ADDR_VAR 0 3
61972: PUSH
61973: LD_EXP 52
61977: PUSH
61978: LD_VAR 0 2
61982: ARRAY
61983: PPUSH
61984: LD_INT 21
61986: PUSH
61987: LD_INT 3
61989: PUSH
61990: EMPTY
61991: LIST
61992: LIST
61993: PUSH
61994: LD_INT 3
61996: PUSH
61997: LD_INT 24
61999: PUSH
62000: LD_INT 1000
62002: PUSH
62003: EMPTY
62004: LIST
62005: LIST
62006: PUSH
62007: EMPTY
62008: LIST
62009: LIST
62010: PUSH
62011: EMPTY
62012: LIST
62013: LIST
62014: PPUSH
62015: CALL_OW 72
62019: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
62020: LD_ADDR_EXP 53
62024: PUSH
62025: LD_EXP 53
62029: PPUSH
62030: LD_VAR 0 2
62034: PPUSH
62035: LD_VAR 0 3
62039: PPUSH
62040: CALL_OW 1
62044: ST_TO_ADDR
// end ;
62045: GO 61965
62047: POP
62048: POP
// RaiseSailEvent ( 101 ) ;
62049: LD_INT 101
62051: PPUSH
62052: CALL_OW 427
// end ;
62056: LD_VAR 0 1
62060: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
62061: LD_INT 0
62063: PPUSH
62064: PPUSH
62065: PPUSH
62066: PPUSH
62067: PPUSH
62068: PPUSH
62069: PPUSH
// if not mc_bases then
62070: LD_EXP 52
62074: NOT
62075: IFFALSE 62079
// exit ;
62077: GO 62652
// for i = 1 to mc_bases do
62079: LD_ADDR_VAR 0 2
62083: PUSH
62084: DOUBLE
62085: LD_INT 1
62087: DEC
62088: ST_TO_ADDR
62089: LD_EXP 52
62093: PUSH
62094: FOR_TO
62095: IFFALSE 62643
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
62097: LD_ADDR_VAR 0 5
62101: PUSH
62102: LD_EXP 52
62106: PUSH
62107: LD_VAR 0 2
62111: ARRAY
62112: PUSH
62113: LD_EXP 81
62117: PUSH
62118: LD_VAR 0 2
62122: ARRAY
62123: UNION
62124: PPUSH
62125: LD_INT 21
62127: PUSH
62128: LD_INT 1
62130: PUSH
62131: EMPTY
62132: LIST
62133: LIST
62134: PUSH
62135: LD_INT 1
62137: PUSH
62138: LD_INT 3
62140: PUSH
62141: LD_INT 54
62143: PUSH
62144: EMPTY
62145: LIST
62146: PUSH
62147: EMPTY
62148: LIST
62149: LIST
62150: PUSH
62151: LD_INT 3
62153: PUSH
62154: LD_INT 24
62156: PUSH
62157: LD_INT 800
62159: PUSH
62160: EMPTY
62161: LIST
62162: LIST
62163: PUSH
62164: EMPTY
62165: LIST
62166: LIST
62167: PUSH
62168: EMPTY
62169: LIST
62170: LIST
62171: LIST
62172: PUSH
62173: EMPTY
62174: LIST
62175: LIST
62176: PPUSH
62177: CALL_OW 72
62181: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
62182: LD_ADDR_VAR 0 6
62186: PUSH
62187: LD_EXP 52
62191: PUSH
62192: LD_VAR 0 2
62196: ARRAY
62197: PPUSH
62198: LD_INT 21
62200: PUSH
62201: LD_INT 1
62203: PUSH
62204: EMPTY
62205: LIST
62206: LIST
62207: PUSH
62208: LD_INT 1
62210: PUSH
62211: LD_INT 3
62213: PUSH
62214: LD_INT 54
62216: PUSH
62217: EMPTY
62218: LIST
62219: PUSH
62220: EMPTY
62221: LIST
62222: LIST
62223: PUSH
62224: LD_INT 3
62226: PUSH
62227: LD_INT 24
62229: PUSH
62230: LD_INT 250
62232: PUSH
62233: EMPTY
62234: LIST
62235: LIST
62236: PUSH
62237: EMPTY
62238: LIST
62239: LIST
62240: PUSH
62241: EMPTY
62242: LIST
62243: LIST
62244: LIST
62245: PUSH
62246: EMPTY
62247: LIST
62248: LIST
62249: PPUSH
62250: CALL_OW 72
62254: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
62255: LD_ADDR_VAR 0 7
62259: PUSH
62260: LD_VAR 0 5
62264: PUSH
62265: LD_VAR 0 6
62269: DIFF
62270: ST_TO_ADDR
// if not need_heal_1 then
62271: LD_VAR 0 6
62275: NOT
62276: IFFALSE 62309
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
62278: LD_ADDR_EXP 55
62282: PUSH
62283: LD_EXP 55
62287: PPUSH
62288: LD_VAR 0 2
62292: PUSH
62293: LD_INT 1
62295: PUSH
62296: EMPTY
62297: LIST
62298: LIST
62299: PPUSH
62300: EMPTY
62301: PPUSH
62302: CALL 17816 0 3
62306: ST_TO_ADDR
62307: GO 62379
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
62309: LD_ADDR_EXP 55
62313: PUSH
62314: LD_EXP 55
62318: PPUSH
62319: LD_VAR 0 2
62323: PUSH
62324: LD_INT 1
62326: PUSH
62327: EMPTY
62328: LIST
62329: LIST
62330: PPUSH
62331: LD_EXP 55
62335: PUSH
62336: LD_VAR 0 2
62340: ARRAY
62341: PUSH
62342: LD_INT 1
62344: ARRAY
62345: PPUSH
62346: LD_INT 3
62348: PUSH
62349: LD_INT 24
62351: PUSH
62352: LD_INT 1000
62354: PUSH
62355: EMPTY
62356: LIST
62357: LIST
62358: PUSH
62359: EMPTY
62360: LIST
62361: LIST
62362: PPUSH
62363: CALL_OW 72
62367: PUSH
62368: LD_VAR 0 6
62372: UNION
62373: PPUSH
62374: CALL 17816 0 3
62378: ST_TO_ADDR
// if not need_heal_2 then
62379: LD_VAR 0 7
62383: NOT
62384: IFFALSE 62417
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
62386: LD_ADDR_EXP 55
62390: PUSH
62391: LD_EXP 55
62395: PPUSH
62396: LD_VAR 0 2
62400: PUSH
62401: LD_INT 2
62403: PUSH
62404: EMPTY
62405: LIST
62406: LIST
62407: PPUSH
62408: EMPTY
62409: PPUSH
62410: CALL 17816 0 3
62414: ST_TO_ADDR
62415: GO 62449
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
62417: LD_ADDR_EXP 55
62421: PUSH
62422: LD_EXP 55
62426: PPUSH
62427: LD_VAR 0 2
62431: PUSH
62432: LD_INT 2
62434: PUSH
62435: EMPTY
62436: LIST
62437: LIST
62438: PPUSH
62439: LD_VAR 0 7
62443: PPUSH
62444: CALL 17816 0 3
62448: ST_TO_ADDR
// if need_heal_2 then
62449: LD_VAR 0 7
62453: IFFALSE 62625
// for j in need_heal_2 do
62455: LD_ADDR_VAR 0 3
62459: PUSH
62460: LD_VAR 0 7
62464: PUSH
62465: FOR_IN
62466: IFFALSE 62623
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
62468: LD_ADDR_VAR 0 5
62472: PUSH
62473: LD_EXP 52
62477: PUSH
62478: LD_VAR 0 2
62482: ARRAY
62483: PPUSH
62484: LD_INT 2
62486: PUSH
62487: LD_INT 30
62489: PUSH
62490: LD_INT 6
62492: PUSH
62493: EMPTY
62494: LIST
62495: LIST
62496: PUSH
62497: LD_INT 30
62499: PUSH
62500: LD_INT 7
62502: PUSH
62503: EMPTY
62504: LIST
62505: LIST
62506: PUSH
62507: LD_INT 30
62509: PUSH
62510: LD_INT 8
62512: PUSH
62513: EMPTY
62514: LIST
62515: LIST
62516: PUSH
62517: LD_INT 30
62519: PUSH
62520: LD_INT 0
62522: PUSH
62523: EMPTY
62524: LIST
62525: LIST
62526: PUSH
62527: LD_INT 30
62529: PUSH
62530: LD_INT 1
62532: PUSH
62533: EMPTY
62534: LIST
62535: LIST
62536: PUSH
62537: LD_INT 25
62539: PUSH
62540: LD_INT 4
62542: PUSH
62543: EMPTY
62544: LIST
62545: LIST
62546: PUSH
62547: EMPTY
62548: LIST
62549: LIST
62550: LIST
62551: LIST
62552: LIST
62553: LIST
62554: LIST
62555: PPUSH
62556: CALL_OW 72
62560: ST_TO_ADDR
// if tmp then
62561: LD_VAR 0 5
62565: IFFALSE 62621
// begin k := NearestUnitToUnit ( tmp , j ) ;
62567: LD_ADDR_VAR 0 4
62571: PUSH
62572: LD_VAR 0 5
62576: PPUSH
62577: LD_VAR 0 3
62581: PPUSH
62582: CALL_OW 74
62586: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
62587: LD_VAR 0 3
62591: PPUSH
62592: LD_VAR 0 4
62596: PPUSH
62597: CALL_OW 296
62601: PUSH
62602: LD_INT 7
62604: GREATER
62605: IFFALSE 62621
// ComMoveUnit ( j , k ) ;
62607: LD_VAR 0 3
62611: PPUSH
62612: LD_VAR 0 4
62616: PPUSH
62617: CALL_OW 112
// end ; end ;
62621: GO 62465
62623: POP
62624: POP
// if not need_heal_1 and not need_heal_2 then
62625: LD_VAR 0 6
62629: NOT
62630: PUSH
62631: LD_VAR 0 7
62635: NOT
62636: AND
62637: IFFALSE 62641
// continue ;
62639: GO 62094
// end ;
62641: GO 62094
62643: POP
62644: POP
// RaiseSailEvent ( 102 ) ;
62645: LD_INT 102
62647: PPUSH
62648: CALL_OW 427
// end ;
62652: LD_VAR 0 1
62656: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
62657: LD_INT 0
62659: PPUSH
62660: PPUSH
62661: PPUSH
62662: PPUSH
62663: PPUSH
// if not mc_bases then
62664: LD_EXP 52
62668: NOT
62669: IFFALSE 62673
// exit ;
62671: GO 63058
// for i = 1 to mc_bases do
62673: LD_ADDR_VAR 0 2
62677: PUSH
62678: DOUBLE
62679: LD_INT 1
62681: DEC
62682: ST_TO_ADDR
62683: LD_EXP 52
62687: PUSH
62688: FOR_TO
62689: IFFALSE 63056
// begin if not mc_building_need_repair [ i ] then
62691: LD_EXP 53
62695: PUSH
62696: LD_VAR 0 2
62700: ARRAY
62701: NOT
62702: IFFALSE 62740
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
62704: LD_ADDR_EXP 54
62708: PUSH
62709: LD_EXP 54
62713: PPUSH
62714: LD_VAR 0 2
62718: PPUSH
62719: EMPTY
62720: PPUSH
62721: CALL_OW 1
62725: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
62726: LD_VAR 0 2
62730: PPUSH
62731: LD_INT 101
62733: PPUSH
62734: CALL 57778 0 2
// continue ;
62738: GO 62688
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
62740: LD_ADDR_EXP 58
62744: PUSH
62745: LD_EXP 58
62749: PPUSH
62750: LD_VAR 0 2
62754: PPUSH
62755: EMPTY
62756: PPUSH
62757: CALL_OW 1
62761: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62762: LD_VAR 0 2
62766: PPUSH
62767: LD_INT 103
62769: PPUSH
62770: CALL 57778 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
62774: LD_ADDR_VAR 0 5
62778: PUSH
62779: LD_EXP 52
62783: PUSH
62784: LD_VAR 0 2
62788: ARRAY
62789: PUSH
62790: LD_EXP 81
62794: PUSH
62795: LD_VAR 0 2
62799: ARRAY
62800: UNION
62801: PPUSH
62802: LD_INT 2
62804: PUSH
62805: LD_INT 25
62807: PUSH
62808: LD_INT 2
62810: PUSH
62811: EMPTY
62812: LIST
62813: LIST
62814: PUSH
62815: LD_INT 25
62817: PUSH
62818: LD_INT 16
62820: PUSH
62821: EMPTY
62822: LIST
62823: LIST
62824: PUSH
62825: EMPTY
62826: LIST
62827: LIST
62828: LIST
62829: PUSH
62830: EMPTY
62831: LIST
62832: PPUSH
62833: CALL_OW 72
62837: ST_TO_ADDR
// if not tmp then
62838: LD_VAR 0 5
62842: NOT
62843: IFFALSE 62847
// continue ;
62845: GO 62688
// for j in tmp do
62847: LD_ADDR_VAR 0 3
62851: PUSH
62852: LD_VAR 0 5
62856: PUSH
62857: FOR_IN
62858: IFFALSE 63052
// begin if mc_need_heal [ i ] then
62860: LD_EXP 55
62864: PUSH
62865: LD_VAR 0 2
62869: ARRAY
62870: IFFALSE 62918
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
62872: LD_VAR 0 3
62876: PUSH
62877: LD_EXP 55
62881: PUSH
62882: LD_VAR 0 2
62886: ARRAY
62887: PUSH
62888: LD_INT 1
62890: ARRAY
62891: IN
62892: PUSH
62893: LD_VAR 0 3
62897: PUSH
62898: LD_EXP 55
62902: PUSH
62903: LD_VAR 0 2
62907: ARRAY
62908: PUSH
62909: LD_INT 2
62911: ARRAY
62912: IN
62913: OR
62914: IFFALSE 62918
// continue ;
62916: GO 62857
// if IsInUnit ( j ) then
62918: LD_VAR 0 3
62922: PPUSH
62923: CALL_OW 310
62927: IFFALSE 62938
// ComExitBuilding ( j ) ;
62929: LD_VAR 0 3
62933: PPUSH
62934: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
62938: LD_VAR 0 3
62942: PUSH
62943: LD_EXP 54
62947: PUSH
62948: LD_VAR 0 2
62952: ARRAY
62953: IN
62954: NOT
62955: IFFALSE 63013
// begin SetTag ( j , 101 ) ;
62957: LD_VAR 0 3
62961: PPUSH
62962: LD_INT 101
62964: PPUSH
62965: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
62969: LD_ADDR_EXP 54
62973: PUSH
62974: LD_EXP 54
62978: PPUSH
62979: LD_VAR 0 2
62983: PUSH
62984: LD_EXP 54
62988: PUSH
62989: LD_VAR 0 2
62993: ARRAY
62994: PUSH
62995: LD_INT 1
62997: PLUS
62998: PUSH
62999: EMPTY
63000: LIST
63001: LIST
63002: PPUSH
63003: LD_VAR 0 3
63007: PPUSH
63008: CALL 17816 0 3
63012: ST_TO_ADDR
// end ; wait ( 1 ) ;
63013: LD_INT 1
63015: PPUSH
63016: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
63020: LD_VAR 0 3
63024: PPUSH
63025: LD_EXP 53
63029: PUSH
63030: LD_VAR 0 2
63034: ARRAY
63035: PPUSH
63036: LD_VAR 0 3
63040: PPUSH
63041: CALL_OW 74
63045: PPUSH
63046: CALL_OW 130
// end ;
63050: GO 62857
63052: POP
63053: POP
// end ;
63054: GO 62688
63056: POP
63057: POP
// end ;
63058: LD_VAR 0 1
63062: RET
// export function MC_Heal ; var i , j , tmp ; begin
63063: LD_INT 0
63065: PPUSH
63066: PPUSH
63067: PPUSH
63068: PPUSH
// if not mc_bases then
63069: LD_EXP 52
63073: NOT
63074: IFFALSE 63078
// exit ;
63076: GO 63480
// for i = 1 to mc_bases do
63078: LD_ADDR_VAR 0 2
63082: PUSH
63083: DOUBLE
63084: LD_INT 1
63086: DEC
63087: ST_TO_ADDR
63088: LD_EXP 52
63092: PUSH
63093: FOR_TO
63094: IFFALSE 63478
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
63096: LD_EXP 55
63100: PUSH
63101: LD_VAR 0 2
63105: ARRAY
63106: PUSH
63107: LD_INT 1
63109: ARRAY
63110: NOT
63111: PUSH
63112: LD_EXP 55
63116: PUSH
63117: LD_VAR 0 2
63121: ARRAY
63122: PUSH
63123: LD_INT 2
63125: ARRAY
63126: NOT
63127: AND
63128: IFFALSE 63166
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
63130: LD_ADDR_EXP 56
63134: PUSH
63135: LD_EXP 56
63139: PPUSH
63140: LD_VAR 0 2
63144: PPUSH
63145: EMPTY
63146: PPUSH
63147: CALL_OW 1
63151: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
63152: LD_VAR 0 2
63156: PPUSH
63157: LD_INT 102
63159: PPUSH
63160: CALL 57778 0 2
// continue ;
63164: GO 63093
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
63166: LD_ADDR_VAR 0 4
63170: PUSH
63171: LD_EXP 52
63175: PUSH
63176: LD_VAR 0 2
63180: ARRAY
63181: PPUSH
63182: LD_INT 25
63184: PUSH
63185: LD_INT 4
63187: PUSH
63188: EMPTY
63189: LIST
63190: LIST
63191: PPUSH
63192: CALL_OW 72
63196: ST_TO_ADDR
// if not tmp then
63197: LD_VAR 0 4
63201: NOT
63202: IFFALSE 63206
// continue ;
63204: GO 63093
// if mc_taming [ i ] then
63206: LD_EXP 83
63210: PUSH
63211: LD_VAR 0 2
63215: ARRAY
63216: IFFALSE 63240
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63218: LD_ADDR_EXP 83
63222: PUSH
63223: LD_EXP 83
63227: PPUSH
63228: LD_VAR 0 2
63232: PPUSH
63233: EMPTY
63234: PPUSH
63235: CALL_OW 1
63239: ST_TO_ADDR
// for j in tmp do
63240: LD_ADDR_VAR 0 3
63244: PUSH
63245: LD_VAR 0 4
63249: PUSH
63250: FOR_IN
63251: IFFALSE 63474
// begin if IsInUnit ( j ) then
63253: LD_VAR 0 3
63257: PPUSH
63258: CALL_OW 310
63262: IFFALSE 63273
// ComExitBuilding ( j ) ;
63264: LD_VAR 0 3
63268: PPUSH
63269: CALL_OW 122
// if not j in mc_healers [ i ] then
63273: LD_VAR 0 3
63277: PUSH
63278: LD_EXP 56
63282: PUSH
63283: LD_VAR 0 2
63287: ARRAY
63288: IN
63289: NOT
63290: IFFALSE 63336
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
63292: LD_ADDR_EXP 56
63296: PUSH
63297: LD_EXP 56
63301: PPUSH
63302: LD_VAR 0 2
63306: PUSH
63307: LD_EXP 56
63311: PUSH
63312: LD_VAR 0 2
63316: ARRAY
63317: PUSH
63318: LD_INT 1
63320: PLUS
63321: PUSH
63322: EMPTY
63323: LIST
63324: LIST
63325: PPUSH
63326: LD_VAR 0 3
63330: PPUSH
63331: CALL 17816 0 3
63335: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
63336: LD_VAR 0 3
63340: PPUSH
63341: CALL_OW 110
63345: PUSH
63346: LD_INT 102
63348: NONEQUAL
63349: IFFALSE 63363
// SetTag ( j , 102 ) ;
63351: LD_VAR 0 3
63355: PPUSH
63356: LD_INT 102
63358: PPUSH
63359: CALL_OW 109
// Wait ( 3 ) ;
63363: LD_INT 3
63365: PPUSH
63366: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
63370: LD_EXP 55
63374: PUSH
63375: LD_VAR 0 2
63379: ARRAY
63380: PUSH
63381: LD_INT 1
63383: ARRAY
63384: IFFALSE 63416
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
63386: LD_VAR 0 3
63390: PPUSH
63391: LD_EXP 55
63395: PUSH
63396: LD_VAR 0 2
63400: ARRAY
63401: PUSH
63402: LD_INT 1
63404: ARRAY
63405: PUSH
63406: LD_INT 1
63408: ARRAY
63409: PPUSH
63410: CALL_OW 128
63414: GO 63472
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
63416: LD_VAR 0 3
63420: PPUSH
63421: CALL_OW 314
63425: NOT
63426: PUSH
63427: LD_EXP 55
63431: PUSH
63432: LD_VAR 0 2
63436: ARRAY
63437: PUSH
63438: LD_INT 2
63440: ARRAY
63441: AND
63442: IFFALSE 63472
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
63444: LD_VAR 0 3
63448: PPUSH
63449: LD_EXP 55
63453: PUSH
63454: LD_VAR 0 2
63458: ARRAY
63459: PUSH
63460: LD_INT 2
63462: ARRAY
63463: PUSH
63464: LD_INT 1
63466: ARRAY
63467: PPUSH
63468: CALL_OW 128
// end ;
63472: GO 63250
63474: POP
63475: POP
// end ;
63476: GO 63093
63478: POP
63479: POP
// end ;
63480: LD_VAR 0 1
63484: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
63485: LD_INT 0
63487: PPUSH
63488: PPUSH
63489: PPUSH
63490: PPUSH
63491: PPUSH
// if not mc_bases then
63492: LD_EXP 52
63496: NOT
63497: IFFALSE 63501
// exit ;
63499: GO 64644
// for i = 1 to mc_bases do
63501: LD_ADDR_VAR 0 2
63505: PUSH
63506: DOUBLE
63507: LD_INT 1
63509: DEC
63510: ST_TO_ADDR
63511: LD_EXP 52
63515: PUSH
63516: FOR_TO
63517: IFFALSE 64642
// begin if mc_scan [ i ] then
63519: LD_EXP 75
63523: PUSH
63524: LD_VAR 0 2
63528: ARRAY
63529: IFFALSE 63533
// continue ;
63531: GO 63516
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
63533: LD_EXP 57
63537: PUSH
63538: LD_VAR 0 2
63542: ARRAY
63543: NOT
63544: PUSH
63545: LD_EXP 59
63549: PUSH
63550: LD_VAR 0 2
63554: ARRAY
63555: NOT
63556: AND
63557: PUSH
63558: LD_EXP 58
63562: PUSH
63563: LD_VAR 0 2
63567: ARRAY
63568: AND
63569: IFFALSE 63607
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
63571: LD_ADDR_EXP 58
63575: PUSH
63576: LD_EXP 58
63580: PPUSH
63581: LD_VAR 0 2
63585: PPUSH
63586: EMPTY
63587: PPUSH
63588: CALL_OW 1
63592: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63593: LD_VAR 0 2
63597: PPUSH
63598: LD_INT 103
63600: PPUSH
63601: CALL 57778 0 2
// continue ;
63605: GO 63516
// end ; if mc_construct_list [ i ] then
63607: LD_EXP 59
63611: PUSH
63612: LD_VAR 0 2
63616: ARRAY
63617: IFFALSE 63837
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63619: LD_ADDR_VAR 0 4
63623: PUSH
63624: LD_EXP 52
63628: PUSH
63629: LD_VAR 0 2
63633: ARRAY
63634: PPUSH
63635: LD_INT 25
63637: PUSH
63638: LD_INT 2
63640: PUSH
63641: EMPTY
63642: LIST
63643: LIST
63644: PPUSH
63645: CALL_OW 72
63649: PUSH
63650: LD_EXP 54
63654: PUSH
63655: LD_VAR 0 2
63659: ARRAY
63660: DIFF
63661: ST_TO_ADDR
// if not tmp then
63662: LD_VAR 0 4
63666: NOT
63667: IFFALSE 63671
// continue ;
63669: GO 63516
// for j in tmp do
63671: LD_ADDR_VAR 0 3
63675: PUSH
63676: LD_VAR 0 4
63680: PUSH
63681: FOR_IN
63682: IFFALSE 63833
// begin if not mc_builders [ i ] then
63684: LD_EXP 58
63688: PUSH
63689: LD_VAR 0 2
63693: ARRAY
63694: NOT
63695: IFFALSE 63753
// begin SetTag ( j , 103 ) ;
63697: LD_VAR 0 3
63701: PPUSH
63702: LD_INT 103
63704: PPUSH
63705: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63709: LD_ADDR_EXP 58
63713: PUSH
63714: LD_EXP 58
63718: PPUSH
63719: LD_VAR 0 2
63723: PUSH
63724: LD_EXP 58
63728: PUSH
63729: LD_VAR 0 2
63733: ARRAY
63734: PUSH
63735: LD_INT 1
63737: PLUS
63738: PUSH
63739: EMPTY
63740: LIST
63741: LIST
63742: PPUSH
63743: LD_VAR 0 3
63747: PPUSH
63748: CALL 17816 0 3
63752: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63753: LD_VAR 0 3
63757: PPUSH
63758: CALL_OW 310
63762: IFFALSE 63773
// ComExitBuilding ( j ) ;
63764: LD_VAR 0 3
63768: PPUSH
63769: CALL_OW 122
// wait ( 3 ) ;
63773: LD_INT 3
63775: PPUSH
63776: CALL_OW 67
// if not mc_construct_list [ i ] then
63780: LD_EXP 59
63784: PUSH
63785: LD_VAR 0 2
63789: ARRAY
63790: NOT
63791: IFFALSE 63795
// break ;
63793: GO 63833
// if not HasTask ( j ) then
63795: LD_VAR 0 3
63799: PPUSH
63800: CALL_OW 314
63804: NOT
63805: IFFALSE 63831
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
63807: LD_VAR 0 3
63811: PPUSH
63812: LD_EXP 59
63816: PUSH
63817: LD_VAR 0 2
63821: ARRAY
63822: PUSH
63823: LD_INT 1
63825: ARRAY
63826: PPUSH
63827: CALL 20667 0 2
// end ;
63831: GO 63681
63833: POP
63834: POP
// end else
63835: GO 64640
// if mc_build_list [ i ] then
63837: LD_EXP 57
63841: PUSH
63842: LD_VAR 0 2
63846: ARRAY
63847: IFFALSE 64640
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63849: LD_ADDR_VAR 0 5
63853: PUSH
63854: LD_EXP 52
63858: PUSH
63859: LD_VAR 0 2
63863: ARRAY
63864: PPUSH
63865: LD_INT 2
63867: PUSH
63868: LD_INT 30
63870: PUSH
63871: LD_INT 0
63873: PUSH
63874: EMPTY
63875: LIST
63876: LIST
63877: PUSH
63878: LD_INT 30
63880: PUSH
63881: LD_INT 1
63883: PUSH
63884: EMPTY
63885: LIST
63886: LIST
63887: PUSH
63888: EMPTY
63889: LIST
63890: LIST
63891: LIST
63892: PPUSH
63893: CALL_OW 72
63897: ST_TO_ADDR
// if depot then
63898: LD_VAR 0 5
63902: IFFALSE 63920
// depot := depot [ 1 ] else
63904: LD_ADDR_VAR 0 5
63908: PUSH
63909: LD_VAR 0 5
63913: PUSH
63914: LD_INT 1
63916: ARRAY
63917: ST_TO_ADDR
63918: GO 63928
// depot := 0 ;
63920: LD_ADDR_VAR 0 5
63924: PUSH
63925: LD_INT 0
63927: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
63928: LD_EXP 57
63932: PUSH
63933: LD_VAR 0 2
63937: ARRAY
63938: PUSH
63939: LD_INT 1
63941: ARRAY
63942: PUSH
63943: LD_INT 1
63945: ARRAY
63946: PPUSH
63947: CALL 20497 0 1
63951: PUSH
63952: LD_EXP 52
63956: PUSH
63957: LD_VAR 0 2
63961: ARRAY
63962: PPUSH
63963: LD_INT 2
63965: PUSH
63966: LD_INT 30
63968: PUSH
63969: LD_INT 2
63971: PUSH
63972: EMPTY
63973: LIST
63974: LIST
63975: PUSH
63976: LD_INT 30
63978: PUSH
63979: LD_INT 3
63981: PUSH
63982: EMPTY
63983: LIST
63984: LIST
63985: PUSH
63986: EMPTY
63987: LIST
63988: LIST
63989: LIST
63990: PPUSH
63991: CALL_OW 72
63995: NOT
63996: AND
63997: IFFALSE 64102
// begin for j = 1 to mc_build_list [ i ] do
63999: LD_ADDR_VAR 0 3
64003: PUSH
64004: DOUBLE
64005: LD_INT 1
64007: DEC
64008: ST_TO_ADDR
64009: LD_EXP 57
64013: PUSH
64014: LD_VAR 0 2
64018: ARRAY
64019: PUSH
64020: FOR_TO
64021: IFFALSE 64100
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
64023: LD_EXP 57
64027: PUSH
64028: LD_VAR 0 2
64032: ARRAY
64033: PUSH
64034: LD_VAR 0 3
64038: ARRAY
64039: PUSH
64040: LD_INT 1
64042: ARRAY
64043: PUSH
64044: LD_INT 2
64046: EQUAL
64047: IFFALSE 64098
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
64049: LD_ADDR_EXP 57
64053: PUSH
64054: LD_EXP 57
64058: PPUSH
64059: LD_VAR 0 2
64063: PPUSH
64064: LD_EXP 57
64068: PUSH
64069: LD_VAR 0 2
64073: ARRAY
64074: PPUSH
64075: LD_VAR 0 3
64079: PPUSH
64080: LD_INT 1
64082: PPUSH
64083: LD_INT 0
64085: PPUSH
64086: CALL 17234 0 4
64090: PPUSH
64091: CALL_OW 1
64095: ST_TO_ADDR
// break ;
64096: GO 64100
// end ;
64098: GO 64020
64100: POP
64101: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
64102: LD_EXP 57
64106: PUSH
64107: LD_VAR 0 2
64111: ARRAY
64112: PUSH
64113: LD_INT 1
64115: ARRAY
64116: PUSH
64117: LD_INT 1
64119: ARRAY
64120: PUSH
64121: LD_INT 0
64123: EQUAL
64124: PUSH
64125: LD_VAR 0 5
64129: PUSH
64130: LD_VAR 0 5
64134: PPUSH
64135: LD_EXP 57
64139: PUSH
64140: LD_VAR 0 2
64144: ARRAY
64145: PUSH
64146: LD_INT 1
64148: ARRAY
64149: PUSH
64150: LD_INT 1
64152: ARRAY
64153: PPUSH
64154: LD_EXP 57
64158: PUSH
64159: LD_VAR 0 2
64163: ARRAY
64164: PUSH
64165: LD_INT 1
64167: ARRAY
64168: PUSH
64169: LD_INT 2
64171: ARRAY
64172: PPUSH
64173: LD_EXP 57
64177: PUSH
64178: LD_VAR 0 2
64182: ARRAY
64183: PUSH
64184: LD_INT 1
64186: ARRAY
64187: PUSH
64188: LD_INT 3
64190: ARRAY
64191: PPUSH
64192: LD_EXP 57
64196: PUSH
64197: LD_VAR 0 2
64201: ARRAY
64202: PUSH
64203: LD_INT 1
64205: ARRAY
64206: PUSH
64207: LD_INT 4
64209: ARRAY
64210: PPUSH
64211: CALL 25231 0 5
64215: AND
64216: OR
64217: IFFALSE 64498
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64219: LD_ADDR_VAR 0 4
64223: PUSH
64224: LD_EXP 52
64228: PUSH
64229: LD_VAR 0 2
64233: ARRAY
64234: PPUSH
64235: LD_INT 25
64237: PUSH
64238: LD_INT 2
64240: PUSH
64241: EMPTY
64242: LIST
64243: LIST
64244: PPUSH
64245: CALL_OW 72
64249: PUSH
64250: LD_EXP 54
64254: PUSH
64255: LD_VAR 0 2
64259: ARRAY
64260: DIFF
64261: ST_TO_ADDR
// if not tmp then
64262: LD_VAR 0 4
64266: NOT
64267: IFFALSE 64271
// continue ;
64269: GO 63516
// for j in tmp do
64271: LD_ADDR_VAR 0 3
64275: PUSH
64276: LD_VAR 0 4
64280: PUSH
64281: FOR_IN
64282: IFFALSE 64494
// begin if not mc_builders [ i ] then
64284: LD_EXP 58
64288: PUSH
64289: LD_VAR 0 2
64293: ARRAY
64294: NOT
64295: IFFALSE 64353
// begin SetTag ( j , 103 ) ;
64297: LD_VAR 0 3
64301: PPUSH
64302: LD_INT 103
64304: PPUSH
64305: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64309: LD_ADDR_EXP 58
64313: PUSH
64314: LD_EXP 58
64318: PPUSH
64319: LD_VAR 0 2
64323: PUSH
64324: LD_EXP 58
64328: PUSH
64329: LD_VAR 0 2
64333: ARRAY
64334: PUSH
64335: LD_INT 1
64337: PLUS
64338: PUSH
64339: EMPTY
64340: LIST
64341: LIST
64342: PPUSH
64343: LD_VAR 0 3
64347: PPUSH
64348: CALL 17816 0 3
64352: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64353: LD_VAR 0 3
64357: PPUSH
64358: CALL_OW 310
64362: IFFALSE 64373
// ComExitBuilding ( j ) ;
64364: LD_VAR 0 3
64368: PPUSH
64369: CALL_OW 122
// wait ( 3 ) ;
64373: LD_INT 3
64375: PPUSH
64376: CALL_OW 67
// if not mc_build_list [ i ] then
64380: LD_EXP 57
64384: PUSH
64385: LD_VAR 0 2
64389: ARRAY
64390: NOT
64391: IFFALSE 64395
// break ;
64393: GO 64494
// if not HasTask ( j ) then
64395: LD_VAR 0 3
64399: PPUSH
64400: CALL_OW 314
64404: NOT
64405: IFFALSE 64492
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
64407: LD_VAR 0 3
64411: PPUSH
64412: LD_EXP 57
64416: PUSH
64417: LD_VAR 0 2
64421: ARRAY
64422: PUSH
64423: LD_INT 1
64425: ARRAY
64426: PUSH
64427: LD_INT 1
64429: ARRAY
64430: PPUSH
64431: LD_EXP 57
64435: PUSH
64436: LD_VAR 0 2
64440: ARRAY
64441: PUSH
64442: LD_INT 1
64444: ARRAY
64445: PUSH
64446: LD_INT 2
64448: ARRAY
64449: PPUSH
64450: LD_EXP 57
64454: PUSH
64455: LD_VAR 0 2
64459: ARRAY
64460: PUSH
64461: LD_INT 1
64463: ARRAY
64464: PUSH
64465: LD_INT 3
64467: ARRAY
64468: PPUSH
64469: LD_EXP 57
64473: PUSH
64474: LD_VAR 0 2
64478: ARRAY
64479: PUSH
64480: LD_INT 1
64482: ARRAY
64483: PUSH
64484: LD_INT 4
64486: ARRAY
64487: PPUSH
64488: CALL_OW 145
// end ;
64492: GO 64281
64494: POP
64495: POP
// end else
64496: GO 64640
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
64498: LD_EXP 52
64502: PUSH
64503: LD_VAR 0 2
64507: ARRAY
64508: PPUSH
64509: LD_EXP 57
64513: PUSH
64514: LD_VAR 0 2
64518: ARRAY
64519: PUSH
64520: LD_INT 1
64522: ARRAY
64523: PUSH
64524: LD_INT 1
64526: ARRAY
64527: PPUSH
64528: LD_EXP 57
64532: PUSH
64533: LD_VAR 0 2
64537: ARRAY
64538: PUSH
64539: LD_INT 1
64541: ARRAY
64542: PUSH
64543: LD_INT 2
64545: ARRAY
64546: PPUSH
64547: LD_EXP 57
64551: PUSH
64552: LD_VAR 0 2
64556: ARRAY
64557: PUSH
64558: LD_INT 1
64560: ARRAY
64561: PUSH
64562: LD_INT 3
64564: ARRAY
64565: PPUSH
64566: LD_EXP 57
64570: PUSH
64571: LD_VAR 0 2
64575: ARRAY
64576: PUSH
64577: LD_INT 1
64579: ARRAY
64580: PUSH
64581: LD_INT 4
64583: ARRAY
64584: PPUSH
64585: CALL 24567 0 5
64589: NOT
64590: IFFALSE 64640
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
64592: LD_ADDR_EXP 57
64596: PUSH
64597: LD_EXP 57
64601: PPUSH
64602: LD_VAR 0 2
64606: PPUSH
64607: LD_EXP 57
64611: PUSH
64612: LD_VAR 0 2
64616: ARRAY
64617: PPUSH
64618: LD_INT 1
64620: PPUSH
64621: LD_INT 1
64623: NEG
64624: PPUSH
64625: LD_INT 0
64627: PPUSH
64628: CALL 17234 0 4
64632: PPUSH
64633: CALL_OW 1
64637: ST_TO_ADDR
// continue ;
64638: GO 63516
// end ; end ; end ;
64640: GO 63516
64642: POP
64643: POP
// end ;
64644: LD_VAR 0 1
64648: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
64649: LD_INT 0
64651: PPUSH
64652: PPUSH
64653: PPUSH
64654: PPUSH
64655: PPUSH
64656: PPUSH
// if not mc_bases then
64657: LD_EXP 52
64661: NOT
64662: IFFALSE 64666
// exit ;
64664: GO 65093
// for i = 1 to mc_bases do
64666: LD_ADDR_VAR 0 2
64670: PUSH
64671: DOUBLE
64672: LD_INT 1
64674: DEC
64675: ST_TO_ADDR
64676: LD_EXP 52
64680: PUSH
64681: FOR_TO
64682: IFFALSE 65091
// begin tmp := mc_build_upgrade [ i ] ;
64684: LD_ADDR_VAR 0 4
64688: PUSH
64689: LD_EXP 84
64693: PUSH
64694: LD_VAR 0 2
64698: ARRAY
64699: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
64700: LD_ADDR_VAR 0 6
64704: PUSH
64705: LD_EXP 85
64709: PUSH
64710: LD_VAR 0 2
64714: ARRAY
64715: PPUSH
64716: LD_INT 2
64718: PUSH
64719: LD_INT 30
64721: PUSH
64722: LD_INT 6
64724: PUSH
64725: EMPTY
64726: LIST
64727: LIST
64728: PUSH
64729: LD_INT 30
64731: PUSH
64732: LD_INT 7
64734: PUSH
64735: EMPTY
64736: LIST
64737: LIST
64738: PUSH
64739: EMPTY
64740: LIST
64741: LIST
64742: LIST
64743: PPUSH
64744: CALL_OW 72
64748: ST_TO_ADDR
// if not tmp and not lab then
64749: LD_VAR 0 4
64753: NOT
64754: PUSH
64755: LD_VAR 0 6
64759: NOT
64760: AND
64761: IFFALSE 64765
// continue ;
64763: GO 64681
// if tmp then
64765: LD_VAR 0 4
64769: IFFALSE 64889
// for j in tmp do
64771: LD_ADDR_VAR 0 3
64775: PUSH
64776: LD_VAR 0 4
64780: PUSH
64781: FOR_IN
64782: IFFALSE 64887
// begin if UpgradeCost ( j ) then
64784: LD_VAR 0 3
64788: PPUSH
64789: CALL 24227 0 1
64793: IFFALSE 64885
// begin ComUpgrade ( j ) ;
64795: LD_VAR 0 3
64799: PPUSH
64800: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
64804: LD_ADDR_EXP 84
64808: PUSH
64809: LD_EXP 84
64813: PPUSH
64814: LD_VAR 0 2
64818: PPUSH
64819: LD_EXP 84
64823: PUSH
64824: LD_VAR 0 2
64828: ARRAY
64829: PUSH
64830: LD_VAR 0 3
64834: DIFF
64835: PPUSH
64836: CALL_OW 1
64840: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64841: LD_ADDR_EXP 59
64845: PUSH
64846: LD_EXP 59
64850: PPUSH
64851: LD_VAR 0 2
64855: PUSH
64856: LD_EXP 59
64860: PUSH
64861: LD_VAR 0 2
64865: ARRAY
64866: PUSH
64867: LD_INT 1
64869: PLUS
64870: PUSH
64871: EMPTY
64872: LIST
64873: LIST
64874: PPUSH
64875: LD_VAR 0 3
64879: PPUSH
64880: CALL 17816 0 3
64884: ST_TO_ADDR
// end ; end ;
64885: GO 64781
64887: POP
64888: POP
// if not lab or not mc_lab_upgrade [ i ] then
64889: LD_VAR 0 6
64893: NOT
64894: PUSH
64895: LD_EXP 86
64899: PUSH
64900: LD_VAR 0 2
64904: ARRAY
64905: NOT
64906: OR
64907: IFFALSE 64911
// continue ;
64909: GO 64681
// for j in lab do
64911: LD_ADDR_VAR 0 3
64915: PUSH
64916: LD_VAR 0 6
64920: PUSH
64921: FOR_IN
64922: IFFALSE 65087
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
64924: LD_VAR 0 3
64928: PPUSH
64929: CALL_OW 266
64933: PUSH
64934: LD_INT 6
64936: PUSH
64937: LD_INT 7
64939: PUSH
64940: EMPTY
64941: LIST
64942: LIST
64943: IN
64944: PUSH
64945: LD_VAR 0 3
64949: PPUSH
64950: CALL_OW 461
64954: PUSH
64955: LD_INT 1
64957: NONEQUAL
64958: AND
64959: IFFALSE 65085
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
64961: LD_VAR 0 3
64965: PPUSH
64966: LD_EXP 86
64970: PUSH
64971: LD_VAR 0 2
64975: ARRAY
64976: PUSH
64977: LD_INT 1
64979: ARRAY
64980: PPUSH
64981: CALL 24432 0 2
64985: IFFALSE 65085
// begin ComCancel ( j ) ;
64987: LD_VAR 0 3
64991: PPUSH
64992: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
64996: LD_VAR 0 3
65000: PPUSH
65001: LD_EXP 86
65005: PUSH
65006: LD_VAR 0 2
65010: ARRAY
65011: PUSH
65012: LD_INT 1
65014: ARRAY
65015: PPUSH
65016: CALL_OW 207
// if not j in mc_construct_list [ i ] then
65020: LD_VAR 0 3
65024: PUSH
65025: LD_EXP 59
65029: PUSH
65030: LD_VAR 0 2
65034: ARRAY
65035: IN
65036: NOT
65037: IFFALSE 65083
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65039: LD_ADDR_EXP 59
65043: PUSH
65044: LD_EXP 59
65048: PPUSH
65049: LD_VAR 0 2
65053: PUSH
65054: LD_EXP 59
65058: PUSH
65059: LD_VAR 0 2
65063: ARRAY
65064: PUSH
65065: LD_INT 1
65067: PLUS
65068: PUSH
65069: EMPTY
65070: LIST
65071: LIST
65072: PPUSH
65073: LD_VAR 0 3
65077: PPUSH
65078: CALL 17816 0 3
65082: ST_TO_ADDR
// break ;
65083: GO 65087
// end ; end ; end ;
65085: GO 64921
65087: POP
65088: POP
// end ;
65089: GO 64681
65091: POP
65092: POP
// end ;
65093: LD_VAR 0 1
65097: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
65098: LD_INT 0
65100: PPUSH
65101: PPUSH
65102: PPUSH
65103: PPUSH
65104: PPUSH
65105: PPUSH
65106: PPUSH
65107: PPUSH
65108: PPUSH
// if not mc_bases then
65109: LD_EXP 52
65113: NOT
65114: IFFALSE 65118
// exit ;
65116: GO 65523
// for i = 1 to mc_bases do
65118: LD_ADDR_VAR 0 2
65122: PUSH
65123: DOUBLE
65124: LD_INT 1
65126: DEC
65127: ST_TO_ADDR
65128: LD_EXP 52
65132: PUSH
65133: FOR_TO
65134: IFFALSE 65521
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
65136: LD_EXP 60
65140: PUSH
65141: LD_VAR 0 2
65145: ARRAY
65146: NOT
65147: PUSH
65148: LD_EXP 52
65152: PUSH
65153: LD_VAR 0 2
65157: ARRAY
65158: PPUSH
65159: LD_INT 30
65161: PUSH
65162: LD_INT 3
65164: PUSH
65165: EMPTY
65166: LIST
65167: LIST
65168: PPUSH
65169: CALL_OW 72
65173: NOT
65174: OR
65175: IFFALSE 65179
// continue ;
65177: GO 65133
// busy := false ;
65179: LD_ADDR_VAR 0 8
65183: PUSH
65184: LD_INT 0
65186: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65187: LD_ADDR_VAR 0 4
65191: PUSH
65192: LD_EXP 52
65196: PUSH
65197: LD_VAR 0 2
65201: ARRAY
65202: PPUSH
65203: LD_INT 30
65205: PUSH
65206: LD_INT 3
65208: PUSH
65209: EMPTY
65210: LIST
65211: LIST
65212: PPUSH
65213: CALL_OW 72
65217: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
65218: LD_ADDR_VAR 0 6
65222: PUSH
65223: LD_EXP 60
65227: PUSH
65228: LD_VAR 0 2
65232: ARRAY
65233: PPUSH
65234: LD_INT 2
65236: PUSH
65237: LD_INT 30
65239: PUSH
65240: LD_INT 32
65242: PUSH
65243: EMPTY
65244: LIST
65245: LIST
65246: PUSH
65247: LD_INT 30
65249: PUSH
65250: LD_INT 33
65252: PUSH
65253: EMPTY
65254: LIST
65255: LIST
65256: PUSH
65257: EMPTY
65258: LIST
65259: LIST
65260: LIST
65261: PPUSH
65262: CALL_OW 72
65266: ST_TO_ADDR
// if not t then
65267: LD_VAR 0 6
65271: NOT
65272: IFFALSE 65276
// continue ;
65274: GO 65133
// for j in tmp do
65276: LD_ADDR_VAR 0 3
65280: PUSH
65281: LD_VAR 0 4
65285: PUSH
65286: FOR_IN
65287: IFFALSE 65317
// if not BuildingStatus ( j ) = bs_idle then
65289: LD_VAR 0 3
65293: PPUSH
65294: CALL_OW 461
65298: PUSH
65299: LD_INT 2
65301: EQUAL
65302: NOT
65303: IFFALSE 65315
// begin busy := true ;
65305: LD_ADDR_VAR 0 8
65309: PUSH
65310: LD_INT 1
65312: ST_TO_ADDR
// break ;
65313: GO 65317
// end ;
65315: GO 65286
65317: POP
65318: POP
// if busy then
65319: LD_VAR 0 8
65323: IFFALSE 65327
// continue ;
65325: GO 65133
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
65327: LD_ADDR_VAR 0 7
65331: PUSH
65332: LD_VAR 0 6
65336: PPUSH
65337: LD_INT 35
65339: PUSH
65340: LD_INT 0
65342: PUSH
65343: EMPTY
65344: LIST
65345: LIST
65346: PPUSH
65347: CALL_OW 72
65351: ST_TO_ADDR
// if tw then
65352: LD_VAR 0 7
65356: IFFALSE 65433
// begin tw := tw [ 1 ] ;
65358: LD_ADDR_VAR 0 7
65362: PUSH
65363: LD_VAR 0 7
65367: PUSH
65368: LD_INT 1
65370: ARRAY
65371: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
65372: LD_ADDR_VAR 0 9
65376: PUSH
65377: LD_VAR 0 7
65381: PPUSH
65382: LD_EXP 77
65386: PUSH
65387: LD_VAR 0 2
65391: ARRAY
65392: PPUSH
65393: CALL 22786 0 2
65397: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
65398: LD_EXP 91
65402: PUSH
65403: LD_VAR 0 2
65407: ARRAY
65408: IFFALSE 65431
// if not weapon in mc_allowed_tower_weapons [ i ] then
65410: LD_VAR 0 9
65414: PUSH
65415: LD_EXP 91
65419: PUSH
65420: LD_VAR 0 2
65424: ARRAY
65425: IN
65426: NOT
65427: IFFALSE 65431
// continue ;
65429: GO 65133
// end else
65431: GO 65496
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
65433: LD_ADDR_VAR 0 5
65437: PUSH
65438: LD_EXP 60
65442: PUSH
65443: LD_VAR 0 2
65447: ARRAY
65448: PPUSH
65449: LD_VAR 0 4
65453: PPUSH
65454: CALL 52987 0 2
65458: ST_TO_ADDR
// if not tmp2 then
65459: LD_VAR 0 5
65463: NOT
65464: IFFALSE 65468
// continue ;
65466: GO 65133
// tw := tmp2 [ 1 ] ;
65468: LD_ADDR_VAR 0 7
65472: PUSH
65473: LD_VAR 0 5
65477: PUSH
65478: LD_INT 1
65480: ARRAY
65481: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
65482: LD_ADDR_VAR 0 9
65486: PUSH
65487: LD_VAR 0 5
65491: PUSH
65492: LD_INT 2
65494: ARRAY
65495: ST_TO_ADDR
// end ; if not weapon then
65496: LD_VAR 0 9
65500: NOT
65501: IFFALSE 65505
// continue ;
65503: GO 65133
// ComPlaceWeapon ( tw , weapon ) ;
65505: LD_VAR 0 7
65509: PPUSH
65510: LD_VAR 0 9
65514: PPUSH
65515: CALL_OW 148
// end ;
65519: GO 65133
65521: POP
65522: POP
// end ;
65523: LD_VAR 0 1
65527: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
65528: LD_INT 0
65530: PPUSH
65531: PPUSH
65532: PPUSH
65533: PPUSH
65534: PPUSH
65535: PPUSH
// if not mc_bases then
65536: LD_EXP 52
65540: NOT
65541: IFFALSE 65545
// exit ;
65543: GO 66557
// for i = 1 to mc_bases do
65545: LD_ADDR_VAR 0 2
65549: PUSH
65550: DOUBLE
65551: LD_INT 1
65553: DEC
65554: ST_TO_ADDR
65555: LD_EXP 52
65559: PUSH
65560: FOR_TO
65561: IFFALSE 66555
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
65563: LD_EXP 65
65567: PUSH
65568: LD_VAR 0 2
65572: ARRAY
65573: NOT
65574: PUSH
65575: LD_EXP 65
65579: PUSH
65580: LD_VAR 0 2
65584: ARRAY
65585: PUSH
65586: LD_EXP 66
65590: PUSH
65591: LD_VAR 0 2
65595: ARRAY
65596: EQUAL
65597: OR
65598: IFFALSE 65602
// continue ;
65600: GO 65560
// if mc_miners [ i ] then
65602: LD_EXP 66
65606: PUSH
65607: LD_VAR 0 2
65611: ARRAY
65612: IFFALSE 66242
// begin k := 1 ;
65614: LD_ADDR_VAR 0 4
65618: PUSH
65619: LD_INT 1
65621: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
65622: LD_ADDR_VAR 0 3
65626: PUSH
65627: DOUBLE
65628: LD_EXP 66
65632: PUSH
65633: LD_VAR 0 2
65637: ARRAY
65638: INC
65639: ST_TO_ADDR
65640: LD_INT 1
65642: PUSH
65643: FOR_DOWNTO
65644: IFFALSE 66240
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
65646: LD_EXP 66
65650: PUSH
65651: LD_VAR 0 2
65655: ARRAY
65656: PUSH
65657: LD_VAR 0 3
65661: ARRAY
65662: PPUSH
65663: CALL_OW 301
65667: PUSH
65668: LD_EXP 66
65672: PUSH
65673: LD_VAR 0 2
65677: ARRAY
65678: PUSH
65679: LD_VAR 0 3
65683: ARRAY
65684: PPUSH
65685: CALL_OW 257
65689: PUSH
65690: LD_INT 1
65692: NONEQUAL
65693: OR
65694: IFFALSE 65757
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
65696: LD_ADDR_VAR 0 5
65700: PUSH
65701: LD_EXP 66
65705: PUSH
65706: LD_VAR 0 2
65710: ARRAY
65711: PUSH
65712: LD_EXP 66
65716: PUSH
65717: LD_VAR 0 2
65721: ARRAY
65722: PUSH
65723: LD_VAR 0 3
65727: ARRAY
65728: DIFF
65729: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
65730: LD_ADDR_EXP 66
65734: PUSH
65735: LD_EXP 66
65739: PPUSH
65740: LD_VAR 0 2
65744: PPUSH
65745: LD_VAR 0 5
65749: PPUSH
65750: CALL_OW 1
65754: ST_TO_ADDR
// continue ;
65755: GO 65643
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
65757: LD_EXP 66
65761: PUSH
65762: LD_VAR 0 2
65766: ARRAY
65767: PUSH
65768: LD_VAR 0 3
65772: ARRAY
65773: PPUSH
65774: CALL 17752 0 1
65778: PUSH
65779: LD_EXP 66
65783: PUSH
65784: LD_VAR 0 2
65788: ARRAY
65789: PUSH
65790: LD_VAR 0 3
65794: ARRAY
65795: PPUSH
65796: CALL_OW 255
65800: PPUSH
65801: LD_EXP 65
65805: PUSH
65806: LD_VAR 0 2
65810: ARRAY
65811: PUSH
65812: LD_VAR 0 4
65816: ARRAY
65817: PUSH
65818: LD_INT 1
65820: ARRAY
65821: PPUSH
65822: LD_EXP 65
65826: PUSH
65827: LD_VAR 0 2
65831: ARRAY
65832: PUSH
65833: LD_VAR 0 4
65837: ARRAY
65838: PUSH
65839: LD_INT 2
65841: ARRAY
65842: PPUSH
65843: LD_INT 15
65845: PPUSH
65846: CALL 18712 0 4
65850: PUSH
65851: LD_INT 4
65853: ARRAY
65854: PUSH
65855: LD_EXP 66
65859: PUSH
65860: LD_VAR 0 2
65864: ARRAY
65865: PUSH
65866: LD_VAR 0 3
65870: ARRAY
65871: PPUSH
65872: LD_INT 10
65874: PPUSH
65875: CALL 20409 0 2
65879: PUSH
65880: LD_INT 4
65882: ARRAY
65883: OR
65884: AND
65885: IFFALSE 65908
// ComStop ( mc_miners [ i ] [ j ] ) ;
65887: LD_EXP 66
65891: PUSH
65892: LD_VAR 0 2
65896: ARRAY
65897: PUSH
65898: LD_VAR 0 3
65902: ARRAY
65903: PPUSH
65904: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
65908: LD_EXP 66
65912: PUSH
65913: LD_VAR 0 2
65917: ARRAY
65918: PUSH
65919: LD_VAR 0 3
65923: ARRAY
65924: PPUSH
65925: CALL_OW 257
65929: PUSH
65930: LD_INT 1
65932: EQUAL
65933: PUSH
65934: LD_EXP 66
65938: PUSH
65939: LD_VAR 0 2
65943: ARRAY
65944: PUSH
65945: LD_VAR 0 3
65949: ARRAY
65950: PPUSH
65951: CALL_OW 459
65955: NOT
65956: AND
65957: PUSH
65958: LD_EXP 66
65962: PUSH
65963: LD_VAR 0 2
65967: ARRAY
65968: PUSH
65969: LD_VAR 0 3
65973: ARRAY
65974: PPUSH
65975: CALL_OW 255
65979: PPUSH
65980: LD_EXP 65
65984: PUSH
65985: LD_VAR 0 2
65989: ARRAY
65990: PUSH
65991: LD_VAR 0 4
65995: ARRAY
65996: PUSH
65997: LD_INT 1
65999: ARRAY
66000: PPUSH
66001: LD_EXP 65
66005: PUSH
66006: LD_VAR 0 2
66010: ARRAY
66011: PUSH
66012: LD_VAR 0 4
66016: ARRAY
66017: PUSH
66018: LD_INT 2
66020: ARRAY
66021: PPUSH
66022: LD_INT 15
66024: PPUSH
66025: CALL 18712 0 4
66029: PUSH
66030: LD_INT 4
66032: ARRAY
66033: PUSH
66034: LD_INT 0
66036: EQUAL
66037: AND
66038: PUSH
66039: LD_EXP 66
66043: PUSH
66044: LD_VAR 0 2
66048: ARRAY
66049: PUSH
66050: LD_VAR 0 3
66054: ARRAY
66055: PPUSH
66056: CALL_OW 314
66060: NOT
66061: AND
66062: IFFALSE 66238
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
66064: LD_EXP 66
66068: PUSH
66069: LD_VAR 0 2
66073: ARRAY
66074: PUSH
66075: LD_VAR 0 3
66079: ARRAY
66080: PPUSH
66081: CALL_OW 310
66085: IFFALSE 66108
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
66087: LD_EXP 66
66091: PUSH
66092: LD_VAR 0 2
66096: ARRAY
66097: PUSH
66098: LD_VAR 0 3
66102: ARRAY
66103: PPUSH
66104: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
66108: LD_EXP 66
66112: PUSH
66113: LD_VAR 0 2
66117: ARRAY
66118: PUSH
66119: LD_VAR 0 3
66123: ARRAY
66124: PPUSH
66125: CALL_OW 314
66129: NOT
66130: IFFALSE 66198
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
66132: LD_EXP 66
66136: PUSH
66137: LD_VAR 0 2
66141: ARRAY
66142: PUSH
66143: LD_VAR 0 3
66147: ARRAY
66148: PPUSH
66149: LD_EXP 65
66153: PUSH
66154: LD_VAR 0 2
66158: ARRAY
66159: PUSH
66160: LD_VAR 0 4
66164: ARRAY
66165: PUSH
66166: LD_INT 1
66168: ARRAY
66169: PPUSH
66170: LD_EXP 65
66174: PUSH
66175: LD_VAR 0 2
66179: ARRAY
66180: PUSH
66181: LD_VAR 0 4
66185: ARRAY
66186: PUSH
66187: LD_INT 2
66189: ARRAY
66190: PPUSH
66191: LD_INT 0
66193: PPUSH
66194: CALL_OW 193
// k := k + 1 ;
66198: LD_ADDR_VAR 0 4
66202: PUSH
66203: LD_VAR 0 4
66207: PUSH
66208: LD_INT 1
66210: PLUS
66211: ST_TO_ADDR
// if k > mc_mines [ i ] then
66212: LD_VAR 0 4
66216: PUSH
66217: LD_EXP 65
66221: PUSH
66222: LD_VAR 0 2
66226: ARRAY
66227: GREATER
66228: IFFALSE 66238
// k := 1 ;
66230: LD_ADDR_VAR 0 4
66234: PUSH
66235: LD_INT 1
66237: ST_TO_ADDR
// end ; end ;
66238: GO 65643
66240: POP
66241: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
66242: LD_ADDR_VAR 0 5
66246: PUSH
66247: LD_EXP 52
66251: PUSH
66252: LD_VAR 0 2
66256: ARRAY
66257: PPUSH
66258: LD_INT 2
66260: PUSH
66261: LD_INT 30
66263: PUSH
66264: LD_INT 4
66266: PUSH
66267: EMPTY
66268: LIST
66269: LIST
66270: PUSH
66271: LD_INT 30
66273: PUSH
66274: LD_INT 5
66276: PUSH
66277: EMPTY
66278: LIST
66279: LIST
66280: PUSH
66281: LD_INT 30
66283: PUSH
66284: LD_INT 32
66286: PUSH
66287: EMPTY
66288: LIST
66289: LIST
66290: PUSH
66291: EMPTY
66292: LIST
66293: LIST
66294: LIST
66295: LIST
66296: PPUSH
66297: CALL_OW 72
66301: ST_TO_ADDR
// if not tmp then
66302: LD_VAR 0 5
66306: NOT
66307: IFFALSE 66311
// continue ;
66309: GO 65560
// list := [ ] ;
66311: LD_ADDR_VAR 0 6
66315: PUSH
66316: EMPTY
66317: ST_TO_ADDR
// for j in tmp do
66318: LD_ADDR_VAR 0 3
66322: PUSH
66323: LD_VAR 0 5
66327: PUSH
66328: FOR_IN
66329: IFFALSE 66398
// begin for k in UnitsInside ( j ) do
66331: LD_ADDR_VAR 0 4
66335: PUSH
66336: LD_VAR 0 3
66340: PPUSH
66341: CALL_OW 313
66345: PUSH
66346: FOR_IN
66347: IFFALSE 66394
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
66349: LD_VAR 0 4
66353: PPUSH
66354: CALL_OW 257
66358: PUSH
66359: LD_INT 1
66361: EQUAL
66362: PUSH
66363: LD_VAR 0 4
66367: PPUSH
66368: CALL_OW 459
66372: NOT
66373: AND
66374: IFFALSE 66392
// list := list ^ k ;
66376: LD_ADDR_VAR 0 6
66380: PUSH
66381: LD_VAR 0 6
66385: PUSH
66386: LD_VAR 0 4
66390: ADD
66391: ST_TO_ADDR
66392: GO 66346
66394: POP
66395: POP
// end ;
66396: GO 66328
66398: POP
66399: POP
// list := list diff mc_miners [ i ] ;
66400: LD_ADDR_VAR 0 6
66404: PUSH
66405: LD_VAR 0 6
66409: PUSH
66410: LD_EXP 66
66414: PUSH
66415: LD_VAR 0 2
66419: ARRAY
66420: DIFF
66421: ST_TO_ADDR
// if not list then
66422: LD_VAR 0 6
66426: NOT
66427: IFFALSE 66431
// continue ;
66429: GO 65560
// k := mc_mines [ i ] - mc_miners [ i ] ;
66431: LD_ADDR_VAR 0 4
66435: PUSH
66436: LD_EXP 65
66440: PUSH
66441: LD_VAR 0 2
66445: ARRAY
66446: PUSH
66447: LD_EXP 66
66451: PUSH
66452: LD_VAR 0 2
66456: ARRAY
66457: MINUS
66458: ST_TO_ADDR
// if k > list then
66459: LD_VAR 0 4
66463: PUSH
66464: LD_VAR 0 6
66468: GREATER
66469: IFFALSE 66481
// k := list ;
66471: LD_ADDR_VAR 0 4
66475: PUSH
66476: LD_VAR 0 6
66480: ST_TO_ADDR
// for j = 1 to k do
66481: LD_ADDR_VAR 0 3
66485: PUSH
66486: DOUBLE
66487: LD_INT 1
66489: DEC
66490: ST_TO_ADDR
66491: LD_VAR 0 4
66495: PUSH
66496: FOR_TO
66497: IFFALSE 66551
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
66499: LD_ADDR_EXP 66
66503: PUSH
66504: LD_EXP 66
66508: PPUSH
66509: LD_VAR 0 2
66513: PUSH
66514: LD_EXP 66
66518: PUSH
66519: LD_VAR 0 2
66523: ARRAY
66524: PUSH
66525: LD_INT 1
66527: PLUS
66528: PUSH
66529: EMPTY
66530: LIST
66531: LIST
66532: PPUSH
66533: LD_VAR 0 6
66537: PUSH
66538: LD_VAR 0 3
66542: ARRAY
66543: PPUSH
66544: CALL 17816 0 3
66548: ST_TO_ADDR
66549: GO 66496
66551: POP
66552: POP
// end ;
66553: GO 65560
66555: POP
66556: POP
// end ;
66557: LD_VAR 0 1
66561: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
66562: LD_INT 0
66564: PPUSH
66565: PPUSH
66566: PPUSH
66567: PPUSH
66568: PPUSH
66569: PPUSH
66570: PPUSH
66571: PPUSH
66572: PPUSH
66573: PPUSH
// if not mc_bases then
66574: LD_EXP 52
66578: NOT
66579: IFFALSE 66583
// exit ;
66581: GO 68314
// for i = 1 to mc_bases do
66583: LD_ADDR_VAR 0 2
66587: PUSH
66588: DOUBLE
66589: LD_INT 1
66591: DEC
66592: ST_TO_ADDR
66593: LD_EXP 52
66597: PUSH
66598: FOR_TO
66599: IFFALSE 68312
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
66601: LD_EXP 52
66605: PUSH
66606: LD_VAR 0 2
66610: ARRAY
66611: NOT
66612: PUSH
66613: LD_EXP 59
66617: PUSH
66618: LD_VAR 0 2
66622: ARRAY
66623: OR
66624: IFFALSE 66628
// continue ;
66626: GO 66598
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
66628: LD_EXP 68
66632: PUSH
66633: LD_VAR 0 2
66637: ARRAY
66638: NOT
66639: PUSH
66640: LD_EXP 69
66644: PUSH
66645: LD_VAR 0 2
66649: ARRAY
66650: AND
66651: IFFALSE 66689
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
66653: LD_ADDR_EXP 69
66657: PUSH
66658: LD_EXP 69
66662: PPUSH
66663: LD_VAR 0 2
66667: PPUSH
66668: EMPTY
66669: PPUSH
66670: CALL_OW 1
66674: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
66675: LD_VAR 0 2
66679: PPUSH
66680: LD_INT 107
66682: PPUSH
66683: CALL 57778 0 2
// continue ;
66687: GO 66598
// end ; target := [ ] ;
66689: LD_ADDR_VAR 0 6
66693: PUSH
66694: EMPTY
66695: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
66696: LD_ADDR_VAR 0 3
66700: PUSH
66701: DOUBLE
66702: LD_EXP 68
66706: PUSH
66707: LD_VAR 0 2
66711: ARRAY
66712: INC
66713: ST_TO_ADDR
66714: LD_INT 1
66716: PUSH
66717: FOR_DOWNTO
66718: IFFALSE 66978
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
66720: LD_EXP 68
66724: PUSH
66725: LD_VAR 0 2
66729: ARRAY
66730: PUSH
66731: LD_VAR 0 3
66735: ARRAY
66736: PUSH
66737: LD_INT 2
66739: ARRAY
66740: PPUSH
66741: LD_EXP 68
66745: PUSH
66746: LD_VAR 0 2
66750: ARRAY
66751: PUSH
66752: LD_VAR 0 3
66756: ARRAY
66757: PUSH
66758: LD_INT 3
66760: ARRAY
66761: PPUSH
66762: CALL_OW 488
66766: PUSH
66767: LD_EXP 68
66771: PUSH
66772: LD_VAR 0 2
66776: ARRAY
66777: PUSH
66778: LD_VAR 0 3
66782: ARRAY
66783: PUSH
66784: LD_INT 2
66786: ARRAY
66787: PPUSH
66788: LD_EXP 68
66792: PUSH
66793: LD_VAR 0 2
66797: ARRAY
66798: PUSH
66799: LD_VAR 0 3
66803: ARRAY
66804: PUSH
66805: LD_INT 3
66807: ARRAY
66808: PPUSH
66809: CALL_OW 284
66813: PUSH
66814: LD_INT 0
66816: EQUAL
66817: AND
66818: IFFALSE 66873
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
66820: LD_ADDR_VAR 0 5
66824: PUSH
66825: LD_EXP 68
66829: PUSH
66830: LD_VAR 0 2
66834: ARRAY
66835: PPUSH
66836: LD_VAR 0 3
66840: PPUSH
66841: CALL_OW 3
66845: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
66846: LD_ADDR_EXP 68
66850: PUSH
66851: LD_EXP 68
66855: PPUSH
66856: LD_VAR 0 2
66860: PPUSH
66861: LD_VAR 0 5
66865: PPUSH
66866: CALL_OW 1
66870: ST_TO_ADDR
// continue ;
66871: GO 66717
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
66873: LD_EXP 52
66877: PUSH
66878: LD_VAR 0 2
66882: ARRAY
66883: PUSH
66884: LD_INT 1
66886: ARRAY
66887: PPUSH
66888: CALL_OW 255
66892: PPUSH
66893: LD_EXP 68
66897: PUSH
66898: LD_VAR 0 2
66902: ARRAY
66903: PUSH
66904: LD_VAR 0 3
66908: ARRAY
66909: PUSH
66910: LD_INT 2
66912: ARRAY
66913: PPUSH
66914: LD_EXP 68
66918: PUSH
66919: LD_VAR 0 2
66923: ARRAY
66924: PUSH
66925: LD_VAR 0 3
66929: ARRAY
66930: PUSH
66931: LD_INT 3
66933: ARRAY
66934: PPUSH
66935: LD_INT 30
66937: PPUSH
66938: CALL 18712 0 4
66942: PUSH
66943: LD_INT 4
66945: ARRAY
66946: PUSH
66947: LD_INT 0
66949: EQUAL
66950: IFFALSE 66976
// begin target := mc_crates [ i ] [ j ] ;
66952: LD_ADDR_VAR 0 6
66956: PUSH
66957: LD_EXP 68
66961: PUSH
66962: LD_VAR 0 2
66966: ARRAY
66967: PUSH
66968: LD_VAR 0 3
66972: ARRAY
66973: ST_TO_ADDR
// break ;
66974: GO 66978
// end ; end ;
66976: GO 66717
66978: POP
66979: POP
// if not target then
66980: LD_VAR 0 6
66984: NOT
66985: IFFALSE 66989
// continue ;
66987: GO 66598
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
66989: LD_ADDR_VAR 0 7
66993: PUSH
66994: LD_EXP 71
66998: PUSH
66999: LD_VAR 0 2
67003: ARRAY
67004: PPUSH
67005: LD_INT 2
67007: PUSH
67008: LD_INT 3
67010: PUSH
67011: LD_INT 58
67013: PUSH
67014: EMPTY
67015: LIST
67016: PUSH
67017: EMPTY
67018: LIST
67019: LIST
67020: PUSH
67021: LD_INT 61
67023: PUSH
67024: EMPTY
67025: LIST
67026: PUSH
67027: LD_INT 33
67029: PUSH
67030: LD_INT 5
67032: PUSH
67033: EMPTY
67034: LIST
67035: LIST
67036: PUSH
67037: LD_INT 33
67039: PUSH
67040: LD_INT 3
67042: PUSH
67043: EMPTY
67044: LIST
67045: LIST
67046: PUSH
67047: EMPTY
67048: LIST
67049: LIST
67050: LIST
67051: LIST
67052: LIST
67053: PUSH
67054: LD_INT 2
67056: PUSH
67057: LD_INT 34
67059: PUSH
67060: LD_INT 32
67062: PUSH
67063: EMPTY
67064: LIST
67065: LIST
67066: PUSH
67067: LD_INT 34
67069: PUSH
67070: LD_INT 51
67072: PUSH
67073: EMPTY
67074: LIST
67075: LIST
67076: PUSH
67077: LD_INT 34
67079: PUSH
67080: LD_INT 12
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: LIST
67091: LIST
67092: PUSH
67093: EMPTY
67094: LIST
67095: LIST
67096: PPUSH
67097: CALL_OW 72
67101: ST_TO_ADDR
// if not cargo then
67102: LD_VAR 0 7
67106: NOT
67107: IFFALSE 67750
// begin if mc_crates_collector [ i ] < 5 then
67109: LD_EXP 69
67113: PUSH
67114: LD_VAR 0 2
67118: ARRAY
67119: PUSH
67120: LD_INT 5
67122: LESS
67123: IFFALSE 67489
// begin if mc_ape [ i ] then
67125: LD_EXP 81
67129: PUSH
67130: LD_VAR 0 2
67134: ARRAY
67135: IFFALSE 67182
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
67137: LD_ADDR_VAR 0 5
67141: PUSH
67142: LD_EXP 81
67146: PUSH
67147: LD_VAR 0 2
67151: ARRAY
67152: PPUSH
67153: LD_INT 25
67155: PUSH
67156: LD_INT 16
67158: PUSH
67159: EMPTY
67160: LIST
67161: LIST
67162: PUSH
67163: LD_INT 24
67165: PUSH
67166: LD_INT 750
67168: PUSH
67169: EMPTY
67170: LIST
67171: LIST
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PPUSH
67177: CALL_OW 72
67181: ST_TO_ADDR
// if not tmp then
67182: LD_VAR 0 5
67186: NOT
67187: IFFALSE 67234
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
67189: LD_ADDR_VAR 0 5
67193: PUSH
67194: LD_EXP 52
67198: PUSH
67199: LD_VAR 0 2
67203: ARRAY
67204: PPUSH
67205: LD_INT 25
67207: PUSH
67208: LD_INT 2
67210: PUSH
67211: EMPTY
67212: LIST
67213: LIST
67214: PUSH
67215: LD_INT 24
67217: PUSH
67218: LD_INT 750
67220: PUSH
67221: EMPTY
67222: LIST
67223: LIST
67224: PUSH
67225: EMPTY
67226: LIST
67227: LIST
67228: PPUSH
67229: CALL_OW 72
67233: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
67234: LD_EXP 81
67238: PUSH
67239: LD_VAR 0 2
67243: ARRAY
67244: PUSH
67245: LD_EXP 52
67249: PUSH
67250: LD_VAR 0 2
67254: ARRAY
67255: PPUSH
67256: LD_INT 25
67258: PUSH
67259: LD_INT 2
67261: PUSH
67262: EMPTY
67263: LIST
67264: LIST
67265: PUSH
67266: LD_INT 24
67268: PUSH
67269: LD_INT 750
67271: PUSH
67272: EMPTY
67273: LIST
67274: LIST
67275: PUSH
67276: EMPTY
67277: LIST
67278: LIST
67279: PPUSH
67280: CALL_OW 72
67284: AND
67285: PUSH
67286: LD_VAR 0 5
67290: PUSH
67291: LD_INT 5
67293: LESS
67294: AND
67295: IFFALSE 67377
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
67297: LD_ADDR_VAR 0 3
67301: PUSH
67302: LD_EXP 52
67306: PUSH
67307: LD_VAR 0 2
67311: ARRAY
67312: PPUSH
67313: LD_INT 25
67315: PUSH
67316: LD_INT 2
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: PUSH
67323: LD_INT 24
67325: PUSH
67326: LD_INT 750
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PUSH
67333: EMPTY
67334: LIST
67335: LIST
67336: PPUSH
67337: CALL_OW 72
67341: PUSH
67342: FOR_IN
67343: IFFALSE 67375
// begin tmp := tmp union j ;
67345: LD_ADDR_VAR 0 5
67349: PUSH
67350: LD_VAR 0 5
67354: PUSH
67355: LD_VAR 0 3
67359: UNION
67360: ST_TO_ADDR
// if tmp >= 5 then
67361: LD_VAR 0 5
67365: PUSH
67366: LD_INT 5
67368: GREATEREQUAL
67369: IFFALSE 67373
// break ;
67371: GO 67375
// end ;
67373: GO 67342
67375: POP
67376: POP
// end ; if not tmp then
67377: LD_VAR 0 5
67381: NOT
67382: IFFALSE 67386
// continue ;
67384: GO 66598
// for j in tmp do
67386: LD_ADDR_VAR 0 3
67390: PUSH
67391: LD_VAR 0 5
67395: PUSH
67396: FOR_IN
67397: IFFALSE 67487
// if not GetTag ( j ) then
67399: LD_VAR 0 3
67403: PPUSH
67404: CALL_OW 110
67408: NOT
67409: IFFALSE 67485
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
67411: LD_ADDR_EXP 69
67415: PUSH
67416: LD_EXP 69
67420: PPUSH
67421: LD_VAR 0 2
67425: PUSH
67426: LD_EXP 69
67430: PUSH
67431: LD_VAR 0 2
67435: ARRAY
67436: PUSH
67437: LD_INT 1
67439: PLUS
67440: PUSH
67441: EMPTY
67442: LIST
67443: LIST
67444: PPUSH
67445: LD_VAR 0 3
67449: PPUSH
67450: CALL 17816 0 3
67454: ST_TO_ADDR
// SetTag ( j , 107 ) ;
67455: LD_VAR 0 3
67459: PPUSH
67460: LD_INT 107
67462: PPUSH
67463: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
67467: LD_EXP 69
67471: PUSH
67472: LD_VAR 0 2
67476: ARRAY
67477: PUSH
67478: LD_INT 5
67480: GREATEREQUAL
67481: IFFALSE 67485
// break ;
67483: GO 67487
// end ;
67485: GO 67396
67487: POP
67488: POP
// end ; if mc_crates_collector [ i ] and target then
67489: LD_EXP 69
67493: PUSH
67494: LD_VAR 0 2
67498: ARRAY
67499: PUSH
67500: LD_VAR 0 6
67504: AND
67505: IFFALSE 67748
// begin if mc_crates_collector [ i ] < target [ 1 ] then
67507: LD_EXP 69
67511: PUSH
67512: LD_VAR 0 2
67516: ARRAY
67517: PUSH
67518: LD_VAR 0 6
67522: PUSH
67523: LD_INT 1
67525: ARRAY
67526: LESS
67527: IFFALSE 67547
// tmp := mc_crates_collector [ i ] else
67529: LD_ADDR_VAR 0 5
67533: PUSH
67534: LD_EXP 69
67538: PUSH
67539: LD_VAR 0 2
67543: ARRAY
67544: ST_TO_ADDR
67545: GO 67561
// tmp := target [ 1 ] ;
67547: LD_ADDR_VAR 0 5
67551: PUSH
67552: LD_VAR 0 6
67556: PUSH
67557: LD_INT 1
67559: ARRAY
67560: ST_TO_ADDR
// k := 0 ;
67561: LD_ADDR_VAR 0 4
67565: PUSH
67566: LD_INT 0
67568: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
67569: LD_ADDR_VAR 0 3
67573: PUSH
67574: LD_EXP 69
67578: PUSH
67579: LD_VAR 0 2
67583: ARRAY
67584: PUSH
67585: FOR_IN
67586: IFFALSE 67746
// begin k := k + 1 ;
67588: LD_ADDR_VAR 0 4
67592: PUSH
67593: LD_VAR 0 4
67597: PUSH
67598: LD_INT 1
67600: PLUS
67601: ST_TO_ADDR
// if k > tmp then
67602: LD_VAR 0 4
67606: PUSH
67607: LD_VAR 0 5
67611: GREATER
67612: IFFALSE 67616
// break ;
67614: GO 67746
// if not GetClass ( j ) in [ 2 , 16 ] then
67616: LD_VAR 0 3
67620: PPUSH
67621: CALL_OW 257
67625: PUSH
67626: LD_INT 2
67628: PUSH
67629: LD_INT 16
67631: PUSH
67632: EMPTY
67633: LIST
67634: LIST
67635: IN
67636: NOT
67637: IFFALSE 67690
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
67639: LD_ADDR_EXP 69
67643: PUSH
67644: LD_EXP 69
67648: PPUSH
67649: LD_VAR 0 2
67653: PPUSH
67654: LD_EXP 69
67658: PUSH
67659: LD_VAR 0 2
67663: ARRAY
67664: PUSH
67665: LD_VAR 0 3
67669: DIFF
67670: PPUSH
67671: CALL_OW 1
67675: ST_TO_ADDR
// SetTag ( j , 0 ) ;
67676: LD_VAR 0 3
67680: PPUSH
67681: LD_INT 0
67683: PPUSH
67684: CALL_OW 109
// continue ;
67688: GO 67585
// end ; if IsInUnit ( j ) then
67690: LD_VAR 0 3
67694: PPUSH
67695: CALL_OW 310
67699: IFFALSE 67710
// ComExitBuilding ( j ) ;
67701: LD_VAR 0 3
67705: PPUSH
67706: CALL_OW 122
// wait ( 3 ) ;
67710: LD_INT 3
67712: PPUSH
67713: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67717: LD_VAR 0 3
67721: PPUSH
67722: LD_VAR 0 6
67726: PUSH
67727: LD_INT 2
67729: ARRAY
67730: PPUSH
67731: LD_VAR 0 6
67735: PUSH
67736: LD_INT 3
67738: ARRAY
67739: PPUSH
67740: CALL_OW 117
// end ;
67744: GO 67585
67746: POP
67747: POP
// end ; end else
67748: GO 68310
// begin for j in cargo do
67750: LD_ADDR_VAR 0 3
67754: PUSH
67755: LD_VAR 0 7
67759: PUSH
67760: FOR_IN
67761: IFFALSE 68308
// begin if GetTag ( j ) <> 0 then
67763: LD_VAR 0 3
67767: PPUSH
67768: CALL_OW 110
67772: PUSH
67773: LD_INT 0
67775: NONEQUAL
67776: IFFALSE 67780
// continue ;
67778: GO 67760
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
67780: LD_VAR 0 3
67784: PPUSH
67785: CALL_OW 256
67789: PUSH
67790: LD_INT 1000
67792: LESS
67793: PUSH
67794: LD_VAR 0 3
67798: PPUSH
67799: LD_EXP 76
67803: PUSH
67804: LD_VAR 0 2
67808: ARRAY
67809: PPUSH
67810: CALL_OW 308
67814: NOT
67815: AND
67816: IFFALSE 67838
// ComMoveToArea ( j , mc_parking [ i ] ) ;
67818: LD_VAR 0 3
67822: PPUSH
67823: LD_EXP 76
67827: PUSH
67828: LD_VAR 0 2
67832: ARRAY
67833: PPUSH
67834: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
67838: LD_VAR 0 3
67842: PPUSH
67843: CALL_OW 256
67847: PUSH
67848: LD_INT 1000
67850: LESS
67851: PUSH
67852: LD_VAR 0 3
67856: PPUSH
67857: LD_EXP 76
67861: PUSH
67862: LD_VAR 0 2
67866: ARRAY
67867: PPUSH
67868: CALL_OW 308
67872: AND
67873: IFFALSE 67877
// continue ;
67875: GO 67760
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
67877: LD_VAR 0 3
67881: PPUSH
67882: CALL_OW 262
67886: PUSH
67887: LD_INT 2
67889: EQUAL
67890: PUSH
67891: LD_VAR 0 3
67895: PPUSH
67896: CALL_OW 261
67900: PUSH
67901: LD_INT 15
67903: LESS
67904: AND
67905: IFFALSE 67909
// continue ;
67907: GO 67760
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
67909: LD_VAR 0 3
67913: PPUSH
67914: CALL_OW 262
67918: PUSH
67919: LD_INT 1
67921: EQUAL
67922: PUSH
67923: LD_VAR 0 3
67927: PPUSH
67928: CALL_OW 261
67932: PUSH
67933: LD_INT 10
67935: LESS
67936: AND
67937: IFFALSE 68247
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67939: LD_ADDR_VAR 0 8
67943: PUSH
67944: LD_EXP 52
67948: PUSH
67949: LD_VAR 0 2
67953: ARRAY
67954: PPUSH
67955: LD_INT 2
67957: PUSH
67958: LD_INT 30
67960: PUSH
67961: LD_INT 0
67963: PUSH
67964: EMPTY
67965: LIST
67966: LIST
67967: PUSH
67968: LD_INT 30
67970: PUSH
67971: LD_INT 1
67973: PUSH
67974: EMPTY
67975: LIST
67976: LIST
67977: PUSH
67978: EMPTY
67979: LIST
67980: LIST
67981: LIST
67982: PPUSH
67983: CALL_OW 72
67987: ST_TO_ADDR
// if not depot then
67988: LD_VAR 0 8
67992: NOT
67993: IFFALSE 67997
// continue ;
67995: GO 67760
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
67997: LD_VAR 0 3
68001: PPUSH
68002: LD_VAR 0 8
68006: PPUSH
68007: LD_VAR 0 3
68011: PPUSH
68012: CALL_OW 74
68016: PPUSH
68017: CALL_OW 296
68021: PUSH
68022: LD_INT 6
68024: LESS
68025: IFFALSE 68041
// SetFuel ( j , 100 ) else
68027: LD_VAR 0 3
68031: PPUSH
68032: LD_INT 100
68034: PPUSH
68035: CALL_OW 240
68039: GO 68247
// if GetFuel ( j ) = 0 then
68041: LD_VAR 0 3
68045: PPUSH
68046: CALL_OW 261
68050: PUSH
68051: LD_INT 0
68053: EQUAL
68054: IFFALSE 68247
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
68056: LD_ADDR_EXP 71
68060: PUSH
68061: LD_EXP 71
68065: PPUSH
68066: LD_VAR 0 2
68070: PPUSH
68071: LD_EXP 71
68075: PUSH
68076: LD_VAR 0 2
68080: ARRAY
68081: PUSH
68082: LD_VAR 0 3
68086: DIFF
68087: PPUSH
68088: CALL_OW 1
68092: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
68093: LD_VAR 0 3
68097: PPUSH
68098: CALL_OW 263
68102: PUSH
68103: LD_INT 1
68105: EQUAL
68106: IFFALSE 68122
// ComExitVehicle ( IsInUnit ( j ) ) ;
68108: LD_VAR 0 3
68112: PPUSH
68113: CALL_OW 310
68117: PPUSH
68118: CALL_OW 121
// if GetControl ( j ) = control_remote then
68122: LD_VAR 0 3
68126: PPUSH
68127: CALL_OW 263
68131: PUSH
68132: LD_INT 2
68134: EQUAL
68135: IFFALSE 68146
// ComUnlink ( j ) ;
68137: LD_VAR 0 3
68141: PPUSH
68142: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
68146: LD_ADDR_VAR 0 9
68150: PUSH
68151: LD_VAR 0 2
68155: PPUSH
68156: LD_INT 3
68158: PPUSH
68159: CALL 77293 0 2
68163: ST_TO_ADDR
// if fac then
68164: LD_VAR 0 9
68168: IFFALSE 68245
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
68170: LD_ADDR_VAR 0 10
68174: PUSH
68175: LD_VAR 0 9
68179: PPUSH
68180: LD_VAR 0 3
68184: PPUSH
68185: CALL_OW 265
68189: PPUSH
68190: LD_VAR 0 3
68194: PPUSH
68195: CALL_OW 262
68199: PPUSH
68200: LD_VAR 0 3
68204: PPUSH
68205: CALL_OW 263
68209: PPUSH
68210: LD_VAR 0 3
68214: PPUSH
68215: CALL_OW 264
68219: PPUSH
68220: CALL 15409 0 5
68224: ST_TO_ADDR
// if components then
68225: LD_VAR 0 10
68229: IFFALSE 68245
// MC_InsertProduceList ( i , components ) ;
68231: LD_VAR 0 2
68235: PPUSH
68236: LD_VAR 0 10
68240: PPUSH
68241: CALL 76921 0 2
// end ; continue ;
68245: GO 67760
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
68247: LD_VAR 0 3
68251: PPUSH
68252: LD_INT 1
68254: PPUSH
68255: CALL_OW 289
68259: PUSH
68260: LD_INT 100
68262: LESS
68263: PUSH
68264: LD_VAR 0 3
68268: PPUSH
68269: CALL_OW 314
68273: NOT
68274: AND
68275: IFFALSE 68304
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68277: LD_VAR 0 3
68281: PPUSH
68282: LD_VAR 0 6
68286: PUSH
68287: LD_INT 2
68289: ARRAY
68290: PPUSH
68291: LD_VAR 0 6
68295: PUSH
68296: LD_INT 3
68298: ARRAY
68299: PPUSH
68300: CALL_OW 117
// break ;
68304: GO 68308
// end ;
68306: GO 67760
68308: POP
68309: POP
// end ; end ;
68310: GO 66598
68312: POP
68313: POP
// end ;
68314: LD_VAR 0 1
68318: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
68319: LD_INT 0
68321: PPUSH
68322: PPUSH
68323: PPUSH
68324: PPUSH
// if not mc_bases then
68325: LD_EXP 52
68329: NOT
68330: IFFALSE 68334
// exit ;
68332: GO 68495
// for i = 1 to mc_bases do
68334: LD_ADDR_VAR 0 2
68338: PUSH
68339: DOUBLE
68340: LD_INT 1
68342: DEC
68343: ST_TO_ADDR
68344: LD_EXP 52
68348: PUSH
68349: FOR_TO
68350: IFFALSE 68493
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
68352: LD_ADDR_VAR 0 4
68356: PUSH
68357: LD_EXP 71
68361: PUSH
68362: LD_VAR 0 2
68366: ARRAY
68367: PUSH
68368: LD_EXP 74
68372: PUSH
68373: LD_VAR 0 2
68377: ARRAY
68378: UNION
68379: PPUSH
68380: LD_INT 33
68382: PUSH
68383: LD_INT 2
68385: PUSH
68386: EMPTY
68387: LIST
68388: LIST
68389: PPUSH
68390: CALL_OW 72
68394: ST_TO_ADDR
// if tmp then
68395: LD_VAR 0 4
68399: IFFALSE 68491
// for j in tmp do
68401: LD_ADDR_VAR 0 3
68405: PUSH
68406: LD_VAR 0 4
68410: PUSH
68411: FOR_IN
68412: IFFALSE 68489
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
68414: LD_VAR 0 3
68418: PPUSH
68419: CALL_OW 312
68423: NOT
68424: PUSH
68425: LD_VAR 0 3
68429: PPUSH
68430: CALL_OW 256
68434: PUSH
68435: LD_INT 250
68437: GREATEREQUAL
68438: AND
68439: IFFALSE 68452
// Connect ( j ) else
68441: LD_VAR 0 3
68445: PPUSH
68446: CALL 20749 0 1
68450: GO 68487
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
68452: LD_VAR 0 3
68456: PPUSH
68457: CALL_OW 256
68461: PUSH
68462: LD_INT 250
68464: LESS
68465: PUSH
68466: LD_VAR 0 3
68470: PPUSH
68471: CALL_OW 312
68475: AND
68476: IFFALSE 68487
// ComUnlink ( j ) ;
68478: LD_VAR 0 3
68482: PPUSH
68483: CALL_OW 136
68487: GO 68411
68489: POP
68490: POP
// end ;
68491: GO 68349
68493: POP
68494: POP
// end ;
68495: LD_VAR 0 1
68499: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
68500: LD_INT 0
68502: PPUSH
68503: PPUSH
68504: PPUSH
68505: PPUSH
68506: PPUSH
// if not mc_bases then
68507: LD_EXP 52
68511: NOT
68512: IFFALSE 68516
// exit ;
68514: GO 68976
// for i = 1 to mc_bases do
68516: LD_ADDR_VAR 0 2
68520: PUSH
68521: DOUBLE
68522: LD_INT 1
68524: DEC
68525: ST_TO_ADDR
68526: LD_EXP 52
68530: PUSH
68531: FOR_TO
68532: IFFALSE 68974
// begin if not mc_produce [ i ] then
68534: LD_EXP 73
68538: PUSH
68539: LD_VAR 0 2
68543: ARRAY
68544: NOT
68545: IFFALSE 68549
// continue ;
68547: GO 68531
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68549: LD_ADDR_VAR 0 5
68553: PUSH
68554: LD_EXP 52
68558: PUSH
68559: LD_VAR 0 2
68563: ARRAY
68564: PPUSH
68565: LD_INT 30
68567: PUSH
68568: LD_INT 3
68570: PUSH
68571: EMPTY
68572: LIST
68573: LIST
68574: PPUSH
68575: CALL_OW 72
68579: ST_TO_ADDR
// if not fac then
68580: LD_VAR 0 5
68584: NOT
68585: IFFALSE 68589
// continue ;
68587: GO 68531
// for j in fac do
68589: LD_ADDR_VAR 0 3
68593: PUSH
68594: LD_VAR 0 5
68598: PUSH
68599: FOR_IN
68600: IFFALSE 68970
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
68602: LD_VAR 0 3
68606: PPUSH
68607: CALL_OW 461
68611: PUSH
68612: LD_INT 2
68614: NONEQUAL
68615: PUSH
68616: LD_VAR 0 3
68620: PPUSH
68621: LD_INT 15
68623: PPUSH
68624: CALL 20409 0 2
68628: PUSH
68629: LD_INT 4
68631: ARRAY
68632: OR
68633: PUSH
68634: LD_VAR 0 3
68638: PPUSH
68639: CALL_OW 313
68643: PUSH
68644: LD_INT 0
68646: EQUAL
68647: OR
68648: IFFALSE 68652
// continue ;
68650: GO 68599
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
68652: LD_VAR 0 3
68656: PPUSH
68657: LD_EXP 73
68661: PUSH
68662: LD_VAR 0 2
68666: ARRAY
68667: PUSH
68668: LD_INT 1
68670: ARRAY
68671: PUSH
68672: LD_INT 1
68674: ARRAY
68675: PPUSH
68676: LD_EXP 73
68680: PUSH
68681: LD_VAR 0 2
68685: ARRAY
68686: PUSH
68687: LD_INT 1
68689: ARRAY
68690: PUSH
68691: LD_INT 2
68693: ARRAY
68694: PPUSH
68695: LD_EXP 73
68699: PUSH
68700: LD_VAR 0 2
68704: ARRAY
68705: PUSH
68706: LD_INT 1
68708: ARRAY
68709: PUSH
68710: LD_INT 3
68712: ARRAY
68713: PPUSH
68714: LD_EXP 73
68718: PUSH
68719: LD_VAR 0 2
68723: ARRAY
68724: PUSH
68725: LD_INT 1
68727: ARRAY
68728: PUSH
68729: LD_INT 4
68731: ARRAY
68732: PPUSH
68733: CALL_OW 448
68737: PUSH
68738: LD_VAR 0 3
68742: PPUSH
68743: LD_EXP 73
68747: PUSH
68748: LD_VAR 0 2
68752: ARRAY
68753: PUSH
68754: LD_INT 1
68756: ARRAY
68757: PUSH
68758: LD_INT 1
68760: ARRAY
68761: PUSH
68762: LD_EXP 73
68766: PUSH
68767: LD_VAR 0 2
68771: ARRAY
68772: PUSH
68773: LD_INT 1
68775: ARRAY
68776: PUSH
68777: LD_INT 2
68779: ARRAY
68780: PUSH
68781: LD_EXP 73
68785: PUSH
68786: LD_VAR 0 2
68790: ARRAY
68791: PUSH
68792: LD_INT 1
68794: ARRAY
68795: PUSH
68796: LD_INT 3
68798: ARRAY
68799: PUSH
68800: LD_EXP 73
68804: PUSH
68805: LD_VAR 0 2
68809: ARRAY
68810: PUSH
68811: LD_INT 1
68813: ARRAY
68814: PUSH
68815: LD_INT 4
68817: ARRAY
68818: PUSH
68819: EMPTY
68820: LIST
68821: LIST
68822: LIST
68823: LIST
68824: PPUSH
68825: CALL 24080 0 2
68829: AND
68830: IFFALSE 68968
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
68832: LD_VAR 0 3
68836: PPUSH
68837: LD_EXP 73
68841: PUSH
68842: LD_VAR 0 2
68846: ARRAY
68847: PUSH
68848: LD_INT 1
68850: ARRAY
68851: PUSH
68852: LD_INT 1
68854: ARRAY
68855: PPUSH
68856: LD_EXP 73
68860: PUSH
68861: LD_VAR 0 2
68865: ARRAY
68866: PUSH
68867: LD_INT 1
68869: ARRAY
68870: PUSH
68871: LD_INT 2
68873: ARRAY
68874: PPUSH
68875: LD_EXP 73
68879: PUSH
68880: LD_VAR 0 2
68884: ARRAY
68885: PUSH
68886: LD_INT 1
68888: ARRAY
68889: PUSH
68890: LD_INT 3
68892: ARRAY
68893: PPUSH
68894: LD_EXP 73
68898: PUSH
68899: LD_VAR 0 2
68903: ARRAY
68904: PUSH
68905: LD_INT 1
68907: ARRAY
68908: PUSH
68909: LD_INT 4
68911: ARRAY
68912: PPUSH
68913: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
68917: LD_ADDR_VAR 0 4
68921: PUSH
68922: LD_EXP 73
68926: PUSH
68927: LD_VAR 0 2
68931: ARRAY
68932: PPUSH
68933: LD_INT 1
68935: PPUSH
68936: CALL_OW 3
68940: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
68941: LD_ADDR_EXP 73
68945: PUSH
68946: LD_EXP 73
68950: PPUSH
68951: LD_VAR 0 2
68955: PPUSH
68956: LD_VAR 0 4
68960: PPUSH
68961: CALL_OW 1
68965: ST_TO_ADDR
// break ;
68966: GO 68970
// end ; end ;
68968: GO 68599
68970: POP
68971: POP
// end ;
68972: GO 68531
68974: POP
68975: POP
// end ;
68976: LD_VAR 0 1
68980: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
68981: LD_INT 0
68983: PPUSH
68984: PPUSH
68985: PPUSH
// if not mc_bases then
68986: LD_EXP 52
68990: NOT
68991: IFFALSE 68995
// exit ;
68993: GO 69084
// for i = 1 to mc_bases do
68995: LD_ADDR_VAR 0 2
68999: PUSH
69000: DOUBLE
69001: LD_INT 1
69003: DEC
69004: ST_TO_ADDR
69005: LD_EXP 52
69009: PUSH
69010: FOR_TO
69011: IFFALSE 69082
// begin if mc_attack [ i ] then
69013: LD_EXP 72
69017: PUSH
69018: LD_VAR 0 2
69022: ARRAY
69023: IFFALSE 69080
// begin tmp := mc_attack [ i ] [ 1 ] ;
69025: LD_ADDR_VAR 0 3
69029: PUSH
69030: LD_EXP 72
69034: PUSH
69035: LD_VAR 0 2
69039: ARRAY
69040: PUSH
69041: LD_INT 1
69043: ARRAY
69044: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
69045: LD_ADDR_EXP 72
69049: PUSH
69050: LD_EXP 72
69054: PPUSH
69055: LD_VAR 0 2
69059: PPUSH
69060: EMPTY
69061: PPUSH
69062: CALL_OW 1
69066: ST_TO_ADDR
// Attack ( tmp ) ;
69067: LD_VAR 0 3
69071: PPUSH
69072: CALL 46293 0 1
// exit ;
69076: POP
69077: POP
69078: GO 69084
// end ; end ;
69080: GO 69010
69082: POP
69083: POP
// end ;
69084: LD_VAR 0 1
69088: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
69089: LD_INT 0
69091: PPUSH
69092: PPUSH
69093: PPUSH
69094: PPUSH
69095: PPUSH
69096: PPUSH
69097: PPUSH
// if not mc_bases then
69098: LD_EXP 52
69102: NOT
69103: IFFALSE 69107
// exit ;
69105: GO 69689
// for i = 1 to mc_bases do
69107: LD_ADDR_VAR 0 2
69111: PUSH
69112: DOUBLE
69113: LD_INT 1
69115: DEC
69116: ST_TO_ADDR
69117: LD_EXP 52
69121: PUSH
69122: FOR_TO
69123: IFFALSE 69687
// begin if not mc_bases [ i ] then
69125: LD_EXP 52
69129: PUSH
69130: LD_VAR 0 2
69134: ARRAY
69135: NOT
69136: IFFALSE 69140
// continue ;
69138: GO 69122
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
69140: LD_ADDR_VAR 0 7
69144: PUSH
69145: LD_EXP 52
69149: PUSH
69150: LD_VAR 0 2
69154: ARRAY
69155: PUSH
69156: LD_INT 1
69158: ARRAY
69159: PPUSH
69160: CALL 14713 0 1
69164: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
69165: LD_ADDR_EXP 75
69169: PUSH
69170: LD_EXP 75
69174: PPUSH
69175: LD_VAR 0 2
69179: PPUSH
69180: LD_EXP 52
69184: PUSH
69185: LD_VAR 0 2
69189: ARRAY
69190: PUSH
69191: LD_INT 1
69193: ARRAY
69194: PPUSH
69195: CALL_OW 255
69199: PPUSH
69200: LD_EXP 77
69204: PUSH
69205: LD_VAR 0 2
69209: ARRAY
69210: PPUSH
69211: CALL 12710 0 2
69215: PPUSH
69216: CALL_OW 1
69220: ST_TO_ADDR
// if not mc_scan [ i ] then
69221: LD_EXP 75
69225: PUSH
69226: LD_VAR 0 2
69230: ARRAY
69231: NOT
69232: IFFALSE 69387
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69234: LD_ADDR_VAR 0 4
69238: PUSH
69239: LD_EXP 52
69243: PUSH
69244: LD_VAR 0 2
69248: ARRAY
69249: PPUSH
69250: LD_INT 2
69252: PUSH
69253: LD_INT 25
69255: PUSH
69256: LD_INT 5
69258: PUSH
69259: EMPTY
69260: LIST
69261: LIST
69262: PUSH
69263: LD_INT 25
69265: PUSH
69266: LD_INT 8
69268: PUSH
69269: EMPTY
69270: LIST
69271: LIST
69272: PUSH
69273: LD_INT 25
69275: PUSH
69276: LD_INT 9
69278: PUSH
69279: EMPTY
69280: LIST
69281: LIST
69282: PUSH
69283: EMPTY
69284: LIST
69285: LIST
69286: LIST
69287: LIST
69288: PPUSH
69289: CALL_OW 72
69293: ST_TO_ADDR
// if not tmp then
69294: LD_VAR 0 4
69298: NOT
69299: IFFALSE 69303
// continue ;
69301: GO 69122
// for j in tmp do
69303: LD_ADDR_VAR 0 3
69307: PUSH
69308: LD_VAR 0 4
69312: PUSH
69313: FOR_IN
69314: IFFALSE 69385
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
69316: LD_VAR 0 3
69320: PPUSH
69321: CALL_OW 310
69325: PPUSH
69326: CALL_OW 266
69330: PUSH
69331: LD_INT 5
69333: EQUAL
69334: PUSH
69335: LD_VAR 0 3
69339: PPUSH
69340: CALL_OW 257
69344: PUSH
69345: LD_INT 1
69347: EQUAL
69348: AND
69349: PUSH
69350: LD_VAR 0 3
69354: PPUSH
69355: CALL_OW 459
69359: NOT
69360: AND
69361: PUSH
69362: LD_VAR 0 7
69366: AND
69367: IFFALSE 69383
// ComChangeProfession ( j , class ) ;
69369: LD_VAR 0 3
69373: PPUSH
69374: LD_VAR 0 7
69378: PPUSH
69379: CALL_OW 123
69383: GO 69313
69385: POP
69386: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
69387: LD_EXP 75
69391: PUSH
69392: LD_VAR 0 2
69396: ARRAY
69397: PUSH
69398: LD_EXP 74
69402: PUSH
69403: LD_VAR 0 2
69407: ARRAY
69408: NOT
69409: AND
69410: PUSH
69411: LD_EXP 52
69415: PUSH
69416: LD_VAR 0 2
69420: ARRAY
69421: PPUSH
69422: LD_INT 30
69424: PUSH
69425: LD_INT 32
69427: PUSH
69428: EMPTY
69429: LIST
69430: LIST
69431: PPUSH
69432: CALL_OW 72
69436: NOT
69437: AND
69438: PUSH
69439: LD_EXP 52
69443: PUSH
69444: LD_VAR 0 2
69448: ARRAY
69449: PPUSH
69450: LD_INT 2
69452: PUSH
69453: LD_INT 30
69455: PUSH
69456: LD_INT 4
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: PUSH
69463: LD_INT 30
69465: PUSH
69466: LD_INT 5
69468: PUSH
69469: EMPTY
69470: LIST
69471: LIST
69472: PUSH
69473: EMPTY
69474: LIST
69475: LIST
69476: LIST
69477: PPUSH
69478: CALL_OW 72
69482: NOT
69483: AND
69484: IFFALSE 69616
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69486: LD_ADDR_VAR 0 4
69490: PUSH
69491: LD_EXP 52
69495: PUSH
69496: LD_VAR 0 2
69500: ARRAY
69501: PPUSH
69502: LD_INT 2
69504: PUSH
69505: LD_INT 25
69507: PUSH
69508: LD_INT 1
69510: PUSH
69511: EMPTY
69512: LIST
69513: LIST
69514: PUSH
69515: LD_INT 25
69517: PUSH
69518: LD_INT 5
69520: PUSH
69521: EMPTY
69522: LIST
69523: LIST
69524: PUSH
69525: LD_INT 25
69527: PUSH
69528: LD_INT 8
69530: PUSH
69531: EMPTY
69532: LIST
69533: LIST
69534: PUSH
69535: LD_INT 25
69537: PUSH
69538: LD_INT 9
69540: PUSH
69541: EMPTY
69542: LIST
69543: LIST
69544: PUSH
69545: EMPTY
69546: LIST
69547: LIST
69548: LIST
69549: LIST
69550: LIST
69551: PPUSH
69552: CALL_OW 72
69556: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
69557: LD_ADDR_VAR 0 4
69561: PUSH
69562: LD_VAR 0 4
69566: PUSH
69567: LD_VAR 0 4
69571: PPUSH
69572: LD_INT 18
69574: PPUSH
69575: CALL 51076 0 2
69579: DIFF
69580: ST_TO_ADDR
// if tmp then
69581: LD_VAR 0 4
69585: IFFALSE 69616
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
69587: LD_VAR 0 2
69591: PPUSH
69592: LD_VAR 0 4
69596: PPUSH
69597: LD_EXP 77
69601: PUSH
69602: LD_VAR 0 2
69606: ARRAY
69607: PPUSH
69608: CALL 12745 0 3
// exit ;
69612: POP
69613: POP
69614: GO 69689
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
69616: LD_EXP 75
69620: PUSH
69621: LD_VAR 0 2
69625: ARRAY
69626: PUSH
69627: LD_EXP 74
69631: PUSH
69632: LD_VAR 0 2
69636: ARRAY
69637: AND
69638: IFFALSE 69685
// begin tmp := mc_defender [ i ] ;
69640: LD_ADDR_VAR 0 4
69644: PUSH
69645: LD_EXP 74
69649: PUSH
69650: LD_VAR 0 2
69654: ARRAY
69655: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
69656: LD_VAR 0 2
69660: PPUSH
69661: LD_VAR 0 4
69665: PPUSH
69666: LD_EXP 75
69670: PUSH
69671: LD_VAR 0 2
69675: ARRAY
69676: PPUSH
69677: CALL 13243 0 3
// exit ;
69681: POP
69682: POP
69683: GO 69689
// end ; end ;
69685: GO 69122
69687: POP
69688: POP
// end ;
69689: LD_VAR 0 1
69693: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
69694: LD_INT 0
69696: PPUSH
69697: PPUSH
69698: PPUSH
69699: PPUSH
69700: PPUSH
69701: PPUSH
69702: PPUSH
69703: PPUSH
69704: PPUSH
69705: PPUSH
69706: PPUSH
// if not mc_bases then
69707: LD_EXP 52
69711: NOT
69712: IFFALSE 69716
// exit ;
69714: GO 70803
// for i = 1 to mc_bases do
69716: LD_ADDR_VAR 0 2
69720: PUSH
69721: DOUBLE
69722: LD_INT 1
69724: DEC
69725: ST_TO_ADDR
69726: LD_EXP 52
69730: PUSH
69731: FOR_TO
69732: IFFALSE 70801
// begin tmp := mc_lab [ i ] ;
69734: LD_ADDR_VAR 0 6
69738: PUSH
69739: LD_EXP 85
69743: PUSH
69744: LD_VAR 0 2
69748: ARRAY
69749: ST_TO_ADDR
// if not tmp then
69750: LD_VAR 0 6
69754: NOT
69755: IFFALSE 69759
// continue ;
69757: GO 69731
// idle_lab := 0 ;
69759: LD_ADDR_VAR 0 11
69763: PUSH
69764: LD_INT 0
69766: ST_TO_ADDR
// for j in tmp do
69767: LD_ADDR_VAR 0 3
69771: PUSH
69772: LD_VAR 0 6
69776: PUSH
69777: FOR_IN
69778: IFFALSE 70797
// begin researching := false ;
69780: LD_ADDR_VAR 0 10
69784: PUSH
69785: LD_INT 0
69787: ST_TO_ADDR
// side := GetSide ( j ) ;
69788: LD_ADDR_VAR 0 4
69792: PUSH
69793: LD_VAR 0 3
69797: PPUSH
69798: CALL_OW 255
69802: ST_TO_ADDR
// if not mc_tech [ side ] then
69803: LD_EXP 79
69807: PUSH
69808: LD_VAR 0 4
69812: ARRAY
69813: NOT
69814: IFFALSE 69818
// continue ;
69816: GO 69777
// if BuildingStatus ( j ) = bs_idle then
69818: LD_VAR 0 3
69822: PPUSH
69823: CALL_OW 461
69827: PUSH
69828: LD_INT 2
69830: EQUAL
69831: IFFALSE 70019
// begin if idle_lab and UnitsInside ( j ) < 6 then
69833: LD_VAR 0 11
69837: PUSH
69838: LD_VAR 0 3
69842: PPUSH
69843: CALL_OW 313
69847: PUSH
69848: LD_INT 6
69850: LESS
69851: AND
69852: IFFALSE 69923
// begin tmp2 := UnitsInside ( idle_lab ) ;
69854: LD_ADDR_VAR 0 9
69858: PUSH
69859: LD_VAR 0 11
69863: PPUSH
69864: CALL_OW 313
69868: ST_TO_ADDR
// if tmp2 then
69869: LD_VAR 0 9
69873: IFFALSE 69915
// for x in tmp2 do
69875: LD_ADDR_VAR 0 7
69879: PUSH
69880: LD_VAR 0 9
69884: PUSH
69885: FOR_IN
69886: IFFALSE 69913
// begin ComExitBuilding ( x ) ;
69888: LD_VAR 0 7
69892: PPUSH
69893: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69897: LD_VAR 0 7
69901: PPUSH
69902: LD_VAR 0 3
69906: PPUSH
69907: CALL_OW 180
// end ;
69911: GO 69885
69913: POP
69914: POP
// idle_lab := 0 ;
69915: LD_ADDR_VAR 0 11
69919: PUSH
69920: LD_INT 0
69922: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
69923: LD_ADDR_VAR 0 5
69927: PUSH
69928: LD_EXP 79
69932: PUSH
69933: LD_VAR 0 4
69937: ARRAY
69938: PUSH
69939: FOR_IN
69940: IFFALSE 70000
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
69942: LD_VAR 0 3
69946: PPUSH
69947: LD_VAR 0 5
69951: PPUSH
69952: CALL_OW 430
69956: PUSH
69957: LD_VAR 0 4
69961: PPUSH
69962: LD_VAR 0 5
69966: PPUSH
69967: CALL 11815 0 2
69971: AND
69972: IFFALSE 69998
// begin researching := true ;
69974: LD_ADDR_VAR 0 10
69978: PUSH
69979: LD_INT 1
69981: ST_TO_ADDR
// ComResearch ( j , t ) ;
69982: LD_VAR 0 3
69986: PPUSH
69987: LD_VAR 0 5
69991: PPUSH
69992: CALL_OW 124
// break ;
69996: GO 70000
// end ;
69998: GO 69939
70000: POP
70001: POP
// if not researching then
70002: LD_VAR 0 10
70006: NOT
70007: IFFALSE 70019
// idle_lab := j ;
70009: LD_ADDR_VAR 0 11
70013: PUSH
70014: LD_VAR 0 3
70018: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
70019: LD_VAR 0 3
70023: PPUSH
70024: CALL_OW 461
70028: PUSH
70029: LD_INT 10
70031: EQUAL
70032: IFFALSE 70620
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
70034: LD_EXP 81
70038: PUSH
70039: LD_VAR 0 2
70043: ARRAY
70044: NOT
70045: PUSH
70046: LD_EXP 82
70050: PUSH
70051: LD_VAR 0 2
70055: ARRAY
70056: NOT
70057: AND
70058: PUSH
70059: LD_EXP 79
70063: PUSH
70064: LD_VAR 0 4
70068: ARRAY
70069: PUSH
70070: LD_INT 1
70072: GREATER
70073: AND
70074: IFFALSE 70205
// begin ComCancel ( j ) ;
70076: LD_VAR 0 3
70080: PPUSH
70081: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
70085: LD_ADDR_EXP 79
70089: PUSH
70090: LD_EXP 79
70094: PPUSH
70095: LD_VAR 0 4
70099: PPUSH
70100: LD_EXP 79
70104: PUSH
70105: LD_VAR 0 4
70109: ARRAY
70110: PPUSH
70111: LD_EXP 79
70115: PUSH
70116: LD_VAR 0 4
70120: ARRAY
70121: PUSH
70122: LD_INT 1
70124: MINUS
70125: PPUSH
70126: LD_EXP 79
70130: PUSH
70131: LD_VAR 0 4
70135: ARRAY
70136: PPUSH
70137: LD_INT 0
70139: PPUSH
70140: CALL 17234 0 4
70144: PPUSH
70145: CALL_OW 1
70149: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
70150: LD_ADDR_EXP 79
70154: PUSH
70155: LD_EXP 79
70159: PPUSH
70160: LD_VAR 0 4
70164: PPUSH
70165: LD_EXP 79
70169: PUSH
70170: LD_VAR 0 4
70174: ARRAY
70175: PPUSH
70176: LD_EXP 79
70180: PUSH
70181: LD_VAR 0 4
70185: ARRAY
70186: PPUSH
70187: LD_INT 1
70189: PPUSH
70190: LD_INT 0
70192: PPUSH
70193: CALL 17234 0 4
70197: PPUSH
70198: CALL_OW 1
70202: ST_TO_ADDR
// continue ;
70203: GO 69777
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
70205: LD_EXP 81
70209: PUSH
70210: LD_VAR 0 2
70214: ARRAY
70215: PUSH
70216: LD_EXP 82
70220: PUSH
70221: LD_VAR 0 2
70225: ARRAY
70226: NOT
70227: AND
70228: IFFALSE 70355
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
70230: LD_ADDR_EXP 82
70234: PUSH
70235: LD_EXP 82
70239: PPUSH
70240: LD_VAR 0 2
70244: PUSH
70245: LD_EXP 82
70249: PUSH
70250: LD_VAR 0 2
70254: ARRAY
70255: PUSH
70256: LD_INT 1
70258: PLUS
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PPUSH
70264: LD_EXP 81
70268: PUSH
70269: LD_VAR 0 2
70273: ARRAY
70274: PUSH
70275: LD_INT 1
70277: ARRAY
70278: PPUSH
70279: CALL 17816 0 3
70283: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
70284: LD_EXP 81
70288: PUSH
70289: LD_VAR 0 2
70293: ARRAY
70294: PUSH
70295: LD_INT 1
70297: ARRAY
70298: PPUSH
70299: LD_INT 112
70301: PPUSH
70302: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
70306: LD_ADDR_VAR 0 9
70310: PUSH
70311: LD_EXP 81
70315: PUSH
70316: LD_VAR 0 2
70320: ARRAY
70321: PPUSH
70322: LD_INT 1
70324: PPUSH
70325: CALL_OW 3
70329: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
70330: LD_ADDR_EXP 81
70334: PUSH
70335: LD_EXP 81
70339: PPUSH
70340: LD_VAR 0 2
70344: PPUSH
70345: LD_VAR 0 9
70349: PPUSH
70350: CALL_OW 1
70354: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
70355: LD_EXP 81
70359: PUSH
70360: LD_VAR 0 2
70364: ARRAY
70365: PUSH
70366: LD_EXP 82
70370: PUSH
70371: LD_VAR 0 2
70375: ARRAY
70376: AND
70377: PUSH
70378: LD_EXP 82
70382: PUSH
70383: LD_VAR 0 2
70387: ARRAY
70388: PUSH
70389: LD_INT 1
70391: ARRAY
70392: PPUSH
70393: CALL_OW 310
70397: NOT
70398: AND
70399: PUSH
70400: LD_VAR 0 3
70404: PPUSH
70405: CALL_OW 313
70409: PUSH
70410: LD_INT 6
70412: EQUAL
70413: AND
70414: IFFALSE 70470
// begin tmp2 := UnitsInside ( j ) ;
70416: LD_ADDR_VAR 0 9
70420: PUSH
70421: LD_VAR 0 3
70425: PPUSH
70426: CALL_OW 313
70430: ST_TO_ADDR
// if tmp2 = 6 then
70431: LD_VAR 0 9
70435: PUSH
70436: LD_INT 6
70438: EQUAL
70439: IFFALSE 70470
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
70441: LD_VAR 0 9
70445: PUSH
70446: LD_INT 1
70448: ARRAY
70449: PPUSH
70450: LD_INT 112
70452: PPUSH
70453: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
70457: LD_VAR 0 9
70461: PUSH
70462: LD_INT 1
70464: ARRAY
70465: PPUSH
70466: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
70470: LD_EXP 82
70474: PUSH
70475: LD_VAR 0 2
70479: ARRAY
70480: PUSH
70481: LD_EXP 82
70485: PUSH
70486: LD_VAR 0 2
70490: ARRAY
70491: PUSH
70492: LD_INT 1
70494: ARRAY
70495: PPUSH
70496: CALL_OW 314
70500: NOT
70501: AND
70502: PUSH
70503: LD_EXP 82
70507: PUSH
70508: LD_VAR 0 2
70512: ARRAY
70513: PUSH
70514: LD_INT 1
70516: ARRAY
70517: PPUSH
70518: CALL_OW 310
70522: NOT
70523: AND
70524: IFFALSE 70550
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
70526: LD_EXP 82
70530: PUSH
70531: LD_VAR 0 2
70535: ARRAY
70536: PUSH
70537: LD_INT 1
70539: ARRAY
70540: PPUSH
70541: LD_VAR 0 3
70545: PPUSH
70546: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
70550: LD_EXP 82
70554: PUSH
70555: LD_VAR 0 2
70559: ARRAY
70560: PUSH
70561: LD_INT 1
70563: ARRAY
70564: PPUSH
70565: CALL_OW 310
70569: PUSH
70570: LD_EXP 82
70574: PUSH
70575: LD_VAR 0 2
70579: ARRAY
70580: PUSH
70581: LD_INT 1
70583: ARRAY
70584: PPUSH
70585: CALL_OW 310
70589: PPUSH
70590: CALL_OW 461
70594: PUSH
70595: LD_INT 3
70597: NONEQUAL
70598: AND
70599: IFFALSE 70620
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
70601: LD_EXP 82
70605: PUSH
70606: LD_VAR 0 2
70610: ARRAY
70611: PUSH
70612: LD_INT 1
70614: ARRAY
70615: PPUSH
70616: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
70620: LD_VAR 0 3
70624: PPUSH
70625: CALL_OW 461
70629: PUSH
70630: LD_INT 6
70632: EQUAL
70633: PUSH
70634: LD_VAR 0 6
70638: PUSH
70639: LD_INT 1
70641: GREATER
70642: AND
70643: IFFALSE 70795
// begin sci := [ ] ;
70645: LD_ADDR_VAR 0 8
70649: PUSH
70650: EMPTY
70651: ST_TO_ADDR
// for x in ( tmp diff j ) do
70652: LD_ADDR_VAR 0 7
70656: PUSH
70657: LD_VAR 0 6
70661: PUSH
70662: LD_VAR 0 3
70666: DIFF
70667: PUSH
70668: FOR_IN
70669: IFFALSE 70721
// begin if sci = 6 then
70671: LD_VAR 0 8
70675: PUSH
70676: LD_INT 6
70678: EQUAL
70679: IFFALSE 70683
// break ;
70681: GO 70721
// if BuildingStatus ( x ) = bs_idle then
70683: LD_VAR 0 7
70687: PPUSH
70688: CALL_OW 461
70692: PUSH
70693: LD_INT 2
70695: EQUAL
70696: IFFALSE 70719
// sci := sci ^ UnitsInside ( x ) ;
70698: LD_ADDR_VAR 0 8
70702: PUSH
70703: LD_VAR 0 8
70707: PUSH
70708: LD_VAR 0 7
70712: PPUSH
70713: CALL_OW 313
70717: ADD
70718: ST_TO_ADDR
// end ;
70719: GO 70668
70721: POP
70722: POP
// if not sci then
70723: LD_VAR 0 8
70727: NOT
70728: IFFALSE 70732
// continue ;
70730: GO 69777
// for x in sci do
70732: LD_ADDR_VAR 0 7
70736: PUSH
70737: LD_VAR 0 8
70741: PUSH
70742: FOR_IN
70743: IFFALSE 70793
// if IsInUnit ( x ) and not HasTask ( x ) then
70745: LD_VAR 0 7
70749: PPUSH
70750: CALL_OW 310
70754: PUSH
70755: LD_VAR 0 7
70759: PPUSH
70760: CALL_OW 314
70764: NOT
70765: AND
70766: IFFALSE 70791
// begin ComExitBuilding ( x ) ;
70768: LD_VAR 0 7
70772: PPUSH
70773: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70777: LD_VAR 0 7
70781: PPUSH
70782: LD_VAR 0 3
70786: PPUSH
70787: CALL_OW 180
// end ;
70791: GO 70742
70793: POP
70794: POP
// end ; end ;
70795: GO 69777
70797: POP
70798: POP
// end ;
70799: GO 69731
70801: POP
70802: POP
// end ;
70803: LD_VAR 0 1
70807: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
70808: LD_INT 0
70810: PPUSH
70811: PPUSH
// if not mc_bases then
70812: LD_EXP 52
70816: NOT
70817: IFFALSE 70821
// exit ;
70819: GO 70902
// for i = 1 to mc_bases do
70821: LD_ADDR_VAR 0 2
70825: PUSH
70826: DOUBLE
70827: LD_INT 1
70829: DEC
70830: ST_TO_ADDR
70831: LD_EXP 52
70835: PUSH
70836: FOR_TO
70837: IFFALSE 70900
// if mc_mines [ i ] and mc_miners [ i ] then
70839: LD_EXP 65
70843: PUSH
70844: LD_VAR 0 2
70848: ARRAY
70849: PUSH
70850: LD_EXP 66
70854: PUSH
70855: LD_VAR 0 2
70859: ARRAY
70860: AND
70861: IFFALSE 70898
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
70863: LD_EXP 66
70867: PUSH
70868: LD_VAR 0 2
70872: ARRAY
70873: PUSH
70874: LD_INT 1
70876: ARRAY
70877: PPUSH
70878: CALL_OW 255
70882: PPUSH
70883: LD_EXP 65
70887: PUSH
70888: LD_VAR 0 2
70892: ARRAY
70893: PPUSH
70894: CALL 14866 0 2
70898: GO 70836
70900: POP
70901: POP
// end ;
70902: LD_VAR 0 1
70906: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
70907: LD_INT 0
70909: PPUSH
70910: PPUSH
70911: PPUSH
70912: PPUSH
70913: PPUSH
70914: PPUSH
70915: PPUSH
70916: PPUSH
// if not mc_bases or not mc_parking then
70917: LD_EXP 52
70921: NOT
70922: PUSH
70923: LD_EXP 76
70927: NOT
70928: OR
70929: IFFALSE 70933
// exit ;
70931: GO 71609
// for i = 1 to mc_bases do
70933: LD_ADDR_VAR 0 2
70937: PUSH
70938: DOUBLE
70939: LD_INT 1
70941: DEC
70942: ST_TO_ADDR
70943: LD_EXP 52
70947: PUSH
70948: FOR_TO
70949: IFFALSE 71607
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
70951: LD_EXP 52
70955: PUSH
70956: LD_VAR 0 2
70960: ARRAY
70961: NOT
70962: PUSH
70963: LD_EXP 76
70967: PUSH
70968: LD_VAR 0 2
70972: ARRAY
70973: NOT
70974: OR
70975: IFFALSE 70979
// continue ;
70977: GO 70948
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70979: LD_ADDR_VAR 0 5
70983: PUSH
70984: LD_EXP 52
70988: PUSH
70989: LD_VAR 0 2
70993: ARRAY
70994: PUSH
70995: LD_INT 1
70997: ARRAY
70998: PPUSH
70999: CALL_OW 255
71003: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71004: LD_ADDR_VAR 0 6
71008: PUSH
71009: LD_EXP 52
71013: PUSH
71014: LD_VAR 0 2
71018: ARRAY
71019: PPUSH
71020: LD_INT 30
71022: PUSH
71023: LD_INT 3
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PPUSH
71030: CALL_OW 72
71034: ST_TO_ADDR
// if not fac then
71035: LD_VAR 0 6
71039: NOT
71040: IFFALSE 71091
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71042: LD_ADDR_VAR 0 6
71046: PUSH
71047: LD_EXP 52
71051: PUSH
71052: LD_VAR 0 2
71056: ARRAY
71057: PPUSH
71058: LD_INT 2
71060: PUSH
71061: LD_INT 30
71063: PUSH
71064: LD_INT 0
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PUSH
71071: LD_INT 30
71073: PUSH
71074: LD_INT 1
71076: PUSH
71077: EMPTY
71078: LIST
71079: LIST
71080: PUSH
71081: EMPTY
71082: LIST
71083: LIST
71084: LIST
71085: PPUSH
71086: CALL_OW 72
71090: ST_TO_ADDR
// if not fac then
71091: LD_VAR 0 6
71095: NOT
71096: IFFALSE 71100
// continue ;
71098: GO 70948
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71100: LD_ADDR_VAR 0 7
71104: PUSH
71105: LD_EXP 76
71109: PUSH
71110: LD_VAR 0 2
71114: ARRAY
71115: PPUSH
71116: LD_INT 22
71118: PUSH
71119: LD_VAR 0 5
71123: PUSH
71124: EMPTY
71125: LIST
71126: LIST
71127: PUSH
71128: LD_INT 21
71130: PUSH
71131: LD_INT 2
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: PUSH
71138: LD_INT 3
71140: PUSH
71141: LD_INT 24
71143: PUSH
71144: LD_INT 1000
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: LIST
71159: PPUSH
71160: CALL_OW 70
71164: PUSH
71165: LD_INT 22
71167: PUSH
71168: LD_VAR 0 5
71172: PUSH
71173: EMPTY
71174: LIST
71175: LIST
71176: PUSH
71177: LD_INT 91
71179: PUSH
71180: LD_VAR 0 6
71184: PUSH
71185: LD_INT 1
71187: ARRAY
71188: PUSH
71189: LD_INT 25
71191: PUSH
71192: EMPTY
71193: LIST
71194: LIST
71195: LIST
71196: PUSH
71197: LD_INT 21
71199: PUSH
71200: LD_INT 2
71202: PUSH
71203: EMPTY
71204: LIST
71205: LIST
71206: PUSH
71207: LD_INT 3
71209: PUSH
71210: LD_INT 24
71212: PUSH
71213: LD_INT 1000
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: EMPTY
71225: LIST
71226: LIST
71227: LIST
71228: LIST
71229: PPUSH
71230: CALL_OW 69
71234: UNION
71235: ST_TO_ADDR
// if not vehs then
71236: LD_VAR 0 7
71240: NOT
71241: IFFALSE 71267
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
71243: LD_ADDR_EXP 64
71247: PUSH
71248: LD_EXP 64
71252: PPUSH
71253: LD_VAR 0 2
71257: PPUSH
71258: EMPTY
71259: PPUSH
71260: CALL_OW 1
71264: ST_TO_ADDR
// continue ;
71265: GO 70948
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71267: LD_ADDR_VAR 0 8
71271: PUSH
71272: LD_EXP 52
71276: PUSH
71277: LD_VAR 0 2
71281: ARRAY
71282: PPUSH
71283: LD_INT 30
71285: PUSH
71286: LD_INT 3
71288: PUSH
71289: EMPTY
71290: LIST
71291: LIST
71292: PPUSH
71293: CALL_OW 72
71297: ST_TO_ADDR
// if tmp then
71298: LD_VAR 0 8
71302: IFFALSE 71405
// begin for j in tmp do
71304: LD_ADDR_VAR 0 3
71308: PUSH
71309: LD_VAR 0 8
71313: PUSH
71314: FOR_IN
71315: IFFALSE 71403
// for k in UnitsInside ( j ) do
71317: LD_ADDR_VAR 0 4
71321: PUSH
71322: LD_VAR 0 3
71326: PPUSH
71327: CALL_OW 313
71331: PUSH
71332: FOR_IN
71333: IFFALSE 71399
// if k then
71335: LD_VAR 0 4
71339: IFFALSE 71397
// if not k in mc_repair_vehicle [ i ] then
71341: LD_VAR 0 4
71345: PUSH
71346: LD_EXP 64
71350: PUSH
71351: LD_VAR 0 2
71355: ARRAY
71356: IN
71357: NOT
71358: IFFALSE 71397
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
71360: LD_ADDR_EXP 64
71364: PUSH
71365: LD_EXP 64
71369: PPUSH
71370: LD_VAR 0 2
71374: PPUSH
71375: LD_EXP 64
71379: PUSH
71380: LD_VAR 0 2
71384: ARRAY
71385: PUSH
71386: LD_VAR 0 4
71390: UNION
71391: PPUSH
71392: CALL_OW 1
71396: ST_TO_ADDR
71397: GO 71332
71399: POP
71400: POP
71401: GO 71314
71403: POP
71404: POP
// end ; if not mc_repair_vehicle [ i ] then
71405: LD_EXP 64
71409: PUSH
71410: LD_VAR 0 2
71414: ARRAY
71415: NOT
71416: IFFALSE 71420
// continue ;
71418: GO 70948
// for j in mc_repair_vehicle [ i ] do
71420: LD_ADDR_VAR 0 3
71424: PUSH
71425: LD_EXP 64
71429: PUSH
71430: LD_VAR 0 2
71434: ARRAY
71435: PUSH
71436: FOR_IN
71437: IFFALSE 71603
// begin if GetClass ( j ) <> 3 then
71439: LD_VAR 0 3
71443: PPUSH
71444: CALL_OW 257
71448: PUSH
71449: LD_INT 3
71451: NONEQUAL
71452: IFFALSE 71493
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
71454: LD_ADDR_EXP 64
71458: PUSH
71459: LD_EXP 64
71463: PPUSH
71464: LD_VAR 0 2
71468: PPUSH
71469: LD_EXP 64
71473: PUSH
71474: LD_VAR 0 2
71478: ARRAY
71479: PUSH
71480: LD_VAR 0 3
71484: DIFF
71485: PPUSH
71486: CALL_OW 1
71490: ST_TO_ADDR
// continue ;
71491: GO 71436
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71493: LD_VAR 0 3
71497: PPUSH
71498: CALL_OW 311
71502: NOT
71503: PUSH
71504: LD_VAR 0 3
71508: PUSH
71509: LD_EXP 55
71513: PUSH
71514: LD_VAR 0 2
71518: ARRAY
71519: PUSH
71520: LD_INT 1
71522: ARRAY
71523: IN
71524: NOT
71525: AND
71526: PUSH
71527: LD_VAR 0 3
71531: PUSH
71532: LD_EXP 55
71536: PUSH
71537: LD_VAR 0 2
71541: ARRAY
71542: PUSH
71543: LD_INT 2
71545: ARRAY
71546: IN
71547: NOT
71548: AND
71549: IFFALSE 71601
// begin if IsInUnit ( j ) then
71551: LD_VAR 0 3
71555: PPUSH
71556: CALL_OW 310
71560: IFFALSE 71571
// ComExitBuilding ( j ) ;
71562: LD_VAR 0 3
71566: PPUSH
71567: CALL_OW 122
// if not HasTask ( j ) then
71571: LD_VAR 0 3
71575: PPUSH
71576: CALL_OW 314
71580: NOT
71581: IFFALSE 71601
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
71583: LD_VAR 0 3
71587: PPUSH
71588: LD_VAR 0 7
71592: PUSH
71593: LD_INT 1
71595: ARRAY
71596: PPUSH
71597: CALL_OW 189
// end ; end ;
71601: GO 71436
71603: POP
71604: POP
// end ;
71605: GO 70948
71607: POP
71608: POP
// end ;
71609: LD_VAR 0 1
71613: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
71614: LD_INT 0
71616: PPUSH
71617: PPUSH
71618: PPUSH
71619: PPUSH
71620: PPUSH
71621: PPUSH
71622: PPUSH
71623: PPUSH
71624: PPUSH
71625: PPUSH
71626: PPUSH
// if not mc_bases then
71627: LD_EXP 52
71631: NOT
71632: IFFALSE 71636
// exit ;
71634: GO 72438
// for i = 1 to mc_bases do
71636: LD_ADDR_VAR 0 2
71640: PUSH
71641: DOUBLE
71642: LD_INT 1
71644: DEC
71645: ST_TO_ADDR
71646: LD_EXP 52
71650: PUSH
71651: FOR_TO
71652: IFFALSE 72436
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
71654: LD_EXP 80
71658: PUSH
71659: LD_VAR 0 2
71663: ARRAY
71664: NOT
71665: PUSH
71666: LD_EXP 55
71670: PUSH
71671: LD_VAR 0 2
71675: ARRAY
71676: PUSH
71677: LD_INT 1
71679: ARRAY
71680: OR
71681: PUSH
71682: LD_EXP 55
71686: PUSH
71687: LD_VAR 0 2
71691: ARRAY
71692: PUSH
71693: LD_INT 2
71695: ARRAY
71696: OR
71697: PUSH
71698: LD_EXP 78
71702: PUSH
71703: LD_VAR 0 2
71707: ARRAY
71708: PPUSH
71709: LD_INT 1
71711: PPUSH
71712: CALL_OW 325
71716: NOT
71717: OR
71718: PUSH
71719: LD_EXP 75
71723: PUSH
71724: LD_VAR 0 2
71728: ARRAY
71729: OR
71730: IFFALSE 71734
// continue ;
71732: GO 71651
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
71734: LD_ADDR_VAR 0 8
71738: PUSH
71739: LD_EXP 52
71743: PUSH
71744: LD_VAR 0 2
71748: ARRAY
71749: PPUSH
71750: LD_INT 25
71752: PUSH
71753: LD_INT 4
71755: PUSH
71756: EMPTY
71757: LIST
71758: LIST
71759: PUSH
71760: LD_INT 50
71762: PUSH
71763: EMPTY
71764: LIST
71765: PUSH
71766: LD_INT 3
71768: PUSH
71769: LD_INT 60
71771: PUSH
71772: EMPTY
71773: LIST
71774: PUSH
71775: EMPTY
71776: LIST
71777: LIST
71778: PUSH
71779: EMPTY
71780: LIST
71781: LIST
71782: LIST
71783: PPUSH
71784: CALL_OW 72
71788: PUSH
71789: LD_EXP 56
71793: PUSH
71794: LD_VAR 0 2
71798: ARRAY
71799: DIFF
71800: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71801: LD_ADDR_VAR 0 9
71805: PUSH
71806: LD_EXP 52
71810: PUSH
71811: LD_VAR 0 2
71815: ARRAY
71816: PPUSH
71817: LD_INT 2
71819: PUSH
71820: LD_INT 30
71822: PUSH
71823: LD_INT 0
71825: PUSH
71826: EMPTY
71827: LIST
71828: LIST
71829: PUSH
71830: LD_INT 30
71832: PUSH
71833: LD_INT 1
71835: PUSH
71836: EMPTY
71837: LIST
71838: LIST
71839: PUSH
71840: EMPTY
71841: LIST
71842: LIST
71843: LIST
71844: PPUSH
71845: CALL_OW 72
71849: ST_TO_ADDR
// if not tmp or not dep then
71850: LD_VAR 0 8
71854: NOT
71855: PUSH
71856: LD_VAR 0 9
71860: NOT
71861: OR
71862: IFFALSE 71866
// continue ;
71864: GO 71651
// side := GetSide ( tmp [ 1 ] ) ;
71866: LD_ADDR_VAR 0 11
71870: PUSH
71871: LD_VAR 0 8
71875: PUSH
71876: LD_INT 1
71878: ARRAY
71879: PPUSH
71880: CALL_OW 255
71884: ST_TO_ADDR
// dep := dep [ 1 ] ;
71885: LD_ADDR_VAR 0 9
71889: PUSH
71890: LD_VAR 0 9
71894: PUSH
71895: LD_INT 1
71897: ARRAY
71898: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
71899: LD_ADDR_VAR 0 7
71903: PUSH
71904: LD_EXP 80
71908: PUSH
71909: LD_VAR 0 2
71913: ARRAY
71914: PPUSH
71915: LD_INT 22
71917: PUSH
71918: LD_INT 0
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: PUSH
71925: LD_INT 25
71927: PUSH
71928: LD_INT 12
71930: PUSH
71931: EMPTY
71932: LIST
71933: LIST
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: PPUSH
71939: CALL_OW 70
71943: PUSH
71944: LD_INT 22
71946: PUSH
71947: LD_INT 0
71949: PUSH
71950: EMPTY
71951: LIST
71952: LIST
71953: PUSH
71954: LD_INT 25
71956: PUSH
71957: LD_INT 12
71959: PUSH
71960: EMPTY
71961: LIST
71962: LIST
71963: PUSH
71964: LD_INT 91
71966: PUSH
71967: LD_VAR 0 9
71971: PUSH
71972: LD_INT 20
71974: PUSH
71975: EMPTY
71976: LIST
71977: LIST
71978: LIST
71979: PUSH
71980: EMPTY
71981: LIST
71982: LIST
71983: LIST
71984: PPUSH
71985: CALL_OW 69
71989: UNION
71990: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
71991: LD_ADDR_VAR 0 10
71995: PUSH
71996: LD_EXP 80
72000: PUSH
72001: LD_VAR 0 2
72005: ARRAY
72006: PPUSH
72007: LD_INT 81
72009: PUSH
72010: LD_VAR 0 11
72014: PUSH
72015: EMPTY
72016: LIST
72017: LIST
72018: PPUSH
72019: CALL_OW 70
72023: ST_TO_ADDR
// if not apes or danger_at_area then
72024: LD_VAR 0 7
72028: NOT
72029: PUSH
72030: LD_VAR 0 10
72034: OR
72035: IFFALSE 72085
// begin if mc_taming [ i ] then
72037: LD_EXP 83
72041: PUSH
72042: LD_VAR 0 2
72046: ARRAY
72047: IFFALSE 72083
// begin MC_Reset ( i , 121 ) ;
72049: LD_VAR 0 2
72053: PPUSH
72054: LD_INT 121
72056: PPUSH
72057: CALL 57778 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
72061: LD_ADDR_EXP 83
72065: PUSH
72066: LD_EXP 83
72070: PPUSH
72071: LD_VAR 0 2
72075: PPUSH
72076: EMPTY
72077: PPUSH
72078: CALL_OW 1
72082: ST_TO_ADDR
// end ; continue ;
72083: GO 71651
// end ; for j in tmp do
72085: LD_ADDR_VAR 0 3
72089: PUSH
72090: LD_VAR 0 8
72094: PUSH
72095: FOR_IN
72096: IFFALSE 72432
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
72098: LD_VAR 0 3
72102: PUSH
72103: LD_EXP 83
72107: PUSH
72108: LD_VAR 0 2
72112: ARRAY
72113: IN
72114: NOT
72115: PUSH
72116: LD_EXP 83
72120: PUSH
72121: LD_VAR 0 2
72125: ARRAY
72126: PUSH
72127: LD_INT 3
72129: LESS
72130: AND
72131: IFFALSE 72189
// begin SetTag ( j , 121 ) ;
72133: LD_VAR 0 3
72137: PPUSH
72138: LD_INT 121
72140: PPUSH
72141: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
72145: LD_ADDR_EXP 83
72149: PUSH
72150: LD_EXP 83
72154: PPUSH
72155: LD_VAR 0 2
72159: PUSH
72160: LD_EXP 83
72164: PUSH
72165: LD_VAR 0 2
72169: ARRAY
72170: PUSH
72171: LD_INT 1
72173: PLUS
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: PPUSH
72179: LD_VAR 0 3
72183: PPUSH
72184: CALL 17816 0 3
72188: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
72189: LD_VAR 0 3
72193: PUSH
72194: LD_EXP 83
72198: PUSH
72199: LD_VAR 0 2
72203: ARRAY
72204: IN
72205: IFFALSE 72430
// begin if GetClass ( j ) <> 4 then
72207: LD_VAR 0 3
72211: PPUSH
72212: CALL_OW 257
72216: PUSH
72217: LD_INT 4
72219: NONEQUAL
72220: IFFALSE 72273
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
72222: LD_ADDR_EXP 83
72226: PUSH
72227: LD_EXP 83
72231: PPUSH
72232: LD_VAR 0 2
72236: PPUSH
72237: LD_EXP 83
72241: PUSH
72242: LD_VAR 0 2
72246: ARRAY
72247: PUSH
72248: LD_VAR 0 3
72252: DIFF
72253: PPUSH
72254: CALL_OW 1
72258: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72259: LD_VAR 0 3
72263: PPUSH
72264: LD_INT 0
72266: PPUSH
72267: CALL_OW 109
// continue ;
72271: GO 72095
// end ; if IsInUnit ( j ) then
72273: LD_VAR 0 3
72277: PPUSH
72278: CALL_OW 310
72282: IFFALSE 72293
// ComExitBuilding ( j ) ;
72284: LD_VAR 0 3
72288: PPUSH
72289: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
72293: LD_ADDR_VAR 0 6
72297: PUSH
72298: LD_VAR 0 7
72302: PPUSH
72303: LD_VAR 0 3
72307: PPUSH
72308: CALL_OW 74
72312: ST_TO_ADDR
// if not ape then
72313: LD_VAR 0 6
72317: NOT
72318: IFFALSE 72322
// break ;
72320: GO 72432
// x := GetX ( ape ) ;
72322: LD_ADDR_VAR 0 4
72326: PUSH
72327: LD_VAR 0 6
72331: PPUSH
72332: CALL_OW 250
72336: ST_TO_ADDR
// y := GetY ( ape ) ;
72337: LD_ADDR_VAR 0 5
72341: PUSH
72342: LD_VAR 0 6
72346: PPUSH
72347: CALL_OW 251
72351: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
72352: LD_VAR 0 4
72356: PPUSH
72357: LD_VAR 0 5
72361: PPUSH
72362: CALL_OW 488
72366: NOT
72367: PUSH
72368: LD_VAR 0 11
72372: PPUSH
72373: LD_VAR 0 4
72377: PPUSH
72378: LD_VAR 0 5
72382: PPUSH
72383: LD_INT 20
72385: PPUSH
72386: CALL 18712 0 4
72390: PUSH
72391: LD_INT 4
72393: ARRAY
72394: OR
72395: IFFALSE 72399
// break ;
72397: GO 72432
// if not HasTask ( j ) then
72399: LD_VAR 0 3
72403: PPUSH
72404: CALL_OW 314
72408: NOT
72409: IFFALSE 72430
// ComTameXY ( j , x , y ) ;
72411: LD_VAR 0 3
72415: PPUSH
72416: LD_VAR 0 4
72420: PPUSH
72421: LD_VAR 0 5
72425: PPUSH
72426: CALL_OW 131
// end ; end ;
72430: GO 72095
72432: POP
72433: POP
// end ;
72434: GO 71651
72436: POP
72437: POP
// end ;
72438: LD_VAR 0 1
72442: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
72443: LD_INT 0
72445: PPUSH
72446: PPUSH
72447: PPUSH
72448: PPUSH
72449: PPUSH
72450: PPUSH
72451: PPUSH
72452: PPUSH
// if not mc_bases then
72453: LD_EXP 52
72457: NOT
72458: IFFALSE 72462
// exit ;
72460: GO 73088
// for i = 1 to mc_bases do
72462: LD_ADDR_VAR 0 2
72466: PUSH
72467: DOUBLE
72468: LD_INT 1
72470: DEC
72471: ST_TO_ADDR
72472: LD_EXP 52
72476: PUSH
72477: FOR_TO
72478: IFFALSE 73086
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
72480: LD_EXP 81
72484: PUSH
72485: LD_VAR 0 2
72489: ARRAY
72490: NOT
72491: PUSH
72492: LD_EXP 81
72496: PUSH
72497: LD_VAR 0 2
72501: ARRAY
72502: PPUSH
72503: LD_INT 25
72505: PUSH
72506: LD_INT 12
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PPUSH
72513: CALL_OW 72
72517: NOT
72518: OR
72519: IFFALSE 72523
// continue ;
72521: GO 72477
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
72523: LD_ADDR_VAR 0 5
72527: PUSH
72528: LD_EXP 81
72532: PUSH
72533: LD_VAR 0 2
72537: ARRAY
72538: PUSH
72539: LD_INT 1
72541: ARRAY
72542: PPUSH
72543: CALL_OW 255
72547: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
72548: LD_VAR 0 5
72552: PPUSH
72553: LD_INT 2
72555: PPUSH
72556: CALL_OW 325
72560: IFFALSE 72813
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72562: LD_ADDR_VAR 0 4
72566: PUSH
72567: LD_EXP 81
72571: PUSH
72572: LD_VAR 0 2
72576: ARRAY
72577: PPUSH
72578: LD_INT 25
72580: PUSH
72581: LD_INT 16
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: PPUSH
72588: CALL_OW 72
72592: ST_TO_ADDR
// if tmp < 6 then
72593: LD_VAR 0 4
72597: PUSH
72598: LD_INT 6
72600: LESS
72601: IFFALSE 72813
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72603: LD_ADDR_VAR 0 6
72607: PUSH
72608: LD_EXP 52
72612: PUSH
72613: LD_VAR 0 2
72617: ARRAY
72618: PPUSH
72619: LD_INT 2
72621: PUSH
72622: LD_INT 30
72624: PUSH
72625: LD_INT 0
72627: PUSH
72628: EMPTY
72629: LIST
72630: LIST
72631: PUSH
72632: LD_INT 30
72634: PUSH
72635: LD_INT 1
72637: PUSH
72638: EMPTY
72639: LIST
72640: LIST
72641: PUSH
72642: EMPTY
72643: LIST
72644: LIST
72645: LIST
72646: PPUSH
72647: CALL_OW 72
72651: ST_TO_ADDR
// if depot then
72652: LD_VAR 0 6
72656: IFFALSE 72813
// begin selected := 0 ;
72658: LD_ADDR_VAR 0 7
72662: PUSH
72663: LD_INT 0
72665: ST_TO_ADDR
// for j in depot do
72666: LD_ADDR_VAR 0 3
72670: PUSH
72671: LD_VAR 0 6
72675: PUSH
72676: FOR_IN
72677: IFFALSE 72708
// begin if UnitsInside ( j ) < 6 then
72679: LD_VAR 0 3
72683: PPUSH
72684: CALL_OW 313
72688: PUSH
72689: LD_INT 6
72691: LESS
72692: IFFALSE 72706
// begin selected := j ;
72694: LD_ADDR_VAR 0 7
72698: PUSH
72699: LD_VAR 0 3
72703: ST_TO_ADDR
// break ;
72704: GO 72708
// end ; end ;
72706: GO 72676
72708: POP
72709: POP
// if selected then
72710: LD_VAR 0 7
72714: IFFALSE 72813
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72716: LD_ADDR_VAR 0 3
72720: PUSH
72721: LD_EXP 81
72725: PUSH
72726: LD_VAR 0 2
72730: ARRAY
72731: PPUSH
72732: LD_INT 25
72734: PUSH
72735: LD_INT 12
72737: PUSH
72738: EMPTY
72739: LIST
72740: LIST
72741: PPUSH
72742: CALL_OW 72
72746: PUSH
72747: FOR_IN
72748: IFFALSE 72811
// if not HasTask ( j ) then
72750: LD_VAR 0 3
72754: PPUSH
72755: CALL_OW 314
72759: NOT
72760: IFFALSE 72809
// begin if not IsInUnit ( j ) then
72762: LD_VAR 0 3
72766: PPUSH
72767: CALL_OW 310
72771: NOT
72772: IFFALSE 72788
// ComEnterUnit ( j , selected ) ;
72774: LD_VAR 0 3
72778: PPUSH
72779: LD_VAR 0 7
72783: PPUSH
72784: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
72788: LD_VAR 0 3
72792: PPUSH
72793: LD_INT 16
72795: PPUSH
72796: CALL_OW 183
// AddComExitBuilding ( j ) ;
72800: LD_VAR 0 3
72804: PPUSH
72805: CALL_OW 182
// end ;
72809: GO 72747
72811: POP
72812: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
72813: LD_VAR 0 5
72817: PPUSH
72818: LD_INT 11
72820: PPUSH
72821: CALL_OW 325
72825: IFFALSE 73084
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72827: LD_ADDR_VAR 0 4
72831: PUSH
72832: LD_EXP 81
72836: PUSH
72837: LD_VAR 0 2
72841: ARRAY
72842: PPUSH
72843: LD_INT 25
72845: PUSH
72846: LD_INT 16
72848: PUSH
72849: EMPTY
72850: LIST
72851: LIST
72852: PPUSH
72853: CALL_OW 72
72857: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
72858: LD_VAR 0 4
72862: PUSH
72863: LD_INT 6
72865: GREATEREQUAL
72866: PUSH
72867: LD_VAR 0 5
72871: PPUSH
72872: LD_INT 2
72874: PPUSH
72875: CALL_OW 325
72879: NOT
72880: OR
72881: IFFALSE 73084
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
72883: LD_ADDR_VAR 0 8
72887: PUSH
72888: LD_EXP 52
72892: PUSH
72893: LD_VAR 0 2
72897: ARRAY
72898: PPUSH
72899: LD_INT 2
72901: PUSH
72902: LD_INT 30
72904: PUSH
72905: LD_INT 4
72907: PUSH
72908: EMPTY
72909: LIST
72910: LIST
72911: PUSH
72912: LD_INT 30
72914: PUSH
72915: LD_INT 5
72917: PUSH
72918: EMPTY
72919: LIST
72920: LIST
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: LIST
72926: PPUSH
72927: CALL_OW 72
72931: ST_TO_ADDR
// if barracks then
72932: LD_VAR 0 8
72936: IFFALSE 73084
// begin selected := 0 ;
72938: LD_ADDR_VAR 0 7
72942: PUSH
72943: LD_INT 0
72945: ST_TO_ADDR
// for j in barracks do
72946: LD_ADDR_VAR 0 3
72950: PUSH
72951: LD_VAR 0 8
72955: PUSH
72956: FOR_IN
72957: IFFALSE 72988
// begin if UnitsInside ( j ) < 6 then
72959: LD_VAR 0 3
72963: PPUSH
72964: CALL_OW 313
72968: PUSH
72969: LD_INT 6
72971: LESS
72972: IFFALSE 72986
// begin selected := j ;
72974: LD_ADDR_VAR 0 7
72978: PUSH
72979: LD_VAR 0 3
72983: ST_TO_ADDR
// break ;
72984: GO 72988
// end ; end ;
72986: GO 72956
72988: POP
72989: POP
// if selected then
72990: LD_VAR 0 7
72994: IFFALSE 73084
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72996: LD_ADDR_VAR 0 3
73000: PUSH
73001: LD_EXP 81
73005: PUSH
73006: LD_VAR 0 2
73010: ARRAY
73011: PPUSH
73012: LD_INT 25
73014: PUSH
73015: LD_INT 12
73017: PUSH
73018: EMPTY
73019: LIST
73020: LIST
73021: PPUSH
73022: CALL_OW 72
73026: PUSH
73027: FOR_IN
73028: IFFALSE 73082
// if not IsInUnit ( j ) and not HasTask ( j ) then
73030: LD_VAR 0 3
73034: PPUSH
73035: CALL_OW 310
73039: NOT
73040: PUSH
73041: LD_VAR 0 3
73045: PPUSH
73046: CALL_OW 314
73050: NOT
73051: AND
73052: IFFALSE 73080
// begin ComEnterUnit ( j , selected ) ;
73054: LD_VAR 0 3
73058: PPUSH
73059: LD_VAR 0 7
73063: PPUSH
73064: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
73068: LD_VAR 0 3
73072: PPUSH
73073: LD_INT 15
73075: PPUSH
73076: CALL_OW 183
// end ;
73080: GO 73027
73082: POP
73083: POP
// end ; end ; end ; end ; end ;
73084: GO 72477
73086: POP
73087: POP
// end ;
73088: LD_VAR 0 1
73092: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
73093: LD_INT 0
73095: PPUSH
73096: PPUSH
73097: PPUSH
73098: PPUSH
// if not mc_bases then
73099: LD_EXP 52
73103: NOT
73104: IFFALSE 73108
// exit ;
73106: GO 73286
// for i = 1 to mc_bases do
73108: LD_ADDR_VAR 0 2
73112: PUSH
73113: DOUBLE
73114: LD_INT 1
73116: DEC
73117: ST_TO_ADDR
73118: LD_EXP 52
73122: PUSH
73123: FOR_TO
73124: IFFALSE 73284
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
73126: LD_ADDR_VAR 0 4
73130: PUSH
73131: LD_EXP 52
73135: PUSH
73136: LD_VAR 0 2
73140: ARRAY
73141: PPUSH
73142: LD_INT 25
73144: PUSH
73145: LD_INT 9
73147: PUSH
73148: EMPTY
73149: LIST
73150: LIST
73151: PPUSH
73152: CALL_OW 72
73156: ST_TO_ADDR
// if not tmp then
73157: LD_VAR 0 4
73161: NOT
73162: IFFALSE 73166
// continue ;
73164: GO 73123
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
73166: LD_EXP 78
73170: PUSH
73171: LD_VAR 0 2
73175: ARRAY
73176: PPUSH
73177: LD_INT 29
73179: PPUSH
73180: CALL_OW 325
73184: NOT
73185: PUSH
73186: LD_EXP 78
73190: PUSH
73191: LD_VAR 0 2
73195: ARRAY
73196: PPUSH
73197: LD_INT 28
73199: PPUSH
73200: CALL_OW 325
73204: NOT
73205: AND
73206: IFFALSE 73210
// continue ;
73208: GO 73123
// for j in tmp do
73210: LD_ADDR_VAR 0 3
73214: PUSH
73215: LD_VAR 0 4
73219: PUSH
73220: FOR_IN
73221: IFFALSE 73280
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73223: LD_VAR 0 3
73227: PUSH
73228: LD_EXP 55
73232: PUSH
73233: LD_VAR 0 2
73237: ARRAY
73238: PUSH
73239: LD_INT 1
73241: ARRAY
73242: IN
73243: NOT
73244: PUSH
73245: LD_VAR 0 3
73249: PUSH
73250: LD_EXP 55
73254: PUSH
73255: LD_VAR 0 2
73259: ARRAY
73260: PUSH
73261: LD_INT 2
73263: ARRAY
73264: IN
73265: NOT
73266: AND
73267: IFFALSE 73278
// ComSpaceTimeShoot ( j ) ;
73269: LD_VAR 0 3
73273: PPUSH
73274: CALL 11906 0 1
73278: GO 73220
73280: POP
73281: POP
// end ;
73282: GO 73123
73284: POP
73285: POP
// end ;
73286: LD_VAR 0 1
73290: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
73291: LD_INT 0
73293: PPUSH
73294: PPUSH
73295: PPUSH
73296: PPUSH
73297: PPUSH
73298: PPUSH
73299: PPUSH
73300: PPUSH
73301: PPUSH
// if not mc_bases then
73302: LD_EXP 52
73306: NOT
73307: IFFALSE 73311
// exit ;
73309: GO 73933
// for i = 1 to mc_bases do
73311: LD_ADDR_VAR 0 2
73315: PUSH
73316: DOUBLE
73317: LD_INT 1
73319: DEC
73320: ST_TO_ADDR
73321: LD_EXP 52
73325: PUSH
73326: FOR_TO
73327: IFFALSE 73931
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
73329: LD_EXP 87
73333: PUSH
73334: LD_VAR 0 2
73338: ARRAY
73339: NOT
73340: PUSH
73341: LD_INT 38
73343: PPUSH
73344: LD_EXP 78
73348: PUSH
73349: LD_VAR 0 2
73353: ARRAY
73354: PPUSH
73355: CALL_OW 321
73359: PUSH
73360: LD_INT 2
73362: NONEQUAL
73363: OR
73364: IFFALSE 73368
// continue ;
73366: GO 73326
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
73368: LD_ADDR_VAR 0 8
73372: PUSH
73373: LD_EXP 52
73377: PUSH
73378: LD_VAR 0 2
73382: ARRAY
73383: PPUSH
73384: LD_INT 30
73386: PUSH
73387: LD_INT 34
73389: PUSH
73390: EMPTY
73391: LIST
73392: LIST
73393: PPUSH
73394: CALL_OW 72
73398: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
73399: LD_ADDR_VAR 0 9
73403: PUSH
73404: LD_EXP 52
73408: PUSH
73409: LD_VAR 0 2
73413: ARRAY
73414: PPUSH
73415: LD_INT 25
73417: PUSH
73418: LD_INT 4
73420: PUSH
73421: EMPTY
73422: LIST
73423: LIST
73424: PPUSH
73425: CALL_OW 72
73429: PPUSH
73430: LD_INT 0
73432: PPUSH
73433: CALL 51076 0 2
73437: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
73438: LD_VAR 0 9
73442: NOT
73443: PUSH
73444: LD_VAR 0 8
73448: NOT
73449: OR
73450: PUSH
73451: LD_EXP 52
73455: PUSH
73456: LD_VAR 0 2
73460: ARRAY
73461: PPUSH
73462: LD_INT 124
73464: PPUSH
73465: CALL 51076 0 2
73469: OR
73470: IFFALSE 73474
// continue ;
73472: GO 73326
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
73474: LD_EXP 88
73478: PUSH
73479: LD_VAR 0 2
73483: ARRAY
73484: PUSH
73485: LD_EXP 87
73489: PUSH
73490: LD_VAR 0 2
73494: ARRAY
73495: LESS
73496: PUSH
73497: LD_EXP 88
73501: PUSH
73502: LD_VAR 0 2
73506: ARRAY
73507: PUSH
73508: LD_VAR 0 8
73512: LESS
73513: AND
73514: IFFALSE 73929
// begin tmp := sci [ 1 ] ;
73516: LD_ADDR_VAR 0 7
73520: PUSH
73521: LD_VAR 0 9
73525: PUSH
73526: LD_INT 1
73528: ARRAY
73529: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
73530: LD_VAR 0 7
73534: PPUSH
73535: LD_INT 124
73537: PPUSH
73538: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
73542: LD_ADDR_VAR 0 3
73546: PUSH
73547: DOUBLE
73548: LD_EXP 87
73552: PUSH
73553: LD_VAR 0 2
73557: ARRAY
73558: INC
73559: ST_TO_ADDR
73560: LD_EXP 87
73564: PUSH
73565: LD_VAR 0 2
73569: ARRAY
73570: PUSH
73571: FOR_DOWNTO
73572: IFFALSE 73915
// begin if IsInUnit ( tmp ) then
73574: LD_VAR 0 7
73578: PPUSH
73579: CALL_OW 310
73583: IFFALSE 73594
// ComExitBuilding ( tmp ) ;
73585: LD_VAR 0 7
73589: PPUSH
73590: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
73594: LD_INT 35
73596: PPUSH
73597: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
73601: LD_VAR 0 7
73605: PPUSH
73606: CALL_OW 310
73610: NOT
73611: PUSH
73612: LD_VAR 0 7
73616: PPUSH
73617: CALL_OW 314
73621: NOT
73622: AND
73623: IFFALSE 73594
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
73625: LD_ADDR_VAR 0 6
73629: PUSH
73630: LD_VAR 0 7
73634: PPUSH
73635: CALL_OW 250
73639: PUSH
73640: LD_VAR 0 7
73644: PPUSH
73645: CALL_OW 251
73649: PUSH
73650: EMPTY
73651: LIST
73652: LIST
73653: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
73654: LD_INT 35
73656: PPUSH
73657: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
73661: LD_ADDR_VAR 0 4
73665: PUSH
73666: LD_EXP 87
73670: PUSH
73671: LD_VAR 0 2
73675: ARRAY
73676: PUSH
73677: LD_VAR 0 3
73681: ARRAY
73682: PUSH
73683: LD_INT 1
73685: ARRAY
73686: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
73687: LD_ADDR_VAR 0 5
73691: PUSH
73692: LD_EXP 87
73696: PUSH
73697: LD_VAR 0 2
73701: ARRAY
73702: PUSH
73703: LD_VAR 0 3
73707: ARRAY
73708: PUSH
73709: LD_INT 2
73711: ARRAY
73712: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
73713: LD_VAR 0 7
73717: PPUSH
73718: LD_INT 10
73720: PPUSH
73721: CALL 20409 0 2
73725: PUSH
73726: LD_INT 4
73728: ARRAY
73729: IFFALSE 73767
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
73731: LD_VAR 0 7
73735: PPUSH
73736: LD_VAR 0 6
73740: PUSH
73741: LD_INT 1
73743: ARRAY
73744: PPUSH
73745: LD_VAR 0 6
73749: PUSH
73750: LD_INT 2
73752: ARRAY
73753: PPUSH
73754: CALL_OW 111
// wait ( 0 0$10 ) ;
73758: LD_INT 350
73760: PPUSH
73761: CALL_OW 67
// end else
73765: GO 73793
// begin ComMoveXY ( tmp , x , y ) ;
73767: LD_VAR 0 7
73771: PPUSH
73772: LD_VAR 0 4
73776: PPUSH
73777: LD_VAR 0 5
73781: PPUSH
73782: CALL_OW 111
// wait ( 0 0$3 ) ;
73786: LD_INT 105
73788: PPUSH
73789: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
73793: LD_VAR 0 7
73797: PPUSH
73798: LD_VAR 0 4
73802: PPUSH
73803: LD_VAR 0 5
73807: PPUSH
73808: CALL_OW 307
73812: IFFALSE 73654
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
73814: LD_VAR 0 7
73818: PPUSH
73819: LD_VAR 0 4
73823: PPUSH
73824: LD_VAR 0 5
73828: PPUSH
73829: LD_VAR 0 8
73833: PUSH
73834: LD_VAR 0 3
73838: ARRAY
73839: PPUSH
73840: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
73844: LD_INT 35
73846: PPUSH
73847: CALL_OW 67
// until not HasTask ( tmp ) ;
73851: LD_VAR 0 7
73855: PPUSH
73856: CALL_OW 314
73860: NOT
73861: IFFALSE 73844
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
73863: LD_ADDR_EXP 88
73867: PUSH
73868: LD_EXP 88
73872: PPUSH
73873: LD_VAR 0 2
73877: PUSH
73878: LD_EXP 88
73882: PUSH
73883: LD_VAR 0 2
73887: ARRAY
73888: PUSH
73889: LD_INT 1
73891: PLUS
73892: PUSH
73893: EMPTY
73894: LIST
73895: LIST
73896: PPUSH
73897: LD_VAR 0 8
73901: PUSH
73902: LD_VAR 0 3
73906: ARRAY
73907: PPUSH
73908: CALL 17816 0 3
73912: ST_TO_ADDR
// end ;
73913: GO 73571
73915: POP
73916: POP
// MC_Reset ( i , 124 ) ;
73917: LD_VAR 0 2
73921: PPUSH
73922: LD_INT 124
73924: PPUSH
73925: CALL 57778 0 2
// end ; end ;
73929: GO 73326
73931: POP
73932: POP
// end ;
73933: LD_VAR 0 1
73937: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
73938: LD_INT 0
73940: PPUSH
73941: PPUSH
73942: PPUSH
// if not mc_bases then
73943: LD_EXP 52
73947: NOT
73948: IFFALSE 73952
// exit ;
73950: GO 74558
// for i = 1 to mc_bases do
73952: LD_ADDR_VAR 0 2
73956: PUSH
73957: DOUBLE
73958: LD_INT 1
73960: DEC
73961: ST_TO_ADDR
73962: LD_EXP 52
73966: PUSH
73967: FOR_TO
73968: IFFALSE 74556
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
73970: LD_ADDR_VAR 0 3
73974: PUSH
73975: LD_EXP 52
73979: PUSH
73980: LD_VAR 0 2
73984: ARRAY
73985: PPUSH
73986: LD_INT 25
73988: PUSH
73989: LD_INT 4
73991: PUSH
73992: EMPTY
73993: LIST
73994: LIST
73995: PPUSH
73996: CALL_OW 72
74000: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
74001: LD_VAR 0 3
74005: NOT
74006: PUSH
74007: LD_EXP 89
74011: PUSH
74012: LD_VAR 0 2
74016: ARRAY
74017: NOT
74018: OR
74019: PUSH
74020: LD_EXP 52
74024: PUSH
74025: LD_VAR 0 2
74029: ARRAY
74030: PPUSH
74031: LD_INT 2
74033: PUSH
74034: LD_INT 30
74036: PUSH
74037: LD_INT 0
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: PUSH
74044: LD_INT 30
74046: PUSH
74047: LD_INT 1
74049: PUSH
74050: EMPTY
74051: LIST
74052: LIST
74053: PUSH
74054: EMPTY
74055: LIST
74056: LIST
74057: LIST
74058: PPUSH
74059: CALL_OW 72
74063: NOT
74064: OR
74065: IFFALSE 74115
// begin if mc_deposits_finder [ i ] then
74067: LD_EXP 90
74071: PUSH
74072: LD_VAR 0 2
74076: ARRAY
74077: IFFALSE 74113
// begin MC_Reset ( i , 125 ) ;
74079: LD_VAR 0 2
74083: PPUSH
74084: LD_INT 125
74086: PPUSH
74087: CALL 57778 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74091: LD_ADDR_EXP 90
74095: PUSH
74096: LD_EXP 90
74100: PPUSH
74101: LD_VAR 0 2
74105: PPUSH
74106: EMPTY
74107: PPUSH
74108: CALL_OW 1
74112: ST_TO_ADDR
// end ; continue ;
74113: GO 73967
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
74115: LD_EXP 89
74119: PUSH
74120: LD_VAR 0 2
74124: ARRAY
74125: PUSH
74126: LD_INT 1
74128: ARRAY
74129: PUSH
74130: LD_INT 3
74132: ARRAY
74133: PUSH
74134: LD_INT 1
74136: EQUAL
74137: PUSH
74138: LD_INT 20
74140: PPUSH
74141: LD_EXP 78
74145: PUSH
74146: LD_VAR 0 2
74150: ARRAY
74151: PPUSH
74152: CALL_OW 321
74156: PUSH
74157: LD_INT 2
74159: NONEQUAL
74160: AND
74161: IFFALSE 74211
// begin if mc_deposits_finder [ i ] then
74163: LD_EXP 90
74167: PUSH
74168: LD_VAR 0 2
74172: ARRAY
74173: IFFALSE 74209
// begin MC_Reset ( i , 125 ) ;
74175: LD_VAR 0 2
74179: PPUSH
74180: LD_INT 125
74182: PPUSH
74183: CALL 57778 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74187: LD_ADDR_EXP 90
74191: PUSH
74192: LD_EXP 90
74196: PPUSH
74197: LD_VAR 0 2
74201: PPUSH
74202: EMPTY
74203: PPUSH
74204: CALL_OW 1
74208: ST_TO_ADDR
// end ; continue ;
74209: GO 73967
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
74211: LD_EXP 89
74215: PUSH
74216: LD_VAR 0 2
74220: ARRAY
74221: PUSH
74222: LD_INT 1
74224: ARRAY
74225: PUSH
74226: LD_INT 1
74228: ARRAY
74229: PPUSH
74230: LD_EXP 89
74234: PUSH
74235: LD_VAR 0 2
74239: ARRAY
74240: PUSH
74241: LD_INT 1
74243: ARRAY
74244: PUSH
74245: LD_INT 2
74247: ARRAY
74248: PPUSH
74249: LD_EXP 78
74253: PUSH
74254: LD_VAR 0 2
74258: ARRAY
74259: PPUSH
74260: CALL_OW 440
74264: IFFALSE 74307
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
74266: LD_ADDR_EXP 89
74270: PUSH
74271: LD_EXP 89
74275: PPUSH
74276: LD_VAR 0 2
74280: PPUSH
74281: LD_EXP 89
74285: PUSH
74286: LD_VAR 0 2
74290: ARRAY
74291: PPUSH
74292: LD_INT 1
74294: PPUSH
74295: CALL_OW 3
74299: PPUSH
74300: CALL_OW 1
74304: ST_TO_ADDR
74305: GO 74554
// begin if not mc_deposits_finder [ i ] then
74307: LD_EXP 90
74311: PUSH
74312: LD_VAR 0 2
74316: ARRAY
74317: NOT
74318: IFFALSE 74370
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
74320: LD_ADDR_EXP 90
74324: PUSH
74325: LD_EXP 90
74329: PPUSH
74330: LD_VAR 0 2
74334: PPUSH
74335: LD_VAR 0 3
74339: PUSH
74340: LD_INT 1
74342: ARRAY
74343: PUSH
74344: EMPTY
74345: LIST
74346: PPUSH
74347: CALL_OW 1
74351: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
74352: LD_VAR 0 3
74356: PUSH
74357: LD_INT 1
74359: ARRAY
74360: PPUSH
74361: LD_INT 125
74363: PPUSH
74364: CALL_OW 109
// end else
74368: GO 74554
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
74370: LD_EXP 90
74374: PUSH
74375: LD_VAR 0 2
74379: ARRAY
74380: PUSH
74381: LD_INT 1
74383: ARRAY
74384: PPUSH
74385: CALL_OW 310
74389: IFFALSE 74412
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
74391: LD_EXP 90
74395: PUSH
74396: LD_VAR 0 2
74400: ARRAY
74401: PUSH
74402: LD_INT 1
74404: ARRAY
74405: PPUSH
74406: CALL_OW 122
74410: GO 74554
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
74412: LD_EXP 90
74416: PUSH
74417: LD_VAR 0 2
74421: ARRAY
74422: PUSH
74423: LD_INT 1
74425: ARRAY
74426: PPUSH
74427: CALL_OW 314
74431: NOT
74432: PUSH
74433: LD_EXP 90
74437: PUSH
74438: LD_VAR 0 2
74442: ARRAY
74443: PUSH
74444: LD_INT 1
74446: ARRAY
74447: PPUSH
74448: LD_EXP 89
74452: PUSH
74453: LD_VAR 0 2
74457: ARRAY
74458: PUSH
74459: LD_INT 1
74461: ARRAY
74462: PUSH
74463: LD_INT 1
74465: ARRAY
74466: PPUSH
74467: LD_EXP 89
74471: PUSH
74472: LD_VAR 0 2
74476: ARRAY
74477: PUSH
74478: LD_INT 1
74480: ARRAY
74481: PUSH
74482: LD_INT 2
74484: ARRAY
74485: PPUSH
74486: CALL_OW 297
74490: PUSH
74491: LD_INT 6
74493: GREATER
74494: AND
74495: IFFALSE 74554
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
74497: LD_EXP 90
74501: PUSH
74502: LD_VAR 0 2
74506: ARRAY
74507: PUSH
74508: LD_INT 1
74510: ARRAY
74511: PPUSH
74512: LD_EXP 89
74516: PUSH
74517: LD_VAR 0 2
74521: ARRAY
74522: PUSH
74523: LD_INT 1
74525: ARRAY
74526: PUSH
74527: LD_INT 1
74529: ARRAY
74530: PPUSH
74531: LD_EXP 89
74535: PUSH
74536: LD_VAR 0 2
74540: ARRAY
74541: PUSH
74542: LD_INT 1
74544: ARRAY
74545: PUSH
74546: LD_INT 2
74548: ARRAY
74549: PPUSH
74550: CALL_OW 111
// end ; end ; end ;
74554: GO 73967
74556: POP
74557: POP
// end ;
74558: LD_VAR 0 1
74562: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
74563: LD_INT 0
74565: PPUSH
74566: PPUSH
74567: PPUSH
74568: PPUSH
74569: PPUSH
74570: PPUSH
74571: PPUSH
74572: PPUSH
74573: PPUSH
74574: PPUSH
74575: PPUSH
// if not mc_bases then
74576: LD_EXP 52
74580: NOT
74581: IFFALSE 74585
// exit ;
74583: GO 75309
// for i = 1 to mc_bases do
74585: LD_ADDR_VAR 0 2
74589: PUSH
74590: DOUBLE
74591: LD_INT 1
74593: DEC
74594: ST_TO_ADDR
74595: LD_EXP 52
74599: PUSH
74600: FOR_TO
74601: IFFALSE 75307
// begin if not mc_bases [ i ] then
74603: LD_EXP 52
74607: PUSH
74608: LD_VAR 0 2
74612: ARRAY
74613: NOT
74614: IFFALSE 74618
// continue ;
74616: GO 74600
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
74618: LD_ADDR_VAR 0 7
74622: PUSH
74623: LD_EXP 52
74627: PUSH
74628: LD_VAR 0 2
74632: ARRAY
74633: PUSH
74634: LD_INT 1
74636: ARRAY
74637: PPUSH
74638: CALL_OW 248
74642: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
74643: LD_VAR 0 7
74647: PUSH
74648: LD_INT 3
74650: EQUAL
74651: PUSH
74652: LD_EXP 71
74656: PUSH
74657: LD_VAR 0 2
74661: ARRAY
74662: PUSH
74663: LD_EXP 74
74667: PUSH
74668: LD_VAR 0 2
74672: ARRAY
74673: UNION
74674: PPUSH
74675: LD_INT 33
74677: PUSH
74678: LD_INT 2
74680: PUSH
74681: EMPTY
74682: LIST
74683: LIST
74684: PPUSH
74685: CALL_OW 72
74689: NOT
74690: OR
74691: IFFALSE 74695
// continue ;
74693: GO 74600
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
74695: LD_ADDR_VAR 0 9
74699: PUSH
74700: LD_EXP 52
74704: PUSH
74705: LD_VAR 0 2
74709: ARRAY
74710: PPUSH
74711: LD_INT 30
74713: PUSH
74714: LD_INT 36
74716: PUSH
74717: EMPTY
74718: LIST
74719: LIST
74720: PPUSH
74721: CALL_OW 72
74725: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
74726: LD_ADDR_VAR 0 10
74730: PUSH
74731: LD_EXP 71
74735: PUSH
74736: LD_VAR 0 2
74740: ARRAY
74741: PPUSH
74742: LD_INT 34
74744: PUSH
74745: LD_INT 31
74747: PUSH
74748: EMPTY
74749: LIST
74750: LIST
74751: PPUSH
74752: CALL_OW 72
74756: ST_TO_ADDR
// if not cts and not mcts then
74757: LD_VAR 0 9
74761: NOT
74762: PUSH
74763: LD_VAR 0 10
74767: NOT
74768: AND
74769: IFFALSE 74773
// continue ;
74771: GO 74600
// x := cts ;
74773: LD_ADDR_VAR 0 11
74777: PUSH
74778: LD_VAR 0 9
74782: ST_TO_ADDR
// if not x then
74783: LD_VAR 0 11
74787: NOT
74788: IFFALSE 74800
// x := mcts ;
74790: LD_ADDR_VAR 0 11
74794: PUSH
74795: LD_VAR 0 10
74799: ST_TO_ADDR
// if mc_remote_driver [ i ] then
74800: LD_EXP 92
74804: PUSH
74805: LD_VAR 0 2
74809: ARRAY
74810: IFFALSE 75079
// for j in mc_remote_driver [ i ] do
74812: LD_ADDR_VAR 0 3
74816: PUSH
74817: LD_EXP 92
74821: PUSH
74822: LD_VAR 0 2
74826: ARRAY
74827: PUSH
74828: FOR_IN
74829: IFFALSE 75077
// begin if GetClass ( j ) <> 3 then
74831: LD_VAR 0 3
74835: PPUSH
74836: CALL_OW 257
74840: PUSH
74841: LD_INT 3
74843: NONEQUAL
74844: IFFALSE 74897
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
74846: LD_ADDR_EXP 92
74850: PUSH
74851: LD_EXP 92
74855: PPUSH
74856: LD_VAR 0 2
74860: PPUSH
74861: LD_EXP 92
74865: PUSH
74866: LD_VAR 0 2
74870: ARRAY
74871: PUSH
74872: LD_VAR 0 3
74876: DIFF
74877: PPUSH
74878: CALL_OW 1
74882: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74883: LD_VAR 0 3
74887: PPUSH
74888: LD_INT 0
74890: PPUSH
74891: CALL_OW 109
// continue ;
74895: GO 74828
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
74897: LD_VAR 0 3
74901: PPUSH
74902: CALL_OW 310
74906: NOT
74907: PUSH
74908: LD_VAR 0 3
74912: PPUSH
74913: CALL_OW 310
74917: PPUSH
74918: CALL_OW 266
74922: PUSH
74923: LD_INT 36
74925: NONEQUAL
74926: PUSH
74927: LD_VAR 0 3
74931: PPUSH
74932: CALL 51164 0 1
74936: NOT
74937: AND
74938: OR
74939: IFFALSE 75075
// begin if IsInUnit ( j ) then
74941: LD_VAR 0 3
74945: PPUSH
74946: CALL_OW 310
74950: IFFALSE 74961
// ComExitBuilding ( j ) ;
74952: LD_VAR 0 3
74956: PPUSH
74957: CALL_OW 122
// ct := 0 ;
74961: LD_ADDR_VAR 0 8
74965: PUSH
74966: LD_INT 0
74968: ST_TO_ADDR
// for k in x do
74969: LD_ADDR_VAR 0 4
74973: PUSH
74974: LD_VAR 0 11
74978: PUSH
74979: FOR_IN
74980: IFFALSE 75053
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
74982: LD_VAR 0 4
74986: PPUSH
74987: CALL_OW 264
74991: PUSH
74992: LD_INT 31
74994: EQUAL
74995: PUSH
74996: LD_VAR 0 4
75000: PPUSH
75001: CALL_OW 311
75005: NOT
75006: AND
75007: PUSH
75008: LD_VAR 0 4
75012: PPUSH
75013: CALL_OW 266
75017: PUSH
75018: LD_INT 36
75020: EQUAL
75021: PUSH
75022: LD_VAR 0 4
75026: PPUSH
75027: CALL_OW 313
75031: PUSH
75032: LD_INT 3
75034: LESS
75035: AND
75036: OR
75037: IFFALSE 75051
// begin ct := k ;
75039: LD_ADDR_VAR 0 8
75043: PUSH
75044: LD_VAR 0 4
75048: ST_TO_ADDR
// break ;
75049: GO 75053
// end ;
75051: GO 74979
75053: POP
75054: POP
// if ct then
75055: LD_VAR 0 8
75059: IFFALSE 75075
// ComEnterUnit ( j , ct ) ;
75061: LD_VAR 0 3
75065: PPUSH
75066: LD_VAR 0 8
75070: PPUSH
75071: CALL_OW 120
// end ; end ;
75075: GO 74828
75077: POP
75078: POP
// places := 0 ;
75079: LD_ADDR_VAR 0 5
75083: PUSH
75084: LD_INT 0
75086: ST_TO_ADDR
// for j = 1 to x do
75087: LD_ADDR_VAR 0 3
75091: PUSH
75092: DOUBLE
75093: LD_INT 1
75095: DEC
75096: ST_TO_ADDR
75097: LD_VAR 0 11
75101: PUSH
75102: FOR_TO
75103: IFFALSE 75158
// if GetWeapon ( x [ j ] ) = ar_control_tower then
75105: LD_VAR 0 11
75109: PUSH
75110: LD_VAR 0 3
75114: ARRAY
75115: PPUSH
75116: CALL_OW 264
75120: PUSH
75121: LD_INT 31
75123: EQUAL
75124: IFFALSE 75142
// places := places + 1 else
75126: LD_ADDR_VAR 0 5
75130: PUSH
75131: LD_VAR 0 5
75135: PUSH
75136: LD_INT 1
75138: PLUS
75139: ST_TO_ADDR
75140: GO 75156
// places := places + 3 ;
75142: LD_ADDR_VAR 0 5
75146: PUSH
75147: LD_VAR 0 5
75151: PUSH
75152: LD_INT 3
75154: PLUS
75155: ST_TO_ADDR
75156: GO 75102
75158: POP
75159: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
75160: LD_ADDR_VAR 0 6
75164: PUSH
75165: LD_EXP 52
75169: PUSH
75170: LD_VAR 0 2
75174: ARRAY
75175: PPUSH
75176: LD_INT 25
75178: PUSH
75179: LD_INT 3
75181: PUSH
75182: EMPTY
75183: LIST
75184: LIST
75185: PPUSH
75186: CALL_OW 72
75190: PUSH
75191: LD_EXP 92
75195: PUSH
75196: LD_VAR 0 2
75200: ARRAY
75201: DIFF
75202: PPUSH
75203: LD_INT 3
75205: PPUSH
75206: CALL 52064 0 2
75210: ST_TO_ADDR
// if not tmp then
75211: LD_VAR 0 6
75215: NOT
75216: IFFALSE 75220
// continue ;
75218: GO 74600
// places := places - mc_remote_driver [ i ] ;
75220: LD_ADDR_VAR 0 5
75224: PUSH
75225: LD_VAR 0 5
75229: PUSH
75230: LD_EXP 92
75234: PUSH
75235: LD_VAR 0 2
75239: ARRAY
75240: MINUS
75241: ST_TO_ADDR
// if places then
75242: LD_VAR 0 5
75246: IFFALSE 75305
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
75248: LD_ADDR_EXP 92
75252: PUSH
75253: LD_EXP 92
75257: PPUSH
75258: LD_VAR 0 2
75262: PPUSH
75263: LD_EXP 92
75267: PUSH
75268: LD_VAR 0 2
75272: ARRAY
75273: PUSH
75274: LD_VAR 0 6
75278: PUSH
75279: LD_INT 1
75281: ARRAY
75282: UNION
75283: PPUSH
75284: CALL_OW 1
75288: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
75289: LD_VAR 0 6
75293: PUSH
75294: LD_INT 1
75296: ARRAY
75297: PPUSH
75298: LD_INT 126
75300: PPUSH
75301: CALL_OW 109
// end ; end ;
75305: GO 74600
75307: POP
75308: POP
// end ;
75309: LD_VAR 0 1
75313: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
75314: LD_INT 0
75316: PPUSH
75317: PPUSH
75318: PPUSH
75319: PPUSH
75320: PPUSH
75321: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
75322: LD_VAR 0 1
75326: NOT
75327: PUSH
75328: LD_VAR 0 2
75332: NOT
75333: OR
75334: PUSH
75335: LD_VAR 0 3
75339: NOT
75340: OR
75341: PUSH
75342: LD_VAR 0 4
75346: PUSH
75347: LD_INT 1
75349: PUSH
75350: LD_INT 2
75352: PUSH
75353: LD_INT 3
75355: PUSH
75356: LD_INT 4
75358: PUSH
75359: LD_INT 5
75361: PUSH
75362: LD_INT 8
75364: PUSH
75365: LD_INT 9
75367: PUSH
75368: LD_INT 15
75370: PUSH
75371: LD_INT 16
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: LIST
75378: LIST
75379: LIST
75380: LIST
75381: LIST
75382: LIST
75383: LIST
75384: IN
75385: NOT
75386: OR
75387: IFFALSE 75391
// exit ;
75389: GO 76291
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
75391: LD_ADDR_VAR 0 2
75395: PUSH
75396: LD_VAR 0 2
75400: PPUSH
75401: LD_INT 21
75403: PUSH
75404: LD_INT 3
75406: PUSH
75407: EMPTY
75408: LIST
75409: LIST
75410: PUSH
75411: LD_INT 24
75413: PUSH
75414: LD_INT 250
75416: PUSH
75417: EMPTY
75418: LIST
75419: LIST
75420: PUSH
75421: EMPTY
75422: LIST
75423: LIST
75424: PPUSH
75425: CALL_OW 72
75429: ST_TO_ADDR
// case class of 1 , 15 :
75430: LD_VAR 0 4
75434: PUSH
75435: LD_INT 1
75437: DOUBLE
75438: EQUAL
75439: IFTRUE 75449
75441: LD_INT 15
75443: DOUBLE
75444: EQUAL
75445: IFTRUE 75449
75447: GO 75534
75449: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
75450: LD_ADDR_VAR 0 8
75454: PUSH
75455: LD_VAR 0 2
75459: PPUSH
75460: LD_INT 2
75462: PUSH
75463: LD_INT 30
75465: PUSH
75466: LD_INT 32
75468: PUSH
75469: EMPTY
75470: LIST
75471: LIST
75472: PUSH
75473: LD_INT 30
75475: PUSH
75476: LD_INT 31
75478: PUSH
75479: EMPTY
75480: LIST
75481: LIST
75482: PUSH
75483: EMPTY
75484: LIST
75485: LIST
75486: LIST
75487: PPUSH
75488: CALL_OW 72
75492: PUSH
75493: LD_VAR 0 2
75497: PPUSH
75498: LD_INT 2
75500: PUSH
75501: LD_INT 30
75503: PUSH
75504: LD_INT 4
75506: PUSH
75507: EMPTY
75508: LIST
75509: LIST
75510: PUSH
75511: LD_INT 30
75513: PUSH
75514: LD_INT 5
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: PUSH
75521: EMPTY
75522: LIST
75523: LIST
75524: LIST
75525: PPUSH
75526: CALL_OW 72
75530: ADD
75531: ST_TO_ADDR
75532: GO 75780
75534: LD_INT 2
75536: DOUBLE
75537: EQUAL
75538: IFTRUE 75548
75540: LD_INT 16
75542: DOUBLE
75543: EQUAL
75544: IFTRUE 75548
75546: GO 75594
75548: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
75549: LD_ADDR_VAR 0 8
75553: PUSH
75554: LD_VAR 0 2
75558: PPUSH
75559: LD_INT 2
75561: PUSH
75562: LD_INT 30
75564: PUSH
75565: LD_INT 0
75567: PUSH
75568: EMPTY
75569: LIST
75570: LIST
75571: PUSH
75572: LD_INT 30
75574: PUSH
75575: LD_INT 1
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: PUSH
75582: EMPTY
75583: LIST
75584: LIST
75585: LIST
75586: PPUSH
75587: CALL_OW 72
75591: ST_TO_ADDR
75592: GO 75780
75594: LD_INT 3
75596: DOUBLE
75597: EQUAL
75598: IFTRUE 75602
75600: GO 75648
75602: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
75603: LD_ADDR_VAR 0 8
75607: PUSH
75608: LD_VAR 0 2
75612: PPUSH
75613: LD_INT 2
75615: PUSH
75616: LD_INT 30
75618: PUSH
75619: LD_INT 2
75621: PUSH
75622: EMPTY
75623: LIST
75624: LIST
75625: PUSH
75626: LD_INT 30
75628: PUSH
75629: LD_INT 3
75631: PUSH
75632: EMPTY
75633: LIST
75634: LIST
75635: PUSH
75636: EMPTY
75637: LIST
75638: LIST
75639: LIST
75640: PPUSH
75641: CALL_OW 72
75645: ST_TO_ADDR
75646: GO 75780
75648: LD_INT 4
75650: DOUBLE
75651: EQUAL
75652: IFTRUE 75656
75654: GO 75713
75656: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
75657: LD_ADDR_VAR 0 8
75661: PUSH
75662: LD_VAR 0 2
75666: PPUSH
75667: LD_INT 2
75669: PUSH
75670: LD_INT 30
75672: PUSH
75673: LD_INT 6
75675: PUSH
75676: EMPTY
75677: LIST
75678: LIST
75679: PUSH
75680: LD_INT 30
75682: PUSH
75683: LD_INT 7
75685: PUSH
75686: EMPTY
75687: LIST
75688: LIST
75689: PUSH
75690: LD_INT 30
75692: PUSH
75693: LD_INT 8
75695: PUSH
75696: EMPTY
75697: LIST
75698: LIST
75699: PUSH
75700: EMPTY
75701: LIST
75702: LIST
75703: LIST
75704: LIST
75705: PPUSH
75706: CALL_OW 72
75710: ST_TO_ADDR
75711: GO 75780
75713: LD_INT 5
75715: DOUBLE
75716: EQUAL
75717: IFTRUE 75733
75719: LD_INT 8
75721: DOUBLE
75722: EQUAL
75723: IFTRUE 75733
75725: LD_INT 9
75727: DOUBLE
75728: EQUAL
75729: IFTRUE 75733
75731: GO 75779
75733: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
75734: LD_ADDR_VAR 0 8
75738: PUSH
75739: LD_VAR 0 2
75743: PPUSH
75744: LD_INT 2
75746: PUSH
75747: LD_INT 30
75749: PUSH
75750: LD_INT 4
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: PUSH
75757: LD_INT 30
75759: PUSH
75760: LD_INT 5
75762: PUSH
75763: EMPTY
75764: LIST
75765: LIST
75766: PUSH
75767: EMPTY
75768: LIST
75769: LIST
75770: LIST
75771: PPUSH
75772: CALL_OW 72
75776: ST_TO_ADDR
75777: GO 75780
75779: POP
// if not tmp then
75780: LD_VAR 0 8
75784: NOT
75785: IFFALSE 75789
// exit ;
75787: GO 76291
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
75789: LD_VAR 0 4
75793: PUSH
75794: LD_INT 1
75796: PUSH
75797: LD_INT 15
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: IN
75804: PUSH
75805: LD_EXP 61
75809: PUSH
75810: LD_VAR 0 1
75814: ARRAY
75815: AND
75816: IFFALSE 75972
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
75818: LD_ADDR_VAR 0 9
75822: PUSH
75823: LD_EXP 61
75827: PUSH
75828: LD_VAR 0 1
75832: ARRAY
75833: PUSH
75834: LD_INT 1
75836: ARRAY
75837: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
75838: LD_VAR 0 9
75842: PUSH
75843: LD_EXP 62
75847: PUSH
75848: LD_VAR 0 1
75852: ARRAY
75853: IN
75854: NOT
75855: IFFALSE 75970
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
75857: LD_ADDR_EXP 62
75861: PUSH
75862: LD_EXP 62
75866: PPUSH
75867: LD_VAR 0 1
75871: PUSH
75872: LD_EXP 62
75876: PUSH
75877: LD_VAR 0 1
75881: ARRAY
75882: PUSH
75883: LD_INT 1
75885: PLUS
75886: PUSH
75887: EMPTY
75888: LIST
75889: LIST
75890: PPUSH
75891: LD_VAR 0 9
75895: PPUSH
75896: CALL 17816 0 3
75900: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
75901: LD_ADDR_EXP 61
75905: PUSH
75906: LD_EXP 61
75910: PPUSH
75911: LD_VAR 0 1
75915: PPUSH
75916: LD_EXP 61
75920: PUSH
75921: LD_VAR 0 1
75925: ARRAY
75926: PUSH
75927: LD_VAR 0 9
75931: DIFF
75932: PPUSH
75933: CALL_OW 1
75937: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
75938: LD_VAR 0 3
75942: PPUSH
75943: LD_EXP 62
75947: PUSH
75948: LD_VAR 0 1
75952: ARRAY
75953: PUSH
75954: LD_EXP 62
75958: PUSH
75959: LD_VAR 0 1
75963: ARRAY
75964: ARRAY
75965: PPUSH
75966: CALL_OW 120
// end ; exit ;
75970: GO 76291
// end ; if tmp > 1 then
75972: LD_VAR 0 8
75976: PUSH
75977: LD_INT 1
75979: GREATER
75980: IFFALSE 76084
// for i = 2 to tmp do
75982: LD_ADDR_VAR 0 6
75986: PUSH
75987: DOUBLE
75988: LD_INT 2
75990: DEC
75991: ST_TO_ADDR
75992: LD_VAR 0 8
75996: PUSH
75997: FOR_TO
75998: IFFALSE 76082
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
76000: LD_VAR 0 8
76004: PUSH
76005: LD_VAR 0 6
76009: ARRAY
76010: PPUSH
76011: CALL_OW 461
76015: PUSH
76016: LD_INT 6
76018: EQUAL
76019: IFFALSE 76080
// begin x := tmp [ i ] ;
76021: LD_ADDR_VAR 0 9
76025: PUSH
76026: LD_VAR 0 8
76030: PUSH
76031: LD_VAR 0 6
76035: ARRAY
76036: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
76037: LD_ADDR_VAR 0 8
76041: PUSH
76042: LD_VAR 0 8
76046: PPUSH
76047: LD_VAR 0 6
76051: PPUSH
76052: CALL_OW 3
76056: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
76057: LD_ADDR_VAR 0 8
76061: PUSH
76062: LD_VAR 0 8
76066: PPUSH
76067: LD_INT 1
76069: PPUSH
76070: LD_VAR 0 9
76074: PPUSH
76075: CALL_OW 2
76079: ST_TO_ADDR
// end ;
76080: GO 75997
76082: POP
76083: POP
// for i in tmp do
76084: LD_ADDR_VAR 0 6
76088: PUSH
76089: LD_VAR 0 8
76093: PUSH
76094: FOR_IN
76095: IFFALSE 76164
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
76097: LD_VAR 0 6
76101: PPUSH
76102: CALL_OW 313
76106: PUSH
76107: LD_INT 6
76109: LESS
76110: PUSH
76111: LD_VAR 0 6
76115: PPUSH
76116: CALL_OW 266
76120: PUSH
76121: LD_INT 31
76123: PUSH
76124: LD_INT 32
76126: PUSH
76127: EMPTY
76128: LIST
76129: LIST
76130: IN
76131: NOT
76132: AND
76133: PUSH
76134: LD_VAR 0 6
76138: PPUSH
76139: CALL_OW 313
76143: PUSH
76144: LD_INT 0
76146: EQUAL
76147: OR
76148: IFFALSE 76162
// begin j := i ;
76150: LD_ADDR_VAR 0 7
76154: PUSH
76155: LD_VAR 0 6
76159: ST_TO_ADDR
// break ;
76160: GO 76164
// end ; end ;
76162: GO 76094
76164: POP
76165: POP
// if j then
76166: LD_VAR 0 7
76170: IFFALSE 76188
// ComEnterUnit ( unit , j ) else
76172: LD_VAR 0 3
76176: PPUSH
76177: LD_VAR 0 7
76181: PPUSH
76182: CALL_OW 120
76186: GO 76291
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76188: LD_ADDR_VAR 0 10
76192: PUSH
76193: LD_VAR 0 2
76197: PPUSH
76198: LD_INT 2
76200: PUSH
76201: LD_INT 30
76203: PUSH
76204: LD_INT 0
76206: PUSH
76207: EMPTY
76208: LIST
76209: LIST
76210: PUSH
76211: LD_INT 30
76213: PUSH
76214: LD_INT 1
76216: PUSH
76217: EMPTY
76218: LIST
76219: LIST
76220: PUSH
76221: EMPTY
76222: LIST
76223: LIST
76224: LIST
76225: PPUSH
76226: CALL_OW 72
76230: ST_TO_ADDR
// if depot then
76231: LD_VAR 0 10
76235: IFFALSE 76291
// begin depot := NearestUnitToUnit ( depot , unit ) ;
76237: LD_ADDR_VAR 0 10
76241: PUSH
76242: LD_VAR 0 10
76246: PPUSH
76247: LD_VAR 0 3
76251: PPUSH
76252: CALL_OW 74
76256: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
76257: LD_VAR 0 3
76261: PPUSH
76262: LD_VAR 0 10
76266: PPUSH
76267: CALL_OW 296
76271: PUSH
76272: LD_INT 10
76274: GREATER
76275: IFFALSE 76291
// ComStandNearbyBuilding ( unit , depot ) ;
76277: LD_VAR 0 3
76281: PPUSH
76282: LD_VAR 0 10
76286: PPUSH
76287: CALL 12523 0 2
// end ; end ; end ;
76291: LD_VAR 0 5
76295: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
76296: LD_INT 0
76298: PPUSH
76299: PPUSH
76300: PPUSH
76301: PPUSH
// if not mc_bases then
76302: LD_EXP 52
76306: NOT
76307: IFFALSE 76311
// exit ;
76309: GO 76550
// for i = 1 to mc_bases do
76311: LD_ADDR_VAR 0 2
76315: PUSH
76316: DOUBLE
76317: LD_INT 1
76319: DEC
76320: ST_TO_ADDR
76321: LD_EXP 52
76325: PUSH
76326: FOR_TO
76327: IFFALSE 76548
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
76329: LD_ADDR_VAR 0 4
76333: PUSH
76334: LD_EXP 52
76338: PUSH
76339: LD_VAR 0 2
76343: ARRAY
76344: PPUSH
76345: LD_INT 21
76347: PUSH
76348: LD_INT 1
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: PPUSH
76355: CALL_OW 72
76359: PUSH
76360: LD_EXP 81
76364: PUSH
76365: LD_VAR 0 2
76369: ARRAY
76370: UNION
76371: ST_TO_ADDR
// if not tmp then
76372: LD_VAR 0 4
76376: NOT
76377: IFFALSE 76381
// continue ;
76379: GO 76326
// for j in tmp do
76381: LD_ADDR_VAR 0 3
76385: PUSH
76386: LD_VAR 0 4
76390: PUSH
76391: FOR_IN
76392: IFFALSE 76544
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
76394: LD_VAR 0 3
76398: PPUSH
76399: CALL_OW 110
76403: NOT
76404: PUSH
76405: LD_VAR 0 3
76409: PPUSH
76410: CALL_OW 314
76414: NOT
76415: AND
76416: PUSH
76417: LD_VAR 0 3
76421: PPUSH
76422: CALL_OW 311
76426: NOT
76427: AND
76428: PUSH
76429: LD_VAR 0 3
76433: PPUSH
76434: CALL_OW 310
76438: NOT
76439: AND
76440: PUSH
76441: LD_VAR 0 3
76445: PUSH
76446: LD_EXP 55
76450: PUSH
76451: LD_VAR 0 2
76455: ARRAY
76456: PUSH
76457: LD_INT 1
76459: ARRAY
76460: IN
76461: NOT
76462: AND
76463: PUSH
76464: LD_VAR 0 3
76468: PUSH
76469: LD_EXP 55
76473: PUSH
76474: LD_VAR 0 2
76478: ARRAY
76479: PUSH
76480: LD_INT 2
76482: ARRAY
76483: IN
76484: NOT
76485: AND
76486: PUSH
76487: LD_VAR 0 3
76491: PUSH
76492: LD_EXP 64
76496: PUSH
76497: LD_VAR 0 2
76501: ARRAY
76502: IN
76503: NOT
76504: AND
76505: IFFALSE 76542
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
76507: LD_VAR 0 2
76511: PPUSH
76512: LD_EXP 52
76516: PUSH
76517: LD_VAR 0 2
76521: ARRAY
76522: PPUSH
76523: LD_VAR 0 3
76527: PPUSH
76528: LD_VAR 0 3
76532: PPUSH
76533: CALL_OW 257
76537: PPUSH
76538: CALL 75314 0 4
// end ;
76542: GO 76391
76544: POP
76545: POP
// end ;
76546: GO 76326
76548: POP
76549: POP
// end ;
76550: LD_VAR 0 1
76554: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
76555: LD_INT 0
76557: PPUSH
76558: PPUSH
76559: PPUSH
76560: PPUSH
76561: PPUSH
76562: PPUSH
// if not mc_bases [ base ] then
76563: LD_EXP 52
76567: PUSH
76568: LD_VAR 0 1
76572: ARRAY
76573: NOT
76574: IFFALSE 76578
// exit ;
76576: GO 76760
// tmp := [ ] ;
76578: LD_ADDR_VAR 0 6
76582: PUSH
76583: EMPTY
76584: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
76585: LD_ADDR_VAR 0 7
76589: PUSH
76590: LD_VAR 0 3
76594: PPUSH
76595: LD_INT 0
76597: PPUSH
76598: CALL_OW 517
76602: ST_TO_ADDR
// if not list then
76603: LD_VAR 0 7
76607: NOT
76608: IFFALSE 76612
// exit ;
76610: GO 76760
// for i = 1 to amount do
76612: LD_ADDR_VAR 0 5
76616: PUSH
76617: DOUBLE
76618: LD_INT 1
76620: DEC
76621: ST_TO_ADDR
76622: LD_VAR 0 2
76626: PUSH
76627: FOR_TO
76628: IFFALSE 76708
// begin x := rand ( 1 , list [ 1 ] ) ;
76630: LD_ADDR_VAR 0 8
76634: PUSH
76635: LD_INT 1
76637: PPUSH
76638: LD_VAR 0 7
76642: PUSH
76643: LD_INT 1
76645: ARRAY
76646: PPUSH
76647: CALL_OW 12
76651: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
76652: LD_ADDR_VAR 0 6
76656: PUSH
76657: LD_VAR 0 6
76661: PPUSH
76662: LD_VAR 0 5
76666: PPUSH
76667: LD_VAR 0 7
76671: PUSH
76672: LD_INT 1
76674: ARRAY
76675: PUSH
76676: LD_VAR 0 8
76680: ARRAY
76681: PUSH
76682: LD_VAR 0 7
76686: PUSH
76687: LD_INT 2
76689: ARRAY
76690: PUSH
76691: LD_VAR 0 8
76695: ARRAY
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: PPUSH
76701: CALL_OW 1
76705: ST_TO_ADDR
// end ;
76706: GO 76627
76708: POP
76709: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
76710: LD_ADDR_EXP 65
76714: PUSH
76715: LD_EXP 65
76719: PPUSH
76720: LD_VAR 0 1
76724: PPUSH
76725: LD_VAR 0 6
76729: PPUSH
76730: CALL_OW 1
76734: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
76735: LD_ADDR_EXP 67
76739: PUSH
76740: LD_EXP 67
76744: PPUSH
76745: LD_VAR 0 1
76749: PPUSH
76750: LD_VAR 0 3
76754: PPUSH
76755: CALL_OW 1
76759: ST_TO_ADDR
// end ;
76760: LD_VAR 0 4
76764: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
76765: LD_INT 0
76767: PPUSH
// if not mc_bases [ base ] then
76768: LD_EXP 52
76772: PUSH
76773: LD_VAR 0 1
76777: ARRAY
76778: NOT
76779: IFFALSE 76783
// exit ;
76781: GO 76808
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
76783: LD_ADDR_EXP 57
76787: PUSH
76788: LD_EXP 57
76792: PPUSH
76793: LD_VAR 0 1
76797: PPUSH
76798: LD_VAR 0 2
76802: PPUSH
76803: CALL_OW 1
76807: ST_TO_ADDR
// end ;
76808: LD_VAR 0 3
76812: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
76813: LD_INT 0
76815: PPUSH
// if not mc_bases [ base ] then
76816: LD_EXP 52
76820: PUSH
76821: LD_VAR 0 1
76825: ARRAY
76826: NOT
76827: IFFALSE 76831
// exit ;
76829: GO 76868
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
76831: LD_ADDR_EXP 57
76835: PUSH
76836: LD_EXP 57
76840: PPUSH
76841: LD_VAR 0 1
76845: PPUSH
76846: LD_EXP 57
76850: PUSH
76851: LD_VAR 0 1
76855: ARRAY
76856: PUSH
76857: LD_VAR 0 2
76861: UNION
76862: PPUSH
76863: CALL_OW 1
76867: ST_TO_ADDR
// end ;
76868: LD_VAR 0 3
76872: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
76873: LD_INT 0
76875: PPUSH
// if not mc_bases [ base ] then
76876: LD_EXP 52
76880: PUSH
76881: LD_VAR 0 1
76885: ARRAY
76886: NOT
76887: IFFALSE 76891
// exit ;
76889: GO 76916
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
76891: LD_ADDR_EXP 73
76895: PUSH
76896: LD_EXP 73
76900: PPUSH
76901: LD_VAR 0 1
76905: PPUSH
76906: LD_VAR 0 2
76910: PPUSH
76911: CALL_OW 1
76915: ST_TO_ADDR
// end ;
76916: LD_VAR 0 3
76920: RET
// export function MC_InsertProduceList ( base , components ) ; begin
76921: LD_INT 0
76923: PPUSH
// if not mc_bases [ base ] then
76924: LD_EXP 52
76928: PUSH
76929: LD_VAR 0 1
76933: ARRAY
76934: NOT
76935: IFFALSE 76939
// exit ;
76937: GO 76976
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
76939: LD_ADDR_EXP 73
76943: PUSH
76944: LD_EXP 73
76948: PPUSH
76949: LD_VAR 0 1
76953: PPUSH
76954: LD_EXP 73
76958: PUSH
76959: LD_VAR 0 1
76963: ARRAY
76964: PUSH
76965: LD_VAR 0 2
76969: ADD
76970: PPUSH
76971: CALL_OW 1
76975: ST_TO_ADDR
// end ;
76976: LD_VAR 0 3
76980: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
76981: LD_INT 0
76983: PPUSH
// if not mc_bases [ base ] then
76984: LD_EXP 52
76988: PUSH
76989: LD_VAR 0 1
76993: ARRAY
76994: NOT
76995: IFFALSE 76999
// exit ;
76997: GO 77053
// mc_defender := Replace ( mc_defender , base , deflist ) ;
76999: LD_ADDR_EXP 74
77003: PUSH
77004: LD_EXP 74
77008: PPUSH
77009: LD_VAR 0 1
77013: PPUSH
77014: LD_VAR 0 2
77018: PPUSH
77019: CALL_OW 1
77023: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
77024: LD_ADDR_EXP 63
77028: PUSH
77029: LD_EXP 63
77033: PPUSH
77034: LD_VAR 0 1
77038: PPUSH
77039: LD_VAR 0 2
77043: PUSH
77044: LD_INT 0
77046: PLUS
77047: PPUSH
77048: CALL_OW 1
77052: ST_TO_ADDR
// end ;
77053: LD_VAR 0 3
77057: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
77058: LD_INT 0
77060: PPUSH
// if not mc_bases [ base ] then
77061: LD_EXP 52
77065: PUSH
77066: LD_VAR 0 1
77070: ARRAY
77071: NOT
77072: IFFALSE 77076
// exit ;
77074: GO 77101
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
77076: LD_ADDR_EXP 63
77080: PUSH
77081: LD_EXP 63
77085: PPUSH
77086: LD_VAR 0 1
77090: PPUSH
77091: LD_VAR 0 2
77095: PPUSH
77096: CALL_OW 1
77100: ST_TO_ADDR
// end ;
77101: LD_VAR 0 3
77105: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
77106: LD_INT 0
77108: PPUSH
77109: PPUSH
77110: PPUSH
77111: PPUSH
// if not mc_bases [ base ] then
77112: LD_EXP 52
77116: PUSH
77117: LD_VAR 0 1
77121: ARRAY
77122: NOT
77123: IFFALSE 77127
// exit ;
77125: GO 77192
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
77127: LD_ADDR_EXP 72
77131: PUSH
77132: LD_EXP 72
77136: PPUSH
77137: LD_VAR 0 1
77141: PUSH
77142: LD_EXP 72
77146: PUSH
77147: LD_VAR 0 1
77151: ARRAY
77152: PUSH
77153: LD_INT 1
77155: PLUS
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: PPUSH
77161: LD_VAR 0 1
77165: PUSH
77166: LD_VAR 0 2
77170: PUSH
77171: LD_VAR 0 3
77175: PUSH
77176: LD_VAR 0 4
77180: PUSH
77181: EMPTY
77182: LIST
77183: LIST
77184: LIST
77185: LIST
77186: PPUSH
77187: CALL 17816 0 3
77191: ST_TO_ADDR
// end ;
77192: LD_VAR 0 5
77196: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
77197: LD_INT 0
77199: PPUSH
// if not mc_bases [ base ] then
77200: LD_EXP 52
77204: PUSH
77205: LD_VAR 0 1
77209: ARRAY
77210: NOT
77211: IFFALSE 77215
// exit ;
77213: GO 77240
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
77215: LD_ADDR_EXP 89
77219: PUSH
77220: LD_EXP 89
77224: PPUSH
77225: LD_VAR 0 1
77229: PPUSH
77230: LD_VAR 0 2
77234: PPUSH
77235: CALL_OW 1
77239: ST_TO_ADDR
// end ;
77240: LD_VAR 0 3
77244: RET
// export function MC_GetMinesField ( base ) ; begin
77245: LD_INT 0
77247: PPUSH
// result := mc_mines [ base ] ;
77248: LD_ADDR_VAR 0 2
77252: PUSH
77253: LD_EXP 65
77257: PUSH
77258: LD_VAR 0 1
77262: ARRAY
77263: ST_TO_ADDR
// end ;
77264: LD_VAR 0 2
77268: RET
// export function MC_GetProduceList ( base ) ; begin
77269: LD_INT 0
77271: PPUSH
// result := mc_produce [ base ] ;
77272: LD_ADDR_VAR 0 2
77276: PUSH
77277: LD_EXP 73
77281: PUSH
77282: LD_VAR 0 1
77286: ARRAY
77287: ST_TO_ADDR
// end ;
77288: LD_VAR 0 2
77292: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
77293: LD_INT 0
77295: PPUSH
77296: PPUSH
// if not mc_bases then
77297: LD_EXP 52
77301: NOT
77302: IFFALSE 77306
// exit ;
77304: GO 77371
// if mc_bases [ base ] then
77306: LD_EXP 52
77310: PUSH
77311: LD_VAR 0 1
77315: ARRAY
77316: IFFALSE 77371
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77318: LD_ADDR_VAR 0 3
77322: PUSH
77323: LD_EXP 52
77327: PUSH
77328: LD_VAR 0 1
77332: ARRAY
77333: PPUSH
77334: LD_INT 30
77336: PUSH
77337: LD_VAR 0 2
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: PPUSH
77346: CALL_OW 72
77350: ST_TO_ADDR
// if result then
77351: LD_VAR 0 3
77355: IFFALSE 77371
// result := result [ 1 ] ;
77357: LD_ADDR_VAR 0 3
77361: PUSH
77362: LD_VAR 0 3
77366: PUSH
77367: LD_INT 1
77369: ARRAY
77370: ST_TO_ADDR
// end ; end ;
77371: LD_VAR 0 3
77375: RET
// export function MC_SetTame ( base , area ) ; begin
77376: LD_INT 0
77378: PPUSH
// if not mc_bases or not base then
77379: LD_EXP 52
77383: NOT
77384: PUSH
77385: LD_VAR 0 1
77389: NOT
77390: OR
77391: IFFALSE 77395
// exit ;
77393: GO 77420
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
77395: LD_ADDR_EXP 80
77399: PUSH
77400: LD_EXP 80
77404: PPUSH
77405: LD_VAR 0 1
77409: PPUSH
77410: LD_VAR 0 2
77414: PPUSH
77415: CALL_OW 1
77419: ST_TO_ADDR
// end ;
77420: LD_VAR 0 3
77424: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
77425: LD_INT 0
77427: PPUSH
77428: PPUSH
// if not mc_bases or not base then
77429: LD_EXP 52
77433: NOT
77434: PUSH
77435: LD_VAR 0 1
77439: NOT
77440: OR
77441: IFFALSE 77445
// exit ;
77443: GO 77547
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77445: LD_ADDR_VAR 0 4
77449: PUSH
77450: LD_EXP 52
77454: PUSH
77455: LD_VAR 0 1
77459: ARRAY
77460: PPUSH
77461: LD_INT 30
77463: PUSH
77464: LD_VAR 0 2
77468: PUSH
77469: EMPTY
77470: LIST
77471: LIST
77472: PPUSH
77473: CALL_OW 72
77477: ST_TO_ADDR
// if not tmp then
77478: LD_VAR 0 4
77482: NOT
77483: IFFALSE 77487
// exit ;
77485: GO 77547
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
77487: LD_ADDR_EXP 84
77491: PUSH
77492: LD_EXP 84
77496: PPUSH
77497: LD_VAR 0 1
77501: PPUSH
77502: LD_EXP 84
77506: PUSH
77507: LD_VAR 0 1
77511: ARRAY
77512: PPUSH
77513: LD_EXP 84
77517: PUSH
77518: LD_VAR 0 1
77522: ARRAY
77523: PUSH
77524: LD_INT 1
77526: PLUS
77527: PPUSH
77528: LD_VAR 0 4
77532: PUSH
77533: LD_INT 1
77535: ARRAY
77536: PPUSH
77537: CALL_OW 2
77541: PPUSH
77542: CALL_OW 1
77546: ST_TO_ADDR
// end ;
77547: LD_VAR 0 3
77551: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
77552: LD_INT 0
77554: PPUSH
77555: PPUSH
// if not mc_bases or not base or not kinds then
77556: LD_EXP 52
77560: NOT
77561: PUSH
77562: LD_VAR 0 1
77566: NOT
77567: OR
77568: PUSH
77569: LD_VAR 0 2
77573: NOT
77574: OR
77575: IFFALSE 77579
// exit ;
77577: GO 77640
// for i in kinds do
77579: LD_ADDR_VAR 0 4
77583: PUSH
77584: LD_VAR 0 2
77588: PUSH
77589: FOR_IN
77590: IFFALSE 77638
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
77592: LD_ADDR_EXP 86
77596: PUSH
77597: LD_EXP 86
77601: PPUSH
77602: LD_VAR 0 1
77606: PUSH
77607: LD_EXP 86
77611: PUSH
77612: LD_VAR 0 1
77616: ARRAY
77617: PUSH
77618: LD_INT 1
77620: PLUS
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: PPUSH
77626: LD_VAR 0 4
77630: PPUSH
77631: CALL 17816 0 3
77635: ST_TO_ADDR
77636: GO 77589
77638: POP
77639: POP
// end ;
77640: LD_VAR 0 3
77644: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
77645: LD_INT 0
77647: PPUSH
// if not mc_bases or not base or not areas then
77648: LD_EXP 52
77652: NOT
77653: PUSH
77654: LD_VAR 0 1
77658: NOT
77659: OR
77660: PUSH
77661: LD_VAR 0 2
77665: NOT
77666: OR
77667: IFFALSE 77671
// exit ;
77669: GO 77696
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
77671: LD_ADDR_EXP 70
77675: PUSH
77676: LD_EXP 70
77680: PPUSH
77681: LD_VAR 0 1
77685: PPUSH
77686: LD_VAR 0 2
77690: PPUSH
77691: CALL_OW 1
77695: ST_TO_ADDR
// end ;
77696: LD_VAR 0 3
77700: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
77701: LD_INT 0
77703: PPUSH
// if not mc_bases or not base or not teleports_exit then
77704: LD_EXP 52
77708: NOT
77709: PUSH
77710: LD_VAR 0 1
77714: NOT
77715: OR
77716: PUSH
77717: LD_VAR 0 2
77721: NOT
77722: OR
77723: IFFALSE 77727
// exit ;
77725: GO 77752
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
77727: LD_ADDR_EXP 87
77731: PUSH
77732: LD_EXP 87
77736: PPUSH
77737: LD_VAR 0 1
77741: PPUSH
77742: LD_VAR 0 2
77746: PPUSH
77747: CALL_OW 1
77751: ST_TO_ADDR
// end ;
77752: LD_VAR 0 3
77756: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
77757: LD_INT 0
77759: PPUSH
77760: PPUSH
77761: PPUSH
// if not mc_bases or not base or not ext_list then
77762: LD_EXP 52
77766: NOT
77767: PUSH
77768: LD_VAR 0 1
77772: NOT
77773: OR
77774: PUSH
77775: LD_VAR 0 5
77779: NOT
77780: OR
77781: IFFALSE 77785
// exit ;
77783: GO 77958
// tmp := GetFacExtXYD ( x , y , d ) ;
77785: LD_ADDR_VAR 0 8
77789: PUSH
77790: LD_VAR 0 2
77794: PPUSH
77795: LD_VAR 0 3
77799: PPUSH
77800: LD_VAR 0 4
77804: PPUSH
77805: CALL 51194 0 3
77809: ST_TO_ADDR
// if not tmp then
77810: LD_VAR 0 8
77814: NOT
77815: IFFALSE 77819
// exit ;
77817: GO 77958
// for i in tmp do
77819: LD_ADDR_VAR 0 7
77823: PUSH
77824: LD_VAR 0 8
77828: PUSH
77829: FOR_IN
77830: IFFALSE 77956
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
77832: LD_ADDR_EXP 57
77836: PUSH
77837: LD_EXP 57
77841: PPUSH
77842: LD_VAR 0 1
77846: PPUSH
77847: LD_EXP 57
77851: PUSH
77852: LD_VAR 0 1
77856: ARRAY
77857: PPUSH
77858: LD_EXP 57
77862: PUSH
77863: LD_VAR 0 1
77867: ARRAY
77868: PUSH
77869: LD_INT 1
77871: PLUS
77872: PPUSH
77873: LD_VAR 0 5
77877: PUSH
77878: LD_INT 1
77880: ARRAY
77881: PUSH
77882: LD_VAR 0 7
77886: PUSH
77887: LD_INT 1
77889: ARRAY
77890: PUSH
77891: LD_VAR 0 7
77895: PUSH
77896: LD_INT 2
77898: ARRAY
77899: PUSH
77900: LD_VAR 0 7
77904: PUSH
77905: LD_INT 3
77907: ARRAY
77908: PUSH
77909: EMPTY
77910: LIST
77911: LIST
77912: LIST
77913: LIST
77914: PPUSH
77915: CALL_OW 2
77919: PPUSH
77920: CALL_OW 1
77924: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
77925: LD_ADDR_VAR 0 5
77929: PUSH
77930: LD_VAR 0 5
77934: PPUSH
77935: LD_INT 1
77937: PPUSH
77938: CALL_OW 3
77942: ST_TO_ADDR
// if not ext_list then
77943: LD_VAR 0 5
77947: NOT
77948: IFFALSE 77954
// exit ;
77950: POP
77951: POP
77952: GO 77958
// end ;
77954: GO 77829
77956: POP
77957: POP
// end ;
77958: LD_VAR 0 6
77962: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
77963: LD_INT 0
77965: PPUSH
// if not mc_bases or not base or not weapon_list then
77966: LD_EXP 52
77970: NOT
77971: PUSH
77972: LD_VAR 0 1
77976: NOT
77977: OR
77978: PUSH
77979: LD_VAR 0 2
77983: NOT
77984: OR
77985: IFFALSE 77989
// exit ;
77987: GO 78014
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
77989: LD_ADDR_EXP 91
77993: PUSH
77994: LD_EXP 91
77998: PPUSH
77999: LD_VAR 0 1
78003: PPUSH
78004: LD_VAR 0 2
78008: PPUSH
78009: CALL_OW 1
78013: ST_TO_ADDR
// end ;
78014: LD_VAR 0 3
78018: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
78019: LD_INT 0
78021: PPUSH
// if not mc_bases or not base or not tech_list then
78022: LD_EXP 52
78026: NOT
78027: PUSH
78028: LD_VAR 0 1
78032: NOT
78033: OR
78034: PUSH
78035: LD_VAR 0 2
78039: NOT
78040: OR
78041: IFFALSE 78045
// exit ;
78043: GO 78070
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
78045: LD_ADDR_EXP 79
78049: PUSH
78050: LD_EXP 79
78054: PPUSH
78055: LD_VAR 0 1
78059: PPUSH
78060: LD_VAR 0 2
78064: PPUSH
78065: CALL_OW 1
78069: ST_TO_ADDR
// end ;
78070: LD_VAR 0 3
78074: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
78075: LD_INT 0
78077: PPUSH
// if not mc_bases or not parking_area or not base then
78078: LD_EXP 52
78082: NOT
78083: PUSH
78084: LD_VAR 0 2
78088: NOT
78089: OR
78090: PUSH
78091: LD_VAR 0 1
78095: NOT
78096: OR
78097: IFFALSE 78101
// exit ;
78099: GO 78126
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
78101: LD_ADDR_EXP 76
78105: PUSH
78106: LD_EXP 76
78110: PPUSH
78111: LD_VAR 0 1
78115: PPUSH
78116: LD_VAR 0 2
78120: PPUSH
78121: CALL_OW 1
78125: ST_TO_ADDR
// end ;
78126: LD_VAR 0 3
78130: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
78131: LD_INT 0
78133: PPUSH
// if not mc_bases or not base or not scan_area then
78134: LD_EXP 52
78138: NOT
78139: PUSH
78140: LD_VAR 0 1
78144: NOT
78145: OR
78146: PUSH
78147: LD_VAR 0 2
78151: NOT
78152: OR
78153: IFFALSE 78157
// exit ;
78155: GO 78182
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
78157: LD_ADDR_EXP 77
78161: PUSH
78162: LD_EXP 77
78166: PPUSH
78167: LD_VAR 0 1
78171: PPUSH
78172: LD_VAR 0 2
78176: PPUSH
78177: CALL_OW 1
78181: ST_TO_ADDR
// end ;
78182: LD_VAR 0 3
78186: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
78187: LD_INT 0
78189: PPUSH
78190: PPUSH
// if not mc_bases or not base then
78191: LD_EXP 52
78195: NOT
78196: PUSH
78197: LD_VAR 0 1
78201: NOT
78202: OR
78203: IFFALSE 78207
// exit ;
78205: GO 78271
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
78207: LD_ADDR_VAR 0 3
78211: PUSH
78212: LD_INT 1
78214: PUSH
78215: LD_INT 2
78217: PUSH
78218: LD_INT 3
78220: PUSH
78221: LD_INT 4
78223: PUSH
78224: LD_INT 11
78226: PUSH
78227: EMPTY
78228: LIST
78229: LIST
78230: LIST
78231: LIST
78232: LIST
78233: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
78234: LD_ADDR_EXP 79
78238: PUSH
78239: LD_EXP 79
78243: PPUSH
78244: LD_VAR 0 1
78248: PPUSH
78249: LD_EXP 79
78253: PUSH
78254: LD_VAR 0 1
78258: ARRAY
78259: PUSH
78260: LD_VAR 0 3
78264: DIFF
78265: PPUSH
78266: CALL_OW 1
78270: ST_TO_ADDR
// end ;
78271: LD_VAR 0 2
78275: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
78276: LD_INT 0
78278: PPUSH
// result := mc_vehicles [ base ] ;
78279: LD_ADDR_VAR 0 3
78283: PUSH
78284: LD_EXP 71
78288: PUSH
78289: LD_VAR 0 1
78293: ARRAY
78294: ST_TO_ADDR
// if onlyCombat then
78295: LD_VAR 0 2
78299: IFFALSE 78464
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
78301: LD_ADDR_VAR 0 3
78305: PUSH
78306: LD_VAR 0 3
78310: PUSH
78311: LD_VAR 0 3
78315: PPUSH
78316: LD_INT 2
78318: PUSH
78319: LD_INT 34
78321: PUSH
78322: LD_INT 12
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: PUSH
78329: LD_INT 34
78331: PUSH
78332: LD_INT 51
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: PUSH
78339: LD_INT 34
78341: PUSH
78342: LD_EXP 46
78346: PUSH
78347: EMPTY
78348: LIST
78349: LIST
78350: PUSH
78351: LD_INT 34
78353: PUSH
78354: LD_INT 32
78356: PUSH
78357: EMPTY
78358: LIST
78359: LIST
78360: PUSH
78361: LD_INT 34
78363: PUSH
78364: LD_INT 13
78366: PUSH
78367: EMPTY
78368: LIST
78369: LIST
78370: PUSH
78371: LD_INT 34
78373: PUSH
78374: LD_INT 52
78376: PUSH
78377: EMPTY
78378: LIST
78379: LIST
78380: PUSH
78381: LD_INT 34
78383: PUSH
78384: LD_INT 14
78386: PUSH
78387: EMPTY
78388: LIST
78389: LIST
78390: PUSH
78391: LD_INT 34
78393: PUSH
78394: LD_INT 53
78396: PUSH
78397: EMPTY
78398: LIST
78399: LIST
78400: PUSH
78401: LD_INT 34
78403: PUSH
78404: LD_EXP 45
78408: PUSH
78409: EMPTY
78410: LIST
78411: LIST
78412: PUSH
78413: LD_INT 34
78415: PUSH
78416: LD_INT 31
78418: PUSH
78419: EMPTY
78420: LIST
78421: LIST
78422: PUSH
78423: LD_INT 34
78425: PUSH
78426: LD_INT 48
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PUSH
78433: LD_INT 34
78435: PUSH
78436: LD_INT 8
78438: PUSH
78439: EMPTY
78440: LIST
78441: LIST
78442: PUSH
78443: EMPTY
78444: LIST
78445: LIST
78446: LIST
78447: LIST
78448: LIST
78449: LIST
78450: LIST
78451: LIST
78452: LIST
78453: LIST
78454: LIST
78455: LIST
78456: LIST
78457: PPUSH
78458: CALL_OW 72
78462: DIFF
78463: ST_TO_ADDR
// end ; end_of_file
78464: LD_VAR 0 3
78468: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
78469: LD_INT 0
78471: PPUSH
78472: PPUSH
78473: PPUSH
// if not mc_bases or not skirmish then
78474: LD_EXP 52
78478: NOT
78479: PUSH
78480: LD_EXP 50
78484: NOT
78485: OR
78486: IFFALSE 78490
// exit ;
78488: GO 78655
// for i = 1 to mc_bases do
78490: LD_ADDR_VAR 0 4
78494: PUSH
78495: DOUBLE
78496: LD_INT 1
78498: DEC
78499: ST_TO_ADDR
78500: LD_EXP 52
78504: PUSH
78505: FOR_TO
78506: IFFALSE 78653
// begin if sci in mc_bases [ i ] then
78508: LD_VAR 0 2
78512: PUSH
78513: LD_EXP 52
78517: PUSH
78518: LD_VAR 0 4
78522: ARRAY
78523: IN
78524: IFFALSE 78651
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
78526: LD_ADDR_EXP 81
78530: PUSH
78531: LD_EXP 81
78535: PPUSH
78536: LD_VAR 0 4
78540: PUSH
78541: LD_EXP 81
78545: PUSH
78546: LD_VAR 0 4
78550: ARRAY
78551: PUSH
78552: LD_INT 1
78554: PLUS
78555: PUSH
78556: EMPTY
78557: LIST
78558: LIST
78559: PPUSH
78560: LD_VAR 0 1
78564: PPUSH
78565: CALL 17816 0 3
78569: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
78570: LD_ADDR_VAR 0 5
78574: PUSH
78575: LD_EXP 52
78579: PUSH
78580: LD_VAR 0 4
78584: ARRAY
78585: PPUSH
78586: LD_INT 2
78588: PUSH
78589: LD_INT 30
78591: PUSH
78592: LD_INT 0
78594: PUSH
78595: EMPTY
78596: LIST
78597: LIST
78598: PUSH
78599: LD_INT 30
78601: PUSH
78602: LD_INT 1
78604: PUSH
78605: EMPTY
78606: LIST
78607: LIST
78608: PUSH
78609: EMPTY
78610: LIST
78611: LIST
78612: LIST
78613: PPUSH
78614: CALL_OW 72
78618: PPUSH
78619: LD_VAR 0 1
78623: PPUSH
78624: CALL_OW 74
78628: ST_TO_ADDR
// if tmp then
78629: LD_VAR 0 5
78633: IFFALSE 78649
// ComStandNearbyBuilding ( ape , tmp ) ;
78635: LD_VAR 0 1
78639: PPUSH
78640: LD_VAR 0 5
78644: PPUSH
78645: CALL 12523 0 2
// break ;
78649: GO 78653
// end ; end ;
78651: GO 78505
78653: POP
78654: POP
// end ;
78655: LD_VAR 0 3
78659: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
78660: LD_INT 0
78662: PPUSH
78663: PPUSH
78664: PPUSH
// if not mc_bases or not skirmish then
78665: LD_EXP 52
78669: NOT
78670: PUSH
78671: LD_EXP 50
78675: NOT
78676: OR
78677: IFFALSE 78681
// exit ;
78679: GO 78770
// for i = 1 to mc_bases do
78681: LD_ADDR_VAR 0 4
78685: PUSH
78686: DOUBLE
78687: LD_INT 1
78689: DEC
78690: ST_TO_ADDR
78691: LD_EXP 52
78695: PUSH
78696: FOR_TO
78697: IFFALSE 78768
// begin if building in mc_busy_turret_list [ i ] then
78699: LD_VAR 0 1
78703: PUSH
78704: LD_EXP 62
78708: PUSH
78709: LD_VAR 0 4
78713: ARRAY
78714: IN
78715: IFFALSE 78766
// begin tmp := mc_busy_turret_list [ i ] diff building ;
78717: LD_ADDR_VAR 0 5
78721: PUSH
78722: LD_EXP 62
78726: PUSH
78727: LD_VAR 0 4
78731: ARRAY
78732: PUSH
78733: LD_VAR 0 1
78737: DIFF
78738: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
78739: LD_ADDR_EXP 62
78743: PUSH
78744: LD_EXP 62
78748: PPUSH
78749: LD_VAR 0 4
78753: PPUSH
78754: LD_VAR 0 5
78758: PPUSH
78759: CALL_OW 1
78763: ST_TO_ADDR
// break ;
78764: GO 78768
// end ; end ;
78766: GO 78696
78768: POP
78769: POP
// end ;
78770: LD_VAR 0 3
78774: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
78775: LD_INT 0
78777: PPUSH
78778: PPUSH
78779: PPUSH
// if not mc_bases or not skirmish then
78780: LD_EXP 52
78784: NOT
78785: PUSH
78786: LD_EXP 50
78790: NOT
78791: OR
78792: IFFALSE 78796
// exit ;
78794: GO 78995
// for i = 1 to mc_bases do
78796: LD_ADDR_VAR 0 5
78800: PUSH
78801: DOUBLE
78802: LD_INT 1
78804: DEC
78805: ST_TO_ADDR
78806: LD_EXP 52
78810: PUSH
78811: FOR_TO
78812: IFFALSE 78993
// if building in mc_bases [ i ] then
78814: LD_VAR 0 1
78818: PUSH
78819: LD_EXP 52
78823: PUSH
78824: LD_VAR 0 5
78828: ARRAY
78829: IN
78830: IFFALSE 78991
// begin tmp := mc_bases [ i ] diff building ;
78832: LD_ADDR_VAR 0 6
78836: PUSH
78837: LD_EXP 52
78841: PUSH
78842: LD_VAR 0 5
78846: ARRAY
78847: PUSH
78848: LD_VAR 0 1
78852: DIFF
78853: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
78854: LD_ADDR_EXP 52
78858: PUSH
78859: LD_EXP 52
78863: PPUSH
78864: LD_VAR 0 5
78868: PPUSH
78869: LD_VAR 0 6
78873: PPUSH
78874: CALL_OW 1
78878: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
78879: LD_VAR 0 1
78883: PUSH
78884: LD_EXP 60
78888: PUSH
78889: LD_VAR 0 5
78893: ARRAY
78894: IN
78895: IFFALSE 78934
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
78897: LD_ADDR_EXP 60
78901: PUSH
78902: LD_EXP 60
78906: PPUSH
78907: LD_VAR 0 5
78911: PPUSH
78912: LD_EXP 60
78916: PUSH
78917: LD_VAR 0 5
78921: ARRAY
78922: PUSH
78923: LD_VAR 0 1
78927: DIFF
78928: PPUSH
78929: CALL_OW 1
78933: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
78934: LD_VAR 0 1
78938: PUSH
78939: LD_EXP 61
78943: PUSH
78944: LD_VAR 0 5
78948: ARRAY
78949: IN
78950: IFFALSE 78989
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
78952: LD_ADDR_EXP 61
78956: PUSH
78957: LD_EXP 61
78961: PPUSH
78962: LD_VAR 0 5
78966: PPUSH
78967: LD_EXP 61
78971: PUSH
78972: LD_VAR 0 5
78976: ARRAY
78977: PUSH
78978: LD_VAR 0 1
78982: DIFF
78983: PPUSH
78984: CALL_OW 1
78988: ST_TO_ADDR
// break ;
78989: GO 78993
// end ;
78991: GO 78811
78993: POP
78994: POP
// end ;
78995: LD_VAR 0 4
78999: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
79000: LD_INT 0
79002: PPUSH
79003: PPUSH
79004: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
79005: LD_EXP 52
79009: NOT
79010: PUSH
79011: LD_EXP 50
79015: NOT
79016: OR
79017: PUSH
79018: LD_VAR 0 3
79022: PUSH
79023: LD_EXP 78
79027: IN
79028: NOT
79029: OR
79030: IFFALSE 79034
// exit ;
79032: GO 79157
// for i = 1 to mc_vehicles do
79034: LD_ADDR_VAR 0 6
79038: PUSH
79039: DOUBLE
79040: LD_INT 1
79042: DEC
79043: ST_TO_ADDR
79044: LD_EXP 71
79048: PUSH
79049: FOR_TO
79050: IFFALSE 79155
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
79052: LD_VAR 0 2
79056: PUSH
79057: LD_EXP 71
79061: PUSH
79062: LD_VAR 0 6
79066: ARRAY
79067: IN
79068: PUSH
79069: LD_VAR 0 1
79073: PUSH
79074: LD_EXP 71
79078: PUSH
79079: LD_VAR 0 6
79083: ARRAY
79084: IN
79085: OR
79086: IFFALSE 79153
// begin tmp := mc_vehicles [ i ] diff old ;
79088: LD_ADDR_VAR 0 7
79092: PUSH
79093: LD_EXP 71
79097: PUSH
79098: LD_VAR 0 6
79102: ARRAY
79103: PUSH
79104: LD_VAR 0 2
79108: DIFF
79109: ST_TO_ADDR
// tmp := tmp diff new ;
79110: LD_ADDR_VAR 0 7
79114: PUSH
79115: LD_VAR 0 7
79119: PUSH
79120: LD_VAR 0 1
79124: DIFF
79125: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
79126: LD_ADDR_EXP 71
79130: PUSH
79131: LD_EXP 71
79135: PPUSH
79136: LD_VAR 0 6
79140: PPUSH
79141: LD_VAR 0 7
79145: PPUSH
79146: CALL_OW 1
79150: ST_TO_ADDR
// break ;
79151: GO 79155
// end ;
79153: GO 79049
79155: POP
79156: POP
// end ;
79157: LD_VAR 0 5
79161: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
79162: LD_INT 0
79164: PPUSH
79165: PPUSH
79166: PPUSH
79167: PPUSH
// if not mc_bases or not skirmish then
79168: LD_EXP 52
79172: NOT
79173: PUSH
79174: LD_EXP 50
79178: NOT
79179: OR
79180: IFFALSE 79184
// exit ;
79182: GO 79561
// side := GetSide ( vehicle ) ;
79184: LD_ADDR_VAR 0 5
79188: PUSH
79189: LD_VAR 0 1
79193: PPUSH
79194: CALL_OW 255
79198: ST_TO_ADDR
// for i = 1 to mc_bases do
79199: LD_ADDR_VAR 0 4
79203: PUSH
79204: DOUBLE
79205: LD_INT 1
79207: DEC
79208: ST_TO_ADDR
79209: LD_EXP 52
79213: PUSH
79214: FOR_TO
79215: IFFALSE 79559
// begin if factory in mc_bases [ i ] then
79217: LD_VAR 0 2
79221: PUSH
79222: LD_EXP 52
79226: PUSH
79227: LD_VAR 0 4
79231: ARRAY
79232: IN
79233: IFFALSE 79557
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
79235: LD_EXP 74
79239: PUSH
79240: LD_VAR 0 4
79244: ARRAY
79245: PUSH
79246: LD_EXP 63
79250: PUSH
79251: LD_VAR 0 4
79255: ARRAY
79256: LESS
79257: PUSH
79258: LD_VAR 0 1
79262: PPUSH
79263: CALL_OW 264
79267: PUSH
79268: LD_INT 31
79270: PUSH
79271: LD_INT 32
79273: PUSH
79274: LD_INT 51
79276: PUSH
79277: LD_EXP 46
79281: PUSH
79282: LD_INT 12
79284: PUSH
79285: LD_INT 30
79287: PUSH
79288: LD_EXP 45
79292: PUSH
79293: LD_INT 11
79295: PUSH
79296: LD_INT 53
79298: PUSH
79299: LD_INT 14
79301: PUSH
79302: LD_EXP 49
79306: PUSH
79307: LD_INT 29
79309: PUSH
79310: LD_EXP 47
79314: PUSH
79315: LD_INT 13
79317: PUSH
79318: LD_INT 52
79320: PUSH
79321: LD_INT 48
79323: PUSH
79324: LD_INT 8
79326: PUSH
79327: EMPTY
79328: LIST
79329: LIST
79330: LIST
79331: LIST
79332: LIST
79333: LIST
79334: LIST
79335: LIST
79336: LIST
79337: LIST
79338: LIST
79339: LIST
79340: LIST
79341: LIST
79342: LIST
79343: LIST
79344: LIST
79345: IN
79346: NOT
79347: AND
79348: IFFALSE 79396
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
79350: LD_ADDR_EXP 74
79354: PUSH
79355: LD_EXP 74
79359: PPUSH
79360: LD_VAR 0 4
79364: PUSH
79365: LD_EXP 74
79369: PUSH
79370: LD_VAR 0 4
79374: ARRAY
79375: PUSH
79376: LD_INT 1
79378: PLUS
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: PPUSH
79384: LD_VAR 0 1
79388: PPUSH
79389: CALL 17816 0 3
79393: ST_TO_ADDR
79394: GO 79440
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
79396: LD_ADDR_EXP 71
79400: PUSH
79401: LD_EXP 71
79405: PPUSH
79406: LD_VAR 0 4
79410: PUSH
79411: LD_EXP 71
79415: PUSH
79416: LD_VAR 0 4
79420: ARRAY
79421: PUSH
79422: LD_INT 1
79424: PLUS
79425: PUSH
79426: EMPTY
79427: LIST
79428: LIST
79429: PPUSH
79430: LD_VAR 0 1
79434: PPUSH
79435: CALL 17816 0 3
79439: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
79440: LD_VAR 0 1
79444: PPUSH
79445: CALL_OW 263
79449: PUSH
79450: LD_INT 2
79452: EQUAL
79453: IFFALSE 79473
// begin repeat wait ( 0 0$1 ) ;
79455: LD_INT 35
79457: PPUSH
79458: CALL_OW 67
// until IsControledBy ( vehicle ) ;
79462: LD_VAR 0 1
79466: PPUSH
79467: CALL_OW 312
79471: IFFALSE 79455
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
79473: LD_VAR 0 1
79477: PPUSH
79478: LD_EXP 76
79482: PUSH
79483: LD_VAR 0 4
79487: ARRAY
79488: PPUSH
79489: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
79493: LD_VAR 0 1
79497: PPUSH
79498: CALL_OW 263
79502: PUSH
79503: LD_INT 1
79505: NONEQUAL
79506: IFFALSE 79510
// break ;
79508: GO 79559
// repeat wait ( 0 0$1 ) ;
79510: LD_INT 35
79512: PPUSH
79513: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
79517: LD_VAR 0 1
79521: PPUSH
79522: LD_EXP 76
79526: PUSH
79527: LD_VAR 0 4
79531: ARRAY
79532: PPUSH
79533: CALL_OW 308
79537: IFFALSE 79510
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
79539: LD_VAR 0 1
79543: PPUSH
79544: CALL_OW 311
79548: PPUSH
79549: CALL_OW 121
// exit ;
79553: POP
79554: POP
79555: GO 79561
// end ; end ;
79557: GO 79214
79559: POP
79560: POP
// end ;
79561: LD_VAR 0 3
79565: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
79566: LD_INT 0
79568: PPUSH
79569: PPUSH
79570: PPUSH
79571: PPUSH
// if not mc_bases or not skirmish then
79572: LD_EXP 52
79576: NOT
79577: PUSH
79578: LD_EXP 50
79582: NOT
79583: OR
79584: IFFALSE 79588
// exit ;
79586: GO 79941
// repeat wait ( 0 0$1 ) ;
79588: LD_INT 35
79590: PPUSH
79591: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
79595: LD_VAR 0 2
79599: PPUSH
79600: LD_VAR 0 3
79604: PPUSH
79605: CALL_OW 284
79609: IFFALSE 79588
// if GetResourceTypeXY ( x , y ) = mat_artefact then
79611: LD_VAR 0 2
79615: PPUSH
79616: LD_VAR 0 3
79620: PPUSH
79621: CALL_OW 283
79625: PUSH
79626: LD_INT 4
79628: EQUAL
79629: IFFALSE 79633
// exit ;
79631: GO 79941
// for i = 1 to mc_bases do
79633: LD_ADDR_VAR 0 7
79637: PUSH
79638: DOUBLE
79639: LD_INT 1
79641: DEC
79642: ST_TO_ADDR
79643: LD_EXP 52
79647: PUSH
79648: FOR_TO
79649: IFFALSE 79939
// begin if mc_crates_area [ i ] then
79651: LD_EXP 70
79655: PUSH
79656: LD_VAR 0 7
79660: ARRAY
79661: IFFALSE 79772
// for j in mc_crates_area [ i ] do
79663: LD_ADDR_VAR 0 8
79667: PUSH
79668: LD_EXP 70
79672: PUSH
79673: LD_VAR 0 7
79677: ARRAY
79678: PUSH
79679: FOR_IN
79680: IFFALSE 79770
// if InArea ( x , y , j ) then
79682: LD_VAR 0 2
79686: PPUSH
79687: LD_VAR 0 3
79691: PPUSH
79692: LD_VAR 0 8
79696: PPUSH
79697: CALL_OW 309
79701: IFFALSE 79768
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79703: LD_ADDR_EXP 68
79707: PUSH
79708: LD_EXP 68
79712: PPUSH
79713: LD_VAR 0 7
79717: PUSH
79718: LD_EXP 68
79722: PUSH
79723: LD_VAR 0 7
79727: ARRAY
79728: PUSH
79729: LD_INT 1
79731: PLUS
79732: PUSH
79733: EMPTY
79734: LIST
79735: LIST
79736: PPUSH
79737: LD_VAR 0 4
79741: PUSH
79742: LD_VAR 0 2
79746: PUSH
79747: LD_VAR 0 3
79751: PUSH
79752: EMPTY
79753: LIST
79754: LIST
79755: LIST
79756: PPUSH
79757: CALL 17816 0 3
79761: ST_TO_ADDR
// exit ;
79762: POP
79763: POP
79764: POP
79765: POP
79766: GO 79941
// end ;
79768: GO 79679
79770: POP
79771: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79772: LD_ADDR_VAR 0 9
79776: PUSH
79777: LD_EXP 52
79781: PUSH
79782: LD_VAR 0 7
79786: ARRAY
79787: PPUSH
79788: LD_INT 2
79790: PUSH
79791: LD_INT 30
79793: PUSH
79794: LD_INT 0
79796: PUSH
79797: EMPTY
79798: LIST
79799: LIST
79800: PUSH
79801: LD_INT 30
79803: PUSH
79804: LD_INT 1
79806: PUSH
79807: EMPTY
79808: LIST
79809: LIST
79810: PUSH
79811: EMPTY
79812: LIST
79813: LIST
79814: LIST
79815: PPUSH
79816: CALL_OW 72
79820: ST_TO_ADDR
// if not depot then
79821: LD_VAR 0 9
79825: NOT
79826: IFFALSE 79830
// continue ;
79828: GO 79648
// for j in depot do
79830: LD_ADDR_VAR 0 8
79834: PUSH
79835: LD_VAR 0 9
79839: PUSH
79840: FOR_IN
79841: IFFALSE 79935
// if GetDistUnitXY ( j , x , y ) < 30 then
79843: LD_VAR 0 8
79847: PPUSH
79848: LD_VAR 0 2
79852: PPUSH
79853: LD_VAR 0 3
79857: PPUSH
79858: CALL_OW 297
79862: PUSH
79863: LD_INT 30
79865: LESS
79866: IFFALSE 79933
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79868: LD_ADDR_EXP 68
79872: PUSH
79873: LD_EXP 68
79877: PPUSH
79878: LD_VAR 0 7
79882: PUSH
79883: LD_EXP 68
79887: PUSH
79888: LD_VAR 0 7
79892: ARRAY
79893: PUSH
79894: LD_INT 1
79896: PLUS
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: PPUSH
79902: LD_VAR 0 4
79906: PUSH
79907: LD_VAR 0 2
79911: PUSH
79912: LD_VAR 0 3
79916: PUSH
79917: EMPTY
79918: LIST
79919: LIST
79920: LIST
79921: PPUSH
79922: CALL 17816 0 3
79926: ST_TO_ADDR
// exit ;
79927: POP
79928: POP
79929: POP
79930: POP
79931: GO 79941
// end ;
79933: GO 79840
79935: POP
79936: POP
// end ;
79937: GO 79648
79939: POP
79940: POP
// end ;
79941: LD_VAR 0 6
79945: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
79946: LD_INT 0
79948: PPUSH
79949: PPUSH
79950: PPUSH
79951: PPUSH
// if not mc_bases or not skirmish then
79952: LD_EXP 52
79956: NOT
79957: PUSH
79958: LD_EXP 50
79962: NOT
79963: OR
79964: IFFALSE 79968
// exit ;
79966: GO 80245
// side := GetSide ( lab ) ;
79968: LD_ADDR_VAR 0 4
79972: PUSH
79973: LD_VAR 0 2
79977: PPUSH
79978: CALL_OW 255
79982: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
79983: LD_VAR 0 4
79987: PUSH
79988: LD_EXP 78
79992: IN
79993: NOT
79994: PUSH
79995: LD_EXP 79
79999: NOT
80000: OR
80001: PUSH
80002: LD_EXP 52
80006: NOT
80007: OR
80008: IFFALSE 80012
// exit ;
80010: GO 80245
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
80012: LD_ADDR_EXP 79
80016: PUSH
80017: LD_EXP 79
80021: PPUSH
80022: LD_VAR 0 4
80026: PPUSH
80027: LD_EXP 79
80031: PUSH
80032: LD_VAR 0 4
80036: ARRAY
80037: PUSH
80038: LD_VAR 0 1
80042: DIFF
80043: PPUSH
80044: CALL_OW 1
80048: ST_TO_ADDR
// for i = 1 to mc_bases do
80049: LD_ADDR_VAR 0 5
80053: PUSH
80054: DOUBLE
80055: LD_INT 1
80057: DEC
80058: ST_TO_ADDR
80059: LD_EXP 52
80063: PUSH
80064: FOR_TO
80065: IFFALSE 80243
// begin if lab in mc_bases [ i ] then
80067: LD_VAR 0 2
80071: PUSH
80072: LD_EXP 52
80076: PUSH
80077: LD_VAR 0 5
80081: ARRAY
80082: IN
80083: IFFALSE 80241
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
80085: LD_VAR 0 1
80089: PUSH
80090: LD_INT 11
80092: PUSH
80093: LD_INT 4
80095: PUSH
80096: LD_INT 3
80098: PUSH
80099: LD_INT 2
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: LIST
80106: LIST
80107: IN
80108: PUSH
80109: LD_EXP 82
80113: PUSH
80114: LD_VAR 0 5
80118: ARRAY
80119: AND
80120: IFFALSE 80241
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
80122: LD_ADDR_VAR 0 6
80126: PUSH
80127: LD_EXP 82
80131: PUSH
80132: LD_VAR 0 5
80136: ARRAY
80137: PUSH
80138: LD_INT 1
80140: ARRAY
80141: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80142: LD_ADDR_EXP 82
80146: PUSH
80147: LD_EXP 82
80151: PPUSH
80152: LD_VAR 0 5
80156: PPUSH
80157: EMPTY
80158: PPUSH
80159: CALL_OW 1
80163: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
80164: LD_VAR 0 6
80168: PPUSH
80169: LD_INT 0
80171: PPUSH
80172: CALL_OW 109
// ComExitBuilding ( tmp ) ;
80176: LD_VAR 0 6
80180: PPUSH
80181: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
80185: LD_ADDR_EXP 81
80189: PUSH
80190: LD_EXP 81
80194: PPUSH
80195: LD_VAR 0 5
80199: PPUSH
80200: LD_EXP 81
80204: PUSH
80205: LD_VAR 0 5
80209: ARRAY
80210: PPUSH
80211: LD_INT 1
80213: PPUSH
80214: LD_VAR 0 6
80218: PPUSH
80219: CALL_OW 2
80223: PPUSH
80224: CALL_OW 1
80228: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
80229: LD_VAR 0 5
80233: PPUSH
80234: LD_INT 112
80236: PPUSH
80237: CALL 57778 0 2
// end ; end ; end ;
80241: GO 80064
80243: POP
80244: POP
// end ;
80245: LD_VAR 0 3
80249: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
80250: LD_INT 0
80252: PPUSH
80253: PPUSH
80254: PPUSH
80255: PPUSH
80256: PPUSH
80257: PPUSH
80258: PPUSH
80259: PPUSH
// if not mc_bases or not skirmish then
80260: LD_EXP 52
80264: NOT
80265: PUSH
80266: LD_EXP 50
80270: NOT
80271: OR
80272: IFFALSE 80276
// exit ;
80274: GO 81368
// for i = 1 to mc_bases do
80276: LD_ADDR_VAR 0 3
80280: PUSH
80281: DOUBLE
80282: LD_INT 1
80284: DEC
80285: ST_TO_ADDR
80286: LD_EXP 52
80290: PUSH
80291: FOR_TO
80292: IFFALSE 81366
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
80294: LD_VAR 0 1
80298: PUSH
80299: LD_EXP 52
80303: PUSH
80304: LD_VAR 0 3
80308: ARRAY
80309: IN
80310: PUSH
80311: LD_VAR 0 1
80315: PUSH
80316: LD_EXP 59
80320: PUSH
80321: LD_VAR 0 3
80325: ARRAY
80326: IN
80327: OR
80328: PUSH
80329: LD_VAR 0 1
80333: PUSH
80334: LD_EXP 74
80338: PUSH
80339: LD_VAR 0 3
80343: ARRAY
80344: IN
80345: OR
80346: PUSH
80347: LD_VAR 0 1
80351: PUSH
80352: LD_EXP 71
80356: PUSH
80357: LD_VAR 0 3
80361: ARRAY
80362: IN
80363: OR
80364: PUSH
80365: LD_VAR 0 1
80369: PUSH
80370: LD_EXP 81
80374: PUSH
80375: LD_VAR 0 3
80379: ARRAY
80380: IN
80381: OR
80382: PUSH
80383: LD_VAR 0 1
80387: PUSH
80388: LD_EXP 82
80392: PUSH
80393: LD_VAR 0 3
80397: ARRAY
80398: IN
80399: OR
80400: IFFALSE 81364
// begin if un in mc_ape [ i ] then
80402: LD_VAR 0 1
80406: PUSH
80407: LD_EXP 81
80411: PUSH
80412: LD_VAR 0 3
80416: ARRAY
80417: IN
80418: IFFALSE 80457
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
80420: LD_ADDR_EXP 81
80424: PUSH
80425: LD_EXP 81
80429: PPUSH
80430: LD_VAR 0 3
80434: PPUSH
80435: LD_EXP 81
80439: PUSH
80440: LD_VAR 0 3
80444: ARRAY
80445: PUSH
80446: LD_VAR 0 1
80450: DIFF
80451: PPUSH
80452: CALL_OW 1
80456: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
80457: LD_VAR 0 1
80461: PUSH
80462: LD_EXP 82
80466: PUSH
80467: LD_VAR 0 3
80471: ARRAY
80472: IN
80473: IFFALSE 80497
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80475: LD_ADDR_EXP 82
80479: PUSH
80480: LD_EXP 82
80484: PPUSH
80485: LD_VAR 0 3
80489: PPUSH
80490: EMPTY
80491: PPUSH
80492: CALL_OW 1
80496: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
80497: LD_VAR 0 1
80501: PPUSH
80502: CALL_OW 247
80506: PUSH
80507: LD_INT 2
80509: EQUAL
80510: PUSH
80511: LD_VAR 0 1
80515: PPUSH
80516: CALL_OW 110
80520: PUSH
80521: LD_INT 20
80523: EQUAL
80524: PUSH
80525: LD_VAR 0 1
80529: PUSH
80530: LD_EXP 74
80534: PUSH
80535: LD_VAR 0 3
80539: ARRAY
80540: IN
80541: OR
80542: AND
80543: IFFALSE 80704
// begin if un in mc_defender [ i ] then
80545: LD_VAR 0 1
80549: PUSH
80550: LD_EXP 74
80554: PUSH
80555: LD_VAR 0 3
80559: ARRAY
80560: IN
80561: IFFALSE 80600
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80563: LD_ADDR_EXP 74
80567: PUSH
80568: LD_EXP 74
80572: PPUSH
80573: LD_VAR 0 3
80577: PPUSH
80578: LD_EXP 74
80582: PUSH
80583: LD_VAR 0 3
80587: ARRAY
80588: PUSH
80589: LD_VAR 0 1
80593: DIFF
80594: PPUSH
80595: CALL_OW 1
80599: ST_TO_ADDR
// fac := MC_GetBuilding ( i , b_factory ) ;
80600: LD_ADDR_VAR 0 8
80604: PUSH
80605: LD_VAR 0 3
80609: PPUSH
80610: LD_INT 3
80612: PPUSH
80613: CALL 77293 0 2
80617: ST_TO_ADDR
// if fac then
80618: LD_VAR 0 8
80622: IFFALSE 80704
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
80624: LD_ADDR_VAR 0 9
80628: PUSH
80629: LD_VAR 0 8
80633: PPUSH
80634: LD_VAR 0 1
80638: PPUSH
80639: CALL_OW 265
80643: PPUSH
80644: LD_VAR 0 1
80648: PPUSH
80649: CALL_OW 262
80653: PPUSH
80654: LD_VAR 0 1
80658: PPUSH
80659: CALL_OW 263
80663: PPUSH
80664: LD_VAR 0 1
80668: PPUSH
80669: CALL_OW 264
80673: PPUSH
80674: CALL 15409 0 5
80678: ST_TO_ADDR
// if components then
80679: LD_VAR 0 9
80683: IFFALSE 80702
// MC_InsertProduceList ( i , [ components ] ) ;
80685: LD_VAR 0 3
80689: PPUSH
80690: LD_VAR 0 9
80694: PUSH
80695: EMPTY
80696: LIST
80697: PPUSH
80698: CALL 76921 0 2
// break ;
80702: GO 81366
// end ; end ; if GetType ( un ) = unit_building then
80704: LD_VAR 0 1
80708: PPUSH
80709: CALL_OW 247
80713: PUSH
80714: LD_INT 3
80716: EQUAL
80717: IFFALSE 81032
// begin btype := GetBType ( un ) ;
80719: LD_ADDR_VAR 0 5
80723: PUSH
80724: LD_VAR 0 1
80728: PPUSH
80729: CALL_OW 266
80733: ST_TO_ADDR
// if btype = b_warehouse then
80734: LD_VAR 0 5
80738: PUSH
80739: LD_INT 1
80741: EQUAL
80742: IFFALSE 80760
// begin btype := b_depot ;
80744: LD_ADDR_VAR 0 5
80748: PUSH
80749: LD_INT 0
80751: ST_TO_ADDR
// pos := 1 ;
80752: LD_ADDR_VAR 0 6
80756: PUSH
80757: LD_INT 1
80759: ST_TO_ADDR
// end ; if btype = b_factory then
80760: LD_VAR 0 5
80764: PUSH
80765: LD_INT 3
80767: EQUAL
80768: IFFALSE 80786
// begin btype := b_workshop ;
80770: LD_ADDR_VAR 0 5
80774: PUSH
80775: LD_INT 2
80777: ST_TO_ADDR
// pos := 1 ;
80778: LD_ADDR_VAR 0 6
80782: PUSH
80783: LD_INT 1
80785: ST_TO_ADDR
// end ; if btype = b_barracks then
80786: LD_VAR 0 5
80790: PUSH
80791: LD_INT 5
80793: EQUAL
80794: IFFALSE 80804
// btype := b_armoury ;
80796: LD_ADDR_VAR 0 5
80800: PUSH
80801: LD_INT 4
80803: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
80804: LD_VAR 0 5
80808: PUSH
80809: LD_INT 7
80811: PUSH
80812: LD_INT 8
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: IN
80819: IFFALSE 80829
// btype := b_lab ;
80821: LD_ADDR_VAR 0 5
80825: PUSH
80826: LD_INT 6
80828: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
80829: LD_ADDR_EXP 57
80833: PUSH
80834: LD_EXP 57
80838: PPUSH
80839: LD_VAR 0 3
80843: PUSH
80844: LD_EXP 57
80848: PUSH
80849: LD_VAR 0 3
80853: ARRAY
80854: PUSH
80855: LD_INT 1
80857: PLUS
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: PPUSH
80863: LD_VAR 0 5
80867: PUSH
80868: LD_VAR 0 1
80872: PPUSH
80873: CALL_OW 250
80877: PUSH
80878: LD_VAR 0 1
80882: PPUSH
80883: CALL_OW 251
80887: PUSH
80888: LD_VAR 0 1
80892: PPUSH
80893: CALL_OW 254
80897: PUSH
80898: EMPTY
80899: LIST
80900: LIST
80901: LIST
80902: LIST
80903: PPUSH
80904: CALL 17816 0 3
80908: ST_TO_ADDR
// if pos = 1 then
80909: LD_VAR 0 6
80913: PUSH
80914: LD_INT 1
80916: EQUAL
80917: IFFALSE 81032
// begin tmp := mc_build_list [ i ] ;
80919: LD_ADDR_VAR 0 7
80923: PUSH
80924: LD_EXP 57
80928: PUSH
80929: LD_VAR 0 3
80933: ARRAY
80934: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
80935: LD_VAR 0 7
80939: PPUSH
80940: LD_INT 2
80942: PUSH
80943: LD_INT 30
80945: PUSH
80946: LD_INT 0
80948: PUSH
80949: EMPTY
80950: LIST
80951: LIST
80952: PUSH
80953: LD_INT 30
80955: PUSH
80956: LD_INT 1
80958: PUSH
80959: EMPTY
80960: LIST
80961: LIST
80962: PUSH
80963: EMPTY
80964: LIST
80965: LIST
80966: LIST
80967: PPUSH
80968: CALL_OW 72
80972: IFFALSE 80982
// pos := 2 ;
80974: LD_ADDR_VAR 0 6
80978: PUSH
80979: LD_INT 2
80981: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
80982: LD_ADDR_VAR 0 7
80986: PUSH
80987: LD_VAR 0 7
80991: PPUSH
80992: LD_VAR 0 6
80996: PPUSH
80997: LD_VAR 0 7
81001: PPUSH
81002: CALL 18142 0 3
81006: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
81007: LD_ADDR_EXP 57
81011: PUSH
81012: LD_EXP 57
81016: PPUSH
81017: LD_VAR 0 3
81021: PPUSH
81022: LD_VAR 0 7
81026: PPUSH
81027: CALL_OW 1
81031: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
81032: LD_VAR 0 1
81036: PUSH
81037: LD_EXP 52
81041: PUSH
81042: LD_VAR 0 3
81046: ARRAY
81047: IN
81048: IFFALSE 81087
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
81050: LD_ADDR_EXP 52
81054: PUSH
81055: LD_EXP 52
81059: PPUSH
81060: LD_VAR 0 3
81064: PPUSH
81065: LD_EXP 52
81069: PUSH
81070: LD_VAR 0 3
81074: ARRAY
81075: PUSH
81076: LD_VAR 0 1
81080: DIFF
81081: PPUSH
81082: CALL_OW 1
81086: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
81087: LD_VAR 0 1
81091: PUSH
81092: LD_EXP 59
81096: PUSH
81097: LD_VAR 0 3
81101: ARRAY
81102: IN
81103: IFFALSE 81142
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
81105: LD_ADDR_EXP 59
81109: PUSH
81110: LD_EXP 59
81114: PPUSH
81115: LD_VAR 0 3
81119: PPUSH
81120: LD_EXP 59
81124: PUSH
81125: LD_VAR 0 3
81129: ARRAY
81130: PUSH
81131: LD_VAR 0 1
81135: DIFF
81136: PPUSH
81137: CALL_OW 1
81141: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
81142: LD_VAR 0 1
81146: PUSH
81147: LD_EXP 71
81151: PUSH
81152: LD_VAR 0 3
81156: ARRAY
81157: IN
81158: IFFALSE 81197
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
81160: LD_ADDR_EXP 71
81164: PUSH
81165: LD_EXP 71
81169: PPUSH
81170: LD_VAR 0 3
81174: PPUSH
81175: LD_EXP 71
81179: PUSH
81180: LD_VAR 0 3
81184: ARRAY
81185: PUSH
81186: LD_VAR 0 1
81190: DIFF
81191: PPUSH
81192: CALL_OW 1
81196: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
81197: LD_VAR 0 1
81201: PUSH
81202: LD_EXP 74
81206: PUSH
81207: LD_VAR 0 3
81211: ARRAY
81212: IN
81213: IFFALSE 81252
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81215: LD_ADDR_EXP 74
81219: PUSH
81220: LD_EXP 74
81224: PPUSH
81225: LD_VAR 0 3
81229: PPUSH
81230: LD_EXP 74
81234: PUSH
81235: LD_VAR 0 3
81239: ARRAY
81240: PUSH
81241: LD_VAR 0 1
81245: DIFF
81246: PPUSH
81247: CALL_OW 1
81251: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
81252: LD_VAR 0 1
81256: PUSH
81257: LD_EXP 61
81261: PUSH
81262: LD_VAR 0 3
81266: ARRAY
81267: IN
81268: IFFALSE 81307
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
81270: LD_ADDR_EXP 61
81274: PUSH
81275: LD_EXP 61
81279: PPUSH
81280: LD_VAR 0 3
81284: PPUSH
81285: LD_EXP 61
81289: PUSH
81290: LD_VAR 0 3
81294: ARRAY
81295: PUSH
81296: LD_VAR 0 1
81300: DIFF
81301: PPUSH
81302: CALL_OW 1
81306: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
81307: LD_VAR 0 1
81311: PUSH
81312: LD_EXP 60
81316: PUSH
81317: LD_VAR 0 3
81321: ARRAY
81322: IN
81323: IFFALSE 81362
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
81325: LD_ADDR_EXP 60
81329: PUSH
81330: LD_EXP 60
81334: PPUSH
81335: LD_VAR 0 3
81339: PPUSH
81340: LD_EXP 60
81344: PUSH
81345: LD_VAR 0 3
81349: ARRAY
81350: PUSH
81351: LD_VAR 0 1
81355: DIFF
81356: PPUSH
81357: CALL_OW 1
81361: ST_TO_ADDR
// end ; break ;
81362: GO 81366
// end ;
81364: GO 80291
81366: POP
81367: POP
// end ;
81368: LD_VAR 0 2
81372: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
81373: LD_INT 0
81375: PPUSH
81376: PPUSH
81377: PPUSH
// if not mc_bases or not skirmish then
81378: LD_EXP 52
81382: NOT
81383: PUSH
81384: LD_EXP 50
81388: NOT
81389: OR
81390: IFFALSE 81394
// exit ;
81392: GO 81609
// for i = 1 to mc_bases do
81394: LD_ADDR_VAR 0 3
81398: PUSH
81399: DOUBLE
81400: LD_INT 1
81402: DEC
81403: ST_TO_ADDR
81404: LD_EXP 52
81408: PUSH
81409: FOR_TO
81410: IFFALSE 81607
// begin if building in mc_construct_list [ i ] then
81412: LD_VAR 0 1
81416: PUSH
81417: LD_EXP 59
81421: PUSH
81422: LD_VAR 0 3
81426: ARRAY
81427: IN
81428: IFFALSE 81605
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81430: LD_ADDR_EXP 59
81434: PUSH
81435: LD_EXP 59
81439: PPUSH
81440: LD_VAR 0 3
81444: PPUSH
81445: LD_EXP 59
81449: PUSH
81450: LD_VAR 0 3
81454: ARRAY
81455: PUSH
81456: LD_VAR 0 1
81460: DIFF
81461: PPUSH
81462: CALL_OW 1
81466: ST_TO_ADDR
// if building in mc_lab [ i ] then
81467: LD_VAR 0 1
81471: PUSH
81472: LD_EXP 85
81476: PUSH
81477: LD_VAR 0 3
81481: ARRAY
81482: IN
81483: IFFALSE 81538
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
81485: LD_ADDR_EXP 86
81489: PUSH
81490: LD_EXP 86
81494: PPUSH
81495: LD_VAR 0 3
81499: PPUSH
81500: LD_EXP 86
81504: PUSH
81505: LD_VAR 0 3
81509: ARRAY
81510: PPUSH
81511: LD_INT 1
81513: PPUSH
81514: LD_EXP 86
81518: PUSH
81519: LD_VAR 0 3
81523: ARRAY
81524: PPUSH
81525: LD_INT 0
81527: PPUSH
81528: CALL 17234 0 4
81532: PPUSH
81533: CALL_OW 1
81537: ST_TO_ADDR
// if not building in mc_bases [ i ] then
81538: LD_VAR 0 1
81542: PUSH
81543: LD_EXP 52
81547: PUSH
81548: LD_VAR 0 3
81552: ARRAY
81553: IN
81554: NOT
81555: IFFALSE 81601
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81557: LD_ADDR_EXP 52
81561: PUSH
81562: LD_EXP 52
81566: PPUSH
81567: LD_VAR 0 3
81571: PUSH
81572: LD_EXP 52
81576: PUSH
81577: LD_VAR 0 3
81581: ARRAY
81582: PUSH
81583: LD_INT 1
81585: PLUS
81586: PUSH
81587: EMPTY
81588: LIST
81589: LIST
81590: PPUSH
81591: LD_VAR 0 1
81595: PPUSH
81596: CALL 17816 0 3
81600: ST_TO_ADDR
// exit ;
81601: POP
81602: POP
81603: GO 81609
// end ; end ;
81605: GO 81409
81607: POP
81608: POP
// end ;
81609: LD_VAR 0 2
81613: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
81614: LD_INT 0
81616: PPUSH
81617: PPUSH
81618: PPUSH
81619: PPUSH
81620: PPUSH
81621: PPUSH
81622: PPUSH
// if not mc_bases or not skirmish then
81623: LD_EXP 52
81627: NOT
81628: PUSH
81629: LD_EXP 50
81633: NOT
81634: OR
81635: IFFALSE 81639
// exit ;
81637: GO 82300
// for i = 1 to mc_bases do
81639: LD_ADDR_VAR 0 3
81643: PUSH
81644: DOUBLE
81645: LD_INT 1
81647: DEC
81648: ST_TO_ADDR
81649: LD_EXP 52
81653: PUSH
81654: FOR_TO
81655: IFFALSE 82298
// begin if building in mc_construct_list [ i ] then
81657: LD_VAR 0 1
81661: PUSH
81662: LD_EXP 59
81666: PUSH
81667: LD_VAR 0 3
81671: ARRAY
81672: IN
81673: IFFALSE 82296
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81675: LD_ADDR_EXP 59
81679: PUSH
81680: LD_EXP 59
81684: PPUSH
81685: LD_VAR 0 3
81689: PPUSH
81690: LD_EXP 59
81694: PUSH
81695: LD_VAR 0 3
81699: ARRAY
81700: PUSH
81701: LD_VAR 0 1
81705: DIFF
81706: PPUSH
81707: CALL_OW 1
81711: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81712: LD_ADDR_EXP 52
81716: PUSH
81717: LD_EXP 52
81721: PPUSH
81722: LD_VAR 0 3
81726: PUSH
81727: LD_EXP 52
81731: PUSH
81732: LD_VAR 0 3
81736: ARRAY
81737: PUSH
81738: LD_INT 1
81740: PLUS
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: PPUSH
81746: LD_VAR 0 1
81750: PPUSH
81751: CALL 17816 0 3
81755: ST_TO_ADDR
// btype := GetBType ( building ) ;
81756: LD_ADDR_VAR 0 5
81760: PUSH
81761: LD_VAR 0 1
81765: PPUSH
81766: CALL_OW 266
81770: ST_TO_ADDR
// side := GetSide ( building ) ;
81771: LD_ADDR_VAR 0 8
81775: PUSH
81776: LD_VAR 0 1
81780: PPUSH
81781: CALL_OW 255
81785: ST_TO_ADDR
// if btype = b_lab then
81786: LD_VAR 0 5
81790: PUSH
81791: LD_INT 6
81793: EQUAL
81794: IFFALSE 81844
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
81796: LD_ADDR_EXP 85
81800: PUSH
81801: LD_EXP 85
81805: PPUSH
81806: LD_VAR 0 3
81810: PUSH
81811: LD_EXP 85
81815: PUSH
81816: LD_VAR 0 3
81820: ARRAY
81821: PUSH
81822: LD_INT 1
81824: PLUS
81825: PUSH
81826: EMPTY
81827: LIST
81828: LIST
81829: PPUSH
81830: LD_VAR 0 1
81834: PPUSH
81835: CALL 17816 0 3
81839: ST_TO_ADDR
// exit ;
81840: POP
81841: POP
81842: GO 82300
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
81844: LD_VAR 0 5
81848: PUSH
81849: LD_INT 0
81851: PUSH
81852: LD_INT 2
81854: PUSH
81855: LD_INT 4
81857: PUSH
81858: EMPTY
81859: LIST
81860: LIST
81861: LIST
81862: IN
81863: IFFALSE 81987
// begin if btype = b_armoury then
81865: LD_VAR 0 5
81869: PUSH
81870: LD_INT 4
81872: EQUAL
81873: IFFALSE 81883
// btype := b_barracks ;
81875: LD_ADDR_VAR 0 5
81879: PUSH
81880: LD_INT 5
81882: ST_TO_ADDR
// if btype = b_depot then
81883: LD_VAR 0 5
81887: PUSH
81888: LD_INT 0
81890: EQUAL
81891: IFFALSE 81901
// btype := b_warehouse ;
81893: LD_ADDR_VAR 0 5
81897: PUSH
81898: LD_INT 1
81900: ST_TO_ADDR
// if btype = b_workshop then
81901: LD_VAR 0 5
81905: PUSH
81906: LD_INT 2
81908: EQUAL
81909: IFFALSE 81919
// btype := b_factory ;
81911: LD_ADDR_VAR 0 5
81915: PUSH
81916: LD_INT 3
81918: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
81919: LD_VAR 0 5
81923: PPUSH
81924: LD_VAR 0 8
81928: PPUSH
81929: CALL_OW 323
81933: PUSH
81934: LD_INT 1
81936: EQUAL
81937: IFFALSE 81983
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
81939: LD_ADDR_EXP 84
81943: PUSH
81944: LD_EXP 84
81948: PPUSH
81949: LD_VAR 0 3
81953: PUSH
81954: LD_EXP 84
81958: PUSH
81959: LD_VAR 0 3
81963: ARRAY
81964: PUSH
81965: LD_INT 1
81967: PLUS
81968: PUSH
81969: EMPTY
81970: LIST
81971: LIST
81972: PPUSH
81973: LD_VAR 0 1
81977: PPUSH
81978: CALL 17816 0 3
81982: ST_TO_ADDR
// exit ;
81983: POP
81984: POP
81985: GO 82300
// end ; if btype in [ b_bunker , b_turret ] then
81987: LD_VAR 0 5
81991: PUSH
81992: LD_INT 32
81994: PUSH
81995: LD_INT 33
81997: PUSH
81998: EMPTY
81999: LIST
82000: LIST
82001: IN
82002: IFFALSE 82292
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
82004: LD_ADDR_EXP 60
82008: PUSH
82009: LD_EXP 60
82013: PPUSH
82014: LD_VAR 0 3
82018: PUSH
82019: LD_EXP 60
82023: PUSH
82024: LD_VAR 0 3
82028: ARRAY
82029: PUSH
82030: LD_INT 1
82032: PLUS
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: PPUSH
82038: LD_VAR 0 1
82042: PPUSH
82043: CALL 17816 0 3
82047: ST_TO_ADDR
// if btype = b_bunker then
82048: LD_VAR 0 5
82052: PUSH
82053: LD_INT 32
82055: EQUAL
82056: IFFALSE 82292
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82058: LD_ADDR_EXP 61
82062: PUSH
82063: LD_EXP 61
82067: PPUSH
82068: LD_VAR 0 3
82072: PUSH
82073: LD_EXP 61
82077: PUSH
82078: LD_VAR 0 3
82082: ARRAY
82083: PUSH
82084: LD_INT 1
82086: PLUS
82087: PUSH
82088: EMPTY
82089: LIST
82090: LIST
82091: PPUSH
82092: LD_VAR 0 1
82096: PPUSH
82097: CALL 17816 0 3
82101: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
82102: LD_ADDR_VAR 0 6
82106: PUSH
82107: LD_EXP 52
82111: PUSH
82112: LD_VAR 0 3
82116: ARRAY
82117: PPUSH
82118: LD_INT 25
82120: PUSH
82121: LD_INT 1
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PUSH
82128: LD_INT 3
82130: PUSH
82131: LD_INT 54
82133: PUSH
82134: EMPTY
82135: LIST
82136: PUSH
82137: EMPTY
82138: LIST
82139: LIST
82140: PUSH
82141: EMPTY
82142: LIST
82143: LIST
82144: PPUSH
82145: CALL_OW 72
82149: ST_TO_ADDR
// if tmp then
82150: LD_VAR 0 6
82154: IFFALSE 82160
// exit ;
82156: POP
82157: POP
82158: GO 82300
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82160: LD_ADDR_VAR 0 6
82164: PUSH
82165: LD_EXP 52
82169: PUSH
82170: LD_VAR 0 3
82174: ARRAY
82175: PPUSH
82176: LD_INT 2
82178: PUSH
82179: LD_INT 30
82181: PUSH
82182: LD_INT 4
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: LD_INT 30
82191: PUSH
82192: LD_INT 5
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PUSH
82199: EMPTY
82200: LIST
82201: LIST
82202: LIST
82203: PPUSH
82204: CALL_OW 72
82208: ST_TO_ADDR
// if not tmp then
82209: LD_VAR 0 6
82213: NOT
82214: IFFALSE 82220
// exit ;
82216: POP
82217: POP
82218: GO 82300
// for j in tmp do
82220: LD_ADDR_VAR 0 4
82224: PUSH
82225: LD_VAR 0 6
82229: PUSH
82230: FOR_IN
82231: IFFALSE 82290
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
82233: LD_ADDR_VAR 0 7
82237: PUSH
82238: LD_VAR 0 4
82242: PPUSH
82243: CALL_OW 313
82247: PPUSH
82248: LD_INT 25
82250: PUSH
82251: LD_INT 1
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PPUSH
82258: CALL_OW 72
82262: ST_TO_ADDR
// if units then
82263: LD_VAR 0 7
82267: IFFALSE 82288
// begin ComExitBuilding ( units [ 1 ] ) ;
82269: LD_VAR 0 7
82273: PUSH
82274: LD_INT 1
82276: ARRAY
82277: PPUSH
82278: CALL_OW 122
// exit ;
82282: POP
82283: POP
82284: POP
82285: POP
82286: GO 82300
// end ; end ;
82288: GO 82230
82290: POP
82291: POP
// end ; end ; exit ;
82292: POP
82293: POP
82294: GO 82300
// end ; end ;
82296: GO 81654
82298: POP
82299: POP
// end ;
82300: LD_VAR 0 2
82304: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
82305: LD_INT 0
82307: PPUSH
82308: PPUSH
82309: PPUSH
82310: PPUSH
82311: PPUSH
82312: PPUSH
82313: PPUSH
// if not mc_bases or not skirmish then
82314: LD_EXP 52
82318: NOT
82319: PUSH
82320: LD_EXP 50
82324: NOT
82325: OR
82326: IFFALSE 82330
// exit ;
82328: GO 82561
// btype := GetBType ( building ) ;
82330: LD_ADDR_VAR 0 6
82334: PUSH
82335: LD_VAR 0 1
82339: PPUSH
82340: CALL_OW 266
82344: ST_TO_ADDR
// x := GetX ( building ) ;
82345: LD_ADDR_VAR 0 7
82349: PUSH
82350: LD_VAR 0 1
82354: PPUSH
82355: CALL_OW 250
82359: ST_TO_ADDR
// y := GetY ( building ) ;
82360: LD_ADDR_VAR 0 8
82364: PUSH
82365: LD_VAR 0 1
82369: PPUSH
82370: CALL_OW 251
82374: ST_TO_ADDR
// d := GetDir ( building ) ;
82375: LD_ADDR_VAR 0 9
82379: PUSH
82380: LD_VAR 0 1
82384: PPUSH
82385: CALL_OW 254
82389: ST_TO_ADDR
// for i = 1 to mc_bases do
82390: LD_ADDR_VAR 0 4
82394: PUSH
82395: DOUBLE
82396: LD_INT 1
82398: DEC
82399: ST_TO_ADDR
82400: LD_EXP 52
82404: PUSH
82405: FOR_TO
82406: IFFALSE 82559
// begin if not mc_build_list [ i ] then
82408: LD_EXP 57
82412: PUSH
82413: LD_VAR 0 4
82417: ARRAY
82418: NOT
82419: IFFALSE 82423
// continue ;
82421: GO 82405
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
82423: LD_VAR 0 6
82427: PUSH
82428: LD_VAR 0 7
82432: PUSH
82433: LD_VAR 0 8
82437: PUSH
82438: LD_VAR 0 9
82442: PUSH
82443: EMPTY
82444: LIST
82445: LIST
82446: LIST
82447: LIST
82448: PPUSH
82449: LD_EXP 57
82453: PUSH
82454: LD_VAR 0 4
82458: ARRAY
82459: PUSH
82460: LD_INT 1
82462: ARRAY
82463: PPUSH
82464: CALL 23985 0 2
82468: IFFALSE 82557
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
82470: LD_ADDR_EXP 57
82474: PUSH
82475: LD_EXP 57
82479: PPUSH
82480: LD_VAR 0 4
82484: PPUSH
82485: LD_EXP 57
82489: PUSH
82490: LD_VAR 0 4
82494: ARRAY
82495: PPUSH
82496: LD_INT 1
82498: PPUSH
82499: CALL_OW 3
82503: PPUSH
82504: CALL_OW 1
82508: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
82509: LD_ADDR_EXP 59
82513: PUSH
82514: LD_EXP 59
82518: PPUSH
82519: LD_VAR 0 4
82523: PUSH
82524: LD_EXP 59
82528: PUSH
82529: LD_VAR 0 4
82533: ARRAY
82534: PUSH
82535: LD_INT 1
82537: PLUS
82538: PUSH
82539: EMPTY
82540: LIST
82541: LIST
82542: PPUSH
82543: LD_VAR 0 1
82547: PPUSH
82548: CALL 17816 0 3
82552: ST_TO_ADDR
// exit ;
82553: POP
82554: POP
82555: GO 82561
// end ; end ;
82557: GO 82405
82559: POP
82560: POP
// end ;
82561: LD_VAR 0 3
82565: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
82566: LD_INT 0
82568: PPUSH
82569: PPUSH
82570: PPUSH
// if not mc_bases or not skirmish then
82571: LD_EXP 52
82575: NOT
82576: PUSH
82577: LD_EXP 50
82581: NOT
82582: OR
82583: IFFALSE 82587
// exit ;
82585: GO 82777
// for i = 1 to mc_bases do
82587: LD_ADDR_VAR 0 4
82591: PUSH
82592: DOUBLE
82593: LD_INT 1
82595: DEC
82596: ST_TO_ADDR
82597: LD_EXP 52
82601: PUSH
82602: FOR_TO
82603: IFFALSE 82690
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
82605: LD_VAR 0 1
82609: PUSH
82610: LD_EXP 60
82614: PUSH
82615: LD_VAR 0 4
82619: ARRAY
82620: IN
82621: PUSH
82622: LD_VAR 0 1
82626: PUSH
82627: LD_EXP 61
82631: PUSH
82632: LD_VAR 0 4
82636: ARRAY
82637: IN
82638: NOT
82639: AND
82640: IFFALSE 82688
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82642: LD_ADDR_EXP 61
82646: PUSH
82647: LD_EXP 61
82651: PPUSH
82652: LD_VAR 0 4
82656: PUSH
82657: LD_EXP 61
82661: PUSH
82662: LD_VAR 0 4
82666: ARRAY
82667: PUSH
82668: LD_INT 1
82670: PLUS
82671: PUSH
82672: EMPTY
82673: LIST
82674: LIST
82675: PPUSH
82676: LD_VAR 0 1
82680: PPUSH
82681: CALL 17816 0 3
82685: ST_TO_ADDR
// break ;
82686: GO 82690
// end ; end ;
82688: GO 82602
82690: POP
82691: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
82692: LD_VAR 0 1
82696: PPUSH
82697: CALL_OW 257
82701: PUSH
82702: LD_EXP 78
82706: IN
82707: PUSH
82708: LD_VAR 0 1
82712: PPUSH
82713: CALL_OW 266
82717: PUSH
82718: LD_INT 5
82720: EQUAL
82721: AND
82722: PUSH
82723: LD_VAR 0 2
82727: PPUSH
82728: CALL_OW 110
82732: PUSH
82733: LD_INT 18
82735: NONEQUAL
82736: AND
82737: IFFALSE 82777
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
82739: LD_VAR 0 2
82743: PPUSH
82744: CALL_OW 257
82748: PUSH
82749: LD_INT 5
82751: PUSH
82752: LD_INT 8
82754: PUSH
82755: LD_INT 9
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: LIST
82762: IN
82763: IFFALSE 82777
// SetClass ( unit , 1 ) ;
82765: LD_VAR 0 2
82769: PPUSH
82770: LD_INT 1
82772: PPUSH
82773: CALL_OW 336
// end ;
82777: LD_VAR 0 3
82781: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
82782: LD_INT 0
82784: PPUSH
82785: PPUSH
// if not mc_bases or not skirmish then
82786: LD_EXP 52
82790: NOT
82791: PUSH
82792: LD_EXP 50
82796: NOT
82797: OR
82798: IFFALSE 82802
// exit ;
82800: GO 82918
// if GetLives ( abandoned_vehicle ) > 250 then
82802: LD_VAR 0 2
82806: PPUSH
82807: CALL_OW 256
82811: PUSH
82812: LD_INT 250
82814: GREATER
82815: IFFALSE 82819
// exit ;
82817: GO 82918
// for i = 1 to mc_bases do
82819: LD_ADDR_VAR 0 6
82823: PUSH
82824: DOUBLE
82825: LD_INT 1
82827: DEC
82828: ST_TO_ADDR
82829: LD_EXP 52
82833: PUSH
82834: FOR_TO
82835: IFFALSE 82916
// begin if driver in mc_bases [ i ] then
82837: LD_VAR 0 1
82841: PUSH
82842: LD_EXP 52
82846: PUSH
82847: LD_VAR 0 6
82851: ARRAY
82852: IN
82853: IFFALSE 82914
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
82855: LD_VAR 0 1
82859: PPUSH
82860: LD_EXP 52
82864: PUSH
82865: LD_VAR 0 6
82869: ARRAY
82870: PPUSH
82871: LD_INT 2
82873: PUSH
82874: LD_INT 30
82876: PUSH
82877: LD_INT 0
82879: PUSH
82880: EMPTY
82881: LIST
82882: LIST
82883: PUSH
82884: LD_INT 30
82886: PUSH
82887: LD_INT 1
82889: PUSH
82890: EMPTY
82891: LIST
82892: LIST
82893: PUSH
82894: EMPTY
82895: LIST
82896: LIST
82897: LIST
82898: PPUSH
82899: CALL_OW 72
82903: PUSH
82904: LD_INT 1
82906: ARRAY
82907: PPUSH
82908: CALL_OW 112
// break ;
82912: GO 82916
// end ; end ;
82914: GO 82834
82916: POP
82917: POP
// end ; end_of_file end_of_file end_of_file
82918: LD_VAR 0 5
82922: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
82923: LD_INT 0
82925: PPUSH
82926: PPUSH
82927: PPUSH
82928: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
82929: LD_VAR 0 1
82933: PPUSH
82934: CALL_OW 264
82938: PUSH
82939: LD_EXP 49
82943: EQUAL
82944: IFFALSE 83016
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
82946: LD_INT 68
82948: PPUSH
82949: LD_VAR 0 1
82953: PPUSH
82954: CALL_OW 255
82958: PPUSH
82959: CALL_OW 321
82963: PUSH
82964: LD_INT 2
82966: EQUAL
82967: IFFALSE 82979
// eff := 70 else
82969: LD_ADDR_VAR 0 6
82973: PUSH
82974: LD_INT 70
82976: ST_TO_ADDR
82977: GO 82987
// eff := 30 ;
82979: LD_ADDR_VAR 0 6
82983: PUSH
82984: LD_INT 30
82986: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
82987: LD_VAR 0 1
82991: PPUSH
82992: CALL_OW 250
82996: PPUSH
82997: LD_VAR 0 1
83001: PPUSH
83002: CALL_OW 251
83006: PPUSH
83007: LD_VAR 0 6
83011: PPUSH
83012: CALL_OW 495
// end ; end ;
83016: LD_VAR 0 4
83020: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
83021: LD_INT 0
83023: PPUSH
83024: PPUSH
83025: PPUSH
83026: PPUSH
83027: PPUSH
83028: PPUSH
// if cmd = 124 then
83029: LD_VAR 0 1
83033: PUSH
83034: LD_INT 124
83036: EQUAL
83037: IFFALSE 83243
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
83039: LD_ADDR_VAR 0 5
83043: PUSH
83044: LD_INT 2
83046: PUSH
83047: LD_INT 34
83049: PUSH
83050: LD_INT 53
83052: PUSH
83053: EMPTY
83054: LIST
83055: LIST
83056: PUSH
83057: LD_INT 34
83059: PUSH
83060: LD_INT 14
83062: PUSH
83063: EMPTY
83064: LIST
83065: LIST
83066: PUSH
83067: EMPTY
83068: LIST
83069: LIST
83070: LIST
83071: PPUSH
83072: CALL_OW 69
83076: ST_TO_ADDR
// if not tmp then
83077: LD_VAR 0 5
83081: NOT
83082: IFFALSE 83086
// exit ;
83084: GO 83243
// for i in tmp do
83086: LD_ADDR_VAR 0 3
83090: PUSH
83091: LD_VAR 0 5
83095: PUSH
83096: FOR_IN
83097: IFFALSE 83241
// begin taskList := GetTaskList ( i ) ;
83099: LD_ADDR_VAR 0 6
83103: PUSH
83104: LD_VAR 0 3
83108: PPUSH
83109: CALL_OW 437
83113: ST_TO_ADDR
// if not taskList then
83114: LD_VAR 0 6
83118: NOT
83119: IFFALSE 83123
// continue ;
83121: GO 83096
// for j = 1 to taskList do
83123: LD_ADDR_VAR 0 4
83127: PUSH
83128: DOUBLE
83129: LD_INT 1
83131: DEC
83132: ST_TO_ADDR
83133: LD_VAR 0 6
83137: PUSH
83138: FOR_TO
83139: IFFALSE 83237
// if taskList [ j ] [ 1 ] = | then
83141: LD_VAR 0 6
83145: PUSH
83146: LD_VAR 0 4
83150: ARRAY
83151: PUSH
83152: LD_INT 1
83154: ARRAY
83155: PUSH
83156: LD_STRING |
83158: EQUAL
83159: IFFALSE 83235
// begin _taskList := Delete ( taskList , 1 ) ;
83161: LD_ADDR_VAR 0 7
83165: PUSH
83166: LD_VAR 0 6
83170: PPUSH
83171: LD_INT 1
83173: PPUSH
83174: CALL_OW 3
83178: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
83179: LD_VAR 0 3
83183: PPUSH
83184: LD_VAR 0 7
83188: PPUSH
83189: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
83193: LD_VAR 0 3
83197: PPUSH
83198: LD_VAR 0 6
83202: PUSH
83203: LD_VAR 0 4
83207: ARRAY
83208: PUSH
83209: LD_INT 2
83211: ARRAY
83212: PPUSH
83213: LD_VAR 0 6
83217: PUSH
83218: LD_VAR 0 4
83222: ARRAY
83223: PUSH
83224: LD_INT 3
83226: ARRAY
83227: PPUSH
83228: LD_INT 8
83230: PPUSH
83231: CALL 83248 0 4
// end ;
83235: GO 83138
83237: POP
83238: POP
// end ;
83239: GO 83096
83241: POP
83242: POP
// end ; end ;
83243: LD_VAR 0 2
83247: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
83248: LD_INT 0
83250: PPUSH
83251: PPUSH
83252: PPUSH
83253: PPUSH
83254: PPUSH
83255: PPUSH
83256: PPUSH
83257: PPUSH
83258: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
83259: LD_VAR 0 1
83263: NOT
83264: PUSH
83265: LD_VAR 0 2
83269: PPUSH
83270: LD_VAR 0 3
83274: PPUSH
83275: CALL_OW 488
83279: NOT
83280: OR
83281: PUSH
83282: LD_VAR 0 4
83286: NOT
83287: OR
83288: IFFALSE 83292
// exit ;
83290: GO 83632
// list := [ ] ;
83292: LD_ADDR_VAR 0 13
83296: PUSH
83297: EMPTY
83298: ST_TO_ADDR
// if x - r < 0 then
83299: LD_VAR 0 2
83303: PUSH
83304: LD_VAR 0 4
83308: MINUS
83309: PUSH
83310: LD_INT 0
83312: LESS
83313: IFFALSE 83325
// min_x := 0 else
83315: LD_ADDR_VAR 0 7
83319: PUSH
83320: LD_INT 0
83322: ST_TO_ADDR
83323: GO 83341
// min_x := x - r ;
83325: LD_ADDR_VAR 0 7
83329: PUSH
83330: LD_VAR 0 2
83334: PUSH
83335: LD_VAR 0 4
83339: MINUS
83340: ST_TO_ADDR
// if y - r < 0 then
83341: LD_VAR 0 3
83345: PUSH
83346: LD_VAR 0 4
83350: MINUS
83351: PUSH
83352: LD_INT 0
83354: LESS
83355: IFFALSE 83367
// min_y := 0 else
83357: LD_ADDR_VAR 0 8
83361: PUSH
83362: LD_INT 0
83364: ST_TO_ADDR
83365: GO 83383
// min_y := y - r ;
83367: LD_ADDR_VAR 0 8
83371: PUSH
83372: LD_VAR 0 3
83376: PUSH
83377: LD_VAR 0 4
83381: MINUS
83382: ST_TO_ADDR
// max_x := x + r ;
83383: LD_ADDR_VAR 0 9
83387: PUSH
83388: LD_VAR 0 2
83392: PUSH
83393: LD_VAR 0 4
83397: PLUS
83398: ST_TO_ADDR
// max_y := y + r ;
83399: LD_ADDR_VAR 0 10
83403: PUSH
83404: LD_VAR 0 3
83408: PUSH
83409: LD_VAR 0 4
83413: PLUS
83414: ST_TO_ADDR
// for _x = min_x to max_x do
83415: LD_ADDR_VAR 0 11
83419: PUSH
83420: DOUBLE
83421: LD_VAR 0 7
83425: DEC
83426: ST_TO_ADDR
83427: LD_VAR 0 9
83431: PUSH
83432: FOR_TO
83433: IFFALSE 83550
// for _y = min_y to max_y do
83435: LD_ADDR_VAR 0 12
83439: PUSH
83440: DOUBLE
83441: LD_VAR 0 8
83445: DEC
83446: ST_TO_ADDR
83447: LD_VAR 0 10
83451: PUSH
83452: FOR_TO
83453: IFFALSE 83546
// begin if not ValidHex ( _x , _y ) then
83455: LD_VAR 0 11
83459: PPUSH
83460: LD_VAR 0 12
83464: PPUSH
83465: CALL_OW 488
83469: NOT
83470: IFFALSE 83474
// continue ;
83472: GO 83452
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
83474: LD_VAR 0 11
83478: PPUSH
83479: LD_VAR 0 12
83483: PPUSH
83484: CALL_OW 351
83488: PUSH
83489: LD_VAR 0 11
83493: PPUSH
83494: LD_VAR 0 12
83498: PPUSH
83499: CALL_OW 554
83503: AND
83504: IFFALSE 83544
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
83506: LD_ADDR_VAR 0 13
83510: PUSH
83511: LD_VAR 0 13
83515: PPUSH
83516: LD_VAR 0 13
83520: PUSH
83521: LD_INT 1
83523: PLUS
83524: PPUSH
83525: LD_VAR 0 11
83529: PUSH
83530: LD_VAR 0 12
83534: PUSH
83535: EMPTY
83536: LIST
83537: LIST
83538: PPUSH
83539: CALL_OW 2
83543: ST_TO_ADDR
// end ;
83544: GO 83452
83546: POP
83547: POP
83548: GO 83432
83550: POP
83551: POP
// if not list then
83552: LD_VAR 0 13
83556: NOT
83557: IFFALSE 83561
// exit ;
83559: GO 83632
// for i in list do
83561: LD_ADDR_VAR 0 6
83565: PUSH
83566: LD_VAR 0 13
83570: PUSH
83571: FOR_IN
83572: IFFALSE 83630
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
83574: LD_VAR 0 1
83578: PPUSH
83579: LD_STRING M
83581: PUSH
83582: LD_VAR 0 6
83586: PUSH
83587: LD_INT 1
83589: ARRAY
83590: PUSH
83591: LD_VAR 0 6
83595: PUSH
83596: LD_INT 2
83598: ARRAY
83599: PUSH
83600: LD_INT 0
83602: PUSH
83603: LD_INT 0
83605: PUSH
83606: LD_INT 0
83608: PUSH
83609: LD_INT 0
83611: PUSH
83612: EMPTY
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: PUSH
83621: EMPTY
83622: LIST
83623: PPUSH
83624: CALL_OW 447
83628: GO 83571
83630: POP
83631: POP
// end ;
83632: LD_VAR 0 5
83636: RET
