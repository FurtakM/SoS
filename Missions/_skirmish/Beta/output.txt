// export MissionStart ; export southAreaBlocker ; starting begin southAreaBlocker = true ;
   0: LD_ADDR_EXP 2
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// ResetFog ;
   8: CALL_OW 335
// AnimateTrees ( true ) ;
  12: LD_INT 1
  14: PPUSH
  15: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  19: LD_INT 1
  21: PPUSH
  22: LD_INT 8
  24: PPUSH
  25: CALL_OW 332
// GameType ;
  29: CALL 5444 0 0
// SetBName ( BetaA , beta ) ;
  33: LD_INT 1
  35: PPUSH
  36: LD_STRING beta
  38: PPUSH
  39: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  43: LD_INT 3
  45: PPUSH
  46: LD_STRING beta
  48: PPUSH
  49: CALL_OW 500
// SetResourceType ( GetBase ( BetaA ) , mat_cans , startCrates [ 1 ] ) ;
  53: LD_INT 1
  55: PPUSH
  56: CALL_OW 274
  60: PPUSH
  61: LD_INT 1
  63: PPUSH
  64: LD_EXP 43
  68: PUSH
  69: LD_INT 1
  71: ARRAY
  72: PPUSH
  73: CALL_OW 277
// SetResourceType ( GetBase ( BetaB ) , mat_cans , startCrates [ 2 ] ) ;
  77: LD_INT 3
  79: PPUSH
  80: CALL_OW 274
  84: PPUSH
  85: LD_INT 1
  87: PPUSH
  88: LD_EXP 43
  92: PUSH
  93: LD_INT 2
  95: ARRAY
  96: PPUSH
  97: CALL_OW 277
// PrepareHeroes ;
 101: CALL 2607 0 0
// PrepareBeta ;
 105: CALL 2996 0 0
// HideArea ( 1 , SouthArea ) ;
 109: LD_INT 1
 111: PPUSH
 112: LD_INT 16
 114: PPUSH
 115: CALL_OW 333
// InGameOn ;
 119: CALL_OW 8
// ComHold ( Brighton ) ;
 123: LD_EXP 9
 127: PPUSH
 128: CALL_OW 140
// CenterNowOnUnits ( Brighton ) ;
 132: LD_EXP 9
 136: PPUSH
 137: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
 141: LD_EXP 11
 145: PPUSH
 146: LD_INT 50
 148: PPUSH
 149: LD_INT 42
 151: PPUSH
 152: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
 156: LD_INT 35
 158: PPUSH
 159: CALL_OW 67
 163: LD_EXP 11
 167: PPUSH
 168: LD_EXP 9
 172: PPUSH
 173: CALL_OW 296
 177: PUSH
 178: LD_INT 3
 180: LESS
 181: IFFALSE 156
// ComTurnUnit ( Megan , Brighton ) ;
 183: LD_EXP 11
 187: PPUSH
 188: LD_EXP 9
 192: PPUSH
 193: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 197: LD_EXP 11
 201: PPUSH
 202: LD_STRING DMegan-1a
 204: PPUSH
 205: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 209: LD_INT 10
 211: PPUSH
 212: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 216: LD_EXP 9
 220: PPUSH
 221: LD_EXP 11
 225: PPUSH
 226: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 230: LD_EXP 9
 234: PPUSH
 235: LD_STRING DBrighton-1a
 237: PPUSH
 238: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 242: LD_EXP 11
 246: PPUSH
 247: LD_STRING DMegan-2a
 249: PPUSH
 250: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 254: LD_EXP 9
 258: PPUSH
 259: LD_STRING DBrighton-2a
 261: PPUSH
 262: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 266: LD_EXP 11
 270: PPUSH
 271: LD_INT 40
 273: PPUSH
 274: LD_INT 37
 276: PPUSH
 277: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 281: LD_EXP 11
 285: PPUSH
 286: LD_EXP 9
 290: PPUSH
 291: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 295: LD_EXP 10
 299: PPUSH
 300: LD_INT 50
 302: PPUSH
 303: LD_INT 42
 305: PPUSH
 306: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 310: LD_INT 35
 312: PPUSH
 313: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 317: LD_EXP 9
 321: PPUSH
 322: LD_EXP 10
 326: PPUSH
 327: CALL_OW 296
 331: PUSH
 332: LD_INT 6
 334: LESS
 335: IFFALSE 310
// ComTurnUnit ( Brighton , Palmer ) ;
 337: LD_EXP 9
 341: PPUSH
 342: LD_EXP 10
 346: PPUSH
 347: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 351: LD_EXP 10
 355: PPUSH
 356: LD_EXP 9
 360: PPUSH
 361: CALL_OW 119
// Say ( Palmer , DPalmer-1 ) ;
 365: LD_EXP 10
 369: PPUSH
 370: LD_STRING DPalmer-1
 372: PPUSH
 373: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 377: LD_EXP 9
 381: PPUSH
 382: LD_STRING DBrighton-1
 384: PPUSH
 385: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 389: LD_EXP 10
 393: PPUSH
 394: LD_STRING DPalmer-2
 396: PPUSH
 397: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 401: LD_EXP 9
 405: PPUSH
 406: LD_STRING DBrighton-2
 408: PPUSH
 409: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 413: LD_EXP 10
 417: PPUSH
 418: LD_STRING DPalmer-3
 420: PPUSH
 421: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 425: LD_EXP 9
 429: PPUSH
 430: LD_STRING DBrighton-3
 432: PPUSH
 433: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 437: LD_EXP 10
 441: PPUSH
 442: LD_STRING DPalmer-4
 444: PPUSH
 445: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 449: LD_EXP 10
 453: PPUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 461: LD_INT 35
 463: PPUSH
 464: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 468: LD_EXP 10
 472: PPUSH
 473: CALL_OW 310
 477: PUSH
 478: LD_INT 6
 480: EQUAL
 481: IFFALSE 461
// SayRadio ( Palmer , DPalmer-5 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_STRING DPalmer-5
 490: PPUSH
 491: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 495: LD_EXP 9
 499: PPUSH
 500: LD_INT 59
 502: PPUSH
 503: LD_INT 36
 505: PPUSH
 506: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 510: LD_EXP 11
 514: PPUSH
 515: LD_INT 60
 517: PPUSH
 518: LD_INT 35
 520: PPUSH
 521: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 525: LD_EXP 10
 529: PPUSH
 530: LD_INT 60
 532: PPUSH
 533: LD_INT 34
 535: PPUSH
 536: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 540: LD_EXP 9
 544: PPUSH
 545: LD_INT 99
 547: PPUSH
 548: LD_INT 37
 550: PPUSH
 551: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 555: LD_EXP 11
 559: PPUSH
 560: LD_EXP 9
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 569: LD_EXP 10
 573: PPUSH
 574: LD_EXP 9
 578: PPUSH
 579: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 583: LD_INT 64
 585: PPUSH
 586: LD_INT 40
 588: PPUSH
 589: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 593: LD_EXP 12
 597: PPUSH
 598: LD_INT 13
 600: PPUSH
 601: CALL 12715 0 2
// wait ( 0 0$30 ) ;
 605: LD_INT 1050
 607: PPUSH
 608: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 612: LD_EXP 9
 616: PPUSH
 617: LD_STRING DBrighton-4
 619: PPUSH
 620: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 624: LD_EXP 9
 628: PPUSH
 629: LD_STRING DBrighton-5
 631: PPUSH
 632: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 636: LD_EXP 9
 640: PPUSH
 641: LD_EXP 11
 645: PPUSH
 646: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 650: LD_EXP 9
 654: PPUSH
 655: LD_STRING DBrighton-6
 657: PPUSH
 658: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 662: LD_EXP 11
 666: PPUSH
 667: LD_STRING DMegan-1
 669: PPUSH
 670: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 674: LD_EXP 9
 678: PPUSH
 679: LD_STRING DBrighton-7
 681: PPUSH
 682: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 686: LD_EXP 9
 690: PPUSH
 691: LD_INT 99
 693: PPUSH
 694: LD_INT 37
 696: PPUSH
 697: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 701: LD_EXP 9
 705: PPUSH
 706: LD_STRING DBrighton-8
 708: PPUSH
 709: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 713: LD_STRING C1
 715: PPUSH
 716: CALL_OW 337
// InGameOff ;
 720: CALL_OW 9
// SaveForQuickRestart ;
 724: CALL_OW 22
// MissionStart := true ;
 728: LD_ADDR_EXP 1
 732: PUSH
 733: LD_INT 1
 735: ST_TO_ADDR
// PrepareRUBase_v2 ;
 736: CALL 4719 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 740: LD_ADDR_EXP 68
 744: PUSH
 745: LD_EXP 68
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: PPUSH
 763: CALL_OW 69
 767: PPUSH
 768: CALL_OW 1
 772: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 773: LD_ADDR_EXP 68
 777: PUSH
 778: LD_EXP 68
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: LD_EXP 36
 790: PPUSH
 791: CALL_OW 1
 795: ST_TO_ADDR
// MC_Start ( ) ;
 796: CALL 53583 0 0
// music_nat := 1 ;
 800: LD_ADDR_OWVAR 71
 804: PUSH
 805: LD_INT 1
 807: ST_TO_ADDR
// end ;
 808: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var i , tmp ;
 809: LD_EXP 1
 813: IFFALSE 1237
 815: GO 817
 817: DISABLE
 818: LD_INT 0
 820: PPUSH
 821: PPUSH
// begin wait ( ruArrival ) ;
 822: LD_EXP 42
 826: PPUSH
 827: CALL_OW 67
// PrepareRUArmada ;
 831: CALL 3578 0 0
// wait ( 0 0$3 ) ;
 835: LD_INT 105
 837: PPUSH
 838: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 842: LD_ADDR_VAR 0 2
 846: PUSH
 847: LD_INT 15
 849: PPUSH
 850: LD_INT 0
 852: PPUSH
 853: CALL_OW 517
 857: ST_TO_ADDR
// for i = 1 to RUArmada do
 858: LD_ADDR_VAR 0 1
 862: PUSH
 863: DOUBLE
 864: LD_INT 1
 866: DEC
 867: ST_TO_ADDR
 868: LD_EXP 17
 872: PUSH
 873: FOR_TO
 874: IFFALSE 923
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 876: LD_EXP 17
 880: PUSH
 881: LD_VAR 0 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 1
 894: ARRAY
 895: PUSH
 896: LD_VAR 0 1
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 2
 909: ARRAY
 910: PUSH
 911: LD_VAR 0 1
 915: ARRAY
 916: PPUSH
 917: CALL_OW 111
 921: GO 873
 923: POP
 924: POP
// ArmadaArrived := true ;
 925: LD_ADDR_EXP 3
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 933: LD_EXP 10
 937: PPUSH
 938: LD_STRING DPalmer-A1
 940: PPUSH
 941: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 945: LD_EXP 9
 949: PPUSH
 950: LD_STRING DBrighton-A1
 952: PPUSH
 953: CALL_OW 88
// wait ( 0 0$20 ) ;
 957: LD_INT 700
 959: PPUSH
 960: CALL_OW 67
// PrepareRUBase ;
 964: CALL 4303 0 0
// wait ( 1 1$20 ) ;
 968: LD_INT 2800
 970: PPUSH
 971: CALL_OW 67
// PrepareRUBulldozers ;
 975: CALL 4190 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 979: LD_EXP 18
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: LD_INT 9
 990: PPUSH
 991: CALL 12572 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 995: LD_EXP 18
 999: PUSH
1000: LD_INT 2
1002: ARRAY
1003: PPUSH
1004: LD_INT 11
1006: PPUSH
1007: CALL 12572 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
1011: LD_INT 1
1013: PPUSH
1014: LD_EXP 18
1018: PUSH
1019: LD_INT 1
1021: ARRAY
1022: PPUSH
1023: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1027: LD_INT 1
1029: PPUSH
1030: LD_EXP 18
1034: PUSH
1035: LD_INT 2
1037: ARRAY
1038: PPUSH
1039: CALL_OW 471
// wait ( 1 1$20 ) ;
1043: LD_INT 2800
1045: PPUSH
1046: CALL_OW 67
// ComMoveXY ( Bulldozers , 64 , 114 ) ;
1050: LD_EXP 18
1054: PPUSH
1055: LD_INT 64
1057: PPUSH
1058: LD_INT 114
1060: PPUSH
1061: CALL_OW 111
// wait ( 0 0$10 ) ;
1065: LD_INT 350
1067: PPUSH
1068: CALL_OW 67
// for i := 1 to 2 do
1072: LD_ADDR_VAR 0 1
1076: PUSH
1077: DOUBLE
1078: LD_INT 1
1080: DEC
1081: ST_TO_ADDR
1082: LD_INT 2
1084: PUSH
1085: FOR_TO
1086: IFFALSE 1105
// RemoveUnit ( Bulldozers [ i ] ) ;
1088: LD_EXP 18
1092: PUSH
1093: LD_VAR 0 1
1097: ARRAY
1098: PPUSH
1099: CALL_OW 64
1103: GO 1085
1105: POP
1106: POP
// RemoveEnvironmentArea ( BulldozerArea ) ;
1107: LD_INT 9
1109: PPUSH
1110: CALL_OW 355
// RemoveEnvironmentArea ( BulldozerArea2 ) ;
1114: LD_INT 11
1116: PPUSH
1117: CALL_OW 355
// SayEffect ( DRuSol-A1 ) ;
1121: LD_STRING DRuSol-A1
1123: PPUSH
1124: CALL_OW 96
// AssaultStarted := true ;
1128: LD_ADDR_EXP 8
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// wait ( 0 0$2 ) ;
1136: LD_INT 70
1138: PPUSH
1139: CALL_OW 67
// Say ( Yashin , DDeath-Yas-1 ) ;
1143: LD_EXP 13
1147: PPUSH
1148: LD_STRING DDeath-Yas-1
1150: PPUSH
1151: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-2 ) ;
1155: LD_EXP 15
1159: PPUSH
1160: LD_STRING DDeath-Gay-2
1162: PPUSH
1163: CALL_OW 88
// wait ( 0 0$2 ) ;
1167: LD_INT 70
1169: PPUSH
1170: CALL_OW 67
// Say ( Popov , DDeath-Pop-1 ) ;
1174: LD_EXP 14
1178: PPUSH
1179: LD_STRING DDeath-Pop-1
1181: PPUSH
1182: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1186: LD_EXP 15
1190: PPUSH
1191: LD_STRING DDeath-Gay-1
1193: PPUSH
1194: CALL_OW 88
// wait ( 0 0$5 ) ;
1198: LD_INT 175
1200: PPUSH
1201: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1205: LD_EXP 16
1209: PPUSH
1210: LD_STRING DDeath-Vse-1
1212: PPUSH
1213: CALL_OW 88
// Say ( Popov , DDeath-Pop-2 ) ;
1217: LD_EXP 14
1221: PPUSH
1222: LD_STRING DDeath-Pop-2
1224: PPUSH
1225: CALL_OW 88
// southAreaBlocker = false ;
1229: LD_ADDR_EXP 2
1233: PUSH
1234: LD_INT 0
1236: ST_TO_ADDR
// end ;
1237: PPOPN 2
1239: END
// every 0 0$1 trigger AssaultStarted do var i , tmp ;
1240: LD_EXP 8
1244: IFFALSE 1835
1246: GO 1248
1248: DISABLE
1249: LD_INT 0
1251: PPUSH
1252: PPUSH
// begin PriorityAttack ( 6 , BetaA ) ;
1253: LD_INT 6
1255: PPUSH
1256: LD_INT 1
1258: PPUSH
1259: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1263: LD_INT 6
1265: PPUSH
1266: LD_INT 3
1268: PPUSH
1269: CALL_OW 470
// repeat for i in RuArmada do
1273: LD_ADDR_VAR 0 1
1277: PUSH
1278: LD_EXP 17
1282: PUSH
1283: FOR_IN
1284: IFFALSE 1487
// begin if GetDistUnitXY ( i , 87 , 77 ) < 10 and not GetTag ( i ) then
1286: LD_VAR 0 1
1290: PPUSH
1291: LD_INT 87
1293: PPUSH
1294: LD_INT 77
1296: PPUSH
1297: CALL_OW 297
1301: PUSH
1302: LD_INT 10
1304: LESS
1305: PUSH
1306: LD_VAR 0 1
1310: PPUSH
1311: CALL_OW 110
1315: NOT
1316: AND
1317: IFFALSE 1331
// SetTag ( i , 1 ) ;
1319: LD_VAR 0 1
1323: PPUSH
1324: LD_INT 1
1326: PPUSH
1327: CALL_OW 109
// if GetDistUnitXY ( i , 62 , 48 ) < 10 and GetTag ( i ) < 2 then
1331: LD_VAR 0 1
1335: PPUSH
1336: LD_INT 62
1338: PPUSH
1339: LD_INT 48
1341: PPUSH
1342: CALL_OW 297
1346: PUSH
1347: LD_INT 10
1349: LESS
1350: PUSH
1351: LD_VAR 0 1
1355: PPUSH
1356: CALL_OW 110
1360: PUSH
1361: LD_INT 2
1363: LESS
1364: AND
1365: IFFALSE 1379
// SetTag ( i , 2 ) ;
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_INT 2
1374: PPUSH
1375: CALL_OW 109
// if not GetTag ( i ) then
1379: LD_VAR 0 1
1383: PPUSH
1384: CALL_OW 110
1388: NOT
1389: IFFALSE 1406
// ComAgressiveMove ( i , 87 , 77 ) ;
1391: LD_VAR 0 1
1395: PPUSH
1396: LD_INT 87
1398: PPUSH
1399: LD_INT 77
1401: PPUSH
1402: CALL_OW 114
// if GetTag ( i ) = 1 then
1406: LD_VAR 0 1
1410: PPUSH
1411: CALL_OW 110
1415: PUSH
1416: LD_INT 1
1418: EQUAL
1419: IFFALSE 1436
// ComAgressiveMove ( i , 62 , 48 ) ;
1421: LD_VAR 0 1
1425: PPUSH
1426: LD_INT 62
1428: PPUSH
1429: LD_INT 48
1431: PPUSH
1432: CALL_OW 114
// if GetTag ( i ) = 2 then
1436: LD_VAR 0 1
1440: PPUSH
1441: CALL_OW 110
1445: PUSH
1446: LD_INT 2
1448: EQUAL
1449: IFFALSE 1485
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1451: LD_VAR 0 1
1455: PPUSH
1456: LD_INT 22
1458: PUSH
1459: LD_INT 1
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PPUSH
1466: CALL_OW 69
1470: PPUSH
1471: LD_VAR 0 1
1475: PPUSH
1476: CALL_OW 74
1480: PPUSH
1481: CALL_OW 115
// end ;
1485: GO 1283
1487: POP
1488: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1489: LD_INT 35
1491: PPUSH
1492: CALL_OW 67
1496: LD_INT 1
1498: PUSH
1499: LD_INT 22
1501: PUSH
1502: LD_INT 6
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: PUSH
1509: LD_INT 21
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: EMPTY
1516: LIST
1517: LIST
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PPUSH
1524: CALL_OW 69
1528: PUSH
1529: LD_INT 10
1531: LESS
1532: PUSH
1533: LD_EXP 13
1537: PPUSH
1538: CALL_OW 301
1542: AND
1543: PUSH
1544: LD_EXP 14
1548: PPUSH
1549: CALL_OW 301
1553: AND
1554: PUSH
1555: LD_EXP 15
1559: PPUSH
1560: CALL_OW 301
1564: AND
1565: PUSH
1566: LD_EXP 16
1570: PPUSH
1571: CALL_OW 301
1575: AND
1576: IFFALSE 1273
// AssaultStarted := false ;
1578: LD_ADDR_EXP 8
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 6 ] ) , RUArrivalArea ) ;
1586: LD_INT 22
1588: PUSH
1589: LD_INT 6
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PPUSH
1596: CALL_OW 69
1600: PPUSH
1601: LD_INT 5
1603: PPUSH
1604: CALL_OW 113
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1608: LD_ADDR_EXP 5
1612: PUSH
1613: LD_INT 1
1615: PUSH
1616: LD_INT 22
1618: PUSH
1619: LD_INT 6
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: LD_INT 26
1628: PUSH
1629: LD_INT 1
1631: PUSH
1632: EMPTY
1633: LIST
1634: LIST
1635: PUSH
1636: LD_INT 21
1638: PUSH
1639: LD_INT 1
1641: PUSH
1642: EMPTY
1643: LIST
1644: LIST
1645: PUSH
1646: LD_INT 24
1648: PUSH
1649: LD_INT 500
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: PPUSH
1663: CALL_OW 69
1667: ST_TO_ADDR
// if RuSpeaker then
1668: LD_EXP 5
1672: IFFALSE 1690
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1674: LD_EXP 5
1678: PUSH
1679: LD_INT 1
1681: ARRAY
1682: PPUSH
1683: LD_STRING DRuSol-A2
1685: PPUSH
1686: CALL_OW 88
// wait ( 0 0$30 ) ;
1690: LD_INT 1050
1692: PPUSH
1693: CALL_OW 67
// DialogueOn ;
1697: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1701: LD_EXP 9
1705: PPUSH
1706: LD_STRING DBrighton-B1
1708: PPUSH
1709: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1713: LD_EXP 10
1717: PPUSH
1718: LD_STRING DPalmer-B1
1720: PPUSH
1721: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1725: LD_EXP 9
1729: PPUSH
1730: LD_STRING DBrighton-B2
1732: PPUSH
1733: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1737: LD_EXP 19
1741: PPUSH
1742: LD_STRING DBurlak-B1
1744: PPUSH
1745: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1749: LD_EXP 9
1753: PPUSH
1754: LD_STRING DBrighton-B3
1756: PPUSH
1757: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1761: LD_EXP 10
1765: PPUSH
1766: LD_STRING DPalmer-B2
1768: PPUSH
1769: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1773: LD_EXP 9
1777: PPUSH
1778: LD_STRING DBrighton-B4
1780: PPUSH
1781: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1785: LD_EXP 9
1789: PPUSH
1790: LD_STRING DBrighton-B5
1792: PPUSH
1793: CALL_OW 88
// DialogueOff ;
1797: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1801: LD_STRING C2
1803: PPUSH
1804: CALL_OW 337
// FirstAssaultRepelled := true ;
1808: LD_ADDR_EXP 4
1812: PUSH
1813: LD_INT 1
1815: ST_TO_ADDR
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1816: LD_INT 22
1818: PUSH
1819: LD_INT 6
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 69
1830: PPUSH
1831: CALL_OW 181
// end ;
1835: PPOPN 2
1837: END
// every 0 0$1 trigger FirstAssaultRepelled do var unit , insideUnit ;
1838: LD_EXP 4
1842: IFFALSE 2007
1844: GO 1846
1846: DISABLE
1847: LD_INT 0
1849: PPUSH
1850: PPUSH
// begin enable ;
1851: ENABLE
// if FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) = 0 then
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 22
1857: PUSH
1858: LD_INT 6
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: PPUSH
1868: CALL_OW 70
1872: PUSH
1873: LD_INT 0
1875: EQUAL
1876: IFFALSE 1880
// exit ;
1878: GO 2007
// for unit in FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) do
1880: LD_ADDR_VAR 0 1
1884: PUSH
1885: LD_INT 5
1887: PPUSH
1888: LD_INT 22
1890: PUSH
1891: LD_INT 6
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: PUSH
1898: EMPTY
1899: LIST
1900: PPUSH
1901: CALL_OW 70
1905: PUSH
1906: FOR_IN
1907: IFFALSE 2005
// begin SetSide ( unit , 3 ) ;
1909: LD_VAR 0 1
1913: PPUSH
1914: LD_INT 3
1916: PPUSH
1917: CALL_OW 235
// if ( GetType ( unit ) = unit_vehicle ) then
1921: LD_VAR 0 1
1925: PPUSH
1926: CALL_OW 247
1930: PUSH
1931: LD_INT 2
1933: EQUAL
1934: IFFALSE 1970
// for insideUnit in UnitsInside ( unit ) do
1936: LD_ADDR_VAR 0 2
1940: PUSH
1941: LD_VAR 0 1
1945: PPUSH
1946: CALL_OW 313
1950: PUSH
1951: FOR_IN
1952: IFFALSE 1968
// SetSide ( insideUnit , 3 ) ;
1954: LD_VAR 0 2
1958: PPUSH
1959: LD_INT 3
1961: PPUSH
1962: CALL_OW 235
1966: GO 1951
1968: POP
1969: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
1970: LD_ADDR_EXP 68
1974: PUSH
1975: LD_EXP 68
1979: PPUSH
1980: LD_INT 1
1982: PPUSH
1983: LD_INT 22
1985: PUSH
1986: LD_INT 3
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: PPUSH
1993: CALL_OW 69
1997: PPUSH
1998: CALL_OW 1
2002: ST_TO_ADDR
// end ;
2003: GO 1906
2005: POP
2006: POP
// end ;
2007: PPOPN 2
2009: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
2010: LD_EXP 4
2014: PUSH
2015: LD_EXP 41
2019: PUSH
2020: LD_INT 0
2022: GREATER
2023: AND
2024: IFFALSE 2044
2026: GO 2028
2028: DISABLE
// begin enable ;
2029: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
2030: LD_ADDR_EXP 41
2034: PUSH
2035: LD_EXP 41
2039: PUSH
2040: LD_INT 35
2042: MINUS
2043: ST_TO_ADDR
// end ;
2044: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
2045: LD_EXP 41
2049: PUSH
2050: LD_INT 0
2052: EQUAL
2053: IFFALSE 2159
2055: GO 2057
2057: DISABLE
// begin JMMReinforcement ;
2058: CALL 5047 0 0
// DialogueOn ;
2062: CALL_OW 6
// CenterOnUnits ( JMM ) ;
2066: LD_EXP 37
2070: PPUSH
2071: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
2075: LD_EXP 37
2079: PPUSH
2080: LD_STRING DJMM-F1
2082: PPUSH
2083: CALL_OW 88
// if RussiansDefeated then
2087: LD_EXP 44
2091: IFFALSE 2117
// begin AddMedal ( Russians , 1 ) ;
2093: LD_STRING Russians
2095: PPUSH
2096: LD_INT 1
2098: PPUSH
2099: CALL_OW 101
// Say ( Brighton , DBrighton-F1a ) ;
2103: LD_EXP 9
2107: PPUSH
2108: LD_STRING DBrighton-F1a
2110: PPUSH
2111: CALL_OW 88
// end else
2115: GO 2147
// begin AddMedal ( Russians , - 1 ) ;
2117: LD_STRING Russians
2119: PPUSH
2120: LD_INT 1
2122: NEG
2123: PPUSH
2124: CALL_OW 101
// Say ( Brighton , DBrighton-F1 ) ;
2128: LD_EXP 9
2132: PPUSH
2133: LD_STRING DBrighton-F1
2135: PPUSH
2136: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2140: LD_STRING C3
2142: PPUSH
2143: CALL_OW 337
// end ; DialogueOff ;
2147: CALL_OW 7
// JMM_Arrived := true ;
2151: LD_ADDR_EXP 6
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// end ;
2159: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2160: LD_EXP 6
2164: PUSH
2165: LD_INT 1
2167: PPUSH
2168: LD_EXP 19
2172: PPUSH
2173: CALL_OW 292
2177: AND
2178: IFFALSE 2207
2180: GO 2182
2182: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2183: LD_EXP 19
2187: PPUSH
2188: LD_STRING DBurlak
2190: PPUSH
2191: CALL_OW 88
// Say ( JMM , DJMM ) ;
2195: LD_EXP 37
2199: PPUSH
2200: LD_STRING DJMM
2202: PPUSH
2203: CALL_OW 88
// end ;
2207: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2208: LD_INT 1
2210: PUSH
2211: LD_INT 22
2213: PUSH
2214: LD_INT 1
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PUSH
2221: LD_INT 2
2223: PUSH
2224: LD_INT 34
2226: PUSH
2227: LD_INT 9
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: PUSH
2234: LD_INT 35
2236: PUSH
2237: LD_INT 9
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: PUSH
2259: LD_INT 1
2261: GREATER
2262: IFFALSE 2275
2264: GO 2266
2266: DISABLE
// LaserBuilt := true ;
2267: LD_ADDR_EXP 7
2271: PUSH
2272: LD_INT 1
2274: ST_TO_ADDR
2275: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2276: LD_EXP 8
2280: PUSH
2281: LD_INT 6
2283: PPUSH
2284: LD_INT 1
2286: PUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: LD_INT 35
2299: PUSH
2300: LD_INT 9
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PUSH
2307: EMPTY
2308: LIST
2309: LIST
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PPUSH
2320: LD_EXP 16
2324: PPUSH
2325: CALL_OW 310
2329: PPUSH
2330: CALL_OW 74
2334: PPUSH
2335: CALL_OW 292
2339: AND
2340: IFFALSE 2369
2342: GO 2344
2344: DISABLE
// begin Say ( Sevi , DDeath-Vse-2 ) ;
2345: LD_EXP 16
2349: PPUSH
2350: LD_STRING DDeath-Vse-2
2352: PPUSH
2353: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2357: LD_EXP 13
2361: PPUSH
2362: LD_STRING DDeath-Yas-2
2364: PPUSH
2365: CALL_OW 88
// end ;
2369: END
// every 0 0$1 trigger MissionStart and GetResourceArea ( CratesArea , mat_cans ) < 20 do
2370: LD_EXP 1
2374: PUSH
2375: LD_INT 12
2377: PPUSH
2378: LD_INT 1
2380: PPUSH
2381: CALL_OW 287
2385: PUSH
2386: LD_INT 20
2388: LESS
2389: AND
2390: IFFALSE 2432
2392: GO 2394
2394: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2395: LD_INT 1750
2397: PPUSH
2398: LD_INT 4900
2400: PPUSH
2401: CALL_OW 12
2405: PPUSH
2406: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2410: LD_INT 2
2412: PPUSH
2413: LD_INT 5
2415: PPUSH
2416: CALL_OW 12
2420: PPUSH
2421: LD_INT 12
2423: PPUSH
2424: LD_INT 1
2426: PPUSH
2427: CALL_OW 55
// enable ;
2431: ENABLE
// end ;
2432: END
// every 0 0$1 trigger FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) do var un , x , y ;
2433: LD_INT 17
2435: PPUSH
2436: LD_INT 81
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PPUSH
2446: CALL_OW 70
2450: IFFALSE 2576
2452: GO 2454
2454: DISABLE
2455: LD_INT 0
2457: PPUSH
2458: PPUSH
2459: PPUSH
// begin un := FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) [ 1 ] ;
2460: LD_ADDR_VAR 0 1
2464: PUSH
2465: LD_INT 17
2467: PPUSH
2468: LD_INT 81
2470: PUSH
2471: LD_INT 1
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: PPUSH
2478: CALL_OW 70
2482: PUSH
2483: LD_INT 1
2485: ARRAY
2486: ST_TO_ADDR
// x := GetX ( un ) ;
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: LD_VAR 0 1
2496: PPUSH
2497: CALL_OW 250
2501: ST_TO_ADDR
// y := GetY ( un ) ;
2502: LD_ADDR_VAR 0 3
2506: PUSH
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 251
2516: ST_TO_ADDR
// PlaceSeeing ( x , y , 1 , - 12 ) ;
2517: LD_VAR 0 2
2521: PPUSH
2522: LD_VAR 0 3
2526: PPUSH
2527: LD_INT 1
2529: PPUSH
2530: LD_INT 12
2532: NEG
2533: PPUSH
2534: CALL_OW 330
// CenterNowOnUnits ( un ) ;
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 87
// Say ( Brighton , DBrighton-E1 ) ;
2547: LD_EXP 9
2551: PPUSH
2552: LD_STRING DBrighton-E1
2554: PPUSH
2555: CALL_OW 88
// RemoveSeeing ( x , y , 1 ) ;
2559: LD_VAR 0 2
2563: PPUSH
2564: LD_VAR 0 3
2568: PPUSH
2569: LD_INT 1
2571: PPUSH
2572: CALL_OW 331
// end ;
2576: PPOPN 3
2578: END
// every 0 0$1 trigger MissionStart do
2579: LD_EXP 1
2583: IFFALSE 2606
2585: GO 2587
2587: DISABLE
// begin enable ;
2588: ENABLE
// display_Strings := [ #tick , tick ] ;
2589: LD_ADDR_OWVAR 47
2593: PUSH
2594: LD_STRING #tick
2596: PUSH
2597: LD_OWVAR 1
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: ST_TO_ADDR
// end ; end_of_file
2606: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2607: LD_INT 0
2609: PPUSH
// uc_side := 1 ;
2610: LD_ADDR_OWVAR 20
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// hc_class = class_soldier ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 1
2625: ST_TO_ADDR
// uc_nation := nation_american ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_sex = sex_male ;
2634: LD_ADDR_OWVAR 27
2638: PUSH
2639: LD_INT 1
2641: ST_TO_ADDR
// hc_importance = 110 ;
2642: LD_ADDR_OWVAR 32
2646: PUSH
2647: LD_INT 110
2649: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2650: LD_ADDR_OWVAR 30
2654: PUSH
2655: LD_INT 5
2657: PUSH
2658: LD_INT 4
2660: PUSH
2661: LD_INT 5
2663: PUSH
2664: LD_INT 3
2666: PUSH
2667: EMPTY
2668: LIST
2669: LIST
2670: LIST
2671: LIST
2672: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2673: LD_ADDR_OWVAR 31
2677: PUSH
2678: LD_INT 9
2680: PUSH
2681: LD_INT 6
2683: PUSH
2684: LD_INT 7
2686: PUSH
2687: LD_INT 6
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: LIST
2695: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2696: LD_ADDR_OWVAR 29
2700: PUSH
2701: LD_INT 12
2703: PUSH
2704: LD_INT 10
2706: PUSH
2707: EMPTY
2708: LIST
2709: LIST
2710: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING Gerard Brighton
2718: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2719: LD_ADDR_OWVAR 33
2723: PUSH
2724: LD_STRING Beta_Skirmish
2726: ST_TO_ADDR
// hc_face_number := 1 ;
2727: LD_ADDR_OWVAR 34
2731: PUSH
2732: LD_INT 1
2734: ST_TO_ADDR
// Brighton := CreateHuman ;
2735: LD_ADDR_EXP 9
2739: PUSH
2740: CALL_OW 44
2744: ST_TO_ADDR
// uc_nation := nation_american ;
2745: LD_ADDR_OWVAR 21
2749: PUSH
2750: LD_INT 1
2752: ST_TO_ADDR
// hc_importance = 80 ;
2753: LD_ADDR_OWVAR 32
2757: PUSH
2758: LD_INT 80
2760: ST_TO_ADDR
// hc_sex = sex_male ;
2761: LD_ADDR_OWVAR 27
2765: PUSH
2766: LD_INT 1
2768: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2769: LD_ADDR_OWVAR 30
2773: PUSH
2774: LD_INT 5
2776: PUSH
2777: LD_INT 5
2779: PUSH
2780: LD_INT 3
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: LIST
2790: LIST
2791: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2792: LD_ADDR_OWVAR 31
2796: PUSH
2797: LD_INT 7
2799: PUSH
2800: LD_INT 6
2802: PUSH
2803: LD_INT 5
2805: PUSH
2806: LD_INT 3
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2815: LD_ADDR_OWVAR 29
2819: PUSH
2820: LD_INT 10
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: ST_TO_ADDR
// hc_name := Brian Palmer ;
2830: LD_ADDR_OWVAR 26
2834: PUSH
2835: LD_STRING Brian Palmer
2837: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2838: LD_ADDR_OWVAR 33
2842: PUSH
2843: LD_STRING Beta_Skirmish
2845: ST_TO_ADDR
// hc_face_number := 3 ;
2846: LD_ADDR_OWVAR 34
2850: PUSH
2851: LD_INT 3
2853: ST_TO_ADDR
// Palmer := CreateHuman ;
2854: LD_ADDR_EXP 10
2858: PUSH
2859: CALL_OW 44
2863: ST_TO_ADDR
// hc_class = class_scientistic ;
2864: LD_ADDR_OWVAR 28
2868: PUSH
2869: LD_INT 4
2871: ST_TO_ADDR
// uc_nation := nation_american ;
2872: LD_ADDR_OWVAR 21
2876: PUSH
2877: LD_INT 1
2879: ST_TO_ADDR
// hc_importance = 70 ;
2880: LD_ADDR_OWVAR 32
2884: PUSH
2885: LD_INT 70
2887: ST_TO_ADDR
// hc_sex = sex_female ;
2888: LD_ADDR_OWVAR 27
2892: PUSH
2893: LD_INT 2
2895: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2896: LD_ADDR_OWVAR 30
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 2
2906: PUSH
2907: LD_INT 4
2909: PUSH
2910: LD_INT 6
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: LIST
2917: LIST
2918: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2919: LD_ADDR_OWVAR 31
2923: PUSH
2924: LD_INT 4
2926: PUSH
2927: LD_INT 2
2929: PUSH
2930: LD_INT 5
2932: PUSH
2933: LD_INT 8
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2942: LD_ADDR_OWVAR 29
2946: PUSH
2947: LD_INT 10
2949: PUSH
2950: LD_INT 10
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: ST_TO_ADDR
// hc_name := Megan Armitage ;
2957: LD_ADDR_OWVAR 26
2961: PUSH
2962: LD_STRING Megan Armitage
2964: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2965: LD_ADDR_OWVAR 33
2969: PUSH
2970: LD_STRING Beta_Skirmish
2972: ST_TO_ADDR
// hc_face_number := 4 ;
2973: LD_ADDR_OWVAR 34
2977: PUSH
2978: LD_INT 4
2980: ST_TO_ADDR
// Megan := CreateHuman ;
2981: LD_ADDR_EXP 11
2985: PUSH
2986: CALL_OW 44
2990: ST_TO_ADDR
// end ;
2991: LD_VAR 0 1
2995: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
2996: LD_INT 0
2998: PPUSH
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
// uc_side := 1 ;
3003: LD_ADDR_OWVAR 20
3007: PUSH
3008: LD_INT 1
3010: ST_TO_ADDR
// uc_nation := nation_american ;
3011: LD_ADDR_OWVAR 21
3015: PUSH
3016: LD_INT 1
3018: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
3019: LD_ADDR_VAR 0 2
3023: PUSH
3024: LD_INT 22
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 30
3036: PUSH
3037: LD_INT 32
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PPUSH
3048: CALL_OW 69
3052: PUSH
3053: FOR_IN
3054: IFFALSE 3109
// PlaceWeaponTurret ( i , [ us_light_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
3056: LD_VAR 0 2
3060: PPUSH
3061: LD_INT 3
3063: PUSH
3064: LD_INT 3
3066: PUSH
3067: LD_INT 4
3069: PUSH
3070: LD_INT 5
3072: PUSH
3073: LD_INT 11
3075: PUSH
3076: LD_INT 3
3078: PUSH
3079: LD_INT 4
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 1
3093: PPUSH
3094: LD_INT 7
3096: PPUSH
3097: CALL_OW 12
3101: ARRAY
3102: PPUSH
3103: CALL_OW 431
3107: GO 3053
3109: POP
3110: POP
// hc_name :=  ;
3111: LD_ADDR_OWVAR 26
3115: PUSH
3116: LD_STRING 
3118: ST_TO_ADDR
// hc_gallery :=  ;
3119: LD_ADDR_OWVAR 33
3123: PUSH
3124: LD_STRING 
3126: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
3127: LD_ADDR_VAR 0 2
3131: PUSH
3132: DOUBLE
3133: LD_INT 1
3135: DEC
3136: ST_TO_ADDR
3137: LD_INT 6
3139: PUSH
3140: LD_INT 5
3142: PUSH
3143: LD_INT 5
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_OWVAR 67
3155: ARRAY
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3216
// begin PrepareSoldier ( 1 , game_skill ) ;
3160: LD_INT 1
3162: PPUSH
3163: LD_EXP 39
3167: PPUSH
3168: CALL_OW 381
// un := CreateHuman ;
3172: LD_ADDR_VAR 0 4
3176: PUSH
3177: CALL_OW 44
3181: ST_TO_ADDR
// filter := filter ^ un ;
3182: LD_ADDR_VAR 0 3
3186: PUSH
3187: LD_VAR 0 3
3191: PUSH
3192: LD_VAR 0 4
3196: ADD
3197: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3198: LD_ADDR_VAR 0 5
3202: PUSH
3203: LD_VAR 0 5
3207: PUSH
3208: LD_VAR 0 4
3212: ADD
3213: ST_TO_ADDR
// end ;
3214: GO 3157
3216: POP
3217: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
3218: LD_ADDR_VAR 0 2
3222: PUSH
3223: DOUBLE
3224: LD_INT 1
3226: DEC
3227: ST_TO_ADDR
3228: LD_INT 3
3230: PUSH
3231: LD_INT 2
3233: PUSH
3234: LD_INT 2
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PUSH
3242: LD_OWVAR 67
3246: ARRAY
3247: PUSH
3248: FOR_TO
3249: IFFALSE 3303
// begin PrepareEngineer ( 0 , game_skill ) ;
3251: LD_INT 0
3253: PPUSH
3254: LD_EXP 39
3258: PPUSH
3259: CALL_OW 382
// un := CreateHuman ;
3263: LD_ADDR_VAR 0 4
3267: PUSH
3268: CALL_OW 44
3272: ST_TO_ADDR
// filter := filter ^ un ;
3273: LD_ADDR_VAR 0 3
3277: PUSH
3278: LD_VAR 0 3
3282: PUSH
3283: LD_VAR 0 4
3287: ADD
3288: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3289: LD_VAR 0 4
3293: PPUSH
3294: LD_INT 3
3296: PPUSH
3297: CALL_OW 52
// end ;
3301: GO 3248
3303: POP
3304: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3305: LD_ADDR_VAR 0 2
3309: PUSH
3310: DOUBLE
3311: LD_INT 1
3313: DEC
3314: ST_TO_ADDR
3315: LD_INT 4
3317: PUSH
3318: LD_INT 3
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: PUSH
3335: FOR_TO
3336: IFFALSE 3390
// begin PrepareMechanic ( 0 , game_skill ) ;
3338: LD_INT 0
3340: PPUSH
3341: LD_EXP 39
3345: PPUSH
3346: CALL_OW 383
// un := CreateHuman ;
3350: LD_ADDR_VAR 0 4
3354: PUSH
3355: CALL_OW 44
3359: ST_TO_ADDR
// filter := filter ^ un ;
3360: LD_ADDR_VAR 0 3
3364: PUSH
3365: LD_VAR 0 3
3369: PUSH
3370: LD_VAR 0 4
3374: ADD
3375: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3376: LD_VAR 0 4
3380: PPUSH
3381: LD_INT 8
3383: PPUSH
3384: CALL_OW 52
// end ;
3388: GO 3335
3390: POP
3391: POP
// for i = 1 to 2 do
3392: LD_ADDR_VAR 0 2
3396: PUSH
3397: DOUBLE
3398: LD_INT 1
3400: DEC
3401: ST_TO_ADDR
3402: LD_INT 2
3404: PUSH
3405: FOR_TO
3406: IFFALSE 3460
// begin PrepareScientist ( 0 , game_skill ) ;
3408: LD_INT 0
3410: PPUSH
3411: LD_EXP 39
3415: PPUSH
3416: CALL_OW 384
// un := CreateHuman ;
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: CALL_OW 44
3429: ST_TO_ADDR
// filter := filter ^ un ;
3430: LD_ADDR_VAR 0 3
3434: PUSH
3435: LD_VAR 0 3
3439: PUSH
3440: LD_VAR 0 4
3444: ADD
3445: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_INT 14
3453: PPUSH
3454: CALL_OW 52
// end ;
3458: GO 3405
3460: POP
3461: POP
// for i = 1 to soldiers do
3462: LD_ADDR_VAR 0 2
3466: PUSH
3467: DOUBLE
3468: LD_INT 1
3470: DEC
3471: ST_TO_ADDR
3472: LD_VAR 0 5
3476: PUSH
3477: FOR_TO
3478: IFFALSE 3503
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3480: LD_VAR 0 5
3484: PUSH
3485: LD_VAR 0 2
3489: ARRAY
3490: PPUSH
3491: LD_INT 1
3493: PPUSH
3494: LD_INT 0
3496: PPUSH
3497: CALL_OW 49
3501: GO 3477
3503: POP
3504: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3505: LD_EXP 9
3509: PPUSH
3510: LD_INT 51
3512: PPUSH
3513: LD_INT 43
3515: PPUSH
3516: LD_INT 0
3518: PPUSH
3519: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3523: LD_EXP 10
3527: PPUSH
3528: LD_INT 55
3530: PPUSH
3531: LD_INT 58
3533: PPUSH
3534: LD_INT 0
3536: PPUSH
3537: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3541: LD_EXP 11
3545: PPUSH
3546: LD_INT 39
3548: PPUSH
3549: LD_INT 36
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// BetaSquad := filter diff 0 ;
3559: LD_ADDR_EXP 12
3563: PUSH
3564: LD_VAR 0 3
3568: PUSH
3569: LD_INT 0
3571: DIFF
3572: ST_TO_ADDR
// end ;
3573: LD_VAR 0 1
3577: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3578: LD_INT 0
3580: PPUSH
3581: PPUSH
3582: PPUSH
3583: PPUSH
3584: PPUSH
3585: PPUSH
// uc_side := 6 ;
3586: LD_ADDR_OWVAR 20
3590: PUSH
3591: LD_INT 6
3593: ST_TO_ADDR
// uc_nation := nation_russian ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// soldiers := [ ] ;
3602: LD_ADDR_VAR 0 4
3606: PUSH
3607: EMPTY
3608: ST_TO_ADDR
// vehs := [ ] ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: EMPTY
3615: ST_TO_ADDR
// RUArmada := [ ] ;
3616: LD_ADDR_EXP 17
3620: PUSH
3621: EMPTY
3622: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3623: LD_ADDR_EXP 13
3627: PUSH
3628: LD_STRING Yashin
3630: PPUSH
3631: CALL_OW 25
3635: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3636: LD_ADDR_EXP 14
3640: PUSH
3641: LD_STRING Popov
3643: PPUSH
3644: CALL_OW 25
3648: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3649: LD_ADDR_EXP 15
3653: PUSH
3654: LD_STRING Gaydar
3656: PPUSH
3657: CALL_OW 25
3661: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3662: LD_ADDR_EXP 16
3666: PUSH
3667: LD_STRING Vsevolod
3669: PPUSH
3670: CALL_OW 25
3674: ST_TO_ADDR
// for i = 1 to 16 do
3675: LD_ADDR_VAR 0 2
3679: PUSH
3680: DOUBLE
3681: LD_INT 1
3683: DEC
3684: ST_TO_ADDR
3685: LD_INT 16
3687: PUSH
3688: FOR_TO
3689: IFFALSE 3731
// begin PrepareSoldier ( 0 , game_eskill ) ;
3691: LD_INT 0
3693: PPUSH
3694: LD_EXP 40
3698: PPUSH
3699: CALL_OW 381
// un := CreateHuman ;
3703: LD_ADDR_VAR 0 5
3707: PUSH
3708: CALL_OW 44
3712: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3713: LD_ADDR_VAR 0 4
3717: PUSH
3718: LD_VAR 0 4
3722: PUSH
3723: LD_VAR 0 5
3727: ADD
3728: ST_TO_ADDR
// end ;
3729: GO 3688
3731: POP
3732: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: LD_EXP 13
3742: PUSH
3743: LD_EXP 14
3747: ADD
3748: PUSH
3749: LD_EXP 15
3753: ADD
3754: PUSH
3755: LD_EXP 16
3759: ADD
3760: PUSH
3761: LD_VAR 0 4
3765: ADD
3766: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3767: LD_INT 24
3769: PPUSH
3770: LD_INT 3
3772: PPUSH
3773: LD_INT 1
3775: PPUSH
3776: LD_INT 46
3778: PPUSH
3779: LD_INT 100
3781: PPUSH
3782: CALL 18426 0 5
// for i = 1 to 8 do
3786: LD_ADDR_VAR 0 2
3790: PUSH
3791: DOUBLE
3792: LD_INT 1
3794: DEC
3795: ST_TO_ADDR
3796: LD_INT 8
3798: PUSH
3799: FOR_TO
3800: IFFALSE 3883
// begin vehicle := CreateVehicle ;
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: CALL_OW 45
3811: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3812: LD_VAR 0 4
3816: PUSH
3817: LD_INT 1
3819: ARRAY
3820: PPUSH
3821: LD_VAR 0 3
3825: PPUSH
3826: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3830: LD_ADDR_VAR 0 4
3834: PUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_VAR 0 4
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: DIFF
3849: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3850: LD_VAR 0 3
3854: PPUSH
3855: LD_INT 5
3857: PPUSH
3858: LD_INT 0
3860: PPUSH
3861: CALL_OW 49
// vehs := vehs ^ vehicle ;
3865: LD_ADDR_VAR 0 6
3869: PUSH
3870: LD_VAR 0 6
3874: PUSH
3875: LD_VAR 0 3
3879: ADD
3880: ST_TO_ADDR
// end ;
3881: GO 3799
3883: POP
3884: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3885: LD_INT 24
3887: PPUSH
3888: LD_INT 3
3890: PPUSH
3891: LD_INT 1
3893: PPUSH
3894: LD_INT 43
3896: PPUSH
3897: LD_INT 100
3899: PPUSH
3900: CALL 18426 0 5
// for i = 1 to 8 do
3904: LD_ADDR_VAR 0 2
3908: PUSH
3909: DOUBLE
3910: LD_INT 1
3912: DEC
3913: ST_TO_ADDR
3914: LD_INT 8
3916: PUSH
3917: FOR_TO
3918: IFFALSE 4001
// begin vehicle := CreateVehicle ;
3920: LD_ADDR_VAR 0 3
3924: PUSH
3925: CALL_OW 45
3929: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3930: LD_VAR 0 4
3934: PUSH
3935: LD_INT 1
3937: ARRAY
3938: PPUSH
3939: LD_VAR 0 3
3943: PPUSH
3944: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3948: LD_ADDR_VAR 0 4
3952: PUSH
3953: LD_VAR 0 4
3957: PUSH
3958: LD_VAR 0 4
3962: PUSH
3963: LD_INT 1
3965: ARRAY
3966: DIFF
3967: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3968: LD_VAR 0 3
3972: PPUSH
3973: LD_INT 5
3975: PPUSH
3976: LD_INT 0
3978: PPUSH
3979: CALL_OW 49
// vehs := vehs ^ vehicle ;
3983: LD_ADDR_VAR 0 6
3987: PUSH
3988: LD_VAR 0 6
3992: PUSH
3993: LD_VAR 0 3
3997: ADD
3998: ST_TO_ADDR
// end ;
3999: GO 3917
4001: POP
4002: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
4003: LD_INT 22
4005: PPUSH
4006: LD_INT 3
4008: PPUSH
4009: LD_INT 1
4011: PPUSH
4012: LD_INT 44
4014: PPUSH
4015: LD_INT 100
4017: PPUSH
4018: CALL 18426 0 5
// for i = 1 to 4 do
4022: LD_ADDR_VAR 0 2
4026: PUSH
4027: DOUBLE
4028: LD_INT 1
4030: DEC
4031: ST_TO_ADDR
4032: LD_INT 4
4034: PUSH
4035: FOR_TO
4036: IFFALSE 4119
// begin vehicle := CreateVehicle ;
4038: LD_ADDR_VAR 0 3
4042: PUSH
4043: CALL_OW 45
4047: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4048: LD_VAR 0 4
4052: PUSH
4053: LD_INT 1
4055: ARRAY
4056: PPUSH
4057: LD_VAR 0 3
4061: PPUSH
4062: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4066: LD_ADDR_VAR 0 4
4070: PUSH
4071: LD_VAR 0 4
4075: PUSH
4076: LD_VAR 0 4
4080: PUSH
4081: LD_INT 1
4083: ARRAY
4084: DIFF
4085: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_INT 5
4093: PPUSH
4094: LD_INT 0
4096: PPUSH
4097: CALL_OW 49
// vehs := vehs ^ vehicle ;
4101: LD_ADDR_VAR 0 6
4105: PUSH
4106: LD_VAR 0 6
4110: PUSH
4111: LD_VAR 0 3
4115: ADD
4116: ST_TO_ADDR
// end ;
4117: GO 4035
4119: POP
4120: POP
// RUArmada := vehs ;
4121: LD_ADDR_EXP 17
4125: PUSH
4126: LD_VAR 0 6
4130: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
4131: LD_EXP 13
4135: PPUSH
4136: CALL_OW 310
4140: PUSH
4141: LD_EXP 14
4145: PPUSH
4146: CALL_OW 310
4150: PUSH
4151: LD_EXP 15
4155: PPUSH
4156: CALL_OW 310
4160: PUSH
4161: LD_EXP 16
4165: PPUSH
4166: CALL_OW 310
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: LIST
4176: PPUSH
4177: LD_INT 6
4179: NEG
4180: PPUSH
4181: CALL_OW 242
// end ;
4185: LD_VAR 0 1
4189: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
4190: LD_INT 0
4192: PPUSH
4193: PPUSH
4194: PPUSH
// uc_side := 6 ;
4195: LD_ADDR_OWVAR 20
4199: PUSH
4200: LD_INT 6
4202: ST_TO_ADDR
// uc_nation := nation_russian ;
4203: LD_ADDR_OWVAR 21
4207: PUSH
4208: LD_INT 3
4210: ST_TO_ADDR
// Bulldozers := [ ] ;
4211: LD_ADDR_EXP 18
4215: PUSH
4216: EMPTY
4217: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
4218: LD_INT 24
4220: PPUSH
4221: LD_INT 3
4223: PPUSH
4224: LD_INT 3
4226: PPUSH
4227: LD_INT 53
4229: PPUSH
4230: LD_INT 100
4232: PPUSH
4233: CALL 18426 0 5
// for i = 1 to 2 do
4237: LD_ADDR_VAR 0 2
4241: PUSH
4242: DOUBLE
4243: LD_INT 1
4245: DEC
4246: ST_TO_ADDR
4247: LD_INT 2
4249: PUSH
4250: FOR_TO
4251: IFFALSE 4296
// begin vehicle := CreateVehicle ;
4253: LD_ADDR_VAR 0 3
4257: PUSH
4258: CALL_OW 45
4262: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4263: LD_VAR 0 3
4267: PPUSH
4268: LD_INT 5
4270: PPUSH
4271: LD_INT 0
4273: PPUSH
4274: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4278: LD_ADDR_EXP 18
4282: PUSH
4283: LD_EXP 18
4287: PUSH
4288: LD_VAR 0 3
4292: ADD
4293: ST_TO_ADDR
// end ;
4294: GO 4250
4296: POP
4297: POP
// end ;
4298: LD_VAR 0 1
4302: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4303: LD_INT 0
4305: PPUSH
4306: PPUSH
4307: PPUSH
4308: PPUSH
// uc_side := 3 ;
4309: LD_ADDR_OWVAR 20
4313: PUSH
4314: LD_INT 3
4316: ST_TO_ADDR
// uc_nation := nation_russian ;
4317: LD_ADDR_OWVAR 21
4321: PUSH
4322: LD_INT 3
4324: ST_TO_ADDR
// hc_name :=  ;
4325: LD_ADDR_OWVAR 26
4329: PUSH
4330: LD_STRING 
4332: ST_TO_ADDR
// hc_gallery :=  ;
4333: LD_ADDR_OWVAR 33
4337: PUSH
4338: LD_STRING 
4340: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4341: LD_ADDR_EXP 19
4345: PUSH
4346: LD_STRING Burlak
4348: PPUSH
4349: CALL_OW 25
4353: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4354: LD_ADDR_EXP 20
4358: PUSH
4359: LD_STRING Gleb
4361: PPUSH
4362: CALL_OW 25
4366: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4367: LD_ADDR_EXP 21
4371: PUSH
4372: LD_STRING Furmanov
4374: PPUSH
4375: CALL_OW 25
4379: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4380: LD_ADDR_EXP 22
4384: PUSH
4385: LD_STRING Titov
4387: PPUSH
4388: CALL_OW 25
4392: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4393: LD_ADDR_EXP 23
4397: PUSH
4398: LD_STRING Scholtze
4400: PPUSH
4401: CALL_OW 25
4405: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4406: LD_ADDR_EXP 24
4410: PUSH
4411: LD_STRING Dolgov
4413: PPUSH
4414: CALL_OW 25
4418: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4419: LD_ADDR_EXP 25
4423: PUSH
4424: LD_STRING Kapitsova
4426: PPUSH
4427: CALL_OW 25
4431: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4432: LD_ADDR_EXP 26
4436: PUSH
4437: LD_STRING Karamazov
4439: PPUSH
4440: CALL_OW 25
4444: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4445: LD_ADDR_EXP 27
4449: PUSH
4450: LD_STRING Kirlenkova
4452: PPUSH
4453: CALL_OW 25
4457: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4458: LD_ADDR_EXP 28
4462: PUSH
4463: LD_STRING Kovalyuk
4465: PPUSH
4466: CALL_OW 25
4470: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4471: LD_ADDR_EXP 29
4475: PUSH
4476: LD_STRING Kozlov
4478: PPUSH
4479: CALL_OW 25
4483: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4484: LD_ADDR_EXP 30
4488: PUSH
4489: LD_STRING Kuzmov
4491: PPUSH
4492: CALL_OW 25
4496: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4497: LD_ADDR_EXP 31
4501: PUSH
4502: LD_STRING Lipshchin
4504: PPUSH
4505: CALL_OW 25
4509: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4510: LD_ADDR_EXP 32
4514: PUSH
4515: LD_STRING Oblukov
4517: PPUSH
4518: CALL_OW 25
4522: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4523: LD_ADDR_EXP 33
4527: PUSH
4528: LD_STRING Xavier2
4530: PPUSH
4531: CALL_OW 25
4535: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4536: LD_ADDR_EXP 34
4540: PUSH
4541: LD_STRING Gnyevko
4543: PPUSH
4544: CALL_OW 25
4548: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4549: LD_ADDR_EXP 35
4553: PUSH
4554: LD_STRING Belkov
4556: PPUSH
4557: CALL_OW 25
4561: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4562: LD_ADDR_VAR 0 3
4566: PUSH
4567: LD_EXP 19
4571: PUSH
4572: LD_EXP 20
4576: PUSH
4577: LD_EXP 21
4581: PUSH
4582: LD_EXP 22
4586: PUSH
4587: LD_EXP 23
4591: PUSH
4592: LD_EXP 24
4596: PUSH
4597: LD_EXP 25
4601: PUSH
4602: LD_EXP 26
4606: PUSH
4607: LD_EXP 27
4611: PUSH
4612: LD_EXP 28
4616: PUSH
4617: LD_EXP 29
4621: PUSH
4622: LD_EXP 30
4626: PUSH
4627: LD_EXP 31
4631: PUSH
4632: LD_EXP 32
4636: PUSH
4637: LD_EXP 33
4641: PUSH
4642: LD_EXP 34
4646: PUSH
4647: LD_EXP 35
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ST_TO_ADDR
// for i = 1 to filter do
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: DOUBLE
4677: LD_INT 1
4679: DEC
4680: ST_TO_ADDR
4681: LD_VAR 0 3
4685: PUSH
4686: FOR_TO
4687: IFFALSE 4712
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4689: LD_VAR 0 3
4693: PUSH
4694: LD_VAR 0 2
4698: ARRAY
4699: PPUSH
4700: LD_INT 6
4702: PPUSH
4703: LD_INT 0
4705: PPUSH
4706: CALL_OW 49
4710: GO 4686
4712: POP
4713: POP
// end ;
4714: LD_VAR 0 1
4718: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4719: LD_INT 0
4721: PPUSH
4722: PPUSH
4723: PPUSH
4724: PPUSH
// uc_side := 3 ;
4725: LD_ADDR_OWVAR 20
4729: PUSH
4730: LD_INT 3
4732: ST_TO_ADDR
// uc_nation := nation_russian ;
4733: LD_ADDR_OWVAR 21
4737: PUSH
4738: LD_INT 3
4740: ST_TO_ADDR
// hc_name :=  ;
4741: LD_ADDR_OWVAR 26
4745: PUSH
4746: LD_STRING 
4748: ST_TO_ADDR
// hc_gallery :=  ;
4749: LD_ADDR_OWVAR 33
4753: PUSH
4754: LD_STRING 
4756: ST_TO_ADDR
// for i = 1 to 8 do
4757: LD_ADDR_VAR 0 2
4761: PUSH
4762: DOUBLE
4763: LD_INT 1
4765: DEC
4766: ST_TO_ADDR
4767: LD_INT 8
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4813
// begin PrepareSoldier ( 0 , game_eskill ) ;
4773: LD_INT 0
4775: PPUSH
4776: LD_EXP 40
4780: PPUSH
4781: CALL_OW 381
// un := CreateHuman ;
4785: LD_ADDR_VAR 0 4
4789: PUSH
4790: CALL_OW 44
4794: ST_TO_ADDR
// filter := filter ^ un ;
4795: LD_ADDR_VAR 0 3
4799: PUSH
4800: LD_VAR 0 3
4804: PUSH
4805: LD_VAR 0 4
4809: ADD
4810: ST_TO_ADDR
// end ;
4811: GO 4770
4813: POP
4814: POP
// for i = 1 to 4 do
4815: LD_ADDR_VAR 0 2
4819: PUSH
4820: DOUBLE
4821: LD_INT 1
4823: DEC
4824: ST_TO_ADDR
4825: LD_INT 4
4827: PUSH
4828: FOR_TO
4829: IFFALSE 4871
// begin PrepareEngineer ( 0 , game_eskill ) ;
4831: LD_INT 0
4833: PPUSH
4834: LD_EXP 40
4838: PPUSH
4839: CALL_OW 382
// un := CreateHuman ;
4843: LD_ADDR_VAR 0 4
4847: PUSH
4848: CALL_OW 44
4852: ST_TO_ADDR
// filter := filter ^ un ;
4853: LD_ADDR_VAR 0 3
4857: PUSH
4858: LD_VAR 0 3
4862: PUSH
4863: LD_VAR 0 4
4867: ADD
4868: ST_TO_ADDR
// end ;
4869: GO 4828
4871: POP
4872: POP
// for i = 1 to 6 do
4873: LD_ADDR_VAR 0 2
4877: PUSH
4878: DOUBLE
4879: LD_INT 1
4881: DEC
4882: ST_TO_ADDR
4883: LD_INT 6
4885: PUSH
4886: FOR_TO
4887: IFFALSE 4929
// begin PrepareMechanic ( 0 , game_eskill ) ;
4889: LD_INT 0
4891: PPUSH
4892: LD_EXP 40
4896: PPUSH
4897: CALL_OW 383
// un := CreateHuman ;
4901: LD_ADDR_VAR 0 4
4905: PUSH
4906: CALL_OW 44
4910: ST_TO_ADDR
// filter := filter ^ un ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_VAR 0 3
4920: PUSH
4921: LD_VAR 0 4
4925: ADD
4926: ST_TO_ADDR
// end ;
4927: GO 4886
4929: POP
4930: POP
// for i = 1 to 4 do
4931: LD_ADDR_VAR 0 2
4935: PUSH
4936: DOUBLE
4937: LD_INT 1
4939: DEC
4940: ST_TO_ADDR
4941: LD_INT 4
4943: PUSH
4944: FOR_TO
4945: IFFALSE 4987
// begin PrepareScientist ( 0 , game_eskill ) ;
4947: LD_INT 0
4949: PPUSH
4950: LD_EXP 40
4954: PPUSH
4955: CALL_OW 384
// un := CreateHuman ;
4959: LD_ADDR_VAR 0 4
4963: PUSH
4964: CALL_OW 44
4968: ST_TO_ADDR
// filter := filter ^ un ;
4969: LD_ADDR_VAR 0 3
4973: PUSH
4974: LD_VAR 0 3
4978: PUSH
4979: LD_VAR 0 4
4983: ADD
4984: ST_TO_ADDR
// end ;
4985: GO 4944
4987: POP
4988: POP
// for i = 1 to filter do
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: DOUBLE
4995: LD_INT 1
4997: DEC
4998: ST_TO_ADDR
4999: LD_VAR 0 3
5003: PUSH
5004: FOR_TO
5005: IFFALSE 5030
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
5007: LD_VAR 0 3
5011: PUSH
5012: LD_VAR 0 2
5016: ARRAY
5017: PPUSH
5018: LD_INT 6
5020: PPUSH
5021: LD_INT 0
5023: PPUSH
5024: CALL_OW 49
5028: GO 5004
5030: POP
5031: POP
// RU_SecondPersonnel := filter ;
5032: LD_ADDR_EXP 36
5036: PUSH
5037: LD_VAR 0 3
5041: ST_TO_ADDR
// end ;
5042: LD_VAR 0 1
5046: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
5047: LD_INT 0
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
5055: PPUSH
// uc_side := 1 ;
5056: LD_ADDR_OWVAR 20
5060: PUSH
5061: LD_INT 1
5063: ST_TO_ADDR
// uc_nation := nation_american ;
5064: LD_ADDR_OWVAR 21
5068: PUSH
5069: LD_INT 1
5071: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
5072: LD_ADDR_EXP 37
5076: PUSH
5077: LD_STRING JMM
5079: PPUSH
5080: CALL_OW 25
5084: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
5085: LD_EXP 37
5089: PPUSH
5090: LD_INT 1
5092: PPUSH
5093: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
5097: LD_EXP 37
5101: PPUSH
5102: LD_INT 7
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 49
// mechs := [ ] ;
5112: LD_ADDR_VAR 0 7
5116: PUSH
5117: EMPTY
5118: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
5119: LD_ADDR_VAR 0 2
5123: PUSH
5124: DOUBLE
5125: LD_INT 1
5127: DEC
5128: ST_TO_ADDR
5129: LD_INT 4
5131: PUSH
5132: LD_INT 3
5134: PUSH
5135: LD_INT 3
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: LIST
5142: PUSH
5143: LD_OWVAR 67
5147: ARRAY
5148: PUSH
5149: FOR_TO
5150: IFFALSE 5211
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_EXP 39
5159: PUSH
5160: LD_INT 1
5162: PLUS
5163: PPUSH
5164: CALL_OW 381
// un := CreateHuman ;
5168: LD_ADDR_VAR 0 4
5172: PUSH
5173: CALL_OW 44
5177: ST_TO_ADDR
// soldiers := soldiers ^ un ;
5178: LD_ADDR_VAR 0 3
5182: PUSH
5183: LD_VAR 0 3
5187: PUSH
5188: LD_VAR 0 4
5192: ADD
5193: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
5194: LD_VAR 0 4
5198: PPUSH
5199: LD_INT 7
5201: PPUSH
5202: LD_INT 0
5204: PPUSH
5205: CALL_OW 49
// end ;
5209: GO 5149
5211: POP
5212: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5213: LD_ADDR_VAR 0 2
5217: PUSH
5218: DOUBLE
5219: LD_INT 1
5221: DEC
5222: ST_TO_ADDR
5223: LD_INT 7
5225: PUSH
5226: LD_INT 6
5228: PUSH
5229: LD_INT 4
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: LIST
5236: PUSH
5237: LD_OWVAR 67
5241: ARRAY
5242: PUSH
5243: FOR_TO
5244: IFFALSE 5290
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5246: LD_INT 0
5248: PPUSH
5249: LD_EXP 39
5253: PUSH
5254: LD_INT 1
5256: PLUS
5257: PPUSH
5258: CALL_OW 383
// un := CreateHuman ;
5262: LD_ADDR_VAR 0 4
5266: PUSH
5267: CALL_OW 44
5271: ST_TO_ADDR
// mechs := mechs ^ un ;
5272: LD_ADDR_VAR 0 7
5276: PUSH
5277: LD_VAR 0 7
5281: PUSH
5282: LD_VAR 0 4
5286: ADD
5287: ST_TO_ADDR
// end ;
5288: GO 5243
5290: POP
5291: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5292: LD_INT 3
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 1
5300: PPUSH
5301: LD_INT 5
5303: PPUSH
5304: LD_INT 100
5306: PPUSH
5307: CALL 18426 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5311: LD_ADDR_VAR 0 2
5315: PUSH
5316: DOUBLE
5317: LD_INT 1
5319: DEC
5320: ST_TO_ADDR
5321: LD_INT 7
5323: PUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 4
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: LIST
5334: PUSH
5335: LD_OWVAR 67
5339: ARRAY
5340: PUSH
5341: FOR_TO
5342: IFFALSE 5437
// begin vehicle := CreateVehicle ;
5344: LD_ADDR_VAR 0 6
5348: PUSH
5349: CALL_OW 45
5353: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5354: LD_VAR 0 7
5358: PUSH
5359: LD_INT 1
5361: ARRAY
5362: PPUSH
5363: LD_VAR 0 6
5367: PPUSH
5368: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5372: LD_ADDR_VAR 0 7
5376: PUSH
5377: LD_VAR 0 7
5381: PUSH
5382: LD_VAR 0 7
5386: PUSH
5387: LD_INT 1
5389: ARRAY
5390: DIFF
5391: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5392: LD_VAR 0 6
5396: PPUSH
5397: LD_INT 1
5399: PPUSH
5400: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5404: LD_VAR 0 6
5408: PPUSH
5409: LD_INT 7
5411: PPUSH
5412: LD_INT 0
5414: PPUSH
5415: CALL_OW 49
// vehs := vehs ^ vehicle ;
5419: LD_ADDR_VAR 0 5
5423: PUSH
5424: LD_VAR 0 5
5428: PUSH
5429: LD_VAR 0 6
5433: ADD
5434: ST_TO_ADDR
// end ;
5435: GO 5341
5437: POP
5438: POP
// end ; end_of_file
5439: LD_VAR 0 1
5443: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export startCrates ; export function GameType ; var i , ruStartTechs ; begin
5444: LD_INT 0
5446: PPUSH
5447: PPUSH
5448: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5449: LD_ADDR_OWVAR 67
5453: PUSH
5454: LD_INT 0
5456: PPUSH
5457: CALL_OW 426
5461: ST_TO_ADDR
// game_diff := Difficulty ;
5462: LD_ADDR_EXP 38
5466: PUSH
5467: LD_OWVAR 67
5471: ST_TO_ADDR
// game_skill := [ 7 , 6 , 5 ] [ game_diff ] ;
5472: LD_ADDR_EXP 39
5476: PUSH
5477: LD_INT 7
5479: PUSH
5480: LD_INT 6
5482: PUSH
5483: LD_INT 5
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: LD_EXP 38
5495: ARRAY
5496: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5497: LD_ADDR_EXP 40
5501: PUSH
5502: LD_INT 6
5504: PUSH
5505: LD_INT 7
5507: PUSH
5508: LD_INT 8
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_EXP 38
5520: ARRAY
5521: ST_TO_ADDR
// ruArrival := [ 3 3$00 , 2 2$00 , 1 1$00 ] [ game_diff ] ;
5522: LD_ADDR_EXP 42
5526: PUSH
5527: LD_INT 6300
5529: PUSH
5530: LD_INT 4200
5532: PUSH
5533: LD_INT 2100
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: LIST
5540: PUSH
5541: LD_EXP 38
5545: ARRAY
5546: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5547: LD_ADDR_EXP 41
5551: PUSH
5552: LD_INT 73500
5554: PUSH
5555: LD_INT 94500
5557: PUSH
5558: LD_INT 115500
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: PUSH
5566: LD_EXP 38
5570: ARRAY
5571: ST_TO_ADDR
// ruStartTechs = [ [ tech_Weap1 ] , [ tech_Weap1 , tech_Comp1 ] , [ tech_Weap1 , tech_Weap2 , tech_Comp1 ] ] ;
5572: LD_ADDR_VAR 0 3
5576: PUSH
5577: LD_INT 51
5579: PUSH
5580: EMPTY
5581: LIST
5582: PUSH
5583: LD_INT 51
5585: PUSH
5586: LD_INT 57
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 51
5595: PUSH
5596: LD_INT 52
5598: PUSH
5599: LD_INT 57
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: ST_TO_ADDR
// startCrates = [ [ 300 , 350 ] , [ 230 , 200 ] , [ 150 , 100 ] ] [ game_diff ] ;
5612: LD_ADDR_EXP 43
5616: PUSH
5617: LD_INT 300
5619: PUSH
5620: LD_INT 350
5622: PUSH
5623: EMPTY
5624: LIST
5625: LIST
5626: PUSH
5627: LD_INT 230
5629: PUSH
5630: LD_INT 200
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 150
5639: PUSH
5640: LD_INT 100
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_EXP 38
5656: ARRAY
5657: ST_TO_ADDR
// for i := 1 to ruStartTechs [ game_diff ] do
5658: LD_ADDR_VAR 0 2
5662: PUSH
5663: DOUBLE
5664: LD_INT 1
5666: DEC
5667: ST_TO_ADDR
5668: LD_VAR 0 3
5672: PUSH
5673: LD_EXP 38
5677: ARRAY
5678: PUSH
5679: FOR_TO
5680: IFFALSE 5738
// begin SetTech ( ruStartTechs [ game_diff ] [ i ] , 3 , state_researched ) ;
5682: LD_VAR 0 3
5686: PUSH
5687: LD_EXP 38
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: LD_INT 3
5701: PPUSH
5702: LD_INT 2
5704: PPUSH
5705: CALL_OW 322
// SetTech ( ruStartTechs [ game_diff ] [ i ] , 6 , state_researched ) ;
5709: LD_VAR 0 3
5713: PUSH
5714: LD_EXP 38
5718: ARRAY
5719: PUSH
5720: LD_VAR 0 2
5724: ARRAY
5725: PPUSH
5726: LD_INT 6
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 322
// end ;
5736: GO 5679
5738: POP
5739: POP
// end ; end_of_file
5740: LD_VAR 0 1
5744: RET
// export function CustomEvent ( event ) ; begin
5745: LD_INT 0
5747: PPUSH
// end ;
5748: LD_VAR 0 2
5752: RET
// export function CustomInitMacro ( ) ; begin
5753: LD_INT 0
5755: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5756: LD_INT 1
5758: PPUSH
5759: LD_INT 3
5761: PPUSH
5762: CALL 76587 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5766: LD_INT 1
5768: PPUSH
5769: LD_INT 4
5771: PPUSH
5772: CALL 76531 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5776: LD_INT 1
5778: PPUSH
5779: LD_INT 136
5781: PUSH
5782: LD_INT 130
5784: PUSH
5785: LD_INT 0
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 145
5795: PUSH
5796: LD_INT 123
5798: PUSH
5799: LD_INT 0
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: CALL 75590 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5815: LD_INT 1
5817: PPUSH
5818: LD_INT 43
5820: PUSH
5821: LD_INT 46
5823: PUSH
5824: LD_INT 45
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PPUSH
5832: CALL 76419 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5836: LD_INT 1
5838: PPUSH
5839: LD_INT 3
5841: PPUSH
5842: CALL 76101 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5846: LD_INT 1
5848: PPUSH
5849: LD_INT 3
5851: PPUSH
5852: CALL 75832 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5856: LD_INT 1
5858: PPUSH
5859: LD_INT 8
5861: PPUSH
5862: CALL 75451 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5866: LD_INT 1
5868: PPUSH
5869: LD_INT 22
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: LD_INT 3
5877: PUSH
5878: LD_INT 43
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: PUSH
5887: LD_INT 22
5889: PUSH
5890: LD_INT 1
5892: PUSH
5893: LD_INT 3
5895: PUSH
5896: LD_INT 44
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 22
5907: PUSH
5908: LD_INT 1
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: LD_INT 45
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: PUSH
5923: LD_INT 24
5925: PUSH
5926: LD_INT 1
5928: PUSH
5929: LD_INT 3
5931: PUSH
5932: LD_INT 43
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_INT 24
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 3
5949: PUSH
5950: LD_INT 43
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 24
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: LD_INT 3
5967: PUSH
5968: LD_INT 46
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: PUSH
5977: LD_INT 22
5979: PUSH
5980: LD_INT 1
5982: PUSH
5983: LD_INT 3
5985: PUSH
5986: LD_INT 43
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 22
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: LD_INT 3
6003: PUSH
6004: LD_INT 44
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: LIST
6011: LIST
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PPUSH
6023: CALL 75266 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
6027: LD_INT 1
6029: PPUSH
6030: LD_INT 0
6032: PUSH
6033: LD_INT 127
6035: PUSH
6036: LD_INT 125
6038: PUSH
6039: LD_INT 5
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 6
6050: PUSH
6051: LD_INT 124
6053: PUSH
6054: LD_INT 132
6056: PUSH
6057: LD_INT 0
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 29
6068: PUSH
6069: LD_INT 136
6071: PUSH
6072: LD_INT 130
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 4
6086: PUSH
6087: LD_INT 118
6089: PUSH
6090: LD_INT 114
6092: PUSH
6093: LD_INT 2
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 29
6104: PUSH
6105: LD_INT 145
6107: PUSH
6108: LD_INT 123
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 26
6122: PUSH
6123: LD_INT 150
6125: PUSH
6126: LD_INT 135
6128: PUSH
6129: LD_INT 1
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 26
6140: PUSH
6141: LD_INT 140
6143: PUSH
6144: LD_INT 134
6146: PUSH
6147: LD_INT 2
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_INT 26
6158: PUSH
6159: LD_INT 137
6161: PUSH
6162: LD_INT 121
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 2
6176: PUSH
6177: LD_INT 155
6179: PUSH
6180: LD_INT 130
6182: PUSH
6183: LD_INT 0
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 32
6194: PUSH
6195: LD_INT 155
6197: PUSH
6198: LD_INT 130
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 32
6212: PUSH
6213: LD_INT 130
6215: PUSH
6216: LD_INT 114
6218: PUSH
6219: LD_INT 3
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 32
6230: PUSH
6231: LD_INT 142
6233: PUSH
6234: LD_INT 115
6236: PUSH
6237: LD_INT 3
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 32
6248: PUSH
6249: LD_INT 153
6251: PUSH
6252: LD_INT 120
6254: PUSH
6255: LD_INT 3
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: PPUSH
6279: CALL 75158 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
6283: LD_INT 1
6285: PPUSH
6286: LD_INT 10
6288: PUSH
6289: LD_INT 12
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: PPUSH
6296: CALL 76008 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6300: LD_INT 1
6302: PPUSH
6303: LD_INT 155
6305: PPUSH
6306: LD_INT 130
6308: PPUSH
6309: LD_INT 0
6311: PPUSH
6312: LD_INT 24
6314: PUSH
6315: LD_INT 16
6317: PUSH
6318: LD_INT 17
6320: PUSH
6321: LD_INT 18
6323: PUSH
6324: LD_INT 21
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL 76213 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
6338: LD_INT 2
6340: PPUSH
6341: LD_INT 3
6343: PPUSH
6344: CALL 76587 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 4
6353: PPUSH
6354: CALL 76531 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
6358: LD_INT 2
6360: PPUSH
6361: LD_INT 84
6363: PUSH
6364: LD_INT 125
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: EMPTY
6376: LIST
6377: PPUSH
6378: CALL 75590 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
6382: LD_INT 2
6384: PPUSH
6385: LD_INT 43
6387: PUSH
6388: LD_INT 46
6390: PUSH
6391: LD_INT 45
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: LIST
6398: PPUSH
6399: CALL 76419 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
6403: LD_INT 2
6405: PPUSH
6406: LD_INT 3
6408: PPUSH
6409: CALL 76101 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6413: LD_INT 2
6415: PPUSH
6416: LD_INT 3
6418: PPUSH
6419: CALL 75832 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6423: LD_INT 2
6425: PPUSH
6426: LD_INT 8
6428: PPUSH
6429: CALL 75451 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6433: LD_INT 2
6435: PPUSH
6436: LD_INT 22
6438: PUSH
6439: LD_INT 3
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: LD_INT 43
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 22
6456: PUSH
6457: LD_INT 3
6459: PUSH
6460: LD_INT 3
6462: PUSH
6463: LD_INT 44
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 22
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: LD_INT 3
6480: PUSH
6481: LD_INT 45
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 24
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 43
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 24
6510: PUSH
6511: LD_INT 3
6513: PUSH
6514: LD_INT 3
6516: PUSH
6517: LD_INT 43
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 24
6528: PUSH
6529: LD_INT 3
6531: PUSH
6532: LD_INT 3
6534: PUSH
6535: LD_INT 46
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 22
6546: PUSH
6547: LD_INT 3
6549: PUSH
6550: LD_INT 3
6552: PUSH
6553: LD_INT 43
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 22
6564: PUSH
6565: LD_INT 3
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 44
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: LIST
6588: LIST
6589: PPUSH
6590: CALL 75266 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6594: LD_INT 2
6596: PPUSH
6597: LD_INT 0
6599: PUSH
6600: LD_INT 96
6602: PUSH
6603: LD_INT 125
6605: PUSH
6606: LD_INT 0
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 6
6617: PUSH
6618: LD_INT 74
6620: PUSH
6621: LD_INT 122
6623: PUSH
6624: LD_INT 1
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 30
6635: PUSH
6636: LD_INT 84
6638: PUSH
6639: LD_INT 125
6641: PUSH
6642: LD_INT 1
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 28
6653: PUSH
6654: LD_INT 86
6656: PUSH
6657: LD_INT 128
6659: PUSH
6660: LD_INT 1
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 28
6671: PUSH
6672: LD_INT 85
6674: PUSH
6675: LD_INT 130
6677: PUSH
6678: LD_INT 2
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 28
6689: PUSH
6690: LD_INT 88
6692: PUSH
6693: LD_INT 132
6695: PUSH
6696: LD_INT 5
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: LD_INT 2
6707: PUSH
6708: LD_INT 106
6710: PUSH
6711: LD_INT 130
6713: PUSH
6714: LD_INT 0
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 4
6725: PUSH
6726: LD_INT 99
6728: PUSH
6729: LD_INT 114
6731: PUSH
6732: LD_INT 3
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: PUSH
6741: LD_INT 32
6743: PUSH
6744: LD_INT 72
6746: PUSH
6747: LD_INT 112
6749: PUSH
6750: LD_INT 2
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 32
6761: PUSH
6762: LD_INT 78
6764: PUSH
6765: LD_INT 110
6767: PUSH
6768: LD_INT 3
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: PUSH
6777: LD_INT 32
6779: PUSH
6780: LD_INT 84
6782: PUSH
6783: LD_INT 110
6785: PUSH
6786: LD_INT 2
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: PUSH
6795: LD_INT 32
6797: PUSH
6798: LD_INT 105
6800: PUSH
6801: LD_INT 117
6803: PUSH
6804: LD_INT 3
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: LIST
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL 75158 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6831: LD_INT 2
6833: PPUSH
6834: LD_INT 14
6836: PUSH
6837: LD_INT 11
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PPUSH
6844: CALL 76008 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6848: LD_INT 2
6850: PPUSH
6851: LD_INT 106
6853: PPUSH
6854: LD_INT 130
6856: PPUSH
6857: LD_INT 0
6859: PPUSH
6860: LD_INT 24
6862: PUSH
6863: LD_INT 16
6865: PUSH
6866: LD_INT 17
6868: PUSH
6869: LD_INT 18
6871: PUSH
6872: LD_INT 21
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: LIST
6879: LIST
6880: LIST
6881: PPUSH
6882: CALL 76213 0 5
// end ;
6886: LD_VAR 0 1
6890: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6891: LD_INT 22
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 30
6903: PUSH
6904: LD_INT 3
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PPUSH
6915: CALL_OW 69
6919: IFFALSE 8062
6921: GO 6923
6923: DISABLE
6924: LD_INT 0
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
6931: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
6932: LD_INT 6300
6934: PUSH
6935: LD_INT 4200
6937: PUSH
6938: LD_INT 2100
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: LIST
6945: PUSH
6946: LD_OWVAR 67
6950: ARRAY
6951: PPUSH
6952: CALL_OW 67
// base := 2 ;
6956: LD_ADDR_VAR 0 2
6960: PUSH
6961: LD_INT 2
6963: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
6964: LD_INT 22
6966: PUSH
6967: LD_INT 3
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 30
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PPUSH
6988: CALL_OW 69
6992: NOT
6993: IFFALSE 6997
// continue ;
6995: GO 6932
// case Rand ( 1 , 3 ) of 1 :
6997: LD_INT 1
6999: PPUSH
7000: LD_INT 3
7002: PPUSH
7003: CALL_OW 12
7007: PUSH
7008: LD_INT 1
7010: DOUBLE
7011: EQUAL
7012: IFTRUE 7016
7014: GO 7192
7016: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7017: LD_ADDR_VAR 0 3
7021: PUSH
7022: LD_INT 22
7024: PUSH
7025: LD_INT 3
7027: PUSH
7028: LD_INT 3
7030: PUSH
7031: LD_INT 43
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 24
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 3
7048: PUSH
7049: LD_INT 46
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 24
7060: PUSH
7061: LD_INT 3
7063: PUSH
7064: LD_INT 3
7066: PUSH
7067: LD_INT 43
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 24
7078: PUSH
7079: LD_INT 3
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: LD_INT 46
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PUSH
7094: LD_INT 22
7096: PUSH
7097: LD_INT 3
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 45
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: LD_INT 3
7120: PUSH
7121: LD_INT 43
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: PUSH
7130: LD_INT 24
7132: PUSH
7133: LD_INT 3
7135: PUSH
7136: LD_INT 3
7138: PUSH
7139: LD_INT 46
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: PUSH
7148: LD_INT 22
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 3
7156: PUSH
7157: LD_INT 45
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7176: LD_VAR 0 2
7180: PPUSH
7181: LD_VAR 0 3
7185: PPUSH
7186: CALL 75314 0 2
// end ; 2 :
7190: GO 7523
7192: LD_INT 2
7194: DOUBLE
7195: EQUAL
7196: IFTRUE 7200
7198: GO 7338
7200: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7201: LD_ADDR_VAR 0 3
7205: PUSH
7206: LD_INT 24
7208: PUSH
7209: LD_INT 3
7211: PUSH
7212: LD_INT 3
7214: PUSH
7215: LD_INT 43
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: PUSH
7224: LD_INT 24
7226: PUSH
7227: LD_INT 3
7229: PUSH
7230: LD_INT 3
7232: PUSH
7233: LD_INT 46
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: PUSH
7242: LD_INT 24
7244: PUSH
7245: LD_INT 3
7247: PUSH
7248: LD_INT 3
7250: PUSH
7251: LD_INT 43
7253: PUSH
7254: EMPTY
7255: LIST
7256: LIST
7257: LIST
7258: LIST
7259: PUSH
7260: LD_INT 24
7262: PUSH
7263: LD_INT 3
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: LD_INT 46
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: PUSH
7278: LD_INT 22
7280: PUSH
7281: LD_INT 3
7283: PUSH
7284: LD_INT 3
7286: PUSH
7287: LD_INT 45
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 22
7298: PUSH
7299: LD_INT 3
7301: PUSH
7302: LD_INT 3
7304: PUSH
7305: LD_INT 45
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: LIST
7318: LIST
7319: LIST
7320: LIST
7321: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7322: LD_VAR 0 2
7326: PPUSH
7327: LD_VAR 0 3
7331: PPUSH
7332: CALL 75314 0 2
// end ; 3 :
7336: GO 7523
7338: LD_INT 3
7340: DOUBLE
7341: EQUAL
7342: IFTRUE 7346
7344: GO 7522
7346: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7347: LD_ADDR_VAR 0 3
7351: PUSH
7352: LD_INT 22
7354: PUSH
7355: LD_INT 3
7357: PUSH
7358: LD_INT 3
7360: PUSH
7361: LD_INT 43
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 24
7372: PUSH
7373: LD_INT 3
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: LD_INT 46
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: LD_INT 3
7396: PUSH
7397: LD_INT 43
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: LD_INT 24
7408: PUSH
7409: LD_INT 3
7411: PUSH
7412: LD_INT 3
7414: PUSH
7415: LD_INT 46
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_INT 3
7429: PUSH
7430: LD_INT 3
7432: PUSH
7433: LD_INT 45
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: LD_INT 22
7444: PUSH
7445: LD_INT 3
7447: PUSH
7448: LD_INT 3
7450: PUSH
7451: LD_INT 43
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 24
7462: PUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: LD_INT 46
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: LIST
7476: LIST
7477: PUSH
7478: LD_INT 22
7480: PUSH
7481: LD_INT 3
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 45
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7506: LD_VAR 0 2
7510: PPUSH
7511: LD_VAR 0 3
7515: PPUSH
7516: CALL 75314 0 2
// end ; end ;
7520: GO 7523
7522: POP
// repeat wait ( 0 0$1 ) ;
7523: LD_INT 35
7525: PPUSH
7526: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7530: LD_VAR 0 2
7534: PPUSH
7535: CALL 75662 0 1
7539: PUSH
7540: LD_INT 0
7542: EQUAL
7543: IFFALSE 7523
// wait ( 0 0$30 ) ;
7545: LD_INT 1050
7547: PPUSH
7548: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7552: LD_ADDR_VAR 0 5
7556: PUSH
7557: LD_INT 86
7559: PUSH
7560: LD_INT 77
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 63
7569: PUSH
7570: LD_INT 38
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7581: LD_ADDR_VAR 0 4
7585: PUSH
7586: LD_INT 0
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: LD_INT 0
7594: PUSH
7595: LD_INT 1
7597: PUSH
7598: LD_INT 0
7600: PUSH
7601: LD_INT 0
7603: PUSH
7604: LD_INT 0
7606: PUSH
7607: LD_INT 0
7609: PUSH
7610: LD_INT 1
7612: PUSH
7613: LD_INT 0
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7628: LD_ADDR_VAR 0 6
7632: PUSH
7633: LD_EXP 87
7637: PUSH
7638: LD_VAR 0 2
7642: ARRAY
7643: PUSH
7644: LD_EXP 90
7648: PUSH
7649: LD_VAR 0 2
7653: ARRAY
7654: DIFF
7655: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7656: LD_ADDR_EXP 87
7660: PUSH
7661: LD_EXP 87
7665: PPUSH
7666: LD_VAR 0 2
7670: PPUSH
7671: LD_EXP 87
7675: PUSH
7676: LD_VAR 0 2
7680: ARRAY
7681: PUSH
7682: LD_VAR 0 6
7686: DIFF
7687: PPUSH
7688: CALL_OW 1
7692: ST_TO_ADDR
// if not attackers then
7693: LD_VAR 0 6
7697: NOT
7698: IFFALSE 7702
// continue ;
7700: GO 6932
// repeat wait ( 0 0$1 ) ;
7702: LD_INT 35
7704: PPUSH
7705: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7709: LD_VAR 0 6
7713: PPUSH
7714: LD_INT 60
7716: PUSH
7717: EMPTY
7718: LIST
7719: PPUSH
7720: CALL_OW 72
7724: NOT
7725: IFFALSE 7702
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// for i in attackers do
7734: LD_ADDR_VAR 0 1
7738: PUSH
7739: LD_VAR 0 6
7743: PUSH
7744: FOR_IN
7745: IFFALSE 8029
// begin if IsDead ( i ) then
7747: LD_VAR 0 1
7751: PPUSH
7752: CALL_OW 301
7756: IFFALSE 7774
// attackers := attackers diff i ;
7758: LD_ADDR_VAR 0 6
7762: PUSH
7763: LD_VAR 0 6
7767: PUSH
7768: LD_VAR 0 1
7772: DIFF
7773: ST_TO_ADDR
// if not HasTask ( i ) then
7774: LD_VAR 0 1
7778: PPUSH
7779: CALL_OW 314
7783: NOT
7784: IFFALSE 8027
// begin if not GetTag ( i ) then
7786: LD_VAR 0 1
7790: PPUSH
7791: CALL_OW 110
7795: NOT
7796: IFFALSE 7888
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
7798: LD_VAR 0 1
7802: PPUSH
7803: LD_VAR 0 5
7807: PUSH
7808: LD_INT 1
7810: ARRAY
7811: PUSH
7812: LD_INT 1
7814: ARRAY
7815: PPUSH
7816: LD_VAR 0 5
7820: PUSH
7821: LD_INT 1
7823: ARRAY
7824: PUSH
7825: LD_INT 2
7827: ARRAY
7828: PPUSH
7829: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
7833: LD_VAR 0 1
7837: PPUSH
7838: LD_VAR 0 5
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PUSH
7847: LD_INT 1
7849: ARRAY
7850: PPUSH
7851: LD_VAR 0 5
7855: PUSH
7856: LD_INT 1
7858: ARRAY
7859: PUSH
7860: LD_INT 2
7862: ARRAY
7863: PPUSH
7864: CALL_OW 297
7868: PUSH
7869: LD_INT 8
7871: LESS
7872: IFFALSE 7886
// SetTag ( i , 1 ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_INT 1
7881: PPUSH
7882: CALL_OW 109
// end else
7886: GO 8027
// if GetTag ( i ) = 1 then
7888: LD_VAR 0 1
7892: PPUSH
7893: CALL_OW 110
7897: PUSH
7898: LD_INT 1
7900: EQUAL
7901: IFFALSE 7993
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
7903: LD_VAR 0 1
7907: PPUSH
7908: LD_VAR 0 5
7912: PUSH
7913: LD_INT 2
7915: ARRAY
7916: PUSH
7917: LD_INT 1
7919: ARRAY
7920: PPUSH
7921: LD_VAR 0 5
7925: PUSH
7926: LD_INT 2
7928: ARRAY
7929: PUSH
7930: LD_INT 2
7932: ARRAY
7933: PPUSH
7934: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
7938: LD_VAR 0 1
7942: PPUSH
7943: LD_VAR 0 5
7947: PUSH
7948: LD_INT 2
7950: ARRAY
7951: PUSH
7952: LD_INT 1
7954: ARRAY
7955: PPUSH
7956: LD_VAR 0 5
7960: PUSH
7961: LD_INT 2
7963: ARRAY
7964: PUSH
7965: LD_INT 2
7967: ARRAY
7968: PPUSH
7969: CALL_OW 297
7973: PUSH
7974: LD_INT 8
7976: LESS
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// end else
7991: GO 8027
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_INT 81
8000: PUSH
8001: LD_INT 3
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PPUSH
8008: CALL_OW 69
8012: PPUSH
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL_OW 74
8022: PPUSH
8023: CALL_OW 115
// end ; end ;
8027: GO 7744
8029: POP
8030: POP
// until not attackers ;
8031: LD_VAR 0 6
8035: NOT
8036: IFFALSE 7727
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8038: LD_EXP 68
8042: PUSH
8043: LD_VAR 0 2
8047: ARRAY
8048: PPUSH
8049: LD_INT 50
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 72
8059: NOT
8060: IFFALSE 6932
// end ;
8062: PPOPN 6
8064: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
8065: LD_INT 22
8067: PUSH
8068: LD_INT 3
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: LD_INT 30
8077: PUSH
8078: LD_INT 3
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PPUSH
8089: CALL_OW 69
8093: IFFALSE 9277
8095: GO 8097
8097: DISABLE
8098: LD_INT 0
8100: PPUSH
8101: PPUSH
8102: PPUSH
8103: PPUSH
8104: PPUSH
8105: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
8106: LD_INT 6300
8108: PUSH
8109: LD_INT 4200
8111: PUSH
8112: LD_INT 2100
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PPUSH
8126: CALL_OW 67
// base := 1 ;
8130: LD_ADDR_VAR 0 2
8134: PUSH
8135: LD_INT 1
8137: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8138: LD_INT 22
8140: PUSH
8141: LD_INT 3
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 30
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PPUSH
8162: CALL_OW 69
8166: NOT
8167: IFFALSE 8171
// continue ;
8169: GO 8106
// case Rand ( 1 , 3 ) of 1 :
8171: LD_INT 1
8173: PPUSH
8174: LD_INT 3
8176: PPUSH
8177: CALL_OW 12
8181: PUSH
8182: LD_INT 1
8184: DOUBLE
8185: EQUAL
8186: IFTRUE 8190
8188: GO 8366
8190: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8191: LD_ADDR_VAR 0 3
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 1
8201: PUSH
8202: LD_INT 3
8204: PUSH
8205: LD_INT 43
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 24
8216: PUSH
8217: LD_INT 1
8219: PUSH
8220: LD_INT 3
8222: PUSH
8223: LD_INT 46
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 24
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: LD_INT 3
8240: PUSH
8241: LD_INT 43
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: PUSH
8250: LD_INT 24
8252: PUSH
8253: LD_INT 1
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: LD_INT 46
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: PUSH
8268: LD_INT 22
8270: PUSH
8271: LD_INT 1
8273: PUSH
8274: LD_INT 3
8276: PUSH
8277: LD_INT 45
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: LIST
8284: LIST
8285: PUSH
8286: LD_INT 22
8288: PUSH
8289: LD_INT 1
8291: PUSH
8292: LD_INT 3
8294: PUSH
8295: LD_INT 43
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: LIST
8302: LIST
8303: PUSH
8304: LD_INT 24
8306: PUSH
8307: LD_INT 1
8309: PUSH
8310: LD_INT 3
8312: PUSH
8313: LD_INT 46
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_INT 22
8324: PUSH
8325: LD_INT 1
8327: PUSH
8328: LD_INT 3
8330: PUSH
8331: LD_INT 45
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: LIST
8349: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_VAR 0 3
8359: PPUSH
8360: CALL 75314 0 2
// end ; 2 :
8364: GO 8735
8366: LD_INT 2
8368: DOUBLE
8369: EQUAL
8370: IFTRUE 8374
8372: GO 8550
8374: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8375: LD_ADDR_VAR 0 3
8379: PUSH
8380: LD_INT 24
8382: PUSH
8383: LD_INT 1
8385: PUSH
8386: LD_INT 3
8388: PUSH
8389: LD_INT 43
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 24
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: LD_INT 3
8406: PUSH
8407: LD_INT 46
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 24
8418: PUSH
8419: LD_INT 1
8421: PUSH
8422: LD_INT 3
8424: PUSH
8425: LD_INT 43
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 24
8436: PUSH
8437: LD_INT 1
8439: PUSH
8440: LD_INT 3
8442: PUSH
8443: LD_INT 46
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: LIST
8451: PUSH
8452: LD_INT 22
8454: PUSH
8455: LD_INT 1
8457: PUSH
8458: LD_INT 3
8460: PUSH
8461: LD_INT 45
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 22
8472: PUSH
8473: LD_INT 1
8475: PUSH
8476: LD_INT 3
8478: PUSH
8479: LD_INT 45
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 22
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 3
8496: PUSH
8497: LD_INT 45
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 1
8511: PUSH
8512: LD_INT 3
8514: PUSH
8515: LD_INT 45
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: LIST
8533: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8534: LD_VAR 0 2
8538: PPUSH
8539: LD_VAR 0 3
8543: PPUSH
8544: CALL 75314 0 2
// end ; 3 :
8548: GO 8735
8550: LD_INT 3
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8734
8558: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: LD_INT 22
8566: PUSH
8567: LD_INT 1
8569: PUSH
8570: LD_INT 3
8572: PUSH
8573: LD_INT 43
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_INT 24
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: LD_INT 3
8590: PUSH
8591: LD_INT 46
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 22
8602: PUSH
8603: LD_INT 1
8605: PUSH
8606: LD_INT 3
8608: PUSH
8609: LD_INT 43
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: LIST
8616: LIST
8617: PUSH
8618: LD_INT 24
8620: PUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: LD_INT 46
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: LIST
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: LD_INT 45
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: PUSH
8654: LD_INT 22
8656: PUSH
8657: LD_INT 1
8659: PUSH
8660: LD_INT 3
8662: PUSH
8663: LD_INT 43
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: LIST
8670: LIST
8671: PUSH
8672: LD_INT 24
8674: PUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: LD_INT 46
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 22
8692: PUSH
8693: LD_INT 1
8695: PUSH
8696: LD_INT 3
8698: PUSH
8699: LD_INT 45
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: LIST
8706: LIST
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8718: LD_VAR 0 2
8722: PPUSH
8723: LD_VAR 0 3
8727: PPUSH
8728: CALL 75314 0 2
// end ; end ;
8732: GO 8735
8734: POP
// repeat wait ( 0 0$1 ) ;
8735: LD_INT 35
8737: PPUSH
8738: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8742: LD_VAR 0 2
8746: PPUSH
8747: LD_INT 1
8749: PPUSH
8750: CALL 76732 0 2
8754: PUSH
8755: LD_INT 8
8757: GREATEREQUAL
8758: IFFALSE 8735
// wait ( 0 0$30 ) ;
8760: LD_INT 1050
8762: PPUSH
8763: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8767: LD_ADDR_VAR 0 5
8771: PUSH
8772: LD_INT 144
8774: PUSH
8775: LD_INT 65
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 63
8784: PUSH
8785: LD_INT 38
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: PUSH
8792: EMPTY
8793: LIST
8794: LIST
8795: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8796: LD_ADDR_VAR 0 4
8800: PUSH
8801: LD_INT 0
8803: PUSH
8804: LD_INT 0
8806: PUSH
8807: LD_INT 0
8809: PUSH
8810: LD_INT 1
8812: PUSH
8813: LD_INT 0
8815: PUSH
8816: LD_INT 0
8818: PUSH
8819: LD_INT 0
8821: PUSH
8822: LD_INT 0
8824: PUSH
8825: LD_INT 1
8827: PUSH
8828: LD_INT 0
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_EXP 87
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PUSH
8859: LD_EXP 90
8863: PUSH
8864: LD_VAR 0 2
8868: ARRAY
8869: DIFF
8870: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8871: LD_ADDR_EXP 87
8875: PUSH
8876: LD_EXP 87
8880: PPUSH
8881: LD_VAR 0 2
8885: PPUSH
8886: LD_EXP 87
8890: PUSH
8891: LD_VAR 0 2
8895: ARRAY
8896: PUSH
8897: LD_VAR 0 6
8901: DIFF
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// if not attackers then
8908: LD_VAR 0 6
8912: NOT
8913: IFFALSE 8917
// continue ;
8915: GO 8106
// repeat wait ( 0 0$1 ) ;
8917: LD_INT 35
8919: PPUSH
8920: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8924: LD_VAR 0 6
8928: PPUSH
8929: LD_INT 60
8931: PUSH
8932: EMPTY
8933: LIST
8934: PPUSH
8935: CALL_OW 72
8939: NOT
8940: IFFALSE 8917
// repeat wait ( 0 0$1 ) ;
8942: LD_INT 35
8944: PPUSH
8945: CALL_OW 67
// for i in attackers do
8949: LD_ADDR_VAR 0 1
8953: PUSH
8954: LD_VAR 0 6
8958: PUSH
8959: FOR_IN
8960: IFFALSE 9244
// begin if IsDead ( i ) then
8962: LD_VAR 0 1
8966: PPUSH
8967: CALL_OW 301
8971: IFFALSE 8989
// attackers := attackers diff i ;
8973: LD_ADDR_VAR 0 6
8977: PUSH
8978: LD_VAR 0 6
8982: PUSH
8983: LD_VAR 0 1
8987: DIFF
8988: ST_TO_ADDR
// if not HasTask ( i ) then
8989: LD_VAR 0 1
8993: PPUSH
8994: CALL_OW 314
8998: NOT
8999: IFFALSE 9242
// begin if not GetTag ( i ) then
9001: LD_VAR 0 1
9005: PPUSH
9006: CALL_OW 110
9010: NOT
9011: IFFALSE 9103
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
9013: LD_VAR 0 1
9017: PPUSH
9018: LD_VAR 0 5
9022: PUSH
9023: LD_INT 1
9025: ARRAY
9026: PUSH
9027: LD_INT 1
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 5
9035: PUSH
9036: LD_INT 1
9038: ARRAY
9039: PUSH
9040: LD_INT 2
9042: ARRAY
9043: PPUSH
9044: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
9048: LD_VAR 0 1
9052: PPUSH
9053: LD_VAR 0 5
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PUSH
9062: LD_INT 1
9064: ARRAY
9065: PPUSH
9066: LD_VAR 0 5
9070: PUSH
9071: LD_INT 1
9073: ARRAY
9074: PUSH
9075: LD_INT 2
9077: ARRAY
9078: PPUSH
9079: CALL_OW 297
9083: PUSH
9084: LD_INT 8
9086: LESS
9087: IFFALSE 9101
// SetTag ( i , 1 ) ;
9089: LD_VAR 0 1
9093: PPUSH
9094: LD_INT 1
9096: PPUSH
9097: CALL_OW 109
// end else
9101: GO 9242
// if GetTag ( i ) = 1 then
9103: LD_VAR 0 1
9107: PPUSH
9108: CALL_OW 110
9112: PUSH
9113: LD_INT 1
9115: EQUAL
9116: IFFALSE 9208
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
9118: LD_VAR 0 1
9122: PPUSH
9123: LD_VAR 0 5
9127: PUSH
9128: LD_INT 2
9130: ARRAY
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_VAR 0 5
9140: PUSH
9141: LD_INT 2
9143: ARRAY
9144: PUSH
9145: LD_INT 2
9147: ARRAY
9148: PPUSH
9149: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
9153: LD_VAR 0 1
9157: PPUSH
9158: LD_VAR 0 5
9162: PUSH
9163: LD_INT 2
9165: ARRAY
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 5
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PUSH
9180: LD_INT 2
9182: ARRAY
9183: PPUSH
9184: CALL_OW 297
9188: PUSH
9189: LD_INT 8
9191: LESS
9192: IFFALSE 9206
// SetTag ( i , 2 ) ;
9194: LD_VAR 0 1
9198: PPUSH
9199: LD_INT 2
9201: PPUSH
9202: CALL_OW 109
// end else
9206: GO 9242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9208: LD_VAR 0 1
9212: PPUSH
9213: LD_INT 81
9215: PUSH
9216: LD_INT 3
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: PPUSH
9223: CALL_OW 69
9227: PPUSH
9228: LD_VAR 0 1
9232: PPUSH
9233: CALL_OW 74
9237: PPUSH
9238: CALL_OW 115
// end ; end ;
9242: GO 8959
9244: POP
9245: POP
// until not attackers ;
9246: LD_VAR 0 6
9250: NOT
9251: IFFALSE 8942
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
9253: LD_EXP 68
9257: PUSH
9258: LD_VAR 0 2
9262: ARRAY
9263: PPUSH
9264: LD_INT 50
9266: PUSH
9267: EMPTY
9268: LIST
9269: PPUSH
9270: CALL_OW 72
9274: NOT
9275: IFFALSE 8106
// end ;
9277: PPOPN 6
9279: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9280: LD_EXP 4
9284: PUSH
9285: LD_INT 22
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 21
9297: PUSH
9298: LD_INT 1
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 69
9313: PUSH
9314: LD_INT 0
9316: EQUAL
9317: AND
9318: IFFALSE 9331
9320: GO 9322
9322: DISABLE
// RussiansDefeated := true ;
9323: LD_ADDR_EXP 44
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
9331: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
9332: LD_EXP 4
9336: PUSH
9337: LD_EXP 6
9341: NOT
9342: AND
9343: IFFALSE 10767
9345: GO 9347
9347: DISABLE
9348: LD_INT 0
9350: PPUSH
9351: PPUSH
9352: PPUSH
9353: PPUSH
9354: PPUSH
9355: PPUSH
9356: PPUSH
9357: PPUSH
9358: PPUSH
9359: PPUSH
9360: PPUSH
9361: PPUSH
// begin wait ( [ Rand ( 4 4$00 , 4 4$30 ) , Rand ( 4 4$30 , 3 3$30 ) , Rand ( 3 3$00 , 2 2$00 ) ] [ Difficulty ] ) ;
9362: LD_INT 8400
9364: PPUSH
9365: LD_INT 9450
9367: PPUSH
9368: CALL_OW 12
9372: PUSH
9373: LD_INT 9450
9375: PPUSH
9376: LD_INT 7350
9378: PPUSH
9379: CALL_OW 12
9383: PUSH
9384: LD_INT 6300
9386: PPUSH
9387: LD_INT 4200
9389: PPUSH
9390: CALL_OW 12
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: LD_OWVAR 67
9404: ARRAY
9405: PPUSH
9406: CALL_OW 67
// filter := [ ] ;
9410: LD_ADDR_VAR 0 3
9414: PUSH
9415: EMPTY
9416: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9417: LD_ADDR_VAR 0 4
9421: PUSH
9422: LD_INT 2
9424: PPUSH
9425: LD_INT 3
9427: PPUSH
9428: CALL_OW 12
9432: PUSH
9433: LD_INT 3
9435: PPUSH
9436: LD_INT 4
9438: PPUSH
9439: CALL_OW 12
9443: PUSH
9444: LD_INT 3
9446: PPUSH
9447: LD_INT 5
9449: PPUSH
9450: CALL_OW 12
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: LIST
9459: PUSH
9460: LD_OWVAR 67
9464: ARRAY
9465: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 1
9473: PUSH
9474: LD_INT 1
9476: PPUSH
9477: LD_INT 2
9479: PPUSH
9480: CALL_OW 12
9484: PUSH
9485: LD_INT 2
9487: PPUSH
9488: LD_INT 3
9490: PPUSH
9491: CALL_OW 12
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: LIST
9500: PUSH
9501: LD_OWVAR 67
9505: ARRAY
9506: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9507: LD_ADDR_VAR 0 6
9511: PUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: PUSH
9523: LD_INT 2
9525: PPUSH
9526: LD_INT 4
9528: PPUSH
9529: CALL_OW 12
9533: PUSH
9534: LD_INT 3
9536: PPUSH
9537: LD_INT 5
9539: PPUSH
9540: CALL_OW 12
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_OWVAR 67
9554: ARRAY
9555: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
9556: LD_ADDR_VAR 0 8
9560: PUSH
9561: LD_INT 1
9563: PUSH
9564: LD_INT 2
9566: PUSH
9567: LD_INT 2
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: LD_OWVAR 67
9579: ARRAY
9580: ST_TO_ADDR
// uc_side := 3 ;
9581: LD_ADDR_OWVAR 20
9585: PUSH
9586: LD_INT 3
9588: ST_TO_ADDR
// uc_nation := nation_russian ;
9589: LD_ADDR_OWVAR 21
9593: PUSH
9594: LD_INT 3
9596: ST_TO_ADDR
// for i = 1 to soldiers do
9597: LD_ADDR_VAR 0 1
9601: PUSH
9602: DOUBLE
9603: LD_INT 1
9605: DEC
9606: ST_TO_ADDR
9607: LD_VAR 0 4
9611: PUSH
9612: FOR_TO
9613: IFFALSE 9655
// begin PrepareSoldier ( 0 , game_eskill ) ;
9615: LD_INT 0
9617: PPUSH
9618: LD_EXP 40
9622: PPUSH
9623: CALL_OW 381
// un := CreateHuman ;
9627: LD_ADDR_VAR 0 2
9631: PUSH
9632: CALL_OW 44
9636: ST_TO_ADDR
// filter := filter ^ un ;
9637: LD_ADDR_VAR 0 3
9641: PUSH
9642: LD_VAR 0 3
9646: PUSH
9647: LD_VAR 0 2
9651: ADD
9652: ST_TO_ADDR
// end ;
9653: GO 9612
9655: POP
9656: POP
// for i = 1 to bazookas do
9657: LD_ADDR_VAR 0 1
9661: PUSH
9662: DOUBLE
9663: LD_INT 1
9665: DEC
9666: ST_TO_ADDR
9667: LD_VAR 0 5
9671: PUSH
9672: FOR_TO
9673: IFFALSE 9723
// begin PrepareSoldier ( 0 , game_eskill ) ;
9675: LD_INT 0
9677: PPUSH
9678: LD_EXP 40
9682: PPUSH
9683: CALL_OW 381
// hc_class := class_bazooker ;
9687: LD_ADDR_OWVAR 28
9691: PUSH
9692: LD_INT 9
9694: ST_TO_ADDR
// un := CreateHuman ;
9695: LD_ADDR_VAR 0 2
9699: PUSH
9700: CALL_OW 44
9704: ST_TO_ADDR
// filter := filter ^ un ;
9705: LD_ADDR_VAR 0 3
9709: PUSH
9710: LD_VAR 0 3
9714: PUSH
9715: LD_VAR 0 2
9719: ADD
9720: ST_TO_ADDR
// end ;
9721: GO 9672
9723: POP
9724: POP
// for i = 1 to medics do
9725: LD_ADDR_VAR 0 1
9729: PUSH
9730: DOUBLE
9731: LD_INT 1
9733: DEC
9734: ST_TO_ADDR
9735: LD_VAR 0 8
9739: PUSH
9740: FOR_TO
9741: IFFALSE 9783
// begin PrepareScientist ( 0 , game_eskill ) ;
9743: LD_INT 0
9745: PPUSH
9746: LD_EXP 40
9750: PPUSH
9751: CALL_OW 384
// un := CreateHuman ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: CALL_OW 44
9764: ST_TO_ADDR
// filter := filter ^ un ;
9765: LD_ADDR_VAR 0 3
9769: PUSH
9770: LD_VAR 0 3
9774: PUSH
9775: LD_VAR 0 2
9779: ADD
9780: ST_TO_ADDR
// end ;
9781: GO 9740
9783: POP
9784: POP
// for i = 1 to vehs do
9785: LD_ADDR_VAR 0 1
9789: PUSH
9790: DOUBLE
9791: LD_INT 1
9793: DEC
9794: ST_TO_ADDR
9795: LD_VAR 0 6
9799: PUSH
9800: FOR_TO
9801: IFFALSE 9993
// begin case Rand ( 1 , 5 ) of 1 :
9803: LD_INT 1
9805: PPUSH
9806: LD_INT 5
9808: PPUSH
9809: CALL_OW 12
9813: PUSH
9814: LD_INT 1
9816: DOUBLE
9817: EQUAL
9818: IFTRUE 9822
9820: GO 9844
9822: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
9823: LD_INT 22
9825: PPUSH
9826: LD_INT 3
9828: PPUSH
9829: LD_INT 3
9831: PPUSH
9832: LD_INT 43
9834: PPUSH
9835: LD_INT 100
9837: PPUSH
9838: CALL 18426 0 5
9842: GO 9965
9844: LD_INT 2
9846: DOUBLE
9847: EQUAL
9848: IFTRUE 9852
9850: GO 9874
9852: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
9853: LD_INT 22
9855: PPUSH
9856: LD_INT 3
9858: PPUSH
9859: LD_INT 3
9861: PPUSH
9862: LD_INT 44
9864: PPUSH
9865: LD_INT 100
9867: PPUSH
9868: CALL 18426 0 5
9872: GO 9965
9874: LD_INT 3
9876: DOUBLE
9877: EQUAL
9878: IFTRUE 9882
9880: GO 9904
9882: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
9883: LD_INT 22
9885: PPUSH
9886: LD_INT 3
9888: PPUSH
9889: LD_INT 3
9891: PPUSH
9892: LD_INT 45
9894: PPUSH
9895: LD_INT 100
9897: PPUSH
9898: CALL 18426 0 5
9902: GO 9965
9904: LD_INT 4
9906: DOUBLE
9907: EQUAL
9908: IFTRUE 9912
9910: GO 9934
9912: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
9913: LD_INT 24
9915: PPUSH
9916: LD_INT 3
9918: PPUSH
9919: LD_INT 3
9921: PPUSH
9922: LD_INT 43
9924: PPUSH
9925: LD_INT 100
9927: PPUSH
9928: CALL 18426 0 5
9932: GO 9965
9934: LD_INT 5
9936: DOUBLE
9937: EQUAL
9938: IFTRUE 9942
9940: GO 9964
9942: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
9943: LD_INT 24
9945: PPUSH
9946: LD_INT 3
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 46
9954: PPUSH
9955: LD_INT 100
9957: PPUSH
9958: CALL 18426 0 5
9962: GO 9965
9964: POP
// vehicle := CreateVehicle ;
9965: LD_ADDR_VAR 0 7
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// filter := filter ^ vehicle ;
9975: LD_ADDR_VAR 0 3
9979: PUSH
9980: LD_VAR 0 3
9984: PUSH
9985: LD_VAR 0 7
9989: ADD
9990: ST_TO_ADDR
// end ;
9991: GO 9800
9993: POP
9994: POP
// for i = 1 to filter do
9995: LD_ADDR_VAR 0 1
9999: PUSH
10000: DOUBLE
10001: LD_INT 1
10003: DEC
10004: ST_TO_ADDR
10005: LD_VAR 0 3
10009: PUSH
10010: FOR_TO
10011: IFFALSE 10036
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
10013: LD_VAR 0 3
10017: PUSH
10018: LD_VAR 0 1
10022: ARRAY
10023: PPUSH
10024: LD_INT 14
10026: PPUSH
10027: LD_INT 0
10029: PPUSH
10030: CALL_OW 49
10034: GO 10010
10036: POP
10037: POP
// case Rand ( 1 , 3 ) of 1 :
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 3
10043: PPUSH
10044: CALL_OW 12
10048: PUSH
10049: LD_INT 1
10051: DOUBLE
10052: EQUAL
10053: IFTRUE 10057
10055: GO 10111
10057: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
10058: LD_ADDR_VAR 0 11
10062: PUSH
10063: LD_INT 165
10065: PUSH
10066: LD_INT 114
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PUSH
10073: LD_INT 104
10075: PUSH
10076: LD_INT 108
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PUSH
10083: LD_INT 86
10085: PUSH
10086: LD_INT 77
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PUSH
10093: LD_INT 63
10095: PUSH
10096: LD_INT 38
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: ST_TO_ADDR
10109: GO 10236
10111: LD_INT 2
10113: DOUBLE
10114: EQUAL
10115: IFTRUE 10119
10117: GO 10173
10119: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
10120: LD_ADDR_VAR 0 11
10124: PUSH
10125: LD_INT 165
10127: PUSH
10128: LD_INT 114
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 146
10137: PUSH
10138: LD_INT 71
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: LD_INT 112
10147: PUSH
10148: LD_INT 41
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PUSH
10155: LD_INT 63
10157: PUSH
10158: LD_INT 38
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: ST_TO_ADDR
10171: GO 10236
10173: LD_INT 3
10175: DOUBLE
10176: EQUAL
10177: IFTRUE 10181
10179: GO 10235
10181: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
10182: LD_ADDR_VAR 0 11
10186: PUSH
10187: LD_INT 165
10189: PUSH
10190: LD_INT 114
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 63
10199: PUSH
10200: LD_INT 99
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 55
10209: PUSH
10210: LD_INT 77
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PUSH
10217: LD_INT 63
10219: PUSH
10220: LD_INT 38
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: ST_TO_ADDR
10233: GO 10236
10235: POP
// attackers := filter ;
10236: LD_ADDR_VAR 0 10
10240: PUSH
10241: LD_VAR 0 3
10245: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// for i in attackers do
10253: LD_ADDR_VAR 0 1
10257: PUSH
10258: LD_VAR 0 10
10262: PUSH
10263: FOR_IN
10264: IFFALSE 10758
// begin if IsDead ( i ) then
10266: LD_VAR 0 1
10270: PPUSH
10271: CALL_OW 301
10275: IFFALSE 10293
// attackers := attackers diff i ;
10277: LD_ADDR_VAR 0 10
10281: PUSH
10282: LD_VAR 0 10
10286: PUSH
10287: LD_VAR 0 1
10291: DIFF
10292: ST_TO_ADDR
// if not HasTask ( i ) then
10293: LD_VAR 0 1
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10756
// begin if not GetTag ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 110
10314: NOT
10315: IFFALSE 10407
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
10317: LD_VAR 0 1
10321: PPUSH
10322: LD_VAR 0 11
10326: PUSH
10327: LD_INT 1
10329: ARRAY
10330: PUSH
10331: LD_INT 1
10333: ARRAY
10334: PPUSH
10335: LD_VAR 0 11
10339: PUSH
10340: LD_INT 1
10342: ARRAY
10343: PUSH
10344: LD_INT 2
10346: ARRAY
10347: PPUSH
10348: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
10352: LD_VAR 0 1
10356: PPUSH
10357: LD_VAR 0 11
10361: PUSH
10362: LD_INT 1
10364: ARRAY
10365: PUSH
10366: LD_INT 1
10368: ARRAY
10369: PPUSH
10370: LD_VAR 0 11
10374: PUSH
10375: LD_INT 1
10377: ARRAY
10378: PUSH
10379: LD_INT 2
10381: ARRAY
10382: PPUSH
10383: CALL_OW 297
10387: PUSH
10388: LD_INT 8
10390: LESS
10391: IFFALSE 10405
// SetTag ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 109
// end else
10405: GO 10756
// if GetTag ( i ) = 1 then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 110
10416: PUSH
10417: LD_INT 1
10419: EQUAL
10420: IFFALSE 10512
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
10422: LD_VAR 0 1
10426: PPUSH
10427: LD_VAR 0 11
10431: PUSH
10432: LD_INT 2
10434: ARRAY
10435: PUSH
10436: LD_INT 1
10438: ARRAY
10439: PPUSH
10440: LD_VAR 0 11
10444: PUSH
10445: LD_INT 2
10447: ARRAY
10448: PUSH
10449: LD_INT 2
10451: ARRAY
10452: PPUSH
10453: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
10457: LD_VAR 0 1
10461: PPUSH
10462: LD_VAR 0 11
10466: PUSH
10467: LD_INT 2
10469: ARRAY
10470: PUSH
10471: LD_INT 1
10473: ARRAY
10474: PPUSH
10475: LD_VAR 0 11
10479: PUSH
10480: LD_INT 2
10482: ARRAY
10483: PUSH
10484: LD_INT 2
10486: ARRAY
10487: PPUSH
10488: CALL_OW 297
10492: PUSH
10493: LD_INT 8
10495: LESS
10496: IFFALSE 10510
// SetTag ( i , 2 ) ;
10498: LD_VAR 0 1
10502: PPUSH
10503: LD_INT 2
10505: PPUSH
10506: CALL_OW 109
// end else
10510: GO 10756
// if GetTag ( i ) = 2 then
10512: LD_VAR 0 1
10516: PPUSH
10517: CALL_OW 110
10521: PUSH
10522: LD_INT 2
10524: EQUAL
10525: IFFALSE 10617
// begin ComAgressiveMove ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) ;
10527: LD_VAR 0 1
10531: PPUSH
10532: LD_VAR 0 11
10536: PUSH
10537: LD_INT 3
10539: ARRAY
10540: PUSH
10541: LD_INT 1
10543: ARRAY
10544: PPUSH
10545: LD_VAR 0 11
10549: PUSH
10550: LD_INT 3
10552: ARRAY
10553: PUSH
10554: LD_INT 2
10556: ARRAY
10557: PPUSH
10558: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) < 8 then
10562: LD_VAR 0 1
10566: PPUSH
10567: LD_VAR 0 11
10571: PUSH
10572: LD_INT 3
10574: ARRAY
10575: PUSH
10576: LD_INT 1
10578: ARRAY
10579: PPUSH
10580: LD_VAR 0 11
10584: PUSH
10585: LD_INT 3
10587: ARRAY
10588: PUSH
10589: LD_INT 2
10591: ARRAY
10592: PPUSH
10593: CALL_OW 297
10597: PUSH
10598: LD_INT 8
10600: LESS
10601: IFFALSE 10615
// SetTag ( i , 3 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_INT 3
10610: PPUSH
10611: CALL_OW 109
// end else
10615: GO 10756
// if GetTag ( i ) = 3 then
10617: LD_VAR 0 1
10621: PPUSH
10622: CALL_OW 110
10626: PUSH
10627: LD_INT 3
10629: EQUAL
10630: IFFALSE 10722
// begin ComAgressiveMove ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) ;
10632: LD_VAR 0 1
10636: PPUSH
10637: LD_VAR 0 11
10641: PUSH
10642: LD_INT 4
10644: ARRAY
10645: PUSH
10646: LD_INT 1
10648: ARRAY
10649: PPUSH
10650: LD_VAR 0 11
10654: PUSH
10655: LD_INT 4
10657: ARRAY
10658: PUSH
10659: LD_INT 2
10661: ARRAY
10662: PPUSH
10663: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) < 8 then
10667: LD_VAR 0 1
10671: PPUSH
10672: LD_VAR 0 11
10676: PUSH
10677: LD_INT 4
10679: ARRAY
10680: PUSH
10681: LD_INT 1
10683: ARRAY
10684: PPUSH
10685: LD_VAR 0 11
10689: PUSH
10690: LD_INT 4
10692: ARRAY
10693: PUSH
10694: LD_INT 2
10696: ARRAY
10697: PPUSH
10698: CALL_OW 297
10702: PUSH
10703: LD_INT 8
10705: LESS
10706: IFFALSE 10720
// SetTag ( i , 4 ) ;
10708: LD_VAR 0 1
10712: PPUSH
10713: LD_INT 4
10715: PPUSH
10716: CALL_OW 109
// end else
10720: GO 10756
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10722: LD_VAR 0 1
10726: PPUSH
10727: LD_INT 81
10729: PUSH
10730: LD_INT 3
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PPUSH
10737: CALL_OW 69
10741: PPUSH
10742: LD_VAR 0 1
10746: PPUSH
10747: CALL_OW 74
10751: PPUSH
10752: CALL_OW 115
// end ; end ;
10756: GO 10263
10758: POP
10759: POP
// until not attackers ;
10760: LD_VAR 0 10
10764: NOT
10765: IFFALSE 10246
// end ;
10767: PPOPN 12
10769: END
// every 0 0$1 do var i , tmp ;
10770: GO 10772
10772: DISABLE
10773: LD_INT 0
10775: PPUSH
10776: PPUSH
// begin enable ;
10777: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
10778: LD_ADDR_VAR 0 2
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: LD_INT 22
10788: PUSH
10789: LD_INT 1
10791: PUSH
10792: EMPTY
10793: LIST
10794: LIST
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 32
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 69
10818: ST_TO_ADDR
// if tmp then
10819: LD_VAR 0 2
10823: IFFALSE 10869
// for i in tmp do
10825: LD_ADDR_VAR 0 1
10829: PUSH
10830: LD_VAR 0 2
10834: PUSH
10835: FOR_IN
10836: IFFALSE 10867
// if GetFuel ( i ) < 3 then
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 261
10847: PUSH
10848: LD_INT 3
10850: LESS
10851: IFFALSE 10865
// SetFuel ( i , 3 ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: LD_INT 3
10860: PPUSH
10861: CALL_OW 240
10865: GO 10835
10867: POP
10868: POP
// end ;
10869: PPOPN 2
10871: END
// every 0 0$1 trigger ( FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) and not JMMArrival ) or ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) and not FirstAssaultRepelled ) do
10872: LD_INT 3
10874: PPUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 1
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PPUSH
10885: CALL_OW 70
10889: PUSH
10890: LD_EXP 41
10894: NOT
10895: AND
10896: PUSH
10897: LD_INT 10
10899: PPUSH
10900: LD_INT 22
10902: PUSH
10903: LD_INT 1
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PPUSH
10910: CALL_OW 70
10914: PUSH
10915: LD_EXP 4
10919: NOT
10920: AND
10921: OR
10922: IFFALSE 10931
10924: GO 10926
10926: DISABLE
// Antirush ;
10927: CALL 10932 0 0
10931: END
// export function Antirush ; var i , veh , tmp , num ; begin
10932: LD_INT 0
10934: PPUSH
10935: PPUSH
10936: PPUSH
10937: PPUSH
10938: PPUSH
// tmp := [ ] ;
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: EMPTY
10945: ST_TO_ADDR
// if not FirstAssaultRepelled then
10946: LD_EXP 4
10950: NOT
10951: IFFALSE 10963
// num := 12 else
10953: LD_ADDR_VAR 0 5
10957: PUSH
10958: LD_INT 12
10960: ST_TO_ADDR
10961: GO 10971
// num := 10 ;
10963: LD_ADDR_VAR 0 5
10967: PUSH
10968: LD_INT 10
10970: ST_TO_ADDR
// num := num - [ 4 , 2 , 0 ] [ Difficulty ] ;
10971: LD_ADDR_VAR 0 5
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: LD_INT 4
10983: PUSH
10984: LD_INT 2
10986: PUSH
10987: LD_INT 0
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_OWVAR 67
10999: ARRAY
11000: MINUS
11001: ST_TO_ADDR
// for i := 1 to num do
11002: LD_ADDR_VAR 0 2
11006: PUSH
11007: DOUBLE
11008: LD_INT 1
11010: DEC
11011: ST_TO_ADDR
11012: LD_VAR 0 5
11016: PUSH
11017: FOR_TO
11018: IFFALSE 11157
// begin uc_side := 3 ;
11020: LD_ADDR_OWVAR 20
11024: PUSH
11025: LD_INT 3
11027: ST_TO_ADDR
// uc_nation := 3 ;
11028: LD_ADDR_OWVAR 21
11032: PUSH
11033: LD_INT 3
11035: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
11036: LD_INT 23
11038: PPUSH
11039: LD_INT 3
11041: PPUSH
11042: LD_INT 3
11044: PPUSH
11045: LD_INT 46
11047: PUSH
11048: LD_INT 43
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: PUSH
11055: LD_INT 1
11057: PPUSH
11058: LD_INT 2
11060: PPUSH
11061: CALL_OW 12
11065: ARRAY
11066: PPUSH
11067: LD_INT 100
11069: PPUSH
11070: CALL 18426 0 5
// veh := CreateVehicle ;
11074: LD_ADDR_VAR 0 3
11078: PUSH
11079: CALL_OW 45
11083: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
11084: LD_VAR 0 3
11088: PPUSH
11089: LD_INT 5
11091: PPUSH
11092: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
11096: LD_VAR 0 3
11100: PPUSH
11101: LD_INT 199
11103: PPUSH
11104: LD_INT 135
11106: PPUSH
11107: LD_INT 3
11109: PPUSH
11110: LD_INT 0
11112: PPUSH
11113: CALL_OW 50
// tmp := tmp ^ veh ;
11117: LD_ADDR_VAR 0 4
11121: PUSH
11122: LD_VAR 0 4
11126: PUSH
11127: LD_VAR 0 3
11131: ADD
11132: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
11133: LD_VAR 0 3
11137: PPUSH
11138: LD_INT 173
11140: PPUSH
11141: LD_INT 118
11143: PPUSH
11144: CALL_OW 111
// wait ( 0 0$2 ) ;
11148: LD_INT 70
11150: PPUSH
11151: CALL_OW 67
// end ;
11155: GO 11017
11157: POP
11158: POP
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// for i in tmp do
11166: LD_ADDR_VAR 0 2
11170: PUSH
11171: LD_VAR 0 4
11175: PUSH
11176: FOR_IN
11177: IFFALSE 11244
// if IsDead ( i ) then
11179: LD_VAR 0 2
11183: PPUSH
11184: CALL_OW 301
11188: IFFALSE 11208
// tmp := tmp diff i else
11190: LD_ADDR_VAR 0 4
11194: PUSH
11195: LD_VAR 0 4
11199: PUSH
11200: LD_VAR 0 2
11204: DIFF
11205: ST_TO_ADDR
11206: GO 11242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 22
11215: PUSH
11216: LD_INT 1
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PPUSH
11223: CALL_OW 69
11227: PPUSH
11228: LD_VAR 0 2
11232: PPUSH
11233: CALL_OW 74
11237: PPUSH
11238: CALL_OW 115
11242: GO 11176
11244: POP
11245: POP
// until not tmp ;
11246: LD_VAR 0 4
11250: NOT
11251: IFFALSE 11159
// end ; end_of_file
11253: LD_VAR 0 1
11257: RET
// export Losses ; on UnitDestroyed ( un ) do begin if un = Brighton then
11258: LD_VAR 0 1
11262: PUSH
11263: LD_EXP 9
11267: EQUAL
11268: IFFALSE 11284
// begin wait ( 0 0$1 ) ;
11270: LD_INT 35
11272: PPUSH
11273: CALL_OW 67
// YouLost ( Brighton ) ;
11277: LD_STRING Brighton
11279: PPUSH
11280: CALL_OW 104
// end ; if un = JMM then
11284: LD_VAR 0 1
11288: PUSH
11289: LD_EXP 37
11293: EQUAL
11294: IFFALSE 11310
// begin wait ( 0 0$1 ) ;
11296: LD_INT 35
11298: PPUSH
11299: CALL_OW 67
// YouLost ( JMM ) ;
11303: LD_STRING JMM
11305: PPUSH
11306: CALL_OW 104
// end ; if un = Megan then
11310: LD_VAR 0 1
11314: PUSH
11315: LD_EXP 11
11319: EQUAL
11320: IFFALSE 11334
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
11322: LD_EXP 9
11326: PPUSH
11327: LD_STRING DBrighton-MeganDeath
11329: PPUSH
11330: CALL_OW 88
// end ; if un = Palmer then
11334: LD_VAR 0 1
11338: PUSH
11339: LD_EXP 10
11343: EQUAL
11344: IFFALSE 11358
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
11346: LD_EXP 9
11350: PPUSH
11351: LD_STRING DBrighton-PalmerDeath
11353: PPUSH
11354: CALL_OW 88
// end ; if un = Burlak then
11358: LD_VAR 0 1
11362: PUSH
11363: LD_EXP 19
11367: EQUAL
11368: IFFALSE 11400
// begin if JMM_Arrived then
11370: LD_EXP 6
11374: IFFALSE 11388
// Say ( JMM , DJMM-BurlakDead ) ;
11376: LD_EXP 37
11380: PPUSH
11381: LD_STRING DJMM-BurlakDead
11383: PPUSH
11384: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
11388: LD_EXP 10
11392: PPUSH
11393: LD_STRING DSol-BurlakDead
11395: PPUSH
11396: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
11400: LD_VAR 0 1
11404: PUSH
11405: LD_INT 1
11407: EQUAL
11408: PUSH
11409: LD_VAR 0 1
11413: PUSH
11414: LD_INT 3
11416: EQUAL
11417: OR
11418: IFFALSE 11434
// begin wait ( 0 0$1 ) ;
11420: LD_INT 35
11422: PPUSH
11423: CALL_OW 67
// YouLost ( Depot ) ;
11427: LD_STRING Depot
11429: PPUSH
11430: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
11434: LD_VAR 0 1
11438: PPUSH
11439: CALL_OW 255
11443: PUSH
11444: LD_INT 1
11446: EQUAL
11447: PUSH
11448: LD_VAR 0 1
11452: PPUSH
11453: CALL_OW 247
11457: PUSH
11458: LD_INT 1
11460: EQUAL
11461: AND
11462: IFFALSE 11478
// Losses := Losses + 1 ;
11464: LD_ADDR_EXP 45
11468: PUSH
11469: LD_EXP 45
11473: PUSH
11474: LD_INT 1
11476: PLUS
11477: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11478: LD_VAR 0 1
11482: PPUSH
11483: CALL 78725 0 1
// end ;
11487: PPOPN 1
11489: END
// on UnitGoesToRed ( un ) do begin if GetType ( un ) = unit_vehicle and un in RUArmada then
11490: LD_VAR 0 1
11494: PPUSH
11495: CALL_OW 247
11499: PUSH
11500: LD_INT 2
11502: EQUAL
11503: PUSH
11504: LD_VAR 0 1
11508: PUSH
11509: LD_EXP 17
11513: IN
11514: AND
11515: IFFALSE 11529
// SetLives ( un , 0 ) ;
11517: LD_VAR 0 1
11521: PPUSH
11522: LD_INT 0
11524: PPUSH
11525: CALL_OW 234
// if un = Yashin then
11529: LD_VAR 0 1
11533: PUSH
11534: LD_EXP 13
11538: EQUAL
11539: IFFALSE 11553
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
11541: LD_EXP 13
11545: PPUSH
11546: LD_STRING DDeath-Yas-3
11548: PPUSH
11549: CALL_OW 91
// if un = Popov then
11553: LD_VAR 0 1
11557: PUSH
11558: LD_EXP 14
11562: EQUAL
11563: IFFALSE 11577
// ForceSay ( Popov , DDeath-Pop-3 ) ;
11565: LD_EXP 14
11569: PPUSH
11570: LD_STRING DDeath-Pop-3
11572: PPUSH
11573: CALL_OW 91
// if un = Gaydar then
11577: LD_VAR 0 1
11581: PUSH
11582: LD_EXP 15
11586: EQUAL
11587: IFFALSE 11601
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
11589: LD_EXP 15
11593: PPUSH
11594: LD_STRING DDeath-Gay-3
11596: PPUSH
11597: CALL_OW 91
// if un = Sevi then
11601: LD_VAR 0 1
11605: PUSH
11606: LD_EXP 16
11610: EQUAL
11611: IFFALSE 11625
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
11613: LD_EXP 16
11617: PPUSH
11618: LD_STRING DDeath-Vse-3
11620: PPUSH
11621: CALL_OW 91
// end ;
11625: PPOPN 1
11627: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
11628: LD_VAR 0 1
11632: PUSH
11633: LD_INT 10
11635: EQUAL
11636: IFFALSE 11674
// begin Say ( Brighton , DBrighton-C1 ) ;
11638: LD_EXP 9
11642: PPUSH
11643: LD_STRING DBrighton-C1
11645: PPUSH
11646: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
11650: LD_EXP 11
11654: PPUSH
11655: LD_STRING DMegan-C1
11657: PPUSH
11658: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
11662: LD_EXP 9
11666: PPUSH
11667: LD_STRING DBrighton-C2
11669: PPUSH
11670: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
11674: LD_VAR 0 1
11678: PPUSH
11679: LD_VAR 0 2
11683: PPUSH
11684: CALL 78421 0 2
// end ;
11688: PPOPN 2
11690: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11691: LD_VAR 0 1
11695: PPUSH
11696: LD_VAR 0 2
11700: PPUSH
11701: CALL 81059 0 2
// end ;
11705: PPOPN 2
11707: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11708: LD_VAR 0 1
11712: PPUSH
11713: CALL 80127 0 1
// end ;
11717: PPOPN 1
11719: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
11720: LD_VAR 0 1
11724: PPUSH
11725: CALL_OW 266
11729: PUSH
11730: LD_INT 0
11732: EQUAL
11733: PUSH
11734: LD_VAR 0 1
11738: PPUSH
11739: CALL_OW 255
11743: PUSH
11744: LD_INT 3
11746: EQUAL
11747: AND
11748: IFFALSE 11810
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
11750: LD_VAR 0 1
11754: PPUSH
11755: CALL_OW 274
11759: PPUSH
11760: LD_INT 1
11762: PPUSH
11763: LD_INT 10000
11765: PPUSH
11766: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
11770: LD_VAR 0 1
11774: PPUSH
11775: CALL_OW 274
11779: PPUSH
11780: LD_INT 2
11782: PPUSH
11783: LD_INT 250
11785: PPUSH
11786: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
11790: LD_VAR 0 1
11794: PPUSH
11795: CALL_OW 274
11799: PPUSH
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 100
11805: PPUSH
11806: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
11810: LD_VAR 0 1
11814: PPUSH
11815: CALL 80368 0 1
// end ;
11819: PPOPN 1
11821: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11822: LD_VAR 0 1
11826: PPUSH
11827: LD_VAR 0 2
11831: PPUSH
11832: LD_VAR 0 3
11836: PPUSH
11837: LD_VAR 0 4
11841: PPUSH
11842: LD_VAR 0 5
11846: PPUSH
11847: CALL 78041 0 5
// end ;
11851: PPOPN 5
11853: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11854: LD_VAR 0 1
11858: PPUSH
11859: LD_VAR 0 2
11863: PPUSH
11864: CALL 77631 0 2
// end ;
11868: PPOPN 2
11870: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11871: LD_VAR 0 1
11875: PPUSH
11876: LD_VAR 0 2
11880: PPUSH
11881: LD_VAR 0 3
11885: PPUSH
11886: LD_VAR 0 4
11890: PPUSH
11891: CALL 77469 0 4
// end ;
11895: PPOPN 4
11897: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11898: LD_VAR 0 1
11902: PPUSH
11903: LD_VAR 0 2
11907: PPUSH
11908: LD_VAR 0 3
11912: PPUSH
11913: CALL 77244 0 3
// end ;
11917: PPOPN 3
11919: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11920: LD_VAR 0 1
11924: PPUSH
11925: LD_VAR 0 2
11929: PPUSH
11930: CALL 77129 0 2
// end ;
11934: PPOPN 2
11936: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11937: LD_VAR 0 1
11941: PPUSH
11942: LD_VAR 0 2
11946: PPUSH
11947: CALL 81320 0 2
// end ;
11951: PPOPN 2
11953: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
11954: LD_VAR 0 1
11958: PPUSH
11959: CALL_OW 255
11963: PUSH
11964: LD_INT 6
11966: EQUAL
11967: IFFALSE 12097
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
11969: LD_VAR 0 1
11973: PUSH
11974: LD_EXP 13
11978: PUSH
11979: LD_EXP 16
11983: PUSH
11984: LD_EXP 15
11988: PUSH
11989: LD_EXP 14
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: IN
12000: IFFALSE 12004
// exit ;
12002: GO 12121
// if AssaultStarted then
12004: LD_EXP 8
12008: IFFALSE 12082
// case Rand ( 1 , 4 ) of 1 .. 3 :
12010: LD_INT 1
12012: PPUSH
12013: LD_INT 4
12015: PPUSH
12016: CALL_OW 12
12020: PUSH
12021: LD_INT 1
12023: DOUBLE
12024: GREATEREQUAL
12025: IFFALSE 12033
12027: LD_INT 3
12029: DOUBLE
12030: LESSEQUAL
12031: IFTRUE 12035
12033: GO 12053
12035: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
12036: LD_VAR 0 1
12040: PPUSH
12041: LD_INT 67
12043: PPUSH
12044: LD_INT 37
12046: PPUSH
12047: CALL_OW 114
12051: GO 12080
12053: LD_INT 4
12055: DOUBLE
12056: EQUAL
12057: IFTRUE 12061
12059: GO 12079
12061: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
12062: LD_VAR 0 1
12066: PPUSH
12067: LD_INT 120
12069: PPUSH
12070: LD_INT 131
12072: PPUSH
12073: CALL_OW 111
12077: GO 12080
12079: POP
12080: GO 12097
// ComMoveXY ( driver , 120 , 131 ) ;
12082: LD_VAR 0 1
12086: PPUSH
12087: LD_INT 120
12089: PPUSH
12090: LD_INT 131
12092: PPUSH
12093: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12097: LD_VAR 0 1
12101: PPUSH
12102: LD_VAR 0 2
12106: PPUSH
12107: LD_VAR 0 3
12111: PPUSH
12112: LD_VAR 0 4
12116: PPUSH
12117: CALL 81536 0 4
// end ;
12121: PPOPN 4
12123: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12124: LD_VAR 0 1
12128: PPUSH
12129: LD_VAR 0 2
12133: PPUSH
12134: CALL 76938 0 2
// end ;
12138: PPOPN 2
12140: END
// on Command ( cmd ) do var i ;
12141: LD_INT 0
12143: PPUSH
// begin if cmd = 77 and southAreaBlocker then
12144: LD_VAR 0 1
12148: PUSH
12149: LD_INT 77
12151: EQUAL
12152: PUSH
12153: LD_EXP 2
12157: AND
12158: IFFALSE 12234
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12160: LD_ADDR_VAR 0 2
12164: PUSH
12165: LD_INT 22
12167: PUSH
12168: LD_INT 1
12170: PUSH
12171: EMPTY
12172: LIST
12173: LIST
12174: PUSH
12175: LD_INT 2
12177: PUSH
12178: LD_INT 21
12180: PUSH
12181: LD_INT 1
12183: PUSH
12184: EMPTY
12185: LIST
12186: LIST
12187: PUSH
12188: LD_INT 21
12190: PUSH
12191: LD_INT 2
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: LIST
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PPUSH
12207: CALL_OW 69
12211: PUSH
12212: FOR_IN
12213: IFFALSE 12232
// NotGoToAreaUnit ( i , SouthAreaBlock , SouthAreaGoAway ) ;
12215: LD_VAR 0 2
12219: PPUSH
12220: LD_INT 20
12222: PPUSH
12223: LD_INT 19
12225: PPUSH
12226: CALL 50578 0 3
12230: GO 12212
12232: POP
12233: POP
// end ; SOS_Command ( cmd ) ;
12234: LD_VAR 0 1
12238: PPUSH
12239: CALL 94955 0 1
// end ;
12243: PPOPN 2
12245: END
// every 0 0$1 trigger southAreaBlocker and FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do var i ;
12246: LD_EXP 2
12250: PUSH
12251: LD_INT 16
12253: PPUSH
12254: LD_INT 22
12256: PUSH
12257: LD_INT 1
12259: PUSH
12260: EMPTY
12261: LIST
12262: LIST
12263: PUSH
12264: LD_INT 2
12266: PUSH
12267: LD_INT 21
12269: PUSH
12270: LD_INT 1
12272: PUSH
12273: EMPTY
12274: LIST
12275: LIST
12276: PUSH
12277: LD_INT 21
12279: PUSH
12280: LD_INT 2
12282: PUSH
12283: EMPTY
12284: LIST
12285: LIST
12286: PUSH
12287: EMPTY
12288: LIST
12289: LIST
12290: LIST
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PPUSH
12296: CALL_OW 70
12300: AND
12301: IFFALSE 12387
12303: GO 12305
12305: DISABLE
12306: LD_INT 0
12308: PPUSH
// begin enable ;
12309: ENABLE
// for i in FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12310: LD_ADDR_VAR 0 1
12314: PUSH
12315: LD_INT 16
12317: PPUSH
12318: LD_INT 22
12320: PUSH
12321: LD_INT 1
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PUSH
12328: LD_INT 2
12330: PUSH
12331: LD_INT 21
12333: PUSH
12334: LD_INT 1
12336: PUSH
12337: EMPTY
12338: LIST
12339: LIST
12340: PUSH
12341: LD_INT 21
12343: PUSH
12344: LD_INT 2
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: PUSH
12351: EMPTY
12352: LIST
12353: LIST
12354: LIST
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PPUSH
12360: CALL_OW 70
12364: PUSH
12365: FOR_IN
12366: IFFALSE 12385
// NotGoToAreaUnit ( i , SouthAreaOutside , SouthAreaGoAway ) ;
12368: LD_VAR 0 1
12372: PPUSH
12373: LD_INT 18
12375: PPUSH
12376: LD_INT 19
12378: PPUSH
12379: CALL 50578 0 3
12383: GO 12365
12385: POP
12386: POP
// end ; end_of_file
12387: PPOPN 1
12389: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
12390: LD_EXP 6
12394: PUSH
12395: LD_EXP 44
12399: AND
12400: IFFALSE 12571
12402: GO 12404
12404: DISABLE
// begin wait ( 0 0$2 ) ;
12405: LD_INT 70
12407: PPUSH
12408: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
12412: LD_EXP 9
12416: PPUSH
12417: LD_STRING DBrighton-G1
12419: PPUSH
12420: CALL_OW 88
// if Losses < 1 then
12424: LD_EXP 45
12428: PUSH
12429: LD_INT 1
12431: LESS
12432: IFFALSE 12446
// AddMedal ( Losses , 1 ) else
12434: LD_STRING Losses
12436: PPUSH
12437: LD_INT 1
12439: PPUSH
12440: CALL_OW 101
12444: GO 12479
// if Losses < 5 then
12446: LD_EXP 45
12450: PUSH
12451: LD_INT 5
12453: LESS
12454: IFFALSE 12468
// AddMedal ( Losses , 2 ) else
12456: LD_STRING Losses
12458: PPUSH
12459: LD_INT 2
12461: PPUSH
12462: CALL_OW 101
12466: GO 12479
// AddMedal ( Losses , - 1 ) ;
12468: LD_STRING Losses
12470: PPUSH
12471: LD_INT 1
12473: NEG
12474: PPUSH
12475: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12479: LD_EXP 7
12483: PUSH
12484: LD_INT 10
12486: PPUSH
12487: LD_INT 1
12489: PPUSH
12490: CALL_OW 321
12494: PUSH
12495: LD_INT 2
12497: EQUAL
12498: AND
12499: IFFALSE 12513
// AddMedal ( Laser , 1 ) else
12501: LD_STRING Laser
12503: PPUSH
12504: LD_INT 1
12506: PPUSH
12507: CALL_OW 101
12511: GO 12560
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12513: LD_EXP 7
12517: NOT
12518: PUSH
12519: LD_INT 10
12521: PPUSH
12522: LD_INT 1
12524: PPUSH
12525: CALL_OW 321
12529: PUSH
12530: LD_INT 2
12532: EQUAL
12533: AND
12534: IFFALSE 12549
// AddMedal ( Laser , - 1 ) else
12536: LD_STRING Laser
12538: PPUSH
12539: LD_INT 1
12541: NEG
12542: PPUSH
12543: CALL_OW 101
12547: GO 12560
// AddMedal ( Laser , - 2 ) ;
12549: LD_STRING Laser
12551: PPUSH
12552: LD_INT 2
12554: NEG
12555: PPUSH
12556: CALL_OW 101
// GiveMedals ( BaseMain ) ;
12560: LD_STRING BaseMain
12562: PPUSH
12563: CALL_OW 102
// YouWin ;
12567: CALL_OW 103
// end ; end_of_file
12571: END
// export rows ; export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
12572: LD_INT 0
12574: PPUSH
12575: PPUSH
// area = ListEnvironmentArea ( area ) ;
12576: LD_ADDR_VAR 0 2
12580: PUSH
12581: LD_VAR 0 2
12585: PPUSH
12586: CALL_OW 353
12590: ST_TO_ADDR
// if bulldozer > 0 then
12591: LD_VAR 0 1
12595: PUSH
12596: LD_INT 0
12598: GREATER
12599: IFFALSE 12710
// for i = area downto 1 do
12601: LD_ADDR_VAR 0 4
12605: PUSH
12606: DOUBLE
12607: LD_VAR 0 2
12611: INC
12612: ST_TO_ADDR
12613: LD_INT 1
12615: PUSH
12616: FOR_DOWNTO
12617: IFFALSE 12708
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
12619: LD_VAR 0 2
12623: PUSH
12624: LD_VAR 0 4
12628: ARRAY
12629: PUSH
12630: LD_INT 1
12632: ARRAY
12633: PPUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_VAR 0 4
12643: ARRAY
12644: PUSH
12645: LD_INT 2
12647: ARRAY
12648: PPUSH
12649: CALL_OW 351
12653: IFFALSE 12706
// if not HasTask ( bulldozer ) then
12655: LD_VAR 0 1
12659: PPUSH
12660: CALL_OW 314
12664: NOT
12665: IFFALSE 12706
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
12667: LD_VAR 0 1
12671: PPUSH
12672: LD_VAR 0 2
12676: PUSH
12677: LD_VAR 0 4
12681: ARRAY
12682: PUSH
12683: LD_INT 1
12685: ARRAY
12686: PPUSH
12687: LD_VAR 0 2
12691: PUSH
12692: LD_VAR 0 4
12696: ARRAY
12697: PUSH
12698: LD_INT 2
12700: ARRAY
12701: PPUSH
12702: CALL_OW 171
12706: GO 12616
12708: POP
12709: POP
// end ;
12710: LD_VAR 0 3
12714: RET
// export function ComMeeting ( team , area ) ; var i , x , tmp , offset , sold_team , civil_team ; begin
12715: LD_INT 0
12717: PPUSH
12718: PPUSH
12719: PPUSH
12720: PPUSH
12721: PPUSH
12722: PPUSH
12723: PPUSH
// sold_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , class_soldier ] ] ) ;
12724: LD_ADDR_VAR 0 8
12728: PUSH
12729: LD_VAR 0 1
12733: PPUSH
12734: LD_INT 22
12736: PUSH
12737: LD_INT 1
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: PUSH
12744: LD_INT 21
12746: PUSH
12747: LD_INT 1
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 25
12756: PUSH
12757: LD_INT 1
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: LIST
12768: PPUSH
12769: CALL_OW 72
12773: ST_TO_ADDR
// civil_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , class_soldier ] ] ] ) ;
12774: LD_ADDR_VAR 0 9
12778: PUSH
12779: LD_VAR 0 1
12783: PPUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 1
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 21
12796: PUSH
12797: LD_INT 1
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 3
12806: PUSH
12807: LD_INT 25
12809: PUSH
12810: LD_INT 1
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: LIST
12825: PPUSH
12826: CALL_OW 72
12830: ST_TO_ADDR
// rows = MakeRows ( sold_team , civil_team ) ;
12831: LD_ADDR_EXP 47
12835: PUSH
12836: LD_VAR 0 8
12840: PPUSH
12841: LD_VAR 0 9
12845: PPUSH
12846: CALL 13239 0 2
12850: ST_TO_ADDR
// offset = 0 ;
12851: LD_ADDR_VAR 0 7
12855: PUSH
12856: LD_INT 0
12858: ST_TO_ADDR
// for i := 1 to sold_team do
12859: LD_ADDR_VAR 0 4
12863: PUSH
12864: DOUBLE
12865: LD_INT 1
12867: DEC
12868: ST_TO_ADDR
12869: LD_VAR 0 8
12873: PUSH
12874: FOR_TO
12875: IFFALSE 13006
// begin if IsInUnit ( sold_team [ i ] ) then
12877: LD_VAR 0 8
12881: PUSH
12882: LD_VAR 0 4
12886: ARRAY
12887: PPUSH
12888: CALL_OW 310
12892: IFFALSE 12909
// ComExitBuilding ( sold_team [ i ] ) ;
12894: LD_VAR 0 8
12898: PUSH
12899: LD_VAR 0 4
12903: ARRAY
12904: PPUSH
12905: CALL_OW 122
// AddComMoveXY ( sold_team [ i ] , rows [ 1 ] [ i + offset ] , rows [ 1 ] [ i + 1 + offset ] ) ;
12909: LD_VAR 0 8
12913: PUSH
12914: LD_VAR 0 4
12918: ARRAY
12919: PPUSH
12920: LD_EXP 47
12924: PUSH
12925: LD_INT 1
12927: ARRAY
12928: PUSH
12929: LD_VAR 0 4
12933: PUSH
12934: LD_VAR 0 7
12938: PLUS
12939: ARRAY
12940: PPUSH
12941: LD_EXP 47
12945: PUSH
12946: LD_INT 1
12948: ARRAY
12949: PUSH
12950: LD_VAR 0 4
12954: PUSH
12955: LD_INT 1
12957: PLUS
12958: PUSH
12959: LD_VAR 0 7
12963: PLUS
12964: ARRAY
12965: PPUSH
12966: CALL_OW 171
// AddComTurnUnit ( sold_team [ i ] , Brighton ) ;
12970: LD_VAR 0 8
12974: PUSH
12975: LD_VAR 0 4
12979: ARRAY
12980: PPUSH
12981: LD_EXP 9
12985: PPUSH
12986: CALL_OW 179
// offset = offset + 1 ;
12990: LD_ADDR_VAR 0 7
12994: PUSH
12995: LD_VAR 0 7
12999: PUSH
13000: LD_INT 1
13002: PLUS
13003: ST_TO_ADDR
// end ;
13004: GO 12874
13006: POP
13007: POP
// offset = 0 ;
13008: LD_ADDR_VAR 0 7
13012: PUSH
13013: LD_INT 0
13015: ST_TO_ADDR
// tmp = 1 ;
13016: LD_ADDR_VAR 0 6
13020: PUSH
13021: LD_INT 1
13023: ST_TO_ADDR
// for i := 2 to rows do
13024: LD_ADDR_VAR 0 4
13028: PUSH
13029: DOUBLE
13030: LD_INT 2
13032: DEC
13033: ST_TO_ADDR
13034: LD_EXP 47
13038: PUSH
13039: FOR_TO
13040: IFFALSE 13232
// begin for x := 1 to sold_team do
13042: LD_ADDR_VAR 0 5
13046: PUSH
13047: DOUBLE
13048: LD_INT 1
13050: DEC
13051: ST_TO_ADDR
13052: LD_VAR 0 8
13056: PUSH
13057: FOR_TO
13058: IFFALSE 13220
// begin if IsInUnit ( civil_team [ tmp ] ) then
13060: LD_VAR 0 9
13064: PUSH
13065: LD_VAR 0 6
13069: ARRAY
13070: PPUSH
13071: CALL_OW 310
13075: IFFALSE 13092
// ComExitBuilding ( civil_team [ tmp ] ) ;
13077: LD_VAR 0 9
13081: PUSH
13082: LD_VAR 0 6
13086: ARRAY
13087: PPUSH
13088: CALL_OW 122
// AddComMoveXY ( civil_team [ tmp ] , rows [ i ] [ x + offset ] , rows [ i ] [ x + 1 + offset ] ) ;
13092: LD_VAR 0 9
13096: PUSH
13097: LD_VAR 0 6
13101: ARRAY
13102: PPUSH
13103: LD_EXP 47
13107: PUSH
13108: LD_VAR 0 4
13112: ARRAY
13113: PUSH
13114: LD_VAR 0 5
13118: PUSH
13119: LD_VAR 0 7
13123: PLUS
13124: ARRAY
13125: PPUSH
13126: LD_EXP 47
13130: PUSH
13131: LD_VAR 0 4
13135: ARRAY
13136: PUSH
13137: LD_VAR 0 5
13141: PUSH
13142: LD_INT 1
13144: PLUS
13145: PUSH
13146: LD_VAR 0 7
13150: PLUS
13151: ARRAY
13152: PPUSH
13153: CALL_OW 171
// AddComTurnUnit ( civil_team [ tmp ] , Brighton ) ;
13157: LD_VAR 0 9
13161: PUSH
13162: LD_VAR 0 6
13166: ARRAY
13167: PPUSH
13168: LD_EXP 9
13172: PPUSH
13173: CALL_OW 179
// offset = offset + 1 ;
13177: LD_ADDR_VAR 0 7
13181: PUSH
13182: LD_VAR 0 7
13186: PUSH
13187: LD_INT 1
13189: PLUS
13190: ST_TO_ADDR
// if not ( tmp = civil_team ) then
13191: LD_VAR 0 6
13195: PUSH
13196: LD_VAR 0 9
13200: EQUAL
13201: NOT
13202: IFFALSE 13218
// tmp = tmp + 1 ;
13204: LD_ADDR_VAR 0 6
13208: PUSH
13209: LD_VAR 0 6
13213: PUSH
13214: LD_INT 1
13216: PLUS
13217: ST_TO_ADDR
// end ;
13218: GO 13057
13220: POP
13221: POP
// offset = 0 ;
13222: LD_ADDR_VAR 0 7
13226: PUSH
13227: LD_INT 0
13229: ST_TO_ADDR
// end ;
13230: GO 13039
13232: POP
13233: POP
// end ;
13234: LD_VAR 0 3
13238: RET
// export function MakeRows ( sold_team , civil_team ) ; var i , x , start_pos , row_size , new_row , result_rows , civil_rows , offsetX , offsetY ; begin
13239: LD_INT 0
13241: PPUSH
13242: PPUSH
13243: PPUSH
13244: PPUSH
13245: PPUSH
13246: PPUSH
13247: PPUSH
13248: PPUSH
13249: PPUSH
13250: PPUSH
// start_pos = [ 65 , 34 ] ;
13251: LD_ADDR_VAR 0 6
13255: PUSH
13256: LD_INT 65
13258: PUSH
13259: LD_INT 34
13261: PUSH
13262: EMPTY
13263: LIST
13264: LIST
13265: ST_TO_ADDR
// row_size = 0 ;
13266: LD_ADDR_VAR 0 7
13270: PUSH
13271: LD_INT 0
13273: ST_TO_ADDR
// result_rows = [ ] ;
13274: LD_ADDR_VAR 0 9
13278: PUSH
13279: EMPTY
13280: ST_TO_ADDR
// new_row = [ ] ;
13281: LD_ADDR_VAR 0 8
13285: PUSH
13286: EMPTY
13287: ST_TO_ADDR
// for i := 1 to sold_team do
13288: LD_ADDR_VAR 0 4
13292: PUSH
13293: DOUBLE
13294: LD_INT 1
13296: DEC
13297: ST_TO_ADDR
13298: LD_VAR 0 1
13302: PUSH
13303: FOR_TO
13304: IFFALSE 13358
// begin new_row = new_row ^ start_pos [ 1 ] ^ start_pos [ 2 ] + i ;
13306: LD_ADDR_VAR 0 8
13310: PUSH
13311: LD_VAR 0 8
13315: PUSH
13316: LD_VAR 0 6
13320: PUSH
13321: LD_INT 1
13323: ARRAY
13324: ADD
13325: PUSH
13326: LD_VAR 0 6
13330: PUSH
13331: LD_INT 2
13333: ARRAY
13334: PUSH
13335: LD_VAR 0 4
13339: PLUS
13340: ADD
13341: ST_TO_ADDR
// row_size = row_size + 1 ;
13342: LD_ADDR_VAR 0 7
13346: PUSH
13347: LD_VAR 0 7
13351: PUSH
13352: LD_INT 1
13354: PLUS
13355: ST_TO_ADDR
// end ;
13356: GO 13303
13358: POP
13359: POP
// result_rows = result_rows ^ [ new_row ] ;
13360: LD_ADDR_VAR 0 9
13364: PUSH
13365: LD_VAR 0 9
13369: PUSH
13370: LD_VAR 0 8
13374: PUSH
13375: EMPTY
13376: LIST
13377: ADD
13378: ST_TO_ADDR
// civil_rows = civil_team div sold_team ;
13379: LD_ADDR_VAR 0 10
13383: PUSH
13384: LD_VAR 0 2
13388: PUSH
13389: LD_VAR 0 1
13393: DIV
13394: ST_TO_ADDR
// if ( civil_rows mod sold_team > 0 ) then
13395: LD_VAR 0 10
13399: PUSH
13400: LD_VAR 0 1
13404: MOD
13405: PUSH
13406: LD_INT 0
13408: GREATER
13409: IFFALSE 13425
// civil_rows = civil_rows + 1 ;
13411: LD_ADDR_VAR 0 10
13415: PUSH
13416: LD_VAR 0 10
13420: PUSH
13421: LD_INT 1
13423: PLUS
13424: ST_TO_ADDR
// offsetX = 2 ;
13425: LD_ADDR_VAR 0 11
13429: PUSH
13430: LD_INT 2
13432: ST_TO_ADDR
// offsetY = 1 ;
13433: LD_ADDR_VAR 0 12
13437: PUSH
13438: LD_INT 1
13440: ST_TO_ADDR
// for i := 1 to civil_rows do
13441: LD_ADDR_VAR 0 4
13445: PUSH
13446: DOUBLE
13447: LD_INT 1
13449: DEC
13450: ST_TO_ADDR
13451: LD_VAR 0 10
13455: PUSH
13456: FOR_TO
13457: IFFALSE 13585
// begin new_row = [ ] ;
13459: LD_ADDR_VAR 0 8
13463: PUSH
13464: EMPTY
13465: ST_TO_ADDR
// for x := 1 to row_size do
13466: LD_ADDR_VAR 0 5
13470: PUSH
13471: DOUBLE
13472: LD_INT 1
13474: DEC
13475: ST_TO_ADDR
13476: LD_VAR 0 7
13480: PUSH
13481: FOR_TO
13482: IFFALSE 13534
// begin new_row = new_row ^ start_pos [ 1 ] + offsetX ^ start_pos [ 2 ] + offsetY + x ;
13484: LD_ADDR_VAR 0 8
13488: PUSH
13489: LD_VAR 0 8
13493: PUSH
13494: LD_VAR 0 6
13498: PUSH
13499: LD_INT 1
13501: ARRAY
13502: PUSH
13503: LD_VAR 0 11
13507: PLUS
13508: ADD
13509: PUSH
13510: LD_VAR 0 6
13514: PUSH
13515: LD_INT 2
13517: ARRAY
13518: PUSH
13519: LD_VAR 0 12
13523: PLUS
13524: PUSH
13525: LD_VAR 0 5
13529: PLUS
13530: ADD
13531: ST_TO_ADDR
// end ;
13532: GO 13481
13534: POP
13535: POP
// result_rows = result_rows ^ [ new_row ] ;
13536: LD_ADDR_VAR 0 9
13540: PUSH
13541: LD_VAR 0 9
13545: PUSH
13546: LD_VAR 0 8
13550: PUSH
13551: EMPTY
13552: LIST
13553: ADD
13554: ST_TO_ADDR
// offsetX = offsetX + 2 ;
13555: LD_ADDR_VAR 0 11
13559: PUSH
13560: LD_VAR 0 11
13564: PUSH
13565: LD_INT 2
13567: PLUS
13568: ST_TO_ADDR
// offsetY = offsetY + 1 ;
13569: LD_ADDR_VAR 0 12
13573: PUSH
13574: LD_VAR 0 12
13578: PUSH
13579: LD_INT 1
13581: PLUS
13582: ST_TO_ADDR
// end ;
13583: GO 13456
13585: POP
13586: POP
// result = result_rows ;
13587: LD_ADDR_VAR 0 3
13591: PUSH
13592: LD_VAR 0 9
13596: ST_TO_ADDR
// end ; end_of_file
13597: LD_VAR 0 3
13601: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13602: LD_INT 0
13604: PPUSH
13605: PPUSH
// if exist_mode then
13606: LD_VAR 0 2
13610: IFFALSE 13635
// unit := CreateCharacter ( prefix & ident ) else
13612: LD_ADDR_VAR 0 5
13616: PUSH
13617: LD_VAR 0 3
13621: PUSH
13622: LD_VAR 0 1
13626: STR
13627: PPUSH
13628: CALL_OW 34
13632: ST_TO_ADDR
13633: GO 13650
// unit := NewCharacter ( ident ) ;
13635: LD_ADDR_VAR 0 5
13639: PUSH
13640: LD_VAR 0 1
13644: PPUSH
13645: CALL_OW 25
13649: ST_TO_ADDR
// result := unit ;
13650: LD_ADDR_VAR 0 4
13654: PUSH
13655: LD_VAR 0 5
13659: ST_TO_ADDR
// end ;
13660: LD_VAR 0 4
13664: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13665: LD_INT 0
13667: PPUSH
13668: PPUSH
// if not side or not nation then
13669: LD_VAR 0 1
13673: NOT
13674: PUSH
13675: LD_VAR 0 2
13679: NOT
13680: OR
13681: IFFALSE 13685
// exit ;
13683: GO 14449
// case nation of nation_american :
13685: LD_VAR 0 2
13689: PUSH
13690: LD_INT 1
13692: DOUBLE
13693: EQUAL
13694: IFTRUE 13698
13696: GO 13912
13698: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
13699: LD_ADDR_VAR 0 4
13703: PUSH
13704: LD_INT 35
13706: PUSH
13707: LD_INT 45
13709: PUSH
13710: LD_INT 46
13712: PUSH
13713: LD_INT 47
13715: PUSH
13716: LD_INT 82
13718: PUSH
13719: LD_INT 83
13721: PUSH
13722: LD_INT 84
13724: PUSH
13725: LD_INT 85
13727: PUSH
13728: LD_INT 86
13730: PUSH
13731: LD_INT 1
13733: PUSH
13734: LD_INT 2
13736: PUSH
13737: LD_INT 6
13739: PUSH
13740: LD_INT 15
13742: PUSH
13743: LD_INT 16
13745: PUSH
13746: LD_INT 7
13748: PUSH
13749: LD_INT 12
13751: PUSH
13752: LD_INT 13
13754: PUSH
13755: LD_INT 10
13757: PUSH
13758: LD_INT 14
13760: PUSH
13761: LD_INT 20
13763: PUSH
13764: LD_INT 21
13766: PUSH
13767: LD_INT 22
13769: PUSH
13770: LD_INT 25
13772: PUSH
13773: LD_INT 32
13775: PUSH
13776: LD_INT 27
13778: PUSH
13779: LD_INT 36
13781: PUSH
13782: LD_INT 69
13784: PUSH
13785: LD_INT 39
13787: PUSH
13788: LD_INT 34
13790: PUSH
13791: LD_INT 40
13793: PUSH
13794: LD_INT 48
13796: PUSH
13797: LD_INT 49
13799: PUSH
13800: LD_INT 50
13802: PUSH
13803: LD_INT 51
13805: PUSH
13806: LD_INT 52
13808: PUSH
13809: LD_INT 53
13811: PUSH
13812: LD_INT 54
13814: PUSH
13815: LD_INT 55
13817: PUSH
13818: LD_INT 56
13820: PUSH
13821: LD_INT 57
13823: PUSH
13824: LD_INT 58
13826: PUSH
13827: LD_INT 59
13829: PUSH
13830: LD_INT 60
13832: PUSH
13833: LD_INT 61
13835: PUSH
13836: LD_INT 62
13838: PUSH
13839: LD_INT 80
13841: PUSH
13842: LD_INT 82
13844: PUSH
13845: LD_INT 83
13847: PUSH
13848: LD_INT 84
13850: PUSH
13851: LD_INT 85
13853: PUSH
13854: LD_INT 86
13856: PUSH
13857: EMPTY
13858: LIST
13859: LIST
13860: LIST
13861: LIST
13862: LIST
13863: LIST
13864: LIST
13865: LIST
13866: LIST
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: ST_TO_ADDR
13910: GO 14373
13912: LD_INT 2
13914: DOUBLE
13915: EQUAL
13916: IFTRUE 13920
13918: GO 14142
13920: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
13921: LD_ADDR_VAR 0 4
13925: PUSH
13926: LD_INT 35
13928: PUSH
13929: LD_INT 45
13931: PUSH
13932: LD_INT 46
13934: PUSH
13935: LD_INT 47
13937: PUSH
13938: LD_INT 82
13940: PUSH
13941: LD_INT 83
13943: PUSH
13944: LD_INT 84
13946: PUSH
13947: LD_INT 85
13949: PUSH
13950: LD_INT 87
13952: PUSH
13953: LD_INT 70
13955: PUSH
13956: LD_INT 1
13958: PUSH
13959: LD_INT 11
13961: PUSH
13962: LD_INT 3
13964: PUSH
13965: LD_INT 4
13967: PUSH
13968: LD_INT 5
13970: PUSH
13971: LD_INT 6
13973: PUSH
13974: LD_INT 15
13976: PUSH
13977: LD_INT 18
13979: PUSH
13980: LD_INT 7
13982: PUSH
13983: LD_INT 17
13985: PUSH
13986: LD_INT 8
13988: PUSH
13989: LD_INT 20
13991: PUSH
13992: LD_INT 21
13994: PUSH
13995: LD_INT 22
13997: PUSH
13998: LD_INT 72
14000: PUSH
14001: LD_INT 26
14003: PUSH
14004: LD_INT 69
14006: PUSH
14007: LD_INT 39
14009: PUSH
14010: LD_INT 40
14012: PUSH
14013: LD_INT 41
14015: PUSH
14016: LD_INT 42
14018: PUSH
14019: LD_INT 43
14021: PUSH
14022: LD_INT 48
14024: PUSH
14025: LD_INT 49
14027: PUSH
14028: LD_INT 50
14030: PUSH
14031: LD_INT 51
14033: PUSH
14034: LD_INT 52
14036: PUSH
14037: LD_INT 53
14039: PUSH
14040: LD_INT 54
14042: PUSH
14043: LD_INT 55
14045: PUSH
14046: LD_INT 56
14048: PUSH
14049: LD_INT 60
14051: PUSH
14052: LD_INT 61
14054: PUSH
14055: LD_INT 62
14057: PUSH
14058: LD_INT 66
14060: PUSH
14061: LD_INT 67
14063: PUSH
14064: LD_INT 68
14066: PUSH
14067: LD_INT 81
14069: PUSH
14070: LD_INT 82
14072: PUSH
14073: LD_INT 83
14075: PUSH
14076: LD_INT 84
14078: PUSH
14079: LD_INT 85
14081: PUSH
14082: LD_INT 87
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: LIST
14089: LIST
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: ST_TO_ADDR
14140: GO 14373
14142: LD_INT 3
14144: DOUBLE
14145: EQUAL
14146: IFTRUE 14150
14148: GO 14372
14150: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14151: LD_ADDR_VAR 0 4
14155: PUSH
14156: LD_INT 46
14158: PUSH
14159: LD_INT 47
14161: PUSH
14162: LD_INT 1
14164: PUSH
14165: LD_INT 2
14167: PUSH
14168: LD_INT 82
14170: PUSH
14171: LD_INT 83
14173: PUSH
14174: LD_INT 84
14176: PUSH
14177: LD_INT 85
14179: PUSH
14180: LD_INT 86
14182: PUSH
14183: LD_INT 11
14185: PUSH
14186: LD_INT 9
14188: PUSH
14189: LD_INT 20
14191: PUSH
14192: LD_INT 19
14194: PUSH
14195: LD_INT 21
14197: PUSH
14198: LD_INT 24
14200: PUSH
14201: LD_INT 22
14203: PUSH
14204: LD_INT 25
14206: PUSH
14207: LD_INT 28
14209: PUSH
14210: LD_INT 29
14212: PUSH
14213: LD_INT 30
14215: PUSH
14216: LD_INT 31
14218: PUSH
14219: LD_INT 37
14221: PUSH
14222: LD_INT 38
14224: PUSH
14225: LD_INT 32
14227: PUSH
14228: LD_INT 27
14230: PUSH
14231: LD_INT 33
14233: PUSH
14234: LD_INT 69
14236: PUSH
14237: LD_INT 39
14239: PUSH
14240: LD_INT 34
14242: PUSH
14243: LD_INT 40
14245: PUSH
14246: LD_INT 71
14248: PUSH
14249: LD_INT 23
14251: PUSH
14252: LD_INT 44
14254: PUSH
14255: LD_INT 48
14257: PUSH
14258: LD_INT 49
14260: PUSH
14261: LD_INT 50
14263: PUSH
14264: LD_INT 51
14266: PUSH
14267: LD_INT 52
14269: PUSH
14270: LD_INT 53
14272: PUSH
14273: LD_INT 54
14275: PUSH
14276: LD_INT 55
14278: PUSH
14279: LD_INT 56
14281: PUSH
14282: LD_INT 57
14284: PUSH
14285: LD_INT 58
14287: PUSH
14288: LD_INT 59
14290: PUSH
14291: LD_INT 63
14293: PUSH
14294: LD_INT 64
14296: PUSH
14297: LD_INT 65
14299: PUSH
14300: LD_INT 82
14302: PUSH
14303: LD_INT 83
14305: PUSH
14306: LD_INT 84
14308: PUSH
14309: LD_INT 85
14311: PUSH
14312: LD_INT 86
14314: PUSH
14315: EMPTY
14316: LIST
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: ST_TO_ADDR
14370: GO 14373
14372: POP
// if state > - 1 and state < 3 then
14373: LD_VAR 0 3
14377: PUSH
14378: LD_INT 1
14380: NEG
14381: GREATER
14382: PUSH
14383: LD_VAR 0 3
14387: PUSH
14388: LD_INT 3
14390: LESS
14391: AND
14392: IFFALSE 14449
// for i in result do
14394: LD_ADDR_VAR 0 5
14398: PUSH
14399: LD_VAR 0 4
14403: PUSH
14404: FOR_IN
14405: IFFALSE 14447
// if GetTech ( i , side ) <> state then
14407: LD_VAR 0 5
14411: PPUSH
14412: LD_VAR 0 1
14416: PPUSH
14417: CALL_OW 321
14421: PUSH
14422: LD_VAR 0 3
14426: NONEQUAL
14427: IFFALSE 14445
// result := result diff i ;
14429: LD_ADDR_VAR 0 4
14433: PUSH
14434: LD_VAR 0 4
14438: PUSH
14439: LD_VAR 0 5
14443: DIFF
14444: ST_TO_ADDR
14445: GO 14404
14447: POP
14448: POP
// end ;
14449: LD_VAR 0 4
14453: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14454: LD_INT 0
14456: PPUSH
14457: PPUSH
14458: PPUSH
// result := true ;
14459: LD_ADDR_VAR 0 3
14463: PUSH
14464: LD_INT 1
14466: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14467: LD_ADDR_VAR 0 5
14471: PUSH
14472: LD_VAR 0 2
14476: PPUSH
14477: CALL_OW 480
14481: ST_TO_ADDR
// if not tmp then
14482: LD_VAR 0 5
14486: NOT
14487: IFFALSE 14491
// exit ;
14489: GO 14540
// for i in tmp do
14491: LD_ADDR_VAR 0 4
14495: PUSH
14496: LD_VAR 0 5
14500: PUSH
14501: FOR_IN
14502: IFFALSE 14538
// if GetTech ( i , side ) <> state_researched then
14504: LD_VAR 0 4
14508: PPUSH
14509: LD_VAR 0 1
14513: PPUSH
14514: CALL_OW 321
14518: PUSH
14519: LD_INT 2
14521: NONEQUAL
14522: IFFALSE 14536
// begin result := false ;
14524: LD_ADDR_VAR 0 3
14528: PUSH
14529: LD_INT 0
14531: ST_TO_ADDR
// exit ;
14532: POP
14533: POP
14534: GO 14540
// end ;
14536: GO 14501
14538: POP
14539: POP
// end ;
14540: LD_VAR 0 3
14544: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14545: LD_INT 0
14547: PPUSH
14548: PPUSH
14549: PPUSH
14550: PPUSH
14551: PPUSH
14552: PPUSH
14553: PPUSH
14554: PPUSH
14555: PPUSH
14556: PPUSH
14557: PPUSH
14558: PPUSH
14559: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14560: LD_VAR 0 1
14564: NOT
14565: PUSH
14566: LD_VAR 0 1
14570: PPUSH
14571: CALL_OW 257
14575: PUSH
14576: LD_INT 9
14578: NONEQUAL
14579: OR
14580: IFFALSE 14584
// exit ;
14582: GO 15157
// side := GetSide ( unit ) ;
14584: LD_ADDR_VAR 0 9
14588: PUSH
14589: LD_VAR 0 1
14593: PPUSH
14594: CALL_OW 255
14598: ST_TO_ADDR
// tech_space := tech_spacanom ;
14599: LD_ADDR_VAR 0 12
14603: PUSH
14604: LD_INT 29
14606: ST_TO_ADDR
// tech_time := tech_taurad ;
14607: LD_ADDR_VAR 0 13
14611: PUSH
14612: LD_INT 28
14614: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14615: LD_ADDR_VAR 0 11
14619: PUSH
14620: LD_VAR 0 1
14624: PPUSH
14625: CALL_OW 310
14629: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14630: LD_VAR 0 11
14634: PPUSH
14635: CALL_OW 247
14639: PUSH
14640: LD_INT 2
14642: EQUAL
14643: IFFALSE 14647
// exit ;
14645: GO 15157
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14647: LD_ADDR_VAR 0 8
14651: PUSH
14652: LD_INT 81
14654: PUSH
14655: LD_VAR 0 9
14659: PUSH
14660: EMPTY
14661: LIST
14662: LIST
14663: PUSH
14664: LD_INT 3
14666: PUSH
14667: LD_INT 21
14669: PUSH
14670: LD_INT 3
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PPUSH
14685: CALL_OW 69
14689: ST_TO_ADDR
// if not tmp then
14690: LD_VAR 0 8
14694: NOT
14695: IFFALSE 14699
// exit ;
14697: GO 15157
// if in_unit then
14699: LD_VAR 0 11
14703: IFFALSE 14727
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14705: LD_ADDR_VAR 0 10
14709: PUSH
14710: LD_VAR 0 8
14714: PPUSH
14715: LD_VAR 0 11
14719: PPUSH
14720: CALL_OW 74
14724: ST_TO_ADDR
14725: GO 14747
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14727: LD_ADDR_VAR 0 10
14731: PUSH
14732: LD_VAR 0 8
14736: PPUSH
14737: LD_VAR 0 1
14741: PPUSH
14742: CALL_OW 74
14746: ST_TO_ADDR
// if not enemy then
14747: LD_VAR 0 10
14751: NOT
14752: IFFALSE 14756
// exit ;
14754: GO 15157
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14756: LD_VAR 0 11
14760: PUSH
14761: LD_VAR 0 11
14765: PPUSH
14766: LD_VAR 0 10
14770: PPUSH
14771: CALL_OW 296
14775: PUSH
14776: LD_INT 13
14778: GREATER
14779: AND
14780: PUSH
14781: LD_VAR 0 1
14785: PPUSH
14786: LD_VAR 0 10
14790: PPUSH
14791: CALL_OW 296
14795: PUSH
14796: LD_INT 12
14798: GREATER
14799: OR
14800: IFFALSE 14804
// exit ;
14802: GO 15157
// missile := [ 1 ] ;
14804: LD_ADDR_VAR 0 14
14808: PUSH
14809: LD_INT 1
14811: PUSH
14812: EMPTY
14813: LIST
14814: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14815: LD_VAR 0 9
14819: PPUSH
14820: LD_VAR 0 12
14824: PPUSH
14825: CALL_OW 325
14829: IFFALSE 14858
// missile := Insert ( missile , missile + 1 , 2 ) ;
14831: LD_ADDR_VAR 0 14
14835: PUSH
14836: LD_VAR 0 14
14840: PPUSH
14841: LD_VAR 0 14
14845: PUSH
14846: LD_INT 1
14848: PLUS
14849: PPUSH
14850: LD_INT 2
14852: PPUSH
14853: CALL_OW 2
14857: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14858: LD_VAR 0 9
14862: PPUSH
14863: LD_VAR 0 13
14867: PPUSH
14868: CALL_OW 325
14872: PUSH
14873: LD_VAR 0 10
14877: PPUSH
14878: CALL_OW 255
14882: PPUSH
14883: LD_VAR 0 13
14887: PPUSH
14888: CALL_OW 325
14892: NOT
14893: AND
14894: IFFALSE 14923
// missile := Insert ( missile , missile + 1 , 3 ) ;
14896: LD_ADDR_VAR 0 14
14900: PUSH
14901: LD_VAR 0 14
14905: PPUSH
14906: LD_VAR 0 14
14910: PUSH
14911: LD_INT 1
14913: PLUS
14914: PPUSH
14915: LD_INT 3
14917: PPUSH
14918: CALL_OW 2
14922: ST_TO_ADDR
// if missile < 2 then
14923: LD_VAR 0 14
14927: PUSH
14928: LD_INT 2
14930: LESS
14931: IFFALSE 14935
// exit ;
14933: GO 15157
// x := GetX ( enemy ) ;
14935: LD_ADDR_VAR 0 4
14939: PUSH
14940: LD_VAR 0 10
14944: PPUSH
14945: CALL_OW 250
14949: ST_TO_ADDR
// y := GetY ( enemy ) ;
14950: LD_ADDR_VAR 0 5
14954: PUSH
14955: LD_VAR 0 10
14959: PPUSH
14960: CALL_OW 251
14964: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14965: LD_ADDR_VAR 0 6
14969: PUSH
14970: LD_VAR 0 4
14974: PUSH
14975: LD_INT 1
14977: NEG
14978: PPUSH
14979: LD_INT 1
14981: PPUSH
14982: CALL_OW 12
14986: PLUS
14987: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
14988: LD_ADDR_VAR 0 7
14992: PUSH
14993: LD_VAR 0 5
14997: PUSH
14998: LD_INT 1
15000: NEG
15001: PPUSH
15002: LD_INT 1
15004: PPUSH
15005: CALL_OW 12
15009: PLUS
15010: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15011: LD_VAR 0 6
15015: PPUSH
15016: LD_VAR 0 7
15020: PPUSH
15021: CALL_OW 488
15025: NOT
15026: IFFALSE 15048
// begin _x := x ;
15028: LD_ADDR_VAR 0 6
15032: PUSH
15033: LD_VAR 0 4
15037: ST_TO_ADDR
// _y := y ;
15038: LD_ADDR_VAR 0 7
15042: PUSH
15043: LD_VAR 0 5
15047: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15048: LD_ADDR_VAR 0 3
15052: PUSH
15053: LD_INT 1
15055: PPUSH
15056: LD_VAR 0 14
15060: PPUSH
15061: CALL_OW 12
15065: ST_TO_ADDR
// case i of 1 :
15066: LD_VAR 0 3
15070: PUSH
15071: LD_INT 1
15073: DOUBLE
15074: EQUAL
15075: IFTRUE 15079
15077: GO 15096
15079: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15080: LD_VAR 0 1
15084: PPUSH
15085: LD_VAR 0 10
15089: PPUSH
15090: CALL_OW 115
15094: GO 15157
15096: LD_INT 2
15098: DOUBLE
15099: EQUAL
15100: IFTRUE 15104
15102: GO 15126
15104: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15105: LD_VAR 0 1
15109: PPUSH
15110: LD_VAR 0 6
15114: PPUSH
15115: LD_VAR 0 7
15119: PPUSH
15120: CALL_OW 153
15124: GO 15157
15126: LD_INT 3
15128: DOUBLE
15129: EQUAL
15130: IFTRUE 15134
15132: GO 15156
15134: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15135: LD_VAR 0 1
15139: PPUSH
15140: LD_VAR 0 6
15144: PPUSH
15145: LD_VAR 0 7
15149: PPUSH
15150: CALL_OW 154
15154: GO 15157
15156: POP
// end ;
15157: LD_VAR 0 2
15161: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15162: LD_INT 0
15164: PPUSH
15165: PPUSH
15166: PPUSH
15167: PPUSH
15168: PPUSH
15169: PPUSH
// if not unit or not building then
15170: LD_VAR 0 1
15174: NOT
15175: PUSH
15176: LD_VAR 0 2
15180: NOT
15181: OR
15182: IFFALSE 15186
// exit ;
15184: GO 15344
// x := GetX ( building ) ;
15186: LD_ADDR_VAR 0 5
15190: PUSH
15191: LD_VAR 0 2
15195: PPUSH
15196: CALL_OW 250
15200: ST_TO_ADDR
// y := GetY ( building ) ;
15201: LD_ADDR_VAR 0 6
15205: PUSH
15206: LD_VAR 0 2
15210: PPUSH
15211: CALL_OW 251
15215: ST_TO_ADDR
// for i = 0 to 5 do
15216: LD_ADDR_VAR 0 4
15220: PUSH
15221: DOUBLE
15222: LD_INT 0
15224: DEC
15225: ST_TO_ADDR
15226: LD_INT 5
15228: PUSH
15229: FOR_TO
15230: IFFALSE 15342
// begin _x := ShiftX ( x , i , 3 ) ;
15232: LD_ADDR_VAR 0 7
15236: PUSH
15237: LD_VAR 0 5
15241: PPUSH
15242: LD_VAR 0 4
15246: PPUSH
15247: LD_INT 3
15249: PPUSH
15250: CALL_OW 272
15254: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15255: LD_ADDR_VAR 0 8
15259: PUSH
15260: LD_VAR 0 6
15264: PPUSH
15265: LD_VAR 0 4
15269: PPUSH
15270: LD_INT 3
15272: PPUSH
15273: CALL_OW 273
15277: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15278: LD_VAR 0 7
15282: PPUSH
15283: LD_VAR 0 8
15287: PPUSH
15288: CALL_OW 488
15292: NOT
15293: IFFALSE 15297
// continue ;
15295: GO 15229
// if HexInfo ( _x , _y ) = 0 then
15297: LD_VAR 0 7
15301: PPUSH
15302: LD_VAR 0 8
15306: PPUSH
15307: CALL_OW 428
15311: PUSH
15312: LD_INT 0
15314: EQUAL
15315: IFFALSE 15340
// begin ComMoveXY ( unit , _x , _y ) ;
15317: LD_VAR 0 1
15321: PPUSH
15322: LD_VAR 0 7
15326: PPUSH
15327: LD_VAR 0 8
15331: PPUSH
15332: CALL_OW 111
// exit ;
15336: POP
15337: POP
15338: GO 15344
// end ; end ;
15340: GO 15229
15342: POP
15343: POP
// end ;
15344: LD_VAR 0 3
15348: RET
// export function ScanBase ( side , base_area ) ; begin
15349: LD_INT 0
15351: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15352: LD_ADDR_VAR 0 3
15356: PUSH
15357: LD_VAR 0 2
15361: PPUSH
15362: LD_INT 81
15364: PUSH
15365: LD_VAR 0 1
15369: PUSH
15370: EMPTY
15371: LIST
15372: LIST
15373: PPUSH
15374: CALL_OW 70
15378: ST_TO_ADDR
// end ;
15379: LD_VAR 0 3
15383: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15384: LD_INT 0
15386: PPUSH
15387: PPUSH
15388: PPUSH
15389: PPUSH
// result := false ;
15390: LD_ADDR_VAR 0 2
15394: PUSH
15395: LD_INT 0
15397: ST_TO_ADDR
// side := GetSide ( unit ) ;
15398: LD_ADDR_VAR 0 3
15402: PUSH
15403: LD_VAR 0 1
15407: PPUSH
15408: CALL_OW 255
15412: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15413: LD_ADDR_VAR 0 4
15417: PUSH
15418: LD_VAR 0 1
15422: PPUSH
15423: CALL_OW 248
15427: ST_TO_ADDR
// case nat of 1 :
15428: LD_VAR 0 4
15432: PUSH
15433: LD_INT 1
15435: DOUBLE
15436: EQUAL
15437: IFTRUE 15441
15439: GO 15452
15441: POP
// tech := tech_lassight ; 2 :
15442: LD_ADDR_VAR 0 5
15446: PUSH
15447: LD_INT 12
15449: ST_TO_ADDR
15450: GO 15491
15452: LD_INT 2
15454: DOUBLE
15455: EQUAL
15456: IFTRUE 15460
15458: GO 15471
15460: POP
// tech := tech_mortar ; 3 :
15461: LD_ADDR_VAR 0 5
15465: PUSH
15466: LD_INT 41
15468: ST_TO_ADDR
15469: GO 15491
15471: LD_INT 3
15473: DOUBLE
15474: EQUAL
15475: IFTRUE 15479
15477: GO 15490
15479: POP
// tech := tech_bazooka ; end ;
15480: LD_ADDR_VAR 0 5
15484: PUSH
15485: LD_INT 44
15487: ST_TO_ADDR
15488: GO 15491
15490: POP
// if Researched ( side , tech ) then
15491: LD_VAR 0 3
15495: PPUSH
15496: LD_VAR 0 5
15500: PPUSH
15501: CALL_OW 325
15505: IFFALSE 15532
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15507: LD_ADDR_VAR 0 2
15511: PUSH
15512: LD_INT 5
15514: PUSH
15515: LD_INT 8
15517: PUSH
15518: LD_INT 9
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: LIST
15525: PUSH
15526: LD_VAR 0 4
15530: ARRAY
15531: ST_TO_ADDR
// end ;
15532: LD_VAR 0 2
15536: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15537: LD_INT 0
15539: PPUSH
15540: PPUSH
15541: PPUSH
// if not mines then
15542: LD_VAR 0 2
15546: NOT
15547: IFFALSE 15551
// exit ;
15549: GO 15695
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15551: LD_ADDR_VAR 0 5
15555: PUSH
15556: LD_INT 81
15558: PUSH
15559: LD_VAR 0 1
15563: PUSH
15564: EMPTY
15565: LIST
15566: LIST
15567: PUSH
15568: LD_INT 3
15570: PUSH
15571: LD_INT 21
15573: PUSH
15574: LD_INT 3
15576: PUSH
15577: EMPTY
15578: LIST
15579: LIST
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PPUSH
15589: CALL_OW 69
15593: ST_TO_ADDR
// for i in mines do
15594: LD_ADDR_VAR 0 4
15598: PUSH
15599: LD_VAR 0 2
15603: PUSH
15604: FOR_IN
15605: IFFALSE 15693
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15607: LD_VAR 0 4
15611: PUSH
15612: LD_INT 1
15614: ARRAY
15615: PPUSH
15616: LD_VAR 0 4
15620: PUSH
15621: LD_INT 2
15623: ARRAY
15624: PPUSH
15625: CALL_OW 458
15629: NOT
15630: IFFALSE 15634
// continue ;
15632: GO 15604
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15634: LD_VAR 0 4
15638: PUSH
15639: LD_INT 1
15641: ARRAY
15642: PPUSH
15643: LD_VAR 0 4
15647: PUSH
15648: LD_INT 2
15650: ARRAY
15651: PPUSH
15652: CALL_OW 428
15656: PUSH
15657: LD_VAR 0 5
15661: IN
15662: IFFALSE 15691
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15664: LD_VAR 0 4
15668: PUSH
15669: LD_INT 1
15671: ARRAY
15672: PPUSH
15673: LD_VAR 0 4
15677: PUSH
15678: LD_INT 2
15680: ARRAY
15681: PPUSH
15682: LD_VAR 0 1
15686: PPUSH
15687: CALL_OW 456
// end ;
15691: GO 15604
15693: POP
15694: POP
// end ;
15695: LD_VAR 0 3
15699: RET
// export function Count ( array ) ; var i ; begin
15700: LD_INT 0
15702: PPUSH
15703: PPUSH
// result := 0 ;
15704: LD_ADDR_VAR 0 2
15708: PUSH
15709: LD_INT 0
15711: ST_TO_ADDR
// for i in array do
15712: LD_ADDR_VAR 0 3
15716: PUSH
15717: LD_VAR 0 1
15721: PUSH
15722: FOR_IN
15723: IFFALSE 15747
// if i then
15725: LD_VAR 0 3
15729: IFFALSE 15745
// result := result + 1 ;
15731: LD_ADDR_VAR 0 2
15735: PUSH
15736: LD_VAR 0 2
15740: PUSH
15741: LD_INT 1
15743: PLUS
15744: ST_TO_ADDR
15745: GO 15722
15747: POP
15748: POP
// end ;
15749: LD_VAR 0 2
15753: RET
// export function IsEmpty ( building ) ; begin
15754: LD_INT 0
15756: PPUSH
// if not building then
15757: LD_VAR 0 1
15761: NOT
15762: IFFALSE 15766
// exit ;
15764: GO 15809
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15766: LD_ADDR_VAR 0 2
15770: PUSH
15771: LD_VAR 0 1
15775: PUSH
15776: LD_INT 22
15778: PUSH
15779: LD_VAR 0 1
15783: PPUSH
15784: CALL_OW 255
15788: PUSH
15789: EMPTY
15790: LIST
15791: LIST
15792: PUSH
15793: LD_INT 58
15795: PUSH
15796: EMPTY
15797: LIST
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: PPUSH
15803: CALL_OW 69
15807: IN
15808: ST_TO_ADDR
// end ;
15809: LD_VAR 0 2
15813: RET
// export function IsNotFull ( building ) ; begin
15814: LD_INT 0
15816: PPUSH
// if not building then
15817: LD_VAR 0 1
15821: NOT
15822: IFFALSE 15826
// exit ;
15824: GO 15845
// result := UnitsInside ( building ) < 6 ;
15826: LD_ADDR_VAR 0 2
15830: PUSH
15831: LD_VAR 0 1
15835: PPUSH
15836: CALL_OW 313
15840: PUSH
15841: LD_INT 6
15843: LESS
15844: ST_TO_ADDR
// end ;
15845: LD_VAR 0 2
15849: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
15850: LD_INT 0
15852: PPUSH
15853: PPUSH
15854: PPUSH
15855: PPUSH
// tmp := [ ] ;
15856: LD_ADDR_VAR 0 3
15860: PUSH
15861: EMPTY
15862: ST_TO_ADDR
// list := [ ] ;
15863: LD_ADDR_VAR 0 5
15867: PUSH
15868: EMPTY
15869: ST_TO_ADDR
// for i = 16 to 25 do
15870: LD_ADDR_VAR 0 4
15874: PUSH
15875: DOUBLE
15876: LD_INT 16
15878: DEC
15879: ST_TO_ADDR
15880: LD_INT 25
15882: PUSH
15883: FOR_TO
15884: IFFALSE 15957
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
15886: LD_ADDR_VAR 0 3
15890: PUSH
15891: LD_VAR 0 3
15895: PUSH
15896: LD_INT 22
15898: PUSH
15899: LD_VAR 0 1
15903: PPUSH
15904: CALL_OW 255
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: PUSH
15913: LD_INT 91
15915: PUSH
15916: LD_VAR 0 1
15920: PUSH
15921: LD_INT 6
15923: PUSH
15924: EMPTY
15925: LIST
15926: LIST
15927: LIST
15928: PUSH
15929: LD_INT 30
15931: PUSH
15932: LD_VAR 0 4
15936: PUSH
15937: EMPTY
15938: LIST
15939: LIST
15940: PUSH
15941: EMPTY
15942: LIST
15943: LIST
15944: LIST
15945: PUSH
15946: EMPTY
15947: LIST
15948: PPUSH
15949: CALL_OW 69
15953: ADD
15954: ST_TO_ADDR
15955: GO 15883
15957: POP
15958: POP
// for i = 1 to tmp do
15959: LD_ADDR_VAR 0 4
15963: PUSH
15964: DOUBLE
15965: LD_INT 1
15967: DEC
15968: ST_TO_ADDR
15969: LD_VAR 0 3
15973: PUSH
15974: FOR_TO
15975: IFFALSE 16063
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
15977: LD_ADDR_VAR 0 5
15981: PUSH
15982: LD_VAR 0 5
15986: PUSH
15987: LD_VAR 0 3
15991: PUSH
15992: LD_VAR 0 4
15996: ARRAY
15997: PPUSH
15998: CALL_OW 266
16002: PUSH
16003: LD_VAR 0 3
16007: PUSH
16008: LD_VAR 0 4
16012: ARRAY
16013: PPUSH
16014: CALL_OW 250
16018: PUSH
16019: LD_VAR 0 3
16023: PUSH
16024: LD_VAR 0 4
16028: ARRAY
16029: PPUSH
16030: CALL_OW 251
16034: PUSH
16035: LD_VAR 0 3
16039: PUSH
16040: LD_VAR 0 4
16044: ARRAY
16045: PPUSH
16046: CALL_OW 254
16050: PUSH
16051: EMPTY
16052: LIST
16053: LIST
16054: LIST
16055: LIST
16056: PUSH
16057: EMPTY
16058: LIST
16059: ADD
16060: ST_TO_ADDR
16061: GO 15974
16063: POP
16064: POP
// result := list ;
16065: LD_ADDR_VAR 0 2
16069: PUSH
16070: LD_VAR 0 5
16074: ST_TO_ADDR
// end ;
16075: LD_VAR 0 2
16079: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16080: LD_INT 0
16082: PPUSH
16083: PPUSH
16084: PPUSH
16085: PPUSH
16086: PPUSH
16087: PPUSH
16088: PPUSH
// if not factory then
16089: LD_VAR 0 1
16093: NOT
16094: IFFALSE 16098
// exit ;
16096: GO 16691
// if control = control_apeman then
16098: LD_VAR 0 4
16102: PUSH
16103: LD_INT 5
16105: EQUAL
16106: IFFALSE 16215
// begin tmp := UnitsInside ( factory ) ;
16108: LD_ADDR_VAR 0 8
16112: PUSH
16113: LD_VAR 0 1
16117: PPUSH
16118: CALL_OW 313
16122: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16123: LD_VAR 0 8
16127: PPUSH
16128: LD_INT 25
16130: PUSH
16131: LD_INT 12
16133: PUSH
16134: EMPTY
16135: LIST
16136: LIST
16137: PPUSH
16138: CALL_OW 72
16142: NOT
16143: IFFALSE 16153
// control := control_manual ;
16145: LD_ADDR_VAR 0 4
16149: PUSH
16150: LD_INT 1
16152: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16153: LD_ADDR_VAR 0 8
16157: PUSH
16158: LD_VAR 0 1
16162: PPUSH
16163: CALL 15850 0 1
16167: ST_TO_ADDR
// if tmp then
16168: LD_VAR 0 8
16172: IFFALSE 16215
// begin for i in tmp do
16174: LD_ADDR_VAR 0 7
16178: PUSH
16179: LD_VAR 0 8
16183: PUSH
16184: FOR_IN
16185: IFFALSE 16213
// if i [ 1 ] = b_ext_radio then
16187: LD_VAR 0 7
16191: PUSH
16192: LD_INT 1
16194: ARRAY
16195: PUSH
16196: LD_INT 22
16198: EQUAL
16199: IFFALSE 16211
// begin control := control_remote ;
16201: LD_ADDR_VAR 0 4
16205: PUSH
16206: LD_INT 2
16208: ST_TO_ADDR
// break ;
16209: GO 16213
// end ;
16211: GO 16184
16213: POP
16214: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16215: LD_VAR 0 1
16219: PPUSH
16220: LD_VAR 0 2
16224: PPUSH
16225: LD_VAR 0 3
16229: PPUSH
16230: LD_VAR 0 4
16234: PPUSH
16235: LD_VAR 0 5
16239: PPUSH
16240: CALL_OW 448
16244: IFFALSE 16279
// begin result := [ chassis , engine , control , weapon ] ;
16246: LD_ADDR_VAR 0 6
16250: PUSH
16251: LD_VAR 0 2
16255: PUSH
16256: LD_VAR 0 3
16260: PUSH
16261: LD_VAR 0 4
16265: PUSH
16266: LD_VAR 0 5
16270: PUSH
16271: EMPTY
16272: LIST
16273: LIST
16274: LIST
16275: LIST
16276: ST_TO_ADDR
// exit ;
16277: GO 16691
// end ; _chassis := AvailableChassisList ( factory ) ;
16279: LD_ADDR_VAR 0 9
16283: PUSH
16284: LD_VAR 0 1
16288: PPUSH
16289: CALL_OW 475
16293: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16294: LD_ADDR_VAR 0 11
16298: PUSH
16299: LD_VAR 0 1
16303: PPUSH
16304: CALL_OW 476
16308: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16309: LD_ADDR_VAR 0 12
16313: PUSH
16314: LD_VAR 0 1
16318: PPUSH
16319: CALL_OW 477
16323: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
16324: LD_ADDR_VAR 0 10
16328: PUSH
16329: LD_VAR 0 1
16333: PPUSH
16334: CALL_OW 478
16338: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
16339: LD_VAR 0 9
16343: NOT
16344: PUSH
16345: LD_VAR 0 11
16349: NOT
16350: OR
16351: PUSH
16352: LD_VAR 0 12
16356: NOT
16357: OR
16358: PUSH
16359: LD_VAR 0 10
16363: NOT
16364: OR
16365: IFFALSE 16400
// begin result := [ chassis , engine , control , weapon ] ;
16367: LD_ADDR_VAR 0 6
16371: PUSH
16372: LD_VAR 0 2
16376: PUSH
16377: LD_VAR 0 3
16381: PUSH
16382: LD_VAR 0 4
16386: PUSH
16387: LD_VAR 0 5
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: LIST
16396: LIST
16397: ST_TO_ADDR
// exit ;
16398: GO 16691
// end ; if not chassis in _chassis then
16400: LD_VAR 0 2
16404: PUSH
16405: LD_VAR 0 9
16409: IN
16410: NOT
16411: IFFALSE 16437
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16413: LD_ADDR_VAR 0 2
16417: PUSH
16418: LD_VAR 0 9
16422: PUSH
16423: LD_INT 1
16425: PPUSH
16426: LD_VAR 0 9
16430: PPUSH
16431: CALL_OW 12
16435: ARRAY
16436: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16437: LD_VAR 0 2
16441: PPUSH
16442: LD_VAR 0 3
16446: PPUSH
16447: CALL 16696 0 2
16451: NOT
16452: IFFALSE 16511
// repeat engine := _engine [ 1 ] ;
16454: LD_ADDR_VAR 0 3
16458: PUSH
16459: LD_VAR 0 11
16463: PUSH
16464: LD_INT 1
16466: ARRAY
16467: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16468: LD_ADDR_VAR 0 11
16472: PUSH
16473: LD_VAR 0 11
16477: PPUSH
16478: LD_INT 1
16480: PPUSH
16481: CALL_OW 3
16485: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16486: LD_VAR 0 2
16490: PPUSH
16491: LD_VAR 0 3
16495: PPUSH
16496: CALL 16696 0 2
16500: PUSH
16501: LD_VAR 0 11
16505: PUSH
16506: EMPTY
16507: EQUAL
16508: OR
16509: IFFALSE 16454
// if not control in _control then
16511: LD_VAR 0 4
16515: PUSH
16516: LD_VAR 0 12
16520: IN
16521: NOT
16522: IFFALSE 16548
// control := _control [ rand ( 1 , _control ) ] ;
16524: LD_ADDR_VAR 0 4
16528: PUSH
16529: LD_VAR 0 12
16533: PUSH
16534: LD_INT 1
16536: PPUSH
16537: LD_VAR 0 12
16541: PPUSH
16542: CALL_OW 12
16546: ARRAY
16547: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16548: LD_VAR 0 2
16552: PPUSH
16553: LD_VAR 0 5
16557: PPUSH
16558: CALL 16916 0 2
16562: NOT
16563: IFFALSE 16622
// repeat weapon := _weapon [ 1 ] ;
16565: LD_ADDR_VAR 0 5
16569: PUSH
16570: LD_VAR 0 10
16574: PUSH
16575: LD_INT 1
16577: ARRAY
16578: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16579: LD_ADDR_VAR 0 10
16583: PUSH
16584: LD_VAR 0 10
16588: PPUSH
16589: LD_INT 1
16591: PPUSH
16592: CALL_OW 3
16596: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16597: LD_VAR 0 2
16601: PPUSH
16602: LD_VAR 0 5
16606: PPUSH
16607: CALL 16916 0 2
16611: PUSH
16612: LD_VAR 0 10
16616: PUSH
16617: EMPTY
16618: EQUAL
16619: OR
16620: IFFALSE 16565
// result := [ ] ;
16622: LD_ADDR_VAR 0 6
16626: PUSH
16627: EMPTY
16628: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16629: LD_VAR 0 1
16633: PPUSH
16634: LD_VAR 0 2
16638: PPUSH
16639: LD_VAR 0 3
16643: PPUSH
16644: LD_VAR 0 4
16648: PPUSH
16649: LD_VAR 0 5
16653: PPUSH
16654: CALL_OW 448
16658: IFFALSE 16691
// result := [ chassis , engine , control , weapon ] ;
16660: LD_ADDR_VAR 0 6
16664: PUSH
16665: LD_VAR 0 2
16669: PUSH
16670: LD_VAR 0 3
16674: PUSH
16675: LD_VAR 0 4
16679: PUSH
16680: LD_VAR 0 5
16684: PUSH
16685: EMPTY
16686: LIST
16687: LIST
16688: LIST
16689: LIST
16690: ST_TO_ADDR
// end ;
16691: LD_VAR 0 6
16695: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16696: LD_INT 0
16698: PPUSH
// if not chassis or not engine then
16699: LD_VAR 0 1
16703: NOT
16704: PUSH
16705: LD_VAR 0 2
16709: NOT
16710: OR
16711: IFFALSE 16715
// exit ;
16713: GO 16911
// case engine of engine_solar :
16715: LD_VAR 0 2
16719: PUSH
16720: LD_INT 2
16722: DOUBLE
16723: EQUAL
16724: IFTRUE 16728
16726: GO 16766
16728: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16729: LD_ADDR_VAR 0 3
16733: PUSH
16734: LD_INT 11
16736: PUSH
16737: LD_INT 12
16739: PUSH
16740: LD_INT 13
16742: PUSH
16743: LD_INT 14
16745: PUSH
16746: LD_INT 1
16748: PUSH
16749: LD_INT 2
16751: PUSH
16752: LD_INT 3
16754: PUSH
16755: EMPTY
16756: LIST
16757: LIST
16758: LIST
16759: LIST
16760: LIST
16761: LIST
16762: LIST
16763: ST_TO_ADDR
16764: GO 16895
16766: LD_INT 1
16768: DOUBLE
16769: EQUAL
16770: IFTRUE 16774
16772: GO 16836
16774: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16775: LD_ADDR_VAR 0 3
16779: PUSH
16780: LD_INT 11
16782: PUSH
16783: LD_INT 12
16785: PUSH
16786: LD_INT 13
16788: PUSH
16789: LD_INT 14
16791: PUSH
16792: LD_INT 1
16794: PUSH
16795: LD_INT 2
16797: PUSH
16798: LD_INT 3
16800: PUSH
16801: LD_INT 4
16803: PUSH
16804: LD_INT 5
16806: PUSH
16807: LD_INT 21
16809: PUSH
16810: LD_INT 23
16812: PUSH
16813: LD_INT 22
16815: PUSH
16816: LD_INT 24
16818: PUSH
16819: EMPTY
16820: LIST
16821: LIST
16822: LIST
16823: LIST
16824: LIST
16825: LIST
16826: LIST
16827: LIST
16828: LIST
16829: LIST
16830: LIST
16831: LIST
16832: LIST
16833: ST_TO_ADDR
16834: GO 16895
16836: LD_INT 3
16838: DOUBLE
16839: EQUAL
16840: IFTRUE 16844
16842: GO 16894
16844: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
16845: LD_ADDR_VAR 0 3
16849: PUSH
16850: LD_INT 13
16852: PUSH
16853: LD_INT 14
16855: PUSH
16856: LD_INT 2
16858: PUSH
16859: LD_INT 3
16861: PUSH
16862: LD_INT 4
16864: PUSH
16865: LD_INT 5
16867: PUSH
16868: LD_INT 21
16870: PUSH
16871: LD_INT 22
16873: PUSH
16874: LD_INT 23
16876: PUSH
16877: LD_INT 24
16879: PUSH
16880: EMPTY
16881: LIST
16882: LIST
16883: LIST
16884: LIST
16885: LIST
16886: LIST
16887: LIST
16888: LIST
16889: LIST
16890: LIST
16891: ST_TO_ADDR
16892: GO 16895
16894: POP
// result := ( chassis in result ) ;
16895: LD_ADDR_VAR 0 3
16899: PUSH
16900: LD_VAR 0 1
16904: PUSH
16905: LD_VAR 0 3
16909: IN
16910: ST_TO_ADDR
// end ;
16911: LD_VAR 0 3
16915: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
16916: LD_INT 0
16918: PPUSH
// if not chassis or not weapon then
16919: LD_VAR 0 1
16923: NOT
16924: PUSH
16925: LD_VAR 0 2
16929: NOT
16930: OR
16931: IFFALSE 16935
// exit ;
16933: GO 17961
// case weapon of us_machine_gun :
16935: LD_VAR 0 2
16939: PUSH
16940: LD_INT 2
16942: DOUBLE
16943: EQUAL
16944: IFTRUE 16948
16946: GO 16978
16948: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
16949: LD_ADDR_VAR 0 3
16953: PUSH
16954: LD_INT 1
16956: PUSH
16957: LD_INT 2
16959: PUSH
16960: LD_INT 3
16962: PUSH
16963: LD_INT 4
16965: PUSH
16966: LD_INT 5
16968: PUSH
16969: EMPTY
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: LIST
16975: ST_TO_ADDR
16976: GO 17945
16978: LD_INT 3
16980: DOUBLE
16981: EQUAL
16982: IFTRUE 16986
16984: GO 17016
16986: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
16987: LD_ADDR_VAR 0 3
16991: PUSH
16992: LD_INT 1
16994: PUSH
16995: LD_INT 2
16997: PUSH
16998: LD_INT 3
17000: PUSH
17001: LD_INT 4
17003: PUSH
17004: LD_INT 5
17006: PUSH
17007: EMPTY
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: LIST
17013: ST_TO_ADDR
17014: GO 17945
17016: LD_INT 11
17018: DOUBLE
17019: EQUAL
17020: IFTRUE 17024
17022: GO 17054
17024: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17025: LD_ADDR_VAR 0 3
17029: PUSH
17030: LD_INT 1
17032: PUSH
17033: LD_INT 2
17035: PUSH
17036: LD_INT 3
17038: PUSH
17039: LD_INT 4
17041: PUSH
17042: LD_INT 5
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: LIST
17049: LIST
17050: LIST
17051: ST_TO_ADDR
17052: GO 17945
17054: LD_INT 4
17056: DOUBLE
17057: EQUAL
17058: IFTRUE 17062
17060: GO 17088
17062: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17063: LD_ADDR_VAR 0 3
17067: PUSH
17068: LD_INT 2
17070: PUSH
17071: LD_INT 3
17073: PUSH
17074: LD_INT 4
17076: PUSH
17077: LD_INT 5
17079: PUSH
17080: EMPTY
17081: LIST
17082: LIST
17083: LIST
17084: LIST
17085: ST_TO_ADDR
17086: GO 17945
17088: LD_INT 5
17090: DOUBLE
17091: EQUAL
17092: IFTRUE 17096
17094: GO 17122
17096: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17097: LD_ADDR_VAR 0 3
17101: PUSH
17102: LD_INT 2
17104: PUSH
17105: LD_INT 3
17107: PUSH
17108: LD_INT 4
17110: PUSH
17111: LD_INT 5
17113: PUSH
17114: EMPTY
17115: LIST
17116: LIST
17117: LIST
17118: LIST
17119: ST_TO_ADDR
17120: GO 17945
17122: LD_INT 9
17124: DOUBLE
17125: EQUAL
17126: IFTRUE 17130
17128: GO 17156
17130: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17131: LD_ADDR_VAR 0 3
17135: PUSH
17136: LD_INT 2
17138: PUSH
17139: LD_INT 3
17141: PUSH
17142: LD_INT 4
17144: PUSH
17145: LD_INT 5
17147: PUSH
17148: EMPTY
17149: LIST
17150: LIST
17151: LIST
17152: LIST
17153: ST_TO_ADDR
17154: GO 17945
17156: LD_INT 7
17158: DOUBLE
17159: EQUAL
17160: IFTRUE 17164
17162: GO 17190
17164: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17165: LD_ADDR_VAR 0 3
17169: PUSH
17170: LD_INT 2
17172: PUSH
17173: LD_INT 3
17175: PUSH
17176: LD_INT 4
17178: PUSH
17179: LD_INT 5
17181: PUSH
17182: EMPTY
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: ST_TO_ADDR
17188: GO 17945
17190: LD_INT 12
17192: DOUBLE
17193: EQUAL
17194: IFTRUE 17198
17196: GO 17224
17198: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17199: LD_ADDR_VAR 0 3
17203: PUSH
17204: LD_INT 2
17206: PUSH
17207: LD_INT 3
17209: PUSH
17210: LD_INT 4
17212: PUSH
17213: LD_INT 5
17215: PUSH
17216: EMPTY
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: ST_TO_ADDR
17222: GO 17945
17224: LD_INT 13
17226: DOUBLE
17227: EQUAL
17228: IFTRUE 17232
17230: GO 17258
17232: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17233: LD_ADDR_VAR 0 3
17237: PUSH
17238: LD_INT 2
17240: PUSH
17241: LD_INT 3
17243: PUSH
17244: LD_INT 4
17246: PUSH
17247: LD_INT 5
17249: PUSH
17250: EMPTY
17251: LIST
17252: LIST
17253: LIST
17254: LIST
17255: ST_TO_ADDR
17256: GO 17945
17258: LD_INT 14
17260: DOUBLE
17261: EQUAL
17262: IFTRUE 17266
17264: GO 17284
17266: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17267: LD_ADDR_VAR 0 3
17271: PUSH
17272: LD_INT 4
17274: PUSH
17275: LD_INT 5
17277: PUSH
17278: EMPTY
17279: LIST
17280: LIST
17281: ST_TO_ADDR
17282: GO 17945
17284: LD_INT 6
17286: DOUBLE
17287: EQUAL
17288: IFTRUE 17292
17290: GO 17310
17292: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17293: LD_ADDR_VAR 0 3
17297: PUSH
17298: LD_INT 4
17300: PUSH
17301: LD_INT 5
17303: PUSH
17304: EMPTY
17305: LIST
17306: LIST
17307: ST_TO_ADDR
17308: GO 17945
17310: LD_INT 10
17312: DOUBLE
17313: EQUAL
17314: IFTRUE 17318
17316: GO 17336
17318: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
17319: LD_ADDR_VAR 0 3
17323: PUSH
17324: LD_INT 4
17326: PUSH
17327: LD_INT 5
17329: PUSH
17330: EMPTY
17331: LIST
17332: LIST
17333: ST_TO_ADDR
17334: GO 17945
17336: LD_INT 22
17338: DOUBLE
17339: EQUAL
17340: IFTRUE 17344
17342: GO 17370
17344: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
17345: LD_ADDR_VAR 0 3
17349: PUSH
17350: LD_INT 11
17352: PUSH
17353: LD_INT 12
17355: PUSH
17356: LD_INT 13
17358: PUSH
17359: LD_INT 14
17361: PUSH
17362: EMPTY
17363: LIST
17364: LIST
17365: LIST
17366: LIST
17367: ST_TO_ADDR
17368: GO 17945
17370: LD_INT 23
17372: DOUBLE
17373: EQUAL
17374: IFTRUE 17378
17376: GO 17404
17378: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
17379: LD_ADDR_VAR 0 3
17383: PUSH
17384: LD_INT 11
17386: PUSH
17387: LD_INT 12
17389: PUSH
17390: LD_INT 13
17392: PUSH
17393: LD_INT 14
17395: PUSH
17396: EMPTY
17397: LIST
17398: LIST
17399: LIST
17400: LIST
17401: ST_TO_ADDR
17402: GO 17945
17404: LD_INT 24
17406: DOUBLE
17407: EQUAL
17408: IFTRUE 17412
17410: GO 17438
17412: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17413: LD_ADDR_VAR 0 3
17417: PUSH
17418: LD_INT 11
17420: PUSH
17421: LD_INT 12
17423: PUSH
17424: LD_INT 13
17426: PUSH
17427: LD_INT 14
17429: PUSH
17430: EMPTY
17431: LIST
17432: LIST
17433: LIST
17434: LIST
17435: ST_TO_ADDR
17436: GO 17945
17438: LD_INT 30
17440: DOUBLE
17441: EQUAL
17442: IFTRUE 17446
17444: GO 17472
17446: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17447: LD_ADDR_VAR 0 3
17451: PUSH
17452: LD_INT 11
17454: PUSH
17455: LD_INT 12
17457: PUSH
17458: LD_INT 13
17460: PUSH
17461: LD_INT 14
17463: PUSH
17464: EMPTY
17465: LIST
17466: LIST
17467: LIST
17468: LIST
17469: ST_TO_ADDR
17470: GO 17945
17472: LD_INT 25
17474: DOUBLE
17475: EQUAL
17476: IFTRUE 17480
17478: GO 17498
17480: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17481: LD_ADDR_VAR 0 3
17485: PUSH
17486: LD_INT 13
17488: PUSH
17489: LD_INT 14
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: ST_TO_ADDR
17496: GO 17945
17498: LD_INT 27
17500: DOUBLE
17501: EQUAL
17502: IFTRUE 17506
17504: GO 17524
17506: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17507: LD_ADDR_VAR 0 3
17511: PUSH
17512: LD_INT 13
17514: PUSH
17515: LD_INT 14
17517: PUSH
17518: EMPTY
17519: LIST
17520: LIST
17521: ST_TO_ADDR
17522: GO 17945
17524: LD_INT 28
17526: DOUBLE
17527: EQUAL
17528: IFTRUE 17532
17530: GO 17550
17532: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17533: LD_ADDR_VAR 0 3
17537: PUSH
17538: LD_INT 13
17540: PUSH
17541: LD_INT 14
17543: PUSH
17544: EMPTY
17545: LIST
17546: LIST
17547: ST_TO_ADDR
17548: GO 17945
17550: LD_INT 29
17552: DOUBLE
17553: EQUAL
17554: IFTRUE 17558
17556: GO 17576
17558: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17559: LD_ADDR_VAR 0 3
17563: PUSH
17564: LD_INT 13
17566: PUSH
17567: LD_INT 14
17569: PUSH
17570: EMPTY
17571: LIST
17572: LIST
17573: ST_TO_ADDR
17574: GO 17945
17576: LD_INT 31
17578: DOUBLE
17579: EQUAL
17580: IFTRUE 17584
17582: GO 17602
17584: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17585: LD_ADDR_VAR 0 3
17589: PUSH
17590: LD_INT 13
17592: PUSH
17593: LD_INT 14
17595: PUSH
17596: EMPTY
17597: LIST
17598: LIST
17599: ST_TO_ADDR
17600: GO 17945
17602: LD_INT 26
17604: DOUBLE
17605: EQUAL
17606: IFTRUE 17610
17608: GO 17628
17610: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17611: LD_ADDR_VAR 0 3
17615: PUSH
17616: LD_INT 13
17618: PUSH
17619: LD_INT 14
17621: PUSH
17622: EMPTY
17623: LIST
17624: LIST
17625: ST_TO_ADDR
17626: GO 17945
17628: LD_INT 42
17630: DOUBLE
17631: EQUAL
17632: IFTRUE 17636
17634: GO 17662
17636: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17637: LD_ADDR_VAR 0 3
17641: PUSH
17642: LD_INT 21
17644: PUSH
17645: LD_INT 22
17647: PUSH
17648: LD_INT 23
17650: PUSH
17651: LD_INT 24
17653: PUSH
17654: EMPTY
17655: LIST
17656: LIST
17657: LIST
17658: LIST
17659: ST_TO_ADDR
17660: GO 17945
17662: LD_INT 43
17664: DOUBLE
17665: EQUAL
17666: IFTRUE 17670
17668: GO 17696
17670: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17671: LD_ADDR_VAR 0 3
17675: PUSH
17676: LD_INT 21
17678: PUSH
17679: LD_INT 22
17681: PUSH
17682: LD_INT 23
17684: PUSH
17685: LD_INT 24
17687: PUSH
17688: EMPTY
17689: LIST
17690: LIST
17691: LIST
17692: LIST
17693: ST_TO_ADDR
17694: GO 17945
17696: LD_INT 44
17698: DOUBLE
17699: EQUAL
17700: IFTRUE 17704
17702: GO 17730
17704: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17705: LD_ADDR_VAR 0 3
17709: PUSH
17710: LD_INT 21
17712: PUSH
17713: LD_INT 22
17715: PUSH
17716: LD_INT 23
17718: PUSH
17719: LD_INT 24
17721: PUSH
17722: EMPTY
17723: LIST
17724: LIST
17725: LIST
17726: LIST
17727: ST_TO_ADDR
17728: GO 17945
17730: LD_INT 45
17732: DOUBLE
17733: EQUAL
17734: IFTRUE 17738
17736: GO 17764
17738: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17739: LD_ADDR_VAR 0 3
17743: PUSH
17744: LD_INT 21
17746: PUSH
17747: LD_INT 22
17749: PUSH
17750: LD_INT 23
17752: PUSH
17753: LD_INT 24
17755: PUSH
17756: EMPTY
17757: LIST
17758: LIST
17759: LIST
17760: LIST
17761: ST_TO_ADDR
17762: GO 17945
17764: LD_INT 49
17766: DOUBLE
17767: EQUAL
17768: IFTRUE 17772
17770: GO 17798
17772: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17773: LD_ADDR_VAR 0 3
17777: PUSH
17778: LD_INT 21
17780: PUSH
17781: LD_INT 22
17783: PUSH
17784: LD_INT 23
17786: PUSH
17787: LD_INT 24
17789: PUSH
17790: EMPTY
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: ST_TO_ADDR
17796: GO 17945
17798: LD_INT 51
17800: DOUBLE
17801: EQUAL
17802: IFTRUE 17806
17804: GO 17832
17806: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
17807: LD_ADDR_VAR 0 3
17811: PUSH
17812: LD_INT 21
17814: PUSH
17815: LD_INT 22
17817: PUSH
17818: LD_INT 23
17820: PUSH
17821: LD_INT 24
17823: PUSH
17824: EMPTY
17825: LIST
17826: LIST
17827: LIST
17828: LIST
17829: ST_TO_ADDR
17830: GO 17945
17832: LD_INT 52
17834: DOUBLE
17835: EQUAL
17836: IFTRUE 17840
17838: GO 17866
17840: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
17841: LD_ADDR_VAR 0 3
17845: PUSH
17846: LD_INT 21
17848: PUSH
17849: LD_INT 22
17851: PUSH
17852: LD_INT 23
17854: PUSH
17855: LD_INT 24
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: LIST
17862: LIST
17863: ST_TO_ADDR
17864: GO 17945
17866: LD_INT 53
17868: DOUBLE
17869: EQUAL
17870: IFTRUE 17874
17872: GO 17892
17874: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
17875: LD_ADDR_VAR 0 3
17879: PUSH
17880: LD_INT 23
17882: PUSH
17883: LD_INT 24
17885: PUSH
17886: EMPTY
17887: LIST
17888: LIST
17889: ST_TO_ADDR
17890: GO 17945
17892: LD_INT 46
17894: DOUBLE
17895: EQUAL
17896: IFTRUE 17900
17898: GO 17918
17900: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
17901: LD_ADDR_VAR 0 3
17905: PUSH
17906: LD_INT 23
17908: PUSH
17909: LD_INT 24
17911: PUSH
17912: EMPTY
17913: LIST
17914: LIST
17915: ST_TO_ADDR
17916: GO 17945
17918: LD_INT 47
17920: DOUBLE
17921: EQUAL
17922: IFTRUE 17926
17924: GO 17944
17926: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17927: LD_ADDR_VAR 0 3
17931: PUSH
17932: LD_INT 23
17934: PUSH
17935: LD_INT 24
17937: PUSH
17938: EMPTY
17939: LIST
17940: LIST
17941: ST_TO_ADDR
17942: GO 17945
17944: POP
// result := ( chassis in result ) ;
17945: LD_ADDR_VAR 0 3
17949: PUSH
17950: LD_VAR 0 1
17954: PUSH
17955: LD_VAR 0 3
17959: IN
17960: ST_TO_ADDR
// end ;
17961: LD_VAR 0 3
17965: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
17966: LD_INT 0
17968: PPUSH
17969: PPUSH
17970: PPUSH
17971: PPUSH
17972: PPUSH
17973: PPUSH
17974: PPUSH
// result := array ;
17975: LD_ADDR_VAR 0 5
17979: PUSH
17980: LD_VAR 0 1
17984: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
17985: LD_VAR 0 1
17989: NOT
17990: PUSH
17991: LD_VAR 0 2
17995: NOT
17996: OR
17997: PUSH
17998: LD_VAR 0 3
18002: NOT
18003: OR
18004: PUSH
18005: LD_VAR 0 2
18009: PUSH
18010: LD_VAR 0 1
18014: GREATER
18015: OR
18016: PUSH
18017: LD_VAR 0 3
18021: PUSH
18022: LD_VAR 0 1
18026: GREATER
18027: OR
18028: IFFALSE 18032
// exit ;
18030: GO 18328
// if direction then
18032: LD_VAR 0 4
18036: IFFALSE 18100
// begin d := 1 ;
18038: LD_ADDR_VAR 0 9
18042: PUSH
18043: LD_INT 1
18045: ST_TO_ADDR
// if i_from > i_to then
18046: LD_VAR 0 2
18050: PUSH
18051: LD_VAR 0 3
18055: GREATER
18056: IFFALSE 18082
// length := ( array - i_from ) + i_to else
18058: LD_ADDR_VAR 0 11
18062: PUSH
18063: LD_VAR 0 1
18067: PUSH
18068: LD_VAR 0 2
18072: MINUS
18073: PUSH
18074: LD_VAR 0 3
18078: PLUS
18079: ST_TO_ADDR
18080: GO 18098
// length := i_to - i_from ;
18082: LD_ADDR_VAR 0 11
18086: PUSH
18087: LD_VAR 0 3
18091: PUSH
18092: LD_VAR 0 2
18096: MINUS
18097: ST_TO_ADDR
// end else
18098: GO 18161
// begin d := - 1 ;
18100: LD_ADDR_VAR 0 9
18104: PUSH
18105: LD_INT 1
18107: NEG
18108: ST_TO_ADDR
// if i_from > i_to then
18109: LD_VAR 0 2
18113: PUSH
18114: LD_VAR 0 3
18118: GREATER
18119: IFFALSE 18139
// length := i_from - i_to else
18121: LD_ADDR_VAR 0 11
18125: PUSH
18126: LD_VAR 0 2
18130: PUSH
18131: LD_VAR 0 3
18135: MINUS
18136: ST_TO_ADDR
18137: GO 18161
// length := ( array - i_to ) + i_from ;
18139: LD_ADDR_VAR 0 11
18143: PUSH
18144: LD_VAR 0 1
18148: PUSH
18149: LD_VAR 0 3
18153: MINUS
18154: PUSH
18155: LD_VAR 0 2
18159: PLUS
18160: ST_TO_ADDR
// end ; if not length then
18161: LD_VAR 0 11
18165: NOT
18166: IFFALSE 18170
// exit ;
18168: GO 18328
// tmp := array ;
18170: LD_ADDR_VAR 0 10
18174: PUSH
18175: LD_VAR 0 1
18179: ST_TO_ADDR
// for i = 1 to length do
18180: LD_ADDR_VAR 0 6
18184: PUSH
18185: DOUBLE
18186: LD_INT 1
18188: DEC
18189: ST_TO_ADDR
18190: LD_VAR 0 11
18194: PUSH
18195: FOR_TO
18196: IFFALSE 18316
// begin for j = 1 to array do
18198: LD_ADDR_VAR 0 7
18202: PUSH
18203: DOUBLE
18204: LD_INT 1
18206: DEC
18207: ST_TO_ADDR
18208: LD_VAR 0 1
18212: PUSH
18213: FOR_TO
18214: IFFALSE 18302
// begin k := j + d ;
18216: LD_ADDR_VAR 0 8
18220: PUSH
18221: LD_VAR 0 7
18225: PUSH
18226: LD_VAR 0 9
18230: PLUS
18231: ST_TO_ADDR
// if k > array then
18232: LD_VAR 0 8
18236: PUSH
18237: LD_VAR 0 1
18241: GREATER
18242: IFFALSE 18252
// k := 1 ;
18244: LD_ADDR_VAR 0 8
18248: PUSH
18249: LD_INT 1
18251: ST_TO_ADDR
// if not k then
18252: LD_VAR 0 8
18256: NOT
18257: IFFALSE 18269
// k := array ;
18259: LD_ADDR_VAR 0 8
18263: PUSH
18264: LD_VAR 0 1
18268: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18269: LD_ADDR_VAR 0 10
18273: PUSH
18274: LD_VAR 0 10
18278: PPUSH
18279: LD_VAR 0 8
18283: PPUSH
18284: LD_VAR 0 1
18288: PUSH
18289: LD_VAR 0 7
18293: ARRAY
18294: PPUSH
18295: CALL_OW 1
18299: ST_TO_ADDR
// end ;
18300: GO 18213
18302: POP
18303: POP
// array := tmp ;
18304: LD_ADDR_VAR 0 1
18308: PUSH
18309: LD_VAR 0 10
18313: ST_TO_ADDR
// end ;
18314: GO 18195
18316: POP
18317: POP
// result := array ;
18318: LD_ADDR_VAR 0 5
18322: PUSH
18323: LD_VAR 0 1
18327: ST_TO_ADDR
// end ;
18328: LD_VAR 0 5
18332: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
18333: LD_INT 0
18335: PPUSH
18336: PPUSH
// result := 0 ;
18337: LD_ADDR_VAR 0 3
18341: PUSH
18342: LD_INT 0
18344: ST_TO_ADDR
// if not array or not value in array then
18345: LD_VAR 0 1
18349: NOT
18350: PUSH
18351: LD_VAR 0 2
18355: PUSH
18356: LD_VAR 0 1
18360: IN
18361: NOT
18362: OR
18363: IFFALSE 18367
// exit ;
18365: GO 18421
// for i = 1 to array do
18367: LD_ADDR_VAR 0 4
18371: PUSH
18372: DOUBLE
18373: LD_INT 1
18375: DEC
18376: ST_TO_ADDR
18377: LD_VAR 0 1
18381: PUSH
18382: FOR_TO
18383: IFFALSE 18419
// if value = array [ i ] then
18385: LD_VAR 0 2
18389: PUSH
18390: LD_VAR 0 1
18394: PUSH
18395: LD_VAR 0 4
18399: ARRAY
18400: EQUAL
18401: IFFALSE 18417
// begin result := i ;
18403: LD_ADDR_VAR 0 3
18407: PUSH
18408: LD_VAR 0 4
18412: ST_TO_ADDR
// exit ;
18413: POP
18414: POP
18415: GO 18421
// end ;
18417: GO 18382
18419: POP
18420: POP
// end ;
18421: LD_VAR 0 3
18425: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18426: LD_INT 0
18428: PPUSH
// vc_chassis := chassis ;
18429: LD_ADDR_OWVAR 37
18433: PUSH
18434: LD_VAR 0 1
18438: ST_TO_ADDR
// vc_engine := engine ;
18439: LD_ADDR_OWVAR 39
18443: PUSH
18444: LD_VAR 0 2
18448: ST_TO_ADDR
// vc_control := control ;
18449: LD_ADDR_OWVAR 38
18453: PUSH
18454: LD_VAR 0 3
18458: ST_TO_ADDR
// vc_weapon := weapon ;
18459: LD_ADDR_OWVAR 40
18463: PUSH
18464: LD_VAR 0 4
18468: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18469: LD_ADDR_OWVAR 41
18473: PUSH
18474: LD_VAR 0 5
18478: ST_TO_ADDR
// end ;
18479: LD_VAR 0 6
18483: RET
// export function WantPlant ( unit ) ; var task ; begin
18484: LD_INT 0
18486: PPUSH
18487: PPUSH
// result := false ;
18488: LD_ADDR_VAR 0 2
18492: PUSH
18493: LD_INT 0
18495: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18496: LD_ADDR_VAR 0 3
18500: PUSH
18501: LD_VAR 0 1
18505: PPUSH
18506: CALL_OW 437
18510: ST_TO_ADDR
// if task then
18511: LD_VAR 0 3
18515: IFFALSE 18543
// if task [ 1 ] [ 1 ] = p then
18517: LD_VAR 0 3
18521: PUSH
18522: LD_INT 1
18524: ARRAY
18525: PUSH
18526: LD_INT 1
18528: ARRAY
18529: PUSH
18530: LD_STRING p
18532: EQUAL
18533: IFFALSE 18543
// result := true ;
18535: LD_ADDR_VAR 0 2
18539: PUSH
18540: LD_INT 1
18542: ST_TO_ADDR
// end ;
18543: LD_VAR 0 2
18547: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18548: LD_INT 0
18550: PPUSH
18551: PPUSH
18552: PPUSH
18553: PPUSH
// if pos < 1 then
18554: LD_VAR 0 2
18558: PUSH
18559: LD_INT 1
18561: LESS
18562: IFFALSE 18566
// exit ;
18564: GO 18869
// if pos = 1 then
18566: LD_VAR 0 2
18570: PUSH
18571: LD_INT 1
18573: EQUAL
18574: IFFALSE 18607
// result := Replace ( arr , pos [ 1 ] , value ) else
18576: LD_ADDR_VAR 0 4
18580: PUSH
18581: LD_VAR 0 1
18585: PPUSH
18586: LD_VAR 0 2
18590: PUSH
18591: LD_INT 1
18593: ARRAY
18594: PPUSH
18595: LD_VAR 0 3
18599: PPUSH
18600: CALL_OW 1
18604: ST_TO_ADDR
18605: GO 18869
// begin tmp := arr ;
18607: LD_ADDR_VAR 0 6
18611: PUSH
18612: LD_VAR 0 1
18616: ST_TO_ADDR
// s_arr := [ tmp ] ;
18617: LD_ADDR_VAR 0 7
18621: PUSH
18622: LD_VAR 0 6
18626: PUSH
18627: EMPTY
18628: LIST
18629: ST_TO_ADDR
// for i = 1 to pos - 1 do
18630: LD_ADDR_VAR 0 5
18634: PUSH
18635: DOUBLE
18636: LD_INT 1
18638: DEC
18639: ST_TO_ADDR
18640: LD_VAR 0 2
18644: PUSH
18645: LD_INT 1
18647: MINUS
18648: PUSH
18649: FOR_TO
18650: IFFALSE 18695
// begin tmp := tmp [ pos [ i ] ] ;
18652: LD_ADDR_VAR 0 6
18656: PUSH
18657: LD_VAR 0 6
18661: PUSH
18662: LD_VAR 0 2
18666: PUSH
18667: LD_VAR 0 5
18671: ARRAY
18672: ARRAY
18673: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18674: LD_ADDR_VAR 0 7
18678: PUSH
18679: LD_VAR 0 7
18683: PUSH
18684: LD_VAR 0 6
18688: PUSH
18689: EMPTY
18690: LIST
18691: ADD
18692: ST_TO_ADDR
// end ;
18693: GO 18649
18695: POP
18696: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18697: LD_ADDR_VAR 0 6
18701: PUSH
18702: LD_VAR 0 6
18706: PPUSH
18707: LD_VAR 0 2
18711: PUSH
18712: LD_VAR 0 2
18716: ARRAY
18717: PPUSH
18718: LD_VAR 0 3
18722: PPUSH
18723: CALL_OW 1
18727: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18728: LD_ADDR_VAR 0 7
18732: PUSH
18733: LD_VAR 0 7
18737: PPUSH
18738: LD_VAR 0 7
18742: PPUSH
18743: LD_VAR 0 6
18747: PPUSH
18748: CALL_OW 1
18752: ST_TO_ADDR
// for i = s_arr downto 2 do
18753: LD_ADDR_VAR 0 5
18757: PUSH
18758: DOUBLE
18759: LD_VAR 0 7
18763: INC
18764: ST_TO_ADDR
18765: LD_INT 2
18767: PUSH
18768: FOR_DOWNTO
18769: IFFALSE 18853
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18771: LD_ADDR_VAR 0 6
18775: PUSH
18776: LD_VAR 0 7
18780: PUSH
18781: LD_VAR 0 5
18785: PUSH
18786: LD_INT 1
18788: MINUS
18789: ARRAY
18790: PPUSH
18791: LD_VAR 0 2
18795: PUSH
18796: LD_VAR 0 5
18800: PUSH
18801: LD_INT 1
18803: MINUS
18804: ARRAY
18805: PPUSH
18806: LD_VAR 0 7
18810: PUSH
18811: LD_VAR 0 5
18815: ARRAY
18816: PPUSH
18817: CALL_OW 1
18821: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
18822: LD_ADDR_VAR 0 7
18826: PUSH
18827: LD_VAR 0 7
18831: PPUSH
18832: LD_VAR 0 5
18836: PUSH
18837: LD_INT 1
18839: MINUS
18840: PPUSH
18841: LD_VAR 0 6
18845: PPUSH
18846: CALL_OW 1
18850: ST_TO_ADDR
// end ;
18851: GO 18768
18853: POP
18854: POP
// result := s_arr [ 1 ] ;
18855: LD_ADDR_VAR 0 4
18859: PUSH
18860: LD_VAR 0 7
18864: PUSH
18865: LD_INT 1
18867: ARRAY
18868: ST_TO_ADDR
// end ; end ;
18869: LD_VAR 0 4
18873: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
18874: LD_INT 0
18876: PPUSH
18877: PPUSH
// if not list then
18878: LD_VAR 0 1
18882: NOT
18883: IFFALSE 18887
// exit ;
18885: GO 18978
// i := list [ pos1 ] ;
18887: LD_ADDR_VAR 0 5
18891: PUSH
18892: LD_VAR 0 1
18896: PUSH
18897: LD_VAR 0 2
18901: ARRAY
18902: ST_TO_ADDR
// if not i then
18903: LD_VAR 0 5
18907: NOT
18908: IFFALSE 18912
// exit ;
18910: GO 18978
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
18912: LD_ADDR_VAR 0 1
18916: PUSH
18917: LD_VAR 0 1
18921: PPUSH
18922: LD_VAR 0 2
18926: PPUSH
18927: LD_VAR 0 1
18931: PUSH
18932: LD_VAR 0 3
18936: ARRAY
18937: PPUSH
18938: CALL_OW 1
18942: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
18943: LD_ADDR_VAR 0 1
18947: PUSH
18948: LD_VAR 0 1
18952: PPUSH
18953: LD_VAR 0 3
18957: PPUSH
18958: LD_VAR 0 5
18962: PPUSH
18963: CALL_OW 1
18967: ST_TO_ADDR
// result := list ;
18968: LD_ADDR_VAR 0 4
18972: PUSH
18973: LD_VAR 0 1
18977: ST_TO_ADDR
// end ;
18978: LD_VAR 0 4
18982: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
18983: LD_INT 0
18985: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
18986: LD_ADDR_VAR 0 5
18990: PUSH
18991: LD_VAR 0 1
18995: PPUSH
18996: CALL_OW 250
19000: PPUSH
19001: LD_VAR 0 1
19005: PPUSH
19006: CALL_OW 251
19010: PPUSH
19011: LD_VAR 0 2
19015: PPUSH
19016: LD_VAR 0 3
19020: PPUSH
19021: LD_VAR 0 4
19025: PPUSH
19026: CALL 19036 0 5
19030: ST_TO_ADDR
// end ;
19031: LD_VAR 0 5
19035: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19036: LD_INT 0
19038: PPUSH
19039: PPUSH
19040: PPUSH
19041: PPUSH
// if not list then
19042: LD_VAR 0 3
19046: NOT
19047: IFFALSE 19051
// exit ;
19049: GO 19439
// result := [ ] ;
19051: LD_ADDR_VAR 0 6
19055: PUSH
19056: EMPTY
19057: ST_TO_ADDR
// for i in list do
19058: LD_ADDR_VAR 0 7
19062: PUSH
19063: LD_VAR 0 3
19067: PUSH
19068: FOR_IN
19069: IFFALSE 19271
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19071: LD_ADDR_VAR 0 9
19075: PUSH
19076: LD_VAR 0 7
19080: PPUSH
19081: LD_VAR 0 1
19085: PPUSH
19086: LD_VAR 0 2
19090: PPUSH
19091: CALL_OW 297
19095: ST_TO_ADDR
// if not result then
19096: LD_VAR 0 6
19100: NOT
19101: IFFALSE 19127
// result := [ [ i , tmp ] ] else
19103: LD_ADDR_VAR 0 6
19107: PUSH
19108: LD_VAR 0 7
19112: PUSH
19113: LD_VAR 0 9
19117: PUSH
19118: EMPTY
19119: LIST
19120: LIST
19121: PUSH
19122: EMPTY
19123: LIST
19124: ST_TO_ADDR
19125: GO 19269
// begin if result [ result ] [ 2 ] < tmp then
19127: LD_VAR 0 6
19131: PUSH
19132: LD_VAR 0 6
19136: ARRAY
19137: PUSH
19138: LD_INT 2
19140: ARRAY
19141: PUSH
19142: LD_VAR 0 9
19146: LESS
19147: IFFALSE 19189
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19149: LD_ADDR_VAR 0 6
19153: PUSH
19154: LD_VAR 0 6
19158: PPUSH
19159: LD_VAR 0 6
19163: PUSH
19164: LD_INT 1
19166: PLUS
19167: PPUSH
19168: LD_VAR 0 7
19172: PUSH
19173: LD_VAR 0 9
19177: PUSH
19178: EMPTY
19179: LIST
19180: LIST
19181: PPUSH
19182: CALL_OW 2
19186: ST_TO_ADDR
19187: GO 19269
// for j = 1 to result do
19189: LD_ADDR_VAR 0 8
19193: PUSH
19194: DOUBLE
19195: LD_INT 1
19197: DEC
19198: ST_TO_ADDR
19199: LD_VAR 0 6
19203: PUSH
19204: FOR_TO
19205: IFFALSE 19267
// begin if tmp < result [ j ] [ 2 ] then
19207: LD_VAR 0 9
19211: PUSH
19212: LD_VAR 0 6
19216: PUSH
19217: LD_VAR 0 8
19221: ARRAY
19222: PUSH
19223: LD_INT 2
19225: ARRAY
19226: LESS
19227: IFFALSE 19265
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19229: LD_ADDR_VAR 0 6
19233: PUSH
19234: LD_VAR 0 6
19238: PPUSH
19239: LD_VAR 0 8
19243: PPUSH
19244: LD_VAR 0 7
19248: PUSH
19249: LD_VAR 0 9
19253: PUSH
19254: EMPTY
19255: LIST
19256: LIST
19257: PPUSH
19258: CALL_OW 2
19262: ST_TO_ADDR
// break ;
19263: GO 19267
// end ; end ;
19265: GO 19204
19267: POP
19268: POP
// end ; end ;
19269: GO 19068
19271: POP
19272: POP
// if result and not asc then
19273: LD_VAR 0 6
19277: PUSH
19278: LD_VAR 0 4
19282: NOT
19283: AND
19284: IFFALSE 19359
// begin tmp := result ;
19286: LD_ADDR_VAR 0 9
19290: PUSH
19291: LD_VAR 0 6
19295: ST_TO_ADDR
// for i = tmp downto 1 do
19296: LD_ADDR_VAR 0 7
19300: PUSH
19301: DOUBLE
19302: LD_VAR 0 9
19306: INC
19307: ST_TO_ADDR
19308: LD_INT 1
19310: PUSH
19311: FOR_DOWNTO
19312: IFFALSE 19357
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
19314: LD_ADDR_VAR 0 6
19318: PUSH
19319: LD_VAR 0 6
19323: PPUSH
19324: LD_VAR 0 9
19328: PUSH
19329: LD_VAR 0 7
19333: MINUS
19334: PUSH
19335: LD_INT 1
19337: PLUS
19338: PPUSH
19339: LD_VAR 0 9
19343: PUSH
19344: LD_VAR 0 7
19348: ARRAY
19349: PPUSH
19350: CALL_OW 1
19354: ST_TO_ADDR
19355: GO 19311
19357: POP
19358: POP
// end ; tmp := [ ] ;
19359: LD_ADDR_VAR 0 9
19363: PUSH
19364: EMPTY
19365: ST_TO_ADDR
// if mode then
19366: LD_VAR 0 5
19370: IFFALSE 19439
// begin for i = 1 to result do
19372: LD_ADDR_VAR 0 7
19376: PUSH
19377: DOUBLE
19378: LD_INT 1
19380: DEC
19381: ST_TO_ADDR
19382: LD_VAR 0 6
19386: PUSH
19387: FOR_TO
19388: IFFALSE 19427
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19390: LD_ADDR_VAR 0 9
19394: PUSH
19395: LD_VAR 0 9
19399: PPUSH
19400: LD_VAR 0 7
19404: PPUSH
19405: LD_VAR 0 6
19409: PUSH
19410: LD_VAR 0 7
19414: ARRAY
19415: PUSH
19416: LD_INT 1
19418: ARRAY
19419: PPUSH
19420: CALL_OW 1
19424: ST_TO_ADDR
19425: GO 19387
19427: POP
19428: POP
// result := tmp ;
19429: LD_ADDR_VAR 0 6
19433: PUSH
19434: LD_VAR 0 9
19438: ST_TO_ADDR
// end ; end ;
19439: LD_VAR 0 6
19443: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19444: LD_INT 0
19446: PPUSH
19447: PPUSH
19448: PPUSH
19449: PPUSH
19450: PPUSH
19451: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19452: LD_ADDR_VAR 0 5
19456: PUSH
19457: LD_INT 0
19459: PUSH
19460: LD_INT 0
19462: PUSH
19463: LD_INT 0
19465: PUSH
19466: EMPTY
19467: PUSH
19468: EMPTY
19469: LIST
19470: LIST
19471: LIST
19472: LIST
19473: ST_TO_ADDR
// if not x or not y then
19474: LD_VAR 0 2
19478: NOT
19479: PUSH
19480: LD_VAR 0 3
19484: NOT
19485: OR
19486: IFFALSE 19490
// exit ;
19488: GO 21136
// if not range then
19490: LD_VAR 0 4
19494: NOT
19495: IFFALSE 19505
// range := 10 ;
19497: LD_ADDR_VAR 0 4
19501: PUSH
19502: LD_INT 10
19504: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19505: LD_ADDR_VAR 0 8
19509: PUSH
19510: LD_INT 81
19512: PUSH
19513: LD_VAR 0 1
19517: PUSH
19518: EMPTY
19519: LIST
19520: LIST
19521: PUSH
19522: LD_INT 92
19524: PUSH
19525: LD_VAR 0 2
19529: PUSH
19530: LD_VAR 0 3
19534: PUSH
19535: LD_VAR 0 4
19539: PUSH
19540: EMPTY
19541: LIST
19542: LIST
19543: LIST
19544: LIST
19545: PUSH
19546: LD_INT 3
19548: PUSH
19549: LD_INT 21
19551: PUSH
19552: LD_INT 3
19554: PUSH
19555: EMPTY
19556: LIST
19557: LIST
19558: PUSH
19559: EMPTY
19560: LIST
19561: LIST
19562: PUSH
19563: EMPTY
19564: LIST
19565: LIST
19566: LIST
19567: PPUSH
19568: CALL_OW 69
19572: ST_TO_ADDR
// if not tmp then
19573: LD_VAR 0 8
19577: NOT
19578: IFFALSE 19582
// exit ;
19580: GO 21136
// for i in tmp do
19582: LD_ADDR_VAR 0 6
19586: PUSH
19587: LD_VAR 0 8
19591: PUSH
19592: FOR_IN
19593: IFFALSE 21111
// begin points := [ 0 , 0 , 0 ] ;
19595: LD_ADDR_VAR 0 9
19599: PUSH
19600: LD_INT 0
19602: PUSH
19603: LD_INT 0
19605: PUSH
19606: LD_INT 0
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: LIST
19613: ST_TO_ADDR
// bpoints := 1 ;
19614: LD_ADDR_VAR 0 10
19618: PUSH
19619: LD_INT 1
19621: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19622: LD_VAR 0 6
19626: PPUSH
19627: CALL_OW 247
19631: PUSH
19632: LD_INT 1
19634: DOUBLE
19635: EQUAL
19636: IFTRUE 19640
19638: GO 20218
19640: POP
// begin if GetClass ( i ) = 1 then
19641: LD_VAR 0 6
19645: PPUSH
19646: CALL_OW 257
19650: PUSH
19651: LD_INT 1
19653: EQUAL
19654: IFFALSE 19675
// points := [ 10 , 5 , 3 ] ;
19656: LD_ADDR_VAR 0 9
19660: PUSH
19661: LD_INT 10
19663: PUSH
19664: LD_INT 5
19666: PUSH
19667: LD_INT 3
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: LIST
19674: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19675: LD_VAR 0 6
19679: PPUSH
19680: CALL_OW 257
19684: PUSH
19685: LD_INT 2
19687: PUSH
19688: LD_INT 3
19690: PUSH
19691: LD_INT 4
19693: PUSH
19694: EMPTY
19695: LIST
19696: LIST
19697: LIST
19698: IN
19699: IFFALSE 19720
// points := [ 3 , 2 , 1 ] ;
19701: LD_ADDR_VAR 0 9
19705: PUSH
19706: LD_INT 3
19708: PUSH
19709: LD_INT 2
19711: PUSH
19712: LD_INT 1
19714: PUSH
19715: EMPTY
19716: LIST
19717: LIST
19718: LIST
19719: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19720: LD_VAR 0 6
19724: PPUSH
19725: CALL_OW 257
19729: PUSH
19730: LD_INT 5
19732: EQUAL
19733: IFFALSE 19754
// points := [ 130 , 5 , 2 ] ;
19735: LD_ADDR_VAR 0 9
19739: PUSH
19740: LD_INT 130
19742: PUSH
19743: LD_INT 5
19745: PUSH
19746: LD_INT 2
19748: PUSH
19749: EMPTY
19750: LIST
19751: LIST
19752: LIST
19753: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19754: LD_VAR 0 6
19758: PPUSH
19759: CALL_OW 257
19763: PUSH
19764: LD_INT 8
19766: EQUAL
19767: IFFALSE 19788
// points := [ 35 , 35 , 30 ] ;
19769: LD_ADDR_VAR 0 9
19773: PUSH
19774: LD_INT 35
19776: PUSH
19777: LD_INT 35
19779: PUSH
19780: LD_INT 30
19782: PUSH
19783: EMPTY
19784: LIST
19785: LIST
19786: LIST
19787: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19788: LD_VAR 0 6
19792: PPUSH
19793: CALL_OW 257
19797: PUSH
19798: LD_INT 9
19800: EQUAL
19801: IFFALSE 19822
// points := [ 20 , 55 , 40 ] ;
19803: LD_ADDR_VAR 0 9
19807: PUSH
19808: LD_INT 20
19810: PUSH
19811: LD_INT 55
19813: PUSH
19814: LD_INT 40
19816: PUSH
19817: EMPTY
19818: LIST
19819: LIST
19820: LIST
19821: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
19822: LD_VAR 0 6
19826: PPUSH
19827: CALL_OW 257
19831: PUSH
19832: LD_INT 12
19834: PUSH
19835: LD_INT 16
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: IN
19842: IFFALSE 19863
// points := [ 5 , 3 , 2 ] ;
19844: LD_ADDR_VAR 0 9
19848: PUSH
19849: LD_INT 5
19851: PUSH
19852: LD_INT 3
19854: PUSH
19855: LD_INT 2
19857: PUSH
19858: EMPTY
19859: LIST
19860: LIST
19861: LIST
19862: ST_TO_ADDR
// if GetClass ( i ) = 17 then
19863: LD_VAR 0 6
19867: PPUSH
19868: CALL_OW 257
19872: PUSH
19873: LD_INT 17
19875: EQUAL
19876: IFFALSE 19897
// points := [ 100 , 50 , 75 ] ;
19878: LD_ADDR_VAR 0 9
19882: PUSH
19883: LD_INT 100
19885: PUSH
19886: LD_INT 50
19888: PUSH
19889: LD_INT 75
19891: PUSH
19892: EMPTY
19893: LIST
19894: LIST
19895: LIST
19896: ST_TO_ADDR
// if GetClass ( i ) = 15 then
19897: LD_VAR 0 6
19901: PPUSH
19902: CALL_OW 257
19906: PUSH
19907: LD_INT 15
19909: EQUAL
19910: IFFALSE 19931
// points := [ 10 , 5 , 3 ] ;
19912: LD_ADDR_VAR 0 9
19916: PUSH
19917: LD_INT 10
19919: PUSH
19920: LD_INT 5
19922: PUSH
19923: LD_INT 3
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: LIST
19930: ST_TO_ADDR
// if GetClass ( i ) = 14 then
19931: LD_VAR 0 6
19935: PPUSH
19936: CALL_OW 257
19940: PUSH
19941: LD_INT 14
19943: EQUAL
19944: IFFALSE 19965
// points := [ 10 , 0 , 0 ] ;
19946: LD_ADDR_VAR 0 9
19950: PUSH
19951: LD_INT 10
19953: PUSH
19954: LD_INT 0
19956: PUSH
19957: LD_INT 0
19959: PUSH
19960: EMPTY
19961: LIST
19962: LIST
19963: LIST
19964: ST_TO_ADDR
// if GetClass ( i ) = 11 then
19965: LD_VAR 0 6
19969: PPUSH
19970: CALL_OW 257
19974: PUSH
19975: LD_INT 11
19977: EQUAL
19978: IFFALSE 19999
// points := [ 30 , 10 , 5 ] ;
19980: LD_ADDR_VAR 0 9
19984: PUSH
19985: LD_INT 30
19987: PUSH
19988: LD_INT 10
19990: PUSH
19991: LD_INT 5
19993: PUSH
19994: EMPTY
19995: LIST
19996: LIST
19997: LIST
19998: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
19999: LD_VAR 0 1
20003: PPUSH
20004: LD_INT 5
20006: PPUSH
20007: CALL_OW 321
20011: PUSH
20012: LD_INT 2
20014: EQUAL
20015: IFFALSE 20032
// bpoints := bpoints * 1.8 ;
20017: LD_ADDR_VAR 0 10
20021: PUSH
20022: LD_VAR 0 10
20026: PUSH
20027: LD_REAL  1.80000000000000E+0000
20030: MUL
20031: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20032: LD_VAR 0 6
20036: PPUSH
20037: CALL_OW 257
20041: PUSH
20042: LD_INT 1
20044: PUSH
20045: LD_INT 2
20047: PUSH
20048: LD_INT 3
20050: PUSH
20051: LD_INT 4
20053: PUSH
20054: EMPTY
20055: LIST
20056: LIST
20057: LIST
20058: LIST
20059: IN
20060: PUSH
20061: LD_VAR 0 1
20065: PPUSH
20066: LD_INT 51
20068: PPUSH
20069: CALL_OW 321
20073: PUSH
20074: LD_INT 2
20076: EQUAL
20077: AND
20078: IFFALSE 20095
// bpoints := bpoints * 1.2 ;
20080: LD_ADDR_VAR 0 10
20084: PUSH
20085: LD_VAR 0 10
20089: PUSH
20090: LD_REAL  1.20000000000000E+0000
20093: MUL
20094: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20095: LD_VAR 0 6
20099: PPUSH
20100: CALL_OW 257
20104: PUSH
20105: LD_INT 5
20107: PUSH
20108: LD_INT 7
20110: PUSH
20111: LD_INT 9
20113: PUSH
20114: EMPTY
20115: LIST
20116: LIST
20117: LIST
20118: IN
20119: PUSH
20120: LD_VAR 0 1
20124: PPUSH
20125: LD_INT 52
20127: PPUSH
20128: CALL_OW 321
20132: PUSH
20133: LD_INT 2
20135: EQUAL
20136: AND
20137: IFFALSE 20154
// bpoints := bpoints * 1.5 ;
20139: LD_ADDR_VAR 0 10
20143: PUSH
20144: LD_VAR 0 10
20148: PUSH
20149: LD_REAL  1.50000000000000E+0000
20152: MUL
20153: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20154: LD_VAR 0 1
20158: PPUSH
20159: LD_INT 66
20161: PPUSH
20162: CALL_OW 321
20166: PUSH
20167: LD_INT 2
20169: EQUAL
20170: IFFALSE 20187
// bpoints := bpoints * 1.1 ;
20172: LD_ADDR_VAR 0 10
20176: PUSH
20177: LD_VAR 0 10
20181: PUSH
20182: LD_REAL  1.10000000000000E+0000
20185: MUL
20186: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20187: LD_ADDR_VAR 0 10
20191: PUSH
20192: LD_VAR 0 10
20196: PUSH
20197: LD_VAR 0 6
20201: PPUSH
20202: LD_INT 1
20204: PPUSH
20205: CALL_OW 259
20209: PUSH
20210: LD_REAL  1.15000000000000E+0000
20213: MUL
20214: MUL
20215: ST_TO_ADDR
// end ; unit_vehicle :
20216: GO 21040
20218: LD_INT 2
20220: DOUBLE
20221: EQUAL
20222: IFTRUE 20226
20224: GO 21028
20226: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20227: LD_VAR 0 6
20231: PPUSH
20232: CALL_OW 264
20236: PUSH
20237: LD_INT 2
20239: PUSH
20240: LD_INT 42
20242: PUSH
20243: LD_INT 24
20245: PUSH
20246: EMPTY
20247: LIST
20248: LIST
20249: LIST
20250: IN
20251: IFFALSE 20272
// points := [ 25 , 5 , 3 ] ;
20253: LD_ADDR_VAR 0 9
20257: PUSH
20258: LD_INT 25
20260: PUSH
20261: LD_INT 5
20263: PUSH
20264: LD_INT 3
20266: PUSH
20267: EMPTY
20268: LIST
20269: LIST
20270: LIST
20271: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20272: LD_VAR 0 6
20276: PPUSH
20277: CALL_OW 264
20281: PUSH
20282: LD_INT 4
20284: PUSH
20285: LD_INT 43
20287: PUSH
20288: LD_INT 25
20290: PUSH
20291: EMPTY
20292: LIST
20293: LIST
20294: LIST
20295: IN
20296: IFFALSE 20317
// points := [ 40 , 15 , 5 ] ;
20298: LD_ADDR_VAR 0 9
20302: PUSH
20303: LD_INT 40
20305: PUSH
20306: LD_INT 15
20308: PUSH
20309: LD_INT 5
20311: PUSH
20312: EMPTY
20313: LIST
20314: LIST
20315: LIST
20316: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
20317: LD_VAR 0 6
20321: PPUSH
20322: CALL_OW 264
20326: PUSH
20327: LD_INT 3
20329: PUSH
20330: LD_INT 23
20332: PUSH
20333: EMPTY
20334: LIST
20335: LIST
20336: IN
20337: IFFALSE 20358
// points := [ 7 , 25 , 8 ] ;
20339: LD_ADDR_VAR 0 9
20343: PUSH
20344: LD_INT 7
20346: PUSH
20347: LD_INT 25
20349: PUSH
20350: LD_INT 8
20352: PUSH
20353: EMPTY
20354: LIST
20355: LIST
20356: LIST
20357: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
20358: LD_VAR 0 6
20362: PPUSH
20363: CALL_OW 264
20367: PUSH
20368: LD_INT 5
20370: PUSH
20371: LD_INT 27
20373: PUSH
20374: LD_INT 44
20376: PUSH
20377: EMPTY
20378: LIST
20379: LIST
20380: LIST
20381: IN
20382: IFFALSE 20403
// points := [ 14 , 50 , 16 ] ;
20384: LD_ADDR_VAR 0 9
20388: PUSH
20389: LD_INT 14
20391: PUSH
20392: LD_INT 50
20394: PUSH
20395: LD_INT 16
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: LIST
20402: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20403: LD_VAR 0 6
20407: PPUSH
20408: CALL_OW 264
20412: PUSH
20413: LD_INT 6
20415: PUSH
20416: LD_INT 46
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: IN
20423: IFFALSE 20444
// points := [ 32 , 120 , 70 ] ;
20425: LD_ADDR_VAR 0 9
20429: PUSH
20430: LD_INT 32
20432: PUSH
20433: LD_INT 120
20435: PUSH
20436: LD_INT 70
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: LIST
20443: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
20444: LD_VAR 0 6
20448: PPUSH
20449: CALL_OW 264
20453: PUSH
20454: LD_INT 7
20456: PUSH
20457: LD_INT 28
20459: PUSH
20460: LD_INT 45
20462: PUSH
20463: EMPTY
20464: LIST
20465: LIST
20466: LIST
20467: IN
20468: IFFALSE 20489
// points := [ 35 , 20 , 45 ] ;
20470: LD_ADDR_VAR 0 9
20474: PUSH
20475: LD_INT 35
20477: PUSH
20478: LD_INT 20
20480: PUSH
20481: LD_INT 45
20483: PUSH
20484: EMPTY
20485: LIST
20486: LIST
20487: LIST
20488: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20489: LD_VAR 0 6
20493: PPUSH
20494: CALL_OW 264
20498: PUSH
20499: LD_INT 47
20501: PUSH
20502: EMPTY
20503: LIST
20504: IN
20505: IFFALSE 20526
// points := [ 67 , 45 , 75 ] ;
20507: LD_ADDR_VAR 0 9
20511: PUSH
20512: LD_INT 67
20514: PUSH
20515: LD_INT 45
20517: PUSH
20518: LD_INT 75
20520: PUSH
20521: EMPTY
20522: LIST
20523: LIST
20524: LIST
20525: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20526: LD_VAR 0 6
20530: PPUSH
20531: CALL_OW 264
20535: PUSH
20536: LD_INT 26
20538: PUSH
20539: EMPTY
20540: LIST
20541: IN
20542: IFFALSE 20563
// points := [ 120 , 30 , 80 ] ;
20544: LD_ADDR_VAR 0 9
20548: PUSH
20549: LD_INT 120
20551: PUSH
20552: LD_INT 30
20554: PUSH
20555: LD_INT 80
20557: PUSH
20558: EMPTY
20559: LIST
20560: LIST
20561: LIST
20562: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20563: LD_VAR 0 6
20567: PPUSH
20568: CALL_OW 264
20572: PUSH
20573: LD_INT 22
20575: PUSH
20576: EMPTY
20577: LIST
20578: IN
20579: IFFALSE 20600
// points := [ 40 , 1 , 1 ] ;
20581: LD_ADDR_VAR 0 9
20585: PUSH
20586: LD_INT 40
20588: PUSH
20589: LD_INT 1
20591: PUSH
20592: LD_INT 1
20594: PUSH
20595: EMPTY
20596: LIST
20597: LIST
20598: LIST
20599: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20600: LD_VAR 0 6
20604: PPUSH
20605: CALL_OW 264
20609: PUSH
20610: LD_INT 29
20612: PUSH
20613: EMPTY
20614: LIST
20615: IN
20616: IFFALSE 20637
// points := [ 70 , 200 , 400 ] ;
20618: LD_ADDR_VAR 0 9
20622: PUSH
20623: LD_INT 70
20625: PUSH
20626: LD_INT 200
20628: PUSH
20629: LD_INT 400
20631: PUSH
20632: EMPTY
20633: LIST
20634: LIST
20635: LIST
20636: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20637: LD_VAR 0 6
20641: PPUSH
20642: CALL_OW 264
20646: PUSH
20647: LD_INT 14
20649: PUSH
20650: LD_INT 53
20652: PUSH
20653: EMPTY
20654: LIST
20655: LIST
20656: IN
20657: IFFALSE 20678
// points := [ 40 , 10 , 20 ] ;
20659: LD_ADDR_VAR 0 9
20663: PUSH
20664: LD_INT 40
20666: PUSH
20667: LD_INT 10
20669: PUSH
20670: LD_INT 20
20672: PUSH
20673: EMPTY
20674: LIST
20675: LIST
20676: LIST
20677: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20678: LD_VAR 0 6
20682: PPUSH
20683: CALL_OW 264
20687: PUSH
20688: LD_INT 9
20690: PUSH
20691: EMPTY
20692: LIST
20693: IN
20694: IFFALSE 20715
// points := [ 5 , 70 , 20 ] ;
20696: LD_ADDR_VAR 0 9
20700: PUSH
20701: LD_INT 5
20703: PUSH
20704: LD_INT 70
20706: PUSH
20707: LD_INT 20
20709: PUSH
20710: EMPTY
20711: LIST
20712: LIST
20713: LIST
20714: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20715: LD_VAR 0 6
20719: PPUSH
20720: CALL_OW 264
20724: PUSH
20725: LD_INT 10
20727: PUSH
20728: EMPTY
20729: LIST
20730: IN
20731: IFFALSE 20752
// points := [ 35 , 110 , 70 ] ;
20733: LD_ADDR_VAR 0 9
20737: PUSH
20738: LD_INT 35
20740: PUSH
20741: LD_INT 110
20743: PUSH
20744: LD_INT 70
20746: PUSH
20747: EMPTY
20748: LIST
20749: LIST
20750: LIST
20751: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20752: LD_VAR 0 6
20756: PPUSH
20757: CALL_OW 265
20761: PUSH
20762: LD_INT 25
20764: EQUAL
20765: IFFALSE 20786
// points := [ 80 , 65 , 100 ] ;
20767: LD_ADDR_VAR 0 9
20771: PUSH
20772: LD_INT 80
20774: PUSH
20775: LD_INT 65
20777: PUSH
20778: LD_INT 100
20780: PUSH
20781: EMPTY
20782: LIST
20783: LIST
20784: LIST
20785: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20786: LD_VAR 0 6
20790: PPUSH
20791: CALL_OW 263
20795: PUSH
20796: LD_INT 1
20798: EQUAL
20799: IFFALSE 20834
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
20801: LD_ADDR_VAR 0 10
20805: PUSH
20806: LD_VAR 0 10
20810: PUSH
20811: LD_VAR 0 6
20815: PPUSH
20816: CALL_OW 311
20820: PPUSH
20821: LD_INT 3
20823: PPUSH
20824: CALL_OW 259
20828: PUSH
20829: LD_INT 4
20831: MUL
20832: MUL
20833: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
20834: LD_VAR 0 6
20838: PPUSH
20839: CALL_OW 263
20843: PUSH
20844: LD_INT 2
20846: EQUAL
20847: IFFALSE 20898
// begin j := IsControledBy ( i ) ;
20849: LD_ADDR_VAR 0 7
20853: PUSH
20854: LD_VAR 0 6
20858: PPUSH
20859: CALL_OW 312
20863: ST_TO_ADDR
// if j then
20864: LD_VAR 0 7
20868: IFFALSE 20898
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
20870: LD_ADDR_VAR 0 10
20874: PUSH
20875: LD_VAR 0 10
20879: PUSH
20880: LD_VAR 0 7
20884: PPUSH
20885: LD_INT 3
20887: PPUSH
20888: CALL_OW 259
20892: PUSH
20893: LD_INT 3
20895: MUL
20896: MUL
20897: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
20898: LD_VAR 0 6
20902: PPUSH
20903: CALL_OW 264
20907: PUSH
20908: LD_INT 5
20910: PUSH
20911: LD_INT 6
20913: PUSH
20914: LD_INT 46
20916: PUSH
20917: LD_INT 44
20919: PUSH
20920: LD_INT 47
20922: PUSH
20923: LD_INT 45
20925: PUSH
20926: LD_INT 28
20928: PUSH
20929: LD_INT 7
20931: PUSH
20932: LD_INT 27
20934: PUSH
20935: LD_INT 29
20937: PUSH
20938: EMPTY
20939: LIST
20940: LIST
20941: LIST
20942: LIST
20943: LIST
20944: LIST
20945: LIST
20946: LIST
20947: LIST
20948: LIST
20949: IN
20950: PUSH
20951: LD_VAR 0 1
20955: PPUSH
20956: LD_INT 52
20958: PPUSH
20959: CALL_OW 321
20963: PUSH
20964: LD_INT 2
20966: EQUAL
20967: AND
20968: IFFALSE 20985
// bpoints := bpoints * 1.2 ;
20970: LD_ADDR_VAR 0 10
20974: PUSH
20975: LD_VAR 0 10
20979: PUSH
20980: LD_REAL  1.20000000000000E+0000
20983: MUL
20984: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
20985: LD_VAR 0 6
20989: PPUSH
20990: CALL_OW 264
20994: PUSH
20995: LD_INT 6
20997: PUSH
20998: LD_INT 46
21000: PUSH
21001: LD_INT 47
21003: PUSH
21004: EMPTY
21005: LIST
21006: LIST
21007: LIST
21008: IN
21009: IFFALSE 21026
// bpoints := bpoints * 1.2 ;
21011: LD_ADDR_VAR 0 10
21015: PUSH
21016: LD_VAR 0 10
21020: PUSH
21021: LD_REAL  1.20000000000000E+0000
21024: MUL
21025: ST_TO_ADDR
// end ; unit_building :
21026: GO 21040
21028: LD_INT 3
21030: DOUBLE
21031: EQUAL
21032: IFTRUE 21036
21034: GO 21039
21036: POP
// ; end ;
21037: GO 21040
21039: POP
// for j = 1 to 3 do
21040: LD_ADDR_VAR 0 7
21044: PUSH
21045: DOUBLE
21046: LD_INT 1
21048: DEC
21049: ST_TO_ADDR
21050: LD_INT 3
21052: PUSH
21053: FOR_TO
21054: IFFALSE 21107
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21056: LD_ADDR_VAR 0 5
21060: PUSH
21061: LD_VAR 0 5
21065: PPUSH
21066: LD_VAR 0 7
21070: PPUSH
21071: LD_VAR 0 5
21075: PUSH
21076: LD_VAR 0 7
21080: ARRAY
21081: PUSH
21082: LD_VAR 0 9
21086: PUSH
21087: LD_VAR 0 7
21091: ARRAY
21092: PUSH
21093: LD_VAR 0 10
21097: MUL
21098: PLUS
21099: PPUSH
21100: CALL_OW 1
21104: ST_TO_ADDR
21105: GO 21053
21107: POP
21108: POP
// end ;
21109: GO 19592
21111: POP
21112: POP
// result := Replace ( result , 4 , tmp ) ;
21113: LD_ADDR_VAR 0 5
21117: PUSH
21118: LD_VAR 0 5
21122: PPUSH
21123: LD_INT 4
21125: PPUSH
21126: LD_VAR 0 8
21130: PPUSH
21131: CALL_OW 1
21135: ST_TO_ADDR
// end ;
21136: LD_VAR 0 5
21140: RET
// export function DangerAtRange ( unit , range ) ; begin
21141: LD_INT 0
21143: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21144: LD_ADDR_VAR 0 3
21148: PUSH
21149: LD_VAR 0 1
21153: PPUSH
21154: CALL_OW 255
21158: PPUSH
21159: LD_VAR 0 1
21163: PPUSH
21164: CALL_OW 250
21168: PPUSH
21169: LD_VAR 0 1
21173: PPUSH
21174: CALL_OW 251
21178: PPUSH
21179: LD_VAR 0 2
21183: PPUSH
21184: CALL 19444 0 4
21188: ST_TO_ADDR
// end ;
21189: LD_VAR 0 3
21193: RET
// export function DangerInArea ( side , area ) ; begin
21194: LD_INT 0
21196: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21197: LD_ADDR_VAR 0 3
21201: PUSH
21202: LD_VAR 0 2
21206: PPUSH
21207: LD_INT 81
21209: PUSH
21210: LD_VAR 0 1
21214: PUSH
21215: EMPTY
21216: LIST
21217: LIST
21218: PPUSH
21219: CALL_OW 70
21223: ST_TO_ADDR
// end ;
21224: LD_VAR 0 3
21228: RET
// export function IsExtension ( b ) ; begin
21229: LD_INT 0
21231: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21232: LD_ADDR_VAR 0 2
21236: PUSH
21237: LD_VAR 0 1
21241: PUSH
21242: LD_INT 23
21244: PUSH
21245: LD_INT 20
21247: PUSH
21248: LD_INT 22
21250: PUSH
21251: LD_INT 17
21253: PUSH
21254: LD_INT 24
21256: PUSH
21257: LD_INT 21
21259: PUSH
21260: LD_INT 19
21262: PUSH
21263: LD_INT 16
21265: PUSH
21266: LD_INT 25
21268: PUSH
21269: LD_INT 18
21271: PUSH
21272: EMPTY
21273: LIST
21274: LIST
21275: LIST
21276: LIST
21277: LIST
21278: LIST
21279: LIST
21280: LIST
21281: LIST
21282: LIST
21283: IN
21284: ST_TO_ADDR
// end ;
21285: LD_VAR 0 2
21289: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
21290: LD_INT 0
21292: PPUSH
21293: PPUSH
21294: PPUSH
// result := [ ] ;
21295: LD_ADDR_VAR 0 4
21299: PUSH
21300: EMPTY
21301: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21302: LD_ADDR_VAR 0 5
21306: PUSH
21307: LD_VAR 0 2
21311: PPUSH
21312: LD_INT 21
21314: PUSH
21315: LD_INT 3
21317: PUSH
21318: EMPTY
21319: LIST
21320: LIST
21321: PPUSH
21322: CALL_OW 70
21326: ST_TO_ADDR
// if not tmp then
21327: LD_VAR 0 5
21331: NOT
21332: IFFALSE 21336
// exit ;
21334: GO 21400
// if checkLink then
21336: LD_VAR 0 3
21340: IFFALSE 21390
// begin for i in tmp do
21342: LD_ADDR_VAR 0 6
21346: PUSH
21347: LD_VAR 0 5
21351: PUSH
21352: FOR_IN
21353: IFFALSE 21388
// if GetBase ( i ) <> base then
21355: LD_VAR 0 6
21359: PPUSH
21360: CALL_OW 274
21364: PUSH
21365: LD_VAR 0 1
21369: NONEQUAL
21370: IFFALSE 21386
// ComLinkToBase ( base , i ) ;
21372: LD_VAR 0 1
21376: PPUSH
21377: LD_VAR 0 6
21381: PPUSH
21382: CALL_OW 169
21386: GO 21352
21388: POP
21389: POP
// end ; result := tmp ;
21390: LD_ADDR_VAR 0 4
21394: PUSH
21395: LD_VAR 0 5
21399: ST_TO_ADDR
// end ;
21400: LD_VAR 0 4
21404: RET
// export function ComComplete ( units , b ) ; var i ; begin
21405: LD_INT 0
21407: PPUSH
21408: PPUSH
// if not units then
21409: LD_VAR 0 1
21413: NOT
21414: IFFALSE 21418
// exit ;
21416: GO 21508
// for i in units do
21418: LD_ADDR_VAR 0 4
21422: PUSH
21423: LD_VAR 0 1
21427: PUSH
21428: FOR_IN
21429: IFFALSE 21506
// if BuildingStatus ( b ) = bs_build then
21431: LD_VAR 0 2
21435: PPUSH
21436: CALL_OW 461
21440: PUSH
21441: LD_INT 1
21443: EQUAL
21444: IFFALSE 21504
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21446: LD_VAR 0 4
21450: PPUSH
21451: LD_STRING h
21453: PUSH
21454: LD_VAR 0 2
21458: PPUSH
21459: CALL_OW 250
21463: PUSH
21464: LD_VAR 0 2
21468: PPUSH
21469: CALL_OW 251
21473: PUSH
21474: LD_VAR 0 2
21478: PUSH
21479: LD_INT 0
21481: PUSH
21482: LD_INT 0
21484: PUSH
21485: LD_INT 0
21487: PUSH
21488: EMPTY
21489: LIST
21490: LIST
21491: LIST
21492: LIST
21493: LIST
21494: LIST
21495: LIST
21496: PUSH
21497: EMPTY
21498: LIST
21499: PPUSH
21500: CALL_OW 446
21504: GO 21428
21506: POP
21507: POP
// end ;
21508: LD_VAR 0 3
21512: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21513: LD_INT 0
21515: PPUSH
21516: PPUSH
21517: PPUSH
21518: PPUSH
21519: PPUSH
21520: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
21521: LD_VAR 0 1
21525: NOT
21526: PUSH
21527: LD_VAR 0 1
21531: PPUSH
21532: CALL_OW 263
21536: PUSH
21537: LD_INT 2
21539: EQUAL
21540: NOT
21541: OR
21542: IFFALSE 21546
// exit ;
21544: GO 21862
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21546: LD_ADDR_VAR 0 6
21550: PUSH
21551: LD_INT 22
21553: PUSH
21554: LD_VAR 0 1
21558: PPUSH
21559: CALL_OW 255
21563: PUSH
21564: EMPTY
21565: LIST
21566: LIST
21567: PUSH
21568: LD_INT 2
21570: PUSH
21571: LD_INT 30
21573: PUSH
21574: LD_INT 36
21576: PUSH
21577: EMPTY
21578: LIST
21579: LIST
21580: PUSH
21581: LD_INT 34
21583: PUSH
21584: LD_INT 31
21586: PUSH
21587: EMPTY
21588: LIST
21589: LIST
21590: PUSH
21591: EMPTY
21592: LIST
21593: LIST
21594: LIST
21595: PUSH
21596: EMPTY
21597: LIST
21598: LIST
21599: PPUSH
21600: CALL_OW 69
21604: ST_TO_ADDR
// if not tmp then
21605: LD_VAR 0 6
21609: NOT
21610: IFFALSE 21614
// exit ;
21612: GO 21862
// result := [ ] ;
21614: LD_ADDR_VAR 0 2
21618: PUSH
21619: EMPTY
21620: ST_TO_ADDR
// for i in tmp do
21621: LD_ADDR_VAR 0 3
21625: PUSH
21626: LD_VAR 0 6
21630: PUSH
21631: FOR_IN
21632: IFFALSE 21703
// begin t := UnitsInside ( i ) ;
21634: LD_ADDR_VAR 0 4
21638: PUSH
21639: LD_VAR 0 3
21643: PPUSH
21644: CALL_OW 313
21648: ST_TO_ADDR
// if t then
21649: LD_VAR 0 4
21653: IFFALSE 21701
// for j in t do
21655: LD_ADDR_VAR 0 7
21659: PUSH
21660: LD_VAR 0 4
21664: PUSH
21665: FOR_IN
21666: IFFALSE 21699
// result := Insert ( result , result + 1 , j ) ;
21668: LD_ADDR_VAR 0 2
21672: PUSH
21673: LD_VAR 0 2
21677: PPUSH
21678: LD_VAR 0 2
21682: PUSH
21683: LD_INT 1
21685: PLUS
21686: PPUSH
21687: LD_VAR 0 7
21691: PPUSH
21692: CALL_OW 2
21696: ST_TO_ADDR
21697: GO 21665
21699: POP
21700: POP
// end ;
21701: GO 21631
21703: POP
21704: POP
// if not result then
21705: LD_VAR 0 2
21709: NOT
21710: IFFALSE 21714
// exit ;
21712: GO 21862
// mech := result [ 1 ] ;
21714: LD_ADDR_VAR 0 5
21718: PUSH
21719: LD_VAR 0 2
21723: PUSH
21724: LD_INT 1
21726: ARRAY
21727: ST_TO_ADDR
// if result > 1 then
21728: LD_VAR 0 2
21732: PUSH
21733: LD_INT 1
21735: GREATER
21736: IFFALSE 21848
// for i = 2 to result do
21738: LD_ADDR_VAR 0 3
21742: PUSH
21743: DOUBLE
21744: LD_INT 2
21746: DEC
21747: ST_TO_ADDR
21748: LD_VAR 0 2
21752: PUSH
21753: FOR_TO
21754: IFFALSE 21846
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21756: LD_ADDR_VAR 0 4
21760: PUSH
21761: LD_VAR 0 2
21765: PUSH
21766: LD_VAR 0 3
21770: ARRAY
21771: PPUSH
21772: LD_INT 3
21774: PPUSH
21775: CALL_OW 259
21779: PUSH
21780: LD_VAR 0 2
21784: PUSH
21785: LD_VAR 0 3
21789: ARRAY
21790: PPUSH
21791: CALL_OW 432
21795: MINUS
21796: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
21797: LD_VAR 0 4
21801: PUSH
21802: LD_VAR 0 5
21806: PPUSH
21807: LD_INT 3
21809: PPUSH
21810: CALL_OW 259
21814: PUSH
21815: LD_VAR 0 5
21819: PPUSH
21820: CALL_OW 432
21824: MINUS
21825: GREATEREQUAL
21826: IFFALSE 21844
// mech := result [ i ] ;
21828: LD_ADDR_VAR 0 5
21832: PUSH
21833: LD_VAR 0 2
21837: PUSH
21838: LD_VAR 0 3
21842: ARRAY
21843: ST_TO_ADDR
// end ;
21844: GO 21753
21846: POP
21847: POP
// ComLinkTo ( vehicle , mech ) ;
21848: LD_VAR 0 1
21852: PPUSH
21853: LD_VAR 0 5
21857: PPUSH
21858: CALL_OW 135
// end ;
21862: LD_VAR 0 2
21866: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
21867: LD_INT 0
21869: PPUSH
21870: PPUSH
21871: PPUSH
21872: PPUSH
21873: PPUSH
21874: PPUSH
21875: PPUSH
21876: PPUSH
21877: PPUSH
21878: PPUSH
21879: PPUSH
21880: PPUSH
21881: PPUSH
// result := [ ] ;
21882: LD_ADDR_VAR 0 7
21886: PUSH
21887: EMPTY
21888: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
21889: LD_VAR 0 1
21893: PPUSH
21894: CALL_OW 266
21898: PUSH
21899: LD_INT 0
21901: PUSH
21902: LD_INT 1
21904: PUSH
21905: EMPTY
21906: LIST
21907: LIST
21908: IN
21909: NOT
21910: IFFALSE 21914
// exit ;
21912: GO 23548
// if name then
21914: LD_VAR 0 3
21918: IFFALSE 21934
// SetBName ( base_dep , name ) ;
21920: LD_VAR 0 1
21924: PPUSH
21925: LD_VAR 0 3
21929: PPUSH
21930: CALL_OW 500
// base := GetBase ( base_dep ) ;
21934: LD_ADDR_VAR 0 15
21938: PUSH
21939: LD_VAR 0 1
21943: PPUSH
21944: CALL_OW 274
21948: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
21949: LD_ADDR_VAR 0 16
21953: PUSH
21954: LD_VAR 0 1
21958: PPUSH
21959: CALL_OW 255
21963: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
21964: LD_ADDR_VAR 0 17
21968: PUSH
21969: LD_VAR 0 1
21973: PPUSH
21974: CALL_OW 248
21978: ST_TO_ADDR
// if sources then
21979: LD_VAR 0 5
21983: IFFALSE 22030
// for i = 1 to 3 do
21985: LD_ADDR_VAR 0 8
21989: PUSH
21990: DOUBLE
21991: LD_INT 1
21993: DEC
21994: ST_TO_ADDR
21995: LD_INT 3
21997: PUSH
21998: FOR_TO
21999: IFFALSE 22028
// AddResourceType ( base , i , sources [ i ] ) ;
22001: LD_VAR 0 15
22005: PPUSH
22006: LD_VAR 0 8
22010: PPUSH
22011: LD_VAR 0 5
22015: PUSH
22016: LD_VAR 0 8
22020: ARRAY
22021: PPUSH
22022: CALL_OW 276
22026: GO 21998
22028: POP
22029: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
22030: LD_ADDR_VAR 0 18
22034: PUSH
22035: LD_VAR 0 15
22039: PPUSH
22040: LD_VAR 0 2
22044: PPUSH
22045: LD_INT 1
22047: PPUSH
22048: CALL 21290 0 3
22052: ST_TO_ADDR
// InitHc ;
22053: CALL_OW 19
// InitUc ;
22057: CALL_OW 18
// uc_side := side ;
22061: LD_ADDR_OWVAR 20
22065: PUSH
22066: LD_VAR 0 16
22070: ST_TO_ADDR
// uc_nation := nation ;
22071: LD_ADDR_OWVAR 21
22075: PUSH
22076: LD_VAR 0 17
22080: ST_TO_ADDR
// if buildings then
22081: LD_VAR 0 18
22085: IFFALSE 23407
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22087: LD_ADDR_VAR 0 19
22091: PUSH
22092: LD_VAR 0 18
22096: PPUSH
22097: LD_INT 2
22099: PUSH
22100: LD_INT 30
22102: PUSH
22103: LD_INT 29
22105: PUSH
22106: EMPTY
22107: LIST
22108: LIST
22109: PUSH
22110: LD_INT 30
22112: PUSH
22113: LD_INT 30
22115: PUSH
22116: EMPTY
22117: LIST
22118: LIST
22119: PUSH
22120: EMPTY
22121: LIST
22122: LIST
22123: LIST
22124: PPUSH
22125: CALL_OW 72
22129: ST_TO_ADDR
// if tmp then
22130: LD_VAR 0 19
22134: IFFALSE 22182
// for i in tmp do
22136: LD_ADDR_VAR 0 8
22140: PUSH
22141: LD_VAR 0 19
22145: PUSH
22146: FOR_IN
22147: IFFALSE 22180
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22149: LD_VAR 0 8
22153: PPUSH
22154: CALL_OW 250
22158: PPUSH
22159: LD_VAR 0 8
22163: PPUSH
22164: CALL_OW 251
22168: PPUSH
22169: LD_VAR 0 16
22173: PPUSH
22174: CALL_OW 441
22178: GO 22146
22180: POP
22181: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22182: LD_VAR 0 18
22186: PPUSH
22187: LD_INT 2
22189: PUSH
22190: LD_INT 30
22192: PUSH
22193: LD_INT 32
22195: PUSH
22196: EMPTY
22197: LIST
22198: LIST
22199: PUSH
22200: LD_INT 30
22202: PUSH
22203: LD_INT 33
22205: PUSH
22206: EMPTY
22207: LIST
22208: LIST
22209: PUSH
22210: EMPTY
22211: LIST
22212: LIST
22213: LIST
22214: PPUSH
22215: CALL_OW 72
22219: IFFALSE 22307
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22221: LD_ADDR_VAR 0 8
22225: PUSH
22226: LD_VAR 0 18
22230: PPUSH
22231: LD_INT 2
22233: PUSH
22234: LD_INT 30
22236: PUSH
22237: LD_INT 32
22239: PUSH
22240: EMPTY
22241: LIST
22242: LIST
22243: PUSH
22244: LD_INT 30
22246: PUSH
22247: LD_INT 33
22249: PUSH
22250: EMPTY
22251: LIST
22252: LIST
22253: PUSH
22254: EMPTY
22255: LIST
22256: LIST
22257: LIST
22258: PPUSH
22259: CALL_OW 72
22263: PUSH
22264: FOR_IN
22265: IFFALSE 22305
// begin if not GetBWeapon ( i ) then
22267: LD_VAR 0 8
22271: PPUSH
22272: CALL_OW 269
22276: NOT
22277: IFFALSE 22303
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22279: LD_VAR 0 8
22283: PPUSH
22284: LD_VAR 0 8
22288: PPUSH
22289: LD_VAR 0 2
22293: PPUSH
22294: CALL 23553 0 2
22298: PPUSH
22299: CALL_OW 431
// end ;
22303: GO 22264
22305: POP
22306: POP
// end ; for i = 1 to personel do
22307: LD_ADDR_VAR 0 8
22311: PUSH
22312: DOUBLE
22313: LD_INT 1
22315: DEC
22316: ST_TO_ADDR
22317: LD_VAR 0 6
22321: PUSH
22322: FOR_TO
22323: IFFALSE 23387
// begin if i > 4 then
22325: LD_VAR 0 8
22329: PUSH
22330: LD_INT 4
22332: GREATER
22333: IFFALSE 22337
// break ;
22335: GO 23387
// case i of 1 :
22337: LD_VAR 0 8
22341: PUSH
22342: LD_INT 1
22344: DOUBLE
22345: EQUAL
22346: IFTRUE 22350
22348: GO 22430
22350: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
22351: LD_ADDR_VAR 0 12
22355: PUSH
22356: LD_VAR 0 18
22360: PPUSH
22361: LD_INT 22
22363: PUSH
22364: LD_VAR 0 16
22368: PUSH
22369: EMPTY
22370: LIST
22371: LIST
22372: PUSH
22373: LD_INT 58
22375: PUSH
22376: EMPTY
22377: LIST
22378: PUSH
22379: LD_INT 2
22381: PUSH
22382: LD_INT 30
22384: PUSH
22385: LD_INT 32
22387: PUSH
22388: EMPTY
22389: LIST
22390: LIST
22391: PUSH
22392: LD_INT 30
22394: PUSH
22395: LD_INT 4
22397: PUSH
22398: EMPTY
22399: LIST
22400: LIST
22401: PUSH
22402: LD_INT 30
22404: PUSH
22405: LD_INT 5
22407: PUSH
22408: EMPTY
22409: LIST
22410: LIST
22411: PUSH
22412: EMPTY
22413: LIST
22414: LIST
22415: LIST
22416: LIST
22417: PUSH
22418: EMPTY
22419: LIST
22420: LIST
22421: LIST
22422: PPUSH
22423: CALL_OW 72
22427: ST_TO_ADDR
22428: GO 22652
22430: LD_INT 2
22432: DOUBLE
22433: EQUAL
22434: IFTRUE 22438
22436: GO 22500
22438: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22439: LD_ADDR_VAR 0 12
22443: PUSH
22444: LD_VAR 0 18
22448: PPUSH
22449: LD_INT 22
22451: PUSH
22452: LD_VAR 0 16
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: PUSH
22461: LD_INT 2
22463: PUSH
22464: LD_INT 30
22466: PUSH
22467: LD_INT 0
22469: PUSH
22470: EMPTY
22471: LIST
22472: LIST
22473: PUSH
22474: LD_INT 30
22476: PUSH
22477: LD_INT 1
22479: PUSH
22480: EMPTY
22481: LIST
22482: LIST
22483: PUSH
22484: EMPTY
22485: LIST
22486: LIST
22487: LIST
22488: PUSH
22489: EMPTY
22490: LIST
22491: LIST
22492: PPUSH
22493: CALL_OW 72
22497: ST_TO_ADDR
22498: GO 22652
22500: LD_INT 3
22502: DOUBLE
22503: EQUAL
22504: IFTRUE 22508
22506: GO 22570
22508: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22509: LD_ADDR_VAR 0 12
22513: PUSH
22514: LD_VAR 0 18
22518: PPUSH
22519: LD_INT 22
22521: PUSH
22522: LD_VAR 0 16
22526: PUSH
22527: EMPTY
22528: LIST
22529: LIST
22530: PUSH
22531: LD_INT 2
22533: PUSH
22534: LD_INT 30
22536: PUSH
22537: LD_INT 2
22539: PUSH
22540: EMPTY
22541: LIST
22542: LIST
22543: PUSH
22544: LD_INT 30
22546: PUSH
22547: LD_INT 3
22549: PUSH
22550: EMPTY
22551: LIST
22552: LIST
22553: PUSH
22554: EMPTY
22555: LIST
22556: LIST
22557: LIST
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PPUSH
22563: CALL_OW 72
22567: ST_TO_ADDR
22568: GO 22652
22570: LD_INT 4
22572: DOUBLE
22573: EQUAL
22574: IFTRUE 22578
22576: GO 22651
22578: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22579: LD_ADDR_VAR 0 12
22583: PUSH
22584: LD_VAR 0 18
22588: PPUSH
22589: LD_INT 22
22591: PUSH
22592: LD_VAR 0 16
22596: PUSH
22597: EMPTY
22598: LIST
22599: LIST
22600: PUSH
22601: LD_INT 2
22603: PUSH
22604: LD_INT 30
22606: PUSH
22607: LD_INT 6
22609: PUSH
22610: EMPTY
22611: LIST
22612: LIST
22613: PUSH
22614: LD_INT 30
22616: PUSH
22617: LD_INT 7
22619: PUSH
22620: EMPTY
22621: LIST
22622: LIST
22623: PUSH
22624: LD_INT 30
22626: PUSH
22627: LD_INT 8
22629: PUSH
22630: EMPTY
22631: LIST
22632: LIST
22633: PUSH
22634: EMPTY
22635: LIST
22636: LIST
22637: LIST
22638: LIST
22639: PUSH
22640: EMPTY
22641: LIST
22642: LIST
22643: PPUSH
22644: CALL_OW 72
22648: ST_TO_ADDR
22649: GO 22652
22651: POP
// if i = 1 then
22652: LD_VAR 0 8
22656: PUSH
22657: LD_INT 1
22659: EQUAL
22660: IFFALSE 22771
// begin tmp := [ ] ;
22662: LD_ADDR_VAR 0 19
22666: PUSH
22667: EMPTY
22668: ST_TO_ADDR
// for j in f do
22669: LD_ADDR_VAR 0 9
22673: PUSH
22674: LD_VAR 0 12
22678: PUSH
22679: FOR_IN
22680: IFFALSE 22753
// if GetBType ( j ) = b_bunker then
22682: LD_VAR 0 9
22686: PPUSH
22687: CALL_OW 266
22691: PUSH
22692: LD_INT 32
22694: EQUAL
22695: IFFALSE 22722
// tmp := Insert ( tmp , 1 , j ) else
22697: LD_ADDR_VAR 0 19
22701: PUSH
22702: LD_VAR 0 19
22706: PPUSH
22707: LD_INT 1
22709: PPUSH
22710: LD_VAR 0 9
22714: PPUSH
22715: CALL_OW 2
22719: ST_TO_ADDR
22720: GO 22751
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22722: LD_ADDR_VAR 0 19
22726: PUSH
22727: LD_VAR 0 19
22731: PPUSH
22732: LD_VAR 0 19
22736: PUSH
22737: LD_INT 1
22739: PLUS
22740: PPUSH
22741: LD_VAR 0 9
22745: PPUSH
22746: CALL_OW 2
22750: ST_TO_ADDR
22751: GO 22679
22753: POP
22754: POP
// if tmp then
22755: LD_VAR 0 19
22759: IFFALSE 22771
// f := tmp ;
22761: LD_ADDR_VAR 0 12
22765: PUSH
22766: LD_VAR 0 19
22770: ST_TO_ADDR
// end ; x := personel [ i ] ;
22771: LD_ADDR_VAR 0 13
22775: PUSH
22776: LD_VAR 0 6
22780: PUSH
22781: LD_VAR 0 8
22785: ARRAY
22786: ST_TO_ADDR
// if x = - 1 then
22787: LD_VAR 0 13
22791: PUSH
22792: LD_INT 1
22794: NEG
22795: EQUAL
22796: IFFALSE 23005
// begin for j in f do
22798: LD_ADDR_VAR 0 9
22802: PUSH
22803: LD_VAR 0 12
22807: PUSH
22808: FOR_IN
22809: IFFALSE 23001
// repeat InitHc ;
22811: CALL_OW 19
// if GetBType ( j ) = b_barracks then
22815: LD_VAR 0 9
22819: PPUSH
22820: CALL_OW 266
22824: PUSH
22825: LD_INT 5
22827: EQUAL
22828: IFFALSE 22898
// begin if UnitsInside ( j ) < 3 then
22830: LD_VAR 0 9
22834: PPUSH
22835: CALL_OW 313
22839: PUSH
22840: LD_INT 3
22842: LESS
22843: IFFALSE 22879
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22845: LD_INT 0
22847: PPUSH
22848: LD_INT 5
22850: PUSH
22851: LD_INT 8
22853: PUSH
22854: LD_INT 9
22856: PUSH
22857: EMPTY
22858: LIST
22859: LIST
22860: LIST
22861: PUSH
22862: LD_VAR 0 17
22866: ARRAY
22867: PPUSH
22868: LD_VAR 0 4
22872: PPUSH
22873: CALL_OW 380
22877: GO 22896
// PrepareHuman ( false , i , skill ) ;
22879: LD_INT 0
22881: PPUSH
22882: LD_VAR 0 8
22886: PPUSH
22887: LD_VAR 0 4
22891: PPUSH
22892: CALL_OW 380
// end else
22896: GO 22915
// PrepareHuman ( false , i , skill ) ;
22898: LD_INT 0
22900: PPUSH
22901: LD_VAR 0 8
22905: PPUSH
22906: LD_VAR 0 4
22910: PPUSH
22911: CALL_OW 380
// un := CreateHuman ;
22915: LD_ADDR_VAR 0 14
22919: PUSH
22920: CALL_OW 44
22924: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22925: LD_ADDR_VAR 0 7
22929: PUSH
22930: LD_VAR 0 7
22934: PPUSH
22935: LD_INT 1
22937: PPUSH
22938: LD_VAR 0 14
22942: PPUSH
22943: CALL_OW 2
22947: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
22948: LD_VAR 0 14
22952: PPUSH
22953: LD_VAR 0 9
22957: PPUSH
22958: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
22962: LD_VAR 0 9
22966: PPUSH
22967: CALL_OW 313
22971: PUSH
22972: LD_INT 6
22974: EQUAL
22975: PUSH
22976: LD_VAR 0 9
22980: PPUSH
22981: CALL_OW 266
22985: PUSH
22986: LD_INT 32
22988: PUSH
22989: LD_INT 31
22991: PUSH
22992: EMPTY
22993: LIST
22994: LIST
22995: IN
22996: OR
22997: IFFALSE 22811
22999: GO 22808
23001: POP
23002: POP
// end else
23003: GO 23385
// for j = 1 to x do
23005: LD_ADDR_VAR 0 9
23009: PUSH
23010: DOUBLE
23011: LD_INT 1
23013: DEC
23014: ST_TO_ADDR
23015: LD_VAR 0 13
23019: PUSH
23020: FOR_TO
23021: IFFALSE 23383
// begin InitHc ;
23023: CALL_OW 19
// if not f then
23027: LD_VAR 0 12
23031: NOT
23032: IFFALSE 23121
// begin PrepareHuman ( false , i , skill ) ;
23034: LD_INT 0
23036: PPUSH
23037: LD_VAR 0 8
23041: PPUSH
23042: LD_VAR 0 4
23046: PPUSH
23047: CALL_OW 380
// un := CreateHuman ;
23051: LD_ADDR_VAR 0 14
23055: PUSH
23056: CALL_OW 44
23060: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23061: LD_ADDR_VAR 0 7
23065: PUSH
23066: LD_VAR 0 7
23070: PPUSH
23071: LD_INT 1
23073: PPUSH
23074: LD_VAR 0 14
23078: PPUSH
23079: CALL_OW 2
23083: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23084: LD_VAR 0 14
23088: PPUSH
23089: LD_VAR 0 1
23093: PPUSH
23094: CALL_OW 250
23098: PPUSH
23099: LD_VAR 0 1
23103: PPUSH
23104: CALL_OW 251
23108: PPUSH
23109: LD_INT 10
23111: PPUSH
23112: LD_INT 0
23114: PPUSH
23115: CALL_OW 50
// continue ;
23119: GO 23020
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23121: LD_VAR 0 12
23125: PUSH
23126: LD_INT 1
23128: ARRAY
23129: PPUSH
23130: CALL_OW 313
23134: PUSH
23135: LD_VAR 0 12
23139: PUSH
23140: LD_INT 1
23142: ARRAY
23143: PPUSH
23144: CALL_OW 266
23148: PUSH
23149: LD_INT 32
23151: PUSH
23152: LD_INT 31
23154: PUSH
23155: EMPTY
23156: LIST
23157: LIST
23158: IN
23159: AND
23160: PUSH
23161: LD_VAR 0 12
23165: PUSH
23166: LD_INT 1
23168: ARRAY
23169: PPUSH
23170: CALL_OW 313
23174: PUSH
23175: LD_INT 6
23177: EQUAL
23178: OR
23179: IFFALSE 23199
// f := Delete ( f , 1 ) ;
23181: LD_ADDR_VAR 0 12
23185: PUSH
23186: LD_VAR 0 12
23190: PPUSH
23191: LD_INT 1
23193: PPUSH
23194: CALL_OW 3
23198: ST_TO_ADDR
// if not f then
23199: LD_VAR 0 12
23203: NOT
23204: IFFALSE 23222
// begin x := x + 2 ;
23206: LD_ADDR_VAR 0 13
23210: PUSH
23211: LD_VAR 0 13
23215: PUSH
23216: LD_INT 2
23218: PLUS
23219: ST_TO_ADDR
// continue ;
23220: GO 23020
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23222: LD_VAR 0 12
23226: PUSH
23227: LD_INT 1
23229: ARRAY
23230: PPUSH
23231: CALL_OW 266
23235: PUSH
23236: LD_INT 5
23238: EQUAL
23239: IFFALSE 23313
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23241: LD_VAR 0 12
23245: PUSH
23246: LD_INT 1
23248: ARRAY
23249: PPUSH
23250: CALL_OW 313
23254: PUSH
23255: LD_INT 3
23257: LESS
23258: IFFALSE 23294
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23260: LD_INT 0
23262: PPUSH
23263: LD_INT 5
23265: PUSH
23266: LD_INT 8
23268: PUSH
23269: LD_INT 9
23271: PUSH
23272: EMPTY
23273: LIST
23274: LIST
23275: LIST
23276: PUSH
23277: LD_VAR 0 17
23281: ARRAY
23282: PPUSH
23283: LD_VAR 0 4
23287: PPUSH
23288: CALL_OW 380
23292: GO 23311
// PrepareHuman ( false , i , skill ) ;
23294: LD_INT 0
23296: PPUSH
23297: LD_VAR 0 8
23301: PPUSH
23302: LD_VAR 0 4
23306: PPUSH
23307: CALL_OW 380
// end else
23311: GO 23330
// PrepareHuman ( false , i , skill ) ;
23313: LD_INT 0
23315: PPUSH
23316: LD_VAR 0 8
23320: PPUSH
23321: LD_VAR 0 4
23325: PPUSH
23326: CALL_OW 380
// un := CreateHuman ;
23330: LD_ADDR_VAR 0 14
23334: PUSH
23335: CALL_OW 44
23339: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23340: LD_ADDR_VAR 0 7
23344: PUSH
23345: LD_VAR 0 7
23349: PPUSH
23350: LD_INT 1
23352: PPUSH
23353: LD_VAR 0 14
23357: PPUSH
23358: CALL_OW 2
23362: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
23363: LD_VAR 0 14
23367: PPUSH
23368: LD_VAR 0 12
23372: PUSH
23373: LD_INT 1
23375: ARRAY
23376: PPUSH
23377: CALL_OW 52
// end ;
23381: GO 23020
23383: POP
23384: POP
// end ;
23385: GO 22322
23387: POP
23388: POP
// result := result ^ buildings ;
23389: LD_ADDR_VAR 0 7
23393: PUSH
23394: LD_VAR 0 7
23398: PUSH
23399: LD_VAR 0 18
23403: ADD
23404: ST_TO_ADDR
// end else
23405: GO 23548
// begin for i = 1 to personel do
23407: LD_ADDR_VAR 0 8
23411: PUSH
23412: DOUBLE
23413: LD_INT 1
23415: DEC
23416: ST_TO_ADDR
23417: LD_VAR 0 6
23421: PUSH
23422: FOR_TO
23423: IFFALSE 23546
// begin if i > 4 then
23425: LD_VAR 0 8
23429: PUSH
23430: LD_INT 4
23432: GREATER
23433: IFFALSE 23437
// break ;
23435: GO 23546
// x := personel [ i ] ;
23437: LD_ADDR_VAR 0 13
23441: PUSH
23442: LD_VAR 0 6
23446: PUSH
23447: LD_VAR 0 8
23451: ARRAY
23452: ST_TO_ADDR
// if x = - 1 then
23453: LD_VAR 0 13
23457: PUSH
23458: LD_INT 1
23460: NEG
23461: EQUAL
23462: IFFALSE 23466
// continue ;
23464: GO 23422
// PrepareHuman ( false , i , skill ) ;
23466: LD_INT 0
23468: PPUSH
23469: LD_VAR 0 8
23473: PPUSH
23474: LD_VAR 0 4
23478: PPUSH
23479: CALL_OW 380
// un := CreateHuman ;
23483: LD_ADDR_VAR 0 14
23487: PUSH
23488: CALL_OW 44
23492: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23493: LD_VAR 0 14
23497: PPUSH
23498: LD_VAR 0 1
23502: PPUSH
23503: CALL_OW 250
23507: PPUSH
23508: LD_VAR 0 1
23512: PPUSH
23513: CALL_OW 251
23517: PPUSH
23518: LD_INT 10
23520: PPUSH
23521: LD_INT 0
23523: PPUSH
23524: CALL_OW 50
// result := result ^ un ;
23528: LD_ADDR_VAR 0 7
23532: PUSH
23533: LD_VAR 0 7
23537: PUSH
23538: LD_VAR 0 14
23542: ADD
23543: ST_TO_ADDR
// end ;
23544: GO 23422
23546: POP
23547: POP
// end ; end ;
23548: LD_VAR 0 7
23552: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23553: LD_INT 0
23555: PPUSH
23556: PPUSH
23557: PPUSH
23558: PPUSH
23559: PPUSH
23560: PPUSH
23561: PPUSH
23562: PPUSH
23563: PPUSH
23564: PPUSH
23565: PPUSH
23566: PPUSH
23567: PPUSH
23568: PPUSH
23569: PPUSH
23570: PPUSH
// result := false ;
23571: LD_ADDR_VAR 0 3
23575: PUSH
23576: LD_INT 0
23578: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23579: LD_VAR 0 1
23583: NOT
23584: PUSH
23585: LD_VAR 0 1
23589: PPUSH
23590: CALL_OW 266
23594: PUSH
23595: LD_INT 32
23597: PUSH
23598: LD_INT 33
23600: PUSH
23601: EMPTY
23602: LIST
23603: LIST
23604: IN
23605: NOT
23606: OR
23607: IFFALSE 23611
// exit ;
23609: GO 24750
// nat := GetNation ( tower ) ;
23611: LD_ADDR_VAR 0 12
23615: PUSH
23616: LD_VAR 0 1
23620: PPUSH
23621: CALL_OW 248
23625: ST_TO_ADDR
// side := GetSide ( tower ) ;
23626: LD_ADDR_VAR 0 16
23630: PUSH
23631: LD_VAR 0 1
23635: PPUSH
23636: CALL_OW 255
23640: ST_TO_ADDR
// x := GetX ( tower ) ;
23641: LD_ADDR_VAR 0 10
23645: PUSH
23646: LD_VAR 0 1
23650: PPUSH
23651: CALL_OW 250
23655: ST_TO_ADDR
// y := GetY ( tower ) ;
23656: LD_ADDR_VAR 0 11
23660: PUSH
23661: LD_VAR 0 1
23665: PPUSH
23666: CALL_OW 251
23670: ST_TO_ADDR
// if not x or not y then
23671: LD_VAR 0 10
23675: NOT
23676: PUSH
23677: LD_VAR 0 11
23681: NOT
23682: OR
23683: IFFALSE 23687
// exit ;
23685: GO 24750
// weapon := 0 ;
23687: LD_ADDR_VAR 0 18
23691: PUSH
23692: LD_INT 0
23694: ST_TO_ADDR
// fac_list := [ ] ;
23695: LD_ADDR_VAR 0 17
23699: PUSH
23700: EMPTY
23701: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
23702: LD_ADDR_VAR 0 6
23706: PUSH
23707: LD_VAR 0 1
23711: PPUSH
23712: CALL_OW 274
23716: PPUSH
23717: LD_VAR 0 2
23721: PPUSH
23722: LD_INT 0
23724: PPUSH
23725: CALL 21290 0 3
23729: PPUSH
23730: LD_INT 30
23732: PUSH
23733: LD_INT 3
23735: PUSH
23736: EMPTY
23737: LIST
23738: LIST
23739: PPUSH
23740: CALL_OW 72
23744: ST_TO_ADDR
// if not factories then
23745: LD_VAR 0 6
23749: NOT
23750: IFFALSE 23754
// exit ;
23752: GO 24750
// for i in factories do
23754: LD_ADDR_VAR 0 8
23758: PUSH
23759: LD_VAR 0 6
23763: PUSH
23764: FOR_IN
23765: IFFALSE 23790
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23767: LD_ADDR_VAR 0 17
23771: PUSH
23772: LD_VAR 0 17
23776: PUSH
23777: LD_VAR 0 8
23781: PPUSH
23782: CALL_OW 478
23786: UNION
23787: ST_TO_ADDR
23788: GO 23764
23790: POP
23791: POP
// if not fac_list then
23792: LD_VAR 0 17
23796: NOT
23797: IFFALSE 23801
// exit ;
23799: GO 24750
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
23801: LD_ADDR_VAR 0 5
23805: PUSH
23806: LD_INT 4
23808: PUSH
23809: LD_INT 5
23811: PUSH
23812: LD_INT 9
23814: PUSH
23815: LD_INT 10
23817: PUSH
23818: LD_INT 6
23820: PUSH
23821: LD_INT 7
23823: PUSH
23824: LD_INT 11
23826: PUSH
23827: EMPTY
23828: LIST
23829: LIST
23830: LIST
23831: LIST
23832: LIST
23833: LIST
23834: LIST
23835: PUSH
23836: LD_INT 27
23838: PUSH
23839: LD_INT 28
23841: PUSH
23842: LD_INT 26
23844: PUSH
23845: LD_INT 30
23847: PUSH
23848: EMPTY
23849: LIST
23850: LIST
23851: LIST
23852: LIST
23853: PUSH
23854: LD_INT 43
23856: PUSH
23857: LD_INT 44
23859: PUSH
23860: LD_INT 46
23862: PUSH
23863: LD_INT 45
23865: PUSH
23866: LD_INT 47
23868: PUSH
23869: LD_INT 49
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: LIST
23876: LIST
23877: LIST
23878: LIST
23879: PUSH
23880: EMPTY
23881: LIST
23882: LIST
23883: LIST
23884: PUSH
23885: LD_VAR 0 12
23889: ARRAY
23890: ST_TO_ADDR
// for i in list do
23891: LD_ADDR_VAR 0 8
23895: PUSH
23896: LD_VAR 0 5
23900: PUSH
23901: FOR_IN
23902: IFFALSE 23935
// if not i in fac_list then
23904: LD_VAR 0 8
23908: PUSH
23909: LD_VAR 0 17
23913: IN
23914: NOT
23915: IFFALSE 23933
// list := list diff i ;
23917: LD_ADDR_VAR 0 5
23921: PUSH
23922: LD_VAR 0 5
23926: PUSH
23927: LD_VAR 0 8
23931: DIFF
23932: ST_TO_ADDR
23933: GO 23901
23935: POP
23936: POP
// if not list then
23937: LD_VAR 0 5
23941: NOT
23942: IFFALSE 23946
// exit ;
23944: GO 24750
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
23946: LD_VAR 0 12
23950: PUSH
23951: LD_INT 3
23953: EQUAL
23954: PUSH
23955: LD_INT 49
23957: PUSH
23958: LD_VAR 0 5
23962: IN
23963: AND
23964: PUSH
23965: LD_INT 31
23967: PPUSH
23968: LD_VAR 0 16
23972: PPUSH
23973: CALL_OW 321
23977: PUSH
23978: LD_INT 2
23980: EQUAL
23981: AND
23982: IFFALSE 24042
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
23984: LD_INT 22
23986: PUSH
23987: LD_VAR 0 16
23991: PUSH
23992: EMPTY
23993: LIST
23994: LIST
23995: PUSH
23996: LD_INT 35
23998: PUSH
23999: LD_INT 49
24001: PUSH
24002: EMPTY
24003: LIST
24004: LIST
24005: PUSH
24006: LD_INT 91
24008: PUSH
24009: LD_VAR 0 1
24013: PUSH
24014: LD_INT 10
24016: PUSH
24017: EMPTY
24018: LIST
24019: LIST
24020: LIST
24021: PUSH
24022: EMPTY
24023: LIST
24024: LIST
24025: LIST
24026: PPUSH
24027: CALL_OW 69
24031: NOT
24032: IFFALSE 24042
// weapon := ru_time_lapser ;
24034: LD_ADDR_VAR 0 18
24038: PUSH
24039: LD_INT 49
24041: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24042: LD_VAR 0 12
24046: PUSH
24047: LD_INT 1
24049: PUSH
24050: LD_INT 2
24052: PUSH
24053: EMPTY
24054: LIST
24055: LIST
24056: IN
24057: PUSH
24058: LD_INT 11
24060: PUSH
24061: LD_VAR 0 5
24065: IN
24066: PUSH
24067: LD_INT 30
24069: PUSH
24070: LD_VAR 0 5
24074: IN
24075: OR
24076: AND
24077: PUSH
24078: LD_INT 6
24080: PPUSH
24081: LD_VAR 0 16
24085: PPUSH
24086: CALL_OW 321
24090: PUSH
24091: LD_INT 2
24093: EQUAL
24094: AND
24095: IFFALSE 24260
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24097: LD_INT 22
24099: PUSH
24100: LD_VAR 0 16
24104: PUSH
24105: EMPTY
24106: LIST
24107: LIST
24108: PUSH
24109: LD_INT 2
24111: PUSH
24112: LD_INT 35
24114: PUSH
24115: LD_INT 11
24117: PUSH
24118: EMPTY
24119: LIST
24120: LIST
24121: PUSH
24122: LD_INT 35
24124: PUSH
24125: LD_INT 30
24127: PUSH
24128: EMPTY
24129: LIST
24130: LIST
24131: PUSH
24132: EMPTY
24133: LIST
24134: LIST
24135: LIST
24136: PUSH
24137: LD_INT 91
24139: PUSH
24140: LD_VAR 0 1
24144: PUSH
24145: LD_INT 18
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: LIST
24152: PUSH
24153: EMPTY
24154: LIST
24155: LIST
24156: LIST
24157: PPUSH
24158: CALL_OW 69
24162: NOT
24163: PUSH
24164: LD_INT 22
24166: PUSH
24167: LD_VAR 0 16
24171: PUSH
24172: EMPTY
24173: LIST
24174: LIST
24175: PUSH
24176: LD_INT 2
24178: PUSH
24179: LD_INT 30
24181: PUSH
24182: LD_INT 32
24184: PUSH
24185: EMPTY
24186: LIST
24187: LIST
24188: PUSH
24189: LD_INT 30
24191: PUSH
24192: LD_INT 33
24194: PUSH
24195: EMPTY
24196: LIST
24197: LIST
24198: PUSH
24199: EMPTY
24200: LIST
24201: LIST
24202: LIST
24203: PUSH
24204: LD_INT 91
24206: PUSH
24207: LD_VAR 0 1
24211: PUSH
24212: LD_INT 12
24214: PUSH
24215: EMPTY
24216: LIST
24217: LIST
24218: LIST
24219: PUSH
24220: EMPTY
24221: LIST
24222: LIST
24223: LIST
24224: PUSH
24225: EMPTY
24226: LIST
24227: PPUSH
24228: CALL_OW 69
24232: PUSH
24233: LD_INT 2
24235: GREATER
24236: AND
24237: IFFALSE 24260
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24239: LD_ADDR_VAR 0 18
24243: PUSH
24244: LD_INT 11
24246: PUSH
24247: LD_INT 30
24249: PUSH
24250: EMPTY
24251: LIST
24252: LIST
24253: PUSH
24254: LD_VAR 0 12
24258: ARRAY
24259: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24260: LD_VAR 0 18
24264: NOT
24265: PUSH
24266: LD_INT 40
24268: PPUSH
24269: LD_VAR 0 16
24273: PPUSH
24274: CALL_OW 321
24278: PUSH
24279: LD_INT 2
24281: EQUAL
24282: AND
24283: PUSH
24284: LD_INT 7
24286: PUSH
24287: LD_VAR 0 5
24291: IN
24292: PUSH
24293: LD_INT 28
24295: PUSH
24296: LD_VAR 0 5
24300: IN
24301: OR
24302: PUSH
24303: LD_INT 45
24305: PUSH
24306: LD_VAR 0 5
24310: IN
24311: OR
24312: AND
24313: IFFALSE 24567
// begin hex := GetHexInfo ( x , y ) ;
24315: LD_ADDR_VAR 0 4
24319: PUSH
24320: LD_VAR 0 10
24324: PPUSH
24325: LD_VAR 0 11
24329: PPUSH
24330: CALL_OW 546
24334: ST_TO_ADDR
// if hex [ 1 ] then
24335: LD_VAR 0 4
24339: PUSH
24340: LD_INT 1
24342: ARRAY
24343: IFFALSE 24347
// exit ;
24345: GO 24750
// height := hex [ 2 ] ;
24347: LD_ADDR_VAR 0 15
24351: PUSH
24352: LD_VAR 0 4
24356: PUSH
24357: LD_INT 2
24359: ARRAY
24360: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
24361: LD_ADDR_VAR 0 14
24365: PUSH
24366: LD_INT 0
24368: PUSH
24369: LD_INT 2
24371: PUSH
24372: LD_INT 3
24374: PUSH
24375: LD_INT 5
24377: PUSH
24378: EMPTY
24379: LIST
24380: LIST
24381: LIST
24382: LIST
24383: ST_TO_ADDR
// for i in tmp do
24384: LD_ADDR_VAR 0 8
24388: PUSH
24389: LD_VAR 0 14
24393: PUSH
24394: FOR_IN
24395: IFFALSE 24565
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
24397: LD_ADDR_VAR 0 9
24401: PUSH
24402: LD_VAR 0 10
24406: PPUSH
24407: LD_VAR 0 8
24411: PPUSH
24412: LD_INT 5
24414: PPUSH
24415: CALL_OW 272
24419: PUSH
24420: LD_VAR 0 11
24424: PPUSH
24425: LD_VAR 0 8
24429: PPUSH
24430: LD_INT 5
24432: PPUSH
24433: CALL_OW 273
24437: PUSH
24438: EMPTY
24439: LIST
24440: LIST
24441: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24442: LD_VAR 0 9
24446: PUSH
24447: LD_INT 1
24449: ARRAY
24450: PPUSH
24451: LD_VAR 0 9
24455: PUSH
24456: LD_INT 2
24458: ARRAY
24459: PPUSH
24460: CALL_OW 488
24464: IFFALSE 24563
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24466: LD_ADDR_VAR 0 4
24470: PUSH
24471: LD_VAR 0 9
24475: PUSH
24476: LD_INT 1
24478: ARRAY
24479: PPUSH
24480: LD_VAR 0 9
24484: PUSH
24485: LD_INT 2
24487: ARRAY
24488: PPUSH
24489: CALL_OW 546
24493: ST_TO_ADDR
// if hex [ 1 ] then
24494: LD_VAR 0 4
24498: PUSH
24499: LD_INT 1
24501: ARRAY
24502: IFFALSE 24506
// continue ;
24504: GO 24394
// h := hex [ 2 ] ;
24506: LD_ADDR_VAR 0 13
24510: PUSH
24511: LD_VAR 0 4
24515: PUSH
24516: LD_INT 2
24518: ARRAY
24519: ST_TO_ADDR
// if h + 7 < height then
24520: LD_VAR 0 13
24524: PUSH
24525: LD_INT 7
24527: PLUS
24528: PUSH
24529: LD_VAR 0 15
24533: LESS
24534: IFFALSE 24563
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24536: LD_ADDR_VAR 0 18
24540: PUSH
24541: LD_INT 7
24543: PUSH
24544: LD_INT 28
24546: PUSH
24547: LD_INT 45
24549: PUSH
24550: EMPTY
24551: LIST
24552: LIST
24553: LIST
24554: PUSH
24555: LD_VAR 0 12
24559: ARRAY
24560: ST_TO_ADDR
// break ;
24561: GO 24565
// end ; end ; end ;
24563: GO 24394
24565: POP
24566: POP
// end ; if not weapon then
24567: LD_VAR 0 18
24571: NOT
24572: IFFALSE 24632
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24574: LD_ADDR_VAR 0 5
24578: PUSH
24579: LD_VAR 0 5
24583: PUSH
24584: LD_INT 11
24586: PUSH
24587: LD_INT 30
24589: PUSH
24590: LD_INT 49
24592: PUSH
24593: EMPTY
24594: LIST
24595: LIST
24596: LIST
24597: DIFF
24598: ST_TO_ADDR
// if not list then
24599: LD_VAR 0 5
24603: NOT
24604: IFFALSE 24608
// exit ;
24606: GO 24750
// weapon := list [ rand ( 1 , list ) ] ;
24608: LD_ADDR_VAR 0 18
24612: PUSH
24613: LD_VAR 0 5
24617: PUSH
24618: LD_INT 1
24620: PPUSH
24621: LD_VAR 0 5
24625: PPUSH
24626: CALL_OW 12
24630: ARRAY
24631: ST_TO_ADDR
// end ; if weapon then
24632: LD_VAR 0 18
24636: IFFALSE 24750
// begin tmp := CostOfWeapon ( weapon ) ;
24638: LD_ADDR_VAR 0 14
24642: PUSH
24643: LD_VAR 0 18
24647: PPUSH
24648: CALL_OW 451
24652: ST_TO_ADDR
// j := GetBase ( tower ) ;
24653: LD_ADDR_VAR 0 9
24657: PUSH
24658: LD_VAR 0 1
24662: PPUSH
24663: CALL_OW 274
24667: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24668: LD_VAR 0 9
24672: PPUSH
24673: LD_INT 1
24675: PPUSH
24676: CALL_OW 275
24680: PUSH
24681: LD_VAR 0 14
24685: PUSH
24686: LD_INT 1
24688: ARRAY
24689: GREATEREQUAL
24690: PUSH
24691: LD_VAR 0 9
24695: PPUSH
24696: LD_INT 2
24698: PPUSH
24699: CALL_OW 275
24703: PUSH
24704: LD_VAR 0 14
24708: PUSH
24709: LD_INT 2
24711: ARRAY
24712: GREATEREQUAL
24713: AND
24714: PUSH
24715: LD_VAR 0 9
24719: PPUSH
24720: LD_INT 3
24722: PPUSH
24723: CALL_OW 275
24727: PUSH
24728: LD_VAR 0 14
24732: PUSH
24733: LD_INT 3
24735: ARRAY
24736: GREATEREQUAL
24737: AND
24738: IFFALSE 24750
// result := weapon ;
24740: LD_ADDR_VAR 0 3
24744: PUSH
24745: LD_VAR 0 18
24749: ST_TO_ADDR
// end ; end ;
24750: LD_VAR 0 3
24754: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24755: LD_INT 0
24757: PPUSH
24758: PPUSH
// result := true ;
24759: LD_ADDR_VAR 0 3
24763: PUSH
24764: LD_INT 1
24766: ST_TO_ADDR
// if array1 = array2 then
24767: LD_VAR 0 1
24771: PUSH
24772: LD_VAR 0 2
24776: EQUAL
24777: IFFALSE 24837
// begin for i = 1 to array1 do
24779: LD_ADDR_VAR 0 4
24783: PUSH
24784: DOUBLE
24785: LD_INT 1
24787: DEC
24788: ST_TO_ADDR
24789: LD_VAR 0 1
24793: PUSH
24794: FOR_TO
24795: IFFALSE 24833
// if array1 [ i ] <> array2 [ i ] then
24797: LD_VAR 0 1
24801: PUSH
24802: LD_VAR 0 4
24806: ARRAY
24807: PUSH
24808: LD_VAR 0 2
24812: PUSH
24813: LD_VAR 0 4
24817: ARRAY
24818: NONEQUAL
24819: IFFALSE 24831
// begin result := false ;
24821: LD_ADDR_VAR 0 3
24825: PUSH
24826: LD_INT 0
24828: ST_TO_ADDR
// break ;
24829: GO 24833
// end ;
24831: GO 24794
24833: POP
24834: POP
// end else
24835: GO 24845
// result := false ;
24837: LD_ADDR_VAR 0 3
24841: PUSH
24842: LD_INT 0
24844: ST_TO_ADDR
// end ;
24845: LD_VAR 0 3
24849: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
24850: LD_INT 0
24852: PPUSH
24853: PPUSH
// if not array1 or not array2 then
24854: LD_VAR 0 1
24858: NOT
24859: PUSH
24860: LD_VAR 0 2
24864: NOT
24865: OR
24866: IFFALSE 24870
// exit ;
24868: GO 24934
// result := true ;
24870: LD_ADDR_VAR 0 3
24874: PUSH
24875: LD_INT 1
24877: ST_TO_ADDR
// for i = 1 to array1 do
24878: LD_ADDR_VAR 0 4
24882: PUSH
24883: DOUBLE
24884: LD_INT 1
24886: DEC
24887: ST_TO_ADDR
24888: LD_VAR 0 1
24892: PUSH
24893: FOR_TO
24894: IFFALSE 24932
// if array1 [ i ] <> array2 [ i ] then
24896: LD_VAR 0 1
24900: PUSH
24901: LD_VAR 0 4
24905: ARRAY
24906: PUSH
24907: LD_VAR 0 2
24911: PUSH
24912: LD_VAR 0 4
24916: ARRAY
24917: NONEQUAL
24918: IFFALSE 24930
// begin result := false ;
24920: LD_ADDR_VAR 0 3
24924: PUSH
24925: LD_INT 0
24927: ST_TO_ADDR
// break ;
24928: GO 24932
// end ;
24930: GO 24893
24932: POP
24933: POP
// end ;
24934: LD_VAR 0 3
24938: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
24939: LD_INT 0
24941: PPUSH
24942: PPUSH
24943: PPUSH
// pom := GetBase ( fac ) ;
24944: LD_ADDR_VAR 0 5
24948: PUSH
24949: LD_VAR 0 1
24953: PPUSH
24954: CALL_OW 274
24958: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24959: LD_ADDR_VAR 0 4
24963: PUSH
24964: LD_VAR 0 2
24968: PUSH
24969: LD_INT 1
24971: ARRAY
24972: PPUSH
24973: LD_VAR 0 2
24977: PUSH
24978: LD_INT 2
24980: ARRAY
24981: PPUSH
24982: LD_VAR 0 2
24986: PUSH
24987: LD_INT 3
24989: ARRAY
24990: PPUSH
24991: LD_VAR 0 2
24995: PUSH
24996: LD_INT 4
24998: ARRAY
24999: PPUSH
25000: CALL_OW 449
25004: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25005: LD_ADDR_VAR 0 3
25009: PUSH
25010: LD_VAR 0 5
25014: PPUSH
25015: LD_INT 1
25017: PPUSH
25018: CALL_OW 275
25022: PUSH
25023: LD_VAR 0 4
25027: PUSH
25028: LD_INT 1
25030: ARRAY
25031: GREATEREQUAL
25032: PUSH
25033: LD_VAR 0 5
25037: PPUSH
25038: LD_INT 2
25040: PPUSH
25041: CALL_OW 275
25045: PUSH
25046: LD_VAR 0 4
25050: PUSH
25051: LD_INT 2
25053: ARRAY
25054: GREATEREQUAL
25055: AND
25056: PUSH
25057: LD_VAR 0 5
25061: PPUSH
25062: LD_INT 3
25064: PPUSH
25065: CALL_OW 275
25069: PUSH
25070: LD_VAR 0 4
25074: PUSH
25075: LD_INT 3
25077: ARRAY
25078: GREATEREQUAL
25079: AND
25080: ST_TO_ADDR
// end ;
25081: LD_VAR 0 3
25085: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25086: LD_INT 0
25088: PPUSH
25089: PPUSH
25090: PPUSH
25091: PPUSH
// pom := GetBase ( building ) ;
25092: LD_ADDR_VAR 0 3
25096: PUSH
25097: LD_VAR 0 1
25101: PPUSH
25102: CALL_OW 274
25106: ST_TO_ADDR
// if not pom then
25107: LD_VAR 0 3
25111: NOT
25112: IFFALSE 25116
// exit ;
25114: GO 25286
// btype := GetBType ( building ) ;
25116: LD_ADDR_VAR 0 5
25120: PUSH
25121: LD_VAR 0 1
25125: PPUSH
25126: CALL_OW 266
25130: ST_TO_ADDR
// if btype = b_armoury then
25131: LD_VAR 0 5
25135: PUSH
25136: LD_INT 4
25138: EQUAL
25139: IFFALSE 25149
// btype := b_barracks ;
25141: LD_ADDR_VAR 0 5
25145: PUSH
25146: LD_INT 5
25148: ST_TO_ADDR
// if btype = b_depot then
25149: LD_VAR 0 5
25153: PUSH
25154: LD_INT 0
25156: EQUAL
25157: IFFALSE 25167
// btype := b_warehouse ;
25159: LD_ADDR_VAR 0 5
25163: PUSH
25164: LD_INT 1
25166: ST_TO_ADDR
// if btype = b_workshop then
25167: LD_VAR 0 5
25171: PUSH
25172: LD_INT 2
25174: EQUAL
25175: IFFALSE 25185
// btype := b_factory ;
25177: LD_ADDR_VAR 0 5
25181: PUSH
25182: LD_INT 3
25184: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25185: LD_ADDR_VAR 0 4
25189: PUSH
25190: LD_VAR 0 5
25194: PPUSH
25195: LD_VAR 0 1
25199: PPUSH
25200: CALL_OW 248
25204: PPUSH
25205: CALL_OW 450
25209: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25210: LD_ADDR_VAR 0 2
25214: PUSH
25215: LD_VAR 0 3
25219: PPUSH
25220: LD_INT 1
25222: PPUSH
25223: CALL_OW 275
25227: PUSH
25228: LD_VAR 0 4
25232: PUSH
25233: LD_INT 1
25235: ARRAY
25236: GREATEREQUAL
25237: PUSH
25238: LD_VAR 0 3
25242: PPUSH
25243: LD_INT 2
25245: PPUSH
25246: CALL_OW 275
25250: PUSH
25251: LD_VAR 0 4
25255: PUSH
25256: LD_INT 2
25258: ARRAY
25259: GREATEREQUAL
25260: AND
25261: PUSH
25262: LD_VAR 0 3
25266: PPUSH
25267: LD_INT 3
25269: PPUSH
25270: CALL_OW 275
25274: PUSH
25275: LD_VAR 0 4
25279: PUSH
25280: LD_INT 3
25282: ARRAY
25283: GREATEREQUAL
25284: AND
25285: ST_TO_ADDR
// end ;
25286: LD_VAR 0 2
25290: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25291: LD_INT 0
25293: PPUSH
25294: PPUSH
25295: PPUSH
// pom := GetBase ( building ) ;
25296: LD_ADDR_VAR 0 4
25300: PUSH
25301: LD_VAR 0 1
25305: PPUSH
25306: CALL_OW 274
25310: ST_TO_ADDR
// if not pom then
25311: LD_VAR 0 4
25315: NOT
25316: IFFALSE 25320
// exit ;
25318: GO 25421
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25320: LD_ADDR_VAR 0 5
25324: PUSH
25325: LD_VAR 0 2
25329: PPUSH
25330: LD_VAR 0 1
25334: PPUSH
25335: CALL_OW 248
25339: PPUSH
25340: CALL_OW 450
25344: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25345: LD_ADDR_VAR 0 3
25349: PUSH
25350: LD_VAR 0 4
25354: PPUSH
25355: LD_INT 1
25357: PPUSH
25358: CALL_OW 275
25362: PUSH
25363: LD_VAR 0 5
25367: PUSH
25368: LD_INT 1
25370: ARRAY
25371: GREATEREQUAL
25372: PUSH
25373: LD_VAR 0 4
25377: PPUSH
25378: LD_INT 2
25380: PPUSH
25381: CALL_OW 275
25385: PUSH
25386: LD_VAR 0 5
25390: PUSH
25391: LD_INT 2
25393: ARRAY
25394: GREATEREQUAL
25395: AND
25396: PUSH
25397: LD_VAR 0 4
25401: PPUSH
25402: LD_INT 3
25404: PPUSH
25405: CALL_OW 275
25409: PUSH
25410: LD_VAR 0 5
25414: PUSH
25415: LD_INT 3
25417: ARRAY
25418: GREATEREQUAL
25419: AND
25420: ST_TO_ADDR
// end ;
25421: LD_VAR 0 3
25425: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
25426: LD_INT 0
25428: PPUSH
25429: PPUSH
25430: PPUSH
25431: PPUSH
25432: PPUSH
25433: PPUSH
25434: PPUSH
25435: PPUSH
25436: PPUSH
25437: PPUSH
25438: PPUSH
// result := false ;
25439: LD_ADDR_VAR 0 8
25443: PUSH
25444: LD_INT 0
25446: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
25447: LD_VAR 0 5
25451: NOT
25452: PUSH
25453: LD_VAR 0 1
25457: NOT
25458: OR
25459: PUSH
25460: LD_VAR 0 2
25464: NOT
25465: OR
25466: PUSH
25467: LD_VAR 0 3
25471: NOT
25472: OR
25473: IFFALSE 25477
// exit ;
25475: GO 26291
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
25477: LD_ADDR_VAR 0 14
25481: PUSH
25482: LD_VAR 0 1
25486: PPUSH
25487: LD_VAR 0 2
25491: PPUSH
25492: LD_VAR 0 3
25496: PPUSH
25497: LD_VAR 0 4
25501: PPUSH
25502: LD_VAR 0 5
25506: PUSH
25507: LD_INT 1
25509: ARRAY
25510: PPUSH
25511: CALL_OW 248
25515: PPUSH
25516: LD_INT 0
25518: PPUSH
25519: CALL 27128 0 6
25523: ST_TO_ADDR
// if not hexes then
25524: LD_VAR 0 14
25528: NOT
25529: IFFALSE 25533
// exit ;
25531: GO 26291
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25533: LD_ADDR_VAR 0 17
25537: PUSH
25538: LD_VAR 0 5
25542: PPUSH
25543: LD_INT 22
25545: PUSH
25546: LD_VAR 0 13
25550: PPUSH
25551: CALL_OW 255
25555: PUSH
25556: EMPTY
25557: LIST
25558: LIST
25559: PUSH
25560: LD_INT 2
25562: PUSH
25563: LD_INT 30
25565: PUSH
25566: LD_INT 0
25568: PUSH
25569: EMPTY
25570: LIST
25571: LIST
25572: PUSH
25573: LD_INT 30
25575: PUSH
25576: LD_INT 1
25578: PUSH
25579: EMPTY
25580: LIST
25581: LIST
25582: PUSH
25583: EMPTY
25584: LIST
25585: LIST
25586: LIST
25587: PUSH
25588: EMPTY
25589: LIST
25590: LIST
25591: PPUSH
25592: CALL_OW 72
25596: ST_TO_ADDR
// for i = 1 to hexes do
25597: LD_ADDR_VAR 0 9
25601: PUSH
25602: DOUBLE
25603: LD_INT 1
25605: DEC
25606: ST_TO_ADDR
25607: LD_VAR 0 14
25611: PUSH
25612: FOR_TO
25613: IFFALSE 26289
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25615: LD_ADDR_VAR 0 13
25619: PUSH
25620: LD_VAR 0 14
25624: PUSH
25625: LD_VAR 0 9
25629: ARRAY
25630: PUSH
25631: LD_INT 1
25633: ARRAY
25634: PPUSH
25635: LD_VAR 0 14
25639: PUSH
25640: LD_VAR 0 9
25644: ARRAY
25645: PUSH
25646: LD_INT 2
25648: ARRAY
25649: PPUSH
25650: CALL_OW 428
25654: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25655: LD_VAR 0 14
25659: PUSH
25660: LD_VAR 0 9
25664: ARRAY
25665: PUSH
25666: LD_INT 1
25668: ARRAY
25669: PPUSH
25670: LD_VAR 0 14
25674: PUSH
25675: LD_VAR 0 9
25679: ARRAY
25680: PUSH
25681: LD_INT 2
25683: ARRAY
25684: PPUSH
25685: CALL_OW 351
25689: PUSH
25690: LD_VAR 0 14
25694: PUSH
25695: LD_VAR 0 9
25699: ARRAY
25700: PUSH
25701: LD_INT 1
25703: ARRAY
25704: PPUSH
25705: LD_VAR 0 14
25709: PUSH
25710: LD_VAR 0 9
25714: ARRAY
25715: PUSH
25716: LD_INT 2
25718: ARRAY
25719: PPUSH
25720: CALL_OW 488
25724: NOT
25725: OR
25726: PUSH
25727: LD_VAR 0 13
25731: PPUSH
25732: CALL_OW 247
25736: PUSH
25737: LD_INT 3
25739: EQUAL
25740: OR
25741: IFFALSE 25747
// exit ;
25743: POP
25744: POP
25745: GO 26291
// if not tmp then
25747: LD_VAR 0 13
25751: NOT
25752: IFFALSE 25756
// continue ;
25754: GO 25612
// result := true ;
25756: LD_ADDR_VAR 0 8
25760: PUSH
25761: LD_INT 1
25763: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
25764: LD_VAR 0 6
25768: PUSH
25769: LD_VAR 0 13
25773: PPUSH
25774: CALL_OW 247
25778: PUSH
25779: LD_INT 2
25781: EQUAL
25782: AND
25783: PUSH
25784: LD_VAR 0 13
25788: PPUSH
25789: CALL_OW 263
25793: PUSH
25794: LD_INT 1
25796: EQUAL
25797: AND
25798: IFFALSE 25962
// begin if IsDrivenBy ( tmp ) then
25800: LD_VAR 0 13
25804: PPUSH
25805: CALL_OW 311
25809: IFFALSE 25813
// continue ;
25811: GO 25612
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
25813: LD_VAR 0 6
25817: PPUSH
25818: LD_INT 3
25820: PUSH
25821: LD_INT 60
25823: PUSH
25824: EMPTY
25825: LIST
25826: PUSH
25827: EMPTY
25828: LIST
25829: LIST
25830: PUSH
25831: LD_INT 3
25833: PUSH
25834: LD_INT 55
25836: PUSH
25837: EMPTY
25838: LIST
25839: PUSH
25840: EMPTY
25841: LIST
25842: LIST
25843: PUSH
25844: EMPTY
25845: LIST
25846: LIST
25847: PPUSH
25848: CALL_OW 72
25852: IFFALSE 25960
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
25854: LD_ADDR_VAR 0 18
25858: PUSH
25859: LD_VAR 0 6
25863: PPUSH
25864: LD_INT 3
25866: PUSH
25867: LD_INT 60
25869: PUSH
25870: EMPTY
25871: LIST
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: PUSH
25877: LD_INT 3
25879: PUSH
25880: LD_INT 55
25882: PUSH
25883: EMPTY
25884: LIST
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: PUSH
25890: EMPTY
25891: LIST
25892: LIST
25893: PPUSH
25894: CALL_OW 72
25898: PUSH
25899: LD_INT 1
25901: ARRAY
25902: ST_TO_ADDR
// if IsInUnit ( driver ) then
25903: LD_VAR 0 18
25907: PPUSH
25908: CALL_OW 310
25912: IFFALSE 25923
// ComExit ( driver ) ;
25914: LD_VAR 0 18
25918: PPUSH
25919: CALL 50312 0 1
// AddComEnterUnit ( driver , tmp ) ;
25923: LD_VAR 0 18
25927: PPUSH
25928: LD_VAR 0 13
25932: PPUSH
25933: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
25937: LD_VAR 0 18
25941: PPUSH
25942: LD_VAR 0 7
25946: PPUSH
25947: CALL_OW 173
// AddComExitVehicle ( driver ) ;
25951: LD_VAR 0 18
25955: PPUSH
25956: CALL_OW 181
// end ; continue ;
25960: GO 25612
// end ; if not cleaners or not tmp in cleaners then
25962: LD_VAR 0 6
25966: NOT
25967: PUSH
25968: LD_VAR 0 13
25972: PUSH
25973: LD_VAR 0 6
25977: IN
25978: NOT
25979: OR
25980: IFFALSE 26287
// begin if dep then
25982: LD_VAR 0 17
25986: IFFALSE 26122
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
25988: LD_ADDR_VAR 0 16
25992: PUSH
25993: LD_VAR 0 17
25997: PUSH
25998: LD_INT 1
26000: ARRAY
26001: PPUSH
26002: CALL_OW 250
26006: PPUSH
26007: LD_VAR 0 17
26011: PUSH
26012: LD_INT 1
26014: ARRAY
26015: PPUSH
26016: CALL_OW 254
26020: PPUSH
26021: LD_INT 5
26023: PPUSH
26024: CALL_OW 272
26028: PUSH
26029: LD_VAR 0 17
26033: PUSH
26034: LD_INT 1
26036: ARRAY
26037: PPUSH
26038: CALL_OW 251
26042: PPUSH
26043: LD_VAR 0 17
26047: PUSH
26048: LD_INT 1
26050: ARRAY
26051: PPUSH
26052: CALL_OW 254
26056: PPUSH
26057: LD_INT 5
26059: PPUSH
26060: CALL_OW 273
26064: PUSH
26065: EMPTY
26066: LIST
26067: LIST
26068: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26069: LD_VAR 0 16
26073: PUSH
26074: LD_INT 1
26076: ARRAY
26077: PPUSH
26078: LD_VAR 0 16
26082: PUSH
26083: LD_INT 2
26085: ARRAY
26086: PPUSH
26087: CALL_OW 488
26091: IFFALSE 26122
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26093: LD_VAR 0 13
26097: PPUSH
26098: LD_VAR 0 16
26102: PUSH
26103: LD_INT 1
26105: ARRAY
26106: PPUSH
26107: LD_VAR 0 16
26111: PUSH
26112: LD_INT 2
26114: ARRAY
26115: PPUSH
26116: CALL_OW 111
// continue ;
26120: GO 25612
// end ; end ; r := GetDir ( tmp ) ;
26122: LD_ADDR_VAR 0 15
26126: PUSH
26127: LD_VAR 0 13
26131: PPUSH
26132: CALL_OW 254
26136: ST_TO_ADDR
// if r = 5 then
26137: LD_VAR 0 15
26141: PUSH
26142: LD_INT 5
26144: EQUAL
26145: IFFALSE 26155
// r := 0 ;
26147: LD_ADDR_VAR 0 15
26151: PUSH
26152: LD_INT 0
26154: ST_TO_ADDR
// for j = r to 5 do
26155: LD_ADDR_VAR 0 10
26159: PUSH
26160: DOUBLE
26161: LD_VAR 0 15
26165: DEC
26166: ST_TO_ADDR
26167: LD_INT 5
26169: PUSH
26170: FOR_TO
26171: IFFALSE 26285
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26173: LD_ADDR_VAR 0 11
26177: PUSH
26178: LD_VAR 0 13
26182: PPUSH
26183: CALL_OW 250
26187: PPUSH
26188: LD_VAR 0 10
26192: PPUSH
26193: LD_INT 2
26195: PPUSH
26196: CALL_OW 272
26200: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26201: LD_ADDR_VAR 0 12
26205: PUSH
26206: LD_VAR 0 13
26210: PPUSH
26211: CALL_OW 251
26215: PPUSH
26216: LD_VAR 0 10
26220: PPUSH
26221: LD_INT 2
26223: PPUSH
26224: CALL_OW 273
26228: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26229: LD_VAR 0 11
26233: PPUSH
26234: LD_VAR 0 12
26238: PPUSH
26239: CALL_OW 488
26243: PUSH
26244: LD_VAR 0 11
26248: PPUSH
26249: LD_VAR 0 12
26253: PPUSH
26254: CALL_OW 428
26258: NOT
26259: AND
26260: IFFALSE 26283
// begin ComMoveXY ( tmp , _x , _y ) ;
26262: LD_VAR 0 13
26266: PPUSH
26267: LD_VAR 0 11
26271: PPUSH
26272: LD_VAR 0 12
26276: PPUSH
26277: CALL_OW 111
// break ;
26281: GO 26285
// end ; end ;
26283: GO 26170
26285: POP
26286: POP
// end ; end ;
26287: GO 25612
26289: POP
26290: POP
// end ;
26291: LD_VAR 0 8
26295: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
26296: LD_INT 0
26298: PPUSH
26299: PPUSH
26300: PPUSH
26301: PPUSH
26302: PPUSH
26303: PPUSH
26304: PPUSH
26305: PPUSH
26306: PPUSH
26307: PPUSH
// result := false ;
26308: LD_ADDR_VAR 0 6
26312: PUSH
26313: LD_INT 0
26315: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26316: LD_VAR 0 1
26320: NOT
26321: PUSH
26322: LD_VAR 0 1
26326: PPUSH
26327: CALL_OW 266
26331: PUSH
26332: LD_INT 0
26334: PUSH
26335: LD_INT 1
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: IN
26342: NOT
26343: OR
26344: PUSH
26345: LD_VAR 0 2
26349: NOT
26350: OR
26351: PUSH
26352: LD_VAR 0 5
26356: PUSH
26357: LD_INT 0
26359: PUSH
26360: LD_INT 1
26362: PUSH
26363: LD_INT 2
26365: PUSH
26366: LD_INT 3
26368: PUSH
26369: LD_INT 4
26371: PUSH
26372: LD_INT 5
26374: PUSH
26375: EMPTY
26376: LIST
26377: LIST
26378: LIST
26379: LIST
26380: LIST
26381: LIST
26382: IN
26383: NOT
26384: OR
26385: PUSH
26386: LD_VAR 0 3
26390: PPUSH
26391: LD_VAR 0 4
26395: PPUSH
26396: CALL_OW 488
26400: NOT
26401: OR
26402: IFFALSE 26406
// exit ;
26404: GO 27123
// pom := GetBase ( depot ) ;
26406: LD_ADDR_VAR 0 10
26410: PUSH
26411: LD_VAR 0 1
26415: PPUSH
26416: CALL_OW 274
26420: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26421: LD_ADDR_VAR 0 11
26425: PUSH
26426: LD_VAR 0 2
26430: PPUSH
26431: LD_VAR 0 1
26435: PPUSH
26436: CALL_OW 248
26440: PPUSH
26441: CALL_OW 450
26445: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26446: LD_VAR 0 10
26450: PPUSH
26451: LD_INT 1
26453: PPUSH
26454: CALL_OW 275
26458: PUSH
26459: LD_VAR 0 11
26463: PUSH
26464: LD_INT 1
26466: ARRAY
26467: GREATEREQUAL
26468: PUSH
26469: LD_VAR 0 10
26473: PPUSH
26474: LD_INT 2
26476: PPUSH
26477: CALL_OW 275
26481: PUSH
26482: LD_VAR 0 11
26486: PUSH
26487: LD_INT 2
26489: ARRAY
26490: GREATEREQUAL
26491: AND
26492: PUSH
26493: LD_VAR 0 10
26497: PPUSH
26498: LD_INT 3
26500: PPUSH
26501: CALL_OW 275
26505: PUSH
26506: LD_VAR 0 11
26510: PUSH
26511: LD_INT 3
26513: ARRAY
26514: GREATEREQUAL
26515: AND
26516: NOT
26517: IFFALSE 26521
// exit ;
26519: GO 27123
// if GetBType ( depot ) = b_depot then
26521: LD_VAR 0 1
26525: PPUSH
26526: CALL_OW 266
26530: PUSH
26531: LD_INT 0
26533: EQUAL
26534: IFFALSE 26546
// dist := 28 else
26536: LD_ADDR_VAR 0 14
26540: PUSH
26541: LD_INT 28
26543: ST_TO_ADDR
26544: GO 26554
// dist := 36 ;
26546: LD_ADDR_VAR 0 14
26550: PUSH
26551: LD_INT 36
26553: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26554: LD_VAR 0 1
26558: PPUSH
26559: LD_VAR 0 3
26563: PPUSH
26564: LD_VAR 0 4
26568: PPUSH
26569: CALL_OW 297
26573: PUSH
26574: LD_VAR 0 14
26578: GREATER
26579: IFFALSE 26583
// exit ;
26581: GO 27123
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
26583: LD_ADDR_VAR 0 12
26587: PUSH
26588: LD_VAR 0 2
26592: PPUSH
26593: LD_VAR 0 3
26597: PPUSH
26598: LD_VAR 0 4
26602: PPUSH
26603: LD_VAR 0 5
26607: PPUSH
26608: LD_VAR 0 1
26612: PPUSH
26613: CALL_OW 248
26617: PPUSH
26618: LD_INT 0
26620: PPUSH
26621: CALL 27128 0 6
26625: ST_TO_ADDR
// if not hexes then
26626: LD_VAR 0 12
26630: NOT
26631: IFFALSE 26635
// exit ;
26633: GO 27123
// hex := GetHexInfo ( x , y ) ;
26635: LD_ADDR_VAR 0 15
26639: PUSH
26640: LD_VAR 0 3
26644: PPUSH
26645: LD_VAR 0 4
26649: PPUSH
26650: CALL_OW 546
26654: ST_TO_ADDR
// if hex [ 1 ] then
26655: LD_VAR 0 15
26659: PUSH
26660: LD_INT 1
26662: ARRAY
26663: IFFALSE 26667
// exit ;
26665: GO 27123
// height := hex [ 2 ] ;
26667: LD_ADDR_VAR 0 13
26671: PUSH
26672: LD_VAR 0 15
26676: PUSH
26677: LD_INT 2
26679: ARRAY
26680: ST_TO_ADDR
// for i = 1 to hexes do
26681: LD_ADDR_VAR 0 7
26685: PUSH
26686: DOUBLE
26687: LD_INT 1
26689: DEC
26690: ST_TO_ADDR
26691: LD_VAR 0 12
26695: PUSH
26696: FOR_TO
26697: IFFALSE 27027
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
26699: LD_VAR 0 12
26703: PUSH
26704: LD_VAR 0 7
26708: ARRAY
26709: PUSH
26710: LD_INT 1
26712: ARRAY
26713: PPUSH
26714: LD_VAR 0 12
26718: PUSH
26719: LD_VAR 0 7
26723: ARRAY
26724: PUSH
26725: LD_INT 2
26727: ARRAY
26728: PPUSH
26729: CALL_OW 488
26733: NOT
26734: PUSH
26735: LD_VAR 0 12
26739: PUSH
26740: LD_VAR 0 7
26744: ARRAY
26745: PUSH
26746: LD_INT 1
26748: ARRAY
26749: PPUSH
26750: LD_VAR 0 12
26754: PUSH
26755: LD_VAR 0 7
26759: ARRAY
26760: PUSH
26761: LD_INT 2
26763: ARRAY
26764: PPUSH
26765: CALL_OW 428
26769: PUSH
26770: LD_INT 0
26772: GREATER
26773: OR
26774: PUSH
26775: LD_VAR 0 12
26779: PUSH
26780: LD_VAR 0 7
26784: ARRAY
26785: PUSH
26786: LD_INT 1
26788: ARRAY
26789: PPUSH
26790: LD_VAR 0 12
26794: PUSH
26795: LD_VAR 0 7
26799: ARRAY
26800: PUSH
26801: LD_INT 2
26803: ARRAY
26804: PPUSH
26805: CALL_OW 351
26809: OR
26810: IFFALSE 26816
// exit ;
26812: POP
26813: POP
26814: GO 27123
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26816: LD_ADDR_VAR 0 8
26820: PUSH
26821: LD_VAR 0 12
26825: PUSH
26826: LD_VAR 0 7
26830: ARRAY
26831: PUSH
26832: LD_INT 1
26834: ARRAY
26835: PPUSH
26836: LD_VAR 0 12
26840: PUSH
26841: LD_VAR 0 7
26845: ARRAY
26846: PUSH
26847: LD_INT 2
26849: ARRAY
26850: PPUSH
26851: CALL_OW 546
26855: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
26856: LD_VAR 0 8
26860: PUSH
26861: LD_INT 1
26863: ARRAY
26864: PUSH
26865: LD_VAR 0 8
26869: PUSH
26870: LD_INT 2
26872: ARRAY
26873: PUSH
26874: LD_VAR 0 13
26878: PUSH
26879: LD_INT 2
26881: PLUS
26882: GREATER
26883: OR
26884: PUSH
26885: LD_VAR 0 8
26889: PUSH
26890: LD_INT 2
26892: ARRAY
26893: PUSH
26894: LD_VAR 0 13
26898: PUSH
26899: LD_INT 2
26901: MINUS
26902: LESS
26903: OR
26904: PUSH
26905: LD_VAR 0 8
26909: PUSH
26910: LD_INT 3
26912: ARRAY
26913: PUSH
26914: LD_INT 0
26916: PUSH
26917: LD_INT 8
26919: PUSH
26920: LD_INT 9
26922: PUSH
26923: LD_INT 10
26925: PUSH
26926: LD_INT 11
26928: PUSH
26929: LD_INT 12
26931: PUSH
26932: LD_INT 13
26934: PUSH
26935: LD_INT 16
26937: PUSH
26938: LD_INT 17
26940: PUSH
26941: LD_INT 18
26943: PUSH
26944: LD_INT 19
26946: PUSH
26947: LD_INT 20
26949: PUSH
26950: LD_INT 21
26952: PUSH
26953: EMPTY
26954: LIST
26955: LIST
26956: LIST
26957: LIST
26958: LIST
26959: LIST
26960: LIST
26961: LIST
26962: LIST
26963: LIST
26964: LIST
26965: LIST
26966: LIST
26967: IN
26968: NOT
26969: OR
26970: PUSH
26971: LD_VAR 0 8
26975: PUSH
26976: LD_INT 5
26978: ARRAY
26979: NOT
26980: OR
26981: PUSH
26982: LD_VAR 0 8
26986: PUSH
26987: LD_INT 6
26989: ARRAY
26990: PUSH
26991: LD_INT 1
26993: PUSH
26994: LD_INT 2
26996: PUSH
26997: LD_INT 7
26999: PUSH
27000: LD_INT 9
27002: PUSH
27003: LD_INT 10
27005: PUSH
27006: LD_INT 11
27008: PUSH
27009: EMPTY
27010: LIST
27011: LIST
27012: LIST
27013: LIST
27014: LIST
27015: LIST
27016: IN
27017: NOT
27018: OR
27019: IFFALSE 27025
// exit ;
27021: POP
27022: POP
27023: GO 27123
// end ;
27025: GO 26696
27027: POP
27028: POP
// side := GetSide ( depot ) ;
27029: LD_ADDR_VAR 0 9
27033: PUSH
27034: LD_VAR 0 1
27038: PPUSH
27039: CALL_OW 255
27043: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27044: LD_VAR 0 9
27048: PPUSH
27049: LD_VAR 0 3
27053: PPUSH
27054: LD_VAR 0 4
27058: PPUSH
27059: LD_INT 20
27061: PPUSH
27062: CALL 19444 0 4
27066: PUSH
27067: LD_INT 4
27069: ARRAY
27070: IFFALSE 27074
// exit ;
27072: GO 27123
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27074: LD_VAR 0 2
27078: PUSH
27079: LD_INT 29
27081: PUSH
27082: LD_INT 30
27084: PUSH
27085: EMPTY
27086: LIST
27087: LIST
27088: IN
27089: PUSH
27090: LD_VAR 0 3
27094: PPUSH
27095: LD_VAR 0 4
27099: PPUSH
27100: LD_VAR 0 9
27104: PPUSH
27105: CALL_OW 440
27109: NOT
27110: AND
27111: IFFALSE 27115
// exit ;
27113: GO 27123
// result := true ;
27115: LD_ADDR_VAR 0 6
27119: PUSH
27120: LD_INT 1
27122: ST_TO_ADDR
// end ;
27123: LD_VAR 0 6
27127: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
27128: LD_INT 0
27130: PPUSH
27131: PPUSH
27132: PPUSH
27133: PPUSH
27134: PPUSH
27135: PPUSH
27136: PPUSH
27137: PPUSH
27138: PPUSH
27139: PPUSH
27140: PPUSH
27141: PPUSH
27142: PPUSH
27143: PPUSH
27144: PPUSH
27145: PPUSH
27146: PPUSH
27147: PPUSH
27148: PPUSH
27149: PPUSH
27150: PPUSH
27151: PPUSH
27152: PPUSH
27153: PPUSH
27154: PPUSH
27155: PPUSH
27156: PPUSH
27157: PPUSH
27158: PPUSH
27159: PPUSH
27160: PPUSH
27161: PPUSH
27162: PPUSH
27163: PPUSH
27164: PPUSH
27165: PPUSH
27166: PPUSH
27167: PPUSH
27168: PPUSH
27169: PPUSH
27170: PPUSH
27171: PPUSH
27172: PPUSH
27173: PPUSH
27174: PPUSH
27175: PPUSH
27176: PPUSH
27177: PPUSH
27178: PPUSH
27179: PPUSH
27180: PPUSH
27181: PPUSH
27182: PPUSH
27183: PPUSH
27184: PPUSH
27185: PPUSH
27186: PPUSH
27187: PPUSH
// result = [ ] ;
27188: LD_ADDR_VAR 0 7
27192: PUSH
27193: EMPTY
27194: ST_TO_ADDR
// temp_list = [ ] ;
27195: LD_ADDR_VAR 0 9
27199: PUSH
27200: EMPTY
27201: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27202: LD_VAR 0 4
27206: PUSH
27207: LD_INT 0
27209: PUSH
27210: LD_INT 1
27212: PUSH
27213: LD_INT 2
27215: PUSH
27216: LD_INT 3
27218: PUSH
27219: LD_INT 4
27221: PUSH
27222: LD_INT 5
27224: PUSH
27225: EMPTY
27226: LIST
27227: LIST
27228: LIST
27229: LIST
27230: LIST
27231: LIST
27232: IN
27233: NOT
27234: PUSH
27235: LD_VAR 0 1
27239: PUSH
27240: LD_INT 0
27242: PUSH
27243: LD_INT 1
27245: PUSH
27246: EMPTY
27247: LIST
27248: LIST
27249: IN
27250: PUSH
27251: LD_VAR 0 5
27255: PUSH
27256: LD_INT 1
27258: PUSH
27259: LD_INT 2
27261: PUSH
27262: LD_INT 3
27264: PUSH
27265: EMPTY
27266: LIST
27267: LIST
27268: LIST
27269: IN
27270: NOT
27271: AND
27272: OR
27273: IFFALSE 27277
// exit ;
27275: GO 45668
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27277: LD_VAR 0 1
27281: PUSH
27282: LD_INT 6
27284: PUSH
27285: LD_INT 7
27287: PUSH
27288: LD_INT 8
27290: PUSH
27291: LD_INT 13
27293: PUSH
27294: LD_INT 12
27296: PUSH
27297: LD_INT 15
27299: PUSH
27300: LD_INT 11
27302: PUSH
27303: LD_INT 14
27305: PUSH
27306: LD_INT 10
27308: PUSH
27309: EMPTY
27310: LIST
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: LIST
27317: LIST
27318: LIST
27319: IN
27320: IFFALSE 27330
// btype = b_lab ;
27322: LD_ADDR_VAR 0 1
27326: PUSH
27327: LD_INT 6
27329: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27330: LD_VAR 0 6
27334: PUSH
27335: LD_INT 0
27337: PUSH
27338: LD_INT 1
27340: PUSH
27341: LD_INT 2
27343: PUSH
27344: EMPTY
27345: LIST
27346: LIST
27347: LIST
27348: IN
27349: NOT
27350: PUSH
27351: LD_VAR 0 1
27355: PUSH
27356: LD_INT 0
27358: PUSH
27359: LD_INT 1
27361: PUSH
27362: LD_INT 2
27364: PUSH
27365: LD_INT 3
27367: PUSH
27368: LD_INT 6
27370: PUSH
27371: LD_INT 36
27373: PUSH
27374: LD_INT 4
27376: PUSH
27377: LD_INT 5
27379: PUSH
27380: LD_INT 31
27382: PUSH
27383: LD_INT 32
27385: PUSH
27386: LD_INT 33
27388: PUSH
27389: EMPTY
27390: LIST
27391: LIST
27392: LIST
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: LIST
27398: LIST
27399: LIST
27400: LIST
27401: IN
27402: NOT
27403: PUSH
27404: LD_VAR 0 6
27408: PUSH
27409: LD_INT 1
27411: EQUAL
27412: AND
27413: OR
27414: PUSH
27415: LD_VAR 0 1
27419: PUSH
27420: LD_INT 2
27422: PUSH
27423: LD_INT 3
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: IN
27430: NOT
27431: PUSH
27432: LD_VAR 0 6
27436: PUSH
27437: LD_INT 2
27439: EQUAL
27440: AND
27441: OR
27442: IFFALSE 27452
// mode = 0 ;
27444: LD_ADDR_VAR 0 6
27448: PUSH
27449: LD_INT 0
27451: ST_TO_ADDR
// case mode of 0 :
27452: LD_VAR 0 6
27456: PUSH
27457: LD_INT 0
27459: DOUBLE
27460: EQUAL
27461: IFTRUE 27465
27463: GO 38918
27465: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27466: LD_ADDR_VAR 0 11
27470: PUSH
27471: LD_INT 0
27473: PUSH
27474: LD_INT 0
27476: PUSH
27477: EMPTY
27478: LIST
27479: LIST
27480: PUSH
27481: LD_INT 0
27483: PUSH
27484: LD_INT 1
27486: NEG
27487: PUSH
27488: EMPTY
27489: LIST
27490: LIST
27491: PUSH
27492: LD_INT 1
27494: PUSH
27495: LD_INT 0
27497: PUSH
27498: EMPTY
27499: LIST
27500: LIST
27501: PUSH
27502: LD_INT 1
27504: PUSH
27505: LD_INT 1
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: PUSH
27512: LD_INT 0
27514: PUSH
27515: LD_INT 1
27517: PUSH
27518: EMPTY
27519: LIST
27520: LIST
27521: PUSH
27522: LD_INT 1
27524: NEG
27525: PUSH
27526: LD_INT 0
27528: PUSH
27529: EMPTY
27530: LIST
27531: LIST
27532: PUSH
27533: LD_INT 1
27535: NEG
27536: PUSH
27537: LD_INT 1
27539: NEG
27540: PUSH
27541: EMPTY
27542: LIST
27543: LIST
27544: PUSH
27545: LD_INT 1
27547: NEG
27548: PUSH
27549: LD_INT 2
27551: NEG
27552: PUSH
27553: EMPTY
27554: LIST
27555: LIST
27556: PUSH
27557: LD_INT 0
27559: PUSH
27560: LD_INT 2
27562: NEG
27563: PUSH
27564: EMPTY
27565: LIST
27566: LIST
27567: PUSH
27568: LD_INT 1
27570: PUSH
27571: LD_INT 1
27573: NEG
27574: PUSH
27575: EMPTY
27576: LIST
27577: LIST
27578: PUSH
27579: LD_INT 1
27581: PUSH
27582: LD_INT 2
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 0
27591: PUSH
27592: LD_INT 2
27594: PUSH
27595: EMPTY
27596: LIST
27597: LIST
27598: PUSH
27599: LD_INT 1
27601: NEG
27602: PUSH
27603: LD_INT 1
27605: PUSH
27606: EMPTY
27607: LIST
27608: LIST
27609: PUSH
27610: LD_INT 1
27612: PUSH
27613: LD_INT 3
27615: PUSH
27616: EMPTY
27617: LIST
27618: LIST
27619: PUSH
27620: LD_INT 0
27622: PUSH
27623: LD_INT 3
27625: PUSH
27626: EMPTY
27627: LIST
27628: LIST
27629: PUSH
27630: LD_INT 1
27632: NEG
27633: PUSH
27634: LD_INT 2
27636: PUSH
27637: EMPTY
27638: LIST
27639: LIST
27640: PUSH
27641: EMPTY
27642: LIST
27643: LIST
27644: LIST
27645: LIST
27646: LIST
27647: LIST
27648: LIST
27649: LIST
27650: LIST
27651: LIST
27652: LIST
27653: LIST
27654: LIST
27655: LIST
27656: LIST
27657: LIST
27658: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
27659: LD_ADDR_VAR 0 12
27663: PUSH
27664: LD_INT 0
27666: PUSH
27667: LD_INT 0
27669: PUSH
27670: EMPTY
27671: LIST
27672: LIST
27673: PUSH
27674: LD_INT 0
27676: PUSH
27677: LD_INT 1
27679: NEG
27680: PUSH
27681: EMPTY
27682: LIST
27683: LIST
27684: PUSH
27685: LD_INT 1
27687: PUSH
27688: LD_INT 0
27690: PUSH
27691: EMPTY
27692: LIST
27693: LIST
27694: PUSH
27695: LD_INT 1
27697: PUSH
27698: LD_INT 1
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: PUSH
27705: LD_INT 0
27707: PUSH
27708: LD_INT 1
27710: PUSH
27711: EMPTY
27712: LIST
27713: LIST
27714: PUSH
27715: LD_INT 1
27717: NEG
27718: PUSH
27719: LD_INT 0
27721: PUSH
27722: EMPTY
27723: LIST
27724: LIST
27725: PUSH
27726: LD_INT 1
27728: NEG
27729: PUSH
27730: LD_INT 1
27732: NEG
27733: PUSH
27734: EMPTY
27735: LIST
27736: LIST
27737: PUSH
27738: LD_INT 1
27740: PUSH
27741: LD_INT 1
27743: NEG
27744: PUSH
27745: EMPTY
27746: LIST
27747: LIST
27748: PUSH
27749: LD_INT 2
27751: PUSH
27752: LD_INT 0
27754: PUSH
27755: EMPTY
27756: LIST
27757: LIST
27758: PUSH
27759: LD_INT 2
27761: PUSH
27762: LD_INT 1
27764: PUSH
27765: EMPTY
27766: LIST
27767: LIST
27768: PUSH
27769: LD_INT 1
27771: NEG
27772: PUSH
27773: LD_INT 1
27775: PUSH
27776: EMPTY
27777: LIST
27778: LIST
27779: PUSH
27780: LD_INT 2
27782: NEG
27783: PUSH
27784: LD_INT 0
27786: PUSH
27787: EMPTY
27788: LIST
27789: LIST
27790: PUSH
27791: LD_INT 2
27793: NEG
27794: PUSH
27795: LD_INT 1
27797: NEG
27798: PUSH
27799: EMPTY
27800: LIST
27801: LIST
27802: PUSH
27803: LD_INT 2
27805: NEG
27806: PUSH
27807: LD_INT 1
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: PUSH
27814: LD_INT 3
27816: NEG
27817: PUSH
27818: LD_INT 0
27820: PUSH
27821: EMPTY
27822: LIST
27823: LIST
27824: PUSH
27825: LD_INT 3
27827: NEG
27828: PUSH
27829: LD_INT 1
27831: NEG
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PUSH
27837: EMPTY
27838: LIST
27839: LIST
27840: LIST
27841: LIST
27842: LIST
27843: LIST
27844: LIST
27845: LIST
27846: LIST
27847: LIST
27848: LIST
27849: LIST
27850: LIST
27851: LIST
27852: LIST
27853: LIST
27854: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
27855: LD_ADDR_VAR 0 13
27859: PUSH
27860: LD_INT 0
27862: PUSH
27863: LD_INT 0
27865: PUSH
27866: EMPTY
27867: LIST
27868: LIST
27869: PUSH
27870: LD_INT 0
27872: PUSH
27873: LD_INT 1
27875: NEG
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 1
27883: PUSH
27884: LD_INT 0
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: LD_INT 1
27893: PUSH
27894: LD_INT 1
27896: PUSH
27897: EMPTY
27898: LIST
27899: LIST
27900: PUSH
27901: LD_INT 0
27903: PUSH
27904: LD_INT 1
27906: PUSH
27907: EMPTY
27908: LIST
27909: LIST
27910: PUSH
27911: LD_INT 1
27913: NEG
27914: PUSH
27915: LD_INT 0
27917: PUSH
27918: EMPTY
27919: LIST
27920: LIST
27921: PUSH
27922: LD_INT 1
27924: NEG
27925: PUSH
27926: LD_INT 1
27928: NEG
27929: PUSH
27930: EMPTY
27931: LIST
27932: LIST
27933: PUSH
27934: LD_INT 1
27936: NEG
27937: PUSH
27938: LD_INT 2
27940: NEG
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 2
27948: PUSH
27949: LD_INT 1
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 2
27958: PUSH
27959: LD_INT 2
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: PUSH
27966: LD_INT 1
27968: PUSH
27969: LD_INT 2
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: PUSH
27976: LD_INT 2
27978: NEG
27979: PUSH
27980: LD_INT 1
27982: NEG
27983: PUSH
27984: EMPTY
27985: LIST
27986: LIST
27987: PUSH
27988: LD_INT 2
27990: NEG
27991: PUSH
27992: LD_INT 2
27994: NEG
27995: PUSH
27996: EMPTY
27997: LIST
27998: LIST
27999: PUSH
28000: LD_INT 2
28002: NEG
28003: PUSH
28004: LD_INT 3
28006: NEG
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: LD_INT 3
28014: NEG
28015: PUSH
28016: LD_INT 2
28018: NEG
28019: PUSH
28020: EMPTY
28021: LIST
28022: LIST
28023: PUSH
28024: LD_INT 3
28026: NEG
28027: PUSH
28028: LD_INT 3
28030: NEG
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: LIST
28040: LIST
28041: LIST
28042: LIST
28043: LIST
28044: LIST
28045: LIST
28046: LIST
28047: LIST
28048: LIST
28049: LIST
28050: LIST
28051: LIST
28052: LIST
28053: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28054: LD_ADDR_VAR 0 14
28058: PUSH
28059: LD_INT 0
28061: PUSH
28062: LD_INT 0
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: PUSH
28069: LD_INT 0
28071: PUSH
28072: LD_INT 1
28074: NEG
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PUSH
28080: LD_INT 1
28082: PUSH
28083: LD_INT 0
28085: PUSH
28086: EMPTY
28087: LIST
28088: LIST
28089: PUSH
28090: LD_INT 1
28092: PUSH
28093: LD_INT 1
28095: PUSH
28096: EMPTY
28097: LIST
28098: LIST
28099: PUSH
28100: LD_INT 0
28102: PUSH
28103: LD_INT 1
28105: PUSH
28106: EMPTY
28107: LIST
28108: LIST
28109: PUSH
28110: LD_INT 1
28112: NEG
28113: PUSH
28114: LD_INT 0
28116: PUSH
28117: EMPTY
28118: LIST
28119: LIST
28120: PUSH
28121: LD_INT 1
28123: NEG
28124: PUSH
28125: LD_INT 1
28127: NEG
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: PUSH
28133: LD_INT 1
28135: NEG
28136: PUSH
28137: LD_INT 2
28139: NEG
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: PUSH
28145: LD_INT 0
28147: PUSH
28148: LD_INT 2
28150: NEG
28151: PUSH
28152: EMPTY
28153: LIST
28154: LIST
28155: PUSH
28156: LD_INT 1
28158: PUSH
28159: LD_INT 1
28161: NEG
28162: PUSH
28163: EMPTY
28164: LIST
28165: LIST
28166: PUSH
28167: LD_INT 1
28169: PUSH
28170: LD_INT 2
28172: PUSH
28173: EMPTY
28174: LIST
28175: LIST
28176: PUSH
28177: LD_INT 0
28179: PUSH
28180: LD_INT 2
28182: PUSH
28183: EMPTY
28184: LIST
28185: LIST
28186: PUSH
28187: LD_INT 1
28189: NEG
28190: PUSH
28191: LD_INT 1
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: PUSH
28198: LD_INT 1
28200: NEG
28201: PUSH
28202: LD_INT 3
28204: NEG
28205: PUSH
28206: EMPTY
28207: LIST
28208: LIST
28209: PUSH
28210: LD_INT 0
28212: PUSH
28213: LD_INT 3
28215: NEG
28216: PUSH
28217: EMPTY
28218: LIST
28219: LIST
28220: PUSH
28221: LD_INT 1
28223: PUSH
28224: LD_INT 2
28226: NEG
28227: PUSH
28228: EMPTY
28229: LIST
28230: LIST
28231: PUSH
28232: EMPTY
28233: LIST
28234: LIST
28235: LIST
28236: LIST
28237: LIST
28238: LIST
28239: LIST
28240: LIST
28241: LIST
28242: LIST
28243: LIST
28244: LIST
28245: LIST
28246: LIST
28247: LIST
28248: LIST
28249: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28250: LD_ADDR_VAR 0 15
28254: PUSH
28255: LD_INT 0
28257: PUSH
28258: LD_INT 0
28260: PUSH
28261: EMPTY
28262: LIST
28263: LIST
28264: PUSH
28265: LD_INT 0
28267: PUSH
28268: LD_INT 1
28270: NEG
28271: PUSH
28272: EMPTY
28273: LIST
28274: LIST
28275: PUSH
28276: LD_INT 1
28278: PUSH
28279: LD_INT 0
28281: PUSH
28282: EMPTY
28283: LIST
28284: LIST
28285: PUSH
28286: LD_INT 1
28288: PUSH
28289: LD_INT 1
28291: PUSH
28292: EMPTY
28293: LIST
28294: LIST
28295: PUSH
28296: LD_INT 0
28298: PUSH
28299: LD_INT 1
28301: PUSH
28302: EMPTY
28303: LIST
28304: LIST
28305: PUSH
28306: LD_INT 1
28308: NEG
28309: PUSH
28310: LD_INT 0
28312: PUSH
28313: EMPTY
28314: LIST
28315: LIST
28316: PUSH
28317: LD_INT 1
28319: NEG
28320: PUSH
28321: LD_INT 1
28323: NEG
28324: PUSH
28325: EMPTY
28326: LIST
28327: LIST
28328: PUSH
28329: LD_INT 1
28331: PUSH
28332: LD_INT 1
28334: NEG
28335: PUSH
28336: EMPTY
28337: LIST
28338: LIST
28339: PUSH
28340: LD_INT 2
28342: PUSH
28343: LD_INT 0
28345: PUSH
28346: EMPTY
28347: LIST
28348: LIST
28349: PUSH
28350: LD_INT 2
28352: PUSH
28353: LD_INT 1
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PUSH
28360: LD_INT 1
28362: NEG
28363: PUSH
28364: LD_INT 1
28366: PUSH
28367: EMPTY
28368: LIST
28369: LIST
28370: PUSH
28371: LD_INT 2
28373: NEG
28374: PUSH
28375: LD_INT 0
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: LD_INT 2
28384: NEG
28385: PUSH
28386: LD_INT 1
28388: NEG
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PUSH
28394: LD_INT 2
28396: PUSH
28397: LD_INT 1
28399: NEG
28400: PUSH
28401: EMPTY
28402: LIST
28403: LIST
28404: PUSH
28405: LD_INT 3
28407: PUSH
28408: LD_INT 0
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 3
28417: PUSH
28418: LD_INT 1
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: PUSH
28425: EMPTY
28426: LIST
28427: LIST
28428: LIST
28429: LIST
28430: LIST
28431: LIST
28432: LIST
28433: LIST
28434: LIST
28435: LIST
28436: LIST
28437: LIST
28438: LIST
28439: LIST
28440: LIST
28441: LIST
28442: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28443: LD_ADDR_VAR 0 16
28447: PUSH
28448: LD_INT 0
28450: PUSH
28451: LD_INT 0
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: PUSH
28458: LD_INT 0
28460: PUSH
28461: LD_INT 1
28463: NEG
28464: PUSH
28465: EMPTY
28466: LIST
28467: LIST
28468: PUSH
28469: LD_INT 1
28471: PUSH
28472: LD_INT 0
28474: PUSH
28475: EMPTY
28476: LIST
28477: LIST
28478: PUSH
28479: LD_INT 1
28481: PUSH
28482: LD_INT 1
28484: PUSH
28485: EMPTY
28486: LIST
28487: LIST
28488: PUSH
28489: LD_INT 0
28491: PUSH
28492: LD_INT 1
28494: PUSH
28495: EMPTY
28496: LIST
28497: LIST
28498: PUSH
28499: LD_INT 1
28501: NEG
28502: PUSH
28503: LD_INT 0
28505: PUSH
28506: EMPTY
28507: LIST
28508: LIST
28509: PUSH
28510: LD_INT 1
28512: NEG
28513: PUSH
28514: LD_INT 1
28516: NEG
28517: PUSH
28518: EMPTY
28519: LIST
28520: LIST
28521: PUSH
28522: LD_INT 1
28524: NEG
28525: PUSH
28526: LD_INT 2
28528: NEG
28529: PUSH
28530: EMPTY
28531: LIST
28532: LIST
28533: PUSH
28534: LD_INT 2
28536: PUSH
28537: LD_INT 1
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: PUSH
28544: LD_INT 2
28546: PUSH
28547: LD_INT 2
28549: PUSH
28550: EMPTY
28551: LIST
28552: LIST
28553: PUSH
28554: LD_INT 1
28556: PUSH
28557: LD_INT 2
28559: PUSH
28560: EMPTY
28561: LIST
28562: LIST
28563: PUSH
28564: LD_INT 2
28566: NEG
28567: PUSH
28568: LD_INT 1
28570: NEG
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: PUSH
28576: LD_INT 2
28578: NEG
28579: PUSH
28580: LD_INT 2
28582: NEG
28583: PUSH
28584: EMPTY
28585: LIST
28586: LIST
28587: PUSH
28588: LD_INT 3
28590: PUSH
28591: LD_INT 2
28593: PUSH
28594: EMPTY
28595: LIST
28596: LIST
28597: PUSH
28598: LD_INT 3
28600: PUSH
28601: LD_INT 3
28603: PUSH
28604: EMPTY
28605: LIST
28606: LIST
28607: PUSH
28608: LD_INT 2
28610: PUSH
28611: LD_INT 3
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: LIST
28622: LIST
28623: LIST
28624: LIST
28625: LIST
28626: LIST
28627: LIST
28628: LIST
28629: LIST
28630: LIST
28631: LIST
28632: LIST
28633: LIST
28634: LIST
28635: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28636: LD_ADDR_VAR 0 17
28640: PUSH
28641: LD_INT 0
28643: PUSH
28644: LD_INT 0
28646: PUSH
28647: EMPTY
28648: LIST
28649: LIST
28650: PUSH
28651: LD_INT 0
28653: PUSH
28654: LD_INT 1
28656: NEG
28657: PUSH
28658: EMPTY
28659: LIST
28660: LIST
28661: PUSH
28662: LD_INT 1
28664: PUSH
28665: LD_INT 0
28667: PUSH
28668: EMPTY
28669: LIST
28670: LIST
28671: PUSH
28672: LD_INT 1
28674: PUSH
28675: LD_INT 1
28677: PUSH
28678: EMPTY
28679: LIST
28680: LIST
28681: PUSH
28682: LD_INT 0
28684: PUSH
28685: LD_INT 1
28687: PUSH
28688: EMPTY
28689: LIST
28690: LIST
28691: PUSH
28692: LD_INT 1
28694: NEG
28695: PUSH
28696: LD_INT 0
28698: PUSH
28699: EMPTY
28700: LIST
28701: LIST
28702: PUSH
28703: LD_INT 1
28705: NEG
28706: PUSH
28707: LD_INT 1
28709: NEG
28710: PUSH
28711: EMPTY
28712: LIST
28713: LIST
28714: PUSH
28715: LD_INT 1
28717: NEG
28718: PUSH
28719: LD_INT 2
28721: NEG
28722: PUSH
28723: EMPTY
28724: LIST
28725: LIST
28726: PUSH
28727: LD_INT 0
28729: PUSH
28730: LD_INT 2
28732: NEG
28733: PUSH
28734: EMPTY
28735: LIST
28736: LIST
28737: PUSH
28738: LD_INT 1
28740: PUSH
28741: LD_INT 1
28743: NEG
28744: PUSH
28745: EMPTY
28746: LIST
28747: LIST
28748: PUSH
28749: LD_INT 2
28751: PUSH
28752: LD_INT 0
28754: PUSH
28755: EMPTY
28756: LIST
28757: LIST
28758: PUSH
28759: LD_INT 2
28761: PUSH
28762: LD_INT 1
28764: PUSH
28765: EMPTY
28766: LIST
28767: LIST
28768: PUSH
28769: LD_INT 2
28771: PUSH
28772: LD_INT 2
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: PUSH
28779: LD_INT 1
28781: PUSH
28782: LD_INT 2
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: PUSH
28789: LD_INT 0
28791: PUSH
28792: LD_INT 2
28794: PUSH
28795: EMPTY
28796: LIST
28797: LIST
28798: PUSH
28799: LD_INT 1
28801: NEG
28802: PUSH
28803: LD_INT 1
28805: PUSH
28806: EMPTY
28807: LIST
28808: LIST
28809: PUSH
28810: LD_INT 2
28812: NEG
28813: PUSH
28814: LD_INT 0
28816: PUSH
28817: EMPTY
28818: LIST
28819: LIST
28820: PUSH
28821: LD_INT 2
28823: NEG
28824: PUSH
28825: LD_INT 1
28827: NEG
28828: PUSH
28829: EMPTY
28830: LIST
28831: LIST
28832: PUSH
28833: LD_INT 2
28835: NEG
28836: PUSH
28837: LD_INT 2
28839: NEG
28840: PUSH
28841: EMPTY
28842: LIST
28843: LIST
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: LIST
28862: LIST
28863: LIST
28864: LIST
28865: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28866: LD_ADDR_VAR 0 18
28870: PUSH
28871: LD_INT 0
28873: PUSH
28874: LD_INT 0
28876: PUSH
28877: EMPTY
28878: LIST
28879: LIST
28880: PUSH
28881: LD_INT 0
28883: PUSH
28884: LD_INT 1
28886: NEG
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: PUSH
28892: LD_INT 1
28894: PUSH
28895: LD_INT 0
28897: PUSH
28898: EMPTY
28899: LIST
28900: LIST
28901: PUSH
28902: LD_INT 1
28904: PUSH
28905: LD_INT 1
28907: PUSH
28908: EMPTY
28909: LIST
28910: LIST
28911: PUSH
28912: LD_INT 0
28914: PUSH
28915: LD_INT 1
28917: PUSH
28918: EMPTY
28919: LIST
28920: LIST
28921: PUSH
28922: LD_INT 1
28924: NEG
28925: PUSH
28926: LD_INT 0
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PUSH
28933: LD_INT 1
28935: NEG
28936: PUSH
28937: LD_INT 1
28939: NEG
28940: PUSH
28941: EMPTY
28942: LIST
28943: LIST
28944: PUSH
28945: LD_INT 1
28947: NEG
28948: PUSH
28949: LD_INT 2
28951: NEG
28952: PUSH
28953: EMPTY
28954: LIST
28955: LIST
28956: PUSH
28957: LD_INT 0
28959: PUSH
28960: LD_INT 2
28962: NEG
28963: PUSH
28964: EMPTY
28965: LIST
28966: LIST
28967: PUSH
28968: LD_INT 1
28970: PUSH
28971: LD_INT 1
28973: NEG
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: PUSH
28979: LD_INT 2
28981: PUSH
28982: LD_INT 0
28984: PUSH
28985: EMPTY
28986: LIST
28987: LIST
28988: PUSH
28989: LD_INT 2
28991: PUSH
28992: LD_INT 1
28994: PUSH
28995: EMPTY
28996: LIST
28997: LIST
28998: PUSH
28999: LD_INT 2
29001: PUSH
29002: LD_INT 2
29004: PUSH
29005: EMPTY
29006: LIST
29007: LIST
29008: PUSH
29009: LD_INT 1
29011: PUSH
29012: LD_INT 2
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: PUSH
29019: LD_INT 0
29021: PUSH
29022: LD_INT 2
29024: PUSH
29025: EMPTY
29026: LIST
29027: LIST
29028: PUSH
29029: LD_INT 1
29031: NEG
29032: PUSH
29033: LD_INT 1
29035: PUSH
29036: EMPTY
29037: LIST
29038: LIST
29039: PUSH
29040: LD_INT 2
29042: NEG
29043: PUSH
29044: LD_INT 0
29046: PUSH
29047: EMPTY
29048: LIST
29049: LIST
29050: PUSH
29051: LD_INT 2
29053: NEG
29054: PUSH
29055: LD_INT 1
29057: NEG
29058: PUSH
29059: EMPTY
29060: LIST
29061: LIST
29062: PUSH
29063: LD_INT 2
29065: NEG
29066: PUSH
29067: LD_INT 2
29069: NEG
29070: PUSH
29071: EMPTY
29072: LIST
29073: LIST
29074: PUSH
29075: EMPTY
29076: LIST
29077: LIST
29078: LIST
29079: LIST
29080: LIST
29081: LIST
29082: LIST
29083: LIST
29084: LIST
29085: LIST
29086: LIST
29087: LIST
29088: LIST
29089: LIST
29090: LIST
29091: LIST
29092: LIST
29093: LIST
29094: LIST
29095: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29096: LD_ADDR_VAR 0 19
29100: PUSH
29101: LD_INT 0
29103: PUSH
29104: LD_INT 0
29106: PUSH
29107: EMPTY
29108: LIST
29109: LIST
29110: PUSH
29111: LD_INT 0
29113: PUSH
29114: LD_INT 1
29116: NEG
29117: PUSH
29118: EMPTY
29119: LIST
29120: LIST
29121: PUSH
29122: LD_INT 1
29124: PUSH
29125: LD_INT 0
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: PUSH
29132: LD_INT 1
29134: PUSH
29135: LD_INT 1
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: PUSH
29142: LD_INT 0
29144: PUSH
29145: LD_INT 1
29147: PUSH
29148: EMPTY
29149: LIST
29150: LIST
29151: PUSH
29152: LD_INT 1
29154: NEG
29155: PUSH
29156: LD_INT 0
29158: PUSH
29159: EMPTY
29160: LIST
29161: LIST
29162: PUSH
29163: LD_INT 1
29165: NEG
29166: PUSH
29167: LD_INT 1
29169: NEG
29170: PUSH
29171: EMPTY
29172: LIST
29173: LIST
29174: PUSH
29175: LD_INT 1
29177: NEG
29178: PUSH
29179: LD_INT 2
29181: NEG
29182: PUSH
29183: EMPTY
29184: LIST
29185: LIST
29186: PUSH
29187: LD_INT 0
29189: PUSH
29190: LD_INT 2
29192: NEG
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: PUSH
29198: LD_INT 1
29200: PUSH
29201: LD_INT 1
29203: NEG
29204: PUSH
29205: EMPTY
29206: LIST
29207: LIST
29208: PUSH
29209: LD_INT 2
29211: PUSH
29212: LD_INT 0
29214: PUSH
29215: EMPTY
29216: LIST
29217: LIST
29218: PUSH
29219: LD_INT 2
29221: PUSH
29222: LD_INT 1
29224: PUSH
29225: EMPTY
29226: LIST
29227: LIST
29228: PUSH
29229: LD_INT 2
29231: PUSH
29232: LD_INT 2
29234: PUSH
29235: EMPTY
29236: LIST
29237: LIST
29238: PUSH
29239: LD_INT 1
29241: PUSH
29242: LD_INT 2
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PUSH
29249: LD_INT 0
29251: PUSH
29252: LD_INT 2
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PUSH
29259: LD_INT 1
29261: NEG
29262: PUSH
29263: LD_INT 1
29265: PUSH
29266: EMPTY
29267: LIST
29268: LIST
29269: PUSH
29270: LD_INT 2
29272: NEG
29273: PUSH
29274: LD_INT 0
29276: PUSH
29277: EMPTY
29278: LIST
29279: LIST
29280: PUSH
29281: LD_INT 2
29283: NEG
29284: PUSH
29285: LD_INT 1
29287: NEG
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: LD_INT 2
29295: NEG
29296: PUSH
29297: LD_INT 2
29299: NEG
29300: PUSH
29301: EMPTY
29302: LIST
29303: LIST
29304: PUSH
29305: EMPTY
29306: LIST
29307: LIST
29308: LIST
29309: LIST
29310: LIST
29311: LIST
29312: LIST
29313: LIST
29314: LIST
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: LIST
29325: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29326: LD_ADDR_VAR 0 20
29330: PUSH
29331: LD_INT 0
29333: PUSH
29334: LD_INT 0
29336: PUSH
29337: EMPTY
29338: LIST
29339: LIST
29340: PUSH
29341: LD_INT 0
29343: PUSH
29344: LD_INT 1
29346: NEG
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: LD_INT 1
29354: PUSH
29355: LD_INT 0
29357: PUSH
29358: EMPTY
29359: LIST
29360: LIST
29361: PUSH
29362: LD_INT 1
29364: PUSH
29365: LD_INT 1
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 0
29374: PUSH
29375: LD_INT 1
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: PUSH
29382: LD_INT 1
29384: NEG
29385: PUSH
29386: LD_INT 0
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 1
29395: NEG
29396: PUSH
29397: LD_INT 1
29399: NEG
29400: PUSH
29401: EMPTY
29402: LIST
29403: LIST
29404: PUSH
29405: LD_INT 1
29407: NEG
29408: PUSH
29409: LD_INT 2
29411: NEG
29412: PUSH
29413: EMPTY
29414: LIST
29415: LIST
29416: PUSH
29417: LD_INT 0
29419: PUSH
29420: LD_INT 2
29422: NEG
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: LD_INT 1
29430: PUSH
29431: LD_INT 1
29433: NEG
29434: PUSH
29435: EMPTY
29436: LIST
29437: LIST
29438: PUSH
29439: LD_INT 2
29441: PUSH
29442: LD_INT 0
29444: PUSH
29445: EMPTY
29446: LIST
29447: LIST
29448: PUSH
29449: LD_INT 2
29451: PUSH
29452: LD_INT 1
29454: PUSH
29455: EMPTY
29456: LIST
29457: LIST
29458: PUSH
29459: LD_INT 2
29461: PUSH
29462: LD_INT 2
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PUSH
29469: LD_INT 1
29471: PUSH
29472: LD_INT 2
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 0
29481: PUSH
29482: LD_INT 2
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 1
29491: NEG
29492: PUSH
29493: LD_INT 1
29495: PUSH
29496: EMPTY
29497: LIST
29498: LIST
29499: PUSH
29500: LD_INT 2
29502: NEG
29503: PUSH
29504: LD_INT 0
29506: PUSH
29507: EMPTY
29508: LIST
29509: LIST
29510: PUSH
29511: LD_INT 2
29513: NEG
29514: PUSH
29515: LD_INT 1
29517: NEG
29518: PUSH
29519: EMPTY
29520: LIST
29521: LIST
29522: PUSH
29523: LD_INT 2
29525: NEG
29526: PUSH
29527: LD_INT 2
29529: NEG
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: PUSH
29535: EMPTY
29536: LIST
29537: LIST
29538: LIST
29539: LIST
29540: LIST
29541: LIST
29542: LIST
29543: LIST
29544: LIST
29545: LIST
29546: LIST
29547: LIST
29548: LIST
29549: LIST
29550: LIST
29551: LIST
29552: LIST
29553: LIST
29554: LIST
29555: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29556: LD_ADDR_VAR 0 21
29560: PUSH
29561: LD_INT 0
29563: PUSH
29564: LD_INT 0
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: PUSH
29571: LD_INT 0
29573: PUSH
29574: LD_INT 1
29576: NEG
29577: PUSH
29578: EMPTY
29579: LIST
29580: LIST
29581: PUSH
29582: LD_INT 1
29584: PUSH
29585: LD_INT 0
29587: PUSH
29588: EMPTY
29589: LIST
29590: LIST
29591: PUSH
29592: LD_INT 1
29594: PUSH
29595: LD_INT 1
29597: PUSH
29598: EMPTY
29599: LIST
29600: LIST
29601: PUSH
29602: LD_INT 0
29604: PUSH
29605: LD_INT 1
29607: PUSH
29608: EMPTY
29609: LIST
29610: LIST
29611: PUSH
29612: LD_INT 1
29614: NEG
29615: PUSH
29616: LD_INT 0
29618: PUSH
29619: EMPTY
29620: LIST
29621: LIST
29622: PUSH
29623: LD_INT 1
29625: NEG
29626: PUSH
29627: LD_INT 1
29629: NEG
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: PUSH
29635: LD_INT 1
29637: NEG
29638: PUSH
29639: LD_INT 2
29641: NEG
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 0
29649: PUSH
29650: LD_INT 2
29652: NEG
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PUSH
29658: LD_INT 1
29660: PUSH
29661: LD_INT 1
29663: NEG
29664: PUSH
29665: EMPTY
29666: LIST
29667: LIST
29668: PUSH
29669: LD_INT 2
29671: PUSH
29672: LD_INT 0
29674: PUSH
29675: EMPTY
29676: LIST
29677: LIST
29678: PUSH
29679: LD_INT 2
29681: PUSH
29682: LD_INT 1
29684: PUSH
29685: EMPTY
29686: LIST
29687: LIST
29688: PUSH
29689: LD_INT 2
29691: PUSH
29692: LD_INT 2
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 1
29701: PUSH
29702: LD_INT 2
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 0
29711: PUSH
29712: LD_INT 2
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 1
29721: NEG
29722: PUSH
29723: LD_INT 1
29725: PUSH
29726: EMPTY
29727: LIST
29728: LIST
29729: PUSH
29730: LD_INT 2
29732: NEG
29733: PUSH
29734: LD_INT 0
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PUSH
29741: LD_INT 2
29743: NEG
29744: PUSH
29745: LD_INT 1
29747: NEG
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: LD_INT 2
29755: NEG
29756: PUSH
29757: LD_INT 2
29759: NEG
29760: PUSH
29761: EMPTY
29762: LIST
29763: LIST
29764: PUSH
29765: EMPTY
29766: LIST
29767: LIST
29768: LIST
29769: LIST
29770: LIST
29771: LIST
29772: LIST
29773: LIST
29774: LIST
29775: LIST
29776: LIST
29777: LIST
29778: LIST
29779: LIST
29780: LIST
29781: LIST
29782: LIST
29783: LIST
29784: LIST
29785: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29786: LD_ADDR_VAR 0 22
29790: PUSH
29791: LD_INT 0
29793: PUSH
29794: LD_INT 0
29796: PUSH
29797: EMPTY
29798: LIST
29799: LIST
29800: PUSH
29801: LD_INT 0
29803: PUSH
29804: LD_INT 1
29806: NEG
29807: PUSH
29808: EMPTY
29809: LIST
29810: LIST
29811: PUSH
29812: LD_INT 1
29814: PUSH
29815: LD_INT 0
29817: PUSH
29818: EMPTY
29819: LIST
29820: LIST
29821: PUSH
29822: LD_INT 1
29824: PUSH
29825: LD_INT 1
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: PUSH
29832: LD_INT 0
29834: PUSH
29835: LD_INT 1
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PUSH
29842: LD_INT 1
29844: NEG
29845: PUSH
29846: LD_INT 0
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: LD_INT 1
29855: NEG
29856: PUSH
29857: LD_INT 1
29859: NEG
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: PUSH
29865: LD_INT 1
29867: NEG
29868: PUSH
29869: LD_INT 2
29871: NEG
29872: PUSH
29873: EMPTY
29874: LIST
29875: LIST
29876: PUSH
29877: LD_INT 0
29879: PUSH
29880: LD_INT 2
29882: NEG
29883: PUSH
29884: EMPTY
29885: LIST
29886: LIST
29887: PUSH
29888: LD_INT 1
29890: PUSH
29891: LD_INT 1
29893: NEG
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 2
29901: PUSH
29902: LD_INT 0
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: PUSH
29909: LD_INT 2
29911: PUSH
29912: LD_INT 1
29914: PUSH
29915: EMPTY
29916: LIST
29917: LIST
29918: PUSH
29919: LD_INT 2
29921: PUSH
29922: LD_INT 2
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 1
29931: PUSH
29932: LD_INT 2
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: LD_INT 0
29941: PUSH
29942: LD_INT 2
29944: PUSH
29945: EMPTY
29946: LIST
29947: LIST
29948: PUSH
29949: LD_INT 1
29951: NEG
29952: PUSH
29953: LD_INT 1
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PUSH
29960: LD_INT 2
29962: NEG
29963: PUSH
29964: LD_INT 0
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: PUSH
29971: LD_INT 2
29973: NEG
29974: PUSH
29975: LD_INT 1
29977: NEG
29978: PUSH
29979: EMPTY
29980: LIST
29981: LIST
29982: PUSH
29983: LD_INT 2
29985: NEG
29986: PUSH
29987: LD_INT 2
29989: NEG
29990: PUSH
29991: EMPTY
29992: LIST
29993: LIST
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: LIST
29999: LIST
30000: LIST
30001: LIST
30002: LIST
30003: LIST
30004: LIST
30005: LIST
30006: LIST
30007: LIST
30008: LIST
30009: LIST
30010: LIST
30011: LIST
30012: LIST
30013: LIST
30014: LIST
30015: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30016: LD_ADDR_VAR 0 23
30020: PUSH
30021: LD_INT 0
30023: PUSH
30024: LD_INT 0
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PUSH
30031: LD_INT 0
30033: PUSH
30034: LD_INT 1
30036: NEG
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 1
30044: PUSH
30045: LD_INT 0
30047: PUSH
30048: EMPTY
30049: LIST
30050: LIST
30051: PUSH
30052: LD_INT 1
30054: PUSH
30055: LD_INT 1
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 0
30064: PUSH
30065: LD_INT 1
30067: PUSH
30068: EMPTY
30069: LIST
30070: LIST
30071: PUSH
30072: LD_INT 1
30074: NEG
30075: PUSH
30076: LD_INT 0
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PUSH
30083: LD_INT 1
30085: NEG
30086: PUSH
30087: LD_INT 1
30089: NEG
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: LD_INT 1
30097: NEG
30098: PUSH
30099: LD_INT 2
30101: NEG
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 0
30109: PUSH
30110: LD_INT 2
30112: NEG
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PUSH
30118: LD_INT 1
30120: PUSH
30121: LD_INT 1
30123: NEG
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: PUSH
30129: LD_INT 2
30131: PUSH
30132: LD_INT 0
30134: PUSH
30135: EMPTY
30136: LIST
30137: LIST
30138: PUSH
30139: LD_INT 2
30141: PUSH
30142: LD_INT 1
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: LD_INT 2
30151: PUSH
30152: LD_INT 2
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: LD_INT 1
30161: PUSH
30162: LD_INT 2
30164: PUSH
30165: EMPTY
30166: LIST
30167: LIST
30168: PUSH
30169: LD_INT 0
30171: PUSH
30172: LD_INT 2
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: LD_INT 1
30181: NEG
30182: PUSH
30183: LD_INT 1
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 2
30192: NEG
30193: PUSH
30194: LD_INT 0
30196: PUSH
30197: EMPTY
30198: LIST
30199: LIST
30200: PUSH
30201: LD_INT 2
30203: NEG
30204: PUSH
30205: LD_INT 1
30207: NEG
30208: PUSH
30209: EMPTY
30210: LIST
30211: LIST
30212: PUSH
30213: LD_INT 2
30215: NEG
30216: PUSH
30217: LD_INT 2
30219: NEG
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 2
30227: NEG
30228: PUSH
30229: LD_INT 3
30231: NEG
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: PUSH
30237: LD_INT 1
30239: NEG
30240: PUSH
30241: LD_INT 3
30243: NEG
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: LD_INT 1
30251: PUSH
30252: LD_INT 2
30254: NEG
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 2
30262: PUSH
30263: LD_INT 1
30265: NEG
30266: PUSH
30267: EMPTY
30268: LIST
30269: LIST
30270: PUSH
30271: EMPTY
30272: LIST
30273: LIST
30274: LIST
30275: LIST
30276: LIST
30277: LIST
30278: LIST
30279: LIST
30280: LIST
30281: LIST
30282: LIST
30283: LIST
30284: LIST
30285: LIST
30286: LIST
30287: LIST
30288: LIST
30289: LIST
30290: LIST
30291: LIST
30292: LIST
30293: LIST
30294: LIST
30295: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30296: LD_ADDR_VAR 0 24
30300: PUSH
30301: LD_INT 0
30303: PUSH
30304: LD_INT 0
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 0
30313: PUSH
30314: LD_INT 1
30316: NEG
30317: PUSH
30318: EMPTY
30319: LIST
30320: LIST
30321: PUSH
30322: LD_INT 1
30324: PUSH
30325: LD_INT 0
30327: PUSH
30328: EMPTY
30329: LIST
30330: LIST
30331: PUSH
30332: LD_INT 1
30334: PUSH
30335: LD_INT 1
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 0
30344: PUSH
30345: LD_INT 1
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 1
30354: NEG
30355: PUSH
30356: LD_INT 0
30358: PUSH
30359: EMPTY
30360: LIST
30361: LIST
30362: PUSH
30363: LD_INT 1
30365: NEG
30366: PUSH
30367: LD_INT 1
30369: NEG
30370: PUSH
30371: EMPTY
30372: LIST
30373: LIST
30374: PUSH
30375: LD_INT 1
30377: NEG
30378: PUSH
30379: LD_INT 2
30381: NEG
30382: PUSH
30383: EMPTY
30384: LIST
30385: LIST
30386: PUSH
30387: LD_INT 0
30389: PUSH
30390: LD_INT 2
30392: NEG
30393: PUSH
30394: EMPTY
30395: LIST
30396: LIST
30397: PUSH
30398: LD_INT 1
30400: PUSH
30401: LD_INT 1
30403: NEG
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 2
30411: PUSH
30412: LD_INT 0
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 2
30421: PUSH
30422: LD_INT 1
30424: PUSH
30425: EMPTY
30426: LIST
30427: LIST
30428: PUSH
30429: LD_INT 2
30431: PUSH
30432: LD_INT 2
30434: PUSH
30435: EMPTY
30436: LIST
30437: LIST
30438: PUSH
30439: LD_INT 1
30441: PUSH
30442: LD_INT 2
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PUSH
30449: LD_INT 0
30451: PUSH
30452: LD_INT 2
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PUSH
30459: LD_INT 1
30461: NEG
30462: PUSH
30463: LD_INT 1
30465: PUSH
30466: EMPTY
30467: LIST
30468: LIST
30469: PUSH
30470: LD_INT 2
30472: NEG
30473: PUSH
30474: LD_INT 0
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: PUSH
30481: LD_INT 2
30483: NEG
30484: PUSH
30485: LD_INT 1
30487: NEG
30488: PUSH
30489: EMPTY
30490: LIST
30491: LIST
30492: PUSH
30493: LD_INT 2
30495: NEG
30496: PUSH
30497: LD_INT 2
30499: NEG
30500: PUSH
30501: EMPTY
30502: LIST
30503: LIST
30504: PUSH
30505: LD_INT 1
30507: PUSH
30508: LD_INT 2
30510: NEG
30511: PUSH
30512: EMPTY
30513: LIST
30514: LIST
30515: PUSH
30516: LD_INT 2
30518: PUSH
30519: LD_INT 1
30521: NEG
30522: PUSH
30523: EMPTY
30524: LIST
30525: LIST
30526: PUSH
30527: LD_INT 3
30529: PUSH
30530: LD_INT 1
30532: PUSH
30533: EMPTY
30534: LIST
30535: LIST
30536: PUSH
30537: LD_INT 3
30539: PUSH
30540: LD_INT 2
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: LIST
30551: LIST
30552: LIST
30553: LIST
30554: LIST
30555: LIST
30556: LIST
30557: LIST
30558: LIST
30559: LIST
30560: LIST
30561: LIST
30562: LIST
30563: LIST
30564: LIST
30565: LIST
30566: LIST
30567: LIST
30568: LIST
30569: LIST
30570: LIST
30571: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30572: LD_ADDR_VAR 0 25
30576: PUSH
30577: LD_INT 0
30579: PUSH
30580: LD_INT 0
30582: PUSH
30583: EMPTY
30584: LIST
30585: LIST
30586: PUSH
30587: LD_INT 0
30589: PUSH
30590: LD_INT 1
30592: NEG
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: PUSH
30598: LD_INT 1
30600: PUSH
30601: LD_INT 0
30603: PUSH
30604: EMPTY
30605: LIST
30606: LIST
30607: PUSH
30608: LD_INT 1
30610: PUSH
30611: LD_INT 1
30613: PUSH
30614: EMPTY
30615: LIST
30616: LIST
30617: PUSH
30618: LD_INT 0
30620: PUSH
30621: LD_INT 1
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: LD_INT 1
30630: NEG
30631: PUSH
30632: LD_INT 0
30634: PUSH
30635: EMPTY
30636: LIST
30637: LIST
30638: PUSH
30639: LD_INT 1
30641: NEG
30642: PUSH
30643: LD_INT 1
30645: NEG
30646: PUSH
30647: EMPTY
30648: LIST
30649: LIST
30650: PUSH
30651: LD_INT 1
30653: NEG
30654: PUSH
30655: LD_INT 2
30657: NEG
30658: PUSH
30659: EMPTY
30660: LIST
30661: LIST
30662: PUSH
30663: LD_INT 0
30665: PUSH
30666: LD_INT 2
30668: NEG
30669: PUSH
30670: EMPTY
30671: LIST
30672: LIST
30673: PUSH
30674: LD_INT 1
30676: PUSH
30677: LD_INT 1
30679: NEG
30680: PUSH
30681: EMPTY
30682: LIST
30683: LIST
30684: PUSH
30685: LD_INT 2
30687: PUSH
30688: LD_INT 0
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 2
30697: PUSH
30698: LD_INT 1
30700: PUSH
30701: EMPTY
30702: LIST
30703: LIST
30704: PUSH
30705: LD_INT 2
30707: PUSH
30708: LD_INT 2
30710: PUSH
30711: EMPTY
30712: LIST
30713: LIST
30714: PUSH
30715: LD_INT 1
30717: PUSH
30718: LD_INT 2
30720: PUSH
30721: EMPTY
30722: LIST
30723: LIST
30724: PUSH
30725: LD_INT 0
30727: PUSH
30728: LD_INT 2
30730: PUSH
30731: EMPTY
30732: LIST
30733: LIST
30734: PUSH
30735: LD_INT 1
30737: NEG
30738: PUSH
30739: LD_INT 1
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: PUSH
30746: LD_INT 2
30748: NEG
30749: PUSH
30750: LD_INT 0
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: PUSH
30757: LD_INT 2
30759: NEG
30760: PUSH
30761: LD_INT 1
30763: NEG
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PUSH
30769: LD_INT 2
30771: NEG
30772: PUSH
30773: LD_INT 2
30775: NEG
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PUSH
30781: LD_INT 3
30783: PUSH
30784: LD_INT 1
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 3
30793: PUSH
30794: LD_INT 2
30796: PUSH
30797: EMPTY
30798: LIST
30799: LIST
30800: PUSH
30801: LD_INT 2
30803: PUSH
30804: LD_INT 3
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: PUSH
30811: LD_INT 1
30813: PUSH
30814: LD_INT 3
30816: PUSH
30817: EMPTY
30818: LIST
30819: LIST
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: LIST
30825: LIST
30826: LIST
30827: LIST
30828: LIST
30829: LIST
30830: LIST
30831: LIST
30832: LIST
30833: LIST
30834: LIST
30835: LIST
30836: LIST
30837: LIST
30838: LIST
30839: LIST
30840: LIST
30841: LIST
30842: LIST
30843: LIST
30844: LIST
30845: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
30846: LD_ADDR_VAR 0 26
30850: PUSH
30851: LD_INT 0
30853: PUSH
30854: LD_INT 0
30856: PUSH
30857: EMPTY
30858: LIST
30859: LIST
30860: PUSH
30861: LD_INT 0
30863: PUSH
30864: LD_INT 1
30866: NEG
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: PUSH
30872: LD_INT 1
30874: PUSH
30875: LD_INT 0
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: PUSH
30882: LD_INT 1
30884: PUSH
30885: LD_INT 1
30887: PUSH
30888: EMPTY
30889: LIST
30890: LIST
30891: PUSH
30892: LD_INT 0
30894: PUSH
30895: LD_INT 1
30897: PUSH
30898: EMPTY
30899: LIST
30900: LIST
30901: PUSH
30902: LD_INT 1
30904: NEG
30905: PUSH
30906: LD_INT 0
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 1
30915: NEG
30916: PUSH
30917: LD_INT 1
30919: NEG
30920: PUSH
30921: EMPTY
30922: LIST
30923: LIST
30924: PUSH
30925: LD_INT 1
30927: NEG
30928: PUSH
30929: LD_INT 2
30931: NEG
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: PUSH
30937: LD_INT 0
30939: PUSH
30940: LD_INT 2
30942: NEG
30943: PUSH
30944: EMPTY
30945: LIST
30946: LIST
30947: PUSH
30948: LD_INT 1
30950: PUSH
30951: LD_INT 1
30953: NEG
30954: PUSH
30955: EMPTY
30956: LIST
30957: LIST
30958: PUSH
30959: LD_INT 2
30961: PUSH
30962: LD_INT 0
30964: PUSH
30965: EMPTY
30966: LIST
30967: LIST
30968: PUSH
30969: LD_INT 2
30971: PUSH
30972: LD_INT 1
30974: PUSH
30975: EMPTY
30976: LIST
30977: LIST
30978: PUSH
30979: LD_INT 2
30981: PUSH
30982: LD_INT 2
30984: PUSH
30985: EMPTY
30986: LIST
30987: LIST
30988: PUSH
30989: LD_INT 1
30991: PUSH
30992: LD_INT 2
30994: PUSH
30995: EMPTY
30996: LIST
30997: LIST
30998: PUSH
30999: LD_INT 0
31001: PUSH
31002: LD_INT 2
31004: PUSH
31005: EMPTY
31006: LIST
31007: LIST
31008: PUSH
31009: LD_INT 1
31011: NEG
31012: PUSH
31013: LD_INT 1
31015: PUSH
31016: EMPTY
31017: LIST
31018: LIST
31019: PUSH
31020: LD_INT 2
31022: NEG
31023: PUSH
31024: LD_INT 0
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 2
31033: NEG
31034: PUSH
31035: LD_INT 1
31037: NEG
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PUSH
31043: LD_INT 2
31045: NEG
31046: PUSH
31047: LD_INT 2
31049: NEG
31050: PUSH
31051: EMPTY
31052: LIST
31053: LIST
31054: PUSH
31055: LD_INT 2
31057: PUSH
31058: LD_INT 3
31060: PUSH
31061: EMPTY
31062: LIST
31063: LIST
31064: PUSH
31065: LD_INT 1
31067: PUSH
31068: LD_INT 3
31070: PUSH
31071: EMPTY
31072: LIST
31073: LIST
31074: PUSH
31075: LD_INT 1
31077: NEG
31078: PUSH
31079: LD_INT 2
31081: PUSH
31082: EMPTY
31083: LIST
31084: LIST
31085: PUSH
31086: LD_INT 2
31088: NEG
31089: PUSH
31090: LD_INT 1
31092: PUSH
31093: EMPTY
31094: LIST
31095: LIST
31096: PUSH
31097: EMPTY
31098: LIST
31099: LIST
31100: LIST
31101: LIST
31102: LIST
31103: LIST
31104: LIST
31105: LIST
31106: LIST
31107: LIST
31108: LIST
31109: LIST
31110: LIST
31111: LIST
31112: LIST
31113: LIST
31114: LIST
31115: LIST
31116: LIST
31117: LIST
31118: LIST
31119: LIST
31120: LIST
31121: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31122: LD_ADDR_VAR 0 27
31126: PUSH
31127: LD_INT 0
31129: PUSH
31130: LD_INT 0
31132: PUSH
31133: EMPTY
31134: LIST
31135: LIST
31136: PUSH
31137: LD_INT 0
31139: PUSH
31140: LD_INT 1
31142: NEG
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 1
31150: PUSH
31151: LD_INT 0
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PUSH
31158: LD_INT 1
31160: PUSH
31161: LD_INT 1
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: PUSH
31168: LD_INT 0
31170: PUSH
31171: LD_INT 1
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: LD_INT 1
31180: NEG
31181: PUSH
31182: LD_INT 0
31184: PUSH
31185: EMPTY
31186: LIST
31187: LIST
31188: PUSH
31189: LD_INT 1
31191: NEG
31192: PUSH
31193: LD_INT 1
31195: NEG
31196: PUSH
31197: EMPTY
31198: LIST
31199: LIST
31200: PUSH
31201: LD_INT 1
31203: NEG
31204: PUSH
31205: LD_INT 2
31207: NEG
31208: PUSH
31209: EMPTY
31210: LIST
31211: LIST
31212: PUSH
31213: LD_INT 0
31215: PUSH
31216: LD_INT 2
31218: NEG
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: PUSH
31224: LD_INT 1
31226: PUSH
31227: LD_INT 1
31229: NEG
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 2
31237: PUSH
31238: LD_INT 0
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: LD_INT 2
31247: PUSH
31248: LD_INT 1
31250: PUSH
31251: EMPTY
31252: LIST
31253: LIST
31254: PUSH
31255: LD_INT 2
31257: PUSH
31258: LD_INT 2
31260: PUSH
31261: EMPTY
31262: LIST
31263: LIST
31264: PUSH
31265: LD_INT 1
31267: PUSH
31268: LD_INT 2
31270: PUSH
31271: EMPTY
31272: LIST
31273: LIST
31274: PUSH
31275: LD_INT 0
31277: PUSH
31278: LD_INT 2
31280: PUSH
31281: EMPTY
31282: LIST
31283: LIST
31284: PUSH
31285: LD_INT 1
31287: NEG
31288: PUSH
31289: LD_INT 1
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 2
31298: NEG
31299: PUSH
31300: LD_INT 0
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: PUSH
31307: LD_INT 2
31309: NEG
31310: PUSH
31311: LD_INT 1
31313: NEG
31314: PUSH
31315: EMPTY
31316: LIST
31317: LIST
31318: PUSH
31319: LD_INT 2
31321: NEG
31322: PUSH
31323: LD_INT 2
31325: NEG
31326: PUSH
31327: EMPTY
31328: LIST
31329: LIST
31330: PUSH
31331: LD_INT 1
31333: NEG
31334: PUSH
31335: LD_INT 2
31337: PUSH
31338: EMPTY
31339: LIST
31340: LIST
31341: PUSH
31342: LD_INT 2
31344: NEG
31345: PUSH
31346: LD_INT 1
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 3
31355: NEG
31356: PUSH
31357: LD_INT 1
31359: NEG
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: LD_INT 3
31367: NEG
31368: PUSH
31369: LD_INT 2
31371: NEG
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: LIST
31386: LIST
31387: LIST
31388: LIST
31389: LIST
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: LIST
31396: LIST
31397: LIST
31398: LIST
31399: LIST
31400: LIST
31401: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31402: LD_ADDR_VAR 0 28
31406: PUSH
31407: LD_INT 0
31409: PUSH
31410: LD_INT 0
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: PUSH
31417: LD_INT 0
31419: PUSH
31420: LD_INT 1
31422: NEG
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: PUSH
31428: LD_INT 1
31430: PUSH
31431: LD_INT 0
31433: PUSH
31434: EMPTY
31435: LIST
31436: LIST
31437: PUSH
31438: LD_INT 1
31440: PUSH
31441: LD_INT 1
31443: PUSH
31444: EMPTY
31445: LIST
31446: LIST
31447: PUSH
31448: LD_INT 0
31450: PUSH
31451: LD_INT 1
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: PUSH
31458: LD_INT 1
31460: NEG
31461: PUSH
31462: LD_INT 0
31464: PUSH
31465: EMPTY
31466: LIST
31467: LIST
31468: PUSH
31469: LD_INT 1
31471: NEG
31472: PUSH
31473: LD_INT 1
31475: NEG
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: LD_INT 1
31483: NEG
31484: PUSH
31485: LD_INT 2
31487: NEG
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: LD_INT 0
31495: PUSH
31496: LD_INT 2
31498: NEG
31499: PUSH
31500: EMPTY
31501: LIST
31502: LIST
31503: PUSH
31504: LD_INT 1
31506: PUSH
31507: LD_INT 1
31509: NEG
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: PUSH
31515: LD_INT 2
31517: PUSH
31518: LD_INT 0
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 2
31527: PUSH
31528: LD_INT 1
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: PUSH
31535: LD_INT 2
31537: PUSH
31538: LD_INT 2
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 1
31547: PUSH
31548: LD_INT 2
31550: PUSH
31551: EMPTY
31552: LIST
31553: LIST
31554: PUSH
31555: LD_INT 0
31557: PUSH
31558: LD_INT 2
31560: PUSH
31561: EMPTY
31562: LIST
31563: LIST
31564: PUSH
31565: LD_INT 1
31567: NEG
31568: PUSH
31569: LD_INT 1
31571: PUSH
31572: EMPTY
31573: LIST
31574: LIST
31575: PUSH
31576: LD_INT 2
31578: NEG
31579: PUSH
31580: LD_INT 0
31582: PUSH
31583: EMPTY
31584: LIST
31585: LIST
31586: PUSH
31587: LD_INT 2
31589: NEG
31590: PUSH
31591: LD_INT 1
31593: NEG
31594: PUSH
31595: EMPTY
31596: LIST
31597: LIST
31598: PUSH
31599: LD_INT 2
31601: NEG
31602: PUSH
31603: LD_INT 2
31605: NEG
31606: PUSH
31607: EMPTY
31608: LIST
31609: LIST
31610: PUSH
31611: LD_INT 2
31613: NEG
31614: PUSH
31615: LD_INT 3
31617: NEG
31618: PUSH
31619: EMPTY
31620: LIST
31621: LIST
31622: PUSH
31623: LD_INT 1
31625: NEG
31626: PUSH
31627: LD_INT 3
31629: NEG
31630: PUSH
31631: EMPTY
31632: LIST
31633: LIST
31634: PUSH
31635: LD_INT 3
31637: NEG
31638: PUSH
31639: LD_INT 1
31641: NEG
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 3
31649: NEG
31650: PUSH
31651: LD_INT 2
31653: NEG
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: LIST
31667: LIST
31668: LIST
31669: LIST
31670: LIST
31671: LIST
31672: LIST
31673: LIST
31674: LIST
31675: LIST
31676: LIST
31677: LIST
31678: LIST
31679: LIST
31680: LIST
31681: LIST
31682: LIST
31683: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31684: LD_ADDR_VAR 0 29
31688: PUSH
31689: LD_INT 0
31691: PUSH
31692: LD_INT 0
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 0
31701: PUSH
31702: LD_INT 1
31704: NEG
31705: PUSH
31706: EMPTY
31707: LIST
31708: LIST
31709: PUSH
31710: LD_INT 1
31712: PUSH
31713: LD_INT 0
31715: PUSH
31716: EMPTY
31717: LIST
31718: LIST
31719: PUSH
31720: LD_INT 1
31722: PUSH
31723: LD_INT 1
31725: PUSH
31726: EMPTY
31727: LIST
31728: LIST
31729: PUSH
31730: LD_INT 0
31732: PUSH
31733: LD_INT 1
31735: PUSH
31736: EMPTY
31737: LIST
31738: LIST
31739: PUSH
31740: LD_INT 1
31742: NEG
31743: PUSH
31744: LD_INT 0
31746: PUSH
31747: EMPTY
31748: LIST
31749: LIST
31750: PUSH
31751: LD_INT 1
31753: NEG
31754: PUSH
31755: LD_INT 1
31757: NEG
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: PUSH
31763: LD_INT 1
31765: NEG
31766: PUSH
31767: LD_INT 2
31769: NEG
31770: PUSH
31771: EMPTY
31772: LIST
31773: LIST
31774: PUSH
31775: LD_INT 0
31777: PUSH
31778: LD_INT 2
31780: NEG
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PUSH
31786: LD_INT 1
31788: PUSH
31789: LD_INT 1
31791: NEG
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: LD_INT 2
31799: PUSH
31800: LD_INT 0
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 2
31809: PUSH
31810: LD_INT 1
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: LD_INT 1
31819: PUSH
31820: LD_INT 2
31822: PUSH
31823: EMPTY
31824: LIST
31825: LIST
31826: PUSH
31827: LD_INT 0
31829: PUSH
31830: LD_INT 2
31832: PUSH
31833: EMPTY
31834: LIST
31835: LIST
31836: PUSH
31837: LD_INT 1
31839: NEG
31840: PUSH
31841: LD_INT 1
31843: PUSH
31844: EMPTY
31845: LIST
31846: LIST
31847: PUSH
31848: LD_INT 2
31850: NEG
31851: PUSH
31852: LD_INT 1
31854: NEG
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: PUSH
31860: LD_INT 2
31862: NEG
31863: PUSH
31864: LD_INT 2
31866: NEG
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 2
31874: NEG
31875: PUSH
31876: LD_INT 3
31878: NEG
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PUSH
31884: LD_INT 2
31886: PUSH
31887: LD_INT 1
31889: NEG
31890: PUSH
31891: EMPTY
31892: LIST
31893: LIST
31894: PUSH
31895: LD_INT 3
31897: PUSH
31898: LD_INT 1
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 1
31907: PUSH
31908: LD_INT 3
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: LD_INT 1
31917: NEG
31918: PUSH
31919: LD_INT 2
31921: PUSH
31922: EMPTY
31923: LIST
31924: LIST
31925: PUSH
31926: LD_INT 3
31928: NEG
31929: PUSH
31930: LD_INT 2
31932: NEG
31933: PUSH
31934: EMPTY
31935: LIST
31936: LIST
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: LIST
31942: LIST
31943: LIST
31944: LIST
31945: LIST
31946: LIST
31947: LIST
31948: LIST
31949: LIST
31950: LIST
31951: LIST
31952: LIST
31953: LIST
31954: LIST
31955: LIST
31956: LIST
31957: LIST
31958: LIST
31959: LIST
31960: LIST
31961: LIST
31962: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31963: LD_ADDR_VAR 0 30
31967: PUSH
31968: LD_INT 0
31970: PUSH
31971: LD_INT 0
31973: PUSH
31974: EMPTY
31975: LIST
31976: LIST
31977: PUSH
31978: LD_INT 0
31980: PUSH
31981: LD_INT 1
31983: NEG
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 1
31991: PUSH
31992: LD_INT 0
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 1
32001: PUSH
32002: LD_INT 1
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 0
32011: PUSH
32012: LD_INT 1
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: LD_INT 1
32021: NEG
32022: PUSH
32023: LD_INT 0
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 1
32032: NEG
32033: PUSH
32034: LD_INT 1
32036: NEG
32037: PUSH
32038: EMPTY
32039: LIST
32040: LIST
32041: PUSH
32042: LD_INT 1
32044: NEG
32045: PUSH
32046: LD_INT 2
32048: NEG
32049: PUSH
32050: EMPTY
32051: LIST
32052: LIST
32053: PUSH
32054: LD_INT 0
32056: PUSH
32057: LD_INT 2
32059: NEG
32060: PUSH
32061: EMPTY
32062: LIST
32063: LIST
32064: PUSH
32065: LD_INT 1
32067: PUSH
32068: LD_INT 1
32070: NEG
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 2
32078: PUSH
32079: LD_INT 0
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 2
32088: PUSH
32089: LD_INT 1
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 2
32098: PUSH
32099: LD_INT 2
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 1
32108: PUSH
32109: LD_INT 2
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PUSH
32116: LD_INT 1
32118: NEG
32119: PUSH
32120: LD_INT 1
32122: PUSH
32123: EMPTY
32124: LIST
32125: LIST
32126: PUSH
32127: LD_INT 2
32129: NEG
32130: PUSH
32131: LD_INT 0
32133: PUSH
32134: EMPTY
32135: LIST
32136: LIST
32137: PUSH
32138: LD_INT 2
32140: NEG
32141: PUSH
32142: LD_INT 1
32144: NEG
32145: PUSH
32146: EMPTY
32147: LIST
32148: LIST
32149: PUSH
32150: LD_INT 1
32152: NEG
32153: PUSH
32154: LD_INT 3
32156: NEG
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PUSH
32162: LD_INT 1
32164: PUSH
32165: LD_INT 2
32167: NEG
32168: PUSH
32169: EMPTY
32170: LIST
32171: LIST
32172: PUSH
32173: LD_INT 3
32175: PUSH
32176: LD_INT 2
32178: PUSH
32179: EMPTY
32180: LIST
32181: LIST
32182: PUSH
32183: LD_INT 2
32185: PUSH
32186: LD_INT 3
32188: PUSH
32189: EMPTY
32190: LIST
32191: LIST
32192: PUSH
32193: LD_INT 2
32195: NEG
32196: PUSH
32197: LD_INT 1
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: LD_INT 3
32206: NEG
32207: PUSH
32208: LD_INT 1
32210: NEG
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: PUSH
32216: EMPTY
32217: LIST
32218: LIST
32219: LIST
32220: LIST
32221: LIST
32222: LIST
32223: LIST
32224: LIST
32225: LIST
32226: LIST
32227: LIST
32228: LIST
32229: LIST
32230: LIST
32231: LIST
32232: LIST
32233: LIST
32234: LIST
32235: LIST
32236: LIST
32237: LIST
32238: LIST
32239: LIST
32240: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32241: LD_ADDR_VAR 0 31
32245: PUSH
32246: LD_INT 0
32248: PUSH
32249: LD_INT 0
32251: PUSH
32252: EMPTY
32253: LIST
32254: LIST
32255: PUSH
32256: LD_INT 0
32258: PUSH
32259: LD_INT 1
32261: NEG
32262: PUSH
32263: EMPTY
32264: LIST
32265: LIST
32266: PUSH
32267: LD_INT 1
32269: PUSH
32270: LD_INT 0
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 1
32279: PUSH
32280: LD_INT 1
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 0
32289: PUSH
32290: LD_INT 1
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: NEG
32300: PUSH
32301: LD_INT 0
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 1
32310: NEG
32311: PUSH
32312: LD_INT 1
32314: NEG
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 1
32322: NEG
32323: PUSH
32324: LD_INT 2
32326: NEG
32327: PUSH
32328: EMPTY
32329: LIST
32330: LIST
32331: PUSH
32332: LD_INT 1
32334: PUSH
32335: LD_INT 1
32337: NEG
32338: PUSH
32339: EMPTY
32340: LIST
32341: LIST
32342: PUSH
32343: LD_INT 2
32345: PUSH
32346: LD_INT 0
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 2
32355: PUSH
32356: LD_INT 1
32358: PUSH
32359: EMPTY
32360: LIST
32361: LIST
32362: PUSH
32363: LD_INT 2
32365: PUSH
32366: LD_INT 2
32368: PUSH
32369: EMPTY
32370: LIST
32371: LIST
32372: PUSH
32373: LD_INT 1
32375: PUSH
32376: LD_INT 2
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: LD_INT 0
32385: PUSH
32386: LD_INT 2
32388: PUSH
32389: EMPTY
32390: LIST
32391: LIST
32392: PUSH
32393: LD_INT 1
32395: NEG
32396: PUSH
32397: LD_INT 1
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 2
32406: NEG
32407: PUSH
32408: LD_INT 1
32410: NEG
32411: PUSH
32412: EMPTY
32413: LIST
32414: LIST
32415: PUSH
32416: LD_INT 2
32418: NEG
32419: PUSH
32420: LD_INT 2
32422: NEG
32423: PUSH
32424: EMPTY
32425: LIST
32426: LIST
32427: PUSH
32428: LD_INT 2
32430: NEG
32431: PUSH
32432: LD_INT 3
32434: NEG
32435: PUSH
32436: EMPTY
32437: LIST
32438: LIST
32439: PUSH
32440: LD_INT 2
32442: PUSH
32443: LD_INT 1
32445: NEG
32446: PUSH
32447: EMPTY
32448: LIST
32449: LIST
32450: PUSH
32451: LD_INT 3
32453: PUSH
32454: LD_INT 1
32456: PUSH
32457: EMPTY
32458: LIST
32459: LIST
32460: PUSH
32461: LD_INT 1
32463: PUSH
32464: LD_INT 3
32466: PUSH
32467: EMPTY
32468: LIST
32469: LIST
32470: PUSH
32471: LD_INT 1
32473: NEG
32474: PUSH
32475: LD_INT 2
32477: PUSH
32478: EMPTY
32479: LIST
32480: LIST
32481: PUSH
32482: LD_INT 3
32484: NEG
32485: PUSH
32486: LD_INT 2
32488: NEG
32489: PUSH
32490: EMPTY
32491: LIST
32492: LIST
32493: PUSH
32494: EMPTY
32495: LIST
32496: LIST
32497: LIST
32498: LIST
32499: LIST
32500: LIST
32501: LIST
32502: LIST
32503: LIST
32504: LIST
32505: LIST
32506: LIST
32507: LIST
32508: LIST
32509: LIST
32510: LIST
32511: LIST
32512: LIST
32513: LIST
32514: LIST
32515: LIST
32516: LIST
32517: LIST
32518: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32519: LD_ADDR_VAR 0 32
32523: PUSH
32524: LD_INT 0
32526: PUSH
32527: LD_INT 0
32529: PUSH
32530: EMPTY
32531: LIST
32532: LIST
32533: PUSH
32534: LD_INT 0
32536: PUSH
32537: LD_INT 1
32539: NEG
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: PUSH
32545: LD_INT 1
32547: PUSH
32548: LD_INT 0
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 1
32557: PUSH
32558: LD_INT 1
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 0
32567: PUSH
32568: LD_INT 1
32570: PUSH
32571: EMPTY
32572: LIST
32573: LIST
32574: PUSH
32575: LD_INT 1
32577: NEG
32578: PUSH
32579: LD_INT 0
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 1
32588: NEG
32589: PUSH
32590: LD_INT 1
32592: NEG
32593: PUSH
32594: EMPTY
32595: LIST
32596: LIST
32597: PUSH
32598: LD_INT 1
32600: NEG
32601: PUSH
32602: LD_INT 2
32604: NEG
32605: PUSH
32606: EMPTY
32607: LIST
32608: LIST
32609: PUSH
32610: LD_INT 0
32612: PUSH
32613: LD_INT 2
32615: NEG
32616: PUSH
32617: EMPTY
32618: LIST
32619: LIST
32620: PUSH
32621: LD_INT 1
32623: PUSH
32624: LD_INT 1
32626: NEG
32627: PUSH
32628: EMPTY
32629: LIST
32630: LIST
32631: PUSH
32632: LD_INT 2
32634: PUSH
32635: LD_INT 1
32637: PUSH
32638: EMPTY
32639: LIST
32640: LIST
32641: PUSH
32642: LD_INT 2
32644: PUSH
32645: LD_INT 2
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: PUSH
32652: LD_INT 1
32654: PUSH
32655: LD_INT 2
32657: PUSH
32658: EMPTY
32659: LIST
32660: LIST
32661: PUSH
32662: LD_INT 0
32664: PUSH
32665: LD_INT 2
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 1
32674: NEG
32675: PUSH
32676: LD_INT 1
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PUSH
32683: LD_INT 2
32685: NEG
32686: PUSH
32687: LD_INT 0
32689: PUSH
32690: EMPTY
32691: LIST
32692: LIST
32693: PUSH
32694: LD_INT 2
32696: NEG
32697: PUSH
32698: LD_INT 1
32700: NEG
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PUSH
32706: LD_INT 1
32708: NEG
32709: PUSH
32710: LD_INT 3
32712: NEG
32713: PUSH
32714: EMPTY
32715: LIST
32716: LIST
32717: PUSH
32718: LD_INT 1
32720: PUSH
32721: LD_INT 2
32723: NEG
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: LD_INT 3
32731: PUSH
32732: LD_INT 2
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PUSH
32739: LD_INT 2
32741: PUSH
32742: LD_INT 3
32744: PUSH
32745: EMPTY
32746: LIST
32747: LIST
32748: PUSH
32749: LD_INT 2
32751: NEG
32752: PUSH
32753: LD_INT 1
32755: PUSH
32756: EMPTY
32757: LIST
32758: LIST
32759: PUSH
32760: LD_INT 3
32762: NEG
32763: PUSH
32764: LD_INT 1
32766: NEG
32767: PUSH
32768: EMPTY
32769: LIST
32770: LIST
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: LIST
32776: LIST
32777: LIST
32778: LIST
32779: LIST
32780: LIST
32781: LIST
32782: LIST
32783: LIST
32784: LIST
32785: LIST
32786: LIST
32787: LIST
32788: LIST
32789: LIST
32790: LIST
32791: LIST
32792: LIST
32793: LIST
32794: LIST
32795: LIST
32796: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32797: LD_ADDR_VAR 0 33
32801: PUSH
32802: LD_INT 0
32804: PUSH
32805: LD_INT 0
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: LD_INT 0
32814: PUSH
32815: LD_INT 1
32817: NEG
32818: PUSH
32819: EMPTY
32820: LIST
32821: LIST
32822: PUSH
32823: LD_INT 1
32825: PUSH
32826: LD_INT 0
32828: PUSH
32829: EMPTY
32830: LIST
32831: LIST
32832: PUSH
32833: LD_INT 1
32835: PUSH
32836: LD_INT 1
32838: PUSH
32839: EMPTY
32840: LIST
32841: LIST
32842: PUSH
32843: LD_INT 0
32845: PUSH
32846: LD_INT 1
32848: PUSH
32849: EMPTY
32850: LIST
32851: LIST
32852: PUSH
32853: LD_INT 1
32855: NEG
32856: PUSH
32857: LD_INT 0
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 1
32866: NEG
32867: PUSH
32868: LD_INT 1
32870: NEG
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 1
32878: NEG
32879: PUSH
32880: LD_INT 2
32882: NEG
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PUSH
32888: LD_INT 1
32890: PUSH
32891: LD_INT 1
32893: NEG
32894: PUSH
32895: EMPTY
32896: LIST
32897: LIST
32898: PUSH
32899: LD_INT 2
32901: PUSH
32902: LD_INT 0
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 2
32911: PUSH
32912: LD_INT 1
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: LD_INT 1
32921: PUSH
32922: LD_INT 2
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: LD_INT 0
32931: PUSH
32932: LD_INT 2
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 1
32941: NEG
32942: PUSH
32943: LD_INT 1
32945: PUSH
32946: EMPTY
32947: LIST
32948: LIST
32949: PUSH
32950: LD_INT 2
32952: NEG
32953: PUSH
32954: LD_INT 0
32956: PUSH
32957: EMPTY
32958: LIST
32959: LIST
32960: PUSH
32961: LD_INT 2
32963: NEG
32964: PUSH
32965: LD_INT 1
32967: NEG
32968: PUSH
32969: EMPTY
32970: LIST
32971: LIST
32972: PUSH
32973: LD_INT 2
32975: NEG
32976: PUSH
32977: LD_INT 2
32979: NEG
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: PUSH
32985: LD_INT 2
32987: NEG
32988: PUSH
32989: LD_INT 3
32991: NEG
32992: PUSH
32993: EMPTY
32994: LIST
32995: LIST
32996: PUSH
32997: LD_INT 2
32999: PUSH
33000: LD_INT 1
33002: NEG
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 3
33010: PUSH
33011: LD_INT 1
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 1
33020: PUSH
33021: LD_INT 3
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 1
33030: NEG
33031: PUSH
33032: LD_INT 2
33034: PUSH
33035: EMPTY
33036: LIST
33037: LIST
33038: PUSH
33039: LD_INT 3
33041: NEG
33042: PUSH
33043: LD_INT 2
33045: NEG
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: LIST
33055: LIST
33056: LIST
33057: LIST
33058: LIST
33059: LIST
33060: LIST
33061: LIST
33062: LIST
33063: LIST
33064: LIST
33065: LIST
33066: LIST
33067: LIST
33068: LIST
33069: LIST
33070: LIST
33071: LIST
33072: LIST
33073: LIST
33074: LIST
33075: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33076: LD_ADDR_VAR 0 34
33080: PUSH
33081: LD_INT 0
33083: PUSH
33084: LD_INT 0
33086: PUSH
33087: EMPTY
33088: LIST
33089: LIST
33090: PUSH
33091: LD_INT 0
33093: PUSH
33094: LD_INT 1
33096: NEG
33097: PUSH
33098: EMPTY
33099: LIST
33100: LIST
33101: PUSH
33102: LD_INT 1
33104: PUSH
33105: LD_INT 0
33107: PUSH
33108: EMPTY
33109: LIST
33110: LIST
33111: PUSH
33112: LD_INT 1
33114: PUSH
33115: LD_INT 1
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: PUSH
33122: LD_INT 0
33124: PUSH
33125: LD_INT 1
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 1
33134: NEG
33135: PUSH
33136: LD_INT 0
33138: PUSH
33139: EMPTY
33140: LIST
33141: LIST
33142: PUSH
33143: LD_INT 1
33145: NEG
33146: PUSH
33147: LD_INT 1
33149: NEG
33150: PUSH
33151: EMPTY
33152: LIST
33153: LIST
33154: PUSH
33155: LD_INT 1
33157: NEG
33158: PUSH
33159: LD_INT 2
33161: NEG
33162: PUSH
33163: EMPTY
33164: LIST
33165: LIST
33166: PUSH
33167: LD_INT 0
33169: PUSH
33170: LD_INT 2
33172: NEG
33173: PUSH
33174: EMPTY
33175: LIST
33176: LIST
33177: PUSH
33178: LD_INT 1
33180: PUSH
33181: LD_INT 1
33183: NEG
33184: PUSH
33185: EMPTY
33186: LIST
33187: LIST
33188: PUSH
33189: LD_INT 2
33191: PUSH
33192: LD_INT 1
33194: PUSH
33195: EMPTY
33196: LIST
33197: LIST
33198: PUSH
33199: LD_INT 2
33201: PUSH
33202: LD_INT 2
33204: PUSH
33205: EMPTY
33206: LIST
33207: LIST
33208: PUSH
33209: LD_INT 1
33211: PUSH
33212: LD_INT 2
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 1
33221: NEG
33222: PUSH
33223: LD_INT 1
33225: PUSH
33226: EMPTY
33227: LIST
33228: LIST
33229: PUSH
33230: LD_INT 2
33232: NEG
33233: PUSH
33234: LD_INT 0
33236: PUSH
33237: EMPTY
33238: LIST
33239: LIST
33240: PUSH
33241: LD_INT 2
33243: NEG
33244: PUSH
33245: LD_INT 1
33247: NEG
33248: PUSH
33249: EMPTY
33250: LIST
33251: LIST
33252: PUSH
33253: LD_INT 2
33255: NEG
33256: PUSH
33257: LD_INT 2
33259: NEG
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 1
33267: NEG
33268: PUSH
33269: LD_INT 3
33271: NEG
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 1
33279: PUSH
33280: LD_INT 2
33282: NEG
33283: PUSH
33284: EMPTY
33285: LIST
33286: LIST
33287: PUSH
33288: LD_INT 3
33290: PUSH
33291: LD_INT 2
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: PUSH
33298: LD_INT 2
33300: PUSH
33301: LD_INT 3
33303: PUSH
33304: EMPTY
33305: LIST
33306: LIST
33307: PUSH
33308: LD_INT 2
33310: NEG
33311: PUSH
33312: LD_INT 1
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 3
33321: NEG
33322: PUSH
33323: LD_INT 1
33325: NEG
33326: PUSH
33327: EMPTY
33328: LIST
33329: LIST
33330: PUSH
33331: EMPTY
33332: LIST
33333: LIST
33334: LIST
33335: LIST
33336: LIST
33337: LIST
33338: LIST
33339: LIST
33340: LIST
33341: LIST
33342: LIST
33343: LIST
33344: LIST
33345: LIST
33346: LIST
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33356: LD_ADDR_VAR 0 35
33360: PUSH
33361: LD_INT 0
33363: PUSH
33364: LD_INT 0
33366: PUSH
33367: EMPTY
33368: LIST
33369: LIST
33370: PUSH
33371: LD_INT 0
33373: PUSH
33374: LD_INT 1
33376: NEG
33377: PUSH
33378: EMPTY
33379: LIST
33380: LIST
33381: PUSH
33382: LD_INT 1
33384: PUSH
33385: LD_INT 0
33387: PUSH
33388: EMPTY
33389: LIST
33390: LIST
33391: PUSH
33392: LD_INT 1
33394: PUSH
33395: LD_INT 1
33397: PUSH
33398: EMPTY
33399: LIST
33400: LIST
33401: PUSH
33402: LD_INT 0
33404: PUSH
33405: LD_INT 1
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: PUSH
33412: LD_INT 1
33414: NEG
33415: PUSH
33416: LD_INT 0
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PUSH
33423: LD_INT 1
33425: NEG
33426: PUSH
33427: LD_INT 1
33429: NEG
33430: PUSH
33431: EMPTY
33432: LIST
33433: LIST
33434: PUSH
33435: LD_INT 2
33437: PUSH
33438: LD_INT 1
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: LD_INT 2
33447: NEG
33448: PUSH
33449: LD_INT 1
33451: NEG
33452: PUSH
33453: EMPTY
33454: LIST
33455: LIST
33456: PUSH
33457: EMPTY
33458: LIST
33459: LIST
33460: LIST
33461: LIST
33462: LIST
33463: LIST
33464: LIST
33465: LIST
33466: LIST
33467: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33468: LD_ADDR_VAR 0 36
33472: PUSH
33473: LD_INT 0
33475: PUSH
33476: LD_INT 0
33478: PUSH
33479: EMPTY
33480: LIST
33481: LIST
33482: PUSH
33483: LD_INT 0
33485: PUSH
33486: LD_INT 1
33488: NEG
33489: PUSH
33490: EMPTY
33491: LIST
33492: LIST
33493: PUSH
33494: LD_INT 1
33496: PUSH
33497: LD_INT 0
33499: PUSH
33500: EMPTY
33501: LIST
33502: LIST
33503: PUSH
33504: LD_INT 1
33506: PUSH
33507: LD_INT 1
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 0
33516: PUSH
33517: LD_INT 1
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 1
33526: NEG
33527: PUSH
33528: LD_INT 0
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: PUSH
33535: LD_INT 1
33537: NEG
33538: PUSH
33539: LD_INT 1
33541: NEG
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: NEG
33550: PUSH
33551: LD_INT 2
33553: NEG
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 1
33561: PUSH
33562: LD_INT 2
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: LIST
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33580: LD_ADDR_VAR 0 37
33584: PUSH
33585: LD_INT 0
33587: PUSH
33588: LD_INT 0
33590: PUSH
33591: EMPTY
33592: LIST
33593: LIST
33594: PUSH
33595: LD_INT 0
33597: PUSH
33598: LD_INT 1
33600: NEG
33601: PUSH
33602: EMPTY
33603: LIST
33604: LIST
33605: PUSH
33606: LD_INT 1
33608: PUSH
33609: LD_INT 0
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: LD_INT 1
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PUSH
33626: LD_INT 0
33628: PUSH
33629: LD_INT 1
33631: PUSH
33632: EMPTY
33633: LIST
33634: LIST
33635: PUSH
33636: LD_INT 1
33638: NEG
33639: PUSH
33640: LD_INT 0
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 1
33649: NEG
33650: PUSH
33651: LD_INT 1
33653: NEG
33654: PUSH
33655: EMPTY
33656: LIST
33657: LIST
33658: PUSH
33659: LD_INT 1
33661: PUSH
33662: LD_INT 1
33664: NEG
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: LD_INT 1
33672: NEG
33673: PUSH
33674: LD_INT 1
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: EMPTY
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33692: LD_ADDR_VAR 0 38
33696: PUSH
33697: LD_INT 0
33699: PUSH
33700: LD_INT 0
33702: PUSH
33703: EMPTY
33704: LIST
33705: LIST
33706: PUSH
33707: LD_INT 0
33709: PUSH
33710: LD_INT 1
33712: NEG
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 1
33720: PUSH
33721: LD_INT 0
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 1
33730: PUSH
33731: LD_INT 1
33733: PUSH
33734: EMPTY
33735: LIST
33736: LIST
33737: PUSH
33738: LD_INT 0
33740: PUSH
33741: LD_INT 1
33743: PUSH
33744: EMPTY
33745: LIST
33746: LIST
33747: PUSH
33748: LD_INT 1
33750: NEG
33751: PUSH
33752: LD_INT 0
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PUSH
33759: LD_INT 1
33761: NEG
33762: PUSH
33763: LD_INT 1
33765: NEG
33766: PUSH
33767: EMPTY
33768: LIST
33769: LIST
33770: PUSH
33771: LD_INT 2
33773: PUSH
33774: LD_INT 1
33776: PUSH
33777: EMPTY
33778: LIST
33779: LIST
33780: PUSH
33781: LD_INT 2
33783: NEG
33784: PUSH
33785: LD_INT 1
33787: NEG
33788: PUSH
33789: EMPTY
33790: LIST
33791: LIST
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: LIST
33797: LIST
33798: LIST
33799: LIST
33800: LIST
33801: LIST
33802: LIST
33803: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33804: LD_ADDR_VAR 0 39
33808: PUSH
33809: LD_INT 0
33811: PUSH
33812: LD_INT 0
33814: PUSH
33815: EMPTY
33816: LIST
33817: LIST
33818: PUSH
33819: LD_INT 0
33821: PUSH
33822: LD_INT 1
33824: NEG
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 1
33832: PUSH
33833: LD_INT 0
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 1
33842: PUSH
33843: LD_INT 1
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 0
33852: PUSH
33853: LD_INT 1
33855: PUSH
33856: EMPTY
33857: LIST
33858: LIST
33859: PUSH
33860: LD_INT 1
33862: NEG
33863: PUSH
33864: LD_INT 0
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 1
33873: NEG
33874: PUSH
33875: LD_INT 1
33877: NEG
33878: PUSH
33879: EMPTY
33880: LIST
33881: LIST
33882: PUSH
33883: LD_INT 1
33885: NEG
33886: PUSH
33887: LD_INT 2
33889: NEG
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 1
33897: PUSH
33898: LD_INT 2
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: LIST
33909: LIST
33910: LIST
33911: LIST
33912: LIST
33913: LIST
33914: LIST
33915: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33916: LD_ADDR_VAR 0 40
33920: PUSH
33921: LD_INT 0
33923: PUSH
33924: LD_INT 0
33926: PUSH
33927: EMPTY
33928: LIST
33929: LIST
33930: PUSH
33931: LD_INT 0
33933: PUSH
33934: LD_INT 1
33936: NEG
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 1
33944: PUSH
33945: LD_INT 0
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: LD_INT 1
33954: PUSH
33955: LD_INT 1
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 0
33964: PUSH
33965: LD_INT 1
33967: PUSH
33968: EMPTY
33969: LIST
33970: LIST
33971: PUSH
33972: LD_INT 1
33974: NEG
33975: PUSH
33976: LD_INT 0
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 1
33985: NEG
33986: PUSH
33987: LD_INT 1
33989: NEG
33990: PUSH
33991: EMPTY
33992: LIST
33993: LIST
33994: PUSH
33995: LD_INT 1
33997: PUSH
33998: LD_INT 1
34000: NEG
34001: PUSH
34002: EMPTY
34003: LIST
34004: LIST
34005: PUSH
34006: LD_INT 1
34008: NEG
34009: PUSH
34010: LD_INT 1
34012: PUSH
34013: EMPTY
34014: LIST
34015: LIST
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: LIST
34021: LIST
34022: LIST
34023: LIST
34024: LIST
34025: LIST
34026: LIST
34027: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34028: LD_ADDR_VAR 0 41
34032: PUSH
34033: LD_INT 0
34035: PUSH
34036: LD_INT 0
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 0
34045: PUSH
34046: LD_INT 1
34048: NEG
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 1
34056: PUSH
34057: LD_INT 0
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 1
34066: PUSH
34067: LD_INT 1
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 0
34076: PUSH
34077: LD_INT 1
34079: PUSH
34080: EMPTY
34081: LIST
34082: LIST
34083: PUSH
34084: LD_INT 1
34086: NEG
34087: PUSH
34088: LD_INT 0
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 1
34097: NEG
34098: PUSH
34099: LD_INT 1
34101: NEG
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 1
34109: NEG
34110: PUSH
34111: LD_INT 2
34113: NEG
34114: PUSH
34115: EMPTY
34116: LIST
34117: LIST
34118: PUSH
34119: LD_INT 1
34121: PUSH
34122: LD_INT 1
34124: NEG
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 2
34132: PUSH
34133: LD_INT 0
34135: PUSH
34136: EMPTY
34137: LIST
34138: LIST
34139: PUSH
34140: LD_INT 2
34142: PUSH
34143: LD_INT 1
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: LD_INT 2
34152: PUSH
34153: LD_INT 2
34155: PUSH
34156: EMPTY
34157: LIST
34158: LIST
34159: PUSH
34160: LD_INT 1
34162: PUSH
34163: LD_INT 2
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 1
34172: NEG
34173: PUSH
34174: LD_INT 1
34176: PUSH
34177: EMPTY
34178: LIST
34179: LIST
34180: PUSH
34181: LD_INT 2
34183: NEG
34184: PUSH
34185: LD_INT 0
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: PUSH
34192: LD_INT 2
34194: NEG
34195: PUSH
34196: LD_INT 1
34198: NEG
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 2
34206: NEG
34207: PUSH
34208: LD_INT 2
34210: NEG
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PUSH
34216: LD_INT 2
34218: NEG
34219: PUSH
34220: LD_INT 3
34222: NEG
34223: PUSH
34224: EMPTY
34225: LIST
34226: LIST
34227: PUSH
34228: LD_INT 2
34230: PUSH
34231: LD_INT 1
34233: NEG
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: LD_INT 3
34241: PUSH
34242: LD_INT 0
34244: PUSH
34245: EMPTY
34246: LIST
34247: LIST
34248: PUSH
34249: LD_INT 3
34251: PUSH
34252: LD_INT 1
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 3
34261: PUSH
34262: LD_INT 2
34264: PUSH
34265: EMPTY
34266: LIST
34267: LIST
34268: PUSH
34269: LD_INT 3
34271: PUSH
34272: LD_INT 3
34274: PUSH
34275: EMPTY
34276: LIST
34277: LIST
34278: PUSH
34279: LD_INT 2
34281: PUSH
34282: LD_INT 3
34284: PUSH
34285: EMPTY
34286: LIST
34287: LIST
34288: PUSH
34289: LD_INT 2
34291: NEG
34292: PUSH
34293: LD_INT 1
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 3
34302: NEG
34303: PUSH
34304: LD_INT 0
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 3
34313: NEG
34314: PUSH
34315: LD_INT 1
34317: NEG
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 3
34325: NEG
34326: PUSH
34327: LD_INT 2
34329: NEG
34330: PUSH
34331: EMPTY
34332: LIST
34333: LIST
34334: PUSH
34335: LD_INT 3
34337: NEG
34338: PUSH
34339: LD_INT 3
34341: NEG
34342: PUSH
34343: EMPTY
34344: LIST
34345: LIST
34346: PUSH
34347: EMPTY
34348: LIST
34349: LIST
34350: LIST
34351: LIST
34352: LIST
34353: LIST
34354: LIST
34355: LIST
34356: LIST
34357: LIST
34358: LIST
34359: LIST
34360: LIST
34361: LIST
34362: LIST
34363: LIST
34364: LIST
34365: LIST
34366: LIST
34367: LIST
34368: LIST
34369: LIST
34370: LIST
34371: LIST
34372: LIST
34373: LIST
34374: LIST
34375: LIST
34376: LIST
34377: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34378: LD_ADDR_VAR 0 42
34382: PUSH
34383: LD_INT 0
34385: PUSH
34386: LD_INT 0
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: PUSH
34393: LD_INT 0
34395: PUSH
34396: LD_INT 1
34398: NEG
34399: PUSH
34400: EMPTY
34401: LIST
34402: LIST
34403: PUSH
34404: LD_INT 1
34406: PUSH
34407: LD_INT 0
34409: PUSH
34410: EMPTY
34411: LIST
34412: LIST
34413: PUSH
34414: LD_INT 1
34416: PUSH
34417: LD_INT 1
34419: PUSH
34420: EMPTY
34421: LIST
34422: LIST
34423: PUSH
34424: LD_INT 0
34426: PUSH
34427: LD_INT 1
34429: PUSH
34430: EMPTY
34431: LIST
34432: LIST
34433: PUSH
34434: LD_INT 1
34436: NEG
34437: PUSH
34438: LD_INT 0
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: PUSH
34445: LD_INT 1
34447: NEG
34448: PUSH
34449: LD_INT 1
34451: NEG
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: PUSH
34457: LD_INT 1
34459: NEG
34460: PUSH
34461: LD_INT 2
34463: NEG
34464: PUSH
34465: EMPTY
34466: LIST
34467: LIST
34468: PUSH
34469: LD_INT 0
34471: PUSH
34472: LD_INT 2
34474: NEG
34475: PUSH
34476: EMPTY
34477: LIST
34478: LIST
34479: PUSH
34480: LD_INT 1
34482: PUSH
34483: LD_INT 1
34485: NEG
34486: PUSH
34487: EMPTY
34488: LIST
34489: LIST
34490: PUSH
34491: LD_INT 2
34493: PUSH
34494: LD_INT 1
34496: PUSH
34497: EMPTY
34498: LIST
34499: LIST
34500: PUSH
34501: LD_INT 2
34503: PUSH
34504: LD_INT 2
34506: PUSH
34507: EMPTY
34508: LIST
34509: LIST
34510: PUSH
34511: LD_INT 1
34513: PUSH
34514: LD_INT 2
34516: PUSH
34517: EMPTY
34518: LIST
34519: LIST
34520: PUSH
34521: LD_INT 0
34523: PUSH
34524: LD_INT 2
34526: PUSH
34527: EMPTY
34528: LIST
34529: LIST
34530: PUSH
34531: LD_INT 1
34533: NEG
34534: PUSH
34535: LD_INT 1
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 2
34544: NEG
34545: PUSH
34546: LD_INT 1
34548: NEG
34549: PUSH
34550: EMPTY
34551: LIST
34552: LIST
34553: PUSH
34554: LD_INT 2
34556: NEG
34557: PUSH
34558: LD_INT 2
34560: NEG
34561: PUSH
34562: EMPTY
34563: LIST
34564: LIST
34565: PUSH
34566: LD_INT 2
34568: NEG
34569: PUSH
34570: LD_INT 3
34572: NEG
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PUSH
34578: LD_INT 1
34580: NEG
34581: PUSH
34582: LD_INT 3
34584: NEG
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 0
34592: PUSH
34593: LD_INT 3
34595: NEG
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 1
34603: PUSH
34604: LD_INT 2
34606: NEG
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 3
34614: PUSH
34615: LD_INT 2
34617: PUSH
34618: EMPTY
34619: LIST
34620: LIST
34621: PUSH
34622: LD_INT 3
34624: PUSH
34625: LD_INT 3
34627: PUSH
34628: EMPTY
34629: LIST
34630: LIST
34631: PUSH
34632: LD_INT 2
34634: PUSH
34635: LD_INT 3
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 1
34644: PUSH
34645: LD_INT 3
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 0
34654: PUSH
34655: LD_INT 3
34657: PUSH
34658: EMPTY
34659: LIST
34660: LIST
34661: PUSH
34662: LD_INT 1
34664: NEG
34665: PUSH
34666: LD_INT 2
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: LD_INT 3
34675: NEG
34676: PUSH
34677: LD_INT 2
34679: NEG
34680: PUSH
34681: EMPTY
34682: LIST
34683: LIST
34684: PUSH
34685: LD_INT 3
34687: NEG
34688: PUSH
34689: LD_INT 3
34691: NEG
34692: PUSH
34693: EMPTY
34694: LIST
34695: LIST
34696: PUSH
34697: EMPTY
34698: LIST
34699: LIST
34700: LIST
34701: LIST
34702: LIST
34703: LIST
34704: LIST
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34728: LD_ADDR_VAR 0 43
34732: PUSH
34733: LD_INT 0
34735: PUSH
34736: LD_INT 0
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: LD_INT 1
34748: NEG
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 1
34756: PUSH
34757: LD_INT 0
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 1
34766: PUSH
34767: LD_INT 1
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: LD_INT 0
34776: PUSH
34777: LD_INT 1
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 1
34786: NEG
34787: PUSH
34788: LD_INT 0
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 1
34797: NEG
34798: PUSH
34799: LD_INT 1
34801: NEG
34802: PUSH
34803: EMPTY
34804: LIST
34805: LIST
34806: PUSH
34807: LD_INT 1
34809: NEG
34810: PUSH
34811: LD_INT 2
34813: NEG
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PUSH
34819: LD_INT 0
34821: PUSH
34822: LD_INT 2
34824: NEG
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: LD_INT 1
34832: PUSH
34833: LD_INT 1
34835: NEG
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 2
34843: PUSH
34844: LD_INT 0
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 2
34853: PUSH
34854: LD_INT 1
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: PUSH
34861: LD_INT 1
34863: PUSH
34864: LD_INT 2
34866: PUSH
34867: EMPTY
34868: LIST
34869: LIST
34870: PUSH
34871: LD_INT 0
34873: PUSH
34874: LD_INT 2
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: LD_INT 1
34883: NEG
34884: PUSH
34885: LD_INT 1
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: LD_INT 2
34894: NEG
34895: PUSH
34896: LD_INT 0
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: PUSH
34903: LD_INT 2
34905: NEG
34906: PUSH
34907: LD_INT 1
34909: NEG
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 1
34917: NEG
34918: PUSH
34919: LD_INT 3
34921: NEG
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 0
34929: PUSH
34930: LD_INT 3
34932: NEG
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: LD_INT 1
34940: PUSH
34941: LD_INT 2
34943: NEG
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 2
34951: PUSH
34952: LD_INT 1
34954: NEG
34955: PUSH
34956: EMPTY
34957: LIST
34958: LIST
34959: PUSH
34960: LD_INT 3
34962: PUSH
34963: LD_INT 0
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 3
34972: PUSH
34973: LD_INT 1
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: LD_INT 1
34982: PUSH
34983: LD_INT 3
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: PUSH
34990: LD_INT 0
34992: PUSH
34993: LD_INT 3
34995: PUSH
34996: EMPTY
34997: LIST
34998: LIST
34999: PUSH
35000: LD_INT 1
35002: NEG
35003: PUSH
35004: LD_INT 2
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 2
35013: NEG
35014: PUSH
35015: LD_INT 1
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: LD_INT 3
35024: NEG
35025: PUSH
35026: LD_INT 0
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 3
35035: NEG
35036: PUSH
35037: LD_INT 1
35039: NEG
35040: PUSH
35041: EMPTY
35042: LIST
35043: LIST
35044: PUSH
35045: EMPTY
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: LIST
35052: LIST
35053: LIST
35054: LIST
35055: LIST
35056: LIST
35057: LIST
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: LIST
35063: LIST
35064: LIST
35065: LIST
35066: LIST
35067: LIST
35068: LIST
35069: LIST
35070: LIST
35071: LIST
35072: LIST
35073: LIST
35074: LIST
35075: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35076: LD_ADDR_VAR 0 44
35080: PUSH
35081: LD_INT 0
35083: PUSH
35084: LD_INT 0
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: LD_INT 0
35093: PUSH
35094: LD_INT 1
35096: NEG
35097: PUSH
35098: EMPTY
35099: LIST
35100: LIST
35101: PUSH
35102: LD_INT 1
35104: PUSH
35105: LD_INT 0
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: LD_INT 1
35114: PUSH
35115: LD_INT 1
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 0
35124: PUSH
35125: LD_INT 1
35127: PUSH
35128: EMPTY
35129: LIST
35130: LIST
35131: PUSH
35132: LD_INT 1
35134: NEG
35135: PUSH
35136: LD_INT 0
35138: PUSH
35139: EMPTY
35140: LIST
35141: LIST
35142: PUSH
35143: LD_INT 1
35145: NEG
35146: PUSH
35147: LD_INT 1
35149: NEG
35150: PUSH
35151: EMPTY
35152: LIST
35153: LIST
35154: PUSH
35155: LD_INT 1
35157: NEG
35158: PUSH
35159: LD_INT 2
35161: NEG
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PUSH
35167: LD_INT 1
35169: PUSH
35170: LD_INT 1
35172: NEG
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 2
35180: PUSH
35181: LD_INT 0
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 2
35190: PUSH
35191: LD_INT 1
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 2
35200: PUSH
35201: LD_INT 2
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 1
35210: PUSH
35211: LD_INT 2
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 1
35220: NEG
35221: PUSH
35222: LD_INT 1
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 2
35231: NEG
35232: PUSH
35233: LD_INT 0
35235: PUSH
35236: EMPTY
35237: LIST
35238: LIST
35239: PUSH
35240: LD_INT 2
35242: NEG
35243: PUSH
35244: LD_INT 1
35246: NEG
35247: PUSH
35248: EMPTY
35249: LIST
35250: LIST
35251: PUSH
35252: LD_INT 2
35254: NEG
35255: PUSH
35256: LD_INT 2
35258: NEG
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 2
35266: NEG
35267: PUSH
35268: LD_INT 3
35270: NEG
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: LD_INT 2
35278: PUSH
35279: LD_INT 1
35281: NEG
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: LD_INT 3
35289: PUSH
35290: LD_INT 0
35292: PUSH
35293: EMPTY
35294: LIST
35295: LIST
35296: PUSH
35297: LD_INT 3
35299: PUSH
35300: LD_INT 1
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PUSH
35307: LD_INT 3
35309: PUSH
35310: LD_INT 2
35312: PUSH
35313: EMPTY
35314: LIST
35315: LIST
35316: PUSH
35317: LD_INT 3
35319: PUSH
35320: LD_INT 3
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 2
35329: PUSH
35330: LD_INT 3
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 2
35339: NEG
35340: PUSH
35341: LD_INT 1
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: PUSH
35348: LD_INT 3
35350: NEG
35351: PUSH
35352: LD_INT 0
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: LD_INT 3
35361: NEG
35362: PUSH
35363: LD_INT 1
35365: NEG
35366: PUSH
35367: EMPTY
35368: LIST
35369: LIST
35370: PUSH
35371: LD_INT 3
35373: NEG
35374: PUSH
35375: LD_INT 2
35377: NEG
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 3
35385: NEG
35386: PUSH
35387: LD_INT 3
35389: NEG
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: LIST
35399: LIST
35400: LIST
35401: LIST
35402: LIST
35403: LIST
35404: LIST
35405: LIST
35406: LIST
35407: LIST
35408: LIST
35409: LIST
35410: LIST
35411: LIST
35412: LIST
35413: LIST
35414: LIST
35415: LIST
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35426: LD_ADDR_VAR 0 45
35430: PUSH
35431: LD_INT 0
35433: PUSH
35434: LD_INT 0
35436: PUSH
35437: EMPTY
35438: LIST
35439: LIST
35440: PUSH
35441: LD_INT 0
35443: PUSH
35444: LD_INT 1
35446: NEG
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: LD_INT 1
35454: PUSH
35455: LD_INT 0
35457: PUSH
35458: EMPTY
35459: LIST
35460: LIST
35461: PUSH
35462: LD_INT 1
35464: PUSH
35465: LD_INT 1
35467: PUSH
35468: EMPTY
35469: LIST
35470: LIST
35471: PUSH
35472: LD_INT 0
35474: PUSH
35475: LD_INT 1
35477: PUSH
35478: EMPTY
35479: LIST
35480: LIST
35481: PUSH
35482: LD_INT 1
35484: NEG
35485: PUSH
35486: LD_INT 0
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: LD_INT 1
35495: NEG
35496: PUSH
35497: LD_INT 1
35499: NEG
35500: PUSH
35501: EMPTY
35502: LIST
35503: LIST
35504: PUSH
35505: LD_INT 1
35507: NEG
35508: PUSH
35509: LD_INT 2
35511: NEG
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 0
35519: PUSH
35520: LD_INT 2
35522: NEG
35523: PUSH
35524: EMPTY
35525: LIST
35526: LIST
35527: PUSH
35528: LD_INT 1
35530: PUSH
35531: LD_INT 1
35533: NEG
35534: PUSH
35535: EMPTY
35536: LIST
35537: LIST
35538: PUSH
35539: LD_INT 2
35541: PUSH
35542: LD_INT 1
35544: PUSH
35545: EMPTY
35546: LIST
35547: LIST
35548: PUSH
35549: LD_INT 2
35551: PUSH
35552: LD_INT 2
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 1
35561: PUSH
35562: LD_INT 2
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: LD_INT 0
35571: PUSH
35572: LD_INT 2
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PUSH
35579: LD_INT 1
35581: NEG
35582: PUSH
35583: LD_INT 1
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 2
35592: NEG
35593: PUSH
35594: LD_INT 1
35596: NEG
35597: PUSH
35598: EMPTY
35599: LIST
35600: LIST
35601: PUSH
35602: LD_INT 2
35604: NEG
35605: PUSH
35606: LD_INT 2
35608: NEG
35609: PUSH
35610: EMPTY
35611: LIST
35612: LIST
35613: PUSH
35614: LD_INT 2
35616: NEG
35617: PUSH
35618: LD_INT 3
35620: NEG
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 1
35628: NEG
35629: PUSH
35630: LD_INT 3
35632: NEG
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 0
35640: PUSH
35641: LD_INT 3
35643: NEG
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 1
35651: PUSH
35652: LD_INT 2
35654: NEG
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 3
35662: PUSH
35663: LD_INT 2
35665: PUSH
35666: EMPTY
35667: LIST
35668: LIST
35669: PUSH
35670: LD_INT 3
35672: PUSH
35673: LD_INT 3
35675: PUSH
35676: EMPTY
35677: LIST
35678: LIST
35679: PUSH
35680: LD_INT 2
35682: PUSH
35683: LD_INT 3
35685: PUSH
35686: EMPTY
35687: LIST
35688: LIST
35689: PUSH
35690: LD_INT 1
35692: PUSH
35693: LD_INT 3
35695: PUSH
35696: EMPTY
35697: LIST
35698: LIST
35699: PUSH
35700: LD_INT 0
35702: PUSH
35703: LD_INT 3
35705: PUSH
35706: EMPTY
35707: LIST
35708: LIST
35709: PUSH
35710: LD_INT 1
35712: NEG
35713: PUSH
35714: LD_INT 2
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: PUSH
35721: LD_INT 3
35723: NEG
35724: PUSH
35725: LD_INT 2
35727: NEG
35728: PUSH
35729: EMPTY
35730: LIST
35731: LIST
35732: PUSH
35733: LD_INT 3
35735: NEG
35736: PUSH
35737: LD_INT 3
35739: NEG
35740: PUSH
35741: EMPTY
35742: LIST
35743: LIST
35744: PUSH
35745: EMPTY
35746: LIST
35747: LIST
35748: LIST
35749: LIST
35750: LIST
35751: LIST
35752: LIST
35753: LIST
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: LIST
35761: LIST
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: LIST
35768: LIST
35769: LIST
35770: LIST
35771: LIST
35772: LIST
35773: LIST
35774: LIST
35775: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35776: LD_ADDR_VAR 0 46
35780: PUSH
35781: LD_INT 0
35783: PUSH
35784: LD_INT 0
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 0
35793: PUSH
35794: LD_INT 1
35796: NEG
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: LD_INT 1
35804: PUSH
35805: LD_INT 0
35807: PUSH
35808: EMPTY
35809: LIST
35810: LIST
35811: PUSH
35812: LD_INT 1
35814: PUSH
35815: LD_INT 1
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: PUSH
35822: LD_INT 0
35824: PUSH
35825: LD_INT 1
35827: PUSH
35828: EMPTY
35829: LIST
35830: LIST
35831: PUSH
35832: LD_INT 1
35834: NEG
35835: PUSH
35836: LD_INT 0
35838: PUSH
35839: EMPTY
35840: LIST
35841: LIST
35842: PUSH
35843: LD_INT 1
35845: NEG
35846: PUSH
35847: LD_INT 1
35849: NEG
35850: PUSH
35851: EMPTY
35852: LIST
35853: LIST
35854: PUSH
35855: LD_INT 1
35857: NEG
35858: PUSH
35859: LD_INT 2
35861: NEG
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: LD_INT 0
35869: PUSH
35870: LD_INT 2
35872: NEG
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: PUSH
35878: LD_INT 1
35880: PUSH
35881: LD_INT 1
35883: NEG
35884: PUSH
35885: EMPTY
35886: LIST
35887: LIST
35888: PUSH
35889: LD_INT 2
35891: PUSH
35892: LD_INT 0
35894: PUSH
35895: EMPTY
35896: LIST
35897: LIST
35898: PUSH
35899: LD_INT 2
35901: PUSH
35902: LD_INT 1
35904: PUSH
35905: EMPTY
35906: LIST
35907: LIST
35908: PUSH
35909: LD_INT 1
35911: PUSH
35912: LD_INT 2
35914: PUSH
35915: EMPTY
35916: LIST
35917: LIST
35918: PUSH
35919: LD_INT 0
35921: PUSH
35922: LD_INT 2
35924: PUSH
35925: EMPTY
35926: LIST
35927: LIST
35928: PUSH
35929: LD_INT 1
35931: NEG
35932: PUSH
35933: LD_INT 1
35935: PUSH
35936: EMPTY
35937: LIST
35938: LIST
35939: PUSH
35940: LD_INT 2
35942: NEG
35943: PUSH
35944: LD_INT 0
35946: PUSH
35947: EMPTY
35948: LIST
35949: LIST
35950: PUSH
35951: LD_INT 2
35953: NEG
35954: PUSH
35955: LD_INT 1
35957: NEG
35958: PUSH
35959: EMPTY
35960: LIST
35961: LIST
35962: PUSH
35963: LD_INT 1
35965: NEG
35966: PUSH
35967: LD_INT 3
35969: NEG
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: PUSH
35975: LD_INT 0
35977: PUSH
35978: LD_INT 3
35980: NEG
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 1
35988: PUSH
35989: LD_INT 2
35991: NEG
35992: PUSH
35993: EMPTY
35994: LIST
35995: LIST
35996: PUSH
35997: LD_INT 2
35999: PUSH
36000: LD_INT 1
36002: NEG
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 3
36010: PUSH
36011: LD_INT 0
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: PUSH
36018: LD_INT 3
36020: PUSH
36021: LD_INT 1
36023: PUSH
36024: EMPTY
36025: LIST
36026: LIST
36027: PUSH
36028: LD_INT 1
36030: PUSH
36031: LD_INT 3
36033: PUSH
36034: EMPTY
36035: LIST
36036: LIST
36037: PUSH
36038: LD_INT 0
36040: PUSH
36041: LD_INT 3
36043: PUSH
36044: EMPTY
36045: LIST
36046: LIST
36047: PUSH
36048: LD_INT 1
36050: NEG
36051: PUSH
36052: LD_INT 2
36054: PUSH
36055: EMPTY
36056: LIST
36057: LIST
36058: PUSH
36059: LD_INT 2
36061: NEG
36062: PUSH
36063: LD_INT 1
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: LD_INT 3
36072: NEG
36073: PUSH
36074: LD_INT 0
36076: PUSH
36077: EMPTY
36078: LIST
36079: LIST
36080: PUSH
36081: LD_INT 3
36083: NEG
36084: PUSH
36085: LD_INT 1
36087: NEG
36088: PUSH
36089: EMPTY
36090: LIST
36091: LIST
36092: PUSH
36093: EMPTY
36094: LIST
36095: LIST
36096: LIST
36097: LIST
36098: LIST
36099: LIST
36100: LIST
36101: LIST
36102: LIST
36103: LIST
36104: LIST
36105: LIST
36106: LIST
36107: LIST
36108: LIST
36109: LIST
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36124: LD_ADDR_VAR 0 47
36128: PUSH
36129: LD_INT 0
36131: PUSH
36132: LD_INT 0
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 0
36141: PUSH
36142: LD_INT 1
36144: NEG
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: PUSH
36150: LD_INT 1
36152: PUSH
36153: LD_INT 0
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 1
36162: PUSH
36163: LD_INT 1
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 0
36172: PUSH
36173: LD_INT 1
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 1
36182: NEG
36183: PUSH
36184: LD_INT 0
36186: PUSH
36187: EMPTY
36188: LIST
36189: LIST
36190: PUSH
36191: LD_INT 1
36193: NEG
36194: PUSH
36195: LD_INT 1
36197: NEG
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 1
36205: NEG
36206: PUSH
36207: LD_INT 2
36209: NEG
36210: PUSH
36211: EMPTY
36212: LIST
36213: LIST
36214: PUSH
36215: LD_INT 0
36217: PUSH
36218: LD_INT 2
36220: NEG
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 1
36228: PUSH
36229: LD_INT 1
36231: NEG
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 2
36239: NEG
36240: PUSH
36241: LD_INT 1
36243: NEG
36244: PUSH
36245: EMPTY
36246: LIST
36247: LIST
36248: PUSH
36249: LD_INT 2
36251: NEG
36252: PUSH
36253: LD_INT 2
36255: NEG
36256: PUSH
36257: EMPTY
36258: LIST
36259: LIST
36260: PUSH
36261: EMPTY
36262: LIST
36263: LIST
36264: LIST
36265: LIST
36266: LIST
36267: LIST
36268: LIST
36269: LIST
36270: LIST
36271: LIST
36272: LIST
36273: LIST
36274: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36275: LD_ADDR_VAR 0 48
36279: PUSH
36280: LD_INT 0
36282: PUSH
36283: LD_INT 0
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 0
36292: PUSH
36293: LD_INT 1
36295: NEG
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 1
36303: PUSH
36304: LD_INT 0
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 1
36313: PUSH
36314: LD_INT 1
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 0
36323: PUSH
36324: LD_INT 1
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 1
36333: NEG
36334: PUSH
36335: LD_INT 0
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 1
36344: NEG
36345: PUSH
36346: LD_INT 1
36348: NEG
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 1
36356: NEG
36357: PUSH
36358: LD_INT 2
36360: NEG
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: PUSH
36366: LD_INT 0
36368: PUSH
36369: LD_INT 2
36371: NEG
36372: PUSH
36373: EMPTY
36374: LIST
36375: LIST
36376: PUSH
36377: LD_INT 1
36379: PUSH
36380: LD_INT 1
36382: NEG
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 2
36390: PUSH
36391: LD_INT 0
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 2
36400: PUSH
36401: LD_INT 1
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: LIST
36412: LIST
36413: LIST
36414: LIST
36415: LIST
36416: LIST
36417: LIST
36418: LIST
36419: LIST
36420: LIST
36421: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36422: LD_ADDR_VAR 0 49
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: LD_INT 0
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PUSH
36437: LD_INT 0
36439: PUSH
36440: LD_INT 1
36442: NEG
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: LD_INT 1
36450: PUSH
36451: LD_INT 0
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 1
36460: PUSH
36461: LD_INT 1
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 0
36470: PUSH
36471: LD_INT 1
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 1
36480: NEG
36481: PUSH
36482: LD_INT 0
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 1
36491: NEG
36492: PUSH
36493: LD_INT 1
36495: NEG
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PUSH
36501: LD_INT 1
36503: PUSH
36504: LD_INT 1
36506: NEG
36507: PUSH
36508: EMPTY
36509: LIST
36510: LIST
36511: PUSH
36512: LD_INT 2
36514: PUSH
36515: LD_INT 0
36517: PUSH
36518: EMPTY
36519: LIST
36520: LIST
36521: PUSH
36522: LD_INT 2
36524: PUSH
36525: LD_INT 1
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 2
36534: PUSH
36535: LD_INT 2
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 1
36544: PUSH
36545: LD_INT 2
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: EMPTY
36553: LIST
36554: LIST
36555: LIST
36556: LIST
36557: LIST
36558: LIST
36559: LIST
36560: LIST
36561: LIST
36562: LIST
36563: LIST
36564: LIST
36565: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36566: LD_ADDR_VAR 0 50
36570: PUSH
36571: LD_INT 0
36573: PUSH
36574: LD_INT 0
36576: PUSH
36577: EMPTY
36578: LIST
36579: LIST
36580: PUSH
36581: LD_INT 0
36583: PUSH
36584: LD_INT 1
36586: NEG
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 1
36594: PUSH
36595: LD_INT 0
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 1
36604: PUSH
36605: LD_INT 1
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 0
36614: PUSH
36615: LD_INT 1
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: PUSH
36622: LD_INT 1
36624: NEG
36625: PUSH
36626: LD_INT 0
36628: PUSH
36629: EMPTY
36630: LIST
36631: LIST
36632: PUSH
36633: LD_INT 1
36635: NEG
36636: PUSH
36637: LD_INT 1
36639: NEG
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 2
36647: PUSH
36648: LD_INT 1
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 2
36657: PUSH
36658: LD_INT 2
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 1
36667: PUSH
36668: LD_INT 2
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: LD_INT 0
36677: PUSH
36678: LD_INT 2
36680: PUSH
36681: EMPTY
36682: LIST
36683: LIST
36684: PUSH
36685: LD_INT 1
36687: NEG
36688: PUSH
36689: LD_INT 1
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: EMPTY
36697: LIST
36698: LIST
36699: LIST
36700: LIST
36701: LIST
36702: LIST
36703: LIST
36704: LIST
36705: LIST
36706: LIST
36707: LIST
36708: LIST
36709: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
36710: LD_ADDR_VAR 0 51
36714: PUSH
36715: LD_INT 0
36717: PUSH
36718: LD_INT 0
36720: PUSH
36721: EMPTY
36722: LIST
36723: LIST
36724: PUSH
36725: LD_INT 0
36727: PUSH
36728: LD_INT 1
36730: NEG
36731: PUSH
36732: EMPTY
36733: LIST
36734: LIST
36735: PUSH
36736: LD_INT 1
36738: PUSH
36739: LD_INT 0
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: PUSH
36746: LD_INT 1
36748: PUSH
36749: LD_INT 1
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 0
36758: PUSH
36759: LD_INT 1
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: LD_INT 1
36768: NEG
36769: PUSH
36770: LD_INT 0
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: PUSH
36777: LD_INT 1
36779: NEG
36780: PUSH
36781: LD_INT 1
36783: NEG
36784: PUSH
36785: EMPTY
36786: LIST
36787: LIST
36788: PUSH
36789: LD_INT 1
36791: PUSH
36792: LD_INT 2
36794: PUSH
36795: EMPTY
36796: LIST
36797: LIST
36798: PUSH
36799: LD_INT 0
36801: PUSH
36802: LD_INT 2
36804: PUSH
36805: EMPTY
36806: LIST
36807: LIST
36808: PUSH
36809: LD_INT 1
36811: NEG
36812: PUSH
36813: LD_INT 1
36815: PUSH
36816: EMPTY
36817: LIST
36818: LIST
36819: PUSH
36820: LD_INT 2
36822: NEG
36823: PUSH
36824: LD_INT 0
36826: PUSH
36827: EMPTY
36828: LIST
36829: LIST
36830: PUSH
36831: LD_INT 2
36833: NEG
36834: PUSH
36835: LD_INT 1
36837: NEG
36838: PUSH
36839: EMPTY
36840: LIST
36841: LIST
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: LIST
36849: LIST
36850: LIST
36851: LIST
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36857: LD_ADDR_VAR 0 52
36861: PUSH
36862: LD_INT 0
36864: PUSH
36865: LD_INT 0
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 0
36874: PUSH
36875: LD_INT 1
36877: NEG
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 1
36885: PUSH
36886: LD_INT 0
36888: PUSH
36889: EMPTY
36890: LIST
36891: LIST
36892: PUSH
36893: LD_INT 1
36895: PUSH
36896: LD_INT 1
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: LD_INT 0
36905: PUSH
36906: LD_INT 1
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 1
36915: NEG
36916: PUSH
36917: LD_INT 0
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 1
36926: NEG
36927: PUSH
36928: LD_INT 1
36930: NEG
36931: PUSH
36932: EMPTY
36933: LIST
36934: LIST
36935: PUSH
36936: LD_INT 1
36938: NEG
36939: PUSH
36940: LD_INT 2
36942: NEG
36943: PUSH
36944: EMPTY
36945: LIST
36946: LIST
36947: PUSH
36948: LD_INT 1
36950: NEG
36951: PUSH
36952: LD_INT 1
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: LD_INT 2
36961: NEG
36962: PUSH
36963: LD_INT 0
36965: PUSH
36966: EMPTY
36967: LIST
36968: LIST
36969: PUSH
36970: LD_INT 2
36972: NEG
36973: PUSH
36974: LD_INT 1
36976: NEG
36977: PUSH
36978: EMPTY
36979: LIST
36980: LIST
36981: PUSH
36982: LD_INT 2
36984: NEG
36985: PUSH
36986: LD_INT 2
36988: NEG
36989: PUSH
36990: EMPTY
36991: LIST
36992: LIST
36993: PUSH
36994: EMPTY
36995: LIST
36996: LIST
36997: LIST
36998: LIST
36999: LIST
37000: LIST
37001: LIST
37002: LIST
37003: LIST
37004: LIST
37005: LIST
37006: LIST
37007: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37008: LD_ADDR_VAR 0 53
37012: PUSH
37013: LD_INT 0
37015: PUSH
37016: LD_INT 0
37018: PUSH
37019: EMPTY
37020: LIST
37021: LIST
37022: PUSH
37023: LD_INT 0
37025: PUSH
37026: LD_INT 1
37028: NEG
37029: PUSH
37030: EMPTY
37031: LIST
37032: LIST
37033: PUSH
37034: LD_INT 1
37036: PUSH
37037: LD_INT 0
37039: PUSH
37040: EMPTY
37041: LIST
37042: LIST
37043: PUSH
37044: LD_INT 1
37046: PUSH
37047: LD_INT 1
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: PUSH
37054: LD_INT 0
37056: PUSH
37057: LD_INT 1
37059: PUSH
37060: EMPTY
37061: LIST
37062: LIST
37063: PUSH
37064: LD_INT 1
37066: NEG
37067: PUSH
37068: LD_INT 0
37070: PUSH
37071: EMPTY
37072: LIST
37073: LIST
37074: PUSH
37075: LD_INT 1
37077: NEG
37078: PUSH
37079: LD_INT 1
37081: NEG
37082: PUSH
37083: EMPTY
37084: LIST
37085: LIST
37086: PUSH
37087: LD_INT 1
37089: NEG
37090: PUSH
37091: LD_INT 2
37093: NEG
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PUSH
37099: LD_INT 0
37101: PUSH
37102: LD_INT 2
37104: NEG
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 1
37112: PUSH
37113: LD_INT 1
37115: NEG
37116: PUSH
37117: EMPTY
37118: LIST
37119: LIST
37120: PUSH
37121: LD_INT 2
37123: PUSH
37124: LD_INT 0
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 2
37133: PUSH
37134: LD_INT 1
37136: PUSH
37137: EMPTY
37138: LIST
37139: LIST
37140: PUSH
37141: LD_INT 2
37143: PUSH
37144: LD_INT 2
37146: PUSH
37147: EMPTY
37148: LIST
37149: LIST
37150: PUSH
37151: LD_INT 1
37153: PUSH
37154: LD_INT 2
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 0
37163: PUSH
37164: LD_INT 2
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 1
37173: NEG
37174: PUSH
37175: LD_INT 1
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 2
37184: NEG
37185: PUSH
37186: LD_INT 0
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 2
37195: NEG
37196: PUSH
37197: LD_INT 1
37199: NEG
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 2
37207: NEG
37208: PUSH
37209: LD_INT 2
37211: NEG
37212: PUSH
37213: EMPTY
37214: LIST
37215: LIST
37216: PUSH
37217: EMPTY
37218: LIST
37219: LIST
37220: LIST
37221: LIST
37222: LIST
37223: LIST
37224: LIST
37225: LIST
37226: LIST
37227: LIST
37228: LIST
37229: LIST
37230: LIST
37231: LIST
37232: LIST
37233: LIST
37234: LIST
37235: LIST
37236: LIST
37237: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37238: LD_ADDR_VAR 0 54
37242: PUSH
37243: LD_INT 0
37245: PUSH
37246: LD_INT 0
37248: PUSH
37249: EMPTY
37250: LIST
37251: LIST
37252: PUSH
37253: LD_INT 0
37255: PUSH
37256: LD_INT 1
37258: NEG
37259: PUSH
37260: EMPTY
37261: LIST
37262: LIST
37263: PUSH
37264: LD_INT 1
37266: PUSH
37267: LD_INT 0
37269: PUSH
37270: EMPTY
37271: LIST
37272: LIST
37273: PUSH
37274: LD_INT 1
37276: PUSH
37277: LD_INT 1
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: PUSH
37284: LD_INT 0
37286: PUSH
37287: LD_INT 1
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: PUSH
37294: LD_INT 1
37296: NEG
37297: PUSH
37298: LD_INT 0
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: PUSH
37305: LD_INT 1
37307: NEG
37308: PUSH
37309: LD_INT 1
37311: NEG
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: LD_INT 1
37319: NEG
37320: PUSH
37321: LD_INT 2
37323: NEG
37324: PUSH
37325: EMPTY
37326: LIST
37327: LIST
37328: PUSH
37329: LD_INT 0
37331: PUSH
37332: LD_INT 2
37334: NEG
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: LD_INT 1
37342: PUSH
37343: LD_INT 1
37345: NEG
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: LD_INT 2
37353: PUSH
37354: LD_INT 0
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: LD_INT 2
37363: PUSH
37364: LD_INT 1
37366: PUSH
37367: EMPTY
37368: LIST
37369: LIST
37370: PUSH
37371: LD_INT 2
37373: PUSH
37374: LD_INT 2
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: PUSH
37381: LD_INT 1
37383: PUSH
37384: LD_INT 2
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 0
37393: PUSH
37394: LD_INT 2
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: LD_INT 1
37403: NEG
37404: PUSH
37405: LD_INT 1
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: PUSH
37412: LD_INT 2
37414: NEG
37415: PUSH
37416: LD_INT 0
37418: PUSH
37419: EMPTY
37420: LIST
37421: LIST
37422: PUSH
37423: LD_INT 2
37425: NEG
37426: PUSH
37427: LD_INT 1
37429: NEG
37430: PUSH
37431: EMPTY
37432: LIST
37433: LIST
37434: PUSH
37435: LD_INT 2
37437: NEG
37438: PUSH
37439: LD_INT 2
37441: NEG
37442: PUSH
37443: EMPTY
37444: LIST
37445: LIST
37446: PUSH
37447: EMPTY
37448: LIST
37449: LIST
37450: LIST
37451: LIST
37452: LIST
37453: LIST
37454: LIST
37455: LIST
37456: LIST
37457: LIST
37458: LIST
37459: LIST
37460: LIST
37461: LIST
37462: LIST
37463: LIST
37464: LIST
37465: LIST
37466: LIST
37467: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37468: LD_ADDR_VAR 0 55
37472: PUSH
37473: LD_INT 0
37475: PUSH
37476: LD_INT 0
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 0
37485: PUSH
37486: LD_INT 1
37488: NEG
37489: PUSH
37490: EMPTY
37491: LIST
37492: LIST
37493: PUSH
37494: LD_INT 1
37496: PUSH
37497: LD_INT 0
37499: PUSH
37500: EMPTY
37501: LIST
37502: LIST
37503: PUSH
37504: LD_INT 1
37506: PUSH
37507: LD_INT 1
37509: PUSH
37510: EMPTY
37511: LIST
37512: LIST
37513: PUSH
37514: LD_INT 0
37516: PUSH
37517: LD_INT 1
37519: PUSH
37520: EMPTY
37521: LIST
37522: LIST
37523: PUSH
37524: LD_INT 1
37526: NEG
37527: PUSH
37528: LD_INT 0
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: PUSH
37535: LD_INT 1
37537: NEG
37538: PUSH
37539: LD_INT 1
37541: NEG
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 1
37549: NEG
37550: PUSH
37551: LD_INT 2
37553: NEG
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: LD_INT 0
37561: PUSH
37562: LD_INT 2
37564: NEG
37565: PUSH
37566: EMPTY
37567: LIST
37568: LIST
37569: PUSH
37570: LD_INT 1
37572: PUSH
37573: LD_INT 1
37575: NEG
37576: PUSH
37577: EMPTY
37578: LIST
37579: LIST
37580: PUSH
37581: LD_INT 2
37583: PUSH
37584: LD_INT 0
37586: PUSH
37587: EMPTY
37588: LIST
37589: LIST
37590: PUSH
37591: LD_INT 2
37593: PUSH
37594: LD_INT 1
37596: PUSH
37597: EMPTY
37598: LIST
37599: LIST
37600: PUSH
37601: LD_INT 2
37603: PUSH
37604: LD_INT 2
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: PUSH
37611: LD_INT 1
37613: PUSH
37614: LD_INT 2
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 0
37623: PUSH
37624: LD_INT 2
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 1
37633: NEG
37634: PUSH
37635: LD_INT 1
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 2
37644: NEG
37645: PUSH
37646: LD_INT 0
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: LD_INT 2
37655: NEG
37656: PUSH
37657: LD_INT 1
37659: NEG
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: LD_INT 2
37667: NEG
37668: PUSH
37669: LD_INT 2
37671: NEG
37672: PUSH
37673: EMPTY
37674: LIST
37675: LIST
37676: PUSH
37677: EMPTY
37678: LIST
37679: LIST
37680: LIST
37681: LIST
37682: LIST
37683: LIST
37684: LIST
37685: LIST
37686: LIST
37687: LIST
37688: LIST
37689: LIST
37690: LIST
37691: LIST
37692: LIST
37693: LIST
37694: LIST
37695: LIST
37696: LIST
37697: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37698: LD_ADDR_VAR 0 56
37702: PUSH
37703: LD_INT 0
37705: PUSH
37706: LD_INT 0
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 0
37715: PUSH
37716: LD_INT 1
37718: NEG
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 1
37726: PUSH
37727: LD_INT 0
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 1
37736: PUSH
37737: LD_INT 1
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 0
37746: PUSH
37747: LD_INT 1
37749: PUSH
37750: EMPTY
37751: LIST
37752: LIST
37753: PUSH
37754: LD_INT 1
37756: NEG
37757: PUSH
37758: LD_INT 0
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 1
37767: NEG
37768: PUSH
37769: LD_INT 1
37771: NEG
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PUSH
37777: LD_INT 1
37779: NEG
37780: PUSH
37781: LD_INT 2
37783: NEG
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 0
37791: PUSH
37792: LD_INT 2
37794: NEG
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 1
37802: PUSH
37803: LD_INT 1
37805: NEG
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 2
37813: PUSH
37814: LD_INT 0
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 2
37823: PUSH
37824: LD_INT 1
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 2
37833: PUSH
37834: LD_INT 2
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 1
37843: PUSH
37844: LD_INT 2
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 0
37853: PUSH
37854: LD_INT 2
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 1
37863: NEG
37864: PUSH
37865: LD_INT 1
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 2
37874: NEG
37875: PUSH
37876: LD_INT 0
37878: PUSH
37879: EMPTY
37880: LIST
37881: LIST
37882: PUSH
37883: LD_INT 2
37885: NEG
37886: PUSH
37887: LD_INT 1
37889: NEG
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: PUSH
37895: LD_INT 2
37897: NEG
37898: PUSH
37899: LD_INT 2
37901: NEG
37902: PUSH
37903: EMPTY
37904: LIST
37905: LIST
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: LIST
37911: LIST
37912: LIST
37913: LIST
37914: LIST
37915: LIST
37916: LIST
37917: LIST
37918: LIST
37919: LIST
37920: LIST
37921: LIST
37922: LIST
37923: LIST
37924: LIST
37925: LIST
37926: LIST
37927: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37928: LD_ADDR_VAR 0 57
37932: PUSH
37933: LD_INT 0
37935: PUSH
37936: LD_INT 0
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: PUSH
37943: LD_INT 0
37945: PUSH
37946: LD_INT 1
37948: NEG
37949: PUSH
37950: EMPTY
37951: LIST
37952: LIST
37953: PUSH
37954: LD_INT 1
37956: PUSH
37957: LD_INT 0
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: LD_INT 1
37966: PUSH
37967: LD_INT 1
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: LD_INT 0
37976: PUSH
37977: LD_INT 1
37979: PUSH
37980: EMPTY
37981: LIST
37982: LIST
37983: PUSH
37984: LD_INT 1
37986: NEG
37987: PUSH
37988: LD_INT 0
37990: PUSH
37991: EMPTY
37992: LIST
37993: LIST
37994: PUSH
37995: LD_INT 1
37997: NEG
37998: PUSH
37999: LD_INT 1
38001: NEG
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PUSH
38007: LD_INT 1
38009: NEG
38010: PUSH
38011: LD_INT 2
38013: NEG
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: PUSH
38019: LD_INT 0
38021: PUSH
38022: LD_INT 2
38024: NEG
38025: PUSH
38026: EMPTY
38027: LIST
38028: LIST
38029: PUSH
38030: LD_INT 1
38032: PUSH
38033: LD_INT 1
38035: NEG
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: LD_INT 2
38043: PUSH
38044: LD_INT 0
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PUSH
38051: LD_INT 2
38053: PUSH
38054: LD_INT 1
38056: PUSH
38057: EMPTY
38058: LIST
38059: LIST
38060: PUSH
38061: LD_INT 2
38063: PUSH
38064: LD_INT 2
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: PUSH
38071: LD_INT 1
38073: PUSH
38074: LD_INT 2
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 0
38083: PUSH
38084: LD_INT 2
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 1
38093: NEG
38094: PUSH
38095: LD_INT 1
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 2
38104: NEG
38105: PUSH
38106: LD_INT 0
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 2
38115: NEG
38116: PUSH
38117: LD_INT 1
38119: NEG
38120: PUSH
38121: EMPTY
38122: LIST
38123: LIST
38124: PUSH
38125: LD_INT 2
38127: NEG
38128: PUSH
38129: LD_INT 2
38131: NEG
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: EMPTY
38138: LIST
38139: LIST
38140: LIST
38141: LIST
38142: LIST
38143: LIST
38144: LIST
38145: LIST
38146: LIST
38147: LIST
38148: LIST
38149: LIST
38150: LIST
38151: LIST
38152: LIST
38153: LIST
38154: LIST
38155: LIST
38156: LIST
38157: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38158: LD_ADDR_VAR 0 58
38162: PUSH
38163: LD_INT 0
38165: PUSH
38166: LD_INT 0
38168: PUSH
38169: EMPTY
38170: LIST
38171: LIST
38172: PUSH
38173: LD_INT 0
38175: PUSH
38176: LD_INT 1
38178: NEG
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: PUSH
38184: LD_INT 1
38186: PUSH
38187: LD_INT 0
38189: PUSH
38190: EMPTY
38191: LIST
38192: LIST
38193: PUSH
38194: LD_INT 1
38196: PUSH
38197: LD_INT 1
38199: PUSH
38200: EMPTY
38201: LIST
38202: LIST
38203: PUSH
38204: LD_INT 0
38206: PUSH
38207: LD_INT 1
38209: PUSH
38210: EMPTY
38211: LIST
38212: LIST
38213: PUSH
38214: LD_INT 1
38216: NEG
38217: PUSH
38218: LD_INT 0
38220: PUSH
38221: EMPTY
38222: LIST
38223: LIST
38224: PUSH
38225: LD_INT 1
38227: NEG
38228: PUSH
38229: LD_INT 1
38231: NEG
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: PUSH
38237: LD_INT 1
38239: NEG
38240: PUSH
38241: LD_INT 2
38243: NEG
38244: PUSH
38245: EMPTY
38246: LIST
38247: LIST
38248: PUSH
38249: LD_INT 0
38251: PUSH
38252: LD_INT 2
38254: NEG
38255: PUSH
38256: EMPTY
38257: LIST
38258: LIST
38259: PUSH
38260: LD_INT 1
38262: PUSH
38263: LD_INT 1
38265: NEG
38266: PUSH
38267: EMPTY
38268: LIST
38269: LIST
38270: PUSH
38271: LD_INT 2
38273: PUSH
38274: LD_INT 0
38276: PUSH
38277: EMPTY
38278: LIST
38279: LIST
38280: PUSH
38281: LD_INT 2
38283: PUSH
38284: LD_INT 1
38286: PUSH
38287: EMPTY
38288: LIST
38289: LIST
38290: PUSH
38291: LD_INT 2
38293: PUSH
38294: LD_INT 2
38296: PUSH
38297: EMPTY
38298: LIST
38299: LIST
38300: PUSH
38301: LD_INT 1
38303: PUSH
38304: LD_INT 2
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 0
38313: PUSH
38314: LD_INT 2
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 1
38323: NEG
38324: PUSH
38325: LD_INT 1
38327: PUSH
38328: EMPTY
38329: LIST
38330: LIST
38331: PUSH
38332: LD_INT 2
38334: NEG
38335: PUSH
38336: LD_INT 0
38338: PUSH
38339: EMPTY
38340: LIST
38341: LIST
38342: PUSH
38343: LD_INT 2
38345: NEG
38346: PUSH
38347: LD_INT 1
38349: NEG
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: PUSH
38355: LD_INT 2
38357: NEG
38358: PUSH
38359: LD_INT 2
38361: NEG
38362: PUSH
38363: EMPTY
38364: LIST
38365: LIST
38366: PUSH
38367: EMPTY
38368: LIST
38369: LIST
38370: LIST
38371: LIST
38372: LIST
38373: LIST
38374: LIST
38375: LIST
38376: LIST
38377: LIST
38378: LIST
38379: LIST
38380: LIST
38381: LIST
38382: LIST
38383: LIST
38384: LIST
38385: LIST
38386: LIST
38387: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38388: LD_ADDR_VAR 0 59
38392: PUSH
38393: LD_INT 0
38395: PUSH
38396: LD_INT 0
38398: PUSH
38399: EMPTY
38400: LIST
38401: LIST
38402: PUSH
38403: LD_INT 0
38405: PUSH
38406: LD_INT 1
38408: NEG
38409: PUSH
38410: EMPTY
38411: LIST
38412: LIST
38413: PUSH
38414: LD_INT 1
38416: PUSH
38417: LD_INT 0
38419: PUSH
38420: EMPTY
38421: LIST
38422: LIST
38423: PUSH
38424: LD_INT 1
38426: PUSH
38427: LD_INT 1
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 0
38436: PUSH
38437: LD_INT 1
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: PUSH
38444: LD_INT 1
38446: NEG
38447: PUSH
38448: LD_INT 0
38450: PUSH
38451: EMPTY
38452: LIST
38453: LIST
38454: PUSH
38455: LD_INT 1
38457: NEG
38458: PUSH
38459: LD_INT 1
38461: NEG
38462: PUSH
38463: EMPTY
38464: LIST
38465: LIST
38466: PUSH
38467: EMPTY
38468: LIST
38469: LIST
38470: LIST
38471: LIST
38472: LIST
38473: LIST
38474: LIST
38475: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38476: LD_ADDR_VAR 0 60
38480: PUSH
38481: LD_INT 0
38483: PUSH
38484: LD_INT 0
38486: PUSH
38487: EMPTY
38488: LIST
38489: LIST
38490: PUSH
38491: LD_INT 0
38493: PUSH
38494: LD_INT 1
38496: NEG
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 1
38504: PUSH
38505: LD_INT 0
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 1
38514: PUSH
38515: LD_INT 1
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 0
38524: PUSH
38525: LD_INT 1
38527: PUSH
38528: EMPTY
38529: LIST
38530: LIST
38531: PUSH
38532: LD_INT 1
38534: NEG
38535: PUSH
38536: LD_INT 0
38538: PUSH
38539: EMPTY
38540: LIST
38541: LIST
38542: PUSH
38543: LD_INT 1
38545: NEG
38546: PUSH
38547: LD_INT 1
38549: NEG
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: EMPTY
38556: LIST
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38564: LD_ADDR_VAR 0 61
38568: PUSH
38569: LD_INT 0
38571: PUSH
38572: LD_INT 0
38574: PUSH
38575: EMPTY
38576: LIST
38577: LIST
38578: PUSH
38579: LD_INT 0
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: EMPTY
38587: LIST
38588: LIST
38589: PUSH
38590: LD_INT 1
38592: PUSH
38593: LD_INT 0
38595: PUSH
38596: EMPTY
38597: LIST
38598: LIST
38599: PUSH
38600: LD_INT 1
38602: PUSH
38603: LD_INT 1
38605: PUSH
38606: EMPTY
38607: LIST
38608: LIST
38609: PUSH
38610: LD_INT 0
38612: PUSH
38613: LD_INT 1
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: PUSH
38620: LD_INT 1
38622: NEG
38623: PUSH
38624: LD_INT 0
38626: PUSH
38627: EMPTY
38628: LIST
38629: LIST
38630: PUSH
38631: LD_INT 1
38633: NEG
38634: PUSH
38635: LD_INT 1
38637: NEG
38638: PUSH
38639: EMPTY
38640: LIST
38641: LIST
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: LIST
38647: LIST
38648: LIST
38649: LIST
38650: LIST
38651: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38652: LD_ADDR_VAR 0 62
38656: PUSH
38657: LD_INT 0
38659: PUSH
38660: LD_INT 0
38662: PUSH
38663: EMPTY
38664: LIST
38665: LIST
38666: PUSH
38667: LD_INT 0
38669: PUSH
38670: LD_INT 1
38672: NEG
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 1
38680: PUSH
38681: LD_INT 0
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 1
38690: PUSH
38691: LD_INT 1
38693: PUSH
38694: EMPTY
38695: LIST
38696: LIST
38697: PUSH
38698: LD_INT 0
38700: PUSH
38701: LD_INT 1
38703: PUSH
38704: EMPTY
38705: LIST
38706: LIST
38707: PUSH
38708: LD_INT 1
38710: NEG
38711: PUSH
38712: LD_INT 0
38714: PUSH
38715: EMPTY
38716: LIST
38717: LIST
38718: PUSH
38719: LD_INT 1
38721: NEG
38722: PUSH
38723: LD_INT 1
38725: NEG
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38740: LD_ADDR_VAR 0 63
38744: PUSH
38745: LD_INT 0
38747: PUSH
38748: LD_INT 0
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: LD_INT 0
38757: PUSH
38758: LD_INT 1
38760: NEG
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 1
38768: PUSH
38769: LD_INT 0
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 1
38778: PUSH
38779: LD_INT 1
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: LD_INT 0
38788: PUSH
38789: LD_INT 1
38791: PUSH
38792: EMPTY
38793: LIST
38794: LIST
38795: PUSH
38796: LD_INT 1
38798: NEG
38799: PUSH
38800: LD_INT 0
38802: PUSH
38803: EMPTY
38804: LIST
38805: LIST
38806: PUSH
38807: LD_INT 1
38809: NEG
38810: PUSH
38811: LD_INT 1
38813: NEG
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: PUSH
38819: EMPTY
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38828: LD_ADDR_VAR 0 64
38832: PUSH
38833: LD_INT 0
38835: PUSH
38836: LD_INT 0
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: PUSH
38843: LD_INT 0
38845: PUSH
38846: LD_INT 1
38848: NEG
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: LD_INT 0
38859: PUSH
38860: EMPTY
38861: LIST
38862: LIST
38863: PUSH
38864: LD_INT 1
38866: PUSH
38867: LD_INT 1
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: LD_INT 0
38876: PUSH
38877: LD_INT 1
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 1
38886: NEG
38887: PUSH
38888: LD_INT 0
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: PUSH
38895: LD_INT 1
38897: NEG
38898: PUSH
38899: LD_INT 1
38901: NEG
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: EMPTY
38908: LIST
38909: LIST
38910: LIST
38911: LIST
38912: LIST
38913: LIST
38914: LIST
38915: ST_TO_ADDR
// end ; 1 :
38916: GO 44813
38918: LD_INT 1
38920: DOUBLE
38921: EQUAL
38922: IFTRUE 38926
38924: GO 41549
38926: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38927: LD_ADDR_VAR 0 11
38931: PUSH
38932: LD_INT 1
38934: NEG
38935: PUSH
38936: LD_INT 3
38938: NEG
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: LD_INT 0
38946: PUSH
38947: LD_INT 3
38949: NEG
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PUSH
38955: LD_INT 1
38957: PUSH
38958: LD_INT 2
38960: NEG
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PUSH
38966: EMPTY
38967: LIST
38968: LIST
38969: LIST
38970: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38971: LD_ADDR_VAR 0 12
38975: PUSH
38976: LD_INT 2
38978: PUSH
38979: LD_INT 1
38981: NEG
38982: PUSH
38983: EMPTY
38984: LIST
38985: LIST
38986: PUSH
38987: LD_INT 3
38989: PUSH
38990: LD_INT 0
38992: PUSH
38993: EMPTY
38994: LIST
38995: LIST
38996: PUSH
38997: LD_INT 3
38999: PUSH
39000: LD_INT 1
39002: PUSH
39003: EMPTY
39004: LIST
39005: LIST
39006: PUSH
39007: EMPTY
39008: LIST
39009: LIST
39010: LIST
39011: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39012: LD_ADDR_VAR 0 13
39016: PUSH
39017: LD_INT 3
39019: PUSH
39020: LD_INT 2
39022: PUSH
39023: EMPTY
39024: LIST
39025: LIST
39026: PUSH
39027: LD_INT 3
39029: PUSH
39030: LD_INT 3
39032: PUSH
39033: EMPTY
39034: LIST
39035: LIST
39036: PUSH
39037: LD_INT 2
39039: PUSH
39040: LD_INT 3
39042: PUSH
39043: EMPTY
39044: LIST
39045: LIST
39046: PUSH
39047: EMPTY
39048: LIST
39049: LIST
39050: LIST
39051: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39052: LD_ADDR_VAR 0 14
39056: PUSH
39057: LD_INT 1
39059: PUSH
39060: LD_INT 3
39062: PUSH
39063: EMPTY
39064: LIST
39065: LIST
39066: PUSH
39067: LD_INT 0
39069: PUSH
39070: LD_INT 3
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 1
39079: NEG
39080: PUSH
39081: LD_INT 2
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: LIST
39092: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39093: LD_ADDR_VAR 0 15
39097: PUSH
39098: LD_INT 2
39100: NEG
39101: PUSH
39102: LD_INT 1
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 3
39111: NEG
39112: PUSH
39113: LD_INT 0
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: PUSH
39120: LD_INT 3
39122: NEG
39123: PUSH
39124: LD_INT 1
39126: NEG
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: LIST
39136: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39137: LD_ADDR_VAR 0 16
39141: PUSH
39142: LD_INT 2
39144: NEG
39145: PUSH
39146: LD_INT 3
39148: NEG
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: LD_INT 3
39156: NEG
39157: PUSH
39158: LD_INT 2
39160: NEG
39161: PUSH
39162: EMPTY
39163: LIST
39164: LIST
39165: PUSH
39166: LD_INT 3
39168: NEG
39169: PUSH
39170: LD_INT 3
39172: NEG
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: EMPTY
39179: LIST
39180: LIST
39181: LIST
39182: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39183: LD_ADDR_VAR 0 17
39187: PUSH
39188: LD_INT 1
39190: NEG
39191: PUSH
39192: LD_INT 3
39194: NEG
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 0
39202: PUSH
39203: LD_INT 3
39205: NEG
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PUSH
39211: LD_INT 1
39213: PUSH
39214: LD_INT 2
39216: NEG
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PUSH
39222: EMPTY
39223: LIST
39224: LIST
39225: LIST
39226: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39227: LD_ADDR_VAR 0 18
39231: PUSH
39232: LD_INT 2
39234: PUSH
39235: LD_INT 1
39237: NEG
39238: PUSH
39239: EMPTY
39240: LIST
39241: LIST
39242: PUSH
39243: LD_INT 3
39245: PUSH
39246: LD_INT 0
39248: PUSH
39249: EMPTY
39250: LIST
39251: LIST
39252: PUSH
39253: LD_INT 3
39255: PUSH
39256: LD_INT 1
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: LIST
39267: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39268: LD_ADDR_VAR 0 19
39272: PUSH
39273: LD_INT 3
39275: PUSH
39276: LD_INT 2
39278: PUSH
39279: EMPTY
39280: LIST
39281: LIST
39282: PUSH
39283: LD_INT 3
39285: PUSH
39286: LD_INT 3
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: LD_INT 2
39295: PUSH
39296: LD_INT 3
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: LIST
39307: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39308: LD_ADDR_VAR 0 20
39312: PUSH
39313: LD_INT 1
39315: PUSH
39316: LD_INT 3
39318: PUSH
39319: EMPTY
39320: LIST
39321: LIST
39322: PUSH
39323: LD_INT 0
39325: PUSH
39326: LD_INT 3
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 1
39335: NEG
39336: PUSH
39337: LD_INT 2
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: LIST
39348: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39349: LD_ADDR_VAR 0 21
39353: PUSH
39354: LD_INT 2
39356: NEG
39357: PUSH
39358: LD_INT 1
39360: PUSH
39361: EMPTY
39362: LIST
39363: LIST
39364: PUSH
39365: LD_INT 3
39367: NEG
39368: PUSH
39369: LD_INT 0
39371: PUSH
39372: EMPTY
39373: LIST
39374: LIST
39375: PUSH
39376: LD_INT 3
39378: NEG
39379: PUSH
39380: LD_INT 1
39382: NEG
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: LIST
39392: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39393: LD_ADDR_VAR 0 22
39397: PUSH
39398: LD_INT 2
39400: NEG
39401: PUSH
39402: LD_INT 3
39404: NEG
39405: PUSH
39406: EMPTY
39407: LIST
39408: LIST
39409: PUSH
39410: LD_INT 3
39412: NEG
39413: PUSH
39414: LD_INT 2
39416: NEG
39417: PUSH
39418: EMPTY
39419: LIST
39420: LIST
39421: PUSH
39422: LD_INT 3
39424: NEG
39425: PUSH
39426: LD_INT 3
39428: NEG
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: LIST
39438: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39439: LD_ADDR_VAR 0 23
39443: PUSH
39444: LD_INT 0
39446: PUSH
39447: LD_INT 3
39449: NEG
39450: PUSH
39451: EMPTY
39452: LIST
39453: LIST
39454: PUSH
39455: LD_INT 1
39457: NEG
39458: PUSH
39459: LD_INT 4
39461: NEG
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 1
39469: PUSH
39470: LD_INT 3
39472: NEG
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: LIST
39482: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39483: LD_ADDR_VAR 0 24
39487: PUSH
39488: LD_INT 3
39490: PUSH
39491: LD_INT 0
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: PUSH
39498: LD_INT 3
39500: PUSH
39501: LD_INT 1
39503: NEG
39504: PUSH
39505: EMPTY
39506: LIST
39507: LIST
39508: PUSH
39509: LD_INT 4
39511: PUSH
39512: LD_INT 1
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: LIST
39523: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39524: LD_ADDR_VAR 0 25
39528: PUSH
39529: LD_INT 3
39531: PUSH
39532: LD_INT 3
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: PUSH
39539: LD_INT 4
39541: PUSH
39542: LD_INT 3
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: PUSH
39549: LD_INT 3
39551: PUSH
39552: LD_INT 4
39554: PUSH
39555: EMPTY
39556: LIST
39557: LIST
39558: PUSH
39559: EMPTY
39560: LIST
39561: LIST
39562: LIST
39563: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39564: LD_ADDR_VAR 0 26
39568: PUSH
39569: LD_INT 0
39571: PUSH
39572: LD_INT 3
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: LD_INT 1
39581: PUSH
39582: LD_INT 4
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: PUSH
39589: LD_INT 1
39591: NEG
39592: PUSH
39593: LD_INT 3
39595: PUSH
39596: EMPTY
39597: LIST
39598: LIST
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: LIST
39604: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
39605: LD_ADDR_VAR 0 27
39609: PUSH
39610: LD_INT 3
39612: NEG
39613: PUSH
39614: LD_INT 0
39616: PUSH
39617: EMPTY
39618: LIST
39619: LIST
39620: PUSH
39621: LD_INT 3
39623: NEG
39624: PUSH
39625: LD_INT 1
39627: PUSH
39628: EMPTY
39629: LIST
39630: LIST
39631: PUSH
39632: LD_INT 4
39634: NEG
39635: PUSH
39636: LD_INT 1
39638: NEG
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: EMPTY
39645: LIST
39646: LIST
39647: LIST
39648: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
39649: LD_ADDR_VAR 0 28
39653: PUSH
39654: LD_INT 3
39656: NEG
39657: PUSH
39658: LD_INT 3
39660: NEG
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: PUSH
39666: LD_INT 3
39668: NEG
39669: PUSH
39670: LD_INT 4
39672: NEG
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: LD_INT 4
39680: NEG
39681: PUSH
39682: LD_INT 3
39684: NEG
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: EMPTY
39691: LIST
39692: LIST
39693: LIST
39694: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
39695: LD_ADDR_VAR 0 29
39699: PUSH
39700: LD_INT 1
39702: NEG
39703: PUSH
39704: LD_INT 3
39706: NEG
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 0
39714: PUSH
39715: LD_INT 3
39717: NEG
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 1
39725: PUSH
39726: LD_INT 2
39728: NEG
39729: PUSH
39730: EMPTY
39731: LIST
39732: LIST
39733: PUSH
39734: LD_INT 1
39736: NEG
39737: PUSH
39738: LD_INT 4
39740: NEG
39741: PUSH
39742: EMPTY
39743: LIST
39744: LIST
39745: PUSH
39746: LD_INT 0
39748: PUSH
39749: LD_INT 4
39751: NEG
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: LD_INT 1
39759: PUSH
39760: LD_INT 3
39762: NEG
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 1
39770: NEG
39771: PUSH
39772: LD_INT 5
39774: NEG
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 0
39782: PUSH
39783: LD_INT 5
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 1
39793: PUSH
39794: LD_INT 4
39796: NEG
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 1
39804: NEG
39805: PUSH
39806: LD_INT 6
39808: NEG
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 0
39816: PUSH
39817: LD_INT 6
39819: NEG
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: LD_INT 1
39827: PUSH
39828: LD_INT 5
39830: NEG
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: LIST
39840: LIST
39841: LIST
39842: LIST
39843: LIST
39844: LIST
39845: LIST
39846: LIST
39847: LIST
39848: LIST
39849: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
39850: LD_ADDR_VAR 0 30
39854: PUSH
39855: LD_INT 2
39857: PUSH
39858: LD_INT 1
39860: NEG
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 3
39868: PUSH
39869: LD_INT 0
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: LD_INT 3
39878: PUSH
39879: LD_INT 1
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 3
39888: PUSH
39889: LD_INT 1
39891: NEG
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 4
39899: PUSH
39900: LD_INT 0
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 4
39909: PUSH
39910: LD_INT 1
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 4
39919: PUSH
39920: LD_INT 1
39922: NEG
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 5
39930: PUSH
39931: LD_INT 0
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 5
39940: PUSH
39941: LD_INT 1
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PUSH
39948: LD_INT 5
39950: PUSH
39951: LD_INT 1
39953: NEG
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: PUSH
39959: LD_INT 6
39961: PUSH
39962: LD_INT 0
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: PUSH
39969: LD_INT 6
39971: PUSH
39972: LD_INT 1
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: PUSH
39979: EMPTY
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: LIST
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
39993: LD_ADDR_VAR 0 31
39997: PUSH
39998: LD_INT 3
40000: PUSH
40001: LD_INT 2
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: PUSH
40008: LD_INT 3
40010: PUSH
40011: LD_INT 3
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: PUSH
40018: LD_INT 2
40020: PUSH
40021: LD_INT 3
40023: PUSH
40024: EMPTY
40025: LIST
40026: LIST
40027: PUSH
40028: LD_INT 4
40030: PUSH
40031: LD_INT 3
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 4
40040: PUSH
40041: LD_INT 4
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PUSH
40048: LD_INT 3
40050: PUSH
40051: LD_INT 4
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: PUSH
40058: LD_INT 5
40060: PUSH
40061: LD_INT 4
40063: PUSH
40064: EMPTY
40065: LIST
40066: LIST
40067: PUSH
40068: LD_INT 5
40070: PUSH
40071: LD_INT 5
40073: PUSH
40074: EMPTY
40075: LIST
40076: LIST
40077: PUSH
40078: LD_INT 4
40080: PUSH
40081: LD_INT 5
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: PUSH
40088: LD_INT 6
40090: PUSH
40091: LD_INT 5
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 6
40100: PUSH
40101: LD_INT 6
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: LD_INT 5
40110: PUSH
40111: LD_INT 6
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: LIST
40122: LIST
40123: LIST
40124: LIST
40125: LIST
40126: LIST
40127: LIST
40128: LIST
40129: LIST
40130: LIST
40131: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40132: LD_ADDR_VAR 0 32
40136: PUSH
40137: LD_INT 1
40139: PUSH
40140: LD_INT 3
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 0
40149: PUSH
40150: LD_INT 3
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 1
40159: NEG
40160: PUSH
40161: LD_INT 2
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 1
40170: PUSH
40171: LD_INT 4
40173: PUSH
40174: EMPTY
40175: LIST
40176: LIST
40177: PUSH
40178: LD_INT 0
40180: PUSH
40181: LD_INT 4
40183: PUSH
40184: EMPTY
40185: LIST
40186: LIST
40187: PUSH
40188: LD_INT 1
40190: NEG
40191: PUSH
40192: LD_INT 3
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: PUSH
40199: LD_INT 1
40201: PUSH
40202: LD_INT 5
40204: PUSH
40205: EMPTY
40206: LIST
40207: LIST
40208: PUSH
40209: LD_INT 0
40211: PUSH
40212: LD_INT 5
40214: PUSH
40215: EMPTY
40216: LIST
40217: LIST
40218: PUSH
40219: LD_INT 1
40221: NEG
40222: PUSH
40223: LD_INT 4
40225: PUSH
40226: EMPTY
40227: LIST
40228: LIST
40229: PUSH
40230: LD_INT 1
40232: PUSH
40233: LD_INT 6
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PUSH
40240: LD_INT 0
40242: PUSH
40243: LD_INT 6
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: PUSH
40250: LD_INT 1
40252: NEG
40253: PUSH
40254: LD_INT 5
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: LIST
40265: LIST
40266: LIST
40267: LIST
40268: LIST
40269: LIST
40270: LIST
40271: LIST
40272: LIST
40273: LIST
40274: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40275: LD_ADDR_VAR 0 33
40279: PUSH
40280: LD_INT 2
40282: NEG
40283: PUSH
40284: LD_INT 1
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 3
40293: NEG
40294: PUSH
40295: LD_INT 0
40297: PUSH
40298: EMPTY
40299: LIST
40300: LIST
40301: PUSH
40302: LD_INT 3
40304: NEG
40305: PUSH
40306: LD_INT 1
40308: NEG
40309: PUSH
40310: EMPTY
40311: LIST
40312: LIST
40313: PUSH
40314: LD_INT 3
40316: NEG
40317: PUSH
40318: LD_INT 1
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 4
40327: NEG
40328: PUSH
40329: LD_INT 0
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 4
40338: NEG
40339: PUSH
40340: LD_INT 1
40342: NEG
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: PUSH
40348: LD_INT 4
40350: NEG
40351: PUSH
40352: LD_INT 1
40354: PUSH
40355: EMPTY
40356: LIST
40357: LIST
40358: PUSH
40359: LD_INT 5
40361: NEG
40362: PUSH
40363: LD_INT 0
40365: PUSH
40366: EMPTY
40367: LIST
40368: LIST
40369: PUSH
40370: LD_INT 5
40372: NEG
40373: PUSH
40374: LD_INT 1
40376: NEG
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: PUSH
40382: LD_INT 5
40384: NEG
40385: PUSH
40386: LD_INT 1
40388: PUSH
40389: EMPTY
40390: LIST
40391: LIST
40392: PUSH
40393: LD_INT 6
40395: NEG
40396: PUSH
40397: LD_INT 0
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: LD_INT 6
40406: NEG
40407: PUSH
40408: LD_INT 1
40410: NEG
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: LIST
40422: LIST
40423: LIST
40424: LIST
40425: LIST
40426: LIST
40427: LIST
40428: LIST
40429: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40430: LD_ADDR_VAR 0 34
40434: PUSH
40435: LD_INT 2
40437: NEG
40438: PUSH
40439: LD_INT 3
40441: NEG
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: LD_INT 3
40449: NEG
40450: PUSH
40451: LD_INT 2
40453: NEG
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 3
40461: NEG
40462: PUSH
40463: LD_INT 3
40465: NEG
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 3
40473: NEG
40474: PUSH
40475: LD_INT 4
40477: NEG
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: LD_INT 4
40485: NEG
40486: PUSH
40487: LD_INT 3
40489: NEG
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: LD_INT 4
40497: NEG
40498: PUSH
40499: LD_INT 4
40501: NEG
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: PUSH
40507: LD_INT 4
40509: NEG
40510: PUSH
40511: LD_INT 5
40513: NEG
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: PUSH
40519: LD_INT 5
40521: NEG
40522: PUSH
40523: LD_INT 4
40525: NEG
40526: PUSH
40527: EMPTY
40528: LIST
40529: LIST
40530: PUSH
40531: LD_INT 5
40533: NEG
40534: PUSH
40535: LD_INT 5
40537: NEG
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 5
40545: NEG
40546: PUSH
40547: LD_INT 6
40549: NEG
40550: PUSH
40551: EMPTY
40552: LIST
40553: LIST
40554: PUSH
40555: LD_INT 6
40557: NEG
40558: PUSH
40559: LD_INT 5
40561: NEG
40562: PUSH
40563: EMPTY
40564: LIST
40565: LIST
40566: PUSH
40567: LD_INT 6
40569: NEG
40570: PUSH
40571: LD_INT 6
40573: NEG
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: LIST
40583: LIST
40584: LIST
40585: LIST
40586: LIST
40587: LIST
40588: LIST
40589: LIST
40590: LIST
40591: LIST
40592: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
40593: LD_ADDR_VAR 0 41
40597: PUSH
40598: LD_INT 0
40600: PUSH
40601: LD_INT 2
40603: NEG
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: PUSH
40609: LD_INT 1
40611: NEG
40612: PUSH
40613: LD_INT 3
40615: NEG
40616: PUSH
40617: EMPTY
40618: LIST
40619: LIST
40620: PUSH
40621: LD_INT 1
40623: PUSH
40624: LD_INT 2
40626: NEG
40627: PUSH
40628: EMPTY
40629: LIST
40630: LIST
40631: PUSH
40632: EMPTY
40633: LIST
40634: LIST
40635: LIST
40636: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
40637: LD_ADDR_VAR 0 42
40641: PUSH
40642: LD_INT 2
40644: PUSH
40645: LD_INT 0
40647: PUSH
40648: EMPTY
40649: LIST
40650: LIST
40651: PUSH
40652: LD_INT 2
40654: PUSH
40655: LD_INT 1
40657: NEG
40658: PUSH
40659: EMPTY
40660: LIST
40661: LIST
40662: PUSH
40663: LD_INT 3
40665: PUSH
40666: LD_INT 1
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: LIST
40677: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
40678: LD_ADDR_VAR 0 43
40682: PUSH
40683: LD_INT 2
40685: PUSH
40686: LD_INT 2
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: LD_INT 3
40695: PUSH
40696: LD_INT 2
40698: PUSH
40699: EMPTY
40700: LIST
40701: LIST
40702: PUSH
40703: LD_INT 2
40705: PUSH
40706: LD_INT 3
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: LIST
40717: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
40718: LD_ADDR_VAR 0 44
40722: PUSH
40723: LD_INT 0
40725: PUSH
40726: LD_INT 2
40728: PUSH
40729: EMPTY
40730: LIST
40731: LIST
40732: PUSH
40733: LD_INT 1
40735: PUSH
40736: LD_INT 3
40738: PUSH
40739: EMPTY
40740: LIST
40741: LIST
40742: PUSH
40743: LD_INT 1
40745: NEG
40746: PUSH
40747: LD_INT 2
40749: PUSH
40750: EMPTY
40751: LIST
40752: LIST
40753: PUSH
40754: EMPTY
40755: LIST
40756: LIST
40757: LIST
40758: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
40759: LD_ADDR_VAR 0 45
40763: PUSH
40764: LD_INT 2
40766: NEG
40767: PUSH
40768: LD_INT 0
40770: PUSH
40771: EMPTY
40772: LIST
40773: LIST
40774: PUSH
40775: LD_INT 2
40777: NEG
40778: PUSH
40779: LD_INT 1
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 3
40788: NEG
40789: PUSH
40790: LD_INT 1
40792: NEG
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: LIST
40802: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
40803: LD_ADDR_VAR 0 46
40807: PUSH
40808: LD_INT 2
40810: NEG
40811: PUSH
40812: LD_INT 2
40814: NEG
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: LD_INT 2
40822: NEG
40823: PUSH
40824: LD_INT 3
40826: NEG
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 3
40834: NEG
40835: PUSH
40836: LD_INT 2
40838: NEG
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: LIST
40848: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
40849: LD_ADDR_VAR 0 47
40853: PUSH
40854: LD_INT 2
40856: NEG
40857: PUSH
40858: LD_INT 3
40860: NEG
40861: PUSH
40862: EMPTY
40863: LIST
40864: LIST
40865: PUSH
40866: LD_INT 1
40868: NEG
40869: PUSH
40870: LD_INT 3
40872: NEG
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
40882: LD_ADDR_VAR 0 48
40886: PUSH
40887: LD_INT 1
40889: PUSH
40890: LD_INT 2
40892: NEG
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: LD_INT 2
40900: PUSH
40901: LD_INT 1
40903: NEG
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
40913: LD_ADDR_VAR 0 49
40917: PUSH
40918: LD_INT 3
40920: PUSH
40921: LD_INT 1
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PUSH
40928: LD_INT 3
40930: PUSH
40931: LD_INT 2
40933: PUSH
40934: EMPTY
40935: LIST
40936: LIST
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
40942: LD_ADDR_VAR 0 50
40946: PUSH
40947: LD_INT 2
40949: PUSH
40950: LD_INT 3
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: LD_INT 1
40959: PUSH
40960: LD_INT 3
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PUSH
40967: EMPTY
40968: LIST
40969: LIST
40970: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
40971: LD_ADDR_VAR 0 51
40975: PUSH
40976: LD_INT 1
40978: NEG
40979: PUSH
40980: LD_INT 2
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: PUSH
40987: LD_INT 2
40989: NEG
40990: PUSH
40991: LD_INT 1
40993: PUSH
40994: EMPTY
40995: LIST
40996: LIST
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41002: LD_ADDR_VAR 0 52
41006: PUSH
41007: LD_INT 3
41009: NEG
41010: PUSH
41011: LD_INT 1
41013: NEG
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 3
41021: NEG
41022: PUSH
41023: LD_INT 2
41025: NEG
41026: PUSH
41027: EMPTY
41028: LIST
41029: LIST
41030: PUSH
41031: EMPTY
41032: LIST
41033: LIST
41034: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41035: LD_ADDR_VAR 0 53
41039: PUSH
41040: LD_INT 1
41042: NEG
41043: PUSH
41044: LD_INT 3
41046: NEG
41047: PUSH
41048: EMPTY
41049: LIST
41050: LIST
41051: PUSH
41052: LD_INT 0
41054: PUSH
41055: LD_INT 3
41057: NEG
41058: PUSH
41059: EMPTY
41060: LIST
41061: LIST
41062: PUSH
41063: LD_INT 1
41065: PUSH
41066: LD_INT 2
41068: NEG
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: PUSH
41074: EMPTY
41075: LIST
41076: LIST
41077: LIST
41078: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41079: LD_ADDR_VAR 0 54
41083: PUSH
41084: LD_INT 2
41086: PUSH
41087: LD_INT 1
41089: NEG
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: LD_INT 3
41097: PUSH
41098: LD_INT 0
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 3
41107: PUSH
41108: LD_INT 1
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: LIST
41119: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41120: LD_ADDR_VAR 0 55
41124: PUSH
41125: LD_INT 3
41127: PUSH
41128: LD_INT 2
41130: PUSH
41131: EMPTY
41132: LIST
41133: LIST
41134: PUSH
41135: LD_INT 3
41137: PUSH
41138: LD_INT 3
41140: PUSH
41141: EMPTY
41142: LIST
41143: LIST
41144: PUSH
41145: LD_INT 2
41147: PUSH
41148: LD_INT 3
41150: PUSH
41151: EMPTY
41152: LIST
41153: LIST
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: LIST
41159: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41160: LD_ADDR_VAR 0 56
41164: PUSH
41165: LD_INT 1
41167: PUSH
41168: LD_INT 3
41170: PUSH
41171: EMPTY
41172: LIST
41173: LIST
41174: PUSH
41175: LD_INT 0
41177: PUSH
41178: LD_INT 3
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 1
41187: NEG
41188: PUSH
41189: LD_INT 2
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: LIST
41200: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41201: LD_ADDR_VAR 0 57
41205: PUSH
41206: LD_INT 2
41208: NEG
41209: PUSH
41210: LD_INT 1
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: PUSH
41217: LD_INT 3
41219: NEG
41220: PUSH
41221: LD_INT 0
41223: PUSH
41224: EMPTY
41225: LIST
41226: LIST
41227: PUSH
41228: LD_INT 3
41230: NEG
41231: PUSH
41232: LD_INT 1
41234: NEG
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: LIST
41244: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41245: LD_ADDR_VAR 0 58
41249: PUSH
41250: LD_INT 2
41252: NEG
41253: PUSH
41254: LD_INT 3
41256: NEG
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: PUSH
41262: LD_INT 3
41264: NEG
41265: PUSH
41266: LD_INT 2
41268: NEG
41269: PUSH
41270: EMPTY
41271: LIST
41272: LIST
41273: PUSH
41274: LD_INT 3
41276: NEG
41277: PUSH
41278: LD_INT 3
41280: NEG
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: LIST
41290: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41291: LD_ADDR_VAR 0 59
41295: PUSH
41296: LD_INT 1
41298: NEG
41299: PUSH
41300: LD_INT 2
41302: NEG
41303: PUSH
41304: EMPTY
41305: LIST
41306: LIST
41307: PUSH
41308: LD_INT 0
41310: PUSH
41311: LD_INT 2
41313: NEG
41314: PUSH
41315: EMPTY
41316: LIST
41317: LIST
41318: PUSH
41319: LD_INT 1
41321: PUSH
41322: LD_INT 1
41324: NEG
41325: PUSH
41326: EMPTY
41327: LIST
41328: LIST
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: LIST
41334: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41335: LD_ADDR_VAR 0 60
41339: PUSH
41340: LD_INT 1
41342: PUSH
41343: LD_INT 1
41345: NEG
41346: PUSH
41347: EMPTY
41348: LIST
41349: LIST
41350: PUSH
41351: LD_INT 2
41353: PUSH
41354: LD_INT 0
41356: PUSH
41357: EMPTY
41358: LIST
41359: LIST
41360: PUSH
41361: LD_INT 2
41363: PUSH
41364: LD_INT 1
41366: PUSH
41367: EMPTY
41368: LIST
41369: LIST
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: LIST
41375: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41376: LD_ADDR_VAR 0 61
41380: PUSH
41381: LD_INT 2
41383: PUSH
41384: LD_INT 1
41386: PUSH
41387: EMPTY
41388: LIST
41389: LIST
41390: PUSH
41391: LD_INT 2
41393: PUSH
41394: LD_INT 2
41396: PUSH
41397: EMPTY
41398: LIST
41399: LIST
41400: PUSH
41401: LD_INT 1
41403: PUSH
41404: LD_INT 2
41406: PUSH
41407: EMPTY
41408: LIST
41409: LIST
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: LIST
41415: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41416: LD_ADDR_VAR 0 62
41420: PUSH
41421: LD_INT 1
41423: PUSH
41424: LD_INT 2
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: LD_INT 0
41433: PUSH
41434: LD_INT 2
41436: PUSH
41437: EMPTY
41438: LIST
41439: LIST
41440: PUSH
41441: LD_INT 1
41443: NEG
41444: PUSH
41445: LD_INT 1
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: LIST
41456: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41457: LD_ADDR_VAR 0 63
41461: PUSH
41462: LD_INT 1
41464: NEG
41465: PUSH
41466: LD_INT 1
41468: PUSH
41469: EMPTY
41470: LIST
41471: LIST
41472: PUSH
41473: LD_INT 2
41475: NEG
41476: PUSH
41477: LD_INT 0
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 2
41486: NEG
41487: PUSH
41488: LD_INT 1
41490: NEG
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: LIST
41500: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41501: LD_ADDR_VAR 0 64
41505: PUSH
41506: LD_INT 1
41508: NEG
41509: PUSH
41510: LD_INT 2
41512: NEG
41513: PUSH
41514: EMPTY
41515: LIST
41516: LIST
41517: PUSH
41518: LD_INT 2
41520: NEG
41521: PUSH
41522: LD_INT 1
41524: NEG
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 2
41532: NEG
41533: PUSH
41534: LD_INT 2
41536: NEG
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PUSH
41542: EMPTY
41543: LIST
41544: LIST
41545: LIST
41546: ST_TO_ADDR
// end ; 2 :
41547: GO 44813
41549: LD_INT 2
41551: DOUBLE
41552: EQUAL
41553: IFTRUE 41557
41555: GO 44812
41557: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41558: LD_ADDR_VAR 0 29
41562: PUSH
41563: LD_INT 4
41565: PUSH
41566: LD_INT 0
41568: PUSH
41569: EMPTY
41570: LIST
41571: LIST
41572: PUSH
41573: LD_INT 4
41575: PUSH
41576: LD_INT 1
41578: NEG
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: PUSH
41584: LD_INT 5
41586: PUSH
41587: LD_INT 0
41589: PUSH
41590: EMPTY
41591: LIST
41592: LIST
41593: PUSH
41594: LD_INT 5
41596: PUSH
41597: LD_INT 1
41599: PUSH
41600: EMPTY
41601: LIST
41602: LIST
41603: PUSH
41604: LD_INT 4
41606: PUSH
41607: LD_INT 1
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: PUSH
41614: LD_INT 3
41616: PUSH
41617: LD_INT 0
41619: PUSH
41620: EMPTY
41621: LIST
41622: LIST
41623: PUSH
41624: LD_INT 3
41626: PUSH
41627: LD_INT 1
41629: NEG
41630: PUSH
41631: EMPTY
41632: LIST
41633: LIST
41634: PUSH
41635: LD_INT 3
41637: PUSH
41638: LD_INT 2
41640: NEG
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: LD_INT 5
41648: PUSH
41649: LD_INT 2
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 3
41658: PUSH
41659: LD_INT 3
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: LD_INT 3
41668: PUSH
41669: LD_INT 2
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 4
41678: PUSH
41679: LD_INT 3
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 4
41688: PUSH
41689: LD_INT 4
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 3
41698: PUSH
41699: LD_INT 4
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 2
41708: PUSH
41709: LD_INT 3
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 2
41718: PUSH
41719: LD_INT 2
41721: PUSH
41722: EMPTY
41723: LIST
41724: LIST
41725: PUSH
41726: LD_INT 4
41728: PUSH
41729: LD_INT 2
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: PUSH
41736: LD_INT 2
41738: PUSH
41739: LD_INT 4
41741: PUSH
41742: EMPTY
41743: LIST
41744: LIST
41745: PUSH
41746: LD_INT 0
41748: PUSH
41749: LD_INT 4
41751: PUSH
41752: EMPTY
41753: LIST
41754: LIST
41755: PUSH
41756: LD_INT 0
41758: PUSH
41759: LD_INT 3
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: PUSH
41766: LD_INT 1
41768: PUSH
41769: LD_INT 4
41771: PUSH
41772: EMPTY
41773: LIST
41774: LIST
41775: PUSH
41776: LD_INT 1
41778: PUSH
41779: LD_INT 5
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: PUSH
41786: LD_INT 0
41788: PUSH
41789: LD_INT 5
41791: PUSH
41792: EMPTY
41793: LIST
41794: LIST
41795: PUSH
41796: LD_INT 1
41798: NEG
41799: PUSH
41800: LD_INT 4
41802: PUSH
41803: EMPTY
41804: LIST
41805: LIST
41806: PUSH
41807: LD_INT 1
41809: NEG
41810: PUSH
41811: LD_INT 3
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: LD_INT 2
41820: PUSH
41821: LD_INT 5
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 2
41830: NEG
41831: PUSH
41832: LD_INT 3
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 3
41841: NEG
41842: PUSH
41843: LD_INT 0
41845: PUSH
41846: EMPTY
41847: LIST
41848: LIST
41849: PUSH
41850: LD_INT 3
41852: NEG
41853: PUSH
41854: LD_INT 1
41856: NEG
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: PUSH
41862: LD_INT 2
41864: NEG
41865: PUSH
41866: LD_INT 0
41868: PUSH
41869: EMPTY
41870: LIST
41871: LIST
41872: PUSH
41873: LD_INT 2
41875: NEG
41876: PUSH
41877: LD_INT 1
41879: PUSH
41880: EMPTY
41881: LIST
41882: LIST
41883: PUSH
41884: LD_INT 3
41886: NEG
41887: PUSH
41888: LD_INT 1
41890: PUSH
41891: EMPTY
41892: LIST
41893: LIST
41894: PUSH
41895: LD_INT 4
41897: NEG
41898: PUSH
41899: LD_INT 0
41901: PUSH
41902: EMPTY
41903: LIST
41904: LIST
41905: PUSH
41906: LD_INT 4
41908: NEG
41909: PUSH
41910: LD_INT 1
41912: NEG
41913: PUSH
41914: EMPTY
41915: LIST
41916: LIST
41917: PUSH
41918: LD_INT 4
41920: NEG
41921: PUSH
41922: LD_INT 2
41924: NEG
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 2
41932: NEG
41933: PUSH
41934: LD_INT 2
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 4
41943: NEG
41944: PUSH
41945: LD_INT 4
41947: NEG
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: PUSH
41953: LD_INT 4
41955: NEG
41956: PUSH
41957: LD_INT 5
41959: NEG
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 3
41967: NEG
41968: PUSH
41969: LD_INT 4
41971: NEG
41972: PUSH
41973: EMPTY
41974: LIST
41975: LIST
41976: PUSH
41977: LD_INT 3
41979: NEG
41980: PUSH
41981: LD_INT 3
41983: NEG
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: LD_INT 4
41991: NEG
41992: PUSH
41993: LD_INT 3
41995: NEG
41996: PUSH
41997: EMPTY
41998: LIST
41999: LIST
42000: PUSH
42001: LD_INT 5
42003: NEG
42004: PUSH
42005: LD_INT 4
42007: NEG
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: LD_INT 5
42015: NEG
42016: PUSH
42017: LD_INT 5
42019: NEG
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: PUSH
42025: LD_INT 3
42027: NEG
42028: PUSH
42029: LD_INT 5
42031: NEG
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: PUSH
42037: LD_INT 5
42039: NEG
42040: PUSH
42041: LD_INT 3
42043: NEG
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: EMPTY
42050: LIST
42051: LIST
42052: LIST
42053: LIST
42054: LIST
42055: LIST
42056: LIST
42057: LIST
42058: LIST
42059: LIST
42060: LIST
42061: LIST
42062: LIST
42063: LIST
42064: LIST
42065: LIST
42066: LIST
42067: LIST
42068: LIST
42069: LIST
42070: LIST
42071: LIST
42072: LIST
42073: LIST
42074: LIST
42075: LIST
42076: LIST
42077: LIST
42078: LIST
42079: LIST
42080: LIST
42081: LIST
42082: LIST
42083: LIST
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: LIST
42091: LIST
42092: LIST
42093: LIST
42094: LIST
42095: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42096: LD_ADDR_VAR 0 30
42100: PUSH
42101: LD_INT 4
42103: PUSH
42104: LD_INT 4
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 4
42113: PUSH
42114: LD_INT 3
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 5
42123: PUSH
42124: LD_INT 4
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: LD_INT 5
42133: PUSH
42134: LD_INT 5
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 4
42143: PUSH
42144: LD_INT 5
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 3
42153: PUSH
42154: LD_INT 4
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 3
42163: PUSH
42164: LD_INT 3
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 5
42173: PUSH
42174: LD_INT 3
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 3
42183: PUSH
42184: LD_INT 5
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_INT 0
42193: PUSH
42194: LD_INT 3
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 0
42203: PUSH
42204: LD_INT 2
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 1
42213: PUSH
42214: LD_INT 3
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 1
42223: PUSH
42224: LD_INT 4
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 0
42233: PUSH
42234: LD_INT 4
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 1
42243: NEG
42244: PUSH
42245: LD_INT 3
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 1
42254: NEG
42255: PUSH
42256: LD_INT 2
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 2
42265: PUSH
42266: LD_INT 4
42268: PUSH
42269: EMPTY
42270: LIST
42271: LIST
42272: PUSH
42273: LD_INT 2
42275: NEG
42276: PUSH
42277: LD_INT 2
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: PUSH
42284: LD_INT 4
42286: NEG
42287: PUSH
42288: LD_INT 0
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: LD_INT 4
42297: NEG
42298: PUSH
42299: LD_INT 1
42301: NEG
42302: PUSH
42303: EMPTY
42304: LIST
42305: LIST
42306: PUSH
42307: LD_INT 3
42309: NEG
42310: PUSH
42311: LD_INT 0
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PUSH
42318: LD_INT 3
42320: NEG
42321: PUSH
42322: LD_INT 1
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: PUSH
42329: LD_INT 4
42331: NEG
42332: PUSH
42333: LD_INT 1
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: LD_INT 5
42342: NEG
42343: PUSH
42344: LD_INT 0
42346: PUSH
42347: EMPTY
42348: LIST
42349: LIST
42350: PUSH
42351: LD_INT 5
42353: NEG
42354: PUSH
42355: LD_INT 1
42357: NEG
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PUSH
42363: LD_INT 5
42365: NEG
42366: PUSH
42367: LD_INT 2
42369: NEG
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: PUSH
42375: LD_INT 3
42377: NEG
42378: PUSH
42379: LD_INT 2
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 3
42388: NEG
42389: PUSH
42390: LD_INT 3
42392: NEG
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: LD_INT 3
42400: NEG
42401: PUSH
42402: LD_INT 4
42404: NEG
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: PUSH
42410: LD_INT 2
42412: NEG
42413: PUSH
42414: LD_INT 3
42416: NEG
42417: PUSH
42418: EMPTY
42419: LIST
42420: LIST
42421: PUSH
42422: LD_INT 2
42424: NEG
42425: PUSH
42426: LD_INT 2
42428: NEG
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: LD_INT 3
42436: NEG
42437: PUSH
42438: LD_INT 2
42440: NEG
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: LD_INT 4
42448: NEG
42449: PUSH
42450: LD_INT 3
42452: NEG
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: LD_INT 4
42460: NEG
42461: PUSH
42462: LD_INT 4
42464: NEG
42465: PUSH
42466: EMPTY
42467: LIST
42468: LIST
42469: PUSH
42470: LD_INT 2
42472: NEG
42473: PUSH
42474: LD_INT 4
42476: NEG
42477: PUSH
42478: EMPTY
42479: LIST
42480: LIST
42481: PUSH
42482: LD_INT 4
42484: NEG
42485: PUSH
42486: LD_INT 2
42488: NEG
42489: PUSH
42490: EMPTY
42491: LIST
42492: LIST
42493: PUSH
42494: LD_INT 0
42496: PUSH
42497: LD_INT 4
42499: NEG
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 0
42507: PUSH
42508: LD_INT 5
42510: NEG
42511: PUSH
42512: EMPTY
42513: LIST
42514: LIST
42515: PUSH
42516: LD_INT 1
42518: PUSH
42519: LD_INT 4
42521: NEG
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: PUSH
42527: LD_INT 1
42529: PUSH
42530: LD_INT 3
42532: NEG
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 0
42540: PUSH
42541: LD_INT 3
42543: NEG
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 1
42551: NEG
42552: PUSH
42553: LD_INT 4
42555: NEG
42556: PUSH
42557: EMPTY
42558: LIST
42559: LIST
42560: PUSH
42561: LD_INT 1
42563: NEG
42564: PUSH
42565: LD_INT 5
42567: NEG
42568: PUSH
42569: EMPTY
42570: LIST
42571: LIST
42572: PUSH
42573: LD_INT 2
42575: PUSH
42576: LD_INT 3
42578: NEG
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: LD_INT 2
42586: NEG
42587: PUSH
42588: LD_INT 5
42590: NEG
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: PUSH
42596: EMPTY
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: LIST
42614: LIST
42615: LIST
42616: LIST
42617: LIST
42618: LIST
42619: LIST
42620: LIST
42621: LIST
42622: LIST
42623: LIST
42624: LIST
42625: LIST
42626: LIST
42627: LIST
42628: LIST
42629: LIST
42630: LIST
42631: LIST
42632: LIST
42633: LIST
42634: LIST
42635: LIST
42636: LIST
42637: LIST
42638: LIST
42639: LIST
42640: LIST
42641: LIST
42642: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
42643: LD_ADDR_VAR 0 31
42647: PUSH
42648: LD_INT 0
42650: PUSH
42651: LD_INT 4
42653: PUSH
42654: EMPTY
42655: LIST
42656: LIST
42657: PUSH
42658: LD_INT 0
42660: PUSH
42661: LD_INT 3
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PUSH
42668: LD_INT 1
42670: PUSH
42671: LD_INT 4
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PUSH
42678: LD_INT 1
42680: PUSH
42681: LD_INT 5
42683: PUSH
42684: EMPTY
42685: LIST
42686: LIST
42687: PUSH
42688: LD_INT 0
42690: PUSH
42691: LD_INT 5
42693: PUSH
42694: EMPTY
42695: LIST
42696: LIST
42697: PUSH
42698: LD_INT 1
42700: NEG
42701: PUSH
42702: LD_INT 4
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: PUSH
42709: LD_INT 1
42711: NEG
42712: PUSH
42713: LD_INT 3
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 2
42722: PUSH
42723: LD_INT 5
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 2
42732: NEG
42733: PUSH
42734: LD_INT 3
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 3
42743: NEG
42744: PUSH
42745: LD_INT 0
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: LD_INT 3
42754: NEG
42755: PUSH
42756: LD_INT 1
42758: NEG
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: LD_INT 2
42766: NEG
42767: PUSH
42768: LD_INT 0
42770: PUSH
42771: EMPTY
42772: LIST
42773: LIST
42774: PUSH
42775: LD_INT 2
42777: NEG
42778: PUSH
42779: LD_INT 1
42781: PUSH
42782: EMPTY
42783: LIST
42784: LIST
42785: PUSH
42786: LD_INT 3
42788: NEG
42789: PUSH
42790: LD_INT 1
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: PUSH
42797: LD_INT 4
42799: NEG
42800: PUSH
42801: LD_INT 0
42803: PUSH
42804: EMPTY
42805: LIST
42806: LIST
42807: PUSH
42808: LD_INT 4
42810: NEG
42811: PUSH
42812: LD_INT 1
42814: NEG
42815: PUSH
42816: EMPTY
42817: LIST
42818: LIST
42819: PUSH
42820: LD_INT 4
42822: NEG
42823: PUSH
42824: LD_INT 2
42826: NEG
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: PUSH
42832: LD_INT 2
42834: NEG
42835: PUSH
42836: LD_INT 2
42838: PUSH
42839: EMPTY
42840: LIST
42841: LIST
42842: PUSH
42843: LD_INT 4
42845: NEG
42846: PUSH
42847: LD_INT 4
42849: NEG
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 4
42857: NEG
42858: PUSH
42859: LD_INT 5
42861: NEG
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: LD_INT 3
42869: NEG
42870: PUSH
42871: LD_INT 4
42873: NEG
42874: PUSH
42875: EMPTY
42876: LIST
42877: LIST
42878: PUSH
42879: LD_INT 3
42881: NEG
42882: PUSH
42883: LD_INT 3
42885: NEG
42886: PUSH
42887: EMPTY
42888: LIST
42889: LIST
42890: PUSH
42891: LD_INT 4
42893: NEG
42894: PUSH
42895: LD_INT 3
42897: NEG
42898: PUSH
42899: EMPTY
42900: LIST
42901: LIST
42902: PUSH
42903: LD_INT 5
42905: NEG
42906: PUSH
42907: LD_INT 4
42909: NEG
42910: PUSH
42911: EMPTY
42912: LIST
42913: LIST
42914: PUSH
42915: LD_INT 5
42917: NEG
42918: PUSH
42919: LD_INT 5
42921: NEG
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: LD_INT 3
42929: NEG
42930: PUSH
42931: LD_INT 5
42933: NEG
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: PUSH
42939: LD_INT 5
42941: NEG
42942: PUSH
42943: LD_INT 3
42945: NEG
42946: PUSH
42947: EMPTY
42948: LIST
42949: LIST
42950: PUSH
42951: LD_INT 0
42953: PUSH
42954: LD_INT 3
42956: NEG
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: PUSH
42962: LD_INT 0
42964: PUSH
42965: LD_INT 4
42967: NEG
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: LD_INT 1
42975: PUSH
42976: LD_INT 3
42978: NEG
42979: PUSH
42980: EMPTY
42981: LIST
42982: LIST
42983: PUSH
42984: LD_INT 1
42986: PUSH
42987: LD_INT 2
42989: NEG
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: LD_INT 0
42997: PUSH
42998: LD_INT 2
43000: NEG
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: LD_INT 1
43008: NEG
43009: PUSH
43010: LD_INT 3
43012: NEG
43013: PUSH
43014: EMPTY
43015: LIST
43016: LIST
43017: PUSH
43018: LD_INT 1
43020: NEG
43021: PUSH
43022: LD_INT 4
43024: NEG
43025: PUSH
43026: EMPTY
43027: LIST
43028: LIST
43029: PUSH
43030: LD_INT 2
43032: PUSH
43033: LD_INT 2
43035: NEG
43036: PUSH
43037: EMPTY
43038: LIST
43039: LIST
43040: PUSH
43041: LD_INT 2
43043: NEG
43044: PUSH
43045: LD_INT 4
43047: NEG
43048: PUSH
43049: EMPTY
43050: LIST
43051: LIST
43052: PUSH
43053: LD_INT 4
43055: PUSH
43056: LD_INT 0
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: LD_INT 4
43065: PUSH
43066: LD_INT 1
43068: NEG
43069: PUSH
43070: EMPTY
43071: LIST
43072: LIST
43073: PUSH
43074: LD_INT 5
43076: PUSH
43077: LD_INT 0
43079: PUSH
43080: EMPTY
43081: LIST
43082: LIST
43083: PUSH
43084: LD_INT 5
43086: PUSH
43087: LD_INT 1
43089: PUSH
43090: EMPTY
43091: LIST
43092: LIST
43093: PUSH
43094: LD_INT 4
43096: PUSH
43097: LD_INT 1
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PUSH
43104: LD_INT 3
43106: PUSH
43107: LD_INT 0
43109: PUSH
43110: EMPTY
43111: LIST
43112: LIST
43113: PUSH
43114: LD_INT 3
43116: PUSH
43117: LD_INT 1
43119: NEG
43120: PUSH
43121: EMPTY
43122: LIST
43123: LIST
43124: PUSH
43125: LD_INT 3
43127: PUSH
43128: LD_INT 2
43130: NEG
43131: PUSH
43132: EMPTY
43133: LIST
43134: LIST
43135: PUSH
43136: LD_INT 5
43138: PUSH
43139: LD_INT 2
43141: PUSH
43142: EMPTY
43143: LIST
43144: LIST
43145: PUSH
43146: EMPTY
43147: LIST
43148: LIST
43149: LIST
43150: LIST
43151: LIST
43152: LIST
43153: LIST
43154: LIST
43155: LIST
43156: LIST
43157: LIST
43158: LIST
43159: LIST
43160: LIST
43161: LIST
43162: LIST
43163: LIST
43164: LIST
43165: LIST
43166: LIST
43167: LIST
43168: LIST
43169: LIST
43170: LIST
43171: LIST
43172: LIST
43173: LIST
43174: LIST
43175: LIST
43176: LIST
43177: LIST
43178: LIST
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: LIST
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: LIST
43190: LIST
43191: LIST
43192: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43193: LD_ADDR_VAR 0 32
43197: PUSH
43198: LD_INT 4
43200: NEG
43201: PUSH
43202: LD_INT 0
43204: PUSH
43205: EMPTY
43206: LIST
43207: LIST
43208: PUSH
43209: LD_INT 4
43211: NEG
43212: PUSH
43213: LD_INT 1
43215: NEG
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: LD_INT 3
43223: NEG
43224: PUSH
43225: LD_INT 0
43227: PUSH
43228: EMPTY
43229: LIST
43230: LIST
43231: PUSH
43232: LD_INT 3
43234: NEG
43235: PUSH
43236: LD_INT 1
43238: PUSH
43239: EMPTY
43240: LIST
43241: LIST
43242: PUSH
43243: LD_INT 4
43245: NEG
43246: PUSH
43247: LD_INT 1
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: PUSH
43254: LD_INT 5
43256: NEG
43257: PUSH
43258: LD_INT 0
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: PUSH
43265: LD_INT 5
43267: NEG
43268: PUSH
43269: LD_INT 1
43271: NEG
43272: PUSH
43273: EMPTY
43274: LIST
43275: LIST
43276: PUSH
43277: LD_INT 5
43279: NEG
43280: PUSH
43281: LD_INT 2
43283: NEG
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 3
43291: NEG
43292: PUSH
43293: LD_INT 2
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 3
43302: NEG
43303: PUSH
43304: LD_INT 3
43306: NEG
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: PUSH
43312: LD_INT 3
43314: NEG
43315: PUSH
43316: LD_INT 4
43318: NEG
43319: PUSH
43320: EMPTY
43321: LIST
43322: LIST
43323: PUSH
43324: LD_INT 2
43326: NEG
43327: PUSH
43328: LD_INT 3
43330: NEG
43331: PUSH
43332: EMPTY
43333: LIST
43334: LIST
43335: PUSH
43336: LD_INT 2
43338: NEG
43339: PUSH
43340: LD_INT 2
43342: NEG
43343: PUSH
43344: EMPTY
43345: LIST
43346: LIST
43347: PUSH
43348: LD_INT 3
43350: NEG
43351: PUSH
43352: LD_INT 2
43354: NEG
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 4
43362: NEG
43363: PUSH
43364: LD_INT 3
43366: NEG
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 4
43374: NEG
43375: PUSH
43376: LD_INT 4
43378: NEG
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 2
43386: NEG
43387: PUSH
43388: LD_INT 4
43390: NEG
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: PUSH
43396: LD_INT 4
43398: NEG
43399: PUSH
43400: LD_INT 2
43402: NEG
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: PUSH
43408: LD_INT 0
43410: PUSH
43411: LD_INT 4
43413: NEG
43414: PUSH
43415: EMPTY
43416: LIST
43417: LIST
43418: PUSH
43419: LD_INT 0
43421: PUSH
43422: LD_INT 5
43424: NEG
43425: PUSH
43426: EMPTY
43427: LIST
43428: LIST
43429: PUSH
43430: LD_INT 1
43432: PUSH
43433: LD_INT 4
43435: NEG
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: PUSH
43441: LD_INT 1
43443: PUSH
43444: LD_INT 3
43446: NEG
43447: PUSH
43448: EMPTY
43449: LIST
43450: LIST
43451: PUSH
43452: LD_INT 0
43454: PUSH
43455: LD_INT 3
43457: NEG
43458: PUSH
43459: EMPTY
43460: LIST
43461: LIST
43462: PUSH
43463: LD_INT 1
43465: NEG
43466: PUSH
43467: LD_INT 4
43469: NEG
43470: PUSH
43471: EMPTY
43472: LIST
43473: LIST
43474: PUSH
43475: LD_INT 1
43477: NEG
43478: PUSH
43479: LD_INT 5
43481: NEG
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 2
43489: PUSH
43490: LD_INT 3
43492: NEG
43493: PUSH
43494: EMPTY
43495: LIST
43496: LIST
43497: PUSH
43498: LD_INT 2
43500: NEG
43501: PUSH
43502: LD_INT 5
43504: NEG
43505: PUSH
43506: EMPTY
43507: LIST
43508: LIST
43509: PUSH
43510: LD_INT 3
43512: PUSH
43513: LD_INT 0
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: PUSH
43520: LD_INT 3
43522: PUSH
43523: LD_INT 1
43525: NEG
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: PUSH
43531: LD_INT 4
43533: PUSH
43534: LD_INT 0
43536: PUSH
43537: EMPTY
43538: LIST
43539: LIST
43540: PUSH
43541: LD_INT 4
43543: PUSH
43544: LD_INT 1
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 3
43553: PUSH
43554: LD_INT 1
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: LD_INT 2
43563: PUSH
43564: LD_INT 0
43566: PUSH
43567: EMPTY
43568: LIST
43569: LIST
43570: PUSH
43571: LD_INT 2
43573: PUSH
43574: LD_INT 1
43576: NEG
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: PUSH
43582: LD_INT 2
43584: PUSH
43585: LD_INT 2
43587: NEG
43588: PUSH
43589: EMPTY
43590: LIST
43591: LIST
43592: PUSH
43593: LD_INT 4
43595: PUSH
43596: LD_INT 2
43598: PUSH
43599: EMPTY
43600: LIST
43601: LIST
43602: PUSH
43603: LD_INT 4
43605: PUSH
43606: LD_INT 4
43608: PUSH
43609: EMPTY
43610: LIST
43611: LIST
43612: PUSH
43613: LD_INT 4
43615: PUSH
43616: LD_INT 3
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: LD_INT 5
43625: PUSH
43626: LD_INT 4
43628: PUSH
43629: EMPTY
43630: LIST
43631: LIST
43632: PUSH
43633: LD_INT 5
43635: PUSH
43636: LD_INT 5
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: PUSH
43643: LD_INT 4
43645: PUSH
43646: LD_INT 5
43648: PUSH
43649: EMPTY
43650: LIST
43651: LIST
43652: PUSH
43653: LD_INT 3
43655: PUSH
43656: LD_INT 4
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 3
43665: PUSH
43666: LD_INT 3
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 5
43675: PUSH
43676: LD_INT 3
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: PUSH
43683: LD_INT 3
43685: PUSH
43686: LD_INT 5
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: EMPTY
43694: LIST
43695: LIST
43696: LIST
43697: LIST
43698: LIST
43699: LIST
43700: LIST
43701: LIST
43702: LIST
43703: LIST
43704: LIST
43705: LIST
43706: LIST
43707: LIST
43708: LIST
43709: LIST
43710: LIST
43711: LIST
43712: LIST
43713: LIST
43714: LIST
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: LIST
43729: LIST
43730: LIST
43731: LIST
43732: LIST
43733: LIST
43734: LIST
43735: LIST
43736: LIST
43737: LIST
43738: LIST
43739: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
43740: LD_ADDR_VAR 0 33
43744: PUSH
43745: LD_INT 4
43747: NEG
43748: PUSH
43749: LD_INT 4
43751: NEG
43752: PUSH
43753: EMPTY
43754: LIST
43755: LIST
43756: PUSH
43757: LD_INT 4
43759: NEG
43760: PUSH
43761: LD_INT 5
43763: NEG
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: LD_INT 3
43771: NEG
43772: PUSH
43773: LD_INT 4
43775: NEG
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: LD_INT 3
43783: NEG
43784: PUSH
43785: LD_INT 3
43787: NEG
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 4
43795: NEG
43796: PUSH
43797: LD_INT 3
43799: NEG
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: LD_INT 5
43807: NEG
43808: PUSH
43809: LD_INT 4
43811: NEG
43812: PUSH
43813: EMPTY
43814: LIST
43815: LIST
43816: PUSH
43817: LD_INT 5
43819: NEG
43820: PUSH
43821: LD_INT 5
43823: NEG
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: PUSH
43829: LD_INT 3
43831: NEG
43832: PUSH
43833: LD_INT 5
43835: NEG
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: PUSH
43841: LD_INT 5
43843: NEG
43844: PUSH
43845: LD_INT 3
43847: NEG
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PUSH
43853: LD_INT 0
43855: PUSH
43856: LD_INT 3
43858: NEG
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: PUSH
43864: LD_INT 0
43866: PUSH
43867: LD_INT 4
43869: NEG
43870: PUSH
43871: EMPTY
43872: LIST
43873: LIST
43874: PUSH
43875: LD_INT 1
43877: PUSH
43878: LD_INT 3
43880: NEG
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: PUSH
43886: LD_INT 1
43888: PUSH
43889: LD_INT 2
43891: NEG
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 0
43899: PUSH
43900: LD_INT 2
43902: NEG
43903: PUSH
43904: EMPTY
43905: LIST
43906: LIST
43907: PUSH
43908: LD_INT 1
43910: NEG
43911: PUSH
43912: LD_INT 3
43914: NEG
43915: PUSH
43916: EMPTY
43917: LIST
43918: LIST
43919: PUSH
43920: LD_INT 1
43922: NEG
43923: PUSH
43924: LD_INT 4
43926: NEG
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: PUSH
43932: LD_INT 2
43934: PUSH
43935: LD_INT 2
43937: NEG
43938: PUSH
43939: EMPTY
43940: LIST
43941: LIST
43942: PUSH
43943: LD_INT 2
43945: NEG
43946: PUSH
43947: LD_INT 4
43949: NEG
43950: PUSH
43951: EMPTY
43952: LIST
43953: LIST
43954: PUSH
43955: LD_INT 4
43957: PUSH
43958: LD_INT 0
43960: PUSH
43961: EMPTY
43962: LIST
43963: LIST
43964: PUSH
43965: LD_INT 4
43967: PUSH
43968: LD_INT 1
43970: NEG
43971: PUSH
43972: EMPTY
43973: LIST
43974: LIST
43975: PUSH
43976: LD_INT 5
43978: PUSH
43979: LD_INT 0
43981: PUSH
43982: EMPTY
43983: LIST
43984: LIST
43985: PUSH
43986: LD_INT 5
43988: PUSH
43989: LD_INT 1
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: PUSH
43996: LD_INT 4
43998: PUSH
43999: LD_INT 1
44001: PUSH
44002: EMPTY
44003: LIST
44004: LIST
44005: PUSH
44006: LD_INT 3
44008: PUSH
44009: LD_INT 0
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: PUSH
44016: LD_INT 3
44018: PUSH
44019: LD_INT 1
44021: NEG
44022: PUSH
44023: EMPTY
44024: LIST
44025: LIST
44026: PUSH
44027: LD_INT 3
44029: PUSH
44030: LD_INT 2
44032: NEG
44033: PUSH
44034: EMPTY
44035: LIST
44036: LIST
44037: PUSH
44038: LD_INT 5
44040: PUSH
44041: LD_INT 2
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 3
44050: PUSH
44051: LD_INT 3
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 3
44060: PUSH
44061: LD_INT 2
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: LD_INT 4
44070: PUSH
44071: LD_INT 3
44073: PUSH
44074: EMPTY
44075: LIST
44076: LIST
44077: PUSH
44078: LD_INT 4
44080: PUSH
44081: LD_INT 4
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PUSH
44088: LD_INT 3
44090: PUSH
44091: LD_INT 4
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 2
44100: PUSH
44101: LD_INT 3
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: LD_INT 2
44110: PUSH
44111: LD_INT 2
44113: PUSH
44114: EMPTY
44115: LIST
44116: LIST
44117: PUSH
44118: LD_INT 4
44120: PUSH
44121: LD_INT 2
44123: PUSH
44124: EMPTY
44125: LIST
44126: LIST
44127: PUSH
44128: LD_INT 2
44130: PUSH
44131: LD_INT 4
44133: PUSH
44134: EMPTY
44135: LIST
44136: LIST
44137: PUSH
44138: LD_INT 0
44140: PUSH
44141: LD_INT 4
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: LD_INT 0
44150: PUSH
44151: LD_INT 3
44153: PUSH
44154: EMPTY
44155: LIST
44156: LIST
44157: PUSH
44158: LD_INT 1
44160: PUSH
44161: LD_INT 4
44163: PUSH
44164: EMPTY
44165: LIST
44166: LIST
44167: PUSH
44168: LD_INT 1
44170: PUSH
44171: LD_INT 5
44173: PUSH
44174: EMPTY
44175: LIST
44176: LIST
44177: PUSH
44178: LD_INT 0
44180: PUSH
44181: LD_INT 5
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PUSH
44188: LD_INT 1
44190: NEG
44191: PUSH
44192: LD_INT 4
44194: PUSH
44195: EMPTY
44196: LIST
44197: LIST
44198: PUSH
44199: LD_INT 1
44201: NEG
44202: PUSH
44203: LD_INT 3
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 2
44212: PUSH
44213: LD_INT 5
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 2
44222: NEG
44223: PUSH
44224: LD_INT 3
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: LIST
44235: LIST
44236: LIST
44237: LIST
44238: LIST
44239: LIST
44240: LIST
44241: LIST
44242: LIST
44243: LIST
44244: LIST
44245: LIST
44246: LIST
44247: LIST
44248: LIST
44249: LIST
44250: LIST
44251: LIST
44252: LIST
44253: LIST
44254: LIST
44255: LIST
44256: LIST
44257: LIST
44258: LIST
44259: LIST
44260: LIST
44261: LIST
44262: LIST
44263: LIST
44264: LIST
44265: LIST
44266: LIST
44267: LIST
44268: LIST
44269: LIST
44270: LIST
44271: LIST
44272: LIST
44273: LIST
44274: LIST
44275: LIST
44276: LIST
44277: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44278: LD_ADDR_VAR 0 34
44282: PUSH
44283: LD_INT 0
44285: PUSH
44286: LD_INT 4
44288: NEG
44289: PUSH
44290: EMPTY
44291: LIST
44292: LIST
44293: PUSH
44294: LD_INT 0
44296: PUSH
44297: LD_INT 5
44299: NEG
44300: PUSH
44301: EMPTY
44302: LIST
44303: LIST
44304: PUSH
44305: LD_INT 1
44307: PUSH
44308: LD_INT 4
44310: NEG
44311: PUSH
44312: EMPTY
44313: LIST
44314: LIST
44315: PUSH
44316: LD_INT 1
44318: PUSH
44319: LD_INT 3
44321: NEG
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: PUSH
44327: LD_INT 0
44329: PUSH
44330: LD_INT 3
44332: NEG
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: LD_INT 1
44340: NEG
44341: PUSH
44342: LD_INT 4
44344: NEG
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: LD_INT 1
44352: NEG
44353: PUSH
44354: LD_INT 5
44356: NEG
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: LD_INT 2
44364: PUSH
44365: LD_INT 3
44367: NEG
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 2
44375: NEG
44376: PUSH
44377: LD_INT 5
44379: NEG
44380: PUSH
44381: EMPTY
44382: LIST
44383: LIST
44384: PUSH
44385: LD_INT 3
44387: PUSH
44388: LD_INT 0
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: PUSH
44395: LD_INT 3
44397: PUSH
44398: LD_INT 1
44400: NEG
44401: PUSH
44402: EMPTY
44403: LIST
44404: LIST
44405: PUSH
44406: LD_INT 4
44408: PUSH
44409: LD_INT 0
44411: PUSH
44412: EMPTY
44413: LIST
44414: LIST
44415: PUSH
44416: LD_INT 4
44418: PUSH
44419: LD_INT 1
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: PUSH
44426: LD_INT 3
44428: PUSH
44429: LD_INT 1
44431: PUSH
44432: EMPTY
44433: LIST
44434: LIST
44435: PUSH
44436: LD_INT 2
44438: PUSH
44439: LD_INT 0
44441: PUSH
44442: EMPTY
44443: LIST
44444: LIST
44445: PUSH
44446: LD_INT 2
44448: PUSH
44449: LD_INT 1
44451: NEG
44452: PUSH
44453: EMPTY
44454: LIST
44455: LIST
44456: PUSH
44457: LD_INT 2
44459: PUSH
44460: LD_INT 2
44462: NEG
44463: PUSH
44464: EMPTY
44465: LIST
44466: LIST
44467: PUSH
44468: LD_INT 4
44470: PUSH
44471: LD_INT 2
44473: PUSH
44474: EMPTY
44475: LIST
44476: LIST
44477: PUSH
44478: LD_INT 4
44480: PUSH
44481: LD_INT 4
44483: PUSH
44484: EMPTY
44485: LIST
44486: LIST
44487: PUSH
44488: LD_INT 4
44490: PUSH
44491: LD_INT 3
44493: PUSH
44494: EMPTY
44495: LIST
44496: LIST
44497: PUSH
44498: LD_INT 5
44500: PUSH
44501: LD_INT 4
44503: PUSH
44504: EMPTY
44505: LIST
44506: LIST
44507: PUSH
44508: LD_INT 5
44510: PUSH
44511: LD_INT 5
44513: PUSH
44514: EMPTY
44515: LIST
44516: LIST
44517: PUSH
44518: LD_INT 4
44520: PUSH
44521: LD_INT 5
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: PUSH
44528: LD_INT 3
44530: PUSH
44531: LD_INT 4
44533: PUSH
44534: EMPTY
44535: LIST
44536: LIST
44537: PUSH
44538: LD_INT 3
44540: PUSH
44541: LD_INT 3
44543: PUSH
44544: EMPTY
44545: LIST
44546: LIST
44547: PUSH
44548: LD_INT 5
44550: PUSH
44551: LD_INT 3
44553: PUSH
44554: EMPTY
44555: LIST
44556: LIST
44557: PUSH
44558: LD_INT 3
44560: PUSH
44561: LD_INT 5
44563: PUSH
44564: EMPTY
44565: LIST
44566: LIST
44567: PUSH
44568: LD_INT 0
44570: PUSH
44571: LD_INT 3
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: PUSH
44578: LD_INT 0
44580: PUSH
44581: LD_INT 2
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: LD_INT 1
44590: PUSH
44591: LD_INT 3
44593: PUSH
44594: EMPTY
44595: LIST
44596: LIST
44597: PUSH
44598: LD_INT 1
44600: PUSH
44601: LD_INT 4
44603: PUSH
44604: EMPTY
44605: LIST
44606: LIST
44607: PUSH
44608: LD_INT 0
44610: PUSH
44611: LD_INT 4
44613: PUSH
44614: EMPTY
44615: LIST
44616: LIST
44617: PUSH
44618: LD_INT 1
44620: NEG
44621: PUSH
44622: LD_INT 3
44624: PUSH
44625: EMPTY
44626: LIST
44627: LIST
44628: PUSH
44629: LD_INT 1
44631: NEG
44632: PUSH
44633: LD_INT 2
44635: PUSH
44636: EMPTY
44637: LIST
44638: LIST
44639: PUSH
44640: LD_INT 2
44642: PUSH
44643: LD_INT 4
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: PUSH
44650: LD_INT 2
44652: NEG
44653: PUSH
44654: LD_INT 2
44656: PUSH
44657: EMPTY
44658: LIST
44659: LIST
44660: PUSH
44661: LD_INT 4
44663: NEG
44664: PUSH
44665: LD_INT 0
44667: PUSH
44668: EMPTY
44669: LIST
44670: LIST
44671: PUSH
44672: LD_INT 4
44674: NEG
44675: PUSH
44676: LD_INT 1
44678: NEG
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PUSH
44684: LD_INT 3
44686: NEG
44687: PUSH
44688: LD_INT 0
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PUSH
44695: LD_INT 3
44697: NEG
44698: PUSH
44699: LD_INT 1
44701: PUSH
44702: EMPTY
44703: LIST
44704: LIST
44705: PUSH
44706: LD_INT 4
44708: NEG
44709: PUSH
44710: LD_INT 1
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: PUSH
44717: LD_INT 5
44719: NEG
44720: PUSH
44721: LD_INT 0
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: LD_INT 5
44730: NEG
44731: PUSH
44732: LD_INT 1
44734: NEG
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PUSH
44740: LD_INT 5
44742: NEG
44743: PUSH
44744: LD_INT 2
44746: NEG
44747: PUSH
44748: EMPTY
44749: LIST
44750: LIST
44751: PUSH
44752: LD_INT 3
44754: NEG
44755: PUSH
44756: LD_INT 2
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: PUSH
44763: EMPTY
44764: LIST
44765: LIST
44766: LIST
44767: LIST
44768: LIST
44769: LIST
44770: LIST
44771: LIST
44772: LIST
44773: LIST
44774: LIST
44775: LIST
44776: LIST
44777: LIST
44778: LIST
44779: LIST
44780: LIST
44781: LIST
44782: LIST
44783: LIST
44784: LIST
44785: LIST
44786: LIST
44787: LIST
44788: LIST
44789: LIST
44790: LIST
44791: LIST
44792: LIST
44793: LIST
44794: LIST
44795: LIST
44796: LIST
44797: LIST
44798: LIST
44799: LIST
44800: LIST
44801: LIST
44802: LIST
44803: LIST
44804: LIST
44805: LIST
44806: LIST
44807: LIST
44808: LIST
44809: ST_TO_ADDR
// end ; end ;
44810: GO 44813
44812: POP
// case btype of b_depot , b_warehouse :
44813: LD_VAR 0 1
44817: PUSH
44818: LD_INT 0
44820: DOUBLE
44821: EQUAL
44822: IFTRUE 44832
44824: LD_INT 1
44826: DOUBLE
44827: EQUAL
44828: IFTRUE 44832
44830: GO 45033
44832: POP
// case nation of nation_american :
44833: LD_VAR 0 5
44837: PUSH
44838: LD_INT 1
44840: DOUBLE
44841: EQUAL
44842: IFTRUE 44846
44844: GO 44902
44846: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
44847: LD_ADDR_VAR 0 9
44851: PUSH
44852: LD_VAR 0 11
44856: PUSH
44857: LD_VAR 0 12
44861: PUSH
44862: LD_VAR 0 13
44866: PUSH
44867: LD_VAR 0 14
44871: PUSH
44872: LD_VAR 0 15
44876: PUSH
44877: LD_VAR 0 16
44881: PUSH
44882: EMPTY
44883: LIST
44884: LIST
44885: LIST
44886: LIST
44887: LIST
44888: LIST
44889: PUSH
44890: LD_VAR 0 4
44894: PUSH
44895: LD_INT 1
44897: PLUS
44898: ARRAY
44899: ST_TO_ADDR
44900: GO 45031
44902: LD_INT 2
44904: DOUBLE
44905: EQUAL
44906: IFTRUE 44910
44908: GO 44966
44910: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
44911: LD_ADDR_VAR 0 9
44915: PUSH
44916: LD_VAR 0 17
44920: PUSH
44921: LD_VAR 0 18
44925: PUSH
44926: LD_VAR 0 19
44930: PUSH
44931: LD_VAR 0 20
44935: PUSH
44936: LD_VAR 0 21
44940: PUSH
44941: LD_VAR 0 22
44945: PUSH
44946: EMPTY
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: LIST
44953: PUSH
44954: LD_VAR 0 4
44958: PUSH
44959: LD_INT 1
44961: PLUS
44962: ARRAY
44963: ST_TO_ADDR
44964: GO 45031
44966: LD_INT 3
44968: DOUBLE
44969: EQUAL
44970: IFTRUE 44974
44972: GO 45030
44974: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
44975: LD_ADDR_VAR 0 9
44979: PUSH
44980: LD_VAR 0 23
44984: PUSH
44985: LD_VAR 0 24
44989: PUSH
44990: LD_VAR 0 25
44994: PUSH
44995: LD_VAR 0 26
44999: PUSH
45000: LD_VAR 0 27
45004: PUSH
45005: LD_VAR 0 28
45009: PUSH
45010: EMPTY
45011: LIST
45012: LIST
45013: LIST
45014: LIST
45015: LIST
45016: LIST
45017: PUSH
45018: LD_VAR 0 4
45022: PUSH
45023: LD_INT 1
45025: PLUS
45026: ARRAY
45027: ST_TO_ADDR
45028: GO 45031
45030: POP
45031: GO 45586
45033: LD_INT 2
45035: DOUBLE
45036: EQUAL
45037: IFTRUE 45047
45039: LD_INT 3
45041: DOUBLE
45042: EQUAL
45043: IFTRUE 45047
45045: GO 45103
45047: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45048: LD_ADDR_VAR 0 9
45052: PUSH
45053: LD_VAR 0 29
45057: PUSH
45058: LD_VAR 0 30
45062: PUSH
45063: LD_VAR 0 31
45067: PUSH
45068: LD_VAR 0 32
45072: PUSH
45073: LD_VAR 0 33
45077: PUSH
45078: LD_VAR 0 34
45082: PUSH
45083: EMPTY
45084: LIST
45085: LIST
45086: LIST
45087: LIST
45088: LIST
45089: LIST
45090: PUSH
45091: LD_VAR 0 4
45095: PUSH
45096: LD_INT 1
45098: PLUS
45099: ARRAY
45100: ST_TO_ADDR
45101: GO 45586
45103: LD_INT 16
45105: DOUBLE
45106: EQUAL
45107: IFTRUE 45165
45109: LD_INT 17
45111: DOUBLE
45112: EQUAL
45113: IFTRUE 45165
45115: LD_INT 18
45117: DOUBLE
45118: EQUAL
45119: IFTRUE 45165
45121: LD_INT 19
45123: DOUBLE
45124: EQUAL
45125: IFTRUE 45165
45127: LD_INT 22
45129: DOUBLE
45130: EQUAL
45131: IFTRUE 45165
45133: LD_INT 20
45135: DOUBLE
45136: EQUAL
45137: IFTRUE 45165
45139: LD_INT 21
45141: DOUBLE
45142: EQUAL
45143: IFTRUE 45165
45145: LD_INT 23
45147: DOUBLE
45148: EQUAL
45149: IFTRUE 45165
45151: LD_INT 24
45153: DOUBLE
45154: EQUAL
45155: IFTRUE 45165
45157: LD_INT 25
45159: DOUBLE
45160: EQUAL
45161: IFTRUE 45165
45163: GO 45221
45165: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45166: LD_ADDR_VAR 0 9
45170: PUSH
45171: LD_VAR 0 35
45175: PUSH
45176: LD_VAR 0 36
45180: PUSH
45181: LD_VAR 0 37
45185: PUSH
45186: LD_VAR 0 38
45190: PUSH
45191: LD_VAR 0 39
45195: PUSH
45196: LD_VAR 0 40
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: PUSH
45209: LD_VAR 0 4
45213: PUSH
45214: LD_INT 1
45216: PLUS
45217: ARRAY
45218: ST_TO_ADDR
45219: GO 45586
45221: LD_INT 6
45223: DOUBLE
45224: EQUAL
45225: IFTRUE 45277
45227: LD_INT 7
45229: DOUBLE
45230: EQUAL
45231: IFTRUE 45277
45233: LD_INT 8
45235: DOUBLE
45236: EQUAL
45237: IFTRUE 45277
45239: LD_INT 13
45241: DOUBLE
45242: EQUAL
45243: IFTRUE 45277
45245: LD_INT 12
45247: DOUBLE
45248: EQUAL
45249: IFTRUE 45277
45251: LD_INT 15
45253: DOUBLE
45254: EQUAL
45255: IFTRUE 45277
45257: LD_INT 11
45259: DOUBLE
45260: EQUAL
45261: IFTRUE 45277
45263: LD_INT 14
45265: DOUBLE
45266: EQUAL
45267: IFTRUE 45277
45269: LD_INT 10
45271: DOUBLE
45272: EQUAL
45273: IFTRUE 45277
45275: GO 45333
45277: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
45278: LD_ADDR_VAR 0 9
45282: PUSH
45283: LD_VAR 0 41
45287: PUSH
45288: LD_VAR 0 42
45292: PUSH
45293: LD_VAR 0 43
45297: PUSH
45298: LD_VAR 0 44
45302: PUSH
45303: LD_VAR 0 45
45307: PUSH
45308: LD_VAR 0 46
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: LIST
45317: LIST
45318: LIST
45319: LIST
45320: PUSH
45321: LD_VAR 0 4
45325: PUSH
45326: LD_INT 1
45328: PLUS
45329: ARRAY
45330: ST_TO_ADDR
45331: GO 45586
45333: LD_INT 36
45335: DOUBLE
45336: EQUAL
45337: IFTRUE 45341
45339: GO 45397
45341: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45342: LD_ADDR_VAR 0 9
45346: PUSH
45347: LD_VAR 0 47
45351: PUSH
45352: LD_VAR 0 48
45356: PUSH
45357: LD_VAR 0 49
45361: PUSH
45362: LD_VAR 0 50
45366: PUSH
45367: LD_VAR 0 51
45371: PUSH
45372: LD_VAR 0 52
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: LIST
45381: LIST
45382: LIST
45383: LIST
45384: PUSH
45385: LD_VAR 0 4
45389: PUSH
45390: LD_INT 1
45392: PLUS
45393: ARRAY
45394: ST_TO_ADDR
45395: GO 45586
45397: LD_INT 4
45399: DOUBLE
45400: EQUAL
45401: IFTRUE 45423
45403: LD_INT 5
45405: DOUBLE
45406: EQUAL
45407: IFTRUE 45423
45409: LD_INT 34
45411: DOUBLE
45412: EQUAL
45413: IFTRUE 45423
45415: LD_INT 37
45417: DOUBLE
45418: EQUAL
45419: IFTRUE 45423
45421: GO 45479
45423: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45424: LD_ADDR_VAR 0 9
45428: PUSH
45429: LD_VAR 0 53
45433: PUSH
45434: LD_VAR 0 54
45438: PUSH
45439: LD_VAR 0 55
45443: PUSH
45444: LD_VAR 0 56
45448: PUSH
45449: LD_VAR 0 57
45453: PUSH
45454: LD_VAR 0 58
45458: PUSH
45459: EMPTY
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: PUSH
45467: LD_VAR 0 4
45471: PUSH
45472: LD_INT 1
45474: PLUS
45475: ARRAY
45476: ST_TO_ADDR
45477: GO 45586
45479: LD_INT 31
45481: DOUBLE
45482: EQUAL
45483: IFTRUE 45529
45485: LD_INT 32
45487: DOUBLE
45488: EQUAL
45489: IFTRUE 45529
45491: LD_INT 33
45493: DOUBLE
45494: EQUAL
45495: IFTRUE 45529
45497: LD_INT 27
45499: DOUBLE
45500: EQUAL
45501: IFTRUE 45529
45503: LD_INT 26
45505: DOUBLE
45506: EQUAL
45507: IFTRUE 45529
45509: LD_INT 28
45511: DOUBLE
45512: EQUAL
45513: IFTRUE 45529
45515: LD_INT 29
45517: DOUBLE
45518: EQUAL
45519: IFTRUE 45529
45521: LD_INT 30
45523: DOUBLE
45524: EQUAL
45525: IFTRUE 45529
45527: GO 45585
45529: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
45530: LD_ADDR_VAR 0 9
45534: PUSH
45535: LD_VAR 0 59
45539: PUSH
45540: LD_VAR 0 60
45544: PUSH
45545: LD_VAR 0 61
45549: PUSH
45550: LD_VAR 0 62
45554: PUSH
45555: LD_VAR 0 63
45559: PUSH
45560: LD_VAR 0 64
45564: PUSH
45565: EMPTY
45566: LIST
45567: LIST
45568: LIST
45569: LIST
45570: LIST
45571: LIST
45572: PUSH
45573: LD_VAR 0 4
45577: PUSH
45578: LD_INT 1
45580: PLUS
45581: ARRAY
45582: ST_TO_ADDR
45583: GO 45586
45585: POP
// temp_list2 = [ ] ;
45586: LD_ADDR_VAR 0 10
45590: PUSH
45591: EMPTY
45592: ST_TO_ADDR
// for i in temp_list do
45593: LD_ADDR_VAR 0 8
45597: PUSH
45598: LD_VAR 0 9
45602: PUSH
45603: FOR_IN
45604: IFFALSE 45656
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
45606: LD_ADDR_VAR 0 10
45610: PUSH
45611: LD_VAR 0 10
45615: PUSH
45616: LD_VAR 0 8
45620: PUSH
45621: LD_INT 1
45623: ARRAY
45624: PUSH
45625: LD_VAR 0 2
45629: PLUS
45630: PUSH
45631: LD_VAR 0 8
45635: PUSH
45636: LD_INT 2
45638: ARRAY
45639: PUSH
45640: LD_VAR 0 3
45644: PLUS
45645: PUSH
45646: EMPTY
45647: LIST
45648: LIST
45649: PUSH
45650: EMPTY
45651: LIST
45652: ADD
45653: ST_TO_ADDR
45654: GO 45603
45656: POP
45657: POP
// result = temp_list2 ;
45658: LD_ADDR_VAR 0 7
45662: PUSH
45663: LD_VAR 0 10
45667: ST_TO_ADDR
// end ;
45668: LD_VAR 0 7
45672: RET
// export function EnemyInRange ( unit , dist ) ; begin
45673: LD_INT 0
45675: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
45676: LD_ADDR_VAR 0 3
45680: PUSH
45681: LD_VAR 0 1
45685: PPUSH
45686: CALL_OW 255
45690: PPUSH
45691: LD_VAR 0 1
45695: PPUSH
45696: CALL_OW 250
45700: PPUSH
45701: LD_VAR 0 1
45705: PPUSH
45706: CALL_OW 251
45710: PPUSH
45711: LD_VAR 0 2
45715: PPUSH
45716: CALL 19444 0 4
45720: PUSH
45721: LD_INT 4
45723: ARRAY
45724: ST_TO_ADDR
// end ;
45725: LD_VAR 0 3
45729: RET
// export function PlayerSeeMe ( unit ) ; begin
45730: LD_INT 0
45732: PPUSH
// result := See ( your_side , unit ) ;
45733: LD_ADDR_VAR 0 2
45737: PUSH
45738: LD_OWVAR 2
45742: PPUSH
45743: LD_VAR 0 1
45747: PPUSH
45748: CALL_OW 292
45752: ST_TO_ADDR
// end ;
45753: LD_VAR 0 2
45757: RET
// export function ReverseDir ( unit ) ; begin
45758: LD_INT 0
45760: PPUSH
// if not unit then
45761: LD_VAR 0 1
45765: NOT
45766: IFFALSE 45770
// exit ;
45768: GO 45793
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
45770: LD_ADDR_VAR 0 2
45774: PUSH
45775: LD_VAR 0 1
45779: PPUSH
45780: CALL_OW 254
45784: PUSH
45785: LD_INT 3
45787: PLUS
45788: PUSH
45789: LD_INT 6
45791: MOD
45792: ST_TO_ADDR
// end ;
45793: LD_VAR 0 2
45797: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
45798: LD_INT 0
45800: PPUSH
45801: PPUSH
45802: PPUSH
45803: PPUSH
45804: PPUSH
// if not hexes then
45805: LD_VAR 0 2
45809: NOT
45810: IFFALSE 45814
// exit ;
45812: GO 45962
// dist := 9999 ;
45814: LD_ADDR_VAR 0 5
45818: PUSH
45819: LD_INT 9999
45821: ST_TO_ADDR
// for i = 1 to hexes do
45822: LD_ADDR_VAR 0 4
45826: PUSH
45827: DOUBLE
45828: LD_INT 1
45830: DEC
45831: ST_TO_ADDR
45832: LD_VAR 0 2
45836: PUSH
45837: FOR_TO
45838: IFFALSE 45950
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
45840: LD_VAR 0 1
45844: PPUSH
45845: LD_VAR 0 2
45849: PUSH
45850: LD_VAR 0 4
45854: ARRAY
45855: PUSH
45856: LD_INT 1
45858: ARRAY
45859: PPUSH
45860: LD_VAR 0 2
45864: PUSH
45865: LD_VAR 0 4
45869: ARRAY
45870: PUSH
45871: LD_INT 2
45873: ARRAY
45874: PPUSH
45875: CALL_OW 297
45879: PUSH
45880: LD_VAR 0 5
45884: LESS
45885: IFFALSE 45948
// begin hex := hexes [ i ] ;
45887: LD_ADDR_VAR 0 7
45891: PUSH
45892: LD_VAR 0 2
45896: PUSH
45897: LD_VAR 0 4
45901: ARRAY
45902: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
45903: LD_ADDR_VAR 0 5
45907: PUSH
45908: LD_VAR 0 1
45912: PPUSH
45913: LD_VAR 0 2
45917: PUSH
45918: LD_VAR 0 4
45922: ARRAY
45923: PUSH
45924: LD_INT 1
45926: ARRAY
45927: PPUSH
45928: LD_VAR 0 2
45932: PUSH
45933: LD_VAR 0 4
45937: ARRAY
45938: PUSH
45939: LD_INT 2
45941: ARRAY
45942: PPUSH
45943: CALL_OW 297
45947: ST_TO_ADDR
// end ; end ;
45948: GO 45837
45950: POP
45951: POP
// result := hex ;
45952: LD_ADDR_VAR 0 3
45956: PUSH
45957: LD_VAR 0 7
45961: ST_TO_ADDR
// end ;
45962: LD_VAR 0 3
45966: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
45967: LD_INT 0
45969: PPUSH
45970: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
45971: LD_VAR 0 1
45975: NOT
45976: PUSH
45977: LD_VAR 0 1
45981: PUSH
45982: LD_INT 21
45984: PUSH
45985: LD_INT 2
45987: PUSH
45988: EMPTY
45989: LIST
45990: LIST
45991: PUSH
45992: LD_INT 23
45994: PUSH
45995: LD_INT 2
45997: PUSH
45998: EMPTY
45999: LIST
46000: LIST
46001: PUSH
46002: EMPTY
46003: LIST
46004: LIST
46005: PPUSH
46006: CALL_OW 69
46010: IN
46011: NOT
46012: OR
46013: IFFALSE 46017
// exit ;
46015: GO 46064
// for i = 1 to 3 do
46017: LD_ADDR_VAR 0 3
46021: PUSH
46022: DOUBLE
46023: LD_INT 1
46025: DEC
46026: ST_TO_ADDR
46027: LD_INT 3
46029: PUSH
46030: FOR_TO
46031: IFFALSE 46062
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46033: LD_VAR 0 1
46037: PPUSH
46038: CALL_OW 250
46042: PPUSH
46043: LD_VAR 0 1
46047: PPUSH
46048: CALL_OW 251
46052: PPUSH
46053: LD_INT 1
46055: PPUSH
46056: CALL_OW 453
46060: GO 46030
46062: POP
46063: POP
// end ;
46064: LD_VAR 0 2
46068: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46069: LD_INT 0
46071: PPUSH
46072: PPUSH
46073: PPUSH
46074: PPUSH
46075: PPUSH
46076: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46077: LD_VAR 0 1
46081: NOT
46082: PUSH
46083: LD_VAR 0 2
46087: NOT
46088: OR
46089: PUSH
46090: LD_VAR 0 1
46094: PPUSH
46095: CALL_OW 314
46099: OR
46100: IFFALSE 46104
// exit ;
46102: GO 46545
// x := GetX ( enemy_unit ) ;
46104: LD_ADDR_VAR 0 7
46108: PUSH
46109: LD_VAR 0 2
46113: PPUSH
46114: CALL_OW 250
46118: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46119: LD_ADDR_VAR 0 8
46123: PUSH
46124: LD_VAR 0 2
46128: PPUSH
46129: CALL_OW 251
46133: ST_TO_ADDR
// if not x or not y then
46134: LD_VAR 0 7
46138: NOT
46139: PUSH
46140: LD_VAR 0 8
46144: NOT
46145: OR
46146: IFFALSE 46150
// exit ;
46148: GO 46545
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46150: LD_ADDR_VAR 0 6
46154: PUSH
46155: LD_VAR 0 7
46159: PPUSH
46160: LD_INT 0
46162: PPUSH
46163: LD_INT 4
46165: PPUSH
46166: CALL_OW 272
46170: PUSH
46171: LD_VAR 0 8
46175: PPUSH
46176: LD_INT 0
46178: PPUSH
46179: LD_INT 4
46181: PPUSH
46182: CALL_OW 273
46186: PUSH
46187: EMPTY
46188: LIST
46189: LIST
46190: PUSH
46191: LD_VAR 0 7
46195: PPUSH
46196: LD_INT 1
46198: PPUSH
46199: LD_INT 4
46201: PPUSH
46202: CALL_OW 272
46206: PUSH
46207: LD_VAR 0 8
46211: PPUSH
46212: LD_INT 1
46214: PPUSH
46215: LD_INT 4
46217: PPUSH
46218: CALL_OW 273
46222: PUSH
46223: EMPTY
46224: LIST
46225: LIST
46226: PUSH
46227: LD_VAR 0 7
46231: PPUSH
46232: LD_INT 2
46234: PPUSH
46235: LD_INT 4
46237: PPUSH
46238: CALL_OW 272
46242: PUSH
46243: LD_VAR 0 8
46247: PPUSH
46248: LD_INT 2
46250: PPUSH
46251: LD_INT 4
46253: PPUSH
46254: CALL_OW 273
46258: PUSH
46259: EMPTY
46260: LIST
46261: LIST
46262: PUSH
46263: LD_VAR 0 7
46267: PPUSH
46268: LD_INT 3
46270: PPUSH
46271: LD_INT 4
46273: PPUSH
46274: CALL_OW 272
46278: PUSH
46279: LD_VAR 0 8
46283: PPUSH
46284: LD_INT 3
46286: PPUSH
46287: LD_INT 4
46289: PPUSH
46290: CALL_OW 273
46294: PUSH
46295: EMPTY
46296: LIST
46297: LIST
46298: PUSH
46299: LD_VAR 0 7
46303: PPUSH
46304: LD_INT 4
46306: PPUSH
46307: LD_INT 4
46309: PPUSH
46310: CALL_OW 272
46314: PUSH
46315: LD_VAR 0 8
46319: PPUSH
46320: LD_INT 4
46322: PPUSH
46323: LD_INT 4
46325: PPUSH
46326: CALL_OW 273
46330: PUSH
46331: EMPTY
46332: LIST
46333: LIST
46334: PUSH
46335: LD_VAR 0 7
46339: PPUSH
46340: LD_INT 5
46342: PPUSH
46343: LD_INT 4
46345: PPUSH
46346: CALL_OW 272
46350: PUSH
46351: LD_VAR 0 8
46355: PPUSH
46356: LD_INT 5
46358: PPUSH
46359: LD_INT 4
46361: PPUSH
46362: CALL_OW 273
46366: PUSH
46367: EMPTY
46368: LIST
46369: LIST
46370: PUSH
46371: EMPTY
46372: LIST
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: ST_TO_ADDR
// for i = tmp downto 1 do
46379: LD_ADDR_VAR 0 4
46383: PUSH
46384: DOUBLE
46385: LD_VAR 0 6
46389: INC
46390: ST_TO_ADDR
46391: LD_INT 1
46393: PUSH
46394: FOR_DOWNTO
46395: IFFALSE 46496
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46397: LD_VAR 0 6
46401: PUSH
46402: LD_VAR 0 4
46406: ARRAY
46407: PUSH
46408: LD_INT 1
46410: ARRAY
46411: PPUSH
46412: LD_VAR 0 6
46416: PUSH
46417: LD_VAR 0 4
46421: ARRAY
46422: PUSH
46423: LD_INT 2
46425: ARRAY
46426: PPUSH
46427: CALL_OW 488
46431: NOT
46432: PUSH
46433: LD_VAR 0 6
46437: PUSH
46438: LD_VAR 0 4
46442: ARRAY
46443: PUSH
46444: LD_INT 1
46446: ARRAY
46447: PPUSH
46448: LD_VAR 0 6
46452: PUSH
46453: LD_VAR 0 4
46457: ARRAY
46458: PUSH
46459: LD_INT 2
46461: ARRAY
46462: PPUSH
46463: CALL_OW 428
46467: PUSH
46468: LD_INT 0
46470: NONEQUAL
46471: OR
46472: IFFALSE 46494
// tmp := Delete ( tmp , i ) ;
46474: LD_ADDR_VAR 0 6
46478: PUSH
46479: LD_VAR 0 6
46483: PPUSH
46484: LD_VAR 0 4
46488: PPUSH
46489: CALL_OW 3
46493: ST_TO_ADDR
46494: GO 46394
46496: POP
46497: POP
// j := GetClosestHex ( unit , tmp ) ;
46498: LD_ADDR_VAR 0 5
46502: PUSH
46503: LD_VAR 0 1
46507: PPUSH
46508: LD_VAR 0 6
46512: PPUSH
46513: CALL 45798 0 2
46517: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46518: LD_VAR 0 1
46522: PPUSH
46523: LD_VAR 0 5
46527: PUSH
46528: LD_INT 1
46530: ARRAY
46531: PPUSH
46532: LD_VAR 0 5
46536: PUSH
46537: LD_INT 2
46539: ARRAY
46540: PPUSH
46541: CALL_OW 111
// end ;
46545: LD_VAR 0 3
46549: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46550: LD_INT 0
46552: PPUSH
46553: PPUSH
46554: PPUSH
// uc_side = 0 ;
46555: LD_ADDR_OWVAR 20
46559: PUSH
46560: LD_INT 0
46562: ST_TO_ADDR
// uc_nation = 0 ;
46563: LD_ADDR_OWVAR 21
46567: PUSH
46568: LD_INT 0
46570: ST_TO_ADDR
// InitHc_All ( ) ;
46571: CALL_OW 584
// InitVc ;
46575: CALL_OW 20
// if mastodonts then
46579: LD_VAR 0 6
46583: IFFALSE 46650
// for i = 1 to mastodonts do
46585: LD_ADDR_VAR 0 11
46589: PUSH
46590: DOUBLE
46591: LD_INT 1
46593: DEC
46594: ST_TO_ADDR
46595: LD_VAR 0 6
46599: PUSH
46600: FOR_TO
46601: IFFALSE 46648
// begin vc_chassis := 31 ;
46603: LD_ADDR_OWVAR 37
46607: PUSH
46608: LD_INT 31
46610: ST_TO_ADDR
// vc_control := control_rider ;
46611: LD_ADDR_OWVAR 38
46615: PUSH
46616: LD_INT 4
46618: ST_TO_ADDR
// animal := CreateVehicle ;
46619: LD_ADDR_VAR 0 12
46623: PUSH
46624: CALL_OW 45
46628: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46629: LD_VAR 0 12
46633: PPUSH
46634: LD_VAR 0 8
46638: PPUSH
46639: LD_INT 0
46641: PPUSH
46642: CALL 48838 0 3
// end ;
46646: GO 46600
46648: POP
46649: POP
// if horses then
46650: LD_VAR 0 5
46654: IFFALSE 46721
// for i = 1 to horses do
46656: LD_ADDR_VAR 0 11
46660: PUSH
46661: DOUBLE
46662: LD_INT 1
46664: DEC
46665: ST_TO_ADDR
46666: LD_VAR 0 5
46670: PUSH
46671: FOR_TO
46672: IFFALSE 46719
// begin hc_class := 21 ;
46674: LD_ADDR_OWVAR 28
46678: PUSH
46679: LD_INT 21
46681: ST_TO_ADDR
// hc_gallery :=  ;
46682: LD_ADDR_OWVAR 33
46686: PUSH
46687: LD_STRING 
46689: ST_TO_ADDR
// animal := CreateHuman ;
46690: LD_ADDR_VAR 0 12
46694: PUSH
46695: CALL_OW 44
46699: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46700: LD_VAR 0 12
46704: PPUSH
46705: LD_VAR 0 8
46709: PPUSH
46710: LD_INT 0
46712: PPUSH
46713: CALL 48838 0 3
// end ;
46717: GO 46671
46719: POP
46720: POP
// if birds then
46721: LD_VAR 0 1
46725: IFFALSE 46792
// for i = 1 to birds do
46727: LD_ADDR_VAR 0 11
46731: PUSH
46732: DOUBLE
46733: LD_INT 1
46735: DEC
46736: ST_TO_ADDR
46737: LD_VAR 0 1
46741: PUSH
46742: FOR_TO
46743: IFFALSE 46790
// begin hc_class = 18 ;
46745: LD_ADDR_OWVAR 28
46749: PUSH
46750: LD_INT 18
46752: ST_TO_ADDR
// hc_gallery =  ;
46753: LD_ADDR_OWVAR 33
46757: PUSH
46758: LD_STRING 
46760: ST_TO_ADDR
// animal := CreateHuman ;
46761: LD_ADDR_VAR 0 12
46765: PUSH
46766: CALL_OW 44
46770: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46771: LD_VAR 0 12
46775: PPUSH
46776: LD_VAR 0 8
46780: PPUSH
46781: LD_INT 0
46783: PPUSH
46784: CALL 48838 0 3
// end ;
46788: GO 46742
46790: POP
46791: POP
// if tigers then
46792: LD_VAR 0 2
46796: IFFALSE 46880
// for i = 1 to tigers do
46798: LD_ADDR_VAR 0 11
46802: PUSH
46803: DOUBLE
46804: LD_INT 1
46806: DEC
46807: ST_TO_ADDR
46808: LD_VAR 0 2
46812: PUSH
46813: FOR_TO
46814: IFFALSE 46878
// begin hc_class = class_tiger ;
46816: LD_ADDR_OWVAR 28
46820: PUSH
46821: LD_INT 14
46823: ST_TO_ADDR
// hc_gallery =  ;
46824: LD_ADDR_OWVAR 33
46828: PUSH
46829: LD_STRING 
46831: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
46832: LD_ADDR_OWVAR 35
46836: PUSH
46837: LD_INT 7
46839: NEG
46840: PPUSH
46841: LD_INT 7
46843: PPUSH
46844: CALL_OW 12
46848: ST_TO_ADDR
// animal := CreateHuman ;
46849: LD_ADDR_VAR 0 12
46853: PUSH
46854: CALL_OW 44
46858: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46859: LD_VAR 0 12
46863: PPUSH
46864: LD_VAR 0 8
46868: PPUSH
46869: LD_INT 0
46871: PPUSH
46872: CALL 48838 0 3
// end ;
46876: GO 46813
46878: POP
46879: POP
// if apemans then
46880: LD_VAR 0 3
46884: IFFALSE 47007
// for i = 1 to apemans do
46886: LD_ADDR_VAR 0 11
46890: PUSH
46891: DOUBLE
46892: LD_INT 1
46894: DEC
46895: ST_TO_ADDR
46896: LD_VAR 0 3
46900: PUSH
46901: FOR_TO
46902: IFFALSE 47005
// begin hc_class = class_apeman ;
46904: LD_ADDR_OWVAR 28
46908: PUSH
46909: LD_INT 12
46911: ST_TO_ADDR
// hc_gallery =  ;
46912: LD_ADDR_OWVAR 33
46916: PUSH
46917: LD_STRING 
46919: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
46920: LD_ADDR_OWVAR 35
46924: PUSH
46925: LD_INT 5
46927: NEG
46928: PPUSH
46929: LD_INT 5
46931: PPUSH
46932: CALL_OW 12
46936: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
46937: LD_ADDR_OWVAR 31
46941: PUSH
46942: LD_INT 1
46944: PPUSH
46945: LD_INT 3
46947: PPUSH
46948: CALL_OW 12
46952: PUSH
46953: LD_INT 1
46955: PPUSH
46956: LD_INT 3
46958: PPUSH
46959: CALL_OW 12
46963: PUSH
46964: LD_INT 0
46966: PUSH
46967: LD_INT 0
46969: PUSH
46970: EMPTY
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: ST_TO_ADDR
// animal := CreateHuman ;
46976: LD_ADDR_VAR 0 12
46980: PUSH
46981: CALL_OW 44
46985: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46986: LD_VAR 0 12
46990: PPUSH
46991: LD_VAR 0 8
46995: PPUSH
46996: LD_INT 0
46998: PPUSH
46999: CALL 48838 0 3
// end ;
47003: GO 46901
47005: POP
47006: POP
// if enchidnas then
47007: LD_VAR 0 4
47011: IFFALSE 47078
// for i = 1 to enchidnas do
47013: LD_ADDR_VAR 0 11
47017: PUSH
47018: DOUBLE
47019: LD_INT 1
47021: DEC
47022: ST_TO_ADDR
47023: LD_VAR 0 4
47027: PUSH
47028: FOR_TO
47029: IFFALSE 47076
// begin hc_class = 13 ;
47031: LD_ADDR_OWVAR 28
47035: PUSH
47036: LD_INT 13
47038: ST_TO_ADDR
// hc_gallery =  ;
47039: LD_ADDR_OWVAR 33
47043: PUSH
47044: LD_STRING 
47046: ST_TO_ADDR
// animal := CreateHuman ;
47047: LD_ADDR_VAR 0 12
47051: PUSH
47052: CALL_OW 44
47056: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47057: LD_VAR 0 12
47061: PPUSH
47062: LD_VAR 0 8
47066: PPUSH
47067: LD_INT 0
47069: PPUSH
47070: CALL 48838 0 3
// end ;
47074: GO 47028
47076: POP
47077: POP
// if fishes then
47078: LD_VAR 0 7
47082: IFFALSE 47149
// for i = 1 to fishes do
47084: LD_ADDR_VAR 0 11
47088: PUSH
47089: DOUBLE
47090: LD_INT 1
47092: DEC
47093: ST_TO_ADDR
47094: LD_VAR 0 7
47098: PUSH
47099: FOR_TO
47100: IFFALSE 47147
// begin hc_class = 20 ;
47102: LD_ADDR_OWVAR 28
47106: PUSH
47107: LD_INT 20
47109: ST_TO_ADDR
// hc_gallery =  ;
47110: LD_ADDR_OWVAR 33
47114: PUSH
47115: LD_STRING 
47117: ST_TO_ADDR
// animal := CreateHuman ;
47118: LD_ADDR_VAR 0 12
47122: PUSH
47123: CALL_OW 44
47127: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
47128: LD_VAR 0 12
47132: PPUSH
47133: LD_VAR 0 9
47137: PPUSH
47138: LD_INT 0
47140: PPUSH
47141: CALL 48838 0 3
// end ;
47145: GO 47099
47147: POP
47148: POP
// end ;
47149: LD_VAR 0 10
47153: RET
// export function WantHeal ( sci , unit ) ; begin
47154: LD_INT 0
47156: PPUSH
// if GetTaskList ( sci ) > 0 then
47157: LD_VAR 0 1
47161: PPUSH
47162: CALL_OW 437
47166: PUSH
47167: LD_INT 0
47169: GREATER
47170: IFFALSE 47240
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
47172: LD_VAR 0 1
47176: PPUSH
47177: CALL_OW 437
47181: PUSH
47182: LD_INT 1
47184: ARRAY
47185: PUSH
47186: LD_INT 1
47188: ARRAY
47189: PUSH
47190: LD_STRING l
47192: EQUAL
47193: PUSH
47194: LD_VAR 0 1
47198: PPUSH
47199: CALL_OW 437
47203: PUSH
47204: LD_INT 1
47206: ARRAY
47207: PUSH
47208: LD_INT 4
47210: ARRAY
47211: PUSH
47212: LD_VAR 0 2
47216: EQUAL
47217: AND
47218: IFFALSE 47230
// result := true else
47220: LD_ADDR_VAR 0 3
47224: PUSH
47225: LD_INT 1
47227: ST_TO_ADDR
47228: GO 47238
// result := false ;
47230: LD_ADDR_VAR 0 3
47234: PUSH
47235: LD_INT 0
47237: ST_TO_ADDR
// end else
47238: GO 47248
// result := false ;
47240: LD_ADDR_VAR 0 3
47244: PUSH
47245: LD_INT 0
47247: ST_TO_ADDR
// end ;
47248: LD_VAR 0 3
47252: RET
// export function HealTarget ( sci ) ; begin
47253: LD_INT 0
47255: PPUSH
// if not sci then
47256: LD_VAR 0 1
47260: NOT
47261: IFFALSE 47265
// exit ;
47263: GO 47330
// result := 0 ;
47265: LD_ADDR_VAR 0 2
47269: PUSH
47270: LD_INT 0
47272: ST_TO_ADDR
// if GetTaskList ( sci ) then
47273: LD_VAR 0 1
47277: PPUSH
47278: CALL_OW 437
47282: IFFALSE 47330
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
47284: LD_VAR 0 1
47288: PPUSH
47289: CALL_OW 437
47293: PUSH
47294: LD_INT 1
47296: ARRAY
47297: PUSH
47298: LD_INT 1
47300: ARRAY
47301: PUSH
47302: LD_STRING l
47304: EQUAL
47305: IFFALSE 47330
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
47307: LD_ADDR_VAR 0 2
47311: PUSH
47312: LD_VAR 0 1
47316: PPUSH
47317: CALL_OW 437
47321: PUSH
47322: LD_INT 1
47324: ARRAY
47325: PUSH
47326: LD_INT 4
47328: ARRAY
47329: ST_TO_ADDR
// end ;
47330: LD_VAR 0 2
47334: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
47335: LD_INT 0
47337: PPUSH
47338: PPUSH
47339: PPUSH
47340: PPUSH
// if not base_units then
47341: LD_VAR 0 1
47345: NOT
47346: IFFALSE 47350
// exit ;
47348: GO 47437
// result := false ;
47350: LD_ADDR_VAR 0 2
47354: PUSH
47355: LD_INT 0
47357: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
47358: LD_ADDR_VAR 0 5
47362: PUSH
47363: LD_VAR 0 1
47367: PPUSH
47368: LD_INT 21
47370: PUSH
47371: LD_INT 3
47373: PUSH
47374: EMPTY
47375: LIST
47376: LIST
47377: PPUSH
47378: CALL_OW 72
47382: ST_TO_ADDR
// if not tmp then
47383: LD_VAR 0 5
47387: NOT
47388: IFFALSE 47392
// exit ;
47390: GO 47437
// for i in tmp do
47392: LD_ADDR_VAR 0 3
47396: PUSH
47397: LD_VAR 0 5
47401: PUSH
47402: FOR_IN
47403: IFFALSE 47435
// begin result := EnemyInRange ( i , 22 ) ;
47405: LD_ADDR_VAR 0 2
47409: PUSH
47410: LD_VAR 0 3
47414: PPUSH
47415: LD_INT 22
47417: PPUSH
47418: CALL 45673 0 2
47422: ST_TO_ADDR
// if result then
47423: LD_VAR 0 2
47427: IFFALSE 47433
// exit ;
47429: POP
47430: POP
47431: GO 47437
// end ;
47433: GO 47402
47435: POP
47436: POP
// end ;
47437: LD_VAR 0 2
47441: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
47442: LD_INT 0
47444: PPUSH
47445: PPUSH
// if not units then
47446: LD_VAR 0 1
47450: NOT
47451: IFFALSE 47455
// exit ;
47453: GO 47525
// result := [ ] ;
47455: LD_ADDR_VAR 0 3
47459: PUSH
47460: EMPTY
47461: ST_TO_ADDR
// for i in units do
47462: LD_ADDR_VAR 0 4
47466: PUSH
47467: LD_VAR 0 1
47471: PUSH
47472: FOR_IN
47473: IFFALSE 47523
// if GetTag ( i ) = tag then
47475: LD_VAR 0 4
47479: PPUSH
47480: CALL_OW 110
47484: PUSH
47485: LD_VAR 0 2
47489: EQUAL
47490: IFFALSE 47521
// result := Insert ( result , result + 1 , i ) ;
47492: LD_ADDR_VAR 0 3
47496: PUSH
47497: LD_VAR 0 3
47501: PPUSH
47502: LD_VAR 0 3
47506: PUSH
47507: LD_INT 1
47509: PLUS
47510: PPUSH
47511: LD_VAR 0 4
47515: PPUSH
47516: CALL_OW 2
47520: ST_TO_ADDR
47521: GO 47472
47523: POP
47524: POP
// end ;
47525: LD_VAR 0 3
47529: RET
// export function IsDriver ( un ) ; begin
47530: LD_INT 0
47532: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47533: LD_ADDR_VAR 0 2
47537: PUSH
47538: LD_VAR 0 1
47542: PUSH
47543: LD_INT 55
47545: PUSH
47546: EMPTY
47547: LIST
47548: PPUSH
47549: CALL_OW 69
47553: IN
47554: ST_TO_ADDR
// end ;
47555: LD_VAR 0 2
47559: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47560: LD_INT 0
47562: PPUSH
47563: PPUSH
// list := [ ] ;
47564: LD_ADDR_VAR 0 5
47568: PUSH
47569: EMPTY
47570: ST_TO_ADDR
// case d of 0 :
47571: LD_VAR 0 3
47575: PUSH
47576: LD_INT 0
47578: DOUBLE
47579: EQUAL
47580: IFTRUE 47584
47582: GO 47717
47584: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
47585: LD_ADDR_VAR 0 5
47589: PUSH
47590: LD_VAR 0 1
47594: PUSH
47595: LD_INT 4
47597: MINUS
47598: PUSH
47599: LD_VAR 0 2
47603: PUSH
47604: LD_INT 4
47606: MINUS
47607: PUSH
47608: LD_INT 2
47610: PUSH
47611: EMPTY
47612: LIST
47613: LIST
47614: LIST
47615: PUSH
47616: LD_VAR 0 1
47620: PUSH
47621: LD_INT 3
47623: MINUS
47624: PUSH
47625: LD_VAR 0 2
47629: PUSH
47630: LD_INT 1
47632: PUSH
47633: EMPTY
47634: LIST
47635: LIST
47636: LIST
47637: PUSH
47638: LD_VAR 0 1
47642: PUSH
47643: LD_INT 4
47645: PLUS
47646: PUSH
47647: LD_VAR 0 2
47651: PUSH
47652: LD_INT 4
47654: PUSH
47655: EMPTY
47656: LIST
47657: LIST
47658: LIST
47659: PUSH
47660: LD_VAR 0 1
47664: PUSH
47665: LD_INT 3
47667: PLUS
47668: PUSH
47669: LD_VAR 0 2
47673: PUSH
47674: LD_INT 3
47676: PLUS
47677: PUSH
47678: LD_INT 5
47680: PUSH
47681: EMPTY
47682: LIST
47683: LIST
47684: LIST
47685: PUSH
47686: LD_VAR 0 1
47690: PUSH
47691: LD_VAR 0 2
47695: PUSH
47696: LD_INT 4
47698: PLUS
47699: PUSH
47700: LD_INT 0
47702: PUSH
47703: EMPTY
47704: LIST
47705: LIST
47706: LIST
47707: PUSH
47708: EMPTY
47709: LIST
47710: LIST
47711: LIST
47712: LIST
47713: LIST
47714: ST_TO_ADDR
// end ; 1 :
47715: GO 48415
47717: LD_INT 1
47719: DOUBLE
47720: EQUAL
47721: IFTRUE 47725
47723: GO 47858
47725: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
47726: LD_ADDR_VAR 0 5
47730: PUSH
47731: LD_VAR 0 1
47735: PUSH
47736: LD_VAR 0 2
47740: PUSH
47741: LD_INT 4
47743: MINUS
47744: PUSH
47745: LD_INT 3
47747: PUSH
47748: EMPTY
47749: LIST
47750: LIST
47751: LIST
47752: PUSH
47753: LD_VAR 0 1
47757: PUSH
47758: LD_INT 3
47760: MINUS
47761: PUSH
47762: LD_VAR 0 2
47766: PUSH
47767: LD_INT 3
47769: MINUS
47770: PUSH
47771: LD_INT 2
47773: PUSH
47774: EMPTY
47775: LIST
47776: LIST
47777: LIST
47778: PUSH
47779: LD_VAR 0 1
47783: PUSH
47784: LD_INT 4
47786: MINUS
47787: PUSH
47788: LD_VAR 0 2
47792: PUSH
47793: LD_INT 1
47795: PUSH
47796: EMPTY
47797: LIST
47798: LIST
47799: LIST
47800: PUSH
47801: LD_VAR 0 1
47805: PUSH
47806: LD_VAR 0 2
47810: PUSH
47811: LD_INT 3
47813: PLUS
47814: PUSH
47815: LD_INT 0
47817: PUSH
47818: EMPTY
47819: LIST
47820: LIST
47821: LIST
47822: PUSH
47823: LD_VAR 0 1
47827: PUSH
47828: LD_INT 4
47830: PLUS
47831: PUSH
47832: LD_VAR 0 2
47836: PUSH
47837: LD_INT 4
47839: PLUS
47840: PUSH
47841: LD_INT 5
47843: PUSH
47844: EMPTY
47845: LIST
47846: LIST
47847: LIST
47848: PUSH
47849: EMPTY
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: LIST
47855: ST_TO_ADDR
// end ; 2 :
47856: GO 48415
47858: LD_INT 2
47860: DOUBLE
47861: EQUAL
47862: IFTRUE 47866
47864: GO 47995
47866: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
47867: LD_ADDR_VAR 0 5
47871: PUSH
47872: LD_VAR 0 1
47876: PUSH
47877: LD_VAR 0 2
47881: PUSH
47882: LD_INT 3
47884: MINUS
47885: PUSH
47886: LD_INT 3
47888: PUSH
47889: EMPTY
47890: LIST
47891: LIST
47892: LIST
47893: PUSH
47894: LD_VAR 0 1
47898: PUSH
47899: LD_INT 4
47901: PLUS
47902: PUSH
47903: LD_VAR 0 2
47907: PUSH
47908: LD_INT 4
47910: PUSH
47911: EMPTY
47912: LIST
47913: LIST
47914: LIST
47915: PUSH
47916: LD_VAR 0 1
47920: PUSH
47921: LD_VAR 0 2
47925: PUSH
47926: LD_INT 4
47928: PLUS
47929: PUSH
47930: LD_INT 0
47932: PUSH
47933: EMPTY
47934: LIST
47935: LIST
47936: LIST
47937: PUSH
47938: LD_VAR 0 1
47942: PUSH
47943: LD_INT 3
47945: MINUS
47946: PUSH
47947: LD_VAR 0 2
47951: PUSH
47952: LD_INT 1
47954: PUSH
47955: EMPTY
47956: LIST
47957: LIST
47958: LIST
47959: PUSH
47960: LD_VAR 0 1
47964: PUSH
47965: LD_INT 4
47967: MINUS
47968: PUSH
47969: LD_VAR 0 2
47973: PUSH
47974: LD_INT 4
47976: MINUS
47977: PUSH
47978: LD_INT 2
47980: PUSH
47981: EMPTY
47982: LIST
47983: LIST
47984: LIST
47985: PUSH
47986: EMPTY
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: LIST
47992: ST_TO_ADDR
// end ; 3 :
47993: GO 48415
47995: LD_INT 3
47997: DOUBLE
47998: EQUAL
47999: IFTRUE 48003
48001: GO 48136
48003: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
48004: LD_ADDR_VAR 0 5
48008: PUSH
48009: LD_VAR 0 1
48013: PUSH
48014: LD_INT 3
48016: PLUS
48017: PUSH
48018: LD_VAR 0 2
48022: PUSH
48023: LD_INT 4
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: LIST
48030: PUSH
48031: LD_VAR 0 1
48035: PUSH
48036: LD_INT 4
48038: PLUS
48039: PUSH
48040: LD_VAR 0 2
48044: PUSH
48045: LD_INT 4
48047: PLUS
48048: PUSH
48049: LD_INT 5
48051: PUSH
48052: EMPTY
48053: LIST
48054: LIST
48055: LIST
48056: PUSH
48057: LD_VAR 0 1
48061: PUSH
48062: LD_INT 4
48064: MINUS
48065: PUSH
48066: LD_VAR 0 2
48070: PUSH
48071: LD_INT 1
48073: PUSH
48074: EMPTY
48075: LIST
48076: LIST
48077: LIST
48078: PUSH
48079: LD_VAR 0 1
48083: PUSH
48084: LD_VAR 0 2
48088: PUSH
48089: LD_INT 4
48091: MINUS
48092: PUSH
48093: LD_INT 3
48095: PUSH
48096: EMPTY
48097: LIST
48098: LIST
48099: LIST
48100: PUSH
48101: LD_VAR 0 1
48105: PUSH
48106: LD_INT 3
48108: MINUS
48109: PUSH
48110: LD_VAR 0 2
48114: PUSH
48115: LD_INT 3
48117: MINUS
48118: PUSH
48119: LD_INT 2
48121: PUSH
48122: EMPTY
48123: LIST
48124: LIST
48125: LIST
48126: PUSH
48127: EMPTY
48128: LIST
48129: LIST
48130: LIST
48131: LIST
48132: LIST
48133: ST_TO_ADDR
// end ; 4 :
48134: GO 48415
48136: LD_INT 4
48138: DOUBLE
48139: EQUAL
48140: IFTRUE 48144
48142: GO 48277
48144: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
48145: LD_ADDR_VAR 0 5
48149: PUSH
48150: LD_VAR 0 1
48154: PUSH
48155: LD_VAR 0 2
48159: PUSH
48160: LD_INT 4
48162: PLUS
48163: PUSH
48164: LD_INT 0
48166: PUSH
48167: EMPTY
48168: LIST
48169: LIST
48170: LIST
48171: PUSH
48172: LD_VAR 0 1
48176: PUSH
48177: LD_INT 3
48179: PLUS
48180: PUSH
48181: LD_VAR 0 2
48185: PUSH
48186: LD_INT 3
48188: PLUS
48189: PUSH
48190: LD_INT 5
48192: PUSH
48193: EMPTY
48194: LIST
48195: LIST
48196: LIST
48197: PUSH
48198: LD_VAR 0 1
48202: PUSH
48203: LD_INT 4
48205: PLUS
48206: PUSH
48207: LD_VAR 0 2
48211: PUSH
48212: LD_INT 4
48214: PUSH
48215: EMPTY
48216: LIST
48217: LIST
48218: LIST
48219: PUSH
48220: LD_VAR 0 1
48224: PUSH
48225: LD_VAR 0 2
48229: PUSH
48230: LD_INT 3
48232: MINUS
48233: PUSH
48234: LD_INT 3
48236: PUSH
48237: EMPTY
48238: LIST
48239: LIST
48240: LIST
48241: PUSH
48242: LD_VAR 0 1
48246: PUSH
48247: LD_INT 4
48249: MINUS
48250: PUSH
48251: LD_VAR 0 2
48255: PUSH
48256: LD_INT 4
48258: MINUS
48259: PUSH
48260: LD_INT 2
48262: PUSH
48263: EMPTY
48264: LIST
48265: LIST
48266: LIST
48267: PUSH
48268: EMPTY
48269: LIST
48270: LIST
48271: LIST
48272: LIST
48273: LIST
48274: ST_TO_ADDR
// end ; 5 :
48275: GO 48415
48277: LD_INT 5
48279: DOUBLE
48280: EQUAL
48281: IFTRUE 48285
48283: GO 48414
48285: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
48286: LD_ADDR_VAR 0 5
48290: PUSH
48291: LD_VAR 0 1
48295: PUSH
48296: LD_INT 4
48298: MINUS
48299: PUSH
48300: LD_VAR 0 2
48304: PUSH
48305: LD_INT 1
48307: PUSH
48308: EMPTY
48309: LIST
48310: LIST
48311: LIST
48312: PUSH
48313: LD_VAR 0 1
48317: PUSH
48318: LD_VAR 0 2
48322: PUSH
48323: LD_INT 4
48325: MINUS
48326: PUSH
48327: LD_INT 3
48329: PUSH
48330: EMPTY
48331: LIST
48332: LIST
48333: LIST
48334: PUSH
48335: LD_VAR 0 1
48339: PUSH
48340: LD_INT 4
48342: PLUS
48343: PUSH
48344: LD_VAR 0 2
48348: PUSH
48349: LD_INT 4
48351: PLUS
48352: PUSH
48353: LD_INT 5
48355: PUSH
48356: EMPTY
48357: LIST
48358: LIST
48359: LIST
48360: PUSH
48361: LD_VAR 0 1
48365: PUSH
48366: LD_INT 3
48368: PLUS
48369: PUSH
48370: LD_VAR 0 2
48374: PUSH
48375: LD_INT 4
48377: PUSH
48378: EMPTY
48379: LIST
48380: LIST
48381: LIST
48382: PUSH
48383: LD_VAR 0 1
48387: PUSH
48388: LD_VAR 0 2
48392: PUSH
48393: LD_INT 3
48395: PLUS
48396: PUSH
48397: LD_INT 0
48399: PUSH
48400: EMPTY
48401: LIST
48402: LIST
48403: LIST
48404: PUSH
48405: EMPTY
48406: LIST
48407: LIST
48408: LIST
48409: LIST
48410: LIST
48411: ST_TO_ADDR
// end ; end ;
48412: GO 48415
48414: POP
// result := list ;
48415: LD_ADDR_VAR 0 4
48419: PUSH
48420: LD_VAR 0 5
48424: ST_TO_ADDR
// end ;
48425: LD_VAR 0 4
48429: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48430: LD_INT 0
48432: PPUSH
48433: PPUSH
48434: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48435: LD_VAR 0 1
48439: NOT
48440: PUSH
48441: LD_VAR 0 2
48445: PUSH
48446: LD_INT 1
48448: PUSH
48449: LD_INT 2
48451: PUSH
48452: LD_INT 3
48454: PUSH
48455: LD_INT 4
48457: PUSH
48458: EMPTY
48459: LIST
48460: LIST
48461: LIST
48462: LIST
48463: IN
48464: NOT
48465: OR
48466: IFFALSE 48470
// exit ;
48468: GO 48562
// tmp := [ ] ;
48470: LD_ADDR_VAR 0 5
48474: PUSH
48475: EMPTY
48476: ST_TO_ADDR
// for i in units do
48477: LD_ADDR_VAR 0 4
48481: PUSH
48482: LD_VAR 0 1
48486: PUSH
48487: FOR_IN
48488: IFFALSE 48531
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48490: LD_ADDR_VAR 0 5
48494: PUSH
48495: LD_VAR 0 5
48499: PPUSH
48500: LD_VAR 0 5
48504: PUSH
48505: LD_INT 1
48507: PLUS
48508: PPUSH
48509: LD_VAR 0 4
48513: PPUSH
48514: LD_VAR 0 2
48518: PPUSH
48519: CALL_OW 259
48523: PPUSH
48524: CALL_OW 2
48528: ST_TO_ADDR
48529: GO 48487
48531: POP
48532: POP
// if not tmp then
48533: LD_VAR 0 5
48537: NOT
48538: IFFALSE 48542
// exit ;
48540: GO 48562
// result := SortListByListDesc ( units , tmp ) ;
48542: LD_ADDR_VAR 0 3
48546: PUSH
48547: LD_VAR 0 1
48551: PPUSH
48552: LD_VAR 0 5
48556: PPUSH
48557: CALL_OW 77
48561: ST_TO_ADDR
// end ;
48562: LD_VAR 0 3
48566: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48567: LD_INT 0
48569: PPUSH
48570: PPUSH
48571: PPUSH
// result := false ;
48572: LD_ADDR_VAR 0 3
48576: PUSH
48577: LD_INT 0
48579: ST_TO_ADDR
// x := GetX ( building ) ;
48580: LD_ADDR_VAR 0 4
48584: PUSH
48585: LD_VAR 0 2
48589: PPUSH
48590: CALL_OW 250
48594: ST_TO_ADDR
// y := GetY ( building ) ;
48595: LD_ADDR_VAR 0 5
48599: PUSH
48600: LD_VAR 0 2
48604: PPUSH
48605: CALL_OW 251
48609: ST_TO_ADDR
// if not building or not x or not y then
48610: LD_VAR 0 2
48614: NOT
48615: PUSH
48616: LD_VAR 0 4
48620: NOT
48621: OR
48622: PUSH
48623: LD_VAR 0 5
48627: NOT
48628: OR
48629: IFFALSE 48633
// exit ;
48631: GO 48725
// if GetTaskList ( unit ) then
48633: LD_VAR 0 1
48637: PPUSH
48638: CALL_OW 437
48642: IFFALSE 48725
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48644: LD_STRING e
48646: PUSH
48647: LD_VAR 0 1
48651: PPUSH
48652: CALL_OW 437
48656: PUSH
48657: LD_INT 1
48659: ARRAY
48660: PUSH
48661: LD_INT 1
48663: ARRAY
48664: EQUAL
48665: PUSH
48666: LD_VAR 0 4
48670: PUSH
48671: LD_VAR 0 1
48675: PPUSH
48676: CALL_OW 437
48680: PUSH
48681: LD_INT 1
48683: ARRAY
48684: PUSH
48685: LD_INT 2
48687: ARRAY
48688: EQUAL
48689: AND
48690: PUSH
48691: LD_VAR 0 5
48695: PUSH
48696: LD_VAR 0 1
48700: PPUSH
48701: CALL_OW 437
48705: PUSH
48706: LD_INT 1
48708: ARRAY
48709: PUSH
48710: LD_INT 3
48712: ARRAY
48713: EQUAL
48714: AND
48715: IFFALSE 48725
// result := true end ;
48717: LD_ADDR_VAR 0 3
48721: PUSH
48722: LD_INT 1
48724: ST_TO_ADDR
// end ;
48725: LD_VAR 0 3
48729: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
48730: LD_INT 0
48732: PPUSH
// result := false ;
48733: LD_ADDR_VAR 0 4
48737: PUSH
48738: LD_INT 0
48740: ST_TO_ADDR
// if GetTaskList ( unit ) then
48741: LD_VAR 0 1
48745: PPUSH
48746: CALL_OW 437
48750: IFFALSE 48833
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48752: LD_STRING M
48754: PUSH
48755: LD_VAR 0 1
48759: PPUSH
48760: CALL_OW 437
48764: PUSH
48765: LD_INT 1
48767: ARRAY
48768: PUSH
48769: LD_INT 1
48771: ARRAY
48772: EQUAL
48773: PUSH
48774: LD_VAR 0 2
48778: PUSH
48779: LD_VAR 0 1
48783: PPUSH
48784: CALL_OW 437
48788: PUSH
48789: LD_INT 1
48791: ARRAY
48792: PUSH
48793: LD_INT 2
48795: ARRAY
48796: EQUAL
48797: AND
48798: PUSH
48799: LD_VAR 0 3
48803: PUSH
48804: LD_VAR 0 1
48808: PPUSH
48809: CALL_OW 437
48813: PUSH
48814: LD_INT 1
48816: ARRAY
48817: PUSH
48818: LD_INT 3
48820: ARRAY
48821: EQUAL
48822: AND
48823: IFFALSE 48833
// result := true ;
48825: LD_ADDR_VAR 0 4
48829: PUSH
48830: LD_INT 1
48832: ST_TO_ADDR
// end ; end ;
48833: LD_VAR 0 4
48837: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
48838: LD_INT 0
48840: PPUSH
48841: PPUSH
48842: PPUSH
48843: PPUSH
// if not unit or not area then
48844: LD_VAR 0 1
48848: NOT
48849: PUSH
48850: LD_VAR 0 2
48854: NOT
48855: OR
48856: IFFALSE 48860
// exit ;
48858: GO 49024
// tmp := AreaToList ( area , i ) ;
48860: LD_ADDR_VAR 0 6
48864: PUSH
48865: LD_VAR 0 2
48869: PPUSH
48870: LD_VAR 0 5
48874: PPUSH
48875: CALL_OW 517
48879: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
48880: LD_ADDR_VAR 0 5
48884: PUSH
48885: DOUBLE
48886: LD_INT 1
48888: DEC
48889: ST_TO_ADDR
48890: LD_VAR 0 6
48894: PUSH
48895: LD_INT 1
48897: ARRAY
48898: PUSH
48899: FOR_TO
48900: IFFALSE 49022
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
48902: LD_ADDR_VAR 0 7
48906: PUSH
48907: LD_VAR 0 6
48911: PUSH
48912: LD_INT 1
48914: ARRAY
48915: PUSH
48916: LD_VAR 0 5
48920: ARRAY
48921: PUSH
48922: LD_VAR 0 6
48926: PUSH
48927: LD_INT 2
48929: ARRAY
48930: PUSH
48931: LD_VAR 0 5
48935: ARRAY
48936: PUSH
48937: EMPTY
48938: LIST
48939: LIST
48940: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
48941: LD_VAR 0 7
48945: PUSH
48946: LD_INT 1
48948: ARRAY
48949: PPUSH
48950: LD_VAR 0 7
48954: PUSH
48955: LD_INT 2
48957: ARRAY
48958: PPUSH
48959: CALL_OW 428
48963: PUSH
48964: LD_INT 0
48966: EQUAL
48967: IFFALSE 49020
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
48969: LD_VAR 0 1
48973: PPUSH
48974: LD_VAR 0 7
48978: PUSH
48979: LD_INT 1
48981: ARRAY
48982: PPUSH
48983: LD_VAR 0 7
48987: PUSH
48988: LD_INT 2
48990: ARRAY
48991: PPUSH
48992: LD_VAR 0 3
48996: PPUSH
48997: CALL_OW 48
// result := IsPlaced ( unit ) ;
49001: LD_ADDR_VAR 0 4
49005: PUSH
49006: LD_VAR 0 1
49010: PPUSH
49011: CALL_OW 305
49015: ST_TO_ADDR
// exit ;
49016: POP
49017: POP
49018: GO 49024
// end ; end ;
49020: GO 48899
49022: POP
49023: POP
// end ;
49024: LD_VAR 0 4
49028: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
49029: LD_INT 0
49031: PPUSH
49032: PPUSH
49033: PPUSH
// if not side or side > 8 then
49034: LD_VAR 0 1
49038: NOT
49039: PUSH
49040: LD_VAR 0 1
49044: PUSH
49045: LD_INT 8
49047: GREATER
49048: OR
49049: IFFALSE 49053
// exit ;
49051: GO 49240
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
49053: LD_ADDR_VAR 0 4
49057: PUSH
49058: LD_INT 22
49060: PUSH
49061: LD_VAR 0 1
49065: PUSH
49066: EMPTY
49067: LIST
49068: LIST
49069: PUSH
49070: LD_INT 21
49072: PUSH
49073: LD_INT 3
49075: PUSH
49076: EMPTY
49077: LIST
49078: LIST
49079: PUSH
49080: EMPTY
49081: LIST
49082: LIST
49083: PPUSH
49084: CALL_OW 69
49088: ST_TO_ADDR
// if not tmp then
49089: LD_VAR 0 4
49093: NOT
49094: IFFALSE 49098
// exit ;
49096: GO 49240
// enable_addtolog := true ;
49098: LD_ADDR_OWVAR 81
49102: PUSH
49103: LD_INT 1
49105: ST_TO_ADDR
// AddToLog ( [ ) ;
49106: LD_STRING [
49108: PPUSH
49109: CALL_OW 561
// for i in tmp do
49113: LD_ADDR_VAR 0 3
49117: PUSH
49118: LD_VAR 0 4
49122: PUSH
49123: FOR_IN
49124: IFFALSE 49231
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
49126: LD_STRING [
49128: PUSH
49129: LD_VAR 0 3
49133: PPUSH
49134: CALL_OW 266
49138: STR
49139: PUSH
49140: LD_STRING , 
49142: STR
49143: PUSH
49144: LD_VAR 0 3
49148: PPUSH
49149: CALL_OW 250
49153: STR
49154: PUSH
49155: LD_STRING , 
49157: STR
49158: PUSH
49159: LD_VAR 0 3
49163: PPUSH
49164: CALL_OW 251
49168: STR
49169: PUSH
49170: LD_STRING , 
49172: STR
49173: PUSH
49174: LD_VAR 0 3
49178: PPUSH
49179: CALL_OW 254
49183: STR
49184: PUSH
49185: LD_STRING , 
49187: STR
49188: PUSH
49189: LD_VAR 0 3
49193: PPUSH
49194: LD_INT 1
49196: PPUSH
49197: CALL_OW 268
49201: STR
49202: PUSH
49203: LD_STRING , 
49205: STR
49206: PUSH
49207: LD_VAR 0 3
49211: PPUSH
49212: LD_INT 2
49214: PPUSH
49215: CALL_OW 268
49219: STR
49220: PUSH
49221: LD_STRING ],
49223: STR
49224: PPUSH
49225: CALL_OW 561
// end ;
49229: GO 49123
49231: POP
49232: POP
// AddToLog ( ]; ) ;
49233: LD_STRING ];
49235: PPUSH
49236: CALL_OW 561
// end ;
49240: LD_VAR 0 2
49244: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
49245: LD_INT 0
49247: PPUSH
49248: PPUSH
49249: PPUSH
49250: PPUSH
49251: PPUSH
// if not area or not rate or not max then
49252: LD_VAR 0 1
49256: NOT
49257: PUSH
49258: LD_VAR 0 2
49262: NOT
49263: OR
49264: PUSH
49265: LD_VAR 0 4
49269: NOT
49270: OR
49271: IFFALSE 49275
// exit ;
49273: GO 49467
// while 1 do
49275: LD_INT 1
49277: IFFALSE 49467
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
49279: LD_ADDR_VAR 0 9
49283: PUSH
49284: LD_VAR 0 1
49288: PPUSH
49289: LD_INT 1
49291: PPUSH
49292: CALL_OW 287
49296: PUSH
49297: LD_INT 10
49299: MUL
49300: ST_TO_ADDR
// r := rate / 10 ;
49301: LD_ADDR_VAR 0 7
49305: PUSH
49306: LD_VAR 0 2
49310: PUSH
49311: LD_INT 10
49313: DIVREAL
49314: ST_TO_ADDR
// time := 1 1$00 ;
49315: LD_ADDR_VAR 0 8
49319: PUSH
49320: LD_INT 2100
49322: ST_TO_ADDR
// if amount < min then
49323: LD_VAR 0 9
49327: PUSH
49328: LD_VAR 0 3
49332: LESS
49333: IFFALSE 49351
// r := r * 2 else
49335: LD_ADDR_VAR 0 7
49339: PUSH
49340: LD_VAR 0 7
49344: PUSH
49345: LD_INT 2
49347: MUL
49348: ST_TO_ADDR
49349: GO 49377
// if amount > max then
49351: LD_VAR 0 9
49355: PUSH
49356: LD_VAR 0 4
49360: GREATER
49361: IFFALSE 49377
// r := r / 2 ;
49363: LD_ADDR_VAR 0 7
49367: PUSH
49368: LD_VAR 0 7
49372: PUSH
49373: LD_INT 2
49375: DIVREAL
49376: ST_TO_ADDR
// time := time / r ;
49377: LD_ADDR_VAR 0 8
49381: PUSH
49382: LD_VAR 0 8
49386: PUSH
49387: LD_VAR 0 7
49391: DIVREAL
49392: ST_TO_ADDR
// if time < 0 then
49393: LD_VAR 0 8
49397: PUSH
49398: LD_INT 0
49400: LESS
49401: IFFALSE 49418
// time := time * - 1 ;
49403: LD_ADDR_VAR 0 8
49407: PUSH
49408: LD_VAR 0 8
49412: PUSH
49413: LD_INT 1
49415: NEG
49416: MUL
49417: ST_TO_ADDR
// wait ( time ) ;
49418: LD_VAR 0 8
49422: PPUSH
49423: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
49427: LD_INT 35
49429: PPUSH
49430: LD_INT 875
49432: PPUSH
49433: CALL_OW 12
49437: PPUSH
49438: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
49442: LD_INT 1
49444: PPUSH
49445: LD_INT 5
49447: PPUSH
49448: CALL_OW 12
49452: PPUSH
49453: LD_VAR 0 1
49457: PPUSH
49458: LD_INT 1
49460: PPUSH
49461: CALL_OW 55
// end ;
49465: GO 49275
// end ;
49467: LD_VAR 0 5
49471: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
49472: LD_INT 0
49474: PPUSH
49475: PPUSH
49476: PPUSH
49477: PPUSH
49478: PPUSH
49479: PPUSH
49480: PPUSH
49481: PPUSH
// if not turrets or not factories then
49482: LD_VAR 0 1
49486: NOT
49487: PUSH
49488: LD_VAR 0 2
49492: NOT
49493: OR
49494: IFFALSE 49498
// exit ;
49496: GO 49805
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49498: LD_ADDR_VAR 0 10
49502: PUSH
49503: LD_INT 5
49505: PUSH
49506: LD_INT 6
49508: PUSH
49509: EMPTY
49510: LIST
49511: LIST
49512: PUSH
49513: LD_INT 2
49515: PUSH
49516: LD_INT 4
49518: PUSH
49519: EMPTY
49520: LIST
49521: LIST
49522: PUSH
49523: LD_INT 3
49525: PUSH
49526: LD_INT 5
49528: PUSH
49529: EMPTY
49530: LIST
49531: LIST
49532: PUSH
49533: EMPTY
49534: LIST
49535: LIST
49536: LIST
49537: PUSH
49538: LD_INT 24
49540: PUSH
49541: LD_INT 25
49543: PUSH
49544: EMPTY
49545: LIST
49546: LIST
49547: PUSH
49548: LD_INT 23
49550: PUSH
49551: LD_INT 27
49553: PUSH
49554: EMPTY
49555: LIST
49556: LIST
49557: PUSH
49558: EMPTY
49559: LIST
49560: LIST
49561: PUSH
49562: LD_INT 42
49564: PUSH
49565: LD_INT 43
49567: PUSH
49568: EMPTY
49569: LIST
49570: LIST
49571: PUSH
49572: LD_INT 44
49574: PUSH
49575: LD_INT 46
49577: PUSH
49578: EMPTY
49579: LIST
49580: LIST
49581: PUSH
49582: LD_INT 45
49584: PUSH
49585: LD_INT 47
49587: PUSH
49588: EMPTY
49589: LIST
49590: LIST
49591: PUSH
49592: EMPTY
49593: LIST
49594: LIST
49595: LIST
49596: PUSH
49597: EMPTY
49598: LIST
49599: LIST
49600: LIST
49601: ST_TO_ADDR
// result := [ ] ;
49602: LD_ADDR_VAR 0 3
49606: PUSH
49607: EMPTY
49608: ST_TO_ADDR
// for i in turrets do
49609: LD_ADDR_VAR 0 4
49613: PUSH
49614: LD_VAR 0 1
49618: PUSH
49619: FOR_IN
49620: IFFALSE 49803
// begin nat := GetNation ( i ) ;
49622: LD_ADDR_VAR 0 7
49626: PUSH
49627: LD_VAR 0 4
49631: PPUSH
49632: CALL_OW 248
49636: ST_TO_ADDR
// weapon := 0 ;
49637: LD_ADDR_VAR 0 8
49641: PUSH
49642: LD_INT 0
49644: ST_TO_ADDR
// if not nat then
49645: LD_VAR 0 7
49649: NOT
49650: IFFALSE 49654
// continue ;
49652: GO 49619
// for j in list [ nat ] do
49654: LD_ADDR_VAR 0 5
49658: PUSH
49659: LD_VAR 0 10
49663: PUSH
49664: LD_VAR 0 7
49668: ARRAY
49669: PUSH
49670: FOR_IN
49671: IFFALSE 49712
// if GetBWeapon ( i ) = j [ 1 ] then
49673: LD_VAR 0 4
49677: PPUSH
49678: CALL_OW 269
49682: PUSH
49683: LD_VAR 0 5
49687: PUSH
49688: LD_INT 1
49690: ARRAY
49691: EQUAL
49692: IFFALSE 49710
// begin weapon := j [ 2 ] ;
49694: LD_ADDR_VAR 0 8
49698: PUSH
49699: LD_VAR 0 5
49703: PUSH
49704: LD_INT 2
49706: ARRAY
49707: ST_TO_ADDR
// break ;
49708: GO 49712
// end ;
49710: GO 49670
49712: POP
49713: POP
// if not weapon then
49714: LD_VAR 0 8
49718: NOT
49719: IFFALSE 49723
// continue ;
49721: GO 49619
// for k in factories do
49723: LD_ADDR_VAR 0 6
49727: PUSH
49728: LD_VAR 0 2
49732: PUSH
49733: FOR_IN
49734: IFFALSE 49799
// begin weapons := AvailableWeaponList ( k ) ;
49736: LD_ADDR_VAR 0 9
49740: PUSH
49741: LD_VAR 0 6
49745: PPUSH
49746: CALL_OW 478
49750: ST_TO_ADDR
// if not weapons then
49751: LD_VAR 0 9
49755: NOT
49756: IFFALSE 49760
// continue ;
49758: GO 49733
// if weapon in weapons then
49760: LD_VAR 0 8
49764: PUSH
49765: LD_VAR 0 9
49769: IN
49770: IFFALSE 49797
// begin result := [ i , weapon ] ;
49772: LD_ADDR_VAR 0 3
49776: PUSH
49777: LD_VAR 0 4
49781: PUSH
49782: LD_VAR 0 8
49786: PUSH
49787: EMPTY
49788: LIST
49789: LIST
49790: ST_TO_ADDR
// exit ;
49791: POP
49792: POP
49793: POP
49794: POP
49795: GO 49805
// end ; end ;
49797: GO 49733
49799: POP
49800: POP
// end ;
49801: GO 49619
49803: POP
49804: POP
// end ;
49805: LD_VAR 0 3
49809: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
49810: LD_INT 0
49812: PPUSH
// if not side or side > 8 then
49813: LD_VAR 0 3
49817: NOT
49818: PUSH
49819: LD_VAR 0 3
49823: PUSH
49824: LD_INT 8
49826: GREATER
49827: OR
49828: IFFALSE 49832
// exit ;
49830: GO 49891
// if not range then
49832: LD_VAR 0 4
49836: NOT
49837: IFFALSE 49848
// range := - 12 ;
49839: LD_ADDR_VAR 0 4
49843: PUSH
49844: LD_INT 12
49846: NEG
49847: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
49848: LD_VAR 0 1
49852: PPUSH
49853: LD_VAR 0 2
49857: PPUSH
49858: LD_VAR 0 3
49862: PPUSH
49863: LD_VAR 0 4
49867: PPUSH
49868: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
49872: LD_VAR 0 1
49876: PPUSH
49877: LD_VAR 0 2
49881: PPUSH
49882: LD_VAR 0 3
49886: PPUSH
49887: CALL_OW 331
// end ;
49891: LD_VAR 0 5
49895: RET
// export function Video ( mode ) ; begin
49896: LD_INT 0
49898: PPUSH
// ingame_video = mode ;
49899: LD_ADDR_OWVAR 52
49903: PUSH
49904: LD_VAR 0 1
49908: ST_TO_ADDR
// interface_hidden = mode ;
49909: LD_ADDR_OWVAR 54
49913: PUSH
49914: LD_VAR 0 1
49918: ST_TO_ADDR
// end ;
49919: LD_VAR 0 2
49923: RET
// export function Join ( array , element ) ; begin
49924: LD_INT 0
49926: PPUSH
// result := Replace ( array , array + 1 , element ) ;
49927: LD_ADDR_VAR 0 3
49931: PUSH
49932: LD_VAR 0 1
49936: PPUSH
49937: LD_VAR 0 1
49941: PUSH
49942: LD_INT 1
49944: PLUS
49945: PPUSH
49946: LD_VAR 0 2
49950: PPUSH
49951: CALL_OW 1
49955: ST_TO_ADDR
// end ;
49956: LD_VAR 0 3
49960: RET
// export function JoinUnion ( array , element ) ; begin
49961: LD_INT 0
49963: PPUSH
// result := array union element ;
49964: LD_ADDR_VAR 0 3
49968: PUSH
49969: LD_VAR 0 1
49973: PUSH
49974: LD_VAR 0 2
49978: UNION
49979: ST_TO_ADDR
// end ;
49980: LD_VAR 0 3
49984: RET
// export function GetBehemoths ( side ) ; begin
49985: LD_INT 0
49987: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
49988: LD_ADDR_VAR 0 2
49992: PUSH
49993: LD_INT 22
49995: PUSH
49996: LD_VAR 0 1
50000: PUSH
50001: EMPTY
50002: LIST
50003: LIST
50004: PUSH
50005: LD_INT 31
50007: PUSH
50008: LD_INT 25
50010: PUSH
50011: EMPTY
50012: LIST
50013: LIST
50014: PUSH
50015: EMPTY
50016: LIST
50017: LIST
50018: PPUSH
50019: CALL_OW 69
50023: ST_TO_ADDR
// end ;
50024: LD_VAR 0 2
50028: RET
// export function Shuffle ( array ) ; var i , index ; begin
50029: LD_INT 0
50031: PPUSH
50032: PPUSH
50033: PPUSH
// result := [ ] ;
50034: LD_ADDR_VAR 0 2
50038: PUSH
50039: EMPTY
50040: ST_TO_ADDR
// if not array then
50041: LD_VAR 0 1
50045: NOT
50046: IFFALSE 50050
// exit ;
50048: GO 50149
// Randomize ;
50050: CALL_OW 10
// for i = array downto 1 do
50054: LD_ADDR_VAR 0 3
50058: PUSH
50059: DOUBLE
50060: LD_VAR 0 1
50064: INC
50065: ST_TO_ADDR
50066: LD_INT 1
50068: PUSH
50069: FOR_DOWNTO
50070: IFFALSE 50147
// begin index := rand ( 1 , array ) ;
50072: LD_ADDR_VAR 0 4
50076: PUSH
50077: LD_INT 1
50079: PPUSH
50080: LD_VAR 0 1
50084: PPUSH
50085: CALL_OW 12
50089: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
50090: LD_ADDR_VAR 0 2
50094: PUSH
50095: LD_VAR 0 2
50099: PPUSH
50100: LD_VAR 0 2
50104: PUSH
50105: LD_INT 1
50107: PLUS
50108: PPUSH
50109: LD_VAR 0 1
50113: PUSH
50114: LD_VAR 0 4
50118: ARRAY
50119: PPUSH
50120: CALL_OW 2
50124: ST_TO_ADDR
// array := Delete ( array , index ) ;
50125: LD_ADDR_VAR 0 1
50129: PUSH
50130: LD_VAR 0 1
50134: PPUSH
50135: LD_VAR 0 4
50139: PPUSH
50140: CALL_OW 3
50144: ST_TO_ADDR
// end ;
50145: GO 50069
50147: POP
50148: POP
// end ;
50149: LD_VAR 0 2
50153: RET
// export function GetBaseMaterials ( base ) ; begin
50154: LD_INT 0
50156: PPUSH
// result := [ 0 , 0 , 0 ] ;
50157: LD_ADDR_VAR 0 2
50161: PUSH
50162: LD_INT 0
50164: PUSH
50165: LD_INT 0
50167: PUSH
50168: LD_INT 0
50170: PUSH
50171: EMPTY
50172: LIST
50173: LIST
50174: LIST
50175: ST_TO_ADDR
// if not base then
50176: LD_VAR 0 1
50180: NOT
50181: IFFALSE 50185
// exit ;
50183: GO 50234
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
50185: LD_ADDR_VAR 0 2
50189: PUSH
50190: LD_VAR 0 1
50194: PPUSH
50195: LD_INT 1
50197: PPUSH
50198: CALL_OW 275
50202: PUSH
50203: LD_VAR 0 1
50207: PPUSH
50208: LD_INT 2
50210: PPUSH
50211: CALL_OW 275
50215: PUSH
50216: LD_VAR 0 1
50220: PPUSH
50221: LD_INT 3
50223: PPUSH
50224: CALL_OW 275
50228: PUSH
50229: EMPTY
50230: LIST
50231: LIST
50232: LIST
50233: ST_TO_ADDR
// end ;
50234: LD_VAR 0 2
50238: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
50239: LD_INT 0
50241: PPUSH
50242: PPUSH
// result := array ;
50243: LD_ADDR_VAR 0 3
50247: PUSH
50248: LD_VAR 0 1
50252: ST_TO_ADDR
// if size > 0 then
50253: LD_VAR 0 2
50257: PUSH
50258: LD_INT 0
50260: GREATER
50261: IFFALSE 50307
// for i := array downto size do
50263: LD_ADDR_VAR 0 4
50267: PUSH
50268: DOUBLE
50269: LD_VAR 0 1
50273: INC
50274: ST_TO_ADDR
50275: LD_VAR 0 2
50279: PUSH
50280: FOR_DOWNTO
50281: IFFALSE 50305
// result := Delete ( result , result ) ;
50283: LD_ADDR_VAR 0 3
50287: PUSH
50288: LD_VAR 0 3
50292: PPUSH
50293: LD_VAR 0 3
50297: PPUSH
50298: CALL_OW 3
50302: ST_TO_ADDR
50303: GO 50280
50305: POP
50306: POP
// end ;
50307: LD_VAR 0 3
50311: RET
// export function ComExit ( unit ) ; var tmp ; begin
50312: LD_INT 0
50314: PPUSH
50315: PPUSH
// if not IsInUnit ( unit ) then
50316: LD_VAR 0 1
50320: PPUSH
50321: CALL_OW 310
50325: NOT
50326: IFFALSE 50330
// exit ;
50328: GO 50390
// tmp := IsInUnit ( unit ) ;
50330: LD_ADDR_VAR 0 3
50334: PUSH
50335: LD_VAR 0 1
50339: PPUSH
50340: CALL_OW 310
50344: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
50345: LD_VAR 0 3
50349: PPUSH
50350: CALL_OW 247
50354: PUSH
50355: LD_INT 2
50357: EQUAL
50358: IFFALSE 50371
// ComExitVehicle ( unit ) else
50360: LD_VAR 0 1
50364: PPUSH
50365: CALL_OW 121
50369: GO 50380
// ComExitBuilding ( unit ) ;
50371: LD_VAR 0 1
50375: PPUSH
50376: CALL_OW 122
// result := tmp ;
50380: LD_ADDR_VAR 0 2
50384: PUSH
50385: LD_VAR 0 3
50389: ST_TO_ADDR
// end ;
50390: LD_VAR 0 2
50394: RET
// export function ComExitAll ( units ) ; var i ; begin
50395: LD_INT 0
50397: PPUSH
50398: PPUSH
// if not units then
50399: LD_VAR 0 1
50403: NOT
50404: IFFALSE 50408
// exit ;
50406: GO 50434
// for i in units do
50408: LD_ADDR_VAR 0 3
50412: PUSH
50413: LD_VAR 0 1
50417: PUSH
50418: FOR_IN
50419: IFFALSE 50432
// ComExit ( i ) ;
50421: LD_VAR 0 3
50425: PPUSH
50426: CALL 50312 0 1
50430: GO 50418
50432: POP
50433: POP
// end ;
50434: LD_VAR 0 2
50438: RET
// export function ResetHc ; begin
50439: LD_INT 0
50441: PPUSH
// InitHc ;
50442: CALL_OW 19
// hc_importance := 0 ;
50446: LD_ADDR_OWVAR 32
50450: PUSH
50451: LD_INT 0
50453: ST_TO_ADDR
// end ;
50454: LD_VAR 0 1
50458: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
50459: LD_INT 0
50461: PPUSH
50462: PPUSH
50463: PPUSH
// _x := ( x1 + x2 ) div 2 ;
50464: LD_ADDR_VAR 0 6
50468: PUSH
50469: LD_VAR 0 1
50473: PUSH
50474: LD_VAR 0 3
50478: PLUS
50479: PUSH
50480: LD_INT 2
50482: DIV
50483: ST_TO_ADDR
// if _x < 0 then
50484: LD_VAR 0 6
50488: PUSH
50489: LD_INT 0
50491: LESS
50492: IFFALSE 50509
// _x := _x * - 1 ;
50494: LD_ADDR_VAR 0 6
50498: PUSH
50499: LD_VAR 0 6
50503: PUSH
50504: LD_INT 1
50506: NEG
50507: MUL
50508: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
50509: LD_ADDR_VAR 0 7
50513: PUSH
50514: LD_VAR 0 2
50518: PUSH
50519: LD_VAR 0 4
50523: PLUS
50524: PUSH
50525: LD_INT 2
50527: DIV
50528: ST_TO_ADDR
// if _y < 0 then
50529: LD_VAR 0 7
50533: PUSH
50534: LD_INT 0
50536: LESS
50537: IFFALSE 50554
// _y := _y * - 1 ;
50539: LD_ADDR_VAR 0 7
50543: PUSH
50544: LD_VAR 0 7
50548: PUSH
50549: LD_INT 1
50551: NEG
50552: MUL
50553: ST_TO_ADDR
// result := [ _x , _y ] ;
50554: LD_ADDR_VAR 0 5
50558: PUSH
50559: LD_VAR 0 6
50563: PUSH
50564: LD_VAR 0 7
50568: PUSH
50569: EMPTY
50570: LIST
50571: LIST
50572: ST_TO_ADDR
// end ;
50573: LD_VAR 0 5
50577: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
50578: LD_INT 0
50580: PPUSH
50581: PPUSH
50582: PPUSH
50583: PPUSH
// task := GetTaskList ( unit ) ;
50584: LD_ADDR_VAR 0 7
50588: PUSH
50589: LD_VAR 0 1
50593: PPUSH
50594: CALL_OW 437
50598: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
50599: LD_VAR 0 7
50603: NOT
50604: PUSH
50605: LD_VAR 0 1
50609: PPUSH
50610: LD_VAR 0 2
50614: PPUSH
50615: CALL_OW 308
50619: NOT
50620: AND
50621: IFFALSE 50625
// exit ;
50623: GO 50743
// if IsInArea ( unit , area ) then
50625: LD_VAR 0 1
50629: PPUSH
50630: LD_VAR 0 2
50634: PPUSH
50635: CALL_OW 308
50639: IFFALSE 50657
// begin ComMoveToArea ( unit , goAway ) ;
50641: LD_VAR 0 1
50645: PPUSH
50646: LD_VAR 0 3
50650: PPUSH
50651: CALL_OW 113
// exit ;
50655: GO 50743
// end ; if task [ 1 ] [ 1 ] <> M then
50657: LD_VAR 0 7
50661: PUSH
50662: LD_INT 1
50664: ARRAY
50665: PUSH
50666: LD_INT 1
50668: ARRAY
50669: PUSH
50670: LD_STRING M
50672: NONEQUAL
50673: IFFALSE 50677
// exit ;
50675: GO 50743
// x := task [ 1 ] [ 2 ] ;
50677: LD_ADDR_VAR 0 5
50681: PUSH
50682: LD_VAR 0 7
50686: PUSH
50687: LD_INT 1
50689: ARRAY
50690: PUSH
50691: LD_INT 2
50693: ARRAY
50694: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
50695: LD_ADDR_VAR 0 6
50699: PUSH
50700: LD_VAR 0 7
50704: PUSH
50705: LD_INT 1
50707: ARRAY
50708: PUSH
50709: LD_INT 3
50711: ARRAY
50712: ST_TO_ADDR
// if InArea ( x , y , area ) then
50713: LD_VAR 0 5
50717: PPUSH
50718: LD_VAR 0 6
50722: PPUSH
50723: LD_VAR 0 2
50727: PPUSH
50728: CALL_OW 309
50732: IFFALSE 50743
// ComStop ( unit ) ;
50734: LD_VAR 0 1
50738: PPUSH
50739: CALL_OW 141
// end ;
50743: LD_VAR 0 4
50747: RET
// export function Abs ( value ) ; begin
50748: LD_INT 0
50750: PPUSH
// result := value ;
50751: LD_ADDR_VAR 0 2
50755: PUSH
50756: LD_VAR 0 1
50760: ST_TO_ADDR
// if value < 0 then
50761: LD_VAR 0 1
50765: PUSH
50766: LD_INT 0
50768: LESS
50769: IFFALSE 50786
// result := value * - 1 ;
50771: LD_ADDR_VAR 0 2
50775: PUSH
50776: LD_VAR 0 1
50780: PUSH
50781: LD_INT 1
50783: NEG
50784: MUL
50785: ST_TO_ADDR
// end ;
50786: LD_VAR 0 2
50790: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
50791: LD_INT 0
50793: PPUSH
50794: PPUSH
50795: PPUSH
50796: PPUSH
50797: PPUSH
50798: PPUSH
50799: PPUSH
50800: PPUSH
// if not unit or not building then
50801: LD_VAR 0 1
50805: NOT
50806: PUSH
50807: LD_VAR 0 2
50811: NOT
50812: OR
50813: IFFALSE 50817
// exit ;
50815: GO 51043
// x := GetX ( building ) ;
50817: LD_ADDR_VAR 0 4
50821: PUSH
50822: LD_VAR 0 2
50826: PPUSH
50827: CALL_OW 250
50831: ST_TO_ADDR
// y := GetY ( building ) ;
50832: LD_ADDR_VAR 0 6
50836: PUSH
50837: LD_VAR 0 2
50841: PPUSH
50842: CALL_OW 251
50846: ST_TO_ADDR
// d := GetDir ( building ) ;
50847: LD_ADDR_VAR 0 8
50851: PUSH
50852: LD_VAR 0 2
50856: PPUSH
50857: CALL_OW 254
50861: ST_TO_ADDR
// r := 4 ;
50862: LD_ADDR_VAR 0 9
50866: PUSH
50867: LD_INT 4
50869: ST_TO_ADDR
// for i := 1 to 5 do
50870: LD_ADDR_VAR 0 10
50874: PUSH
50875: DOUBLE
50876: LD_INT 1
50878: DEC
50879: ST_TO_ADDR
50880: LD_INT 5
50882: PUSH
50883: FOR_TO
50884: IFFALSE 51041
// begin _x := ShiftX ( x , d , r + i ) ;
50886: LD_ADDR_VAR 0 5
50890: PUSH
50891: LD_VAR 0 4
50895: PPUSH
50896: LD_VAR 0 8
50900: PPUSH
50901: LD_VAR 0 9
50905: PUSH
50906: LD_VAR 0 10
50910: PLUS
50911: PPUSH
50912: CALL_OW 272
50916: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
50917: LD_ADDR_VAR 0 7
50921: PUSH
50922: LD_VAR 0 6
50926: PPUSH
50927: LD_VAR 0 8
50931: PPUSH
50932: LD_VAR 0 9
50936: PUSH
50937: LD_VAR 0 10
50941: PLUS
50942: PPUSH
50943: CALL_OW 273
50947: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
50948: LD_VAR 0 5
50952: PPUSH
50953: LD_VAR 0 7
50957: PPUSH
50958: CALL_OW 488
50962: PUSH
50963: LD_VAR 0 5
50967: PPUSH
50968: LD_VAR 0 7
50972: PPUSH
50973: CALL_OW 428
50977: PPUSH
50978: CALL_OW 247
50982: PUSH
50983: LD_INT 3
50985: PUSH
50986: LD_INT 2
50988: PUSH
50989: EMPTY
50990: LIST
50991: LIST
50992: IN
50993: NOT
50994: AND
50995: IFFALSE 51039
// begin ComMoveXY ( unit , _x , _y ) ;
50997: LD_VAR 0 1
51001: PPUSH
51002: LD_VAR 0 5
51006: PPUSH
51007: LD_VAR 0 7
51011: PPUSH
51012: CALL_OW 111
// result := [ _x , _y ] ;
51016: LD_ADDR_VAR 0 3
51020: PUSH
51021: LD_VAR 0 5
51025: PUSH
51026: LD_VAR 0 7
51030: PUSH
51031: EMPTY
51032: LIST
51033: LIST
51034: ST_TO_ADDR
// exit ;
51035: POP
51036: POP
51037: GO 51043
// end ; end ;
51039: GO 50883
51041: POP
51042: POP
// end ;
51043: LD_VAR 0 3
51047: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
51048: LD_INT 0
51050: PPUSH
51051: PPUSH
51052: PPUSH
// result := 0 ;
51053: LD_ADDR_VAR 0 3
51057: PUSH
51058: LD_INT 0
51060: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
51061: LD_VAR 0 1
51065: PUSH
51066: LD_INT 0
51068: LESS
51069: PUSH
51070: LD_VAR 0 1
51074: PUSH
51075: LD_INT 8
51077: GREATER
51078: OR
51079: PUSH
51080: LD_VAR 0 2
51084: PUSH
51085: LD_INT 0
51087: LESS
51088: OR
51089: PUSH
51090: LD_VAR 0 2
51094: PUSH
51095: LD_INT 8
51097: GREATER
51098: OR
51099: IFFALSE 51103
// exit ;
51101: GO 51178
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
51103: LD_ADDR_VAR 0 4
51107: PUSH
51108: LD_INT 22
51110: PUSH
51111: LD_VAR 0 2
51115: PUSH
51116: EMPTY
51117: LIST
51118: LIST
51119: PPUSH
51120: CALL_OW 69
51124: PUSH
51125: FOR_IN
51126: IFFALSE 51176
// begin un := UnitShoot ( i ) ;
51128: LD_ADDR_VAR 0 5
51132: PUSH
51133: LD_VAR 0 4
51137: PPUSH
51138: CALL_OW 504
51142: ST_TO_ADDR
// if GetSide ( un ) = side1 then
51143: LD_VAR 0 5
51147: PPUSH
51148: CALL_OW 255
51152: PUSH
51153: LD_VAR 0 1
51157: EQUAL
51158: IFFALSE 51174
// begin result := un ;
51160: LD_ADDR_VAR 0 3
51164: PUSH
51165: LD_VAR 0 5
51169: ST_TO_ADDR
// exit ;
51170: POP
51171: POP
51172: GO 51178
// end ; end ;
51174: GO 51125
51176: POP
51177: POP
// end ;
51178: LD_VAR 0 3
51182: RET
// export function GetCargoBay ( units ) ; begin
51183: LD_INT 0
51185: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
51186: LD_ADDR_VAR 0 2
51190: PUSH
51191: LD_VAR 0 1
51195: PPUSH
51196: LD_INT 2
51198: PUSH
51199: LD_INT 34
51201: PUSH
51202: LD_INT 12
51204: PUSH
51205: EMPTY
51206: LIST
51207: LIST
51208: PUSH
51209: LD_INT 34
51211: PUSH
51212: LD_INT 51
51214: PUSH
51215: EMPTY
51216: LIST
51217: LIST
51218: PUSH
51219: LD_INT 34
51221: PUSH
51222: LD_INT 32
51224: PUSH
51225: EMPTY
51226: LIST
51227: LIST
51228: PUSH
51229: LD_INT 34
51231: PUSH
51232: LD_EXP 49
51236: PUSH
51237: EMPTY
51238: LIST
51239: LIST
51240: PUSH
51241: EMPTY
51242: LIST
51243: LIST
51244: LIST
51245: LIST
51246: LIST
51247: PPUSH
51248: CALL_OW 72
51252: ST_TO_ADDR
// end ; end_of_file
51253: LD_VAR 0 2
51257: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
51258: LD_INT 0
51260: PPUSH
// ar_miner := 81 ;
51261: LD_ADDR_EXP 55
51265: PUSH
51266: LD_INT 81
51268: ST_TO_ADDR
// ar_crane := 88 ;
51269: LD_ADDR_EXP 54
51273: PUSH
51274: LD_INT 88
51276: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
51277: LD_ADDR_EXP 49
51281: PUSH
51282: LD_INT 89
51284: ST_TO_ADDR
// us_hack := 99 ;
51285: LD_ADDR_EXP 50
51289: PUSH
51290: LD_INT 99
51292: ST_TO_ADDR
// us_artillery := 97 ;
51293: LD_ADDR_EXP 51
51297: PUSH
51298: LD_INT 97
51300: ST_TO_ADDR
// ar_bio_bomb := 91 ;
51301: LD_ADDR_EXP 52
51305: PUSH
51306: LD_INT 91
51308: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
51309: LD_ADDR_EXP 53
51313: PUSH
51314: LD_INT 92
51316: ST_TO_ADDR
// ru_radar := 98 ;
51317: LD_ADDR_EXP 48
51321: PUSH
51322: LD_INT 98
51324: ST_TO_ADDR
// tech_Artillery := 80 ;
51325: LD_ADDR_EXP 56
51329: PUSH
51330: LD_INT 80
51332: ST_TO_ADDR
// tech_RadMat := 81 ;
51333: LD_ADDR_EXP 57
51337: PUSH
51338: LD_INT 81
51340: ST_TO_ADDR
// tech_BasicTools := 82 ;
51341: LD_ADDR_EXP 58
51345: PUSH
51346: LD_INT 82
51348: ST_TO_ADDR
// tech_Cargo := 83 ;
51349: LD_ADDR_EXP 59
51353: PUSH
51354: LD_INT 83
51356: ST_TO_ADDR
// tech_Track := 84 ;
51357: LD_ADDR_EXP 60
51361: PUSH
51362: LD_INT 84
51364: ST_TO_ADDR
// tech_Crane := 85 ;
51365: LD_ADDR_EXP 61
51369: PUSH
51370: LD_INT 85
51372: ST_TO_ADDR
// tech_Bulldozer := 86 ;
51373: LD_ADDR_EXP 62
51377: PUSH
51378: LD_INT 86
51380: ST_TO_ADDR
// tech_Hovercraft := 87 ;
51381: LD_ADDR_EXP 63
51385: PUSH
51386: LD_INT 87
51388: ST_TO_ADDR
// class_mastodont := 31 ;
51389: LD_ADDR_EXP 64
51393: PUSH
51394: LD_INT 31
51396: ST_TO_ADDR
// class_horse := 21 ;
51397: LD_ADDR_EXP 65
51401: PUSH
51402: LD_INT 21
51404: ST_TO_ADDR
// end ;
51405: LD_VAR 0 1
51409: RET
// every 1 do
51410: GO 51412
51412: DISABLE
// InitGlobalVariables ; end_of_file
51413: CALL 51258 0 0
51417: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
51418: LD_INT 0
51420: PPUSH
51421: PPUSH
// skirmish := false ;
51422: LD_ADDR_EXP 66
51426: PUSH
51427: LD_INT 0
51429: ST_TO_ADDR
// debug_mc := false ;
51430: LD_ADDR_EXP 67
51434: PUSH
51435: LD_INT 0
51437: ST_TO_ADDR
// mc_bases := [ ] ;
51438: LD_ADDR_EXP 68
51442: PUSH
51443: EMPTY
51444: ST_TO_ADDR
// mc_sides := [ ] ;
51445: LD_ADDR_EXP 94
51449: PUSH
51450: EMPTY
51451: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
51452: LD_ADDR_EXP 69
51456: PUSH
51457: EMPTY
51458: ST_TO_ADDR
// mc_building_repairs := [ ] ;
51459: LD_ADDR_EXP 70
51463: PUSH
51464: EMPTY
51465: ST_TO_ADDR
// mc_need_heal := [ ] ;
51466: LD_ADDR_EXP 71
51470: PUSH
51471: EMPTY
51472: ST_TO_ADDR
// mc_healers := [ ] ;
51473: LD_ADDR_EXP 72
51477: PUSH
51478: EMPTY
51479: ST_TO_ADDR
// mc_build_list := [ ] ;
51480: LD_ADDR_EXP 73
51484: PUSH
51485: EMPTY
51486: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
51487: LD_ADDR_EXP 100
51491: PUSH
51492: EMPTY
51493: ST_TO_ADDR
// mc_builders := [ ] ;
51494: LD_ADDR_EXP 74
51498: PUSH
51499: EMPTY
51500: ST_TO_ADDR
// mc_construct_list := [ ] ;
51501: LD_ADDR_EXP 75
51505: PUSH
51506: EMPTY
51507: ST_TO_ADDR
// mc_turret_list := [ ] ;
51508: LD_ADDR_EXP 76
51512: PUSH
51513: EMPTY
51514: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
51515: LD_ADDR_EXP 77
51519: PUSH
51520: EMPTY
51521: ST_TO_ADDR
// mc_miners := [ ] ;
51522: LD_ADDR_EXP 82
51526: PUSH
51527: EMPTY
51528: ST_TO_ADDR
// mc_mines := [ ] ;
51529: LD_ADDR_EXP 81
51533: PUSH
51534: EMPTY
51535: ST_TO_ADDR
// mc_minefields := [ ] ;
51536: LD_ADDR_EXP 83
51540: PUSH
51541: EMPTY
51542: ST_TO_ADDR
// mc_crates := [ ] ;
51543: LD_ADDR_EXP 84
51547: PUSH
51548: EMPTY
51549: ST_TO_ADDR
// mc_crates_collector := [ ] ;
51550: LD_ADDR_EXP 85
51554: PUSH
51555: EMPTY
51556: ST_TO_ADDR
// mc_crates_area := [ ] ;
51557: LD_ADDR_EXP 86
51561: PUSH
51562: EMPTY
51563: ST_TO_ADDR
// mc_vehicles := [ ] ;
51564: LD_ADDR_EXP 87
51568: PUSH
51569: EMPTY
51570: ST_TO_ADDR
// mc_attack := [ ] ;
51571: LD_ADDR_EXP 88
51575: PUSH
51576: EMPTY
51577: ST_TO_ADDR
// mc_produce := [ ] ;
51578: LD_ADDR_EXP 89
51582: PUSH
51583: EMPTY
51584: ST_TO_ADDR
// mc_defender := [ ] ;
51585: LD_ADDR_EXP 90
51589: PUSH
51590: EMPTY
51591: ST_TO_ADDR
// mc_parking := [ ] ;
51592: LD_ADDR_EXP 92
51596: PUSH
51597: EMPTY
51598: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51599: LD_ADDR_EXP 78
51603: PUSH
51604: EMPTY
51605: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51606: LD_ADDR_EXP 80
51610: PUSH
51611: EMPTY
51612: ST_TO_ADDR
// mc_scan := [ ] ;
51613: LD_ADDR_EXP 91
51617: PUSH
51618: EMPTY
51619: ST_TO_ADDR
// mc_scan_area := [ ] ;
51620: LD_ADDR_EXP 93
51624: PUSH
51625: EMPTY
51626: ST_TO_ADDR
// mc_tech := [ ] ;
51627: LD_ADDR_EXP 95
51631: PUSH
51632: EMPTY
51633: ST_TO_ADDR
// mc_class := [ ] ;
51634: LD_ADDR_EXP 109
51638: PUSH
51639: EMPTY
51640: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51641: LD_ADDR_EXP 110
51645: PUSH
51646: EMPTY
51647: ST_TO_ADDR
// mc_is_defending := [ ] ;
51648: LD_ADDR_EXP 111
51652: PUSH
51653: EMPTY
51654: ST_TO_ADDR
// end ;
51655: LD_VAR 0 1
51659: RET
// export function MC_Kill ( base ) ; begin
51660: LD_INT 0
51662: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51663: LD_ADDR_EXP 68
51667: PUSH
51668: LD_EXP 68
51672: PPUSH
51673: LD_VAR 0 1
51677: PPUSH
51678: EMPTY
51679: PPUSH
51680: CALL_OW 1
51684: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51685: LD_ADDR_EXP 69
51689: PUSH
51690: LD_EXP 69
51694: PPUSH
51695: LD_VAR 0 1
51699: PPUSH
51700: EMPTY
51701: PPUSH
51702: CALL_OW 1
51706: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51707: LD_ADDR_EXP 70
51711: PUSH
51712: LD_EXP 70
51716: PPUSH
51717: LD_VAR 0 1
51721: PPUSH
51722: EMPTY
51723: PPUSH
51724: CALL_OW 1
51728: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51729: LD_ADDR_EXP 71
51733: PUSH
51734: LD_EXP 71
51738: PPUSH
51739: LD_VAR 0 1
51743: PPUSH
51744: EMPTY
51745: PPUSH
51746: CALL_OW 1
51750: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51751: LD_ADDR_EXP 72
51755: PUSH
51756: LD_EXP 72
51760: PPUSH
51761: LD_VAR 0 1
51765: PPUSH
51766: EMPTY
51767: PPUSH
51768: CALL_OW 1
51772: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51773: LD_ADDR_EXP 73
51777: PUSH
51778: LD_EXP 73
51782: PPUSH
51783: LD_VAR 0 1
51787: PPUSH
51788: EMPTY
51789: PPUSH
51790: CALL_OW 1
51794: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51795: LD_ADDR_EXP 74
51799: PUSH
51800: LD_EXP 74
51804: PPUSH
51805: LD_VAR 0 1
51809: PPUSH
51810: EMPTY
51811: PPUSH
51812: CALL_OW 1
51816: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51817: LD_ADDR_EXP 75
51821: PUSH
51822: LD_EXP 75
51826: PPUSH
51827: LD_VAR 0 1
51831: PPUSH
51832: EMPTY
51833: PPUSH
51834: CALL_OW 1
51838: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51839: LD_ADDR_EXP 76
51843: PUSH
51844: LD_EXP 76
51848: PPUSH
51849: LD_VAR 0 1
51853: PPUSH
51854: EMPTY
51855: PPUSH
51856: CALL_OW 1
51860: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51861: LD_ADDR_EXP 77
51865: PUSH
51866: LD_EXP 77
51870: PPUSH
51871: LD_VAR 0 1
51875: PPUSH
51876: EMPTY
51877: PPUSH
51878: CALL_OW 1
51882: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51883: LD_ADDR_EXP 78
51887: PUSH
51888: LD_EXP 78
51892: PPUSH
51893: LD_VAR 0 1
51897: PPUSH
51898: EMPTY
51899: PPUSH
51900: CALL_OW 1
51904: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51905: LD_ADDR_EXP 79
51909: PUSH
51910: LD_EXP 79
51914: PPUSH
51915: LD_VAR 0 1
51919: PPUSH
51920: LD_INT 0
51922: PPUSH
51923: CALL_OW 1
51927: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51928: LD_ADDR_EXP 80
51932: PUSH
51933: LD_EXP 80
51937: PPUSH
51938: LD_VAR 0 1
51942: PPUSH
51943: EMPTY
51944: PPUSH
51945: CALL_OW 1
51949: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51950: LD_ADDR_EXP 81
51954: PUSH
51955: LD_EXP 81
51959: PPUSH
51960: LD_VAR 0 1
51964: PPUSH
51965: EMPTY
51966: PPUSH
51967: CALL_OW 1
51971: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51972: LD_ADDR_EXP 82
51976: PUSH
51977: LD_EXP 82
51981: PPUSH
51982: LD_VAR 0 1
51986: PPUSH
51987: EMPTY
51988: PPUSH
51989: CALL_OW 1
51993: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51994: LD_ADDR_EXP 83
51998: PUSH
51999: LD_EXP 83
52003: PPUSH
52004: LD_VAR 0 1
52008: PPUSH
52009: EMPTY
52010: PPUSH
52011: CALL_OW 1
52015: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52016: LD_ADDR_EXP 84
52020: PUSH
52021: LD_EXP 84
52025: PPUSH
52026: LD_VAR 0 1
52030: PPUSH
52031: EMPTY
52032: PPUSH
52033: CALL_OW 1
52037: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52038: LD_ADDR_EXP 85
52042: PUSH
52043: LD_EXP 85
52047: PPUSH
52048: LD_VAR 0 1
52052: PPUSH
52053: EMPTY
52054: PPUSH
52055: CALL_OW 1
52059: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52060: LD_ADDR_EXP 86
52064: PUSH
52065: LD_EXP 86
52069: PPUSH
52070: LD_VAR 0 1
52074: PPUSH
52075: EMPTY
52076: PPUSH
52077: CALL_OW 1
52081: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52082: LD_ADDR_EXP 87
52086: PUSH
52087: LD_EXP 87
52091: PPUSH
52092: LD_VAR 0 1
52096: PPUSH
52097: EMPTY
52098: PPUSH
52099: CALL_OW 1
52103: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52104: LD_ADDR_EXP 88
52108: PUSH
52109: LD_EXP 88
52113: PPUSH
52114: LD_VAR 0 1
52118: PPUSH
52119: EMPTY
52120: PPUSH
52121: CALL_OW 1
52125: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52126: LD_ADDR_EXP 89
52130: PUSH
52131: LD_EXP 89
52135: PPUSH
52136: LD_VAR 0 1
52140: PPUSH
52141: EMPTY
52142: PPUSH
52143: CALL_OW 1
52147: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52148: LD_ADDR_EXP 90
52152: PUSH
52153: LD_EXP 90
52157: PPUSH
52158: LD_VAR 0 1
52162: PPUSH
52163: EMPTY
52164: PPUSH
52165: CALL_OW 1
52169: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52170: LD_ADDR_EXP 91
52174: PUSH
52175: LD_EXP 91
52179: PPUSH
52180: LD_VAR 0 1
52184: PPUSH
52185: EMPTY
52186: PPUSH
52187: CALL_OW 1
52191: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52192: LD_ADDR_EXP 92
52196: PUSH
52197: LD_EXP 92
52201: PPUSH
52202: LD_VAR 0 1
52206: PPUSH
52207: EMPTY
52208: PPUSH
52209: CALL_OW 1
52213: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52214: LD_ADDR_EXP 93
52218: PUSH
52219: LD_EXP 93
52223: PPUSH
52224: LD_VAR 0 1
52228: PPUSH
52229: EMPTY
52230: PPUSH
52231: CALL_OW 1
52235: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52236: LD_ADDR_EXP 95
52240: PUSH
52241: LD_EXP 95
52245: PPUSH
52246: LD_VAR 0 1
52250: PPUSH
52251: EMPTY
52252: PPUSH
52253: CALL_OW 1
52257: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52258: LD_ADDR_EXP 97
52262: PUSH
52263: LD_EXP 97
52267: PPUSH
52268: LD_VAR 0 1
52272: PPUSH
52273: EMPTY
52274: PPUSH
52275: CALL_OW 1
52279: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52280: LD_ADDR_EXP 98
52284: PUSH
52285: LD_EXP 98
52289: PPUSH
52290: LD_VAR 0 1
52294: PPUSH
52295: EMPTY
52296: PPUSH
52297: CALL_OW 1
52301: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52302: LD_ADDR_EXP 99
52306: PUSH
52307: LD_EXP 99
52311: PPUSH
52312: LD_VAR 0 1
52316: PPUSH
52317: EMPTY
52318: PPUSH
52319: CALL_OW 1
52323: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52324: LD_ADDR_EXP 100
52328: PUSH
52329: LD_EXP 100
52333: PPUSH
52334: LD_VAR 0 1
52338: PPUSH
52339: EMPTY
52340: PPUSH
52341: CALL_OW 1
52345: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52346: LD_ADDR_EXP 101
52350: PUSH
52351: LD_EXP 101
52355: PPUSH
52356: LD_VAR 0 1
52360: PPUSH
52361: EMPTY
52362: PPUSH
52363: CALL_OW 1
52367: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52368: LD_ADDR_EXP 102
52372: PUSH
52373: LD_EXP 102
52377: PPUSH
52378: LD_VAR 0 1
52382: PPUSH
52383: EMPTY
52384: PPUSH
52385: CALL_OW 1
52389: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52390: LD_ADDR_EXP 103
52394: PUSH
52395: LD_EXP 103
52399: PPUSH
52400: LD_VAR 0 1
52404: PPUSH
52405: EMPTY
52406: PPUSH
52407: CALL_OW 1
52411: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52412: LD_ADDR_EXP 104
52416: PUSH
52417: LD_EXP 104
52421: PPUSH
52422: LD_VAR 0 1
52426: PPUSH
52427: EMPTY
52428: PPUSH
52429: CALL_OW 1
52433: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52434: LD_ADDR_EXP 105
52438: PUSH
52439: LD_EXP 105
52443: PPUSH
52444: LD_VAR 0 1
52448: PPUSH
52449: EMPTY
52450: PPUSH
52451: CALL_OW 1
52455: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52456: LD_ADDR_EXP 106
52460: PUSH
52461: LD_EXP 106
52465: PPUSH
52466: LD_VAR 0 1
52470: PPUSH
52471: EMPTY
52472: PPUSH
52473: CALL_OW 1
52477: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52478: LD_ADDR_EXP 107
52482: PUSH
52483: LD_EXP 107
52487: PPUSH
52488: LD_VAR 0 1
52492: PPUSH
52493: EMPTY
52494: PPUSH
52495: CALL_OW 1
52499: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52500: LD_ADDR_EXP 108
52504: PUSH
52505: LD_EXP 108
52509: PPUSH
52510: LD_VAR 0 1
52514: PPUSH
52515: EMPTY
52516: PPUSH
52517: CALL_OW 1
52521: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52522: LD_ADDR_EXP 109
52526: PUSH
52527: LD_EXP 109
52531: PPUSH
52532: LD_VAR 0 1
52536: PPUSH
52537: EMPTY
52538: PPUSH
52539: CALL_OW 1
52543: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52544: LD_ADDR_EXP 110
52548: PUSH
52549: LD_EXP 110
52553: PPUSH
52554: LD_VAR 0 1
52558: PPUSH
52559: LD_INT 0
52561: PPUSH
52562: CALL_OW 1
52566: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52567: LD_ADDR_EXP 111
52571: PUSH
52572: LD_EXP 111
52576: PPUSH
52577: LD_VAR 0 1
52581: PPUSH
52582: LD_INT 0
52584: PPUSH
52585: CALL_OW 1
52589: ST_TO_ADDR
// end ;
52590: LD_VAR 0 2
52594: RET
// export function MC_Add ( side , units ) ; var base ; begin
52595: LD_INT 0
52597: PPUSH
52598: PPUSH
// base := mc_bases + 1 ;
52599: LD_ADDR_VAR 0 4
52603: PUSH
52604: LD_EXP 68
52608: PUSH
52609: LD_INT 1
52611: PLUS
52612: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52613: LD_ADDR_EXP 94
52617: PUSH
52618: LD_EXP 94
52622: PPUSH
52623: LD_VAR 0 4
52627: PPUSH
52628: LD_VAR 0 1
52632: PPUSH
52633: CALL_OW 1
52637: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52638: LD_ADDR_EXP 68
52642: PUSH
52643: LD_EXP 68
52647: PPUSH
52648: LD_VAR 0 4
52652: PPUSH
52653: LD_VAR 0 2
52657: PPUSH
52658: CALL_OW 1
52662: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52663: LD_ADDR_EXP 69
52667: PUSH
52668: LD_EXP 69
52672: PPUSH
52673: LD_VAR 0 4
52677: PPUSH
52678: EMPTY
52679: PPUSH
52680: CALL_OW 1
52684: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52685: LD_ADDR_EXP 70
52689: PUSH
52690: LD_EXP 70
52694: PPUSH
52695: LD_VAR 0 4
52699: PPUSH
52700: EMPTY
52701: PPUSH
52702: CALL_OW 1
52706: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52707: LD_ADDR_EXP 71
52711: PUSH
52712: LD_EXP 71
52716: PPUSH
52717: LD_VAR 0 4
52721: PPUSH
52722: EMPTY
52723: PPUSH
52724: CALL_OW 1
52728: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52729: LD_ADDR_EXP 72
52733: PUSH
52734: LD_EXP 72
52738: PPUSH
52739: LD_VAR 0 4
52743: PPUSH
52744: EMPTY
52745: PPUSH
52746: CALL_OW 1
52750: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52751: LD_ADDR_EXP 73
52755: PUSH
52756: LD_EXP 73
52760: PPUSH
52761: LD_VAR 0 4
52765: PPUSH
52766: EMPTY
52767: PPUSH
52768: CALL_OW 1
52772: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52773: LD_ADDR_EXP 74
52777: PUSH
52778: LD_EXP 74
52782: PPUSH
52783: LD_VAR 0 4
52787: PPUSH
52788: EMPTY
52789: PPUSH
52790: CALL_OW 1
52794: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52795: LD_ADDR_EXP 75
52799: PUSH
52800: LD_EXP 75
52804: PPUSH
52805: LD_VAR 0 4
52809: PPUSH
52810: EMPTY
52811: PPUSH
52812: CALL_OW 1
52816: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52817: LD_ADDR_EXP 76
52821: PUSH
52822: LD_EXP 76
52826: PPUSH
52827: LD_VAR 0 4
52831: PPUSH
52832: EMPTY
52833: PPUSH
52834: CALL_OW 1
52838: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52839: LD_ADDR_EXP 77
52843: PUSH
52844: LD_EXP 77
52848: PPUSH
52849: LD_VAR 0 4
52853: PPUSH
52854: EMPTY
52855: PPUSH
52856: CALL_OW 1
52860: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52861: LD_ADDR_EXP 78
52865: PUSH
52866: LD_EXP 78
52870: PPUSH
52871: LD_VAR 0 4
52875: PPUSH
52876: EMPTY
52877: PPUSH
52878: CALL_OW 1
52882: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52883: LD_ADDR_EXP 79
52887: PUSH
52888: LD_EXP 79
52892: PPUSH
52893: LD_VAR 0 4
52897: PPUSH
52898: LD_INT 0
52900: PPUSH
52901: CALL_OW 1
52905: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52906: LD_ADDR_EXP 80
52910: PUSH
52911: LD_EXP 80
52915: PPUSH
52916: LD_VAR 0 4
52920: PPUSH
52921: EMPTY
52922: PPUSH
52923: CALL_OW 1
52927: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52928: LD_ADDR_EXP 81
52932: PUSH
52933: LD_EXP 81
52937: PPUSH
52938: LD_VAR 0 4
52942: PPUSH
52943: EMPTY
52944: PPUSH
52945: CALL_OW 1
52949: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52950: LD_ADDR_EXP 82
52954: PUSH
52955: LD_EXP 82
52959: PPUSH
52960: LD_VAR 0 4
52964: PPUSH
52965: EMPTY
52966: PPUSH
52967: CALL_OW 1
52971: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52972: LD_ADDR_EXP 83
52976: PUSH
52977: LD_EXP 83
52981: PPUSH
52982: LD_VAR 0 4
52986: PPUSH
52987: EMPTY
52988: PPUSH
52989: CALL_OW 1
52993: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52994: LD_ADDR_EXP 84
52998: PUSH
52999: LD_EXP 84
53003: PPUSH
53004: LD_VAR 0 4
53008: PPUSH
53009: EMPTY
53010: PPUSH
53011: CALL_OW 1
53015: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53016: LD_ADDR_EXP 85
53020: PUSH
53021: LD_EXP 85
53025: PPUSH
53026: LD_VAR 0 4
53030: PPUSH
53031: EMPTY
53032: PPUSH
53033: CALL_OW 1
53037: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53038: LD_ADDR_EXP 86
53042: PUSH
53043: LD_EXP 86
53047: PPUSH
53048: LD_VAR 0 4
53052: PPUSH
53053: EMPTY
53054: PPUSH
53055: CALL_OW 1
53059: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53060: LD_ADDR_EXP 87
53064: PUSH
53065: LD_EXP 87
53069: PPUSH
53070: LD_VAR 0 4
53074: PPUSH
53075: EMPTY
53076: PPUSH
53077: CALL_OW 1
53081: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53082: LD_ADDR_EXP 88
53086: PUSH
53087: LD_EXP 88
53091: PPUSH
53092: LD_VAR 0 4
53096: PPUSH
53097: EMPTY
53098: PPUSH
53099: CALL_OW 1
53103: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53104: LD_ADDR_EXP 89
53108: PUSH
53109: LD_EXP 89
53113: PPUSH
53114: LD_VAR 0 4
53118: PPUSH
53119: EMPTY
53120: PPUSH
53121: CALL_OW 1
53125: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53126: LD_ADDR_EXP 90
53130: PUSH
53131: LD_EXP 90
53135: PPUSH
53136: LD_VAR 0 4
53140: PPUSH
53141: EMPTY
53142: PPUSH
53143: CALL_OW 1
53147: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53148: LD_ADDR_EXP 91
53152: PUSH
53153: LD_EXP 91
53157: PPUSH
53158: LD_VAR 0 4
53162: PPUSH
53163: EMPTY
53164: PPUSH
53165: CALL_OW 1
53169: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53170: LD_ADDR_EXP 92
53174: PUSH
53175: LD_EXP 92
53179: PPUSH
53180: LD_VAR 0 4
53184: PPUSH
53185: EMPTY
53186: PPUSH
53187: CALL_OW 1
53191: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53192: LD_ADDR_EXP 93
53196: PUSH
53197: LD_EXP 93
53201: PPUSH
53202: LD_VAR 0 4
53206: PPUSH
53207: EMPTY
53208: PPUSH
53209: CALL_OW 1
53213: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53214: LD_ADDR_EXP 95
53218: PUSH
53219: LD_EXP 95
53223: PPUSH
53224: LD_VAR 0 4
53228: PPUSH
53229: EMPTY
53230: PPUSH
53231: CALL_OW 1
53235: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53236: LD_ADDR_EXP 97
53240: PUSH
53241: LD_EXP 97
53245: PPUSH
53246: LD_VAR 0 4
53250: PPUSH
53251: EMPTY
53252: PPUSH
53253: CALL_OW 1
53257: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53258: LD_ADDR_EXP 98
53262: PUSH
53263: LD_EXP 98
53267: PPUSH
53268: LD_VAR 0 4
53272: PPUSH
53273: EMPTY
53274: PPUSH
53275: CALL_OW 1
53279: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53280: LD_ADDR_EXP 99
53284: PUSH
53285: LD_EXP 99
53289: PPUSH
53290: LD_VAR 0 4
53294: PPUSH
53295: EMPTY
53296: PPUSH
53297: CALL_OW 1
53301: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53302: LD_ADDR_EXP 100
53306: PUSH
53307: LD_EXP 100
53311: PPUSH
53312: LD_VAR 0 4
53316: PPUSH
53317: EMPTY
53318: PPUSH
53319: CALL_OW 1
53323: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53324: LD_ADDR_EXP 101
53328: PUSH
53329: LD_EXP 101
53333: PPUSH
53334: LD_VAR 0 4
53338: PPUSH
53339: EMPTY
53340: PPUSH
53341: CALL_OW 1
53345: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53346: LD_ADDR_EXP 102
53350: PUSH
53351: LD_EXP 102
53355: PPUSH
53356: LD_VAR 0 4
53360: PPUSH
53361: EMPTY
53362: PPUSH
53363: CALL_OW 1
53367: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53368: LD_ADDR_EXP 103
53372: PUSH
53373: LD_EXP 103
53377: PPUSH
53378: LD_VAR 0 4
53382: PPUSH
53383: EMPTY
53384: PPUSH
53385: CALL_OW 1
53389: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53390: LD_ADDR_EXP 104
53394: PUSH
53395: LD_EXP 104
53399: PPUSH
53400: LD_VAR 0 4
53404: PPUSH
53405: EMPTY
53406: PPUSH
53407: CALL_OW 1
53411: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53412: LD_ADDR_EXP 105
53416: PUSH
53417: LD_EXP 105
53421: PPUSH
53422: LD_VAR 0 4
53426: PPUSH
53427: EMPTY
53428: PPUSH
53429: CALL_OW 1
53433: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53434: LD_ADDR_EXP 106
53438: PUSH
53439: LD_EXP 106
53443: PPUSH
53444: LD_VAR 0 4
53448: PPUSH
53449: EMPTY
53450: PPUSH
53451: CALL_OW 1
53455: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53456: LD_ADDR_EXP 107
53460: PUSH
53461: LD_EXP 107
53465: PPUSH
53466: LD_VAR 0 4
53470: PPUSH
53471: EMPTY
53472: PPUSH
53473: CALL_OW 1
53477: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53478: LD_ADDR_EXP 108
53482: PUSH
53483: LD_EXP 108
53487: PPUSH
53488: LD_VAR 0 4
53492: PPUSH
53493: EMPTY
53494: PPUSH
53495: CALL_OW 1
53499: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53500: LD_ADDR_EXP 109
53504: PUSH
53505: LD_EXP 109
53509: PPUSH
53510: LD_VAR 0 4
53514: PPUSH
53515: EMPTY
53516: PPUSH
53517: CALL_OW 1
53521: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53522: LD_ADDR_EXP 110
53526: PUSH
53527: LD_EXP 110
53531: PPUSH
53532: LD_VAR 0 4
53536: PPUSH
53537: LD_INT 0
53539: PPUSH
53540: CALL_OW 1
53544: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53545: LD_ADDR_EXP 111
53549: PUSH
53550: LD_EXP 111
53554: PPUSH
53555: LD_VAR 0 4
53559: PPUSH
53560: LD_INT 0
53562: PPUSH
53563: CALL_OW 1
53567: ST_TO_ADDR
// result := base ;
53568: LD_ADDR_VAR 0 3
53572: PUSH
53573: LD_VAR 0 4
53577: ST_TO_ADDR
// end ;
53578: LD_VAR 0 3
53582: RET
// export function MC_Start ( ) ; var i ; begin
53583: LD_INT 0
53585: PPUSH
53586: PPUSH
// for i = 1 to mc_bases do
53587: LD_ADDR_VAR 0 2
53591: PUSH
53592: DOUBLE
53593: LD_INT 1
53595: DEC
53596: ST_TO_ADDR
53597: LD_EXP 68
53601: PUSH
53602: FOR_TO
53603: IFFALSE 54680
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53605: LD_ADDR_EXP 68
53609: PUSH
53610: LD_EXP 68
53614: PPUSH
53615: LD_VAR 0 2
53619: PPUSH
53620: LD_EXP 68
53624: PUSH
53625: LD_VAR 0 2
53629: ARRAY
53630: PUSH
53631: LD_INT 0
53633: DIFF
53634: PPUSH
53635: CALL_OW 1
53639: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53640: LD_ADDR_EXP 69
53644: PUSH
53645: LD_EXP 69
53649: PPUSH
53650: LD_VAR 0 2
53654: PPUSH
53655: EMPTY
53656: PPUSH
53657: CALL_OW 1
53661: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53662: LD_ADDR_EXP 70
53666: PUSH
53667: LD_EXP 70
53671: PPUSH
53672: LD_VAR 0 2
53676: PPUSH
53677: EMPTY
53678: PPUSH
53679: CALL_OW 1
53683: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53684: LD_ADDR_EXP 71
53688: PUSH
53689: LD_EXP 71
53693: PPUSH
53694: LD_VAR 0 2
53698: PPUSH
53699: EMPTY
53700: PPUSH
53701: CALL_OW 1
53705: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53706: LD_ADDR_EXP 72
53710: PUSH
53711: LD_EXP 72
53715: PPUSH
53716: LD_VAR 0 2
53720: PPUSH
53721: EMPTY
53722: PUSH
53723: EMPTY
53724: PUSH
53725: EMPTY
53726: LIST
53727: LIST
53728: PPUSH
53729: CALL_OW 1
53733: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53734: LD_ADDR_EXP 73
53738: PUSH
53739: LD_EXP 73
53743: PPUSH
53744: LD_VAR 0 2
53748: PPUSH
53749: EMPTY
53750: PPUSH
53751: CALL_OW 1
53755: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53756: LD_ADDR_EXP 100
53760: PUSH
53761: LD_EXP 100
53765: PPUSH
53766: LD_VAR 0 2
53770: PPUSH
53771: EMPTY
53772: PPUSH
53773: CALL_OW 1
53777: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53778: LD_ADDR_EXP 74
53782: PUSH
53783: LD_EXP 74
53787: PPUSH
53788: LD_VAR 0 2
53792: PPUSH
53793: EMPTY
53794: PPUSH
53795: CALL_OW 1
53799: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53800: LD_ADDR_EXP 75
53804: PUSH
53805: LD_EXP 75
53809: PPUSH
53810: LD_VAR 0 2
53814: PPUSH
53815: EMPTY
53816: PPUSH
53817: CALL_OW 1
53821: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53822: LD_ADDR_EXP 76
53826: PUSH
53827: LD_EXP 76
53831: PPUSH
53832: LD_VAR 0 2
53836: PPUSH
53837: LD_EXP 68
53841: PUSH
53842: LD_VAR 0 2
53846: ARRAY
53847: PPUSH
53848: LD_INT 2
53850: PUSH
53851: LD_INT 30
53853: PUSH
53854: LD_INT 32
53856: PUSH
53857: EMPTY
53858: LIST
53859: LIST
53860: PUSH
53861: LD_INT 30
53863: PUSH
53864: LD_INT 33
53866: PUSH
53867: EMPTY
53868: LIST
53869: LIST
53870: PUSH
53871: EMPTY
53872: LIST
53873: LIST
53874: LIST
53875: PPUSH
53876: CALL_OW 72
53880: PPUSH
53881: CALL_OW 1
53885: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53886: LD_ADDR_EXP 77
53890: PUSH
53891: LD_EXP 77
53895: PPUSH
53896: LD_VAR 0 2
53900: PPUSH
53901: LD_EXP 68
53905: PUSH
53906: LD_VAR 0 2
53910: ARRAY
53911: PPUSH
53912: LD_INT 2
53914: PUSH
53915: LD_INT 30
53917: PUSH
53918: LD_INT 32
53920: PUSH
53921: EMPTY
53922: LIST
53923: LIST
53924: PUSH
53925: LD_INT 30
53927: PUSH
53928: LD_INT 31
53930: PUSH
53931: EMPTY
53932: LIST
53933: LIST
53934: PUSH
53935: EMPTY
53936: LIST
53937: LIST
53938: LIST
53939: PUSH
53940: LD_INT 58
53942: PUSH
53943: EMPTY
53944: LIST
53945: PUSH
53946: EMPTY
53947: LIST
53948: LIST
53949: PPUSH
53950: CALL_OW 72
53954: PPUSH
53955: CALL_OW 1
53959: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53960: LD_ADDR_EXP 78
53964: PUSH
53965: LD_EXP 78
53969: PPUSH
53970: LD_VAR 0 2
53974: PPUSH
53975: EMPTY
53976: PPUSH
53977: CALL_OW 1
53981: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53982: LD_ADDR_EXP 82
53986: PUSH
53987: LD_EXP 82
53991: PPUSH
53992: LD_VAR 0 2
53996: PPUSH
53997: EMPTY
53998: PPUSH
53999: CALL_OW 1
54003: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
54004: LD_ADDR_EXP 81
54008: PUSH
54009: LD_EXP 81
54013: PPUSH
54014: LD_VAR 0 2
54018: PPUSH
54019: EMPTY
54020: PPUSH
54021: CALL_OW 1
54025: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
54026: LD_ADDR_EXP 83
54030: PUSH
54031: LD_EXP 83
54035: PPUSH
54036: LD_VAR 0 2
54040: PPUSH
54041: EMPTY
54042: PPUSH
54043: CALL_OW 1
54047: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
54048: LD_ADDR_EXP 84
54052: PUSH
54053: LD_EXP 84
54057: PPUSH
54058: LD_VAR 0 2
54062: PPUSH
54063: EMPTY
54064: PPUSH
54065: CALL_OW 1
54069: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
54070: LD_ADDR_EXP 85
54074: PUSH
54075: LD_EXP 85
54079: PPUSH
54080: LD_VAR 0 2
54084: PPUSH
54085: EMPTY
54086: PPUSH
54087: CALL_OW 1
54091: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
54092: LD_ADDR_EXP 86
54096: PUSH
54097: LD_EXP 86
54101: PPUSH
54102: LD_VAR 0 2
54106: PPUSH
54107: EMPTY
54108: PPUSH
54109: CALL_OW 1
54113: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
54114: LD_ADDR_EXP 87
54118: PUSH
54119: LD_EXP 87
54123: PPUSH
54124: LD_VAR 0 2
54128: PPUSH
54129: EMPTY
54130: PPUSH
54131: CALL_OW 1
54135: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54136: LD_ADDR_EXP 88
54140: PUSH
54141: LD_EXP 88
54145: PPUSH
54146: LD_VAR 0 2
54150: PPUSH
54151: EMPTY
54152: PPUSH
54153: CALL_OW 1
54157: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
54158: LD_ADDR_EXP 89
54162: PUSH
54163: LD_EXP 89
54167: PPUSH
54168: LD_VAR 0 2
54172: PPUSH
54173: EMPTY
54174: PPUSH
54175: CALL_OW 1
54179: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54180: LD_ADDR_EXP 90
54184: PUSH
54185: LD_EXP 90
54189: PPUSH
54190: LD_VAR 0 2
54194: PPUSH
54195: EMPTY
54196: PPUSH
54197: CALL_OW 1
54201: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
54202: LD_ADDR_EXP 79
54206: PUSH
54207: LD_EXP 79
54211: PPUSH
54212: LD_VAR 0 2
54216: PPUSH
54217: LD_INT 0
54219: PPUSH
54220: CALL_OW 1
54224: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
54225: LD_ADDR_EXP 92
54229: PUSH
54230: LD_EXP 92
54234: PPUSH
54235: LD_VAR 0 2
54239: PPUSH
54240: LD_INT 0
54242: PPUSH
54243: CALL_OW 1
54247: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
54248: LD_ADDR_EXP 80
54252: PUSH
54253: LD_EXP 80
54257: PPUSH
54258: LD_VAR 0 2
54262: PPUSH
54263: EMPTY
54264: PPUSH
54265: CALL_OW 1
54269: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
54270: LD_ADDR_EXP 91
54274: PUSH
54275: LD_EXP 91
54279: PPUSH
54280: LD_VAR 0 2
54284: PPUSH
54285: LD_INT 0
54287: PPUSH
54288: CALL_OW 1
54292: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
54293: LD_ADDR_EXP 93
54297: PUSH
54298: LD_EXP 93
54302: PPUSH
54303: LD_VAR 0 2
54307: PPUSH
54308: EMPTY
54309: PPUSH
54310: CALL_OW 1
54314: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
54315: LD_ADDR_EXP 96
54319: PUSH
54320: LD_EXP 96
54324: PPUSH
54325: LD_VAR 0 2
54329: PPUSH
54330: LD_INT 0
54332: PPUSH
54333: CALL_OW 1
54337: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
54338: LD_ADDR_EXP 97
54342: PUSH
54343: LD_EXP 97
54347: PPUSH
54348: LD_VAR 0 2
54352: PPUSH
54353: EMPTY
54354: PPUSH
54355: CALL_OW 1
54359: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
54360: LD_ADDR_EXP 98
54364: PUSH
54365: LD_EXP 98
54369: PPUSH
54370: LD_VAR 0 2
54374: PPUSH
54375: EMPTY
54376: PPUSH
54377: CALL_OW 1
54381: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54382: LD_ADDR_EXP 99
54386: PUSH
54387: LD_EXP 99
54391: PPUSH
54392: LD_VAR 0 2
54396: PPUSH
54397: EMPTY
54398: PPUSH
54399: CALL_OW 1
54403: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54404: LD_ADDR_EXP 101
54408: PUSH
54409: LD_EXP 101
54413: PPUSH
54414: LD_VAR 0 2
54418: PPUSH
54419: LD_EXP 68
54423: PUSH
54424: LD_VAR 0 2
54428: ARRAY
54429: PPUSH
54430: LD_INT 2
54432: PUSH
54433: LD_INT 30
54435: PUSH
54436: LD_INT 6
54438: PUSH
54439: EMPTY
54440: LIST
54441: LIST
54442: PUSH
54443: LD_INT 30
54445: PUSH
54446: LD_INT 7
54448: PUSH
54449: EMPTY
54450: LIST
54451: LIST
54452: PUSH
54453: LD_INT 30
54455: PUSH
54456: LD_INT 8
54458: PUSH
54459: EMPTY
54460: LIST
54461: LIST
54462: PUSH
54463: EMPTY
54464: LIST
54465: LIST
54466: LIST
54467: LIST
54468: PPUSH
54469: CALL_OW 72
54473: PPUSH
54474: CALL_OW 1
54478: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
54479: LD_ADDR_EXP 102
54483: PUSH
54484: LD_EXP 102
54488: PPUSH
54489: LD_VAR 0 2
54493: PPUSH
54494: EMPTY
54495: PPUSH
54496: CALL_OW 1
54500: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
54501: LD_ADDR_EXP 103
54505: PUSH
54506: LD_EXP 103
54510: PPUSH
54511: LD_VAR 0 2
54515: PPUSH
54516: EMPTY
54517: PPUSH
54518: CALL_OW 1
54522: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
54523: LD_ADDR_EXP 104
54527: PUSH
54528: LD_EXP 104
54532: PPUSH
54533: LD_VAR 0 2
54537: PPUSH
54538: EMPTY
54539: PPUSH
54540: CALL_OW 1
54544: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
54545: LD_ADDR_EXP 105
54549: PUSH
54550: LD_EXP 105
54554: PPUSH
54555: LD_VAR 0 2
54559: PPUSH
54560: EMPTY
54561: PPUSH
54562: CALL_OW 1
54566: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54567: LD_ADDR_EXP 106
54571: PUSH
54572: LD_EXP 106
54576: PPUSH
54577: LD_VAR 0 2
54581: PPUSH
54582: EMPTY
54583: PPUSH
54584: CALL_OW 1
54588: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54589: LD_ADDR_EXP 107
54593: PUSH
54594: LD_EXP 107
54598: PPUSH
54599: LD_VAR 0 2
54603: PPUSH
54604: EMPTY
54605: PPUSH
54606: CALL_OW 1
54610: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54611: LD_ADDR_EXP 108
54615: PUSH
54616: LD_EXP 108
54620: PPUSH
54621: LD_VAR 0 2
54625: PPUSH
54626: EMPTY
54627: PPUSH
54628: CALL_OW 1
54632: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54633: LD_ADDR_EXP 109
54637: PUSH
54638: LD_EXP 109
54642: PPUSH
54643: LD_VAR 0 2
54647: PPUSH
54648: EMPTY
54649: PPUSH
54650: CALL_OW 1
54654: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54655: LD_ADDR_EXP 110
54659: PUSH
54660: LD_EXP 110
54664: PPUSH
54665: LD_VAR 0 2
54669: PPUSH
54670: LD_INT 0
54672: PPUSH
54673: CALL_OW 1
54677: ST_TO_ADDR
// end ;
54678: GO 53602
54680: POP
54681: POP
// MC_InitSides ( ) ;
54682: CALL 54968 0 0
// MC_InitResearch ( ) ;
54686: CALL 54707 0 0
// CustomInitMacro ( ) ;
54690: CALL 5753 0 0
// skirmish := true ;
54694: LD_ADDR_EXP 66
54698: PUSH
54699: LD_INT 1
54701: ST_TO_ADDR
// end ;
54702: LD_VAR 0 1
54706: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54707: LD_INT 0
54709: PPUSH
54710: PPUSH
54711: PPUSH
54712: PPUSH
54713: PPUSH
54714: PPUSH
// if not mc_bases then
54715: LD_EXP 68
54719: NOT
54720: IFFALSE 54724
// exit ;
54722: GO 54963
// for i = 1 to 8 do
54724: LD_ADDR_VAR 0 2
54728: PUSH
54729: DOUBLE
54730: LD_INT 1
54732: DEC
54733: ST_TO_ADDR
54734: LD_INT 8
54736: PUSH
54737: FOR_TO
54738: IFFALSE 54764
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54740: LD_ADDR_EXP 95
54744: PUSH
54745: LD_EXP 95
54749: PPUSH
54750: LD_VAR 0 2
54754: PPUSH
54755: EMPTY
54756: PPUSH
54757: CALL_OW 1
54761: ST_TO_ADDR
54762: GO 54737
54764: POP
54765: POP
// tmp := [ ] ;
54766: LD_ADDR_VAR 0 5
54770: PUSH
54771: EMPTY
54772: ST_TO_ADDR
// for i = 1 to mc_sides do
54773: LD_ADDR_VAR 0 2
54777: PUSH
54778: DOUBLE
54779: LD_INT 1
54781: DEC
54782: ST_TO_ADDR
54783: LD_EXP 94
54787: PUSH
54788: FOR_TO
54789: IFFALSE 54847
// if not mc_sides [ i ] in tmp then
54791: LD_EXP 94
54795: PUSH
54796: LD_VAR 0 2
54800: ARRAY
54801: PUSH
54802: LD_VAR 0 5
54806: IN
54807: NOT
54808: IFFALSE 54845
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54810: LD_ADDR_VAR 0 5
54814: PUSH
54815: LD_VAR 0 5
54819: PPUSH
54820: LD_VAR 0 5
54824: PUSH
54825: LD_INT 1
54827: PLUS
54828: PPUSH
54829: LD_EXP 94
54833: PUSH
54834: LD_VAR 0 2
54838: ARRAY
54839: PPUSH
54840: CALL_OW 2
54844: ST_TO_ADDR
54845: GO 54788
54847: POP
54848: POP
// if not tmp then
54849: LD_VAR 0 5
54853: NOT
54854: IFFALSE 54858
// exit ;
54856: GO 54963
// for j in tmp do
54858: LD_ADDR_VAR 0 3
54862: PUSH
54863: LD_VAR 0 5
54867: PUSH
54868: FOR_IN
54869: IFFALSE 54961
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54871: LD_ADDR_VAR 0 6
54875: PUSH
54876: LD_INT 22
54878: PUSH
54879: LD_VAR 0 3
54883: PUSH
54884: EMPTY
54885: LIST
54886: LIST
54887: PPUSH
54888: CALL_OW 69
54892: ST_TO_ADDR
// if not un then
54893: LD_VAR 0 6
54897: NOT
54898: IFFALSE 54902
// continue ;
54900: GO 54868
// nation := GetNation ( un [ 1 ] ) ;
54902: LD_ADDR_VAR 0 4
54906: PUSH
54907: LD_VAR 0 6
54911: PUSH
54912: LD_INT 1
54914: ARRAY
54915: PPUSH
54916: CALL_OW 248
54920: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54921: LD_ADDR_EXP 95
54925: PUSH
54926: LD_EXP 95
54930: PPUSH
54931: LD_VAR 0 3
54935: PPUSH
54936: LD_VAR 0 3
54940: PPUSH
54941: LD_VAR 0 4
54945: PPUSH
54946: LD_INT 1
54948: PPUSH
54949: CALL 13665 0 3
54953: PPUSH
54954: CALL_OW 1
54958: ST_TO_ADDR
// end ;
54959: GO 54868
54961: POP
54962: POP
// end ;
54963: LD_VAR 0 1
54967: RET
// export function MC_InitSides ( ) ; var i ; begin
54968: LD_INT 0
54970: PPUSH
54971: PPUSH
// if not mc_bases then
54972: LD_EXP 68
54976: NOT
54977: IFFALSE 54981
// exit ;
54979: GO 55055
// for i = 1 to mc_bases do
54981: LD_ADDR_VAR 0 2
54985: PUSH
54986: DOUBLE
54987: LD_INT 1
54989: DEC
54990: ST_TO_ADDR
54991: LD_EXP 68
54995: PUSH
54996: FOR_TO
54997: IFFALSE 55053
// if mc_bases [ i ] then
54999: LD_EXP 68
55003: PUSH
55004: LD_VAR 0 2
55008: ARRAY
55009: IFFALSE 55051
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
55011: LD_ADDR_EXP 94
55015: PUSH
55016: LD_EXP 94
55020: PPUSH
55021: LD_VAR 0 2
55025: PPUSH
55026: LD_EXP 68
55030: PUSH
55031: LD_VAR 0 2
55035: ARRAY
55036: PUSH
55037: LD_INT 1
55039: ARRAY
55040: PPUSH
55041: CALL_OW 255
55045: PPUSH
55046: CALL_OW 1
55050: ST_TO_ADDR
55051: GO 54996
55053: POP
55054: POP
// end ;
55055: LD_VAR 0 1
55059: RET
// every 0 0$03 trigger skirmish do
55060: LD_EXP 66
55064: IFFALSE 55218
55066: GO 55068
55068: DISABLE
// begin enable ;
55069: ENABLE
// MC_CheckBuildings ( ) ;
55070: CALL 59716 0 0
// MC_CheckPeopleLife ( ) ;
55074: CALL 59841 0 0
// RaiseSailEvent ( 100 ) ;
55078: LD_INT 100
55080: PPUSH
55081: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
55085: LD_INT 103
55087: PPUSH
55088: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
55092: LD_INT 104
55094: PPUSH
55095: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
55099: LD_INT 105
55101: PPUSH
55102: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
55106: LD_INT 106
55108: PPUSH
55109: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
55113: LD_INT 107
55115: PPUSH
55116: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
55120: LD_INT 108
55122: PPUSH
55123: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
55127: LD_INT 109
55129: PPUSH
55130: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
55134: LD_INT 110
55136: PPUSH
55137: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
55141: LD_INT 111
55143: PPUSH
55144: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
55148: LD_INT 112
55150: PPUSH
55151: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
55155: LD_INT 113
55157: PPUSH
55158: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
55162: LD_INT 120
55164: PPUSH
55165: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
55169: LD_INT 121
55171: PPUSH
55172: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
55176: LD_INT 122
55178: PPUSH
55179: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
55183: LD_INT 123
55185: PPUSH
55186: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
55190: LD_INT 124
55192: PPUSH
55193: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
55197: LD_INT 125
55199: PPUSH
55200: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
55204: LD_INT 126
55206: PPUSH
55207: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
55211: LD_INT 200
55213: PPUSH
55214: CALL_OW 427
// end ;
55218: END
// on SailEvent ( event ) do begin if event < 100 then
55219: LD_VAR 0 1
55223: PUSH
55224: LD_INT 100
55226: LESS
55227: IFFALSE 55238
// CustomEvent ( event ) ;
55229: LD_VAR 0 1
55233: PPUSH
55234: CALL 5745 0 1
// if event = 100 then
55238: LD_VAR 0 1
55242: PUSH
55243: LD_INT 100
55245: EQUAL
55246: IFFALSE 55252
// MC_ClassManager ( ) ;
55248: CALL 55644 0 0
// if event = 101 then
55252: LD_VAR 0 1
55256: PUSH
55257: LD_INT 101
55259: EQUAL
55260: IFFALSE 55266
// MC_RepairBuildings ( ) ;
55262: CALL 60426 0 0
// if event = 102 then
55266: LD_VAR 0 1
55270: PUSH
55271: LD_INT 102
55273: EQUAL
55274: IFFALSE 55280
// MC_Heal ( ) ;
55276: CALL 61311 0 0
// if event = 103 then
55280: LD_VAR 0 1
55284: PUSH
55285: LD_INT 103
55287: EQUAL
55288: IFFALSE 55294
// MC_Build ( ) ;
55290: CALL 61733 0 0
// if event = 104 then
55294: LD_VAR 0 1
55298: PUSH
55299: LD_INT 104
55301: EQUAL
55302: IFFALSE 55308
// MC_TurretWeapon ( ) ;
55304: CALL 63374 0 0
// if event = 105 then
55308: LD_VAR 0 1
55312: PUSH
55313: LD_INT 105
55315: EQUAL
55316: IFFALSE 55322
// MC_BuildUpgrade ( ) ;
55318: CALL 62925 0 0
// if event = 106 then
55322: LD_VAR 0 1
55326: PUSH
55327: LD_INT 106
55329: EQUAL
55330: IFFALSE 55336
// MC_PlantMines ( ) ;
55332: CALL 63804 0 0
// if event = 107 then
55336: LD_VAR 0 1
55340: PUSH
55341: LD_INT 107
55343: EQUAL
55344: IFFALSE 55350
// MC_CollectCrates ( ) ;
55346: CALL 64595 0 0
// if event = 108 then
55350: LD_VAR 0 1
55354: PUSH
55355: LD_INT 108
55357: EQUAL
55358: IFFALSE 55364
// MC_LinkRemoteControl ( ) ;
55360: CALL 66371 0 0
// if event = 109 then
55364: LD_VAR 0 1
55368: PUSH
55369: LD_INT 109
55371: EQUAL
55372: IFFALSE 55378
// MC_ProduceVehicle ( ) ;
55374: CALL 66552 0 0
// if event = 110 then
55378: LD_VAR 0 1
55382: PUSH
55383: LD_INT 110
55385: EQUAL
55386: IFFALSE 55392
// MC_SendAttack ( ) ;
55388: CALL 67018 0 0
// if event = 111 then
55392: LD_VAR 0 1
55396: PUSH
55397: LD_INT 111
55399: EQUAL
55400: IFFALSE 55406
// MC_Defend ( ) ;
55402: CALL 67126 0 0
// if event = 112 then
55406: LD_VAR 0 1
55410: PUSH
55411: LD_INT 112
55413: EQUAL
55414: IFFALSE 55420
// MC_Research ( ) ;
55416: CALL 67848 0 0
// if event = 113 then
55420: LD_VAR 0 1
55424: PUSH
55425: LD_INT 113
55427: EQUAL
55428: IFFALSE 55434
// MC_MinesTrigger ( ) ;
55430: CALL 68962 0 0
// if event = 120 then
55434: LD_VAR 0 1
55438: PUSH
55439: LD_INT 120
55441: EQUAL
55442: IFFALSE 55448
// MC_RepairVehicle ( ) ;
55444: CALL 69061 0 0
// if event = 121 then
55448: LD_VAR 0 1
55452: PUSH
55453: LD_INT 121
55455: EQUAL
55456: IFFALSE 55462
// MC_TameApe ( ) ;
55458: CALL 69791 0 0
// if event = 122 then
55462: LD_VAR 0 1
55466: PUSH
55467: LD_INT 122
55469: EQUAL
55470: IFFALSE 55476
// MC_ChangeApeClass ( ) ;
55472: CALL 70620 0 0
// if event = 123 then
55476: LD_VAR 0 1
55480: PUSH
55481: LD_INT 123
55483: EQUAL
55484: IFFALSE 55490
// MC_Bazooka ( ) ;
55486: CALL 71270 0 0
// if event = 124 then
55490: LD_VAR 0 1
55494: PUSH
55495: LD_INT 124
55497: EQUAL
55498: IFFALSE 55504
// MC_TeleportExit ( ) ;
55500: CALL 71468 0 0
// if event = 125 then
55504: LD_VAR 0 1
55508: PUSH
55509: LD_INT 125
55511: EQUAL
55512: IFFALSE 55518
// MC_Deposits ( ) ;
55514: CALL 72115 0 0
// if event = 126 then
55518: LD_VAR 0 1
55522: PUSH
55523: LD_INT 126
55525: EQUAL
55526: IFFALSE 55532
// MC_RemoteDriver ( ) ;
55528: CALL 72740 0 0
// if event = 200 then
55532: LD_VAR 0 1
55536: PUSH
55537: LD_INT 200
55539: EQUAL
55540: IFFALSE 55546
// MC_Idle ( ) ;
55542: CALL 74689 0 0
// end ;
55546: PPOPN 1
55548: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55549: LD_INT 0
55551: PPUSH
55552: PPUSH
// if not mc_bases [ base ] or not tag then
55553: LD_EXP 68
55557: PUSH
55558: LD_VAR 0 1
55562: ARRAY
55563: NOT
55564: PUSH
55565: LD_VAR 0 2
55569: NOT
55570: OR
55571: IFFALSE 55575
// exit ;
55573: GO 55639
// for i in mc_bases [ base ] union mc_ape [ base ] do
55575: LD_ADDR_VAR 0 4
55579: PUSH
55580: LD_EXP 68
55584: PUSH
55585: LD_VAR 0 1
55589: ARRAY
55590: PUSH
55591: LD_EXP 97
55595: PUSH
55596: LD_VAR 0 1
55600: ARRAY
55601: UNION
55602: PUSH
55603: FOR_IN
55604: IFFALSE 55637
// if GetTag ( i ) = tag then
55606: LD_VAR 0 4
55610: PPUSH
55611: CALL_OW 110
55615: PUSH
55616: LD_VAR 0 2
55620: EQUAL
55621: IFFALSE 55635
// SetTag ( i , 0 ) ;
55623: LD_VAR 0 4
55627: PPUSH
55628: LD_INT 0
55630: PPUSH
55631: CALL_OW 109
55635: GO 55603
55637: POP
55638: POP
// end ;
55639: LD_VAR 0 3
55643: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
55644: LD_INT 0
55646: PPUSH
55647: PPUSH
55648: PPUSH
55649: PPUSH
55650: PPUSH
55651: PPUSH
55652: PPUSH
55653: PPUSH
// if not mc_bases then
55654: LD_EXP 68
55658: NOT
55659: IFFALSE 55663
// exit ;
55661: GO 56121
// for i = 1 to mc_bases do
55663: LD_ADDR_VAR 0 2
55667: PUSH
55668: DOUBLE
55669: LD_INT 1
55671: DEC
55672: ST_TO_ADDR
55673: LD_EXP 68
55677: PUSH
55678: FOR_TO
55679: IFFALSE 56119
// begin tmp := MC_ClassCheckReq ( i ) ;
55681: LD_ADDR_VAR 0 4
55685: PUSH
55686: LD_VAR 0 2
55690: PPUSH
55691: CALL 56126 0 1
55695: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55696: LD_ADDR_EXP 109
55700: PUSH
55701: LD_EXP 109
55705: PPUSH
55706: LD_VAR 0 2
55710: PPUSH
55711: LD_VAR 0 4
55715: PPUSH
55716: CALL_OW 1
55720: ST_TO_ADDR
// if not tmp then
55721: LD_VAR 0 4
55725: NOT
55726: IFFALSE 55730
// continue ;
55728: GO 55678
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55730: LD_ADDR_VAR 0 6
55734: PUSH
55735: LD_EXP 68
55739: PUSH
55740: LD_VAR 0 2
55744: ARRAY
55745: PPUSH
55746: LD_INT 2
55748: PUSH
55749: LD_INT 30
55751: PUSH
55752: LD_INT 4
55754: PUSH
55755: EMPTY
55756: LIST
55757: LIST
55758: PUSH
55759: LD_INT 30
55761: PUSH
55762: LD_INT 5
55764: PUSH
55765: EMPTY
55766: LIST
55767: LIST
55768: PUSH
55769: EMPTY
55770: LIST
55771: LIST
55772: LIST
55773: PPUSH
55774: CALL_OW 72
55778: PUSH
55779: LD_EXP 68
55783: PUSH
55784: LD_VAR 0 2
55788: ARRAY
55789: PPUSH
55790: LD_INT 2
55792: PUSH
55793: LD_INT 30
55795: PUSH
55796: LD_INT 0
55798: PUSH
55799: EMPTY
55800: LIST
55801: LIST
55802: PUSH
55803: LD_INT 30
55805: PUSH
55806: LD_INT 1
55808: PUSH
55809: EMPTY
55810: LIST
55811: LIST
55812: PUSH
55813: EMPTY
55814: LIST
55815: LIST
55816: LIST
55817: PPUSH
55818: CALL_OW 72
55822: PUSH
55823: LD_EXP 68
55827: PUSH
55828: LD_VAR 0 2
55832: ARRAY
55833: PPUSH
55834: LD_INT 30
55836: PUSH
55837: LD_INT 3
55839: PUSH
55840: EMPTY
55841: LIST
55842: LIST
55843: PPUSH
55844: CALL_OW 72
55848: PUSH
55849: LD_EXP 68
55853: PUSH
55854: LD_VAR 0 2
55858: ARRAY
55859: PPUSH
55860: LD_INT 2
55862: PUSH
55863: LD_INT 30
55865: PUSH
55866: LD_INT 6
55868: PUSH
55869: EMPTY
55870: LIST
55871: LIST
55872: PUSH
55873: LD_INT 30
55875: PUSH
55876: LD_INT 7
55878: PUSH
55879: EMPTY
55880: LIST
55881: LIST
55882: PUSH
55883: LD_INT 30
55885: PUSH
55886: LD_INT 8
55888: PUSH
55889: EMPTY
55890: LIST
55891: LIST
55892: PUSH
55893: EMPTY
55894: LIST
55895: LIST
55896: LIST
55897: LIST
55898: PPUSH
55899: CALL_OW 72
55903: PUSH
55904: EMPTY
55905: LIST
55906: LIST
55907: LIST
55908: LIST
55909: ST_TO_ADDR
// for j = 1 to 4 do
55910: LD_ADDR_VAR 0 3
55914: PUSH
55915: DOUBLE
55916: LD_INT 1
55918: DEC
55919: ST_TO_ADDR
55920: LD_INT 4
55922: PUSH
55923: FOR_TO
55924: IFFALSE 56115
// begin if not tmp [ j ] then
55926: LD_VAR 0 4
55930: PUSH
55931: LD_VAR 0 3
55935: ARRAY
55936: NOT
55937: IFFALSE 55941
// continue ;
55939: GO 55923
// for p in tmp [ j ] do
55941: LD_ADDR_VAR 0 5
55945: PUSH
55946: LD_VAR 0 4
55950: PUSH
55951: LD_VAR 0 3
55955: ARRAY
55956: PUSH
55957: FOR_IN
55958: IFFALSE 56111
// begin if not b [ j ] then
55960: LD_VAR 0 6
55964: PUSH
55965: LD_VAR 0 3
55969: ARRAY
55970: NOT
55971: IFFALSE 55975
// break ;
55973: GO 56111
// e := 0 ;
55975: LD_ADDR_VAR 0 7
55979: PUSH
55980: LD_INT 0
55982: ST_TO_ADDR
// for k in b [ j ] do
55983: LD_ADDR_VAR 0 8
55987: PUSH
55988: LD_VAR 0 6
55992: PUSH
55993: LD_VAR 0 3
55997: ARRAY
55998: PUSH
55999: FOR_IN
56000: IFFALSE 56027
// if IsNotFull ( k ) then
56002: LD_VAR 0 8
56006: PPUSH
56007: CALL 15814 0 1
56011: IFFALSE 56025
// begin e := k ;
56013: LD_ADDR_VAR 0 7
56017: PUSH
56018: LD_VAR 0 8
56022: ST_TO_ADDR
// break ;
56023: GO 56027
// end ;
56025: GO 55999
56027: POP
56028: POP
// if e and not UnitGoingToBuilding ( p , e ) then
56029: LD_VAR 0 7
56033: PUSH
56034: LD_VAR 0 5
56038: PPUSH
56039: LD_VAR 0 7
56043: PPUSH
56044: CALL 48567 0 2
56048: NOT
56049: AND
56050: IFFALSE 56109
// begin if IsInUnit ( p ) then
56052: LD_VAR 0 5
56056: PPUSH
56057: CALL_OW 310
56061: IFFALSE 56072
// ComExitBuilding ( p ) ;
56063: LD_VAR 0 5
56067: PPUSH
56068: CALL_OW 122
// ComEnterUnit ( p , e ) ;
56072: LD_VAR 0 5
56076: PPUSH
56077: LD_VAR 0 7
56081: PPUSH
56082: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
56086: LD_VAR 0 5
56090: PPUSH
56091: LD_VAR 0 3
56095: PPUSH
56096: CALL_OW 183
// AddComExitBuilding ( p ) ;
56100: LD_VAR 0 5
56104: PPUSH
56105: CALL_OW 182
// end ; end ;
56109: GO 55957
56111: POP
56112: POP
// end ;
56113: GO 55923
56115: POP
56116: POP
// end ;
56117: GO 55678
56119: POP
56120: POP
// end ;
56121: LD_VAR 0 1
56125: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
56126: LD_INT 0
56128: PPUSH
56129: PPUSH
56130: PPUSH
56131: PPUSH
56132: PPUSH
56133: PPUSH
56134: PPUSH
56135: PPUSH
56136: PPUSH
56137: PPUSH
56138: PPUSH
56139: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56140: LD_VAR 0 1
56144: NOT
56145: PUSH
56146: LD_EXP 68
56150: PUSH
56151: LD_VAR 0 1
56155: ARRAY
56156: NOT
56157: OR
56158: PUSH
56159: LD_EXP 68
56163: PUSH
56164: LD_VAR 0 1
56168: ARRAY
56169: PPUSH
56170: LD_INT 2
56172: PUSH
56173: LD_INT 30
56175: PUSH
56176: LD_INT 0
56178: PUSH
56179: EMPTY
56180: LIST
56181: LIST
56182: PUSH
56183: LD_INT 30
56185: PUSH
56186: LD_INT 1
56188: PUSH
56189: EMPTY
56190: LIST
56191: LIST
56192: PUSH
56193: EMPTY
56194: LIST
56195: LIST
56196: LIST
56197: PPUSH
56198: CALL_OW 72
56202: NOT
56203: OR
56204: IFFALSE 56208
// exit ;
56206: GO 59711
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56208: LD_ADDR_VAR 0 4
56212: PUSH
56213: LD_EXP 68
56217: PUSH
56218: LD_VAR 0 1
56222: ARRAY
56223: PPUSH
56224: LD_INT 2
56226: PUSH
56227: LD_INT 25
56229: PUSH
56230: LD_INT 1
56232: PUSH
56233: EMPTY
56234: LIST
56235: LIST
56236: PUSH
56237: LD_INT 25
56239: PUSH
56240: LD_INT 2
56242: PUSH
56243: EMPTY
56244: LIST
56245: LIST
56246: PUSH
56247: LD_INT 25
56249: PUSH
56250: LD_INT 3
56252: PUSH
56253: EMPTY
56254: LIST
56255: LIST
56256: PUSH
56257: LD_INT 25
56259: PUSH
56260: LD_INT 4
56262: PUSH
56263: EMPTY
56264: LIST
56265: LIST
56266: PUSH
56267: LD_INT 25
56269: PUSH
56270: LD_INT 5
56272: PUSH
56273: EMPTY
56274: LIST
56275: LIST
56276: PUSH
56277: LD_INT 25
56279: PUSH
56280: LD_INT 8
56282: PUSH
56283: EMPTY
56284: LIST
56285: LIST
56286: PUSH
56287: LD_INT 25
56289: PUSH
56290: LD_INT 9
56292: PUSH
56293: EMPTY
56294: LIST
56295: LIST
56296: PUSH
56297: EMPTY
56298: LIST
56299: LIST
56300: LIST
56301: LIST
56302: LIST
56303: LIST
56304: LIST
56305: LIST
56306: PPUSH
56307: CALL_OW 72
56311: ST_TO_ADDR
// if not tmp then
56312: LD_VAR 0 4
56316: NOT
56317: IFFALSE 56321
// exit ;
56319: GO 59711
// for i in tmp do
56321: LD_ADDR_VAR 0 3
56325: PUSH
56326: LD_VAR 0 4
56330: PUSH
56331: FOR_IN
56332: IFFALSE 56363
// if GetTag ( i ) then
56334: LD_VAR 0 3
56338: PPUSH
56339: CALL_OW 110
56343: IFFALSE 56361
// tmp := tmp diff i ;
56345: LD_ADDR_VAR 0 4
56349: PUSH
56350: LD_VAR 0 4
56354: PUSH
56355: LD_VAR 0 3
56359: DIFF
56360: ST_TO_ADDR
56361: GO 56331
56363: POP
56364: POP
// if not tmp then
56365: LD_VAR 0 4
56369: NOT
56370: IFFALSE 56374
// exit ;
56372: GO 59711
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56374: LD_ADDR_VAR 0 5
56378: PUSH
56379: LD_EXP 68
56383: PUSH
56384: LD_VAR 0 1
56388: ARRAY
56389: PPUSH
56390: LD_INT 2
56392: PUSH
56393: LD_INT 25
56395: PUSH
56396: LD_INT 1
56398: PUSH
56399: EMPTY
56400: LIST
56401: LIST
56402: PUSH
56403: LD_INT 25
56405: PUSH
56406: LD_INT 5
56408: PUSH
56409: EMPTY
56410: LIST
56411: LIST
56412: PUSH
56413: LD_INT 25
56415: PUSH
56416: LD_INT 8
56418: PUSH
56419: EMPTY
56420: LIST
56421: LIST
56422: PUSH
56423: LD_INT 25
56425: PUSH
56426: LD_INT 9
56428: PUSH
56429: EMPTY
56430: LIST
56431: LIST
56432: PUSH
56433: EMPTY
56434: LIST
56435: LIST
56436: LIST
56437: LIST
56438: LIST
56439: PPUSH
56440: CALL_OW 72
56444: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56445: LD_ADDR_VAR 0 6
56449: PUSH
56450: LD_EXP 68
56454: PUSH
56455: LD_VAR 0 1
56459: ARRAY
56460: PPUSH
56461: LD_INT 25
56463: PUSH
56464: LD_INT 2
56466: PUSH
56467: EMPTY
56468: LIST
56469: LIST
56470: PPUSH
56471: CALL_OW 72
56475: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56476: LD_ADDR_VAR 0 7
56480: PUSH
56481: LD_EXP 68
56485: PUSH
56486: LD_VAR 0 1
56490: ARRAY
56491: PPUSH
56492: LD_INT 25
56494: PUSH
56495: LD_INT 3
56497: PUSH
56498: EMPTY
56499: LIST
56500: LIST
56501: PPUSH
56502: CALL_OW 72
56506: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
56507: LD_ADDR_VAR 0 8
56511: PUSH
56512: LD_EXP 68
56516: PUSH
56517: LD_VAR 0 1
56521: ARRAY
56522: PPUSH
56523: LD_INT 25
56525: PUSH
56526: LD_INT 4
56528: PUSH
56529: EMPTY
56530: LIST
56531: LIST
56532: PUSH
56533: LD_INT 24
56535: PUSH
56536: LD_INT 251
56538: PUSH
56539: EMPTY
56540: LIST
56541: LIST
56542: PUSH
56543: EMPTY
56544: LIST
56545: LIST
56546: PPUSH
56547: CALL_OW 72
56551: ST_TO_ADDR
// if mc_scan [ base ] then
56552: LD_EXP 91
56556: PUSH
56557: LD_VAR 0 1
56561: ARRAY
56562: IFFALSE 57023
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56564: LD_ADDR_EXP 110
56568: PUSH
56569: LD_EXP 110
56573: PPUSH
56574: LD_VAR 0 1
56578: PPUSH
56579: LD_INT 4
56581: PPUSH
56582: CALL_OW 1
56586: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56587: LD_ADDR_VAR 0 12
56591: PUSH
56592: LD_EXP 68
56596: PUSH
56597: LD_VAR 0 1
56601: ARRAY
56602: PPUSH
56603: LD_INT 2
56605: PUSH
56606: LD_INT 30
56608: PUSH
56609: LD_INT 4
56611: PUSH
56612: EMPTY
56613: LIST
56614: LIST
56615: PUSH
56616: LD_INT 30
56618: PUSH
56619: LD_INT 5
56621: PUSH
56622: EMPTY
56623: LIST
56624: LIST
56625: PUSH
56626: EMPTY
56627: LIST
56628: LIST
56629: LIST
56630: PPUSH
56631: CALL_OW 72
56635: ST_TO_ADDR
// if not b then
56636: LD_VAR 0 12
56640: NOT
56641: IFFALSE 56645
// exit ;
56643: GO 59711
// p := [ ] ;
56645: LD_ADDR_VAR 0 11
56649: PUSH
56650: EMPTY
56651: ST_TO_ADDR
// if sci >= 2 then
56652: LD_VAR 0 8
56656: PUSH
56657: LD_INT 2
56659: GREATEREQUAL
56660: IFFALSE 56691
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56662: LD_ADDR_VAR 0 8
56666: PUSH
56667: LD_VAR 0 8
56671: PUSH
56672: LD_INT 1
56674: ARRAY
56675: PUSH
56676: LD_VAR 0 8
56680: PUSH
56681: LD_INT 2
56683: ARRAY
56684: PUSH
56685: EMPTY
56686: LIST
56687: LIST
56688: ST_TO_ADDR
56689: GO 56752
// if sci = 1 then
56691: LD_VAR 0 8
56695: PUSH
56696: LD_INT 1
56698: EQUAL
56699: IFFALSE 56720
// sci := [ sci [ 1 ] ] else
56701: LD_ADDR_VAR 0 8
56705: PUSH
56706: LD_VAR 0 8
56710: PUSH
56711: LD_INT 1
56713: ARRAY
56714: PUSH
56715: EMPTY
56716: LIST
56717: ST_TO_ADDR
56718: GO 56752
// if sci = 0 then
56720: LD_VAR 0 8
56724: PUSH
56725: LD_INT 0
56727: EQUAL
56728: IFFALSE 56752
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56730: LD_ADDR_VAR 0 11
56734: PUSH
56735: LD_VAR 0 4
56739: PPUSH
56740: LD_INT 4
56742: PPUSH
56743: CALL 48430 0 2
56747: PUSH
56748: LD_INT 1
56750: ARRAY
56751: ST_TO_ADDR
// if eng > 4 then
56752: LD_VAR 0 6
56756: PUSH
56757: LD_INT 4
56759: GREATER
56760: IFFALSE 56806
// for i = eng downto 4 do
56762: LD_ADDR_VAR 0 3
56766: PUSH
56767: DOUBLE
56768: LD_VAR 0 6
56772: INC
56773: ST_TO_ADDR
56774: LD_INT 4
56776: PUSH
56777: FOR_DOWNTO
56778: IFFALSE 56804
// eng := eng diff eng [ i ] ;
56780: LD_ADDR_VAR 0 6
56784: PUSH
56785: LD_VAR 0 6
56789: PUSH
56790: LD_VAR 0 6
56794: PUSH
56795: LD_VAR 0 3
56799: ARRAY
56800: DIFF
56801: ST_TO_ADDR
56802: GO 56777
56804: POP
56805: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56806: LD_ADDR_VAR 0 4
56810: PUSH
56811: LD_VAR 0 4
56815: PUSH
56816: LD_VAR 0 5
56820: PUSH
56821: LD_VAR 0 6
56825: UNION
56826: PUSH
56827: LD_VAR 0 7
56831: UNION
56832: PUSH
56833: LD_VAR 0 8
56837: UNION
56838: DIFF
56839: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56840: LD_ADDR_VAR 0 13
56844: PUSH
56845: LD_EXP 68
56849: PUSH
56850: LD_VAR 0 1
56854: ARRAY
56855: PPUSH
56856: LD_INT 2
56858: PUSH
56859: LD_INT 30
56861: PUSH
56862: LD_INT 32
56864: PUSH
56865: EMPTY
56866: LIST
56867: LIST
56868: PUSH
56869: LD_INT 30
56871: PUSH
56872: LD_INT 31
56874: PUSH
56875: EMPTY
56876: LIST
56877: LIST
56878: PUSH
56879: EMPTY
56880: LIST
56881: LIST
56882: LIST
56883: PPUSH
56884: CALL_OW 72
56888: PUSH
56889: LD_EXP 68
56893: PUSH
56894: LD_VAR 0 1
56898: ARRAY
56899: PPUSH
56900: LD_INT 2
56902: PUSH
56903: LD_INT 30
56905: PUSH
56906: LD_INT 4
56908: PUSH
56909: EMPTY
56910: LIST
56911: LIST
56912: PUSH
56913: LD_INT 30
56915: PUSH
56916: LD_INT 5
56918: PUSH
56919: EMPTY
56920: LIST
56921: LIST
56922: PUSH
56923: EMPTY
56924: LIST
56925: LIST
56926: LIST
56927: PPUSH
56928: CALL_OW 72
56932: PUSH
56933: LD_INT 6
56935: MUL
56936: PLUS
56937: ST_TO_ADDR
// if bcount < tmp then
56938: LD_VAR 0 13
56942: PUSH
56943: LD_VAR 0 4
56947: LESS
56948: IFFALSE 56994
// for i = tmp downto bcount do
56950: LD_ADDR_VAR 0 3
56954: PUSH
56955: DOUBLE
56956: LD_VAR 0 4
56960: INC
56961: ST_TO_ADDR
56962: LD_VAR 0 13
56966: PUSH
56967: FOR_DOWNTO
56968: IFFALSE 56992
// tmp := Delete ( tmp , tmp ) ;
56970: LD_ADDR_VAR 0 4
56974: PUSH
56975: LD_VAR 0 4
56979: PPUSH
56980: LD_VAR 0 4
56984: PPUSH
56985: CALL_OW 3
56989: ST_TO_ADDR
56990: GO 56967
56992: POP
56993: POP
// result := [ tmp , 0 , 0 , p ] ;
56994: LD_ADDR_VAR 0 2
56998: PUSH
56999: LD_VAR 0 4
57003: PUSH
57004: LD_INT 0
57006: PUSH
57007: LD_INT 0
57009: PUSH
57010: LD_VAR 0 11
57014: PUSH
57015: EMPTY
57016: LIST
57017: LIST
57018: LIST
57019: LIST
57020: ST_TO_ADDR
// exit ;
57021: GO 59711
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57023: LD_EXP 68
57027: PUSH
57028: LD_VAR 0 1
57032: ARRAY
57033: PPUSH
57034: LD_INT 2
57036: PUSH
57037: LD_INT 30
57039: PUSH
57040: LD_INT 6
57042: PUSH
57043: EMPTY
57044: LIST
57045: LIST
57046: PUSH
57047: LD_INT 30
57049: PUSH
57050: LD_INT 7
57052: PUSH
57053: EMPTY
57054: LIST
57055: LIST
57056: PUSH
57057: LD_INT 30
57059: PUSH
57060: LD_INT 8
57062: PUSH
57063: EMPTY
57064: LIST
57065: LIST
57066: PUSH
57067: EMPTY
57068: LIST
57069: LIST
57070: LIST
57071: LIST
57072: PPUSH
57073: CALL_OW 72
57077: NOT
57078: PUSH
57079: LD_EXP 68
57083: PUSH
57084: LD_VAR 0 1
57088: ARRAY
57089: PPUSH
57090: LD_INT 30
57092: PUSH
57093: LD_INT 3
57095: PUSH
57096: EMPTY
57097: LIST
57098: LIST
57099: PPUSH
57100: CALL_OW 72
57104: NOT
57105: AND
57106: IFFALSE 57178
// begin if eng = tmp then
57108: LD_VAR 0 6
57112: PUSH
57113: LD_VAR 0 4
57117: EQUAL
57118: IFFALSE 57122
// exit ;
57120: GO 59711
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
57122: LD_ADDR_EXP 110
57126: PUSH
57127: LD_EXP 110
57131: PPUSH
57132: LD_VAR 0 1
57136: PPUSH
57137: LD_INT 1
57139: PPUSH
57140: CALL_OW 1
57144: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
57145: LD_ADDR_VAR 0 2
57149: PUSH
57150: LD_INT 0
57152: PUSH
57153: LD_VAR 0 4
57157: PUSH
57158: LD_VAR 0 6
57162: DIFF
57163: PUSH
57164: LD_INT 0
57166: PUSH
57167: LD_INT 0
57169: PUSH
57170: EMPTY
57171: LIST
57172: LIST
57173: LIST
57174: LIST
57175: ST_TO_ADDR
// exit ;
57176: GO 59711
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57178: LD_EXP 95
57182: PUSH
57183: LD_EXP 94
57187: PUSH
57188: LD_VAR 0 1
57192: ARRAY
57193: ARRAY
57194: PUSH
57195: LD_EXP 68
57199: PUSH
57200: LD_VAR 0 1
57204: ARRAY
57205: PPUSH
57206: LD_INT 2
57208: PUSH
57209: LD_INT 30
57211: PUSH
57212: LD_INT 6
57214: PUSH
57215: EMPTY
57216: LIST
57217: LIST
57218: PUSH
57219: LD_INT 30
57221: PUSH
57222: LD_INT 7
57224: PUSH
57225: EMPTY
57226: LIST
57227: LIST
57228: PUSH
57229: LD_INT 30
57231: PUSH
57232: LD_INT 8
57234: PUSH
57235: EMPTY
57236: LIST
57237: LIST
57238: PUSH
57239: EMPTY
57240: LIST
57241: LIST
57242: LIST
57243: LIST
57244: PPUSH
57245: CALL_OW 72
57249: AND
57250: PUSH
57251: LD_EXP 68
57255: PUSH
57256: LD_VAR 0 1
57260: ARRAY
57261: PPUSH
57262: LD_INT 30
57264: PUSH
57265: LD_INT 3
57267: PUSH
57268: EMPTY
57269: LIST
57270: LIST
57271: PPUSH
57272: CALL_OW 72
57276: NOT
57277: AND
57278: IFFALSE 57492
// begin if sci >= 6 then
57280: LD_VAR 0 8
57284: PUSH
57285: LD_INT 6
57287: GREATEREQUAL
57288: IFFALSE 57292
// exit ;
57290: GO 59711
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
57292: LD_ADDR_EXP 110
57296: PUSH
57297: LD_EXP 110
57301: PPUSH
57302: LD_VAR 0 1
57306: PPUSH
57307: LD_INT 2
57309: PPUSH
57310: CALL_OW 1
57314: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
57315: LD_ADDR_VAR 0 9
57319: PUSH
57320: LD_VAR 0 4
57324: PUSH
57325: LD_VAR 0 8
57329: DIFF
57330: PPUSH
57331: LD_INT 4
57333: PPUSH
57334: CALL 48430 0 2
57338: ST_TO_ADDR
// p := [ ] ;
57339: LD_ADDR_VAR 0 11
57343: PUSH
57344: EMPTY
57345: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57346: LD_VAR 0 8
57350: PUSH
57351: LD_INT 6
57353: LESS
57354: PUSH
57355: LD_VAR 0 9
57359: PUSH
57360: LD_INT 6
57362: GREATER
57363: AND
57364: IFFALSE 57445
// begin for i = 1 to 6 - sci do
57366: LD_ADDR_VAR 0 3
57370: PUSH
57371: DOUBLE
57372: LD_INT 1
57374: DEC
57375: ST_TO_ADDR
57376: LD_INT 6
57378: PUSH
57379: LD_VAR 0 8
57383: MINUS
57384: PUSH
57385: FOR_TO
57386: IFFALSE 57441
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57388: LD_ADDR_VAR 0 11
57392: PUSH
57393: LD_VAR 0 11
57397: PPUSH
57398: LD_VAR 0 11
57402: PUSH
57403: LD_INT 1
57405: PLUS
57406: PPUSH
57407: LD_VAR 0 9
57411: PUSH
57412: LD_INT 1
57414: ARRAY
57415: PPUSH
57416: CALL_OW 2
57420: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57421: LD_ADDR_VAR 0 9
57425: PUSH
57426: LD_VAR 0 9
57430: PPUSH
57431: LD_INT 1
57433: PPUSH
57434: CALL_OW 3
57438: ST_TO_ADDR
// end ;
57439: GO 57385
57441: POP
57442: POP
// end else
57443: GO 57465
// if sort then
57445: LD_VAR 0 9
57449: IFFALSE 57465
// p := sort [ 1 ] ;
57451: LD_ADDR_VAR 0 11
57455: PUSH
57456: LD_VAR 0 9
57460: PUSH
57461: LD_INT 1
57463: ARRAY
57464: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57465: LD_ADDR_VAR 0 2
57469: PUSH
57470: LD_INT 0
57472: PUSH
57473: LD_INT 0
57475: PUSH
57476: LD_INT 0
57478: PUSH
57479: LD_VAR 0 11
57483: PUSH
57484: EMPTY
57485: LIST
57486: LIST
57487: LIST
57488: LIST
57489: ST_TO_ADDR
// exit ;
57490: GO 59711
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57492: LD_EXP 95
57496: PUSH
57497: LD_EXP 94
57501: PUSH
57502: LD_VAR 0 1
57506: ARRAY
57507: ARRAY
57508: PUSH
57509: LD_EXP 68
57513: PUSH
57514: LD_VAR 0 1
57518: ARRAY
57519: PPUSH
57520: LD_INT 2
57522: PUSH
57523: LD_INT 30
57525: PUSH
57526: LD_INT 6
57528: PUSH
57529: EMPTY
57530: LIST
57531: LIST
57532: PUSH
57533: LD_INT 30
57535: PUSH
57536: LD_INT 7
57538: PUSH
57539: EMPTY
57540: LIST
57541: LIST
57542: PUSH
57543: LD_INT 30
57545: PUSH
57546: LD_INT 8
57548: PUSH
57549: EMPTY
57550: LIST
57551: LIST
57552: PUSH
57553: EMPTY
57554: LIST
57555: LIST
57556: LIST
57557: LIST
57558: PPUSH
57559: CALL_OW 72
57563: AND
57564: PUSH
57565: LD_EXP 68
57569: PUSH
57570: LD_VAR 0 1
57574: ARRAY
57575: PPUSH
57576: LD_INT 30
57578: PUSH
57579: LD_INT 3
57581: PUSH
57582: EMPTY
57583: LIST
57584: LIST
57585: PPUSH
57586: CALL_OW 72
57590: AND
57591: IFFALSE 58325
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57593: LD_ADDR_EXP 110
57597: PUSH
57598: LD_EXP 110
57602: PPUSH
57603: LD_VAR 0 1
57607: PPUSH
57608: LD_INT 3
57610: PPUSH
57611: CALL_OW 1
57615: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57616: LD_ADDR_VAR 0 2
57620: PUSH
57621: LD_INT 0
57623: PUSH
57624: LD_INT 0
57626: PUSH
57627: LD_INT 0
57629: PUSH
57630: LD_INT 0
57632: PUSH
57633: EMPTY
57634: LIST
57635: LIST
57636: LIST
57637: LIST
57638: ST_TO_ADDR
// if not eng then
57639: LD_VAR 0 6
57643: NOT
57644: IFFALSE 57707
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
57646: LD_ADDR_VAR 0 11
57650: PUSH
57651: LD_VAR 0 4
57655: PPUSH
57656: LD_INT 2
57658: PPUSH
57659: CALL 48430 0 2
57663: PUSH
57664: LD_INT 1
57666: ARRAY
57667: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57668: LD_ADDR_VAR 0 2
57672: PUSH
57673: LD_VAR 0 2
57677: PPUSH
57678: LD_INT 2
57680: PPUSH
57681: LD_VAR 0 11
57685: PPUSH
57686: CALL_OW 1
57690: ST_TO_ADDR
// tmp := tmp diff p ;
57691: LD_ADDR_VAR 0 4
57695: PUSH
57696: LD_VAR 0 4
57700: PUSH
57701: LD_VAR 0 11
57705: DIFF
57706: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57707: LD_VAR 0 4
57711: PUSH
57712: LD_VAR 0 8
57716: PUSH
57717: LD_INT 6
57719: LESS
57720: AND
57721: IFFALSE 57909
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57723: LD_ADDR_VAR 0 9
57727: PUSH
57728: LD_VAR 0 4
57732: PUSH
57733: LD_VAR 0 8
57737: PUSH
57738: LD_VAR 0 7
57742: UNION
57743: DIFF
57744: PPUSH
57745: LD_INT 4
57747: PPUSH
57748: CALL 48430 0 2
57752: ST_TO_ADDR
// p := [ ] ;
57753: LD_ADDR_VAR 0 11
57757: PUSH
57758: EMPTY
57759: ST_TO_ADDR
// if sort then
57760: LD_VAR 0 9
57764: IFFALSE 57880
// for i = 1 to 6 - sci do
57766: LD_ADDR_VAR 0 3
57770: PUSH
57771: DOUBLE
57772: LD_INT 1
57774: DEC
57775: ST_TO_ADDR
57776: LD_INT 6
57778: PUSH
57779: LD_VAR 0 8
57783: MINUS
57784: PUSH
57785: FOR_TO
57786: IFFALSE 57878
// begin if i = sort then
57788: LD_VAR 0 3
57792: PUSH
57793: LD_VAR 0 9
57797: EQUAL
57798: IFFALSE 57802
// break ;
57800: GO 57878
// if GetClass ( i ) = 4 then
57802: LD_VAR 0 3
57806: PPUSH
57807: CALL_OW 257
57811: PUSH
57812: LD_INT 4
57814: EQUAL
57815: IFFALSE 57819
// continue ;
57817: GO 57785
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57819: LD_ADDR_VAR 0 11
57823: PUSH
57824: LD_VAR 0 11
57828: PPUSH
57829: LD_VAR 0 11
57833: PUSH
57834: LD_INT 1
57836: PLUS
57837: PPUSH
57838: LD_VAR 0 9
57842: PUSH
57843: LD_VAR 0 3
57847: ARRAY
57848: PPUSH
57849: CALL_OW 2
57853: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57854: LD_ADDR_VAR 0 4
57858: PUSH
57859: LD_VAR 0 4
57863: PUSH
57864: LD_VAR 0 9
57868: PUSH
57869: LD_VAR 0 3
57873: ARRAY
57874: DIFF
57875: ST_TO_ADDR
// end ;
57876: GO 57785
57878: POP
57879: POP
// if p then
57880: LD_VAR 0 11
57884: IFFALSE 57909
// result := Replace ( result , 4 , p ) ;
57886: LD_ADDR_VAR 0 2
57890: PUSH
57891: LD_VAR 0 2
57895: PPUSH
57896: LD_INT 4
57898: PPUSH
57899: LD_VAR 0 11
57903: PPUSH
57904: CALL_OW 1
57908: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57909: LD_VAR 0 4
57913: PUSH
57914: LD_VAR 0 7
57918: PUSH
57919: LD_INT 6
57921: LESS
57922: AND
57923: IFFALSE 58111
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57925: LD_ADDR_VAR 0 9
57929: PUSH
57930: LD_VAR 0 4
57934: PUSH
57935: LD_VAR 0 8
57939: PUSH
57940: LD_VAR 0 7
57944: UNION
57945: DIFF
57946: PPUSH
57947: LD_INT 3
57949: PPUSH
57950: CALL 48430 0 2
57954: ST_TO_ADDR
// p := [ ] ;
57955: LD_ADDR_VAR 0 11
57959: PUSH
57960: EMPTY
57961: ST_TO_ADDR
// if sort then
57962: LD_VAR 0 9
57966: IFFALSE 58082
// for i = 1 to 6 - mech do
57968: LD_ADDR_VAR 0 3
57972: PUSH
57973: DOUBLE
57974: LD_INT 1
57976: DEC
57977: ST_TO_ADDR
57978: LD_INT 6
57980: PUSH
57981: LD_VAR 0 7
57985: MINUS
57986: PUSH
57987: FOR_TO
57988: IFFALSE 58080
// begin if i = sort then
57990: LD_VAR 0 3
57994: PUSH
57995: LD_VAR 0 9
57999: EQUAL
58000: IFFALSE 58004
// break ;
58002: GO 58080
// if GetClass ( i ) = 3 then
58004: LD_VAR 0 3
58008: PPUSH
58009: CALL_OW 257
58013: PUSH
58014: LD_INT 3
58016: EQUAL
58017: IFFALSE 58021
// continue ;
58019: GO 57987
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58021: LD_ADDR_VAR 0 11
58025: PUSH
58026: LD_VAR 0 11
58030: PPUSH
58031: LD_VAR 0 11
58035: PUSH
58036: LD_INT 1
58038: PLUS
58039: PPUSH
58040: LD_VAR 0 9
58044: PUSH
58045: LD_VAR 0 3
58049: ARRAY
58050: PPUSH
58051: CALL_OW 2
58055: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58056: LD_ADDR_VAR 0 4
58060: PUSH
58061: LD_VAR 0 4
58065: PUSH
58066: LD_VAR 0 9
58070: PUSH
58071: LD_VAR 0 3
58075: ARRAY
58076: DIFF
58077: ST_TO_ADDR
// end ;
58078: GO 57987
58080: POP
58081: POP
// if p then
58082: LD_VAR 0 11
58086: IFFALSE 58111
// result := Replace ( result , 3 , p ) ;
58088: LD_ADDR_VAR 0 2
58092: PUSH
58093: LD_VAR 0 2
58097: PPUSH
58098: LD_INT 3
58100: PPUSH
58101: LD_VAR 0 11
58105: PPUSH
58106: CALL_OW 1
58110: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
58111: LD_VAR 0 4
58115: PUSH
58116: LD_INT 6
58118: GREATER
58119: PUSH
58120: LD_VAR 0 6
58124: PUSH
58125: LD_INT 6
58127: LESS
58128: AND
58129: IFFALSE 58323
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58131: LD_ADDR_VAR 0 9
58135: PUSH
58136: LD_VAR 0 4
58140: PUSH
58141: LD_VAR 0 8
58145: PUSH
58146: LD_VAR 0 7
58150: UNION
58151: PUSH
58152: LD_VAR 0 6
58156: UNION
58157: DIFF
58158: PPUSH
58159: LD_INT 2
58161: PPUSH
58162: CALL 48430 0 2
58166: ST_TO_ADDR
// p := [ ] ;
58167: LD_ADDR_VAR 0 11
58171: PUSH
58172: EMPTY
58173: ST_TO_ADDR
// if sort then
58174: LD_VAR 0 9
58178: IFFALSE 58294
// for i = 1 to 6 - eng do
58180: LD_ADDR_VAR 0 3
58184: PUSH
58185: DOUBLE
58186: LD_INT 1
58188: DEC
58189: ST_TO_ADDR
58190: LD_INT 6
58192: PUSH
58193: LD_VAR 0 6
58197: MINUS
58198: PUSH
58199: FOR_TO
58200: IFFALSE 58292
// begin if i = sort then
58202: LD_VAR 0 3
58206: PUSH
58207: LD_VAR 0 9
58211: EQUAL
58212: IFFALSE 58216
// break ;
58214: GO 58292
// if GetClass ( i ) = 2 then
58216: LD_VAR 0 3
58220: PPUSH
58221: CALL_OW 257
58225: PUSH
58226: LD_INT 2
58228: EQUAL
58229: IFFALSE 58233
// continue ;
58231: GO 58199
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58233: LD_ADDR_VAR 0 11
58237: PUSH
58238: LD_VAR 0 11
58242: PPUSH
58243: LD_VAR 0 11
58247: PUSH
58248: LD_INT 1
58250: PLUS
58251: PPUSH
58252: LD_VAR 0 9
58256: PUSH
58257: LD_VAR 0 3
58261: ARRAY
58262: PPUSH
58263: CALL_OW 2
58267: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58268: LD_ADDR_VAR 0 4
58272: PUSH
58273: LD_VAR 0 4
58277: PUSH
58278: LD_VAR 0 9
58282: PUSH
58283: LD_VAR 0 3
58287: ARRAY
58288: DIFF
58289: ST_TO_ADDR
// end ;
58290: GO 58199
58292: POP
58293: POP
// if p then
58294: LD_VAR 0 11
58298: IFFALSE 58323
// result := Replace ( result , 2 , p ) ;
58300: LD_ADDR_VAR 0 2
58304: PUSH
58305: LD_VAR 0 2
58309: PPUSH
58310: LD_INT 2
58312: PPUSH
58313: LD_VAR 0 11
58317: PPUSH
58318: CALL_OW 1
58322: ST_TO_ADDR
// end ; exit ;
58323: GO 59711
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
58325: LD_EXP 95
58329: PUSH
58330: LD_EXP 94
58334: PUSH
58335: LD_VAR 0 1
58339: ARRAY
58340: ARRAY
58341: NOT
58342: PUSH
58343: LD_EXP 68
58347: PUSH
58348: LD_VAR 0 1
58352: ARRAY
58353: PPUSH
58354: LD_INT 30
58356: PUSH
58357: LD_INT 3
58359: PUSH
58360: EMPTY
58361: LIST
58362: LIST
58363: PPUSH
58364: CALL_OW 72
58368: AND
58369: PUSH
58370: LD_EXP 73
58374: PUSH
58375: LD_VAR 0 1
58379: ARRAY
58380: AND
58381: IFFALSE 58989
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58383: LD_ADDR_EXP 110
58387: PUSH
58388: LD_EXP 110
58392: PPUSH
58393: LD_VAR 0 1
58397: PPUSH
58398: LD_INT 5
58400: PPUSH
58401: CALL_OW 1
58405: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58406: LD_ADDR_VAR 0 2
58410: PUSH
58411: LD_INT 0
58413: PUSH
58414: LD_INT 0
58416: PUSH
58417: LD_INT 0
58419: PUSH
58420: LD_INT 0
58422: PUSH
58423: EMPTY
58424: LIST
58425: LIST
58426: LIST
58427: LIST
58428: ST_TO_ADDR
// if sci > 1 then
58429: LD_VAR 0 8
58433: PUSH
58434: LD_INT 1
58436: GREATER
58437: IFFALSE 58465
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58439: LD_ADDR_VAR 0 4
58443: PUSH
58444: LD_VAR 0 4
58448: PUSH
58449: LD_VAR 0 8
58453: PUSH
58454: LD_VAR 0 8
58458: PUSH
58459: LD_INT 1
58461: ARRAY
58462: DIFF
58463: DIFF
58464: ST_TO_ADDR
// if tmp and not sci then
58465: LD_VAR 0 4
58469: PUSH
58470: LD_VAR 0 8
58474: NOT
58475: AND
58476: IFFALSE 58545
// begin sort := SortBySkill ( tmp , 4 ) ;
58478: LD_ADDR_VAR 0 9
58482: PUSH
58483: LD_VAR 0 4
58487: PPUSH
58488: LD_INT 4
58490: PPUSH
58491: CALL 48430 0 2
58495: ST_TO_ADDR
// if sort then
58496: LD_VAR 0 9
58500: IFFALSE 58516
// p := sort [ 1 ] ;
58502: LD_ADDR_VAR 0 11
58506: PUSH
58507: LD_VAR 0 9
58511: PUSH
58512: LD_INT 1
58514: ARRAY
58515: ST_TO_ADDR
// if p then
58516: LD_VAR 0 11
58520: IFFALSE 58545
// result := Replace ( result , 4 , p ) ;
58522: LD_ADDR_VAR 0 2
58526: PUSH
58527: LD_VAR 0 2
58531: PPUSH
58532: LD_INT 4
58534: PPUSH
58535: LD_VAR 0 11
58539: PPUSH
58540: CALL_OW 1
58544: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58545: LD_ADDR_VAR 0 4
58549: PUSH
58550: LD_VAR 0 4
58554: PUSH
58555: LD_VAR 0 7
58559: DIFF
58560: ST_TO_ADDR
// if tmp and mech < 6 then
58561: LD_VAR 0 4
58565: PUSH
58566: LD_VAR 0 7
58570: PUSH
58571: LD_INT 6
58573: LESS
58574: AND
58575: IFFALSE 58763
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58577: LD_ADDR_VAR 0 9
58581: PUSH
58582: LD_VAR 0 4
58586: PUSH
58587: LD_VAR 0 8
58591: PUSH
58592: LD_VAR 0 7
58596: UNION
58597: DIFF
58598: PPUSH
58599: LD_INT 3
58601: PPUSH
58602: CALL 48430 0 2
58606: ST_TO_ADDR
// p := [ ] ;
58607: LD_ADDR_VAR 0 11
58611: PUSH
58612: EMPTY
58613: ST_TO_ADDR
// if sort then
58614: LD_VAR 0 9
58618: IFFALSE 58734
// for i = 1 to 6 - mech do
58620: LD_ADDR_VAR 0 3
58624: PUSH
58625: DOUBLE
58626: LD_INT 1
58628: DEC
58629: ST_TO_ADDR
58630: LD_INT 6
58632: PUSH
58633: LD_VAR 0 7
58637: MINUS
58638: PUSH
58639: FOR_TO
58640: IFFALSE 58732
// begin if i = sort then
58642: LD_VAR 0 3
58646: PUSH
58647: LD_VAR 0 9
58651: EQUAL
58652: IFFALSE 58656
// break ;
58654: GO 58732
// if GetClass ( i ) = 3 then
58656: LD_VAR 0 3
58660: PPUSH
58661: CALL_OW 257
58665: PUSH
58666: LD_INT 3
58668: EQUAL
58669: IFFALSE 58673
// continue ;
58671: GO 58639
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58673: LD_ADDR_VAR 0 11
58677: PUSH
58678: LD_VAR 0 11
58682: PPUSH
58683: LD_VAR 0 11
58687: PUSH
58688: LD_INT 1
58690: PLUS
58691: PPUSH
58692: LD_VAR 0 9
58696: PUSH
58697: LD_VAR 0 3
58701: ARRAY
58702: PPUSH
58703: CALL_OW 2
58707: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58708: LD_ADDR_VAR 0 4
58712: PUSH
58713: LD_VAR 0 4
58717: PUSH
58718: LD_VAR 0 9
58722: PUSH
58723: LD_VAR 0 3
58727: ARRAY
58728: DIFF
58729: ST_TO_ADDR
// end ;
58730: GO 58639
58732: POP
58733: POP
// if p then
58734: LD_VAR 0 11
58738: IFFALSE 58763
// result := Replace ( result , 3 , p ) ;
58740: LD_ADDR_VAR 0 2
58744: PUSH
58745: LD_VAR 0 2
58749: PPUSH
58750: LD_INT 3
58752: PPUSH
58753: LD_VAR 0 11
58757: PPUSH
58758: CALL_OW 1
58762: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58763: LD_ADDR_VAR 0 4
58767: PUSH
58768: LD_VAR 0 4
58772: PUSH
58773: LD_VAR 0 6
58777: DIFF
58778: ST_TO_ADDR
// if tmp and eng < 6 then
58779: LD_VAR 0 4
58783: PUSH
58784: LD_VAR 0 6
58788: PUSH
58789: LD_INT 6
58791: LESS
58792: AND
58793: IFFALSE 58987
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58795: LD_ADDR_VAR 0 9
58799: PUSH
58800: LD_VAR 0 4
58804: PUSH
58805: LD_VAR 0 8
58809: PUSH
58810: LD_VAR 0 7
58814: UNION
58815: PUSH
58816: LD_VAR 0 6
58820: UNION
58821: DIFF
58822: PPUSH
58823: LD_INT 2
58825: PPUSH
58826: CALL 48430 0 2
58830: ST_TO_ADDR
// p := [ ] ;
58831: LD_ADDR_VAR 0 11
58835: PUSH
58836: EMPTY
58837: ST_TO_ADDR
// if sort then
58838: LD_VAR 0 9
58842: IFFALSE 58958
// for i = 1 to 6 - eng do
58844: LD_ADDR_VAR 0 3
58848: PUSH
58849: DOUBLE
58850: LD_INT 1
58852: DEC
58853: ST_TO_ADDR
58854: LD_INT 6
58856: PUSH
58857: LD_VAR 0 6
58861: MINUS
58862: PUSH
58863: FOR_TO
58864: IFFALSE 58956
// begin if i = sort then
58866: LD_VAR 0 3
58870: PUSH
58871: LD_VAR 0 9
58875: EQUAL
58876: IFFALSE 58880
// break ;
58878: GO 58956
// if GetClass ( i ) = 2 then
58880: LD_VAR 0 3
58884: PPUSH
58885: CALL_OW 257
58889: PUSH
58890: LD_INT 2
58892: EQUAL
58893: IFFALSE 58897
// continue ;
58895: GO 58863
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58897: LD_ADDR_VAR 0 11
58901: PUSH
58902: LD_VAR 0 11
58906: PPUSH
58907: LD_VAR 0 11
58911: PUSH
58912: LD_INT 1
58914: PLUS
58915: PPUSH
58916: LD_VAR 0 9
58920: PUSH
58921: LD_VAR 0 3
58925: ARRAY
58926: PPUSH
58927: CALL_OW 2
58931: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58932: LD_ADDR_VAR 0 4
58936: PUSH
58937: LD_VAR 0 4
58941: PUSH
58942: LD_VAR 0 9
58946: PUSH
58947: LD_VAR 0 3
58951: ARRAY
58952: DIFF
58953: ST_TO_ADDR
// end ;
58954: GO 58863
58956: POP
58957: POP
// if p then
58958: LD_VAR 0 11
58962: IFFALSE 58987
// result := Replace ( result , 2 , p ) ;
58964: LD_ADDR_VAR 0 2
58968: PUSH
58969: LD_VAR 0 2
58973: PPUSH
58974: LD_INT 2
58976: PPUSH
58977: LD_VAR 0 11
58981: PPUSH
58982: CALL_OW 1
58986: ST_TO_ADDR
// end ; exit ;
58987: GO 59711
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58989: LD_EXP 95
58993: PUSH
58994: LD_EXP 94
58998: PUSH
58999: LD_VAR 0 1
59003: ARRAY
59004: ARRAY
59005: NOT
59006: PUSH
59007: LD_EXP 68
59011: PUSH
59012: LD_VAR 0 1
59016: ARRAY
59017: PPUSH
59018: LD_INT 30
59020: PUSH
59021: LD_INT 3
59023: PUSH
59024: EMPTY
59025: LIST
59026: LIST
59027: PPUSH
59028: CALL_OW 72
59032: AND
59033: PUSH
59034: LD_EXP 73
59038: PUSH
59039: LD_VAR 0 1
59043: ARRAY
59044: NOT
59045: AND
59046: IFFALSE 59711
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
59048: LD_ADDR_EXP 110
59052: PUSH
59053: LD_EXP 110
59057: PPUSH
59058: LD_VAR 0 1
59062: PPUSH
59063: LD_INT 6
59065: PPUSH
59066: CALL_OW 1
59070: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59071: LD_ADDR_VAR 0 2
59075: PUSH
59076: LD_INT 0
59078: PUSH
59079: LD_INT 0
59081: PUSH
59082: LD_INT 0
59084: PUSH
59085: LD_INT 0
59087: PUSH
59088: EMPTY
59089: LIST
59090: LIST
59091: LIST
59092: LIST
59093: ST_TO_ADDR
// if sci >= 1 then
59094: LD_VAR 0 8
59098: PUSH
59099: LD_INT 1
59101: GREATEREQUAL
59102: IFFALSE 59124
// tmp := tmp diff sci [ 1 ] ;
59104: LD_ADDR_VAR 0 4
59108: PUSH
59109: LD_VAR 0 4
59113: PUSH
59114: LD_VAR 0 8
59118: PUSH
59119: LD_INT 1
59121: ARRAY
59122: DIFF
59123: ST_TO_ADDR
// if tmp and not sci then
59124: LD_VAR 0 4
59128: PUSH
59129: LD_VAR 0 8
59133: NOT
59134: AND
59135: IFFALSE 59204
// begin sort := SortBySkill ( tmp , 4 ) ;
59137: LD_ADDR_VAR 0 9
59141: PUSH
59142: LD_VAR 0 4
59146: PPUSH
59147: LD_INT 4
59149: PPUSH
59150: CALL 48430 0 2
59154: ST_TO_ADDR
// if sort then
59155: LD_VAR 0 9
59159: IFFALSE 59175
// p := sort [ 1 ] ;
59161: LD_ADDR_VAR 0 11
59165: PUSH
59166: LD_VAR 0 9
59170: PUSH
59171: LD_INT 1
59173: ARRAY
59174: ST_TO_ADDR
// if p then
59175: LD_VAR 0 11
59179: IFFALSE 59204
// result := Replace ( result , 4 , p ) ;
59181: LD_ADDR_VAR 0 2
59185: PUSH
59186: LD_VAR 0 2
59190: PPUSH
59191: LD_INT 4
59193: PPUSH
59194: LD_VAR 0 11
59198: PPUSH
59199: CALL_OW 1
59203: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59204: LD_ADDR_VAR 0 4
59208: PUSH
59209: LD_VAR 0 4
59213: PUSH
59214: LD_VAR 0 7
59218: DIFF
59219: ST_TO_ADDR
// if tmp and mech < 6 then
59220: LD_VAR 0 4
59224: PUSH
59225: LD_VAR 0 7
59229: PUSH
59230: LD_INT 6
59232: LESS
59233: AND
59234: IFFALSE 59416
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
59236: LD_ADDR_VAR 0 9
59240: PUSH
59241: LD_VAR 0 4
59245: PUSH
59246: LD_VAR 0 7
59250: DIFF
59251: PPUSH
59252: LD_INT 3
59254: PPUSH
59255: CALL 48430 0 2
59259: ST_TO_ADDR
// p := [ ] ;
59260: LD_ADDR_VAR 0 11
59264: PUSH
59265: EMPTY
59266: ST_TO_ADDR
// if sort then
59267: LD_VAR 0 9
59271: IFFALSE 59387
// for i = 1 to 6 - mech do
59273: LD_ADDR_VAR 0 3
59277: PUSH
59278: DOUBLE
59279: LD_INT 1
59281: DEC
59282: ST_TO_ADDR
59283: LD_INT 6
59285: PUSH
59286: LD_VAR 0 7
59290: MINUS
59291: PUSH
59292: FOR_TO
59293: IFFALSE 59385
// begin if i = sort then
59295: LD_VAR 0 3
59299: PUSH
59300: LD_VAR 0 9
59304: EQUAL
59305: IFFALSE 59309
// break ;
59307: GO 59385
// if GetClass ( i ) = 3 then
59309: LD_VAR 0 3
59313: PPUSH
59314: CALL_OW 257
59318: PUSH
59319: LD_INT 3
59321: EQUAL
59322: IFFALSE 59326
// continue ;
59324: GO 59292
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59326: LD_ADDR_VAR 0 11
59330: PUSH
59331: LD_VAR 0 11
59335: PPUSH
59336: LD_VAR 0 11
59340: PUSH
59341: LD_INT 1
59343: PLUS
59344: PPUSH
59345: LD_VAR 0 9
59349: PUSH
59350: LD_VAR 0 3
59354: ARRAY
59355: PPUSH
59356: CALL_OW 2
59360: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59361: LD_ADDR_VAR 0 4
59365: PUSH
59366: LD_VAR 0 4
59370: PUSH
59371: LD_VAR 0 9
59375: PUSH
59376: LD_VAR 0 3
59380: ARRAY
59381: DIFF
59382: ST_TO_ADDR
// end ;
59383: GO 59292
59385: POP
59386: POP
// if p then
59387: LD_VAR 0 11
59391: IFFALSE 59416
// result := Replace ( result , 3 , p ) ;
59393: LD_ADDR_VAR 0 2
59397: PUSH
59398: LD_VAR 0 2
59402: PPUSH
59403: LD_INT 3
59405: PPUSH
59406: LD_VAR 0 11
59410: PPUSH
59411: CALL_OW 1
59415: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59416: LD_ADDR_VAR 0 4
59420: PUSH
59421: LD_VAR 0 4
59425: PUSH
59426: LD_VAR 0 6
59430: DIFF
59431: ST_TO_ADDR
// if tmp and eng < 4 then
59432: LD_VAR 0 4
59436: PUSH
59437: LD_VAR 0 6
59441: PUSH
59442: LD_INT 4
59444: LESS
59445: AND
59446: IFFALSE 59636
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59448: LD_ADDR_VAR 0 9
59452: PUSH
59453: LD_VAR 0 4
59457: PUSH
59458: LD_VAR 0 7
59462: PUSH
59463: LD_VAR 0 6
59467: UNION
59468: DIFF
59469: PPUSH
59470: LD_INT 2
59472: PPUSH
59473: CALL 48430 0 2
59477: ST_TO_ADDR
// p := [ ] ;
59478: LD_ADDR_VAR 0 11
59482: PUSH
59483: EMPTY
59484: ST_TO_ADDR
// if sort then
59485: LD_VAR 0 9
59489: IFFALSE 59605
// for i = 1 to 4 - eng do
59491: LD_ADDR_VAR 0 3
59495: PUSH
59496: DOUBLE
59497: LD_INT 1
59499: DEC
59500: ST_TO_ADDR
59501: LD_INT 4
59503: PUSH
59504: LD_VAR 0 6
59508: MINUS
59509: PUSH
59510: FOR_TO
59511: IFFALSE 59603
// begin if i = sort then
59513: LD_VAR 0 3
59517: PUSH
59518: LD_VAR 0 9
59522: EQUAL
59523: IFFALSE 59527
// break ;
59525: GO 59603
// if GetClass ( i ) = 2 then
59527: LD_VAR 0 3
59531: PPUSH
59532: CALL_OW 257
59536: PUSH
59537: LD_INT 2
59539: EQUAL
59540: IFFALSE 59544
// continue ;
59542: GO 59510
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59544: LD_ADDR_VAR 0 11
59548: PUSH
59549: LD_VAR 0 11
59553: PPUSH
59554: LD_VAR 0 11
59558: PUSH
59559: LD_INT 1
59561: PLUS
59562: PPUSH
59563: LD_VAR 0 9
59567: PUSH
59568: LD_VAR 0 3
59572: ARRAY
59573: PPUSH
59574: CALL_OW 2
59578: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59579: LD_ADDR_VAR 0 4
59583: PUSH
59584: LD_VAR 0 4
59588: PUSH
59589: LD_VAR 0 9
59593: PUSH
59594: LD_VAR 0 3
59598: ARRAY
59599: DIFF
59600: ST_TO_ADDR
// end ;
59601: GO 59510
59603: POP
59604: POP
// if p then
59605: LD_VAR 0 11
59609: IFFALSE 59634
// result := Replace ( result , 2 , p ) ;
59611: LD_ADDR_VAR 0 2
59615: PUSH
59616: LD_VAR 0 2
59620: PPUSH
59621: LD_INT 2
59623: PPUSH
59624: LD_VAR 0 11
59628: PPUSH
59629: CALL_OW 1
59633: ST_TO_ADDR
// end else
59634: GO 59680
// for i = eng downto 5 do
59636: LD_ADDR_VAR 0 3
59640: PUSH
59641: DOUBLE
59642: LD_VAR 0 6
59646: INC
59647: ST_TO_ADDR
59648: LD_INT 5
59650: PUSH
59651: FOR_DOWNTO
59652: IFFALSE 59678
// tmp := tmp union eng [ i ] ;
59654: LD_ADDR_VAR 0 4
59658: PUSH
59659: LD_VAR 0 4
59663: PUSH
59664: LD_VAR 0 6
59668: PUSH
59669: LD_VAR 0 3
59673: ARRAY
59674: UNION
59675: ST_TO_ADDR
59676: GO 59651
59678: POP
59679: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59680: LD_ADDR_VAR 0 2
59684: PUSH
59685: LD_VAR 0 2
59689: PPUSH
59690: LD_INT 1
59692: PPUSH
59693: LD_VAR 0 4
59697: PUSH
59698: LD_VAR 0 5
59702: DIFF
59703: PPUSH
59704: CALL_OW 1
59708: ST_TO_ADDR
// exit ;
59709: GO 59711
// end ; end ;
59711: LD_VAR 0 2
59715: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59716: LD_INT 0
59718: PPUSH
59719: PPUSH
59720: PPUSH
// if not mc_bases then
59721: LD_EXP 68
59725: NOT
59726: IFFALSE 59730
// exit ;
59728: GO 59836
// for i = 1 to mc_bases do
59730: LD_ADDR_VAR 0 2
59734: PUSH
59735: DOUBLE
59736: LD_INT 1
59738: DEC
59739: ST_TO_ADDR
59740: LD_EXP 68
59744: PUSH
59745: FOR_TO
59746: IFFALSE 59827
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59748: LD_ADDR_VAR 0 3
59752: PUSH
59753: LD_EXP 68
59757: PUSH
59758: LD_VAR 0 2
59762: ARRAY
59763: PPUSH
59764: LD_INT 21
59766: PUSH
59767: LD_INT 3
59769: PUSH
59770: EMPTY
59771: LIST
59772: LIST
59773: PUSH
59774: LD_INT 3
59776: PUSH
59777: LD_INT 24
59779: PUSH
59780: LD_INT 1000
59782: PUSH
59783: EMPTY
59784: LIST
59785: LIST
59786: PUSH
59787: EMPTY
59788: LIST
59789: LIST
59790: PUSH
59791: EMPTY
59792: LIST
59793: LIST
59794: PPUSH
59795: CALL_OW 72
59799: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59800: LD_ADDR_EXP 69
59804: PUSH
59805: LD_EXP 69
59809: PPUSH
59810: LD_VAR 0 2
59814: PPUSH
59815: LD_VAR 0 3
59819: PPUSH
59820: CALL_OW 1
59824: ST_TO_ADDR
// end ;
59825: GO 59745
59827: POP
59828: POP
// RaiseSailEvent ( 101 ) ;
59829: LD_INT 101
59831: PPUSH
59832: CALL_OW 427
// end ;
59836: LD_VAR 0 1
59840: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59841: LD_INT 0
59843: PPUSH
59844: PPUSH
59845: PPUSH
59846: PPUSH
59847: PPUSH
59848: PPUSH
59849: PPUSH
// if not mc_bases then
59850: LD_EXP 68
59854: NOT
59855: IFFALSE 59859
// exit ;
59857: GO 60421
// for i = 1 to mc_bases do
59859: LD_ADDR_VAR 0 2
59863: PUSH
59864: DOUBLE
59865: LD_INT 1
59867: DEC
59868: ST_TO_ADDR
59869: LD_EXP 68
59873: PUSH
59874: FOR_TO
59875: IFFALSE 60412
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
59877: LD_ADDR_VAR 0 5
59881: PUSH
59882: LD_EXP 68
59886: PUSH
59887: LD_VAR 0 2
59891: ARRAY
59892: PUSH
59893: LD_EXP 97
59897: PUSH
59898: LD_VAR 0 2
59902: ARRAY
59903: UNION
59904: PPUSH
59905: LD_INT 21
59907: PUSH
59908: LD_INT 1
59910: PUSH
59911: EMPTY
59912: LIST
59913: LIST
59914: PUSH
59915: LD_INT 1
59917: PUSH
59918: LD_INT 3
59920: PUSH
59921: LD_INT 54
59923: PUSH
59924: EMPTY
59925: LIST
59926: PUSH
59927: EMPTY
59928: LIST
59929: LIST
59930: PUSH
59931: LD_INT 3
59933: PUSH
59934: LD_INT 24
59936: PUSH
59937: LD_INT 1000
59939: PUSH
59940: EMPTY
59941: LIST
59942: LIST
59943: PUSH
59944: EMPTY
59945: LIST
59946: LIST
59947: PUSH
59948: EMPTY
59949: LIST
59950: LIST
59951: LIST
59952: PUSH
59953: EMPTY
59954: LIST
59955: LIST
59956: PPUSH
59957: CALL_OW 72
59961: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59962: LD_ADDR_VAR 0 6
59966: PUSH
59967: LD_EXP 68
59971: PUSH
59972: LD_VAR 0 2
59976: ARRAY
59977: PPUSH
59978: LD_INT 21
59980: PUSH
59981: LD_INT 1
59983: PUSH
59984: EMPTY
59985: LIST
59986: LIST
59987: PUSH
59988: LD_INT 1
59990: PUSH
59991: LD_INT 3
59993: PUSH
59994: LD_INT 54
59996: PUSH
59997: EMPTY
59998: LIST
59999: PUSH
60000: EMPTY
60001: LIST
60002: LIST
60003: PUSH
60004: LD_INT 3
60006: PUSH
60007: LD_INT 24
60009: PUSH
60010: LD_INT 250
60012: PUSH
60013: EMPTY
60014: LIST
60015: LIST
60016: PUSH
60017: EMPTY
60018: LIST
60019: LIST
60020: PUSH
60021: EMPTY
60022: LIST
60023: LIST
60024: LIST
60025: PUSH
60026: EMPTY
60027: LIST
60028: LIST
60029: PPUSH
60030: CALL_OW 72
60034: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
60035: LD_ADDR_VAR 0 7
60039: PUSH
60040: LD_VAR 0 5
60044: PUSH
60045: LD_VAR 0 6
60049: DIFF
60050: ST_TO_ADDR
// if not need_heal_1 then
60051: LD_VAR 0 6
60055: NOT
60056: IFFALSE 60089
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
60058: LD_ADDR_EXP 71
60062: PUSH
60063: LD_EXP 71
60067: PPUSH
60068: LD_VAR 0 2
60072: PUSH
60073: LD_INT 1
60075: PUSH
60076: EMPTY
60077: LIST
60078: LIST
60079: PPUSH
60080: EMPTY
60081: PPUSH
60082: CALL 18548 0 3
60086: ST_TO_ADDR
60087: GO 60159
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
60089: LD_ADDR_EXP 71
60093: PUSH
60094: LD_EXP 71
60098: PPUSH
60099: LD_VAR 0 2
60103: PUSH
60104: LD_INT 1
60106: PUSH
60107: EMPTY
60108: LIST
60109: LIST
60110: PPUSH
60111: LD_EXP 71
60115: PUSH
60116: LD_VAR 0 2
60120: ARRAY
60121: PUSH
60122: LD_INT 1
60124: ARRAY
60125: PPUSH
60126: LD_INT 3
60128: PUSH
60129: LD_INT 24
60131: PUSH
60132: LD_INT 1000
60134: PUSH
60135: EMPTY
60136: LIST
60137: LIST
60138: PUSH
60139: EMPTY
60140: LIST
60141: LIST
60142: PPUSH
60143: CALL_OW 72
60147: PUSH
60148: LD_VAR 0 6
60152: UNION
60153: PPUSH
60154: CALL 18548 0 3
60158: ST_TO_ADDR
// if not need_heal_2 then
60159: LD_VAR 0 7
60163: NOT
60164: IFFALSE 60197
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
60166: LD_ADDR_EXP 71
60170: PUSH
60171: LD_EXP 71
60175: PPUSH
60176: LD_VAR 0 2
60180: PUSH
60181: LD_INT 2
60183: PUSH
60184: EMPTY
60185: LIST
60186: LIST
60187: PPUSH
60188: EMPTY
60189: PPUSH
60190: CALL 18548 0 3
60194: ST_TO_ADDR
60195: GO 60229
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
60197: LD_ADDR_EXP 71
60201: PUSH
60202: LD_EXP 71
60206: PPUSH
60207: LD_VAR 0 2
60211: PUSH
60212: LD_INT 2
60214: PUSH
60215: EMPTY
60216: LIST
60217: LIST
60218: PPUSH
60219: LD_VAR 0 7
60223: PPUSH
60224: CALL 18548 0 3
60228: ST_TO_ADDR
// if need_heal_2 then
60229: LD_VAR 0 7
60233: IFFALSE 60394
// for j in need_heal_2 do
60235: LD_ADDR_VAR 0 3
60239: PUSH
60240: LD_VAR 0 7
60244: PUSH
60245: FOR_IN
60246: IFFALSE 60392
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60248: LD_ADDR_VAR 0 5
60252: PUSH
60253: LD_EXP 68
60257: PUSH
60258: LD_VAR 0 2
60262: ARRAY
60263: PPUSH
60264: LD_INT 2
60266: PUSH
60267: LD_INT 30
60269: PUSH
60270: LD_INT 6
60272: PUSH
60273: EMPTY
60274: LIST
60275: LIST
60276: PUSH
60277: LD_INT 30
60279: PUSH
60280: LD_INT 7
60282: PUSH
60283: EMPTY
60284: LIST
60285: LIST
60286: PUSH
60287: LD_INT 30
60289: PUSH
60290: LD_INT 8
60292: PUSH
60293: EMPTY
60294: LIST
60295: LIST
60296: PUSH
60297: LD_INT 30
60299: PUSH
60300: LD_INT 0
60302: PUSH
60303: EMPTY
60304: LIST
60305: LIST
60306: PUSH
60307: LD_INT 30
60309: PUSH
60310: LD_INT 1
60312: PUSH
60313: EMPTY
60314: LIST
60315: LIST
60316: PUSH
60317: EMPTY
60318: LIST
60319: LIST
60320: LIST
60321: LIST
60322: LIST
60323: LIST
60324: PPUSH
60325: CALL_OW 72
60329: ST_TO_ADDR
// if tmp then
60330: LD_VAR 0 5
60334: IFFALSE 60390
// begin k := NearestUnitToUnit ( tmp , j ) ;
60336: LD_ADDR_VAR 0 4
60340: PUSH
60341: LD_VAR 0 5
60345: PPUSH
60346: LD_VAR 0 3
60350: PPUSH
60351: CALL_OW 74
60355: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60356: LD_VAR 0 3
60360: PPUSH
60361: LD_VAR 0 4
60365: PPUSH
60366: CALL_OW 296
60370: PUSH
60371: LD_INT 5
60373: GREATER
60374: IFFALSE 60390
// ComMoveToNearbyEntrance ( j , k ) ;
60376: LD_VAR 0 3
60380: PPUSH
60381: LD_VAR 0 4
60385: PPUSH
60386: CALL 50791 0 2
// end ; end ;
60390: GO 60245
60392: POP
60393: POP
// if not need_heal_1 and not need_heal_2 then
60394: LD_VAR 0 6
60398: NOT
60399: PUSH
60400: LD_VAR 0 7
60404: NOT
60405: AND
60406: IFFALSE 60410
// continue ;
60408: GO 59874
// end ;
60410: GO 59874
60412: POP
60413: POP
// RaiseSailEvent ( 102 ) ;
60414: LD_INT 102
60416: PPUSH
60417: CALL_OW 427
// end ;
60421: LD_VAR 0 1
60425: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60426: LD_INT 0
60428: PPUSH
60429: PPUSH
60430: PPUSH
60431: PPUSH
60432: PPUSH
60433: PPUSH
60434: PPUSH
60435: PPUSH
// if not mc_bases then
60436: LD_EXP 68
60440: NOT
60441: IFFALSE 60445
// exit ;
60443: GO 61306
// for i = 1 to mc_bases do
60445: LD_ADDR_VAR 0 2
60449: PUSH
60450: DOUBLE
60451: LD_INT 1
60453: DEC
60454: ST_TO_ADDR
60455: LD_EXP 68
60459: PUSH
60460: FOR_TO
60461: IFFALSE 61304
// begin if not mc_building_need_repair [ i ] then
60463: LD_EXP 69
60467: PUSH
60468: LD_VAR 0 2
60472: ARRAY
60473: NOT
60474: IFFALSE 60661
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
60476: LD_ADDR_VAR 0 6
60480: PUSH
60481: LD_EXP 87
60485: PUSH
60486: LD_VAR 0 2
60490: ARRAY
60491: PPUSH
60492: LD_INT 3
60494: PUSH
60495: LD_INT 24
60497: PUSH
60498: LD_INT 1000
60500: PUSH
60501: EMPTY
60502: LIST
60503: LIST
60504: PUSH
60505: EMPTY
60506: LIST
60507: LIST
60508: PUSH
60509: LD_INT 2
60511: PUSH
60512: LD_INT 34
60514: PUSH
60515: LD_INT 13
60517: PUSH
60518: EMPTY
60519: LIST
60520: LIST
60521: PUSH
60522: LD_INT 34
60524: PUSH
60525: LD_INT 52
60527: PUSH
60528: EMPTY
60529: LIST
60530: LIST
60531: PUSH
60532: LD_INT 34
60534: PUSH
60535: LD_EXP 54
60539: PUSH
60540: EMPTY
60541: LIST
60542: LIST
60543: PUSH
60544: EMPTY
60545: LIST
60546: LIST
60547: LIST
60548: LIST
60549: PUSH
60550: EMPTY
60551: LIST
60552: LIST
60553: PPUSH
60554: CALL_OW 72
60558: ST_TO_ADDR
// if cranes then
60559: LD_VAR 0 6
60563: IFFALSE 60625
// for j in cranes do
60565: LD_ADDR_VAR 0 3
60569: PUSH
60570: LD_VAR 0 6
60574: PUSH
60575: FOR_IN
60576: IFFALSE 60623
// if not IsInArea ( j , mc_parking [ i ] ) then
60578: LD_VAR 0 3
60582: PPUSH
60583: LD_EXP 92
60587: PUSH
60588: LD_VAR 0 2
60592: ARRAY
60593: PPUSH
60594: CALL_OW 308
60598: NOT
60599: IFFALSE 60621
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60601: LD_VAR 0 3
60605: PPUSH
60606: LD_EXP 92
60610: PUSH
60611: LD_VAR 0 2
60615: ARRAY
60616: PPUSH
60617: CALL_OW 113
60621: GO 60575
60623: POP
60624: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60625: LD_ADDR_EXP 70
60629: PUSH
60630: LD_EXP 70
60634: PPUSH
60635: LD_VAR 0 2
60639: PPUSH
60640: EMPTY
60641: PPUSH
60642: CALL_OW 1
60646: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
60647: LD_VAR 0 2
60651: PPUSH
60652: LD_INT 101
60654: PPUSH
60655: CALL 55549 0 2
// continue ;
60659: GO 60460
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60661: LD_ADDR_EXP 74
60665: PUSH
60666: LD_EXP 74
60670: PPUSH
60671: LD_VAR 0 2
60675: PPUSH
60676: EMPTY
60677: PPUSH
60678: CALL_OW 1
60682: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60683: LD_VAR 0 2
60687: PPUSH
60688: LD_INT 103
60690: PPUSH
60691: CALL 55549 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60695: LD_ADDR_VAR 0 5
60699: PUSH
60700: LD_EXP 68
60704: PUSH
60705: LD_VAR 0 2
60709: ARRAY
60710: PUSH
60711: LD_EXP 97
60715: PUSH
60716: LD_VAR 0 2
60720: ARRAY
60721: UNION
60722: PPUSH
60723: LD_INT 2
60725: PUSH
60726: LD_INT 25
60728: PUSH
60729: LD_INT 2
60731: PUSH
60732: EMPTY
60733: LIST
60734: LIST
60735: PUSH
60736: LD_INT 25
60738: PUSH
60739: LD_INT 16
60741: PUSH
60742: EMPTY
60743: LIST
60744: LIST
60745: PUSH
60746: EMPTY
60747: LIST
60748: LIST
60749: LIST
60750: PUSH
60751: EMPTY
60752: LIST
60753: PPUSH
60754: CALL_OW 72
60758: PUSH
60759: LD_EXP 71
60763: PUSH
60764: LD_VAR 0 2
60768: ARRAY
60769: PUSH
60770: LD_INT 1
60772: ARRAY
60773: PUSH
60774: LD_EXP 71
60778: PUSH
60779: LD_VAR 0 2
60783: ARRAY
60784: PUSH
60785: LD_INT 2
60787: ARRAY
60788: UNION
60789: DIFF
60790: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60791: LD_ADDR_VAR 0 6
60795: PUSH
60796: LD_EXP 87
60800: PUSH
60801: LD_VAR 0 2
60805: ARRAY
60806: PPUSH
60807: LD_INT 2
60809: PUSH
60810: LD_INT 34
60812: PUSH
60813: LD_INT 13
60815: PUSH
60816: EMPTY
60817: LIST
60818: LIST
60819: PUSH
60820: LD_INT 34
60822: PUSH
60823: LD_INT 52
60825: PUSH
60826: EMPTY
60827: LIST
60828: LIST
60829: PUSH
60830: LD_INT 34
60832: PUSH
60833: LD_EXP 54
60837: PUSH
60838: EMPTY
60839: LIST
60840: LIST
60841: PUSH
60842: EMPTY
60843: LIST
60844: LIST
60845: LIST
60846: LIST
60847: PPUSH
60848: CALL_OW 72
60852: ST_TO_ADDR
// if cranes then
60853: LD_VAR 0 6
60857: IFFALSE 60993
// begin for j in cranes do
60859: LD_ADDR_VAR 0 3
60863: PUSH
60864: LD_VAR 0 6
60868: PUSH
60869: FOR_IN
60870: IFFALSE 60991
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60872: LD_VAR 0 3
60876: PPUSH
60877: CALL_OW 256
60881: PUSH
60882: LD_INT 1000
60884: EQUAL
60885: PUSH
60886: LD_VAR 0 3
60890: PPUSH
60891: CALL_OW 314
60895: NOT
60896: AND
60897: IFFALSE 60931
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
60899: LD_VAR 0 3
60903: PPUSH
60904: LD_EXP 69
60908: PUSH
60909: LD_VAR 0 2
60913: ARRAY
60914: PPUSH
60915: LD_VAR 0 3
60919: PPUSH
60920: CALL_OW 74
60924: PPUSH
60925: CALL_OW 130
60929: GO 60989
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60931: LD_VAR 0 3
60935: PPUSH
60936: CALL_OW 256
60940: PUSH
60941: LD_INT 500
60943: LESS
60944: PUSH
60945: LD_VAR 0 3
60949: PPUSH
60950: LD_EXP 92
60954: PUSH
60955: LD_VAR 0 2
60959: ARRAY
60960: PPUSH
60961: CALL_OW 308
60965: NOT
60966: AND
60967: IFFALSE 60989
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60969: LD_VAR 0 3
60973: PPUSH
60974: LD_EXP 92
60978: PUSH
60979: LD_VAR 0 2
60983: ARRAY
60984: PPUSH
60985: CALL_OW 113
// end ;
60989: GO 60869
60991: POP
60992: POP
// end ; if tmp > 3 then
60993: LD_VAR 0 5
60997: PUSH
60998: LD_INT 3
61000: GREATER
61001: IFFALSE 61021
// tmp := ShrinkArray ( tmp , 4 ) ;
61003: LD_ADDR_VAR 0 5
61007: PUSH
61008: LD_VAR 0 5
61012: PPUSH
61013: LD_INT 4
61015: PPUSH
61016: CALL 50239 0 2
61020: ST_TO_ADDR
// if not tmp then
61021: LD_VAR 0 5
61025: NOT
61026: IFFALSE 61030
// continue ;
61028: GO 60460
// for j in tmp do
61030: LD_ADDR_VAR 0 3
61034: PUSH
61035: LD_VAR 0 5
61039: PUSH
61040: FOR_IN
61041: IFFALSE 61300
// begin if IsInUnit ( j ) then
61043: LD_VAR 0 3
61047: PPUSH
61048: CALL_OW 310
61052: IFFALSE 61063
// ComExitBuilding ( j ) ;
61054: LD_VAR 0 3
61058: PPUSH
61059: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
61063: LD_VAR 0 3
61067: PUSH
61068: LD_EXP 70
61072: PUSH
61073: LD_VAR 0 2
61077: ARRAY
61078: IN
61079: NOT
61080: IFFALSE 61138
// begin SetTag ( j , 101 ) ;
61082: LD_VAR 0 3
61086: PPUSH
61087: LD_INT 101
61089: PPUSH
61090: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
61094: LD_ADDR_EXP 70
61098: PUSH
61099: LD_EXP 70
61103: PPUSH
61104: LD_VAR 0 2
61108: PUSH
61109: LD_EXP 70
61113: PUSH
61114: LD_VAR 0 2
61118: ARRAY
61119: PUSH
61120: LD_INT 1
61122: PLUS
61123: PUSH
61124: EMPTY
61125: LIST
61126: LIST
61127: PPUSH
61128: LD_VAR 0 3
61132: PPUSH
61133: CALL 18548 0 3
61137: ST_TO_ADDR
// end ; wait ( 1 ) ;
61138: LD_INT 1
61140: PPUSH
61141: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
61145: LD_ADDR_VAR 0 7
61149: PUSH
61150: LD_EXP 69
61154: PUSH
61155: LD_VAR 0 2
61159: ARRAY
61160: ST_TO_ADDR
// if mc_scan [ i ] then
61161: LD_EXP 91
61165: PUSH
61166: LD_VAR 0 2
61170: ARRAY
61171: IFFALSE 61233
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
61173: LD_ADDR_VAR 0 7
61177: PUSH
61178: LD_EXP 69
61182: PUSH
61183: LD_VAR 0 2
61187: ARRAY
61188: PPUSH
61189: LD_INT 3
61191: PUSH
61192: LD_INT 30
61194: PUSH
61195: LD_INT 32
61197: PUSH
61198: EMPTY
61199: LIST
61200: LIST
61201: PUSH
61202: LD_INT 30
61204: PUSH
61205: LD_INT 33
61207: PUSH
61208: EMPTY
61209: LIST
61210: LIST
61211: PUSH
61212: LD_INT 30
61214: PUSH
61215: LD_INT 31
61217: PUSH
61218: EMPTY
61219: LIST
61220: LIST
61221: PUSH
61222: EMPTY
61223: LIST
61224: LIST
61225: LIST
61226: LIST
61227: PPUSH
61228: CALL_OW 72
61232: ST_TO_ADDR
// if not to_repair_tmp then
61233: LD_VAR 0 7
61237: NOT
61238: IFFALSE 61242
// continue ;
61240: GO 61040
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
61242: LD_ADDR_VAR 0 8
61246: PUSH
61247: LD_VAR 0 7
61251: PPUSH
61252: LD_VAR 0 3
61256: PPUSH
61257: CALL_OW 74
61261: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
61262: LD_VAR 0 8
61266: PPUSH
61267: LD_INT 16
61269: PPUSH
61270: CALL 21141 0 2
61274: PUSH
61275: LD_INT 4
61277: ARRAY
61278: PUSH
61279: LD_INT 10
61281: LESS
61282: IFFALSE 61298
// ComRepairBuilding ( j , to_repair ) ;
61284: LD_VAR 0 3
61288: PPUSH
61289: LD_VAR 0 8
61293: PPUSH
61294: CALL_OW 130
// end ;
61298: GO 61040
61300: POP
61301: POP
// end ;
61302: GO 60460
61304: POP
61305: POP
// end ;
61306: LD_VAR 0 1
61310: RET
// export function MC_Heal ; var i , j , tmp ; begin
61311: LD_INT 0
61313: PPUSH
61314: PPUSH
61315: PPUSH
61316: PPUSH
// if not mc_bases then
61317: LD_EXP 68
61321: NOT
61322: IFFALSE 61326
// exit ;
61324: GO 61728
// for i = 1 to mc_bases do
61326: LD_ADDR_VAR 0 2
61330: PUSH
61331: DOUBLE
61332: LD_INT 1
61334: DEC
61335: ST_TO_ADDR
61336: LD_EXP 68
61340: PUSH
61341: FOR_TO
61342: IFFALSE 61726
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61344: LD_EXP 71
61348: PUSH
61349: LD_VAR 0 2
61353: ARRAY
61354: PUSH
61355: LD_INT 1
61357: ARRAY
61358: NOT
61359: PUSH
61360: LD_EXP 71
61364: PUSH
61365: LD_VAR 0 2
61369: ARRAY
61370: PUSH
61371: LD_INT 2
61373: ARRAY
61374: NOT
61375: AND
61376: IFFALSE 61414
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61378: LD_ADDR_EXP 72
61382: PUSH
61383: LD_EXP 72
61387: PPUSH
61388: LD_VAR 0 2
61392: PPUSH
61393: EMPTY
61394: PPUSH
61395: CALL_OW 1
61399: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61400: LD_VAR 0 2
61404: PPUSH
61405: LD_INT 102
61407: PPUSH
61408: CALL 55549 0 2
// continue ;
61412: GO 61341
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61414: LD_ADDR_VAR 0 4
61418: PUSH
61419: LD_EXP 68
61423: PUSH
61424: LD_VAR 0 2
61428: ARRAY
61429: PPUSH
61430: LD_INT 25
61432: PUSH
61433: LD_INT 4
61435: PUSH
61436: EMPTY
61437: LIST
61438: LIST
61439: PPUSH
61440: CALL_OW 72
61444: ST_TO_ADDR
// if not tmp then
61445: LD_VAR 0 4
61449: NOT
61450: IFFALSE 61454
// continue ;
61452: GO 61341
// if mc_taming [ i ] then
61454: LD_EXP 99
61458: PUSH
61459: LD_VAR 0 2
61463: ARRAY
61464: IFFALSE 61488
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61466: LD_ADDR_EXP 99
61470: PUSH
61471: LD_EXP 99
61475: PPUSH
61476: LD_VAR 0 2
61480: PPUSH
61481: EMPTY
61482: PPUSH
61483: CALL_OW 1
61487: ST_TO_ADDR
// for j in tmp do
61488: LD_ADDR_VAR 0 3
61492: PUSH
61493: LD_VAR 0 4
61497: PUSH
61498: FOR_IN
61499: IFFALSE 61722
// begin if IsInUnit ( j ) then
61501: LD_VAR 0 3
61505: PPUSH
61506: CALL_OW 310
61510: IFFALSE 61521
// ComExitBuilding ( j ) ;
61512: LD_VAR 0 3
61516: PPUSH
61517: CALL_OW 122
// if not j in mc_healers [ i ] then
61521: LD_VAR 0 3
61525: PUSH
61526: LD_EXP 72
61530: PUSH
61531: LD_VAR 0 2
61535: ARRAY
61536: IN
61537: NOT
61538: IFFALSE 61584
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61540: LD_ADDR_EXP 72
61544: PUSH
61545: LD_EXP 72
61549: PPUSH
61550: LD_VAR 0 2
61554: PUSH
61555: LD_EXP 72
61559: PUSH
61560: LD_VAR 0 2
61564: ARRAY
61565: PUSH
61566: LD_INT 1
61568: PLUS
61569: PUSH
61570: EMPTY
61571: LIST
61572: LIST
61573: PPUSH
61574: LD_VAR 0 3
61578: PPUSH
61579: CALL 18548 0 3
61583: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
61584: LD_VAR 0 3
61588: PPUSH
61589: CALL_OW 110
61593: PUSH
61594: LD_INT 102
61596: NONEQUAL
61597: IFFALSE 61611
// SetTag ( j , 102 ) ;
61599: LD_VAR 0 3
61603: PPUSH
61604: LD_INT 102
61606: PPUSH
61607: CALL_OW 109
// Wait ( 3 ) ;
61611: LD_INT 3
61613: PPUSH
61614: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
61618: LD_EXP 71
61622: PUSH
61623: LD_VAR 0 2
61627: ARRAY
61628: PUSH
61629: LD_INT 1
61631: ARRAY
61632: IFFALSE 61664
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
61634: LD_VAR 0 3
61638: PPUSH
61639: LD_EXP 71
61643: PUSH
61644: LD_VAR 0 2
61648: ARRAY
61649: PUSH
61650: LD_INT 1
61652: ARRAY
61653: PUSH
61654: LD_INT 1
61656: ARRAY
61657: PPUSH
61658: CALL_OW 128
61662: GO 61720
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61664: LD_VAR 0 3
61668: PPUSH
61669: CALL_OW 314
61673: NOT
61674: PUSH
61675: LD_EXP 71
61679: PUSH
61680: LD_VAR 0 2
61684: ARRAY
61685: PUSH
61686: LD_INT 2
61688: ARRAY
61689: AND
61690: IFFALSE 61720
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61692: LD_VAR 0 3
61696: PPUSH
61697: LD_EXP 71
61701: PUSH
61702: LD_VAR 0 2
61706: ARRAY
61707: PUSH
61708: LD_INT 2
61710: ARRAY
61711: PUSH
61712: LD_INT 1
61714: ARRAY
61715: PPUSH
61716: CALL_OW 128
// end ;
61720: GO 61498
61722: POP
61723: POP
// end ;
61724: GO 61341
61726: POP
61727: POP
// end ;
61728: LD_VAR 0 1
61732: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
61733: LD_INT 0
61735: PPUSH
61736: PPUSH
61737: PPUSH
61738: PPUSH
61739: PPUSH
// if not mc_bases then
61740: LD_EXP 68
61744: NOT
61745: IFFALSE 61749
// exit ;
61747: GO 62920
// for i = 1 to mc_bases do
61749: LD_ADDR_VAR 0 2
61753: PUSH
61754: DOUBLE
61755: LD_INT 1
61757: DEC
61758: ST_TO_ADDR
61759: LD_EXP 68
61763: PUSH
61764: FOR_TO
61765: IFFALSE 62918
// begin if mc_scan [ i ] then
61767: LD_EXP 91
61771: PUSH
61772: LD_VAR 0 2
61776: ARRAY
61777: IFFALSE 61781
// continue ;
61779: GO 61764
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61781: LD_EXP 73
61785: PUSH
61786: LD_VAR 0 2
61790: ARRAY
61791: NOT
61792: PUSH
61793: LD_EXP 75
61797: PUSH
61798: LD_VAR 0 2
61802: ARRAY
61803: NOT
61804: AND
61805: PUSH
61806: LD_EXP 74
61810: PUSH
61811: LD_VAR 0 2
61815: ARRAY
61816: AND
61817: IFFALSE 61855
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61819: LD_ADDR_EXP 74
61823: PUSH
61824: LD_EXP 74
61828: PPUSH
61829: LD_VAR 0 2
61833: PPUSH
61834: EMPTY
61835: PPUSH
61836: CALL_OW 1
61840: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61841: LD_VAR 0 2
61845: PPUSH
61846: LD_INT 103
61848: PPUSH
61849: CALL 55549 0 2
// continue ;
61853: GO 61764
// end ; if mc_construct_list [ i ] then
61855: LD_EXP 75
61859: PUSH
61860: LD_VAR 0 2
61864: ARRAY
61865: IFFALSE 62085
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61867: LD_ADDR_VAR 0 4
61871: PUSH
61872: LD_EXP 68
61876: PUSH
61877: LD_VAR 0 2
61881: ARRAY
61882: PPUSH
61883: LD_INT 25
61885: PUSH
61886: LD_INT 2
61888: PUSH
61889: EMPTY
61890: LIST
61891: LIST
61892: PPUSH
61893: CALL_OW 72
61897: PUSH
61898: LD_EXP 70
61902: PUSH
61903: LD_VAR 0 2
61907: ARRAY
61908: DIFF
61909: ST_TO_ADDR
// if not tmp then
61910: LD_VAR 0 4
61914: NOT
61915: IFFALSE 61919
// continue ;
61917: GO 61764
// for j in tmp do
61919: LD_ADDR_VAR 0 3
61923: PUSH
61924: LD_VAR 0 4
61928: PUSH
61929: FOR_IN
61930: IFFALSE 62081
// begin if not mc_builders [ i ] then
61932: LD_EXP 74
61936: PUSH
61937: LD_VAR 0 2
61941: ARRAY
61942: NOT
61943: IFFALSE 62001
// begin SetTag ( j , 103 ) ;
61945: LD_VAR 0 3
61949: PPUSH
61950: LD_INT 103
61952: PPUSH
61953: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61957: LD_ADDR_EXP 74
61961: PUSH
61962: LD_EXP 74
61966: PPUSH
61967: LD_VAR 0 2
61971: PUSH
61972: LD_EXP 74
61976: PUSH
61977: LD_VAR 0 2
61981: ARRAY
61982: PUSH
61983: LD_INT 1
61985: PLUS
61986: PUSH
61987: EMPTY
61988: LIST
61989: LIST
61990: PPUSH
61991: LD_VAR 0 3
61995: PPUSH
61996: CALL 18548 0 3
62000: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62001: LD_VAR 0 3
62005: PPUSH
62006: CALL_OW 310
62010: IFFALSE 62021
// ComExitBuilding ( j ) ;
62012: LD_VAR 0 3
62016: PPUSH
62017: CALL_OW 122
// wait ( 3 ) ;
62021: LD_INT 3
62023: PPUSH
62024: CALL_OW 67
// if not mc_construct_list [ i ] then
62028: LD_EXP 75
62032: PUSH
62033: LD_VAR 0 2
62037: ARRAY
62038: NOT
62039: IFFALSE 62043
// break ;
62041: GO 62081
// if not HasTask ( j ) then
62043: LD_VAR 0 3
62047: PPUSH
62048: CALL_OW 314
62052: NOT
62053: IFFALSE 62079
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
62055: LD_VAR 0 3
62059: PPUSH
62060: LD_EXP 75
62064: PUSH
62065: LD_VAR 0 2
62069: ARRAY
62070: PUSH
62071: LD_INT 1
62073: ARRAY
62074: PPUSH
62075: CALL 21405 0 2
// end ;
62079: GO 61929
62081: POP
62082: POP
// end else
62083: GO 62916
// if mc_build_list [ i ] then
62085: LD_EXP 73
62089: PUSH
62090: LD_VAR 0 2
62094: ARRAY
62095: IFFALSE 62916
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62097: LD_ADDR_VAR 0 5
62101: PUSH
62102: LD_EXP 68
62106: PUSH
62107: LD_VAR 0 2
62111: ARRAY
62112: PPUSH
62113: LD_INT 2
62115: PUSH
62116: LD_INT 30
62118: PUSH
62119: LD_INT 0
62121: PUSH
62122: EMPTY
62123: LIST
62124: LIST
62125: PUSH
62126: LD_INT 30
62128: PUSH
62129: LD_INT 1
62131: PUSH
62132: EMPTY
62133: LIST
62134: LIST
62135: PUSH
62136: EMPTY
62137: LIST
62138: LIST
62139: LIST
62140: PPUSH
62141: CALL_OW 72
62145: ST_TO_ADDR
// if depot then
62146: LD_VAR 0 5
62150: IFFALSE 62168
// depot := depot [ 1 ] else
62152: LD_ADDR_VAR 0 5
62156: PUSH
62157: LD_VAR 0 5
62161: PUSH
62162: LD_INT 1
62164: ARRAY
62165: ST_TO_ADDR
62166: GO 62176
// depot := 0 ;
62168: LD_ADDR_VAR 0 5
62172: PUSH
62173: LD_INT 0
62175: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
62176: LD_EXP 73
62180: PUSH
62181: LD_VAR 0 2
62185: ARRAY
62186: PUSH
62187: LD_INT 1
62189: ARRAY
62190: PUSH
62191: LD_INT 1
62193: ARRAY
62194: PPUSH
62195: CALL 21229 0 1
62199: PUSH
62200: LD_EXP 68
62204: PUSH
62205: LD_VAR 0 2
62209: ARRAY
62210: PPUSH
62211: LD_INT 2
62213: PUSH
62214: LD_INT 30
62216: PUSH
62217: LD_INT 2
62219: PUSH
62220: EMPTY
62221: LIST
62222: LIST
62223: PUSH
62224: LD_INT 30
62226: PUSH
62227: LD_INT 3
62229: PUSH
62230: EMPTY
62231: LIST
62232: LIST
62233: PUSH
62234: EMPTY
62235: LIST
62236: LIST
62237: LIST
62238: PPUSH
62239: CALL_OW 72
62243: NOT
62244: AND
62245: IFFALSE 62350
// begin for j = 1 to mc_build_list [ i ] do
62247: LD_ADDR_VAR 0 3
62251: PUSH
62252: DOUBLE
62253: LD_INT 1
62255: DEC
62256: ST_TO_ADDR
62257: LD_EXP 73
62261: PUSH
62262: LD_VAR 0 2
62266: ARRAY
62267: PUSH
62268: FOR_TO
62269: IFFALSE 62348
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
62271: LD_EXP 73
62275: PUSH
62276: LD_VAR 0 2
62280: ARRAY
62281: PUSH
62282: LD_VAR 0 3
62286: ARRAY
62287: PUSH
62288: LD_INT 1
62290: ARRAY
62291: PUSH
62292: LD_INT 2
62294: EQUAL
62295: IFFALSE 62346
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62297: LD_ADDR_EXP 73
62301: PUSH
62302: LD_EXP 73
62306: PPUSH
62307: LD_VAR 0 2
62311: PPUSH
62312: LD_EXP 73
62316: PUSH
62317: LD_VAR 0 2
62321: ARRAY
62322: PPUSH
62323: LD_VAR 0 3
62327: PPUSH
62328: LD_INT 1
62330: PPUSH
62331: LD_INT 0
62333: PPUSH
62334: CALL 17966 0 4
62338: PPUSH
62339: CALL_OW 1
62343: ST_TO_ADDR
// break ;
62344: GO 62348
// end ;
62346: GO 62268
62348: POP
62349: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
62350: LD_EXP 73
62354: PUSH
62355: LD_VAR 0 2
62359: ARRAY
62360: PUSH
62361: LD_INT 1
62363: ARRAY
62364: PUSH
62365: LD_INT 1
62367: ARRAY
62368: PUSH
62369: LD_INT 0
62371: EQUAL
62372: PUSH
62373: LD_VAR 0 5
62377: PUSH
62378: LD_VAR 0 5
62382: PPUSH
62383: LD_EXP 73
62387: PUSH
62388: LD_VAR 0 2
62392: ARRAY
62393: PUSH
62394: LD_INT 1
62396: ARRAY
62397: PUSH
62398: LD_INT 1
62400: ARRAY
62401: PPUSH
62402: LD_EXP 73
62406: PUSH
62407: LD_VAR 0 2
62411: ARRAY
62412: PUSH
62413: LD_INT 1
62415: ARRAY
62416: PUSH
62417: LD_INT 2
62419: ARRAY
62420: PPUSH
62421: LD_EXP 73
62425: PUSH
62426: LD_VAR 0 2
62430: ARRAY
62431: PUSH
62432: LD_INT 1
62434: ARRAY
62435: PUSH
62436: LD_INT 3
62438: ARRAY
62439: PPUSH
62440: LD_EXP 73
62444: PUSH
62445: LD_VAR 0 2
62449: ARRAY
62450: PUSH
62451: LD_INT 1
62453: ARRAY
62454: PUSH
62455: LD_INT 4
62457: ARRAY
62458: PPUSH
62459: CALL 26296 0 5
62463: AND
62464: OR
62465: IFFALSE 62746
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62467: LD_ADDR_VAR 0 4
62471: PUSH
62472: LD_EXP 68
62476: PUSH
62477: LD_VAR 0 2
62481: ARRAY
62482: PPUSH
62483: LD_INT 25
62485: PUSH
62486: LD_INT 2
62488: PUSH
62489: EMPTY
62490: LIST
62491: LIST
62492: PPUSH
62493: CALL_OW 72
62497: PUSH
62498: LD_EXP 70
62502: PUSH
62503: LD_VAR 0 2
62507: ARRAY
62508: DIFF
62509: ST_TO_ADDR
// if not tmp then
62510: LD_VAR 0 4
62514: NOT
62515: IFFALSE 62519
// continue ;
62517: GO 61764
// for j in tmp do
62519: LD_ADDR_VAR 0 3
62523: PUSH
62524: LD_VAR 0 4
62528: PUSH
62529: FOR_IN
62530: IFFALSE 62742
// begin if not mc_builders [ i ] then
62532: LD_EXP 74
62536: PUSH
62537: LD_VAR 0 2
62541: ARRAY
62542: NOT
62543: IFFALSE 62601
// begin SetTag ( j , 103 ) ;
62545: LD_VAR 0 3
62549: PPUSH
62550: LD_INT 103
62552: PPUSH
62553: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62557: LD_ADDR_EXP 74
62561: PUSH
62562: LD_EXP 74
62566: PPUSH
62567: LD_VAR 0 2
62571: PUSH
62572: LD_EXP 74
62576: PUSH
62577: LD_VAR 0 2
62581: ARRAY
62582: PUSH
62583: LD_INT 1
62585: PLUS
62586: PUSH
62587: EMPTY
62588: LIST
62589: LIST
62590: PPUSH
62591: LD_VAR 0 3
62595: PPUSH
62596: CALL 18548 0 3
62600: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62601: LD_VAR 0 3
62605: PPUSH
62606: CALL_OW 310
62610: IFFALSE 62621
// ComExitBuilding ( j ) ;
62612: LD_VAR 0 3
62616: PPUSH
62617: CALL_OW 122
// wait ( 3 ) ;
62621: LD_INT 3
62623: PPUSH
62624: CALL_OW 67
// if not mc_build_list [ i ] then
62628: LD_EXP 73
62632: PUSH
62633: LD_VAR 0 2
62637: ARRAY
62638: NOT
62639: IFFALSE 62643
// break ;
62641: GO 62742
// if not HasTask ( j ) then
62643: LD_VAR 0 3
62647: PPUSH
62648: CALL_OW 314
62652: NOT
62653: IFFALSE 62740
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
62655: LD_VAR 0 3
62659: PPUSH
62660: LD_EXP 73
62664: PUSH
62665: LD_VAR 0 2
62669: ARRAY
62670: PUSH
62671: LD_INT 1
62673: ARRAY
62674: PUSH
62675: LD_INT 1
62677: ARRAY
62678: PPUSH
62679: LD_EXP 73
62683: PUSH
62684: LD_VAR 0 2
62688: ARRAY
62689: PUSH
62690: LD_INT 1
62692: ARRAY
62693: PUSH
62694: LD_INT 2
62696: ARRAY
62697: PPUSH
62698: LD_EXP 73
62702: PUSH
62703: LD_VAR 0 2
62707: ARRAY
62708: PUSH
62709: LD_INT 1
62711: ARRAY
62712: PUSH
62713: LD_INT 3
62715: ARRAY
62716: PPUSH
62717: LD_EXP 73
62721: PUSH
62722: LD_VAR 0 2
62726: ARRAY
62727: PUSH
62728: LD_INT 1
62730: ARRAY
62731: PUSH
62732: LD_INT 4
62734: ARRAY
62735: PPUSH
62736: CALL_OW 145
// end ;
62740: GO 62529
62742: POP
62743: POP
// end else
62744: GO 62916
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
62746: LD_EXP 68
62750: PUSH
62751: LD_VAR 0 2
62755: ARRAY
62756: PPUSH
62757: LD_EXP 73
62761: PUSH
62762: LD_VAR 0 2
62766: ARRAY
62767: PUSH
62768: LD_INT 1
62770: ARRAY
62771: PUSH
62772: LD_INT 1
62774: ARRAY
62775: PPUSH
62776: LD_EXP 73
62780: PUSH
62781: LD_VAR 0 2
62785: ARRAY
62786: PUSH
62787: LD_INT 1
62789: ARRAY
62790: PUSH
62791: LD_INT 2
62793: ARRAY
62794: PPUSH
62795: LD_EXP 73
62799: PUSH
62800: LD_VAR 0 2
62804: ARRAY
62805: PUSH
62806: LD_INT 1
62808: ARRAY
62809: PUSH
62810: LD_INT 3
62812: ARRAY
62813: PPUSH
62814: LD_EXP 73
62818: PUSH
62819: LD_VAR 0 2
62823: ARRAY
62824: PUSH
62825: LD_INT 1
62827: ARRAY
62828: PUSH
62829: LD_INT 4
62831: ARRAY
62832: PPUSH
62833: LD_EXP 68
62837: PUSH
62838: LD_VAR 0 2
62842: ARRAY
62843: PPUSH
62844: LD_INT 21
62846: PUSH
62847: LD_INT 3
62849: PUSH
62850: EMPTY
62851: LIST
62852: LIST
62853: PPUSH
62854: CALL_OW 72
62858: PPUSH
62859: EMPTY
62860: PPUSH
62861: CALL 25426 0 7
62865: NOT
62866: IFFALSE 62916
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62868: LD_ADDR_EXP 73
62872: PUSH
62873: LD_EXP 73
62877: PPUSH
62878: LD_VAR 0 2
62882: PPUSH
62883: LD_EXP 73
62887: PUSH
62888: LD_VAR 0 2
62892: ARRAY
62893: PPUSH
62894: LD_INT 1
62896: PPUSH
62897: LD_INT 1
62899: NEG
62900: PPUSH
62901: LD_INT 0
62903: PPUSH
62904: CALL 17966 0 4
62908: PPUSH
62909: CALL_OW 1
62913: ST_TO_ADDR
// continue ;
62914: GO 61764
// end ; end ; end ;
62916: GO 61764
62918: POP
62919: POP
// end ;
62920: LD_VAR 0 1
62924: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62925: LD_INT 0
62927: PPUSH
62928: PPUSH
62929: PPUSH
62930: PPUSH
62931: PPUSH
62932: PPUSH
// if not mc_bases then
62933: LD_EXP 68
62937: NOT
62938: IFFALSE 62942
// exit ;
62940: GO 63369
// for i = 1 to mc_bases do
62942: LD_ADDR_VAR 0 2
62946: PUSH
62947: DOUBLE
62948: LD_INT 1
62950: DEC
62951: ST_TO_ADDR
62952: LD_EXP 68
62956: PUSH
62957: FOR_TO
62958: IFFALSE 63367
// begin tmp := mc_build_upgrade [ i ] ;
62960: LD_ADDR_VAR 0 4
62964: PUSH
62965: LD_EXP 100
62969: PUSH
62970: LD_VAR 0 2
62974: ARRAY
62975: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62976: LD_ADDR_VAR 0 6
62980: PUSH
62981: LD_EXP 101
62985: PUSH
62986: LD_VAR 0 2
62990: ARRAY
62991: PPUSH
62992: LD_INT 2
62994: PUSH
62995: LD_INT 30
62997: PUSH
62998: LD_INT 6
63000: PUSH
63001: EMPTY
63002: LIST
63003: LIST
63004: PUSH
63005: LD_INT 30
63007: PUSH
63008: LD_INT 7
63010: PUSH
63011: EMPTY
63012: LIST
63013: LIST
63014: PUSH
63015: EMPTY
63016: LIST
63017: LIST
63018: LIST
63019: PPUSH
63020: CALL_OW 72
63024: ST_TO_ADDR
// if not tmp and not lab then
63025: LD_VAR 0 4
63029: NOT
63030: PUSH
63031: LD_VAR 0 6
63035: NOT
63036: AND
63037: IFFALSE 63041
// continue ;
63039: GO 62957
// if tmp then
63041: LD_VAR 0 4
63045: IFFALSE 63165
// for j in tmp do
63047: LD_ADDR_VAR 0 3
63051: PUSH
63052: LD_VAR 0 4
63056: PUSH
63057: FOR_IN
63058: IFFALSE 63163
// begin if UpgradeCost ( j ) then
63060: LD_VAR 0 3
63064: PPUSH
63065: CALL 25086 0 1
63069: IFFALSE 63161
// begin ComUpgrade ( j ) ;
63071: LD_VAR 0 3
63075: PPUSH
63076: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
63080: LD_ADDR_EXP 100
63084: PUSH
63085: LD_EXP 100
63089: PPUSH
63090: LD_VAR 0 2
63094: PPUSH
63095: LD_EXP 100
63099: PUSH
63100: LD_VAR 0 2
63104: ARRAY
63105: PUSH
63106: LD_VAR 0 3
63110: DIFF
63111: PPUSH
63112: CALL_OW 1
63116: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63117: LD_ADDR_EXP 75
63121: PUSH
63122: LD_EXP 75
63126: PPUSH
63127: LD_VAR 0 2
63131: PUSH
63132: LD_EXP 75
63136: PUSH
63137: LD_VAR 0 2
63141: ARRAY
63142: PUSH
63143: LD_INT 1
63145: PLUS
63146: PUSH
63147: EMPTY
63148: LIST
63149: LIST
63150: PPUSH
63151: LD_VAR 0 3
63155: PPUSH
63156: CALL 18548 0 3
63160: ST_TO_ADDR
// end ; end ;
63161: GO 63057
63163: POP
63164: POP
// if not lab or not mc_lab_upgrade [ i ] then
63165: LD_VAR 0 6
63169: NOT
63170: PUSH
63171: LD_EXP 102
63175: PUSH
63176: LD_VAR 0 2
63180: ARRAY
63181: NOT
63182: OR
63183: IFFALSE 63187
// continue ;
63185: GO 62957
// for j in lab do
63187: LD_ADDR_VAR 0 3
63191: PUSH
63192: LD_VAR 0 6
63196: PUSH
63197: FOR_IN
63198: IFFALSE 63363
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
63200: LD_VAR 0 3
63204: PPUSH
63205: CALL_OW 266
63209: PUSH
63210: LD_INT 6
63212: PUSH
63213: LD_INT 7
63215: PUSH
63216: EMPTY
63217: LIST
63218: LIST
63219: IN
63220: PUSH
63221: LD_VAR 0 3
63225: PPUSH
63226: CALL_OW 461
63230: PUSH
63231: LD_INT 1
63233: NONEQUAL
63234: AND
63235: IFFALSE 63361
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
63237: LD_VAR 0 3
63241: PPUSH
63242: LD_EXP 102
63246: PUSH
63247: LD_VAR 0 2
63251: ARRAY
63252: PUSH
63253: LD_INT 1
63255: ARRAY
63256: PPUSH
63257: CALL 25291 0 2
63261: IFFALSE 63361
// begin ComCancel ( j ) ;
63263: LD_VAR 0 3
63267: PPUSH
63268: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
63272: LD_VAR 0 3
63276: PPUSH
63277: LD_EXP 102
63281: PUSH
63282: LD_VAR 0 2
63286: ARRAY
63287: PUSH
63288: LD_INT 1
63290: ARRAY
63291: PPUSH
63292: CALL_OW 207
// if not j in mc_construct_list [ i ] then
63296: LD_VAR 0 3
63300: PUSH
63301: LD_EXP 75
63305: PUSH
63306: LD_VAR 0 2
63310: ARRAY
63311: IN
63312: NOT
63313: IFFALSE 63359
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63315: LD_ADDR_EXP 75
63319: PUSH
63320: LD_EXP 75
63324: PPUSH
63325: LD_VAR 0 2
63329: PUSH
63330: LD_EXP 75
63334: PUSH
63335: LD_VAR 0 2
63339: ARRAY
63340: PUSH
63341: LD_INT 1
63343: PLUS
63344: PUSH
63345: EMPTY
63346: LIST
63347: LIST
63348: PPUSH
63349: LD_VAR 0 3
63353: PPUSH
63354: CALL 18548 0 3
63358: ST_TO_ADDR
// break ;
63359: GO 63363
// end ; end ; end ;
63361: GO 63197
63363: POP
63364: POP
// end ;
63365: GO 62957
63367: POP
63368: POP
// end ;
63369: LD_VAR 0 1
63373: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63374: LD_INT 0
63376: PPUSH
63377: PPUSH
63378: PPUSH
63379: PPUSH
63380: PPUSH
63381: PPUSH
63382: PPUSH
63383: PPUSH
63384: PPUSH
// if not mc_bases then
63385: LD_EXP 68
63389: NOT
63390: IFFALSE 63394
// exit ;
63392: GO 63799
// for i = 1 to mc_bases do
63394: LD_ADDR_VAR 0 2
63398: PUSH
63399: DOUBLE
63400: LD_INT 1
63402: DEC
63403: ST_TO_ADDR
63404: LD_EXP 68
63408: PUSH
63409: FOR_TO
63410: IFFALSE 63797
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
63412: LD_EXP 76
63416: PUSH
63417: LD_VAR 0 2
63421: ARRAY
63422: NOT
63423: PUSH
63424: LD_EXP 68
63428: PUSH
63429: LD_VAR 0 2
63433: ARRAY
63434: PPUSH
63435: LD_INT 30
63437: PUSH
63438: LD_INT 3
63440: PUSH
63441: EMPTY
63442: LIST
63443: LIST
63444: PPUSH
63445: CALL_OW 72
63449: NOT
63450: OR
63451: IFFALSE 63455
// continue ;
63453: GO 63409
// busy := false ;
63455: LD_ADDR_VAR 0 8
63459: PUSH
63460: LD_INT 0
63462: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63463: LD_ADDR_VAR 0 4
63467: PUSH
63468: LD_EXP 68
63472: PUSH
63473: LD_VAR 0 2
63477: ARRAY
63478: PPUSH
63479: LD_INT 30
63481: PUSH
63482: LD_INT 3
63484: PUSH
63485: EMPTY
63486: LIST
63487: LIST
63488: PPUSH
63489: CALL_OW 72
63493: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63494: LD_ADDR_VAR 0 6
63498: PUSH
63499: LD_EXP 76
63503: PUSH
63504: LD_VAR 0 2
63508: ARRAY
63509: PPUSH
63510: LD_INT 2
63512: PUSH
63513: LD_INT 30
63515: PUSH
63516: LD_INT 32
63518: PUSH
63519: EMPTY
63520: LIST
63521: LIST
63522: PUSH
63523: LD_INT 30
63525: PUSH
63526: LD_INT 33
63528: PUSH
63529: EMPTY
63530: LIST
63531: LIST
63532: PUSH
63533: EMPTY
63534: LIST
63535: LIST
63536: LIST
63537: PPUSH
63538: CALL_OW 72
63542: ST_TO_ADDR
// if not t then
63543: LD_VAR 0 6
63547: NOT
63548: IFFALSE 63552
// continue ;
63550: GO 63409
// for j in tmp do
63552: LD_ADDR_VAR 0 3
63556: PUSH
63557: LD_VAR 0 4
63561: PUSH
63562: FOR_IN
63563: IFFALSE 63593
// if not BuildingStatus ( j ) = bs_idle then
63565: LD_VAR 0 3
63569: PPUSH
63570: CALL_OW 461
63574: PUSH
63575: LD_INT 2
63577: EQUAL
63578: NOT
63579: IFFALSE 63591
// begin busy := true ;
63581: LD_ADDR_VAR 0 8
63585: PUSH
63586: LD_INT 1
63588: ST_TO_ADDR
// break ;
63589: GO 63593
// end ;
63591: GO 63562
63593: POP
63594: POP
// if busy then
63595: LD_VAR 0 8
63599: IFFALSE 63603
// continue ;
63601: GO 63409
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
63603: LD_ADDR_VAR 0 7
63607: PUSH
63608: LD_VAR 0 6
63612: PPUSH
63613: LD_INT 35
63615: PUSH
63616: LD_INT 0
63618: PUSH
63619: EMPTY
63620: LIST
63621: LIST
63622: PPUSH
63623: CALL_OW 72
63627: ST_TO_ADDR
// if tw then
63628: LD_VAR 0 7
63632: IFFALSE 63709
// begin tw := tw [ 1 ] ;
63634: LD_ADDR_VAR 0 7
63638: PUSH
63639: LD_VAR 0 7
63643: PUSH
63644: LD_INT 1
63646: ARRAY
63647: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
63648: LD_ADDR_VAR 0 9
63652: PUSH
63653: LD_VAR 0 7
63657: PPUSH
63658: LD_EXP 93
63662: PUSH
63663: LD_VAR 0 2
63667: ARRAY
63668: PPUSH
63669: CALL 23553 0 2
63673: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
63674: LD_EXP 107
63678: PUSH
63679: LD_VAR 0 2
63683: ARRAY
63684: IFFALSE 63707
// if not weapon in mc_allowed_tower_weapons [ i ] then
63686: LD_VAR 0 9
63690: PUSH
63691: LD_EXP 107
63695: PUSH
63696: LD_VAR 0 2
63700: ARRAY
63701: IN
63702: NOT
63703: IFFALSE 63707
// continue ;
63705: GO 63409
// end else
63707: GO 63772
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63709: LD_ADDR_VAR 0 5
63713: PUSH
63714: LD_EXP 76
63718: PUSH
63719: LD_VAR 0 2
63723: ARRAY
63724: PPUSH
63725: LD_VAR 0 4
63729: PPUSH
63730: CALL 49472 0 2
63734: ST_TO_ADDR
// if not tmp2 then
63735: LD_VAR 0 5
63739: NOT
63740: IFFALSE 63744
// continue ;
63742: GO 63409
// tw := tmp2 [ 1 ] ;
63744: LD_ADDR_VAR 0 7
63748: PUSH
63749: LD_VAR 0 5
63753: PUSH
63754: LD_INT 1
63756: ARRAY
63757: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63758: LD_ADDR_VAR 0 9
63762: PUSH
63763: LD_VAR 0 5
63767: PUSH
63768: LD_INT 2
63770: ARRAY
63771: ST_TO_ADDR
// end ; if not weapon then
63772: LD_VAR 0 9
63776: NOT
63777: IFFALSE 63781
// continue ;
63779: GO 63409
// ComPlaceWeapon ( tw , weapon ) ;
63781: LD_VAR 0 7
63785: PPUSH
63786: LD_VAR 0 9
63790: PPUSH
63791: CALL_OW 148
// end ;
63795: GO 63409
63797: POP
63798: POP
// end ;
63799: LD_VAR 0 1
63803: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
63804: LD_INT 0
63806: PPUSH
63807: PPUSH
63808: PPUSH
63809: PPUSH
63810: PPUSH
63811: PPUSH
63812: PPUSH
// if not mc_bases then
63813: LD_EXP 68
63817: NOT
63818: IFFALSE 63822
// exit ;
63820: GO 64590
// for i = 1 to mc_bases do
63822: LD_ADDR_VAR 0 2
63826: PUSH
63827: DOUBLE
63828: LD_INT 1
63830: DEC
63831: ST_TO_ADDR
63832: LD_EXP 68
63836: PUSH
63837: FOR_TO
63838: IFFALSE 64588
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63840: LD_EXP 81
63844: PUSH
63845: LD_VAR 0 2
63849: ARRAY
63850: NOT
63851: PUSH
63852: LD_EXP 81
63856: PUSH
63857: LD_VAR 0 2
63861: ARRAY
63862: PUSH
63863: LD_EXP 82
63867: PUSH
63868: LD_VAR 0 2
63872: ARRAY
63873: EQUAL
63874: OR
63875: PUSH
63876: LD_EXP 91
63880: PUSH
63881: LD_VAR 0 2
63885: ARRAY
63886: OR
63887: IFFALSE 63891
// continue ;
63889: GO 63837
// if mc_miners [ i ] then
63891: LD_EXP 82
63895: PUSH
63896: LD_VAR 0 2
63900: ARRAY
63901: IFFALSE 64275
// begin for j = mc_miners [ i ] downto 1 do
63903: LD_ADDR_VAR 0 3
63907: PUSH
63908: DOUBLE
63909: LD_EXP 82
63913: PUSH
63914: LD_VAR 0 2
63918: ARRAY
63919: INC
63920: ST_TO_ADDR
63921: LD_INT 1
63923: PUSH
63924: FOR_DOWNTO
63925: IFFALSE 64273
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63927: LD_EXP 82
63931: PUSH
63932: LD_VAR 0 2
63936: ARRAY
63937: PUSH
63938: LD_VAR 0 3
63942: ARRAY
63943: PPUSH
63944: CALL_OW 301
63948: PUSH
63949: LD_EXP 82
63953: PUSH
63954: LD_VAR 0 2
63958: ARRAY
63959: PUSH
63960: LD_VAR 0 3
63964: ARRAY
63965: PPUSH
63966: CALL_OW 257
63970: PUSH
63971: LD_INT 1
63973: NONEQUAL
63974: OR
63975: IFFALSE 64038
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63977: LD_ADDR_VAR 0 5
63981: PUSH
63982: LD_EXP 82
63986: PUSH
63987: LD_VAR 0 2
63991: ARRAY
63992: PUSH
63993: LD_EXP 82
63997: PUSH
63998: LD_VAR 0 2
64002: ARRAY
64003: PUSH
64004: LD_VAR 0 3
64008: ARRAY
64009: DIFF
64010: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
64011: LD_ADDR_EXP 82
64015: PUSH
64016: LD_EXP 82
64020: PPUSH
64021: LD_VAR 0 2
64025: PPUSH
64026: LD_VAR 0 5
64030: PPUSH
64031: CALL_OW 1
64035: ST_TO_ADDR
// continue ;
64036: GO 63924
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
64038: LD_EXP 82
64042: PUSH
64043: LD_VAR 0 2
64047: ARRAY
64048: PUSH
64049: LD_VAR 0 3
64053: ARRAY
64054: PPUSH
64055: CALL_OW 257
64059: PUSH
64060: LD_INT 1
64062: EQUAL
64063: PUSH
64064: LD_EXP 82
64068: PUSH
64069: LD_VAR 0 2
64073: ARRAY
64074: PUSH
64075: LD_VAR 0 3
64079: ARRAY
64080: PPUSH
64081: CALL_OW 459
64085: NOT
64086: AND
64087: PUSH
64088: LD_EXP 82
64092: PUSH
64093: LD_VAR 0 2
64097: ARRAY
64098: PUSH
64099: LD_VAR 0 3
64103: ARRAY
64104: PPUSH
64105: CALL_OW 314
64109: NOT
64110: AND
64111: IFFALSE 64271
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
64113: LD_EXP 82
64117: PUSH
64118: LD_VAR 0 2
64122: ARRAY
64123: PUSH
64124: LD_VAR 0 3
64128: ARRAY
64129: PPUSH
64130: CALL_OW 310
64134: IFFALSE 64157
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
64136: LD_EXP 82
64140: PUSH
64141: LD_VAR 0 2
64145: ARRAY
64146: PUSH
64147: LD_VAR 0 3
64151: ARRAY
64152: PPUSH
64153: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
64157: LD_EXP 82
64161: PUSH
64162: LD_VAR 0 2
64166: ARRAY
64167: PUSH
64168: LD_VAR 0 3
64172: ARRAY
64173: PPUSH
64174: CALL_OW 314
64178: NOT
64179: IFFALSE 64271
// begin r := rand ( 1 , mc_mines [ i ] ) ;
64181: LD_ADDR_VAR 0 7
64185: PUSH
64186: LD_INT 1
64188: PPUSH
64189: LD_EXP 81
64193: PUSH
64194: LD_VAR 0 2
64198: ARRAY
64199: PPUSH
64200: CALL_OW 12
64204: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
64205: LD_EXP 82
64209: PUSH
64210: LD_VAR 0 2
64214: ARRAY
64215: PUSH
64216: LD_VAR 0 3
64220: ARRAY
64221: PPUSH
64222: LD_EXP 81
64226: PUSH
64227: LD_VAR 0 2
64231: ARRAY
64232: PUSH
64233: LD_VAR 0 7
64237: ARRAY
64238: PUSH
64239: LD_INT 1
64241: ARRAY
64242: PPUSH
64243: LD_EXP 81
64247: PUSH
64248: LD_VAR 0 2
64252: ARRAY
64253: PUSH
64254: LD_VAR 0 7
64258: ARRAY
64259: PUSH
64260: LD_INT 2
64262: ARRAY
64263: PPUSH
64264: LD_INT 0
64266: PPUSH
64267: CALL_OW 193
// end ; end ; end ;
64271: GO 63924
64273: POP
64274: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
64275: LD_ADDR_VAR 0 5
64279: PUSH
64280: LD_EXP 68
64284: PUSH
64285: LD_VAR 0 2
64289: ARRAY
64290: PPUSH
64291: LD_INT 2
64293: PUSH
64294: LD_INT 30
64296: PUSH
64297: LD_INT 4
64299: PUSH
64300: EMPTY
64301: LIST
64302: LIST
64303: PUSH
64304: LD_INT 30
64306: PUSH
64307: LD_INT 5
64309: PUSH
64310: EMPTY
64311: LIST
64312: LIST
64313: PUSH
64314: LD_INT 30
64316: PUSH
64317: LD_INT 32
64319: PUSH
64320: EMPTY
64321: LIST
64322: LIST
64323: PUSH
64324: EMPTY
64325: LIST
64326: LIST
64327: LIST
64328: LIST
64329: PPUSH
64330: CALL_OW 72
64334: ST_TO_ADDR
// if not tmp then
64335: LD_VAR 0 5
64339: NOT
64340: IFFALSE 64344
// continue ;
64342: GO 63837
// list := [ ] ;
64344: LD_ADDR_VAR 0 6
64348: PUSH
64349: EMPTY
64350: ST_TO_ADDR
// for j in tmp do
64351: LD_ADDR_VAR 0 3
64355: PUSH
64356: LD_VAR 0 5
64360: PUSH
64361: FOR_IN
64362: IFFALSE 64431
// begin for k in UnitsInside ( j ) do
64364: LD_ADDR_VAR 0 4
64368: PUSH
64369: LD_VAR 0 3
64373: PPUSH
64374: CALL_OW 313
64378: PUSH
64379: FOR_IN
64380: IFFALSE 64427
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64382: LD_VAR 0 4
64386: PPUSH
64387: CALL_OW 257
64391: PUSH
64392: LD_INT 1
64394: EQUAL
64395: PUSH
64396: LD_VAR 0 4
64400: PPUSH
64401: CALL_OW 459
64405: NOT
64406: AND
64407: IFFALSE 64425
// list := list ^ k ;
64409: LD_ADDR_VAR 0 6
64413: PUSH
64414: LD_VAR 0 6
64418: PUSH
64419: LD_VAR 0 4
64423: ADD
64424: ST_TO_ADDR
64425: GO 64379
64427: POP
64428: POP
// end ;
64429: GO 64361
64431: POP
64432: POP
// list := list diff mc_miners [ i ] ;
64433: LD_ADDR_VAR 0 6
64437: PUSH
64438: LD_VAR 0 6
64442: PUSH
64443: LD_EXP 82
64447: PUSH
64448: LD_VAR 0 2
64452: ARRAY
64453: DIFF
64454: ST_TO_ADDR
// if not list then
64455: LD_VAR 0 6
64459: NOT
64460: IFFALSE 64464
// continue ;
64462: GO 63837
// k := mc_mines [ i ] - mc_miners [ i ] ;
64464: LD_ADDR_VAR 0 4
64468: PUSH
64469: LD_EXP 81
64473: PUSH
64474: LD_VAR 0 2
64478: ARRAY
64479: PUSH
64480: LD_EXP 82
64484: PUSH
64485: LD_VAR 0 2
64489: ARRAY
64490: MINUS
64491: ST_TO_ADDR
// if k > list then
64492: LD_VAR 0 4
64496: PUSH
64497: LD_VAR 0 6
64501: GREATER
64502: IFFALSE 64514
// k := list ;
64504: LD_ADDR_VAR 0 4
64508: PUSH
64509: LD_VAR 0 6
64513: ST_TO_ADDR
// for j = 1 to k do
64514: LD_ADDR_VAR 0 3
64518: PUSH
64519: DOUBLE
64520: LD_INT 1
64522: DEC
64523: ST_TO_ADDR
64524: LD_VAR 0 4
64528: PUSH
64529: FOR_TO
64530: IFFALSE 64584
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64532: LD_ADDR_EXP 82
64536: PUSH
64537: LD_EXP 82
64541: PPUSH
64542: LD_VAR 0 2
64546: PUSH
64547: LD_EXP 82
64551: PUSH
64552: LD_VAR 0 2
64556: ARRAY
64557: PUSH
64558: LD_INT 1
64560: PLUS
64561: PUSH
64562: EMPTY
64563: LIST
64564: LIST
64565: PPUSH
64566: LD_VAR 0 6
64570: PUSH
64571: LD_VAR 0 3
64575: ARRAY
64576: PPUSH
64577: CALL 18548 0 3
64581: ST_TO_ADDR
64582: GO 64529
64584: POP
64585: POP
// end ;
64586: GO 63837
64588: POP
64589: POP
// end ;
64590: LD_VAR 0 1
64594: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
64595: LD_INT 0
64597: PPUSH
64598: PPUSH
64599: PPUSH
64600: PPUSH
64601: PPUSH
64602: PPUSH
64603: PPUSH
64604: PPUSH
64605: PPUSH
64606: PPUSH
// if not mc_bases then
64607: LD_EXP 68
64611: NOT
64612: IFFALSE 64616
// exit ;
64614: GO 66366
// for i = 1 to mc_bases do
64616: LD_ADDR_VAR 0 2
64620: PUSH
64621: DOUBLE
64622: LD_INT 1
64624: DEC
64625: ST_TO_ADDR
64626: LD_EXP 68
64630: PUSH
64631: FOR_TO
64632: IFFALSE 66364
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
64634: LD_EXP 68
64638: PUSH
64639: LD_VAR 0 2
64643: ARRAY
64644: NOT
64645: PUSH
64646: LD_EXP 75
64650: PUSH
64651: LD_VAR 0 2
64655: ARRAY
64656: OR
64657: IFFALSE 64661
// continue ;
64659: GO 64631
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
64661: LD_EXP 84
64665: PUSH
64666: LD_VAR 0 2
64670: ARRAY
64671: NOT
64672: PUSH
64673: LD_EXP 85
64677: PUSH
64678: LD_VAR 0 2
64682: ARRAY
64683: AND
64684: IFFALSE 64722
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64686: LD_ADDR_EXP 85
64690: PUSH
64691: LD_EXP 85
64695: PPUSH
64696: LD_VAR 0 2
64700: PPUSH
64701: EMPTY
64702: PPUSH
64703: CALL_OW 1
64707: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64708: LD_VAR 0 2
64712: PPUSH
64713: LD_INT 107
64715: PPUSH
64716: CALL 55549 0 2
// continue ;
64720: GO 64631
// end ; target := [ ] ;
64722: LD_ADDR_VAR 0 6
64726: PUSH
64727: EMPTY
64728: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64729: LD_ADDR_VAR 0 3
64733: PUSH
64734: DOUBLE
64735: LD_EXP 84
64739: PUSH
64740: LD_VAR 0 2
64744: ARRAY
64745: INC
64746: ST_TO_ADDR
64747: LD_INT 1
64749: PUSH
64750: FOR_DOWNTO
64751: IFFALSE 65011
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64753: LD_EXP 84
64757: PUSH
64758: LD_VAR 0 2
64762: ARRAY
64763: PUSH
64764: LD_VAR 0 3
64768: ARRAY
64769: PUSH
64770: LD_INT 2
64772: ARRAY
64773: PPUSH
64774: LD_EXP 84
64778: PUSH
64779: LD_VAR 0 2
64783: ARRAY
64784: PUSH
64785: LD_VAR 0 3
64789: ARRAY
64790: PUSH
64791: LD_INT 3
64793: ARRAY
64794: PPUSH
64795: CALL_OW 488
64799: PUSH
64800: LD_EXP 84
64804: PUSH
64805: LD_VAR 0 2
64809: ARRAY
64810: PUSH
64811: LD_VAR 0 3
64815: ARRAY
64816: PUSH
64817: LD_INT 2
64819: ARRAY
64820: PPUSH
64821: LD_EXP 84
64825: PUSH
64826: LD_VAR 0 2
64830: ARRAY
64831: PUSH
64832: LD_VAR 0 3
64836: ARRAY
64837: PUSH
64838: LD_INT 3
64840: ARRAY
64841: PPUSH
64842: CALL_OW 284
64846: PUSH
64847: LD_INT 0
64849: EQUAL
64850: AND
64851: IFFALSE 64906
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64853: LD_ADDR_VAR 0 5
64857: PUSH
64858: LD_EXP 84
64862: PUSH
64863: LD_VAR 0 2
64867: ARRAY
64868: PPUSH
64869: LD_VAR 0 3
64873: PPUSH
64874: CALL_OW 3
64878: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64879: LD_ADDR_EXP 84
64883: PUSH
64884: LD_EXP 84
64888: PPUSH
64889: LD_VAR 0 2
64893: PPUSH
64894: LD_VAR 0 5
64898: PPUSH
64899: CALL_OW 1
64903: ST_TO_ADDR
// continue ;
64904: GO 64750
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64906: LD_EXP 68
64910: PUSH
64911: LD_VAR 0 2
64915: ARRAY
64916: PUSH
64917: LD_INT 1
64919: ARRAY
64920: PPUSH
64921: CALL_OW 255
64925: PPUSH
64926: LD_EXP 84
64930: PUSH
64931: LD_VAR 0 2
64935: ARRAY
64936: PUSH
64937: LD_VAR 0 3
64941: ARRAY
64942: PUSH
64943: LD_INT 2
64945: ARRAY
64946: PPUSH
64947: LD_EXP 84
64951: PUSH
64952: LD_VAR 0 2
64956: ARRAY
64957: PUSH
64958: LD_VAR 0 3
64962: ARRAY
64963: PUSH
64964: LD_INT 3
64966: ARRAY
64967: PPUSH
64968: LD_INT 30
64970: PPUSH
64971: CALL 19444 0 4
64975: PUSH
64976: LD_INT 4
64978: ARRAY
64979: PUSH
64980: LD_INT 0
64982: EQUAL
64983: IFFALSE 65009
// begin target := mc_crates [ i ] [ j ] ;
64985: LD_ADDR_VAR 0 6
64989: PUSH
64990: LD_EXP 84
64994: PUSH
64995: LD_VAR 0 2
64999: ARRAY
65000: PUSH
65001: LD_VAR 0 3
65005: ARRAY
65006: ST_TO_ADDR
// break ;
65007: GO 65011
// end ; end ;
65009: GO 64750
65011: POP
65012: POP
// if not target then
65013: LD_VAR 0 6
65017: NOT
65018: IFFALSE 65022
// continue ;
65020: GO 64631
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
65022: LD_ADDR_VAR 0 7
65026: PUSH
65027: LD_EXP 87
65031: PUSH
65032: LD_VAR 0 2
65036: ARRAY
65037: PPUSH
65038: LD_INT 2
65040: PUSH
65041: LD_INT 3
65043: PUSH
65044: LD_INT 58
65046: PUSH
65047: EMPTY
65048: LIST
65049: PUSH
65050: EMPTY
65051: LIST
65052: LIST
65053: PUSH
65054: LD_INT 61
65056: PUSH
65057: EMPTY
65058: LIST
65059: PUSH
65060: LD_INT 33
65062: PUSH
65063: LD_INT 5
65065: PUSH
65066: EMPTY
65067: LIST
65068: LIST
65069: PUSH
65070: LD_INT 33
65072: PUSH
65073: LD_INT 3
65075: PUSH
65076: EMPTY
65077: LIST
65078: LIST
65079: PUSH
65080: EMPTY
65081: LIST
65082: LIST
65083: LIST
65084: LIST
65085: LIST
65086: PUSH
65087: LD_INT 2
65089: PUSH
65090: LD_INT 34
65092: PUSH
65093: LD_INT 32
65095: PUSH
65096: EMPTY
65097: LIST
65098: LIST
65099: PUSH
65100: LD_INT 34
65102: PUSH
65103: LD_INT 51
65105: PUSH
65106: EMPTY
65107: LIST
65108: LIST
65109: PUSH
65110: LD_INT 34
65112: PUSH
65113: LD_INT 12
65115: PUSH
65116: EMPTY
65117: LIST
65118: LIST
65119: PUSH
65120: EMPTY
65121: LIST
65122: LIST
65123: LIST
65124: LIST
65125: PUSH
65126: EMPTY
65127: LIST
65128: LIST
65129: PPUSH
65130: CALL_OW 72
65134: ST_TO_ADDR
// if not cargo then
65135: LD_VAR 0 7
65139: NOT
65140: IFFALSE 65783
// begin if mc_crates_collector [ i ] < 5 then
65142: LD_EXP 85
65146: PUSH
65147: LD_VAR 0 2
65151: ARRAY
65152: PUSH
65153: LD_INT 5
65155: LESS
65156: IFFALSE 65522
// begin if mc_ape [ i ] then
65158: LD_EXP 97
65162: PUSH
65163: LD_VAR 0 2
65167: ARRAY
65168: IFFALSE 65215
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
65170: LD_ADDR_VAR 0 5
65174: PUSH
65175: LD_EXP 97
65179: PUSH
65180: LD_VAR 0 2
65184: ARRAY
65185: PPUSH
65186: LD_INT 25
65188: PUSH
65189: LD_INT 16
65191: PUSH
65192: EMPTY
65193: LIST
65194: LIST
65195: PUSH
65196: LD_INT 24
65198: PUSH
65199: LD_INT 750
65201: PUSH
65202: EMPTY
65203: LIST
65204: LIST
65205: PUSH
65206: EMPTY
65207: LIST
65208: LIST
65209: PPUSH
65210: CALL_OW 72
65214: ST_TO_ADDR
// if not tmp then
65215: LD_VAR 0 5
65219: NOT
65220: IFFALSE 65267
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
65222: LD_ADDR_VAR 0 5
65226: PUSH
65227: LD_EXP 68
65231: PUSH
65232: LD_VAR 0 2
65236: ARRAY
65237: PPUSH
65238: LD_INT 25
65240: PUSH
65241: LD_INT 2
65243: PUSH
65244: EMPTY
65245: LIST
65246: LIST
65247: PUSH
65248: LD_INT 24
65250: PUSH
65251: LD_INT 750
65253: PUSH
65254: EMPTY
65255: LIST
65256: LIST
65257: PUSH
65258: EMPTY
65259: LIST
65260: LIST
65261: PPUSH
65262: CALL_OW 72
65266: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65267: LD_EXP 97
65271: PUSH
65272: LD_VAR 0 2
65276: ARRAY
65277: PUSH
65278: LD_EXP 68
65282: PUSH
65283: LD_VAR 0 2
65287: ARRAY
65288: PPUSH
65289: LD_INT 25
65291: PUSH
65292: LD_INT 2
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: LD_INT 24
65301: PUSH
65302: LD_INT 750
65304: PUSH
65305: EMPTY
65306: LIST
65307: LIST
65308: PUSH
65309: EMPTY
65310: LIST
65311: LIST
65312: PPUSH
65313: CALL_OW 72
65317: AND
65318: PUSH
65319: LD_VAR 0 5
65323: PUSH
65324: LD_INT 5
65326: LESS
65327: AND
65328: IFFALSE 65410
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65330: LD_ADDR_VAR 0 3
65334: PUSH
65335: LD_EXP 68
65339: PUSH
65340: LD_VAR 0 2
65344: ARRAY
65345: PPUSH
65346: LD_INT 25
65348: PUSH
65349: LD_INT 2
65351: PUSH
65352: EMPTY
65353: LIST
65354: LIST
65355: PUSH
65356: LD_INT 24
65358: PUSH
65359: LD_INT 750
65361: PUSH
65362: EMPTY
65363: LIST
65364: LIST
65365: PUSH
65366: EMPTY
65367: LIST
65368: LIST
65369: PPUSH
65370: CALL_OW 72
65374: PUSH
65375: FOR_IN
65376: IFFALSE 65408
// begin tmp := tmp union j ;
65378: LD_ADDR_VAR 0 5
65382: PUSH
65383: LD_VAR 0 5
65387: PUSH
65388: LD_VAR 0 3
65392: UNION
65393: ST_TO_ADDR
// if tmp >= 5 then
65394: LD_VAR 0 5
65398: PUSH
65399: LD_INT 5
65401: GREATEREQUAL
65402: IFFALSE 65406
// break ;
65404: GO 65408
// end ;
65406: GO 65375
65408: POP
65409: POP
// end ; if not tmp then
65410: LD_VAR 0 5
65414: NOT
65415: IFFALSE 65419
// continue ;
65417: GO 64631
// for j in tmp do
65419: LD_ADDR_VAR 0 3
65423: PUSH
65424: LD_VAR 0 5
65428: PUSH
65429: FOR_IN
65430: IFFALSE 65520
// if not GetTag ( j ) then
65432: LD_VAR 0 3
65436: PPUSH
65437: CALL_OW 110
65441: NOT
65442: IFFALSE 65518
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65444: LD_ADDR_EXP 85
65448: PUSH
65449: LD_EXP 85
65453: PPUSH
65454: LD_VAR 0 2
65458: PUSH
65459: LD_EXP 85
65463: PUSH
65464: LD_VAR 0 2
65468: ARRAY
65469: PUSH
65470: LD_INT 1
65472: PLUS
65473: PUSH
65474: EMPTY
65475: LIST
65476: LIST
65477: PPUSH
65478: LD_VAR 0 3
65482: PPUSH
65483: CALL 18548 0 3
65487: ST_TO_ADDR
// SetTag ( j , 107 ) ;
65488: LD_VAR 0 3
65492: PPUSH
65493: LD_INT 107
65495: PPUSH
65496: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
65500: LD_EXP 85
65504: PUSH
65505: LD_VAR 0 2
65509: ARRAY
65510: PUSH
65511: LD_INT 5
65513: GREATEREQUAL
65514: IFFALSE 65518
// break ;
65516: GO 65520
// end ;
65518: GO 65429
65520: POP
65521: POP
// end ; if mc_crates_collector [ i ] and target then
65522: LD_EXP 85
65526: PUSH
65527: LD_VAR 0 2
65531: ARRAY
65532: PUSH
65533: LD_VAR 0 6
65537: AND
65538: IFFALSE 65781
// begin if mc_crates_collector [ i ] < target [ 1 ] then
65540: LD_EXP 85
65544: PUSH
65545: LD_VAR 0 2
65549: ARRAY
65550: PUSH
65551: LD_VAR 0 6
65555: PUSH
65556: LD_INT 1
65558: ARRAY
65559: LESS
65560: IFFALSE 65580
// tmp := mc_crates_collector [ i ] else
65562: LD_ADDR_VAR 0 5
65566: PUSH
65567: LD_EXP 85
65571: PUSH
65572: LD_VAR 0 2
65576: ARRAY
65577: ST_TO_ADDR
65578: GO 65594
// tmp := target [ 1 ] ;
65580: LD_ADDR_VAR 0 5
65584: PUSH
65585: LD_VAR 0 6
65589: PUSH
65590: LD_INT 1
65592: ARRAY
65593: ST_TO_ADDR
// k := 0 ;
65594: LD_ADDR_VAR 0 4
65598: PUSH
65599: LD_INT 0
65601: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
65602: LD_ADDR_VAR 0 3
65606: PUSH
65607: LD_EXP 85
65611: PUSH
65612: LD_VAR 0 2
65616: ARRAY
65617: PUSH
65618: FOR_IN
65619: IFFALSE 65779
// begin k := k + 1 ;
65621: LD_ADDR_VAR 0 4
65625: PUSH
65626: LD_VAR 0 4
65630: PUSH
65631: LD_INT 1
65633: PLUS
65634: ST_TO_ADDR
// if k > tmp then
65635: LD_VAR 0 4
65639: PUSH
65640: LD_VAR 0 5
65644: GREATER
65645: IFFALSE 65649
// break ;
65647: GO 65779
// if not GetClass ( j ) in [ 2 , 16 ] then
65649: LD_VAR 0 3
65653: PPUSH
65654: CALL_OW 257
65658: PUSH
65659: LD_INT 2
65661: PUSH
65662: LD_INT 16
65664: PUSH
65665: EMPTY
65666: LIST
65667: LIST
65668: IN
65669: NOT
65670: IFFALSE 65723
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
65672: LD_ADDR_EXP 85
65676: PUSH
65677: LD_EXP 85
65681: PPUSH
65682: LD_VAR 0 2
65686: PPUSH
65687: LD_EXP 85
65691: PUSH
65692: LD_VAR 0 2
65696: ARRAY
65697: PUSH
65698: LD_VAR 0 3
65702: DIFF
65703: PPUSH
65704: CALL_OW 1
65708: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65709: LD_VAR 0 3
65713: PPUSH
65714: LD_INT 0
65716: PPUSH
65717: CALL_OW 109
// continue ;
65721: GO 65618
// end ; if IsInUnit ( j ) then
65723: LD_VAR 0 3
65727: PPUSH
65728: CALL_OW 310
65732: IFFALSE 65743
// ComExitBuilding ( j ) ;
65734: LD_VAR 0 3
65738: PPUSH
65739: CALL_OW 122
// wait ( 3 ) ;
65743: LD_INT 3
65745: PPUSH
65746: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65750: LD_VAR 0 3
65754: PPUSH
65755: LD_VAR 0 6
65759: PUSH
65760: LD_INT 2
65762: ARRAY
65763: PPUSH
65764: LD_VAR 0 6
65768: PUSH
65769: LD_INT 3
65771: ARRAY
65772: PPUSH
65773: CALL_OW 117
// end ;
65777: GO 65618
65779: POP
65780: POP
// end ; end else
65781: GO 66362
// begin for j in cargo do
65783: LD_ADDR_VAR 0 3
65787: PUSH
65788: LD_VAR 0 7
65792: PUSH
65793: FOR_IN
65794: IFFALSE 66360
// begin if GetTag ( j ) <> 0 then
65796: LD_VAR 0 3
65800: PPUSH
65801: CALL_OW 110
65805: PUSH
65806: LD_INT 0
65808: NONEQUAL
65809: IFFALSE 65813
// continue ;
65811: GO 65793
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65813: LD_VAR 0 3
65817: PPUSH
65818: CALL_OW 256
65822: PUSH
65823: LD_INT 1000
65825: LESS
65826: PUSH
65827: LD_VAR 0 3
65831: PPUSH
65832: LD_EXP 92
65836: PUSH
65837: LD_VAR 0 2
65841: ARRAY
65842: PPUSH
65843: CALL_OW 308
65847: NOT
65848: AND
65849: IFFALSE 65871
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65851: LD_VAR 0 3
65855: PPUSH
65856: LD_EXP 92
65860: PUSH
65861: LD_VAR 0 2
65865: ARRAY
65866: PPUSH
65867: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65871: LD_VAR 0 3
65875: PPUSH
65876: CALL_OW 256
65880: PUSH
65881: LD_INT 1000
65883: LESS
65884: PUSH
65885: LD_VAR 0 3
65889: PPUSH
65890: LD_EXP 92
65894: PUSH
65895: LD_VAR 0 2
65899: ARRAY
65900: PPUSH
65901: CALL_OW 308
65905: AND
65906: IFFALSE 65910
// continue ;
65908: GO 65793
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65910: LD_VAR 0 3
65914: PPUSH
65915: CALL_OW 262
65919: PUSH
65920: LD_INT 2
65922: EQUAL
65923: PUSH
65924: LD_VAR 0 3
65928: PPUSH
65929: CALL_OW 261
65933: PUSH
65934: LD_INT 15
65936: LESS
65937: AND
65938: IFFALSE 65942
// continue ;
65940: GO 65793
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
65942: LD_VAR 0 3
65946: PPUSH
65947: CALL_OW 262
65951: PUSH
65952: LD_INT 1
65954: EQUAL
65955: PUSH
65956: LD_VAR 0 3
65960: PPUSH
65961: CALL_OW 261
65965: PUSH
65966: LD_INT 10
65968: LESS
65969: AND
65970: IFFALSE 66299
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65972: LD_ADDR_VAR 0 8
65976: PUSH
65977: LD_EXP 68
65981: PUSH
65982: LD_VAR 0 2
65986: ARRAY
65987: PPUSH
65988: LD_INT 2
65990: PUSH
65991: LD_INT 30
65993: PUSH
65994: LD_INT 0
65996: PUSH
65997: EMPTY
65998: LIST
65999: LIST
66000: PUSH
66001: LD_INT 30
66003: PUSH
66004: LD_INT 1
66006: PUSH
66007: EMPTY
66008: LIST
66009: LIST
66010: PUSH
66011: EMPTY
66012: LIST
66013: LIST
66014: LIST
66015: PPUSH
66016: CALL_OW 72
66020: ST_TO_ADDR
// if not depot then
66021: LD_VAR 0 8
66025: NOT
66026: IFFALSE 66030
// continue ;
66028: GO 65793
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
66030: LD_VAR 0 3
66034: PPUSH
66035: LD_VAR 0 8
66039: PPUSH
66040: LD_VAR 0 3
66044: PPUSH
66045: CALL_OW 74
66049: PPUSH
66050: CALL_OW 296
66054: PUSH
66055: LD_INT 6
66057: LESS
66058: IFFALSE 66074
// SetFuel ( j , 100 ) else
66060: LD_VAR 0 3
66064: PPUSH
66065: LD_INT 100
66067: PPUSH
66068: CALL_OW 240
66072: GO 66299
// if GetFuel ( j ) = 0 then
66074: LD_VAR 0 3
66078: PPUSH
66079: CALL_OW 261
66083: PUSH
66084: LD_INT 0
66086: EQUAL
66087: IFFALSE 66299
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
66089: LD_ADDR_EXP 87
66093: PUSH
66094: LD_EXP 87
66098: PPUSH
66099: LD_VAR 0 2
66103: PPUSH
66104: LD_EXP 87
66108: PUSH
66109: LD_VAR 0 2
66113: ARRAY
66114: PUSH
66115: LD_VAR 0 3
66119: DIFF
66120: PPUSH
66121: CALL_OW 1
66125: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
66126: LD_VAR 0 3
66130: PPUSH
66131: CALL_OW 263
66135: PUSH
66136: LD_INT 1
66138: EQUAL
66139: IFFALSE 66155
// ComExitVehicle ( IsInUnit ( j ) ) ;
66141: LD_VAR 0 3
66145: PPUSH
66146: CALL_OW 310
66150: PPUSH
66151: CALL_OW 121
// if GetControl ( j ) = control_remote then
66155: LD_VAR 0 3
66159: PPUSH
66160: CALL_OW 263
66164: PUSH
66165: LD_INT 2
66167: EQUAL
66168: IFFALSE 66179
// ComUnlink ( j ) ;
66170: LD_VAR 0 3
66174: PPUSH
66175: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
66179: LD_ADDR_VAR 0 9
66183: PUSH
66184: LD_VAR 0 2
66188: PPUSH
66189: LD_INT 3
66191: PPUSH
66192: CALL 75769 0 2
66196: ST_TO_ADDR
// if fac then
66197: LD_VAR 0 9
66201: IFFALSE 66297
// begin for k in fac do
66203: LD_ADDR_VAR 0 4
66207: PUSH
66208: LD_VAR 0 9
66212: PUSH
66213: FOR_IN
66214: IFFALSE 66295
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66216: LD_ADDR_VAR 0 10
66220: PUSH
66221: LD_VAR 0 9
66225: PPUSH
66226: LD_VAR 0 3
66230: PPUSH
66231: CALL_OW 265
66235: PPUSH
66236: LD_VAR 0 3
66240: PPUSH
66241: CALL_OW 262
66245: PPUSH
66246: LD_VAR 0 3
66250: PPUSH
66251: CALL_OW 263
66255: PPUSH
66256: LD_VAR 0 3
66260: PPUSH
66261: CALL_OW 264
66265: PPUSH
66266: CALL 16080 0 5
66270: ST_TO_ADDR
// if components then
66271: LD_VAR 0 10
66275: IFFALSE 66293
// begin MC_InsertProduceList ( i , components ) ;
66277: LD_VAR 0 2
66281: PPUSH
66282: LD_VAR 0 10
66286: PPUSH
66287: CALL 75314 0 2
// break ;
66291: GO 66295
// end ; end ;
66293: GO 66213
66295: POP
66296: POP
// end ; continue ;
66297: GO 65793
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66299: LD_VAR 0 3
66303: PPUSH
66304: LD_INT 1
66306: PPUSH
66307: CALL_OW 289
66311: PUSH
66312: LD_INT 100
66314: LESS
66315: PUSH
66316: LD_VAR 0 3
66320: PPUSH
66321: CALL_OW 314
66325: NOT
66326: AND
66327: IFFALSE 66356
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66329: LD_VAR 0 3
66333: PPUSH
66334: LD_VAR 0 6
66338: PUSH
66339: LD_INT 2
66341: ARRAY
66342: PPUSH
66343: LD_VAR 0 6
66347: PUSH
66348: LD_INT 3
66350: ARRAY
66351: PPUSH
66352: CALL_OW 117
// break ;
66356: GO 66360
// end ;
66358: GO 65793
66360: POP
66361: POP
// end ; end ;
66362: GO 64631
66364: POP
66365: POP
// end ;
66366: LD_VAR 0 1
66370: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66371: LD_INT 0
66373: PPUSH
66374: PPUSH
66375: PPUSH
66376: PPUSH
// if not mc_bases then
66377: LD_EXP 68
66381: NOT
66382: IFFALSE 66386
// exit ;
66384: GO 66547
// for i = 1 to mc_bases do
66386: LD_ADDR_VAR 0 2
66390: PUSH
66391: DOUBLE
66392: LD_INT 1
66394: DEC
66395: ST_TO_ADDR
66396: LD_EXP 68
66400: PUSH
66401: FOR_TO
66402: IFFALSE 66545
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66404: LD_ADDR_VAR 0 4
66408: PUSH
66409: LD_EXP 87
66413: PUSH
66414: LD_VAR 0 2
66418: ARRAY
66419: PUSH
66420: LD_EXP 90
66424: PUSH
66425: LD_VAR 0 2
66429: ARRAY
66430: UNION
66431: PPUSH
66432: LD_INT 33
66434: PUSH
66435: LD_INT 2
66437: PUSH
66438: EMPTY
66439: LIST
66440: LIST
66441: PPUSH
66442: CALL_OW 72
66446: ST_TO_ADDR
// if tmp then
66447: LD_VAR 0 4
66451: IFFALSE 66543
// for j in tmp do
66453: LD_ADDR_VAR 0 3
66457: PUSH
66458: LD_VAR 0 4
66462: PUSH
66463: FOR_IN
66464: IFFALSE 66541
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66466: LD_VAR 0 3
66470: PPUSH
66471: CALL_OW 312
66475: NOT
66476: PUSH
66477: LD_VAR 0 3
66481: PPUSH
66482: CALL_OW 256
66486: PUSH
66487: LD_INT 250
66489: GREATEREQUAL
66490: AND
66491: IFFALSE 66504
// Connect ( j ) else
66493: LD_VAR 0 3
66497: PPUSH
66498: CALL 21513 0 1
66502: GO 66539
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
66504: LD_VAR 0 3
66508: PPUSH
66509: CALL_OW 256
66513: PUSH
66514: LD_INT 250
66516: LESS
66517: PUSH
66518: LD_VAR 0 3
66522: PPUSH
66523: CALL_OW 312
66527: AND
66528: IFFALSE 66539
// ComUnlink ( j ) ;
66530: LD_VAR 0 3
66534: PPUSH
66535: CALL_OW 136
66539: GO 66463
66541: POP
66542: POP
// end ;
66543: GO 66401
66545: POP
66546: POP
// end ;
66547: LD_VAR 0 1
66551: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
66552: LD_INT 0
66554: PPUSH
66555: PPUSH
66556: PPUSH
66557: PPUSH
66558: PPUSH
// if not mc_bases then
66559: LD_EXP 68
66563: NOT
66564: IFFALSE 66568
// exit ;
66566: GO 67013
// for i = 1 to mc_bases do
66568: LD_ADDR_VAR 0 2
66572: PUSH
66573: DOUBLE
66574: LD_INT 1
66576: DEC
66577: ST_TO_ADDR
66578: LD_EXP 68
66582: PUSH
66583: FOR_TO
66584: IFFALSE 67011
// begin if not mc_produce [ i ] then
66586: LD_EXP 89
66590: PUSH
66591: LD_VAR 0 2
66595: ARRAY
66596: NOT
66597: IFFALSE 66601
// continue ;
66599: GO 66583
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66601: LD_ADDR_VAR 0 5
66605: PUSH
66606: LD_EXP 68
66610: PUSH
66611: LD_VAR 0 2
66615: ARRAY
66616: PPUSH
66617: LD_INT 30
66619: PUSH
66620: LD_INT 3
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: PPUSH
66627: CALL_OW 72
66631: ST_TO_ADDR
// if not fac then
66632: LD_VAR 0 5
66636: NOT
66637: IFFALSE 66641
// continue ;
66639: GO 66583
// for j in fac do
66641: LD_ADDR_VAR 0 3
66645: PUSH
66646: LD_VAR 0 5
66650: PUSH
66651: FOR_IN
66652: IFFALSE 67007
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
66654: LD_VAR 0 3
66658: PPUSH
66659: CALL_OW 461
66663: PUSH
66664: LD_INT 2
66666: NONEQUAL
66667: PUSH
66668: LD_VAR 0 3
66672: PPUSH
66673: LD_INT 15
66675: PPUSH
66676: CALL 21141 0 2
66680: PUSH
66681: LD_INT 4
66683: ARRAY
66684: OR
66685: IFFALSE 66689
// continue ;
66687: GO 66651
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66689: LD_VAR 0 3
66693: PPUSH
66694: LD_EXP 89
66698: PUSH
66699: LD_VAR 0 2
66703: ARRAY
66704: PUSH
66705: LD_INT 1
66707: ARRAY
66708: PUSH
66709: LD_INT 1
66711: ARRAY
66712: PPUSH
66713: LD_EXP 89
66717: PUSH
66718: LD_VAR 0 2
66722: ARRAY
66723: PUSH
66724: LD_INT 1
66726: ARRAY
66727: PUSH
66728: LD_INT 2
66730: ARRAY
66731: PPUSH
66732: LD_EXP 89
66736: PUSH
66737: LD_VAR 0 2
66741: ARRAY
66742: PUSH
66743: LD_INT 1
66745: ARRAY
66746: PUSH
66747: LD_INT 3
66749: ARRAY
66750: PPUSH
66751: LD_EXP 89
66755: PUSH
66756: LD_VAR 0 2
66760: ARRAY
66761: PUSH
66762: LD_INT 1
66764: ARRAY
66765: PUSH
66766: LD_INT 4
66768: ARRAY
66769: PPUSH
66770: CALL_OW 448
66774: PUSH
66775: LD_VAR 0 3
66779: PPUSH
66780: LD_EXP 89
66784: PUSH
66785: LD_VAR 0 2
66789: ARRAY
66790: PUSH
66791: LD_INT 1
66793: ARRAY
66794: PUSH
66795: LD_INT 1
66797: ARRAY
66798: PUSH
66799: LD_EXP 89
66803: PUSH
66804: LD_VAR 0 2
66808: ARRAY
66809: PUSH
66810: LD_INT 1
66812: ARRAY
66813: PUSH
66814: LD_INT 2
66816: ARRAY
66817: PUSH
66818: LD_EXP 89
66822: PUSH
66823: LD_VAR 0 2
66827: ARRAY
66828: PUSH
66829: LD_INT 1
66831: ARRAY
66832: PUSH
66833: LD_INT 3
66835: ARRAY
66836: PUSH
66837: LD_EXP 89
66841: PUSH
66842: LD_VAR 0 2
66846: ARRAY
66847: PUSH
66848: LD_INT 1
66850: ARRAY
66851: PUSH
66852: LD_INT 4
66854: ARRAY
66855: PUSH
66856: EMPTY
66857: LIST
66858: LIST
66859: LIST
66860: LIST
66861: PPUSH
66862: CALL 24939 0 2
66866: AND
66867: IFFALSE 67005
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66869: LD_VAR 0 3
66873: PPUSH
66874: LD_EXP 89
66878: PUSH
66879: LD_VAR 0 2
66883: ARRAY
66884: PUSH
66885: LD_INT 1
66887: ARRAY
66888: PUSH
66889: LD_INT 1
66891: ARRAY
66892: PPUSH
66893: LD_EXP 89
66897: PUSH
66898: LD_VAR 0 2
66902: ARRAY
66903: PUSH
66904: LD_INT 1
66906: ARRAY
66907: PUSH
66908: LD_INT 2
66910: ARRAY
66911: PPUSH
66912: LD_EXP 89
66916: PUSH
66917: LD_VAR 0 2
66921: ARRAY
66922: PUSH
66923: LD_INT 1
66925: ARRAY
66926: PUSH
66927: LD_INT 3
66929: ARRAY
66930: PPUSH
66931: LD_EXP 89
66935: PUSH
66936: LD_VAR 0 2
66940: ARRAY
66941: PUSH
66942: LD_INT 1
66944: ARRAY
66945: PUSH
66946: LD_INT 4
66948: ARRAY
66949: PPUSH
66950: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66954: LD_ADDR_VAR 0 4
66958: PUSH
66959: LD_EXP 89
66963: PUSH
66964: LD_VAR 0 2
66968: ARRAY
66969: PPUSH
66970: LD_INT 1
66972: PPUSH
66973: CALL_OW 3
66977: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66978: LD_ADDR_EXP 89
66982: PUSH
66983: LD_EXP 89
66987: PPUSH
66988: LD_VAR 0 2
66992: PPUSH
66993: LD_VAR 0 4
66997: PPUSH
66998: CALL_OW 1
67002: ST_TO_ADDR
// break ;
67003: GO 67007
// end ; end ;
67005: GO 66651
67007: POP
67008: POP
// end ;
67009: GO 66583
67011: POP
67012: POP
// end ;
67013: LD_VAR 0 1
67017: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
67018: LD_INT 0
67020: PPUSH
67021: PPUSH
67022: PPUSH
// if not mc_bases then
67023: LD_EXP 68
67027: NOT
67028: IFFALSE 67032
// exit ;
67030: GO 67121
// for i = 1 to mc_bases do
67032: LD_ADDR_VAR 0 2
67036: PUSH
67037: DOUBLE
67038: LD_INT 1
67040: DEC
67041: ST_TO_ADDR
67042: LD_EXP 68
67046: PUSH
67047: FOR_TO
67048: IFFALSE 67119
// begin if mc_attack [ i ] then
67050: LD_EXP 88
67054: PUSH
67055: LD_VAR 0 2
67059: ARRAY
67060: IFFALSE 67117
// begin tmp := mc_attack [ i ] [ 1 ] ;
67062: LD_ADDR_VAR 0 3
67066: PUSH
67067: LD_EXP 88
67071: PUSH
67072: LD_VAR 0 2
67076: ARRAY
67077: PUSH
67078: LD_INT 1
67080: ARRAY
67081: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
67082: LD_ADDR_EXP 88
67086: PUSH
67087: LD_EXP 88
67091: PPUSH
67092: LD_VAR 0 2
67096: PPUSH
67097: EMPTY
67098: PPUSH
67099: CALL_OW 1
67103: ST_TO_ADDR
// Attack ( tmp ) ;
67104: LD_VAR 0 3
67108: PPUSH
67109: CALL 98864 0 1
// exit ;
67113: POP
67114: POP
67115: GO 67121
// end ; end ;
67117: GO 67047
67119: POP
67120: POP
// end ;
67121: LD_VAR 0 1
67125: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
67126: LD_INT 0
67128: PPUSH
67129: PPUSH
67130: PPUSH
67131: PPUSH
67132: PPUSH
67133: PPUSH
67134: PPUSH
// if not mc_bases then
67135: LD_EXP 68
67139: NOT
67140: IFFALSE 67144
// exit ;
67142: GO 67843
// for i = 1 to mc_bases do
67144: LD_ADDR_VAR 0 2
67148: PUSH
67149: DOUBLE
67150: LD_INT 1
67152: DEC
67153: ST_TO_ADDR
67154: LD_EXP 68
67158: PUSH
67159: FOR_TO
67160: IFFALSE 67841
// begin if not mc_bases [ i ] then
67162: LD_EXP 68
67166: PUSH
67167: LD_VAR 0 2
67171: ARRAY
67172: NOT
67173: IFFALSE 67177
// continue ;
67175: GO 67159
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
67177: LD_ADDR_VAR 0 7
67181: PUSH
67182: LD_EXP 68
67186: PUSH
67187: LD_VAR 0 2
67191: ARRAY
67192: PUSH
67193: LD_INT 1
67195: ARRAY
67196: PPUSH
67197: CALL 15384 0 1
67201: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
67202: LD_ADDR_EXP 91
67206: PUSH
67207: LD_EXP 91
67211: PPUSH
67212: LD_VAR 0 2
67216: PPUSH
67217: LD_EXP 68
67221: PUSH
67222: LD_VAR 0 2
67226: ARRAY
67227: PUSH
67228: LD_INT 1
67230: ARRAY
67231: PPUSH
67232: CALL_OW 255
67236: PPUSH
67237: LD_EXP 93
67241: PUSH
67242: LD_VAR 0 2
67246: ARRAY
67247: PPUSH
67248: CALL 15349 0 2
67252: PPUSH
67253: CALL_OW 1
67257: ST_TO_ADDR
// if not mc_scan [ i ] then
67258: LD_EXP 91
67262: PUSH
67263: LD_VAR 0 2
67267: ARRAY
67268: NOT
67269: IFFALSE 67447
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67271: LD_ADDR_VAR 0 4
67275: PUSH
67276: LD_EXP 68
67280: PUSH
67281: LD_VAR 0 2
67285: ARRAY
67286: PPUSH
67287: LD_INT 2
67289: PUSH
67290: LD_INT 25
67292: PUSH
67293: LD_INT 5
67295: PUSH
67296: EMPTY
67297: LIST
67298: LIST
67299: PUSH
67300: LD_INT 25
67302: PUSH
67303: LD_INT 8
67305: PUSH
67306: EMPTY
67307: LIST
67308: LIST
67309: PUSH
67310: LD_INT 25
67312: PUSH
67313: LD_INT 9
67315: PUSH
67316: EMPTY
67317: LIST
67318: LIST
67319: PUSH
67320: EMPTY
67321: LIST
67322: LIST
67323: LIST
67324: LIST
67325: PPUSH
67326: CALL_OW 72
67330: ST_TO_ADDR
// if not tmp then
67331: LD_VAR 0 4
67335: NOT
67336: IFFALSE 67340
// continue ;
67338: GO 67159
// for j in tmp do
67340: LD_ADDR_VAR 0 3
67344: PUSH
67345: LD_VAR 0 4
67349: PUSH
67350: FOR_IN
67351: IFFALSE 67422
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67353: LD_VAR 0 3
67357: PPUSH
67358: CALL_OW 310
67362: PPUSH
67363: CALL_OW 266
67367: PUSH
67368: LD_INT 5
67370: EQUAL
67371: PUSH
67372: LD_VAR 0 3
67376: PPUSH
67377: CALL_OW 257
67381: PUSH
67382: LD_INT 1
67384: EQUAL
67385: AND
67386: PUSH
67387: LD_VAR 0 3
67391: PPUSH
67392: CALL_OW 459
67396: NOT
67397: AND
67398: PUSH
67399: LD_VAR 0 7
67403: AND
67404: IFFALSE 67420
// ComChangeProfession ( j , class ) ;
67406: LD_VAR 0 3
67410: PPUSH
67411: LD_VAR 0 7
67415: PPUSH
67416: CALL_OW 123
67420: GO 67350
67422: POP
67423: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
67424: LD_ADDR_EXP 111
67428: PUSH
67429: LD_EXP 111
67433: PPUSH
67434: LD_VAR 0 2
67438: PPUSH
67439: LD_INT 0
67441: PPUSH
67442: CALL_OW 1
67446: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67447: LD_EXP 91
67451: PUSH
67452: LD_VAR 0 2
67456: ARRAY
67457: PUSH
67458: LD_EXP 111
67462: PUSH
67463: LD_VAR 0 2
67467: ARRAY
67468: NOT
67469: AND
67470: PUSH
67471: LD_EXP 90
67475: PUSH
67476: LD_VAR 0 2
67480: ARRAY
67481: NOT
67482: AND
67483: PUSH
67484: LD_EXP 68
67488: PUSH
67489: LD_VAR 0 2
67493: ARRAY
67494: PPUSH
67495: LD_INT 30
67497: PUSH
67498: LD_INT 32
67500: PUSH
67501: EMPTY
67502: LIST
67503: LIST
67504: PPUSH
67505: CALL_OW 72
67509: NOT
67510: AND
67511: PUSH
67512: LD_EXP 68
67516: PUSH
67517: LD_VAR 0 2
67521: ARRAY
67522: PPUSH
67523: LD_INT 2
67525: PUSH
67526: LD_INT 30
67528: PUSH
67529: LD_INT 4
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: LD_INT 30
67538: PUSH
67539: LD_INT 5
67541: PUSH
67542: EMPTY
67543: LIST
67544: LIST
67545: PUSH
67546: EMPTY
67547: LIST
67548: LIST
67549: LIST
67550: PPUSH
67551: CALL_OW 72
67555: NOT
67556: AND
67557: IFFALSE 67712
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67559: LD_ADDR_VAR 0 4
67563: PUSH
67564: LD_EXP 68
67568: PUSH
67569: LD_VAR 0 2
67573: ARRAY
67574: PPUSH
67575: LD_INT 2
67577: PUSH
67578: LD_INT 25
67580: PUSH
67581: LD_INT 1
67583: PUSH
67584: EMPTY
67585: LIST
67586: LIST
67587: PUSH
67588: LD_INT 25
67590: PUSH
67591: LD_INT 5
67593: PUSH
67594: EMPTY
67595: LIST
67596: LIST
67597: PUSH
67598: LD_INT 25
67600: PUSH
67601: LD_INT 8
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: LD_INT 25
67610: PUSH
67611: LD_INT 9
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: EMPTY
67619: LIST
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: PPUSH
67625: CALL_OW 72
67629: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67630: LD_ADDR_VAR 0 4
67634: PUSH
67635: LD_VAR 0 4
67639: PUSH
67640: LD_VAR 0 4
67644: PPUSH
67645: LD_INT 18
67647: PPUSH
67648: CALL 47442 0 2
67652: DIFF
67653: ST_TO_ADDR
// if tmp then
67654: LD_VAR 0 4
67658: IFFALSE 67712
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67660: LD_ADDR_EXP 111
67664: PUSH
67665: LD_EXP 111
67669: PPUSH
67670: LD_VAR 0 2
67674: PPUSH
67675: LD_INT 1
67677: PPUSH
67678: CALL_OW 1
67682: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
67683: LD_VAR 0 2
67687: PPUSH
67688: LD_VAR 0 4
67692: PPUSH
67693: LD_EXP 93
67697: PUSH
67698: LD_VAR 0 2
67702: ARRAY
67703: PPUSH
67704: CALL 103573 0 3
// exit ;
67708: POP
67709: POP
67710: GO 67843
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
67712: LD_EXP 91
67716: PUSH
67717: LD_VAR 0 2
67721: ARRAY
67722: PUSH
67723: LD_EXP 111
67727: PUSH
67728: LD_VAR 0 2
67732: ARRAY
67733: NOT
67734: AND
67735: PUSH
67736: LD_EXP 90
67740: PUSH
67741: LD_VAR 0 2
67745: ARRAY
67746: AND
67747: IFFALSE 67839
// begin tmp := mc_defender [ i ] ;
67749: LD_ADDR_VAR 0 4
67753: PUSH
67754: LD_EXP 90
67758: PUSH
67759: LD_VAR 0 2
67763: ARRAY
67764: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
67765: LD_ADDR_EXP 90
67769: PUSH
67770: LD_EXP 90
67774: PPUSH
67775: LD_VAR 0 2
67779: PPUSH
67780: EMPTY
67781: PPUSH
67782: CALL_OW 1
67786: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67787: LD_ADDR_EXP 111
67791: PUSH
67792: LD_EXP 111
67796: PPUSH
67797: LD_VAR 0 2
67801: PPUSH
67802: LD_INT 1
67804: PPUSH
67805: CALL_OW 1
67809: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
67810: LD_VAR 0 2
67814: PPUSH
67815: LD_VAR 0 4
67819: PPUSH
67820: LD_EXP 91
67824: PUSH
67825: LD_VAR 0 2
67829: ARRAY
67830: PPUSH
67831: CALL 104134 0 3
// exit ;
67835: POP
67836: POP
67837: GO 67843
// end ; end ;
67839: GO 67159
67841: POP
67842: POP
// end ;
67843: LD_VAR 0 1
67847: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
67848: LD_INT 0
67850: PPUSH
67851: PPUSH
67852: PPUSH
67853: PPUSH
67854: PPUSH
67855: PPUSH
67856: PPUSH
67857: PPUSH
67858: PPUSH
67859: PPUSH
67860: PPUSH
// if not mc_bases then
67861: LD_EXP 68
67865: NOT
67866: IFFALSE 67870
// exit ;
67868: GO 68957
// for i = 1 to mc_bases do
67870: LD_ADDR_VAR 0 2
67874: PUSH
67875: DOUBLE
67876: LD_INT 1
67878: DEC
67879: ST_TO_ADDR
67880: LD_EXP 68
67884: PUSH
67885: FOR_TO
67886: IFFALSE 68955
// begin tmp := mc_lab [ i ] ;
67888: LD_ADDR_VAR 0 6
67892: PUSH
67893: LD_EXP 101
67897: PUSH
67898: LD_VAR 0 2
67902: ARRAY
67903: ST_TO_ADDR
// if not tmp then
67904: LD_VAR 0 6
67908: NOT
67909: IFFALSE 67913
// continue ;
67911: GO 67885
// idle_lab := 0 ;
67913: LD_ADDR_VAR 0 11
67917: PUSH
67918: LD_INT 0
67920: ST_TO_ADDR
// for j in tmp do
67921: LD_ADDR_VAR 0 3
67925: PUSH
67926: LD_VAR 0 6
67930: PUSH
67931: FOR_IN
67932: IFFALSE 68951
// begin researching := false ;
67934: LD_ADDR_VAR 0 10
67938: PUSH
67939: LD_INT 0
67941: ST_TO_ADDR
// side := GetSide ( j ) ;
67942: LD_ADDR_VAR 0 4
67946: PUSH
67947: LD_VAR 0 3
67951: PPUSH
67952: CALL_OW 255
67956: ST_TO_ADDR
// if not mc_tech [ side ] then
67957: LD_EXP 95
67961: PUSH
67962: LD_VAR 0 4
67966: ARRAY
67967: NOT
67968: IFFALSE 67972
// continue ;
67970: GO 67931
// if BuildingStatus ( j ) = bs_idle then
67972: LD_VAR 0 3
67976: PPUSH
67977: CALL_OW 461
67981: PUSH
67982: LD_INT 2
67984: EQUAL
67985: IFFALSE 68173
// begin if idle_lab and UnitsInside ( j ) < 6 then
67987: LD_VAR 0 11
67991: PUSH
67992: LD_VAR 0 3
67996: PPUSH
67997: CALL_OW 313
68001: PUSH
68002: LD_INT 6
68004: LESS
68005: AND
68006: IFFALSE 68077
// begin tmp2 := UnitsInside ( idle_lab ) ;
68008: LD_ADDR_VAR 0 9
68012: PUSH
68013: LD_VAR 0 11
68017: PPUSH
68018: CALL_OW 313
68022: ST_TO_ADDR
// if tmp2 then
68023: LD_VAR 0 9
68027: IFFALSE 68069
// for x in tmp2 do
68029: LD_ADDR_VAR 0 7
68033: PUSH
68034: LD_VAR 0 9
68038: PUSH
68039: FOR_IN
68040: IFFALSE 68067
// begin ComExitBuilding ( x ) ;
68042: LD_VAR 0 7
68046: PPUSH
68047: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68051: LD_VAR 0 7
68055: PPUSH
68056: LD_VAR 0 3
68060: PPUSH
68061: CALL_OW 180
// end ;
68065: GO 68039
68067: POP
68068: POP
// idle_lab := 0 ;
68069: LD_ADDR_VAR 0 11
68073: PUSH
68074: LD_INT 0
68076: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
68077: LD_ADDR_VAR 0 5
68081: PUSH
68082: LD_EXP 95
68086: PUSH
68087: LD_VAR 0 4
68091: ARRAY
68092: PUSH
68093: FOR_IN
68094: IFFALSE 68154
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
68096: LD_VAR 0 3
68100: PPUSH
68101: LD_VAR 0 5
68105: PPUSH
68106: CALL_OW 430
68110: PUSH
68111: LD_VAR 0 4
68115: PPUSH
68116: LD_VAR 0 5
68120: PPUSH
68121: CALL 14454 0 2
68125: AND
68126: IFFALSE 68152
// begin researching := true ;
68128: LD_ADDR_VAR 0 10
68132: PUSH
68133: LD_INT 1
68135: ST_TO_ADDR
// ComResearch ( j , t ) ;
68136: LD_VAR 0 3
68140: PPUSH
68141: LD_VAR 0 5
68145: PPUSH
68146: CALL_OW 124
// break ;
68150: GO 68154
// end ;
68152: GO 68093
68154: POP
68155: POP
// if not researching then
68156: LD_VAR 0 10
68160: NOT
68161: IFFALSE 68173
// idle_lab := j ;
68163: LD_ADDR_VAR 0 11
68167: PUSH
68168: LD_VAR 0 3
68172: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
68173: LD_VAR 0 3
68177: PPUSH
68178: CALL_OW 461
68182: PUSH
68183: LD_INT 10
68185: EQUAL
68186: IFFALSE 68774
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
68188: LD_EXP 97
68192: PUSH
68193: LD_VAR 0 2
68197: ARRAY
68198: NOT
68199: PUSH
68200: LD_EXP 98
68204: PUSH
68205: LD_VAR 0 2
68209: ARRAY
68210: NOT
68211: AND
68212: PUSH
68213: LD_EXP 95
68217: PUSH
68218: LD_VAR 0 4
68222: ARRAY
68223: PUSH
68224: LD_INT 1
68226: GREATER
68227: AND
68228: IFFALSE 68359
// begin ComCancel ( j ) ;
68230: LD_VAR 0 3
68234: PPUSH
68235: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68239: LD_ADDR_EXP 95
68243: PUSH
68244: LD_EXP 95
68248: PPUSH
68249: LD_VAR 0 4
68253: PPUSH
68254: LD_EXP 95
68258: PUSH
68259: LD_VAR 0 4
68263: ARRAY
68264: PPUSH
68265: LD_EXP 95
68269: PUSH
68270: LD_VAR 0 4
68274: ARRAY
68275: PUSH
68276: LD_INT 1
68278: MINUS
68279: PPUSH
68280: LD_EXP 95
68284: PUSH
68285: LD_VAR 0 4
68289: ARRAY
68290: PPUSH
68291: LD_INT 0
68293: PPUSH
68294: CALL 17966 0 4
68298: PPUSH
68299: CALL_OW 1
68303: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68304: LD_ADDR_EXP 95
68308: PUSH
68309: LD_EXP 95
68313: PPUSH
68314: LD_VAR 0 4
68318: PPUSH
68319: LD_EXP 95
68323: PUSH
68324: LD_VAR 0 4
68328: ARRAY
68329: PPUSH
68330: LD_EXP 95
68334: PUSH
68335: LD_VAR 0 4
68339: ARRAY
68340: PPUSH
68341: LD_INT 1
68343: PPUSH
68344: LD_INT 0
68346: PPUSH
68347: CALL 17966 0 4
68351: PPUSH
68352: CALL_OW 1
68356: ST_TO_ADDR
// continue ;
68357: GO 67931
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68359: LD_EXP 97
68363: PUSH
68364: LD_VAR 0 2
68368: ARRAY
68369: PUSH
68370: LD_EXP 98
68374: PUSH
68375: LD_VAR 0 2
68379: ARRAY
68380: NOT
68381: AND
68382: IFFALSE 68509
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68384: LD_ADDR_EXP 98
68388: PUSH
68389: LD_EXP 98
68393: PPUSH
68394: LD_VAR 0 2
68398: PUSH
68399: LD_EXP 98
68403: PUSH
68404: LD_VAR 0 2
68408: ARRAY
68409: PUSH
68410: LD_INT 1
68412: PLUS
68413: PUSH
68414: EMPTY
68415: LIST
68416: LIST
68417: PPUSH
68418: LD_EXP 97
68422: PUSH
68423: LD_VAR 0 2
68427: ARRAY
68428: PUSH
68429: LD_INT 1
68431: ARRAY
68432: PPUSH
68433: CALL 18548 0 3
68437: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
68438: LD_EXP 97
68442: PUSH
68443: LD_VAR 0 2
68447: ARRAY
68448: PUSH
68449: LD_INT 1
68451: ARRAY
68452: PPUSH
68453: LD_INT 112
68455: PPUSH
68456: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
68460: LD_ADDR_VAR 0 9
68464: PUSH
68465: LD_EXP 97
68469: PUSH
68470: LD_VAR 0 2
68474: ARRAY
68475: PPUSH
68476: LD_INT 1
68478: PPUSH
68479: CALL_OW 3
68483: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
68484: LD_ADDR_EXP 97
68488: PUSH
68489: LD_EXP 97
68493: PPUSH
68494: LD_VAR 0 2
68498: PPUSH
68499: LD_VAR 0 9
68503: PPUSH
68504: CALL_OW 1
68508: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
68509: LD_EXP 97
68513: PUSH
68514: LD_VAR 0 2
68518: ARRAY
68519: PUSH
68520: LD_EXP 98
68524: PUSH
68525: LD_VAR 0 2
68529: ARRAY
68530: AND
68531: PUSH
68532: LD_EXP 98
68536: PUSH
68537: LD_VAR 0 2
68541: ARRAY
68542: PUSH
68543: LD_INT 1
68545: ARRAY
68546: PPUSH
68547: CALL_OW 310
68551: NOT
68552: AND
68553: PUSH
68554: LD_VAR 0 3
68558: PPUSH
68559: CALL_OW 313
68563: PUSH
68564: LD_INT 6
68566: EQUAL
68567: AND
68568: IFFALSE 68624
// begin tmp2 := UnitsInside ( j ) ;
68570: LD_ADDR_VAR 0 9
68574: PUSH
68575: LD_VAR 0 3
68579: PPUSH
68580: CALL_OW 313
68584: ST_TO_ADDR
// if tmp2 = 6 then
68585: LD_VAR 0 9
68589: PUSH
68590: LD_INT 6
68592: EQUAL
68593: IFFALSE 68624
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68595: LD_VAR 0 9
68599: PUSH
68600: LD_INT 1
68602: ARRAY
68603: PPUSH
68604: LD_INT 112
68606: PPUSH
68607: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68611: LD_VAR 0 9
68615: PUSH
68616: LD_INT 1
68618: ARRAY
68619: PPUSH
68620: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68624: LD_EXP 98
68628: PUSH
68629: LD_VAR 0 2
68633: ARRAY
68634: PUSH
68635: LD_EXP 98
68639: PUSH
68640: LD_VAR 0 2
68644: ARRAY
68645: PUSH
68646: LD_INT 1
68648: ARRAY
68649: PPUSH
68650: CALL_OW 314
68654: NOT
68655: AND
68656: PUSH
68657: LD_EXP 98
68661: PUSH
68662: LD_VAR 0 2
68666: ARRAY
68667: PUSH
68668: LD_INT 1
68670: ARRAY
68671: PPUSH
68672: CALL_OW 310
68676: NOT
68677: AND
68678: IFFALSE 68704
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68680: LD_EXP 98
68684: PUSH
68685: LD_VAR 0 2
68689: ARRAY
68690: PUSH
68691: LD_INT 1
68693: ARRAY
68694: PPUSH
68695: LD_VAR 0 3
68699: PPUSH
68700: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
68704: LD_EXP 98
68708: PUSH
68709: LD_VAR 0 2
68713: ARRAY
68714: PUSH
68715: LD_INT 1
68717: ARRAY
68718: PPUSH
68719: CALL_OW 310
68723: PUSH
68724: LD_EXP 98
68728: PUSH
68729: LD_VAR 0 2
68733: ARRAY
68734: PUSH
68735: LD_INT 1
68737: ARRAY
68738: PPUSH
68739: CALL_OW 310
68743: PPUSH
68744: CALL_OW 461
68748: PUSH
68749: LD_INT 3
68751: NONEQUAL
68752: AND
68753: IFFALSE 68774
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
68755: LD_EXP 98
68759: PUSH
68760: LD_VAR 0 2
68764: ARRAY
68765: PUSH
68766: LD_INT 1
68768: ARRAY
68769: PPUSH
68770: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68774: LD_VAR 0 3
68778: PPUSH
68779: CALL_OW 461
68783: PUSH
68784: LD_INT 6
68786: EQUAL
68787: PUSH
68788: LD_VAR 0 6
68792: PUSH
68793: LD_INT 1
68795: GREATER
68796: AND
68797: IFFALSE 68949
// begin sci := [ ] ;
68799: LD_ADDR_VAR 0 8
68803: PUSH
68804: EMPTY
68805: ST_TO_ADDR
// for x in ( tmp diff j ) do
68806: LD_ADDR_VAR 0 7
68810: PUSH
68811: LD_VAR 0 6
68815: PUSH
68816: LD_VAR 0 3
68820: DIFF
68821: PUSH
68822: FOR_IN
68823: IFFALSE 68875
// begin if sci = 6 then
68825: LD_VAR 0 8
68829: PUSH
68830: LD_INT 6
68832: EQUAL
68833: IFFALSE 68837
// break ;
68835: GO 68875
// if BuildingStatus ( x ) = bs_idle then
68837: LD_VAR 0 7
68841: PPUSH
68842: CALL_OW 461
68846: PUSH
68847: LD_INT 2
68849: EQUAL
68850: IFFALSE 68873
// sci := sci ^ UnitsInside ( x ) ;
68852: LD_ADDR_VAR 0 8
68856: PUSH
68857: LD_VAR 0 8
68861: PUSH
68862: LD_VAR 0 7
68866: PPUSH
68867: CALL_OW 313
68871: ADD
68872: ST_TO_ADDR
// end ;
68873: GO 68822
68875: POP
68876: POP
// if not sci then
68877: LD_VAR 0 8
68881: NOT
68882: IFFALSE 68886
// continue ;
68884: GO 67931
// for x in sci do
68886: LD_ADDR_VAR 0 7
68890: PUSH
68891: LD_VAR 0 8
68895: PUSH
68896: FOR_IN
68897: IFFALSE 68947
// if IsInUnit ( x ) and not HasTask ( x ) then
68899: LD_VAR 0 7
68903: PPUSH
68904: CALL_OW 310
68908: PUSH
68909: LD_VAR 0 7
68913: PPUSH
68914: CALL_OW 314
68918: NOT
68919: AND
68920: IFFALSE 68945
// begin ComExitBuilding ( x ) ;
68922: LD_VAR 0 7
68926: PPUSH
68927: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68931: LD_VAR 0 7
68935: PPUSH
68936: LD_VAR 0 3
68940: PPUSH
68941: CALL_OW 180
// end ;
68945: GO 68896
68947: POP
68948: POP
// end ; end ;
68949: GO 67931
68951: POP
68952: POP
// end ;
68953: GO 67885
68955: POP
68956: POP
// end ;
68957: LD_VAR 0 1
68961: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
68962: LD_INT 0
68964: PPUSH
68965: PPUSH
// if not mc_bases then
68966: LD_EXP 68
68970: NOT
68971: IFFALSE 68975
// exit ;
68973: GO 69056
// for i = 1 to mc_bases do
68975: LD_ADDR_VAR 0 2
68979: PUSH
68980: DOUBLE
68981: LD_INT 1
68983: DEC
68984: ST_TO_ADDR
68985: LD_EXP 68
68989: PUSH
68990: FOR_TO
68991: IFFALSE 69054
// if mc_mines [ i ] and mc_miners [ i ] then
68993: LD_EXP 81
68997: PUSH
68998: LD_VAR 0 2
69002: ARRAY
69003: PUSH
69004: LD_EXP 82
69008: PUSH
69009: LD_VAR 0 2
69013: ARRAY
69014: AND
69015: IFFALSE 69052
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
69017: LD_EXP 82
69021: PUSH
69022: LD_VAR 0 2
69026: ARRAY
69027: PUSH
69028: LD_INT 1
69030: ARRAY
69031: PPUSH
69032: CALL_OW 255
69036: PPUSH
69037: LD_EXP 81
69041: PUSH
69042: LD_VAR 0 2
69046: ARRAY
69047: PPUSH
69048: CALL 15537 0 2
69052: GO 68990
69054: POP
69055: POP
// end ;
69056: LD_VAR 0 1
69060: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
69061: LD_INT 0
69063: PPUSH
69064: PPUSH
69065: PPUSH
69066: PPUSH
69067: PPUSH
69068: PPUSH
69069: PPUSH
69070: PPUSH
// if not mc_bases or not mc_parking then
69071: LD_EXP 68
69075: NOT
69076: PUSH
69077: LD_EXP 92
69081: NOT
69082: OR
69083: IFFALSE 69087
// exit ;
69085: GO 69786
// for i = 1 to mc_bases do
69087: LD_ADDR_VAR 0 2
69091: PUSH
69092: DOUBLE
69093: LD_INT 1
69095: DEC
69096: ST_TO_ADDR
69097: LD_EXP 68
69101: PUSH
69102: FOR_TO
69103: IFFALSE 69784
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
69105: LD_EXP 68
69109: PUSH
69110: LD_VAR 0 2
69114: ARRAY
69115: NOT
69116: PUSH
69117: LD_EXP 92
69121: PUSH
69122: LD_VAR 0 2
69126: ARRAY
69127: NOT
69128: OR
69129: IFFALSE 69133
// continue ;
69131: GO 69102
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69133: LD_ADDR_VAR 0 5
69137: PUSH
69138: LD_EXP 68
69142: PUSH
69143: LD_VAR 0 2
69147: ARRAY
69148: PUSH
69149: LD_INT 1
69151: ARRAY
69152: PPUSH
69153: CALL_OW 255
69157: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69158: LD_ADDR_VAR 0 6
69162: PUSH
69163: LD_EXP 68
69167: PUSH
69168: LD_VAR 0 2
69172: ARRAY
69173: PPUSH
69174: LD_INT 30
69176: PUSH
69177: LD_INT 3
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: PPUSH
69184: CALL_OW 72
69188: ST_TO_ADDR
// if not fac then
69189: LD_VAR 0 6
69193: NOT
69194: IFFALSE 69245
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69196: LD_ADDR_VAR 0 6
69200: PUSH
69201: LD_EXP 68
69205: PUSH
69206: LD_VAR 0 2
69210: ARRAY
69211: PPUSH
69212: LD_INT 2
69214: PUSH
69215: LD_INT 30
69217: PUSH
69218: LD_INT 0
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: PUSH
69225: LD_INT 30
69227: PUSH
69228: LD_INT 1
69230: PUSH
69231: EMPTY
69232: LIST
69233: LIST
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: LIST
69239: PPUSH
69240: CALL_OW 72
69244: ST_TO_ADDR
// if not fac then
69245: LD_VAR 0 6
69249: NOT
69250: IFFALSE 69254
// continue ;
69252: GO 69102
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69254: LD_ADDR_VAR 0 7
69258: PUSH
69259: LD_EXP 92
69263: PUSH
69264: LD_VAR 0 2
69268: ARRAY
69269: PPUSH
69270: LD_INT 22
69272: PUSH
69273: LD_VAR 0 5
69277: PUSH
69278: EMPTY
69279: LIST
69280: LIST
69281: PUSH
69282: LD_INT 21
69284: PUSH
69285: LD_INT 2
69287: PUSH
69288: EMPTY
69289: LIST
69290: LIST
69291: PUSH
69292: LD_INT 3
69294: PUSH
69295: LD_INT 24
69297: PUSH
69298: LD_INT 1000
69300: PUSH
69301: EMPTY
69302: LIST
69303: LIST
69304: PUSH
69305: EMPTY
69306: LIST
69307: LIST
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: LIST
69313: PPUSH
69314: CALL_OW 70
69318: ST_TO_ADDR
// for j in fac do
69319: LD_ADDR_VAR 0 3
69323: PUSH
69324: LD_VAR 0 6
69328: PUSH
69329: FOR_IN
69330: IFFALSE 69411
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69332: LD_ADDR_VAR 0 7
69336: PUSH
69337: LD_VAR 0 7
69341: PUSH
69342: LD_INT 22
69344: PUSH
69345: LD_VAR 0 5
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: PUSH
69354: LD_INT 91
69356: PUSH
69357: LD_VAR 0 3
69361: PUSH
69362: LD_INT 15
69364: PUSH
69365: EMPTY
69366: LIST
69367: LIST
69368: LIST
69369: PUSH
69370: LD_INT 21
69372: PUSH
69373: LD_INT 2
69375: PUSH
69376: EMPTY
69377: LIST
69378: LIST
69379: PUSH
69380: LD_INT 3
69382: PUSH
69383: LD_INT 24
69385: PUSH
69386: LD_INT 1000
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: PUSH
69393: EMPTY
69394: LIST
69395: LIST
69396: PUSH
69397: EMPTY
69398: LIST
69399: LIST
69400: LIST
69401: LIST
69402: PPUSH
69403: CALL_OW 69
69407: UNION
69408: ST_TO_ADDR
69409: GO 69329
69411: POP
69412: POP
// if not vehs then
69413: LD_VAR 0 7
69417: NOT
69418: IFFALSE 69444
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
69420: LD_ADDR_EXP 80
69424: PUSH
69425: LD_EXP 80
69429: PPUSH
69430: LD_VAR 0 2
69434: PPUSH
69435: EMPTY
69436: PPUSH
69437: CALL_OW 1
69441: ST_TO_ADDR
// continue ;
69442: GO 69102
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69444: LD_ADDR_VAR 0 8
69448: PUSH
69449: LD_EXP 68
69453: PUSH
69454: LD_VAR 0 2
69458: ARRAY
69459: PPUSH
69460: LD_INT 30
69462: PUSH
69463: LD_INT 3
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PPUSH
69470: CALL_OW 72
69474: ST_TO_ADDR
// if tmp then
69475: LD_VAR 0 8
69479: IFFALSE 69582
// begin for j in tmp do
69481: LD_ADDR_VAR 0 3
69485: PUSH
69486: LD_VAR 0 8
69490: PUSH
69491: FOR_IN
69492: IFFALSE 69580
// for k in UnitsInside ( j ) do
69494: LD_ADDR_VAR 0 4
69498: PUSH
69499: LD_VAR 0 3
69503: PPUSH
69504: CALL_OW 313
69508: PUSH
69509: FOR_IN
69510: IFFALSE 69576
// if k then
69512: LD_VAR 0 4
69516: IFFALSE 69574
// if not k in mc_repair_vehicle [ i ] then
69518: LD_VAR 0 4
69522: PUSH
69523: LD_EXP 80
69527: PUSH
69528: LD_VAR 0 2
69532: ARRAY
69533: IN
69534: NOT
69535: IFFALSE 69574
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69537: LD_ADDR_EXP 80
69541: PUSH
69542: LD_EXP 80
69546: PPUSH
69547: LD_VAR 0 2
69551: PPUSH
69552: LD_EXP 80
69556: PUSH
69557: LD_VAR 0 2
69561: ARRAY
69562: PUSH
69563: LD_VAR 0 4
69567: UNION
69568: PPUSH
69569: CALL_OW 1
69573: ST_TO_ADDR
69574: GO 69509
69576: POP
69577: POP
69578: GO 69491
69580: POP
69581: POP
// end ; if not mc_repair_vehicle [ i ] then
69582: LD_EXP 80
69586: PUSH
69587: LD_VAR 0 2
69591: ARRAY
69592: NOT
69593: IFFALSE 69597
// continue ;
69595: GO 69102
// for j in mc_repair_vehicle [ i ] do
69597: LD_ADDR_VAR 0 3
69601: PUSH
69602: LD_EXP 80
69606: PUSH
69607: LD_VAR 0 2
69611: ARRAY
69612: PUSH
69613: FOR_IN
69614: IFFALSE 69780
// begin if GetClass ( j ) <> 3 then
69616: LD_VAR 0 3
69620: PPUSH
69621: CALL_OW 257
69625: PUSH
69626: LD_INT 3
69628: NONEQUAL
69629: IFFALSE 69670
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69631: LD_ADDR_EXP 80
69635: PUSH
69636: LD_EXP 80
69640: PPUSH
69641: LD_VAR 0 2
69645: PPUSH
69646: LD_EXP 80
69650: PUSH
69651: LD_VAR 0 2
69655: ARRAY
69656: PUSH
69657: LD_VAR 0 3
69661: DIFF
69662: PPUSH
69663: CALL_OW 1
69667: ST_TO_ADDR
// continue ;
69668: GO 69613
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69670: LD_VAR 0 3
69674: PPUSH
69675: CALL_OW 311
69679: NOT
69680: PUSH
69681: LD_VAR 0 3
69685: PUSH
69686: LD_EXP 71
69690: PUSH
69691: LD_VAR 0 2
69695: ARRAY
69696: PUSH
69697: LD_INT 1
69699: ARRAY
69700: IN
69701: NOT
69702: AND
69703: PUSH
69704: LD_VAR 0 3
69708: PUSH
69709: LD_EXP 71
69713: PUSH
69714: LD_VAR 0 2
69718: ARRAY
69719: PUSH
69720: LD_INT 2
69722: ARRAY
69723: IN
69724: NOT
69725: AND
69726: IFFALSE 69778
// begin if IsInUnit ( j ) then
69728: LD_VAR 0 3
69732: PPUSH
69733: CALL_OW 310
69737: IFFALSE 69748
// ComExitBuilding ( j ) ;
69739: LD_VAR 0 3
69743: PPUSH
69744: CALL_OW 122
// if not HasTask ( j ) then
69748: LD_VAR 0 3
69752: PPUSH
69753: CALL_OW 314
69757: NOT
69758: IFFALSE 69778
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
69760: LD_VAR 0 3
69764: PPUSH
69765: LD_VAR 0 7
69769: PUSH
69770: LD_INT 1
69772: ARRAY
69773: PPUSH
69774: CALL_OW 189
// end ; end ;
69778: GO 69613
69780: POP
69781: POP
// end ;
69782: GO 69102
69784: POP
69785: POP
// end ;
69786: LD_VAR 0 1
69790: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
69791: LD_INT 0
69793: PPUSH
69794: PPUSH
69795: PPUSH
69796: PPUSH
69797: PPUSH
69798: PPUSH
69799: PPUSH
69800: PPUSH
69801: PPUSH
69802: PPUSH
69803: PPUSH
// if not mc_bases then
69804: LD_EXP 68
69808: NOT
69809: IFFALSE 69813
// exit ;
69811: GO 70615
// for i = 1 to mc_bases do
69813: LD_ADDR_VAR 0 2
69817: PUSH
69818: DOUBLE
69819: LD_INT 1
69821: DEC
69822: ST_TO_ADDR
69823: LD_EXP 68
69827: PUSH
69828: FOR_TO
69829: IFFALSE 70613
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
69831: LD_EXP 96
69835: PUSH
69836: LD_VAR 0 2
69840: ARRAY
69841: NOT
69842: PUSH
69843: LD_EXP 71
69847: PUSH
69848: LD_VAR 0 2
69852: ARRAY
69853: PUSH
69854: LD_INT 1
69856: ARRAY
69857: OR
69858: PUSH
69859: LD_EXP 71
69863: PUSH
69864: LD_VAR 0 2
69868: ARRAY
69869: PUSH
69870: LD_INT 2
69872: ARRAY
69873: OR
69874: PUSH
69875: LD_EXP 94
69879: PUSH
69880: LD_VAR 0 2
69884: ARRAY
69885: PPUSH
69886: LD_INT 1
69888: PPUSH
69889: CALL_OW 325
69893: NOT
69894: OR
69895: PUSH
69896: LD_EXP 91
69900: PUSH
69901: LD_VAR 0 2
69905: ARRAY
69906: OR
69907: IFFALSE 69911
// continue ;
69909: GO 69828
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
69911: LD_ADDR_VAR 0 8
69915: PUSH
69916: LD_EXP 68
69920: PUSH
69921: LD_VAR 0 2
69925: ARRAY
69926: PPUSH
69927: LD_INT 25
69929: PUSH
69930: LD_INT 4
69932: PUSH
69933: EMPTY
69934: LIST
69935: LIST
69936: PUSH
69937: LD_INT 50
69939: PUSH
69940: EMPTY
69941: LIST
69942: PUSH
69943: LD_INT 3
69945: PUSH
69946: LD_INT 60
69948: PUSH
69949: EMPTY
69950: LIST
69951: PUSH
69952: EMPTY
69953: LIST
69954: LIST
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: LIST
69960: PPUSH
69961: CALL_OW 72
69965: PUSH
69966: LD_EXP 72
69970: PUSH
69971: LD_VAR 0 2
69975: ARRAY
69976: DIFF
69977: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69978: LD_ADDR_VAR 0 9
69982: PUSH
69983: LD_EXP 68
69987: PUSH
69988: LD_VAR 0 2
69992: ARRAY
69993: PPUSH
69994: LD_INT 2
69996: PUSH
69997: LD_INT 30
69999: PUSH
70000: LD_INT 0
70002: PUSH
70003: EMPTY
70004: LIST
70005: LIST
70006: PUSH
70007: LD_INT 30
70009: PUSH
70010: LD_INT 1
70012: PUSH
70013: EMPTY
70014: LIST
70015: LIST
70016: PUSH
70017: EMPTY
70018: LIST
70019: LIST
70020: LIST
70021: PPUSH
70022: CALL_OW 72
70026: ST_TO_ADDR
// if not tmp or not dep then
70027: LD_VAR 0 8
70031: NOT
70032: PUSH
70033: LD_VAR 0 9
70037: NOT
70038: OR
70039: IFFALSE 70043
// continue ;
70041: GO 69828
// side := GetSide ( tmp [ 1 ] ) ;
70043: LD_ADDR_VAR 0 11
70047: PUSH
70048: LD_VAR 0 8
70052: PUSH
70053: LD_INT 1
70055: ARRAY
70056: PPUSH
70057: CALL_OW 255
70061: ST_TO_ADDR
// dep := dep [ 1 ] ;
70062: LD_ADDR_VAR 0 9
70066: PUSH
70067: LD_VAR 0 9
70071: PUSH
70072: LD_INT 1
70074: ARRAY
70075: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
70076: LD_ADDR_VAR 0 7
70080: PUSH
70081: LD_EXP 96
70085: PUSH
70086: LD_VAR 0 2
70090: ARRAY
70091: PPUSH
70092: LD_INT 22
70094: PUSH
70095: LD_INT 0
70097: PUSH
70098: EMPTY
70099: LIST
70100: LIST
70101: PUSH
70102: LD_INT 25
70104: PUSH
70105: LD_INT 12
70107: PUSH
70108: EMPTY
70109: LIST
70110: LIST
70111: PUSH
70112: EMPTY
70113: LIST
70114: LIST
70115: PPUSH
70116: CALL_OW 70
70120: PUSH
70121: LD_INT 22
70123: PUSH
70124: LD_INT 0
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PUSH
70131: LD_INT 25
70133: PUSH
70134: LD_INT 12
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: LD_INT 91
70143: PUSH
70144: LD_VAR 0 9
70148: PUSH
70149: LD_INT 20
70151: PUSH
70152: EMPTY
70153: LIST
70154: LIST
70155: LIST
70156: PUSH
70157: EMPTY
70158: LIST
70159: LIST
70160: LIST
70161: PPUSH
70162: CALL_OW 69
70166: UNION
70167: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
70168: LD_ADDR_VAR 0 10
70172: PUSH
70173: LD_EXP 96
70177: PUSH
70178: LD_VAR 0 2
70182: ARRAY
70183: PPUSH
70184: LD_INT 81
70186: PUSH
70187: LD_VAR 0 11
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PPUSH
70196: CALL_OW 70
70200: ST_TO_ADDR
// if not apes or danger_at_area then
70201: LD_VAR 0 7
70205: NOT
70206: PUSH
70207: LD_VAR 0 10
70211: OR
70212: IFFALSE 70262
// begin if mc_taming [ i ] then
70214: LD_EXP 99
70218: PUSH
70219: LD_VAR 0 2
70223: ARRAY
70224: IFFALSE 70260
// begin MC_Reset ( i , 121 ) ;
70226: LD_VAR 0 2
70230: PPUSH
70231: LD_INT 121
70233: PPUSH
70234: CALL 55549 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70238: LD_ADDR_EXP 99
70242: PUSH
70243: LD_EXP 99
70247: PPUSH
70248: LD_VAR 0 2
70252: PPUSH
70253: EMPTY
70254: PPUSH
70255: CALL_OW 1
70259: ST_TO_ADDR
// end ; continue ;
70260: GO 69828
// end ; for j in tmp do
70262: LD_ADDR_VAR 0 3
70266: PUSH
70267: LD_VAR 0 8
70271: PUSH
70272: FOR_IN
70273: IFFALSE 70609
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70275: LD_VAR 0 3
70279: PUSH
70280: LD_EXP 99
70284: PUSH
70285: LD_VAR 0 2
70289: ARRAY
70290: IN
70291: NOT
70292: PUSH
70293: LD_EXP 99
70297: PUSH
70298: LD_VAR 0 2
70302: ARRAY
70303: PUSH
70304: LD_INT 3
70306: LESS
70307: AND
70308: IFFALSE 70366
// begin SetTag ( j , 121 ) ;
70310: LD_VAR 0 3
70314: PPUSH
70315: LD_INT 121
70317: PPUSH
70318: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70322: LD_ADDR_EXP 99
70326: PUSH
70327: LD_EXP 99
70331: PPUSH
70332: LD_VAR 0 2
70336: PUSH
70337: LD_EXP 99
70341: PUSH
70342: LD_VAR 0 2
70346: ARRAY
70347: PUSH
70348: LD_INT 1
70350: PLUS
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: PPUSH
70356: LD_VAR 0 3
70360: PPUSH
70361: CALL 18548 0 3
70365: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70366: LD_VAR 0 3
70370: PUSH
70371: LD_EXP 99
70375: PUSH
70376: LD_VAR 0 2
70380: ARRAY
70381: IN
70382: IFFALSE 70607
// begin if GetClass ( j ) <> 4 then
70384: LD_VAR 0 3
70388: PPUSH
70389: CALL_OW 257
70393: PUSH
70394: LD_INT 4
70396: NONEQUAL
70397: IFFALSE 70450
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70399: LD_ADDR_EXP 99
70403: PUSH
70404: LD_EXP 99
70408: PPUSH
70409: LD_VAR 0 2
70413: PPUSH
70414: LD_EXP 99
70418: PUSH
70419: LD_VAR 0 2
70423: ARRAY
70424: PUSH
70425: LD_VAR 0 3
70429: DIFF
70430: PPUSH
70431: CALL_OW 1
70435: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70436: LD_VAR 0 3
70440: PPUSH
70441: LD_INT 0
70443: PPUSH
70444: CALL_OW 109
// continue ;
70448: GO 70272
// end ; if IsInUnit ( j ) then
70450: LD_VAR 0 3
70454: PPUSH
70455: CALL_OW 310
70459: IFFALSE 70470
// ComExitBuilding ( j ) ;
70461: LD_VAR 0 3
70465: PPUSH
70466: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
70470: LD_ADDR_VAR 0 6
70474: PUSH
70475: LD_VAR 0 7
70479: PPUSH
70480: LD_VAR 0 3
70484: PPUSH
70485: CALL_OW 74
70489: ST_TO_ADDR
// if not ape then
70490: LD_VAR 0 6
70494: NOT
70495: IFFALSE 70499
// break ;
70497: GO 70609
// x := GetX ( ape ) ;
70499: LD_ADDR_VAR 0 4
70503: PUSH
70504: LD_VAR 0 6
70508: PPUSH
70509: CALL_OW 250
70513: ST_TO_ADDR
// y := GetY ( ape ) ;
70514: LD_ADDR_VAR 0 5
70518: PUSH
70519: LD_VAR 0 6
70523: PPUSH
70524: CALL_OW 251
70528: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
70529: LD_VAR 0 4
70533: PPUSH
70534: LD_VAR 0 5
70538: PPUSH
70539: CALL_OW 488
70543: NOT
70544: PUSH
70545: LD_VAR 0 11
70549: PPUSH
70550: LD_VAR 0 4
70554: PPUSH
70555: LD_VAR 0 5
70559: PPUSH
70560: LD_INT 20
70562: PPUSH
70563: CALL 19444 0 4
70567: PUSH
70568: LD_INT 4
70570: ARRAY
70571: OR
70572: IFFALSE 70576
// break ;
70574: GO 70609
// if not HasTask ( j ) then
70576: LD_VAR 0 3
70580: PPUSH
70581: CALL_OW 314
70585: NOT
70586: IFFALSE 70607
// ComTameXY ( j , x , y ) ;
70588: LD_VAR 0 3
70592: PPUSH
70593: LD_VAR 0 4
70597: PPUSH
70598: LD_VAR 0 5
70602: PPUSH
70603: CALL_OW 131
// end ; end ;
70607: GO 70272
70609: POP
70610: POP
// end ;
70611: GO 69828
70613: POP
70614: POP
// end ;
70615: LD_VAR 0 1
70619: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70620: LD_INT 0
70622: PPUSH
70623: PPUSH
70624: PPUSH
70625: PPUSH
70626: PPUSH
70627: PPUSH
70628: PPUSH
70629: PPUSH
// if not mc_bases then
70630: LD_EXP 68
70634: NOT
70635: IFFALSE 70639
// exit ;
70637: GO 71265
// for i = 1 to mc_bases do
70639: LD_ADDR_VAR 0 2
70643: PUSH
70644: DOUBLE
70645: LD_INT 1
70647: DEC
70648: ST_TO_ADDR
70649: LD_EXP 68
70653: PUSH
70654: FOR_TO
70655: IFFALSE 71263
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
70657: LD_EXP 97
70661: PUSH
70662: LD_VAR 0 2
70666: ARRAY
70667: NOT
70668: PUSH
70669: LD_EXP 97
70673: PUSH
70674: LD_VAR 0 2
70678: ARRAY
70679: PPUSH
70680: LD_INT 25
70682: PUSH
70683: LD_INT 12
70685: PUSH
70686: EMPTY
70687: LIST
70688: LIST
70689: PPUSH
70690: CALL_OW 72
70694: NOT
70695: OR
70696: IFFALSE 70700
// continue ;
70698: GO 70654
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
70700: LD_ADDR_VAR 0 5
70704: PUSH
70705: LD_EXP 97
70709: PUSH
70710: LD_VAR 0 2
70714: ARRAY
70715: PUSH
70716: LD_INT 1
70718: ARRAY
70719: PPUSH
70720: CALL_OW 255
70724: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
70725: LD_VAR 0 5
70729: PPUSH
70730: LD_INT 2
70732: PPUSH
70733: CALL_OW 325
70737: IFFALSE 70990
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70739: LD_ADDR_VAR 0 4
70743: PUSH
70744: LD_EXP 97
70748: PUSH
70749: LD_VAR 0 2
70753: ARRAY
70754: PPUSH
70755: LD_INT 25
70757: PUSH
70758: LD_INT 16
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PPUSH
70765: CALL_OW 72
70769: ST_TO_ADDR
// if tmp < 6 then
70770: LD_VAR 0 4
70774: PUSH
70775: LD_INT 6
70777: LESS
70778: IFFALSE 70990
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70780: LD_ADDR_VAR 0 6
70784: PUSH
70785: LD_EXP 68
70789: PUSH
70790: LD_VAR 0 2
70794: ARRAY
70795: PPUSH
70796: LD_INT 2
70798: PUSH
70799: LD_INT 30
70801: PUSH
70802: LD_INT 0
70804: PUSH
70805: EMPTY
70806: LIST
70807: LIST
70808: PUSH
70809: LD_INT 30
70811: PUSH
70812: LD_INT 1
70814: PUSH
70815: EMPTY
70816: LIST
70817: LIST
70818: PUSH
70819: EMPTY
70820: LIST
70821: LIST
70822: LIST
70823: PPUSH
70824: CALL_OW 72
70828: ST_TO_ADDR
// if depot then
70829: LD_VAR 0 6
70833: IFFALSE 70990
// begin selected := 0 ;
70835: LD_ADDR_VAR 0 7
70839: PUSH
70840: LD_INT 0
70842: ST_TO_ADDR
// for j in depot do
70843: LD_ADDR_VAR 0 3
70847: PUSH
70848: LD_VAR 0 6
70852: PUSH
70853: FOR_IN
70854: IFFALSE 70885
// begin if UnitsInside ( j ) < 6 then
70856: LD_VAR 0 3
70860: PPUSH
70861: CALL_OW 313
70865: PUSH
70866: LD_INT 6
70868: LESS
70869: IFFALSE 70883
// begin selected := j ;
70871: LD_ADDR_VAR 0 7
70875: PUSH
70876: LD_VAR 0 3
70880: ST_TO_ADDR
// break ;
70881: GO 70885
// end ; end ;
70883: GO 70853
70885: POP
70886: POP
// if selected then
70887: LD_VAR 0 7
70891: IFFALSE 70990
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70893: LD_ADDR_VAR 0 3
70897: PUSH
70898: LD_EXP 97
70902: PUSH
70903: LD_VAR 0 2
70907: ARRAY
70908: PPUSH
70909: LD_INT 25
70911: PUSH
70912: LD_INT 12
70914: PUSH
70915: EMPTY
70916: LIST
70917: LIST
70918: PPUSH
70919: CALL_OW 72
70923: PUSH
70924: FOR_IN
70925: IFFALSE 70988
// if not HasTask ( j ) then
70927: LD_VAR 0 3
70931: PPUSH
70932: CALL_OW 314
70936: NOT
70937: IFFALSE 70986
// begin if not IsInUnit ( j ) then
70939: LD_VAR 0 3
70943: PPUSH
70944: CALL_OW 310
70948: NOT
70949: IFFALSE 70965
// ComEnterUnit ( j , selected ) ;
70951: LD_VAR 0 3
70955: PPUSH
70956: LD_VAR 0 7
70960: PPUSH
70961: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
70965: LD_VAR 0 3
70969: PPUSH
70970: LD_INT 16
70972: PPUSH
70973: CALL_OW 183
// AddComExitBuilding ( j ) ;
70977: LD_VAR 0 3
70981: PPUSH
70982: CALL_OW 182
// end ;
70986: GO 70924
70988: POP
70989: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
70990: LD_VAR 0 5
70994: PPUSH
70995: LD_INT 11
70997: PPUSH
70998: CALL_OW 325
71002: IFFALSE 71261
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71004: LD_ADDR_VAR 0 4
71008: PUSH
71009: LD_EXP 97
71013: PUSH
71014: LD_VAR 0 2
71018: ARRAY
71019: PPUSH
71020: LD_INT 25
71022: PUSH
71023: LD_INT 16
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PPUSH
71030: CALL_OW 72
71034: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
71035: LD_VAR 0 4
71039: PUSH
71040: LD_INT 6
71042: GREATEREQUAL
71043: PUSH
71044: LD_VAR 0 5
71048: PPUSH
71049: LD_INT 2
71051: PPUSH
71052: CALL_OW 325
71056: NOT
71057: OR
71058: IFFALSE 71261
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71060: LD_ADDR_VAR 0 8
71064: PUSH
71065: LD_EXP 68
71069: PUSH
71070: LD_VAR 0 2
71074: ARRAY
71075: PPUSH
71076: LD_INT 2
71078: PUSH
71079: LD_INT 30
71081: PUSH
71082: LD_INT 4
71084: PUSH
71085: EMPTY
71086: LIST
71087: LIST
71088: PUSH
71089: LD_INT 30
71091: PUSH
71092: LD_INT 5
71094: PUSH
71095: EMPTY
71096: LIST
71097: LIST
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: LIST
71103: PPUSH
71104: CALL_OW 72
71108: ST_TO_ADDR
// if barracks then
71109: LD_VAR 0 8
71113: IFFALSE 71261
// begin selected := 0 ;
71115: LD_ADDR_VAR 0 7
71119: PUSH
71120: LD_INT 0
71122: ST_TO_ADDR
// for j in barracks do
71123: LD_ADDR_VAR 0 3
71127: PUSH
71128: LD_VAR 0 8
71132: PUSH
71133: FOR_IN
71134: IFFALSE 71165
// begin if UnitsInside ( j ) < 6 then
71136: LD_VAR 0 3
71140: PPUSH
71141: CALL_OW 313
71145: PUSH
71146: LD_INT 6
71148: LESS
71149: IFFALSE 71163
// begin selected := j ;
71151: LD_ADDR_VAR 0 7
71155: PUSH
71156: LD_VAR 0 3
71160: ST_TO_ADDR
// break ;
71161: GO 71165
// end ; end ;
71163: GO 71133
71165: POP
71166: POP
// if selected then
71167: LD_VAR 0 7
71171: IFFALSE 71261
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71173: LD_ADDR_VAR 0 3
71177: PUSH
71178: LD_EXP 97
71182: PUSH
71183: LD_VAR 0 2
71187: ARRAY
71188: PPUSH
71189: LD_INT 25
71191: PUSH
71192: LD_INT 12
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: PPUSH
71199: CALL_OW 72
71203: PUSH
71204: FOR_IN
71205: IFFALSE 71259
// if not IsInUnit ( j ) and not HasTask ( j ) then
71207: LD_VAR 0 3
71211: PPUSH
71212: CALL_OW 310
71216: NOT
71217: PUSH
71218: LD_VAR 0 3
71222: PPUSH
71223: CALL_OW 314
71227: NOT
71228: AND
71229: IFFALSE 71257
// begin ComEnterUnit ( j , selected ) ;
71231: LD_VAR 0 3
71235: PPUSH
71236: LD_VAR 0 7
71240: PPUSH
71241: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
71245: LD_VAR 0 3
71249: PPUSH
71250: LD_INT 15
71252: PPUSH
71253: CALL_OW 183
// end ;
71257: GO 71204
71259: POP
71260: POP
// end ; end ; end ; end ; end ;
71261: GO 70654
71263: POP
71264: POP
// end ;
71265: LD_VAR 0 1
71269: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71270: LD_INT 0
71272: PPUSH
71273: PPUSH
71274: PPUSH
71275: PPUSH
// if not mc_bases then
71276: LD_EXP 68
71280: NOT
71281: IFFALSE 71285
// exit ;
71283: GO 71463
// for i = 1 to mc_bases do
71285: LD_ADDR_VAR 0 2
71289: PUSH
71290: DOUBLE
71291: LD_INT 1
71293: DEC
71294: ST_TO_ADDR
71295: LD_EXP 68
71299: PUSH
71300: FOR_TO
71301: IFFALSE 71461
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71303: LD_ADDR_VAR 0 4
71307: PUSH
71308: LD_EXP 68
71312: PUSH
71313: LD_VAR 0 2
71317: ARRAY
71318: PPUSH
71319: LD_INT 25
71321: PUSH
71322: LD_INT 9
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: PPUSH
71329: CALL_OW 72
71333: ST_TO_ADDR
// if not tmp then
71334: LD_VAR 0 4
71338: NOT
71339: IFFALSE 71343
// continue ;
71341: GO 71300
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71343: LD_EXP 94
71347: PUSH
71348: LD_VAR 0 2
71352: ARRAY
71353: PPUSH
71354: LD_INT 29
71356: PPUSH
71357: CALL_OW 325
71361: NOT
71362: PUSH
71363: LD_EXP 94
71367: PUSH
71368: LD_VAR 0 2
71372: ARRAY
71373: PPUSH
71374: LD_INT 28
71376: PPUSH
71377: CALL_OW 325
71381: NOT
71382: AND
71383: IFFALSE 71387
// continue ;
71385: GO 71300
// for j in tmp do
71387: LD_ADDR_VAR 0 3
71391: PUSH
71392: LD_VAR 0 4
71396: PUSH
71397: FOR_IN
71398: IFFALSE 71457
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71400: LD_VAR 0 3
71404: PUSH
71405: LD_EXP 71
71409: PUSH
71410: LD_VAR 0 2
71414: ARRAY
71415: PUSH
71416: LD_INT 1
71418: ARRAY
71419: IN
71420: NOT
71421: PUSH
71422: LD_VAR 0 3
71426: PUSH
71427: LD_EXP 71
71431: PUSH
71432: LD_VAR 0 2
71436: ARRAY
71437: PUSH
71438: LD_INT 2
71440: ARRAY
71441: IN
71442: NOT
71443: AND
71444: IFFALSE 71455
// ComSpaceTimeShoot ( j ) ;
71446: LD_VAR 0 3
71450: PPUSH
71451: CALL 14545 0 1
71455: GO 71397
71457: POP
71458: POP
// end ;
71459: GO 71300
71461: POP
71462: POP
// end ;
71463: LD_VAR 0 1
71467: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
71468: LD_INT 0
71470: PPUSH
71471: PPUSH
71472: PPUSH
71473: PPUSH
71474: PPUSH
71475: PPUSH
71476: PPUSH
71477: PPUSH
71478: PPUSH
// if not mc_bases then
71479: LD_EXP 68
71483: NOT
71484: IFFALSE 71488
// exit ;
71486: GO 72110
// for i = 1 to mc_bases do
71488: LD_ADDR_VAR 0 2
71492: PUSH
71493: DOUBLE
71494: LD_INT 1
71496: DEC
71497: ST_TO_ADDR
71498: LD_EXP 68
71502: PUSH
71503: FOR_TO
71504: IFFALSE 72108
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
71506: LD_EXP 103
71510: PUSH
71511: LD_VAR 0 2
71515: ARRAY
71516: NOT
71517: PUSH
71518: LD_INT 38
71520: PPUSH
71521: LD_EXP 94
71525: PUSH
71526: LD_VAR 0 2
71530: ARRAY
71531: PPUSH
71532: CALL_OW 321
71536: PUSH
71537: LD_INT 2
71539: NONEQUAL
71540: OR
71541: IFFALSE 71545
// continue ;
71543: GO 71503
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71545: LD_ADDR_VAR 0 8
71549: PUSH
71550: LD_EXP 68
71554: PUSH
71555: LD_VAR 0 2
71559: ARRAY
71560: PPUSH
71561: LD_INT 30
71563: PUSH
71564: LD_INT 34
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: PPUSH
71571: CALL_OW 72
71575: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71576: LD_ADDR_VAR 0 9
71580: PUSH
71581: LD_EXP 68
71585: PUSH
71586: LD_VAR 0 2
71590: ARRAY
71591: PPUSH
71592: LD_INT 25
71594: PUSH
71595: LD_INT 4
71597: PUSH
71598: EMPTY
71599: LIST
71600: LIST
71601: PPUSH
71602: CALL_OW 72
71606: PPUSH
71607: LD_INT 0
71609: PPUSH
71610: CALL 47442 0 2
71614: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71615: LD_VAR 0 9
71619: NOT
71620: PUSH
71621: LD_VAR 0 8
71625: NOT
71626: OR
71627: PUSH
71628: LD_EXP 68
71632: PUSH
71633: LD_VAR 0 2
71637: ARRAY
71638: PPUSH
71639: LD_INT 124
71641: PPUSH
71642: CALL 47442 0 2
71646: OR
71647: IFFALSE 71651
// continue ;
71649: GO 71503
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71651: LD_EXP 104
71655: PUSH
71656: LD_VAR 0 2
71660: ARRAY
71661: PUSH
71662: LD_EXP 103
71666: PUSH
71667: LD_VAR 0 2
71671: ARRAY
71672: LESS
71673: PUSH
71674: LD_EXP 104
71678: PUSH
71679: LD_VAR 0 2
71683: ARRAY
71684: PUSH
71685: LD_VAR 0 8
71689: LESS
71690: AND
71691: IFFALSE 72106
// begin tmp := sci [ 1 ] ;
71693: LD_ADDR_VAR 0 7
71697: PUSH
71698: LD_VAR 0 9
71702: PUSH
71703: LD_INT 1
71705: ARRAY
71706: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
71707: LD_VAR 0 7
71711: PPUSH
71712: LD_INT 124
71714: PPUSH
71715: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
71719: LD_ADDR_VAR 0 3
71723: PUSH
71724: DOUBLE
71725: LD_EXP 103
71729: PUSH
71730: LD_VAR 0 2
71734: ARRAY
71735: INC
71736: ST_TO_ADDR
71737: LD_EXP 103
71741: PUSH
71742: LD_VAR 0 2
71746: ARRAY
71747: PUSH
71748: FOR_DOWNTO
71749: IFFALSE 72092
// begin if IsInUnit ( tmp ) then
71751: LD_VAR 0 7
71755: PPUSH
71756: CALL_OW 310
71760: IFFALSE 71771
// ComExitBuilding ( tmp ) ;
71762: LD_VAR 0 7
71766: PPUSH
71767: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
71771: LD_INT 35
71773: PPUSH
71774: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
71778: LD_VAR 0 7
71782: PPUSH
71783: CALL_OW 310
71787: NOT
71788: PUSH
71789: LD_VAR 0 7
71793: PPUSH
71794: CALL_OW 314
71798: NOT
71799: AND
71800: IFFALSE 71771
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
71802: LD_ADDR_VAR 0 6
71806: PUSH
71807: LD_VAR 0 7
71811: PPUSH
71812: CALL_OW 250
71816: PUSH
71817: LD_VAR 0 7
71821: PPUSH
71822: CALL_OW 251
71826: PUSH
71827: EMPTY
71828: LIST
71829: LIST
71830: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71831: LD_INT 35
71833: PPUSH
71834: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
71838: LD_ADDR_VAR 0 4
71842: PUSH
71843: LD_EXP 103
71847: PUSH
71848: LD_VAR 0 2
71852: ARRAY
71853: PUSH
71854: LD_VAR 0 3
71858: ARRAY
71859: PUSH
71860: LD_INT 1
71862: ARRAY
71863: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
71864: LD_ADDR_VAR 0 5
71868: PUSH
71869: LD_EXP 103
71873: PUSH
71874: LD_VAR 0 2
71878: ARRAY
71879: PUSH
71880: LD_VAR 0 3
71884: ARRAY
71885: PUSH
71886: LD_INT 2
71888: ARRAY
71889: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
71890: LD_VAR 0 7
71894: PPUSH
71895: LD_INT 10
71897: PPUSH
71898: CALL 21141 0 2
71902: PUSH
71903: LD_INT 4
71905: ARRAY
71906: IFFALSE 71944
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
71908: LD_VAR 0 7
71912: PPUSH
71913: LD_VAR 0 6
71917: PUSH
71918: LD_INT 1
71920: ARRAY
71921: PPUSH
71922: LD_VAR 0 6
71926: PUSH
71927: LD_INT 2
71929: ARRAY
71930: PPUSH
71931: CALL_OW 111
// wait ( 0 0$10 ) ;
71935: LD_INT 350
71937: PPUSH
71938: CALL_OW 67
// end else
71942: GO 71970
// begin ComMoveXY ( tmp , x , y ) ;
71944: LD_VAR 0 7
71948: PPUSH
71949: LD_VAR 0 4
71953: PPUSH
71954: LD_VAR 0 5
71958: PPUSH
71959: CALL_OW 111
// wait ( 0 0$3 ) ;
71963: LD_INT 105
71965: PPUSH
71966: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
71970: LD_VAR 0 7
71974: PPUSH
71975: LD_VAR 0 4
71979: PPUSH
71980: LD_VAR 0 5
71984: PPUSH
71985: CALL_OW 307
71989: IFFALSE 71831
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
71991: LD_VAR 0 7
71995: PPUSH
71996: LD_VAR 0 4
72000: PPUSH
72001: LD_VAR 0 5
72005: PPUSH
72006: LD_VAR 0 8
72010: PUSH
72011: LD_VAR 0 3
72015: ARRAY
72016: PPUSH
72017: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
72021: LD_INT 35
72023: PPUSH
72024: CALL_OW 67
// until not HasTask ( tmp ) ;
72028: LD_VAR 0 7
72032: PPUSH
72033: CALL_OW 314
72037: NOT
72038: IFFALSE 72021
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
72040: LD_ADDR_EXP 104
72044: PUSH
72045: LD_EXP 104
72049: PPUSH
72050: LD_VAR 0 2
72054: PUSH
72055: LD_EXP 104
72059: PUSH
72060: LD_VAR 0 2
72064: ARRAY
72065: PUSH
72066: LD_INT 1
72068: PLUS
72069: PUSH
72070: EMPTY
72071: LIST
72072: LIST
72073: PPUSH
72074: LD_VAR 0 8
72078: PUSH
72079: LD_VAR 0 3
72083: ARRAY
72084: PPUSH
72085: CALL 18548 0 3
72089: ST_TO_ADDR
// end ;
72090: GO 71748
72092: POP
72093: POP
// MC_Reset ( i , 124 ) ;
72094: LD_VAR 0 2
72098: PPUSH
72099: LD_INT 124
72101: PPUSH
72102: CALL 55549 0 2
// end ; end ;
72106: GO 71503
72108: POP
72109: POP
// end ;
72110: LD_VAR 0 1
72114: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
72115: LD_INT 0
72117: PPUSH
72118: PPUSH
72119: PPUSH
// if not mc_bases then
72120: LD_EXP 68
72124: NOT
72125: IFFALSE 72129
// exit ;
72127: GO 72735
// for i = 1 to mc_bases do
72129: LD_ADDR_VAR 0 2
72133: PUSH
72134: DOUBLE
72135: LD_INT 1
72137: DEC
72138: ST_TO_ADDR
72139: LD_EXP 68
72143: PUSH
72144: FOR_TO
72145: IFFALSE 72733
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
72147: LD_ADDR_VAR 0 3
72151: PUSH
72152: LD_EXP 68
72156: PUSH
72157: LD_VAR 0 2
72161: ARRAY
72162: PPUSH
72163: LD_INT 25
72165: PUSH
72166: LD_INT 4
72168: PUSH
72169: EMPTY
72170: LIST
72171: LIST
72172: PPUSH
72173: CALL_OW 72
72177: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
72178: LD_VAR 0 3
72182: NOT
72183: PUSH
72184: LD_EXP 105
72188: PUSH
72189: LD_VAR 0 2
72193: ARRAY
72194: NOT
72195: OR
72196: PUSH
72197: LD_EXP 68
72201: PUSH
72202: LD_VAR 0 2
72206: ARRAY
72207: PPUSH
72208: LD_INT 2
72210: PUSH
72211: LD_INT 30
72213: PUSH
72214: LD_INT 0
72216: PUSH
72217: EMPTY
72218: LIST
72219: LIST
72220: PUSH
72221: LD_INT 30
72223: PUSH
72224: LD_INT 1
72226: PUSH
72227: EMPTY
72228: LIST
72229: LIST
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: LIST
72235: PPUSH
72236: CALL_OW 72
72240: NOT
72241: OR
72242: IFFALSE 72292
// begin if mc_deposits_finder [ i ] then
72244: LD_EXP 106
72248: PUSH
72249: LD_VAR 0 2
72253: ARRAY
72254: IFFALSE 72290
// begin MC_Reset ( i , 125 ) ;
72256: LD_VAR 0 2
72260: PPUSH
72261: LD_INT 125
72263: PPUSH
72264: CALL 55549 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72268: LD_ADDR_EXP 106
72272: PUSH
72273: LD_EXP 106
72277: PPUSH
72278: LD_VAR 0 2
72282: PPUSH
72283: EMPTY
72284: PPUSH
72285: CALL_OW 1
72289: ST_TO_ADDR
// end ; continue ;
72290: GO 72144
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72292: LD_EXP 105
72296: PUSH
72297: LD_VAR 0 2
72301: ARRAY
72302: PUSH
72303: LD_INT 1
72305: ARRAY
72306: PUSH
72307: LD_INT 3
72309: ARRAY
72310: PUSH
72311: LD_INT 1
72313: EQUAL
72314: PUSH
72315: LD_INT 20
72317: PPUSH
72318: LD_EXP 94
72322: PUSH
72323: LD_VAR 0 2
72327: ARRAY
72328: PPUSH
72329: CALL_OW 321
72333: PUSH
72334: LD_INT 2
72336: NONEQUAL
72337: AND
72338: IFFALSE 72388
// begin if mc_deposits_finder [ i ] then
72340: LD_EXP 106
72344: PUSH
72345: LD_VAR 0 2
72349: ARRAY
72350: IFFALSE 72386
// begin MC_Reset ( i , 125 ) ;
72352: LD_VAR 0 2
72356: PPUSH
72357: LD_INT 125
72359: PPUSH
72360: CALL 55549 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72364: LD_ADDR_EXP 106
72368: PUSH
72369: LD_EXP 106
72373: PPUSH
72374: LD_VAR 0 2
72378: PPUSH
72379: EMPTY
72380: PPUSH
72381: CALL_OW 1
72385: ST_TO_ADDR
// end ; continue ;
72386: GO 72144
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72388: LD_EXP 105
72392: PUSH
72393: LD_VAR 0 2
72397: ARRAY
72398: PUSH
72399: LD_INT 1
72401: ARRAY
72402: PUSH
72403: LD_INT 1
72405: ARRAY
72406: PPUSH
72407: LD_EXP 105
72411: PUSH
72412: LD_VAR 0 2
72416: ARRAY
72417: PUSH
72418: LD_INT 1
72420: ARRAY
72421: PUSH
72422: LD_INT 2
72424: ARRAY
72425: PPUSH
72426: LD_EXP 94
72430: PUSH
72431: LD_VAR 0 2
72435: ARRAY
72436: PPUSH
72437: CALL_OW 440
72441: IFFALSE 72484
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
72443: LD_ADDR_EXP 105
72447: PUSH
72448: LD_EXP 105
72452: PPUSH
72453: LD_VAR 0 2
72457: PPUSH
72458: LD_EXP 105
72462: PUSH
72463: LD_VAR 0 2
72467: ARRAY
72468: PPUSH
72469: LD_INT 1
72471: PPUSH
72472: CALL_OW 3
72476: PPUSH
72477: CALL_OW 1
72481: ST_TO_ADDR
72482: GO 72731
// begin if not mc_deposits_finder [ i ] then
72484: LD_EXP 106
72488: PUSH
72489: LD_VAR 0 2
72493: ARRAY
72494: NOT
72495: IFFALSE 72547
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
72497: LD_ADDR_EXP 106
72501: PUSH
72502: LD_EXP 106
72506: PPUSH
72507: LD_VAR 0 2
72511: PPUSH
72512: LD_VAR 0 3
72516: PUSH
72517: LD_INT 1
72519: ARRAY
72520: PUSH
72521: EMPTY
72522: LIST
72523: PPUSH
72524: CALL_OW 1
72528: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
72529: LD_VAR 0 3
72533: PUSH
72534: LD_INT 1
72536: ARRAY
72537: PPUSH
72538: LD_INT 125
72540: PPUSH
72541: CALL_OW 109
// end else
72545: GO 72731
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72547: LD_EXP 106
72551: PUSH
72552: LD_VAR 0 2
72556: ARRAY
72557: PUSH
72558: LD_INT 1
72560: ARRAY
72561: PPUSH
72562: CALL_OW 310
72566: IFFALSE 72589
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72568: LD_EXP 106
72572: PUSH
72573: LD_VAR 0 2
72577: ARRAY
72578: PUSH
72579: LD_INT 1
72581: ARRAY
72582: PPUSH
72583: CALL_OW 122
72587: GO 72731
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72589: LD_EXP 106
72593: PUSH
72594: LD_VAR 0 2
72598: ARRAY
72599: PUSH
72600: LD_INT 1
72602: ARRAY
72603: PPUSH
72604: CALL_OW 314
72608: NOT
72609: PUSH
72610: LD_EXP 106
72614: PUSH
72615: LD_VAR 0 2
72619: ARRAY
72620: PUSH
72621: LD_INT 1
72623: ARRAY
72624: PPUSH
72625: LD_EXP 105
72629: PUSH
72630: LD_VAR 0 2
72634: ARRAY
72635: PUSH
72636: LD_INT 1
72638: ARRAY
72639: PUSH
72640: LD_INT 1
72642: ARRAY
72643: PPUSH
72644: LD_EXP 105
72648: PUSH
72649: LD_VAR 0 2
72653: ARRAY
72654: PUSH
72655: LD_INT 1
72657: ARRAY
72658: PUSH
72659: LD_INT 2
72661: ARRAY
72662: PPUSH
72663: CALL_OW 297
72667: PUSH
72668: LD_INT 6
72670: GREATER
72671: AND
72672: IFFALSE 72731
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
72674: LD_EXP 106
72678: PUSH
72679: LD_VAR 0 2
72683: ARRAY
72684: PUSH
72685: LD_INT 1
72687: ARRAY
72688: PPUSH
72689: LD_EXP 105
72693: PUSH
72694: LD_VAR 0 2
72698: ARRAY
72699: PUSH
72700: LD_INT 1
72702: ARRAY
72703: PUSH
72704: LD_INT 1
72706: ARRAY
72707: PPUSH
72708: LD_EXP 105
72712: PUSH
72713: LD_VAR 0 2
72717: ARRAY
72718: PUSH
72719: LD_INT 1
72721: ARRAY
72722: PUSH
72723: LD_INT 2
72725: ARRAY
72726: PPUSH
72727: CALL_OW 111
// end ; end ; end ;
72731: GO 72144
72733: POP
72734: POP
// end ;
72735: LD_VAR 0 1
72739: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
72740: LD_INT 0
72742: PPUSH
72743: PPUSH
72744: PPUSH
72745: PPUSH
72746: PPUSH
72747: PPUSH
72748: PPUSH
72749: PPUSH
72750: PPUSH
72751: PPUSH
72752: PPUSH
// if not mc_bases then
72753: LD_EXP 68
72757: NOT
72758: IFFALSE 72762
// exit ;
72760: GO 73702
// for i = 1 to mc_bases do
72762: LD_ADDR_VAR 0 2
72766: PUSH
72767: DOUBLE
72768: LD_INT 1
72770: DEC
72771: ST_TO_ADDR
72772: LD_EXP 68
72776: PUSH
72777: FOR_TO
72778: IFFALSE 73700
// begin if not mc_bases [ i ] or mc_scan [ i ] then
72780: LD_EXP 68
72784: PUSH
72785: LD_VAR 0 2
72789: ARRAY
72790: NOT
72791: PUSH
72792: LD_EXP 91
72796: PUSH
72797: LD_VAR 0 2
72801: ARRAY
72802: OR
72803: IFFALSE 72807
// continue ;
72805: GO 72777
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
72807: LD_ADDR_VAR 0 7
72811: PUSH
72812: LD_EXP 68
72816: PUSH
72817: LD_VAR 0 2
72821: ARRAY
72822: PUSH
72823: LD_INT 1
72825: ARRAY
72826: PPUSH
72827: CALL_OW 248
72831: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
72832: LD_VAR 0 7
72836: PUSH
72837: LD_INT 3
72839: EQUAL
72840: PUSH
72841: LD_EXP 87
72845: PUSH
72846: LD_VAR 0 2
72850: ARRAY
72851: PUSH
72852: LD_EXP 90
72856: PUSH
72857: LD_VAR 0 2
72861: ARRAY
72862: UNION
72863: PPUSH
72864: LD_INT 33
72866: PUSH
72867: LD_INT 2
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PPUSH
72874: CALL_OW 72
72878: NOT
72879: OR
72880: IFFALSE 72884
// continue ;
72882: GO 72777
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
72884: LD_ADDR_VAR 0 9
72888: PUSH
72889: LD_EXP 68
72893: PUSH
72894: LD_VAR 0 2
72898: ARRAY
72899: PPUSH
72900: LD_INT 30
72902: PUSH
72903: LD_INT 36
72905: PUSH
72906: EMPTY
72907: LIST
72908: LIST
72909: PPUSH
72910: CALL_OW 72
72914: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
72915: LD_ADDR_VAR 0 10
72919: PUSH
72920: LD_EXP 87
72924: PUSH
72925: LD_VAR 0 2
72929: ARRAY
72930: PPUSH
72931: LD_INT 34
72933: PUSH
72934: LD_INT 31
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: PPUSH
72941: CALL_OW 72
72945: ST_TO_ADDR
// if not cts and not mcts then
72946: LD_VAR 0 9
72950: NOT
72951: PUSH
72952: LD_VAR 0 10
72956: NOT
72957: AND
72958: IFFALSE 72962
// continue ;
72960: GO 72777
// x := cts ;
72962: LD_ADDR_VAR 0 11
72966: PUSH
72967: LD_VAR 0 9
72971: ST_TO_ADDR
// if not x then
72972: LD_VAR 0 11
72976: NOT
72977: IFFALSE 72989
// x := mcts ;
72979: LD_ADDR_VAR 0 11
72983: PUSH
72984: LD_VAR 0 10
72988: ST_TO_ADDR
// if not x then
72989: LD_VAR 0 11
72993: NOT
72994: IFFALSE 72998
// continue ;
72996: GO 72777
// if mc_remote_driver [ i ] then
72998: LD_EXP 108
73002: PUSH
73003: LD_VAR 0 2
73007: ARRAY
73008: IFFALSE 73395
// for j in mc_remote_driver [ i ] do
73010: LD_ADDR_VAR 0 3
73014: PUSH
73015: LD_EXP 108
73019: PUSH
73020: LD_VAR 0 2
73024: ARRAY
73025: PUSH
73026: FOR_IN
73027: IFFALSE 73393
// begin if GetClass ( j ) <> 3 then
73029: LD_VAR 0 3
73033: PPUSH
73034: CALL_OW 257
73038: PUSH
73039: LD_INT 3
73041: NONEQUAL
73042: IFFALSE 73095
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
73044: LD_ADDR_EXP 108
73048: PUSH
73049: LD_EXP 108
73053: PPUSH
73054: LD_VAR 0 2
73058: PPUSH
73059: LD_EXP 108
73063: PUSH
73064: LD_VAR 0 2
73068: ARRAY
73069: PUSH
73070: LD_VAR 0 3
73074: DIFF
73075: PPUSH
73076: CALL_OW 1
73080: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73081: LD_VAR 0 3
73085: PPUSH
73086: LD_INT 0
73088: PPUSH
73089: CALL_OW 109
// continue ;
73093: GO 73026
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
73095: LD_EXP 87
73099: PUSH
73100: LD_VAR 0 2
73104: ARRAY
73105: PPUSH
73106: LD_INT 34
73108: PUSH
73109: LD_INT 31
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: LD_INT 58
73118: PUSH
73119: EMPTY
73120: LIST
73121: PUSH
73122: EMPTY
73123: LIST
73124: LIST
73125: PPUSH
73126: CALL_OW 72
73130: PUSH
73131: LD_VAR 0 3
73135: PPUSH
73136: CALL 47530 0 1
73140: NOT
73141: AND
73142: IFFALSE 73213
// begin if IsInUnit ( j ) then
73144: LD_VAR 0 3
73148: PPUSH
73149: CALL_OW 310
73153: IFFALSE 73164
// ComExitBuilding ( j ) ;
73155: LD_VAR 0 3
73159: PPUSH
73160: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
73164: LD_VAR 0 3
73168: PPUSH
73169: LD_EXP 87
73173: PUSH
73174: LD_VAR 0 2
73178: ARRAY
73179: PPUSH
73180: LD_INT 34
73182: PUSH
73183: LD_INT 31
73185: PUSH
73186: EMPTY
73187: LIST
73188: LIST
73189: PUSH
73190: LD_INT 58
73192: PUSH
73193: EMPTY
73194: LIST
73195: PUSH
73196: EMPTY
73197: LIST
73198: LIST
73199: PPUSH
73200: CALL_OW 72
73204: PUSH
73205: LD_INT 1
73207: ARRAY
73208: PPUSH
73209: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
73213: LD_VAR 0 3
73217: PPUSH
73218: CALL_OW 310
73222: NOT
73223: PUSH
73224: LD_VAR 0 3
73228: PPUSH
73229: CALL_OW 310
73233: PPUSH
73234: CALL_OW 266
73238: PUSH
73239: LD_INT 36
73241: NONEQUAL
73242: PUSH
73243: LD_VAR 0 3
73247: PPUSH
73248: CALL 47530 0 1
73252: NOT
73253: AND
73254: OR
73255: IFFALSE 73391
// begin if IsInUnit ( j ) then
73257: LD_VAR 0 3
73261: PPUSH
73262: CALL_OW 310
73266: IFFALSE 73277
// ComExitBuilding ( j ) ;
73268: LD_VAR 0 3
73272: PPUSH
73273: CALL_OW 122
// ct := 0 ;
73277: LD_ADDR_VAR 0 8
73281: PUSH
73282: LD_INT 0
73284: ST_TO_ADDR
// for k in x do
73285: LD_ADDR_VAR 0 4
73289: PUSH
73290: LD_VAR 0 11
73294: PUSH
73295: FOR_IN
73296: IFFALSE 73369
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73298: LD_VAR 0 4
73302: PPUSH
73303: CALL_OW 264
73307: PUSH
73308: LD_INT 31
73310: EQUAL
73311: PUSH
73312: LD_VAR 0 4
73316: PPUSH
73317: CALL_OW 311
73321: NOT
73322: AND
73323: PUSH
73324: LD_VAR 0 4
73328: PPUSH
73329: CALL_OW 266
73333: PUSH
73334: LD_INT 36
73336: EQUAL
73337: PUSH
73338: LD_VAR 0 4
73342: PPUSH
73343: CALL_OW 313
73347: PUSH
73348: LD_INT 3
73350: LESS
73351: AND
73352: OR
73353: IFFALSE 73367
// begin ct := k ;
73355: LD_ADDR_VAR 0 8
73359: PUSH
73360: LD_VAR 0 4
73364: ST_TO_ADDR
// break ;
73365: GO 73369
// end ;
73367: GO 73295
73369: POP
73370: POP
// if ct then
73371: LD_VAR 0 8
73375: IFFALSE 73391
// ComEnterUnit ( j , ct ) ;
73377: LD_VAR 0 3
73381: PPUSH
73382: LD_VAR 0 8
73386: PPUSH
73387: CALL_OW 120
// end ; end ;
73391: GO 73026
73393: POP
73394: POP
// places := 0 ;
73395: LD_ADDR_VAR 0 5
73399: PUSH
73400: LD_INT 0
73402: ST_TO_ADDR
// for j = 1 to x do
73403: LD_ADDR_VAR 0 3
73407: PUSH
73408: DOUBLE
73409: LD_INT 1
73411: DEC
73412: ST_TO_ADDR
73413: LD_VAR 0 11
73417: PUSH
73418: FOR_TO
73419: IFFALSE 73495
// if GetWeapon ( x [ j ] ) = ar_control_tower then
73421: LD_VAR 0 11
73425: PUSH
73426: LD_VAR 0 3
73430: ARRAY
73431: PPUSH
73432: CALL_OW 264
73436: PUSH
73437: LD_INT 31
73439: EQUAL
73440: IFFALSE 73458
// places := places + 1 else
73442: LD_ADDR_VAR 0 5
73446: PUSH
73447: LD_VAR 0 5
73451: PUSH
73452: LD_INT 1
73454: PLUS
73455: ST_TO_ADDR
73456: GO 73493
// if GetBType ( x [ j ] ) = b_control_tower then
73458: LD_VAR 0 11
73462: PUSH
73463: LD_VAR 0 3
73467: ARRAY
73468: PPUSH
73469: CALL_OW 266
73473: PUSH
73474: LD_INT 36
73476: EQUAL
73477: IFFALSE 73493
// places := places + 3 ;
73479: LD_ADDR_VAR 0 5
73483: PUSH
73484: LD_VAR 0 5
73488: PUSH
73489: LD_INT 3
73491: PLUS
73492: ST_TO_ADDR
73493: GO 73418
73495: POP
73496: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
73497: LD_VAR 0 5
73501: PUSH
73502: LD_INT 0
73504: EQUAL
73505: PUSH
73506: LD_VAR 0 5
73510: PUSH
73511: LD_EXP 108
73515: PUSH
73516: LD_VAR 0 2
73520: ARRAY
73521: LESSEQUAL
73522: OR
73523: IFFALSE 73527
// continue ;
73525: GO 72777
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
73527: LD_ADDR_VAR 0 6
73531: PUSH
73532: LD_EXP 68
73536: PUSH
73537: LD_VAR 0 2
73541: ARRAY
73542: PPUSH
73543: LD_INT 25
73545: PUSH
73546: LD_INT 3
73548: PUSH
73549: EMPTY
73550: LIST
73551: LIST
73552: PPUSH
73553: CALL_OW 72
73557: PUSH
73558: LD_EXP 108
73562: PUSH
73563: LD_VAR 0 2
73567: ARRAY
73568: DIFF
73569: PPUSH
73570: LD_INT 3
73572: PPUSH
73573: CALL 48430 0 2
73577: ST_TO_ADDR
// for j in tmp do
73578: LD_ADDR_VAR 0 3
73582: PUSH
73583: LD_VAR 0 6
73587: PUSH
73588: FOR_IN
73589: IFFALSE 73624
// if GetTag ( j ) > 0 then
73591: LD_VAR 0 3
73595: PPUSH
73596: CALL_OW 110
73600: PUSH
73601: LD_INT 0
73603: GREATER
73604: IFFALSE 73622
// tmp := tmp diff j ;
73606: LD_ADDR_VAR 0 6
73610: PUSH
73611: LD_VAR 0 6
73615: PUSH
73616: LD_VAR 0 3
73620: DIFF
73621: ST_TO_ADDR
73622: GO 73588
73624: POP
73625: POP
// if not tmp then
73626: LD_VAR 0 6
73630: NOT
73631: IFFALSE 73635
// continue ;
73633: GO 72777
// if places then
73635: LD_VAR 0 5
73639: IFFALSE 73698
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73641: LD_ADDR_EXP 108
73645: PUSH
73646: LD_EXP 108
73650: PPUSH
73651: LD_VAR 0 2
73655: PPUSH
73656: LD_EXP 108
73660: PUSH
73661: LD_VAR 0 2
73665: ARRAY
73666: PUSH
73667: LD_VAR 0 6
73671: PUSH
73672: LD_INT 1
73674: ARRAY
73675: UNION
73676: PPUSH
73677: CALL_OW 1
73681: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
73682: LD_VAR 0 6
73686: PUSH
73687: LD_INT 1
73689: ARRAY
73690: PPUSH
73691: LD_INT 126
73693: PPUSH
73694: CALL_OW 109
// end ; end ;
73698: GO 72777
73700: POP
73701: POP
// end ;
73702: LD_VAR 0 1
73706: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
73707: LD_INT 0
73709: PPUSH
73710: PPUSH
73711: PPUSH
73712: PPUSH
73713: PPUSH
73714: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
73715: LD_VAR 0 1
73719: NOT
73720: PUSH
73721: LD_VAR 0 2
73725: NOT
73726: OR
73727: PUSH
73728: LD_VAR 0 3
73732: NOT
73733: OR
73734: PUSH
73735: LD_VAR 0 4
73739: PUSH
73740: LD_INT 1
73742: PUSH
73743: LD_INT 2
73745: PUSH
73746: LD_INT 3
73748: PUSH
73749: LD_INT 4
73751: PUSH
73752: LD_INT 5
73754: PUSH
73755: LD_INT 8
73757: PUSH
73758: LD_INT 9
73760: PUSH
73761: LD_INT 15
73763: PUSH
73764: LD_INT 16
73766: PUSH
73767: EMPTY
73768: LIST
73769: LIST
73770: LIST
73771: LIST
73772: LIST
73773: LIST
73774: LIST
73775: LIST
73776: LIST
73777: IN
73778: NOT
73779: OR
73780: IFFALSE 73784
// exit ;
73782: GO 74684
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
73784: LD_ADDR_VAR 0 2
73788: PUSH
73789: LD_VAR 0 2
73793: PPUSH
73794: LD_INT 21
73796: PUSH
73797: LD_INT 3
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 24
73806: PUSH
73807: LD_INT 250
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: PUSH
73814: EMPTY
73815: LIST
73816: LIST
73817: PPUSH
73818: CALL_OW 72
73822: ST_TO_ADDR
// case class of 1 , 15 :
73823: LD_VAR 0 4
73827: PUSH
73828: LD_INT 1
73830: DOUBLE
73831: EQUAL
73832: IFTRUE 73842
73834: LD_INT 15
73836: DOUBLE
73837: EQUAL
73838: IFTRUE 73842
73840: GO 73927
73842: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
73843: LD_ADDR_VAR 0 8
73847: PUSH
73848: LD_VAR 0 2
73852: PPUSH
73853: LD_INT 2
73855: PUSH
73856: LD_INT 30
73858: PUSH
73859: LD_INT 32
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: LD_INT 30
73868: PUSH
73869: LD_INT 31
73871: PUSH
73872: EMPTY
73873: LIST
73874: LIST
73875: PUSH
73876: EMPTY
73877: LIST
73878: LIST
73879: LIST
73880: PPUSH
73881: CALL_OW 72
73885: PUSH
73886: LD_VAR 0 2
73890: PPUSH
73891: LD_INT 2
73893: PUSH
73894: LD_INT 30
73896: PUSH
73897: LD_INT 4
73899: PUSH
73900: EMPTY
73901: LIST
73902: LIST
73903: PUSH
73904: LD_INT 30
73906: PUSH
73907: LD_INT 5
73909: PUSH
73910: EMPTY
73911: LIST
73912: LIST
73913: PUSH
73914: EMPTY
73915: LIST
73916: LIST
73917: LIST
73918: PPUSH
73919: CALL_OW 72
73923: ADD
73924: ST_TO_ADDR
73925: GO 74173
73927: LD_INT 2
73929: DOUBLE
73930: EQUAL
73931: IFTRUE 73941
73933: LD_INT 16
73935: DOUBLE
73936: EQUAL
73937: IFTRUE 73941
73939: GO 73987
73941: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
73942: LD_ADDR_VAR 0 8
73946: PUSH
73947: LD_VAR 0 2
73951: PPUSH
73952: LD_INT 2
73954: PUSH
73955: LD_INT 30
73957: PUSH
73958: LD_INT 0
73960: PUSH
73961: EMPTY
73962: LIST
73963: LIST
73964: PUSH
73965: LD_INT 30
73967: PUSH
73968: LD_INT 1
73970: PUSH
73971: EMPTY
73972: LIST
73973: LIST
73974: PUSH
73975: EMPTY
73976: LIST
73977: LIST
73978: LIST
73979: PPUSH
73980: CALL_OW 72
73984: ST_TO_ADDR
73985: GO 74173
73987: LD_INT 3
73989: DOUBLE
73990: EQUAL
73991: IFTRUE 73995
73993: GO 74041
73995: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
73996: LD_ADDR_VAR 0 8
74000: PUSH
74001: LD_VAR 0 2
74005: PPUSH
74006: LD_INT 2
74008: PUSH
74009: LD_INT 30
74011: PUSH
74012: LD_INT 2
74014: PUSH
74015: EMPTY
74016: LIST
74017: LIST
74018: PUSH
74019: LD_INT 30
74021: PUSH
74022: LD_INT 3
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: LIST
74033: PPUSH
74034: CALL_OW 72
74038: ST_TO_ADDR
74039: GO 74173
74041: LD_INT 4
74043: DOUBLE
74044: EQUAL
74045: IFTRUE 74049
74047: GO 74106
74049: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
74050: LD_ADDR_VAR 0 8
74054: PUSH
74055: LD_VAR 0 2
74059: PPUSH
74060: LD_INT 2
74062: PUSH
74063: LD_INT 30
74065: PUSH
74066: LD_INT 6
74068: PUSH
74069: EMPTY
74070: LIST
74071: LIST
74072: PUSH
74073: LD_INT 30
74075: PUSH
74076: LD_INT 7
74078: PUSH
74079: EMPTY
74080: LIST
74081: LIST
74082: PUSH
74083: LD_INT 30
74085: PUSH
74086: LD_INT 8
74088: PUSH
74089: EMPTY
74090: LIST
74091: LIST
74092: PUSH
74093: EMPTY
74094: LIST
74095: LIST
74096: LIST
74097: LIST
74098: PPUSH
74099: CALL_OW 72
74103: ST_TO_ADDR
74104: GO 74173
74106: LD_INT 5
74108: DOUBLE
74109: EQUAL
74110: IFTRUE 74126
74112: LD_INT 8
74114: DOUBLE
74115: EQUAL
74116: IFTRUE 74126
74118: LD_INT 9
74120: DOUBLE
74121: EQUAL
74122: IFTRUE 74126
74124: GO 74172
74126: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
74127: LD_ADDR_VAR 0 8
74131: PUSH
74132: LD_VAR 0 2
74136: PPUSH
74137: LD_INT 2
74139: PUSH
74140: LD_INT 30
74142: PUSH
74143: LD_INT 4
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: PUSH
74150: LD_INT 30
74152: PUSH
74153: LD_INT 5
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: PUSH
74160: EMPTY
74161: LIST
74162: LIST
74163: LIST
74164: PPUSH
74165: CALL_OW 72
74169: ST_TO_ADDR
74170: GO 74173
74172: POP
// if not tmp then
74173: LD_VAR 0 8
74177: NOT
74178: IFFALSE 74182
// exit ;
74180: GO 74684
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
74182: LD_VAR 0 4
74186: PUSH
74187: LD_INT 1
74189: PUSH
74190: LD_INT 15
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: IN
74197: PUSH
74198: LD_EXP 77
74202: PUSH
74203: LD_VAR 0 1
74207: ARRAY
74208: AND
74209: IFFALSE 74365
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
74211: LD_ADDR_VAR 0 9
74215: PUSH
74216: LD_EXP 77
74220: PUSH
74221: LD_VAR 0 1
74225: ARRAY
74226: PUSH
74227: LD_INT 1
74229: ARRAY
74230: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74231: LD_VAR 0 9
74235: PUSH
74236: LD_EXP 78
74240: PUSH
74241: LD_VAR 0 1
74245: ARRAY
74246: IN
74247: NOT
74248: IFFALSE 74363
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74250: LD_ADDR_EXP 78
74254: PUSH
74255: LD_EXP 78
74259: PPUSH
74260: LD_VAR 0 1
74264: PUSH
74265: LD_EXP 78
74269: PUSH
74270: LD_VAR 0 1
74274: ARRAY
74275: PUSH
74276: LD_INT 1
74278: PLUS
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PPUSH
74284: LD_VAR 0 9
74288: PPUSH
74289: CALL 18548 0 3
74293: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74294: LD_ADDR_EXP 77
74298: PUSH
74299: LD_EXP 77
74303: PPUSH
74304: LD_VAR 0 1
74308: PPUSH
74309: LD_EXP 77
74313: PUSH
74314: LD_VAR 0 1
74318: ARRAY
74319: PUSH
74320: LD_VAR 0 9
74324: DIFF
74325: PPUSH
74326: CALL_OW 1
74330: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74331: LD_VAR 0 3
74335: PPUSH
74336: LD_EXP 78
74340: PUSH
74341: LD_VAR 0 1
74345: ARRAY
74346: PUSH
74347: LD_EXP 78
74351: PUSH
74352: LD_VAR 0 1
74356: ARRAY
74357: ARRAY
74358: PPUSH
74359: CALL_OW 120
// end ; exit ;
74363: GO 74684
// end ; if tmp > 1 then
74365: LD_VAR 0 8
74369: PUSH
74370: LD_INT 1
74372: GREATER
74373: IFFALSE 74477
// for i = 2 to tmp do
74375: LD_ADDR_VAR 0 6
74379: PUSH
74380: DOUBLE
74381: LD_INT 2
74383: DEC
74384: ST_TO_ADDR
74385: LD_VAR 0 8
74389: PUSH
74390: FOR_TO
74391: IFFALSE 74475
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74393: LD_VAR 0 8
74397: PUSH
74398: LD_VAR 0 6
74402: ARRAY
74403: PPUSH
74404: CALL_OW 461
74408: PUSH
74409: LD_INT 6
74411: EQUAL
74412: IFFALSE 74473
// begin x := tmp [ i ] ;
74414: LD_ADDR_VAR 0 9
74418: PUSH
74419: LD_VAR 0 8
74423: PUSH
74424: LD_VAR 0 6
74428: ARRAY
74429: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
74430: LD_ADDR_VAR 0 8
74434: PUSH
74435: LD_VAR 0 8
74439: PPUSH
74440: LD_VAR 0 6
74444: PPUSH
74445: CALL_OW 3
74449: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
74450: LD_ADDR_VAR 0 8
74454: PUSH
74455: LD_VAR 0 8
74459: PPUSH
74460: LD_INT 1
74462: PPUSH
74463: LD_VAR 0 9
74467: PPUSH
74468: CALL_OW 2
74472: ST_TO_ADDR
// end ;
74473: GO 74390
74475: POP
74476: POP
// for i in tmp do
74477: LD_ADDR_VAR 0 6
74481: PUSH
74482: LD_VAR 0 8
74486: PUSH
74487: FOR_IN
74488: IFFALSE 74557
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
74490: LD_VAR 0 6
74494: PPUSH
74495: CALL_OW 313
74499: PUSH
74500: LD_INT 6
74502: LESS
74503: PUSH
74504: LD_VAR 0 6
74508: PPUSH
74509: CALL_OW 266
74513: PUSH
74514: LD_INT 31
74516: PUSH
74517: LD_INT 32
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: IN
74524: NOT
74525: AND
74526: PUSH
74527: LD_VAR 0 6
74531: PPUSH
74532: CALL_OW 313
74536: PUSH
74537: LD_INT 0
74539: EQUAL
74540: OR
74541: IFFALSE 74555
// begin j := i ;
74543: LD_ADDR_VAR 0 7
74547: PUSH
74548: LD_VAR 0 6
74552: ST_TO_ADDR
// break ;
74553: GO 74557
// end ; end ;
74555: GO 74487
74557: POP
74558: POP
// if j then
74559: LD_VAR 0 7
74563: IFFALSE 74581
// ComEnterUnit ( unit , j ) else
74565: LD_VAR 0 3
74569: PPUSH
74570: LD_VAR 0 7
74574: PPUSH
74575: CALL_OW 120
74579: GO 74684
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74581: LD_ADDR_VAR 0 10
74585: PUSH
74586: LD_VAR 0 2
74590: PPUSH
74591: LD_INT 2
74593: PUSH
74594: LD_INT 30
74596: PUSH
74597: LD_INT 0
74599: PUSH
74600: EMPTY
74601: LIST
74602: LIST
74603: PUSH
74604: LD_INT 30
74606: PUSH
74607: LD_INT 1
74609: PUSH
74610: EMPTY
74611: LIST
74612: LIST
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: LIST
74618: PPUSH
74619: CALL_OW 72
74623: ST_TO_ADDR
// if depot then
74624: LD_VAR 0 10
74628: IFFALSE 74684
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74630: LD_ADDR_VAR 0 10
74634: PUSH
74635: LD_VAR 0 10
74639: PPUSH
74640: LD_VAR 0 3
74644: PPUSH
74645: CALL_OW 74
74649: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74650: LD_VAR 0 3
74654: PPUSH
74655: LD_VAR 0 10
74659: PPUSH
74660: CALL_OW 296
74664: PUSH
74665: LD_INT 10
74667: GREATER
74668: IFFALSE 74684
// ComStandNearbyBuilding ( unit , depot ) ;
74670: LD_VAR 0 3
74674: PPUSH
74675: LD_VAR 0 10
74679: PPUSH
74680: CALL 15162 0 2
// end ; end ; end ;
74684: LD_VAR 0 5
74688: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74689: LD_INT 0
74691: PPUSH
74692: PPUSH
74693: PPUSH
74694: PPUSH
// if not mc_bases then
74695: LD_EXP 68
74699: NOT
74700: IFFALSE 74704
// exit ;
74702: GO 74943
// for i = 1 to mc_bases do
74704: LD_ADDR_VAR 0 2
74708: PUSH
74709: DOUBLE
74710: LD_INT 1
74712: DEC
74713: ST_TO_ADDR
74714: LD_EXP 68
74718: PUSH
74719: FOR_TO
74720: IFFALSE 74941
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
74722: LD_ADDR_VAR 0 4
74726: PUSH
74727: LD_EXP 68
74731: PUSH
74732: LD_VAR 0 2
74736: ARRAY
74737: PPUSH
74738: LD_INT 21
74740: PUSH
74741: LD_INT 1
74743: PUSH
74744: EMPTY
74745: LIST
74746: LIST
74747: PPUSH
74748: CALL_OW 72
74752: PUSH
74753: LD_EXP 97
74757: PUSH
74758: LD_VAR 0 2
74762: ARRAY
74763: UNION
74764: ST_TO_ADDR
// if not tmp then
74765: LD_VAR 0 4
74769: NOT
74770: IFFALSE 74774
// continue ;
74772: GO 74719
// for j in tmp do
74774: LD_ADDR_VAR 0 3
74778: PUSH
74779: LD_VAR 0 4
74783: PUSH
74784: FOR_IN
74785: IFFALSE 74937
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
74787: LD_VAR 0 3
74791: PPUSH
74792: CALL_OW 110
74796: NOT
74797: PUSH
74798: LD_VAR 0 3
74802: PPUSH
74803: CALL_OW 314
74807: NOT
74808: AND
74809: PUSH
74810: LD_VAR 0 3
74814: PPUSH
74815: CALL_OW 311
74819: NOT
74820: AND
74821: PUSH
74822: LD_VAR 0 3
74826: PPUSH
74827: CALL_OW 310
74831: NOT
74832: AND
74833: PUSH
74834: LD_VAR 0 3
74838: PUSH
74839: LD_EXP 71
74843: PUSH
74844: LD_VAR 0 2
74848: ARRAY
74849: PUSH
74850: LD_INT 1
74852: ARRAY
74853: IN
74854: NOT
74855: AND
74856: PUSH
74857: LD_VAR 0 3
74861: PUSH
74862: LD_EXP 71
74866: PUSH
74867: LD_VAR 0 2
74871: ARRAY
74872: PUSH
74873: LD_INT 2
74875: ARRAY
74876: IN
74877: NOT
74878: AND
74879: PUSH
74880: LD_VAR 0 3
74884: PUSH
74885: LD_EXP 80
74889: PUSH
74890: LD_VAR 0 2
74894: ARRAY
74895: IN
74896: NOT
74897: AND
74898: IFFALSE 74935
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
74900: LD_VAR 0 2
74904: PPUSH
74905: LD_EXP 68
74909: PUSH
74910: LD_VAR 0 2
74914: ARRAY
74915: PPUSH
74916: LD_VAR 0 3
74920: PPUSH
74921: LD_VAR 0 3
74925: PPUSH
74926: CALL_OW 257
74930: PPUSH
74931: CALL 73707 0 4
// end ;
74935: GO 74784
74937: POP
74938: POP
// end ;
74939: GO 74719
74941: POP
74942: POP
// end ;
74943: LD_VAR 0 1
74947: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
74948: LD_INT 0
74950: PPUSH
74951: PPUSH
74952: PPUSH
74953: PPUSH
74954: PPUSH
74955: PPUSH
// if not mc_bases [ base ] then
74956: LD_EXP 68
74960: PUSH
74961: LD_VAR 0 1
74965: ARRAY
74966: NOT
74967: IFFALSE 74971
// exit ;
74969: GO 75153
// tmp := [ ] ;
74971: LD_ADDR_VAR 0 6
74975: PUSH
74976: EMPTY
74977: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
74978: LD_ADDR_VAR 0 7
74982: PUSH
74983: LD_VAR 0 3
74987: PPUSH
74988: LD_INT 0
74990: PPUSH
74991: CALL_OW 517
74995: ST_TO_ADDR
// if not list then
74996: LD_VAR 0 7
75000: NOT
75001: IFFALSE 75005
// exit ;
75003: GO 75153
// for i = 1 to amount do
75005: LD_ADDR_VAR 0 5
75009: PUSH
75010: DOUBLE
75011: LD_INT 1
75013: DEC
75014: ST_TO_ADDR
75015: LD_VAR 0 2
75019: PUSH
75020: FOR_TO
75021: IFFALSE 75101
// begin x := rand ( 1 , list [ 1 ] ) ;
75023: LD_ADDR_VAR 0 8
75027: PUSH
75028: LD_INT 1
75030: PPUSH
75031: LD_VAR 0 7
75035: PUSH
75036: LD_INT 1
75038: ARRAY
75039: PPUSH
75040: CALL_OW 12
75044: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
75045: LD_ADDR_VAR 0 6
75049: PUSH
75050: LD_VAR 0 6
75054: PPUSH
75055: LD_VAR 0 5
75059: PPUSH
75060: LD_VAR 0 7
75064: PUSH
75065: LD_INT 1
75067: ARRAY
75068: PUSH
75069: LD_VAR 0 8
75073: ARRAY
75074: PUSH
75075: LD_VAR 0 7
75079: PUSH
75080: LD_INT 2
75082: ARRAY
75083: PUSH
75084: LD_VAR 0 8
75088: ARRAY
75089: PUSH
75090: EMPTY
75091: LIST
75092: LIST
75093: PPUSH
75094: CALL_OW 1
75098: ST_TO_ADDR
// end ;
75099: GO 75020
75101: POP
75102: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
75103: LD_ADDR_EXP 81
75107: PUSH
75108: LD_EXP 81
75112: PPUSH
75113: LD_VAR 0 1
75117: PPUSH
75118: LD_VAR 0 6
75122: PPUSH
75123: CALL_OW 1
75127: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
75128: LD_ADDR_EXP 83
75132: PUSH
75133: LD_EXP 83
75137: PPUSH
75138: LD_VAR 0 1
75142: PPUSH
75143: LD_VAR 0 3
75147: PPUSH
75148: CALL_OW 1
75152: ST_TO_ADDR
// end ;
75153: LD_VAR 0 4
75157: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
75158: LD_INT 0
75160: PPUSH
// if not mc_bases [ base ] then
75161: LD_EXP 68
75165: PUSH
75166: LD_VAR 0 1
75170: ARRAY
75171: NOT
75172: IFFALSE 75176
// exit ;
75174: GO 75201
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
75176: LD_ADDR_EXP 73
75180: PUSH
75181: LD_EXP 73
75185: PPUSH
75186: LD_VAR 0 1
75190: PPUSH
75191: LD_VAR 0 2
75195: PPUSH
75196: CALL_OW 1
75200: ST_TO_ADDR
// end ;
75201: LD_VAR 0 3
75205: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
75206: LD_INT 0
75208: PPUSH
// if not mc_bases [ base ] then
75209: LD_EXP 68
75213: PUSH
75214: LD_VAR 0 1
75218: ARRAY
75219: NOT
75220: IFFALSE 75224
// exit ;
75222: GO 75261
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75224: LD_ADDR_EXP 73
75228: PUSH
75229: LD_EXP 73
75233: PPUSH
75234: LD_VAR 0 1
75238: PPUSH
75239: LD_EXP 73
75243: PUSH
75244: LD_VAR 0 1
75248: ARRAY
75249: PUSH
75250: LD_VAR 0 2
75254: UNION
75255: PPUSH
75256: CALL_OW 1
75260: ST_TO_ADDR
// end ;
75261: LD_VAR 0 3
75265: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75266: LD_INT 0
75268: PPUSH
// if not mc_bases [ base ] then
75269: LD_EXP 68
75273: PUSH
75274: LD_VAR 0 1
75278: ARRAY
75279: NOT
75280: IFFALSE 75284
// exit ;
75282: GO 75309
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75284: LD_ADDR_EXP 89
75288: PUSH
75289: LD_EXP 89
75293: PPUSH
75294: LD_VAR 0 1
75298: PPUSH
75299: LD_VAR 0 2
75303: PPUSH
75304: CALL_OW 1
75308: ST_TO_ADDR
// end ;
75309: LD_VAR 0 3
75313: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75314: LD_INT 0
75316: PPUSH
// if not mc_bases [ base ] then
75317: LD_EXP 68
75321: PUSH
75322: LD_VAR 0 1
75326: ARRAY
75327: NOT
75328: IFFALSE 75332
// exit ;
75330: GO 75369
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75332: LD_ADDR_EXP 89
75336: PUSH
75337: LD_EXP 89
75341: PPUSH
75342: LD_VAR 0 1
75346: PPUSH
75347: LD_EXP 89
75351: PUSH
75352: LD_VAR 0 1
75356: ARRAY
75357: PUSH
75358: LD_VAR 0 2
75362: ADD
75363: PPUSH
75364: CALL_OW 1
75368: ST_TO_ADDR
// end ;
75369: LD_VAR 0 3
75373: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75374: LD_INT 0
75376: PPUSH
// if not mc_bases [ base ] then
75377: LD_EXP 68
75381: PUSH
75382: LD_VAR 0 1
75386: ARRAY
75387: NOT
75388: IFFALSE 75392
// exit ;
75390: GO 75446
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75392: LD_ADDR_EXP 90
75396: PUSH
75397: LD_EXP 90
75401: PPUSH
75402: LD_VAR 0 1
75406: PPUSH
75407: LD_VAR 0 2
75411: PPUSH
75412: CALL_OW 1
75416: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
75417: LD_ADDR_EXP 79
75421: PUSH
75422: LD_EXP 79
75426: PPUSH
75427: LD_VAR 0 1
75431: PPUSH
75432: LD_VAR 0 2
75436: PUSH
75437: LD_INT 0
75439: PLUS
75440: PPUSH
75441: CALL_OW 1
75445: ST_TO_ADDR
// end ;
75446: LD_VAR 0 3
75450: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
75451: LD_INT 0
75453: PPUSH
// if not mc_bases [ base ] then
75454: LD_EXP 68
75458: PUSH
75459: LD_VAR 0 1
75463: ARRAY
75464: NOT
75465: IFFALSE 75469
// exit ;
75467: GO 75494
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
75469: LD_ADDR_EXP 79
75473: PUSH
75474: LD_EXP 79
75478: PPUSH
75479: LD_VAR 0 1
75483: PPUSH
75484: LD_VAR 0 2
75488: PPUSH
75489: CALL_OW 1
75493: ST_TO_ADDR
// end ;
75494: LD_VAR 0 3
75498: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
75499: LD_INT 0
75501: PPUSH
75502: PPUSH
75503: PPUSH
75504: PPUSH
// if not mc_bases [ base ] then
75505: LD_EXP 68
75509: PUSH
75510: LD_VAR 0 1
75514: ARRAY
75515: NOT
75516: IFFALSE 75520
// exit ;
75518: GO 75585
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
75520: LD_ADDR_EXP 88
75524: PUSH
75525: LD_EXP 88
75529: PPUSH
75530: LD_VAR 0 1
75534: PUSH
75535: LD_EXP 88
75539: PUSH
75540: LD_VAR 0 1
75544: ARRAY
75545: PUSH
75546: LD_INT 1
75548: PLUS
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PPUSH
75554: LD_VAR 0 1
75558: PUSH
75559: LD_VAR 0 2
75563: PUSH
75564: LD_VAR 0 3
75568: PUSH
75569: LD_VAR 0 4
75573: PUSH
75574: EMPTY
75575: LIST
75576: LIST
75577: LIST
75578: LIST
75579: PPUSH
75580: CALL 18548 0 3
75584: ST_TO_ADDR
// end ;
75585: LD_VAR 0 5
75589: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75590: LD_INT 0
75592: PPUSH
// if not mc_bases [ base ] then
75593: LD_EXP 68
75597: PUSH
75598: LD_VAR 0 1
75602: ARRAY
75603: NOT
75604: IFFALSE 75608
// exit ;
75606: GO 75633
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75608: LD_ADDR_EXP 105
75612: PUSH
75613: LD_EXP 105
75617: PPUSH
75618: LD_VAR 0 1
75622: PPUSH
75623: LD_VAR 0 2
75627: PPUSH
75628: CALL_OW 1
75632: ST_TO_ADDR
// end ;
75633: LD_VAR 0 3
75637: RET
// export function MC_GetMinesField ( base ) ; begin
75638: LD_INT 0
75640: PPUSH
// result := mc_mines [ base ] ;
75641: LD_ADDR_VAR 0 2
75645: PUSH
75646: LD_EXP 81
75650: PUSH
75651: LD_VAR 0 1
75655: ARRAY
75656: ST_TO_ADDR
// end ;
75657: LD_VAR 0 2
75661: RET
// export function MC_GetProduceList ( base ) ; begin
75662: LD_INT 0
75664: PPUSH
// result := mc_produce [ base ] ;
75665: LD_ADDR_VAR 0 2
75669: PUSH
75670: LD_EXP 89
75674: PUSH
75675: LD_VAR 0 1
75679: ARRAY
75680: ST_TO_ADDR
// end ;
75681: LD_VAR 0 2
75685: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
75686: LD_INT 0
75688: PPUSH
75689: PPUSH
// if not mc_bases then
75690: LD_EXP 68
75694: NOT
75695: IFFALSE 75699
// exit ;
75697: GO 75764
// if mc_bases [ base ] then
75699: LD_EXP 68
75703: PUSH
75704: LD_VAR 0 1
75708: ARRAY
75709: IFFALSE 75764
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75711: LD_ADDR_VAR 0 3
75715: PUSH
75716: LD_EXP 68
75720: PUSH
75721: LD_VAR 0 1
75725: ARRAY
75726: PPUSH
75727: LD_INT 30
75729: PUSH
75730: LD_VAR 0 2
75734: PUSH
75735: EMPTY
75736: LIST
75737: LIST
75738: PPUSH
75739: CALL_OW 72
75743: ST_TO_ADDR
// if result then
75744: LD_VAR 0 3
75748: IFFALSE 75764
// result := result [ 1 ] ;
75750: LD_ADDR_VAR 0 3
75754: PUSH
75755: LD_VAR 0 3
75759: PUSH
75760: LD_INT 1
75762: ARRAY
75763: ST_TO_ADDR
// end ; end ;
75764: LD_VAR 0 3
75768: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
75769: LD_INT 0
75771: PPUSH
75772: PPUSH
// if not mc_bases then
75773: LD_EXP 68
75777: NOT
75778: IFFALSE 75782
// exit ;
75780: GO 75827
// if mc_bases [ base ] then
75782: LD_EXP 68
75786: PUSH
75787: LD_VAR 0 1
75791: ARRAY
75792: IFFALSE 75827
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75794: LD_ADDR_VAR 0 3
75798: PUSH
75799: LD_EXP 68
75803: PUSH
75804: LD_VAR 0 1
75808: ARRAY
75809: PPUSH
75810: LD_INT 30
75812: PUSH
75813: LD_VAR 0 2
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: PPUSH
75822: CALL_OW 72
75826: ST_TO_ADDR
// end ;
75827: LD_VAR 0 3
75831: RET
// export function MC_SetTame ( base , area ) ; begin
75832: LD_INT 0
75834: PPUSH
// if not mc_bases or not base then
75835: LD_EXP 68
75839: NOT
75840: PUSH
75841: LD_VAR 0 1
75845: NOT
75846: OR
75847: IFFALSE 75851
// exit ;
75849: GO 75876
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
75851: LD_ADDR_EXP 96
75855: PUSH
75856: LD_EXP 96
75860: PPUSH
75861: LD_VAR 0 1
75865: PPUSH
75866: LD_VAR 0 2
75870: PPUSH
75871: CALL_OW 1
75875: ST_TO_ADDR
// end ;
75876: LD_VAR 0 3
75880: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
75881: LD_INT 0
75883: PPUSH
75884: PPUSH
// if not mc_bases or not base then
75885: LD_EXP 68
75889: NOT
75890: PUSH
75891: LD_VAR 0 1
75895: NOT
75896: OR
75897: IFFALSE 75901
// exit ;
75899: GO 76003
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75901: LD_ADDR_VAR 0 4
75905: PUSH
75906: LD_EXP 68
75910: PUSH
75911: LD_VAR 0 1
75915: ARRAY
75916: PPUSH
75917: LD_INT 30
75919: PUSH
75920: LD_VAR 0 2
75924: PUSH
75925: EMPTY
75926: LIST
75927: LIST
75928: PPUSH
75929: CALL_OW 72
75933: ST_TO_ADDR
// if not tmp then
75934: LD_VAR 0 4
75938: NOT
75939: IFFALSE 75943
// exit ;
75941: GO 76003
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
75943: LD_ADDR_EXP 100
75947: PUSH
75948: LD_EXP 100
75952: PPUSH
75953: LD_VAR 0 1
75957: PPUSH
75958: LD_EXP 100
75962: PUSH
75963: LD_VAR 0 1
75967: ARRAY
75968: PPUSH
75969: LD_EXP 100
75973: PUSH
75974: LD_VAR 0 1
75978: ARRAY
75979: PUSH
75980: LD_INT 1
75982: PLUS
75983: PPUSH
75984: LD_VAR 0 4
75988: PUSH
75989: LD_INT 1
75991: ARRAY
75992: PPUSH
75993: CALL_OW 2
75997: PPUSH
75998: CALL_OW 1
76002: ST_TO_ADDR
// end ;
76003: LD_VAR 0 3
76007: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
76008: LD_INT 0
76010: PPUSH
76011: PPUSH
// if not mc_bases or not base or not kinds then
76012: LD_EXP 68
76016: NOT
76017: PUSH
76018: LD_VAR 0 1
76022: NOT
76023: OR
76024: PUSH
76025: LD_VAR 0 2
76029: NOT
76030: OR
76031: IFFALSE 76035
// exit ;
76033: GO 76096
// for i in kinds do
76035: LD_ADDR_VAR 0 4
76039: PUSH
76040: LD_VAR 0 2
76044: PUSH
76045: FOR_IN
76046: IFFALSE 76094
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
76048: LD_ADDR_EXP 102
76052: PUSH
76053: LD_EXP 102
76057: PPUSH
76058: LD_VAR 0 1
76062: PUSH
76063: LD_EXP 102
76067: PUSH
76068: LD_VAR 0 1
76072: ARRAY
76073: PUSH
76074: LD_INT 1
76076: PLUS
76077: PUSH
76078: EMPTY
76079: LIST
76080: LIST
76081: PPUSH
76082: LD_VAR 0 4
76086: PPUSH
76087: CALL 18548 0 3
76091: ST_TO_ADDR
76092: GO 76045
76094: POP
76095: POP
// end ;
76096: LD_VAR 0 3
76100: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
76101: LD_INT 0
76103: PPUSH
// if not mc_bases or not base or not areas then
76104: LD_EXP 68
76108: NOT
76109: PUSH
76110: LD_VAR 0 1
76114: NOT
76115: OR
76116: PUSH
76117: LD_VAR 0 2
76121: NOT
76122: OR
76123: IFFALSE 76127
// exit ;
76125: GO 76152
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
76127: LD_ADDR_EXP 86
76131: PUSH
76132: LD_EXP 86
76136: PPUSH
76137: LD_VAR 0 1
76141: PPUSH
76142: LD_VAR 0 2
76146: PPUSH
76147: CALL_OW 1
76151: ST_TO_ADDR
// end ;
76152: LD_VAR 0 3
76156: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
76157: LD_INT 0
76159: PPUSH
// if not mc_bases or not base or not teleports_exit then
76160: LD_EXP 68
76164: NOT
76165: PUSH
76166: LD_VAR 0 1
76170: NOT
76171: OR
76172: PUSH
76173: LD_VAR 0 2
76177: NOT
76178: OR
76179: IFFALSE 76183
// exit ;
76181: GO 76208
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
76183: LD_ADDR_EXP 103
76187: PUSH
76188: LD_EXP 103
76192: PPUSH
76193: LD_VAR 0 1
76197: PPUSH
76198: LD_VAR 0 2
76202: PPUSH
76203: CALL_OW 1
76207: ST_TO_ADDR
// end ;
76208: LD_VAR 0 3
76212: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
76213: LD_INT 0
76215: PPUSH
76216: PPUSH
76217: PPUSH
// if not mc_bases or not base or not ext_list then
76218: LD_EXP 68
76222: NOT
76223: PUSH
76224: LD_VAR 0 1
76228: NOT
76229: OR
76230: PUSH
76231: LD_VAR 0 5
76235: NOT
76236: OR
76237: IFFALSE 76241
// exit ;
76239: GO 76414
// tmp := GetFacExtXYD ( x , y , d ) ;
76241: LD_ADDR_VAR 0 8
76245: PUSH
76246: LD_VAR 0 2
76250: PPUSH
76251: LD_VAR 0 3
76255: PPUSH
76256: LD_VAR 0 4
76260: PPUSH
76261: CALL 47560 0 3
76265: ST_TO_ADDR
// if not tmp then
76266: LD_VAR 0 8
76270: NOT
76271: IFFALSE 76275
// exit ;
76273: GO 76414
// for i in tmp do
76275: LD_ADDR_VAR 0 7
76279: PUSH
76280: LD_VAR 0 8
76284: PUSH
76285: FOR_IN
76286: IFFALSE 76412
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76288: LD_ADDR_EXP 73
76292: PUSH
76293: LD_EXP 73
76297: PPUSH
76298: LD_VAR 0 1
76302: PPUSH
76303: LD_EXP 73
76307: PUSH
76308: LD_VAR 0 1
76312: ARRAY
76313: PPUSH
76314: LD_EXP 73
76318: PUSH
76319: LD_VAR 0 1
76323: ARRAY
76324: PUSH
76325: LD_INT 1
76327: PLUS
76328: PPUSH
76329: LD_VAR 0 5
76333: PUSH
76334: LD_INT 1
76336: ARRAY
76337: PUSH
76338: LD_VAR 0 7
76342: PUSH
76343: LD_INT 1
76345: ARRAY
76346: PUSH
76347: LD_VAR 0 7
76351: PUSH
76352: LD_INT 2
76354: ARRAY
76355: PUSH
76356: LD_VAR 0 7
76360: PUSH
76361: LD_INT 3
76363: ARRAY
76364: PUSH
76365: EMPTY
76366: LIST
76367: LIST
76368: LIST
76369: LIST
76370: PPUSH
76371: CALL_OW 2
76375: PPUSH
76376: CALL_OW 1
76380: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76381: LD_ADDR_VAR 0 5
76385: PUSH
76386: LD_VAR 0 5
76390: PPUSH
76391: LD_INT 1
76393: PPUSH
76394: CALL_OW 3
76398: ST_TO_ADDR
// if not ext_list then
76399: LD_VAR 0 5
76403: NOT
76404: IFFALSE 76410
// exit ;
76406: POP
76407: POP
76408: GO 76414
// end ;
76410: GO 76285
76412: POP
76413: POP
// end ;
76414: LD_VAR 0 6
76418: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
76419: LD_INT 0
76421: PPUSH
// if not mc_bases or not base or not weapon_list then
76422: LD_EXP 68
76426: NOT
76427: PUSH
76428: LD_VAR 0 1
76432: NOT
76433: OR
76434: PUSH
76435: LD_VAR 0 2
76439: NOT
76440: OR
76441: IFFALSE 76445
// exit ;
76443: GO 76470
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
76445: LD_ADDR_EXP 107
76449: PUSH
76450: LD_EXP 107
76454: PPUSH
76455: LD_VAR 0 1
76459: PPUSH
76460: LD_VAR 0 2
76464: PPUSH
76465: CALL_OW 1
76469: ST_TO_ADDR
// end ;
76470: LD_VAR 0 3
76474: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
76475: LD_INT 0
76477: PPUSH
// if not mc_bases or not base or not tech_list then
76478: LD_EXP 68
76482: NOT
76483: PUSH
76484: LD_VAR 0 1
76488: NOT
76489: OR
76490: PUSH
76491: LD_VAR 0 2
76495: NOT
76496: OR
76497: IFFALSE 76501
// exit ;
76499: GO 76526
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
76501: LD_ADDR_EXP 95
76505: PUSH
76506: LD_EXP 95
76510: PPUSH
76511: LD_VAR 0 1
76515: PPUSH
76516: LD_VAR 0 2
76520: PPUSH
76521: CALL_OW 1
76525: ST_TO_ADDR
// end ;
76526: LD_VAR 0 3
76530: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76531: LD_INT 0
76533: PPUSH
// if not mc_bases or not parking_area or not base then
76534: LD_EXP 68
76538: NOT
76539: PUSH
76540: LD_VAR 0 2
76544: NOT
76545: OR
76546: PUSH
76547: LD_VAR 0 1
76551: NOT
76552: OR
76553: IFFALSE 76557
// exit ;
76555: GO 76582
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76557: LD_ADDR_EXP 92
76561: PUSH
76562: LD_EXP 92
76566: PPUSH
76567: LD_VAR 0 1
76571: PPUSH
76572: LD_VAR 0 2
76576: PPUSH
76577: CALL_OW 1
76581: ST_TO_ADDR
// end ;
76582: LD_VAR 0 3
76586: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76587: LD_INT 0
76589: PPUSH
// if not mc_bases or not base or not scan_area then
76590: LD_EXP 68
76594: NOT
76595: PUSH
76596: LD_VAR 0 1
76600: NOT
76601: OR
76602: PUSH
76603: LD_VAR 0 2
76607: NOT
76608: OR
76609: IFFALSE 76613
// exit ;
76611: GO 76638
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76613: LD_ADDR_EXP 93
76617: PUSH
76618: LD_EXP 93
76622: PPUSH
76623: LD_VAR 0 1
76627: PPUSH
76628: LD_VAR 0 2
76632: PPUSH
76633: CALL_OW 1
76637: ST_TO_ADDR
// end ;
76638: LD_VAR 0 3
76642: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76643: LD_INT 0
76645: PPUSH
76646: PPUSH
// if not mc_bases or not base then
76647: LD_EXP 68
76651: NOT
76652: PUSH
76653: LD_VAR 0 1
76657: NOT
76658: OR
76659: IFFALSE 76663
// exit ;
76661: GO 76727
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76663: LD_ADDR_VAR 0 3
76667: PUSH
76668: LD_INT 1
76670: PUSH
76671: LD_INT 2
76673: PUSH
76674: LD_INT 3
76676: PUSH
76677: LD_INT 4
76679: PUSH
76680: LD_INT 11
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: LIST
76687: LIST
76688: LIST
76689: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
76690: LD_ADDR_EXP 95
76694: PUSH
76695: LD_EXP 95
76699: PPUSH
76700: LD_VAR 0 1
76704: PPUSH
76705: LD_EXP 95
76709: PUSH
76710: LD_VAR 0 1
76714: ARRAY
76715: PUSH
76716: LD_VAR 0 3
76720: DIFF
76721: PPUSH
76722: CALL_OW 1
76726: ST_TO_ADDR
// end ;
76727: LD_VAR 0 2
76731: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
76732: LD_INT 0
76734: PPUSH
// result := mc_vehicles [ base ] ;
76735: LD_ADDR_VAR 0 3
76739: PUSH
76740: LD_EXP 87
76744: PUSH
76745: LD_VAR 0 1
76749: ARRAY
76750: ST_TO_ADDR
// if onlyCombat then
76751: LD_VAR 0 2
76755: IFFALSE 76933
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
76757: LD_ADDR_VAR 0 3
76761: PUSH
76762: LD_VAR 0 3
76766: PUSH
76767: LD_VAR 0 3
76771: PPUSH
76772: LD_INT 2
76774: PUSH
76775: LD_INT 34
76777: PUSH
76778: LD_INT 12
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: LD_INT 34
76787: PUSH
76788: LD_INT 51
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: PUSH
76795: LD_INT 34
76797: PUSH
76798: LD_EXP 49
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: PUSH
76807: LD_INT 34
76809: PUSH
76810: LD_INT 32
76812: PUSH
76813: EMPTY
76814: LIST
76815: LIST
76816: PUSH
76817: LD_INT 34
76819: PUSH
76820: LD_INT 13
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: PUSH
76827: LD_INT 34
76829: PUSH
76830: LD_INT 52
76832: PUSH
76833: EMPTY
76834: LIST
76835: LIST
76836: PUSH
76837: LD_INT 34
76839: PUSH
76840: LD_EXP 54
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: PUSH
76849: LD_INT 34
76851: PUSH
76852: LD_INT 14
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: PUSH
76859: LD_INT 34
76861: PUSH
76862: LD_INT 53
76864: PUSH
76865: EMPTY
76866: LIST
76867: LIST
76868: PUSH
76869: LD_INT 34
76871: PUSH
76872: LD_EXP 48
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: PUSH
76881: LD_INT 34
76883: PUSH
76884: LD_INT 31
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: PUSH
76891: LD_INT 34
76893: PUSH
76894: LD_INT 48
76896: PUSH
76897: EMPTY
76898: LIST
76899: LIST
76900: PUSH
76901: LD_INT 34
76903: PUSH
76904: LD_INT 8
76906: PUSH
76907: EMPTY
76908: LIST
76909: LIST
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: LIST
76915: LIST
76916: LIST
76917: LIST
76918: LIST
76919: LIST
76920: LIST
76921: LIST
76922: LIST
76923: LIST
76924: LIST
76925: LIST
76926: PPUSH
76927: CALL_OW 72
76931: DIFF
76932: ST_TO_ADDR
// end ; end_of_file
76933: LD_VAR 0 3
76937: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
76938: LD_INT 0
76940: PPUSH
76941: PPUSH
76942: PPUSH
// if not mc_bases or not skirmish then
76943: LD_EXP 68
76947: NOT
76948: PUSH
76949: LD_EXP 66
76953: NOT
76954: OR
76955: IFFALSE 76959
// exit ;
76957: GO 77124
// for i = 1 to mc_bases do
76959: LD_ADDR_VAR 0 4
76963: PUSH
76964: DOUBLE
76965: LD_INT 1
76967: DEC
76968: ST_TO_ADDR
76969: LD_EXP 68
76973: PUSH
76974: FOR_TO
76975: IFFALSE 77122
// begin if sci in mc_bases [ i ] then
76977: LD_VAR 0 2
76981: PUSH
76982: LD_EXP 68
76986: PUSH
76987: LD_VAR 0 4
76991: ARRAY
76992: IN
76993: IFFALSE 77120
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
76995: LD_ADDR_EXP 97
76999: PUSH
77000: LD_EXP 97
77004: PPUSH
77005: LD_VAR 0 4
77009: PUSH
77010: LD_EXP 97
77014: PUSH
77015: LD_VAR 0 4
77019: ARRAY
77020: PUSH
77021: LD_INT 1
77023: PLUS
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: PPUSH
77029: LD_VAR 0 1
77033: PPUSH
77034: CALL 18548 0 3
77038: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
77039: LD_ADDR_VAR 0 5
77043: PUSH
77044: LD_EXP 68
77048: PUSH
77049: LD_VAR 0 4
77053: ARRAY
77054: PPUSH
77055: LD_INT 2
77057: PUSH
77058: LD_INT 30
77060: PUSH
77061: LD_INT 0
77063: PUSH
77064: EMPTY
77065: LIST
77066: LIST
77067: PUSH
77068: LD_INT 30
77070: PUSH
77071: LD_INT 1
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: PUSH
77078: EMPTY
77079: LIST
77080: LIST
77081: LIST
77082: PPUSH
77083: CALL_OW 72
77087: PPUSH
77088: LD_VAR 0 1
77092: PPUSH
77093: CALL_OW 74
77097: ST_TO_ADDR
// if tmp then
77098: LD_VAR 0 5
77102: IFFALSE 77118
// ComStandNearbyBuilding ( ape , tmp ) ;
77104: LD_VAR 0 1
77108: PPUSH
77109: LD_VAR 0 5
77113: PPUSH
77114: CALL 15162 0 2
// break ;
77118: GO 77122
// end ; end ;
77120: GO 76974
77122: POP
77123: POP
// end ;
77124: LD_VAR 0 3
77128: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
77129: LD_INT 0
77131: PPUSH
77132: PPUSH
77133: PPUSH
// if not mc_bases or not skirmish then
77134: LD_EXP 68
77138: NOT
77139: PUSH
77140: LD_EXP 66
77144: NOT
77145: OR
77146: IFFALSE 77150
// exit ;
77148: GO 77239
// for i = 1 to mc_bases do
77150: LD_ADDR_VAR 0 4
77154: PUSH
77155: DOUBLE
77156: LD_INT 1
77158: DEC
77159: ST_TO_ADDR
77160: LD_EXP 68
77164: PUSH
77165: FOR_TO
77166: IFFALSE 77237
// begin if building in mc_busy_turret_list [ i ] then
77168: LD_VAR 0 1
77172: PUSH
77173: LD_EXP 78
77177: PUSH
77178: LD_VAR 0 4
77182: ARRAY
77183: IN
77184: IFFALSE 77235
// begin tmp := mc_busy_turret_list [ i ] diff building ;
77186: LD_ADDR_VAR 0 5
77190: PUSH
77191: LD_EXP 78
77195: PUSH
77196: LD_VAR 0 4
77200: ARRAY
77201: PUSH
77202: LD_VAR 0 1
77206: DIFF
77207: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
77208: LD_ADDR_EXP 78
77212: PUSH
77213: LD_EXP 78
77217: PPUSH
77218: LD_VAR 0 4
77222: PPUSH
77223: LD_VAR 0 5
77227: PPUSH
77228: CALL_OW 1
77232: ST_TO_ADDR
// break ;
77233: GO 77237
// end ; end ;
77235: GO 77165
77237: POP
77238: POP
// end ;
77239: LD_VAR 0 3
77243: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77244: LD_INT 0
77246: PPUSH
77247: PPUSH
77248: PPUSH
// if not mc_bases or not skirmish then
77249: LD_EXP 68
77253: NOT
77254: PUSH
77255: LD_EXP 66
77259: NOT
77260: OR
77261: IFFALSE 77265
// exit ;
77263: GO 77464
// for i = 1 to mc_bases do
77265: LD_ADDR_VAR 0 5
77269: PUSH
77270: DOUBLE
77271: LD_INT 1
77273: DEC
77274: ST_TO_ADDR
77275: LD_EXP 68
77279: PUSH
77280: FOR_TO
77281: IFFALSE 77462
// if building in mc_bases [ i ] then
77283: LD_VAR 0 1
77287: PUSH
77288: LD_EXP 68
77292: PUSH
77293: LD_VAR 0 5
77297: ARRAY
77298: IN
77299: IFFALSE 77460
// begin tmp := mc_bases [ i ] diff building ;
77301: LD_ADDR_VAR 0 6
77305: PUSH
77306: LD_EXP 68
77310: PUSH
77311: LD_VAR 0 5
77315: ARRAY
77316: PUSH
77317: LD_VAR 0 1
77321: DIFF
77322: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77323: LD_ADDR_EXP 68
77327: PUSH
77328: LD_EXP 68
77332: PPUSH
77333: LD_VAR 0 5
77337: PPUSH
77338: LD_VAR 0 6
77342: PPUSH
77343: CALL_OW 1
77347: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77348: LD_VAR 0 1
77352: PUSH
77353: LD_EXP 76
77357: PUSH
77358: LD_VAR 0 5
77362: ARRAY
77363: IN
77364: IFFALSE 77403
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77366: LD_ADDR_EXP 76
77370: PUSH
77371: LD_EXP 76
77375: PPUSH
77376: LD_VAR 0 5
77380: PPUSH
77381: LD_EXP 76
77385: PUSH
77386: LD_VAR 0 5
77390: ARRAY
77391: PUSH
77392: LD_VAR 0 1
77396: DIFF
77397: PPUSH
77398: CALL_OW 1
77402: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
77403: LD_VAR 0 1
77407: PUSH
77408: LD_EXP 77
77412: PUSH
77413: LD_VAR 0 5
77417: ARRAY
77418: IN
77419: IFFALSE 77458
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
77421: LD_ADDR_EXP 77
77425: PUSH
77426: LD_EXP 77
77430: PPUSH
77431: LD_VAR 0 5
77435: PPUSH
77436: LD_EXP 77
77440: PUSH
77441: LD_VAR 0 5
77445: ARRAY
77446: PUSH
77447: LD_VAR 0 1
77451: DIFF
77452: PPUSH
77453: CALL_OW 1
77457: ST_TO_ADDR
// break ;
77458: GO 77462
// end ;
77460: GO 77280
77462: POP
77463: POP
// end ;
77464: LD_VAR 0 4
77468: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
77469: LD_INT 0
77471: PPUSH
77472: PPUSH
77473: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
77474: LD_EXP 68
77478: NOT
77479: PUSH
77480: LD_EXP 66
77484: NOT
77485: OR
77486: PUSH
77487: LD_VAR 0 3
77491: PUSH
77492: LD_EXP 94
77496: IN
77497: NOT
77498: OR
77499: IFFALSE 77503
// exit ;
77501: GO 77626
// for i = 1 to mc_vehicles do
77503: LD_ADDR_VAR 0 6
77507: PUSH
77508: DOUBLE
77509: LD_INT 1
77511: DEC
77512: ST_TO_ADDR
77513: LD_EXP 87
77517: PUSH
77518: FOR_TO
77519: IFFALSE 77624
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
77521: LD_VAR 0 2
77525: PUSH
77526: LD_EXP 87
77530: PUSH
77531: LD_VAR 0 6
77535: ARRAY
77536: IN
77537: PUSH
77538: LD_VAR 0 1
77542: PUSH
77543: LD_EXP 87
77547: PUSH
77548: LD_VAR 0 6
77552: ARRAY
77553: IN
77554: OR
77555: IFFALSE 77622
// begin tmp := mc_vehicles [ i ] diff old ;
77557: LD_ADDR_VAR 0 7
77561: PUSH
77562: LD_EXP 87
77566: PUSH
77567: LD_VAR 0 6
77571: ARRAY
77572: PUSH
77573: LD_VAR 0 2
77577: DIFF
77578: ST_TO_ADDR
// tmp := tmp diff new ;
77579: LD_ADDR_VAR 0 7
77583: PUSH
77584: LD_VAR 0 7
77588: PUSH
77589: LD_VAR 0 1
77593: DIFF
77594: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77595: LD_ADDR_EXP 87
77599: PUSH
77600: LD_EXP 87
77604: PPUSH
77605: LD_VAR 0 6
77609: PPUSH
77610: LD_VAR 0 7
77614: PPUSH
77615: CALL_OW 1
77619: ST_TO_ADDR
// break ;
77620: GO 77624
// end ;
77622: GO 77518
77624: POP
77625: POP
// end ;
77626: LD_VAR 0 5
77630: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77631: LD_INT 0
77633: PPUSH
77634: PPUSH
77635: PPUSH
77636: PPUSH
// if not mc_bases or not skirmish then
77637: LD_EXP 68
77641: NOT
77642: PUSH
77643: LD_EXP 66
77647: NOT
77648: OR
77649: IFFALSE 77653
// exit ;
77651: GO 78036
// side := GetSide ( vehicle ) ;
77653: LD_ADDR_VAR 0 5
77657: PUSH
77658: LD_VAR 0 1
77662: PPUSH
77663: CALL_OW 255
77667: ST_TO_ADDR
// for i = 1 to mc_bases do
77668: LD_ADDR_VAR 0 4
77672: PUSH
77673: DOUBLE
77674: LD_INT 1
77676: DEC
77677: ST_TO_ADDR
77678: LD_EXP 68
77682: PUSH
77683: FOR_TO
77684: IFFALSE 78034
// begin if factory in mc_bases [ i ] then
77686: LD_VAR 0 2
77690: PUSH
77691: LD_EXP 68
77695: PUSH
77696: LD_VAR 0 4
77700: ARRAY
77701: IN
77702: IFFALSE 78032
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
77704: LD_EXP 90
77708: PUSH
77709: LD_VAR 0 4
77713: ARRAY
77714: PUSH
77715: LD_EXP 79
77719: PUSH
77720: LD_VAR 0 4
77724: ARRAY
77725: LESS
77726: PUSH
77727: LD_VAR 0 1
77731: PPUSH
77732: CALL_OW 264
77736: PUSH
77737: LD_INT 31
77739: PUSH
77740: LD_INT 32
77742: PUSH
77743: LD_INT 51
77745: PUSH
77746: LD_EXP 49
77750: PUSH
77751: LD_INT 12
77753: PUSH
77754: LD_INT 30
77756: PUSH
77757: LD_EXP 48
77761: PUSH
77762: LD_INT 11
77764: PUSH
77765: LD_INT 53
77767: PUSH
77768: LD_INT 14
77770: PUSH
77771: LD_EXP 52
77775: PUSH
77776: LD_INT 29
77778: PUSH
77779: LD_EXP 50
77783: PUSH
77784: LD_INT 13
77786: PUSH
77787: LD_INT 52
77789: PUSH
77790: LD_EXP 54
77794: PUSH
77795: LD_INT 48
77797: PUSH
77798: LD_INT 8
77800: PUSH
77801: EMPTY
77802: LIST
77803: LIST
77804: LIST
77805: LIST
77806: LIST
77807: LIST
77808: LIST
77809: LIST
77810: LIST
77811: LIST
77812: LIST
77813: LIST
77814: LIST
77815: LIST
77816: LIST
77817: LIST
77818: LIST
77819: LIST
77820: IN
77821: NOT
77822: AND
77823: IFFALSE 77871
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
77825: LD_ADDR_EXP 90
77829: PUSH
77830: LD_EXP 90
77834: PPUSH
77835: LD_VAR 0 4
77839: PUSH
77840: LD_EXP 90
77844: PUSH
77845: LD_VAR 0 4
77849: ARRAY
77850: PUSH
77851: LD_INT 1
77853: PLUS
77854: PUSH
77855: EMPTY
77856: LIST
77857: LIST
77858: PPUSH
77859: LD_VAR 0 1
77863: PPUSH
77864: CALL 18548 0 3
77868: ST_TO_ADDR
77869: GO 77915
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
77871: LD_ADDR_EXP 87
77875: PUSH
77876: LD_EXP 87
77880: PPUSH
77881: LD_VAR 0 4
77885: PUSH
77886: LD_EXP 87
77890: PUSH
77891: LD_VAR 0 4
77895: ARRAY
77896: PUSH
77897: LD_INT 1
77899: PLUS
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PPUSH
77905: LD_VAR 0 1
77909: PPUSH
77910: CALL 18548 0 3
77914: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
77915: LD_VAR 0 1
77919: PPUSH
77920: CALL_OW 263
77924: PUSH
77925: LD_INT 2
77927: EQUAL
77928: IFFALSE 77948
// begin repeat wait ( 0 0$1 ) ;
77930: LD_INT 35
77932: PPUSH
77933: CALL_OW 67
// until IsControledBy ( vehicle ) ;
77937: LD_VAR 0 1
77941: PPUSH
77942: CALL_OW 312
77946: IFFALSE 77930
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
77948: LD_VAR 0 1
77952: PPUSH
77953: LD_EXP 92
77957: PUSH
77958: LD_VAR 0 4
77962: ARRAY
77963: PPUSH
77964: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
77968: LD_VAR 0 1
77972: PPUSH
77973: CALL_OW 263
77977: PUSH
77978: LD_INT 1
77980: NONEQUAL
77981: IFFALSE 77985
// break ;
77983: GO 78034
// repeat wait ( 0 0$1 ) ;
77985: LD_INT 35
77987: PPUSH
77988: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
77992: LD_VAR 0 1
77996: PPUSH
77997: LD_EXP 92
78001: PUSH
78002: LD_VAR 0 4
78006: ARRAY
78007: PPUSH
78008: CALL_OW 308
78012: IFFALSE 77985
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
78014: LD_VAR 0 1
78018: PPUSH
78019: CALL_OW 311
78023: PPUSH
78024: CALL_OW 121
// exit ;
78028: POP
78029: POP
78030: GO 78036
// end ; end ;
78032: GO 77683
78034: POP
78035: POP
// end ;
78036: LD_VAR 0 3
78040: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
78041: LD_INT 0
78043: PPUSH
78044: PPUSH
78045: PPUSH
78046: PPUSH
// if not mc_bases or not skirmish then
78047: LD_EXP 68
78051: NOT
78052: PUSH
78053: LD_EXP 66
78057: NOT
78058: OR
78059: IFFALSE 78063
// exit ;
78061: GO 78416
// repeat wait ( 0 0$1 ) ;
78063: LD_INT 35
78065: PPUSH
78066: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
78070: LD_VAR 0 2
78074: PPUSH
78075: LD_VAR 0 3
78079: PPUSH
78080: CALL_OW 284
78084: IFFALSE 78063
// if GetResourceTypeXY ( x , y ) = mat_artefact then
78086: LD_VAR 0 2
78090: PPUSH
78091: LD_VAR 0 3
78095: PPUSH
78096: CALL_OW 283
78100: PUSH
78101: LD_INT 4
78103: EQUAL
78104: IFFALSE 78108
// exit ;
78106: GO 78416
// for i = 1 to mc_bases do
78108: LD_ADDR_VAR 0 7
78112: PUSH
78113: DOUBLE
78114: LD_INT 1
78116: DEC
78117: ST_TO_ADDR
78118: LD_EXP 68
78122: PUSH
78123: FOR_TO
78124: IFFALSE 78414
// begin if mc_crates_area [ i ] then
78126: LD_EXP 86
78130: PUSH
78131: LD_VAR 0 7
78135: ARRAY
78136: IFFALSE 78247
// for j in mc_crates_area [ i ] do
78138: LD_ADDR_VAR 0 8
78142: PUSH
78143: LD_EXP 86
78147: PUSH
78148: LD_VAR 0 7
78152: ARRAY
78153: PUSH
78154: FOR_IN
78155: IFFALSE 78245
// if InArea ( x , y , j ) then
78157: LD_VAR 0 2
78161: PPUSH
78162: LD_VAR 0 3
78166: PPUSH
78167: LD_VAR 0 8
78171: PPUSH
78172: CALL_OW 309
78176: IFFALSE 78243
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78178: LD_ADDR_EXP 84
78182: PUSH
78183: LD_EXP 84
78187: PPUSH
78188: LD_VAR 0 7
78192: PUSH
78193: LD_EXP 84
78197: PUSH
78198: LD_VAR 0 7
78202: ARRAY
78203: PUSH
78204: LD_INT 1
78206: PLUS
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: PPUSH
78212: LD_VAR 0 4
78216: PUSH
78217: LD_VAR 0 2
78221: PUSH
78222: LD_VAR 0 3
78226: PUSH
78227: EMPTY
78228: LIST
78229: LIST
78230: LIST
78231: PPUSH
78232: CALL 18548 0 3
78236: ST_TO_ADDR
// exit ;
78237: POP
78238: POP
78239: POP
78240: POP
78241: GO 78416
// end ;
78243: GO 78154
78245: POP
78246: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78247: LD_ADDR_VAR 0 9
78251: PUSH
78252: LD_EXP 68
78256: PUSH
78257: LD_VAR 0 7
78261: ARRAY
78262: PPUSH
78263: LD_INT 2
78265: PUSH
78266: LD_INT 30
78268: PUSH
78269: LD_INT 0
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: PUSH
78276: LD_INT 30
78278: PUSH
78279: LD_INT 1
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: LIST
78290: PPUSH
78291: CALL_OW 72
78295: ST_TO_ADDR
// if not depot then
78296: LD_VAR 0 9
78300: NOT
78301: IFFALSE 78305
// continue ;
78303: GO 78123
// for j in depot do
78305: LD_ADDR_VAR 0 8
78309: PUSH
78310: LD_VAR 0 9
78314: PUSH
78315: FOR_IN
78316: IFFALSE 78410
// if GetDistUnitXY ( j , x , y ) < 30 then
78318: LD_VAR 0 8
78322: PPUSH
78323: LD_VAR 0 2
78327: PPUSH
78328: LD_VAR 0 3
78332: PPUSH
78333: CALL_OW 297
78337: PUSH
78338: LD_INT 30
78340: LESS
78341: IFFALSE 78408
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78343: LD_ADDR_EXP 84
78347: PUSH
78348: LD_EXP 84
78352: PPUSH
78353: LD_VAR 0 7
78357: PUSH
78358: LD_EXP 84
78362: PUSH
78363: LD_VAR 0 7
78367: ARRAY
78368: PUSH
78369: LD_INT 1
78371: PLUS
78372: PUSH
78373: EMPTY
78374: LIST
78375: LIST
78376: PPUSH
78377: LD_VAR 0 4
78381: PUSH
78382: LD_VAR 0 2
78386: PUSH
78387: LD_VAR 0 3
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: LIST
78396: PPUSH
78397: CALL 18548 0 3
78401: ST_TO_ADDR
// exit ;
78402: POP
78403: POP
78404: POP
78405: POP
78406: GO 78416
// end ;
78408: GO 78315
78410: POP
78411: POP
// end ;
78412: GO 78123
78414: POP
78415: POP
// end ;
78416: LD_VAR 0 6
78420: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
78421: LD_INT 0
78423: PPUSH
78424: PPUSH
78425: PPUSH
78426: PPUSH
// if not mc_bases or not skirmish then
78427: LD_EXP 68
78431: NOT
78432: PUSH
78433: LD_EXP 66
78437: NOT
78438: OR
78439: IFFALSE 78443
// exit ;
78441: GO 78720
// side := GetSide ( lab ) ;
78443: LD_ADDR_VAR 0 4
78447: PUSH
78448: LD_VAR 0 2
78452: PPUSH
78453: CALL_OW 255
78457: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
78458: LD_VAR 0 4
78462: PUSH
78463: LD_EXP 94
78467: IN
78468: NOT
78469: PUSH
78470: LD_EXP 95
78474: NOT
78475: OR
78476: PUSH
78477: LD_EXP 68
78481: NOT
78482: OR
78483: IFFALSE 78487
// exit ;
78485: GO 78720
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
78487: LD_ADDR_EXP 95
78491: PUSH
78492: LD_EXP 95
78496: PPUSH
78497: LD_VAR 0 4
78501: PPUSH
78502: LD_EXP 95
78506: PUSH
78507: LD_VAR 0 4
78511: ARRAY
78512: PUSH
78513: LD_VAR 0 1
78517: DIFF
78518: PPUSH
78519: CALL_OW 1
78523: ST_TO_ADDR
// for i = 1 to mc_bases do
78524: LD_ADDR_VAR 0 5
78528: PUSH
78529: DOUBLE
78530: LD_INT 1
78532: DEC
78533: ST_TO_ADDR
78534: LD_EXP 68
78538: PUSH
78539: FOR_TO
78540: IFFALSE 78718
// begin if lab in mc_bases [ i ] then
78542: LD_VAR 0 2
78546: PUSH
78547: LD_EXP 68
78551: PUSH
78552: LD_VAR 0 5
78556: ARRAY
78557: IN
78558: IFFALSE 78716
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78560: LD_VAR 0 1
78564: PUSH
78565: LD_INT 11
78567: PUSH
78568: LD_INT 4
78570: PUSH
78571: LD_INT 3
78573: PUSH
78574: LD_INT 2
78576: PUSH
78577: EMPTY
78578: LIST
78579: LIST
78580: LIST
78581: LIST
78582: IN
78583: PUSH
78584: LD_EXP 98
78588: PUSH
78589: LD_VAR 0 5
78593: ARRAY
78594: AND
78595: IFFALSE 78716
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78597: LD_ADDR_VAR 0 6
78601: PUSH
78602: LD_EXP 98
78606: PUSH
78607: LD_VAR 0 5
78611: ARRAY
78612: PUSH
78613: LD_INT 1
78615: ARRAY
78616: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78617: LD_ADDR_EXP 98
78621: PUSH
78622: LD_EXP 98
78626: PPUSH
78627: LD_VAR 0 5
78631: PPUSH
78632: EMPTY
78633: PPUSH
78634: CALL_OW 1
78638: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78639: LD_VAR 0 6
78643: PPUSH
78644: LD_INT 0
78646: PPUSH
78647: CALL_OW 109
// ComExitBuilding ( tmp ) ;
78651: LD_VAR 0 6
78655: PPUSH
78656: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
78660: LD_ADDR_EXP 97
78664: PUSH
78665: LD_EXP 97
78669: PPUSH
78670: LD_VAR 0 5
78674: PPUSH
78675: LD_EXP 97
78679: PUSH
78680: LD_VAR 0 5
78684: ARRAY
78685: PPUSH
78686: LD_INT 1
78688: PPUSH
78689: LD_VAR 0 6
78693: PPUSH
78694: CALL_OW 2
78698: PPUSH
78699: CALL_OW 1
78703: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
78704: LD_VAR 0 5
78708: PPUSH
78709: LD_INT 112
78711: PPUSH
78712: CALL 55549 0 2
// end ; end ; end ;
78716: GO 78539
78718: POP
78719: POP
// end ;
78720: LD_VAR 0 3
78724: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
78725: LD_INT 0
78727: PPUSH
78728: PPUSH
78729: PPUSH
78730: PPUSH
78731: PPUSH
78732: PPUSH
78733: PPUSH
78734: PPUSH
// if not mc_bases or not skirmish then
78735: LD_EXP 68
78739: NOT
78740: PUSH
78741: LD_EXP 66
78745: NOT
78746: OR
78747: IFFALSE 78751
// exit ;
78749: GO 80122
// for i = 1 to mc_bases do
78751: LD_ADDR_VAR 0 3
78755: PUSH
78756: DOUBLE
78757: LD_INT 1
78759: DEC
78760: ST_TO_ADDR
78761: LD_EXP 68
78765: PUSH
78766: FOR_TO
78767: IFFALSE 80120
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
78769: LD_VAR 0 1
78773: PUSH
78774: LD_EXP 68
78778: PUSH
78779: LD_VAR 0 3
78783: ARRAY
78784: IN
78785: PUSH
78786: LD_VAR 0 1
78790: PUSH
78791: LD_EXP 75
78795: PUSH
78796: LD_VAR 0 3
78800: ARRAY
78801: IN
78802: OR
78803: PUSH
78804: LD_VAR 0 1
78808: PUSH
78809: LD_EXP 90
78813: PUSH
78814: LD_VAR 0 3
78818: ARRAY
78819: IN
78820: OR
78821: PUSH
78822: LD_VAR 0 1
78826: PUSH
78827: LD_EXP 87
78831: PUSH
78832: LD_VAR 0 3
78836: ARRAY
78837: IN
78838: OR
78839: PUSH
78840: LD_VAR 0 1
78844: PUSH
78845: LD_EXP 97
78849: PUSH
78850: LD_VAR 0 3
78854: ARRAY
78855: IN
78856: OR
78857: PUSH
78858: LD_VAR 0 1
78862: PUSH
78863: LD_EXP 98
78867: PUSH
78868: LD_VAR 0 3
78872: ARRAY
78873: IN
78874: OR
78875: IFFALSE 80118
// begin if un in mc_ape [ i ] then
78877: LD_VAR 0 1
78881: PUSH
78882: LD_EXP 97
78886: PUSH
78887: LD_VAR 0 3
78891: ARRAY
78892: IN
78893: IFFALSE 78932
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
78895: LD_ADDR_EXP 97
78899: PUSH
78900: LD_EXP 97
78904: PPUSH
78905: LD_VAR 0 3
78909: PPUSH
78910: LD_EXP 97
78914: PUSH
78915: LD_VAR 0 3
78919: ARRAY
78920: PUSH
78921: LD_VAR 0 1
78925: DIFF
78926: PPUSH
78927: CALL_OW 1
78931: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
78932: LD_VAR 0 1
78936: PUSH
78937: LD_EXP 98
78941: PUSH
78942: LD_VAR 0 3
78946: ARRAY
78947: IN
78948: IFFALSE 78972
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78950: LD_ADDR_EXP 98
78954: PUSH
78955: LD_EXP 98
78959: PPUSH
78960: LD_VAR 0 3
78964: PPUSH
78965: EMPTY
78966: PPUSH
78967: CALL_OW 1
78971: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
78972: LD_VAR 0 1
78976: PPUSH
78977: CALL_OW 247
78981: PUSH
78982: LD_INT 2
78984: EQUAL
78985: PUSH
78986: LD_VAR 0 1
78990: PPUSH
78991: CALL_OW 110
78995: PUSH
78996: LD_INT 20
78998: EQUAL
78999: PUSH
79000: LD_VAR 0 1
79004: PUSH
79005: LD_EXP 90
79009: PUSH
79010: LD_VAR 0 3
79014: ARRAY
79015: IN
79016: OR
79017: PUSH
79018: LD_VAR 0 1
79022: PPUSH
79023: CALL_OW 264
79027: PUSH
79028: LD_INT 12
79030: PUSH
79031: LD_INT 51
79033: PUSH
79034: LD_EXP 49
79038: PUSH
79039: LD_INT 32
79041: PUSH
79042: LD_INT 13
79044: PUSH
79045: LD_INT 52
79047: PUSH
79048: LD_INT 31
79050: PUSH
79051: EMPTY
79052: LIST
79053: LIST
79054: LIST
79055: LIST
79056: LIST
79057: LIST
79058: LIST
79059: IN
79060: OR
79061: AND
79062: IFFALSE 79370
// begin if un in mc_defender [ i ] then
79064: LD_VAR 0 1
79068: PUSH
79069: LD_EXP 90
79073: PUSH
79074: LD_VAR 0 3
79078: ARRAY
79079: IN
79080: IFFALSE 79119
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79082: LD_ADDR_EXP 90
79086: PUSH
79087: LD_EXP 90
79091: PPUSH
79092: LD_VAR 0 3
79096: PPUSH
79097: LD_EXP 90
79101: PUSH
79102: LD_VAR 0 3
79106: ARRAY
79107: PUSH
79108: LD_VAR 0 1
79112: DIFF
79113: PPUSH
79114: CALL_OW 1
79118: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
79119: LD_ADDR_VAR 0 8
79123: PUSH
79124: LD_VAR 0 3
79128: PPUSH
79129: LD_INT 3
79131: PPUSH
79132: CALL 75769 0 2
79136: ST_TO_ADDR
// if fac then
79137: LD_VAR 0 8
79141: IFFALSE 79370
// begin for j in fac do
79143: LD_ADDR_VAR 0 4
79147: PUSH
79148: LD_VAR 0 8
79152: PUSH
79153: FOR_IN
79154: IFFALSE 79368
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
79156: LD_ADDR_VAR 0 9
79160: PUSH
79161: LD_VAR 0 8
79165: PPUSH
79166: LD_VAR 0 1
79170: PPUSH
79171: CALL_OW 265
79175: PPUSH
79176: LD_VAR 0 1
79180: PPUSH
79181: CALL_OW 262
79185: PPUSH
79186: LD_VAR 0 1
79190: PPUSH
79191: CALL_OW 263
79195: PPUSH
79196: LD_VAR 0 1
79200: PPUSH
79201: CALL_OW 264
79205: PPUSH
79206: CALL 16080 0 5
79210: ST_TO_ADDR
// if components then
79211: LD_VAR 0 9
79215: IFFALSE 79366
// begin if GetWeapon ( un ) = ar_control_tower then
79217: LD_VAR 0 1
79221: PPUSH
79222: CALL_OW 264
79226: PUSH
79227: LD_INT 31
79229: EQUAL
79230: IFFALSE 79347
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79232: LD_VAR 0 1
79236: PPUSH
79237: CALL_OW 311
79241: PPUSH
79242: LD_INT 0
79244: PPUSH
79245: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79249: LD_ADDR_EXP 108
79253: PUSH
79254: LD_EXP 108
79258: PPUSH
79259: LD_VAR 0 3
79263: PPUSH
79264: LD_EXP 108
79268: PUSH
79269: LD_VAR 0 3
79273: ARRAY
79274: PUSH
79275: LD_VAR 0 1
79279: PPUSH
79280: CALL_OW 311
79284: DIFF
79285: PPUSH
79286: CALL_OW 1
79290: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79291: LD_ADDR_VAR 0 7
79295: PUSH
79296: LD_EXP 89
79300: PUSH
79301: LD_VAR 0 3
79305: ARRAY
79306: PPUSH
79307: LD_INT 1
79309: PPUSH
79310: LD_VAR 0 9
79314: PPUSH
79315: CALL_OW 2
79319: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79320: LD_ADDR_EXP 89
79324: PUSH
79325: LD_EXP 89
79329: PPUSH
79330: LD_VAR 0 3
79334: PPUSH
79335: LD_VAR 0 7
79339: PPUSH
79340: CALL_OW 1
79344: ST_TO_ADDR
// end else
79345: GO 79364
// MC_InsertProduceList ( i , [ components ] ) ;
79347: LD_VAR 0 3
79351: PPUSH
79352: LD_VAR 0 9
79356: PUSH
79357: EMPTY
79358: LIST
79359: PPUSH
79360: CALL 75314 0 2
// break ;
79364: GO 79368
// end ; end ;
79366: GO 79153
79368: POP
79369: POP
// end ; end ; if GetType ( un ) = unit_building then
79370: LD_VAR 0 1
79374: PPUSH
79375: CALL_OW 247
79379: PUSH
79380: LD_INT 3
79382: EQUAL
79383: IFFALSE 79786
// begin btype := GetBType ( un ) ;
79385: LD_ADDR_VAR 0 5
79389: PUSH
79390: LD_VAR 0 1
79394: PPUSH
79395: CALL_OW 266
79399: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79400: LD_VAR 0 5
79404: PUSH
79405: LD_INT 29
79407: PUSH
79408: LD_INT 30
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: IN
79415: IFFALSE 79488
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
79417: LD_VAR 0 1
79421: PPUSH
79422: CALL_OW 250
79426: PPUSH
79427: LD_VAR 0 1
79431: PPUSH
79432: CALL_OW 251
79436: PPUSH
79437: LD_VAR 0 1
79441: PPUSH
79442: CALL_OW 255
79446: PPUSH
79447: CALL_OW 440
79451: NOT
79452: IFFALSE 79488
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
79454: LD_VAR 0 1
79458: PPUSH
79459: CALL_OW 250
79463: PPUSH
79464: LD_VAR 0 1
79468: PPUSH
79469: CALL_OW 251
79473: PPUSH
79474: LD_VAR 0 1
79478: PPUSH
79479: CALL_OW 255
79483: PPUSH
79484: CALL_OW 441
// end ; if btype = b_warehouse then
79488: LD_VAR 0 5
79492: PUSH
79493: LD_INT 1
79495: EQUAL
79496: IFFALSE 79514
// begin btype := b_depot ;
79498: LD_ADDR_VAR 0 5
79502: PUSH
79503: LD_INT 0
79505: ST_TO_ADDR
// pos := 1 ;
79506: LD_ADDR_VAR 0 6
79510: PUSH
79511: LD_INT 1
79513: ST_TO_ADDR
// end ; if btype = b_factory then
79514: LD_VAR 0 5
79518: PUSH
79519: LD_INT 3
79521: EQUAL
79522: IFFALSE 79540
// begin btype := b_workshop ;
79524: LD_ADDR_VAR 0 5
79528: PUSH
79529: LD_INT 2
79531: ST_TO_ADDR
// pos := 1 ;
79532: LD_ADDR_VAR 0 6
79536: PUSH
79537: LD_INT 1
79539: ST_TO_ADDR
// end ; if btype = b_barracks then
79540: LD_VAR 0 5
79544: PUSH
79545: LD_INT 5
79547: EQUAL
79548: IFFALSE 79558
// btype := b_armoury ;
79550: LD_ADDR_VAR 0 5
79554: PUSH
79555: LD_INT 4
79557: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79558: LD_VAR 0 5
79562: PUSH
79563: LD_INT 7
79565: PUSH
79566: LD_INT 8
79568: PUSH
79569: EMPTY
79570: LIST
79571: LIST
79572: IN
79573: IFFALSE 79583
// btype := b_lab ;
79575: LD_ADDR_VAR 0 5
79579: PUSH
79580: LD_INT 6
79582: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79583: LD_ADDR_EXP 73
79587: PUSH
79588: LD_EXP 73
79592: PPUSH
79593: LD_VAR 0 3
79597: PUSH
79598: LD_EXP 73
79602: PUSH
79603: LD_VAR 0 3
79607: ARRAY
79608: PUSH
79609: LD_INT 1
79611: PLUS
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: PPUSH
79617: LD_VAR 0 5
79621: PUSH
79622: LD_VAR 0 1
79626: PPUSH
79627: CALL_OW 250
79631: PUSH
79632: LD_VAR 0 1
79636: PPUSH
79637: CALL_OW 251
79641: PUSH
79642: LD_VAR 0 1
79646: PPUSH
79647: CALL_OW 254
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: LIST
79656: LIST
79657: PPUSH
79658: CALL 18548 0 3
79662: ST_TO_ADDR
// if pos = 1 then
79663: LD_VAR 0 6
79667: PUSH
79668: LD_INT 1
79670: EQUAL
79671: IFFALSE 79786
// begin tmp := mc_build_list [ i ] ;
79673: LD_ADDR_VAR 0 7
79677: PUSH
79678: LD_EXP 73
79682: PUSH
79683: LD_VAR 0 3
79687: ARRAY
79688: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79689: LD_VAR 0 7
79693: PPUSH
79694: LD_INT 2
79696: PUSH
79697: LD_INT 30
79699: PUSH
79700: LD_INT 0
79702: PUSH
79703: EMPTY
79704: LIST
79705: LIST
79706: PUSH
79707: LD_INT 30
79709: PUSH
79710: LD_INT 1
79712: PUSH
79713: EMPTY
79714: LIST
79715: LIST
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: LIST
79721: PPUSH
79722: CALL_OW 72
79726: IFFALSE 79736
// pos := 2 ;
79728: LD_ADDR_VAR 0 6
79732: PUSH
79733: LD_INT 2
79735: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
79736: LD_ADDR_VAR 0 7
79740: PUSH
79741: LD_VAR 0 7
79745: PPUSH
79746: LD_VAR 0 6
79750: PPUSH
79751: LD_VAR 0 7
79755: PPUSH
79756: CALL 18874 0 3
79760: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
79761: LD_ADDR_EXP 73
79765: PUSH
79766: LD_EXP 73
79770: PPUSH
79771: LD_VAR 0 3
79775: PPUSH
79776: LD_VAR 0 7
79780: PPUSH
79781: CALL_OW 1
79785: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
79786: LD_VAR 0 1
79790: PUSH
79791: LD_EXP 68
79795: PUSH
79796: LD_VAR 0 3
79800: ARRAY
79801: IN
79802: IFFALSE 79841
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
79804: LD_ADDR_EXP 68
79808: PUSH
79809: LD_EXP 68
79813: PPUSH
79814: LD_VAR 0 3
79818: PPUSH
79819: LD_EXP 68
79823: PUSH
79824: LD_VAR 0 3
79828: ARRAY
79829: PUSH
79830: LD_VAR 0 1
79834: DIFF
79835: PPUSH
79836: CALL_OW 1
79840: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
79841: LD_VAR 0 1
79845: PUSH
79846: LD_EXP 75
79850: PUSH
79851: LD_VAR 0 3
79855: ARRAY
79856: IN
79857: IFFALSE 79896
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
79859: LD_ADDR_EXP 75
79863: PUSH
79864: LD_EXP 75
79868: PPUSH
79869: LD_VAR 0 3
79873: PPUSH
79874: LD_EXP 75
79878: PUSH
79879: LD_VAR 0 3
79883: ARRAY
79884: PUSH
79885: LD_VAR 0 1
79889: DIFF
79890: PPUSH
79891: CALL_OW 1
79895: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
79896: LD_VAR 0 1
79900: PUSH
79901: LD_EXP 87
79905: PUSH
79906: LD_VAR 0 3
79910: ARRAY
79911: IN
79912: IFFALSE 79951
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
79914: LD_ADDR_EXP 87
79918: PUSH
79919: LD_EXP 87
79923: PPUSH
79924: LD_VAR 0 3
79928: PPUSH
79929: LD_EXP 87
79933: PUSH
79934: LD_VAR 0 3
79938: ARRAY
79939: PUSH
79940: LD_VAR 0 1
79944: DIFF
79945: PPUSH
79946: CALL_OW 1
79950: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
79951: LD_VAR 0 1
79955: PUSH
79956: LD_EXP 90
79960: PUSH
79961: LD_VAR 0 3
79965: ARRAY
79966: IN
79967: IFFALSE 80006
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79969: LD_ADDR_EXP 90
79973: PUSH
79974: LD_EXP 90
79978: PPUSH
79979: LD_VAR 0 3
79983: PPUSH
79984: LD_EXP 90
79988: PUSH
79989: LD_VAR 0 3
79993: ARRAY
79994: PUSH
79995: LD_VAR 0 1
79999: DIFF
80000: PPUSH
80001: CALL_OW 1
80005: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
80006: LD_VAR 0 1
80010: PUSH
80011: LD_EXP 77
80015: PUSH
80016: LD_VAR 0 3
80020: ARRAY
80021: IN
80022: IFFALSE 80061
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
80024: LD_ADDR_EXP 77
80028: PUSH
80029: LD_EXP 77
80033: PPUSH
80034: LD_VAR 0 3
80038: PPUSH
80039: LD_EXP 77
80043: PUSH
80044: LD_VAR 0 3
80048: ARRAY
80049: PUSH
80050: LD_VAR 0 1
80054: DIFF
80055: PPUSH
80056: CALL_OW 1
80060: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
80061: LD_VAR 0 1
80065: PUSH
80066: LD_EXP 76
80070: PUSH
80071: LD_VAR 0 3
80075: ARRAY
80076: IN
80077: IFFALSE 80116
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
80079: LD_ADDR_EXP 76
80083: PUSH
80084: LD_EXP 76
80088: PPUSH
80089: LD_VAR 0 3
80093: PPUSH
80094: LD_EXP 76
80098: PUSH
80099: LD_VAR 0 3
80103: ARRAY
80104: PUSH
80105: LD_VAR 0 1
80109: DIFF
80110: PPUSH
80111: CALL_OW 1
80115: ST_TO_ADDR
// end ; break ;
80116: GO 80120
// end ;
80118: GO 78766
80120: POP
80121: POP
// end ;
80122: LD_VAR 0 2
80126: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
80127: LD_INT 0
80129: PPUSH
80130: PPUSH
80131: PPUSH
// if not mc_bases or not skirmish then
80132: LD_EXP 68
80136: NOT
80137: PUSH
80138: LD_EXP 66
80142: NOT
80143: OR
80144: IFFALSE 80148
// exit ;
80146: GO 80363
// for i = 1 to mc_bases do
80148: LD_ADDR_VAR 0 3
80152: PUSH
80153: DOUBLE
80154: LD_INT 1
80156: DEC
80157: ST_TO_ADDR
80158: LD_EXP 68
80162: PUSH
80163: FOR_TO
80164: IFFALSE 80361
// begin if building in mc_construct_list [ i ] then
80166: LD_VAR 0 1
80170: PUSH
80171: LD_EXP 75
80175: PUSH
80176: LD_VAR 0 3
80180: ARRAY
80181: IN
80182: IFFALSE 80359
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80184: LD_ADDR_EXP 75
80188: PUSH
80189: LD_EXP 75
80193: PPUSH
80194: LD_VAR 0 3
80198: PPUSH
80199: LD_EXP 75
80203: PUSH
80204: LD_VAR 0 3
80208: ARRAY
80209: PUSH
80210: LD_VAR 0 1
80214: DIFF
80215: PPUSH
80216: CALL_OW 1
80220: ST_TO_ADDR
// if building in mc_lab [ i ] then
80221: LD_VAR 0 1
80225: PUSH
80226: LD_EXP 101
80230: PUSH
80231: LD_VAR 0 3
80235: ARRAY
80236: IN
80237: IFFALSE 80292
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80239: LD_ADDR_EXP 102
80243: PUSH
80244: LD_EXP 102
80248: PPUSH
80249: LD_VAR 0 3
80253: PPUSH
80254: LD_EXP 102
80258: PUSH
80259: LD_VAR 0 3
80263: ARRAY
80264: PPUSH
80265: LD_INT 1
80267: PPUSH
80268: LD_EXP 102
80272: PUSH
80273: LD_VAR 0 3
80277: ARRAY
80278: PPUSH
80279: LD_INT 0
80281: PPUSH
80282: CALL 17966 0 4
80286: PPUSH
80287: CALL_OW 1
80291: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80292: LD_VAR 0 1
80296: PUSH
80297: LD_EXP 68
80301: PUSH
80302: LD_VAR 0 3
80306: ARRAY
80307: IN
80308: NOT
80309: IFFALSE 80355
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80311: LD_ADDR_EXP 68
80315: PUSH
80316: LD_EXP 68
80320: PPUSH
80321: LD_VAR 0 3
80325: PUSH
80326: LD_EXP 68
80330: PUSH
80331: LD_VAR 0 3
80335: ARRAY
80336: PUSH
80337: LD_INT 1
80339: PLUS
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: PPUSH
80345: LD_VAR 0 1
80349: PPUSH
80350: CALL 18548 0 3
80354: ST_TO_ADDR
// exit ;
80355: POP
80356: POP
80357: GO 80363
// end ; end ;
80359: GO 80163
80361: POP
80362: POP
// end ;
80363: LD_VAR 0 2
80367: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80368: LD_INT 0
80370: PPUSH
80371: PPUSH
80372: PPUSH
80373: PPUSH
80374: PPUSH
80375: PPUSH
80376: PPUSH
// if not mc_bases or not skirmish then
80377: LD_EXP 68
80381: NOT
80382: PUSH
80383: LD_EXP 66
80387: NOT
80388: OR
80389: IFFALSE 80393
// exit ;
80391: GO 81054
// for i = 1 to mc_bases do
80393: LD_ADDR_VAR 0 3
80397: PUSH
80398: DOUBLE
80399: LD_INT 1
80401: DEC
80402: ST_TO_ADDR
80403: LD_EXP 68
80407: PUSH
80408: FOR_TO
80409: IFFALSE 81052
// begin if building in mc_construct_list [ i ] then
80411: LD_VAR 0 1
80415: PUSH
80416: LD_EXP 75
80420: PUSH
80421: LD_VAR 0 3
80425: ARRAY
80426: IN
80427: IFFALSE 81050
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80429: LD_ADDR_EXP 75
80433: PUSH
80434: LD_EXP 75
80438: PPUSH
80439: LD_VAR 0 3
80443: PPUSH
80444: LD_EXP 75
80448: PUSH
80449: LD_VAR 0 3
80453: ARRAY
80454: PUSH
80455: LD_VAR 0 1
80459: DIFF
80460: PPUSH
80461: CALL_OW 1
80465: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80466: LD_ADDR_EXP 68
80470: PUSH
80471: LD_EXP 68
80475: PPUSH
80476: LD_VAR 0 3
80480: PUSH
80481: LD_EXP 68
80485: PUSH
80486: LD_VAR 0 3
80490: ARRAY
80491: PUSH
80492: LD_INT 1
80494: PLUS
80495: PUSH
80496: EMPTY
80497: LIST
80498: LIST
80499: PPUSH
80500: LD_VAR 0 1
80504: PPUSH
80505: CALL 18548 0 3
80509: ST_TO_ADDR
// btype := GetBType ( building ) ;
80510: LD_ADDR_VAR 0 5
80514: PUSH
80515: LD_VAR 0 1
80519: PPUSH
80520: CALL_OW 266
80524: ST_TO_ADDR
// side := GetSide ( building ) ;
80525: LD_ADDR_VAR 0 8
80529: PUSH
80530: LD_VAR 0 1
80534: PPUSH
80535: CALL_OW 255
80539: ST_TO_ADDR
// if btype = b_lab then
80540: LD_VAR 0 5
80544: PUSH
80545: LD_INT 6
80547: EQUAL
80548: IFFALSE 80598
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80550: LD_ADDR_EXP 101
80554: PUSH
80555: LD_EXP 101
80559: PPUSH
80560: LD_VAR 0 3
80564: PUSH
80565: LD_EXP 101
80569: PUSH
80570: LD_VAR 0 3
80574: ARRAY
80575: PUSH
80576: LD_INT 1
80578: PLUS
80579: PUSH
80580: EMPTY
80581: LIST
80582: LIST
80583: PPUSH
80584: LD_VAR 0 1
80588: PPUSH
80589: CALL 18548 0 3
80593: ST_TO_ADDR
// exit ;
80594: POP
80595: POP
80596: GO 81054
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80598: LD_VAR 0 5
80602: PUSH
80603: LD_INT 0
80605: PUSH
80606: LD_INT 2
80608: PUSH
80609: LD_INT 4
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: LIST
80616: IN
80617: IFFALSE 80741
// begin if btype = b_armoury then
80619: LD_VAR 0 5
80623: PUSH
80624: LD_INT 4
80626: EQUAL
80627: IFFALSE 80637
// btype := b_barracks ;
80629: LD_ADDR_VAR 0 5
80633: PUSH
80634: LD_INT 5
80636: ST_TO_ADDR
// if btype = b_depot then
80637: LD_VAR 0 5
80641: PUSH
80642: LD_INT 0
80644: EQUAL
80645: IFFALSE 80655
// btype := b_warehouse ;
80647: LD_ADDR_VAR 0 5
80651: PUSH
80652: LD_INT 1
80654: ST_TO_ADDR
// if btype = b_workshop then
80655: LD_VAR 0 5
80659: PUSH
80660: LD_INT 2
80662: EQUAL
80663: IFFALSE 80673
// btype := b_factory ;
80665: LD_ADDR_VAR 0 5
80669: PUSH
80670: LD_INT 3
80672: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
80673: LD_VAR 0 5
80677: PPUSH
80678: LD_VAR 0 8
80682: PPUSH
80683: CALL_OW 323
80687: PUSH
80688: LD_INT 1
80690: EQUAL
80691: IFFALSE 80737
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
80693: LD_ADDR_EXP 100
80697: PUSH
80698: LD_EXP 100
80702: PPUSH
80703: LD_VAR 0 3
80707: PUSH
80708: LD_EXP 100
80712: PUSH
80713: LD_VAR 0 3
80717: ARRAY
80718: PUSH
80719: LD_INT 1
80721: PLUS
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: PPUSH
80727: LD_VAR 0 1
80731: PPUSH
80732: CALL 18548 0 3
80736: ST_TO_ADDR
// exit ;
80737: POP
80738: POP
80739: GO 81054
// end ; if btype in [ b_bunker , b_turret ] then
80741: LD_VAR 0 5
80745: PUSH
80746: LD_INT 32
80748: PUSH
80749: LD_INT 33
80751: PUSH
80752: EMPTY
80753: LIST
80754: LIST
80755: IN
80756: IFFALSE 81046
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
80758: LD_ADDR_EXP 76
80762: PUSH
80763: LD_EXP 76
80767: PPUSH
80768: LD_VAR 0 3
80772: PUSH
80773: LD_EXP 76
80777: PUSH
80778: LD_VAR 0 3
80782: ARRAY
80783: PUSH
80784: LD_INT 1
80786: PLUS
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PPUSH
80792: LD_VAR 0 1
80796: PPUSH
80797: CALL 18548 0 3
80801: ST_TO_ADDR
// if btype = b_bunker then
80802: LD_VAR 0 5
80806: PUSH
80807: LD_INT 32
80809: EQUAL
80810: IFFALSE 81046
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80812: LD_ADDR_EXP 77
80816: PUSH
80817: LD_EXP 77
80821: PPUSH
80822: LD_VAR 0 3
80826: PUSH
80827: LD_EXP 77
80831: PUSH
80832: LD_VAR 0 3
80836: ARRAY
80837: PUSH
80838: LD_INT 1
80840: PLUS
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PPUSH
80846: LD_VAR 0 1
80850: PPUSH
80851: CALL 18548 0 3
80855: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
80856: LD_ADDR_VAR 0 6
80860: PUSH
80861: LD_EXP 68
80865: PUSH
80866: LD_VAR 0 3
80870: ARRAY
80871: PPUSH
80872: LD_INT 25
80874: PUSH
80875: LD_INT 1
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 3
80884: PUSH
80885: LD_INT 54
80887: PUSH
80888: EMPTY
80889: LIST
80890: PUSH
80891: EMPTY
80892: LIST
80893: LIST
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PPUSH
80899: CALL_OW 72
80903: ST_TO_ADDR
// if tmp then
80904: LD_VAR 0 6
80908: IFFALSE 80914
// exit ;
80910: POP
80911: POP
80912: GO 81054
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80914: LD_ADDR_VAR 0 6
80918: PUSH
80919: LD_EXP 68
80923: PUSH
80924: LD_VAR 0 3
80928: ARRAY
80929: PPUSH
80930: LD_INT 2
80932: PUSH
80933: LD_INT 30
80935: PUSH
80936: LD_INT 4
80938: PUSH
80939: EMPTY
80940: LIST
80941: LIST
80942: PUSH
80943: LD_INT 30
80945: PUSH
80946: LD_INT 5
80948: PUSH
80949: EMPTY
80950: LIST
80951: LIST
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: LIST
80957: PPUSH
80958: CALL_OW 72
80962: ST_TO_ADDR
// if not tmp then
80963: LD_VAR 0 6
80967: NOT
80968: IFFALSE 80974
// exit ;
80970: POP
80971: POP
80972: GO 81054
// for j in tmp do
80974: LD_ADDR_VAR 0 4
80978: PUSH
80979: LD_VAR 0 6
80983: PUSH
80984: FOR_IN
80985: IFFALSE 81044
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
80987: LD_ADDR_VAR 0 7
80991: PUSH
80992: LD_VAR 0 4
80996: PPUSH
80997: CALL_OW 313
81001: PPUSH
81002: LD_INT 25
81004: PUSH
81005: LD_INT 1
81007: PUSH
81008: EMPTY
81009: LIST
81010: LIST
81011: PPUSH
81012: CALL_OW 72
81016: ST_TO_ADDR
// if units then
81017: LD_VAR 0 7
81021: IFFALSE 81042
// begin ComExitBuilding ( units [ 1 ] ) ;
81023: LD_VAR 0 7
81027: PUSH
81028: LD_INT 1
81030: ARRAY
81031: PPUSH
81032: CALL_OW 122
// exit ;
81036: POP
81037: POP
81038: POP
81039: POP
81040: GO 81054
// end ; end ;
81042: GO 80984
81044: POP
81045: POP
// end ; end ; exit ;
81046: POP
81047: POP
81048: GO 81054
// end ; end ;
81050: GO 80408
81052: POP
81053: POP
// end ;
81054: LD_VAR 0 2
81058: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
81059: LD_INT 0
81061: PPUSH
81062: PPUSH
81063: PPUSH
81064: PPUSH
81065: PPUSH
81066: PPUSH
81067: PPUSH
// if not mc_bases or not skirmish then
81068: LD_EXP 68
81072: NOT
81073: PUSH
81074: LD_EXP 66
81078: NOT
81079: OR
81080: IFFALSE 81084
// exit ;
81082: GO 81315
// btype := GetBType ( building ) ;
81084: LD_ADDR_VAR 0 6
81088: PUSH
81089: LD_VAR 0 1
81093: PPUSH
81094: CALL_OW 266
81098: ST_TO_ADDR
// x := GetX ( building ) ;
81099: LD_ADDR_VAR 0 7
81103: PUSH
81104: LD_VAR 0 1
81108: PPUSH
81109: CALL_OW 250
81113: ST_TO_ADDR
// y := GetY ( building ) ;
81114: LD_ADDR_VAR 0 8
81118: PUSH
81119: LD_VAR 0 1
81123: PPUSH
81124: CALL_OW 251
81128: ST_TO_ADDR
// d := GetDir ( building ) ;
81129: LD_ADDR_VAR 0 9
81133: PUSH
81134: LD_VAR 0 1
81138: PPUSH
81139: CALL_OW 254
81143: ST_TO_ADDR
// for i = 1 to mc_bases do
81144: LD_ADDR_VAR 0 4
81148: PUSH
81149: DOUBLE
81150: LD_INT 1
81152: DEC
81153: ST_TO_ADDR
81154: LD_EXP 68
81158: PUSH
81159: FOR_TO
81160: IFFALSE 81313
// begin if not mc_build_list [ i ] then
81162: LD_EXP 73
81166: PUSH
81167: LD_VAR 0 4
81171: ARRAY
81172: NOT
81173: IFFALSE 81177
// continue ;
81175: GO 81159
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
81177: LD_VAR 0 6
81181: PUSH
81182: LD_VAR 0 7
81186: PUSH
81187: LD_VAR 0 8
81191: PUSH
81192: LD_VAR 0 9
81196: PUSH
81197: EMPTY
81198: LIST
81199: LIST
81200: LIST
81201: LIST
81202: PPUSH
81203: LD_EXP 73
81207: PUSH
81208: LD_VAR 0 4
81212: ARRAY
81213: PUSH
81214: LD_INT 1
81216: ARRAY
81217: PPUSH
81218: CALL 24755 0 2
81222: IFFALSE 81311
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
81224: LD_ADDR_EXP 73
81228: PUSH
81229: LD_EXP 73
81233: PPUSH
81234: LD_VAR 0 4
81238: PPUSH
81239: LD_EXP 73
81243: PUSH
81244: LD_VAR 0 4
81248: ARRAY
81249: PPUSH
81250: LD_INT 1
81252: PPUSH
81253: CALL_OW 3
81257: PPUSH
81258: CALL_OW 1
81262: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81263: LD_ADDR_EXP 75
81267: PUSH
81268: LD_EXP 75
81272: PPUSH
81273: LD_VAR 0 4
81277: PUSH
81278: LD_EXP 75
81282: PUSH
81283: LD_VAR 0 4
81287: ARRAY
81288: PUSH
81289: LD_INT 1
81291: PLUS
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: PPUSH
81297: LD_VAR 0 1
81301: PPUSH
81302: CALL 18548 0 3
81306: ST_TO_ADDR
// exit ;
81307: POP
81308: POP
81309: GO 81315
// end ; end ;
81311: GO 81159
81313: POP
81314: POP
// end ;
81315: LD_VAR 0 3
81319: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81320: LD_INT 0
81322: PPUSH
81323: PPUSH
81324: PPUSH
// if not mc_bases or not skirmish then
81325: LD_EXP 68
81329: NOT
81330: PUSH
81331: LD_EXP 66
81335: NOT
81336: OR
81337: IFFALSE 81341
// exit ;
81339: GO 81531
// for i = 1 to mc_bases do
81341: LD_ADDR_VAR 0 4
81345: PUSH
81346: DOUBLE
81347: LD_INT 1
81349: DEC
81350: ST_TO_ADDR
81351: LD_EXP 68
81355: PUSH
81356: FOR_TO
81357: IFFALSE 81444
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81359: LD_VAR 0 1
81363: PUSH
81364: LD_EXP 76
81368: PUSH
81369: LD_VAR 0 4
81373: ARRAY
81374: IN
81375: PUSH
81376: LD_VAR 0 1
81380: PUSH
81381: LD_EXP 77
81385: PUSH
81386: LD_VAR 0 4
81390: ARRAY
81391: IN
81392: NOT
81393: AND
81394: IFFALSE 81442
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81396: LD_ADDR_EXP 77
81400: PUSH
81401: LD_EXP 77
81405: PPUSH
81406: LD_VAR 0 4
81410: PUSH
81411: LD_EXP 77
81415: PUSH
81416: LD_VAR 0 4
81420: ARRAY
81421: PUSH
81422: LD_INT 1
81424: PLUS
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PPUSH
81430: LD_VAR 0 1
81434: PPUSH
81435: CALL 18548 0 3
81439: ST_TO_ADDR
// break ;
81440: GO 81444
// end ; end ;
81442: GO 81356
81444: POP
81445: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
81446: LD_VAR 0 1
81450: PPUSH
81451: CALL_OW 257
81455: PUSH
81456: LD_EXP 94
81460: IN
81461: PUSH
81462: LD_VAR 0 1
81466: PPUSH
81467: CALL_OW 266
81471: PUSH
81472: LD_INT 5
81474: EQUAL
81475: AND
81476: PUSH
81477: LD_VAR 0 2
81481: PPUSH
81482: CALL_OW 110
81486: PUSH
81487: LD_INT 18
81489: NONEQUAL
81490: AND
81491: IFFALSE 81531
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81493: LD_VAR 0 2
81497: PPUSH
81498: CALL_OW 257
81502: PUSH
81503: LD_INT 5
81505: PUSH
81506: LD_INT 8
81508: PUSH
81509: LD_INT 9
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: LIST
81516: IN
81517: IFFALSE 81531
// SetClass ( unit , 1 ) ;
81519: LD_VAR 0 2
81523: PPUSH
81524: LD_INT 1
81526: PPUSH
81527: CALL_OW 336
// end ;
81531: LD_VAR 0 3
81535: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81536: LD_INT 0
81538: PPUSH
81539: PPUSH
// if not mc_bases or not skirmish then
81540: LD_EXP 68
81544: NOT
81545: PUSH
81546: LD_EXP 66
81550: NOT
81551: OR
81552: IFFALSE 81556
// exit ;
81554: GO 81672
// if GetLives ( abandoned_vehicle ) > 250 then
81556: LD_VAR 0 2
81560: PPUSH
81561: CALL_OW 256
81565: PUSH
81566: LD_INT 250
81568: GREATER
81569: IFFALSE 81573
// exit ;
81571: GO 81672
// for i = 1 to mc_bases do
81573: LD_ADDR_VAR 0 6
81577: PUSH
81578: DOUBLE
81579: LD_INT 1
81581: DEC
81582: ST_TO_ADDR
81583: LD_EXP 68
81587: PUSH
81588: FOR_TO
81589: IFFALSE 81670
// begin if driver in mc_bases [ i ] then
81591: LD_VAR 0 1
81595: PUSH
81596: LD_EXP 68
81600: PUSH
81601: LD_VAR 0 6
81605: ARRAY
81606: IN
81607: IFFALSE 81668
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81609: LD_VAR 0 1
81613: PPUSH
81614: LD_EXP 68
81618: PUSH
81619: LD_VAR 0 6
81623: ARRAY
81624: PPUSH
81625: LD_INT 2
81627: PUSH
81628: LD_INT 30
81630: PUSH
81631: LD_INT 0
81633: PUSH
81634: EMPTY
81635: LIST
81636: LIST
81637: PUSH
81638: LD_INT 30
81640: PUSH
81641: LD_INT 1
81643: PUSH
81644: EMPTY
81645: LIST
81646: LIST
81647: PUSH
81648: EMPTY
81649: LIST
81650: LIST
81651: LIST
81652: PPUSH
81653: CALL_OW 72
81657: PUSH
81658: LD_INT 1
81660: ARRAY
81661: PPUSH
81662: CALL 50791 0 2
// break ;
81666: GO 81670
// end ; end ;
81668: GO 81588
81670: POP
81671: POP
// end ; end_of_file end_of_file
81672: LD_VAR 0 5
81676: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
81677: LD_INT 0
81679: PPUSH
// if p2 = 100 then
81680: LD_VAR 0 2
81684: PUSH
81685: LD_INT 100
81687: EQUAL
81688: IFFALSE 82637
// begin if not StreamModeActive then
81690: LD_EXP 112
81694: NOT
81695: IFFALSE 81705
// StreamModeActive := true ;
81697: LD_ADDR_EXP 112
81701: PUSH
81702: LD_INT 1
81704: ST_TO_ADDR
// if p3 = 0 then
81705: LD_VAR 0 3
81709: PUSH
81710: LD_INT 0
81712: EQUAL
81713: IFFALSE 81719
// InitStreamMode ;
81715: CALL 82797 0 0
// if p3 = 1 then
81719: LD_VAR 0 3
81723: PUSH
81724: LD_INT 1
81726: EQUAL
81727: IFFALSE 81737
// sRocket := true ;
81729: LD_ADDR_EXP 117
81733: PUSH
81734: LD_INT 1
81736: ST_TO_ADDR
// if p3 = 2 then
81737: LD_VAR 0 3
81741: PUSH
81742: LD_INT 2
81744: EQUAL
81745: IFFALSE 81755
// sSpeed := true ;
81747: LD_ADDR_EXP 116
81751: PUSH
81752: LD_INT 1
81754: ST_TO_ADDR
// if p3 = 3 then
81755: LD_VAR 0 3
81759: PUSH
81760: LD_INT 3
81762: EQUAL
81763: IFFALSE 81773
// sEngine := true ;
81765: LD_ADDR_EXP 118
81769: PUSH
81770: LD_INT 1
81772: ST_TO_ADDR
// if p3 = 4 then
81773: LD_VAR 0 3
81777: PUSH
81778: LD_INT 4
81780: EQUAL
81781: IFFALSE 81791
// sSpec := true ;
81783: LD_ADDR_EXP 115
81787: PUSH
81788: LD_INT 1
81790: ST_TO_ADDR
// if p3 = 5 then
81791: LD_VAR 0 3
81795: PUSH
81796: LD_INT 5
81798: EQUAL
81799: IFFALSE 81809
// sLevel := true ;
81801: LD_ADDR_EXP 119
81805: PUSH
81806: LD_INT 1
81808: ST_TO_ADDR
// if p3 = 6 then
81809: LD_VAR 0 3
81813: PUSH
81814: LD_INT 6
81816: EQUAL
81817: IFFALSE 81827
// sArmoury := true ;
81819: LD_ADDR_EXP 120
81823: PUSH
81824: LD_INT 1
81826: ST_TO_ADDR
// if p3 = 7 then
81827: LD_VAR 0 3
81831: PUSH
81832: LD_INT 7
81834: EQUAL
81835: IFFALSE 81845
// sRadar := true ;
81837: LD_ADDR_EXP 121
81841: PUSH
81842: LD_INT 1
81844: ST_TO_ADDR
// if p3 = 8 then
81845: LD_VAR 0 3
81849: PUSH
81850: LD_INT 8
81852: EQUAL
81853: IFFALSE 81863
// sBunker := true ;
81855: LD_ADDR_EXP 122
81859: PUSH
81860: LD_INT 1
81862: ST_TO_ADDR
// if p3 = 9 then
81863: LD_VAR 0 3
81867: PUSH
81868: LD_INT 9
81870: EQUAL
81871: IFFALSE 81881
// sHack := true ;
81873: LD_ADDR_EXP 123
81877: PUSH
81878: LD_INT 1
81880: ST_TO_ADDR
// if p3 = 10 then
81881: LD_VAR 0 3
81885: PUSH
81886: LD_INT 10
81888: EQUAL
81889: IFFALSE 81899
// sFire := true ;
81891: LD_ADDR_EXP 124
81895: PUSH
81896: LD_INT 1
81898: ST_TO_ADDR
// if p3 = 11 then
81899: LD_VAR 0 3
81903: PUSH
81904: LD_INT 11
81906: EQUAL
81907: IFFALSE 81917
// sRefresh := true ;
81909: LD_ADDR_EXP 125
81913: PUSH
81914: LD_INT 1
81916: ST_TO_ADDR
// if p3 = 12 then
81917: LD_VAR 0 3
81921: PUSH
81922: LD_INT 12
81924: EQUAL
81925: IFFALSE 81935
// sExp := true ;
81927: LD_ADDR_EXP 126
81931: PUSH
81932: LD_INT 1
81934: ST_TO_ADDR
// if p3 = 13 then
81935: LD_VAR 0 3
81939: PUSH
81940: LD_INT 13
81942: EQUAL
81943: IFFALSE 81953
// sDepot := true ;
81945: LD_ADDR_EXP 127
81949: PUSH
81950: LD_INT 1
81952: ST_TO_ADDR
// if p3 = 14 then
81953: LD_VAR 0 3
81957: PUSH
81958: LD_INT 14
81960: EQUAL
81961: IFFALSE 81971
// sFlag := true ;
81963: LD_ADDR_EXP 128
81967: PUSH
81968: LD_INT 1
81970: ST_TO_ADDR
// if p3 = 15 then
81971: LD_VAR 0 3
81975: PUSH
81976: LD_INT 15
81978: EQUAL
81979: IFFALSE 81989
// sKamikadze := true ;
81981: LD_ADDR_EXP 136
81985: PUSH
81986: LD_INT 1
81988: ST_TO_ADDR
// if p3 = 16 then
81989: LD_VAR 0 3
81993: PUSH
81994: LD_INT 16
81996: EQUAL
81997: IFFALSE 82007
// sTroll := true ;
81999: LD_ADDR_EXP 137
82003: PUSH
82004: LD_INT 1
82006: ST_TO_ADDR
// if p3 = 17 then
82007: LD_VAR 0 3
82011: PUSH
82012: LD_INT 17
82014: EQUAL
82015: IFFALSE 82025
// sSlow := true ;
82017: LD_ADDR_EXP 138
82021: PUSH
82022: LD_INT 1
82024: ST_TO_ADDR
// if p3 = 18 then
82025: LD_VAR 0 3
82029: PUSH
82030: LD_INT 18
82032: EQUAL
82033: IFFALSE 82043
// sLack := true ;
82035: LD_ADDR_EXP 139
82039: PUSH
82040: LD_INT 1
82042: ST_TO_ADDR
// if p3 = 19 then
82043: LD_VAR 0 3
82047: PUSH
82048: LD_INT 19
82050: EQUAL
82051: IFFALSE 82061
// sTank := true ;
82053: LD_ADDR_EXP 141
82057: PUSH
82058: LD_INT 1
82060: ST_TO_ADDR
// if p3 = 20 then
82061: LD_VAR 0 3
82065: PUSH
82066: LD_INT 20
82068: EQUAL
82069: IFFALSE 82079
// sRemote := true ;
82071: LD_ADDR_EXP 142
82075: PUSH
82076: LD_INT 1
82078: ST_TO_ADDR
// if p3 = 21 then
82079: LD_VAR 0 3
82083: PUSH
82084: LD_INT 21
82086: EQUAL
82087: IFFALSE 82097
// sPowell := true ;
82089: LD_ADDR_EXP 143
82093: PUSH
82094: LD_INT 1
82096: ST_TO_ADDR
// if p3 = 22 then
82097: LD_VAR 0 3
82101: PUSH
82102: LD_INT 22
82104: EQUAL
82105: IFFALSE 82115
// sTeleport := true ;
82107: LD_ADDR_EXP 146
82111: PUSH
82112: LD_INT 1
82114: ST_TO_ADDR
// if p3 = 23 then
82115: LD_VAR 0 3
82119: PUSH
82120: LD_INT 23
82122: EQUAL
82123: IFFALSE 82133
// sOilTower := true ;
82125: LD_ADDR_EXP 148
82129: PUSH
82130: LD_INT 1
82132: ST_TO_ADDR
// if p3 = 24 then
82133: LD_VAR 0 3
82137: PUSH
82138: LD_INT 24
82140: EQUAL
82141: IFFALSE 82151
// sShovel := true ;
82143: LD_ADDR_EXP 149
82147: PUSH
82148: LD_INT 1
82150: ST_TO_ADDR
// if p3 = 25 then
82151: LD_VAR 0 3
82155: PUSH
82156: LD_INT 25
82158: EQUAL
82159: IFFALSE 82169
// sSheik := true ;
82161: LD_ADDR_EXP 150
82165: PUSH
82166: LD_INT 1
82168: ST_TO_ADDR
// if p3 = 26 then
82169: LD_VAR 0 3
82173: PUSH
82174: LD_INT 26
82176: EQUAL
82177: IFFALSE 82187
// sEarthquake := true ;
82179: LD_ADDR_EXP 152
82183: PUSH
82184: LD_INT 1
82186: ST_TO_ADDR
// if p3 = 27 then
82187: LD_VAR 0 3
82191: PUSH
82192: LD_INT 27
82194: EQUAL
82195: IFFALSE 82205
// sAI := true ;
82197: LD_ADDR_EXP 153
82201: PUSH
82202: LD_INT 1
82204: ST_TO_ADDR
// if p3 = 28 then
82205: LD_VAR 0 3
82209: PUSH
82210: LD_INT 28
82212: EQUAL
82213: IFFALSE 82223
// sCargo := true ;
82215: LD_ADDR_EXP 156
82219: PUSH
82220: LD_INT 1
82222: ST_TO_ADDR
// if p3 = 29 then
82223: LD_VAR 0 3
82227: PUSH
82228: LD_INT 29
82230: EQUAL
82231: IFFALSE 82241
// sDLaser := true ;
82233: LD_ADDR_EXP 157
82237: PUSH
82238: LD_INT 1
82240: ST_TO_ADDR
// if p3 = 30 then
82241: LD_VAR 0 3
82245: PUSH
82246: LD_INT 30
82248: EQUAL
82249: IFFALSE 82259
// sExchange := true ;
82251: LD_ADDR_EXP 158
82255: PUSH
82256: LD_INT 1
82258: ST_TO_ADDR
// if p3 = 31 then
82259: LD_VAR 0 3
82263: PUSH
82264: LD_INT 31
82266: EQUAL
82267: IFFALSE 82277
// sFac := true ;
82269: LD_ADDR_EXP 159
82273: PUSH
82274: LD_INT 1
82276: ST_TO_ADDR
// if p3 = 32 then
82277: LD_VAR 0 3
82281: PUSH
82282: LD_INT 32
82284: EQUAL
82285: IFFALSE 82295
// sPower := true ;
82287: LD_ADDR_EXP 160
82291: PUSH
82292: LD_INT 1
82294: ST_TO_ADDR
// if p3 = 33 then
82295: LD_VAR 0 3
82299: PUSH
82300: LD_INT 33
82302: EQUAL
82303: IFFALSE 82313
// sRandom := true ;
82305: LD_ADDR_EXP 161
82309: PUSH
82310: LD_INT 1
82312: ST_TO_ADDR
// if p3 = 34 then
82313: LD_VAR 0 3
82317: PUSH
82318: LD_INT 34
82320: EQUAL
82321: IFFALSE 82331
// sShield := true ;
82323: LD_ADDR_EXP 162
82327: PUSH
82328: LD_INT 1
82330: ST_TO_ADDR
// if p3 = 35 then
82331: LD_VAR 0 3
82335: PUSH
82336: LD_INT 35
82338: EQUAL
82339: IFFALSE 82349
// sTime := true ;
82341: LD_ADDR_EXP 163
82345: PUSH
82346: LD_INT 1
82348: ST_TO_ADDR
// if p3 = 36 then
82349: LD_VAR 0 3
82353: PUSH
82354: LD_INT 36
82356: EQUAL
82357: IFFALSE 82367
// sTools := true ;
82359: LD_ADDR_EXP 164
82363: PUSH
82364: LD_INT 1
82366: ST_TO_ADDR
// if p3 = 101 then
82367: LD_VAR 0 3
82371: PUSH
82372: LD_INT 101
82374: EQUAL
82375: IFFALSE 82385
// sSold := true ;
82377: LD_ADDR_EXP 129
82381: PUSH
82382: LD_INT 1
82384: ST_TO_ADDR
// if p3 = 102 then
82385: LD_VAR 0 3
82389: PUSH
82390: LD_INT 102
82392: EQUAL
82393: IFFALSE 82403
// sDiff := true ;
82395: LD_ADDR_EXP 130
82399: PUSH
82400: LD_INT 1
82402: ST_TO_ADDR
// if p3 = 103 then
82403: LD_VAR 0 3
82407: PUSH
82408: LD_INT 103
82410: EQUAL
82411: IFFALSE 82421
// sFog := true ;
82413: LD_ADDR_EXP 133
82417: PUSH
82418: LD_INT 1
82420: ST_TO_ADDR
// if p3 = 104 then
82421: LD_VAR 0 3
82425: PUSH
82426: LD_INT 104
82428: EQUAL
82429: IFFALSE 82439
// sReset := true ;
82431: LD_ADDR_EXP 134
82435: PUSH
82436: LD_INT 1
82438: ST_TO_ADDR
// if p3 = 105 then
82439: LD_VAR 0 3
82443: PUSH
82444: LD_INT 105
82446: EQUAL
82447: IFFALSE 82457
// sSun := true ;
82449: LD_ADDR_EXP 135
82453: PUSH
82454: LD_INT 1
82456: ST_TO_ADDR
// if p3 = 106 then
82457: LD_VAR 0 3
82461: PUSH
82462: LD_INT 106
82464: EQUAL
82465: IFFALSE 82475
// sTiger := true ;
82467: LD_ADDR_EXP 131
82471: PUSH
82472: LD_INT 1
82474: ST_TO_ADDR
// if p3 = 107 then
82475: LD_VAR 0 3
82479: PUSH
82480: LD_INT 107
82482: EQUAL
82483: IFFALSE 82493
// sBomb := true ;
82485: LD_ADDR_EXP 132
82489: PUSH
82490: LD_INT 1
82492: ST_TO_ADDR
// if p3 = 108 then
82493: LD_VAR 0 3
82497: PUSH
82498: LD_INT 108
82500: EQUAL
82501: IFFALSE 82511
// sWound := true ;
82503: LD_ADDR_EXP 140
82507: PUSH
82508: LD_INT 1
82510: ST_TO_ADDR
// if p3 = 109 then
82511: LD_VAR 0 3
82515: PUSH
82516: LD_INT 109
82518: EQUAL
82519: IFFALSE 82529
// sBetray := true ;
82521: LD_ADDR_EXP 144
82525: PUSH
82526: LD_INT 1
82528: ST_TO_ADDR
// if p3 = 110 then
82529: LD_VAR 0 3
82533: PUSH
82534: LD_INT 110
82536: EQUAL
82537: IFFALSE 82547
// sContamin := true ;
82539: LD_ADDR_EXP 145
82543: PUSH
82544: LD_INT 1
82546: ST_TO_ADDR
// if p3 = 111 then
82547: LD_VAR 0 3
82551: PUSH
82552: LD_INT 111
82554: EQUAL
82555: IFFALSE 82565
// sOil := true ;
82557: LD_ADDR_EXP 147
82561: PUSH
82562: LD_INT 1
82564: ST_TO_ADDR
// if p3 = 112 then
82565: LD_VAR 0 3
82569: PUSH
82570: LD_INT 112
82572: EQUAL
82573: IFFALSE 82583
// sStu := true ;
82575: LD_ADDR_EXP 151
82579: PUSH
82580: LD_INT 1
82582: ST_TO_ADDR
// if p3 = 113 then
82583: LD_VAR 0 3
82587: PUSH
82588: LD_INT 113
82590: EQUAL
82591: IFFALSE 82601
// sBazooka := true ;
82593: LD_ADDR_EXP 154
82597: PUSH
82598: LD_INT 1
82600: ST_TO_ADDR
// if p3 = 114 then
82601: LD_VAR 0 3
82605: PUSH
82606: LD_INT 114
82608: EQUAL
82609: IFFALSE 82619
// sMortar := true ;
82611: LD_ADDR_EXP 155
82615: PUSH
82616: LD_INT 1
82618: ST_TO_ADDR
// if p3 = 115 then
82619: LD_VAR 0 3
82623: PUSH
82624: LD_INT 115
82626: EQUAL
82627: IFFALSE 82637
// sRanger := true ;
82629: LD_ADDR_EXP 165
82633: PUSH
82634: LD_INT 1
82636: ST_TO_ADDR
// end ; if p2 = 101 then
82637: LD_VAR 0 2
82641: PUSH
82642: LD_INT 101
82644: EQUAL
82645: IFFALSE 82773
// begin case p3 of 1 :
82647: LD_VAR 0 3
82651: PUSH
82652: LD_INT 1
82654: DOUBLE
82655: EQUAL
82656: IFTRUE 82660
82658: GO 82667
82660: POP
// hHackUnlimitedResources ; 2 :
82661: CALL 93810 0 0
82665: GO 82773
82667: LD_INT 2
82669: DOUBLE
82670: EQUAL
82671: IFTRUE 82675
82673: GO 82682
82675: POP
// hHackSetLevel10 ; 3 :
82676: CALL 93943 0 0
82680: GO 82773
82682: LD_INT 3
82684: DOUBLE
82685: EQUAL
82686: IFTRUE 82690
82688: GO 82697
82690: POP
// hHackSetLevel10YourUnits ; 4 :
82691: CALL 94028 0 0
82695: GO 82773
82697: LD_INT 4
82699: DOUBLE
82700: EQUAL
82701: IFTRUE 82705
82703: GO 82712
82705: POP
// hHackInvincible ; 5 :
82706: CALL 94476 0 0
82710: GO 82773
82712: LD_INT 5
82714: DOUBLE
82715: EQUAL
82716: IFTRUE 82720
82718: GO 82727
82720: POP
// hHackInvisible ; 6 :
82721: CALL 94587 0 0
82725: GO 82773
82727: LD_INT 6
82729: DOUBLE
82730: EQUAL
82731: IFTRUE 82735
82733: GO 82742
82735: POP
// hHackChangeYourSide ; 7 :
82736: CALL 94644 0 0
82740: GO 82773
82742: LD_INT 7
82744: DOUBLE
82745: EQUAL
82746: IFTRUE 82750
82748: GO 82757
82750: POP
// hHackChangeUnitSide ; 8 :
82751: CALL 94686 0 0
82755: GO 82773
82757: LD_INT 8
82759: DOUBLE
82760: EQUAL
82761: IFTRUE 82765
82763: GO 82772
82765: POP
// hHackFog ; end ;
82766: CALL 94787 0 0
82770: GO 82773
82772: POP
// end ; end ;
82773: LD_VAR 0 7
82777: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
82778: GO 82780
82780: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
82781: LD_STRING initStreamRollete();
82783: PPUSH
82784: CALL_OW 559
// InitStreamMode ;
82788: CALL 82797 0 0
// DefineStreamItems ( ) ;
82792: CALL 83237 0 0
// end ;
82796: END
// function InitStreamMode ; begin
82797: LD_INT 0
82799: PPUSH
// streamModeActive := false ;
82800: LD_ADDR_EXP 112
82804: PUSH
82805: LD_INT 0
82807: ST_TO_ADDR
// normalCounter := 36 ;
82808: LD_ADDR_EXP 113
82812: PUSH
82813: LD_INT 36
82815: ST_TO_ADDR
// hardcoreCounter := 16 ;
82816: LD_ADDR_EXP 114
82820: PUSH
82821: LD_INT 16
82823: ST_TO_ADDR
// sRocket := false ;
82824: LD_ADDR_EXP 117
82828: PUSH
82829: LD_INT 0
82831: ST_TO_ADDR
// sSpeed := false ;
82832: LD_ADDR_EXP 116
82836: PUSH
82837: LD_INT 0
82839: ST_TO_ADDR
// sEngine := false ;
82840: LD_ADDR_EXP 118
82844: PUSH
82845: LD_INT 0
82847: ST_TO_ADDR
// sSpec := false ;
82848: LD_ADDR_EXP 115
82852: PUSH
82853: LD_INT 0
82855: ST_TO_ADDR
// sLevel := false ;
82856: LD_ADDR_EXP 119
82860: PUSH
82861: LD_INT 0
82863: ST_TO_ADDR
// sArmoury := false ;
82864: LD_ADDR_EXP 120
82868: PUSH
82869: LD_INT 0
82871: ST_TO_ADDR
// sRadar := false ;
82872: LD_ADDR_EXP 121
82876: PUSH
82877: LD_INT 0
82879: ST_TO_ADDR
// sBunker := false ;
82880: LD_ADDR_EXP 122
82884: PUSH
82885: LD_INT 0
82887: ST_TO_ADDR
// sHack := false ;
82888: LD_ADDR_EXP 123
82892: PUSH
82893: LD_INT 0
82895: ST_TO_ADDR
// sFire := false ;
82896: LD_ADDR_EXP 124
82900: PUSH
82901: LD_INT 0
82903: ST_TO_ADDR
// sRefresh := false ;
82904: LD_ADDR_EXP 125
82908: PUSH
82909: LD_INT 0
82911: ST_TO_ADDR
// sExp := false ;
82912: LD_ADDR_EXP 126
82916: PUSH
82917: LD_INT 0
82919: ST_TO_ADDR
// sDepot := false ;
82920: LD_ADDR_EXP 127
82924: PUSH
82925: LD_INT 0
82927: ST_TO_ADDR
// sFlag := false ;
82928: LD_ADDR_EXP 128
82932: PUSH
82933: LD_INT 0
82935: ST_TO_ADDR
// sKamikadze := false ;
82936: LD_ADDR_EXP 136
82940: PUSH
82941: LD_INT 0
82943: ST_TO_ADDR
// sTroll := false ;
82944: LD_ADDR_EXP 137
82948: PUSH
82949: LD_INT 0
82951: ST_TO_ADDR
// sSlow := false ;
82952: LD_ADDR_EXP 138
82956: PUSH
82957: LD_INT 0
82959: ST_TO_ADDR
// sLack := false ;
82960: LD_ADDR_EXP 139
82964: PUSH
82965: LD_INT 0
82967: ST_TO_ADDR
// sTank := false ;
82968: LD_ADDR_EXP 141
82972: PUSH
82973: LD_INT 0
82975: ST_TO_ADDR
// sRemote := false ;
82976: LD_ADDR_EXP 142
82980: PUSH
82981: LD_INT 0
82983: ST_TO_ADDR
// sPowell := false ;
82984: LD_ADDR_EXP 143
82988: PUSH
82989: LD_INT 0
82991: ST_TO_ADDR
// sTeleport := false ;
82992: LD_ADDR_EXP 146
82996: PUSH
82997: LD_INT 0
82999: ST_TO_ADDR
// sOilTower := false ;
83000: LD_ADDR_EXP 148
83004: PUSH
83005: LD_INT 0
83007: ST_TO_ADDR
// sShovel := false ;
83008: LD_ADDR_EXP 149
83012: PUSH
83013: LD_INT 0
83015: ST_TO_ADDR
// sSheik := false ;
83016: LD_ADDR_EXP 150
83020: PUSH
83021: LD_INT 0
83023: ST_TO_ADDR
// sEarthquake := false ;
83024: LD_ADDR_EXP 152
83028: PUSH
83029: LD_INT 0
83031: ST_TO_ADDR
// sAI := false ;
83032: LD_ADDR_EXP 153
83036: PUSH
83037: LD_INT 0
83039: ST_TO_ADDR
// sCargo := false ;
83040: LD_ADDR_EXP 156
83044: PUSH
83045: LD_INT 0
83047: ST_TO_ADDR
// sDLaser := false ;
83048: LD_ADDR_EXP 157
83052: PUSH
83053: LD_INT 0
83055: ST_TO_ADDR
// sExchange := false ;
83056: LD_ADDR_EXP 158
83060: PUSH
83061: LD_INT 0
83063: ST_TO_ADDR
// sFac := false ;
83064: LD_ADDR_EXP 159
83068: PUSH
83069: LD_INT 0
83071: ST_TO_ADDR
// sPower := false ;
83072: LD_ADDR_EXP 160
83076: PUSH
83077: LD_INT 0
83079: ST_TO_ADDR
// sRandom := false ;
83080: LD_ADDR_EXP 161
83084: PUSH
83085: LD_INT 0
83087: ST_TO_ADDR
// sShield := false ;
83088: LD_ADDR_EXP 162
83092: PUSH
83093: LD_INT 0
83095: ST_TO_ADDR
// sTime := false ;
83096: LD_ADDR_EXP 163
83100: PUSH
83101: LD_INT 0
83103: ST_TO_ADDR
// sTools := false ;
83104: LD_ADDR_EXP 164
83108: PUSH
83109: LD_INT 0
83111: ST_TO_ADDR
// sSold := false ;
83112: LD_ADDR_EXP 129
83116: PUSH
83117: LD_INT 0
83119: ST_TO_ADDR
// sDiff := false ;
83120: LD_ADDR_EXP 130
83124: PUSH
83125: LD_INT 0
83127: ST_TO_ADDR
// sFog := false ;
83128: LD_ADDR_EXP 133
83132: PUSH
83133: LD_INT 0
83135: ST_TO_ADDR
// sReset := false ;
83136: LD_ADDR_EXP 134
83140: PUSH
83141: LD_INT 0
83143: ST_TO_ADDR
// sSun := false ;
83144: LD_ADDR_EXP 135
83148: PUSH
83149: LD_INT 0
83151: ST_TO_ADDR
// sTiger := false ;
83152: LD_ADDR_EXP 131
83156: PUSH
83157: LD_INT 0
83159: ST_TO_ADDR
// sBomb := false ;
83160: LD_ADDR_EXP 132
83164: PUSH
83165: LD_INT 0
83167: ST_TO_ADDR
// sWound := false ;
83168: LD_ADDR_EXP 140
83172: PUSH
83173: LD_INT 0
83175: ST_TO_ADDR
// sBetray := false ;
83176: LD_ADDR_EXP 144
83180: PUSH
83181: LD_INT 0
83183: ST_TO_ADDR
// sContamin := false ;
83184: LD_ADDR_EXP 145
83188: PUSH
83189: LD_INT 0
83191: ST_TO_ADDR
// sOil := false ;
83192: LD_ADDR_EXP 147
83196: PUSH
83197: LD_INT 0
83199: ST_TO_ADDR
// sStu := false ;
83200: LD_ADDR_EXP 151
83204: PUSH
83205: LD_INT 0
83207: ST_TO_ADDR
// sBazooka := false ;
83208: LD_ADDR_EXP 154
83212: PUSH
83213: LD_INT 0
83215: ST_TO_ADDR
// sMortar := false ;
83216: LD_ADDR_EXP 155
83220: PUSH
83221: LD_INT 0
83223: ST_TO_ADDR
// sRanger := false ;
83224: LD_ADDR_EXP 165
83228: PUSH
83229: LD_INT 0
83231: ST_TO_ADDR
// end ;
83232: LD_VAR 0 1
83236: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
83237: LD_INT 0
83239: PPUSH
83240: PPUSH
83241: PPUSH
83242: PPUSH
83243: PPUSH
// result := [ ] ;
83244: LD_ADDR_VAR 0 1
83248: PUSH
83249: EMPTY
83250: ST_TO_ADDR
// if campaign_id = 1 then
83251: LD_OWVAR 69
83255: PUSH
83256: LD_INT 1
83258: EQUAL
83259: IFFALSE 86197
// begin case mission_number of 1 :
83261: LD_OWVAR 70
83265: PUSH
83266: LD_INT 1
83268: DOUBLE
83269: EQUAL
83270: IFTRUE 83274
83272: GO 83338
83274: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
83275: LD_ADDR_VAR 0 1
83279: PUSH
83280: LD_INT 2
83282: PUSH
83283: LD_INT 4
83285: PUSH
83286: LD_INT 11
83288: PUSH
83289: LD_INT 12
83291: PUSH
83292: LD_INT 15
83294: PUSH
83295: LD_INT 16
83297: PUSH
83298: LD_INT 22
83300: PUSH
83301: LD_INT 23
83303: PUSH
83304: LD_INT 26
83306: PUSH
83307: EMPTY
83308: LIST
83309: LIST
83310: LIST
83311: LIST
83312: LIST
83313: LIST
83314: LIST
83315: LIST
83316: LIST
83317: PUSH
83318: LD_INT 101
83320: PUSH
83321: LD_INT 102
83323: PUSH
83324: LD_INT 106
83326: PUSH
83327: EMPTY
83328: LIST
83329: LIST
83330: LIST
83331: PUSH
83332: EMPTY
83333: LIST
83334: LIST
83335: ST_TO_ADDR
83336: GO 86195
83338: LD_INT 2
83340: DOUBLE
83341: EQUAL
83342: IFTRUE 83346
83344: GO 83418
83346: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
83347: LD_ADDR_VAR 0 1
83351: PUSH
83352: LD_INT 2
83354: PUSH
83355: LD_INT 4
83357: PUSH
83358: LD_INT 11
83360: PUSH
83361: LD_INT 12
83363: PUSH
83364: LD_INT 15
83366: PUSH
83367: LD_INT 16
83369: PUSH
83370: LD_INT 22
83372: PUSH
83373: LD_INT 23
83375: PUSH
83376: LD_INT 26
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: PUSH
83390: LD_INT 101
83392: PUSH
83393: LD_INT 102
83395: PUSH
83396: LD_INT 105
83398: PUSH
83399: LD_INT 106
83401: PUSH
83402: LD_INT 108
83404: PUSH
83405: EMPTY
83406: LIST
83407: LIST
83408: LIST
83409: LIST
83410: LIST
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: ST_TO_ADDR
83416: GO 86195
83418: LD_INT 3
83420: DOUBLE
83421: EQUAL
83422: IFTRUE 83426
83424: GO 83502
83426: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
83427: LD_ADDR_VAR 0 1
83431: PUSH
83432: LD_INT 2
83434: PUSH
83435: LD_INT 4
83437: PUSH
83438: LD_INT 5
83440: PUSH
83441: LD_INT 11
83443: PUSH
83444: LD_INT 12
83446: PUSH
83447: LD_INT 15
83449: PUSH
83450: LD_INT 16
83452: PUSH
83453: LD_INT 22
83455: PUSH
83456: LD_INT 26
83458: PUSH
83459: LD_INT 36
83461: PUSH
83462: EMPTY
83463: LIST
83464: LIST
83465: LIST
83466: LIST
83467: LIST
83468: LIST
83469: LIST
83470: LIST
83471: LIST
83472: LIST
83473: PUSH
83474: LD_INT 101
83476: PUSH
83477: LD_INT 102
83479: PUSH
83480: LD_INT 105
83482: PUSH
83483: LD_INT 106
83485: PUSH
83486: LD_INT 108
83488: PUSH
83489: EMPTY
83490: LIST
83491: LIST
83492: LIST
83493: LIST
83494: LIST
83495: PUSH
83496: EMPTY
83497: LIST
83498: LIST
83499: ST_TO_ADDR
83500: GO 86195
83502: LD_INT 4
83504: DOUBLE
83505: EQUAL
83506: IFTRUE 83510
83508: GO 83594
83510: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
83511: LD_ADDR_VAR 0 1
83515: PUSH
83516: LD_INT 2
83518: PUSH
83519: LD_INT 4
83521: PUSH
83522: LD_INT 5
83524: PUSH
83525: LD_INT 8
83527: PUSH
83528: LD_INT 11
83530: PUSH
83531: LD_INT 12
83533: PUSH
83534: LD_INT 15
83536: PUSH
83537: LD_INT 16
83539: PUSH
83540: LD_INT 22
83542: PUSH
83543: LD_INT 23
83545: PUSH
83546: LD_INT 26
83548: PUSH
83549: LD_INT 36
83551: PUSH
83552: EMPTY
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: LIST
83560: LIST
83561: LIST
83562: LIST
83563: LIST
83564: LIST
83565: PUSH
83566: LD_INT 101
83568: PUSH
83569: LD_INT 102
83571: PUSH
83572: LD_INT 105
83574: PUSH
83575: LD_INT 106
83577: PUSH
83578: LD_INT 108
83580: PUSH
83581: EMPTY
83582: LIST
83583: LIST
83584: LIST
83585: LIST
83586: LIST
83587: PUSH
83588: EMPTY
83589: LIST
83590: LIST
83591: ST_TO_ADDR
83592: GO 86195
83594: LD_INT 5
83596: DOUBLE
83597: EQUAL
83598: IFTRUE 83602
83600: GO 83702
83602: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
83603: LD_ADDR_VAR 0 1
83607: PUSH
83608: LD_INT 2
83610: PUSH
83611: LD_INT 4
83613: PUSH
83614: LD_INT 5
83616: PUSH
83617: LD_INT 6
83619: PUSH
83620: LD_INT 8
83622: PUSH
83623: LD_INT 11
83625: PUSH
83626: LD_INT 12
83628: PUSH
83629: LD_INT 15
83631: PUSH
83632: LD_INT 16
83634: PUSH
83635: LD_INT 22
83637: PUSH
83638: LD_INT 23
83640: PUSH
83641: LD_INT 25
83643: PUSH
83644: LD_INT 26
83646: PUSH
83647: LD_INT 36
83649: PUSH
83650: EMPTY
83651: LIST
83652: LIST
83653: LIST
83654: LIST
83655: LIST
83656: LIST
83657: LIST
83658: LIST
83659: LIST
83660: LIST
83661: LIST
83662: LIST
83663: LIST
83664: LIST
83665: PUSH
83666: LD_INT 101
83668: PUSH
83669: LD_INT 102
83671: PUSH
83672: LD_INT 105
83674: PUSH
83675: LD_INT 106
83677: PUSH
83678: LD_INT 108
83680: PUSH
83681: LD_INT 109
83683: PUSH
83684: LD_INT 112
83686: PUSH
83687: EMPTY
83688: LIST
83689: LIST
83690: LIST
83691: LIST
83692: LIST
83693: LIST
83694: LIST
83695: PUSH
83696: EMPTY
83697: LIST
83698: LIST
83699: ST_TO_ADDR
83700: GO 86195
83702: LD_INT 6
83704: DOUBLE
83705: EQUAL
83706: IFTRUE 83710
83708: GO 83830
83710: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
83711: LD_ADDR_VAR 0 1
83715: PUSH
83716: LD_INT 2
83718: PUSH
83719: LD_INT 4
83721: PUSH
83722: LD_INT 5
83724: PUSH
83725: LD_INT 6
83727: PUSH
83728: LD_INT 8
83730: PUSH
83731: LD_INT 11
83733: PUSH
83734: LD_INT 12
83736: PUSH
83737: LD_INT 15
83739: PUSH
83740: LD_INT 16
83742: PUSH
83743: LD_INT 20
83745: PUSH
83746: LD_INT 21
83748: PUSH
83749: LD_INT 22
83751: PUSH
83752: LD_INT 23
83754: PUSH
83755: LD_INT 25
83757: PUSH
83758: LD_INT 26
83760: PUSH
83761: LD_INT 30
83763: PUSH
83764: LD_INT 31
83766: PUSH
83767: LD_INT 32
83769: PUSH
83770: LD_INT 36
83772: PUSH
83773: EMPTY
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: LIST
83782: LIST
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: LIST
83793: PUSH
83794: LD_INT 101
83796: PUSH
83797: LD_INT 102
83799: PUSH
83800: LD_INT 105
83802: PUSH
83803: LD_INT 106
83805: PUSH
83806: LD_INT 108
83808: PUSH
83809: LD_INT 109
83811: PUSH
83812: LD_INT 112
83814: PUSH
83815: EMPTY
83816: LIST
83817: LIST
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: PUSH
83824: EMPTY
83825: LIST
83826: LIST
83827: ST_TO_ADDR
83828: GO 86195
83830: LD_INT 7
83832: DOUBLE
83833: EQUAL
83834: IFTRUE 83838
83836: GO 83938
83838: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
83839: LD_ADDR_VAR 0 1
83843: PUSH
83844: LD_INT 2
83846: PUSH
83847: LD_INT 4
83849: PUSH
83850: LD_INT 5
83852: PUSH
83853: LD_INT 7
83855: PUSH
83856: LD_INT 11
83858: PUSH
83859: LD_INT 12
83861: PUSH
83862: LD_INT 15
83864: PUSH
83865: LD_INT 16
83867: PUSH
83868: LD_INT 20
83870: PUSH
83871: LD_INT 21
83873: PUSH
83874: LD_INT 22
83876: PUSH
83877: LD_INT 23
83879: PUSH
83880: LD_INT 25
83882: PUSH
83883: LD_INT 26
83885: PUSH
83886: EMPTY
83887: LIST
83888: LIST
83889: LIST
83890: LIST
83891: LIST
83892: LIST
83893: LIST
83894: LIST
83895: LIST
83896: LIST
83897: LIST
83898: LIST
83899: LIST
83900: LIST
83901: PUSH
83902: LD_INT 101
83904: PUSH
83905: LD_INT 102
83907: PUSH
83908: LD_INT 103
83910: PUSH
83911: LD_INT 105
83913: PUSH
83914: LD_INT 106
83916: PUSH
83917: LD_INT 108
83919: PUSH
83920: LD_INT 112
83922: PUSH
83923: EMPTY
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: LIST
83930: LIST
83931: PUSH
83932: EMPTY
83933: LIST
83934: LIST
83935: ST_TO_ADDR
83936: GO 86195
83938: LD_INT 8
83940: DOUBLE
83941: EQUAL
83942: IFTRUE 83946
83944: GO 84074
83946: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
83947: LD_ADDR_VAR 0 1
83951: PUSH
83952: LD_INT 2
83954: PUSH
83955: LD_INT 4
83957: PUSH
83958: LD_INT 5
83960: PUSH
83961: LD_INT 6
83963: PUSH
83964: LD_INT 7
83966: PUSH
83967: LD_INT 8
83969: PUSH
83970: LD_INT 11
83972: PUSH
83973: LD_INT 12
83975: PUSH
83976: LD_INT 15
83978: PUSH
83979: LD_INT 16
83981: PUSH
83982: LD_INT 20
83984: PUSH
83985: LD_INT 21
83987: PUSH
83988: LD_INT 22
83990: PUSH
83991: LD_INT 23
83993: PUSH
83994: LD_INT 25
83996: PUSH
83997: LD_INT 26
83999: PUSH
84000: LD_INT 30
84002: PUSH
84003: LD_INT 31
84005: PUSH
84006: LD_INT 32
84008: PUSH
84009: LD_INT 36
84011: PUSH
84012: EMPTY
84013: LIST
84014: LIST
84015: LIST
84016: LIST
84017: LIST
84018: LIST
84019: LIST
84020: LIST
84021: LIST
84022: LIST
84023: LIST
84024: LIST
84025: LIST
84026: LIST
84027: LIST
84028: LIST
84029: LIST
84030: LIST
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 101
84036: PUSH
84037: LD_INT 102
84039: PUSH
84040: LD_INT 103
84042: PUSH
84043: LD_INT 105
84045: PUSH
84046: LD_INT 106
84048: PUSH
84049: LD_INT 108
84051: PUSH
84052: LD_INT 109
84054: PUSH
84055: LD_INT 112
84057: PUSH
84058: EMPTY
84059: LIST
84060: LIST
84061: LIST
84062: LIST
84063: LIST
84064: LIST
84065: LIST
84066: LIST
84067: PUSH
84068: EMPTY
84069: LIST
84070: LIST
84071: ST_TO_ADDR
84072: GO 86195
84074: LD_INT 9
84076: DOUBLE
84077: EQUAL
84078: IFTRUE 84082
84080: GO 84218
84082: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
84083: LD_ADDR_VAR 0 1
84087: PUSH
84088: LD_INT 2
84090: PUSH
84091: LD_INT 4
84093: PUSH
84094: LD_INT 5
84096: PUSH
84097: LD_INT 6
84099: PUSH
84100: LD_INT 7
84102: PUSH
84103: LD_INT 8
84105: PUSH
84106: LD_INT 11
84108: PUSH
84109: LD_INT 12
84111: PUSH
84112: LD_INT 15
84114: PUSH
84115: LD_INT 16
84117: PUSH
84118: LD_INT 20
84120: PUSH
84121: LD_INT 21
84123: PUSH
84124: LD_INT 22
84126: PUSH
84127: LD_INT 23
84129: PUSH
84130: LD_INT 25
84132: PUSH
84133: LD_INT 26
84135: PUSH
84136: LD_INT 28
84138: PUSH
84139: LD_INT 30
84141: PUSH
84142: LD_INT 31
84144: PUSH
84145: LD_INT 32
84147: PUSH
84148: LD_INT 36
84150: PUSH
84151: EMPTY
84152: LIST
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: LIST
84170: LIST
84171: LIST
84172: LIST
84173: PUSH
84174: LD_INT 101
84176: PUSH
84177: LD_INT 102
84179: PUSH
84180: LD_INT 103
84182: PUSH
84183: LD_INT 105
84185: PUSH
84186: LD_INT 106
84188: PUSH
84189: LD_INT 108
84191: PUSH
84192: LD_INT 109
84194: PUSH
84195: LD_INT 112
84197: PUSH
84198: LD_INT 114
84200: PUSH
84201: EMPTY
84202: LIST
84203: LIST
84204: LIST
84205: LIST
84206: LIST
84207: LIST
84208: LIST
84209: LIST
84210: LIST
84211: PUSH
84212: EMPTY
84213: LIST
84214: LIST
84215: ST_TO_ADDR
84216: GO 86195
84218: LD_INT 10
84220: DOUBLE
84221: EQUAL
84222: IFTRUE 84226
84224: GO 84410
84226: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
84227: LD_ADDR_VAR 0 1
84231: PUSH
84232: LD_INT 2
84234: PUSH
84235: LD_INT 4
84237: PUSH
84238: LD_INT 5
84240: PUSH
84241: LD_INT 6
84243: PUSH
84244: LD_INT 7
84246: PUSH
84247: LD_INT 8
84249: PUSH
84250: LD_INT 9
84252: PUSH
84253: LD_INT 10
84255: PUSH
84256: LD_INT 11
84258: PUSH
84259: LD_INT 12
84261: PUSH
84262: LD_INT 13
84264: PUSH
84265: LD_INT 14
84267: PUSH
84268: LD_INT 15
84270: PUSH
84271: LD_INT 16
84273: PUSH
84274: LD_INT 17
84276: PUSH
84277: LD_INT 18
84279: PUSH
84280: LD_INT 19
84282: PUSH
84283: LD_INT 20
84285: PUSH
84286: LD_INT 21
84288: PUSH
84289: LD_INT 22
84291: PUSH
84292: LD_INT 23
84294: PUSH
84295: LD_INT 24
84297: PUSH
84298: LD_INT 25
84300: PUSH
84301: LD_INT 26
84303: PUSH
84304: LD_INT 28
84306: PUSH
84307: LD_INT 30
84309: PUSH
84310: LD_INT 31
84312: PUSH
84313: LD_INT 32
84315: PUSH
84316: LD_INT 36
84318: PUSH
84319: EMPTY
84320: LIST
84321: LIST
84322: LIST
84323: LIST
84324: LIST
84325: LIST
84326: LIST
84327: LIST
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: LIST
84336: LIST
84337: LIST
84338: LIST
84339: LIST
84340: LIST
84341: LIST
84342: LIST
84343: LIST
84344: LIST
84345: LIST
84346: LIST
84347: LIST
84348: LIST
84349: PUSH
84350: LD_INT 101
84352: PUSH
84353: LD_INT 102
84355: PUSH
84356: LD_INT 103
84358: PUSH
84359: LD_INT 104
84361: PUSH
84362: LD_INT 105
84364: PUSH
84365: LD_INT 106
84367: PUSH
84368: LD_INT 107
84370: PUSH
84371: LD_INT 108
84373: PUSH
84374: LD_INT 109
84376: PUSH
84377: LD_INT 110
84379: PUSH
84380: LD_INT 111
84382: PUSH
84383: LD_INT 112
84385: PUSH
84386: LD_INT 114
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: LIST
84393: LIST
84394: LIST
84395: LIST
84396: LIST
84397: LIST
84398: LIST
84399: LIST
84400: LIST
84401: LIST
84402: LIST
84403: PUSH
84404: EMPTY
84405: LIST
84406: LIST
84407: ST_TO_ADDR
84408: GO 86195
84410: LD_INT 11
84412: DOUBLE
84413: EQUAL
84414: IFTRUE 84418
84416: GO 84610
84418: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
84419: LD_ADDR_VAR 0 1
84423: PUSH
84424: LD_INT 2
84426: PUSH
84427: LD_INT 3
84429: PUSH
84430: LD_INT 4
84432: PUSH
84433: LD_INT 5
84435: PUSH
84436: LD_INT 6
84438: PUSH
84439: LD_INT 7
84441: PUSH
84442: LD_INT 8
84444: PUSH
84445: LD_INT 9
84447: PUSH
84448: LD_INT 10
84450: PUSH
84451: LD_INT 11
84453: PUSH
84454: LD_INT 12
84456: PUSH
84457: LD_INT 13
84459: PUSH
84460: LD_INT 14
84462: PUSH
84463: LD_INT 15
84465: PUSH
84466: LD_INT 16
84468: PUSH
84469: LD_INT 17
84471: PUSH
84472: LD_INT 18
84474: PUSH
84475: LD_INT 19
84477: PUSH
84478: LD_INT 20
84480: PUSH
84481: LD_INT 21
84483: PUSH
84484: LD_INT 22
84486: PUSH
84487: LD_INT 23
84489: PUSH
84490: LD_INT 24
84492: PUSH
84493: LD_INT 25
84495: PUSH
84496: LD_INT 26
84498: PUSH
84499: LD_INT 28
84501: PUSH
84502: LD_INT 30
84504: PUSH
84505: LD_INT 31
84507: PUSH
84508: LD_INT 32
84510: PUSH
84511: LD_INT 34
84513: PUSH
84514: LD_INT 36
84516: PUSH
84517: EMPTY
84518: LIST
84519: LIST
84520: LIST
84521: LIST
84522: LIST
84523: LIST
84524: LIST
84525: LIST
84526: LIST
84527: LIST
84528: LIST
84529: LIST
84530: LIST
84531: LIST
84532: LIST
84533: LIST
84534: LIST
84535: LIST
84536: LIST
84537: LIST
84538: LIST
84539: LIST
84540: LIST
84541: LIST
84542: LIST
84543: LIST
84544: LIST
84545: LIST
84546: LIST
84547: LIST
84548: LIST
84549: PUSH
84550: LD_INT 101
84552: PUSH
84553: LD_INT 102
84555: PUSH
84556: LD_INT 103
84558: PUSH
84559: LD_INT 104
84561: PUSH
84562: LD_INT 105
84564: PUSH
84565: LD_INT 106
84567: PUSH
84568: LD_INT 107
84570: PUSH
84571: LD_INT 108
84573: PUSH
84574: LD_INT 109
84576: PUSH
84577: LD_INT 110
84579: PUSH
84580: LD_INT 111
84582: PUSH
84583: LD_INT 112
84585: PUSH
84586: LD_INT 114
84588: PUSH
84589: EMPTY
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: LIST
84595: LIST
84596: LIST
84597: LIST
84598: LIST
84599: LIST
84600: LIST
84601: LIST
84602: LIST
84603: PUSH
84604: EMPTY
84605: LIST
84606: LIST
84607: ST_TO_ADDR
84608: GO 86195
84610: LD_INT 12
84612: DOUBLE
84613: EQUAL
84614: IFTRUE 84618
84616: GO 84826
84618: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
84619: LD_ADDR_VAR 0 1
84623: PUSH
84624: LD_INT 1
84626: PUSH
84627: LD_INT 2
84629: PUSH
84630: LD_INT 3
84632: PUSH
84633: LD_INT 4
84635: PUSH
84636: LD_INT 5
84638: PUSH
84639: LD_INT 6
84641: PUSH
84642: LD_INT 7
84644: PUSH
84645: LD_INT 8
84647: PUSH
84648: LD_INT 9
84650: PUSH
84651: LD_INT 10
84653: PUSH
84654: LD_INT 11
84656: PUSH
84657: LD_INT 12
84659: PUSH
84660: LD_INT 13
84662: PUSH
84663: LD_INT 14
84665: PUSH
84666: LD_INT 15
84668: PUSH
84669: LD_INT 16
84671: PUSH
84672: LD_INT 17
84674: PUSH
84675: LD_INT 18
84677: PUSH
84678: LD_INT 19
84680: PUSH
84681: LD_INT 20
84683: PUSH
84684: LD_INT 21
84686: PUSH
84687: LD_INT 22
84689: PUSH
84690: LD_INT 23
84692: PUSH
84693: LD_INT 24
84695: PUSH
84696: LD_INT 25
84698: PUSH
84699: LD_INT 26
84701: PUSH
84702: LD_INT 27
84704: PUSH
84705: LD_INT 28
84707: PUSH
84708: LD_INT 30
84710: PUSH
84711: LD_INT 31
84713: PUSH
84714: LD_INT 32
84716: PUSH
84717: LD_INT 33
84719: PUSH
84720: LD_INT 34
84722: PUSH
84723: LD_INT 36
84725: PUSH
84726: EMPTY
84727: LIST
84728: LIST
84729: LIST
84730: LIST
84731: LIST
84732: LIST
84733: LIST
84734: LIST
84735: LIST
84736: LIST
84737: LIST
84738: LIST
84739: LIST
84740: LIST
84741: LIST
84742: LIST
84743: LIST
84744: LIST
84745: LIST
84746: LIST
84747: LIST
84748: LIST
84749: LIST
84750: LIST
84751: LIST
84752: LIST
84753: LIST
84754: LIST
84755: LIST
84756: LIST
84757: LIST
84758: LIST
84759: LIST
84760: LIST
84761: PUSH
84762: LD_INT 101
84764: PUSH
84765: LD_INT 102
84767: PUSH
84768: LD_INT 103
84770: PUSH
84771: LD_INT 104
84773: PUSH
84774: LD_INT 105
84776: PUSH
84777: LD_INT 106
84779: PUSH
84780: LD_INT 107
84782: PUSH
84783: LD_INT 108
84785: PUSH
84786: LD_INT 109
84788: PUSH
84789: LD_INT 110
84791: PUSH
84792: LD_INT 111
84794: PUSH
84795: LD_INT 112
84797: PUSH
84798: LD_INT 113
84800: PUSH
84801: LD_INT 114
84803: PUSH
84804: EMPTY
84805: LIST
84806: LIST
84807: LIST
84808: LIST
84809: LIST
84810: LIST
84811: LIST
84812: LIST
84813: LIST
84814: LIST
84815: LIST
84816: LIST
84817: LIST
84818: LIST
84819: PUSH
84820: EMPTY
84821: LIST
84822: LIST
84823: ST_TO_ADDR
84824: GO 86195
84826: LD_INT 13
84828: DOUBLE
84829: EQUAL
84830: IFTRUE 84834
84832: GO 85030
84834: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
84835: LD_ADDR_VAR 0 1
84839: PUSH
84840: LD_INT 1
84842: PUSH
84843: LD_INT 2
84845: PUSH
84846: LD_INT 3
84848: PUSH
84849: LD_INT 4
84851: PUSH
84852: LD_INT 5
84854: PUSH
84855: LD_INT 8
84857: PUSH
84858: LD_INT 9
84860: PUSH
84861: LD_INT 10
84863: PUSH
84864: LD_INT 11
84866: PUSH
84867: LD_INT 12
84869: PUSH
84870: LD_INT 14
84872: PUSH
84873: LD_INT 15
84875: PUSH
84876: LD_INT 16
84878: PUSH
84879: LD_INT 17
84881: PUSH
84882: LD_INT 18
84884: PUSH
84885: LD_INT 19
84887: PUSH
84888: LD_INT 20
84890: PUSH
84891: LD_INT 21
84893: PUSH
84894: LD_INT 22
84896: PUSH
84897: LD_INT 23
84899: PUSH
84900: LD_INT 24
84902: PUSH
84903: LD_INT 25
84905: PUSH
84906: LD_INT 26
84908: PUSH
84909: LD_INT 27
84911: PUSH
84912: LD_INT 28
84914: PUSH
84915: LD_INT 30
84917: PUSH
84918: LD_INT 31
84920: PUSH
84921: LD_INT 32
84923: PUSH
84924: LD_INT 33
84926: PUSH
84927: LD_INT 34
84929: PUSH
84930: LD_INT 36
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: LIST
84943: LIST
84944: LIST
84945: LIST
84946: LIST
84947: LIST
84948: LIST
84949: LIST
84950: LIST
84951: LIST
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: LIST
84957: LIST
84958: LIST
84959: LIST
84960: LIST
84961: LIST
84962: LIST
84963: LIST
84964: LIST
84965: PUSH
84966: LD_INT 101
84968: PUSH
84969: LD_INT 102
84971: PUSH
84972: LD_INT 103
84974: PUSH
84975: LD_INT 104
84977: PUSH
84978: LD_INT 105
84980: PUSH
84981: LD_INT 106
84983: PUSH
84984: LD_INT 107
84986: PUSH
84987: LD_INT 108
84989: PUSH
84990: LD_INT 109
84992: PUSH
84993: LD_INT 110
84995: PUSH
84996: LD_INT 111
84998: PUSH
84999: LD_INT 112
85001: PUSH
85002: LD_INT 113
85004: PUSH
85005: LD_INT 114
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: LIST
85012: LIST
85013: LIST
85014: LIST
85015: LIST
85016: LIST
85017: LIST
85018: LIST
85019: LIST
85020: LIST
85021: LIST
85022: LIST
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: ST_TO_ADDR
85028: GO 86195
85030: LD_INT 14
85032: DOUBLE
85033: EQUAL
85034: IFTRUE 85038
85036: GO 85250
85038: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
85039: LD_ADDR_VAR 0 1
85043: PUSH
85044: LD_INT 1
85046: PUSH
85047: LD_INT 2
85049: PUSH
85050: LD_INT 3
85052: PUSH
85053: LD_INT 4
85055: PUSH
85056: LD_INT 5
85058: PUSH
85059: LD_INT 6
85061: PUSH
85062: LD_INT 7
85064: PUSH
85065: LD_INT 8
85067: PUSH
85068: LD_INT 9
85070: PUSH
85071: LD_INT 10
85073: PUSH
85074: LD_INT 11
85076: PUSH
85077: LD_INT 12
85079: PUSH
85080: LD_INT 13
85082: PUSH
85083: LD_INT 14
85085: PUSH
85086: LD_INT 15
85088: PUSH
85089: LD_INT 16
85091: PUSH
85092: LD_INT 17
85094: PUSH
85095: LD_INT 18
85097: PUSH
85098: LD_INT 19
85100: PUSH
85101: LD_INT 20
85103: PUSH
85104: LD_INT 21
85106: PUSH
85107: LD_INT 22
85109: PUSH
85110: LD_INT 23
85112: PUSH
85113: LD_INT 24
85115: PUSH
85116: LD_INT 25
85118: PUSH
85119: LD_INT 26
85121: PUSH
85122: LD_INT 27
85124: PUSH
85125: LD_INT 28
85127: PUSH
85128: LD_INT 29
85130: PUSH
85131: LD_INT 30
85133: PUSH
85134: LD_INT 31
85136: PUSH
85137: LD_INT 32
85139: PUSH
85140: LD_INT 33
85142: PUSH
85143: LD_INT 34
85145: PUSH
85146: LD_INT 36
85148: PUSH
85149: EMPTY
85150: LIST
85151: LIST
85152: LIST
85153: LIST
85154: LIST
85155: LIST
85156: LIST
85157: LIST
85158: LIST
85159: LIST
85160: LIST
85161: LIST
85162: LIST
85163: LIST
85164: LIST
85165: LIST
85166: LIST
85167: LIST
85168: LIST
85169: LIST
85170: LIST
85171: LIST
85172: LIST
85173: LIST
85174: LIST
85175: LIST
85176: LIST
85177: LIST
85178: LIST
85179: LIST
85180: LIST
85181: LIST
85182: LIST
85183: LIST
85184: LIST
85185: PUSH
85186: LD_INT 101
85188: PUSH
85189: LD_INT 102
85191: PUSH
85192: LD_INT 103
85194: PUSH
85195: LD_INT 104
85197: PUSH
85198: LD_INT 105
85200: PUSH
85201: LD_INT 106
85203: PUSH
85204: LD_INT 107
85206: PUSH
85207: LD_INT 108
85209: PUSH
85210: LD_INT 109
85212: PUSH
85213: LD_INT 110
85215: PUSH
85216: LD_INT 111
85218: PUSH
85219: LD_INT 112
85221: PUSH
85222: LD_INT 113
85224: PUSH
85225: LD_INT 114
85227: PUSH
85228: EMPTY
85229: LIST
85230: LIST
85231: LIST
85232: LIST
85233: LIST
85234: LIST
85235: LIST
85236: LIST
85237: LIST
85238: LIST
85239: LIST
85240: LIST
85241: LIST
85242: LIST
85243: PUSH
85244: EMPTY
85245: LIST
85246: LIST
85247: ST_TO_ADDR
85248: GO 86195
85250: LD_INT 15
85252: DOUBLE
85253: EQUAL
85254: IFTRUE 85258
85256: GO 85470
85258: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
85259: LD_ADDR_VAR 0 1
85263: PUSH
85264: LD_INT 1
85266: PUSH
85267: LD_INT 2
85269: PUSH
85270: LD_INT 3
85272: PUSH
85273: LD_INT 4
85275: PUSH
85276: LD_INT 5
85278: PUSH
85279: LD_INT 6
85281: PUSH
85282: LD_INT 7
85284: PUSH
85285: LD_INT 8
85287: PUSH
85288: LD_INT 9
85290: PUSH
85291: LD_INT 10
85293: PUSH
85294: LD_INT 11
85296: PUSH
85297: LD_INT 12
85299: PUSH
85300: LD_INT 13
85302: PUSH
85303: LD_INT 14
85305: PUSH
85306: LD_INT 15
85308: PUSH
85309: LD_INT 16
85311: PUSH
85312: LD_INT 17
85314: PUSH
85315: LD_INT 18
85317: PUSH
85318: LD_INT 19
85320: PUSH
85321: LD_INT 20
85323: PUSH
85324: LD_INT 21
85326: PUSH
85327: LD_INT 22
85329: PUSH
85330: LD_INT 23
85332: PUSH
85333: LD_INT 24
85335: PUSH
85336: LD_INT 25
85338: PUSH
85339: LD_INT 26
85341: PUSH
85342: LD_INT 27
85344: PUSH
85345: LD_INT 28
85347: PUSH
85348: LD_INT 29
85350: PUSH
85351: LD_INT 30
85353: PUSH
85354: LD_INT 31
85356: PUSH
85357: LD_INT 32
85359: PUSH
85360: LD_INT 33
85362: PUSH
85363: LD_INT 34
85365: PUSH
85366: LD_INT 36
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: LIST
85373: LIST
85374: LIST
85375: LIST
85376: LIST
85377: LIST
85378: LIST
85379: LIST
85380: LIST
85381: LIST
85382: LIST
85383: LIST
85384: LIST
85385: LIST
85386: LIST
85387: LIST
85388: LIST
85389: LIST
85390: LIST
85391: LIST
85392: LIST
85393: LIST
85394: LIST
85395: LIST
85396: LIST
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: LIST
85404: LIST
85405: PUSH
85406: LD_INT 101
85408: PUSH
85409: LD_INT 102
85411: PUSH
85412: LD_INT 103
85414: PUSH
85415: LD_INT 104
85417: PUSH
85418: LD_INT 105
85420: PUSH
85421: LD_INT 106
85423: PUSH
85424: LD_INT 107
85426: PUSH
85427: LD_INT 108
85429: PUSH
85430: LD_INT 109
85432: PUSH
85433: LD_INT 110
85435: PUSH
85436: LD_INT 111
85438: PUSH
85439: LD_INT 112
85441: PUSH
85442: LD_INT 113
85444: PUSH
85445: LD_INT 114
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: LIST
85452: LIST
85453: LIST
85454: LIST
85455: LIST
85456: LIST
85457: LIST
85458: LIST
85459: LIST
85460: LIST
85461: LIST
85462: LIST
85463: PUSH
85464: EMPTY
85465: LIST
85466: LIST
85467: ST_TO_ADDR
85468: GO 86195
85470: LD_INT 16
85472: DOUBLE
85473: EQUAL
85474: IFTRUE 85478
85476: GO 85602
85478: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
85479: LD_ADDR_VAR 0 1
85483: PUSH
85484: LD_INT 2
85486: PUSH
85487: LD_INT 4
85489: PUSH
85490: LD_INT 5
85492: PUSH
85493: LD_INT 7
85495: PUSH
85496: LD_INT 11
85498: PUSH
85499: LD_INT 12
85501: PUSH
85502: LD_INT 15
85504: PUSH
85505: LD_INT 16
85507: PUSH
85508: LD_INT 20
85510: PUSH
85511: LD_INT 21
85513: PUSH
85514: LD_INT 22
85516: PUSH
85517: LD_INT 23
85519: PUSH
85520: LD_INT 25
85522: PUSH
85523: LD_INT 26
85525: PUSH
85526: LD_INT 30
85528: PUSH
85529: LD_INT 31
85531: PUSH
85532: LD_INT 32
85534: PUSH
85535: LD_INT 33
85537: PUSH
85538: LD_INT 34
85540: PUSH
85541: EMPTY
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: LIST
85551: LIST
85552: LIST
85553: LIST
85554: LIST
85555: LIST
85556: LIST
85557: LIST
85558: LIST
85559: LIST
85560: LIST
85561: PUSH
85562: LD_INT 101
85564: PUSH
85565: LD_INT 102
85567: PUSH
85568: LD_INT 103
85570: PUSH
85571: LD_INT 106
85573: PUSH
85574: LD_INT 108
85576: PUSH
85577: LD_INT 112
85579: PUSH
85580: LD_INT 113
85582: PUSH
85583: LD_INT 114
85585: PUSH
85586: EMPTY
85587: LIST
85588: LIST
85589: LIST
85590: LIST
85591: LIST
85592: LIST
85593: LIST
85594: LIST
85595: PUSH
85596: EMPTY
85597: LIST
85598: LIST
85599: ST_TO_ADDR
85600: GO 86195
85602: LD_INT 17
85604: DOUBLE
85605: EQUAL
85606: IFTRUE 85610
85608: GO 85822
85610: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
85611: LD_ADDR_VAR 0 1
85615: PUSH
85616: LD_INT 1
85618: PUSH
85619: LD_INT 2
85621: PUSH
85622: LD_INT 3
85624: PUSH
85625: LD_INT 4
85627: PUSH
85628: LD_INT 5
85630: PUSH
85631: LD_INT 6
85633: PUSH
85634: LD_INT 7
85636: PUSH
85637: LD_INT 8
85639: PUSH
85640: LD_INT 9
85642: PUSH
85643: LD_INT 10
85645: PUSH
85646: LD_INT 11
85648: PUSH
85649: LD_INT 12
85651: PUSH
85652: LD_INT 13
85654: PUSH
85655: LD_INT 14
85657: PUSH
85658: LD_INT 15
85660: PUSH
85661: LD_INT 16
85663: PUSH
85664: LD_INT 17
85666: PUSH
85667: LD_INT 18
85669: PUSH
85670: LD_INT 19
85672: PUSH
85673: LD_INT 20
85675: PUSH
85676: LD_INT 21
85678: PUSH
85679: LD_INT 22
85681: PUSH
85682: LD_INT 23
85684: PUSH
85685: LD_INT 24
85687: PUSH
85688: LD_INT 25
85690: PUSH
85691: LD_INT 26
85693: PUSH
85694: LD_INT 27
85696: PUSH
85697: LD_INT 28
85699: PUSH
85700: LD_INT 29
85702: PUSH
85703: LD_INT 30
85705: PUSH
85706: LD_INT 31
85708: PUSH
85709: LD_INT 32
85711: PUSH
85712: LD_INT 33
85714: PUSH
85715: LD_INT 34
85717: PUSH
85718: LD_INT 36
85720: PUSH
85721: EMPTY
85722: LIST
85723: LIST
85724: LIST
85725: LIST
85726: LIST
85727: LIST
85728: LIST
85729: LIST
85730: LIST
85731: LIST
85732: LIST
85733: LIST
85734: LIST
85735: LIST
85736: LIST
85737: LIST
85738: LIST
85739: LIST
85740: LIST
85741: LIST
85742: LIST
85743: LIST
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: LIST
85757: PUSH
85758: LD_INT 101
85760: PUSH
85761: LD_INT 102
85763: PUSH
85764: LD_INT 103
85766: PUSH
85767: LD_INT 104
85769: PUSH
85770: LD_INT 105
85772: PUSH
85773: LD_INT 106
85775: PUSH
85776: LD_INT 107
85778: PUSH
85779: LD_INT 108
85781: PUSH
85782: LD_INT 109
85784: PUSH
85785: LD_INT 110
85787: PUSH
85788: LD_INT 111
85790: PUSH
85791: LD_INT 112
85793: PUSH
85794: LD_INT 113
85796: PUSH
85797: LD_INT 114
85799: PUSH
85800: EMPTY
85801: LIST
85802: LIST
85803: LIST
85804: LIST
85805: LIST
85806: LIST
85807: LIST
85808: LIST
85809: LIST
85810: LIST
85811: LIST
85812: LIST
85813: LIST
85814: LIST
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: ST_TO_ADDR
85820: GO 86195
85822: LD_INT 18
85824: DOUBLE
85825: EQUAL
85826: IFTRUE 85830
85828: GO 85966
85830: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
85831: LD_ADDR_VAR 0 1
85835: PUSH
85836: LD_INT 2
85838: PUSH
85839: LD_INT 4
85841: PUSH
85842: LD_INT 5
85844: PUSH
85845: LD_INT 7
85847: PUSH
85848: LD_INT 11
85850: PUSH
85851: LD_INT 12
85853: PUSH
85854: LD_INT 15
85856: PUSH
85857: LD_INT 16
85859: PUSH
85860: LD_INT 20
85862: PUSH
85863: LD_INT 21
85865: PUSH
85866: LD_INT 22
85868: PUSH
85869: LD_INT 23
85871: PUSH
85872: LD_INT 25
85874: PUSH
85875: LD_INT 26
85877: PUSH
85878: LD_INT 30
85880: PUSH
85881: LD_INT 31
85883: PUSH
85884: LD_INT 32
85886: PUSH
85887: LD_INT 33
85889: PUSH
85890: LD_INT 34
85892: PUSH
85893: LD_INT 35
85895: PUSH
85896: LD_INT 36
85898: PUSH
85899: EMPTY
85900: LIST
85901: LIST
85902: LIST
85903: LIST
85904: LIST
85905: LIST
85906: LIST
85907: LIST
85908: LIST
85909: LIST
85910: LIST
85911: LIST
85912: LIST
85913: LIST
85914: LIST
85915: LIST
85916: LIST
85917: LIST
85918: LIST
85919: LIST
85920: LIST
85921: PUSH
85922: LD_INT 101
85924: PUSH
85925: LD_INT 102
85927: PUSH
85928: LD_INT 103
85930: PUSH
85931: LD_INT 106
85933: PUSH
85934: LD_INT 108
85936: PUSH
85937: LD_INT 112
85939: PUSH
85940: LD_INT 113
85942: PUSH
85943: LD_INT 114
85945: PUSH
85946: LD_INT 115
85948: PUSH
85949: EMPTY
85950: LIST
85951: LIST
85952: LIST
85953: LIST
85954: LIST
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: ST_TO_ADDR
85964: GO 86195
85966: LD_INT 19
85968: DOUBLE
85969: EQUAL
85970: IFTRUE 85974
85972: GO 86194
85974: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
85975: LD_ADDR_VAR 0 1
85979: PUSH
85980: LD_INT 1
85982: PUSH
85983: LD_INT 2
85985: PUSH
85986: LD_INT 3
85988: PUSH
85989: LD_INT 4
85991: PUSH
85992: LD_INT 5
85994: PUSH
85995: LD_INT 6
85997: PUSH
85998: LD_INT 7
86000: PUSH
86001: LD_INT 8
86003: PUSH
86004: LD_INT 9
86006: PUSH
86007: LD_INT 10
86009: PUSH
86010: LD_INT 11
86012: PUSH
86013: LD_INT 12
86015: PUSH
86016: LD_INT 13
86018: PUSH
86019: LD_INT 14
86021: PUSH
86022: LD_INT 15
86024: PUSH
86025: LD_INT 16
86027: PUSH
86028: LD_INT 17
86030: PUSH
86031: LD_INT 18
86033: PUSH
86034: LD_INT 19
86036: PUSH
86037: LD_INT 20
86039: PUSH
86040: LD_INT 21
86042: PUSH
86043: LD_INT 22
86045: PUSH
86046: LD_INT 23
86048: PUSH
86049: LD_INT 24
86051: PUSH
86052: LD_INT 25
86054: PUSH
86055: LD_INT 26
86057: PUSH
86058: LD_INT 27
86060: PUSH
86061: LD_INT 28
86063: PUSH
86064: LD_INT 29
86066: PUSH
86067: LD_INT 30
86069: PUSH
86070: LD_INT 31
86072: PUSH
86073: LD_INT 32
86075: PUSH
86076: LD_INT 33
86078: PUSH
86079: LD_INT 34
86081: PUSH
86082: LD_INT 35
86084: PUSH
86085: LD_INT 36
86087: PUSH
86088: EMPTY
86089: LIST
86090: LIST
86091: LIST
86092: LIST
86093: LIST
86094: LIST
86095: LIST
86096: LIST
86097: LIST
86098: LIST
86099: LIST
86100: LIST
86101: LIST
86102: LIST
86103: LIST
86104: LIST
86105: LIST
86106: LIST
86107: LIST
86108: LIST
86109: LIST
86110: LIST
86111: LIST
86112: LIST
86113: LIST
86114: LIST
86115: LIST
86116: LIST
86117: LIST
86118: LIST
86119: LIST
86120: LIST
86121: LIST
86122: LIST
86123: LIST
86124: LIST
86125: PUSH
86126: LD_INT 101
86128: PUSH
86129: LD_INT 102
86131: PUSH
86132: LD_INT 103
86134: PUSH
86135: LD_INT 104
86137: PUSH
86138: LD_INT 105
86140: PUSH
86141: LD_INT 106
86143: PUSH
86144: LD_INT 107
86146: PUSH
86147: LD_INT 108
86149: PUSH
86150: LD_INT 109
86152: PUSH
86153: LD_INT 110
86155: PUSH
86156: LD_INT 111
86158: PUSH
86159: LD_INT 112
86161: PUSH
86162: LD_INT 113
86164: PUSH
86165: LD_INT 114
86167: PUSH
86168: LD_INT 115
86170: PUSH
86171: EMPTY
86172: LIST
86173: LIST
86174: LIST
86175: LIST
86176: LIST
86177: LIST
86178: LIST
86179: LIST
86180: LIST
86181: LIST
86182: LIST
86183: LIST
86184: LIST
86185: LIST
86186: LIST
86187: PUSH
86188: EMPTY
86189: LIST
86190: LIST
86191: ST_TO_ADDR
86192: GO 86195
86194: POP
// end else
86195: GO 86414
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
86197: LD_ADDR_VAR 0 1
86201: PUSH
86202: LD_INT 1
86204: PUSH
86205: LD_INT 2
86207: PUSH
86208: LD_INT 3
86210: PUSH
86211: LD_INT 4
86213: PUSH
86214: LD_INT 5
86216: PUSH
86217: LD_INT 6
86219: PUSH
86220: LD_INT 7
86222: PUSH
86223: LD_INT 8
86225: PUSH
86226: LD_INT 9
86228: PUSH
86229: LD_INT 10
86231: PUSH
86232: LD_INT 11
86234: PUSH
86235: LD_INT 12
86237: PUSH
86238: LD_INT 13
86240: PUSH
86241: LD_INT 14
86243: PUSH
86244: LD_INT 15
86246: PUSH
86247: LD_INT 16
86249: PUSH
86250: LD_INT 17
86252: PUSH
86253: LD_INT 18
86255: PUSH
86256: LD_INT 19
86258: PUSH
86259: LD_INT 20
86261: PUSH
86262: LD_INT 21
86264: PUSH
86265: LD_INT 22
86267: PUSH
86268: LD_INT 23
86270: PUSH
86271: LD_INT 24
86273: PUSH
86274: LD_INT 25
86276: PUSH
86277: LD_INT 26
86279: PUSH
86280: LD_INT 27
86282: PUSH
86283: LD_INT 28
86285: PUSH
86286: LD_INT 29
86288: PUSH
86289: LD_INT 30
86291: PUSH
86292: LD_INT 31
86294: PUSH
86295: LD_INT 32
86297: PUSH
86298: LD_INT 33
86300: PUSH
86301: LD_INT 34
86303: PUSH
86304: LD_INT 35
86306: PUSH
86307: LD_INT 36
86309: PUSH
86310: EMPTY
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: LIST
86323: LIST
86324: LIST
86325: LIST
86326: LIST
86327: LIST
86328: LIST
86329: LIST
86330: LIST
86331: LIST
86332: LIST
86333: LIST
86334: LIST
86335: LIST
86336: LIST
86337: LIST
86338: LIST
86339: LIST
86340: LIST
86341: LIST
86342: LIST
86343: LIST
86344: LIST
86345: LIST
86346: LIST
86347: PUSH
86348: LD_INT 101
86350: PUSH
86351: LD_INT 102
86353: PUSH
86354: LD_INT 103
86356: PUSH
86357: LD_INT 104
86359: PUSH
86360: LD_INT 105
86362: PUSH
86363: LD_INT 106
86365: PUSH
86366: LD_INT 107
86368: PUSH
86369: LD_INT 108
86371: PUSH
86372: LD_INT 109
86374: PUSH
86375: LD_INT 110
86377: PUSH
86378: LD_INT 111
86380: PUSH
86381: LD_INT 112
86383: PUSH
86384: LD_INT 113
86386: PUSH
86387: LD_INT 114
86389: PUSH
86390: LD_INT 115
86392: PUSH
86393: EMPTY
86394: LIST
86395: LIST
86396: LIST
86397: LIST
86398: LIST
86399: LIST
86400: LIST
86401: LIST
86402: LIST
86403: LIST
86404: LIST
86405: LIST
86406: LIST
86407: LIST
86408: LIST
86409: PUSH
86410: EMPTY
86411: LIST
86412: LIST
86413: ST_TO_ADDR
// if result then
86414: LD_VAR 0 1
86418: IFFALSE 86707
// begin normal :=  ;
86420: LD_ADDR_VAR 0 3
86424: PUSH
86425: LD_STRING 
86427: ST_TO_ADDR
// hardcore :=  ;
86428: LD_ADDR_VAR 0 4
86432: PUSH
86433: LD_STRING 
86435: ST_TO_ADDR
// for i = 1 to normalCounter do
86436: LD_ADDR_VAR 0 5
86440: PUSH
86441: DOUBLE
86442: LD_INT 1
86444: DEC
86445: ST_TO_ADDR
86446: LD_EXP 113
86450: PUSH
86451: FOR_TO
86452: IFFALSE 86553
// begin tmp := 0 ;
86454: LD_ADDR_VAR 0 2
86458: PUSH
86459: LD_STRING 0
86461: ST_TO_ADDR
// if result [ 1 ] then
86462: LD_VAR 0 1
86466: PUSH
86467: LD_INT 1
86469: ARRAY
86470: IFFALSE 86535
// if result [ 1 ] [ 1 ] = i then
86472: LD_VAR 0 1
86476: PUSH
86477: LD_INT 1
86479: ARRAY
86480: PUSH
86481: LD_INT 1
86483: ARRAY
86484: PUSH
86485: LD_VAR 0 5
86489: EQUAL
86490: IFFALSE 86535
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
86492: LD_ADDR_VAR 0 1
86496: PUSH
86497: LD_VAR 0 1
86501: PPUSH
86502: LD_INT 1
86504: PPUSH
86505: LD_VAR 0 1
86509: PUSH
86510: LD_INT 1
86512: ARRAY
86513: PPUSH
86514: LD_INT 1
86516: PPUSH
86517: CALL_OW 3
86521: PPUSH
86522: CALL_OW 1
86526: ST_TO_ADDR
// tmp := 1 ;
86527: LD_ADDR_VAR 0 2
86531: PUSH
86532: LD_STRING 1
86534: ST_TO_ADDR
// end ; normal := normal & tmp ;
86535: LD_ADDR_VAR 0 3
86539: PUSH
86540: LD_VAR 0 3
86544: PUSH
86545: LD_VAR 0 2
86549: STR
86550: ST_TO_ADDR
// end ;
86551: GO 86451
86553: POP
86554: POP
// for i = 1 to hardcoreCounter do
86555: LD_ADDR_VAR 0 5
86559: PUSH
86560: DOUBLE
86561: LD_INT 1
86563: DEC
86564: ST_TO_ADDR
86565: LD_EXP 114
86569: PUSH
86570: FOR_TO
86571: IFFALSE 86676
// begin tmp := 0 ;
86573: LD_ADDR_VAR 0 2
86577: PUSH
86578: LD_STRING 0
86580: ST_TO_ADDR
// if result [ 2 ] then
86581: LD_VAR 0 1
86585: PUSH
86586: LD_INT 2
86588: ARRAY
86589: IFFALSE 86658
// if result [ 2 ] [ 1 ] = 100 + i then
86591: LD_VAR 0 1
86595: PUSH
86596: LD_INT 2
86598: ARRAY
86599: PUSH
86600: LD_INT 1
86602: ARRAY
86603: PUSH
86604: LD_INT 100
86606: PUSH
86607: LD_VAR 0 5
86611: PLUS
86612: EQUAL
86613: IFFALSE 86658
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
86615: LD_ADDR_VAR 0 1
86619: PUSH
86620: LD_VAR 0 1
86624: PPUSH
86625: LD_INT 2
86627: PPUSH
86628: LD_VAR 0 1
86632: PUSH
86633: LD_INT 2
86635: ARRAY
86636: PPUSH
86637: LD_INT 1
86639: PPUSH
86640: CALL_OW 3
86644: PPUSH
86645: CALL_OW 1
86649: ST_TO_ADDR
// tmp := 1 ;
86650: LD_ADDR_VAR 0 2
86654: PUSH
86655: LD_STRING 1
86657: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
86658: LD_ADDR_VAR 0 4
86662: PUSH
86663: LD_VAR 0 4
86667: PUSH
86668: LD_VAR 0 2
86672: STR
86673: ST_TO_ADDR
// end ;
86674: GO 86570
86676: POP
86677: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
86678: LD_STRING getStreamItemsFromMission("
86680: PUSH
86681: LD_VAR 0 3
86685: STR
86686: PUSH
86687: LD_STRING ","
86689: STR
86690: PUSH
86691: LD_VAR 0 4
86695: STR
86696: PUSH
86697: LD_STRING ")
86699: STR
86700: PPUSH
86701: CALL_OW 559
// end else
86705: GO 86714
// ToLua ( getStreamItemsFromMission("","") ) ;
86707: LD_STRING getStreamItemsFromMission("","")
86709: PPUSH
86710: CALL_OW 559
// end ;
86714: LD_VAR 0 1
86718: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
86719: LD_EXP 112
86723: PUSH
86724: LD_EXP 117
86728: AND
86729: IFFALSE 86853
86731: GO 86733
86733: DISABLE
86734: LD_INT 0
86736: PPUSH
86737: PPUSH
// begin enable ;
86738: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
86739: LD_ADDR_VAR 0 2
86743: PUSH
86744: LD_INT 22
86746: PUSH
86747: LD_OWVAR 2
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: LD_INT 2
86758: PUSH
86759: LD_INT 34
86761: PUSH
86762: LD_INT 7
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: LD_INT 34
86771: PUSH
86772: LD_INT 45
86774: PUSH
86775: EMPTY
86776: LIST
86777: LIST
86778: PUSH
86779: LD_INT 34
86781: PUSH
86782: LD_INT 28
86784: PUSH
86785: EMPTY
86786: LIST
86787: LIST
86788: PUSH
86789: LD_INT 34
86791: PUSH
86792: LD_INT 47
86794: PUSH
86795: EMPTY
86796: LIST
86797: LIST
86798: PUSH
86799: EMPTY
86800: LIST
86801: LIST
86802: LIST
86803: LIST
86804: LIST
86805: PUSH
86806: EMPTY
86807: LIST
86808: LIST
86809: PPUSH
86810: CALL_OW 69
86814: ST_TO_ADDR
// if not tmp then
86815: LD_VAR 0 2
86819: NOT
86820: IFFALSE 86824
// exit ;
86822: GO 86853
// for i in tmp do
86824: LD_ADDR_VAR 0 1
86828: PUSH
86829: LD_VAR 0 2
86833: PUSH
86834: FOR_IN
86835: IFFALSE 86851
// begin SetLives ( i , 0 ) ;
86837: LD_VAR 0 1
86841: PPUSH
86842: LD_INT 0
86844: PPUSH
86845: CALL_OW 234
// end ;
86849: GO 86834
86851: POP
86852: POP
// end ;
86853: PPOPN 2
86855: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
86856: LD_EXP 112
86860: PUSH
86861: LD_EXP 118
86865: AND
86866: IFFALSE 86950
86868: GO 86870
86870: DISABLE
86871: LD_INT 0
86873: PPUSH
86874: PPUSH
// begin enable ;
86875: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
86876: LD_ADDR_VAR 0 2
86880: PUSH
86881: LD_INT 22
86883: PUSH
86884: LD_OWVAR 2
86888: PUSH
86889: EMPTY
86890: LIST
86891: LIST
86892: PUSH
86893: LD_INT 32
86895: PUSH
86896: LD_INT 3
86898: PUSH
86899: EMPTY
86900: LIST
86901: LIST
86902: PUSH
86903: EMPTY
86904: LIST
86905: LIST
86906: PPUSH
86907: CALL_OW 69
86911: ST_TO_ADDR
// if not tmp then
86912: LD_VAR 0 2
86916: NOT
86917: IFFALSE 86921
// exit ;
86919: GO 86950
// for i in tmp do
86921: LD_ADDR_VAR 0 1
86925: PUSH
86926: LD_VAR 0 2
86930: PUSH
86931: FOR_IN
86932: IFFALSE 86948
// begin SetLives ( i , 0 ) ;
86934: LD_VAR 0 1
86938: PPUSH
86939: LD_INT 0
86941: PPUSH
86942: CALL_OW 234
// end ;
86946: GO 86931
86948: POP
86949: POP
// end ;
86950: PPOPN 2
86952: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
86953: LD_EXP 112
86957: PUSH
86958: LD_EXP 115
86962: AND
86963: IFFALSE 87056
86965: GO 86967
86967: DISABLE
86968: LD_INT 0
86970: PPUSH
// begin enable ;
86971: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
86972: LD_ADDR_VAR 0 1
86976: PUSH
86977: LD_INT 22
86979: PUSH
86980: LD_OWVAR 2
86984: PUSH
86985: EMPTY
86986: LIST
86987: LIST
86988: PUSH
86989: LD_INT 2
86991: PUSH
86992: LD_INT 25
86994: PUSH
86995: LD_INT 5
86997: PUSH
86998: EMPTY
86999: LIST
87000: LIST
87001: PUSH
87002: LD_INT 25
87004: PUSH
87005: LD_INT 9
87007: PUSH
87008: EMPTY
87009: LIST
87010: LIST
87011: PUSH
87012: LD_INT 25
87014: PUSH
87015: LD_INT 8
87017: PUSH
87018: EMPTY
87019: LIST
87020: LIST
87021: PUSH
87022: EMPTY
87023: LIST
87024: LIST
87025: LIST
87026: LIST
87027: PUSH
87028: EMPTY
87029: LIST
87030: LIST
87031: PPUSH
87032: CALL_OW 69
87036: PUSH
87037: FOR_IN
87038: IFFALSE 87054
// begin SetClass ( i , 1 ) ;
87040: LD_VAR 0 1
87044: PPUSH
87045: LD_INT 1
87047: PPUSH
87048: CALL_OW 336
// end ;
87052: GO 87037
87054: POP
87055: POP
// end ;
87056: PPOPN 1
87058: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
87059: LD_EXP 112
87063: PUSH
87064: LD_EXP 116
87068: AND
87069: PUSH
87070: LD_OWVAR 65
87074: PUSH
87075: LD_INT 7
87077: LESS
87078: AND
87079: IFFALSE 87093
87081: GO 87083
87083: DISABLE
// begin enable ;
87084: ENABLE
// game_speed := 7 ;
87085: LD_ADDR_OWVAR 65
87089: PUSH
87090: LD_INT 7
87092: ST_TO_ADDR
// end ;
87093: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
87094: LD_EXP 112
87098: PUSH
87099: LD_EXP 119
87103: AND
87104: IFFALSE 87306
87106: GO 87108
87108: DISABLE
87109: LD_INT 0
87111: PPUSH
87112: PPUSH
87113: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
87114: LD_ADDR_VAR 0 3
87118: PUSH
87119: LD_INT 81
87121: PUSH
87122: LD_OWVAR 2
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: PUSH
87131: LD_INT 21
87133: PUSH
87134: LD_INT 1
87136: PUSH
87137: EMPTY
87138: LIST
87139: LIST
87140: PUSH
87141: EMPTY
87142: LIST
87143: LIST
87144: PPUSH
87145: CALL_OW 69
87149: ST_TO_ADDR
// if not tmp then
87150: LD_VAR 0 3
87154: NOT
87155: IFFALSE 87159
// exit ;
87157: GO 87306
// if tmp > 5 then
87159: LD_VAR 0 3
87163: PUSH
87164: LD_INT 5
87166: GREATER
87167: IFFALSE 87179
// k := 5 else
87169: LD_ADDR_VAR 0 2
87173: PUSH
87174: LD_INT 5
87176: ST_TO_ADDR
87177: GO 87189
// k := tmp ;
87179: LD_ADDR_VAR 0 2
87183: PUSH
87184: LD_VAR 0 3
87188: ST_TO_ADDR
// for i := 1 to k do
87189: LD_ADDR_VAR 0 1
87193: PUSH
87194: DOUBLE
87195: LD_INT 1
87197: DEC
87198: ST_TO_ADDR
87199: LD_VAR 0 2
87203: PUSH
87204: FOR_TO
87205: IFFALSE 87304
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
87207: LD_VAR 0 3
87211: PUSH
87212: LD_VAR 0 1
87216: ARRAY
87217: PPUSH
87218: LD_VAR 0 1
87222: PUSH
87223: LD_INT 4
87225: MOD
87226: PUSH
87227: LD_INT 1
87229: PLUS
87230: PPUSH
87231: CALL_OW 259
87235: PUSH
87236: LD_INT 10
87238: LESS
87239: IFFALSE 87302
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
87241: LD_VAR 0 3
87245: PUSH
87246: LD_VAR 0 1
87250: ARRAY
87251: PPUSH
87252: LD_VAR 0 1
87256: PUSH
87257: LD_INT 4
87259: MOD
87260: PUSH
87261: LD_INT 1
87263: PLUS
87264: PPUSH
87265: LD_VAR 0 3
87269: PUSH
87270: LD_VAR 0 1
87274: ARRAY
87275: PPUSH
87276: LD_VAR 0 1
87280: PUSH
87281: LD_INT 4
87283: MOD
87284: PUSH
87285: LD_INT 1
87287: PLUS
87288: PPUSH
87289: CALL_OW 259
87293: PUSH
87294: LD_INT 1
87296: PLUS
87297: PPUSH
87298: CALL_OW 237
87302: GO 87204
87304: POP
87305: POP
// end ;
87306: PPOPN 3
87308: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
87309: LD_EXP 112
87313: PUSH
87314: LD_EXP 120
87318: AND
87319: IFFALSE 87339
87321: GO 87323
87323: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
87324: LD_INT 4
87326: PPUSH
87327: LD_OWVAR 2
87331: PPUSH
87332: LD_INT 0
87334: PPUSH
87335: CALL_OW 324
87339: END
// every 0 0$1 trigger StreamModeActive and sShovel do
87340: LD_EXP 112
87344: PUSH
87345: LD_EXP 149
87349: AND
87350: IFFALSE 87370
87352: GO 87354
87354: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
87355: LD_INT 19
87357: PPUSH
87358: LD_OWVAR 2
87362: PPUSH
87363: LD_INT 0
87365: PPUSH
87366: CALL_OW 324
87370: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
87371: LD_EXP 112
87375: PUSH
87376: LD_EXP 121
87380: AND
87381: IFFALSE 87483
87383: GO 87385
87385: DISABLE
87386: LD_INT 0
87388: PPUSH
87389: PPUSH
// begin enable ;
87390: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
87391: LD_ADDR_VAR 0 2
87395: PUSH
87396: LD_INT 22
87398: PUSH
87399: LD_OWVAR 2
87403: PUSH
87404: EMPTY
87405: LIST
87406: LIST
87407: PUSH
87408: LD_INT 2
87410: PUSH
87411: LD_INT 34
87413: PUSH
87414: LD_INT 11
87416: PUSH
87417: EMPTY
87418: LIST
87419: LIST
87420: PUSH
87421: LD_INT 34
87423: PUSH
87424: LD_INT 30
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: PUSH
87431: EMPTY
87432: LIST
87433: LIST
87434: LIST
87435: PUSH
87436: EMPTY
87437: LIST
87438: LIST
87439: PPUSH
87440: CALL_OW 69
87444: ST_TO_ADDR
// if not tmp then
87445: LD_VAR 0 2
87449: NOT
87450: IFFALSE 87454
// exit ;
87452: GO 87483
// for i in tmp do
87454: LD_ADDR_VAR 0 1
87458: PUSH
87459: LD_VAR 0 2
87463: PUSH
87464: FOR_IN
87465: IFFALSE 87481
// begin SetLives ( i , 0 ) ;
87467: LD_VAR 0 1
87471: PPUSH
87472: LD_INT 0
87474: PPUSH
87475: CALL_OW 234
// end ;
87479: GO 87464
87481: POP
87482: POP
// end ;
87483: PPOPN 2
87485: END
// every 0 0$1 trigger StreamModeActive and sBunker do
87486: LD_EXP 112
87490: PUSH
87491: LD_EXP 122
87495: AND
87496: IFFALSE 87516
87498: GO 87500
87500: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
87501: LD_INT 32
87503: PPUSH
87504: LD_OWVAR 2
87508: PPUSH
87509: LD_INT 0
87511: PPUSH
87512: CALL_OW 324
87516: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
87517: LD_EXP 112
87521: PUSH
87522: LD_EXP 123
87526: AND
87527: IFFALSE 87708
87529: GO 87531
87531: DISABLE
87532: LD_INT 0
87534: PPUSH
87535: PPUSH
87536: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
87537: LD_ADDR_VAR 0 2
87541: PUSH
87542: LD_INT 22
87544: PUSH
87545: LD_OWVAR 2
87549: PUSH
87550: EMPTY
87551: LIST
87552: LIST
87553: PUSH
87554: LD_INT 33
87556: PUSH
87557: LD_INT 3
87559: PUSH
87560: EMPTY
87561: LIST
87562: LIST
87563: PUSH
87564: EMPTY
87565: LIST
87566: LIST
87567: PPUSH
87568: CALL_OW 69
87572: ST_TO_ADDR
// if not tmp then
87573: LD_VAR 0 2
87577: NOT
87578: IFFALSE 87582
// exit ;
87580: GO 87708
// side := 0 ;
87582: LD_ADDR_VAR 0 3
87586: PUSH
87587: LD_INT 0
87589: ST_TO_ADDR
// for i := 1 to 8 do
87590: LD_ADDR_VAR 0 1
87594: PUSH
87595: DOUBLE
87596: LD_INT 1
87598: DEC
87599: ST_TO_ADDR
87600: LD_INT 8
87602: PUSH
87603: FOR_TO
87604: IFFALSE 87652
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
87606: LD_OWVAR 2
87610: PUSH
87611: LD_VAR 0 1
87615: NONEQUAL
87616: PUSH
87617: LD_OWVAR 2
87621: PPUSH
87622: LD_VAR 0 1
87626: PPUSH
87627: CALL_OW 81
87631: PUSH
87632: LD_INT 2
87634: EQUAL
87635: AND
87636: IFFALSE 87650
// begin side := i ;
87638: LD_ADDR_VAR 0 3
87642: PUSH
87643: LD_VAR 0 1
87647: ST_TO_ADDR
// break ;
87648: GO 87652
// end ;
87650: GO 87603
87652: POP
87653: POP
// if not side then
87654: LD_VAR 0 3
87658: NOT
87659: IFFALSE 87663
// exit ;
87661: GO 87708
// for i := 1 to tmp do
87663: LD_ADDR_VAR 0 1
87667: PUSH
87668: DOUBLE
87669: LD_INT 1
87671: DEC
87672: ST_TO_ADDR
87673: LD_VAR 0 2
87677: PUSH
87678: FOR_TO
87679: IFFALSE 87706
// if Prob ( 60 ) then
87681: LD_INT 60
87683: PPUSH
87684: CALL_OW 13
87688: IFFALSE 87704
// SetSide ( i , side ) ;
87690: LD_VAR 0 1
87694: PPUSH
87695: LD_VAR 0 3
87699: PPUSH
87700: CALL_OW 235
87704: GO 87678
87706: POP
87707: POP
// end ;
87708: PPOPN 3
87710: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
87711: LD_EXP 112
87715: PUSH
87716: LD_EXP 125
87720: AND
87721: IFFALSE 87840
87723: GO 87725
87725: DISABLE
87726: LD_INT 0
87728: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
87729: LD_ADDR_VAR 0 1
87733: PUSH
87734: LD_INT 22
87736: PUSH
87737: LD_OWVAR 2
87741: PUSH
87742: EMPTY
87743: LIST
87744: LIST
87745: PUSH
87746: LD_INT 21
87748: PUSH
87749: LD_INT 1
87751: PUSH
87752: EMPTY
87753: LIST
87754: LIST
87755: PUSH
87756: LD_INT 3
87758: PUSH
87759: LD_INT 23
87761: PUSH
87762: LD_INT 0
87764: PUSH
87765: EMPTY
87766: LIST
87767: LIST
87768: PUSH
87769: EMPTY
87770: LIST
87771: LIST
87772: PUSH
87773: EMPTY
87774: LIST
87775: LIST
87776: LIST
87777: PPUSH
87778: CALL_OW 69
87782: PUSH
87783: FOR_IN
87784: IFFALSE 87838
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
87786: LD_VAR 0 1
87790: PPUSH
87791: CALL_OW 257
87795: PUSH
87796: LD_INT 1
87798: PUSH
87799: LD_INT 2
87801: PUSH
87802: LD_INT 3
87804: PUSH
87805: LD_INT 4
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: LIST
87812: LIST
87813: IN
87814: IFFALSE 87836
// SetClass ( un , rand ( 1 , 4 ) ) ;
87816: LD_VAR 0 1
87820: PPUSH
87821: LD_INT 1
87823: PPUSH
87824: LD_INT 4
87826: PPUSH
87827: CALL_OW 12
87831: PPUSH
87832: CALL_OW 336
87836: GO 87783
87838: POP
87839: POP
// end ;
87840: PPOPN 1
87842: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
87843: LD_EXP 112
87847: PUSH
87848: LD_EXP 124
87852: AND
87853: IFFALSE 87932
87855: GO 87857
87857: DISABLE
87858: LD_INT 0
87860: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
87861: LD_ADDR_VAR 0 1
87865: PUSH
87866: LD_INT 22
87868: PUSH
87869: LD_OWVAR 2
87873: PUSH
87874: EMPTY
87875: LIST
87876: LIST
87877: PUSH
87878: LD_INT 21
87880: PUSH
87881: LD_INT 3
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: PUSH
87888: EMPTY
87889: LIST
87890: LIST
87891: PPUSH
87892: CALL_OW 69
87896: ST_TO_ADDR
// if not tmp then
87897: LD_VAR 0 1
87901: NOT
87902: IFFALSE 87906
// exit ;
87904: GO 87932
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
87906: LD_VAR 0 1
87910: PUSH
87911: LD_INT 1
87913: PPUSH
87914: LD_VAR 0 1
87918: PPUSH
87919: CALL_OW 12
87923: ARRAY
87924: PPUSH
87925: LD_INT 100
87927: PPUSH
87928: CALL_OW 234
// end ;
87932: PPOPN 1
87934: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
87935: LD_EXP 112
87939: PUSH
87940: LD_EXP 126
87944: AND
87945: IFFALSE 88043
87947: GO 87949
87949: DISABLE
87950: LD_INT 0
87952: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
87953: LD_ADDR_VAR 0 1
87957: PUSH
87958: LD_INT 22
87960: PUSH
87961: LD_OWVAR 2
87965: PUSH
87966: EMPTY
87967: LIST
87968: LIST
87969: PUSH
87970: LD_INT 21
87972: PUSH
87973: LD_INT 1
87975: PUSH
87976: EMPTY
87977: LIST
87978: LIST
87979: PUSH
87980: EMPTY
87981: LIST
87982: LIST
87983: PPUSH
87984: CALL_OW 69
87988: ST_TO_ADDR
// if not tmp then
87989: LD_VAR 0 1
87993: NOT
87994: IFFALSE 87998
// exit ;
87996: GO 88043
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
87998: LD_VAR 0 1
88002: PUSH
88003: LD_INT 1
88005: PPUSH
88006: LD_VAR 0 1
88010: PPUSH
88011: CALL_OW 12
88015: ARRAY
88016: PPUSH
88017: LD_INT 1
88019: PPUSH
88020: LD_INT 4
88022: PPUSH
88023: CALL_OW 12
88027: PPUSH
88028: LD_INT 3000
88030: PPUSH
88031: LD_INT 9000
88033: PPUSH
88034: CALL_OW 12
88038: PPUSH
88039: CALL_OW 492
// end ;
88043: PPOPN 1
88045: END
// every 0 0$1 trigger StreamModeActive and sDepot do
88046: LD_EXP 112
88050: PUSH
88051: LD_EXP 127
88055: AND
88056: IFFALSE 88076
88058: GO 88060
88060: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
88061: LD_INT 1
88063: PPUSH
88064: LD_OWVAR 2
88068: PPUSH
88069: LD_INT 0
88071: PPUSH
88072: CALL_OW 324
88076: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
88077: LD_EXP 112
88081: PUSH
88082: LD_EXP 128
88086: AND
88087: IFFALSE 88170
88089: GO 88091
88091: DISABLE
88092: LD_INT 0
88094: PPUSH
88095: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
88096: LD_ADDR_VAR 0 2
88100: PUSH
88101: LD_INT 22
88103: PUSH
88104: LD_OWVAR 2
88108: PUSH
88109: EMPTY
88110: LIST
88111: LIST
88112: PUSH
88113: LD_INT 21
88115: PUSH
88116: LD_INT 3
88118: PUSH
88119: EMPTY
88120: LIST
88121: LIST
88122: PUSH
88123: EMPTY
88124: LIST
88125: LIST
88126: PPUSH
88127: CALL_OW 69
88131: ST_TO_ADDR
// if not tmp then
88132: LD_VAR 0 2
88136: NOT
88137: IFFALSE 88141
// exit ;
88139: GO 88170
// for i in tmp do
88141: LD_ADDR_VAR 0 1
88145: PUSH
88146: LD_VAR 0 2
88150: PUSH
88151: FOR_IN
88152: IFFALSE 88168
// SetBLevel ( i , 10 ) ;
88154: LD_VAR 0 1
88158: PPUSH
88159: LD_INT 10
88161: PPUSH
88162: CALL_OW 241
88166: GO 88151
88168: POP
88169: POP
// end ;
88170: PPOPN 2
88172: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
88173: LD_EXP 112
88177: PUSH
88178: LD_EXP 129
88182: AND
88183: IFFALSE 88294
88185: GO 88187
88187: DISABLE
88188: LD_INT 0
88190: PPUSH
88191: PPUSH
88192: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
88193: LD_ADDR_VAR 0 3
88197: PUSH
88198: LD_INT 22
88200: PUSH
88201: LD_OWVAR 2
88205: PUSH
88206: EMPTY
88207: LIST
88208: LIST
88209: PUSH
88210: LD_INT 25
88212: PUSH
88213: LD_INT 1
88215: PUSH
88216: EMPTY
88217: LIST
88218: LIST
88219: PUSH
88220: EMPTY
88221: LIST
88222: LIST
88223: PPUSH
88224: CALL_OW 69
88228: ST_TO_ADDR
// if not tmp then
88229: LD_VAR 0 3
88233: NOT
88234: IFFALSE 88238
// exit ;
88236: GO 88294
// un := tmp [ rand ( 1 , tmp ) ] ;
88238: LD_ADDR_VAR 0 2
88242: PUSH
88243: LD_VAR 0 3
88247: PUSH
88248: LD_INT 1
88250: PPUSH
88251: LD_VAR 0 3
88255: PPUSH
88256: CALL_OW 12
88260: ARRAY
88261: ST_TO_ADDR
// if Crawls ( un ) then
88262: LD_VAR 0 2
88266: PPUSH
88267: CALL_OW 318
88271: IFFALSE 88282
// ComWalk ( un ) ;
88273: LD_VAR 0 2
88277: PPUSH
88278: CALL_OW 138
// SetClass ( un , class_sniper ) ;
88282: LD_VAR 0 2
88286: PPUSH
88287: LD_INT 5
88289: PPUSH
88290: CALL_OW 336
// end ;
88294: PPOPN 3
88296: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
88297: LD_EXP 112
88301: PUSH
88302: LD_EXP 130
88306: AND
88307: PUSH
88308: LD_OWVAR 67
88312: PUSH
88313: LD_INT 3
88315: LESS
88316: AND
88317: IFFALSE 88336
88319: GO 88321
88321: DISABLE
// Difficulty := Difficulty + 1 ;
88322: LD_ADDR_OWVAR 67
88326: PUSH
88327: LD_OWVAR 67
88331: PUSH
88332: LD_INT 1
88334: PLUS
88335: ST_TO_ADDR
88336: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
88337: LD_EXP 112
88341: PUSH
88342: LD_EXP 131
88346: AND
88347: IFFALSE 88450
88349: GO 88351
88351: DISABLE
88352: LD_INT 0
88354: PPUSH
// begin for i := 1 to 5 do
88355: LD_ADDR_VAR 0 1
88359: PUSH
88360: DOUBLE
88361: LD_INT 1
88363: DEC
88364: ST_TO_ADDR
88365: LD_INT 5
88367: PUSH
88368: FOR_TO
88369: IFFALSE 88448
// begin uc_nation := nation_nature ;
88371: LD_ADDR_OWVAR 21
88375: PUSH
88376: LD_INT 0
88378: ST_TO_ADDR
// uc_side := 0 ;
88379: LD_ADDR_OWVAR 20
88383: PUSH
88384: LD_INT 0
88386: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
88387: LD_ADDR_OWVAR 29
88391: PUSH
88392: LD_INT 12
88394: PUSH
88395: LD_INT 12
88397: PUSH
88398: EMPTY
88399: LIST
88400: LIST
88401: ST_TO_ADDR
// hc_agressivity := 20 ;
88402: LD_ADDR_OWVAR 35
88406: PUSH
88407: LD_INT 20
88409: ST_TO_ADDR
// hc_class := class_tiger ;
88410: LD_ADDR_OWVAR 28
88414: PUSH
88415: LD_INT 14
88417: ST_TO_ADDR
// hc_gallery :=  ;
88418: LD_ADDR_OWVAR 33
88422: PUSH
88423: LD_STRING 
88425: ST_TO_ADDR
// hc_name :=  ;
88426: LD_ADDR_OWVAR 26
88430: PUSH
88431: LD_STRING 
88433: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
88434: CALL_OW 44
88438: PPUSH
88439: LD_INT 0
88441: PPUSH
88442: CALL_OW 51
// end ;
88446: GO 88368
88448: POP
88449: POP
// end ;
88450: PPOPN 1
88452: END
// every 0 0$1 trigger StreamModeActive and sBomb do
88453: LD_EXP 112
88457: PUSH
88458: LD_EXP 132
88462: AND
88463: IFFALSE 88472
88465: GO 88467
88467: DISABLE
// StreamSibBomb ;
88468: CALL 88473 0 0
88472: END
// export function StreamSibBomb ; var i , x , y ; begin
88473: LD_INT 0
88475: PPUSH
88476: PPUSH
88477: PPUSH
88478: PPUSH
// result := false ;
88479: LD_ADDR_VAR 0 1
88483: PUSH
88484: LD_INT 0
88486: ST_TO_ADDR
// for i := 1 to 16 do
88487: LD_ADDR_VAR 0 2
88491: PUSH
88492: DOUBLE
88493: LD_INT 1
88495: DEC
88496: ST_TO_ADDR
88497: LD_INT 16
88499: PUSH
88500: FOR_TO
88501: IFFALSE 88700
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
88503: LD_ADDR_VAR 0 3
88507: PUSH
88508: LD_INT 10
88510: PUSH
88511: LD_INT 20
88513: PUSH
88514: LD_INT 30
88516: PUSH
88517: LD_INT 40
88519: PUSH
88520: LD_INT 50
88522: PUSH
88523: LD_INT 60
88525: PUSH
88526: LD_INT 70
88528: PUSH
88529: LD_INT 80
88531: PUSH
88532: LD_INT 90
88534: PUSH
88535: LD_INT 100
88537: PUSH
88538: LD_INT 110
88540: PUSH
88541: LD_INT 120
88543: PUSH
88544: LD_INT 130
88546: PUSH
88547: LD_INT 140
88549: PUSH
88550: LD_INT 150
88552: PUSH
88553: EMPTY
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: PUSH
88570: LD_INT 1
88572: PPUSH
88573: LD_INT 15
88575: PPUSH
88576: CALL_OW 12
88580: ARRAY
88581: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
88582: LD_ADDR_VAR 0 4
88586: PUSH
88587: LD_INT 10
88589: PUSH
88590: LD_INT 20
88592: PUSH
88593: LD_INT 30
88595: PUSH
88596: LD_INT 40
88598: PUSH
88599: LD_INT 50
88601: PUSH
88602: LD_INT 60
88604: PUSH
88605: LD_INT 70
88607: PUSH
88608: LD_INT 80
88610: PUSH
88611: LD_INT 90
88613: PUSH
88614: LD_INT 100
88616: PUSH
88617: LD_INT 110
88619: PUSH
88620: LD_INT 120
88622: PUSH
88623: LD_INT 130
88625: PUSH
88626: LD_INT 140
88628: PUSH
88629: LD_INT 150
88631: PUSH
88632: EMPTY
88633: LIST
88634: LIST
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: PUSH
88649: LD_INT 1
88651: PPUSH
88652: LD_INT 15
88654: PPUSH
88655: CALL_OW 12
88659: ARRAY
88660: ST_TO_ADDR
// if ValidHex ( x , y ) then
88661: LD_VAR 0 3
88665: PPUSH
88666: LD_VAR 0 4
88670: PPUSH
88671: CALL_OW 488
88675: IFFALSE 88698
// begin result := [ x , y ] ;
88677: LD_ADDR_VAR 0 1
88681: PUSH
88682: LD_VAR 0 3
88686: PUSH
88687: LD_VAR 0 4
88691: PUSH
88692: EMPTY
88693: LIST
88694: LIST
88695: ST_TO_ADDR
// break ;
88696: GO 88700
// end ; end ;
88698: GO 88500
88700: POP
88701: POP
// if result then
88702: LD_VAR 0 1
88706: IFFALSE 88766
// begin ToLua ( playSibBomb() ) ;
88708: LD_STRING playSibBomb()
88710: PPUSH
88711: CALL_OW 559
// wait ( 0 0$14 ) ;
88715: LD_INT 490
88717: PPUSH
88718: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
88722: LD_VAR 0 1
88726: PUSH
88727: LD_INT 1
88729: ARRAY
88730: PPUSH
88731: LD_VAR 0 1
88735: PUSH
88736: LD_INT 2
88738: ARRAY
88739: PPUSH
88740: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
88744: LD_VAR 0 1
88748: PUSH
88749: LD_INT 1
88751: ARRAY
88752: PPUSH
88753: LD_VAR 0 1
88757: PUSH
88758: LD_INT 2
88760: ARRAY
88761: PPUSH
88762: CALL_OW 429
// end ; end ;
88766: LD_VAR 0 1
88770: RET
// every 0 0$1 trigger StreamModeActive and sReset do
88771: LD_EXP 112
88775: PUSH
88776: LD_EXP 134
88780: AND
88781: IFFALSE 88793
88783: GO 88785
88785: DISABLE
// YouLost (  ) ;
88786: LD_STRING 
88788: PPUSH
88789: CALL_OW 104
88793: END
// every 0 0$1 trigger StreamModeActive and sFog do
88794: LD_EXP 112
88798: PUSH
88799: LD_EXP 133
88803: AND
88804: IFFALSE 88818
88806: GO 88808
88808: DISABLE
// FogOff ( your_side ) ;
88809: LD_OWVAR 2
88813: PPUSH
88814: CALL_OW 344
88818: END
// every 0 0$1 trigger StreamModeActive and sSun do
88819: LD_EXP 112
88823: PUSH
88824: LD_EXP 135
88828: AND
88829: IFFALSE 88857
88831: GO 88833
88833: DISABLE
// begin solar_recharge_percent := 0 ;
88834: LD_ADDR_OWVAR 79
88838: PUSH
88839: LD_INT 0
88841: ST_TO_ADDR
// wait ( 5 5$00 ) ;
88842: LD_INT 10500
88844: PPUSH
88845: CALL_OW 67
// solar_recharge_percent := 100 ;
88849: LD_ADDR_OWVAR 79
88853: PUSH
88854: LD_INT 100
88856: ST_TO_ADDR
// end ;
88857: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
88858: LD_EXP 112
88862: PUSH
88863: LD_EXP 136
88867: AND
88868: IFFALSE 89107
88870: GO 88872
88872: DISABLE
88873: LD_INT 0
88875: PPUSH
88876: PPUSH
88877: PPUSH
// begin tmp := [ ] ;
88878: LD_ADDR_VAR 0 3
88882: PUSH
88883: EMPTY
88884: ST_TO_ADDR
// for i := 1 to 6 do
88885: LD_ADDR_VAR 0 1
88889: PUSH
88890: DOUBLE
88891: LD_INT 1
88893: DEC
88894: ST_TO_ADDR
88895: LD_INT 6
88897: PUSH
88898: FOR_TO
88899: IFFALSE 89004
// begin uc_nation := nation_nature ;
88901: LD_ADDR_OWVAR 21
88905: PUSH
88906: LD_INT 0
88908: ST_TO_ADDR
// uc_side := 0 ;
88909: LD_ADDR_OWVAR 20
88913: PUSH
88914: LD_INT 0
88916: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
88917: LD_ADDR_OWVAR 29
88921: PUSH
88922: LD_INT 12
88924: PUSH
88925: LD_INT 12
88927: PUSH
88928: EMPTY
88929: LIST
88930: LIST
88931: ST_TO_ADDR
// hc_agressivity := 20 ;
88932: LD_ADDR_OWVAR 35
88936: PUSH
88937: LD_INT 20
88939: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
88940: LD_ADDR_OWVAR 28
88944: PUSH
88945: LD_INT 17
88947: ST_TO_ADDR
// hc_gallery :=  ;
88948: LD_ADDR_OWVAR 33
88952: PUSH
88953: LD_STRING 
88955: ST_TO_ADDR
// hc_name :=  ;
88956: LD_ADDR_OWVAR 26
88960: PUSH
88961: LD_STRING 
88963: ST_TO_ADDR
// un := CreateHuman ;
88964: LD_ADDR_VAR 0 2
88968: PUSH
88969: CALL_OW 44
88973: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
88974: LD_VAR 0 2
88978: PPUSH
88979: LD_INT 1
88981: PPUSH
88982: CALL_OW 51
// tmp := tmp ^ un ;
88986: LD_ADDR_VAR 0 3
88990: PUSH
88991: LD_VAR 0 3
88995: PUSH
88996: LD_VAR 0 2
89000: ADD
89001: ST_TO_ADDR
// end ;
89002: GO 88898
89004: POP
89005: POP
// repeat wait ( 0 0$1 ) ;
89006: LD_INT 35
89008: PPUSH
89009: CALL_OW 67
// for un in tmp do
89013: LD_ADDR_VAR 0 2
89017: PUSH
89018: LD_VAR 0 3
89022: PUSH
89023: FOR_IN
89024: IFFALSE 89098
// begin if IsDead ( un ) then
89026: LD_VAR 0 2
89030: PPUSH
89031: CALL_OW 301
89035: IFFALSE 89055
// begin tmp := tmp diff un ;
89037: LD_ADDR_VAR 0 3
89041: PUSH
89042: LD_VAR 0 3
89046: PUSH
89047: LD_VAR 0 2
89051: DIFF
89052: ST_TO_ADDR
// continue ;
89053: GO 89023
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
89055: LD_VAR 0 2
89059: PPUSH
89060: LD_INT 3
89062: PUSH
89063: LD_INT 22
89065: PUSH
89066: LD_INT 0
89068: PUSH
89069: EMPTY
89070: LIST
89071: LIST
89072: PUSH
89073: EMPTY
89074: LIST
89075: LIST
89076: PPUSH
89077: CALL_OW 69
89081: PPUSH
89082: LD_VAR 0 2
89086: PPUSH
89087: CALL_OW 74
89091: PPUSH
89092: CALL_OW 115
// end ;
89096: GO 89023
89098: POP
89099: POP
// until not tmp ;
89100: LD_VAR 0 3
89104: NOT
89105: IFFALSE 89006
// end ;
89107: PPOPN 3
89109: END
// every 0 0$1 trigger StreamModeActive and sTroll do
89110: LD_EXP 112
89114: PUSH
89115: LD_EXP 137
89119: AND
89120: IFFALSE 89174
89122: GO 89124
89124: DISABLE
// begin ToLua ( displayTroll(); ) ;
89125: LD_STRING displayTroll();
89127: PPUSH
89128: CALL_OW 559
// wait ( 3 3$00 ) ;
89132: LD_INT 6300
89134: PPUSH
89135: CALL_OW 67
// ToLua ( hideTroll(); ) ;
89139: LD_STRING hideTroll();
89141: PPUSH
89142: CALL_OW 559
// wait ( 1 1$00 ) ;
89146: LD_INT 2100
89148: PPUSH
89149: CALL_OW 67
// ToLua ( displayTroll(); ) ;
89153: LD_STRING displayTroll();
89155: PPUSH
89156: CALL_OW 559
// wait ( 1 1$00 ) ;
89160: LD_INT 2100
89162: PPUSH
89163: CALL_OW 67
// ToLua ( hideTroll(); ) ;
89167: LD_STRING hideTroll();
89169: PPUSH
89170: CALL_OW 559
// end ;
89174: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
89175: LD_EXP 112
89179: PUSH
89180: LD_EXP 138
89184: AND
89185: IFFALSE 89248
89187: GO 89189
89189: DISABLE
89190: LD_INT 0
89192: PPUSH
// begin p := 0 ;
89193: LD_ADDR_VAR 0 1
89197: PUSH
89198: LD_INT 0
89200: ST_TO_ADDR
// repeat game_speed := 1 ;
89201: LD_ADDR_OWVAR 65
89205: PUSH
89206: LD_INT 1
89208: ST_TO_ADDR
// wait ( 0 0$1 ) ;
89209: LD_INT 35
89211: PPUSH
89212: CALL_OW 67
// p := p + 1 ;
89216: LD_ADDR_VAR 0 1
89220: PUSH
89221: LD_VAR 0 1
89225: PUSH
89226: LD_INT 1
89228: PLUS
89229: ST_TO_ADDR
// until p >= 60 ;
89230: LD_VAR 0 1
89234: PUSH
89235: LD_INT 60
89237: GREATEREQUAL
89238: IFFALSE 89201
// game_speed := 4 ;
89240: LD_ADDR_OWVAR 65
89244: PUSH
89245: LD_INT 4
89247: ST_TO_ADDR
// end ;
89248: PPOPN 1
89250: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
89251: LD_EXP 112
89255: PUSH
89256: LD_EXP 139
89260: AND
89261: IFFALSE 89407
89263: GO 89265
89265: DISABLE
89266: LD_INT 0
89268: PPUSH
89269: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
89270: LD_ADDR_VAR 0 1
89274: PUSH
89275: LD_INT 22
89277: PUSH
89278: LD_OWVAR 2
89282: PUSH
89283: EMPTY
89284: LIST
89285: LIST
89286: PUSH
89287: LD_INT 2
89289: PUSH
89290: LD_INT 30
89292: PUSH
89293: LD_INT 0
89295: PUSH
89296: EMPTY
89297: LIST
89298: LIST
89299: PUSH
89300: LD_INT 30
89302: PUSH
89303: LD_INT 1
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: PUSH
89310: EMPTY
89311: LIST
89312: LIST
89313: LIST
89314: PUSH
89315: EMPTY
89316: LIST
89317: LIST
89318: PPUSH
89319: CALL_OW 69
89323: ST_TO_ADDR
// if not depot then
89324: LD_VAR 0 1
89328: NOT
89329: IFFALSE 89333
// exit ;
89331: GO 89407
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
89333: LD_ADDR_VAR 0 2
89337: PUSH
89338: LD_VAR 0 1
89342: PUSH
89343: LD_INT 1
89345: PPUSH
89346: LD_VAR 0 1
89350: PPUSH
89351: CALL_OW 12
89355: ARRAY
89356: PPUSH
89357: CALL_OW 274
89361: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
89362: LD_VAR 0 2
89366: PPUSH
89367: LD_INT 1
89369: PPUSH
89370: LD_INT 0
89372: PPUSH
89373: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
89377: LD_VAR 0 2
89381: PPUSH
89382: LD_INT 2
89384: PPUSH
89385: LD_INT 0
89387: PPUSH
89388: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
89392: LD_VAR 0 2
89396: PPUSH
89397: LD_INT 3
89399: PPUSH
89400: LD_INT 0
89402: PPUSH
89403: CALL_OW 277
// end ;
89407: PPOPN 2
89409: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
89410: LD_EXP 112
89414: PUSH
89415: LD_EXP 140
89419: AND
89420: IFFALSE 89517
89422: GO 89424
89424: DISABLE
89425: LD_INT 0
89427: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
89428: LD_ADDR_VAR 0 1
89432: PUSH
89433: LD_INT 22
89435: PUSH
89436: LD_OWVAR 2
89440: PUSH
89441: EMPTY
89442: LIST
89443: LIST
89444: PUSH
89445: LD_INT 21
89447: PUSH
89448: LD_INT 1
89450: PUSH
89451: EMPTY
89452: LIST
89453: LIST
89454: PUSH
89455: LD_INT 3
89457: PUSH
89458: LD_INT 23
89460: PUSH
89461: LD_INT 0
89463: PUSH
89464: EMPTY
89465: LIST
89466: LIST
89467: PUSH
89468: EMPTY
89469: LIST
89470: LIST
89471: PUSH
89472: EMPTY
89473: LIST
89474: LIST
89475: LIST
89476: PPUSH
89477: CALL_OW 69
89481: ST_TO_ADDR
// if not tmp then
89482: LD_VAR 0 1
89486: NOT
89487: IFFALSE 89491
// exit ;
89489: GO 89517
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
89491: LD_VAR 0 1
89495: PUSH
89496: LD_INT 1
89498: PPUSH
89499: LD_VAR 0 1
89503: PPUSH
89504: CALL_OW 12
89508: ARRAY
89509: PPUSH
89510: LD_INT 200
89512: PPUSH
89513: CALL_OW 234
// end ;
89517: PPOPN 1
89519: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
89520: LD_EXP 112
89524: PUSH
89525: LD_EXP 141
89529: AND
89530: IFFALSE 89609
89532: GO 89534
89534: DISABLE
89535: LD_INT 0
89537: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
89538: LD_ADDR_VAR 0 1
89542: PUSH
89543: LD_INT 22
89545: PUSH
89546: LD_OWVAR 2
89550: PUSH
89551: EMPTY
89552: LIST
89553: LIST
89554: PUSH
89555: LD_INT 21
89557: PUSH
89558: LD_INT 2
89560: PUSH
89561: EMPTY
89562: LIST
89563: LIST
89564: PUSH
89565: EMPTY
89566: LIST
89567: LIST
89568: PPUSH
89569: CALL_OW 69
89573: ST_TO_ADDR
// if not tmp then
89574: LD_VAR 0 1
89578: NOT
89579: IFFALSE 89583
// exit ;
89581: GO 89609
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
89583: LD_VAR 0 1
89587: PUSH
89588: LD_INT 1
89590: PPUSH
89591: LD_VAR 0 1
89595: PPUSH
89596: CALL_OW 12
89600: ARRAY
89601: PPUSH
89602: LD_INT 60
89604: PPUSH
89605: CALL_OW 234
// end ;
89609: PPOPN 1
89611: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
89612: LD_EXP 112
89616: PUSH
89617: LD_EXP 142
89621: AND
89622: IFFALSE 89721
89624: GO 89626
89626: DISABLE
89627: LD_INT 0
89629: PPUSH
89630: PPUSH
// begin enable ;
89631: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
89632: LD_ADDR_VAR 0 1
89636: PUSH
89637: LD_INT 22
89639: PUSH
89640: LD_OWVAR 2
89644: PUSH
89645: EMPTY
89646: LIST
89647: LIST
89648: PUSH
89649: LD_INT 61
89651: PUSH
89652: EMPTY
89653: LIST
89654: PUSH
89655: LD_INT 33
89657: PUSH
89658: LD_INT 2
89660: PUSH
89661: EMPTY
89662: LIST
89663: LIST
89664: PUSH
89665: EMPTY
89666: LIST
89667: LIST
89668: LIST
89669: PPUSH
89670: CALL_OW 69
89674: ST_TO_ADDR
// if not tmp then
89675: LD_VAR 0 1
89679: NOT
89680: IFFALSE 89684
// exit ;
89682: GO 89721
// for i in tmp do
89684: LD_ADDR_VAR 0 2
89688: PUSH
89689: LD_VAR 0 1
89693: PUSH
89694: FOR_IN
89695: IFFALSE 89719
// if IsControledBy ( i ) then
89697: LD_VAR 0 2
89701: PPUSH
89702: CALL_OW 312
89706: IFFALSE 89717
// ComUnlink ( i ) ;
89708: LD_VAR 0 2
89712: PPUSH
89713: CALL_OW 136
89717: GO 89694
89719: POP
89720: POP
// end ;
89721: PPOPN 2
89723: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
89724: LD_EXP 112
89728: PUSH
89729: LD_EXP 143
89733: AND
89734: IFFALSE 89874
89736: GO 89738
89738: DISABLE
89739: LD_INT 0
89741: PPUSH
89742: PPUSH
// begin ToLua ( displayPowell(); ) ;
89743: LD_STRING displayPowell();
89745: PPUSH
89746: CALL_OW 559
// uc_side := 0 ;
89750: LD_ADDR_OWVAR 20
89754: PUSH
89755: LD_INT 0
89757: ST_TO_ADDR
// uc_nation := 2 ;
89758: LD_ADDR_OWVAR 21
89762: PUSH
89763: LD_INT 2
89765: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
89766: LD_ADDR_OWVAR 37
89770: PUSH
89771: LD_INT 14
89773: ST_TO_ADDR
// vc_engine := engine_siberite ;
89774: LD_ADDR_OWVAR 39
89778: PUSH
89779: LD_INT 3
89781: ST_TO_ADDR
// vc_control := control_apeman ;
89782: LD_ADDR_OWVAR 38
89786: PUSH
89787: LD_INT 5
89789: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
89790: LD_ADDR_OWVAR 40
89794: PUSH
89795: LD_INT 29
89797: ST_TO_ADDR
// un := CreateVehicle ;
89798: LD_ADDR_VAR 0 2
89802: PUSH
89803: CALL_OW 45
89807: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
89808: LD_VAR 0 2
89812: PPUSH
89813: LD_INT 1
89815: PPUSH
89816: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
89820: LD_INT 35
89822: PPUSH
89823: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
89827: LD_VAR 0 2
89831: PPUSH
89832: LD_INT 22
89834: PUSH
89835: LD_OWVAR 2
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: PPUSH
89844: CALL_OW 69
89848: PPUSH
89849: LD_VAR 0 2
89853: PPUSH
89854: CALL_OW 74
89858: PPUSH
89859: CALL_OW 115
// until IsDead ( un ) ;
89863: LD_VAR 0 2
89867: PPUSH
89868: CALL_OW 301
89872: IFFALSE 89820
// end ;
89874: PPOPN 2
89876: END
// every 0 0$1 trigger StreamModeActive and sStu do
89877: LD_EXP 112
89881: PUSH
89882: LD_EXP 151
89886: AND
89887: IFFALSE 89903
89889: GO 89891
89891: DISABLE
// begin ToLua ( displayStucuk(); ) ;
89892: LD_STRING displayStucuk();
89894: PPUSH
89895: CALL_OW 559
// ResetFog ;
89899: CALL_OW 335
// end ;
89903: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
89904: LD_EXP 112
89908: PUSH
89909: LD_EXP 144
89913: AND
89914: IFFALSE 90055
89916: GO 89918
89918: DISABLE
89919: LD_INT 0
89921: PPUSH
89922: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89923: LD_ADDR_VAR 0 2
89927: PUSH
89928: LD_INT 22
89930: PUSH
89931: LD_OWVAR 2
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: PUSH
89940: LD_INT 21
89942: PUSH
89943: LD_INT 1
89945: PUSH
89946: EMPTY
89947: LIST
89948: LIST
89949: PUSH
89950: EMPTY
89951: LIST
89952: LIST
89953: PPUSH
89954: CALL_OW 69
89958: ST_TO_ADDR
// if not tmp then
89959: LD_VAR 0 2
89963: NOT
89964: IFFALSE 89968
// exit ;
89966: GO 90055
// un := tmp [ rand ( 1 , tmp ) ] ;
89968: LD_ADDR_VAR 0 1
89972: PUSH
89973: LD_VAR 0 2
89977: PUSH
89978: LD_INT 1
89980: PPUSH
89981: LD_VAR 0 2
89985: PPUSH
89986: CALL_OW 12
89990: ARRAY
89991: ST_TO_ADDR
// SetSide ( un , 0 ) ;
89992: LD_VAR 0 1
89996: PPUSH
89997: LD_INT 0
89999: PPUSH
90000: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
90004: LD_VAR 0 1
90008: PPUSH
90009: LD_OWVAR 3
90013: PUSH
90014: LD_VAR 0 1
90018: DIFF
90019: PPUSH
90020: LD_VAR 0 1
90024: PPUSH
90025: CALL_OW 74
90029: PPUSH
90030: CALL_OW 115
// wait ( 0 0$20 ) ;
90034: LD_INT 700
90036: PPUSH
90037: CALL_OW 67
// SetSide ( un , your_side ) ;
90041: LD_VAR 0 1
90045: PPUSH
90046: LD_OWVAR 2
90050: PPUSH
90051: CALL_OW 235
// end ;
90055: PPOPN 2
90057: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
90058: LD_EXP 112
90062: PUSH
90063: LD_EXP 145
90067: AND
90068: IFFALSE 90174
90070: GO 90072
90072: DISABLE
90073: LD_INT 0
90075: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
90076: LD_ADDR_VAR 0 1
90080: PUSH
90081: LD_INT 22
90083: PUSH
90084: LD_OWVAR 2
90088: PUSH
90089: EMPTY
90090: LIST
90091: LIST
90092: PUSH
90093: LD_INT 2
90095: PUSH
90096: LD_INT 30
90098: PUSH
90099: LD_INT 0
90101: PUSH
90102: EMPTY
90103: LIST
90104: LIST
90105: PUSH
90106: LD_INT 30
90108: PUSH
90109: LD_INT 1
90111: PUSH
90112: EMPTY
90113: LIST
90114: LIST
90115: PUSH
90116: EMPTY
90117: LIST
90118: LIST
90119: LIST
90120: PUSH
90121: EMPTY
90122: LIST
90123: LIST
90124: PPUSH
90125: CALL_OW 69
90129: ST_TO_ADDR
// if not depot then
90130: LD_VAR 0 1
90134: NOT
90135: IFFALSE 90139
// exit ;
90137: GO 90174
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
90139: LD_VAR 0 1
90143: PUSH
90144: LD_INT 1
90146: ARRAY
90147: PPUSH
90148: CALL_OW 250
90152: PPUSH
90153: LD_VAR 0 1
90157: PUSH
90158: LD_INT 1
90160: ARRAY
90161: PPUSH
90162: CALL_OW 251
90166: PPUSH
90167: LD_INT 70
90169: PPUSH
90170: CALL_OW 495
// end ;
90174: PPOPN 1
90176: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
90177: LD_EXP 112
90181: PUSH
90182: LD_EXP 146
90186: AND
90187: IFFALSE 90398
90189: GO 90191
90191: DISABLE
90192: LD_INT 0
90194: PPUSH
90195: PPUSH
90196: PPUSH
90197: PPUSH
90198: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90199: LD_ADDR_VAR 0 5
90203: PUSH
90204: LD_INT 22
90206: PUSH
90207: LD_OWVAR 2
90211: PUSH
90212: EMPTY
90213: LIST
90214: LIST
90215: PUSH
90216: LD_INT 21
90218: PUSH
90219: LD_INT 1
90221: PUSH
90222: EMPTY
90223: LIST
90224: LIST
90225: PUSH
90226: EMPTY
90227: LIST
90228: LIST
90229: PPUSH
90230: CALL_OW 69
90234: ST_TO_ADDR
// if not tmp then
90235: LD_VAR 0 5
90239: NOT
90240: IFFALSE 90244
// exit ;
90242: GO 90398
// for i in tmp do
90244: LD_ADDR_VAR 0 1
90248: PUSH
90249: LD_VAR 0 5
90253: PUSH
90254: FOR_IN
90255: IFFALSE 90396
// begin d := rand ( 0 , 5 ) ;
90257: LD_ADDR_VAR 0 4
90261: PUSH
90262: LD_INT 0
90264: PPUSH
90265: LD_INT 5
90267: PPUSH
90268: CALL_OW 12
90272: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
90273: LD_ADDR_VAR 0 2
90277: PUSH
90278: LD_VAR 0 1
90282: PPUSH
90283: CALL_OW 250
90287: PPUSH
90288: LD_VAR 0 4
90292: PPUSH
90293: LD_INT 3
90295: PPUSH
90296: LD_INT 12
90298: PPUSH
90299: CALL_OW 12
90303: PPUSH
90304: CALL_OW 272
90308: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
90309: LD_ADDR_VAR 0 3
90313: PUSH
90314: LD_VAR 0 1
90318: PPUSH
90319: CALL_OW 251
90323: PPUSH
90324: LD_VAR 0 4
90328: PPUSH
90329: LD_INT 3
90331: PPUSH
90332: LD_INT 12
90334: PPUSH
90335: CALL_OW 12
90339: PPUSH
90340: CALL_OW 273
90344: ST_TO_ADDR
// if ValidHex ( x , y ) then
90345: LD_VAR 0 2
90349: PPUSH
90350: LD_VAR 0 3
90354: PPUSH
90355: CALL_OW 488
90359: IFFALSE 90394
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
90361: LD_VAR 0 1
90365: PPUSH
90366: LD_VAR 0 2
90370: PPUSH
90371: LD_VAR 0 3
90375: PPUSH
90376: LD_INT 3
90378: PPUSH
90379: LD_INT 6
90381: PPUSH
90382: CALL_OW 12
90386: PPUSH
90387: LD_INT 1
90389: PPUSH
90390: CALL_OW 483
// end ;
90394: GO 90254
90396: POP
90397: POP
// end ;
90398: PPOPN 5
90400: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
90401: LD_EXP 112
90405: PUSH
90406: LD_EXP 147
90410: AND
90411: IFFALSE 90505
90413: GO 90415
90415: DISABLE
90416: LD_INT 0
90418: PPUSH
90419: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
90420: LD_ADDR_VAR 0 2
90424: PUSH
90425: LD_INT 22
90427: PUSH
90428: LD_OWVAR 2
90432: PUSH
90433: EMPTY
90434: LIST
90435: LIST
90436: PUSH
90437: LD_INT 32
90439: PUSH
90440: LD_INT 1
90442: PUSH
90443: EMPTY
90444: LIST
90445: LIST
90446: PUSH
90447: LD_INT 21
90449: PUSH
90450: LD_INT 2
90452: PUSH
90453: EMPTY
90454: LIST
90455: LIST
90456: PUSH
90457: EMPTY
90458: LIST
90459: LIST
90460: LIST
90461: PPUSH
90462: CALL_OW 69
90466: ST_TO_ADDR
// if not tmp then
90467: LD_VAR 0 2
90471: NOT
90472: IFFALSE 90476
// exit ;
90474: GO 90505
// for i in tmp do
90476: LD_ADDR_VAR 0 1
90480: PUSH
90481: LD_VAR 0 2
90485: PUSH
90486: FOR_IN
90487: IFFALSE 90503
// SetFuel ( i , 0 ) ;
90489: LD_VAR 0 1
90493: PPUSH
90494: LD_INT 0
90496: PPUSH
90497: CALL_OW 240
90501: GO 90486
90503: POP
90504: POP
// end ;
90505: PPOPN 2
90507: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
90508: LD_EXP 112
90512: PUSH
90513: LD_EXP 148
90517: AND
90518: IFFALSE 90584
90520: GO 90522
90522: DISABLE
90523: LD_INT 0
90525: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
90526: LD_ADDR_VAR 0 1
90530: PUSH
90531: LD_INT 22
90533: PUSH
90534: LD_OWVAR 2
90538: PUSH
90539: EMPTY
90540: LIST
90541: LIST
90542: PUSH
90543: LD_INT 30
90545: PUSH
90546: LD_INT 29
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: PUSH
90553: EMPTY
90554: LIST
90555: LIST
90556: PPUSH
90557: CALL_OW 69
90561: ST_TO_ADDR
// if not tmp then
90562: LD_VAR 0 1
90566: NOT
90567: IFFALSE 90571
// exit ;
90569: GO 90584
// DestroyUnit ( tmp [ 1 ] ) ;
90571: LD_VAR 0 1
90575: PUSH
90576: LD_INT 1
90578: ARRAY
90579: PPUSH
90580: CALL_OW 65
// end ;
90584: PPOPN 1
90586: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
90587: LD_EXP 112
90591: PUSH
90592: LD_EXP 150
90596: AND
90597: IFFALSE 90726
90599: GO 90601
90601: DISABLE
90602: LD_INT 0
90604: PPUSH
// begin uc_side := 0 ;
90605: LD_ADDR_OWVAR 20
90609: PUSH
90610: LD_INT 0
90612: ST_TO_ADDR
// uc_nation := nation_arabian ;
90613: LD_ADDR_OWVAR 21
90617: PUSH
90618: LD_INT 2
90620: ST_TO_ADDR
// hc_gallery :=  ;
90621: LD_ADDR_OWVAR 33
90625: PUSH
90626: LD_STRING 
90628: ST_TO_ADDR
// hc_name :=  ;
90629: LD_ADDR_OWVAR 26
90633: PUSH
90634: LD_STRING 
90636: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
90637: LD_INT 1
90639: PPUSH
90640: LD_INT 11
90642: PPUSH
90643: LD_INT 10
90645: PPUSH
90646: CALL_OW 380
// un := CreateHuman ;
90650: LD_ADDR_VAR 0 1
90654: PUSH
90655: CALL_OW 44
90659: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
90660: LD_VAR 0 1
90664: PPUSH
90665: LD_INT 1
90667: PPUSH
90668: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
90672: LD_INT 35
90674: PPUSH
90675: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
90679: LD_VAR 0 1
90683: PPUSH
90684: LD_INT 22
90686: PUSH
90687: LD_OWVAR 2
90691: PUSH
90692: EMPTY
90693: LIST
90694: LIST
90695: PPUSH
90696: CALL_OW 69
90700: PPUSH
90701: LD_VAR 0 1
90705: PPUSH
90706: CALL_OW 74
90710: PPUSH
90711: CALL_OW 115
// until IsDead ( un ) ;
90715: LD_VAR 0 1
90719: PPUSH
90720: CALL_OW 301
90724: IFFALSE 90672
// end ;
90726: PPOPN 1
90728: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
90729: LD_EXP 112
90733: PUSH
90734: LD_EXP 152
90738: AND
90739: IFFALSE 90751
90741: GO 90743
90743: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
90744: LD_STRING earthquake(getX(game), 0, 32)
90746: PPUSH
90747: CALL_OW 559
90751: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
90752: LD_EXP 112
90756: PUSH
90757: LD_EXP 153
90761: AND
90762: IFFALSE 90853
90764: GO 90766
90766: DISABLE
90767: LD_INT 0
90769: PPUSH
// begin enable ;
90770: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
90771: LD_ADDR_VAR 0 1
90775: PUSH
90776: LD_INT 22
90778: PUSH
90779: LD_OWVAR 2
90783: PUSH
90784: EMPTY
90785: LIST
90786: LIST
90787: PUSH
90788: LD_INT 21
90790: PUSH
90791: LD_INT 2
90793: PUSH
90794: EMPTY
90795: LIST
90796: LIST
90797: PUSH
90798: LD_INT 33
90800: PUSH
90801: LD_INT 3
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: PUSH
90808: EMPTY
90809: LIST
90810: LIST
90811: LIST
90812: PPUSH
90813: CALL_OW 69
90817: ST_TO_ADDR
// if not tmp then
90818: LD_VAR 0 1
90822: NOT
90823: IFFALSE 90827
// exit ;
90825: GO 90853
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
90827: LD_VAR 0 1
90831: PUSH
90832: LD_INT 1
90834: PPUSH
90835: LD_VAR 0 1
90839: PPUSH
90840: CALL_OW 12
90844: ARRAY
90845: PPUSH
90846: LD_INT 1
90848: PPUSH
90849: CALL_OW 234
// end ;
90853: PPOPN 1
90855: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
90856: LD_EXP 112
90860: PUSH
90861: LD_EXP 154
90865: AND
90866: IFFALSE 91007
90868: GO 90870
90870: DISABLE
90871: LD_INT 0
90873: PPUSH
90874: PPUSH
90875: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90876: LD_ADDR_VAR 0 3
90880: PUSH
90881: LD_INT 22
90883: PUSH
90884: LD_OWVAR 2
90888: PUSH
90889: EMPTY
90890: LIST
90891: LIST
90892: PUSH
90893: LD_INT 25
90895: PUSH
90896: LD_INT 1
90898: PUSH
90899: EMPTY
90900: LIST
90901: LIST
90902: PUSH
90903: EMPTY
90904: LIST
90905: LIST
90906: PPUSH
90907: CALL_OW 69
90911: ST_TO_ADDR
// if not tmp then
90912: LD_VAR 0 3
90916: NOT
90917: IFFALSE 90921
// exit ;
90919: GO 91007
// un := tmp [ rand ( 1 , tmp ) ] ;
90921: LD_ADDR_VAR 0 2
90925: PUSH
90926: LD_VAR 0 3
90930: PUSH
90931: LD_INT 1
90933: PPUSH
90934: LD_VAR 0 3
90938: PPUSH
90939: CALL_OW 12
90943: ARRAY
90944: ST_TO_ADDR
// if Crawls ( un ) then
90945: LD_VAR 0 2
90949: PPUSH
90950: CALL_OW 318
90954: IFFALSE 90965
// ComWalk ( un ) ;
90956: LD_VAR 0 2
90960: PPUSH
90961: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
90965: LD_VAR 0 2
90969: PPUSH
90970: LD_INT 9
90972: PPUSH
90973: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
90977: LD_INT 28
90979: PPUSH
90980: LD_OWVAR 2
90984: PPUSH
90985: LD_INT 2
90987: PPUSH
90988: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
90992: LD_INT 29
90994: PPUSH
90995: LD_OWVAR 2
90999: PPUSH
91000: LD_INT 2
91002: PPUSH
91003: CALL_OW 322
// end ;
91007: PPOPN 3
91009: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
91010: LD_EXP 112
91014: PUSH
91015: LD_EXP 155
91019: AND
91020: IFFALSE 91131
91022: GO 91024
91024: DISABLE
91025: LD_INT 0
91027: PPUSH
91028: PPUSH
91029: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91030: LD_ADDR_VAR 0 3
91034: PUSH
91035: LD_INT 22
91037: PUSH
91038: LD_OWVAR 2
91042: PUSH
91043: EMPTY
91044: LIST
91045: LIST
91046: PUSH
91047: LD_INT 25
91049: PUSH
91050: LD_INT 1
91052: PUSH
91053: EMPTY
91054: LIST
91055: LIST
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: PPUSH
91061: CALL_OW 69
91065: ST_TO_ADDR
// if not tmp then
91066: LD_VAR 0 3
91070: NOT
91071: IFFALSE 91075
// exit ;
91073: GO 91131
// un := tmp [ rand ( 1 , tmp ) ] ;
91075: LD_ADDR_VAR 0 2
91079: PUSH
91080: LD_VAR 0 3
91084: PUSH
91085: LD_INT 1
91087: PPUSH
91088: LD_VAR 0 3
91092: PPUSH
91093: CALL_OW 12
91097: ARRAY
91098: ST_TO_ADDR
// if Crawls ( un ) then
91099: LD_VAR 0 2
91103: PPUSH
91104: CALL_OW 318
91108: IFFALSE 91119
// ComWalk ( un ) ;
91110: LD_VAR 0 2
91114: PPUSH
91115: CALL_OW 138
// SetClass ( un , class_mortar ) ;
91119: LD_VAR 0 2
91123: PPUSH
91124: LD_INT 8
91126: PPUSH
91127: CALL_OW 336
// end ;
91131: PPOPN 3
91133: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
91134: LD_EXP 112
91138: PUSH
91139: LD_EXP 156
91143: AND
91144: IFFALSE 91288
91146: GO 91148
91148: DISABLE
91149: LD_INT 0
91151: PPUSH
91152: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
91153: LD_ADDR_VAR 0 2
91157: PUSH
91158: LD_INT 22
91160: PUSH
91161: LD_OWVAR 2
91165: PUSH
91166: EMPTY
91167: LIST
91168: LIST
91169: PUSH
91170: LD_INT 21
91172: PUSH
91173: LD_INT 2
91175: PUSH
91176: EMPTY
91177: LIST
91178: LIST
91179: PUSH
91180: LD_INT 2
91182: PUSH
91183: LD_INT 34
91185: PUSH
91186: LD_INT 12
91188: PUSH
91189: EMPTY
91190: LIST
91191: LIST
91192: PUSH
91193: LD_INT 34
91195: PUSH
91196: LD_INT 51
91198: PUSH
91199: EMPTY
91200: LIST
91201: LIST
91202: PUSH
91203: LD_INT 34
91205: PUSH
91206: LD_INT 32
91208: PUSH
91209: EMPTY
91210: LIST
91211: LIST
91212: PUSH
91213: EMPTY
91214: LIST
91215: LIST
91216: LIST
91217: LIST
91218: PUSH
91219: EMPTY
91220: LIST
91221: LIST
91222: LIST
91223: PPUSH
91224: CALL_OW 69
91228: ST_TO_ADDR
// if not tmp then
91229: LD_VAR 0 2
91233: NOT
91234: IFFALSE 91238
// exit ;
91236: GO 91288
// for i in tmp do
91238: LD_ADDR_VAR 0 1
91242: PUSH
91243: LD_VAR 0 2
91247: PUSH
91248: FOR_IN
91249: IFFALSE 91286
// if GetCargo ( i , mat_artifact ) = 0 then
91251: LD_VAR 0 1
91255: PPUSH
91256: LD_INT 4
91258: PPUSH
91259: CALL_OW 289
91263: PUSH
91264: LD_INT 0
91266: EQUAL
91267: IFFALSE 91284
// SetCargo ( i , mat_siberit , 100 ) ;
91269: LD_VAR 0 1
91273: PPUSH
91274: LD_INT 3
91276: PPUSH
91277: LD_INT 100
91279: PPUSH
91280: CALL_OW 290
91284: GO 91248
91286: POP
91287: POP
// end ;
91288: PPOPN 2
91290: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
91291: LD_EXP 112
91295: PUSH
91296: LD_EXP 157
91300: AND
91301: IFFALSE 91484
91303: GO 91305
91305: DISABLE
91306: LD_INT 0
91308: PPUSH
91309: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
91310: LD_ADDR_VAR 0 2
91314: PUSH
91315: LD_INT 22
91317: PUSH
91318: LD_OWVAR 2
91322: PUSH
91323: EMPTY
91324: LIST
91325: LIST
91326: PPUSH
91327: CALL_OW 69
91331: ST_TO_ADDR
// if not tmp then
91332: LD_VAR 0 2
91336: NOT
91337: IFFALSE 91341
// exit ;
91339: GO 91484
// for i := 1 to 2 do
91341: LD_ADDR_VAR 0 1
91345: PUSH
91346: DOUBLE
91347: LD_INT 1
91349: DEC
91350: ST_TO_ADDR
91351: LD_INT 2
91353: PUSH
91354: FOR_TO
91355: IFFALSE 91482
// begin uc_side := your_side ;
91357: LD_ADDR_OWVAR 20
91361: PUSH
91362: LD_OWVAR 2
91366: ST_TO_ADDR
// uc_nation := nation_american ;
91367: LD_ADDR_OWVAR 21
91371: PUSH
91372: LD_INT 1
91374: ST_TO_ADDR
// vc_chassis := us_morphling ;
91375: LD_ADDR_OWVAR 37
91379: PUSH
91380: LD_INT 5
91382: ST_TO_ADDR
// vc_engine := engine_siberite ;
91383: LD_ADDR_OWVAR 39
91387: PUSH
91388: LD_INT 3
91390: ST_TO_ADDR
// vc_control := control_computer ;
91391: LD_ADDR_OWVAR 38
91395: PUSH
91396: LD_INT 3
91398: ST_TO_ADDR
// vc_weapon := us_double_laser ;
91399: LD_ADDR_OWVAR 40
91403: PUSH
91404: LD_INT 10
91406: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
91407: LD_VAR 0 2
91411: PUSH
91412: LD_INT 1
91414: ARRAY
91415: PPUSH
91416: CALL_OW 310
91420: NOT
91421: IFFALSE 91468
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
91423: CALL_OW 45
91427: PPUSH
91428: LD_VAR 0 2
91432: PUSH
91433: LD_INT 1
91435: ARRAY
91436: PPUSH
91437: CALL_OW 250
91441: PPUSH
91442: LD_VAR 0 2
91446: PUSH
91447: LD_INT 1
91449: ARRAY
91450: PPUSH
91451: CALL_OW 251
91455: PPUSH
91456: LD_INT 12
91458: PPUSH
91459: LD_INT 1
91461: PPUSH
91462: CALL_OW 50
91466: GO 91480
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
91468: CALL_OW 45
91472: PPUSH
91473: LD_INT 1
91475: PPUSH
91476: CALL_OW 51
// end ;
91480: GO 91354
91482: POP
91483: POP
// end ;
91484: PPOPN 2
91486: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
91487: LD_EXP 112
91491: PUSH
91492: LD_EXP 158
91496: AND
91497: IFFALSE 91719
91499: GO 91501
91501: DISABLE
91502: LD_INT 0
91504: PPUSH
91505: PPUSH
91506: PPUSH
91507: PPUSH
91508: PPUSH
91509: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91510: LD_ADDR_VAR 0 6
91514: PUSH
91515: LD_INT 22
91517: PUSH
91518: LD_OWVAR 2
91522: PUSH
91523: EMPTY
91524: LIST
91525: LIST
91526: PUSH
91527: LD_INT 21
91529: PUSH
91530: LD_INT 1
91532: PUSH
91533: EMPTY
91534: LIST
91535: LIST
91536: PUSH
91537: LD_INT 3
91539: PUSH
91540: LD_INT 23
91542: PUSH
91543: LD_INT 0
91545: PUSH
91546: EMPTY
91547: LIST
91548: LIST
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: PUSH
91554: EMPTY
91555: LIST
91556: LIST
91557: LIST
91558: PPUSH
91559: CALL_OW 69
91563: ST_TO_ADDR
// if not tmp then
91564: LD_VAR 0 6
91568: NOT
91569: IFFALSE 91573
// exit ;
91571: GO 91719
// s1 := rand ( 1 , 4 ) ;
91573: LD_ADDR_VAR 0 2
91577: PUSH
91578: LD_INT 1
91580: PPUSH
91581: LD_INT 4
91583: PPUSH
91584: CALL_OW 12
91588: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
91589: LD_ADDR_VAR 0 4
91593: PUSH
91594: LD_VAR 0 6
91598: PUSH
91599: LD_INT 1
91601: ARRAY
91602: PPUSH
91603: LD_VAR 0 2
91607: PPUSH
91608: CALL_OW 259
91612: ST_TO_ADDR
// if s1 = 1 then
91613: LD_VAR 0 2
91617: PUSH
91618: LD_INT 1
91620: EQUAL
91621: IFFALSE 91641
// s2 := rand ( 2 , 4 ) else
91623: LD_ADDR_VAR 0 3
91627: PUSH
91628: LD_INT 2
91630: PPUSH
91631: LD_INT 4
91633: PPUSH
91634: CALL_OW 12
91638: ST_TO_ADDR
91639: GO 91649
// s2 := 1 ;
91641: LD_ADDR_VAR 0 3
91645: PUSH
91646: LD_INT 1
91648: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
91649: LD_ADDR_VAR 0 5
91653: PUSH
91654: LD_VAR 0 6
91658: PUSH
91659: LD_INT 1
91661: ARRAY
91662: PPUSH
91663: LD_VAR 0 3
91667: PPUSH
91668: CALL_OW 259
91672: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
91673: LD_VAR 0 6
91677: PUSH
91678: LD_INT 1
91680: ARRAY
91681: PPUSH
91682: LD_VAR 0 2
91686: PPUSH
91687: LD_VAR 0 5
91691: PPUSH
91692: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
91696: LD_VAR 0 6
91700: PUSH
91701: LD_INT 1
91703: ARRAY
91704: PPUSH
91705: LD_VAR 0 3
91709: PPUSH
91710: LD_VAR 0 4
91714: PPUSH
91715: CALL_OW 237
// end ;
91719: PPOPN 6
91721: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
91722: LD_EXP 112
91726: PUSH
91727: LD_EXP 159
91731: AND
91732: IFFALSE 91811
91734: GO 91736
91736: DISABLE
91737: LD_INT 0
91739: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
91740: LD_ADDR_VAR 0 1
91744: PUSH
91745: LD_INT 22
91747: PUSH
91748: LD_OWVAR 2
91752: PUSH
91753: EMPTY
91754: LIST
91755: LIST
91756: PUSH
91757: LD_INT 30
91759: PUSH
91760: LD_INT 3
91762: PUSH
91763: EMPTY
91764: LIST
91765: LIST
91766: PUSH
91767: EMPTY
91768: LIST
91769: LIST
91770: PPUSH
91771: CALL_OW 69
91775: ST_TO_ADDR
// if not tmp then
91776: LD_VAR 0 1
91780: NOT
91781: IFFALSE 91785
// exit ;
91783: GO 91811
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
91785: LD_VAR 0 1
91789: PUSH
91790: LD_INT 1
91792: PPUSH
91793: LD_VAR 0 1
91797: PPUSH
91798: CALL_OW 12
91802: ARRAY
91803: PPUSH
91804: LD_INT 1
91806: PPUSH
91807: CALL_OW 234
// end ;
91811: PPOPN 1
91813: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
91814: LD_EXP 112
91818: PUSH
91819: LD_EXP 160
91823: AND
91824: IFFALSE 91936
91826: GO 91828
91828: DISABLE
91829: LD_INT 0
91831: PPUSH
91832: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
91833: LD_ADDR_VAR 0 2
91837: PUSH
91838: LD_INT 22
91840: PUSH
91841: LD_OWVAR 2
91845: PUSH
91846: EMPTY
91847: LIST
91848: LIST
91849: PUSH
91850: LD_INT 2
91852: PUSH
91853: LD_INT 30
91855: PUSH
91856: LD_INT 27
91858: PUSH
91859: EMPTY
91860: LIST
91861: LIST
91862: PUSH
91863: LD_INT 30
91865: PUSH
91866: LD_INT 26
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: PUSH
91873: LD_INT 30
91875: PUSH
91876: LD_INT 28
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: LIST
91887: LIST
91888: PUSH
91889: EMPTY
91890: LIST
91891: LIST
91892: PPUSH
91893: CALL_OW 69
91897: ST_TO_ADDR
// if not tmp then
91898: LD_VAR 0 2
91902: NOT
91903: IFFALSE 91907
// exit ;
91905: GO 91936
// for i in tmp do
91907: LD_ADDR_VAR 0 1
91911: PUSH
91912: LD_VAR 0 2
91916: PUSH
91917: FOR_IN
91918: IFFALSE 91934
// SetLives ( i , 1 ) ;
91920: LD_VAR 0 1
91924: PPUSH
91925: LD_INT 1
91927: PPUSH
91928: CALL_OW 234
91932: GO 91917
91934: POP
91935: POP
// end ;
91936: PPOPN 2
91938: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
91939: LD_EXP 112
91943: PUSH
91944: LD_EXP 161
91948: AND
91949: IFFALSE 92223
91951: GO 91953
91953: DISABLE
91954: LD_INT 0
91956: PPUSH
91957: PPUSH
91958: PPUSH
// begin i := rand ( 1 , 7 ) ;
91959: LD_ADDR_VAR 0 1
91963: PUSH
91964: LD_INT 1
91966: PPUSH
91967: LD_INT 7
91969: PPUSH
91970: CALL_OW 12
91974: ST_TO_ADDR
// case i of 1 :
91975: LD_VAR 0 1
91979: PUSH
91980: LD_INT 1
91982: DOUBLE
91983: EQUAL
91984: IFTRUE 91988
91986: GO 91998
91988: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
91989: LD_STRING earthquake(getX(game), 0, 32)
91991: PPUSH
91992: CALL_OW 559
91996: GO 92223
91998: LD_INT 2
92000: DOUBLE
92001: EQUAL
92002: IFTRUE 92006
92004: GO 92020
92006: POP
// begin ToLua ( displayStucuk(); ) ;
92007: LD_STRING displayStucuk();
92009: PPUSH
92010: CALL_OW 559
// ResetFog ;
92014: CALL_OW 335
// end ; 3 :
92018: GO 92223
92020: LD_INT 3
92022: DOUBLE
92023: EQUAL
92024: IFTRUE 92028
92026: GO 92132
92028: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92029: LD_ADDR_VAR 0 2
92033: PUSH
92034: LD_INT 22
92036: PUSH
92037: LD_OWVAR 2
92041: PUSH
92042: EMPTY
92043: LIST
92044: LIST
92045: PUSH
92046: LD_INT 25
92048: PUSH
92049: LD_INT 1
92051: PUSH
92052: EMPTY
92053: LIST
92054: LIST
92055: PUSH
92056: EMPTY
92057: LIST
92058: LIST
92059: PPUSH
92060: CALL_OW 69
92064: ST_TO_ADDR
// if not tmp then
92065: LD_VAR 0 2
92069: NOT
92070: IFFALSE 92074
// exit ;
92072: GO 92223
// un := tmp [ rand ( 1 , tmp ) ] ;
92074: LD_ADDR_VAR 0 3
92078: PUSH
92079: LD_VAR 0 2
92083: PUSH
92084: LD_INT 1
92086: PPUSH
92087: LD_VAR 0 2
92091: PPUSH
92092: CALL_OW 12
92096: ARRAY
92097: ST_TO_ADDR
// if Crawls ( un ) then
92098: LD_VAR 0 3
92102: PPUSH
92103: CALL_OW 318
92107: IFFALSE 92118
// ComWalk ( un ) ;
92109: LD_VAR 0 3
92113: PPUSH
92114: CALL_OW 138
// SetClass ( un , class_mortar ) ;
92118: LD_VAR 0 3
92122: PPUSH
92123: LD_INT 8
92125: PPUSH
92126: CALL_OW 336
// end ; 4 :
92130: GO 92223
92132: LD_INT 4
92134: DOUBLE
92135: EQUAL
92136: IFTRUE 92140
92138: GO 92201
92140: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
92141: LD_ADDR_VAR 0 2
92145: PUSH
92146: LD_INT 22
92148: PUSH
92149: LD_OWVAR 2
92153: PUSH
92154: EMPTY
92155: LIST
92156: LIST
92157: PUSH
92158: LD_INT 30
92160: PUSH
92161: LD_INT 29
92163: PUSH
92164: EMPTY
92165: LIST
92166: LIST
92167: PUSH
92168: EMPTY
92169: LIST
92170: LIST
92171: PPUSH
92172: CALL_OW 69
92176: ST_TO_ADDR
// if not tmp then
92177: LD_VAR 0 2
92181: NOT
92182: IFFALSE 92186
// exit ;
92184: GO 92223
// DestroyUnit ( tmp [ 1 ] ) ;
92186: LD_VAR 0 2
92190: PUSH
92191: LD_INT 1
92193: ARRAY
92194: PPUSH
92195: CALL_OW 65
// end ; 5 .. 7 :
92199: GO 92223
92201: LD_INT 5
92203: DOUBLE
92204: GREATEREQUAL
92205: IFFALSE 92213
92207: LD_INT 7
92209: DOUBLE
92210: LESSEQUAL
92211: IFTRUE 92215
92213: GO 92222
92215: POP
// StreamSibBomb ; end ;
92216: CALL 88473 0 0
92220: GO 92223
92222: POP
// end ;
92223: PPOPN 3
92225: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
92226: LD_EXP 112
92230: PUSH
92231: LD_EXP 162
92235: AND
92236: IFFALSE 92392
92238: GO 92240
92240: DISABLE
92241: LD_INT 0
92243: PPUSH
92244: PPUSH
92245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
92246: LD_ADDR_VAR 0 2
92250: PUSH
92251: LD_INT 81
92253: PUSH
92254: LD_OWVAR 2
92258: PUSH
92259: EMPTY
92260: LIST
92261: LIST
92262: PUSH
92263: LD_INT 2
92265: PUSH
92266: LD_INT 21
92268: PUSH
92269: LD_INT 1
92271: PUSH
92272: EMPTY
92273: LIST
92274: LIST
92275: PUSH
92276: LD_INT 21
92278: PUSH
92279: LD_INT 2
92281: PUSH
92282: EMPTY
92283: LIST
92284: LIST
92285: PUSH
92286: EMPTY
92287: LIST
92288: LIST
92289: LIST
92290: PUSH
92291: EMPTY
92292: LIST
92293: LIST
92294: PPUSH
92295: CALL_OW 69
92299: ST_TO_ADDR
// if not tmp then
92300: LD_VAR 0 2
92304: NOT
92305: IFFALSE 92309
// exit ;
92307: GO 92392
// p := 0 ;
92309: LD_ADDR_VAR 0 3
92313: PUSH
92314: LD_INT 0
92316: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
92317: LD_INT 35
92319: PPUSH
92320: CALL_OW 67
// p := p + 1 ;
92324: LD_ADDR_VAR 0 3
92328: PUSH
92329: LD_VAR 0 3
92333: PUSH
92334: LD_INT 1
92336: PLUS
92337: ST_TO_ADDR
// for i in tmp do
92338: LD_ADDR_VAR 0 1
92342: PUSH
92343: LD_VAR 0 2
92347: PUSH
92348: FOR_IN
92349: IFFALSE 92380
// if GetLives ( i ) < 1000 then
92351: LD_VAR 0 1
92355: PPUSH
92356: CALL_OW 256
92360: PUSH
92361: LD_INT 1000
92363: LESS
92364: IFFALSE 92378
// SetLives ( i , 1000 ) ;
92366: LD_VAR 0 1
92370: PPUSH
92371: LD_INT 1000
92373: PPUSH
92374: CALL_OW 234
92378: GO 92348
92380: POP
92381: POP
// until p > 20 ;
92382: LD_VAR 0 3
92386: PUSH
92387: LD_INT 20
92389: GREATER
92390: IFFALSE 92317
// end ;
92392: PPOPN 3
92394: END
// every 0 0$1 trigger StreamModeActive and sTime do
92395: LD_EXP 112
92399: PUSH
92400: LD_EXP 163
92404: AND
92405: IFFALSE 92440
92407: GO 92409
92409: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
92410: LD_INT 28
92412: PPUSH
92413: LD_OWVAR 2
92417: PPUSH
92418: LD_INT 2
92420: PPUSH
92421: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
92425: LD_INT 30
92427: PPUSH
92428: LD_OWVAR 2
92432: PPUSH
92433: LD_INT 2
92435: PPUSH
92436: CALL_OW 322
// end ;
92440: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
92441: LD_EXP 112
92445: PUSH
92446: LD_EXP 164
92450: AND
92451: IFFALSE 92572
92453: GO 92455
92455: DISABLE
92456: LD_INT 0
92458: PPUSH
92459: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92460: LD_ADDR_VAR 0 2
92464: PUSH
92465: LD_INT 22
92467: PUSH
92468: LD_OWVAR 2
92472: PUSH
92473: EMPTY
92474: LIST
92475: LIST
92476: PUSH
92477: LD_INT 21
92479: PUSH
92480: LD_INT 1
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: PUSH
92487: LD_INT 3
92489: PUSH
92490: LD_INT 23
92492: PUSH
92493: LD_INT 0
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: PUSH
92500: EMPTY
92501: LIST
92502: LIST
92503: PUSH
92504: EMPTY
92505: LIST
92506: LIST
92507: LIST
92508: PPUSH
92509: CALL_OW 69
92513: ST_TO_ADDR
// if not tmp then
92514: LD_VAR 0 2
92518: NOT
92519: IFFALSE 92523
// exit ;
92521: GO 92572
// for i in tmp do
92523: LD_ADDR_VAR 0 1
92527: PUSH
92528: LD_VAR 0 2
92532: PUSH
92533: FOR_IN
92534: IFFALSE 92570
// begin if Crawls ( i ) then
92536: LD_VAR 0 1
92540: PPUSH
92541: CALL_OW 318
92545: IFFALSE 92556
// ComWalk ( i ) ;
92547: LD_VAR 0 1
92551: PPUSH
92552: CALL_OW 138
// SetClass ( i , 2 ) ;
92556: LD_VAR 0 1
92560: PPUSH
92561: LD_INT 2
92563: PPUSH
92564: CALL_OW 336
// end ;
92568: GO 92533
92570: POP
92571: POP
// end ;
92572: PPOPN 2
92574: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
92575: LD_EXP 112
92579: PUSH
92580: LD_EXP 165
92584: AND
92585: IFFALSE 92866
92587: GO 92589
92589: DISABLE
92590: LD_INT 0
92592: PPUSH
92593: PPUSH
92594: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
92595: LD_OWVAR 2
92599: PPUSH
92600: LD_INT 9
92602: PPUSH
92603: LD_INT 1
92605: PPUSH
92606: LD_INT 1
92608: PPUSH
92609: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
92613: LD_INT 9
92615: PPUSH
92616: LD_OWVAR 2
92620: PPUSH
92621: CALL_OW 343
// uc_side := 9 ;
92625: LD_ADDR_OWVAR 20
92629: PUSH
92630: LD_INT 9
92632: ST_TO_ADDR
// uc_nation := 2 ;
92633: LD_ADDR_OWVAR 21
92637: PUSH
92638: LD_INT 2
92640: ST_TO_ADDR
// hc_name := Dark Warrior ;
92641: LD_ADDR_OWVAR 26
92645: PUSH
92646: LD_STRING Dark Warrior
92648: ST_TO_ADDR
// hc_gallery :=  ;
92649: LD_ADDR_OWVAR 33
92653: PUSH
92654: LD_STRING 
92656: ST_TO_ADDR
// hc_noskilllimit := true ;
92657: LD_ADDR_OWVAR 76
92661: PUSH
92662: LD_INT 1
92664: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
92665: LD_ADDR_OWVAR 31
92669: PUSH
92670: LD_INT 30
92672: PUSH
92673: LD_INT 30
92675: PUSH
92676: LD_INT 30
92678: PUSH
92679: LD_INT 30
92681: PUSH
92682: EMPTY
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: ST_TO_ADDR
// un := CreateHuman ;
92688: LD_ADDR_VAR 0 3
92692: PUSH
92693: CALL_OW 44
92697: ST_TO_ADDR
// hc_noskilllimit := false ;
92698: LD_ADDR_OWVAR 76
92702: PUSH
92703: LD_INT 0
92705: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92706: LD_VAR 0 3
92710: PPUSH
92711: LD_INT 1
92713: PPUSH
92714: CALL_OW 51
// p := 0 ;
92718: LD_ADDR_VAR 0 2
92722: PUSH
92723: LD_INT 0
92725: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
92726: LD_INT 35
92728: PPUSH
92729: CALL_OW 67
// p := p + 1 ;
92733: LD_ADDR_VAR 0 2
92737: PUSH
92738: LD_VAR 0 2
92742: PUSH
92743: LD_INT 1
92745: PLUS
92746: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
92747: LD_VAR 0 3
92751: PPUSH
92752: CALL_OW 256
92756: PUSH
92757: LD_INT 1000
92759: LESS
92760: IFFALSE 92774
// SetLives ( un , 1000 ) ;
92762: LD_VAR 0 3
92766: PPUSH
92767: LD_INT 1000
92769: PPUSH
92770: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
92774: LD_VAR 0 3
92778: PPUSH
92779: LD_INT 81
92781: PUSH
92782: LD_OWVAR 2
92786: PUSH
92787: EMPTY
92788: LIST
92789: LIST
92790: PUSH
92791: LD_INT 91
92793: PUSH
92794: LD_VAR 0 3
92798: PUSH
92799: LD_INT 30
92801: PUSH
92802: EMPTY
92803: LIST
92804: LIST
92805: LIST
92806: PUSH
92807: EMPTY
92808: LIST
92809: LIST
92810: PPUSH
92811: CALL_OW 69
92815: PPUSH
92816: LD_VAR 0 3
92820: PPUSH
92821: CALL_OW 74
92825: PPUSH
92826: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
92830: LD_VAR 0 2
92834: PUSH
92835: LD_INT 60
92837: GREATER
92838: PUSH
92839: LD_VAR 0 3
92843: PPUSH
92844: CALL_OW 301
92848: OR
92849: IFFALSE 92726
// if un then
92851: LD_VAR 0 3
92855: IFFALSE 92866
// RemoveUnit ( un ) ;
92857: LD_VAR 0 3
92861: PPUSH
92862: CALL_OW 64
// end ;
92866: PPOPN 3
92868: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92869: LD_INT 0
92871: PPUSH
// case cmd of 301 :
92872: LD_VAR 0 1
92876: PUSH
92877: LD_INT 301
92879: DOUBLE
92880: EQUAL
92881: IFTRUE 92885
92883: GO 92917
92885: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
92886: LD_VAR 0 6
92890: PPUSH
92891: LD_VAR 0 7
92895: PPUSH
92896: LD_VAR 0 8
92900: PPUSH
92901: LD_VAR 0 4
92905: PPUSH
92906: LD_VAR 0 5
92910: PPUSH
92911: CALL 94118 0 5
92915: GO 93038
92917: LD_INT 302
92919: DOUBLE
92920: EQUAL
92921: IFTRUE 92925
92923: GO 92962
92925: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
92926: LD_VAR 0 6
92930: PPUSH
92931: LD_VAR 0 7
92935: PPUSH
92936: LD_VAR 0 8
92940: PPUSH
92941: LD_VAR 0 9
92945: PPUSH
92946: LD_VAR 0 4
92950: PPUSH
92951: LD_VAR 0 5
92955: PPUSH
92956: CALL 94209 0 6
92960: GO 93038
92962: LD_INT 303
92964: DOUBLE
92965: EQUAL
92966: IFTRUE 92970
92968: GO 93007
92970: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
92971: LD_VAR 0 6
92975: PPUSH
92976: LD_VAR 0 7
92980: PPUSH
92981: LD_VAR 0 8
92985: PPUSH
92986: LD_VAR 0 9
92990: PPUSH
92991: LD_VAR 0 4
92995: PPUSH
92996: LD_VAR 0 5
93000: PPUSH
93001: CALL 93043 0 6
93005: GO 93038
93007: LD_INT 304
93009: DOUBLE
93010: EQUAL
93011: IFTRUE 93015
93013: GO 93037
93015: POP
// hHackTeleport ( unit , x , y ) ; end ;
93016: LD_VAR 0 2
93020: PPUSH
93021: LD_VAR 0 4
93025: PPUSH
93026: LD_VAR 0 5
93030: PPUSH
93031: CALL 94802 0 3
93035: GO 93038
93037: POP
// end ;
93038: LD_VAR 0 12
93042: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
93043: LD_INT 0
93045: PPUSH
93046: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
93047: LD_VAR 0 1
93051: PUSH
93052: LD_INT 1
93054: LESS
93055: PUSH
93056: LD_VAR 0 1
93060: PUSH
93061: LD_INT 3
93063: GREATER
93064: OR
93065: PUSH
93066: LD_VAR 0 5
93070: PPUSH
93071: LD_VAR 0 6
93075: PPUSH
93076: CALL_OW 428
93080: OR
93081: IFFALSE 93085
// exit ;
93083: GO 93805
// uc_side := your_side ;
93085: LD_ADDR_OWVAR 20
93089: PUSH
93090: LD_OWVAR 2
93094: ST_TO_ADDR
// uc_nation := nation ;
93095: LD_ADDR_OWVAR 21
93099: PUSH
93100: LD_VAR 0 1
93104: ST_TO_ADDR
// bc_level = 1 ;
93105: LD_ADDR_OWVAR 43
93109: PUSH
93110: LD_INT 1
93112: ST_TO_ADDR
// case btype of 1 :
93113: LD_VAR 0 2
93117: PUSH
93118: LD_INT 1
93120: DOUBLE
93121: EQUAL
93122: IFTRUE 93126
93124: GO 93137
93126: POP
// bc_type := b_depot ; 2 :
93127: LD_ADDR_OWVAR 42
93131: PUSH
93132: LD_INT 0
93134: ST_TO_ADDR
93135: GO 93749
93137: LD_INT 2
93139: DOUBLE
93140: EQUAL
93141: IFTRUE 93145
93143: GO 93156
93145: POP
// bc_type := b_warehouse ; 3 :
93146: LD_ADDR_OWVAR 42
93150: PUSH
93151: LD_INT 1
93153: ST_TO_ADDR
93154: GO 93749
93156: LD_INT 3
93158: DOUBLE
93159: EQUAL
93160: IFTRUE 93164
93162: GO 93175
93164: POP
// bc_type := b_lab ; 4 .. 9 :
93165: LD_ADDR_OWVAR 42
93169: PUSH
93170: LD_INT 6
93172: ST_TO_ADDR
93173: GO 93749
93175: LD_INT 4
93177: DOUBLE
93178: GREATEREQUAL
93179: IFFALSE 93187
93181: LD_INT 9
93183: DOUBLE
93184: LESSEQUAL
93185: IFTRUE 93189
93187: GO 93241
93189: POP
// begin bc_type := b_lab_half ;
93190: LD_ADDR_OWVAR 42
93194: PUSH
93195: LD_INT 7
93197: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
93198: LD_ADDR_OWVAR 44
93202: PUSH
93203: LD_INT 10
93205: PUSH
93206: LD_INT 11
93208: PUSH
93209: LD_INT 12
93211: PUSH
93212: LD_INT 15
93214: PUSH
93215: LD_INT 14
93217: PUSH
93218: LD_INT 13
93220: PUSH
93221: EMPTY
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: PUSH
93229: LD_VAR 0 2
93233: PUSH
93234: LD_INT 3
93236: MINUS
93237: ARRAY
93238: ST_TO_ADDR
// end ; 10 .. 13 :
93239: GO 93749
93241: LD_INT 10
93243: DOUBLE
93244: GREATEREQUAL
93245: IFFALSE 93253
93247: LD_INT 13
93249: DOUBLE
93250: LESSEQUAL
93251: IFTRUE 93255
93253: GO 93332
93255: POP
// begin bc_type := b_lab_full ;
93256: LD_ADDR_OWVAR 42
93260: PUSH
93261: LD_INT 8
93263: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
93264: LD_ADDR_OWVAR 44
93268: PUSH
93269: LD_INT 10
93271: PUSH
93272: LD_INT 12
93274: PUSH
93275: LD_INT 14
93277: PUSH
93278: LD_INT 13
93280: PUSH
93281: EMPTY
93282: LIST
93283: LIST
93284: LIST
93285: LIST
93286: PUSH
93287: LD_VAR 0 2
93291: PUSH
93292: LD_INT 9
93294: MINUS
93295: ARRAY
93296: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
93297: LD_ADDR_OWVAR 45
93301: PUSH
93302: LD_INT 11
93304: PUSH
93305: LD_INT 15
93307: PUSH
93308: LD_INT 12
93310: PUSH
93311: LD_INT 15
93313: PUSH
93314: EMPTY
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: PUSH
93320: LD_VAR 0 2
93324: PUSH
93325: LD_INT 9
93327: MINUS
93328: ARRAY
93329: ST_TO_ADDR
// end ; 14 :
93330: GO 93749
93332: LD_INT 14
93334: DOUBLE
93335: EQUAL
93336: IFTRUE 93340
93338: GO 93351
93340: POP
// bc_type := b_workshop ; 15 :
93341: LD_ADDR_OWVAR 42
93345: PUSH
93346: LD_INT 2
93348: ST_TO_ADDR
93349: GO 93749
93351: LD_INT 15
93353: DOUBLE
93354: EQUAL
93355: IFTRUE 93359
93357: GO 93370
93359: POP
// bc_type := b_factory ; 16 :
93360: LD_ADDR_OWVAR 42
93364: PUSH
93365: LD_INT 3
93367: ST_TO_ADDR
93368: GO 93749
93370: LD_INT 16
93372: DOUBLE
93373: EQUAL
93374: IFTRUE 93378
93376: GO 93389
93378: POP
// bc_type := b_ext_gun ; 17 :
93379: LD_ADDR_OWVAR 42
93383: PUSH
93384: LD_INT 17
93386: ST_TO_ADDR
93387: GO 93749
93389: LD_INT 17
93391: DOUBLE
93392: EQUAL
93393: IFTRUE 93397
93395: GO 93425
93397: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
93398: LD_ADDR_OWVAR 42
93402: PUSH
93403: LD_INT 19
93405: PUSH
93406: LD_INT 23
93408: PUSH
93409: LD_INT 19
93411: PUSH
93412: EMPTY
93413: LIST
93414: LIST
93415: LIST
93416: PUSH
93417: LD_VAR 0 1
93421: ARRAY
93422: ST_TO_ADDR
93423: GO 93749
93425: LD_INT 18
93427: DOUBLE
93428: EQUAL
93429: IFTRUE 93433
93431: GO 93444
93433: POP
// bc_type := b_ext_radar ; 19 :
93434: LD_ADDR_OWVAR 42
93438: PUSH
93439: LD_INT 20
93441: ST_TO_ADDR
93442: GO 93749
93444: LD_INT 19
93446: DOUBLE
93447: EQUAL
93448: IFTRUE 93452
93450: GO 93463
93452: POP
// bc_type := b_ext_radio ; 20 :
93453: LD_ADDR_OWVAR 42
93457: PUSH
93458: LD_INT 22
93460: ST_TO_ADDR
93461: GO 93749
93463: LD_INT 20
93465: DOUBLE
93466: EQUAL
93467: IFTRUE 93471
93469: GO 93482
93471: POP
// bc_type := b_ext_siberium ; 21 :
93472: LD_ADDR_OWVAR 42
93476: PUSH
93477: LD_INT 21
93479: ST_TO_ADDR
93480: GO 93749
93482: LD_INT 21
93484: DOUBLE
93485: EQUAL
93486: IFTRUE 93490
93488: GO 93501
93490: POP
// bc_type := b_ext_computer ; 22 :
93491: LD_ADDR_OWVAR 42
93495: PUSH
93496: LD_INT 24
93498: ST_TO_ADDR
93499: GO 93749
93501: LD_INT 22
93503: DOUBLE
93504: EQUAL
93505: IFTRUE 93509
93507: GO 93520
93509: POP
// bc_type := b_ext_track ; 23 :
93510: LD_ADDR_OWVAR 42
93514: PUSH
93515: LD_INT 16
93517: ST_TO_ADDR
93518: GO 93749
93520: LD_INT 23
93522: DOUBLE
93523: EQUAL
93524: IFTRUE 93528
93526: GO 93539
93528: POP
// bc_type := b_ext_laser ; 24 :
93529: LD_ADDR_OWVAR 42
93533: PUSH
93534: LD_INT 25
93536: ST_TO_ADDR
93537: GO 93749
93539: LD_INT 24
93541: DOUBLE
93542: EQUAL
93543: IFTRUE 93547
93545: GO 93558
93547: POP
// bc_type := b_control_tower ; 25 :
93548: LD_ADDR_OWVAR 42
93552: PUSH
93553: LD_INT 36
93555: ST_TO_ADDR
93556: GO 93749
93558: LD_INT 25
93560: DOUBLE
93561: EQUAL
93562: IFTRUE 93566
93564: GO 93577
93566: POP
// bc_type := b_breastwork ; 26 :
93567: LD_ADDR_OWVAR 42
93571: PUSH
93572: LD_INT 31
93574: ST_TO_ADDR
93575: GO 93749
93577: LD_INT 26
93579: DOUBLE
93580: EQUAL
93581: IFTRUE 93585
93583: GO 93596
93585: POP
// bc_type := b_bunker ; 27 :
93586: LD_ADDR_OWVAR 42
93590: PUSH
93591: LD_INT 32
93593: ST_TO_ADDR
93594: GO 93749
93596: LD_INT 27
93598: DOUBLE
93599: EQUAL
93600: IFTRUE 93604
93602: GO 93615
93604: POP
// bc_type := b_turret ; 28 :
93605: LD_ADDR_OWVAR 42
93609: PUSH
93610: LD_INT 33
93612: ST_TO_ADDR
93613: GO 93749
93615: LD_INT 28
93617: DOUBLE
93618: EQUAL
93619: IFTRUE 93623
93621: GO 93634
93623: POP
// bc_type := b_armoury ; 29 :
93624: LD_ADDR_OWVAR 42
93628: PUSH
93629: LD_INT 4
93631: ST_TO_ADDR
93632: GO 93749
93634: LD_INT 29
93636: DOUBLE
93637: EQUAL
93638: IFTRUE 93642
93640: GO 93653
93642: POP
// bc_type := b_barracks ; 30 :
93643: LD_ADDR_OWVAR 42
93647: PUSH
93648: LD_INT 5
93650: ST_TO_ADDR
93651: GO 93749
93653: LD_INT 30
93655: DOUBLE
93656: EQUAL
93657: IFTRUE 93661
93659: GO 93672
93661: POP
// bc_type := b_solar_power ; 31 :
93662: LD_ADDR_OWVAR 42
93666: PUSH
93667: LD_INT 27
93669: ST_TO_ADDR
93670: GO 93749
93672: LD_INT 31
93674: DOUBLE
93675: EQUAL
93676: IFTRUE 93680
93678: GO 93691
93680: POP
// bc_type := b_oil_power ; 32 :
93681: LD_ADDR_OWVAR 42
93685: PUSH
93686: LD_INT 26
93688: ST_TO_ADDR
93689: GO 93749
93691: LD_INT 32
93693: DOUBLE
93694: EQUAL
93695: IFTRUE 93699
93697: GO 93710
93699: POP
// bc_type := b_siberite_power ; 33 :
93700: LD_ADDR_OWVAR 42
93704: PUSH
93705: LD_INT 28
93707: ST_TO_ADDR
93708: GO 93749
93710: LD_INT 33
93712: DOUBLE
93713: EQUAL
93714: IFTRUE 93718
93716: GO 93729
93718: POP
// bc_type := b_oil_mine ; 34 :
93719: LD_ADDR_OWVAR 42
93723: PUSH
93724: LD_INT 29
93726: ST_TO_ADDR
93727: GO 93749
93729: LD_INT 34
93731: DOUBLE
93732: EQUAL
93733: IFTRUE 93737
93735: GO 93748
93737: POP
// bc_type := b_siberite_mine ; end ;
93738: LD_ADDR_OWVAR 42
93742: PUSH
93743: LD_INT 30
93745: ST_TO_ADDR
93746: GO 93749
93748: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
93749: LD_ADDR_VAR 0 8
93753: PUSH
93754: LD_VAR 0 5
93758: PPUSH
93759: LD_VAR 0 6
93763: PPUSH
93764: LD_VAR 0 3
93768: PPUSH
93769: CALL_OW 47
93773: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
93774: LD_OWVAR 42
93778: PUSH
93779: LD_INT 32
93781: PUSH
93782: LD_INT 33
93784: PUSH
93785: EMPTY
93786: LIST
93787: LIST
93788: IN
93789: IFFALSE 93805
// PlaceWeaponTurret ( b , weapon ) ;
93791: LD_VAR 0 8
93795: PPUSH
93796: LD_VAR 0 4
93800: PPUSH
93801: CALL_OW 431
// end ;
93805: LD_VAR 0 7
93809: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
93810: LD_INT 0
93812: PPUSH
93813: PPUSH
93814: PPUSH
93815: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93816: LD_ADDR_VAR 0 4
93820: PUSH
93821: LD_INT 22
93823: PUSH
93824: LD_OWVAR 2
93828: PUSH
93829: EMPTY
93830: LIST
93831: LIST
93832: PUSH
93833: LD_INT 2
93835: PUSH
93836: LD_INT 30
93838: PUSH
93839: LD_INT 0
93841: PUSH
93842: EMPTY
93843: LIST
93844: LIST
93845: PUSH
93846: LD_INT 30
93848: PUSH
93849: LD_INT 1
93851: PUSH
93852: EMPTY
93853: LIST
93854: LIST
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: LIST
93860: PUSH
93861: EMPTY
93862: LIST
93863: LIST
93864: PPUSH
93865: CALL_OW 69
93869: ST_TO_ADDR
// if not tmp then
93870: LD_VAR 0 4
93874: NOT
93875: IFFALSE 93879
// exit ;
93877: GO 93938
// for i in tmp do
93879: LD_ADDR_VAR 0 2
93883: PUSH
93884: LD_VAR 0 4
93888: PUSH
93889: FOR_IN
93890: IFFALSE 93936
// for j = 1 to 3 do
93892: LD_ADDR_VAR 0 3
93896: PUSH
93897: DOUBLE
93898: LD_INT 1
93900: DEC
93901: ST_TO_ADDR
93902: LD_INT 3
93904: PUSH
93905: FOR_TO
93906: IFFALSE 93932
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
93908: LD_VAR 0 2
93912: PPUSH
93913: CALL_OW 274
93917: PPUSH
93918: LD_VAR 0 3
93922: PPUSH
93923: LD_INT 99999
93925: PPUSH
93926: CALL_OW 277
93930: GO 93905
93932: POP
93933: POP
93934: GO 93889
93936: POP
93937: POP
// end ;
93938: LD_VAR 0 1
93942: RET
// export function hHackSetLevel10 ; var i , j ; begin
93943: LD_INT 0
93945: PPUSH
93946: PPUSH
93947: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
93948: LD_ADDR_VAR 0 2
93952: PUSH
93953: LD_INT 21
93955: PUSH
93956: LD_INT 1
93958: PUSH
93959: EMPTY
93960: LIST
93961: LIST
93962: PPUSH
93963: CALL_OW 69
93967: PUSH
93968: FOR_IN
93969: IFFALSE 94021
// if IsSelected ( i ) then
93971: LD_VAR 0 2
93975: PPUSH
93976: CALL_OW 306
93980: IFFALSE 94019
// begin for j := 1 to 4 do
93982: LD_ADDR_VAR 0 3
93986: PUSH
93987: DOUBLE
93988: LD_INT 1
93990: DEC
93991: ST_TO_ADDR
93992: LD_INT 4
93994: PUSH
93995: FOR_TO
93996: IFFALSE 94017
// SetSkill ( i , j , 10 ) ;
93998: LD_VAR 0 2
94002: PPUSH
94003: LD_VAR 0 3
94007: PPUSH
94008: LD_INT 10
94010: PPUSH
94011: CALL_OW 237
94015: GO 93995
94017: POP
94018: POP
// end ;
94019: GO 93968
94021: POP
94022: POP
// end ;
94023: LD_VAR 0 1
94027: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
94028: LD_INT 0
94030: PPUSH
94031: PPUSH
94032: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
94033: LD_ADDR_VAR 0 2
94037: PUSH
94038: LD_INT 22
94040: PUSH
94041: LD_OWVAR 2
94045: PUSH
94046: EMPTY
94047: LIST
94048: LIST
94049: PUSH
94050: LD_INT 21
94052: PUSH
94053: LD_INT 1
94055: PUSH
94056: EMPTY
94057: LIST
94058: LIST
94059: PUSH
94060: EMPTY
94061: LIST
94062: LIST
94063: PPUSH
94064: CALL_OW 69
94068: PUSH
94069: FOR_IN
94070: IFFALSE 94111
// begin for j := 1 to 4 do
94072: LD_ADDR_VAR 0 3
94076: PUSH
94077: DOUBLE
94078: LD_INT 1
94080: DEC
94081: ST_TO_ADDR
94082: LD_INT 4
94084: PUSH
94085: FOR_TO
94086: IFFALSE 94107
// SetSkill ( i , j , 10 ) ;
94088: LD_VAR 0 2
94092: PPUSH
94093: LD_VAR 0 3
94097: PPUSH
94098: LD_INT 10
94100: PPUSH
94101: CALL_OW 237
94105: GO 94085
94107: POP
94108: POP
// end ;
94109: GO 94069
94111: POP
94112: POP
// end ;
94113: LD_VAR 0 1
94117: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
94118: LD_INT 0
94120: PPUSH
// uc_side := your_side ;
94121: LD_ADDR_OWVAR 20
94125: PUSH
94126: LD_OWVAR 2
94130: ST_TO_ADDR
// uc_nation := nation ;
94131: LD_ADDR_OWVAR 21
94135: PUSH
94136: LD_VAR 0 1
94140: ST_TO_ADDR
// InitHc ;
94141: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
94145: LD_INT 0
94147: PPUSH
94148: LD_VAR 0 2
94152: PPUSH
94153: LD_VAR 0 3
94157: PPUSH
94158: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
94162: LD_VAR 0 4
94166: PPUSH
94167: LD_VAR 0 5
94171: PPUSH
94172: CALL_OW 428
94176: PUSH
94177: LD_INT 0
94179: EQUAL
94180: IFFALSE 94204
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
94182: CALL_OW 44
94186: PPUSH
94187: LD_VAR 0 4
94191: PPUSH
94192: LD_VAR 0 5
94196: PPUSH
94197: LD_INT 1
94199: PPUSH
94200: CALL_OW 48
// end ;
94204: LD_VAR 0 6
94208: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
94209: LD_INT 0
94211: PPUSH
94212: PPUSH
// uc_side := your_side ;
94213: LD_ADDR_OWVAR 20
94217: PUSH
94218: LD_OWVAR 2
94222: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
94223: LD_VAR 0 1
94227: PUSH
94228: LD_INT 1
94230: PUSH
94231: LD_INT 2
94233: PUSH
94234: LD_INT 3
94236: PUSH
94237: LD_INT 4
94239: PUSH
94240: LD_INT 5
94242: PUSH
94243: EMPTY
94244: LIST
94245: LIST
94246: LIST
94247: LIST
94248: LIST
94249: IN
94250: IFFALSE 94262
// uc_nation := nation_american else
94252: LD_ADDR_OWVAR 21
94256: PUSH
94257: LD_INT 1
94259: ST_TO_ADDR
94260: GO 94305
// if chassis in [ 11 , 12 , 13 , 14 ] then
94262: LD_VAR 0 1
94266: PUSH
94267: LD_INT 11
94269: PUSH
94270: LD_INT 12
94272: PUSH
94273: LD_INT 13
94275: PUSH
94276: LD_INT 14
94278: PUSH
94279: EMPTY
94280: LIST
94281: LIST
94282: LIST
94283: LIST
94284: IN
94285: IFFALSE 94297
// uc_nation := nation_arabian else
94287: LD_ADDR_OWVAR 21
94291: PUSH
94292: LD_INT 2
94294: ST_TO_ADDR
94295: GO 94305
// uc_nation := nation_russian ;
94297: LD_ADDR_OWVAR 21
94301: PUSH
94302: LD_INT 3
94304: ST_TO_ADDR
// vc_chassis := chassis ;
94305: LD_ADDR_OWVAR 37
94309: PUSH
94310: LD_VAR 0 1
94314: ST_TO_ADDR
// vc_engine := engine ;
94315: LD_ADDR_OWVAR 39
94319: PUSH
94320: LD_VAR 0 2
94324: ST_TO_ADDR
// vc_control := control ;
94325: LD_ADDR_OWVAR 38
94329: PUSH
94330: LD_VAR 0 3
94334: ST_TO_ADDR
// vc_weapon := weapon ;
94335: LD_ADDR_OWVAR 40
94339: PUSH
94340: LD_VAR 0 4
94344: ST_TO_ADDR
// un := CreateVehicle ;
94345: LD_ADDR_VAR 0 8
94349: PUSH
94350: CALL_OW 45
94354: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
94355: LD_VAR 0 8
94359: PPUSH
94360: LD_INT 0
94362: PPUSH
94363: LD_INT 5
94365: PPUSH
94366: CALL_OW 12
94370: PPUSH
94371: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
94375: LD_VAR 0 8
94379: PPUSH
94380: LD_VAR 0 5
94384: PPUSH
94385: LD_VAR 0 6
94389: PPUSH
94390: LD_INT 1
94392: PPUSH
94393: CALL_OW 48
// end ;
94397: LD_VAR 0 7
94401: RET
// export hInvincible ; every 1 do
94402: GO 94404
94404: DISABLE
// hInvincible := [ ] ;
94405: LD_ADDR_EXP 166
94409: PUSH
94410: EMPTY
94411: ST_TO_ADDR
94412: END
// every 10 do var i ;
94413: GO 94415
94415: DISABLE
94416: LD_INT 0
94418: PPUSH
// begin enable ;
94419: ENABLE
// if not hInvincible then
94420: LD_EXP 166
94424: NOT
94425: IFFALSE 94429
// exit ;
94427: GO 94473
// for i in hInvincible do
94429: LD_ADDR_VAR 0 1
94433: PUSH
94434: LD_EXP 166
94438: PUSH
94439: FOR_IN
94440: IFFALSE 94471
// if GetLives ( i ) < 1000 then
94442: LD_VAR 0 1
94446: PPUSH
94447: CALL_OW 256
94451: PUSH
94452: LD_INT 1000
94454: LESS
94455: IFFALSE 94469
// SetLives ( i , 1000 ) ;
94457: LD_VAR 0 1
94461: PPUSH
94462: LD_INT 1000
94464: PPUSH
94465: CALL_OW 234
94469: GO 94439
94471: POP
94472: POP
// end ;
94473: PPOPN 1
94475: END
// export function hHackInvincible ; var i ; begin
94476: LD_INT 0
94478: PPUSH
94479: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
94480: LD_ADDR_VAR 0 2
94484: PUSH
94485: LD_INT 2
94487: PUSH
94488: LD_INT 21
94490: PUSH
94491: LD_INT 1
94493: PUSH
94494: EMPTY
94495: LIST
94496: LIST
94497: PUSH
94498: LD_INT 21
94500: PUSH
94501: LD_INT 2
94503: PUSH
94504: EMPTY
94505: LIST
94506: LIST
94507: PUSH
94508: EMPTY
94509: LIST
94510: LIST
94511: LIST
94512: PPUSH
94513: CALL_OW 69
94517: PUSH
94518: FOR_IN
94519: IFFALSE 94580
// if IsSelected ( i ) then
94521: LD_VAR 0 2
94525: PPUSH
94526: CALL_OW 306
94530: IFFALSE 94578
// begin if i in hInvincible then
94532: LD_VAR 0 2
94536: PUSH
94537: LD_EXP 166
94541: IN
94542: IFFALSE 94562
// hInvincible := hInvincible diff i else
94544: LD_ADDR_EXP 166
94548: PUSH
94549: LD_EXP 166
94553: PUSH
94554: LD_VAR 0 2
94558: DIFF
94559: ST_TO_ADDR
94560: GO 94578
// hInvincible := hInvincible union i ;
94562: LD_ADDR_EXP 166
94566: PUSH
94567: LD_EXP 166
94571: PUSH
94572: LD_VAR 0 2
94576: UNION
94577: ST_TO_ADDR
// end ;
94578: GO 94518
94580: POP
94581: POP
// end ;
94582: LD_VAR 0 1
94586: RET
// export function hHackInvisible ; var i , j ; begin
94587: LD_INT 0
94589: PPUSH
94590: PPUSH
94591: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
94592: LD_ADDR_VAR 0 2
94596: PUSH
94597: LD_INT 21
94599: PUSH
94600: LD_INT 1
94602: PUSH
94603: EMPTY
94604: LIST
94605: LIST
94606: PPUSH
94607: CALL_OW 69
94611: PUSH
94612: FOR_IN
94613: IFFALSE 94637
// if IsSelected ( i ) then
94615: LD_VAR 0 2
94619: PPUSH
94620: CALL_OW 306
94624: IFFALSE 94635
// ComForceInvisible ( i ) ;
94626: LD_VAR 0 2
94630: PPUSH
94631: CALL_OW 496
94635: GO 94612
94637: POP
94638: POP
// end ;
94639: LD_VAR 0 1
94643: RET
// export function hHackChangeYourSide ; begin
94644: LD_INT 0
94646: PPUSH
// if your_side = 8 then
94647: LD_OWVAR 2
94651: PUSH
94652: LD_INT 8
94654: EQUAL
94655: IFFALSE 94667
// your_side := 0 else
94657: LD_ADDR_OWVAR 2
94661: PUSH
94662: LD_INT 0
94664: ST_TO_ADDR
94665: GO 94681
// your_side := your_side + 1 ;
94667: LD_ADDR_OWVAR 2
94671: PUSH
94672: LD_OWVAR 2
94676: PUSH
94677: LD_INT 1
94679: PLUS
94680: ST_TO_ADDR
// end ;
94681: LD_VAR 0 1
94685: RET
// export function hHackChangeUnitSide ; var i , j ; begin
94686: LD_INT 0
94688: PPUSH
94689: PPUSH
94690: PPUSH
// for i in all_units do
94691: LD_ADDR_VAR 0 2
94695: PUSH
94696: LD_OWVAR 3
94700: PUSH
94701: FOR_IN
94702: IFFALSE 94780
// if IsSelected ( i ) then
94704: LD_VAR 0 2
94708: PPUSH
94709: CALL_OW 306
94713: IFFALSE 94778
// begin j := GetSide ( i ) ;
94715: LD_ADDR_VAR 0 3
94719: PUSH
94720: LD_VAR 0 2
94724: PPUSH
94725: CALL_OW 255
94729: ST_TO_ADDR
// if j = 8 then
94730: LD_VAR 0 3
94734: PUSH
94735: LD_INT 8
94737: EQUAL
94738: IFFALSE 94750
// j := 0 else
94740: LD_ADDR_VAR 0 3
94744: PUSH
94745: LD_INT 0
94747: ST_TO_ADDR
94748: GO 94764
// j := j + 1 ;
94750: LD_ADDR_VAR 0 3
94754: PUSH
94755: LD_VAR 0 3
94759: PUSH
94760: LD_INT 1
94762: PLUS
94763: ST_TO_ADDR
// SetSide ( i , j ) ;
94764: LD_VAR 0 2
94768: PPUSH
94769: LD_VAR 0 3
94773: PPUSH
94774: CALL_OW 235
// end ;
94778: GO 94701
94780: POP
94781: POP
// end ;
94782: LD_VAR 0 1
94786: RET
// export function hHackFog ; begin
94787: LD_INT 0
94789: PPUSH
// FogOff ( true ) ;
94790: LD_INT 1
94792: PPUSH
94793: CALL_OW 344
// end ;
94797: LD_VAR 0 1
94801: RET
// export function hHackTeleport ( unit , x , y ) ; begin
94802: LD_INT 0
94804: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
94805: LD_VAR 0 1
94809: PPUSH
94810: LD_VAR 0 2
94814: PPUSH
94815: LD_VAR 0 3
94819: PPUSH
94820: LD_INT 1
94822: PPUSH
94823: LD_INT 1
94825: PPUSH
94826: CALL_OW 483
// CenterOnXY ( x , y ) ;
94830: LD_VAR 0 2
94834: PPUSH
94835: LD_VAR 0 3
94839: PPUSH
94840: CALL_OW 84
// end ; end_of_file
94844: LD_VAR 0 4
94848: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
94849: LD_INT 0
94851: PPUSH
94852: PPUSH
94853: PPUSH
94854: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
94855: LD_VAR 0 1
94859: PPUSH
94860: CALL_OW 264
94864: PUSH
94865: LD_EXP 52
94869: EQUAL
94870: IFFALSE 94942
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
94872: LD_INT 68
94874: PPUSH
94875: LD_VAR 0 1
94879: PPUSH
94880: CALL_OW 255
94884: PPUSH
94885: CALL_OW 321
94889: PUSH
94890: LD_INT 2
94892: EQUAL
94893: IFFALSE 94905
// eff := 70 else
94895: LD_ADDR_VAR 0 4
94899: PUSH
94900: LD_INT 70
94902: ST_TO_ADDR
94903: GO 94913
// eff := 30 ;
94905: LD_ADDR_VAR 0 4
94909: PUSH
94910: LD_INT 30
94912: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
94913: LD_VAR 0 1
94917: PPUSH
94918: CALL_OW 250
94922: PPUSH
94923: LD_VAR 0 1
94927: PPUSH
94928: CALL_OW 251
94932: PPUSH
94933: LD_VAR 0 4
94937: PPUSH
94938: CALL_OW 495
// end ; end ;
94942: LD_VAR 0 2
94946: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
94947: LD_INT 0
94949: PPUSH
// end ;
94950: LD_VAR 0 4
94954: RET
// export function SOS_Command ( cmd ) ; begin
94955: LD_INT 0
94957: PPUSH
// end ;
94958: LD_VAR 0 2
94962: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
94963: LD_INT 0
94965: PPUSH
// if cmd = 121 then
94966: LD_VAR 0 1
94970: PUSH
94971: LD_INT 121
94973: EQUAL
94974: IFFALSE 94976
// end ;
94976: LD_VAR 0 6
94980: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
94981: LD_INT 0
94983: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
94984: LD_VAR 0 1
94988: PUSH
94989: LD_INT 250
94991: EQUAL
94992: PUSH
94993: LD_VAR 0 2
94997: PPUSH
94998: CALL_OW 264
95002: PUSH
95003: LD_EXP 55
95007: EQUAL
95008: AND
95009: IFFALSE 95030
// MinerPlaceMine ( unit , x , y ) ;
95011: LD_VAR 0 2
95015: PPUSH
95016: LD_VAR 0 4
95020: PPUSH
95021: LD_VAR 0 5
95025: PPUSH
95026: CALL 97379 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
95030: LD_VAR 0 1
95034: PUSH
95035: LD_INT 251
95037: EQUAL
95038: PUSH
95039: LD_VAR 0 2
95043: PPUSH
95044: CALL_OW 264
95048: PUSH
95049: LD_EXP 55
95053: EQUAL
95054: AND
95055: IFFALSE 95076
// MinerDetonateMine ( unit , x , y ) ;
95057: LD_VAR 0 2
95061: PPUSH
95062: LD_VAR 0 4
95066: PPUSH
95067: LD_VAR 0 5
95071: PPUSH
95072: CALL 97656 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
95076: LD_VAR 0 1
95080: PUSH
95081: LD_INT 252
95083: EQUAL
95084: PUSH
95085: LD_VAR 0 2
95089: PPUSH
95090: CALL_OW 264
95094: PUSH
95095: LD_EXP 55
95099: EQUAL
95100: AND
95101: IFFALSE 95122
// MinerCreateMinefield ( unit , x , y ) ;
95103: LD_VAR 0 2
95107: PPUSH
95108: LD_VAR 0 4
95112: PPUSH
95113: LD_VAR 0 5
95117: PPUSH
95118: CALL 98073 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
95122: LD_VAR 0 1
95126: PUSH
95127: LD_INT 253
95129: EQUAL
95130: PUSH
95131: LD_VAR 0 2
95135: PPUSH
95136: CALL_OW 257
95140: PUSH
95141: LD_INT 5
95143: EQUAL
95144: AND
95145: IFFALSE 95166
// ComBinocular ( unit , x , y ) ;
95147: LD_VAR 0 2
95151: PPUSH
95152: LD_VAR 0 4
95156: PPUSH
95157: LD_VAR 0 5
95161: PPUSH
95162: CALL 98444 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
95166: LD_VAR 0 1
95170: PUSH
95171: LD_INT 254
95173: EQUAL
95174: PUSH
95175: LD_VAR 0 2
95179: PPUSH
95180: CALL_OW 264
95184: PUSH
95185: LD_EXP 50
95189: EQUAL
95190: AND
95191: PUSH
95192: LD_VAR 0 3
95196: PPUSH
95197: CALL_OW 263
95201: PUSH
95202: LD_INT 3
95204: EQUAL
95205: AND
95206: IFFALSE 95222
// HackDestroyVehicle ( unit , selectedUnit ) ;
95208: LD_VAR 0 2
95212: PPUSH
95213: LD_VAR 0 3
95217: PPUSH
95218: CALL 96739 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
95222: LD_VAR 0 1
95226: PUSH
95227: LD_INT 255
95229: EQUAL
95230: PUSH
95231: LD_VAR 0 2
95235: PPUSH
95236: CALL_OW 264
95240: PUSH
95241: LD_INT 14
95243: PUSH
95244: LD_INT 53
95246: PUSH
95247: EMPTY
95248: LIST
95249: LIST
95250: IN
95251: AND
95252: PUSH
95253: LD_VAR 0 4
95257: PPUSH
95258: LD_VAR 0 5
95262: PPUSH
95263: CALL_OW 488
95267: AND
95268: IFFALSE 95292
// CutTreeXYR ( unit , x , y , 12 ) ;
95270: LD_VAR 0 2
95274: PPUSH
95275: LD_VAR 0 4
95279: PPUSH
95280: LD_VAR 0 5
95284: PPUSH
95285: LD_INT 12
95287: PPUSH
95288: CALL 95305 0 4
// end ;
95292: LD_VAR 0 6
95296: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
95297: LD_INT 0
95299: PPUSH
// end ;
95300: LD_VAR 0 4
95304: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
95305: LD_INT 0
95307: PPUSH
95308: PPUSH
95309: PPUSH
95310: PPUSH
95311: PPUSH
95312: PPUSH
95313: PPUSH
95314: PPUSH
95315: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
95316: LD_VAR 0 1
95320: NOT
95321: PUSH
95322: LD_VAR 0 2
95326: PPUSH
95327: LD_VAR 0 3
95331: PPUSH
95332: CALL_OW 488
95336: NOT
95337: OR
95338: PUSH
95339: LD_VAR 0 4
95343: NOT
95344: OR
95345: IFFALSE 95349
// exit ;
95347: GO 95689
// list := [ ] ;
95349: LD_ADDR_VAR 0 13
95353: PUSH
95354: EMPTY
95355: ST_TO_ADDR
// if x - r < 0 then
95356: LD_VAR 0 2
95360: PUSH
95361: LD_VAR 0 4
95365: MINUS
95366: PUSH
95367: LD_INT 0
95369: LESS
95370: IFFALSE 95382
// min_x := 0 else
95372: LD_ADDR_VAR 0 7
95376: PUSH
95377: LD_INT 0
95379: ST_TO_ADDR
95380: GO 95398
// min_x := x - r ;
95382: LD_ADDR_VAR 0 7
95386: PUSH
95387: LD_VAR 0 2
95391: PUSH
95392: LD_VAR 0 4
95396: MINUS
95397: ST_TO_ADDR
// if y - r < 0 then
95398: LD_VAR 0 3
95402: PUSH
95403: LD_VAR 0 4
95407: MINUS
95408: PUSH
95409: LD_INT 0
95411: LESS
95412: IFFALSE 95424
// min_y := 0 else
95414: LD_ADDR_VAR 0 8
95418: PUSH
95419: LD_INT 0
95421: ST_TO_ADDR
95422: GO 95440
// min_y := y - r ;
95424: LD_ADDR_VAR 0 8
95428: PUSH
95429: LD_VAR 0 3
95433: PUSH
95434: LD_VAR 0 4
95438: MINUS
95439: ST_TO_ADDR
// max_x := x + r ;
95440: LD_ADDR_VAR 0 9
95444: PUSH
95445: LD_VAR 0 2
95449: PUSH
95450: LD_VAR 0 4
95454: PLUS
95455: ST_TO_ADDR
// max_y := y + r ;
95456: LD_ADDR_VAR 0 10
95460: PUSH
95461: LD_VAR 0 3
95465: PUSH
95466: LD_VAR 0 4
95470: PLUS
95471: ST_TO_ADDR
// for _x = min_x to max_x do
95472: LD_ADDR_VAR 0 11
95476: PUSH
95477: DOUBLE
95478: LD_VAR 0 7
95482: DEC
95483: ST_TO_ADDR
95484: LD_VAR 0 9
95488: PUSH
95489: FOR_TO
95490: IFFALSE 95607
// for _y = min_y to max_y do
95492: LD_ADDR_VAR 0 12
95496: PUSH
95497: DOUBLE
95498: LD_VAR 0 8
95502: DEC
95503: ST_TO_ADDR
95504: LD_VAR 0 10
95508: PUSH
95509: FOR_TO
95510: IFFALSE 95603
// begin if not ValidHex ( _x , _y ) then
95512: LD_VAR 0 11
95516: PPUSH
95517: LD_VAR 0 12
95521: PPUSH
95522: CALL_OW 488
95526: NOT
95527: IFFALSE 95531
// continue ;
95529: GO 95509
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
95531: LD_VAR 0 11
95535: PPUSH
95536: LD_VAR 0 12
95540: PPUSH
95541: CALL_OW 351
95545: PUSH
95546: LD_VAR 0 11
95550: PPUSH
95551: LD_VAR 0 12
95555: PPUSH
95556: CALL_OW 554
95560: AND
95561: IFFALSE 95601
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
95563: LD_ADDR_VAR 0 13
95567: PUSH
95568: LD_VAR 0 13
95572: PPUSH
95573: LD_VAR 0 13
95577: PUSH
95578: LD_INT 1
95580: PLUS
95581: PPUSH
95582: LD_VAR 0 11
95586: PUSH
95587: LD_VAR 0 12
95591: PUSH
95592: EMPTY
95593: LIST
95594: LIST
95595: PPUSH
95596: CALL_OW 2
95600: ST_TO_ADDR
// end ;
95601: GO 95509
95603: POP
95604: POP
95605: GO 95489
95607: POP
95608: POP
// if not list then
95609: LD_VAR 0 13
95613: NOT
95614: IFFALSE 95618
// exit ;
95616: GO 95689
// for i in list do
95618: LD_ADDR_VAR 0 6
95622: PUSH
95623: LD_VAR 0 13
95627: PUSH
95628: FOR_IN
95629: IFFALSE 95687
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
95631: LD_VAR 0 1
95635: PPUSH
95636: LD_STRING M
95638: PUSH
95639: LD_VAR 0 6
95643: PUSH
95644: LD_INT 1
95646: ARRAY
95647: PUSH
95648: LD_VAR 0 6
95652: PUSH
95653: LD_INT 2
95655: ARRAY
95656: PUSH
95657: LD_INT 0
95659: PUSH
95660: LD_INT 0
95662: PUSH
95663: LD_INT 0
95665: PUSH
95666: LD_INT 0
95668: PUSH
95669: EMPTY
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: LIST
95677: PUSH
95678: EMPTY
95679: LIST
95680: PPUSH
95681: CALL_OW 447
95685: GO 95628
95687: POP
95688: POP
// end ;
95689: LD_VAR 0 5
95693: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
95694: LD_EXP 169
95698: NOT
95699: IFFALSE 95749
95701: GO 95703
95703: DISABLE
// begin initHack := true ;
95704: LD_ADDR_EXP 169
95708: PUSH
95709: LD_INT 1
95711: ST_TO_ADDR
// hackTanks := [ ] ;
95712: LD_ADDR_EXP 170
95716: PUSH
95717: EMPTY
95718: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
95719: LD_ADDR_EXP 171
95723: PUSH
95724: EMPTY
95725: ST_TO_ADDR
// hackLimit := 3 ;
95726: LD_ADDR_EXP 172
95730: PUSH
95731: LD_INT 3
95733: ST_TO_ADDR
// hackDist := 12 ;
95734: LD_ADDR_EXP 173
95738: PUSH
95739: LD_INT 12
95741: ST_TO_ADDR
// hackCounter := [ ] ;
95742: LD_ADDR_EXP 174
95746: PUSH
95747: EMPTY
95748: ST_TO_ADDR
// end ;
95749: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
95750: LD_EXP 169
95754: PUSH
95755: LD_INT 34
95757: PUSH
95758: LD_EXP 50
95762: PUSH
95763: EMPTY
95764: LIST
95765: LIST
95766: PPUSH
95767: CALL_OW 69
95771: AND
95772: IFFALSE 96027
95774: GO 95776
95776: DISABLE
95777: LD_INT 0
95779: PPUSH
95780: PPUSH
// begin enable ;
95781: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
95782: LD_ADDR_VAR 0 1
95786: PUSH
95787: LD_INT 34
95789: PUSH
95790: LD_EXP 50
95794: PUSH
95795: EMPTY
95796: LIST
95797: LIST
95798: PPUSH
95799: CALL_OW 69
95803: PUSH
95804: FOR_IN
95805: IFFALSE 96025
// begin if not i in hackTanks then
95807: LD_VAR 0 1
95811: PUSH
95812: LD_EXP 170
95816: IN
95817: NOT
95818: IFFALSE 95901
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
95820: LD_ADDR_EXP 170
95824: PUSH
95825: LD_EXP 170
95829: PPUSH
95830: LD_EXP 170
95834: PUSH
95835: LD_INT 1
95837: PLUS
95838: PPUSH
95839: LD_VAR 0 1
95843: PPUSH
95844: CALL_OW 1
95848: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
95849: LD_ADDR_EXP 171
95853: PUSH
95854: LD_EXP 171
95858: PPUSH
95859: LD_EXP 171
95863: PUSH
95864: LD_INT 1
95866: PLUS
95867: PPUSH
95868: EMPTY
95869: PPUSH
95870: CALL_OW 1
95874: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
95875: LD_ADDR_EXP 174
95879: PUSH
95880: LD_EXP 174
95884: PPUSH
95885: LD_EXP 174
95889: PUSH
95890: LD_INT 1
95892: PLUS
95893: PPUSH
95894: EMPTY
95895: PPUSH
95896: CALL_OW 1
95900: ST_TO_ADDR
// end ; if not IsOk ( i ) then
95901: LD_VAR 0 1
95905: PPUSH
95906: CALL_OW 302
95910: NOT
95911: IFFALSE 95924
// begin HackUnlinkAll ( i ) ;
95913: LD_VAR 0 1
95917: PPUSH
95918: CALL 96030 0 1
// continue ;
95922: GO 95804
// end ; HackCheckCapturedStatus ( i ) ;
95924: LD_VAR 0 1
95928: PPUSH
95929: CALL 96473 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
95933: LD_ADDR_VAR 0 2
95937: PUSH
95938: LD_INT 81
95940: PUSH
95941: LD_VAR 0 1
95945: PPUSH
95946: CALL_OW 255
95950: PUSH
95951: EMPTY
95952: LIST
95953: LIST
95954: PUSH
95955: LD_INT 33
95957: PUSH
95958: LD_INT 3
95960: PUSH
95961: EMPTY
95962: LIST
95963: LIST
95964: PUSH
95965: LD_INT 91
95967: PUSH
95968: LD_VAR 0 1
95972: PUSH
95973: LD_EXP 173
95977: PUSH
95978: EMPTY
95979: LIST
95980: LIST
95981: LIST
95982: PUSH
95983: LD_INT 50
95985: PUSH
95986: EMPTY
95987: LIST
95988: PUSH
95989: EMPTY
95990: LIST
95991: LIST
95992: LIST
95993: LIST
95994: PPUSH
95995: CALL_OW 69
95999: ST_TO_ADDR
// if not tmp then
96000: LD_VAR 0 2
96004: NOT
96005: IFFALSE 96009
// continue ;
96007: GO 95804
// HackLink ( i , tmp ) ;
96009: LD_VAR 0 1
96013: PPUSH
96014: LD_VAR 0 2
96018: PPUSH
96019: CALL 96166 0 2
// end ;
96023: GO 95804
96025: POP
96026: POP
// end ;
96027: PPOPN 2
96029: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
96030: LD_INT 0
96032: PPUSH
96033: PPUSH
96034: PPUSH
// if not hack in hackTanks then
96035: LD_VAR 0 1
96039: PUSH
96040: LD_EXP 170
96044: IN
96045: NOT
96046: IFFALSE 96050
// exit ;
96048: GO 96161
// index := GetElementIndex ( hackTanks , hack ) ;
96050: LD_ADDR_VAR 0 4
96054: PUSH
96055: LD_EXP 170
96059: PPUSH
96060: LD_VAR 0 1
96064: PPUSH
96065: CALL 18333 0 2
96069: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
96070: LD_EXP 171
96074: PUSH
96075: LD_VAR 0 4
96079: ARRAY
96080: IFFALSE 96161
// begin for i in hackTanksCaptured [ index ] do
96082: LD_ADDR_VAR 0 3
96086: PUSH
96087: LD_EXP 171
96091: PUSH
96092: LD_VAR 0 4
96096: ARRAY
96097: PUSH
96098: FOR_IN
96099: IFFALSE 96125
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
96101: LD_VAR 0 3
96105: PUSH
96106: LD_INT 1
96108: ARRAY
96109: PPUSH
96110: LD_VAR 0 3
96114: PUSH
96115: LD_INT 2
96117: ARRAY
96118: PPUSH
96119: CALL_OW 235
96123: GO 96098
96125: POP
96126: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
96127: LD_ADDR_EXP 171
96131: PUSH
96132: LD_EXP 171
96136: PPUSH
96137: LD_VAR 0 4
96141: PPUSH
96142: EMPTY
96143: PPUSH
96144: CALL_OW 1
96148: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
96149: LD_VAR 0 1
96153: PPUSH
96154: LD_INT 0
96156: PPUSH
96157: CALL_OW 505
// end ; end ;
96161: LD_VAR 0 2
96165: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
96166: LD_INT 0
96168: PPUSH
96169: PPUSH
96170: PPUSH
// if not hack in hackTanks or not vehicles then
96171: LD_VAR 0 1
96175: PUSH
96176: LD_EXP 170
96180: IN
96181: NOT
96182: PUSH
96183: LD_VAR 0 2
96187: NOT
96188: OR
96189: IFFALSE 96193
// exit ;
96191: GO 96468
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
96193: LD_ADDR_VAR 0 2
96197: PUSH
96198: LD_VAR 0 1
96202: PPUSH
96203: LD_VAR 0 2
96207: PPUSH
96208: LD_INT 1
96210: PPUSH
96211: LD_INT 1
96213: PPUSH
96214: CALL 18983 0 4
96218: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
96219: LD_ADDR_VAR 0 5
96223: PUSH
96224: LD_EXP 170
96228: PPUSH
96229: LD_VAR 0 1
96233: PPUSH
96234: CALL 18333 0 2
96238: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
96239: LD_EXP 171
96243: PUSH
96244: LD_VAR 0 5
96248: ARRAY
96249: PUSH
96250: LD_EXP 172
96254: LESS
96255: IFFALSE 96444
// begin for i := 1 to vehicles do
96257: LD_ADDR_VAR 0 4
96261: PUSH
96262: DOUBLE
96263: LD_INT 1
96265: DEC
96266: ST_TO_ADDR
96267: LD_VAR 0 2
96271: PUSH
96272: FOR_TO
96273: IFFALSE 96442
// begin if hackTanksCaptured [ index ] = hackLimit then
96275: LD_EXP 171
96279: PUSH
96280: LD_VAR 0 5
96284: ARRAY
96285: PUSH
96286: LD_EXP 172
96290: EQUAL
96291: IFFALSE 96295
// break ;
96293: GO 96442
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
96295: LD_ADDR_EXP 174
96299: PUSH
96300: LD_EXP 174
96304: PPUSH
96305: LD_VAR 0 5
96309: PPUSH
96310: LD_EXP 174
96314: PUSH
96315: LD_VAR 0 5
96319: ARRAY
96320: PUSH
96321: LD_INT 1
96323: PLUS
96324: PPUSH
96325: CALL_OW 1
96329: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
96330: LD_ADDR_EXP 171
96334: PUSH
96335: LD_EXP 171
96339: PPUSH
96340: LD_VAR 0 5
96344: PUSH
96345: LD_EXP 171
96349: PUSH
96350: LD_VAR 0 5
96354: ARRAY
96355: PUSH
96356: LD_INT 1
96358: PLUS
96359: PUSH
96360: EMPTY
96361: LIST
96362: LIST
96363: PPUSH
96364: LD_VAR 0 2
96368: PUSH
96369: LD_VAR 0 4
96373: ARRAY
96374: PUSH
96375: LD_VAR 0 2
96379: PUSH
96380: LD_VAR 0 4
96384: ARRAY
96385: PPUSH
96386: CALL_OW 255
96390: PUSH
96391: EMPTY
96392: LIST
96393: LIST
96394: PPUSH
96395: CALL 18548 0 3
96399: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
96400: LD_VAR 0 2
96404: PUSH
96405: LD_VAR 0 4
96409: ARRAY
96410: PPUSH
96411: LD_VAR 0 1
96415: PPUSH
96416: CALL_OW 255
96420: PPUSH
96421: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
96425: LD_VAR 0 2
96429: PUSH
96430: LD_VAR 0 4
96434: ARRAY
96435: PPUSH
96436: CALL_OW 141
// end ;
96440: GO 96272
96442: POP
96443: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
96444: LD_VAR 0 1
96448: PPUSH
96449: LD_EXP 171
96453: PUSH
96454: LD_VAR 0 5
96458: ARRAY
96459: PUSH
96460: LD_INT 0
96462: PLUS
96463: PPUSH
96464: CALL_OW 505
// end ;
96468: LD_VAR 0 3
96472: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
96473: LD_INT 0
96475: PPUSH
96476: PPUSH
96477: PPUSH
96478: PPUSH
// if not hack in hackTanks then
96479: LD_VAR 0 1
96483: PUSH
96484: LD_EXP 170
96488: IN
96489: NOT
96490: IFFALSE 96494
// exit ;
96492: GO 96734
// index := GetElementIndex ( hackTanks , hack ) ;
96494: LD_ADDR_VAR 0 4
96498: PUSH
96499: LD_EXP 170
96503: PPUSH
96504: LD_VAR 0 1
96508: PPUSH
96509: CALL 18333 0 2
96513: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
96514: LD_ADDR_VAR 0 3
96518: PUSH
96519: DOUBLE
96520: LD_EXP 171
96524: PUSH
96525: LD_VAR 0 4
96529: ARRAY
96530: INC
96531: ST_TO_ADDR
96532: LD_INT 1
96534: PUSH
96535: FOR_DOWNTO
96536: IFFALSE 96708
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
96538: LD_ADDR_VAR 0 5
96542: PUSH
96543: LD_EXP 171
96547: PUSH
96548: LD_VAR 0 4
96552: ARRAY
96553: PUSH
96554: LD_VAR 0 3
96558: ARRAY
96559: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
96560: LD_VAR 0 5
96564: PUSH
96565: LD_INT 1
96567: ARRAY
96568: PPUSH
96569: CALL_OW 302
96573: NOT
96574: PUSH
96575: LD_VAR 0 5
96579: PUSH
96580: LD_INT 1
96582: ARRAY
96583: PPUSH
96584: CALL_OW 255
96588: PUSH
96589: LD_VAR 0 1
96593: PPUSH
96594: CALL_OW 255
96598: NONEQUAL
96599: OR
96600: IFFALSE 96706
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
96602: LD_VAR 0 5
96606: PUSH
96607: LD_INT 1
96609: ARRAY
96610: PPUSH
96611: CALL_OW 305
96615: PUSH
96616: LD_VAR 0 5
96620: PUSH
96621: LD_INT 1
96623: ARRAY
96624: PPUSH
96625: CALL_OW 255
96629: PUSH
96630: LD_VAR 0 1
96634: PPUSH
96635: CALL_OW 255
96639: EQUAL
96640: AND
96641: IFFALSE 96665
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
96643: LD_VAR 0 5
96647: PUSH
96648: LD_INT 1
96650: ARRAY
96651: PPUSH
96652: LD_VAR 0 5
96656: PUSH
96657: LD_INT 2
96659: ARRAY
96660: PPUSH
96661: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
96665: LD_ADDR_EXP 171
96669: PUSH
96670: LD_EXP 171
96674: PPUSH
96675: LD_VAR 0 4
96679: PPUSH
96680: LD_EXP 171
96684: PUSH
96685: LD_VAR 0 4
96689: ARRAY
96690: PPUSH
96691: LD_VAR 0 3
96695: PPUSH
96696: CALL_OW 3
96700: PPUSH
96701: CALL_OW 1
96705: ST_TO_ADDR
// end ; end ;
96706: GO 96535
96708: POP
96709: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
96710: LD_VAR 0 1
96714: PPUSH
96715: LD_EXP 171
96719: PUSH
96720: LD_VAR 0 4
96724: ARRAY
96725: PUSH
96726: LD_INT 0
96728: PLUS
96729: PPUSH
96730: CALL_OW 505
// end ;
96734: LD_VAR 0 2
96738: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
96739: LD_INT 0
96741: PPUSH
96742: PPUSH
96743: PPUSH
96744: PPUSH
// if not hack in hackTanks then
96745: LD_VAR 0 1
96749: PUSH
96750: LD_EXP 170
96754: IN
96755: NOT
96756: IFFALSE 96760
// exit ;
96758: GO 96845
// index := GetElementIndex ( hackTanks , hack ) ;
96760: LD_ADDR_VAR 0 5
96764: PUSH
96765: LD_EXP 170
96769: PPUSH
96770: LD_VAR 0 1
96774: PPUSH
96775: CALL 18333 0 2
96779: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
96780: LD_ADDR_VAR 0 4
96784: PUSH
96785: DOUBLE
96786: LD_INT 1
96788: DEC
96789: ST_TO_ADDR
96790: LD_EXP 171
96794: PUSH
96795: LD_VAR 0 5
96799: ARRAY
96800: PUSH
96801: FOR_TO
96802: IFFALSE 96843
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
96804: LD_EXP 171
96808: PUSH
96809: LD_VAR 0 5
96813: ARRAY
96814: PUSH
96815: LD_VAR 0 4
96819: ARRAY
96820: PUSH
96821: LD_INT 1
96823: ARRAY
96824: PUSH
96825: LD_VAR 0 2
96829: EQUAL
96830: IFFALSE 96841
// KillUnit ( vehicle ) ;
96832: LD_VAR 0 2
96836: PPUSH
96837: CALL_OW 66
96841: GO 96801
96843: POP
96844: POP
// end ;
96845: LD_VAR 0 3
96849: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
96850: LD_EXP 175
96854: NOT
96855: IFFALSE 96890
96857: GO 96859
96859: DISABLE
// begin initMiner := true ;
96860: LD_ADDR_EXP 175
96864: PUSH
96865: LD_INT 1
96867: ST_TO_ADDR
// minersList := [ ] ;
96868: LD_ADDR_EXP 176
96872: PUSH
96873: EMPTY
96874: ST_TO_ADDR
// minerMinesList := [ ] ;
96875: LD_ADDR_EXP 177
96879: PUSH
96880: EMPTY
96881: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
96882: LD_ADDR_EXP 178
96886: PUSH
96887: LD_INT 5
96889: ST_TO_ADDR
// end ;
96890: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
96891: LD_EXP 175
96895: PUSH
96896: LD_INT 34
96898: PUSH
96899: LD_EXP 55
96903: PUSH
96904: EMPTY
96905: LIST
96906: LIST
96907: PPUSH
96908: CALL_OW 69
96912: AND
96913: IFFALSE 97376
96915: GO 96917
96917: DISABLE
96918: LD_INT 0
96920: PPUSH
96921: PPUSH
96922: PPUSH
96923: PPUSH
// begin enable ;
96924: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
96925: LD_ADDR_VAR 0 1
96929: PUSH
96930: LD_INT 34
96932: PUSH
96933: LD_EXP 55
96937: PUSH
96938: EMPTY
96939: LIST
96940: LIST
96941: PPUSH
96942: CALL_OW 69
96946: PUSH
96947: FOR_IN
96948: IFFALSE 97020
// begin if not i in minersList then
96950: LD_VAR 0 1
96954: PUSH
96955: LD_EXP 176
96959: IN
96960: NOT
96961: IFFALSE 97018
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
96963: LD_ADDR_EXP 176
96967: PUSH
96968: LD_EXP 176
96972: PPUSH
96973: LD_EXP 176
96977: PUSH
96978: LD_INT 1
96980: PLUS
96981: PPUSH
96982: LD_VAR 0 1
96986: PPUSH
96987: CALL_OW 1
96991: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
96992: LD_ADDR_EXP 177
96996: PUSH
96997: LD_EXP 177
97001: PPUSH
97002: LD_EXP 177
97006: PUSH
97007: LD_INT 1
97009: PLUS
97010: PPUSH
97011: EMPTY
97012: PPUSH
97013: CALL_OW 1
97017: ST_TO_ADDR
// end end ;
97018: GO 96947
97020: POP
97021: POP
// for i := minerMinesList downto 1 do
97022: LD_ADDR_VAR 0 1
97026: PUSH
97027: DOUBLE
97028: LD_EXP 177
97032: INC
97033: ST_TO_ADDR
97034: LD_INT 1
97036: PUSH
97037: FOR_DOWNTO
97038: IFFALSE 97374
// begin if IsLive ( minersList [ i ] ) then
97040: LD_EXP 176
97044: PUSH
97045: LD_VAR 0 1
97049: ARRAY
97050: PPUSH
97051: CALL_OW 300
97055: IFFALSE 97083
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
97057: LD_EXP 176
97061: PUSH
97062: LD_VAR 0 1
97066: ARRAY
97067: PPUSH
97068: LD_EXP 177
97072: PUSH
97073: LD_VAR 0 1
97077: ARRAY
97078: PPUSH
97079: CALL_OW 505
// if not minerMinesList [ i ] then
97083: LD_EXP 177
97087: PUSH
97088: LD_VAR 0 1
97092: ARRAY
97093: NOT
97094: IFFALSE 97098
// continue ;
97096: GO 97037
// for j := minerMinesList [ i ] downto 1 do
97098: LD_ADDR_VAR 0 2
97102: PUSH
97103: DOUBLE
97104: LD_EXP 177
97108: PUSH
97109: LD_VAR 0 1
97113: ARRAY
97114: INC
97115: ST_TO_ADDR
97116: LD_INT 1
97118: PUSH
97119: FOR_DOWNTO
97120: IFFALSE 97370
// begin side := GetSide ( minersList [ i ] ) ;
97122: LD_ADDR_VAR 0 3
97126: PUSH
97127: LD_EXP 176
97131: PUSH
97132: LD_VAR 0 1
97136: ARRAY
97137: PPUSH
97138: CALL_OW 255
97142: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
97143: LD_ADDR_VAR 0 4
97147: PUSH
97148: LD_EXP 177
97152: PUSH
97153: LD_VAR 0 1
97157: ARRAY
97158: PUSH
97159: LD_VAR 0 2
97163: ARRAY
97164: PUSH
97165: LD_INT 1
97167: ARRAY
97168: PPUSH
97169: LD_EXP 177
97173: PUSH
97174: LD_VAR 0 1
97178: ARRAY
97179: PUSH
97180: LD_VAR 0 2
97184: ARRAY
97185: PUSH
97186: LD_INT 2
97188: ARRAY
97189: PPUSH
97190: CALL_OW 428
97194: ST_TO_ADDR
// if not tmp then
97195: LD_VAR 0 4
97199: NOT
97200: IFFALSE 97204
// continue ;
97202: GO 97119
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
97204: LD_VAR 0 4
97208: PUSH
97209: LD_INT 81
97211: PUSH
97212: LD_VAR 0 3
97216: PUSH
97217: EMPTY
97218: LIST
97219: LIST
97220: PPUSH
97221: CALL_OW 69
97225: IN
97226: PUSH
97227: LD_EXP 177
97231: PUSH
97232: LD_VAR 0 1
97236: ARRAY
97237: PUSH
97238: LD_VAR 0 2
97242: ARRAY
97243: PUSH
97244: LD_INT 1
97246: ARRAY
97247: PPUSH
97248: LD_EXP 177
97252: PUSH
97253: LD_VAR 0 1
97257: ARRAY
97258: PUSH
97259: LD_VAR 0 2
97263: ARRAY
97264: PUSH
97265: LD_INT 2
97267: ARRAY
97268: PPUSH
97269: CALL_OW 458
97273: AND
97274: IFFALSE 97368
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
97276: LD_EXP 177
97280: PUSH
97281: LD_VAR 0 1
97285: ARRAY
97286: PUSH
97287: LD_VAR 0 2
97291: ARRAY
97292: PUSH
97293: LD_INT 1
97295: ARRAY
97296: PPUSH
97297: LD_EXP 177
97301: PUSH
97302: LD_VAR 0 1
97306: ARRAY
97307: PUSH
97308: LD_VAR 0 2
97312: ARRAY
97313: PUSH
97314: LD_INT 2
97316: ARRAY
97317: PPUSH
97318: LD_VAR 0 3
97322: PPUSH
97323: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
97327: LD_ADDR_EXP 177
97331: PUSH
97332: LD_EXP 177
97336: PPUSH
97337: LD_VAR 0 1
97341: PPUSH
97342: LD_EXP 177
97346: PUSH
97347: LD_VAR 0 1
97351: ARRAY
97352: PPUSH
97353: LD_VAR 0 2
97357: PPUSH
97358: CALL_OW 3
97362: PPUSH
97363: CALL_OW 1
97367: ST_TO_ADDR
// end ; end ;
97368: GO 97119
97370: POP
97371: POP
// end ;
97372: GO 97037
97374: POP
97375: POP
// end ;
97376: PPOPN 4
97378: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
97379: LD_INT 0
97381: PPUSH
97382: PPUSH
// result := false ;
97383: LD_ADDR_VAR 0 4
97387: PUSH
97388: LD_INT 0
97390: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
97391: LD_VAR 0 1
97395: PPUSH
97396: CALL_OW 264
97400: PUSH
97401: LD_EXP 55
97405: EQUAL
97406: NOT
97407: IFFALSE 97411
// exit ;
97409: GO 97651
// index := GetElementIndex ( minersList , unit ) ;
97411: LD_ADDR_VAR 0 5
97415: PUSH
97416: LD_EXP 176
97420: PPUSH
97421: LD_VAR 0 1
97425: PPUSH
97426: CALL 18333 0 2
97430: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
97431: LD_EXP 177
97435: PUSH
97436: LD_VAR 0 5
97440: ARRAY
97441: PUSH
97442: LD_EXP 178
97446: GREATEREQUAL
97447: IFFALSE 97451
// exit ;
97449: GO 97651
// ComMoveXY ( unit , x , y ) ;
97451: LD_VAR 0 1
97455: PPUSH
97456: LD_VAR 0 2
97460: PPUSH
97461: LD_VAR 0 3
97465: PPUSH
97466: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
97470: LD_INT 35
97472: PPUSH
97473: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
97477: LD_VAR 0 1
97481: PPUSH
97482: LD_VAR 0 2
97486: PPUSH
97487: LD_VAR 0 3
97491: PPUSH
97492: CALL 48730 0 3
97496: NOT
97497: PUSH
97498: LD_VAR 0 1
97502: PPUSH
97503: CALL_OW 314
97507: AND
97508: IFFALSE 97512
// exit ;
97510: GO 97651
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
97512: LD_VAR 0 2
97516: PPUSH
97517: LD_VAR 0 3
97521: PPUSH
97522: CALL_OW 428
97526: PUSH
97527: LD_VAR 0 1
97531: EQUAL
97532: PUSH
97533: LD_VAR 0 1
97537: PPUSH
97538: CALL_OW 314
97542: NOT
97543: AND
97544: IFFALSE 97470
// PlaySoundXY ( x , y , PlantMine ) ;
97546: LD_VAR 0 2
97550: PPUSH
97551: LD_VAR 0 3
97555: PPUSH
97556: LD_STRING PlantMine
97558: PPUSH
97559: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
97563: LD_VAR 0 2
97567: PPUSH
97568: LD_VAR 0 3
97572: PPUSH
97573: LD_VAR 0 1
97577: PPUSH
97578: CALL_OW 255
97582: PPUSH
97583: LD_INT 0
97585: PPUSH
97586: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
97590: LD_ADDR_EXP 177
97594: PUSH
97595: LD_EXP 177
97599: PPUSH
97600: LD_VAR 0 5
97604: PUSH
97605: LD_EXP 177
97609: PUSH
97610: LD_VAR 0 5
97614: ARRAY
97615: PUSH
97616: LD_INT 1
97618: PLUS
97619: PUSH
97620: EMPTY
97621: LIST
97622: LIST
97623: PPUSH
97624: LD_VAR 0 2
97628: PUSH
97629: LD_VAR 0 3
97633: PUSH
97634: EMPTY
97635: LIST
97636: LIST
97637: PPUSH
97638: CALL 18548 0 3
97642: ST_TO_ADDR
// result := true ;
97643: LD_ADDR_VAR 0 4
97647: PUSH
97648: LD_INT 1
97650: ST_TO_ADDR
// end ;
97651: LD_VAR 0 4
97655: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
97656: LD_INT 0
97658: PPUSH
97659: PPUSH
97660: PPUSH
// if not unit in minersList then
97661: LD_VAR 0 1
97665: PUSH
97666: LD_EXP 176
97670: IN
97671: NOT
97672: IFFALSE 97676
// exit ;
97674: GO 98068
// index := GetElementIndex ( minersList , unit ) ;
97676: LD_ADDR_VAR 0 6
97680: PUSH
97681: LD_EXP 176
97685: PPUSH
97686: LD_VAR 0 1
97690: PPUSH
97691: CALL 18333 0 2
97695: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
97696: LD_ADDR_VAR 0 5
97700: PUSH
97701: DOUBLE
97702: LD_EXP 177
97706: PUSH
97707: LD_VAR 0 6
97711: ARRAY
97712: INC
97713: ST_TO_ADDR
97714: LD_INT 1
97716: PUSH
97717: FOR_DOWNTO
97718: IFFALSE 97879
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
97720: LD_EXP 177
97724: PUSH
97725: LD_VAR 0 6
97729: ARRAY
97730: PUSH
97731: LD_VAR 0 5
97735: ARRAY
97736: PUSH
97737: LD_INT 1
97739: ARRAY
97740: PUSH
97741: LD_VAR 0 2
97745: EQUAL
97746: PUSH
97747: LD_EXP 177
97751: PUSH
97752: LD_VAR 0 6
97756: ARRAY
97757: PUSH
97758: LD_VAR 0 5
97762: ARRAY
97763: PUSH
97764: LD_INT 2
97766: ARRAY
97767: PUSH
97768: LD_VAR 0 3
97772: EQUAL
97773: AND
97774: IFFALSE 97877
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
97776: LD_EXP 177
97780: PUSH
97781: LD_VAR 0 6
97785: ARRAY
97786: PUSH
97787: LD_VAR 0 5
97791: ARRAY
97792: PUSH
97793: LD_INT 1
97795: ARRAY
97796: PPUSH
97797: LD_EXP 177
97801: PUSH
97802: LD_VAR 0 6
97806: ARRAY
97807: PUSH
97808: LD_VAR 0 5
97812: ARRAY
97813: PUSH
97814: LD_INT 2
97816: ARRAY
97817: PPUSH
97818: LD_VAR 0 1
97822: PPUSH
97823: CALL_OW 255
97827: PPUSH
97828: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
97832: LD_ADDR_EXP 177
97836: PUSH
97837: LD_EXP 177
97841: PPUSH
97842: LD_VAR 0 6
97846: PPUSH
97847: LD_EXP 177
97851: PUSH
97852: LD_VAR 0 6
97856: ARRAY
97857: PPUSH
97858: LD_VAR 0 5
97862: PPUSH
97863: CALL_OW 3
97867: PPUSH
97868: CALL_OW 1
97872: ST_TO_ADDR
// exit ;
97873: POP
97874: POP
97875: GO 98068
// end ; end ;
97877: GO 97717
97879: POP
97880: POP
// for i := minerMinesList [ index ] downto 1 do
97881: LD_ADDR_VAR 0 5
97885: PUSH
97886: DOUBLE
97887: LD_EXP 177
97891: PUSH
97892: LD_VAR 0 6
97896: ARRAY
97897: INC
97898: ST_TO_ADDR
97899: LD_INT 1
97901: PUSH
97902: FOR_DOWNTO
97903: IFFALSE 98066
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
97905: LD_EXP 177
97909: PUSH
97910: LD_VAR 0 6
97914: ARRAY
97915: PUSH
97916: LD_VAR 0 5
97920: ARRAY
97921: PUSH
97922: LD_INT 1
97924: ARRAY
97925: PPUSH
97926: LD_EXP 177
97930: PUSH
97931: LD_VAR 0 6
97935: ARRAY
97936: PUSH
97937: LD_VAR 0 5
97941: ARRAY
97942: PUSH
97943: LD_INT 2
97945: ARRAY
97946: PPUSH
97947: LD_VAR 0 2
97951: PPUSH
97952: LD_VAR 0 3
97956: PPUSH
97957: CALL_OW 298
97961: PUSH
97962: LD_INT 6
97964: LESS
97965: IFFALSE 98064
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
97967: LD_EXP 177
97971: PUSH
97972: LD_VAR 0 6
97976: ARRAY
97977: PUSH
97978: LD_VAR 0 5
97982: ARRAY
97983: PUSH
97984: LD_INT 1
97986: ARRAY
97987: PPUSH
97988: LD_EXP 177
97992: PUSH
97993: LD_VAR 0 6
97997: ARRAY
97998: PUSH
97999: LD_VAR 0 5
98003: ARRAY
98004: PUSH
98005: LD_INT 2
98007: ARRAY
98008: PPUSH
98009: LD_VAR 0 1
98013: PPUSH
98014: CALL_OW 255
98018: PPUSH
98019: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
98023: LD_ADDR_EXP 177
98027: PUSH
98028: LD_EXP 177
98032: PPUSH
98033: LD_VAR 0 6
98037: PPUSH
98038: LD_EXP 177
98042: PUSH
98043: LD_VAR 0 6
98047: ARRAY
98048: PPUSH
98049: LD_VAR 0 5
98053: PPUSH
98054: CALL_OW 3
98058: PPUSH
98059: CALL_OW 1
98063: ST_TO_ADDR
// end ; end ;
98064: GO 97902
98066: POP
98067: POP
// end ;
98068: LD_VAR 0 4
98072: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
98073: LD_INT 0
98075: PPUSH
98076: PPUSH
98077: PPUSH
98078: PPUSH
98079: PPUSH
98080: PPUSH
98081: PPUSH
98082: PPUSH
98083: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
98084: LD_VAR 0 1
98088: PPUSH
98089: CALL_OW 264
98093: PUSH
98094: LD_EXP 55
98098: EQUAL
98099: NOT
98100: PUSH
98101: LD_VAR 0 1
98105: PUSH
98106: LD_EXP 176
98110: IN
98111: NOT
98112: OR
98113: IFFALSE 98117
// exit ;
98115: GO 98439
// index := GetElementIndex ( minersList , unit ) ;
98117: LD_ADDR_VAR 0 6
98121: PUSH
98122: LD_EXP 176
98126: PPUSH
98127: LD_VAR 0 1
98131: PPUSH
98132: CALL 18333 0 2
98136: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
98137: LD_ADDR_VAR 0 8
98141: PUSH
98142: LD_EXP 178
98146: PUSH
98147: LD_EXP 177
98151: PUSH
98152: LD_VAR 0 6
98156: ARRAY
98157: MINUS
98158: ST_TO_ADDR
// if not minesFreeAmount then
98159: LD_VAR 0 8
98163: NOT
98164: IFFALSE 98168
// exit ;
98166: GO 98439
// tmp := [ ] ;
98168: LD_ADDR_VAR 0 7
98172: PUSH
98173: EMPTY
98174: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
98175: LD_ADDR_VAR 0 5
98179: PUSH
98180: DOUBLE
98181: LD_INT 1
98183: DEC
98184: ST_TO_ADDR
98185: LD_VAR 0 8
98189: PUSH
98190: FOR_TO
98191: IFFALSE 98386
// begin _d := rand ( 0 , 5 ) ;
98193: LD_ADDR_VAR 0 11
98197: PUSH
98198: LD_INT 0
98200: PPUSH
98201: LD_INT 5
98203: PPUSH
98204: CALL_OW 12
98208: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
98209: LD_ADDR_VAR 0 12
98213: PUSH
98214: LD_INT 2
98216: PPUSH
98217: LD_INT 6
98219: PPUSH
98220: CALL_OW 12
98224: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
98225: LD_ADDR_VAR 0 9
98229: PUSH
98230: LD_VAR 0 2
98234: PPUSH
98235: LD_VAR 0 11
98239: PPUSH
98240: LD_VAR 0 12
98244: PPUSH
98245: CALL_OW 272
98249: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
98250: LD_ADDR_VAR 0 10
98254: PUSH
98255: LD_VAR 0 3
98259: PPUSH
98260: LD_VAR 0 11
98264: PPUSH
98265: LD_VAR 0 12
98269: PPUSH
98270: CALL_OW 273
98274: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
98275: LD_VAR 0 9
98279: PPUSH
98280: LD_VAR 0 10
98284: PPUSH
98285: CALL_OW 488
98289: PUSH
98290: LD_VAR 0 9
98294: PUSH
98295: LD_VAR 0 10
98299: PUSH
98300: EMPTY
98301: LIST
98302: LIST
98303: PUSH
98304: LD_VAR 0 7
98308: IN
98309: NOT
98310: AND
98311: PUSH
98312: LD_VAR 0 9
98316: PPUSH
98317: LD_VAR 0 10
98321: PPUSH
98322: CALL_OW 458
98326: NOT
98327: AND
98328: IFFALSE 98370
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
98330: LD_ADDR_VAR 0 7
98334: PUSH
98335: LD_VAR 0 7
98339: PPUSH
98340: LD_VAR 0 7
98344: PUSH
98345: LD_INT 1
98347: PLUS
98348: PPUSH
98349: LD_VAR 0 9
98353: PUSH
98354: LD_VAR 0 10
98358: PUSH
98359: EMPTY
98360: LIST
98361: LIST
98362: PPUSH
98363: CALL_OW 1
98367: ST_TO_ADDR
98368: GO 98384
// i := i - 1 ;
98370: LD_ADDR_VAR 0 5
98374: PUSH
98375: LD_VAR 0 5
98379: PUSH
98380: LD_INT 1
98382: MINUS
98383: ST_TO_ADDR
// end ;
98384: GO 98190
98386: POP
98387: POP
// for i in tmp do
98388: LD_ADDR_VAR 0 5
98392: PUSH
98393: LD_VAR 0 7
98397: PUSH
98398: FOR_IN
98399: IFFALSE 98437
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
98401: LD_VAR 0 1
98405: PPUSH
98406: LD_VAR 0 5
98410: PUSH
98411: LD_INT 1
98413: ARRAY
98414: PPUSH
98415: LD_VAR 0 5
98419: PUSH
98420: LD_INT 2
98422: ARRAY
98423: PPUSH
98424: CALL 97379 0 3
98428: NOT
98429: IFFALSE 98435
// exit ;
98431: POP
98432: POP
98433: GO 98439
98435: GO 98398
98437: POP
98438: POP
// end ;
98439: LD_VAR 0 4
98443: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
98444: LD_INT 0
98446: PPUSH
98447: PPUSH
98448: PPUSH
98449: PPUSH
98450: PPUSH
98451: PPUSH
98452: PPUSH
// if not GetClass ( unit ) = class_sniper then
98453: LD_VAR 0 1
98457: PPUSH
98458: CALL_OW 257
98462: PUSH
98463: LD_INT 5
98465: EQUAL
98466: NOT
98467: IFFALSE 98471
// exit ;
98469: GO 98859
// dist := 8 ;
98471: LD_ADDR_VAR 0 5
98475: PUSH
98476: LD_INT 8
98478: ST_TO_ADDR
// viewRange := 12 ;
98479: LD_ADDR_VAR 0 7
98483: PUSH
98484: LD_INT 12
98486: ST_TO_ADDR
// side := GetSide ( unit ) ;
98487: LD_ADDR_VAR 0 6
98491: PUSH
98492: LD_VAR 0 1
98496: PPUSH
98497: CALL_OW 255
98501: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
98502: LD_INT 61
98504: PPUSH
98505: LD_VAR 0 6
98509: PPUSH
98510: CALL_OW 321
98514: PUSH
98515: LD_INT 2
98517: EQUAL
98518: IFFALSE 98528
// viewRange := 16 ;
98520: LD_ADDR_VAR 0 7
98524: PUSH
98525: LD_INT 16
98527: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
98528: LD_VAR 0 1
98532: PPUSH
98533: LD_VAR 0 2
98537: PPUSH
98538: LD_VAR 0 3
98542: PPUSH
98543: CALL_OW 297
98547: PUSH
98548: LD_VAR 0 5
98552: GREATER
98553: IFFALSE 98632
// begin ComMoveXY ( unit , x , y ) ;
98555: LD_VAR 0 1
98559: PPUSH
98560: LD_VAR 0 2
98564: PPUSH
98565: LD_VAR 0 3
98569: PPUSH
98570: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
98574: LD_INT 35
98576: PPUSH
98577: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
98581: LD_VAR 0 1
98585: PPUSH
98586: LD_VAR 0 2
98590: PPUSH
98591: LD_VAR 0 3
98595: PPUSH
98596: CALL 48730 0 3
98600: NOT
98601: IFFALSE 98605
// exit ;
98603: GO 98859
// until GetDistUnitXY ( unit , x , y ) < dist ;
98605: LD_VAR 0 1
98609: PPUSH
98610: LD_VAR 0 2
98614: PPUSH
98615: LD_VAR 0 3
98619: PPUSH
98620: CALL_OW 297
98624: PUSH
98625: LD_VAR 0 5
98629: LESS
98630: IFFALSE 98574
// end ; ComTurnXY ( unit , x , y ) ;
98632: LD_VAR 0 1
98636: PPUSH
98637: LD_VAR 0 2
98641: PPUSH
98642: LD_VAR 0 3
98646: PPUSH
98647: CALL_OW 118
// wait ( 5 ) ;
98651: LD_INT 5
98653: PPUSH
98654: CALL_OW 67
// _d := GetDir ( unit ) ;
98658: LD_ADDR_VAR 0 10
98662: PUSH
98663: LD_VAR 0 1
98667: PPUSH
98668: CALL_OW 254
98672: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
98673: LD_ADDR_VAR 0 8
98677: PUSH
98678: LD_VAR 0 1
98682: PPUSH
98683: CALL_OW 250
98687: PPUSH
98688: LD_VAR 0 10
98692: PPUSH
98693: LD_VAR 0 5
98697: PPUSH
98698: CALL_OW 272
98702: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
98703: LD_ADDR_VAR 0 9
98707: PUSH
98708: LD_VAR 0 1
98712: PPUSH
98713: CALL_OW 251
98717: PPUSH
98718: LD_VAR 0 10
98722: PPUSH
98723: LD_VAR 0 5
98727: PPUSH
98728: CALL_OW 273
98732: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
98733: LD_VAR 0 8
98737: PPUSH
98738: LD_VAR 0 9
98742: PPUSH
98743: CALL_OW 488
98747: NOT
98748: IFFALSE 98752
// exit ;
98750: GO 98859
// ComAnimCustom ( unit , 1 ) ;
98752: LD_VAR 0 1
98756: PPUSH
98757: LD_INT 1
98759: PPUSH
98760: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
98764: LD_VAR 0 8
98768: PPUSH
98769: LD_VAR 0 9
98773: PPUSH
98774: LD_VAR 0 6
98778: PPUSH
98779: LD_VAR 0 7
98783: PPUSH
98784: CALL_OW 330
// repeat wait ( 1 ) ;
98788: LD_INT 1
98790: PPUSH
98791: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
98795: LD_VAR 0 1
98799: PPUSH
98800: CALL_OW 316
98804: PUSH
98805: LD_VAR 0 1
98809: PPUSH
98810: CALL_OW 314
98814: OR
98815: PUSH
98816: LD_VAR 0 1
98820: PPUSH
98821: CALL_OW 302
98825: NOT
98826: OR
98827: PUSH
98828: LD_VAR 0 1
98832: PPUSH
98833: CALL_OW 301
98837: OR
98838: IFFALSE 98788
// RemoveSeeing ( _x , _y , side ) ;
98840: LD_VAR 0 8
98844: PPUSH
98845: LD_VAR 0 9
98849: PPUSH
98850: LD_VAR 0 6
98854: PPUSH
98855: CALL_OW 331
// end ; end_of_file
98859: LD_VAR 0 4
98863: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
98864: LD_INT 0
98866: PPUSH
98867: PPUSH
98868: PPUSH
98869: PPUSH
98870: PPUSH
98871: PPUSH
98872: PPUSH
98873: PPUSH
98874: PPUSH
98875: PPUSH
98876: PPUSH
98877: PPUSH
98878: PPUSH
98879: PPUSH
98880: PPUSH
98881: PPUSH
98882: PPUSH
98883: PPUSH
98884: PPUSH
98885: PPUSH
98886: PPUSH
98887: PPUSH
98888: PPUSH
98889: PPUSH
98890: PPUSH
98891: PPUSH
98892: PPUSH
98893: PPUSH
98894: PPUSH
98895: PPUSH
98896: PPUSH
98897: PPUSH
98898: PPUSH
98899: PPUSH
// if not list then
98900: LD_VAR 0 1
98904: NOT
98905: IFFALSE 98909
// exit ;
98907: GO 103568
// base := list [ 1 ] ;
98909: LD_ADDR_VAR 0 3
98913: PUSH
98914: LD_VAR 0 1
98918: PUSH
98919: LD_INT 1
98921: ARRAY
98922: ST_TO_ADDR
// group := list [ 2 ] ;
98923: LD_ADDR_VAR 0 4
98927: PUSH
98928: LD_VAR 0 1
98932: PUSH
98933: LD_INT 2
98935: ARRAY
98936: ST_TO_ADDR
// path := list [ 3 ] ;
98937: LD_ADDR_VAR 0 5
98941: PUSH
98942: LD_VAR 0 1
98946: PUSH
98947: LD_INT 3
98949: ARRAY
98950: ST_TO_ADDR
// flags := list [ 4 ] ;
98951: LD_ADDR_VAR 0 6
98955: PUSH
98956: LD_VAR 0 1
98960: PUSH
98961: LD_INT 4
98963: ARRAY
98964: ST_TO_ADDR
// mined := [ ] ;
98965: LD_ADDR_VAR 0 27
98969: PUSH
98970: EMPTY
98971: ST_TO_ADDR
// bombed := [ ] ;
98972: LD_ADDR_VAR 0 28
98976: PUSH
98977: EMPTY
98978: ST_TO_ADDR
// healers := [ ] ;
98979: LD_ADDR_VAR 0 31
98983: PUSH
98984: EMPTY
98985: ST_TO_ADDR
// to_heal := [ ] ;
98986: LD_ADDR_VAR 0 30
98990: PUSH
98991: EMPTY
98992: ST_TO_ADDR
// repairs := [ ] ;
98993: LD_ADDR_VAR 0 33
98997: PUSH
98998: EMPTY
98999: ST_TO_ADDR
// to_repair := [ ] ;
99000: LD_ADDR_VAR 0 32
99004: PUSH
99005: EMPTY
99006: ST_TO_ADDR
// if not group or not path then
99007: LD_VAR 0 4
99011: NOT
99012: PUSH
99013: LD_VAR 0 5
99017: NOT
99018: OR
99019: IFFALSE 99023
// exit ;
99021: GO 103568
// side := GetSide ( group [ 1 ] ) ;
99023: LD_ADDR_VAR 0 35
99027: PUSH
99028: LD_VAR 0 4
99032: PUSH
99033: LD_INT 1
99035: ARRAY
99036: PPUSH
99037: CALL_OW 255
99041: ST_TO_ADDR
// if flags then
99042: LD_VAR 0 6
99046: IFFALSE 99190
// begin f_ignore_area := flags [ 1 ] ;
99048: LD_ADDR_VAR 0 17
99052: PUSH
99053: LD_VAR 0 6
99057: PUSH
99058: LD_INT 1
99060: ARRAY
99061: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
99062: LD_ADDR_VAR 0 18
99066: PUSH
99067: LD_VAR 0 6
99071: PUSH
99072: LD_INT 2
99074: ARRAY
99075: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
99076: LD_ADDR_VAR 0 19
99080: PUSH
99081: LD_VAR 0 6
99085: PUSH
99086: LD_INT 3
99088: ARRAY
99089: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
99090: LD_ADDR_VAR 0 20
99094: PUSH
99095: LD_VAR 0 6
99099: PUSH
99100: LD_INT 4
99102: ARRAY
99103: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
99104: LD_ADDR_VAR 0 21
99108: PUSH
99109: LD_VAR 0 6
99113: PUSH
99114: LD_INT 5
99116: ARRAY
99117: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
99118: LD_ADDR_VAR 0 22
99122: PUSH
99123: LD_VAR 0 6
99127: PUSH
99128: LD_INT 6
99130: ARRAY
99131: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
99132: LD_ADDR_VAR 0 23
99136: PUSH
99137: LD_VAR 0 6
99141: PUSH
99142: LD_INT 7
99144: ARRAY
99145: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
99146: LD_ADDR_VAR 0 24
99150: PUSH
99151: LD_VAR 0 6
99155: PUSH
99156: LD_INT 8
99158: ARRAY
99159: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
99160: LD_ADDR_VAR 0 25
99164: PUSH
99165: LD_VAR 0 6
99169: PUSH
99170: LD_INT 9
99172: ARRAY
99173: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
99174: LD_ADDR_VAR 0 26
99178: PUSH
99179: LD_VAR 0 6
99183: PUSH
99184: LD_INT 10
99186: ARRAY
99187: ST_TO_ADDR
// end else
99188: GO 99270
// begin f_ignore_area := false ;
99190: LD_ADDR_VAR 0 17
99194: PUSH
99195: LD_INT 0
99197: ST_TO_ADDR
// f_capture := false ;
99198: LD_ADDR_VAR 0 18
99202: PUSH
99203: LD_INT 0
99205: ST_TO_ADDR
// f_ignore_civ := false ;
99206: LD_ADDR_VAR 0 19
99210: PUSH
99211: LD_INT 0
99213: ST_TO_ADDR
// f_murder := false ;
99214: LD_ADDR_VAR 0 20
99218: PUSH
99219: LD_INT 0
99221: ST_TO_ADDR
// f_mines := false ;
99222: LD_ADDR_VAR 0 21
99226: PUSH
99227: LD_INT 0
99229: ST_TO_ADDR
// f_repair := false ;
99230: LD_ADDR_VAR 0 22
99234: PUSH
99235: LD_INT 0
99237: ST_TO_ADDR
// f_heal := false ;
99238: LD_ADDR_VAR 0 23
99242: PUSH
99243: LD_INT 0
99245: ST_TO_ADDR
// f_spacetime := false ;
99246: LD_ADDR_VAR 0 24
99250: PUSH
99251: LD_INT 0
99253: ST_TO_ADDR
// f_attack_depot := false ;
99254: LD_ADDR_VAR 0 25
99258: PUSH
99259: LD_INT 0
99261: ST_TO_ADDR
// f_crawl := false ;
99262: LD_ADDR_VAR 0 26
99266: PUSH
99267: LD_INT 0
99269: ST_TO_ADDR
// end ; if f_heal then
99270: LD_VAR 0 23
99274: IFFALSE 99301
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
99276: LD_ADDR_VAR 0 31
99280: PUSH
99281: LD_VAR 0 4
99285: PPUSH
99286: LD_INT 25
99288: PUSH
99289: LD_INT 4
99291: PUSH
99292: EMPTY
99293: LIST
99294: LIST
99295: PPUSH
99296: CALL_OW 72
99300: ST_TO_ADDR
// if f_repair then
99301: LD_VAR 0 22
99305: IFFALSE 99332
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
99307: LD_ADDR_VAR 0 33
99311: PUSH
99312: LD_VAR 0 4
99316: PPUSH
99317: LD_INT 25
99319: PUSH
99320: LD_INT 3
99322: PUSH
99323: EMPTY
99324: LIST
99325: LIST
99326: PPUSH
99327: CALL_OW 72
99331: ST_TO_ADDR
// units_path := [ ] ;
99332: LD_ADDR_VAR 0 16
99336: PUSH
99337: EMPTY
99338: ST_TO_ADDR
// for i = 1 to group do
99339: LD_ADDR_VAR 0 7
99343: PUSH
99344: DOUBLE
99345: LD_INT 1
99347: DEC
99348: ST_TO_ADDR
99349: LD_VAR 0 4
99353: PUSH
99354: FOR_TO
99355: IFFALSE 99384
// units_path := Replace ( units_path , i , path ) ;
99357: LD_ADDR_VAR 0 16
99361: PUSH
99362: LD_VAR 0 16
99366: PPUSH
99367: LD_VAR 0 7
99371: PPUSH
99372: LD_VAR 0 5
99376: PPUSH
99377: CALL_OW 1
99381: ST_TO_ADDR
99382: GO 99354
99384: POP
99385: POP
// repeat for i = group downto 1 do
99386: LD_ADDR_VAR 0 7
99390: PUSH
99391: DOUBLE
99392: LD_VAR 0 4
99396: INC
99397: ST_TO_ADDR
99398: LD_INT 1
99400: PUSH
99401: FOR_DOWNTO
99402: IFFALSE 103524
// begin wait ( 5 ) ;
99404: LD_INT 5
99406: PPUSH
99407: CALL_OW 67
// tmp := [ ] ;
99411: LD_ADDR_VAR 0 14
99415: PUSH
99416: EMPTY
99417: ST_TO_ADDR
// attacking := false ;
99418: LD_ADDR_VAR 0 29
99422: PUSH
99423: LD_INT 0
99425: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
99426: LD_VAR 0 4
99430: PUSH
99431: LD_VAR 0 7
99435: ARRAY
99436: PPUSH
99437: CALL_OW 301
99441: PUSH
99442: LD_VAR 0 4
99446: PUSH
99447: LD_VAR 0 7
99451: ARRAY
99452: NOT
99453: OR
99454: IFFALSE 99563
// begin if GetType ( group [ i ] ) = unit_human then
99456: LD_VAR 0 4
99460: PUSH
99461: LD_VAR 0 7
99465: ARRAY
99466: PPUSH
99467: CALL_OW 247
99471: PUSH
99472: LD_INT 1
99474: EQUAL
99475: IFFALSE 99521
// begin to_heal := to_heal diff group [ i ] ;
99477: LD_ADDR_VAR 0 30
99481: PUSH
99482: LD_VAR 0 30
99486: PUSH
99487: LD_VAR 0 4
99491: PUSH
99492: LD_VAR 0 7
99496: ARRAY
99497: DIFF
99498: ST_TO_ADDR
// healers := healers diff group [ i ] ;
99499: LD_ADDR_VAR 0 31
99503: PUSH
99504: LD_VAR 0 31
99508: PUSH
99509: LD_VAR 0 4
99513: PUSH
99514: LD_VAR 0 7
99518: ARRAY
99519: DIFF
99520: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
99521: LD_ADDR_VAR 0 4
99525: PUSH
99526: LD_VAR 0 4
99530: PPUSH
99531: LD_VAR 0 7
99535: PPUSH
99536: CALL_OW 3
99540: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
99541: LD_ADDR_VAR 0 16
99545: PUSH
99546: LD_VAR 0 16
99550: PPUSH
99551: LD_VAR 0 7
99555: PPUSH
99556: CALL_OW 3
99560: ST_TO_ADDR
// continue ;
99561: GO 99401
// end ; if f_repair then
99563: LD_VAR 0 22
99567: IFFALSE 100056
// begin if GetType ( group [ i ] ) = unit_vehicle then
99569: LD_VAR 0 4
99573: PUSH
99574: LD_VAR 0 7
99578: ARRAY
99579: PPUSH
99580: CALL_OW 247
99584: PUSH
99585: LD_INT 2
99587: EQUAL
99588: IFFALSE 99778
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
99590: LD_VAR 0 4
99594: PUSH
99595: LD_VAR 0 7
99599: ARRAY
99600: PPUSH
99601: CALL_OW 256
99605: PUSH
99606: LD_INT 700
99608: LESS
99609: PUSH
99610: LD_VAR 0 4
99614: PUSH
99615: LD_VAR 0 7
99619: ARRAY
99620: PUSH
99621: LD_VAR 0 32
99625: IN
99626: NOT
99627: AND
99628: IFFALSE 99652
// to_repair := to_repair union group [ i ] ;
99630: LD_ADDR_VAR 0 32
99634: PUSH
99635: LD_VAR 0 32
99639: PUSH
99640: LD_VAR 0 4
99644: PUSH
99645: LD_VAR 0 7
99649: ARRAY
99650: UNION
99651: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
99652: LD_VAR 0 4
99656: PUSH
99657: LD_VAR 0 7
99661: ARRAY
99662: PPUSH
99663: CALL_OW 256
99667: PUSH
99668: LD_INT 1000
99670: EQUAL
99671: PUSH
99672: LD_VAR 0 4
99676: PUSH
99677: LD_VAR 0 7
99681: ARRAY
99682: PUSH
99683: LD_VAR 0 32
99687: IN
99688: AND
99689: IFFALSE 99713
// to_repair := to_repair diff group [ i ] ;
99691: LD_ADDR_VAR 0 32
99695: PUSH
99696: LD_VAR 0 32
99700: PUSH
99701: LD_VAR 0 4
99705: PUSH
99706: LD_VAR 0 7
99710: ARRAY
99711: DIFF
99712: ST_TO_ADDR
// if group [ i ] in to_repair then
99713: LD_VAR 0 4
99717: PUSH
99718: LD_VAR 0 7
99722: ARRAY
99723: PUSH
99724: LD_VAR 0 32
99728: IN
99729: IFFALSE 99776
// begin if not IsInArea ( group [ i ] , f_repair ) then
99731: LD_VAR 0 4
99735: PUSH
99736: LD_VAR 0 7
99740: ARRAY
99741: PPUSH
99742: LD_VAR 0 22
99746: PPUSH
99747: CALL_OW 308
99751: NOT
99752: IFFALSE 99774
// ComMoveToArea ( group [ i ] , f_repair ) ;
99754: LD_VAR 0 4
99758: PUSH
99759: LD_VAR 0 7
99763: ARRAY
99764: PPUSH
99765: LD_VAR 0 22
99769: PPUSH
99770: CALL_OW 113
// continue ;
99774: GO 99401
// end ; end else
99776: GO 100056
// if group [ i ] in repairs then
99778: LD_VAR 0 4
99782: PUSH
99783: LD_VAR 0 7
99787: ARRAY
99788: PUSH
99789: LD_VAR 0 33
99793: IN
99794: IFFALSE 100056
// begin if IsInUnit ( group [ i ] ) then
99796: LD_VAR 0 4
99800: PUSH
99801: LD_VAR 0 7
99805: ARRAY
99806: PPUSH
99807: CALL_OW 310
99811: IFFALSE 99879
// begin z := IsInUnit ( group [ i ] ) ;
99813: LD_ADDR_VAR 0 13
99817: PUSH
99818: LD_VAR 0 4
99822: PUSH
99823: LD_VAR 0 7
99827: ARRAY
99828: PPUSH
99829: CALL_OW 310
99833: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
99834: LD_VAR 0 13
99838: PUSH
99839: LD_VAR 0 32
99843: IN
99844: PUSH
99845: LD_VAR 0 13
99849: PPUSH
99850: LD_VAR 0 22
99854: PPUSH
99855: CALL_OW 308
99859: AND
99860: IFFALSE 99877
// ComExitVehicle ( group [ i ] ) ;
99862: LD_VAR 0 4
99866: PUSH
99867: LD_VAR 0 7
99871: ARRAY
99872: PPUSH
99873: CALL_OW 121
// end else
99877: GO 100056
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
99879: LD_ADDR_VAR 0 13
99883: PUSH
99884: LD_VAR 0 4
99888: PPUSH
99889: LD_INT 95
99891: PUSH
99892: LD_VAR 0 22
99896: PUSH
99897: EMPTY
99898: LIST
99899: LIST
99900: PUSH
99901: LD_INT 58
99903: PUSH
99904: EMPTY
99905: LIST
99906: PUSH
99907: EMPTY
99908: LIST
99909: LIST
99910: PPUSH
99911: CALL_OW 72
99915: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
99916: LD_VAR 0 4
99920: PUSH
99921: LD_VAR 0 7
99925: ARRAY
99926: PPUSH
99927: CALL_OW 314
99931: NOT
99932: IFFALSE 100054
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
99934: LD_ADDR_VAR 0 10
99938: PUSH
99939: LD_VAR 0 13
99943: PPUSH
99944: LD_VAR 0 4
99948: PUSH
99949: LD_VAR 0 7
99953: ARRAY
99954: PPUSH
99955: CALL_OW 74
99959: ST_TO_ADDR
// if not x then
99960: LD_VAR 0 10
99964: NOT
99965: IFFALSE 99969
// continue ;
99967: GO 99401
// if GetLives ( x ) < 1000 then
99969: LD_VAR 0 10
99973: PPUSH
99974: CALL_OW 256
99978: PUSH
99979: LD_INT 1000
99981: LESS
99982: IFFALSE 100006
// ComRepairVehicle ( group [ i ] , x ) else
99984: LD_VAR 0 4
99988: PUSH
99989: LD_VAR 0 7
99993: ARRAY
99994: PPUSH
99995: LD_VAR 0 10
99999: PPUSH
100000: CALL_OW 129
100004: GO 100054
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
100006: LD_VAR 0 23
100010: PUSH
100011: LD_VAR 0 4
100015: PUSH
100016: LD_VAR 0 7
100020: ARRAY
100021: PPUSH
100022: CALL_OW 256
100026: PUSH
100027: LD_INT 1000
100029: LESS
100030: AND
100031: NOT
100032: IFFALSE 100054
// ComEnterUnit ( group [ i ] , x ) ;
100034: LD_VAR 0 4
100038: PUSH
100039: LD_VAR 0 7
100043: ARRAY
100044: PPUSH
100045: LD_VAR 0 10
100049: PPUSH
100050: CALL_OW 120
// end ; continue ;
100054: GO 99401
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
100056: LD_VAR 0 23
100060: PUSH
100061: LD_VAR 0 4
100065: PUSH
100066: LD_VAR 0 7
100070: ARRAY
100071: PPUSH
100072: CALL_OW 247
100076: PUSH
100077: LD_INT 1
100079: EQUAL
100080: AND
100081: IFFALSE 100559
// begin if group [ i ] in healers then
100083: LD_VAR 0 4
100087: PUSH
100088: LD_VAR 0 7
100092: ARRAY
100093: PUSH
100094: LD_VAR 0 31
100098: IN
100099: IFFALSE 100372
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
100101: LD_VAR 0 4
100105: PUSH
100106: LD_VAR 0 7
100110: ARRAY
100111: PPUSH
100112: LD_VAR 0 23
100116: PPUSH
100117: CALL_OW 308
100121: NOT
100122: PUSH
100123: LD_VAR 0 4
100127: PUSH
100128: LD_VAR 0 7
100132: ARRAY
100133: PPUSH
100134: CALL_OW 314
100138: NOT
100139: AND
100140: IFFALSE 100164
// ComMoveToArea ( group [ i ] , f_heal ) else
100142: LD_VAR 0 4
100146: PUSH
100147: LD_VAR 0 7
100151: ARRAY
100152: PPUSH
100153: LD_VAR 0 23
100157: PPUSH
100158: CALL_OW 113
100162: GO 100370
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
100164: LD_VAR 0 4
100168: PUSH
100169: LD_VAR 0 7
100173: ARRAY
100174: PPUSH
100175: CALL 47253 0 1
100179: PPUSH
100180: CALL_OW 256
100184: PUSH
100185: LD_INT 1000
100187: EQUAL
100188: IFFALSE 100207
// ComStop ( group [ i ] ) else
100190: LD_VAR 0 4
100194: PUSH
100195: LD_VAR 0 7
100199: ARRAY
100200: PPUSH
100201: CALL_OW 141
100205: GO 100370
// if not HasTask ( group [ i ] ) and to_heal then
100207: LD_VAR 0 4
100211: PUSH
100212: LD_VAR 0 7
100216: ARRAY
100217: PPUSH
100218: CALL_OW 314
100222: NOT
100223: PUSH
100224: LD_VAR 0 30
100228: AND
100229: IFFALSE 100370
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
100231: LD_ADDR_VAR 0 13
100235: PUSH
100236: LD_VAR 0 30
100240: PPUSH
100241: LD_INT 3
100243: PUSH
100244: LD_INT 54
100246: PUSH
100247: EMPTY
100248: LIST
100249: PUSH
100250: EMPTY
100251: LIST
100252: LIST
100253: PPUSH
100254: CALL_OW 72
100258: PPUSH
100259: LD_VAR 0 4
100263: PUSH
100264: LD_VAR 0 7
100268: ARRAY
100269: PPUSH
100270: CALL_OW 74
100274: ST_TO_ADDR
// if z then
100275: LD_VAR 0 13
100279: IFFALSE 100370
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
100281: LD_INT 91
100283: PUSH
100284: LD_VAR 0 13
100288: PUSH
100289: LD_INT 10
100291: PUSH
100292: EMPTY
100293: LIST
100294: LIST
100295: LIST
100296: PUSH
100297: LD_INT 81
100299: PUSH
100300: LD_VAR 0 13
100304: PPUSH
100305: CALL_OW 255
100309: PUSH
100310: EMPTY
100311: LIST
100312: LIST
100313: PUSH
100314: EMPTY
100315: LIST
100316: LIST
100317: PPUSH
100318: CALL_OW 69
100322: PUSH
100323: LD_INT 0
100325: EQUAL
100326: IFFALSE 100350
// ComHeal ( group [ i ] , z ) else
100328: LD_VAR 0 4
100332: PUSH
100333: LD_VAR 0 7
100337: ARRAY
100338: PPUSH
100339: LD_VAR 0 13
100343: PPUSH
100344: CALL_OW 128
100348: GO 100370
// ComMoveToArea ( group [ i ] , f_heal ) ;
100350: LD_VAR 0 4
100354: PUSH
100355: LD_VAR 0 7
100359: ARRAY
100360: PPUSH
100361: LD_VAR 0 23
100365: PPUSH
100366: CALL_OW 113
// end ; continue ;
100370: GO 99401
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
100372: LD_VAR 0 4
100376: PUSH
100377: LD_VAR 0 7
100381: ARRAY
100382: PPUSH
100383: CALL_OW 256
100387: PUSH
100388: LD_INT 700
100390: LESS
100391: PUSH
100392: LD_VAR 0 4
100396: PUSH
100397: LD_VAR 0 7
100401: ARRAY
100402: PUSH
100403: LD_VAR 0 30
100407: IN
100408: NOT
100409: AND
100410: IFFALSE 100434
// to_heal := to_heal union group [ i ] ;
100412: LD_ADDR_VAR 0 30
100416: PUSH
100417: LD_VAR 0 30
100421: PUSH
100422: LD_VAR 0 4
100426: PUSH
100427: LD_VAR 0 7
100431: ARRAY
100432: UNION
100433: ST_TO_ADDR
// if group [ i ] in to_heal then
100434: LD_VAR 0 4
100438: PUSH
100439: LD_VAR 0 7
100443: ARRAY
100444: PUSH
100445: LD_VAR 0 30
100449: IN
100450: IFFALSE 100559
// begin if GetLives ( group [ i ] ) = 1000 then
100452: LD_VAR 0 4
100456: PUSH
100457: LD_VAR 0 7
100461: ARRAY
100462: PPUSH
100463: CALL_OW 256
100467: PUSH
100468: LD_INT 1000
100470: EQUAL
100471: IFFALSE 100497
// to_heal := to_heal diff group [ i ] else
100473: LD_ADDR_VAR 0 30
100477: PUSH
100478: LD_VAR 0 30
100482: PUSH
100483: LD_VAR 0 4
100487: PUSH
100488: LD_VAR 0 7
100492: ARRAY
100493: DIFF
100494: ST_TO_ADDR
100495: GO 100559
// begin if not IsInArea ( group [ i ] , to_heal ) then
100497: LD_VAR 0 4
100501: PUSH
100502: LD_VAR 0 7
100506: ARRAY
100507: PPUSH
100508: LD_VAR 0 30
100512: PPUSH
100513: CALL_OW 308
100517: NOT
100518: IFFALSE 100542
// ComMoveToArea ( group [ i ] , f_heal ) else
100520: LD_VAR 0 4
100524: PUSH
100525: LD_VAR 0 7
100529: ARRAY
100530: PPUSH
100531: LD_VAR 0 23
100535: PPUSH
100536: CALL_OW 113
100540: GO 100557
// ComHold ( group [ i ] ) ;
100542: LD_VAR 0 4
100546: PUSH
100547: LD_VAR 0 7
100551: ARRAY
100552: PPUSH
100553: CALL_OW 140
// continue ;
100557: GO 99401
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
100559: LD_VAR 0 4
100563: PUSH
100564: LD_VAR 0 7
100568: ARRAY
100569: PPUSH
100570: LD_INT 10
100572: PPUSH
100573: CALL 45673 0 2
100577: NOT
100578: PUSH
100579: LD_VAR 0 16
100583: PUSH
100584: LD_VAR 0 7
100588: ARRAY
100589: PUSH
100590: EMPTY
100591: EQUAL
100592: NOT
100593: AND
100594: IFFALSE 100860
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
100596: LD_VAR 0 4
100600: PUSH
100601: LD_VAR 0 7
100605: ARRAY
100606: PPUSH
100607: CALL_OW 262
100611: PUSH
100612: LD_INT 1
100614: PUSH
100615: LD_INT 2
100617: PUSH
100618: EMPTY
100619: LIST
100620: LIST
100621: IN
100622: IFFALSE 100663
// if GetFuel ( group [ i ] ) < 10 then
100624: LD_VAR 0 4
100628: PUSH
100629: LD_VAR 0 7
100633: ARRAY
100634: PPUSH
100635: CALL_OW 261
100639: PUSH
100640: LD_INT 10
100642: LESS
100643: IFFALSE 100663
// SetFuel ( group [ i ] , 12 ) ;
100645: LD_VAR 0 4
100649: PUSH
100650: LD_VAR 0 7
100654: ARRAY
100655: PPUSH
100656: LD_INT 12
100658: PPUSH
100659: CALL_OW 240
// if units_path [ i ] then
100663: LD_VAR 0 16
100667: PUSH
100668: LD_VAR 0 7
100672: ARRAY
100673: IFFALSE 100858
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
100675: LD_VAR 0 4
100679: PUSH
100680: LD_VAR 0 7
100684: ARRAY
100685: PPUSH
100686: LD_VAR 0 16
100690: PUSH
100691: LD_VAR 0 7
100695: ARRAY
100696: PUSH
100697: LD_INT 1
100699: ARRAY
100700: PUSH
100701: LD_INT 1
100703: ARRAY
100704: PPUSH
100705: LD_VAR 0 16
100709: PUSH
100710: LD_VAR 0 7
100714: ARRAY
100715: PUSH
100716: LD_INT 1
100718: ARRAY
100719: PUSH
100720: LD_INT 2
100722: ARRAY
100723: PPUSH
100724: CALL_OW 297
100728: PUSH
100729: LD_INT 6
100731: GREATER
100732: IFFALSE 100807
// begin if not HasTask ( group [ i ] ) then
100734: LD_VAR 0 4
100738: PUSH
100739: LD_VAR 0 7
100743: ARRAY
100744: PPUSH
100745: CALL_OW 314
100749: NOT
100750: IFFALSE 100805
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
100752: LD_VAR 0 4
100756: PUSH
100757: LD_VAR 0 7
100761: ARRAY
100762: PPUSH
100763: LD_VAR 0 16
100767: PUSH
100768: LD_VAR 0 7
100772: ARRAY
100773: PUSH
100774: LD_INT 1
100776: ARRAY
100777: PUSH
100778: LD_INT 1
100780: ARRAY
100781: PPUSH
100782: LD_VAR 0 16
100786: PUSH
100787: LD_VAR 0 7
100791: ARRAY
100792: PUSH
100793: LD_INT 1
100795: ARRAY
100796: PUSH
100797: LD_INT 2
100799: ARRAY
100800: PPUSH
100801: CALL_OW 114
// end else
100805: GO 100858
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
100807: LD_ADDR_VAR 0 15
100811: PUSH
100812: LD_VAR 0 16
100816: PUSH
100817: LD_VAR 0 7
100821: ARRAY
100822: PPUSH
100823: LD_INT 1
100825: PPUSH
100826: CALL_OW 3
100830: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
100831: LD_ADDR_VAR 0 16
100835: PUSH
100836: LD_VAR 0 16
100840: PPUSH
100841: LD_VAR 0 7
100845: PPUSH
100846: LD_VAR 0 15
100850: PPUSH
100851: CALL_OW 1
100855: ST_TO_ADDR
// continue ;
100856: GO 99401
// end ; end ; end else
100858: GO 103522
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
100860: LD_ADDR_VAR 0 14
100864: PUSH
100865: LD_INT 81
100867: PUSH
100868: LD_VAR 0 4
100872: PUSH
100873: LD_VAR 0 7
100877: ARRAY
100878: PPUSH
100879: CALL_OW 255
100883: PUSH
100884: EMPTY
100885: LIST
100886: LIST
100887: PPUSH
100888: CALL_OW 69
100892: ST_TO_ADDR
// if not tmp then
100893: LD_VAR 0 14
100897: NOT
100898: IFFALSE 100902
// continue ;
100900: GO 99401
// if f_ignore_area then
100902: LD_VAR 0 17
100906: IFFALSE 100994
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
100908: LD_ADDR_VAR 0 15
100912: PUSH
100913: LD_VAR 0 14
100917: PPUSH
100918: LD_INT 3
100920: PUSH
100921: LD_INT 92
100923: PUSH
100924: LD_VAR 0 17
100928: PUSH
100929: LD_INT 1
100931: ARRAY
100932: PUSH
100933: LD_VAR 0 17
100937: PUSH
100938: LD_INT 2
100940: ARRAY
100941: PUSH
100942: LD_VAR 0 17
100946: PUSH
100947: LD_INT 3
100949: ARRAY
100950: PUSH
100951: EMPTY
100952: LIST
100953: LIST
100954: LIST
100955: LIST
100956: PUSH
100957: EMPTY
100958: LIST
100959: LIST
100960: PPUSH
100961: CALL_OW 72
100965: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100966: LD_VAR 0 14
100970: PUSH
100971: LD_VAR 0 15
100975: DIFF
100976: IFFALSE 100994
// tmp := tmp diff tmp2 ;
100978: LD_ADDR_VAR 0 14
100982: PUSH
100983: LD_VAR 0 14
100987: PUSH
100988: LD_VAR 0 15
100992: DIFF
100993: ST_TO_ADDR
// end ; if not f_murder then
100994: LD_VAR 0 20
100998: NOT
100999: IFFALSE 101057
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
101001: LD_ADDR_VAR 0 15
101005: PUSH
101006: LD_VAR 0 14
101010: PPUSH
101011: LD_INT 3
101013: PUSH
101014: LD_INT 50
101016: PUSH
101017: EMPTY
101018: LIST
101019: PUSH
101020: EMPTY
101021: LIST
101022: LIST
101023: PPUSH
101024: CALL_OW 72
101028: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101029: LD_VAR 0 14
101033: PUSH
101034: LD_VAR 0 15
101038: DIFF
101039: IFFALSE 101057
// tmp := tmp diff tmp2 ;
101041: LD_ADDR_VAR 0 14
101045: PUSH
101046: LD_VAR 0 14
101050: PUSH
101051: LD_VAR 0 15
101055: DIFF
101056: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
101057: LD_ADDR_VAR 0 14
101061: PUSH
101062: LD_VAR 0 4
101066: PUSH
101067: LD_VAR 0 7
101071: ARRAY
101072: PPUSH
101073: LD_VAR 0 14
101077: PPUSH
101078: LD_INT 1
101080: PPUSH
101081: LD_INT 1
101083: PPUSH
101084: CALL 18983 0 4
101088: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
101089: LD_VAR 0 4
101093: PUSH
101094: LD_VAR 0 7
101098: ARRAY
101099: PPUSH
101100: CALL_OW 257
101104: PUSH
101105: LD_INT 1
101107: EQUAL
101108: IFFALSE 101556
// begin if WantPlant ( group [ i ] ) then
101110: LD_VAR 0 4
101114: PUSH
101115: LD_VAR 0 7
101119: ARRAY
101120: PPUSH
101121: CALL 18484 0 1
101125: IFFALSE 101129
// continue ;
101127: GO 99401
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
101129: LD_VAR 0 18
101133: PUSH
101134: LD_VAR 0 4
101138: PUSH
101139: LD_VAR 0 7
101143: ARRAY
101144: PPUSH
101145: CALL_OW 310
101149: NOT
101150: AND
101151: PUSH
101152: LD_VAR 0 14
101156: PUSH
101157: LD_INT 1
101159: ARRAY
101160: PUSH
101161: LD_VAR 0 14
101165: PPUSH
101166: LD_INT 21
101168: PUSH
101169: LD_INT 2
101171: PUSH
101172: EMPTY
101173: LIST
101174: LIST
101175: PUSH
101176: LD_INT 58
101178: PUSH
101179: EMPTY
101180: LIST
101181: PUSH
101182: EMPTY
101183: LIST
101184: LIST
101185: PPUSH
101186: CALL_OW 72
101190: IN
101191: AND
101192: IFFALSE 101228
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
101194: LD_VAR 0 4
101198: PUSH
101199: LD_VAR 0 7
101203: ARRAY
101204: PPUSH
101205: LD_VAR 0 14
101209: PUSH
101210: LD_INT 1
101212: ARRAY
101213: PPUSH
101214: CALL_OW 120
// attacking := true ;
101218: LD_ADDR_VAR 0 29
101222: PUSH
101223: LD_INT 1
101225: ST_TO_ADDR
// continue ;
101226: GO 99401
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
101228: LD_VAR 0 26
101232: PUSH
101233: LD_VAR 0 4
101237: PUSH
101238: LD_VAR 0 7
101242: ARRAY
101243: PPUSH
101244: CALL_OW 257
101248: PUSH
101249: LD_INT 1
101251: EQUAL
101252: AND
101253: PUSH
101254: LD_VAR 0 4
101258: PUSH
101259: LD_VAR 0 7
101263: ARRAY
101264: PPUSH
101265: CALL_OW 256
101269: PUSH
101270: LD_INT 800
101272: LESS
101273: AND
101274: PUSH
101275: LD_VAR 0 4
101279: PUSH
101280: LD_VAR 0 7
101284: ARRAY
101285: PPUSH
101286: CALL_OW 318
101290: NOT
101291: AND
101292: IFFALSE 101309
// ComCrawl ( group [ i ] ) ;
101294: LD_VAR 0 4
101298: PUSH
101299: LD_VAR 0 7
101303: ARRAY
101304: PPUSH
101305: CALL_OW 137
// if f_mines then
101309: LD_VAR 0 21
101313: IFFALSE 101556
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
101315: LD_VAR 0 14
101319: PUSH
101320: LD_INT 1
101322: ARRAY
101323: PPUSH
101324: CALL_OW 247
101328: PUSH
101329: LD_INT 3
101331: EQUAL
101332: PUSH
101333: LD_VAR 0 14
101337: PUSH
101338: LD_INT 1
101340: ARRAY
101341: PUSH
101342: LD_VAR 0 27
101346: IN
101347: NOT
101348: AND
101349: IFFALSE 101556
// begin x := GetX ( tmp [ 1 ] ) ;
101351: LD_ADDR_VAR 0 10
101355: PUSH
101356: LD_VAR 0 14
101360: PUSH
101361: LD_INT 1
101363: ARRAY
101364: PPUSH
101365: CALL_OW 250
101369: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
101370: LD_ADDR_VAR 0 11
101374: PUSH
101375: LD_VAR 0 14
101379: PUSH
101380: LD_INT 1
101382: ARRAY
101383: PPUSH
101384: CALL_OW 251
101388: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
101389: LD_ADDR_VAR 0 12
101393: PUSH
101394: LD_VAR 0 4
101398: PUSH
101399: LD_VAR 0 7
101403: ARRAY
101404: PPUSH
101405: CALL 45758 0 1
101409: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
101410: LD_VAR 0 4
101414: PUSH
101415: LD_VAR 0 7
101419: ARRAY
101420: PPUSH
101421: LD_VAR 0 10
101425: PPUSH
101426: LD_VAR 0 11
101430: PPUSH
101431: LD_VAR 0 14
101435: PUSH
101436: LD_INT 1
101438: ARRAY
101439: PPUSH
101440: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
101444: LD_VAR 0 4
101448: PUSH
101449: LD_VAR 0 7
101453: ARRAY
101454: PPUSH
101455: LD_VAR 0 10
101459: PPUSH
101460: LD_VAR 0 12
101464: PPUSH
101465: LD_INT 7
101467: PPUSH
101468: CALL_OW 272
101472: PPUSH
101473: LD_VAR 0 11
101477: PPUSH
101478: LD_VAR 0 12
101482: PPUSH
101483: LD_INT 7
101485: PPUSH
101486: CALL_OW 273
101490: PPUSH
101491: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
101495: LD_VAR 0 4
101499: PUSH
101500: LD_VAR 0 7
101504: ARRAY
101505: PPUSH
101506: LD_INT 71
101508: PPUSH
101509: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
101513: LD_ADDR_VAR 0 27
101517: PUSH
101518: LD_VAR 0 27
101522: PPUSH
101523: LD_VAR 0 27
101527: PUSH
101528: LD_INT 1
101530: PLUS
101531: PPUSH
101532: LD_VAR 0 14
101536: PUSH
101537: LD_INT 1
101539: ARRAY
101540: PPUSH
101541: CALL_OW 1
101545: ST_TO_ADDR
// attacking := true ;
101546: LD_ADDR_VAR 0 29
101550: PUSH
101551: LD_INT 1
101553: ST_TO_ADDR
// continue ;
101554: GO 99401
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
101556: LD_VAR 0 4
101560: PUSH
101561: LD_VAR 0 7
101565: ARRAY
101566: PPUSH
101567: CALL_OW 257
101571: PUSH
101572: LD_INT 17
101574: EQUAL
101575: PUSH
101576: LD_VAR 0 4
101580: PUSH
101581: LD_VAR 0 7
101585: ARRAY
101586: PPUSH
101587: CALL_OW 110
101591: PUSH
101592: LD_INT 71
101594: EQUAL
101595: NOT
101596: AND
101597: IFFALSE 101743
// begin attacking := false ;
101599: LD_ADDR_VAR 0 29
101603: PUSH
101604: LD_INT 0
101606: ST_TO_ADDR
// k := 5 ;
101607: LD_ADDR_VAR 0 9
101611: PUSH
101612: LD_INT 5
101614: ST_TO_ADDR
// if tmp < k then
101615: LD_VAR 0 14
101619: PUSH
101620: LD_VAR 0 9
101624: LESS
101625: IFFALSE 101637
// k := tmp ;
101627: LD_ADDR_VAR 0 9
101631: PUSH
101632: LD_VAR 0 14
101636: ST_TO_ADDR
// for j = 1 to k do
101637: LD_ADDR_VAR 0 8
101641: PUSH
101642: DOUBLE
101643: LD_INT 1
101645: DEC
101646: ST_TO_ADDR
101647: LD_VAR 0 9
101651: PUSH
101652: FOR_TO
101653: IFFALSE 101741
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
101655: LD_VAR 0 14
101659: PUSH
101660: LD_VAR 0 8
101664: ARRAY
101665: PUSH
101666: LD_VAR 0 14
101670: PPUSH
101671: LD_INT 58
101673: PUSH
101674: EMPTY
101675: LIST
101676: PPUSH
101677: CALL_OW 72
101681: IN
101682: NOT
101683: IFFALSE 101739
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101685: LD_VAR 0 4
101689: PUSH
101690: LD_VAR 0 7
101694: ARRAY
101695: PPUSH
101696: LD_VAR 0 14
101700: PUSH
101701: LD_VAR 0 8
101705: ARRAY
101706: PPUSH
101707: CALL_OW 115
// attacking := true ;
101711: LD_ADDR_VAR 0 29
101715: PUSH
101716: LD_INT 1
101718: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
101719: LD_VAR 0 4
101723: PUSH
101724: LD_VAR 0 7
101728: ARRAY
101729: PPUSH
101730: LD_INT 71
101732: PPUSH
101733: CALL_OW 109
// continue ;
101737: GO 101652
// end ; end ;
101739: GO 101652
101741: POP
101742: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
101743: LD_VAR 0 4
101747: PUSH
101748: LD_VAR 0 7
101752: ARRAY
101753: PPUSH
101754: CALL_OW 257
101758: PUSH
101759: LD_INT 8
101761: EQUAL
101762: PUSH
101763: LD_VAR 0 4
101767: PUSH
101768: LD_VAR 0 7
101772: ARRAY
101773: PPUSH
101774: CALL_OW 264
101778: PUSH
101779: LD_INT 28
101781: PUSH
101782: LD_INT 45
101784: PUSH
101785: LD_INT 7
101787: PUSH
101788: LD_INT 47
101790: PUSH
101791: EMPTY
101792: LIST
101793: LIST
101794: LIST
101795: LIST
101796: IN
101797: OR
101798: IFFALSE 102054
// begin attacking := false ;
101800: LD_ADDR_VAR 0 29
101804: PUSH
101805: LD_INT 0
101807: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
101808: LD_VAR 0 14
101812: PUSH
101813: LD_INT 1
101815: ARRAY
101816: PPUSH
101817: CALL_OW 266
101821: PUSH
101822: LD_INT 32
101824: PUSH
101825: LD_INT 31
101827: PUSH
101828: LD_INT 33
101830: PUSH
101831: LD_INT 4
101833: PUSH
101834: LD_INT 5
101836: PUSH
101837: EMPTY
101838: LIST
101839: LIST
101840: LIST
101841: LIST
101842: LIST
101843: IN
101844: IFFALSE 102030
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
101846: LD_ADDR_VAR 0 9
101850: PUSH
101851: LD_VAR 0 14
101855: PUSH
101856: LD_INT 1
101858: ARRAY
101859: PPUSH
101860: CALL_OW 266
101864: PPUSH
101865: LD_VAR 0 14
101869: PUSH
101870: LD_INT 1
101872: ARRAY
101873: PPUSH
101874: CALL_OW 250
101878: PPUSH
101879: LD_VAR 0 14
101883: PUSH
101884: LD_INT 1
101886: ARRAY
101887: PPUSH
101888: CALL_OW 251
101892: PPUSH
101893: LD_VAR 0 14
101897: PUSH
101898: LD_INT 1
101900: ARRAY
101901: PPUSH
101902: CALL_OW 254
101906: PPUSH
101907: LD_VAR 0 14
101911: PUSH
101912: LD_INT 1
101914: ARRAY
101915: PPUSH
101916: CALL_OW 248
101920: PPUSH
101921: LD_INT 0
101923: PPUSH
101924: CALL 27128 0 6
101928: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
101929: LD_ADDR_VAR 0 8
101933: PUSH
101934: LD_VAR 0 4
101938: PUSH
101939: LD_VAR 0 7
101943: ARRAY
101944: PPUSH
101945: LD_VAR 0 9
101949: PPUSH
101950: CALL 45798 0 2
101954: ST_TO_ADDR
// if j then
101955: LD_VAR 0 8
101959: IFFALSE 102028
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
101961: LD_VAR 0 8
101965: PUSH
101966: LD_INT 1
101968: ARRAY
101969: PPUSH
101970: LD_VAR 0 8
101974: PUSH
101975: LD_INT 2
101977: ARRAY
101978: PPUSH
101979: CALL_OW 488
101983: IFFALSE 102028
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
101985: LD_VAR 0 4
101989: PUSH
101990: LD_VAR 0 7
101994: ARRAY
101995: PPUSH
101996: LD_VAR 0 8
102000: PUSH
102001: LD_INT 1
102003: ARRAY
102004: PPUSH
102005: LD_VAR 0 8
102009: PUSH
102010: LD_INT 2
102012: ARRAY
102013: PPUSH
102014: CALL_OW 116
// attacking := true ;
102018: LD_ADDR_VAR 0 29
102022: PUSH
102023: LD_INT 1
102025: ST_TO_ADDR
// continue ;
102026: GO 99401
// end ; end else
102028: GO 102054
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102030: LD_VAR 0 4
102034: PUSH
102035: LD_VAR 0 7
102039: ARRAY
102040: PPUSH
102041: LD_VAR 0 14
102045: PUSH
102046: LD_INT 1
102048: ARRAY
102049: PPUSH
102050: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
102054: LD_VAR 0 4
102058: PUSH
102059: LD_VAR 0 7
102063: ARRAY
102064: PPUSH
102065: CALL_OW 265
102069: PUSH
102070: LD_INT 11
102072: EQUAL
102073: IFFALSE 102351
// begin k := 10 ;
102075: LD_ADDR_VAR 0 9
102079: PUSH
102080: LD_INT 10
102082: ST_TO_ADDR
// x := 0 ;
102083: LD_ADDR_VAR 0 10
102087: PUSH
102088: LD_INT 0
102090: ST_TO_ADDR
// if tmp < k then
102091: LD_VAR 0 14
102095: PUSH
102096: LD_VAR 0 9
102100: LESS
102101: IFFALSE 102113
// k := tmp ;
102103: LD_ADDR_VAR 0 9
102107: PUSH
102108: LD_VAR 0 14
102112: ST_TO_ADDR
// for j = k downto 1 do
102113: LD_ADDR_VAR 0 8
102117: PUSH
102118: DOUBLE
102119: LD_VAR 0 9
102123: INC
102124: ST_TO_ADDR
102125: LD_INT 1
102127: PUSH
102128: FOR_DOWNTO
102129: IFFALSE 102204
// begin if GetType ( tmp [ j ] ) = unit_human then
102131: LD_VAR 0 14
102135: PUSH
102136: LD_VAR 0 8
102140: ARRAY
102141: PPUSH
102142: CALL_OW 247
102146: PUSH
102147: LD_INT 1
102149: EQUAL
102150: IFFALSE 102202
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
102152: LD_VAR 0 4
102156: PUSH
102157: LD_VAR 0 7
102161: ARRAY
102162: PPUSH
102163: LD_VAR 0 14
102167: PUSH
102168: LD_VAR 0 8
102172: ARRAY
102173: PPUSH
102174: CALL 46069 0 2
// x := tmp [ j ] ;
102178: LD_ADDR_VAR 0 10
102182: PUSH
102183: LD_VAR 0 14
102187: PUSH
102188: LD_VAR 0 8
102192: ARRAY
102193: ST_TO_ADDR
// attacking := true ;
102194: LD_ADDR_VAR 0 29
102198: PUSH
102199: LD_INT 1
102201: ST_TO_ADDR
// end ; end ;
102202: GO 102128
102204: POP
102205: POP
// if not x then
102206: LD_VAR 0 10
102210: NOT
102211: IFFALSE 102351
// begin attacking := true ;
102213: LD_ADDR_VAR 0 29
102217: PUSH
102218: LD_INT 1
102220: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
102221: LD_VAR 0 4
102225: PUSH
102226: LD_VAR 0 7
102230: ARRAY
102231: PPUSH
102232: CALL_OW 250
102236: PPUSH
102237: LD_VAR 0 4
102241: PUSH
102242: LD_VAR 0 7
102246: ARRAY
102247: PPUSH
102248: CALL_OW 251
102252: PPUSH
102253: CALL_OW 546
102257: PUSH
102258: LD_INT 2
102260: ARRAY
102261: PUSH
102262: LD_VAR 0 14
102266: PUSH
102267: LD_INT 1
102269: ARRAY
102270: PPUSH
102271: CALL_OW 250
102275: PPUSH
102276: LD_VAR 0 14
102280: PUSH
102281: LD_INT 1
102283: ARRAY
102284: PPUSH
102285: CALL_OW 251
102289: PPUSH
102290: CALL_OW 546
102294: PUSH
102295: LD_INT 2
102297: ARRAY
102298: EQUAL
102299: IFFALSE 102327
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
102301: LD_VAR 0 4
102305: PUSH
102306: LD_VAR 0 7
102310: ARRAY
102311: PPUSH
102312: LD_VAR 0 14
102316: PUSH
102317: LD_INT 1
102319: ARRAY
102320: PPUSH
102321: CALL 46069 0 2
102325: GO 102351
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102327: LD_VAR 0 4
102331: PUSH
102332: LD_VAR 0 7
102336: ARRAY
102337: PPUSH
102338: LD_VAR 0 14
102342: PUSH
102343: LD_INT 1
102345: ARRAY
102346: PPUSH
102347: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
102351: LD_VAR 0 4
102355: PUSH
102356: LD_VAR 0 7
102360: ARRAY
102361: PPUSH
102362: CALL_OW 264
102366: PUSH
102367: LD_INT 29
102369: EQUAL
102370: IFFALSE 102736
// begin if WantsToAttack ( group [ i ] ) in bombed then
102372: LD_VAR 0 4
102376: PUSH
102377: LD_VAR 0 7
102381: ARRAY
102382: PPUSH
102383: CALL_OW 319
102387: PUSH
102388: LD_VAR 0 28
102392: IN
102393: IFFALSE 102397
// continue ;
102395: GO 99401
// k := 8 ;
102397: LD_ADDR_VAR 0 9
102401: PUSH
102402: LD_INT 8
102404: ST_TO_ADDR
// x := 0 ;
102405: LD_ADDR_VAR 0 10
102409: PUSH
102410: LD_INT 0
102412: ST_TO_ADDR
// if tmp < k then
102413: LD_VAR 0 14
102417: PUSH
102418: LD_VAR 0 9
102422: LESS
102423: IFFALSE 102435
// k := tmp ;
102425: LD_ADDR_VAR 0 9
102429: PUSH
102430: LD_VAR 0 14
102434: ST_TO_ADDR
// for j = 1 to k do
102435: LD_ADDR_VAR 0 8
102439: PUSH
102440: DOUBLE
102441: LD_INT 1
102443: DEC
102444: ST_TO_ADDR
102445: LD_VAR 0 9
102449: PUSH
102450: FOR_TO
102451: IFFALSE 102583
// begin if GetType ( tmp [ j ] ) = unit_building then
102453: LD_VAR 0 14
102457: PUSH
102458: LD_VAR 0 8
102462: ARRAY
102463: PPUSH
102464: CALL_OW 247
102468: PUSH
102469: LD_INT 3
102471: EQUAL
102472: IFFALSE 102581
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
102474: LD_VAR 0 14
102478: PUSH
102479: LD_VAR 0 8
102483: ARRAY
102484: PUSH
102485: LD_VAR 0 28
102489: IN
102490: NOT
102491: PUSH
102492: LD_VAR 0 14
102496: PUSH
102497: LD_VAR 0 8
102501: ARRAY
102502: PPUSH
102503: CALL_OW 313
102507: AND
102508: IFFALSE 102581
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102510: LD_VAR 0 4
102514: PUSH
102515: LD_VAR 0 7
102519: ARRAY
102520: PPUSH
102521: LD_VAR 0 14
102525: PUSH
102526: LD_VAR 0 8
102530: ARRAY
102531: PPUSH
102532: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
102536: LD_ADDR_VAR 0 28
102540: PUSH
102541: LD_VAR 0 28
102545: PPUSH
102546: LD_VAR 0 28
102550: PUSH
102551: LD_INT 1
102553: PLUS
102554: PPUSH
102555: LD_VAR 0 14
102559: PUSH
102560: LD_VAR 0 8
102564: ARRAY
102565: PPUSH
102566: CALL_OW 1
102570: ST_TO_ADDR
// attacking := true ;
102571: LD_ADDR_VAR 0 29
102575: PUSH
102576: LD_INT 1
102578: ST_TO_ADDR
// break ;
102579: GO 102583
// end ; end ;
102581: GO 102450
102583: POP
102584: POP
// if not attacking and f_attack_depot then
102585: LD_VAR 0 29
102589: NOT
102590: PUSH
102591: LD_VAR 0 25
102595: AND
102596: IFFALSE 102691
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
102598: LD_ADDR_VAR 0 13
102602: PUSH
102603: LD_VAR 0 14
102607: PPUSH
102608: LD_INT 2
102610: PUSH
102611: LD_INT 30
102613: PUSH
102614: LD_INT 0
102616: PUSH
102617: EMPTY
102618: LIST
102619: LIST
102620: PUSH
102621: LD_INT 30
102623: PUSH
102624: LD_INT 1
102626: PUSH
102627: EMPTY
102628: LIST
102629: LIST
102630: PUSH
102631: EMPTY
102632: LIST
102633: LIST
102634: LIST
102635: PPUSH
102636: CALL_OW 72
102640: ST_TO_ADDR
// if z then
102641: LD_VAR 0 13
102645: IFFALSE 102691
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
102647: LD_VAR 0 4
102651: PUSH
102652: LD_VAR 0 7
102656: ARRAY
102657: PPUSH
102658: LD_VAR 0 13
102662: PPUSH
102663: LD_VAR 0 4
102667: PUSH
102668: LD_VAR 0 7
102672: ARRAY
102673: PPUSH
102674: CALL_OW 74
102678: PPUSH
102679: CALL_OW 115
// attacking := true ;
102683: LD_ADDR_VAR 0 29
102687: PUSH
102688: LD_INT 1
102690: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
102691: LD_VAR 0 4
102695: PUSH
102696: LD_VAR 0 7
102700: ARRAY
102701: PPUSH
102702: CALL_OW 256
102706: PUSH
102707: LD_INT 500
102709: LESS
102710: IFFALSE 102736
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102712: LD_VAR 0 4
102716: PUSH
102717: LD_VAR 0 7
102721: ARRAY
102722: PPUSH
102723: LD_VAR 0 14
102727: PUSH
102728: LD_INT 1
102730: ARRAY
102731: PPUSH
102732: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
102736: LD_VAR 0 4
102740: PUSH
102741: LD_VAR 0 7
102745: ARRAY
102746: PPUSH
102747: CALL_OW 264
102751: PUSH
102752: LD_INT 49
102754: EQUAL
102755: IFFALSE 102876
// begin if not HasTask ( group [ i ] ) then
102757: LD_VAR 0 4
102761: PUSH
102762: LD_VAR 0 7
102766: ARRAY
102767: PPUSH
102768: CALL_OW 314
102772: NOT
102773: IFFALSE 102876
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
102775: LD_ADDR_VAR 0 9
102779: PUSH
102780: LD_INT 81
102782: PUSH
102783: LD_VAR 0 4
102787: PUSH
102788: LD_VAR 0 7
102792: ARRAY
102793: PPUSH
102794: CALL_OW 255
102798: PUSH
102799: EMPTY
102800: LIST
102801: LIST
102802: PPUSH
102803: CALL_OW 69
102807: PPUSH
102808: LD_VAR 0 4
102812: PUSH
102813: LD_VAR 0 7
102817: ARRAY
102818: PPUSH
102819: CALL_OW 74
102823: ST_TO_ADDR
// if k then
102824: LD_VAR 0 9
102828: IFFALSE 102876
// if GetDistUnits ( group [ i ] , k ) > 10 then
102830: LD_VAR 0 4
102834: PUSH
102835: LD_VAR 0 7
102839: ARRAY
102840: PPUSH
102841: LD_VAR 0 9
102845: PPUSH
102846: CALL_OW 296
102850: PUSH
102851: LD_INT 10
102853: GREATER
102854: IFFALSE 102876
// ComMoveUnit ( group [ i ] , k ) ;
102856: LD_VAR 0 4
102860: PUSH
102861: LD_VAR 0 7
102865: ARRAY
102866: PPUSH
102867: LD_VAR 0 9
102871: PPUSH
102872: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102876: LD_VAR 0 4
102880: PUSH
102881: LD_VAR 0 7
102885: ARRAY
102886: PPUSH
102887: CALL_OW 256
102891: PUSH
102892: LD_INT 250
102894: LESS
102895: PUSH
102896: LD_VAR 0 4
102900: PUSH
102901: LD_VAR 0 7
102905: ARRAY
102906: PUSH
102907: LD_INT 21
102909: PUSH
102910: LD_INT 2
102912: PUSH
102913: EMPTY
102914: LIST
102915: LIST
102916: PUSH
102917: LD_INT 23
102919: PUSH
102920: LD_INT 2
102922: PUSH
102923: EMPTY
102924: LIST
102925: LIST
102926: PUSH
102927: EMPTY
102928: LIST
102929: LIST
102930: PPUSH
102931: CALL_OW 69
102935: IN
102936: AND
102937: IFFALSE 103062
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
102939: LD_ADDR_VAR 0 9
102943: PUSH
102944: LD_OWVAR 3
102948: PUSH
102949: LD_VAR 0 4
102953: PUSH
102954: LD_VAR 0 7
102958: ARRAY
102959: DIFF
102960: PPUSH
102961: LD_VAR 0 4
102965: PUSH
102966: LD_VAR 0 7
102970: ARRAY
102971: PPUSH
102972: CALL_OW 74
102976: ST_TO_ADDR
// if not k then
102977: LD_VAR 0 9
102981: NOT
102982: IFFALSE 102986
// continue ;
102984: GO 99401
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
102986: LD_VAR 0 9
102990: PUSH
102991: LD_INT 81
102993: PUSH
102994: LD_VAR 0 4
102998: PUSH
102999: LD_VAR 0 7
103003: ARRAY
103004: PPUSH
103005: CALL_OW 255
103009: PUSH
103010: EMPTY
103011: LIST
103012: LIST
103013: PPUSH
103014: CALL_OW 69
103018: IN
103019: PUSH
103020: LD_VAR 0 9
103024: PPUSH
103025: LD_VAR 0 4
103029: PUSH
103030: LD_VAR 0 7
103034: ARRAY
103035: PPUSH
103036: CALL_OW 296
103040: PUSH
103041: LD_INT 5
103043: LESS
103044: AND
103045: IFFALSE 103062
// ComAutodestruct ( group [ i ] ) ;
103047: LD_VAR 0 4
103051: PUSH
103052: LD_VAR 0 7
103056: ARRAY
103057: PPUSH
103058: CALL 45967 0 1
// end ; if f_attack_depot then
103062: LD_VAR 0 25
103066: IFFALSE 103178
// begin k := 6 ;
103068: LD_ADDR_VAR 0 9
103072: PUSH
103073: LD_INT 6
103075: ST_TO_ADDR
// if tmp < k then
103076: LD_VAR 0 14
103080: PUSH
103081: LD_VAR 0 9
103085: LESS
103086: IFFALSE 103098
// k := tmp ;
103088: LD_ADDR_VAR 0 9
103092: PUSH
103093: LD_VAR 0 14
103097: ST_TO_ADDR
// for j = 1 to k do
103098: LD_ADDR_VAR 0 8
103102: PUSH
103103: DOUBLE
103104: LD_INT 1
103106: DEC
103107: ST_TO_ADDR
103108: LD_VAR 0 9
103112: PUSH
103113: FOR_TO
103114: IFFALSE 103176
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
103116: LD_VAR 0 8
103120: PPUSH
103121: CALL_OW 266
103125: PUSH
103126: LD_INT 0
103128: PUSH
103129: LD_INT 1
103131: PUSH
103132: EMPTY
103133: LIST
103134: LIST
103135: IN
103136: IFFALSE 103174
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103138: LD_VAR 0 4
103142: PUSH
103143: LD_VAR 0 7
103147: ARRAY
103148: PPUSH
103149: LD_VAR 0 14
103153: PUSH
103154: LD_VAR 0 8
103158: ARRAY
103159: PPUSH
103160: CALL_OW 115
// attacking := true ;
103164: LD_ADDR_VAR 0 29
103168: PUSH
103169: LD_INT 1
103171: ST_TO_ADDR
// break ;
103172: GO 103176
// end ;
103174: GO 103113
103176: POP
103177: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
103178: LD_VAR 0 4
103182: PUSH
103183: LD_VAR 0 7
103187: ARRAY
103188: PPUSH
103189: CALL_OW 302
103193: PUSH
103194: LD_VAR 0 29
103198: NOT
103199: AND
103200: IFFALSE 103522
// begin if GetTag ( group [ i ] ) = 71 then
103202: LD_VAR 0 4
103206: PUSH
103207: LD_VAR 0 7
103211: ARRAY
103212: PPUSH
103213: CALL_OW 110
103217: PUSH
103218: LD_INT 71
103220: EQUAL
103221: IFFALSE 103262
// begin if HasTask ( group [ i ] ) then
103223: LD_VAR 0 4
103227: PUSH
103228: LD_VAR 0 7
103232: ARRAY
103233: PPUSH
103234: CALL_OW 314
103238: IFFALSE 103244
// continue else
103240: GO 99401
103242: GO 103262
// SetTag ( group [ i ] , 0 ) ;
103244: LD_VAR 0 4
103248: PUSH
103249: LD_VAR 0 7
103253: ARRAY
103254: PPUSH
103255: LD_INT 0
103257: PPUSH
103258: CALL_OW 109
// end ; k := 8 ;
103262: LD_ADDR_VAR 0 9
103266: PUSH
103267: LD_INT 8
103269: ST_TO_ADDR
// x := 0 ;
103270: LD_ADDR_VAR 0 10
103274: PUSH
103275: LD_INT 0
103277: ST_TO_ADDR
// if tmp < k then
103278: LD_VAR 0 14
103282: PUSH
103283: LD_VAR 0 9
103287: LESS
103288: IFFALSE 103300
// k := tmp ;
103290: LD_ADDR_VAR 0 9
103294: PUSH
103295: LD_VAR 0 14
103299: ST_TO_ADDR
// for j = 1 to k do
103300: LD_ADDR_VAR 0 8
103304: PUSH
103305: DOUBLE
103306: LD_INT 1
103308: DEC
103309: ST_TO_ADDR
103310: LD_VAR 0 9
103314: PUSH
103315: FOR_TO
103316: IFFALSE 103414
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
103318: LD_VAR 0 14
103322: PUSH
103323: LD_VAR 0 8
103327: ARRAY
103328: PPUSH
103329: CALL_OW 247
103333: PUSH
103334: LD_INT 1
103336: EQUAL
103337: PUSH
103338: LD_VAR 0 14
103342: PUSH
103343: LD_VAR 0 8
103347: ARRAY
103348: PPUSH
103349: CALL_OW 256
103353: PUSH
103354: LD_INT 250
103356: LESS
103357: PUSH
103358: LD_VAR 0 20
103362: AND
103363: PUSH
103364: LD_VAR 0 20
103368: NOT
103369: PUSH
103370: LD_VAR 0 14
103374: PUSH
103375: LD_VAR 0 8
103379: ARRAY
103380: PPUSH
103381: CALL_OW 256
103385: PUSH
103386: LD_INT 250
103388: GREATEREQUAL
103389: AND
103390: OR
103391: AND
103392: IFFALSE 103412
// begin x := tmp [ j ] ;
103394: LD_ADDR_VAR 0 10
103398: PUSH
103399: LD_VAR 0 14
103403: PUSH
103404: LD_VAR 0 8
103408: ARRAY
103409: ST_TO_ADDR
// break ;
103410: GO 103414
// end ;
103412: GO 103315
103414: POP
103415: POP
// if x then
103416: LD_VAR 0 10
103420: IFFALSE 103444
// ComAttackUnit ( group [ i ] , x ) else
103422: LD_VAR 0 4
103426: PUSH
103427: LD_VAR 0 7
103431: ARRAY
103432: PPUSH
103433: LD_VAR 0 10
103437: PPUSH
103438: CALL_OW 115
103442: GO 103468
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103444: LD_VAR 0 4
103448: PUSH
103449: LD_VAR 0 7
103453: ARRAY
103454: PPUSH
103455: LD_VAR 0 14
103459: PUSH
103460: LD_INT 1
103462: ARRAY
103463: PPUSH
103464: CALL_OW 115
// if not HasTask ( group [ i ] ) then
103468: LD_VAR 0 4
103472: PUSH
103473: LD_VAR 0 7
103477: ARRAY
103478: PPUSH
103479: CALL_OW 314
103483: NOT
103484: IFFALSE 103522
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
103486: LD_VAR 0 4
103490: PUSH
103491: LD_VAR 0 7
103495: ARRAY
103496: PPUSH
103497: LD_VAR 0 14
103501: PPUSH
103502: LD_VAR 0 4
103506: PUSH
103507: LD_VAR 0 7
103511: ARRAY
103512: PPUSH
103513: CALL_OW 74
103517: PPUSH
103518: CALL_OW 115
// end ; end ; end ;
103522: GO 99401
103524: POP
103525: POP
// wait ( 0 0$2 ) ;
103526: LD_INT 70
103528: PPUSH
103529: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
103533: LD_VAR 0 4
103537: NOT
103538: PUSH
103539: LD_VAR 0 4
103543: PUSH
103544: EMPTY
103545: EQUAL
103546: OR
103547: PUSH
103548: LD_INT 81
103550: PUSH
103551: LD_VAR 0 35
103555: PUSH
103556: EMPTY
103557: LIST
103558: LIST
103559: PPUSH
103560: CALL_OW 69
103564: NOT
103565: OR
103566: IFFALSE 99386
// end ;
103568: LD_VAR 0 2
103572: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
103573: LD_INT 0
103575: PPUSH
103576: PPUSH
103577: PPUSH
103578: PPUSH
103579: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
103580: LD_VAR 0 1
103584: NOT
103585: PUSH
103586: LD_EXP 68
103590: PUSH
103591: LD_VAR 0 1
103595: ARRAY
103596: NOT
103597: OR
103598: PUSH
103599: LD_VAR 0 2
103603: NOT
103604: OR
103605: PUSH
103606: LD_VAR 0 3
103610: NOT
103611: OR
103612: IFFALSE 103616
// exit ;
103614: GO 104129
// side := mc_sides [ base ] ;
103616: LD_ADDR_VAR 0 6
103620: PUSH
103621: LD_EXP 94
103625: PUSH
103626: LD_VAR 0 1
103630: ARRAY
103631: ST_TO_ADDR
// if not side then
103632: LD_VAR 0 6
103636: NOT
103637: IFFALSE 103641
// exit ;
103639: GO 104129
// for i in solds do
103641: LD_ADDR_VAR 0 7
103645: PUSH
103646: LD_VAR 0 2
103650: PUSH
103651: FOR_IN
103652: IFFALSE 103713
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
103654: LD_VAR 0 7
103658: PPUSH
103659: CALL_OW 310
103663: PPUSH
103664: CALL_OW 266
103668: PUSH
103669: LD_INT 32
103671: PUSH
103672: LD_INT 31
103674: PUSH
103675: EMPTY
103676: LIST
103677: LIST
103678: IN
103679: IFFALSE 103699
// solds := solds diff i else
103681: LD_ADDR_VAR 0 2
103685: PUSH
103686: LD_VAR 0 2
103690: PUSH
103691: LD_VAR 0 7
103695: DIFF
103696: ST_TO_ADDR
103697: GO 103711
// SetTag ( i , 18 ) ;
103699: LD_VAR 0 7
103703: PPUSH
103704: LD_INT 18
103706: PPUSH
103707: CALL_OW 109
103711: GO 103651
103713: POP
103714: POP
// if not solds then
103715: LD_VAR 0 2
103719: NOT
103720: IFFALSE 103724
// exit ;
103722: GO 104129
// repeat wait ( 0 0$2 ) ;
103724: LD_INT 70
103726: PPUSH
103727: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
103731: LD_ADDR_VAR 0 5
103735: PUSH
103736: LD_VAR 0 6
103740: PPUSH
103741: LD_VAR 0 3
103745: PPUSH
103746: CALL 15349 0 2
103750: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
103751: LD_EXP 68
103755: PUSH
103756: LD_VAR 0 1
103760: ARRAY
103761: NOT
103762: PUSH
103763: LD_EXP 68
103767: PUSH
103768: LD_VAR 0 1
103772: ARRAY
103773: PUSH
103774: EMPTY
103775: EQUAL
103776: OR
103777: IFFALSE 103814
// begin for i in solds do
103779: LD_ADDR_VAR 0 7
103783: PUSH
103784: LD_VAR 0 2
103788: PUSH
103789: FOR_IN
103790: IFFALSE 103803
// ComStop ( i ) ;
103792: LD_VAR 0 7
103796: PPUSH
103797: CALL_OW 141
103801: GO 103789
103803: POP
103804: POP
// solds := [ ] ;
103805: LD_ADDR_VAR 0 2
103809: PUSH
103810: EMPTY
103811: ST_TO_ADDR
// exit ;
103812: GO 104129
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
103814: LD_VAR 0 5
103818: NOT
103819: PUSH
103820: LD_VAR 0 5
103824: PUSH
103825: LD_INT 3
103827: GREATER
103828: OR
103829: PUSH
103830: LD_EXP 90
103834: PUSH
103835: LD_VAR 0 1
103839: ARRAY
103840: OR
103841: IFFALSE 103882
// begin for i in solds do
103843: LD_ADDR_VAR 0 7
103847: PUSH
103848: LD_VAR 0 2
103852: PUSH
103853: FOR_IN
103854: IFFALSE 103878
// if HasTask ( i ) then
103856: LD_VAR 0 7
103860: PPUSH
103861: CALL_OW 314
103865: IFFALSE 103876
// ComStop ( i ) ;
103867: LD_VAR 0 7
103871: PPUSH
103872: CALL_OW 141
103876: GO 103853
103878: POP
103879: POP
// break ;
103880: GO 104117
// end ; for i in solds do
103882: LD_ADDR_VAR 0 7
103886: PUSH
103887: LD_VAR 0 2
103891: PUSH
103892: FOR_IN
103893: IFFALSE 104109
// begin if IsInUnit ( i ) then
103895: LD_VAR 0 7
103899: PPUSH
103900: CALL_OW 310
103904: IFFALSE 103915
// ComExitBuilding ( i ) ;
103906: LD_VAR 0 7
103910: PPUSH
103911: CALL_OW 122
// if GetLives ( i ) > 333 then
103915: LD_VAR 0 7
103919: PPUSH
103920: CALL_OW 256
103924: PUSH
103925: LD_INT 333
103927: GREATER
103928: IFFALSE 103956
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
103930: LD_VAR 0 7
103934: PPUSH
103935: LD_VAR 0 5
103939: PPUSH
103940: LD_VAR 0 7
103944: PPUSH
103945: CALL_OW 74
103949: PPUSH
103950: CALL_OW 115
103954: GO 104107
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
103956: LD_ADDR_VAR 0 8
103960: PUSH
103961: LD_EXP 68
103965: PUSH
103966: LD_VAR 0 1
103970: ARRAY
103971: PPUSH
103972: LD_INT 2
103974: PUSH
103975: LD_INT 30
103977: PUSH
103978: LD_INT 0
103980: PUSH
103981: EMPTY
103982: LIST
103983: LIST
103984: PUSH
103985: LD_INT 30
103987: PUSH
103988: LD_INT 1
103990: PUSH
103991: EMPTY
103992: LIST
103993: LIST
103994: PUSH
103995: LD_INT 30
103997: PUSH
103998: LD_INT 6
104000: PUSH
104001: EMPTY
104002: LIST
104003: LIST
104004: PUSH
104005: EMPTY
104006: LIST
104007: LIST
104008: LIST
104009: LIST
104010: PPUSH
104011: CALL_OW 72
104015: PPUSH
104016: LD_VAR 0 7
104020: PPUSH
104021: CALL_OW 74
104025: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
104026: LD_VAR 0 7
104030: PPUSH
104031: LD_VAR 0 8
104035: PPUSH
104036: CALL_OW 250
104040: PPUSH
104041: LD_INT 3
104043: PPUSH
104044: LD_INT 5
104046: PPUSH
104047: CALL_OW 272
104051: PPUSH
104052: LD_VAR 0 8
104056: PPUSH
104057: CALL_OW 251
104061: PPUSH
104062: LD_INT 3
104064: PPUSH
104065: LD_INT 5
104067: PPUSH
104068: CALL_OW 273
104072: PPUSH
104073: CALL_OW 111
// SetTag ( i , 0 ) ;
104077: LD_VAR 0 7
104081: PPUSH
104082: LD_INT 0
104084: PPUSH
104085: CALL_OW 109
// solds := solds diff i ;
104089: LD_ADDR_VAR 0 2
104093: PUSH
104094: LD_VAR 0 2
104098: PUSH
104099: LD_VAR 0 7
104103: DIFF
104104: ST_TO_ADDR
// continue ;
104105: GO 103892
// end ; end ;
104107: GO 103892
104109: POP
104110: POP
// until solds ;
104111: LD_VAR 0 2
104115: IFFALSE 103724
// MC_Reset ( base , 18 ) ;
104117: LD_VAR 0 1
104121: PPUSH
104122: LD_INT 18
104124: PPUSH
104125: CALL 55549 0 2
// end ;
104129: LD_VAR 0 4
104133: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
104134: LD_INT 0
104136: PPUSH
104137: PPUSH
104138: PPUSH
104139: PPUSH
104140: PPUSH
104141: PPUSH
104142: PPUSH
104143: PPUSH
104144: PPUSH
104145: PPUSH
104146: PPUSH
104147: PPUSH
104148: PPUSH
104149: PPUSH
104150: PPUSH
104151: PPUSH
104152: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
104153: LD_ADDR_VAR 0 13
104157: PUSH
104158: LD_EXP 68
104162: PUSH
104163: LD_VAR 0 1
104167: ARRAY
104168: PPUSH
104169: LD_INT 25
104171: PUSH
104172: LD_INT 3
104174: PUSH
104175: EMPTY
104176: LIST
104177: LIST
104178: PPUSH
104179: CALL_OW 72
104183: ST_TO_ADDR
// if mc_remote_driver [ base ] then
104184: LD_EXP 108
104188: PUSH
104189: LD_VAR 0 1
104193: ARRAY
104194: IFFALSE 104218
// mechs := mechs diff mc_remote_driver [ base ] ;
104196: LD_ADDR_VAR 0 13
104200: PUSH
104201: LD_VAR 0 13
104205: PUSH
104206: LD_EXP 108
104210: PUSH
104211: LD_VAR 0 1
104215: ARRAY
104216: DIFF
104217: ST_TO_ADDR
// for i in mechs do
104218: LD_ADDR_VAR 0 5
104222: PUSH
104223: LD_VAR 0 13
104227: PUSH
104228: FOR_IN
104229: IFFALSE 104264
// if GetTag ( i ) > 0 then
104231: LD_VAR 0 5
104235: PPUSH
104236: CALL_OW 110
104240: PUSH
104241: LD_INT 0
104243: GREATER
104244: IFFALSE 104262
// mechs := mechs diff i ;
104246: LD_ADDR_VAR 0 13
104250: PUSH
104251: LD_VAR 0 13
104255: PUSH
104256: LD_VAR 0 5
104260: DIFF
104261: ST_TO_ADDR
104262: GO 104228
104264: POP
104265: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104266: LD_ADDR_VAR 0 9
104270: PUSH
104271: LD_EXP 68
104275: PUSH
104276: LD_VAR 0 1
104280: ARRAY
104281: PPUSH
104282: LD_INT 2
104284: PUSH
104285: LD_INT 25
104287: PUSH
104288: LD_INT 1
104290: PUSH
104291: EMPTY
104292: LIST
104293: LIST
104294: PUSH
104295: LD_INT 25
104297: PUSH
104298: LD_INT 5
104300: PUSH
104301: EMPTY
104302: LIST
104303: LIST
104304: PUSH
104305: LD_INT 25
104307: PUSH
104308: LD_INT 8
104310: PUSH
104311: EMPTY
104312: LIST
104313: LIST
104314: PUSH
104315: LD_INT 25
104317: PUSH
104318: LD_INT 9
104320: PUSH
104321: EMPTY
104322: LIST
104323: LIST
104324: PUSH
104325: EMPTY
104326: LIST
104327: LIST
104328: LIST
104329: LIST
104330: LIST
104331: PPUSH
104332: CALL_OW 72
104336: ST_TO_ADDR
// if not defenders and not solds then
104337: LD_VAR 0 2
104341: NOT
104342: PUSH
104343: LD_VAR 0 9
104347: NOT
104348: AND
104349: IFFALSE 104353
// exit ;
104351: GO 106043
// depot_under_attack := false ;
104353: LD_ADDR_VAR 0 17
104357: PUSH
104358: LD_INT 0
104360: ST_TO_ADDR
// sold_defenders := [ ] ;
104361: LD_ADDR_VAR 0 18
104365: PUSH
104366: EMPTY
104367: ST_TO_ADDR
// if mechs then
104368: LD_VAR 0 13
104372: IFFALSE 104525
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
104374: LD_ADDR_VAR 0 5
104378: PUSH
104379: LD_VAR 0 2
104383: PPUSH
104384: LD_INT 21
104386: PUSH
104387: LD_INT 2
104389: PUSH
104390: EMPTY
104391: LIST
104392: LIST
104393: PPUSH
104394: CALL_OW 72
104398: PUSH
104399: FOR_IN
104400: IFFALSE 104523
// begin if GetTag ( i ) <> 20 then
104402: LD_VAR 0 5
104406: PPUSH
104407: CALL_OW 110
104411: PUSH
104412: LD_INT 20
104414: NONEQUAL
104415: IFFALSE 104429
// SetTag ( i , 20 ) ;
104417: LD_VAR 0 5
104421: PPUSH
104422: LD_INT 20
104424: PPUSH
104425: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
104429: LD_VAR 0 5
104433: PPUSH
104434: CALL_OW 263
104438: PUSH
104439: LD_INT 1
104441: EQUAL
104442: PUSH
104443: LD_VAR 0 5
104447: PPUSH
104448: CALL_OW 311
104452: NOT
104453: AND
104454: IFFALSE 104521
// begin un := mechs [ 1 ] ;
104456: LD_ADDR_VAR 0 11
104460: PUSH
104461: LD_VAR 0 13
104465: PUSH
104466: LD_INT 1
104468: ARRAY
104469: ST_TO_ADDR
// ComExit ( un ) ;
104470: LD_VAR 0 11
104474: PPUSH
104475: CALL 50312 0 1
// AddComEnterUnit ( un , i ) ;
104479: LD_VAR 0 11
104483: PPUSH
104484: LD_VAR 0 5
104488: PPUSH
104489: CALL_OW 180
// SetTag ( un , 19 ) ;
104493: LD_VAR 0 11
104497: PPUSH
104498: LD_INT 19
104500: PPUSH
104501: CALL_OW 109
// mechs := mechs diff un ;
104505: LD_ADDR_VAR 0 13
104509: PUSH
104510: LD_VAR 0 13
104514: PUSH
104515: LD_VAR 0 11
104519: DIFF
104520: ST_TO_ADDR
// end ; end ;
104521: GO 104399
104523: POP
104524: POP
// if solds then
104525: LD_VAR 0 9
104529: IFFALSE 104588
// for i in solds do
104531: LD_ADDR_VAR 0 5
104535: PUSH
104536: LD_VAR 0 9
104540: PUSH
104541: FOR_IN
104542: IFFALSE 104586
// if not GetTag ( i ) then
104544: LD_VAR 0 5
104548: PPUSH
104549: CALL_OW 110
104553: NOT
104554: IFFALSE 104584
// begin defenders := defenders union i ;
104556: LD_ADDR_VAR 0 2
104560: PUSH
104561: LD_VAR 0 2
104565: PUSH
104566: LD_VAR 0 5
104570: UNION
104571: ST_TO_ADDR
// SetTag ( i , 18 ) ;
104572: LD_VAR 0 5
104576: PPUSH
104577: LD_INT 18
104579: PPUSH
104580: CALL_OW 109
// end ;
104584: GO 104541
104586: POP
104587: POP
// repeat wait ( 0 0$2 ) ;
104588: LD_INT 70
104590: PPUSH
104591: CALL_OW 67
// enemy := mc_scan [ base ] ;
104595: LD_ADDR_VAR 0 3
104599: PUSH
104600: LD_EXP 91
104604: PUSH
104605: LD_VAR 0 1
104609: ARRAY
104610: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
104611: LD_EXP 68
104615: PUSH
104616: LD_VAR 0 1
104620: ARRAY
104621: NOT
104622: PUSH
104623: LD_EXP 68
104627: PUSH
104628: LD_VAR 0 1
104632: ARRAY
104633: PUSH
104634: EMPTY
104635: EQUAL
104636: OR
104637: IFFALSE 104674
// begin for i in defenders do
104639: LD_ADDR_VAR 0 5
104643: PUSH
104644: LD_VAR 0 2
104648: PUSH
104649: FOR_IN
104650: IFFALSE 104663
// ComStop ( i ) ;
104652: LD_VAR 0 5
104656: PPUSH
104657: CALL_OW 141
104661: GO 104649
104663: POP
104664: POP
// defenders := [ ] ;
104665: LD_ADDR_VAR 0 2
104669: PUSH
104670: EMPTY
104671: ST_TO_ADDR
// exit ;
104672: GO 106043
// end ; for i in defenders do
104674: LD_ADDR_VAR 0 5
104678: PUSH
104679: LD_VAR 0 2
104683: PUSH
104684: FOR_IN
104685: IFFALSE 105503
// begin e := NearestUnitToUnit ( enemy , i ) ;
104687: LD_ADDR_VAR 0 14
104691: PUSH
104692: LD_VAR 0 3
104696: PPUSH
104697: LD_VAR 0 5
104701: PPUSH
104702: CALL_OW 74
104706: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104707: LD_ADDR_VAR 0 8
104711: PUSH
104712: LD_EXP 68
104716: PUSH
104717: LD_VAR 0 1
104721: ARRAY
104722: PPUSH
104723: LD_INT 2
104725: PUSH
104726: LD_INT 30
104728: PUSH
104729: LD_INT 0
104731: PUSH
104732: EMPTY
104733: LIST
104734: LIST
104735: PUSH
104736: LD_INT 30
104738: PUSH
104739: LD_INT 1
104741: PUSH
104742: EMPTY
104743: LIST
104744: LIST
104745: PUSH
104746: EMPTY
104747: LIST
104748: LIST
104749: LIST
104750: PPUSH
104751: CALL_OW 72
104755: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
104756: LD_ADDR_VAR 0 17
104760: PUSH
104761: LD_VAR 0 8
104765: NOT
104766: PUSH
104767: LD_VAR 0 8
104771: PPUSH
104772: LD_INT 3
104774: PUSH
104775: LD_INT 24
104777: PUSH
104778: LD_INT 600
104780: PUSH
104781: EMPTY
104782: LIST
104783: LIST
104784: PUSH
104785: EMPTY
104786: LIST
104787: LIST
104788: PPUSH
104789: CALL_OW 72
104793: OR
104794: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
104795: LD_VAR 0 5
104799: PPUSH
104800: CALL_OW 247
104804: PUSH
104805: LD_INT 2
104807: DOUBLE
104808: EQUAL
104809: IFTRUE 104813
104811: GO 105209
104813: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
104814: LD_VAR 0 5
104818: PPUSH
104819: CALL_OW 256
104823: PUSH
104824: LD_INT 1000
104826: EQUAL
104827: PUSH
104828: LD_VAR 0 5
104832: PPUSH
104833: LD_VAR 0 14
104837: PPUSH
104838: CALL_OW 296
104842: PUSH
104843: LD_INT 40
104845: LESS
104846: PUSH
104847: LD_VAR 0 14
104851: PPUSH
104852: LD_EXP 93
104856: PUSH
104857: LD_VAR 0 1
104861: ARRAY
104862: PPUSH
104863: CALL_OW 308
104867: OR
104868: AND
104869: IFFALSE 104991
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
104871: LD_VAR 0 5
104875: PPUSH
104876: CALL_OW 262
104880: PUSH
104881: LD_INT 1
104883: EQUAL
104884: PUSH
104885: LD_VAR 0 5
104889: PPUSH
104890: CALL_OW 261
104894: PUSH
104895: LD_INT 30
104897: LESS
104898: AND
104899: PUSH
104900: LD_VAR 0 8
104904: AND
104905: IFFALSE 104975
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
104907: LD_VAR 0 5
104911: PPUSH
104912: LD_VAR 0 8
104916: PPUSH
104917: LD_VAR 0 5
104921: PPUSH
104922: CALL_OW 74
104926: PPUSH
104927: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
104931: LD_VAR 0 5
104935: PPUSH
104936: LD_VAR 0 8
104940: PPUSH
104941: LD_VAR 0 5
104945: PPUSH
104946: CALL_OW 74
104950: PPUSH
104951: CALL_OW 296
104955: PUSH
104956: LD_INT 6
104958: LESS
104959: IFFALSE 104973
// SetFuel ( i , 100 ) ;
104961: LD_VAR 0 5
104965: PPUSH
104966: LD_INT 100
104968: PPUSH
104969: CALL_OW 240
// end else
104973: GO 104989
// ComAttackUnit ( i , e ) ;
104975: LD_VAR 0 5
104979: PPUSH
104980: LD_VAR 0 14
104984: PPUSH
104985: CALL_OW 115
// end else
104989: GO 105092
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
104991: LD_VAR 0 14
104995: PPUSH
104996: LD_EXP 93
105000: PUSH
105001: LD_VAR 0 1
105005: ARRAY
105006: PPUSH
105007: CALL_OW 308
105011: NOT
105012: PUSH
105013: LD_VAR 0 5
105017: PPUSH
105018: LD_VAR 0 14
105022: PPUSH
105023: CALL_OW 296
105027: PUSH
105028: LD_INT 40
105030: GREATEREQUAL
105031: AND
105032: PUSH
105033: LD_VAR 0 5
105037: PPUSH
105038: CALL_OW 256
105042: PUSH
105043: LD_INT 650
105045: LESSEQUAL
105046: OR
105047: PUSH
105048: LD_VAR 0 5
105052: PPUSH
105053: LD_EXP 92
105057: PUSH
105058: LD_VAR 0 1
105062: ARRAY
105063: PPUSH
105064: CALL_OW 308
105068: NOT
105069: AND
105070: IFFALSE 105092
// ComMoveToArea ( i , mc_parking [ base ] ) ;
105072: LD_VAR 0 5
105076: PPUSH
105077: LD_EXP 92
105081: PUSH
105082: LD_VAR 0 1
105086: ARRAY
105087: PPUSH
105088: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
105092: LD_VAR 0 5
105096: PPUSH
105097: CALL_OW 256
105101: PUSH
105102: LD_INT 1000
105104: LESS
105105: PUSH
105106: LD_VAR 0 5
105110: PPUSH
105111: CALL_OW 263
105115: PUSH
105116: LD_INT 1
105118: EQUAL
105119: AND
105120: PUSH
105121: LD_VAR 0 5
105125: PPUSH
105126: CALL_OW 311
105130: AND
105131: PUSH
105132: LD_VAR 0 5
105136: PPUSH
105137: LD_EXP 92
105141: PUSH
105142: LD_VAR 0 1
105146: ARRAY
105147: PPUSH
105148: CALL_OW 308
105152: AND
105153: IFFALSE 105207
// begin mech := IsDrivenBy ( i ) ;
105155: LD_ADDR_VAR 0 10
105159: PUSH
105160: LD_VAR 0 5
105164: PPUSH
105165: CALL_OW 311
105169: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
105170: LD_VAR 0 10
105174: PPUSH
105175: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
105179: LD_VAR 0 10
105183: PPUSH
105184: LD_VAR 0 5
105188: PPUSH
105189: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
105193: LD_VAR 0 10
105197: PPUSH
105198: LD_VAR 0 5
105202: PPUSH
105203: CALL_OW 180
// end ; end ; unit_human :
105207: GO 105474
105209: LD_INT 1
105211: DOUBLE
105212: EQUAL
105213: IFTRUE 105217
105215: GO 105473
105217: POP
// begin b := IsInUnit ( i ) ;
105218: LD_ADDR_VAR 0 19
105222: PUSH
105223: LD_VAR 0 5
105227: PPUSH
105228: CALL_OW 310
105232: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
105233: LD_ADDR_VAR 0 20
105237: PUSH
105238: LD_VAR 0 19
105242: NOT
105243: PUSH
105244: LD_VAR 0 19
105248: PPUSH
105249: CALL_OW 266
105253: PUSH
105254: LD_INT 32
105256: PUSH
105257: LD_INT 31
105259: PUSH
105260: EMPTY
105261: LIST
105262: LIST
105263: IN
105264: OR
105265: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
105266: LD_VAR 0 17
105270: PUSH
105271: LD_VAR 0 2
105275: PPUSH
105276: LD_INT 21
105278: PUSH
105279: LD_INT 2
105281: PUSH
105282: EMPTY
105283: LIST
105284: LIST
105285: PPUSH
105286: CALL_OW 72
105290: PUSH
105291: LD_INT 1
105293: LESSEQUAL
105294: OR
105295: PUSH
105296: LD_VAR 0 20
105300: AND
105301: PUSH
105302: LD_VAR 0 5
105306: PUSH
105307: LD_VAR 0 18
105311: IN
105312: NOT
105313: AND
105314: IFFALSE 105407
// begin if b then
105316: LD_VAR 0 19
105320: IFFALSE 105369
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
105322: LD_VAR 0 19
105326: PPUSH
105327: LD_VAR 0 3
105331: PPUSH
105332: LD_VAR 0 19
105336: PPUSH
105337: CALL_OW 74
105341: PPUSH
105342: CALL_OW 296
105346: PUSH
105347: LD_INT 10
105349: LESS
105350: PUSH
105351: LD_VAR 0 19
105355: PPUSH
105356: CALL_OW 461
105360: PUSH
105361: LD_INT 7
105363: NONEQUAL
105364: AND
105365: IFFALSE 105369
// continue ;
105367: GO 104684
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
105369: LD_ADDR_VAR 0 18
105373: PUSH
105374: LD_VAR 0 18
105378: PPUSH
105379: LD_VAR 0 18
105383: PUSH
105384: LD_INT 1
105386: PLUS
105387: PPUSH
105388: LD_VAR 0 5
105392: PPUSH
105393: CALL_OW 1
105397: ST_TO_ADDR
// ComExitBuilding ( i ) ;
105398: LD_VAR 0 5
105402: PPUSH
105403: CALL_OW 122
// end ; if sold_defenders then
105407: LD_VAR 0 18
105411: IFFALSE 105471
// if i in sold_defenders then
105413: LD_VAR 0 5
105417: PUSH
105418: LD_VAR 0 18
105422: IN
105423: IFFALSE 105471
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
105425: LD_VAR 0 5
105429: PPUSH
105430: CALL_OW 314
105434: NOT
105435: PUSH
105436: LD_VAR 0 5
105440: PPUSH
105441: LD_VAR 0 14
105445: PPUSH
105446: CALL_OW 296
105450: PUSH
105451: LD_INT 30
105453: LESS
105454: AND
105455: IFFALSE 105471
// ComAttackUnit ( i , e ) ;
105457: LD_VAR 0 5
105461: PPUSH
105462: LD_VAR 0 14
105466: PPUSH
105467: CALL_OW 115
// end ; end ; end ;
105471: GO 105474
105473: POP
// if IsDead ( i ) then
105474: LD_VAR 0 5
105478: PPUSH
105479: CALL_OW 301
105483: IFFALSE 105501
// defenders := defenders diff i ;
105485: LD_ADDR_VAR 0 2
105489: PUSH
105490: LD_VAR 0 2
105494: PUSH
105495: LD_VAR 0 5
105499: DIFF
105500: ST_TO_ADDR
// end ;
105501: GO 104684
105503: POP
105504: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
105505: LD_VAR 0 3
105509: NOT
105510: PUSH
105511: LD_VAR 0 2
105515: NOT
105516: OR
105517: PUSH
105518: LD_EXP 68
105522: PUSH
105523: LD_VAR 0 1
105527: ARRAY
105528: NOT
105529: OR
105530: IFFALSE 104588
// MC_Reset ( base , 18 ) ;
105532: LD_VAR 0 1
105536: PPUSH
105537: LD_INT 18
105539: PPUSH
105540: CALL 55549 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
105544: LD_ADDR_VAR 0 2
105548: PUSH
105549: LD_VAR 0 2
105553: PUSH
105554: LD_VAR 0 2
105558: PPUSH
105559: LD_INT 2
105561: PUSH
105562: LD_INT 25
105564: PUSH
105565: LD_INT 1
105567: PUSH
105568: EMPTY
105569: LIST
105570: LIST
105571: PUSH
105572: LD_INT 25
105574: PUSH
105575: LD_INT 5
105577: PUSH
105578: EMPTY
105579: LIST
105580: LIST
105581: PUSH
105582: LD_INT 25
105584: PUSH
105585: LD_INT 8
105587: PUSH
105588: EMPTY
105589: LIST
105590: LIST
105591: PUSH
105592: LD_INT 25
105594: PUSH
105595: LD_INT 9
105597: PUSH
105598: EMPTY
105599: LIST
105600: LIST
105601: PUSH
105602: EMPTY
105603: LIST
105604: LIST
105605: LIST
105606: LIST
105607: LIST
105608: PPUSH
105609: CALL_OW 72
105613: DIFF
105614: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
105615: LD_VAR 0 3
105619: NOT
105620: PUSH
105621: LD_VAR 0 2
105625: PPUSH
105626: LD_INT 21
105628: PUSH
105629: LD_INT 2
105631: PUSH
105632: EMPTY
105633: LIST
105634: LIST
105635: PPUSH
105636: CALL_OW 72
105640: AND
105641: IFFALSE 105979
// begin tmp := FilterByTag ( defenders , 19 ) ;
105643: LD_ADDR_VAR 0 12
105647: PUSH
105648: LD_VAR 0 2
105652: PPUSH
105653: LD_INT 19
105655: PPUSH
105656: CALL 47442 0 2
105660: ST_TO_ADDR
// if tmp then
105661: LD_VAR 0 12
105665: IFFALSE 105735
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
105667: LD_ADDR_VAR 0 12
105671: PUSH
105672: LD_VAR 0 12
105676: PPUSH
105677: LD_INT 25
105679: PUSH
105680: LD_INT 3
105682: PUSH
105683: EMPTY
105684: LIST
105685: LIST
105686: PPUSH
105687: CALL_OW 72
105691: ST_TO_ADDR
// if tmp then
105692: LD_VAR 0 12
105696: IFFALSE 105735
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
105698: LD_ADDR_EXP 80
105702: PUSH
105703: LD_EXP 80
105707: PPUSH
105708: LD_VAR 0 1
105712: PPUSH
105713: LD_EXP 80
105717: PUSH
105718: LD_VAR 0 1
105722: ARRAY
105723: PUSH
105724: LD_VAR 0 12
105728: UNION
105729: PPUSH
105730: CALL_OW 1
105734: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
105735: LD_VAR 0 1
105739: PPUSH
105740: LD_INT 19
105742: PPUSH
105743: CALL 55549 0 2
// repeat wait ( 0 0$1 ) ;
105747: LD_INT 35
105749: PPUSH
105750: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
105754: LD_EXP 68
105758: PUSH
105759: LD_VAR 0 1
105763: ARRAY
105764: NOT
105765: PUSH
105766: LD_EXP 68
105770: PUSH
105771: LD_VAR 0 1
105775: ARRAY
105776: PUSH
105777: EMPTY
105778: EQUAL
105779: OR
105780: IFFALSE 105817
// begin for i in defenders do
105782: LD_ADDR_VAR 0 5
105786: PUSH
105787: LD_VAR 0 2
105791: PUSH
105792: FOR_IN
105793: IFFALSE 105806
// ComStop ( i ) ;
105795: LD_VAR 0 5
105799: PPUSH
105800: CALL_OW 141
105804: GO 105792
105806: POP
105807: POP
// defenders := [ ] ;
105808: LD_ADDR_VAR 0 2
105812: PUSH
105813: EMPTY
105814: ST_TO_ADDR
// exit ;
105815: GO 106043
// end ; for i in defenders do
105817: LD_ADDR_VAR 0 5
105821: PUSH
105822: LD_VAR 0 2
105826: PUSH
105827: FOR_IN
105828: IFFALSE 105917
// begin if not IsInArea ( i , mc_parking [ base ] ) then
105830: LD_VAR 0 5
105834: PPUSH
105835: LD_EXP 92
105839: PUSH
105840: LD_VAR 0 1
105844: ARRAY
105845: PPUSH
105846: CALL_OW 308
105850: NOT
105851: IFFALSE 105875
// ComMoveToArea ( i , mc_parking [ base ] ) else
105853: LD_VAR 0 5
105857: PPUSH
105858: LD_EXP 92
105862: PUSH
105863: LD_VAR 0 1
105867: ARRAY
105868: PPUSH
105869: CALL_OW 113
105873: GO 105915
// if GetControl ( i ) = control_manual then
105875: LD_VAR 0 5
105879: PPUSH
105880: CALL_OW 263
105884: PUSH
105885: LD_INT 1
105887: EQUAL
105888: IFFALSE 105915
// if IsDrivenBy ( i ) then
105890: LD_VAR 0 5
105894: PPUSH
105895: CALL_OW 311
105899: IFFALSE 105915
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
105901: LD_VAR 0 5
105905: PPUSH
105906: CALL_OW 311
105910: PPUSH
105911: CALL_OW 121
// end ;
105915: GO 105827
105917: POP
105918: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
105919: LD_VAR 0 2
105923: PPUSH
105924: LD_INT 95
105926: PUSH
105927: LD_EXP 92
105931: PUSH
105932: LD_VAR 0 1
105936: ARRAY
105937: PUSH
105938: EMPTY
105939: LIST
105940: LIST
105941: PPUSH
105942: CALL_OW 72
105946: PUSH
105947: LD_VAR 0 2
105951: EQUAL
105952: PUSH
105953: LD_EXP 91
105957: PUSH
105958: LD_VAR 0 1
105962: ARRAY
105963: OR
105964: PUSH
105965: LD_EXP 68
105969: PUSH
105970: LD_VAR 0 1
105974: ARRAY
105975: NOT
105976: OR
105977: IFFALSE 105747
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
105979: LD_ADDR_EXP 90
105983: PUSH
105984: LD_EXP 90
105988: PPUSH
105989: LD_VAR 0 1
105993: PPUSH
105994: LD_VAR 0 2
105998: PPUSH
105999: LD_INT 21
106001: PUSH
106002: LD_INT 2
106004: PUSH
106005: EMPTY
106006: LIST
106007: LIST
106008: PPUSH
106009: CALL_OW 72
106013: PPUSH
106014: CALL_OW 1
106018: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
106019: LD_VAR 0 1
106023: PPUSH
106024: LD_INT 19
106026: PPUSH
106027: CALL 55549 0 2
// MC_Reset ( base , 20 ) ;
106031: LD_VAR 0 1
106035: PPUSH
106036: LD_INT 20
106038: PPUSH
106039: CALL 55549 0 2
// end ; end_of_file
106043: LD_VAR 0 4
106047: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
106048: LD_VAR 0 1
106052: PUSH
106053: LD_INT 200
106055: DOUBLE
106056: GREATEREQUAL
106057: IFFALSE 106065
106059: LD_INT 299
106061: DOUBLE
106062: LESSEQUAL
106063: IFTRUE 106067
106065: GO 106099
106067: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
106068: LD_VAR 0 1
106072: PPUSH
106073: LD_VAR 0 2
106077: PPUSH
106078: LD_VAR 0 3
106082: PPUSH
106083: LD_VAR 0 4
106087: PPUSH
106088: LD_VAR 0 5
106092: PPUSH
106093: CALL 94981 0 5
106097: GO 106176
106099: LD_INT 300
106101: DOUBLE
106102: GREATEREQUAL
106103: IFFALSE 106111
106105: LD_INT 399
106107: DOUBLE
106108: LESSEQUAL
106109: IFTRUE 106113
106111: GO 106175
106113: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
106114: LD_VAR 0 1
106118: PPUSH
106119: LD_VAR 0 2
106123: PPUSH
106124: LD_VAR 0 3
106128: PPUSH
106129: LD_VAR 0 4
106133: PPUSH
106134: LD_VAR 0 5
106138: PPUSH
106139: LD_VAR 0 6
106143: PPUSH
106144: LD_VAR 0 7
106148: PPUSH
106149: LD_VAR 0 8
106153: PPUSH
106154: LD_VAR 0 9
106158: PPUSH
106159: LD_VAR 0 10
106163: PPUSH
106164: LD_VAR 0 11
106168: PPUSH
106169: CALL 92869 0 11
106173: GO 106176
106175: POP
// end ;
106176: PPOPN 11
106178: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
106179: LD_VAR 0 1
106183: PPUSH
106184: LD_VAR 0 2
106188: PPUSH
106189: LD_VAR 0 3
106193: PPUSH
106194: LD_VAR 0 4
106198: PPUSH
106199: LD_VAR 0 5
106203: PPUSH
106204: CALL 94963 0 5
// end ; end_of_file
106208: PPOPN 5
106210: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
106211: LD_VAR 0 1
106215: PPUSH
106216: LD_VAR 0 2
106220: PPUSH
106221: LD_VAR 0 3
106225: PPUSH
106226: LD_VAR 0 4
106230: PPUSH
106231: LD_VAR 0 5
106235: PPUSH
106236: LD_VAR 0 6
106240: PPUSH
106241: CALL 81677 0 6
// end ;
106245: PPOPN 6
106247: END
