// export MissionStart ; export southAreaBlocker ; starting begin southAreaBlocker = true ;
   0: LD_ADDR_EXP 2
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// ResetFog ;
   8: CALL_OW 335
// AnimateTrees ( true ) ;
  12: LD_INT 1
  14: PPUSH
  15: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  19: LD_INT 1
  21: PPUSH
  22: LD_INT 8
  24: PPUSH
  25: CALL_OW 332
// GameType ;
  29: CALL 5676 0 0
// SetBName ( BetaA , beta ) ;
  33: LD_INT 1
  35: PPUSH
  36: LD_STRING beta
  38: PPUSH
  39: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  43: LD_INT 3
  45: PPUSH
  46: LD_STRING beta
  48: PPUSH
  49: CALL_OW 500
// SetResourceType ( GetBase ( BetaA ) , mat_cans , startCrates [ 1 ] ) ;
  53: LD_INT 1
  55: PPUSH
  56: CALL_OW 274
  60: PPUSH
  61: LD_INT 1
  63: PPUSH
  64: LD_EXP 43
  68: PUSH
  69: LD_INT 1
  71: ARRAY
  72: PPUSH
  73: CALL_OW 277
// SetResourceType ( GetBase ( BetaB ) , mat_cans , startCrates [ 2 ] ) ;
  77: LD_INT 3
  79: PPUSH
  80: CALL_OW 274
  84: PPUSH
  85: LD_INT 1
  87: PPUSH
  88: LD_EXP 43
  92: PUSH
  93: LD_INT 2
  95: ARRAY
  96: PPUSH
  97: CALL_OW 277
// PrepareHeroes ;
 101: CALL 2839 0 0
// PrepareBeta ;
 105: CALL 3228 0 0
// HideArea ( 1 , SouthArea ) ;
 109: LD_INT 1
 111: PPUSH
 112: LD_INT 16
 114: PPUSH
 115: CALL_OW 333
// InGameOn ;
 119: CALL_OW 8
// ComHold ( Brighton ) ;
 123: LD_EXP 9
 127: PPUSH
 128: CALL_OW 140
// CenterNowOnUnits ( Brighton ) ;
 132: LD_EXP 9
 136: PPUSH
 137: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
 141: LD_EXP 11
 145: PPUSH
 146: LD_INT 50
 148: PPUSH
 149: LD_INT 42
 151: PPUSH
 152: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
 156: LD_INT 35
 158: PPUSH
 159: CALL_OW 67
 163: LD_EXP 11
 167: PPUSH
 168: LD_EXP 9
 172: PPUSH
 173: CALL_OW 296
 177: PUSH
 178: LD_INT 3
 180: LESS
 181: IFFALSE 156
// ComTurnUnit ( Megan , Brighton ) ;
 183: LD_EXP 11
 187: PPUSH
 188: LD_EXP 9
 192: PPUSH
 193: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 197: LD_EXP 11
 201: PPUSH
 202: LD_STRING DMegan-1a
 204: PPUSH
 205: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 209: LD_INT 10
 211: PPUSH
 212: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 216: LD_EXP 9
 220: PPUSH
 221: LD_EXP 11
 225: PPUSH
 226: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 230: LD_EXP 9
 234: PPUSH
 235: LD_STRING DBrighton-1a
 237: PPUSH
 238: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 242: LD_EXP 11
 246: PPUSH
 247: LD_STRING DMegan-2a
 249: PPUSH
 250: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 254: LD_EXP 9
 258: PPUSH
 259: LD_STRING DBrighton-2a
 261: PPUSH
 262: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 266: LD_EXP 11
 270: PPUSH
 271: LD_INT 40
 273: PPUSH
 274: LD_INT 37
 276: PPUSH
 277: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 281: LD_EXP 11
 285: PPUSH
 286: LD_EXP 9
 290: PPUSH
 291: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 295: LD_EXP 10
 299: PPUSH
 300: LD_INT 50
 302: PPUSH
 303: LD_INT 42
 305: PPUSH
 306: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 310: LD_INT 35
 312: PPUSH
 313: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 317: LD_EXP 9
 321: PPUSH
 322: LD_EXP 10
 326: PPUSH
 327: CALL_OW 296
 331: PUSH
 332: LD_INT 6
 334: LESS
 335: IFFALSE 310
// ComTurnUnit ( Brighton , Palmer ) ;
 337: LD_EXP 9
 341: PPUSH
 342: LD_EXP 10
 346: PPUSH
 347: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 351: LD_EXP 10
 355: PPUSH
 356: LD_EXP 9
 360: PPUSH
 361: CALL_OW 119
// Say ( Palmer , DPalmer-1 ) ;
 365: LD_EXP 10
 369: PPUSH
 370: LD_STRING DPalmer-1
 372: PPUSH
 373: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 377: LD_EXP 9
 381: PPUSH
 382: LD_STRING DBrighton-1
 384: PPUSH
 385: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 389: LD_EXP 10
 393: PPUSH
 394: LD_STRING DPalmer-2
 396: PPUSH
 397: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 401: LD_EXP 9
 405: PPUSH
 406: LD_STRING DBrighton-2
 408: PPUSH
 409: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 413: LD_EXP 10
 417: PPUSH
 418: LD_STRING DPalmer-3
 420: PPUSH
 421: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 425: LD_EXP 9
 429: PPUSH
 430: LD_STRING DBrighton-3
 432: PPUSH
 433: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 437: LD_EXP 10
 441: PPUSH
 442: LD_STRING DPalmer-4
 444: PPUSH
 445: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 449: LD_EXP 10
 453: PPUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 461: LD_INT 35
 463: PPUSH
 464: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 468: LD_EXP 10
 472: PPUSH
 473: CALL_OW 310
 477: PUSH
 478: LD_INT 6
 480: EQUAL
 481: IFFALSE 461
// SayRadio ( Palmer , DPalmer-5 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_STRING DPalmer-5
 490: PPUSH
 491: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 495: LD_EXP 9
 499: PPUSH
 500: LD_INT 59
 502: PPUSH
 503: LD_INT 36
 505: PPUSH
 506: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 510: LD_EXP 11
 514: PPUSH
 515: LD_INT 60
 517: PPUSH
 518: LD_INT 35
 520: PPUSH
 521: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 525: LD_EXP 10
 529: PPUSH
 530: LD_INT 60
 532: PPUSH
 533: LD_INT 34
 535: PPUSH
 536: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 540: LD_EXP 9
 544: PPUSH
 545: LD_INT 99
 547: PPUSH
 548: LD_INT 37
 550: PPUSH
 551: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 555: LD_EXP 11
 559: PPUSH
 560: LD_EXP 9
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 569: LD_EXP 10
 573: PPUSH
 574: LD_EXP 9
 578: PPUSH
 579: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 583: LD_INT 64
 585: PPUSH
 586: LD_INT 40
 588: PPUSH
 589: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 593: LD_EXP 12
 597: PPUSH
 598: LD_INT 13
 600: PPUSH
 601: CALL 12671 0 2
// wait ( 0 0$30 ) ;
 605: LD_INT 1050
 607: PPUSH
 608: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 612: LD_EXP 9
 616: PPUSH
 617: LD_STRING DBrighton-4
 619: PPUSH
 620: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 624: LD_EXP 9
 628: PPUSH
 629: LD_STRING DBrighton-5
 631: PPUSH
 632: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 636: LD_EXP 9
 640: PPUSH
 641: LD_EXP 11
 645: PPUSH
 646: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 650: LD_EXP 9
 654: PPUSH
 655: LD_STRING DBrighton-6
 657: PPUSH
 658: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 662: LD_EXP 11
 666: PPUSH
 667: LD_STRING DMegan-1
 669: PPUSH
 670: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 674: LD_EXP 9
 678: PPUSH
 679: LD_STRING DBrighton-7
 681: PPUSH
 682: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 686: LD_EXP 9
 690: PPUSH
 691: LD_INT 99
 693: PPUSH
 694: LD_INT 37
 696: PPUSH
 697: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 701: LD_EXP 9
 705: PPUSH
 706: LD_STRING DBrighton-8
 708: PPUSH
 709: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 713: LD_STRING C1
 715: PPUSH
 716: CALL_OW 337
// InGameOff ;
 720: CALL_OW 9
// SaveForQuickRestart ;
 724: CALL_OW 22
// MissionStart := true ;
 728: LD_ADDR_EXP 1
 732: PUSH
 733: LD_INT 1
 735: ST_TO_ADDR
// PrepareRUBase_v2 ;
 736: CALL 4951 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 740: LD_ADDR_EXP 65
 744: PUSH
 745: LD_EXP 65
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: PPUSH
 763: CALL_OW 69
 767: PPUSH
 768: CALL_OW 1
 772: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 773: LD_ADDR_EXP 65
 777: PUSH
 778: LD_EXP 65
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: LD_EXP 36
 790: PPUSH
 791: CALL_OW 1
 795: ST_TO_ADDR
// MC_Start ( ) ;
 796: CALL 52167 0 0
// music_nat := 1 ;
 800: LD_ADDR_OWVAR 71
 804: PUSH
 805: LD_INT 1
 807: ST_TO_ADDR
// end ;
 808: END
// every 0 0$1 trigger southAreaBlocker and FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do var unit ;
 809: LD_EXP 2
 813: PUSH
 814: LD_INT 16
 816: PPUSH
 817: LD_INT 22
 819: PUSH
 820: LD_INT 1
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: PUSH
 827: LD_INT 2
 829: PUSH
 830: LD_INT 21
 832: PUSH
 833: LD_INT 1
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: PUSH
 840: LD_INT 21
 842: PUSH
 843: LD_INT 2
 845: PUSH
 846: EMPTY
 847: LIST
 848: LIST
 849: PUSH
 850: EMPTY
 851: LIST
 852: LIST
 853: LIST
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL_OW 70
 863: AND
 864: IFFALSE 968
 866: GO 868
 868: DISABLE
 869: LD_INT 0
 871: PPUSH
// begin enable ;
 872: ENABLE
// for unit in FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
 873: LD_ADDR_VAR 0 1
 877: PUSH
 878: LD_INT 16
 880: PPUSH
 881: LD_INT 22
 883: PUSH
 884: LD_INT 1
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: PUSH
 891: LD_INT 2
 893: PUSH
 894: LD_INT 21
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: EMPTY
 901: LIST
 902: LIST
 903: PUSH
 904: LD_INT 21
 906: PUSH
 907: LD_INT 2
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: PUSH
 914: EMPTY
 915: LIST
 916: LIST
 917: LIST
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: PPUSH
 923: CALL_OW 70
 927: PUSH
 928: FOR_IN
 929: IFFALSE 966
// ComMoveXY ( unit , GetX ( unit ) , GetY ( unit ) - 2 ) ;
 931: LD_VAR 0 1
 935: PPUSH
 936: LD_VAR 0 1
 940: PPUSH
 941: CALL_OW 250
 945: PPUSH
 946: LD_VAR 0 1
 950: PPUSH
 951: CALL_OW 251
 955: PUSH
 956: LD_INT 2
 958: MINUS
 959: PPUSH
 960: CALL_OW 111
 964: GO 928
 966: POP
 967: POP
// end ;
 968: PPOPN 1
 970: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var i , tmp ;
 971: LD_EXP 1
 975: IFFALSE 1608
 977: GO 979
 979: DISABLE
 980: LD_INT 0
 982: PPUSH
 983: PPUSH
// begin wait ( ruArrival ) ;
 984: LD_EXP 42
 988: PPUSH
 989: CALL_OW 67
// PrepareRUArmada ;
 993: CALL 3810 0 0
// wait ( 0 0$3 ) ;
 997: LD_INT 105
 999: PPUSH
1000: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
1004: LD_ADDR_VAR 0 2
1008: PUSH
1009: LD_INT 15
1011: PPUSH
1012: LD_INT 0
1014: PPUSH
1015: CALL_OW 517
1019: ST_TO_ADDR
// for i = 1 to RUArmada do
1020: LD_ADDR_VAR 0 1
1024: PUSH
1025: DOUBLE
1026: LD_INT 1
1028: DEC
1029: ST_TO_ADDR
1030: LD_EXP 17
1034: PUSH
1035: FOR_TO
1036: IFFALSE 1085
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
1038: LD_EXP 17
1042: PUSH
1043: LD_VAR 0 1
1047: ARRAY
1048: PPUSH
1049: LD_VAR 0 2
1053: PUSH
1054: LD_INT 1
1056: ARRAY
1057: PUSH
1058: LD_VAR 0 1
1062: ARRAY
1063: PPUSH
1064: LD_VAR 0 2
1068: PUSH
1069: LD_INT 2
1071: ARRAY
1072: PUSH
1073: LD_VAR 0 1
1077: ARRAY
1078: PPUSH
1079: CALL_OW 111
1083: GO 1035
1085: POP
1086: POP
// ArmadaArrived := true ;
1087: LD_ADDR_EXP 3
1091: PUSH
1092: LD_INT 1
1094: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
1095: LD_EXP 10
1099: PPUSH
1100: LD_STRING DPalmer-A1
1102: PPUSH
1103: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
1107: LD_EXP 9
1111: PPUSH
1112: LD_STRING DBrighton-A1
1114: PPUSH
1115: CALL_OW 88
// wait ( 0 0$20 ) ;
1119: LD_INT 700
1121: PPUSH
1122: CALL_OW 67
// PrepareRUBase ;
1126: CALL 4535 0 0
// wait ( 1 1$20 ) ;
1130: LD_INT 2800
1132: PPUSH
1133: CALL_OW 67
// PrepareRUBulldozers ;
1137: CALL 4422 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
1141: LD_EXP 18
1145: PUSH
1146: LD_INT 1
1148: ARRAY
1149: PPUSH
1150: LD_INT 9
1152: PPUSH
1153: CALL 12528 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
1157: LD_EXP 18
1161: PUSH
1162: LD_INT 2
1164: ARRAY
1165: PPUSH
1166: LD_INT 11
1168: PPUSH
1169: CALL 12528 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
1173: LD_INT 1
1175: PPUSH
1176: LD_EXP 18
1180: PUSH
1181: LD_INT 1
1183: ARRAY
1184: PPUSH
1185: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1189: LD_INT 1
1191: PPUSH
1192: LD_EXP 18
1196: PUSH
1197: LD_INT 2
1199: ARRAY
1200: PPUSH
1201: CALL_OW 471
// wait ( 0 0$50 ) ;
1205: LD_INT 1750
1207: PPUSH
1208: CALL_OW 67
// ShowArea ( 1 , SouthArea ) ;
1212: LD_INT 1
1214: PPUSH
1215: LD_INT 16
1217: PPUSH
1218: CALL_OW 334
// InGameOn ;
1222: CALL_OW 8
// PlaceSeeing ( 95 , 93 , 1 , - 30 ) ;
1226: LD_INT 95
1228: PPUSH
1229: LD_INT 93
1231: PPUSH
1232: LD_INT 1
1234: PPUSH
1235: LD_INT 30
1237: NEG
1238: PPUSH
1239: CALL_OW 330
// ComMoveXY ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) , 63 , 39 ) ;
1243: LD_INT 10
1245: PPUSH
1246: LD_INT 22
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: PPUSH
1256: CALL_OW 70
1260: PPUSH
1261: LD_INT 63
1263: PPUSH
1264: LD_INT 39
1266: PPUSH
1267: CALL_OW 111
// CenterOnXY ( 95 , 93 ) ;
1271: LD_INT 95
1273: PPUSH
1274: LD_INT 93
1276: PPUSH
1277: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
1281: LD_INT 35
1283: PPUSH
1284: CALL_OW 67
// if not HasTask ( Bulldozers [ 1 ] ) then
1288: LD_EXP 18
1292: PUSH
1293: LD_INT 1
1295: ARRAY
1296: PPUSH
1297: CALL_OW 314
1301: NOT
1302: IFFALSE 1320
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
1304: LD_EXP 18
1308: PUSH
1309: LD_INT 1
1311: ARRAY
1312: PPUSH
1313: LD_INT 9
1315: PPUSH
1316: CALL 12528 0 2
// if not HasTask ( Bulldozers [ 2 ] ) then
1320: LD_EXP 18
1324: PUSH
1325: LD_INT 2
1327: ARRAY
1328: PPUSH
1329: CALL_OW 314
1333: NOT
1334: IFFALSE 1352
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
1336: LD_EXP 18
1340: PUSH
1341: LD_INT 2
1343: ARRAY
1344: PPUSH
1345: LD_INT 11
1347: PPUSH
1348: CALL 12528 0 2
// until ListEnvironmentArea ( BulldozerArea ) < 2 or ListEnvironmentArea ( BulldozerArea2 ) < 2 or IsDead ( Bulldozers [ 1 ] ) ;
1352: LD_INT 9
1354: PPUSH
1355: CALL_OW 353
1359: PUSH
1360: LD_INT 2
1362: LESS
1363: PUSH
1364: LD_INT 11
1366: PPUSH
1367: CALL_OW 353
1371: PUSH
1372: LD_INT 2
1374: LESS
1375: OR
1376: PUSH
1377: LD_EXP 18
1381: PUSH
1382: LD_INT 1
1384: ARRAY
1385: PPUSH
1386: CALL_OW 301
1390: OR
1391: IFFALSE 1281
// if UnitFilter ( Bulldozers , [ f_ok ] ) then
1393: LD_EXP 18
1397: PPUSH
1398: LD_INT 50
1400: PUSH
1401: EMPTY
1402: LIST
1403: PPUSH
1404: CALL_OW 72
1408: IFFALSE 1461
// begin wait ( 0 0$10 ) ;
1410: LD_INT 350
1412: PPUSH
1413: CALL_OW 67
// ComMoveXY ( Bulldozers , 120 , 131 ) ;
1417: LD_EXP 18
1421: PPUSH
1422: LD_INT 120
1424: PPUSH
1425: LD_INT 131
1427: PPUSH
1428: CALL_OW 111
// for i in Bulldozers do
1432: LD_ADDR_VAR 0 1
1436: PUSH
1437: LD_EXP 18
1441: PUSH
1442: FOR_IN
1443: IFFALSE 1459
// NormalAttack ( 1 , i ) ;
1445: LD_INT 1
1447: PPUSH
1448: LD_VAR 0 1
1452: PPUSH
1453: CALL_OW 472
1457: GO 1442
1459: POP
1460: POP
// end ; wait ( 0 0$10 ) ;
1461: LD_INT 350
1463: PPUSH
1464: CALL_OW 67
// RemoveSeeing ( 95 , 93 , 1 ) ;
1468: LD_INT 95
1470: PPUSH
1471: LD_INT 93
1473: PPUSH
1474: LD_INT 1
1476: PPUSH
1477: CALL_OW 331
// southAreaBlocker = false ;
1481: LD_ADDR_EXP 2
1485: PUSH
1486: LD_INT 0
1488: ST_TO_ADDR
// wait ( 0 0$3 ) ;
1489: LD_INT 105
1491: PPUSH
1492: CALL_OW 67
// InGameOff ;
1496: CALL_OW 9
// SayEffect ( DRuSol-A1 ) ;
1500: LD_STRING DRuSol-A1
1502: PPUSH
1503: CALL_OW 96
// AssaultStarted := true ;
1507: LD_ADDR_EXP 8
1511: PUSH
1512: LD_INT 1
1514: ST_TO_ADDR
// wait ( 0 0$2 ) ;
1515: LD_INT 70
1517: PPUSH
1518: CALL_OW 67
// Say ( Yashin , DDeath-Yas-1 ) ;
1522: LD_EXP 13
1526: PPUSH
1527: LD_STRING DDeath-Yas-1
1529: PPUSH
1530: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-2 ) ;
1534: LD_EXP 15
1538: PPUSH
1539: LD_STRING DDeath-Gay-2
1541: PPUSH
1542: CALL_OW 88
// wait ( 0 0$2 ) ;
1546: LD_INT 70
1548: PPUSH
1549: CALL_OW 67
// Say ( Popov , DDeath-Pop-1 ) ;
1553: LD_EXP 14
1557: PPUSH
1558: LD_STRING DDeath-Pop-1
1560: PPUSH
1561: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1565: LD_EXP 15
1569: PPUSH
1570: LD_STRING DDeath-Gay-1
1572: PPUSH
1573: CALL_OW 88
// wait ( 0 0$5 ) ;
1577: LD_INT 175
1579: PPUSH
1580: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1584: LD_EXP 16
1588: PPUSH
1589: LD_STRING DDeath-Vse-1
1591: PPUSH
1592: CALL_OW 88
// Say ( Popov , DDeath-Pop-2 ) ;
1596: LD_EXP 14
1600: PPUSH
1601: LD_STRING DDeath-Pop-2
1603: PPUSH
1604: CALL_OW 88
// end ;
1608: PPOPN 2
1610: END
// every 0 0$1 trigger AssaultStarted do var i , tmp ;
1611: LD_EXP 8
1615: IFFALSE 2067
1617: GO 1619
1619: DISABLE
1620: LD_INT 0
1622: PPUSH
1623: PPUSH
// begin PriorityAttack ( 6 , BetaA ) ;
1624: LD_INT 6
1626: PPUSH
1627: LD_INT 1
1629: PPUSH
1630: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1634: LD_INT 6
1636: PPUSH
1637: LD_INT 3
1639: PPUSH
1640: CALL_OW 470
// repeat for i in RuArmada do
1644: LD_ADDR_VAR 0 1
1648: PUSH
1649: LD_EXP 17
1653: PUSH
1654: FOR_IN
1655: IFFALSE 1693
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1657: LD_VAR 0 1
1661: PPUSH
1662: LD_INT 22
1664: PUSH
1665: LD_INT 1
1667: PUSH
1668: EMPTY
1669: LIST
1670: LIST
1671: PPUSH
1672: CALL_OW 69
1676: PPUSH
1677: LD_VAR 0 1
1681: PPUSH
1682: CALL_OW 74
1686: PPUSH
1687: CALL_OW 115
1691: GO 1654
1693: POP
1694: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1695: LD_INT 35
1697: PPUSH
1698: CALL_OW 67
1702: LD_INT 1
1704: PUSH
1705: LD_INT 22
1707: PUSH
1708: LD_INT 6
1710: PUSH
1711: EMPTY
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 21
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: EMPTY
1722: LIST
1723: LIST
1724: PUSH
1725: EMPTY
1726: LIST
1727: LIST
1728: LIST
1729: PPUSH
1730: CALL_OW 69
1734: PUSH
1735: LD_INT 10
1737: LESS
1738: PUSH
1739: LD_EXP 13
1743: PPUSH
1744: CALL_OW 301
1748: AND
1749: PUSH
1750: LD_EXP 14
1754: PPUSH
1755: CALL_OW 301
1759: AND
1760: PUSH
1761: LD_EXP 15
1765: PPUSH
1766: CALL_OW 301
1770: AND
1771: PUSH
1772: LD_EXP 16
1776: PPUSH
1777: CALL_OW 301
1781: AND
1782: IFFALSE 1644
// AssaultStarted := false ;
1784: LD_ADDR_EXP 8
1788: PUSH
1789: LD_INT 0
1791: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 6 ] ) , RUArrivalArea ) ;
1792: LD_INT 22
1794: PUSH
1795: LD_INT 6
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: PPUSH
1802: CALL_OW 69
1806: PPUSH
1807: LD_INT 5
1809: PPUSH
1810: CALL_OW 113
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1814: LD_ADDR_EXP 5
1818: PUSH
1819: LD_INT 1
1821: PUSH
1822: LD_INT 22
1824: PUSH
1825: LD_INT 6
1827: PUSH
1828: EMPTY
1829: LIST
1830: LIST
1831: PUSH
1832: LD_INT 26
1834: PUSH
1835: LD_INT 1
1837: PUSH
1838: EMPTY
1839: LIST
1840: LIST
1841: PUSH
1842: LD_INT 21
1844: PUSH
1845: LD_INT 1
1847: PUSH
1848: EMPTY
1849: LIST
1850: LIST
1851: PUSH
1852: LD_INT 24
1854: PUSH
1855: LD_INT 500
1857: PUSH
1858: EMPTY
1859: LIST
1860: LIST
1861: PUSH
1862: EMPTY
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: PPUSH
1869: CALL_OW 69
1873: ST_TO_ADDR
// if RuSpeaker then
1874: LD_EXP 5
1878: IFFALSE 1896
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1880: LD_EXP 5
1884: PUSH
1885: LD_INT 1
1887: ARRAY
1888: PPUSH
1889: LD_STRING DRuSol-A2
1891: PPUSH
1892: CALL_OW 88
// wait ( 0 0$30 ) ;
1896: LD_INT 1050
1898: PPUSH
1899: CALL_OW 67
// DialogueOn ;
1903: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1907: LD_EXP 9
1911: PPUSH
1912: LD_STRING DBrighton-B1
1914: PPUSH
1915: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1919: LD_EXP 10
1923: PPUSH
1924: LD_STRING DPalmer-B1
1926: PPUSH
1927: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1931: LD_EXP 9
1935: PPUSH
1936: LD_STRING DBrighton-B2
1938: PPUSH
1939: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1943: LD_EXP 19
1947: PPUSH
1948: LD_STRING DBurlak-B1
1950: PPUSH
1951: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1955: LD_EXP 9
1959: PPUSH
1960: LD_STRING DBrighton-B3
1962: PPUSH
1963: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1967: LD_EXP 10
1971: PPUSH
1972: LD_STRING DPalmer-B2
1974: PPUSH
1975: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1979: LD_EXP 9
1983: PPUSH
1984: LD_STRING DBrighton-B4
1986: PPUSH
1987: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1991: LD_EXP 9
1995: PPUSH
1996: LD_STRING DBrighton-B5
1998: PPUSH
1999: CALL_OW 88
// DialogueOff ;
2003: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
2007: LD_STRING C2
2009: PPUSH
2010: CALL_OW 337
// FirstAssaultRepelled := true ;
2014: LD_ADDR_EXP 4
2018: PUSH
2019: LD_INT 1
2021: ST_TO_ADDR
// RemoveUnit ( Bulldozers [ 1 ] ) ;
2022: LD_EXP 18
2026: PUSH
2027: LD_INT 1
2029: ARRAY
2030: PPUSH
2031: CALL_OW 64
// RemoveUnit ( Bulldozers [ 2 ] ) ;
2035: LD_EXP 18
2039: PUSH
2040: LD_INT 2
2042: ARRAY
2043: PPUSH
2044: CALL_OW 64
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
2048: LD_INT 22
2050: PUSH
2051: LD_INT 6
2053: PUSH
2054: EMPTY
2055: LIST
2056: LIST
2057: PPUSH
2058: CALL_OW 69
2062: PPUSH
2063: CALL_OW 181
// end ;
2067: PPOPN 2
2069: END
// every 0 0$1 trigger FirstAssaultRepelled do var unit , insideUnit ;
2070: LD_EXP 4
2074: IFFALSE 2239
2076: GO 2078
2078: DISABLE
2079: LD_INT 0
2081: PPUSH
2082: PPUSH
// begin enable ;
2083: ENABLE
// if FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) = 0 then
2084: LD_INT 5
2086: PPUSH
2087: LD_INT 22
2089: PUSH
2090: LD_INT 6
2092: PUSH
2093: EMPTY
2094: LIST
2095: LIST
2096: PUSH
2097: EMPTY
2098: LIST
2099: PPUSH
2100: CALL_OW 70
2104: PUSH
2105: LD_INT 0
2107: EQUAL
2108: IFFALSE 2112
// exit ;
2110: GO 2239
// for unit in FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) do
2112: LD_ADDR_VAR 0 1
2116: PUSH
2117: LD_INT 5
2119: PPUSH
2120: LD_INT 22
2122: PUSH
2123: LD_INT 6
2125: PUSH
2126: EMPTY
2127: LIST
2128: LIST
2129: PUSH
2130: EMPTY
2131: LIST
2132: PPUSH
2133: CALL_OW 70
2137: PUSH
2138: FOR_IN
2139: IFFALSE 2237
// begin SetSide ( unit , 3 ) ;
2141: LD_VAR 0 1
2145: PPUSH
2146: LD_INT 3
2148: PPUSH
2149: CALL_OW 235
// if ( GetType ( unit ) = unit_vehicle ) then
2153: LD_VAR 0 1
2157: PPUSH
2158: CALL_OW 247
2162: PUSH
2163: LD_INT 2
2165: EQUAL
2166: IFFALSE 2202
// for insideUnit in UnitsInside ( unit ) do
2168: LD_ADDR_VAR 0 2
2172: PUSH
2173: LD_VAR 0 1
2177: PPUSH
2178: CALL_OW 313
2182: PUSH
2183: FOR_IN
2184: IFFALSE 2200
// SetSide ( insideUnit , 3 ) ;
2186: LD_VAR 0 2
2190: PPUSH
2191: LD_INT 3
2193: PPUSH
2194: CALL_OW 235
2198: GO 2183
2200: POP
2201: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
2202: LD_ADDR_EXP 65
2206: PUSH
2207: LD_EXP 65
2211: PPUSH
2212: LD_INT 1
2214: PPUSH
2215: LD_INT 22
2217: PUSH
2218: LD_INT 3
2220: PUSH
2221: EMPTY
2222: LIST
2223: LIST
2224: PPUSH
2225: CALL_OW 69
2229: PPUSH
2230: CALL_OW 1
2234: ST_TO_ADDR
// end ;
2235: GO 2138
2237: POP
2238: POP
// end ;
2239: PPOPN 2
2241: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
2242: LD_EXP 4
2246: PUSH
2247: LD_EXP 41
2251: PUSH
2252: LD_INT 0
2254: GREATER
2255: AND
2256: IFFALSE 2276
2258: GO 2260
2260: DISABLE
// begin enable ;
2261: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
2262: LD_ADDR_EXP 41
2266: PUSH
2267: LD_EXP 41
2271: PUSH
2272: LD_INT 35
2274: MINUS
2275: ST_TO_ADDR
// end ;
2276: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
2277: LD_EXP 41
2281: PUSH
2282: LD_INT 0
2284: EQUAL
2285: IFFALSE 2391
2287: GO 2289
2289: DISABLE
// begin JMMReinforcement ;
2290: CALL 5279 0 0
// DialogueOn ;
2294: CALL_OW 6
// CenterOnUnits ( JMM ) ;
2298: LD_EXP 37
2302: PPUSH
2303: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
2307: LD_EXP 37
2311: PPUSH
2312: LD_STRING DJMM-F1
2314: PPUSH
2315: CALL_OW 88
// if RussiansDefeated then
2319: LD_EXP 44
2323: IFFALSE 2349
// begin AddMedal ( Russians , 1 ) ;
2325: LD_STRING Russians
2327: PPUSH
2328: LD_INT 1
2330: PPUSH
2331: CALL_OW 101
// Say ( Brighton , DBrighton-F1a ) ;
2335: LD_EXP 9
2339: PPUSH
2340: LD_STRING DBrighton-F1a
2342: PPUSH
2343: CALL_OW 88
// end else
2347: GO 2379
// begin AddMedal ( Russians , - 1 ) ;
2349: LD_STRING Russians
2351: PPUSH
2352: LD_INT 1
2354: NEG
2355: PPUSH
2356: CALL_OW 101
// Say ( Brighton , DBrighton-F1 ) ;
2360: LD_EXP 9
2364: PPUSH
2365: LD_STRING DBrighton-F1
2367: PPUSH
2368: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2372: LD_STRING C3
2374: PPUSH
2375: CALL_OW 337
// end ; DialogueOff ;
2379: CALL_OW 7
// JMM_Arrived := true ;
2383: LD_ADDR_EXP 6
2387: PUSH
2388: LD_INT 1
2390: ST_TO_ADDR
// end ;
2391: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2392: LD_EXP 6
2396: PUSH
2397: LD_INT 1
2399: PPUSH
2400: LD_EXP 19
2404: PPUSH
2405: CALL_OW 292
2409: AND
2410: IFFALSE 2439
2412: GO 2414
2414: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2415: LD_EXP 19
2419: PPUSH
2420: LD_STRING DBurlak
2422: PPUSH
2423: CALL_OW 88
// Say ( JMM , DJMM ) ;
2427: LD_EXP 37
2431: PPUSH
2432: LD_STRING DJMM
2434: PPUSH
2435: CALL_OW 88
// end ;
2439: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2440: LD_INT 1
2442: PUSH
2443: LD_INT 22
2445: PUSH
2446: LD_INT 1
2448: PUSH
2449: EMPTY
2450: LIST
2451: LIST
2452: PUSH
2453: LD_INT 2
2455: PUSH
2456: LD_INT 34
2458: PUSH
2459: LD_INT 9
2461: PUSH
2462: EMPTY
2463: LIST
2464: LIST
2465: PUSH
2466: LD_INT 35
2468: PUSH
2469: LD_INT 9
2471: PUSH
2472: EMPTY
2473: LIST
2474: LIST
2475: PUSH
2476: EMPTY
2477: LIST
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: LIST
2485: PPUSH
2486: CALL_OW 69
2490: PUSH
2491: LD_INT 1
2493: GREATER
2494: IFFALSE 2507
2496: GO 2498
2498: DISABLE
// LaserBuilt := true ;
2499: LD_ADDR_EXP 7
2503: PUSH
2504: LD_INT 1
2506: ST_TO_ADDR
2507: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2508: LD_EXP 8
2512: PUSH
2513: LD_INT 6
2515: PPUSH
2516: LD_INT 1
2518: PUSH
2519: LD_INT 22
2521: PUSH
2522: LD_INT 1
2524: PUSH
2525: EMPTY
2526: LIST
2527: LIST
2528: PUSH
2529: LD_INT 35
2531: PUSH
2532: LD_INT 9
2534: PUSH
2535: EMPTY
2536: LIST
2537: LIST
2538: PUSH
2539: EMPTY
2540: LIST
2541: LIST
2542: PUSH
2543: EMPTY
2544: LIST
2545: LIST
2546: PPUSH
2547: CALL_OW 69
2551: PPUSH
2552: LD_EXP 16
2556: PPUSH
2557: CALL_OW 310
2561: PPUSH
2562: CALL_OW 74
2566: PPUSH
2567: CALL_OW 292
2571: AND
2572: IFFALSE 2601
2574: GO 2576
2576: DISABLE
// begin Say ( Sevi , DDeath-Vse-2 ) ;
2577: LD_EXP 16
2581: PPUSH
2582: LD_STRING DDeath-Vse-2
2584: PPUSH
2585: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2589: LD_EXP 13
2593: PPUSH
2594: LD_STRING DDeath-Yas-2
2596: PPUSH
2597: CALL_OW 88
// end ;
2601: END
// every 0 0$1 trigger MissionStart and GetResourceArea ( CratesArea , mat_cans ) < 20 do
2602: LD_EXP 1
2606: PUSH
2607: LD_INT 12
2609: PPUSH
2610: LD_INT 1
2612: PPUSH
2613: CALL_OW 287
2617: PUSH
2618: LD_INT 20
2620: LESS
2621: AND
2622: IFFALSE 2664
2624: GO 2626
2626: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2627: LD_INT 1750
2629: PPUSH
2630: LD_INT 4900
2632: PPUSH
2633: CALL_OW 12
2637: PPUSH
2638: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2642: LD_INT 2
2644: PPUSH
2645: LD_INT 5
2647: PPUSH
2648: CALL_OW 12
2652: PPUSH
2653: LD_INT 12
2655: PPUSH
2656: LD_INT 1
2658: PPUSH
2659: CALL_OW 55
// enable ;
2663: ENABLE
// end ;
2664: END
// every 0 0$1 trigger FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) do var un , x , y ;
2665: LD_INT 17
2667: PPUSH
2668: LD_INT 81
2670: PUSH
2671: LD_INT 1
2673: PUSH
2674: EMPTY
2675: LIST
2676: LIST
2677: PPUSH
2678: CALL_OW 70
2682: IFFALSE 2808
2684: GO 2686
2686: DISABLE
2687: LD_INT 0
2689: PPUSH
2690: PPUSH
2691: PPUSH
// begin un := FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) [ 1 ] ;
2692: LD_ADDR_VAR 0 1
2696: PUSH
2697: LD_INT 17
2699: PPUSH
2700: LD_INT 81
2702: PUSH
2703: LD_INT 1
2705: PUSH
2706: EMPTY
2707: LIST
2708: LIST
2709: PPUSH
2710: CALL_OW 70
2714: PUSH
2715: LD_INT 1
2717: ARRAY
2718: ST_TO_ADDR
// x := GetX ( un ) ;
2719: LD_ADDR_VAR 0 2
2723: PUSH
2724: LD_VAR 0 1
2728: PPUSH
2729: CALL_OW 250
2733: ST_TO_ADDR
// y := GetY ( un ) ;
2734: LD_ADDR_VAR 0 3
2738: PUSH
2739: LD_VAR 0 1
2743: PPUSH
2744: CALL_OW 251
2748: ST_TO_ADDR
// PlaceSeeing ( x , y , 1 , - 12 ) ;
2749: LD_VAR 0 2
2753: PPUSH
2754: LD_VAR 0 3
2758: PPUSH
2759: LD_INT 1
2761: PPUSH
2762: LD_INT 12
2764: NEG
2765: PPUSH
2766: CALL_OW 330
// CenterNowOnUnits ( un ) ;
2770: LD_VAR 0 1
2774: PPUSH
2775: CALL_OW 87
// Say ( Brighton , DBrighton-E1 ) ;
2779: LD_EXP 9
2783: PPUSH
2784: LD_STRING DBrighton-E1
2786: PPUSH
2787: CALL_OW 88
// RemoveSeeing ( x , y , 1 ) ;
2791: LD_VAR 0 2
2795: PPUSH
2796: LD_VAR 0 3
2800: PPUSH
2801: LD_INT 1
2803: PPUSH
2804: CALL_OW 331
// end ;
2808: PPOPN 3
2810: END
// every 0 0$1 trigger MissionStart do
2811: LD_EXP 1
2815: IFFALSE 2838
2817: GO 2819
2819: DISABLE
// begin enable ;
2820: ENABLE
// display_Strings := [ #tick , tick ] ;
2821: LD_ADDR_OWVAR 47
2825: PUSH
2826: LD_STRING #tick
2828: PUSH
2829: LD_OWVAR 1
2833: PUSH
2834: EMPTY
2835: LIST
2836: LIST
2837: ST_TO_ADDR
// end ; end_of_file
2838: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2839: LD_INT 0
2841: PPUSH
// uc_side := 1 ;
2842: LD_ADDR_OWVAR 20
2846: PUSH
2847: LD_INT 1
2849: ST_TO_ADDR
// hc_class = class_soldier ;
2850: LD_ADDR_OWVAR 28
2854: PUSH
2855: LD_INT 1
2857: ST_TO_ADDR
// uc_nation := nation_american ;
2858: LD_ADDR_OWVAR 21
2862: PUSH
2863: LD_INT 1
2865: ST_TO_ADDR
// hc_sex = sex_male ;
2866: LD_ADDR_OWVAR 27
2870: PUSH
2871: LD_INT 1
2873: ST_TO_ADDR
// hc_importance = 110 ;
2874: LD_ADDR_OWVAR 32
2878: PUSH
2879: LD_INT 110
2881: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2882: LD_ADDR_OWVAR 30
2886: PUSH
2887: LD_INT 5
2889: PUSH
2890: LD_INT 4
2892: PUSH
2893: LD_INT 5
2895: PUSH
2896: LD_INT 3
2898: PUSH
2899: EMPTY
2900: LIST
2901: LIST
2902: LIST
2903: LIST
2904: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2905: LD_ADDR_OWVAR 31
2909: PUSH
2910: LD_INT 9
2912: PUSH
2913: LD_INT 6
2915: PUSH
2916: LD_INT 7
2918: PUSH
2919: LD_INT 6
2921: PUSH
2922: EMPTY
2923: LIST
2924: LIST
2925: LIST
2926: LIST
2927: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2928: LD_ADDR_OWVAR 29
2932: PUSH
2933: LD_INT 12
2935: PUSH
2936: LD_INT 10
2938: PUSH
2939: EMPTY
2940: LIST
2941: LIST
2942: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2943: LD_ADDR_OWVAR 26
2947: PUSH
2948: LD_STRING Gerard Brighton
2950: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2951: LD_ADDR_OWVAR 33
2955: PUSH
2956: LD_STRING Beta_Skirmish
2958: ST_TO_ADDR
// hc_face_number := 1 ;
2959: LD_ADDR_OWVAR 34
2963: PUSH
2964: LD_INT 1
2966: ST_TO_ADDR
// Brighton := CreateHuman ;
2967: LD_ADDR_EXP 9
2971: PUSH
2972: CALL_OW 44
2976: ST_TO_ADDR
// uc_nation := nation_american ;
2977: LD_ADDR_OWVAR 21
2981: PUSH
2982: LD_INT 1
2984: ST_TO_ADDR
// hc_importance = 80 ;
2985: LD_ADDR_OWVAR 32
2989: PUSH
2990: LD_INT 80
2992: ST_TO_ADDR
// hc_sex = sex_male ;
2993: LD_ADDR_OWVAR 27
2997: PUSH
2998: LD_INT 1
3000: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
3001: LD_ADDR_OWVAR 30
3005: PUSH
3006: LD_INT 5
3008: PUSH
3009: LD_INT 5
3011: PUSH
3012: LD_INT 3
3014: PUSH
3015: LD_INT 1
3017: PUSH
3018: EMPTY
3019: LIST
3020: LIST
3021: LIST
3022: LIST
3023: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
3024: LD_ADDR_OWVAR 31
3028: PUSH
3029: LD_INT 7
3031: PUSH
3032: LD_INT 6
3034: PUSH
3035: LD_INT 5
3037: PUSH
3038: LD_INT 3
3040: PUSH
3041: EMPTY
3042: LIST
3043: LIST
3044: LIST
3045: LIST
3046: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
3047: LD_ADDR_OWVAR 29
3051: PUSH
3052: LD_INT 10
3054: PUSH
3055: LD_INT 10
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: ST_TO_ADDR
// hc_name := Brian Palmer ;
3062: LD_ADDR_OWVAR 26
3066: PUSH
3067: LD_STRING Brian Palmer
3069: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
3070: LD_ADDR_OWVAR 33
3074: PUSH
3075: LD_STRING Beta_Skirmish
3077: ST_TO_ADDR
// hc_face_number := 3 ;
3078: LD_ADDR_OWVAR 34
3082: PUSH
3083: LD_INT 3
3085: ST_TO_ADDR
// Palmer := CreateHuman ;
3086: LD_ADDR_EXP 10
3090: PUSH
3091: CALL_OW 44
3095: ST_TO_ADDR
// hc_class = class_scientistic ;
3096: LD_ADDR_OWVAR 28
3100: PUSH
3101: LD_INT 4
3103: ST_TO_ADDR
// uc_nation := nation_american ;
3104: LD_ADDR_OWVAR 21
3108: PUSH
3109: LD_INT 1
3111: ST_TO_ADDR
// hc_importance = 70 ;
3112: LD_ADDR_OWVAR 32
3116: PUSH
3117: LD_INT 70
3119: ST_TO_ADDR
// hc_sex = sex_female ;
3120: LD_ADDR_OWVAR 27
3124: PUSH
3125: LD_INT 2
3127: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
3128: LD_ADDR_OWVAR 30
3132: PUSH
3133: LD_INT 3
3135: PUSH
3136: LD_INT 2
3138: PUSH
3139: LD_INT 4
3141: PUSH
3142: LD_INT 6
3144: PUSH
3145: EMPTY
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
3151: LD_ADDR_OWVAR 31
3155: PUSH
3156: LD_INT 4
3158: PUSH
3159: LD_INT 2
3161: PUSH
3162: LD_INT 5
3164: PUSH
3165: LD_INT 8
3167: PUSH
3168: EMPTY
3169: LIST
3170: LIST
3171: LIST
3172: LIST
3173: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
3174: LD_ADDR_OWVAR 29
3178: PUSH
3179: LD_INT 10
3181: PUSH
3182: LD_INT 10
3184: PUSH
3185: EMPTY
3186: LIST
3187: LIST
3188: ST_TO_ADDR
// hc_name := Megan Armitage ;
3189: LD_ADDR_OWVAR 26
3193: PUSH
3194: LD_STRING Megan Armitage
3196: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
3197: LD_ADDR_OWVAR 33
3201: PUSH
3202: LD_STRING Beta_Skirmish
3204: ST_TO_ADDR
// hc_face_number := 4 ;
3205: LD_ADDR_OWVAR 34
3209: PUSH
3210: LD_INT 4
3212: ST_TO_ADDR
// Megan := CreateHuman ;
3213: LD_ADDR_EXP 11
3217: PUSH
3218: CALL_OW 44
3222: ST_TO_ADDR
// end ;
3223: LD_VAR 0 1
3227: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
3228: LD_INT 0
3230: PPUSH
3231: PPUSH
3232: PPUSH
3233: PPUSH
3234: PPUSH
// uc_side := 1 ;
3235: LD_ADDR_OWVAR 20
3239: PUSH
3240: LD_INT 1
3242: ST_TO_ADDR
// uc_nation := nation_american ;
3243: LD_ADDR_OWVAR 21
3247: PUSH
3248: LD_INT 1
3250: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
3251: LD_ADDR_VAR 0 2
3255: PUSH
3256: LD_INT 22
3258: PUSH
3259: LD_INT 1
3261: PUSH
3262: EMPTY
3263: LIST
3264: LIST
3265: PUSH
3266: LD_INT 30
3268: PUSH
3269: LD_INT 32
3271: PUSH
3272: EMPTY
3273: LIST
3274: LIST
3275: PUSH
3276: EMPTY
3277: LIST
3278: LIST
3279: PPUSH
3280: CALL_OW 69
3284: PUSH
3285: FOR_IN
3286: IFFALSE 3341
// PlaceWeaponTurret ( i , [ us_light_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
3288: LD_VAR 0 2
3292: PPUSH
3293: LD_INT 3
3295: PUSH
3296: LD_INT 3
3298: PUSH
3299: LD_INT 4
3301: PUSH
3302: LD_INT 5
3304: PUSH
3305: LD_INT 11
3307: PUSH
3308: LD_INT 3
3310: PUSH
3311: LD_INT 4
3313: PUSH
3314: EMPTY
3315: LIST
3316: LIST
3317: LIST
3318: LIST
3319: LIST
3320: LIST
3321: LIST
3322: PUSH
3323: LD_INT 1
3325: PPUSH
3326: LD_INT 7
3328: PPUSH
3329: CALL_OW 12
3333: ARRAY
3334: PPUSH
3335: CALL_OW 431
3339: GO 3285
3341: POP
3342: POP
// hc_name :=  ;
3343: LD_ADDR_OWVAR 26
3347: PUSH
3348: LD_STRING 
3350: ST_TO_ADDR
// hc_gallery :=  ;
3351: LD_ADDR_OWVAR 33
3355: PUSH
3356: LD_STRING 
3358: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
3359: LD_ADDR_VAR 0 2
3363: PUSH
3364: DOUBLE
3365: LD_INT 1
3367: DEC
3368: ST_TO_ADDR
3369: LD_INT 6
3371: PUSH
3372: LD_INT 5
3374: PUSH
3375: LD_INT 5
3377: PUSH
3378: EMPTY
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_OWVAR 67
3387: ARRAY
3388: PUSH
3389: FOR_TO
3390: IFFALSE 3448
// begin PrepareSoldier ( 1 , game_skill ) ;
3392: LD_INT 1
3394: PPUSH
3395: LD_EXP 39
3399: PPUSH
3400: CALL_OW 381
// un := CreateHuman ;
3404: LD_ADDR_VAR 0 4
3408: PUSH
3409: CALL_OW 44
3413: ST_TO_ADDR
// filter := filter ^ un ;
3414: LD_ADDR_VAR 0 3
3418: PUSH
3419: LD_VAR 0 3
3423: PUSH
3424: LD_VAR 0 4
3428: ADD
3429: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3430: LD_ADDR_VAR 0 5
3434: PUSH
3435: LD_VAR 0 5
3439: PUSH
3440: LD_VAR 0 4
3444: ADD
3445: ST_TO_ADDR
// end ;
3446: GO 3389
3448: POP
3449: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
3450: LD_ADDR_VAR 0 2
3454: PUSH
3455: DOUBLE
3456: LD_INT 1
3458: DEC
3459: ST_TO_ADDR
3460: LD_INT 3
3462: PUSH
3463: LD_INT 2
3465: PUSH
3466: LD_INT 2
3468: PUSH
3469: EMPTY
3470: LIST
3471: LIST
3472: LIST
3473: PUSH
3474: LD_OWVAR 67
3478: ARRAY
3479: PUSH
3480: FOR_TO
3481: IFFALSE 3535
// begin PrepareEngineer ( 0 , game_skill ) ;
3483: LD_INT 0
3485: PPUSH
3486: LD_EXP 39
3490: PPUSH
3491: CALL_OW 382
// un := CreateHuman ;
3495: LD_ADDR_VAR 0 4
3499: PUSH
3500: CALL_OW 44
3504: ST_TO_ADDR
// filter := filter ^ un ;
3505: LD_ADDR_VAR 0 3
3509: PUSH
3510: LD_VAR 0 3
3514: PUSH
3515: LD_VAR 0 4
3519: ADD
3520: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3521: LD_VAR 0 4
3525: PPUSH
3526: LD_INT 3
3528: PPUSH
3529: CALL_OW 52
// end ;
3533: GO 3480
3535: POP
3536: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3537: LD_ADDR_VAR 0 2
3541: PUSH
3542: DOUBLE
3543: LD_INT 1
3545: DEC
3546: ST_TO_ADDR
3547: LD_INT 4
3549: PUSH
3550: LD_INT 3
3552: PUSH
3553: LD_INT 3
3555: PUSH
3556: EMPTY
3557: LIST
3558: LIST
3559: LIST
3560: PUSH
3561: LD_OWVAR 67
3565: ARRAY
3566: PUSH
3567: FOR_TO
3568: IFFALSE 3622
// begin PrepareMechanic ( 0 , game_skill ) ;
3570: LD_INT 0
3572: PPUSH
3573: LD_EXP 39
3577: PPUSH
3578: CALL_OW 383
// un := CreateHuman ;
3582: LD_ADDR_VAR 0 4
3586: PUSH
3587: CALL_OW 44
3591: ST_TO_ADDR
// filter := filter ^ un ;
3592: LD_ADDR_VAR 0 3
3596: PUSH
3597: LD_VAR 0 3
3601: PUSH
3602: LD_VAR 0 4
3606: ADD
3607: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3608: LD_VAR 0 4
3612: PPUSH
3613: LD_INT 8
3615: PPUSH
3616: CALL_OW 52
// end ;
3620: GO 3567
3622: POP
3623: POP
// for i = 1 to 2 do
3624: LD_ADDR_VAR 0 2
3628: PUSH
3629: DOUBLE
3630: LD_INT 1
3632: DEC
3633: ST_TO_ADDR
3634: LD_INT 2
3636: PUSH
3637: FOR_TO
3638: IFFALSE 3692
// begin PrepareScientist ( 0 , game_skill ) ;
3640: LD_INT 0
3642: PPUSH
3643: LD_EXP 39
3647: PPUSH
3648: CALL_OW 384
// un := CreateHuman ;
3652: LD_ADDR_VAR 0 4
3656: PUSH
3657: CALL_OW 44
3661: ST_TO_ADDR
// filter := filter ^ un ;
3662: LD_ADDR_VAR 0 3
3666: PUSH
3667: LD_VAR 0 3
3671: PUSH
3672: LD_VAR 0 4
3676: ADD
3677: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3678: LD_VAR 0 4
3682: PPUSH
3683: LD_INT 14
3685: PPUSH
3686: CALL_OW 52
// end ;
3690: GO 3637
3692: POP
3693: POP
// for i = 1 to soldiers do
3694: LD_ADDR_VAR 0 2
3698: PUSH
3699: DOUBLE
3700: LD_INT 1
3702: DEC
3703: ST_TO_ADDR
3704: LD_VAR 0 5
3708: PUSH
3709: FOR_TO
3710: IFFALSE 3735
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3712: LD_VAR 0 5
3716: PUSH
3717: LD_VAR 0 2
3721: ARRAY
3722: PPUSH
3723: LD_INT 1
3725: PPUSH
3726: LD_INT 0
3728: PPUSH
3729: CALL_OW 49
3733: GO 3709
3735: POP
3736: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3737: LD_EXP 9
3741: PPUSH
3742: LD_INT 51
3744: PPUSH
3745: LD_INT 43
3747: PPUSH
3748: LD_INT 0
3750: PPUSH
3751: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3755: LD_EXP 10
3759: PPUSH
3760: LD_INT 55
3762: PPUSH
3763: LD_INT 58
3765: PPUSH
3766: LD_INT 0
3768: PPUSH
3769: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3773: LD_EXP 11
3777: PPUSH
3778: LD_INT 39
3780: PPUSH
3781: LD_INT 36
3783: PPUSH
3784: LD_INT 0
3786: PPUSH
3787: CALL_OW 48
// BetaSquad := filter diff 0 ;
3791: LD_ADDR_EXP 12
3795: PUSH
3796: LD_VAR 0 3
3800: PUSH
3801: LD_INT 0
3803: DIFF
3804: ST_TO_ADDR
// end ;
3805: LD_VAR 0 1
3809: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3810: LD_INT 0
3812: PPUSH
3813: PPUSH
3814: PPUSH
3815: PPUSH
3816: PPUSH
3817: PPUSH
// uc_side := 6 ;
3818: LD_ADDR_OWVAR 20
3822: PUSH
3823: LD_INT 6
3825: ST_TO_ADDR
// uc_nation := nation_russian ;
3826: LD_ADDR_OWVAR 21
3830: PUSH
3831: LD_INT 3
3833: ST_TO_ADDR
// soldiers := [ ] ;
3834: LD_ADDR_VAR 0 4
3838: PUSH
3839: EMPTY
3840: ST_TO_ADDR
// vehs := [ ] ;
3841: LD_ADDR_VAR 0 6
3845: PUSH
3846: EMPTY
3847: ST_TO_ADDR
// RUArmada := [ ] ;
3848: LD_ADDR_EXP 17
3852: PUSH
3853: EMPTY
3854: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3855: LD_ADDR_EXP 13
3859: PUSH
3860: LD_STRING Yashin
3862: PPUSH
3863: CALL_OW 25
3867: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3868: LD_ADDR_EXP 14
3872: PUSH
3873: LD_STRING Popov
3875: PPUSH
3876: CALL_OW 25
3880: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3881: LD_ADDR_EXP 15
3885: PUSH
3886: LD_STRING Gaydar
3888: PPUSH
3889: CALL_OW 25
3893: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3894: LD_ADDR_EXP 16
3898: PUSH
3899: LD_STRING Vsevolod
3901: PPUSH
3902: CALL_OW 25
3906: ST_TO_ADDR
// for i = 1 to 16 do
3907: LD_ADDR_VAR 0 2
3911: PUSH
3912: DOUBLE
3913: LD_INT 1
3915: DEC
3916: ST_TO_ADDR
3917: LD_INT 16
3919: PUSH
3920: FOR_TO
3921: IFFALSE 3963
// begin PrepareSoldier ( 0 , game_eskill ) ;
3923: LD_INT 0
3925: PPUSH
3926: LD_EXP 40
3930: PPUSH
3931: CALL_OW 381
// un := CreateHuman ;
3935: LD_ADDR_VAR 0 5
3939: PUSH
3940: CALL_OW 44
3944: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3945: LD_ADDR_VAR 0 4
3949: PUSH
3950: LD_VAR 0 4
3954: PUSH
3955: LD_VAR 0 5
3959: ADD
3960: ST_TO_ADDR
// end ;
3961: GO 3920
3963: POP
3964: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3965: LD_ADDR_VAR 0 4
3969: PUSH
3970: LD_EXP 13
3974: PUSH
3975: LD_EXP 14
3979: ADD
3980: PUSH
3981: LD_EXP 15
3985: ADD
3986: PUSH
3987: LD_EXP 16
3991: ADD
3992: PUSH
3993: LD_VAR 0 4
3997: ADD
3998: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3999: LD_INT 24
4001: PPUSH
4002: LD_INT 3
4004: PPUSH
4005: LD_INT 1
4007: PPUSH
4008: LD_INT 46
4010: PPUSH
4011: LD_INT 100
4013: PPUSH
4014: CALL 18382 0 5
// for i = 1 to 8 do
4018: LD_ADDR_VAR 0 2
4022: PUSH
4023: DOUBLE
4024: LD_INT 1
4026: DEC
4027: ST_TO_ADDR
4028: LD_INT 8
4030: PUSH
4031: FOR_TO
4032: IFFALSE 4115
// begin vehicle := CreateVehicle ;
4034: LD_ADDR_VAR 0 3
4038: PUSH
4039: CALL_OW 45
4043: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4044: LD_VAR 0 4
4048: PUSH
4049: LD_INT 1
4051: ARRAY
4052: PPUSH
4053: LD_VAR 0 3
4057: PPUSH
4058: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4062: LD_ADDR_VAR 0 4
4066: PUSH
4067: LD_VAR 0 4
4071: PUSH
4072: LD_VAR 0 4
4076: PUSH
4077: LD_INT 1
4079: ARRAY
4080: DIFF
4081: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4082: LD_VAR 0 3
4086: PPUSH
4087: LD_INT 5
4089: PPUSH
4090: LD_INT 0
4092: PPUSH
4093: CALL_OW 49
// vehs := vehs ^ vehicle ;
4097: LD_ADDR_VAR 0 6
4101: PUSH
4102: LD_VAR 0 6
4106: PUSH
4107: LD_VAR 0 3
4111: ADD
4112: ST_TO_ADDR
// end ;
4113: GO 4031
4115: POP
4116: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
4117: LD_INT 24
4119: PPUSH
4120: LD_INT 3
4122: PPUSH
4123: LD_INT 1
4125: PPUSH
4126: LD_INT 43
4128: PPUSH
4129: LD_INT 100
4131: PPUSH
4132: CALL 18382 0 5
// for i = 1 to 8 do
4136: LD_ADDR_VAR 0 2
4140: PUSH
4141: DOUBLE
4142: LD_INT 1
4144: DEC
4145: ST_TO_ADDR
4146: LD_INT 8
4148: PUSH
4149: FOR_TO
4150: IFFALSE 4233
// begin vehicle := CreateVehicle ;
4152: LD_ADDR_VAR 0 3
4156: PUSH
4157: CALL_OW 45
4161: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4162: LD_VAR 0 4
4166: PUSH
4167: LD_INT 1
4169: ARRAY
4170: PPUSH
4171: LD_VAR 0 3
4175: PPUSH
4176: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4180: LD_ADDR_VAR 0 4
4184: PUSH
4185: LD_VAR 0 4
4189: PUSH
4190: LD_VAR 0 4
4194: PUSH
4195: LD_INT 1
4197: ARRAY
4198: DIFF
4199: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4200: LD_VAR 0 3
4204: PPUSH
4205: LD_INT 5
4207: PPUSH
4208: LD_INT 0
4210: PPUSH
4211: CALL_OW 49
// vehs := vehs ^ vehicle ;
4215: LD_ADDR_VAR 0 6
4219: PUSH
4220: LD_VAR 0 6
4224: PUSH
4225: LD_VAR 0 3
4229: ADD
4230: ST_TO_ADDR
// end ;
4231: GO 4149
4233: POP
4234: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
4235: LD_INT 22
4237: PPUSH
4238: LD_INT 3
4240: PPUSH
4241: LD_INT 1
4243: PPUSH
4244: LD_INT 44
4246: PPUSH
4247: LD_INT 100
4249: PPUSH
4250: CALL 18382 0 5
// for i = 1 to 4 do
4254: LD_ADDR_VAR 0 2
4258: PUSH
4259: DOUBLE
4260: LD_INT 1
4262: DEC
4263: ST_TO_ADDR
4264: LD_INT 4
4266: PUSH
4267: FOR_TO
4268: IFFALSE 4351
// begin vehicle := CreateVehicle ;
4270: LD_ADDR_VAR 0 3
4274: PUSH
4275: CALL_OW 45
4279: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4280: LD_VAR 0 4
4284: PUSH
4285: LD_INT 1
4287: ARRAY
4288: PPUSH
4289: LD_VAR 0 3
4293: PPUSH
4294: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4298: LD_ADDR_VAR 0 4
4302: PUSH
4303: LD_VAR 0 4
4307: PUSH
4308: LD_VAR 0 4
4312: PUSH
4313: LD_INT 1
4315: ARRAY
4316: DIFF
4317: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4318: LD_VAR 0 3
4322: PPUSH
4323: LD_INT 5
4325: PPUSH
4326: LD_INT 0
4328: PPUSH
4329: CALL_OW 49
// vehs := vehs ^ vehicle ;
4333: LD_ADDR_VAR 0 6
4337: PUSH
4338: LD_VAR 0 6
4342: PUSH
4343: LD_VAR 0 3
4347: ADD
4348: ST_TO_ADDR
// end ;
4349: GO 4267
4351: POP
4352: POP
// RUArmada := vehs ;
4353: LD_ADDR_EXP 17
4357: PUSH
4358: LD_VAR 0 6
4362: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
4363: LD_EXP 13
4367: PPUSH
4368: CALL_OW 310
4372: PUSH
4373: LD_EXP 14
4377: PPUSH
4378: CALL_OW 310
4382: PUSH
4383: LD_EXP 15
4387: PPUSH
4388: CALL_OW 310
4392: PUSH
4393: LD_EXP 16
4397: PPUSH
4398: CALL_OW 310
4402: PUSH
4403: EMPTY
4404: LIST
4405: LIST
4406: LIST
4407: LIST
4408: PPUSH
4409: LD_INT 6
4411: NEG
4412: PPUSH
4413: CALL_OW 242
// end ;
4417: LD_VAR 0 1
4421: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
4422: LD_INT 0
4424: PPUSH
4425: PPUSH
4426: PPUSH
// uc_side := 6 ;
4427: LD_ADDR_OWVAR 20
4431: PUSH
4432: LD_INT 6
4434: ST_TO_ADDR
// uc_nation := nation_russian ;
4435: LD_ADDR_OWVAR 21
4439: PUSH
4440: LD_INT 3
4442: ST_TO_ADDR
// Bulldozers := [ ] ;
4443: LD_ADDR_EXP 18
4447: PUSH
4448: EMPTY
4449: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
4450: LD_INT 24
4452: PPUSH
4453: LD_INT 3
4455: PPUSH
4456: LD_INT 3
4458: PPUSH
4459: LD_INT 53
4461: PPUSH
4462: LD_INT 100
4464: PPUSH
4465: CALL 18382 0 5
// for i = 1 to 2 do
4469: LD_ADDR_VAR 0 2
4473: PUSH
4474: DOUBLE
4475: LD_INT 1
4477: DEC
4478: ST_TO_ADDR
4479: LD_INT 2
4481: PUSH
4482: FOR_TO
4483: IFFALSE 4528
// begin vehicle := CreateVehicle ;
4485: LD_ADDR_VAR 0 3
4489: PUSH
4490: CALL_OW 45
4494: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4495: LD_VAR 0 3
4499: PPUSH
4500: LD_INT 5
4502: PPUSH
4503: LD_INT 0
4505: PPUSH
4506: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4510: LD_ADDR_EXP 18
4514: PUSH
4515: LD_EXP 18
4519: PUSH
4520: LD_VAR 0 3
4524: ADD
4525: ST_TO_ADDR
// end ;
4526: GO 4482
4528: POP
4529: POP
// end ;
4530: LD_VAR 0 1
4534: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4535: LD_INT 0
4537: PPUSH
4538: PPUSH
4539: PPUSH
4540: PPUSH
// uc_side := 3 ;
4541: LD_ADDR_OWVAR 20
4545: PUSH
4546: LD_INT 3
4548: ST_TO_ADDR
// uc_nation := nation_russian ;
4549: LD_ADDR_OWVAR 21
4553: PUSH
4554: LD_INT 3
4556: ST_TO_ADDR
// hc_name :=  ;
4557: LD_ADDR_OWVAR 26
4561: PUSH
4562: LD_STRING 
4564: ST_TO_ADDR
// hc_gallery :=  ;
4565: LD_ADDR_OWVAR 33
4569: PUSH
4570: LD_STRING 
4572: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4573: LD_ADDR_EXP 19
4577: PUSH
4578: LD_STRING Burlak
4580: PPUSH
4581: CALL_OW 25
4585: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4586: LD_ADDR_EXP 20
4590: PUSH
4591: LD_STRING Gleb
4593: PPUSH
4594: CALL_OW 25
4598: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4599: LD_ADDR_EXP 21
4603: PUSH
4604: LD_STRING Furmanov
4606: PPUSH
4607: CALL_OW 25
4611: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4612: LD_ADDR_EXP 22
4616: PUSH
4617: LD_STRING Titov
4619: PPUSH
4620: CALL_OW 25
4624: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4625: LD_ADDR_EXP 23
4629: PUSH
4630: LD_STRING Scholtze
4632: PPUSH
4633: CALL_OW 25
4637: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4638: LD_ADDR_EXP 24
4642: PUSH
4643: LD_STRING Dolgov
4645: PPUSH
4646: CALL_OW 25
4650: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4651: LD_ADDR_EXP 25
4655: PUSH
4656: LD_STRING Kapitsova
4658: PPUSH
4659: CALL_OW 25
4663: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4664: LD_ADDR_EXP 26
4668: PUSH
4669: LD_STRING Karamazov
4671: PPUSH
4672: CALL_OW 25
4676: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4677: LD_ADDR_EXP 27
4681: PUSH
4682: LD_STRING Kirlenkova
4684: PPUSH
4685: CALL_OW 25
4689: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4690: LD_ADDR_EXP 28
4694: PUSH
4695: LD_STRING Kovalyuk
4697: PPUSH
4698: CALL_OW 25
4702: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4703: LD_ADDR_EXP 29
4707: PUSH
4708: LD_STRING Kozlov
4710: PPUSH
4711: CALL_OW 25
4715: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4716: LD_ADDR_EXP 30
4720: PUSH
4721: LD_STRING Kuzmov
4723: PPUSH
4724: CALL_OW 25
4728: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4729: LD_ADDR_EXP 31
4733: PUSH
4734: LD_STRING Lipshchin
4736: PPUSH
4737: CALL_OW 25
4741: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4742: LD_ADDR_EXP 32
4746: PUSH
4747: LD_STRING Oblukov
4749: PPUSH
4750: CALL_OW 25
4754: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4755: LD_ADDR_EXP 33
4759: PUSH
4760: LD_STRING Xavier2
4762: PPUSH
4763: CALL_OW 25
4767: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4768: LD_ADDR_EXP 34
4772: PUSH
4773: LD_STRING Gnyevko
4775: PPUSH
4776: CALL_OW 25
4780: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4781: LD_ADDR_EXP 35
4785: PUSH
4786: LD_STRING Belkov
4788: PPUSH
4789: CALL_OW 25
4793: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4794: LD_ADDR_VAR 0 3
4798: PUSH
4799: LD_EXP 19
4803: PUSH
4804: LD_EXP 20
4808: PUSH
4809: LD_EXP 21
4813: PUSH
4814: LD_EXP 22
4818: PUSH
4819: LD_EXP 23
4823: PUSH
4824: LD_EXP 24
4828: PUSH
4829: LD_EXP 25
4833: PUSH
4834: LD_EXP 26
4838: PUSH
4839: LD_EXP 27
4843: PUSH
4844: LD_EXP 28
4848: PUSH
4849: LD_EXP 29
4853: PUSH
4854: LD_EXP 30
4858: PUSH
4859: LD_EXP 31
4863: PUSH
4864: LD_EXP 32
4868: PUSH
4869: LD_EXP 33
4873: PUSH
4874: LD_EXP 34
4878: PUSH
4879: LD_EXP 35
4883: PUSH
4884: EMPTY
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: LIST
4890: LIST
4891: LIST
4892: LIST
4893: LIST
4894: LIST
4895: LIST
4896: LIST
4897: LIST
4898: LIST
4899: LIST
4900: LIST
4901: LIST
4902: ST_TO_ADDR
// for i = 1 to filter do
4903: LD_ADDR_VAR 0 2
4907: PUSH
4908: DOUBLE
4909: LD_INT 1
4911: DEC
4912: ST_TO_ADDR
4913: LD_VAR 0 3
4917: PUSH
4918: FOR_TO
4919: IFFALSE 4944
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4921: LD_VAR 0 3
4925: PUSH
4926: LD_VAR 0 2
4930: ARRAY
4931: PPUSH
4932: LD_INT 6
4934: PPUSH
4935: LD_INT 0
4937: PPUSH
4938: CALL_OW 49
4942: GO 4918
4944: POP
4945: POP
// end ;
4946: LD_VAR 0 1
4950: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4951: LD_INT 0
4953: PPUSH
4954: PPUSH
4955: PPUSH
4956: PPUSH
// uc_side := 3 ;
4957: LD_ADDR_OWVAR 20
4961: PUSH
4962: LD_INT 3
4964: ST_TO_ADDR
// uc_nation := nation_russian ;
4965: LD_ADDR_OWVAR 21
4969: PUSH
4970: LD_INT 3
4972: ST_TO_ADDR
// hc_name :=  ;
4973: LD_ADDR_OWVAR 26
4977: PUSH
4978: LD_STRING 
4980: ST_TO_ADDR
// hc_gallery :=  ;
4981: LD_ADDR_OWVAR 33
4985: PUSH
4986: LD_STRING 
4988: ST_TO_ADDR
// for i = 1 to 8 do
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: DOUBLE
4995: LD_INT 1
4997: DEC
4998: ST_TO_ADDR
4999: LD_INT 8
5001: PUSH
5002: FOR_TO
5003: IFFALSE 5045
// begin PrepareSoldier ( 0 , game_eskill ) ;
5005: LD_INT 0
5007: PPUSH
5008: LD_EXP 40
5012: PPUSH
5013: CALL_OW 381
// un := CreateHuman ;
5017: LD_ADDR_VAR 0 4
5021: PUSH
5022: CALL_OW 44
5026: ST_TO_ADDR
// filter := filter ^ un ;
5027: LD_ADDR_VAR 0 3
5031: PUSH
5032: LD_VAR 0 3
5036: PUSH
5037: LD_VAR 0 4
5041: ADD
5042: ST_TO_ADDR
// end ;
5043: GO 5002
5045: POP
5046: POP
// for i = 1 to 4 do
5047: LD_ADDR_VAR 0 2
5051: PUSH
5052: DOUBLE
5053: LD_INT 1
5055: DEC
5056: ST_TO_ADDR
5057: LD_INT 4
5059: PUSH
5060: FOR_TO
5061: IFFALSE 5103
// begin PrepareEngineer ( 0 , game_eskill ) ;
5063: LD_INT 0
5065: PPUSH
5066: LD_EXP 40
5070: PPUSH
5071: CALL_OW 382
// un := CreateHuman ;
5075: LD_ADDR_VAR 0 4
5079: PUSH
5080: CALL_OW 44
5084: ST_TO_ADDR
// filter := filter ^ un ;
5085: LD_ADDR_VAR 0 3
5089: PUSH
5090: LD_VAR 0 3
5094: PUSH
5095: LD_VAR 0 4
5099: ADD
5100: ST_TO_ADDR
// end ;
5101: GO 5060
5103: POP
5104: POP
// for i = 1 to 6 do
5105: LD_ADDR_VAR 0 2
5109: PUSH
5110: DOUBLE
5111: LD_INT 1
5113: DEC
5114: ST_TO_ADDR
5115: LD_INT 6
5117: PUSH
5118: FOR_TO
5119: IFFALSE 5161
// begin PrepareMechanic ( 0 , game_eskill ) ;
5121: LD_INT 0
5123: PPUSH
5124: LD_EXP 40
5128: PPUSH
5129: CALL_OW 383
// un := CreateHuman ;
5133: LD_ADDR_VAR 0 4
5137: PUSH
5138: CALL_OW 44
5142: ST_TO_ADDR
// filter := filter ^ un ;
5143: LD_ADDR_VAR 0 3
5147: PUSH
5148: LD_VAR 0 3
5152: PUSH
5153: LD_VAR 0 4
5157: ADD
5158: ST_TO_ADDR
// end ;
5159: GO 5118
5161: POP
5162: POP
// for i = 1 to 4 do
5163: LD_ADDR_VAR 0 2
5167: PUSH
5168: DOUBLE
5169: LD_INT 1
5171: DEC
5172: ST_TO_ADDR
5173: LD_INT 4
5175: PUSH
5176: FOR_TO
5177: IFFALSE 5219
// begin PrepareScientist ( 0 , game_eskill ) ;
5179: LD_INT 0
5181: PPUSH
5182: LD_EXP 40
5186: PPUSH
5187: CALL_OW 384
// un := CreateHuman ;
5191: LD_ADDR_VAR 0 4
5195: PUSH
5196: CALL_OW 44
5200: ST_TO_ADDR
// filter := filter ^ un ;
5201: LD_ADDR_VAR 0 3
5205: PUSH
5206: LD_VAR 0 3
5210: PUSH
5211: LD_VAR 0 4
5215: ADD
5216: ST_TO_ADDR
// end ;
5217: GO 5176
5219: POP
5220: POP
// for i = 1 to filter do
5221: LD_ADDR_VAR 0 2
5225: PUSH
5226: DOUBLE
5227: LD_INT 1
5229: DEC
5230: ST_TO_ADDR
5231: LD_VAR 0 3
5235: PUSH
5236: FOR_TO
5237: IFFALSE 5262
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
5239: LD_VAR 0 3
5243: PUSH
5244: LD_VAR 0 2
5248: ARRAY
5249: PPUSH
5250: LD_INT 6
5252: PPUSH
5253: LD_INT 0
5255: PPUSH
5256: CALL_OW 49
5260: GO 5236
5262: POP
5263: POP
// RU_SecondPersonnel := filter ;
5264: LD_ADDR_EXP 36
5268: PUSH
5269: LD_VAR 0 3
5273: ST_TO_ADDR
// end ;
5274: LD_VAR 0 1
5278: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
5279: LD_INT 0
5281: PPUSH
5282: PPUSH
5283: PPUSH
5284: PPUSH
5285: PPUSH
5286: PPUSH
5287: PPUSH
// uc_side := 1 ;
5288: LD_ADDR_OWVAR 20
5292: PUSH
5293: LD_INT 1
5295: ST_TO_ADDR
// uc_nation := nation_american ;
5296: LD_ADDR_OWVAR 21
5300: PUSH
5301: LD_INT 1
5303: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
5304: LD_ADDR_EXP 37
5308: PUSH
5309: LD_STRING JMM
5311: PPUSH
5312: CALL_OW 25
5316: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
5317: LD_EXP 37
5321: PPUSH
5322: LD_INT 1
5324: PPUSH
5325: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
5329: LD_EXP 37
5333: PPUSH
5334: LD_INT 7
5336: PPUSH
5337: LD_INT 0
5339: PPUSH
5340: CALL_OW 49
// mechs := [ ] ;
5344: LD_ADDR_VAR 0 7
5348: PUSH
5349: EMPTY
5350: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
5351: LD_ADDR_VAR 0 2
5355: PUSH
5356: DOUBLE
5357: LD_INT 1
5359: DEC
5360: ST_TO_ADDR
5361: LD_INT 4
5363: PUSH
5364: LD_INT 3
5366: PUSH
5367: LD_INT 3
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: LIST
5374: PUSH
5375: LD_OWVAR 67
5379: ARRAY
5380: PUSH
5381: FOR_TO
5382: IFFALSE 5443
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
5384: LD_INT 0
5386: PPUSH
5387: LD_EXP 39
5391: PUSH
5392: LD_INT 1
5394: PLUS
5395: PPUSH
5396: CALL_OW 381
// un := CreateHuman ;
5400: LD_ADDR_VAR 0 4
5404: PUSH
5405: CALL_OW 44
5409: ST_TO_ADDR
// soldiers := soldiers ^ un ;
5410: LD_ADDR_VAR 0 3
5414: PUSH
5415: LD_VAR 0 3
5419: PUSH
5420: LD_VAR 0 4
5424: ADD
5425: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
5426: LD_VAR 0 4
5430: PPUSH
5431: LD_INT 7
5433: PPUSH
5434: LD_INT 0
5436: PPUSH
5437: CALL_OW 49
// end ;
5441: GO 5381
5443: POP
5444: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5445: LD_ADDR_VAR 0 2
5449: PUSH
5450: DOUBLE
5451: LD_INT 1
5453: DEC
5454: ST_TO_ADDR
5455: LD_INT 7
5457: PUSH
5458: LD_INT 6
5460: PUSH
5461: LD_INT 4
5463: PUSH
5464: EMPTY
5465: LIST
5466: LIST
5467: LIST
5468: PUSH
5469: LD_OWVAR 67
5473: ARRAY
5474: PUSH
5475: FOR_TO
5476: IFFALSE 5522
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5478: LD_INT 0
5480: PPUSH
5481: LD_EXP 39
5485: PUSH
5486: LD_INT 1
5488: PLUS
5489: PPUSH
5490: CALL_OW 383
// un := CreateHuman ;
5494: LD_ADDR_VAR 0 4
5498: PUSH
5499: CALL_OW 44
5503: ST_TO_ADDR
// mechs := mechs ^ un ;
5504: LD_ADDR_VAR 0 7
5508: PUSH
5509: LD_VAR 0 7
5513: PUSH
5514: LD_VAR 0 4
5518: ADD
5519: ST_TO_ADDR
// end ;
5520: GO 5475
5522: POP
5523: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5524: LD_INT 3
5526: PPUSH
5527: LD_INT 3
5529: PPUSH
5530: LD_INT 1
5532: PPUSH
5533: LD_INT 5
5535: PPUSH
5536: LD_INT 100
5538: PPUSH
5539: CALL 18382 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5543: LD_ADDR_VAR 0 2
5547: PUSH
5548: DOUBLE
5549: LD_INT 1
5551: DEC
5552: ST_TO_ADDR
5553: LD_INT 7
5555: PUSH
5556: LD_INT 6
5558: PUSH
5559: LD_INT 4
5561: PUSH
5562: EMPTY
5563: LIST
5564: LIST
5565: LIST
5566: PUSH
5567: LD_OWVAR 67
5571: ARRAY
5572: PUSH
5573: FOR_TO
5574: IFFALSE 5669
// begin vehicle := CreateVehicle ;
5576: LD_ADDR_VAR 0 6
5580: PUSH
5581: CALL_OW 45
5585: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5586: LD_VAR 0 7
5590: PUSH
5591: LD_INT 1
5593: ARRAY
5594: PPUSH
5595: LD_VAR 0 6
5599: PPUSH
5600: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5604: LD_ADDR_VAR 0 7
5608: PUSH
5609: LD_VAR 0 7
5613: PUSH
5614: LD_VAR 0 7
5618: PUSH
5619: LD_INT 1
5621: ARRAY
5622: DIFF
5623: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5624: LD_VAR 0 6
5628: PPUSH
5629: LD_INT 1
5631: PPUSH
5632: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5636: LD_VAR 0 6
5640: PPUSH
5641: LD_INT 7
5643: PPUSH
5644: LD_INT 0
5646: PPUSH
5647: CALL_OW 49
// vehs := vehs ^ vehicle ;
5651: LD_ADDR_VAR 0 5
5655: PUSH
5656: LD_VAR 0 5
5660: PUSH
5661: LD_VAR 0 6
5665: ADD
5666: ST_TO_ADDR
// end ;
5667: GO 5573
5669: POP
5670: POP
// end ; end_of_file
5671: LD_VAR 0 1
5675: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export startCrates ; export function GameType ; var i , ruStartTechs ; begin
5676: LD_INT 0
5678: PPUSH
5679: PPUSH
5680: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5681: LD_ADDR_OWVAR 67
5685: PUSH
5686: LD_INT 0
5688: PPUSH
5689: CALL_OW 426
5693: ST_TO_ADDR
// game_diff := Difficulty ;
5694: LD_ADDR_EXP 38
5698: PUSH
5699: LD_OWVAR 67
5703: ST_TO_ADDR
// game_skill := [ 7 , 6 , 6 ] [ game_diff ] ;
5704: LD_ADDR_EXP 39
5708: PUSH
5709: LD_INT 7
5711: PUSH
5712: LD_INT 6
5714: PUSH
5715: LD_INT 6
5717: PUSH
5718: EMPTY
5719: LIST
5720: LIST
5721: LIST
5722: PUSH
5723: LD_EXP 38
5727: ARRAY
5728: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5729: LD_ADDR_EXP 40
5733: PUSH
5734: LD_INT 6
5736: PUSH
5737: LD_INT 7
5739: PUSH
5740: LD_INT 8
5742: PUSH
5743: EMPTY
5744: LIST
5745: LIST
5746: LIST
5747: PUSH
5748: LD_EXP 38
5752: ARRAY
5753: ST_TO_ADDR
// ruArrival := [ 5 5$00 , 3 3$00 , 2 2$00 ] [ game_diff ] ;
5754: LD_ADDR_EXP 42
5758: PUSH
5759: LD_INT 10500
5761: PUSH
5762: LD_INT 6300
5764: PUSH
5765: LD_INT 4200
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_EXP 38
5777: ARRAY
5778: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5779: LD_ADDR_EXP 41
5783: PUSH
5784: LD_INT 73500
5786: PUSH
5787: LD_INT 94500
5789: PUSH
5790: LD_INT 115500
5792: PUSH
5793: EMPTY
5794: LIST
5795: LIST
5796: LIST
5797: PUSH
5798: LD_EXP 38
5802: ARRAY
5803: ST_TO_ADDR
// ruStartTechs = [ [ tech_Weap1 ] , [ tech_Weap1 , tech_Comp1 ] , [ tech_Weap1 , tech_Weap2 , tech_Comp1 ] ] ;
5804: LD_ADDR_VAR 0 3
5808: PUSH
5809: LD_INT 51
5811: PUSH
5812: EMPTY
5813: LIST
5814: PUSH
5815: LD_INT 51
5817: PUSH
5818: LD_INT 57
5820: PUSH
5821: EMPTY
5822: LIST
5823: LIST
5824: PUSH
5825: LD_INT 51
5827: PUSH
5828: LD_INT 52
5830: PUSH
5831: LD_INT 57
5833: PUSH
5834: EMPTY
5835: LIST
5836: LIST
5837: LIST
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: LIST
5843: ST_TO_ADDR
// startCrates = [ [ 300 , 350 ] , [ 230 , 200 ] , [ 150 , 100 ] ] [ game_diff ] ;
5844: LD_ADDR_EXP 43
5848: PUSH
5849: LD_INT 300
5851: PUSH
5852: LD_INT 350
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: LD_INT 230
5861: PUSH
5862: LD_INT 200
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: PUSH
5869: LD_INT 150
5871: PUSH
5872: LD_INT 100
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: PUSH
5879: EMPTY
5880: LIST
5881: LIST
5882: LIST
5883: PUSH
5884: LD_EXP 38
5888: ARRAY
5889: ST_TO_ADDR
// for i := 1 to ruStartTechs [ game_diff ] do
5890: LD_ADDR_VAR 0 2
5894: PUSH
5895: DOUBLE
5896: LD_INT 1
5898: DEC
5899: ST_TO_ADDR
5900: LD_VAR 0 3
5904: PUSH
5905: LD_EXP 38
5909: ARRAY
5910: PUSH
5911: FOR_TO
5912: IFFALSE 5970
// begin SetTech ( ruStartTechs [ game_diff ] [ i ] , 3 , state_researched ) ;
5914: LD_VAR 0 3
5918: PUSH
5919: LD_EXP 38
5923: ARRAY
5924: PUSH
5925: LD_VAR 0 2
5929: ARRAY
5930: PPUSH
5931: LD_INT 3
5933: PPUSH
5934: LD_INT 2
5936: PPUSH
5937: CALL_OW 322
// SetTech ( ruStartTechs [ game_diff ] [ i ] , 6 , state_researched ) ;
5941: LD_VAR 0 3
5945: PUSH
5946: LD_EXP 38
5950: ARRAY
5951: PUSH
5952: LD_VAR 0 2
5956: ARRAY
5957: PPUSH
5958: LD_INT 6
5960: PPUSH
5961: LD_INT 2
5963: PPUSH
5964: CALL_OW 322
// end ;
5968: GO 5911
5970: POP
5971: POP
// end ; end_of_file
5972: LD_VAR 0 1
5976: RET
// export function CustomEvent ( event ) ; begin
5977: LD_INT 0
5979: PPUSH
// end ;
5980: LD_VAR 0 2
5984: RET
// export function CustomInitMacro ( ) ; begin
5985: LD_INT 0
5987: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5988: LD_INT 1
5990: PPUSH
5991: LD_INT 3
5993: PPUSH
5994: CALL 75007 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5998: LD_INT 1
6000: PPUSH
6001: LD_INT 4
6003: PPUSH
6004: CALL 74951 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
6008: LD_INT 1
6010: PPUSH
6011: LD_INT 136
6013: PUSH
6014: LD_INT 130
6016: PUSH
6017: LD_INT 0
6019: PUSH
6020: EMPTY
6021: LIST
6022: LIST
6023: LIST
6024: PUSH
6025: LD_INT 145
6027: PUSH
6028: LD_INT 123
6030: PUSH
6031: LD_INT 0
6033: PUSH
6034: EMPTY
6035: LIST
6036: LIST
6037: LIST
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: PPUSH
6043: CALL 74010 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
6047: LD_INT 1
6049: PPUSH
6050: LD_INT 43
6052: PUSH
6053: LD_INT 46
6055: PUSH
6056: LD_INT 45
6058: PUSH
6059: EMPTY
6060: LIST
6061: LIST
6062: LIST
6063: PPUSH
6064: CALL 74839 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
6068: LD_INT 1
6070: PPUSH
6071: LD_INT 3
6073: PPUSH
6074: CALL 74521 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
6078: LD_INT 1
6080: PPUSH
6081: LD_INT 3
6083: PPUSH
6084: CALL 74252 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
6088: LD_INT 1
6090: PPUSH
6091: LD_INT 8
6093: PPUSH
6094: CALL 73871 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
6098: LD_INT 1
6100: PPUSH
6101: LD_INT 22
6103: PUSH
6104: LD_INT 1
6106: PUSH
6107: LD_INT 3
6109: PUSH
6110: LD_INT 43
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: LIST
6118: PUSH
6119: LD_INT 22
6121: PUSH
6122: LD_INT 1
6124: PUSH
6125: LD_INT 3
6127: PUSH
6128: LD_INT 44
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: LIST
6135: LIST
6136: PUSH
6137: LD_INT 22
6139: PUSH
6140: LD_INT 1
6142: PUSH
6143: LD_INT 3
6145: PUSH
6146: LD_INT 45
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: LIST
6153: LIST
6154: PUSH
6155: LD_INT 24
6157: PUSH
6158: LD_INT 1
6160: PUSH
6161: LD_INT 3
6163: PUSH
6164: LD_INT 43
6166: PUSH
6167: EMPTY
6168: LIST
6169: LIST
6170: LIST
6171: LIST
6172: PUSH
6173: LD_INT 24
6175: PUSH
6176: LD_INT 1
6178: PUSH
6179: LD_INT 3
6181: PUSH
6182: LD_INT 43
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: LIST
6189: LIST
6190: PUSH
6191: LD_INT 24
6193: PUSH
6194: LD_INT 1
6196: PUSH
6197: LD_INT 3
6199: PUSH
6200: LD_INT 46
6202: PUSH
6203: EMPTY
6204: LIST
6205: LIST
6206: LIST
6207: LIST
6208: PUSH
6209: LD_INT 22
6211: PUSH
6212: LD_INT 1
6214: PUSH
6215: LD_INT 3
6217: PUSH
6218: LD_INT 43
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: PUSH
6227: LD_INT 22
6229: PUSH
6230: LD_INT 1
6232: PUSH
6233: LD_INT 3
6235: PUSH
6236: LD_INT 44
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: LIST
6243: LIST
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: LIST
6250: LIST
6251: LIST
6252: LIST
6253: LIST
6254: PPUSH
6255: CALL 73686 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
6259: LD_INT 1
6261: PPUSH
6262: LD_INT 0
6264: PUSH
6265: LD_INT 127
6267: PUSH
6268: LD_INT 125
6270: PUSH
6271: LD_INT 5
6273: PUSH
6274: EMPTY
6275: LIST
6276: LIST
6277: LIST
6278: LIST
6279: PUSH
6280: LD_INT 6
6282: PUSH
6283: LD_INT 124
6285: PUSH
6286: LD_INT 132
6288: PUSH
6289: LD_INT 0
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: LIST
6296: LIST
6297: PUSH
6298: LD_INT 29
6300: PUSH
6301: LD_INT 136
6303: PUSH
6304: LD_INT 130
6306: PUSH
6307: LD_INT 1
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: PUSH
6316: LD_INT 4
6318: PUSH
6319: LD_INT 118
6321: PUSH
6322: LD_INT 114
6324: PUSH
6325: LD_INT 2
6327: PUSH
6328: EMPTY
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PUSH
6334: LD_INT 29
6336: PUSH
6337: LD_INT 145
6339: PUSH
6340: LD_INT 123
6342: PUSH
6343: LD_INT 1
6345: PUSH
6346: EMPTY
6347: LIST
6348: LIST
6349: LIST
6350: LIST
6351: PUSH
6352: LD_INT 26
6354: PUSH
6355: LD_INT 150
6357: PUSH
6358: LD_INT 135
6360: PUSH
6361: LD_INT 1
6363: PUSH
6364: EMPTY
6365: LIST
6366: LIST
6367: LIST
6368: LIST
6369: PUSH
6370: LD_INT 26
6372: PUSH
6373: LD_INT 140
6375: PUSH
6376: LD_INT 134
6378: PUSH
6379: LD_INT 2
6381: PUSH
6382: EMPTY
6383: LIST
6384: LIST
6385: LIST
6386: LIST
6387: PUSH
6388: LD_INT 26
6390: PUSH
6391: LD_INT 137
6393: PUSH
6394: LD_INT 121
6396: PUSH
6397: LD_INT 5
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: LIST
6404: LIST
6405: PUSH
6406: LD_INT 2
6408: PUSH
6409: LD_INT 155
6411: PUSH
6412: LD_INT 130
6414: PUSH
6415: LD_INT 0
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: LIST
6422: LIST
6423: PUSH
6424: LD_INT 32
6426: PUSH
6427: LD_INT 155
6429: PUSH
6430: LD_INT 130
6432: PUSH
6433: LD_INT 0
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: LD_INT 32
6444: PUSH
6445: LD_INT 130
6447: PUSH
6448: LD_INT 114
6450: PUSH
6451: LD_INT 3
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: LIST
6458: LIST
6459: PUSH
6460: LD_INT 32
6462: PUSH
6463: LD_INT 142
6465: PUSH
6466: LD_INT 115
6468: PUSH
6469: LD_INT 3
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: PUSH
6478: LD_INT 32
6480: PUSH
6481: LD_INT 153
6483: PUSH
6484: LD_INT 120
6486: PUSH
6487: LD_INT 3
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: LIST
6502: LIST
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: LIST
6508: LIST
6509: LIST
6510: PPUSH
6511: CALL 73578 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
6515: LD_INT 1
6517: PPUSH
6518: LD_INT 10
6520: PUSH
6521: LD_INT 12
6523: PUSH
6524: EMPTY
6525: LIST
6526: LIST
6527: PPUSH
6528: CALL 74428 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6532: LD_INT 1
6534: PPUSH
6535: LD_INT 155
6537: PPUSH
6538: LD_INT 130
6540: PPUSH
6541: LD_INT 0
6543: PPUSH
6544: LD_INT 24
6546: PUSH
6547: LD_INT 16
6549: PUSH
6550: LD_INT 17
6552: PUSH
6553: LD_INT 18
6555: PUSH
6556: LD_INT 21
6558: PUSH
6559: EMPTY
6560: LIST
6561: LIST
6562: LIST
6563: LIST
6564: LIST
6565: PPUSH
6566: CALL 74633 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
6570: LD_INT 2
6572: PPUSH
6573: LD_INT 3
6575: PPUSH
6576: CALL 75007 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
6580: LD_INT 2
6582: PPUSH
6583: LD_INT 4
6585: PPUSH
6586: CALL 74951 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
6590: LD_INT 2
6592: PPUSH
6593: LD_INT 84
6595: PUSH
6596: LD_INT 125
6598: PUSH
6599: LD_INT 1
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: LIST
6606: PUSH
6607: EMPTY
6608: LIST
6609: PPUSH
6610: CALL 74010 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
6614: LD_INT 2
6616: PPUSH
6617: LD_INT 43
6619: PUSH
6620: LD_INT 46
6622: PUSH
6623: LD_INT 45
6625: PUSH
6626: EMPTY
6627: LIST
6628: LIST
6629: LIST
6630: PPUSH
6631: CALL 74839 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
6635: LD_INT 2
6637: PPUSH
6638: LD_INT 3
6640: PPUSH
6641: CALL 74521 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6645: LD_INT 2
6647: PPUSH
6648: LD_INT 3
6650: PPUSH
6651: CALL 74252 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6655: LD_INT 2
6657: PPUSH
6658: LD_INT 8
6660: PPUSH
6661: CALL 73871 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6665: LD_INT 2
6667: PPUSH
6668: LD_INT 22
6670: PUSH
6671: LD_INT 3
6673: PUSH
6674: LD_INT 3
6676: PUSH
6677: LD_INT 43
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: PUSH
6686: LD_INT 22
6688: PUSH
6689: LD_INT 3
6691: PUSH
6692: LD_INT 3
6694: PUSH
6695: LD_INT 44
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: LIST
6702: LIST
6703: PUSH
6704: LD_INT 22
6706: PUSH
6707: LD_INT 3
6709: PUSH
6710: LD_INT 3
6712: PUSH
6713: LD_INT 45
6715: PUSH
6716: EMPTY
6717: LIST
6718: LIST
6719: LIST
6720: LIST
6721: PUSH
6722: LD_INT 24
6724: PUSH
6725: LD_INT 3
6727: PUSH
6728: LD_INT 3
6730: PUSH
6731: LD_INT 43
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: LIST
6738: LIST
6739: PUSH
6740: LD_INT 24
6742: PUSH
6743: LD_INT 3
6745: PUSH
6746: LD_INT 3
6748: PUSH
6749: LD_INT 43
6751: PUSH
6752: EMPTY
6753: LIST
6754: LIST
6755: LIST
6756: LIST
6757: PUSH
6758: LD_INT 24
6760: PUSH
6761: LD_INT 3
6763: PUSH
6764: LD_INT 3
6766: PUSH
6767: LD_INT 46
6769: PUSH
6770: EMPTY
6771: LIST
6772: LIST
6773: LIST
6774: LIST
6775: PUSH
6776: LD_INT 22
6778: PUSH
6779: LD_INT 3
6781: PUSH
6782: LD_INT 3
6784: PUSH
6785: LD_INT 43
6787: PUSH
6788: EMPTY
6789: LIST
6790: LIST
6791: LIST
6792: LIST
6793: PUSH
6794: LD_INT 22
6796: PUSH
6797: LD_INT 3
6799: PUSH
6800: LD_INT 3
6802: PUSH
6803: LD_INT 44
6805: PUSH
6806: EMPTY
6807: LIST
6808: LIST
6809: LIST
6810: LIST
6811: PUSH
6812: EMPTY
6813: LIST
6814: LIST
6815: LIST
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: PPUSH
6822: CALL 73686 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6826: LD_INT 2
6828: PPUSH
6829: LD_INT 0
6831: PUSH
6832: LD_INT 96
6834: PUSH
6835: LD_INT 125
6837: PUSH
6838: LD_INT 0
6840: PUSH
6841: EMPTY
6842: LIST
6843: LIST
6844: LIST
6845: LIST
6846: PUSH
6847: LD_INT 6
6849: PUSH
6850: LD_INT 74
6852: PUSH
6853: LD_INT 122
6855: PUSH
6856: LD_INT 1
6858: PUSH
6859: EMPTY
6860: LIST
6861: LIST
6862: LIST
6863: LIST
6864: PUSH
6865: LD_INT 30
6867: PUSH
6868: LD_INT 84
6870: PUSH
6871: LD_INT 125
6873: PUSH
6874: LD_INT 1
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: LIST
6881: LIST
6882: PUSH
6883: LD_INT 28
6885: PUSH
6886: LD_INT 86
6888: PUSH
6889: LD_INT 128
6891: PUSH
6892: LD_INT 1
6894: PUSH
6895: EMPTY
6896: LIST
6897: LIST
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 28
6903: PUSH
6904: LD_INT 85
6906: PUSH
6907: LD_INT 130
6909: PUSH
6910: LD_INT 2
6912: PUSH
6913: EMPTY
6914: LIST
6915: LIST
6916: LIST
6917: LIST
6918: PUSH
6919: LD_INT 28
6921: PUSH
6922: LD_INT 88
6924: PUSH
6925: LD_INT 132
6927: PUSH
6928: LD_INT 5
6930: PUSH
6931: EMPTY
6932: LIST
6933: LIST
6934: LIST
6935: LIST
6936: PUSH
6937: LD_INT 2
6939: PUSH
6940: LD_INT 106
6942: PUSH
6943: LD_INT 130
6945: PUSH
6946: LD_INT 0
6948: PUSH
6949: EMPTY
6950: LIST
6951: LIST
6952: LIST
6953: LIST
6954: PUSH
6955: LD_INT 4
6957: PUSH
6958: LD_INT 99
6960: PUSH
6961: LD_INT 114
6963: PUSH
6964: LD_INT 3
6966: PUSH
6967: EMPTY
6968: LIST
6969: LIST
6970: LIST
6971: LIST
6972: PUSH
6973: LD_INT 32
6975: PUSH
6976: LD_INT 72
6978: PUSH
6979: LD_INT 112
6981: PUSH
6982: LD_INT 2
6984: PUSH
6985: EMPTY
6986: LIST
6987: LIST
6988: LIST
6989: LIST
6990: PUSH
6991: LD_INT 32
6993: PUSH
6994: LD_INT 78
6996: PUSH
6997: LD_INT 110
6999: PUSH
7000: LD_INT 3
7002: PUSH
7003: EMPTY
7004: LIST
7005: LIST
7006: LIST
7007: LIST
7008: PUSH
7009: LD_INT 32
7011: PUSH
7012: LD_INT 84
7014: PUSH
7015: LD_INT 110
7017: PUSH
7018: LD_INT 2
7020: PUSH
7021: EMPTY
7022: LIST
7023: LIST
7024: LIST
7025: LIST
7026: PUSH
7027: LD_INT 32
7029: PUSH
7030: LD_INT 105
7032: PUSH
7033: LD_INT 117
7035: PUSH
7036: LD_INT 3
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: LIST
7043: LIST
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: LIST
7049: LIST
7050: LIST
7051: LIST
7052: LIST
7053: LIST
7054: LIST
7055: LIST
7056: LIST
7057: LIST
7058: PPUSH
7059: CALL 73578 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
7063: LD_INT 2
7065: PPUSH
7066: LD_INT 14
7068: PUSH
7069: LD_INT 11
7071: PUSH
7072: EMPTY
7073: LIST
7074: LIST
7075: PPUSH
7076: CALL 74428 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
7080: LD_INT 2
7082: PPUSH
7083: LD_INT 106
7085: PPUSH
7086: LD_INT 130
7088: PPUSH
7089: LD_INT 0
7091: PPUSH
7092: LD_INT 24
7094: PUSH
7095: LD_INT 16
7097: PUSH
7098: LD_INT 17
7100: PUSH
7101: LD_INT 18
7103: PUSH
7104: LD_INT 21
7106: PUSH
7107: EMPTY
7108: LIST
7109: LIST
7110: LIST
7111: LIST
7112: LIST
7113: PPUSH
7114: CALL 74633 0 5
// end ;
7118: LD_VAR 0 1
7122: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
7123: LD_INT 22
7125: PUSH
7126: LD_INT 3
7128: PUSH
7129: EMPTY
7130: LIST
7131: LIST
7132: PUSH
7133: LD_INT 30
7135: PUSH
7136: LD_INT 3
7138: PUSH
7139: EMPTY
7140: LIST
7141: LIST
7142: PUSH
7143: EMPTY
7144: LIST
7145: LIST
7146: PPUSH
7147: CALL_OW 69
7151: IFFALSE 8294
7153: GO 7155
7155: DISABLE
7156: LD_INT 0
7158: PPUSH
7159: PPUSH
7160: PPUSH
7161: PPUSH
7162: PPUSH
7163: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
7164: LD_INT 6300
7166: PUSH
7167: LD_INT 4200
7169: PUSH
7170: LD_INT 2100
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: LIST
7177: PUSH
7178: LD_OWVAR 67
7182: ARRAY
7183: PPUSH
7184: CALL_OW 67
// base := 2 ;
7188: LD_ADDR_VAR 0 2
7192: PUSH
7193: LD_INT 2
7195: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
7196: LD_INT 22
7198: PUSH
7199: LD_INT 3
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: PUSH
7206: LD_INT 30
7208: PUSH
7209: LD_INT 3
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: PUSH
7216: EMPTY
7217: LIST
7218: LIST
7219: PPUSH
7220: CALL_OW 69
7224: NOT
7225: IFFALSE 7229
// continue ;
7227: GO 7164
// case Rand ( 1 , 3 ) of 1 :
7229: LD_INT 1
7231: PPUSH
7232: LD_INT 3
7234: PPUSH
7235: CALL_OW 12
7239: PUSH
7240: LD_INT 1
7242: DOUBLE
7243: EQUAL
7244: IFTRUE 7248
7246: GO 7424
7248: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7249: LD_ADDR_VAR 0 3
7253: PUSH
7254: LD_INT 22
7256: PUSH
7257: LD_INT 3
7259: PUSH
7260: LD_INT 3
7262: PUSH
7263: LD_INT 43
7265: PUSH
7266: EMPTY
7267: LIST
7268: LIST
7269: LIST
7270: LIST
7271: PUSH
7272: LD_INT 24
7274: PUSH
7275: LD_INT 3
7277: PUSH
7278: LD_INT 3
7280: PUSH
7281: LD_INT 46
7283: PUSH
7284: EMPTY
7285: LIST
7286: LIST
7287: LIST
7288: LIST
7289: PUSH
7290: LD_INT 24
7292: PUSH
7293: LD_INT 3
7295: PUSH
7296: LD_INT 3
7298: PUSH
7299: LD_INT 43
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: LIST
7306: LIST
7307: PUSH
7308: LD_INT 24
7310: PUSH
7311: LD_INT 3
7313: PUSH
7314: LD_INT 3
7316: PUSH
7317: LD_INT 46
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: LIST
7324: LIST
7325: PUSH
7326: LD_INT 22
7328: PUSH
7329: LD_INT 3
7331: PUSH
7332: LD_INT 3
7334: PUSH
7335: LD_INT 45
7337: PUSH
7338: EMPTY
7339: LIST
7340: LIST
7341: LIST
7342: LIST
7343: PUSH
7344: LD_INT 22
7346: PUSH
7347: LD_INT 3
7349: PUSH
7350: LD_INT 3
7352: PUSH
7353: LD_INT 43
7355: PUSH
7356: EMPTY
7357: LIST
7358: LIST
7359: LIST
7360: LIST
7361: PUSH
7362: LD_INT 24
7364: PUSH
7365: LD_INT 3
7367: PUSH
7368: LD_INT 3
7370: PUSH
7371: LD_INT 46
7373: PUSH
7374: EMPTY
7375: LIST
7376: LIST
7377: LIST
7378: LIST
7379: PUSH
7380: LD_INT 22
7382: PUSH
7383: LD_INT 3
7385: PUSH
7386: LD_INT 3
7388: PUSH
7389: LD_INT 45
7391: PUSH
7392: EMPTY
7393: LIST
7394: LIST
7395: LIST
7396: LIST
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: LIST
7406: LIST
7407: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7408: LD_VAR 0 2
7412: PPUSH
7413: LD_VAR 0 3
7417: PPUSH
7418: CALL 73734 0 2
// end ; 2 :
7422: GO 7755
7424: LD_INT 2
7426: DOUBLE
7427: EQUAL
7428: IFTRUE 7432
7430: GO 7570
7432: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7433: LD_ADDR_VAR 0 3
7437: PUSH
7438: LD_INT 24
7440: PUSH
7441: LD_INT 3
7443: PUSH
7444: LD_INT 3
7446: PUSH
7447: LD_INT 43
7449: PUSH
7450: EMPTY
7451: LIST
7452: LIST
7453: LIST
7454: LIST
7455: PUSH
7456: LD_INT 24
7458: PUSH
7459: LD_INT 3
7461: PUSH
7462: LD_INT 3
7464: PUSH
7465: LD_INT 46
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: PUSH
7474: LD_INT 24
7476: PUSH
7477: LD_INT 3
7479: PUSH
7480: LD_INT 3
7482: PUSH
7483: LD_INT 43
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: LIST
7490: LIST
7491: PUSH
7492: LD_INT 24
7494: PUSH
7495: LD_INT 3
7497: PUSH
7498: LD_INT 3
7500: PUSH
7501: LD_INT 46
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: LIST
7508: LIST
7509: PUSH
7510: LD_INT 22
7512: PUSH
7513: LD_INT 3
7515: PUSH
7516: LD_INT 3
7518: PUSH
7519: LD_INT 45
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: LIST
7526: LIST
7527: PUSH
7528: LD_INT 22
7530: PUSH
7531: LD_INT 3
7533: PUSH
7534: LD_INT 3
7536: PUSH
7537: LD_INT 45
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: LIST
7544: LIST
7545: PUSH
7546: EMPTY
7547: LIST
7548: LIST
7549: LIST
7550: LIST
7551: LIST
7552: LIST
7553: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7554: LD_VAR 0 2
7558: PPUSH
7559: LD_VAR 0 3
7563: PPUSH
7564: CALL 73734 0 2
// end ; 3 :
7568: GO 7755
7570: LD_INT 3
7572: DOUBLE
7573: EQUAL
7574: IFTRUE 7578
7576: GO 7754
7578: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7579: LD_ADDR_VAR 0 3
7583: PUSH
7584: LD_INT 22
7586: PUSH
7587: LD_INT 3
7589: PUSH
7590: LD_INT 3
7592: PUSH
7593: LD_INT 43
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: LIST
7600: LIST
7601: PUSH
7602: LD_INT 24
7604: PUSH
7605: LD_INT 3
7607: PUSH
7608: LD_INT 3
7610: PUSH
7611: LD_INT 46
7613: PUSH
7614: EMPTY
7615: LIST
7616: LIST
7617: LIST
7618: LIST
7619: PUSH
7620: LD_INT 22
7622: PUSH
7623: LD_INT 3
7625: PUSH
7626: LD_INT 3
7628: PUSH
7629: LD_INT 43
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: LIST
7636: LIST
7637: PUSH
7638: LD_INT 24
7640: PUSH
7641: LD_INT 3
7643: PUSH
7644: LD_INT 3
7646: PUSH
7647: LD_INT 46
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: LIST
7654: LIST
7655: PUSH
7656: LD_INT 22
7658: PUSH
7659: LD_INT 3
7661: PUSH
7662: LD_INT 3
7664: PUSH
7665: LD_INT 45
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: LIST
7672: LIST
7673: PUSH
7674: LD_INT 22
7676: PUSH
7677: LD_INT 3
7679: PUSH
7680: LD_INT 3
7682: PUSH
7683: LD_INT 43
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: LIST
7690: LIST
7691: PUSH
7692: LD_INT 24
7694: PUSH
7695: LD_INT 3
7697: PUSH
7698: LD_INT 3
7700: PUSH
7701: LD_INT 46
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 22
7712: PUSH
7713: LD_INT 3
7715: PUSH
7716: LD_INT 3
7718: PUSH
7719: LD_INT 45
7721: PUSH
7722: EMPTY
7723: LIST
7724: LIST
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7738: LD_VAR 0 2
7742: PPUSH
7743: LD_VAR 0 3
7747: PPUSH
7748: CALL 73734 0 2
// end ; end ;
7752: GO 7755
7754: POP
// repeat wait ( 0 0$1 ) ;
7755: LD_INT 35
7757: PPUSH
7758: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7762: LD_VAR 0 2
7766: PPUSH
7767: CALL 74082 0 1
7771: PUSH
7772: LD_INT 0
7774: EQUAL
7775: IFFALSE 7755
// wait ( 0 0$30 ) ;
7777: LD_INT 1050
7779: PPUSH
7780: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7784: LD_ADDR_VAR 0 5
7788: PUSH
7789: LD_INT 86
7791: PUSH
7792: LD_INT 77
7794: PUSH
7795: EMPTY
7796: LIST
7797: LIST
7798: PUSH
7799: LD_INT 63
7801: PUSH
7802: LD_INT 38
7804: PUSH
7805: EMPTY
7806: LIST
7807: LIST
7808: PUSH
7809: EMPTY
7810: LIST
7811: LIST
7812: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7813: LD_ADDR_VAR 0 4
7817: PUSH
7818: LD_INT 0
7820: PUSH
7821: LD_INT 0
7823: PUSH
7824: LD_INT 0
7826: PUSH
7827: LD_INT 1
7829: PUSH
7830: LD_INT 0
7832: PUSH
7833: LD_INT 0
7835: PUSH
7836: LD_INT 0
7838: PUSH
7839: LD_INT 0
7841: PUSH
7842: LD_INT 1
7844: PUSH
7845: LD_INT 0
7847: PUSH
7848: EMPTY
7849: LIST
7850: LIST
7851: LIST
7852: LIST
7853: LIST
7854: LIST
7855: LIST
7856: LIST
7857: LIST
7858: LIST
7859: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7860: LD_ADDR_VAR 0 6
7864: PUSH
7865: LD_EXP 84
7869: PUSH
7870: LD_VAR 0 2
7874: ARRAY
7875: PUSH
7876: LD_EXP 87
7880: PUSH
7881: LD_VAR 0 2
7885: ARRAY
7886: DIFF
7887: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7888: LD_ADDR_EXP 84
7892: PUSH
7893: LD_EXP 84
7897: PPUSH
7898: LD_VAR 0 2
7902: PPUSH
7903: LD_EXP 84
7907: PUSH
7908: LD_VAR 0 2
7912: ARRAY
7913: PUSH
7914: LD_VAR 0 6
7918: DIFF
7919: PPUSH
7920: CALL_OW 1
7924: ST_TO_ADDR
// if not attackers then
7925: LD_VAR 0 6
7929: NOT
7930: IFFALSE 7934
// continue ;
7932: GO 7164
// repeat wait ( 0 0$1 ) ;
7934: LD_INT 35
7936: PPUSH
7937: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7941: LD_VAR 0 6
7945: PPUSH
7946: LD_INT 60
7948: PUSH
7949: EMPTY
7950: LIST
7951: PPUSH
7952: CALL_OW 72
7956: NOT
7957: IFFALSE 7934
// repeat wait ( 0 0$1 ) ;
7959: LD_INT 35
7961: PPUSH
7962: CALL_OW 67
// for i in attackers do
7966: LD_ADDR_VAR 0 1
7970: PUSH
7971: LD_VAR 0 6
7975: PUSH
7976: FOR_IN
7977: IFFALSE 8261
// begin if IsDead ( i ) then
7979: LD_VAR 0 1
7983: PPUSH
7984: CALL_OW 301
7988: IFFALSE 8006
// attackers := attackers diff i ;
7990: LD_ADDR_VAR 0 6
7994: PUSH
7995: LD_VAR 0 6
7999: PUSH
8000: LD_VAR 0 1
8004: DIFF
8005: ST_TO_ADDR
// if not HasTask ( i ) then
8006: LD_VAR 0 1
8010: PPUSH
8011: CALL_OW 314
8015: NOT
8016: IFFALSE 8259
// begin if not GetTag ( i ) then
8018: LD_VAR 0 1
8022: PPUSH
8023: CALL_OW 110
8027: NOT
8028: IFFALSE 8120
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
8030: LD_VAR 0 1
8034: PPUSH
8035: LD_VAR 0 5
8039: PUSH
8040: LD_INT 1
8042: ARRAY
8043: PUSH
8044: LD_INT 1
8046: ARRAY
8047: PPUSH
8048: LD_VAR 0 5
8052: PUSH
8053: LD_INT 1
8055: ARRAY
8056: PUSH
8057: LD_INT 2
8059: ARRAY
8060: PPUSH
8061: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
8065: LD_VAR 0 1
8069: PPUSH
8070: LD_VAR 0 5
8074: PUSH
8075: LD_INT 1
8077: ARRAY
8078: PUSH
8079: LD_INT 1
8081: ARRAY
8082: PPUSH
8083: LD_VAR 0 5
8087: PUSH
8088: LD_INT 1
8090: ARRAY
8091: PUSH
8092: LD_INT 2
8094: ARRAY
8095: PPUSH
8096: CALL_OW 297
8100: PUSH
8101: LD_INT 8
8103: LESS
8104: IFFALSE 8118
// SetTag ( i , 1 ) ;
8106: LD_VAR 0 1
8110: PPUSH
8111: LD_INT 1
8113: PPUSH
8114: CALL_OW 109
// end else
8118: GO 8259
// if GetTag ( i ) = 1 then
8120: LD_VAR 0 1
8124: PPUSH
8125: CALL_OW 110
8129: PUSH
8130: LD_INT 1
8132: EQUAL
8133: IFFALSE 8225
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
8135: LD_VAR 0 1
8139: PPUSH
8140: LD_VAR 0 5
8144: PUSH
8145: LD_INT 2
8147: ARRAY
8148: PUSH
8149: LD_INT 1
8151: ARRAY
8152: PPUSH
8153: LD_VAR 0 5
8157: PUSH
8158: LD_INT 2
8160: ARRAY
8161: PUSH
8162: LD_INT 2
8164: ARRAY
8165: PPUSH
8166: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
8170: LD_VAR 0 1
8174: PPUSH
8175: LD_VAR 0 5
8179: PUSH
8180: LD_INT 2
8182: ARRAY
8183: PUSH
8184: LD_INT 1
8186: ARRAY
8187: PPUSH
8188: LD_VAR 0 5
8192: PUSH
8193: LD_INT 2
8195: ARRAY
8196: PUSH
8197: LD_INT 2
8199: ARRAY
8200: PPUSH
8201: CALL_OW 297
8205: PUSH
8206: LD_INT 8
8208: LESS
8209: IFFALSE 8223
// SetTag ( i , 2 ) ;
8211: LD_VAR 0 1
8215: PPUSH
8216: LD_INT 2
8218: PPUSH
8219: CALL_OW 109
// end else
8223: GO 8259
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8225: LD_VAR 0 1
8229: PPUSH
8230: LD_INT 81
8232: PUSH
8233: LD_INT 3
8235: PUSH
8236: EMPTY
8237: LIST
8238: LIST
8239: PPUSH
8240: CALL_OW 69
8244: PPUSH
8245: LD_VAR 0 1
8249: PPUSH
8250: CALL_OW 74
8254: PPUSH
8255: CALL_OW 115
// end ; end ;
8259: GO 7976
8261: POP
8262: POP
// until not attackers ;
8263: LD_VAR 0 6
8267: NOT
8268: IFFALSE 7959
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8270: LD_EXP 65
8274: PUSH
8275: LD_VAR 0 2
8279: ARRAY
8280: PPUSH
8281: LD_INT 50
8283: PUSH
8284: EMPTY
8285: LIST
8286: PPUSH
8287: CALL_OW 72
8291: NOT
8292: IFFALSE 7164
// end ;
8294: PPOPN 6
8296: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
8297: LD_INT 22
8299: PUSH
8300: LD_INT 3
8302: PUSH
8303: EMPTY
8304: LIST
8305: LIST
8306: PUSH
8307: LD_INT 30
8309: PUSH
8310: LD_INT 3
8312: PUSH
8313: EMPTY
8314: LIST
8315: LIST
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: PPUSH
8321: CALL_OW 69
8325: IFFALSE 9509
8327: GO 8329
8329: DISABLE
8330: LD_INT 0
8332: PPUSH
8333: PPUSH
8334: PPUSH
8335: PPUSH
8336: PPUSH
8337: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
8338: LD_INT 6300
8340: PUSH
8341: LD_INT 4200
8343: PUSH
8344: LD_INT 2100
8346: PUSH
8347: EMPTY
8348: LIST
8349: LIST
8350: LIST
8351: PUSH
8352: LD_OWVAR 67
8356: ARRAY
8357: PPUSH
8358: CALL_OW 67
// base := 1 ;
8362: LD_ADDR_VAR 0 2
8366: PUSH
8367: LD_INT 1
8369: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8370: LD_INT 22
8372: PUSH
8373: LD_INT 3
8375: PUSH
8376: EMPTY
8377: LIST
8378: LIST
8379: PUSH
8380: LD_INT 30
8382: PUSH
8383: LD_INT 3
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PUSH
8390: EMPTY
8391: LIST
8392: LIST
8393: PPUSH
8394: CALL_OW 69
8398: NOT
8399: IFFALSE 8403
// continue ;
8401: GO 8338
// case Rand ( 1 , 3 ) of 1 :
8403: LD_INT 1
8405: PPUSH
8406: LD_INT 3
8408: PPUSH
8409: CALL_OW 12
8413: PUSH
8414: LD_INT 1
8416: DOUBLE
8417: EQUAL
8418: IFTRUE 8422
8420: GO 8598
8422: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8423: LD_ADDR_VAR 0 3
8427: PUSH
8428: LD_INT 22
8430: PUSH
8431: LD_INT 1
8433: PUSH
8434: LD_INT 3
8436: PUSH
8437: LD_INT 43
8439: PUSH
8440: EMPTY
8441: LIST
8442: LIST
8443: LIST
8444: LIST
8445: PUSH
8446: LD_INT 24
8448: PUSH
8449: LD_INT 1
8451: PUSH
8452: LD_INT 3
8454: PUSH
8455: LD_INT 46
8457: PUSH
8458: EMPTY
8459: LIST
8460: LIST
8461: LIST
8462: LIST
8463: PUSH
8464: LD_INT 24
8466: PUSH
8467: LD_INT 1
8469: PUSH
8470: LD_INT 3
8472: PUSH
8473: LD_INT 43
8475: PUSH
8476: EMPTY
8477: LIST
8478: LIST
8479: LIST
8480: LIST
8481: PUSH
8482: LD_INT 24
8484: PUSH
8485: LD_INT 1
8487: PUSH
8488: LD_INT 3
8490: PUSH
8491: LD_INT 46
8493: PUSH
8494: EMPTY
8495: LIST
8496: LIST
8497: LIST
8498: LIST
8499: PUSH
8500: LD_INT 22
8502: PUSH
8503: LD_INT 1
8505: PUSH
8506: LD_INT 3
8508: PUSH
8509: LD_INT 45
8511: PUSH
8512: EMPTY
8513: LIST
8514: LIST
8515: LIST
8516: LIST
8517: PUSH
8518: LD_INT 22
8520: PUSH
8521: LD_INT 1
8523: PUSH
8524: LD_INT 3
8526: PUSH
8527: LD_INT 43
8529: PUSH
8530: EMPTY
8531: LIST
8532: LIST
8533: LIST
8534: LIST
8535: PUSH
8536: LD_INT 24
8538: PUSH
8539: LD_INT 1
8541: PUSH
8542: LD_INT 3
8544: PUSH
8545: LD_INT 46
8547: PUSH
8548: EMPTY
8549: LIST
8550: LIST
8551: LIST
8552: LIST
8553: PUSH
8554: LD_INT 22
8556: PUSH
8557: LD_INT 1
8559: PUSH
8560: LD_INT 3
8562: PUSH
8563: LD_INT 45
8565: PUSH
8566: EMPTY
8567: LIST
8568: LIST
8569: LIST
8570: LIST
8571: PUSH
8572: EMPTY
8573: LIST
8574: LIST
8575: LIST
8576: LIST
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8582: LD_VAR 0 2
8586: PPUSH
8587: LD_VAR 0 3
8591: PPUSH
8592: CALL 73734 0 2
// end ; 2 :
8596: GO 8967
8598: LD_INT 2
8600: DOUBLE
8601: EQUAL
8602: IFTRUE 8606
8604: GO 8782
8606: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8607: LD_ADDR_VAR 0 3
8611: PUSH
8612: LD_INT 24
8614: PUSH
8615: LD_INT 1
8617: PUSH
8618: LD_INT 3
8620: PUSH
8621: LD_INT 43
8623: PUSH
8624: EMPTY
8625: LIST
8626: LIST
8627: LIST
8628: LIST
8629: PUSH
8630: LD_INT 24
8632: PUSH
8633: LD_INT 1
8635: PUSH
8636: LD_INT 3
8638: PUSH
8639: LD_INT 46
8641: PUSH
8642: EMPTY
8643: LIST
8644: LIST
8645: LIST
8646: LIST
8647: PUSH
8648: LD_INT 24
8650: PUSH
8651: LD_INT 1
8653: PUSH
8654: LD_INT 3
8656: PUSH
8657: LD_INT 43
8659: PUSH
8660: EMPTY
8661: LIST
8662: LIST
8663: LIST
8664: LIST
8665: PUSH
8666: LD_INT 24
8668: PUSH
8669: LD_INT 1
8671: PUSH
8672: LD_INT 3
8674: PUSH
8675: LD_INT 46
8677: PUSH
8678: EMPTY
8679: LIST
8680: LIST
8681: LIST
8682: LIST
8683: PUSH
8684: LD_INT 22
8686: PUSH
8687: LD_INT 1
8689: PUSH
8690: LD_INT 3
8692: PUSH
8693: LD_INT 45
8695: PUSH
8696: EMPTY
8697: LIST
8698: LIST
8699: LIST
8700: LIST
8701: PUSH
8702: LD_INT 22
8704: PUSH
8705: LD_INT 1
8707: PUSH
8708: LD_INT 3
8710: PUSH
8711: LD_INT 45
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: LIST
8718: LIST
8719: PUSH
8720: LD_INT 22
8722: PUSH
8723: LD_INT 1
8725: PUSH
8726: LD_INT 3
8728: PUSH
8729: LD_INT 45
8731: PUSH
8732: EMPTY
8733: LIST
8734: LIST
8735: LIST
8736: LIST
8737: PUSH
8738: LD_INT 22
8740: PUSH
8741: LD_INT 1
8743: PUSH
8744: LD_INT 3
8746: PUSH
8747: LD_INT 45
8749: PUSH
8750: EMPTY
8751: LIST
8752: LIST
8753: LIST
8754: LIST
8755: PUSH
8756: EMPTY
8757: LIST
8758: LIST
8759: LIST
8760: LIST
8761: LIST
8762: LIST
8763: LIST
8764: LIST
8765: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8766: LD_VAR 0 2
8770: PPUSH
8771: LD_VAR 0 3
8775: PPUSH
8776: CALL 73734 0 2
// end ; 3 :
8780: GO 8967
8782: LD_INT 3
8784: DOUBLE
8785: EQUAL
8786: IFTRUE 8790
8788: GO 8966
8790: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8791: LD_ADDR_VAR 0 3
8795: PUSH
8796: LD_INT 22
8798: PUSH
8799: LD_INT 1
8801: PUSH
8802: LD_INT 3
8804: PUSH
8805: LD_INT 43
8807: PUSH
8808: EMPTY
8809: LIST
8810: LIST
8811: LIST
8812: LIST
8813: PUSH
8814: LD_INT 24
8816: PUSH
8817: LD_INT 1
8819: PUSH
8820: LD_INT 3
8822: PUSH
8823: LD_INT 46
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: LIST
8830: LIST
8831: PUSH
8832: LD_INT 22
8834: PUSH
8835: LD_INT 1
8837: PUSH
8838: LD_INT 3
8840: PUSH
8841: LD_INT 43
8843: PUSH
8844: EMPTY
8845: LIST
8846: LIST
8847: LIST
8848: LIST
8849: PUSH
8850: LD_INT 24
8852: PUSH
8853: LD_INT 1
8855: PUSH
8856: LD_INT 3
8858: PUSH
8859: LD_INT 46
8861: PUSH
8862: EMPTY
8863: LIST
8864: LIST
8865: LIST
8866: LIST
8867: PUSH
8868: LD_INT 22
8870: PUSH
8871: LD_INT 1
8873: PUSH
8874: LD_INT 3
8876: PUSH
8877: LD_INT 45
8879: PUSH
8880: EMPTY
8881: LIST
8882: LIST
8883: LIST
8884: LIST
8885: PUSH
8886: LD_INT 22
8888: PUSH
8889: LD_INT 1
8891: PUSH
8892: LD_INT 3
8894: PUSH
8895: LD_INT 43
8897: PUSH
8898: EMPTY
8899: LIST
8900: LIST
8901: LIST
8902: LIST
8903: PUSH
8904: LD_INT 24
8906: PUSH
8907: LD_INT 1
8909: PUSH
8910: LD_INT 3
8912: PUSH
8913: LD_INT 46
8915: PUSH
8916: EMPTY
8917: LIST
8918: LIST
8919: LIST
8920: LIST
8921: PUSH
8922: LD_INT 22
8924: PUSH
8925: LD_INT 1
8927: PUSH
8928: LD_INT 3
8930: PUSH
8931: LD_INT 45
8933: PUSH
8934: EMPTY
8935: LIST
8936: LIST
8937: LIST
8938: LIST
8939: PUSH
8940: EMPTY
8941: LIST
8942: LIST
8943: LIST
8944: LIST
8945: LIST
8946: LIST
8947: LIST
8948: LIST
8949: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8950: LD_VAR 0 2
8954: PPUSH
8955: LD_VAR 0 3
8959: PPUSH
8960: CALL 73734 0 2
// end ; end ;
8964: GO 8967
8966: POP
// repeat wait ( 0 0$1 ) ;
8967: LD_INT 35
8969: PPUSH
8970: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8974: LD_VAR 0 2
8978: PPUSH
8979: LD_INT 1
8981: PPUSH
8982: CALL 75152 0 2
8986: PUSH
8987: LD_INT 8
8989: GREATEREQUAL
8990: IFFALSE 8967
// wait ( 0 0$30 ) ;
8992: LD_INT 1050
8994: PPUSH
8995: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8999: LD_ADDR_VAR 0 5
9003: PUSH
9004: LD_INT 144
9006: PUSH
9007: LD_INT 65
9009: PUSH
9010: EMPTY
9011: LIST
9012: LIST
9013: PUSH
9014: LD_INT 63
9016: PUSH
9017: LD_INT 38
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PUSH
9024: EMPTY
9025: LIST
9026: LIST
9027: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
9028: LD_ADDR_VAR 0 4
9032: PUSH
9033: LD_INT 0
9035: PUSH
9036: LD_INT 0
9038: PUSH
9039: LD_INT 0
9041: PUSH
9042: LD_INT 1
9044: PUSH
9045: LD_INT 0
9047: PUSH
9048: LD_INT 0
9050: PUSH
9051: LD_INT 0
9053: PUSH
9054: LD_INT 0
9056: PUSH
9057: LD_INT 1
9059: PUSH
9060: LD_INT 0
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: LIST
9067: LIST
9068: LIST
9069: LIST
9070: LIST
9071: LIST
9072: LIST
9073: LIST
9074: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
9075: LD_ADDR_VAR 0 6
9079: PUSH
9080: LD_EXP 84
9084: PUSH
9085: LD_VAR 0 2
9089: ARRAY
9090: PUSH
9091: LD_EXP 87
9095: PUSH
9096: LD_VAR 0 2
9100: ARRAY
9101: DIFF
9102: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
9103: LD_ADDR_EXP 84
9107: PUSH
9108: LD_EXP 84
9112: PPUSH
9113: LD_VAR 0 2
9117: PPUSH
9118: LD_EXP 84
9122: PUSH
9123: LD_VAR 0 2
9127: ARRAY
9128: PUSH
9129: LD_VAR 0 6
9133: DIFF
9134: PPUSH
9135: CALL_OW 1
9139: ST_TO_ADDR
// if not attackers then
9140: LD_VAR 0 6
9144: NOT
9145: IFFALSE 9149
// continue ;
9147: GO 8338
// repeat wait ( 0 0$1 ) ;
9149: LD_INT 35
9151: PPUSH
9152: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
9156: LD_VAR 0 6
9160: PPUSH
9161: LD_INT 60
9163: PUSH
9164: EMPTY
9165: LIST
9166: PPUSH
9167: CALL_OW 72
9171: NOT
9172: IFFALSE 9149
// repeat wait ( 0 0$1 ) ;
9174: LD_INT 35
9176: PPUSH
9177: CALL_OW 67
// for i in attackers do
9181: LD_ADDR_VAR 0 1
9185: PUSH
9186: LD_VAR 0 6
9190: PUSH
9191: FOR_IN
9192: IFFALSE 9476
// begin if IsDead ( i ) then
9194: LD_VAR 0 1
9198: PPUSH
9199: CALL_OW 301
9203: IFFALSE 9221
// attackers := attackers diff i ;
9205: LD_ADDR_VAR 0 6
9209: PUSH
9210: LD_VAR 0 6
9214: PUSH
9215: LD_VAR 0 1
9219: DIFF
9220: ST_TO_ADDR
// if not HasTask ( i ) then
9221: LD_VAR 0 1
9225: PPUSH
9226: CALL_OW 314
9230: NOT
9231: IFFALSE 9474
// begin if not GetTag ( i ) then
9233: LD_VAR 0 1
9237: PPUSH
9238: CALL_OW 110
9242: NOT
9243: IFFALSE 9335
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
9245: LD_VAR 0 1
9249: PPUSH
9250: LD_VAR 0 5
9254: PUSH
9255: LD_INT 1
9257: ARRAY
9258: PUSH
9259: LD_INT 1
9261: ARRAY
9262: PPUSH
9263: LD_VAR 0 5
9267: PUSH
9268: LD_INT 1
9270: ARRAY
9271: PUSH
9272: LD_INT 2
9274: ARRAY
9275: PPUSH
9276: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
9280: LD_VAR 0 1
9284: PPUSH
9285: LD_VAR 0 5
9289: PUSH
9290: LD_INT 1
9292: ARRAY
9293: PUSH
9294: LD_INT 1
9296: ARRAY
9297: PPUSH
9298: LD_VAR 0 5
9302: PUSH
9303: LD_INT 1
9305: ARRAY
9306: PUSH
9307: LD_INT 2
9309: ARRAY
9310: PPUSH
9311: CALL_OW 297
9315: PUSH
9316: LD_INT 8
9318: LESS
9319: IFFALSE 9333
// SetTag ( i , 1 ) ;
9321: LD_VAR 0 1
9325: PPUSH
9326: LD_INT 1
9328: PPUSH
9329: CALL_OW 109
// end else
9333: GO 9474
// if GetTag ( i ) = 1 then
9335: LD_VAR 0 1
9339: PPUSH
9340: CALL_OW 110
9344: PUSH
9345: LD_INT 1
9347: EQUAL
9348: IFFALSE 9440
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
9350: LD_VAR 0 1
9354: PPUSH
9355: LD_VAR 0 5
9359: PUSH
9360: LD_INT 2
9362: ARRAY
9363: PUSH
9364: LD_INT 1
9366: ARRAY
9367: PPUSH
9368: LD_VAR 0 5
9372: PUSH
9373: LD_INT 2
9375: ARRAY
9376: PUSH
9377: LD_INT 2
9379: ARRAY
9380: PPUSH
9381: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
9385: LD_VAR 0 1
9389: PPUSH
9390: LD_VAR 0 5
9394: PUSH
9395: LD_INT 2
9397: ARRAY
9398: PUSH
9399: LD_INT 1
9401: ARRAY
9402: PPUSH
9403: LD_VAR 0 5
9407: PUSH
9408: LD_INT 2
9410: ARRAY
9411: PUSH
9412: LD_INT 2
9414: ARRAY
9415: PPUSH
9416: CALL_OW 297
9420: PUSH
9421: LD_INT 8
9423: LESS
9424: IFFALSE 9438
// SetTag ( i , 2 ) ;
9426: LD_VAR 0 1
9430: PPUSH
9431: LD_INT 2
9433: PPUSH
9434: CALL_OW 109
// end else
9438: GO 9474
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9440: LD_VAR 0 1
9444: PPUSH
9445: LD_INT 81
9447: PUSH
9448: LD_INT 3
9450: PUSH
9451: EMPTY
9452: LIST
9453: LIST
9454: PPUSH
9455: CALL_OW 69
9459: PPUSH
9460: LD_VAR 0 1
9464: PPUSH
9465: CALL_OW 74
9469: PPUSH
9470: CALL_OW 115
// end ; end ;
9474: GO 9191
9476: POP
9477: POP
// until not attackers ;
9478: LD_VAR 0 6
9482: NOT
9483: IFFALSE 9174
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
9485: LD_EXP 65
9489: PUSH
9490: LD_VAR 0 2
9494: ARRAY
9495: PPUSH
9496: LD_INT 50
9498: PUSH
9499: EMPTY
9500: LIST
9501: PPUSH
9502: CALL_OW 72
9506: NOT
9507: IFFALSE 8338
// end ;
9509: PPOPN 6
9511: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9512: LD_EXP 4
9516: PUSH
9517: LD_INT 22
9519: PUSH
9520: LD_INT 3
9522: PUSH
9523: EMPTY
9524: LIST
9525: LIST
9526: PUSH
9527: LD_INT 21
9529: PUSH
9530: LD_INT 1
9532: PUSH
9533: EMPTY
9534: LIST
9535: LIST
9536: PUSH
9537: EMPTY
9538: LIST
9539: LIST
9540: PPUSH
9541: CALL_OW 69
9545: PUSH
9546: LD_INT 0
9548: EQUAL
9549: AND
9550: IFFALSE 9563
9552: GO 9554
9554: DISABLE
// RussiansDefeated := true ;
9555: LD_ADDR_EXP 44
9559: PUSH
9560: LD_INT 1
9562: ST_TO_ADDR
9563: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
9564: LD_EXP 4
9568: PUSH
9569: LD_EXP 6
9573: NOT
9574: AND
9575: IFFALSE 10999
9577: GO 9579
9579: DISABLE
9580: LD_INT 0
9582: PPUSH
9583: PPUSH
9584: PPUSH
9585: PPUSH
9586: PPUSH
9587: PPUSH
9588: PPUSH
9589: PPUSH
9590: PPUSH
9591: PPUSH
9592: PPUSH
9593: PPUSH
// begin wait ( [ Rand ( 4 4$00 , 4 4$30 ) , Rand ( 4 4$30 , 3 3$30 ) , Rand ( 3 3$00 , 2 2$00 ) ] [ Difficulty ] ) ;
9594: LD_INT 8400
9596: PPUSH
9597: LD_INT 9450
9599: PPUSH
9600: CALL_OW 12
9604: PUSH
9605: LD_INT 9450
9607: PPUSH
9608: LD_INT 7350
9610: PPUSH
9611: CALL_OW 12
9615: PUSH
9616: LD_INT 6300
9618: PPUSH
9619: LD_INT 4200
9621: PPUSH
9622: CALL_OW 12
9626: PUSH
9627: EMPTY
9628: LIST
9629: LIST
9630: LIST
9631: PUSH
9632: LD_OWVAR 67
9636: ARRAY
9637: PPUSH
9638: CALL_OW 67
// filter := [ ] ;
9642: LD_ADDR_VAR 0 3
9646: PUSH
9647: EMPTY
9648: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9649: LD_ADDR_VAR 0 4
9653: PUSH
9654: LD_INT 2
9656: PPUSH
9657: LD_INT 3
9659: PPUSH
9660: CALL_OW 12
9664: PUSH
9665: LD_INT 3
9667: PPUSH
9668: LD_INT 4
9670: PPUSH
9671: CALL_OW 12
9675: PUSH
9676: LD_INT 3
9678: PPUSH
9679: LD_INT 5
9681: PPUSH
9682: CALL_OW 12
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: LIST
9691: PUSH
9692: LD_OWVAR 67
9696: ARRAY
9697: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
9698: LD_ADDR_VAR 0 5
9702: PUSH
9703: LD_INT 1
9705: PUSH
9706: LD_INT 1
9708: PPUSH
9709: LD_INT 2
9711: PPUSH
9712: CALL_OW 12
9716: PUSH
9717: LD_INT 2
9719: PPUSH
9720: LD_INT 3
9722: PPUSH
9723: CALL_OW 12
9727: PUSH
9728: EMPTY
9729: LIST
9730: LIST
9731: LIST
9732: PUSH
9733: LD_OWVAR 67
9737: ARRAY
9738: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9739: LD_ADDR_VAR 0 6
9743: PUSH
9744: LD_INT 2
9746: PPUSH
9747: LD_INT 3
9749: PPUSH
9750: CALL_OW 12
9754: PUSH
9755: LD_INT 2
9757: PPUSH
9758: LD_INT 4
9760: PPUSH
9761: CALL_OW 12
9765: PUSH
9766: LD_INT 3
9768: PPUSH
9769: LD_INT 5
9771: PPUSH
9772: CALL_OW 12
9776: PUSH
9777: EMPTY
9778: LIST
9779: LIST
9780: LIST
9781: PUSH
9782: LD_OWVAR 67
9786: ARRAY
9787: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
9788: LD_ADDR_VAR 0 8
9792: PUSH
9793: LD_INT 1
9795: PUSH
9796: LD_INT 2
9798: PUSH
9799: LD_INT 2
9801: PUSH
9802: EMPTY
9803: LIST
9804: LIST
9805: LIST
9806: PUSH
9807: LD_OWVAR 67
9811: ARRAY
9812: ST_TO_ADDR
// uc_side := 3 ;
9813: LD_ADDR_OWVAR 20
9817: PUSH
9818: LD_INT 3
9820: ST_TO_ADDR
// uc_nation := nation_russian ;
9821: LD_ADDR_OWVAR 21
9825: PUSH
9826: LD_INT 3
9828: ST_TO_ADDR
// for i = 1 to soldiers do
9829: LD_ADDR_VAR 0 1
9833: PUSH
9834: DOUBLE
9835: LD_INT 1
9837: DEC
9838: ST_TO_ADDR
9839: LD_VAR 0 4
9843: PUSH
9844: FOR_TO
9845: IFFALSE 9887
// begin PrepareSoldier ( 0 , game_eskill ) ;
9847: LD_INT 0
9849: PPUSH
9850: LD_EXP 40
9854: PPUSH
9855: CALL_OW 381
// un := CreateHuman ;
9859: LD_ADDR_VAR 0 2
9863: PUSH
9864: CALL_OW 44
9868: ST_TO_ADDR
// filter := filter ^ un ;
9869: LD_ADDR_VAR 0 3
9873: PUSH
9874: LD_VAR 0 3
9878: PUSH
9879: LD_VAR 0 2
9883: ADD
9884: ST_TO_ADDR
// end ;
9885: GO 9844
9887: POP
9888: POP
// for i = 1 to bazookas do
9889: LD_ADDR_VAR 0 1
9893: PUSH
9894: DOUBLE
9895: LD_INT 1
9897: DEC
9898: ST_TO_ADDR
9899: LD_VAR 0 5
9903: PUSH
9904: FOR_TO
9905: IFFALSE 9955
// begin PrepareSoldier ( 0 , game_eskill ) ;
9907: LD_INT 0
9909: PPUSH
9910: LD_EXP 40
9914: PPUSH
9915: CALL_OW 381
// hc_class := class_bazooker ;
9919: LD_ADDR_OWVAR 28
9923: PUSH
9924: LD_INT 9
9926: ST_TO_ADDR
// un := CreateHuman ;
9927: LD_ADDR_VAR 0 2
9931: PUSH
9932: CALL_OW 44
9936: ST_TO_ADDR
// filter := filter ^ un ;
9937: LD_ADDR_VAR 0 3
9941: PUSH
9942: LD_VAR 0 3
9946: PUSH
9947: LD_VAR 0 2
9951: ADD
9952: ST_TO_ADDR
// end ;
9953: GO 9904
9955: POP
9956: POP
// for i = 1 to medics do
9957: LD_ADDR_VAR 0 1
9961: PUSH
9962: DOUBLE
9963: LD_INT 1
9965: DEC
9966: ST_TO_ADDR
9967: LD_VAR 0 8
9971: PUSH
9972: FOR_TO
9973: IFFALSE 10015
// begin PrepareScientist ( 0 , game_eskill ) ;
9975: LD_INT 0
9977: PPUSH
9978: LD_EXP 40
9982: PPUSH
9983: CALL_OW 384
// un := CreateHuman ;
9987: LD_ADDR_VAR 0 2
9991: PUSH
9992: CALL_OW 44
9996: ST_TO_ADDR
// filter := filter ^ un ;
9997: LD_ADDR_VAR 0 3
10001: PUSH
10002: LD_VAR 0 3
10006: PUSH
10007: LD_VAR 0 2
10011: ADD
10012: ST_TO_ADDR
// end ;
10013: GO 9972
10015: POP
10016: POP
// for i = 1 to vehs do
10017: LD_ADDR_VAR 0 1
10021: PUSH
10022: DOUBLE
10023: LD_INT 1
10025: DEC
10026: ST_TO_ADDR
10027: LD_VAR 0 6
10031: PUSH
10032: FOR_TO
10033: IFFALSE 10225
// begin case Rand ( 1 , 5 ) of 1 :
10035: LD_INT 1
10037: PPUSH
10038: LD_INT 5
10040: PPUSH
10041: CALL_OW 12
10045: PUSH
10046: LD_INT 1
10048: DOUBLE
10049: EQUAL
10050: IFTRUE 10054
10052: GO 10076
10054: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
10055: LD_INT 22
10057: PPUSH
10058: LD_INT 3
10060: PPUSH
10061: LD_INT 3
10063: PPUSH
10064: LD_INT 43
10066: PPUSH
10067: LD_INT 100
10069: PPUSH
10070: CALL 18382 0 5
10074: GO 10197
10076: LD_INT 2
10078: DOUBLE
10079: EQUAL
10080: IFTRUE 10084
10082: GO 10106
10084: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
10085: LD_INT 22
10087: PPUSH
10088: LD_INT 3
10090: PPUSH
10091: LD_INT 3
10093: PPUSH
10094: LD_INT 44
10096: PPUSH
10097: LD_INT 100
10099: PPUSH
10100: CALL 18382 0 5
10104: GO 10197
10106: LD_INT 3
10108: DOUBLE
10109: EQUAL
10110: IFTRUE 10114
10112: GO 10136
10114: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
10115: LD_INT 22
10117: PPUSH
10118: LD_INT 3
10120: PPUSH
10121: LD_INT 3
10123: PPUSH
10124: LD_INT 45
10126: PPUSH
10127: LD_INT 100
10129: PPUSH
10130: CALL 18382 0 5
10134: GO 10197
10136: LD_INT 4
10138: DOUBLE
10139: EQUAL
10140: IFTRUE 10144
10142: GO 10166
10144: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
10145: LD_INT 24
10147: PPUSH
10148: LD_INT 3
10150: PPUSH
10151: LD_INT 3
10153: PPUSH
10154: LD_INT 43
10156: PPUSH
10157: LD_INT 100
10159: PPUSH
10160: CALL 18382 0 5
10164: GO 10197
10166: LD_INT 5
10168: DOUBLE
10169: EQUAL
10170: IFTRUE 10174
10172: GO 10196
10174: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
10175: LD_INT 24
10177: PPUSH
10178: LD_INT 3
10180: PPUSH
10181: LD_INT 3
10183: PPUSH
10184: LD_INT 46
10186: PPUSH
10187: LD_INT 100
10189: PPUSH
10190: CALL 18382 0 5
10194: GO 10197
10196: POP
// vehicle := CreateVehicle ;
10197: LD_ADDR_VAR 0 7
10201: PUSH
10202: CALL_OW 45
10206: ST_TO_ADDR
// filter := filter ^ vehicle ;
10207: LD_ADDR_VAR 0 3
10211: PUSH
10212: LD_VAR 0 3
10216: PUSH
10217: LD_VAR 0 7
10221: ADD
10222: ST_TO_ADDR
// end ;
10223: GO 10032
10225: POP
10226: POP
// for i = 1 to filter do
10227: LD_ADDR_VAR 0 1
10231: PUSH
10232: DOUBLE
10233: LD_INT 1
10235: DEC
10236: ST_TO_ADDR
10237: LD_VAR 0 3
10241: PUSH
10242: FOR_TO
10243: IFFALSE 10268
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
10245: LD_VAR 0 3
10249: PUSH
10250: LD_VAR 0 1
10254: ARRAY
10255: PPUSH
10256: LD_INT 14
10258: PPUSH
10259: LD_INT 0
10261: PPUSH
10262: CALL_OW 49
10266: GO 10242
10268: POP
10269: POP
// case Rand ( 1 , 3 ) of 1 :
10270: LD_INT 1
10272: PPUSH
10273: LD_INT 3
10275: PPUSH
10276: CALL_OW 12
10280: PUSH
10281: LD_INT 1
10283: DOUBLE
10284: EQUAL
10285: IFTRUE 10289
10287: GO 10343
10289: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
10290: LD_ADDR_VAR 0 11
10294: PUSH
10295: LD_INT 165
10297: PUSH
10298: LD_INT 114
10300: PUSH
10301: EMPTY
10302: LIST
10303: LIST
10304: PUSH
10305: LD_INT 104
10307: PUSH
10308: LD_INT 108
10310: PUSH
10311: EMPTY
10312: LIST
10313: LIST
10314: PUSH
10315: LD_INT 86
10317: PUSH
10318: LD_INT 77
10320: PUSH
10321: EMPTY
10322: LIST
10323: LIST
10324: PUSH
10325: LD_INT 63
10327: PUSH
10328: LD_INT 38
10330: PUSH
10331: EMPTY
10332: LIST
10333: LIST
10334: PUSH
10335: EMPTY
10336: LIST
10337: LIST
10338: LIST
10339: LIST
10340: ST_TO_ADDR
10341: GO 10468
10343: LD_INT 2
10345: DOUBLE
10346: EQUAL
10347: IFTRUE 10351
10349: GO 10405
10351: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
10352: LD_ADDR_VAR 0 11
10356: PUSH
10357: LD_INT 165
10359: PUSH
10360: LD_INT 114
10362: PUSH
10363: EMPTY
10364: LIST
10365: LIST
10366: PUSH
10367: LD_INT 146
10369: PUSH
10370: LD_INT 71
10372: PUSH
10373: EMPTY
10374: LIST
10375: LIST
10376: PUSH
10377: LD_INT 112
10379: PUSH
10380: LD_INT 41
10382: PUSH
10383: EMPTY
10384: LIST
10385: LIST
10386: PUSH
10387: LD_INT 63
10389: PUSH
10390: LD_INT 38
10392: PUSH
10393: EMPTY
10394: LIST
10395: LIST
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: LIST
10401: LIST
10402: ST_TO_ADDR
10403: GO 10468
10405: LD_INT 3
10407: DOUBLE
10408: EQUAL
10409: IFTRUE 10413
10411: GO 10467
10413: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
10414: LD_ADDR_VAR 0 11
10418: PUSH
10419: LD_INT 165
10421: PUSH
10422: LD_INT 114
10424: PUSH
10425: EMPTY
10426: LIST
10427: LIST
10428: PUSH
10429: LD_INT 63
10431: PUSH
10432: LD_INT 99
10434: PUSH
10435: EMPTY
10436: LIST
10437: LIST
10438: PUSH
10439: LD_INT 55
10441: PUSH
10442: LD_INT 77
10444: PUSH
10445: EMPTY
10446: LIST
10447: LIST
10448: PUSH
10449: LD_INT 63
10451: PUSH
10452: LD_INT 38
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: LIST
10463: LIST
10464: ST_TO_ADDR
10465: GO 10468
10467: POP
// attackers := filter ;
10468: LD_ADDR_VAR 0 10
10472: PUSH
10473: LD_VAR 0 3
10477: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10478: LD_INT 35
10480: PPUSH
10481: CALL_OW 67
// for i in attackers do
10485: LD_ADDR_VAR 0 1
10489: PUSH
10490: LD_VAR 0 10
10494: PUSH
10495: FOR_IN
10496: IFFALSE 10990
// begin if IsDead ( i ) then
10498: LD_VAR 0 1
10502: PPUSH
10503: CALL_OW 301
10507: IFFALSE 10525
// attackers := attackers diff i ;
10509: LD_ADDR_VAR 0 10
10513: PUSH
10514: LD_VAR 0 10
10518: PUSH
10519: LD_VAR 0 1
10523: DIFF
10524: ST_TO_ADDR
// if not HasTask ( i ) then
10525: LD_VAR 0 1
10529: PPUSH
10530: CALL_OW 314
10534: NOT
10535: IFFALSE 10988
// begin if not GetTag ( i ) then
10537: LD_VAR 0 1
10541: PPUSH
10542: CALL_OW 110
10546: NOT
10547: IFFALSE 10639
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
10549: LD_VAR 0 1
10553: PPUSH
10554: LD_VAR 0 11
10558: PUSH
10559: LD_INT 1
10561: ARRAY
10562: PUSH
10563: LD_INT 1
10565: ARRAY
10566: PPUSH
10567: LD_VAR 0 11
10571: PUSH
10572: LD_INT 1
10574: ARRAY
10575: PUSH
10576: LD_INT 2
10578: ARRAY
10579: PPUSH
10580: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
10584: LD_VAR 0 1
10588: PPUSH
10589: LD_VAR 0 11
10593: PUSH
10594: LD_INT 1
10596: ARRAY
10597: PUSH
10598: LD_INT 1
10600: ARRAY
10601: PPUSH
10602: LD_VAR 0 11
10606: PUSH
10607: LD_INT 1
10609: ARRAY
10610: PUSH
10611: LD_INT 2
10613: ARRAY
10614: PPUSH
10615: CALL_OW 297
10619: PUSH
10620: LD_INT 8
10622: LESS
10623: IFFALSE 10637
// SetTag ( i , 1 ) ;
10625: LD_VAR 0 1
10629: PPUSH
10630: LD_INT 1
10632: PPUSH
10633: CALL_OW 109
// end else
10637: GO 10988
// if GetTag ( i ) = 1 then
10639: LD_VAR 0 1
10643: PPUSH
10644: CALL_OW 110
10648: PUSH
10649: LD_INT 1
10651: EQUAL
10652: IFFALSE 10744
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
10654: LD_VAR 0 1
10658: PPUSH
10659: LD_VAR 0 11
10663: PUSH
10664: LD_INT 2
10666: ARRAY
10667: PUSH
10668: LD_INT 1
10670: ARRAY
10671: PPUSH
10672: LD_VAR 0 11
10676: PUSH
10677: LD_INT 2
10679: ARRAY
10680: PUSH
10681: LD_INT 2
10683: ARRAY
10684: PPUSH
10685: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
10689: LD_VAR 0 1
10693: PPUSH
10694: LD_VAR 0 11
10698: PUSH
10699: LD_INT 2
10701: ARRAY
10702: PUSH
10703: LD_INT 1
10705: ARRAY
10706: PPUSH
10707: LD_VAR 0 11
10711: PUSH
10712: LD_INT 2
10714: ARRAY
10715: PUSH
10716: LD_INT 2
10718: ARRAY
10719: PPUSH
10720: CALL_OW 297
10724: PUSH
10725: LD_INT 8
10727: LESS
10728: IFFALSE 10742
// SetTag ( i , 2 ) ;
10730: LD_VAR 0 1
10734: PPUSH
10735: LD_INT 2
10737: PPUSH
10738: CALL_OW 109
// end else
10742: GO 10988
// if GetTag ( i ) = 2 then
10744: LD_VAR 0 1
10748: PPUSH
10749: CALL_OW 110
10753: PUSH
10754: LD_INT 2
10756: EQUAL
10757: IFFALSE 10849
// begin ComAgressiveMove ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) ;
10759: LD_VAR 0 1
10763: PPUSH
10764: LD_VAR 0 11
10768: PUSH
10769: LD_INT 3
10771: ARRAY
10772: PUSH
10773: LD_INT 1
10775: ARRAY
10776: PPUSH
10777: LD_VAR 0 11
10781: PUSH
10782: LD_INT 3
10784: ARRAY
10785: PUSH
10786: LD_INT 2
10788: ARRAY
10789: PPUSH
10790: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) < 8 then
10794: LD_VAR 0 1
10798: PPUSH
10799: LD_VAR 0 11
10803: PUSH
10804: LD_INT 3
10806: ARRAY
10807: PUSH
10808: LD_INT 1
10810: ARRAY
10811: PPUSH
10812: LD_VAR 0 11
10816: PUSH
10817: LD_INT 3
10819: ARRAY
10820: PUSH
10821: LD_INT 2
10823: ARRAY
10824: PPUSH
10825: CALL_OW 297
10829: PUSH
10830: LD_INT 8
10832: LESS
10833: IFFALSE 10847
// SetTag ( i , 3 ) ;
10835: LD_VAR 0 1
10839: PPUSH
10840: LD_INT 3
10842: PPUSH
10843: CALL_OW 109
// end else
10847: GO 10988
// if GetTag ( i ) = 3 then
10849: LD_VAR 0 1
10853: PPUSH
10854: CALL_OW 110
10858: PUSH
10859: LD_INT 3
10861: EQUAL
10862: IFFALSE 10954
// begin ComAgressiveMove ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) ;
10864: LD_VAR 0 1
10868: PPUSH
10869: LD_VAR 0 11
10873: PUSH
10874: LD_INT 4
10876: ARRAY
10877: PUSH
10878: LD_INT 1
10880: ARRAY
10881: PPUSH
10882: LD_VAR 0 11
10886: PUSH
10887: LD_INT 4
10889: ARRAY
10890: PUSH
10891: LD_INT 2
10893: ARRAY
10894: PPUSH
10895: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) < 8 then
10899: LD_VAR 0 1
10903: PPUSH
10904: LD_VAR 0 11
10908: PUSH
10909: LD_INT 4
10911: ARRAY
10912: PUSH
10913: LD_INT 1
10915: ARRAY
10916: PPUSH
10917: LD_VAR 0 11
10921: PUSH
10922: LD_INT 4
10924: ARRAY
10925: PUSH
10926: LD_INT 2
10928: ARRAY
10929: PPUSH
10930: CALL_OW 297
10934: PUSH
10935: LD_INT 8
10937: LESS
10938: IFFALSE 10952
// SetTag ( i , 4 ) ;
10940: LD_VAR 0 1
10944: PPUSH
10945: LD_INT 4
10947: PPUSH
10948: CALL_OW 109
// end else
10952: GO 10988
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10954: LD_VAR 0 1
10958: PPUSH
10959: LD_INT 81
10961: PUSH
10962: LD_INT 3
10964: PUSH
10965: EMPTY
10966: LIST
10967: LIST
10968: PPUSH
10969: CALL_OW 69
10973: PPUSH
10974: LD_VAR 0 1
10978: PPUSH
10979: CALL_OW 74
10983: PPUSH
10984: CALL_OW 115
// end ; end ;
10988: GO 10495
10990: POP
10991: POP
// until not attackers ;
10992: LD_VAR 0 10
10996: NOT
10997: IFFALSE 10478
// end ;
10999: PPOPN 12
11001: END
// every 0 0$1 do var i , tmp ;
11002: GO 11004
11004: DISABLE
11005: LD_INT 0
11007: PPUSH
11008: PPUSH
// begin enable ;
11009: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
11010: LD_ADDR_VAR 0 2
11014: PUSH
11015: LD_INT 3
11017: PUSH
11018: LD_INT 22
11020: PUSH
11021: LD_INT 1
11023: PUSH
11024: EMPTY
11025: LIST
11026: LIST
11027: PUSH
11028: EMPTY
11029: LIST
11030: LIST
11031: PUSH
11032: LD_INT 32
11034: PUSH
11035: LD_INT 1
11037: PUSH
11038: EMPTY
11039: LIST
11040: LIST
11041: PUSH
11042: EMPTY
11043: LIST
11044: LIST
11045: PPUSH
11046: CALL_OW 69
11050: ST_TO_ADDR
// if tmp then
11051: LD_VAR 0 2
11055: IFFALSE 11101
// for i in tmp do
11057: LD_ADDR_VAR 0 1
11061: PUSH
11062: LD_VAR 0 2
11066: PUSH
11067: FOR_IN
11068: IFFALSE 11099
// if GetFuel ( i ) < 3 then
11070: LD_VAR 0 1
11074: PPUSH
11075: CALL_OW 261
11079: PUSH
11080: LD_INT 3
11082: LESS
11083: IFFALSE 11097
// SetFuel ( i , 3 ) ;
11085: LD_VAR 0 1
11089: PPUSH
11090: LD_INT 3
11092: PPUSH
11093: CALL_OW 240
11097: GO 11067
11099: POP
11100: POP
// end ;
11101: PPOPN 2
11103: END
// every 0 0$1 trigger ( FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) and not JMMArrival ) or ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) and not FirstAssaultRepelled ) do
11104: LD_INT 3
11106: PPUSH
11107: LD_INT 22
11109: PUSH
11110: LD_INT 1
11112: PUSH
11113: EMPTY
11114: LIST
11115: LIST
11116: PPUSH
11117: CALL_OW 70
11121: PUSH
11122: LD_EXP 41
11126: NOT
11127: AND
11128: PUSH
11129: LD_INT 10
11131: PPUSH
11132: LD_INT 22
11134: PUSH
11135: LD_INT 1
11137: PUSH
11138: EMPTY
11139: LIST
11140: LIST
11141: PPUSH
11142: CALL_OW 70
11146: PUSH
11147: LD_EXP 4
11151: NOT
11152: AND
11153: OR
11154: IFFALSE 11163
11156: GO 11158
11158: DISABLE
// Antirush ;
11159: CALL 11164 0 0
11163: END
// export function Antirush ; var i , veh , tmp , num ; begin
11164: LD_INT 0
11166: PPUSH
11167: PPUSH
11168: PPUSH
11169: PPUSH
11170: PPUSH
// tmp := [ ] ;
11171: LD_ADDR_VAR 0 4
11175: PUSH
11176: EMPTY
11177: ST_TO_ADDR
// if not FirstAssaultRepelled then
11178: LD_EXP 4
11182: NOT
11183: IFFALSE 11195
// num := 12 else
11185: LD_ADDR_VAR 0 5
11189: PUSH
11190: LD_INT 12
11192: ST_TO_ADDR
11193: GO 11203
// num := 10 ;
11195: LD_ADDR_VAR 0 5
11199: PUSH
11200: LD_INT 10
11202: ST_TO_ADDR
// num := num - [ 4 , 2 , 0 ] [ Difficulty ] ;
11203: LD_ADDR_VAR 0 5
11207: PUSH
11208: LD_VAR 0 5
11212: PUSH
11213: LD_INT 4
11215: PUSH
11216: LD_INT 2
11218: PUSH
11219: LD_INT 0
11221: PUSH
11222: EMPTY
11223: LIST
11224: LIST
11225: LIST
11226: PUSH
11227: LD_OWVAR 67
11231: ARRAY
11232: MINUS
11233: ST_TO_ADDR
// for i := 1 to num do
11234: LD_ADDR_VAR 0 2
11238: PUSH
11239: DOUBLE
11240: LD_INT 1
11242: DEC
11243: ST_TO_ADDR
11244: LD_VAR 0 5
11248: PUSH
11249: FOR_TO
11250: IFFALSE 11389
// begin uc_side := 3 ;
11252: LD_ADDR_OWVAR 20
11256: PUSH
11257: LD_INT 3
11259: ST_TO_ADDR
// uc_nation := 3 ;
11260: LD_ADDR_OWVAR 21
11264: PUSH
11265: LD_INT 3
11267: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
11268: LD_INT 23
11270: PPUSH
11271: LD_INT 3
11273: PPUSH
11274: LD_INT 3
11276: PPUSH
11277: LD_INT 46
11279: PUSH
11280: LD_INT 43
11282: PUSH
11283: EMPTY
11284: LIST
11285: LIST
11286: PUSH
11287: LD_INT 1
11289: PPUSH
11290: LD_INT 2
11292: PPUSH
11293: CALL_OW 12
11297: ARRAY
11298: PPUSH
11299: LD_INT 100
11301: PPUSH
11302: CALL 18382 0 5
// veh := CreateVehicle ;
11306: LD_ADDR_VAR 0 3
11310: PUSH
11311: CALL_OW 45
11315: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
11316: LD_VAR 0 3
11320: PPUSH
11321: LD_INT 5
11323: PPUSH
11324: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
11328: LD_VAR 0 3
11332: PPUSH
11333: LD_INT 199
11335: PPUSH
11336: LD_INT 135
11338: PPUSH
11339: LD_INT 3
11341: PPUSH
11342: LD_INT 0
11344: PPUSH
11345: CALL_OW 50
// tmp := tmp ^ veh ;
11349: LD_ADDR_VAR 0 4
11353: PUSH
11354: LD_VAR 0 4
11358: PUSH
11359: LD_VAR 0 3
11363: ADD
11364: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
11365: LD_VAR 0 3
11369: PPUSH
11370: LD_INT 173
11372: PPUSH
11373: LD_INT 118
11375: PPUSH
11376: CALL_OW 111
// wait ( 0 0$2 ) ;
11380: LD_INT 70
11382: PPUSH
11383: CALL_OW 67
// end ;
11387: GO 11249
11389: POP
11390: POP
// repeat wait ( 0 0$1 ) ;
11391: LD_INT 35
11393: PPUSH
11394: CALL_OW 67
// for i in tmp do
11398: LD_ADDR_VAR 0 2
11402: PUSH
11403: LD_VAR 0 4
11407: PUSH
11408: FOR_IN
11409: IFFALSE 11476
// if IsDead ( i ) then
11411: LD_VAR 0 2
11415: PPUSH
11416: CALL_OW 301
11420: IFFALSE 11440
// tmp := tmp diff i else
11422: LD_ADDR_VAR 0 4
11426: PUSH
11427: LD_VAR 0 4
11431: PUSH
11432: LD_VAR 0 2
11436: DIFF
11437: ST_TO_ADDR
11438: GO 11474
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
11440: LD_VAR 0 2
11444: PPUSH
11445: LD_INT 22
11447: PUSH
11448: LD_INT 1
11450: PUSH
11451: EMPTY
11452: LIST
11453: LIST
11454: PPUSH
11455: CALL_OW 69
11459: PPUSH
11460: LD_VAR 0 2
11464: PPUSH
11465: CALL_OW 74
11469: PPUSH
11470: CALL_OW 115
11474: GO 11408
11476: POP
11477: POP
// until not tmp ;
11478: LD_VAR 0 4
11482: NOT
11483: IFFALSE 11391
// end ; end_of_file
11485: LD_VAR 0 1
11489: RET
// export Losses ; on UnitDestroyed ( un ) do begin if un = Brighton then
11490: LD_VAR 0 1
11494: PUSH
11495: LD_EXP 9
11499: EQUAL
11500: IFFALSE 11516
// begin wait ( 0 0$1 ) ;
11502: LD_INT 35
11504: PPUSH
11505: CALL_OW 67
// YouLost ( Brighton ) ;
11509: LD_STRING Brighton
11511: PPUSH
11512: CALL_OW 104
// end ; if un = JMM then
11516: LD_VAR 0 1
11520: PUSH
11521: LD_EXP 37
11525: EQUAL
11526: IFFALSE 11542
// begin wait ( 0 0$1 ) ;
11528: LD_INT 35
11530: PPUSH
11531: CALL_OW 67
// YouLost ( JMM ) ;
11535: LD_STRING JMM
11537: PPUSH
11538: CALL_OW 104
// end ; if un = Megan then
11542: LD_VAR 0 1
11546: PUSH
11547: LD_EXP 11
11551: EQUAL
11552: IFFALSE 11566
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
11554: LD_EXP 9
11558: PPUSH
11559: LD_STRING DBrighton-MeganDeath
11561: PPUSH
11562: CALL_OW 88
// end ; if un = Palmer then
11566: LD_VAR 0 1
11570: PUSH
11571: LD_EXP 10
11575: EQUAL
11576: IFFALSE 11590
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
11578: LD_EXP 9
11582: PPUSH
11583: LD_STRING DBrighton-PalmerDeath
11585: PPUSH
11586: CALL_OW 88
// end ; if un = Burlak then
11590: LD_VAR 0 1
11594: PUSH
11595: LD_EXP 19
11599: EQUAL
11600: IFFALSE 11632
// begin if JMM_Arrived then
11602: LD_EXP 6
11606: IFFALSE 11620
// Say ( JMM , DJMM-BurlakDead ) ;
11608: LD_EXP 37
11612: PPUSH
11613: LD_STRING DJMM-BurlakDead
11615: PPUSH
11616: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
11620: LD_EXP 10
11624: PPUSH
11625: LD_STRING DSol-BurlakDead
11627: PPUSH
11628: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
11632: LD_VAR 0 1
11636: PUSH
11637: LD_INT 1
11639: EQUAL
11640: PUSH
11641: LD_VAR 0 1
11645: PUSH
11646: LD_INT 3
11648: EQUAL
11649: OR
11650: IFFALSE 11666
// begin wait ( 0 0$1 ) ;
11652: LD_INT 35
11654: PPUSH
11655: CALL_OW 67
// YouLost ( Depot ) ;
11659: LD_STRING Depot
11661: PPUSH
11662: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
11666: LD_VAR 0 1
11670: PPUSH
11671: CALL_OW 255
11675: PUSH
11676: LD_INT 1
11678: EQUAL
11679: PUSH
11680: LD_VAR 0 1
11684: PPUSH
11685: CALL_OW 247
11689: PUSH
11690: LD_INT 1
11692: EQUAL
11693: AND
11694: IFFALSE 11710
// Losses := Losses + 1 ;
11696: LD_ADDR_EXP 45
11700: PUSH
11701: LD_EXP 45
11705: PUSH
11706: LD_INT 1
11708: PLUS
11709: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11710: LD_VAR 0 1
11714: PPUSH
11715: CALL 77126 0 1
// end ;
11719: PPOPN 1
11721: END
// on UnitGoesToRed ( un ) do begin if un = Yashin then
11722: LD_VAR 0 1
11726: PUSH
11727: LD_EXP 13
11731: EQUAL
11732: IFFALSE 11746
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
11734: LD_EXP 13
11738: PPUSH
11739: LD_STRING DDeath-Yas-3
11741: PPUSH
11742: CALL_OW 91
// if un = Popov then
11746: LD_VAR 0 1
11750: PUSH
11751: LD_EXP 14
11755: EQUAL
11756: IFFALSE 11770
// ForceSay ( Popov , DDeath-Pop-3 ) ;
11758: LD_EXP 14
11762: PPUSH
11763: LD_STRING DDeath-Pop-3
11765: PPUSH
11766: CALL_OW 91
// if un = Gaydar then
11770: LD_VAR 0 1
11774: PUSH
11775: LD_EXP 15
11779: EQUAL
11780: IFFALSE 11794
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
11782: LD_EXP 15
11786: PPUSH
11787: LD_STRING DDeath-Gay-3
11789: PPUSH
11790: CALL_OW 91
// if un = Sevi then
11794: LD_VAR 0 1
11798: PUSH
11799: LD_EXP 16
11803: EQUAL
11804: IFFALSE 11818
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
11806: LD_EXP 16
11810: PPUSH
11811: LD_STRING DDeath-Vse-3
11813: PPUSH
11814: CALL_OW 91
// end ;
11818: PPOPN 1
11820: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
11821: LD_VAR 0 1
11825: PUSH
11826: LD_INT 10
11828: EQUAL
11829: IFFALSE 11867
// begin Say ( Brighton , DBrighton-C1 ) ;
11831: LD_EXP 9
11835: PPUSH
11836: LD_STRING DBrighton-C1
11838: PPUSH
11839: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
11843: LD_EXP 11
11847: PPUSH
11848: LD_STRING DMegan-C1
11850: PPUSH
11851: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
11855: LD_EXP 9
11859: PPUSH
11860: LD_STRING DBrighton-C2
11862: PPUSH
11863: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
11867: LD_VAR 0 1
11871: PPUSH
11872: LD_VAR 0 2
11876: PPUSH
11877: CALL 76822 0 2
// end ;
11881: PPOPN 2
11883: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11884: LD_VAR 0 1
11888: PPUSH
11889: LD_VAR 0 2
11893: PPUSH
11894: CALL 79460 0 2
// end ;
11898: PPOPN 2
11900: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11901: LD_VAR 0 1
11905: PPUSH
11906: CALL 78528 0 1
// end ;
11910: PPOPN 1
11912: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
11913: LD_VAR 0 1
11917: PPUSH
11918: CALL_OW 266
11922: PUSH
11923: LD_INT 0
11925: EQUAL
11926: PUSH
11927: LD_VAR 0 1
11931: PPUSH
11932: CALL_OW 255
11936: PUSH
11937: LD_INT 3
11939: EQUAL
11940: AND
11941: IFFALSE 12003
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
11943: LD_VAR 0 1
11947: PPUSH
11948: CALL_OW 274
11952: PPUSH
11953: LD_INT 1
11955: PPUSH
11956: LD_INT 10000
11958: PPUSH
11959: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
11963: LD_VAR 0 1
11967: PPUSH
11968: CALL_OW 274
11972: PPUSH
11973: LD_INT 2
11975: PPUSH
11976: LD_INT 250
11978: PPUSH
11979: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
11983: LD_VAR 0 1
11987: PPUSH
11988: CALL_OW 274
11992: PPUSH
11993: LD_INT 3
11995: PPUSH
11996: LD_INT 100
11998: PPUSH
11999: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
12003: LD_VAR 0 1
12007: PPUSH
12008: CALL 78769 0 1
// end ;
12012: PPOPN 1
12014: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
12015: LD_VAR 0 1
12019: PPUSH
12020: LD_VAR 0 2
12024: PPUSH
12025: LD_VAR 0 3
12029: PPUSH
12030: LD_VAR 0 4
12034: PPUSH
12035: LD_VAR 0 5
12039: PPUSH
12040: CALL 76442 0 5
// end ;
12044: PPOPN 5
12046: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
12047: LD_VAR 0 1
12051: PPUSH
12052: LD_VAR 0 2
12056: PPUSH
12057: CALL 76038 0 2
// end ;
12061: PPOPN 2
12063: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
12064: LD_VAR 0 1
12068: PPUSH
12069: LD_VAR 0 2
12073: PPUSH
12074: LD_VAR 0 3
12078: PPUSH
12079: LD_VAR 0 4
12083: PPUSH
12084: CALL 75876 0 4
// end ;
12088: PPOPN 4
12090: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
12091: LD_VAR 0 1
12095: PPUSH
12096: LD_VAR 0 2
12100: PPUSH
12101: LD_VAR 0 3
12105: PPUSH
12106: CALL 75651 0 3
// end ;
12110: PPOPN 3
12112: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
12113: LD_VAR 0 1
12117: PPUSH
12118: LD_VAR 0 2
12122: PPUSH
12123: CALL 75536 0 2
// end ;
12127: PPOPN 2
12129: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
12130: LD_VAR 0 1
12134: PPUSH
12135: LD_VAR 0 2
12139: PPUSH
12140: CALL 79721 0 2
// end ;
12144: PPOPN 2
12146: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
12147: LD_VAR 0 1
12151: PPUSH
12152: CALL_OW 255
12156: PUSH
12157: LD_INT 6
12159: EQUAL
12160: IFFALSE 12290
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
12162: LD_VAR 0 1
12166: PUSH
12167: LD_EXP 13
12171: PUSH
12172: LD_EXP 16
12176: PUSH
12177: LD_EXP 15
12181: PUSH
12182: LD_EXP 14
12186: PUSH
12187: EMPTY
12188: LIST
12189: LIST
12190: LIST
12191: LIST
12192: IN
12193: IFFALSE 12197
// exit ;
12195: GO 12314
// if AssaultStarted then
12197: LD_EXP 8
12201: IFFALSE 12275
// case Rand ( 1 , 4 ) of 1 .. 3 :
12203: LD_INT 1
12205: PPUSH
12206: LD_INT 4
12208: PPUSH
12209: CALL_OW 12
12213: PUSH
12214: LD_INT 1
12216: DOUBLE
12217: GREATEREQUAL
12218: IFFALSE 12226
12220: LD_INT 3
12222: DOUBLE
12223: LESSEQUAL
12224: IFTRUE 12228
12226: GO 12246
12228: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
12229: LD_VAR 0 1
12233: PPUSH
12234: LD_INT 67
12236: PPUSH
12237: LD_INT 37
12239: PPUSH
12240: CALL_OW 114
12244: GO 12273
12246: LD_INT 4
12248: DOUBLE
12249: EQUAL
12250: IFTRUE 12254
12252: GO 12272
12254: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
12255: LD_VAR 0 1
12259: PPUSH
12260: LD_INT 120
12262: PPUSH
12263: LD_INT 131
12265: PPUSH
12266: CALL_OW 111
12270: GO 12273
12272: POP
12273: GO 12290
// ComMoveXY ( driver , 120 , 131 ) ;
12275: LD_VAR 0 1
12279: PPUSH
12280: LD_INT 120
12282: PPUSH
12283: LD_INT 131
12285: PPUSH
12286: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12290: LD_VAR 0 1
12294: PPUSH
12295: LD_VAR 0 2
12299: PPUSH
12300: LD_VAR 0 3
12304: PPUSH
12305: LD_VAR 0 4
12309: PPUSH
12310: CALL 79937 0 4
// end ;
12314: PPOPN 4
12316: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12317: LD_VAR 0 1
12321: PPUSH
12322: LD_VAR 0 2
12326: PPUSH
12327: CALL 75345 0 2
// end ;
12331: PPOPN 2
12333: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12334: LD_VAR 0 1
12338: PPUSH
12339: CALL 93351 0 1
// end ; end_of_file
12343: PPOPN 1
12345: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
12346: LD_EXP 6
12350: PUSH
12351: LD_EXP 44
12355: AND
12356: IFFALSE 12527
12358: GO 12360
12360: DISABLE
// begin wait ( 0 0$2 ) ;
12361: LD_INT 70
12363: PPUSH
12364: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
12368: LD_EXP 9
12372: PPUSH
12373: LD_STRING DBrighton-G1
12375: PPUSH
12376: CALL_OW 88
// if Losses < 1 then
12380: LD_EXP 45
12384: PUSH
12385: LD_INT 1
12387: LESS
12388: IFFALSE 12402
// AddMedal ( Losses , 1 ) else
12390: LD_STRING Losses
12392: PPUSH
12393: LD_INT 1
12395: PPUSH
12396: CALL_OW 101
12400: GO 12435
// if Losses < 5 then
12402: LD_EXP 45
12406: PUSH
12407: LD_INT 5
12409: LESS
12410: IFFALSE 12424
// AddMedal ( Losses , 2 ) else
12412: LD_STRING Losses
12414: PPUSH
12415: LD_INT 2
12417: PPUSH
12418: CALL_OW 101
12422: GO 12435
// AddMedal ( Losses , - 1 ) ;
12424: LD_STRING Losses
12426: PPUSH
12427: LD_INT 1
12429: NEG
12430: PPUSH
12431: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12435: LD_EXP 7
12439: PUSH
12440: LD_INT 10
12442: PPUSH
12443: LD_INT 1
12445: PPUSH
12446: CALL_OW 321
12450: PUSH
12451: LD_INT 2
12453: EQUAL
12454: AND
12455: IFFALSE 12469
// AddMedal ( Laser , 1 ) else
12457: LD_STRING Laser
12459: PPUSH
12460: LD_INT 1
12462: PPUSH
12463: CALL_OW 101
12467: GO 12516
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12469: LD_EXP 7
12473: NOT
12474: PUSH
12475: LD_INT 10
12477: PPUSH
12478: LD_INT 1
12480: PPUSH
12481: CALL_OW 321
12485: PUSH
12486: LD_INT 2
12488: EQUAL
12489: AND
12490: IFFALSE 12505
// AddMedal ( Laser , - 1 ) else
12492: LD_STRING Laser
12494: PPUSH
12495: LD_INT 1
12497: NEG
12498: PPUSH
12499: CALL_OW 101
12503: GO 12516
// AddMedal ( Laser , - 2 ) ;
12505: LD_STRING Laser
12507: PPUSH
12508: LD_INT 2
12510: NEG
12511: PPUSH
12512: CALL_OW 101
// GiveMedals ( BaseMain ) ;
12516: LD_STRING BaseMain
12518: PPUSH
12519: CALL_OW 102
// YouWin ;
12523: CALL_OW 103
// end ; end_of_file
12527: END
// export rows ; export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
12528: LD_INT 0
12530: PPUSH
12531: PPUSH
// area = ListEnvironmentArea ( area ) ;
12532: LD_ADDR_VAR 0 2
12536: PUSH
12537: LD_VAR 0 2
12541: PPUSH
12542: CALL_OW 353
12546: ST_TO_ADDR
// if bulldozer > 0 then
12547: LD_VAR 0 1
12551: PUSH
12552: LD_INT 0
12554: GREATER
12555: IFFALSE 12666
// for i = area downto 1 do
12557: LD_ADDR_VAR 0 4
12561: PUSH
12562: DOUBLE
12563: LD_VAR 0 2
12567: INC
12568: ST_TO_ADDR
12569: LD_INT 1
12571: PUSH
12572: FOR_DOWNTO
12573: IFFALSE 12664
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
12575: LD_VAR 0 2
12579: PUSH
12580: LD_VAR 0 4
12584: ARRAY
12585: PUSH
12586: LD_INT 1
12588: ARRAY
12589: PPUSH
12590: LD_VAR 0 2
12594: PUSH
12595: LD_VAR 0 4
12599: ARRAY
12600: PUSH
12601: LD_INT 2
12603: ARRAY
12604: PPUSH
12605: CALL_OW 351
12609: IFFALSE 12662
// if not HasTask ( bulldozer ) then
12611: LD_VAR 0 1
12615: PPUSH
12616: CALL_OW 314
12620: NOT
12621: IFFALSE 12662
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
12623: LD_VAR 0 1
12627: PPUSH
12628: LD_VAR 0 2
12632: PUSH
12633: LD_VAR 0 4
12637: ARRAY
12638: PUSH
12639: LD_INT 1
12641: ARRAY
12642: PPUSH
12643: LD_VAR 0 2
12647: PUSH
12648: LD_VAR 0 4
12652: ARRAY
12653: PUSH
12654: LD_INT 2
12656: ARRAY
12657: PPUSH
12658: CALL_OW 171
12662: GO 12572
12664: POP
12665: POP
// end ;
12666: LD_VAR 0 3
12670: RET
// export function ComMeeting ( team , area ) ; var i , x , tmp , offset , sold_team , civil_team ; begin
12671: LD_INT 0
12673: PPUSH
12674: PPUSH
12675: PPUSH
12676: PPUSH
12677: PPUSH
12678: PPUSH
12679: PPUSH
// sold_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , class_soldier ] ] ) ;
12680: LD_ADDR_VAR 0 8
12684: PUSH
12685: LD_VAR 0 1
12689: PPUSH
12690: LD_INT 22
12692: PUSH
12693: LD_INT 1
12695: PUSH
12696: EMPTY
12697: LIST
12698: LIST
12699: PUSH
12700: LD_INT 21
12702: PUSH
12703: LD_INT 1
12705: PUSH
12706: EMPTY
12707: LIST
12708: LIST
12709: PUSH
12710: LD_INT 25
12712: PUSH
12713: LD_INT 1
12715: PUSH
12716: EMPTY
12717: LIST
12718: LIST
12719: PUSH
12720: EMPTY
12721: LIST
12722: LIST
12723: LIST
12724: PPUSH
12725: CALL_OW 72
12729: ST_TO_ADDR
// civil_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , class_soldier ] ] ] ) ;
12730: LD_ADDR_VAR 0 9
12734: PUSH
12735: LD_VAR 0 1
12739: PPUSH
12740: LD_INT 22
12742: PUSH
12743: LD_INT 1
12745: PUSH
12746: EMPTY
12747: LIST
12748: LIST
12749: PUSH
12750: LD_INT 21
12752: PUSH
12753: LD_INT 1
12755: PUSH
12756: EMPTY
12757: LIST
12758: LIST
12759: PUSH
12760: LD_INT 3
12762: PUSH
12763: LD_INT 25
12765: PUSH
12766: LD_INT 1
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: PUSH
12777: EMPTY
12778: LIST
12779: LIST
12780: LIST
12781: PPUSH
12782: CALL_OW 72
12786: ST_TO_ADDR
// rows = MakeRows ( sold_team , civil_team ) ;
12787: LD_ADDR_EXP 47
12791: PUSH
12792: LD_VAR 0 8
12796: PPUSH
12797: LD_VAR 0 9
12801: PPUSH
12802: CALL 13195 0 2
12806: ST_TO_ADDR
// offset = 0 ;
12807: LD_ADDR_VAR 0 7
12811: PUSH
12812: LD_INT 0
12814: ST_TO_ADDR
// for i := 1 to sold_team do
12815: LD_ADDR_VAR 0 4
12819: PUSH
12820: DOUBLE
12821: LD_INT 1
12823: DEC
12824: ST_TO_ADDR
12825: LD_VAR 0 8
12829: PUSH
12830: FOR_TO
12831: IFFALSE 12962
// begin if IsInUnit ( sold_team [ i ] ) then
12833: LD_VAR 0 8
12837: PUSH
12838: LD_VAR 0 4
12842: ARRAY
12843: PPUSH
12844: CALL_OW 310
12848: IFFALSE 12865
// ComExitBuilding ( sold_team [ i ] ) ;
12850: LD_VAR 0 8
12854: PUSH
12855: LD_VAR 0 4
12859: ARRAY
12860: PPUSH
12861: CALL_OW 122
// AddComMoveXY ( sold_team [ i ] , rows [ 1 ] [ i + offset ] , rows [ 1 ] [ i + 1 + offset ] ) ;
12865: LD_VAR 0 8
12869: PUSH
12870: LD_VAR 0 4
12874: ARRAY
12875: PPUSH
12876: LD_EXP 47
12880: PUSH
12881: LD_INT 1
12883: ARRAY
12884: PUSH
12885: LD_VAR 0 4
12889: PUSH
12890: LD_VAR 0 7
12894: PLUS
12895: ARRAY
12896: PPUSH
12897: LD_EXP 47
12901: PUSH
12902: LD_INT 1
12904: ARRAY
12905: PUSH
12906: LD_VAR 0 4
12910: PUSH
12911: LD_INT 1
12913: PLUS
12914: PUSH
12915: LD_VAR 0 7
12919: PLUS
12920: ARRAY
12921: PPUSH
12922: CALL_OW 171
// AddComTurnUnit ( sold_team [ i ] , Brighton ) ;
12926: LD_VAR 0 8
12930: PUSH
12931: LD_VAR 0 4
12935: ARRAY
12936: PPUSH
12937: LD_EXP 9
12941: PPUSH
12942: CALL_OW 179
// offset = offset + 1 ;
12946: LD_ADDR_VAR 0 7
12950: PUSH
12951: LD_VAR 0 7
12955: PUSH
12956: LD_INT 1
12958: PLUS
12959: ST_TO_ADDR
// end ;
12960: GO 12830
12962: POP
12963: POP
// offset = 0 ;
12964: LD_ADDR_VAR 0 7
12968: PUSH
12969: LD_INT 0
12971: ST_TO_ADDR
// tmp = 1 ;
12972: LD_ADDR_VAR 0 6
12976: PUSH
12977: LD_INT 1
12979: ST_TO_ADDR
// for i := 2 to rows do
12980: LD_ADDR_VAR 0 4
12984: PUSH
12985: DOUBLE
12986: LD_INT 2
12988: DEC
12989: ST_TO_ADDR
12990: LD_EXP 47
12994: PUSH
12995: FOR_TO
12996: IFFALSE 13188
// begin for x := 1 to sold_team do
12998: LD_ADDR_VAR 0 5
13002: PUSH
13003: DOUBLE
13004: LD_INT 1
13006: DEC
13007: ST_TO_ADDR
13008: LD_VAR 0 8
13012: PUSH
13013: FOR_TO
13014: IFFALSE 13176
// begin if IsInUnit ( civil_team [ tmp ] ) then
13016: LD_VAR 0 9
13020: PUSH
13021: LD_VAR 0 6
13025: ARRAY
13026: PPUSH
13027: CALL_OW 310
13031: IFFALSE 13048
// ComExitBuilding ( civil_team [ tmp ] ) ;
13033: LD_VAR 0 9
13037: PUSH
13038: LD_VAR 0 6
13042: ARRAY
13043: PPUSH
13044: CALL_OW 122
// AddComMoveXY ( civil_team [ tmp ] , rows [ i ] [ x + offset ] , rows [ i ] [ x + 1 + offset ] ) ;
13048: LD_VAR 0 9
13052: PUSH
13053: LD_VAR 0 6
13057: ARRAY
13058: PPUSH
13059: LD_EXP 47
13063: PUSH
13064: LD_VAR 0 4
13068: ARRAY
13069: PUSH
13070: LD_VAR 0 5
13074: PUSH
13075: LD_VAR 0 7
13079: PLUS
13080: ARRAY
13081: PPUSH
13082: LD_EXP 47
13086: PUSH
13087: LD_VAR 0 4
13091: ARRAY
13092: PUSH
13093: LD_VAR 0 5
13097: PUSH
13098: LD_INT 1
13100: PLUS
13101: PUSH
13102: LD_VAR 0 7
13106: PLUS
13107: ARRAY
13108: PPUSH
13109: CALL_OW 171
// AddComTurnUnit ( civil_team [ tmp ] , Brighton ) ;
13113: LD_VAR 0 9
13117: PUSH
13118: LD_VAR 0 6
13122: ARRAY
13123: PPUSH
13124: LD_EXP 9
13128: PPUSH
13129: CALL_OW 179
// offset = offset + 1 ;
13133: LD_ADDR_VAR 0 7
13137: PUSH
13138: LD_VAR 0 7
13142: PUSH
13143: LD_INT 1
13145: PLUS
13146: ST_TO_ADDR
// if not ( tmp = civil_team ) then
13147: LD_VAR 0 6
13151: PUSH
13152: LD_VAR 0 9
13156: EQUAL
13157: NOT
13158: IFFALSE 13174
// tmp = tmp + 1 ;
13160: LD_ADDR_VAR 0 6
13164: PUSH
13165: LD_VAR 0 6
13169: PUSH
13170: LD_INT 1
13172: PLUS
13173: ST_TO_ADDR
// end ;
13174: GO 13013
13176: POP
13177: POP
// offset = 0 ;
13178: LD_ADDR_VAR 0 7
13182: PUSH
13183: LD_INT 0
13185: ST_TO_ADDR
// end ;
13186: GO 12995
13188: POP
13189: POP
// end ;
13190: LD_VAR 0 3
13194: RET
// export function MakeRows ( sold_team , civil_team ) ; var i , x , start_pos , row_size , new_row , result_rows , civil_rows , offsetX , offsetY ; begin
13195: LD_INT 0
13197: PPUSH
13198: PPUSH
13199: PPUSH
13200: PPUSH
13201: PPUSH
13202: PPUSH
13203: PPUSH
13204: PPUSH
13205: PPUSH
13206: PPUSH
// start_pos = [ 65 , 34 ] ;
13207: LD_ADDR_VAR 0 6
13211: PUSH
13212: LD_INT 65
13214: PUSH
13215: LD_INT 34
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: ST_TO_ADDR
// row_size = 0 ;
13222: LD_ADDR_VAR 0 7
13226: PUSH
13227: LD_INT 0
13229: ST_TO_ADDR
// result_rows = [ ] ;
13230: LD_ADDR_VAR 0 9
13234: PUSH
13235: EMPTY
13236: ST_TO_ADDR
// new_row = [ ] ;
13237: LD_ADDR_VAR 0 8
13241: PUSH
13242: EMPTY
13243: ST_TO_ADDR
// for i := 1 to sold_team do
13244: LD_ADDR_VAR 0 4
13248: PUSH
13249: DOUBLE
13250: LD_INT 1
13252: DEC
13253: ST_TO_ADDR
13254: LD_VAR 0 1
13258: PUSH
13259: FOR_TO
13260: IFFALSE 13314
// begin new_row = new_row ^ start_pos [ 1 ] ^ start_pos [ 2 ] + i ;
13262: LD_ADDR_VAR 0 8
13266: PUSH
13267: LD_VAR 0 8
13271: PUSH
13272: LD_VAR 0 6
13276: PUSH
13277: LD_INT 1
13279: ARRAY
13280: ADD
13281: PUSH
13282: LD_VAR 0 6
13286: PUSH
13287: LD_INT 2
13289: ARRAY
13290: PUSH
13291: LD_VAR 0 4
13295: PLUS
13296: ADD
13297: ST_TO_ADDR
// row_size = row_size + 1 ;
13298: LD_ADDR_VAR 0 7
13302: PUSH
13303: LD_VAR 0 7
13307: PUSH
13308: LD_INT 1
13310: PLUS
13311: ST_TO_ADDR
// end ;
13312: GO 13259
13314: POP
13315: POP
// result_rows = result_rows ^ [ new_row ] ;
13316: LD_ADDR_VAR 0 9
13320: PUSH
13321: LD_VAR 0 9
13325: PUSH
13326: LD_VAR 0 8
13330: PUSH
13331: EMPTY
13332: LIST
13333: ADD
13334: ST_TO_ADDR
// civil_rows = civil_team div sold_team ;
13335: LD_ADDR_VAR 0 10
13339: PUSH
13340: LD_VAR 0 2
13344: PUSH
13345: LD_VAR 0 1
13349: DIV
13350: ST_TO_ADDR
// if ( civil_rows mod sold_team > 0 ) then
13351: LD_VAR 0 10
13355: PUSH
13356: LD_VAR 0 1
13360: MOD
13361: PUSH
13362: LD_INT 0
13364: GREATER
13365: IFFALSE 13381
// civil_rows = civil_rows + 1 ;
13367: LD_ADDR_VAR 0 10
13371: PUSH
13372: LD_VAR 0 10
13376: PUSH
13377: LD_INT 1
13379: PLUS
13380: ST_TO_ADDR
// offsetX = 2 ;
13381: LD_ADDR_VAR 0 11
13385: PUSH
13386: LD_INT 2
13388: ST_TO_ADDR
// offsetY = 1 ;
13389: LD_ADDR_VAR 0 12
13393: PUSH
13394: LD_INT 1
13396: ST_TO_ADDR
// for i := 1 to civil_rows do
13397: LD_ADDR_VAR 0 4
13401: PUSH
13402: DOUBLE
13403: LD_INT 1
13405: DEC
13406: ST_TO_ADDR
13407: LD_VAR 0 10
13411: PUSH
13412: FOR_TO
13413: IFFALSE 13541
// begin new_row = [ ] ;
13415: LD_ADDR_VAR 0 8
13419: PUSH
13420: EMPTY
13421: ST_TO_ADDR
// for x := 1 to row_size do
13422: LD_ADDR_VAR 0 5
13426: PUSH
13427: DOUBLE
13428: LD_INT 1
13430: DEC
13431: ST_TO_ADDR
13432: LD_VAR 0 7
13436: PUSH
13437: FOR_TO
13438: IFFALSE 13490
// begin new_row = new_row ^ start_pos [ 1 ] + offsetX ^ start_pos [ 2 ] + offsetY + x ;
13440: LD_ADDR_VAR 0 8
13444: PUSH
13445: LD_VAR 0 8
13449: PUSH
13450: LD_VAR 0 6
13454: PUSH
13455: LD_INT 1
13457: ARRAY
13458: PUSH
13459: LD_VAR 0 11
13463: PLUS
13464: ADD
13465: PUSH
13466: LD_VAR 0 6
13470: PUSH
13471: LD_INT 2
13473: ARRAY
13474: PUSH
13475: LD_VAR 0 12
13479: PLUS
13480: PUSH
13481: LD_VAR 0 5
13485: PLUS
13486: ADD
13487: ST_TO_ADDR
// end ;
13488: GO 13437
13490: POP
13491: POP
// result_rows = result_rows ^ [ new_row ] ;
13492: LD_ADDR_VAR 0 9
13496: PUSH
13497: LD_VAR 0 9
13501: PUSH
13502: LD_VAR 0 8
13506: PUSH
13507: EMPTY
13508: LIST
13509: ADD
13510: ST_TO_ADDR
// offsetX = offsetX + 2 ;
13511: LD_ADDR_VAR 0 11
13515: PUSH
13516: LD_VAR 0 11
13520: PUSH
13521: LD_INT 2
13523: PLUS
13524: ST_TO_ADDR
// offsetY = offsetY + 1 ;
13525: LD_ADDR_VAR 0 12
13529: PUSH
13530: LD_VAR 0 12
13534: PUSH
13535: LD_INT 1
13537: PLUS
13538: ST_TO_ADDR
// end ;
13539: GO 13412
13541: POP
13542: POP
// result = result_rows ;
13543: LD_ADDR_VAR 0 3
13547: PUSH
13548: LD_VAR 0 9
13552: ST_TO_ADDR
// end ; end_of_file
13553: LD_VAR 0 3
13557: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13558: LD_INT 0
13560: PPUSH
13561: PPUSH
// if exist_mode then
13562: LD_VAR 0 2
13566: IFFALSE 13591
// unit := CreateCharacter ( prefix & ident ) else
13568: LD_ADDR_VAR 0 5
13572: PUSH
13573: LD_VAR 0 3
13577: PUSH
13578: LD_VAR 0 1
13582: STR
13583: PPUSH
13584: CALL_OW 34
13588: ST_TO_ADDR
13589: GO 13606
// unit := NewCharacter ( ident ) ;
13591: LD_ADDR_VAR 0 5
13595: PUSH
13596: LD_VAR 0 1
13600: PPUSH
13601: CALL_OW 25
13605: ST_TO_ADDR
// result := unit ;
13606: LD_ADDR_VAR 0 4
13610: PUSH
13611: LD_VAR 0 5
13615: ST_TO_ADDR
// end ;
13616: LD_VAR 0 4
13620: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13621: LD_INT 0
13623: PPUSH
13624: PPUSH
// if not side or not nation then
13625: LD_VAR 0 1
13629: NOT
13630: PUSH
13631: LD_VAR 0 2
13635: NOT
13636: OR
13637: IFFALSE 13641
// exit ;
13639: GO 14405
// case nation of nation_american :
13641: LD_VAR 0 2
13645: PUSH
13646: LD_INT 1
13648: DOUBLE
13649: EQUAL
13650: IFTRUE 13654
13652: GO 13868
13654: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
13655: LD_ADDR_VAR 0 4
13659: PUSH
13660: LD_INT 35
13662: PUSH
13663: LD_INT 45
13665: PUSH
13666: LD_INT 46
13668: PUSH
13669: LD_INT 47
13671: PUSH
13672: LD_INT 82
13674: PUSH
13675: LD_INT 83
13677: PUSH
13678: LD_INT 84
13680: PUSH
13681: LD_INT 85
13683: PUSH
13684: LD_INT 86
13686: PUSH
13687: LD_INT 1
13689: PUSH
13690: LD_INT 2
13692: PUSH
13693: LD_INT 6
13695: PUSH
13696: LD_INT 15
13698: PUSH
13699: LD_INT 16
13701: PUSH
13702: LD_INT 7
13704: PUSH
13705: LD_INT 12
13707: PUSH
13708: LD_INT 13
13710: PUSH
13711: LD_INT 10
13713: PUSH
13714: LD_INT 14
13716: PUSH
13717: LD_INT 20
13719: PUSH
13720: LD_INT 21
13722: PUSH
13723: LD_INT 22
13725: PUSH
13726: LD_INT 25
13728: PUSH
13729: LD_INT 32
13731: PUSH
13732: LD_INT 27
13734: PUSH
13735: LD_INT 36
13737: PUSH
13738: LD_INT 69
13740: PUSH
13741: LD_INT 39
13743: PUSH
13744: LD_INT 34
13746: PUSH
13747: LD_INT 40
13749: PUSH
13750: LD_INT 48
13752: PUSH
13753: LD_INT 49
13755: PUSH
13756: LD_INT 50
13758: PUSH
13759: LD_INT 51
13761: PUSH
13762: LD_INT 52
13764: PUSH
13765: LD_INT 53
13767: PUSH
13768: LD_INT 54
13770: PUSH
13771: LD_INT 55
13773: PUSH
13774: LD_INT 56
13776: PUSH
13777: LD_INT 57
13779: PUSH
13780: LD_INT 58
13782: PUSH
13783: LD_INT 59
13785: PUSH
13786: LD_INT 60
13788: PUSH
13789: LD_INT 61
13791: PUSH
13792: LD_INT 62
13794: PUSH
13795: LD_INT 80
13797: PUSH
13798: LD_INT 82
13800: PUSH
13801: LD_INT 83
13803: PUSH
13804: LD_INT 84
13806: PUSH
13807: LD_INT 85
13809: PUSH
13810: LD_INT 86
13812: PUSH
13813: EMPTY
13814: LIST
13815: LIST
13816: LIST
13817: LIST
13818: LIST
13819: LIST
13820: LIST
13821: LIST
13822: LIST
13823: LIST
13824: LIST
13825: LIST
13826: LIST
13827: LIST
13828: LIST
13829: LIST
13830: LIST
13831: LIST
13832: LIST
13833: LIST
13834: LIST
13835: LIST
13836: LIST
13837: LIST
13838: LIST
13839: LIST
13840: LIST
13841: LIST
13842: LIST
13843: LIST
13844: LIST
13845: LIST
13846: LIST
13847: LIST
13848: LIST
13849: LIST
13850: LIST
13851: LIST
13852: LIST
13853: LIST
13854: LIST
13855: LIST
13856: LIST
13857: LIST
13858: LIST
13859: LIST
13860: LIST
13861: LIST
13862: LIST
13863: LIST
13864: LIST
13865: ST_TO_ADDR
13866: GO 14329
13868: LD_INT 2
13870: DOUBLE
13871: EQUAL
13872: IFTRUE 13876
13874: GO 14098
13876: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
13877: LD_ADDR_VAR 0 4
13881: PUSH
13882: LD_INT 35
13884: PUSH
13885: LD_INT 45
13887: PUSH
13888: LD_INT 46
13890: PUSH
13891: LD_INT 47
13893: PUSH
13894: LD_INT 82
13896: PUSH
13897: LD_INT 83
13899: PUSH
13900: LD_INT 84
13902: PUSH
13903: LD_INT 85
13905: PUSH
13906: LD_INT 87
13908: PUSH
13909: LD_INT 70
13911: PUSH
13912: LD_INT 1
13914: PUSH
13915: LD_INT 11
13917: PUSH
13918: LD_INT 3
13920: PUSH
13921: LD_INT 4
13923: PUSH
13924: LD_INT 5
13926: PUSH
13927: LD_INT 6
13929: PUSH
13930: LD_INT 15
13932: PUSH
13933: LD_INT 18
13935: PUSH
13936: LD_INT 7
13938: PUSH
13939: LD_INT 17
13941: PUSH
13942: LD_INT 8
13944: PUSH
13945: LD_INT 20
13947: PUSH
13948: LD_INT 21
13950: PUSH
13951: LD_INT 22
13953: PUSH
13954: LD_INT 72
13956: PUSH
13957: LD_INT 26
13959: PUSH
13960: LD_INT 69
13962: PUSH
13963: LD_INT 39
13965: PUSH
13966: LD_INT 40
13968: PUSH
13969: LD_INT 41
13971: PUSH
13972: LD_INT 42
13974: PUSH
13975: LD_INT 43
13977: PUSH
13978: LD_INT 48
13980: PUSH
13981: LD_INT 49
13983: PUSH
13984: LD_INT 50
13986: PUSH
13987: LD_INT 51
13989: PUSH
13990: LD_INT 52
13992: PUSH
13993: LD_INT 53
13995: PUSH
13996: LD_INT 54
13998: PUSH
13999: LD_INT 55
14001: PUSH
14002: LD_INT 56
14004: PUSH
14005: LD_INT 60
14007: PUSH
14008: LD_INT 61
14010: PUSH
14011: LD_INT 62
14013: PUSH
14014: LD_INT 66
14016: PUSH
14017: LD_INT 67
14019: PUSH
14020: LD_INT 68
14022: PUSH
14023: LD_INT 81
14025: PUSH
14026: LD_INT 82
14028: PUSH
14029: LD_INT 83
14031: PUSH
14032: LD_INT 84
14034: PUSH
14035: LD_INT 85
14037: PUSH
14038: LD_INT 87
14040: PUSH
14041: EMPTY
14042: LIST
14043: LIST
14044: LIST
14045: LIST
14046: LIST
14047: LIST
14048: LIST
14049: LIST
14050: LIST
14051: LIST
14052: LIST
14053: LIST
14054: LIST
14055: LIST
14056: LIST
14057: LIST
14058: LIST
14059: LIST
14060: LIST
14061: LIST
14062: LIST
14063: LIST
14064: LIST
14065: LIST
14066: LIST
14067: LIST
14068: LIST
14069: LIST
14070: LIST
14071: LIST
14072: LIST
14073: LIST
14074: LIST
14075: LIST
14076: LIST
14077: LIST
14078: LIST
14079: LIST
14080: LIST
14081: LIST
14082: LIST
14083: LIST
14084: LIST
14085: LIST
14086: LIST
14087: LIST
14088: LIST
14089: LIST
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: LIST
14095: ST_TO_ADDR
14096: GO 14329
14098: LD_INT 3
14100: DOUBLE
14101: EQUAL
14102: IFTRUE 14106
14104: GO 14328
14106: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14107: LD_ADDR_VAR 0 4
14111: PUSH
14112: LD_INT 46
14114: PUSH
14115: LD_INT 47
14117: PUSH
14118: LD_INT 1
14120: PUSH
14121: LD_INT 2
14123: PUSH
14124: LD_INT 82
14126: PUSH
14127: LD_INT 83
14129: PUSH
14130: LD_INT 84
14132: PUSH
14133: LD_INT 85
14135: PUSH
14136: LD_INT 86
14138: PUSH
14139: LD_INT 11
14141: PUSH
14142: LD_INT 9
14144: PUSH
14145: LD_INT 20
14147: PUSH
14148: LD_INT 19
14150: PUSH
14151: LD_INT 21
14153: PUSH
14154: LD_INT 24
14156: PUSH
14157: LD_INT 22
14159: PUSH
14160: LD_INT 25
14162: PUSH
14163: LD_INT 28
14165: PUSH
14166: LD_INT 29
14168: PUSH
14169: LD_INT 30
14171: PUSH
14172: LD_INT 31
14174: PUSH
14175: LD_INT 37
14177: PUSH
14178: LD_INT 38
14180: PUSH
14181: LD_INT 32
14183: PUSH
14184: LD_INT 27
14186: PUSH
14187: LD_INT 33
14189: PUSH
14190: LD_INT 69
14192: PUSH
14193: LD_INT 39
14195: PUSH
14196: LD_INT 34
14198: PUSH
14199: LD_INT 40
14201: PUSH
14202: LD_INT 71
14204: PUSH
14205: LD_INT 23
14207: PUSH
14208: LD_INT 44
14210: PUSH
14211: LD_INT 48
14213: PUSH
14214: LD_INT 49
14216: PUSH
14217: LD_INT 50
14219: PUSH
14220: LD_INT 51
14222: PUSH
14223: LD_INT 52
14225: PUSH
14226: LD_INT 53
14228: PUSH
14229: LD_INT 54
14231: PUSH
14232: LD_INT 55
14234: PUSH
14235: LD_INT 56
14237: PUSH
14238: LD_INT 57
14240: PUSH
14241: LD_INT 58
14243: PUSH
14244: LD_INT 59
14246: PUSH
14247: LD_INT 63
14249: PUSH
14250: LD_INT 64
14252: PUSH
14253: LD_INT 65
14255: PUSH
14256: LD_INT 82
14258: PUSH
14259: LD_INT 83
14261: PUSH
14262: LD_INT 84
14264: PUSH
14265: LD_INT 85
14267: PUSH
14268: LD_INT 86
14270: PUSH
14271: EMPTY
14272: LIST
14273: LIST
14274: LIST
14275: LIST
14276: LIST
14277: LIST
14278: LIST
14279: LIST
14280: LIST
14281: LIST
14282: LIST
14283: LIST
14284: LIST
14285: LIST
14286: LIST
14287: LIST
14288: LIST
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: LIST
14298: LIST
14299: LIST
14300: LIST
14301: LIST
14302: LIST
14303: LIST
14304: LIST
14305: LIST
14306: LIST
14307: LIST
14308: LIST
14309: LIST
14310: LIST
14311: LIST
14312: LIST
14313: LIST
14314: LIST
14315: LIST
14316: LIST
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: ST_TO_ADDR
14326: GO 14329
14328: POP
// if state > - 1 and state < 3 then
14329: LD_VAR 0 3
14333: PUSH
14334: LD_INT 1
14336: NEG
14337: GREATER
14338: PUSH
14339: LD_VAR 0 3
14343: PUSH
14344: LD_INT 3
14346: LESS
14347: AND
14348: IFFALSE 14405
// for i in result do
14350: LD_ADDR_VAR 0 5
14354: PUSH
14355: LD_VAR 0 4
14359: PUSH
14360: FOR_IN
14361: IFFALSE 14403
// if GetTech ( i , side ) <> state then
14363: LD_VAR 0 5
14367: PPUSH
14368: LD_VAR 0 1
14372: PPUSH
14373: CALL_OW 321
14377: PUSH
14378: LD_VAR 0 3
14382: NONEQUAL
14383: IFFALSE 14401
// result := result diff i ;
14385: LD_ADDR_VAR 0 4
14389: PUSH
14390: LD_VAR 0 4
14394: PUSH
14395: LD_VAR 0 5
14399: DIFF
14400: ST_TO_ADDR
14401: GO 14360
14403: POP
14404: POP
// end ;
14405: LD_VAR 0 4
14409: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14410: LD_INT 0
14412: PPUSH
14413: PPUSH
14414: PPUSH
// result := true ;
14415: LD_ADDR_VAR 0 3
14419: PUSH
14420: LD_INT 1
14422: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14423: LD_ADDR_VAR 0 5
14427: PUSH
14428: LD_VAR 0 2
14432: PPUSH
14433: CALL_OW 480
14437: ST_TO_ADDR
// if not tmp then
14438: LD_VAR 0 5
14442: NOT
14443: IFFALSE 14447
// exit ;
14445: GO 14496
// for i in tmp do
14447: LD_ADDR_VAR 0 4
14451: PUSH
14452: LD_VAR 0 5
14456: PUSH
14457: FOR_IN
14458: IFFALSE 14494
// if GetTech ( i , side ) <> state_researched then
14460: LD_VAR 0 4
14464: PPUSH
14465: LD_VAR 0 1
14469: PPUSH
14470: CALL_OW 321
14474: PUSH
14475: LD_INT 2
14477: NONEQUAL
14478: IFFALSE 14492
// begin result := false ;
14480: LD_ADDR_VAR 0 3
14484: PUSH
14485: LD_INT 0
14487: ST_TO_ADDR
// exit ;
14488: POP
14489: POP
14490: GO 14496
// end ;
14492: GO 14457
14494: POP
14495: POP
// end ;
14496: LD_VAR 0 3
14500: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14501: LD_INT 0
14503: PPUSH
14504: PPUSH
14505: PPUSH
14506: PPUSH
14507: PPUSH
14508: PPUSH
14509: PPUSH
14510: PPUSH
14511: PPUSH
14512: PPUSH
14513: PPUSH
14514: PPUSH
14515: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14516: LD_VAR 0 1
14520: NOT
14521: PUSH
14522: LD_VAR 0 1
14526: PPUSH
14527: CALL_OW 257
14531: PUSH
14532: LD_INT 9
14534: NONEQUAL
14535: OR
14536: IFFALSE 14540
// exit ;
14538: GO 15113
// side := GetSide ( unit ) ;
14540: LD_ADDR_VAR 0 9
14544: PUSH
14545: LD_VAR 0 1
14549: PPUSH
14550: CALL_OW 255
14554: ST_TO_ADDR
// tech_space := tech_spacanom ;
14555: LD_ADDR_VAR 0 12
14559: PUSH
14560: LD_INT 29
14562: ST_TO_ADDR
// tech_time := tech_taurad ;
14563: LD_ADDR_VAR 0 13
14567: PUSH
14568: LD_INT 28
14570: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14571: LD_ADDR_VAR 0 11
14575: PUSH
14576: LD_VAR 0 1
14580: PPUSH
14581: CALL_OW 310
14585: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14586: LD_VAR 0 11
14590: PPUSH
14591: CALL_OW 247
14595: PUSH
14596: LD_INT 2
14598: EQUAL
14599: IFFALSE 14603
// exit ;
14601: GO 15113
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14603: LD_ADDR_VAR 0 8
14607: PUSH
14608: LD_INT 81
14610: PUSH
14611: LD_VAR 0 9
14615: PUSH
14616: EMPTY
14617: LIST
14618: LIST
14619: PUSH
14620: LD_INT 3
14622: PUSH
14623: LD_INT 21
14625: PUSH
14626: LD_INT 3
14628: PUSH
14629: EMPTY
14630: LIST
14631: LIST
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: PPUSH
14641: CALL_OW 69
14645: ST_TO_ADDR
// if not tmp then
14646: LD_VAR 0 8
14650: NOT
14651: IFFALSE 14655
// exit ;
14653: GO 15113
// if in_unit then
14655: LD_VAR 0 11
14659: IFFALSE 14683
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14661: LD_ADDR_VAR 0 10
14665: PUSH
14666: LD_VAR 0 8
14670: PPUSH
14671: LD_VAR 0 11
14675: PPUSH
14676: CALL_OW 74
14680: ST_TO_ADDR
14681: GO 14703
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14683: LD_ADDR_VAR 0 10
14687: PUSH
14688: LD_VAR 0 8
14692: PPUSH
14693: LD_VAR 0 1
14697: PPUSH
14698: CALL_OW 74
14702: ST_TO_ADDR
// if not enemy then
14703: LD_VAR 0 10
14707: NOT
14708: IFFALSE 14712
// exit ;
14710: GO 15113
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14712: LD_VAR 0 11
14716: PUSH
14717: LD_VAR 0 11
14721: PPUSH
14722: LD_VAR 0 10
14726: PPUSH
14727: CALL_OW 296
14731: PUSH
14732: LD_INT 13
14734: GREATER
14735: AND
14736: PUSH
14737: LD_VAR 0 1
14741: PPUSH
14742: LD_VAR 0 10
14746: PPUSH
14747: CALL_OW 296
14751: PUSH
14752: LD_INT 12
14754: GREATER
14755: OR
14756: IFFALSE 14760
// exit ;
14758: GO 15113
// missile := [ 1 ] ;
14760: LD_ADDR_VAR 0 14
14764: PUSH
14765: LD_INT 1
14767: PUSH
14768: EMPTY
14769: LIST
14770: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14771: LD_VAR 0 9
14775: PPUSH
14776: LD_VAR 0 12
14780: PPUSH
14781: CALL_OW 325
14785: IFFALSE 14814
// missile := Insert ( missile , missile + 1 , 2 ) ;
14787: LD_ADDR_VAR 0 14
14791: PUSH
14792: LD_VAR 0 14
14796: PPUSH
14797: LD_VAR 0 14
14801: PUSH
14802: LD_INT 1
14804: PLUS
14805: PPUSH
14806: LD_INT 2
14808: PPUSH
14809: CALL_OW 2
14813: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14814: LD_VAR 0 9
14818: PPUSH
14819: LD_VAR 0 13
14823: PPUSH
14824: CALL_OW 325
14828: PUSH
14829: LD_VAR 0 10
14833: PPUSH
14834: CALL_OW 255
14838: PPUSH
14839: LD_VAR 0 13
14843: PPUSH
14844: CALL_OW 325
14848: NOT
14849: AND
14850: IFFALSE 14879
// missile := Insert ( missile , missile + 1 , 3 ) ;
14852: LD_ADDR_VAR 0 14
14856: PUSH
14857: LD_VAR 0 14
14861: PPUSH
14862: LD_VAR 0 14
14866: PUSH
14867: LD_INT 1
14869: PLUS
14870: PPUSH
14871: LD_INT 3
14873: PPUSH
14874: CALL_OW 2
14878: ST_TO_ADDR
// if missile < 2 then
14879: LD_VAR 0 14
14883: PUSH
14884: LD_INT 2
14886: LESS
14887: IFFALSE 14891
// exit ;
14889: GO 15113
// x := GetX ( enemy ) ;
14891: LD_ADDR_VAR 0 4
14895: PUSH
14896: LD_VAR 0 10
14900: PPUSH
14901: CALL_OW 250
14905: ST_TO_ADDR
// y := GetY ( enemy ) ;
14906: LD_ADDR_VAR 0 5
14910: PUSH
14911: LD_VAR 0 10
14915: PPUSH
14916: CALL_OW 251
14920: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14921: LD_ADDR_VAR 0 6
14925: PUSH
14926: LD_VAR 0 4
14930: PUSH
14931: LD_INT 1
14933: NEG
14934: PPUSH
14935: LD_INT 1
14937: PPUSH
14938: CALL_OW 12
14942: PLUS
14943: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
14944: LD_ADDR_VAR 0 7
14948: PUSH
14949: LD_VAR 0 5
14953: PUSH
14954: LD_INT 1
14956: NEG
14957: PPUSH
14958: LD_INT 1
14960: PPUSH
14961: CALL_OW 12
14965: PLUS
14966: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
14967: LD_VAR 0 6
14971: PPUSH
14972: LD_VAR 0 7
14976: PPUSH
14977: CALL_OW 488
14981: NOT
14982: IFFALSE 15004
// begin _x := x ;
14984: LD_ADDR_VAR 0 6
14988: PUSH
14989: LD_VAR 0 4
14993: ST_TO_ADDR
// _y := y ;
14994: LD_ADDR_VAR 0 7
14998: PUSH
14999: LD_VAR 0 5
15003: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15004: LD_ADDR_VAR 0 3
15008: PUSH
15009: LD_INT 1
15011: PPUSH
15012: LD_VAR 0 14
15016: PPUSH
15017: CALL_OW 12
15021: ST_TO_ADDR
// case i of 1 :
15022: LD_VAR 0 3
15026: PUSH
15027: LD_INT 1
15029: DOUBLE
15030: EQUAL
15031: IFTRUE 15035
15033: GO 15052
15035: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15036: LD_VAR 0 1
15040: PPUSH
15041: LD_VAR 0 10
15045: PPUSH
15046: CALL_OW 115
15050: GO 15113
15052: LD_INT 2
15054: DOUBLE
15055: EQUAL
15056: IFTRUE 15060
15058: GO 15082
15060: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15061: LD_VAR 0 1
15065: PPUSH
15066: LD_VAR 0 6
15070: PPUSH
15071: LD_VAR 0 7
15075: PPUSH
15076: CALL_OW 153
15080: GO 15113
15082: LD_INT 3
15084: DOUBLE
15085: EQUAL
15086: IFTRUE 15090
15088: GO 15112
15090: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15091: LD_VAR 0 1
15095: PPUSH
15096: LD_VAR 0 6
15100: PPUSH
15101: LD_VAR 0 7
15105: PPUSH
15106: CALL_OW 154
15110: GO 15113
15112: POP
// end ;
15113: LD_VAR 0 2
15117: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15118: LD_INT 0
15120: PPUSH
15121: PPUSH
15122: PPUSH
15123: PPUSH
15124: PPUSH
15125: PPUSH
// if not unit or not building then
15126: LD_VAR 0 1
15130: NOT
15131: PUSH
15132: LD_VAR 0 2
15136: NOT
15137: OR
15138: IFFALSE 15142
// exit ;
15140: GO 15300
// x := GetX ( building ) ;
15142: LD_ADDR_VAR 0 5
15146: PUSH
15147: LD_VAR 0 2
15151: PPUSH
15152: CALL_OW 250
15156: ST_TO_ADDR
// y := GetY ( building ) ;
15157: LD_ADDR_VAR 0 6
15161: PUSH
15162: LD_VAR 0 2
15166: PPUSH
15167: CALL_OW 251
15171: ST_TO_ADDR
// for i = 0 to 5 do
15172: LD_ADDR_VAR 0 4
15176: PUSH
15177: DOUBLE
15178: LD_INT 0
15180: DEC
15181: ST_TO_ADDR
15182: LD_INT 5
15184: PUSH
15185: FOR_TO
15186: IFFALSE 15298
// begin _x := ShiftX ( x , i , 3 ) ;
15188: LD_ADDR_VAR 0 7
15192: PUSH
15193: LD_VAR 0 5
15197: PPUSH
15198: LD_VAR 0 4
15202: PPUSH
15203: LD_INT 3
15205: PPUSH
15206: CALL_OW 272
15210: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15211: LD_ADDR_VAR 0 8
15215: PUSH
15216: LD_VAR 0 6
15220: PPUSH
15221: LD_VAR 0 4
15225: PPUSH
15226: LD_INT 3
15228: PPUSH
15229: CALL_OW 273
15233: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15234: LD_VAR 0 7
15238: PPUSH
15239: LD_VAR 0 8
15243: PPUSH
15244: CALL_OW 488
15248: NOT
15249: IFFALSE 15253
// continue ;
15251: GO 15185
// if HexInfo ( _x , _y ) = 0 then
15253: LD_VAR 0 7
15257: PPUSH
15258: LD_VAR 0 8
15262: PPUSH
15263: CALL_OW 428
15267: PUSH
15268: LD_INT 0
15270: EQUAL
15271: IFFALSE 15296
// begin ComMoveXY ( unit , _x , _y ) ;
15273: LD_VAR 0 1
15277: PPUSH
15278: LD_VAR 0 7
15282: PPUSH
15283: LD_VAR 0 8
15287: PPUSH
15288: CALL_OW 111
// exit ;
15292: POP
15293: POP
15294: GO 15300
// end ; end ;
15296: GO 15185
15298: POP
15299: POP
// end ;
15300: LD_VAR 0 3
15304: RET
// export function ScanBase ( side , base_area ) ; begin
15305: LD_INT 0
15307: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15308: LD_ADDR_VAR 0 3
15312: PUSH
15313: LD_VAR 0 2
15317: PPUSH
15318: LD_INT 81
15320: PUSH
15321: LD_VAR 0 1
15325: PUSH
15326: EMPTY
15327: LIST
15328: LIST
15329: PPUSH
15330: CALL_OW 70
15334: ST_TO_ADDR
// end ;
15335: LD_VAR 0 3
15339: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15340: LD_INT 0
15342: PPUSH
15343: PPUSH
15344: PPUSH
15345: PPUSH
// result := false ;
15346: LD_ADDR_VAR 0 2
15350: PUSH
15351: LD_INT 0
15353: ST_TO_ADDR
// side := GetSide ( unit ) ;
15354: LD_ADDR_VAR 0 3
15358: PUSH
15359: LD_VAR 0 1
15363: PPUSH
15364: CALL_OW 255
15368: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15369: LD_ADDR_VAR 0 4
15373: PUSH
15374: LD_VAR 0 1
15378: PPUSH
15379: CALL_OW 248
15383: ST_TO_ADDR
// case nat of 1 :
15384: LD_VAR 0 4
15388: PUSH
15389: LD_INT 1
15391: DOUBLE
15392: EQUAL
15393: IFTRUE 15397
15395: GO 15408
15397: POP
// tech := tech_lassight ; 2 :
15398: LD_ADDR_VAR 0 5
15402: PUSH
15403: LD_INT 12
15405: ST_TO_ADDR
15406: GO 15447
15408: LD_INT 2
15410: DOUBLE
15411: EQUAL
15412: IFTRUE 15416
15414: GO 15427
15416: POP
// tech := tech_mortar ; 3 :
15417: LD_ADDR_VAR 0 5
15421: PUSH
15422: LD_INT 41
15424: ST_TO_ADDR
15425: GO 15447
15427: LD_INT 3
15429: DOUBLE
15430: EQUAL
15431: IFTRUE 15435
15433: GO 15446
15435: POP
// tech := tech_bazooka ; end ;
15436: LD_ADDR_VAR 0 5
15440: PUSH
15441: LD_INT 44
15443: ST_TO_ADDR
15444: GO 15447
15446: POP
// if Researched ( side , tech ) then
15447: LD_VAR 0 3
15451: PPUSH
15452: LD_VAR 0 5
15456: PPUSH
15457: CALL_OW 325
15461: IFFALSE 15488
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15463: LD_ADDR_VAR 0 2
15467: PUSH
15468: LD_INT 5
15470: PUSH
15471: LD_INT 8
15473: PUSH
15474: LD_INT 9
15476: PUSH
15477: EMPTY
15478: LIST
15479: LIST
15480: LIST
15481: PUSH
15482: LD_VAR 0 4
15486: ARRAY
15487: ST_TO_ADDR
// end ;
15488: LD_VAR 0 2
15492: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15493: LD_INT 0
15495: PPUSH
15496: PPUSH
15497: PPUSH
// if not mines then
15498: LD_VAR 0 2
15502: NOT
15503: IFFALSE 15507
// exit ;
15505: GO 15651
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15507: LD_ADDR_VAR 0 5
15511: PUSH
15512: LD_INT 81
15514: PUSH
15515: LD_VAR 0 1
15519: PUSH
15520: EMPTY
15521: LIST
15522: LIST
15523: PUSH
15524: LD_INT 3
15526: PUSH
15527: LD_INT 21
15529: PUSH
15530: LD_INT 3
15532: PUSH
15533: EMPTY
15534: LIST
15535: LIST
15536: PUSH
15537: EMPTY
15538: LIST
15539: LIST
15540: PUSH
15541: EMPTY
15542: LIST
15543: LIST
15544: PPUSH
15545: CALL_OW 69
15549: ST_TO_ADDR
// for i in mines do
15550: LD_ADDR_VAR 0 4
15554: PUSH
15555: LD_VAR 0 2
15559: PUSH
15560: FOR_IN
15561: IFFALSE 15649
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15563: LD_VAR 0 4
15567: PUSH
15568: LD_INT 1
15570: ARRAY
15571: PPUSH
15572: LD_VAR 0 4
15576: PUSH
15577: LD_INT 2
15579: ARRAY
15580: PPUSH
15581: CALL_OW 458
15585: NOT
15586: IFFALSE 15590
// continue ;
15588: GO 15560
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15590: LD_VAR 0 4
15594: PUSH
15595: LD_INT 1
15597: ARRAY
15598: PPUSH
15599: LD_VAR 0 4
15603: PUSH
15604: LD_INT 2
15606: ARRAY
15607: PPUSH
15608: CALL_OW 428
15612: PUSH
15613: LD_VAR 0 5
15617: IN
15618: IFFALSE 15647
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15620: LD_VAR 0 4
15624: PUSH
15625: LD_INT 1
15627: ARRAY
15628: PPUSH
15629: LD_VAR 0 4
15633: PUSH
15634: LD_INT 2
15636: ARRAY
15637: PPUSH
15638: LD_VAR 0 1
15642: PPUSH
15643: CALL_OW 456
// end ;
15647: GO 15560
15649: POP
15650: POP
// end ;
15651: LD_VAR 0 3
15655: RET
// export function Count ( array ) ; var i ; begin
15656: LD_INT 0
15658: PPUSH
15659: PPUSH
// result := 0 ;
15660: LD_ADDR_VAR 0 2
15664: PUSH
15665: LD_INT 0
15667: ST_TO_ADDR
// for i in array do
15668: LD_ADDR_VAR 0 3
15672: PUSH
15673: LD_VAR 0 1
15677: PUSH
15678: FOR_IN
15679: IFFALSE 15703
// if i then
15681: LD_VAR 0 3
15685: IFFALSE 15701
// result := result + 1 ;
15687: LD_ADDR_VAR 0 2
15691: PUSH
15692: LD_VAR 0 2
15696: PUSH
15697: LD_INT 1
15699: PLUS
15700: ST_TO_ADDR
15701: GO 15678
15703: POP
15704: POP
// end ;
15705: LD_VAR 0 2
15709: RET
// export function IsEmpty ( building ) ; begin
15710: LD_INT 0
15712: PPUSH
// if not building then
15713: LD_VAR 0 1
15717: NOT
15718: IFFALSE 15722
// exit ;
15720: GO 15765
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15722: LD_ADDR_VAR 0 2
15726: PUSH
15727: LD_VAR 0 1
15731: PUSH
15732: LD_INT 22
15734: PUSH
15735: LD_VAR 0 1
15739: PPUSH
15740: CALL_OW 255
15744: PUSH
15745: EMPTY
15746: LIST
15747: LIST
15748: PUSH
15749: LD_INT 58
15751: PUSH
15752: EMPTY
15753: LIST
15754: PUSH
15755: EMPTY
15756: LIST
15757: LIST
15758: PPUSH
15759: CALL_OW 69
15763: IN
15764: ST_TO_ADDR
// end ;
15765: LD_VAR 0 2
15769: RET
// export function IsNotFull ( building ) ; begin
15770: LD_INT 0
15772: PPUSH
// if not building then
15773: LD_VAR 0 1
15777: NOT
15778: IFFALSE 15782
// exit ;
15780: GO 15801
// result := UnitsInside ( building ) < 6 ;
15782: LD_ADDR_VAR 0 2
15786: PUSH
15787: LD_VAR 0 1
15791: PPUSH
15792: CALL_OW 313
15796: PUSH
15797: LD_INT 6
15799: LESS
15800: ST_TO_ADDR
// end ;
15801: LD_VAR 0 2
15805: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
15806: LD_INT 0
15808: PPUSH
15809: PPUSH
15810: PPUSH
15811: PPUSH
// tmp := [ ] ;
15812: LD_ADDR_VAR 0 3
15816: PUSH
15817: EMPTY
15818: ST_TO_ADDR
// list := [ ] ;
15819: LD_ADDR_VAR 0 5
15823: PUSH
15824: EMPTY
15825: ST_TO_ADDR
// for i = 16 to 25 do
15826: LD_ADDR_VAR 0 4
15830: PUSH
15831: DOUBLE
15832: LD_INT 16
15834: DEC
15835: ST_TO_ADDR
15836: LD_INT 25
15838: PUSH
15839: FOR_TO
15840: IFFALSE 15913
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
15842: LD_ADDR_VAR 0 3
15846: PUSH
15847: LD_VAR 0 3
15851: PUSH
15852: LD_INT 22
15854: PUSH
15855: LD_VAR 0 1
15859: PPUSH
15860: CALL_OW 255
15864: PUSH
15865: EMPTY
15866: LIST
15867: LIST
15868: PUSH
15869: LD_INT 91
15871: PUSH
15872: LD_VAR 0 1
15876: PUSH
15877: LD_INT 6
15879: PUSH
15880: EMPTY
15881: LIST
15882: LIST
15883: LIST
15884: PUSH
15885: LD_INT 30
15887: PUSH
15888: LD_VAR 0 4
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: PUSH
15897: EMPTY
15898: LIST
15899: LIST
15900: LIST
15901: PUSH
15902: EMPTY
15903: LIST
15904: PPUSH
15905: CALL_OW 69
15909: ADD
15910: ST_TO_ADDR
15911: GO 15839
15913: POP
15914: POP
// for i = 1 to tmp do
15915: LD_ADDR_VAR 0 4
15919: PUSH
15920: DOUBLE
15921: LD_INT 1
15923: DEC
15924: ST_TO_ADDR
15925: LD_VAR 0 3
15929: PUSH
15930: FOR_TO
15931: IFFALSE 16019
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
15933: LD_ADDR_VAR 0 5
15937: PUSH
15938: LD_VAR 0 5
15942: PUSH
15943: LD_VAR 0 3
15947: PUSH
15948: LD_VAR 0 4
15952: ARRAY
15953: PPUSH
15954: CALL_OW 266
15958: PUSH
15959: LD_VAR 0 3
15963: PUSH
15964: LD_VAR 0 4
15968: ARRAY
15969: PPUSH
15970: CALL_OW 250
15974: PUSH
15975: LD_VAR 0 3
15979: PUSH
15980: LD_VAR 0 4
15984: ARRAY
15985: PPUSH
15986: CALL_OW 251
15990: PUSH
15991: LD_VAR 0 3
15995: PUSH
15996: LD_VAR 0 4
16000: ARRAY
16001: PPUSH
16002: CALL_OW 254
16006: PUSH
16007: EMPTY
16008: LIST
16009: LIST
16010: LIST
16011: LIST
16012: PUSH
16013: EMPTY
16014: LIST
16015: ADD
16016: ST_TO_ADDR
16017: GO 15930
16019: POP
16020: POP
// result := list ;
16021: LD_ADDR_VAR 0 2
16025: PUSH
16026: LD_VAR 0 5
16030: ST_TO_ADDR
// end ;
16031: LD_VAR 0 2
16035: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16036: LD_INT 0
16038: PPUSH
16039: PPUSH
16040: PPUSH
16041: PPUSH
16042: PPUSH
16043: PPUSH
16044: PPUSH
// if not factory then
16045: LD_VAR 0 1
16049: NOT
16050: IFFALSE 16054
// exit ;
16052: GO 16647
// if control = control_apeman then
16054: LD_VAR 0 4
16058: PUSH
16059: LD_INT 5
16061: EQUAL
16062: IFFALSE 16171
// begin tmp := UnitsInside ( factory ) ;
16064: LD_ADDR_VAR 0 8
16068: PUSH
16069: LD_VAR 0 1
16073: PPUSH
16074: CALL_OW 313
16078: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16079: LD_VAR 0 8
16083: PPUSH
16084: LD_INT 25
16086: PUSH
16087: LD_INT 12
16089: PUSH
16090: EMPTY
16091: LIST
16092: LIST
16093: PPUSH
16094: CALL_OW 72
16098: NOT
16099: IFFALSE 16109
// control := control_manual ;
16101: LD_ADDR_VAR 0 4
16105: PUSH
16106: LD_INT 1
16108: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16109: LD_ADDR_VAR 0 8
16113: PUSH
16114: LD_VAR 0 1
16118: PPUSH
16119: CALL 15806 0 1
16123: ST_TO_ADDR
// if tmp then
16124: LD_VAR 0 8
16128: IFFALSE 16171
// begin for i in tmp do
16130: LD_ADDR_VAR 0 7
16134: PUSH
16135: LD_VAR 0 8
16139: PUSH
16140: FOR_IN
16141: IFFALSE 16169
// if i [ 1 ] = b_ext_radio then
16143: LD_VAR 0 7
16147: PUSH
16148: LD_INT 1
16150: ARRAY
16151: PUSH
16152: LD_INT 22
16154: EQUAL
16155: IFFALSE 16167
// begin control := control_remote ;
16157: LD_ADDR_VAR 0 4
16161: PUSH
16162: LD_INT 2
16164: ST_TO_ADDR
// break ;
16165: GO 16169
// end ;
16167: GO 16140
16169: POP
16170: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16171: LD_VAR 0 1
16175: PPUSH
16176: LD_VAR 0 2
16180: PPUSH
16181: LD_VAR 0 3
16185: PPUSH
16186: LD_VAR 0 4
16190: PPUSH
16191: LD_VAR 0 5
16195: PPUSH
16196: CALL_OW 448
16200: IFFALSE 16235
// begin result := [ chassis , engine , control , weapon ] ;
16202: LD_ADDR_VAR 0 6
16206: PUSH
16207: LD_VAR 0 2
16211: PUSH
16212: LD_VAR 0 3
16216: PUSH
16217: LD_VAR 0 4
16221: PUSH
16222: LD_VAR 0 5
16226: PUSH
16227: EMPTY
16228: LIST
16229: LIST
16230: LIST
16231: LIST
16232: ST_TO_ADDR
// exit ;
16233: GO 16647
// end ; _chassis := AvailableChassisList ( factory ) ;
16235: LD_ADDR_VAR 0 9
16239: PUSH
16240: LD_VAR 0 1
16244: PPUSH
16245: CALL_OW 475
16249: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16250: LD_ADDR_VAR 0 11
16254: PUSH
16255: LD_VAR 0 1
16259: PPUSH
16260: CALL_OW 476
16264: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16265: LD_ADDR_VAR 0 12
16269: PUSH
16270: LD_VAR 0 1
16274: PPUSH
16275: CALL_OW 477
16279: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
16280: LD_ADDR_VAR 0 10
16284: PUSH
16285: LD_VAR 0 1
16289: PPUSH
16290: CALL_OW 478
16294: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
16295: LD_VAR 0 9
16299: NOT
16300: PUSH
16301: LD_VAR 0 11
16305: NOT
16306: OR
16307: PUSH
16308: LD_VAR 0 12
16312: NOT
16313: OR
16314: PUSH
16315: LD_VAR 0 10
16319: NOT
16320: OR
16321: IFFALSE 16356
// begin result := [ chassis , engine , control , weapon ] ;
16323: LD_ADDR_VAR 0 6
16327: PUSH
16328: LD_VAR 0 2
16332: PUSH
16333: LD_VAR 0 3
16337: PUSH
16338: LD_VAR 0 4
16342: PUSH
16343: LD_VAR 0 5
16347: PUSH
16348: EMPTY
16349: LIST
16350: LIST
16351: LIST
16352: LIST
16353: ST_TO_ADDR
// exit ;
16354: GO 16647
// end ; if not chassis in _chassis then
16356: LD_VAR 0 2
16360: PUSH
16361: LD_VAR 0 9
16365: IN
16366: NOT
16367: IFFALSE 16393
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16369: LD_ADDR_VAR 0 2
16373: PUSH
16374: LD_VAR 0 9
16378: PUSH
16379: LD_INT 1
16381: PPUSH
16382: LD_VAR 0 9
16386: PPUSH
16387: CALL_OW 12
16391: ARRAY
16392: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16393: LD_VAR 0 2
16397: PPUSH
16398: LD_VAR 0 3
16402: PPUSH
16403: CALL 16652 0 2
16407: NOT
16408: IFFALSE 16467
// repeat engine := _engine [ 1 ] ;
16410: LD_ADDR_VAR 0 3
16414: PUSH
16415: LD_VAR 0 11
16419: PUSH
16420: LD_INT 1
16422: ARRAY
16423: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16424: LD_ADDR_VAR 0 11
16428: PUSH
16429: LD_VAR 0 11
16433: PPUSH
16434: LD_INT 1
16436: PPUSH
16437: CALL_OW 3
16441: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16442: LD_VAR 0 2
16446: PPUSH
16447: LD_VAR 0 3
16451: PPUSH
16452: CALL 16652 0 2
16456: PUSH
16457: LD_VAR 0 11
16461: PUSH
16462: EMPTY
16463: EQUAL
16464: OR
16465: IFFALSE 16410
// if not control in _control then
16467: LD_VAR 0 4
16471: PUSH
16472: LD_VAR 0 12
16476: IN
16477: NOT
16478: IFFALSE 16504
// control := _control [ rand ( 1 , _control ) ] ;
16480: LD_ADDR_VAR 0 4
16484: PUSH
16485: LD_VAR 0 12
16489: PUSH
16490: LD_INT 1
16492: PPUSH
16493: LD_VAR 0 12
16497: PPUSH
16498: CALL_OW 12
16502: ARRAY
16503: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16504: LD_VAR 0 2
16508: PPUSH
16509: LD_VAR 0 5
16513: PPUSH
16514: CALL 16872 0 2
16518: NOT
16519: IFFALSE 16578
// repeat weapon := _weapon [ 1 ] ;
16521: LD_ADDR_VAR 0 5
16525: PUSH
16526: LD_VAR 0 10
16530: PUSH
16531: LD_INT 1
16533: ARRAY
16534: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16535: LD_ADDR_VAR 0 10
16539: PUSH
16540: LD_VAR 0 10
16544: PPUSH
16545: LD_INT 1
16547: PPUSH
16548: CALL_OW 3
16552: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16553: LD_VAR 0 2
16557: PPUSH
16558: LD_VAR 0 5
16562: PPUSH
16563: CALL 16872 0 2
16567: PUSH
16568: LD_VAR 0 10
16572: PUSH
16573: EMPTY
16574: EQUAL
16575: OR
16576: IFFALSE 16521
// result := [ ] ;
16578: LD_ADDR_VAR 0 6
16582: PUSH
16583: EMPTY
16584: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16585: LD_VAR 0 1
16589: PPUSH
16590: LD_VAR 0 2
16594: PPUSH
16595: LD_VAR 0 3
16599: PPUSH
16600: LD_VAR 0 4
16604: PPUSH
16605: LD_VAR 0 5
16609: PPUSH
16610: CALL_OW 448
16614: IFFALSE 16647
// result := [ chassis , engine , control , weapon ] ;
16616: LD_ADDR_VAR 0 6
16620: PUSH
16621: LD_VAR 0 2
16625: PUSH
16626: LD_VAR 0 3
16630: PUSH
16631: LD_VAR 0 4
16635: PUSH
16636: LD_VAR 0 5
16640: PUSH
16641: EMPTY
16642: LIST
16643: LIST
16644: LIST
16645: LIST
16646: ST_TO_ADDR
// end ;
16647: LD_VAR 0 6
16651: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16652: LD_INT 0
16654: PPUSH
// if not chassis or not engine then
16655: LD_VAR 0 1
16659: NOT
16660: PUSH
16661: LD_VAR 0 2
16665: NOT
16666: OR
16667: IFFALSE 16671
// exit ;
16669: GO 16867
// case engine of engine_solar :
16671: LD_VAR 0 2
16675: PUSH
16676: LD_INT 2
16678: DOUBLE
16679: EQUAL
16680: IFTRUE 16684
16682: GO 16722
16684: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16685: LD_ADDR_VAR 0 3
16689: PUSH
16690: LD_INT 11
16692: PUSH
16693: LD_INT 12
16695: PUSH
16696: LD_INT 13
16698: PUSH
16699: LD_INT 14
16701: PUSH
16702: LD_INT 1
16704: PUSH
16705: LD_INT 2
16707: PUSH
16708: LD_INT 3
16710: PUSH
16711: EMPTY
16712: LIST
16713: LIST
16714: LIST
16715: LIST
16716: LIST
16717: LIST
16718: LIST
16719: ST_TO_ADDR
16720: GO 16851
16722: LD_INT 1
16724: DOUBLE
16725: EQUAL
16726: IFTRUE 16730
16728: GO 16792
16730: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16731: LD_ADDR_VAR 0 3
16735: PUSH
16736: LD_INT 11
16738: PUSH
16739: LD_INT 12
16741: PUSH
16742: LD_INT 13
16744: PUSH
16745: LD_INT 14
16747: PUSH
16748: LD_INT 1
16750: PUSH
16751: LD_INT 2
16753: PUSH
16754: LD_INT 3
16756: PUSH
16757: LD_INT 4
16759: PUSH
16760: LD_INT 5
16762: PUSH
16763: LD_INT 21
16765: PUSH
16766: LD_INT 23
16768: PUSH
16769: LD_INT 22
16771: PUSH
16772: LD_INT 24
16774: PUSH
16775: EMPTY
16776: LIST
16777: LIST
16778: LIST
16779: LIST
16780: LIST
16781: LIST
16782: LIST
16783: LIST
16784: LIST
16785: LIST
16786: LIST
16787: LIST
16788: LIST
16789: ST_TO_ADDR
16790: GO 16851
16792: LD_INT 3
16794: DOUBLE
16795: EQUAL
16796: IFTRUE 16800
16798: GO 16850
16800: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
16801: LD_ADDR_VAR 0 3
16805: PUSH
16806: LD_INT 13
16808: PUSH
16809: LD_INT 14
16811: PUSH
16812: LD_INT 2
16814: PUSH
16815: LD_INT 3
16817: PUSH
16818: LD_INT 4
16820: PUSH
16821: LD_INT 5
16823: PUSH
16824: LD_INT 21
16826: PUSH
16827: LD_INT 22
16829: PUSH
16830: LD_INT 23
16832: PUSH
16833: LD_INT 24
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: LIST
16840: LIST
16841: LIST
16842: LIST
16843: LIST
16844: LIST
16845: LIST
16846: LIST
16847: ST_TO_ADDR
16848: GO 16851
16850: POP
// result := ( chassis in result ) ;
16851: LD_ADDR_VAR 0 3
16855: PUSH
16856: LD_VAR 0 1
16860: PUSH
16861: LD_VAR 0 3
16865: IN
16866: ST_TO_ADDR
// end ;
16867: LD_VAR 0 3
16871: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
16872: LD_INT 0
16874: PPUSH
// if not chassis or not weapon then
16875: LD_VAR 0 1
16879: NOT
16880: PUSH
16881: LD_VAR 0 2
16885: NOT
16886: OR
16887: IFFALSE 16891
// exit ;
16889: GO 17917
// case weapon of us_machine_gun :
16891: LD_VAR 0 2
16895: PUSH
16896: LD_INT 2
16898: DOUBLE
16899: EQUAL
16900: IFTRUE 16904
16902: GO 16934
16904: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
16905: LD_ADDR_VAR 0 3
16909: PUSH
16910: LD_INT 1
16912: PUSH
16913: LD_INT 2
16915: PUSH
16916: LD_INT 3
16918: PUSH
16919: LD_INT 4
16921: PUSH
16922: LD_INT 5
16924: PUSH
16925: EMPTY
16926: LIST
16927: LIST
16928: LIST
16929: LIST
16930: LIST
16931: ST_TO_ADDR
16932: GO 17901
16934: LD_INT 3
16936: DOUBLE
16937: EQUAL
16938: IFTRUE 16942
16940: GO 16972
16942: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
16943: LD_ADDR_VAR 0 3
16947: PUSH
16948: LD_INT 1
16950: PUSH
16951: LD_INT 2
16953: PUSH
16954: LD_INT 3
16956: PUSH
16957: LD_INT 4
16959: PUSH
16960: LD_INT 5
16962: PUSH
16963: EMPTY
16964: LIST
16965: LIST
16966: LIST
16967: LIST
16968: LIST
16969: ST_TO_ADDR
16970: GO 17901
16972: LD_INT 11
16974: DOUBLE
16975: EQUAL
16976: IFTRUE 16980
16978: GO 17010
16980: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
16981: LD_ADDR_VAR 0 3
16985: PUSH
16986: LD_INT 1
16988: PUSH
16989: LD_INT 2
16991: PUSH
16992: LD_INT 3
16994: PUSH
16995: LD_INT 4
16997: PUSH
16998: LD_INT 5
17000: PUSH
17001: EMPTY
17002: LIST
17003: LIST
17004: LIST
17005: LIST
17006: LIST
17007: ST_TO_ADDR
17008: GO 17901
17010: LD_INT 4
17012: DOUBLE
17013: EQUAL
17014: IFTRUE 17018
17016: GO 17044
17018: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17019: LD_ADDR_VAR 0 3
17023: PUSH
17024: LD_INT 2
17026: PUSH
17027: LD_INT 3
17029: PUSH
17030: LD_INT 4
17032: PUSH
17033: LD_INT 5
17035: PUSH
17036: EMPTY
17037: LIST
17038: LIST
17039: LIST
17040: LIST
17041: ST_TO_ADDR
17042: GO 17901
17044: LD_INT 5
17046: DOUBLE
17047: EQUAL
17048: IFTRUE 17052
17050: GO 17078
17052: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17053: LD_ADDR_VAR 0 3
17057: PUSH
17058: LD_INT 2
17060: PUSH
17061: LD_INT 3
17063: PUSH
17064: LD_INT 4
17066: PUSH
17067: LD_INT 5
17069: PUSH
17070: EMPTY
17071: LIST
17072: LIST
17073: LIST
17074: LIST
17075: ST_TO_ADDR
17076: GO 17901
17078: LD_INT 9
17080: DOUBLE
17081: EQUAL
17082: IFTRUE 17086
17084: GO 17112
17086: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17087: LD_ADDR_VAR 0 3
17091: PUSH
17092: LD_INT 2
17094: PUSH
17095: LD_INT 3
17097: PUSH
17098: LD_INT 4
17100: PUSH
17101: LD_INT 5
17103: PUSH
17104: EMPTY
17105: LIST
17106: LIST
17107: LIST
17108: LIST
17109: ST_TO_ADDR
17110: GO 17901
17112: LD_INT 7
17114: DOUBLE
17115: EQUAL
17116: IFTRUE 17120
17118: GO 17146
17120: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17121: LD_ADDR_VAR 0 3
17125: PUSH
17126: LD_INT 2
17128: PUSH
17129: LD_INT 3
17131: PUSH
17132: LD_INT 4
17134: PUSH
17135: LD_INT 5
17137: PUSH
17138: EMPTY
17139: LIST
17140: LIST
17141: LIST
17142: LIST
17143: ST_TO_ADDR
17144: GO 17901
17146: LD_INT 12
17148: DOUBLE
17149: EQUAL
17150: IFTRUE 17154
17152: GO 17180
17154: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17155: LD_ADDR_VAR 0 3
17159: PUSH
17160: LD_INT 2
17162: PUSH
17163: LD_INT 3
17165: PUSH
17166: LD_INT 4
17168: PUSH
17169: LD_INT 5
17171: PUSH
17172: EMPTY
17173: LIST
17174: LIST
17175: LIST
17176: LIST
17177: ST_TO_ADDR
17178: GO 17901
17180: LD_INT 13
17182: DOUBLE
17183: EQUAL
17184: IFTRUE 17188
17186: GO 17214
17188: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17189: LD_ADDR_VAR 0 3
17193: PUSH
17194: LD_INT 2
17196: PUSH
17197: LD_INT 3
17199: PUSH
17200: LD_INT 4
17202: PUSH
17203: LD_INT 5
17205: PUSH
17206: EMPTY
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: ST_TO_ADDR
17212: GO 17901
17214: LD_INT 14
17216: DOUBLE
17217: EQUAL
17218: IFTRUE 17222
17220: GO 17240
17222: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17223: LD_ADDR_VAR 0 3
17227: PUSH
17228: LD_INT 4
17230: PUSH
17231: LD_INT 5
17233: PUSH
17234: EMPTY
17235: LIST
17236: LIST
17237: ST_TO_ADDR
17238: GO 17901
17240: LD_INT 6
17242: DOUBLE
17243: EQUAL
17244: IFTRUE 17248
17246: GO 17266
17248: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17249: LD_ADDR_VAR 0 3
17253: PUSH
17254: LD_INT 4
17256: PUSH
17257: LD_INT 5
17259: PUSH
17260: EMPTY
17261: LIST
17262: LIST
17263: ST_TO_ADDR
17264: GO 17901
17266: LD_INT 10
17268: DOUBLE
17269: EQUAL
17270: IFTRUE 17274
17272: GO 17292
17274: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
17275: LD_ADDR_VAR 0 3
17279: PUSH
17280: LD_INT 4
17282: PUSH
17283: LD_INT 5
17285: PUSH
17286: EMPTY
17287: LIST
17288: LIST
17289: ST_TO_ADDR
17290: GO 17901
17292: LD_INT 22
17294: DOUBLE
17295: EQUAL
17296: IFTRUE 17300
17298: GO 17326
17300: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
17301: LD_ADDR_VAR 0 3
17305: PUSH
17306: LD_INT 11
17308: PUSH
17309: LD_INT 12
17311: PUSH
17312: LD_INT 13
17314: PUSH
17315: LD_INT 14
17317: PUSH
17318: EMPTY
17319: LIST
17320: LIST
17321: LIST
17322: LIST
17323: ST_TO_ADDR
17324: GO 17901
17326: LD_INT 23
17328: DOUBLE
17329: EQUAL
17330: IFTRUE 17334
17332: GO 17360
17334: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
17335: LD_ADDR_VAR 0 3
17339: PUSH
17340: LD_INT 11
17342: PUSH
17343: LD_INT 12
17345: PUSH
17346: LD_INT 13
17348: PUSH
17349: LD_INT 14
17351: PUSH
17352: EMPTY
17353: LIST
17354: LIST
17355: LIST
17356: LIST
17357: ST_TO_ADDR
17358: GO 17901
17360: LD_INT 24
17362: DOUBLE
17363: EQUAL
17364: IFTRUE 17368
17366: GO 17394
17368: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17369: LD_ADDR_VAR 0 3
17373: PUSH
17374: LD_INT 11
17376: PUSH
17377: LD_INT 12
17379: PUSH
17380: LD_INT 13
17382: PUSH
17383: LD_INT 14
17385: PUSH
17386: EMPTY
17387: LIST
17388: LIST
17389: LIST
17390: LIST
17391: ST_TO_ADDR
17392: GO 17901
17394: LD_INT 30
17396: DOUBLE
17397: EQUAL
17398: IFTRUE 17402
17400: GO 17428
17402: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17403: LD_ADDR_VAR 0 3
17407: PUSH
17408: LD_INT 11
17410: PUSH
17411: LD_INT 12
17413: PUSH
17414: LD_INT 13
17416: PUSH
17417: LD_INT 14
17419: PUSH
17420: EMPTY
17421: LIST
17422: LIST
17423: LIST
17424: LIST
17425: ST_TO_ADDR
17426: GO 17901
17428: LD_INT 25
17430: DOUBLE
17431: EQUAL
17432: IFTRUE 17436
17434: GO 17454
17436: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17437: LD_ADDR_VAR 0 3
17441: PUSH
17442: LD_INT 13
17444: PUSH
17445: LD_INT 14
17447: PUSH
17448: EMPTY
17449: LIST
17450: LIST
17451: ST_TO_ADDR
17452: GO 17901
17454: LD_INT 27
17456: DOUBLE
17457: EQUAL
17458: IFTRUE 17462
17460: GO 17480
17462: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17463: LD_ADDR_VAR 0 3
17467: PUSH
17468: LD_INT 13
17470: PUSH
17471: LD_INT 14
17473: PUSH
17474: EMPTY
17475: LIST
17476: LIST
17477: ST_TO_ADDR
17478: GO 17901
17480: LD_INT 28
17482: DOUBLE
17483: EQUAL
17484: IFTRUE 17488
17486: GO 17506
17488: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17489: LD_ADDR_VAR 0 3
17493: PUSH
17494: LD_INT 13
17496: PUSH
17497: LD_INT 14
17499: PUSH
17500: EMPTY
17501: LIST
17502: LIST
17503: ST_TO_ADDR
17504: GO 17901
17506: LD_INT 29
17508: DOUBLE
17509: EQUAL
17510: IFTRUE 17514
17512: GO 17532
17514: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17515: LD_ADDR_VAR 0 3
17519: PUSH
17520: LD_INT 13
17522: PUSH
17523: LD_INT 14
17525: PUSH
17526: EMPTY
17527: LIST
17528: LIST
17529: ST_TO_ADDR
17530: GO 17901
17532: LD_INT 31
17534: DOUBLE
17535: EQUAL
17536: IFTRUE 17540
17538: GO 17558
17540: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17541: LD_ADDR_VAR 0 3
17545: PUSH
17546: LD_INT 13
17548: PUSH
17549: LD_INT 14
17551: PUSH
17552: EMPTY
17553: LIST
17554: LIST
17555: ST_TO_ADDR
17556: GO 17901
17558: LD_INT 26
17560: DOUBLE
17561: EQUAL
17562: IFTRUE 17566
17564: GO 17584
17566: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17567: LD_ADDR_VAR 0 3
17571: PUSH
17572: LD_INT 13
17574: PUSH
17575: LD_INT 14
17577: PUSH
17578: EMPTY
17579: LIST
17580: LIST
17581: ST_TO_ADDR
17582: GO 17901
17584: LD_INT 42
17586: DOUBLE
17587: EQUAL
17588: IFTRUE 17592
17590: GO 17618
17592: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17593: LD_ADDR_VAR 0 3
17597: PUSH
17598: LD_INT 21
17600: PUSH
17601: LD_INT 22
17603: PUSH
17604: LD_INT 23
17606: PUSH
17607: LD_INT 24
17609: PUSH
17610: EMPTY
17611: LIST
17612: LIST
17613: LIST
17614: LIST
17615: ST_TO_ADDR
17616: GO 17901
17618: LD_INT 43
17620: DOUBLE
17621: EQUAL
17622: IFTRUE 17626
17624: GO 17652
17626: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17627: LD_ADDR_VAR 0 3
17631: PUSH
17632: LD_INT 21
17634: PUSH
17635: LD_INT 22
17637: PUSH
17638: LD_INT 23
17640: PUSH
17641: LD_INT 24
17643: PUSH
17644: EMPTY
17645: LIST
17646: LIST
17647: LIST
17648: LIST
17649: ST_TO_ADDR
17650: GO 17901
17652: LD_INT 44
17654: DOUBLE
17655: EQUAL
17656: IFTRUE 17660
17658: GO 17686
17660: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17661: LD_ADDR_VAR 0 3
17665: PUSH
17666: LD_INT 21
17668: PUSH
17669: LD_INT 22
17671: PUSH
17672: LD_INT 23
17674: PUSH
17675: LD_INT 24
17677: PUSH
17678: EMPTY
17679: LIST
17680: LIST
17681: LIST
17682: LIST
17683: ST_TO_ADDR
17684: GO 17901
17686: LD_INT 45
17688: DOUBLE
17689: EQUAL
17690: IFTRUE 17694
17692: GO 17720
17694: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17695: LD_ADDR_VAR 0 3
17699: PUSH
17700: LD_INT 21
17702: PUSH
17703: LD_INT 22
17705: PUSH
17706: LD_INT 23
17708: PUSH
17709: LD_INT 24
17711: PUSH
17712: EMPTY
17713: LIST
17714: LIST
17715: LIST
17716: LIST
17717: ST_TO_ADDR
17718: GO 17901
17720: LD_INT 49
17722: DOUBLE
17723: EQUAL
17724: IFTRUE 17728
17726: GO 17754
17728: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17729: LD_ADDR_VAR 0 3
17733: PUSH
17734: LD_INT 21
17736: PUSH
17737: LD_INT 22
17739: PUSH
17740: LD_INT 23
17742: PUSH
17743: LD_INT 24
17745: PUSH
17746: EMPTY
17747: LIST
17748: LIST
17749: LIST
17750: LIST
17751: ST_TO_ADDR
17752: GO 17901
17754: LD_INT 51
17756: DOUBLE
17757: EQUAL
17758: IFTRUE 17762
17760: GO 17788
17762: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
17763: LD_ADDR_VAR 0 3
17767: PUSH
17768: LD_INT 21
17770: PUSH
17771: LD_INT 22
17773: PUSH
17774: LD_INT 23
17776: PUSH
17777: LD_INT 24
17779: PUSH
17780: EMPTY
17781: LIST
17782: LIST
17783: LIST
17784: LIST
17785: ST_TO_ADDR
17786: GO 17901
17788: LD_INT 52
17790: DOUBLE
17791: EQUAL
17792: IFTRUE 17796
17794: GO 17822
17796: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
17797: LD_ADDR_VAR 0 3
17801: PUSH
17802: LD_INT 21
17804: PUSH
17805: LD_INT 22
17807: PUSH
17808: LD_INT 23
17810: PUSH
17811: LD_INT 24
17813: PUSH
17814: EMPTY
17815: LIST
17816: LIST
17817: LIST
17818: LIST
17819: ST_TO_ADDR
17820: GO 17901
17822: LD_INT 53
17824: DOUBLE
17825: EQUAL
17826: IFTRUE 17830
17828: GO 17848
17830: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
17831: LD_ADDR_VAR 0 3
17835: PUSH
17836: LD_INT 23
17838: PUSH
17839: LD_INT 24
17841: PUSH
17842: EMPTY
17843: LIST
17844: LIST
17845: ST_TO_ADDR
17846: GO 17901
17848: LD_INT 46
17850: DOUBLE
17851: EQUAL
17852: IFTRUE 17856
17854: GO 17874
17856: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
17857: LD_ADDR_VAR 0 3
17861: PUSH
17862: LD_INT 23
17864: PUSH
17865: LD_INT 24
17867: PUSH
17868: EMPTY
17869: LIST
17870: LIST
17871: ST_TO_ADDR
17872: GO 17901
17874: LD_INT 47
17876: DOUBLE
17877: EQUAL
17878: IFTRUE 17882
17880: GO 17900
17882: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17883: LD_ADDR_VAR 0 3
17887: PUSH
17888: LD_INT 23
17890: PUSH
17891: LD_INT 24
17893: PUSH
17894: EMPTY
17895: LIST
17896: LIST
17897: ST_TO_ADDR
17898: GO 17901
17900: POP
// result := ( chassis in result ) ;
17901: LD_ADDR_VAR 0 3
17905: PUSH
17906: LD_VAR 0 1
17910: PUSH
17911: LD_VAR 0 3
17915: IN
17916: ST_TO_ADDR
// end ;
17917: LD_VAR 0 3
17921: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
17922: LD_INT 0
17924: PPUSH
17925: PPUSH
17926: PPUSH
17927: PPUSH
17928: PPUSH
17929: PPUSH
17930: PPUSH
// result := array ;
17931: LD_ADDR_VAR 0 5
17935: PUSH
17936: LD_VAR 0 1
17940: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
17941: LD_VAR 0 1
17945: NOT
17946: PUSH
17947: LD_VAR 0 2
17951: NOT
17952: OR
17953: PUSH
17954: LD_VAR 0 3
17958: NOT
17959: OR
17960: PUSH
17961: LD_VAR 0 2
17965: PUSH
17966: LD_VAR 0 1
17970: GREATER
17971: OR
17972: PUSH
17973: LD_VAR 0 3
17977: PUSH
17978: LD_VAR 0 1
17982: GREATER
17983: OR
17984: IFFALSE 17988
// exit ;
17986: GO 18284
// if direction then
17988: LD_VAR 0 4
17992: IFFALSE 18056
// begin d := 1 ;
17994: LD_ADDR_VAR 0 9
17998: PUSH
17999: LD_INT 1
18001: ST_TO_ADDR
// if i_from > i_to then
18002: LD_VAR 0 2
18006: PUSH
18007: LD_VAR 0 3
18011: GREATER
18012: IFFALSE 18038
// length := ( array - i_from ) + i_to else
18014: LD_ADDR_VAR 0 11
18018: PUSH
18019: LD_VAR 0 1
18023: PUSH
18024: LD_VAR 0 2
18028: MINUS
18029: PUSH
18030: LD_VAR 0 3
18034: PLUS
18035: ST_TO_ADDR
18036: GO 18054
// length := i_to - i_from ;
18038: LD_ADDR_VAR 0 11
18042: PUSH
18043: LD_VAR 0 3
18047: PUSH
18048: LD_VAR 0 2
18052: MINUS
18053: ST_TO_ADDR
// end else
18054: GO 18117
// begin d := - 1 ;
18056: LD_ADDR_VAR 0 9
18060: PUSH
18061: LD_INT 1
18063: NEG
18064: ST_TO_ADDR
// if i_from > i_to then
18065: LD_VAR 0 2
18069: PUSH
18070: LD_VAR 0 3
18074: GREATER
18075: IFFALSE 18095
// length := i_from - i_to else
18077: LD_ADDR_VAR 0 11
18081: PUSH
18082: LD_VAR 0 2
18086: PUSH
18087: LD_VAR 0 3
18091: MINUS
18092: ST_TO_ADDR
18093: GO 18117
// length := ( array - i_to ) + i_from ;
18095: LD_ADDR_VAR 0 11
18099: PUSH
18100: LD_VAR 0 1
18104: PUSH
18105: LD_VAR 0 3
18109: MINUS
18110: PUSH
18111: LD_VAR 0 2
18115: PLUS
18116: ST_TO_ADDR
// end ; if not length then
18117: LD_VAR 0 11
18121: NOT
18122: IFFALSE 18126
// exit ;
18124: GO 18284
// tmp := array ;
18126: LD_ADDR_VAR 0 10
18130: PUSH
18131: LD_VAR 0 1
18135: ST_TO_ADDR
// for i = 1 to length do
18136: LD_ADDR_VAR 0 6
18140: PUSH
18141: DOUBLE
18142: LD_INT 1
18144: DEC
18145: ST_TO_ADDR
18146: LD_VAR 0 11
18150: PUSH
18151: FOR_TO
18152: IFFALSE 18272
// begin for j = 1 to array do
18154: LD_ADDR_VAR 0 7
18158: PUSH
18159: DOUBLE
18160: LD_INT 1
18162: DEC
18163: ST_TO_ADDR
18164: LD_VAR 0 1
18168: PUSH
18169: FOR_TO
18170: IFFALSE 18258
// begin k := j + d ;
18172: LD_ADDR_VAR 0 8
18176: PUSH
18177: LD_VAR 0 7
18181: PUSH
18182: LD_VAR 0 9
18186: PLUS
18187: ST_TO_ADDR
// if k > array then
18188: LD_VAR 0 8
18192: PUSH
18193: LD_VAR 0 1
18197: GREATER
18198: IFFALSE 18208
// k := 1 ;
18200: LD_ADDR_VAR 0 8
18204: PUSH
18205: LD_INT 1
18207: ST_TO_ADDR
// if not k then
18208: LD_VAR 0 8
18212: NOT
18213: IFFALSE 18225
// k := array ;
18215: LD_ADDR_VAR 0 8
18219: PUSH
18220: LD_VAR 0 1
18224: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18225: LD_ADDR_VAR 0 10
18229: PUSH
18230: LD_VAR 0 10
18234: PPUSH
18235: LD_VAR 0 8
18239: PPUSH
18240: LD_VAR 0 1
18244: PUSH
18245: LD_VAR 0 7
18249: ARRAY
18250: PPUSH
18251: CALL_OW 1
18255: ST_TO_ADDR
// end ;
18256: GO 18169
18258: POP
18259: POP
// array := tmp ;
18260: LD_ADDR_VAR 0 1
18264: PUSH
18265: LD_VAR 0 10
18269: ST_TO_ADDR
// end ;
18270: GO 18151
18272: POP
18273: POP
// result := array ;
18274: LD_ADDR_VAR 0 5
18278: PUSH
18279: LD_VAR 0 1
18283: ST_TO_ADDR
// end ;
18284: LD_VAR 0 5
18288: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
18289: LD_INT 0
18291: PPUSH
18292: PPUSH
// result := 0 ;
18293: LD_ADDR_VAR 0 3
18297: PUSH
18298: LD_INT 0
18300: ST_TO_ADDR
// if not array or not value in array then
18301: LD_VAR 0 1
18305: NOT
18306: PUSH
18307: LD_VAR 0 2
18311: PUSH
18312: LD_VAR 0 1
18316: IN
18317: NOT
18318: OR
18319: IFFALSE 18323
// exit ;
18321: GO 18377
// for i = 1 to array do
18323: LD_ADDR_VAR 0 4
18327: PUSH
18328: DOUBLE
18329: LD_INT 1
18331: DEC
18332: ST_TO_ADDR
18333: LD_VAR 0 1
18337: PUSH
18338: FOR_TO
18339: IFFALSE 18375
// if value = array [ i ] then
18341: LD_VAR 0 2
18345: PUSH
18346: LD_VAR 0 1
18350: PUSH
18351: LD_VAR 0 4
18355: ARRAY
18356: EQUAL
18357: IFFALSE 18373
// begin result := i ;
18359: LD_ADDR_VAR 0 3
18363: PUSH
18364: LD_VAR 0 4
18368: ST_TO_ADDR
// exit ;
18369: POP
18370: POP
18371: GO 18377
// end ;
18373: GO 18338
18375: POP
18376: POP
// end ;
18377: LD_VAR 0 3
18381: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18382: LD_INT 0
18384: PPUSH
// vc_chassis := chassis ;
18385: LD_ADDR_OWVAR 37
18389: PUSH
18390: LD_VAR 0 1
18394: ST_TO_ADDR
// vc_engine := engine ;
18395: LD_ADDR_OWVAR 39
18399: PUSH
18400: LD_VAR 0 2
18404: ST_TO_ADDR
// vc_control := control ;
18405: LD_ADDR_OWVAR 38
18409: PUSH
18410: LD_VAR 0 3
18414: ST_TO_ADDR
// vc_weapon := weapon ;
18415: LD_ADDR_OWVAR 40
18419: PUSH
18420: LD_VAR 0 4
18424: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18425: LD_ADDR_OWVAR 41
18429: PUSH
18430: LD_VAR 0 5
18434: ST_TO_ADDR
// end ;
18435: LD_VAR 0 6
18439: RET
// export function WantPlant ( unit ) ; var task ; begin
18440: LD_INT 0
18442: PPUSH
18443: PPUSH
// result := false ;
18444: LD_ADDR_VAR 0 2
18448: PUSH
18449: LD_INT 0
18451: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18452: LD_ADDR_VAR 0 3
18456: PUSH
18457: LD_VAR 0 1
18461: PPUSH
18462: CALL_OW 437
18466: ST_TO_ADDR
// if task then
18467: LD_VAR 0 3
18471: IFFALSE 18499
// if task [ 1 ] [ 1 ] = p then
18473: LD_VAR 0 3
18477: PUSH
18478: LD_INT 1
18480: ARRAY
18481: PUSH
18482: LD_INT 1
18484: ARRAY
18485: PUSH
18486: LD_STRING p
18488: EQUAL
18489: IFFALSE 18499
// result := true ;
18491: LD_ADDR_VAR 0 2
18495: PUSH
18496: LD_INT 1
18498: ST_TO_ADDR
// end ;
18499: LD_VAR 0 2
18503: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18504: LD_INT 0
18506: PPUSH
18507: PPUSH
18508: PPUSH
18509: PPUSH
// if pos < 1 then
18510: LD_VAR 0 2
18514: PUSH
18515: LD_INT 1
18517: LESS
18518: IFFALSE 18522
// exit ;
18520: GO 18825
// if pos = 1 then
18522: LD_VAR 0 2
18526: PUSH
18527: LD_INT 1
18529: EQUAL
18530: IFFALSE 18563
// result := Replace ( arr , pos [ 1 ] , value ) else
18532: LD_ADDR_VAR 0 4
18536: PUSH
18537: LD_VAR 0 1
18541: PPUSH
18542: LD_VAR 0 2
18546: PUSH
18547: LD_INT 1
18549: ARRAY
18550: PPUSH
18551: LD_VAR 0 3
18555: PPUSH
18556: CALL_OW 1
18560: ST_TO_ADDR
18561: GO 18825
// begin tmp := arr ;
18563: LD_ADDR_VAR 0 6
18567: PUSH
18568: LD_VAR 0 1
18572: ST_TO_ADDR
// s_arr := [ tmp ] ;
18573: LD_ADDR_VAR 0 7
18577: PUSH
18578: LD_VAR 0 6
18582: PUSH
18583: EMPTY
18584: LIST
18585: ST_TO_ADDR
// for i = 1 to pos - 1 do
18586: LD_ADDR_VAR 0 5
18590: PUSH
18591: DOUBLE
18592: LD_INT 1
18594: DEC
18595: ST_TO_ADDR
18596: LD_VAR 0 2
18600: PUSH
18601: LD_INT 1
18603: MINUS
18604: PUSH
18605: FOR_TO
18606: IFFALSE 18651
// begin tmp := tmp [ pos [ i ] ] ;
18608: LD_ADDR_VAR 0 6
18612: PUSH
18613: LD_VAR 0 6
18617: PUSH
18618: LD_VAR 0 2
18622: PUSH
18623: LD_VAR 0 5
18627: ARRAY
18628: ARRAY
18629: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18630: LD_ADDR_VAR 0 7
18634: PUSH
18635: LD_VAR 0 7
18639: PUSH
18640: LD_VAR 0 6
18644: PUSH
18645: EMPTY
18646: LIST
18647: ADD
18648: ST_TO_ADDR
// end ;
18649: GO 18605
18651: POP
18652: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18653: LD_ADDR_VAR 0 6
18657: PUSH
18658: LD_VAR 0 6
18662: PPUSH
18663: LD_VAR 0 2
18667: PUSH
18668: LD_VAR 0 2
18672: ARRAY
18673: PPUSH
18674: LD_VAR 0 3
18678: PPUSH
18679: CALL_OW 1
18683: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18684: LD_ADDR_VAR 0 7
18688: PUSH
18689: LD_VAR 0 7
18693: PPUSH
18694: LD_VAR 0 7
18698: PPUSH
18699: LD_VAR 0 6
18703: PPUSH
18704: CALL_OW 1
18708: ST_TO_ADDR
// for i = s_arr downto 2 do
18709: LD_ADDR_VAR 0 5
18713: PUSH
18714: DOUBLE
18715: LD_VAR 0 7
18719: INC
18720: ST_TO_ADDR
18721: LD_INT 2
18723: PUSH
18724: FOR_DOWNTO
18725: IFFALSE 18809
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18727: LD_ADDR_VAR 0 6
18731: PUSH
18732: LD_VAR 0 7
18736: PUSH
18737: LD_VAR 0 5
18741: PUSH
18742: LD_INT 1
18744: MINUS
18745: ARRAY
18746: PPUSH
18747: LD_VAR 0 2
18751: PUSH
18752: LD_VAR 0 5
18756: PUSH
18757: LD_INT 1
18759: MINUS
18760: ARRAY
18761: PPUSH
18762: LD_VAR 0 7
18766: PUSH
18767: LD_VAR 0 5
18771: ARRAY
18772: PPUSH
18773: CALL_OW 1
18777: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
18778: LD_ADDR_VAR 0 7
18782: PUSH
18783: LD_VAR 0 7
18787: PPUSH
18788: LD_VAR 0 5
18792: PUSH
18793: LD_INT 1
18795: MINUS
18796: PPUSH
18797: LD_VAR 0 6
18801: PPUSH
18802: CALL_OW 1
18806: ST_TO_ADDR
// end ;
18807: GO 18724
18809: POP
18810: POP
// result := s_arr [ 1 ] ;
18811: LD_ADDR_VAR 0 4
18815: PUSH
18816: LD_VAR 0 7
18820: PUSH
18821: LD_INT 1
18823: ARRAY
18824: ST_TO_ADDR
// end ; end ;
18825: LD_VAR 0 4
18829: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
18830: LD_INT 0
18832: PPUSH
18833: PPUSH
// if not list then
18834: LD_VAR 0 1
18838: NOT
18839: IFFALSE 18843
// exit ;
18841: GO 18934
// i := list [ pos1 ] ;
18843: LD_ADDR_VAR 0 5
18847: PUSH
18848: LD_VAR 0 1
18852: PUSH
18853: LD_VAR 0 2
18857: ARRAY
18858: ST_TO_ADDR
// if not i then
18859: LD_VAR 0 5
18863: NOT
18864: IFFALSE 18868
// exit ;
18866: GO 18934
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
18868: LD_ADDR_VAR 0 1
18872: PUSH
18873: LD_VAR 0 1
18877: PPUSH
18878: LD_VAR 0 2
18882: PPUSH
18883: LD_VAR 0 1
18887: PUSH
18888: LD_VAR 0 3
18892: ARRAY
18893: PPUSH
18894: CALL_OW 1
18898: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
18899: LD_ADDR_VAR 0 1
18903: PUSH
18904: LD_VAR 0 1
18908: PPUSH
18909: LD_VAR 0 3
18913: PPUSH
18914: LD_VAR 0 5
18918: PPUSH
18919: CALL_OW 1
18923: ST_TO_ADDR
// result := list ;
18924: LD_ADDR_VAR 0 4
18928: PUSH
18929: LD_VAR 0 1
18933: ST_TO_ADDR
// end ;
18934: LD_VAR 0 4
18938: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
18939: LD_INT 0
18941: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
18942: LD_ADDR_VAR 0 5
18946: PUSH
18947: LD_VAR 0 1
18951: PPUSH
18952: CALL_OW 250
18956: PPUSH
18957: LD_VAR 0 1
18961: PPUSH
18962: CALL_OW 251
18966: PPUSH
18967: LD_VAR 0 2
18971: PPUSH
18972: LD_VAR 0 3
18976: PPUSH
18977: LD_VAR 0 4
18981: PPUSH
18982: CALL 18992 0 5
18986: ST_TO_ADDR
// end ;
18987: LD_VAR 0 5
18991: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
18992: LD_INT 0
18994: PPUSH
18995: PPUSH
18996: PPUSH
18997: PPUSH
// if not list then
18998: LD_VAR 0 3
19002: NOT
19003: IFFALSE 19007
// exit ;
19005: GO 19395
// result := [ ] ;
19007: LD_ADDR_VAR 0 6
19011: PUSH
19012: EMPTY
19013: ST_TO_ADDR
// for i in list do
19014: LD_ADDR_VAR 0 7
19018: PUSH
19019: LD_VAR 0 3
19023: PUSH
19024: FOR_IN
19025: IFFALSE 19227
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19027: LD_ADDR_VAR 0 9
19031: PUSH
19032: LD_VAR 0 7
19036: PPUSH
19037: LD_VAR 0 1
19041: PPUSH
19042: LD_VAR 0 2
19046: PPUSH
19047: CALL_OW 297
19051: ST_TO_ADDR
// if not result then
19052: LD_VAR 0 6
19056: NOT
19057: IFFALSE 19083
// result := [ [ i , tmp ] ] else
19059: LD_ADDR_VAR 0 6
19063: PUSH
19064: LD_VAR 0 7
19068: PUSH
19069: LD_VAR 0 9
19073: PUSH
19074: EMPTY
19075: LIST
19076: LIST
19077: PUSH
19078: EMPTY
19079: LIST
19080: ST_TO_ADDR
19081: GO 19225
// begin if result [ result ] [ 2 ] < tmp then
19083: LD_VAR 0 6
19087: PUSH
19088: LD_VAR 0 6
19092: ARRAY
19093: PUSH
19094: LD_INT 2
19096: ARRAY
19097: PUSH
19098: LD_VAR 0 9
19102: LESS
19103: IFFALSE 19145
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19105: LD_ADDR_VAR 0 6
19109: PUSH
19110: LD_VAR 0 6
19114: PPUSH
19115: LD_VAR 0 6
19119: PUSH
19120: LD_INT 1
19122: PLUS
19123: PPUSH
19124: LD_VAR 0 7
19128: PUSH
19129: LD_VAR 0 9
19133: PUSH
19134: EMPTY
19135: LIST
19136: LIST
19137: PPUSH
19138: CALL_OW 2
19142: ST_TO_ADDR
19143: GO 19225
// for j = 1 to result do
19145: LD_ADDR_VAR 0 8
19149: PUSH
19150: DOUBLE
19151: LD_INT 1
19153: DEC
19154: ST_TO_ADDR
19155: LD_VAR 0 6
19159: PUSH
19160: FOR_TO
19161: IFFALSE 19223
// begin if tmp < result [ j ] [ 2 ] then
19163: LD_VAR 0 9
19167: PUSH
19168: LD_VAR 0 6
19172: PUSH
19173: LD_VAR 0 8
19177: ARRAY
19178: PUSH
19179: LD_INT 2
19181: ARRAY
19182: LESS
19183: IFFALSE 19221
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19185: LD_ADDR_VAR 0 6
19189: PUSH
19190: LD_VAR 0 6
19194: PPUSH
19195: LD_VAR 0 8
19199: PPUSH
19200: LD_VAR 0 7
19204: PUSH
19205: LD_VAR 0 9
19209: PUSH
19210: EMPTY
19211: LIST
19212: LIST
19213: PPUSH
19214: CALL_OW 2
19218: ST_TO_ADDR
// break ;
19219: GO 19223
// end ; end ;
19221: GO 19160
19223: POP
19224: POP
// end ; end ;
19225: GO 19024
19227: POP
19228: POP
// if result and not asc then
19229: LD_VAR 0 6
19233: PUSH
19234: LD_VAR 0 4
19238: NOT
19239: AND
19240: IFFALSE 19315
// begin tmp := result ;
19242: LD_ADDR_VAR 0 9
19246: PUSH
19247: LD_VAR 0 6
19251: ST_TO_ADDR
// for i = tmp downto 1 do
19252: LD_ADDR_VAR 0 7
19256: PUSH
19257: DOUBLE
19258: LD_VAR 0 9
19262: INC
19263: ST_TO_ADDR
19264: LD_INT 1
19266: PUSH
19267: FOR_DOWNTO
19268: IFFALSE 19313
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
19270: LD_ADDR_VAR 0 6
19274: PUSH
19275: LD_VAR 0 6
19279: PPUSH
19280: LD_VAR 0 9
19284: PUSH
19285: LD_VAR 0 7
19289: MINUS
19290: PUSH
19291: LD_INT 1
19293: PLUS
19294: PPUSH
19295: LD_VAR 0 9
19299: PUSH
19300: LD_VAR 0 7
19304: ARRAY
19305: PPUSH
19306: CALL_OW 1
19310: ST_TO_ADDR
19311: GO 19267
19313: POP
19314: POP
// end ; tmp := [ ] ;
19315: LD_ADDR_VAR 0 9
19319: PUSH
19320: EMPTY
19321: ST_TO_ADDR
// if mode then
19322: LD_VAR 0 5
19326: IFFALSE 19395
// begin for i = 1 to result do
19328: LD_ADDR_VAR 0 7
19332: PUSH
19333: DOUBLE
19334: LD_INT 1
19336: DEC
19337: ST_TO_ADDR
19338: LD_VAR 0 6
19342: PUSH
19343: FOR_TO
19344: IFFALSE 19383
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19346: LD_ADDR_VAR 0 9
19350: PUSH
19351: LD_VAR 0 9
19355: PPUSH
19356: LD_VAR 0 7
19360: PPUSH
19361: LD_VAR 0 6
19365: PUSH
19366: LD_VAR 0 7
19370: ARRAY
19371: PUSH
19372: LD_INT 1
19374: ARRAY
19375: PPUSH
19376: CALL_OW 1
19380: ST_TO_ADDR
19381: GO 19343
19383: POP
19384: POP
// result := tmp ;
19385: LD_ADDR_VAR 0 6
19389: PUSH
19390: LD_VAR 0 9
19394: ST_TO_ADDR
// end ; end ;
19395: LD_VAR 0 6
19399: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19400: LD_INT 0
19402: PPUSH
19403: PPUSH
19404: PPUSH
19405: PPUSH
19406: PPUSH
19407: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19408: LD_ADDR_VAR 0 5
19412: PUSH
19413: LD_INT 0
19415: PUSH
19416: LD_INT 0
19418: PUSH
19419: LD_INT 0
19421: PUSH
19422: EMPTY
19423: PUSH
19424: EMPTY
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: ST_TO_ADDR
// if not x or not y then
19430: LD_VAR 0 2
19434: NOT
19435: PUSH
19436: LD_VAR 0 3
19440: NOT
19441: OR
19442: IFFALSE 19446
// exit ;
19444: GO 21092
// if not range then
19446: LD_VAR 0 4
19450: NOT
19451: IFFALSE 19461
// range := 10 ;
19453: LD_ADDR_VAR 0 4
19457: PUSH
19458: LD_INT 10
19460: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19461: LD_ADDR_VAR 0 8
19465: PUSH
19466: LD_INT 81
19468: PUSH
19469: LD_VAR 0 1
19473: PUSH
19474: EMPTY
19475: LIST
19476: LIST
19477: PUSH
19478: LD_INT 92
19480: PUSH
19481: LD_VAR 0 2
19485: PUSH
19486: LD_VAR 0 3
19490: PUSH
19491: LD_VAR 0 4
19495: PUSH
19496: EMPTY
19497: LIST
19498: LIST
19499: LIST
19500: LIST
19501: PUSH
19502: LD_INT 3
19504: PUSH
19505: LD_INT 21
19507: PUSH
19508: LD_INT 3
19510: PUSH
19511: EMPTY
19512: LIST
19513: LIST
19514: PUSH
19515: EMPTY
19516: LIST
19517: LIST
19518: PUSH
19519: EMPTY
19520: LIST
19521: LIST
19522: LIST
19523: PPUSH
19524: CALL_OW 69
19528: ST_TO_ADDR
// if not tmp then
19529: LD_VAR 0 8
19533: NOT
19534: IFFALSE 19538
// exit ;
19536: GO 21092
// for i in tmp do
19538: LD_ADDR_VAR 0 6
19542: PUSH
19543: LD_VAR 0 8
19547: PUSH
19548: FOR_IN
19549: IFFALSE 21067
// begin points := [ 0 , 0 , 0 ] ;
19551: LD_ADDR_VAR 0 9
19555: PUSH
19556: LD_INT 0
19558: PUSH
19559: LD_INT 0
19561: PUSH
19562: LD_INT 0
19564: PUSH
19565: EMPTY
19566: LIST
19567: LIST
19568: LIST
19569: ST_TO_ADDR
// bpoints := 1 ;
19570: LD_ADDR_VAR 0 10
19574: PUSH
19575: LD_INT 1
19577: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19578: LD_VAR 0 6
19582: PPUSH
19583: CALL_OW 247
19587: PUSH
19588: LD_INT 1
19590: DOUBLE
19591: EQUAL
19592: IFTRUE 19596
19594: GO 20174
19596: POP
// begin if GetClass ( i ) = 1 then
19597: LD_VAR 0 6
19601: PPUSH
19602: CALL_OW 257
19606: PUSH
19607: LD_INT 1
19609: EQUAL
19610: IFFALSE 19631
// points := [ 10 , 5 , 3 ] ;
19612: LD_ADDR_VAR 0 9
19616: PUSH
19617: LD_INT 10
19619: PUSH
19620: LD_INT 5
19622: PUSH
19623: LD_INT 3
19625: PUSH
19626: EMPTY
19627: LIST
19628: LIST
19629: LIST
19630: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19631: LD_VAR 0 6
19635: PPUSH
19636: CALL_OW 257
19640: PUSH
19641: LD_INT 2
19643: PUSH
19644: LD_INT 3
19646: PUSH
19647: LD_INT 4
19649: PUSH
19650: EMPTY
19651: LIST
19652: LIST
19653: LIST
19654: IN
19655: IFFALSE 19676
// points := [ 3 , 2 , 1 ] ;
19657: LD_ADDR_VAR 0 9
19661: PUSH
19662: LD_INT 3
19664: PUSH
19665: LD_INT 2
19667: PUSH
19668: LD_INT 1
19670: PUSH
19671: EMPTY
19672: LIST
19673: LIST
19674: LIST
19675: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19676: LD_VAR 0 6
19680: PPUSH
19681: CALL_OW 257
19685: PUSH
19686: LD_INT 5
19688: EQUAL
19689: IFFALSE 19710
// points := [ 130 , 5 , 2 ] ;
19691: LD_ADDR_VAR 0 9
19695: PUSH
19696: LD_INT 130
19698: PUSH
19699: LD_INT 5
19701: PUSH
19702: LD_INT 2
19704: PUSH
19705: EMPTY
19706: LIST
19707: LIST
19708: LIST
19709: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19710: LD_VAR 0 6
19714: PPUSH
19715: CALL_OW 257
19719: PUSH
19720: LD_INT 8
19722: EQUAL
19723: IFFALSE 19744
// points := [ 35 , 35 , 30 ] ;
19725: LD_ADDR_VAR 0 9
19729: PUSH
19730: LD_INT 35
19732: PUSH
19733: LD_INT 35
19735: PUSH
19736: LD_INT 30
19738: PUSH
19739: EMPTY
19740: LIST
19741: LIST
19742: LIST
19743: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19744: LD_VAR 0 6
19748: PPUSH
19749: CALL_OW 257
19753: PUSH
19754: LD_INT 9
19756: EQUAL
19757: IFFALSE 19778
// points := [ 20 , 55 , 40 ] ;
19759: LD_ADDR_VAR 0 9
19763: PUSH
19764: LD_INT 20
19766: PUSH
19767: LD_INT 55
19769: PUSH
19770: LD_INT 40
19772: PUSH
19773: EMPTY
19774: LIST
19775: LIST
19776: LIST
19777: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
19778: LD_VAR 0 6
19782: PPUSH
19783: CALL_OW 257
19787: PUSH
19788: LD_INT 12
19790: PUSH
19791: LD_INT 16
19793: PUSH
19794: EMPTY
19795: LIST
19796: LIST
19797: IN
19798: IFFALSE 19819
// points := [ 5 , 3 , 2 ] ;
19800: LD_ADDR_VAR 0 9
19804: PUSH
19805: LD_INT 5
19807: PUSH
19808: LD_INT 3
19810: PUSH
19811: LD_INT 2
19813: PUSH
19814: EMPTY
19815: LIST
19816: LIST
19817: LIST
19818: ST_TO_ADDR
// if GetClass ( i ) = 17 then
19819: LD_VAR 0 6
19823: PPUSH
19824: CALL_OW 257
19828: PUSH
19829: LD_INT 17
19831: EQUAL
19832: IFFALSE 19853
// points := [ 100 , 50 , 75 ] ;
19834: LD_ADDR_VAR 0 9
19838: PUSH
19839: LD_INT 100
19841: PUSH
19842: LD_INT 50
19844: PUSH
19845: LD_INT 75
19847: PUSH
19848: EMPTY
19849: LIST
19850: LIST
19851: LIST
19852: ST_TO_ADDR
// if GetClass ( i ) = 15 then
19853: LD_VAR 0 6
19857: PPUSH
19858: CALL_OW 257
19862: PUSH
19863: LD_INT 15
19865: EQUAL
19866: IFFALSE 19887
// points := [ 10 , 5 , 3 ] ;
19868: LD_ADDR_VAR 0 9
19872: PUSH
19873: LD_INT 10
19875: PUSH
19876: LD_INT 5
19878: PUSH
19879: LD_INT 3
19881: PUSH
19882: EMPTY
19883: LIST
19884: LIST
19885: LIST
19886: ST_TO_ADDR
// if GetClass ( i ) = 14 then
19887: LD_VAR 0 6
19891: PPUSH
19892: CALL_OW 257
19896: PUSH
19897: LD_INT 14
19899: EQUAL
19900: IFFALSE 19921
// points := [ 10 , 0 , 0 ] ;
19902: LD_ADDR_VAR 0 9
19906: PUSH
19907: LD_INT 10
19909: PUSH
19910: LD_INT 0
19912: PUSH
19913: LD_INT 0
19915: PUSH
19916: EMPTY
19917: LIST
19918: LIST
19919: LIST
19920: ST_TO_ADDR
// if GetClass ( i ) = 11 then
19921: LD_VAR 0 6
19925: PPUSH
19926: CALL_OW 257
19930: PUSH
19931: LD_INT 11
19933: EQUAL
19934: IFFALSE 19955
// points := [ 30 , 10 , 5 ] ;
19936: LD_ADDR_VAR 0 9
19940: PUSH
19941: LD_INT 30
19943: PUSH
19944: LD_INT 10
19946: PUSH
19947: LD_INT 5
19949: PUSH
19950: EMPTY
19951: LIST
19952: LIST
19953: LIST
19954: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
19955: LD_VAR 0 1
19959: PPUSH
19960: LD_INT 5
19962: PPUSH
19963: CALL_OW 321
19967: PUSH
19968: LD_INT 2
19970: EQUAL
19971: IFFALSE 19988
// bpoints := bpoints * 1.8 ;
19973: LD_ADDR_VAR 0 10
19977: PUSH
19978: LD_VAR 0 10
19982: PUSH
19983: LD_REAL  1.80000000000000E+0000
19986: MUL
19987: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
19988: LD_VAR 0 6
19992: PPUSH
19993: CALL_OW 257
19997: PUSH
19998: LD_INT 1
20000: PUSH
20001: LD_INT 2
20003: PUSH
20004: LD_INT 3
20006: PUSH
20007: LD_INT 4
20009: PUSH
20010: EMPTY
20011: LIST
20012: LIST
20013: LIST
20014: LIST
20015: IN
20016: PUSH
20017: LD_VAR 0 1
20021: PPUSH
20022: LD_INT 51
20024: PPUSH
20025: CALL_OW 321
20029: PUSH
20030: LD_INT 2
20032: EQUAL
20033: AND
20034: IFFALSE 20051
// bpoints := bpoints * 1.2 ;
20036: LD_ADDR_VAR 0 10
20040: PUSH
20041: LD_VAR 0 10
20045: PUSH
20046: LD_REAL  1.20000000000000E+0000
20049: MUL
20050: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20051: LD_VAR 0 6
20055: PPUSH
20056: CALL_OW 257
20060: PUSH
20061: LD_INT 5
20063: PUSH
20064: LD_INT 7
20066: PUSH
20067: LD_INT 9
20069: PUSH
20070: EMPTY
20071: LIST
20072: LIST
20073: LIST
20074: IN
20075: PUSH
20076: LD_VAR 0 1
20080: PPUSH
20081: LD_INT 52
20083: PPUSH
20084: CALL_OW 321
20088: PUSH
20089: LD_INT 2
20091: EQUAL
20092: AND
20093: IFFALSE 20110
// bpoints := bpoints * 1.5 ;
20095: LD_ADDR_VAR 0 10
20099: PUSH
20100: LD_VAR 0 10
20104: PUSH
20105: LD_REAL  1.50000000000000E+0000
20108: MUL
20109: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20110: LD_VAR 0 1
20114: PPUSH
20115: LD_INT 66
20117: PPUSH
20118: CALL_OW 321
20122: PUSH
20123: LD_INT 2
20125: EQUAL
20126: IFFALSE 20143
// bpoints := bpoints * 1.1 ;
20128: LD_ADDR_VAR 0 10
20132: PUSH
20133: LD_VAR 0 10
20137: PUSH
20138: LD_REAL  1.10000000000000E+0000
20141: MUL
20142: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20143: LD_ADDR_VAR 0 10
20147: PUSH
20148: LD_VAR 0 10
20152: PUSH
20153: LD_VAR 0 6
20157: PPUSH
20158: LD_INT 1
20160: PPUSH
20161: CALL_OW 259
20165: PUSH
20166: LD_REAL  1.15000000000000E+0000
20169: MUL
20170: MUL
20171: ST_TO_ADDR
// end ; unit_vehicle :
20172: GO 20996
20174: LD_INT 2
20176: DOUBLE
20177: EQUAL
20178: IFTRUE 20182
20180: GO 20984
20182: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20183: LD_VAR 0 6
20187: PPUSH
20188: CALL_OW 264
20192: PUSH
20193: LD_INT 2
20195: PUSH
20196: LD_INT 42
20198: PUSH
20199: LD_INT 24
20201: PUSH
20202: EMPTY
20203: LIST
20204: LIST
20205: LIST
20206: IN
20207: IFFALSE 20228
// points := [ 25 , 5 , 3 ] ;
20209: LD_ADDR_VAR 0 9
20213: PUSH
20214: LD_INT 25
20216: PUSH
20217: LD_INT 5
20219: PUSH
20220: LD_INT 3
20222: PUSH
20223: EMPTY
20224: LIST
20225: LIST
20226: LIST
20227: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20228: LD_VAR 0 6
20232: PPUSH
20233: CALL_OW 264
20237: PUSH
20238: LD_INT 4
20240: PUSH
20241: LD_INT 43
20243: PUSH
20244: LD_INT 25
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: LIST
20251: IN
20252: IFFALSE 20273
// points := [ 40 , 15 , 5 ] ;
20254: LD_ADDR_VAR 0 9
20258: PUSH
20259: LD_INT 40
20261: PUSH
20262: LD_INT 15
20264: PUSH
20265: LD_INT 5
20267: PUSH
20268: EMPTY
20269: LIST
20270: LIST
20271: LIST
20272: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
20273: LD_VAR 0 6
20277: PPUSH
20278: CALL_OW 264
20282: PUSH
20283: LD_INT 3
20285: PUSH
20286: LD_INT 23
20288: PUSH
20289: EMPTY
20290: LIST
20291: LIST
20292: IN
20293: IFFALSE 20314
// points := [ 7 , 25 , 8 ] ;
20295: LD_ADDR_VAR 0 9
20299: PUSH
20300: LD_INT 7
20302: PUSH
20303: LD_INT 25
20305: PUSH
20306: LD_INT 8
20308: PUSH
20309: EMPTY
20310: LIST
20311: LIST
20312: LIST
20313: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
20314: LD_VAR 0 6
20318: PPUSH
20319: CALL_OW 264
20323: PUSH
20324: LD_INT 5
20326: PUSH
20327: LD_INT 27
20329: PUSH
20330: LD_INT 44
20332: PUSH
20333: EMPTY
20334: LIST
20335: LIST
20336: LIST
20337: IN
20338: IFFALSE 20359
// points := [ 14 , 50 , 16 ] ;
20340: LD_ADDR_VAR 0 9
20344: PUSH
20345: LD_INT 14
20347: PUSH
20348: LD_INT 50
20350: PUSH
20351: LD_INT 16
20353: PUSH
20354: EMPTY
20355: LIST
20356: LIST
20357: LIST
20358: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20359: LD_VAR 0 6
20363: PPUSH
20364: CALL_OW 264
20368: PUSH
20369: LD_INT 6
20371: PUSH
20372: LD_INT 46
20374: PUSH
20375: EMPTY
20376: LIST
20377: LIST
20378: IN
20379: IFFALSE 20400
// points := [ 32 , 120 , 70 ] ;
20381: LD_ADDR_VAR 0 9
20385: PUSH
20386: LD_INT 32
20388: PUSH
20389: LD_INT 120
20391: PUSH
20392: LD_INT 70
20394: PUSH
20395: EMPTY
20396: LIST
20397: LIST
20398: LIST
20399: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
20400: LD_VAR 0 6
20404: PPUSH
20405: CALL_OW 264
20409: PUSH
20410: LD_INT 7
20412: PUSH
20413: LD_INT 28
20415: PUSH
20416: LD_INT 45
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: LIST
20423: IN
20424: IFFALSE 20445
// points := [ 35 , 20 , 45 ] ;
20426: LD_ADDR_VAR 0 9
20430: PUSH
20431: LD_INT 35
20433: PUSH
20434: LD_INT 20
20436: PUSH
20437: LD_INT 45
20439: PUSH
20440: EMPTY
20441: LIST
20442: LIST
20443: LIST
20444: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20445: LD_VAR 0 6
20449: PPUSH
20450: CALL_OW 264
20454: PUSH
20455: LD_INT 47
20457: PUSH
20458: EMPTY
20459: LIST
20460: IN
20461: IFFALSE 20482
// points := [ 67 , 45 , 75 ] ;
20463: LD_ADDR_VAR 0 9
20467: PUSH
20468: LD_INT 67
20470: PUSH
20471: LD_INT 45
20473: PUSH
20474: LD_INT 75
20476: PUSH
20477: EMPTY
20478: LIST
20479: LIST
20480: LIST
20481: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20482: LD_VAR 0 6
20486: PPUSH
20487: CALL_OW 264
20491: PUSH
20492: LD_INT 26
20494: PUSH
20495: EMPTY
20496: LIST
20497: IN
20498: IFFALSE 20519
// points := [ 120 , 30 , 80 ] ;
20500: LD_ADDR_VAR 0 9
20504: PUSH
20505: LD_INT 120
20507: PUSH
20508: LD_INT 30
20510: PUSH
20511: LD_INT 80
20513: PUSH
20514: EMPTY
20515: LIST
20516: LIST
20517: LIST
20518: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20519: LD_VAR 0 6
20523: PPUSH
20524: CALL_OW 264
20528: PUSH
20529: LD_INT 22
20531: PUSH
20532: EMPTY
20533: LIST
20534: IN
20535: IFFALSE 20556
// points := [ 40 , 1 , 1 ] ;
20537: LD_ADDR_VAR 0 9
20541: PUSH
20542: LD_INT 40
20544: PUSH
20545: LD_INT 1
20547: PUSH
20548: LD_INT 1
20550: PUSH
20551: EMPTY
20552: LIST
20553: LIST
20554: LIST
20555: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20556: LD_VAR 0 6
20560: PPUSH
20561: CALL_OW 264
20565: PUSH
20566: LD_INT 29
20568: PUSH
20569: EMPTY
20570: LIST
20571: IN
20572: IFFALSE 20593
// points := [ 70 , 200 , 400 ] ;
20574: LD_ADDR_VAR 0 9
20578: PUSH
20579: LD_INT 70
20581: PUSH
20582: LD_INT 200
20584: PUSH
20585: LD_INT 400
20587: PUSH
20588: EMPTY
20589: LIST
20590: LIST
20591: LIST
20592: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20593: LD_VAR 0 6
20597: PPUSH
20598: CALL_OW 264
20602: PUSH
20603: LD_INT 14
20605: PUSH
20606: LD_INT 53
20608: PUSH
20609: EMPTY
20610: LIST
20611: LIST
20612: IN
20613: IFFALSE 20634
// points := [ 40 , 10 , 20 ] ;
20615: LD_ADDR_VAR 0 9
20619: PUSH
20620: LD_INT 40
20622: PUSH
20623: LD_INT 10
20625: PUSH
20626: LD_INT 20
20628: PUSH
20629: EMPTY
20630: LIST
20631: LIST
20632: LIST
20633: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20634: LD_VAR 0 6
20638: PPUSH
20639: CALL_OW 264
20643: PUSH
20644: LD_INT 9
20646: PUSH
20647: EMPTY
20648: LIST
20649: IN
20650: IFFALSE 20671
// points := [ 5 , 70 , 20 ] ;
20652: LD_ADDR_VAR 0 9
20656: PUSH
20657: LD_INT 5
20659: PUSH
20660: LD_INT 70
20662: PUSH
20663: LD_INT 20
20665: PUSH
20666: EMPTY
20667: LIST
20668: LIST
20669: LIST
20670: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20671: LD_VAR 0 6
20675: PPUSH
20676: CALL_OW 264
20680: PUSH
20681: LD_INT 10
20683: PUSH
20684: EMPTY
20685: LIST
20686: IN
20687: IFFALSE 20708
// points := [ 35 , 110 , 70 ] ;
20689: LD_ADDR_VAR 0 9
20693: PUSH
20694: LD_INT 35
20696: PUSH
20697: LD_INT 110
20699: PUSH
20700: LD_INT 70
20702: PUSH
20703: EMPTY
20704: LIST
20705: LIST
20706: LIST
20707: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20708: LD_VAR 0 6
20712: PPUSH
20713: CALL_OW 265
20717: PUSH
20718: LD_INT 25
20720: EQUAL
20721: IFFALSE 20742
// points := [ 80 , 65 , 100 ] ;
20723: LD_ADDR_VAR 0 9
20727: PUSH
20728: LD_INT 80
20730: PUSH
20731: LD_INT 65
20733: PUSH
20734: LD_INT 100
20736: PUSH
20737: EMPTY
20738: LIST
20739: LIST
20740: LIST
20741: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20742: LD_VAR 0 6
20746: PPUSH
20747: CALL_OW 263
20751: PUSH
20752: LD_INT 1
20754: EQUAL
20755: IFFALSE 20790
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
20757: LD_ADDR_VAR 0 10
20761: PUSH
20762: LD_VAR 0 10
20766: PUSH
20767: LD_VAR 0 6
20771: PPUSH
20772: CALL_OW 311
20776: PPUSH
20777: LD_INT 3
20779: PPUSH
20780: CALL_OW 259
20784: PUSH
20785: LD_INT 4
20787: MUL
20788: MUL
20789: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
20790: LD_VAR 0 6
20794: PPUSH
20795: CALL_OW 263
20799: PUSH
20800: LD_INT 2
20802: EQUAL
20803: IFFALSE 20854
// begin j := IsControledBy ( i ) ;
20805: LD_ADDR_VAR 0 7
20809: PUSH
20810: LD_VAR 0 6
20814: PPUSH
20815: CALL_OW 312
20819: ST_TO_ADDR
// if j then
20820: LD_VAR 0 7
20824: IFFALSE 20854
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
20826: LD_ADDR_VAR 0 10
20830: PUSH
20831: LD_VAR 0 10
20835: PUSH
20836: LD_VAR 0 7
20840: PPUSH
20841: LD_INT 3
20843: PPUSH
20844: CALL_OW 259
20848: PUSH
20849: LD_INT 3
20851: MUL
20852: MUL
20853: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
20854: LD_VAR 0 6
20858: PPUSH
20859: CALL_OW 264
20863: PUSH
20864: LD_INT 5
20866: PUSH
20867: LD_INT 6
20869: PUSH
20870: LD_INT 46
20872: PUSH
20873: LD_INT 44
20875: PUSH
20876: LD_INT 47
20878: PUSH
20879: LD_INT 45
20881: PUSH
20882: LD_INT 28
20884: PUSH
20885: LD_INT 7
20887: PUSH
20888: LD_INT 27
20890: PUSH
20891: LD_INT 29
20893: PUSH
20894: EMPTY
20895: LIST
20896: LIST
20897: LIST
20898: LIST
20899: LIST
20900: LIST
20901: LIST
20902: LIST
20903: LIST
20904: LIST
20905: IN
20906: PUSH
20907: LD_VAR 0 1
20911: PPUSH
20912: LD_INT 52
20914: PPUSH
20915: CALL_OW 321
20919: PUSH
20920: LD_INT 2
20922: EQUAL
20923: AND
20924: IFFALSE 20941
// bpoints := bpoints * 1.2 ;
20926: LD_ADDR_VAR 0 10
20930: PUSH
20931: LD_VAR 0 10
20935: PUSH
20936: LD_REAL  1.20000000000000E+0000
20939: MUL
20940: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
20941: LD_VAR 0 6
20945: PPUSH
20946: CALL_OW 264
20950: PUSH
20951: LD_INT 6
20953: PUSH
20954: LD_INT 46
20956: PUSH
20957: LD_INT 47
20959: PUSH
20960: EMPTY
20961: LIST
20962: LIST
20963: LIST
20964: IN
20965: IFFALSE 20982
// bpoints := bpoints * 1.2 ;
20967: LD_ADDR_VAR 0 10
20971: PUSH
20972: LD_VAR 0 10
20976: PUSH
20977: LD_REAL  1.20000000000000E+0000
20980: MUL
20981: ST_TO_ADDR
// end ; unit_building :
20982: GO 20996
20984: LD_INT 3
20986: DOUBLE
20987: EQUAL
20988: IFTRUE 20992
20990: GO 20995
20992: POP
// ; end ;
20993: GO 20996
20995: POP
// for j = 1 to 3 do
20996: LD_ADDR_VAR 0 7
21000: PUSH
21001: DOUBLE
21002: LD_INT 1
21004: DEC
21005: ST_TO_ADDR
21006: LD_INT 3
21008: PUSH
21009: FOR_TO
21010: IFFALSE 21063
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21012: LD_ADDR_VAR 0 5
21016: PUSH
21017: LD_VAR 0 5
21021: PPUSH
21022: LD_VAR 0 7
21026: PPUSH
21027: LD_VAR 0 5
21031: PUSH
21032: LD_VAR 0 7
21036: ARRAY
21037: PUSH
21038: LD_VAR 0 9
21042: PUSH
21043: LD_VAR 0 7
21047: ARRAY
21048: PUSH
21049: LD_VAR 0 10
21053: MUL
21054: PLUS
21055: PPUSH
21056: CALL_OW 1
21060: ST_TO_ADDR
21061: GO 21009
21063: POP
21064: POP
// end ;
21065: GO 19548
21067: POP
21068: POP
// result := Replace ( result , 4 , tmp ) ;
21069: LD_ADDR_VAR 0 5
21073: PUSH
21074: LD_VAR 0 5
21078: PPUSH
21079: LD_INT 4
21081: PPUSH
21082: LD_VAR 0 8
21086: PPUSH
21087: CALL_OW 1
21091: ST_TO_ADDR
// end ;
21092: LD_VAR 0 5
21096: RET
// export function DangerAtRange ( unit , range ) ; begin
21097: LD_INT 0
21099: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21100: LD_ADDR_VAR 0 3
21104: PUSH
21105: LD_VAR 0 1
21109: PPUSH
21110: CALL_OW 255
21114: PPUSH
21115: LD_VAR 0 1
21119: PPUSH
21120: CALL_OW 250
21124: PPUSH
21125: LD_VAR 0 1
21129: PPUSH
21130: CALL_OW 251
21134: PPUSH
21135: LD_VAR 0 2
21139: PPUSH
21140: CALL 19400 0 4
21144: ST_TO_ADDR
// end ;
21145: LD_VAR 0 3
21149: RET
// export function DangerInArea ( side , area ) ; begin
21150: LD_INT 0
21152: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21153: LD_ADDR_VAR 0 3
21157: PUSH
21158: LD_VAR 0 2
21162: PPUSH
21163: LD_INT 81
21165: PUSH
21166: LD_VAR 0 1
21170: PUSH
21171: EMPTY
21172: LIST
21173: LIST
21174: PPUSH
21175: CALL_OW 70
21179: ST_TO_ADDR
// end ;
21180: LD_VAR 0 3
21184: RET
// export function IsExtension ( b ) ; begin
21185: LD_INT 0
21187: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21188: LD_ADDR_VAR 0 2
21192: PUSH
21193: LD_VAR 0 1
21197: PUSH
21198: LD_INT 23
21200: PUSH
21201: LD_INT 20
21203: PUSH
21204: LD_INT 22
21206: PUSH
21207: LD_INT 17
21209: PUSH
21210: LD_INT 24
21212: PUSH
21213: LD_INT 21
21215: PUSH
21216: LD_INT 19
21218: PUSH
21219: LD_INT 16
21221: PUSH
21222: LD_INT 25
21224: PUSH
21225: LD_INT 18
21227: PUSH
21228: EMPTY
21229: LIST
21230: LIST
21231: LIST
21232: LIST
21233: LIST
21234: LIST
21235: LIST
21236: LIST
21237: LIST
21238: LIST
21239: IN
21240: ST_TO_ADDR
// end ;
21241: LD_VAR 0 2
21245: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
21246: LD_INT 0
21248: PPUSH
21249: PPUSH
21250: PPUSH
// result := [ ] ;
21251: LD_ADDR_VAR 0 3
21255: PUSH
21256: EMPTY
21257: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21258: LD_ADDR_VAR 0 4
21262: PUSH
21263: LD_VAR 0 2
21267: PPUSH
21268: LD_INT 21
21270: PUSH
21271: LD_INT 3
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: PPUSH
21278: CALL_OW 70
21282: ST_TO_ADDR
// if not tmp then
21283: LD_VAR 0 4
21287: NOT
21288: IFFALSE 21292
// exit ;
21290: GO 21350
// for i in tmp do
21292: LD_ADDR_VAR 0 5
21296: PUSH
21297: LD_VAR 0 4
21301: PUSH
21302: FOR_IN
21303: IFFALSE 21338
// if GetBase ( i ) <> base then
21305: LD_VAR 0 5
21309: PPUSH
21310: CALL_OW 274
21314: PUSH
21315: LD_VAR 0 1
21319: NONEQUAL
21320: IFFALSE 21336
// ComLinkToBase ( base , i ) ;
21322: LD_VAR 0 1
21326: PPUSH
21327: LD_VAR 0 5
21331: PPUSH
21332: CALL_OW 169
21336: GO 21302
21338: POP
21339: POP
// result := tmp ;
21340: LD_ADDR_VAR 0 3
21344: PUSH
21345: LD_VAR 0 4
21349: ST_TO_ADDR
// end ;
21350: LD_VAR 0 3
21354: RET
// export function ComComplete ( unit , b ) ; var i ; begin
21355: LD_INT 0
21357: PPUSH
21358: PPUSH
// if BuildingStatus ( b ) = bs_build then
21359: LD_VAR 0 2
21363: PPUSH
21364: CALL_OW 461
21368: PUSH
21369: LD_INT 1
21371: EQUAL
21372: IFFALSE 21432
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21374: LD_VAR 0 1
21378: PPUSH
21379: LD_STRING h
21381: PUSH
21382: LD_VAR 0 2
21386: PPUSH
21387: CALL_OW 250
21391: PUSH
21392: LD_VAR 0 2
21396: PPUSH
21397: CALL_OW 251
21401: PUSH
21402: LD_VAR 0 2
21406: PUSH
21407: LD_INT 0
21409: PUSH
21410: LD_INT 0
21412: PUSH
21413: LD_INT 0
21415: PUSH
21416: EMPTY
21417: LIST
21418: LIST
21419: LIST
21420: LIST
21421: LIST
21422: LIST
21423: LIST
21424: PUSH
21425: EMPTY
21426: LIST
21427: PPUSH
21428: CALL_OW 446
// end ;
21432: LD_VAR 0 3
21436: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21437: LD_INT 0
21439: PPUSH
21440: PPUSH
21441: PPUSH
21442: PPUSH
21443: PPUSH
21444: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
21445: LD_VAR 0 1
21449: NOT
21450: PUSH
21451: LD_VAR 0 1
21455: PPUSH
21456: CALL_OW 263
21460: PUSH
21461: LD_INT 2
21463: EQUAL
21464: NOT
21465: OR
21466: IFFALSE 21470
// exit ;
21468: GO 21786
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21470: LD_ADDR_VAR 0 6
21474: PUSH
21475: LD_INT 22
21477: PUSH
21478: LD_VAR 0 1
21482: PPUSH
21483: CALL_OW 255
21487: PUSH
21488: EMPTY
21489: LIST
21490: LIST
21491: PUSH
21492: LD_INT 2
21494: PUSH
21495: LD_INT 30
21497: PUSH
21498: LD_INT 36
21500: PUSH
21501: EMPTY
21502: LIST
21503: LIST
21504: PUSH
21505: LD_INT 34
21507: PUSH
21508: LD_INT 31
21510: PUSH
21511: EMPTY
21512: LIST
21513: LIST
21514: PUSH
21515: EMPTY
21516: LIST
21517: LIST
21518: LIST
21519: PUSH
21520: EMPTY
21521: LIST
21522: LIST
21523: PPUSH
21524: CALL_OW 69
21528: ST_TO_ADDR
// if not tmp then
21529: LD_VAR 0 6
21533: NOT
21534: IFFALSE 21538
// exit ;
21536: GO 21786
// result := [ ] ;
21538: LD_ADDR_VAR 0 2
21542: PUSH
21543: EMPTY
21544: ST_TO_ADDR
// for i in tmp do
21545: LD_ADDR_VAR 0 3
21549: PUSH
21550: LD_VAR 0 6
21554: PUSH
21555: FOR_IN
21556: IFFALSE 21627
// begin t := UnitsInside ( i ) ;
21558: LD_ADDR_VAR 0 4
21562: PUSH
21563: LD_VAR 0 3
21567: PPUSH
21568: CALL_OW 313
21572: ST_TO_ADDR
// if t then
21573: LD_VAR 0 4
21577: IFFALSE 21625
// for j in t do
21579: LD_ADDR_VAR 0 7
21583: PUSH
21584: LD_VAR 0 4
21588: PUSH
21589: FOR_IN
21590: IFFALSE 21623
// result := Insert ( result , result + 1 , j ) ;
21592: LD_ADDR_VAR 0 2
21596: PUSH
21597: LD_VAR 0 2
21601: PPUSH
21602: LD_VAR 0 2
21606: PUSH
21607: LD_INT 1
21609: PLUS
21610: PPUSH
21611: LD_VAR 0 7
21615: PPUSH
21616: CALL_OW 2
21620: ST_TO_ADDR
21621: GO 21589
21623: POP
21624: POP
// end ;
21625: GO 21555
21627: POP
21628: POP
// if not result then
21629: LD_VAR 0 2
21633: NOT
21634: IFFALSE 21638
// exit ;
21636: GO 21786
// mech := result [ 1 ] ;
21638: LD_ADDR_VAR 0 5
21642: PUSH
21643: LD_VAR 0 2
21647: PUSH
21648: LD_INT 1
21650: ARRAY
21651: ST_TO_ADDR
// if result > 1 then
21652: LD_VAR 0 2
21656: PUSH
21657: LD_INT 1
21659: GREATER
21660: IFFALSE 21772
// for i = 2 to result do
21662: LD_ADDR_VAR 0 3
21666: PUSH
21667: DOUBLE
21668: LD_INT 2
21670: DEC
21671: ST_TO_ADDR
21672: LD_VAR 0 2
21676: PUSH
21677: FOR_TO
21678: IFFALSE 21770
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21680: LD_ADDR_VAR 0 4
21684: PUSH
21685: LD_VAR 0 2
21689: PUSH
21690: LD_VAR 0 3
21694: ARRAY
21695: PPUSH
21696: LD_INT 3
21698: PPUSH
21699: CALL_OW 259
21703: PUSH
21704: LD_VAR 0 2
21708: PUSH
21709: LD_VAR 0 3
21713: ARRAY
21714: PPUSH
21715: CALL_OW 432
21719: MINUS
21720: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
21721: LD_VAR 0 4
21725: PUSH
21726: LD_VAR 0 5
21730: PPUSH
21731: LD_INT 3
21733: PPUSH
21734: CALL_OW 259
21738: PUSH
21739: LD_VAR 0 5
21743: PPUSH
21744: CALL_OW 432
21748: MINUS
21749: GREATEREQUAL
21750: IFFALSE 21768
// mech := result [ i ] ;
21752: LD_ADDR_VAR 0 5
21756: PUSH
21757: LD_VAR 0 2
21761: PUSH
21762: LD_VAR 0 3
21766: ARRAY
21767: ST_TO_ADDR
// end ;
21768: GO 21677
21770: POP
21771: POP
// ComLinkTo ( vehicle , mech ) ;
21772: LD_VAR 0 1
21776: PPUSH
21777: LD_VAR 0 5
21781: PPUSH
21782: CALL_OW 135
// end ;
21786: LD_VAR 0 2
21790: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
21791: LD_INT 0
21793: PPUSH
21794: PPUSH
21795: PPUSH
21796: PPUSH
21797: PPUSH
21798: PPUSH
21799: PPUSH
21800: PPUSH
21801: PPUSH
21802: PPUSH
21803: PPUSH
21804: PPUSH
21805: PPUSH
// result := [ ] ;
21806: LD_ADDR_VAR 0 7
21810: PUSH
21811: EMPTY
21812: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
21813: LD_VAR 0 1
21817: PPUSH
21818: CALL_OW 266
21822: PUSH
21823: LD_INT 0
21825: PUSH
21826: LD_INT 1
21828: PUSH
21829: EMPTY
21830: LIST
21831: LIST
21832: IN
21833: NOT
21834: IFFALSE 21838
// exit ;
21836: GO 23469
// if name then
21838: LD_VAR 0 3
21842: IFFALSE 21858
// SetBName ( base_dep , name ) ;
21844: LD_VAR 0 1
21848: PPUSH
21849: LD_VAR 0 3
21853: PPUSH
21854: CALL_OW 500
// base := GetBase ( base_dep ) ;
21858: LD_ADDR_VAR 0 15
21862: PUSH
21863: LD_VAR 0 1
21867: PPUSH
21868: CALL_OW 274
21872: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
21873: LD_ADDR_VAR 0 16
21877: PUSH
21878: LD_VAR 0 1
21882: PPUSH
21883: CALL_OW 255
21887: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
21888: LD_ADDR_VAR 0 17
21892: PUSH
21893: LD_VAR 0 1
21897: PPUSH
21898: CALL_OW 248
21902: ST_TO_ADDR
// if sources then
21903: LD_VAR 0 5
21907: IFFALSE 21954
// for i = 1 to 3 do
21909: LD_ADDR_VAR 0 8
21913: PUSH
21914: DOUBLE
21915: LD_INT 1
21917: DEC
21918: ST_TO_ADDR
21919: LD_INT 3
21921: PUSH
21922: FOR_TO
21923: IFFALSE 21952
// AddResourceType ( base , i , sources [ i ] ) ;
21925: LD_VAR 0 15
21929: PPUSH
21930: LD_VAR 0 8
21934: PPUSH
21935: LD_VAR 0 5
21939: PUSH
21940: LD_VAR 0 8
21944: ARRAY
21945: PPUSH
21946: CALL_OW 276
21950: GO 21922
21952: POP
21953: POP
// buildings := GetBaseBuildings ( base , area ) ;
21954: LD_ADDR_VAR 0 18
21958: PUSH
21959: LD_VAR 0 15
21963: PPUSH
21964: LD_VAR 0 2
21968: PPUSH
21969: CALL 21246 0 2
21973: ST_TO_ADDR
// InitHc ;
21974: CALL_OW 19
// InitUc ;
21978: CALL_OW 18
// uc_side := side ;
21982: LD_ADDR_OWVAR 20
21986: PUSH
21987: LD_VAR 0 16
21991: ST_TO_ADDR
// uc_nation := nation ;
21992: LD_ADDR_OWVAR 21
21996: PUSH
21997: LD_VAR 0 17
22001: ST_TO_ADDR
// if buildings then
22002: LD_VAR 0 18
22006: IFFALSE 23328
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22008: LD_ADDR_VAR 0 19
22012: PUSH
22013: LD_VAR 0 18
22017: PPUSH
22018: LD_INT 2
22020: PUSH
22021: LD_INT 30
22023: PUSH
22024: LD_INT 29
22026: PUSH
22027: EMPTY
22028: LIST
22029: LIST
22030: PUSH
22031: LD_INT 30
22033: PUSH
22034: LD_INT 30
22036: PUSH
22037: EMPTY
22038: LIST
22039: LIST
22040: PUSH
22041: EMPTY
22042: LIST
22043: LIST
22044: LIST
22045: PPUSH
22046: CALL_OW 72
22050: ST_TO_ADDR
// if tmp then
22051: LD_VAR 0 19
22055: IFFALSE 22103
// for i in tmp do
22057: LD_ADDR_VAR 0 8
22061: PUSH
22062: LD_VAR 0 19
22066: PUSH
22067: FOR_IN
22068: IFFALSE 22101
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22070: LD_VAR 0 8
22074: PPUSH
22075: CALL_OW 250
22079: PPUSH
22080: LD_VAR 0 8
22084: PPUSH
22085: CALL_OW 251
22089: PPUSH
22090: LD_VAR 0 16
22094: PPUSH
22095: CALL_OW 441
22099: GO 22067
22101: POP
22102: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22103: LD_VAR 0 18
22107: PPUSH
22108: LD_INT 2
22110: PUSH
22111: LD_INT 30
22113: PUSH
22114: LD_INT 32
22116: PUSH
22117: EMPTY
22118: LIST
22119: LIST
22120: PUSH
22121: LD_INT 30
22123: PUSH
22124: LD_INT 33
22126: PUSH
22127: EMPTY
22128: LIST
22129: LIST
22130: PUSH
22131: EMPTY
22132: LIST
22133: LIST
22134: LIST
22135: PPUSH
22136: CALL_OW 72
22140: IFFALSE 22228
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22142: LD_ADDR_VAR 0 8
22146: PUSH
22147: LD_VAR 0 18
22151: PPUSH
22152: LD_INT 2
22154: PUSH
22155: LD_INT 30
22157: PUSH
22158: LD_INT 32
22160: PUSH
22161: EMPTY
22162: LIST
22163: LIST
22164: PUSH
22165: LD_INT 30
22167: PUSH
22168: LD_INT 33
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: PUSH
22175: EMPTY
22176: LIST
22177: LIST
22178: LIST
22179: PPUSH
22180: CALL_OW 72
22184: PUSH
22185: FOR_IN
22186: IFFALSE 22226
// begin if not GetBWeapon ( i ) then
22188: LD_VAR 0 8
22192: PPUSH
22193: CALL_OW 269
22197: NOT
22198: IFFALSE 22224
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22200: LD_VAR 0 8
22204: PPUSH
22205: LD_VAR 0 8
22209: PPUSH
22210: LD_VAR 0 2
22214: PPUSH
22215: CALL 23474 0 2
22219: PPUSH
22220: CALL_OW 431
// end ;
22224: GO 22185
22226: POP
22227: POP
// end ; for i = 1 to personel do
22228: LD_ADDR_VAR 0 8
22232: PUSH
22233: DOUBLE
22234: LD_INT 1
22236: DEC
22237: ST_TO_ADDR
22238: LD_VAR 0 6
22242: PUSH
22243: FOR_TO
22244: IFFALSE 23308
// begin if i > 4 then
22246: LD_VAR 0 8
22250: PUSH
22251: LD_INT 4
22253: GREATER
22254: IFFALSE 22258
// break ;
22256: GO 23308
// case i of 1 :
22258: LD_VAR 0 8
22262: PUSH
22263: LD_INT 1
22265: DOUBLE
22266: EQUAL
22267: IFTRUE 22271
22269: GO 22351
22271: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
22272: LD_ADDR_VAR 0 12
22276: PUSH
22277: LD_VAR 0 18
22281: PPUSH
22282: LD_INT 22
22284: PUSH
22285: LD_VAR 0 16
22289: PUSH
22290: EMPTY
22291: LIST
22292: LIST
22293: PUSH
22294: LD_INT 58
22296: PUSH
22297: EMPTY
22298: LIST
22299: PUSH
22300: LD_INT 2
22302: PUSH
22303: LD_INT 30
22305: PUSH
22306: LD_INT 32
22308: PUSH
22309: EMPTY
22310: LIST
22311: LIST
22312: PUSH
22313: LD_INT 30
22315: PUSH
22316: LD_INT 4
22318: PUSH
22319: EMPTY
22320: LIST
22321: LIST
22322: PUSH
22323: LD_INT 30
22325: PUSH
22326: LD_INT 5
22328: PUSH
22329: EMPTY
22330: LIST
22331: LIST
22332: PUSH
22333: EMPTY
22334: LIST
22335: LIST
22336: LIST
22337: LIST
22338: PUSH
22339: EMPTY
22340: LIST
22341: LIST
22342: LIST
22343: PPUSH
22344: CALL_OW 72
22348: ST_TO_ADDR
22349: GO 22573
22351: LD_INT 2
22353: DOUBLE
22354: EQUAL
22355: IFTRUE 22359
22357: GO 22421
22359: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22360: LD_ADDR_VAR 0 12
22364: PUSH
22365: LD_VAR 0 18
22369: PPUSH
22370: LD_INT 22
22372: PUSH
22373: LD_VAR 0 16
22377: PUSH
22378: EMPTY
22379: LIST
22380: LIST
22381: PUSH
22382: LD_INT 2
22384: PUSH
22385: LD_INT 30
22387: PUSH
22388: LD_INT 0
22390: PUSH
22391: EMPTY
22392: LIST
22393: LIST
22394: PUSH
22395: LD_INT 30
22397: PUSH
22398: LD_INT 1
22400: PUSH
22401: EMPTY
22402: LIST
22403: LIST
22404: PUSH
22405: EMPTY
22406: LIST
22407: LIST
22408: LIST
22409: PUSH
22410: EMPTY
22411: LIST
22412: LIST
22413: PPUSH
22414: CALL_OW 72
22418: ST_TO_ADDR
22419: GO 22573
22421: LD_INT 3
22423: DOUBLE
22424: EQUAL
22425: IFTRUE 22429
22427: GO 22491
22429: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22430: LD_ADDR_VAR 0 12
22434: PUSH
22435: LD_VAR 0 18
22439: PPUSH
22440: LD_INT 22
22442: PUSH
22443: LD_VAR 0 16
22447: PUSH
22448: EMPTY
22449: LIST
22450: LIST
22451: PUSH
22452: LD_INT 2
22454: PUSH
22455: LD_INT 30
22457: PUSH
22458: LD_INT 2
22460: PUSH
22461: EMPTY
22462: LIST
22463: LIST
22464: PUSH
22465: LD_INT 30
22467: PUSH
22468: LD_INT 3
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: PUSH
22475: EMPTY
22476: LIST
22477: LIST
22478: LIST
22479: PUSH
22480: EMPTY
22481: LIST
22482: LIST
22483: PPUSH
22484: CALL_OW 72
22488: ST_TO_ADDR
22489: GO 22573
22491: LD_INT 4
22493: DOUBLE
22494: EQUAL
22495: IFTRUE 22499
22497: GO 22572
22499: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22500: LD_ADDR_VAR 0 12
22504: PUSH
22505: LD_VAR 0 18
22509: PPUSH
22510: LD_INT 22
22512: PUSH
22513: LD_VAR 0 16
22517: PUSH
22518: EMPTY
22519: LIST
22520: LIST
22521: PUSH
22522: LD_INT 2
22524: PUSH
22525: LD_INT 30
22527: PUSH
22528: LD_INT 6
22530: PUSH
22531: EMPTY
22532: LIST
22533: LIST
22534: PUSH
22535: LD_INT 30
22537: PUSH
22538: LD_INT 7
22540: PUSH
22541: EMPTY
22542: LIST
22543: LIST
22544: PUSH
22545: LD_INT 30
22547: PUSH
22548: LD_INT 8
22550: PUSH
22551: EMPTY
22552: LIST
22553: LIST
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: LIST
22559: LIST
22560: PUSH
22561: EMPTY
22562: LIST
22563: LIST
22564: PPUSH
22565: CALL_OW 72
22569: ST_TO_ADDR
22570: GO 22573
22572: POP
// if i = 1 then
22573: LD_VAR 0 8
22577: PUSH
22578: LD_INT 1
22580: EQUAL
22581: IFFALSE 22692
// begin tmp := [ ] ;
22583: LD_ADDR_VAR 0 19
22587: PUSH
22588: EMPTY
22589: ST_TO_ADDR
// for j in f do
22590: LD_ADDR_VAR 0 9
22594: PUSH
22595: LD_VAR 0 12
22599: PUSH
22600: FOR_IN
22601: IFFALSE 22674
// if GetBType ( j ) = b_bunker then
22603: LD_VAR 0 9
22607: PPUSH
22608: CALL_OW 266
22612: PUSH
22613: LD_INT 32
22615: EQUAL
22616: IFFALSE 22643
// tmp := Insert ( tmp , 1 , j ) else
22618: LD_ADDR_VAR 0 19
22622: PUSH
22623: LD_VAR 0 19
22627: PPUSH
22628: LD_INT 1
22630: PPUSH
22631: LD_VAR 0 9
22635: PPUSH
22636: CALL_OW 2
22640: ST_TO_ADDR
22641: GO 22672
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22643: LD_ADDR_VAR 0 19
22647: PUSH
22648: LD_VAR 0 19
22652: PPUSH
22653: LD_VAR 0 19
22657: PUSH
22658: LD_INT 1
22660: PLUS
22661: PPUSH
22662: LD_VAR 0 9
22666: PPUSH
22667: CALL_OW 2
22671: ST_TO_ADDR
22672: GO 22600
22674: POP
22675: POP
// if tmp then
22676: LD_VAR 0 19
22680: IFFALSE 22692
// f := tmp ;
22682: LD_ADDR_VAR 0 12
22686: PUSH
22687: LD_VAR 0 19
22691: ST_TO_ADDR
// end ; x := personel [ i ] ;
22692: LD_ADDR_VAR 0 13
22696: PUSH
22697: LD_VAR 0 6
22701: PUSH
22702: LD_VAR 0 8
22706: ARRAY
22707: ST_TO_ADDR
// if x = - 1 then
22708: LD_VAR 0 13
22712: PUSH
22713: LD_INT 1
22715: NEG
22716: EQUAL
22717: IFFALSE 22926
// begin for j in f do
22719: LD_ADDR_VAR 0 9
22723: PUSH
22724: LD_VAR 0 12
22728: PUSH
22729: FOR_IN
22730: IFFALSE 22922
// repeat InitHc ;
22732: CALL_OW 19
// if GetBType ( j ) = b_barracks then
22736: LD_VAR 0 9
22740: PPUSH
22741: CALL_OW 266
22745: PUSH
22746: LD_INT 5
22748: EQUAL
22749: IFFALSE 22819
// begin if UnitsInside ( j ) < 3 then
22751: LD_VAR 0 9
22755: PPUSH
22756: CALL_OW 313
22760: PUSH
22761: LD_INT 3
22763: LESS
22764: IFFALSE 22800
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22766: LD_INT 0
22768: PPUSH
22769: LD_INT 5
22771: PUSH
22772: LD_INT 8
22774: PUSH
22775: LD_INT 9
22777: PUSH
22778: EMPTY
22779: LIST
22780: LIST
22781: LIST
22782: PUSH
22783: LD_VAR 0 17
22787: ARRAY
22788: PPUSH
22789: LD_VAR 0 4
22793: PPUSH
22794: CALL_OW 380
22798: GO 22817
// PrepareHuman ( false , i , skill ) ;
22800: LD_INT 0
22802: PPUSH
22803: LD_VAR 0 8
22807: PPUSH
22808: LD_VAR 0 4
22812: PPUSH
22813: CALL_OW 380
// end else
22817: GO 22836
// PrepareHuman ( false , i , skill ) ;
22819: LD_INT 0
22821: PPUSH
22822: LD_VAR 0 8
22826: PPUSH
22827: LD_VAR 0 4
22831: PPUSH
22832: CALL_OW 380
// un := CreateHuman ;
22836: LD_ADDR_VAR 0 14
22840: PUSH
22841: CALL_OW 44
22845: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22846: LD_ADDR_VAR 0 7
22850: PUSH
22851: LD_VAR 0 7
22855: PPUSH
22856: LD_INT 1
22858: PPUSH
22859: LD_VAR 0 14
22863: PPUSH
22864: CALL_OW 2
22868: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
22869: LD_VAR 0 14
22873: PPUSH
22874: LD_VAR 0 9
22878: PPUSH
22879: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
22883: LD_VAR 0 9
22887: PPUSH
22888: CALL_OW 313
22892: PUSH
22893: LD_INT 6
22895: EQUAL
22896: PUSH
22897: LD_VAR 0 9
22901: PPUSH
22902: CALL_OW 266
22906: PUSH
22907: LD_INT 32
22909: PUSH
22910: LD_INT 31
22912: PUSH
22913: EMPTY
22914: LIST
22915: LIST
22916: IN
22917: OR
22918: IFFALSE 22732
22920: GO 22729
22922: POP
22923: POP
// end else
22924: GO 23306
// for j = 1 to x do
22926: LD_ADDR_VAR 0 9
22930: PUSH
22931: DOUBLE
22932: LD_INT 1
22934: DEC
22935: ST_TO_ADDR
22936: LD_VAR 0 13
22940: PUSH
22941: FOR_TO
22942: IFFALSE 23304
// begin InitHc ;
22944: CALL_OW 19
// if not f then
22948: LD_VAR 0 12
22952: NOT
22953: IFFALSE 23042
// begin PrepareHuman ( false , i , skill ) ;
22955: LD_INT 0
22957: PPUSH
22958: LD_VAR 0 8
22962: PPUSH
22963: LD_VAR 0 4
22967: PPUSH
22968: CALL_OW 380
// un := CreateHuman ;
22972: LD_ADDR_VAR 0 14
22976: PUSH
22977: CALL_OW 44
22981: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22982: LD_ADDR_VAR 0 7
22986: PUSH
22987: LD_VAR 0 7
22991: PPUSH
22992: LD_INT 1
22994: PPUSH
22995: LD_VAR 0 14
22999: PPUSH
23000: CALL_OW 2
23004: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23005: LD_VAR 0 14
23009: PPUSH
23010: LD_VAR 0 1
23014: PPUSH
23015: CALL_OW 250
23019: PPUSH
23020: LD_VAR 0 1
23024: PPUSH
23025: CALL_OW 251
23029: PPUSH
23030: LD_INT 10
23032: PPUSH
23033: LD_INT 0
23035: PPUSH
23036: CALL_OW 50
// continue ;
23040: GO 22941
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23042: LD_VAR 0 12
23046: PUSH
23047: LD_INT 1
23049: ARRAY
23050: PPUSH
23051: CALL_OW 313
23055: PUSH
23056: LD_VAR 0 12
23060: PUSH
23061: LD_INT 1
23063: ARRAY
23064: PPUSH
23065: CALL_OW 266
23069: PUSH
23070: LD_INT 32
23072: PUSH
23073: LD_INT 31
23075: PUSH
23076: EMPTY
23077: LIST
23078: LIST
23079: IN
23080: AND
23081: PUSH
23082: LD_VAR 0 12
23086: PUSH
23087: LD_INT 1
23089: ARRAY
23090: PPUSH
23091: CALL_OW 313
23095: PUSH
23096: LD_INT 6
23098: EQUAL
23099: OR
23100: IFFALSE 23120
// f := Delete ( f , 1 ) ;
23102: LD_ADDR_VAR 0 12
23106: PUSH
23107: LD_VAR 0 12
23111: PPUSH
23112: LD_INT 1
23114: PPUSH
23115: CALL_OW 3
23119: ST_TO_ADDR
// if not f then
23120: LD_VAR 0 12
23124: NOT
23125: IFFALSE 23143
// begin x := x + 2 ;
23127: LD_ADDR_VAR 0 13
23131: PUSH
23132: LD_VAR 0 13
23136: PUSH
23137: LD_INT 2
23139: PLUS
23140: ST_TO_ADDR
// continue ;
23141: GO 22941
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23143: LD_VAR 0 12
23147: PUSH
23148: LD_INT 1
23150: ARRAY
23151: PPUSH
23152: CALL_OW 266
23156: PUSH
23157: LD_INT 5
23159: EQUAL
23160: IFFALSE 23234
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23162: LD_VAR 0 12
23166: PUSH
23167: LD_INT 1
23169: ARRAY
23170: PPUSH
23171: CALL_OW 313
23175: PUSH
23176: LD_INT 3
23178: LESS
23179: IFFALSE 23215
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23181: LD_INT 0
23183: PPUSH
23184: LD_INT 5
23186: PUSH
23187: LD_INT 8
23189: PUSH
23190: LD_INT 9
23192: PUSH
23193: EMPTY
23194: LIST
23195: LIST
23196: LIST
23197: PUSH
23198: LD_VAR 0 17
23202: ARRAY
23203: PPUSH
23204: LD_VAR 0 4
23208: PPUSH
23209: CALL_OW 380
23213: GO 23232
// PrepareHuman ( false , i , skill ) ;
23215: LD_INT 0
23217: PPUSH
23218: LD_VAR 0 8
23222: PPUSH
23223: LD_VAR 0 4
23227: PPUSH
23228: CALL_OW 380
// end else
23232: GO 23251
// PrepareHuman ( false , i , skill ) ;
23234: LD_INT 0
23236: PPUSH
23237: LD_VAR 0 8
23241: PPUSH
23242: LD_VAR 0 4
23246: PPUSH
23247: CALL_OW 380
// un := CreateHuman ;
23251: LD_ADDR_VAR 0 14
23255: PUSH
23256: CALL_OW 44
23260: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23261: LD_ADDR_VAR 0 7
23265: PUSH
23266: LD_VAR 0 7
23270: PPUSH
23271: LD_INT 1
23273: PPUSH
23274: LD_VAR 0 14
23278: PPUSH
23279: CALL_OW 2
23283: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
23284: LD_VAR 0 14
23288: PPUSH
23289: LD_VAR 0 12
23293: PUSH
23294: LD_INT 1
23296: ARRAY
23297: PPUSH
23298: CALL_OW 52
// end ;
23302: GO 22941
23304: POP
23305: POP
// end ;
23306: GO 22243
23308: POP
23309: POP
// result := result ^ buildings ;
23310: LD_ADDR_VAR 0 7
23314: PUSH
23315: LD_VAR 0 7
23319: PUSH
23320: LD_VAR 0 18
23324: ADD
23325: ST_TO_ADDR
// end else
23326: GO 23469
// begin for i = 1 to personel do
23328: LD_ADDR_VAR 0 8
23332: PUSH
23333: DOUBLE
23334: LD_INT 1
23336: DEC
23337: ST_TO_ADDR
23338: LD_VAR 0 6
23342: PUSH
23343: FOR_TO
23344: IFFALSE 23467
// begin if i > 4 then
23346: LD_VAR 0 8
23350: PUSH
23351: LD_INT 4
23353: GREATER
23354: IFFALSE 23358
// break ;
23356: GO 23467
// x := personel [ i ] ;
23358: LD_ADDR_VAR 0 13
23362: PUSH
23363: LD_VAR 0 6
23367: PUSH
23368: LD_VAR 0 8
23372: ARRAY
23373: ST_TO_ADDR
// if x = - 1 then
23374: LD_VAR 0 13
23378: PUSH
23379: LD_INT 1
23381: NEG
23382: EQUAL
23383: IFFALSE 23387
// continue ;
23385: GO 23343
// PrepareHuman ( false , i , skill ) ;
23387: LD_INT 0
23389: PPUSH
23390: LD_VAR 0 8
23394: PPUSH
23395: LD_VAR 0 4
23399: PPUSH
23400: CALL_OW 380
// un := CreateHuman ;
23404: LD_ADDR_VAR 0 14
23408: PUSH
23409: CALL_OW 44
23413: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23414: LD_VAR 0 14
23418: PPUSH
23419: LD_VAR 0 1
23423: PPUSH
23424: CALL_OW 250
23428: PPUSH
23429: LD_VAR 0 1
23433: PPUSH
23434: CALL_OW 251
23438: PPUSH
23439: LD_INT 10
23441: PPUSH
23442: LD_INT 0
23444: PPUSH
23445: CALL_OW 50
// result := result ^ un ;
23449: LD_ADDR_VAR 0 7
23453: PUSH
23454: LD_VAR 0 7
23458: PUSH
23459: LD_VAR 0 14
23463: ADD
23464: ST_TO_ADDR
// end ;
23465: GO 23343
23467: POP
23468: POP
// end ; end ;
23469: LD_VAR 0 7
23473: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23474: LD_INT 0
23476: PPUSH
23477: PPUSH
23478: PPUSH
23479: PPUSH
23480: PPUSH
23481: PPUSH
23482: PPUSH
23483: PPUSH
23484: PPUSH
23485: PPUSH
23486: PPUSH
23487: PPUSH
23488: PPUSH
23489: PPUSH
23490: PPUSH
23491: PPUSH
// result := false ;
23492: LD_ADDR_VAR 0 3
23496: PUSH
23497: LD_INT 0
23499: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23500: LD_VAR 0 1
23504: NOT
23505: PUSH
23506: LD_VAR 0 1
23510: PPUSH
23511: CALL_OW 266
23515: PUSH
23516: LD_INT 32
23518: PUSH
23519: LD_INT 33
23521: PUSH
23522: EMPTY
23523: LIST
23524: LIST
23525: IN
23526: NOT
23527: OR
23528: IFFALSE 23532
// exit ;
23530: GO 24668
// nat := GetNation ( tower ) ;
23532: LD_ADDR_VAR 0 12
23536: PUSH
23537: LD_VAR 0 1
23541: PPUSH
23542: CALL_OW 248
23546: ST_TO_ADDR
// side := GetSide ( tower ) ;
23547: LD_ADDR_VAR 0 16
23551: PUSH
23552: LD_VAR 0 1
23556: PPUSH
23557: CALL_OW 255
23561: ST_TO_ADDR
// x := GetX ( tower ) ;
23562: LD_ADDR_VAR 0 10
23566: PUSH
23567: LD_VAR 0 1
23571: PPUSH
23572: CALL_OW 250
23576: ST_TO_ADDR
// y := GetY ( tower ) ;
23577: LD_ADDR_VAR 0 11
23581: PUSH
23582: LD_VAR 0 1
23586: PPUSH
23587: CALL_OW 251
23591: ST_TO_ADDR
// if not x or not y then
23592: LD_VAR 0 10
23596: NOT
23597: PUSH
23598: LD_VAR 0 11
23602: NOT
23603: OR
23604: IFFALSE 23608
// exit ;
23606: GO 24668
// weapon := 0 ;
23608: LD_ADDR_VAR 0 18
23612: PUSH
23613: LD_INT 0
23615: ST_TO_ADDR
// fac_list := [ ] ;
23616: LD_ADDR_VAR 0 17
23620: PUSH
23621: EMPTY
23622: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
23623: LD_ADDR_VAR 0 6
23627: PUSH
23628: LD_VAR 0 1
23632: PPUSH
23633: CALL_OW 274
23637: PPUSH
23638: LD_VAR 0 2
23642: PPUSH
23643: CALL 21246 0 2
23647: PPUSH
23648: LD_INT 30
23650: PUSH
23651: LD_INT 3
23653: PUSH
23654: EMPTY
23655: LIST
23656: LIST
23657: PPUSH
23658: CALL_OW 72
23662: ST_TO_ADDR
// if not factories then
23663: LD_VAR 0 6
23667: NOT
23668: IFFALSE 23672
// exit ;
23670: GO 24668
// for i in factories do
23672: LD_ADDR_VAR 0 8
23676: PUSH
23677: LD_VAR 0 6
23681: PUSH
23682: FOR_IN
23683: IFFALSE 23708
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23685: LD_ADDR_VAR 0 17
23689: PUSH
23690: LD_VAR 0 17
23694: PUSH
23695: LD_VAR 0 8
23699: PPUSH
23700: CALL_OW 478
23704: UNION
23705: ST_TO_ADDR
23706: GO 23682
23708: POP
23709: POP
// if not fac_list then
23710: LD_VAR 0 17
23714: NOT
23715: IFFALSE 23719
// exit ;
23717: GO 24668
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
23719: LD_ADDR_VAR 0 5
23723: PUSH
23724: LD_INT 4
23726: PUSH
23727: LD_INT 5
23729: PUSH
23730: LD_INT 9
23732: PUSH
23733: LD_INT 10
23735: PUSH
23736: LD_INT 6
23738: PUSH
23739: LD_INT 7
23741: PUSH
23742: LD_INT 11
23744: PUSH
23745: EMPTY
23746: LIST
23747: LIST
23748: LIST
23749: LIST
23750: LIST
23751: LIST
23752: LIST
23753: PUSH
23754: LD_INT 27
23756: PUSH
23757: LD_INT 28
23759: PUSH
23760: LD_INT 26
23762: PUSH
23763: LD_INT 30
23765: PUSH
23766: EMPTY
23767: LIST
23768: LIST
23769: LIST
23770: LIST
23771: PUSH
23772: LD_INT 43
23774: PUSH
23775: LD_INT 44
23777: PUSH
23778: LD_INT 46
23780: PUSH
23781: LD_INT 45
23783: PUSH
23784: LD_INT 47
23786: PUSH
23787: LD_INT 49
23789: PUSH
23790: EMPTY
23791: LIST
23792: LIST
23793: LIST
23794: LIST
23795: LIST
23796: LIST
23797: PUSH
23798: EMPTY
23799: LIST
23800: LIST
23801: LIST
23802: PUSH
23803: LD_VAR 0 12
23807: ARRAY
23808: ST_TO_ADDR
// for i in list do
23809: LD_ADDR_VAR 0 8
23813: PUSH
23814: LD_VAR 0 5
23818: PUSH
23819: FOR_IN
23820: IFFALSE 23853
// if not i in fac_list then
23822: LD_VAR 0 8
23826: PUSH
23827: LD_VAR 0 17
23831: IN
23832: NOT
23833: IFFALSE 23851
// list := list diff i ;
23835: LD_ADDR_VAR 0 5
23839: PUSH
23840: LD_VAR 0 5
23844: PUSH
23845: LD_VAR 0 8
23849: DIFF
23850: ST_TO_ADDR
23851: GO 23819
23853: POP
23854: POP
// if not list then
23855: LD_VAR 0 5
23859: NOT
23860: IFFALSE 23864
// exit ;
23862: GO 24668
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
23864: LD_VAR 0 12
23868: PUSH
23869: LD_INT 3
23871: EQUAL
23872: PUSH
23873: LD_INT 49
23875: PUSH
23876: LD_VAR 0 5
23880: IN
23881: AND
23882: PUSH
23883: LD_INT 31
23885: PPUSH
23886: LD_VAR 0 16
23890: PPUSH
23891: CALL_OW 321
23895: PUSH
23896: LD_INT 2
23898: EQUAL
23899: AND
23900: IFFALSE 23960
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
23902: LD_INT 22
23904: PUSH
23905: LD_VAR 0 16
23909: PUSH
23910: EMPTY
23911: LIST
23912: LIST
23913: PUSH
23914: LD_INT 35
23916: PUSH
23917: LD_INT 49
23919: PUSH
23920: EMPTY
23921: LIST
23922: LIST
23923: PUSH
23924: LD_INT 91
23926: PUSH
23927: LD_VAR 0 1
23931: PUSH
23932: LD_INT 10
23934: PUSH
23935: EMPTY
23936: LIST
23937: LIST
23938: LIST
23939: PUSH
23940: EMPTY
23941: LIST
23942: LIST
23943: LIST
23944: PPUSH
23945: CALL_OW 69
23949: NOT
23950: IFFALSE 23960
// weapon := ru_time_lapser ;
23952: LD_ADDR_VAR 0 18
23956: PUSH
23957: LD_INT 49
23959: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
23960: LD_VAR 0 12
23964: PUSH
23965: LD_INT 1
23967: PUSH
23968: LD_INT 2
23970: PUSH
23971: EMPTY
23972: LIST
23973: LIST
23974: IN
23975: PUSH
23976: LD_INT 11
23978: PUSH
23979: LD_VAR 0 5
23983: IN
23984: PUSH
23985: LD_INT 30
23987: PUSH
23988: LD_VAR 0 5
23992: IN
23993: OR
23994: AND
23995: PUSH
23996: LD_INT 6
23998: PPUSH
23999: LD_VAR 0 16
24003: PPUSH
24004: CALL_OW 321
24008: PUSH
24009: LD_INT 2
24011: EQUAL
24012: AND
24013: IFFALSE 24178
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24015: LD_INT 22
24017: PUSH
24018: LD_VAR 0 16
24022: PUSH
24023: EMPTY
24024: LIST
24025: LIST
24026: PUSH
24027: LD_INT 2
24029: PUSH
24030: LD_INT 35
24032: PUSH
24033: LD_INT 11
24035: PUSH
24036: EMPTY
24037: LIST
24038: LIST
24039: PUSH
24040: LD_INT 35
24042: PUSH
24043: LD_INT 30
24045: PUSH
24046: EMPTY
24047: LIST
24048: LIST
24049: PUSH
24050: EMPTY
24051: LIST
24052: LIST
24053: LIST
24054: PUSH
24055: LD_INT 91
24057: PUSH
24058: LD_VAR 0 1
24062: PUSH
24063: LD_INT 18
24065: PUSH
24066: EMPTY
24067: LIST
24068: LIST
24069: LIST
24070: PUSH
24071: EMPTY
24072: LIST
24073: LIST
24074: LIST
24075: PPUSH
24076: CALL_OW 69
24080: NOT
24081: PUSH
24082: LD_INT 22
24084: PUSH
24085: LD_VAR 0 16
24089: PUSH
24090: EMPTY
24091: LIST
24092: LIST
24093: PUSH
24094: LD_INT 2
24096: PUSH
24097: LD_INT 30
24099: PUSH
24100: LD_INT 32
24102: PUSH
24103: EMPTY
24104: LIST
24105: LIST
24106: PUSH
24107: LD_INT 30
24109: PUSH
24110: LD_INT 33
24112: PUSH
24113: EMPTY
24114: LIST
24115: LIST
24116: PUSH
24117: EMPTY
24118: LIST
24119: LIST
24120: LIST
24121: PUSH
24122: LD_INT 91
24124: PUSH
24125: LD_VAR 0 1
24129: PUSH
24130: LD_INT 12
24132: PUSH
24133: EMPTY
24134: LIST
24135: LIST
24136: LIST
24137: PUSH
24138: EMPTY
24139: LIST
24140: LIST
24141: LIST
24142: PUSH
24143: EMPTY
24144: LIST
24145: PPUSH
24146: CALL_OW 69
24150: PUSH
24151: LD_INT 2
24153: GREATER
24154: AND
24155: IFFALSE 24178
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24157: LD_ADDR_VAR 0 18
24161: PUSH
24162: LD_INT 11
24164: PUSH
24165: LD_INT 30
24167: PUSH
24168: EMPTY
24169: LIST
24170: LIST
24171: PUSH
24172: LD_VAR 0 12
24176: ARRAY
24177: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24178: LD_VAR 0 18
24182: NOT
24183: PUSH
24184: LD_INT 40
24186: PPUSH
24187: LD_VAR 0 16
24191: PPUSH
24192: CALL_OW 321
24196: PUSH
24197: LD_INT 2
24199: EQUAL
24200: AND
24201: PUSH
24202: LD_INT 7
24204: PUSH
24205: LD_VAR 0 5
24209: IN
24210: PUSH
24211: LD_INT 28
24213: PUSH
24214: LD_VAR 0 5
24218: IN
24219: OR
24220: PUSH
24221: LD_INT 45
24223: PUSH
24224: LD_VAR 0 5
24228: IN
24229: OR
24230: AND
24231: IFFALSE 24485
// begin hex := GetHexInfo ( x , y ) ;
24233: LD_ADDR_VAR 0 4
24237: PUSH
24238: LD_VAR 0 10
24242: PPUSH
24243: LD_VAR 0 11
24247: PPUSH
24248: CALL_OW 546
24252: ST_TO_ADDR
// if hex [ 1 ] then
24253: LD_VAR 0 4
24257: PUSH
24258: LD_INT 1
24260: ARRAY
24261: IFFALSE 24265
// exit ;
24263: GO 24668
// height := hex [ 2 ] ;
24265: LD_ADDR_VAR 0 15
24269: PUSH
24270: LD_VAR 0 4
24274: PUSH
24275: LD_INT 2
24277: ARRAY
24278: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
24279: LD_ADDR_VAR 0 14
24283: PUSH
24284: LD_INT 0
24286: PUSH
24287: LD_INT 2
24289: PUSH
24290: LD_INT 3
24292: PUSH
24293: LD_INT 5
24295: PUSH
24296: EMPTY
24297: LIST
24298: LIST
24299: LIST
24300: LIST
24301: ST_TO_ADDR
// for i in tmp do
24302: LD_ADDR_VAR 0 8
24306: PUSH
24307: LD_VAR 0 14
24311: PUSH
24312: FOR_IN
24313: IFFALSE 24483
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
24315: LD_ADDR_VAR 0 9
24319: PUSH
24320: LD_VAR 0 10
24324: PPUSH
24325: LD_VAR 0 8
24329: PPUSH
24330: LD_INT 5
24332: PPUSH
24333: CALL_OW 272
24337: PUSH
24338: LD_VAR 0 11
24342: PPUSH
24343: LD_VAR 0 8
24347: PPUSH
24348: LD_INT 5
24350: PPUSH
24351: CALL_OW 273
24355: PUSH
24356: EMPTY
24357: LIST
24358: LIST
24359: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24360: LD_VAR 0 9
24364: PUSH
24365: LD_INT 1
24367: ARRAY
24368: PPUSH
24369: LD_VAR 0 9
24373: PUSH
24374: LD_INT 2
24376: ARRAY
24377: PPUSH
24378: CALL_OW 488
24382: IFFALSE 24481
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24384: LD_ADDR_VAR 0 4
24388: PUSH
24389: LD_VAR 0 9
24393: PUSH
24394: LD_INT 1
24396: ARRAY
24397: PPUSH
24398: LD_VAR 0 9
24402: PUSH
24403: LD_INT 2
24405: ARRAY
24406: PPUSH
24407: CALL_OW 546
24411: ST_TO_ADDR
// if hex [ 1 ] then
24412: LD_VAR 0 4
24416: PUSH
24417: LD_INT 1
24419: ARRAY
24420: IFFALSE 24424
// continue ;
24422: GO 24312
// h := hex [ 2 ] ;
24424: LD_ADDR_VAR 0 13
24428: PUSH
24429: LD_VAR 0 4
24433: PUSH
24434: LD_INT 2
24436: ARRAY
24437: ST_TO_ADDR
// if h + 7 < height then
24438: LD_VAR 0 13
24442: PUSH
24443: LD_INT 7
24445: PLUS
24446: PUSH
24447: LD_VAR 0 15
24451: LESS
24452: IFFALSE 24481
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24454: LD_ADDR_VAR 0 18
24458: PUSH
24459: LD_INT 7
24461: PUSH
24462: LD_INT 28
24464: PUSH
24465: LD_INT 45
24467: PUSH
24468: EMPTY
24469: LIST
24470: LIST
24471: LIST
24472: PUSH
24473: LD_VAR 0 12
24477: ARRAY
24478: ST_TO_ADDR
// break ;
24479: GO 24483
// end ; end ; end ;
24481: GO 24312
24483: POP
24484: POP
// end ; if not weapon then
24485: LD_VAR 0 18
24489: NOT
24490: IFFALSE 24550
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24492: LD_ADDR_VAR 0 5
24496: PUSH
24497: LD_VAR 0 5
24501: PUSH
24502: LD_INT 11
24504: PUSH
24505: LD_INT 30
24507: PUSH
24508: LD_INT 49
24510: PUSH
24511: EMPTY
24512: LIST
24513: LIST
24514: LIST
24515: DIFF
24516: ST_TO_ADDR
// if not list then
24517: LD_VAR 0 5
24521: NOT
24522: IFFALSE 24526
// exit ;
24524: GO 24668
// weapon := list [ rand ( 1 , list ) ] ;
24526: LD_ADDR_VAR 0 18
24530: PUSH
24531: LD_VAR 0 5
24535: PUSH
24536: LD_INT 1
24538: PPUSH
24539: LD_VAR 0 5
24543: PPUSH
24544: CALL_OW 12
24548: ARRAY
24549: ST_TO_ADDR
// end ; if weapon then
24550: LD_VAR 0 18
24554: IFFALSE 24668
// begin tmp := CostOfWeapon ( weapon ) ;
24556: LD_ADDR_VAR 0 14
24560: PUSH
24561: LD_VAR 0 18
24565: PPUSH
24566: CALL_OW 451
24570: ST_TO_ADDR
// j := GetBase ( tower ) ;
24571: LD_ADDR_VAR 0 9
24575: PUSH
24576: LD_VAR 0 1
24580: PPUSH
24581: CALL_OW 274
24585: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24586: LD_VAR 0 9
24590: PPUSH
24591: LD_INT 1
24593: PPUSH
24594: CALL_OW 275
24598: PUSH
24599: LD_VAR 0 14
24603: PUSH
24604: LD_INT 1
24606: ARRAY
24607: GREATEREQUAL
24608: PUSH
24609: LD_VAR 0 9
24613: PPUSH
24614: LD_INT 2
24616: PPUSH
24617: CALL_OW 275
24621: PUSH
24622: LD_VAR 0 14
24626: PUSH
24627: LD_INT 2
24629: ARRAY
24630: GREATEREQUAL
24631: AND
24632: PUSH
24633: LD_VAR 0 9
24637: PPUSH
24638: LD_INT 3
24640: PPUSH
24641: CALL_OW 275
24645: PUSH
24646: LD_VAR 0 14
24650: PUSH
24651: LD_INT 3
24653: ARRAY
24654: GREATEREQUAL
24655: AND
24656: IFFALSE 24668
// result := weapon ;
24658: LD_ADDR_VAR 0 3
24662: PUSH
24663: LD_VAR 0 18
24667: ST_TO_ADDR
// end ; end ;
24668: LD_VAR 0 3
24672: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24673: LD_INT 0
24675: PPUSH
24676: PPUSH
// result := true ;
24677: LD_ADDR_VAR 0 3
24681: PUSH
24682: LD_INT 1
24684: ST_TO_ADDR
// if array1 = array2 then
24685: LD_VAR 0 1
24689: PUSH
24690: LD_VAR 0 2
24694: EQUAL
24695: IFFALSE 24755
// begin for i = 1 to array1 do
24697: LD_ADDR_VAR 0 4
24701: PUSH
24702: DOUBLE
24703: LD_INT 1
24705: DEC
24706: ST_TO_ADDR
24707: LD_VAR 0 1
24711: PUSH
24712: FOR_TO
24713: IFFALSE 24751
// if array1 [ i ] <> array2 [ i ] then
24715: LD_VAR 0 1
24719: PUSH
24720: LD_VAR 0 4
24724: ARRAY
24725: PUSH
24726: LD_VAR 0 2
24730: PUSH
24731: LD_VAR 0 4
24735: ARRAY
24736: NONEQUAL
24737: IFFALSE 24749
// begin result := false ;
24739: LD_ADDR_VAR 0 3
24743: PUSH
24744: LD_INT 0
24746: ST_TO_ADDR
// break ;
24747: GO 24751
// end ;
24749: GO 24712
24751: POP
24752: POP
// end else
24753: GO 24763
// result := false ;
24755: LD_ADDR_VAR 0 3
24759: PUSH
24760: LD_INT 0
24762: ST_TO_ADDR
// end ;
24763: LD_VAR 0 3
24767: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
24768: LD_INT 0
24770: PPUSH
24771: PPUSH
24772: PPUSH
// pom := GetBase ( fac ) ;
24773: LD_ADDR_VAR 0 5
24777: PUSH
24778: LD_VAR 0 1
24782: PPUSH
24783: CALL_OW 274
24787: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24788: LD_ADDR_VAR 0 4
24792: PUSH
24793: LD_VAR 0 2
24797: PUSH
24798: LD_INT 1
24800: ARRAY
24801: PPUSH
24802: LD_VAR 0 2
24806: PUSH
24807: LD_INT 2
24809: ARRAY
24810: PPUSH
24811: LD_VAR 0 2
24815: PUSH
24816: LD_INT 3
24818: ARRAY
24819: PPUSH
24820: LD_VAR 0 2
24824: PUSH
24825: LD_INT 4
24827: ARRAY
24828: PPUSH
24829: CALL_OW 449
24833: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
24834: LD_ADDR_VAR 0 3
24838: PUSH
24839: LD_VAR 0 5
24843: PPUSH
24844: LD_INT 1
24846: PPUSH
24847: CALL_OW 275
24851: PUSH
24852: LD_VAR 0 4
24856: PUSH
24857: LD_INT 1
24859: ARRAY
24860: GREATEREQUAL
24861: PUSH
24862: LD_VAR 0 5
24866: PPUSH
24867: LD_INT 2
24869: PPUSH
24870: CALL_OW 275
24874: PUSH
24875: LD_VAR 0 4
24879: PUSH
24880: LD_INT 2
24882: ARRAY
24883: GREATEREQUAL
24884: AND
24885: PUSH
24886: LD_VAR 0 5
24890: PPUSH
24891: LD_INT 3
24893: PPUSH
24894: CALL_OW 275
24898: PUSH
24899: LD_VAR 0 4
24903: PUSH
24904: LD_INT 3
24906: ARRAY
24907: GREATEREQUAL
24908: AND
24909: ST_TO_ADDR
// end ;
24910: LD_VAR 0 3
24914: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
24915: LD_INT 0
24917: PPUSH
24918: PPUSH
24919: PPUSH
24920: PPUSH
// pom := GetBase ( building ) ;
24921: LD_ADDR_VAR 0 3
24925: PUSH
24926: LD_VAR 0 1
24930: PPUSH
24931: CALL_OW 274
24935: ST_TO_ADDR
// if not pom then
24936: LD_VAR 0 3
24940: NOT
24941: IFFALSE 24945
// exit ;
24943: GO 25115
// btype := GetBType ( building ) ;
24945: LD_ADDR_VAR 0 5
24949: PUSH
24950: LD_VAR 0 1
24954: PPUSH
24955: CALL_OW 266
24959: ST_TO_ADDR
// if btype = b_armoury then
24960: LD_VAR 0 5
24964: PUSH
24965: LD_INT 4
24967: EQUAL
24968: IFFALSE 24978
// btype := b_barracks ;
24970: LD_ADDR_VAR 0 5
24974: PUSH
24975: LD_INT 5
24977: ST_TO_ADDR
// if btype = b_depot then
24978: LD_VAR 0 5
24982: PUSH
24983: LD_INT 0
24985: EQUAL
24986: IFFALSE 24996
// btype := b_warehouse ;
24988: LD_ADDR_VAR 0 5
24992: PUSH
24993: LD_INT 1
24995: ST_TO_ADDR
// if btype = b_workshop then
24996: LD_VAR 0 5
25000: PUSH
25001: LD_INT 2
25003: EQUAL
25004: IFFALSE 25014
// btype := b_factory ;
25006: LD_ADDR_VAR 0 5
25010: PUSH
25011: LD_INT 3
25013: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25014: LD_ADDR_VAR 0 4
25018: PUSH
25019: LD_VAR 0 5
25023: PPUSH
25024: LD_VAR 0 1
25028: PPUSH
25029: CALL_OW 248
25033: PPUSH
25034: CALL_OW 450
25038: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25039: LD_ADDR_VAR 0 2
25043: PUSH
25044: LD_VAR 0 3
25048: PPUSH
25049: LD_INT 1
25051: PPUSH
25052: CALL_OW 275
25056: PUSH
25057: LD_VAR 0 4
25061: PUSH
25062: LD_INT 1
25064: ARRAY
25065: GREATEREQUAL
25066: PUSH
25067: LD_VAR 0 3
25071: PPUSH
25072: LD_INT 2
25074: PPUSH
25075: CALL_OW 275
25079: PUSH
25080: LD_VAR 0 4
25084: PUSH
25085: LD_INT 2
25087: ARRAY
25088: GREATEREQUAL
25089: AND
25090: PUSH
25091: LD_VAR 0 3
25095: PPUSH
25096: LD_INT 3
25098: PPUSH
25099: CALL_OW 275
25103: PUSH
25104: LD_VAR 0 4
25108: PUSH
25109: LD_INT 3
25111: ARRAY
25112: GREATEREQUAL
25113: AND
25114: ST_TO_ADDR
// end ;
25115: LD_VAR 0 2
25119: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25120: LD_INT 0
25122: PPUSH
25123: PPUSH
25124: PPUSH
// pom := GetBase ( building ) ;
25125: LD_ADDR_VAR 0 4
25129: PUSH
25130: LD_VAR 0 1
25134: PPUSH
25135: CALL_OW 274
25139: ST_TO_ADDR
// if not pom then
25140: LD_VAR 0 4
25144: NOT
25145: IFFALSE 25149
// exit ;
25147: GO 25250
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25149: LD_ADDR_VAR 0 5
25153: PUSH
25154: LD_VAR 0 2
25158: PPUSH
25159: LD_VAR 0 1
25163: PPUSH
25164: CALL_OW 248
25168: PPUSH
25169: CALL_OW 450
25173: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25174: LD_ADDR_VAR 0 3
25178: PUSH
25179: LD_VAR 0 4
25183: PPUSH
25184: LD_INT 1
25186: PPUSH
25187: CALL_OW 275
25191: PUSH
25192: LD_VAR 0 5
25196: PUSH
25197: LD_INT 1
25199: ARRAY
25200: GREATEREQUAL
25201: PUSH
25202: LD_VAR 0 4
25206: PPUSH
25207: LD_INT 2
25209: PPUSH
25210: CALL_OW 275
25214: PUSH
25215: LD_VAR 0 5
25219: PUSH
25220: LD_INT 2
25222: ARRAY
25223: GREATEREQUAL
25224: AND
25225: PUSH
25226: LD_VAR 0 4
25230: PPUSH
25231: LD_INT 3
25233: PPUSH
25234: CALL_OW 275
25238: PUSH
25239: LD_VAR 0 5
25243: PUSH
25244: LD_INT 3
25246: ARRAY
25247: GREATEREQUAL
25248: AND
25249: ST_TO_ADDR
// end ;
25250: LD_VAR 0 3
25254: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
25255: LD_INT 0
25257: PPUSH
25258: PPUSH
25259: PPUSH
25260: PPUSH
25261: PPUSH
25262: PPUSH
25263: PPUSH
25264: PPUSH
25265: PPUSH
25266: PPUSH
// result := false ;
25267: LD_ADDR_VAR 0 6
25271: PUSH
25272: LD_INT 0
25274: ST_TO_ADDR
// if not base or not btype or not x or not y then
25275: LD_VAR 0 1
25279: NOT
25280: PUSH
25281: LD_VAR 0 2
25285: NOT
25286: OR
25287: PUSH
25288: LD_VAR 0 3
25292: NOT
25293: OR
25294: PUSH
25295: LD_VAR 0 4
25299: NOT
25300: OR
25301: IFFALSE 25305
// exit ;
25303: GO 25914
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
25305: LD_ADDR_VAR 0 12
25309: PUSH
25310: LD_VAR 0 2
25314: PPUSH
25315: LD_VAR 0 3
25319: PPUSH
25320: LD_VAR 0 4
25324: PPUSH
25325: LD_VAR 0 5
25329: PPUSH
25330: LD_VAR 0 1
25334: PUSH
25335: LD_INT 1
25337: ARRAY
25338: PPUSH
25339: CALL_OW 248
25343: PPUSH
25344: LD_INT 0
25346: PPUSH
25347: CALL 26751 0 6
25351: ST_TO_ADDR
// if not hexes then
25352: LD_VAR 0 12
25356: NOT
25357: IFFALSE 25361
// exit ;
25359: GO 25914
// for i = 1 to hexes do
25361: LD_ADDR_VAR 0 7
25365: PUSH
25366: DOUBLE
25367: LD_INT 1
25369: DEC
25370: ST_TO_ADDR
25371: LD_VAR 0 12
25375: PUSH
25376: FOR_TO
25377: IFFALSE 25912
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25379: LD_ADDR_VAR 0 11
25383: PUSH
25384: LD_VAR 0 12
25388: PUSH
25389: LD_VAR 0 7
25393: ARRAY
25394: PUSH
25395: LD_INT 1
25397: ARRAY
25398: PPUSH
25399: LD_VAR 0 12
25403: PUSH
25404: LD_VAR 0 7
25408: ARRAY
25409: PUSH
25410: LD_INT 2
25412: ARRAY
25413: PPUSH
25414: CALL_OW 428
25418: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25419: LD_VAR 0 12
25423: PUSH
25424: LD_VAR 0 7
25428: ARRAY
25429: PUSH
25430: LD_INT 1
25432: ARRAY
25433: PPUSH
25434: LD_VAR 0 12
25438: PUSH
25439: LD_VAR 0 7
25443: ARRAY
25444: PUSH
25445: LD_INT 2
25447: ARRAY
25448: PPUSH
25449: CALL_OW 351
25453: PUSH
25454: LD_VAR 0 12
25458: PUSH
25459: LD_VAR 0 7
25463: ARRAY
25464: PUSH
25465: LD_INT 1
25467: ARRAY
25468: PPUSH
25469: LD_VAR 0 12
25473: PUSH
25474: LD_VAR 0 7
25478: ARRAY
25479: PUSH
25480: LD_INT 2
25482: ARRAY
25483: PPUSH
25484: CALL_OW 488
25488: NOT
25489: OR
25490: PUSH
25491: LD_VAR 0 11
25495: PPUSH
25496: CALL_OW 247
25500: PUSH
25501: LD_INT 3
25503: EQUAL
25504: OR
25505: IFFALSE 25511
// exit ;
25507: POP
25508: POP
25509: GO 25914
// if not tmp or not tmp in base then
25511: LD_VAR 0 11
25515: NOT
25516: PUSH
25517: LD_VAR 0 11
25521: PUSH
25522: LD_VAR 0 1
25526: IN
25527: NOT
25528: OR
25529: IFFALSE 25533
// continue ;
25531: GO 25376
// result := true ;
25533: LD_ADDR_VAR 0 6
25537: PUSH
25538: LD_INT 1
25540: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25541: LD_ADDR_VAR 0 15
25545: PUSH
25546: LD_VAR 0 1
25550: PPUSH
25551: LD_INT 22
25553: PUSH
25554: LD_VAR 0 11
25558: PPUSH
25559: CALL_OW 255
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: PUSH
25568: LD_INT 2
25570: PUSH
25571: LD_INT 30
25573: PUSH
25574: LD_INT 0
25576: PUSH
25577: EMPTY
25578: LIST
25579: LIST
25580: PUSH
25581: LD_INT 30
25583: PUSH
25584: LD_INT 1
25586: PUSH
25587: EMPTY
25588: LIST
25589: LIST
25590: PUSH
25591: EMPTY
25592: LIST
25593: LIST
25594: LIST
25595: PUSH
25596: EMPTY
25597: LIST
25598: LIST
25599: PPUSH
25600: CALL_OW 72
25604: ST_TO_ADDR
// if dep then
25605: LD_VAR 0 15
25609: IFFALSE 25745
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
25611: LD_ADDR_VAR 0 14
25615: PUSH
25616: LD_VAR 0 15
25620: PUSH
25621: LD_INT 1
25623: ARRAY
25624: PPUSH
25625: CALL_OW 250
25629: PPUSH
25630: LD_VAR 0 15
25634: PUSH
25635: LD_INT 1
25637: ARRAY
25638: PPUSH
25639: CALL_OW 254
25643: PPUSH
25644: LD_INT 5
25646: PPUSH
25647: CALL_OW 272
25651: PUSH
25652: LD_VAR 0 15
25656: PUSH
25657: LD_INT 1
25659: ARRAY
25660: PPUSH
25661: CALL_OW 251
25665: PPUSH
25666: LD_VAR 0 15
25670: PUSH
25671: LD_INT 1
25673: ARRAY
25674: PPUSH
25675: CALL_OW 254
25679: PPUSH
25680: LD_INT 5
25682: PPUSH
25683: CALL_OW 273
25687: PUSH
25688: EMPTY
25689: LIST
25690: LIST
25691: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
25692: LD_VAR 0 14
25696: PUSH
25697: LD_INT 1
25699: ARRAY
25700: PPUSH
25701: LD_VAR 0 14
25705: PUSH
25706: LD_INT 2
25708: ARRAY
25709: PPUSH
25710: CALL_OW 488
25714: IFFALSE 25745
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
25716: LD_VAR 0 11
25720: PPUSH
25721: LD_VAR 0 14
25725: PUSH
25726: LD_INT 1
25728: ARRAY
25729: PPUSH
25730: LD_VAR 0 14
25734: PUSH
25735: LD_INT 2
25737: ARRAY
25738: PPUSH
25739: CALL_OW 111
// continue ;
25743: GO 25376
// end ; end ; r := GetDir ( tmp ) ;
25745: LD_ADDR_VAR 0 13
25749: PUSH
25750: LD_VAR 0 11
25754: PPUSH
25755: CALL_OW 254
25759: ST_TO_ADDR
// if r = 5 then
25760: LD_VAR 0 13
25764: PUSH
25765: LD_INT 5
25767: EQUAL
25768: IFFALSE 25778
// r := 0 ;
25770: LD_ADDR_VAR 0 13
25774: PUSH
25775: LD_INT 0
25777: ST_TO_ADDR
// for j = r to 5 do
25778: LD_ADDR_VAR 0 8
25782: PUSH
25783: DOUBLE
25784: LD_VAR 0 13
25788: DEC
25789: ST_TO_ADDR
25790: LD_INT 5
25792: PUSH
25793: FOR_TO
25794: IFFALSE 25908
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
25796: LD_ADDR_VAR 0 9
25800: PUSH
25801: LD_VAR 0 11
25805: PPUSH
25806: CALL_OW 250
25810: PPUSH
25811: LD_VAR 0 8
25815: PPUSH
25816: LD_INT 2
25818: PPUSH
25819: CALL_OW 272
25823: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
25824: LD_ADDR_VAR 0 10
25828: PUSH
25829: LD_VAR 0 11
25833: PPUSH
25834: CALL_OW 251
25838: PPUSH
25839: LD_VAR 0 8
25843: PPUSH
25844: LD_INT 2
25846: PPUSH
25847: CALL_OW 273
25851: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
25852: LD_VAR 0 9
25856: PPUSH
25857: LD_VAR 0 10
25861: PPUSH
25862: CALL_OW 488
25866: PUSH
25867: LD_VAR 0 9
25871: PPUSH
25872: LD_VAR 0 10
25876: PPUSH
25877: CALL_OW 428
25881: NOT
25882: AND
25883: IFFALSE 25906
// begin ComMoveXY ( tmp , _x , _y ) ;
25885: LD_VAR 0 11
25889: PPUSH
25890: LD_VAR 0 9
25894: PPUSH
25895: LD_VAR 0 10
25899: PPUSH
25900: CALL_OW 111
// break ;
25904: GO 25908
// end ; end ;
25906: GO 25793
25908: POP
25909: POP
// end ;
25910: GO 25376
25912: POP
25913: POP
// end ;
25914: LD_VAR 0 6
25918: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
25919: LD_INT 0
25921: PPUSH
25922: PPUSH
25923: PPUSH
25924: PPUSH
25925: PPUSH
25926: PPUSH
25927: PPUSH
25928: PPUSH
25929: PPUSH
25930: PPUSH
// result := false ;
25931: LD_ADDR_VAR 0 6
25935: PUSH
25936: LD_INT 0
25938: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
25939: LD_VAR 0 1
25943: NOT
25944: PUSH
25945: LD_VAR 0 1
25949: PPUSH
25950: CALL_OW 266
25954: PUSH
25955: LD_INT 0
25957: PUSH
25958: LD_INT 1
25960: PUSH
25961: EMPTY
25962: LIST
25963: LIST
25964: IN
25965: NOT
25966: OR
25967: PUSH
25968: LD_VAR 0 2
25972: NOT
25973: OR
25974: PUSH
25975: LD_VAR 0 5
25979: PUSH
25980: LD_INT 0
25982: PUSH
25983: LD_INT 1
25985: PUSH
25986: LD_INT 2
25988: PUSH
25989: LD_INT 3
25991: PUSH
25992: LD_INT 4
25994: PUSH
25995: LD_INT 5
25997: PUSH
25998: EMPTY
25999: LIST
26000: LIST
26001: LIST
26002: LIST
26003: LIST
26004: LIST
26005: IN
26006: NOT
26007: OR
26008: PUSH
26009: LD_VAR 0 3
26013: PPUSH
26014: LD_VAR 0 4
26018: PPUSH
26019: CALL_OW 488
26023: NOT
26024: OR
26025: IFFALSE 26029
// exit ;
26027: GO 26746
// pom := GetBase ( depot ) ;
26029: LD_ADDR_VAR 0 10
26033: PUSH
26034: LD_VAR 0 1
26038: PPUSH
26039: CALL_OW 274
26043: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26044: LD_ADDR_VAR 0 11
26048: PUSH
26049: LD_VAR 0 2
26053: PPUSH
26054: LD_VAR 0 1
26058: PPUSH
26059: CALL_OW 248
26063: PPUSH
26064: CALL_OW 450
26068: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26069: LD_VAR 0 10
26073: PPUSH
26074: LD_INT 1
26076: PPUSH
26077: CALL_OW 275
26081: PUSH
26082: LD_VAR 0 11
26086: PUSH
26087: LD_INT 1
26089: ARRAY
26090: GREATEREQUAL
26091: PUSH
26092: LD_VAR 0 10
26096: PPUSH
26097: LD_INT 2
26099: PPUSH
26100: CALL_OW 275
26104: PUSH
26105: LD_VAR 0 11
26109: PUSH
26110: LD_INT 2
26112: ARRAY
26113: GREATEREQUAL
26114: AND
26115: PUSH
26116: LD_VAR 0 10
26120: PPUSH
26121: LD_INT 3
26123: PPUSH
26124: CALL_OW 275
26128: PUSH
26129: LD_VAR 0 11
26133: PUSH
26134: LD_INT 3
26136: ARRAY
26137: GREATEREQUAL
26138: AND
26139: NOT
26140: IFFALSE 26144
// exit ;
26142: GO 26746
// if GetBType ( depot ) = b_depot then
26144: LD_VAR 0 1
26148: PPUSH
26149: CALL_OW 266
26153: PUSH
26154: LD_INT 0
26156: EQUAL
26157: IFFALSE 26169
// dist := 28 else
26159: LD_ADDR_VAR 0 14
26163: PUSH
26164: LD_INT 28
26166: ST_TO_ADDR
26167: GO 26177
// dist := 36 ;
26169: LD_ADDR_VAR 0 14
26173: PUSH
26174: LD_INT 36
26176: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26177: LD_VAR 0 1
26181: PPUSH
26182: LD_VAR 0 3
26186: PPUSH
26187: LD_VAR 0 4
26191: PPUSH
26192: CALL_OW 297
26196: PUSH
26197: LD_VAR 0 14
26201: GREATER
26202: IFFALSE 26206
// exit ;
26204: GO 26746
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
26206: LD_ADDR_VAR 0 12
26210: PUSH
26211: LD_VAR 0 2
26215: PPUSH
26216: LD_VAR 0 3
26220: PPUSH
26221: LD_VAR 0 4
26225: PPUSH
26226: LD_VAR 0 5
26230: PPUSH
26231: LD_VAR 0 1
26235: PPUSH
26236: CALL_OW 248
26240: PPUSH
26241: LD_INT 0
26243: PPUSH
26244: CALL 26751 0 6
26248: ST_TO_ADDR
// if not hexes then
26249: LD_VAR 0 12
26253: NOT
26254: IFFALSE 26258
// exit ;
26256: GO 26746
// hex := GetHexInfo ( x , y ) ;
26258: LD_ADDR_VAR 0 15
26262: PUSH
26263: LD_VAR 0 3
26267: PPUSH
26268: LD_VAR 0 4
26272: PPUSH
26273: CALL_OW 546
26277: ST_TO_ADDR
// if hex [ 1 ] then
26278: LD_VAR 0 15
26282: PUSH
26283: LD_INT 1
26285: ARRAY
26286: IFFALSE 26290
// exit ;
26288: GO 26746
// height := hex [ 2 ] ;
26290: LD_ADDR_VAR 0 13
26294: PUSH
26295: LD_VAR 0 15
26299: PUSH
26300: LD_INT 2
26302: ARRAY
26303: ST_TO_ADDR
// for i = 1 to hexes do
26304: LD_ADDR_VAR 0 7
26308: PUSH
26309: DOUBLE
26310: LD_INT 1
26312: DEC
26313: ST_TO_ADDR
26314: LD_VAR 0 12
26318: PUSH
26319: FOR_TO
26320: IFFALSE 26650
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
26322: LD_VAR 0 12
26326: PUSH
26327: LD_VAR 0 7
26331: ARRAY
26332: PUSH
26333: LD_INT 1
26335: ARRAY
26336: PPUSH
26337: LD_VAR 0 12
26341: PUSH
26342: LD_VAR 0 7
26346: ARRAY
26347: PUSH
26348: LD_INT 2
26350: ARRAY
26351: PPUSH
26352: CALL_OW 488
26356: NOT
26357: PUSH
26358: LD_VAR 0 12
26362: PUSH
26363: LD_VAR 0 7
26367: ARRAY
26368: PUSH
26369: LD_INT 1
26371: ARRAY
26372: PPUSH
26373: LD_VAR 0 12
26377: PUSH
26378: LD_VAR 0 7
26382: ARRAY
26383: PUSH
26384: LD_INT 2
26386: ARRAY
26387: PPUSH
26388: CALL_OW 428
26392: PUSH
26393: LD_INT 0
26395: GREATER
26396: OR
26397: PUSH
26398: LD_VAR 0 12
26402: PUSH
26403: LD_VAR 0 7
26407: ARRAY
26408: PUSH
26409: LD_INT 1
26411: ARRAY
26412: PPUSH
26413: LD_VAR 0 12
26417: PUSH
26418: LD_VAR 0 7
26422: ARRAY
26423: PUSH
26424: LD_INT 2
26426: ARRAY
26427: PPUSH
26428: CALL_OW 351
26432: OR
26433: IFFALSE 26439
// exit ;
26435: POP
26436: POP
26437: GO 26746
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26439: LD_ADDR_VAR 0 8
26443: PUSH
26444: LD_VAR 0 12
26448: PUSH
26449: LD_VAR 0 7
26453: ARRAY
26454: PUSH
26455: LD_INT 1
26457: ARRAY
26458: PPUSH
26459: LD_VAR 0 12
26463: PUSH
26464: LD_VAR 0 7
26468: ARRAY
26469: PUSH
26470: LD_INT 2
26472: ARRAY
26473: PPUSH
26474: CALL_OW 546
26478: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
26479: LD_VAR 0 8
26483: PUSH
26484: LD_INT 1
26486: ARRAY
26487: PUSH
26488: LD_VAR 0 8
26492: PUSH
26493: LD_INT 2
26495: ARRAY
26496: PUSH
26497: LD_VAR 0 13
26501: PUSH
26502: LD_INT 2
26504: PLUS
26505: GREATER
26506: OR
26507: PUSH
26508: LD_VAR 0 8
26512: PUSH
26513: LD_INT 2
26515: ARRAY
26516: PUSH
26517: LD_VAR 0 13
26521: PUSH
26522: LD_INT 2
26524: MINUS
26525: LESS
26526: OR
26527: PUSH
26528: LD_VAR 0 8
26532: PUSH
26533: LD_INT 3
26535: ARRAY
26536: PUSH
26537: LD_INT 0
26539: PUSH
26540: LD_INT 8
26542: PUSH
26543: LD_INT 9
26545: PUSH
26546: LD_INT 10
26548: PUSH
26549: LD_INT 11
26551: PUSH
26552: LD_INT 12
26554: PUSH
26555: LD_INT 13
26557: PUSH
26558: LD_INT 16
26560: PUSH
26561: LD_INT 17
26563: PUSH
26564: LD_INT 18
26566: PUSH
26567: LD_INT 19
26569: PUSH
26570: LD_INT 20
26572: PUSH
26573: LD_INT 21
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: LIST
26580: LIST
26581: LIST
26582: LIST
26583: LIST
26584: LIST
26585: LIST
26586: LIST
26587: LIST
26588: LIST
26589: LIST
26590: IN
26591: NOT
26592: OR
26593: PUSH
26594: LD_VAR 0 8
26598: PUSH
26599: LD_INT 5
26601: ARRAY
26602: NOT
26603: OR
26604: PUSH
26605: LD_VAR 0 8
26609: PUSH
26610: LD_INT 6
26612: ARRAY
26613: PUSH
26614: LD_INT 1
26616: PUSH
26617: LD_INT 2
26619: PUSH
26620: LD_INT 7
26622: PUSH
26623: LD_INT 9
26625: PUSH
26626: LD_INT 10
26628: PUSH
26629: LD_INT 11
26631: PUSH
26632: EMPTY
26633: LIST
26634: LIST
26635: LIST
26636: LIST
26637: LIST
26638: LIST
26639: IN
26640: NOT
26641: OR
26642: IFFALSE 26648
// exit ;
26644: POP
26645: POP
26646: GO 26746
// end ;
26648: GO 26319
26650: POP
26651: POP
// side := GetSide ( depot ) ;
26652: LD_ADDR_VAR 0 9
26656: PUSH
26657: LD_VAR 0 1
26661: PPUSH
26662: CALL_OW 255
26666: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
26667: LD_VAR 0 9
26671: PPUSH
26672: LD_VAR 0 3
26676: PPUSH
26677: LD_VAR 0 4
26681: PPUSH
26682: LD_INT 20
26684: PPUSH
26685: CALL 19400 0 4
26689: PUSH
26690: LD_INT 4
26692: ARRAY
26693: IFFALSE 26697
// exit ;
26695: GO 26746
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
26697: LD_VAR 0 2
26701: PUSH
26702: LD_INT 29
26704: PUSH
26705: LD_INT 30
26707: PUSH
26708: EMPTY
26709: LIST
26710: LIST
26711: IN
26712: PUSH
26713: LD_VAR 0 3
26717: PPUSH
26718: LD_VAR 0 4
26722: PPUSH
26723: LD_VAR 0 9
26727: PPUSH
26728: CALL_OW 440
26732: NOT
26733: AND
26734: IFFALSE 26738
// exit ;
26736: GO 26746
// result := true ;
26738: LD_ADDR_VAR 0 6
26742: PUSH
26743: LD_INT 1
26745: ST_TO_ADDR
// end ;
26746: LD_VAR 0 6
26750: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
26751: LD_INT 0
26753: PPUSH
26754: PPUSH
26755: PPUSH
26756: PPUSH
26757: PPUSH
26758: PPUSH
26759: PPUSH
26760: PPUSH
26761: PPUSH
26762: PPUSH
26763: PPUSH
26764: PPUSH
26765: PPUSH
26766: PPUSH
26767: PPUSH
26768: PPUSH
26769: PPUSH
26770: PPUSH
26771: PPUSH
26772: PPUSH
26773: PPUSH
26774: PPUSH
26775: PPUSH
26776: PPUSH
26777: PPUSH
26778: PPUSH
26779: PPUSH
26780: PPUSH
26781: PPUSH
26782: PPUSH
26783: PPUSH
26784: PPUSH
26785: PPUSH
26786: PPUSH
26787: PPUSH
26788: PPUSH
26789: PPUSH
26790: PPUSH
26791: PPUSH
26792: PPUSH
26793: PPUSH
26794: PPUSH
26795: PPUSH
26796: PPUSH
26797: PPUSH
26798: PPUSH
26799: PPUSH
26800: PPUSH
26801: PPUSH
26802: PPUSH
26803: PPUSH
26804: PPUSH
26805: PPUSH
26806: PPUSH
26807: PPUSH
26808: PPUSH
26809: PPUSH
26810: PPUSH
// result = [ ] ;
26811: LD_ADDR_VAR 0 7
26815: PUSH
26816: EMPTY
26817: ST_TO_ADDR
// temp_list = [ ] ;
26818: LD_ADDR_VAR 0 9
26822: PUSH
26823: EMPTY
26824: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
26825: LD_VAR 0 4
26829: PUSH
26830: LD_INT 0
26832: PUSH
26833: LD_INT 1
26835: PUSH
26836: LD_INT 2
26838: PUSH
26839: LD_INT 3
26841: PUSH
26842: LD_INT 4
26844: PUSH
26845: LD_INT 5
26847: PUSH
26848: EMPTY
26849: LIST
26850: LIST
26851: LIST
26852: LIST
26853: LIST
26854: LIST
26855: IN
26856: NOT
26857: PUSH
26858: LD_VAR 0 1
26862: PUSH
26863: LD_INT 0
26865: PUSH
26866: LD_INT 1
26868: PUSH
26869: EMPTY
26870: LIST
26871: LIST
26872: IN
26873: PUSH
26874: LD_VAR 0 5
26878: PUSH
26879: LD_INT 1
26881: PUSH
26882: LD_INT 2
26884: PUSH
26885: LD_INT 3
26887: PUSH
26888: EMPTY
26889: LIST
26890: LIST
26891: LIST
26892: IN
26893: NOT
26894: AND
26895: OR
26896: IFFALSE 26900
// exit ;
26898: GO 45291
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
26900: LD_VAR 0 1
26904: PUSH
26905: LD_INT 6
26907: PUSH
26908: LD_INT 7
26910: PUSH
26911: LD_INT 8
26913: PUSH
26914: LD_INT 13
26916: PUSH
26917: LD_INT 12
26919: PUSH
26920: LD_INT 15
26922: PUSH
26923: LD_INT 11
26925: PUSH
26926: LD_INT 14
26928: PUSH
26929: LD_INT 10
26931: PUSH
26932: EMPTY
26933: LIST
26934: LIST
26935: LIST
26936: LIST
26937: LIST
26938: LIST
26939: LIST
26940: LIST
26941: LIST
26942: IN
26943: IFFALSE 26953
// btype = b_lab ;
26945: LD_ADDR_VAR 0 1
26949: PUSH
26950: LD_INT 6
26952: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
26953: LD_VAR 0 6
26957: PUSH
26958: LD_INT 0
26960: PUSH
26961: LD_INT 1
26963: PUSH
26964: LD_INT 2
26966: PUSH
26967: EMPTY
26968: LIST
26969: LIST
26970: LIST
26971: IN
26972: NOT
26973: PUSH
26974: LD_VAR 0 1
26978: PUSH
26979: LD_INT 0
26981: PUSH
26982: LD_INT 1
26984: PUSH
26985: LD_INT 2
26987: PUSH
26988: LD_INT 3
26990: PUSH
26991: LD_INT 6
26993: PUSH
26994: LD_INT 36
26996: PUSH
26997: LD_INT 4
26999: PUSH
27000: LD_INT 5
27002: PUSH
27003: LD_INT 31
27005: PUSH
27006: LD_INT 32
27008: PUSH
27009: LD_INT 33
27011: PUSH
27012: EMPTY
27013: LIST
27014: LIST
27015: LIST
27016: LIST
27017: LIST
27018: LIST
27019: LIST
27020: LIST
27021: LIST
27022: LIST
27023: LIST
27024: IN
27025: NOT
27026: PUSH
27027: LD_VAR 0 6
27031: PUSH
27032: LD_INT 1
27034: EQUAL
27035: AND
27036: OR
27037: PUSH
27038: LD_VAR 0 1
27042: PUSH
27043: LD_INT 2
27045: PUSH
27046: LD_INT 3
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: IN
27053: NOT
27054: PUSH
27055: LD_VAR 0 6
27059: PUSH
27060: LD_INT 2
27062: EQUAL
27063: AND
27064: OR
27065: IFFALSE 27075
// mode = 0 ;
27067: LD_ADDR_VAR 0 6
27071: PUSH
27072: LD_INT 0
27074: ST_TO_ADDR
// case mode of 0 :
27075: LD_VAR 0 6
27079: PUSH
27080: LD_INT 0
27082: DOUBLE
27083: EQUAL
27084: IFTRUE 27088
27086: GO 38541
27088: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27089: LD_ADDR_VAR 0 11
27093: PUSH
27094: LD_INT 0
27096: PUSH
27097: LD_INT 0
27099: PUSH
27100: EMPTY
27101: LIST
27102: LIST
27103: PUSH
27104: LD_INT 0
27106: PUSH
27107: LD_INT 1
27109: NEG
27110: PUSH
27111: EMPTY
27112: LIST
27113: LIST
27114: PUSH
27115: LD_INT 1
27117: PUSH
27118: LD_INT 0
27120: PUSH
27121: EMPTY
27122: LIST
27123: LIST
27124: PUSH
27125: LD_INT 1
27127: PUSH
27128: LD_INT 1
27130: PUSH
27131: EMPTY
27132: LIST
27133: LIST
27134: PUSH
27135: LD_INT 0
27137: PUSH
27138: LD_INT 1
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: PUSH
27145: LD_INT 1
27147: NEG
27148: PUSH
27149: LD_INT 0
27151: PUSH
27152: EMPTY
27153: LIST
27154: LIST
27155: PUSH
27156: LD_INT 1
27158: NEG
27159: PUSH
27160: LD_INT 1
27162: NEG
27163: PUSH
27164: EMPTY
27165: LIST
27166: LIST
27167: PUSH
27168: LD_INT 1
27170: NEG
27171: PUSH
27172: LD_INT 2
27174: NEG
27175: PUSH
27176: EMPTY
27177: LIST
27178: LIST
27179: PUSH
27180: LD_INT 0
27182: PUSH
27183: LD_INT 2
27185: NEG
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: PUSH
27191: LD_INT 1
27193: PUSH
27194: LD_INT 1
27196: NEG
27197: PUSH
27198: EMPTY
27199: LIST
27200: LIST
27201: PUSH
27202: LD_INT 1
27204: PUSH
27205: LD_INT 2
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: PUSH
27212: LD_INT 0
27214: PUSH
27215: LD_INT 2
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: PUSH
27222: LD_INT 1
27224: NEG
27225: PUSH
27226: LD_INT 1
27228: PUSH
27229: EMPTY
27230: LIST
27231: LIST
27232: PUSH
27233: LD_INT 1
27235: PUSH
27236: LD_INT 3
27238: PUSH
27239: EMPTY
27240: LIST
27241: LIST
27242: PUSH
27243: LD_INT 0
27245: PUSH
27246: LD_INT 3
27248: PUSH
27249: EMPTY
27250: LIST
27251: LIST
27252: PUSH
27253: LD_INT 1
27255: NEG
27256: PUSH
27257: LD_INT 2
27259: PUSH
27260: EMPTY
27261: LIST
27262: LIST
27263: PUSH
27264: EMPTY
27265: LIST
27266: LIST
27267: LIST
27268: LIST
27269: LIST
27270: LIST
27271: LIST
27272: LIST
27273: LIST
27274: LIST
27275: LIST
27276: LIST
27277: LIST
27278: LIST
27279: LIST
27280: LIST
27281: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
27282: LD_ADDR_VAR 0 12
27286: PUSH
27287: LD_INT 0
27289: PUSH
27290: LD_INT 0
27292: PUSH
27293: EMPTY
27294: LIST
27295: LIST
27296: PUSH
27297: LD_INT 0
27299: PUSH
27300: LD_INT 1
27302: NEG
27303: PUSH
27304: EMPTY
27305: LIST
27306: LIST
27307: PUSH
27308: LD_INT 1
27310: PUSH
27311: LD_INT 0
27313: PUSH
27314: EMPTY
27315: LIST
27316: LIST
27317: PUSH
27318: LD_INT 1
27320: PUSH
27321: LD_INT 1
27323: PUSH
27324: EMPTY
27325: LIST
27326: LIST
27327: PUSH
27328: LD_INT 0
27330: PUSH
27331: LD_INT 1
27333: PUSH
27334: EMPTY
27335: LIST
27336: LIST
27337: PUSH
27338: LD_INT 1
27340: NEG
27341: PUSH
27342: LD_INT 0
27344: PUSH
27345: EMPTY
27346: LIST
27347: LIST
27348: PUSH
27349: LD_INT 1
27351: NEG
27352: PUSH
27353: LD_INT 1
27355: NEG
27356: PUSH
27357: EMPTY
27358: LIST
27359: LIST
27360: PUSH
27361: LD_INT 1
27363: PUSH
27364: LD_INT 1
27366: NEG
27367: PUSH
27368: EMPTY
27369: LIST
27370: LIST
27371: PUSH
27372: LD_INT 2
27374: PUSH
27375: LD_INT 0
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: PUSH
27382: LD_INT 2
27384: PUSH
27385: LD_INT 1
27387: PUSH
27388: EMPTY
27389: LIST
27390: LIST
27391: PUSH
27392: LD_INT 1
27394: NEG
27395: PUSH
27396: LD_INT 1
27398: PUSH
27399: EMPTY
27400: LIST
27401: LIST
27402: PUSH
27403: LD_INT 2
27405: NEG
27406: PUSH
27407: LD_INT 0
27409: PUSH
27410: EMPTY
27411: LIST
27412: LIST
27413: PUSH
27414: LD_INT 2
27416: NEG
27417: PUSH
27418: LD_INT 1
27420: NEG
27421: PUSH
27422: EMPTY
27423: LIST
27424: LIST
27425: PUSH
27426: LD_INT 2
27428: NEG
27429: PUSH
27430: LD_INT 1
27432: PUSH
27433: EMPTY
27434: LIST
27435: LIST
27436: PUSH
27437: LD_INT 3
27439: NEG
27440: PUSH
27441: LD_INT 0
27443: PUSH
27444: EMPTY
27445: LIST
27446: LIST
27447: PUSH
27448: LD_INT 3
27450: NEG
27451: PUSH
27452: LD_INT 1
27454: NEG
27455: PUSH
27456: EMPTY
27457: LIST
27458: LIST
27459: PUSH
27460: EMPTY
27461: LIST
27462: LIST
27463: LIST
27464: LIST
27465: LIST
27466: LIST
27467: LIST
27468: LIST
27469: LIST
27470: LIST
27471: LIST
27472: LIST
27473: LIST
27474: LIST
27475: LIST
27476: LIST
27477: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
27478: LD_ADDR_VAR 0 13
27482: PUSH
27483: LD_INT 0
27485: PUSH
27486: LD_INT 0
27488: PUSH
27489: EMPTY
27490: LIST
27491: LIST
27492: PUSH
27493: LD_INT 0
27495: PUSH
27496: LD_INT 1
27498: NEG
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: LD_INT 1
27506: PUSH
27507: LD_INT 0
27509: PUSH
27510: EMPTY
27511: LIST
27512: LIST
27513: PUSH
27514: LD_INT 1
27516: PUSH
27517: LD_INT 1
27519: PUSH
27520: EMPTY
27521: LIST
27522: LIST
27523: PUSH
27524: LD_INT 0
27526: PUSH
27527: LD_INT 1
27529: PUSH
27530: EMPTY
27531: LIST
27532: LIST
27533: PUSH
27534: LD_INT 1
27536: NEG
27537: PUSH
27538: LD_INT 0
27540: PUSH
27541: EMPTY
27542: LIST
27543: LIST
27544: PUSH
27545: LD_INT 1
27547: NEG
27548: PUSH
27549: LD_INT 1
27551: NEG
27552: PUSH
27553: EMPTY
27554: LIST
27555: LIST
27556: PUSH
27557: LD_INT 1
27559: NEG
27560: PUSH
27561: LD_INT 2
27563: NEG
27564: PUSH
27565: EMPTY
27566: LIST
27567: LIST
27568: PUSH
27569: LD_INT 2
27571: PUSH
27572: LD_INT 1
27574: PUSH
27575: EMPTY
27576: LIST
27577: LIST
27578: PUSH
27579: LD_INT 2
27581: PUSH
27582: LD_INT 2
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 1
27591: PUSH
27592: LD_INT 2
27594: PUSH
27595: EMPTY
27596: LIST
27597: LIST
27598: PUSH
27599: LD_INT 2
27601: NEG
27602: PUSH
27603: LD_INT 1
27605: NEG
27606: PUSH
27607: EMPTY
27608: LIST
27609: LIST
27610: PUSH
27611: LD_INT 2
27613: NEG
27614: PUSH
27615: LD_INT 2
27617: NEG
27618: PUSH
27619: EMPTY
27620: LIST
27621: LIST
27622: PUSH
27623: LD_INT 2
27625: NEG
27626: PUSH
27627: LD_INT 3
27629: NEG
27630: PUSH
27631: EMPTY
27632: LIST
27633: LIST
27634: PUSH
27635: LD_INT 3
27637: NEG
27638: PUSH
27639: LD_INT 2
27641: NEG
27642: PUSH
27643: EMPTY
27644: LIST
27645: LIST
27646: PUSH
27647: LD_INT 3
27649: NEG
27650: PUSH
27651: LD_INT 3
27653: NEG
27654: PUSH
27655: EMPTY
27656: LIST
27657: LIST
27658: PUSH
27659: EMPTY
27660: LIST
27661: LIST
27662: LIST
27663: LIST
27664: LIST
27665: LIST
27666: LIST
27667: LIST
27668: LIST
27669: LIST
27670: LIST
27671: LIST
27672: LIST
27673: LIST
27674: LIST
27675: LIST
27676: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
27677: LD_ADDR_VAR 0 14
27681: PUSH
27682: LD_INT 0
27684: PUSH
27685: LD_INT 0
27687: PUSH
27688: EMPTY
27689: LIST
27690: LIST
27691: PUSH
27692: LD_INT 0
27694: PUSH
27695: LD_INT 1
27697: NEG
27698: PUSH
27699: EMPTY
27700: LIST
27701: LIST
27702: PUSH
27703: LD_INT 1
27705: PUSH
27706: LD_INT 0
27708: PUSH
27709: EMPTY
27710: LIST
27711: LIST
27712: PUSH
27713: LD_INT 1
27715: PUSH
27716: LD_INT 1
27718: PUSH
27719: EMPTY
27720: LIST
27721: LIST
27722: PUSH
27723: LD_INT 0
27725: PUSH
27726: LD_INT 1
27728: PUSH
27729: EMPTY
27730: LIST
27731: LIST
27732: PUSH
27733: LD_INT 1
27735: NEG
27736: PUSH
27737: LD_INT 0
27739: PUSH
27740: EMPTY
27741: LIST
27742: LIST
27743: PUSH
27744: LD_INT 1
27746: NEG
27747: PUSH
27748: LD_INT 1
27750: NEG
27751: PUSH
27752: EMPTY
27753: LIST
27754: LIST
27755: PUSH
27756: LD_INT 1
27758: NEG
27759: PUSH
27760: LD_INT 2
27762: NEG
27763: PUSH
27764: EMPTY
27765: LIST
27766: LIST
27767: PUSH
27768: LD_INT 0
27770: PUSH
27771: LD_INT 2
27773: NEG
27774: PUSH
27775: EMPTY
27776: LIST
27777: LIST
27778: PUSH
27779: LD_INT 1
27781: PUSH
27782: LD_INT 1
27784: NEG
27785: PUSH
27786: EMPTY
27787: LIST
27788: LIST
27789: PUSH
27790: LD_INT 1
27792: PUSH
27793: LD_INT 2
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: LD_INT 0
27802: PUSH
27803: LD_INT 2
27805: PUSH
27806: EMPTY
27807: LIST
27808: LIST
27809: PUSH
27810: LD_INT 1
27812: NEG
27813: PUSH
27814: LD_INT 1
27816: PUSH
27817: EMPTY
27818: LIST
27819: LIST
27820: PUSH
27821: LD_INT 1
27823: NEG
27824: PUSH
27825: LD_INT 3
27827: NEG
27828: PUSH
27829: EMPTY
27830: LIST
27831: LIST
27832: PUSH
27833: LD_INT 0
27835: PUSH
27836: LD_INT 3
27838: NEG
27839: PUSH
27840: EMPTY
27841: LIST
27842: LIST
27843: PUSH
27844: LD_INT 1
27846: PUSH
27847: LD_INT 2
27849: NEG
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: LIST
27859: LIST
27860: LIST
27861: LIST
27862: LIST
27863: LIST
27864: LIST
27865: LIST
27866: LIST
27867: LIST
27868: LIST
27869: LIST
27870: LIST
27871: LIST
27872: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
27873: LD_ADDR_VAR 0 15
27877: PUSH
27878: LD_INT 0
27880: PUSH
27881: LD_INT 0
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: LD_INT 0
27890: PUSH
27891: LD_INT 1
27893: NEG
27894: PUSH
27895: EMPTY
27896: LIST
27897: LIST
27898: PUSH
27899: LD_INT 1
27901: PUSH
27902: LD_INT 0
27904: PUSH
27905: EMPTY
27906: LIST
27907: LIST
27908: PUSH
27909: LD_INT 1
27911: PUSH
27912: LD_INT 1
27914: PUSH
27915: EMPTY
27916: LIST
27917: LIST
27918: PUSH
27919: LD_INT 0
27921: PUSH
27922: LD_INT 1
27924: PUSH
27925: EMPTY
27926: LIST
27927: LIST
27928: PUSH
27929: LD_INT 1
27931: NEG
27932: PUSH
27933: LD_INT 0
27935: PUSH
27936: EMPTY
27937: LIST
27938: LIST
27939: PUSH
27940: LD_INT 1
27942: NEG
27943: PUSH
27944: LD_INT 1
27946: NEG
27947: PUSH
27948: EMPTY
27949: LIST
27950: LIST
27951: PUSH
27952: LD_INT 1
27954: PUSH
27955: LD_INT 1
27957: NEG
27958: PUSH
27959: EMPTY
27960: LIST
27961: LIST
27962: PUSH
27963: LD_INT 2
27965: PUSH
27966: LD_INT 0
27968: PUSH
27969: EMPTY
27970: LIST
27971: LIST
27972: PUSH
27973: LD_INT 2
27975: PUSH
27976: LD_INT 1
27978: PUSH
27979: EMPTY
27980: LIST
27981: LIST
27982: PUSH
27983: LD_INT 1
27985: NEG
27986: PUSH
27987: LD_INT 1
27989: PUSH
27990: EMPTY
27991: LIST
27992: LIST
27993: PUSH
27994: LD_INT 2
27996: NEG
27997: PUSH
27998: LD_INT 0
28000: PUSH
28001: EMPTY
28002: LIST
28003: LIST
28004: PUSH
28005: LD_INT 2
28007: NEG
28008: PUSH
28009: LD_INT 1
28011: NEG
28012: PUSH
28013: EMPTY
28014: LIST
28015: LIST
28016: PUSH
28017: LD_INT 2
28019: PUSH
28020: LD_INT 1
28022: NEG
28023: PUSH
28024: EMPTY
28025: LIST
28026: LIST
28027: PUSH
28028: LD_INT 3
28030: PUSH
28031: LD_INT 0
28033: PUSH
28034: EMPTY
28035: LIST
28036: LIST
28037: PUSH
28038: LD_INT 3
28040: PUSH
28041: LD_INT 1
28043: PUSH
28044: EMPTY
28045: LIST
28046: LIST
28047: PUSH
28048: EMPTY
28049: LIST
28050: LIST
28051: LIST
28052: LIST
28053: LIST
28054: LIST
28055: LIST
28056: LIST
28057: LIST
28058: LIST
28059: LIST
28060: LIST
28061: LIST
28062: LIST
28063: LIST
28064: LIST
28065: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28066: LD_ADDR_VAR 0 16
28070: PUSH
28071: LD_INT 0
28073: PUSH
28074: LD_INT 0
28076: PUSH
28077: EMPTY
28078: LIST
28079: LIST
28080: PUSH
28081: LD_INT 0
28083: PUSH
28084: LD_INT 1
28086: NEG
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: PUSH
28092: LD_INT 1
28094: PUSH
28095: LD_INT 0
28097: PUSH
28098: EMPTY
28099: LIST
28100: LIST
28101: PUSH
28102: LD_INT 1
28104: PUSH
28105: LD_INT 1
28107: PUSH
28108: EMPTY
28109: LIST
28110: LIST
28111: PUSH
28112: LD_INT 0
28114: PUSH
28115: LD_INT 1
28117: PUSH
28118: EMPTY
28119: LIST
28120: LIST
28121: PUSH
28122: LD_INT 1
28124: NEG
28125: PUSH
28126: LD_INT 0
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: PUSH
28133: LD_INT 1
28135: NEG
28136: PUSH
28137: LD_INT 1
28139: NEG
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: PUSH
28145: LD_INT 1
28147: NEG
28148: PUSH
28149: LD_INT 2
28151: NEG
28152: PUSH
28153: EMPTY
28154: LIST
28155: LIST
28156: PUSH
28157: LD_INT 2
28159: PUSH
28160: LD_INT 1
28162: PUSH
28163: EMPTY
28164: LIST
28165: LIST
28166: PUSH
28167: LD_INT 2
28169: PUSH
28170: LD_INT 2
28172: PUSH
28173: EMPTY
28174: LIST
28175: LIST
28176: PUSH
28177: LD_INT 1
28179: PUSH
28180: LD_INT 2
28182: PUSH
28183: EMPTY
28184: LIST
28185: LIST
28186: PUSH
28187: LD_INT 2
28189: NEG
28190: PUSH
28191: LD_INT 1
28193: NEG
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 2
28201: NEG
28202: PUSH
28203: LD_INT 2
28205: NEG
28206: PUSH
28207: EMPTY
28208: LIST
28209: LIST
28210: PUSH
28211: LD_INT 3
28213: PUSH
28214: LD_INT 2
28216: PUSH
28217: EMPTY
28218: LIST
28219: LIST
28220: PUSH
28221: LD_INT 3
28223: PUSH
28224: LD_INT 3
28226: PUSH
28227: EMPTY
28228: LIST
28229: LIST
28230: PUSH
28231: LD_INT 2
28233: PUSH
28234: LD_INT 3
28236: PUSH
28237: EMPTY
28238: LIST
28239: LIST
28240: PUSH
28241: EMPTY
28242: LIST
28243: LIST
28244: LIST
28245: LIST
28246: LIST
28247: LIST
28248: LIST
28249: LIST
28250: LIST
28251: LIST
28252: LIST
28253: LIST
28254: LIST
28255: LIST
28256: LIST
28257: LIST
28258: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28259: LD_ADDR_VAR 0 17
28263: PUSH
28264: LD_INT 0
28266: PUSH
28267: LD_INT 0
28269: PUSH
28270: EMPTY
28271: LIST
28272: LIST
28273: PUSH
28274: LD_INT 0
28276: PUSH
28277: LD_INT 1
28279: NEG
28280: PUSH
28281: EMPTY
28282: LIST
28283: LIST
28284: PUSH
28285: LD_INT 1
28287: PUSH
28288: LD_INT 0
28290: PUSH
28291: EMPTY
28292: LIST
28293: LIST
28294: PUSH
28295: LD_INT 1
28297: PUSH
28298: LD_INT 1
28300: PUSH
28301: EMPTY
28302: LIST
28303: LIST
28304: PUSH
28305: LD_INT 0
28307: PUSH
28308: LD_INT 1
28310: PUSH
28311: EMPTY
28312: LIST
28313: LIST
28314: PUSH
28315: LD_INT 1
28317: NEG
28318: PUSH
28319: LD_INT 0
28321: PUSH
28322: EMPTY
28323: LIST
28324: LIST
28325: PUSH
28326: LD_INT 1
28328: NEG
28329: PUSH
28330: LD_INT 1
28332: NEG
28333: PUSH
28334: EMPTY
28335: LIST
28336: LIST
28337: PUSH
28338: LD_INT 1
28340: NEG
28341: PUSH
28342: LD_INT 2
28344: NEG
28345: PUSH
28346: EMPTY
28347: LIST
28348: LIST
28349: PUSH
28350: LD_INT 0
28352: PUSH
28353: LD_INT 2
28355: NEG
28356: PUSH
28357: EMPTY
28358: LIST
28359: LIST
28360: PUSH
28361: LD_INT 1
28363: PUSH
28364: LD_INT 1
28366: NEG
28367: PUSH
28368: EMPTY
28369: LIST
28370: LIST
28371: PUSH
28372: LD_INT 2
28374: PUSH
28375: LD_INT 0
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: LD_INT 2
28384: PUSH
28385: LD_INT 1
28387: PUSH
28388: EMPTY
28389: LIST
28390: LIST
28391: PUSH
28392: LD_INT 2
28394: PUSH
28395: LD_INT 2
28397: PUSH
28398: EMPTY
28399: LIST
28400: LIST
28401: PUSH
28402: LD_INT 1
28404: PUSH
28405: LD_INT 2
28407: PUSH
28408: EMPTY
28409: LIST
28410: LIST
28411: PUSH
28412: LD_INT 0
28414: PUSH
28415: LD_INT 2
28417: PUSH
28418: EMPTY
28419: LIST
28420: LIST
28421: PUSH
28422: LD_INT 1
28424: NEG
28425: PUSH
28426: LD_INT 1
28428: PUSH
28429: EMPTY
28430: LIST
28431: LIST
28432: PUSH
28433: LD_INT 2
28435: NEG
28436: PUSH
28437: LD_INT 0
28439: PUSH
28440: EMPTY
28441: LIST
28442: LIST
28443: PUSH
28444: LD_INT 2
28446: NEG
28447: PUSH
28448: LD_INT 1
28450: NEG
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: PUSH
28456: LD_INT 2
28458: NEG
28459: PUSH
28460: LD_INT 2
28462: NEG
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: EMPTY
28469: LIST
28470: LIST
28471: LIST
28472: LIST
28473: LIST
28474: LIST
28475: LIST
28476: LIST
28477: LIST
28478: LIST
28479: LIST
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28489: LD_ADDR_VAR 0 18
28493: PUSH
28494: LD_INT 0
28496: PUSH
28497: LD_INT 0
28499: PUSH
28500: EMPTY
28501: LIST
28502: LIST
28503: PUSH
28504: LD_INT 0
28506: PUSH
28507: LD_INT 1
28509: NEG
28510: PUSH
28511: EMPTY
28512: LIST
28513: LIST
28514: PUSH
28515: LD_INT 1
28517: PUSH
28518: LD_INT 0
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PUSH
28525: LD_INT 1
28527: PUSH
28528: LD_INT 1
28530: PUSH
28531: EMPTY
28532: LIST
28533: LIST
28534: PUSH
28535: LD_INT 0
28537: PUSH
28538: LD_INT 1
28540: PUSH
28541: EMPTY
28542: LIST
28543: LIST
28544: PUSH
28545: LD_INT 1
28547: NEG
28548: PUSH
28549: LD_INT 0
28551: PUSH
28552: EMPTY
28553: LIST
28554: LIST
28555: PUSH
28556: LD_INT 1
28558: NEG
28559: PUSH
28560: LD_INT 1
28562: NEG
28563: PUSH
28564: EMPTY
28565: LIST
28566: LIST
28567: PUSH
28568: LD_INT 1
28570: NEG
28571: PUSH
28572: LD_INT 2
28574: NEG
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PUSH
28580: LD_INT 0
28582: PUSH
28583: LD_INT 2
28585: NEG
28586: PUSH
28587: EMPTY
28588: LIST
28589: LIST
28590: PUSH
28591: LD_INT 1
28593: PUSH
28594: LD_INT 1
28596: NEG
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: PUSH
28602: LD_INT 2
28604: PUSH
28605: LD_INT 0
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: PUSH
28612: LD_INT 2
28614: PUSH
28615: LD_INT 1
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: PUSH
28622: LD_INT 2
28624: PUSH
28625: LD_INT 2
28627: PUSH
28628: EMPTY
28629: LIST
28630: LIST
28631: PUSH
28632: LD_INT 1
28634: PUSH
28635: LD_INT 2
28637: PUSH
28638: EMPTY
28639: LIST
28640: LIST
28641: PUSH
28642: LD_INT 0
28644: PUSH
28645: LD_INT 2
28647: PUSH
28648: EMPTY
28649: LIST
28650: LIST
28651: PUSH
28652: LD_INT 1
28654: NEG
28655: PUSH
28656: LD_INT 1
28658: PUSH
28659: EMPTY
28660: LIST
28661: LIST
28662: PUSH
28663: LD_INT 2
28665: NEG
28666: PUSH
28667: LD_INT 0
28669: PUSH
28670: EMPTY
28671: LIST
28672: LIST
28673: PUSH
28674: LD_INT 2
28676: NEG
28677: PUSH
28678: LD_INT 1
28680: NEG
28681: PUSH
28682: EMPTY
28683: LIST
28684: LIST
28685: PUSH
28686: LD_INT 2
28688: NEG
28689: PUSH
28690: LD_INT 2
28692: NEG
28693: PUSH
28694: EMPTY
28695: LIST
28696: LIST
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: LIST
28702: LIST
28703: LIST
28704: LIST
28705: LIST
28706: LIST
28707: LIST
28708: LIST
28709: LIST
28710: LIST
28711: LIST
28712: LIST
28713: LIST
28714: LIST
28715: LIST
28716: LIST
28717: LIST
28718: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28719: LD_ADDR_VAR 0 19
28723: PUSH
28724: LD_INT 0
28726: PUSH
28727: LD_INT 0
28729: PUSH
28730: EMPTY
28731: LIST
28732: LIST
28733: PUSH
28734: LD_INT 0
28736: PUSH
28737: LD_INT 1
28739: NEG
28740: PUSH
28741: EMPTY
28742: LIST
28743: LIST
28744: PUSH
28745: LD_INT 1
28747: PUSH
28748: LD_INT 0
28750: PUSH
28751: EMPTY
28752: LIST
28753: LIST
28754: PUSH
28755: LD_INT 1
28757: PUSH
28758: LD_INT 1
28760: PUSH
28761: EMPTY
28762: LIST
28763: LIST
28764: PUSH
28765: LD_INT 0
28767: PUSH
28768: LD_INT 1
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: PUSH
28775: LD_INT 1
28777: NEG
28778: PUSH
28779: LD_INT 0
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 1
28788: NEG
28789: PUSH
28790: LD_INT 1
28792: NEG
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: LD_INT 1
28800: NEG
28801: PUSH
28802: LD_INT 2
28804: NEG
28805: PUSH
28806: EMPTY
28807: LIST
28808: LIST
28809: PUSH
28810: LD_INT 0
28812: PUSH
28813: LD_INT 2
28815: NEG
28816: PUSH
28817: EMPTY
28818: LIST
28819: LIST
28820: PUSH
28821: LD_INT 1
28823: PUSH
28824: LD_INT 1
28826: NEG
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: PUSH
28832: LD_INT 2
28834: PUSH
28835: LD_INT 0
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: PUSH
28842: LD_INT 2
28844: PUSH
28845: LD_INT 1
28847: PUSH
28848: EMPTY
28849: LIST
28850: LIST
28851: PUSH
28852: LD_INT 2
28854: PUSH
28855: LD_INT 2
28857: PUSH
28858: EMPTY
28859: LIST
28860: LIST
28861: PUSH
28862: LD_INT 1
28864: PUSH
28865: LD_INT 2
28867: PUSH
28868: EMPTY
28869: LIST
28870: LIST
28871: PUSH
28872: LD_INT 0
28874: PUSH
28875: LD_INT 2
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: PUSH
28882: LD_INT 1
28884: NEG
28885: PUSH
28886: LD_INT 1
28888: PUSH
28889: EMPTY
28890: LIST
28891: LIST
28892: PUSH
28893: LD_INT 2
28895: NEG
28896: PUSH
28897: LD_INT 0
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: LD_INT 2
28906: NEG
28907: PUSH
28908: LD_INT 1
28910: NEG
28911: PUSH
28912: EMPTY
28913: LIST
28914: LIST
28915: PUSH
28916: LD_INT 2
28918: NEG
28919: PUSH
28920: LD_INT 2
28922: NEG
28923: PUSH
28924: EMPTY
28925: LIST
28926: LIST
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: LIST
28932: LIST
28933: LIST
28934: LIST
28935: LIST
28936: LIST
28937: LIST
28938: LIST
28939: LIST
28940: LIST
28941: LIST
28942: LIST
28943: LIST
28944: LIST
28945: LIST
28946: LIST
28947: LIST
28948: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28949: LD_ADDR_VAR 0 20
28953: PUSH
28954: LD_INT 0
28956: PUSH
28957: LD_INT 0
28959: PUSH
28960: EMPTY
28961: LIST
28962: LIST
28963: PUSH
28964: LD_INT 0
28966: PUSH
28967: LD_INT 1
28969: NEG
28970: PUSH
28971: EMPTY
28972: LIST
28973: LIST
28974: PUSH
28975: LD_INT 1
28977: PUSH
28978: LD_INT 0
28980: PUSH
28981: EMPTY
28982: LIST
28983: LIST
28984: PUSH
28985: LD_INT 1
28987: PUSH
28988: LD_INT 1
28990: PUSH
28991: EMPTY
28992: LIST
28993: LIST
28994: PUSH
28995: LD_INT 0
28997: PUSH
28998: LD_INT 1
29000: PUSH
29001: EMPTY
29002: LIST
29003: LIST
29004: PUSH
29005: LD_INT 1
29007: NEG
29008: PUSH
29009: LD_INT 0
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: PUSH
29016: LD_INT 1
29018: NEG
29019: PUSH
29020: LD_INT 1
29022: NEG
29023: PUSH
29024: EMPTY
29025: LIST
29026: LIST
29027: PUSH
29028: LD_INT 1
29030: NEG
29031: PUSH
29032: LD_INT 2
29034: NEG
29035: PUSH
29036: EMPTY
29037: LIST
29038: LIST
29039: PUSH
29040: LD_INT 0
29042: PUSH
29043: LD_INT 2
29045: NEG
29046: PUSH
29047: EMPTY
29048: LIST
29049: LIST
29050: PUSH
29051: LD_INT 1
29053: PUSH
29054: LD_INT 1
29056: NEG
29057: PUSH
29058: EMPTY
29059: LIST
29060: LIST
29061: PUSH
29062: LD_INT 2
29064: PUSH
29065: LD_INT 0
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 2
29074: PUSH
29075: LD_INT 1
29077: PUSH
29078: EMPTY
29079: LIST
29080: LIST
29081: PUSH
29082: LD_INT 2
29084: PUSH
29085: LD_INT 2
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: PUSH
29092: LD_INT 1
29094: PUSH
29095: LD_INT 2
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PUSH
29102: LD_INT 0
29104: PUSH
29105: LD_INT 2
29107: PUSH
29108: EMPTY
29109: LIST
29110: LIST
29111: PUSH
29112: LD_INT 1
29114: NEG
29115: PUSH
29116: LD_INT 1
29118: PUSH
29119: EMPTY
29120: LIST
29121: LIST
29122: PUSH
29123: LD_INT 2
29125: NEG
29126: PUSH
29127: LD_INT 0
29129: PUSH
29130: EMPTY
29131: LIST
29132: LIST
29133: PUSH
29134: LD_INT 2
29136: NEG
29137: PUSH
29138: LD_INT 1
29140: NEG
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PUSH
29146: LD_INT 2
29148: NEG
29149: PUSH
29150: LD_INT 2
29152: NEG
29153: PUSH
29154: EMPTY
29155: LIST
29156: LIST
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: LIST
29162: LIST
29163: LIST
29164: LIST
29165: LIST
29166: LIST
29167: LIST
29168: LIST
29169: LIST
29170: LIST
29171: LIST
29172: LIST
29173: LIST
29174: LIST
29175: LIST
29176: LIST
29177: LIST
29178: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29179: LD_ADDR_VAR 0 21
29183: PUSH
29184: LD_INT 0
29186: PUSH
29187: LD_INT 0
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: LD_INT 0
29196: PUSH
29197: LD_INT 1
29199: NEG
29200: PUSH
29201: EMPTY
29202: LIST
29203: LIST
29204: PUSH
29205: LD_INT 1
29207: PUSH
29208: LD_INT 0
29210: PUSH
29211: EMPTY
29212: LIST
29213: LIST
29214: PUSH
29215: LD_INT 1
29217: PUSH
29218: LD_INT 1
29220: PUSH
29221: EMPTY
29222: LIST
29223: LIST
29224: PUSH
29225: LD_INT 0
29227: PUSH
29228: LD_INT 1
29230: PUSH
29231: EMPTY
29232: LIST
29233: LIST
29234: PUSH
29235: LD_INT 1
29237: NEG
29238: PUSH
29239: LD_INT 0
29241: PUSH
29242: EMPTY
29243: LIST
29244: LIST
29245: PUSH
29246: LD_INT 1
29248: NEG
29249: PUSH
29250: LD_INT 1
29252: NEG
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: LD_INT 1
29260: NEG
29261: PUSH
29262: LD_INT 2
29264: NEG
29265: PUSH
29266: EMPTY
29267: LIST
29268: LIST
29269: PUSH
29270: LD_INT 0
29272: PUSH
29273: LD_INT 2
29275: NEG
29276: PUSH
29277: EMPTY
29278: LIST
29279: LIST
29280: PUSH
29281: LD_INT 1
29283: PUSH
29284: LD_INT 1
29286: NEG
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: PUSH
29292: LD_INT 2
29294: PUSH
29295: LD_INT 0
29297: PUSH
29298: EMPTY
29299: LIST
29300: LIST
29301: PUSH
29302: LD_INT 2
29304: PUSH
29305: LD_INT 1
29307: PUSH
29308: EMPTY
29309: LIST
29310: LIST
29311: PUSH
29312: LD_INT 2
29314: PUSH
29315: LD_INT 2
29317: PUSH
29318: EMPTY
29319: LIST
29320: LIST
29321: PUSH
29322: LD_INT 1
29324: PUSH
29325: LD_INT 2
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: PUSH
29332: LD_INT 0
29334: PUSH
29335: LD_INT 2
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 1
29344: NEG
29345: PUSH
29346: LD_INT 1
29348: PUSH
29349: EMPTY
29350: LIST
29351: LIST
29352: PUSH
29353: LD_INT 2
29355: NEG
29356: PUSH
29357: LD_INT 0
29359: PUSH
29360: EMPTY
29361: LIST
29362: LIST
29363: PUSH
29364: LD_INT 2
29366: NEG
29367: PUSH
29368: LD_INT 1
29370: NEG
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 2
29378: NEG
29379: PUSH
29380: LD_INT 2
29382: NEG
29383: PUSH
29384: EMPTY
29385: LIST
29386: LIST
29387: PUSH
29388: EMPTY
29389: LIST
29390: LIST
29391: LIST
29392: LIST
29393: LIST
29394: LIST
29395: LIST
29396: LIST
29397: LIST
29398: LIST
29399: LIST
29400: LIST
29401: LIST
29402: LIST
29403: LIST
29404: LIST
29405: LIST
29406: LIST
29407: LIST
29408: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29409: LD_ADDR_VAR 0 22
29413: PUSH
29414: LD_INT 0
29416: PUSH
29417: LD_INT 0
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: PUSH
29424: LD_INT 0
29426: PUSH
29427: LD_INT 1
29429: NEG
29430: PUSH
29431: EMPTY
29432: LIST
29433: LIST
29434: PUSH
29435: LD_INT 1
29437: PUSH
29438: LD_INT 0
29440: PUSH
29441: EMPTY
29442: LIST
29443: LIST
29444: PUSH
29445: LD_INT 1
29447: PUSH
29448: LD_INT 1
29450: PUSH
29451: EMPTY
29452: LIST
29453: LIST
29454: PUSH
29455: LD_INT 0
29457: PUSH
29458: LD_INT 1
29460: PUSH
29461: EMPTY
29462: LIST
29463: LIST
29464: PUSH
29465: LD_INT 1
29467: NEG
29468: PUSH
29469: LD_INT 0
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: LD_INT 1
29478: NEG
29479: PUSH
29480: LD_INT 1
29482: NEG
29483: PUSH
29484: EMPTY
29485: LIST
29486: LIST
29487: PUSH
29488: LD_INT 1
29490: NEG
29491: PUSH
29492: LD_INT 2
29494: NEG
29495: PUSH
29496: EMPTY
29497: LIST
29498: LIST
29499: PUSH
29500: LD_INT 0
29502: PUSH
29503: LD_INT 2
29505: NEG
29506: PUSH
29507: EMPTY
29508: LIST
29509: LIST
29510: PUSH
29511: LD_INT 1
29513: PUSH
29514: LD_INT 1
29516: NEG
29517: PUSH
29518: EMPTY
29519: LIST
29520: LIST
29521: PUSH
29522: LD_INT 2
29524: PUSH
29525: LD_INT 0
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: LD_INT 2
29534: PUSH
29535: LD_INT 1
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: PUSH
29542: LD_INT 2
29544: PUSH
29545: LD_INT 2
29547: PUSH
29548: EMPTY
29549: LIST
29550: LIST
29551: PUSH
29552: LD_INT 1
29554: PUSH
29555: LD_INT 2
29557: PUSH
29558: EMPTY
29559: LIST
29560: LIST
29561: PUSH
29562: LD_INT 0
29564: PUSH
29565: LD_INT 2
29567: PUSH
29568: EMPTY
29569: LIST
29570: LIST
29571: PUSH
29572: LD_INT 1
29574: NEG
29575: PUSH
29576: LD_INT 1
29578: PUSH
29579: EMPTY
29580: LIST
29581: LIST
29582: PUSH
29583: LD_INT 2
29585: NEG
29586: PUSH
29587: LD_INT 0
29589: PUSH
29590: EMPTY
29591: LIST
29592: LIST
29593: PUSH
29594: LD_INT 2
29596: NEG
29597: PUSH
29598: LD_INT 1
29600: NEG
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: PUSH
29606: LD_INT 2
29608: NEG
29609: PUSH
29610: LD_INT 2
29612: NEG
29613: PUSH
29614: EMPTY
29615: LIST
29616: LIST
29617: PUSH
29618: EMPTY
29619: LIST
29620: LIST
29621: LIST
29622: LIST
29623: LIST
29624: LIST
29625: LIST
29626: LIST
29627: LIST
29628: LIST
29629: LIST
29630: LIST
29631: LIST
29632: LIST
29633: LIST
29634: LIST
29635: LIST
29636: LIST
29637: LIST
29638: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
29639: LD_ADDR_VAR 0 23
29643: PUSH
29644: LD_INT 0
29646: PUSH
29647: LD_INT 0
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 0
29656: PUSH
29657: LD_INT 1
29659: NEG
29660: PUSH
29661: EMPTY
29662: LIST
29663: LIST
29664: PUSH
29665: LD_INT 1
29667: PUSH
29668: LD_INT 0
29670: PUSH
29671: EMPTY
29672: LIST
29673: LIST
29674: PUSH
29675: LD_INT 1
29677: PUSH
29678: LD_INT 1
29680: PUSH
29681: EMPTY
29682: LIST
29683: LIST
29684: PUSH
29685: LD_INT 0
29687: PUSH
29688: LD_INT 1
29690: PUSH
29691: EMPTY
29692: LIST
29693: LIST
29694: PUSH
29695: LD_INT 1
29697: NEG
29698: PUSH
29699: LD_INT 0
29701: PUSH
29702: EMPTY
29703: LIST
29704: LIST
29705: PUSH
29706: LD_INT 1
29708: NEG
29709: PUSH
29710: LD_INT 1
29712: NEG
29713: PUSH
29714: EMPTY
29715: LIST
29716: LIST
29717: PUSH
29718: LD_INT 1
29720: NEG
29721: PUSH
29722: LD_INT 2
29724: NEG
29725: PUSH
29726: EMPTY
29727: LIST
29728: LIST
29729: PUSH
29730: LD_INT 0
29732: PUSH
29733: LD_INT 2
29735: NEG
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PUSH
29741: LD_INT 1
29743: PUSH
29744: LD_INT 1
29746: NEG
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: PUSH
29752: LD_INT 2
29754: PUSH
29755: LD_INT 0
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 2
29764: PUSH
29765: LD_INT 1
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: PUSH
29772: LD_INT 2
29774: PUSH
29775: LD_INT 2
29777: PUSH
29778: EMPTY
29779: LIST
29780: LIST
29781: PUSH
29782: LD_INT 1
29784: PUSH
29785: LD_INT 2
29787: PUSH
29788: EMPTY
29789: LIST
29790: LIST
29791: PUSH
29792: LD_INT 0
29794: PUSH
29795: LD_INT 2
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: PUSH
29802: LD_INT 1
29804: NEG
29805: PUSH
29806: LD_INT 1
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: PUSH
29813: LD_INT 2
29815: NEG
29816: PUSH
29817: LD_INT 0
29819: PUSH
29820: EMPTY
29821: LIST
29822: LIST
29823: PUSH
29824: LD_INT 2
29826: NEG
29827: PUSH
29828: LD_INT 1
29830: NEG
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 2
29838: NEG
29839: PUSH
29840: LD_INT 2
29842: NEG
29843: PUSH
29844: EMPTY
29845: LIST
29846: LIST
29847: PUSH
29848: LD_INT 2
29850: NEG
29851: PUSH
29852: LD_INT 3
29854: NEG
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: LD_INT 1
29862: NEG
29863: PUSH
29864: LD_INT 3
29866: NEG
29867: PUSH
29868: EMPTY
29869: LIST
29870: LIST
29871: PUSH
29872: LD_INT 1
29874: PUSH
29875: LD_INT 2
29877: NEG
29878: PUSH
29879: EMPTY
29880: LIST
29881: LIST
29882: PUSH
29883: LD_INT 2
29885: PUSH
29886: LD_INT 1
29888: NEG
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: EMPTY
29895: LIST
29896: LIST
29897: LIST
29898: LIST
29899: LIST
29900: LIST
29901: LIST
29902: LIST
29903: LIST
29904: LIST
29905: LIST
29906: LIST
29907: LIST
29908: LIST
29909: LIST
29910: LIST
29911: LIST
29912: LIST
29913: LIST
29914: LIST
29915: LIST
29916: LIST
29917: LIST
29918: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
29919: LD_ADDR_VAR 0 24
29923: PUSH
29924: LD_INT 0
29926: PUSH
29927: LD_INT 0
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PUSH
29934: LD_INT 0
29936: PUSH
29937: LD_INT 1
29939: NEG
29940: PUSH
29941: EMPTY
29942: LIST
29943: LIST
29944: PUSH
29945: LD_INT 1
29947: PUSH
29948: LD_INT 0
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 1
29957: PUSH
29958: LD_INT 1
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PUSH
29965: LD_INT 0
29967: PUSH
29968: LD_INT 1
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: PUSH
29975: LD_INT 1
29977: NEG
29978: PUSH
29979: LD_INT 0
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: LD_INT 1
29988: NEG
29989: PUSH
29990: LD_INT 1
29992: NEG
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: LD_INT 1
30000: NEG
30001: PUSH
30002: LD_INT 2
30004: NEG
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: PUSH
30010: LD_INT 0
30012: PUSH
30013: LD_INT 2
30015: NEG
30016: PUSH
30017: EMPTY
30018: LIST
30019: LIST
30020: PUSH
30021: LD_INT 1
30023: PUSH
30024: LD_INT 1
30026: NEG
30027: PUSH
30028: EMPTY
30029: LIST
30030: LIST
30031: PUSH
30032: LD_INT 2
30034: PUSH
30035: LD_INT 0
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 2
30044: PUSH
30045: LD_INT 1
30047: PUSH
30048: EMPTY
30049: LIST
30050: LIST
30051: PUSH
30052: LD_INT 2
30054: PUSH
30055: LD_INT 2
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 1
30064: PUSH
30065: LD_INT 2
30067: PUSH
30068: EMPTY
30069: LIST
30070: LIST
30071: PUSH
30072: LD_INT 0
30074: PUSH
30075: LD_INT 2
30077: PUSH
30078: EMPTY
30079: LIST
30080: LIST
30081: PUSH
30082: LD_INT 1
30084: NEG
30085: PUSH
30086: LD_INT 1
30088: PUSH
30089: EMPTY
30090: LIST
30091: LIST
30092: PUSH
30093: LD_INT 2
30095: NEG
30096: PUSH
30097: LD_INT 0
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 2
30106: NEG
30107: PUSH
30108: LD_INT 1
30110: NEG
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: PUSH
30116: LD_INT 2
30118: NEG
30119: PUSH
30120: LD_INT 2
30122: NEG
30123: PUSH
30124: EMPTY
30125: LIST
30126: LIST
30127: PUSH
30128: LD_INT 1
30130: PUSH
30131: LD_INT 2
30133: NEG
30134: PUSH
30135: EMPTY
30136: LIST
30137: LIST
30138: PUSH
30139: LD_INT 2
30141: PUSH
30142: LD_INT 1
30144: NEG
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: PUSH
30150: LD_INT 3
30152: PUSH
30153: LD_INT 1
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 3
30162: PUSH
30163: LD_INT 2
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: EMPTY
30171: LIST
30172: LIST
30173: LIST
30174: LIST
30175: LIST
30176: LIST
30177: LIST
30178: LIST
30179: LIST
30180: LIST
30181: LIST
30182: LIST
30183: LIST
30184: LIST
30185: LIST
30186: LIST
30187: LIST
30188: LIST
30189: LIST
30190: LIST
30191: LIST
30192: LIST
30193: LIST
30194: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30195: LD_ADDR_VAR 0 25
30199: PUSH
30200: LD_INT 0
30202: PUSH
30203: LD_INT 0
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 0
30212: PUSH
30213: LD_INT 1
30215: NEG
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 1
30223: PUSH
30224: LD_INT 0
30226: PUSH
30227: EMPTY
30228: LIST
30229: LIST
30230: PUSH
30231: LD_INT 1
30233: PUSH
30234: LD_INT 1
30236: PUSH
30237: EMPTY
30238: LIST
30239: LIST
30240: PUSH
30241: LD_INT 0
30243: PUSH
30244: LD_INT 1
30246: PUSH
30247: EMPTY
30248: LIST
30249: LIST
30250: PUSH
30251: LD_INT 1
30253: NEG
30254: PUSH
30255: LD_INT 0
30257: PUSH
30258: EMPTY
30259: LIST
30260: LIST
30261: PUSH
30262: LD_INT 1
30264: NEG
30265: PUSH
30266: LD_INT 1
30268: NEG
30269: PUSH
30270: EMPTY
30271: LIST
30272: LIST
30273: PUSH
30274: LD_INT 1
30276: NEG
30277: PUSH
30278: LD_INT 2
30280: NEG
30281: PUSH
30282: EMPTY
30283: LIST
30284: LIST
30285: PUSH
30286: LD_INT 0
30288: PUSH
30289: LD_INT 2
30291: NEG
30292: PUSH
30293: EMPTY
30294: LIST
30295: LIST
30296: PUSH
30297: LD_INT 1
30299: PUSH
30300: LD_INT 1
30302: NEG
30303: PUSH
30304: EMPTY
30305: LIST
30306: LIST
30307: PUSH
30308: LD_INT 2
30310: PUSH
30311: LD_INT 0
30313: PUSH
30314: EMPTY
30315: LIST
30316: LIST
30317: PUSH
30318: LD_INT 2
30320: PUSH
30321: LD_INT 1
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: PUSH
30328: LD_INT 2
30330: PUSH
30331: LD_INT 2
30333: PUSH
30334: EMPTY
30335: LIST
30336: LIST
30337: PUSH
30338: LD_INT 1
30340: PUSH
30341: LD_INT 2
30343: PUSH
30344: EMPTY
30345: LIST
30346: LIST
30347: PUSH
30348: LD_INT 0
30350: PUSH
30351: LD_INT 2
30353: PUSH
30354: EMPTY
30355: LIST
30356: LIST
30357: PUSH
30358: LD_INT 1
30360: NEG
30361: PUSH
30362: LD_INT 1
30364: PUSH
30365: EMPTY
30366: LIST
30367: LIST
30368: PUSH
30369: LD_INT 2
30371: NEG
30372: PUSH
30373: LD_INT 0
30375: PUSH
30376: EMPTY
30377: LIST
30378: LIST
30379: PUSH
30380: LD_INT 2
30382: NEG
30383: PUSH
30384: LD_INT 1
30386: NEG
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 2
30394: NEG
30395: PUSH
30396: LD_INT 2
30398: NEG
30399: PUSH
30400: EMPTY
30401: LIST
30402: LIST
30403: PUSH
30404: LD_INT 3
30406: PUSH
30407: LD_INT 1
30409: PUSH
30410: EMPTY
30411: LIST
30412: LIST
30413: PUSH
30414: LD_INT 3
30416: PUSH
30417: LD_INT 2
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 2
30426: PUSH
30427: LD_INT 3
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: LD_INT 1
30436: PUSH
30437: LD_INT 3
30439: PUSH
30440: EMPTY
30441: LIST
30442: LIST
30443: PUSH
30444: EMPTY
30445: LIST
30446: LIST
30447: LIST
30448: LIST
30449: LIST
30450: LIST
30451: LIST
30452: LIST
30453: LIST
30454: LIST
30455: LIST
30456: LIST
30457: LIST
30458: LIST
30459: LIST
30460: LIST
30461: LIST
30462: LIST
30463: LIST
30464: LIST
30465: LIST
30466: LIST
30467: LIST
30468: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
30469: LD_ADDR_VAR 0 26
30473: PUSH
30474: LD_INT 0
30476: PUSH
30477: LD_INT 0
30479: PUSH
30480: EMPTY
30481: LIST
30482: LIST
30483: PUSH
30484: LD_INT 0
30486: PUSH
30487: LD_INT 1
30489: NEG
30490: PUSH
30491: EMPTY
30492: LIST
30493: LIST
30494: PUSH
30495: LD_INT 1
30497: PUSH
30498: LD_INT 0
30500: PUSH
30501: EMPTY
30502: LIST
30503: LIST
30504: PUSH
30505: LD_INT 1
30507: PUSH
30508: LD_INT 1
30510: PUSH
30511: EMPTY
30512: LIST
30513: LIST
30514: PUSH
30515: LD_INT 0
30517: PUSH
30518: LD_INT 1
30520: PUSH
30521: EMPTY
30522: LIST
30523: LIST
30524: PUSH
30525: LD_INT 1
30527: NEG
30528: PUSH
30529: LD_INT 0
30531: PUSH
30532: EMPTY
30533: LIST
30534: LIST
30535: PUSH
30536: LD_INT 1
30538: NEG
30539: PUSH
30540: LD_INT 1
30542: NEG
30543: PUSH
30544: EMPTY
30545: LIST
30546: LIST
30547: PUSH
30548: LD_INT 1
30550: NEG
30551: PUSH
30552: LD_INT 2
30554: NEG
30555: PUSH
30556: EMPTY
30557: LIST
30558: LIST
30559: PUSH
30560: LD_INT 0
30562: PUSH
30563: LD_INT 2
30565: NEG
30566: PUSH
30567: EMPTY
30568: LIST
30569: LIST
30570: PUSH
30571: LD_INT 1
30573: PUSH
30574: LD_INT 1
30576: NEG
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 2
30584: PUSH
30585: LD_INT 0
30587: PUSH
30588: EMPTY
30589: LIST
30590: LIST
30591: PUSH
30592: LD_INT 2
30594: PUSH
30595: LD_INT 1
30597: PUSH
30598: EMPTY
30599: LIST
30600: LIST
30601: PUSH
30602: LD_INT 2
30604: PUSH
30605: LD_INT 2
30607: PUSH
30608: EMPTY
30609: LIST
30610: LIST
30611: PUSH
30612: LD_INT 1
30614: PUSH
30615: LD_INT 2
30617: PUSH
30618: EMPTY
30619: LIST
30620: LIST
30621: PUSH
30622: LD_INT 0
30624: PUSH
30625: LD_INT 2
30627: PUSH
30628: EMPTY
30629: LIST
30630: LIST
30631: PUSH
30632: LD_INT 1
30634: NEG
30635: PUSH
30636: LD_INT 1
30638: PUSH
30639: EMPTY
30640: LIST
30641: LIST
30642: PUSH
30643: LD_INT 2
30645: NEG
30646: PUSH
30647: LD_INT 0
30649: PUSH
30650: EMPTY
30651: LIST
30652: LIST
30653: PUSH
30654: LD_INT 2
30656: NEG
30657: PUSH
30658: LD_INT 1
30660: NEG
30661: PUSH
30662: EMPTY
30663: LIST
30664: LIST
30665: PUSH
30666: LD_INT 2
30668: NEG
30669: PUSH
30670: LD_INT 2
30672: NEG
30673: PUSH
30674: EMPTY
30675: LIST
30676: LIST
30677: PUSH
30678: LD_INT 2
30680: PUSH
30681: LD_INT 3
30683: PUSH
30684: EMPTY
30685: LIST
30686: LIST
30687: PUSH
30688: LD_INT 1
30690: PUSH
30691: LD_INT 3
30693: PUSH
30694: EMPTY
30695: LIST
30696: LIST
30697: PUSH
30698: LD_INT 1
30700: NEG
30701: PUSH
30702: LD_INT 2
30704: PUSH
30705: EMPTY
30706: LIST
30707: LIST
30708: PUSH
30709: LD_INT 2
30711: NEG
30712: PUSH
30713: LD_INT 1
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: PUSH
30720: EMPTY
30721: LIST
30722: LIST
30723: LIST
30724: LIST
30725: LIST
30726: LIST
30727: LIST
30728: LIST
30729: LIST
30730: LIST
30731: LIST
30732: LIST
30733: LIST
30734: LIST
30735: LIST
30736: LIST
30737: LIST
30738: LIST
30739: LIST
30740: LIST
30741: LIST
30742: LIST
30743: LIST
30744: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
30745: LD_ADDR_VAR 0 27
30749: PUSH
30750: LD_INT 0
30752: PUSH
30753: LD_INT 0
30755: PUSH
30756: EMPTY
30757: LIST
30758: LIST
30759: PUSH
30760: LD_INT 0
30762: PUSH
30763: LD_INT 1
30765: NEG
30766: PUSH
30767: EMPTY
30768: LIST
30769: LIST
30770: PUSH
30771: LD_INT 1
30773: PUSH
30774: LD_INT 0
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PUSH
30781: LD_INT 1
30783: PUSH
30784: LD_INT 1
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 0
30793: PUSH
30794: LD_INT 1
30796: PUSH
30797: EMPTY
30798: LIST
30799: LIST
30800: PUSH
30801: LD_INT 1
30803: NEG
30804: PUSH
30805: LD_INT 0
30807: PUSH
30808: EMPTY
30809: LIST
30810: LIST
30811: PUSH
30812: LD_INT 1
30814: NEG
30815: PUSH
30816: LD_INT 1
30818: NEG
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 1
30826: NEG
30827: PUSH
30828: LD_INT 2
30830: NEG
30831: PUSH
30832: EMPTY
30833: LIST
30834: LIST
30835: PUSH
30836: LD_INT 0
30838: PUSH
30839: LD_INT 2
30841: NEG
30842: PUSH
30843: EMPTY
30844: LIST
30845: LIST
30846: PUSH
30847: LD_INT 1
30849: PUSH
30850: LD_INT 1
30852: NEG
30853: PUSH
30854: EMPTY
30855: LIST
30856: LIST
30857: PUSH
30858: LD_INT 2
30860: PUSH
30861: LD_INT 0
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 2
30870: PUSH
30871: LD_INT 1
30873: PUSH
30874: EMPTY
30875: LIST
30876: LIST
30877: PUSH
30878: LD_INT 2
30880: PUSH
30881: LD_INT 2
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 1
30890: PUSH
30891: LD_INT 2
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PUSH
30898: LD_INT 0
30900: PUSH
30901: LD_INT 2
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 1
30910: NEG
30911: PUSH
30912: LD_INT 1
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PUSH
30919: LD_INT 2
30921: NEG
30922: PUSH
30923: LD_INT 0
30925: PUSH
30926: EMPTY
30927: LIST
30928: LIST
30929: PUSH
30930: LD_INT 2
30932: NEG
30933: PUSH
30934: LD_INT 1
30936: NEG
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 2
30944: NEG
30945: PUSH
30946: LD_INT 2
30948: NEG
30949: PUSH
30950: EMPTY
30951: LIST
30952: LIST
30953: PUSH
30954: LD_INT 1
30956: NEG
30957: PUSH
30958: LD_INT 2
30960: PUSH
30961: EMPTY
30962: LIST
30963: LIST
30964: PUSH
30965: LD_INT 2
30967: NEG
30968: PUSH
30969: LD_INT 1
30971: PUSH
30972: EMPTY
30973: LIST
30974: LIST
30975: PUSH
30976: LD_INT 3
30978: NEG
30979: PUSH
30980: LD_INT 1
30982: NEG
30983: PUSH
30984: EMPTY
30985: LIST
30986: LIST
30987: PUSH
30988: LD_INT 3
30990: NEG
30991: PUSH
30992: LD_INT 2
30994: NEG
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: EMPTY
31001: LIST
31002: LIST
31003: LIST
31004: LIST
31005: LIST
31006: LIST
31007: LIST
31008: LIST
31009: LIST
31010: LIST
31011: LIST
31012: LIST
31013: LIST
31014: LIST
31015: LIST
31016: LIST
31017: LIST
31018: LIST
31019: LIST
31020: LIST
31021: LIST
31022: LIST
31023: LIST
31024: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31025: LD_ADDR_VAR 0 28
31029: PUSH
31030: LD_INT 0
31032: PUSH
31033: LD_INT 0
31035: PUSH
31036: EMPTY
31037: LIST
31038: LIST
31039: PUSH
31040: LD_INT 0
31042: PUSH
31043: LD_INT 1
31045: NEG
31046: PUSH
31047: EMPTY
31048: LIST
31049: LIST
31050: PUSH
31051: LD_INT 1
31053: PUSH
31054: LD_INT 0
31056: PUSH
31057: EMPTY
31058: LIST
31059: LIST
31060: PUSH
31061: LD_INT 1
31063: PUSH
31064: LD_INT 1
31066: PUSH
31067: EMPTY
31068: LIST
31069: LIST
31070: PUSH
31071: LD_INT 0
31073: PUSH
31074: LD_INT 1
31076: PUSH
31077: EMPTY
31078: LIST
31079: LIST
31080: PUSH
31081: LD_INT 1
31083: NEG
31084: PUSH
31085: LD_INT 0
31087: PUSH
31088: EMPTY
31089: LIST
31090: LIST
31091: PUSH
31092: LD_INT 1
31094: NEG
31095: PUSH
31096: LD_INT 1
31098: NEG
31099: PUSH
31100: EMPTY
31101: LIST
31102: LIST
31103: PUSH
31104: LD_INT 1
31106: NEG
31107: PUSH
31108: LD_INT 2
31110: NEG
31111: PUSH
31112: EMPTY
31113: LIST
31114: LIST
31115: PUSH
31116: LD_INT 0
31118: PUSH
31119: LD_INT 2
31121: NEG
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: LD_INT 1
31129: PUSH
31130: LD_INT 1
31132: NEG
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: LD_INT 2
31140: PUSH
31141: LD_INT 0
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 2
31150: PUSH
31151: LD_INT 1
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PUSH
31158: LD_INT 2
31160: PUSH
31161: LD_INT 2
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: PUSH
31168: LD_INT 1
31170: PUSH
31171: LD_INT 2
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: LD_INT 0
31180: PUSH
31181: LD_INT 2
31183: PUSH
31184: EMPTY
31185: LIST
31186: LIST
31187: PUSH
31188: LD_INT 1
31190: NEG
31191: PUSH
31192: LD_INT 1
31194: PUSH
31195: EMPTY
31196: LIST
31197: LIST
31198: PUSH
31199: LD_INT 2
31201: NEG
31202: PUSH
31203: LD_INT 0
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: LD_INT 2
31212: NEG
31213: PUSH
31214: LD_INT 1
31216: NEG
31217: PUSH
31218: EMPTY
31219: LIST
31220: LIST
31221: PUSH
31222: LD_INT 2
31224: NEG
31225: PUSH
31226: LD_INT 2
31228: NEG
31229: PUSH
31230: EMPTY
31231: LIST
31232: LIST
31233: PUSH
31234: LD_INT 2
31236: NEG
31237: PUSH
31238: LD_INT 3
31240: NEG
31241: PUSH
31242: EMPTY
31243: LIST
31244: LIST
31245: PUSH
31246: LD_INT 1
31248: NEG
31249: PUSH
31250: LD_INT 3
31252: NEG
31253: PUSH
31254: EMPTY
31255: LIST
31256: LIST
31257: PUSH
31258: LD_INT 3
31260: NEG
31261: PUSH
31262: LD_INT 1
31264: NEG
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 3
31272: NEG
31273: PUSH
31274: LD_INT 2
31276: NEG
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: PUSH
31282: EMPTY
31283: LIST
31284: LIST
31285: LIST
31286: LIST
31287: LIST
31288: LIST
31289: LIST
31290: LIST
31291: LIST
31292: LIST
31293: LIST
31294: LIST
31295: LIST
31296: LIST
31297: LIST
31298: LIST
31299: LIST
31300: LIST
31301: LIST
31302: LIST
31303: LIST
31304: LIST
31305: LIST
31306: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31307: LD_ADDR_VAR 0 29
31311: PUSH
31312: LD_INT 0
31314: PUSH
31315: LD_INT 0
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: PUSH
31322: LD_INT 0
31324: PUSH
31325: LD_INT 1
31327: NEG
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: PUSH
31333: LD_INT 1
31335: PUSH
31336: LD_INT 0
31338: PUSH
31339: EMPTY
31340: LIST
31341: LIST
31342: PUSH
31343: LD_INT 1
31345: PUSH
31346: LD_INT 1
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 0
31355: PUSH
31356: LD_INT 1
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 1
31365: NEG
31366: PUSH
31367: LD_INT 0
31369: PUSH
31370: EMPTY
31371: LIST
31372: LIST
31373: PUSH
31374: LD_INT 1
31376: NEG
31377: PUSH
31378: LD_INT 1
31380: NEG
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: LD_INT 1
31388: NEG
31389: PUSH
31390: LD_INT 2
31392: NEG
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PUSH
31398: LD_INT 0
31400: PUSH
31401: LD_INT 2
31403: NEG
31404: PUSH
31405: EMPTY
31406: LIST
31407: LIST
31408: PUSH
31409: LD_INT 1
31411: PUSH
31412: LD_INT 1
31414: NEG
31415: PUSH
31416: EMPTY
31417: LIST
31418: LIST
31419: PUSH
31420: LD_INT 2
31422: PUSH
31423: LD_INT 0
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: LD_INT 2
31432: PUSH
31433: LD_INT 1
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: LD_INT 1
31442: PUSH
31443: LD_INT 2
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PUSH
31450: LD_INT 0
31452: PUSH
31453: LD_INT 2
31455: PUSH
31456: EMPTY
31457: LIST
31458: LIST
31459: PUSH
31460: LD_INT 1
31462: NEG
31463: PUSH
31464: LD_INT 1
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 2
31473: NEG
31474: PUSH
31475: LD_INT 1
31477: NEG
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: LD_INT 2
31485: NEG
31486: PUSH
31487: LD_INT 2
31489: NEG
31490: PUSH
31491: EMPTY
31492: LIST
31493: LIST
31494: PUSH
31495: LD_INT 2
31497: NEG
31498: PUSH
31499: LD_INT 3
31501: NEG
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 2
31509: PUSH
31510: LD_INT 1
31512: NEG
31513: PUSH
31514: EMPTY
31515: LIST
31516: LIST
31517: PUSH
31518: LD_INT 3
31520: PUSH
31521: LD_INT 1
31523: PUSH
31524: EMPTY
31525: LIST
31526: LIST
31527: PUSH
31528: LD_INT 1
31530: PUSH
31531: LD_INT 3
31533: PUSH
31534: EMPTY
31535: LIST
31536: LIST
31537: PUSH
31538: LD_INT 1
31540: NEG
31541: PUSH
31542: LD_INT 2
31544: PUSH
31545: EMPTY
31546: LIST
31547: LIST
31548: PUSH
31549: LD_INT 3
31551: NEG
31552: PUSH
31553: LD_INT 2
31555: NEG
31556: PUSH
31557: EMPTY
31558: LIST
31559: LIST
31560: PUSH
31561: EMPTY
31562: LIST
31563: LIST
31564: LIST
31565: LIST
31566: LIST
31567: LIST
31568: LIST
31569: LIST
31570: LIST
31571: LIST
31572: LIST
31573: LIST
31574: LIST
31575: LIST
31576: LIST
31577: LIST
31578: LIST
31579: LIST
31580: LIST
31581: LIST
31582: LIST
31583: LIST
31584: LIST
31585: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31586: LD_ADDR_VAR 0 30
31590: PUSH
31591: LD_INT 0
31593: PUSH
31594: LD_INT 0
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: LD_INT 0
31603: PUSH
31604: LD_INT 1
31606: NEG
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: LD_INT 1
31614: PUSH
31615: LD_INT 0
31617: PUSH
31618: EMPTY
31619: LIST
31620: LIST
31621: PUSH
31622: LD_INT 1
31624: PUSH
31625: LD_INT 1
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 0
31634: PUSH
31635: LD_INT 1
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: LD_INT 1
31644: NEG
31645: PUSH
31646: LD_INT 0
31648: PUSH
31649: EMPTY
31650: LIST
31651: LIST
31652: PUSH
31653: LD_INT 1
31655: NEG
31656: PUSH
31657: LD_INT 1
31659: NEG
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 1
31667: NEG
31668: PUSH
31669: LD_INT 2
31671: NEG
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 0
31679: PUSH
31680: LD_INT 2
31682: NEG
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 1
31690: PUSH
31691: LD_INT 1
31693: NEG
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 2
31701: PUSH
31702: LD_INT 0
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: LD_INT 2
31711: PUSH
31712: LD_INT 1
31714: PUSH
31715: EMPTY
31716: LIST
31717: LIST
31718: PUSH
31719: LD_INT 2
31721: PUSH
31722: LD_INT 2
31724: PUSH
31725: EMPTY
31726: LIST
31727: LIST
31728: PUSH
31729: LD_INT 1
31731: PUSH
31732: LD_INT 2
31734: PUSH
31735: EMPTY
31736: LIST
31737: LIST
31738: PUSH
31739: LD_INT 1
31741: NEG
31742: PUSH
31743: LD_INT 1
31745: PUSH
31746: EMPTY
31747: LIST
31748: LIST
31749: PUSH
31750: LD_INT 2
31752: NEG
31753: PUSH
31754: LD_INT 0
31756: PUSH
31757: EMPTY
31758: LIST
31759: LIST
31760: PUSH
31761: LD_INT 2
31763: NEG
31764: PUSH
31765: LD_INT 1
31767: NEG
31768: PUSH
31769: EMPTY
31770: LIST
31771: LIST
31772: PUSH
31773: LD_INT 1
31775: NEG
31776: PUSH
31777: LD_INT 3
31779: NEG
31780: PUSH
31781: EMPTY
31782: LIST
31783: LIST
31784: PUSH
31785: LD_INT 1
31787: PUSH
31788: LD_INT 2
31790: NEG
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PUSH
31796: LD_INT 3
31798: PUSH
31799: LD_INT 2
31801: PUSH
31802: EMPTY
31803: LIST
31804: LIST
31805: PUSH
31806: LD_INT 2
31808: PUSH
31809: LD_INT 3
31811: PUSH
31812: EMPTY
31813: LIST
31814: LIST
31815: PUSH
31816: LD_INT 2
31818: NEG
31819: PUSH
31820: LD_INT 1
31822: PUSH
31823: EMPTY
31824: LIST
31825: LIST
31826: PUSH
31827: LD_INT 3
31829: NEG
31830: PUSH
31831: LD_INT 1
31833: NEG
31834: PUSH
31835: EMPTY
31836: LIST
31837: LIST
31838: PUSH
31839: EMPTY
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: LIST
31845: LIST
31846: LIST
31847: LIST
31848: LIST
31849: LIST
31850: LIST
31851: LIST
31852: LIST
31853: LIST
31854: LIST
31855: LIST
31856: LIST
31857: LIST
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31864: LD_ADDR_VAR 0 31
31868: PUSH
31869: LD_INT 0
31871: PUSH
31872: LD_INT 0
31874: PUSH
31875: EMPTY
31876: LIST
31877: LIST
31878: PUSH
31879: LD_INT 0
31881: PUSH
31882: LD_INT 1
31884: NEG
31885: PUSH
31886: EMPTY
31887: LIST
31888: LIST
31889: PUSH
31890: LD_INT 1
31892: PUSH
31893: LD_INT 0
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PUSH
31900: LD_INT 1
31902: PUSH
31903: LD_INT 1
31905: PUSH
31906: EMPTY
31907: LIST
31908: LIST
31909: PUSH
31910: LD_INT 0
31912: PUSH
31913: LD_INT 1
31915: PUSH
31916: EMPTY
31917: LIST
31918: LIST
31919: PUSH
31920: LD_INT 1
31922: NEG
31923: PUSH
31924: LD_INT 0
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: LD_INT 1
31933: NEG
31934: PUSH
31935: LD_INT 1
31937: NEG
31938: PUSH
31939: EMPTY
31940: LIST
31941: LIST
31942: PUSH
31943: LD_INT 1
31945: NEG
31946: PUSH
31947: LD_INT 2
31949: NEG
31950: PUSH
31951: EMPTY
31952: LIST
31953: LIST
31954: PUSH
31955: LD_INT 1
31957: PUSH
31958: LD_INT 1
31960: NEG
31961: PUSH
31962: EMPTY
31963: LIST
31964: LIST
31965: PUSH
31966: LD_INT 2
31968: PUSH
31969: LD_INT 0
31971: PUSH
31972: EMPTY
31973: LIST
31974: LIST
31975: PUSH
31976: LD_INT 2
31978: PUSH
31979: LD_INT 1
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: LD_INT 2
31988: PUSH
31989: LD_INT 2
31991: PUSH
31992: EMPTY
31993: LIST
31994: LIST
31995: PUSH
31996: LD_INT 1
31998: PUSH
31999: LD_INT 2
32001: PUSH
32002: EMPTY
32003: LIST
32004: LIST
32005: PUSH
32006: LD_INT 0
32008: PUSH
32009: LD_INT 2
32011: PUSH
32012: EMPTY
32013: LIST
32014: LIST
32015: PUSH
32016: LD_INT 1
32018: NEG
32019: PUSH
32020: LD_INT 1
32022: PUSH
32023: EMPTY
32024: LIST
32025: LIST
32026: PUSH
32027: LD_INT 2
32029: NEG
32030: PUSH
32031: LD_INT 1
32033: NEG
32034: PUSH
32035: EMPTY
32036: LIST
32037: LIST
32038: PUSH
32039: LD_INT 2
32041: NEG
32042: PUSH
32043: LD_INT 2
32045: NEG
32046: PUSH
32047: EMPTY
32048: LIST
32049: LIST
32050: PUSH
32051: LD_INT 2
32053: NEG
32054: PUSH
32055: LD_INT 3
32057: NEG
32058: PUSH
32059: EMPTY
32060: LIST
32061: LIST
32062: PUSH
32063: LD_INT 2
32065: PUSH
32066: LD_INT 1
32068: NEG
32069: PUSH
32070: EMPTY
32071: LIST
32072: LIST
32073: PUSH
32074: LD_INT 3
32076: PUSH
32077: LD_INT 1
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: PUSH
32084: LD_INT 1
32086: PUSH
32087: LD_INT 3
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: PUSH
32094: LD_INT 1
32096: NEG
32097: PUSH
32098: LD_INT 2
32100: PUSH
32101: EMPTY
32102: LIST
32103: LIST
32104: PUSH
32105: LD_INT 3
32107: NEG
32108: PUSH
32109: LD_INT 2
32111: NEG
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: EMPTY
32118: LIST
32119: LIST
32120: LIST
32121: LIST
32122: LIST
32123: LIST
32124: LIST
32125: LIST
32126: LIST
32127: LIST
32128: LIST
32129: LIST
32130: LIST
32131: LIST
32132: LIST
32133: LIST
32134: LIST
32135: LIST
32136: LIST
32137: LIST
32138: LIST
32139: LIST
32140: LIST
32141: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32142: LD_ADDR_VAR 0 32
32146: PUSH
32147: LD_INT 0
32149: PUSH
32150: LD_INT 0
32152: PUSH
32153: EMPTY
32154: LIST
32155: LIST
32156: PUSH
32157: LD_INT 0
32159: PUSH
32160: LD_INT 1
32162: NEG
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 1
32170: PUSH
32171: LD_INT 0
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: LD_INT 1
32180: PUSH
32181: LD_INT 1
32183: PUSH
32184: EMPTY
32185: LIST
32186: LIST
32187: PUSH
32188: LD_INT 0
32190: PUSH
32191: LD_INT 1
32193: PUSH
32194: EMPTY
32195: LIST
32196: LIST
32197: PUSH
32198: LD_INT 1
32200: NEG
32201: PUSH
32202: LD_INT 0
32204: PUSH
32205: EMPTY
32206: LIST
32207: LIST
32208: PUSH
32209: LD_INT 1
32211: NEG
32212: PUSH
32213: LD_INT 1
32215: NEG
32216: PUSH
32217: EMPTY
32218: LIST
32219: LIST
32220: PUSH
32221: LD_INT 1
32223: NEG
32224: PUSH
32225: LD_INT 2
32227: NEG
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: PUSH
32233: LD_INT 0
32235: PUSH
32236: LD_INT 2
32238: NEG
32239: PUSH
32240: EMPTY
32241: LIST
32242: LIST
32243: PUSH
32244: LD_INT 1
32246: PUSH
32247: LD_INT 1
32249: NEG
32250: PUSH
32251: EMPTY
32252: LIST
32253: LIST
32254: PUSH
32255: LD_INT 2
32257: PUSH
32258: LD_INT 1
32260: PUSH
32261: EMPTY
32262: LIST
32263: LIST
32264: PUSH
32265: LD_INT 2
32267: PUSH
32268: LD_INT 2
32270: PUSH
32271: EMPTY
32272: LIST
32273: LIST
32274: PUSH
32275: LD_INT 1
32277: PUSH
32278: LD_INT 2
32280: PUSH
32281: EMPTY
32282: LIST
32283: LIST
32284: PUSH
32285: LD_INT 0
32287: PUSH
32288: LD_INT 2
32290: PUSH
32291: EMPTY
32292: LIST
32293: LIST
32294: PUSH
32295: LD_INT 1
32297: NEG
32298: PUSH
32299: LD_INT 1
32301: PUSH
32302: EMPTY
32303: LIST
32304: LIST
32305: PUSH
32306: LD_INT 2
32308: NEG
32309: PUSH
32310: LD_INT 0
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: PUSH
32317: LD_INT 2
32319: NEG
32320: PUSH
32321: LD_INT 1
32323: NEG
32324: PUSH
32325: EMPTY
32326: LIST
32327: LIST
32328: PUSH
32329: LD_INT 1
32331: NEG
32332: PUSH
32333: LD_INT 3
32335: NEG
32336: PUSH
32337: EMPTY
32338: LIST
32339: LIST
32340: PUSH
32341: LD_INT 1
32343: PUSH
32344: LD_INT 2
32346: NEG
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: PUSH
32352: LD_INT 3
32354: PUSH
32355: LD_INT 2
32357: PUSH
32358: EMPTY
32359: LIST
32360: LIST
32361: PUSH
32362: LD_INT 2
32364: PUSH
32365: LD_INT 3
32367: PUSH
32368: EMPTY
32369: LIST
32370: LIST
32371: PUSH
32372: LD_INT 2
32374: NEG
32375: PUSH
32376: LD_INT 1
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: LD_INT 3
32385: NEG
32386: PUSH
32387: LD_INT 1
32389: NEG
32390: PUSH
32391: EMPTY
32392: LIST
32393: LIST
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: LIST
32401: LIST
32402: LIST
32403: LIST
32404: LIST
32405: LIST
32406: LIST
32407: LIST
32408: LIST
32409: LIST
32410: LIST
32411: LIST
32412: LIST
32413: LIST
32414: LIST
32415: LIST
32416: LIST
32417: LIST
32418: LIST
32419: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32420: LD_ADDR_VAR 0 33
32424: PUSH
32425: LD_INT 0
32427: PUSH
32428: LD_INT 0
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: LD_INT 0
32437: PUSH
32438: LD_INT 1
32440: NEG
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: PUSH
32446: LD_INT 1
32448: PUSH
32449: LD_INT 0
32451: PUSH
32452: EMPTY
32453: LIST
32454: LIST
32455: PUSH
32456: LD_INT 1
32458: PUSH
32459: LD_INT 1
32461: PUSH
32462: EMPTY
32463: LIST
32464: LIST
32465: PUSH
32466: LD_INT 0
32468: PUSH
32469: LD_INT 1
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 1
32478: NEG
32479: PUSH
32480: LD_INT 0
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: PUSH
32487: LD_INT 1
32489: NEG
32490: PUSH
32491: LD_INT 1
32493: NEG
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: PUSH
32499: LD_INT 1
32501: NEG
32502: PUSH
32503: LD_INT 2
32505: NEG
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 1
32513: PUSH
32514: LD_INT 1
32516: NEG
32517: PUSH
32518: EMPTY
32519: LIST
32520: LIST
32521: PUSH
32522: LD_INT 2
32524: PUSH
32525: LD_INT 0
32527: PUSH
32528: EMPTY
32529: LIST
32530: LIST
32531: PUSH
32532: LD_INT 2
32534: PUSH
32535: LD_INT 1
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 1
32544: PUSH
32545: LD_INT 2
32547: PUSH
32548: EMPTY
32549: LIST
32550: LIST
32551: PUSH
32552: LD_INT 0
32554: PUSH
32555: LD_INT 2
32557: PUSH
32558: EMPTY
32559: LIST
32560: LIST
32561: PUSH
32562: LD_INT 1
32564: NEG
32565: PUSH
32566: LD_INT 1
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: LD_INT 2
32575: NEG
32576: PUSH
32577: LD_INT 0
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PUSH
32584: LD_INT 2
32586: NEG
32587: PUSH
32588: LD_INT 1
32590: NEG
32591: PUSH
32592: EMPTY
32593: LIST
32594: LIST
32595: PUSH
32596: LD_INT 2
32598: NEG
32599: PUSH
32600: LD_INT 2
32602: NEG
32603: PUSH
32604: EMPTY
32605: LIST
32606: LIST
32607: PUSH
32608: LD_INT 2
32610: NEG
32611: PUSH
32612: LD_INT 3
32614: NEG
32615: PUSH
32616: EMPTY
32617: LIST
32618: LIST
32619: PUSH
32620: LD_INT 2
32622: PUSH
32623: LD_INT 1
32625: NEG
32626: PUSH
32627: EMPTY
32628: LIST
32629: LIST
32630: PUSH
32631: LD_INT 3
32633: PUSH
32634: LD_INT 1
32636: PUSH
32637: EMPTY
32638: LIST
32639: LIST
32640: PUSH
32641: LD_INT 1
32643: PUSH
32644: LD_INT 3
32646: PUSH
32647: EMPTY
32648: LIST
32649: LIST
32650: PUSH
32651: LD_INT 1
32653: NEG
32654: PUSH
32655: LD_INT 2
32657: PUSH
32658: EMPTY
32659: LIST
32660: LIST
32661: PUSH
32662: LD_INT 3
32664: NEG
32665: PUSH
32666: LD_INT 2
32668: NEG
32669: PUSH
32670: EMPTY
32671: LIST
32672: LIST
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: LIST
32678: LIST
32679: LIST
32680: LIST
32681: LIST
32682: LIST
32683: LIST
32684: LIST
32685: LIST
32686: LIST
32687: LIST
32688: LIST
32689: LIST
32690: LIST
32691: LIST
32692: LIST
32693: LIST
32694: LIST
32695: LIST
32696: LIST
32697: LIST
32698: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32699: LD_ADDR_VAR 0 34
32703: PUSH
32704: LD_INT 0
32706: PUSH
32707: LD_INT 0
32709: PUSH
32710: EMPTY
32711: LIST
32712: LIST
32713: PUSH
32714: LD_INT 0
32716: PUSH
32717: LD_INT 1
32719: NEG
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: LD_INT 1
32727: PUSH
32728: LD_INT 0
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 1
32737: PUSH
32738: LD_INT 1
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 0
32747: PUSH
32748: LD_INT 1
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: NEG
32758: PUSH
32759: LD_INT 0
32761: PUSH
32762: EMPTY
32763: LIST
32764: LIST
32765: PUSH
32766: LD_INT 1
32768: NEG
32769: PUSH
32770: LD_INT 1
32772: NEG
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 1
32780: NEG
32781: PUSH
32782: LD_INT 2
32784: NEG
32785: PUSH
32786: EMPTY
32787: LIST
32788: LIST
32789: PUSH
32790: LD_INT 0
32792: PUSH
32793: LD_INT 2
32795: NEG
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PUSH
32801: LD_INT 1
32803: PUSH
32804: LD_INT 1
32806: NEG
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: LD_INT 2
32814: PUSH
32815: LD_INT 1
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PUSH
32822: LD_INT 2
32824: PUSH
32825: LD_INT 2
32827: PUSH
32828: EMPTY
32829: LIST
32830: LIST
32831: PUSH
32832: LD_INT 1
32834: PUSH
32835: LD_INT 2
32837: PUSH
32838: EMPTY
32839: LIST
32840: LIST
32841: PUSH
32842: LD_INT 1
32844: NEG
32845: PUSH
32846: LD_INT 1
32848: PUSH
32849: EMPTY
32850: LIST
32851: LIST
32852: PUSH
32853: LD_INT 2
32855: NEG
32856: PUSH
32857: LD_INT 0
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 2
32866: NEG
32867: PUSH
32868: LD_INT 1
32870: NEG
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 2
32878: NEG
32879: PUSH
32880: LD_INT 2
32882: NEG
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PUSH
32888: LD_INT 1
32890: NEG
32891: PUSH
32892: LD_INT 3
32894: NEG
32895: PUSH
32896: EMPTY
32897: LIST
32898: LIST
32899: PUSH
32900: LD_INT 1
32902: PUSH
32903: LD_INT 2
32905: NEG
32906: PUSH
32907: EMPTY
32908: LIST
32909: LIST
32910: PUSH
32911: LD_INT 3
32913: PUSH
32914: LD_INT 2
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: PUSH
32921: LD_INT 2
32923: PUSH
32924: LD_INT 3
32926: PUSH
32927: EMPTY
32928: LIST
32929: LIST
32930: PUSH
32931: LD_INT 2
32933: NEG
32934: PUSH
32935: LD_INT 1
32937: PUSH
32938: EMPTY
32939: LIST
32940: LIST
32941: PUSH
32942: LD_INT 3
32944: NEG
32945: PUSH
32946: LD_INT 1
32948: NEG
32949: PUSH
32950: EMPTY
32951: LIST
32952: LIST
32953: PUSH
32954: EMPTY
32955: LIST
32956: LIST
32957: LIST
32958: LIST
32959: LIST
32960: LIST
32961: LIST
32962: LIST
32963: LIST
32964: LIST
32965: LIST
32966: LIST
32967: LIST
32968: LIST
32969: LIST
32970: LIST
32971: LIST
32972: LIST
32973: LIST
32974: LIST
32975: LIST
32976: LIST
32977: LIST
32978: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
32979: LD_ADDR_VAR 0 35
32983: PUSH
32984: LD_INT 0
32986: PUSH
32987: LD_INT 0
32989: PUSH
32990: EMPTY
32991: LIST
32992: LIST
32993: PUSH
32994: LD_INT 0
32996: PUSH
32997: LD_INT 1
32999: NEG
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PUSH
33005: LD_INT 1
33007: PUSH
33008: LD_INT 0
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 1
33017: PUSH
33018: LD_INT 1
33020: PUSH
33021: EMPTY
33022: LIST
33023: LIST
33024: PUSH
33025: LD_INT 0
33027: PUSH
33028: LD_INT 1
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 1
33037: NEG
33038: PUSH
33039: LD_INT 0
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: LD_INT 1
33048: NEG
33049: PUSH
33050: LD_INT 1
33052: NEG
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PUSH
33058: LD_INT 2
33060: PUSH
33061: LD_INT 1
33063: PUSH
33064: EMPTY
33065: LIST
33066: LIST
33067: PUSH
33068: LD_INT 2
33070: NEG
33071: PUSH
33072: LD_INT 1
33074: NEG
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: LIST
33086: LIST
33087: LIST
33088: LIST
33089: LIST
33090: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33091: LD_ADDR_VAR 0 36
33095: PUSH
33096: LD_INT 0
33098: PUSH
33099: LD_INT 0
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: PUSH
33106: LD_INT 0
33108: PUSH
33109: LD_INT 1
33111: NEG
33112: PUSH
33113: EMPTY
33114: LIST
33115: LIST
33116: PUSH
33117: LD_INT 1
33119: PUSH
33120: LD_INT 0
33122: PUSH
33123: EMPTY
33124: LIST
33125: LIST
33126: PUSH
33127: LD_INT 1
33129: PUSH
33130: LD_INT 1
33132: PUSH
33133: EMPTY
33134: LIST
33135: LIST
33136: PUSH
33137: LD_INT 0
33139: PUSH
33140: LD_INT 1
33142: PUSH
33143: EMPTY
33144: LIST
33145: LIST
33146: PUSH
33147: LD_INT 1
33149: NEG
33150: PUSH
33151: LD_INT 0
33153: PUSH
33154: EMPTY
33155: LIST
33156: LIST
33157: PUSH
33158: LD_INT 1
33160: NEG
33161: PUSH
33162: LD_INT 1
33164: NEG
33165: PUSH
33166: EMPTY
33167: LIST
33168: LIST
33169: PUSH
33170: LD_INT 1
33172: NEG
33173: PUSH
33174: LD_INT 2
33176: NEG
33177: PUSH
33178: EMPTY
33179: LIST
33180: LIST
33181: PUSH
33182: LD_INT 1
33184: PUSH
33185: LD_INT 2
33187: PUSH
33188: EMPTY
33189: LIST
33190: LIST
33191: PUSH
33192: EMPTY
33193: LIST
33194: LIST
33195: LIST
33196: LIST
33197: LIST
33198: LIST
33199: LIST
33200: LIST
33201: LIST
33202: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33203: LD_ADDR_VAR 0 37
33207: PUSH
33208: LD_INT 0
33210: PUSH
33211: LD_INT 0
33213: PUSH
33214: EMPTY
33215: LIST
33216: LIST
33217: PUSH
33218: LD_INT 0
33220: PUSH
33221: LD_INT 1
33223: NEG
33224: PUSH
33225: EMPTY
33226: LIST
33227: LIST
33228: PUSH
33229: LD_INT 1
33231: PUSH
33232: LD_INT 0
33234: PUSH
33235: EMPTY
33236: LIST
33237: LIST
33238: PUSH
33239: LD_INT 1
33241: PUSH
33242: LD_INT 1
33244: PUSH
33245: EMPTY
33246: LIST
33247: LIST
33248: PUSH
33249: LD_INT 0
33251: PUSH
33252: LD_INT 1
33254: PUSH
33255: EMPTY
33256: LIST
33257: LIST
33258: PUSH
33259: LD_INT 1
33261: NEG
33262: PUSH
33263: LD_INT 0
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 1
33272: NEG
33273: PUSH
33274: LD_INT 1
33276: NEG
33277: PUSH
33278: EMPTY
33279: LIST
33280: LIST
33281: PUSH
33282: LD_INT 1
33284: PUSH
33285: LD_INT 1
33287: NEG
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PUSH
33293: LD_INT 1
33295: NEG
33296: PUSH
33297: LD_INT 1
33299: PUSH
33300: EMPTY
33301: LIST
33302: LIST
33303: PUSH
33304: EMPTY
33305: LIST
33306: LIST
33307: LIST
33308: LIST
33309: LIST
33310: LIST
33311: LIST
33312: LIST
33313: LIST
33314: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33315: LD_ADDR_VAR 0 38
33319: PUSH
33320: LD_INT 0
33322: PUSH
33323: LD_INT 0
33325: PUSH
33326: EMPTY
33327: LIST
33328: LIST
33329: PUSH
33330: LD_INT 0
33332: PUSH
33333: LD_INT 1
33335: NEG
33336: PUSH
33337: EMPTY
33338: LIST
33339: LIST
33340: PUSH
33341: LD_INT 1
33343: PUSH
33344: LD_INT 0
33346: PUSH
33347: EMPTY
33348: LIST
33349: LIST
33350: PUSH
33351: LD_INT 1
33353: PUSH
33354: LD_INT 1
33356: PUSH
33357: EMPTY
33358: LIST
33359: LIST
33360: PUSH
33361: LD_INT 0
33363: PUSH
33364: LD_INT 1
33366: PUSH
33367: EMPTY
33368: LIST
33369: LIST
33370: PUSH
33371: LD_INT 1
33373: NEG
33374: PUSH
33375: LD_INT 0
33377: PUSH
33378: EMPTY
33379: LIST
33380: LIST
33381: PUSH
33382: LD_INT 1
33384: NEG
33385: PUSH
33386: LD_INT 1
33388: NEG
33389: PUSH
33390: EMPTY
33391: LIST
33392: LIST
33393: PUSH
33394: LD_INT 2
33396: PUSH
33397: LD_INT 1
33399: PUSH
33400: EMPTY
33401: LIST
33402: LIST
33403: PUSH
33404: LD_INT 2
33406: NEG
33407: PUSH
33408: LD_INT 1
33410: NEG
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: LIST
33420: LIST
33421: LIST
33422: LIST
33423: LIST
33424: LIST
33425: LIST
33426: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33427: LD_ADDR_VAR 0 39
33431: PUSH
33432: LD_INT 0
33434: PUSH
33435: LD_INT 0
33437: PUSH
33438: EMPTY
33439: LIST
33440: LIST
33441: PUSH
33442: LD_INT 0
33444: PUSH
33445: LD_INT 1
33447: NEG
33448: PUSH
33449: EMPTY
33450: LIST
33451: LIST
33452: PUSH
33453: LD_INT 1
33455: PUSH
33456: LD_INT 0
33458: PUSH
33459: EMPTY
33460: LIST
33461: LIST
33462: PUSH
33463: LD_INT 1
33465: PUSH
33466: LD_INT 1
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 0
33475: PUSH
33476: LD_INT 1
33478: PUSH
33479: EMPTY
33480: LIST
33481: LIST
33482: PUSH
33483: LD_INT 1
33485: NEG
33486: PUSH
33487: LD_INT 0
33489: PUSH
33490: EMPTY
33491: LIST
33492: LIST
33493: PUSH
33494: LD_INT 1
33496: NEG
33497: PUSH
33498: LD_INT 1
33500: NEG
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 1
33508: NEG
33509: PUSH
33510: LD_INT 2
33512: NEG
33513: PUSH
33514: EMPTY
33515: LIST
33516: LIST
33517: PUSH
33518: LD_INT 1
33520: PUSH
33521: LD_INT 2
33523: PUSH
33524: EMPTY
33525: LIST
33526: LIST
33527: PUSH
33528: EMPTY
33529: LIST
33530: LIST
33531: LIST
33532: LIST
33533: LIST
33534: LIST
33535: LIST
33536: LIST
33537: LIST
33538: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33539: LD_ADDR_VAR 0 40
33543: PUSH
33544: LD_INT 0
33546: PUSH
33547: LD_INT 0
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 0
33556: PUSH
33557: LD_INT 1
33559: NEG
33560: PUSH
33561: EMPTY
33562: LIST
33563: LIST
33564: PUSH
33565: LD_INT 1
33567: PUSH
33568: LD_INT 0
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 1
33577: PUSH
33578: LD_INT 1
33580: PUSH
33581: EMPTY
33582: LIST
33583: LIST
33584: PUSH
33585: LD_INT 0
33587: PUSH
33588: LD_INT 1
33590: PUSH
33591: EMPTY
33592: LIST
33593: LIST
33594: PUSH
33595: LD_INT 1
33597: NEG
33598: PUSH
33599: LD_INT 0
33601: PUSH
33602: EMPTY
33603: LIST
33604: LIST
33605: PUSH
33606: LD_INT 1
33608: NEG
33609: PUSH
33610: LD_INT 1
33612: NEG
33613: PUSH
33614: EMPTY
33615: LIST
33616: LIST
33617: PUSH
33618: LD_INT 1
33620: PUSH
33621: LD_INT 1
33623: NEG
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 1
33631: NEG
33632: PUSH
33633: LD_INT 1
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: EMPTY
33641: LIST
33642: LIST
33643: LIST
33644: LIST
33645: LIST
33646: LIST
33647: LIST
33648: LIST
33649: LIST
33650: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33651: LD_ADDR_VAR 0 41
33655: PUSH
33656: LD_INT 0
33658: PUSH
33659: LD_INT 0
33661: PUSH
33662: EMPTY
33663: LIST
33664: LIST
33665: PUSH
33666: LD_INT 0
33668: PUSH
33669: LD_INT 1
33671: NEG
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 1
33679: PUSH
33680: LD_INT 0
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 1
33689: PUSH
33690: LD_INT 1
33692: PUSH
33693: EMPTY
33694: LIST
33695: LIST
33696: PUSH
33697: LD_INT 0
33699: PUSH
33700: LD_INT 1
33702: PUSH
33703: EMPTY
33704: LIST
33705: LIST
33706: PUSH
33707: LD_INT 1
33709: NEG
33710: PUSH
33711: LD_INT 0
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 1
33720: NEG
33721: PUSH
33722: LD_INT 1
33724: NEG
33725: PUSH
33726: EMPTY
33727: LIST
33728: LIST
33729: PUSH
33730: LD_INT 1
33732: NEG
33733: PUSH
33734: LD_INT 2
33736: NEG
33737: PUSH
33738: EMPTY
33739: LIST
33740: LIST
33741: PUSH
33742: LD_INT 1
33744: PUSH
33745: LD_INT 1
33747: NEG
33748: PUSH
33749: EMPTY
33750: LIST
33751: LIST
33752: PUSH
33753: LD_INT 2
33755: PUSH
33756: LD_INT 0
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 2
33765: PUSH
33766: LD_INT 1
33768: PUSH
33769: EMPTY
33770: LIST
33771: LIST
33772: PUSH
33773: LD_INT 2
33775: PUSH
33776: LD_INT 2
33778: PUSH
33779: EMPTY
33780: LIST
33781: LIST
33782: PUSH
33783: LD_INT 1
33785: PUSH
33786: LD_INT 2
33788: PUSH
33789: EMPTY
33790: LIST
33791: LIST
33792: PUSH
33793: LD_INT 1
33795: NEG
33796: PUSH
33797: LD_INT 1
33799: PUSH
33800: EMPTY
33801: LIST
33802: LIST
33803: PUSH
33804: LD_INT 2
33806: NEG
33807: PUSH
33808: LD_INT 0
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: PUSH
33815: LD_INT 2
33817: NEG
33818: PUSH
33819: LD_INT 1
33821: NEG
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 2
33829: NEG
33830: PUSH
33831: LD_INT 2
33833: NEG
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PUSH
33839: LD_INT 2
33841: NEG
33842: PUSH
33843: LD_INT 3
33845: NEG
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 2
33853: PUSH
33854: LD_INT 1
33856: NEG
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 3
33864: PUSH
33865: LD_INT 0
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: LD_INT 3
33874: PUSH
33875: LD_INT 1
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: LD_INT 3
33884: PUSH
33885: LD_INT 2
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: PUSH
33892: LD_INT 3
33894: PUSH
33895: LD_INT 3
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: LD_INT 2
33904: PUSH
33905: LD_INT 3
33907: PUSH
33908: EMPTY
33909: LIST
33910: LIST
33911: PUSH
33912: LD_INT 2
33914: NEG
33915: PUSH
33916: LD_INT 1
33918: PUSH
33919: EMPTY
33920: LIST
33921: LIST
33922: PUSH
33923: LD_INT 3
33925: NEG
33926: PUSH
33927: LD_INT 0
33929: PUSH
33930: EMPTY
33931: LIST
33932: LIST
33933: PUSH
33934: LD_INT 3
33936: NEG
33937: PUSH
33938: LD_INT 1
33940: NEG
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 3
33948: NEG
33949: PUSH
33950: LD_INT 2
33952: NEG
33953: PUSH
33954: EMPTY
33955: LIST
33956: LIST
33957: PUSH
33958: LD_INT 3
33960: NEG
33961: PUSH
33962: LD_INT 3
33964: NEG
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: EMPTY
33971: LIST
33972: LIST
33973: LIST
33974: LIST
33975: LIST
33976: LIST
33977: LIST
33978: LIST
33979: LIST
33980: LIST
33981: LIST
33982: LIST
33983: LIST
33984: LIST
33985: LIST
33986: LIST
33987: LIST
33988: LIST
33989: LIST
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34001: LD_ADDR_VAR 0 42
34005: PUSH
34006: LD_INT 0
34008: PUSH
34009: LD_INT 0
34011: PUSH
34012: EMPTY
34013: LIST
34014: LIST
34015: PUSH
34016: LD_INT 0
34018: PUSH
34019: LD_INT 1
34021: NEG
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: LD_INT 1
34029: PUSH
34030: LD_INT 0
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: PUSH
34037: LD_INT 1
34039: PUSH
34040: LD_INT 1
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: PUSH
34047: LD_INT 0
34049: PUSH
34050: LD_INT 1
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: PUSH
34057: LD_INT 1
34059: NEG
34060: PUSH
34061: LD_INT 0
34063: PUSH
34064: EMPTY
34065: LIST
34066: LIST
34067: PUSH
34068: LD_INT 1
34070: NEG
34071: PUSH
34072: LD_INT 1
34074: NEG
34075: PUSH
34076: EMPTY
34077: LIST
34078: LIST
34079: PUSH
34080: LD_INT 1
34082: NEG
34083: PUSH
34084: LD_INT 2
34086: NEG
34087: PUSH
34088: EMPTY
34089: LIST
34090: LIST
34091: PUSH
34092: LD_INT 0
34094: PUSH
34095: LD_INT 2
34097: NEG
34098: PUSH
34099: EMPTY
34100: LIST
34101: LIST
34102: PUSH
34103: LD_INT 1
34105: PUSH
34106: LD_INT 1
34108: NEG
34109: PUSH
34110: EMPTY
34111: LIST
34112: LIST
34113: PUSH
34114: LD_INT 2
34116: PUSH
34117: LD_INT 1
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PUSH
34124: LD_INT 2
34126: PUSH
34127: LD_INT 2
34129: PUSH
34130: EMPTY
34131: LIST
34132: LIST
34133: PUSH
34134: LD_INT 1
34136: PUSH
34137: LD_INT 2
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: PUSH
34144: LD_INT 0
34146: PUSH
34147: LD_INT 2
34149: PUSH
34150: EMPTY
34151: LIST
34152: LIST
34153: PUSH
34154: LD_INT 1
34156: NEG
34157: PUSH
34158: LD_INT 1
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PUSH
34165: LD_INT 2
34167: NEG
34168: PUSH
34169: LD_INT 1
34171: NEG
34172: PUSH
34173: EMPTY
34174: LIST
34175: LIST
34176: PUSH
34177: LD_INT 2
34179: NEG
34180: PUSH
34181: LD_INT 2
34183: NEG
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: PUSH
34189: LD_INT 2
34191: NEG
34192: PUSH
34193: LD_INT 3
34195: NEG
34196: PUSH
34197: EMPTY
34198: LIST
34199: LIST
34200: PUSH
34201: LD_INT 1
34203: NEG
34204: PUSH
34205: LD_INT 3
34207: NEG
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 0
34215: PUSH
34216: LD_INT 3
34218: NEG
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 1
34226: PUSH
34227: LD_INT 2
34229: NEG
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 3
34237: PUSH
34238: LD_INT 2
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PUSH
34245: LD_INT 3
34247: PUSH
34248: LD_INT 3
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 2
34257: PUSH
34258: LD_INT 3
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PUSH
34265: LD_INT 1
34267: PUSH
34268: LD_INT 3
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 0
34277: PUSH
34278: LD_INT 3
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 1
34287: NEG
34288: PUSH
34289: LD_INT 2
34291: PUSH
34292: EMPTY
34293: LIST
34294: LIST
34295: PUSH
34296: LD_INT 3
34298: NEG
34299: PUSH
34300: LD_INT 2
34302: NEG
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: PUSH
34308: LD_INT 3
34310: NEG
34311: PUSH
34312: LD_INT 3
34314: NEG
34315: PUSH
34316: EMPTY
34317: LIST
34318: LIST
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: LIST
34324: LIST
34325: LIST
34326: LIST
34327: LIST
34328: LIST
34329: LIST
34330: LIST
34331: LIST
34332: LIST
34333: LIST
34334: LIST
34335: LIST
34336: LIST
34337: LIST
34338: LIST
34339: LIST
34340: LIST
34341: LIST
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: LIST
34349: LIST
34350: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34351: LD_ADDR_VAR 0 43
34355: PUSH
34356: LD_INT 0
34358: PUSH
34359: LD_INT 0
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: PUSH
34366: LD_INT 0
34368: PUSH
34369: LD_INT 1
34371: NEG
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 1
34379: PUSH
34380: LD_INT 0
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: PUSH
34390: LD_INT 1
34392: PUSH
34393: EMPTY
34394: LIST
34395: LIST
34396: PUSH
34397: LD_INT 0
34399: PUSH
34400: LD_INT 1
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PUSH
34407: LD_INT 1
34409: NEG
34410: PUSH
34411: LD_INT 0
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 1
34420: NEG
34421: PUSH
34422: LD_INT 1
34424: NEG
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: PUSH
34430: LD_INT 1
34432: NEG
34433: PUSH
34434: LD_INT 2
34436: NEG
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PUSH
34442: LD_INT 0
34444: PUSH
34445: LD_INT 2
34447: NEG
34448: PUSH
34449: EMPTY
34450: LIST
34451: LIST
34452: PUSH
34453: LD_INT 1
34455: PUSH
34456: LD_INT 1
34458: NEG
34459: PUSH
34460: EMPTY
34461: LIST
34462: LIST
34463: PUSH
34464: LD_INT 2
34466: PUSH
34467: LD_INT 0
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 2
34476: PUSH
34477: LD_INT 1
34479: PUSH
34480: EMPTY
34481: LIST
34482: LIST
34483: PUSH
34484: LD_INT 1
34486: PUSH
34487: LD_INT 2
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: PUSH
34494: LD_INT 0
34496: PUSH
34497: LD_INT 2
34499: PUSH
34500: EMPTY
34501: LIST
34502: LIST
34503: PUSH
34504: LD_INT 1
34506: NEG
34507: PUSH
34508: LD_INT 1
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 2
34517: NEG
34518: PUSH
34519: LD_INT 0
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 2
34528: NEG
34529: PUSH
34530: LD_INT 1
34532: NEG
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 1
34540: NEG
34541: PUSH
34542: LD_INT 3
34544: NEG
34545: PUSH
34546: EMPTY
34547: LIST
34548: LIST
34549: PUSH
34550: LD_INT 0
34552: PUSH
34553: LD_INT 3
34555: NEG
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 1
34563: PUSH
34564: LD_INT 2
34566: NEG
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: PUSH
34572: LD_INT 2
34574: PUSH
34575: LD_INT 1
34577: NEG
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PUSH
34583: LD_INT 3
34585: PUSH
34586: LD_INT 0
34588: PUSH
34589: EMPTY
34590: LIST
34591: LIST
34592: PUSH
34593: LD_INT 3
34595: PUSH
34596: LD_INT 1
34598: PUSH
34599: EMPTY
34600: LIST
34601: LIST
34602: PUSH
34603: LD_INT 1
34605: PUSH
34606: LD_INT 3
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 0
34615: PUSH
34616: LD_INT 3
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: LD_INT 1
34625: NEG
34626: PUSH
34627: LD_INT 2
34629: PUSH
34630: EMPTY
34631: LIST
34632: LIST
34633: PUSH
34634: LD_INT 2
34636: NEG
34637: PUSH
34638: LD_INT 1
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 3
34647: NEG
34648: PUSH
34649: LD_INT 0
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 3
34658: NEG
34659: PUSH
34660: LD_INT 1
34662: NEG
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: LIST
34672: LIST
34673: LIST
34674: LIST
34675: LIST
34676: LIST
34677: LIST
34678: LIST
34679: LIST
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: LIST
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: LIST
34697: LIST
34698: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34699: LD_ADDR_VAR 0 44
34703: PUSH
34704: LD_INT 0
34706: PUSH
34707: LD_INT 0
34709: PUSH
34710: EMPTY
34711: LIST
34712: LIST
34713: PUSH
34714: LD_INT 0
34716: PUSH
34717: LD_INT 1
34719: NEG
34720: PUSH
34721: EMPTY
34722: LIST
34723: LIST
34724: PUSH
34725: LD_INT 1
34727: PUSH
34728: LD_INT 0
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: LD_INT 1
34737: PUSH
34738: LD_INT 1
34740: PUSH
34741: EMPTY
34742: LIST
34743: LIST
34744: PUSH
34745: LD_INT 0
34747: PUSH
34748: LD_INT 1
34750: PUSH
34751: EMPTY
34752: LIST
34753: LIST
34754: PUSH
34755: LD_INT 1
34757: NEG
34758: PUSH
34759: LD_INT 0
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: PUSH
34766: LD_INT 1
34768: NEG
34769: PUSH
34770: LD_INT 1
34772: NEG
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: PUSH
34778: LD_INT 1
34780: NEG
34781: PUSH
34782: LD_INT 2
34784: NEG
34785: PUSH
34786: EMPTY
34787: LIST
34788: LIST
34789: PUSH
34790: LD_INT 1
34792: PUSH
34793: LD_INT 1
34795: NEG
34796: PUSH
34797: EMPTY
34798: LIST
34799: LIST
34800: PUSH
34801: LD_INT 2
34803: PUSH
34804: LD_INT 0
34806: PUSH
34807: EMPTY
34808: LIST
34809: LIST
34810: PUSH
34811: LD_INT 2
34813: PUSH
34814: LD_INT 1
34816: PUSH
34817: EMPTY
34818: LIST
34819: LIST
34820: PUSH
34821: LD_INT 2
34823: PUSH
34824: LD_INT 2
34826: PUSH
34827: EMPTY
34828: LIST
34829: LIST
34830: PUSH
34831: LD_INT 1
34833: PUSH
34834: LD_INT 2
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 1
34843: NEG
34844: PUSH
34845: LD_INT 1
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 2
34854: NEG
34855: PUSH
34856: LD_INT 0
34858: PUSH
34859: EMPTY
34860: LIST
34861: LIST
34862: PUSH
34863: LD_INT 2
34865: NEG
34866: PUSH
34867: LD_INT 1
34869: NEG
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 2
34877: NEG
34878: PUSH
34879: LD_INT 2
34881: NEG
34882: PUSH
34883: EMPTY
34884: LIST
34885: LIST
34886: PUSH
34887: LD_INT 2
34889: NEG
34890: PUSH
34891: LD_INT 3
34893: NEG
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: PUSH
34899: LD_INT 2
34901: PUSH
34902: LD_INT 1
34904: NEG
34905: PUSH
34906: EMPTY
34907: LIST
34908: LIST
34909: PUSH
34910: LD_INT 3
34912: PUSH
34913: LD_INT 0
34915: PUSH
34916: EMPTY
34917: LIST
34918: LIST
34919: PUSH
34920: LD_INT 3
34922: PUSH
34923: LD_INT 1
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 3
34932: PUSH
34933: LD_INT 2
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: LD_INT 3
34942: PUSH
34943: LD_INT 3
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: PUSH
34950: LD_INT 2
34952: PUSH
34953: LD_INT 3
34955: PUSH
34956: EMPTY
34957: LIST
34958: LIST
34959: PUSH
34960: LD_INT 2
34962: NEG
34963: PUSH
34964: LD_INT 1
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: LD_INT 3
34973: NEG
34974: PUSH
34975: LD_INT 0
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 3
34984: NEG
34985: PUSH
34986: LD_INT 1
34988: NEG
34989: PUSH
34990: EMPTY
34991: LIST
34992: LIST
34993: PUSH
34994: LD_INT 3
34996: NEG
34997: PUSH
34998: LD_INT 2
35000: NEG
35001: PUSH
35002: EMPTY
35003: LIST
35004: LIST
35005: PUSH
35006: LD_INT 3
35008: NEG
35009: PUSH
35010: LD_INT 3
35012: NEG
35013: PUSH
35014: EMPTY
35015: LIST
35016: LIST
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: LIST
35022: LIST
35023: LIST
35024: LIST
35025: LIST
35026: LIST
35027: LIST
35028: LIST
35029: LIST
35030: LIST
35031: LIST
35032: LIST
35033: LIST
35034: LIST
35035: LIST
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35049: LD_ADDR_VAR 0 45
35053: PUSH
35054: LD_INT 0
35056: PUSH
35057: LD_INT 0
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: LD_INT 0
35066: PUSH
35067: LD_INT 1
35069: NEG
35070: PUSH
35071: EMPTY
35072: LIST
35073: LIST
35074: PUSH
35075: LD_INT 1
35077: PUSH
35078: LD_INT 0
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PUSH
35085: LD_INT 1
35087: PUSH
35088: LD_INT 1
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PUSH
35095: LD_INT 0
35097: PUSH
35098: LD_INT 1
35100: PUSH
35101: EMPTY
35102: LIST
35103: LIST
35104: PUSH
35105: LD_INT 1
35107: NEG
35108: PUSH
35109: LD_INT 0
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: PUSH
35116: LD_INT 1
35118: NEG
35119: PUSH
35120: LD_INT 1
35122: NEG
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 1
35130: NEG
35131: PUSH
35132: LD_INT 2
35134: NEG
35135: PUSH
35136: EMPTY
35137: LIST
35138: LIST
35139: PUSH
35140: LD_INT 0
35142: PUSH
35143: LD_INT 2
35145: NEG
35146: PUSH
35147: EMPTY
35148: LIST
35149: LIST
35150: PUSH
35151: LD_INT 1
35153: PUSH
35154: LD_INT 1
35156: NEG
35157: PUSH
35158: EMPTY
35159: LIST
35160: LIST
35161: PUSH
35162: LD_INT 2
35164: PUSH
35165: LD_INT 1
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: PUSH
35172: LD_INT 2
35174: PUSH
35175: LD_INT 2
35177: PUSH
35178: EMPTY
35179: LIST
35180: LIST
35181: PUSH
35182: LD_INT 1
35184: PUSH
35185: LD_INT 2
35187: PUSH
35188: EMPTY
35189: LIST
35190: LIST
35191: PUSH
35192: LD_INT 0
35194: PUSH
35195: LD_INT 2
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: PUSH
35202: LD_INT 1
35204: NEG
35205: PUSH
35206: LD_INT 1
35208: PUSH
35209: EMPTY
35210: LIST
35211: LIST
35212: PUSH
35213: LD_INT 2
35215: NEG
35216: PUSH
35217: LD_INT 1
35219: NEG
35220: PUSH
35221: EMPTY
35222: LIST
35223: LIST
35224: PUSH
35225: LD_INT 2
35227: NEG
35228: PUSH
35229: LD_INT 2
35231: NEG
35232: PUSH
35233: EMPTY
35234: LIST
35235: LIST
35236: PUSH
35237: LD_INT 2
35239: NEG
35240: PUSH
35241: LD_INT 3
35243: NEG
35244: PUSH
35245: EMPTY
35246: LIST
35247: LIST
35248: PUSH
35249: LD_INT 1
35251: NEG
35252: PUSH
35253: LD_INT 3
35255: NEG
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 0
35263: PUSH
35264: LD_INT 3
35266: NEG
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 1
35274: PUSH
35275: LD_INT 2
35277: NEG
35278: PUSH
35279: EMPTY
35280: LIST
35281: LIST
35282: PUSH
35283: LD_INT 3
35285: PUSH
35286: LD_INT 2
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: PUSH
35293: LD_INT 3
35295: PUSH
35296: LD_INT 3
35298: PUSH
35299: EMPTY
35300: LIST
35301: LIST
35302: PUSH
35303: LD_INT 2
35305: PUSH
35306: LD_INT 3
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: PUSH
35316: LD_INT 3
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: PUSH
35323: LD_INT 0
35325: PUSH
35326: LD_INT 3
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 1
35335: NEG
35336: PUSH
35337: LD_INT 2
35339: PUSH
35340: EMPTY
35341: LIST
35342: LIST
35343: PUSH
35344: LD_INT 3
35346: NEG
35347: PUSH
35348: LD_INT 2
35350: NEG
35351: PUSH
35352: EMPTY
35353: LIST
35354: LIST
35355: PUSH
35356: LD_INT 3
35358: NEG
35359: PUSH
35360: LD_INT 3
35362: NEG
35363: PUSH
35364: EMPTY
35365: LIST
35366: LIST
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: LIST
35372: LIST
35373: LIST
35374: LIST
35375: LIST
35376: LIST
35377: LIST
35378: LIST
35379: LIST
35380: LIST
35381: LIST
35382: LIST
35383: LIST
35384: LIST
35385: LIST
35386: LIST
35387: LIST
35388: LIST
35389: LIST
35390: LIST
35391: LIST
35392: LIST
35393: LIST
35394: LIST
35395: LIST
35396: LIST
35397: LIST
35398: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35399: LD_ADDR_VAR 0 46
35403: PUSH
35404: LD_INT 0
35406: PUSH
35407: LD_INT 0
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 0
35416: PUSH
35417: LD_INT 1
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: LD_INT 0
35430: PUSH
35431: EMPTY
35432: LIST
35433: LIST
35434: PUSH
35435: LD_INT 1
35437: PUSH
35438: LD_INT 1
35440: PUSH
35441: EMPTY
35442: LIST
35443: LIST
35444: PUSH
35445: LD_INT 0
35447: PUSH
35448: LD_INT 1
35450: PUSH
35451: EMPTY
35452: LIST
35453: LIST
35454: PUSH
35455: LD_INT 1
35457: NEG
35458: PUSH
35459: LD_INT 0
35461: PUSH
35462: EMPTY
35463: LIST
35464: LIST
35465: PUSH
35466: LD_INT 1
35468: NEG
35469: PUSH
35470: LD_INT 1
35472: NEG
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: PUSH
35478: LD_INT 1
35480: NEG
35481: PUSH
35482: LD_INT 2
35484: NEG
35485: PUSH
35486: EMPTY
35487: LIST
35488: LIST
35489: PUSH
35490: LD_INT 0
35492: PUSH
35493: LD_INT 2
35495: NEG
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 1
35503: PUSH
35504: LD_INT 1
35506: NEG
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 2
35514: PUSH
35515: LD_INT 0
35517: PUSH
35518: EMPTY
35519: LIST
35520: LIST
35521: PUSH
35522: LD_INT 2
35524: PUSH
35525: LD_INT 1
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 1
35534: PUSH
35535: LD_INT 2
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: LD_INT 0
35544: PUSH
35545: LD_INT 2
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: PUSH
35552: LD_INT 1
35554: NEG
35555: PUSH
35556: LD_INT 1
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: PUSH
35563: LD_INT 2
35565: NEG
35566: PUSH
35567: LD_INT 0
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: PUSH
35574: LD_INT 2
35576: NEG
35577: PUSH
35578: LD_INT 1
35580: NEG
35581: PUSH
35582: EMPTY
35583: LIST
35584: LIST
35585: PUSH
35586: LD_INT 1
35588: NEG
35589: PUSH
35590: LD_INT 3
35592: NEG
35593: PUSH
35594: EMPTY
35595: LIST
35596: LIST
35597: PUSH
35598: LD_INT 0
35600: PUSH
35601: LD_INT 3
35603: NEG
35604: PUSH
35605: EMPTY
35606: LIST
35607: LIST
35608: PUSH
35609: LD_INT 1
35611: PUSH
35612: LD_INT 2
35614: NEG
35615: PUSH
35616: EMPTY
35617: LIST
35618: LIST
35619: PUSH
35620: LD_INT 2
35622: PUSH
35623: LD_INT 1
35625: NEG
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: LD_INT 3
35633: PUSH
35634: LD_INT 0
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PUSH
35641: LD_INT 3
35643: PUSH
35644: LD_INT 1
35646: PUSH
35647: EMPTY
35648: LIST
35649: LIST
35650: PUSH
35651: LD_INT 1
35653: PUSH
35654: LD_INT 3
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 0
35663: PUSH
35664: LD_INT 3
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 1
35673: NEG
35674: PUSH
35675: LD_INT 2
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: LD_INT 2
35684: NEG
35685: PUSH
35686: LD_INT 1
35688: PUSH
35689: EMPTY
35690: LIST
35691: LIST
35692: PUSH
35693: LD_INT 3
35695: NEG
35696: PUSH
35697: LD_INT 0
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 3
35706: NEG
35707: PUSH
35708: LD_INT 1
35710: NEG
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: LIST
35720: LIST
35721: LIST
35722: LIST
35723: LIST
35724: LIST
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: LIST
35738: LIST
35739: LIST
35740: LIST
35741: LIST
35742: LIST
35743: LIST
35744: LIST
35745: LIST
35746: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35747: LD_ADDR_VAR 0 47
35751: PUSH
35752: LD_INT 0
35754: PUSH
35755: LD_INT 0
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PUSH
35762: LD_INT 0
35764: PUSH
35765: LD_INT 1
35767: NEG
35768: PUSH
35769: EMPTY
35770: LIST
35771: LIST
35772: PUSH
35773: LD_INT 1
35775: PUSH
35776: LD_INT 0
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PUSH
35783: LD_INT 1
35785: PUSH
35786: LD_INT 1
35788: PUSH
35789: EMPTY
35790: LIST
35791: LIST
35792: PUSH
35793: LD_INT 0
35795: PUSH
35796: LD_INT 1
35798: PUSH
35799: EMPTY
35800: LIST
35801: LIST
35802: PUSH
35803: LD_INT 1
35805: NEG
35806: PUSH
35807: LD_INT 0
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: PUSH
35814: LD_INT 1
35816: NEG
35817: PUSH
35818: LD_INT 1
35820: NEG
35821: PUSH
35822: EMPTY
35823: LIST
35824: LIST
35825: PUSH
35826: LD_INT 1
35828: NEG
35829: PUSH
35830: LD_INT 2
35832: NEG
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: PUSH
35838: LD_INT 0
35840: PUSH
35841: LD_INT 2
35843: NEG
35844: PUSH
35845: EMPTY
35846: LIST
35847: LIST
35848: PUSH
35849: LD_INT 1
35851: PUSH
35852: LD_INT 1
35854: NEG
35855: PUSH
35856: EMPTY
35857: LIST
35858: LIST
35859: PUSH
35860: LD_INT 2
35862: NEG
35863: PUSH
35864: LD_INT 1
35866: NEG
35867: PUSH
35868: EMPTY
35869: LIST
35870: LIST
35871: PUSH
35872: LD_INT 2
35874: NEG
35875: PUSH
35876: LD_INT 2
35878: NEG
35879: PUSH
35880: EMPTY
35881: LIST
35882: LIST
35883: PUSH
35884: EMPTY
35885: LIST
35886: LIST
35887: LIST
35888: LIST
35889: LIST
35890: LIST
35891: LIST
35892: LIST
35893: LIST
35894: LIST
35895: LIST
35896: LIST
35897: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
35898: LD_ADDR_VAR 0 48
35902: PUSH
35903: LD_INT 0
35905: PUSH
35906: LD_INT 0
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: LD_INT 0
35915: PUSH
35916: LD_INT 1
35918: NEG
35919: PUSH
35920: EMPTY
35921: LIST
35922: LIST
35923: PUSH
35924: LD_INT 1
35926: PUSH
35927: LD_INT 0
35929: PUSH
35930: EMPTY
35931: LIST
35932: LIST
35933: PUSH
35934: LD_INT 1
35936: PUSH
35937: LD_INT 1
35939: PUSH
35940: EMPTY
35941: LIST
35942: LIST
35943: PUSH
35944: LD_INT 0
35946: PUSH
35947: LD_INT 1
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: LD_INT 1
35956: NEG
35957: PUSH
35958: LD_INT 0
35960: PUSH
35961: EMPTY
35962: LIST
35963: LIST
35964: PUSH
35965: LD_INT 1
35967: NEG
35968: PUSH
35969: LD_INT 1
35971: NEG
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 1
35979: NEG
35980: PUSH
35981: LD_INT 2
35983: NEG
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: LD_INT 0
35991: PUSH
35992: LD_INT 2
35994: NEG
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: LD_INT 1
36002: PUSH
36003: LD_INT 1
36005: NEG
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 2
36013: PUSH
36014: LD_INT 0
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 2
36023: PUSH
36024: LD_INT 1
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: LIST
36035: LIST
36036: LIST
36037: LIST
36038: LIST
36039: LIST
36040: LIST
36041: LIST
36042: LIST
36043: LIST
36044: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36045: LD_ADDR_VAR 0 49
36049: PUSH
36050: LD_INT 0
36052: PUSH
36053: LD_INT 0
36055: PUSH
36056: EMPTY
36057: LIST
36058: LIST
36059: PUSH
36060: LD_INT 0
36062: PUSH
36063: LD_INT 1
36065: NEG
36066: PUSH
36067: EMPTY
36068: LIST
36069: LIST
36070: PUSH
36071: LD_INT 1
36073: PUSH
36074: LD_INT 0
36076: PUSH
36077: EMPTY
36078: LIST
36079: LIST
36080: PUSH
36081: LD_INT 1
36083: PUSH
36084: LD_INT 1
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 0
36093: PUSH
36094: LD_INT 1
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 1
36103: NEG
36104: PUSH
36105: LD_INT 0
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: PUSH
36112: LD_INT 1
36114: NEG
36115: PUSH
36116: LD_INT 1
36118: NEG
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: PUSH
36124: LD_INT 1
36126: PUSH
36127: LD_INT 1
36129: NEG
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 2
36137: PUSH
36138: LD_INT 0
36140: PUSH
36141: EMPTY
36142: LIST
36143: LIST
36144: PUSH
36145: LD_INT 2
36147: PUSH
36148: LD_INT 1
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: LD_INT 2
36157: PUSH
36158: LD_INT 2
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: LD_INT 1
36167: PUSH
36168: LD_INT 2
36170: PUSH
36171: EMPTY
36172: LIST
36173: LIST
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: LIST
36184: LIST
36185: LIST
36186: LIST
36187: LIST
36188: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36189: LD_ADDR_VAR 0 50
36193: PUSH
36194: LD_INT 0
36196: PUSH
36197: LD_INT 0
36199: PUSH
36200: EMPTY
36201: LIST
36202: LIST
36203: PUSH
36204: LD_INT 0
36206: PUSH
36207: LD_INT 1
36209: NEG
36210: PUSH
36211: EMPTY
36212: LIST
36213: LIST
36214: PUSH
36215: LD_INT 1
36217: PUSH
36218: LD_INT 0
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: LD_INT 1
36227: PUSH
36228: LD_INT 1
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 0
36237: PUSH
36238: LD_INT 1
36240: PUSH
36241: EMPTY
36242: LIST
36243: LIST
36244: PUSH
36245: LD_INT 1
36247: NEG
36248: PUSH
36249: LD_INT 0
36251: PUSH
36252: EMPTY
36253: LIST
36254: LIST
36255: PUSH
36256: LD_INT 1
36258: NEG
36259: PUSH
36260: LD_INT 1
36262: NEG
36263: PUSH
36264: EMPTY
36265: LIST
36266: LIST
36267: PUSH
36268: LD_INT 2
36270: PUSH
36271: LD_INT 1
36273: PUSH
36274: EMPTY
36275: LIST
36276: LIST
36277: PUSH
36278: LD_INT 2
36280: PUSH
36281: LD_INT 2
36283: PUSH
36284: EMPTY
36285: LIST
36286: LIST
36287: PUSH
36288: LD_INT 1
36290: PUSH
36291: LD_INT 2
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 0
36300: PUSH
36301: LD_INT 2
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 1
36310: NEG
36311: PUSH
36312: LD_INT 1
36314: PUSH
36315: EMPTY
36316: LIST
36317: LIST
36318: PUSH
36319: EMPTY
36320: LIST
36321: LIST
36322: LIST
36323: LIST
36324: LIST
36325: LIST
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: LIST
36332: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
36333: LD_ADDR_VAR 0 51
36337: PUSH
36338: LD_INT 0
36340: PUSH
36341: LD_INT 0
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: LD_INT 0
36350: PUSH
36351: LD_INT 1
36353: NEG
36354: PUSH
36355: EMPTY
36356: LIST
36357: LIST
36358: PUSH
36359: LD_INT 1
36361: PUSH
36362: LD_INT 0
36364: PUSH
36365: EMPTY
36366: LIST
36367: LIST
36368: PUSH
36369: LD_INT 1
36371: PUSH
36372: LD_INT 1
36374: PUSH
36375: EMPTY
36376: LIST
36377: LIST
36378: PUSH
36379: LD_INT 0
36381: PUSH
36382: LD_INT 1
36384: PUSH
36385: EMPTY
36386: LIST
36387: LIST
36388: PUSH
36389: LD_INT 1
36391: NEG
36392: PUSH
36393: LD_INT 0
36395: PUSH
36396: EMPTY
36397: LIST
36398: LIST
36399: PUSH
36400: LD_INT 1
36402: NEG
36403: PUSH
36404: LD_INT 1
36406: NEG
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 1
36414: PUSH
36415: LD_INT 2
36417: PUSH
36418: EMPTY
36419: LIST
36420: LIST
36421: PUSH
36422: LD_INT 0
36424: PUSH
36425: LD_INT 2
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: LD_INT 1
36434: NEG
36435: PUSH
36436: LD_INT 1
36438: PUSH
36439: EMPTY
36440: LIST
36441: LIST
36442: PUSH
36443: LD_INT 2
36445: NEG
36446: PUSH
36447: LD_INT 0
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: PUSH
36454: LD_INT 2
36456: NEG
36457: PUSH
36458: LD_INT 1
36460: NEG
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: EMPTY
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36480: LD_ADDR_VAR 0 52
36484: PUSH
36485: LD_INT 0
36487: PUSH
36488: LD_INT 0
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 0
36497: PUSH
36498: LD_INT 1
36500: NEG
36501: PUSH
36502: EMPTY
36503: LIST
36504: LIST
36505: PUSH
36506: LD_INT 1
36508: PUSH
36509: LD_INT 0
36511: PUSH
36512: EMPTY
36513: LIST
36514: LIST
36515: PUSH
36516: LD_INT 1
36518: PUSH
36519: LD_INT 1
36521: PUSH
36522: EMPTY
36523: LIST
36524: LIST
36525: PUSH
36526: LD_INT 0
36528: PUSH
36529: LD_INT 1
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: PUSH
36536: LD_INT 1
36538: NEG
36539: PUSH
36540: LD_INT 0
36542: PUSH
36543: EMPTY
36544: LIST
36545: LIST
36546: PUSH
36547: LD_INT 1
36549: NEG
36550: PUSH
36551: LD_INT 1
36553: NEG
36554: PUSH
36555: EMPTY
36556: LIST
36557: LIST
36558: PUSH
36559: LD_INT 1
36561: NEG
36562: PUSH
36563: LD_INT 2
36565: NEG
36566: PUSH
36567: EMPTY
36568: LIST
36569: LIST
36570: PUSH
36571: LD_INT 1
36573: NEG
36574: PUSH
36575: LD_INT 1
36577: PUSH
36578: EMPTY
36579: LIST
36580: LIST
36581: PUSH
36582: LD_INT 2
36584: NEG
36585: PUSH
36586: LD_INT 0
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 2
36595: NEG
36596: PUSH
36597: LD_INT 1
36599: NEG
36600: PUSH
36601: EMPTY
36602: LIST
36603: LIST
36604: PUSH
36605: LD_INT 2
36607: NEG
36608: PUSH
36609: LD_INT 2
36611: NEG
36612: PUSH
36613: EMPTY
36614: LIST
36615: LIST
36616: PUSH
36617: EMPTY
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: LIST
36629: LIST
36630: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36631: LD_ADDR_VAR 0 53
36635: PUSH
36636: LD_INT 0
36638: PUSH
36639: LD_INT 0
36641: PUSH
36642: EMPTY
36643: LIST
36644: LIST
36645: PUSH
36646: LD_INT 0
36648: PUSH
36649: LD_INT 1
36651: NEG
36652: PUSH
36653: EMPTY
36654: LIST
36655: LIST
36656: PUSH
36657: LD_INT 1
36659: PUSH
36660: LD_INT 0
36662: PUSH
36663: EMPTY
36664: LIST
36665: LIST
36666: PUSH
36667: LD_INT 1
36669: PUSH
36670: LD_INT 1
36672: PUSH
36673: EMPTY
36674: LIST
36675: LIST
36676: PUSH
36677: LD_INT 0
36679: PUSH
36680: LD_INT 1
36682: PUSH
36683: EMPTY
36684: LIST
36685: LIST
36686: PUSH
36687: LD_INT 1
36689: NEG
36690: PUSH
36691: LD_INT 0
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 1
36700: NEG
36701: PUSH
36702: LD_INT 1
36704: NEG
36705: PUSH
36706: EMPTY
36707: LIST
36708: LIST
36709: PUSH
36710: LD_INT 1
36712: NEG
36713: PUSH
36714: LD_INT 2
36716: NEG
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 0
36724: PUSH
36725: LD_INT 2
36727: NEG
36728: PUSH
36729: EMPTY
36730: LIST
36731: LIST
36732: PUSH
36733: LD_INT 1
36735: PUSH
36736: LD_INT 1
36738: NEG
36739: PUSH
36740: EMPTY
36741: LIST
36742: LIST
36743: PUSH
36744: LD_INT 2
36746: PUSH
36747: LD_INT 0
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: PUSH
36754: LD_INT 2
36756: PUSH
36757: LD_INT 1
36759: PUSH
36760: EMPTY
36761: LIST
36762: LIST
36763: PUSH
36764: LD_INT 2
36766: PUSH
36767: LD_INT 2
36769: PUSH
36770: EMPTY
36771: LIST
36772: LIST
36773: PUSH
36774: LD_INT 1
36776: PUSH
36777: LD_INT 2
36779: PUSH
36780: EMPTY
36781: LIST
36782: LIST
36783: PUSH
36784: LD_INT 0
36786: PUSH
36787: LD_INT 2
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 1
36796: NEG
36797: PUSH
36798: LD_INT 1
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: PUSH
36805: LD_INT 2
36807: NEG
36808: PUSH
36809: LD_INT 0
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: PUSH
36816: LD_INT 2
36818: NEG
36819: PUSH
36820: LD_INT 1
36822: NEG
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: PUSH
36828: LD_INT 2
36830: NEG
36831: PUSH
36832: LD_INT 2
36834: NEG
36835: PUSH
36836: EMPTY
36837: LIST
36838: LIST
36839: PUSH
36840: EMPTY
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: LIST
36849: LIST
36850: LIST
36851: LIST
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: LIST
36857: LIST
36858: LIST
36859: LIST
36860: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36861: LD_ADDR_VAR 0 54
36865: PUSH
36866: LD_INT 0
36868: PUSH
36869: LD_INT 0
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: LD_INT 0
36878: PUSH
36879: LD_INT 1
36881: NEG
36882: PUSH
36883: EMPTY
36884: LIST
36885: LIST
36886: PUSH
36887: LD_INT 1
36889: PUSH
36890: LD_INT 0
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: PUSH
36897: LD_INT 1
36899: PUSH
36900: LD_INT 1
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: LD_INT 0
36909: PUSH
36910: LD_INT 1
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 1
36919: NEG
36920: PUSH
36921: LD_INT 0
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 1
36930: NEG
36931: PUSH
36932: LD_INT 1
36934: NEG
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: PUSH
36940: LD_INT 1
36942: NEG
36943: PUSH
36944: LD_INT 2
36946: NEG
36947: PUSH
36948: EMPTY
36949: LIST
36950: LIST
36951: PUSH
36952: LD_INT 0
36954: PUSH
36955: LD_INT 2
36957: NEG
36958: PUSH
36959: EMPTY
36960: LIST
36961: LIST
36962: PUSH
36963: LD_INT 1
36965: PUSH
36966: LD_INT 1
36968: NEG
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 2
36976: PUSH
36977: LD_INT 0
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 2
36986: PUSH
36987: LD_INT 1
36989: PUSH
36990: EMPTY
36991: LIST
36992: LIST
36993: PUSH
36994: LD_INT 2
36996: PUSH
36997: LD_INT 2
36999: PUSH
37000: EMPTY
37001: LIST
37002: LIST
37003: PUSH
37004: LD_INT 1
37006: PUSH
37007: LD_INT 2
37009: PUSH
37010: EMPTY
37011: LIST
37012: LIST
37013: PUSH
37014: LD_INT 0
37016: PUSH
37017: LD_INT 2
37019: PUSH
37020: EMPTY
37021: LIST
37022: LIST
37023: PUSH
37024: LD_INT 1
37026: NEG
37027: PUSH
37028: LD_INT 1
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: PUSH
37035: LD_INT 2
37037: NEG
37038: PUSH
37039: LD_INT 0
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 2
37048: NEG
37049: PUSH
37050: LD_INT 1
37052: NEG
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: LD_INT 2
37060: NEG
37061: PUSH
37062: LD_INT 2
37064: NEG
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: EMPTY
37071: LIST
37072: LIST
37073: LIST
37074: LIST
37075: LIST
37076: LIST
37077: LIST
37078: LIST
37079: LIST
37080: LIST
37081: LIST
37082: LIST
37083: LIST
37084: LIST
37085: LIST
37086: LIST
37087: LIST
37088: LIST
37089: LIST
37090: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37091: LD_ADDR_VAR 0 55
37095: PUSH
37096: LD_INT 0
37098: PUSH
37099: LD_INT 0
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: PUSH
37106: LD_INT 0
37108: PUSH
37109: LD_INT 1
37111: NEG
37112: PUSH
37113: EMPTY
37114: LIST
37115: LIST
37116: PUSH
37117: LD_INT 1
37119: PUSH
37120: LD_INT 0
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: PUSH
37127: LD_INT 1
37129: PUSH
37130: LD_INT 1
37132: PUSH
37133: EMPTY
37134: LIST
37135: LIST
37136: PUSH
37137: LD_INT 0
37139: PUSH
37140: LD_INT 1
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 1
37149: NEG
37150: PUSH
37151: LD_INT 0
37153: PUSH
37154: EMPTY
37155: LIST
37156: LIST
37157: PUSH
37158: LD_INT 1
37160: NEG
37161: PUSH
37162: LD_INT 1
37164: NEG
37165: PUSH
37166: EMPTY
37167: LIST
37168: LIST
37169: PUSH
37170: LD_INT 1
37172: NEG
37173: PUSH
37174: LD_INT 2
37176: NEG
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 0
37184: PUSH
37185: LD_INT 2
37187: NEG
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 1
37195: PUSH
37196: LD_INT 1
37198: NEG
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 2
37206: PUSH
37207: LD_INT 0
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 2
37216: PUSH
37217: LD_INT 1
37219: PUSH
37220: EMPTY
37221: LIST
37222: LIST
37223: PUSH
37224: LD_INT 2
37226: PUSH
37227: LD_INT 2
37229: PUSH
37230: EMPTY
37231: LIST
37232: LIST
37233: PUSH
37234: LD_INT 1
37236: PUSH
37237: LD_INT 2
37239: PUSH
37240: EMPTY
37241: LIST
37242: LIST
37243: PUSH
37244: LD_INT 0
37246: PUSH
37247: LD_INT 2
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: LD_INT 1
37256: NEG
37257: PUSH
37258: LD_INT 1
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: PUSH
37265: LD_INT 2
37267: NEG
37268: PUSH
37269: LD_INT 0
37271: PUSH
37272: EMPTY
37273: LIST
37274: LIST
37275: PUSH
37276: LD_INT 2
37278: NEG
37279: PUSH
37280: LD_INT 1
37282: NEG
37283: PUSH
37284: EMPTY
37285: LIST
37286: LIST
37287: PUSH
37288: LD_INT 2
37290: NEG
37291: PUSH
37292: LD_INT 2
37294: NEG
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: EMPTY
37301: LIST
37302: LIST
37303: LIST
37304: LIST
37305: LIST
37306: LIST
37307: LIST
37308: LIST
37309: LIST
37310: LIST
37311: LIST
37312: LIST
37313: LIST
37314: LIST
37315: LIST
37316: LIST
37317: LIST
37318: LIST
37319: LIST
37320: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37321: LD_ADDR_VAR 0 56
37325: PUSH
37326: LD_INT 0
37328: PUSH
37329: LD_INT 0
37331: PUSH
37332: EMPTY
37333: LIST
37334: LIST
37335: PUSH
37336: LD_INT 0
37338: PUSH
37339: LD_INT 1
37341: NEG
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PUSH
37347: LD_INT 1
37349: PUSH
37350: LD_INT 0
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: PUSH
37357: LD_INT 1
37359: PUSH
37360: LD_INT 1
37362: PUSH
37363: EMPTY
37364: LIST
37365: LIST
37366: PUSH
37367: LD_INT 0
37369: PUSH
37370: LD_INT 1
37372: PUSH
37373: EMPTY
37374: LIST
37375: LIST
37376: PUSH
37377: LD_INT 1
37379: NEG
37380: PUSH
37381: LD_INT 0
37383: PUSH
37384: EMPTY
37385: LIST
37386: LIST
37387: PUSH
37388: LD_INT 1
37390: NEG
37391: PUSH
37392: LD_INT 1
37394: NEG
37395: PUSH
37396: EMPTY
37397: LIST
37398: LIST
37399: PUSH
37400: LD_INT 1
37402: NEG
37403: PUSH
37404: LD_INT 2
37406: NEG
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: PUSH
37412: LD_INT 0
37414: PUSH
37415: LD_INT 2
37417: NEG
37418: PUSH
37419: EMPTY
37420: LIST
37421: LIST
37422: PUSH
37423: LD_INT 1
37425: PUSH
37426: LD_INT 1
37428: NEG
37429: PUSH
37430: EMPTY
37431: LIST
37432: LIST
37433: PUSH
37434: LD_INT 2
37436: PUSH
37437: LD_INT 0
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: PUSH
37444: LD_INT 2
37446: PUSH
37447: LD_INT 1
37449: PUSH
37450: EMPTY
37451: LIST
37452: LIST
37453: PUSH
37454: LD_INT 2
37456: PUSH
37457: LD_INT 2
37459: PUSH
37460: EMPTY
37461: LIST
37462: LIST
37463: PUSH
37464: LD_INT 1
37466: PUSH
37467: LD_INT 2
37469: PUSH
37470: EMPTY
37471: LIST
37472: LIST
37473: PUSH
37474: LD_INT 0
37476: PUSH
37477: LD_INT 2
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: PUSH
37484: LD_INT 1
37486: NEG
37487: PUSH
37488: LD_INT 1
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 2
37497: NEG
37498: PUSH
37499: LD_INT 0
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 2
37508: NEG
37509: PUSH
37510: LD_INT 1
37512: NEG
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 2
37520: NEG
37521: PUSH
37522: LD_INT 2
37524: NEG
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: LIST
37534: LIST
37535: LIST
37536: LIST
37537: LIST
37538: LIST
37539: LIST
37540: LIST
37541: LIST
37542: LIST
37543: LIST
37544: LIST
37545: LIST
37546: LIST
37547: LIST
37548: LIST
37549: LIST
37550: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37551: LD_ADDR_VAR 0 57
37555: PUSH
37556: LD_INT 0
37558: PUSH
37559: LD_INT 0
37561: PUSH
37562: EMPTY
37563: LIST
37564: LIST
37565: PUSH
37566: LD_INT 0
37568: PUSH
37569: LD_INT 1
37571: NEG
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: LD_INT 1
37579: PUSH
37580: LD_INT 0
37582: PUSH
37583: EMPTY
37584: LIST
37585: LIST
37586: PUSH
37587: LD_INT 1
37589: PUSH
37590: LD_INT 1
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 0
37599: PUSH
37600: LD_INT 1
37602: PUSH
37603: EMPTY
37604: LIST
37605: LIST
37606: PUSH
37607: LD_INT 1
37609: NEG
37610: PUSH
37611: LD_INT 0
37613: PUSH
37614: EMPTY
37615: LIST
37616: LIST
37617: PUSH
37618: LD_INT 1
37620: NEG
37621: PUSH
37622: LD_INT 1
37624: NEG
37625: PUSH
37626: EMPTY
37627: LIST
37628: LIST
37629: PUSH
37630: LD_INT 1
37632: NEG
37633: PUSH
37634: LD_INT 2
37636: NEG
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 0
37644: PUSH
37645: LD_INT 2
37647: NEG
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: LD_INT 1
37655: PUSH
37656: LD_INT 1
37658: NEG
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: PUSH
37664: LD_INT 2
37666: PUSH
37667: LD_INT 0
37669: PUSH
37670: EMPTY
37671: LIST
37672: LIST
37673: PUSH
37674: LD_INT 2
37676: PUSH
37677: LD_INT 1
37679: PUSH
37680: EMPTY
37681: LIST
37682: LIST
37683: PUSH
37684: LD_INT 2
37686: PUSH
37687: LD_INT 2
37689: PUSH
37690: EMPTY
37691: LIST
37692: LIST
37693: PUSH
37694: LD_INT 1
37696: PUSH
37697: LD_INT 2
37699: PUSH
37700: EMPTY
37701: LIST
37702: LIST
37703: PUSH
37704: LD_INT 0
37706: PUSH
37707: LD_INT 2
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 1
37716: NEG
37717: PUSH
37718: LD_INT 1
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: PUSH
37725: LD_INT 2
37727: NEG
37728: PUSH
37729: LD_INT 0
37731: PUSH
37732: EMPTY
37733: LIST
37734: LIST
37735: PUSH
37736: LD_INT 2
37738: NEG
37739: PUSH
37740: LD_INT 1
37742: NEG
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 2
37750: NEG
37751: PUSH
37752: LD_INT 2
37754: NEG
37755: PUSH
37756: EMPTY
37757: LIST
37758: LIST
37759: PUSH
37760: EMPTY
37761: LIST
37762: LIST
37763: LIST
37764: LIST
37765: LIST
37766: LIST
37767: LIST
37768: LIST
37769: LIST
37770: LIST
37771: LIST
37772: LIST
37773: LIST
37774: LIST
37775: LIST
37776: LIST
37777: LIST
37778: LIST
37779: LIST
37780: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37781: LD_ADDR_VAR 0 58
37785: PUSH
37786: LD_INT 0
37788: PUSH
37789: LD_INT 0
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: LD_INT 0
37798: PUSH
37799: LD_INT 1
37801: NEG
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 1
37809: PUSH
37810: LD_INT 0
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: PUSH
37817: LD_INT 1
37819: PUSH
37820: LD_INT 1
37822: PUSH
37823: EMPTY
37824: LIST
37825: LIST
37826: PUSH
37827: LD_INT 0
37829: PUSH
37830: LD_INT 1
37832: PUSH
37833: EMPTY
37834: LIST
37835: LIST
37836: PUSH
37837: LD_INT 1
37839: NEG
37840: PUSH
37841: LD_INT 0
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 1
37850: NEG
37851: PUSH
37852: LD_INT 1
37854: NEG
37855: PUSH
37856: EMPTY
37857: LIST
37858: LIST
37859: PUSH
37860: LD_INT 1
37862: NEG
37863: PUSH
37864: LD_INT 2
37866: NEG
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 0
37874: PUSH
37875: LD_INT 2
37877: NEG
37878: PUSH
37879: EMPTY
37880: LIST
37881: LIST
37882: PUSH
37883: LD_INT 1
37885: PUSH
37886: LD_INT 1
37888: NEG
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: PUSH
37894: LD_INT 2
37896: PUSH
37897: LD_INT 0
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 2
37906: PUSH
37907: LD_INT 1
37909: PUSH
37910: EMPTY
37911: LIST
37912: LIST
37913: PUSH
37914: LD_INT 2
37916: PUSH
37917: LD_INT 2
37919: PUSH
37920: EMPTY
37921: LIST
37922: LIST
37923: PUSH
37924: LD_INT 1
37926: PUSH
37927: LD_INT 2
37929: PUSH
37930: EMPTY
37931: LIST
37932: LIST
37933: PUSH
37934: LD_INT 0
37936: PUSH
37937: LD_INT 2
37939: PUSH
37940: EMPTY
37941: LIST
37942: LIST
37943: PUSH
37944: LD_INT 1
37946: NEG
37947: PUSH
37948: LD_INT 1
37950: PUSH
37951: EMPTY
37952: LIST
37953: LIST
37954: PUSH
37955: LD_INT 2
37957: NEG
37958: PUSH
37959: LD_INT 0
37961: PUSH
37962: EMPTY
37963: LIST
37964: LIST
37965: PUSH
37966: LD_INT 2
37968: NEG
37969: PUSH
37970: LD_INT 1
37972: NEG
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 2
37980: NEG
37981: PUSH
37982: LD_INT 2
37984: NEG
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: LIST
37994: LIST
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: LIST
38000: LIST
38001: LIST
38002: LIST
38003: LIST
38004: LIST
38005: LIST
38006: LIST
38007: LIST
38008: LIST
38009: LIST
38010: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38011: LD_ADDR_VAR 0 59
38015: PUSH
38016: LD_INT 0
38018: PUSH
38019: LD_INT 0
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 0
38028: PUSH
38029: LD_INT 1
38031: NEG
38032: PUSH
38033: EMPTY
38034: LIST
38035: LIST
38036: PUSH
38037: LD_INT 1
38039: PUSH
38040: LD_INT 0
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: PUSH
38047: LD_INT 1
38049: PUSH
38050: LD_INT 1
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PUSH
38057: LD_INT 0
38059: PUSH
38060: LD_INT 1
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 1
38069: NEG
38070: PUSH
38071: LD_INT 0
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PUSH
38078: LD_INT 1
38080: NEG
38081: PUSH
38082: LD_INT 1
38084: NEG
38085: PUSH
38086: EMPTY
38087: LIST
38088: LIST
38089: PUSH
38090: EMPTY
38091: LIST
38092: LIST
38093: LIST
38094: LIST
38095: LIST
38096: LIST
38097: LIST
38098: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38099: LD_ADDR_VAR 0 60
38103: PUSH
38104: LD_INT 0
38106: PUSH
38107: LD_INT 0
38109: PUSH
38110: EMPTY
38111: LIST
38112: LIST
38113: PUSH
38114: LD_INT 0
38116: PUSH
38117: LD_INT 1
38119: NEG
38120: PUSH
38121: EMPTY
38122: LIST
38123: LIST
38124: PUSH
38125: LD_INT 1
38127: PUSH
38128: LD_INT 0
38130: PUSH
38131: EMPTY
38132: LIST
38133: LIST
38134: PUSH
38135: LD_INT 1
38137: PUSH
38138: LD_INT 1
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: PUSH
38145: LD_INT 0
38147: PUSH
38148: LD_INT 1
38150: PUSH
38151: EMPTY
38152: LIST
38153: LIST
38154: PUSH
38155: LD_INT 1
38157: NEG
38158: PUSH
38159: LD_INT 0
38161: PUSH
38162: EMPTY
38163: LIST
38164: LIST
38165: PUSH
38166: LD_INT 1
38168: NEG
38169: PUSH
38170: LD_INT 1
38172: NEG
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: LIST
38182: LIST
38183: LIST
38184: LIST
38185: LIST
38186: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38187: LD_ADDR_VAR 0 61
38191: PUSH
38192: LD_INT 0
38194: PUSH
38195: LD_INT 0
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 0
38204: PUSH
38205: LD_INT 1
38207: NEG
38208: PUSH
38209: EMPTY
38210: LIST
38211: LIST
38212: PUSH
38213: LD_INT 1
38215: PUSH
38216: LD_INT 0
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: PUSH
38223: LD_INT 1
38225: PUSH
38226: LD_INT 1
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 0
38235: PUSH
38236: LD_INT 1
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 1
38245: NEG
38246: PUSH
38247: LD_INT 0
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 1
38256: NEG
38257: PUSH
38258: LD_INT 1
38260: NEG
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38275: LD_ADDR_VAR 0 62
38279: PUSH
38280: LD_INT 0
38282: PUSH
38283: LD_INT 0
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 0
38292: PUSH
38293: LD_INT 1
38295: NEG
38296: PUSH
38297: EMPTY
38298: LIST
38299: LIST
38300: PUSH
38301: LD_INT 1
38303: PUSH
38304: LD_INT 0
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 1
38313: PUSH
38314: LD_INT 1
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 0
38323: PUSH
38324: LD_INT 1
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: LD_INT 1
38333: NEG
38334: PUSH
38335: LD_INT 0
38337: PUSH
38338: EMPTY
38339: LIST
38340: LIST
38341: PUSH
38342: LD_INT 1
38344: NEG
38345: PUSH
38346: LD_INT 1
38348: NEG
38349: PUSH
38350: EMPTY
38351: LIST
38352: LIST
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: LIST
38358: LIST
38359: LIST
38360: LIST
38361: LIST
38362: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38363: LD_ADDR_VAR 0 63
38367: PUSH
38368: LD_INT 0
38370: PUSH
38371: LD_INT 0
38373: PUSH
38374: EMPTY
38375: LIST
38376: LIST
38377: PUSH
38378: LD_INT 0
38380: PUSH
38381: LD_INT 1
38383: NEG
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: LD_INT 1
38391: PUSH
38392: LD_INT 0
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: PUSH
38399: LD_INT 1
38401: PUSH
38402: LD_INT 1
38404: PUSH
38405: EMPTY
38406: LIST
38407: LIST
38408: PUSH
38409: LD_INT 0
38411: PUSH
38412: LD_INT 1
38414: PUSH
38415: EMPTY
38416: LIST
38417: LIST
38418: PUSH
38419: LD_INT 1
38421: NEG
38422: PUSH
38423: LD_INT 0
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 1
38432: NEG
38433: PUSH
38434: LD_INT 1
38436: NEG
38437: PUSH
38438: EMPTY
38439: LIST
38440: LIST
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: LIST
38446: LIST
38447: LIST
38448: LIST
38449: LIST
38450: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38451: LD_ADDR_VAR 0 64
38455: PUSH
38456: LD_INT 0
38458: PUSH
38459: LD_INT 0
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PUSH
38466: LD_INT 0
38468: PUSH
38469: LD_INT 1
38471: NEG
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 1
38479: PUSH
38480: LD_INT 0
38482: PUSH
38483: EMPTY
38484: LIST
38485: LIST
38486: PUSH
38487: LD_INT 1
38489: PUSH
38490: LD_INT 1
38492: PUSH
38493: EMPTY
38494: LIST
38495: LIST
38496: PUSH
38497: LD_INT 0
38499: PUSH
38500: LD_INT 1
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: PUSH
38507: LD_INT 1
38509: NEG
38510: PUSH
38511: LD_INT 0
38513: PUSH
38514: EMPTY
38515: LIST
38516: LIST
38517: PUSH
38518: LD_INT 1
38520: NEG
38521: PUSH
38522: LD_INT 1
38524: NEG
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: ST_TO_ADDR
// end ; 1 :
38539: GO 44436
38541: LD_INT 1
38543: DOUBLE
38544: EQUAL
38545: IFTRUE 38549
38547: GO 41172
38549: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38550: LD_ADDR_VAR 0 11
38554: PUSH
38555: LD_INT 1
38557: NEG
38558: PUSH
38559: LD_INT 3
38561: NEG
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: PUSH
38567: LD_INT 0
38569: PUSH
38570: LD_INT 3
38572: NEG
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: PUSH
38578: LD_INT 1
38580: PUSH
38581: LD_INT 2
38583: NEG
38584: PUSH
38585: EMPTY
38586: LIST
38587: LIST
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: LIST
38593: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38594: LD_ADDR_VAR 0 12
38598: PUSH
38599: LD_INT 2
38601: PUSH
38602: LD_INT 1
38604: NEG
38605: PUSH
38606: EMPTY
38607: LIST
38608: LIST
38609: PUSH
38610: LD_INT 3
38612: PUSH
38613: LD_INT 0
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: PUSH
38620: LD_INT 3
38622: PUSH
38623: LD_INT 1
38625: PUSH
38626: EMPTY
38627: LIST
38628: LIST
38629: PUSH
38630: EMPTY
38631: LIST
38632: LIST
38633: LIST
38634: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38635: LD_ADDR_VAR 0 13
38639: PUSH
38640: LD_INT 3
38642: PUSH
38643: LD_INT 2
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: PUSH
38650: LD_INT 3
38652: PUSH
38653: LD_INT 3
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: PUSH
38660: LD_INT 2
38662: PUSH
38663: LD_INT 3
38665: PUSH
38666: EMPTY
38667: LIST
38668: LIST
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: LIST
38674: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38675: LD_ADDR_VAR 0 14
38679: PUSH
38680: LD_INT 1
38682: PUSH
38683: LD_INT 3
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 0
38692: PUSH
38693: LD_INT 3
38695: PUSH
38696: EMPTY
38697: LIST
38698: LIST
38699: PUSH
38700: LD_INT 1
38702: NEG
38703: PUSH
38704: LD_INT 2
38706: PUSH
38707: EMPTY
38708: LIST
38709: LIST
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: LIST
38715: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38716: LD_ADDR_VAR 0 15
38720: PUSH
38721: LD_INT 2
38723: NEG
38724: PUSH
38725: LD_INT 1
38727: PUSH
38728: EMPTY
38729: LIST
38730: LIST
38731: PUSH
38732: LD_INT 3
38734: NEG
38735: PUSH
38736: LD_INT 0
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 3
38745: NEG
38746: PUSH
38747: LD_INT 1
38749: NEG
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: LIST
38759: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38760: LD_ADDR_VAR 0 16
38764: PUSH
38765: LD_INT 2
38767: NEG
38768: PUSH
38769: LD_INT 3
38771: NEG
38772: PUSH
38773: EMPTY
38774: LIST
38775: LIST
38776: PUSH
38777: LD_INT 3
38779: NEG
38780: PUSH
38781: LD_INT 2
38783: NEG
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: PUSH
38789: LD_INT 3
38791: NEG
38792: PUSH
38793: LD_INT 3
38795: NEG
38796: PUSH
38797: EMPTY
38798: LIST
38799: LIST
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: LIST
38805: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38806: LD_ADDR_VAR 0 17
38810: PUSH
38811: LD_INT 1
38813: NEG
38814: PUSH
38815: LD_INT 3
38817: NEG
38818: PUSH
38819: EMPTY
38820: LIST
38821: LIST
38822: PUSH
38823: LD_INT 0
38825: PUSH
38826: LD_INT 3
38828: NEG
38829: PUSH
38830: EMPTY
38831: LIST
38832: LIST
38833: PUSH
38834: LD_INT 1
38836: PUSH
38837: LD_INT 2
38839: NEG
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: LIST
38849: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38850: LD_ADDR_VAR 0 18
38854: PUSH
38855: LD_INT 2
38857: PUSH
38858: LD_INT 1
38860: NEG
38861: PUSH
38862: EMPTY
38863: LIST
38864: LIST
38865: PUSH
38866: LD_INT 3
38868: PUSH
38869: LD_INT 0
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: PUSH
38876: LD_INT 3
38878: PUSH
38879: LD_INT 1
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: LIST
38890: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38891: LD_ADDR_VAR 0 19
38895: PUSH
38896: LD_INT 3
38898: PUSH
38899: LD_INT 2
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: PUSH
38906: LD_INT 3
38908: PUSH
38909: LD_INT 3
38911: PUSH
38912: EMPTY
38913: LIST
38914: LIST
38915: PUSH
38916: LD_INT 2
38918: PUSH
38919: LD_INT 3
38921: PUSH
38922: EMPTY
38923: LIST
38924: LIST
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: LIST
38930: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38931: LD_ADDR_VAR 0 20
38935: PUSH
38936: LD_INT 1
38938: PUSH
38939: LD_INT 3
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: PUSH
38946: LD_INT 0
38948: PUSH
38949: LD_INT 3
38951: PUSH
38952: EMPTY
38953: LIST
38954: LIST
38955: PUSH
38956: LD_INT 1
38958: NEG
38959: PUSH
38960: LD_INT 2
38962: PUSH
38963: EMPTY
38964: LIST
38965: LIST
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: LIST
38971: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38972: LD_ADDR_VAR 0 21
38976: PUSH
38977: LD_INT 2
38979: NEG
38980: PUSH
38981: LD_INT 1
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 3
38990: NEG
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: EMPTY
38996: LIST
38997: LIST
38998: PUSH
38999: LD_INT 3
39001: NEG
39002: PUSH
39003: LD_INT 1
39005: NEG
39006: PUSH
39007: EMPTY
39008: LIST
39009: LIST
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: LIST
39015: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39016: LD_ADDR_VAR 0 22
39020: PUSH
39021: LD_INT 2
39023: NEG
39024: PUSH
39025: LD_INT 3
39027: NEG
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: PUSH
39033: LD_INT 3
39035: NEG
39036: PUSH
39037: LD_INT 2
39039: NEG
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 3
39047: NEG
39048: PUSH
39049: LD_INT 3
39051: NEG
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: LIST
39061: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39062: LD_ADDR_VAR 0 23
39066: PUSH
39067: LD_INT 0
39069: PUSH
39070: LD_INT 3
39072: NEG
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 1
39080: NEG
39081: PUSH
39082: LD_INT 4
39084: NEG
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 1
39092: PUSH
39093: LD_INT 3
39095: NEG
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: EMPTY
39102: LIST
39103: LIST
39104: LIST
39105: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39106: LD_ADDR_VAR 0 24
39110: PUSH
39111: LD_INT 3
39113: PUSH
39114: LD_INT 0
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: PUSH
39121: LD_INT 3
39123: PUSH
39124: LD_INT 1
39126: NEG
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 4
39134: PUSH
39135: LD_INT 1
39137: PUSH
39138: EMPTY
39139: LIST
39140: LIST
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: LIST
39146: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39147: LD_ADDR_VAR 0 25
39151: PUSH
39152: LD_INT 3
39154: PUSH
39155: LD_INT 3
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 4
39164: PUSH
39165: LD_INT 3
39167: PUSH
39168: EMPTY
39169: LIST
39170: LIST
39171: PUSH
39172: LD_INT 3
39174: PUSH
39175: LD_INT 4
39177: PUSH
39178: EMPTY
39179: LIST
39180: LIST
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: LIST
39186: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39187: LD_ADDR_VAR 0 26
39191: PUSH
39192: LD_INT 0
39194: PUSH
39195: LD_INT 3
39197: PUSH
39198: EMPTY
39199: LIST
39200: LIST
39201: PUSH
39202: LD_INT 1
39204: PUSH
39205: LD_INT 4
39207: PUSH
39208: EMPTY
39209: LIST
39210: LIST
39211: PUSH
39212: LD_INT 1
39214: NEG
39215: PUSH
39216: LD_INT 3
39218: PUSH
39219: EMPTY
39220: LIST
39221: LIST
39222: PUSH
39223: EMPTY
39224: LIST
39225: LIST
39226: LIST
39227: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
39228: LD_ADDR_VAR 0 27
39232: PUSH
39233: LD_INT 3
39235: NEG
39236: PUSH
39237: LD_INT 0
39239: PUSH
39240: EMPTY
39241: LIST
39242: LIST
39243: PUSH
39244: LD_INT 3
39246: NEG
39247: PUSH
39248: LD_INT 1
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: PUSH
39255: LD_INT 4
39257: NEG
39258: PUSH
39259: LD_INT 1
39261: NEG
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: EMPTY
39268: LIST
39269: LIST
39270: LIST
39271: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
39272: LD_ADDR_VAR 0 28
39276: PUSH
39277: LD_INT 3
39279: NEG
39280: PUSH
39281: LD_INT 3
39283: NEG
39284: PUSH
39285: EMPTY
39286: LIST
39287: LIST
39288: PUSH
39289: LD_INT 3
39291: NEG
39292: PUSH
39293: LD_INT 4
39295: NEG
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 4
39303: NEG
39304: PUSH
39305: LD_INT 3
39307: NEG
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: EMPTY
39314: LIST
39315: LIST
39316: LIST
39317: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
39318: LD_ADDR_VAR 0 29
39322: PUSH
39323: LD_INT 1
39325: NEG
39326: PUSH
39327: LD_INT 3
39329: NEG
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 0
39337: PUSH
39338: LD_INT 3
39340: NEG
39341: PUSH
39342: EMPTY
39343: LIST
39344: LIST
39345: PUSH
39346: LD_INT 1
39348: PUSH
39349: LD_INT 2
39351: NEG
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 1
39359: NEG
39360: PUSH
39361: LD_INT 4
39363: NEG
39364: PUSH
39365: EMPTY
39366: LIST
39367: LIST
39368: PUSH
39369: LD_INT 0
39371: PUSH
39372: LD_INT 4
39374: NEG
39375: PUSH
39376: EMPTY
39377: LIST
39378: LIST
39379: PUSH
39380: LD_INT 1
39382: PUSH
39383: LD_INT 3
39385: NEG
39386: PUSH
39387: EMPTY
39388: LIST
39389: LIST
39390: PUSH
39391: LD_INT 1
39393: NEG
39394: PUSH
39395: LD_INT 5
39397: NEG
39398: PUSH
39399: EMPTY
39400: LIST
39401: LIST
39402: PUSH
39403: LD_INT 0
39405: PUSH
39406: LD_INT 5
39408: NEG
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 1
39416: PUSH
39417: LD_INT 4
39419: NEG
39420: PUSH
39421: EMPTY
39422: LIST
39423: LIST
39424: PUSH
39425: LD_INT 1
39427: NEG
39428: PUSH
39429: LD_INT 6
39431: NEG
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PUSH
39437: LD_INT 0
39439: PUSH
39440: LD_INT 6
39442: NEG
39443: PUSH
39444: EMPTY
39445: LIST
39446: LIST
39447: PUSH
39448: LD_INT 1
39450: PUSH
39451: LD_INT 5
39453: NEG
39454: PUSH
39455: EMPTY
39456: LIST
39457: LIST
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: LIST
39463: LIST
39464: LIST
39465: LIST
39466: LIST
39467: LIST
39468: LIST
39469: LIST
39470: LIST
39471: LIST
39472: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
39473: LD_ADDR_VAR 0 30
39477: PUSH
39478: LD_INT 2
39480: PUSH
39481: LD_INT 1
39483: NEG
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: LD_INT 3
39491: PUSH
39492: LD_INT 0
39494: PUSH
39495: EMPTY
39496: LIST
39497: LIST
39498: PUSH
39499: LD_INT 3
39501: PUSH
39502: LD_INT 1
39504: PUSH
39505: EMPTY
39506: LIST
39507: LIST
39508: PUSH
39509: LD_INT 3
39511: PUSH
39512: LD_INT 1
39514: NEG
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 4
39522: PUSH
39523: LD_INT 0
39525: PUSH
39526: EMPTY
39527: LIST
39528: LIST
39529: PUSH
39530: LD_INT 4
39532: PUSH
39533: LD_INT 1
39535: PUSH
39536: EMPTY
39537: LIST
39538: LIST
39539: PUSH
39540: LD_INT 4
39542: PUSH
39543: LD_INT 1
39545: NEG
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 5
39553: PUSH
39554: LD_INT 0
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 5
39563: PUSH
39564: LD_INT 1
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PUSH
39571: LD_INT 5
39573: PUSH
39574: LD_INT 1
39576: NEG
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PUSH
39582: LD_INT 6
39584: PUSH
39585: LD_INT 0
39587: PUSH
39588: EMPTY
39589: LIST
39590: LIST
39591: PUSH
39592: LD_INT 6
39594: PUSH
39595: LD_INT 1
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: LIST
39606: LIST
39607: LIST
39608: LIST
39609: LIST
39610: LIST
39611: LIST
39612: LIST
39613: LIST
39614: LIST
39615: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
39616: LD_ADDR_VAR 0 31
39620: PUSH
39621: LD_INT 3
39623: PUSH
39624: LD_INT 2
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: PUSH
39631: LD_INT 3
39633: PUSH
39634: LD_INT 3
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: LD_INT 2
39643: PUSH
39644: LD_INT 3
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PUSH
39651: LD_INT 4
39653: PUSH
39654: LD_INT 3
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: LD_INT 4
39663: PUSH
39664: LD_INT 4
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: PUSH
39671: LD_INT 3
39673: PUSH
39674: LD_INT 4
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 5
39683: PUSH
39684: LD_INT 4
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PUSH
39691: LD_INT 5
39693: PUSH
39694: LD_INT 5
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: LD_INT 4
39703: PUSH
39704: LD_INT 5
39706: PUSH
39707: EMPTY
39708: LIST
39709: LIST
39710: PUSH
39711: LD_INT 6
39713: PUSH
39714: LD_INT 5
39716: PUSH
39717: EMPTY
39718: LIST
39719: LIST
39720: PUSH
39721: LD_INT 6
39723: PUSH
39724: LD_INT 6
39726: PUSH
39727: EMPTY
39728: LIST
39729: LIST
39730: PUSH
39731: LD_INT 5
39733: PUSH
39734: LD_INT 6
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: LIST
39745: LIST
39746: LIST
39747: LIST
39748: LIST
39749: LIST
39750: LIST
39751: LIST
39752: LIST
39753: LIST
39754: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
39755: LD_ADDR_VAR 0 32
39759: PUSH
39760: LD_INT 1
39762: PUSH
39763: LD_INT 3
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: LD_INT 0
39772: PUSH
39773: LD_INT 3
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 1
39782: NEG
39783: PUSH
39784: LD_INT 2
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 1
39793: PUSH
39794: LD_INT 4
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 0
39803: PUSH
39804: LD_INT 4
39806: PUSH
39807: EMPTY
39808: LIST
39809: LIST
39810: PUSH
39811: LD_INT 1
39813: NEG
39814: PUSH
39815: LD_INT 3
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 1
39824: PUSH
39825: LD_INT 5
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PUSH
39832: LD_INT 0
39834: PUSH
39835: LD_INT 5
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 1
39844: NEG
39845: PUSH
39846: LD_INT 4
39848: PUSH
39849: EMPTY
39850: LIST
39851: LIST
39852: PUSH
39853: LD_INT 1
39855: PUSH
39856: LD_INT 6
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: LD_INT 0
39865: PUSH
39866: LD_INT 6
39868: PUSH
39869: EMPTY
39870: LIST
39871: LIST
39872: PUSH
39873: LD_INT 1
39875: NEG
39876: PUSH
39877: LD_INT 5
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: LIST
39888: LIST
39889: LIST
39890: LIST
39891: LIST
39892: LIST
39893: LIST
39894: LIST
39895: LIST
39896: LIST
39897: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
39898: LD_ADDR_VAR 0 33
39902: PUSH
39903: LD_INT 2
39905: NEG
39906: PUSH
39907: LD_INT 1
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 3
39916: NEG
39917: PUSH
39918: LD_INT 0
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: PUSH
39925: LD_INT 3
39927: NEG
39928: PUSH
39929: LD_INT 1
39931: NEG
39932: PUSH
39933: EMPTY
39934: LIST
39935: LIST
39936: PUSH
39937: LD_INT 3
39939: NEG
39940: PUSH
39941: LD_INT 1
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PUSH
39948: LD_INT 4
39950: NEG
39951: PUSH
39952: LD_INT 0
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: PUSH
39959: LD_INT 4
39961: NEG
39962: PUSH
39963: LD_INT 1
39965: NEG
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: PUSH
39971: LD_INT 4
39973: NEG
39974: PUSH
39975: LD_INT 1
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: PUSH
39982: LD_INT 5
39984: NEG
39985: PUSH
39986: LD_INT 0
39988: PUSH
39989: EMPTY
39990: LIST
39991: LIST
39992: PUSH
39993: LD_INT 5
39995: NEG
39996: PUSH
39997: LD_INT 1
39999: NEG
40000: PUSH
40001: EMPTY
40002: LIST
40003: LIST
40004: PUSH
40005: LD_INT 5
40007: NEG
40008: PUSH
40009: LD_INT 1
40011: PUSH
40012: EMPTY
40013: LIST
40014: LIST
40015: PUSH
40016: LD_INT 6
40018: NEG
40019: PUSH
40020: LD_INT 0
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: PUSH
40027: LD_INT 6
40029: NEG
40030: PUSH
40031: LD_INT 1
40033: NEG
40034: PUSH
40035: EMPTY
40036: LIST
40037: LIST
40038: PUSH
40039: EMPTY
40040: LIST
40041: LIST
40042: LIST
40043: LIST
40044: LIST
40045: LIST
40046: LIST
40047: LIST
40048: LIST
40049: LIST
40050: LIST
40051: LIST
40052: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40053: LD_ADDR_VAR 0 34
40057: PUSH
40058: LD_INT 2
40060: NEG
40061: PUSH
40062: LD_INT 3
40064: NEG
40065: PUSH
40066: EMPTY
40067: LIST
40068: LIST
40069: PUSH
40070: LD_INT 3
40072: NEG
40073: PUSH
40074: LD_INT 2
40076: NEG
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 3
40084: NEG
40085: PUSH
40086: LD_INT 3
40088: NEG
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 3
40096: NEG
40097: PUSH
40098: LD_INT 4
40100: NEG
40101: PUSH
40102: EMPTY
40103: LIST
40104: LIST
40105: PUSH
40106: LD_INT 4
40108: NEG
40109: PUSH
40110: LD_INT 3
40112: NEG
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PUSH
40118: LD_INT 4
40120: NEG
40121: PUSH
40122: LD_INT 4
40124: NEG
40125: PUSH
40126: EMPTY
40127: LIST
40128: LIST
40129: PUSH
40130: LD_INT 4
40132: NEG
40133: PUSH
40134: LD_INT 5
40136: NEG
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 5
40144: NEG
40145: PUSH
40146: LD_INT 4
40148: NEG
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: LD_INT 5
40156: NEG
40157: PUSH
40158: LD_INT 5
40160: NEG
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: PUSH
40166: LD_INT 5
40168: NEG
40169: PUSH
40170: LD_INT 6
40172: NEG
40173: PUSH
40174: EMPTY
40175: LIST
40176: LIST
40177: PUSH
40178: LD_INT 6
40180: NEG
40181: PUSH
40182: LD_INT 5
40184: NEG
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: LD_INT 6
40192: NEG
40193: PUSH
40194: LD_INT 6
40196: NEG
40197: PUSH
40198: EMPTY
40199: LIST
40200: LIST
40201: PUSH
40202: EMPTY
40203: LIST
40204: LIST
40205: LIST
40206: LIST
40207: LIST
40208: LIST
40209: LIST
40210: LIST
40211: LIST
40212: LIST
40213: LIST
40214: LIST
40215: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
40216: LD_ADDR_VAR 0 41
40220: PUSH
40221: LD_INT 0
40223: PUSH
40224: LD_INT 2
40226: NEG
40227: PUSH
40228: EMPTY
40229: LIST
40230: LIST
40231: PUSH
40232: LD_INT 1
40234: NEG
40235: PUSH
40236: LD_INT 3
40238: NEG
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 1
40246: PUSH
40247: LD_INT 2
40249: NEG
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: PUSH
40255: EMPTY
40256: LIST
40257: LIST
40258: LIST
40259: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
40260: LD_ADDR_VAR 0 42
40264: PUSH
40265: LD_INT 2
40267: PUSH
40268: LD_INT 0
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 2
40277: PUSH
40278: LD_INT 1
40280: NEG
40281: PUSH
40282: EMPTY
40283: LIST
40284: LIST
40285: PUSH
40286: LD_INT 3
40288: PUSH
40289: LD_INT 1
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PUSH
40296: EMPTY
40297: LIST
40298: LIST
40299: LIST
40300: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
40301: LD_ADDR_VAR 0 43
40305: PUSH
40306: LD_INT 2
40308: PUSH
40309: LD_INT 2
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: LD_INT 3
40318: PUSH
40319: LD_INT 2
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 2
40328: PUSH
40329: LD_INT 3
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: LIST
40340: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
40341: LD_ADDR_VAR 0 44
40345: PUSH
40346: LD_INT 0
40348: PUSH
40349: LD_INT 2
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 1
40358: PUSH
40359: LD_INT 3
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 1
40368: NEG
40369: PUSH
40370: LD_INT 2
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: PUSH
40377: EMPTY
40378: LIST
40379: LIST
40380: LIST
40381: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
40382: LD_ADDR_VAR 0 45
40386: PUSH
40387: LD_INT 2
40389: NEG
40390: PUSH
40391: LD_INT 0
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: PUSH
40398: LD_INT 2
40400: NEG
40401: PUSH
40402: LD_INT 1
40404: PUSH
40405: EMPTY
40406: LIST
40407: LIST
40408: PUSH
40409: LD_INT 3
40411: NEG
40412: PUSH
40413: LD_INT 1
40415: NEG
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: LIST
40425: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
40426: LD_ADDR_VAR 0 46
40430: PUSH
40431: LD_INT 2
40433: NEG
40434: PUSH
40435: LD_INT 2
40437: NEG
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: PUSH
40443: LD_INT 2
40445: NEG
40446: PUSH
40447: LD_INT 3
40449: NEG
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: LD_INT 3
40457: NEG
40458: PUSH
40459: LD_INT 2
40461: NEG
40462: PUSH
40463: EMPTY
40464: LIST
40465: LIST
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: LIST
40471: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
40472: LD_ADDR_VAR 0 47
40476: PUSH
40477: LD_INT 2
40479: NEG
40480: PUSH
40481: LD_INT 3
40483: NEG
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: PUSH
40489: LD_INT 1
40491: NEG
40492: PUSH
40493: LD_INT 3
40495: NEG
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
40505: LD_ADDR_VAR 0 48
40509: PUSH
40510: LD_INT 1
40512: PUSH
40513: LD_INT 2
40515: NEG
40516: PUSH
40517: EMPTY
40518: LIST
40519: LIST
40520: PUSH
40521: LD_INT 2
40523: PUSH
40524: LD_INT 1
40526: NEG
40527: PUSH
40528: EMPTY
40529: LIST
40530: LIST
40531: PUSH
40532: EMPTY
40533: LIST
40534: LIST
40535: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
40536: LD_ADDR_VAR 0 49
40540: PUSH
40541: LD_INT 3
40543: PUSH
40544: LD_INT 1
40546: PUSH
40547: EMPTY
40548: LIST
40549: LIST
40550: PUSH
40551: LD_INT 3
40553: PUSH
40554: LD_INT 2
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: EMPTY
40562: LIST
40563: LIST
40564: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
40565: LD_ADDR_VAR 0 50
40569: PUSH
40570: LD_INT 2
40572: PUSH
40573: LD_INT 3
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 1
40582: PUSH
40583: LD_INT 3
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
40594: LD_ADDR_VAR 0 51
40598: PUSH
40599: LD_INT 1
40601: NEG
40602: PUSH
40603: LD_INT 2
40605: PUSH
40606: EMPTY
40607: LIST
40608: LIST
40609: PUSH
40610: LD_INT 2
40612: NEG
40613: PUSH
40614: LD_INT 1
40616: PUSH
40617: EMPTY
40618: LIST
40619: LIST
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
40625: LD_ADDR_VAR 0 52
40629: PUSH
40630: LD_INT 3
40632: NEG
40633: PUSH
40634: LD_INT 1
40636: NEG
40637: PUSH
40638: EMPTY
40639: LIST
40640: LIST
40641: PUSH
40642: LD_INT 3
40644: NEG
40645: PUSH
40646: LD_INT 2
40648: NEG
40649: PUSH
40650: EMPTY
40651: LIST
40652: LIST
40653: PUSH
40654: EMPTY
40655: LIST
40656: LIST
40657: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40658: LD_ADDR_VAR 0 53
40662: PUSH
40663: LD_INT 1
40665: NEG
40666: PUSH
40667: LD_INT 3
40669: NEG
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: LD_INT 0
40677: PUSH
40678: LD_INT 3
40680: NEG
40681: PUSH
40682: EMPTY
40683: LIST
40684: LIST
40685: PUSH
40686: LD_INT 1
40688: PUSH
40689: LD_INT 2
40691: NEG
40692: PUSH
40693: EMPTY
40694: LIST
40695: LIST
40696: PUSH
40697: EMPTY
40698: LIST
40699: LIST
40700: LIST
40701: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40702: LD_ADDR_VAR 0 54
40706: PUSH
40707: LD_INT 2
40709: PUSH
40710: LD_INT 1
40712: NEG
40713: PUSH
40714: EMPTY
40715: LIST
40716: LIST
40717: PUSH
40718: LD_INT 3
40720: PUSH
40721: LD_INT 0
40723: PUSH
40724: EMPTY
40725: LIST
40726: LIST
40727: PUSH
40728: LD_INT 3
40730: PUSH
40731: LD_INT 1
40733: PUSH
40734: EMPTY
40735: LIST
40736: LIST
40737: PUSH
40738: EMPTY
40739: LIST
40740: LIST
40741: LIST
40742: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40743: LD_ADDR_VAR 0 55
40747: PUSH
40748: LD_INT 3
40750: PUSH
40751: LD_INT 2
40753: PUSH
40754: EMPTY
40755: LIST
40756: LIST
40757: PUSH
40758: LD_INT 3
40760: PUSH
40761: LD_INT 3
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: LD_INT 2
40770: PUSH
40771: LD_INT 3
40773: PUSH
40774: EMPTY
40775: LIST
40776: LIST
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: LIST
40782: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40783: LD_ADDR_VAR 0 56
40787: PUSH
40788: LD_INT 1
40790: PUSH
40791: LD_INT 3
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: LD_INT 0
40800: PUSH
40801: LD_INT 3
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 1
40810: NEG
40811: PUSH
40812: LD_INT 2
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: LIST
40823: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40824: LD_ADDR_VAR 0 57
40828: PUSH
40829: LD_INT 2
40831: NEG
40832: PUSH
40833: LD_INT 1
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: LD_INT 3
40842: NEG
40843: PUSH
40844: LD_INT 0
40846: PUSH
40847: EMPTY
40848: LIST
40849: LIST
40850: PUSH
40851: LD_INT 3
40853: NEG
40854: PUSH
40855: LD_INT 1
40857: NEG
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: LIST
40867: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40868: LD_ADDR_VAR 0 58
40872: PUSH
40873: LD_INT 2
40875: NEG
40876: PUSH
40877: LD_INT 3
40879: NEG
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: LD_INT 3
40887: NEG
40888: PUSH
40889: LD_INT 2
40891: NEG
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PUSH
40897: LD_INT 3
40899: NEG
40900: PUSH
40901: LD_INT 3
40903: NEG
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: LIST
40913: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
40914: LD_ADDR_VAR 0 59
40918: PUSH
40919: LD_INT 1
40921: NEG
40922: PUSH
40923: LD_INT 2
40925: NEG
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: LD_INT 0
40933: PUSH
40934: LD_INT 2
40936: NEG
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: PUSH
40942: LD_INT 1
40944: PUSH
40945: LD_INT 1
40947: NEG
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: LIST
40957: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
40958: LD_ADDR_VAR 0 60
40962: PUSH
40963: LD_INT 1
40965: PUSH
40966: LD_INT 1
40968: NEG
40969: PUSH
40970: EMPTY
40971: LIST
40972: LIST
40973: PUSH
40974: LD_INT 2
40976: PUSH
40977: LD_INT 0
40979: PUSH
40980: EMPTY
40981: LIST
40982: LIST
40983: PUSH
40984: LD_INT 2
40986: PUSH
40987: LD_INT 1
40989: PUSH
40990: EMPTY
40991: LIST
40992: LIST
40993: PUSH
40994: EMPTY
40995: LIST
40996: LIST
40997: LIST
40998: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
40999: LD_ADDR_VAR 0 61
41003: PUSH
41004: LD_INT 2
41006: PUSH
41007: LD_INT 1
41009: PUSH
41010: EMPTY
41011: LIST
41012: LIST
41013: PUSH
41014: LD_INT 2
41016: PUSH
41017: LD_INT 2
41019: PUSH
41020: EMPTY
41021: LIST
41022: LIST
41023: PUSH
41024: LD_INT 1
41026: PUSH
41027: LD_INT 2
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: LIST
41038: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41039: LD_ADDR_VAR 0 62
41043: PUSH
41044: LD_INT 1
41046: PUSH
41047: LD_INT 2
41049: PUSH
41050: EMPTY
41051: LIST
41052: LIST
41053: PUSH
41054: LD_INT 0
41056: PUSH
41057: LD_INT 2
41059: PUSH
41060: EMPTY
41061: LIST
41062: LIST
41063: PUSH
41064: LD_INT 1
41066: NEG
41067: PUSH
41068: LD_INT 1
41070: PUSH
41071: EMPTY
41072: LIST
41073: LIST
41074: PUSH
41075: EMPTY
41076: LIST
41077: LIST
41078: LIST
41079: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41080: LD_ADDR_VAR 0 63
41084: PUSH
41085: LD_INT 1
41087: NEG
41088: PUSH
41089: LD_INT 1
41091: PUSH
41092: EMPTY
41093: LIST
41094: LIST
41095: PUSH
41096: LD_INT 2
41098: NEG
41099: PUSH
41100: LD_INT 0
41102: PUSH
41103: EMPTY
41104: LIST
41105: LIST
41106: PUSH
41107: LD_INT 2
41109: NEG
41110: PUSH
41111: LD_INT 1
41113: NEG
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: LIST
41123: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41124: LD_ADDR_VAR 0 64
41128: PUSH
41129: LD_INT 1
41131: NEG
41132: PUSH
41133: LD_INT 2
41135: NEG
41136: PUSH
41137: EMPTY
41138: LIST
41139: LIST
41140: PUSH
41141: LD_INT 2
41143: NEG
41144: PUSH
41145: LD_INT 1
41147: NEG
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: LD_INT 2
41155: NEG
41156: PUSH
41157: LD_INT 2
41159: NEG
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: PUSH
41165: EMPTY
41166: LIST
41167: LIST
41168: LIST
41169: ST_TO_ADDR
// end ; 2 :
41170: GO 44436
41172: LD_INT 2
41174: DOUBLE
41175: EQUAL
41176: IFTRUE 41180
41178: GO 44435
41180: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41181: LD_ADDR_VAR 0 29
41185: PUSH
41186: LD_INT 4
41188: PUSH
41189: LD_INT 0
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: LD_INT 4
41198: PUSH
41199: LD_INT 1
41201: NEG
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: PUSH
41207: LD_INT 5
41209: PUSH
41210: LD_INT 0
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: PUSH
41217: LD_INT 5
41219: PUSH
41220: LD_INT 1
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: LD_INT 4
41229: PUSH
41230: LD_INT 1
41232: PUSH
41233: EMPTY
41234: LIST
41235: LIST
41236: PUSH
41237: LD_INT 3
41239: PUSH
41240: LD_INT 0
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 3
41249: PUSH
41250: LD_INT 1
41252: NEG
41253: PUSH
41254: EMPTY
41255: LIST
41256: LIST
41257: PUSH
41258: LD_INT 3
41260: PUSH
41261: LD_INT 2
41263: NEG
41264: PUSH
41265: EMPTY
41266: LIST
41267: LIST
41268: PUSH
41269: LD_INT 5
41271: PUSH
41272: LD_INT 2
41274: PUSH
41275: EMPTY
41276: LIST
41277: LIST
41278: PUSH
41279: LD_INT 3
41281: PUSH
41282: LD_INT 3
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: PUSH
41289: LD_INT 3
41291: PUSH
41292: LD_INT 2
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: PUSH
41299: LD_INT 4
41301: PUSH
41302: LD_INT 3
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: PUSH
41309: LD_INT 4
41311: PUSH
41312: LD_INT 4
41314: PUSH
41315: EMPTY
41316: LIST
41317: LIST
41318: PUSH
41319: LD_INT 3
41321: PUSH
41322: LD_INT 4
41324: PUSH
41325: EMPTY
41326: LIST
41327: LIST
41328: PUSH
41329: LD_INT 2
41331: PUSH
41332: LD_INT 3
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 2
41341: PUSH
41342: LD_INT 2
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: LD_INT 4
41351: PUSH
41352: LD_INT 2
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 2
41361: PUSH
41362: LD_INT 4
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 0
41371: PUSH
41372: LD_INT 4
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 0
41381: PUSH
41382: LD_INT 3
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: LD_INT 1
41391: PUSH
41392: LD_INT 4
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 1
41401: PUSH
41402: LD_INT 5
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 0
41411: PUSH
41412: LD_INT 5
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 1
41421: NEG
41422: PUSH
41423: LD_INT 4
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 1
41432: NEG
41433: PUSH
41434: LD_INT 3
41436: PUSH
41437: EMPTY
41438: LIST
41439: LIST
41440: PUSH
41441: LD_INT 2
41443: PUSH
41444: LD_INT 5
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PUSH
41451: LD_INT 2
41453: NEG
41454: PUSH
41455: LD_INT 3
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 3
41464: NEG
41465: PUSH
41466: LD_INT 0
41468: PUSH
41469: EMPTY
41470: LIST
41471: LIST
41472: PUSH
41473: LD_INT 3
41475: NEG
41476: PUSH
41477: LD_INT 1
41479: NEG
41480: PUSH
41481: EMPTY
41482: LIST
41483: LIST
41484: PUSH
41485: LD_INT 2
41487: NEG
41488: PUSH
41489: LD_INT 0
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: PUSH
41496: LD_INT 2
41498: NEG
41499: PUSH
41500: LD_INT 1
41502: PUSH
41503: EMPTY
41504: LIST
41505: LIST
41506: PUSH
41507: LD_INT 3
41509: NEG
41510: PUSH
41511: LD_INT 1
41513: PUSH
41514: EMPTY
41515: LIST
41516: LIST
41517: PUSH
41518: LD_INT 4
41520: NEG
41521: PUSH
41522: LD_INT 0
41524: PUSH
41525: EMPTY
41526: LIST
41527: LIST
41528: PUSH
41529: LD_INT 4
41531: NEG
41532: PUSH
41533: LD_INT 1
41535: NEG
41536: PUSH
41537: EMPTY
41538: LIST
41539: LIST
41540: PUSH
41541: LD_INT 4
41543: NEG
41544: PUSH
41545: LD_INT 2
41547: NEG
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: PUSH
41553: LD_INT 2
41555: NEG
41556: PUSH
41557: LD_INT 2
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: LD_INT 4
41566: NEG
41567: PUSH
41568: LD_INT 4
41570: NEG
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 4
41578: NEG
41579: PUSH
41580: LD_INT 5
41582: NEG
41583: PUSH
41584: EMPTY
41585: LIST
41586: LIST
41587: PUSH
41588: LD_INT 3
41590: NEG
41591: PUSH
41592: LD_INT 4
41594: NEG
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: PUSH
41600: LD_INT 3
41602: NEG
41603: PUSH
41604: LD_INT 3
41606: NEG
41607: PUSH
41608: EMPTY
41609: LIST
41610: LIST
41611: PUSH
41612: LD_INT 4
41614: NEG
41615: PUSH
41616: LD_INT 3
41618: NEG
41619: PUSH
41620: EMPTY
41621: LIST
41622: LIST
41623: PUSH
41624: LD_INT 5
41626: NEG
41627: PUSH
41628: LD_INT 4
41630: NEG
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: PUSH
41636: LD_INT 5
41638: NEG
41639: PUSH
41640: LD_INT 5
41642: NEG
41643: PUSH
41644: EMPTY
41645: LIST
41646: LIST
41647: PUSH
41648: LD_INT 3
41650: NEG
41651: PUSH
41652: LD_INT 5
41654: NEG
41655: PUSH
41656: EMPTY
41657: LIST
41658: LIST
41659: PUSH
41660: LD_INT 5
41662: NEG
41663: PUSH
41664: LD_INT 3
41666: NEG
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: LIST
41676: LIST
41677: LIST
41678: LIST
41679: LIST
41680: LIST
41681: LIST
41682: LIST
41683: LIST
41684: LIST
41685: LIST
41686: LIST
41687: LIST
41688: LIST
41689: LIST
41690: LIST
41691: LIST
41692: LIST
41693: LIST
41694: LIST
41695: LIST
41696: LIST
41697: LIST
41698: LIST
41699: LIST
41700: LIST
41701: LIST
41702: LIST
41703: LIST
41704: LIST
41705: LIST
41706: LIST
41707: LIST
41708: LIST
41709: LIST
41710: LIST
41711: LIST
41712: LIST
41713: LIST
41714: LIST
41715: LIST
41716: LIST
41717: LIST
41718: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
41719: LD_ADDR_VAR 0 30
41723: PUSH
41724: LD_INT 4
41726: PUSH
41727: LD_INT 4
41729: PUSH
41730: EMPTY
41731: LIST
41732: LIST
41733: PUSH
41734: LD_INT 4
41736: PUSH
41737: LD_INT 3
41739: PUSH
41740: EMPTY
41741: LIST
41742: LIST
41743: PUSH
41744: LD_INT 5
41746: PUSH
41747: LD_INT 4
41749: PUSH
41750: EMPTY
41751: LIST
41752: LIST
41753: PUSH
41754: LD_INT 5
41756: PUSH
41757: LD_INT 5
41759: PUSH
41760: EMPTY
41761: LIST
41762: LIST
41763: PUSH
41764: LD_INT 4
41766: PUSH
41767: LD_INT 5
41769: PUSH
41770: EMPTY
41771: LIST
41772: LIST
41773: PUSH
41774: LD_INT 3
41776: PUSH
41777: LD_INT 4
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PUSH
41784: LD_INT 3
41786: PUSH
41787: LD_INT 3
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: LD_INT 5
41796: PUSH
41797: LD_INT 3
41799: PUSH
41800: EMPTY
41801: LIST
41802: LIST
41803: PUSH
41804: LD_INT 3
41806: PUSH
41807: LD_INT 5
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: PUSH
41814: LD_INT 0
41816: PUSH
41817: LD_INT 3
41819: PUSH
41820: EMPTY
41821: LIST
41822: LIST
41823: PUSH
41824: LD_INT 0
41826: PUSH
41827: LD_INT 2
41829: PUSH
41830: EMPTY
41831: LIST
41832: LIST
41833: PUSH
41834: LD_INT 1
41836: PUSH
41837: LD_INT 3
41839: PUSH
41840: EMPTY
41841: LIST
41842: LIST
41843: PUSH
41844: LD_INT 1
41846: PUSH
41847: LD_INT 4
41849: PUSH
41850: EMPTY
41851: LIST
41852: LIST
41853: PUSH
41854: LD_INT 0
41856: PUSH
41857: LD_INT 4
41859: PUSH
41860: EMPTY
41861: LIST
41862: LIST
41863: PUSH
41864: LD_INT 1
41866: NEG
41867: PUSH
41868: LD_INT 3
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 1
41877: NEG
41878: PUSH
41879: LD_INT 2
41881: PUSH
41882: EMPTY
41883: LIST
41884: LIST
41885: PUSH
41886: LD_INT 2
41888: PUSH
41889: LD_INT 4
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: PUSH
41896: LD_INT 2
41898: NEG
41899: PUSH
41900: LD_INT 2
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: PUSH
41907: LD_INT 4
41909: NEG
41910: PUSH
41911: LD_INT 0
41913: PUSH
41914: EMPTY
41915: LIST
41916: LIST
41917: PUSH
41918: LD_INT 4
41920: NEG
41921: PUSH
41922: LD_INT 1
41924: NEG
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 3
41932: NEG
41933: PUSH
41934: LD_INT 0
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 3
41943: NEG
41944: PUSH
41945: LD_INT 1
41947: PUSH
41948: EMPTY
41949: LIST
41950: LIST
41951: PUSH
41952: LD_INT 4
41954: NEG
41955: PUSH
41956: LD_INT 1
41958: PUSH
41959: EMPTY
41960: LIST
41961: LIST
41962: PUSH
41963: LD_INT 5
41965: NEG
41966: PUSH
41967: LD_INT 0
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PUSH
41974: LD_INT 5
41976: NEG
41977: PUSH
41978: LD_INT 1
41980: NEG
41981: PUSH
41982: EMPTY
41983: LIST
41984: LIST
41985: PUSH
41986: LD_INT 5
41988: NEG
41989: PUSH
41990: LD_INT 2
41992: NEG
41993: PUSH
41994: EMPTY
41995: LIST
41996: LIST
41997: PUSH
41998: LD_INT 3
42000: NEG
42001: PUSH
42002: LD_INT 2
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 3
42011: NEG
42012: PUSH
42013: LD_INT 3
42015: NEG
42016: PUSH
42017: EMPTY
42018: LIST
42019: LIST
42020: PUSH
42021: LD_INT 3
42023: NEG
42024: PUSH
42025: LD_INT 4
42027: NEG
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: PUSH
42033: LD_INT 2
42035: NEG
42036: PUSH
42037: LD_INT 3
42039: NEG
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: PUSH
42045: LD_INT 2
42047: NEG
42048: PUSH
42049: LD_INT 2
42051: NEG
42052: PUSH
42053: EMPTY
42054: LIST
42055: LIST
42056: PUSH
42057: LD_INT 3
42059: NEG
42060: PUSH
42061: LD_INT 2
42063: NEG
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PUSH
42069: LD_INT 4
42071: NEG
42072: PUSH
42073: LD_INT 3
42075: NEG
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 4
42083: NEG
42084: PUSH
42085: LD_INT 4
42087: NEG
42088: PUSH
42089: EMPTY
42090: LIST
42091: LIST
42092: PUSH
42093: LD_INT 2
42095: NEG
42096: PUSH
42097: LD_INT 4
42099: NEG
42100: PUSH
42101: EMPTY
42102: LIST
42103: LIST
42104: PUSH
42105: LD_INT 4
42107: NEG
42108: PUSH
42109: LD_INT 2
42111: NEG
42112: PUSH
42113: EMPTY
42114: LIST
42115: LIST
42116: PUSH
42117: LD_INT 0
42119: PUSH
42120: LD_INT 4
42122: NEG
42123: PUSH
42124: EMPTY
42125: LIST
42126: LIST
42127: PUSH
42128: LD_INT 0
42130: PUSH
42131: LD_INT 5
42133: NEG
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 1
42141: PUSH
42142: LD_INT 4
42144: NEG
42145: PUSH
42146: EMPTY
42147: LIST
42148: LIST
42149: PUSH
42150: LD_INT 1
42152: PUSH
42153: LD_INT 3
42155: NEG
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 0
42163: PUSH
42164: LD_INT 3
42166: NEG
42167: PUSH
42168: EMPTY
42169: LIST
42170: LIST
42171: PUSH
42172: LD_INT 1
42174: NEG
42175: PUSH
42176: LD_INT 4
42178: NEG
42179: PUSH
42180: EMPTY
42181: LIST
42182: LIST
42183: PUSH
42184: LD_INT 1
42186: NEG
42187: PUSH
42188: LD_INT 5
42190: NEG
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 2
42198: PUSH
42199: LD_INT 3
42201: NEG
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: LD_INT 2
42209: NEG
42210: PUSH
42211: LD_INT 5
42213: NEG
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: LIST
42223: LIST
42224: LIST
42225: LIST
42226: LIST
42227: LIST
42228: LIST
42229: LIST
42230: LIST
42231: LIST
42232: LIST
42233: LIST
42234: LIST
42235: LIST
42236: LIST
42237: LIST
42238: LIST
42239: LIST
42240: LIST
42241: LIST
42242: LIST
42243: LIST
42244: LIST
42245: LIST
42246: LIST
42247: LIST
42248: LIST
42249: LIST
42250: LIST
42251: LIST
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: LIST
42257: LIST
42258: LIST
42259: LIST
42260: LIST
42261: LIST
42262: LIST
42263: LIST
42264: LIST
42265: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
42266: LD_ADDR_VAR 0 31
42270: PUSH
42271: LD_INT 0
42273: PUSH
42274: LD_INT 4
42276: PUSH
42277: EMPTY
42278: LIST
42279: LIST
42280: PUSH
42281: LD_INT 0
42283: PUSH
42284: LD_INT 3
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: PUSH
42291: LD_INT 1
42293: PUSH
42294: LD_INT 4
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PUSH
42301: LD_INT 1
42303: PUSH
42304: LD_INT 5
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: PUSH
42311: LD_INT 0
42313: PUSH
42314: LD_INT 5
42316: PUSH
42317: EMPTY
42318: LIST
42319: LIST
42320: PUSH
42321: LD_INT 1
42323: NEG
42324: PUSH
42325: LD_INT 4
42327: PUSH
42328: EMPTY
42329: LIST
42330: LIST
42331: PUSH
42332: LD_INT 1
42334: NEG
42335: PUSH
42336: LD_INT 3
42338: PUSH
42339: EMPTY
42340: LIST
42341: LIST
42342: PUSH
42343: LD_INT 2
42345: PUSH
42346: LD_INT 5
42348: PUSH
42349: EMPTY
42350: LIST
42351: LIST
42352: PUSH
42353: LD_INT 2
42355: NEG
42356: PUSH
42357: LD_INT 3
42359: PUSH
42360: EMPTY
42361: LIST
42362: LIST
42363: PUSH
42364: LD_INT 3
42366: NEG
42367: PUSH
42368: LD_INT 0
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: PUSH
42375: LD_INT 3
42377: NEG
42378: PUSH
42379: LD_INT 1
42381: NEG
42382: PUSH
42383: EMPTY
42384: LIST
42385: LIST
42386: PUSH
42387: LD_INT 2
42389: NEG
42390: PUSH
42391: LD_INT 0
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: LD_INT 2
42400: NEG
42401: PUSH
42402: LD_INT 1
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: PUSH
42409: LD_INT 3
42411: NEG
42412: PUSH
42413: LD_INT 1
42415: PUSH
42416: EMPTY
42417: LIST
42418: LIST
42419: PUSH
42420: LD_INT 4
42422: NEG
42423: PUSH
42424: LD_INT 0
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: LD_INT 4
42433: NEG
42434: PUSH
42435: LD_INT 1
42437: NEG
42438: PUSH
42439: EMPTY
42440: LIST
42441: LIST
42442: PUSH
42443: LD_INT 4
42445: NEG
42446: PUSH
42447: LD_INT 2
42449: NEG
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: PUSH
42455: LD_INT 2
42457: NEG
42458: PUSH
42459: LD_INT 2
42461: PUSH
42462: EMPTY
42463: LIST
42464: LIST
42465: PUSH
42466: LD_INT 4
42468: NEG
42469: PUSH
42470: LD_INT 4
42472: NEG
42473: PUSH
42474: EMPTY
42475: LIST
42476: LIST
42477: PUSH
42478: LD_INT 4
42480: NEG
42481: PUSH
42482: LD_INT 5
42484: NEG
42485: PUSH
42486: EMPTY
42487: LIST
42488: LIST
42489: PUSH
42490: LD_INT 3
42492: NEG
42493: PUSH
42494: LD_INT 4
42496: NEG
42497: PUSH
42498: EMPTY
42499: LIST
42500: LIST
42501: PUSH
42502: LD_INT 3
42504: NEG
42505: PUSH
42506: LD_INT 3
42508: NEG
42509: PUSH
42510: EMPTY
42511: LIST
42512: LIST
42513: PUSH
42514: LD_INT 4
42516: NEG
42517: PUSH
42518: LD_INT 3
42520: NEG
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 5
42528: NEG
42529: PUSH
42530: LD_INT 4
42532: NEG
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 5
42540: NEG
42541: PUSH
42542: LD_INT 5
42544: NEG
42545: PUSH
42546: EMPTY
42547: LIST
42548: LIST
42549: PUSH
42550: LD_INT 3
42552: NEG
42553: PUSH
42554: LD_INT 5
42556: NEG
42557: PUSH
42558: EMPTY
42559: LIST
42560: LIST
42561: PUSH
42562: LD_INT 5
42564: NEG
42565: PUSH
42566: LD_INT 3
42568: NEG
42569: PUSH
42570: EMPTY
42571: LIST
42572: LIST
42573: PUSH
42574: LD_INT 0
42576: PUSH
42577: LD_INT 3
42579: NEG
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: PUSH
42585: LD_INT 0
42587: PUSH
42588: LD_INT 4
42590: NEG
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: PUSH
42596: LD_INT 1
42598: PUSH
42599: LD_INT 3
42601: NEG
42602: PUSH
42603: EMPTY
42604: LIST
42605: LIST
42606: PUSH
42607: LD_INT 1
42609: PUSH
42610: LD_INT 2
42612: NEG
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PUSH
42618: LD_INT 0
42620: PUSH
42621: LD_INT 2
42623: NEG
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: PUSH
42629: LD_INT 1
42631: NEG
42632: PUSH
42633: LD_INT 3
42635: NEG
42636: PUSH
42637: EMPTY
42638: LIST
42639: LIST
42640: PUSH
42641: LD_INT 1
42643: NEG
42644: PUSH
42645: LD_INT 4
42647: NEG
42648: PUSH
42649: EMPTY
42650: LIST
42651: LIST
42652: PUSH
42653: LD_INT 2
42655: PUSH
42656: LD_INT 2
42658: NEG
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 2
42666: NEG
42667: PUSH
42668: LD_INT 4
42670: NEG
42671: PUSH
42672: EMPTY
42673: LIST
42674: LIST
42675: PUSH
42676: LD_INT 4
42678: PUSH
42679: LD_INT 0
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: PUSH
42686: LD_INT 4
42688: PUSH
42689: LD_INT 1
42691: NEG
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 5
42699: PUSH
42700: LD_INT 0
42702: PUSH
42703: EMPTY
42704: LIST
42705: LIST
42706: PUSH
42707: LD_INT 5
42709: PUSH
42710: LD_INT 1
42712: PUSH
42713: EMPTY
42714: LIST
42715: LIST
42716: PUSH
42717: LD_INT 4
42719: PUSH
42720: LD_INT 1
42722: PUSH
42723: EMPTY
42724: LIST
42725: LIST
42726: PUSH
42727: LD_INT 3
42729: PUSH
42730: LD_INT 0
42732: PUSH
42733: EMPTY
42734: LIST
42735: LIST
42736: PUSH
42737: LD_INT 3
42739: PUSH
42740: LD_INT 1
42742: NEG
42743: PUSH
42744: EMPTY
42745: LIST
42746: LIST
42747: PUSH
42748: LD_INT 3
42750: PUSH
42751: LD_INT 2
42753: NEG
42754: PUSH
42755: EMPTY
42756: LIST
42757: LIST
42758: PUSH
42759: LD_INT 5
42761: PUSH
42762: LD_INT 2
42764: PUSH
42765: EMPTY
42766: LIST
42767: LIST
42768: PUSH
42769: EMPTY
42770: LIST
42771: LIST
42772: LIST
42773: LIST
42774: LIST
42775: LIST
42776: LIST
42777: LIST
42778: LIST
42779: LIST
42780: LIST
42781: LIST
42782: LIST
42783: LIST
42784: LIST
42785: LIST
42786: LIST
42787: LIST
42788: LIST
42789: LIST
42790: LIST
42791: LIST
42792: LIST
42793: LIST
42794: LIST
42795: LIST
42796: LIST
42797: LIST
42798: LIST
42799: LIST
42800: LIST
42801: LIST
42802: LIST
42803: LIST
42804: LIST
42805: LIST
42806: LIST
42807: LIST
42808: LIST
42809: LIST
42810: LIST
42811: LIST
42812: LIST
42813: LIST
42814: LIST
42815: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
42816: LD_ADDR_VAR 0 32
42820: PUSH
42821: LD_INT 4
42823: NEG
42824: PUSH
42825: LD_INT 0
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: PUSH
42832: LD_INT 4
42834: NEG
42835: PUSH
42836: LD_INT 1
42838: NEG
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: PUSH
42844: LD_INT 3
42846: NEG
42847: PUSH
42848: LD_INT 0
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 3
42857: NEG
42858: PUSH
42859: LD_INT 1
42861: PUSH
42862: EMPTY
42863: LIST
42864: LIST
42865: PUSH
42866: LD_INT 4
42868: NEG
42869: PUSH
42870: LD_INT 1
42872: PUSH
42873: EMPTY
42874: LIST
42875: LIST
42876: PUSH
42877: LD_INT 5
42879: NEG
42880: PUSH
42881: LD_INT 0
42883: PUSH
42884: EMPTY
42885: LIST
42886: LIST
42887: PUSH
42888: LD_INT 5
42890: NEG
42891: PUSH
42892: LD_INT 1
42894: NEG
42895: PUSH
42896: EMPTY
42897: LIST
42898: LIST
42899: PUSH
42900: LD_INT 5
42902: NEG
42903: PUSH
42904: LD_INT 2
42906: NEG
42907: PUSH
42908: EMPTY
42909: LIST
42910: LIST
42911: PUSH
42912: LD_INT 3
42914: NEG
42915: PUSH
42916: LD_INT 2
42918: PUSH
42919: EMPTY
42920: LIST
42921: LIST
42922: PUSH
42923: LD_INT 3
42925: NEG
42926: PUSH
42927: LD_INT 3
42929: NEG
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PUSH
42935: LD_INT 3
42937: NEG
42938: PUSH
42939: LD_INT 4
42941: NEG
42942: PUSH
42943: EMPTY
42944: LIST
42945: LIST
42946: PUSH
42947: LD_INT 2
42949: NEG
42950: PUSH
42951: LD_INT 3
42953: NEG
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: LD_INT 2
42961: NEG
42962: PUSH
42963: LD_INT 2
42965: NEG
42966: PUSH
42967: EMPTY
42968: LIST
42969: LIST
42970: PUSH
42971: LD_INT 3
42973: NEG
42974: PUSH
42975: LD_INT 2
42977: NEG
42978: PUSH
42979: EMPTY
42980: LIST
42981: LIST
42982: PUSH
42983: LD_INT 4
42985: NEG
42986: PUSH
42987: LD_INT 3
42989: NEG
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: LD_INT 4
42997: NEG
42998: PUSH
42999: LD_INT 4
43001: NEG
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: PUSH
43007: LD_INT 2
43009: NEG
43010: PUSH
43011: LD_INT 4
43013: NEG
43014: PUSH
43015: EMPTY
43016: LIST
43017: LIST
43018: PUSH
43019: LD_INT 4
43021: NEG
43022: PUSH
43023: LD_INT 2
43025: NEG
43026: PUSH
43027: EMPTY
43028: LIST
43029: LIST
43030: PUSH
43031: LD_INT 0
43033: PUSH
43034: LD_INT 4
43036: NEG
43037: PUSH
43038: EMPTY
43039: LIST
43040: LIST
43041: PUSH
43042: LD_INT 0
43044: PUSH
43045: LD_INT 5
43047: NEG
43048: PUSH
43049: EMPTY
43050: LIST
43051: LIST
43052: PUSH
43053: LD_INT 1
43055: PUSH
43056: LD_INT 4
43058: NEG
43059: PUSH
43060: EMPTY
43061: LIST
43062: LIST
43063: PUSH
43064: LD_INT 1
43066: PUSH
43067: LD_INT 3
43069: NEG
43070: PUSH
43071: EMPTY
43072: LIST
43073: LIST
43074: PUSH
43075: LD_INT 0
43077: PUSH
43078: LD_INT 3
43080: NEG
43081: PUSH
43082: EMPTY
43083: LIST
43084: LIST
43085: PUSH
43086: LD_INT 1
43088: NEG
43089: PUSH
43090: LD_INT 4
43092: NEG
43093: PUSH
43094: EMPTY
43095: LIST
43096: LIST
43097: PUSH
43098: LD_INT 1
43100: NEG
43101: PUSH
43102: LD_INT 5
43104: NEG
43105: PUSH
43106: EMPTY
43107: LIST
43108: LIST
43109: PUSH
43110: LD_INT 2
43112: PUSH
43113: LD_INT 3
43115: NEG
43116: PUSH
43117: EMPTY
43118: LIST
43119: LIST
43120: PUSH
43121: LD_INT 2
43123: NEG
43124: PUSH
43125: LD_INT 5
43127: NEG
43128: PUSH
43129: EMPTY
43130: LIST
43131: LIST
43132: PUSH
43133: LD_INT 3
43135: PUSH
43136: LD_INT 0
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 3
43145: PUSH
43146: LD_INT 1
43148: NEG
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_INT 4
43156: PUSH
43157: LD_INT 0
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: PUSH
43164: LD_INT 4
43166: PUSH
43167: LD_INT 1
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: PUSH
43174: LD_INT 3
43176: PUSH
43177: LD_INT 1
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PUSH
43184: LD_INT 2
43186: PUSH
43187: LD_INT 0
43189: PUSH
43190: EMPTY
43191: LIST
43192: LIST
43193: PUSH
43194: LD_INT 2
43196: PUSH
43197: LD_INT 1
43199: NEG
43200: PUSH
43201: EMPTY
43202: LIST
43203: LIST
43204: PUSH
43205: LD_INT 2
43207: PUSH
43208: LD_INT 2
43210: NEG
43211: PUSH
43212: EMPTY
43213: LIST
43214: LIST
43215: PUSH
43216: LD_INT 4
43218: PUSH
43219: LD_INT 2
43221: PUSH
43222: EMPTY
43223: LIST
43224: LIST
43225: PUSH
43226: LD_INT 4
43228: PUSH
43229: LD_INT 4
43231: PUSH
43232: EMPTY
43233: LIST
43234: LIST
43235: PUSH
43236: LD_INT 4
43238: PUSH
43239: LD_INT 3
43241: PUSH
43242: EMPTY
43243: LIST
43244: LIST
43245: PUSH
43246: LD_INT 5
43248: PUSH
43249: LD_INT 4
43251: PUSH
43252: EMPTY
43253: LIST
43254: LIST
43255: PUSH
43256: LD_INT 5
43258: PUSH
43259: LD_INT 5
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: PUSH
43266: LD_INT 4
43268: PUSH
43269: LD_INT 5
43271: PUSH
43272: EMPTY
43273: LIST
43274: LIST
43275: PUSH
43276: LD_INT 3
43278: PUSH
43279: LD_INT 4
43281: PUSH
43282: EMPTY
43283: LIST
43284: LIST
43285: PUSH
43286: LD_INT 3
43288: PUSH
43289: LD_INT 3
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: LD_INT 5
43298: PUSH
43299: LD_INT 3
43301: PUSH
43302: EMPTY
43303: LIST
43304: LIST
43305: PUSH
43306: LD_INT 3
43308: PUSH
43309: LD_INT 5
43311: PUSH
43312: EMPTY
43313: LIST
43314: LIST
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: LIST
43320: LIST
43321: LIST
43322: LIST
43323: LIST
43324: LIST
43325: LIST
43326: LIST
43327: LIST
43328: LIST
43329: LIST
43330: LIST
43331: LIST
43332: LIST
43333: LIST
43334: LIST
43335: LIST
43336: LIST
43337: LIST
43338: LIST
43339: LIST
43340: LIST
43341: LIST
43342: LIST
43343: LIST
43344: LIST
43345: LIST
43346: LIST
43347: LIST
43348: LIST
43349: LIST
43350: LIST
43351: LIST
43352: LIST
43353: LIST
43354: LIST
43355: LIST
43356: LIST
43357: LIST
43358: LIST
43359: LIST
43360: LIST
43361: LIST
43362: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
43363: LD_ADDR_VAR 0 33
43367: PUSH
43368: LD_INT 4
43370: NEG
43371: PUSH
43372: LD_INT 4
43374: NEG
43375: PUSH
43376: EMPTY
43377: LIST
43378: LIST
43379: PUSH
43380: LD_INT 4
43382: NEG
43383: PUSH
43384: LD_INT 5
43386: NEG
43387: PUSH
43388: EMPTY
43389: LIST
43390: LIST
43391: PUSH
43392: LD_INT 3
43394: NEG
43395: PUSH
43396: LD_INT 4
43398: NEG
43399: PUSH
43400: EMPTY
43401: LIST
43402: LIST
43403: PUSH
43404: LD_INT 3
43406: NEG
43407: PUSH
43408: LD_INT 3
43410: NEG
43411: PUSH
43412: EMPTY
43413: LIST
43414: LIST
43415: PUSH
43416: LD_INT 4
43418: NEG
43419: PUSH
43420: LD_INT 3
43422: NEG
43423: PUSH
43424: EMPTY
43425: LIST
43426: LIST
43427: PUSH
43428: LD_INT 5
43430: NEG
43431: PUSH
43432: LD_INT 4
43434: NEG
43435: PUSH
43436: EMPTY
43437: LIST
43438: LIST
43439: PUSH
43440: LD_INT 5
43442: NEG
43443: PUSH
43444: LD_INT 5
43446: NEG
43447: PUSH
43448: EMPTY
43449: LIST
43450: LIST
43451: PUSH
43452: LD_INT 3
43454: NEG
43455: PUSH
43456: LD_INT 5
43458: NEG
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PUSH
43464: LD_INT 5
43466: NEG
43467: PUSH
43468: LD_INT 3
43470: NEG
43471: PUSH
43472: EMPTY
43473: LIST
43474: LIST
43475: PUSH
43476: LD_INT 0
43478: PUSH
43479: LD_INT 3
43481: NEG
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 0
43489: PUSH
43490: LD_INT 4
43492: NEG
43493: PUSH
43494: EMPTY
43495: LIST
43496: LIST
43497: PUSH
43498: LD_INT 1
43500: PUSH
43501: LD_INT 3
43503: NEG
43504: PUSH
43505: EMPTY
43506: LIST
43507: LIST
43508: PUSH
43509: LD_INT 1
43511: PUSH
43512: LD_INT 2
43514: NEG
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: PUSH
43520: LD_INT 0
43522: PUSH
43523: LD_INT 2
43525: NEG
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: PUSH
43531: LD_INT 1
43533: NEG
43534: PUSH
43535: LD_INT 3
43537: NEG
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: PUSH
43543: LD_INT 1
43545: NEG
43546: PUSH
43547: LD_INT 4
43549: NEG
43550: PUSH
43551: EMPTY
43552: LIST
43553: LIST
43554: PUSH
43555: LD_INT 2
43557: PUSH
43558: LD_INT 2
43560: NEG
43561: PUSH
43562: EMPTY
43563: LIST
43564: LIST
43565: PUSH
43566: LD_INT 2
43568: NEG
43569: PUSH
43570: LD_INT 4
43572: NEG
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 4
43580: PUSH
43581: LD_INT 0
43583: PUSH
43584: EMPTY
43585: LIST
43586: LIST
43587: PUSH
43588: LD_INT 4
43590: PUSH
43591: LD_INT 1
43593: NEG
43594: PUSH
43595: EMPTY
43596: LIST
43597: LIST
43598: PUSH
43599: LD_INT 5
43601: PUSH
43602: LD_INT 0
43604: PUSH
43605: EMPTY
43606: LIST
43607: LIST
43608: PUSH
43609: LD_INT 5
43611: PUSH
43612: LD_INT 1
43614: PUSH
43615: EMPTY
43616: LIST
43617: LIST
43618: PUSH
43619: LD_INT 4
43621: PUSH
43622: LD_INT 1
43624: PUSH
43625: EMPTY
43626: LIST
43627: LIST
43628: PUSH
43629: LD_INT 3
43631: PUSH
43632: LD_INT 0
43634: PUSH
43635: EMPTY
43636: LIST
43637: LIST
43638: PUSH
43639: LD_INT 3
43641: PUSH
43642: LD_INT 1
43644: NEG
43645: PUSH
43646: EMPTY
43647: LIST
43648: LIST
43649: PUSH
43650: LD_INT 3
43652: PUSH
43653: LD_INT 2
43655: NEG
43656: PUSH
43657: EMPTY
43658: LIST
43659: LIST
43660: PUSH
43661: LD_INT 5
43663: PUSH
43664: LD_INT 2
43666: PUSH
43667: EMPTY
43668: LIST
43669: LIST
43670: PUSH
43671: LD_INT 3
43673: PUSH
43674: LD_INT 3
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: PUSH
43681: LD_INT 3
43683: PUSH
43684: LD_INT 2
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: PUSH
43691: LD_INT 4
43693: PUSH
43694: LD_INT 3
43696: PUSH
43697: EMPTY
43698: LIST
43699: LIST
43700: PUSH
43701: LD_INT 4
43703: PUSH
43704: LD_INT 4
43706: PUSH
43707: EMPTY
43708: LIST
43709: LIST
43710: PUSH
43711: LD_INT 3
43713: PUSH
43714: LD_INT 4
43716: PUSH
43717: EMPTY
43718: LIST
43719: LIST
43720: PUSH
43721: LD_INT 2
43723: PUSH
43724: LD_INT 3
43726: PUSH
43727: EMPTY
43728: LIST
43729: LIST
43730: PUSH
43731: LD_INT 2
43733: PUSH
43734: LD_INT 2
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: PUSH
43741: LD_INT 4
43743: PUSH
43744: LD_INT 2
43746: PUSH
43747: EMPTY
43748: LIST
43749: LIST
43750: PUSH
43751: LD_INT 2
43753: PUSH
43754: LD_INT 4
43756: PUSH
43757: EMPTY
43758: LIST
43759: LIST
43760: PUSH
43761: LD_INT 0
43763: PUSH
43764: LD_INT 4
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 0
43773: PUSH
43774: LD_INT 3
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: LD_INT 1
43783: PUSH
43784: LD_INT 4
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PUSH
43791: LD_INT 1
43793: PUSH
43794: LD_INT 5
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 0
43803: PUSH
43804: LD_INT 5
43806: PUSH
43807: EMPTY
43808: LIST
43809: LIST
43810: PUSH
43811: LD_INT 1
43813: NEG
43814: PUSH
43815: LD_INT 4
43817: PUSH
43818: EMPTY
43819: LIST
43820: LIST
43821: PUSH
43822: LD_INT 1
43824: NEG
43825: PUSH
43826: LD_INT 3
43828: PUSH
43829: EMPTY
43830: LIST
43831: LIST
43832: PUSH
43833: LD_INT 2
43835: PUSH
43836: LD_INT 5
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PUSH
43843: LD_INT 2
43845: NEG
43846: PUSH
43847: LD_INT 3
43849: PUSH
43850: EMPTY
43851: LIST
43852: LIST
43853: PUSH
43854: EMPTY
43855: LIST
43856: LIST
43857: LIST
43858: LIST
43859: LIST
43860: LIST
43861: LIST
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: LIST
43867: LIST
43868: LIST
43869: LIST
43870: LIST
43871: LIST
43872: LIST
43873: LIST
43874: LIST
43875: LIST
43876: LIST
43877: LIST
43878: LIST
43879: LIST
43880: LIST
43881: LIST
43882: LIST
43883: LIST
43884: LIST
43885: LIST
43886: LIST
43887: LIST
43888: LIST
43889: LIST
43890: LIST
43891: LIST
43892: LIST
43893: LIST
43894: LIST
43895: LIST
43896: LIST
43897: LIST
43898: LIST
43899: LIST
43900: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
43901: LD_ADDR_VAR 0 34
43905: PUSH
43906: LD_INT 0
43908: PUSH
43909: LD_INT 4
43911: NEG
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 0
43919: PUSH
43920: LD_INT 5
43922: NEG
43923: PUSH
43924: EMPTY
43925: LIST
43926: LIST
43927: PUSH
43928: LD_INT 1
43930: PUSH
43931: LD_INT 4
43933: NEG
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PUSH
43939: LD_INT 1
43941: PUSH
43942: LD_INT 3
43944: NEG
43945: PUSH
43946: EMPTY
43947: LIST
43948: LIST
43949: PUSH
43950: LD_INT 0
43952: PUSH
43953: LD_INT 3
43955: NEG
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PUSH
43961: LD_INT 1
43963: NEG
43964: PUSH
43965: LD_INT 4
43967: NEG
43968: PUSH
43969: EMPTY
43970: LIST
43971: LIST
43972: PUSH
43973: LD_INT 1
43975: NEG
43976: PUSH
43977: LD_INT 5
43979: NEG
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: PUSH
43985: LD_INT 2
43987: PUSH
43988: LD_INT 3
43990: NEG
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: PUSH
43996: LD_INT 2
43998: NEG
43999: PUSH
44000: LD_INT 5
44002: NEG
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: LD_INT 3
44010: PUSH
44011: LD_INT 0
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: LD_INT 3
44020: PUSH
44021: LD_INT 1
44023: NEG
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 4
44031: PUSH
44032: LD_INT 0
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 4
44041: PUSH
44042: LD_INT 1
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PUSH
44049: LD_INT 3
44051: PUSH
44052: LD_INT 1
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: LD_INT 2
44061: PUSH
44062: LD_INT 0
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: PUSH
44069: LD_INT 2
44071: PUSH
44072: LD_INT 1
44074: NEG
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_INT 2
44082: PUSH
44083: LD_INT 2
44085: NEG
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: LD_INT 4
44093: PUSH
44094: LD_INT 2
44096: PUSH
44097: EMPTY
44098: LIST
44099: LIST
44100: PUSH
44101: LD_INT 4
44103: PUSH
44104: LD_INT 4
44106: PUSH
44107: EMPTY
44108: LIST
44109: LIST
44110: PUSH
44111: LD_INT 4
44113: PUSH
44114: LD_INT 3
44116: PUSH
44117: EMPTY
44118: LIST
44119: LIST
44120: PUSH
44121: LD_INT 5
44123: PUSH
44124: LD_INT 4
44126: PUSH
44127: EMPTY
44128: LIST
44129: LIST
44130: PUSH
44131: LD_INT 5
44133: PUSH
44134: LD_INT 5
44136: PUSH
44137: EMPTY
44138: LIST
44139: LIST
44140: PUSH
44141: LD_INT 4
44143: PUSH
44144: LD_INT 5
44146: PUSH
44147: EMPTY
44148: LIST
44149: LIST
44150: PUSH
44151: LD_INT 3
44153: PUSH
44154: LD_INT 4
44156: PUSH
44157: EMPTY
44158: LIST
44159: LIST
44160: PUSH
44161: LD_INT 3
44163: PUSH
44164: LD_INT 3
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 5
44173: PUSH
44174: LD_INT 3
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: PUSH
44181: LD_INT 3
44183: PUSH
44184: LD_INT 5
44186: PUSH
44187: EMPTY
44188: LIST
44189: LIST
44190: PUSH
44191: LD_INT 0
44193: PUSH
44194: LD_INT 3
44196: PUSH
44197: EMPTY
44198: LIST
44199: LIST
44200: PUSH
44201: LD_INT 0
44203: PUSH
44204: LD_INT 2
44206: PUSH
44207: EMPTY
44208: LIST
44209: LIST
44210: PUSH
44211: LD_INT 1
44213: PUSH
44214: LD_INT 3
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: PUSH
44221: LD_INT 1
44223: PUSH
44224: LD_INT 4
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 0
44233: PUSH
44234: LD_INT 4
44236: PUSH
44237: EMPTY
44238: LIST
44239: LIST
44240: PUSH
44241: LD_INT 1
44243: NEG
44244: PUSH
44245: LD_INT 3
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: PUSH
44252: LD_INT 1
44254: NEG
44255: PUSH
44256: LD_INT 2
44258: PUSH
44259: EMPTY
44260: LIST
44261: LIST
44262: PUSH
44263: LD_INT 2
44265: PUSH
44266: LD_INT 4
44268: PUSH
44269: EMPTY
44270: LIST
44271: LIST
44272: PUSH
44273: LD_INT 2
44275: NEG
44276: PUSH
44277: LD_INT 2
44279: PUSH
44280: EMPTY
44281: LIST
44282: LIST
44283: PUSH
44284: LD_INT 4
44286: NEG
44287: PUSH
44288: LD_INT 0
44290: PUSH
44291: EMPTY
44292: LIST
44293: LIST
44294: PUSH
44295: LD_INT 4
44297: NEG
44298: PUSH
44299: LD_INT 1
44301: NEG
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: PUSH
44307: LD_INT 3
44309: NEG
44310: PUSH
44311: LD_INT 0
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: PUSH
44318: LD_INT 3
44320: NEG
44321: PUSH
44322: LD_INT 1
44324: PUSH
44325: EMPTY
44326: LIST
44327: LIST
44328: PUSH
44329: LD_INT 4
44331: NEG
44332: PUSH
44333: LD_INT 1
44335: PUSH
44336: EMPTY
44337: LIST
44338: LIST
44339: PUSH
44340: LD_INT 5
44342: NEG
44343: PUSH
44344: LD_INT 0
44346: PUSH
44347: EMPTY
44348: LIST
44349: LIST
44350: PUSH
44351: LD_INT 5
44353: NEG
44354: PUSH
44355: LD_INT 1
44357: NEG
44358: PUSH
44359: EMPTY
44360: LIST
44361: LIST
44362: PUSH
44363: LD_INT 5
44365: NEG
44366: PUSH
44367: LD_INT 2
44369: NEG
44370: PUSH
44371: EMPTY
44372: LIST
44373: LIST
44374: PUSH
44375: LD_INT 3
44377: NEG
44378: PUSH
44379: LD_INT 2
44381: PUSH
44382: EMPTY
44383: LIST
44384: LIST
44385: PUSH
44386: EMPTY
44387: LIST
44388: LIST
44389: LIST
44390: LIST
44391: LIST
44392: LIST
44393: LIST
44394: LIST
44395: LIST
44396: LIST
44397: LIST
44398: LIST
44399: LIST
44400: LIST
44401: LIST
44402: LIST
44403: LIST
44404: LIST
44405: LIST
44406: LIST
44407: LIST
44408: LIST
44409: LIST
44410: LIST
44411: LIST
44412: LIST
44413: LIST
44414: LIST
44415: LIST
44416: LIST
44417: LIST
44418: LIST
44419: LIST
44420: LIST
44421: LIST
44422: LIST
44423: LIST
44424: LIST
44425: LIST
44426: LIST
44427: LIST
44428: LIST
44429: LIST
44430: LIST
44431: LIST
44432: ST_TO_ADDR
// end ; end ;
44433: GO 44436
44435: POP
// case btype of b_depot , b_warehouse :
44436: LD_VAR 0 1
44440: PUSH
44441: LD_INT 0
44443: DOUBLE
44444: EQUAL
44445: IFTRUE 44455
44447: LD_INT 1
44449: DOUBLE
44450: EQUAL
44451: IFTRUE 44455
44453: GO 44656
44455: POP
// case nation of nation_american :
44456: LD_VAR 0 5
44460: PUSH
44461: LD_INT 1
44463: DOUBLE
44464: EQUAL
44465: IFTRUE 44469
44467: GO 44525
44469: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
44470: LD_ADDR_VAR 0 9
44474: PUSH
44475: LD_VAR 0 11
44479: PUSH
44480: LD_VAR 0 12
44484: PUSH
44485: LD_VAR 0 13
44489: PUSH
44490: LD_VAR 0 14
44494: PUSH
44495: LD_VAR 0 15
44499: PUSH
44500: LD_VAR 0 16
44504: PUSH
44505: EMPTY
44506: LIST
44507: LIST
44508: LIST
44509: LIST
44510: LIST
44511: LIST
44512: PUSH
44513: LD_VAR 0 4
44517: PUSH
44518: LD_INT 1
44520: PLUS
44521: ARRAY
44522: ST_TO_ADDR
44523: GO 44654
44525: LD_INT 2
44527: DOUBLE
44528: EQUAL
44529: IFTRUE 44533
44531: GO 44589
44533: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
44534: LD_ADDR_VAR 0 9
44538: PUSH
44539: LD_VAR 0 17
44543: PUSH
44544: LD_VAR 0 18
44548: PUSH
44549: LD_VAR 0 19
44553: PUSH
44554: LD_VAR 0 20
44558: PUSH
44559: LD_VAR 0 21
44563: PUSH
44564: LD_VAR 0 22
44568: PUSH
44569: EMPTY
44570: LIST
44571: LIST
44572: LIST
44573: LIST
44574: LIST
44575: LIST
44576: PUSH
44577: LD_VAR 0 4
44581: PUSH
44582: LD_INT 1
44584: PLUS
44585: ARRAY
44586: ST_TO_ADDR
44587: GO 44654
44589: LD_INT 3
44591: DOUBLE
44592: EQUAL
44593: IFTRUE 44597
44595: GO 44653
44597: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
44598: LD_ADDR_VAR 0 9
44602: PUSH
44603: LD_VAR 0 23
44607: PUSH
44608: LD_VAR 0 24
44612: PUSH
44613: LD_VAR 0 25
44617: PUSH
44618: LD_VAR 0 26
44622: PUSH
44623: LD_VAR 0 27
44627: PUSH
44628: LD_VAR 0 28
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: LIST
44637: LIST
44638: LIST
44639: LIST
44640: PUSH
44641: LD_VAR 0 4
44645: PUSH
44646: LD_INT 1
44648: PLUS
44649: ARRAY
44650: ST_TO_ADDR
44651: GO 44654
44653: POP
44654: GO 45209
44656: LD_INT 2
44658: DOUBLE
44659: EQUAL
44660: IFTRUE 44670
44662: LD_INT 3
44664: DOUBLE
44665: EQUAL
44666: IFTRUE 44670
44668: GO 44726
44670: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
44671: LD_ADDR_VAR 0 9
44675: PUSH
44676: LD_VAR 0 29
44680: PUSH
44681: LD_VAR 0 30
44685: PUSH
44686: LD_VAR 0 31
44690: PUSH
44691: LD_VAR 0 32
44695: PUSH
44696: LD_VAR 0 33
44700: PUSH
44701: LD_VAR 0 34
44705: PUSH
44706: EMPTY
44707: LIST
44708: LIST
44709: LIST
44710: LIST
44711: LIST
44712: LIST
44713: PUSH
44714: LD_VAR 0 4
44718: PUSH
44719: LD_INT 1
44721: PLUS
44722: ARRAY
44723: ST_TO_ADDR
44724: GO 45209
44726: LD_INT 16
44728: DOUBLE
44729: EQUAL
44730: IFTRUE 44788
44732: LD_INT 17
44734: DOUBLE
44735: EQUAL
44736: IFTRUE 44788
44738: LD_INT 18
44740: DOUBLE
44741: EQUAL
44742: IFTRUE 44788
44744: LD_INT 19
44746: DOUBLE
44747: EQUAL
44748: IFTRUE 44788
44750: LD_INT 22
44752: DOUBLE
44753: EQUAL
44754: IFTRUE 44788
44756: LD_INT 20
44758: DOUBLE
44759: EQUAL
44760: IFTRUE 44788
44762: LD_INT 21
44764: DOUBLE
44765: EQUAL
44766: IFTRUE 44788
44768: LD_INT 23
44770: DOUBLE
44771: EQUAL
44772: IFTRUE 44788
44774: LD_INT 24
44776: DOUBLE
44777: EQUAL
44778: IFTRUE 44788
44780: LD_INT 25
44782: DOUBLE
44783: EQUAL
44784: IFTRUE 44788
44786: GO 44844
44788: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
44789: LD_ADDR_VAR 0 9
44793: PUSH
44794: LD_VAR 0 35
44798: PUSH
44799: LD_VAR 0 36
44803: PUSH
44804: LD_VAR 0 37
44808: PUSH
44809: LD_VAR 0 38
44813: PUSH
44814: LD_VAR 0 39
44818: PUSH
44819: LD_VAR 0 40
44823: PUSH
44824: EMPTY
44825: LIST
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: LIST
44831: PUSH
44832: LD_VAR 0 4
44836: PUSH
44837: LD_INT 1
44839: PLUS
44840: ARRAY
44841: ST_TO_ADDR
44842: GO 45209
44844: LD_INT 6
44846: DOUBLE
44847: EQUAL
44848: IFTRUE 44900
44850: LD_INT 7
44852: DOUBLE
44853: EQUAL
44854: IFTRUE 44900
44856: LD_INT 8
44858: DOUBLE
44859: EQUAL
44860: IFTRUE 44900
44862: LD_INT 13
44864: DOUBLE
44865: EQUAL
44866: IFTRUE 44900
44868: LD_INT 12
44870: DOUBLE
44871: EQUAL
44872: IFTRUE 44900
44874: LD_INT 15
44876: DOUBLE
44877: EQUAL
44878: IFTRUE 44900
44880: LD_INT 11
44882: DOUBLE
44883: EQUAL
44884: IFTRUE 44900
44886: LD_INT 14
44888: DOUBLE
44889: EQUAL
44890: IFTRUE 44900
44892: LD_INT 10
44894: DOUBLE
44895: EQUAL
44896: IFTRUE 44900
44898: GO 44956
44900: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
44901: LD_ADDR_VAR 0 9
44905: PUSH
44906: LD_VAR 0 41
44910: PUSH
44911: LD_VAR 0 42
44915: PUSH
44916: LD_VAR 0 43
44920: PUSH
44921: LD_VAR 0 44
44925: PUSH
44926: LD_VAR 0 45
44930: PUSH
44931: LD_VAR 0 46
44935: PUSH
44936: EMPTY
44937: LIST
44938: LIST
44939: LIST
44940: LIST
44941: LIST
44942: LIST
44943: PUSH
44944: LD_VAR 0 4
44948: PUSH
44949: LD_INT 1
44951: PLUS
44952: ARRAY
44953: ST_TO_ADDR
44954: GO 45209
44956: LD_INT 36
44958: DOUBLE
44959: EQUAL
44960: IFTRUE 44964
44962: GO 45020
44964: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
44965: LD_ADDR_VAR 0 9
44969: PUSH
44970: LD_VAR 0 47
44974: PUSH
44975: LD_VAR 0 48
44979: PUSH
44980: LD_VAR 0 49
44984: PUSH
44985: LD_VAR 0 50
44989: PUSH
44990: LD_VAR 0 51
44994: PUSH
44995: LD_VAR 0 52
44999: PUSH
45000: EMPTY
45001: LIST
45002: LIST
45003: LIST
45004: LIST
45005: LIST
45006: LIST
45007: PUSH
45008: LD_VAR 0 4
45012: PUSH
45013: LD_INT 1
45015: PLUS
45016: ARRAY
45017: ST_TO_ADDR
45018: GO 45209
45020: LD_INT 4
45022: DOUBLE
45023: EQUAL
45024: IFTRUE 45046
45026: LD_INT 5
45028: DOUBLE
45029: EQUAL
45030: IFTRUE 45046
45032: LD_INT 34
45034: DOUBLE
45035: EQUAL
45036: IFTRUE 45046
45038: LD_INT 37
45040: DOUBLE
45041: EQUAL
45042: IFTRUE 45046
45044: GO 45102
45046: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45047: LD_ADDR_VAR 0 9
45051: PUSH
45052: LD_VAR 0 53
45056: PUSH
45057: LD_VAR 0 54
45061: PUSH
45062: LD_VAR 0 55
45066: PUSH
45067: LD_VAR 0 56
45071: PUSH
45072: LD_VAR 0 57
45076: PUSH
45077: LD_VAR 0 58
45081: PUSH
45082: EMPTY
45083: LIST
45084: LIST
45085: LIST
45086: LIST
45087: LIST
45088: LIST
45089: PUSH
45090: LD_VAR 0 4
45094: PUSH
45095: LD_INT 1
45097: PLUS
45098: ARRAY
45099: ST_TO_ADDR
45100: GO 45209
45102: LD_INT 31
45104: DOUBLE
45105: EQUAL
45106: IFTRUE 45152
45108: LD_INT 32
45110: DOUBLE
45111: EQUAL
45112: IFTRUE 45152
45114: LD_INT 33
45116: DOUBLE
45117: EQUAL
45118: IFTRUE 45152
45120: LD_INT 27
45122: DOUBLE
45123: EQUAL
45124: IFTRUE 45152
45126: LD_INT 26
45128: DOUBLE
45129: EQUAL
45130: IFTRUE 45152
45132: LD_INT 28
45134: DOUBLE
45135: EQUAL
45136: IFTRUE 45152
45138: LD_INT 29
45140: DOUBLE
45141: EQUAL
45142: IFTRUE 45152
45144: LD_INT 30
45146: DOUBLE
45147: EQUAL
45148: IFTRUE 45152
45150: GO 45208
45152: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
45153: LD_ADDR_VAR 0 9
45157: PUSH
45158: LD_VAR 0 59
45162: PUSH
45163: LD_VAR 0 60
45167: PUSH
45168: LD_VAR 0 61
45172: PUSH
45173: LD_VAR 0 62
45177: PUSH
45178: LD_VAR 0 63
45182: PUSH
45183: LD_VAR 0 64
45187: PUSH
45188: EMPTY
45189: LIST
45190: LIST
45191: LIST
45192: LIST
45193: LIST
45194: LIST
45195: PUSH
45196: LD_VAR 0 4
45200: PUSH
45201: LD_INT 1
45203: PLUS
45204: ARRAY
45205: ST_TO_ADDR
45206: GO 45209
45208: POP
// temp_list2 = [ ] ;
45209: LD_ADDR_VAR 0 10
45213: PUSH
45214: EMPTY
45215: ST_TO_ADDR
// for i in temp_list do
45216: LD_ADDR_VAR 0 8
45220: PUSH
45221: LD_VAR 0 9
45225: PUSH
45226: FOR_IN
45227: IFFALSE 45279
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
45229: LD_ADDR_VAR 0 10
45233: PUSH
45234: LD_VAR 0 10
45238: PUSH
45239: LD_VAR 0 8
45243: PUSH
45244: LD_INT 1
45246: ARRAY
45247: PUSH
45248: LD_VAR 0 2
45252: PLUS
45253: PUSH
45254: LD_VAR 0 8
45258: PUSH
45259: LD_INT 2
45261: ARRAY
45262: PUSH
45263: LD_VAR 0 3
45267: PLUS
45268: PUSH
45269: EMPTY
45270: LIST
45271: LIST
45272: PUSH
45273: EMPTY
45274: LIST
45275: ADD
45276: ST_TO_ADDR
45277: GO 45226
45279: POP
45280: POP
// result = temp_list2 ;
45281: LD_ADDR_VAR 0 7
45285: PUSH
45286: LD_VAR 0 10
45290: ST_TO_ADDR
// end ;
45291: LD_VAR 0 7
45295: RET
// export function EnemyInRange ( unit , dist ) ; begin
45296: LD_INT 0
45298: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
45299: LD_ADDR_VAR 0 3
45303: PUSH
45304: LD_VAR 0 1
45308: PPUSH
45309: CALL_OW 255
45313: PPUSH
45314: LD_VAR 0 1
45318: PPUSH
45319: CALL_OW 250
45323: PPUSH
45324: LD_VAR 0 1
45328: PPUSH
45329: CALL_OW 251
45333: PPUSH
45334: LD_VAR 0 2
45338: PPUSH
45339: CALL 19400 0 4
45343: PUSH
45344: LD_INT 4
45346: ARRAY
45347: ST_TO_ADDR
// end ;
45348: LD_VAR 0 3
45352: RET
// export function PlayerSeeMe ( unit ) ; begin
45353: LD_INT 0
45355: PPUSH
// result := See ( your_side , unit ) ;
45356: LD_ADDR_VAR 0 2
45360: PUSH
45361: LD_OWVAR 2
45365: PPUSH
45366: LD_VAR 0 1
45370: PPUSH
45371: CALL_OW 292
45375: ST_TO_ADDR
// end ;
45376: LD_VAR 0 2
45380: RET
// export function ReverseDir ( unit ) ; begin
45381: LD_INT 0
45383: PPUSH
// if not unit then
45384: LD_VAR 0 1
45388: NOT
45389: IFFALSE 45393
// exit ;
45391: GO 45416
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
45393: LD_ADDR_VAR 0 2
45397: PUSH
45398: LD_VAR 0 1
45402: PPUSH
45403: CALL_OW 254
45407: PUSH
45408: LD_INT 3
45410: PLUS
45411: PUSH
45412: LD_INT 6
45414: MOD
45415: ST_TO_ADDR
// end ;
45416: LD_VAR 0 2
45420: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
45421: LD_INT 0
45423: PPUSH
45424: PPUSH
45425: PPUSH
45426: PPUSH
45427: PPUSH
// if not hexes then
45428: LD_VAR 0 2
45432: NOT
45433: IFFALSE 45437
// exit ;
45435: GO 45585
// dist := 9999 ;
45437: LD_ADDR_VAR 0 5
45441: PUSH
45442: LD_INT 9999
45444: ST_TO_ADDR
// for i = 1 to hexes do
45445: LD_ADDR_VAR 0 4
45449: PUSH
45450: DOUBLE
45451: LD_INT 1
45453: DEC
45454: ST_TO_ADDR
45455: LD_VAR 0 2
45459: PUSH
45460: FOR_TO
45461: IFFALSE 45573
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
45463: LD_VAR 0 1
45467: PPUSH
45468: LD_VAR 0 2
45472: PUSH
45473: LD_VAR 0 4
45477: ARRAY
45478: PUSH
45479: LD_INT 1
45481: ARRAY
45482: PPUSH
45483: LD_VAR 0 2
45487: PUSH
45488: LD_VAR 0 4
45492: ARRAY
45493: PUSH
45494: LD_INT 2
45496: ARRAY
45497: PPUSH
45498: CALL_OW 297
45502: PUSH
45503: LD_VAR 0 5
45507: LESS
45508: IFFALSE 45571
// begin hex := hexes [ i ] ;
45510: LD_ADDR_VAR 0 7
45514: PUSH
45515: LD_VAR 0 2
45519: PUSH
45520: LD_VAR 0 4
45524: ARRAY
45525: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
45526: LD_ADDR_VAR 0 5
45530: PUSH
45531: LD_VAR 0 1
45535: PPUSH
45536: LD_VAR 0 2
45540: PUSH
45541: LD_VAR 0 4
45545: ARRAY
45546: PUSH
45547: LD_INT 1
45549: ARRAY
45550: PPUSH
45551: LD_VAR 0 2
45555: PUSH
45556: LD_VAR 0 4
45560: ARRAY
45561: PUSH
45562: LD_INT 2
45564: ARRAY
45565: PPUSH
45566: CALL_OW 297
45570: ST_TO_ADDR
// end ; end ;
45571: GO 45460
45573: POP
45574: POP
// result := hex ;
45575: LD_ADDR_VAR 0 3
45579: PUSH
45580: LD_VAR 0 7
45584: ST_TO_ADDR
// end ;
45585: LD_VAR 0 3
45589: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
45590: LD_INT 0
45592: PPUSH
45593: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
45594: LD_VAR 0 1
45598: NOT
45599: PUSH
45600: LD_VAR 0 1
45604: PUSH
45605: LD_INT 21
45607: PUSH
45608: LD_INT 2
45610: PUSH
45611: EMPTY
45612: LIST
45613: LIST
45614: PUSH
45615: LD_INT 23
45617: PUSH
45618: LD_INT 2
45620: PUSH
45621: EMPTY
45622: LIST
45623: LIST
45624: PUSH
45625: EMPTY
45626: LIST
45627: LIST
45628: PPUSH
45629: CALL_OW 69
45633: IN
45634: NOT
45635: OR
45636: IFFALSE 45640
// exit ;
45638: GO 45687
// for i = 1 to 3 do
45640: LD_ADDR_VAR 0 3
45644: PUSH
45645: DOUBLE
45646: LD_INT 1
45648: DEC
45649: ST_TO_ADDR
45650: LD_INT 3
45652: PUSH
45653: FOR_TO
45654: IFFALSE 45685
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
45656: LD_VAR 0 1
45660: PPUSH
45661: CALL_OW 250
45665: PPUSH
45666: LD_VAR 0 1
45670: PPUSH
45671: CALL_OW 251
45675: PPUSH
45676: LD_INT 1
45678: PPUSH
45679: CALL_OW 453
45683: GO 45653
45685: POP
45686: POP
// end ;
45687: LD_VAR 0 2
45691: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
45692: LD_INT 0
45694: PPUSH
45695: PPUSH
45696: PPUSH
45697: PPUSH
45698: PPUSH
45699: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
45700: LD_VAR 0 1
45704: NOT
45705: PUSH
45706: LD_VAR 0 2
45710: NOT
45711: OR
45712: PUSH
45713: LD_VAR 0 1
45717: PPUSH
45718: CALL_OW 314
45722: OR
45723: IFFALSE 45727
// exit ;
45725: GO 46168
// x := GetX ( enemy_unit ) ;
45727: LD_ADDR_VAR 0 7
45731: PUSH
45732: LD_VAR 0 2
45736: PPUSH
45737: CALL_OW 250
45741: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
45742: LD_ADDR_VAR 0 8
45746: PUSH
45747: LD_VAR 0 2
45751: PPUSH
45752: CALL_OW 251
45756: ST_TO_ADDR
// if not x or not y then
45757: LD_VAR 0 7
45761: NOT
45762: PUSH
45763: LD_VAR 0 8
45767: NOT
45768: OR
45769: IFFALSE 45773
// exit ;
45771: GO 46168
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
45773: LD_ADDR_VAR 0 6
45777: PUSH
45778: LD_VAR 0 7
45782: PPUSH
45783: LD_INT 0
45785: PPUSH
45786: LD_INT 4
45788: PPUSH
45789: CALL_OW 272
45793: PUSH
45794: LD_VAR 0 8
45798: PPUSH
45799: LD_INT 0
45801: PPUSH
45802: LD_INT 4
45804: PPUSH
45805: CALL_OW 273
45809: PUSH
45810: EMPTY
45811: LIST
45812: LIST
45813: PUSH
45814: LD_VAR 0 7
45818: PPUSH
45819: LD_INT 1
45821: PPUSH
45822: LD_INT 4
45824: PPUSH
45825: CALL_OW 272
45829: PUSH
45830: LD_VAR 0 8
45834: PPUSH
45835: LD_INT 1
45837: PPUSH
45838: LD_INT 4
45840: PPUSH
45841: CALL_OW 273
45845: PUSH
45846: EMPTY
45847: LIST
45848: LIST
45849: PUSH
45850: LD_VAR 0 7
45854: PPUSH
45855: LD_INT 2
45857: PPUSH
45858: LD_INT 4
45860: PPUSH
45861: CALL_OW 272
45865: PUSH
45866: LD_VAR 0 8
45870: PPUSH
45871: LD_INT 2
45873: PPUSH
45874: LD_INT 4
45876: PPUSH
45877: CALL_OW 273
45881: PUSH
45882: EMPTY
45883: LIST
45884: LIST
45885: PUSH
45886: LD_VAR 0 7
45890: PPUSH
45891: LD_INT 3
45893: PPUSH
45894: LD_INT 4
45896: PPUSH
45897: CALL_OW 272
45901: PUSH
45902: LD_VAR 0 8
45906: PPUSH
45907: LD_INT 3
45909: PPUSH
45910: LD_INT 4
45912: PPUSH
45913: CALL_OW 273
45917: PUSH
45918: EMPTY
45919: LIST
45920: LIST
45921: PUSH
45922: LD_VAR 0 7
45926: PPUSH
45927: LD_INT 4
45929: PPUSH
45930: LD_INT 4
45932: PPUSH
45933: CALL_OW 272
45937: PUSH
45938: LD_VAR 0 8
45942: PPUSH
45943: LD_INT 4
45945: PPUSH
45946: LD_INT 4
45948: PPUSH
45949: CALL_OW 273
45953: PUSH
45954: EMPTY
45955: LIST
45956: LIST
45957: PUSH
45958: LD_VAR 0 7
45962: PPUSH
45963: LD_INT 5
45965: PPUSH
45966: LD_INT 4
45968: PPUSH
45969: CALL_OW 272
45973: PUSH
45974: LD_VAR 0 8
45978: PPUSH
45979: LD_INT 5
45981: PPUSH
45982: LD_INT 4
45984: PPUSH
45985: CALL_OW 273
45989: PUSH
45990: EMPTY
45991: LIST
45992: LIST
45993: PUSH
45994: EMPTY
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: ST_TO_ADDR
// for i = tmp downto 1 do
46002: LD_ADDR_VAR 0 4
46006: PUSH
46007: DOUBLE
46008: LD_VAR 0 6
46012: INC
46013: ST_TO_ADDR
46014: LD_INT 1
46016: PUSH
46017: FOR_DOWNTO
46018: IFFALSE 46119
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46020: LD_VAR 0 6
46024: PUSH
46025: LD_VAR 0 4
46029: ARRAY
46030: PUSH
46031: LD_INT 1
46033: ARRAY
46034: PPUSH
46035: LD_VAR 0 6
46039: PUSH
46040: LD_VAR 0 4
46044: ARRAY
46045: PUSH
46046: LD_INT 2
46048: ARRAY
46049: PPUSH
46050: CALL_OW 488
46054: NOT
46055: PUSH
46056: LD_VAR 0 6
46060: PUSH
46061: LD_VAR 0 4
46065: ARRAY
46066: PUSH
46067: LD_INT 1
46069: ARRAY
46070: PPUSH
46071: LD_VAR 0 6
46075: PUSH
46076: LD_VAR 0 4
46080: ARRAY
46081: PUSH
46082: LD_INT 2
46084: ARRAY
46085: PPUSH
46086: CALL_OW 428
46090: PUSH
46091: LD_INT 0
46093: NONEQUAL
46094: OR
46095: IFFALSE 46117
// tmp := Delete ( tmp , i ) ;
46097: LD_ADDR_VAR 0 6
46101: PUSH
46102: LD_VAR 0 6
46106: PPUSH
46107: LD_VAR 0 4
46111: PPUSH
46112: CALL_OW 3
46116: ST_TO_ADDR
46117: GO 46017
46119: POP
46120: POP
// j := GetClosestHex ( unit , tmp ) ;
46121: LD_ADDR_VAR 0 5
46125: PUSH
46126: LD_VAR 0 1
46130: PPUSH
46131: LD_VAR 0 6
46135: PPUSH
46136: CALL 45421 0 2
46140: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46141: LD_VAR 0 1
46145: PPUSH
46146: LD_VAR 0 5
46150: PUSH
46151: LD_INT 1
46153: ARRAY
46154: PPUSH
46155: LD_VAR 0 5
46159: PUSH
46160: LD_INT 2
46162: ARRAY
46163: PPUSH
46164: CALL_OW 111
// end ;
46168: LD_VAR 0 3
46172: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46173: LD_INT 0
46175: PPUSH
46176: PPUSH
46177: PPUSH
// uc_side = 0 ;
46178: LD_ADDR_OWVAR 20
46182: PUSH
46183: LD_INT 0
46185: ST_TO_ADDR
// uc_nation = 0 ;
46186: LD_ADDR_OWVAR 21
46190: PUSH
46191: LD_INT 0
46193: ST_TO_ADDR
// InitHc ;
46194: CALL_OW 19
// InitVc ;
46198: CALL_OW 20
// if mastodonts then
46202: LD_VAR 0 6
46206: IFFALSE 46273
// for i = 1 to mastodonts do
46208: LD_ADDR_VAR 0 11
46212: PUSH
46213: DOUBLE
46214: LD_INT 1
46216: DEC
46217: ST_TO_ADDR
46218: LD_VAR 0 6
46222: PUSH
46223: FOR_TO
46224: IFFALSE 46271
// begin vc_chassis := 31 ;
46226: LD_ADDR_OWVAR 37
46230: PUSH
46231: LD_INT 31
46233: ST_TO_ADDR
// vc_control := control_rider ;
46234: LD_ADDR_OWVAR 38
46238: PUSH
46239: LD_INT 4
46241: ST_TO_ADDR
// animal := CreateVehicle ;
46242: LD_ADDR_VAR 0 12
46246: PUSH
46247: CALL_OW 45
46251: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46252: LD_VAR 0 12
46256: PPUSH
46257: LD_VAR 0 8
46261: PPUSH
46262: LD_INT 0
46264: PPUSH
46265: CALL 48342 0 3
// end ;
46269: GO 46223
46271: POP
46272: POP
// if horses then
46273: LD_VAR 0 5
46277: IFFALSE 46344
// for i = 1 to horses do
46279: LD_ADDR_VAR 0 11
46283: PUSH
46284: DOUBLE
46285: LD_INT 1
46287: DEC
46288: ST_TO_ADDR
46289: LD_VAR 0 5
46293: PUSH
46294: FOR_TO
46295: IFFALSE 46342
// begin hc_class := 21 ;
46297: LD_ADDR_OWVAR 28
46301: PUSH
46302: LD_INT 21
46304: ST_TO_ADDR
// hc_gallery :=  ;
46305: LD_ADDR_OWVAR 33
46309: PUSH
46310: LD_STRING 
46312: ST_TO_ADDR
// animal := CreateHuman ;
46313: LD_ADDR_VAR 0 12
46317: PUSH
46318: CALL_OW 44
46322: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46323: LD_VAR 0 12
46327: PPUSH
46328: LD_VAR 0 8
46332: PPUSH
46333: LD_INT 0
46335: PPUSH
46336: CALL 48342 0 3
// end ;
46340: GO 46294
46342: POP
46343: POP
// if birds then
46344: LD_VAR 0 1
46348: IFFALSE 46415
// for i = 1 to birds do
46350: LD_ADDR_VAR 0 11
46354: PUSH
46355: DOUBLE
46356: LD_INT 1
46358: DEC
46359: ST_TO_ADDR
46360: LD_VAR 0 1
46364: PUSH
46365: FOR_TO
46366: IFFALSE 46413
// begin hc_class = 18 ;
46368: LD_ADDR_OWVAR 28
46372: PUSH
46373: LD_INT 18
46375: ST_TO_ADDR
// hc_gallery =  ;
46376: LD_ADDR_OWVAR 33
46380: PUSH
46381: LD_STRING 
46383: ST_TO_ADDR
// animal := CreateHuman ;
46384: LD_ADDR_VAR 0 12
46388: PUSH
46389: CALL_OW 44
46393: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46394: LD_VAR 0 12
46398: PPUSH
46399: LD_VAR 0 8
46403: PPUSH
46404: LD_INT 0
46406: PPUSH
46407: CALL 48342 0 3
// end ;
46411: GO 46365
46413: POP
46414: POP
// if tigers then
46415: LD_VAR 0 2
46419: IFFALSE 46503
// for i = 1 to tigers do
46421: LD_ADDR_VAR 0 11
46425: PUSH
46426: DOUBLE
46427: LD_INT 1
46429: DEC
46430: ST_TO_ADDR
46431: LD_VAR 0 2
46435: PUSH
46436: FOR_TO
46437: IFFALSE 46501
// begin hc_class = class_tiger ;
46439: LD_ADDR_OWVAR 28
46443: PUSH
46444: LD_INT 14
46446: ST_TO_ADDR
// hc_gallery =  ;
46447: LD_ADDR_OWVAR 33
46451: PUSH
46452: LD_STRING 
46454: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
46455: LD_ADDR_OWVAR 35
46459: PUSH
46460: LD_INT 7
46462: NEG
46463: PPUSH
46464: LD_INT 7
46466: PPUSH
46467: CALL_OW 12
46471: ST_TO_ADDR
// animal := CreateHuman ;
46472: LD_ADDR_VAR 0 12
46476: PUSH
46477: CALL_OW 44
46481: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46482: LD_VAR 0 12
46486: PPUSH
46487: LD_VAR 0 8
46491: PPUSH
46492: LD_INT 0
46494: PPUSH
46495: CALL 48342 0 3
// end ;
46499: GO 46436
46501: POP
46502: POP
// if apemans then
46503: LD_VAR 0 3
46507: IFFALSE 46630
// for i = 1 to apemans do
46509: LD_ADDR_VAR 0 11
46513: PUSH
46514: DOUBLE
46515: LD_INT 1
46517: DEC
46518: ST_TO_ADDR
46519: LD_VAR 0 3
46523: PUSH
46524: FOR_TO
46525: IFFALSE 46628
// begin hc_class = class_apeman ;
46527: LD_ADDR_OWVAR 28
46531: PUSH
46532: LD_INT 12
46534: ST_TO_ADDR
// hc_gallery =  ;
46535: LD_ADDR_OWVAR 33
46539: PUSH
46540: LD_STRING 
46542: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
46543: LD_ADDR_OWVAR 35
46547: PUSH
46548: LD_INT 5
46550: NEG
46551: PPUSH
46552: LD_INT 5
46554: PPUSH
46555: CALL_OW 12
46559: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
46560: LD_ADDR_OWVAR 31
46564: PUSH
46565: LD_INT 1
46567: PPUSH
46568: LD_INT 3
46570: PPUSH
46571: CALL_OW 12
46575: PUSH
46576: LD_INT 1
46578: PPUSH
46579: LD_INT 3
46581: PPUSH
46582: CALL_OW 12
46586: PUSH
46587: LD_INT 0
46589: PUSH
46590: LD_INT 0
46592: PUSH
46593: EMPTY
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: ST_TO_ADDR
// animal := CreateHuman ;
46599: LD_ADDR_VAR 0 12
46603: PUSH
46604: CALL_OW 44
46608: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46609: LD_VAR 0 12
46613: PPUSH
46614: LD_VAR 0 8
46618: PPUSH
46619: LD_INT 0
46621: PPUSH
46622: CALL 48342 0 3
// end ;
46626: GO 46524
46628: POP
46629: POP
// if enchidnas then
46630: LD_VAR 0 4
46634: IFFALSE 46701
// for i = 1 to enchidnas do
46636: LD_ADDR_VAR 0 11
46640: PUSH
46641: DOUBLE
46642: LD_INT 1
46644: DEC
46645: ST_TO_ADDR
46646: LD_VAR 0 4
46650: PUSH
46651: FOR_TO
46652: IFFALSE 46699
// begin hc_class = 13 ;
46654: LD_ADDR_OWVAR 28
46658: PUSH
46659: LD_INT 13
46661: ST_TO_ADDR
// hc_gallery =  ;
46662: LD_ADDR_OWVAR 33
46666: PUSH
46667: LD_STRING 
46669: ST_TO_ADDR
// animal := CreateHuman ;
46670: LD_ADDR_VAR 0 12
46674: PUSH
46675: CALL_OW 44
46679: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46680: LD_VAR 0 12
46684: PPUSH
46685: LD_VAR 0 8
46689: PPUSH
46690: LD_INT 0
46692: PPUSH
46693: CALL 48342 0 3
// end ;
46697: GO 46651
46699: POP
46700: POP
// if fishes then
46701: LD_VAR 0 7
46705: IFFALSE 46772
// for i = 1 to fishes do
46707: LD_ADDR_VAR 0 11
46711: PUSH
46712: DOUBLE
46713: LD_INT 1
46715: DEC
46716: ST_TO_ADDR
46717: LD_VAR 0 7
46721: PUSH
46722: FOR_TO
46723: IFFALSE 46770
// begin hc_class = 20 ;
46725: LD_ADDR_OWVAR 28
46729: PUSH
46730: LD_INT 20
46732: ST_TO_ADDR
// hc_gallery =  ;
46733: LD_ADDR_OWVAR 33
46737: PUSH
46738: LD_STRING 
46740: ST_TO_ADDR
// animal := CreateHuman ;
46741: LD_ADDR_VAR 0 12
46745: PUSH
46746: CALL_OW 44
46750: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
46751: LD_VAR 0 12
46755: PPUSH
46756: LD_VAR 0 9
46760: PPUSH
46761: LD_INT 0
46763: PPUSH
46764: CALL 48342 0 3
// end ;
46768: GO 46722
46770: POP
46771: POP
// end ;
46772: LD_VAR 0 10
46776: RET
// export function WantHeal ( sci , unit ) ; begin
46777: LD_INT 0
46779: PPUSH
// if GetTaskList ( sci ) > 0 then
46780: LD_VAR 0 1
46784: PPUSH
46785: CALL_OW 437
46789: PUSH
46790: LD_INT 0
46792: GREATER
46793: IFFALSE 46863
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
46795: LD_VAR 0 1
46799: PPUSH
46800: CALL_OW 437
46804: PUSH
46805: LD_INT 1
46807: ARRAY
46808: PUSH
46809: LD_INT 1
46811: ARRAY
46812: PUSH
46813: LD_STRING l
46815: EQUAL
46816: PUSH
46817: LD_VAR 0 1
46821: PPUSH
46822: CALL_OW 437
46826: PUSH
46827: LD_INT 1
46829: ARRAY
46830: PUSH
46831: LD_INT 4
46833: ARRAY
46834: PUSH
46835: LD_VAR 0 2
46839: EQUAL
46840: AND
46841: IFFALSE 46853
// result := true else
46843: LD_ADDR_VAR 0 3
46847: PUSH
46848: LD_INT 1
46850: ST_TO_ADDR
46851: GO 46861
// result := false ;
46853: LD_ADDR_VAR 0 3
46857: PUSH
46858: LD_INT 0
46860: ST_TO_ADDR
// end else
46861: GO 46871
// result := false ;
46863: LD_ADDR_VAR 0 3
46867: PUSH
46868: LD_INT 0
46870: ST_TO_ADDR
// end ;
46871: LD_VAR 0 3
46875: RET
// export function HealTarget ( sci ) ; begin
46876: LD_INT 0
46878: PPUSH
// if not sci then
46879: LD_VAR 0 1
46883: NOT
46884: IFFALSE 46888
// exit ;
46886: GO 46953
// result := 0 ;
46888: LD_ADDR_VAR 0 2
46892: PUSH
46893: LD_INT 0
46895: ST_TO_ADDR
// if GetTaskList ( sci ) then
46896: LD_VAR 0 1
46900: PPUSH
46901: CALL_OW 437
46905: IFFALSE 46953
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
46907: LD_VAR 0 1
46911: PPUSH
46912: CALL_OW 437
46916: PUSH
46917: LD_INT 1
46919: ARRAY
46920: PUSH
46921: LD_INT 1
46923: ARRAY
46924: PUSH
46925: LD_STRING l
46927: EQUAL
46928: IFFALSE 46953
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
46930: LD_ADDR_VAR 0 2
46934: PUSH
46935: LD_VAR 0 1
46939: PPUSH
46940: CALL_OW 437
46944: PUSH
46945: LD_INT 1
46947: ARRAY
46948: PUSH
46949: LD_INT 4
46951: ARRAY
46952: ST_TO_ADDR
// end ;
46953: LD_VAR 0 2
46957: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
46958: LD_INT 0
46960: PPUSH
46961: PPUSH
46962: PPUSH
46963: PPUSH
// if not base_units then
46964: LD_VAR 0 1
46968: NOT
46969: IFFALSE 46973
// exit ;
46971: GO 47060
// result := false ;
46973: LD_ADDR_VAR 0 2
46977: PUSH
46978: LD_INT 0
46980: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
46981: LD_ADDR_VAR 0 5
46985: PUSH
46986: LD_VAR 0 1
46990: PPUSH
46991: LD_INT 21
46993: PUSH
46994: LD_INT 3
46996: PUSH
46997: EMPTY
46998: LIST
46999: LIST
47000: PPUSH
47001: CALL_OW 72
47005: ST_TO_ADDR
// if not tmp then
47006: LD_VAR 0 5
47010: NOT
47011: IFFALSE 47015
// exit ;
47013: GO 47060
// for i in tmp do
47015: LD_ADDR_VAR 0 3
47019: PUSH
47020: LD_VAR 0 5
47024: PUSH
47025: FOR_IN
47026: IFFALSE 47058
// begin result := EnemyInRange ( i , 22 ) ;
47028: LD_ADDR_VAR 0 2
47032: PUSH
47033: LD_VAR 0 3
47037: PPUSH
47038: LD_INT 22
47040: PPUSH
47041: CALL 45296 0 2
47045: ST_TO_ADDR
// if result then
47046: LD_VAR 0 2
47050: IFFALSE 47056
// exit ;
47052: POP
47053: POP
47054: GO 47060
// end ;
47056: GO 47025
47058: POP
47059: POP
// end ;
47060: LD_VAR 0 2
47064: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
47065: LD_INT 0
47067: PPUSH
47068: PPUSH
// if not units then
47069: LD_VAR 0 1
47073: NOT
47074: IFFALSE 47078
// exit ;
47076: GO 47148
// result := [ ] ;
47078: LD_ADDR_VAR 0 3
47082: PUSH
47083: EMPTY
47084: ST_TO_ADDR
// for i in units do
47085: LD_ADDR_VAR 0 4
47089: PUSH
47090: LD_VAR 0 1
47094: PUSH
47095: FOR_IN
47096: IFFALSE 47146
// if GetTag ( i ) = tag then
47098: LD_VAR 0 4
47102: PPUSH
47103: CALL_OW 110
47107: PUSH
47108: LD_VAR 0 2
47112: EQUAL
47113: IFFALSE 47144
// result := Insert ( result , result + 1 , i ) ;
47115: LD_ADDR_VAR 0 3
47119: PUSH
47120: LD_VAR 0 3
47124: PPUSH
47125: LD_VAR 0 3
47129: PUSH
47130: LD_INT 1
47132: PLUS
47133: PPUSH
47134: LD_VAR 0 4
47138: PPUSH
47139: CALL_OW 2
47143: ST_TO_ADDR
47144: GO 47095
47146: POP
47147: POP
// end ;
47148: LD_VAR 0 3
47152: RET
// export function IsDriver ( un ) ; begin
47153: LD_INT 0
47155: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47156: LD_ADDR_VAR 0 2
47160: PUSH
47161: LD_VAR 0 1
47165: PUSH
47166: LD_INT 55
47168: PUSH
47169: EMPTY
47170: LIST
47171: PPUSH
47172: CALL_OW 69
47176: IN
47177: ST_TO_ADDR
// end ;
47178: LD_VAR 0 2
47182: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47183: LD_INT 0
47185: PPUSH
47186: PPUSH
// list := [ ] ;
47187: LD_ADDR_VAR 0 5
47191: PUSH
47192: EMPTY
47193: ST_TO_ADDR
// case d of 0 :
47194: LD_VAR 0 3
47198: PUSH
47199: LD_INT 0
47201: DOUBLE
47202: EQUAL
47203: IFTRUE 47207
47205: GO 47340
47207: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
47208: LD_ADDR_VAR 0 5
47212: PUSH
47213: LD_VAR 0 1
47217: PUSH
47218: LD_INT 4
47220: MINUS
47221: PUSH
47222: LD_VAR 0 2
47226: PUSH
47227: LD_INT 4
47229: MINUS
47230: PUSH
47231: LD_INT 2
47233: PUSH
47234: EMPTY
47235: LIST
47236: LIST
47237: LIST
47238: PUSH
47239: LD_VAR 0 1
47243: PUSH
47244: LD_INT 3
47246: MINUS
47247: PUSH
47248: LD_VAR 0 2
47252: PUSH
47253: LD_INT 1
47255: PUSH
47256: EMPTY
47257: LIST
47258: LIST
47259: LIST
47260: PUSH
47261: LD_VAR 0 1
47265: PUSH
47266: LD_INT 4
47268: PLUS
47269: PUSH
47270: LD_VAR 0 2
47274: PUSH
47275: LD_INT 4
47277: PUSH
47278: EMPTY
47279: LIST
47280: LIST
47281: LIST
47282: PUSH
47283: LD_VAR 0 1
47287: PUSH
47288: LD_INT 3
47290: PLUS
47291: PUSH
47292: LD_VAR 0 2
47296: PUSH
47297: LD_INT 3
47299: PLUS
47300: PUSH
47301: LD_INT 5
47303: PUSH
47304: EMPTY
47305: LIST
47306: LIST
47307: LIST
47308: PUSH
47309: LD_VAR 0 1
47313: PUSH
47314: LD_VAR 0 2
47318: PUSH
47319: LD_INT 4
47321: PLUS
47322: PUSH
47323: LD_INT 0
47325: PUSH
47326: EMPTY
47327: LIST
47328: LIST
47329: LIST
47330: PUSH
47331: EMPTY
47332: LIST
47333: LIST
47334: LIST
47335: LIST
47336: LIST
47337: ST_TO_ADDR
// end ; 1 :
47338: GO 48038
47340: LD_INT 1
47342: DOUBLE
47343: EQUAL
47344: IFTRUE 47348
47346: GO 47481
47348: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
47349: LD_ADDR_VAR 0 5
47353: PUSH
47354: LD_VAR 0 1
47358: PUSH
47359: LD_VAR 0 2
47363: PUSH
47364: LD_INT 4
47366: MINUS
47367: PUSH
47368: LD_INT 3
47370: PUSH
47371: EMPTY
47372: LIST
47373: LIST
47374: LIST
47375: PUSH
47376: LD_VAR 0 1
47380: PUSH
47381: LD_INT 3
47383: MINUS
47384: PUSH
47385: LD_VAR 0 2
47389: PUSH
47390: LD_INT 3
47392: MINUS
47393: PUSH
47394: LD_INT 2
47396: PUSH
47397: EMPTY
47398: LIST
47399: LIST
47400: LIST
47401: PUSH
47402: LD_VAR 0 1
47406: PUSH
47407: LD_INT 4
47409: MINUS
47410: PUSH
47411: LD_VAR 0 2
47415: PUSH
47416: LD_INT 1
47418: PUSH
47419: EMPTY
47420: LIST
47421: LIST
47422: LIST
47423: PUSH
47424: LD_VAR 0 1
47428: PUSH
47429: LD_VAR 0 2
47433: PUSH
47434: LD_INT 3
47436: PLUS
47437: PUSH
47438: LD_INT 0
47440: PUSH
47441: EMPTY
47442: LIST
47443: LIST
47444: LIST
47445: PUSH
47446: LD_VAR 0 1
47450: PUSH
47451: LD_INT 4
47453: PLUS
47454: PUSH
47455: LD_VAR 0 2
47459: PUSH
47460: LD_INT 4
47462: PLUS
47463: PUSH
47464: LD_INT 5
47466: PUSH
47467: EMPTY
47468: LIST
47469: LIST
47470: LIST
47471: PUSH
47472: EMPTY
47473: LIST
47474: LIST
47475: LIST
47476: LIST
47477: LIST
47478: ST_TO_ADDR
// end ; 2 :
47479: GO 48038
47481: LD_INT 2
47483: DOUBLE
47484: EQUAL
47485: IFTRUE 47489
47487: GO 47618
47489: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
47490: LD_ADDR_VAR 0 5
47494: PUSH
47495: LD_VAR 0 1
47499: PUSH
47500: LD_VAR 0 2
47504: PUSH
47505: LD_INT 3
47507: MINUS
47508: PUSH
47509: LD_INT 3
47511: PUSH
47512: EMPTY
47513: LIST
47514: LIST
47515: LIST
47516: PUSH
47517: LD_VAR 0 1
47521: PUSH
47522: LD_INT 4
47524: PLUS
47525: PUSH
47526: LD_VAR 0 2
47530: PUSH
47531: LD_INT 4
47533: PUSH
47534: EMPTY
47535: LIST
47536: LIST
47537: LIST
47538: PUSH
47539: LD_VAR 0 1
47543: PUSH
47544: LD_VAR 0 2
47548: PUSH
47549: LD_INT 4
47551: PLUS
47552: PUSH
47553: LD_INT 0
47555: PUSH
47556: EMPTY
47557: LIST
47558: LIST
47559: LIST
47560: PUSH
47561: LD_VAR 0 1
47565: PUSH
47566: LD_INT 3
47568: MINUS
47569: PUSH
47570: LD_VAR 0 2
47574: PUSH
47575: LD_INT 1
47577: PUSH
47578: EMPTY
47579: LIST
47580: LIST
47581: LIST
47582: PUSH
47583: LD_VAR 0 1
47587: PUSH
47588: LD_INT 4
47590: MINUS
47591: PUSH
47592: LD_VAR 0 2
47596: PUSH
47597: LD_INT 4
47599: MINUS
47600: PUSH
47601: LD_INT 2
47603: PUSH
47604: EMPTY
47605: LIST
47606: LIST
47607: LIST
47608: PUSH
47609: EMPTY
47610: LIST
47611: LIST
47612: LIST
47613: LIST
47614: LIST
47615: ST_TO_ADDR
// end ; 3 :
47616: GO 48038
47618: LD_INT 3
47620: DOUBLE
47621: EQUAL
47622: IFTRUE 47626
47624: GO 47759
47626: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
47627: LD_ADDR_VAR 0 5
47631: PUSH
47632: LD_VAR 0 1
47636: PUSH
47637: LD_INT 3
47639: PLUS
47640: PUSH
47641: LD_VAR 0 2
47645: PUSH
47646: LD_INT 4
47648: PUSH
47649: EMPTY
47650: LIST
47651: LIST
47652: LIST
47653: PUSH
47654: LD_VAR 0 1
47658: PUSH
47659: LD_INT 4
47661: PLUS
47662: PUSH
47663: LD_VAR 0 2
47667: PUSH
47668: LD_INT 4
47670: PLUS
47671: PUSH
47672: LD_INT 5
47674: PUSH
47675: EMPTY
47676: LIST
47677: LIST
47678: LIST
47679: PUSH
47680: LD_VAR 0 1
47684: PUSH
47685: LD_INT 4
47687: MINUS
47688: PUSH
47689: LD_VAR 0 2
47693: PUSH
47694: LD_INT 1
47696: PUSH
47697: EMPTY
47698: LIST
47699: LIST
47700: LIST
47701: PUSH
47702: LD_VAR 0 1
47706: PUSH
47707: LD_VAR 0 2
47711: PUSH
47712: LD_INT 4
47714: MINUS
47715: PUSH
47716: LD_INT 3
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: LIST
47723: PUSH
47724: LD_VAR 0 1
47728: PUSH
47729: LD_INT 3
47731: MINUS
47732: PUSH
47733: LD_VAR 0 2
47737: PUSH
47738: LD_INT 3
47740: MINUS
47741: PUSH
47742: LD_INT 2
47744: PUSH
47745: EMPTY
47746: LIST
47747: LIST
47748: LIST
47749: PUSH
47750: EMPTY
47751: LIST
47752: LIST
47753: LIST
47754: LIST
47755: LIST
47756: ST_TO_ADDR
// end ; 4 :
47757: GO 48038
47759: LD_INT 4
47761: DOUBLE
47762: EQUAL
47763: IFTRUE 47767
47765: GO 47900
47767: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
47768: LD_ADDR_VAR 0 5
47772: PUSH
47773: LD_VAR 0 1
47777: PUSH
47778: LD_VAR 0 2
47782: PUSH
47783: LD_INT 4
47785: PLUS
47786: PUSH
47787: LD_INT 0
47789: PUSH
47790: EMPTY
47791: LIST
47792: LIST
47793: LIST
47794: PUSH
47795: LD_VAR 0 1
47799: PUSH
47800: LD_INT 3
47802: PLUS
47803: PUSH
47804: LD_VAR 0 2
47808: PUSH
47809: LD_INT 3
47811: PLUS
47812: PUSH
47813: LD_INT 5
47815: PUSH
47816: EMPTY
47817: LIST
47818: LIST
47819: LIST
47820: PUSH
47821: LD_VAR 0 1
47825: PUSH
47826: LD_INT 4
47828: PLUS
47829: PUSH
47830: LD_VAR 0 2
47834: PUSH
47835: LD_INT 4
47837: PUSH
47838: EMPTY
47839: LIST
47840: LIST
47841: LIST
47842: PUSH
47843: LD_VAR 0 1
47847: PUSH
47848: LD_VAR 0 2
47852: PUSH
47853: LD_INT 3
47855: MINUS
47856: PUSH
47857: LD_INT 3
47859: PUSH
47860: EMPTY
47861: LIST
47862: LIST
47863: LIST
47864: PUSH
47865: LD_VAR 0 1
47869: PUSH
47870: LD_INT 4
47872: MINUS
47873: PUSH
47874: LD_VAR 0 2
47878: PUSH
47879: LD_INT 4
47881: MINUS
47882: PUSH
47883: LD_INT 2
47885: PUSH
47886: EMPTY
47887: LIST
47888: LIST
47889: LIST
47890: PUSH
47891: EMPTY
47892: LIST
47893: LIST
47894: LIST
47895: LIST
47896: LIST
47897: ST_TO_ADDR
// end ; 5 :
47898: GO 48038
47900: LD_INT 5
47902: DOUBLE
47903: EQUAL
47904: IFTRUE 47908
47906: GO 48037
47908: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
47909: LD_ADDR_VAR 0 5
47913: PUSH
47914: LD_VAR 0 1
47918: PUSH
47919: LD_INT 4
47921: MINUS
47922: PUSH
47923: LD_VAR 0 2
47927: PUSH
47928: LD_INT 1
47930: PUSH
47931: EMPTY
47932: LIST
47933: LIST
47934: LIST
47935: PUSH
47936: LD_VAR 0 1
47940: PUSH
47941: LD_VAR 0 2
47945: PUSH
47946: LD_INT 4
47948: MINUS
47949: PUSH
47950: LD_INT 3
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: LIST
47957: PUSH
47958: LD_VAR 0 1
47962: PUSH
47963: LD_INT 4
47965: PLUS
47966: PUSH
47967: LD_VAR 0 2
47971: PUSH
47972: LD_INT 4
47974: PLUS
47975: PUSH
47976: LD_INT 5
47978: PUSH
47979: EMPTY
47980: LIST
47981: LIST
47982: LIST
47983: PUSH
47984: LD_VAR 0 1
47988: PUSH
47989: LD_INT 3
47991: PLUS
47992: PUSH
47993: LD_VAR 0 2
47997: PUSH
47998: LD_INT 4
48000: PUSH
48001: EMPTY
48002: LIST
48003: LIST
48004: LIST
48005: PUSH
48006: LD_VAR 0 1
48010: PUSH
48011: LD_VAR 0 2
48015: PUSH
48016: LD_INT 3
48018: PLUS
48019: PUSH
48020: LD_INT 0
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: LIST
48027: PUSH
48028: EMPTY
48029: LIST
48030: LIST
48031: LIST
48032: LIST
48033: LIST
48034: ST_TO_ADDR
// end ; end ;
48035: GO 48038
48037: POP
// result := list ;
48038: LD_ADDR_VAR 0 4
48042: PUSH
48043: LD_VAR 0 5
48047: ST_TO_ADDR
// end ;
48048: LD_VAR 0 4
48052: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48053: LD_INT 0
48055: PPUSH
48056: PPUSH
48057: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48058: LD_VAR 0 1
48062: NOT
48063: PUSH
48064: LD_VAR 0 2
48068: PUSH
48069: LD_INT 1
48071: PUSH
48072: LD_INT 2
48074: PUSH
48075: LD_INT 3
48077: PUSH
48078: LD_INT 4
48080: PUSH
48081: EMPTY
48082: LIST
48083: LIST
48084: LIST
48085: LIST
48086: IN
48087: NOT
48088: OR
48089: IFFALSE 48093
// exit ;
48091: GO 48185
// tmp := [ ] ;
48093: LD_ADDR_VAR 0 5
48097: PUSH
48098: EMPTY
48099: ST_TO_ADDR
// for i in units do
48100: LD_ADDR_VAR 0 4
48104: PUSH
48105: LD_VAR 0 1
48109: PUSH
48110: FOR_IN
48111: IFFALSE 48154
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48113: LD_ADDR_VAR 0 5
48117: PUSH
48118: LD_VAR 0 5
48122: PPUSH
48123: LD_VAR 0 5
48127: PUSH
48128: LD_INT 1
48130: PLUS
48131: PPUSH
48132: LD_VAR 0 4
48136: PPUSH
48137: LD_VAR 0 2
48141: PPUSH
48142: CALL_OW 259
48146: PPUSH
48147: CALL_OW 2
48151: ST_TO_ADDR
48152: GO 48110
48154: POP
48155: POP
// if not tmp then
48156: LD_VAR 0 5
48160: NOT
48161: IFFALSE 48165
// exit ;
48163: GO 48185
// result := SortListByListDesc ( units , tmp ) ;
48165: LD_ADDR_VAR 0 3
48169: PUSH
48170: LD_VAR 0 1
48174: PPUSH
48175: LD_VAR 0 5
48179: PPUSH
48180: CALL_OW 77
48184: ST_TO_ADDR
// end ;
48185: LD_VAR 0 3
48189: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48190: LD_INT 0
48192: PPUSH
48193: PPUSH
48194: PPUSH
// x := GetX ( building ) ;
48195: LD_ADDR_VAR 0 4
48199: PUSH
48200: LD_VAR 0 2
48204: PPUSH
48205: CALL_OW 250
48209: ST_TO_ADDR
// y := GetY ( building ) ;
48210: LD_ADDR_VAR 0 5
48214: PUSH
48215: LD_VAR 0 2
48219: PPUSH
48220: CALL_OW 251
48224: ST_TO_ADDR
// if GetTaskList ( unit ) then
48225: LD_VAR 0 1
48229: PPUSH
48230: CALL_OW 437
48234: IFFALSE 48329
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48236: LD_STRING e
48238: PUSH
48239: LD_VAR 0 1
48243: PPUSH
48244: CALL_OW 437
48248: PUSH
48249: LD_INT 1
48251: ARRAY
48252: PUSH
48253: LD_INT 1
48255: ARRAY
48256: EQUAL
48257: PUSH
48258: LD_VAR 0 4
48262: PUSH
48263: LD_VAR 0 1
48267: PPUSH
48268: CALL_OW 437
48272: PUSH
48273: LD_INT 1
48275: ARRAY
48276: PUSH
48277: LD_INT 2
48279: ARRAY
48280: EQUAL
48281: AND
48282: PUSH
48283: LD_VAR 0 5
48287: PUSH
48288: LD_VAR 0 1
48292: PPUSH
48293: CALL_OW 437
48297: PUSH
48298: LD_INT 1
48300: ARRAY
48301: PUSH
48302: LD_INT 3
48304: ARRAY
48305: EQUAL
48306: AND
48307: IFFALSE 48319
// result := true else
48309: LD_ADDR_VAR 0 3
48313: PUSH
48314: LD_INT 1
48316: ST_TO_ADDR
48317: GO 48327
// result := false ;
48319: LD_ADDR_VAR 0 3
48323: PUSH
48324: LD_INT 0
48326: ST_TO_ADDR
// end else
48327: GO 48337
// result := false ;
48329: LD_ADDR_VAR 0 3
48333: PUSH
48334: LD_INT 0
48336: ST_TO_ADDR
// end ;
48337: LD_VAR 0 3
48341: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
48342: LD_INT 0
48344: PPUSH
48345: PPUSH
48346: PPUSH
48347: PPUSH
// if not unit or not area then
48348: LD_VAR 0 1
48352: NOT
48353: PUSH
48354: LD_VAR 0 2
48358: NOT
48359: OR
48360: IFFALSE 48364
// exit ;
48362: GO 48528
// tmp := AreaToList ( area , i ) ;
48364: LD_ADDR_VAR 0 6
48368: PUSH
48369: LD_VAR 0 2
48373: PPUSH
48374: LD_VAR 0 5
48378: PPUSH
48379: CALL_OW 517
48383: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
48384: LD_ADDR_VAR 0 5
48388: PUSH
48389: DOUBLE
48390: LD_INT 1
48392: DEC
48393: ST_TO_ADDR
48394: LD_VAR 0 6
48398: PUSH
48399: LD_INT 1
48401: ARRAY
48402: PUSH
48403: FOR_TO
48404: IFFALSE 48526
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
48406: LD_ADDR_VAR 0 7
48410: PUSH
48411: LD_VAR 0 6
48415: PUSH
48416: LD_INT 1
48418: ARRAY
48419: PUSH
48420: LD_VAR 0 5
48424: ARRAY
48425: PUSH
48426: LD_VAR 0 6
48430: PUSH
48431: LD_INT 2
48433: ARRAY
48434: PUSH
48435: LD_VAR 0 5
48439: ARRAY
48440: PUSH
48441: EMPTY
48442: LIST
48443: LIST
48444: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
48445: LD_VAR 0 7
48449: PUSH
48450: LD_INT 1
48452: ARRAY
48453: PPUSH
48454: LD_VAR 0 7
48458: PUSH
48459: LD_INT 2
48461: ARRAY
48462: PPUSH
48463: CALL_OW 428
48467: PUSH
48468: LD_INT 0
48470: EQUAL
48471: IFFALSE 48524
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
48473: LD_VAR 0 1
48477: PPUSH
48478: LD_VAR 0 7
48482: PUSH
48483: LD_INT 1
48485: ARRAY
48486: PPUSH
48487: LD_VAR 0 7
48491: PUSH
48492: LD_INT 2
48494: ARRAY
48495: PPUSH
48496: LD_VAR 0 3
48500: PPUSH
48501: CALL_OW 48
// result := IsPlaced ( unit ) ;
48505: LD_ADDR_VAR 0 4
48509: PUSH
48510: LD_VAR 0 1
48514: PPUSH
48515: CALL_OW 305
48519: ST_TO_ADDR
// exit ;
48520: POP
48521: POP
48522: GO 48528
// end ; end ;
48524: GO 48403
48526: POP
48527: POP
// end ;
48528: LD_VAR 0 4
48532: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
48533: LD_INT 0
48535: PPUSH
48536: PPUSH
48537: PPUSH
// if not side or side > 8 then
48538: LD_VAR 0 1
48542: NOT
48543: PUSH
48544: LD_VAR 0 1
48548: PUSH
48549: LD_INT 8
48551: GREATER
48552: OR
48553: IFFALSE 48557
// exit ;
48555: GO 48744
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
48557: LD_ADDR_VAR 0 4
48561: PUSH
48562: LD_INT 22
48564: PUSH
48565: LD_VAR 0 1
48569: PUSH
48570: EMPTY
48571: LIST
48572: LIST
48573: PUSH
48574: LD_INT 21
48576: PUSH
48577: LD_INT 3
48579: PUSH
48580: EMPTY
48581: LIST
48582: LIST
48583: PUSH
48584: EMPTY
48585: LIST
48586: LIST
48587: PPUSH
48588: CALL_OW 69
48592: ST_TO_ADDR
// if not tmp then
48593: LD_VAR 0 4
48597: NOT
48598: IFFALSE 48602
// exit ;
48600: GO 48744
// enable_addtolog := true ;
48602: LD_ADDR_OWVAR 81
48606: PUSH
48607: LD_INT 1
48609: ST_TO_ADDR
// AddToLog ( [ ) ;
48610: LD_STRING [
48612: PPUSH
48613: CALL_OW 561
// for i in tmp do
48617: LD_ADDR_VAR 0 3
48621: PUSH
48622: LD_VAR 0 4
48626: PUSH
48627: FOR_IN
48628: IFFALSE 48735
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
48630: LD_STRING [
48632: PUSH
48633: LD_VAR 0 3
48637: PPUSH
48638: CALL_OW 266
48642: STR
48643: PUSH
48644: LD_STRING , 
48646: STR
48647: PUSH
48648: LD_VAR 0 3
48652: PPUSH
48653: CALL_OW 250
48657: STR
48658: PUSH
48659: LD_STRING , 
48661: STR
48662: PUSH
48663: LD_VAR 0 3
48667: PPUSH
48668: CALL_OW 251
48672: STR
48673: PUSH
48674: LD_STRING , 
48676: STR
48677: PUSH
48678: LD_VAR 0 3
48682: PPUSH
48683: CALL_OW 254
48687: STR
48688: PUSH
48689: LD_STRING , 
48691: STR
48692: PUSH
48693: LD_VAR 0 3
48697: PPUSH
48698: LD_INT 1
48700: PPUSH
48701: CALL_OW 268
48705: STR
48706: PUSH
48707: LD_STRING , 
48709: STR
48710: PUSH
48711: LD_VAR 0 3
48715: PPUSH
48716: LD_INT 2
48718: PPUSH
48719: CALL_OW 268
48723: STR
48724: PUSH
48725: LD_STRING ],
48727: STR
48728: PPUSH
48729: CALL_OW 561
// end ;
48733: GO 48627
48735: POP
48736: POP
// AddToLog ( ]; ) ;
48737: LD_STRING ];
48739: PPUSH
48740: CALL_OW 561
// end ;
48744: LD_VAR 0 2
48748: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
48749: LD_INT 0
48751: PPUSH
48752: PPUSH
48753: PPUSH
48754: PPUSH
48755: PPUSH
// if not area or not rate or not max then
48756: LD_VAR 0 1
48760: NOT
48761: PUSH
48762: LD_VAR 0 2
48766: NOT
48767: OR
48768: PUSH
48769: LD_VAR 0 4
48773: NOT
48774: OR
48775: IFFALSE 48779
// exit ;
48777: GO 48971
// while 1 do
48779: LD_INT 1
48781: IFFALSE 48971
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
48783: LD_ADDR_VAR 0 9
48787: PUSH
48788: LD_VAR 0 1
48792: PPUSH
48793: LD_INT 1
48795: PPUSH
48796: CALL_OW 287
48800: PUSH
48801: LD_INT 10
48803: MUL
48804: ST_TO_ADDR
// r := rate / 10 ;
48805: LD_ADDR_VAR 0 7
48809: PUSH
48810: LD_VAR 0 2
48814: PUSH
48815: LD_INT 10
48817: DIVREAL
48818: ST_TO_ADDR
// time := 1 1$00 ;
48819: LD_ADDR_VAR 0 8
48823: PUSH
48824: LD_INT 2100
48826: ST_TO_ADDR
// if amount < min then
48827: LD_VAR 0 9
48831: PUSH
48832: LD_VAR 0 3
48836: LESS
48837: IFFALSE 48855
// r := r * 2 else
48839: LD_ADDR_VAR 0 7
48843: PUSH
48844: LD_VAR 0 7
48848: PUSH
48849: LD_INT 2
48851: MUL
48852: ST_TO_ADDR
48853: GO 48881
// if amount > max then
48855: LD_VAR 0 9
48859: PUSH
48860: LD_VAR 0 4
48864: GREATER
48865: IFFALSE 48881
// r := r / 2 ;
48867: LD_ADDR_VAR 0 7
48871: PUSH
48872: LD_VAR 0 7
48876: PUSH
48877: LD_INT 2
48879: DIVREAL
48880: ST_TO_ADDR
// time := time / r ;
48881: LD_ADDR_VAR 0 8
48885: PUSH
48886: LD_VAR 0 8
48890: PUSH
48891: LD_VAR 0 7
48895: DIVREAL
48896: ST_TO_ADDR
// if time < 0 then
48897: LD_VAR 0 8
48901: PUSH
48902: LD_INT 0
48904: LESS
48905: IFFALSE 48922
// time := time * - 1 ;
48907: LD_ADDR_VAR 0 8
48911: PUSH
48912: LD_VAR 0 8
48916: PUSH
48917: LD_INT 1
48919: NEG
48920: MUL
48921: ST_TO_ADDR
// wait ( time ) ;
48922: LD_VAR 0 8
48926: PPUSH
48927: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
48931: LD_INT 35
48933: PPUSH
48934: LD_INT 875
48936: PPUSH
48937: CALL_OW 12
48941: PPUSH
48942: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
48946: LD_INT 1
48948: PPUSH
48949: LD_INT 5
48951: PPUSH
48952: CALL_OW 12
48956: PPUSH
48957: LD_VAR 0 1
48961: PPUSH
48962: LD_INT 1
48964: PPUSH
48965: CALL_OW 55
// end ;
48969: GO 48779
// end ;
48971: LD_VAR 0 5
48975: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
48976: LD_INT 0
48978: PPUSH
48979: PPUSH
48980: PPUSH
48981: PPUSH
48982: PPUSH
48983: PPUSH
48984: PPUSH
48985: PPUSH
// if not turrets or not factories then
48986: LD_VAR 0 1
48990: NOT
48991: PUSH
48992: LD_VAR 0 2
48996: NOT
48997: OR
48998: IFFALSE 49002
// exit ;
49000: GO 49309
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49002: LD_ADDR_VAR 0 10
49006: PUSH
49007: LD_INT 5
49009: PUSH
49010: LD_INT 6
49012: PUSH
49013: EMPTY
49014: LIST
49015: LIST
49016: PUSH
49017: LD_INT 2
49019: PUSH
49020: LD_INT 4
49022: PUSH
49023: EMPTY
49024: LIST
49025: LIST
49026: PUSH
49027: LD_INT 3
49029: PUSH
49030: LD_INT 5
49032: PUSH
49033: EMPTY
49034: LIST
49035: LIST
49036: PUSH
49037: EMPTY
49038: LIST
49039: LIST
49040: LIST
49041: PUSH
49042: LD_INT 24
49044: PUSH
49045: LD_INT 25
49047: PUSH
49048: EMPTY
49049: LIST
49050: LIST
49051: PUSH
49052: LD_INT 23
49054: PUSH
49055: LD_INT 27
49057: PUSH
49058: EMPTY
49059: LIST
49060: LIST
49061: PUSH
49062: EMPTY
49063: LIST
49064: LIST
49065: PUSH
49066: LD_INT 42
49068: PUSH
49069: LD_INT 43
49071: PUSH
49072: EMPTY
49073: LIST
49074: LIST
49075: PUSH
49076: LD_INT 44
49078: PUSH
49079: LD_INT 46
49081: PUSH
49082: EMPTY
49083: LIST
49084: LIST
49085: PUSH
49086: LD_INT 45
49088: PUSH
49089: LD_INT 47
49091: PUSH
49092: EMPTY
49093: LIST
49094: LIST
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: LIST
49100: PUSH
49101: EMPTY
49102: LIST
49103: LIST
49104: LIST
49105: ST_TO_ADDR
// result := [ ] ;
49106: LD_ADDR_VAR 0 3
49110: PUSH
49111: EMPTY
49112: ST_TO_ADDR
// for i in turrets do
49113: LD_ADDR_VAR 0 4
49117: PUSH
49118: LD_VAR 0 1
49122: PUSH
49123: FOR_IN
49124: IFFALSE 49307
// begin nat := GetNation ( i ) ;
49126: LD_ADDR_VAR 0 7
49130: PUSH
49131: LD_VAR 0 4
49135: PPUSH
49136: CALL_OW 248
49140: ST_TO_ADDR
// weapon := 0 ;
49141: LD_ADDR_VAR 0 8
49145: PUSH
49146: LD_INT 0
49148: ST_TO_ADDR
// if not nat then
49149: LD_VAR 0 7
49153: NOT
49154: IFFALSE 49158
// continue ;
49156: GO 49123
// for j in list [ nat ] do
49158: LD_ADDR_VAR 0 5
49162: PUSH
49163: LD_VAR 0 10
49167: PUSH
49168: LD_VAR 0 7
49172: ARRAY
49173: PUSH
49174: FOR_IN
49175: IFFALSE 49216
// if GetBWeapon ( i ) = j [ 1 ] then
49177: LD_VAR 0 4
49181: PPUSH
49182: CALL_OW 269
49186: PUSH
49187: LD_VAR 0 5
49191: PUSH
49192: LD_INT 1
49194: ARRAY
49195: EQUAL
49196: IFFALSE 49214
// begin weapon := j [ 2 ] ;
49198: LD_ADDR_VAR 0 8
49202: PUSH
49203: LD_VAR 0 5
49207: PUSH
49208: LD_INT 2
49210: ARRAY
49211: ST_TO_ADDR
// break ;
49212: GO 49216
// end ;
49214: GO 49174
49216: POP
49217: POP
// if not weapon then
49218: LD_VAR 0 8
49222: NOT
49223: IFFALSE 49227
// continue ;
49225: GO 49123
// for k in factories do
49227: LD_ADDR_VAR 0 6
49231: PUSH
49232: LD_VAR 0 2
49236: PUSH
49237: FOR_IN
49238: IFFALSE 49303
// begin weapons := AvailableWeaponList ( k ) ;
49240: LD_ADDR_VAR 0 9
49244: PUSH
49245: LD_VAR 0 6
49249: PPUSH
49250: CALL_OW 478
49254: ST_TO_ADDR
// if not weapons then
49255: LD_VAR 0 9
49259: NOT
49260: IFFALSE 49264
// continue ;
49262: GO 49237
// if weapon in weapons then
49264: LD_VAR 0 8
49268: PUSH
49269: LD_VAR 0 9
49273: IN
49274: IFFALSE 49301
// begin result := [ i , weapon ] ;
49276: LD_ADDR_VAR 0 3
49280: PUSH
49281: LD_VAR 0 4
49285: PUSH
49286: LD_VAR 0 8
49290: PUSH
49291: EMPTY
49292: LIST
49293: LIST
49294: ST_TO_ADDR
// exit ;
49295: POP
49296: POP
49297: POP
49298: POP
49299: GO 49309
// end ; end ;
49301: GO 49237
49303: POP
49304: POP
// end ;
49305: GO 49123
49307: POP
49308: POP
// end ;
49309: LD_VAR 0 3
49313: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
49314: LD_INT 0
49316: PPUSH
// if not side or side > 8 then
49317: LD_VAR 0 3
49321: NOT
49322: PUSH
49323: LD_VAR 0 3
49327: PUSH
49328: LD_INT 8
49330: GREATER
49331: OR
49332: IFFALSE 49336
// exit ;
49334: GO 49395
// if not range then
49336: LD_VAR 0 4
49340: NOT
49341: IFFALSE 49352
// range := - 12 ;
49343: LD_ADDR_VAR 0 4
49347: PUSH
49348: LD_INT 12
49350: NEG
49351: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
49352: LD_VAR 0 1
49356: PPUSH
49357: LD_VAR 0 2
49361: PPUSH
49362: LD_VAR 0 3
49366: PPUSH
49367: LD_VAR 0 4
49371: PPUSH
49372: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
49376: LD_VAR 0 1
49380: PPUSH
49381: LD_VAR 0 2
49385: PPUSH
49386: LD_VAR 0 3
49390: PPUSH
49391: CALL_OW 331
// end ;
49395: LD_VAR 0 5
49399: RET
// export function Video ( mode ) ; begin
49400: LD_INT 0
49402: PPUSH
// ingame_video = mode ;
49403: LD_ADDR_OWVAR 52
49407: PUSH
49408: LD_VAR 0 1
49412: ST_TO_ADDR
// interface_hidden = mode ;
49413: LD_ADDR_OWVAR 54
49417: PUSH
49418: LD_VAR 0 1
49422: ST_TO_ADDR
// end ;
49423: LD_VAR 0 2
49427: RET
// export function Join ( array , element ) ; begin
49428: LD_INT 0
49430: PPUSH
// result := Replace ( array , array + 1 , element ) ;
49431: LD_ADDR_VAR 0 3
49435: PUSH
49436: LD_VAR 0 1
49440: PPUSH
49441: LD_VAR 0 1
49445: PUSH
49446: LD_INT 1
49448: PLUS
49449: PPUSH
49450: LD_VAR 0 2
49454: PPUSH
49455: CALL_OW 1
49459: ST_TO_ADDR
// end ;
49460: LD_VAR 0 3
49464: RET
// export function JoinUnion ( array , element ) ; begin
49465: LD_INT 0
49467: PPUSH
// result := array union element ;
49468: LD_ADDR_VAR 0 3
49472: PUSH
49473: LD_VAR 0 1
49477: PUSH
49478: LD_VAR 0 2
49482: UNION
49483: ST_TO_ADDR
// end ;
49484: LD_VAR 0 3
49488: RET
// export function GetBehemoths ( side ) ; begin
49489: LD_INT 0
49491: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
49492: LD_ADDR_VAR 0 2
49496: PUSH
49497: LD_INT 22
49499: PUSH
49500: LD_VAR 0 1
49504: PUSH
49505: EMPTY
49506: LIST
49507: LIST
49508: PUSH
49509: LD_INT 31
49511: PUSH
49512: LD_INT 25
49514: PUSH
49515: EMPTY
49516: LIST
49517: LIST
49518: PUSH
49519: EMPTY
49520: LIST
49521: LIST
49522: PPUSH
49523: CALL_OW 69
49527: ST_TO_ADDR
// end ;
49528: LD_VAR 0 2
49532: RET
// export function Shuffle ( array ) ; var i , index ; begin
49533: LD_INT 0
49535: PPUSH
49536: PPUSH
49537: PPUSH
// result := [ ] ;
49538: LD_ADDR_VAR 0 2
49542: PUSH
49543: EMPTY
49544: ST_TO_ADDR
// if not array then
49545: LD_VAR 0 1
49549: NOT
49550: IFFALSE 49554
// exit ;
49552: GO 49653
// Randomize ;
49554: CALL_OW 10
// for i = array downto 1 do
49558: LD_ADDR_VAR 0 3
49562: PUSH
49563: DOUBLE
49564: LD_VAR 0 1
49568: INC
49569: ST_TO_ADDR
49570: LD_INT 1
49572: PUSH
49573: FOR_DOWNTO
49574: IFFALSE 49651
// begin index := rand ( 1 , array ) ;
49576: LD_ADDR_VAR 0 4
49580: PUSH
49581: LD_INT 1
49583: PPUSH
49584: LD_VAR 0 1
49588: PPUSH
49589: CALL_OW 12
49593: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
49594: LD_ADDR_VAR 0 2
49598: PUSH
49599: LD_VAR 0 2
49603: PPUSH
49604: LD_VAR 0 2
49608: PUSH
49609: LD_INT 1
49611: PLUS
49612: PPUSH
49613: LD_VAR 0 1
49617: PUSH
49618: LD_VAR 0 4
49622: ARRAY
49623: PPUSH
49624: CALL_OW 2
49628: ST_TO_ADDR
// array := Delete ( array , index ) ;
49629: LD_ADDR_VAR 0 1
49633: PUSH
49634: LD_VAR 0 1
49638: PPUSH
49639: LD_VAR 0 4
49643: PPUSH
49644: CALL_OW 3
49648: ST_TO_ADDR
// end ;
49649: GO 49573
49651: POP
49652: POP
// end ;
49653: LD_VAR 0 2
49657: RET
// export function GetBaseMaterials ( base ) ; begin
49658: LD_INT 0
49660: PPUSH
// result := [ 0 , 0 , 0 ] ;
49661: LD_ADDR_VAR 0 2
49665: PUSH
49666: LD_INT 0
49668: PUSH
49669: LD_INT 0
49671: PUSH
49672: LD_INT 0
49674: PUSH
49675: EMPTY
49676: LIST
49677: LIST
49678: LIST
49679: ST_TO_ADDR
// if not base then
49680: LD_VAR 0 1
49684: NOT
49685: IFFALSE 49689
// exit ;
49687: GO 49738
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
49689: LD_ADDR_VAR 0 2
49693: PUSH
49694: LD_VAR 0 1
49698: PPUSH
49699: LD_INT 1
49701: PPUSH
49702: CALL_OW 275
49706: PUSH
49707: LD_VAR 0 1
49711: PPUSH
49712: LD_INT 2
49714: PPUSH
49715: CALL_OW 275
49719: PUSH
49720: LD_VAR 0 1
49724: PPUSH
49725: LD_INT 3
49727: PPUSH
49728: CALL_OW 275
49732: PUSH
49733: EMPTY
49734: LIST
49735: LIST
49736: LIST
49737: ST_TO_ADDR
// end ;
49738: LD_VAR 0 2
49742: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
49743: LD_INT 0
49745: PPUSH
49746: PPUSH
// result := array ;
49747: LD_ADDR_VAR 0 3
49751: PUSH
49752: LD_VAR 0 1
49756: ST_TO_ADDR
// if size > 0 then
49757: LD_VAR 0 2
49761: PUSH
49762: LD_INT 0
49764: GREATER
49765: IFFALSE 49811
// for i := array downto size do
49767: LD_ADDR_VAR 0 4
49771: PUSH
49772: DOUBLE
49773: LD_VAR 0 1
49777: INC
49778: ST_TO_ADDR
49779: LD_VAR 0 2
49783: PUSH
49784: FOR_DOWNTO
49785: IFFALSE 49809
// result := Delete ( result , result ) ;
49787: LD_ADDR_VAR 0 3
49791: PUSH
49792: LD_VAR 0 3
49796: PPUSH
49797: LD_VAR 0 3
49801: PPUSH
49802: CALL_OW 3
49806: ST_TO_ADDR
49807: GO 49784
49809: POP
49810: POP
// end ;
49811: LD_VAR 0 3
49815: RET
// export function ComExit ( unit ) ; var tmp ; begin
49816: LD_INT 0
49818: PPUSH
49819: PPUSH
// if not IsInUnit ( unit ) then
49820: LD_VAR 0 1
49824: PPUSH
49825: CALL_OW 310
49829: NOT
49830: IFFALSE 49834
// exit ;
49832: GO 49894
// tmp := IsInUnit ( unit ) ;
49834: LD_ADDR_VAR 0 3
49838: PUSH
49839: LD_VAR 0 1
49843: PPUSH
49844: CALL_OW 310
49848: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
49849: LD_VAR 0 3
49853: PPUSH
49854: CALL_OW 247
49858: PUSH
49859: LD_INT 2
49861: EQUAL
49862: IFFALSE 49875
// ComExitVehicle ( unit ) else
49864: LD_VAR 0 1
49868: PPUSH
49869: CALL_OW 121
49873: GO 49884
// ComExitBuilding ( unit ) ;
49875: LD_VAR 0 1
49879: PPUSH
49880: CALL_OW 122
// result := tmp ;
49884: LD_ADDR_VAR 0 2
49888: PUSH
49889: LD_VAR 0 3
49893: ST_TO_ADDR
// end ;
49894: LD_VAR 0 2
49898: RET
// export function ResetHc ; begin
49899: LD_INT 0
49901: PPUSH
// InitHc ;
49902: CALL_OW 19
// hc_importance := 0 ;
49906: LD_ADDR_OWVAR 32
49910: PUSH
49911: LD_INT 0
49913: ST_TO_ADDR
// end ; end_of_file
49914: LD_VAR 0 1
49918: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
49919: LD_INT 0
49921: PPUSH
// ar_crane := 88 ;
49922: LD_ADDR_EXP 54
49926: PUSH
49927: LD_INT 88
49929: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
49930: LD_ADDR_EXP 49
49934: PUSH
49935: LD_INT 89
49937: ST_TO_ADDR
// us_hack := 99 ;
49938: LD_ADDR_EXP 50
49942: PUSH
49943: LD_INT 99
49945: ST_TO_ADDR
// us_artillery := 97 ;
49946: LD_ADDR_EXP 51
49950: PUSH
49951: LD_INT 97
49953: ST_TO_ADDR
// ar_bio_bomb := 91 ;
49954: LD_ADDR_EXP 52
49958: PUSH
49959: LD_INT 91
49961: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
49962: LD_ADDR_EXP 53
49966: PUSH
49967: LD_INT 92
49969: ST_TO_ADDR
// ru_radar := 98 ;
49970: LD_ADDR_EXP 48
49974: PUSH
49975: LD_INT 98
49977: ST_TO_ADDR
// tech_Artillery := 80 ;
49978: LD_ADDR_EXP 55
49982: PUSH
49983: LD_INT 80
49985: ST_TO_ADDR
// tech_RadMat := 81 ;
49986: LD_ADDR_EXP 56
49990: PUSH
49991: LD_INT 81
49993: ST_TO_ADDR
// tech_BasicTools := 82 ;
49994: LD_ADDR_EXP 57
49998: PUSH
49999: LD_INT 82
50001: ST_TO_ADDR
// tech_Cargo := 83 ;
50002: LD_ADDR_EXP 58
50006: PUSH
50007: LD_INT 83
50009: ST_TO_ADDR
// tech_Track := 84 ;
50010: LD_ADDR_EXP 59
50014: PUSH
50015: LD_INT 84
50017: ST_TO_ADDR
// tech_Crane := 85 ;
50018: LD_ADDR_EXP 60
50022: PUSH
50023: LD_INT 85
50025: ST_TO_ADDR
// tech_Bulldozer := 86 ;
50026: LD_ADDR_EXP 61
50030: PUSH
50031: LD_INT 86
50033: ST_TO_ADDR
// tech_Hovercraft := 87 ;
50034: LD_ADDR_EXP 62
50038: PUSH
50039: LD_INT 87
50041: ST_TO_ADDR
// end ;
50042: LD_VAR 0 1
50046: RET
// every 1 do
50047: GO 50049
50049: DISABLE
// InitGlobalVariables ; end_of_file
50050: CALL 49919 0 0
50054: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
50055: LD_INT 0
50057: PPUSH
50058: PPUSH
// skirmish := false ;
50059: LD_ADDR_EXP 63
50063: PUSH
50064: LD_INT 0
50066: ST_TO_ADDR
// debug_mc := false ;
50067: LD_ADDR_EXP 64
50071: PUSH
50072: LD_INT 0
50074: ST_TO_ADDR
// mc_bases := [ ] ;
50075: LD_ADDR_EXP 65
50079: PUSH
50080: EMPTY
50081: ST_TO_ADDR
// mc_sides := [ ] ;
50082: LD_ADDR_EXP 91
50086: PUSH
50087: EMPTY
50088: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
50089: LD_ADDR_EXP 66
50093: PUSH
50094: EMPTY
50095: ST_TO_ADDR
// mc_building_repairs := [ ] ;
50096: LD_ADDR_EXP 67
50100: PUSH
50101: EMPTY
50102: ST_TO_ADDR
// mc_need_heal := [ ] ;
50103: LD_ADDR_EXP 68
50107: PUSH
50108: EMPTY
50109: ST_TO_ADDR
// mc_healers := [ ] ;
50110: LD_ADDR_EXP 69
50114: PUSH
50115: EMPTY
50116: ST_TO_ADDR
// mc_build_list := [ ] ;
50117: LD_ADDR_EXP 70
50121: PUSH
50122: EMPTY
50123: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
50124: LD_ADDR_EXP 97
50128: PUSH
50129: EMPTY
50130: ST_TO_ADDR
// mc_builders := [ ] ;
50131: LD_ADDR_EXP 71
50135: PUSH
50136: EMPTY
50137: ST_TO_ADDR
// mc_construct_list := [ ] ;
50138: LD_ADDR_EXP 72
50142: PUSH
50143: EMPTY
50144: ST_TO_ADDR
// mc_turret_list := [ ] ;
50145: LD_ADDR_EXP 73
50149: PUSH
50150: EMPTY
50151: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
50152: LD_ADDR_EXP 74
50156: PUSH
50157: EMPTY
50158: ST_TO_ADDR
// mc_miners := [ ] ;
50159: LD_ADDR_EXP 79
50163: PUSH
50164: EMPTY
50165: ST_TO_ADDR
// mc_mines := [ ] ;
50166: LD_ADDR_EXP 78
50170: PUSH
50171: EMPTY
50172: ST_TO_ADDR
// mc_minefields := [ ] ;
50173: LD_ADDR_EXP 80
50177: PUSH
50178: EMPTY
50179: ST_TO_ADDR
// mc_crates := [ ] ;
50180: LD_ADDR_EXP 81
50184: PUSH
50185: EMPTY
50186: ST_TO_ADDR
// mc_crates_collector := [ ] ;
50187: LD_ADDR_EXP 82
50191: PUSH
50192: EMPTY
50193: ST_TO_ADDR
// mc_crates_area := [ ] ;
50194: LD_ADDR_EXP 83
50198: PUSH
50199: EMPTY
50200: ST_TO_ADDR
// mc_vehicles := [ ] ;
50201: LD_ADDR_EXP 84
50205: PUSH
50206: EMPTY
50207: ST_TO_ADDR
// mc_attack := [ ] ;
50208: LD_ADDR_EXP 85
50212: PUSH
50213: EMPTY
50214: ST_TO_ADDR
// mc_produce := [ ] ;
50215: LD_ADDR_EXP 86
50219: PUSH
50220: EMPTY
50221: ST_TO_ADDR
// mc_defender := [ ] ;
50222: LD_ADDR_EXP 87
50226: PUSH
50227: EMPTY
50228: ST_TO_ADDR
// mc_parking := [ ] ;
50229: LD_ADDR_EXP 89
50233: PUSH
50234: EMPTY
50235: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
50236: LD_ADDR_EXP 75
50240: PUSH
50241: EMPTY
50242: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
50243: LD_ADDR_EXP 77
50247: PUSH
50248: EMPTY
50249: ST_TO_ADDR
// mc_scan := [ ] ;
50250: LD_ADDR_EXP 88
50254: PUSH
50255: EMPTY
50256: ST_TO_ADDR
// mc_scan_area := [ ] ;
50257: LD_ADDR_EXP 90
50261: PUSH
50262: EMPTY
50263: ST_TO_ADDR
// mc_tech := [ ] ;
50264: LD_ADDR_EXP 92
50268: PUSH
50269: EMPTY
50270: ST_TO_ADDR
// mc_class := [ ] ;
50271: LD_ADDR_EXP 106
50275: PUSH
50276: EMPTY
50277: ST_TO_ADDR
// mc_class_case_use := [ ] ;
50278: LD_ADDR_EXP 107
50282: PUSH
50283: EMPTY
50284: ST_TO_ADDR
// end ;
50285: LD_VAR 0 1
50289: RET
// export function MC_Kill ( base ) ; begin
50290: LD_INT 0
50292: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
50293: LD_ADDR_EXP 65
50297: PUSH
50298: LD_EXP 65
50302: PPUSH
50303: LD_VAR 0 1
50307: PPUSH
50308: EMPTY
50309: PPUSH
50310: CALL_OW 1
50314: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
50315: LD_ADDR_EXP 66
50319: PUSH
50320: LD_EXP 66
50324: PPUSH
50325: LD_VAR 0 1
50329: PPUSH
50330: EMPTY
50331: PPUSH
50332: CALL_OW 1
50336: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
50337: LD_ADDR_EXP 67
50341: PUSH
50342: LD_EXP 67
50346: PPUSH
50347: LD_VAR 0 1
50351: PPUSH
50352: EMPTY
50353: PPUSH
50354: CALL_OW 1
50358: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
50359: LD_ADDR_EXP 68
50363: PUSH
50364: LD_EXP 68
50368: PPUSH
50369: LD_VAR 0 1
50373: PPUSH
50374: EMPTY
50375: PPUSH
50376: CALL_OW 1
50380: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
50381: LD_ADDR_EXP 69
50385: PUSH
50386: LD_EXP 69
50390: PPUSH
50391: LD_VAR 0 1
50395: PPUSH
50396: EMPTY
50397: PPUSH
50398: CALL_OW 1
50402: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
50403: LD_ADDR_EXP 70
50407: PUSH
50408: LD_EXP 70
50412: PPUSH
50413: LD_VAR 0 1
50417: PPUSH
50418: EMPTY
50419: PPUSH
50420: CALL_OW 1
50424: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
50425: LD_ADDR_EXP 71
50429: PUSH
50430: LD_EXP 71
50434: PPUSH
50435: LD_VAR 0 1
50439: PPUSH
50440: EMPTY
50441: PPUSH
50442: CALL_OW 1
50446: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
50447: LD_ADDR_EXP 72
50451: PUSH
50452: LD_EXP 72
50456: PPUSH
50457: LD_VAR 0 1
50461: PPUSH
50462: EMPTY
50463: PPUSH
50464: CALL_OW 1
50468: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
50469: LD_ADDR_EXP 73
50473: PUSH
50474: LD_EXP 73
50478: PPUSH
50479: LD_VAR 0 1
50483: PPUSH
50484: EMPTY
50485: PPUSH
50486: CALL_OW 1
50490: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
50491: LD_ADDR_EXP 74
50495: PUSH
50496: LD_EXP 74
50500: PPUSH
50501: LD_VAR 0 1
50505: PPUSH
50506: EMPTY
50507: PPUSH
50508: CALL_OW 1
50512: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
50513: LD_ADDR_EXP 75
50517: PUSH
50518: LD_EXP 75
50522: PPUSH
50523: LD_VAR 0 1
50527: PPUSH
50528: EMPTY
50529: PPUSH
50530: CALL_OW 1
50534: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
50535: LD_ADDR_EXP 76
50539: PUSH
50540: LD_EXP 76
50544: PPUSH
50545: LD_VAR 0 1
50549: PPUSH
50550: LD_INT 0
50552: PPUSH
50553: CALL_OW 1
50557: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
50558: LD_ADDR_EXP 77
50562: PUSH
50563: LD_EXP 77
50567: PPUSH
50568: LD_VAR 0 1
50572: PPUSH
50573: EMPTY
50574: PPUSH
50575: CALL_OW 1
50579: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
50580: LD_ADDR_EXP 78
50584: PUSH
50585: LD_EXP 78
50589: PPUSH
50590: LD_VAR 0 1
50594: PPUSH
50595: EMPTY
50596: PPUSH
50597: CALL_OW 1
50601: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
50602: LD_ADDR_EXP 79
50606: PUSH
50607: LD_EXP 79
50611: PPUSH
50612: LD_VAR 0 1
50616: PPUSH
50617: EMPTY
50618: PPUSH
50619: CALL_OW 1
50623: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
50624: LD_ADDR_EXP 80
50628: PUSH
50629: LD_EXP 80
50633: PPUSH
50634: LD_VAR 0 1
50638: PPUSH
50639: EMPTY
50640: PPUSH
50641: CALL_OW 1
50645: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
50646: LD_ADDR_EXP 81
50650: PUSH
50651: LD_EXP 81
50655: PPUSH
50656: LD_VAR 0 1
50660: PPUSH
50661: EMPTY
50662: PPUSH
50663: CALL_OW 1
50667: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
50668: LD_ADDR_EXP 82
50672: PUSH
50673: LD_EXP 82
50677: PPUSH
50678: LD_VAR 0 1
50682: PPUSH
50683: EMPTY
50684: PPUSH
50685: CALL_OW 1
50689: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
50690: LD_ADDR_EXP 83
50694: PUSH
50695: LD_EXP 83
50699: PPUSH
50700: LD_VAR 0 1
50704: PPUSH
50705: EMPTY
50706: PPUSH
50707: CALL_OW 1
50711: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
50712: LD_ADDR_EXP 84
50716: PUSH
50717: LD_EXP 84
50721: PPUSH
50722: LD_VAR 0 1
50726: PPUSH
50727: EMPTY
50728: PPUSH
50729: CALL_OW 1
50733: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
50734: LD_ADDR_EXP 85
50738: PUSH
50739: LD_EXP 85
50743: PPUSH
50744: LD_VAR 0 1
50748: PPUSH
50749: EMPTY
50750: PPUSH
50751: CALL_OW 1
50755: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
50756: LD_ADDR_EXP 86
50760: PUSH
50761: LD_EXP 86
50765: PPUSH
50766: LD_VAR 0 1
50770: PPUSH
50771: EMPTY
50772: PPUSH
50773: CALL_OW 1
50777: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
50778: LD_ADDR_EXP 87
50782: PUSH
50783: LD_EXP 87
50787: PPUSH
50788: LD_VAR 0 1
50792: PPUSH
50793: EMPTY
50794: PPUSH
50795: CALL_OW 1
50799: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
50800: LD_ADDR_EXP 88
50804: PUSH
50805: LD_EXP 88
50809: PPUSH
50810: LD_VAR 0 1
50814: PPUSH
50815: EMPTY
50816: PPUSH
50817: CALL_OW 1
50821: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
50822: LD_ADDR_EXP 89
50826: PUSH
50827: LD_EXP 89
50831: PPUSH
50832: LD_VAR 0 1
50836: PPUSH
50837: EMPTY
50838: PPUSH
50839: CALL_OW 1
50843: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
50844: LD_ADDR_EXP 90
50848: PUSH
50849: LD_EXP 90
50853: PPUSH
50854: LD_VAR 0 1
50858: PPUSH
50859: EMPTY
50860: PPUSH
50861: CALL_OW 1
50865: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
50866: LD_ADDR_EXP 92
50870: PUSH
50871: LD_EXP 92
50875: PPUSH
50876: LD_VAR 0 1
50880: PPUSH
50881: EMPTY
50882: PPUSH
50883: CALL_OW 1
50887: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
50888: LD_ADDR_EXP 94
50892: PUSH
50893: LD_EXP 94
50897: PPUSH
50898: LD_VAR 0 1
50902: PPUSH
50903: EMPTY
50904: PPUSH
50905: CALL_OW 1
50909: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
50910: LD_ADDR_EXP 95
50914: PUSH
50915: LD_EXP 95
50919: PPUSH
50920: LD_VAR 0 1
50924: PPUSH
50925: EMPTY
50926: PPUSH
50927: CALL_OW 1
50931: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
50932: LD_ADDR_EXP 96
50936: PUSH
50937: LD_EXP 96
50941: PPUSH
50942: LD_VAR 0 1
50946: PPUSH
50947: EMPTY
50948: PPUSH
50949: CALL_OW 1
50953: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
50954: LD_ADDR_EXP 97
50958: PUSH
50959: LD_EXP 97
50963: PPUSH
50964: LD_VAR 0 1
50968: PPUSH
50969: EMPTY
50970: PPUSH
50971: CALL_OW 1
50975: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
50976: LD_ADDR_EXP 98
50980: PUSH
50981: LD_EXP 98
50985: PPUSH
50986: LD_VAR 0 1
50990: PPUSH
50991: EMPTY
50992: PPUSH
50993: CALL_OW 1
50997: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
50998: LD_ADDR_EXP 99
51002: PUSH
51003: LD_EXP 99
51007: PPUSH
51008: LD_VAR 0 1
51012: PPUSH
51013: EMPTY
51014: PPUSH
51015: CALL_OW 1
51019: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
51020: LD_ADDR_EXP 100
51024: PUSH
51025: LD_EXP 100
51029: PPUSH
51030: LD_VAR 0 1
51034: PPUSH
51035: EMPTY
51036: PPUSH
51037: CALL_OW 1
51041: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
51042: LD_ADDR_EXP 101
51046: PUSH
51047: LD_EXP 101
51051: PPUSH
51052: LD_VAR 0 1
51056: PPUSH
51057: EMPTY
51058: PPUSH
51059: CALL_OW 1
51063: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
51064: LD_ADDR_EXP 102
51068: PUSH
51069: LD_EXP 102
51073: PPUSH
51074: LD_VAR 0 1
51078: PPUSH
51079: EMPTY
51080: PPUSH
51081: CALL_OW 1
51085: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
51086: LD_ADDR_EXP 103
51090: PUSH
51091: LD_EXP 103
51095: PPUSH
51096: LD_VAR 0 1
51100: PPUSH
51101: EMPTY
51102: PPUSH
51103: CALL_OW 1
51107: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
51108: LD_ADDR_EXP 104
51112: PUSH
51113: LD_EXP 104
51117: PPUSH
51118: LD_VAR 0 1
51122: PPUSH
51123: EMPTY
51124: PPUSH
51125: CALL_OW 1
51129: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
51130: LD_ADDR_EXP 105
51134: PUSH
51135: LD_EXP 105
51139: PPUSH
51140: LD_VAR 0 1
51144: PPUSH
51145: EMPTY
51146: PPUSH
51147: CALL_OW 1
51151: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
51152: LD_ADDR_EXP 106
51156: PUSH
51157: LD_EXP 106
51161: PPUSH
51162: LD_VAR 0 1
51166: PPUSH
51167: EMPTY
51168: PPUSH
51169: CALL_OW 1
51173: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
51174: LD_ADDR_EXP 107
51178: PUSH
51179: LD_EXP 107
51183: PPUSH
51184: LD_VAR 0 1
51188: PPUSH
51189: LD_INT 0
51191: PPUSH
51192: CALL_OW 1
51196: ST_TO_ADDR
// end ;
51197: LD_VAR 0 2
51201: RET
// export function MC_Add ( side , units ) ; var base ; begin
51202: LD_INT 0
51204: PPUSH
51205: PPUSH
// base := mc_bases + 1 ;
51206: LD_ADDR_VAR 0 4
51210: PUSH
51211: LD_EXP 65
51215: PUSH
51216: LD_INT 1
51218: PLUS
51219: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
51220: LD_ADDR_EXP 91
51224: PUSH
51225: LD_EXP 91
51229: PPUSH
51230: LD_VAR 0 4
51234: PPUSH
51235: LD_VAR 0 1
51239: PPUSH
51240: CALL_OW 1
51244: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
51245: LD_ADDR_EXP 65
51249: PUSH
51250: LD_EXP 65
51254: PPUSH
51255: LD_VAR 0 4
51259: PPUSH
51260: LD_VAR 0 2
51264: PPUSH
51265: CALL_OW 1
51269: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51270: LD_ADDR_EXP 66
51274: PUSH
51275: LD_EXP 66
51279: PPUSH
51280: LD_VAR 0 4
51284: PPUSH
51285: EMPTY
51286: PPUSH
51287: CALL_OW 1
51291: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51292: LD_ADDR_EXP 67
51296: PUSH
51297: LD_EXP 67
51301: PPUSH
51302: LD_VAR 0 4
51306: PPUSH
51307: EMPTY
51308: PPUSH
51309: CALL_OW 1
51313: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51314: LD_ADDR_EXP 68
51318: PUSH
51319: LD_EXP 68
51323: PPUSH
51324: LD_VAR 0 4
51328: PPUSH
51329: EMPTY
51330: PPUSH
51331: CALL_OW 1
51335: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51336: LD_ADDR_EXP 69
51340: PUSH
51341: LD_EXP 69
51345: PPUSH
51346: LD_VAR 0 4
51350: PPUSH
51351: EMPTY
51352: PPUSH
51353: CALL_OW 1
51357: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51358: LD_ADDR_EXP 70
51362: PUSH
51363: LD_EXP 70
51367: PPUSH
51368: LD_VAR 0 4
51372: PPUSH
51373: EMPTY
51374: PPUSH
51375: CALL_OW 1
51379: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51380: LD_ADDR_EXP 71
51384: PUSH
51385: LD_EXP 71
51389: PPUSH
51390: LD_VAR 0 4
51394: PPUSH
51395: EMPTY
51396: PPUSH
51397: CALL_OW 1
51401: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51402: LD_ADDR_EXP 72
51406: PUSH
51407: LD_EXP 72
51411: PPUSH
51412: LD_VAR 0 4
51416: PPUSH
51417: EMPTY
51418: PPUSH
51419: CALL_OW 1
51423: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51424: LD_ADDR_EXP 73
51428: PUSH
51429: LD_EXP 73
51433: PPUSH
51434: LD_VAR 0 4
51438: PPUSH
51439: EMPTY
51440: PPUSH
51441: CALL_OW 1
51445: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51446: LD_ADDR_EXP 74
51450: PUSH
51451: LD_EXP 74
51455: PPUSH
51456: LD_VAR 0 4
51460: PPUSH
51461: EMPTY
51462: PPUSH
51463: CALL_OW 1
51467: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51468: LD_ADDR_EXP 75
51472: PUSH
51473: LD_EXP 75
51477: PPUSH
51478: LD_VAR 0 4
51482: PPUSH
51483: EMPTY
51484: PPUSH
51485: CALL_OW 1
51489: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51490: LD_ADDR_EXP 76
51494: PUSH
51495: LD_EXP 76
51499: PPUSH
51500: LD_VAR 0 4
51504: PPUSH
51505: LD_INT 0
51507: PPUSH
51508: CALL_OW 1
51512: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51513: LD_ADDR_EXP 77
51517: PUSH
51518: LD_EXP 77
51522: PPUSH
51523: LD_VAR 0 4
51527: PPUSH
51528: EMPTY
51529: PPUSH
51530: CALL_OW 1
51534: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51535: LD_ADDR_EXP 78
51539: PUSH
51540: LD_EXP 78
51544: PPUSH
51545: LD_VAR 0 4
51549: PPUSH
51550: EMPTY
51551: PPUSH
51552: CALL_OW 1
51556: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51557: LD_ADDR_EXP 79
51561: PUSH
51562: LD_EXP 79
51566: PPUSH
51567: LD_VAR 0 4
51571: PPUSH
51572: EMPTY
51573: PPUSH
51574: CALL_OW 1
51578: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51579: LD_ADDR_EXP 80
51583: PUSH
51584: LD_EXP 80
51588: PPUSH
51589: LD_VAR 0 4
51593: PPUSH
51594: EMPTY
51595: PPUSH
51596: CALL_OW 1
51600: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51601: LD_ADDR_EXP 81
51605: PUSH
51606: LD_EXP 81
51610: PPUSH
51611: LD_VAR 0 4
51615: PPUSH
51616: EMPTY
51617: PPUSH
51618: CALL_OW 1
51622: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51623: LD_ADDR_EXP 82
51627: PUSH
51628: LD_EXP 82
51632: PPUSH
51633: LD_VAR 0 4
51637: PPUSH
51638: EMPTY
51639: PPUSH
51640: CALL_OW 1
51644: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51645: LD_ADDR_EXP 83
51649: PUSH
51650: LD_EXP 83
51654: PPUSH
51655: LD_VAR 0 4
51659: PPUSH
51660: EMPTY
51661: PPUSH
51662: CALL_OW 1
51666: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51667: LD_ADDR_EXP 84
51671: PUSH
51672: LD_EXP 84
51676: PPUSH
51677: LD_VAR 0 4
51681: PPUSH
51682: EMPTY
51683: PPUSH
51684: CALL_OW 1
51688: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51689: LD_ADDR_EXP 85
51693: PUSH
51694: LD_EXP 85
51698: PPUSH
51699: LD_VAR 0 4
51703: PPUSH
51704: EMPTY
51705: PPUSH
51706: CALL_OW 1
51710: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51711: LD_ADDR_EXP 86
51715: PUSH
51716: LD_EXP 86
51720: PPUSH
51721: LD_VAR 0 4
51725: PPUSH
51726: EMPTY
51727: PPUSH
51728: CALL_OW 1
51732: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51733: LD_ADDR_EXP 87
51737: PUSH
51738: LD_EXP 87
51742: PPUSH
51743: LD_VAR 0 4
51747: PPUSH
51748: EMPTY
51749: PPUSH
51750: CALL_OW 1
51754: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51755: LD_ADDR_EXP 88
51759: PUSH
51760: LD_EXP 88
51764: PPUSH
51765: LD_VAR 0 4
51769: PPUSH
51770: EMPTY
51771: PPUSH
51772: CALL_OW 1
51776: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51777: LD_ADDR_EXP 89
51781: PUSH
51782: LD_EXP 89
51786: PPUSH
51787: LD_VAR 0 4
51791: PPUSH
51792: EMPTY
51793: PPUSH
51794: CALL_OW 1
51798: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51799: LD_ADDR_EXP 90
51803: PUSH
51804: LD_EXP 90
51808: PPUSH
51809: LD_VAR 0 4
51813: PPUSH
51814: EMPTY
51815: PPUSH
51816: CALL_OW 1
51820: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51821: LD_ADDR_EXP 92
51825: PUSH
51826: LD_EXP 92
51830: PPUSH
51831: LD_VAR 0 4
51835: PPUSH
51836: EMPTY
51837: PPUSH
51838: CALL_OW 1
51842: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51843: LD_ADDR_EXP 94
51847: PUSH
51848: LD_EXP 94
51852: PPUSH
51853: LD_VAR 0 4
51857: PPUSH
51858: EMPTY
51859: PPUSH
51860: CALL_OW 1
51864: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51865: LD_ADDR_EXP 95
51869: PUSH
51870: LD_EXP 95
51874: PPUSH
51875: LD_VAR 0 4
51879: PPUSH
51880: EMPTY
51881: PPUSH
51882: CALL_OW 1
51886: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51887: LD_ADDR_EXP 96
51891: PUSH
51892: LD_EXP 96
51896: PPUSH
51897: LD_VAR 0 4
51901: PPUSH
51902: EMPTY
51903: PPUSH
51904: CALL_OW 1
51908: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51909: LD_ADDR_EXP 97
51913: PUSH
51914: LD_EXP 97
51918: PPUSH
51919: LD_VAR 0 4
51923: PPUSH
51924: EMPTY
51925: PPUSH
51926: CALL_OW 1
51930: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51931: LD_ADDR_EXP 98
51935: PUSH
51936: LD_EXP 98
51940: PPUSH
51941: LD_VAR 0 4
51945: PPUSH
51946: EMPTY
51947: PPUSH
51948: CALL_OW 1
51952: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
51953: LD_ADDR_EXP 99
51957: PUSH
51958: LD_EXP 99
51962: PPUSH
51963: LD_VAR 0 4
51967: PPUSH
51968: EMPTY
51969: PPUSH
51970: CALL_OW 1
51974: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
51975: LD_ADDR_EXP 100
51979: PUSH
51980: LD_EXP 100
51984: PPUSH
51985: LD_VAR 0 4
51989: PPUSH
51990: EMPTY
51991: PPUSH
51992: CALL_OW 1
51996: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
51997: LD_ADDR_EXP 101
52001: PUSH
52002: LD_EXP 101
52006: PPUSH
52007: LD_VAR 0 4
52011: PPUSH
52012: EMPTY
52013: PPUSH
52014: CALL_OW 1
52018: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52019: LD_ADDR_EXP 102
52023: PUSH
52024: LD_EXP 102
52028: PPUSH
52029: LD_VAR 0 4
52033: PPUSH
52034: EMPTY
52035: PPUSH
52036: CALL_OW 1
52040: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52041: LD_ADDR_EXP 103
52045: PUSH
52046: LD_EXP 103
52050: PPUSH
52051: LD_VAR 0 4
52055: PPUSH
52056: EMPTY
52057: PPUSH
52058: CALL_OW 1
52062: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52063: LD_ADDR_EXP 104
52067: PUSH
52068: LD_EXP 104
52072: PPUSH
52073: LD_VAR 0 4
52077: PPUSH
52078: EMPTY
52079: PPUSH
52080: CALL_OW 1
52084: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52085: LD_ADDR_EXP 105
52089: PUSH
52090: LD_EXP 105
52094: PPUSH
52095: LD_VAR 0 4
52099: PPUSH
52100: EMPTY
52101: PPUSH
52102: CALL_OW 1
52106: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52107: LD_ADDR_EXP 106
52111: PUSH
52112: LD_EXP 106
52116: PPUSH
52117: LD_VAR 0 4
52121: PPUSH
52122: EMPTY
52123: PPUSH
52124: CALL_OW 1
52128: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52129: LD_ADDR_EXP 107
52133: PUSH
52134: LD_EXP 107
52138: PPUSH
52139: LD_VAR 0 4
52143: PPUSH
52144: LD_INT 0
52146: PPUSH
52147: CALL_OW 1
52151: ST_TO_ADDR
// result := base ;
52152: LD_ADDR_VAR 0 3
52156: PUSH
52157: LD_VAR 0 4
52161: ST_TO_ADDR
// end ;
52162: LD_VAR 0 3
52166: RET
// export function MC_Start ( ) ; var i ; begin
52167: LD_INT 0
52169: PPUSH
52170: PPUSH
// for i = 1 to mc_bases do
52171: LD_ADDR_VAR 0 2
52175: PUSH
52176: DOUBLE
52177: LD_INT 1
52179: DEC
52180: ST_TO_ADDR
52181: LD_EXP 65
52185: PUSH
52186: FOR_TO
52187: IFFALSE 53264
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
52189: LD_ADDR_EXP 65
52193: PUSH
52194: LD_EXP 65
52198: PPUSH
52199: LD_VAR 0 2
52203: PPUSH
52204: LD_EXP 65
52208: PUSH
52209: LD_VAR 0 2
52213: ARRAY
52214: PUSH
52215: LD_INT 0
52217: DIFF
52218: PPUSH
52219: CALL_OW 1
52223: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
52224: LD_ADDR_EXP 66
52228: PUSH
52229: LD_EXP 66
52233: PPUSH
52234: LD_VAR 0 2
52238: PPUSH
52239: EMPTY
52240: PPUSH
52241: CALL_OW 1
52245: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
52246: LD_ADDR_EXP 67
52250: PUSH
52251: LD_EXP 67
52255: PPUSH
52256: LD_VAR 0 2
52260: PPUSH
52261: EMPTY
52262: PPUSH
52263: CALL_OW 1
52267: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
52268: LD_ADDR_EXP 68
52272: PUSH
52273: LD_EXP 68
52277: PPUSH
52278: LD_VAR 0 2
52282: PPUSH
52283: EMPTY
52284: PPUSH
52285: CALL_OW 1
52289: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
52290: LD_ADDR_EXP 69
52294: PUSH
52295: LD_EXP 69
52299: PPUSH
52300: LD_VAR 0 2
52304: PPUSH
52305: EMPTY
52306: PUSH
52307: EMPTY
52308: PUSH
52309: EMPTY
52310: LIST
52311: LIST
52312: PPUSH
52313: CALL_OW 1
52317: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
52318: LD_ADDR_EXP 70
52322: PUSH
52323: LD_EXP 70
52327: PPUSH
52328: LD_VAR 0 2
52332: PPUSH
52333: EMPTY
52334: PPUSH
52335: CALL_OW 1
52339: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
52340: LD_ADDR_EXP 97
52344: PUSH
52345: LD_EXP 97
52349: PPUSH
52350: LD_VAR 0 2
52354: PPUSH
52355: EMPTY
52356: PPUSH
52357: CALL_OW 1
52361: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
52362: LD_ADDR_EXP 71
52366: PUSH
52367: LD_EXP 71
52371: PPUSH
52372: LD_VAR 0 2
52376: PPUSH
52377: EMPTY
52378: PPUSH
52379: CALL_OW 1
52383: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
52384: LD_ADDR_EXP 72
52388: PUSH
52389: LD_EXP 72
52393: PPUSH
52394: LD_VAR 0 2
52398: PPUSH
52399: EMPTY
52400: PPUSH
52401: CALL_OW 1
52405: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
52406: LD_ADDR_EXP 73
52410: PUSH
52411: LD_EXP 73
52415: PPUSH
52416: LD_VAR 0 2
52420: PPUSH
52421: LD_EXP 65
52425: PUSH
52426: LD_VAR 0 2
52430: ARRAY
52431: PPUSH
52432: LD_INT 2
52434: PUSH
52435: LD_INT 30
52437: PUSH
52438: LD_INT 32
52440: PUSH
52441: EMPTY
52442: LIST
52443: LIST
52444: PUSH
52445: LD_INT 30
52447: PUSH
52448: LD_INT 33
52450: PUSH
52451: EMPTY
52452: LIST
52453: LIST
52454: PUSH
52455: EMPTY
52456: LIST
52457: LIST
52458: LIST
52459: PPUSH
52460: CALL_OW 72
52464: PPUSH
52465: CALL_OW 1
52469: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
52470: LD_ADDR_EXP 74
52474: PUSH
52475: LD_EXP 74
52479: PPUSH
52480: LD_VAR 0 2
52484: PPUSH
52485: LD_EXP 65
52489: PUSH
52490: LD_VAR 0 2
52494: ARRAY
52495: PPUSH
52496: LD_INT 2
52498: PUSH
52499: LD_INT 30
52501: PUSH
52502: LD_INT 32
52504: PUSH
52505: EMPTY
52506: LIST
52507: LIST
52508: PUSH
52509: LD_INT 30
52511: PUSH
52512: LD_INT 31
52514: PUSH
52515: EMPTY
52516: LIST
52517: LIST
52518: PUSH
52519: EMPTY
52520: LIST
52521: LIST
52522: LIST
52523: PUSH
52524: LD_INT 58
52526: PUSH
52527: EMPTY
52528: LIST
52529: PUSH
52530: EMPTY
52531: LIST
52532: LIST
52533: PPUSH
52534: CALL_OW 72
52538: PPUSH
52539: CALL_OW 1
52543: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
52544: LD_ADDR_EXP 75
52548: PUSH
52549: LD_EXP 75
52553: PPUSH
52554: LD_VAR 0 2
52558: PPUSH
52559: EMPTY
52560: PPUSH
52561: CALL_OW 1
52565: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
52566: LD_ADDR_EXP 79
52570: PUSH
52571: LD_EXP 79
52575: PPUSH
52576: LD_VAR 0 2
52580: PPUSH
52581: EMPTY
52582: PPUSH
52583: CALL_OW 1
52587: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
52588: LD_ADDR_EXP 78
52592: PUSH
52593: LD_EXP 78
52597: PPUSH
52598: LD_VAR 0 2
52602: PPUSH
52603: EMPTY
52604: PPUSH
52605: CALL_OW 1
52609: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
52610: LD_ADDR_EXP 80
52614: PUSH
52615: LD_EXP 80
52619: PPUSH
52620: LD_VAR 0 2
52624: PPUSH
52625: EMPTY
52626: PPUSH
52627: CALL_OW 1
52631: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
52632: LD_ADDR_EXP 81
52636: PUSH
52637: LD_EXP 81
52641: PPUSH
52642: LD_VAR 0 2
52646: PPUSH
52647: EMPTY
52648: PPUSH
52649: CALL_OW 1
52653: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52654: LD_ADDR_EXP 82
52658: PUSH
52659: LD_EXP 82
52663: PPUSH
52664: LD_VAR 0 2
52668: PPUSH
52669: EMPTY
52670: PPUSH
52671: CALL_OW 1
52675: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
52676: LD_ADDR_EXP 83
52680: PUSH
52681: LD_EXP 83
52685: PPUSH
52686: LD_VAR 0 2
52690: PPUSH
52691: EMPTY
52692: PPUSH
52693: CALL_OW 1
52697: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
52698: LD_ADDR_EXP 84
52702: PUSH
52703: LD_EXP 84
52707: PPUSH
52708: LD_VAR 0 2
52712: PPUSH
52713: EMPTY
52714: PPUSH
52715: CALL_OW 1
52719: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
52720: LD_ADDR_EXP 85
52724: PUSH
52725: LD_EXP 85
52729: PPUSH
52730: LD_VAR 0 2
52734: PPUSH
52735: EMPTY
52736: PPUSH
52737: CALL_OW 1
52741: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
52742: LD_ADDR_EXP 86
52746: PUSH
52747: LD_EXP 86
52751: PPUSH
52752: LD_VAR 0 2
52756: PPUSH
52757: EMPTY
52758: PPUSH
52759: CALL_OW 1
52763: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
52764: LD_ADDR_EXP 87
52768: PUSH
52769: LD_EXP 87
52773: PPUSH
52774: LD_VAR 0 2
52778: PPUSH
52779: EMPTY
52780: PPUSH
52781: CALL_OW 1
52785: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
52786: LD_ADDR_EXP 76
52790: PUSH
52791: LD_EXP 76
52795: PPUSH
52796: LD_VAR 0 2
52800: PPUSH
52801: LD_INT 0
52803: PPUSH
52804: CALL_OW 1
52808: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
52809: LD_ADDR_EXP 89
52813: PUSH
52814: LD_EXP 89
52818: PPUSH
52819: LD_VAR 0 2
52823: PPUSH
52824: LD_INT 0
52826: PPUSH
52827: CALL_OW 1
52831: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52832: LD_ADDR_EXP 77
52836: PUSH
52837: LD_EXP 77
52841: PPUSH
52842: LD_VAR 0 2
52846: PPUSH
52847: EMPTY
52848: PPUSH
52849: CALL_OW 1
52853: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
52854: LD_ADDR_EXP 88
52858: PUSH
52859: LD_EXP 88
52863: PPUSH
52864: LD_VAR 0 2
52868: PPUSH
52869: LD_INT 0
52871: PPUSH
52872: CALL_OW 1
52876: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
52877: LD_ADDR_EXP 90
52881: PUSH
52882: LD_EXP 90
52886: PPUSH
52887: LD_VAR 0 2
52891: PPUSH
52892: EMPTY
52893: PPUSH
52894: CALL_OW 1
52898: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
52899: LD_ADDR_EXP 93
52903: PUSH
52904: LD_EXP 93
52908: PPUSH
52909: LD_VAR 0 2
52913: PPUSH
52914: LD_INT 0
52916: PPUSH
52917: CALL_OW 1
52921: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
52922: LD_ADDR_EXP 94
52926: PUSH
52927: LD_EXP 94
52931: PPUSH
52932: LD_VAR 0 2
52936: PPUSH
52937: EMPTY
52938: PPUSH
52939: CALL_OW 1
52943: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
52944: LD_ADDR_EXP 95
52948: PUSH
52949: LD_EXP 95
52953: PPUSH
52954: LD_VAR 0 2
52958: PPUSH
52959: EMPTY
52960: PPUSH
52961: CALL_OW 1
52965: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52966: LD_ADDR_EXP 96
52970: PUSH
52971: LD_EXP 96
52975: PPUSH
52976: LD_VAR 0 2
52980: PPUSH
52981: EMPTY
52982: PPUSH
52983: CALL_OW 1
52987: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
52988: LD_ADDR_EXP 98
52992: PUSH
52993: LD_EXP 98
52997: PPUSH
52998: LD_VAR 0 2
53002: PPUSH
53003: LD_EXP 65
53007: PUSH
53008: LD_VAR 0 2
53012: ARRAY
53013: PPUSH
53014: LD_INT 2
53016: PUSH
53017: LD_INT 30
53019: PUSH
53020: LD_INT 6
53022: PUSH
53023: EMPTY
53024: LIST
53025: LIST
53026: PUSH
53027: LD_INT 30
53029: PUSH
53030: LD_INT 7
53032: PUSH
53033: EMPTY
53034: LIST
53035: LIST
53036: PUSH
53037: LD_INT 30
53039: PUSH
53040: LD_INT 8
53042: PUSH
53043: EMPTY
53044: LIST
53045: LIST
53046: PUSH
53047: EMPTY
53048: LIST
53049: LIST
53050: LIST
53051: LIST
53052: PPUSH
53053: CALL_OW 72
53057: PPUSH
53058: CALL_OW 1
53062: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
53063: LD_ADDR_EXP 99
53067: PUSH
53068: LD_EXP 99
53072: PPUSH
53073: LD_VAR 0 2
53077: PPUSH
53078: EMPTY
53079: PPUSH
53080: CALL_OW 1
53084: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
53085: LD_ADDR_EXP 100
53089: PUSH
53090: LD_EXP 100
53094: PPUSH
53095: LD_VAR 0 2
53099: PPUSH
53100: EMPTY
53101: PPUSH
53102: CALL_OW 1
53106: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
53107: LD_ADDR_EXP 101
53111: PUSH
53112: LD_EXP 101
53116: PPUSH
53117: LD_VAR 0 2
53121: PPUSH
53122: EMPTY
53123: PPUSH
53124: CALL_OW 1
53128: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
53129: LD_ADDR_EXP 102
53133: PUSH
53134: LD_EXP 102
53138: PPUSH
53139: LD_VAR 0 2
53143: PPUSH
53144: EMPTY
53145: PPUSH
53146: CALL_OW 1
53150: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
53151: LD_ADDR_EXP 103
53155: PUSH
53156: LD_EXP 103
53160: PPUSH
53161: LD_VAR 0 2
53165: PPUSH
53166: EMPTY
53167: PPUSH
53168: CALL_OW 1
53172: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
53173: LD_ADDR_EXP 104
53177: PUSH
53178: LD_EXP 104
53182: PPUSH
53183: LD_VAR 0 2
53187: PPUSH
53188: EMPTY
53189: PPUSH
53190: CALL_OW 1
53194: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
53195: LD_ADDR_EXP 105
53199: PUSH
53200: LD_EXP 105
53204: PPUSH
53205: LD_VAR 0 2
53209: PPUSH
53210: EMPTY
53211: PPUSH
53212: CALL_OW 1
53216: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
53217: LD_ADDR_EXP 106
53221: PUSH
53222: LD_EXP 106
53226: PPUSH
53227: LD_VAR 0 2
53231: PPUSH
53232: EMPTY
53233: PPUSH
53234: CALL_OW 1
53238: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
53239: LD_ADDR_EXP 107
53243: PUSH
53244: LD_EXP 107
53248: PPUSH
53249: LD_VAR 0 2
53253: PPUSH
53254: LD_INT 0
53256: PPUSH
53257: CALL_OW 1
53261: ST_TO_ADDR
// end ;
53262: GO 52186
53264: POP
53265: POP
// MC_InitSides ( ) ;
53266: CALL 53552 0 0
// MC_InitResearch ( ) ;
53270: CALL 53291 0 0
// CustomInitMacro ( ) ;
53274: CALL 5985 0 0
// skirmish := true ;
53278: LD_ADDR_EXP 63
53282: PUSH
53283: LD_INT 1
53285: ST_TO_ADDR
// end ;
53286: LD_VAR 0 1
53290: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
53291: LD_INT 0
53293: PPUSH
53294: PPUSH
53295: PPUSH
53296: PPUSH
53297: PPUSH
53298: PPUSH
// if not mc_bases then
53299: LD_EXP 65
53303: NOT
53304: IFFALSE 53308
// exit ;
53306: GO 53547
// for i = 1 to 8 do
53308: LD_ADDR_VAR 0 2
53312: PUSH
53313: DOUBLE
53314: LD_INT 1
53316: DEC
53317: ST_TO_ADDR
53318: LD_INT 8
53320: PUSH
53321: FOR_TO
53322: IFFALSE 53348
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
53324: LD_ADDR_EXP 92
53328: PUSH
53329: LD_EXP 92
53333: PPUSH
53334: LD_VAR 0 2
53338: PPUSH
53339: EMPTY
53340: PPUSH
53341: CALL_OW 1
53345: ST_TO_ADDR
53346: GO 53321
53348: POP
53349: POP
// tmp := [ ] ;
53350: LD_ADDR_VAR 0 5
53354: PUSH
53355: EMPTY
53356: ST_TO_ADDR
// for i = 1 to mc_sides do
53357: LD_ADDR_VAR 0 2
53361: PUSH
53362: DOUBLE
53363: LD_INT 1
53365: DEC
53366: ST_TO_ADDR
53367: LD_EXP 91
53371: PUSH
53372: FOR_TO
53373: IFFALSE 53431
// if not mc_sides [ i ] in tmp then
53375: LD_EXP 91
53379: PUSH
53380: LD_VAR 0 2
53384: ARRAY
53385: PUSH
53386: LD_VAR 0 5
53390: IN
53391: NOT
53392: IFFALSE 53429
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
53394: LD_ADDR_VAR 0 5
53398: PUSH
53399: LD_VAR 0 5
53403: PPUSH
53404: LD_VAR 0 5
53408: PUSH
53409: LD_INT 1
53411: PLUS
53412: PPUSH
53413: LD_EXP 91
53417: PUSH
53418: LD_VAR 0 2
53422: ARRAY
53423: PPUSH
53424: CALL_OW 2
53428: ST_TO_ADDR
53429: GO 53372
53431: POP
53432: POP
// if not tmp then
53433: LD_VAR 0 5
53437: NOT
53438: IFFALSE 53442
// exit ;
53440: GO 53547
// for j in tmp do
53442: LD_ADDR_VAR 0 3
53446: PUSH
53447: LD_VAR 0 5
53451: PUSH
53452: FOR_IN
53453: IFFALSE 53545
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
53455: LD_ADDR_VAR 0 6
53459: PUSH
53460: LD_INT 22
53462: PUSH
53463: LD_VAR 0 3
53467: PUSH
53468: EMPTY
53469: LIST
53470: LIST
53471: PPUSH
53472: CALL_OW 69
53476: ST_TO_ADDR
// if not un then
53477: LD_VAR 0 6
53481: NOT
53482: IFFALSE 53486
// continue ;
53484: GO 53452
// nation := GetNation ( un [ 1 ] ) ;
53486: LD_ADDR_VAR 0 4
53490: PUSH
53491: LD_VAR 0 6
53495: PUSH
53496: LD_INT 1
53498: ARRAY
53499: PPUSH
53500: CALL_OW 248
53504: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
53505: LD_ADDR_EXP 92
53509: PUSH
53510: LD_EXP 92
53514: PPUSH
53515: LD_VAR 0 3
53519: PPUSH
53520: LD_VAR 0 3
53524: PPUSH
53525: LD_VAR 0 4
53529: PPUSH
53530: LD_INT 1
53532: PPUSH
53533: CALL 13621 0 3
53537: PPUSH
53538: CALL_OW 1
53542: ST_TO_ADDR
// end ;
53543: GO 53452
53545: POP
53546: POP
// end ;
53547: LD_VAR 0 1
53551: RET
// export function MC_InitSides ( ) ; var i ; begin
53552: LD_INT 0
53554: PPUSH
53555: PPUSH
// if not mc_bases then
53556: LD_EXP 65
53560: NOT
53561: IFFALSE 53565
// exit ;
53563: GO 53639
// for i = 1 to mc_bases do
53565: LD_ADDR_VAR 0 2
53569: PUSH
53570: DOUBLE
53571: LD_INT 1
53573: DEC
53574: ST_TO_ADDR
53575: LD_EXP 65
53579: PUSH
53580: FOR_TO
53581: IFFALSE 53637
// if mc_bases [ i ] then
53583: LD_EXP 65
53587: PUSH
53588: LD_VAR 0 2
53592: ARRAY
53593: IFFALSE 53635
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
53595: LD_ADDR_EXP 91
53599: PUSH
53600: LD_EXP 91
53604: PPUSH
53605: LD_VAR 0 2
53609: PPUSH
53610: LD_EXP 65
53614: PUSH
53615: LD_VAR 0 2
53619: ARRAY
53620: PUSH
53621: LD_INT 1
53623: ARRAY
53624: PPUSH
53625: CALL_OW 255
53629: PPUSH
53630: CALL_OW 1
53634: ST_TO_ADDR
53635: GO 53580
53637: POP
53638: POP
// end ;
53639: LD_VAR 0 1
53643: RET
// every 0 0$01 trigger skirmish do
53644: LD_EXP 63
53648: IFFALSE 53802
53650: GO 53652
53652: DISABLE
// begin enable ;
53653: ENABLE
// MC_CheckBuildings ( ) ;
53654: CALL 58300 0 0
// MC_CheckPeopleLife ( ) ;
53658: CALL 58425 0 0
// RaiseSailEvent ( 100 ) ;
53662: LD_INT 100
53664: PPUSH
53665: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
53669: LD_INT 103
53671: PPUSH
53672: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
53676: LD_INT 104
53678: PPUSH
53679: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
53683: LD_INT 105
53685: PPUSH
53686: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
53690: LD_INT 106
53692: PPUSH
53693: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
53697: LD_INT 107
53699: PPUSH
53700: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
53704: LD_INT 108
53706: PPUSH
53707: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
53711: LD_INT 109
53713: PPUSH
53714: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
53718: LD_INT 110
53720: PPUSH
53721: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
53725: LD_INT 111
53727: PPUSH
53728: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
53732: LD_INT 112
53734: PPUSH
53735: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
53739: LD_INT 113
53741: PPUSH
53742: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
53746: LD_INT 120
53748: PPUSH
53749: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
53753: LD_INT 121
53755: PPUSH
53756: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
53760: LD_INT 122
53762: PPUSH
53763: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
53767: LD_INT 123
53769: PPUSH
53770: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
53774: LD_INT 124
53776: PPUSH
53777: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
53781: LD_INT 125
53783: PPUSH
53784: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
53788: LD_INT 126
53790: PPUSH
53791: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
53795: LD_INT 200
53797: PPUSH
53798: CALL_OW 427
// end ;
53802: END
// on SailEvent ( event ) do begin if event < 100 then
53803: LD_VAR 0 1
53807: PUSH
53808: LD_INT 100
53810: LESS
53811: IFFALSE 53822
// CustomEvent ( event ) ;
53813: LD_VAR 0 1
53817: PPUSH
53818: CALL 5977 0 1
// if event = 100 then
53822: LD_VAR 0 1
53826: PUSH
53827: LD_INT 100
53829: EQUAL
53830: IFFALSE 53836
// MC_ClassManager ( ) ;
53832: CALL 54228 0 0
// if event = 101 then
53836: LD_VAR 0 1
53840: PUSH
53841: LD_INT 101
53843: EQUAL
53844: IFFALSE 53850
// MC_RepairBuildings ( ) ;
53846: CALL 59010 0 0
// if event = 102 then
53850: LD_VAR 0 1
53854: PUSH
53855: LD_INT 102
53857: EQUAL
53858: IFFALSE 53864
// MC_Heal ( ) ;
53860: CALL 59869 0 0
// if event = 103 then
53864: LD_VAR 0 1
53868: PUSH
53869: LD_INT 103
53871: EQUAL
53872: IFFALSE 53878
// MC_Build ( ) ;
53874: CALL 60291 0 0
// if event = 104 then
53878: LD_VAR 0 1
53882: PUSH
53883: LD_INT 104
53885: EQUAL
53886: IFFALSE 53892
// MC_TurretWeapon ( ) ;
53888: CALL 61904 0 0
// if event = 105 then
53892: LD_VAR 0 1
53896: PUSH
53897: LD_INT 105
53899: EQUAL
53900: IFFALSE 53906
// MC_BuildUpgrade ( ) ;
53902: CALL 61455 0 0
// if event = 106 then
53906: LD_VAR 0 1
53910: PUSH
53911: LD_INT 106
53913: EQUAL
53914: IFFALSE 53920
// MC_PlantMines ( ) ;
53916: CALL 62334 0 0
// if event = 107 then
53920: LD_VAR 0 1
53924: PUSH
53925: LD_INT 107
53927: EQUAL
53928: IFFALSE 53934
// MC_CollectCrates ( ) ;
53930: CALL 63132 0 0
// if event = 108 then
53934: LD_VAR 0 1
53938: PUSH
53939: LD_INT 108
53941: EQUAL
53942: IFFALSE 53948
// MC_LinkRemoteControl ( ) ;
53944: CALL 64908 0 0
// if event = 109 then
53948: LD_VAR 0 1
53952: PUSH
53953: LD_INT 109
53955: EQUAL
53956: IFFALSE 53962
// MC_ProduceVehicle ( ) ;
53958: CALL 65089 0 0
// if event = 110 then
53962: LD_VAR 0 1
53966: PUSH
53967: LD_INT 110
53969: EQUAL
53970: IFFALSE 53976
// MC_SendAttack ( ) ;
53972: CALL 65555 0 0
// if event = 111 then
53976: LD_VAR 0 1
53980: PUSH
53981: LD_INT 111
53983: EQUAL
53984: IFFALSE 53990
// MC_Defend ( ) ;
53986: CALL 65663 0 0
// if event = 112 then
53990: LD_VAR 0 1
53994: PUSH
53995: LD_INT 112
53997: EQUAL
53998: IFFALSE 54004
// MC_Research ( ) ;
54000: CALL 66268 0 0
// if event = 113 then
54004: LD_VAR 0 1
54008: PUSH
54009: LD_INT 113
54011: EQUAL
54012: IFFALSE 54018
// MC_MinesTrigger ( ) ;
54014: CALL 67382 0 0
// if event = 120 then
54018: LD_VAR 0 1
54022: PUSH
54023: LD_INT 120
54025: EQUAL
54026: IFFALSE 54032
// MC_RepairVehicle ( ) ;
54028: CALL 67481 0 0
// if event = 121 then
54032: LD_VAR 0 1
54036: PUSH
54037: LD_INT 121
54039: EQUAL
54040: IFFALSE 54046
// MC_TameApe ( ) ;
54042: CALL 68211 0 0
// if event = 122 then
54046: LD_VAR 0 1
54050: PUSH
54051: LD_INT 122
54053: EQUAL
54054: IFFALSE 54060
// MC_ChangeApeClass ( ) ;
54056: CALL 69040 0 0
// if event = 123 then
54060: LD_VAR 0 1
54064: PUSH
54065: LD_INT 123
54067: EQUAL
54068: IFFALSE 54074
// MC_Bazooka ( ) ;
54070: CALL 69690 0 0
// if event = 124 then
54074: LD_VAR 0 1
54078: PUSH
54079: LD_INT 124
54081: EQUAL
54082: IFFALSE 54088
// MC_TeleportExit ( ) ;
54084: CALL 69888 0 0
// if event = 125 then
54088: LD_VAR 0 1
54092: PUSH
54093: LD_INT 125
54095: EQUAL
54096: IFFALSE 54102
// MC_Deposits ( ) ;
54098: CALL 70535 0 0
// if event = 126 then
54102: LD_VAR 0 1
54106: PUSH
54107: LD_INT 126
54109: EQUAL
54110: IFFALSE 54116
// MC_RemoteDriver ( ) ;
54112: CALL 71160 0 0
// if event = 200 then
54116: LD_VAR 0 1
54120: PUSH
54121: LD_INT 200
54123: EQUAL
54124: IFFALSE 54130
// MC_Idle ( ) ;
54126: CALL 73109 0 0
// end ;
54130: PPOPN 1
54132: END
// export function MC_Reset ( base , tag ) ; var i ; begin
54133: LD_INT 0
54135: PPUSH
54136: PPUSH
// if not mc_bases [ base ] or not tag then
54137: LD_EXP 65
54141: PUSH
54142: LD_VAR 0 1
54146: ARRAY
54147: NOT
54148: PUSH
54149: LD_VAR 0 2
54153: NOT
54154: OR
54155: IFFALSE 54159
// exit ;
54157: GO 54223
// for i in mc_bases [ base ] union mc_ape [ base ] do
54159: LD_ADDR_VAR 0 4
54163: PUSH
54164: LD_EXP 65
54168: PUSH
54169: LD_VAR 0 1
54173: ARRAY
54174: PUSH
54175: LD_EXP 94
54179: PUSH
54180: LD_VAR 0 1
54184: ARRAY
54185: UNION
54186: PUSH
54187: FOR_IN
54188: IFFALSE 54221
// if GetTag ( i ) = tag then
54190: LD_VAR 0 4
54194: PPUSH
54195: CALL_OW 110
54199: PUSH
54200: LD_VAR 0 2
54204: EQUAL
54205: IFFALSE 54219
// SetTag ( i , 0 ) ;
54207: LD_VAR 0 4
54211: PPUSH
54212: LD_INT 0
54214: PPUSH
54215: CALL_OW 109
54219: GO 54187
54221: POP
54222: POP
// end ;
54223: LD_VAR 0 3
54227: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
54228: LD_INT 0
54230: PPUSH
54231: PPUSH
54232: PPUSH
54233: PPUSH
54234: PPUSH
54235: PPUSH
54236: PPUSH
54237: PPUSH
// if not mc_bases then
54238: LD_EXP 65
54242: NOT
54243: IFFALSE 54247
// exit ;
54245: GO 54705
// for i = 1 to mc_bases do
54247: LD_ADDR_VAR 0 2
54251: PUSH
54252: DOUBLE
54253: LD_INT 1
54255: DEC
54256: ST_TO_ADDR
54257: LD_EXP 65
54261: PUSH
54262: FOR_TO
54263: IFFALSE 54703
// begin tmp := MC_ClassCheckReq ( i ) ;
54265: LD_ADDR_VAR 0 4
54269: PUSH
54270: LD_VAR 0 2
54274: PPUSH
54275: CALL 54710 0 1
54279: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
54280: LD_ADDR_EXP 106
54284: PUSH
54285: LD_EXP 106
54289: PPUSH
54290: LD_VAR 0 2
54294: PPUSH
54295: LD_VAR 0 4
54299: PPUSH
54300: CALL_OW 1
54304: ST_TO_ADDR
// if not tmp then
54305: LD_VAR 0 4
54309: NOT
54310: IFFALSE 54314
// continue ;
54312: GO 54262
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
54314: LD_ADDR_VAR 0 6
54318: PUSH
54319: LD_EXP 65
54323: PUSH
54324: LD_VAR 0 2
54328: ARRAY
54329: PPUSH
54330: LD_INT 2
54332: PUSH
54333: LD_INT 30
54335: PUSH
54336: LD_INT 4
54338: PUSH
54339: EMPTY
54340: LIST
54341: LIST
54342: PUSH
54343: LD_INT 30
54345: PUSH
54346: LD_INT 5
54348: PUSH
54349: EMPTY
54350: LIST
54351: LIST
54352: PUSH
54353: EMPTY
54354: LIST
54355: LIST
54356: LIST
54357: PPUSH
54358: CALL_OW 72
54362: PUSH
54363: LD_EXP 65
54367: PUSH
54368: LD_VAR 0 2
54372: ARRAY
54373: PPUSH
54374: LD_INT 2
54376: PUSH
54377: LD_INT 30
54379: PUSH
54380: LD_INT 0
54382: PUSH
54383: EMPTY
54384: LIST
54385: LIST
54386: PUSH
54387: LD_INT 30
54389: PUSH
54390: LD_INT 1
54392: PUSH
54393: EMPTY
54394: LIST
54395: LIST
54396: PUSH
54397: EMPTY
54398: LIST
54399: LIST
54400: LIST
54401: PPUSH
54402: CALL_OW 72
54406: PUSH
54407: LD_EXP 65
54411: PUSH
54412: LD_VAR 0 2
54416: ARRAY
54417: PPUSH
54418: LD_INT 30
54420: PUSH
54421: LD_INT 3
54423: PUSH
54424: EMPTY
54425: LIST
54426: LIST
54427: PPUSH
54428: CALL_OW 72
54432: PUSH
54433: LD_EXP 65
54437: PUSH
54438: LD_VAR 0 2
54442: ARRAY
54443: PPUSH
54444: LD_INT 2
54446: PUSH
54447: LD_INT 30
54449: PUSH
54450: LD_INT 6
54452: PUSH
54453: EMPTY
54454: LIST
54455: LIST
54456: PUSH
54457: LD_INT 30
54459: PUSH
54460: LD_INT 7
54462: PUSH
54463: EMPTY
54464: LIST
54465: LIST
54466: PUSH
54467: LD_INT 30
54469: PUSH
54470: LD_INT 8
54472: PUSH
54473: EMPTY
54474: LIST
54475: LIST
54476: PUSH
54477: EMPTY
54478: LIST
54479: LIST
54480: LIST
54481: LIST
54482: PPUSH
54483: CALL_OW 72
54487: PUSH
54488: EMPTY
54489: LIST
54490: LIST
54491: LIST
54492: LIST
54493: ST_TO_ADDR
// for j = 1 to 4 do
54494: LD_ADDR_VAR 0 3
54498: PUSH
54499: DOUBLE
54500: LD_INT 1
54502: DEC
54503: ST_TO_ADDR
54504: LD_INT 4
54506: PUSH
54507: FOR_TO
54508: IFFALSE 54699
// begin if not tmp [ j ] then
54510: LD_VAR 0 4
54514: PUSH
54515: LD_VAR 0 3
54519: ARRAY
54520: NOT
54521: IFFALSE 54525
// continue ;
54523: GO 54507
// for p in tmp [ j ] do
54525: LD_ADDR_VAR 0 5
54529: PUSH
54530: LD_VAR 0 4
54534: PUSH
54535: LD_VAR 0 3
54539: ARRAY
54540: PUSH
54541: FOR_IN
54542: IFFALSE 54695
// begin if not b [ j ] then
54544: LD_VAR 0 6
54548: PUSH
54549: LD_VAR 0 3
54553: ARRAY
54554: NOT
54555: IFFALSE 54559
// break ;
54557: GO 54695
// e := 0 ;
54559: LD_ADDR_VAR 0 7
54563: PUSH
54564: LD_INT 0
54566: ST_TO_ADDR
// for k in b [ j ] do
54567: LD_ADDR_VAR 0 8
54571: PUSH
54572: LD_VAR 0 6
54576: PUSH
54577: LD_VAR 0 3
54581: ARRAY
54582: PUSH
54583: FOR_IN
54584: IFFALSE 54611
// if IsNotFull ( k ) then
54586: LD_VAR 0 8
54590: PPUSH
54591: CALL 15770 0 1
54595: IFFALSE 54609
// begin e := k ;
54597: LD_ADDR_VAR 0 7
54601: PUSH
54602: LD_VAR 0 8
54606: ST_TO_ADDR
// break ;
54607: GO 54611
// end ;
54609: GO 54583
54611: POP
54612: POP
// if e and not UnitGoingToBuilding ( p , e ) then
54613: LD_VAR 0 7
54617: PUSH
54618: LD_VAR 0 5
54622: PPUSH
54623: LD_VAR 0 7
54627: PPUSH
54628: CALL 48190 0 2
54632: NOT
54633: AND
54634: IFFALSE 54693
// begin if IsInUnit ( p ) then
54636: LD_VAR 0 5
54640: PPUSH
54641: CALL_OW 310
54645: IFFALSE 54656
// ComExitBuilding ( p ) ;
54647: LD_VAR 0 5
54651: PPUSH
54652: CALL_OW 122
// ComEnterUnit ( p , e ) ;
54656: LD_VAR 0 5
54660: PPUSH
54661: LD_VAR 0 7
54665: PPUSH
54666: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
54670: LD_VAR 0 5
54674: PPUSH
54675: LD_VAR 0 3
54679: PPUSH
54680: CALL_OW 183
// AddComExitBuilding ( p ) ;
54684: LD_VAR 0 5
54688: PPUSH
54689: CALL_OW 182
// end ; end ;
54693: GO 54541
54695: POP
54696: POP
// end ;
54697: GO 54507
54699: POP
54700: POP
// end ;
54701: GO 54262
54703: POP
54704: POP
// end ;
54705: LD_VAR 0 1
54709: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
54710: LD_INT 0
54712: PPUSH
54713: PPUSH
54714: PPUSH
54715: PPUSH
54716: PPUSH
54717: PPUSH
54718: PPUSH
54719: PPUSH
54720: PPUSH
54721: PPUSH
54722: PPUSH
54723: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54724: LD_VAR 0 1
54728: NOT
54729: PUSH
54730: LD_EXP 65
54734: PUSH
54735: LD_VAR 0 1
54739: ARRAY
54740: NOT
54741: OR
54742: PUSH
54743: LD_EXP 65
54747: PUSH
54748: LD_VAR 0 1
54752: ARRAY
54753: PPUSH
54754: LD_INT 2
54756: PUSH
54757: LD_INT 30
54759: PUSH
54760: LD_INT 0
54762: PUSH
54763: EMPTY
54764: LIST
54765: LIST
54766: PUSH
54767: LD_INT 30
54769: PUSH
54770: LD_INT 1
54772: PUSH
54773: EMPTY
54774: LIST
54775: LIST
54776: PUSH
54777: EMPTY
54778: LIST
54779: LIST
54780: LIST
54781: PPUSH
54782: CALL_OW 72
54786: NOT
54787: OR
54788: IFFALSE 54792
// exit ;
54790: GO 58295
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54792: LD_ADDR_VAR 0 4
54796: PUSH
54797: LD_EXP 65
54801: PUSH
54802: LD_VAR 0 1
54806: ARRAY
54807: PPUSH
54808: LD_INT 2
54810: PUSH
54811: LD_INT 25
54813: PUSH
54814: LD_INT 1
54816: PUSH
54817: EMPTY
54818: LIST
54819: LIST
54820: PUSH
54821: LD_INT 25
54823: PUSH
54824: LD_INT 2
54826: PUSH
54827: EMPTY
54828: LIST
54829: LIST
54830: PUSH
54831: LD_INT 25
54833: PUSH
54834: LD_INT 3
54836: PUSH
54837: EMPTY
54838: LIST
54839: LIST
54840: PUSH
54841: LD_INT 25
54843: PUSH
54844: LD_INT 4
54846: PUSH
54847: EMPTY
54848: LIST
54849: LIST
54850: PUSH
54851: LD_INT 25
54853: PUSH
54854: LD_INT 5
54856: PUSH
54857: EMPTY
54858: LIST
54859: LIST
54860: PUSH
54861: LD_INT 25
54863: PUSH
54864: LD_INT 8
54866: PUSH
54867: EMPTY
54868: LIST
54869: LIST
54870: PUSH
54871: LD_INT 25
54873: PUSH
54874: LD_INT 9
54876: PUSH
54877: EMPTY
54878: LIST
54879: LIST
54880: PUSH
54881: EMPTY
54882: LIST
54883: LIST
54884: LIST
54885: LIST
54886: LIST
54887: LIST
54888: LIST
54889: LIST
54890: PPUSH
54891: CALL_OW 72
54895: ST_TO_ADDR
// if not tmp then
54896: LD_VAR 0 4
54900: NOT
54901: IFFALSE 54905
// exit ;
54903: GO 58295
// for i in tmp do
54905: LD_ADDR_VAR 0 3
54909: PUSH
54910: LD_VAR 0 4
54914: PUSH
54915: FOR_IN
54916: IFFALSE 54947
// if GetTag ( i ) then
54918: LD_VAR 0 3
54922: PPUSH
54923: CALL_OW 110
54927: IFFALSE 54945
// tmp := tmp diff i ;
54929: LD_ADDR_VAR 0 4
54933: PUSH
54934: LD_VAR 0 4
54938: PUSH
54939: LD_VAR 0 3
54943: DIFF
54944: ST_TO_ADDR
54945: GO 54915
54947: POP
54948: POP
// if not tmp then
54949: LD_VAR 0 4
54953: NOT
54954: IFFALSE 54958
// exit ;
54956: GO 58295
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54958: LD_ADDR_VAR 0 5
54962: PUSH
54963: LD_EXP 65
54967: PUSH
54968: LD_VAR 0 1
54972: ARRAY
54973: PPUSH
54974: LD_INT 2
54976: PUSH
54977: LD_INT 25
54979: PUSH
54980: LD_INT 1
54982: PUSH
54983: EMPTY
54984: LIST
54985: LIST
54986: PUSH
54987: LD_INT 25
54989: PUSH
54990: LD_INT 5
54992: PUSH
54993: EMPTY
54994: LIST
54995: LIST
54996: PUSH
54997: LD_INT 25
54999: PUSH
55000: LD_INT 8
55002: PUSH
55003: EMPTY
55004: LIST
55005: LIST
55006: PUSH
55007: LD_INT 25
55009: PUSH
55010: LD_INT 9
55012: PUSH
55013: EMPTY
55014: LIST
55015: LIST
55016: PUSH
55017: EMPTY
55018: LIST
55019: LIST
55020: LIST
55021: LIST
55022: LIST
55023: PPUSH
55024: CALL_OW 72
55028: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
55029: LD_ADDR_VAR 0 6
55033: PUSH
55034: LD_EXP 65
55038: PUSH
55039: LD_VAR 0 1
55043: ARRAY
55044: PPUSH
55045: LD_INT 25
55047: PUSH
55048: LD_INT 2
55050: PUSH
55051: EMPTY
55052: LIST
55053: LIST
55054: PPUSH
55055: CALL_OW 72
55059: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
55060: LD_ADDR_VAR 0 7
55064: PUSH
55065: LD_EXP 65
55069: PUSH
55070: LD_VAR 0 1
55074: ARRAY
55075: PPUSH
55076: LD_INT 25
55078: PUSH
55079: LD_INT 3
55081: PUSH
55082: EMPTY
55083: LIST
55084: LIST
55085: PPUSH
55086: CALL_OW 72
55090: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
55091: LD_ADDR_VAR 0 8
55095: PUSH
55096: LD_EXP 65
55100: PUSH
55101: LD_VAR 0 1
55105: ARRAY
55106: PPUSH
55107: LD_INT 25
55109: PUSH
55110: LD_INT 4
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: PUSH
55117: LD_INT 24
55119: PUSH
55120: LD_INT 251
55122: PUSH
55123: EMPTY
55124: LIST
55125: LIST
55126: PUSH
55127: EMPTY
55128: LIST
55129: LIST
55130: PPUSH
55131: CALL_OW 72
55135: ST_TO_ADDR
// if mc_scan [ base ] then
55136: LD_EXP 88
55140: PUSH
55141: LD_VAR 0 1
55145: ARRAY
55146: IFFALSE 55607
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
55148: LD_ADDR_EXP 107
55152: PUSH
55153: LD_EXP 107
55157: PPUSH
55158: LD_VAR 0 1
55162: PPUSH
55163: LD_INT 4
55165: PPUSH
55166: CALL_OW 1
55170: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55171: LD_ADDR_VAR 0 12
55175: PUSH
55176: LD_EXP 65
55180: PUSH
55181: LD_VAR 0 1
55185: ARRAY
55186: PPUSH
55187: LD_INT 2
55189: PUSH
55190: LD_INT 30
55192: PUSH
55193: LD_INT 4
55195: PUSH
55196: EMPTY
55197: LIST
55198: LIST
55199: PUSH
55200: LD_INT 30
55202: PUSH
55203: LD_INT 5
55205: PUSH
55206: EMPTY
55207: LIST
55208: LIST
55209: PUSH
55210: EMPTY
55211: LIST
55212: LIST
55213: LIST
55214: PPUSH
55215: CALL_OW 72
55219: ST_TO_ADDR
// if not b then
55220: LD_VAR 0 12
55224: NOT
55225: IFFALSE 55229
// exit ;
55227: GO 58295
// p := [ ] ;
55229: LD_ADDR_VAR 0 11
55233: PUSH
55234: EMPTY
55235: ST_TO_ADDR
// if sci >= 2 then
55236: LD_VAR 0 8
55240: PUSH
55241: LD_INT 2
55243: GREATEREQUAL
55244: IFFALSE 55275
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
55246: LD_ADDR_VAR 0 8
55250: PUSH
55251: LD_VAR 0 8
55255: PUSH
55256: LD_INT 1
55258: ARRAY
55259: PUSH
55260: LD_VAR 0 8
55264: PUSH
55265: LD_INT 2
55267: ARRAY
55268: PUSH
55269: EMPTY
55270: LIST
55271: LIST
55272: ST_TO_ADDR
55273: GO 55336
// if sci = 1 then
55275: LD_VAR 0 8
55279: PUSH
55280: LD_INT 1
55282: EQUAL
55283: IFFALSE 55304
// sci := [ sci [ 1 ] ] else
55285: LD_ADDR_VAR 0 8
55289: PUSH
55290: LD_VAR 0 8
55294: PUSH
55295: LD_INT 1
55297: ARRAY
55298: PUSH
55299: EMPTY
55300: LIST
55301: ST_TO_ADDR
55302: GO 55336
// if sci = 0 then
55304: LD_VAR 0 8
55308: PUSH
55309: LD_INT 0
55311: EQUAL
55312: IFFALSE 55336
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
55314: LD_ADDR_VAR 0 11
55318: PUSH
55319: LD_VAR 0 4
55323: PPUSH
55324: LD_INT 4
55326: PPUSH
55327: CALL 48053 0 2
55331: PUSH
55332: LD_INT 1
55334: ARRAY
55335: ST_TO_ADDR
// if eng > 4 then
55336: LD_VAR 0 6
55340: PUSH
55341: LD_INT 4
55343: GREATER
55344: IFFALSE 55390
// for i = eng downto 4 do
55346: LD_ADDR_VAR 0 3
55350: PUSH
55351: DOUBLE
55352: LD_VAR 0 6
55356: INC
55357: ST_TO_ADDR
55358: LD_INT 4
55360: PUSH
55361: FOR_DOWNTO
55362: IFFALSE 55388
// eng := eng diff eng [ i ] ;
55364: LD_ADDR_VAR 0 6
55368: PUSH
55369: LD_VAR 0 6
55373: PUSH
55374: LD_VAR 0 6
55378: PUSH
55379: LD_VAR 0 3
55383: ARRAY
55384: DIFF
55385: ST_TO_ADDR
55386: GO 55361
55388: POP
55389: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
55390: LD_ADDR_VAR 0 4
55394: PUSH
55395: LD_VAR 0 4
55399: PUSH
55400: LD_VAR 0 5
55404: PUSH
55405: LD_VAR 0 6
55409: UNION
55410: PUSH
55411: LD_VAR 0 7
55415: UNION
55416: PUSH
55417: LD_VAR 0 8
55421: UNION
55422: DIFF
55423: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
55424: LD_ADDR_VAR 0 13
55428: PUSH
55429: LD_EXP 65
55433: PUSH
55434: LD_VAR 0 1
55438: ARRAY
55439: PPUSH
55440: LD_INT 2
55442: PUSH
55443: LD_INT 30
55445: PUSH
55446: LD_INT 32
55448: PUSH
55449: EMPTY
55450: LIST
55451: LIST
55452: PUSH
55453: LD_INT 30
55455: PUSH
55456: LD_INT 31
55458: PUSH
55459: EMPTY
55460: LIST
55461: LIST
55462: PUSH
55463: EMPTY
55464: LIST
55465: LIST
55466: LIST
55467: PPUSH
55468: CALL_OW 72
55472: PUSH
55473: LD_EXP 65
55477: PUSH
55478: LD_VAR 0 1
55482: ARRAY
55483: PPUSH
55484: LD_INT 2
55486: PUSH
55487: LD_INT 30
55489: PUSH
55490: LD_INT 4
55492: PUSH
55493: EMPTY
55494: LIST
55495: LIST
55496: PUSH
55497: LD_INT 30
55499: PUSH
55500: LD_INT 5
55502: PUSH
55503: EMPTY
55504: LIST
55505: LIST
55506: PUSH
55507: EMPTY
55508: LIST
55509: LIST
55510: LIST
55511: PPUSH
55512: CALL_OW 72
55516: PUSH
55517: LD_INT 6
55519: MUL
55520: PLUS
55521: ST_TO_ADDR
// if bcount < tmp then
55522: LD_VAR 0 13
55526: PUSH
55527: LD_VAR 0 4
55531: LESS
55532: IFFALSE 55578
// for i = tmp downto bcount do
55534: LD_ADDR_VAR 0 3
55538: PUSH
55539: DOUBLE
55540: LD_VAR 0 4
55544: INC
55545: ST_TO_ADDR
55546: LD_VAR 0 13
55550: PUSH
55551: FOR_DOWNTO
55552: IFFALSE 55576
// tmp := Delete ( tmp , tmp ) ;
55554: LD_ADDR_VAR 0 4
55558: PUSH
55559: LD_VAR 0 4
55563: PPUSH
55564: LD_VAR 0 4
55568: PPUSH
55569: CALL_OW 3
55573: ST_TO_ADDR
55574: GO 55551
55576: POP
55577: POP
// result := [ tmp , 0 , 0 , p ] ;
55578: LD_ADDR_VAR 0 2
55582: PUSH
55583: LD_VAR 0 4
55587: PUSH
55588: LD_INT 0
55590: PUSH
55591: LD_INT 0
55593: PUSH
55594: LD_VAR 0 11
55598: PUSH
55599: EMPTY
55600: LIST
55601: LIST
55602: LIST
55603: LIST
55604: ST_TO_ADDR
// exit ;
55605: GO 58295
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55607: LD_EXP 65
55611: PUSH
55612: LD_VAR 0 1
55616: ARRAY
55617: PPUSH
55618: LD_INT 2
55620: PUSH
55621: LD_INT 30
55623: PUSH
55624: LD_INT 6
55626: PUSH
55627: EMPTY
55628: LIST
55629: LIST
55630: PUSH
55631: LD_INT 30
55633: PUSH
55634: LD_INT 7
55636: PUSH
55637: EMPTY
55638: LIST
55639: LIST
55640: PUSH
55641: LD_INT 30
55643: PUSH
55644: LD_INT 8
55646: PUSH
55647: EMPTY
55648: LIST
55649: LIST
55650: PUSH
55651: EMPTY
55652: LIST
55653: LIST
55654: LIST
55655: LIST
55656: PPUSH
55657: CALL_OW 72
55661: NOT
55662: PUSH
55663: LD_EXP 65
55667: PUSH
55668: LD_VAR 0 1
55672: ARRAY
55673: PPUSH
55674: LD_INT 30
55676: PUSH
55677: LD_INT 3
55679: PUSH
55680: EMPTY
55681: LIST
55682: LIST
55683: PPUSH
55684: CALL_OW 72
55688: NOT
55689: AND
55690: IFFALSE 55762
// begin if eng = tmp then
55692: LD_VAR 0 6
55696: PUSH
55697: LD_VAR 0 4
55701: EQUAL
55702: IFFALSE 55706
// exit ;
55704: GO 58295
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
55706: LD_ADDR_EXP 107
55710: PUSH
55711: LD_EXP 107
55715: PPUSH
55716: LD_VAR 0 1
55720: PPUSH
55721: LD_INT 1
55723: PPUSH
55724: CALL_OW 1
55728: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
55729: LD_ADDR_VAR 0 2
55733: PUSH
55734: LD_INT 0
55736: PUSH
55737: LD_VAR 0 4
55741: PUSH
55742: LD_VAR 0 6
55746: DIFF
55747: PUSH
55748: LD_INT 0
55750: PUSH
55751: LD_INT 0
55753: PUSH
55754: EMPTY
55755: LIST
55756: LIST
55757: LIST
55758: LIST
55759: ST_TO_ADDR
// exit ;
55760: GO 58295
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55762: LD_EXP 92
55766: PUSH
55767: LD_EXP 91
55771: PUSH
55772: LD_VAR 0 1
55776: ARRAY
55777: ARRAY
55778: PUSH
55779: LD_EXP 65
55783: PUSH
55784: LD_VAR 0 1
55788: ARRAY
55789: PPUSH
55790: LD_INT 2
55792: PUSH
55793: LD_INT 30
55795: PUSH
55796: LD_INT 6
55798: PUSH
55799: EMPTY
55800: LIST
55801: LIST
55802: PUSH
55803: LD_INT 30
55805: PUSH
55806: LD_INT 7
55808: PUSH
55809: EMPTY
55810: LIST
55811: LIST
55812: PUSH
55813: LD_INT 30
55815: PUSH
55816: LD_INT 8
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: PUSH
55823: EMPTY
55824: LIST
55825: LIST
55826: LIST
55827: LIST
55828: PPUSH
55829: CALL_OW 72
55833: AND
55834: PUSH
55835: LD_EXP 65
55839: PUSH
55840: LD_VAR 0 1
55844: ARRAY
55845: PPUSH
55846: LD_INT 30
55848: PUSH
55849: LD_INT 3
55851: PUSH
55852: EMPTY
55853: LIST
55854: LIST
55855: PPUSH
55856: CALL_OW 72
55860: NOT
55861: AND
55862: IFFALSE 56076
// begin if sci >= 6 then
55864: LD_VAR 0 8
55868: PUSH
55869: LD_INT 6
55871: GREATEREQUAL
55872: IFFALSE 55876
// exit ;
55874: GO 58295
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
55876: LD_ADDR_EXP 107
55880: PUSH
55881: LD_EXP 107
55885: PPUSH
55886: LD_VAR 0 1
55890: PPUSH
55891: LD_INT 2
55893: PPUSH
55894: CALL_OW 1
55898: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
55899: LD_ADDR_VAR 0 9
55903: PUSH
55904: LD_VAR 0 4
55908: PUSH
55909: LD_VAR 0 8
55913: DIFF
55914: PPUSH
55915: LD_INT 4
55917: PPUSH
55918: CALL 48053 0 2
55922: ST_TO_ADDR
// p := [ ] ;
55923: LD_ADDR_VAR 0 11
55927: PUSH
55928: EMPTY
55929: ST_TO_ADDR
// if sci < 6 and sort > 6 then
55930: LD_VAR 0 8
55934: PUSH
55935: LD_INT 6
55937: LESS
55938: PUSH
55939: LD_VAR 0 9
55943: PUSH
55944: LD_INT 6
55946: GREATER
55947: AND
55948: IFFALSE 56029
// begin for i = 1 to 6 - sci do
55950: LD_ADDR_VAR 0 3
55954: PUSH
55955: DOUBLE
55956: LD_INT 1
55958: DEC
55959: ST_TO_ADDR
55960: LD_INT 6
55962: PUSH
55963: LD_VAR 0 8
55967: MINUS
55968: PUSH
55969: FOR_TO
55970: IFFALSE 56025
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
55972: LD_ADDR_VAR 0 11
55976: PUSH
55977: LD_VAR 0 11
55981: PPUSH
55982: LD_VAR 0 11
55986: PUSH
55987: LD_INT 1
55989: PLUS
55990: PPUSH
55991: LD_VAR 0 9
55995: PUSH
55996: LD_INT 1
55998: ARRAY
55999: PPUSH
56000: CALL_OW 2
56004: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
56005: LD_ADDR_VAR 0 9
56009: PUSH
56010: LD_VAR 0 9
56014: PPUSH
56015: LD_INT 1
56017: PPUSH
56018: CALL_OW 3
56022: ST_TO_ADDR
// end ;
56023: GO 55969
56025: POP
56026: POP
// end else
56027: GO 56049
// if sort then
56029: LD_VAR 0 9
56033: IFFALSE 56049
// p := sort [ 1 ] ;
56035: LD_ADDR_VAR 0 11
56039: PUSH
56040: LD_VAR 0 9
56044: PUSH
56045: LD_INT 1
56047: ARRAY
56048: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
56049: LD_ADDR_VAR 0 2
56053: PUSH
56054: LD_INT 0
56056: PUSH
56057: LD_INT 0
56059: PUSH
56060: LD_INT 0
56062: PUSH
56063: LD_VAR 0 11
56067: PUSH
56068: EMPTY
56069: LIST
56070: LIST
56071: LIST
56072: LIST
56073: ST_TO_ADDR
// exit ;
56074: GO 58295
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56076: LD_EXP 92
56080: PUSH
56081: LD_EXP 91
56085: PUSH
56086: LD_VAR 0 1
56090: ARRAY
56091: ARRAY
56092: PUSH
56093: LD_EXP 65
56097: PUSH
56098: LD_VAR 0 1
56102: ARRAY
56103: PPUSH
56104: LD_INT 2
56106: PUSH
56107: LD_INT 30
56109: PUSH
56110: LD_INT 6
56112: PUSH
56113: EMPTY
56114: LIST
56115: LIST
56116: PUSH
56117: LD_INT 30
56119: PUSH
56120: LD_INT 7
56122: PUSH
56123: EMPTY
56124: LIST
56125: LIST
56126: PUSH
56127: LD_INT 30
56129: PUSH
56130: LD_INT 8
56132: PUSH
56133: EMPTY
56134: LIST
56135: LIST
56136: PUSH
56137: EMPTY
56138: LIST
56139: LIST
56140: LIST
56141: LIST
56142: PPUSH
56143: CALL_OW 72
56147: AND
56148: PUSH
56149: LD_EXP 65
56153: PUSH
56154: LD_VAR 0 1
56158: ARRAY
56159: PPUSH
56160: LD_INT 30
56162: PUSH
56163: LD_INT 3
56165: PUSH
56166: EMPTY
56167: LIST
56168: LIST
56169: PPUSH
56170: CALL_OW 72
56174: AND
56175: IFFALSE 56909
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
56177: LD_ADDR_EXP 107
56181: PUSH
56182: LD_EXP 107
56186: PPUSH
56187: LD_VAR 0 1
56191: PPUSH
56192: LD_INT 3
56194: PPUSH
56195: CALL_OW 1
56199: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56200: LD_ADDR_VAR 0 2
56204: PUSH
56205: LD_INT 0
56207: PUSH
56208: LD_INT 0
56210: PUSH
56211: LD_INT 0
56213: PUSH
56214: LD_INT 0
56216: PUSH
56217: EMPTY
56218: LIST
56219: LIST
56220: LIST
56221: LIST
56222: ST_TO_ADDR
// if not eng then
56223: LD_VAR 0 6
56227: NOT
56228: IFFALSE 56291
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
56230: LD_ADDR_VAR 0 11
56234: PUSH
56235: LD_VAR 0 4
56239: PPUSH
56240: LD_INT 2
56242: PPUSH
56243: CALL 48053 0 2
56247: PUSH
56248: LD_INT 1
56250: ARRAY
56251: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
56252: LD_ADDR_VAR 0 2
56256: PUSH
56257: LD_VAR 0 2
56261: PPUSH
56262: LD_INT 2
56264: PPUSH
56265: LD_VAR 0 11
56269: PPUSH
56270: CALL_OW 1
56274: ST_TO_ADDR
// tmp := tmp diff p ;
56275: LD_ADDR_VAR 0 4
56279: PUSH
56280: LD_VAR 0 4
56284: PUSH
56285: LD_VAR 0 11
56289: DIFF
56290: ST_TO_ADDR
// end ; if tmp and sci < 6 then
56291: LD_VAR 0 4
56295: PUSH
56296: LD_VAR 0 8
56300: PUSH
56301: LD_INT 6
56303: LESS
56304: AND
56305: IFFALSE 56493
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
56307: LD_ADDR_VAR 0 9
56311: PUSH
56312: LD_VAR 0 4
56316: PUSH
56317: LD_VAR 0 8
56321: PUSH
56322: LD_VAR 0 7
56326: UNION
56327: DIFF
56328: PPUSH
56329: LD_INT 4
56331: PPUSH
56332: CALL 48053 0 2
56336: ST_TO_ADDR
// p := [ ] ;
56337: LD_ADDR_VAR 0 11
56341: PUSH
56342: EMPTY
56343: ST_TO_ADDR
// if sort then
56344: LD_VAR 0 9
56348: IFFALSE 56464
// for i = 1 to 6 - sci do
56350: LD_ADDR_VAR 0 3
56354: PUSH
56355: DOUBLE
56356: LD_INT 1
56358: DEC
56359: ST_TO_ADDR
56360: LD_INT 6
56362: PUSH
56363: LD_VAR 0 8
56367: MINUS
56368: PUSH
56369: FOR_TO
56370: IFFALSE 56462
// begin if i = sort then
56372: LD_VAR 0 3
56376: PUSH
56377: LD_VAR 0 9
56381: EQUAL
56382: IFFALSE 56386
// break ;
56384: GO 56462
// if GetClass ( i ) = 4 then
56386: LD_VAR 0 3
56390: PPUSH
56391: CALL_OW 257
56395: PUSH
56396: LD_INT 4
56398: EQUAL
56399: IFFALSE 56403
// continue ;
56401: GO 56369
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56403: LD_ADDR_VAR 0 11
56407: PUSH
56408: LD_VAR 0 11
56412: PPUSH
56413: LD_VAR 0 11
56417: PUSH
56418: LD_INT 1
56420: PLUS
56421: PPUSH
56422: LD_VAR 0 9
56426: PUSH
56427: LD_VAR 0 3
56431: ARRAY
56432: PPUSH
56433: CALL_OW 2
56437: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56438: LD_ADDR_VAR 0 4
56442: PUSH
56443: LD_VAR 0 4
56447: PUSH
56448: LD_VAR 0 9
56452: PUSH
56453: LD_VAR 0 3
56457: ARRAY
56458: DIFF
56459: ST_TO_ADDR
// end ;
56460: GO 56369
56462: POP
56463: POP
// if p then
56464: LD_VAR 0 11
56468: IFFALSE 56493
// result := Replace ( result , 4 , p ) ;
56470: LD_ADDR_VAR 0 2
56474: PUSH
56475: LD_VAR 0 2
56479: PPUSH
56480: LD_INT 4
56482: PPUSH
56483: LD_VAR 0 11
56487: PPUSH
56488: CALL_OW 1
56492: ST_TO_ADDR
// end ; if tmp and mech < 6 then
56493: LD_VAR 0 4
56497: PUSH
56498: LD_VAR 0 7
56502: PUSH
56503: LD_INT 6
56505: LESS
56506: AND
56507: IFFALSE 56695
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
56509: LD_ADDR_VAR 0 9
56513: PUSH
56514: LD_VAR 0 4
56518: PUSH
56519: LD_VAR 0 8
56523: PUSH
56524: LD_VAR 0 7
56528: UNION
56529: DIFF
56530: PPUSH
56531: LD_INT 3
56533: PPUSH
56534: CALL 48053 0 2
56538: ST_TO_ADDR
// p := [ ] ;
56539: LD_ADDR_VAR 0 11
56543: PUSH
56544: EMPTY
56545: ST_TO_ADDR
// if sort then
56546: LD_VAR 0 9
56550: IFFALSE 56666
// for i = 1 to 6 - mech do
56552: LD_ADDR_VAR 0 3
56556: PUSH
56557: DOUBLE
56558: LD_INT 1
56560: DEC
56561: ST_TO_ADDR
56562: LD_INT 6
56564: PUSH
56565: LD_VAR 0 7
56569: MINUS
56570: PUSH
56571: FOR_TO
56572: IFFALSE 56664
// begin if i = sort then
56574: LD_VAR 0 3
56578: PUSH
56579: LD_VAR 0 9
56583: EQUAL
56584: IFFALSE 56588
// break ;
56586: GO 56664
// if GetClass ( i ) = 3 then
56588: LD_VAR 0 3
56592: PPUSH
56593: CALL_OW 257
56597: PUSH
56598: LD_INT 3
56600: EQUAL
56601: IFFALSE 56605
// continue ;
56603: GO 56571
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56605: LD_ADDR_VAR 0 11
56609: PUSH
56610: LD_VAR 0 11
56614: PPUSH
56615: LD_VAR 0 11
56619: PUSH
56620: LD_INT 1
56622: PLUS
56623: PPUSH
56624: LD_VAR 0 9
56628: PUSH
56629: LD_VAR 0 3
56633: ARRAY
56634: PPUSH
56635: CALL_OW 2
56639: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56640: LD_ADDR_VAR 0 4
56644: PUSH
56645: LD_VAR 0 4
56649: PUSH
56650: LD_VAR 0 9
56654: PUSH
56655: LD_VAR 0 3
56659: ARRAY
56660: DIFF
56661: ST_TO_ADDR
// end ;
56662: GO 56571
56664: POP
56665: POP
// if p then
56666: LD_VAR 0 11
56670: IFFALSE 56695
// result := Replace ( result , 3 , p ) ;
56672: LD_ADDR_VAR 0 2
56676: PUSH
56677: LD_VAR 0 2
56681: PPUSH
56682: LD_INT 3
56684: PPUSH
56685: LD_VAR 0 11
56689: PPUSH
56690: CALL_OW 1
56694: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
56695: LD_VAR 0 4
56699: PUSH
56700: LD_INT 6
56702: GREATER
56703: PUSH
56704: LD_VAR 0 6
56708: PUSH
56709: LD_INT 6
56711: LESS
56712: AND
56713: IFFALSE 56907
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
56715: LD_ADDR_VAR 0 9
56719: PUSH
56720: LD_VAR 0 4
56724: PUSH
56725: LD_VAR 0 8
56729: PUSH
56730: LD_VAR 0 7
56734: UNION
56735: PUSH
56736: LD_VAR 0 6
56740: UNION
56741: DIFF
56742: PPUSH
56743: LD_INT 2
56745: PPUSH
56746: CALL 48053 0 2
56750: ST_TO_ADDR
// p := [ ] ;
56751: LD_ADDR_VAR 0 11
56755: PUSH
56756: EMPTY
56757: ST_TO_ADDR
// if sort then
56758: LD_VAR 0 9
56762: IFFALSE 56878
// for i = 1 to 6 - eng do
56764: LD_ADDR_VAR 0 3
56768: PUSH
56769: DOUBLE
56770: LD_INT 1
56772: DEC
56773: ST_TO_ADDR
56774: LD_INT 6
56776: PUSH
56777: LD_VAR 0 6
56781: MINUS
56782: PUSH
56783: FOR_TO
56784: IFFALSE 56876
// begin if i = sort then
56786: LD_VAR 0 3
56790: PUSH
56791: LD_VAR 0 9
56795: EQUAL
56796: IFFALSE 56800
// break ;
56798: GO 56876
// if GetClass ( i ) = 2 then
56800: LD_VAR 0 3
56804: PPUSH
56805: CALL_OW 257
56809: PUSH
56810: LD_INT 2
56812: EQUAL
56813: IFFALSE 56817
// continue ;
56815: GO 56783
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56817: LD_ADDR_VAR 0 11
56821: PUSH
56822: LD_VAR 0 11
56826: PPUSH
56827: LD_VAR 0 11
56831: PUSH
56832: LD_INT 1
56834: PLUS
56835: PPUSH
56836: LD_VAR 0 9
56840: PUSH
56841: LD_VAR 0 3
56845: ARRAY
56846: PPUSH
56847: CALL_OW 2
56851: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56852: LD_ADDR_VAR 0 4
56856: PUSH
56857: LD_VAR 0 4
56861: PUSH
56862: LD_VAR 0 9
56866: PUSH
56867: LD_VAR 0 3
56871: ARRAY
56872: DIFF
56873: ST_TO_ADDR
// end ;
56874: GO 56783
56876: POP
56877: POP
// if p then
56878: LD_VAR 0 11
56882: IFFALSE 56907
// result := Replace ( result , 2 , p ) ;
56884: LD_ADDR_VAR 0 2
56888: PUSH
56889: LD_VAR 0 2
56893: PPUSH
56894: LD_INT 2
56896: PPUSH
56897: LD_VAR 0 11
56901: PPUSH
56902: CALL_OW 1
56906: ST_TO_ADDR
// end ; exit ;
56907: GO 58295
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
56909: LD_EXP 92
56913: PUSH
56914: LD_EXP 91
56918: PUSH
56919: LD_VAR 0 1
56923: ARRAY
56924: ARRAY
56925: NOT
56926: PUSH
56927: LD_EXP 65
56931: PUSH
56932: LD_VAR 0 1
56936: ARRAY
56937: PPUSH
56938: LD_INT 30
56940: PUSH
56941: LD_INT 3
56943: PUSH
56944: EMPTY
56945: LIST
56946: LIST
56947: PPUSH
56948: CALL_OW 72
56952: AND
56953: PUSH
56954: LD_EXP 70
56958: PUSH
56959: LD_VAR 0 1
56963: ARRAY
56964: AND
56965: IFFALSE 57573
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
56967: LD_ADDR_EXP 107
56971: PUSH
56972: LD_EXP 107
56976: PPUSH
56977: LD_VAR 0 1
56981: PPUSH
56982: LD_INT 5
56984: PPUSH
56985: CALL_OW 1
56989: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56990: LD_ADDR_VAR 0 2
56994: PUSH
56995: LD_INT 0
56997: PUSH
56998: LD_INT 0
57000: PUSH
57001: LD_INT 0
57003: PUSH
57004: LD_INT 0
57006: PUSH
57007: EMPTY
57008: LIST
57009: LIST
57010: LIST
57011: LIST
57012: ST_TO_ADDR
// if sci > 1 then
57013: LD_VAR 0 8
57017: PUSH
57018: LD_INT 1
57020: GREATER
57021: IFFALSE 57049
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
57023: LD_ADDR_VAR 0 4
57027: PUSH
57028: LD_VAR 0 4
57032: PUSH
57033: LD_VAR 0 8
57037: PUSH
57038: LD_VAR 0 8
57042: PUSH
57043: LD_INT 1
57045: ARRAY
57046: DIFF
57047: DIFF
57048: ST_TO_ADDR
// if tmp and not sci then
57049: LD_VAR 0 4
57053: PUSH
57054: LD_VAR 0 8
57058: NOT
57059: AND
57060: IFFALSE 57129
// begin sort := SortBySkill ( tmp , 4 ) ;
57062: LD_ADDR_VAR 0 9
57066: PUSH
57067: LD_VAR 0 4
57071: PPUSH
57072: LD_INT 4
57074: PPUSH
57075: CALL 48053 0 2
57079: ST_TO_ADDR
// if sort then
57080: LD_VAR 0 9
57084: IFFALSE 57100
// p := sort [ 1 ] ;
57086: LD_ADDR_VAR 0 11
57090: PUSH
57091: LD_VAR 0 9
57095: PUSH
57096: LD_INT 1
57098: ARRAY
57099: ST_TO_ADDR
// if p then
57100: LD_VAR 0 11
57104: IFFALSE 57129
// result := Replace ( result , 4 , p ) ;
57106: LD_ADDR_VAR 0 2
57110: PUSH
57111: LD_VAR 0 2
57115: PPUSH
57116: LD_INT 4
57118: PPUSH
57119: LD_VAR 0 11
57123: PPUSH
57124: CALL_OW 1
57128: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57129: LD_ADDR_VAR 0 4
57133: PUSH
57134: LD_VAR 0 4
57138: PUSH
57139: LD_VAR 0 7
57143: DIFF
57144: ST_TO_ADDR
// if tmp and mech < 6 then
57145: LD_VAR 0 4
57149: PUSH
57150: LD_VAR 0 7
57154: PUSH
57155: LD_INT 6
57157: LESS
57158: AND
57159: IFFALSE 57347
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57161: LD_ADDR_VAR 0 9
57165: PUSH
57166: LD_VAR 0 4
57170: PUSH
57171: LD_VAR 0 8
57175: PUSH
57176: LD_VAR 0 7
57180: UNION
57181: DIFF
57182: PPUSH
57183: LD_INT 3
57185: PPUSH
57186: CALL 48053 0 2
57190: ST_TO_ADDR
// p := [ ] ;
57191: LD_ADDR_VAR 0 11
57195: PUSH
57196: EMPTY
57197: ST_TO_ADDR
// if sort then
57198: LD_VAR 0 9
57202: IFFALSE 57318
// for i = 1 to 6 - mech do
57204: LD_ADDR_VAR 0 3
57208: PUSH
57209: DOUBLE
57210: LD_INT 1
57212: DEC
57213: ST_TO_ADDR
57214: LD_INT 6
57216: PUSH
57217: LD_VAR 0 7
57221: MINUS
57222: PUSH
57223: FOR_TO
57224: IFFALSE 57316
// begin if i = sort then
57226: LD_VAR 0 3
57230: PUSH
57231: LD_VAR 0 9
57235: EQUAL
57236: IFFALSE 57240
// break ;
57238: GO 57316
// if GetClass ( i ) = 3 then
57240: LD_VAR 0 3
57244: PPUSH
57245: CALL_OW 257
57249: PUSH
57250: LD_INT 3
57252: EQUAL
57253: IFFALSE 57257
// continue ;
57255: GO 57223
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57257: LD_ADDR_VAR 0 11
57261: PUSH
57262: LD_VAR 0 11
57266: PPUSH
57267: LD_VAR 0 11
57271: PUSH
57272: LD_INT 1
57274: PLUS
57275: PPUSH
57276: LD_VAR 0 9
57280: PUSH
57281: LD_VAR 0 3
57285: ARRAY
57286: PPUSH
57287: CALL_OW 2
57291: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57292: LD_ADDR_VAR 0 4
57296: PUSH
57297: LD_VAR 0 4
57301: PUSH
57302: LD_VAR 0 9
57306: PUSH
57307: LD_VAR 0 3
57311: ARRAY
57312: DIFF
57313: ST_TO_ADDR
// end ;
57314: GO 57223
57316: POP
57317: POP
// if p then
57318: LD_VAR 0 11
57322: IFFALSE 57347
// result := Replace ( result , 3 , p ) ;
57324: LD_ADDR_VAR 0 2
57328: PUSH
57329: LD_VAR 0 2
57333: PPUSH
57334: LD_INT 3
57336: PPUSH
57337: LD_VAR 0 11
57341: PPUSH
57342: CALL_OW 1
57346: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
57347: LD_ADDR_VAR 0 4
57351: PUSH
57352: LD_VAR 0 4
57356: PUSH
57357: LD_VAR 0 6
57361: DIFF
57362: ST_TO_ADDR
// if tmp and eng < 6 then
57363: LD_VAR 0 4
57367: PUSH
57368: LD_VAR 0 6
57372: PUSH
57373: LD_INT 6
57375: LESS
57376: AND
57377: IFFALSE 57571
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57379: LD_ADDR_VAR 0 9
57383: PUSH
57384: LD_VAR 0 4
57388: PUSH
57389: LD_VAR 0 8
57393: PUSH
57394: LD_VAR 0 7
57398: UNION
57399: PUSH
57400: LD_VAR 0 6
57404: UNION
57405: DIFF
57406: PPUSH
57407: LD_INT 2
57409: PPUSH
57410: CALL 48053 0 2
57414: ST_TO_ADDR
// p := [ ] ;
57415: LD_ADDR_VAR 0 11
57419: PUSH
57420: EMPTY
57421: ST_TO_ADDR
// if sort then
57422: LD_VAR 0 9
57426: IFFALSE 57542
// for i = 1 to 6 - eng do
57428: LD_ADDR_VAR 0 3
57432: PUSH
57433: DOUBLE
57434: LD_INT 1
57436: DEC
57437: ST_TO_ADDR
57438: LD_INT 6
57440: PUSH
57441: LD_VAR 0 6
57445: MINUS
57446: PUSH
57447: FOR_TO
57448: IFFALSE 57540
// begin if i = sort then
57450: LD_VAR 0 3
57454: PUSH
57455: LD_VAR 0 9
57459: EQUAL
57460: IFFALSE 57464
// break ;
57462: GO 57540
// if GetClass ( i ) = 2 then
57464: LD_VAR 0 3
57468: PPUSH
57469: CALL_OW 257
57473: PUSH
57474: LD_INT 2
57476: EQUAL
57477: IFFALSE 57481
// continue ;
57479: GO 57447
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57481: LD_ADDR_VAR 0 11
57485: PUSH
57486: LD_VAR 0 11
57490: PPUSH
57491: LD_VAR 0 11
57495: PUSH
57496: LD_INT 1
57498: PLUS
57499: PPUSH
57500: LD_VAR 0 9
57504: PUSH
57505: LD_VAR 0 3
57509: ARRAY
57510: PPUSH
57511: CALL_OW 2
57515: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57516: LD_ADDR_VAR 0 4
57520: PUSH
57521: LD_VAR 0 4
57525: PUSH
57526: LD_VAR 0 9
57530: PUSH
57531: LD_VAR 0 3
57535: ARRAY
57536: DIFF
57537: ST_TO_ADDR
// end ;
57538: GO 57447
57540: POP
57541: POP
// if p then
57542: LD_VAR 0 11
57546: IFFALSE 57571
// result := Replace ( result , 2 , p ) ;
57548: LD_ADDR_VAR 0 2
57552: PUSH
57553: LD_VAR 0 2
57557: PPUSH
57558: LD_INT 2
57560: PPUSH
57561: LD_VAR 0 11
57565: PPUSH
57566: CALL_OW 1
57570: ST_TO_ADDR
// end ; exit ;
57571: GO 58295
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
57573: LD_EXP 92
57577: PUSH
57578: LD_EXP 91
57582: PUSH
57583: LD_VAR 0 1
57587: ARRAY
57588: ARRAY
57589: NOT
57590: PUSH
57591: LD_EXP 65
57595: PUSH
57596: LD_VAR 0 1
57600: ARRAY
57601: PPUSH
57602: LD_INT 30
57604: PUSH
57605: LD_INT 3
57607: PUSH
57608: EMPTY
57609: LIST
57610: LIST
57611: PPUSH
57612: CALL_OW 72
57616: AND
57617: PUSH
57618: LD_EXP 70
57622: PUSH
57623: LD_VAR 0 1
57627: ARRAY
57628: NOT
57629: AND
57630: IFFALSE 58295
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
57632: LD_ADDR_EXP 107
57636: PUSH
57637: LD_EXP 107
57641: PPUSH
57642: LD_VAR 0 1
57646: PPUSH
57647: LD_INT 6
57649: PPUSH
57650: CALL_OW 1
57654: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57655: LD_ADDR_VAR 0 2
57659: PUSH
57660: LD_INT 0
57662: PUSH
57663: LD_INT 0
57665: PUSH
57666: LD_INT 0
57668: PUSH
57669: LD_INT 0
57671: PUSH
57672: EMPTY
57673: LIST
57674: LIST
57675: LIST
57676: LIST
57677: ST_TO_ADDR
// if sci >= 1 then
57678: LD_VAR 0 8
57682: PUSH
57683: LD_INT 1
57685: GREATEREQUAL
57686: IFFALSE 57708
// tmp := tmp diff sci [ 1 ] ;
57688: LD_ADDR_VAR 0 4
57692: PUSH
57693: LD_VAR 0 4
57697: PUSH
57698: LD_VAR 0 8
57702: PUSH
57703: LD_INT 1
57705: ARRAY
57706: DIFF
57707: ST_TO_ADDR
// if tmp and not sci then
57708: LD_VAR 0 4
57712: PUSH
57713: LD_VAR 0 8
57717: NOT
57718: AND
57719: IFFALSE 57788
// begin sort := SortBySkill ( tmp , 4 ) ;
57721: LD_ADDR_VAR 0 9
57725: PUSH
57726: LD_VAR 0 4
57730: PPUSH
57731: LD_INT 4
57733: PPUSH
57734: CALL 48053 0 2
57738: ST_TO_ADDR
// if sort then
57739: LD_VAR 0 9
57743: IFFALSE 57759
// p := sort [ 1 ] ;
57745: LD_ADDR_VAR 0 11
57749: PUSH
57750: LD_VAR 0 9
57754: PUSH
57755: LD_INT 1
57757: ARRAY
57758: ST_TO_ADDR
// if p then
57759: LD_VAR 0 11
57763: IFFALSE 57788
// result := Replace ( result , 4 , p ) ;
57765: LD_ADDR_VAR 0 2
57769: PUSH
57770: LD_VAR 0 2
57774: PPUSH
57775: LD_INT 4
57777: PPUSH
57778: LD_VAR 0 11
57782: PPUSH
57783: CALL_OW 1
57787: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57788: LD_ADDR_VAR 0 4
57792: PUSH
57793: LD_VAR 0 4
57797: PUSH
57798: LD_VAR 0 7
57802: DIFF
57803: ST_TO_ADDR
// if tmp and mech < 6 then
57804: LD_VAR 0 4
57808: PUSH
57809: LD_VAR 0 7
57813: PUSH
57814: LD_INT 6
57816: LESS
57817: AND
57818: IFFALSE 58000
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
57820: LD_ADDR_VAR 0 9
57824: PUSH
57825: LD_VAR 0 4
57829: PUSH
57830: LD_VAR 0 7
57834: DIFF
57835: PPUSH
57836: LD_INT 3
57838: PPUSH
57839: CALL 48053 0 2
57843: ST_TO_ADDR
// p := [ ] ;
57844: LD_ADDR_VAR 0 11
57848: PUSH
57849: EMPTY
57850: ST_TO_ADDR
// if sort then
57851: LD_VAR 0 9
57855: IFFALSE 57971
// for i = 1 to 6 - mech do
57857: LD_ADDR_VAR 0 3
57861: PUSH
57862: DOUBLE
57863: LD_INT 1
57865: DEC
57866: ST_TO_ADDR
57867: LD_INT 6
57869: PUSH
57870: LD_VAR 0 7
57874: MINUS
57875: PUSH
57876: FOR_TO
57877: IFFALSE 57969
// begin if i = sort then
57879: LD_VAR 0 3
57883: PUSH
57884: LD_VAR 0 9
57888: EQUAL
57889: IFFALSE 57893
// break ;
57891: GO 57969
// if GetClass ( i ) = 3 then
57893: LD_VAR 0 3
57897: PPUSH
57898: CALL_OW 257
57902: PUSH
57903: LD_INT 3
57905: EQUAL
57906: IFFALSE 57910
// continue ;
57908: GO 57876
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57910: LD_ADDR_VAR 0 11
57914: PUSH
57915: LD_VAR 0 11
57919: PPUSH
57920: LD_VAR 0 11
57924: PUSH
57925: LD_INT 1
57927: PLUS
57928: PPUSH
57929: LD_VAR 0 9
57933: PUSH
57934: LD_VAR 0 3
57938: ARRAY
57939: PPUSH
57940: CALL_OW 2
57944: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57945: LD_ADDR_VAR 0 4
57949: PUSH
57950: LD_VAR 0 4
57954: PUSH
57955: LD_VAR 0 9
57959: PUSH
57960: LD_VAR 0 3
57964: ARRAY
57965: DIFF
57966: ST_TO_ADDR
// end ;
57967: GO 57876
57969: POP
57970: POP
// if p then
57971: LD_VAR 0 11
57975: IFFALSE 58000
// result := Replace ( result , 3 , p ) ;
57977: LD_ADDR_VAR 0 2
57981: PUSH
57982: LD_VAR 0 2
57986: PPUSH
57987: LD_INT 3
57989: PPUSH
57990: LD_VAR 0 11
57994: PPUSH
57995: CALL_OW 1
57999: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58000: LD_ADDR_VAR 0 4
58004: PUSH
58005: LD_VAR 0 4
58009: PUSH
58010: LD_VAR 0 6
58014: DIFF
58015: ST_TO_ADDR
// if tmp and eng < 4 then
58016: LD_VAR 0 4
58020: PUSH
58021: LD_VAR 0 6
58025: PUSH
58026: LD_INT 4
58028: LESS
58029: AND
58030: IFFALSE 58220
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
58032: LD_ADDR_VAR 0 9
58036: PUSH
58037: LD_VAR 0 4
58041: PUSH
58042: LD_VAR 0 7
58046: PUSH
58047: LD_VAR 0 6
58051: UNION
58052: DIFF
58053: PPUSH
58054: LD_INT 2
58056: PPUSH
58057: CALL 48053 0 2
58061: ST_TO_ADDR
// p := [ ] ;
58062: LD_ADDR_VAR 0 11
58066: PUSH
58067: EMPTY
58068: ST_TO_ADDR
// if sort then
58069: LD_VAR 0 9
58073: IFFALSE 58189
// for i = 1 to 4 - eng do
58075: LD_ADDR_VAR 0 3
58079: PUSH
58080: DOUBLE
58081: LD_INT 1
58083: DEC
58084: ST_TO_ADDR
58085: LD_INT 4
58087: PUSH
58088: LD_VAR 0 6
58092: MINUS
58093: PUSH
58094: FOR_TO
58095: IFFALSE 58187
// begin if i = sort then
58097: LD_VAR 0 3
58101: PUSH
58102: LD_VAR 0 9
58106: EQUAL
58107: IFFALSE 58111
// break ;
58109: GO 58187
// if GetClass ( i ) = 2 then
58111: LD_VAR 0 3
58115: PPUSH
58116: CALL_OW 257
58120: PUSH
58121: LD_INT 2
58123: EQUAL
58124: IFFALSE 58128
// continue ;
58126: GO 58094
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58128: LD_ADDR_VAR 0 11
58132: PUSH
58133: LD_VAR 0 11
58137: PPUSH
58138: LD_VAR 0 11
58142: PUSH
58143: LD_INT 1
58145: PLUS
58146: PPUSH
58147: LD_VAR 0 9
58151: PUSH
58152: LD_VAR 0 3
58156: ARRAY
58157: PPUSH
58158: CALL_OW 2
58162: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58163: LD_ADDR_VAR 0 4
58167: PUSH
58168: LD_VAR 0 4
58172: PUSH
58173: LD_VAR 0 9
58177: PUSH
58178: LD_VAR 0 3
58182: ARRAY
58183: DIFF
58184: ST_TO_ADDR
// end ;
58185: GO 58094
58187: POP
58188: POP
// if p then
58189: LD_VAR 0 11
58193: IFFALSE 58218
// result := Replace ( result , 2 , p ) ;
58195: LD_ADDR_VAR 0 2
58199: PUSH
58200: LD_VAR 0 2
58204: PPUSH
58205: LD_INT 2
58207: PPUSH
58208: LD_VAR 0 11
58212: PPUSH
58213: CALL_OW 1
58217: ST_TO_ADDR
// end else
58218: GO 58264
// for i = eng downto 5 do
58220: LD_ADDR_VAR 0 3
58224: PUSH
58225: DOUBLE
58226: LD_VAR 0 6
58230: INC
58231: ST_TO_ADDR
58232: LD_INT 5
58234: PUSH
58235: FOR_DOWNTO
58236: IFFALSE 58262
// tmp := tmp union eng [ i ] ;
58238: LD_ADDR_VAR 0 4
58242: PUSH
58243: LD_VAR 0 4
58247: PUSH
58248: LD_VAR 0 6
58252: PUSH
58253: LD_VAR 0 3
58257: ARRAY
58258: UNION
58259: ST_TO_ADDR
58260: GO 58235
58262: POP
58263: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
58264: LD_ADDR_VAR 0 2
58268: PUSH
58269: LD_VAR 0 2
58273: PPUSH
58274: LD_INT 1
58276: PPUSH
58277: LD_VAR 0 4
58281: PUSH
58282: LD_VAR 0 5
58286: DIFF
58287: PPUSH
58288: CALL_OW 1
58292: ST_TO_ADDR
// exit ;
58293: GO 58295
// end ; end ;
58295: LD_VAR 0 2
58299: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
58300: LD_INT 0
58302: PPUSH
58303: PPUSH
58304: PPUSH
// if not mc_bases then
58305: LD_EXP 65
58309: NOT
58310: IFFALSE 58314
// exit ;
58312: GO 58420
// for i = 1 to mc_bases do
58314: LD_ADDR_VAR 0 2
58318: PUSH
58319: DOUBLE
58320: LD_INT 1
58322: DEC
58323: ST_TO_ADDR
58324: LD_EXP 65
58328: PUSH
58329: FOR_TO
58330: IFFALSE 58411
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58332: LD_ADDR_VAR 0 3
58336: PUSH
58337: LD_EXP 65
58341: PUSH
58342: LD_VAR 0 2
58346: ARRAY
58347: PPUSH
58348: LD_INT 21
58350: PUSH
58351: LD_INT 3
58353: PUSH
58354: EMPTY
58355: LIST
58356: LIST
58357: PUSH
58358: LD_INT 3
58360: PUSH
58361: LD_INT 24
58363: PUSH
58364: LD_INT 1000
58366: PUSH
58367: EMPTY
58368: LIST
58369: LIST
58370: PUSH
58371: EMPTY
58372: LIST
58373: LIST
58374: PUSH
58375: EMPTY
58376: LIST
58377: LIST
58378: PPUSH
58379: CALL_OW 72
58383: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
58384: LD_ADDR_EXP 66
58388: PUSH
58389: LD_EXP 66
58393: PPUSH
58394: LD_VAR 0 2
58398: PPUSH
58399: LD_VAR 0 3
58403: PPUSH
58404: CALL_OW 1
58408: ST_TO_ADDR
// end ;
58409: GO 58329
58411: POP
58412: POP
// RaiseSailEvent ( 101 ) ;
58413: LD_INT 101
58415: PPUSH
58416: CALL_OW 427
// end ;
58420: LD_VAR 0 1
58424: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
58425: LD_INT 0
58427: PPUSH
58428: PPUSH
58429: PPUSH
58430: PPUSH
58431: PPUSH
58432: PPUSH
58433: PPUSH
// if not mc_bases then
58434: LD_EXP 65
58438: NOT
58439: IFFALSE 58443
// exit ;
58441: GO 59005
// for i = 1 to mc_bases do
58443: LD_ADDR_VAR 0 2
58447: PUSH
58448: DOUBLE
58449: LD_INT 1
58451: DEC
58452: ST_TO_ADDR
58453: LD_EXP 65
58457: PUSH
58458: FOR_TO
58459: IFFALSE 58996
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
58461: LD_ADDR_VAR 0 5
58465: PUSH
58466: LD_EXP 65
58470: PUSH
58471: LD_VAR 0 2
58475: ARRAY
58476: PUSH
58477: LD_EXP 94
58481: PUSH
58482: LD_VAR 0 2
58486: ARRAY
58487: UNION
58488: PPUSH
58489: LD_INT 21
58491: PUSH
58492: LD_INT 1
58494: PUSH
58495: EMPTY
58496: LIST
58497: LIST
58498: PUSH
58499: LD_INT 1
58501: PUSH
58502: LD_INT 3
58504: PUSH
58505: LD_INT 54
58507: PUSH
58508: EMPTY
58509: LIST
58510: PUSH
58511: EMPTY
58512: LIST
58513: LIST
58514: PUSH
58515: LD_INT 3
58517: PUSH
58518: LD_INT 24
58520: PUSH
58521: LD_INT 800
58523: PUSH
58524: EMPTY
58525: LIST
58526: LIST
58527: PUSH
58528: EMPTY
58529: LIST
58530: LIST
58531: PUSH
58532: EMPTY
58533: LIST
58534: LIST
58535: LIST
58536: PUSH
58537: EMPTY
58538: LIST
58539: LIST
58540: PPUSH
58541: CALL_OW 72
58545: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
58546: LD_ADDR_VAR 0 6
58550: PUSH
58551: LD_EXP 65
58555: PUSH
58556: LD_VAR 0 2
58560: ARRAY
58561: PPUSH
58562: LD_INT 21
58564: PUSH
58565: LD_INT 1
58567: PUSH
58568: EMPTY
58569: LIST
58570: LIST
58571: PUSH
58572: LD_INT 1
58574: PUSH
58575: LD_INT 3
58577: PUSH
58578: LD_INT 54
58580: PUSH
58581: EMPTY
58582: LIST
58583: PUSH
58584: EMPTY
58585: LIST
58586: LIST
58587: PUSH
58588: LD_INT 3
58590: PUSH
58591: LD_INT 24
58593: PUSH
58594: LD_INT 250
58596: PUSH
58597: EMPTY
58598: LIST
58599: LIST
58600: PUSH
58601: EMPTY
58602: LIST
58603: LIST
58604: PUSH
58605: EMPTY
58606: LIST
58607: LIST
58608: LIST
58609: PUSH
58610: EMPTY
58611: LIST
58612: LIST
58613: PPUSH
58614: CALL_OW 72
58618: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
58619: LD_ADDR_VAR 0 7
58623: PUSH
58624: LD_VAR 0 5
58628: PUSH
58629: LD_VAR 0 6
58633: DIFF
58634: ST_TO_ADDR
// if not need_heal_1 then
58635: LD_VAR 0 6
58639: NOT
58640: IFFALSE 58673
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
58642: LD_ADDR_EXP 68
58646: PUSH
58647: LD_EXP 68
58651: PPUSH
58652: LD_VAR 0 2
58656: PUSH
58657: LD_INT 1
58659: PUSH
58660: EMPTY
58661: LIST
58662: LIST
58663: PPUSH
58664: EMPTY
58665: PPUSH
58666: CALL 18504 0 3
58670: ST_TO_ADDR
58671: GO 58743
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
58673: LD_ADDR_EXP 68
58677: PUSH
58678: LD_EXP 68
58682: PPUSH
58683: LD_VAR 0 2
58687: PUSH
58688: LD_INT 1
58690: PUSH
58691: EMPTY
58692: LIST
58693: LIST
58694: PPUSH
58695: LD_EXP 68
58699: PUSH
58700: LD_VAR 0 2
58704: ARRAY
58705: PUSH
58706: LD_INT 1
58708: ARRAY
58709: PPUSH
58710: LD_INT 3
58712: PUSH
58713: LD_INT 24
58715: PUSH
58716: LD_INT 1000
58718: PUSH
58719: EMPTY
58720: LIST
58721: LIST
58722: PUSH
58723: EMPTY
58724: LIST
58725: LIST
58726: PPUSH
58727: CALL_OW 72
58731: PUSH
58732: LD_VAR 0 6
58736: UNION
58737: PPUSH
58738: CALL 18504 0 3
58742: ST_TO_ADDR
// if not need_heal_2 then
58743: LD_VAR 0 7
58747: NOT
58748: IFFALSE 58781
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
58750: LD_ADDR_EXP 68
58754: PUSH
58755: LD_EXP 68
58759: PPUSH
58760: LD_VAR 0 2
58764: PUSH
58765: LD_INT 2
58767: PUSH
58768: EMPTY
58769: LIST
58770: LIST
58771: PPUSH
58772: EMPTY
58773: PPUSH
58774: CALL 18504 0 3
58778: ST_TO_ADDR
58779: GO 58813
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
58781: LD_ADDR_EXP 68
58785: PUSH
58786: LD_EXP 68
58790: PPUSH
58791: LD_VAR 0 2
58795: PUSH
58796: LD_INT 2
58798: PUSH
58799: EMPTY
58800: LIST
58801: LIST
58802: PPUSH
58803: LD_VAR 0 7
58807: PPUSH
58808: CALL 18504 0 3
58812: ST_TO_ADDR
// if need_heal_2 then
58813: LD_VAR 0 7
58817: IFFALSE 58978
// for j in need_heal_2 do
58819: LD_ADDR_VAR 0 3
58823: PUSH
58824: LD_VAR 0 7
58828: PUSH
58829: FOR_IN
58830: IFFALSE 58976
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58832: LD_ADDR_VAR 0 5
58836: PUSH
58837: LD_EXP 65
58841: PUSH
58842: LD_VAR 0 2
58846: ARRAY
58847: PPUSH
58848: LD_INT 2
58850: PUSH
58851: LD_INT 30
58853: PUSH
58854: LD_INT 6
58856: PUSH
58857: EMPTY
58858: LIST
58859: LIST
58860: PUSH
58861: LD_INT 30
58863: PUSH
58864: LD_INT 7
58866: PUSH
58867: EMPTY
58868: LIST
58869: LIST
58870: PUSH
58871: LD_INT 30
58873: PUSH
58874: LD_INT 8
58876: PUSH
58877: EMPTY
58878: LIST
58879: LIST
58880: PUSH
58881: LD_INT 30
58883: PUSH
58884: LD_INT 0
58886: PUSH
58887: EMPTY
58888: LIST
58889: LIST
58890: PUSH
58891: LD_INT 30
58893: PUSH
58894: LD_INT 1
58896: PUSH
58897: EMPTY
58898: LIST
58899: LIST
58900: PUSH
58901: EMPTY
58902: LIST
58903: LIST
58904: LIST
58905: LIST
58906: LIST
58907: LIST
58908: PPUSH
58909: CALL_OW 72
58913: ST_TO_ADDR
// if tmp then
58914: LD_VAR 0 5
58918: IFFALSE 58974
// begin k := NearestUnitToUnit ( tmp , j ) ;
58920: LD_ADDR_VAR 0 4
58924: PUSH
58925: LD_VAR 0 5
58929: PPUSH
58930: LD_VAR 0 3
58934: PPUSH
58935: CALL_OW 74
58939: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
58940: LD_VAR 0 3
58944: PPUSH
58945: LD_VAR 0 4
58949: PPUSH
58950: CALL_OW 296
58954: PUSH
58955: LD_INT 5
58957: GREATER
58958: IFFALSE 58974
// ComMoveUnit ( j , k ) ;
58960: LD_VAR 0 3
58964: PPUSH
58965: LD_VAR 0 4
58969: PPUSH
58970: CALL_OW 112
// end ; end ;
58974: GO 58829
58976: POP
58977: POP
// if not need_heal_1 and not need_heal_2 then
58978: LD_VAR 0 6
58982: NOT
58983: PUSH
58984: LD_VAR 0 7
58988: NOT
58989: AND
58990: IFFALSE 58994
// continue ;
58992: GO 58458
// end ;
58994: GO 58458
58996: POP
58997: POP
// RaiseSailEvent ( 102 ) ;
58998: LD_INT 102
59000: PPUSH
59001: CALL_OW 427
// end ;
59005: LD_VAR 0 1
59009: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
59010: LD_INT 0
59012: PPUSH
59013: PPUSH
59014: PPUSH
59015: PPUSH
59016: PPUSH
59017: PPUSH
59018: PPUSH
59019: PPUSH
// if not mc_bases then
59020: LD_EXP 65
59024: NOT
59025: IFFALSE 59029
// exit ;
59027: GO 59864
// for i = 1 to mc_bases do
59029: LD_ADDR_VAR 0 2
59033: PUSH
59034: DOUBLE
59035: LD_INT 1
59037: DEC
59038: ST_TO_ADDR
59039: LD_EXP 65
59043: PUSH
59044: FOR_TO
59045: IFFALSE 59862
// begin if not mc_building_need_repair [ i ] then
59047: LD_EXP 66
59051: PUSH
59052: LD_VAR 0 2
59056: ARRAY
59057: NOT
59058: IFFALSE 59232
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
59060: LD_ADDR_VAR 0 6
59064: PUSH
59065: LD_EXP 84
59069: PUSH
59070: LD_VAR 0 2
59074: ARRAY
59075: PPUSH
59076: LD_INT 3
59078: PUSH
59079: LD_INT 24
59081: PUSH
59082: LD_INT 1000
59084: PUSH
59085: EMPTY
59086: LIST
59087: LIST
59088: PUSH
59089: EMPTY
59090: LIST
59091: LIST
59092: PUSH
59093: LD_INT 2
59095: PUSH
59096: LD_INT 34
59098: PUSH
59099: LD_INT 13
59101: PUSH
59102: EMPTY
59103: LIST
59104: LIST
59105: PUSH
59106: LD_INT 34
59108: PUSH
59109: LD_INT 52
59111: PUSH
59112: EMPTY
59113: LIST
59114: LIST
59115: PUSH
59116: EMPTY
59117: LIST
59118: LIST
59119: LIST
59120: PUSH
59121: EMPTY
59122: LIST
59123: LIST
59124: PPUSH
59125: CALL_OW 72
59129: ST_TO_ADDR
// if cranes then
59130: LD_VAR 0 6
59134: IFFALSE 59196
// for j in cranes do
59136: LD_ADDR_VAR 0 3
59140: PUSH
59141: LD_VAR 0 6
59145: PUSH
59146: FOR_IN
59147: IFFALSE 59194
// if not IsInArea ( j , mc_parking [ i ] ) then
59149: LD_VAR 0 3
59153: PPUSH
59154: LD_EXP 89
59158: PUSH
59159: LD_VAR 0 2
59163: ARRAY
59164: PPUSH
59165: CALL_OW 308
59169: NOT
59170: IFFALSE 59192
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59172: LD_VAR 0 3
59176: PPUSH
59177: LD_EXP 89
59181: PUSH
59182: LD_VAR 0 2
59186: ARRAY
59187: PPUSH
59188: CALL_OW 113
59192: GO 59146
59194: POP
59195: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59196: LD_ADDR_EXP 67
59200: PUSH
59201: LD_EXP 67
59205: PPUSH
59206: LD_VAR 0 2
59210: PPUSH
59211: EMPTY
59212: PPUSH
59213: CALL_OW 1
59217: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
59218: LD_VAR 0 2
59222: PPUSH
59223: LD_INT 101
59225: PPUSH
59226: CALL 54133 0 2
// continue ;
59230: GO 59044
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
59232: LD_ADDR_EXP 71
59236: PUSH
59237: LD_EXP 71
59241: PPUSH
59242: LD_VAR 0 2
59246: PPUSH
59247: EMPTY
59248: PPUSH
59249: CALL_OW 1
59253: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
59254: LD_VAR 0 2
59258: PPUSH
59259: LD_INT 103
59261: PPUSH
59262: CALL 54133 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
59266: LD_ADDR_VAR 0 5
59270: PUSH
59271: LD_EXP 65
59275: PUSH
59276: LD_VAR 0 2
59280: ARRAY
59281: PUSH
59282: LD_EXP 94
59286: PUSH
59287: LD_VAR 0 2
59291: ARRAY
59292: UNION
59293: PPUSH
59294: LD_INT 2
59296: PUSH
59297: LD_INT 25
59299: PUSH
59300: LD_INT 2
59302: PUSH
59303: EMPTY
59304: LIST
59305: LIST
59306: PUSH
59307: LD_INT 25
59309: PUSH
59310: LD_INT 16
59312: PUSH
59313: EMPTY
59314: LIST
59315: LIST
59316: PUSH
59317: EMPTY
59318: LIST
59319: LIST
59320: LIST
59321: PUSH
59322: EMPTY
59323: LIST
59324: PPUSH
59325: CALL_OW 72
59329: PUSH
59330: LD_EXP 68
59334: PUSH
59335: LD_VAR 0 2
59339: ARRAY
59340: PUSH
59341: LD_INT 1
59343: ARRAY
59344: PUSH
59345: LD_EXP 68
59349: PUSH
59350: LD_VAR 0 2
59354: ARRAY
59355: PUSH
59356: LD_INT 2
59358: ARRAY
59359: UNION
59360: DIFF
59361: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
59362: LD_ADDR_VAR 0 6
59366: PUSH
59367: LD_EXP 84
59371: PUSH
59372: LD_VAR 0 2
59376: ARRAY
59377: PPUSH
59378: LD_INT 2
59380: PUSH
59381: LD_INT 34
59383: PUSH
59384: LD_INT 13
59386: PUSH
59387: EMPTY
59388: LIST
59389: LIST
59390: PUSH
59391: LD_INT 34
59393: PUSH
59394: LD_INT 52
59396: PUSH
59397: EMPTY
59398: LIST
59399: LIST
59400: PUSH
59401: EMPTY
59402: LIST
59403: LIST
59404: LIST
59405: PPUSH
59406: CALL_OW 72
59410: ST_TO_ADDR
// if cranes then
59411: LD_VAR 0 6
59415: IFFALSE 59551
// begin for j in cranes do
59417: LD_ADDR_VAR 0 3
59421: PUSH
59422: LD_VAR 0 6
59426: PUSH
59427: FOR_IN
59428: IFFALSE 59549
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
59430: LD_VAR 0 3
59434: PPUSH
59435: CALL_OW 256
59439: PUSH
59440: LD_INT 500
59442: GREATEREQUAL
59443: PUSH
59444: LD_VAR 0 3
59448: PPUSH
59449: CALL_OW 314
59453: NOT
59454: AND
59455: IFFALSE 59489
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
59457: LD_VAR 0 3
59461: PPUSH
59462: LD_EXP 66
59466: PUSH
59467: LD_VAR 0 2
59471: ARRAY
59472: PPUSH
59473: LD_VAR 0 3
59477: PPUSH
59478: CALL_OW 74
59482: PPUSH
59483: CALL_OW 130
59487: GO 59547
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
59489: LD_VAR 0 3
59493: PPUSH
59494: CALL_OW 256
59498: PUSH
59499: LD_INT 500
59501: LESS
59502: PUSH
59503: LD_VAR 0 3
59507: PPUSH
59508: LD_EXP 89
59512: PUSH
59513: LD_VAR 0 2
59517: ARRAY
59518: PPUSH
59519: CALL_OW 308
59523: NOT
59524: AND
59525: IFFALSE 59547
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59527: LD_VAR 0 3
59531: PPUSH
59532: LD_EXP 89
59536: PUSH
59537: LD_VAR 0 2
59541: ARRAY
59542: PPUSH
59543: CALL_OW 113
59547: GO 59427
59549: POP
59550: POP
// end ; if tmp > 3 then
59551: LD_VAR 0 5
59555: PUSH
59556: LD_INT 3
59558: GREATER
59559: IFFALSE 59579
// tmp := ShrinkArray ( tmp , 4 ) ;
59561: LD_ADDR_VAR 0 5
59565: PUSH
59566: LD_VAR 0 5
59570: PPUSH
59571: LD_INT 4
59573: PPUSH
59574: CALL 49743 0 2
59578: ST_TO_ADDR
// if not tmp then
59579: LD_VAR 0 5
59583: NOT
59584: IFFALSE 59588
// continue ;
59586: GO 59044
// for j in tmp do
59588: LD_ADDR_VAR 0 3
59592: PUSH
59593: LD_VAR 0 5
59597: PUSH
59598: FOR_IN
59599: IFFALSE 59858
// begin if IsInUnit ( j ) then
59601: LD_VAR 0 3
59605: PPUSH
59606: CALL_OW 310
59610: IFFALSE 59621
// ComExitBuilding ( j ) ;
59612: LD_VAR 0 3
59616: PPUSH
59617: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
59621: LD_VAR 0 3
59625: PUSH
59626: LD_EXP 67
59630: PUSH
59631: LD_VAR 0 2
59635: ARRAY
59636: IN
59637: NOT
59638: IFFALSE 59696
// begin SetTag ( j , 101 ) ;
59640: LD_VAR 0 3
59644: PPUSH
59645: LD_INT 101
59647: PPUSH
59648: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
59652: LD_ADDR_EXP 67
59656: PUSH
59657: LD_EXP 67
59661: PPUSH
59662: LD_VAR 0 2
59666: PUSH
59667: LD_EXP 67
59671: PUSH
59672: LD_VAR 0 2
59676: ARRAY
59677: PUSH
59678: LD_INT 1
59680: PLUS
59681: PUSH
59682: EMPTY
59683: LIST
59684: LIST
59685: PPUSH
59686: LD_VAR 0 3
59690: PPUSH
59691: CALL 18504 0 3
59695: ST_TO_ADDR
// end ; wait ( 1 ) ;
59696: LD_INT 1
59698: PPUSH
59699: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
59703: LD_ADDR_VAR 0 7
59707: PUSH
59708: LD_EXP 66
59712: PUSH
59713: LD_VAR 0 2
59717: ARRAY
59718: ST_TO_ADDR
// if mc_scan [ i ] then
59719: LD_EXP 88
59723: PUSH
59724: LD_VAR 0 2
59728: ARRAY
59729: IFFALSE 59791
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
59731: LD_ADDR_VAR 0 7
59735: PUSH
59736: LD_EXP 66
59740: PUSH
59741: LD_VAR 0 2
59745: ARRAY
59746: PPUSH
59747: LD_INT 3
59749: PUSH
59750: LD_INT 30
59752: PUSH
59753: LD_INT 32
59755: PUSH
59756: EMPTY
59757: LIST
59758: LIST
59759: PUSH
59760: LD_INT 30
59762: PUSH
59763: LD_INT 33
59765: PUSH
59766: EMPTY
59767: LIST
59768: LIST
59769: PUSH
59770: LD_INT 30
59772: PUSH
59773: LD_INT 31
59775: PUSH
59776: EMPTY
59777: LIST
59778: LIST
59779: PUSH
59780: EMPTY
59781: LIST
59782: LIST
59783: LIST
59784: LIST
59785: PPUSH
59786: CALL_OW 72
59790: ST_TO_ADDR
// if not to_repair_tmp then
59791: LD_VAR 0 7
59795: NOT
59796: IFFALSE 59800
// continue ;
59798: GO 59598
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
59800: LD_ADDR_VAR 0 8
59804: PUSH
59805: LD_VAR 0 7
59809: PPUSH
59810: LD_VAR 0 3
59814: PPUSH
59815: CALL_OW 74
59819: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
59820: LD_VAR 0 8
59824: PPUSH
59825: LD_INT 16
59827: PPUSH
59828: CALL 21097 0 2
59832: PUSH
59833: LD_INT 4
59835: ARRAY
59836: PUSH
59837: LD_INT 5
59839: LESS
59840: IFFALSE 59856
// ComRepairBuilding ( j , to_repair ) ;
59842: LD_VAR 0 3
59846: PPUSH
59847: LD_VAR 0 8
59851: PPUSH
59852: CALL_OW 130
// end ;
59856: GO 59598
59858: POP
59859: POP
// end ;
59860: GO 59044
59862: POP
59863: POP
// end ;
59864: LD_VAR 0 1
59868: RET
// export function MC_Heal ; var i , j , tmp ; begin
59869: LD_INT 0
59871: PPUSH
59872: PPUSH
59873: PPUSH
59874: PPUSH
// if not mc_bases then
59875: LD_EXP 65
59879: NOT
59880: IFFALSE 59884
// exit ;
59882: GO 60286
// for i = 1 to mc_bases do
59884: LD_ADDR_VAR 0 2
59888: PUSH
59889: DOUBLE
59890: LD_INT 1
59892: DEC
59893: ST_TO_ADDR
59894: LD_EXP 65
59898: PUSH
59899: FOR_TO
59900: IFFALSE 60284
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
59902: LD_EXP 68
59906: PUSH
59907: LD_VAR 0 2
59911: ARRAY
59912: PUSH
59913: LD_INT 1
59915: ARRAY
59916: NOT
59917: PUSH
59918: LD_EXP 68
59922: PUSH
59923: LD_VAR 0 2
59927: ARRAY
59928: PUSH
59929: LD_INT 2
59931: ARRAY
59932: NOT
59933: AND
59934: IFFALSE 59972
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
59936: LD_ADDR_EXP 69
59940: PUSH
59941: LD_EXP 69
59945: PPUSH
59946: LD_VAR 0 2
59950: PPUSH
59951: EMPTY
59952: PPUSH
59953: CALL_OW 1
59957: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
59958: LD_VAR 0 2
59962: PPUSH
59963: LD_INT 102
59965: PPUSH
59966: CALL 54133 0 2
// continue ;
59970: GO 59899
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
59972: LD_ADDR_VAR 0 4
59976: PUSH
59977: LD_EXP 65
59981: PUSH
59982: LD_VAR 0 2
59986: ARRAY
59987: PPUSH
59988: LD_INT 25
59990: PUSH
59991: LD_INT 4
59993: PUSH
59994: EMPTY
59995: LIST
59996: LIST
59997: PPUSH
59998: CALL_OW 72
60002: ST_TO_ADDR
// if not tmp then
60003: LD_VAR 0 4
60007: NOT
60008: IFFALSE 60012
// continue ;
60010: GO 59899
// if mc_taming [ i ] then
60012: LD_EXP 96
60016: PUSH
60017: LD_VAR 0 2
60021: ARRAY
60022: IFFALSE 60046
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60024: LD_ADDR_EXP 96
60028: PUSH
60029: LD_EXP 96
60033: PPUSH
60034: LD_VAR 0 2
60038: PPUSH
60039: EMPTY
60040: PPUSH
60041: CALL_OW 1
60045: ST_TO_ADDR
// for j in tmp do
60046: LD_ADDR_VAR 0 3
60050: PUSH
60051: LD_VAR 0 4
60055: PUSH
60056: FOR_IN
60057: IFFALSE 60280
// begin if IsInUnit ( j ) then
60059: LD_VAR 0 3
60063: PPUSH
60064: CALL_OW 310
60068: IFFALSE 60079
// ComExitBuilding ( j ) ;
60070: LD_VAR 0 3
60074: PPUSH
60075: CALL_OW 122
// if not j in mc_healers [ i ] then
60079: LD_VAR 0 3
60083: PUSH
60084: LD_EXP 69
60088: PUSH
60089: LD_VAR 0 2
60093: ARRAY
60094: IN
60095: NOT
60096: IFFALSE 60142
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
60098: LD_ADDR_EXP 69
60102: PUSH
60103: LD_EXP 69
60107: PPUSH
60108: LD_VAR 0 2
60112: PUSH
60113: LD_EXP 69
60117: PUSH
60118: LD_VAR 0 2
60122: ARRAY
60123: PUSH
60124: LD_INT 1
60126: PLUS
60127: PUSH
60128: EMPTY
60129: LIST
60130: LIST
60131: PPUSH
60132: LD_VAR 0 3
60136: PPUSH
60137: CALL 18504 0 3
60141: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
60142: LD_VAR 0 3
60146: PPUSH
60147: CALL_OW 110
60151: PUSH
60152: LD_INT 102
60154: NONEQUAL
60155: IFFALSE 60169
// SetTag ( j , 102 ) ;
60157: LD_VAR 0 3
60161: PPUSH
60162: LD_INT 102
60164: PPUSH
60165: CALL_OW 109
// Wait ( 3 ) ;
60169: LD_INT 3
60171: PPUSH
60172: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
60176: LD_EXP 68
60180: PUSH
60181: LD_VAR 0 2
60185: ARRAY
60186: PUSH
60187: LD_INT 1
60189: ARRAY
60190: IFFALSE 60222
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
60192: LD_VAR 0 3
60196: PPUSH
60197: LD_EXP 68
60201: PUSH
60202: LD_VAR 0 2
60206: ARRAY
60207: PUSH
60208: LD_INT 1
60210: ARRAY
60211: PUSH
60212: LD_INT 1
60214: ARRAY
60215: PPUSH
60216: CALL_OW 128
60220: GO 60278
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
60222: LD_VAR 0 3
60226: PPUSH
60227: CALL_OW 314
60231: NOT
60232: PUSH
60233: LD_EXP 68
60237: PUSH
60238: LD_VAR 0 2
60242: ARRAY
60243: PUSH
60244: LD_INT 2
60246: ARRAY
60247: AND
60248: IFFALSE 60278
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
60250: LD_VAR 0 3
60254: PPUSH
60255: LD_EXP 68
60259: PUSH
60260: LD_VAR 0 2
60264: ARRAY
60265: PUSH
60266: LD_INT 2
60268: ARRAY
60269: PUSH
60270: LD_INT 1
60272: ARRAY
60273: PPUSH
60274: CALL_OW 128
// end ;
60278: GO 60056
60280: POP
60281: POP
// end ;
60282: GO 59899
60284: POP
60285: POP
// end ;
60286: LD_VAR 0 1
60290: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
60291: LD_INT 0
60293: PPUSH
60294: PPUSH
60295: PPUSH
60296: PPUSH
60297: PPUSH
// if not mc_bases then
60298: LD_EXP 65
60302: NOT
60303: IFFALSE 60307
// exit ;
60305: GO 61450
// for i = 1 to mc_bases do
60307: LD_ADDR_VAR 0 2
60311: PUSH
60312: DOUBLE
60313: LD_INT 1
60315: DEC
60316: ST_TO_ADDR
60317: LD_EXP 65
60321: PUSH
60322: FOR_TO
60323: IFFALSE 61448
// begin if mc_scan [ i ] then
60325: LD_EXP 88
60329: PUSH
60330: LD_VAR 0 2
60334: ARRAY
60335: IFFALSE 60339
// continue ;
60337: GO 60322
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
60339: LD_EXP 70
60343: PUSH
60344: LD_VAR 0 2
60348: ARRAY
60349: NOT
60350: PUSH
60351: LD_EXP 72
60355: PUSH
60356: LD_VAR 0 2
60360: ARRAY
60361: NOT
60362: AND
60363: PUSH
60364: LD_EXP 71
60368: PUSH
60369: LD_VAR 0 2
60373: ARRAY
60374: AND
60375: IFFALSE 60413
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
60377: LD_ADDR_EXP 71
60381: PUSH
60382: LD_EXP 71
60386: PPUSH
60387: LD_VAR 0 2
60391: PPUSH
60392: EMPTY
60393: PPUSH
60394: CALL_OW 1
60398: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60399: LD_VAR 0 2
60403: PPUSH
60404: LD_INT 103
60406: PPUSH
60407: CALL 54133 0 2
// continue ;
60411: GO 60322
// end ; if mc_construct_list [ i ] then
60413: LD_EXP 72
60417: PUSH
60418: LD_VAR 0 2
60422: ARRAY
60423: IFFALSE 60643
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
60425: LD_ADDR_VAR 0 4
60429: PUSH
60430: LD_EXP 65
60434: PUSH
60435: LD_VAR 0 2
60439: ARRAY
60440: PPUSH
60441: LD_INT 25
60443: PUSH
60444: LD_INT 2
60446: PUSH
60447: EMPTY
60448: LIST
60449: LIST
60450: PPUSH
60451: CALL_OW 72
60455: PUSH
60456: LD_EXP 67
60460: PUSH
60461: LD_VAR 0 2
60465: ARRAY
60466: DIFF
60467: ST_TO_ADDR
// if not tmp then
60468: LD_VAR 0 4
60472: NOT
60473: IFFALSE 60477
// continue ;
60475: GO 60322
// for j in tmp do
60477: LD_ADDR_VAR 0 3
60481: PUSH
60482: LD_VAR 0 4
60486: PUSH
60487: FOR_IN
60488: IFFALSE 60639
// begin if not mc_builders [ i ] then
60490: LD_EXP 71
60494: PUSH
60495: LD_VAR 0 2
60499: ARRAY
60500: NOT
60501: IFFALSE 60559
// begin SetTag ( j , 103 ) ;
60503: LD_VAR 0 3
60507: PPUSH
60508: LD_INT 103
60510: PPUSH
60511: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
60515: LD_ADDR_EXP 71
60519: PUSH
60520: LD_EXP 71
60524: PPUSH
60525: LD_VAR 0 2
60529: PUSH
60530: LD_EXP 71
60534: PUSH
60535: LD_VAR 0 2
60539: ARRAY
60540: PUSH
60541: LD_INT 1
60543: PLUS
60544: PUSH
60545: EMPTY
60546: LIST
60547: LIST
60548: PPUSH
60549: LD_VAR 0 3
60553: PPUSH
60554: CALL 18504 0 3
60558: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
60559: LD_VAR 0 3
60563: PPUSH
60564: CALL_OW 310
60568: IFFALSE 60579
// ComExitBuilding ( j ) ;
60570: LD_VAR 0 3
60574: PPUSH
60575: CALL_OW 122
// wait ( 3 ) ;
60579: LD_INT 3
60581: PPUSH
60582: CALL_OW 67
// if not mc_construct_list [ i ] then
60586: LD_EXP 72
60590: PUSH
60591: LD_VAR 0 2
60595: ARRAY
60596: NOT
60597: IFFALSE 60601
// break ;
60599: GO 60639
// if not HasTask ( j ) then
60601: LD_VAR 0 3
60605: PPUSH
60606: CALL_OW 314
60610: NOT
60611: IFFALSE 60637
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
60613: LD_VAR 0 3
60617: PPUSH
60618: LD_EXP 72
60622: PUSH
60623: LD_VAR 0 2
60627: ARRAY
60628: PUSH
60629: LD_INT 1
60631: ARRAY
60632: PPUSH
60633: CALL 21355 0 2
// end ;
60637: GO 60487
60639: POP
60640: POP
// end else
60641: GO 61446
// if mc_build_list [ i ] then
60643: LD_EXP 70
60647: PUSH
60648: LD_VAR 0 2
60652: ARRAY
60653: IFFALSE 61446
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60655: LD_ADDR_VAR 0 5
60659: PUSH
60660: LD_EXP 65
60664: PUSH
60665: LD_VAR 0 2
60669: ARRAY
60670: PPUSH
60671: LD_INT 2
60673: PUSH
60674: LD_INT 30
60676: PUSH
60677: LD_INT 0
60679: PUSH
60680: EMPTY
60681: LIST
60682: LIST
60683: PUSH
60684: LD_INT 30
60686: PUSH
60687: LD_INT 1
60689: PUSH
60690: EMPTY
60691: LIST
60692: LIST
60693: PUSH
60694: EMPTY
60695: LIST
60696: LIST
60697: LIST
60698: PPUSH
60699: CALL_OW 72
60703: ST_TO_ADDR
// if depot then
60704: LD_VAR 0 5
60708: IFFALSE 60726
// depot := depot [ 1 ] else
60710: LD_ADDR_VAR 0 5
60714: PUSH
60715: LD_VAR 0 5
60719: PUSH
60720: LD_INT 1
60722: ARRAY
60723: ST_TO_ADDR
60724: GO 60734
// depot := 0 ;
60726: LD_ADDR_VAR 0 5
60730: PUSH
60731: LD_INT 0
60733: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
60734: LD_EXP 70
60738: PUSH
60739: LD_VAR 0 2
60743: ARRAY
60744: PUSH
60745: LD_INT 1
60747: ARRAY
60748: PUSH
60749: LD_INT 1
60751: ARRAY
60752: PPUSH
60753: CALL 21185 0 1
60757: PUSH
60758: LD_EXP 65
60762: PUSH
60763: LD_VAR 0 2
60767: ARRAY
60768: PPUSH
60769: LD_INT 2
60771: PUSH
60772: LD_INT 30
60774: PUSH
60775: LD_INT 2
60777: PUSH
60778: EMPTY
60779: LIST
60780: LIST
60781: PUSH
60782: LD_INT 30
60784: PUSH
60785: LD_INT 3
60787: PUSH
60788: EMPTY
60789: LIST
60790: LIST
60791: PUSH
60792: EMPTY
60793: LIST
60794: LIST
60795: LIST
60796: PPUSH
60797: CALL_OW 72
60801: NOT
60802: AND
60803: IFFALSE 60908
// begin for j = 1 to mc_build_list [ i ] do
60805: LD_ADDR_VAR 0 3
60809: PUSH
60810: DOUBLE
60811: LD_INT 1
60813: DEC
60814: ST_TO_ADDR
60815: LD_EXP 70
60819: PUSH
60820: LD_VAR 0 2
60824: ARRAY
60825: PUSH
60826: FOR_TO
60827: IFFALSE 60906
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
60829: LD_EXP 70
60833: PUSH
60834: LD_VAR 0 2
60838: ARRAY
60839: PUSH
60840: LD_VAR 0 3
60844: ARRAY
60845: PUSH
60846: LD_INT 1
60848: ARRAY
60849: PUSH
60850: LD_INT 2
60852: EQUAL
60853: IFFALSE 60904
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
60855: LD_ADDR_EXP 70
60859: PUSH
60860: LD_EXP 70
60864: PPUSH
60865: LD_VAR 0 2
60869: PPUSH
60870: LD_EXP 70
60874: PUSH
60875: LD_VAR 0 2
60879: ARRAY
60880: PPUSH
60881: LD_VAR 0 3
60885: PPUSH
60886: LD_INT 1
60888: PPUSH
60889: LD_INT 0
60891: PPUSH
60892: CALL 17922 0 4
60896: PPUSH
60897: CALL_OW 1
60901: ST_TO_ADDR
// break ;
60902: GO 60906
// end ;
60904: GO 60826
60906: POP
60907: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
60908: LD_EXP 70
60912: PUSH
60913: LD_VAR 0 2
60917: ARRAY
60918: PUSH
60919: LD_INT 1
60921: ARRAY
60922: PUSH
60923: LD_INT 1
60925: ARRAY
60926: PUSH
60927: LD_INT 0
60929: EQUAL
60930: PUSH
60931: LD_VAR 0 5
60935: PUSH
60936: LD_VAR 0 5
60940: PPUSH
60941: LD_EXP 70
60945: PUSH
60946: LD_VAR 0 2
60950: ARRAY
60951: PUSH
60952: LD_INT 1
60954: ARRAY
60955: PUSH
60956: LD_INT 1
60958: ARRAY
60959: PPUSH
60960: LD_EXP 70
60964: PUSH
60965: LD_VAR 0 2
60969: ARRAY
60970: PUSH
60971: LD_INT 1
60973: ARRAY
60974: PUSH
60975: LD_INT 2
60977: ARRAY
60978: PPUSH
60979: LD_EXP 70
60983: PUSH
60984: LD_VAR 0 2
60988: ARRAY
60989: PUSH
60990: LD_INT 1
60992: ARRAY
60993: PUSH
60994: LD_INT 3
60996: ARRAY
60997: PPUSH
60998: LD_EXP 70
61002: PUSH
61003: LD_VAR 0 2
61007: ARRAY
61008: PUSH
61009: LD_INT 1
61011: ARRAY
61012: PUSH
61013: LD_INT 4
61015: ARRAY
61016: PPUSH
61017: CALL 25919 0 5
61021: AND
61022: OR
61023: IFFALSE 61304
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61025: LD_ADDR_VAR 0 4
61029: PUSH
61030: LD_EXP 65
61034: PUSH
61035: LD_VAR 0 2
61039: ARRAY
61040: PPUSH
61041: LD_INT 25
61043: PUSH
61044: LD_INT 2
61046: PUSH
61047: EMPTY
61048: LIST
61049: LIST
61050: PPUSH
61051: CALL_OW 72
61055: PUSH
61056: LD_EXP 67
61060: PUSH
61061: LD_VAR 0 2
61065: ARRAY
61066: DIFF
61067: ST_TO_ADDR
// if not tmp then
61068: LD_VAR 0 4
61072: NOT
61073: IFFALSE 61077
// continue ;
61075: GO 60322
// for j in tmp do
61077: LD_ADDR_VAR 0 3
61081: PUSH
61082: LD_VAR 0 4
61086: PUSH
61087: FOR_IN
61088: IFFALSE 61300
// begin if not mc_builders [ i ] then
61090: LD_EXP 71
61094: PUSH
61095: LD_VAR 0 2
61099: ARRAY
61100: NOT
61101: IFFALSE 61159
// begin SetTag ( j , 103 ) ;
61103: LD_VAR 0 3
61107: PPUSH
61108: LD_INT 103
61110: PPUSH
61111: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61115: LD_ADDR_EXP 71
61119: PUSH
61120: LD_EXP 71
61124: PPUSH
61125: LD_VAR 0 2
61129: PUSH
61130: LD_EXP 71
61134: PUSH
61135: LD_VAR 0 2
61139: ARRAY
61140: PUSH
61141: LD_INT 1
61143: PLUS
61144: PUSH
61145: EMPTY
61146: LIST
61147: LIST
61148: PPUSH
61149: LD_VAR 0 3
61153: PPUSH
61154: CALL 18504 0 3
61158: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61159: LD_VAR 0 3
61163: PPUSH
61164: CALL_OW 310
61168: IFFALSE 61179
// ComExitBuilding ( j ) ;
61170: LD_VAR 0 3
61174: PPUSH
61175: CALL_OW 122
// wait ( 3 ) ;
61179: LD_INT 3
61181: PPUSH
61182: CALL_OW 67
// if not mc_build_list [ i ] then
61186: LD_EXP 70
61190: PUSH
61191: LD_VAR 0 2
61195: ARRAY
61196: NOT
61197: IFFALSE 61201
// break ;
61199: GO 61300
// if not HasTask ( j ) then
61201: LD_VAR 0 3
61205: PPUSH
61206: CALL_OW 314
61210: NOT
61211: IFFALSE 61298
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
61213: LD_VAR 0 3
61217: PPUSH
61218: LD_EXP 70
61222: PUSH
61223: LD_VAR 0 2
61227: ARRAY
61228: PUSH
61229: LD_INT 1
61231: ARRAY
61232: PUSH
61233: LD_INT 1
61235: ARRAY
61236: PPUSH
61237: LD_EXP 70
61241: PUSH
61242: LD_VAR 0 2
61246: ARRAY
61247: PUSH
61248: LD_INT 1
61250: ARRAY
61251: PUSH
61252: LD_INT 2
61254: ARRAY
61255: PPUSH
61256: LD_EXP 70
61260: PUSH
61261: LD_VAR 0 2
61265: ARRAY
61266: PUSH
61267: LD_INT 1
61269: ARRAY
61270: PUSH
61271: LD_INT 3
61273: ARRAY
61274: PPUSH
61275: LD_EXP 70
61279: PUSH
61280: LD_VAR 0 2
61284: ARRAY
61285: PUSH
61286: LD_INT 1
61288: ARRAY
61289: PUSH
61290: LD_INT 4
61292: ARRAY
61293: PPUSH
61294: CALL_OW 145
// end ;
61298: GO 61087
61300: POP
61301: POP
// end else
61302: GO 61446
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
61304: LD_EXP 65
61308: PUSH
61309: LD_VAR 0 2
61313: ARRAY
61314: PPUSH
61315: LD_EXP 70
61319: PUSH
61320: LD_VAR 0 2
61324: ARRAY
61325: PUSH
61326: LD_INT 1
61328: ARRAY
61329: PUSH
61330: LD_INT 1
61332: ARRAY
61333: PPUSH
61334: LD_EXP 70
61338: PUSH
61339: LD_VAR 0 2
61343: ARRAY
61344: PUSH
61345: LD_INT 1
61347: ARRAY
61348: PUSH
61349: LD_INT 2
61351: ARRAY
61352: PPUSH
61353: LD_EXP 70
61357: PUSH
61358: LD_VAR 0 2
61362: ARRAY
61363: PUSH
61364: LD_INT 1
61366: ARRAY
61367: PUSH
61368: LD_INT 3
61370: ARRAY
61371: PPUSH
61372: LD_EXP 70
61376: PUSH
61377: LD_VAR 0 2
61381: ARRAY
61382: PUSH
61383: LD_INT 1
61385: ARRAY
61386: PUSH
61387: LD_INT 4
61389: ARRAY
61390: PPUSH
61391: CALL 25255 0 5
61395: NOT
61396: IFFALSE 61446
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
61398: LD_ADDR_EXP 70
61402: PUSH
61403: LD_EXP 70
61407: PPUSH
61408: LD_VAR 0 2
61412: PPUSH
61413: LD_EXP 70
61417: PUSH
61418: LD_VAR 0 2
61422: ARRAY
61423: PPUSH
61424: LD_INT 1
61426: PPUSH
61427: LD_INT 1
61429: NEG
61430: PPUSH
61431: LD_INT 0
61433: PPUSH
61434: CALL 17922 0 4
61438: PPUSH
61439: CALL_OW 1
61443: ST_TO_ADDR
// continue ;
61444: GO 60322
// end ; end ; end ;
61446: GO 60322
61448: POP
61449: POP
// end ;
61450: LD_VAR 0 1
61454: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
61455: LD_INT 0
61457: PPUSH
61458: PPUSH
61459: PPUSH
61460: PPUSH
61461: PPUSH
61462: PPUSH
// if not mc_bases then
61463: LD_EXP 65
61467: NOT
61468: IFFALSE 61472
// exit ;
61470: GO 61899
// for i = 1 to mc_bases do
61472: LD_ADDR_VAR 0 2
61476: PUSH
61477: DOUBLE
61478: LD_INT 1
61480: DEC
61481: ST_TO_ADDR
61482: LD_EXP 65
61486: PUSH
61487: FOR_TO
61488: IFFALSE 61897
// begin tmp := mc_build_upgrade [ i ] ;
61490: LD_ADDR_VAR 0 4
61494: PUSH
61495: LD_EXP 97
61499: PUSH
61500: LD_VAR 0 2
61504: ARRAY
61505: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
61506: LD_ADDR_VAR 0 6
61510: PUSH
61511: LD_EXP 98
61515: PUSH
61516: LD_VAR 0 2
61520: ARRAY
61521: PPUSH
61522: LD_INT 2
61524: PUSH
61525: LD_INT 30
61527: PUSH
61528: LD_INT 6
61530: PUSH
61531: EMPTY
61532: LIST
61533: LIST
61534: PUSH
61535: LD_INT 30
61537: PUSH
61538: LD_INT 7
61540: PUSH
61541: EMPTY
61542: LIST
61543: LIST
61544: PUSH
61545: EMPTY
61546: LIST
61547: LIST
61548: LIST
61549: PPUSH
61550: CALL_OW 72
61554: ST_TO_ADDR
// if not tmp and not lab then
61555: LD_VAR 0 4
61559: NOT
61560: PUSH
61561: LD_VAR 0 6
61565: NOT
61566: AND
61567: IFFALSE 61571
// continue ;
61569: GO 61487
// if tmp then
61571: LD_VAR 0 4
61575: IFFALSE 61695
// for j in tmp do
61577: LD_ADDR_VAR 0 3
61581: PUSH
61582: LD_VAR 0 4
61586: PUSH
61587: FOR_IN
61588: IFFALSE 61693
// begin if UpgradeCost ( j ) then
61590: LD_VAR 0 3
61594: PPUSH
61595: CALL 24915 0 1
61599: IFFALSE 61691
// begin ComUpgrade ( j ) ;
61601: LD_VAR 0 3
61605: PPUSH
61606: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
61610: LD_ADDR_EXP 97
61614: PUSH
61615: LD_EXP 97
61619: PPUSH
61620: LD_VAR 0 2
61624: PPUSH
61625: LD_EXP 97
61629: PUSH
61630: LD_VAR 0 2
61634: ARRAY
61635: PUSH
61636: LD_VAR 0 3
61640: DIFF
61641: PPUSH
61642: CALL_OW 1
61646: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
61647: LD_ADDR_EXP 72
61651: PUSH
61652: LD_EXP 72
61656: PPUSH
61657: LD_VAR 0 2
61661: PUSH
61662: LD_EXP 72
61666: PUSH
61667: LD_VAR 0 2
61671: ARRAY
61672: PUSH
61673: LD_INT 1
61675: PLUS
61676: PUSH
61677: EMPTY
61678: LIST
61679: LIST
61680: PPUSH
61681: LD_VAR 0 3
61685: PPUSH
61686: CALL 18504 0 3
61690: ST_TO_ADDR
// end ; end ;
61691: GO 61587
61693: POP
61694: POP
// if not lab or not mc_lab_upgrade [ i ] then
61695: LD_VAR 0 6
61699: NOT
61700: PUSH
61701: LD_EXP 99
61705: PUSH
61706: LD_VAR 0 2
61710: ARRAY
61711: NOT
61712: OR
61713: IFFALSE 61717
// continue ;
61715: GO 61487
// for j in lab do
61717: LD_ADDR_VAR 0 3
61721: PUSH
61722: LD_VAR 0 6
61726: PUSH
61727: FOR_IN
61728: IFFALSE 61893
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
61730: LD_VAR 0 3
61734: PPUSH
61735: CALL_OW 266
61739: PUSH
61740: LD_INT 6
61742: PUSH
61743: LD_INT 7
61745: PUSH
61746: EMPTY
61747: LIST
61748: LIST
61749: IN
61750: PUSH
61751: LD_VAR 0 3
61755: PPUSH
61756: CALL_OW 461
61760: PUSH
61761: LD_INT 1
61763: NONEQUAL
61764: AND
61765: IFFALSE 61891
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
61767: LD_VAR 0 3
61771: PPUSH
61772: LD_EXP 99
61776: PUSH
61777: LD_VAR 0 2
61781: ARRAY
61782: PUSH
61783: LD_INT 1
61785: ARRAY
61786: PPUSH
61787: CALL 25120 0 2
61791: IFFALSE 61891
// begin ComCancel ( j ) ;
61793: LD_VAR 0 3
61797: PPUSH
61798: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
61802: LD_VAR 0 3
61806: PPUSH
61807: LD_EXP 99
61811: PUSH
61812: LD_VAR 0 2
61816: ARRAY
61817: PUSH
61818: LD_INT 1
61820: ARRAY
61821: PPUSH
61822: CALL_OW 207
// if not j in mc_construct_list [ i ] then
61826: LD_VAR 0 3
61830: PUSH
61831: LD_EXP 72
61835: PUSH
61836: LD_VAR 0 2
61840: ARRAY
61841: IN
61842: NOT
61843: IFFALSE 61889
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
61845: LD_ADDR_EXP 72
61849: PUSH
61850: LD_EXP 72
61854: PPUSH
61855: LD_VAR 0 2
61859: PUSH
61860: LD_EXP 72
61864: PUSH
61865: LD_VAR 0 2
61869: ARRAY
61870: PUSH
61871: LD_INT 1
61873: PLUS
61874: PUSH
61875: EMPTY
61876: LIST
61877: LIST
61878: PPUSH
61879: LD_VAR 0 3
61883: PPUSH
61884: CALL 18504 0 3
61888: ST_TO_ADDR
// break ;
61889: GO 61893
// end ; end ; end ;
61891: GO 61727
61893: POP
61894: POP
// end ;
61895: GO 61487
61897: POP
61898: POP
// end ;
61899: LD_VAR 0 1
61903: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
61904: LD_INT 0
61906: PPUSH
61907: PPUSH
61908: PPUSH
61909: PPUSH
61910: PPUSH
61911: PPUSH
61912: PPUSH
61913: PPUSH
61914: PPUSH
// if not mc_bases then
61915: LD_EXP 65
61919: NOT
61920: IFFALSE 61924
// exit ;
61922: GO 62329
// for i = 1 to mc_bases do
61924: LD_ADDR_VAR 0 2
61928: PUSH
61929: DOUBLE
61930: LD_INT 1
61932: DEC
61933: ST_TO_ADDR
61934: LD_EXP 65
61938: PUSH
61939: FOR_TO
61940: IFFALSE 62327
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
61942: LD_EXP 73
61946: PUSH
61947: LD_VAR 0 2
61951: ARRAY
61952: NOT
61953: PUSH
61954: LD_EXP 65
61958: PUSH
61959: LD_VAR 0 2
61963: ARRAY
61964: PPUSH
61965: LD_INT 30
61967: PUSH
61968: LD_INT 3
61970: PUSH
61971: EMPTY
61972: LIST
61973: LIST
61974: PPUSH
61975: CALL_OW 72
61979: NOT
61980: OR
61981: IFFALSE 61985
// continue ;
61983: GO 61939
// busy := false ;
61985: LD_ADDR_VAR 0 8
61989: PUSH
61990: LD_INT 0
61992: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
61993: LD_ADDR_VAR 0 4
61997: PUSH
61998: LD_EXP 65
62002: PUSH
62003: LD_VAR 0 2
62007: ARRAY
62008: PPUSH
62009: LD_INT 30
62011: PUSH
62012: LD_INT 3
62014: PUSH
62015: EMPTY
62016: LIST
62017: LIST
62018: PPUSH
62019: CALL_OW 72
62023: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
62024: LD_ADDR_VAR 0 6
62028: PUSH
62029: LD_EXP 73
62033: PUSH
62034: LD_VAR 0 2
62038: ARRAY
62039: PPUSH
62040: LD_INT 2
62042: PUSH
62043: LD_INT 30
62045: PUSH
62046: LD_INT 32
62048: PUSH
62049: EMPTY
62050: LIST
62051: LIST
62052: PUSH
62053: LD_INT 30
62055: PUSH
62056: LD_INT 33
62058: PUSH
62059: EMPTY
62060: LIST
62061: LIST
62062: PUSH
62063: EMPTY
62064: LIST
62065: LIST
62066: LIST
62067: PPUSH
62068: CALL_OW 72
62072: ST_TO_ADDR
// if not t then
62073: LD_VAR 0 6
62077: NOT
62078: IFFALSE 62082
// continue ;
62080: GO 61939
// for j in tmp do
62082: LD_ADDR_VAR 0 3
62086: PUSH
62087: LD_VAR 0 4
62091: PUSH
62092: FOR_IN
62093: IFFALSE 62123
// if not BuildingStatus ( j ) = bs_idle then
62095: LD_VAR 0 3
62099: PPUSH
62100: CALL_OW 461
62104: PUSH
62105: LD_INT 2
62107: EQUAL
62108: NOT
62109: IFFALSE 62121
// begin busy := true ;
62111: LD_ADDR_VAR 0 8
62115: PUSH
62116: LD_INT 1
62118: ST_TO_ADDR
// break ;
62119: GO 62123
// end ;
62121: GO 62092
62123: POP
62124: POP
// if busy then
62125: LD_VAR 0 8
62129: IFFALSE 62133
// continue ;
62131: GO 61939
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
62133: LD_ADDR_VAR 0 7
62137: PUSH
62138: LD_VAR 0 6
62142: PPUSH
62143: LD_INT 35
62145: PUSH
62146: LD_INT 0
62148: PUSH
62149: EMPTY
62150: LIST
62151: LIST
62152: PPUSH
62153: CALL_OW 72
62157: ST_TO_ADDR
// if tw then
62158: LD_VAR 0 7
62162: IFFALSE 62239
// begin tw := tw [ 1 ] ;
62164: LD_ADDR_VAR 0 7
62168: PUSH
62169: LD_VAR 0 7
62173: PUSH
62174: LD_INT 1
62176: ARRAY
62177: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
62178: LD_ADDR_VAR 0 9
62182: PUSH
62183: LD_VAR 0 7
62187: PPUSH
62188: LD_EXP 90
62192: PUSH
62193: LD_VAR 0 2
62197: ARRAY
62198: PPUSH
62199: CALL 23474 0 2
62203: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
62204: LD_EXP 104
62208: PUSH
62209: LD_VAR 0 2
62213: ARRAY
62214: IFFALSE 62237
// if not weapon in mc_allowed_tower_weapons [ i ] then
62216: LD_VAR 0 9
62220: PUSH
62221: LD_EXP 104
62225: PUSH
62226: LD_VAR 0 2
62230: ARRAY
62231: IN
62232: NOT
62233: IFFALSE 62237
// continue ;
62235: GO 61939
// end else
62237: GO 62302
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
62239: LD_ADDR_VAR 0 5
62243: PUSH
62244: LD_EXP 73
62248: PUSH
62249: LD_VAR 0 2
62253: ARRAY
62254: PPUSH
62255: LD_VAR 0 4
62259: PPUSH
62260: CALL 48976 0 2
62264: ST_TO_ADDR
// if not tmp2 then
62265: LD_VAR 0 5
62269: NOT
62270: IFFALSE 62274
// continue ;
62272: GO 61939
// tw := tmp2 [ 1 ] ;
62274: LD_ADDR_VAR 0 7
62278: PUSH
62279: LD_VAR 0 5
62283: PUSH
62284: LD_INT 1
62286: ARRAY
62287: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
62288: LD_ADDR_VAR 0 9
62292: PUSH
62293: LD_VAR 0 5
62297: PUSH
62298: LD_INT 2
62300: ARRAY
62301: ST_TO_ADDR
// end ; if not weapon then
62302: LD_VAR 0 9
62306: NOT
62307: IFFALSE 62311
// continue ;
62309: GO 61939
// ComPlaceWeapon ( tw , weapon ) ;
62311: LD_VAR 0 7
62315: PPUSH
62316: LD_VAR 0 9
62320: PPUSH
62321: CALL_OW 148
// end ;
62325: GO 61939
62327: POP
62328: POP
// end ;
62329: LD_VAR 0 1
62333: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
62334: LD_INT 0
62336: PPUSH
62337: PPUSH
62338: PPUSH
62339: PPUSH
62340: PPUSH
62341: PPUSH
// if not mc_bases then
62342: LD_EXP 65
62346: NOT
62347: IFFALSE 62351
// exit ;
62349: GO 63127
// for i = 1 to mc_bases do
62351: LD_ADDR_VAR 0 2
62355: PUSH
62356: DOUBLE
62357: LD_INT 1
62359: DEC
62360: ST_TO_ADDR
62361: LD_EXP 65
62365: PUSH
62366: FOR_TO
62367: IFFALSE 63125
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
62369: LD_EXP 78
62373: PUSH
62374: LD_VAR 0 2
62378: ARRAY
62379: NOT
62380: PUSH
62381: LD_EXP 78
62385: PUSH
62386: LD_VAR 0 2
62390: ARRAY
62391: PUSH
62392: LD_EXP 79
62396: PUSH
62397: LD_VAR 0 2
62401: ARRAY
62402: EQUAL
62403: OR
62404: PUSH
62405: LD_EXP 88
62409: PUSH
62410: LD_VAR 0 2
62414: ARRAY
62415: OR
62416: IFFALSE 62420
// continue ;
62418: GO 62366
// if mc_miners [ i ] then
62420: LD_EXP 79
62424: PUSH
62425: LD_VAR 0 2
62429: ARRAY
62430: IFFALSE 62812
// begin for j = mc_miners [ i ] downto 1 do
62432: LD_ADDR_VAR 0 3
62436: PUSH
62437: DOUBLE
62438: LD_EXP 79
62442: PUSH
62443: LD_VAR 0 2
62447: ARRAY
62448: INC
62449: ST_TO_ADDR
62450: LD_INT 1
62452: PUSH
62453: FOR_DOWNTO
62454: IFFALSE 62810
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
62456: LD_EXP 79
62460: PUSH
62461: LD_VAR 0 2
62465: ARRAY
62466: PUSH
62467: LD_VAR 0 3
62471: ARRAY
62472: PPUSH
62473: CALL_OW 301
62477: PUSH
62478: LD_EXP 79
62482: PUSH
62483: LD_VAR 0 2
62487: ARRAY
62488: PUSH
62489: LD_VAR 0 3
62493: ARRAY
62494: PPUSH
62495: CALL_OW 257
62499: PUSH
62500: LD_INT 1
62502: NONEQUAL
62503: OR
62504: IFFALSE 62567
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
62506: LD_ADDR_VAR 0 5
62510: PUSH
62511: LD_EXP 79
62515: PUSH
62516: LD_VAR 0 2
62520: ARRAY
62521: PUSH
62522: LD_EXP 79
62526: PUSH
62527: LD_VAR 0 2
62531: ARRAY
62532: PUSH
62533: LD_VAR 0 3
62537: ARRAY
62538: DIFF
62539: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
62540: LD_ADDR_EXP 79
62544: PUSH
62545: LD_EXP 79
62549: PPUSH
62550: LD_VAR 0 2
62554: PPUSH
62555: LD_VAR 0 5
62559: PPUSH
62560: CALL_OW 1
62564: ST_TO_ADDR
// continue ;
62565: GO 62453
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
62567: LD_EXP 79
62571: PUSH
62572: LD_VAR 0 2
62576: ARRAY
62577: PUSH
62578: LD_VAR 0 3
62582: ARRAY
62583: PPUSH
62584: CALL_OW 257
62588: PUSH
62589: LD_INT 1
62591: EQUAL
62592: PUSH
62593: LD_EXP 79
62597: PUSH
62598: LD_VAR 0 2
62602: ARRAY
62603: PUSH
62604: LD_VAR 0 3
62608: ARRAY
62609: PPUSH
62610: CALL_OW 459
62614: NOT
62615: AND
62616: PUSH
62617: LD_EXP 79
62621: PUSH
62622: LD_VAR 0 2
62626: ARRAY
62627: PUSH
62628: LD_VAR 0 3
62632: ARRAY
62633: PPUSH
62634: CALL_OW 314
62638: NOT
62639: AND
62640: IFFALSE 62808
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
62642: LD_EXP 79
62646: PUSH
62647: LD_VAR 0 2
62651: ARRAY
62652: PUSH
62653: LD_VAR 0 3
62657: ARRAY
62658: PPUSH
62659: CALL_OW 310
62663: IFFALSE 62686
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
62665: LD_EXP 79
62669: PUSH
62670: LD_VAR 0 2
62674: ARRAY
62675: PUSH
62676: LD_VAR 0 3
62680: ARRAY
62681: PPUSH
62682: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
62686: LD_EXP 79
62690: PUSH
62691: LD_VAR 0 2
62695: ARRAY
62696: PUSH
62697: LD_VAR 0 3
62701: ARRAY
62702: PPUSH
62703: CALL_OW 314
62707: NOT
62708: IFFALSE 62808
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
62710: LD_EXP 79
62714: PUSH
62715: LD_VAR 0 2
62719: ARRAY
62720: PUSH
62721: LD_VAR 0 3
62725: ARRAY
62726: PPUSH
62727: LD_EXP 78
62731: PUSH
62732: LD_VAR 0 2
62736: ARRAY
62737: PUSH
62738: LD_VAR 0 3
62742: PUSH
62743: LD_EXP 78
62747: PUSH
62748: LD_VAR 0 2
62752: ARRAY
62753: MOD
62754: PUSH
62755: LD_INT 1
62757: PLUS
62758: ARRAY
62759: PUSH
62760: LD_INT 1
62762: ARRAY
62763: PPUSH
62764: LD_EXP 78
62768: PUSH
62769: LD_VAR 0 2
62773: ARRAY
62774: PUSH
62775: LD_VAR 0 3
62779: PUSH
62780: LD_EXP 78
62784: PUSH
62785: LD_VAR 0 2
62789: ARRAY
62790: MOD
62791: PUSH
62792: LD_INT 1
62794: PLUS
62795: ARRAY
62796: PUSH
62797: LD_INT 2
62799: ARRAY
62800: PPUSH
62801: LD_INT 0
62803: PPUSH
62804: CALL_OW 193
// end ; end ;
62808: GO 62453
62810: POP
62811: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
62812: LD_ADDR_VAR 0 5
62816: PUSH
62817: LD_EXP 65
62821: PUSH
62822: LD_VAR 0 2
62826: ARRAY
62827: PPUSH
62828: LD_INT 2
62830: PUSH
62831: LD_INT 30
62833: PUSH
62834: LD_INT 4
62836: PUSH
62837: EMPTY
62838: LIST
62839: LIST
62840: PUSH
62841: LD_INT 30
62843: PUSH
62844: LD_INT 5
62846: PUSH
62847: EMPTY
62848: LIST
62849: LIST
62850: PUSH
62851: LD_INT 30
62853: PUSH
62854: LD_INT 32
62856: PUSH
62857: EMPTY
62858: LIST
62859: LIST
62860: PUSH
62861: EMPTY
62862: LIST
62863: LIST
62864: LIST
62865: LIST
62866: PPUSH
62867: CALL_OW 72
62871: ST_TO_ADDR
// if not tmp then
62872: LD_VAR 0 5
62876: NOT
62877: IFFALSE 62881
// continue ;
62879: GO 62366
// list := [ ] ;
62881: LD_ADDR_VAR 0 6
62885: PUSH
62886: EMPTY
62887: ST_TO_ADDR
// for j in tmp do
62888: LD_ADDR_VAR 0 3
62892: PUSH
62893: LD_VAR 0 5
62897: PUSH
62898: FOR_IN
62899: IFFALSE 62968
// begin for k in UnitsInside ( j ) do
62901: LD_ADDR_VAR 0 4
62905: PUSH
62906: LD_VAR 0 3
62910: PPUSH
62911: CALL_OW 313
62915: PUSH
62916: FOR_IN
62917: IFFALSE 62964
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
62919: LD_VAR 0 4
62923: PPUSH
62924: CALL_OW 257
62928: PUSH
62929: LD_INT 1
62931: EQUAL
62932: PUSH
62933: LD_VAR 0 4
62937: PPUSH
62938: CALL_OW 459
62942: NOT
62943: AND
62944: IFFALSE 62962
// list := list ^ k ;
62946: LD_ADDR_VAR 0 6
62950: PUSH
62951: LD_VAR 0 6
62955: PUSH
62956: LD_VAR 0 4
62960: ADD
62961: ST_TO_ADDR
62962: GO 62916
62964: POP
62965: POP
// end ;
62966: GO 62898
62968: POP
62969: POP
// list := list diff mc_miners [ i ] ;
62970: LD_ADDR_VAR 0 6
62974: PUSH
62975: LD_VAR 0 6
62979: PUSH
62980: LD_EXP 79
62984: PUSH
62985: LD_VAR 0 2
62989: ARRAY
62990: DIFF
62991: ST_TO_ADDR
// if not list then
62992: LD_VAR 0 6
62996: NOT
62997: IFFALSE 63001
// continue ;
62999: GO 62366
// k := mc_mines [ i ] - mc_miners [ i ] ;
63001: LD_ADDR_VAR 0 4
63005: PUSH
63006: LD_EXP 78
63010: PUSH
63011: LD_VAR 0 2
63015: ARRAY
63016: PUSH
63017: LD_EXP 79
63021: PUSH
63022: LD_VAR 0 2
63026: ARRAY
63027: MINUS
63028: ST_TO_ADDR
// if k > list then
63029: LD_VAR 0 4
63033: PUSH
63034: LD_VAR 0 6
63038: GREATER
63039: IFFALSE 63051
// k := list ;
63041: LD_ADDR_VAR 0 4
63045: PUSH
63046: LD_VAR 0 6
63050: ST_TO_ADDR
// for j = 1 to k do
63051: LD_ADDR_VAR 0 3
63055: PUSH
63056: DOUBLE
63057: LD_INT 1
63059: DEC
63060: ST_TO_ADDR
63061: LD_VAR 0 4
63065: PUSH
63066: FOR_TO
63067: IFFALSE 63121
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
63069: LD_ADDR_EXP 79
63073: PUSH
63074: LD_EXP 79
63078: PPUSH
63079: LD_VAR 0 2
63083: PUSH
63084: LD_EXP 79
63088: PUSH
63089: LD_VAR 0 2
63093: ARRAY
63094: PUSH
63095: LD_INT 1
63097: PLUS
63098: PUSH
63099: EMPTY
63100: LIST
63101: LIST
63102: PPUSH
63103: LD_VAR 0 6
63107: PUSH
63108: LD_VAR 0 3
63112: ARRAY
63113: PPUSH
63114: CALL 18504 0 3
63118: ST_TO_ADDR
63119: GO 63066
63121: POP
63122: POP
// end ;
63123: GO 62366
63125: POP
63126: POP
// end ;
63127: LD_VAR 0 1
63131: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
63132: LD_INT 0
63134: PPUSH
63135: PPUSH
63136: PPUSH
63137: PPUSH
63138: PPUSH
63139: PPUSH
63140: PPUSH
63141: PPUSH
63142: PPUSH
63143: PPUSH
// if not mc_bases then
63144: LD_EXP 65
63148: NOT
63149: IFFALSE 63153
// exit ;
63151: GO 64903
// for i = 1 to mc_bases do
63153: LD_ADDR_VAR 0 2
63157: PUSH
63158: DOUBLE
63159: LD_INT 1
63161: DEC
63162: ST_TO_ADDR
63163: LD_EXP 65
63167: PUSH
63168: FOR_TO
63169: IFFALSE 64901
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
63171: LD_EXP 65
63175: PUSH
63176: LD_VAR 0 2
63180: ARRAY
63181: NOT
63182: PUSH
63183: LD_EXP 72
63187: PUSH
63188: LD_VAR 0 2
63192: ARRAY
63193: OR
63194: IFFALSE 63198
// continue ;
63196: GO 63168
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
63198: LD_EXP 81
63202: PUSH
63203: LD_VAR 0 2
63207: ARRAY
63208: NOT
63209: PUSH
63210: LD_EXP 82
63214: PUSH
63215: LD_VAR 0 2
63219: ARRAY
63220: AND
63221: IFFALSE 63259
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63223: LD_ADDR_EXP 82
63227: PUSH
63228: LD_EXP 82
63232: PPUSH
63233: LD_VAR 0 2
63237: PPUSH
63238: EMPTY
63239: PPUSH
63240: CALL_OW 1
63244: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
63245: LD_VAR 0 2
63249: PPUSH
63250: LD_INT 107
63252: PPUSH
63253: CALL 54133 0 2
// continue ;
63257: GO 63168
// end ; target := [ ] ;
63259: LD_ADDR_VAR 0 6
63263: PUSH
63264: EMPTY
63265: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
63266: LD_ADDR_VAR 0 3
63270: PUSH
63271: DOUBLE
63272: LD_EXP 81
63276: PUSH
63277: LD_VAR 0 2
63281: ARRAY
63282: INC
63283: ST_TO_ADDR
63284: LD_INT 1
63286: PUSH
63287: FOR_DOWNTO
63288: IFFALSE 63548
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
63290: LD_EXP 81
63294: PUSH
63295: LD_VAR 0 2
63299: ARRAY
63300: PUSH
63301: LD_VAR 0 3
63305: ARRAY
63306: PUSH
63307: LD_INT 2
63309: ARRAY
63310: PPUSH
63311: LD_EXP 81
63315: PUSH
63316: LD_VAR 0 2
63320: ARRAY
63321: PUSH
63322: LD_VAR 0 3
63326: ARRAY
63327: PUSH
63328: LD_INT 3
63330: ARRAY
63331: PPUSH
63332: CALL_OW 488
63336: PUSH
63337: LD_EXP 81
63341: PUSH
63342: LD_VAR 0 2
63346: ARRAY
63347: PUSH
63348: LD_VAR 0 3
63352: ARRAY
63353: PUSH
63354: LD_INT 2
63356: ARRAY
63357: PPUSH
63358: LD_EXP 81
63362: PUSH
63363: LD_VAR 0 2
63367: ARRAY
63368: PUSH
63369: LD_VAR 0 3
63373: ARRAY
63374: PUSH
63375: LD_INT 3
63377: ARRAY
63378: PPUSH
63379: CALL_OW 284
63383: PUSH
63384: LD_INT 0
63386: EQUAL
63387: AND
63388: IFFALSE 63443
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
63390: LD_ADDR_VAR 0 5
63394: PUSH
63395: LD_EXP 81
63399: PUSH
63400: LD_VAR 0 2
63404: ARRAY
63405: PPUSH
63406: LD_VAR 0 3
63410: PPUSH
63411: CALL_OW 3
63415: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
63416: LD_ADDR_EXP 81
63420: PUSH
63421: LD_EXP 81
63425: PPUSH
63426: LD_VAR 0 2
63430: PPUSH
63431: LD_VAR 0 5
63435: PPUSH
63436: CALL_OW 1
63440: ST_TO_ADDR
// continue ;
63441: GO 63287
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
63443: LD_EXP 65
63447: PUSH
63448: LD_VAR 0 2
63452: ARRAY
63453: PUSH
63454: LD_INT 1
63456: ARRAY
63457: PPUSH
63458: CALL_OW 255
63462: PPUSH
63463: LD_EXP 81
63467: PUSH
63468: LD_VAR 0 2
63472: ARRAY
63473: PUSH
63474: LD_VAR 0 3
63478: ARRAY
63479: PUSH
63480: LD_INT 2
63482: ARRAY
63483: PPUSH
63484: LD_EXP 81
63488: PUSH
63489: LD_VAR 0 2
63493: ARRAY
63494: PUSH
63495: LD_VAR 0 3
63499: ARRAY
63500: PUSH
63501: LD_INT 3
63503: ARRAY
63504: PPUSH
63505: LD_INT 30
63507: PPUSH
63508: CALL 19400 0 4
63512: PUSH
63513: LD_INT 4
63515: ARRAY
63516: PUSH
63517: LD_INT 0
63519: EQUAL
63520: IFFALSE 63546
// begin target := mc_crates [ i ] [ j ] ;
63522: LD_ADDR_VAR 0 6
63526: PUSH
63527: LD_EXP 81
63531: PUSH
63532: LD_VAR 0 2
63536: ARRAY
63537: PUSH
63538: LD_VAR 0 3
63542: ARRAY
63543: ST_TO_ADDR
// break ;
63544: GO 63548
// end ; end ;
63546: GO 63287
63548: POP
63549: POP
// if not target then
63550: LD_VAR 0 6
63554: NOT
63555: IFFALSE 63559
// continue ;
63557: GO 63168
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
63559: LD_ADDR_VAR 0 7
63563: PUSH
63564: LD_EXP 84
63568: PUSH
63569: LD_VAR 0 2
63573: ARRAY
63574: PPUSH
63575: LD_INT 2
63577: PUSH
63578: LD_INT 3
63580: PUSH
63581: LD_INT 58
63583: PUSH
63584: EMPTY
63585: LIST
63586: PUSH
63587: EMPTY
63588: LIST
63589: LIST
63590: PUSH
63591: LD_INT 61
63593: PUSH
63594: EMPTY
63595: LIST
63596: PUSH
63597: LD_INT 33
63599: PUSH
63600: LD_INT 5
63602: PUSH
63603: EMPTY
63604: LIST
63605: LIST
63606: PUSH
63607: LD_INT 33
63609: PUSH
63610: LD_INT 3
63612: PUSH
63613: EMPTY
63614: LIST
63615: LIST
63616: PUSH
63617: EMPTY
63618: LIST
63619: LIST
63620: LIST
63621: LIST
63622: LIST
63623: PUSH
63624: LD_INT 2
63626: PUSH
63627: LD_INT 34
63629: PUSH
63630: LD_INT 32
63632: PUSH
63633: EMPTY
63634: LIST
63635: LIST
63636: PUSH
63637: LD_INT 34
63639: PUSH
63640: LD_INT 51
63642: PUSH
63643: EMPTY
63644: LIST
63645: LIST
63646: PUSH
63647: LD_INT 34
63649: PUSH
63650: LD_INT 12
63652: PUSH
63653: EMPTY
63654: LIST
63655: LIST
63656: PUSH
63657: EMPTY
63658: LIST
63659: LIST
63660: LIST
63661: LIST
63662: PUSH
63663: EMPTY
63664: LIST
63665: LIST
63666: PPUSH
63667: CALL_OW 72
63671: ST_TO_ADDR
// if not cargo then
63672: LD_VAR 0 7
63676: NOT
63677: IFFALSE 64320
// begin if mc_crates_collector [ i ] < 5 then
63679: LD_EXP 82
63683: PUSH
63684: LD_VAR 0 2
63688: ARRAY
63689: PUSH
63690: LD_INT 5
63692: LESS
63693: IFFALSE 64059
// begin if mc_ape [ i ] then
63695: LD_EXP 94
63699: PUSH
63700: LD_VAR 0 2
63704: ARRAY
63705: IFFALSE 63752
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
63707: LD_ADDR_VAR 0 5
63711: PUSH
63712: LD_EXP 94
63716: PUSH
63717: LD_VAR 0 2
63721: ARRAY
63722: PPUSH
63723: LD_INT 25
63725: PUSH
63726: LD_INT 16
63728: PUSH
63729: EMPTY
63730: LIST
63731: LIST
63732: PUSH
63733: LD_INT 24
63735: PUSH
63736: LD_INT 750
63738: PUSH
63739: EMPTY
63740: LIST
63741: LIST
63742: PUSH
63743: EMPTY
63744: LIST
63745: LIST
63746: PPUSH
63747: CALL_OW 72
63751: ST_TO_ADDR
// if not tmp then
63752: LD_VAR 0 5
63756: NOT
63757: IFFALSE 63804
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
63759: LD_ADDR_VAR 0 5
63763: PUSH
63764: LD_EXP 65
63768: PUSH
63769: LD_VAR 0 2
63773: ARRAY
63774: PPUSH
63775: LD_INT 25
63777: PUSH
63778: LD_INT 2
63780: PUSH
63781: EMPTY
63782: LIST
63783: LIST
63784: PUSH
63785: LD_INT 24
63787: PUSH
63788: LD_INT 750
63790: PUSH
63791: EMPTY
63792: LIST
63793: LIST
63794: PUSH
63795: EMPTY
63796: LIST
63797: LIST
63798: PPUSH
63799: CALL_OW 72
63803: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
63804: LD_EXP 94
63808: PUSH
63809: LD_VAR 0 2
63813: ARRAY
63814: PUSH
63815: LD_EXP 65
63819: PUSH
63820: LD_VAR 0 2
63824: ARRAY
63825: PPUSH
63826: LD_INT 25
63828: PUSH
63829: LD_INT 2
63831: PUSH
63832: EMPTY
63833: LIST
63834: LIST
63835: PUSH
63836: LD_INT 24
63838: PUSH
63839: LD_INT 750
63841: PUSH
63842: EMPTY
63843: LIST
63844: LIST
63845: PUSH
63846: EMPTY
63847: LIST
63848: LIST
63849: PPUSH
63850: CALL_OW 72
63854: AND
63855: PUSH
63856: LD_VAR 0 5
63860: PUSH
63861: LD_INT 5
63863: LESS
63864: AND
63865: IFFALSE 63947
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
63867: LD_ADDR_VAR 0 3
63871: PUSH
63872: LD_EXP 65
63876: PUSH
63877: LD_VAR 0 2
63881: ARRAY
63882: PPUSH
63883: LD_INT 25
63885: PUSH
63886: LD_INT 2
63888: PUSH
63889: EMPTY
63890: LIST
63891: LIST
63892: PUSH
63893: LD_INT 24
63895: PUSH
63896: LD_INT 750
63898: PUSH
63899: EMPTY
63900: LIST
63901: LIST
63902: PUSH
63903: EMPTY
63904: LIST
63905: LIST
63906: PPUSH
63907: CALL_OW 72
63911: PUSH
63912: FOR_IN
63913: IFFALSE 63945
// begin tmp := tmp union j ;
63915: LD_ADDR_VAR 0 5
63919: PUSH
63920: LD_VAR 0 5
63924: PUSH
63925: LD_VAR 0 3
63929: UNION
63930: ST_TO_ADDR
// if tmp >= 5 then
63931: LD_VAR 0 5
63935: PUSH
63936: LD_INT 5
63938: GREATEREQUAL
63939: IFFALSE 63943
// break ;
63941: GO 63945
// end ;
63943: GO 63912
63945: POP
63946: POP
// end ; if not tmp then
63947: LD_VAR 0 5
63951: NOT
63952: IFFALSE 63956
// continue ;
63954: GO 63168
// for j in tmp do
63956: LD_ADDR_VAR 0 3
63960: PUSH
63961: LD_VAR 0 5
63965: PUSH
63966: FOR_IN
63967: IFFALSE 64057
// if not GetTag ( j ) then
63969: LD_VAR 0 3
63973: PPUSH
63974: CALL_OW 110
63978: NOT
63979: IFFALSE 64055
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
63981: LD_ADDR_EXP 82
63985: PUSH
63986: LD_EXP 82
63990: PPUSH
63991: LD_VAR 0 2
63995: PUSH
63996: LD_EXP 82
64000: PUSH
64001: LD_VAR 0 2
64005: ARRAY
64006: PUSH
64007: LD_INT 1
64009: PLUS
64010: PUSH
64011: EMPTY
64012: LIST
64013: LIST
64014: PPUSH
64015: LD_VAR 0 3
64019: PPUSH
64020: CALL 18504 0 3
64024: ST_TO_ADDR
// SetTag ( j , 107 ) ;
64025: LD_VAR 0 3
64029: PPUSH
64030: LD_INT 107
64032: PPUSH
64033: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
64037: LD_EXP 82
64041: PUSH
64042: LD_VAR 0 2
64046: ARRAY
64047: PUSH
64048: LD_INT 5
64050: GREATEREQUAL
64051: IFFALSE 64055
// break ;
64053: GO 64057
// end ;
64055: GO 63966
64057: POP
64058: POP
// end ; if mc_crates_collector [ i ] and target then
64059: LD_EXP 82
64063: PUSH
64064: LD_VAR 0 2
64068: ARRAY
64069: PUSH
64070: LD_VAR 0 6
64074: AND
64075: IFFALSE 64318
// begin if mc_crates_collector [ i ] < target [ 1 ] then
64077: LD_EXP 82
64081: PUSH
64082: LD_VAR 0 2
64086: ARRAY
64087: PUSH
64088: LD_VAR 0 6
64092: PUSH
64093: LD_INT 1
64095: ARRAY
64096: LESS
64097: IFFALSE 64117
// tmp := mc_crates_collector [ i ] else
64099: LD_ADDR_VAR 0 5
64103: PUSH
64104: LD_EXP 82
64108: PUSH
64109: LD_VAR 0 2
64113: ARRAY
64114: ST_TO_ADDR
64115: GO 64131
// tmp := target [ 1 ] ;
64117: LD_ADDR_VAR 0 5
64121: PUSH
64122: LD_VAR 0 6
64126: PUSH
64127: LD_INT 1
64129: ARRAY
64130: ST_TO_ADDR
// k := 0 ;
64131: LD_ADDR_VAR 0 4
64135: PUSH
64136: LD_INT 0
64138: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
64139: LD_ADDR_VAR 0 3
64143: PUSH
64144: LD_EXP 82
64148: PUSH
64149: LD_VAR 0 2
64153: ARRAY
64154: PUSH
64155: FOR_IN
64156: IFFALSE 64316
// begin k := k + 1 ;
64158: LD_ADDR_VAR 0 4
64162: PUSH
64163: LD_VAR 0 4
64167: PUSH
64168: LD_INT 1
64170: PLUS
64171: ST_TO_ADDR
// if k > tmp then
64172: LD_VAR 0 4
64176: PUSH
64177: LD_VAR 0 5
64181: GREATER
64182: IFFALSE 64186
// break ;
64184: GO 64316
// if not GetClass ( j ) in [ 2 , 16 ] then
64186: LD_VAR 0 3
64190: PPUSH
64191: CALL_OW 257
64195: PUSH
64196: LD_INT 2
64198: PUSH
64199: LD_INT 16
64201: PUSH
64202: EMPTY
64203: LIST
64204: LIST
64205: IN
64206: NOT
64207: IFFALSE 64260
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
64209: LD_ADDR_EXP 82
64213: PUSH
64214: LD_EXP 82
64218: PPUSH
64219: LD_VAR 0 2
64223: PPUSH
64224: LD_EXP 82
64228: PUSH
64229: LD_VAR 0 2
64233: ARRAY
64234: PUSH
64235: LD_VAR 0 3
64239: DIFF
64240: PPUSH
64241: CALL_OW 1
64245: ST_TO_ADDR
// SetTag ( j , 0 ) ;
64246: LD_VAR 0 3
64250: PPUSH
64251: LD_INT 0
64253: PPUSH
64254: CALL_OW 109
// continue ;
64258: GO 64155
// end ; if IsInUnit ( j ) then
64260: LD_VAR 0 3
64264: PPUSH
64265: CALL_OW 310
64269: IFFALSE 64280
// ComExitBuilding ( j ) ;
64271: LD_VAR 0 3
64275: PPUSH
64276: CALL_OW 122
// wait ( 3 ) ;
64280: LD_INT 3
64282: PPUSH
64283: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
64287: LD_VAR 0 3
64291: PPUSH
64292: LD_VAR 0 6
64296: PUSH
64297: LD_INT 2
64299: ARRAY
64300: PPUSH
64301: LD_VAR 0 6
64305: PUSH
64306: LD_INT 3
64308: ARRAY
64309: PPUSH
64310: CALL_OW 117
// end ;
64314: GO 64155
64316: POP
64317: POP
// end ; end else
64318: GO 64899
// begin for j in cargo do
64320: LD_ADDR_VAR 0 3
64324: PUSH
64325: LD_VAR 0 7
64329: PUSH
64330: FOR_IN
64331: IFFALSE 64897
// begin if GetTag ( j ) <> 0 then
64333: LD_VAR 0 3
64337: PPUSH
64338: CALL_OW 110
64342: PUSH
64343: LD_INT 0
64345: NONEQUAL
64346: IFFALSE 64350
// continue ;
64348: GO 64330
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
64350: LD_VAR 0 3
64354: PPUSH
64355: CALL_OW 256
64359: PUSH
64360: LD_INT 1000
64362: LESS
64363: PUSH
64364: LD_VAR 0 3
64368: PPUSH
64369: LD_EXP 89
64373: PUSH
64374: LD_VAR 0 2
64378: ARRAY
64379: PPUSH
64380: CALL_OW 308
64384: NOT
64385: AND
64386: IFFALSE 64408
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64388: LD_VAR 0 3
64392: PPUSH
64393: LD_EXP 89
64397: PUSH
64398: LD_VAR 0 2
64402: ARRAY
64403: PPUSH
64404: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
64408: LD_VAR 0 3
64412: PPUSH
64413: CALL_OW 256
64417: PUSH
64418: LD_INT 1000
64420: LESS
64421: PUSH
64422: LD_VAR 0 3
64426: PPUSH
64427: LD_EXP 89
64431: PUSH
64432: LD_VAR 0 2
64436: ARRAY
64437: PPUSH
64438: CALL_OW 308
64442: AND
64443: IFFALSE 64447
// continue ;
64445: GO 64330
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
64447: LD_VAR 0 3
64451: PPUSH
64452: CALL_OW 262
64456: PUSH
64457: LD_INT 2
64459: EQUAL
64460: PUSH
64461: LD_VAR 0 3
64465: PPUSH
64466: CALL_OW 261
64470: PUSH
64471: LD_INT 15
64473: LESS
64474: AND
64475: IFFALSE 64479
// continue ;
64477: GO 64330
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
64479: LD_VAR 0 3
64483: PPUSH
64484: CALL_OW 262
64488: PUSH
64489: LD_INT 1
64491: EQUAL
64492: PUSH
64493: LD_VAR 0 3
64497: PPUSH
64498: CALL_OW 261
64502: PUSH
64503: LD_INT 10
64505: LESS
64506: AND
64507: IFFALSE 64836
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64509: LD_ADDR_VAR 0 8
64513: PUSH
64514: LD_EXP 65
64518: PUSH
64519: LD_VAR 0 2
64523: ARRAY
64524: PPUSH
64525: LD_INT 2
64527: PUSH
64528: LD_INT 30
64530: PUSH
64531: LD_INT 0
64533: PUSH
64534: EMPTY
64535: LIST
64536: LIST
64537: PUSH
64538: LD_INT 30
64540: PUSH
64541: LD_INT 1
64543: PUSH
64544: EMPTY
64545: LIST
64546: LIST
64547: PUSH
64548: EMPTY
64549: LIST
64550: LIST
64551: LIST
64552: PPUSH
64553: CALL_OW 72
64557: ST_TO_ADDR
// if not depot then
64558: LD_VAR 0 8
64562: NOT
64563: IFFALSE 64567
// continue ;
64565: GO 64330
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
64567: LD_VAR 0 3
64571: PPUSH
64572: LD_VAR 0 8
64576: PPUSH
64577: LD_VAR 0 3
64581: PPUSH
64582: CALL_OW 74
64586: PPUSH
64587: CALL_OW 296
64591: PUSH
64592: LD_INT 6
64594: LESS
64595: IFFALSE 64611
// SetFuel ( j , 100 ) else
64597: LD_VAR 0 3
64601: PPUSH
64602: LD_INT 100
64604: PPUSH
64605: CALL_OW 240
64609: GO 64836
// if GetFuel ( j ) = 0 then
64611: LD_VAR 0 3
64615: PPUSH
64616: CALL_OW 261
64620: PUSH
64621: LD_INT 0
64623: EQUAL
64624: IFFALSE 64836
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
64626: LD_ADDR_EXP 84
64630: PUSH
64631: LD_EXP 84
64635: PPUSH
64636: LD_VAR 0 2
64640: PPUSH
64641: LD_EXP 84
64645: PUSH
64646: LD_VAR 0 2
64650: ARRAY
64651: PUSH
64652: LD_VAR 0 3
64656: DIFF
64657: PPUSH
64658: CALL_OW 1
64662: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
64663: LD_VAR 0 3
64667: PPUSH
64668: CALL_OW 263
64672: PUSH
64673: LD_INT 1
64675: EQUAL
64676: IFFALSE 64692
// ComExitVehicle ( IsInUnit ( j ) ) ;
64678: LD_VAR 0 3
64682: PPUSH
64683: CALL_OW 310
64687: PPUSH
64688: CALL_OW 121
// if GetControl ( j ) = control_remote then
64692: LD_VAR 0 3
64696: PPUSH
64697: CALL_OW 263
64701: PUSH
64702: LD_INT 2
64704: EQUAL
64705: IFFALSE 64716
// ComUnlink ( j ) ;
64707: LD_VAR 0 3
64711: PPUSH
64712: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
64716: LD_ADDR_VAR 0 9
64720: PUSH
64721: LD_VAR 0 2
64725: PPUSH
64726: LD_INT 3
64728: PPUSH
64729: CALL 74189 0 2
64733: ST_TO_ADDR
// if fac then
64734: LD_VAR 0 9
64738: IFFALSE 64834
// begin for k in fac do
64740: LD_ADDR_VAR 0 4
64744: PUSH
64745: LD_VAR 0 9
64749: PUSH
64750: FOR_IN
64751: IFFALSE 64832
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
64753: LD_ADDR_VAR 0 10
64757: PUSH
64758: LD_VAR 0 9
64762: PPUSH
64763: LD_VAR 0 3
64767: PPUSH
64768: CALL_OW 265
64772: PPUSH
64773: LD_VAR 0 3
64777: PPUSH
64778: CALL_OW 262
64782: PPUSH
64783: LD_VAR 0 3
64787: PPUSH
64788: CALL_OW 263
64792: PPUSH
64793: LD_VAR 0 3
64797: PPUSH
64798: CALL_OW 264
64802: PPUSH
64803: CALL 16036 0 5
64807: ST_TO_ADDR
// if components then
64808: LD_VAR 0 10
64812: IFFALSE 64830
// begin MC_InsertProduceList ( i , components ) ;
64814: LD_VAR 0 2
64818: PPUSH
64819: LD_VAR 0 10
64823: PPUSH
64824: CALL 73734 0 2
// break ;
64828: GO 64832
// end ; end ;
64830: GO 64750
64832: POP
64833: POP
// end ; continue ;
64834: GO 64330
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
64836: LD_VAR 0 3
64840: PPUSH
64841: LD_INT 1
64843: PPUSH
64844: CALL_OW 289
64848: PUSH
64849: LD_INT 100
64851: LESS
64852: PUSH
64853: LD_VAR 0 3
64857: PPUSH
64858: CALL_OW 314
64862: NOT
64863: AND
64864: IFFALSE 64893
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
64866: LD_VAR 0 3
64870: PPUSH
64871: LD_VAR 0 6
64875: PUSH
64876: LD_INT 2
64878: ARRAY
64879: PPUSH
64880: LD_VAR 0 6
64884: PUSH
64885: LD_INT 3
64887: ARRAY
64888: PPUSH
64889: CALL_OW 117
// break ;
64893: GO 64897
// end ;
64895: GO 64330
64897: POP
64898: POP
// end ; end ;
64899: GO 63168
64901: POP
64902: POP
// end ;
64903: LD_VAR 0 1
64907: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
64908: LD_INT 0
64910: PPUSH
64911: PPUSH
64912: PPUSH
64913: PPUSH
// if not mc_bases then
64914: LD_EXP 65
64918: NOT
64919: IFFALSE 64923
// exit ;
64921: GO 65084
// for i = 1 to mc_bases do
64923: LD_ADDR_VAR 0 2
64927: PUSH
64928: DOUBLE
64929: LD_INT 1
64931: DEC
64932: ST_TO_ADDR
64933: LD_EXP 65
64937: PUSH
64938: FOR_TO
64939: IFFALSE 65082
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
64941: LD_ADDR_VAR 0 4
64945: PUSH
64946: LD_EXP 84
64950: PUSH
64951: LD_VAR 0 2
64955: ARRAY
64956: PUSH
64957: LD_EXP 87
64961: PUSH
64962: LD_VAR 0 2
64966: ARRAY
64967: UNION
64968: PPUSH
64969: LD_INT 33
64971: PUSH
64972: LD_INT 2
64974: PUSH
64975: EMPTY
64976: LIST
64977: LIST
64978: PPUSH
64979: CALL_OW 72
64983: ST_TO_ADDR
// if tmp then
64984: LD_VAR 0 4
64988: IFFALSE 65080
// for j in tmp do
64990: LD_ADDR_VAR 0 3
64994: PUSH
64995: LD_VAR 0 4
64999: PUSH
65000: FOR_IN
65001: IFFALSE 65078
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
65003: LD_VAR 0 3
65007: PPUSH
65008: CALL_OW 312
65012: NOT
65013: PUSH
65014: LD_VAR 0 3
65018: PPUSH
65019: CALL_OW 256
65023: PUSH
65024: LD_INT 250
65026: GREATEREQUAL
65027: AND
65028: IFFALSE 65041
// Connect ( j ) else
65030: LD_VAR 0 3
65034: PPUSH
65035: CALL 21437 0 1
65039: GO 65076
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
65041: LD_VAR 0 3
65045: PPUSH
65046: CALL_OW 256
65050: PUSH
65051: LD_INT 250
65053: LESS
65054: PUSH
65055: LD_VAR 0 3
65059: PPUSH
65060: CALL_OW 312
65064: AND
65065: IFFALSE 65076
// ComUnlink ( j ) ;
65067: LD_VAR 0 3
65071: PPUSH
65072: CALL_OW 136
65076: GO 65000
65078: POP
65079: POP
// end ;
65080: GO 64938
65082: POP
65083: POP
// end ;
65084: LD_VAR 0 1
65088: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
65089: LD_INT 0
65091: PPUSH
65092: PPUSH
65093: PPUSH
65094: PPUSH
65095: PPUSH
// if not mc_bases then
65096: LD_EXP 65
65100: NOT
65101: IFFALSE 65105
// exit ;
65103: GO 65550
// for i = 1 to mc_bases do
65105: LD_ADDR_VAR 0 2
65109: PUSH
65110: DOUBLE
65111: LD_INT 1
65113: DEC
65114: ST_TO_ADDR
65115: LD_EXP 65
65119: PUSH
65120: FOR_TO
65121: IFFALSE 65548
// begin if not mc_produce [ i ] then
65123: LD_EXP 86
65127: PUSH
65128: LD_VAR 0 2
65132: ARRAY
65133: NOT
65134: IFFALSE 65138
// continue ;
65136: GO 65120
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65138: LD_ADDR_VAR 0 5
65142: PUSH
65143: LD_EXP 65
65147: PUSH
65148: LD_VAR 0 2
65152: ARRAY
65153: PPUSH
65154: LD_INT 30
65156: PUSH
65157: LD_INT 3
65159: PUSH
65160: EMPTY
65161: LIST
65162: LIST
65163: PPUSH
65164: CALL_OW 72
65168: ST_TO_ADDR
// if not fac then
65169: LD_VAR 0 5
65173: NOT
65174: IFFALSE 65178
// continue ;
65176: GO 65120
// for j in fac do
65178: LD_ADDR_VAR 0 3
65182: PUSH
65183: LD_VAR 0 5
65187: PUSH
65188: FOR_IN
65189: IFFALSE 65544
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
65191: LD_VAR 0 3
65195: PPUSH
65196: CALL_OW 461
65200: PUSH
65201: LD_INT 2
65203: NONEQUAL
65204: PUSH
65205: LD_VAR 0 3
65209: PPUSH
65210: LD_INT 15
65212: PPUSH
65213: CALL 21097 0 2
65217: PUSH
65218: LD_INT 4
65220: ARRAY
65221: OR
65222: IFFALSE 65226
// continue ;
65224: GO 65188
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
65226: LD_VAR 0 3
65230: PPUSH
65231: LD_EXP 86
65235: PUSH
65236: LD_VAR 0 2
65240: ARRAY
65241: PUSH
65242: LD_INT 1
65244: ARRAY
65245: PUSH
65246: LD_INT 1
65248: ARRAY
65249: PPUSH
65250: LD_EXP 86
65254: PUSH
65255: LD_VAR 0 2
65259: ARRAY
65260: PUSH
65261: LD_INT 1
65263: ARRAY
65264: PUSH
65265: LD_INT 2
65267: ARRAY
65268: PPUSH
65269: LD_EXP 86
65273: PUSH
65274: LD_VAR 0 2
65278: ARRAY
65279: PUSH
65280: LD_INT 1
65282: ARRAY
65283: PUSH
65284: LD_INT 3
65286: ARRAY
65287: PPUSH
65288: LD_EXP 86
65292: PUSH
65293: LD_VAR 0 2
65297: ARRAY
65298: PUSH
65299: LD_INT 1
65301: ARRAY
65302: PUSH
65303: LD_INT 4
65305: ARRAY
65306: PPUSH
65307: CALL_OW 448
65311: PUSH
65312: LD_VAR 0 3
65316: PPUSH
65317: LD_EXP 86
65321: PUSH
65322: LD_VAR 0 2
65326: ARRAY
65327: PUSH
65328: LD_INT 1
65330: ARRAY
65331: PUSH
65332: LD_INT 1
65334: ARRAY
65335: PUSH
65336: LD_EXP 86
65340: PUSH
65341: LD_VAR 0 2
65345: ARRAY
65346: PUSH
65347: LD_INT 1
65349: ARRAY
65350: PUSH
65351: LD_INT 2
65353: ARRAY
65354: PUSH
65355: LD_EXP 86
65359: PUSH
65360: LD_VAR 0 2
65364: ARRAY
65365: PUSH
65366: LD_INT 1
65368: ARRAY
65369: PUSH
65370: LD_INT 3
65372: ARRAY
65373: PUSH
65374: LD_EXP 86
65378: PUSH
65379: LD_VAR 0 2
65383: ARRAY
65384: PUSH
65385: LD_INT 1
65387: ARRAY
65388: PUSH
65389: LD_INT 4
65391: ARRAY
65392: PUSH
65393: EMPTY
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: PPUSH
65399: CALL 24768 0 2
65403: AND
65404: IFFALSE 65542
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
65406: LD_VAR 0 3
65410: PPUSH
65411: LD_EXP 86
65415: PUSH
65416: LD_VAR 0 2
65420: ARRAY
65421: PUSH
65422: LD_INT 1
65424: ARRAY
65425: PUSH
65426: LD_INT 1
65428: ARRAY
65429: PPUSH
65430: LD_EXP 86
65434: PUSH
65435: LD_VAR 0 2
65439: ARRAY
65440: PUSH
65441: LD_INT 1
65443: ARRAY
65444: PUSH
65445: LD_INT 2
65447: ARRAY
65448: PPUSH
65449: LD_EXP 86
65453: PUSH
65454: LD_VAR 0 2
65458: ARRAY
65459: PUSH
65460: LD_INT 1
65462: ARRAY
65463: PUSH
65464: LD_INT 3
65466: ARRAY
65467: PPUSH
65468: LD_EXP 86
65472: PUSH
65473: LD_VAR 0 2
65477: ARRAY
65478: PUSH
65479: LD_INT 1
65481: ARRAY
65482: PUSH
65483: LD_INT 4
65485: ARRAY
65486: PPUSH
65487: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
65491: LD_ADDR_VAR 0 4
65495: PUSH
65496: LD_EXP 86
65500: PUSH
65501: LD_VAR 0 2
65505: ARRAY
65506: PPUSH
65507: LD_INT 1
65509: PPUSH
65510: CALL_OW 3
65514: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
65515: LD_ADDR_EXP 86
65519: PUSH
65520: LD_EXP 86
65524: PPUSH
65525: LD_VAR 0 2
65529: PPUSH
65530: LD_VAR 0 4
65534: PPUSH
65535: CALL_OW 1
65539: ST_TO_ADDR
// break ;
65540: GO 65544
// end ; end ;
65542: GO 65188
65544: POP
65545: POP
// end ;
65546: GO 65120
65548: POP
65549: POP
// end ;
65550: LD_VAR 0 1
65554: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
65555: LD_INT 0
65557: PPUSH
65558: PPUSH
65559: PPUSH
// if not mc_bases then
65560: LD_EXP 65
65564: NOT
65565: IFFALSE 65569
// exit ;
65567: GO 65658
// for i = 1 to mc_bases do
65569: LD_ADDR_VAR 0 2
65573: PUSH
65574: DOUBLE
65575: LD_INT 1
65577: DEC
65578: ST_TO_ADDR
65579: LD_EXP 65
65583: PUSH
65584: FOR_TO
65585: IFFALSE 65656
// begin if mc_attack [ i ] then
65587: LD_EXP 85
65591: PUSH
65592: LD_VAR 0 2
65596: ARRAY
65597: IFFALSE 65654
// begin tmp := mc_attack [ i ] [ 1 ] ;
65599: LD_ADDR_VAR 0 3
65603: PUSH
65604: LD_EXP 85
65608: PUSH
65609: LD_VAR 0 2
65613: ARRAY
65614: PUSH
65615: LD_INT 1
65617: ARRAY
65618: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
65619: LD_ADDR_EXP 85
65623: PUSH
65624: LD_EXP 85
65628: PPUSH
65629: LD_VAR 0 2
65633: PPUSH
65634: EMPTY
65635: PPUSH
65636: CALL_OW 1
65640: ST_TO_ADDR
// Attack ( tmp ) ;
65641: LD_VAR 0 3
65645: PPUSH
65646: CALL 95038 0 1
// exit ;
65650: POP
65651: POP
65652: GO 65658
// end ; end ;
65654: GO 65584
65656: POP
65657: POP
// end ;
65658: LD_VAR 0 1
65662: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
65663: LD_INT 0
65665: PPUSH
65666: PPUSH
65667: PPUSH
65668: PPUSH
65669: PPUSH
65670: PPUSH
65671: PPUSH
// if not mc_bases then
65672: LD_EXP 65
65676: NOT
65677: IFFALSE 65681
// exit ;
65679: GO 66263
// for i = 1 to mc_bases do
65681: LD_ADDR_VAR 0 2
65685: PUSH
65686: DOUBLE
65687: LD_INT 1
65689: DEC
65690: ST_TO_ADDR
65691: LD_EXP 65
65695: PUSH
65696: FOR_TO
65697: IFFALSE 66261
// begin if not mc_bases [ i ] then
65699: LD_EXP 65
65703: PUSH
65704: LD_VAR 0 2
65708: ARRAY
65709: NOT
65710: IFFALSE 65714
// continue ;
65712: GO 65696
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
65714: LD_ADDR_VAR 0 7
65718: PUSH
65719: LD_EXP 65
65723: PUSH
65724: LD_VAR 0 2
65728: ARRAY
65729: PUSH
65730: LD_INT 1
65732: ARRAY
65733: PPUSH
65734: CALL 15340 0 1
65738: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
65739: LD_ADDR_EXP 88
65743: PUSH
65744: LD_EXP 88
65748: PPUSH
65749: LD_VAR 0 2
65753: PPUSH
65754: LD_EXP 65
65758: PUSH
65759: LD_VAR 0 2
65763: ARRAY
65764: PUSH
65765: LD_INT 1
65767: ARRAY
65768: PPUSH
65769: CALL_OW 255
65773: PPUSH
65774: LD_EXP 90
65778: PUSH
65779: LD_VAR 0 2
65783: ARRAY
65784: PPUSH
65785: CALL 15305 0 2
65789: PPUSH
65790: CALL_OW 1
65794: ST_TO_ADDR
// if not mc_scan [ i ] then
65795: LD_EXP 88
65799: PUSH
65800: LD_VAR 0 2
65804: ARRAY
65805: NOT
65806: IFFALSE 65961
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65808: LD_ADDR_VAR 0 4
65812: PUSH
65813: LD_EXP 65
65817: PUSH
65818: LD_VAR 0 2
65822: ARRAY
65823: PPUSH
65824: LD_INT 2
65826: PUSH
65827: LD_INT 25
65829: PUSH
65830: LD_INT 5
65832: PUSH
65833: EMPTY
65834: LIST
65835: LIST
65836: PUSH
65837: LD_INT 25
65839: PUSH
65840: LD_INT 8
65842: PUSH
65843: EMPTY
65844: LIST
65845: LIST
65846: PUSH
65847: LD_INT 25
65849: PUSH
65850: LD_INT 9
65852: PUSH
65853: EMPTY
65854: LIST
65855: LIST
65856: PUSH
65857: EMPTY
65858: LIST
65859: LIST
65860: LIST
65861: LIST
65862: PPUSH
65863: CALL_OW 72
65867: ST_TO_ADDR
// if not tmp then
65868: LD_VAR 0 4
65872: NOT
65873: IFFALSE 65877
// continue ;
65875: GO 65696
// for j in tmp do
65877: LD_ADDR_VAR 0 3
65881: PUSH
65882: LD_VAR 0 4
65886: PUSH
65887: FOR_IN
65888: IFFALSE 65959
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
65890: LD_VAR 0 3
65894: PPUSH
65895: CALL_OW 310
65899: PPUSH
65900: CALL_OW 266
65904: PUSH
65905: LD_INT 5
65907: EQUAL
65908: PUSH
65909: LD_VAR 0 3
65913: PPUSH
65914: CALL_OW 257
65918: PUSH
65919: LD_INT 1
65921: EQUAL
65922: AND
65923: PUSH
65924: LD_VAR 0 3
65928: PPUSH
65929: CALL_OW 459
65933: NOT
65934: AND
65935: PUSH
65936: LD_VAR 0 7
65940: AND
65941: IFFALSE 65957
// ComChangeProfession ( j , class ) ;
65943: LD_VAR 0 3
65947: PPUSH
65948: LD_VAR 0 7
65952: PPUSH
65953: CALL_OW 123
65957: GO 65887
65959: POP
65960: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
65961: LD_EXP 88
65965: PUSH
65966: LD_VAR 0 2
65970: ARRAY
65971: PUSH
65972: LD_EXP 87
65976: PUSH
65977: LD_VAR 0 2
65981: ARRAY
65982: NOT
65983: AND
65984: PUSH
65985: LD_EXP 65
65989: PUSH
65990: LD_VAR 0 2
65994: ARRAY
65995: PPUSH
65996: LD_INT 30
65998: PUSH
65999: LD_INT 32
66001: PUSH
66002: EMPTY
66003: LIST
66004: LIST
66005: PPUSH
66006: CALL_OW 72
66010: NOT
66011: AND
66012: PUSH
66013: LD_EXP 65
66017: PUSH
66018: LD_VAR 0 2
66022: ARRAY
66023: PPUSH
66024: LD_INT 2
66026: PUSH
66027: LD_INT 30
66029: PUSH
66030: LD_INT 4
66032: PUSH
66033: EMPTY
66034: LIST
66035: LIST
66036: PUSH
66037: LD_INT 30
66039: PUSH
66040: LD_INT 5
66042: PUSH
66043: EMPTY
66044: LIST
66045: LIST
66046: PUSH
66047: EMPTY
66048: LIST
66049: LIST
66050: LIST
66051: PPUSH
66052: CALL_OW 72
66056: NOT
66057: AND
66058: IFFALSE 66190
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66060: LD_ADDR_VAR 0 4
66064: PUSH
66065: LD_EXP 65
66069: PUSH
66070: LD_VAR 0 2
66074: ARRAY
66075: PPUSH
66076: LD_INT 2
66078: PUSH
66079: LD_INT 25
66081: PUSH
66082: LD_INT 1
66084: PUSH
66085: EMPTY
66086: LIST
66087: LIST
66088: PUSH
66089: LD_INT 25
66091: PUSH
66092: LD_INT 5
66094: PUSH
66095: EMPTY
66096: LIST
66097: LIST
66098: PUSH
66099: LD_INT 25
66101: PUSH
66102: LD_INT 8
66104: PUSH
66105: EMPTY
66106: LIST
66107: LIST
66108: PUSH
66109: LD_INT 25
66111: PUSH
66112: LD_INT 9
66114: PUSH
66115: EMPTY
66116: LIST
66117: LIST
66118: PUSH
66119: EMPTY
66120: LIST
66121: LIST
66122: LIST
66123: LIST
66124: LIST
66125: PPUSH
66126: CALL_OW 72
66130: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
66131: LD_ADDR_VAR 0 4
66135: PUSH
66136: LD_VAR 0 4
66140: PUSH
66141: LD_VAR 0 4
66145: PPUSH
66146: LD_INT 18
66148: PPUSH
66149: CALL 47065 0 2
66153: DIFF
66154: ST_TO_ADDR
// if tmp then
66155: LD_VAR 0 4
66159: IFFALSE 66190
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
66161: LD_VAR 0 2
66165: PPUSH
66166: LD_VAR 0 4
66170: PPUSH
66171: LD_EXP 90
66175: PUSH
66176: LD_VAR 0 2
66180: ARRAY
66181: PPUSH
66182: CALL 99747 0 3
// exit ;
66186: POP
66187: POP
66188: GO 66263
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
66190: LD_EXP 88
66194: PUSH
66195: LD_VAR 0 2
66199: ARRAY
66200: PUSH
66201: LD_EXP 87
66205: PUSH
66206: LD_VAR 0 2
66210: ARRAY
66211: AND
66212: IFFALSE 66259
// begin tmp := mc_defender [ i ] ;
66214: LD_ADDR_VAR 0 4
66218: PUSH
66219: LD_EXP 87
66223: PUSH
66224: LD_VAR 0 2
66228: ARRAY
66229: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
66230: LD_VAR 0 2
66234: PPUSH
66235: LD_VAR 0 4
66239: PPUSH
66240: LD_EXP 88
66244: PUSH
66245: LD_VAR 0 2
66249: ARRAY
66250: PPUSH
66251: CALL 100308 0 3
// exit ;
66255: POP
66256: POP
66257: GO 66263
// end ; end ;
66259: GO 65696
66261: POP
66262: POP
// end ;
66263: LD_VAR 0 1
66267: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
66268: LD_INT 0
66270: PPUSH
66271: PPUSH
66272: PPUSH
66273: PPUSH
66274: PPUSH
66275: PPUSH
66276: PPUSH
66277: PPUSH
66278: PPUSH
66279: PPUSH
66280: PPUSH
// if not mc_bases then
66281: LD_EXP 65
66285: NOT
66286: IFFALSE 66290
// exit ;
66288: GO 67377
// for i = 1 to mc_bases do
66290: LD_ADDR_VAR 0 2
66294: PUSH
66295: DOUBLE
66296: LD_INT 1
66298: DEC
66299: ST_TO_ADDR
66300: LD_EXP 65
66304: PUSH
66305: FOR_TO
66306: IFFALSE 67375
// begin tmp := mc_lab [ i ] ;
66308: LD_ADDR_VAR 0 6
66312: PUSH
66313: LD_EXP 98
66317: PUSH
66318: LD_VAR 0 2
66322: ARRAY
66323: ST_TO_ADDR
// if not tmp then
66324: LD_VAR 0 6
66328: NOT
66329: IFFALSE 66333
// continue ;
66331: GO 66305
// idle_lab := 0 ;
66333: LD_ADDR_VAR 0 11
66337: PUSH
66338: LD_INT 0
66340: ST_TO_ADDR
// for j in tmp do
66341: LD_ADDR_VAR 0 3
66345: PUSH
66346: LD_VAR 0 6
66350: PUSH
66351: FOR_IN
66352: IFFALSE 67371
// begin researching := false ;
66354: LD_ADDR_VAR 0 10
66358: PUSH
66359: LD_INT 0
66361: ST_TO_ADDR
// side := GetSide ( j ) ;
66362: LD_ADDR_VAR 0 4
66366: PUSH
66367: LD_VAR 0 3
66371: PPUSH
66372: CALL_OW 255
66376: ST_TO_ADDR
// if not mc_tech [ side ] then
66377: LD_EXP 92
66381: PUSH
66382: LD_VAR 0 4
66386: ARRAY
66387: NOT
66388: IFFALSE 66392
// continue ;
66390: GO 66351
// if BuildingStatus ( j ) = bs_idle then
66392: LD_VAR 0 3
66396: PPUSH
66397: CALL_OW 461
66401: PUSH
66402: LD_INT 2
66404: EQUAL
66405: IFFALSE 66593
// begin if idle_lab and UnitsInside ( j ) < 6 then
66407: LD_VAR 0 11
66411: PUSH
66412: LD_VAR 0 3
66416: PPUSH
66417: CALL_OW 313
66421: PUSH
66422: LD_INT 6
66424: LESS
66425: AND
66426: IFFALSE 66497
// begin tmp2 := UnitsInside ( idle_lab ) ;
66428: LD_ADDR_VAR 0 9
66432: PUSH
66433: LD_VAR 0 11
66437: PPUSH
66438: CALL_OW 313
66442: ST_TO_ADDR
// if tmp2 then
66443: LD_VAR 0 9
66447: IFFALSE 66489
// for x in tmp2 do
66449: LD_ADDR_VAR 0 7
66453: PUSH
66454: LD_VAR 0 9
66458: PUSH
66459: FOR_IN
66460: IFFALSE 66487
// begin ComExitBuilding ( x ) ;
66462: LD_VAR 0 7
66466: PPUSH
66467: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
66471: LD_VAR 0 7
66475: PPUSH
66476: LD_VAR 0 3
66480: PPUSH
66481: CALL_OW 180
// end ;
66485: GO 66459
66487: POP
66488: POP
// idle_lab := 0 ;
66489: LD_ADDR_VAR 0 11
66493: PUSH
66494: LD_INT 0
66496: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
66497: LD_ADDR_VAR 0 5
66501: PUSH
66502: LD_EXP 92
66506: PUSH
66507: LD_VAR 0 4
66511: ARRAY
66512: PUSH
66513: FOR_IN
66514: IFFALSE 66574
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
66516: LD_VAR 0 3
66520: PPUSH
66521: LD_VAR 0 5
66525: PPUSH
66526: CALL_OW 430
66530: PUSH
66531: LD_VAR 0 4
66535: PPUSH
66536: LD_VAR 0 5
66540: PPUSH
66541: CALL 14410 0 2
66545: AND
66546: IFFALSE 66572
// begin researching := true ;
66548: LD_ADDR_VAR 0 10
66552: PUSH
66553: LD_INT 1
66555: ST_TO_ADDR
// ComResearch ( j , t ) ;
66556: LD_VAR 0 3
66560: PPUSH
66561: LD_VAR 0 5
66565: PPUSH
66566: CALL_OW 124
// break ;
66570: GO 66574
// end ;
66572: GO 66513
66574: POP
66575: POP
// if not researching then
66576: LD_VAR 0 10
66580: NOT
66581: IFFALSE 66593
// idle_lab := j ;
66583: LD_ADDR_VAR 0 11
66587: PUSH
66588: LD_VAR 0 3
66592: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
66593: LD_VAR 0 3
66597: PPUSH
66598: CALL_OW 461
66602: PUSH
66603: LD_INT 10
66605: EQUAL
66606: IFFALSE 67194
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
66608: LD_EXP 94
66612: PUSH
66613: LD_VAR 0 2
66617: ARRAY
66618: NOT
66619: PUSH
66620: LD_EXP 95
66624: PUSH
66625: LD_VAR 0 2
66629: ARRAY
66630: NOT
66631: AND
66632: PUSH
66633: LD_EXP 92
66637: PUSH
66638: LD_VAR 0 4
66642: ARRAY
66643: PUSH
66644: LD_INT 1
66646: GREATER
66647: AND
66648: IFFALSE 66779
// begin ComCancel ( j ) ;
66650: LD_VAR 0 3
66654: PPUSH
66655: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
66659: LD_ADDR_EXP 92
66663: PUSH
66664: LD_EXP 92
66668: PPUSH
66669: LD_VAR 0 4
66673: PPUSH
66674: LD_EXP 92
66678: PUSH
66679: LD_VAR 0 4
66683: ARRAY
66684: PPUSH
66685: LD_EXP 92
66689: PUSH
66690: LD_VAR 0 4
66694: ARRAY
66695: PUSH
66696: LD_INT 1
66698: MINUS
66699: PPUSH
66700: LD_EXP 92
66704: PUSH
66705: LD_VAR 0 4
66709: ARRAY
66710: PPUSH
66711: LD_INT 0
66713: PPUSH
66714: CALL 17922 0 4
66718: PPUSH
66719: CALL_OW 1
66723: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
66724: LD_ADDR_EXP 92
66728: PUSH
66729: LD_EXP 92
66733: PPUSH
66734: LD_VAR 0 4
66738: PPUSH
66739: LD_EXP 92
66743: PUSH
66744: LD_VAR 0 4
66748: ARRAY
66749: PPUSH
66750: LD_EXP 92
66754: PUSH
66755: LD_VAR 0 4
66759: ARRAY
66760: PPUSH
66761: LD_INT 1
66763: PPUSH
66764: LD_INT 0
66766: PPUSH
66767: CALL 17922 0 4
66771: PPUSH
66772: CALL_OW 1
66776: ST_TO_ADDR
// continue ;
66777: GO 66351
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
66779: LD_EXP 94
66783: PUSH
66784: LD_VAR 0 2
66788: ARRAY
66789: PUSH
66790: LD_EXP 95
66794: PUSH
66795: LD_VAR 0 2
66799: ARRAY
66800: NOT
66801: AND
66802: IFFALSE 66929
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
66804: LD_ADDR_EXP 95
66808: PUSH
66809: LD_EXP 95
66813: PPUSH
66814: LD_VAR 0 2
66818: PUSH
66819: LD_EXP 95
66823: PUSH
66824: LD_VAR 0 2
66828: ARRAY
66829: PUSH
66830: LD_INT 1
66832: PLUS
66833: PUSH
66834: EMPTY
66835: LIST
66836: LIST
66837: PPUSH
66838: LD_EXP 94
66842: PUSH
66843: LD_VAR 0 2
66847: ARRAY
66848: PUSH
66849: LD_INT 1
66851: ARRAY
66852: PPUSH
66853: CALL 18504 0 3
66857: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
66858: LD_EXP 94
66862: PUSH
66863: LD_VAR 0 2
66867: ARRAY
66868: PUSH
66869: LD_INT 1
66871: ARRAY
66872: PPUSH
66873: LD_INT 112
66875: PPUSH
66876: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
66880: LD_ADDR_VAR 0 9
66884: PUSH
66885: LD_EXP 94
66889: PUSH
66890: LD_VAR 0 2
66894: ARRAY
66895: PPUSH
66896: LD_INT 1
66898: PPUSH
66899: CALL_OW 3
66903: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
66904: LD_ADDR_EXP 94
66908: PUSH
66909: LD_EXP 94
66913: PPUSH
66914: LD_VAR 0 2
66918: PPUSH
66919: LD_VAR 0 9
66923: PPUSH
66924: CALL_OW 1
66928: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
66929: LD_EXP 94
66933: PUSH
66934: LD_VAR 0 2
66938: ARRAY
66939: PUSH
66940: LD_EXP 95
66944: PUSH
66945: LD_VAR 0 2
66949: ARRAY
66950: AND
66951: PUSH
66952: LD_EXP 95
66956: PUSH
66957: LD_VAR 0 2
66961: ARRAY
66962: PUSH
66963: LD_INT 1
66965: ARRAY
66966: PPUSH
66967: CALL_OW 310
66971: NOT
66972: AND
66973: PUSH
66974: LD_VAR 0 3
66978: PPUSH
66979: CALL_OW 313
66983: PUSH
66984: LD_INT 6
66986: EQUAL
66987: AND
66988: IFFALSE 67044
// begin tmp2 := UnitsInside ( j ) ;
66990: LD_ADDR_VAR 0 9
66994: PUSH
66995: LD_VAR 0 3
66999: PPUSH
67000: CALL_OW 313
67004: ST_TO_ADDR
// if tmp2 = 6 then
67005: LD_VAR 0 9
67009: PUSH
67010: LD_INT 6
67012: EQUAL
67013: IFFALSE 67044
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
67015: LD_VAR 0 9
67019: PUSH
67020: LD_INT 1
67022: ARRAY
67023: PPUSH
67024: LD_INT 112
67026: PPUSH
67027: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
67031: LD_VAR 0 9
67035: PUSH
67036: LD_INT 1
67038: ARRAY
67039: PPUSH
67040: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
67044: LD_EXP 95
67048: PUSH
67049: LD_VAR 0 2
67053: ARRAY
67054: PUSH
67055: LD_EXP 95
67059: PUSH
67060: LD_VAR 0 2
67064: ARRAY
67065: PUSH
67066: LD_INT 1
67068: ARRAY
67069: PPUSH
67070: CALL_OW 314
67074: NOT
67075: AND
67076: PUSH
67077: LD_EXP 95
67081: PUSH
67082: LD_VAR 0 2
67086: ARRAY
67087: PUSH
67088: LD_INT 1
67090: ARRAY
67091: PPUSH
67092: CALL_OW 310
67096: NOT
67097: AND
67098: IFFALSE 67124
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
67100: LD_EXP 95
67104: PUSH
67105: LD_VAR 0 2
67109: ARRAY
67110: PUSH
67111: LD_INT 1
67113: ARRAY
67114: PPUSH
67115: LD_VAR 0 3
67119: PPUSH
67120: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
67124: LD_EXP 95
67128: PUSH
67129: LD_VAR 0 2
67133: ARRAY
67134: PUSH
67135: LD_INT 1
67137: ARRAY
67138: PPUSH
67139: CALL_OW 310
67143: PUSH
67144: LD_EXP 95
67148: PUSH
67149: LD_VAR 0 2
67153: ARRAY
67154: PUSH
67155: LD_INT 1
67157: ARRAY
67158: PPUSH
67159: CALL_OW 310
67163: PPUSH
67164: CALL_OW 461
67168: PUSH
67169: LD_INT 3
67171: NONEQUAL
67172: AND
67173: IFFALSE 67194
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
67175: LD_EXP 95
67179: PUSH
67180: LD_VAR 0 2
67184: ARRAY
67185: PUSH
67186: LD_INT 1
67188: ARRAY
67189: PPUSH
67190: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
67194: LD_VAR 0 3
67198: PPUSH
67199: CALL_OW 461
67203: PUSH
67204: LD_INT 6
67206: EQUAL
67207: PUSH
67208: LD_VAR 0 6
67212: PUSH
67213: LD_INT 1
67215: GREATER
67216: AND
67217: IFFALSE 67369
// begin sci := [ ] ;
67219: LD_ADDR_VAR 0 8
67223: PUSH
67224: EMPTY
67225: ST_TO_ADDR
// for x in ( tmp diff j ) do
67226: LD_ADDR_VAR 0 7
67230: PUSH
67231: LD_VAR 0 6
67235: PUSH
67236: LD_VAR 0 3
67240: DIFF
67241: PUSH
67242: FOR_IN
67243: IFFALSE 67295
// begin if sci = 6 then
67245: LD_VAR 0 8
67249: PUSH
67250: LD_INT 6
67252: EQUAL
67253: IFFALSE 67257
// break ;
67255: GO 67295
// if BuildingStatus ( x ) = bs_idle then
67257: LD_VAR 0 7
67261: PPUSH
67262: CALL_OW 461
67266: PUSH
67267: LD_INT 2
67269: EQUAL
67270: IFFALSE 67293
// sci := sci ^ UnitsInside ( x ) ;
67272: LD_ADDR_VAR 0 8
67276: PUSH
67277: LD_VAR 0 8
67281: PUSH
67282: LD_VAR 0 7
67286: PPUSH
67287: CALL_OW 313
67291: ADD
67292: ST_TO_ADDR
// end ;
67293: GO 67242
67295: POP
67296: POP
// if not sci then
67297: LD_VAR 0 8
67301: NOT
67302: IFFALSE 67306
// continue ;
67304: GO 66351
// for x in sci do
67306: LD_ADDR_VAR 0 7
67310: PUSH
67311: LD_VAR 0 8
67315: PUSH
67316: FOR_IN
67317: IFFALSE 67367
// if IsInUnit ( x ) and not HasTask ( x ) then
67319: LD_VAR 0 7
67323: PPUSH
67324: CALL_OW 310
67328: PUSH
67329: LD_VAR 0 7
67333: PPUSH
67334: CALL_OW 314
67338: NOT
67339: AND
67340: IFFALSE 67365
// begin ComExitBuilding ( x ) ;
67342: LD_VAR 0 7
67346: PPUSH
67347: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67351: LD_VAR 0 7
67355: PPUSH
67356: LD_VAR 0 3
67360: PPUSH
67361: CALL_OW 180
// end ;
67365: GO 67316
67367: POP
67368: POP
// end ; end ;
67369: GO 66351
67371: POP
67372: POP
// end ;
67373: GO 66305
67375: POP
67376: POP
// end ;
67377: LD_VAR 0 1
67381: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
67382: LD_INT 0
67384: PPUSH
67385: PPUSH
// if not mc_bases then
67386: LD_EXP 65
67390: NOT
67391: IFFALSE 67395
// exit ;
67393: GO 67476
// for i = 1 to mc_bases do
67395: LD_ADDR_VAR 0 2
67399: PUSH
67400: DOUBLE
67401: LD_INT 1
67403: DEC
67404: ST_TO_ADDR
67405: LD_EXP 65
67409: PUSH
67410: FOR_TO
67411: IFFALSE 67474
// if mc_mines [ i ] and mc_miners [ i ] then
67413: LD_EXP 78
67417: PUSH
67418: LD_VAR 0 2
67422: ARRAY
67423: PUSH
67424: LD_EXP 79
67428: PUSH
67429: LD_VAR 0 2
67433: ARRAY
67434: AND
67435: IFFALSE 67472
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
67437: LD_EXP 79
67441: PUSH
67442: LD_VAR 0 2
67446: ARRAY
67447: PUSH
67448: LD_INT 1
67450: ARRAY
67451: PPUSH
67452: CALL_OW 255
67456: PPUSH
67457: LD_EXP 78
67461: PUSH
67462: LD_VAR 0 2
67466: ARRAY
67467: PPUSH
67468: CALL 15493 0 2
67472: GO 67410
67474: POP
67475: POP
// end ;
67476: LD_VAR 0 1
67480: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
67481: LD_INT 0
67483: PPUSH
67484: PPUSH
67485: PPUSH
67486: PPUSH
67487: PPUSH
67488: PPUSH
67489: PPUSH
67490: PPUSH
// if not mc_bases or not mc_parking then
67491: LD_EXP 65
67495: NOT
67496: PUSH
67497: LD_EXP 89
67501: NOT
67502: OR
67503: IFFALSE 67507
// exit ;
67505: GO 68206
// for i = 1 to mc_bases do
67507: LD_ADDR_VAR 0 2
67511: PUSH
67512: DOUBLE
67513: LD_INT 1
67515: DEC
67516: ST_TO_ADDR
67517: LD_EXP 65
67521: PUSH
67522: FOR_TO
67523: IFFALSE 68204
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
67525: LD_EXP 65
67529: PUSH
67530: LD_VAR 0 2
67534: ARRAY
67535: NOT
67536: PUSH
67537: LD_EXP 89
67541: PUSH
67542: LD_VAR 0 2
67546: ARRAY
67547: NOT
67548: OR
67549: IFFALSE 67553
// continue ;
67551: GO 67522
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
67553: LD_ADDR_VAR 0 5
67557: PUSH
67558: LD_EXP 65
67562: PUSH
67563: LD_VAR 0 2
67567: ARRAY
67568: PUSH
67569: LD_INT 1
67571: ARRAY
67572: PPUSH
67573: CALL_OW 255
67577: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67578: LD_ADDR_VAR 0 6
67582: PUSH
67583: LD_EXP 65
67587: PUSH
67588: LD_VAR 0 2
67592: ARRAY
67593: PPUSH
67594: LD_INT 30
67596: PUSH
67597: LD_INT 3
67599: PUSH
67600: EMPTY
67601: LIST
67602: LIST
67603: PPUSH
67604: CALL_OW 72
67608: ST_TO_ADDR
// if not fac then
67609: LD_VAR 0 6
67613: NOT
67614: IFFALSE 67665
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67616: LD_ADDR_VAR 0 6
67620: PUSH
67621: LD_EXP 65
67625: PUSH
67626: LD_VAR 0 2
67630: ARRAY
67631: PPUSH
67632: LD_INT 2
67634: PUSH
67635: LD_INT 30
67637: PUSH
67638: LD_INT 0
67640: PUSH
67641: EMPTY
67642: LIST
67643: LIST
67644: PUSH
67645: LD_INT 30
67647: PUSH
67648: LD_INT 1
67650: PUSH
67651: EMPTY
67652: LIST
67653: LIST
67654: PUSH
67655: EMPTY
67656: LIST
67657: LIST
67658: LIST
67659: PPUSH
67660: CALL_OW 72
67664: ST_TO_ADDR
// if not fac then
67665: LD_VAR 0 6
67669: NOT
67670: IFFALSE 67674
// continue ;
67672: GO 67522
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
67674: LD_ADDR_VAR 0 7
67678: PUSH
67679: LD_EXP 89
67683: PUSH
67684: LD_VAR 0 2
67688: ARRAY
67689: PPUSH
67690: LD_INT 22
67692: PUSH
67693: LD_VAR 0 5
67697: PUSH
67698: EMPTY
67699: LIST
67700: LIST
67701: PUSH
67702: LD_INT 21
67704: PUSH
67705: LD_INT 2
67707: PUSH
67708: EMPTY
67709: LIST
67710: LIST
67711: PUSH
67712: LD_INT 3
67714: PUSH
67715: LD_INT 24
67717: PUSH
67718: LD_INT 1000
67720: PUSH
67721: EMPTY
67722: LIST
67723: LIST
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: PUSH
67729: EMPTY
67730: LIST
67731: LIST
67732: LIST
67733: PPUSH
67734: CALL_OW 70
67738: ST_TO_ADDR
// for j in fac do
67739: LD_ADDR_VAR 0 3
67743: PUSH
67744: LD_VAR 0 6
67748: PUSH
67749: FOR_IN
67750: IFFALSE 67831
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
67752: LD_ADDR_VAR 0 7
67756: PUSH
67757: LD_VAR 0 7
67761: PUSH
67762: LD_INT 22
67764: PUSH
67765: LD_VAR 0 5
67769: PUSH
67770: EMPTY
67771: LIST
67772: LIST
67773: PUSH
67774: LD_INT 91
67776: PUSH
67777: LD_VAR 0 3
67781: PUSH
67782: LD_INT 15
67784: PUSH
67785: EMPTY
67786: LIST
67787: LIST
67788: LIST
67789: PUSH
67790: LD_INT 21
67792: PUSH
67793: LD_INT 2
67795: PUSH
67796: EMPTY
67797: LIST
67798: LIST
67799: PUSH
67800: LD_INT 3
67802: PUSH
67803: LD_INT 24
67805: PUSH
67806: LD_INT 1000
67808: PUSH
67809: EMPTY
67810: LIST
67811: LIST
67812: PUSH
67813: EMPTY
67814: LIST
67815: LIST
67816: PUSH
67817: EMPTY
67818: LIST
67819: LIST
67820: LIST
67821: LIST
67822: PPUSH
67823: CALL_OW 69
67827: UNION
67828: ST_TO_ADDR
67829: GO 67749
67831: POP
67832: POP
// if not vehs then
67833: LD_VAR 0 7
67837: NOT
67838: IFFALSE 67864
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
67840: LD_ADDR_EXP 77
67844: PUSH
67845: LD_EXP 77
67849: PPUSH
67850: LD_VAR 0 2
67854: PPUSH
67855: EMPTY
67856: PPUSH
67857: CALL_OW 1
67861: ST_TO_ADDR
// continue ;
67862: GO 67522
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67864: LD_ADDR_VAR 0 8
67868: PUSH
67869: LD_EXP 65
67873: PUSH
67874: LD_VAR 0 2
67878: ARRAY
67879: PPUSH
67880: LD_INT 30
67882: PUSH
67883: LD_INT 3
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PPUSH
67890: CALL_OW 72
67894: ST_TO_ADDR
// if tmp then
67895: LD_VAR 0 8
67899: IFFALSE 68002
// begin for j in tmp do
67901: LD_ADDR_VAR 0 3
67905: PUSH
67906: LD_VAR 0 8
67910: PUSH
67911: FOR_IN
67912: IFFALSE 68000
// for k in UnitsInside ( j ) do
67914: LD_ADDR_VAR 0 4
67918: PUSH
67919: LD_VAR 0 3
67923: PPUSH
67924: CALL_OW 313
67928: PUSH
67929: FOR_IN
67930: IFFALSE 67996
// if k then
67932: LD_VAR 0 4
67936: IFFALSE 67994
// if not k in mc_repair_vehicle [ i ] then
67938: LD_VAR 0 4
67942: PUSH
67943: LD_EXP 77
67947: PUSH
67948: LD_VAR 0 2
67952: ARRAY
67953: IN
67954: NOT
67955: IFFALSE 67994
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
67957: LD_ADDR_EXP 77
67961: PUSH
67962: LD_EXP 77
67966: PPUSH
67967: LD_VAR 0 2
67971: PPUSH
67972: LD_EXP 77
67976: PUSH
67977: LD_VAR 0 2
67981: ARRAY
67982: PUSH
67983: LD_VAR 0 4
67987: UNION
67988: PPUSH
67989: CALL_OW 1
67993: ST_TO_ADDR
67994: GO 67929
67996: POP
67997: POP
67998: GO 67911
68000: POP
68001: POP
// end ; if not mc_repair_vehicle [ i ] then
68002: LD_EXP 77
68006: PUSH
68007: LD_VAR 0 2
68011: ARRAY
68012: NOT
68013: IFFALSE 68017
// continue ;
68015: GO 67522
// for j in mc_repair_vehicle [ i ] do
68017: LD_ADDR_VAR 0 3
68021: PUSH
68022: LD_EXP 77
68026: PUSH
68027: LD_VAR 0 2
68031: ARRAY
68032: PUSH
68033: FOR_IN
68034: IFFALSE 68200
// begin if GetClass ( j ) <> 3 then
68036: LD_VAR 0 3
68040: PPUSH
68041: CALL_OW 257
68045: PUSH
68046: LD_INT 3
68048: NONEQUAL
68049: IFFALSE 68090
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
68051: LD_ADDR_EXP 77
68055: PUSH
68056: LD_EXP 77
68060: PPUSH
68061: LD_VAR 0 2
68065: PPUSH
68066: LD_EXP 77
68070: PUSH
68071: LD_VAR 0 2
68075: ARRAY
68076: PUSH
68077: LD_VAR 0 3
68081: DIFF
68082: PPUSH
68083: CALL_OW 1
68087: ST_TO_ADDR
// continue ;
68088: GO 68033
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
68090: LD_VAR 0 3
68094: PPUSH
68095: CALL_OW 311
68099: NOT
68100: PUSH
68101: LD_VAR 0 3
68105: PUSH
68106: LD_EXP 68
68110: PUSH
68111: LD_VAR 0 2
68115: ARRAY
68116: PUSH
68117: LD_INT 1
68119: ARRAY
68120: IN
68121: NOT
68122: AND
68123: PUSH
68124: LD_VAR 0 3
68128: PUSH
68129: LD_EXP 68
68133: PUSH
68134: LD_VAR 0 2
68138: ARRAY
68139: PUSH
68140: LD_INT 2
68142: ARRAY
68143: IN
68144: NOT
68145: AND
68146: IFFALSE 68198
// begin if IsInUnit ( j ) then
68148: LD_VAR 0 3
68152: PPUSH
68153: CALL_OW 310
68157: IFFALSE 68168
// ComExitBuilding ( j ) ;
68159: LD_VAR 0 3
68163: PPUSH
68164: CALL_OW 122
// if not HasTask ( j ) then
68168: LD_VAR 0 3
68172: PPUSH
68173: CALL_OW 314
68177: NOT
68178: IFFALSE 68198
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
68180: LD_VAR 0 3
68184: PPUSH
68185: LD_VAR 0 7
68189: PUSH
68190: LD_INT 1
68192: ARRAY
68193: PPUSH
68194: CALL_OW 189
// end ; end ;
68198: GO 68033
68200: POP
68201: POP
// end ;
68202: GO 67522
68204: POP
68205: POP
// end ;
68206: LD_VAR 0 1
68210: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
68211: LD_INT 0
68213: PPUSH
68214: PPUSH
68215: PPUSH
68216: PPUSH
68217: PPUSH
68218: PPUSH
68219: PPUSH
68220: PPUSH
68221: PPUSH
68222: PPUSH
68223: PPUSH
// if not mc_bases then
68224: LD_EXP 65
68228: NOT
68229: IFFALSE 68233
// exit ;
68231: GO 69035
// for i = 1 to mc_bases do
68233: LD_ADDR_VAR 0 2
68237: PUSH
68238: DOUBLE
68239: LD_INT 1
68241: DEC
68242: ST_TO_ADDR
68243: LD_EXP 65
68247: PUSH
68248: FOR_TO
68249: IFFALSE 69033
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
68251: LD_EXP 93
68255: PUSH
68256: LD_VAR 0 2
68260: ARRAY
68261: NOT
68262: PUSH
68263: LD_EXP 68
68267: PUSH
68268: LD_VAR 0 2
68272: ARRAY
68273: PUSH
68274: LD_INT 1
68276: ARRAY
68277: OR
68278: PUSH
68279: LD_EXP 68
68283: PUSH
68284: LD_VAR 0 2
68288: ARRAY
68289: PUSH
68290: LD_INT 2
68292: ARRAY
68293: OR
68294: PUSH
68295: LD_EXP 91
68299: PUSH
68300: LD_VAR 0 2
68304: ARRAY
68305: PPUSH
68306: LD_INT 1
68308: PPUSH
68309: CALL_OW 325
68313: NOT
68314: OR
68315: PUSH
68316: LD_EXP 88
68320: PUSH
68321: LD_VAR 0 2
68325: ARRAY
68326: OR
68327: IFFALSE 68331
// continue ;
68329: GO 68248
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
68331: LD_ADDR_VAR 0 8
68335: PUSH
68336: LD_EXP 65
68340: PUSH
68341: LD_VAR 0 2
68345: ARRAY
68346: PPUSH
68347: LD_INT 25
68349: PUSH
68350: LD_INT 4
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: LD_INT 50
68359: PUSH
68360: EMPTY
68361: LIST
68362: PUSH
68363: LD_INT 3
68365: PUSH
68366: LD_INT 60
68368: PUSH
68369: EMPTY
68370: LIST
68371: PUSH
68372: EMPTY
68373: LIST
68374: LIST
68375: PUSH
68376: EMPTY
68377: LIST
68378: LIST
68379: LIST
68380: PPUSH
68381: CALL_OW 72
68385: PUSH
68386: LD_EXP 69
68390: PUSH
68391: LD_VAR 0 2
68395: ARRAY
68396: DIFF
68397: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68398: LD_ADDR_VAR 0 9
68402: PUSH
68403: LD_EXP 65
68407: PUSH
68408: LD_VAR 0 2
68412: ARRAY
68413: PPUSH
68414: LD_INT 2
68416: PUSH
68417: LD_INT 30
68419: PUSH
68420: LD_INT 0
68422: PUSH
68423: EMPTY
68424: LIST
68425: LIST
68426: PUSH
68427: LD_INT 30
68429: PUSH
68430: LD_INT 1
68432: PUSH
68433: EMPTY
68434: LIST
68435: LIST
68436: PUSH
68437: EMPTY
68438: LIST
68439: LIST
68440: LIST
68441: PPUSH
68442: CALL_OW 72
68446: ST_TO_ADDR
// if not tmp or not dep then
68447: LD_VAR 0 8
68451: NOT
68452: PUSH
68453: LD_VAR 0 9
68457: NOT
68458: OR
68459: IFFALSE 68463
// continue ;
68461: GO 68248
// side := GetSide ( tmp [ 1 ] ) ;
68463: LD_ADDR_VAR 0 11
68467: PUSH
68468: LD_VAR 0 8
68472: PUSH
68473: LD_INT 1
68475: ARRAY
68476: PPUSH
68477: CALL_OW 255
68481: ST_TO_ADDR
// dep := dep [ 1 ] ;
68482: LD_ADDR_VAR 0 9
68486: PUSH
68487: LD_VAR 0 9
68491: PUSH
68492: LD_INT 1
68494: ARRAY
68495: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
68496: LD_ADDR_VAR 0 7
68500: PUSH
68501: LD_EXP 93
68505: PUSH
68506: LD_VAR 0 2
68510: ARRAY
68511: PPUSH
68512: LD_INT 22
68514: PUSH
68515: LD_INT 0
68517: PUSH
68518: EMPTY
68519: LIST
68520: LIST
68521: PUSH
68522: LD_INT 25
68524: PUSH
68525: LD_INT 12
68527: PUSH
68528: EMPTY
68529: LIST
68530: LIST
68531: PUSH
68532: EMPTY
68533: LIST
68534: LIST
68535: PPUSH
68536: CALL_OW 70
68540: PUSH
68541: LD_INT 22
68543: PUSH
68544: LD_INT 0
68546: PUSH
68547: EMPTY
68548: LIST
68549: LIST
68550: PUSH
68551: LD_INT 25
68553: PUSH
68554: LD_INT 12
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: PUSH
68561: LD_INT 91
68563: PUSH
68564: LD_VAR 0 9
68568: PUSH
68569: LD_INT 20
68571: PUSH
68572: EMPTY
68573: LIST
68574: LIST
68575: LIST
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: LIST
68581: PPUSH
68582: CALL_OW 69
68586: UNION
68587: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
68588: LD_ADDR_VAR 0 10
68592: PUSH
68593: LD_EXP 93
68597: PUSH
68598: LD_VAR 0 2
68602: ARRAY
68603: PPUSH
68604: LD_INT 81
68606: PUSH
68607: LD_VAR 0 11
68611: PUSH
68612: EMPTY
68613: LIST
68614: LIST
68615: PPUSH
68616: CALL_OW 70
68620: ST_TO_ADDR
// if not apes or danger_at_area then
68621: LD_VAR 0 7
68625: NOT
68626: PUSH
68627: LD_VAR 0 10
68631: OR
68632: IFFALSE 68682
// begin if mc_taming [ i ] then
68634: LD_EXP 96
68638: PUSH
68639: LD_VAR 0 2
68643: ARRAY
68644: IFFALSE 68680
// begin MC_Reset ( i , 121 ) ;
68646: LD_VAR 0 2
68650: PPUSH
68651: LD_INT 121
68653: PPUSH
68654: CALL 54133 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
68658: LD_ADDR_EXP 96
68662: PUSH
68663: LD_EXP 96
68667: PPUSH
68668: LD_VAR 0 2
68672: PPUSH
68673: EMPTY
68674: PPUSH
68675: CALL_OW 1
68679: ST_TO_ADDR
// end ; continue ;
68680: GO 68248
// end ; for j in tmp do
68682: LD_ADDR_VAR 0 3
68686: PUSH
68687: LD_VAR 0 8
68691: PUSH
68692: FOR_IN
68693: IFFALSE 69029
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
68695: LD_VAR 0 3
68699: PUSH
68700: LD_EXP 96
68704: PUSH
68705: LD_VAR 0 2
68709: ARRAY
68710: IN
68711: NOT
68712: PUSH
68713: LD_EXP 96
68717: PUSH
68718: LD_VAR 0 2
68722: ARRAY
68723: PUSH
68724: LD_INT 3
68726: LESS
68727: AND
68728: IFFALSE 68786
// begin SetTag ( j , 121 ) ;
68730: LD_VAR 0 3
68734: PPUSH
68735: LD_INT 121
68737: PPUSH
68738: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
68742: LD_ADDR_EXP 96
68746: PUSH
68747: LD_EXP 96
68751: PPUSH
68752: LD_VAR 0 2
68756: PUSH
68757: LD_EXP 96
68761: PUSH
68762: LD_VAR 0 2
68766: ARRAY
68767: PUSH
68768: LD_INT 1
68770: PLUS
68771: PUSH
68772: EMPTY
68773: LIST
68774: LIST
68775: PPUSH
68776: LD_VAR 0 3
68780: PPUSH
68781: CALL 18504 0 3
68785: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
68786: LD_VAR 0 3
68790: PUSH
68791: LD_EXP 96
68795: PUSH
68796: LD_VAR 0 2
68800: ARRAY
68801: IN
68802: IFFALSE 69027
// begin if GetClass ( j ) <> 4 then
68804: LD_VAR 0 3
68808: PPUSH
68809: CALL_OW 257
68813: PUSH
68814: LD_INT 4
68816: NONEQUAL
68817: IFFALSE 68870
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
68819: LD_ADDR_EXP 96
68823: PUSH
68824: LD_EXP 96
68828: PPUSH
68829: LD_VAR 0 2
68833: PPUSH
68834: LD_EXP 96
68838: PUSH
68839: LD_VAR 0 2
68843: ARRAY
68844: PUSH
68845: LD_VAR 0 3
68849: DIFF
68850: PPUSH
68851: CALL_OW 1
68855: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68856: LD_VAR 0 3
68860: PPUSH
68861: LD_INT 0
68863: PPUSH
68864: CALL_OW 109
// continue ;
68868: GO 68692
// end ; if IsInUnit ( j ) then
68870: LD_VAR 0 3
68874: PPUSH
68875: CALL_OW 310
68879: IFFALSE 68890
// ComExitBuilding ( j ) ;
68881: LD_VAR 0 3
68885: PPUSH
68886: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
68890: LD_ADDR_VAR 0 6
68894: PUSH
68895: LD_VAR 0 7
68899: PPUSH
68900: LD_VAR 0 3
68904: PPUSH
68905: CALL_OW 74
68909: ST_TO_ADDR
// if not ape then
68910: LD_VAR 0 6
68914: NOT
68915: IFFALSE 68919
// break ;
68917: GO 69029
// x := GetX ( ape ) ;
68919: LD_ADDR_VAR 0 4
68923: PUSH
68924: LD_VAR 0 6
68928: PPUSH
68929: CALL_OW 250
68933: ST_TO_ADDR
// y := GetY ( ape ) ;
68934: LD_ADDR_VAR 0 5
68938: PUSH
68939: LD_VAR 0 6
68943: PPUSH
68944: CALL_OW 251
68948: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
68949: LD_VAR 0 4
68953: PPUSH
68954: LD_VAR 0 5
68958: PPUSH
68959: CALL_OW 488
68963: NOT
68964: PUSH
68965: LD_VAR 0 11
68969: PPUSH
68970: LD_VAR 0 4
68974: PPUSH
68975: LD_VAR 0 5
68979: PPUSH
68980: LD_INT 20
68982: PPUSH
68983: CALL 19400 0 4
68987: PUSH
68988: LD_INT 4
68990: ARRAY
68991: OR
68992: IFFALSE 68996
// break ;
68994: GO 69029
// if not HasTask ( j ) then
68996: LD_VAR 0 3
69000: PPUSH
69001: CALL_OW 314
69005: NOT
69006: IFFALSE 69027
// ComTameXY ( j , x , y ) ;
69008: LD_VAR 0 3
69012: PPUSH
69013: LD_VAR 0 4
69017: PPUSH
69018: LD_VAR 0 5
69022: PPUSH
69023: CALL_OW 131
// end ; end ;
69027: GO 68692
69029: POP
69030: POP
// end ;
69031: GO 68248
69033: POP
69034: POP
// end ;
69035: LD_VAR 0 1
69039: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
69040: LD_INT 0
69042: PPUSH
69043: PPUSH
69044: PPUSH
69045: PPUSH
69046: PPUSH
69047: PPUSH
69048: PPUSH
69049: PPUSH
// if not mc_bases then
69050: LD_EXP 65
69054: NOT
69055: IFFALSE 69059
// exit ;
69057: GO 69685
// for i = 1 to mc_bases do
69059: LD_ADDR_VAR 0 2
69063: PUSH
69064: DOUBLE
69065: LD_INT 1
69067: DEC
69068: ST_TO_ADDR
69069: LD_EXP 65
69073: PUSH
69074: FOR_TO
69075: IFFALSE 69683
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
69077: LD_EXP 94
69081: PUSH
69082: LD_VAR 0 2
69086: ARRAY
69087: NOT
69088: PUSH
69089: LD_EXP 94
69093: PUSH
69094: LD_VAR 0 2
69098: ARRAY
69099: PPUSH
69100: LD_INT 25
69102: PUSH
69103: LD_INT 12
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PPUSH
69110: CALL_OW 72
69114: NOT
69115: OR
69116: IFFALSE 69120
// continue ;
69118: GO 69074
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
69120: LD_ADDR_VAR 0 5
69124: PUSH
69125: LD_EXP 94
69129: PUSH
69130: LD_VAR 0 2
69134: ARRAY
69135: PUSH
69136: LD_INT 1
69138: ARRAY
69139: PPUSH
69140: CALL_OW 255
69144: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
69145: LD_VAR 0 5
69149: PPUSH
69150: LD_INT 2
69152: PPUSH
69153: CALL_OW 325
69157: IFFALSE 69410
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69159: LD_ADDR_VAR 0 4
69163: PUSH
69164: LD_EXP 94
69168: PUSH
69169: LD_VAR 0 2
69173: ARRAY
69174: PPUSH
69175: LD_INT 25
69177: PUSH
69178: LD_INT 16
69180: PUSH
69181: EMPTY
69182: LIST
69183: LIST
69184: PPUSH
69185: CALL_OW 72
69189: ST_TO_ADDR
// if tmp < 6 then
69190: LD_VAR 0 4
69194: PUSH
69195: LD_INT 6
69197: LESS
69198: IFFALSE 69410
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69200: LD_ADDR_VAR 0 6
69204: PUSH
69205: LD_EXP 65
69209: PUSH
69210: LD_VAR 0 2
69214: ARRAY
69215: PPUSH
69216: LD_INT 2
69218: PUSH
69219: LD_INT 30
69221: PUSH
69222: LD_INT 0
69224: PUSH
69225: EMPTY
69226: LIST
69227: LIST
69228: PUSH
69229: LD_INT 30
69231: PUSH
69232: LD_INT 1
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: PUSH
69239: EMPTY
69240: LIST
69241: LIST
69242: LIST
69243: PPUSH
69244: CALL_OW 72
69248: ST_TO_ADDR
// if depot then
69249: LD_VAR 0 6
69253: IFFALSE 69410
// begin selected := 0 ;
69255: LD_ADDR_VAR 0 7
69259: PUSH
69260: LD_INT 0
69262: ST_TO_ADDR
// for j in depot do
69263: LD_ADDR_VAR 0 3
69267: PUSH
69268: LD_VAR 0 6
69272: PUSH
69273: FOR_IN
69274: IFFALSE 69305
// begin if UnitsInside ( j ) < 6 then
69276: LD_VAR 0 3
69280: PPUSH
69281: CALL_OW 313
69285: PUSH
69286: LD_INT 6
69288: LESS
69289: IFFALSE 69303
// begin selected := j ;
69291: LD_ADDR_VAR 0 7
69295: PUSH
69296: LD_VAR 0 3
69300: ST_TO_ADDR
// break ;
69301: GO 69305
// end ; end ;
69303: GO 69273
69305: POP
69306: POP
// if selected then
69307: LD_VAR 0 7
69311: IFFALSE 69410
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69313: LD_ADDR_VAR 0 3
69317: PUSH
69318: LD_EXP 94
69322: PUSH
69323: LD_VAR 0 2
69327: ARRAY
69328: PPUSH
69329: LD_INT 25
69331: PUSH
69332: LD_INT 12
69334: PUSH
69335: EMPTY
69336: LIST
69337: LIST
69338: PPUSH
69339: CALL_OW 72
69343: PUSH
69344: FOR_IN
69345: IFFALSE 69408
// if not HasTask ( j ) then
69347: LD_VAR 0 3
69351: PPUSH
69352: CALL_OW 314
69356: NOT
69357: IFFALSE 69406
// begin if not IsInUnit ( j ) then
69359: LD_VAR 0 3
69363: PPUSH
69364: CALL_OW 310
69368: NOT
69369: IFFALSE 69385
// ComEnterUnit ( j , selected ) ;
69371: LD_VAR 0 3
69375: PPUSH
69376: LD_VAR 0 7
69380: PPUSH
69381: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
69385: LD_VAR 0 3
69389: PPUSH
69390: LD_INT 16
69392: PPUSH
69393: CALL_OW 183
// AddComExitBuilding ( j ) ;
69397: LD_VAR 0 3
69401: PPUSH
69402: CALL_OW 182
// end ;
69406: GO 69344
69408: POP
69409: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
69410: LD_VAR 0 5
69414: PPUSH
69415: LD_INT 11
69417: PPUSH
69418: CALL_OW 325
69422: IFFALSE 69681
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69424: LD_ADDR_VAR 0 4
69428: PUSH
69429: LD_EXP 94
69433: PUSH
69434: LD_VAR 0 2
69438: ARRAY
69439: PPUSH
69440: LD_INT 25
69442: PUSH
69443: LD_INT 16
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PPUSH
69450: CALL_OW 72
69454: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
69455: LD_VAR 0 4
69459: PUSH
69460: LD_INT 6
69462: GREATEREQUAL
69463: PUSH
69464: LD_VAR 0 5
69468: PPUSH
69469: LD_INT 2
69471: PPUSH
69472: CALL_OW 325
69476: NOT
69477: OR
69478: IFFALSE 69681
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
69480: LD_ADDR_VAR 0 8
69484: PUSH
69485: LD_EXP 65
69489: PUSH
69490: LD_VAR 0 2
69494: ARRAY
69495: PPUSH
69496: LD_INT 2
69498: PUSH
69499: LD_INT 30
69501: PUSH
69502: LD_INT 4
69504: PUSH
69505: EMPTY
69506: LIST
69507: LIST
69508: PUSH
69509: LD_INT 30
69511: PUSH
69512: LD_INT 5
69514: PUSH
69515: EMPTY
69516: LIST
69517: LIST
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: LIST
69523: PPUSH
69524: CALL_OW 72
69528: ST_TO_ADDR
// if barracks then
69529: LD_VAR 0 8
69533: IFFALSE 69681
// begin selected := 0 ;
69535: LD_ADDR_VAR 0 7
69539: PUSH
69540: LD_INT 0
69542: ST_TO_ADDR
// for j in barracks do
69543: LD_ADDR_VAR 0 3
69547: PUSH
69548: LD_VAR 0 8
69552: PUSH
69553: FOR_IN
69554: IFFALSE 69585
// begin if UnitsInside ( j ) < 6 then
69556: LD_VAR 0 3
69560: PPUSH
69561: CALL_OW 313
69565: PUSH
69566: LD_INT 6
69568: LESS
69569: IFFALSE 69583
// begin selected := j ;
69571: LD_ADDR_VAR 0 7
69575: PUSH
69576: LD_VAR 0 3
69580: ST_TO_ADDR
// break ;
69581: GO 69585
// end ; end ;
69583: GO 69553
69585: POP
69586: POP
// if selected then
69587: LD_VAR 0 7
69591: IFFALSE 69681
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69593: LD_ADDR_VAR 0 3
69597: PUSH
69598: LD_EXP 94
69602: PUSH
69603: LD_VAR 0 2
69607: ARRAY
69608: PPUSH
69609: LD_INT 25
69611: PUSH
69612: LD_INT 12
69614: PUSH
69615: EMPTY
69616: LIST
69617: LIST
69618: PPUSH
69619: CALL_OW 72
69623: PUSH
69624: FOR_IN
69625: IFFALSE 69679
// if not IsInUnit ( j ) and not HasTask ( j ) then
69627: LD_VAR 0 3
69631: PPUSH
69632: CALL_OW 310
69636: NOT
69637: PUSH
69638: LD_VAR 0 3
69642: PPUSH
69643: CALL_OW 314
69647: NOT
69648: AND
69649: IFFALSE 69677
// begin ComEnterUnit ( j , selected ) ;
69651: LD_VAR 0 3
69655: PPUSH
69656: LD_VAR 0 7
69660: PPUSH
69661: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
69665: LD_VAR 0 3
69669: PPUSH
69670: LD_INT 15
69672: PPUSH
69673: CALL_OW 183
// end ;
69677: GO 69624
69679: POP
69680: POP
// end ; end ; end ; end ; end ;
69681: GO 69074
69683: POP
69684: POP
// end ;
69685: LD_VAR 0 1
69689: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
69690: LD_INT 0
69692: PPUSH
69693: PPUSH
69694: PPUSH
69695: PPUSH
// if not mc_bases then
69696: LD_EXP 65
69700: NOT
69701: IFFALSE 69705
// exit ;
69703: GO 69883
// for i = 1 to mc_bases do
69705: LD_ADDR_VAR 0 2
69709: PUSH
69710: DOUBLE
69711: LD_INT 1
69713: DEC
69714: ST_TO_ADDR
69715: LD_EXP 65
69719: PUSH
69720: FOR_TO
69721: IFFALSE 69881
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
69723: LD_ADDR_VAR 0 4
69727: PUSH
69728: LD_EXP 65
69732: PUSH
69733: LD_VAR 0 2
69737: ARRAY
69738: PPUSH
69739: LD_INT 25
69741: PUSH
69742: LD_INT 9
69744: PUSH
69745: EMPTY
69746: LIST
69747: LIST
69748: PPUSH
69749: CALL_OW 72
69753: ST_TO_ADDR
// if not tmp then
69754: LD_VAR 0 4
69758: NOT
69759: IFFALSE 69763
// continue ;
69761: GO 69720
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
69763: LD_EXP 91
69767: PUSH
69768: LD_VAR 0 2
69772: ARRAY
69773: PPUSH
69774: LD_INT 29
69776: PPUSH
69777: CALL_OW 325
69781: NOT
69782: PUSH
69783: LD_EXP 91
69787: PUSH
69788: LD_VAR 0 2
69792: ARRAY
69793: PPUSH
69794: LD_INT 28
69796: PPUSH
69797: CALL_OW 325
69801: NOT
69802: AND
69803: IFFALSE 69807
// continue ;
69805: GO 69720
// for j in tmp do
69807: LD_ADDR_VAR 0 3
69811: PUSH
69812: LD_VAR 0 4
69816: PUSH
69817: FOR_IN
69818: IFFALSE 69877
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69820: LD_VAR 0 3
69824: PUSH
69825: LD_EXP 68
69829: PUSH
69830: LD_VAR 0 2
69834: ARRAY
69835: PUSH
69836: LD_INT 1
69838: ARRAY
69839: IN
69840: NOT
69841: PUSH
69842: LD_VAR 0 3
69846: PUSH
69847: LD_EXP 68
69851: PUSH
69852: LD_VAR 0 2
69856: ARRAY
69857: PUSH
69858: LD_INT 2
69860: ARRAY
69861: IN
69862: NOT
69863: AND
69864: IFFALSE 69875
// ComSpaceTimeShoot ( j ) ;
69866: LD_VAR 0 3
69870: PPUSH
69871: CALL 14501 0 1
69875: GO 69817
69877: POP
69878: POP
// end ;
69879: GO 69720
69881: POP
69882: POP
// end ;
69883: LD_VAR 0 1
69887: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
69888: LD_INT 0
69890: PPUSH
69891: PPUSH
69892: PPUSH
69893: PPUSH
69894: PPUSH
69895: PPUSH
69896: PPUSH
69897: PPUSH
69898: PPUSH
// if not mc_bases then
69899: LD_EXP 65
69903: NOT
69904: IFFALSE 69908
// exit ;
69906: GO 70530
// for i = 1 to mc_bases do
69908: LD_ADDR_VAR 0 2
69912: PUSH
69913: DOUBLE
69914: LD_INT 1
69916: DEC
69917: ST_TO_ADDR
69918: LD_EXP 65
69922: PUSH
69923: FOR_TO
69924: IFFALSE 70528
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
69926: LD_EXP 100
69930: PUSH
69931: LD_VAR 0 2
69935: ARRAY
69936: NOT
69937: PUSH
69938: LD_INT 38
69940: PPUSH
69941: LD_EXP 91
69945: PUSH
69946: LD_VAR 0 2
69950: ARRAY
69951: PPUSH
69952: CALL_OW 321
69956: PUSH
69957: LD_INT 2
69959: NONEQUAL
69960: OR
69961: IFFALSE 69965
// continue ;
69963: GO 69923
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
69965: LD_ADDR_VAR 0 8
69969: PUSH
69970: LD_EXP 65
69974: PUSH
69975: LD_VAR 0 2
69979: ARRAY
69980: PPUSH
69981: LD_INT 30
69983: PUSH
69984: LD_INT 34
69986: PUSH
69987: EMPTY
69988: LIST
69989: LIST
69990: PPUSH
69991: CALL_OW 72
69995: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
69996: LD_ADDR_VAR 0 9
70000: PUSH
70001: LD_EXP 65
70005: PUSH
70006: LD_VAR 0 2
70010: ARRAY
70011: PPUSH
70012: LD_INT 25
70014: PUSH
70015: LD_INT 4
70017: PUSH
70018: EMPTY
70019: LIST
70020: LIST
70021: PPUSH
70022: CALL_OW 72
70026: PPUSH
70027: LD_INT 0
70029: PPUSH
70030: CALL 47065 0 2
70034: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
70035: LD_VAR 0 9
70039: NOT
70040: PUSH
70041: LD_VAR 0 8
70045: NOT
70046: OR
70047: PUSH
70048: LD_EXP 65
70052: PUSH
70053: LD_VAR 0 2
70057: ARRAY
70058: PPUSH
70059: LD_INT 124
70061: PPUSH
70062: CALL 47065 0 2
70066: OR
70067: IFFALSE 70071
// continue ;
70069: GO 69923
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
70071: LD_EXP 101
70075: PUSH
70076: LD_VAR 0 2
70080: ARRAY
70081: PUSH
70082: LD_EXP 100
70086: PUSH
70087: LD_VAR 0 2
70091: ARRAY
70092: LESS
70093: PUSH
70094: LD_EXP 101
70098: PUSH
70099: LD_VAR 0 2
70103: ARRAY
70104: PUSH
70105: LD_VAR 0 8
70109: LESS
70110: AND
70111: IFFALSE 70526
// begin tmp := sci [ 1 ] ;
70113: LD_ADDR_VAR 0 7
70117: PUSH
70118: LD_VAR 0 9
70122: PUSH
70123: LD_INT 1
70125: ARRAY
70126: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
70127: LD_VAR 0 7
70131: PPUSH
70132: LD_INT 124
70134: PPUSH
70135: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
70139: LD_ADDR_VAR 0 3
70143: PUSH
70144: DOUBLE
70145: LD_EXP 100
70149: PUSH
70150: LD_VAR 0 2
70154: ARRAY
70155: INC
70156: ST_TO_ADDR
70157: LD_EXP 100
70161: PUSH
70162: LD_VAR 0 2
70166: ARRAY
70167: PUSH
70168: FOR_DOWNTO
70169: IFFALSE 70512
// begin if IsInUnit ( tmp ) then
70171: LD_VAR 0 7
70175: PPUSH
70176: CALL_OW 310
70180: IFFALSE 70191
// ComExitBuilding ( tmp ) ;
70182: LD_VAR 0 7
70186: PPUSH
70187: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
70191: LD_INT 35
70193: PPUSH
70194: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
70198: LD_VAR 0 7
70202: PPUSH
70203: CALL_OW 310
70207: NOT
70208: PUSH
70209: LD_VAR 0 7
70213: PPUSH
70214: CALL_OW 314
70218: NOT
70219: AND
70220: IFFALSE 70191
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
70222: LD_ADDR_VAR 0 6
70226: PUSH
70227: LD_VAR 0 7
70231: PPUSH
70232: CALL_OW 250
70236: PUSH
70237: LD_VAR 0 7
70241: PPUSH
70242: CALL_OW 251
70246: PUSH
70247: EMPTY
70248: LIST
70249: LIST
70250: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
70251: LD_INT 35
70253: PPUSH
70254: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
70258: LD_ADDR_VAR 0 4
70262: PUSH
70263: LD_EXP 100
70267: PUSH
70268: LD_VAR 0 2
70272: ARRAY
70273: PUSH
70274: LD_VAR 0 3
70278: ARRAY
70279: PUSH
70280: LD_INT 1
70282: ARRAY
70283: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
70284: LD_ADDR_VAR 0 5
70288: PUSH
70289: LD_EXP 100
70293: PUSH
70294: LD_VAR 0 2
70298: ARRAY
70299: PUSH
70300: LD_VAR 0 3
70304: ARRAY
70305: PUSH
70306: LD_INT 2
70308: ARRAY
70309: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
70310: LD_VAR 0 7
70314: PPUSH
70315: LD_INT 10
70317: PPUSH
70318: CALL 21097 0 2
70322: PUSH
70323: LD_INT 4
70325: ARRAY
70326: IFFALSE 70364
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
70328: LD_VAR 0 7
70332: PPUSH
70333: LD_VAR 0 6
70337: PUSH
70338: LD_INT 1
70340: ARRAY
70341: PPUSH
70342: LD_VAR 0 6
70346: PUSH
70347: LD_INT 2
70349: ARRAY
70350: PPUSH
70351: CALL_OW 111
// wait ( 0 0$10 ) ;
70355: LD_INT 350
70357: PPUSH
70358: CALL_OW 67
// end else
70362: GO 70390
// begin ComMoveXY ( tmp , x , y ) ;
70364: LD_VAR 0 7
70368: PPUSH
70369: LD_VAR 0 4
70373: PPUSH
70374: LD_VAR 0 5
70378: PPUSH
70379: CALL_OW 111
// wait ( 0 0$3 ) ;
70383: LD_INT 105
70385: PPUSH
70386: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
70390: LD_VAR 0 7
70394: PPUSH
70395: LD_VAR 0 4
70399: PPUSH
70400: LD_VAR 0 5
70404: PPUSH
70405: CALL_OW 307
70409: IFFALSE 70251
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
70411: LD_VAR 0 7
70415: PPUSH
70416: LD_VAR 0 4
70420: PPUSH
70421: LD_VAR 0 5
70425: PPUSH
70426: LD_VAR 0 8
70430: PUSH
70431: LD_VAR 0 3
70435: ARRAY
70436: PPUSH
70437: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
70441: LD_INT 35
70443: PPUSH
70444: CALL_OW 67
// until not HasTask ( tmp ) ;
70448: LD_VAR 0 7
70452: PPUSH
70453: CALL_OW 314
70457: NOT
70458: IFFALSE 70441
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
70460: LD_ADDR_EXP 101
70464: PUSH
70465: LD_EXP 101
70469: PPUSH
70470: LD_VAR 0 2
70474: PUSH
70475: LD_EXP 101
70479: PUSH
70480: LD_VAR 0 2
70484: ARRAY
70485: PUSH
70486: LD_INT 1
70488: PLUS
70489: PUSH
70490: EMPTY
70491: LIST
70492: LIST
70493: PPUSH
70494: LD_VAR 0 8
70498: PUSH
70499: LD_VAR 0 3
70503: ARRAY
70504: PPUSH
70505: CALL 18504 0 3
70509: ST_TO_ADDR
// end ;
70510: GO 70168
70512: POP
70513: POP
// MC_Reset ( i , 124 ) ;
70514: LD_VAR 0 2
70518: PPUSH
70519: LD_INT 124
70521: PPUSH
70522: CALL 54133 0 2
// end ; end ;
70526: GO 69923
70528: POP
70529: POP
// end ;
70530: LD_VAR 0 1
70534: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
70535: LD_INT 0
70537: PPUSH
70538: PPUSH
70539: PPUSH
// if not mc_bases then
70540: LD_EXP 65
70544: NOT
70545: IFFALSE 70549
// exit ;
70547: GO 71155
// for i = 1 to mc_bases do
70549: LD_ADDR_VAR 0 2
70553: PUSH
70554: DOUBLE
70555: LD_INT 1
70557: DEC
70558: ST_TO_ADDR
70559: LD_EXP 65
70563: PUSH
70564: FOR_TO
70565: IFFALSE 71153
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
70567: LD_ADDR_VAR 0 3
70571: PUSH
70572: LD_EXP 65
70576: PUSH
70577: LD_VAR 0 2
70581: ARRAY
70582: PPUSH
70583: LD_INT 25
70585: PUSH
70586: LD_INT 4
70588: PUSH
70589: EMPTY
70590: LIST
70591: LIST
70592: PPUSH
70593: CALL_OW 72
70597: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
70598: LD_VAR 0 3
70602: NOT
70603: PUSH
70604: LD_EXP 102
70608: PUSH
70609: LD_VAR 0 2
70613: ARRAY
70614: NOT
70615: OR
70616: PUSH
70617: LD_EXP 65
70621: PUSH
70622: LD_VAR 0 2
70626: ARRAY
70627: PPUSH
70628: LD_INT 2
70630: PUSH
70631: LD_INT 30
70633: PUSH
70634: LD_INT 0
70636: PUSH
70637: EMPTY
70638: LIST
70639: LIST
70640: PUSH
70641: LD_INT 30
70643: PUSH
70644: LD_INT 1
70646: PUSH
70647: EMPTY
70648: LIST
70649: LIST
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: LIST
70655: PPUSH
70656: CALL_OW 72
70660: NOT
70661: OR
70662: IFFALSE 70712
// begin if mc_deposits_finder [ i ] then
70664: LD_EXP 103
70668: PUSH
70669: LD_VAR 0 2
70673: ARRAY
70674: IFFALSE 70710
// begin MC_Reset ( i , 125 ) ;
70676: LD_VAR 0 2
70680: PPUSH
70681: LD_INT 125
70683: PPUSH
70684: CALL 54133 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
70688: LD_ADDR_EXP 103
70692: PUSH
70693: LD_EXP 103
70697: PPUSH
70698: LD_VAR 0 2
70702: PPUSH
70703: EMPTY
70704: PPUSH
70705: CALL_OW 1
70709: ST_TO_ADDR
// end ; continue ;
70710: GO 70564
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
70712: LD_EXP 102
70716: PUSH
70717: LD_VAR 0 2
70721: ARRAY
70722: PUSH
70723: LD_INT 1
70725: ARRAY
70726: PUSH
70727: LD_INT 3
70729: ARRAY
70730: PUSH
70731: LD_INT 1
70733: EQUAL
70734: PUSH
70735: LD_INT 20
70737: PPUSH
70738: LD_EXP 91
70742: PUSH
70743: LD_VAR 0 2
70747: ARRAY
70748: PPUSH
70749: CALL_OW 321
70753: PUSH
70754: LD_INT 2
70756: NONEQUAL
70757: AND
70758: IFFALSE 70808
// begin if mc_deposits_finder [ i ] then
70760: LD_EXP 103
70764: PUSH
70765: LD_VAR 0 2
70769: ARRAY
70770: IFFALSE 70806
// begin MC_Reset ( i , 125 ) ;
70772: LD_VAR 0 2
70776: PPUSH
70777: LD_INT 125
70779: PPUSH
70780: CALL 54133 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
70784: LD_ADDR_EXP 103
70788: PUSH
70789: LD_EXP 103
70793: PPUSH
70794: LD_VAR 0 2
70798: PPUSH
70799: EMPTY
70800: PPUSH
70801: CALL_OW 1
70805: ST_TO_ADDR
// end ; continue ;
70806: GO 70564
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
70808: LD_EXP 102
70812: PUSH
70813: LD_VAR 0 2
70817: ARRAY
70818: PUSH
70819: LD_INT 1
70821: ARRAY
70822: PUSH
70823: LD_INT 1
70825: ARRAY
70826: PPUSH
70827: LD_EXP 102
70831: PUSH
70832: LD_VAR 0 2
70836: ARRAY
70837: PUSH
70838: LD_INT 1
70840: ARRAY
70841: PUSH
70842: LD_INT 2
70844: ARRAY
70845: PPUSH
70846: LD_EXP 91
70850: PUSH
70851: LD_VAR 0 2
70855: ARRAY
70856: PPUSH
70857: CALL_OW 440
70861: IFFALSE 70904
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
70863: LD_ADDR_EXP 102
70867: PUSH
70868: LD_EXP 102
70872: PPUSH
70873: LD_VAR 0 2
70877: PPUSH
70878: LD_EXP 102
70882: PUSH
70883: LD_VAR 0 2
70887: ARRAY
70888: PPUSH
70889: LD_INT 1
70891: PPUSH
70892: CALL_OW 3
70896: PPUSH
70897: CALL_OW 1
70901: ST_TO_ADDR
70902: GO 71151
// begin if not mc_deposits_finder [ i ] then
70904: LD_EXP 103
70908: PUSH
70909: LD_VAR 0 2
70913: ARRAY
70914: NOT
70915: IFFALSE 70967
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
70917: LD_ADDR_EXP 103
70921: PUSH
70922: LD_EXP 103
70926: PPUSH
70927: LD_VAR 0 2
70931: PPUSH
70932: LD_VAR 0 3
70936: PUSH
70937: LD_INT 1
70939: ARRAY
70940: PUSH
70941: EMPTY
70942: LIST
70943: PPUSH
70944: CALL_OW 1
70948: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
70949: LD_VAR 0 3
70953: PUSH
70954: LD_INT 1
70956: ARRAY
70957: PPUSH
70958: LD_INT 125
70960: PPUSH
70961: CALL_OW 109
// end else
70965: GO 71151
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
70967: LD_EXP 103
70971: PUSH
70972: LD_VAR 0 2
70976: ARRAY
70977: PUSH
70978: LD_INT 1
70980: ARRAY
70981: PPUSH
70982: CALL_OW 310
70986: IFFALSE 71009
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
70988: LD_EXP 103
70992: PUSH
70993: LD_VAR 0 2
70997: ARRAY
70998: PUSH
70999: LD_INT 1
71001: ARRAY
71002: PPUSH
71003: CALL_OW 122
71007: GO 71151
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
71009: LD_EXP 103
71013: PUSH
71014: LD_VAR 0 2
71018: ARRAY
71019: PUSH
71020: LD_INT 1
71022: ARRAY
71023: PPUSH
71024: CALL_OW 314
71028: NOT
71029: PUSH
71030: LD_EXP 103
71034: PUSH
71035: LD_VAR 0 2
71039: ARRAY
71040: PUSH
71041: LD_INT 1
71043: ARRAY
71044: PPUSH
71045: LD_EXP 102
71049: PUSH
71050: LD_VAR 0 2
71054: ARRAY
71055: PUSH
71056: LD_INT 1
71058: ARRAY
71059: PUSH
71060: LD_INT 1
71062: ARRAY
71063: PPUSH
71064: LD_EXP 102
71068: PUSH
71069: LD_VAR 0 2
71073: ARRAY
71074: PUSH
71075: LD_INT 1
71077: ARRAY
71078: PUSH
71079: LD_INT 2
71081: ARRAY
71082: PPUSH
71083: CALL_OW 297
71087: PUSH
71088: LD_INT 6
71090: GREATER
71091: AND
71092: IFFALSE 71151
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
71094: LD_EXP 103
71098: PUSH
71099: LD_VAR 0 2
71103: ARRAY
71104: PUSH
71105: LD_INT 1
71107: ARRAY
71108: PPUSH
71109: LD_EXP 102
71113: PUSH
71114: LD_VAR 0 2
71118: ARRAY
71119: PUSH
71120: LD_INT 1
71122: ARRAY
71123: PUSH
71124: LD_INT 1
71126: ARRAY
71127: PPUSH
71128: LD_EXP 102
71132: PUSH
71133: LD_VAR 0 2
71137: ARRAY
71138: PUSH
71139: LD_INT 1
71141: ARRAY
71142: PUSH
71143: LD_INT 2
71145: ARRAY
71146: PPUSH
71147: CALL_OW 111
// end ; end ; end ;
71151: GO 70564
71153: POP
71154: POP
// end ;
71155: LD_VAR 0 1
71159: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
71160: LD_INT 0
71162: PPUSH
71163: PPUSH
71164: PPUSH
71165: PPUSH
71166: PPUSH
71167: PPUSH
71168: PPUSH
71169: PPUSH
71170: PPUSH
71171: PPUSH
71172: PPUSH
// if not mc_bases then
71173: LD_EXP 65
71177: NOT
71178: IFFALSE 71182
// exit ;
71180: GO 72122
// for i = 1 to mc_bases do
71182: LD_ADDR_VAR 0 2
71186: PUSH
71187: DOUBLE
71188: LD_INT 1
71190: DEC
71191: ST_TO_ADDR
71192: LD_EXP 65
71196: PUSH
71197: FOR_TO
71198: IFFALSE 72120
// begin if not mc_bases [ i ] or mc_scan [ i ] then
71200: LD_EXP 65
71204: PUSH
71205: LD_VAR 0 2
71209: ARRAY
71210: NOT
71211: PUSH
71212: LD_EXP 88
71216: PUSH
71217: LD_VAR 0 2
71221: ARRAY
71222: OR
71223: IFFALSE 71227
// continue ;
71225: GO 71197
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
71227: LD_ADDR_VAR 0 7
71231: PUSH
71232: LD_EXP 65
71236: PUSH
71237: LD_VAR 0 2
71241: ARRAY
71242: PUSH
71243: LD_INT 1
71245: ARRAY
71246: PPUSH
71247: CALL_OW 248
71251: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
71252: LD_VAR 0 7
71256: PUSH
71257: LD_INT 3
71259: EQUAL
71260: PUSH
71261: LD_EXP 84
71265: PUSH
71266: LD_VAR 0 2
71270: ARRAY
71271: PUSH
71272: LD_EXP 87
71276: PUSH
71277: LD_VAR 0 2
71281: ARRAY
71282: UNION
71283: PPUSH
71284: LD_INT 33
71286: PUSH
71287: LD_INT 2
71289: PUSH
71290: EMPTY
71291: LIST
71292: LIST
71293: PPUSH
71294: CALL_OW 72
71298: NOT
71299: OR
71300: IFFALSE 71304
// continue ;
71302: GO 71197
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
71304: LD_ADDR_VAR 0 9
71308: PUSH
71309: LD_EXP 65
71313: PUSH
71314: LD_VAR 0 2
71318: ARRAY
71319: PPUSH
71320: LD_INT 30
71322: PUSH
71323: LD_INT 36
71325: PUSH
71326: EMPTY
71327: LIST
71328: LIST
71329: PPUSH
71330: CALL_OW 72
71334: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
71335: LD_ADDR_VAR 0 10
71339: PUSH
71340: LD_EXP 84
71344: PUSH
71345: LD_VAR 0 2
71349: ARRAY
71350: PPUSH
71351: LD_INT 34
71353: PUSH
71354: LD_INT 31
71356: PUSH
71357: EMPTY
71358: LIST
71359: LIST
71360: PPUSH
71361: CALL_OW 72
71365: ST_TO_ADDR
// if not cts and not mcts then
71366: LD_VAR 0 9
71370: NOT
71371: PUSH
71372: LD_VAR 0 10
71376: NOT
71377: AND
71378: IFFALSE 71382
// continue ;
71380: GO 71197
// x := cts ;
71382: LD_ADDR_VAR 0 11
71386: PUSH
71387: LD_VAR 0 9
71391: ST_TO_ADDR
// if not x then
71392: LD_VAR 0 11
71396: NOT
71397: IFFALSE 71409
// x := mcts ;
71399: LD_ADDR_VAR 0 11
71403: PUSH
71404: LD_VAR 0 10
71408: ST_TO_ADDR
// if not x then
71409: LD_VAR 0 11
71413: NOT
71414: IFFALSE 71418
// continue ;
71416: GO 71197
// if mc_remote_driver [ i ] then
71418: LD_EXP 105
71422: PUSH
71423: LD_VAR 0 2
71427: ARRAY
71428: IFFALSE 71815
// for j in mc_remote_driver [ i ] do
71430: LD_ADDR_VAR 0 3
71434: PUSH
71435: LD_EXP 105
71439: PUSH
71440: LD_VAR 0 2
71444: ARRAY
71445: PUSH
71446: FOR_IN
71447: IFFALSE 71813
// begin if GetClass ( j ) <> 3 then
71449: LD_VAR 0 3
71453: PPUSH
71454: CALL_OW 257
71458: PUSH
71459: LD_INT 3
71461: NONEQUAL
71462: IFFALSE 71515
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
71464: LD_ADDR_EXP 105
71468: PUSH
71469: LD_EXP 105
71473: PPUSH
71474: LD_VAR 0 2
71478: PPUSH
71479: LD_EXP 105
71483: PUSH
71484: LD_VAR 0 2
71488: ARRAY
71489: PUSH
71490: LD_VAR 0 3
71494: DIFF
71495: PPUSH
71496: CALL_OW 1
71500: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71501: LD_VAR 0 3
71505: PPUSH
71506: LD_INT 0
71508: PPUSH
71509: CALL_OW 109
// continue ;
71513: GO 71446
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
71515: LD_EXP 84
71519: PUSH
71520: LD_VAR 0 2
71524: ARRAY
71525: PPUSH
71526: LD_INT 34
71528: PUSH
71529: LD_INT 31
71531: PUSH
71532: EMPTY
71533: LIST
71534: LIST
71535: PUSH
71536: LD_INT 58
71538: PUSH
71539: EMPTY
71540: LIST
71541: PUSH
71542: EMPTY
71543: LIST
71544: LIST
71545: PPUSH
71546: CALL_OW 72
71550: PUSH
71551: LD_VAR 0 3
71555: PPUSH
71556: CALL 47153 0 1
71560: NOT
71561: AND
71562: IFFALSE 71633
// begin if IsInUnit ( j ) then
71564: LD_VAR 0 3
71568: PPUSH
71569: CALL_OW 310
71573: IFFALSE 71584
// ComExitBuilding ( j ) ;
71575: LD_VAR 0 3
71579: PPUSH
71580: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
71584: LD_VAR 0 3
71588: PPUSH
71589: LD_EXP 84
71593: PUSH
71594: LD_VAR 0 2
71598: ARRAY
71599: PPUSH
71600: LD_INT 34
71602: PUSH
71603: LD_INT 31
71605: PUSH
71606: EMPTY
71607: LIST
71608: LIST
71609: PUSH
71610: LD_INT 58
71612: PUSH
71613: EMPTY
71614: LIST
71615: PUSH
71616: EMPTY
71617: LIST
71618: LIST
71619: PPUSH
71620: CALL_OW 72
71624: PUSH
71625: LD_INT 1
71627: ARRAY
71628: PPUSH
71629: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
71633: LD_VAR 0 3
71637: PPUSH
71638: CALL_OW 310
71642: NOT
71643: PUSH
71644: LD_VAR 0 3
71648: PPUSH
71649: CALL_OW 310
71653: PPUSH
71654: CALL_OW 266
71658: PUSH
71659: LD_INT 36
71661: NONEQUAL
71662: PUSH
71663: LD_VAR 0 3
71667: PPUSH
71668: CALL 47153 0 1
71672: NOT
71673: AND
71674: OR
71675: IFFALSE 71811
// begin if IsInUnit ( j ) then
71677: LD_VAR 0 3
71681: PPUSH
71682: CALL_OW 310
71686: IFFALSE 71697
// ComExitBuilding ( j ) ;
71688: LD_VAR 0 3
71692: PPUSH
71693: CALL_OW 122
// ct := 0 ;
71697: LD_ADDR_VAR 0 8
71701: PUSH
71702: LD_INT 0
71704: ST_TO_ADDR
// for k in x do
71705: LD_ADDR_VAR 0 4
71709: PUSH
71710: LD_VAR 0 11
71714: PUSH
71715: FOR_IN
71716: IFFALSE 71789
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
71718: LD_VAR 0 4
71722: PPUSH
71723: CALL_OW 264
71727: PUSH
71728: LD_INT 31
71730: EQUAL
71731: PUSH
71732: LD_VAR 0 4
71736: PPUSH
71737: CALL_OW 311
71741: NOT
71742: AND
71743: PUSH
71744: LD_VAR 0 4
71748: PPUSH
71749: CALL_OW 266
71753: PUSH
71754: LD_INT 36
71756: EQUAL
71757: PUSH
71758: LD_VAR 0 4
71762: PPUSH
71763: CALL_OW 313
71767: PUSH
71768: LD_INT 3
71770: LESS
71771: AND
71772: OR
71773: IFFALSE 71787
// begin ct := k ;
71775: LD_ADDR_VAR 0 8
71779: PUSH
71780: LD_VAR 0 4
71784: ST_TO_ADDR
// break ;
71785: GO 71789
// end ;
71787: GO 71715
71789: POP
71790: POP
// if ct then
71791: LD_VAR 0 8
71795: IFFALSE 71811
// ComEnterUnit ( j , ct ) ;
71797: LD_VAR 0 3
71801: PPUSH
71802: LD_VAR 0 8
71806: PPUSH
71807: CALL_OW 120
// end ; end ;
71811: GO 71446
71813: POP
71814: POP
// places := 0 ;
71815: LD_ADDR_VAR 0 5
71819: PUSH
71820: LD_INT 0
71822: ST_TO_ADDR
// for j = 1 to x do
71823: LD_ADDR_VAR 0 3
71827: PUSH
71828: DOUBLE
71829: LD_INT 1
71831: DEC
71832: ST_TO_ADDR
71833: LD_VAR 0 11
71837: PUSH
71838: FOR_TO
71839: IFFALSE 71915
// if GetWeapon ( x [ j ] ) = ar_control_tower then
71841: LD_VAR 0 11
71845: PUSH
71846: LD_VAR 0 3
71850: ARRAY
71851: PPUSH
71852: CALL_OW 264
71856: PUSH
71857: LD_INT 31
71859: EQUAL
71860: IFFALSE 71878
// places := places + 1 else
71862: LD_ADDR_VAR 0 5
71866: PUSH
71867: LD_VAR 0 5
71871: PUSH
71872: LD_INT 1
71874: PLUS
71875: ST_TO_ADDR
71876: GO 71913
// if GetBType ( x [ j ] ) = b_control_tower then
71878: LD_VAR 0 11
71882: PUSH
71883: LD_VAR 0 3
71887: ARRAY
71888: PPUSH
71889: CALL_OW 266
71893: PUSH
71894: LD_INT 36
71896: EQUAL
71897: IFFALSE 71913
// places := places + 3 ;
71899: LD_ADDR_VAR 0 5
71903: PUSH
71904: LD_VAR 0 5
71908: PUSH
71909: LD_INT 3
71911: PLUS
71912: ST_TO_ADDR
71913: GO 71838
71915: POP
71916: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
71917: LD_VAR 0 5
71921: PUSH
71922: LD_INT 0
71924: EQUAL
71925: PUSH
71926: LD_VAR 0 5
71930: PUSH
71931: LD_EXP 105
71935: PUSH
71936: LD_VAR 0 2
71940: ARRAY
71941: LESSEQUAL
71942: OR
71943: IFFALSE 71947
// continue ;
71945: GO 71197
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
71947: LD_ADDR_VAR 0 6
71951: PUSH
71952: LD_EXP 65
71956: PUSH
71957: LD_VAR 0 2
71961: ARRAY
71962: PPUSH
71963: LD_INT 25
71965: PUSH
71966: LD_INT 3
71968: PUSH
71969: EMPTY
71970: LIST
71971: LIST
71972: PPUSH
71973: CALL_OW 72
71977: PUSH
71978: LD_EXP 105
71982: PUSH
71983: LD_VAR 0 2
71987: ARRAY
71988: DIFF
71989: PPUSH
71990: LD_INT 3
71992: PPUSH
71993: CALL 48053 0 2
71997: ST_TO_ADDR
// for j in tmp do
71998: LD_ADDR_VAR 0 3
72002: PUSH
72003: LD_VAR 0 6
72007: PUSH
72008: FOR_IN
72009: IFFALSE 72044
// if GetTag ( j ) > 0 then
72011: LD_VAR 0 3
72015: PPUSH
72016: CALL_OW 110
72020: PUSH
72021: LD_INT 0
72023: GREATER
72024: IFFALSE 72042
// tmp := tmp diff j ;
72026: LD_ADDR_VAR 0 6
72030: PUSH
72031: LD_VAR 0 6
72035: PUSH
72036: LD_VAR 0 3
72040: DIFF
72041: ST_TO_ADDR
72042: GO 72008
72044: POP
72045: POP
// if not tmp then
72046: LD_VAR 0 6
72050: NOT
72051: IFFALSE 72055
// continue ;
72053: GO 71197
// if places then
72055: LD_VAR 0 5
72059: IFFALSE 72118
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
72061: LD_ADDR_EXP 105
72065: PUSH
72066: LD_EXP 105
72070: PPUSH
72071: LD_VAR 0 2
72075: PPUSH
72076: LD_EXP 105
72080: PUSH
72081: LD_VAR 0 2
72085: ARRAY
72086: PUSH
72087: LD_VAR 0 6
72091: PUSH
72092: LD_INT 1
72094: ARRAY
72095: UNION
72096: PPUSH
72097: CALL_OW 1
72101: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
72102: LD_VAR 0 6
72106: PUSH
72107: LD_INT 1
72109: ARRAY
72110: PPUSH
72111: LD_INT 126
72113: PPUSH
72114: CALL_OW 109
// end ; end ;
72118: GO 71197
72120: POP
72121: POP
// end ;
72122: LD_VAR 0 1
72126: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
72127: LD_INT 0
72129: PPUSH
72130: PPUSH
72131: PPUSH
72132: PPUSH
72133: PPUSH
72134: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
72135: LD_VAR 0 1
72139: NOT
72140: PUSH
72141: LD_VAR 0 2
72145: NOT
72146: OR
72147: PUSH
72148: LD_VAR 0 3
72152: NOT
72153: OR
72154: PUSH
72155: LD_VAR 0 4
72159: PUSH
72160: LD_INT 1
72162: PUSH
72163: LD_INT 2
72165: PUSH
72166: LD_INT 3
72168: PUSH
72169: LD_INT 4
72171: PUSH
72172: LD_INT 5
72174: PUSH
72175: LD_INT 8
72177: PUSH
72178: LD_INT 9
72180: PUSH
72181: LD_INT 15
72183: PUSH
72184: LD_INT 16
72186: PUSH
72187: EMPTY
72188: LIST
72189: LIST
72190: LIST
72191: LIST
72192: LIST
72193: LIST
72194: LIST
72195: LIST
72196: LIST
72197: IN
72198: NOT
72199: OR
72200: IFFALSE 72204
// exit ;
72202: GO 73104
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
72204: LD_ADDR_VAR 0 2
72208: PUSH
72209: LD_VAR 0 2
72213: PPUSH
72214: LD_INT 21
72216: PUSH
72217: LD_INT 3
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: PUSH
72224: LD_INT 24
72226: PUSH
72227: LD_INT 250
72229: PUSH
72230: EMPTY
72231: LIST
72232: LIST
72233: PUSH
72234: EMPTY
72235: LIST
72236: LIST
72237: PPUSH
72238: CALL_OW 72
72242: ST_TO_ADDR
// case class of 1 , 15 :
72243: LD_VAR 0 4
72247: PUSH
72248: LD_INT 1
72250: DOUBLE
72251: EQUAL
72252: IFTRUE 72262
72254: LD_INT 15
72256: DOUBLE
72257: EQUAL
72258: IFTRUE 72262
72260: GO 72347
72262: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
72263: LD_ADDR_VAR 0 8
72267: PUSH
72268: LD_VAR 0 2
72272: PPUSH
72273: LD_INT 2
72275: PUSH
72276: LD_INT 30
72278: PUSH
72279: LD_INT 32
72281: PUSH
72282: EMPTY
72283: LIST
72284: LIST
72285: PUSH
72286: LD_INT 30
72288: PUSH
72289: LD_INT 31
72291: PUSH
72292: EMPTY
72293: LIST
72294: LIST
72295: PUSH
72296: EMPTY
72297: LIST
72298: LIST
72299: LIST
72300: PPUSH
72301: CALL_OW 72
72305: PUSH
72306: LD_VAR 0 2
72310: PPUSH
72311: LD_INT 2
72313: PUSH
72314: LD_INT 30
72316: PUSH
72317: LD_INT 4
72319: PUSH
72320: EMPTY
72321: LIST
72322: LIST
72323: PUSH
72324: LD_INT 30
72326: PUSH
72327: LD_INT 5
72329: PUSH
72330: EMPTY
72331: LIST
72332: LIST
72333: PUSH
72334: EMPTY
72335: LIST
72336: LIST
72337: LIST
72338: PPUSH
72339: CALL_OW 72
72343: ADD
72344: ST_TO_ADDR
72345: GO 72593
72347: LD_INT 2
72349: DOUBLE
72350: EQUAL
72351: IFTRUE 72361
72353: LD_INT 16
72355: DOUBLE
72356: EQUAL
72357: IFTRUE 72361
72359: GO 72407
72361: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
72362: LD_ADDR_VAR 0 8
72366: PUSH
72367: LD_VAR 0 2
72371: PPUSH
72372: LD_INT 2
72374: PUSH
72375: LD_INT 30
72377: PUSH
72378: LD_INT 0
72380: PUSH
72381: EMPTY
72382: LIST
72383: LIST
72384: PUSH
72385: LD_INT 30
72387: PUSH
72388: LD_INT 1
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: LIST
72399: PPUSH
72400: CALL_OW 72
72404: ST_TO_ADDR
72405: GO 72593
72407: LD_INT 3
72409: DOUBLE
72410: EQUAL
72411: IFTRUE 72415
72413: GO 72461
72415: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
72416: LD_ADDR_VAR 0 8
72420: PUSH
72421: LD_VAR 0 2
72425: PPUSH
72426: LD_INT 2
72428: PUSH
72429: LD_INT 30
72431: PUSH
72432: LD_INT 2
72434: PUSH
72435: EMPTY
72436: LIST
72437: LIST
72438: PUSH
72439: LD_INT 30
72441: PUSH
72442: LD_INT 3
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PUSH
72449: EMPTY
72450: LIST
72451: LIST
72452: LIST
72453: PPUSH
72454: CALL_OW 72
72458: ST_TO_ADDR
72459: GO 72593
72461: LD_INT 4
72463: DOUBLE
72464: EQUAL
72465: IFTRUE 72469
72467: GO 72526
72469: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
72470: LD_ADDR_VAR 0 8
72474: PUSH
72475: LD_VAR 0 2
72479: PPUSH
72480: LD_INT 2
72482: PUSH
72483: LD_INT 30
72485: PUSH
72486: LD_INT 6
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: LD_INT 30
72495: PUSH
72496: LD_INT 7
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: PUSH
72503: LD_INT 30
72505: PUSH
72506: LD_INT 8
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: LIST
72517: LIST
72518: PPUSH
72519: CALL_OW 72
72523: ST_TO_ADDR
72524: GO 72593
72526: LD_INT 5
72528: DOUBLE
72529: EQUAL
72530: IFTRUE 72546
72532: LD_INT 8
72534: DOUBLE
72535: EQUAL
72536: IFTRUE 72546
72538: LD_INT 9
72540: DOUBLE
72541: EQUAL
72542: IFTRUE 72546
72544: GO 72592
72546: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
72547: LD_ADDR_VAR 0 8
72551: PUSH
72552: LD_VAR 0 2
72556: PPUSH
72557: LD_INT 2
72559: PUSH
72560: LD_INT 30
72562: PUSH
72563: LD_INT 4
72565: PUSH
72566: EMPTY
72567: LIST
72568: LIST
72569: PUSH
72570: LD_INT 30
72572: PUSH
72573: LD_INT 5
72575: PUSH
72576: EMPTY
72577: LIST
72578: LIST
72579: PUSH
72580: EMPTY
72581: LIST
72582: LIST
72583: LIST
72584: PPUSH
72585: CALL_OW 72
72589: ST_TO_ADDR
72590: GO 72593
72592: POP
// if not tmp then
72593: LD_VAR 0 8
72597: NOT
72598: IFFALSE 72602
// exit ;
72600: GO 73104
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
72602: LD_VAR 0 4
72606: PUSH
72607: LD_INT 1
72609: PUSH
72610: LD_INT 15
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: IN
72617: PUSH
72618: LD_EXP 74
72622: PUSH
72623: LD_VAR 0 1
72627: ARRAY
72628: AND
72629: IFFALSE 72785
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
72631: LD_ADDR_VAR 0 9
72635: PUSH
72636: LD_EXP 74
72640: PUSH
72641: LD_VAR 0 1
72645: ARRAY
72646: PUSH
72647: LD_INT 1
72649: ARRAY
72650: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
72651: LD_VAR 0 9
72655: PUSH
72656: LD_EXP 75
72660: PUSH
72661: LD_VAR 0 1
72665: ARRAY
72666: IN
72667: NOT
72668: IFFALSE 72783
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
72670: LD_ADDR_EXP 75
72674: PUSH
72675: LD_EXP 75
72679: PPUSH
72680: LD_VAR 0 1
72684: PUSH
72685: LD_EXP 75
72689: PUSH
72690: LD_VAR 0 1
72694: ARRAY
72695: PUSH
72696: LD_INT 1
72698: PLUS
72699: PUSH
72700: EMPTY
72701: LIST
72702: LIST
72703: PPUSH
72704: LD_VAR 0 9
72708: PPUSH
72709: CALL 18504 0 3
72713: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
72714: LD_ADDR_EXP 74
72718: PUSH
72719: LD_EXP 74
72723: PPUSH
72724: LD_VAR 0 1
72728: PPUSH
72729: LD_EXP 74
72733: PUSH
72734: LD_VAR 0 1
72738: ARRAY
72739: PUSH
72740: LD_VAR 0 9
72744: DIFF
72745: PPUSH
72746: CALL_OW 1
72750: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
72751: LD_VAR 0 3
72755: PPUSH
72756: LD_EXP 75
72760: PUSH
72761: LD_VAR 0 1
72765: ARRAY
72766: PUSH
72767: LD_EXP 75
72771: PUSH
72772: LD_VAR 0 1
72776: ARRAY
72777: ARRAY
72778: PPUSH
72779: CALL_OW 120
// end ; exit ;
72783: GO 73104
// end ; if tmp > 1 then
72785: LD_VAR 0 8
72789: PUSH
72790: LD_INT 1
72792: GREATER
72793: IFFALSE 72897
// for i = 2 to tmp do
72795: LD_ADDR_VAR 0 6
72799: PUSH
72800: DOUBLE
72801: LD_INT 2
72803: DEC
72804: ST_TO_ADDR
72805: LD_VAR 0 8
72809: PUSH
72810: FOR_TO
72811: IFFALSE 72895
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
72813: LD_VAR 0 8
72817: PUSH
72818: LD_VAR 0 6
72822: ARRAY
72823: PPUSH
72824: CALL_OW 461
72828: PUSH
72829: LD_INT 6
72831: EQUAL
72832: IFFALSE 72893
// begin x := tmp [ i ] ;
72834: LD_ADDR_VAR 0 9
72838: PUSH
72839: LD_VAR 0 8
72843: PUSH
72844: LD_VAR 0 6
72848: ARRAY
72849: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
72850: LD_ADDR_VAR 0 8
72854: PUSH
72855: LD_VAR 0 8
72859: PPUSH
72860: LD_VAR 0 6
72864: PPUSH
72865: CALL_OW 3
72869: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
72870: LD_ADDR_VAR 0 8
72874: PUSH
72875: LD_VAR 0 8
72879: PPUSH
72880: LD_INT 1
72882: PPUSH
72883: LD_VAR 0 9
72887: PPUSH
72888: CALL_OW 2
72892: ST_TO_ADDR
// end ;
72893: GO 72810
72895: POP
72896: POP
// for i in tmp do
72897: LD_ADDR_VAR 0 6
72901: PUSH
72902: LD_VAR 0 8
72906: PUSH
72907: FOR_IN
72908: IFFALSE 72977
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
72910: LD_VAR 0 6
72914: PPUSH
72915: CALL_OW 313
72919: PUSH
72920: LD_INT 6
72922: LESS
72923: PUSH
72924: LD_VAR 0 6
72928: PPUSH
72929: CALL_OW 266
72933: PUSH
72934: LD_INT 31
72936: PUSH
72937: LD_INT 32
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: IN
72944: NOT
72945: AND
72946: PUSH
72947: LD_VAR 0 6
72951: PPUSH
72952: CALL_OW 313
72956: PUSH
72957: LD_INT 0
72959: EQUAL
72960: OR
72961: IFFALSE 72975
// begin j := i ;
72963: LD_ADDR_VAR 0 7
72967: PUSH
72968: LD_VAR 0 6
72972: ST_TO_ADDR
// break ;
72973: GO 72977
// end ; end ;
72975: GO 72907
72977: POP
72978: POP
// if j then
72979: LD_VAR 0 7
72983: IFFALSE 73001
// ComEnterUnit ( unit , j ) else
72985: LD_VAR 0 3
72989: PPUSH
72990: LD_VAR 0 7
72994: PPUSH
72995: CALL_OW 120
72999: GO 73104
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73001: LD_ADDR_VAR 0 10
73005: PUSH
73006: LD_VAR 0 2
73010: PPUSH
73011: LD_INT 2
73013: PUSH
73014: LD_INT 30
73016: PUSH
73017: LD_INT 0
73019: PUSH
73020: EMPTY
73021: LIST
73022: LIST
73023: PUSH
73024: LD_INT 30
73026: PUSH
73027: LD_INT 1
73029: PUSH
73030: EMPTY
73031: LIST
73032: LIST
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: LIST
73038: PPUSH
73039: CALL_OW 72
73043: ST_TO_ADDR
// if depot then
73044: LD_VAR 0 10
73048: IFFALSE 73104
// begin depot := NearestUnitToUnit ( depot , unit ) ;
73050: LD_ADDR_VAR 0 10
73054: PUSH
73055: LD_VAR 0 10
73059: PPUSH
73060: LD_VAR 0 3
73064: PPUSH
73065: CALL_OW 74
73069: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
73070: LD_VAR 0 3
73074: PPUSH
73075: LD_VAR 0 10
73079: PPUSH
73080: CALL_OW 296
73084: PUSH
73085: LD_INT 10
73087: GREATER
73088: IFFALSE 73104
// ComStandNearbyBuilding ( unit , depot ) ;
73090: LD_VAR 0 3
73094: PPUSH
73095: LD_VAR 0 10
73099: PPUSH
73100: CALL 15118 0 2
// end ; end ; end ;
73104: LD_VAR 0 5
73108: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
73109: LD_INT 0
73111: PPUSH
73112: PPUSH
73113: PPUSH
73114: PPUSH
// if not mc_bases then
73115: LD_EXP 65
73119: NOT
73120: IFFALSE 73124
// exit ;
73122: GO 73363
// for i = 1 to mc_bases do
73124: LD_ADDR_VAR 0 2
73128: PUSH
73129: DOUBLE
73130: LD_INT 1
73132: DEC
73133: ST_TO_ADDR
73134: LD_EXP 65
73138: PUSH
73139: FOR_TO
73140: IFFALSE 73361
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
73142: LD_ADDR_VAR 0 4
73146: PUSH
73147: LD_EXP 65
73151: PUSH
73152: LD_VAR 0 2
73156: ARRAY
73157: PPUSH
73158: LD_INT 21
73160: PUSH
73161: LD_INT 1
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PPUSH
73168: CALL_OW 72
73172: PUSH
73173: LD_EXP 94
73177: PUSH
73178: LD_VAR 0 2
73182: ARRAY
73183: UNION
73184: ST_TO_ADDR
// if not tmp then
73185: LD_VAR 0 4
73189: NOT
73190: IFFALSE 73194
// continue ;
73192: GO 73139
// for j in tmp do
73194: LD_ADDR_VAR 0 3
73198: PUSH
73199: LD_VAR 0 4
73203: PUSH
73204: FOR_IN
73205: IFFALSE 73357
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
73207: LD_VAR 0 3
73211: PPUSH
73212: CALL_OW 110
73216: NOT
73217: PUSH
73218: LD_VAR 0 3
73222: PPUSH
73223: CALL_OW 314
73227: NOT
73228: AND
73229: PUSH
73230: LD_VAR 0 3
73234: PPUSH
73235: CALL_OW 311
73239: NOT
73240: AND
73241: PUSH
73242: LD_VAR 0 3
73246: PPUSH
73247: CALL_OW 310
73251: NOT
73252: AND
73253: PUSH
73254: LD_VAR 0 3
73258: PUSH
73259: LD_EXP 68
73263: PUSH
73264: LD_VAR 0 2
73268: ARRAY
73269: PUSH
73270: LD_INT 1
73272: ARRAY
73273: IN
73274: NOT
73275: AND
73276: PUSH
73277: LD_VAR 0 3
73281: PUSH
73282: LD_EXP 68
73286: PUSH
73287: LD_VAR 0 2
73291: ARRAY
73292: PUSH
73293: LD_INT 2
73295: ARRAY
73296: IN
73297: NOT
73298: AND
73299: PUSH
73300: LD_VAR 0 3
73304: PUSH
73305: LD_EXP 77
73309: PUSH
73310: LD_VAR 0 2
73314: ARRAY
73315: IN
73316: NOT
73317: AND
73318: IFFALSE 73355
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
73320: LD_VAR 0 2
73324: PPUSH
73325: LD_EXP 65
73329: PUSH
73330: LD_VAR 0 2
73334: ARRAY
73335: PPUSH
73336: LD_VAR 0 3
73340: PPUSH
73341: LD_VAR 0 3
73345: PPUSH
73346: CALL_OW 257
73350: PPUSH
73351: CALL 72127 0 4
// end ;
73355: GO 73204
73357: POP
73358: POP
// end ;
73359: GO 73139
73361: POP
73362: POP
// end ;
73363: LD_VAR 0 1
73367: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
73368: LD_INT 0
73370: PPUSH
73371: PPUSH
73372: PPUSH
73373: PPUSH
73374: PPUSH
73375: PPUSH
// if not mc_bases [ base ] then
73376: LD_EXP 65
73380: PUSH
73381: LD_VAR 0 1
73385: ARRAY
73386: NOT
73387: IFFALSE 73391
// exit ;
73389: GO 73573
// tmp := [ ] ;
73391: LD_ADDR_VAR 0 6
73395: PUSH
73396: EMPTY
73397: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
73398: LD_ADDR_VAR 0 7
73402: PUSH
73403: LD_VAR 0 3
73407: PPUSH
73408: LD_INT 0
73410: PPUSH
73411: CALL_OW 517
73415: ST_TO_ADDR
// if not list then
73416: LD_VAR 0 7
73420: NOT
73421: IFFALSE 73425
// exit ;
73423: GO 73573
// for i = 1 to amount do
73425: LD_ADDR_VAR 0 5
73429: PUSH
73430: DOUBLE
73431: LD_INT 1
73433: DEC
73434: ST_TO_ADDR
73435: LD_VAR 0 2
73439: PUSH
73440: FOR_TO
73441: IFFALSE 73521
// begin x := rand ( 1 , list [ 1 ] ) ;
73443: LD_ADDR_VAR 0 8
73447: PUSH
73448: LD_INT 1
73450: PPUSH
73451: LD_VAR 0 7
73455: PUSH
73456: LD_INT 1
73458: ARRAY
73459: PPUSH
73460: CALL_OW 12
73464: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
73465: LD_ADDR_VAR 0 6
73469: PUSH
73470: LD_VAR 0 6
73474: PPUSH
73475: LD_VAR 0 5
73479: PPUSH
73480: LD_VAR 0 7
73484: PUSH
73485: LD_INT 1
73487: ARRAY
73488: PUSH
73489: LD_VAR 0 8
73493: ARRAY
73494: PUSH
73495: LD_VAR 0 7
73499: PUSH
73500: LD_INT 2
73502: ARRAY
73503: PUSH
73504: LD_VAR 0 8
73508: ARRAY
73509: PUSH
73510: EMPTY
73511: LIST
73512: LIST
73513: PPUSH
73514: CALL_OW 1
73518: ST_TO_ADDR
// end ;
73519: GO 73440
73521: POP
73522: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
73523: LD_ADDR_EXP 78
73527: PUSH
73528: LD_EXP 78
73532: PPUSH
73533: LD_VAR 0 1
73537: PPUSH
73538: LD_VAR 0 6
73542: PPUSH
73543: CALL_OW 1
73547: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
73548: LD_ADDR_EXP 80
73552: PUSH
73553: LD_EXP 80
73557: PPUSH
73558: LD_VAR 0 1
73562: PPUSH
73563: LD_VAR 0 3
73567: PPUSH
73568: CALL_OW 1
73572: ST_TO_ADDR
// end ;
73573: LD_VAR 0 4
73577: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
73578: LD_INT 0
73580: PPUSH
// if not mc_bases [ base ] then
73581: LD_EXP 65
73585: PUSH
73586: LD_VAR 0 1
73590: ARRAY
73591: NOT
73592: IFFALSE 73596
// exit ;
73594: GO 73621
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
73596: LD_ADDR_EXP 70
73600: PUSH
73601: LD_EXP 70
73605: PPUSH
73606: LD_VAR 0 1
73610: PPUSH
73611: LD_VAR 0 2
73615: PPUSH
73616: CALL_OW 1
73620: ST_TO_ADDR
// end ;
73621: LD_VAR 0 3
73625: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
73626: LD_INT 0
73628: PPUSH
// if not mc_bases [ base ] then
73629: LD_EXP 65
73633: PUSH
73634: LD_VAR 0 1
73638: ARRAY
73639: NOT
73640: IFFALSE 73644
// exit ;
73642: GO 73681
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
73644: LD_ADDR_EXP 70
73648: PUSH
73649: LD_EXP 70
73653: PPUSH
73654: LD_VAR 0 1
73658: PPUSH
73659: LD_EXP 70
73663: PUSH
73664: LD_VAR 0 1
73668: ARRAY
73669: PUSH
73670: LD_VAR 0 2
73674: UNION
73675: PPUSH
73676: CALL_OW 1
73680: ST_TO_ADDR
// end ;
73681: LD_VAR 0 3
73685: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
73686: LD_INT 0
73688: PPUSH
// if not mc_bases [ base ] then
73689: LD_EXP 65
73693: PUSH
73694: LD_VAR 0 1
73698: ARRAY
73699: NOT
73700: IFFALSE 73704
// exit ;
73702: GO 73729
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
73704: LD_ADDR_EXP 86
73708: PUSH
73709: LD_EXP 86
73713: PPUSH
73714: LD_VAR 0 1
73718: PPUSH
73719: LD_VAR 0 2
73723: PPUSH
73724: CALL_OW 1
73728: ST_TO_ADDR
// end ;
73729: LD_VAR 0 3
73733: RET
// export function MC_InsertProduceList ( base , components ) ; begin
73734: LD_INT 0
73736: PPUSH
// if not mc_bases [ base ] then
73737: LD_EXP 65
73741: PUSH
73742: LD_VAR 0 1
73746: ARRAY
73747: NOT
73748: IFFALSE 73752
// exit ;
73750: GO 73789
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
73752: LD_ADDR_EXP 86
73756: PUSH
73757: LD_EXP 86
73761: PPUSH
73762: LD_VAR 0 1
73766: PPUSH
73767: LD_EXP 86
73771: PUSH
73772: LD_VAR 0 1
73776: ARRAY
73777: PUSH
73778: LD_VAR 0 2
73782: ADD
73783: PPUSH
73784: CALL_OW 1
73788: ST_TO_ADDR
// end ;
73789: LD_VAR 0 3
73793: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
73794: LD_INT 0
73796: PPUSH
// if not mc_bases [ base ] then
73797: LD_EXP 65
73801: PUSH
73802: LD_VAR 0 1
73806: ARRAY
73807: NOT
73808: IFFALSE 73812
// exit ;
73810: GO 73866
// mc_defender := Replace ( mc_defender , base , deflist ) ;
73812: LD_ADDR_EXP 87
73816: PUSH
73817: LD_EXP 87
73821: PPUSH
73822: LD_VAR 0 1
73826: PPUSH
73827: LD_VAR 0 2
73831: PPUSH
73832: CALL_OW 1
73836: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
73837: LD_ADDR_EXP 76
73841: PUSH
73842: LD_EXP 76
73846: PPUSH
73847: LD_VAR 0 1
73851: PPUSH
73852: LD_VAR 0 2
73856: PUSH
73857: LD_INT 0
73859: PLUS
73860: PPUSH
73861: CALL_OW 1
73865: ST_TO_ADDR
// end ;
73866: LD_VAR 0 3
73870: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
73871: LD_INT 0
73873: PPUSH
// if not mc_bases [ base ] then
73874: LD_EXP 65
73878: PUSH
73879: LD_VAR 0 1
73883: ARRAY
73884: NOT
73885: IFFALSE 73889
// exit ;
73887: GO 73914
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
73889: LD_ADDR_EXP 76
73893: PUSH
73894: LD_EXP 76
73898: PPUSH
73899: LD_VAR 0 1
73903: PPUSH
73904: LD_VAR 0 2
73908: PPUSH
73909: CALL_OW 1
73913: ST_TO_ADDR
// end ;
73914: LD_VAR 0 3
73918: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
73919: LD_INT 0
73921: PPUSH
73922: PPUSH
73923: PPUSH
73924: PPUSH
// if not mc_bases [ base ] then
73925: LD_EXP 65
73929: PUSH
73930: LD_VAR 0 1
73934: ARRAY
73935: NOT
73936: IFFALSE 73940
// exit ;
73938: GO 74005
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
73940: LD_ADDR_EXP 85
73944: PUSH
73945: LD_EXP 85
73949: PPUSH
73950: LD_VAR 0 1
73954: PUSH
73955: LD_EXP 85
73959: PUSH
73960: LD_VAR 0 1
73964: ARRAY
73965: PUSH
73966: LD_INT 1
73968: PLUS
73969: PUSH
73970: EMPTY
73971: LIST
73972: LIST
73973: PPUSH
73974: LD_VAR 0 1
73978: PUSH
73979: LD_VAR 0 2
73983: PUSH
73984: LD_VAR 0 3
73988: PUSH
73989: LD_VAR 0 4
73993: PUSH
73994: EMPTY
73995: LIST
73996: LIST
73997: LIST
73998: LIST
73999: PPUSH
74000: CALL 18504 0 3
74004: ST_TO_ADDR
// end ;
74005: LD_VAR 0 5
74009: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
74010: LD_INT 0
74012: PPUSH
// if not mc_bases [ base ] then
74013: LD_EXP 65
74017: PUSH
74018: LD_VAR 0 1
74022: ARRAY
74023: NOT
74024: IFFALSE 74028
// exit ;
74026: GO 74053
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
74028: LD_ADDR_EXP 102
74032: PUSH
74033: LD_EXP 102
74037: PPUSH
74038: LD_VAR 0 1
74042: PPUSH
74043: LD_VAR 0 2
74047: PPUSH
74048: CALL_OW 1
74052: ST_TO_ADDR
// end ;
74053: LD_VAR 0 3
74057: RET
// export function MC_GetMinesField ( base ) ; begin
74058: LD_INT 0
74060: PPUSH
// result := mc_mines [ base ] ;
74061: LD_ADDR_VAR 0 2
74065: PUSH
74066: LD_EXP 78
74070: PUSH
74071: LD_VAR 0 1
74075: ARRAY
74076: ST_TO_ADDR
// end ;
74077: LD_VAR 0 2
74081: RET
// export function MC_GetProduceList ( base ) ; begin
74082: LD_INT 0
74084: PPUSH
// result := mc_produce [ base ] ;
74085: LD_ADDR_VAR 0 2
74089: PUSH
74090: LD_EXP 86
74094: PUSH
74095: LD_VAR 0 1
74099: ARRAY
74100: ST_TO_ADDR
// end ;
74101: LD_VAR 0 2
74105: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
74106: LD_INT 0
74108: PPUSH
74109: PPUSH
// if not mc_bases then
74110: LD_EXP 65
74114: NOT
74115: IFFALSE 74119
// exit ;
74117: GO 74184
// if mc_bases [ base ] then
74119: LD_EXP 65
74123: PUSH
74124: LD_VAR 0 1
74128: ARRAY
74129: IFFALSE 74184
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74131: LD_ADDR_VAR 0 3
74135: PUSH
74136: LD_EXP 65
74140: PUSH
74141: LD_VAR 0 1
74145: ARRAY
74146: PPUSH
74147: LD_INT 30
74149: PUSH
74150: LD_VAR 0 2
74154: PUSH
74155: EMPTY
74156: LIST
74157: LIST
74158: PPUSH
74159: CALL_OW 72
74163: ST_TO_ADDR
// if result then
74164: LD_VAR 0 3
74168: IFFALSE 74184
// result := result [ 1 ] ;
74170: LD_ADDR_VAR 0 3
74174: PUSH
74175: LD_VAR 0 3
74179: PUSH
74180: LD_INT 1
74182: ARRAY
74183: ST_TO_ADDR
// end ; end ;
74184: LD_VAR 0 3
74188: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
74189: LD_INT 0
74191: PPUSH
74192: PPUSH
// if not mc_bases then
74193: LD_EXP 65
74197: NOT
74198: IFFALSE 74202
// exit ;
74200: GO 74247
// if mc_bases [ base ] then
74202: LD_EXP 65
74206: PUSH
74207: LD_VAR 0 1
74211: ARRAY
74212: IFFALSE 74247
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74214: LD_ADDR_VAR 0 3
74218: PUSH
74219: LD_EXP 65
74223: PUSH
74224: LD_VAR 0 1
74228: ARRAY
74229: PPUSH
74230: LD_INT 30
74232: PUSH
74233: LD_VAR 0 2
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PPUSH
74242: CALL_OW 72
74246: ST_TO_ADDR
// end ;
74247: LD_VAR 0 3
74251: RET
// export function MC_SetTame ( base , area ) ; begin
74252: LD_INT 0
74254: PPUSH
// if not mc_bases or not base then
74255: LD_EXP 65
74259: NOT
74260: PUSH
74261: LD_VAR 0 1
74265: NOT
74266: OR
74267: IFFALSE 74271
// exit ;
74269: GO 74296
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
74271: LD_ADDR_EXP 93
74275: PUSH
74276: LD_EXP 93
74280: PPUSH
74281: LD_VAR 0 1
74285: PPUSH
74286: LD_VAR 0 2
74290: PPUSH
74291: CALL_OW 1
74295: ST_TO_ADDR
// end ;
74296: LD_VAR 0 3
74300: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
74301: LD_INT 0
74303: PPUSH
74304: PPUSH
// if not mc_bases or not base then
74305: LD_EXP 65
74309: NOT
74310: PUSH
74311: LD_VAR 0 1
74315: NOT
74316: OR
74317: IFFALSE 74321
// exit ;
74319: GO 74423
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74321: LD_ADDR_VAR 0 4
74325: PUSH
74326: LD_EXP 65
74330: PUSH
74331: LD_VAR 0 1
74335: ARRAY
74336: PPUSH
74337: LD_INT 30
74339: PUSH
74340: LD_VAR 0 2
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: PPUSH
74349: CALL_OW 72
74353: ST_TO_ADDR
// if not tmp then
74354: LD_VAR 0 4
74358: NOT
74359: IFFALSE 74363
// exit ;
74361: GO 74423
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
74363: LD_ADDR_EXP 97
74367: PUSH
74368: LD_EXP 97
74372: PPUSH
74373: LD_VAR 0 1
74377: PPUSH
74378: LD_EXP 97
74382: PUSH
74383: LD_VAR 0 1
74387: ARRAY
74388: PPUSH
74389: LD_EXP 97
74393: PUSH
74394: LD_VAR 0 1
74398: ARRAY
74399: PUSH
74400: LD_INT 1
74402: PLUS
74403: PPUSH
74404: LD_VAR 0 4
74408: PUSH
74409: LD_INT 1
74411: ARRAY
74412: PPUSH
74413: CALL_OW 2
74417: PPUSH
74418: CALL_OW 1
74422: ST_TO_ADDR
// end ;
74423: LD_VAR 0 3
74427: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
74428: LD_INT 0
74430: PPUSH
74431: PPUSH
// if not mc_bases or not base or not kinds then
74432: LD_EXP 65
74436: NOT
74437: PUSH
74438: LD_VAR 0 1
74442: NOT
74443: OR
74444: PUSH
74445: LD_VAR 0 2
74449: NOT
74450: OR
74451: IFFALSE 74455
// exit ;
74453: GO 74516
// for i in kinds do
74455: LD_ADDR_VAR 0 4
74459: PUSH
74460: LD_VAR 0 2
74464: PUSH
74465: FOR_IN
74466: IFFALSE 74514
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
74468: LD_ADDR_EXP 99
74472: PUSH
74473: LD_EXP 99
74477: PPUSH
74478: LD_VAR 0 1
74482: PUSH
74483: LD_EXP 99
74487: PUSH
74488: LD_VAR 0 1
74492: ARRAY
74493: PUSH
74494: LD_INT 1
74496: PLUS
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PPUSH
74502: LD_VAR 0 4
74506: PPUSH
74507: CALL 18504 0 3
74511: ST_TO_ADDR
74512: GO 74465
74514: POP
74515: POP
// end ;
74516: LD_VAR 0 3
74520: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
74521: LD_INT 0
74523: PPUSH
// if not mc_bases or not base or not areas then
74524: LD_EXP 65
74528: NOT
74529: PUSH
74530: LD_VAR 0 1
74534: NOT
74535: OR
74536: PUSH
74537: LD_VAR 0 2
74541: NOT
74542: OR
74543: IFFALSE 74547
// exit ;
74545: GO 74572
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
74547: LD_ADDR_EXP 83
74551: PUSH
74552: LD_EXP 83
74556: PPUSH
74557: LD_VAR 0 1
74561: PPUSH
74562: LD_VAR 0 2
74566: PPUSH
74567: CALL_OW 1
74571: ST_TO_ADDR
// end ;
74572: LD_VAR 0 3
74576: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
74577: LD_INT 0
74579: PPUSH
// if not mc_bases or not base or not teleports_exit then
74580: LD_EXP 65
74584: NOT
74585: PUSH
74586: LD_VAR 0 1
74590: NOT
74591: OR
74592: PUSH
74593: LD_VAR 0 2
74597: NOT
74598: OR
74599: IFFALSE 74603
// exit ;
74601: GO 74628
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
74603: LD_ADDR_EXP 100
74607: PUSH
74608: LD_EXP 100
74612: PPUSH
74613: LD_VAR 0 1
74617: PPUSH
74618: LD_VAR 0 2
74622: PPUSH
74623: CALL_OW 1
74627: ST_TO_ADDR
// end ;
74628: LD_VAR 0 3
74632: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
74633: LD_INT 0
74635: PPUSH
74636: PPUSH
74637: PPUSH
// if not mc_bases or not base or not ext_list then
74638: LD_EXP 65
74642: NOT
74643: PUSH
74644: LD_VAR 0 1
74648: NOT
74649: OR
74650: PUSH
74651: LD_VAR 0 5
74655: NOT
74656: OR
74657: IFFALSE 74661
// exit ;
74659: GO 74834
// tmp := GetFacExtXYD ( x , y , d ) ;
74661: LD_ADDR_VAR 0 8
74665: PUSH
74666: LD_VAR 0 2
74670: PPUSH
74671: LD_VAR 0 3
74675: PPUSH
74676: LD_VAR 0 4
74680: PPUSH
74681: CALL 47183 0 3
74685: ST_TO_ADDR
// if not tmp then
74686: LD_VAR 0 8
74690: NOT
74691: IFFALSE 74695
// exit ;
74693: GO 74834
// for i in tmp do
74695: LD_ADDR_VAR 0 7
74699: PUSH
74700: LD_VAR 0 8
74704: PUSH
74705: FOR_IN
74706: IFFALSE 74832
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
74708: LD_ADDR_EXP 70
74712: PUSH
74713: LD_EXP 70
74717: PPUSH
74718: LD_VAR 0 1
74722: PPUSH
74723: LD_EXP 70
74727: PUSH
74728: LD_VAR 0 1
74732: ARRAY
74733: PPUSH
74734: LD_EXP 70
74738: PUSH
74739: LD_VAR 0 1
74743: ARRAY
74744: PUSH
74745: LD_INT 1
74747: PLUS
74748: PPUSH
74749: LD_VAR 0 5
74753: PUSH
74754: LD_INT 1
74756: ARRAY
74757: PUSH
74758: LD_VAR 0 7
74762: PUSH
74763: LD_INT 1
74765: ARRAY
74766: PUSH
74767: LD_VAR 0 7
74771: PUSH
74772: LD_INT 2
74774: ARRAY
74775: PUSH
74776: LD_VAR 0 7
74780: PUSH
74781: LD_INT 3
74783: ARRAY
74784: PUSH
74785: EMPTY
74786: LIST
74787: LIST
74788: LIST
74789: LIST
74790: PPUSH
74791: CALL_OW 2
74795: PPUSH
74796: CALL_OW 1
74800: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
74801: LD_ADDR_VAR 0 5
74805: PUSH
74806: LD_VAR 0 5
74810: PPUSH
74811: LD_INT 1
74813: PPUSH
74814: CALL_OW 3
74818: ST_TO_ADDR
// if not ext_list then
74819: LD_VAR 0 5
74823: NOT
74824: IFFALSE 74830
// exit ;
74826: POP
74827: POP
74828: GO 74834
// end ;
74830: GO 74705
74832: POP
74833: POP
// end ;
74834: LD_VAR 0 6
74838: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
74839: LD_INT 0
74841: PPUSH
// if not mc_bases or not base or not weapon_list then
74842: LD_EXP 65
74846: NOT
74847: PUSH
74848: LD_VAR 0 1
74852: NOT
74853: OR
74854: PUSH
74855: LD_VAR 0 2
74859: NOT
74860: OR
74861: IFFALSE 74865
// exit ;
74863: GO 74890
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
74865: LD_ADDR_EXP 104
74869: PUSH
74870: LD_EXP 104
74874: PPUSH
74875: LD_VAR 0 1
74879: PPUSH
74880: LD_VAR 0 2
74884: PPUSH
74885: CALL_OW 1
74889: ST_TO_ADDR
// end ;
74890: LD_VAR 0 3
74894: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
74895: LD_INT 0
74897: PPUSH
// if not mc_bases or not base or not tech_list then
74898: LD_EXP 65
74902: NOT
74903: PUSH
74904: LD_VAR 0 1
74908: NOT
74909: OR
74910: PUSH
74911: LD_VAR 0 2
74915: NOT
74916: OR
74917: IFFALSE 74921
// exit ;
74919: GO 74946
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
74921: LD_ADDR_EXP 92
74925: PUSH
74926: LD_EXP 92
74930: PPUSH
74931: LD_VAR 0 1
74935: PPUSH
74936: LD_VAR 0 2
74940: PPUSH
74941: CALL_OW 1
74945: ST_TO_ADDR
// end ;
74946: LD_VAR 0 3
74950: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
74951: LD_INT 0
74953: PPUSH
// if not mc_bases or not parking_area or not base then
74954: LD_EXP 65
74958: NOT
74959: PUSH
74960: LD_VAR 0 2
74964: NOT
74965: OR
74966: PUSH
74967: LD_VAR 0 1
74971: NOT
74972: OR
74973: IFFALSE 74977
// exit ;
74975: GO 75002
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
74977: LD_ADDR_EXP 89
74981: PUSH
74982: LD_EXP 89
74986: PPUSH
74987: LD_VAR 0 1
74991: PPUSH
74992: LD_VAR 0 2
74996: PPUSH
74997: CALL_OW 1
75001: ST_TO_ADDR
// end ;
75002: LD_VAR 0 3
75006: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
75007: LD_INT 0
75009: PPUSH
// if not mc_bases or not base or not scan_area then
75010: LD_EXP 65
75014: NOT
75015: PUSH
75016: LD_VAR 0 1
75020: NOT
75021: OR
75022: PUSH
75023: LD_VAR 0 2
75027: NOT
75028: OR
75029: IFFALSE 75033
// exit ;
75031: GO 75058
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
75033: LD_ADDR_EXP 90
75037: PUSH
75038: LD_EXP 90
75042: PPUSH
75043: LD_VAR 0 1
75047: PPUSH
75048: LD_VAR 0 2
75052: PPUSH
75053: CALL_OW 1
75057: ST_TO_ADDR
// end ;
75058: LD_VAR 0 3
75062: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
75063: LD_INT 0
75065: PPUSH
75066: PPUSH
// if not mc_bases or not base then
75067: LD_EXP 65
75071: NOT
75072: PUSH
75073: LD_VAR 0 1
75077: NOT
75078: OR
75079: IFFALSE 75083
// exit ;
75081: GO 75147
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
75083: LD_ADDR_VAR 0 3
75087: PUSH
75088: LD_INT 1
75090: PUSH
75091: LD_INT 2
75093: PUSH
75094: LD_INT 3
75096: PUSH
75097: LD_INT 4
75099: PUSH
75100: LD_INT 11
75102: PUSH
75103: EMPTY
75104: LIST
75105: LIST
75106: LIST
75107: LIST
75108: LIST
75109: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
75110: LD_ADDR_EXP 92
75114: PUSH
75115: LD_EXP 92
75119: PPUSH
75120: LD_VAR 0 1
75124: PPUSH
75125: LD_EXP 92
75129: PUSH
75130: LD_VAR 0 1
75134: ARRAY
75135: PUSH
75136: LD_VAR 0 3
75140: DIFF
75141: PPUSH
75142: CALL_OW 1
75146: ST_TO_ADDR
// end ;
75147: LD_VAR 0 2
75151: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
75152: LD_INT 0
75154: PPUSH
// result := mc_vehicles [ base ] ;
75155: LD_ADDR_VAR 0 3
75159: PUSH
75160: LD_EXP 84
75164: PUSH
75165: LD_VAR 0 1
75169: ARRAY
75170: ST_TO_ADDR
// if onlyCombat then
75171: LD_VAR 0 2
75175: IFFALSE 75340
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
75177: LD_ADDR_VAR 0 3
75181: PUSH
75182: LD_VAR 0 3
75186: PUSH
75187: LD_VAR 0 3
75191: PPUSH
75192: LD_INT 2
75194: PUSH
75195: LD_INT 34
75197: PUSH
75198: LD_INT 12
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: PUSH
75205: LD_INT 34
75207: PUSH
75208: LD_INT 51
75210: PUSH
75211: EMPTY
75212: LIST
75213: LIST
75214: PUSH
75215: LD_INT 34
75217: PUSH
75218: LD_EXP 49
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: LD_INT 34
75229: PUSH
75230: LD_INT 32
75232: PUSH
75233: EMPTY
75234: LIST
75235: LIST
75236: PUSH
75237: LD_INT 34
75239: PUSH
75240: LD_INT 13
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: PUSH
75247: LD_INT 34
75249: PUSH
75250: LD_INT 52
75252: PUSH
75253: EMPTY
75254: LIST
75255: LIST
75256: PUSH
75257: LD_INT 34
75259: PUSH
75260: LD_INT 14
75262: PUSH
75263: EMPTY
75264: LIST
75265: LIST
75266: PUSH
75267: LD_INT 34
75269: PUSH
75270: LD_INT 53
75272: PUSH
75273: EMPTY
75274: LIST
75275: LIST
75276: PUSH
75277: LD_INT 34
75279: PUSH
75280: LD_EXP 48
75284: PUSH
75285: EMPTY
75286: LIST
75287: LIST
75288: PUSH
75289: LD_INT 34
75291: PUSH
75292: LD_INT 31
75294: PUSH
75295: EMPTY
75296: LIST
75297: LIST
75298: PUSH
75299: LD_INT 34
75301: PUSH
75302: LD_INT 48
75304: PUSH
75305: EMPTY
75306: LIST
75307: LIST
75308: PUSH
75309: LD_INT 34
75311: PUSH
75312: LD_INT 8
75314: PUSH
75315: EMPTY
75316: LIST
75317: LIST
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: LIST
75323: LIST
75324: LIST
75325: LIST
75326: LIST
75327: LIST
75328: LIST
75329: LIST
75330: LIST
75331: LIST
75332: LIST
75333: PPUSH
75334: CALL_OW 72
75338: DIFF
75339: ST_TO_ADDR
// end ; end_of_file
75340: LD_VAR 0 3
75344: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
75345: LD_INT 0
75347: PPUSH
75348: PPUSH
75349: PPUSH
// if not mc_bases or not skirmish then
75350: LD_EXP 65
75354: NOT
75355: PUSH
75356: LD_EXP 63
75360: NOT
75361: OR
75362: IFFALSE 75366
// exit ;
75364: GO 75531
// for i = 1 to mc_bases do
75366: LD_ADDR_VAR 0 4
75370: PUSH
75371: DOUBLE
75372: LD_INT 1
75374: DEC
75375: ST_TO_ADDR
75376: LD_EXP 65
75380: PUSH
75381: FOR_TO
75382: IFFALSE 75529
// begin if sci in mc_bases [ i ] then
75384: LD_VAR 0 2
75388: PUSH
75389: LD_EXP 65
75393: PUSH
75394: LD_VAR 0 4
75398: ARRAY
75399: IN
75400: IFFALSE 75527
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
75402: LD_ADDR_EXP 94
75406: PUSH
75407: LD_EXP 94
75411: PPUSH
75412: LD_VAR 0 4
75416: PUSH
75417: LD_EXP 94
75421: PUSH
75422: LD_VAR 0 4
75426: ARRAY
75427: PUSH
75428: LD_INT 1
75430: PLUS
75431: PUSH
75432: EMPTY
75433: LIST
75434: LIST
75435: PPUSH
75436: LD_VAR 0 1
75440: PPUSH
75441: CALL 18504 0 3
75445: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
75446: LD_ADDR_VAR 0 5
75450: PUSH
75451: LD_EXP 65
75455: PUSH
75456: LD_VAR 0 4
75460: ARRAY
75461: PPUSH
75462: LD_INT 2
75464: PUSH
75465: LD_INT 30
75467: PUSH
75468: LD_INT 0
75470: PUSH
75471: EMPTY
75472: LIST
75473: LIST
75474: PUSH
75475: LD_INT 30
75477: PUSH
75478: LD_INT 1
75480: PUSH
75481: EMPTY
75482: LIST
75483: LIST
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: LIST
75489: PPUSH
75490: CALL_OW 72
75494: PPUSH
75495: LD_VAR 0 1
75499: PPUSH
75500: CALL_OW 74
75504: ST_TO_ADDR
// if tmp then
75505: LD_VAR 0 5
75509: IFFALSE 75525
// ComStandNearbyBuilding ( ape , tmp ) ;
75511: LD_VAR 0 1
75515: PPUSH
75516: LD_VAR 0 5
75520: PPUSH
75521: CALL 15118 0 2
// break ;
75525: GO 75529
// end ; end ;
75527: GO 75381
75529: POP
75530: POP
// end ;
75531: LD_VAR 0 3
75535: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
75536: LD_INT 0
75538: PPUSH
75539: PPUSH
75540: PPUSH
// if not mc_bases or not skirmish then
75541: LD_EXP 65
75545: NOT
75546: PUSH
75547: LD_EXP 63
75551: NOT
75552: OR
75553: IFFALSE 75557
// exit ;
75555: GO 75646
// for i = 1 to mc_bases do
75557: LD_ADDR_VAR 0 4
75561: PUSH
75562: DOUBLE
75563: LD_INT 1
75565: DEC
75566: ST_TO_ADDR
75567: LD_EXP 65
75571: PUSH
75572: FOR_TO
75573: IFFALSE 75644
// begin if building in mc_busy_turret_list [ i ] then
75575: LD_VAR 0 1
75579: PUSH
75580: LD_EXP 75
75584: PUSH
75585: LD_VAR 0 4
75589: ARRAY
75590: IN
75591: IFFALSE 75642
// begin tmp := mc_busy_turret_list [ i ] diff building ;
75593: LD_ADDR_VAR 0 5
75597: PUSH
75598: LD_EXP 75
75602: PUSH
75603: LD_VAR 0 4
75607: ARRAY
75608: PUSH
75609: LD_VAR 0 1
75613: DIFF
75614: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
75615: LD_ADDR_EXP 75
75619: PUSH
75620: LD_EXP 75
75624: PPUSH
75625: LD_VAR 0 4
75629: PPUSH
75630: LD_VAR 0 5
75634: PPUSH
75635: CALL_OW 1
75639: ST_TO_ADDR
// break ;
75640: GO 75644
// end ; end ;
75642: GO 75572
75644: POP
75645: POP
// end ;
75646: LD_VAR 0 3
75650: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
75651: LD_INT 0
75653: PPUSH
75654: PPUSH
75655: PPUSH
// if not mc_bases or not skirmish then
75656: LD_EXP 65
75660: NOT
75661: PUSH
75662: LD_EXP 63
75666: NOT
75667: OR
75668: IFFALSE 75672
// exit ;
75670: GO 75871
// for i = 1 to mc_bases do
75672: LD_ADDR_VAR 0 5
75676: PUSH
75677: DOUBLE
75678: LD_INT 1
75680: DEC
75681: ST_TO_ADDR
75682: LD_EXP 65
75686: PUSH
75687: FOR_TO
75688: IFFALSE 75869
// if building in mc_bases [ i ] then
75690: LD_VAR 0 1
75694: PUSH
75695: LD_EXP 65
75699: PUSH
75700: LD_VAR 0 5
75704: ARRAY
75705: IN
75706: IFFALSE 75867
// begin tmp := mc_bases [ i ] diff building ;
75708: LD_ADDR_VAR 0 6
75712: PUSH
75713: LD_EXP 65
75717: PUSH
75718: LD_VAR 0 5
75722: ARRAY
75723: PUSH
75724: LD_VAR 0 1
75728: DIFF
75729: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
75730: LD_ADDR_EXP 65
75734: PUSH
75735: LD_EXP 65
75739: PPUSH
75740: LD_VAR 0 5
75744: PPUSH
75745: LD_VAR 0 6
75749: PPUSH
75750: CALL_OW 1
75754: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
75755: LD_VAR 0 1
75759: PUSH
75760: LD_EXP 73
75764: PUSH
75765: LD_VAR 0 5
75769: ARRAY
75770: IN
75771: IFFALSE 75810
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
75773: LD_ADDR_EXP 73
75777: PUSH
75778: LD_EXP 73
75782: PPUSH
75783: LD_VAR 0 5
75787: PPUSH
75788: LD_EXP 73
75792: PUSH
75793: LD_VAR 0 5
75797: ARRAY
75798: PUSH
75799: LD_VAR 0 1
75803: DIFF
75804: PPUSH
75805: CALL_OW 1
75809: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
75810: LD_VAR 0 1
75814: PUSH
75815: LD_EXP 74
75819: PUSH
75820: LD_VAR 0 5
75824: ARRAY
75825: IN
75826: IFFALSE 75865
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
75828: LD_ADDR_EXP 74
75832: PUSH
75833: LD_EXP 74
75837: PPUSH
75838: LD_VAR 0 5
75842: PPUSH
75843: LD_EXP 74
75847: PUSH
75848: LD_VAR 0 5
75852: ARRAY
75853: PUSH
75854: LD_VAR 0 1
75858: DIFF
75859: PPUSH
75860: CALL_OW 1
75864: ST_TO_ADDR
// break ;
75865: GO 75869
// end ;
75867: GO 75687
75869: POP
75870: POP
// end ;
75871: LD_VAR 0 4
75875: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
75876: LD_INT 0
75878: PPUSH
75879: PPUSH
75880: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
75881: LD_EXP 65
75885: NOT
75886: PUSH
75887: LD_EXP 63
75891: NOT
75892: OR
75893: PUSH
75894: LD_VAR 0 3
75898: PUSH
75899: LD_EXP 91
75903: IN
75904: NOT
75905: OR
75906: IFFALSE 75910
// exit ;
75908: GO 76033
// for i = 1 to mc_vehicles do
75910: LD_ADDR_VAR 0 6
75914: PUSH
75915: DOUBLE
75916: LD_INT 1
75918: DEC
75919: ST_TO_ADDR
75920: LD_EXP 84
75924: PUSH
75925: FOR_TO
75926: IFFALSE 76031
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
75928: LD_VAR 0 2
75932: PUSH
75933: LD_EXP 84
75937: PUSH
75938: LD_VAR 0 6
75942: ARRAY
75943: IN
75944: PUSH
75945: LD_VAR 0 1
75949: PUSH
75950: LD_EXP 84
75954: PUSH
75955: LD_VAR 0 6
75959: ARRAY
75960: IN
75961: OR
75962: IFFALSE 76029
// begin tmp := mc_vehicles [ i ] diff old ;
75964: LD_ADDR_VAR 0 7
75968: PUSH
75969: LD_EXP 84
75973: PUSH
75974: LD_VAR 0 6
75978: ARRAY
75979: PUSH
75980: LD_VAR 0 2
75984: DIFF
75985: ST_TO_ADDR
// tmp := tmp diff new ;
75986: LD_ADDR_VAR 0 7
75990: PUSH
75991: LD_VAR 0 7
75995: PUSH
75996: LD_VAR 0 1
76000: DIFF
76001: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
76002: LD_ADDR_EXP 84
76006: PUSH
76007: LD_EXP 84
76011: PPUSH
76012: LD_VAR 0 6
76016: PPUSH
76017: LD_VAR 0 7
76021: PPUSH
76022: CALL_OW 1
76026: ST_TO_ADDR
// break ;
76027: GO 76031
// end ;
76029: GO 75925
76031: POP
76032: POP
// end ;
76033: LD_VAR 0 5
76037: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
76038: LD_INT 0
76040: PPUSH
76041: PPUSH
76042: PPUSH
76043: PPUSH
// if not mc_bases or not skirmish then
76044: LD_EXP 65
76048: NOT
76049: PUSH
76050: LD_EXP 63
76054: NOT
76055: OR
76056: IFFALSE 76060
// exit ;
76058: GO 76437
// side := GetSide ( vehicle ) ;
76060: LD_ADDR_VAR 0 5
76064: PUSH
76065: LD_VAR 0 1
76069: PPUSH
76070: CALL_OW 255
76074: ST_TO_ADDR
// for i = 1 to mc_bases do
76075: LD_ADDR_VAR 0 4
76079: PUSH
76080: DOUBLE
76081: LD_INT 1
76083: DEC
76084: ST_TO_ADDR
76085: LD_EXP 65
76089: PUSH
76090: FOR_TO
76091: IFFALSE 76435
// begin if factory in mc_bases [ i ] then
76093: LD_VAR 0 2
76097: PUSH
76098: LD_EXP 65
76102: PUSH
76103: LD_VAR 0 4
76107: ARRAY
76108: IN
76109: IFFALSE 76433
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
76111: LD_EXP 87
76115: PUSH
76116: LD_VAR 0 4
76120: ARRAY
76121: PUSH
76122: LD_EXP 76
76126: PUSH
76127: LD_VAR 0 4
76131: ARRAY
76132: LESS
76133: PUSH
76134: LD_VAR 0 1
76138: PPUSH
76139: CALL_OW 264
76143: PUSH
76144: LD_INT 31
76146: PUSH
76147: LD_INT 32
76149: PUSH
76150: LD_INT 51
76152: PUSH
76153: LD_EXP 49
76157: PUSH
76158: LD_INT 12
76160: PUSH
76161: LD_INT 30
76163: PUSH
76164: LD_EXP 48
76168: PUSH
76169: LD_INT 11
76171: PUSH
76172: LD_INT 53
76174: PUSH
76175: LD_INT 14
76177: PUSH
76178: LD_EXP 52
76182: PUSH
76183: LD_INT 29
76185: PUSH
76186: LD_EXP 50
76190: PUSH
76191: LD_INT 13
76193: PUSH
76194: LD_INT 52
76196: PUSH
76197: LD_INT 48
76199: PUSH
76200: LD_INT 8
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: LIST
76207: LIST
76208: LIST
76209: LIST
76210: LIST
76211: LIST
76212: LIST
76213: LIST
76214: LIST
76215: LIST
76216: LIST
76217: LIST
76218: LIST
76219: LIST
76220: LIST
76221: IN
76222: NOT
76223: AND
76224: IFFALSE 76272
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
76226: LD_ADDR_EXP 87
76230: PUSH
76231: LD_EXP 87
76235: PPUSH
76236: LD_VAR 0 4
76240: PUSH
76241: LD_EXP 87
76245: PUSH
76246: LD_VAR 0 4
76250: ARRAY
76251: PUSH
76252: LD_INT 1
76254: PLUS
76255: PUSH
76256: EMPTY
76257: LIST
76258: LIST
76259: PPUSH
76260: LD_VAR 0 1
76264: PPUSH
76265: CALL 18504 0 3
76269: ST_TO_ADDR
76270: GO 76316
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
76272: LD_ADDR_EXP 84
76276: PUSH
76277: LD_EXP 84
76281: PPUSH
76282: LD_VAR 0 4
76286: PUSH
76287: LD_EXP 84
76291: PUSH
76292: LD_VAR 0 4
76296: ARRAY
76297: PUSH
76298: LD_INT 1
76300: PLUS
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PPUSH
76306: LD_VAR 0 1
76310: PPUSH
76311: CALL 18504 0 3
76315: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
76316: LD_VAR 0 1
76320: PPUSH
76321: CALL_OW 263
76325: PUSH
76326: LD_INT 2
76328: EQUAL
76329: IFFALSE 76349
// begin repeat wait ( 0 0$1 ) ;
76331: LD_INT 35
76333: PPUSH
76334: CALL_OW 67
// until IsControledBy ( vehicle ) ;
76338: LD_VAR 0 1
76342: PPUSH
76343: CALL_OW 312
76347: IFFALSE 76331
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
76349: LD_VAR 0 1
76353: PPUSH
76354: LD_EXP 89
76358: PUSH
76359: LD_VAR 0 4
76363: ARRAY
76364: PPUSH
76365: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
76369: LD_VAR 0 1
76373: PPUSH
76374: CALL_OW 263
76378: PUSH
76379: LD_INT 1
76381: NONEQUAL
76382: IFFALSE 76386
// break ;
76384: GO 76435
// repeat wait ( 0 0$1 ) ;
76386: LD_INT 35
76388: PPUSH
76389: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
76393: LD_VAR 0 1
76397: PPUSH
76398: LD_EXP 89
76402: PUSH
76403: LD_VAR 0 4
76407: ARRAY
76408: PPUSH
76409: CALL_OW 308
76413: IFFALSE 76386
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
76415: LD_VAR 0 1
76419: PPUSH
76420: CALL_OW 311
76424: PPUSH
76425: CALL_OW 121
// exit ;
76429: POP
76430: POP
76431: GO 76437
// end ; end ;
76433: GO 76090
76435: POP
76436: POP
// end ;
76437: LD_VAR 0 3
76441: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
76442: LD_INT 0
76444: PPUSH
76445: PPUSH
76446: PPUSH
76447: PPUSH
// if not mc_bases or not skirmish then
76448: LD_EXP 65
76452: NOT
76453: PUSH
76454: LD_EXP 63
76458: NOT
76459: OR
76460: IFFALSE 76464
// exit ;
76462: GO 76817
// repeat wait ( 0 0$1 ) ;
76464: LD_INT 35
76466: PPUSH
76467: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
76471: LD_VAR 0 2
76475: PPUSH
76476: LD_VAR 0 3
76480: PPUSH
76481: CALL_OW 284
76485: IFFALSE 76464
// if GetResourceTypeXY ( x , y ) = mat_artefact then
76487: LD_VAR 0 2
76491: PPUSH
76492: LD_VAR 0 3
76496: PPUSH
76497: CALL_OW 283
76501: PUSH
76502: LD_INT 4
76504: EQUAL
76505: IFFALSE 76509
// exit ;
76507: GO 76817
// for i = 1 to mc_bases do
76509: LD_ADDR_VAR 0 7
76513: PUSH
76514: DOUBLE
76515: LD_INT 1
76517: DEC
76518: ST_TO_ADDR
76519: LD_EXP 65
76523: PUSH
76524: FOR_TO
76525: IFFALSE 76815
// begin if mc_crates_area [ i ] then
76527: LD_EXP 83
76531: PUSH
76532: LD_VAR 0 7
76536: ARRAY
76537: IFFALSE 76648
// for j in mc_crates_area [ i ] do
76539: LD_ADDR_VAR 0 8
76543: PUSH
76544: LD_EXP 83
76548: PUSH
76549: LD_VAR 0 7
76553: ARRAY
76554: PUSH
76555: FOR_IN
76556: IFFALSE 76646
// if InArea ( x , y , j ) then
76558: LD_VAR 0 2
76562: PPUSH
76563: LD_VAR 0 3
76567: PPUSH
76568: LD_VAR 0 8
76572: PPUSH
76573: CALL_OW 309
76577: IFFALSE 76644
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
76579: LD_ADDR_EXP 81
76583: PUSH
76584: LD_EXP 81
76588: PPUSH
76589: LD_VAR 0 7
76593: PUSH
76594: LD_EXP 81
76598: PUSH
76599: LD_VAR 0 7
76603: ARRAY
76604: PUSH
76605: LD_INT 1
76607: PLUS
76608: PUSH
76609: EMPTY
76610: LIST
76611: LIST
76612: PPUSH
76613: LD_VAR 0 4
76617: PUSH
76618: LD_VAR 0 2
76622: PUSH
76623: LD_VAR 0 3
76627: PUSH
76628: EMPTY
76629: LIST
76630: LIST
76631: LIST
76632: PPUSH
76633: CALL 18504 0 3
76637: ST_TO_ADDR
// exit ;
76638: POP
76639: POP
76640: POP
76641: POP
76642: GO 76817
// end ;
76644: GO 76555
76646: POP
76647: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76648: LD_ADDR_VAR 0 9
76652: PUSH
76653: LD_EXP 65
76657: PUSH
76658: LD_VAR 0 7
76662: ARRAY
76663: PPUSH
76664: LD_INT 2
76666: PUSH
76667: LD_INT 30
76669: PUSH
76670: LD_INT 0
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: PUSH
76677: LD_INT 30
76679: PUSH
76680: LD_INT 1
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: EMPTY
76688: LIST
76689: LIST
76690: LIST
76691: PPUSH
76692: CALL_OW 72
76696: ST_TO_ADDR
// if not depot then
76697: LD_VAR 0 9
76701: NOT
76702: IFFALSE 76706
// continue ;
76704: GO 76524
// for j in depot do
76706: LD_ADDR_VAR 0 8
76710: PUSH
76711: LD_VAR 0 9
76715: PUSH
76716: FOR_IN
76717: IFFALSE 76811
// if GetDistUnitXY ( j , x , y ) < 30 then
76719: LD_VAR 0 8
76723: PPUSH
76724: LD_VAR 0 2
76728: PPUSH
76729: LD_VAR 0 3
76733: PPUSH
76734: CALL_OW 297
76738: PUSH
76739: LD_INT 30
76741: LESS
76742: IFFALSE 76809
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
76744: LD_ADDR_EXP 81
76748: PUSH
76749: LD_EXP 81
76753: PPUSH
76754: LD_VAR 0 7
76758: PUSH
76759: LD_EXP 81
76763: PUSH
76764: LD_VAR 0 7
76768: ARRAY
76769: PUSH
76770: LD_INT 1
76772: PLUS
76773: PUSH
76774: EMPTY
76775: LIST
76776: LIST
76777: PPUSH
76778: LD_VAR 0 4
76782: PUSH
76783: LD_VAR 0 2
76787: PUSH
76788: LD_VAR 0 3
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: LIST
76797: PPUSH
76798: CALL 18504 0 3
76802: ST_TO_ADDR
// exit ;
76803: POP
76804: POP
76805: POP
76806: POP
76807: GO 76817
// end ;
76809: GO 76716
76811: POP
76812: POP
// end ;
76813: GO 76524
76815: POP
76816: POP
// end ;
76817: LD_VAR 0 6
76821: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
76822: LD_INT 0
76824: PPUSH
76825: PPUSH
76826: PPUSH
76827: PPUSH
// if not mc_bases or not skirmish then
76828: LD_EXP 65
76832: NOT
76833: PUSH
76834: LD_EXP 63
76838: NOT
76839: OR
76840: IFFALSE 76844
// exit ;
76842: GO 77121
// side := GetSide ( lab ) ;
76844: LD_ADDR_VAR 0 4
76848: PUSH
76849: LD_VAR 0 2
76853: PPUSH
76854: CALL_OW 255
76858: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
76859: LD_VAR 0 4
76863: PUSH
76864: LD_EXP 91
76868: IN
76869: NOT
76870: PUSH
76871: LD_EXP 92
76875: NOT
76876: OR
76877: PUSH
76878: LD_EXP 65
76882: NOT
76883: OR
76884: IFFALSE 76888
// exit ;
76886: GO 77121
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
76888: LD_ADDR_EXP 92
76892: PUSH
76893: LD_EXP 92
76897: PPUSH
76898: LD_VAR 0 4
76902: PPUSH
76903: LD_EXP 92
76907: PUSH
76908: LD_VAR 0 4
76912: ARRAY
76913: PUSH
76914: LD_VAR 0 1
76918: DIFF
76919: PPUSH
76920: CALL_OW 1
76924: ST_TO_ADDR
// for i = 1 to mc_bases do
76925: LD_ADDR_VAR 0 5
76929: PUSH
76930: DOUBLE
76931: LD_INT 1
76933: DEC
76934: ST_TO_ADDR
76935: LD_EXP 65
76939: PUSH
76940: FOR_TO
76941: IFFALSE 77119
// begin if lab in mc_bases [ i ] then
76943: LD_VAR 0 2
76947: PUSH
76948: LD_EXP 65
76952: PUSH
76953: LD_VAR 0 5
76957: ARRAY
76958: IN
76959: IFFALSE 77117
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
76961: LD_VAR 0 1
76965: PUSH
76966: LD_INT 11
76968: PUSH
76969: LD_INT 4
76971: PUSH
76972: LD_INT 3
76974: PUSH
76975: LD_INT 2
76977: PUSH
76978: EMPTY
76979: LIST
76980: LIST
76981: LIST
76982: LIST
76983: IN
76984: PUSH
76985: LD_EXP 95
76989: PUSH
76990: LD_VAR 0 5
76994: ARRAY
76995: AND
76996: IFFALSE 77117
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
76998: LD_ADDR_VAR 0 6
77002: PUSH
77003: LD_EXP 95
77007: PUSH
77008: LD_VAR 0 5
77012: ARRAY
77013: PUSH
77014: LD_INT 1
77016: ARRAY
77017: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77018: LD_ADDR_EXP 95
77022: PUSH
77023: LD_EXP 95
77027: PPUSH
77028: LD_VAR 0 5
77032: PPUSH
77033: EMPTY
77034: PPUSH
77035: CALL_OW 1
77039: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
77040: LD_VAR 0 6
77044: PPUSH
77045: LD_INT 0
77047: PPUSH
77048: CALL_OW 109
// ComExitBuilding ( tmp ) ;
77052: LD_VAR 0 6
77056: PPUSH
77057: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
77061: LD_ADDR_EXP 94
77065: PUSH
77066: LD_EXP 94
77070: PPUSH
77071: LD_VAR 0 5
77075: PPUSH
77076: LD_EXP 94
77080: PUSH
77081: LD_VAR 0 5
77085: ARRAY
77086: PPUSH
77087: LD_INT 1
77089: PPUSH
77090: LD_VAR 0 6
77094: PPUSH
77095: CALL_OW 2
77099: PPUSH
77100: CALL_OW 1
77104: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
77105: LD_VAR 0 5
77109: PPUSH
77110: LD_INT 112
77112: PPUSH
77113: CALL 54133 0 2
// end ; end ; end ;
77117: GO 76940
77119: POP
77120: POP
// end ;
77121: LD_VAR 0 3
77125: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
77126: LD_INT 0
77128: PPUSH
77129: PPUSH
77130: PPUSH
77131: PPUSH
77132: PPUSH
77133: PPUSH
77134: PPUSH
77135: PPUSH
// if not mc_bases or not skirmish then
77136: LD_EXP 65
77140: NOT
77141: PUSH
77142: LD_EXP 63
77146: NOT
77147: OR
77148: IFFALSE 77152
// exit ;
77150: GO 78523
// for i = 1 to mc_bases do
77152: LD_ADDR_VAR 0 3
77156: PUSH
77157: DOUBLE
77158: LD_INT 1
77160: DEC
77161: ST_TO_ADDR
77162: LD_EXP 65
77166: PUSH
77167: FOR_TO
77168: IFFALSE 78521
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
77170: LD_VAR 0 1
77174: PUSH
77175: LD_EXP 65
77179: PUSH
77180: LD_VAR 0 3
77184: ARRAY
77185: IN
77186: PUSH
77187: LD_VAR 0 1
77191: PUSH
77192: LD_EXP 72
77196: PUSH
77197: LD_VAR 0 3
77201: ARRAY
77202: IN
77203: OR
77204: PUSH
77205: LD_VAR 0 1
77209: PUSH
77210: LD_EXP 87
77214: PUSH
77215: LD_VAR 0 3
77219: ARRAY
77220: IN
77221: OR
77222: PUSH
77223: LD_VAR 0 1
77227: PUSH
77228: LD_EXP 84
77232: PUSH
77233: LD_VAR 0 3
77237: ARRAY
77238: IN
77239: OR
77240: PUSH
77241: LD_VAR 0 1
77245: PUSH
77246: LD_EXP 94
77250: PUSH
77251: LD_VAR 0 3
77255: ARRAY
77256: IN
77257: OR
77258: PUSH
77259: LD_VAR 0 1
77263: PUSH
77264: LD_EXP 95
77268: PUSH
77269: LD_VAR 0 3
77273: ARRAY
77274: IN
77275: OR
77276: IFFALSE 78519
// begin if un in mc_ape [ i ] then
77278: LD_VAR 0 1
77282: PUSH
77283: LD_EXP 94
77287: PUSH
77288: LD_VAR 0 3
77292: ARRAY
77293: IN
77294: IFFALSE 77333
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
77296: LD_ADDR_EXP 94
77300: PUSH
77301: LD_EXP 94
77305: PPUSH
77306: LD_VAR 0 3
77310: PPUSH
77311: LD_EXP 94
77315: PUSH
77316: LD_VAR 0 3
77320: ARRAY
77321: PUSH
77322: LD_VAR 0 1
77326: DIFF
77327: PPUSH
77328: CALL_OW 1
77332: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
77333: LD_VAR 0 1
77337: PUSH
77338: LD_EXP 95
77342: PUSH
77343: LD_VAR 0 3
77347: ARRAY
77348: IN
77349: IFFALSE 77373
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77351: LD_ADDR_EXP 95
77355: PUSH
77356: LD_EXP 95
77360: PPUSH
77361: LD_VAR 0 3
77365: PPUSH
77366: EMPTY
77367: PPUSH
77368: CALL_OW 1
77372: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
77373: LD_VAR 0 1
77377: PPUSH
77378: CALL_OW 247
77382: PUSH
77383: LD_INT 2
77385: EQUAL
77386: PUSH
77387: LD_VAR 0 1
77391: PPUSH
77392: CALL_OW 110
77396: PUSH
77397: LD_INT 20
77399: EQUAL
77400: PUSH
77401: LD_VAR 0 1
77405: PUSH
77406: LD_EXP 87
77410: PUSH
77411: LD_VAR 0 3
77415: ARRAY
77416: IN
77417: OR
77418: PUSH
77419: LD_VAR 0 1
77423: PPUSH
77424: CALL_OW 264
77428: PUSH
77429: LD_INT 12
77431: PUSH
77432: LD_INT 51
77434: PUSH
77435: LD_EXP 49
77439: PUSH
77440: LD_INT 32
77442: PUSH
77443: LD_INT 13
77445: PUSH
77446: LD_INT 52
77448: PUSH
77449: LD_INT 31
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: LIST
77456: LIST
77457: LIST
77458: LIST
77459: LIST
77460: IN
77461: OR
77462: AND
77463: IFFALSE 77771
// begin if un in mc_defender [ i ] then
77465: LD_VAR 0 1
77469: PUSH
77470: LD_EXP 87
77474: PUSH
77475: LD_VAR 0 3
77479: ARRAY
77480: IN
77481: IFFALSE 77520
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
77483: LD_ADDR_EXP 87
77487: PUSH
77488: LD_EXP 87
77492: PPUSH
77493: LD_VAR 0 3
77497: PPUSH
77498: LD_EXP 87
77502: PUSH
77503: LD_VAR 0 3
77507: ARRAY
77508: PUSH
77509: LD_VAR 0 1
77513: DIFF
77514: PPUSH
77515: CALL_OW 1
77519: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
77520: LD_ADDR_VAR 0 8
77524: PUSH
77525: LD_VAR 0 3
77529: PPUSH
77530: LD_INT 3
77532: PPUSH
77533: CALL 74189 0 2
77537: ST_TO_ADDR
// if fac then
77538: LD_VAR 0 8
77542: IFFALSE 77771
// begin for j in fac do
77544: LD_ADDR_VAR 0 4
77548: PUSH
77549: LD_VAR 0 8
77553: PUSH
77554: FOR_IN
77555: IFFALSE 77769
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
77557: LD_ADDR_VAR 0 9
77561: PUSH
77562: LD_VAR 0 8
77566: PPUSH
77567: LD_VAR 0 1
77571: PPUSH
77572: CALL_OW 265
77576: PPUSH
77577: LD_VAR 0 1
77581: PPUSH
77582: CALL_OW 262
77586: PPUSH
77587: LD_VAR 0 1
77591: PPUSH
77592: CALL_OW 263
77596: PPUSH
77597: LD_VAR 0 1
77601: PPUSH
77602: CALL_OW 264
77606: PPUSH
77607: CALL 16036 0 5
77611: ST_TO_ADDR
// if components then
77612: LD_VAR 0 9
77616: IFFALSE 77767
// begin if GetWeapon ( un ) = ar_control_tower then
77618: LD_VAR 0 1
77622: PPUSH
77623: CALL_OW 264
77627: PUSH
77628: LD_INT 31
77630: EQUAL
77631: IFFALSE 77748
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
77633: LD_VAR 0 1
77637: PPUSH
77638: CALL_OW 311
77642: PPUSH
77643: LD_INT 0
77645: PPUSH
77646: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
77650: LD_ADDR_EXP 105
77654: PUSH
77655: LD_EXP 105
77659: PPUSH
77660: LD_VAR 0 3
77664: PPUSH
77665: LD_EXP 105
77669: PUSH
77670: LD_VAR 0 3
77674: ARRAY
77675: PUSH
77676: LD_VAR 0 1
77680: PPUSH
77681: CALL_OW 311
77685: DIFF
77686: PPUSH
77687: CALL_OW 1
77691: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
77692: LD_ADDR_VAR 0 7
77696: PUSH
77697: LD_EXP 86
77701: PUSH
77702: LD_VAR 0 3
77706: ARRAY
77707: PPUSH
77708: LD_INT 1
77710: PPUSH
77711: LD_VAR 0 9
77715: PPUSH
77716: CALL_OW 2
77720: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
77721: LD_ADDR_EXP 86
77725: PUSH
77726: LD_EXP 86
77730: PPUSH
77731: LD_VAR 0 3
77735: PPUSH
77736: LD_VAR 0 7
77740: PPUSH
77741: CALL_OW 1
77745: ST_TO_ADDR
// end else
77746: GO 77765
// MC_InsertProduceList ( i , [ components ] ) ;
77748: LD_VAR 0 3
77752: PPUSH
77753: LD_VAR 0 9
77757: PUSH
77758: EMPTY
77759: LIST
77760: PPUSH
77761: CALL 73734 0 2
// break ;
77765: GO 77769
// end ; end ;
77767: GO 77554
77769: POP
77770: POP
// end ; end ; if GetType ( un ) = unit_building then
77771: LD_VAR 0 1
77775: PPUSH
77776: CALL_OW 247
77780: PUSH
77781: LD_INT 3
77783: EQUAL
77784: IFFALSE 78187
// begin btype := GetBType ( un ) ;
77786: LD_ADDR_VAR 0 5
77790: PUSH
77791: LD_VAR 0 1
77795: PPUSH
77796: CALL_OW 266
77800: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
77801: LD_VAR 0 5
77805: PUSH
77806: LD_INT 29
77808: PUSH
77809: LD_INT 30
77811: PUSH
77812: EMPTY
77813: LIST
77814: LIST
77815: IN
77816: IFFALSE 77889
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
77818: LD_VAR 0 1
77822: PPUSH
77823: CALL_OW 250
77827: PPUSH
77828: LD_VAR 0 1
77832: PPUSH
77833: CALL_OW 251
77837: PPUSH
77838: LD_VAR 0 1
77842: PPUSH
77843: CALL_OW 255
77847: PPUSH
77848: CALL_OW 440
77852: NOT
77853: IFFALSE 77889
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
77855: LD_VAR 0 1
77859: PPUSH
77860: CALL_OW 250
77864: PPUSH
77865: LD_VAR 0 1
77869: PPUSH
77870: CALL_OW 251
77874: PPUSH
77875: LD_VAR 0 1
77879: PPUSH
77880: CALL_OW 255
77884: PPUSH
77885: CALL_OW 441
// end ; if btype = b_warehouse then
77889: LD_VAR 0 5
77893: PUSH
77894: LD_INT 1
77896: EQUAL
77897: IFFALSE 77915
// begin btype := b_depot ;
77899: LD_ADDR_VAR 0 5
77903: PUSH
77904: LD_INT 0
77906: ST_TO_ADDR
// pos := 1 ;
77907: LD_ADDR_VAR 0 6
77911: PUSH
77912: LD_INT 1
77914: ST_TO_ADDR
// end ; if btype = b_factory then
77915: LD_VAR 0 5
77919: PUSH
77920: LD_INT 3
77922: EQUAL
77923: IFFALSE 77941
// begin btype := b_workshop ;
77925: LD_ADDR_VAR 0 5
77929: PUSH
77930: LD_INT 2
77932: ST_TO_ADDR
// pos := 1 ;
77933: LD_ADDR_VAR 0 6
77937: PUSH
77938: LD_INT 1
77940: ST_TO_ADDR
// end ; if btype = b_barracks then
77941: LD_VAR 0 5
77945: PUSH
77946: LD_INT 5
77948: EQUAL
77949: IFFALSE 77959
// btype := b_armoury ;
77951: LD_ADDR_VAR 0 5
77955: PUSH
77956: LD_INT 4
77958: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
77959: LD_VAR 0 5
77963: PUSH
77964: LD_INT 7
77966: PUSH
77967: LD_INT 8
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: IN
77974: IFFALSE 77984
// btype := b_lab ;
77976: LD_ADDR_VAR 0 5
77980: PUSH
77981: LD_INT 6
77983: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
77984: LD_ADDR_EXP 70
77988: PUSH
77989: LD_EXP 70
77993: PPUSH
77994: LD_VAR 0 3
77998: PUSH
77999: LD_EXP 70
78003: PUSH
78004: LD_VAR 0 3
78008: ARRAY
78009: PUSH
78010: LD_INT 1
78012: PLUS
78013: PUSH
78014: EMPTY
78015: LIST
78016: LIST
78017: PPUSH
78018: LD_VAR 0 5
78022: PUSH
78023: LD_VAR 0 1
78027: PPUSH
78028: CALL_OW 250
78032: PUSH
78033: LD_VAR 0 1
78037: PPUSH
78038: CALL_OW 251
78042: PUSH
78043: LD_VAR 0 1
78047: PPUSH
78048: CALL_OW 254
78052: PUSH
78053: EMPTY
78054: LIST
78055: LIST
78056: LIST
78057: LIST
78058: PPUSH
78059: CALL 18504 0 3
78063: ST_TO_ADDR
// if pos = 1 then
78064: LD_VAR 0 6
78068: PUSH
78069: LD_INT 1
78071: EQUAL
78072: IFFALSE 78187
// begin tmp := mc_build_list [ i ] ;
78074: LD_ADDR_VAR 0 7
78078: PUSH
78079: LD_EXP 70
78083: PUSH
78084: LD_VAR 0 3
78088: ARRAY
78089: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78090: LD_VAR 0 7
78094: PPUSH
78095: LD_INT 2
78097: PUSH
78098: LD_INT 30
78100: PUSH
78101: LD_INT 0
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: PUSH
78108: LD_INT 30
78110: PUSH
78111: LD_INT 1
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: LIST
78122: PPUSH
78123: CALL_OW 72
78127: IFFALSE 78137
// pos := 2 ;
78129: LD_ADDR_VAR 0 6
78133: PUSH
78134: LD_INT 2
78136: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
78137: LD_ADDR_VAR 0 7
78141: PUSH
78142: LD_VAR 0 7
78146: PPUSH
78147: LD_VAR 0 6
78151: PPUSH
78152: LD_VAR 0 7
78156: PPUSH
78157: CALL 18830 0 3
78161: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
78162: LD_ADDR_EXP 70
78166: PUSH
78167: LD_EXP 70
78171: PPUSH
78172: LD_VAR 0 3
78176: PPUSH
78177: LD_VAR 0 7
78181: PPUSH
78182: CALL_OW 1
78186: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
78187: LD_VAR 0 1
78191: PUSH
78192: LD_EXP 65
78196: PUSH
78197: LD_VAR 0 3
78201: ARRAY
78202: IN
78203: IFFALSE 78242
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
78205: LD_ADDR_EXP 65
78209: PUSH
78210: LD_EXP 65
78214: PPUSH
78215: LD_VAR 0 3
78219: PPUSH
78220: LD_EXP 65
78224: PUSH
78225: LD_VAR 0 3
78229: ARRAY
78230: PUSH
78231: LD_VAR 0 1
78235: DIFF
78236: PPUSH
78237: CALL_OW 1
78241: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
78242: LD_VAR 0 1
78246: PUSH
78247: LD_EXP 72
78251: PUSH
78252: LD_VAR 0 3
78256: ARRAY
78257: IN
78258: IFFALSE 78297
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
78260: LD_ADDR_EXP 72
78264: PUSH
78265: LD_EXP 72
78269: PPUSH
78270: LD_VAR 0 3
78274: PPUSH
78275: LD_EXP 72
78279: PUSH
78280: LD_VAR 0 3
78284: ARRAY
78285: PUSH
78286: LD_VAR 0 1
78290: DIFF
78291: PPUSH
78292: CALL_OW 1
78296: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
78297: LD_VAR 0 1
78301: PUSH
78302: LD_EXP 84
78306: PUSH
78307: LD_VAR 0 3
78311: ARRAY
78312: IN
78313: IFFALSE 78352
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
78315: LD_ADDR_EXP 84
78319: PUSH
78320: LD_EXP 84
78324: PPUSH
78325: LD_VAR 0 3
78329: PPUSH
78330: LD_EXP 84
78334: PUSH
78335: LD_VAR 0 3
78339: ARRAY
78340: PUSH
78341: LD_VAR 0 1
78345: DIFF
78346: PPUSH
78347: CALL_OW 1
78351: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
78352: LD_VAR 0 1
78356: PUSH
78357: LD_EXP 87
78361: PUSH
78362: LD_VAR 0 3
78366: ARRAY
78367: IN
78368: IFFALSE 78407
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78370: LD_ADDR_EXP 87
78374: PUSH
78375: LD_EXP 87
78379: PPUSH
78380: LD_VAR 0 3
78384: PPUSH
78385: LD_EXP 87
78389: PUSH
78390: LD_VAR 0 3
78394: ARRAY
78395: PUSH
78396: LD_VAR 0 1
78400: DIFF
78401: PPUSH
78402: CALL_OW 1
78406: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
78407: LD_VAR 0 1
78411: PUSH
78412: LD_EXP 74
78416: PUSH
78417: LD_VAR 0 3
78421: ARRAY
78422: IN
78423: IFFALSE 78462
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
78425: LD_ADDR_EXP 74
78429: PUSH
78430: LD_EXP 74
78434: PPUSH
78435: LD_VAR 0 3
78439: PPUSH
78440: LD_EXP 74
78444: PUSH
78445: LD_VAR 0 3
78449: ARRAY
78450: PUSH
78451: LD_VAR 0 1
78455: DIFF
78456: PPUSH
78457: CALL_OW 1
78461: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
78462: LD_VAR 0 1
78466: PUSH
78467: LD_EXP 73
78471: PUSH
78472: LD_VAR 0 3
78476: ARRAY
78477: IN
78478: IFFALSE 78517
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
78480: LD_ADDR_EXP 73
78484: PUSH
78485: LD_EXP 73
78489: PPUSH
78490: LD_VAR 0 3
78494: PPUSH
78495: LD_EXP 73
78499: PUSH
78500: LD_VAR 0 3
78504: ARRAY
78505: PUSH
78506: LD_VAR 0 1
78510: DIFF
78511: PPUSH
78512: CALL_OW 1
78516: ST_TO_ADDR
// end ; break ;
78517: GO 78521
// end ;
78519: GO 77167
78521: POP
78522: POP
// end ;
78523: LD_VAR 0 2
78527: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
78528: LD_INT 0
78530: PPUSH
78531: PPUSH
78532: PPUSH
// if not mc_bases or not skirmish then
78533: LD_EXP 65
78537: NOT
78538: PUSH
78539: LD_EXP 63
78543: NOT
78544: OR
78545: IFFALSE 78549
// exit ;
78547: GO 78764
// for i = 1 to mc_bases do
78549: LD_ADDR_VAR 0 3
78553: PUSH
78554: DOUBLE
78555: LD_INT 1
78557: DEC
78558: ST_TO_ADDR
78559: LD_EXP 65
78563: PUSH
78564: FOR_TO
78565: IFFALSE 78762
// begin if building in mc_construct_list [ i ] then
78567: LD_VAR 0 1
78571: PUSH
78572: LD_EXP 72
78576: PUSH
78577: LD_VAR 0 3
78581: ARRAY
78582: IN
78583: IFFALSE 78760
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
78585: LD_ADDR_EXP 72
78589: PUSH
78590: LD_EXP 72
78594: PPUSH
78595: LD_VAR 0 3
78599: PPUSH
78600: LD_EXP 72
78604: PUSH
78605: LD_VAR 0 3
78609: ARRAY
78610: PUSH
78611: LD_VAR 0 1
78615: DIFF
78616: PPUSH
78617: CALL_OW 1
78621: ST_TO_ADDR
// if building in mc_lab [ i ] then
78622: LD_VAR 0 1
78626: PUSH
78627: LD_EXP 98
78631: PUSH
78632: LD_VAR 0 3
78636: ARRAY
78637: IN
78638: IFFALSE 78693
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
78640: LD_ADDR_EXP 99
78644: PUSH
78645: LD_EXP 99
78649: PPUSH
78650: LD_VAR 0 3
78654: PPUSH
78655: LD_EXP 99
78659: PUSH
78660: LD_VAR 0 3
78664: ARRAY
78665: PPUSH
78666: LD_INT 1
78668: PPUSH
78669: LD_EXP 99
78673: PUSH
78674: LD_VAR 0 3
78678: ARRAY
78679: PPUSH
78680: LD_INT 0
78682: PPUSH
78683: CALL 17922 0 4
78687: PPUSH
78688: CALL_OW 1
78692: ST_TO_ADDR
// if not building in mc_bases [ i ] then
78693: LD_VAR 0 1
78697: PUSH
78698: LD_EXP 65
78702: PUSH
78703: LD_VAR 0 3
78707: ARRAY
78708: IN
78709: NOT
78710: IFFALSE 78756
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
78712: LD_ADDR_EXP 65
78716: PUSH
78717: LD_EXP 65
78721: PPUSH
78722: LD_VAR 0 3
78726: PUSH
78727: LD_EXP 65
78731: PUSH
78732: LD_VAR 0 3
78736: ARRAY
78737: PUSH
78738: LD_INT 1
78740: PLUS
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: PPUSH
78746: LD_VAR 0 1
78750: PPUSH
78751: CALL 18504 0 3
78755: ST_TO_ADDR
// exit ;
78756: POP
78757: POP
78758: GO 78764
// end ; end ;
78760: GO 78564
78762: POP
78763: POP
// end ;
78764: LD_VAR 0 2
78768: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
78769: LD_INT 0
78771: PPUSH
78772: PPUSH
78773: PPUSH
78774: PPUSH
78775: PPUSH
78776: PPUSH
78777: PPUSH
// if not mc_bases or not skirmish then
78778: LD_EXP 65
78782: NOT
78783: PUSH
78784: LD_EXP 63
78788: NOT
78789: OR
78790: IFFALSE 78794
// exit ;
78792: GO 79455
// for i = 1 to mc_bases do
78794: LD_ADDR_VAR 0 3
78798: PUSH
78799: DOUBLE
78800: LD_INT 1
78802: DEC
78803: ST_TO_ADDR
78804: LD_EXP 65
78808: PUSH
78809: FOR_TO
78810: IFFALSE 79453
// begin if building in mc_construct_list [ i ] then
78812: LD_VAR 0 1
78816: PUSH
78817: LD_EXP 72
78821: PUSH
78822: LD_VAR 0 3
78826: ARRAY
78827: IN
78828: IFFALSE 79451
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
78830: LD_ADDR_EXP 72
78834: PUSH
78835: LD_EXP 72
78839: PPUSH
78840: LD_VAR 0 3
78844: PPUSH
78845: LD_EXP 72
78849: PUSH
78850: LD_VAR 0 3
78854: ARRAY
78855: PUSH
78856: LD_VAR 0 1
78860: DIFF
78861: PPUSH
78862: CALL_OW 1
78866: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
78867: LD_ADDR_EXP 65
78871: PUSH
78872: LD_EXP 65
78876: PPUSH
78877: LD_VAR 0 3
78881: PUSH
78882: LD_EXP 65
78886: PUSH
78887: LD_VAR 0 3
78891: ARRAY
78892: PUSH
78893: LD_INT 1
78895: PLUS
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: PPUSH
78901: LD_VAR 0 1
78905: PPUSH
78906: CALL 18504 0 3
78910: ST_TO_ADDR
// btype := GetBType ( building ) ;
78911: LD_ADDR_VAR 0 5
78915: PUSH
78916: LD_VAR 0 1
78920: PPUSH
78921: CALL_OW 266
78925: ST_TO_ADDR
// side := GetSide ( building ) ;
78926: LD_ADDR_VAR 0 8
78930: PUSH
78931: LD_VAR 0 1
78935: PPUSH
78936: CALL_OW 255
78940: ST_TO_ADDR
// if btype = b_lab then
78941: LD_VAR 0 5
78945: PUSH
78946: LD_INT 6
78948: EQUAL
78949: IFFALSE 78999
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
78951: LD_ADDR_EXP 98
78955: PUSH
78956: LD_EXP 98
78960: PPUSH
78961: LD_VAR 0 3
78965: PUSH
78966: LD_EXP 98
78970: PUSH
78971: LD_VAR 0 3
78975: ARRAY
78976: PUSH
78977: LD_INT 1
78979: PLUS
78980: PUSH
78981: EMPTY
78982: LIST
78983: LIST
78984: PPUSH
78985: LD_VAR 0 1
78989: PPUSH
78990: CALL 18504 0 3
78994: ST_TO_ADDR
// exit ;
78995: POP
78996: POP
78997: GO 79455
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
78999: LD_VAR 0 5
79003: PUSH
79004: LD_INT 0
79006: PUSH
79007: LD_INT 2
79009: PUSH
79010: LD_INT 4
79012: PUSH
79013: EMPTY
79014: LIST
79015: LIST
79016: LIST
79017: IN
79018: IFFALSE 79142
// begin if btype = b_armoury then
79020: LD_VAR 0 5
79024: PUSH
79025: LD_INT 4
79027: EQUAL
79028: IFFALSE 79038
// btype := b_barracks ;
79030: LD_ADDR_VAR 0 5
79034: PUSH
79035: LD_INT 5
79037: ST_TO_ADDR
// if btype = b_depot then
79038: LD_VAR 0 5
79042: PUSH
79043: LD_INT 0
79045: EQUAL
79046: IFFALSE 79056
// btype := b_warehouse ;
79048: LD_ADDR_VAR 0 5
79052: PUSH
79053: LD_INT 1
79055: ST_TO_ADDR
// if btype = b_workshop then
79056: LD_VAR 0 5
79060: PUSH
79061: LD_INT 2
79063: EQUAL
79064: IFFALSE 79074
// btype := b_factory ;
79066: LD_ADDR_VAR 0 5
79070: PUSH
79071: LD_INT 3
79073: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
79074: LD_VAR 0 5
79078: PPUSH
79079: LD_VAR 0 8
79083: PPUSH
79084: CALL_OW 323
79088: PUSH
79089: LD_INT 1
79091: EQUAL
79092: IFFALSE 79138
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
79094: LD_ADDR_EXP 97
79098: PUSH
79099: LD_EXP 97
79103: PPUSH
79104: LD_VAR 0 3
79108: PUSH
79109: LD_EXP 97
79113: PUSH
79114: LD_VAR 0 3
79118: ARRAY
79119: PUSH
79120: LD_INT 1
79122: PLUS
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: PPUSH
79128: LD_VAR 0 1
79132: PPUSH
79133: CALL 18504 0 3
79137: ST_TO_ADDR
// exit ;
79138: POP
79139: POP
79140: GO 79455
// end ; if btype in [ b_bunker , b_turret ] then
79142: LD_VAR 0 5
79146: PUSH
79147: LD_INT 32
79149: PUSH
79150: LD_INT 33
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: IN
79157: IFFALSE 79447
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
79159: LD_ADDR_EXP 73
79163: PUSH
79164: LD_EXP 73
79168: PPUSH
79169: LD_VAR 0 3
79173: PUSH
79174: LD_EXP 73
79178: PUSH
79179: LD_VAR 0 3
79183: ARRAY
79184: PUSH
79185: LD_INT 1
79187: PLUS
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PPUSH
79193: LD_VAR 0 1
79197: PPUSH
79198: CALL 18504 0 3
79202: ST_TO_ADDR
// if btype = b_bunker then
79203: LD_VAR 0 5
79207: PUSH
79208: LD_INT 32
79210: EQUAL
79211: IFFALSE 79447
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
79213: LD_ADDR_EXP 74
79217: PUSH
79218: LD_EXP 74
79222: PPUSH
79223: LD_VAR 0 3
79227: PUSH
79228: LD_EXP 74
79232: PUSH
79233: LD_VAR 0 3
79237: ARRAY
79238: PUSH
79239: LD_INT 1
79241: PLUS
79242: PUSH
79243: EMPTY
79244: LIST
79245: LIST
79246: PPUSH
79247: LD_VAR 0 1
79251: PPUSH
79252: CALL 18504 0 3
79256: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
79257: LD_ADDR_VAR 0 6
79261: PUSH
79262: LD_EXP 65
79266: PUSH
79267: LD_VAR 0 3
79271: ARRAY
79272: PPUSH
79273: LD_INT 25
79275: PUSH
79276: LD_INT 1
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: LD_INT 3
79285: PUSH
79286: LD_INT 54
79288: PUSH
79289: EMPTY
79290: LIST
79291: PUSH
79292: EMPTY
79293: LIST
79294: LIST
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PPUSH
79300: CALL_OW 72
79304: ST_TO_ADDR
// if tmp then
79305: LD_VAR 0 6
79309: IFFALSE 79315
// exit ;
79311: POP
79312: POP
79313: GO 79455
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
79315: LD_ADDR_VAR 0 6
79319: PUSH
79320: LD_EXP 65
79324: PUSH
79325: LD_VAR 0 3
79329: ARRAY
79330: PPUSH
79331: LD_INT 2
79333: PUSH
79334: LD_INT 30
79336: PUSH
79337: LD_INT 4
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: PUSH
79344: LD_INT 30
79346: PUSH
79347: LD_INT 5
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: PUSH
79354: EMPTY
79355: LIST
79356: LIST
79357: LIST
79358: PPUSH
79359: CALL_OW 72
79363: ST_TO_ADDR
// if not tmp then
79364: LD_VAR 0 6
79368: NOT
79369: IFFALSE 79375
// exit ;
79371: POP
79372: POP
79373: GO 79455
// for j in tmp do
79375: LD_ADDR_VAR 0 4
79379: PUSH
79380: LD_VAR 0 6
79384: PUSH
79385: FOR_IN
79386: IFFALSE 79445
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
79388: LD_ADDR_VAR 0 7
79392: PUSH
79393: LD_VAR 0 4
79397: PPUSH
79398: CALL_OW 313
79402: PPUSH
79403: LD_INT 25
79405: PUSH
79406: LD_INT 1
79408: PUSH
79409: EMPTY
79410: LIST
79411: LIST
79412: PPUSH
79413: CALL_OW 72
79417: ST_TO_ADDR
// if units then
79418: LD_VAR 0 7
79422: IFFALSE 79443
// begin ComExitBuilding ( units [ 1 ] ) ;
79424: LD_VAR 0 7
79428: PUSH
79429: LD_INT 1
79431: ARRAY
79432: PPUSH
79433: CALL_OW 122
// exit ;
79437: POP
79438: POP
79439: POP
79440: POP
79441: GO 79455
// end ; end ;
79443: GO 79385
79445: POP
79446: POP
// end ; end ; exit ;
79447: POP
79448: POP
79449: GO 79455
// end ; end ;
79451: GO 78809
79453: POP
79454: POP
// end ;
79455: LD_VAR 0 2
79459: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
79460: LD_INT 0
79462: PPUSH
79463: PPUSH
79464: PPUSH
79465: PPUSH
79466: PPUSH
79467: PPUSH
79468: PPUSH
// if not mc_bases or not skirmish then
79469: LD_EXP 65
79473: NOT
79474: PUSH
79475: LD_EXP 63
79479: NOT
79480: OR
79481: IFFALSE 79485
// exit ;
79483: GO 79716
// btype := GetBType ( building ) ;
79485: LD_ADDR_VAR 0 6
79489: PUSH
79490: LD_VAR 0 1
79494: PPUSH
79495: CALL_OW 266
79499: ST_TO_ADDR
// x := GetX ( building ) ;
79500: LD_ADDR_VAR 0 7
79504: PUSH
79505: LD_VAR 0 1
79509: PPUSH
79510: CALL_OW 250
79514: ST_TO_ADDR
// y := GetY ( building ) ;
79515: LD_ADDR_VAR 0 8
79519: PUSH
79520: LD_VAR 0 1
79524: PPUSH
79525: CALL_OW 251
79529: ST_TO_ADDR
// d := GetDir ( building ) ;
79530: LD_ADDR_VAR 0 9
79534: PUSH
79535: LD_VAR 0 1
79539: PPUSH
79540: CALL_OW 254
79544: ST_TO_ADDR
// for i = 1 to mc_bases do
79545: LD_ADDR_VAR 0 4
79549: PUSH
79550: DOUBLE
79551: LD_INT 1
79553: DEC
79554: ST_TO_ADDR
79555: LD_EXP 65
79559: PUSH
79560: FOR_TO
79561: IFFALSE 79714
// begin if not mc_build_list [ i ] then
79563: LD_EXP 70
79567: PUSH
79568: LD_VAR 0 4
79572: ARRAY
79573: NOT
79574: IFFALSE 79578
// continue ;
79576: GO 79560
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
79578: LD_VAR 0 6
79582: PUSH
79583: LD_VAR 0 7
79587: PUSH
79588: LD_VAR 0 8
79592: PUSH
79593: LD_VAR 0 9
79597: PUSH
79598: EMPTY
79599: LIST
79600: LIST
79601: LIST
79602: LIST
79603: PPUSH
79604: LD_EXP 70
79608: PUSH
79609: LD_VAR 0 4
79613: ARRAY
79614: PUSH
79615: LD_INT 1
79617: ARRAY
79618: PPUSH
79619: CALL 24673 0 2
79623: IFFALSE 79712
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
79625: LD_ADDR_EXP 70
79629: PUSH
79630: LD_EXP 70
79634: PPUSH
79635: LD_VAR 0 4
79639: PPUSH
79640: LD_EXP 70
79644: PUSH
79645: LD_VAR 0 4
79649: ARRAY
79650: PPUSH
79651: LD_INT 1
79653: PPUSH
79654: CALL_OW 3
79658: PPUSH
79659: CALL_OW 1
79663: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
79664: LD_ADDR_EXP 72
79668: PUSH
79669: LD_EXP 72
79673: PPUSH
79674: LD_VAR 0 4
79678: PUSH
79679: LD_EXP 72
79683: PUSH
79684: LD_VAR 0 4
79688: ARRAY
79689: PUSH
79690: LD_INT 1
79692: PLUS
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PPUSH
79698: LD_VAR 0 1
79702: PPUSH
79703: CALL 18504 0 3
79707: ST_TO_ADDR
// exit ;
79708: POP
79709: POP
79710: GO 79716
// end ; end ;
79712: GO 79560
79714: POP
79715: POP
// end ;
79716: LD_VAR 0 3
79720: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
79721: LD_INT 0
79723: PPUSH
79724: PPUSH
79725: PPUSH
// if not mc_bases or not skirmish then
79726: LD_EXP 65
79730: NOT
79731: PUSH
79732: LD_EXP 63
79736: NOT
79737: OR
79738: IFFALSE 79742
// exit ;
79740: GO 79932
// for i = 1 to mc_bases do
79742: LD_ADDR_VAR 0 4
79746: PUSH
79747: DOUBLE
79748: LD_INT 1
79750: DEC
79751: ST_TO_ADDR
79752: LD_EXP 65
79756: PUSH
79757: FOR_TO
79758: IFFALSE 79845
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
79760: LD_VAR 0 1
79764: PUSH
79765: LD_EXP 73
79769: PUSH
79770: LD_VAR 0 4
79774: ARRAY
79775: IN
79776: PUSH
79777: LD_VAR 0 1
79781: PUSH
79782: LD_EXP 74
79786: PUSH
79787: LD_VAR 0 4
79791: ARRAY
79792: IN
79793: NOT
79794: AND
79795: IFFALSE 79843
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
79797: LD_ADDR_EXP 74
79801: PUSH
79802: LD_EXP 74
79806: PPUSH
79807: LD_VAR 0 4
79811: PUSH
79812: LD_EXP 74
79816: PUSH
79817: LD_VAR 0 4
79821: ARRAY
79822: PUSH
79823: LD_INT 1
79825: PLUS
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: PPUSH
79831: LD_VAR 0 1
79835: PPUSH
79836: CALL 18504 0 3
79840: ST_TO_ADDR
// break ;
79841: GO 79845
// end ; end ;
79843: GO 79757
79845: POP
79846: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
79847: LD_VAR 0 1
79851: PPUSH
79852: CALL_OW 257
79856: PUSH
79857: LD_EXP 91
79861: IN
79862: PUSH
79863: LD_VAR 0 1
79867: PPUSH
79868: CALL_OW 266
79872: PUSH
79873: LD_INT 5
79875: EQUAL
79876: AND
79877: PUSH
79878: LD_VAR 0 2
79882: PPUSH
79883: CALL_OW 110
79887: PUSH
79888: LD_INT 18
79890: NONEQUAL
79891: AND
79892: IFFALSE 79932
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
79894: LD_VAR 0 2
79898: PPUSH
79899: CALL_OW 257
79903: PUSH
79904: LD_INT 5
79906: PUSH
79907: LD_INT 8
79909: PUSH
79910: LD_INT 9
79912: PUSH
79913: EMPTY
79914: LIST
79915: LIST
79916: LIST
79917: IN
79918: IFFALSE 79932
// SetClass ( unit , 1 ) ;
79920: LD_VAR 0 2
79924: PPUSH
79925: LD_INT 1
79927: PPUSH
79928: CALL_OW 336
// end ;
79932: LD_VAR 0 3
79936: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
79937: LD_INT 0
79939: PPUSH
79940: PPUSH
// if not mc_bases or not skirmish then
79941: LD_EXP 65
79945: NOT
79946: PUSH
79947: LD_EXP 63
79951: NOT
79952: OR
79953: IFFALSE 79957
// exit ;
79955: GO 80073
// if GetLives ( abandoned_vehicle ) > 250 then
79957: LD_VAR 0 2
79961: PPUSH
79962: CALL_OW 256
79966: PUSH
79967: LD_INT 250
79969: GREATER
79970: IFFALSE 79974
// exit ;
79972: GO 80073
// for i = 1 to mc_bases do
79974: LD_ADDR_VAR 0 6
79978: PUSH
79979: DOUBLE
79980: LD_INT 1
79982: DEC
79983: ST_TO_ADDR
79984: LD_EXP 65
79988: PUSH
79989: FOR_TO
79990: IFFALSE 80071
// begin if driver in mc_bases [ i ] then
79992: LD_VAR 0 1
79996: PUSH
79997: LD_EXP 65
80001: PUSH
80002: LD_VAR 0 6
80006: ARRAY
80007: IN
80008: IFFALSE 80069
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
80010: LD_VAR 0 1
80014: PPUSH
80015: LD_EXP 65
80019: PUSH
80020: LD_VAR 0 6
80024: ARRAY
80025: PPUSH
80026: LD_INT 2
80028: PUSH
80029: LD_INT 30
80031: PUSH
80032: LD_INT 0
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: PUSH
80039: LD_INT 30
80041: PUSH
80042: LD_INT 1
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: LIST
80053: PPUSH
80054: CALL_OW 72
80058: PUSH
80059: LD_INT 1
80061: ARRAY
80062: PPUSH
80063: CALL_OW 112
// break ;
80067: GO 80071
// end ; end ;
80069: GO 79989
80071: POP
80072: POP
// end ; end_of_file end_of_file
80073: LD_VAR 0 5
80077: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
80078: LD_VAR 0 2
80082: PUSH
80083: LD_INT 100
80085: EQUAL
80086: IFFALSE 81035
// begin if not StreamModeActive then
80088: LD_EXP 108
80092: NOT
80093: IFFALSE 80103
// StreamModeActive := true ;
80095: LD_ADDR_EXP 108
80099: PUSH
80100: LD_INT 1
80102: ST_TO_ADDR
// if p3 = 0 then
80103: LD_VAR 0 3
80107: PUSH
80108: LD_INT 0
80110: EQUAL
80111: IFFALSE 80117
// InitStreamMode ;
80113: CALL 81193 0 0
// if p3 = 1 then
80117: LD_VAR 0 3
80121: PUSH
80122: LD_INT 1
80124: EQUAL
80125: IFFALSE 80135
// sRocket := true ;
80127: LD_ADDR_EXP 113
80131: PUSH
80132: LD_INT 1
80134: ST_TO_ADDR
// if p3 = 2 then
80135: LD_VAR 0 3
80139: PUSH
80140: LD_INT 2
80142: EQUAL
80143: IFFALSE 80153
// sSpeed := true ;
80145: LD_ADDR_EXP 112
80149: PUSH
80150: LD_INT 1
80152: ST_TO_ADDR
// if p3 = 3 then
80153: LD_VAR 0 3
80157: PUSH
80158: LD_INT 3
80160: EQUAL
80161: IFFALSE 80171
// sEngine := true ;
80163: LD_ADDR_EXP 114
80167: PUSH
80168: LD_INT 1
80170: ST_TO_ADDR
// if p3 = 4 then
80171: LD_VAR 0 3
80175: PUSH
80176: LD_INT 4
80178: EQUAL
80179: IFFALSE 80189
// sSpec := true ;
80181: LD_ADDR_EXP 111
80185: PUSH
80186: LD_INT 1
80188: ST_TO_ADDR
// if p3 = 5 then
80189: LD_VAR 0 3
80193: PUSH
80194: LD_INT 5
80196: EQUAL
80197: IFFALSE 80207
// sLevel := true ;
80199: LD_ADDR_EXP 115
80203: PUSH
80204: LD_INT 1
80206: ST_TO_ADDR
// if p3 = 6 then
80207: LD_VAR 0 3
80211: PUSH
80212: LD_INT 6
80214: EQUAL
80215: IFFALSE 80225
// sArmoury := true ;
80217: LD_ADDR_EXP 116
80221: PUSH
80222: LD_INT 1
80224: ST_TO_ADDR
// if p3 = 7 then
80225: LD_VAR 0 3
80229: PUSH
80230: LD_INT 7
80232: EQUAL
80233: IFFALSE 80243
// sRadar := true ;
80235: LD_ADDR_EXP 117
80239: PUSH
80240: LD_INT 1
80242: ST_TO_ADDR
// if p3 = 8 then
80243: LD_VAR 0 3
80247: PUSH
80248: LD_INT 8
80250: EQUAL
80251: IFFALSE 80261
// sBunker := true ;
80253: LD_ADDR_EXP 118
80257: PUSH
80258: LD_INT 1
80260: ST_TO_ADDR
// if p3 = 9 then
80261: LD_VAR 0 3
80265: PUSH
80266: LD_INT 9
80268: EQUAL
80269: IFFALSE 80279
// sHack := true ;
80271: LD_ADDR_EXP 119
80275: PUSH
80276: LD_INT 1
80278: ST_TO_ADDR
// if p3 = 10 then
80279: LD_VAR 0 3
80283: PUSH
80284: LD_INT 10
80286: EQUAL
80287: IFFALSE 80297
// sFire := true ;
80289: LD_ADDR_EXP 120
80293: PUSH
80294: LD_INT 1
80296: ST_TO_ADDR
// if p3 = 11 then
80297: LD_VAR 0 3
80301: PUSH
80302: LD_INT 11
80304: EQUAL
80305: IFFALSE 80315
// sRefresh := true ;
80307: LD_ADDR_EXP 121
80311: PUSH
80312: LD_INT 1
80314: ST_TO_ADDR
// if p3 = 12 then
80315: LD_VAR 0 3
80319: PUSH
80320: LD_INT 12
80322: EQUAL
80323: IFFALSE 80333
// sExp := true ;
80325: LD_ADDR_EXP 122
80329: PUSH
80330: LD_INT 1
80332: ST_TO_ADDR
// if p3 = 13 then
80333: LD_VAR 0 3
80337: PUSH
80338: LD_INT 13
80340: EQUAL
80341: IFFALSE 80351
// sDepot := true ;
80343: LD_ADDR_EXP 123
80347: PUSH
80348: LD_INT 1
80350: ST_TO_ADDR
// if p3 = 14 then
80351: LD_VAR 0 3
80355: PUSH
80356: LD_INT 14
80358: EQUAL
80359: IFFALSE 80369
// sFlag := true ;
80361: LD_ADDR_EXP 124
80365: PUSH
80366: LD_INT 1
80368: ST_TO_ADDR
// if p3 = 15 then
80369: LD_VAR 0 3
80373: PUSH
80374: LD_INT 15
80376: EQUAL
80377: IFFALSE 80387
// sKamikadze := true ;
80379: LD_ADDR_EXP 132
80383: PUSH
80384: LD_INT 1
80386: ST_TO_ADDR
// if p3 = 16 then
80387: LD_VAR 0 3
80391: PUSH
80392: LD_INT 16
80394: EQUAL
80395: IFFALSE 80405
// sTroll := true ;
80397: LD_ADDR_EXP 133
80401: PUSH
80402: LD_INT 1
80404: ST_TO_ADDR
// if p3 = 17 then
80405: LD_VAR 0 3
80409: PUSH
80410: LD_INT 17
80412: EQUAL
80413: IFFALSE 80423
// sSlow := true ;
80415: LD_ADDR_EXP 134
80419: PUSH
80420: LD_INT 1
80422: ST_TO_ADDR
// if p3 = 18 then
80423: LD_VAR 0 3
80427: PUSH
80428: LD_INT 18
80430: EQUAL
80431: IFFALSE 80441
// sLack := true ;
80433: LD_ADDR_EXP 135
80437: PUSH
80438: LD_INT 1
80440: ST_TO_ADDR
// if p3 = 19 then
80441: LD_VAR 0 3
80445: PUSH
80446: LD_INT 19
80448: EQUAL
80449: IFFALSE 80459
// sTank := true ;
80451: LD_ADDR_EXP 137
80455: PUSH
80456: LD_INT 1
80458: ST_TO_ADDR
// if p3 = 20 then
80459: LD_VAR 0 3
80463: PUSH
80464: LD_INT 20
80466: EQUAL
80467: IFFALSE 80477
// sRemote := true ;
80469: LD_ADDR_EXP 138
80473: PUSH
80474: LD_INT 1
80476: ST_TO_ADDR
// if p3 = 21 then
80477: LD_VAR 0 3
80481: PUSH
80482: LD_INT 21
80484: EQUAL
80485: IFFALSE 80495
// sPowell := true ;
80487: LD_ADDR_EXP 139
80491: PUSH
80492: LD_INT 1
80494: ST_TO_ADDR
// if p3 = 22 then
80495: LD_VAR 0 3
80499: PUSH
80500: LD_INT 22
80502: EQUAL
80503: IFFALSE 80513
// sTeleport := true ;
80505: LD_ADDR_EXP 142
80509: PUSH
80510: LD_INT 1
80512: ST_TO_ADDR
// if p3 = 23 then
80513: LD_VAR 0 3
80517: PUSH
80518: LD_INT 23
80520: EQUAL
80521: IFFALSE 80531
// sOilTower := true ;
80523: LD_ADDR_EXP 144
80527: PUSH
80528: LD_INT 1
80530: ST_TO_ADDR
// if p3 = 24 then
80531: LD_VAR 0 3
80535: PUSH
80536: LD_INT 24
80538: EQUAL
80539: IFFALSE 80549
// sShovel := true ;
80541: LD_ADDR_EXP 145
80545: PUSH
80546: LD_INT 1
80548: ST_TO_ADDR
// if p3 = 25 then
80549: LD_VAR 0 3
80553: PUSH
80554: LD_INT 25
80556: EQUAL
80557: IFFALSE 80567
// sSheik := true ;
80559: LD_ADDR_EXP 146
80563: PUSH
80564: LD_INT 1
80566: ST_TO_ADDR
// if p3 = 26 then
80567: LD_VAR 0 3
80571: PUSH
80572: LD_INT 26
80574: EQUAL
80575: IFFALSE 80585
// sEarthquake := true ;
80577: LD_ADDR_EXP 148
80581: PUSH
80582: LD_INT 1
80584: ST_TO_ADDR
// if p3 = 27 then
80585: LD_VAR 0 3
80589: PUSH
80590: LD_INT 27
80592: EQUAL
80593: IFFALSE 80603
// sAI := true ;
80595: LD_ADDR_EXP 149
80599: PUSH
80600: LD_INT 1
80602: ST_TO_ADDR
// if p3 = 28 then
80603: LD_VAR 0 3
80607: PUSH
80608: LD_INT 28
80610: EQUAL
80611: IFFALSE 80621
// sCargo := true ;
80613: LD_ADDR_EXP 152
80617: PUSH
80618: LD_INT 1
80620: ST_TO_ADDR
// if p3 = 29 then
80621: LD_VAR 0 3
80625: PUSH
80626: LD_INT 29
80628: EQUAL
80629: IFFALSE 80639
// sDLaser := true ;
80631: LD_ADDR_EXP 153
80635: PUSH
80636: LD_INT 1
80638: ST_TO_ADDR
// if p3 = 30 then
80639: LD_VAR 0 3
80643: PUSH
80644: LD_INT 30
80646: EQUAL
80647: IFFALSE 80657
// sExchange := true ;
80649: LD_ADDR_EXP 154
80653: PUSH
80654: LD_INT 1
80656: ST_TO_ADDR
// if p3 = 31 then
80657: LD_VAR 0 3
80661: PUSH
80662: LD_INT 31
80664: EQUAL
80665: IFFALSE 80675
// sFac := true ;
80667: LD_ADDR_EXP 155
80671: PUSH
80672: LD_INT 1
80674: ST_TO_ADDR
// if p3 = 32 then
80675: LD_VAR 0 3
80679: PUSH
80680: LD_INT 32
80682: EQUAL
80683: IFFALSE 80693
// sPower := true ;
80685: LD_ADDR_EXP 156
80689: PUSH
80690: LD_INT 1
80692: ST_TO_ADDR
// if p3 = 33 then
80693: LD_VAR 0 3
80697: PUSH
80698: LD_INT 33
80700: EQUAL
80701: IFFALSE 80711
// sRandom := true ;
80703: LD_ADDR_EXP 157
80707: PUSH
80708: LD_INT 1
80710: ST_TO_ADDR
// if p3 = 34 then
80711: LD_VAR 0 3
80715: PUSH
80716: LD_INT 34
80718: EQUAL
80719: IFFALSE 80729
// sShield := true ;
80721: LD_ADDR_EXP 158
80725: PUSH
80726: LD_INT 1
80728: ST_TO_ADDR
// if p3 = 35 then
80729: LD_VAR 0 3
80733: PUSH
80734: LD_INT 35
80736: EQUAL
80737: IFFALSE 80747
// sTime := true ;
80739: LD_ADDR_EXP 159
80743: PUSH
80744: LD_INT 1
80746: ST_TO_ADDR
// if p3 = 36 then
80747: LD_VAR 0 3
80751: PUSH
80752: LD_INT 36
80754: EQUAL
80755: IFFALSE 80765
// sTools := true ;
80757: LD_ADDR_EXP 160
80761: PUSH
80762: LD_INT 1
80764: ST_TO_ADDR
// if p3 = 101 then
80765: LD_VAR 0 3
80769: PUSH
80770: LD_INT 101
80772: EQUAL
80773: IFFALSE 80783
// sSold := true ;
80775: LD_ADDR_EXP 125
80779: PUSH
80780: LD_INT 1
80782: ST_TO_ADDR
// if p3 = 102 then
80783: LD_VAR 0 3
80787: PUSH
80788: LD_INT 102
80790: EQUAL
80791: IFFALSE 80801
// sDiff := true ;
80793: LD_ADDR_EXP 126
80797: PUSH
80798: LD_INT 1
80800: ST_TO_ADDR
// if p3 = 103 then
80801: LD_VAR 0 3
80805: PUSH
80806: LD_INT 103
80808: EQUAL
80809: IFFALSE 80819
// sFog := true ;
80811: LD_ADDR_EXP 129
80815: PUSH
80816: LD_INT 1
80818: ST_TO_ADDR
// if p3 = 104 then
80819: LD_VAR 0 3
80823: PUSH
80824: LD_INT 104
80826: EQUAL
80827: IFFALSE 80837
// sReset := true ;
80829: LD_ADDR_EXP 130
80833: PUSH
80834: LD_INT 1
80836: ST_TO_ADDR
// if p3 = 105 then
80837: LD_VAR 0 3
80841: PUSH
80842: LD_INT 105
80844: EQUAL
80845: IFFALSE 80855
// sSun := true ;
80847: LD_ADDR_EXP 131
80851: PUSH
80852: LD_INT 1
80854: ST_TO_ADDR
// if p3 = 106 then
80855: LD_VAR 0 3
80859: PUSH
80860: LD_INT 106
80862: EQUAL
80863: IFFALSE 80873
// sTiger := true ;
80865: LD_ADDR_EXP 127
80869: PUSH
80870: LD_INT 1
80872: ST_TO_ADDR
// if p3 = 107 then
80873: LD_VAR 0 3
80877: PUSH
80878: LD_INT 107
80880: EQUAL
80881: IFFALSE 80891
// sBomb := true ;
80883: LD_ADDR_EXP 128
80887: PUSH
80888: LD_INT 1
80890: ST_TO_ADDR
// if p3 = 108 then
80891: LD_VAR 0 3
80895: PUSH
80896: LD_INT 108
80898: EQUAL
80899: IFFALSE 80909
// sWound := true ;
80901: LD_ADDR_EXP 136
80905: PUSH
80906: LD_INT 1
80908: ST_TO_ADDR
// if p3 = 109 then
80909: LD_VAR 0 3
80913: PUSH
80914: LD_INT 109
80916: EQUAL
80917: IFFALSE 80927
// sBetray := true ;
80919: LD_ADDR_EXP 140
80923: PUSH
80924: LD_INT 1
80926: ST_TO_ADDR
// if p3 = 110 then
80927: LD_VAR 0 3
80931: PUSH
80932: LD_INT 110
80934: EQUAL
80935: IFFALSE 80945
// sContamin := true ;
80937: LD_ADDR_EXP 141
80941: PUSH
80942: LD_INT 1
80944: ST_TO_ADDR
// if p3 = 111 then
80945: LD_VAR 0 3
80949: PUSH
80950: LD_INT 111
80952: EQUAL
80953: IFFALSE 80963
// sOil := true ;
80955: LD_ADDR_EXP 143
80959: PUSH
80960: LD_INT 1
80962: ST_TO_ADDR
// if p3 = 112 then
80963: LD_VAR 0 3
80967: PUSH
80968: LD_INT 112
80970: EQUAL
80971: IFFALSE 80981
// sStu := true ;
80973: LD_ADDR_EXP 147
80977: PUSH
80978: LD_INT 1
80980: ST_TO_ADDR
// if p3 = 113 then
80981: LD_VAR 0 3
80985: PUSH
80986: LD_INT 113
80988: EQUAL
80989: IFFALSE 80999
// sBazooka := true ;
80991: LD_ADDR_EXP 150
80995: PUSH
80996: LD_INT 1
80998: ST_TO_ADDR
// if p3 = 114 then
80999: LD_VAR 0 3
81003: PUSH
81004: LD_INT 114
81006: EQUAL
81007: IFFALSE 81017
// sMortar := true ;
81009: LD_ADDR_EXP 151
81013: PUSH
81014: LD_INT 1
81016: ST_TO_ADDR
// if p3 = 115 then
81017: LD_VAR 0 3
81021: PUSH
81022: LD_INT 115
81024: EQUAL
81025: IFFALSE 81035
// sRanger := true ;
81027: LD_ADDR_EXP 161
81031: PUSH
81032: LD_INT 1
81034: ST_TO_ADDR
// end ; if p2 = 101 then
81035: LD_VAR 0 2
81039: PUSH
81040: LD_INT 101
81042: EQUAL
81043: IFFALSE 81171
// begin case p3 of 1 :
81045: LD_VAR 0 3
81049: PUSH
81050: LD_INT 1
81052: DOUBLE
81053: EQUAL
81054: IFTRUE 81058
81056: GO 81065
81058: POP
// hHackUnlimitedResources ; 2 :
81059: CALL 92206 0 0
81063: GO 81171
81065: LD_INT 2
81067: DOUBLE
81068: EQUAL
81069: IFTRUE 81073
81071: GO 81080
81073: POP
// hHackSetLevel10 ; 3 :
81074: CALL 92339 0 0
81078: GO 81171
81080: LD_INT 3
81082: DOUBLE
81083: EQUAL
81084: IFTRUE 81088
81086: GO 81095
81088: POP
// hHackSetLevel10YourUnits ; 4 :
81089: CALL 92424 0 0
81093: GO 81171
81095: LD_INT 4
81097: DOUBLE
81098: EQUAL
81099: IFTRUE 81103
81101: GO 81110
81103: POP
// hHackInvincible ; 5 :
81104: CALL 92872 0 0
81108: GO 81171
81110: LD_INT 5
81112: DOUBLE
81113: EQUAL
81114: IFTRUE 81118
81116: GO 81125
81118: POP
// hHackInvisible ; 6 :
81119: CALL 92983 0 0
81123: GO 81171
81125: LD_INT 6
81127: DOUBLE
81128: EQUAL
81129: IFTRUE 81133
81131: GO 81140
81133: POP
// hHackChangeYourSide ; 7 :
81134: CALL 93040 0 0
81138: GO 81171
81140: LD_INT 7
81142: DOUBLE
81143: EQUAL
81144: IFTRUE 81148
81146: GO 81155
81148: POP
// hHackChangeUnitSide ; 8 :
81149: CALL 93082 0 0
81153: GO 81171
81155: LD_INT 8
81157: DOUBLE
81158: EQUAL
81159: IFTRUE 81163
81161: GO 81170
81163: POP
// hHackFog ; end ;
81164: CALL 93183 0 0
81168: GO 81171
81170: POP
// end ; end ;
81171: PPOPN 6
81173: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
81174: GO 81176
81176: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
81177: LD_STRING initStreamRollete();
81179: PPUSH
81180: CALL_OW 559
// InitStreamMode ;
81184: CALL 81193 0 0
// DefineStreamItems ( ) ;
81188: CALL 81633 0 0
// end ;
81192: END
// function InitStreamMode ; begin
81193: LD_INT 0
81195: PPUSH
// streamModeActive := false ;
81196: LD_ADDR_EXP 108
81200: PUSH
81201: LD_INT 0
81203: ST_TO_ADDR
// normalCounter := 36 ;
81204: LD_ADDR_EXP 109
81208: PUSH
81209: LD_INT 36
81211: ST_TO_ADDR
// hardcoreCounter := 16 ;
81212: LD_ADDR_EXP 110
81216: PUSH
81217: LD_INT 16
81219: ST_TO_ADDR
// sRocket := false ;
81220: LD_ADDR_EXP 113
81224: PUSH
81225: LD_INT 0
81227: ST_TO_ADDR
// sSpeed := false ;
81228: LD_ADDR_EXP 112
81232: PUSH
81233: LD_INT 0
81235: ST_TO_ADDR
// sEngine := false ;
81236: LD_ADDR_EXP 114
81240: PUSH
81241: LD_INT 0
81243: ST_TO_ADDR
// sSpec := false ;
81244: LD_ADDR_EXP 111
81248: PUSH
81249: LD_INT 0
81251: ST_TO_ADDR
// sLevel := false ;
81252: LD_ADDR_EXP 115
81256: PUSH
81257: LD_INT 0
81259: ST_TO_ADDR
// sArmoury := false ;
81260: LD_ADDR_EXP 116
81264: PUSH
81265: LD_INT 0
81267: ST_TO_ADDR
// sRadar := false ;
81268: LD_ADDR_EXP 117
81272: PUSH
81273: LD_INT 0
81275: ST_TO_ADDR
// sBunker := false ;
81276: LD_ADDR_EXP 118
81280: PUSH
81281: LD_INT 0
81283: ST_TO_ADDR
// sHack := false ;
81284: LD_ADDR_EXP 119
81288: PUSH
81289: LD_INT 0
81291: ST_TO_ADDR
// sFire := false ;
81292: LD_ADDR_EXP 120
81296: PUSH
81297: LD_INT 0
81299: ST_TO_ADDR
// sRefresh := false ;
81300: LD_ADDR_EXP 121
81304: PUSH
81305: LD_INT 0
81307: ST_TO_ADDR
// sExp := false ;
81308: LD_ADDR_EXP 122
81312: PUSH
81313: LD_INT 0
81315: ST_TO_ADDR
// sDepot := false ;
81316: LD_ADDR_EXP 123
81320: PUSH
81321: LD_INT 0
81323: ST_TO_ADDR
// sFlag := false ;
81324: LD_ADDR_EXP 124
81328: PUSH
81329: LD_INT 0
81331: ST_TO_ADDR
// sKamikadze := false ;
81332: LD_ADDR_EXP 132
81336: PUSH
81337: LD_INT 0
81339: ST_TO_ADDR
// sTroll := false ;
81340: LD_ADDR_EXP 133
81344: PUSH
81345: LD_INT 0
81347: ST_TO_ADDR
// sSlow := false ;
81348: LD_ADDR_EXP 134
81352: PUSH
81353: LD_INT 0
81355: ST_TO_ADDR
// sLack := false ;
81356: LD_ADDR_EXP 135
81360: PUSH
81361: LD_INT 0
81363: ST_TO_ADDR
// sTank := false ;
81364: LD_ADDR_EXP 137
81368: PUSH
81369: LD_INT 0
81371: ST_TO_ADDR
// sRemote := false ;
81372: LD_ADDR_EXP 138
81376: PUSH
81377: LD_INT 0
81379: ST_TO_ADDR
// sPowell := false ;
81380: LD_ADDR_EXP 139
81384: PUSH
81385: LD_INT 0
81387: ST_TO_ADDR
// sTeleport := false ;
81388: LD_ADDR_EXP 142
81392: PUSH
81393: LD_INT 0
81395: ST_TO_ADDR
// sOilTower := false ;
81396: LD_ADDR_EXP 144
81400: PUSH
81401: LD_INT 0
81403: ST_TO_ADDR
// sShovel := false ;
81404: LD_ADDR_EXP 145
81408: PUSH
81409: LD_INT 0
81411: ST_TO_ADDR
// sSheik := false ;
81412: LD_ADDR_EXP 146
81416: PUSH
81417: LD_INT 0
81419: ST_TO_ADDR
// sEarthquake := false ;
81420: LD_ADDR_EXP 148
81424: PUSH
81425: LD_INT 0
81427: ST_TO_ADDR
// sAI := false ;
81428: LD_ADDR_EXP 149
81432: PUSH
81433: LD_INT 0
81435: ST_TO_ADDR
// sCargo := false ;
81436: LD_ADDR_EXP 152
81440: PUSH
81441: LD_INT 0
81443: ST_TO_ADDR
// sDLaser := false ;
81444: LD_ADDR_EXP 153
81448: PUSH
81449: LD_INT 0
81451: ST_TO_ADDR
// sExchange := false ;
81452: LD_ADDR_EXP 154
81456: PUSH
81457: LD_INT 0
81459: ST_TO_ADDR
// sFac := false ;
81460: LD_ADDR_EXP 155
81464: PUSH
81465: LD_INT 0
81467: ST_TO_ADDR
// sPower := false ;
81468: LD_ADDR_EXP 156
81472: PUSH
81473: LD_INT 0
81475: ST_TO_ADDR
// sRandom := false ;
81476: LD_ADDR_EXP 157
81480: PUSH
81481: LD_INT 0
81483: ST_TO_ADDR
// sShield := false ;
81484: LD_ADDR_EXP 158
81488: PUSH
81489: LD_INT 0
81491: ST_TO_ADDR
// sTime := false ;
81492: LD_ADDR_EXP 159
81496: PUSH
81497: LD_INT 0
81499: ST_TO_ADDR
// sTools := false ;
81500: LD_ADDR_EXP 160
81504: PUSH
81505: LD_INT 0
81507: ST_TO_ADDR
// sSold := false ;
81508: LD_ADDR_EXP 125
81512: PUSH
81513: LD_INT 0
81515: ST_TO_ADDR
// sDiff := false ;
81516: LD_ADDR_EXP 126
81520: PUSH
81521: LD_INT 0
81523: ST_TO_ADDR
// sFog := false ;
81524: LD_ADDR_EXP 129
81528: PUSH
81529: LD_INT 0
81531: ST_TO_ADDR
// sReset := false ;
81532: LD_ADDR_EXP 130
81536: PUSH
81537: LD_INT 0
81539: ST_TO_ADDR
// sSun := false ;
81540: LD_ADDR_EXP 131
81544: PUSH
81545: LD_INT 0
81547: ST_TO_ADDR
// sTiger := false ;
81548: LD_ADDR_EXP 127
81552: PUSH
81553: LD_INT 0
81555: ST_TO_ADDR
// sBomb := false ;
81556: LD_ADDR_EXP 128
81560: PUSH
81561: LD_INT 0
81563: ST_TO_ADDR
// sWound := false ;
81564: LD_ADDR_EXP 136
81568: PUSH
81569: LD_INT 0
81571: ST_TO_ADDR
// sBetray := false ;
81572: LD_ADDR_EXP 140
81576: PUSH
81577: LD_INT 0
81579: ST_TO_ADDR
// sContamin := false ;
81580: LD_ADDR_EXP 141
81584: PUSH
81585: LD_INT 0
81587: ST_TO_ADDR
// sOil := false ;
81588: LD_ADDR_EXP 143
81592: PUSH
81593: LD_INT 0
81595: ST_TO_ADDR
// sStu := false ;
81596: LD_ADDR_EXP 147
81600: PUSH
81601: LD_INT 0
81603: ST_TO_ADDR
// sBazooka := false ;
81604: LD_ADDR_EXP 150
81608: PUSH
81609: LD_INT 0
81611: ST_TO_ADDR
// sMortar := false ;
81612: LD_ADDR_EXP 151
81616: PUSH
81617: LD_INT 0
81619: ST_TO_ADDR
// sRanger := false ;
81620: LD_ADDR_EXP 161
81624: PUSH
81625: LD_INT 0
81627: ST_TO_ADDR
// end ;
81628: LD_VAR 0 1
81632: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
81633: LD_INT 0
81635: PPUSH
81636: PPUSH
81637: PPUSH
81638: PPUSH
81639: PPUSH
// result := [ ] ;
81640: LD_ADDR_VAR 0 1
81644: PUSH
81645: EMPTY
81646: ST_TO_ADDR
// if campaign_id = 1 then
81647: LD_OWVAR 69
81651: PUSH
81652: LD_INT 1
81654: EQUAL
81655: IFFALSE 84593
// begin case mission_number of 1 :
81657: LD_OWVAR 70
81661: PUSH
81662: LD_INT 1
81664: DOUBLE
81665: EQUAL
81666: IFTRUE 81670
81668: GO 81734
81670: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
81671: LD_ADDR_VAR 0 1
81675: PUSH
81676: LD_INT 2
81678: PUSH
81679: LD_INT 4
81681: PUSH
81682: LD_INT 11
81684: PUSH
81685: LD_INT 12
81687: PUSH
81688: LD_INT 15
81690: PUSH
81691: LD_INT 16
81693: PUSH
81694: LD_INT 22
81696: PUSH
81697: LD_INT 23
81699: PUSH
81700: LD_INT 26
81702: PUSH
81703: EMPTY
81704: LIST
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: LIST
81713: PUSH
81714: LD_INT 101
81716: PUSH
81717: LD_INT 102
81719: PUSH
81720: LD_INT 106
81722: PUSH
81723: EMPTY
81724: LIST
81725: LIST
81726: LIST
81727: PUSH
81728: EMPTY
81729: LIST
81730: LIST
81731: ST_TO_ADDR
81732: GO 84591
81734: LD_INT 2
81736: DOUBLE
81737: EQUAL
81738: IFTRUE 81742
81740: GO 81814
81742: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
81743: LD_ADDR_VAR 0 1
81747: PUSH
81748: LD_INT 2
81750: PUSH
81751: LD_INT 4
81753: PUSH
81754: LD_INT 11
81756: PUSH
81757: LD_INT 12
81759: PUSH
81760: LD_INT 15
81762: PUSH
81763: LD_INT 16
81765: PUSH
81766: LD_INT 22
81768: PUSH
81769: LD_INT 23
81771: PUSH
81772: LD_INT 26
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: LIST
81779: LIST
81780: LIST
81781: LIST
81782: LIST
81783: LIST
81784: LIST
81785: PUSH
81786: LD_INT 101
81788: PUSH
81789: LD_INT 102
81791: PUSH
81792: LD_INT 105
81794: PUSH
81795: LD_INT 106
81797: PUSH
81798: LD_INT 108
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: LIST
81805: LIST
81806: LIST
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: ST_TO_ADDR
81812: GO 84591
81814: LD_INT 3
81816: DOUBLE
81817: EQUAL
81818: IFTRUE 81822
81820: GO 81898
81822: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
81823: LD_ADDR_VAR 0 1
81827: PUSH
81828: LD_INT 2
81830: PUSH
81831: LD_INT 4
81833: PUSH
81834: LD_INT 5
81836: PUSH
81837: LD_INT 11
81839: PUSH
81840: LD_INT 12
81842: PUSH
81843: LD_INT 15
81845: PUSH
81846: LD_INT 16
81848: PUSH
81849: LD_INT 22
81851: PUSH
81852: LD_INT 26
81854: PUSH
81855: LD_INT 36
81857: PUSH
81858: EMPTY
81859: LIST
81860: LIST
81861: LIST
81862: LIST
81863: LIST
81864: LIST
81865: LIST
81866: LIST
81867: LIST
81868: LIST
81869: PUSH
81870: LD_INT 101
81872: PUSH
81873: LD_INT 102
81875: PUSH
81876: LD_INT 105
81878: PUSH
81879: LD_INT 106
81881: PUSH
81882: LD_INT 108
81884: PUSH
81885: EMPTY
81886: LIST
81887: LIST
81888: LIST
81889: LIST
81890: LIST
81891: PUSH
81892: EMPTY
81893: LIST
81894: LIST
81895: ST_TO_ADDR
81896: GO 84591
81898: LD_INT 4
81900: DOUBLE
81901: EQUAL
81902: IFTRUE 81906
81904: GO 81990
81906: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
81907: LD_ADDR_VAR 0 1
81911: PUSH
81912: LD_INT 2
81914: PUSH
81915: LD_INT 4
81917: PUSH
81918: LD_INT 5
81920: PUSH
81921: LD_INT 8
81923: PUSH
81924: LD_INT 11
81926: PUSH
81927: LD_INT 12
81929: PUSH
81930: LD_INT 15
81932: PUSH
81933: LD_INT 16
81935: PUSH
81936: LD_INT 22
81938: PUSH
81939: LD_INT 23
81941: PUSH
81942: LD_INT 26
81944: PUSH
81945: LD_INT 36
81947: PUSH
81948: EMPTY
81949: LIST
81950: LIST
81951: LIST
81952: LIST
81953: LIST
81954: LIST
81955: LIST
81956: LIST
81957: LIST
81958: LIST
81959: LIST
81960: LIST
81961: PUSH
81962: LD_INT 101
81964: PUSH
81965: LD_INT 102
81967: PUSH
81968: LD_INT 105
81970: PUSH
81971: LD_INT 106
81973: PUSH
81974: LD_INT 108
81976: PUSH
81977: EMPTY
81978: LIST
81979: LIST
81980: LIST
81981: LIST
81982: LIST
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: ST_TO_ADDR
81988: GO 84591
81990: LD_INT 5
81992: DOUBLE
81993: EQUAL
81994: IFTRUE 81998
81996: GO 82098
81998: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
81999: LD_ADDR_VAR 0 1
82003: PUSH
82004: LD_INT 2
82006: PUSH
82007: LD_INT 4
82009: PUSH
82010: LD_INT 5
82012: PUSH
82013: LD_INT 6
82015: PUSH
82016: LD_INT 8
82018: PUSH
82019: LD_INT 11
82021: PUSH
82022: LD_INT 12
82024: PUSH
82025: LD_INT 15
82027: PUSH
82028: LD_INT 16
82030: PUSH
82031: LD_INT 22
82033: PUSH
82034: LD_INT 23
82036: PUSH
82037: LD_INT 25
82039: PUSH
82040: LD_INT 26
82042: PUSH
82043: LD_INT 36
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: LIST
82050: LIST
82051: LIST
82052: LIST
82053: LIST
82054: LIST
82055: LIST
82056: LIST
82057: LIST
82058: LIST
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 101
82064: PUSH
82065: LD_INT 102
82067: PUSH
82068: LD_INT 105
82070: PUSH
82071: LD_INT 106
82073: PUSH
82074: LD_INT 108
82076: PUSH
82077: LD_INT 109
82079: PUSH
82080: LD_INT 112
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: LIST
82087: LIST
82088: LIST
82089: LIST
82090: LIST
82091: PUSH
82092: EMPTY
82093: LIST
82094: LIST
82095: ST_TO_ADDR
82096: GO 84591
82098: LD_INT 6
82100: DOUBLE
82101: EQUAL
82102: IFTRUE 82106
82104: GO 82226
82106: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
82107: LD_ADDR_VAR 0 1
82111: PUSH
82112: LD_INT 2
82114: PUSH
82115: LD_INT 4
82117: PUSH
82118: LD_INT 5
82120: PUSH
82121: LD_INT 6
82123: PUSH
82124: LD_INT 8
82126: PUSH
82127: LD_INT 11
82129: PUSH
82130: LD_INT 12
82132: PUSH
82133: LD_INT 15
82135: PUSH
82136: LD_INT 16
82138: PUSH
82139: LD_INT 20
82141: PUSH
82142: LD_INT 21
82144: PUSH
82145: LD_INT 22
82147: PUSH
82148: LD_INT 23
82150: PUSH
82151: LD_INT 25
82153: PUSH
82154: LD_INT 26
82156: PUSH
82157: LD_INT 30
82159: PUSH
82160: LD_INT 31
82162: PUSH
82163: LD_INT 32
82165: PUSH
82166: LD_INT 36
82168: PUSH
82169: EMPTY
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: LIST
82187: LIST
82188: LIST
82189: PUSH
82190: LD_INT 101
82192: PUSH
82193: LD_INT 102
82195: PUSH
82196: LD_INT 105
82198: PUSH
82199: LD_INT 106
82201: PUSH
82202: LD_INT 108
82204: PUSH
82205: LD_INT 109
82207: PUSH
82208: LD_INT 112
82210: PUSH
82211: EMPTY
82212: LIST
82213: LIST
82214: LIST
82215: LIST
82216: LIST
82217: LIST
82218: LIST
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: ST_TO_ADDR
82224: GO 84591
82226: LD_INT 7
82228: DOUBLE
82229: EQUAL
82230: IFTRUE 82234
82232: GO 82334
82234: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
82235: LD_ADDR_VAR 0 1
82239: PUSH
82240: LD_INT 2
82242: PUSH
82243: LD_INT 4
82245: PUSH
82246: LD_INT 5
82248: PUSH
82249: LD_INT 7
82251: PUSH
82252: LD_INT 11
82254: PUSH
82255: LD_INT 12
82257: PUSH
82258: LD_INT 15
82260: PUSH
82261: LD_INT 16
82263: PUSH
82264: LD_INT 20
82266: PUSH
82267: LD_INT 21
82269: PUSH
82270: LD_INT 22
82272: PUSH
82273: LD_INT 23
82275: PUSH
82276: LD_INT 25
82278: PUSH
82279: LD_INT 26
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: LIST
82286: LIST
82287: LIST
82288: LIST
82289: LIST
82290: LIST
82291: LIST
82292: LIST
82293: LIST
82294: LIST
82295: LIST
82296: LIST
82297: PUSH
82298: LD_INT 101
82300: PUSH
82301: LD_INT 102
82303: PUSH
82304: LD_INT 103
82306: PUSH
82307: LD_INT 105
82309: PUSH
82310: LD_INT 106
82312: PUSH
82313: LD_INT 108
82315: PUSH
82316: LD_INT 112
82318: PUSH
82319: EMPTY
82320: LIST
82321: LIST
82322: LIST
82323: LIST
82324: LIST
82325: LIST
82326: LIST
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: ST_TO_ADDR
82332: GO 84591
82334: LD_INT 8
82336: DOUBLE
82337: EQUAL
82338: IFTRUE 82342
82340: GO 82470
82342: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
82343: LD_ADDR_VAR 0 1
82347: PUSH
82348: LD_INT 2
82350: PUSH
82351: LD_INT 4
82353: PUSH
82354: LD_INT 5
82356: PUSH
82357: LD_INT 6
82359: PUSH
82360: LD_INT 7
82362: PUSH
82363: LD_INT 8
82365: PUSH
82366: LD_INT 11
82368: PUSH
82369: LD_INT 12
82371: PUSH
82372: LD_INT 15
82374: PUSH
82375: LD_INT 16
82377: PUSH
82378: LD_INT 20
82380: PUSH
82381: LD_INT 21
82383: PUSH
82384: LD_INT 22
82386: PUSH
82387: LD_INT 23
82389: PUSH
82390: LD_INT 25
82392: PUSH
82393: LD_INT 26
82395: PUSH
82396: LD_INT 30
82398: PUSH
82399: LD_INT 31
82401: PUSH
82402: LD_INT 32
82404: PUSH
82405: LD_INT 36
82407: PUSH
82408: EMPTY
82409: LIST
82410: LIST
82411: LIST
82412: LIST
82413: LIST
82414: LIST
82415: LIST
82416: LIST
82417: LIST
82418: LIST
82419: LIST
82420: LIST
82421: LIST
82422: LIST
82423: LIST
82424: LIST
82425: LIST
82426: LIST
82427: LIST
82428: LIST
82429: PUSH
82430: LD_INT 101
82432: PUSH
82433: LD_INT 102
82435: PUSH
82436: LD_INT 103
82438: PUSH
82439: LD_INT 105
82441: PUSH
82442: LD_INT 106
82444: PUSH
82445: LD_INT 108
82447: PUSH
82448: LD_INT 109
82450: PUSH
82451: LD_INT 112
82453: PUSH
82454: EMPTY
82455: LIST
82456: LIST
82457: LIST
82458: LIST
82459: LIST
82460: LIST
82461: LIST
82462: LIST
82463: PUSH
82464: EMPTY
82465: LIST
82466: LIST
82467: ST_TO_ADDR
82468: GO 84591
82470: LD_INT 9
82472: DOUBLE
82473: EQUAL
82474: IFTRUE 82478
82476: GO 82614
82478: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
82479: LD_ADDR_VAR 0 1
82483: PUSH
82484: LD_INT 2
82486: PUSH
82487: LD_INT 4
82489: PUSH
82490: LD_INT 5
82492: PUSH
82493: LD_INT 6
82495: PUSH
82496: LD_INT 7
82498: PUSH
82499: LD_INT 8
82501: PUSH
82502: LD_INT 11
82504: PUSH
82505: LD_INT 12
82507: PUSH
82508: LD_INT 15
82510: PUSH
82511: LD_INT 16
82513: PUSH
82514: LD_INT 20
82516: PUSH
82517: LD_INT 21
82519: PUSH
82520: LD_INT 22
82522: PUSH
82523: LD_INT 23
82525: PUSH
82526: LD_INT 25
82528: PUSH
82529: LD_INT 26
82531: PUSH
82532: LD_INT 28
82534: PUSH
82535: LD_INT 30
82537: PUSH
82538: LD_INT 31
82540: PUSH
82541: LD_INT 32
82543: PUSH
82544: LD_INT 36
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: LIST
82551: LIST
82552: LIST
82553: LIST
82554: LIST
82555: LIST
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: PUSH
82570: LD_INT 101
82572: PUSH
82573: LD_INT 102
82575: PUSH
82576: LD_INT 103
82578: PUSH
82579: LD_INT 105
82581: PUSH
82582: LD_INT 106
82584: PUSH
82585: LD_INT 108
82587: PUSH
82588: LD_INT 109
82590: PUSH
82591: LD_INT 112
82593: PUSH
82594: LD_INT 114
82596: PUSH
82597: EMPTY
82598: LIST
82599: LIST
82600: LIST
82601: LIST
82602: LIST
82603: LIST
82604: LIST
82605: LIST
82606: LIST
82607: PUSH
82608: EMPTY
82609: LIST
82610: LIST
82611: ST_TO_ADDR
82612: GO 84591
82614: LD_INT 10
82616: DOUBLE
82617: EQUAL
82618: IFTRUE 82622
82620: GO 82806
82622: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
82623: LD_ADDR_VAR 0 1
82627: PUSH
82628: LD_INT 2
82630: PUSH
82631: LD_INT 4
82633: PUSH
82634: LD_INT 5
82636: PUSH
82637: LD_INT 6
82639: PUSH
82640: LD_INT 7
82642: PUSH
82643: LD_INT 8
82645: PUSH
82646: LD_INT 9
82648: PUSH
82649: LD_INT 10
82651: PUSH
82652: LD_INT 11
82654: PUSH
82655: LD_INT 12
82657: PUSH
82658: LD_INT 13
82660: PUSH
82661: LD_INT 14
82663: PUSH
82664: LD_INT 15
82666: PUSH
82667: LD_INT 16
82669: PUSH
82670: LD_INT 17
82672: PUSH
82673: LD_INT 18
82675: PUSH
82676: LD_INT 19
82678: PUSH
82679: LD_INT 20
82681: PUSH
82682: LD_INT 21
82684: PUSH
82685: LD_INT 22
82687: PUSH
82688: LD_INT 23
82690: PUSH
82691: LD_INT 24
82693: PUSH
82694: LD_INT 25
82696: PUSH
82697: LD_INT 26
82699: PUSH
82700: LD_INT 28
82702: PUSH
82703: LD_INT 30
82705: PUSH
82706: LD_INT 31
82708: PUSH
82709: LD_INT 32
82711: PUSH
82712: LD_INT 36
82714: PUSH
82715: EMPTY
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: LIST
82744: LIST
82745: PUSH
82746: LD_INT 101
82748: PUSH
82749: LD_INT 102
82751: PUSH
82752: LD_INT 103
82754: PUSH
82755: LD_INT 104
82757: PUSH
82758: LD_INT 105
82760: PUSH
82761: LD_INT 106
82763: PUSH
82764: LD_INT 107
82766: PUSH
82767: LD_INT 108
82769: PUSH
82770: LD_INT 109
82772: PUSH
82773: LD_INT 110
82775: PUSH
82776: LD_INT 111
82778: PUSH
82779: LD_INT 112
82781: PUSH
82782: LD_INT 114
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: LIST
82789: LIST
82790: LIST
82791: LIST
82792: LIST
82793: LIST
82794: LIST
82795: LIST
82796: LIST
82797: LIST
82798: LIST
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: ST_TO_ADDR
82804: GO 84591
82806: LD_INT 11
82808: DOUBLE
82809: EQUAL
82810: IFTRUE 82814
82812: GO 83006
82814: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
82815: LD_ADDR_VAR 0 1
82819: PUSH
82820: LD_INT 2
82822: PUSH
82823: LD_INT 3
82825: PUSH
82826: LD_INT 4
82828: PUSH
82829: LD_INT 5
82831: PUSH
82832: LD_INT 6
82834: PUSH
82835: LD_INT 7
82837: PUSH
82838: LD_INT 8
82840: PUSH
82841: LD_INT 9
82843: PUSH
82844: LD_INT 10
82846: PUSH
82847: LD_INT 11
82849: PUSH
82850: LD_INT 12
82852: PUSH
82853: LD_INT 13
82855: PUSH
82856: LD_INT 14
82858: PUSH
82859: LD_INT 15
82861: PUSH
82862: LD_INT 16
82864: PUSH
82865: LD_INT 17
82867: PUSH
82868: LD_INT 18
82870: PUSH
82871: LD_INT 19
82873: PUSH
82874: LD_INT 20
82876: PUSH
82877: LD_INT 21
82879: PUSH
82880: LD_INT 22
82882: PUSH
82883: LD_INT 23
82885: PUSH
82886: LD_INT 24
82888: PUSH
82889: LD_INT 25
82891: PUSH
82892: LD_INT 26
82894: PUSH
82895: LD_INT 28
82897: PUSH
82898: LD_INT 30
82900: PUSH
82901: LD_INT 31
82903: PUSH
82904: LD_INT 32
82906: PUSH
82907: LD_INT 34
82909: PUSH
82910: LD_INT 36
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: LIST
82927: LIST
82928: LIST
82929: LIST
82930: LIST
82931: LIST
82932: LIST
82933: LIST
82934: LIST
82935: LIST
82936: LIST
82937: LIST
82938: LIST
82939: LIST
82940: LIST
82941: LIST
82942: LIST
82943: LIST
82944: LIST
82945: PUSH
82946: LD_INT 101
82948: PUSH
82949: LD_INT 102
82951: PUSH
82952: LD_INT 103
82954: PUSH
82955: LD_INT 104
82957: PUSH
82958: LD_INT 105
82960: PUSH
82961: LD_INT 106
82963: PUSH
82964: LD_INT 107
82966: PUSH
82967: LD_INT 108
82969: PUSH
82970: LD_INT 109
82972: PUSH
82973: LD_INT 110
82975: PUSH
82976: LD_INT 111
82978: PUSH
82979: LD_INT 112
82981: PUSH
82982: LD_INT 114
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: LIST
82989: LIST
82990: LIST
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: LIST
82997: LIST
82998: LIST
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: ST_TO_ADDR
83004: GO 84591
83006: LD_INT 12
83008: DOUBLE
83009: EQUAL
83010: IFTRUE 83014
83012: GO 83222
83014: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
83015: LD_ADDR_VAR 0 1
83019: PUSH
83020: LD_INT 1
83022: PUSH
83023: LD_INT 2
83025: PUSH
83026: LD_INT 3
83028: PUSH
83029: LD_INT 4
83031: PUSH
83032: LD_INT 5
83034: PUSH
83035: LD_INT 6
83037: PUSH
83038: LD_INT 7
83040: PUSH
83041: LD_INT 8
83043: PUSH
83044: LD_INT 9
83046: PUSH
83047: LD_INT 10
83049: PUSH
83050: LD_INT 11
83052: PUSH
83053: LD_INT 12
83055: PUSH
83056: LD_INT 13
83058: PUSH
83059: LD_INT 14
83061: PUSH
83062: LD_INT 15
83064: PUSH
83065: LD_INT 16
83067: PUSH
83068: LD_INT 17
83070: PUSH
83071: LD_INT 18
83073: PUSH
83074: LD_INT 19
83076: PUSH
83077: LD_INT 20
83079: PUSH
83080: LD_INT 21
83082: PUSH
83083: LD_INT 22
83085: PUSH
83086: LD_INT 23
83088: PUSH
83089: LD_INT 24
83091: PUSH
83092: LD_INT 25
83094: PUSH
83095: LD_INT 26
83097: PUSH
83098: LD_INT 27
83100: PUSH
83101: LD_INT 28
83103: PUSH
83104: LD_INT 30
83106: PUSH
83107: LD_INT 31
83109: PUSH
83110: LD_INT 32
83112: PUSH
83113: LD_INT 33
83115: PUSH
83116: LD_INT 34
83118: PUSH
83119: LD_INT 36
83121: PUSH
83122: EMPTY
83123: LIST
83124: LIST
83125: LIST
83126: LIST
83127: LIST
83128: LIST
83129: LIST
83130: LIST
83131: LIST
83132: LIST
83133: LIST
83134: LIST
83135: LIST
83136: LIST
83137: LIST
83138: LIST
83139: LIST
83140: LIST
83141: LIST
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: LIST
83147: LIST
83148: LIST
83149: LIST
83150: LIST
83151: LIST
83152: LIST
83153: LIST
83154: LIST
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 101
83160: PUSH
83161: LD_INT 102
83163: PUSH
83164: LD_INT 103
83166: PUSH
83167: LD_INT 104
83169: PUSH
83170: LD_INT 105
83172: PUSH
83173: LD_INT 106
83175: PUSH
83176: LD_INT 107
83178: PUSH
83179: LD_INT 108
83181: PUSH
83182: LD_INT 109
83184: PUSH
83185: LD_INT 110
83187: PUSH
83188: LD_INT 111
83190: PUSH
83191: LD_INT 112
83193: PUSH
83194: LD_INT 113
83196: PUSH
83197: LD_INT 114
83199: PUSH
83200: EMPTY
83201: LIST
83202: LIST
83203: LIST
83204: LIST
83205: LIST
83206: LIST
83207: LIST
83208: LIST
83209: LIST
83210: LIST
83211: LIST
83212: LIST
83213: LIST
83214: LIST
83215: PUSH
83216: EMPTY
83217: LIST
83218: LIST
83219: ST_TO_ADDR
83220: GO 84591
83222: LD_INT 13
83224: DOUBLE
83225: EQUAL
83226: IFTRUE 83230
83228: GO 83426
83230: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
83231: LD_ADDR_VAR 0 1
83235: PUSH
83236: LD_INT 1
83238: PUSH
83239: LD_INT 2
83241: PUSH
83242: LD_INT 3
83244: PUSH
83245: LD_INT 4
83247: PUSH
83248: LD_INT 5
83250: PUSH
83251: LD_INT 8
83253: PUSH
83254: LD_INT 9
83256: PUSH
83257: LD_INT 10
83259: PUSH
83260: LD_INT 11
83262: PUSH
83263: LD_INT 12
83265: PUSH
83266: LD_INT 14
83268: PUSH
83269: LD_INT 15
83271: PUSH
83272: LD_INT 16
83274: PUSH
83275: LD_INT 17
83277: PUSH
83278: LD_INT 18
83280: PUSH
83281: LD_INT 19
83283: PUSH
83284: LD_INT 20
83286: PUSH
83287: LD_INT 21
83289: PUSH
83290: LD_INT 22
83292: PUSH
83293: LD_INT 23
83295: PUSH
83296: LD_INT 24
83298: PUSH
83299: LD_INT 25
83301: PUSH
83302: LD_INT 26
83304: PUSH
83305: LD_INT 27
83307: PUSH
83308: LD_INT 28
83310: PUSH
83311: LD_INT 30
83313: PUSH
83314: LD_INT 31
83316: PUSH
83317: LD_INT 32
83319: PUSH
83320: LD_INT 33
83322: PUSH
83323: LD_INT 34
83325: PUSH
83326: LD_INT 36
83328: PUSH
83329: EMPTY
83330: LIST
83331: LIST
83332: LIST
83333: LIST
83334: LIST
83335: LIST
83336: LIST
83337: LIST
83338: LIST
83339: LIST
83340: LIST
83341: LIST
83342: LIST
83343: LIST
83344: LIST
83345: LIST
83346: LIST
83347: LIST
83348: LIST
83349: LIST
83350: LIST
83351: LIST
83352: LIST
83353: LIST
83354: LIST
83355: LIST
83356: LIST
83357: LIST
83358: LIST
83359: LIST
83360: LIST
83361: PUSH
83362: LD_INT 101
83364: PUSH
83365: LD_INT 102
83367: PUSH
83368: LD_INT 103
83370: PUSH
83371: LD_INT 104
83373: PUSH
83374: LD_INT 105
83376: PUSH
83377: LD_INT 106
83379: PUSH
83380: LD_INT 107
83382: PUSH
83383: LD_INT 108
83385: PUSH
83386: LD_INT 109
83388: PUSH
83389: LD_INT 110
83391: PUSH
83392: LD_INT 111
83394: PUSH
83395: LD_INT 112
83397: PUSH
83398: LD_INT 113
83400: PUSH
83401: LD_INT 114
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: LIST
83408: LIST
83409: LIST
83410: LIST
83411: LIST
83412: LIST
83413: LIST
83414: LIST
83415: LIST
83416: LIST
83417: LIST
83418: LIST
83419: PUSH
83420: EMPTY
83421: LIST
83422: LIST
83423: ST_TO_ADDR
83424: GO 84591
83426: LD_INT 14
83428: DOUBLE
83429: EQUAL
83430: IFTRUE 83434
83432: GO 83646
83434: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
83435: LD_ADDR_VAR 0 1
83439: PUSH
83440: LD_INT 1
83442: PUSH
83443: LD_INT 2
83445: PUSH
83446: LD_INT 3
83448: PUSH
83449: LD_INT 4
83451: PUSH
83452: LD_INT 5
83454: PUSH
83455: LD_INT 6
83457: PUSH
83458: LD_INT 7
83460: PUSH
83461: LD_INT 8
83463: PUSH
83464: LD_INT 9
83466: PUSH
83467: LD_INT 10
83469: PUSH
83470: LD_INT 11
83472: PUSH
83473: LD_INT 12
83475: PUSH
83476: LD_INT 13
83478: PUSH
83479: LD_INT 14
83481: PUSH
83482: LD_INT 15
83484: PUSH
83485: LD_INT 16
83487: PUSH
83488: LD_INT 17
83490: PUSH
83491: LD_INT 18
83493: PUSH
83494: LD_INT 19
83496: PUSH
83497: LD_INT 20
83499: PUSH
83500: LD_INT 21
83502: PUSH
83503: LD_INT 22
83505: PUSH
83506: LD_INT 23
83508: PUSH
83509: LD_INT 24
83511: PUSH
83512: LD_INT 25
83514: PUSH
83515: LD_INT 26
83517: PUSH
83518: LD_INT 27
83520: PUSH
83521: LD_INT 28
83523: PUSH
83524: LD_INT 29
83526: PUSH
83527: LD_INT 30
83529: PUSH
83530: LD_INT 31
83532: PUSH
83533: LD_INT 32
83535: PUSH
83536: LD_INT 33
83538: PUSH
83539: LD_INT 34
83541: PUSH
83542: LD_INT 36
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: LIST
83560: LIST
83561: LIST
83562: LIST
83563: LIST
83564: LIST
83565: LIST
83566: LIST
83567: LIST
83568: LIST
83569: LIST
83570: LIST
83571: LIST
83572: LIST
83573: LIST
83574: LIST
83575: LIST
83576: LIST
83577: LIST
83578: LIST
83579: LIST
83580: LIST
83581: PUSH
83582: LD_INT 101
83584: PUSH
83585: LD_INT 102
83587: PUSH
83588: LD_INT 103
83590: PUSH
83591: LD_INT 104
83593: PUSH
83594: LD_INT 105
83596: PUSH
83597: LD_INT 106
83599: PUSH
83600: LD_INT 107
83602: PUSH
83603: LD_INT 108
83605: PUSH
83606: LD_INT 109
83608: PUSH
83609: LD_INT 110
83611: PUSH
83612: LD_INT 111
83614: PUSH
83615: LD_INT 112
83617: PUSH
83618: LD_INT 113
83620: PUSH
83621: LD_INT 114
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: PUSH
83640: EMPTY
83641: LIST
83642: LIST
83643: ST_TO_ADDR
83644: GO 84591
83646: LD_INT 15
83648: DOUBLE
83649: EQUAL
83650: IFTRUE 83654
83652: GO 83866
83654: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
83655: LD_ADDR_VAR 0 1
83659: PUSH
83660: LD_INT 1
83662: PUSH
83663: LD_INT 2
83665: PUSH
83666: LD_INT 3
83668: PUSH
83669: LD_INT 4
83671: PUSH
83672: LD_INT 5
83674: PUSH
83675: LD_INT 6
83677: PUSH
83678: LD_INT 7
83680: PUSH
83681: LD_INT 8
83683: PUSH
83684: LD_INT 9
83686: PUSH
83687: LD_INT 10
83689: PUSH
83690: LD_INT 11
83692: PUSH
83693: LD_INT 12
83695: PUSH
83696: LD_INT 13
83698: PUSH
83699: LD_INT 14
83701: PUSH
83702: LD_INT 15
83704: PUSH
83705: LD_INT 16
83707: PUSH
83708: LD_INT 17
83710: PUSH
83711: LD_INT 18
83713: PUSH
83714: LD_INT 19
83716: PUSH
83717: LD_INT 20
83719: PUSH
83720: LD_INT 21
83722: PUSH
83723: LD_INT 22
83725: PUSH
83726: LD_INT 23
83728: PUSH
83729: LD_INT 24
83731: PUSH
83732: LD_INT 25
83734: PUSH
83735: LD_INT 26
83737: PUSH
83738: LD_INT 27
83740: PUSH
83741: LD_INT 28
83743: PUSH
83744: LD_INT 29
83746: PUSH
83747: LD_INT 30
83749: PUSH
83750: LD_INT 31
83752: PUSH
83753: LD_INT 32
83755: PUSH
83756: LD_INT 33
83758: PUSH
83759: LD_INT 34
83761: PUSH
83762: LD_INT 36
83764: PUSH
83765: EMPTY
83766: LIST
83767: LIST
83768: LIST
83769: LIST
83770: LIST
83771: LIST
83772: LIST
83773: LIST
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: LIST
83782: LIST
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: LIST
83793: LIST
83794: LIST
83795: LIST
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: PUSH
83802: LD_INT 101
83804: PUSH
83805: LD_INT 102
83807: PUSH
83808: LD_INT 103
83810: PUSH
83811: LD_INT 104
83813: PUSH
83814: LD_INT 105
83816: PUSH
83817: LD_INT 106
83819: PUSH
83820: LD_INT 107
83822: PUSH
83823: LD_INT 108
83825: PUSH
83826: LD_INT 109
83828: PUSH
83829: LD_INT 110
83831: PUSH
83832: LD_INT 111
83834: PUSH
83835: LD_INT 112
83837: PUSH
83838: LD_INT 113
83840: PUSH
83841: LD_INT 114
83843: PUSH
83844: EMPTY
83845: LIST
83846: LIST
83847: LIST
83848: LIST
83849: LIST
83850: LIST
83851: LIST
83852: LIST
83853: LIST
83854: LIST
83855: LIST
83856: LIST
83857: LIST
83858: LIST
83859: PUSH
83860: EMPTY
83861: LIST
83862: LIST
83863: ST_TO_ADDR
83864: GO 84591
83866: LD_INT 16
83868: DOUBLE
83869: EQUAL
83870: IFTRUE 83874
83872: GO 83998
83874: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
83875: LD_ADDR_VAR 0 1
83879: PUSH
83880: LD_INT 2
83882: PUSH
83883: LD_INT 4
83885: PUSH
83886: LD_INT 5
83888: PUSH
83889: LD_INT 7
83891: PUSH
83892: LD_INT 11
83894: PUSH
83895: LD_INT 12
83897: PUSH
83898: LD_INT 15
83900: PUSH
83901: LD_INT 16
83903: PUSH
83904: LD_INT 20
83906: PUSH
83907: LD_INT 21
83909: PUSH
83910: LD_INT 22
83912: PUSH
83913: LD_INT 23
83915: PUSH
83916: LD_INT 25
83918: PUSH
83919: LD_INT 26
83921: PUSH
83922: LD_INT 30
83924: PUSH
83925: LD_INT 31
83927: PUSH
83928: LD_INT 32
83930: PUSH
83931: LD_INT 33
83933: PUSH
83934: LD_INT 34
83936: PUSH
83937: EMPTY
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: LIST
83946: LIST
83947: LIST
83948: LIST
83949: LIST
83950: LIST
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: LIST
83956: LIST
83957: PUSH
83958: LD_INT 101
83960: PUSH
83961: LD_INT 102
83963: PUSH
83964: LD_INT 103
83966: PUSH
83967: LD_INT 106
83969: PUSH
83970: LD_INT 108
83972: PUSH
83973: LD_INT 112
83975: PUSH
83976: LD_INT 113
83978: PUSH
83979: LD_INT 114
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: LIST
83986: LIST
83987: LIST
83988: LIST
83989: LIST
83990: LIST
83991: PUSH
83992: EMPTY
83993: LIST
83994: LIST
83995: ST_TO_ADDR
83996: GO 84591
83998: LD_INT 17
84000: DOUBLE
84001: EQUAL
84002: IFTRUE 84006
84004: GO 84218
84006: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
84007: LD_ADDR_VAR 0 1
84011: PUSH
84012: LD_INT 1
84014: PUSH
84015: LD_INT 2
84017: PUSH
84018: LD_INT 3
84020: PUSH
84021: LD_INT 4
84023: PUSH
84024: LD_INT 5
84026: PUSH
84027: LD_INT 6
84029: PUSH
84030: LD_INT 7
84032: PUSH
84033: LD_INT 8
84035: PUSH
84036: LD_INT 9
84038: PUSH
84039: LD_INT 10
84041: PUSH
84042: LD_INT 11
84044: PUSH
84045: LD_INT 12
84047: PUSH
84048: LD_INT 13
84050: PUSH
84051: LD_INT 14
84053: PUSH
84054: LD_INT 15
84056: PUSH
84057: LD_INT 16
84059: PUSH
84060: LD_INT 17
84062: PUSH
84063: LD_INT 18
84065: PUSH
84066: LD_INT 19
84068: PUSH
84069: LD_INT 20
84071: PUSH
84072: LD_INT 21
84074: PUSH
84075: LD_INT 22
84077: PUSH
84078: LD_INT 23
84080: PUSH
84081: LD_INT 24
84083: PUSH
84084: LD_INT 25
84086: PUSH
84087: LD_INT 26
84089: PUSH
84090: LD_INT 27
84092: PUSH
84093: LD_INT 28
84095: PUSH
84096: LD_INT 29
84098: PUSH
84099: LD_INT 30
84101: PUSH
84102: LD_INT 31
84104: PUSH
84105: LD_INT 32
84107: PUSH
84108: LD_INT 33
84110: PUSH
84111: LD_INT 34
84113: PUSH
84114: LD_INT 36
84116: PUSH
84117: EMPTY
84118: LIST
84119: LIST
84120: LIST
84121: LIST
84122: LIST
84123: LIST
84124: LIST
84125: LIST
84126: LIST
84127: LIST
84128: LIST
84129: LIST
84130: LIST
84131: LIST
84132: LIST
84133: LIST
84134: LIST
84135: LIST
84136: LIST
84137: LIST
84138: LIST
84139: LIST
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: LIST
84145: LIST
84146: LIST
84147: LIST
84148: LIST
84149: LIST
84150: LIST
84151: LIST
84152: LIST
84153: PUSH
84154: LD_INT 101
84156: PUSH
84157: LD_INT 102
84159: PUSH
84160: LD_INT 103
84162: PUSH
84163: LD_INT 104
84165: PUSH
84166: LD_INT 105
84168: PUSH
84169: LD_INT 106
84171: PUSH
84172: LD_INT 107
84174: PUSH
84175: LD_INT 108
84177: PUSH
84178: LD_INT 109
84180: PUSH
84181: LD_INT 110
84183: PUSH
84184: LD_INT 111
84186: PUSH
84187: LD_INT 112
84189: PUSH
84190: LD_INT 113
84192: PUSH
84193: LD_INT 114
84195: PUSH
84196: EMPTY
84197: LIST
84198: LIST
84199: LIST
84200: LIST
84201: LIST
84202: LIST
84203: LIST
84204: LIST
84205: LIST
84206: LIST
84207: LIST
84208: LIST
84209: LIST
84210: LIST
84211: PUSH
84212: EMPTY
84213: LIST
84214: LIST
84215: ST_TO_ADDR
84216: GO 84591
84218: LD_INT 18
84220: DOUBLE
84221: EQUAL
84222: IFTRUE 84226
84224: GO 84362
84226: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
84227: LD_ADDR_VAR 0 1
84231: PUSH
84232: LD_INT 2
84234: PUSH
84235: LD_INT 4
84237: PUSH
84238: LD_INT 5
84240: PUSH
84241: LD_INT 7
84243: PUSH
84244: LD_INT 11
84246: PUSH
84247: LD_INT 12
84249: PUSH
84250: LD_INT 15
84252: PUSH
84253: LD_INT 16
84255: PUSH
84256: LD_INT 20
84258: PUSH
84259: LD_INT 21
84261: PUSH
84262: LD_INT 22
84264: PUSH
84265: LD_INT 23
84267: PUSH
84268: LD_INT 25
84270: PUSH
84271: LD_INT 26
84273: PUSH
84274: LD_INT 30
84276: PUSH
84277: LD_INT 31
84279: PUSH
84280: LD_INT 32
84282: PUSH
84283: LD_INT 33
84285: PUSH
84286: LD_INT 34
84288: PUSH
84289: LD_INT 35
84291: PUSH
84292: LD_INT 36
84294: PUSH
84295: EMPTY
84296: LIST
84297: LIST
84298: LIST
84299: LIST
84300: LIST
84301: LIST
84302: LIST
84303: LIST
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: LIST
84317: PUSH
84318: LD_INT 101
84320: PUSH
84321: LD_INT 102
84323: PUSH
84324: LD_INT 103
84326: PUSH
84327: LD_INT 106
84329: PUSH
84330: LD_INT 108
84332: PUSH
84333: LD_INT 112
84335: PUSH
84336: LD_INT 113
84338: PUSH
84339: LD_INT 114
84341: PUSH
84342: LD_INT 115
84344: PUSH
84345: EMPTY
84346: LIST
84347: LIST
84348: LIST
84349: LIST
84350: LIST
84351: LIST
84352: LIST
84353: LIST
84354: LIST
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: ST_TO_ADDR
84360: GO 84591
84362: LD_INT 19
84364: DOUBLE
84365: EQUAL
84366: IFTRUE 84370
84368: GO 84590
84370: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
84371: LD_ADDR_VAR 0 1
84375: PUSH
84376: LD_INT 1
84378: PUSH
84379: LD_INT 2
84381: PUSH
84382: LD_INT 3
84384: PUSH
84385: LD_INT 4
84387: PUSH
84388: LD_INT 5
84390: PUSH
84391: LD_INT 6
84393: PUSH
84394: LD_INT 7
84396: PUSH
84397: LD_INT 8
84399: PUSH
84400: LD_INT 9
84402: PUSH
84403: LD_INT 10
84405: PUSH
84406: LD_INT 11
84408: PUSH
84409: LD_INT 12
84411: PUSH
84412: LD_INT 13
84414: PUSH
84415: LD_INT 14
84417: PUSH
84418: LD_INT 15
84420: PUSH
84421: LD_INT 16
84423: PUSH
84424: LD_INT 17
84426: PUSH
84427: LD_INT 18
84429: PUSH
84430: LD_INT 19
84432: PUSH
84433: LD_INT 20
84435: PUSH
84436: LD_INT 21
84438: PUSH
84439: LD_INT 22
84441: PUSH
84442: LD_INT 23
84444: PUSH
84445: LD_INT 24
84447: PUSH
84448: LD_INT 25
84450: PUSH
84451: LD_INT 26
84453: PUSH
84454: LD_INT 27
84456: PUSH
84457: LD_INT 28
84459: PUSH
84460: LD_INT 29
84462: PUSH
84463: LD_INT 30
84465: PUSH
84466: LD_INT 31
84468: PUSH
84469: LD_INT 32
84471: PUSH
84472: LD_INT 33
84474: PUSH
84475: LD_INT 34
84477: PUSH
84478: LD_INT 35
84480: PUSH
84481: LD_INT 36
84483: PUSH
84484: EMPTY
84485: LIST
84486: LIST
84487: LIST
84488: LIST
84489: LIST
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: LIST
84497: LIST
84498: LIST
84499: LIST
84500: LIST
84501: LIST
84502: LIST
84503: LIST
84504: LIST
84505: LIST
84506: LIST
84507: LIST
84508: LIST
84509: LIST
84510: LIST
84511: LIST
84512: LIST
84513: LIST
84514: LIST
84515: LIST
84516: LIST
84517: LIST
84518: LIST
84519: LIST
84520: LIST
84521: PUSH
84522: LD_INT 101
84524: PUSH
84525: LD_INT 102
84527: PUSH
84528: LD_INT 103
84530: PUSH
84531: LD_INT 104
84533: PUSH
84534: LD_INT 105
84536: PUSH
84537: LD_INT 106
84539: PUSH
84540: LD_INT 107
84542: PUSH
84543: LD_INT 108
84545: PUSH
84546: LD_INT 109
84548: PUSH
84549: LD_INT 110
84551: PUSH
84552: LD_INT 111
84554: PUSH
84555: LD_INT 112
84557: PUSH
84558: LD_INT 113
84560: PUSH
84561: LD_INT 114
84563: PUSH
84564: LD_INT 115
84566: PUSH
84567: EMPTY
84568: LIST
84569: LIST
84570: LIST
84571: LIST
84572: LIST
84573: LIST
84574: LIST
84575: LIST
84576: LIST
84577: LIST
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: PUSH
84584: EMPTY
84585: LIST
84586: LIST
84587: ST_TO_ADDR
84588: GO 84591
84590: POP
// end else
84591: GO 84810
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
84593: LD_ADDR_VAR 0 1
84597: PUSH
84598: LD_INT 1
84600: PUSH
84601: LD_INT 2
84603: PUSH
84604: LD_INT 3
84606: PUSH
84607: LD_INT 4
84609: PUSH
84610: LD_INT 5
84612: PUSH
84613: LD_INT 6
84615: PUSH
84616: LD_INT 7
84618: PUSH
84619: LD_INT 8
84621: PUSH
84622: LD_INT 9
84624: PUSH
84625: LD_INT 10
84627: PUSH
84628: LD_INT 11
84630: PUSH
84631: LD_INT 12
84633: PUSH
84634: LD_INT 13
84636: PUSH
84637: LD_INT 14
84639: PUSH
84640: LD_INT 15
84642: PUSH
84643: LD_INT 16
84645: PUSH
84646: LD_INT 17
84648: PUSH
84649: LD_INT 18
84651: PUSH
84652: LD_INT 19
84654: PUSH
84655: LD_INT 20
84657: PUSH
84658: LD_INT 21
84660: PUSH
84661: LD_INT 22
84663: PUSH
84664: LD_INT 23
84666: PUSH
84667: LD_INT 24
84669: PUSH
84670: LD_INT 25
84672: PUSH
84673: LD_INT 26
84675: PUSH
84676: LD_INT 27
84678: PUSH
84679: LD_INT 28
84681: PUSH
84682: LD_INT 29
84684: PUSH
84685: LD_INT 30
84687: PUSH
84688: LD_INT 31
84690: PUSH
84691: LD_INT 32
84693: PUSH
84694: LD_INT 33
84696: PUSH
84697: LD_INT 34
84699: PUSH
84700: LD_INT 35
84702: PUSH
84703: LD_INT 36
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: LIST
84710: LIST
84711: LIST
84712: LIST
84713: LIST
84714: LIST
84715: LIST
84716: LIST
84717: LIST
84718: LIST
84719: LIST
84720: LIST
84721: LIST
84722: LIST
84723: LIST
84724: LIST
84725: LIST
84726: LIST
84727: LIST
84728: LIST
84729: LIST
84730: LIST
84731: LIST
84732: LIST
84733: LIST
84734: LIST
84735: LIST
84736: LIST
84737: LIST
84738: LIST
84739: LIST
84740: LIST
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 101
84746: PUSH
84747: LD_INT 102
84749: PUSH
84750: LD_INT 103
84752: PUSH
84753: LD_INT 104
84755: PUSH
84756: LD_INT 105
84758: PUSH
84759: LD_INT 106
84761: PUSH
84762: LD_INT 107
84764: PUSH
84765: LD_INT 108
84767: PUSH
84768: LD_INT 109
84770: PUSH
84771: LD_INT 110
84773: PUSH
84774: LD_INT 111
84776: PUSH
84777: LD_INT 112
84779: PUSH
84780: LD_INT 113
84782: PUSH
84783: LD_INT 114
84785: PUSH
84786: LD_INT 115
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: LIST
84793: LIST
84794: LIST
84795: LIST
84796: LIST
84797: LIST
84798: LIST
84799: LIST
84800: LIST
84801: LIST
84802: LIST
84803: LIST
84804: LIST
84805: PUSH
84806: EMPTY
84807: LIST
84808: LIST
84809: ST_TO_ADDR
// if result then
84810: LD_VAR 0 1
84814: IFFALSE 85103
// begin normal :=  ;
84816: LD_ADDR_VAR 0 3
84820: PUSH
84821: LD_STRING 
84823: ST_TO_ADDR
// hardcore :=  ;
84824: LD_ADDR_VAR 0 4
84828: PUSH
84829: LD_STRING 
84831: ST_TO_ADDR
// for i = 1 to normalCounter do
84832: LD_ADDR_VAR 0 5
84836: PUSH
84837: DOUBLE
84838: LD_INT 1
84840: DEC
84841: ST_TO_ADDR
84842: LD_EXP 109
84846: PUSH
84847: FOR_TO
84848: IFFALSE 84949
// begin tmp := 0 ;
84850: LD_ADDR_VAR 0 2
84854: PUSH
84855: LD_STRING 0
84857: ST_TO_ADDR
// if result [ 1 ] then
84858: LD_VAR 0 1
84862: PUSH
84863: LD_INT 1
84865: ARRAY
84866: IFFALSE 84931
// if result [ 1 ] [ 1 ] = i then
84868: LD_VAR 0 1
84872: PUSH
84873: LD_INT 1
84875: ARRAY
84876: PUSH
84877: LD_INT 1
84879: ARRAY
84880: PUSH
84881: LD_VAR 0 5
84885: EQUAL
84886: IFFALSE 84931
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
84888: LD_ADDR_VAR 0 1
84892: PUSH
84893: LD_VAR 0 1
84897: PPUSH
84898: LD_INT 1
84900: PPUSH
84901: LD_VAR 0 1
84905: PUSH
84906: LD_INT 1
84908: ARRAY
84909: PPUSH
84910: LD_INT 1
84912: PPUSH
84913: CALL_OW 3
84917: PPUSH
84918: CALL_OW 1
84922: ST_TO_ADDR
// tmp := 1 ;
84923: LD_ADDR_VAR 0 2
84927: PUSH
84928: LD_STRING 1
84930: ST_TO_ADDR
// end ; normal := normal & tmp ;
84931: LD_ADDR_VAR 0 3
84935: PUSH
84936: LD_VAR 0 3
84940: PUSH
84941: LD_VAR 0 2
84945: STR
84946: ST_TO_ADDR
// end ;
84947: GO 84847
84949: POP
84950: POP
// for i = 1 to hardcoreCounter do
84951: LD_ADDR_VAR 0 5
84955: PUSH
84956: DOUBLE
84957: LD_INT 1
84959: DEC
84960: ST_TO_ADDR
84961: LD_EXP 110
84965: PUSH
84966: FOR_TO
84967: IFFALSE 85072
// begin tmp := 0 ;
84969: LD_ADDR_VAR 0 2
84973: PUSH
84974: LD_STRING 0
84976: ST_TO_ADDR
// if result [ 2 ] then
84977: LD_VAR 0 1
84981: PUSH
84982: LD_INT 2
84984: ARRAY
84985: IFFALSE 85054
// if result [ 2 ] [ 1 ] = 100 + i then
84987: LD_VAR 0 1
84991: PUSH
84992: LD_INT 2
84994: ARRAY
84995: PUSH
84996: LD_INT 1
84998: ARRAY
84999: PUSH
85000: LD_INT 100
85002: PUSH
85003: LD_VAR 0 5
85007: PLUS
85008: EQUAL
85009: IFFALSE 85054
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
85011: LD_ADDR_VAR 0 1
85015: PUSH
85016: LD_VAR 0 1
85020: PPUSH
85021: LD_INT 2
85023: PPUSH
85024: LD_VAR 0 1
85028: PUSH
85029: LD_INT 2
85031: ARRAY
85032: PPUSH
85033: LD_INT 1
85035: PPUSH
85036: CALL_OW 3
85040: PPUSH
85041: CALL_OW 1
85045: ST_TO_ADDR
// tmp := 1 ;
85046: LD_ADDR_VAR 0 2
85050: PUSH
85051: LD_STRING 1
85053: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
85054: LD_ADDR_VAR 0 4
85058: PUSH
85059: LD_VAR 0 4
85063: PUSH
85064: LD_VAR 0 2
85068: STR
85069: ST_TO_ADDR
// end ;
85070: GO 84966
85072: POP
85073: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
85074: LD_STRING getStreamItemsFromMission("
85076: PUSH
85077: LD_VAR 0 3
85081: STR
85082: PUSH
85083: LD_STRING ","
85085: STR
85086: PUSH
85087: LD_VAR 0 4
85091: STR
85092: PUSH
85093: LD_STRING ")
85095: STR
85096: PPUSH
85097: CALL_OW 559
// end else
85101: GO 85110
// ToLua ( getStreamItemsFromMission("","") ) ;
85103: LD_STRING getStreamItemsFromMission("","")
85105: PPUSH
85106: CALL_OW 559
// end ;
85110: LD_VAR 0 1
85114: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
85115: LD_EXP 108
85119: PUSH
85120: LD_EXP 113
85124: AND
85125: IFFALSE 85249
85127: GO 85129
85129: DISABLE
85130: LD_INT 0
85132: PPUSH
85133: PPUSH
// begin enable ;
85134: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
85135: LD_ADDR_VAR 0 2
85139: PUSH
85140: LD_INT 22
85142: PUSH
85143: LD_OWVAR 2
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: PUSH
85152: LD_INT 2
85154: PUSH
85155: LD_INT 34
85157: PUSH
85158: LD_INT 7
85160: PUSH
85161: EMPTY
85162: LIST
85163: LIST
85164: PUSH
85165: LD_INT 34
85167: PUSH
85168: LD_INT 45
85170: PUSH
85171: EMPTY
85172: LIST
85173: LIST
85174: PUSH
85175: LD_INT 34
85177: PUSH
85178: LD_INT 28
85180: PUSH
85181: EMPTY
85182: LIST
85183: LIST
85184: PUSH
85185: LD_INT 34
85187: PUSH
85188: LD_INT 47
85190: PUSH
85191: EMPTY
85192: LIST
85193: LIST
85194: PUSH
85195: EMPTY
85196: LIST
85197: LIST
85198: LIST
85199: LIST
85200: LIST
85201: PUSH
85202: EMPTY
85203: LIST
85204: LIST
85205: PPUSH
85206: CALL_OW 69
85210: ST_TO_ADDR
// if not tmp then
85211: LD_VAR 0 2
85215: NOT
85216: IFFALSE 85220
// exit ;
85218: GO 85249
// for i in tmp do
85220: LD_ADDR_VAR 0 1
85224: PUSH
85225: LD_VAR 0 2
85229: PUSH
85230: FOR_IN
85231: IFFALSE 85247
// begin SetLives ( i , 0 ) ;
85233: LD_VAR 0 1
85237: PPUSH
85238: LD_INT 0
85240: PPUSH
85241: CALL_OW 234
// end ;
85245: GO 85230
85247: POP
85248: POP
// end ;
85249: PPOPN 2
85251: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
85252: LD_EXP 108
85256: PUSH
85257: LD_EXP 114
85261: AND
85262: IFFALSE 85346
85264: GO 85266
85266: DISABLE
85267: LD_INT 0
85269: PPUSH
85270: PPUSH
// begin enable ;
85271: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
85272: LD_ADDR_VAR 0 2
85276: PUSH
85277: LD_INT 22
85279: PUSH
85280: LD_OWVAR 2
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: LD_INT 32
85291: PUSH
85292: LD_INT 3
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: PUSH
85299: EMPTY
85300: LIST
85301: LIST
85302: PPUSH
85303: CALL_OW 69
85307: ST_TO_ADDR
// if not tmp then
85308: LD_VAR 0 2
85312: NOT
85313: IFFALSE 85317
// exit ;
85315: GO 85346
// for i in tmp do
85317: LD_ADDR_VAR 0 1
85321: PUSH
85322: LD_VAR 0 2
85326: PUSH
85327: FOR_IN
85328: IFFALSE 85344
// begin SetLives ( i , 0 ) ;
85330: LD_VAR 0 1
85334: PPUSH
85335: LD_INT 0
85337: PPUSH
85338: CALL_OW 234
// end ;
85342: GO 85327
85344: POP
85345: POP
// end ;
85346: PPOPN 2
85348: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
85349: LD_EXP 108
85353: PUSH
85354: LD_EXP 111
85358: AND
85359: IFFALSE 85452
85361: GO 85363
85363: DISABLE
85364: LD_INT 0
85366: PPUSH
// begin enable ;
85367: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
85368: LD_ADDR_VAR 0 1
85372: PUSH
85373: LD_INT 22
85375: PUSH
85376: LD_OWVAR 2
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: LD_INT 2
85387: PUSH
85388: LD_INT 25
85390: PUSH
85391: LD_INT 5
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: PUSH
85398: LD_INT 25
85400: PUSH
85401: LD_INT 9
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 25
85410: PUSH
85411: LD_INT 8
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: EMPTY
85419: LIST
85420: LIST
85421: LIST
85422: LIST
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PPUSH
85428: CALL_OW 69
85432: PUSH
85433: FOR_IN
85434: IFFALSE 85450
// begin SetClass ( i , 1 ) ;
85436: LD_VAR 0 1
85440: PPUSH
85441: LD_INT 1
85443: PPUSH
85444: CALL_OW 336
// end ;
85448: GO 85433
85450: POP
85451: POP
// end ;
85452: PPOPN 1
85454: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
85455: LD_EXP 108
85459: PUSH
85460: LD_EXP 112
85464: AND
85465: PUSH
85466: LD_OWVAR 65
85470: PUSH
85471: LD_INT 7
85473: LESS
85474: AND
85475: IFFALSE 85489
85477: GO 85479
85479: DISABLE
// begin enable ;
85480: ENABLE
// game_speed := 7 ;
85481: LD_ADDR_OWVAR 65
85485: PUSH
85486: LD_INT 7
85488: ST_TO_ADDR
// end ;
85489: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
85490: LD_EXP 108
85494: PUSH
85495: LD_EXP 115
85499: AND
85500: IFFALSE 85702
85502: GO 85504
85504: DISABLE
85505: LD_INT 0
85507: PPUSH
85508: PPUSH
85509: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
85510: LD_ADDR_VAR 0 3
85514: PUSH
85515: LD_INT 81
85517: PUSH
85518: LD_OWVAR 2
85522: PUSH
85523: EMPTY
85524: LIST
85525: LIST
85526: PUSH
85527: LD_INT 21
85529: PUSH
85530: LD_INT 1
85532: PUSH
85533: EMPTY
85534: LIST
85535: LIST
85536: PUSH
85537: EMPTY
85538: LIST
85539: LIST
85540: PPUSH
85541: CALL_OW 69
85545: ST_TO_ADDR
// if not tmp then
85546: LD_VAR 0 3
85550: NOT
85551: IFFALSE 85555
// exit ;
85553: GO 85702
// if tmp > 5 then
85555: LD_VAR 0 3
85559: PUSH
85560: LD_INT 5
85562: GREATER
85563: IFFALSE 85575
// k := 5 else
85565: LD_ADDR_VAR 0 2
85569: PUSH
85570: LD_INT 5
85572: ST_TO_ADDR
85573: GO 85585
// k := tmp ;
85575: LD_ADDR_VAR 0 2
85579: PUSH
85580: LD_VAR 0 3
85584: ST_TO_ADDR
// for i := 1 to k do
85585: LD_ADDR_VAR 0 1
85589: PUSH
85590: DOUBLE
85591: LD_INT 1
85593: DEC
85594: ST_TO_ADDR
85595: LD_VAR 0 2
85599: PUSH
85600: FOR_TO
85601: IFFALSE 85700
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
85603: LD_VAR 0 3
85607: PUSH
85608: LD_VAR 0 1
85612: ARRAY
85613: PPUSH
85614: LD_VAR 0 1
85618: PUSH
85619: LD_INT 4
85621: MOD
85622: PUSH
85623: LD_INT 1
85625: PLUS
85626: PPUSH
85627: CALL_OW 259
85631: PUSH
85632: LD_INT 10
85634: LESS
85635: IFFALSE 85698
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
85637: LD_VAR 0 3
85641: PUSH
85642: LD_VAR 0 1
85646: ARRAY
85647: PPUSH
85648: LD_VAR 0 1
85652: PUSH
85653: LD_INT 4
85655: MOD
85656: PUSH
85657: LD_INT 1
85659: PLUS
85660: PPUSH
85661: LD_VAR 0 3
85665: PUSH
85666: LD_VAR 0 1
85670: ARRAY
85671: PPUSH
85672: LD_VAR 0 1
85676: PUSH
85677: LD_INT 4
85679: MOD
85680: PUSH
85681: LD_INT 1
85683: PLUS
85684: PPUSH
85685: CALL_OW 259
85689: PUSH
85690: LD_INT 1
85692: PLUS
85693: PPUSH
85694: CALL_OW 237
85698: GO 85600
85700: POP
85701: POP
// end ;
85702: PPOPN 3
85704: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
85705: LD_EXP 108
85709: PUSH
85710: LD_EXP 116
85714: AND
85715: IFFALSE 85735
85717: GO 85719
85719: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
85720: LD_INT 4
85722: PPUSH
85723: LD_OWVAR 2
85727: PPUSH
85728: LD_INT 0
85730: PPUSH
85731: CALL_OW 324
85735: END
// every 0 0$1 trigger StreamModeActive and sShovel do
85736: LD_EXP 108
85740: PUSH
85741: LD_EXP 145
85745: AND
85746: IFFALSE 85766
85748: GO 85750
85750: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
85751: LD_INT 19
85753: PPUSH
85754: LD_OWVAR 2
85758: PPUSH
85759: LD_INT 0
85761: PPUSH
85762: CALL_OW 324
85766: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
85767: LD_EXP 108
85771: PUSH
85772: LD_EXP 117
85776: AND
85777: IFFALSE 85879
85779: GO 85781
85781: DISABLE
85782: LD_INT 0
85784: PPUSH
85785: PPUSH
// begin enable ;
85786: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
85787: LD_ADDR_VAR 0 2
85791: PUSH
85792: LD_INT 22
85794: PUSH
85795: LD_OWVAR 2
85799: PUSH
85800: EMPTY
85801: LIST
85802: LIST
85803: PUSH
85804: LD_INT 2
85806: PUSH
85807: LD_INT 34
85809: PUSH
85810: LD_INT 11
85812: PUSH
85813: EMPTY
85814: LIST
85815: LIST
85816: PUSH
85817: LD_INT 34
85819: PUSH
85820: LD_INT 30
85822: PUSH
85823: EMPTY
85824: LIST
85825: LIST
85826: PUSH
85827: EMPTY
85828: LIST
85829: LIST
85830: LIST
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: PPUSH
85836: CALL_OW 69
85840: ST_TO_ADDR
// if not tmp then
85841: LD_VAR 0 2
85845: NOT
85846: IFFALSE 85850
// exit ;
85848: GO 85879
// for i in tmp do
85850: LD_ADDR_VAR 0 1
85854: PUSH
85855: LD_VAR 0 2
85859: PUSH
85860: FOR_IN
85861: IFFALSE 85877
// begin SetLives ( i , 0 ) ;
85863: LD_VAR 0 1
85867: PPUSH
85868: LD_INT 0
85870: PPUSH
85871: CALL_OW 234
// end ;
85875: GO 85860
85877: POP
85878: POP
// end ;
85879: PPOPN 2
85881: END
// every 0 0$1 trigger StreamModeActive and sBunker do
85882: LD_EXP 108
85886: PUSH
85887: LD_EXP 118
85891: AND
85892: IFFALSE 85912
85894: GO 85896
85896: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
85897: LD_INT 32
85899: PPUSH
85900: LD_OWVAR 2
85904: PPUSH
85905: LD_INT 0
85907: PPUSH
85908: CALL_OW 324
85912: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
85913: LD_EXP 108
85917: PUSH
85918: LD_EXP 119
85922: AND
85923: IFFALSE 86104
85925: GO 85927
85927: DISABLE
85928: LD_INT 0
85930: PPUSH
85931: PPUSH
85932: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
85933: LD_ADDR_VAR 0 2
85937: PUSH
85938: LD_INT 22
85940: PUSH
85941: LD_OWVAR 2
85945: PUSH
85946: EMPTY
85947: LIST
85948: LIST
85949: PUSH
85950: LD_INT 33
85952: PUSH
85953: LD_INT 3
85955: PUSH
85956: EMPTY
85957: LIST
85958: LIST
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: PPUSH
85964: CALL_OW 69
85968: ST_TO_ADDR
// if not tmp then
85969: LD_VAR 0 2
85973: NOT
85974: IFFALSE 85978
// exit ;
85976: GO 86104
// side := 0 ;
85978: LD_ADDR_VAR 0 3
85982: PUSH
85983: LD_INT 0
85985: ST_TO_ADDR
// for i := 1 to 8 do
85986: LD_ADDR_VAR 0 1
85990: PUSH
85991: DOUBLE
85992: LD_INT 1
85994: DEC
85995: ST_TO_ADDR
85996: LD_INT 8
85998: PUSH
85999: FOR_TO
86000: IFFALSE 86048
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
86002: LD_OWVAR 2
86006: PUSH
86007: LD_VAR 0 1
86011: NONEQUAL
86012: PUSH
86013: LD_OWVAR 2
86017: PPUSH
86018: LD_VAR 0 1
86022: PPUSH
86023: CALL_OW 81
86027: PUSH
86028: LD_INT 2
86030: EQUAL
86031: AND
86032: IFFALSE 86046
// begin side := i ;
86034: LD_ADDR_VAR 0 3
86038: PUSH
86039: LD_VAR 0 1
86043: ST_TO_ADDR
// break ;
86044: GO 86048
// end ;
86046: GO 85999
86048: POP
86049: POP
// if not side then
86050: LD_VAR 0 3
86054: NOT
86055: IFFALSE 86059
// exit ;
86057: GO 86104
// for i := 1 to tmp do
86059: LD_ADDR_VAR 0 1
86063: PUSH
86064: DOUBLE
86065: LD_INT 1
86067: DEC
86068: ST_TO_ADDR
86069: LD_VAR 0 2
86073: PUSH
86074: FOR_TO
86075: IFFALSE 86102
// if Prob ( 60 ) then
86077: LD_INT 60
86079: PPUSH
86080: CALL_OW 13
86084: IFFALSE 86100
// SetSide ( i , side ) ;
86086: LD_VAR 0 1
86090: PPUSH
86091: LD_VAR 0 3
86095: PPUSH
86096: CALL_OW 235
86100: GO 86074
86102: POP
86103: POP
// end ;
86104: PPOPN 3
86106: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
86107: LD_EXP 108
86111: PUSH
86112: LD_EXP 121
86116: AND
86117: IFFALSE 86236
86119: GO 86121
86121: DISABLE
86122: LD_INT 0
86124: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
86125: LD_ADDR_VAR 0 1
86129: PUSH
86130: LD_INT 22
86132: PUSH
86133: LD_OWVAR 2
86137: PUSH
86138: EMPTY
86139: LIST
86140: LIST
86141: PUSH
86142: LD_INT 21
86144: PUSH
86145: LD_INT 1
86147: PUSH
86148: EMPTY
86149: LIST
86150: LIST
86151: PUSH
86152: LD_INT 3
86154: PUSH
86155: LD_INT 23
86157: PUSH
86158: LD_INT 0
86160: PUSH
86161: EMPTY
86162: LIST
86163: LIST
86164: PUSH
86165: EMPTY
86166: LIST
86167: LIST
86168: PUSH
86169: EMPTY
86170: LIST
86171: LIST
86172: LIST
86173: PPUSH
86174: CALL_OW 69
86178: PUSH
86179: FOR_IN
86180: IFFALSE 86234
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
86182: LD_VAR 0 1
86186: PPUSH
86187: CALL_OW 257
86191: PUSH
86192: LD_INT 1
86194: PUSH
86195: LD_INT 2
86197: PUSH
86198: LD_INT 3
86200: PUSH
86201: LD_INT 4
86203: PUSH
86204: EMPTY
86205: LIST
86206: LIST
86207: LIST
86208: LIST
86209: IN
86210: IFFALSE 86232
// SetClass ( un , rand ( 1 , 4 ) ) ;
86212: LD_VAR 0 1
86216: PPUSH
86217: LD_INT 1
86219: PPUSH
86220: LD_INT 4
86222: PPUSH
86223: CALL_OW 12
86227: PPUSH
86228: CALL_OW 336
86232: GO 86179
86234: POP
86235: POP
// end ;
86236: PPOPN 1
86238: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
86239: LD_EXP 108
86243: PUSH
86244: LD_EXP 120
86248: AND
86249: IFFALSE 86328
86251: GO 86253
86253: DISABLE
86254: LD_INT 0
86256: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
86257: LD_ADDR_VAR 0 1
86261: PUSH
86262: LD_INT 22
86264: PUSH
86265: LD_OWVAR 2
86269: PUSH
86270: EMPTY
86271: LIST
86272: LIST
86273: PUSH
86274: LD_INT 21
86276: PUSH
86277: LD_INT 3
86279: PUSH
86280: EMPTY
86281: LIST
86282: LIST
86283: PUSH
86284: EMPTY
86285: LIST
86286: LIST
86287: PPUSH
86288: CALL_OW 69
86292: ST_TO_ADDR
// if not tmp then
86293: LD_VAR 0 1
86297: NOT
86298: IFFALSE 86302
// exit ;
86300: GO 86328
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
86302: LD_VAR 0 1
86306: PUSH
86307: LD_INT 1
86309: PPUSH
86310: LD_VAR 0 1
86314: PPUSH
86315: CALL_OW 12
86319: ARRAY
86320: PPUSH
86321: LD_INT 100
86323: PPUSH
86324: CALL_OW 234
// end ;
86328: PPOPN 1
86330: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
86331: LD_EXP 108
86335: PUSH
86336: LD_EXP 122
86340: AND
86341: IFFALSE 86439
86343: GO 86345
86345: DISABLE
86346: LD_INT 0
86348: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
86349: LD_ADDR_VAR 0 1
86353: PUSH
86354: LD_INT 22
86356: PUSH
86357: LD_OWVAR 2
86361: PUSH
86362: EMPTY
86363: LIST
86364: LIST
86365: PUSH
86366: LD_INT 21
86368: PUSH
86369: LD_INT 1
86371: PUSH
86372: EMPTY
86373: LIST
86374: LIST
86375: PUSH
86376: EMPTY
86377: LIST
86378: LIST
86379: PPUSH
86380: CALL_OW 69
86384: ST_TO_ADDR
// if not tmp then
86385: LD_VAR 0 1
86389: NOT
86390: IFFALSE 86394
// exit ;
86392: GO 86439
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
86394: LD_VAR 0 1
86398: PUSH
86399: LD_INT 1
86401: PPUSH
86402: LD_VAR 0 1
86406: PPUSH
86407: CALL_OW 12
86411: ARRAY
86412: PPUSH
86413: LD_INT 1
86415: PPUSH
86416: LD_INT 4
86418: PPUSH
86419: CALL_OW 12
86423: PPUSH
86424: LD_INT 3000
86426: PPUSH
86427: LD_INT 9000
86429: PPUSH
86430: CALL_OW 12
86434: PPUSH
86435: CALL_OW 492
// end ;
86439: PPOPN 1
86441: END
// every 0 0$1 trigger StreamModeActive and sDepot do
86442: LD_EXP 108
86446: PUSH
86447: LD_EXP 123
86451: AND
86452: IFFALSE 86472
86454: GO 86456
86456: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
86457: LD_INT 1
86459: PPUSH
86460: LD_OWVAR 2
86464: PPUSH
86465: LD_INT 0
86467: PPUSH
86468: CALL_OW 324
86472: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
86473: LD_EXP 108
86477: PUSH
86478: LD_EXP 124
86482: AND
86483: IFFALSE 86566
86485: GO 86487
86487: DISABLE
86488: LD_INT 0
86490: PPUSH
86491: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
86492: LD_ADDR_VAR 0 2
86496: PUSH
86497: LD_INT 22
86499: PUSH
86500: LD_OWVAR 2
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 21
86511: PUSH
86512: LD_INT 3
86514: PUSH
86515: EMPTY
86516: LIST
86517: LIST
86518: PUSH
86519: EMPTY
86520: LIST
86521: LIST
86522: PPUSH
86523: CALL_OW 69
86527: ST_TO_ADDR
// if not tmp then
86528: LD_VAR 0 2
86532: NOT
86533: IFFALSE 86537
// exit ;
86535: GO 86566
// for i in tmp do
86537: LD_ADDR_VAR 0 1
86541: PUSH
86542: LD_VAR 0 2
86546: PUSH
86547: FOR_IN
86548: IFFALSE 86564
// SetBLevel ( i , 10 ) ;
86550: LD_VAR 0 1
86554: PPUSH
86555: LD_INT 10
86557: PPUSH
86558: CALL_OW 241
86562: GO 86547
86564: POP
86565: POP
// end ;
86566: PPOPN 2
86568: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
86569: LD_EXP 108
86573: PUSH
86574: LD_EXP 125
86578: AND
86579: IFFALSE 86690
86581: GO 86583
86583: DISABLE
86584: LD_INT 0
86586: PPUSH
86587: PPUSH
86588: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
86589: LD_ADDR_VAR 0 3
86593: PUSH
86594: LD_INT 22
86596: PUSH
86597: LD_OWVAR 2
86601: PUSH
86602: EMPTY
86603: LIST
86604: LIST
86605: PUSH
86606: LD_INT 25
86608: PUSH
86609: LD_INT 1
86611: PUSH
86612: EMPTY
86613: LIST
86614: LIST
86615: PUSH
86616: EMPTY
86617: LIST
86618: LIST
86619: PPUSH
86620: CALL_OW 69
86624: ST_TO_ADDR
// if not tmp then
86625: LD_VAR 0 3
86629: NOT
86630: IFFALSE 86634
// exit ;
86632: GO 86690
// un := tmp [ rand ( 1 , tmp ) ] ;
86634: LD_ADDR_VAR 0 2
86638: PUSH
86639: LD_VAR 0 3
86643: PUSH
86644: LD_INT 1
86646: PPUSH
86647: LD_VAR 0 3
86651: PPUSH
86652: CALL_OW 12
86656: ARRAY
86657: ST_TO_ADDR
// if Crawls ( un ) then
86658: LD_VAR 0 2
86662: PPUSH
86663: CALL_OW 318
86667: IFFALSE 86678
// ComWalk ( un ) ;
86669: LD_VAR 0 2
86673: PPUSH
86674: CALL_OW 138
// SetClass ( un , class_sniper ) ;
86678: LD_VAR 0 2
86682: PPUSH
86683: LD_INT 5
86685: PPUSH
86686: CALL_OW 336
// end ;
86690: PPOPN 3
86692: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
86693: LD_EXP 108
86697: PUSH
86698: LD_EXP 126
86702: AND
86703: PUSH
86704: LD_OWVAR 67
86708: PUSH
86709: LD_INT 3
86711: LESS
86712: AND
86713: IFFALSE 86732
86715: GO 86717
86717: DISABLE
// Difficulty := Difficulty + 1 ;
86718: LD_ADDR_OWVAR 67
86722: PUSH
86723: LD_OWVAR 67
86727: PUSH
86728: LD_INT 1
86730: PLUS
86731: ST_TO_ADDR
86732: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
86733: LD_EXP 108
86737: PUSH
86738: LD_EXP 127
86742: AND
86743: IFFALSE 86846
86745: GO 86747
86747: DISABLE
86748: LD_INT 0
86750: PPUSH
// begin for i := 1 to 5 do
86751: LD_ADDR_VAR 0 1
86755: PUSH
86756: DOUBLE
86757: LD_INT 1
86759: DEC
86760: ST_TO_ADDR
86761: LD_INT 5
86763: PUSH
86764: FOR_TO
86765: IFFALSE 86844
// begin uc_nation := nation_nature ;
86767: LD_ADDR_OWVAR 21
86771: PUSH
86772: LD_INT 0
86774: ST_TO_ADDR
// uc_side := 0 ;
86775: LD_ADDR_OWVAR 20
86779: PUSH
86780: LD_INT 0
86782: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
86783: LD_ADDR_OWVAR 29
86787: PUSH
86788: LD_INT 12
86790: PUSH
86791: LD_INT 12
86793: PUSH
86794: EMPTY
86795: LIST
86796: LIST
86797: ST_TO_ADDR
// hc_agressivity := 20 ;
86798: LD_ADDR_OWVAR 35
86802: PUSH
86803: LD_INT 20
86805: ST_TO_ADDR
// hc_class := class_tiger ;
86806: LD_ADDR_OWVAR 28
86810: PUSH
86811: LD_INT 14
86813: ST_TO_ADDR
// hc_gallery :=  ;
86814: LD_ADDR_OWVAR 33
86818: PUSH
86819: LD_STRING 
86821: ST_TO_ADDR
// hc_name :=  ;
86822: LD_ADDR_OWVAR 26
86826: PUSH
86827: LD_STRING 
86829: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
86830: CALL_OW 44
86834: PPUSH
86835: LD_INT 0
86837: PPUSH
86838: CALL_OW 51
// end ;
86842: GO 86764
86844: POP
86845: POP
// end ;
86846: PPOPN 1
86848: END
// every 0 0$1 trigger StreamModeActive and sBomb do
86849: LD_EXP 108
86853: PUSH
86854: LD_EXP 128
86858: AND
86859: IFFALSE 86868
86861: GO 86863
86863: DISABLE
// StreamSibBomb ;
86864: CALL 86869 0 0
86868: END
// export function StreamSibBomb ; var i , x , y ; begin
86869: LD_INT 0
86871: PPUSH
86872: PPUSH
86873: PPUSH
86874: PPUSH
// result := false ;
86875: LD_ADDR_VAR 0 1
86879: PUSH
86880: LD_INT 0
86882: ST_TO_ADDR
// for i := 1 to 16 do
86883: LD_ADDR_VAR 0 2
86887: PUSH
86888: DOUBLE
86889: LD_INT 1
86891: DEC
86892: ST_TO_ADDR
86893: LD_INT 16
86895: PUSH
86896: FOR_TO
86897: IFFALSE 87096
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
86899: LD_ADDR_VAR 0 3
86903: PUSH
86904: LD_INT 10
86906: PUSH
86907: LD_INT 20
86909: PUSH
86910: LD_INT 30
86912: PUSH
86913: LD_INT 40
86915: PUSH
86916: LD_INT 50
86918: PUSH
86919: LD_INT 60
86921: PUSH
86922: LD_INT 70
86924: PUSH
86925: LD_INT 80
86927: PUSH
86928: LD_INT 90
86930: PUSH
86931: LD_INT 100
86933: PUSH
86934: LD_INT 110
86936: PUSH
86937: LD_INT 120
86939: PUSH
86940: LD_INT 130
86942: PUSH
86943: LD_INT 140
86945: PUSH
86946: LD_INT 150
86948: PUSH
86949: EMPTY
86950: LIST
86951: LIST
86952: LIST
86953: LIST
86954: LIST
86955: LIST
86956: LIST
86957: LIST
86958: LIST
86959: LIST
86960: LIST
86961: LIST
86962: LIST
86963: LIST
86964: LIST
86965: PUSH
86966: LD_INT 1
86968: PPUSH
86969: LD_INT 15
86971: PPUSH
86972: CALL_OW 12
86976: ARRAY
86977: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
86978: LD_ADDR_VAR 0 4
86982: PUSH
86983: LD_INT 10
86985: PUSH
86986: LD_INT 20
86988: PUSH
86989: LD_INT 30
86991: PUSH
86992: LD_INT 40
86994: PUSH
86995: LD_INT 50
86997: PUSH
86998: LD_INT 60
87000: PUSH
87001: LD_INT 70
87003: PUSH
87004: LD_INT 80
87006: PUSH
87007: LD_INT 90
87009: PUSH
87010: LD_INT 100
87012: PUSH
87013: LD_INT 110
87015: PUSH
87016: LD_INT 120
87018: PUSH
87019: LD_INT 130
87021: PUSH
87022: LD_INT 140
87024: PUSH
87025: LD_INT 150
87027: PUSH
87028: EMPTY
87029: LIST
87030: LIST
87031: LIST
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: LIST
87037: LIST
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: PUSH
87045: LD_INT 1
87047: PPUSH
87048: LD_INT 15
87050: PPUSH
87051: CALL_OW 12
87055: ARRAY
87056: ST_TO_ADDR
// if ValidHex ( x , y ) then
87057: LD_VAR 0 3
87061: PPUSH
87062: LD_VAR 0 4
87066: PPUSH
87067: CALL_OW 488
87071: IFFALSE 87094
// begin result := [ x , y ] ;
87073: LD_ADDR_VAR 0 1
87077: PUSH
87078: LD_VAR 0 3
87082: PUSH
87083: LD_VAR 0 4
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: ST_TO_ADDR
// break ;
87092: GO 87096
// end ; end ;
87094: GO 86896
87096: POP
87097: POP
// if result then
87098: LD_VAR 0 1
87102: IFFALSE 87162
// begin ToLua ( playSibBomb() ) ;
87104: LD_STRING playSibBomb()
87106: PPUSH
87107: CALL_OW 559
// wait ( 0 0$14 ) ;
87111: LD_INT 490
87113: PPUSH
87114: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
87118: LD_VAR 0 1
87122: PUSH
87123: LD_INT 1
87125: ARRAY
87126: PPUSH
87127: LD_VAR 0 1
87131: PUSH
87132: LD_INT 2
87134: ARRAY
87135: PPUSH
87136: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
87140: LD_VAR 0 1
87144: PUSH
87145: LD_INT 1
87147: ARRAY
87148: PPUSH
87149: LD_VAR 0 1
87153: PUSH
87154: LD_INT 2
87156: ARRAY
87157: PPUSH
87158: CALL_OW 429
// end ; end ;
87162: LD_VAR 0 1
87166: RET
// every 0 0$1 trigger StreamModeActive and sReset do
87167: LD_EXP 108
87171: PUSH
87172: LD_EXP 130
87176: AND
87177: IFFALSE 87189
87179: GO 87181
87181: DISABLE
// YouLost (  ) ;
87182: LD_STRING 
87184: PPUSH
87185: CALL_OW 104
87189: END
// every 0 0$1 trigger StreamModeActive and sFog do
87190: LD_EXP 108
87194: PUSH
87195: LD_EXP 129
87199: AND
87200: IFFALSE 87214
87202: GO 87204
87204: DISABLE
// FogOff ( your_side ) ;
87205: LD_OWVAR 2
87209: PPUSH
87210: CALL_OW 344
87214: END
// every 0 0$1 trigger StreamModeActive and sSun do
87215: LD_EXP 108
87219: PUSH
87220: LD_EXP 131
87224: AND
87225: IFFALSE 87253
87227: GO 87229
87229: DISABLE
// begin solar_recharge_percent := 0 ;
87230: LD_ADDR_OWVAR 79
87234: PUSH
87235: LD_INT 0
87237: ST_TO_ADDR
// wait ( 5 5$00 ) ;
87238: LD_INT 10500
87240: PPUSH
87241: CALL_OW 67
// solar_recharge_percent := 100 ;
87245: LD_ADDR_OWVAR 79
87249: PUSH
87250: LD_INT 100
87252: ST_TO_ADDR
// end ;
87253: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
87254: LD_EXP 108
87258: PUSH
87259: LD_EXP 132
87263: AND
87264: IFFALSE 87503
87266: GO 87268
87268: DISABLE
87269: LD_INT 0
87271: PPUSH
87272: PPUSH
87273: PPUSH
// begin tmp := [ ] ;
87274: LD_ADDR_VAR 0 3
87278: PUSH
87279: EMPTY
87280: ST_TO_ADDR
// for i := 1 to 6 do
87281: LD_ADDR_VAR 0 1
87285: PUSH
87286: DOUBLE
87287: LD_INT 1
87289: DEC
87290: ST_TO_ADDR
87291: LD_INT 6
87293: PUSH
87294: FOR_TO
87295: IFFALSE 87400
// begin uc_nation := nation_nature ;
87297: LD_ADDR_OWVAR 21
87301: PUSH
87302: LD_INT 0
87304: ST_TO_ADDR
// uc_side := 0 ;
87305: LD_ADDR_OWVAR 20
87309: PUSH
87310: LD_INT 0
87312: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
87313: LD_ADDR_OWVAR 29
87317: PUSH
87318: LD_INT 12
87320: PUSH
87321: LD_INT 12
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: ST_TO_ADDR
// hc_agressivity := 20 ;
87328: LD_ADDR_OWVAR 35
87332: PUSH
87333: LD_INT 20
87335: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
87336: LD_ADDR_OWVAR 28
87340: PUSH
87341: LD_INT 17
87343: ST_TO_ADDR
// hc_gallery :=  ;
87344: LD_ADDR_OWVAR 33
87348: PUSH
87349: LD_STRING 
87351: ST_TO_ADDR
// hc_name :=  ;
87352: LD_ADDR_OWVAR 26
87356: PUSH
87357: LD_STRING 
87359: ST_TO_ADDR
// un := CreateHuman ;
87360: LD_ADDR_VAR 0 2
87364: PUSH
87365: CALL_OW 44
87369: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
87370: LD_VAR 0 2
87374: PPUSH
87375: LD_INT 1
87377: PPUSH
87378: CALL_OW 51
// tmp := tmp ^ un ;
87382: LD_ADDR_VAR 0 3
87386: PUSH
87387: LD_VAR 0 3
87391: PUSH
87392: LD_VAR 0 2
87396: ADD
87397: ST_TO_ADDR
// end ;
87398: GO 87294
87400: POP
87401: POP
// repeat wait ( 0 0$1 ) ;
87402: LD_INT 35
87404: PPUSH
87405: CALL_OW 67
// for un in tmp do
87409: LD_ADDR_VAR 0 2
87413: PUSH
87414: LD_VAR 0 3
87418: PUSH
87419: FOR_IN
87420: IFFALSE 87494
// begin if IsDead ( un ) then
87422: LD_VAR 0 2
87426: PPUSH
87427: CALL_OW 301
87431: IFFALSE 87451
// begin tmp := tmp diff un ;
87433: LD_ADDR_VAR 0 3
87437: PUSH
87438: LD_VAR 0 3
87442: PUSH
87443: LD_VAR 0 2
87447: DIFF
87448: ST_TO_ADDR
// continue ;
87449: GO 87419
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
87451: LD_VAR 0 2
87455: PPUSH
87456: LD_INT 3
87458: PUSH
87459: LD_INT 22
87461: PUSH
87462: LD_INT 0
87464: PUSH
87465: EMPTY
87466: LIST
87467: LIST
87468: PUSH
87469: EMPTY
87470: LIST
87471: LIST
87472: PPUSH
87473: CALL_OW 69
87477: PPUSH
87478: LD_VAR 0 2
87482: PPUSH
87483: CALL_OW 74
87487: PPUSH
87488: CALL_OW 115
// end ;
87492: GO 87419
87494: POP
87495: POP
// until not tmp ;
87496: LD_VAR 0 3
87500: NOT
87501: IFFALSE 87402
// end ;
87503: PPOPN 3
87505: END
// every 0 0$1 trigger StreamModeActive and sTroll do
87506: LD_EXP 108
87510: PUSH
87511: LD_EXP 133
87515: AND
87516: IFFALSE 87570
87518: GO 87520
87520: DISABLE
// begin ToLua ( displayTroll(); ) ;
87521: LD_STRING displayTroll();
87523: PPUSH
87524: CALL_OW 559
// wait ( 3 3$00 ) ;
87528: LD_INT 6300
87530: PPUSH
87531: CALL_OW 67
// ToLua ( hideTroll(); ) ;
87535: LD_STRING hideTroll();
87537: PPUSH
87538: CALL_OW 559
// wait ( 1 1$00 ) ;
87542: LD_INT 2100
87544: PPUSH
87545: CALL_OW 67
// ToLua ( displayTroll(); ) ;
87549: LD_STRING displayTroll();
87551: PPUSH
87552: CALL_OW 559
// wait ( 1 1$00 ) ;
87556: LD_INT 2100
87558: PPUSH
87559: CALL_OW 67
// ToLua ( hideTroll(); ) ;
87563: LD_STRING hideTroll();
87565: PPUSH
87566: CALL_OW 559
// end ;
87570: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
87571: LD_EXP 108
87575: PUSH
87576: LD_EXP 134
87580: AND
87581: IFFALSE 87644
87583: GO 87585
87585: DISABLE
87586: LD_INT 0
87588: PPUSH
// begin p := 0 ;
87589: LD_ADDR_VAR 0 1
87593: PUSH
87594: LD_INT 0
87596: ST_TO_ADDR
// repeat game_speed := 1 ;
87597: LD_ADDR_OWVAR 65
87601: PUSH
87602: LD_INT 1
87604: ST_TO_ADDR
// wait ( 0 0$1 ) ;
87605: LD_INT 35
87607: PPUSH
87608: CALL_OW 67
// p := p + 1 ;
87612: LD_ADDR_VAR 0 1
87616: PUSH
87617: LD_VAR 0 1
87621: PUSH
87622: LD_INT 1
87624: PLUS
87625: ST_TO_ADDR
// until p >= 60 ;
87626: LD_VAR 0 1
87630: PUSH
87631: LD_INT 60
87633: GREATEREQUAL
87634: IFFALSE 87597
// game_speed := 4 ;
87636: LD_ADDR_OWVAR 65
87640: PUSH
87641: LD_INT 4
87643: ST_TO_ADDR
// end ;
87644: PPOPN 1
87646: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
87647: LD_EXP 108
87651: PUSH
87652: LD_EXP 135
87656: AND
87657: IFFALSE 87803
87659: GO 87661
87661: DISABLE
87662: LD_INT 0
87664: PPUSH
87665: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
87666: LD_ADDR_VAR 0 1
87670: PUSH
87671: LD_INT 22
87673: PUSH
87674: LD_OWVAR 2
87678: PUSH
87679: EMPTY
87680: LIST
87681: LIST
87682: PUSH
87683: LD_INT 2
87685: PUSH
87686: LD_INT 30
87688: PUSH
87689: LD_INT 0
87691: PUSH
87692: EMPTY
87693: LIST
87694: LIST
87695: PUSH
87696: LD_INT 30
87698: PUSH
87699: LD_INT 1
87701: PUSH
87702: EMPTY
87703: LIST
87704: LIST
87705: PUSH
87706: EMPTY
87707: LIST
87708: LIST
87709: LIST
87710: PUSH
87711: EMPTY
87712: LIST
87713: LIST
87714: PPUSH
87715: CALL_OW 69
87719: ST_TO_ADDR
// if not depot then
87720: LD_VAR 0 1
87724: NOT
87725: IFFALSE 87729
// exit ;
87727: GO 87803
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
87729: LD_ADDR_VAR 0 2
87733: PUSH
87734: LD_VAR 0 1
87738: PUSH
87739: LD_INT 1
87741: PPUSH
87742: LD_VAR 0 1
87746: PPUSH
87747: CALL_OW 12
87751: ARRAY
87752: PPUSH
87753: CALL_OW 274
87757: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
87758: LD_VAR 0 2
87762: PPUSH
87763: LD_INT 1
87765: PPUSH
87766: LD_INT 0
87768: PPUSH
87769: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
87773: LD_VAR 0 2
87777: PPUSH
87778: LD_INT 2
87780: PPUSH
87781: LD_INT 0
87783: PPUSH
87784: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
87788: LD_VAR 0 2
87792: PPUSH
87793: LD_INT 3
87795: PPUSH
87796: LD_INT 0
87798: PPUSH
87799: CALL_OW 277
// end ;
87803: PPOPN 2
87805: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
87806: LD_EXP 108
87810: PUSH
87811: LD_EXP 136
87815: AND
87816: IFFALSE 87913
87818: GO 87820
87820: DISABLE
87821: LD_INT 0
87823: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
87824: LD_ADDR_VAR 0 1
87828: PUSH
87829: LD_INT 22
87831: PUSH
87832: LD_OWVAR 2
87836: PUSH
87837: EMPTY
87838: LIST
87839: LIST
87840: PUSH
87841: LD_INT 21
87843: PUSH
87844: LD_INT 1
87846: PUSH
87847: EMPTY
87848: LIST
87849: LIST
87850: PUSH
87851: LD_INT 3
87853: PUSH
87854: LD_INT 23
87856: PUSH
87857: LD_INT 0
87859: PUSH
87860: EMPTY
87861: LIST
87862: LIST
87863: PUSH
87864: EMPTY
87865: LIST
87866: LIST
87867: PUSH
87868: EMPTY
87869: LIST
87870: LIST
87871: LIST
87872: PPUSH
87873: CALL_OW 69
87877: ST_TO_ADDR
// if not tmp then
87878: LD_VAR 0 1
87882: NOT
87883: IFFALSE 87887
// exit ;
87885: GO 87913
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
87887: LD_VAR 0 1
87891: PUSH
87892: LD_INT 1
87894: PPUSH
87895: LD_VAR 0 1
87899: PPUSH
87900: CALL_OW 12
87904: ARRAY
87905: PPUSH
87906: LD_INT 200
87908: PPUSH
87909: CALL_OW 234
// end ;
87913: PPOPN 1
87915: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
87916: LD_EXP 108
87920: PUSH
87921: LD_EXP 137
87925: AND
87926: IFFALSE 88005
87928: GO 87930
87930: DISABLE
87931: LD_INT 0
87933: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
87934: LD_ADDR_VAR 0 1
87938: PUSH
87939: LD_INT 22
87941: PUSH
87942: LD_OWVAR 2
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: PUSH
87951: LD_INT 21
87953: PUSH
87954: LD_INT 2
87956: PUSH
87957: EMPTY
87958: LIST
87959: LIST
87960: PUSH
87961: EMPTY
87962: LIST
87963: LIST
87964: PPUSH
87965: CALL_OW 69
87969: ST_TO_ADDR
// if not tmp then
87970: LD_VAR 0 1
87974: NOT
87975: IFFALSE 87979
// exit ;
87977: GO 88005
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
87979: LD_VAR 0 1
87983: PUSH
87984: LD_INT 1
87986: PPUSH
87987: LD_VAR 0 1
87991: PPUSH
87992: CALL_OW 12
87996: ARRAY
87997: PPUSH
87998: LD_INT 60
88000: PPUSH
88001: CALL_OW 234
// end ;
88005: PPOPN 1
88007: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
88008: LD_EXP 108
88012: PUSH
88013: LD_EXP 138
88017: AND
88018: IFFALSE 88117
88020: GO 88022
88022: DISABLE
88023: LD_INT 0
88025: PPUSH
88026: PPUSH
// begin enable ;
88027: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
88028: LD_ADDR_VAR 0 1
88032: PUSH
88033: LD_INT 22
88035: PUSH
88036: LD_OWVAR 2
88040: PUSH
88041: EMPTY
88042: LIST
88043: LIST
88044: PUSH
88045: LD_INT 61
88047: PUSH
88048: EMPTY
88049: LIST
88050: PUSH
88051: LD_INT 33
88053: PUSH
88054: LD_INT 2
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: PUSH
88061: EMPTY
88062: LIST
88063: LIST
88064: LIST
88065: PPUSH
88066: CALL_OW 69
88070: ST_TO_ADDR
// if not tmp then
88071: LD_VAR 0 1
88075: NOT
88076: IFFALSE 88080
// exit ;
88078: GO 88117
// for i in tmp do
88080: LD_ADDR_VAR 0 2
88084: PUSH
88085: LD_VAR 0 1
88089: PUSH
88090: FOR_IN
88091: IFFALSE 88115
// if IsControledBy ( i ) then
88093: LD_VAR 0 2
88097: PPUSH
88098: CALL_OW 312
88102: IFFALSE 88113
// ComUnlink ( i ) ;
88104: LD_VAR 0 2
88108: PPUSH
88109: CALL_OW 136
88113: GO 88090
88115: POP
88116: POP
// end ;
88117: PPOPN 2
88119: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
88120: LD_EXP 108
88124: PUSH
88125: LD_EXP 139
88129: AND
88130: IFFALSE 88270
88132: GO 88134
88134: DISABLE
88135: LD_INT 0
88137: PPUSH
88138: PPUSH
// begin ToLua ( displayPowell(); ) ;
88139: LD_STRING displayPowell();
88141: PPUSH
88142: CALL_OW 559
// uc_side := 0 ;
88146: LD_ADDR_OWVAR 20
88150: PUSH
88151: LD_INT 0
88153: ST_TO_ADDR
// uc_nation := 2 ;
88154: LD_ADDR_OWVAR 21
88158: PUSH
88159: LD_INT 2
88161: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
88162: LD_ADDR_OWVAR 37
88166: PUSH
88167: LD_INT 14
88169: ST_TO_ADDR
// vc_engine := engine_siberite ;
88170: LD_ADDR_OWVAR 39
88174: PUSH
88175: LD_INT 3
88177: ST_TO_ADDR
// vc_control := control_apeman ;
88178: LD_ADDR_OWVAR 38
88182: PUSH
88183: LD_INT 5
88185: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
88186: LD_ADDR_OWVAR 40
88190: PUSH
88191: LD_INT 29
88193: ST_TO_ADDR
// un := CreateVehicle ;
88194: LD_ADDR_VAR 0 2
88198: PUSH
88199: CALL_OW 45
88203: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
88204: LD_VAR 0 2
88208: PPUSH
88209: LD_INT 1
88211: PPUSH
88212: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
88216: LD_INT 35
88218: PPUSH
88219: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
88223: LD_VAR 0 2
88227: PPUSH
88228: LD_INT 22
88230: PUSH
88231: LD_OWVAR 2
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PPUSH
88240: CALL_OW 69
88244: PPUSH
88245: LD_VAR 0 2
88249: PPUSH
88250: CALL_OW 74
88254: PPUSH
88255: CALL_OW 115
// until IsDead ( un ) ;
88259: LD_VAR 0 2
88263: PPUSH
88264: CALL_OW 301
88268: IFFALSE 88216
// end ;
88270: PPOPN 2
88272: END
// every 0 0$1 trigger StreamModeActive and sStu do
88273: LD_EXP 108
88277: PUSH
88278: LD_EXP 147
88282: AND
88283: IFFALSE 88299
88285: GO 88287
88287: DISABLE
// begin ToLua ( displayStucuk(); ) ;
88288: LD_STRING displayStucuk();
88290: PPUSH
88291: CALL_OW 559
// ResetFog ;
88295: CALL_OW 335
// end ;
88299: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
88300: LD_EXP 108
88304: PUSH
88305: LD_EXP 140
88309: AND
88310: IFFALSE 88451
88312: GO 88314
88314: DISABLE
88315: LD_INT 0
88317: PPUSH
88318: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
88319: LD_ADDR_VAR 0 2
88323: PUSH
88324: LD_INT 22
88326: PUSH
88327: LD_OWVAR 2
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: PUSH
88336: LD_INT 21
88338: PUSH
88339: LD_INT 1
88341: PUSH
88342: EMPTY
88343: LIST
88344: LIST
88345: PUSH
88346: EMPTY
88347: LIST
88348: LIST
88349: PPUSH
88350: CALL_OW 69
88354: ST_TO_ADDR
// if not tmp then
88355: LD_VAR 0 2
88359: NOT
88360: IFFALSE 88364
// exit ;
88362: GO 88451
// un := tmp [ rand ( 1 , tmp ) ] ;
88364: LD_ADDR_VAR 0 1
88368: PUSH
88369: LD_VAR 0 2
88373: PUSH
88374: LD_INT 1
88376: PPUSH
88377: LD_VAR 0 2
88381: PPUSH
88382: CALL_OW 12
88386: ARRAY
88387: ST_TO_ADDR
// SetSide ( un , 0 ) ;
88388: LD_VAR 0 1
88392: PPUSH
88393: LD_INT 0
88395: PPUSH
88396: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
88400: LD_VAR 0 1
88404: PPUSH
88405: LD_OWVAR 3
88409: PUSH
88410: LD_VAR 0 1
88414: DIFF
88415: PPUSH
88416: LD_VAR 0 1
88420: PPUSH
88421: CALL_OW 74
88425: PPUSH
88426: CALL_OW 115
// wait ( 0 0$20 ) ;
88430: LD_INT 700
88432: PPUSH
88433: CALL_OW 67
// SetSide ( un , your_side ) ;
88437: LD_VAR 0 1
88441: PPUSH
88442: LD_OWVAR 2
88446: PPUSH
88447: CALL_OW 235
// end ;
88451: PPOPN 2
88453: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
88454: LD_EXP 108
88458: PUSH
88459: LD_EXP 141
88463: AND
88464: IFFALSE 88570
88466: GO 88468
88468: DISABLE
88469: LD_INT 0
88471: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
88472: LD_ADDR_VAR 0 1
88476: PUSH
88477: LD_INT 22
88479: PUSH
88480: LD_OWVAR 2
88484: PUSH
88485: EMPTY
88486: LIST
88487: LIST
88488: PUSH
88489: LD_INT 2
88491: PUSH
88492: LD_INT 30
88494: PUSH
88495: LD_INT 0
88497: PUSH
88498: EMPTY
88499: LIST
88500: LIST
88501: PUSH
88502: LD_INT 30
88504: PUSH
88505: LD_INT 1
88507: PUSH
88508: EMPTY
88509: LIST
88510: LIST
88511: PUSH
88512: EMPTY
88513: LIST
88514: LIST
88515: LIST
88516: PUSH
88517: EMPTY
88518: LIST
88519: LIST
88520: PPUSH
88521: CALL_OW 69
88525: ST_TO_ADDR
// if not depot then
88526: LD_VAR 0 1
88530: NOT
88531: IFFALSE 88535
// exit ;
88533: GO 88570
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
88535: LD_VAR 0 1
88539: PUSH
88540: LD_INT 1
88542: ARRAY
88543: PPUSH
88544: CALL_OW 250
88548: PPUSH
88549: LD_VAR 0 1
88553: PUSH
88554: LD_INT 1
88556: ARRAY
88557: PPUSH
88558: CALL_OW 251
88562: PPUSH
88563: LD_INT 70
88565: PPUSH
88566: CALL_OW 495
// end ;
88570: PPOPN 1
88572: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
88573: LD_EXP 108
88577: PUSH
88578: LD_EXP 142
88582: AND
88583: IFFALSE 88794
88585: GO 88587
88587: DISABLE
88588: LD_INT 0
88590: PPUSH
88591: PPUSH
88592: PPUSH
88593: PPUSH
88594: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
88595: LD_ADDR_VAR 0 5
88599: PUSH
88600: LD_INT 22
88602: PUSH
88603: LD_OWVAR 2
88607: PUSH
88608: EMPTY
88609: LIST
88610: LIST
88611: PUSH
88612: LD_INT 21
88614: PUSH
88615: LD_INT 1
88617: PUSH
88618: EMPTY
88619: LIST
88620: LIST
88621: PUSH
88622: EMPTY
88623: LIST
88624: LIST
88625: PPUSH
88626: CALL_OW 69
88630: ST_TO_ADDR
// if not tmp then
88631: LD_VAR 0 5
88635: NOT
88636: IFFALSE 88640
// exit ;
88638: GO 88794
// for i in tmp do
88640: LD_ADDR_VAR 0 1
88644: PUSH
88645: LD_VAR 0 5
88649: PUSH
88650: FOR_IN
88651: IFFALSE 88792
// begin d := rand ( 0 , 5 ) ;
88653: LD_ADDR_VAR 0 4
88657: PUSH
88658: LD_INT 0
88660: PPUSH
88661: LD_INT 5
88663: PPUSH
88664: CALL_OW 12
88668: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
88669: LD_ADDR_VAR 0 2
88673: PUSH
88674: LD_VAR 0 1
88678: PPUSH
88679: CALL_OW 250
88683: PPUSH
88684: LD_VAR 0 4
88688: PPUSH
88689: LD_INT 3
88691: PPUSH
88692: LD_INT 12
88694: PPUSH
88695: CALL_OW 12
88699: PPUSH
88700: CALL_OW 272
88704: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
88705: LD_ADDR_VAR 0 3
88709: PUSH
88710: LD_VAR 0 1
88714: PPUSH
88715: CALL_OW 251
88719: PPUSH
88720: LD_VAR 0 4
88724: PPUSH
88725: LD_INT 3
88727: PPUSH
88728: LD_INT 12
88730: PPUSH
88731: CALL_OW 12
88735: PPUSH
88736: CALL_OW 273
88740: ST_TO_ADDR
// if ValidHex ( x , y ) then
88741: LD_VAR 0 2
88745: PPUSH
88746: LD_VAR 0 3
88750: PPUSH
88751: CALL_OW 488
88755: IFFALSE 88790
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
88757: LD_VAR 0 1
88761: PPUSH
88762: LD_VAR 0 2
88766: PPUSH
88767: LD_VAR 0 3
88771: PPUSH
88772: LD_INT 3
88774: PPUSH
88775: LD_INT 6
88777: PPUSH
88778: CALL_OW 12
88782: PPUSH
88783: LD_INT 1
88785: PPUSH
88786: CALL_OW 483
// end ;
88790: GO 88650
88792: POP
88793: POP
// end ;
88794: PPOPN 5
88796: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
88797: LD_EXP 108
88801: PUSH
88802: LD_EXP 143
88806: AND
88807: IFFALSE 88901
88809: GO 88811
88811: DISABLE
88812: LD_INT 0
88814: PPUSH
88815: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
88816: LD_ADDR_VAR 0 2
88820: PUSH
88821: LD_INT 22
88823: PUSH
88824: LD_OWVAR 2
88828: PUSH
88829: EMPTY
88830: LIST
88831: LIST
88832: PUSH
88833: LD_INT 32
88835: PUSH
88836: LD_INT 1
88838: PUSH
88839: EMPTY
88840: LIST
88841: LIST
88842: PUSH
88843: LD_INT 21
88845: PUSH
88846: LD_INT 2
88848: PUSH
88849: EMPTY
88850: LIST
88851: LIST
88852: PUSH
88853: EMPTY
88854: LIST
88855: LIST
88856: LIST
88857: PPUSH
88858: CALL_OW 69
88862: ST_TO_ADDR
// if not tmp then
88863: LD_VAR 0 2
88867: NOT
88868: IFFALSE 88872
// exit ;
88870: GO 88901
// for i in tmp do
88872: LD_ADDR_VAR 0 1
88876: PUSH
88877: LD_VAR 0 2
88881: PUSH
88882: FOR_IN
88883: IFFALSE 88899
// SetFuel ( i , 0 ) ;
88885: LD_VAR 0 1
88889: PPUSH
88890: LD_INT 0
88892: PPUSH
88893: CALL_OW 240
88897: GO 88882
88899: POP
88900: POP
// end ;
88901: PPOPN 2
88903: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
88904: LD_EXP 108
88908: PUSH
88909: LD_EXP 144
88913: AND
88914: IFFALSE 88980
88916: GO 88918
88918: DISABLE
88919: LD_INT 0
88921: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
88922: LD_ADDR_VAR 0 1
88926: PUSH
88927: LD_INT 22
88929: PUSH
88930: LD_OWVAR 2
88934: PUSH
88935: EMPTY
88936: LIST
88937: LIST
88938: PUSH
88939: LD_INT 30
88941: PUSH
88942: LD_INT 29
88944: PUSH
88945: EMPTY
88946: LIST
88947: LIST
88948: PUSH
88949: EMPTY
88950: LIST
88951: LIST
88952: PPUSH
88953: CALL_OW 69
88957: ST_TO_ADDR
// if not tmp then
88958: LD_VAR 0 1
88962: NOT
88963: IFFALSE 88967
// exit ;
88965: GO 88980
// DestroyUnit ( tmp [ 1 ] ) ;
88967: LD_VAR 0 1
88971: PUSH
88972: LD_INT 1
88974: ARRAY
88975: PPUSH
88976: CALL_OW 65
// end ;
88980: PPOPN 1
88982: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
88983: LD_EXP 108
88987: PUSH
88988: LD_EXP 146
88992: AND
88993: IFFALSE 89122
88995: GO 88997
88997: DISABLE
88998: LD_INT 0
89000: PPUSH
// begin uc_side := 0 ;
89001: LD_ADDR_OWVAR 20
89005: PUSH
89006: LD_INT 0
89008: ST_TO_ADDR
// uc_nation := nation_arabian ;
89009: LD_ADDR_OWVAR 21
89013: PUSH
89014: LD_INT 2
89016: ST_TO_ADDR
// hc_gallery :=  ;
89017: LD_ADDR_OWVAR 33
89021: PUSH
89022: LD_STRING 
89024: ST_TO_ADDR
// hc_name :=  ;
89025: LD_ADDR_OWVAR 26
89029: PUSH
89030: LD_STRING 
89032: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
89033: LD_INT 1
89035: PPUSH
89036: LD_INT 11
89038: PPUSH
89039: LD_INT 10
89041: PPUSH
89042: CALL_OW 380
// un := CreateHuman ;
89046: LD_ADDR_VAR 0 1
89050: PUSH
89051: CALL_OW 44
89055: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
89056: LD_VAR 0 1
89060: PPUSH
89061: LD_INT 1
89063: PPUSH
89064: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
89068: LD_INT 35
89070: PPUSH
89071: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
89075: LD_VAR 0 1
89079: PPUSH
89080: LD_INT 22
89082: PUSH
89083: LD_OWVAR 2
89087: PUSH
89088: EMPTY
89089: LIST
89090: LIST
89091: PPUSH
89092: CALL_OW 69
89096: PPUSH
89097: LD_VAR 0 1
89101: PPUSH
89102: CALL_OW 74
89106: PPUSH
89107: CALL_OW 115
// until IsDead ( un ) ;
89111: LD_VAR 0 1
89115: PPUSH
89116: CALL_OW 301
89120: IFFALSE 89068
// end ;
89122: PPOPN 1
89124: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
89125: LD_EXP 108
89129: PUSH
89130: LD_EXP 148
89134: AND
89135: IFFALSE 89147
89137: GO 89139
89139: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
89140: LD_STRING earthquake(getX(game), 0, 32)
89142: PPUSH
89143: CALL_OW 559
89147: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
89148: LD_EXP 108
89152: PUSH
89153: LD_EXP 149
89157: AND
89158: IFFALSE 89249
89160: GO 89162
89162: DISABLE
89163: LD_INT 0
89165: PPUSH
// begin enable ;
89166: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
89167: LD_ADDR_VAR 0 1
89171: PUSH
89172: LD_INT 22
89174: PUSH
89175: LD_OWVAR 2
89179: PUSH
89180: EMPTY
89181: LIST
89182: LIST
89183: PUSH
89184: LD_INT 21
89186: PUSH
89187: LD_INT 2
89189: PUSH
89190: EMPTY
89191: LIST
89192: LIST
89193: PUSH
89194: LD_INT 33
89196: PUSH
89197: LD_INT 3
89199: PUSH
89200: EMPTY
89201: LIST
89202: LIST
89203: PUSH
89204: EMPTY
89205: LIST
89206: LIST
89207: LIST
89208: PPUSH
89209: CALL_OW 69
89213: ST_TO_ADDR
// if not tmp then
89214: LD_VAR 0 1
89218: NOT
89219: IFFALSE 89223
// exit ;
89221: GO 89249
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
89223: LD_VAR 0 1
89227: PUSH
89228: LD_INT 1
89230: PPUSH
89231: LD_VAR 0 1
89235: PPUSH
89236: CALL_OW 12
89240: ARRAY
89241: PPUSH
89242: LD_INT 1
89244: PPUSH
89245: CALL_OW 234
// end ;
89249: PPOPN 1
89251: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
89252: LD_EXP 108
89256: PUSH
89257: LD_EXP 150
89261: AND
89262: IFFALSE 89403
89264: GO 89266
89266: DISABLE
89267: LD_INT 0
89269: PPUSH
89270: PPUSH
89271: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
89272: LD_ADDR_VAR 0 3
89276: PUSH
89277: LD_INT 22
89279: PUSH
89280: LD_OWVAR 2
89284: PUSH
89285: EMPTY
89286: LIST
89287: LIST
89288: PUSH
89289: LD_INT 25
89291: PUSH
89292: LD_INT 1
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: PPUSH
89303: CALL_OW 69
89307: ST_TO_ADDR
// if not tmp then
89308: LD_VAR 0 3
89312: NOT
89313: IFFALSE 89317
// exit ;
89315: GO 89403
// un := tmp [ rand ( 1 , tmp ) ] ;
89317: LD_ADDR_VAR 0 2
89321: PUSH
89322: LD_VAR 0 3
89326: PUSH
89327: LD_INT 1
89329: PPUSH
89330: LD_VAR 0 3
89334: PPUSH
89335: CALL_OW 12
89339: ARRAY
89340: ST_TO_ADDR
// if Crawls ( un ) then
89341: LD_VAR 0 2
89345: PPUSH
89346: CALL_OW 318
89350: IFFALSE 89361
// ComWalk ( un ) ;
89352: LD_VAR 0 2
89356: PPUSH
89357: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
89361: LD_VAR 0 2
89365: PPUSH
89366: LD_INT 9
89368: PPUSH
89369: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
89373: LD_INT 28
89375: PPUSH
89376: LD_OWVAR 2
89380: PPUSH
89381: LD_INT 2
89383: PPUSH
89384: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
89388: LD_INT 29
89390: PPUSH
89391: LD_OWVAR 2
89395: PPUSH
89396: LD_INT 2
89398: PPUSH
89399: CALL_OW 322
// end ;
89403: PPOPN 3
89405: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
89406: LD_EXP 108
89410: PUSH
89411: LD_EXP 151
89415: AND
89416: IFFALSE 89527
89418: GO 89420
89420: DISABLE
89421: LD_INT 0
89423: PPUSH
89424: PPUSH
89425: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
89426: LD_ADDR_VAR 0 3
89430: PUSH
89431: LD_INT 22
89433: PUSH
89434: LD_OWVAR 2
89438: PUSH
89439: EMPTY
89440: LIST
89441: LIST
89442: PUSH
89443: LD_INT 25
89445: PUSH
89446: LD_INT 1
89448: PUSH
89449: EMPTY
89450: LIST
89451: LIST
89452: PUSH
89453: EMPTY
89454: LIST
89455: LIST
89456: PPUSH
89457: CALL_OW 69
89461: ST_TO_ADDR
// if not tmp then
89462: LD_VAR 0 3
89466: NOT
89467: IFFALSE 89471
// exit ;
89469: GO 89527
// un := tmp [ rand ( 1 , tmp ) ] ;
89471: LD_ADDR_VAR 0 2
89475: PUSH
89476: LD_VAR 0 3
89480: PUSH
89481: LD_INT 1
89483: PPUSH
89484: LD_VAR 0 3
89488: PPUSH
89489: CALL_OW 12
89493: ARRAY
89494: ST_TO_ADDR
// if Crawls ( un ) then
89495: LD_VAR 0 2
89499: PPUSH
89500: CALL_OW 318
89504: IFFALSE 89515
// ComWalk ( un ) ;
89506: LD_VAR 0 2
89510: PPUSH
89511: CALL_OW 138
// SetClass ( un , class_mortar ) ;
89515: LD_VAR 0 2
89519: PPUSH
89520: LD_INT 8
89522: PPUSH
89523: CALL_OW 336
// end ;
89527: PPOPN 3
89529: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
89530: LD_EXP 108
89534: PUSH
89535: LD_EXP 152
89539: AND
89540: IFFALSE 89684
89542: GO 89544
89544: DISABLE
89545: LD_INT 0
89547: PPUSH
89548: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
89549: LD_ADDR_VAR 0 2
89553: PUSH
89554: LD_INT 22
89556: PUSH
89557: LD_OWVAR 2
89561: PUSH
89562: EMPTY
89563: LIST
89564: LIST
89565: PUSH
89566: LD_INT 21
89568: PUSH
89569: LD_INT 2
89571: PUSH
89572: EMPTY
89573: LIST
89574: LIST
89575: PUSH
89576: LD_INT 2
89578: PUSH
89579: LD_INT 34
89581: PUSH
89582: LD_INT 12
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: PUSH
89589: LD_INT 34
89591: PUSH
89592: LD_INT 51
89594: PUSH
89595: EMPTY
89596: LIST
89597: LIST
89598: PUSH
89599: LD_INT 34
89601: PUSH
89602: LD_INT 32
89604: PUSH
89605: EMPTY
89606: LIST
89607: LIST
89608: PUSH
89609: EMPTY
89610: LIST
89611: LIST
89612: LIST
89613: LIST
89614: PUSH
89615: EMPTY
89616: LIST
89617: LIST
89618: LIST
89619: PPUSH
89620: CALL_OW 69
89624: ST_TO_ADDR
// if not tmp then
89625: LD_VAR 0 2
89629: NOT
89630: IFFALSE 89634
// exit ;
89632: GO 89684
// for i in tmp do
89634: LD_ADDR_VAR 0 1
89638: PUSH
89639: LD_VAR 0 2
89643: PUSH
89644: FOR_IN
89645: IFFALSE 89682
// if GetCargo ( i , mat_artifact ) = 0 then
89647: LD_VAR 0 1
89651: PPUSH
89652: LD_INT 4
89654: PPUSH
89655: CALL_OW 289
89659: PUSH
89660: LD_INT 0
89662: EQUAL
89663: IFFALSE 89680
// SetCargo ( i , mat_siberit , 100 ) ;
89665: LD_VAR 0 1
89669: PPUSH
89670: LD_INT 3
89672: PPUSH
89673: LD_INT 100
89675: PPUSH
89676: CALL_OW 290
89680: GO 89644
89682: POP
89683: POP
// end ;
89684: PPOPN 2
89686: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
89687: LD_EXP 108
89691: PUSH
89692: LD_EXP 153
89696: AND
89697: IFFALSE 89880
89699: GO 89701
89701: DISABLE
89702: LD_INT 0
89704: PPUSH
89705: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
89706: LD_ADDR_VAR 0 2
89710: PUSH
89711: LD_INT 22
89713: PUSH
89714: LD_OWVAR 2
89718: PUSH
89719: EMPTY
89720: LIST
89721: LIST
89722: PPUSH
89723: CALL_OW 69
89727: ST_TO_ADDR
// if not tmp then
89728: LD_VAR 0 2
89732: NOT
89733: IFFALSE 89737
// exit ;
89735: GO 89880
// for i := 1 to 2 do
89737: LD_ADDR_VAR 0 1
89741: PUSH
89742: DOUBLE
89743: LD_INT 1
89745: DEC
89746: ST_TO_ADDR
89747: LD_INT 2
89749: PUSH
89750: FOR_TO
89751: IFFALSE 89878
// begin uc_side := your_side ;
89753: LD_ADDR_OWVAR 20
89757: PUSH
89758: LD_OWVAR 2
89762: ST_TO_ADDR
// uc_nation := nation_american ;
89763: LD_ADDR_OWVAR 21
89767: PUSH
89768: LD_INT 1
89770: ST_TO_ADDR
// vc_chassis := us_morphling ;
89771: LD_ADDR_OWVAR 37
89775: PUSH
89776: LD_INT 5
89778: ST_TO_ADDR
// vc_engine := engine_siberite ;
89779: LD_ADDR_OWVAR 39
89783: PUSH
89784: LD_INT 3
89786: ST_TO_ADDR
// vc_control := control_computer ;
89787: LD_ADDR_OWVAR 38
89791: PUSH
89792: LD_INT 3
89794: ST_TO_ADDR
// vc_weapon := us_double_laser ;
89795: LD_ADDR_OWVAR 40
89799: PUSH
89800: LD_INT 10
89802: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
89803: LD_VAR 0 2
89807: PUSH
89808: LD_INT 1
89810: ARRAY
89811: PPUSH
89812: CALL_OW 310
89816: NOT
89817: IFFALSE 89864
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
89819: CALL_OW 45
89823: PPUSH
89824: LD_VAR 0 2
89828: PUSH
89829: LD_INT 1
89831: ARRAY
89832: PPUSH
89833: CALL_OW 250
89837: PPUSH
89838: LD_VAR 0 2
89842: PUSH
89843: LD_INT 1
89845: ARRAY
89846: PPUSH
89847: CALL_OW 251
89851: PPUSH
89852: LD_INT 12
89854: PPUSH
89855: LD_INT 1
89857: PPUSH
89858: CALL_OW 50
89862: GO 89876
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
89864: CALL_OW 45
89868: PPUSH
89869: LD_INT 1
89871: PPUSH
89872: CALL_OW 51
// end ;
89876: GO 89750
89878: POP
89879: POP
// end ;
89880: PPOPN 2
89882: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
89883: LD_EXP 108
89887: PUSH
89888: LD_EXP 154
89892: AND
89893: IFFALSE 90115
89895: GO 89897
89897: DISABLE
89898: LD_INT 0
89900: PPUSH
89901: PPUSH
89902: PPUSH
89903: PPUSH
89904: PPUSH
89905: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
89906: LD_ADDR_VAR 0 6
89910: PUSH
89911: LD_INT 22
89913: PUSH
89914: LD_OWVAR 2
89918: PUSH
89919: EMPTY
89920: LIST
89921: LIST
89922: PUSH
89923: LD_INT 21
89925: PUSH
89926: LD_INT 1
89928: PUSH
89929: EMPTY
89930: LIST
89931: LIST
89932: PUSH
89933: LD_INT 3
89935: PUSH
89936: LD_INT 23
89938: PUSH
89939: LD_INT 0
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: PUSH
89946: EMPTY
89947: LIST
89948: LIST
89949: PUSH
89950: EMPTY
89951: LIST
89952: LIST
89953: LIST
89954: PPUSH
89955: CALL_OW 69
89959: ST_TO_ADDR
// if not tmp then
89960: LD_VAR 0 6
89964: NOT
89965: IFFALSE 89969
// exit ;
89967: GO 90115
// s1 := rand ( 1 , 4 ) ;
89969: LD_ADDR_VAR 0 2
89973: PUSH
89974: LD_INT 1
89976: PPUSH
89977: LD_INT 4
89979: PPUSH
89980: CALL_OW 12
89984: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
89985: LD_ADDR_VAR 0 4
89989: PUSH
89990: LD_VAR 0 6
89994: PUSH
89995: LD_INT 1
89997: ARRAY
89998: PPUSH
89999: LD_VAR 0 2
90003: PPUSH
90004: CALL_OW 259
90008: ST_TO_ADDR
// if s1 = 1 then
90009: LD_VAR 0 2
90013: PUSH
90014: LD_INT 1
90016: EQUAL
90017: IFFALSE 90037
// s2 := rand ( 2 , 4 ) else
90019: LD_ADDR_VAR 0 3
90023: PUSH
90024: LD_INT 2
90026: PPUSH
90027: LD_INT 4
90029: PPUSH
90030: CALL_OW 12
90034: ST_TO_ADDR
90035: GO 90045
// s2 := 1 ;
90037: LD_ADDR_VAR 0 3
90041: PUSH
90042: LD_INT 1
90044: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
90045: LD_ADDR_VAR 0 5
90049: PUSH
90050: LD_VAR 0 6
90054: PUSH
90055: LD_INT 1
90057: ARRAY
90058: PPUSH
90059: LD_VAR 0 3
90063: PPUSH
90064: CALL_OW 259
90068: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
90069: LD_VAR 0 6
90073: PUSH
90074: LD_INT 1
90076: ARRAY
90077: PPUSH
90078: LD_VAR 0 2
90082: PPUSH
90083: LD_VAR 0 5
90087: PPUSH
90088: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
90092: LD_VAR 0 6
90096: PUSH
90097: LD_INT 1
90099: ARRAY
90100: PPUSH
90101: LD_VAR 0 3
90105: PPUSH
90106: LD_VAR 0 4
90110: PPUSH
90111: CALL_OW 237
// end ;
90115: PPOPN 6
90117: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
90118: LD_EXP 108
90122: PUSH
90123: LD_EXP 155
90127: AND
90128: IFFALSE 90207
90130: GO 90132
90132: DISABLE
90133: LD_INT 0
90135: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
90136: LD_ADDR_VAR 0 1
90140: PUSH
90141: LD_INT 22
90143: PUSH
90144: LD_OWVAR 2
90148: PUSH
90149: EMPTY
90150: LIST
90151: LIST
90152: PUSH
90153: LD_INT 30
90155: PUSH
90156: LD_INT 3
90158: PUSH
90159: EMPTY
90160: LIST
90161: LIST
90162: PUSH
90163: EMPTY
90164: LIST
90165: LIST
90166: PPUSH
90167: CALL_OW 69
90171: ST_TO_ADDR
// if not tmp then
90172: LD_VAR 0 1
90176: NOT
90177: IFFALSE 90181
// exit ;
90179: GO 90207
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
90181: LD_VAR 0 1
90185: PUSH
90186: LD_INT 1
90188: PPUSH
90189: LD_VAR 0 1
90193: PPUSH
90194: CALL_OW 12
90198: ARRAY
90199: PPUSH
90200: LD_INT 1
90202: PPUSH
90203: CALL_OW 234
// end ;
90207: PPOPN 1
90209: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
90210: LD_EXP 108
90214: PUSH
90215: LD_EXP 156
90219: AND
90220: IFFALSE 90332
90222: GO 90224
90224: DISABLE
90225: LD_INT 0
90227: PPUSH
90228: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
90229: LD_ADDR_VAR 0 2
90233: PUSH
90234: LD_INT 22
90236: PUSH
90237: LD_OWVAR 2
90241: PUSH
90242: EMPTY
90243: LIST
90244: LIST
90245: PUSH
90246: LD_INT 2
90248: PUSH
90249: LD_INT 30
90251: PUSH
90252: LD_INT 27
90254: PUSH
90255: EMPTY
90256: LIST
90257: LIST
90258: PUSH
90259: LD_INT 30
90261: PUSH
90262: LD_INT 26
90264: PUSH
90265: EMPTY
90266: LIST
90267: LIST
90268: PUSH
90269: LD_INT 30
90271: PUSH
90272: LD_INT 28
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: PUSH
90279: EMPTY
90280: LIST
90281: LIST
90282: LIST
90283: LIST
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: PPUSH
90289: CALL_OW 69
90293: ST_TO_ADDR
// if not tmp then
90294: LD_VAR 0 2
90298: NOT
90299: IFFALSE 90303
// exit ;
90301: GO 90332
// for i in tmp do
90303: LD_ADDR_VAR 0 1
90307: PUSH
90308: LD_VAR 0 2
90312: PUSH
90313: FOR_IN
90314: IFFALSE 90330
// SetLives ( i , 1 ) ;
90316: LD_VAR 0 1
90320: PPUSH
90321: LD_INT 1
90323: PPUSH
90324: CALL_OW 234
90328: GO 90313
90330: POP
90331: POP
// end ;
90332: PPOPN 2
90334: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
90335: LD_EXP 108
90339: PUSH
90340: LD_EXP 157
90344: AND
90345: IFFALSE 90619
90347: GO 90349
90349: DISABLE
90350: LD_INT 0
90352: PPUSH
90353: PPUSH
90354: PPUSH
// begin i := rand ( 1 , 7 ) ;
90355: LD_ADDR_VAR 0 1
90359: PUSH
90360: LD_INT 1
90362: PPUSH
90363: LD_INT 7
90365: PPUSH
90366: CALL_OW 12
90370: ST_TO_ADDR
// case i of 1 :
90371: LD_VAR 0 1
90375: PUSH
90376: LD_INT 1
90378: DOUBLE
90379: EQUAL
90380: IFTRUE 90384
90382: GO 90394
90384: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
90385: LD_STRING earthquake(getX(game), 0, 32)
90387: PPUSH
90388: CALL_OW 559
90392: GO 90619
90394: LD_INT 2
90396: DOUBLE
90397: EQUAL
90398: IFTRUE 90402
90400: GO 90416
90402: POP
// begin ToLua ( displayStucuk(); ) ;
90403: LD_STRING displayStucuk();
90405: PPUSH
90406: CALL_OW 559
// ResetFog ;
90410: CALL_OW 335
// end ; 3 :
90414: GO 90619
90416: LD_INT 3
90418: DOUBLE
90419: EQUAL
90420: IFTRUE 90424
90422: GO 90528
90424: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90425: LD_ADDR_VAR 0 2
90429: PUSH
90430: LD_INT 22
90432: PUSH
90433: LD_OWVAR 2
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 25
90444: PUSH
90445: LD_INT 1
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PUSH
90452: EMPTY
90453: LIST
90454: LIST
90455: PPUSH
90456: CALL_OW 69
90460: ST_TO_ADDR
// if not tmp then
90461: LD_VAR 0 2
90465: NOT
90466: IFFALSE 90470
// exit ;
90468: GO 90619
// un := tmp [ rand ( 1 , tmp ) ] ;
90470: LD_ADDR_VAR 0 3
90474: PUSH
90475: LD_VAR 0 2
90479: PUSH
90480: LD_INT 1
90482: PPUSH
90483: LD_VAR 0 2
90487: PPUSH
90488: CALL_OW 12
90492: ARRAY
90493: ST_TO_ADDR
// if Crawls ( un ) then
90494: LD_VAR 0 3
90498: PPUSH
90499: CALL_OW 318
90503: IFFALSE 90514
// ComWalk ( un ) ;
90505: LD_VAR 0 3
90509: PPUSH
90510: CALL_OW 138
// SetClass ( un , class_mortar ) ;
90514: LD_VAR 0 3
90518: PPUSH
90519: LD_INT 8
90521: PPUSH
90522: CALL_OW 336
// end ; 4 :
90526: GO 90619
90528: LD_INT 4
90530: DOUBLE
90531: EQUAL
90532: IFTRUE 90536
90534: GO 90597
90536: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
90537: LD_ADDR_VAR 0 2
90541: PUSH
90542: LD_INT 22
90544: PUSH
90545: LD_OWVAR 2
90549: PUSH
90550: EMPTY
90551: LIST
90552: LIST
90553: PUSH
90554: LD_INT 30
90556: PUSH
90557: LD_INT 29
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: PUSH
90564: EMPTY
90565: LIST
90566: LIST
90567: PPUSH
90568: CALL_OW 69
90572: ST_TO_ADDR
// if not tmp then
90573: LD_VAR 0 2
90577: NOT
90578: IFFALSE 90582
// exit ;
90580: GO 90619
// DestroyUnit ( tmp [ 1 ] ) ;
90582: LD_VAR 0 2
90586: PUSH
90587: LD_INT 1
90589: ARRAY
90590: PPUSH
90591: CALL_OW 65
// end ; 5 .. 7 :
90595: GO 90619
90597: LD_INT 5
90599: DOUBLE
90600: GREATEREQUAL
90601: IFFALSE 90609
90603: LD_INT 7
90605: DOUBLE
90606: LESSEQUAL
90607: IFTRUE 90611
90609: GO 90618
90611: POP
// StreamSibBomb ; end ;
90612: CALL 86869 0 0
90616: GO 90619
90618: POP
// end ;
90619: PPOPN 3
90621: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
90622: LD_EXP 108
90626: PUSH
90627: LD_EXP 158
90631: AND
90632: IFFALSE 90788
90634: GO 90636
90636: DISABLE
90637: LD_INT 0
90639: PPUSH
90640: PPUSH
90641: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
90642: LD_ADDR_VAR 0 2
90646: PUSH
90647: LD_INT 81
90649: PUSH
90650: LD_OWVAR 2
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: PUSH
90659: LD_INT 2
90661: PUSH
90662: LD_INT 21
90664: PUSH
90665: LD_INT 1
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 21
90674: PUSH
90675: LD_INT 2
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: LIST
90686: PUSH
90687: EMPTY
90688: LIST
90689: LIST
90690: PPUSH
90691: CALL_OW 69
90695: ST_TO_ADDR
// if not tmp then
90696: LD_VAR 0 2
90700: NOT
90701: IFFALSE 90705
// exit ;
90703: GO 90788
// p := 0 ;
90705: LD_ADDR_VAR 0 3
90709: PUSH
90710: LD_INT 0
90712: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
90713: LD_INT 35
90715: PPUSH
90716: CALL_OW 67
// p := p + 1 ;
90720: LD_ADDR_VAR 0 3
90724: PUSH
90725: LD_VAR 0 3
90729: PUSH
90730: LD_INT 1
90732: PLUS
90733: ST_TO_ADDR
// for i in tmp do
90734: LD_ADDR_VAR 0 1
90738: PUSH
90739: LD_VAR 0 2
90743: PUSH
90744: FOR_IN
90745: IFFALSE 90776
// if GetLives ( i ) < 1000 then
90747: LD_VAR 0 1
90751: PPUSH
90752: CALL_OW 256
90756: PUSH
90757: LD_INT 1000
90759: LESS
90760: IFFALSE 90774
// SetLives ( i , 1000 ) ;
90762: LD_VAR 0 1
90766: PPUSH
90767: LD_INT 1000
90769: PPUSH
90770: CALL_OW 234
90774: GO 90744
90776: POP
90777: POP
// until p > 20 ;
90778: LD_VAR 0 3
90782: PUSH
90783: LD_INT 20
90785: GREATER
90786: IFFALSE 90713
// end ;
90788: PPOPN 3
90790: END
// every 0 0$1 trigger StreamModeActive and sTime do
90791: LD_EXP 108
90795: PUSH
90796: LD_EXP 159
90800: AND
90801: IFFALSE 90836
90803: GO 90805
90805: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
90806: LD_INT 28
90808: PPUSH
90809: LD_OWVAR 2
90813: PPUSH
90814: LD_INT 2
90816: PPUSH
90817: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
90821: LD_INT 30
90823: PPUSH
90824: LD_OWVAR 2
90828: PPUSH
90829: LD_INT 2
90831: PPUSH
90832: CALL_OW 322
// end ;
90836: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
90837: LD_EXP 108
90841: PUSH
90842: LD_EXP 160
90846: AND
90847: IFFALSE 90968
90849: GO 90851
90851: DISABLE
90852: LD_INT 0
90854: PPUSH
90855: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
90856: LD_ADDR_VAR 0 2
90860: PUSH
90861: LD_INT 22
90863: PUSH
90864: LD_OWVAR 2
90868: PUSH
90869: EMPTY
90870: LIST
90871: LIST
90872: PUSH
90873: LD_INT 21
90875: PUSH
90876: LD_INT 1
90878: PUSH
90879: EMPTY
90880: LIST
90881: LIST
90882: PUSH
90883: LD_INT 3
90885: PUSH
90886: LD_INT 23
90888: PUSH
90889: LD_INT 0
90891: PUSH
90892: EMPTY
90893: LIST
90894: LIST
90895: PUSH
90896: EMPTY
90897: LIST
90898: LIST
90899: PUSH
90900: EMPTY
90901: LIST
90902: LIST
90903: LIST
90904: PPUSH
90905: CALL_OW 69
90909: ST_TO_ADDR
// if not tmp then
90910: LD_VAR 0 2
90914: NOT
90915: IFFALSE 90919
// exit ;
90917: GO 90968
// for i in tmp do
90919: LD_ADDR_VAR 0 1
90923: PUSH
90924: LD_VAR 0 2
90928: PUSH
90929: FOR_IN
90930: IFFALSE 90966
// begin if Crawls ( i ) then
90932: LD_VAR 0 1
90936: PPUSH
90937: CALL_OW 318
90941: IFFALSE 90952
// ComWalk ( i ) ;
90943: LD_VAR 0 1
90947: PPUSH
90948: CALL_OW 138
// SetClass ( i , 2 ) ;
90952: LD_VAR 0 1
90956: PPUSH
90957: LD_INT 2
90959: PPUSH
90960: CALL_OW 336
// end ;
90964: GO 90929
90966: POP
90967: POP
// end ;
90968: PPOPN 2
90970: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
90971: LD_EXP 108
90975: PUSH
90976: LD_EXP 161
90980: AND
90981: IFFALSE 91262
90983: GO 90985
90985: DISABLE
90986: LD_INT 0
90988: PPUSH
90989: PPUSH
90990: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
90991: LD_OWVAR 2
90995: PPUSH
90996: LD_INT 9
90998: PPUSH
90999: LD_INT 1
91001: PPUSH
91002: LD_INT 1
91004: PPUSH
91005: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
91009: LD_INT 9
91011: PPUSH
91012: LD_OWVAR 2
91016: PPUSH
91017: CALL_OW 343
// uc_side := 9 ;
91021: LD_ADDR_OWVAR 20
91025: PUSH
91026: LD_INT 9
91028: ST_TO_ADDR
// uc_nation := 2 ;
91029: LD_ADDR_OWVAR 21
91033: PUSH
91034: LD_INT 2
91036: ST_TO_ADDR
// hc_name := Dark Warrior ;
91037: LD_ADDR_OWVAR 26
91041: PUSH
91042: LD_STRING Dark Warrior
91044: ST_TO_ADDR
// hc_gallery :=  ;
91045: LD_ADDR_OWVAR 33
91049: PUSH
91050: LD_STRING 
91052: ST_TO_ADDR
// hc_noskilllimit := true ;
91053: LD_ADDR_OWVAR 76
91057: PUSH
91058: LD_INT 1
91060: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
91061: LD_ADDR_OWVAR 31
91065: PUSH
91066: LD_INT 30
91068: PUSH
91069: LD_INT 30
91071: PUSH
91072: LD_INT 30
91074: PUSH
91075: LD_INT 30
91077: PUSH
91078: EMPTY
91079: LIST
91080: LIST
91081: LIST
91082: LIST
91083: ST_TO_ADDR
// un := CreateHuman ;
91084: LD_ADDR_VAR 0 3
91088: PUSH
91089: CALL_OW 44
91093: ST_TO_ADDR
// hc_noskilllimit := false ;
91094: LD_ADDR_OWVAR 76
91098: PUSH
91099: LD_INT 0
91101: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91102: LD_VAR 0 3
91106: PPUSH
91107: LD_INT 1
91109: PPUSH
91110: CALL_OW 51
// p := 0 ;
91114: LD_ADDR_VAR 0 2
91118: PUSH
91119: LD_INT 0
91121: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
91122: LD_INT 35
91124: PPUSH
91125: CALL_OW 67
// p := p + 1 ;
91129: LD_ADDR_VAR 0 2
91133: PUSH
91134: LD_VAR 0 2
91138: PUSH
91139: LD_INT 1
91141: PLUS
91142: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
91143: LD_VAR 0 3
91147: PPUSH
91148: CALL_OW 256
91152: PUSH
91153: LD_INT 1000
91155: LESS
91156: IFFALSE 91170
// SetLives ( un , 1000 ) ;
91158: LD_VAR 0 3
91162: PPUSH
91163: LD_INT 1000
91165: PPUSH
91166: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
91170: LD_VAR 0 3
91174: PPUSH
91175: LD_INT 81
91177: PUSH
91178: LD_OWVAR 2
91182: PUSH
91183: EMPTY
91184: LIST
91185: LIST
91186: PUSH
91187: LD_INT 91
91189: PUSH
91190: LD_VAR 0 3
91194: PUSH
91195: LD_INT 30
91197: PUSH
91198: EMPTY
91199: LIST
91200: LIST
91201: LIST
91202: PUSH
91203: EMPTY
91204: LIST
91205: LIST
91206: PPUSH
91207: CALL_OW 69
91211: PPUSH
91212: LD_VAR 0 3
91216: PPUSH
91217: CALL_OW 74
91221: PPUSH
91222: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
91226: LD_VAR 0 2
91230: PUSH
91231: LD_INT 60
91233: GREATER
91234: PUSH
91235: LD_VAR 0 3
91239: PPUSH
91240: CALL_OW 301
91244: OR
91245: IFFALSE 91122
// if un then
91247: LD_VAR 0 3
91251: IFFALSE 91262
// RemoveUnit ( un ) ;
91253: LD_VAR 0 3
91257: PPUSH
91258: CALL_OW 64
// end ;
91262: PPOPN 3
91264: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91265: LD_INT 0
91267: PPUSH
// case cmd of 301 :
91268: LD_VAR 0 1
91272: PUSH
91273: LD_INT 301
91275: DOUBLE
91276: EQUAL
91277: IFTRUE 91281
91279: GO 91313
91281: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
91282: LD_VAR 0 6
91286: PPUSH
91287: LD_VAR 0 7
91291: PPUSH
91292: LD_VAR 0 8
91296: PPUSH
91297: LD_VAR 0 4
91301: PPUSH
91302: LD_VAR 0 5
91306: PPUSH
91307: CALL 92514 0 5
91311: GO 91434
91313: LD_INT 302
91315: DOUBLE
91316: EQUAL
91317: IFTRUE 91321
91319: GO 91358
91321: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
91322: LD_VAR 0 6
91326: PPUSH
91327: LD_VAR 0 7
91331: PPUSH
91332: LD_VAR 0 8
91336: PPUSH
91337: LD_VAR 0 9
91341: PPUSH
91342: LD_VAR 0 4
91346: PPUSH
91347: LD_VAR 0 5
91351: PPUSH
91352: CALL 92605 0 6
91356: GO 91434
91358: LD_INT 303
91360: DOUBLE
91361: EQUAL
91362: IFTRUE 91366
91364: GO 91403
91366: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
91367: LD_VAR 0 6
91371: PPUSH
91372: LD_VAR 0 7
91376: PPUSH
91377: LD_VAR 0 8
91381: PPUSH
91382: LD_VAR 0 9
91386: PPUSH
91387: LD_VAR 0 4
91391: PPUSH
91392: LD_VAR 0 5
91396: PPUSH
91397: CALL 91439 0 6
91401: GO 91434
91403: LD_INT 304
91405: DOUBLE
91406: EQUAL
91407: IFTRUE 91411
91409: GO 91433
91411: POP
// hHackTeleport ( unit , x , y ) ; end ;
91412: LD_VAR 0 2
91416: PPUSH
91417: LD_VAR 0 4
91421: PPUSH
91422: LD_VAR 0 5
91426: PPUSH
91427: CALL 93198 0 3
91431: GO 91434
91433: POP
// end ;
91434: LD_VAR 0 12
91438: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
91439: LD_INT 0
91441: PPUSH
91442: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
91443: LD_VAR 0 1
91447: PUSH
91448: LD_INT 1
91450: LESS
91451: PUSH
91452: LD_VAR 0 1
91456: PUSH
91457: LD_INT 3
91459: GREATER
91460: OR
91461: PUSH
91462: LD_VAR 0 5
91466: PPUSH
91467: LD_VAR 0 6
91471: PPUSH
91472: CALL_OW 428
91476: OR
91477: IFFALSE 91481
// exit ;
91479: GO 92201
// uc_side := your_side ;
91481: LD_ADDR_OWVAR 20
91485: PUSH
91486: LD_OWVAR 2
91490: ST_TO_ADDR
// uc_nation := nation ;
91491: LD_ADDR_OWVAR 21
91495: PUSH
91496: LD_VAR 0 1
91500: ST_TO_ADDR
// bc_level = 1 ;
91501: LD_ADDR_OWVAR 43
91505: PUSH
91506: LD_INT 1
91508: ST_TO_ADDR
// case btype of 1 :
91509: LD_VAR 0 2
91513: PUSH
91514: LD_INT 1
91516: DOUBLE
91517: EQUAL
91518: IFTRUE 91522
91520: GO 91533
91522: POP
// bc_type := b_depot ; 2 :
91523: LD_ADDR_OWVAR 42
91527: PUSH
91528: LD_INT 0
91530: ST_TO_ADDR
91531: GO 92145
91533: LD_INT 2
91535: DOUBLE
91536: EQUAL
91537: IFTRUE 91541
91539: GO 91552
91541: POP
// bc_type := b_warehouse ; 3 :
91542: LD_ADDR_OWVAR 42
91546: PUSH
91547: LD_INT 1
91549: ST_TO_ADDR
91550: GO 92145
91552: LD_INT 3
91554: DOUBLE
91555: EQUAL
91556: IFTRUE 91560
91558: GO 91571
91560: POP
// bc_type := b_lab ; 4 .. 9 :
91561: LD_ADDR_OWVAR 42
91565: PUSH
91566: LD_INT 6
91568: ST_TO_ADDR
91569: GO 92145
91571: LD_INT 4
91573: DOUBLE
91574: GREATEREQUAL
91575: IFFALSE 91583
91577: LD_INT 9
91579: DOUBLE
91580: LESSEQUAL
91581: IFTRUE 91585
91583: GO 91637
91585: POP
// begin bc_type := b_lab_half ;
91586: LD_ADDR_OWVAR 42
91590: PUSH
91591: LD_INT 7
91593: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
91594: LD_ADDR_OWVAR 44
91598: PUSH
91599: LD_INT 10
91601: PUSH
91602: LD_INT 11
91604: PUSH
91605: LD_INT 12
91607: PUSH
91608: LD_INT 15
91610: PUSH
91611: LD_INT 14
91613: PUSH
91614: LD_INT 13
91616: PUSH
91617: EMPTY
91618: LIST
91619: LIST
91620: LIST
91621: LIST
91622: LIST
91623: LIST
91624: PUSH
91625: LD_VAR 0 2
91629: PUSH
91630: LD_INT 3
91632: MINUS
91633: ARRAY
91634: ST_TO_ADDR
// end ; 10 .. 13 :
91635: GO 92145
91637: LD_INT 10
91639: DOUBLE
91640: GREATEREQUAL
91641: IFFALSE 91649
91643: LD_INT 13
91645: DOUBLE
91646: LESSEQUAL
91647: IFTRUE 91651
91649: GO 91728
91651: POP
// begin bc_type := b_lab_full ;
91652: LD_ADDR_OWVAR 42
91656: PUSH
91657: LD_INT 8
91659: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
91660: LD_ADDR_OWVAR 44
91664: PUSH
91665: LD_INT 10
91667: PUSH
91668: LD_INT 12
91670: PUSH
91671: LD_INT 14
91673: PUSH
91674: LD_INT 13
91676: PUSH
91677: EMPTY
91678: LIST
91679: LIST
91680: LIST
91681: LIST
91682: PUSH
91683: LD_VAR 0 2
91687: PUSH
91688: LD_INT 9
91690: MINUS
91691: ARRAY
91692: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
91693: LD_ADDR_OWVAR 45
91697: PUSH
91698: LD_INT 11
91700: PUSH
91701: LD_INT 15
91703: PUSH
91704: LD_INT 12
91706: PUSH
91707: LD_INT 15
91709: PUSH
91710: EMPTY
91711: LIST
91712: LIST
91713: LIST
91714: LIST
91715: PUSH
91716: LD_VAR 0 2
91720: PUSH
91721: LD_INT 9
91723: MINUS
91724: ARRAY
91725: ST_TO_ADDR
// end ; 14 :
91726: GO 92145
91728: LD_INT 14
91730: DOUBLE
91731: EQUAL
91732: IFTRUE 91736
91734: GO 91747
91736: POP
// bc_type := b_workshop ; 15 :
91737: LD_ADDR_OWVAR 42
91741: PUSH
91742: LD_INT 2
91744: ST_TO_ADDR
91745: GO 92145
91747: LD_INT 15
91749: DOUBLE
91750: EQUAL
91751: IFTRUE 91755
91753: GO 91766
91755: POP
// bc_type := b_factory ; 16 :
91756: LD_ADDR_OWVAR 42
91760: PUSH
91761: LD_INT 3
91763: ST_TO_ADDR
91764: GO 92145
91766: LD_INT 16
91768: DOUBLE
91769: EQUAL
91770: IFTRUE 91774
91772: GO 91785
91774: POP
// bc_type := b_ext_gun ; 17 :
91775: LD_ADDR_OWVAR 42
91779: PUSH
91780: LD_INT 17
91782: ST_TO_ADDR
91783: GO 92145
91785: LD_INT 17
91787: DOUBLE
91788: EQUAL
91789: IFTRUE 91793
91791: GO 91821
91793: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
91794: LD_ADDR_OWVAR 42
91798: PUSH
91799: LD_INT 19
91801: PUSH
91802: LD_INT 23
91804: PUSH
91805: LD_INT 19
91807: PUSH
91808: EMPTY
91809: LIST
91810: LIST
91811: LIST
91812: PUSH
91813: LD_VAR 0 1
91817: ARRAY
91818: ST_TO_ADDR
91819: GO 92145
91821: LD_INT 18
91823: DOUBLE
91824: EQUAL
91825: IFTRUE 91829
91827: GO 91840
91829: POP
// bc_type := b_ext_radar ; 19 :
91830: LD_ADDR_OWVAR 42
91834: PUSH
91835: LD_INT 20
91837: ST_TO_ADDR
91838: GO 92145
91840: LD_INT 19
91842: DOUBLE
91843: EQUAL
91844: IFTRUE 91848
91846: GO 91859
91848: POP
// bc_type := b_ext_radio ; 20 :
91849: LD_ADDR_OWVAR 42
91853: PUSH
91854: LD_INT 22
91856: ST_TO_ADDR
91857: GO 92145
91859: LD_INT 20
91861: DOUBLE
91862: EQUAL
91863: IFTRUE 91867
91865: GO 91878
91867: POP
// bc_type := b_ext_siberium ; 21 :
91868: LD_ADDR_OWVAR 42
91872: PUSH
91873: LD_INT 21
91875: ST_TO_ADDR
91876: GO 92145
91878: LD_INT 21
91880: DOUBLE
91881: EQUAL
91882: IFTRUE 91886
91884: GO 91897
91886: POP
// bc_type := b_ext_computer ; 22 :
91887: LD_ADDR_OWVAR 42
91891: PUSH
91892: LD_INT 24
91894: ST_TO_ADDR
91895: GO 92145
91897: LD_INT 22
91899: DOUBLE
91900: EQUAL
91901: IFTRUE 91905
91903: GO 91916
91905: POP
// bc_type := b_ext_track ; 23 :
91906: LD_ADDR_OWVAR 42
91910: PUSH
91911: LD_INT 16
91913: ST_TO_ADDR
91914: GO 92145
91916: LD_INT 23
91918: DOUBLE
91919: EQUAL
91920: IFTRUE 91924
91922: GO 91935
91924: POP
// bc_type := b_ext_laser ; 24 :
91925: LD_ADDR_OWVAR 42
91929: PUSH
91930: LD_INT 25
91932: ST_TO_ADDR
91933: GO 92145
91935: LD_INT 24
91937: DOUBLE
91938: EQUAL
91939: IFTRUE 91943
91941: GO 91954
91943: POP
// bc_type := b_control_tower ; 25 :
91944: LD_ADDR_OWVAR 42
91948: PUSH
91949: LD_INT 36
91951: ST_TO_ADDR
91952: GO 92145
91954: LD_INT 25
91956: DOUBLE
91957: EQUAL
91958: IFTRUE 91962
91960: GO 91973
91962: POP
// bc_type := b_breastwork ; 26 :
91963: LD_ADDR_OWVAR 42
91967: PUSH
91968: LD_INT 31
91970: ST_TO_ADDR
91971: GO 92145
91973: LD_INT 26
91975: DOUBLE
91976: EQUAL
91977: IFTRUE 91981
91979: GO 91992
91981: POP
// bc_type := b_bunker ; 27 :
91982: LD_ADDR_OWVAR 42
91986: PUSH
91987: LD_INT 32
91989: ST_TO_ADDR
91990: GO 92145
91992: LD_INT 27
91994: DOUBLE
91995: EQUAL
91996: IFTRUE 92000
91998: GO 92011
92000: POP
// bc_type := b_turret ; 28 :
92001: LD_ADDR_OWVAR 42
92005: PUSH
92006: LD_INT 33
92008: ST_TO_ADDR
92009: GO 92145
92011: LD_INT 28
92013: DOUBLE
92014: EQUAL
92015: IFTRUE 92019
92017: GO 92030
92019: POP
// bc_type := b_armoury ; 29 :
92020: LD_ADDR_OWVAR 42
92024: PUSH
92025: LD_INT 4
92027: ST_TO_ADDR
92028: GO 92145
92030: LD_INT 29
92032: DOUBLE
92033: EQUAL
92034: IFTRUE 92038
92036: GO 92049
92038: POP
// bc_type := b_barracks ; 30 :
92039: LD_ADDR_OWVAR 42
92043: PUSH
92044: LD_INT 5
92046: ST_TO_ADDR
92047: GO 92145
92049: LD_INT 30
92051: DOUBLE
92052: EQUAL
92053: IFTRUE 92057
92055: GO 92068
92057: POP
// bc_type := b_solar_power ; 31 :
92058: LD_ADDR_OWVAR 42
92062: PUSH
92063: LD_INT 27
92065: ST_TO_ADDR
92066: GO 92145
92068: LD_INT 31
92070: DOUBLE
92071: EQUAL
92072: IFTRUE 92076
92074: GO 92087
92076: POP
// bc_type := b_oil_power ; 32 :
92077: LD_ADDR_OWVAR 42
92081: PUSH
92082: LD_INT 26
92084: ST_TO_ADDR
92085: GO 92145
92087: LD_INT 32
92089: DOUBLE
92090: EQUAL
92091: IFTRUE 92095
92093: GO 92106
92095: POP
// bc_type := b_siberite_power ; 33 :
92096: LD_ADDR_OWVAR 42
92100: PUSH
92101: LD_INT 28
92103: ST_TO_ADDR
92104: GO 92145
92106: LD_INT 33
92108: DOUBLE
92109: EQUAL
92110: IFTRUE 92114
92112: GO 92125
92114: POP
// bc_type := b_oil_mine ; 34 :
92115: LD_ADDR_OWVAR 42
92119: PUSH
92120: LD_INT 29
92122: ST_TO_ADDR
92123: GO 92145
92125: LD_INT 34
92127: DOUBLE
92128: EQUAL
92129: IFTRUE 92133
92131: GO 92144
92133: POP
// bc_type := b_siberite_mine ; end ;
92134: LD_ADDR_OWVAR 42
92138: PUSH
92139: LD_INT 30
92141: ST_TO_ADDR
92142: GO 92145
92144: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
92145: LD_ADDR_VAR 0 8
92149: PUSH
92150: LD_VAR 0 5
92154: PPUSH
92155: LD_VAR 0 6
92159: PPUSH
92160: LD_VAR 0 3
92164: PPUSH
92165: CALL_OW 47
92169: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
92170: LD_OWVAR 42
92174: PUSH
92175: LD_INT 32
92177: PUSH
92178: LD_INT 33
92180: PUSH
92181: EMPTY
92182: LIST
92183: LIST
92184: IN
92185: IFFALSE 92201
// PlaceWeaponTurret ( b , weapon ) ;
92187: LD_VAR 0 8
92191: PPUSH
92192: LD_VAR 0 4
92196: PPUSH
92197: CALL_OW 431
// end ;
92201: LD_VAR 0 7
92205: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
92206: LD_INT 0
92208: PPUSH
92209: PPUSH
92210: PPUSH
92211: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92212: LD_ADDR_VAR 0 4
92216: PUSH
92217: LD_INT 22
92219: PUSH
92220: LD_OWVAR 2
92224: PUSH
92225: EMPTY
92226: LIST
92227: LIST
92228: PUSH
92229: LD_INT 2
92231: PUSH
92232: LD_INT 30
92234: PUSH
92235: LD_INT 0
92237: PUSH
92238: EMPTY
92239: LIST
92240: LIST
92241: PUSH
92242: LD_INT 30
92244: PUSH
92245: LD_INT 1
92247: PUSH
92248: EMPTY
92249: LIST
92250: LIST
92251: PUSH
92252: EMPTY
92253: LIST
92254: LIST
92255: LIST
92256: PUSH
92257: EMPTY
92258: LIST
92259: LIST
92260: PPUSH
92261: CALL_OW 69
92265: ST_TO_ADDR
// if not tmp then
92266: LD_VAR 0 4
92270: NOT
92271: IFFALSE 92275
// exit ;
92273: GO 92334
// for i in tmp do
92275: LD_ADDR_VAR 0 2
92279: PUSH
92280: LD_VAR 0 4
92284: PUSH
92285: FOR_IN
92286: IFFALSE 92332
// for j = 1 to 3 do
92288: LD_ADDR_VAR 0 3
92292: PUSH
92293: DOUBLE
92294: LD_INT 1
92296: DEC
92297: ST_TO_ADDR
92298: LD_INT 3
92300: PUSH
92301: FOR_TO
92302: IFFALSE 92328
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
92304: LD_VAR 0 2
92308: PPUSH
92309: CALL_OW 274
92313: PPUSH
92314: LD_VAR 0 3
92318: PPUSH
92319: LD_INT 99999
92321: PPUSH
92322: CALL_OW 277
92326: GO 92301
92328: POP
92329: POP
92330: GO 92285
92332: POP
92333: POP
// end ;
92334: LD_VAR 0 1
92338: RET
// export function hHackSetLevel10 ; var i , j ; begin
92339: LD_INT 0
92341: PPUSH
92342: PPUSH
92343: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
92344: LD_ADDR_VAR 0 2
92348: PUSH
92349: LD_INT 21
92351: PUSH
92352: LD_INT 1
92354: PUSH
92355: EMPTY
92356: LIST
92357: LIST
92358: PPUSH
92359: CALL_OW 69
92363: PUSH
92364: FOR_IN
92365: IFFALSE 92417
// if IsSelected ( i ) then
92367: LD_VAR 0 2
92371: PPUSH
92372: CALL_OW 306
92376: IFFALSE 92415
// begin for j := 1 to 4 do
92378: LD_ADDR_VAR 0 3
92382: PUSH
92383: DOUBLE
92384: LD_INT 1
92386: DEC
92387: ST_TO_ADDR
92388: LD_INT 4
92390: PUSH
92391: FOR_TO
92392: IFFALSE 92413
// SetSkill ( i , j , 10 ) ;
92394: LD_VAR 0 2
92398: PPUSH
92399: LD_VAR 0 3
92403: PPUSH
92404: LD_INT 10
92406: PPUSH
92407: CALL_OW 237
92411: GO 92391
92413: POP
92414: POP
// end ;
92415: GO 92364
92417: POP
92418: POP
// end ;
92419: LD_VAR 0 1
92423: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
92424: LD_INT 0
92426: PPUSH
92427: PPUSH
92428: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
92429: LD_ADDR_VAR 0 2
92433: PUSH
92434: LD_INT 22
92436: PUSH
92437: LD_OWVAR 2
92441: PUSH
92442: EMPTY
92443: LIST
92444: LIST
92445: PUSH
92446: LD_INT 21
92448: PUSH
92449: LD_INT 1
92451: PUSH
92452: EMPTY
92453: LIST
92454: LIST
92455: PUSH
92456: EMPTY
92457: LIST
92458: LIST
92459: PPUSH
92460: CALL_OW 69
92464: PUSH
92465: FOR_IN
92466: IFFALSE 92507
// begin for j := 1 to 4 do
92468: LD_ADDR_VAR 0 3
92472: PUSH
92473: DOUBLE
92474: LD_INT 1
92476: DEC
92477: ST_TO_ADDR
92478: LD_INT 4
92480: PUSH
92481: FOR_TO
92482: IFFALSE 92503
// SetSkill ( i , j , 10 ) ;
92484: LD_VAR 0 2
92488: PPUSH
92489: LD_VAR 0 3
92493: PPUSH
92494: LD_INT 10
92496: PPUSH
92497: CALL_OW 237
92501: GO 92481
92503: POP
92504: POP
// end ;
92505: GO 92465
92507: POP
92508: POP
// end ;
92509: LD_VAR 0 1
92513: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
92514: LD_INT 0
92516: PPUSH
// uc_side := your_side ;
92517: LD_ADDR_OWVAR 20
92521: PUSH
92522: LD_OWVAR 2
92526: ST_TO_ADDR
// uc_nation := nation ;
92527: LD_ADDR_OWVAR 21
92531: PUSH
92532: LD_VAR 0 1
92536: ST_TO_ADDR
// InitHc ;
92537: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
92541: LD_INT 0
92543: PPUSH
92544: LD_VAR 0 2
92548: PPUSH
92549: LD_VAR 0 3
92553: PPUSH
92554: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
92558: LD_VAR 0 4
92562: PPUSH
92563: LD_VAR 0 5
92567: PPUSH
92568: CALL_OW 428
92572: PUSH
92573: LD_INT 0
92575: EQUAL
92576: IFFALSE 92600
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
92578: CALL_OW 44
92582: PPUSH
92583: LD_VAR 0 4
92587: PPUSH
92588: LD_VAR 0 5
92592: PPUSH
92593: LD_INT 1
92595: PPUSH
92596: CALL_OW 48
// end ;
92600: LD_VAR 0 6
92604: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
92605: LD_INT 0
92607: PPUSH
92608: PPUSH
// uc_side := your_side ;
92609: LD_ADDR_OWVAR 20
92613: PUSH
92614: LD_OWVAR 2
92618: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
92619: LD_VAR 0 1
92623: PUSH
92624: LD_INT 1
92626: PUSH
92627: LD_INT 2
92629: PUSH
92630: LD_INT 3
92632: PUSH
92633: LD_INT 4
92635: PUSH
92636: LD_INT 5
92638: PUSH
92639: EMPTY
92640: LIST
92641: LIST
92642: LIST
92643: LIST
92644: LIST
92645: IN
92646: IFFALSE 92658
// uc_nation := nation_american else
92648: LD_ADDR_OWVAR 21
92652: PUSH
92653: LD_INT 1
92655: ST_TO_ADDR
92656: GO 92701
// if chassis in [ 11 , 12 , 13 , 14 ] then
92658: LD_VAR 0 1
92662: PUSH
92663: LD_INT 11
92665: PUSH
92666: LD_INT 12
92668: PUSH
92669: LD_INT 13
92671: PUSH
92672: LD_INT 14
92674: PUSH
92675: EMPTY
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: IN
92681: IFFALSE 92693
// uc_nation := nation_arabian else
92683: LD_ADDR_OWVAR 21
92687: PUSH
92688: LD_INT 2
92690: ST_TO_ADDR
92691: GO 92701
// uc_nation := nation_russian ;
92693: LD_ADDR_OWVAR 21
92697: PUSH
92698: LD_INT 3
92700: ST_TO_ADDR
// vc_chassis := chassis ;
92701: LD_ADDR_OWVAR 37
92705: PUSH
92706: LD_VAR 0 1
92710: ST_TO_ADDR
// vc_engine := engine ;
92711: LD_ADDR_OWVAR 39
92715: PUSH
92716: LD_VAR 0 2
92720: ST_TO_ADDR
// vc_control := control ;
92721: LD_ADDR_OWVAR 38
92725: PUSH
92726: LD_VAR 0 3
92730: ST_TO_ADDR
// vc_weapon := weapon ;
92731: LD_ADDR_OWVAR 40
92735: PUSH
92736: LD_VAR 0 4
92740: ST_TO_ADDR
// un := CreateVehicle ;
92741: LD_ADDR_VAR 0 8
92745: PUSH
92746: CALL_OW 45
92750: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
92751: LD_VAR 0 8
92755: PPUSH
92756: LD_INT 0
92758: PPUSH
92759: LD_INT 5
92761: PPUSH
92762: CALL_OW 12
92766: PPUSH
92767: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
92771: LD_VAR 0 8
92775: PPUSH
92776: LD_VAR 0 5
92780: PPUSH
92781: LD_VAR 0 6
92785: PPUSH
92786: LD_INT 1
92788: PPUSH
92789: CALL_OW 48
// end ;
92793: LD_VAR 0 7
92797: RET
// export hInvincible ; every 1 do
92798: GO 92800
92800: DISABLE
// hInvincible := [ ] ;
92801: LD_ADDR_EXP 162
92805: PUSH
92806: EMPTY
92807: ST_TO_ADDR
92808: END
// every 10 do var i ;
92809: GO 92811
92811: DISABLE
92812: LD_INT 0
92814: PPUSH
// begin enable ;
92815: ENABLE
// if not hInvincible then
92816: LD_EXP 162
92820: NOT
92821: IFFALSE 92825
// exit ;
92823: GO 92869
// for i in hInvincible do
92825: LD_ADDR_VAR 0 1
92829: PUSH
92830: LD_EXP 162
92834: PUSH
92835: FOR_IN
92836: IFFALSE 92867
// if GetLives ( i ) < 1000 then
92838: LD_VAR 0 1
92842: PPUSH
92843: CALL_OW 256
92847: PUSH
92848: LD_INT 1000
92850: LESS
92851: IFFALSE 92865
// SetLives ( i , 1000 ) ;
92853: LD_VAR 0 1
92857: PPUSH
92858: LD_INT 1000
92860: PPUSH
92861: CALL_OW 234
92865: GO 92835
92867: POP
92868: POP
// end ;
92869: PPOPN 1
92871: END
// export function hHackInvincible ; var i ; begin
92872: LD_INT 0
92874: PPUSH
92875: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
92876: LD_ADDR_VAR 0 2
92880: PUSH
92881: LD_INT 2
92883: PUSH
92884: LD_INT 21
92886: PUSH
92887: LD_INT 1
92889: PUSH
92890: EMPTY
92891: LIST
92892: LIST
92893: PUSH
92894: LD_INT 21
92896: PUSH
92897: LD_INT 2
92899: PUSH
92900: EMPTY
92901: LIST
92902: LIST
92903: PUSH
92904: EMPTY
92905: LIST
92906: LIST
92907: LIST
92908: PPUSH
92909: CALL_OW 69
92913: PUSH
92914: FOR_IN
92915: IFFALSE 92976
// if IsSelected ( i ) then
92917: LD_VAR 0 2
92921: PPUSH
92922: CALL_OW 306
92926: IFFALSE 92974
// begin if i in hInvincible then
92928: LD_VAR 0 2
92932: PUSH
92933: LD_EXP 162
92937: IN
92938: IFFALSE 92958
// hInvincible := hInvincible diff i else
92940: LD_ADDR_EXP 162
92944: PUSH
92945: LD_EXP 162
92949: PUSH
92950: LD_VAR 0 2
92954: DIFF
92955: ST_TO_ADDR
92956: GO 92974
// hInvincible := hInvincible union i ;
92958: LD_ADDR_EXP 162
92962: PUSH
92963: LD_EXP 162
92967: PUSH
92968: LD_VAR 0 2
92972: UNION
92973: ST_TO_ADDR
// end ;
92974: GO 92914
92976: POP
92977: POP
// end ;
92978: LD_VAR 0 1
92982: RET
// export function hHackInvisible ; var i , j ; begin
92983: LD_INT 0
92985: PPUSH
92986: PPUSH
92987: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
92988: LD_ADDR_VAR 0 2
92992: PUSH
92993: LD_INT 21
92995: PUSH
92996: LD_INT 1
92998: PUSH
92999: EMPTY
93000: LIST
93001: LIST
93002: PPUSH
93003: CALL_OW 69
93007: PUSH
93008: FOR_IN
93009: IFFALSE 93033
// if IsSelected ( i ) then
93011: LD_VAR 0 2
93015: PPUSH
93016: CALL_OW 306
93020: IFFALSE 93031
// ComForceInvisible ( i ) ;
93022: LD_VAR 0 2
93026: PPUSH
93027: CALL_OW 496
93031: GO 93008
93033: POP
93034: POP
// end ;
93035: LD_VAR 0 1
93039: RET
// export function hHackChangeYourSide ; begin
93040: LD_INT 0
93042: PPUSH
// if your_side = 8 then
93043: LD_OWVAR 2
93047: PUSH
93048: LD_INT 8
93050: EQUAL
93051: IFFALSE 93063
// your_side := 0 else
93053: LD_ADDR_OWVAR 2
93057: PUSH
93058: LD_INT 0
93060: ST_TO_ADDR
93061: GO 93077
// your_side := your_side + 1 ;
93063: LD_ADDR_OWVAR 2
93067: PUSH
93068: LD_OWVAR 2
93072: PUSH
93073: LD_INT 1
93075: PLUS
93076: ST_TO_ADDR
// end ;
93077: LD_VAR 0 1
93081: RET
// export function hHackChangeUnitSide ; var i , j ; begin
93082: LD_INT 0
93084: PPUSH
93085: PPUSH
93086: PPUSH
// for i in all_units do
93087: LD_ADDR_VAR 0 2
93091: PUSH
93092: LD_OWVAR 3
93096: PUSH
93097: FOR_IN
93098: IFFALSE 93176
// if IsSelected ( i ) then
93100: LD_VAR 0 2
93104: PPUSH
93105: CALL_OW 306
93109: IFFALSE 93174
// begin j := GetSide ( i ) ;
93111: LD_ADDR_VAR 0 3
93115: PUSH
93116: LD_VAR 0 2
93120: PPUSH
93121: CALL_OW 255
93125: ST_TO_ADDR
// if j = 8 then
93126: LD_VAR 0 3
93130: PUSH
93131: LD_INT 8
93133: EQUAL
93134: IFFALSE 93146
// j := 0 else
93136: LD_ADDR_VAR 0 3
93140: PUSH
93141: LD_INT 0
93143: ST_TO_ADDR
93144: GO 93160
// j := j + 1 ;
93146: LD_ADDR_VAR 0 3
93150: PUSH
93151: LD_VAR 0 3
93155: PUSH
93156: LD_INT 1
93158: PLUS
93159: ST_TO_ADDR
// SetSide ( i , j ) ;
93160: LD_VAR 0 2
93164: PPUSH
93165: LD_VAR 0 3
93169: PPUSH
93170: CALL_OW 235
// end ;
93174: GO 93097
93176: POP
93177: POP
// end ;
93178: LD_VAR 0 1
93182: RET
// export function hHackFog ; begin
93183: LD_INT 0
93185: PPUSH
// FogOff ( true ) ;
93186: LD_INT 1
93188: PPUSH
93189: CALL_OW 344
// end ;
93193: LD_VAR 0 1
93197: RET
// export function hHackTeleport ( unit , x , y ) ; begin
93198: LD_INT 0
93200: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
93201: LD_VAR 0 1
93205: PPUSH
93206: LD_VAR 0 2
93210: PPUSH
93211: LD_VAR 0 3
93215: PPUSH
93216: LD_INT 1
93218: PPUSH
93219: LD_INT 1
93221: PPUSH
93222: CALL_OW 483
// CenterOnXY ( x , y ) ;
93226: LD_VAR 0 2
93230: PPUSH
93231: LD_VAR 0 3
93235: PPUSH
93236: CALL_OW 84
// end ; end_of_file
93240: LD_VAR 0 4
93244: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
93245: LD_INT 0
93247: PPUSH
93248: PPUSH
93249: PPUSH
93250: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
93251: LD_VAR 0 1
93255: PPUSH
93256: CALL_OW 264
93260: PUSH
93261: LD_EXP 52
93265: EQUAL
93266: IFFALSE 93338
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
93268: LD_INT 68
93270: PPUSH
93271: LD_VAR 0 1
93275: PPUSH
93276: CALL_OW 255
93280: PPUSH
93281: CALL_OW 321
93285: PUSH
93286: LD_INT 2
93288: EQUAL
93289: IFFALSE 93301
// eff := 70 else
93291: LD_ADDR_VAR 0 4
93295: PUSH
93296: LD_INT 70
93298: ST_TO_ADDR
93299: GO 93309
// eff := 30 ;
93301: LD_ADDR_VAR 0 4
93305: PUSH
93306: LD_INT 30
93308: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
93309: LD_VAR 0 1
93313: PPUSH
93314: CALL_OW 250
93318: PPUSH
93319: LD_VAR 0 1
93323: PPUSH
93324: CALL_OW 251
93328: PPUSH
93329: LD_VAR 0 4
93333: PPUSH
93334: CALL_OW 495
// end ; end ;
93338: LD_VAR 0 2
93342: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
93343: LD_INT 0
93345: PPUSH
// end ;
93346: LD_VAR 0 4
93350: RET
// export function SOS_Command ( cmd ) ; begin
93351: LD_INT 0
93353: PPUSH
// end ;
93354: LD_VAR 0 2
93358: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
93359: LD_INT 0
93361: PPUSH
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
93362: LD_VAR 0 1
93366: PUSH
93367: LD_INT 254
93369: EQUAL
93370: PUSH
93371: LD_VAR 0 2
93375: PPUSH
93376: CALL_OW 264
93380: PUSH
93381: LD_EXP 50
93385: EQUAL
93386: AND
93387: PUSH
93388: LD_VAR 0 3
93392: PPUSH
93393: CALL_OW 263
93397: PUSH
93398: LD_INT 3
93400: EQUAL
93401: AND
93402: IFFALSE 93418
// HackDestroyVehicle ( unit , selectedUnit ) ;
93404: LD_VAR 0 2
93408: PPUSH
93409: LD_VAR 0 3
93413: PPUSH
93414: CALL 94927 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
93418: LD_VAR 0 1
93422: PUSH
93423: LD_INT 255
93425: EQUAL
93426: PUSH
93427: LD_VAR 0 2
93431: PPUSH
93432: CALL_OW 264
93436: PUSH
93437: LD_INT 14
93439: PUSH
93440: LD_INT 53
93442: PUSH
93443: EMPTY
93444: LIST
93445: LIST
93446: IN
93447: AND
93448: PUSH
93449: LD_VAR 0 4
93453: PPUSH
93454: LD_VAR 0 5
93458: PPUSH
93459: CALL_OW 488
93463: AND
93464: IFFALSE 93488
// CutTreeXYR ( unit , x , y , 12 ) ;
93466: LD_VAR 0 2
93470: PPUSH
93471: LD_VAR 0 4
93475: PPUSH
93476: LD_VAR 0 5
93480: PPUSH
93481: LD_INT 12
93483: PPUSH
93484: CALL 93493 0 4
// end ;
93488: LD_VAR 0 6
93492: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
93493: LD_INT 0
93495: PPUSH
93496: PPUSH
93497: PPUSH
93498: PPUSH
93499: PPUSH
93500: PPUSH
93501: PPUSH
93502: PPUSH
93503: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
93504: LD_VAR 0 1
93508: NOT
93509: PUSH
93510: LD_VAR 0 2
93514: PPUSH
93515: LD_VAR 0 3
93519: PPUSH
93520: CALL_OW 488
93524: NOT
93525: OR
93526: PUSH
93527: LD_VAR 0 4
93531: NOT
93532: OR
93533: IFFALSE 93537
// exit ;
93535: GO 93877
// list := [ ] ;
93537: LD_ADDR_VAR 0 13
93541: PUSH
93542: EMPTY
93543: ST_TO_ADDR
// if x - r < 0 then
93544: LD_VAR 0 2
93548: PUSH
93549: LD_VAR 0 4
93553: MINUS
93554: PUSH
93555: LD_INT 0
93557: LESS
93558: IFFALSE 93570
// min_x := 0 else
93560: LD_ADDR_VAR 0 7
93564: PUSH
93565: LD_INT 0
93567: ST_TO_ADDR
93568: GO 93586
// min_x := x - r ;
93570: LD_ADDR_VAR 0 7
93574: PUSH
93575: LD_VAR 0 2
93579: PUSH
93580: LD_VAR 0 4
93584: MINUS
93585: ST_TO_ADDR
// if y - r < 0 then
93586: LD_VAR 0 3
93590: PUSH
93591: LD_VAR 0 4
93595: MINUS
93596: PUSH
93597: LD_INT 0
93599: LESS
93600: IFFALSE 93612
// min_y := 0 else
93602: LD_ADDR_VAR 0 8
93606: PUSH
93607: LD_INT 0
93609: ST_TO_ADDR
93610: GO 93628
// min_y := y - r ;
93612: LD_ADDR_VAR 0 8
93616: PUSH
93617: LD_VAR 0 3
93621: PUSH
93622: LD_VAR 0 4
93626: MINUS
93627: ST_TO_ADDR
// max_x := x + r ;
93628: LD_ADDR_VAR 0 9
93632: PUSH
93633: LD_VAR 0 2
93637: PUSH
93638: LD_VAR 0 4
93642: PLUS
93643: ST_TO_ADDR
// max_y := y + r ;
93644: LD_ADDR_VAR 0 10
93648: PUSH
93649: LD_VAR 0 3
93653: PUSH
93654: LD_VAR 0 4
93658: PLUS
93659: ST_TO_ADDR
// for _x = min_x to max_x do
93660: LD_ADDR_VAR 0 11
93664: PUSH
93665: DOUBLE
93666: LD_VAR 0 7
93670: DEC
93671: ST_TO_ADDR
93672: LD_VAR 0 9
93676: PUSH
93677: FOR_TO
93678: IFFALSE 93795
// for _y = min_y to max_y do
93680: LD_ADDR_VAR 0 12
93684: PUSH
93685: DOUBLE
93686: LD_VAR 0 8
93690: DEC
93691: ST_TO_ADDR
93692: LD_VAR 0 10
93696: PUSH
93697: FOR_TO
93698: IFFALSE 93791
// begin if not ValidHex ( _x , _y ) then
93700: LD_VAR 0 11
93704: PPUSH
93705: LD_VAR 0 12
93709: PPUSH
93710: CALL_OW 488
93714: NOT
93715: IFFALSE 93719
// continue ;
93717: GO 93697
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
93719: LD_VAR 0 11
93723: PPUSH
93724: LD_VAR 0 12
93728: PPUSH
93729: CALL_OW 351
93733: PUSH
93734: LD_VAR 0 11
93738: PPUSH
93739: LD_VAR 0 12
93743: PPUSH
93744: CALL_OW 554
93748: AND
93749: IFFALSE 93789
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
93751: LD_ADDR_VAR 0 13
93755: PUSH
93756: LD_VAR 0 13
93760: PPUSH
93761: LD_VAR 0 13
93765: PUSH
93766: LD_INT 1
93768: PLUS
93769: PPUSH
93770: LD_VAR 0 11
93774: PUSH
93775: LD_VAR 0 12
93779: PUSH
93780: EMPTY
93781: LIST
93782: LIST
93783: PPUSH
93784: CALL_OW 2
93788: ST_TO_ADDR
// end ;
93789: GO 93697
93791: POP
93792: POP
93793: GO 93677
93795: POP
93796: POP
// if not list then
93797: LD_VAR 0 13
93801: NOT
93802: IFFALSE 93806
// exit ;
93804: GO 93877
// for i in list do
93806: LD_ADDR_VAR 0 6
93810: PUSH
93811: LD_VAR 0 13
93815: PUSH
93816: FOR_IN
93817: IFFALSE 93875
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
93819: LD_VAR 0 1
93823: PPUSH
93824: LD_STRING M
93826: PUSH
93827: LD_VAR 0 6
93831: PUSH
93832: LD_INT 1
93834: ARRAY
93835: PUSH
93836: LD_VAR 0 6
93840: PUSH
93841: LD_INT 2
93843: ARRAY
93844: PUSH
93845: LD_INT 0
93847: PUSH
93848: LD_INT 0
93850: PUSH
93851: LD_INT 0
93853: PUSH
93854: LD_INT 0
93856: PUSH
93857: EMPTY
93858: LIST
93859: LIST
93860: LIST
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: PUSH
93866: EMPTY
93867: LIST
93868: PPUSH
93869: CALL_OW 447
93873: GO 93816
93875: POP
93876: POP
// end ;
93877: LD_VAR 0 5
93881: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
93882: LD_EXP 163
93886: NOT
93887: IFFALSE 93937
93889: GO 93891
93891: DISABLE
// begin initHack := true ;
93892: LD_ADDR_EXP 163
93896: PUSH
93897: LD_INT 1
93899: ST_TO_ADDR
// hackTanks := [ ] ;
93900: LD_ADDR_EXP 164
93904: PUSH
93905: EMPTY
93906: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
93907: LD_ADDR_EXP 165
93911: PUSH
93912: EMPTY
93913: ST_TO_ADDR
// hackLimit := 3 ;
93914: LD_ADDR_EXP 166
93918: PUSH
93919: LD_INT 3
93921: ST_TO_ADDR
// hackDist := 12 ;
93922: LD_ADDR_EXP 167
93926: PUSH
93927: LD_INT 12
93929: ST_TO_ADDR
// hackCounter := [ ] ;
93930: LD_ADDR_EXP 168
93934: PUSH
93935: EMPTY
93936: ST_TO_ADDR
// end ;
93937: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
93938: LD_EXP 163
93942: PUSH
93943: LD_INT 34
93945: PUSH
93946: LD_EXP 50
93950: PUSH
93951: EMPTY
93952: LIST
93953: LIST
93954: PPUSH
93955: CALL_OW 69
93959: AND
93960: IFFALSE 94215
93962: GO 93964
93964: DISABLE
93965: LD_INT 0
93967: PPUSH
93968: PPUSH
// begin enable ;
93969: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
93970: LD_ADDR_VAR 0 1
93974: PUSH
93975: LD_INT 34
93977: PUSH
93978: LD_EXP 50
93982: PUSH
93983: EMPTY
93984: LIST
93985: LIST
93986: PPUSH
93987: CALL_OW 69
93991: PUSH
93992: FOR_IN
93993: IFFALSE 94213
// begin if not i in hackTanks then
93995: LD_VAR 0 1
93999: PUSH
94000: LD_EXP 164
94004: IN
94005: NOT
94006: IFFALSE 94089
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
94008: LD_ADDR_EXP 164
94012: PUSH
94013: LD_EXP 164
94017: PPUSH
94018: LD_EXP 164
94022: PUSH
94023: LD_INT 1
94025: PLUS
94026: PPUSH
94027: LD_VAR 0 1
94031: PPUSH
94032: CALL_OW 1
94036: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
94037: LD_ADDR_EXP 165
94041: PUSH
94042: LD_EXP 165
94046: PPUSH
94047: LD_EXP 165
94051: PUSH
94052: LD_INT 1
94054: PLUS
94055: PPUSH
94056: EMPTY
94057: PPUSH
94058: CALL_OW 1
94062: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
94063: LD_ADDR_EXP 168
94067: PUSH
94068: LD_EXP 168
94072: PPUSH
94073: LD_EXP 168
94077: PUSH
94078: LD_INT 1
94080: PLUS
94081: PPUSH
94082: EMPTY
94083: PPUSH
94084: CALL_OW 1
94088: ST_TO_ADDR
// end ; if not IsOk ( i ) then
94089: LD_VAR 0 1
94093: PPUSH
94094: CALL_OW 302
94098: NOT
94099: IFFALSE 94112
// begin HackUnlinkAll ( i ) ;
94101: LD_VAR 0 1
94105: PPUSH
94106: CALL 94218 0 1
// continue ;
94110: GO 93992
// end ; HackCheckCapturedStatus ( i ) ;
94112: LD_VAR 0 1
94116: PPUSH
94117: CALL 94661 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
94121: LD_ADDR_VAR 0 2
94125: PUSH
94126: LD_INT 81
94128: PUSH
94129: LD_VAR 0 1
94133: PPUSH
94134: CALL_OW 255
94138: PUSH
94139: EMPTY
94140: LIST
94141: LIST
94142: PUSH
94143: LD_INT 33
94145: PUSH
94146: LD_INT 3
94148: PUSH
94149: EMPTY
94150: LIST
94151: LIST
94152: PUSH
94153: LD_INT 91
94155: PUSH
94156: LD_VAR 0 1
94160: PUSH
94161: LD_EXP 167
94165: PUSH
94166: EMPTY
94167: LIST
94168: LIST
94169: LIST
94170: PUSH
94171: LD_INT 50
94173: PUSH
94174: EMPTY
94175: LIST
94176: PUSH
94177: EMPTY
94178: LIST
94179: LIST
94180: LIST
94181: LIST
94182: PPUSH
94183: CALL_OW 69
94187: ST_TO_ADDR
// if not tmp then
94188: LD_VAR 0 2
94192: NOT
94193: IFFALSE 94197
// continue ;
94195: GO 93992
// HackLink ( i , tmp ) ;
94197: LD_VAR 0 1
94201: PPUSH
94202: LD_VAR 0 2
94206: PPUSH
94207: CALL 94354 0 2
// end ;
94211: GO 93992
94213: POP
94214: POP
// end ;
94215: PPOPN 2
94217: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
94218: LD_INT 0
94220: PPUSH
94221: PPUSH
94222: PPUSH
// if not hack in hackTanks then
94223: LD_VAR 0 1
94227: PUSH
94228: LD_EXP 164
94232: IN
94233: NOT
94234: IFFALSE 94238
// exit ;
94236: GO 94349
// index := GetElementIndex ( hackTanks , hack ) ;
94238: LD_ADDR_VAR 0 4
94242: PUSH
94243: LD_EXP 164
94247: PPUSH
94248: LD_VAR 0 1
94252: PPUSH
94253: CALL 18289 0 2
94257: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
94258: LD_EXP 165
94262: PUSH
94263: LD_VAR 0 4
94267: ARRAY
94268: IFFALSE 94349
// begin for i in hackTanksCaptured [ index ] do
94270: LD_ADDR_VAR 0 3
94274: PUSH
94275: LD_EXP 165
94279: PUSH
94280: LD_VAR 0 4
94284: ARRAY
94285: PUSH
94286: FOR_IN
94287: IFFALSE 94313
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
94289: LD_VAR 0 3
94293: PUSH
94294: LD_INT 1
94296: ARRAY
94297: PPUSH
94298: LD_VAR 0 3
94302: PUSH
94303: LD_INT 2
94305: ARRAY
94306: PPUSH
94307: CALL_OW 235
94311: GO 94286
94313: POP
94314: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
94315: LD_ADDR_EXP 165
94319: PUSH
94320: LD_EXP 165
94324: PPUSH
94325: LD_VAR 0 4
94329: PPUSH
94330: EMPTY
94331: PPUSH
94332: CALL_OW 1
94336: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
94337: LD_VAR 0 1
94341: PPUSH
94342: LD_INT 0
94344: PPUSH
94345: CALL_OW 505
// end ; end ;
94349: LD_VAR 0 2
94353: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
94354: LD_INT 0
94356: PPUSH
94357: PPUSH
94358: PPUSH
// if not hack in hackTanks or not vehicles then
94359: LD_VAR 0 1
94363: PUSH
94364: LD_EXP 164
94368: IN
94369: NOT
94370: PUSH
94371: LD_VAR 0 2
94375: NOT
94376: OR
94377: IFFALSE 94381
// exit ;
94379: GO 94656
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
94381: LD_ADDR_VAR 0 2
94385: PUSH
94386: LD_VAR 0 1
94390: PPUSH
94391: LD_VAR 0 2
94395: PPUSH
94396: LD_INT 1
94398: PPUSH
94399: LD_INT 1
94401: PPUSH
94402: CALL 18939 0 4
94406: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
94407: LD_ADDR_VAR 0 5
94411: PUSH
94412: LD_EXP 164
94416: PPUSH
94417: LD_VAR 0 1
94421: PPUSH
94422: CALL 18289 0 2
94426: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
94427: LD_EXP 165
94431: PUSH
94432: LD_VAR 0 5
94436: ARRAY
94437: PUSH
94438: LD_EXP 166
94442: LESS
94443: IFFALSE 94632
// begin for i := 1 to vehicles do
94445: LD_ADDR_VAR 0 4
94449: PUSH
94450: DOUBLE
94451: LD_INT 1
94453: DEC
94454: ST_TO_ADDR
94455: LD_VAR 0 2
94459: PUSH
94460: FOR_TO
94461: IFFALSE 94630
// begin if hackTanksCaptured [ index ] = hackLimit then
94463: LD_EXP 165
94467: PUSH
94468: LD_VAR 0 5
94472: ARRAY
94473: PUSH
94474: LD_EXP 166
94478: EQUAL
94479: IFFALSE 94483
// break ;
94481: GO 94630
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
94483: LD_ADDR_EXP 168
94487: PUSH
94488: LD_EXP 168
94492: PPUSH
94493: LD_VAR 0 5
94497: PPUSH
94498: LD_EXP 168
94502: PUSH
94503: LD_VAR 0 5
94507: ARRAY
94508: PUSH
94509: LD_INT 1
94511: PLUS
94512: PPUSH
94513: CALL_OW 1
94517: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
94518: LD_ADDR_EXP 165
94522: PUSH
94523: LD_EXP 165
94527: PPUSH
94528: LD_VAR 0 5
94532: PUSH
94533: LD_EXP 165
94537: PUSH
94538: LD_VAR 0 5
94542: ARRAY
94543: PUSH
94544: LD_INT 1
94546: PLUS
94547: PUSH
94548: EMPTY
94549: LIST
94550: LIST
94551: PPUSH
94552: LD_VAR 0 2
94556: PUSH
94557: LD_VAR 0 4
94561: ARRAY
94562: PUSH
94563: LD_VAR 0 2
94567: PUSH
94568: LD_VAR 0 4
94572: ARRAY
94573: PPUSH
94574: CALL_OW 255
94578: PUSH
94579: EMPTY
94580: LIST
94581: LIST
94582: PPUSH
94583: CALL 18504 0 3
94587: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
94588: LD_VAR 0 2
94592: PUSH
94593: LD_VAR 0 4
94597: ARRAY
94598: PPUSH
94599: LD_VAR 0 1
94603: PPUSH
94604: CALL_OW 255
94608: PPUSH
94609: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
94613: LD_VAR 0 2
94617: PUSH
94618: LD_VAR 0 4
94622: ARRAY
94623: PPUSH
94624: CALL_OW 141
// end ;
94628: GO 94460
94630: POP
94631: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
94632: LD_VAR 0 1
94636: PPUSH
94637: LD_EXP 165
94641: PUSH
94642: LD_VAR 0 5
94646: ARRAY
94647: PUSH
94648: LD_INT 0
94650: PLUS
94651: PPUSH
94652: CALL_OW 505
// end ;
94656: LD_VAR 0 3
94660: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
94661: LD_INT 0
94663: PPUSH
94664: PPUSH
94665: PPUSH
94666: PPUSH
// if not hack in hackTanks then
94667: LD_VAR 0 1
94671: PUSH
94672: LD_EXP 164
94676: IN
94677: NOT
94678: IFFALSE 94682
// exit ;
94680: GO 94922
// index := GetElementIndex ( hackTanks , hack ) ;
94682: LD_ADDR_VAR 0 4
94686: PUSH
94687: LD_EXP 164
94691: PPUSH
94692: LD_VAR 0 1
94696: PPUSH
94697: CALL 18289 0 2
94701: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
94702: LD_ADDR_VAR 0 3
94706: PUSH
94707: DOUBLE
94708: LD_EXP 165
94712: PUSH
94713: LD_VAR 0 4
94717: ARRAY
94718: INC
94719: ST_TO_ADDR
94720: LD_INT 1
94722: PUSH
94723: FOR_DOWNTO
94724: IFFALSE 94896
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
94726: LD_ADDR_VAR 0 5
94730: PUSH
94731: LD_EXP 165
94735: PUSH
94736: LD_VAR 0 4
94740: ARRAY
94741: PUSH
94742: LD_VAR 0 3
94746: ARRAY
94747: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
94748: LD_VAR 0 5
94752: PUSH
94753: LD_INT 1
94755: ARRAY
94756: PPUSH
94757: CALL_OW 302
94761: NOT
94762: PUSH
94763: LD_VAR 0 5
94767: PUSH
94768: LD_INT 1
94770: ARRAY
94771: PPUSH
94772: CALL_OW 255
94776: PUSH
94777: LD_VAR 0 1
94781: PPUSH
94782: CALL_OW 255
94786: NONEQUAL
94787: OR
94788: IFFALSE 94894
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
94790: LD_VAR 0 5
94794: PUSH
94795: LD_INT 1
94797: ARRAY
94798: PPUSH
94799: CALL_OW 305
94803: PUSH
94804: LD_VAR 0 5
94808: PUSH
94809: LD_INT 1
94811: ARRAY
94812: PPUSH
94813: CALL_OW 255
94817: PUSH
94818: LD_VAR 0 1
94822: PPUSH
94823: CALL_OW 255
94827: EQUAL
94828: AND
94829: IFFALSE 94853
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
94831: LD_VAR 0 5
94835: PUSH
94836: LD_INT 1
94838: ARRAY
94839: PPUSH
94840: LD_VAR 0 5
94844: PUSH
94845: LD_INT 2
94847: ARRAY
94848: PPUSH
94849: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
94853: LD_ADDR_EXP 165
94857: PUSH
94858: LD_EXP 165
94862: PPUSH
94863: LD_VAR 0 4
94867: PPUSH
94868: LD_EXP 165
94872: PUSH
94873: LD_VAR 0 4
94877: ARRAY
94878: PPUSH
94879: LD_VAR 0 3
94883: PPUSH
94884: CALL_OW 3
94888: PPUSH
94889: CALL_OW 1
94893: ST_TO_ADDR
// end ; end ;
94894: GO 94723
94896: POP
94897: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
94898: LD_VAR 0 1
94902: PPUSH
94903: LD_EXP 165
94907: PUSH
94908: LD_VAR 0 4
94912: ARRAY
94913: PUSH
94914: LD_INT 0
94916: PLUS
94917: PPUSH
94918: CALL_OW 505
// end ;
94922: LD_VAR 0 2
94926: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
94927: LD_INT 0
94929: PPUSH
94930: PPUSH
94931: PPUSH
94932: PPUSH
// if not hack in hackTanks then
94933: LD_VAR 0 1
94937: PUSH
94938: LD_EXP 164
94942: IN
94943: NOT
94944: IFFALSE 94948
// exit ;
94946: GO 95033
// index := GetElementIndex ( hackTanks , hack ) ;
94948: LD_ADDR_VAR 0 5
94952: PUSH
94953: LD_EXP 164
94957: PPUSH
94958: LD_VAR 0 1
94962: PPUSH
94963: CALL 18289 0 2
94967: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
94968: LD_ADDR_VAR 0 4
94972: PUSH
94973: DOUBLE
94974: LD_INT 1
94976: DEC
94977: ST_TO_ADDR
94978: LD_EXP 165
94982: PUSH
94983: LD_VAR 0 5
94987: ARRAY
94988: PUSH
94989: FOR_TO
94990: IFFALSE 95031
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
94992: LD_EXP 165
94996: PUSH
94997: LD_VAR 0 5
95001: ARRAY
95002: PUSH
95003: LD_VAR 0 4
95007: ARRAY
95008: PUSH
95009: LD_INT 1
95011: ARRAY
95012: PUSH
95013: LD_VAR 0 2
95017: EQUAL
95018: IFFALSE 95029
// KillUnit ( vehicle ) ;
95020: LD_VAR 0 2
95024: PPUSH
95025: CALL_OW 66
95029: GO 94989
95031: POP
95032: POP
// end ; end_of_file
95033: LD_VAR 0 3
95037: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
95038: LD_INT 0
95040: PPUSH
95041: PPUSH
95042: PPUSH
95043: PPUSH
95044: PPUSH
95045: PPUSH
95046: PPUSH
95047: PPUSH
95048: PPUSH
95049: PPUSH
95050: PPUSH
95051: PPUSH
95052: PPUSH
95053: PPUSH
95054: PPUSH
95055: PPUSH
95056: PPUSH
95057: PPUSH
95058: PPUSH
95059: PPUSH
95060: PPUSH
95061: PPUSH
95062: PPUSH
95063: PPUSH
95064: PPUSH
95065: PPUSH
95066: PPUSH
95067: PPUSH
95068: PPUSH
95069: PPUSH
95070: PPUSH
95071: PPUSH
95072: PPUSH
95073: PPUSH
// if not list then
95074: LD_VAR 0 1
95078: NOT
95079: IFFALSE 95083
// exit ;
95081: GO 99742
// base := list [ 1 ] ;
95083: LD_ADDR_VAR 0 3
95087: PUSH
95088: LD_VAR 0 1
95092: PUSH
95093: LD_INT 1
95095: ARRAY
95096: ST_TO_ADDR
// group := list [ 2 ] ;
95097: LD_ADDR_VAR 0 4
95101: PUSH
95102: LD_VAR 0 1
95106: PUSH
95107: LD_INT 2
95109: ARRAY
95110: ST_TO_ADDR
// path := list [ 3 ] ;
95111: LD_ADDR_VAR 0 5
95115: PUSH
95116: LD_VAR 0 1
95120: PUSH
95121: LD_INT 3
95123: ARRAY
95124: ST_TO_ADDR
// flags := list [ 4 ] ;
95125: LD_ADDR_VAR 0 6
95129: PUSH
95130: LD_VAR 0 1
95134: PUSH
95135: LD_INT 4
95137: ARRAY
95138: ST_TO_ADDR
// mined := [ ] ;
95139: LD_ADDR_VAR 0 27
95143: PUSH
95144: EMPTY
95145: ST_TO_ADDR
// bombed := [ ] ;
95146: LD_ADDR_VAR 0 28
95150: PUSH
95151: EMPTY
95152: ST_TO_ADDR
// healers := [ ] ;
95153: LD_ADDR_VAR 0 31
95157: PUSH
95158: EMPTY
95159: ST_TO_ADDR
// to_heal := [ ] ;
95160: LD_ADDR_VAR 0 30
95164: PUSH
95165: EMPTY
95166: ST_TO_ADDR
// repairs := [ ] ;
95167: LD_ADDR_VAR 0 33
95171: PUSH
95172: EMPTY
95173: ST_TO_ADDR
// to_repair := [ ] ;
95174: LD_ADDR_VAR 0 32
95178: PUSH
95179: EMPTY
95180: ST_TO_ADDR
// if not group or not path then
95181: LD_VAR 0 4
95185: NOT
95186: PUSH
95187: LD_VAR 0 5
95191: NOT
95192: OR
95193: IFFALSE 95197
// exit ;
95195: GO 99742
// side := GetSide ( group [ 1 ] ) ;
95197: LD_ADDR_VAR 0 35
95201: PUSH
95202: LD_VAR 0 4
95206: PUSH
95207: LD_INT 1
95209: ARRAY
95210: PPUSH
95211: CALL_OW 255
95215: ST_TO_ADDR
// if flags then
95216: LD_VAR 0 6
95220: IFFALSE 95364
// begin f_ignore_area := flags [ 1 ] ;
95222: LD_ADDR_VAR 0 17
95226: PUSH
95227: LD_VAR 0 6
95231: PUSH
95232: LD_INT 1
95234: ARRAY
95235: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
95236: LD_ADDR_VAR 0 18
95240: PUSH
95241: LD_VAR 0 6
95245: PUSH
95246: LD_INT 2
95248: ARRAY
95249: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
95250: LD_ADDR_VAR 0 19
95254: PUSH
95255: LD_VAR 0 6
95259: PUSH
95260: LD_INT 3
95262: ARRAY
95263: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
95264: LD_ADDR_VAR 0 20
95268: PUSH
95269: LD_VAR 0 6
95273: PUSH
95274: LD_INT 4
95276: ARRAY
95277: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
95278: LD_ADDR_VAR 0 21
95282: PUSH
95283: LD_VAR 0 6
95287: PUSH
95288: LD_INT 5
95290: ARRAY
95291: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
95292: LD_ADDR_VAR 0 22
95296: PUSH
95297: LD_VAR 0 6
95301: PUSH
95302: LD_INT 6
95304: ARRAY
95305: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
95306: LD_ADDR_VAR 0 23
95310: PUSH
95311: LD_VAR 0 6
95315: PUSH
95316: LD_INT 7
95318: ARRAY
95319: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
95320: LD_ADDR_VAR 0 24
95324: PUSH
95325: LD_VAR 0 6
95329: PUSH
95330: LD_INT 8
95332: ARRAY
95333: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
95334: LD_ADDR_VAR 0 25
95338: PUSH
95339: LD_VAR 0 6
95343: PUSH
95344: LD_INT 9
95346: ARRAY
95347: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
95348: LD_ADDR_VAR 0 26
95352: PUSH
95353: LD_VAR 0 6
95357: PUSH
95358: LD_INT 10
95360: ARRAY
95361: ST_TO_ADDR
// end else
95362: GO 95444
// begin f_ignore_area := false ;
95364: LD_ADDR_VAR 0 17
95368: PUSH
95369: LD_INT 0
95371: ST_TO_ADDR
// f_capture := false ;
95372: LD_ADDR_VAR 0 18
95376: PUSH
95377: LD_INT 0
95379: ST_TO_ADDR
// f_ignore_civ := false ;
95380: LD_ADDR_VAR 0 19
95384: PUSH
95385: LD_INT 0
95387: ST_TO_ADDR
// f_murder := false ;
95388: LD_ADDR_VAR 0 20
95392: PUSH
95393: LD_INT 0
95395: ST_TO_ADDR
// f_mines := false ;
95396: LD_ADDR_VAR 0 21
95400: PUSH
95401: LD_INT 0
95403: ST_TO_ADDR
// f_repair := false ;
95404: LD_ADDR_VAR 0 22
95408: PUSH
95409: LD_INT 0
95411: ST_TO_ADDR
// f_heal := false ;
95412: LD_ADDR_VAR 0 23
95416: PUSH
95417: LD_INT 0
95419: ST_TO_ADDR
// f_spacetime := false ;
95420: LD_ADDR_VAR 0 24
95424: PUSH
95425: LD_INT 0
95427: ST_TO_ADDR
// f_attack_depot := false ;
95428: LD_ADDR_VAR 0 25
95432: PUSH
95433: LD_INT 0
95435: ST_TO_ADDR
// f_crawl := false ;
95436: LD_ADDR_VAR 0 26
95440: PUSH
95441: LD_INT 0
95443: ST_TO_ADDR
// end ; if f_heal then
95444: LD_VAR 0 23
95448: IFFALSE 95475
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
95450: LD_ADDR_VAR 0 31
95454: PUSH
95455: LD_VAR 0 4
95459: PPUSH
95460: LD_INT 25
95462: PUSH
95463: LD_INT 4
95465: PUSH
95466: EMPTY
95467: LIST
95468: LIST
95469: PPUSH
95470: CALL_OW 72
95474: ST_TO_ADDR
// if f_repair then
95475: LD_VAR 0 22
95479: IFFALSE 95506
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
95481: LD_ADDR_VAR 0 33
95485: PUSH
95486: LD_VAR 0 4
95490: PPUSH
95491: LD_INT 25
95493: PUSH
95494: LD_INT 3
95496: PUSH
95497: EMPTY
95498: LIST
95499: LIST
95500: PPUSH
95501: CALL_OW 72
95505: ST_TO_ADDR
// units_path := [ ] ;
95506: LD_ADDR_VAR 0 16
95510: PUSH
95511: EMPTY
95512: ST_TO_ADDR
// for i = 1 to group do
95513: LD_ADDR_VAR 0 7
95517: PUSH
95518: DOUBLE
95519: LD_INT 1
95521: DEC
95522: ST_TO_ADDR
95523: LD_VAR 0 4
95527: PUSH
95528: FOR_TO
95529: IFFALSE 95558
// units_path := Replace ( units_path , i , path ) ;
95531: LD_ADDR_VAR 0 16
95535: PUSH
95536: LD_VAR 0 16
95540: PPUSH
95541: LD_VAR 0 7
95545: PPUSH
95546: LD_VAR 0 5
95550: PPUSH
95551: CALL_OW 1
95555: ST_TO_ADDR
95556: GO 95528
95558: POP
95559: POP
// repeat for i = group downto 1 do
95560: LD_ADDR_VAR 0 7
95564: PUSH
95565: DOUBLE
95566: LD_VAR 0 4
95570: INC
95571: ST_TO_ADDR
95572: LD_INT 1
95574: PUSH
95575: FOR_DOWNTO
95576: IFFALSE 99698
// begin wait ( 5 ) ;
95578: LD_INT 5
95580: PPUSH
95581: CALL_OW 67
// tmp := [ ] ;
95585: LD_ADDR_VAR 0 14
95589: PUSH
95590: EMPTY
95591: ST_TO_ADDR
// attacking := false ;
95592: LD_ADDR_VAR 0 29
95596: PUSH
95597: LD_INT 0
95599: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
95600: LD_VAR 0 4
95604: PUSH
95605: LD_VAR 0 7
95609: ARRAY
95610: PPUSH
95611: CALL_OW 301
95615: PUSH
95616: LD_VAR 0 4
95620: PUSH
95621: LD_VAR 0 7
95625: ARRAY
95626: NOT
95627: OR
95628: IFFALSE 95737
// begin if GetType ( group [ i ] ) = unit_human then
95630: LD_VAR 0 4
95634: PUSH
95635: LD_VAR 0 7
95639: ARRAY
95640: PPUSH
95641: CALL_OW 247
95645: PUSH
95646: LD_INT 1
95648: EQUAL
95649: IFFALSE 95695
// begin to_heal := to_heal diff group [ i ] ;
95651: LD_ADDR_VAR 0 30
95655: PUSH
95656: LD_VAR 0 30
95660: PUSH
95661: LD_VAR 0 4
95665: PUSH
95666: LD_VAR 0 7
95670: ARRAY
95671: DIFF
95672: ST_TO_ADDR
// healers := healers diff group [ i ] ;
95673: LD_ADDR_VAR 0 31
95677: PUSH
95678: LD_VAR 0 31
95682: PUSH
95683: LD_VAR 0 4
95687: PUSH
95688: LD_VAR 0 7
95692: ARRAY
95693: DIFF
95694: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
95695: LD_ADDR_VAR 0 4
95699: PUSH
95700: LD_VAR 0 4
95704: PPUSH
95705: LD_VAR 0 7
95709: PPUSH
95710: CALL_OW 3
95714: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
95715: LD_ADDR_VAR 0 16
95719: PUSH
95720: LD_VAR 0 16
95724: PPUSH
95725: LD_VAR 0 7
95729: PPUSH
95730: CALL_OW 3
95734: ST_TO_ADDR
// continue ;
95735: GO 95575
// end ; if f_repair then
95737: LD_VAR 0 22
95741: IFFALSE 96230
// begin if GetType ( group [ i ] ) = unit_vehicle then
95743: LD_VAR 0 4
95747: PUSH
95748: LD_VAR 0 7
95752: ARRAY
95753: PPUSH
95754: CALL_OW 247
95758: PUSH
95759: LD_INT 2
95761: EQUAL
95762: IFFALSE 95952
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
95764: LD_VAR 0 4
95768: PUSH
95769: LD_VAR 0 7
95773: ARRAY
95774: PPUSH
95775: CALL_OW 256
95779: PUSH
95780: LD_INT 700
95782: LESS
95783: PUSH
95784: LD_VAR 0 4
95788: PUSH
95789: LD_VAR 0 7
95793: ARRAY
95794: PUSH
95795: LD_VAR 0 32
95799: IN
95800: NOT
95801: AND
95802: IFFALSE 95826
// to_repair := to_repair union group [ i ] ;
95804: LD_ADDR_VAR 0 32
95808: PUSH
95809: LD_VAR 0 32
95813: PUSH
95814: LD_VAR 0 4
95818: PUSH
95819: LD_VAR 0 7
95823: ARRAY
95824: UNION
95825: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
95826: LD_VAR 0 4
95830: PUSH
95831: LD_VAR 0 7
95835: ARRAY
95836: PPUSH
95837: CALL_OW 256
95841: PUSH
95842: LD_INT 1000
95844: EQUAL
95845: PUSH
95846: LD_VAR 0 4
95850: PUSH
95851: LD_VAR 0 7
95855: ARRAY
95856: PUSH
95857: LD_VAR 0 32
95861: IN
95862: AND
95863: IFFALSE 95887
// to_repair := to_repair diff group [ i ] ;
95865: LD_ADDR_VAR 0 32
95869: PUSH
95870: LD_VAR 0 32
95874: PUSH
95875: LD_VAR 0 4
95879: PUSH
95880: LD_VAR 0 7
95884: ARRAY
95885: DIFF
95886: ST_TO_ADDR
// if group [ i ] in to_repair then
95887: LD_VAR 0 4
95891: PUSH
95892: LD_VAR 0 7
95896: ARRAY
95897: PUSH
95898: LD_VAR 0 32
95902: IN
95903: IFFALSE 95950
// begin if not IsInArea ( group [ i ] , f_repair ) then
95905: LD_VAR 0 4
95909: PUSH
95910: LD_VAR 0 7
95914: ARRAY
95915: PPUSH
95916: LD_VAR 0 22
95920: PPUSH
95921: CALL_OW 308
95925: NOT
95926: IFFALSE 95948
// ComMoveToArea ( group [ i ] , f_repair ) ;
95928: LD_VAR 0 4
95932: PUSH
95933: LD_VAR 0 7
95937: ARRAY
95938: PPUSH
95939: LD_VAR 0 22
95943: PPUSH
95944: CALL_OW 113
// continue ;
95948: GO 95575
// end ; end else
95950: GO 96230
// if group [ i ] in repairs then
95952: LD_VAR 0 4
95956: PUSH
95957: LD_VAR 0 7
95961: ARRAY
95962: PUSH
95963: LD_VAR 0 33
95967: IN
95968: IFFALSE 96230
// begin if IsInUnit ( group [ i ] ) then
95970: LD_VAR 0 4
95974: PUSH
95975: LD_VAR 0 7
95979: ARRAY
95980: PPUSH
95981: CALL_OW 310
95985: IFFALSE 96053
// begin z := IsInUnit ( group [ i ] ) ;
95987: LD_ADDR_VAR 0 13
95991: PUSH
95992: LD_VAR 0 4
95996: PUSH
95997: LD_VAR 0 7
96001: ARRAY
96002: PPUSH
96003: CALL_OW 310
96007: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
96008: LD_VAR 0 13
96012: PUSH
96013: LD_VAR 0 32
96017: IN
96018: PUSH
96019: LD_VAR 0 13
96023: PPUSH
96024: LD_VAR 0 22
96028: PPUSH
96029: CALL_OW 308
96033: AND
96034: IFFALSE 96051
// ComExitVehicle ( group [ i ] ) ;
96036: LD_VAR 0 4
96040: PUSH
96041: LD_VAR 0 7
96045: ARRAY
96046: PPUSH
96047: CALL_OW 121
// end else
96051: GO 96230
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
96053: LD_ADDR_VAR 0 13
96057: PUSH
96058: LD_VAR 0 4
96062: PPUSH
96063: LD_INT 95
96065: PUSH
96066: LD_VAR 0 22
96070: PUSH
96071: EMPTY
96072: LIST
96073: LIST
96074: PUSH
96075: LD_INT 58
96077: PUSH
96078: EMPTY
96079: LIST
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: PPUSH
96085: CALL_OW 72
96089: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
96090: LD_VAR 0 4
96094: PUSH
96095: LD_VAR 0 7
96099: ARRAY
96100: PPUSH
96101: CALL_OW 314
96105: NOT
96106: IFFALSE 96228
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
96108: LD_ADDR_VAR 0 10
96112: PUSH
96113: LD_VAR 0 13
96117: PPUSH
96118: LD_VAR 0 4
96122: PUSH
96123: LD_VAR 0 7
96127: ARRAY
96128: PPUSH
96129: CALL_OW 74
96133: ST_TO_ADDR
// if not x then
96134: LD_VAR 0 10
96138: NOT
96139: IFFALSE 96143
// continue ;
96141: GO 95575
// if GetLives ( x ) < 1000 then
96143: LD_VAR 0 10
96147: PPUSH
96148: CALL_OW 256
96152: PUSH
96153: LD_INT 1000
96155: LESS
96156: IFFALSE 96180
// ComRepairVehicle ( group [ i ] , x ) else
96158: LD_VAR 0 4
96162: PUSH
96163: LD_VAR 0 7
96167: ARRAY
96168: PPUSH
96169: LD_VAR 0 10
96173: PPUSH
96174: CALL_OW 129
96178: GO 96228
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
96180: LD_VAR 0 23
96184: PUSH
96185: LD_VAR 0 4
96189: PUSH
96190: LD_VAR 0 7
96194: ARRAY
96195: PPUSH
96196: CALL_OW 256
96200: PUSH
96201: LD_INT 1000
96203: LESS
96204: AND
96205: NOT
96206: IFFALSE 96228
// ComEnterUnit ( group [ i ] , x ) ;
96208: LD_VAR 0 4
96212: PUSH
96213: LD_VAR 0 7
96217: ARRAY
96218: PPUSH
96219: LD_VAR 0 10
96223: PPUSH
96224: CALL_OW 120
// end ; continue ;
96228: GO 95575
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
96230: LD_VAR 0 23
96234: PUSH
96235: LD_VAR 0 4
96239: PUSH
96240: LD_VAR 0 7
96244: ARRAY
96245: PPUSH
96246: CALL_OW 247
96250: PUSH
96251: LD_INT 1
96253: EQUAL
96254: AND
96255: IFFALSE 96733
// begin if group [ i ] in healers then
96257: LD_VAR 0 4
96261: PUSH
96262: LD_VAR 0 7
96266: ARRAY
96267: PUSH
96268: LD_VAR 0 31
96272: IN
96273: IFFALSE 96546
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
96275: LD_VAR 0 4
96279: PUSH
96280: LD_VAR 0 7
96284: ARRAY
96285: PPUSH
96286: LD_VAR 0 23
96290: PPUSH
96291: CALL_OW 308
96295: NOT
96296: PUSH
96297: LD_VAR 0 4
96301: PUSH
96302: LD_VAR 0 7
96306: ARRAY
96307: PPUSH
96308: CALL_OW 314
96312: NOT
96313: AND
96314: IFFALSE 96338
// ComMoveToArea ( group [ i ] , f_heal ) else
96316: LD_VAR 0 4
96320: PUSH
96321: LD_VAR 0 7
96325: ARRAY
96326: PPUSH
96327: LD_VAR 0 23
96331: PPUSH
96332: CALL_OW 113
96336: GO 96544
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
96338: LD_VAR 0 4
96342: PUSH
96343: LD_VAR 0 7
96347: ARRAY
96348: PPUSH
96349: CALL 46876 0 1
96353: PPUSH
96354: CALL_OW 256
96358: PUSH
96359: LD_INT 1000
96361: EQUAL
96362: IFFALSE 96381
// ComStop ( group [ i ] ) else
96364: LD_VAR 0 4
96368: PUSH
96369: LD_VAR 0 7
96373: ARRAY
96374: PPUSH
96375: CALL_OW 141
96379: GO 96544
// if not HasTask ( group [ i ] ) and to_heal then
96381: LD_VAR 0 4
96385: PUSH
96386: LD_VAR 0 7
96390: ARRAY
96391: PPUSH
96392: CALL_OW 314
96396: NOT
96397: PUSH
96398: LD_VAR 0 30
96402: AND
96403: IFFALSE 96544
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
96405: LD_ADDR_VAR 0 13
96409: PUSH
96410: LD_VAR 0 30
96414: PPUSH
96415: LD_INT 3
96417: PUSH
96418: LD_INT 54
96420: PUSH
96421: EMPTY
96422: LIST
96423: PUSH
96424: EMPTY
96425: LIST
96426: LIST
96427: PPUSH
96428: CALL_OW 72
96432: PPUSH
96433: LD_VAR 0 4
96437: PUSH
96438: LD_VAR 0 7
96442: ARRAY
96443: PPUSH
96444: CALL_OW 74
96448: ST_TO_ADDR
// if z then
96449: LD_VAR 0 13
96453: IFFALSE 96544
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
96455: LD_INT 91
96457: PUSH
96458: LD_VAR 0 13
96462: PUSH
96463: LD_INT 10
96465: PUSH
96466: EMPTY
96467: LIST
96468: LIST
96469: LIST
96470: PUSH
96471: LD_INT 81
96473: PUSH
96474: LD_VAR 0 13
96478: PPUSH
96479: CALL_OW 255
96483: PUSH
96484: EMPTY
96485: LIST
96486: LIST
96487: PUSH
96488: EMPTY
96489: LIST
96490: LIST
96491: PPUSH
96492: CALL_OW 69
96496: PUSH
96497: LD_INT 0
96499: EQUAL
96500: IFFALSE 96524
// ComHeal ( group [ i ] , z ) else
96502: LD_VAR 0 4
96506: PUSH
96507: LD_VAR 0 7
96511: ARRAY
96512: PPUSH
96513: LD_VAR 0 13
96517: PPUSH
96518: CALL_OW 128
96522: GO 96544
// ComMoveToArea ( group [ i ] , f_heal ) ;
96524: LD_VAR 0 4
96528: PUSH
96529: LD_VAR 0 7
96533: ARRAY
96534: PPUSH
96535: LD_VAR 0 23
96539: PPUSH
96540: CALL_OW 113
// end ; continue ;
96544: GO 95575
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
96546: LD_VAR 0 4
96550: PUSH
96551: LD_VAR 0 7
96555: ARRAY
96556: PPUSH
96557: CALL_OW 256
96561: PUSH
96562: LD_INT 700
96564: LESS
96565: PUSH
96566: LD_VAR 0 4
96570: PUSH
96571: LD_VAR 0 7
96575: ARRAY
96576: PUSH
96577: LD_VAR 0 30
96581: IN
96582: NOT
96583: AND
96584: IFFALSE 96608
// to_heal := to_heal union group [ i ] ;
96586: LD_ADDR_VAR 0 30
96590: PUSH
96591: LD_VAR 0 30
96595: PUSH
96596: LD_VAR 0 4
96600: PUSH
96601: LD_VAR 0 7
96605: ARRAY
96606: UNION
96607: ST_TO_ADDR
// if group [ i ] in to_heal then
96608: LD_VAR 0 4
96612: PUSH
96613: LD_VAR 0 7
96617: ARRAY
96618: PUSH
96619: LD_VAR 0 30
96623: IN
96624: IFFALSE 96733
// begin if GetLives ( group [ i ] ) = 1000 then
96626: LD_VAR 0 4
96630: PUSH
96631: LD_VAR 0 7
96635: ARRAY
96636: PPUSH
96637: CALL_OW 256
96641: PUSH
96642: LD_INT 1000
96644: EQUAL
96645: IFFALSE 96671
// to_heal := to_heal diff group [ i ] else
96647: LD_ADDR_VAR 0 30
96651: PUSH
96652: LD_VAR 0 30
96656: PUSH
96657: LD_VAR 0 4
96661: PUSH
96662: LD_VAR 0 7
96666: ARRAY
96667: DIFF
96668: ST_TO_ADDR
96669: GO 96733
// begin if not IsInArea ( group [ i ] , to_heal ) then
96671: LD_VAR 0 4
96675: PUSH
96676: LD_VAR 0 7
96680: ARRAY
96681: PPUSH
96682: LD_VAR 0 30
96686: PPUSH
96687: CALL_OW 308
96691: NOT
96692: IFFALSE 96716
// ComMoveToArea ( group [ i ] , f_heal ) else
96694: LD_VAR 0 4
96698: PUSH
96699: LD_VAR 0 7
96703: ARRAY
96704: PPUSH
96705: LD_VAR 0 23
96709: PPUSH
96710: CALL_OW 113
96714: GO 96731
// ComHold ( group [ i ] ) ;
96716: LD_VAR 0 4
96720: PUSH
96721: LD_VAR 0 7
96725: ARRAY
96726: PPUSH
96727: CALL_OW 140
// continue ;
96731: GO 95575
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
96733: LD_VAR 0 4
96737: PUSH
96738: LD_VAR 0 7
96742: ARRAY
96743: PPUSH
96744: LD_INT 10
96746: PPUSH
96747: CALL 45296 0 2
96751: NOT
96752: PUSH
96753: LD_VAR 0 16
96757: PUSH
96758: LD_VAR 0 7
96762: ARRAY
96763: PUSH
96764: EMPTY
96765: EQUAL
96766: NOT
96767: AND
96768: IFFALSE 97034
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
96770: LD_VAR 0 4
96774: PUSH
96775: LD_VAR 0 7
96779: ARRAY
96780: PPUSH
96781: CALL_OW 262
96785: PUSH
96786: LD_INT 1
96788: PUSH
96789: LD_INT 2
96791: PUSH
96792: EMPTY
96793: LIST
96794: LIST
96795: IN
96796: IFFALSE 96837
// if GetFuel ( group [ i ] ) < 10 then
96798: LD_VAR 0 4
96802: PUSH
96803: LD_VAR 0 7
96807: ARRAY
96808: PPUSH
96809: CALL_OW 261
96813: PUSH
96814: LD_INT 10
96816: LESS
96817: IFFALSE 96837
// SetFuel ( group [ i ] , 12 ) ;
96819: LD_VAR 0 4
96823: PUSH
96824: LD_VAR 0 7
96828: ARRAY
96829: PPUSH
96830: LD_INT 12
96832: PPUSH
96833: CALL_OW 240
// if units_path [ i ] then
96837: LD_VAR 0 16
96841: PUSH
96842: LD_VAR 0 7
96846: ARRAY
96847: IFFALSE 97032
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
96849: LD_VAR 0 4
96853: PUSH
96854: LD_VAR 0 7
96858: ARRAY
96859: PPUSH
96860: LD_VAR 0 16
96864: PUSH
96865: LD_VAR 0 7
96869: ARRAY
96870: PUSH
96871: LD_INT 1
96873: ARRAY
96874: PUSH
96875: LD_INT 1
96877: ARRAY
96878: PPUSH
96879: LD_VAR 0 16
96883: PUSH
96884: LD_VAR 0 7
96888: ARRAY
96889: PUSH
96890: LD_INT 1
96892: ARRAY
96893: PUSH
96894: LD_INT 2
96896: ARRAY
96897: PPUSH
96898: CALL_OW 297
96902: PUSH
96903: LD_INT 6
96905: GREATER
96906: IFFALSE 96981
// begin if not HasTask ( group [ i ] ) then
96908: LD_VAR 0 4
96912: PUSH
96913: LD_VAR 0 7
96917: ARRAY
96918: PPUSH
96919: CALL_OW 314
96923: NOT
96924: IFFALSE 96979
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
96926: LD_VAR 0 4
96930: PUSH
96931: LD_VAR 0 7
96935: ARRAY
96936: PPUSH
96937: LD_VAR 0 16
96941: PUSH
96942: LD_VAR 0 7
96946: ARRAY
96947: PUSH
96948: LD_INT 1
96950: ARRAY
96951: PUSH
96952: LD_INT 1
96954: ARRAY
96955: PPUSH
96956: LD_VAR 0 16
96960: PUSH
96961: LD_VAR 0 7
96965: ARRAY
96966: PUSH
96967: LD_INT 1
96969: ARRAY
96970: PUSH
96971: LD_INT 2
96973: ARRAY
96974: PPUSH
96975: CALL_OW 114
// end else
96979: GO 97032
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
96981: LD_ADDR_VAR 0 15
96985: PUSH
96986: LD_VAR 0 16
96990: PUSH
96991: LD_VAR 0 7
96995: ARRAY
96996: PPUSH
96997: LD_INT 1
96999: PPUSH
97000: CALL_OW 3
97004: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
97005: LD_ADDR_VAR 0 16
97009: PUSH
97010: LD_VAR 0 16
97014: PPUSH
97015: LD_VAR 0 7
97019: PPUSH
97020: LD_VAR 0 15
97024: PPUSH
97025: CALL_OW 1
97029: ST_TO_ADDR
// continue ;
97030: GO 95575
// end ; end ; end else
97032: GO 99696
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
97034: LD_ADDR_VAR 0 14
97038: PUSH
97039: LD_INT 81
97041: PUSH
97042: LD_VAR 0 4
97046: PUSH
97047: LD_VAR 0 7
97051: ARRAY
97052: PPUSH
97053: CALL_OW 255
97057: PUSH
97058: EMPTY
97059: LIST
97060: LIST
97061: PPUSH
97062: CALL_OW 69
97066: ST_TO_ADDR
// if not tmp then
97067: LD_VAR 0 14
97071: NOT
97072: IFFALSE 97076
// continue ;
97074: GO 95575
// if f_ignore_area then
97076: LD_VAR 0 17
97080: IFFALSE 97168
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
97082: LD_ADDR_VAR 0 15
97086: PUSH
97087: LD_VAR 0 14
97091: PPUSH
97092: LD_INT 3
97094: PUSH
97095: LD_INT 92
97097: PUSH
97098: LD_VAR 0 17
97102: PUSH
97103: LD_INT 1
97105: ARRAY
97106: PUSH
97107: LD_VAR 0 17
97111: PUSH
97112: LD_INT 2
97114: ARRAY
97115: PUSH
97116: LD_VAR 0 17
97120: PUSH
97121: LD_INT 3
97123: ARRAY
97124: PUSH
97125: EMPTY
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: PUSH
97131: EMPTY
97132: LIST
97133: LIST
97134: PPUSH
97135: CALL_OW 72
97139: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
97140: LD_VAR 0 14
97144: PUSH
97145: LD_VAR 0 15
97149: DIFF
97150: IFFALSE 97168
// tmp := tmp diff tmp2 ;
97152: LD_ADDR_VAR 0 14
97156: PUSH
97157: LD_VAR 0 14
97161: PUSH
97162: LD_VAR 0 15
97166: DIFF
97167: ST_TO_ADDR
// end ; if not f_murder then
97168: LD_VAR 0 20
97172: NOT
97173: IFFALSE 97231
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
97175: LD_ADDR_VAR 0 15
97179: PUSH
97180: LD_VAR 0 14
97184: PPUSH
97185: LD_INT 3
97187: PUSH
97188: LD_INT 50
97190: PUSH
97191: EMPTY
97192: LIST
97193: PUSH
97194: EMPTY
97195: LIST
97196: LIST
97197: PPUSH
97198: CALL_OW 72
97202: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
97203: LD_VAR 0 14
97207: PUSH
97208: LD_VAR 0 15
97212: DIFF
97213: IFFALSE 97231
// tmp := tmp diff tmp2 ;
97215: LD_ADDR_VAR 0 14
97219: PUSH
97220: LD_VAR 0 14
97224: PUSH
97225: LD_VAR 0 15
97229: DIFF
97230: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
97231: LD_ADDR_VAR 0 14
97235: PUSH
97236: LD_VAR 0 4
97240: PUSH
97241: LD_VAR 0 7
97245: ARRAY
97246: PPUSH
97247: LD_VAR 0 14
97251: PPUSH
97252: LD_INT 1
97254: PPUSH
97255: LD_INT 1
97257: PPUSH
97258: CALL 18939 0 4
97262: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
97263: LD_VAR 0 4
97267: PUSH
97268: LD_VAR 0 7
97272: ARRAY
97273: PPUSH
97274: CALL_OW 257
97278: PUSH
97279: LD_INT 1
97281: EQUAL
97282: IFFALSE 97730
// begin if WantPlant ( group [ i ] ) then
97284: LD_VAR 0 4
97288: PUSH
97289: LD_VAR 0 7
97293: ARRAY
97294: PPUSH
97295: CALL 18440 0 1
97299: IFFALSE 97303
// continue ;
97301: GO 95575
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
97303: LD_VAR 0 18
97307: PUSH
97308: LD_VAR 0 4
97312: PUSH
97313: LD_VAR 0 7
97317: ARRAY
97318: PPUSH
97319: CALL_OW 310
97323: NOT
97324: AND
97325: PUSH
97326: LD_VAR 0 14
97330: PUSH
97331: LD_INT 1
97333: ARRAY
97334: PUSH
97335: LD_VAR 0 14
97339: PPUSH
97340: LD_INT 21
97342: PUSH
97343: LD_INT 2
97345: PUSH
97346: EMPTY
97347: LIST
97348: LIST
97349: PUSH
97350: LD_INT 58
97352: PUSH
97353: EMPTY
97354: LIST
97355: PUSH
97356: EMPTY
97357: LIST
97358: LIST
97359: PPUSH
97360: CALL_OW 72
97364: IN
97365: AND
97366: IFFALSE 97402
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
97368: LD_VAR 0 4
97372: PUSH
97373: LD_VAR 0 7
97377: ARRAY
97378: PPUSH
97379: LD_VAR 0 14
97383: PUSH
97384: LD_INT 1
97386: ARRAY
97387: PPUSH
97388: CALL_OW 120
// attacking := true ;
97392: LD_ADDR_VAR 0 29
97396: PUSH
97397: LD_INT 1
97399: ST_TO_ADDR
// continue ;
97400: GO 95575
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
97402: LD_VAR 0 26
97406: PUSH
97407: LD_VAR 0 4
97411: PUSH
97412: LD_VAR 0 7
97416: ARRAY
97417: PPUSH
97418: CALL_OW 257
97422: PUSH
97423: LD_INT 1
97425: EQUAL
97426: AND
97427: PUSH
97428: LD_VAR 0 4
97432: PUSH
97433: LD_VAR 0 7
97437: ARRAY
97438: PPUSH
97439: CALL_OW 256
97443: PUSH
97444: LD_INT 800
97446: LESS
97447: AND
97448: PUSH
97449: LD_VAR 0 4
97453: PUSH
97454: LD_VAR 0 7
97458: ARRAY
97459: PPUSH
97460: CALL_OW 318
97464: NOT
97465: AND
97466: IFFALSE 97483
// ComCrawl ( group [ i ] ) ;
97468: LD_VAR 0 4
97472: PUSH
97473: LD_VAR 0 7
97477: ARRAY
97478: PPUSH
97479: CALL_OW 137
// if f_mines then
97483: LD_VAR 0 21
97487: IFFALSE 97730
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
97489: LD_VAR 0 14
97493: PUSH
97494: LD_INT 1
97496: ARRAY
97497: PPUSH
97498: CALL_OW 247
97502: PUSH
97503: LD_INT 3
97505: EQUAL
97506: PUSH
97507: LD_VAR 0 14
97511: PUSH
97512: LD_INT 1
97514: ARRAY
97515: PUSH
97516: LD_VAR 0 27
97520: IN
97521: NOT
97522: AND
97523: IFFALSE 97730
// begin x := GetX ( tmp [ 1 ] ) ;
97525: LD_ADDR_VAR 0 10
97529: PUSH
97530: LD_VAR 0 14
97534: PUSH
97535: LD_INT 1
97537: ARRAY
97538: PPUSH
97539: CALL_OW 250
97543: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
97544: LD_ADDR_VAR 0 11
97548: PUSH
97549: LD_VAR 0 14
97553: PUSH
97554: LD_INT 1
97556: ARRAY
97557: PPUSH
97558: CALL_OW 251
97562: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
97563: LD_ADDR_VAR 0 12
97567: PUSH
97568: LD_VAR 0 4
97572: PUSH
97573: LD_VAR 0 7
97577: ARRAY
97578: PPUSH
97579: CALL 45381 0 1
97583: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
97584: LD_VAR 0 4
97588: PUSH
97589: LD_VAR 0 7
97593: ARRAY
97594: PPUSH
97595: LD_VAR 0 10
97599: PPUSH
97600: LD_VAR 0 11
97604: PPUSH
97605: LD_VAR 0 14
97609: PUSH
97610: LD_INT 1
97612: ARRAY
97613: PPUSH
97614: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
97618: LD_VAR 0 4
97622: PUSH
97623: LD_VAR 0 7
97627: ARRAY
97628: PPUSH
97629: LD_VAR 0 10
97633: PPUSH
97634: LD_VAR 0 12
97638: PPUSH
97639: LD_INT 7
97641: PPUSH
97642: CALL_OW 272
97646: PPUSH
97647: LD_VAR 0 11
97651: PPUSH
97652: LD_VAR 0 12
97656: PPUSH
97657: LD_INT 7
97659: PPUSH
97660: CALL_OW 273
97664: PPUSH
97665: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
97669: LD_VAR 0 4
97673: PUSH
97674: LD_VAR 0 7
97678: ARRAY
97679: PPUSH
97680: LD_INT 71
97682: PPUSH
97683: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
97687: LD_ADDR_VAR 0 27
97691: PUSH
97692: LD_VAR 0 27
97696: PPUSH
97697: LD_VAR 0 27
97701: PUSH
97702: LD_INT 1
97704: PLUS
97705: PPUSH
97706: LD_VAR 0 14
97710: PUSH
97711: LD_INT 1
97713: ARRAY
97714: PPUSH
97715: CALL_OW 1
97719: ST_TO_ADDR
// attacking := true ;
97720: LD_ADDR_VAR 0 29
97724: PUSH
97725: LD_INT 1
97727: ST_TO_ADDR
// continue ;
97728: GO 95575
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
97730: LD_VAR 0 4
97734: PUSH
97735: LD_VAR 0 7
97739: ARRAY
97740: PPUSH
97741: CALL_OW 257
97745: PUSH
97746: LD_INT 17
97748: EQUAL
97749: PUSH
97750: LD_VAR 0 4
97754: PUSH
97755: LD_VAR 0 7
97759: ARRAY
97760: PPUSH
97761: CALL_OW 110
97765: PUSH
97766: LD_INT 71
97768: EQUAL
97769: NOT
97770: AND
97771: IFFALSE 97917
// begin attacking := false ;
97773: LD_ADDR_VAR 0 29
97777: PUSH
97778: LD_INT 0
97780: ST_TO_ADDR
// k := 5 ;
97781: LD_ADDR_VAR 0 9
97785: PUSH
97786: LD_INT 5
97788: ST_TO_ADDR
// if tmp < k then
97789: LD_VAR 0 14
97793: PUSH
97794: LD_VAR 0 9
97798: LESS
97799: IFFALSE 97811
// k := tmp ;
97801: LD_ADDR_VAR 0 9
97805: PUSH
97806: LD_VAR 0 14
97810: ST_TO_ADDR
// for j = 1 to k do
97811: LD_ADDR_VAR 0 8
97815: PUSH
97816: DOUBLE
97817: LD_INT 1
97819: DEC
97820: ST_TO_ADDR
97821: LD_VAR 0 9
97825: PUSH
97826: FOR_TO
97827: IFFALSE 97915
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
97829: LD_VAR 0 14
97833: PUSH
97834: LD_VAR 0 8
97838: ARRAY
97839: PUSH
97840: LD_VAR 0 14
97844: PPUSH
97845: LD_INT 58
97847: PUSH
97848: EMPTY
97849: LIST
97850: PPUSH
97851: CALL_OW 72
97855: IN
97856: NOT
97857: IFFALSE 97913
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
97859: LD_VAR 0 4
97863: PUSH
97864: LD_VAR 0 7
97868: ARRAY
97869: PPUSH
97870: LD_VAR 0 14
97874: PUSH
97875: LD_VAR 0 8
97879: ARRAY
97880: PPUSH
97881: CALL_OW 115
// attacking := true ;
97885: LD_ADDR_VAR 0 29
97889: PUSH
97890: LD_INT 1
97892: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
97893: LD_VAR 0 4
97897: PUSH
97898: LD_VAR 0 7
97902: ARRAY
97903: PPUSH
97904: LD_INT 71
97906: PPUSH
97907: CALL_OW 109
// continue ;
97911: GO 97826
// end ; end ;
97913: GO 97826
97915: POP
97916: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
97917: LD_VAR 0 4
97921: PUSH
97922: LD_VAR 0 7
97926: ARRAY
97927: PPUSH
97928: CALL_OW 257
97932: PUSH
97933: LD_INT 8
97935: EQUAL
97936: PUSH
97937: LD_VAR 0 4
97941: PUSH
97942: LD_VAR 0 7
97946: ARRAY
97947: PPUSH
97948: CALL_OW 264
97952: PUSH
97953: LD_INT 28
97955: PUSH
97956: LD_INT 45
97958: PUSH
97959: LD_INT 7
97961: PUSH
97962: LD_INT 47
97964: PUSH
97965: EMPTY
97966: LIST
97967: LIST
97968: LIST
97969: LIST
97970: IN
97971: OR
97972: IFFALSE 98228
// begin attacking := false ;
97974: LD_ADDR_VAR 0 29
97978: PUSH
97979: LD_INT 0
97981: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
97982: LD_VAR 0 14
97986: PUSH
97987: LD_INT 1
97989: ARRAY
97990: PPUSH
97991: CALL_OW 266
97995: PUSH
97996: LD_INT 32
97998: PUSH
97999: LD_INT 31
98001: PUSH
98002: LD_INT 33
98004: PUSH
98005: LD_INT 4
98007: PUSH
98008: LD_INT 5
98010: PUSH
98011: EMPTY
98012: LIST
98013: LIST
98014: LIST
98015: LIST
98016: LIST
98017: IN
98018: IFFALSE 98204
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
98020: LD_ADDR_VAR 0 9
98024: PUSH
98025: LD_VAR 0 14
98029: PUSH
98030: LD_INT 1
98032: ARRAY
98033: PPUSH
98034: CALL_OW 266
98038: PPUSH
98039: LD_VAR 0 14
98043: PUSH
98044: LD_INT 1
98046: ARRAY
98047: PPUSH
98048: CALL_OW 250
98052: PPUSH
98053: LD_VAR 0 14
98057: PUSH
98058: LD_INT 1
98060: ARRAY
98061: PPUSH
98062: CALL_OW 251
98066: PPUSH
98067: LD_VAR 0 14
98071: PUSH
98072: LD_INT 1
98074: ARRAY
98075: PPUSH
98076: CALL_OW 254
98080: PPUSH
98081: LD_VAR 0 14
98085: PUSH
98086: LD_INT 1
98088: ARRAY
98089: PPUSH
98090: CALL_OW 248
98094: PPUSH
98095: LD_INT 0
98097: PPUSH
98098: CALL 26751 0 6
98102: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
98103: LD_ADDR_VAR 0 8
98107: PUSH
98108: LD_VAR 0 4
98112: PUSH
98113: LD_VAR 0 7
98117: ARRAY
98118: PPUSH
98119: LD_VAR 0 9
98123: PPUSH
98124: CALL 45421 0 2
98128: ST_TO_ADDR
// if j then
98129: LD_VAR 0 8
98133: IFFALSE 98202
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
98135: LD_VAR 0 8
98139: PUSH
98140: LD_INT 1
98142: ARRAY
98143: PPUSH
98144: LD_VAR 0 8
98148: PUSH
98149: LD_INT 2
98151: ARRAY
98152: PPUSH
98153: CALL_OW 488
98157: IFFALSE 98202
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
98159: LD_VAR 0 4
98163: PUSH
98164: LD_VAR 0 7
98168: ARRAY
98169: PPUSH
98170: LD_VAR 0 8
98174: PUSH
98175: LD_INT 1
98177: ARRAY
98178: PPUSH
98179: LD_VAR 0 8
98183: PUSH
98184: LD_INT 2
98186: ARRAY
98187: PPUSH
98188: CALL_OW 116
// attacking := true ;
98192: LD_ADDR_VAR 0 29
98196: PUSH
98197: LD_INT 1
98199: ST_TO_ADDR
// continue ;
98200: GO 95575
// end ; end else
98202: GO 98228
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
98204: LD_VAR 0 4
98208: PUSH
98209: LD_VAR 0 7
98213: ARRAY
98214: PPUSH
98215: LD_VAR 0 14
98219: PUSH
98220: LD_INT 1
98222: ARRAY
98223: PPUSH
98224: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
98228: LD_VAR 0 4
98232: PUSH
98233: LD_VAR 0 7
98237: ARRAY
98238: PPUSH
98239: CALL_OW 265
98243: PUSH
98244: LD_INT 11
98246: EQUAL
98247: IFFALSE 98525
// begin k := 10 ;
98249: LD_ADDR_VAR 0 9
98253: PUSH
98254: LD_INT 10
98256: ST_TO_ADDR
// x := 0 ;
98257: LD_ADDR_VAR 0 10
98261: PUSH
98262: LD_INT 0
98264: ST_TO_ADDR
// if tmp < k then
98265: LD_VAR 0 14
98269: PUSH
98270: LD_VAR 0 9
98274: LESS
98275: IFFALSE 98287
// k := tmp ;
98277: LD_ADDR_VAR 0 9
98281: PUSH
98282: LD_VAR 0 14
98286: ST_TO_ADDR
// for j = k downto 1 do
98287: LD_ADDR_VAR 0 8
98291: PUSH
98292: DOUBLE
98293: LD_VAR 0 9
98297: INC
98298: ST_TO_ADDR
98299: LD_INT 1
98301: PUSH
98302: FOR_DOWNTO
98303: IFFALSE 98378
// begin if GetType ( tmp [ j ] ) = unit_human then
98305: LD_VAR 0 14
98309: PUSH
98310: LD_VAR 0 8
98314: ARRAY
98315: PPUSH
98316: CALL_OW 247
98320: PUSH
98321: LD_INT 1
98323: EQUAL
98324: IFFALSE 98376
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
98326: LD_VAR 0 4
98330: PUSH
98331: LD_VAR 0 7
98335: ARRAY
98336: PPUSH
98337: LD_VAR 0 14
98341: PUSH
98342: LD_VAR 0 8
98346: ARRAY
98347: PPUSH
98348: CALL 45692 0 2
// x := tmp [ j ] ;
98352: LD_ADDR_VAR 0 10
98356: PUSH
98357: LD_VAR 0 14
98361: PUSH
98362: LD_VAR 0 8
98366: ARRAY
98367: ST_TO_ADDR
// attacking := true ;
98368: LD_ADDR_VAR 0 29
98372: PUSH
98373: LD_INT 1
98375: ST_TO_ADDR
// end ; end ;
98376: GO 98302
98378: POP
98379: POP
// if not x then
98380: LD_VAR 0 10
98384: NOT
98385: IFFALSE 98525
// begin attacking := true ;
98387: LD_ADDR_VAR 0 29
98391: PUSH
98392: LD_INT 1
98394: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
98395: LD_VAR 0 4
98399: PUSH
98400: LD_VAR 0 7
98404: ARRAY
98405: PPUSH
98406: CALL_OW 250
98410: PPUSH
98411: LD_VAR 0 4
98415: PUSH
98416: LD_VAR 0 7
98420: ARRAY
98421: PPUSH
98422: CALL_OW 251
98426: PPUSH
98427: CALL_OW 546
98431: PUSH
98432: LD_INT 2
98434: ARRAY
98435: PUSH
98436: LD_VAR 0 14
98440: PUSH
98441: LD_INT 1
98443: ARRAY
98444: PPUSH
98445: CALL_OW 250
98449: PPUSH
98450: LD_VAR 0 14
98454: PUSH
98455: LD_INT 1
98457: ARRAY
98458: PPUSH
98459: CALL_OW 251
98463: PPUSH
98464: CALL_OW 546
98468: PUSH
98469: LD_INT 2
98471: ARRAY
98472: EQUAL
98473: IFFALSE 98501
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
98475: LD_VAR 0 4
98479: PUSH
98480: LD_VAR 0 7
98484: ARRAY
98485: PPUSH
98486: LD_VAR 0 14
98490: PUSH
98491: LD_INT 1
98493: ARRAY
98494: PPUSH
98495: CALL 45692 0 2
98499: GO 98525
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
98501: LD_VAR 0 4
98505: PUSH
98506: LD_VAR 0 7
98510: ARRAY
98511: PPUSH
98512: LD_VAR 0 14
98516: PUSH
98517: LD_INT 1
98519: ARRAY
98520: PPUSH
98521: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
98525: LD_VAR 0 4
98529: PUSH
98530: LD_VAR 0 7
98534: ARRAY
98535: PPUSH
98536: CALL_OW 264
98540: PUSH
98541: LD_INT 29
98543: EQUAL
98544: IFFALSE 98910
// begin if WantsToAttack ( group [ i ] ) in bombed then
98546: LD_VAR 0 4
98550: PUSH
98551: LD_VAR 0 7
98555: ARRAY
98556: PPUSH
98557: CALL_OW 319
98561: PUSH
98562: LD_VAR 0 28
98566: IN
98567: IFFALSE 98571
// continue ;
98569: GO 95575
// k := 8 ;
98571: LD_ADDR_VAR 0 9
98575: PUSH
98576: LD_INT 8
98578: ST_TO_ADDR
// x := 0 ;
98579: LD_ADDR_VAR 0 10
98583: PUSH
98584: LD_INT 0
98586: ST_TO_ADDR
// if tmp < k then
98587: LD_VAR 0 14
98591: PUSH
98592: LD_VAR 0 9
98596: LESS
98597: IFFALSE 98609
// k := tmp ;
98599: LD_ADDR_VAR 0 9
98603: PUSH
98604: LD_VAR 0 14
98608: ST_TO_ADDR
// for j = 1 to k do
98609: LD_ADDR_VAR 0 8
98613: PUSH
98614: DOUBLE
98615: LD_INT 1
98617: DEC
98618: ST_TO_ADDR
98619: LD_VAR 0 9
98623: PUSH
98624: FOR_TO
98625: IFFALSE 98757
// begin if GetType ( tmp [ j ] ) = unit_building then
98627: LD_VAR 0 14
98631: PUSH
98632: LD_VAR 0 8
98636: ARRAY
98637: PPUSH
98638: CALL_OW 247
98642: PUSH
98643: LD_INT 3
98645: EQUAL
98646: IFFALSE 98755
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
98648: LD_VAR 0 14
98652: PUSH
98653: LD_VAR 0 8
98657: ARRAY
98658: PUSH
98659: LD_VAR 0 28
98663: IN
98664: NOT
98665: PUSH
98666: LD_VAR 0 14
98670: PUSH
98671: LD_VAR 0 8
98675: ARRAY
98676: PPUSH
98677: CALL_OW 313
98681: AND
98682: IFFALSE 98755
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
98684: LD_VAR 0 4
98688: PUSH
98689: LD_VAR 0 7
98693: ARRAY
98694: PPUSH
98695: LD_VAR 0 14
98699: PUSH
98700: LD_VAR 0 8
98704: ARRAY
98705: PPUSH
98706: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
98710: LD_ADDR_VAR 0 28
98714: PUSH
98715: LD_VAR 0 28
98719: PPUSH
98720: LD_VAR 0 28
98724: PUSH
98725: LD_INT 1
98727: PLUS
98728: PPUSH
98729: LD_VAR 0 14
98733: PUSH
98734: LD_VAR 0 8
98738: ARRAY
98739: PPUSH
98740: CALL_OW 1
98744: ST_TO_ADDR
// attacking := true ;
98745: LD_ADDR_VAR 0 29
98749: PUSH
98750: LD_INT 1
98752: ST_TO_ADDR
// break ;
98753: GO 98757
// end ; end ;
98755: GO 98624
98757: POP
98758: POP
// if not attacking and f_attack_depot then
98759: LD_VAR 0 29
98763: NOT
98764: PUSH
98765: LD_VAR 0 25
98769: AND
98770: IFFALSE 98865
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
98772: LD_ADDR_VAR 0 13
98776: PUSH
98777: LD_VAR 0 14
98781: PPUSH
98782: LD_INT 2
98784: PUSH
98785: LD_INT 30
98787: PUSH
98788: LD_INT 0
98790: PUSH
98791: EMPTY
98792: LIST
98793: LIST
98794: PUSH
98795: LD_INT 30
98797: PUSH
98798: LD_INT 1
98800: PUSH
98801: EMPTY
98802: LIST
98803: LIST
98804: PUSH
98805: EMPTY
98806: LIST
98807: LIST
98808: LIST
98809: PPUSH
98810: CALL_OW 72
98814: ST_TO_ADDR
// if z then
98815: LD_VAR 0 13
98819: IFFALSE 98865
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
98821: LD_VAR 0 4
98825: PUSH
98826: LD_VAR 0 7
98830: ARRAY
98831: PPUSH
98832: LD_VAR 0 13
98836: PPUSH
98837: LD_VAR 0 4
98841: PUSH
98842: LD_VAR 0 7
98846: ARRAY
98847: PPUSH
98848: CALL_OW 74
98852: PPUSH
98853: CALL_OW 115
// attacking := true ;
98857: LD_ADDR_VAR 0 29
98861: PUSH
98862: LD_INT 1
98864: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
98865: LD_VAR 0 4
98869: PUSH
98870: LD_VAR 0 7
98874: ARRAY
98875: PPUSH
98876: CALL_OW 256
98880: PUSH
98881: LD_INT 500
98883: LESS
98884: IFFALSE 98910
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
98886: LD_VAR 0 4
98890: PUSH
98891: LD_VAR 0 7
98895: ARRAY
98896: PPUSH
98897: LD_VAR 0 14
98901: PUSH
98902: LD_INT 1
98904: ARRAY
98905: PPUSH
98906: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
98910: LD_VAR 0 4
98914: PUSH
98915: LD_VAR 0 7
98919: ARRAY
98920: PPUSH
98921: CALL_OW 264
98925: PUSH
98926: LD_INT 49
98928: EQUAL
98929: IFFALSE 99050
// begin if not HasTask ( group [ i ] ) then
98931: LD_VAR 0 4
98935: PUSH
98936: LD_VAR 0 7
98940: ARRAY
98941: PPUSH
98942: CALL_OW 314
98946: NOT
98947: IFFALSE 99050
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
98949: LD_ADDR_VAR 0 9
98953: PUSH
98954: LD_INT 81
98956: PUSH
98957: LD_VAR 0 4
98961: PUSH
98962: LD_VAR 0 7
98966: ARRAY
98967: PPUSH
98968: CALL_OW 255
98972: PUSH
98973: EMPTY
98974: LIST
98975: LIST
98976: PPUSH
98977: CALL_OW 69
98981: PPUSH
98982: LD_VAR 0 4
98986: PUSH
98987: LD_VAR 0 7
98991: ARRAY
98992: PPUSH
98993: CALL_OW 74
98997: ST_TO_ADDR
// if k then
98998: LD_VAR 0 9
99002: IFFALSE 99050
// if GetDistUnits ( group [ i ] , k ) > 10 then
99004: LD_VAR 0 4
99008: PUSH
99009: LD_VAR 0 7
99013: ARRAY
99014: PPUSH
99015: LD_VAR 0 9
99019: PPUSH
99020: CALL_OW 296
99024: PUSH
99025: LD_INT 10
99027: GREATER
99028: IFFALSE 99050
// ComMoveUnit ( group [ i ] , k ) ;
99030: LD_VAR 0 4
99034: PUSH
99035: LD_VAR 0 7
99039: ARRAY
99040: PPUSH
99041: LD_VAR 0 9
99045: PPUSH
99046: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
99050: LD_VAR 0 4
99054: PUSH
99055: LD_VAR 0 7
99059: ARRAY
99060: PPUSH
99061: CALL_OW 256
99065: PUSH
99066: LD_INT 250
99068: LESS
99069: PUSH
99070: LD_VAR 0 4
99074: PUSH
99075: LD_VAR 0 7
99079: ARRAY
99080: PUSH
99081: LD_INT 21
99083: PUSH
99084: LD_INT 2
99086: PUSH
99087: EMPTY
99088: LIST
99089: LIST
99090: PUSH
99091: LD_INT 23
99093: PUSH
99094: LD_INT 2
99096: PUSH
99097: EMPTY
99098: LIST
99099: LIST
99100: PUSH
99101: EMPTY
99102: LIST
99103: LIST
99104: PPUSH
99105: CALL_OW 69
99109: IN
99110: AND
99111: IFFALSE 99236
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
99113: LD_ADDR_VAR 0 9
99117: PUSH
99118: LD_OWVAR 3
99122: PUSH
99123: LD_VAR 0 4
99127: PUSH
99128: LD_VAR 0 7
99132: ARRAY
99133: DIFF
99134: PPUSH
99135: LD_VAR 0 4
99139: PUSH
99140: LD_VAR 0 7
99144: ARRAY
99145: PPUSH
99146: CALL_OW 74
99150: ST_TO_ADDR
// if not k then
99151: LD_VAR 0 9
99155: NOT
99156: IFFALSE 99160
// continue ;
99158: GO 95575
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
99160: LD_VAR 0 9
99164: PUSH
99165: LD_INT 81
99167: PUSH
99168: LD_VAR 0 4
99172: PUSH
99173: LD_VAR 0 7
99177: ARRAY
99178: PPUSH
99179: CALL_OW 255
99183: PUSH
99184: EMPTY
99185: LIST
99186: LIST
99187: PPUSH
99188: CALL_OW 69
99192: IN
99193: PUSH
99194: LD_VAR 0 9
99198: PPUSH
99199: LD_VAR 0 4
99203: PUSH
99204: LD_VAR 0 7
99208: ARRAY
99209: PPUSH
99210: CALL_OW 296
99214: PUSH
99215: LD_INT 5
99217: LESS
99218: AND
99219: IFFALSE 99236
// ComAutodestruct ( group [ i ] ) ;
99221: LD_VAR 0 4
99225: PUSH
99226: LD_VAR 0 7
99230: ARRAY
99231: PPUSH
99232: CALL 45590 0 1
// end ; if f_attack_depot then
99236: LD_VAR 0 25
99240: IFFALSE 99352
// begin k := 6 ;
99242: LD_ADDR_VAR 0 9
99246: PUSH
99247: LD_INT 6
99249: ST_TO_ADDR
// if tmp < k then
99250: LD_VAR 0 14
99254: PUSH
99255: LD_VAR 0 9
99259: LESS
99260: IFFALSE 99272
// k := tmp ;
99262: LD_ADDR_VAR 0 9
99266: PUSH
99267: LD_VAR 0 14
99271: ST_TO_ADDR
// for j = 1 to k do
99272: LD_ADDR_VAR 0 8
99276: PUSH
99277: DOUBLE
99278: LD_INT 1
99280: DEC
99281: ST_TO_ADDR
99282: LD_VAR 0 9
99286: PUSH
99287: FOR_TO
99288: IFFALSE 99350
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
99290: LD_VAR 0 8
99294: PPUSH
99295: CALL_OW 266
99299: PUSH
99300: LD_INT 0
99302: PUSH
99303: LD_INT 1
99305: PUSH
99306: EMPTY
99307: LIST
99308: LIST
99309: IN
99310: IFFALSE 99348
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
99312: LD_VAR 0 4
99316: PUSH
99317: LD_VAR 0 7
99321: ARRAY
99322: PPUSH
99323: LD_VAR 0 14
99327: PUSH
99328: LD_VAR 0 8
99332: ARRAY
99333: PPUSH
99334: CALL_OW 115
// attacking := true ;
99338: LD_ADDR_VAR 0 29
99342: PUSH
99343: LD_INT 1
99345: ST_TO_ADDR
// break ;
99346: GO 99350
// end ;
99348: GO 99287
99350: POP
99351: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
99352: LD_VAR 0 4
99356: PUSH
99357: LD_VAR 0 7
99361: ARRAY
99362: PPUSH
99363: CALL_OW 302
99367: PUSH
99368: LD_VAR 0 29
99372: NOT
99373: AND
99374: IFFALSE 99696
// begin if GetTag ( group [ i ] ) = 71 then
99376: LD_VAR 0 4
99380: PUSH
99381: LD_VAR 0 7
99385: ARRAY
99386: PPUSH
99387: CALL_OW 110
99391: PUSH
99392: LD_INT 71
99394: EQUAL
99395: IFFALSE 99436
// begin if HasTask ( group [ i ] ) then
99397: LD_VAR 0 4
99401: PUSH
99402: LD_VAR 0 7
99406: ARRAY
99407: PPUSH
99408: CALL_OW 314
99412: IFFALSE 99418
// continue else
99414: GO 95575
99416: GO 99436
// SetTag ( group [ i ] , 0 ) ;
99418: LD_VAR 0 4
99422: PUSH
99423: LD_VAR 0 7
99427: ARRAY
99428: PPUSH
99429: LD_INT 0
99431: PPUSH
99432: CALL_OW 109
// end ; k := 8 ;
99436: LD_ADDR_VAR 0 9
99440: PUSH
99441: LD_INT 8
99443: ST_TO_ADDR
// x := 0 ;
99444: LD_ADDR_VAR 0 10
99448: PUSH
99449: LD_INT 0
99451: ST_TO_ADDR
// if tmp < k then
99452: LD_VAR 0 14
99456: PUSH
99457: LD_VAR 0 9
99461: LESS
99462: IFFALSE 99474
// k := tmp ;
99464: LD_ADDR_VAR 0 9
99468: PUSH
99469: LD_VAR 0 14
99473: ST_TO_ADDR
// for j = 1 to k do
99474: LD_ADDR_VAR 0 8
99478: PUSH
99479: DOUBLE
99480: LD_INT 1
99482: DEC
99483: ST_TO_ADDR
99484: LD_VAR 0 9
99488: PUSH
99489: FOR_TO
99490: IFFALSE 99588
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
99492: LD_VAR 0 14
99496: PUSH
99497: LD_VAR 0 8
99501: ARRAY
99502: PPUSH
99503: CALL_OW 247
99507: PUSH
99508: LD_INT 1
99510: EQUAL
99511: PUSH
99512: LD_VAR 0 14
99516: PUSH
99517: LD_VAR 0 8
99521: ARRAY
99522: PPUSH
99523: CALL_OW 256
99527: PUSH
99528: LD_INT 250
99530: LESS
99531: PUSH
99532: LD_VAR 0 20
99536: AND
99537: PUSH
99538: LD_VAR 0 20
99542: NOT
99543: PUSH
99544: LD_VAR 0 14
99548: PUSH
99549: LD_VAR 0 8
99553: ARRAY
99554: PPUSH
99555: CALL_OW 256
99559: PUSH
99560: LD_INT 250
99562: GREATEREQUAL
99563: AND
99564: OR
99565: AND
99566: IFFALSE 99586
// begin x := tmp [ j ] ;
99568: LD_ADDR_VAR 0 10
99572: PUSH
99573: LD_VAR 0 14
99577: PUSH
99578: LD_VAR 0 8
99582: ARRAY
99583: ST_TO_ADDR
// break ;
99584: GO 99588
// end ;
99586: GO 99489
99588: POP
99589: POP
// if x then
99590: LD_VAR 0 10
99594: IFFALSE 99618
// ComAttackUnit ( group [ i ] , x ) else
99596: LD_VAR 0 4
99600: PUSH
99601: LD_VAR 0 7
99605: ARRAY
99606: PPUSH
99607: LD_VAR 0 10
99611: PPUSH
99612: CALL_OW 115
99616: GO 99642
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
99618: LD_VAR 0 4
99622: PUSH
99623: LD_VAR 0 7
99627: ARRAY
99628: PPUSH
99629: LD_VAR 0 14
99633: PUSH
99634: LD_INT 1
99636: ARRAY
99637: PPUSH
99638: CALL_OW 115
// if not HasTask ( group [ i ] ) then
99642: LD_VAR 0 4
99646: PUSH
99647: LD_VAR 0 7
99651: ARRAY
99652: PPUSH
99653: CALL_OW 314
99657: NOT
99658: IFFALSE 99696
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
99660: LD_VAR 0 4
99664: PUSH
99665: LD_VAR 0 7
99669: ARRAY
99670: PPUSH
99671: LD_VAR 0 14
99675: PPUSH
99676: LD_VAR 0 4
99680: PUSH
99681: LD_VAR 0 7
99685: ARRAY
99686: PPUSH
99687: CALL_OW 74
99691: PPUSH
99692: CALL_OW 115
// end ; end ; end ;
99696: GO 95575
99698: POP
99699: POP
// wait ( 0 0$2 ) ;
99700: LD_INT 70
99702: PPUSH
99703: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
99707: LD_VAR 0 4
99711: NOT
99712: PUSH
99713: LD_VAR 0 4
99717: PUSH
99718: EMPTY
99719: EQUAL
99720: OR
99721: PUSH
99722: LD_INT 81
99724: PUSH
99725: LD_VAR 0 35
99729: PUSH
99730: EMPTY
99731: LIST
99732: LIST
99733: PPUSH
99734: CALL_OW 69
99738: NOT
99739: OR
99740: IFFALSE 95560
// end ;
99742: LD_VAR 0 2
99746: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
99747: LD_INT 0
99749: PPUSH
99750: PPUSH
99751: PPUSH
99752: PPUSH
99753: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
99754: LD_VAR 0 1
99758: NOT
99759: PUSH
99760: LD_EXP 65
99764: PUSH
99765: LD_VAR 0 1
99769: ARRAY
99770: NOT
99771: OR
99772: PUSH
99773: LD_VAR 0 2
99777: NOT
99778: OR
99779: PUSH
99780: LD_VAR 0 3
99784: NOT
99785: OR
99786: IFFALSE 99790
// exit ;
99788: GO 100303
// side := mc_sides [ base ] ;
99790: LD_ADDR_VAR 0 6
99794: PUSH
99795: LD_EXP 91
99799: PUSH
99800: LD_VAR 0 1
99804: ARRAY
99805: ST_TO_ADDR
// if not side then
99806: LD_VAR 0 6
99810: NOT
99811: IFFALSE 99815
// exit ;
99813: GO 100303
// for i in solds do
99815: LD_ADDR_VAR 0 7
99819: PUSH
99820: LD_VAR 0 2
99824: PUSH
99825: FOR_IN
99826: IFFALSE 99887
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
99828: LD_VAR 0 7
99832: PPUSH
99833: CALL_OW 310
99837: PPUSH
99838: CALL_OW 266
99842: PUSH
99843: LD_INT 32
99845: PUSH
99846: LD_INT 31
99848: PUSH
99849: EMPTY
99850: LIST
99851: LIST
99852: IN
99853: IFFALSE 99873
// solds := solds diff i else
99855: LD_ADDR_VAR 0 2
99859: PUSH
99860: LD_VAR 0 2
99864: PUSH
99865: LD_VAR 0 7
99869: DIFF
99870: ST_TO_ADDR
99871: GO 99885
// SetTag ( i , 18 ) ;
99873: LD_VAR 0 7
99877: PPUSH
99878: LD_INT 18
99880: PPUSH
99881: CALL_OW 109
99885: GO 99825
99887: POP
99888: POP
// if not solds then
99889: LD_VAR 0 2
99893: NOT
99894: IFFALSE 99898
// exit ;
99896: GO 100303
// repeat wait ( 0 0$1 ) ;
99898: LD_INT 35
99900: PPUSH
99901: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
99905: LD_ADDR_VAR 0 5
99909: PUSH
99910: LD_VAR 0 6
99914: PPUSH
99915: LD_VAR 0 3
99919: PPUSH
99920: CALL 15305 0 2
99924: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
99925: LD_EXP 65
99929: PUSH
99930: LD_VAR 0 1
99934: ARRAY
99935: NOT
99936: PUSH
99937: LD_EXP 65
99941: PUSH
99942: LD_VAR 0 1
99946: ARRAY
99947: PUSH
99948: EMPTY
99949: EQUAL
99950: OR
99951: IFFALSE 99988
// begin for i in solds do
99953: LD_ADDR_VAR 0 7
99957: PUSH
99958: LD_VAR 0 2
99962: PUSH
99963: FOR_IN
99964: IFFALSE 99977
// ComStop ( i ) ;
99966: LD_VAR 0 7
99970: PPUSH
99971: CALL_OW 141
99975: GO 99963
99977: POP
99978: POP
// solds := [ ] ;
99979: LD_ADDR_VAR 0 2
99983: PUSH
99984: EMPTY
99985: ST_TO_ADDR
// exit ;
99986: GO 100303
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
99988: LD_VAR 0 5
99992: NOT
99993: PUSH
99994: LD_VAR 0 5
99998: PUSH
99999: LD_INT 3
100001: GREATER
100002: OR
100003: PUSH
100004: LD_EXP 87
100008: PUSH
100009: LD_VAR 0 1
100013: ARRAY
100014: OR
100015: IFFALSE 100056
// begin for i in solds do
100017: LD_ADDR_VAR 0 7
100021: PUSH
100022: LD_VAR 0 2
100026: PUSH
100027: FOR_IN
100028: IFFALSE 100052
// if HasTask ( i ) then
100030: LD_VAR 0 7
100034: PPUSH
100035: CALL_OW 314
100039: IFFALSE 100050
// ComStop ( i ) ;
100041: LD_VAR 0 7
100045: PPUSH
100046: CALL_OW 141
100050: GO 100027
100052: POP
100053: POP
// break ;
100054: GO 100291
// end ; for i in solds do
100056: LD_ADDR_VAR 0 7
100060: PUSH
100061: LD_VAR 0 2
100065: PUSH
100066: FOR_IN
100067: IFFALSE 100283
// begin if IsInUnit ( i ) then
100069: LD_VAR 0 7
100073: PPUSH
100074: CALL_OW 310
100078: IFFALSE 100089
// ComExitBuilding ( i ) ;
100080: LD_VAR 0 7
100084: PPUSH
100085: CALL_OW 122
// if GetLives ( i ) > 333 then
100089: LD_VAR 0 7
100093: PPUSH
100094: CALL_OW 256
100098: PUSH
100099: LD_INT 333
100101: GREATER
100102: IFFALSE 100130
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
100104: LD_VAR 0 7
100108: PPUSH
100109: LD_VAR 0 5
100113: PPUSH
100114: LD_VAR 0 7
100118: PPUSH
100119: CALL_OW 74
100123: PPUSH
100124: CALL_OW 115
100128: GO 100281
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
100130: LD_ADDR_VAR 0 8
100134: PUSH
100135: LD_EXP 65
100139: PUSH
100140: LD_VAR 0 1
100144: ARRAY
100145: PPUSH
100146: LD_INT 2
100148: PUSH
100149: LD_INT 30
100151: PUSH
100152: LD_INT 0
100154: PUSH
100155: EMPTY
100156: LIST
100157: LIST
100158: PUSH
100159: LD_INT 30
100161: PUSH
100162: LD_INT 1
100164: PUSH
100165: EMPTY
100166: LIST
100167: LIST
100168: PUSH
100169: LD_INT 30
100171: PUSH
100172: LD_INT 6
100174: PUSH
100175: EMPTY
100176: LIST
100177: LIST
100178: PUSH
100179: EMPTY
100180: LIST
100181: LIST
100182: LIST
100183: LIST
100184: PPUSH
100185: CALL_OW 72
100189: PPUSH
100190: LD_VAR 0 7
100194: PPUSH
100195: CALL_OW 74
100199: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
100200: LD_VAR 0 7
100204: PPUSH
100205: LD_VAR 0 8
100209: PPUSH
100210: CALL_OW 250
100214: PPUSH
100215: LD_INT 3
100217: PPUSH
100218: LD_INT 5
100220: PPUSH
100221: CALL_OW 272
100225: PPUSH
100226: LD_VAR 0 8
100230: PPUSH
100231: CALL_OW 251
100235: PPUSH
100236: LD_INT 3
100238: PPUSH
100239: LD_INT 5
100241: PPUSH
100242: CALL_OW 273
100246: PPUSH
100247: CALL_OW 111
// SetTag ( i , 0 ) ;
100251: LD_VAR 0 7
100255: PPUSH
100256: LD_INT 0
100258: PPUSH
100259: CALL_OW 109
// solds := solds diff i ;
100263: LD_ADDR_VAR 0 2
100267: PUSH
100268: LD_VAR 0 2
100272: PUSH
100273: LD_VAR 0 7
100277: DIFF
100278: ST_TO_ADDR
// continue ;
100279: GO 100066
// end ; end ;
100281: GO 100066
100283: POP
100284: POP
// until solds ;
100285: LD_VAR 0 2
100289: IFFALSE 99898
// MC_Reset ( base , 18 ) ;
100291: LD_VAR 0 1
100295: PPUSH
100296: LD_INT 18
100298: PPUSH
100299: CALL 54133 0 2
// end ;
100303: LD_VAR 0 4
100307: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
100308: LD_INT 0
100310: PPUSH
100311: PPUSH
100312: PPUSH
100313: PPUSH
100314: PPUSH
100315: PPUSH
100316: PPUSH
100317: PPUSH
100318: PPUSH
100319: PPUSH
100320: PPUSH
100321: PPUSH
100322: PPUSH
100323: PPUSH
100324: PPUSH
100325: PPUSH
100326: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
100327: LD_ADDR_VAR 0 13
100331: PUSH
100332: LD_EXP 65
100336: PUSH
100337: LD_VAR 0 1
100341: ARRAY
100342: PPUSH
100343: LD_INT 25
100345: PUSH
100346: LD_INT 3
100348: PUSH
100349: EMPTY
100350: LIST
100351: LIST
100352: PPUSH
100353: CALL_OW 72
100357: ST_TO_ADDR
// if mc_remote_driver [ base ] then
100358: LD_EXP 105
100362: PUSH
100363: LD_VAR 0 1
100367: ARRAY
100368: IFFALSE 100392
// mechs := mechs diff mc_remote_driver [ base ] ;
100370: LD_ADDR_VAR 0 13
100374: PUSH
100375: LD_VAR 0 13
100379: PUSH
100380: LD_EXP 105
100384: PUSH
100385: LD_VAR 0 1
100389: ARRAY
100390: DIFF
100391: ST_TO_ADDR
// for i in mechs do
100392: LD_ADDR_VAR 0 5
100396: PUSH
100397: LD_VAR 0 13
100401: PUSH
100402: FOR_IN
100403: IFFALSE 100438
// if GetTag ( i ) > 0 then
100405: LD_VAR 0 5
100409: PPUSH
100410: CALL_OW 110
100414: PUSH
100415: LD_INT 0
100417: GREATER
100418: IFFALSE 100436
// mechs := mechs diff i ;
100420: LD_ADDR_VAR 0 13
100424: PUSH
100425: LD_VAR 0 13
100429: PUSH
100430: LD_VAR 0 5
100434: DIFF
100435: ST_TO_ADDR
100436: GO 100402
100438: POP
100439: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
100440: LD_ADDR_VAR 0 9
100444: PUSH
100445: LD_EXP 65
100449: PUSH
100450: LD_VAR 0 1
100454: ARRAY
100455: PPUSH
100456: LD_INT 2
100458: PUSH
100459: LD_INT 25
100461: PUSH
100462: LD_INT 1
100464: PUSH
100465: EMPTY
100466: LIST
100467: LIST
100468: PUSH
100469: LD_INT 25
100471: PUSH
100472: LD_INT 5
100474: PUSH
100475: EMPTY
100476: LIST
100477: LIST
100478: PUSH
100479: LD_INT 25
100481: PUSH
100482: LD_INT 8
100484: PUSH
100485: EMPTY
100486: LIST
100487: LIST
100488: PUSH
100489: LD_INT 25
100491: PUSH
100492: LD_INT 9
100494: PUSH
100495: EMPTY
100496: LIST
100497: LIST
100498: PUSH
100499: EMPTY
100500: LIST
100501: LIST
100502: LIST
100503: LIST
100504: LIST
100505: PPUSH
100506: CALL_OW 72
100510: ST_TO_ADDR
// if not defenders and not solds then
100511: LD_VAR 0 2
100515: NOT
100516: PUSH
100517: LD_VAR 0 9
100521: NOT
100522: AND
100523: IFFALSE 100527
// exit ;
100525: GO 102153
// depot_under_attack := false ;
100527: LD_ADDR_VAR 0 17
100531: PUSH
100532: LD_INT 0
100534: ST_TO_ADDR
// sold_defenders := [ ] ;
100535: LD_ADDR_VAR 0 18
100539: PUSH
100540: EMPTY
100541: ST_TO_ADDR
// if mechs then
100542: LD_VAR 0 13
100546: IFFALSE 100675
// for i in defenders do
100548: LD_ADDR_VAR 0 5
100552: PUSH
100553: LD_VAR 0 2
100557: PUSH
100558: FOR_IN
100559: IFFALSE 100673
// begin SetTag ( i , 20 ) ;
100561: LD_VAR 0 5
100565: PPUSH
100566: LD_INT 20
100568: PPUSH
100569: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
100573: LD_VAR 0 5
100577: PPUSH
100578: CALL_OW 263
100582: PUSH
100583: LD_INT 1
100585: EQUAL
100586: PUSH
100587: LD_VAR 0 5
100591: PPUSH
100592: CALL_OW 311
100596: NOT
100597: AND
100598: PUSH
100599: LD_VAR 0 13
100603: AND
100604: IFFALSE 100671
// begin un := mechs [ 1 ] ;
100606: LD_ADDR_VAR 0 11
100610: PUSH
100611: LD_VAR 0 13
100615: PUSH
100616: LD_INT 1
100618: ARRAY
100619: ST_TO_ADDR
// ComExitBuilding ( un ) ;
100620: LD_VAR 0 11
100624: PPUSH
100625: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
100629: LD_VAR 0 11
100633: PPUSH
100634: LD_VAR 0 5
100638: PPUSH
100639: CALL_OW 180
// SetTag ( un , 19 ) ;
100643: LD_VAR 0 11
100647: PPUSH
100648: LD_INT 19
100650: PPUSH
100651: CALL_OW 109
// mechs := mechs diff un ;
100655: LD_ADDR_VAR 0 13
100659: PUSH
100660: LD_VAR 0 13
100664: PUSH
100665: LD_VAR 0 11
100669: DIFF
100670: ST_TO_ADDR
// end ; end ;
100671: GO 100558
100673: POP
100674: POP
// if solds then
100675: LD_VAR 0 9
100679: IFFALSE 100738
// for i in solds do
100681: LD_ADDR_VAR 0 5
100685: PUSH
100686: LD_VAR 0 9
100690: PUSH
100691: FOR_IN
100692: IFFALSE 100736
// if not GetTag ( i ) then
100694: LD_VAR 0 5
100698: PPUSH
100699: CALL_OW 110
100703: NOT
100704: IFFALSE 100734
// begin defenders := defenders union i ;
100706: LD_ADDR_VAR 0 2
100710: PUSH
100711: LD_VAR 0 2
100715: PUSH
100716: LD_VAR 0 5
100720: UNION
100721: ST_TO_ADDR
// SetTag ( i , 18 ) ;
100722: LD_VAR 0 5
100726: PPUSH
100727: LD_INT 18
100729: PPUSH
100730: CALL_OW 109
// end ;
100734: GO 100691
100736: POP
100737: POP
// repeat wait ( 0 0$1 ) ;
100738: LD_INT 35
100740: PPUSH
100741: CALL_OW 67
// enemy := mc_scan [ base ] ;
100745: LD_ADDR_VAR 0 3
100749: PUSH
100750: LD_EXP 88
100754: PUSH
100755: LD_VAR 0 1
100759: ARRAY
100760: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
100761: LD_EXP 65
100765: PUSH
100766: LD_VAR 0 1
100770: ARRAY
100771: NOT
100772: PUSH
100773: LD_EXP 65
100777: PUSH
100778: LD_VAR 0 1
100782: ARRAY
100783: PUSH
100784: EMPTY
100785: EQUAL
100786: OR
100787: IFFALSE 100824
// begin for i in defenders do
100789: LD_ADDR_VAR 0 5
100793: PUSH
100794: LD_VAR 0 2
100798: PUSH
100799: FOR_IN
100800: IFFALSE 100813
// ComStop ( i ) ;
100802: LD_VAR 0 5
100806: PPUSH
100807: CALL_OW 141
100811: GO 100799
100813: POP
100814: POP
// defenders := [ ] ;
100815: LD_ADDR_VAR 0 2
100819: PUSH
100820: EMPTY
100821: ST_TO_ADDR
// exit ;
100822: GO 102153
// end ; for i in defenders do
100824: LD_ADDR_VAR 0 5
100828: PUSH
100829: LD_VAR 0 2
100833: PUSH
100834: FOR_IN
100835: IFFALSE 101653
// begin e := NearestUnitToUnit ( enemy , i ) ;
100837: LD_ADDR_VAR 0 14
100841: PUSH
100842: LD_VAR 0 3
100846: PPUSH
100847: LD_VAR 0 5
100851: PPUSH
100852: CALL_OW 74
100856: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
100857: LD_ADDR_VAR 0 8
100861: PUSH
100862: LD_EXP 65
100866: PUSH
100867: LD_VAR 0 1
100871: ARRAY
100872: PPUSH
100873: LD_INT 2
100875: PUSH
100876: LD_INT 30
100878: PUSH
100879: LD_INT 0
100881: PUSH
100882: EMPTY
100883: LIST
100884: LIST
100885: PUSH
100886: LD_INT 30
100888: PUSH
100889: LD_INT 1
100891: PUSH
100892: EMPTY
100893: LIST
100894: LIST
100895: PUSH
100896: EMPTY
100897: LIST
100898: LIST
100899: LIST
100900: PPUSH
100901: CALL_OW 72
100905: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
100906: LD_ADDR_VAR 0 17
100910: PUSH
100911: LD_VAR 0 8
100915: NOT
100916: PUSH
100917: LD_VAR 0 8
100921: PPUSH
100922: LD_INT 3
100924: PUSH
100925: LD_INT 24
100927: PUSH
100928: LD_INT 600
100930: PUSH
100931: EMPTY
100932: LIST
100933: LIST
100934: PUSH
100935: EMPTY
100936: LIST
100937: LIST
100938: PPUSH
100939: CALL_OW 72
100943: OR
100944: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
100945: LD_VAR 0 5
100949: PPUSH
100950: CALL_OW 247
100954: PUSH
100955: LD_INT 2
100957: DOUBLE
100958: EQUAL
100959: IFTRUE 100963
100961: GO 101359
100963: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
100964: LD_VAR 0 5
100968: PPUSH
100969: CALL_OW 256
100973: PUSH
100974: LD_INT 650
100976: GREATER
100977: PUSH
100978: LD_VAR 0 5
100982: PPUSH
100983: LD_VAR 0 14
100987: PPUSH
100988: CALL_OW 296
100992: PUSH
100993: LD_INT 40
100995: LESS
100996: PUSH
100997: LD_VAR 0 14
101001: PPUSH
101002: LD_EXP 90
101006: PUSH
101007: LD_VAR 0 1
101011: ARRAY
101012: PPUSH
101013: CALL_OW 308
101017: OR
101018: AND
101019: IFFALSE 101141
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
101021: LD_VAR 0 5
101025: PPUSH
101026: CALL_OW 262
101030: PUSH
101031: LD_INT 1
101033: EQUAL
101034: PUSH
101035: LD_VAR 0 5
101039: PPUSH
101040: CALL_OW 261
101044: PUSH
101045: LD_INT 30
101047: LESS
101048: AND
101049: PUSH
101050: LD_VAR 0 8
101054: AND
101055: IFFALSE 101125
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
101057: LD_VAR 0 5
101061: PPUSH
101062: LD_VAR 0 8
101066: PPUSH
101067: LD_VAR 0 5
101071: PPUSH
101072: CALL_OW 74
101076: PPUSH
101077: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
101081: LD_VAR 0 5
101085: PPUSH
101086: LD_VAR 0 8
101090: PPUSH
101091: LD_VAR 0 5
101095: PPUSH
101096: CALL_OW 74
101100: PPUSH
101101: CALL_OW 296
101105: PUSH
101106: LD_INT 6
101108: LESS
101109: IFFALSE 101123
// SetFuel ( i , 100 ) ;
101111: LD_VAR 0 5
101115: PPUSH
101116: LD_INT 100
101118: PPUSH
101119: CALL_OW 240
// end else
101123: GO 101139
// ComAttackUnit ( i , e ) ;
101125: LD_VAR 0 5
101129: PPUSH
101130: LD_VAR 0 14
101134: PPUSH
101135: CALL_OW 115
// end else
101139: GO 101242
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
101141: LD_VAR 0 14
101145: PPUSH
101146: LD_EXP 90
101150: PUSH
101151: LD_VAR 0 1
101155: ARRAY
101156: PPUSH
101157: CALL_OW 308
101161: NOT
101162: PUSH
101163: LD_VAR 0 5
101167: PPUSH
101168: LD_VAR 0 14
101172: PPUSH
101173: CALL_OW 296
101177: PUSH
101178: LD_INT 40
101180: GREATEREQUAL
101181: AND
101182: PUSH
101183: LD_VAR 0 5
101187: PPUSH
101188: CALL_OW 256
101192: PUSH
101193: LD_INT 650
101195: LESSEQUAL
101196: OR
101197: PUSH
101198: LD_VAR 0 5
101202: PPUSH
101203: LD_EXP 89
101207: PUSH
101208: LD_VAR 0 1
101212: ARRAY
101213: PPUSH
101214: CALL_OW 308
101218: NOT
101219: AND
101220: IFFALSE 101242
// ComMoveToArea ( i , mc_parking [ base ] ) ;
101222: LD_VAR 0 5
101226: PPUSH
101227: LD_EXP 89
101231: PUSH
101232: LD_VAR 0 1
101236: ARRAY
101237: PPUSH
101238: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
101242: LD_VAR 0 5
101246: PPUSH
101247: CALL_OW 256
101251: PUSH
101252: LD_INT 998
101254: LESS
101255: PUSH
101256: LD_VAR 0 5
101260: PPUSH
101261: CALL_OW 263
101265: PUSH
101266: LD_INT 1
101268: EQUAL
101269: AND
101270: PUSH
101271: LD_VAR 0 5
101275: PPUSH
101276: CALL_OW 311
101280: AND
101281: PUSH
101282: LD_VAR 0 5
101286: PPUSH
101287: LD_EXP 89
101291: PUSH
101292: LD_VAR 0 1
101296: ARRAY
101297: PPUSH
101298: CALL_OW 308
101302: AND
101303: IFFALSE 101357
// begin mech := IsDrivenBy ( i ) ;
101305: LD_ADDR_VAR 0 10
101309: PUSH
101310: LD_VAR 0 5
101314: PPUSH
101315: CALL_OW 311
101319: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
101320: LD_VAR 0 10
101324: PPUSH
101325: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
101329: LD_VAR 0 10
101333: PPUSH
101334: LD_VAR 0 5
101338: PPUSH
101339: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
101343: LD_VAR 0 10
101347: PPUSH
101348: LD_VAR 0 5
101352: PPUSH
101353: CALL_OW 180
// end ; end ; unit_human :
101357: GO 101624
101359: LD_INT 1
101361: DOUBLE
101362: EQUAL
101363: IFTRUE 101367
101365: GO 101623
101367: POP
// begin b := IsInUnit ( i ) ;
101368: LD_ADDR_VAR 0 19
101372: PUSH
101373: LD_VAR 0 5
101377: PPUSH
101378: CALL_OW 310
101382: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
101383: LD_ADDR_VAR 0 20
101387: PUSH
101388: LD_VAR 0 19
101392: NOT
101393: PUSH
101394: LD_VAR 0 19
101398: PPUSH
101399: CALL_OW 266
101403: PUSH
101404: LD_INT 32
101406: PUSH
101407: LD_INT 31
101409: PUSH
101410: EMPTY
101411: LIST
101412: LIST
101413: IN
101414: OR
101415: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
101416: LD_VAR 0 17
101420: PUSH
101421: LD_VAR 0 2
101425: PPUSH
101426: LD_INT 21
101428: PUSH
101429: LD_INT 2
101431: PUSH
101432: EMPTY
101433: LIST
101434: LIST
101435: PPUSH
101436: CALL_OW 72
101440: PUSH
101441: LD_INT 1
101443: LESSEQUAL
101444: OR
101445: PUSH
101446: LD_VAR 0 20
101450: AND
101451: PUSH
101452: LD_VAR 0 5
101456: PUSH
101457: LD_VAR 0 18
101461: IN
101462: NOT
101463: AND
101464: IFFALSE 101557
// begin if b then
101466: LD_VAR 0 19
101470: IFFALSE 101519
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
101472: LD_VAR 0 19
101476: PPUSH
101477: LD_VAR 0 3
101481: PPUSH
101482: LD_VAR 0 19
101486: PPUSH
101487: CALL_OW 74
101491: PPUSH
101492: CALL_OW 296
101496: PUSH
101497: LD_INT 10
101499: LESS
101500: PUSH
101501: LD_VAR 0 19
101505: PPUSH
101506: CALL_OW 461
101510: PUSH
101511: LD_INT 7
101513: NONEQUAL
101514: AND
101515: IFFALSE 101519
// continue ;
101517: GO 100834
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
101519: LD_ADDR_VAR 0 18
101523: PUSH
101524: LD_VAR 0 18
101528: PPUSH
101529: LD_VAR 0 18
101533: PUSH
101534: LD_INT 1
101536: PLUS
101537: PPUSH
101538: LD_VAR 0 5
101542: PPUSH
101543: CALL_OW 1
101547: ST_TO_ADDR
// ComExitBuilding ( i ) ;
101548: LD_VAR 0 5
101552: PPUSH
101553: CALL_OW 122
// end ; if sold_defenders then
101557: LD_VAR 0 18
101561: IFFALSE 101621
// if i in sold_defenders then
101563: LD_VAR 0 5
101567: PUSH
101568: LD_VAR 0 18
101572: IN
101573: IFFALSE 101621
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
101575: LD_VAR 0 5
101579: PPUSH
101580: CALL_OW 314
101584: NOT
101585: PUSH
101586: LD_VAR 0 5
101590: PPUSH
101591: LD_VAR 0 14
101595: PPUSH
101596: CALL_OW 296
101600: PUSH
101601: LD_INT 30
101603: LESS
101604: AND
101605: IFFALSE 101621
// ComAttackUnit ( i , e ) ;
101607: LD_VAR 0 5
101611: PPUSH
101612: LD_VAR 0 14
101616: PPUSH
101617: CALL_OW 115
// end ; end ; end ;
101621: GO 101624
101623: POP
// if IsDead ( i ) then
101624: LD_VAR 0 5
101628: PPUSH
101629: CALL_OW 301
101633: IFFALSE 101651
// defenders := defenders diff i ;
101635: LD_ADDR_VAR 0 2
101639: PUSH
101640: LD_VAR 0 2
101644: PUSH
101645: LD_VAR 0 5
101649: DIFF
101650: ST_TO_ADDR
// end ;
101651: GO 100834
101653: POP
101654: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
101655: LD_VAR 0 3
101659: NOT
101660: PUSH
101661: LD_VAR 0 2
101665: NOT
101666: OR
101667: PUSH
101668: LD_EXP 65
101672: PUSH
101673: LD_VAR 0 1
101677: ARRAY
101678: NOT
101679: OR
101680: IFFALSE 100738
// MC_Reset ( base , 18 ) ;
101682: LD_VAR 0 1
101686: PPUSH
101687: LD_INT 18
101689: PPUSH
101690: CALL 54133 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
101694: LD_ADDR_VAR 0 2
101698: PUSH
101699: LD_VAR 0 2
101703: PUSH
101704: LD_VAR 0 2
101708: PPUSH
101709: LD_INT 2
101711: PUSH
101712: LD_INT 25
101714: PUSH
101715: LD_INT 1
101717: PUSH
101718: EMPTY
101719: LIST
101720: LIST
101721: PUSH
101722: LD_INT 25
101724: PUSH
101725: LD_INT 5
101727: PUSH
101728: EMPTY
101729: LIST
101730: LIST
101731: PUSH
101732: LD_INT 25
101734: PUSH
101735: LD_INT 8
101737: PUSH
101738: EMPTY
101739: LIST
101740: LIST
101741: PUSH
101742: LD_INT 25
101744: PUSH
101745: LD_INT 9
101747: PUSH
101748: EMPTY
101749: LIST
101750: LIST
101751: PUSH
101752: EMPTY
101753: LIST
101754: LIST
101755: LIST
101756: LIST
101757: LIST
101758: PPUSH
101759: CALL_OW 72
101763: DIFF
101764: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
101765: LD_VAR 0 3
101769: NOT
101770: PUSH
101771: LD_VAR 0 2
101775: PPUSH
101776: LD_INT 21
101778: PUSH
101779: LD_INT 2
101781: PUSH
101782: EMPTY
101783: LIST
101784: LIST
101785: PPUSH
101786: CALL_OW 72
101790: AND
101791: IFFALSE 102129
// begin tmp := FilterByTag ( defenders , 19 ) ;
101793: LD_ADDR_VAR 0 12
101797: PUSH
101798: LD_VAR 0 2
101802: PPUSH
101803: LD_INT 19
101805: PPUSH
101806: CALL 47065 0 2
101810: ST_TO_ADDR
// if tmp then
101811: LD_VAR 0 12
101815: IFFALSE 101885
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
101817: LD_ADDR_VAR 0 12
101821: PUSH
101822: LD_VAR 0 12
101826: PPUSH
101827: LD_INT 25
101829: PUSH
101830: LD_INT 3
101832: PUSH
101833: EMPTY
101834: LIST
101835: LIST
101836: PPUSH
101837: CALL_OW 72
101841: ST_TO_ADDR
// if tmp then
101842: LD_VAR 0 12
101846: IFFALSE 101885
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
101848: LD_ADDR_EXP 77
101852: PUSH
101853: LD_EXP 77
101857: PPUSH
101858: LD_VAR 0 1
101862: PPUSH
101863: LD_EXP 77
101867: PUSH
101868: LD_VAR 0 1
101872: ARRAY
101873: PUSH
101874: LD_VAR 0 12
101878: UNION
101879: PPUSH
101880: CALL_OW 1
101884: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
101885: LD_VAR 0 1
101889: PPUSH
101890: LD_INT 19
101892: PPUSH
101893: CALL 54133 0 2
// repeat wait ( 0 0$1 ) ;
101897: LD_INT 35
101899: PPUSH
101900: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
101904: LD_EXP 65
101908: PUSH
101909: LD_VAR 0 1
101913: ARRAY
101914: NOT
101915: PUSH
101916: LD_EXP 65
101920: PUSH
101921: LD_VAR 0 1
101925: ARRAY
101926: PUSH
101927: EMPTY
101928: EQUAL
101929: OR
101930: IFFALSE 101967
// begin for i in defenders do
101932: LD_ADDR_VAR 0 5
101936: PUSH
101937: LD_VAR 0 2
101941: PUSH
101942: FOR_IN
101943: IFFALSE 101956
// ComStop ( i ) ;
101945: LD_VAR 0 5
101949: PPUSH
101950: CALL_OW 141
101954: GO 101942
101956: POP
101957: POP
// defenders := [ ] ;
101958: LD_ADDR_VAR 0 2
101962: PUSH
101963: EMPTY
101964: ST_TO_ADDR
// exit ;
101965: GO 102153
// end ; for i in defenders do
101967: LD_ADDR_VAR 0 5
101971: PUSH
101972: LD_VAR 0 2
101976: PUSH
101977: FOR_IN
101978: IFFALSE 102067
// begin if not IsInArea ( i , mc_parking [ base ] ) then
101980: LD_VAR 0 5
101984: PPUSH
101985: LD_EXP 89
101989: PUSH
101990: LD_VAR 0 1
101994: ARRAY
101995: PPUSH
101996: CALL_OW 308
102000: NOT
102001: IFFALSE 102025
// ComMoveToArea ( i , mc_parking [ base ] ) else
102003: LD_VAR 0 5
102007: PPUSH
102008: LD_EXP 89
102012: PUSH
102013: LD_VAR 0 1
102017: ARRAY
102018: PPUSH
102019: CALL_OW 113
102023: GO 102065
// if GetControl ( i ) = control_manual then
102025: LD_VAR 0 5
102029: PPUSH
102030: CALL_OW 263
102034: PUSH
102035: LD_INT 1
102037: EQUAL
102038: IFFALSE 102065
// if IsDrivenBy ( i ) then
102040: LD_VAR 0 5
102044: PPUSH
102045: CALL_OW 311
102049: IFFALSE 102065
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
102051: LD_VAR 0 5
102055: PPUSH
102056: CALL_OW 311
102060: PPUSH
102061: CALL_OW 121
// end ;
102065: GO 101977
102067: POP
102068: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
102069: LD_VAR 0 2
102073: PPUSH
102074: LD_INT 95
102076: PUSH
102077: LD_EXP 89
102081: PUSH
102082: LD_VAR 0 1
102086: ARRAY
102087: PUSH
102088: EMPTY
102089: LIST
102090: LIST
102091: PPUSH
102092: CALL_OW 72
102096: PUSH
102097: LD_VAR 0 2
102101: EQUAL
102102: PUSH
102103: LD_EXP 88
102107: PUSH
102108: LD_VAR 0 1
102112: ARRAY
102113: OR
102114: PUSH
102115: LD_EXP 65
102119: PUSH
102120: LD_VAR 0 1
102124: ARRAY
102125: NOT
102126: OR
102127: IFFALSE 101897
// end ; MC_Reset ( base , 19 ) ;
102129: LD_VAR 0 1
102133: PPUSH
102134: LD_INT 19
102136: PPUSH
102137: CALL 54133 0 2
// MC_Reset ( base , 20 ) ;
102141: LD_VAR 0 1
102145: PPUSH
102146: LD_INT 20
102148: PPUSH
102149: CALL 54133 0 2
// end ;
102153: LD_VAR 0 4
102157: RET
