// export MissionStart ; export southAreaBlocker ; starting begin southAreaBlocker = true ;
   0: LD_ADDR_EXP 2
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// ResetFog ;
   8: CALL_OW 335
// AnimateTrees ( true ) ;
  12: LD_INT 1
  14: PPUSH
  15: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  19: LD_INT 1
  21: PPUSH
  22: LD_INT 8
  24: PPUSH
  25: CALL_OW 332
// GameType ;
  29: CALL 5444 0 0
// SetBName ( BetaA , beta ) ;
  33: LD_INT 1
  35: PPUSH
  36: LD_STRING beta
  38: PPUSH
  39: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  43: LD_INT 3
  45: PPUSH
  46: LD_STRING beta
  48: PPUSH
  49: CALL_OW 500
// SetResourceType ( GetBase ( BetaA ) , mat_cans , startCrates [ 1 ] ) ;
  53: LD_INT 1
  55: PPUSH
  56: CALL_OW 274
  60: PPUSH
  61: LD_INT 1
  63: PPUSH
  64: LD_EXP 43
  68: PUSH
  69: LD_INT 1
  71: ARRAY
  72: PPUSH
  73: CALL_OW 277
// SetResourceType ( GetBase ( BetaB ) , mat_cans , startCrates [ 2 ] ) ;
  77: LD_INT 3
  79: PPUSH
  80: CALL_OW 274
  84: PPUSH
  85: LD_INT 1
  87: PPUSH
  88: LD_EXP 43
  92: PUSH
  93: LD_INT 2
  95: ARRAY
  96: PPUSH
  97: CALL_OW 277
// PrepareHeroes ;
 101: CALL 2607 0 0
// PrepareBeta ;
 105: CALL 2996 0 0
// HideArea ( 1 , SouthArea ) ;
 109: LD_INT 1
 111: PPUSH
 112: LD_INT 16
 114: PPUSH
 115: CALL_OW 333
// InGameOn ;
 119: CALL_OW 8
// ComHold ( Brighton ) ;
 123: LD_EXP 9
 127: PPUSH
 128: CALL_OW 140
// CenterNowOnUnits ( Brighton ) ;
 132: LD_EXP 9
 136: PPUSH
 137: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
 141: LD_EXP 11
 145: PPUSH
 146: LD_INT 50
 148: PPUSH
 149: LD_INT 42
 151: PPUSH
 152: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
 156: LD_INT 35
 158: PPUSH
 159: CALL_OW 67
 163: LD_EXP 11
 167: PPUSH
 168: LD_EXP 9
 172: PPUSH
 173: CALL_OW 296
 177: PUSH
 178: LD_INT 3
 180: LESS
 181: IFFALSE 156
// ComTurnUnit ( Megan , Brighton ) ;
 183: LD_EXP 11
 187: PPUSH
 188: LD_EXP 9
 192: PPUSH
 193: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 197: LD_EXP 11
 201: PPUSH
 202: LD_STRING DMegan-1a
 204: PPUSH
 205: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 209: LD_INT 10
 211: PPUSH
 212: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 216: LD_EXP 9
 220: PPUSH
 221: LD_EXP 11
 225: PPUSH
 226: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 230: LD_EXP 9
 234: PPUSH
 235: LD_STRING DBrighton-1a
 237: PPUSH
 238: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 242: LD_EXP 11
 246: PPUSH
 247: LD_STRING DMegan-2a
 249: PPUSH
 250: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 254: LD_EXP 9
 258: PPUSH
 259: LD_STRING DBrighton-2a
 261: PPUSH
 262: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 266: LD_EXP 11
 270: PPUSH
 271: LD_INT 40
 273: PPUSH
 274: LD_INT 37
 276: PPUSH
 277: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 281: LD_EXP 11
 285: PPUSH
 286: LD_EXP 9
 290: PPUSH
 291: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 295: LD_EXP 10
 299: PPUSH
 300: LD_INT 50
 302: PPUSH
 303: LD_INT 42
 305: PPUSH
 306: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 310: LD_INT 35
 312: PPUSH
 313: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 317: LD_EXP 9
 321: PPUSH
 322: LD_EXP 10
 326: PPUSH
 327: CALL_OW 296
 331: PUSH
 332: LD_INT 6
 334: LESS
 335: IFFALSE 310
// ComTurnUnit ( Brighton , Palmer ) ;
 337: LD_EXP 9
 341: PPUSH
 342: LD_EXP 10
 346: PPUSH
 347: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 351: LD_EXP 10
 355: PPUSH
 356: LD_EXP 9
 360: PPUSH
 361: CALL_OW 119
// Say ( Palmer , DPalmer-1 ) ;
 365: LD_EXP 10
 369: PPUSH
 370: LD_STRING DPalmer-1
 372: PPUSH
 373: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 377: LD_EXP 9
 381: PPUSH
 382: LD_STRING DBrighton-1
 384: PPUSH
 385: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 389: LD_EXP 10
 393: PPUSH
 394: LD_STRING DPalmer-2
 396: PPUSH
 397: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 401: LD_EXP 9
 405: PPUSH
 406: LD_STRING DBrighton-2
 408: PPUSH
 409: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 413: LD_EXP 10
 417: PPUSH
 418: LD_STRING DPalmer-3
 420: PPUSH
 421: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 425: LD_EXP 9
 429: PPUSH
 430: LD_STRING DBrighton-3
 432: PPUSH
 433: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 437: LD_EXP 10
 441: PPUSH
 442: LD_STRING DPalmer-4
 444: PPUSH
 445: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 449: LD_EXP 10
 453: PPUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 461: LD_INT 35
 463: PPUSH
 464: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 468: LD_EXP 10
 472: PPUSH
 473: CALL_OW 310
 477: PUSH
 478: LD_INT 6
 480: EQUAL
 481: IFFALSE 461
// SayRadio ( Palmer , DPalmer-5 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_STRING DPalmer-5
 490: PPUSH
 491: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 495: LD_EXP 9
 499: PPUSH
 500: LD_INT 59
 502: PPUSH
 503: LD_INT 36
 505: PPUSH
 506: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 510: LD_EXP 11
 514: PPUSH
 515: LD_INT 60
 517: PPUSH
 518: LD_INT 35
 520: PPUSH
 521: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 525: LD_EXP 10
 529: PPUSH
 530: LD_INT 60
 532: PPUSH
 533: LD_INT 34
 535: PPUSH
 536: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 540: LD_EXP 9
 544: PPUSH
 545: LD_INT 99
 547: PPUSH
 548: LD_INT 37
 550: PPUSH
 551: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 555: LD_EXP 11
 559: PPUSH
 560: LD_EXP 9
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 569: LD_EXP 10
 573: PPUSH
 574: LD_EXP 9
 578: PPUSH
 579: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 583: LD_INT 64
 585: PPUSH
 586: LD_INT 40
 588: PPUSH
 589: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 593: LD_EXP 12
 597: PPUSH
 598: LD_INT 13
 600: PPUSH
 601: CALL 12715 0 2
// wait ( 0 0$30 ) ;
 605: LD_INT 1050
 607: PPUSH
 608: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 612: LD_EXP 9
 616: PPUSH
 617: LD_STRING DBrighton-4
 619: PPUSH
 620: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 624: LD_EXP 9
 628: PPUSH
 629: LD_STRING DBrighton-5
 631: PPUSH
 632: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 636: LD_EXP 9
 640: PPUSH
 641: LD_EXP 11
 645: PPUSH
 646: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 650: LD_EXP 9
 654: PPUSH
 655: LD_STRING DBrighton-6
 657: PPUSH
 658: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 662: LD_EXP 11
 666: PPUSH
 667: LD_STRING DMegan-1
 669: PPUSH
 670: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 674: LD_EXP 9
 678: PPUSH
 679: LD_STRING DBrighton-7
 681: PPUSH
 682: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 686: LD_EXP 9
 690: PPUSH
 691: LD_INT 99
 693: PPUSH
 694: LD_INT 37
 696: PPUSH
 697: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 701: LD_EXP 9
 705: PPUSH
 706: LD_STRING DBrighton-8
 708: PPUSH
 709: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 713: LD_STRING C1
 715: PPUSH
 716: CALL_OW 337
// InGameOff ;
 720: CALL_OW 9
// SaveForQuickRestart ;
 724: CALL_OW 22
// MissionStart := true ;
 728: LD_ADDR_EXP 1
 732: PUSH
 733: LD_INT 1
 735: ST_TO_ADDR
// PrepareRUBase_v2 ;
 736: CALL 4719 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 740: LD_ADDR_EXP 69
 744: PUSH
 745: LD_EXP 69
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: PPUSH
 763: CALL_OW 69
 767: PPUSH
 768: CALL_OW 1
 772: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 773: LD_ADDR_EXP 69
 777: PUSH
 778: LD_EXP 69
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: LD_EXP 36
 790: PPUSH
 791: CALL_OW 1
 795: ST_TO_ADDR
// MC_Start ( ) ;
 796: CALL 56026 0 0
// music_nat := 1 ;
 800: LD_ADDR_OWVAR 71
 804: PUSH
 805: LD_INT 1
 807: ST_TO_ADDR
// end ;
 808: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var i , tmp ;
 809: LD_EXP 1
 813: IFFALSE 1237
 815: GO 817
 817: DISABLE
 818: LD_INT 0
 820: PPUSH
 821: PPUSH
// begin wait ( ruArrival ) ;
 822: LD_EXP 42
 826: PPUSH
 827: CALL_OW 67
// PrepareRUArmada ;
 831: CALL 3578 0 0
// wait ( 0 0$3 ) ;
 835: LD_INT 105
 837: PPUSH
 838: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 842: LD_ADDR_VAR 0 2
 846: PUSH
 847: LD_INT 15
 849: PPUSH
 850: LD_INT 0
 852: PPUSH
 853: CALL_OW 517
 857: ST_TO_ADDR
// for i = 1 to RUArmada do
 858: LD_ADDR_VAR 0 1
 862: PUSH
 863: DOUBLE
 864: LD_INT 1
 866: DEC
 867: ST_TO_ADDR
 868: LD_EXP 17
 872: PUSH
 873: FOR_TO
 874: IFFALSE 923
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 876: LD_EXP 17
 880: PUSH
 881: LD_VAR 0 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 1
 894: ARRAY
 895: PUSH
 896: LD_VAR 0 1
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 2
 909: ARRAY
 910: PUSH
 911: LD_VAR 0 1
 915: ARRAY
 916: PPUSH
 917: CALL_OW 111
 921: GO 873
 923: POP
 924: POP
// ArmadaArrived := true ;
 925: LD_ADDR_EXP 3
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 933: LD_EXP 10
 937: PPUSH
 938: LD_STRING DPalmer-A1
 940: PPUSH
 941: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 945: LD_EXP 9
 949: PPUSH
 950: LD_STRING DBrighton-A1
 952: PPUSH
 953: CALL_OW 88
// wait ( 0 0$20 ) ;
 957: LD_INT 700
 959: PPUSH
 960: CALL_OW 67
// PrepareRUBase ;
 964: CALL 4303 0 0
// wait ( 1 1$20 ) ;
 968: LD_INT 2800
 970: PPUSH
 971: CALL_OW 67
// PrepareRUBulldozers ;
 975: CALL 4190 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 979: LD_EXP 18
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: LD_INT 9
 990: PPUSH
 991: CALL 12572 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 995: LD_EXP 18
 999: PUSH
1000: LD_INT 2
1002: ARRAY
1003: PPUSH
1004: LD_INT 11
1006: PPUSH
1007: CALL 12572 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
1011: LD_INT 1
1013: PPUSH
1014: LD_EXP 18
1018: PUSH
1019: LD_INT 1
1021: ARRAY
1022: PPUSH
1023: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1027: LD_INT 1
1029: PPUSH
1030: LD_EXP 18
1034: PUSH
1035: LD_INT 2
1037: ARRAY
1038: PPUSH
1039: CALL_OW 471
// wait ( 1 1$20 ) ;
1043: LD_INT 2800
1045: PPUSH
1046: CALL_OW 67
// ComMoveXY ( Bulldozers , 64 , 114 ) ;
1050: LD_EXP 18
1054: PPUSH
1055: LD_INT 64
1057: PPUSH
1058: LD_INT 114
1060: PPUSH
1061: CALL_OW 111
// wait ( 0 0$10 ) ;
1065: LD_INT 350
1067: PPUSH
1068: CALL_OW 67
// for i := 1 to 2 do
1072: LD_ADDR_VAR 0 1
1076: PUSH
1077: DOUBLE
1078: LD_INT 1
1080: DEC
1081: ST_TO_ADDR
1082: LD_INT 2
1084: PUSH
1085: FOR_TO
1086: IFFALSE 1105
// RemoveUnit ( Bulldozers [ i ] ) ;
1088: LD_EXP 18
1092: PUSH
1093: LD_VAR 0 1
1097: ARRAY
1098: PPUSH
1099: CALL_OW 64
1103: GO 1085
1105: POP
1106: POP
// RemoveEnvironmentArea ( BulldozerArea ) ;
1107: LD_INT 9
1109: PPUSH
1110: CALL_OW 355
// RemoveEnvironmentArea ( BulldozerArea2 ) ;
1114: LD_INT 11
1116: PPUSH
1117: CALL_OW 355
// SayEffect ( DRuSol-A1 ) ;
1121: LD_STRING DRuSol-A1
1123: PPUSH
1124: CALL_OW 96
// AssaultStarted := true ;
1128: LD_ADDR_EXP 8
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// wait ( 0 0$2 ) ;
1136: LD_INT 70
1138: PPUSH
1139: CALL_OW 67
// Say ( Yashin , DDeath-Yas-1 ) ;
1143: LD_EXP 13
1147: PPUSH
1148: LD_STRING DDeath-Yas-1
1150: PPUSH
1151: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-2 ) ;
1155: LD_EXP 15
1159: PPUSH
1160: LD_STRING DDeath-Gay-2
1162: PPUSH
1163: CALL_OW 88
// wait ( 0 0$2 ) ;
1167: LD_INT 70
1169: PPUSH
1170: CALL_OW 67
// Say ( Popov , DDeath-Pop-1 ) ;
1174: LD_EXP 14
1178: PPUSH
1179: LD_STRING DDeath-Pop-1
1181: PPUSH
1182: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1186: LD_EXP 15
1190: PPUSH
1191: LD_STRING DDeath-Gay-1
1193: PPUSH
1194: CALL_OW 88
// wait ( 0 0$5 ) ;
1198: LD_INT 175
1200: PPUSH
1201: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1205: LD_EXP 16
1209: PPUSH
1210: LD_STRING DDeath-Vse-1
1212: PPUSH
1213: CALL_OW 88
// Say ( Popov , DDeath-Pop-2 ) ;
1217: LD_EXP 14
1221: PPUSH
1222: LD_STRING DDeath-Pop-2
1224: PPUSH
1225: CALL_OW 88
// southAreaBlocker = false ;
1229: LD_ADDR_EXP 2
1233: PUSH
1234: LD_INT 0
1236: ST_TO_ADDR
// end ;
1237: PPOPN 2
1239: END
// every 0 0$1 trigger AssaultStarted do var i , tmp ;
1240: LD_EXP 8
1244: IFFALSE 1835
1246: GO 1248
1248: DISABLE
1249: LD_INT 0
1251: PPUSH
1252: PPUSH
// begin PriorityAttack ( 6 , BetaA ) ;
1253: LD_INT 6
1255: PPUSH
1256: LD_INT 1
1258: PPUSH
1259: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1263: LD_INT 6
1265: PPUSH
1266: LD_INT 3
1268: PPUSH
1269: CALL_OW 470
// repeat for i in RuArmada do
1273: LD_ADDR_VAR 0 1
1277: PUSH
1278: LD_EXP 17
1282: PUSH
1283: FOR_IN
1284: IFFALSE 1487
// begin if GetDistUnitXY ( i , 87 , 77 ) < 10 and not GetTag ( i ) then
1286: LD_VAR 0 1
1290: PPUSH
1291: LD_INT 87
1293: PPUSH
1294: LD_INT 77
1296: PPUSH
1297: CALL_OW 297
1301: PUSH
1302: LD_INT 10
1304: LESS
1305: PUSH
1306: LD_VAR 0 1
1310: PPUSH
1311: CALL_OW 110
1315: NOT
1316: AND
1317: IFFALSE 1331
// SetTag ( i , 1 ) ;
1319: LD_VAR 0 1
1323: PPUSH
1324: LD_INT 1
1326: PPUSH
1327: CALL_OW 109
// if GetDistUnitXY ( i , 62 , 48 ) < 10 and GetTag ( i ) < 2 then
1331: LD_VAR 0 1
1335: PPUSH
1336: LD_INT 62
1338: PPUSH
1339: LD_INT 48
1341: PPUSH
1342: CALL_OW 297
1346: PUSH
1347: LD_INT 10
1349: LESS
1350: PUSH
1351: LD_VAR 0 1
1355: PPUSH
1356: CALL_OW 110
1360: PUSH
1361: LD_INT 2
1363: LESS
1364: AND
1365: IFFALSE 1379
// SetTag ( i , 2 ) ;
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_INT 2
1374: PPUSH
1375: CALL_OW 109
// if not GetTag ( i ) then
1379: LD_VAR 0 1
1383: PPUSH
1384: CALL_OW 110
1388: NOT
1389: IFFALSE 1406
// ComAgressiveMove ( i , 87 , 77 ) ;
1391: LD_VAR 0 1
1395: PPUSH
1396: LD_INT 87
1398: PPUSH
1399: LD_INT 77
1401: PPUSH
1402: CALL_OW 114
// if GetTag ( i ) = 1 then
1406: LD_VAR 0 1
1410: PPUSH
1411: CALL_OW 110
1415: PUSH
1416: LD_INT 1
1418: EQUAL
1419: IFFALSE 1436
// ComAgressiveMove ( i , 62 , 48 ) ;
1421: LD_VAR 0 1
1425: PPUSH
1426: LD_INT 62
1428: PPUSH
1429: LD_INT 48
1431: PPUSH
1432: CALL_OW 114
// if GetTag ( i ) = 2 then
1436: LD_VAR 0 1
1440: PPUSH
1441: CALL_OW 110
1445: PUSH
1446: LD_INT 2
1448: EQUAL
1449: IFFALSE 1485
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1451: LD_VAR 0 1
1455: PPUSH
1456: LD_INT 22
1458: PUSH
1459: LD_INT 1
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PPUSH
1466: CALL_OW 69
1470: PPUSH
1471: LD_VAR 0 1
1475: PPUSH
1476: CALL_OW 74
1480: PPUSH
1481: CALL_OW 115
// end ;
1485: GO 1283
1487: POP
1488: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1489: LD_INT 35
1491: PPUSH
1492: CALL_OW 67
1496: LD_INT 1
1498: PUSH
1499: LD_INT 22
1501: PUSH
1502: LD_INT 6
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: PUSH
1509: LD_INT 21
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: EMPTY
1516: LIST
1517: LIST
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PPUSH
1524: CALL_OW 69
1528: PUSH
1529: LD_INT 10
1531: LESS
1532: PUSH
1533: LD_EXP 13
1537: PPUSH
1538: CALL_OW 301
1542: AND
1543: PUSH
1544: LD_EXP 14
1548: PPUSH
1549: CALL_OW 301
1553: AND
1554: PUSH
1555: LD_EXP 15
1559: PPUSH
1560: CALL_OW 301
1564: AND
1565: PUSH
1566: LD_EXP 16
1570: PPUSH
1571: CALL_OW 301
1575: AND
1576: IFFALSE 1273
// AssaultStarted := false ;
1578: LD_ADDR_EXP 8
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 6 ] ) , RUArrivalArea ) ;
1586: LD_INT 22
1588: PUSH
1589: LD_INT 6
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PPUSH
1596: CALL_OW 69
1600: PPUSH
1601: LD_INT 5
1603: PPUSH
1604: CALL_OW 113
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1608: LD_ADDR_EXP 5
1612: PUSH
1613: LD_INT 1
1615: PUSH
1616: LD_INT 22
1618: PUSH
1619: LD_INT 6
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: LD_INT 26
1628: PUSH
1629: LD_INT 1
1631: PUSH
1632: EMPTY
1633: LIST
1634: LIST
1635: PUSH
1636: LD_INT 21
1638: PUSH
1639: LD_INT 1
1641: PUSH
1642: EMPTY
1643: LIST
1644: LIST
1645: PUSH
1646: LD_INT 24
1648: PUSH
1649: LD_INT 500
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: PPUSH
1663: CALL_OW 69
1667: ST_TO_ADDR
// if RuSpeaker then
1668: LD_EXP 5
1672: IFFALSE 1690
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1674: LD_EXP 5
1678: PUSH
1679: LD_INT 1
1681: ARRAY
1682: PPUSH
1683: LD_STRING DRuSol-A2
1685: PPUSH
1686: CALL_OW 88
// wait ( 0 0$30 ) ;
1690: LD_INT 1050
1692: PPUSH
1693: CALL_OW 67
// DialogueOn ;
1697: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1701: LD_EXP 9
1705: PPUSH
1706: LD_STRING DBrighton-B1
1708: PPUSH
1709: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1713: LD_EXP 10
1717: PPUSH
1718: LD_STRING DPalmer-B1
1720: PPUSH
1721: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1725: LD_EXP 9
1729: PPUSH
1730: LD_STRING DBrighton-B2
1732: PPUSH
1733: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1737: LD_EXP 19
1741: PPUSH
1742: LD_STRING DBurlak-B1
1744: PPUSH
1745: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1749: LD_EXP 9
1753: PPUSH
1754: LD_STRING DBrighton-B3
1756: PPUSH
1757: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1761: LD_EXP 10
1765: PPUSH
1766: LD_STRING DPalmer-B2
1768: PPUSH
1769: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1773: LD_EXP 9
1777: PPUSH
1778: LD_STRING DBrighton-B4
1780: PPUSH
1781: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1785: LD_EXP 9
1789: PPUSH
1790: LD_STRING DBrighton-B5
1792: PPUSH
1793: CALL_OW 88
// DialogueOff ;
1797: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1801: LD_STRING C2
1803: PPUSH
1804: CALL_OW 337
// FirstAssaultRepelled := true ;
1808: LD_ADDR_EXP 4
1812: PUSH
1813: LD_INT 1
1815: ST_TO_ADDR
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1816: LD_INT 22
1818: PUSH
1819: LD_INT 6
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 69
1830: PPUSH
1831: CALL_OW 181
// end ;
1835: PPOPN 2
1837: END
// every 0 0$1 trigger FirstAssaultRepelled do var unit , insideUnit ;
1838: LD_EXP 4
1842: IFFALSE 2007
1844: GO 1846
1846: DISABLE
1847: LD_INT 0
1849: PPUSH
1850: PPUSH
// begin enable ;
1851: ENABLE
// if FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) = 0 then
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 22
1857: PUSH
1858: LD_INT 6
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: PPUSH
1868: CALL_OW 70
1872: PUSH
1873: LD_INT 0
1875: EQUAL
1876: IFFALSE 1880
// exit ;
1878: GO 2007
// for unit in FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) do
1880: LD_ADDR_VAR 0 1
1884: PUSH
1885: LD_INT 5
1887: PPUSH
1888: LD_INT 22
1890: PUSH
1891: LD_INT 6
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: PUSH
1898: EMPTY
1899: LIST
1900: PPUSH
1901: CALL_OW 70
1905: PUSH
1906: FOR_IN
1907: IFFALSE 2005
// begin SetSide ( unit , 3 ) ;
1909: LD_VAR 0 1
1913: PPUSH
1914: LD_INT 3
1916: PPUSH
1917: CALL_OW 235
// if ( GetType ( unit ) = unit_vehicle ) then
1921: LD_VAR 0 1
1925: PPUSH
1926: CALL_OW 247
1930: PUSH
1931: LD_INT 2
1933: EQUAL
1934: IFFALSE 1970
// for insideUnit in UnitsInside ( unit ) do
1936: LD_ADDR_VAR 0 2
1940: PUSH
1941: LD_VAR 0 1
1945: PPUSH
1946: CALL_OW 313
1950: PUSH
1951: FOR_IN
1952: IFFALSE 1968
// SetSide ( insideUnit , 3 ) ;
1954: LD_VAR 0 2
1958: PPUSH
1959: LD_INT 3
1961: PPUSH
1962: CALL_OW 235
1966: GO 1951
1968: POP
1969: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
1970: LD_ADDR_EXP 69
1974: PUSH
1975: LD_EXP 69
1979: PPUSH
1980: LD_INT 1
1982: PPUSH
1983: LD_INT 22
1985: PUSH
1986: LD_INT 3
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: PPUSH
1993: CALL_OW 69
1997: PPUSH
1998: CALL_OW 1
2002: ST_TO_ADDR
// end ;
2003: GO 1906
2005: POP
2006: POP
// end ;
2007: PPOPN 2
2009: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
2010: LD_EXP 4
2014: PUSH
2015: LD_EXP 41
2019: PUSH
2020: LD_INT 0
2022: GREATER
2023: AND
2024: IFFALSE 2044
2026: GO 2028
2028: DISABLE
// begin enable ;
2029: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
2030: LD_ADDR_EXP 41
2034: PUSH
2035: LD_EXP 41
2039: PUSH
2040: LD_INT 35
2042: MINUS
2043: ST_TO_ADDR
// end ;
2044: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
2045: LD_EXP 41
2049: PUSH
2050: LD_INT 0
2052: EQUAL
2053: IFFALSE 2159
2055: GO 2057
2057: DISABLE
// begin JMMReinforcement ;
2058: CALL 5047 0 0
// DialogueOn ;
2062: CALL_OW 6
// CenterOnUnits ( JMM ) ;
2066: LD_EXP 37
2070: PPUSH
2071: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
2075: LD_EXP 37
2079: PPUSH
2080: LD_STRING DJMM-F1
2082: PPUSH
2083: CALL_OW 88
// if RussiansDefeated then
2087: LD_EXP 44
2091: IFFALSE 2117
// begin AddMedal ( Russians , 1 ) ;
2093: LD_STRING Russians
2095: PPUSH
2096: LD_INT 1
2098: PPUSH
2099: CALL_OW 101
// Say ( Brighton , DBrighton-F1a ) ;
2103: LD_EXP 9
2107: PPUSH
2108: LD_STRING DBrighton-F1a
2110: PPUSH
2111: CALL_OW 88
// end else
2115: GO 2147
// begin AddMedal ( Russians , - 1 ) ;
2117: LD_STRING Russians
2119: PPUSH
2120: LD_INT 1
2122: NEG
2123: PPUSH
2124: CALL_OW 101
// Say ( Brighton , DBrighton-F1 ) ;
2128: LD_EXP 9
2132: PPUSH
2133: LD_STRING DBrighton-F1
2135: PPUSH
2136: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2140: LD_STRING C3
2142: PPUSH
2143: CALL_OW 337
// end ; DialogueOff ;
2147: CALL_OW 7
// JMM_Arrived := true ;
2151: LD_ADDR_EXP 6
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// end ;
2159: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2160: LD_EXP 6
2164: PUSH
2165: LD_INT 1
2167: PPUSH
2168: LD_EXP 19
2172: PPUSH
2173: CALL_OW 292
2177: AND
2178: IFFALSE 2207
2180: GO 2182
2182: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2183: LD_EXP 19
2187: PPUSH
2188: LD_STRING DBurlak
2190: PPUSH
2191: CALL_OW 88
// Say ( JMM , DJMM ) ;
2195: LD_EXP 37
2199: PPUSH
2200: LD_STRING DJMM
2202: PPUSH
2203: CALL_OW 88
// end ;
2207: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2208: LD_INT 1
2210: PUSH
2211: LD_INT 22
2213: PUSH
2214: LD_INT 1
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PUSH
2221: LD_INT 2
2223: PUSH
2224: LD_INT 34
2226: PUSH
2227: LD_INT 9
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: PUSH
2234: LD_INT 35
2236: PUSH
2237: LD_INT 9
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: PUSH
2259: LD_INT 1
2261: GREATER
2262: IFFALSE 2275
2264: GO 2266
2266: DISABLE
// LaserBuilt := true ;
2267: LD_ADDR_EXP 7
2271: PUSH
2272: LD_INT 1
2274: ST_TO_ADDR
2275: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2276: LD_EXP 8
2280: PUSH
2281: LD_INT 6
2283: PPUSH
2284: LD_INT 1
2286: PUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: LD_INT 35
2299: PUSH
2300: LD_INT 9
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PUSH
2307: EMPTY
2308: LIST
2309: LIST
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PPUSH
2320: LD_EXP 16
2324: PPUSH
2325: CALL_OW 310
2329: PPUSH
2330: CALL_OW 74
2334: PPUSH
2335: CALL_OW 292
2339: AND
2340: IFFALSE 2369
2342: GO 2344
2344: DISABLE
// begin Say ( Sevi , DDeath-Vse-2 ) ;
2345: LD_EXP 16
2349: PPUSH
2350: LD_STRING DDeath-Vse-2
2352: PPUSH
2353: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2357: LD_EXP 13
2361: PPUSH
2362: LD_STRING DDeath-Yas-2
2364: PPUSH
2365: CALL_OW 88
// end ;
2369: END
// every 0 0$1 trigger MissionStart and GetResourceArea ( CratesArea , mat_cans ) < 20 do
2370: LD_EXP 1
2374: PUSH
2375: LD_INT 12
2377: PPUSH
2378: LD_INT 1
2380: PPUSH
2381: CALL_OW 287
2385: PUSH
2386: LD_INT 20
2388: LESS
2389: AND
2390: IFFALSE 2432
2392: GO 2394
2394: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2395: LD_INT 1750
2397: PPUSH
2398: LD_INT 4900
2400: PPUSH
2401: CALL_OW 12
2405: PPUSH
2406: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2410: LD_INT 2
2412: PPUSH
2413: LD_INT 5
2415: PPUSH
2416: CALL_OW 12
2420: PPUSH
2421: LD_INT 12
2423: PPUSH
2424: LD_INT 1
2426: PPUSH
2427: CALL_OW 55
// enable ;
2431: ENABLE
// end ;
2432: END
// every 0 0$1 trigger FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) do var un , x , y ;
2433: LD_INT 17
2435: PPUSH
2436: LD_INT 81
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PPUSH
2446: CALL_OW 70
2450: IFFALSE 2576
2452: GO 2454
2454: DISABLE
2455: LD_INT 0
2457: PPUSH
2458: PPUSH
2459: PPUSH
// begin un := FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) [ 1 ] ;
2460: LD_ADDR_VAR 0 1
2464: PUSH
2465: LD_INT 17
2467: PPUSH
2468: LD_INT 81
2470: PUSH
2471: LD_INT 1
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: PPUSH
2478: CALL_OW 70
2482: PUSH
2483: LD_INT 1
2485: ARRAY
2486: ST_TO_ADDR
// x := GetX ( un ) ;
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: LD_VAR 0 1
2496: PPUSH
2497: CALL_OW 250
2501: ST_TO_ADDR
// y := GetY ( un ) ;
2502: LD_ADDR_VAR 0 3
2506: PUSH
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 251
2516: ST_TO_ADDR
// PlaceSeeing ( x , y , 1 , - 12 ) ;
2517: LD_VAR 0 2
2521: PPUSH
2522: LD_VAR 0 3
2526: PPUSH
2527: LD_INT 1
2529: PPUSH
2530: LD_INT 12
2532: NEG
2533: PPUSH
2534: CALL_OW 330
// CenterNowOnUnits ( un ) ;
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 87
// Say ( Brighton , DBrighton-E1 ) ;
2547: LD_EXP 9
2551: PPUSH
2552: LD_STRING DBrighton-E1
2554: PPUSH
2555: CALL_OW 88
// RemoveSeeing ( x , y , 1 ) ;
2559: LD_VAR 0 2
2563: PPUSH
2564: LD_VAR 0 3
2568: PPUSH
2569: LD_INT 1
2571: PPUSH
2572: CALL_OW 331
// end ;
2576: PPOPN 3
2578: END
// every 0 0$1 trigger MissionStart do
2579: LD_EXP 1
2583: IFFALSE 2606
2585: GO 2587
2587: DISABLE
// begin enable ;
2588: ENABLE
// display_Strings := [ #tick , tick ] ;
2589: LD_ADDR_OWVAR 47
2593: PUSH
2594: LD_STRING #tick
2596: PUSH
2597: LD_OWVAR 1
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: ST_TO_ADDR
// end ; end_of_file
2606: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2607: LD_INT 0
2609: PPUSH
// uc_side := 1 ;
2610: LD_ADDR_OWVAR 20
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// hc_class = class_soldier ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 1
2625: ST_TO_ADDR
// uc_nation := nation_american ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_sex = sex_male ;
2634: LD_ADDR_OWVAR 27
2638: PUSH
2639: LD_INT 1
2641: ST_TO_ADDR
// hc_importance = 110 ;
2642: LD_ADDR_OWVAR 32
2646: PUSH
2647: LD_INT 110
2649: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2650: LD_ADDR_OWVAR 30
2654: PUSH
2655: LD_INT 5
2657: PUSH
2658: LD_INT 4
2660: PUSH
2661: LD_INT 5
2663: PUSH
2664: LD_INT 3
2666: PUSH
2667: EMPTY
2668: LIST
2669: LIST
2670: LIST
2671: LIST
2672: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2673: LD_ADDR_OWVAR 31
2677: PUSH
2678: LD_INT 9
2680: PUSH
2681: LD_INT 6
2683: PUSH
2684: LD_INT 7
2686: PUSH
2687: LD_INT 6
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: LIST
2695: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2696: LD_ADDR_OWVAR 29
2700: PUSH
2701: LD_INT 12
2703: PUSH
2704: LD_INT 10
2706: PUSH
2707: EMPTY
2708: LIST
2709: LIST
2710: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING Gerard Brighton
2718: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2719: LD_ADDR_OWVAR 33
2723: PUSH
2724: LD_STRING Beta_Skirmish
2726: ST_TO_ADDR
// hc_face_number := 1 ;
2727: LD_ADDR_OWVAR 34
2731: PUSH
2732: LD_INT 1
2734: ST_TO_ADDR
// Brighton := CreateHuman ;
2735: LD_ADDR_EXP 9
2739: PUSH
2740: CALL_OW 44
2744: ST_TO_ADDR
// uc_nation := nation_american ;
2745: LD_ADDR_OWVAR 21
2749: PUSH
2750: LD_INT 1
2752: ST_TO_ADDR
// hc_importance = 80 ;
2753: LD_ADDR_OWVAR 32
2757: PUSH
2758: LD_INT 80
2760: ST_TO_ADDR
// hc_sex = sex_male ;
2761: LD_ADDR_OWVAR 27
2765: PUSH
2766: LD_INT 1
2768: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2769: LD_ADDR_OWVAR 30
2773: PUSH
2774: LD_INT 5
2776: PUSH
2777: LD_INT 5
2779: PUSH
2780: LD_INT 3
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: LIST
2790: LIST
2791: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2792: LD_ADDR_OWVAR 31
2796: PUSH
2797: LD_INT 7
2799: PUSH
2800: LD_INT 6
2802: PUSH
2803: LD_INT 5
2805: PUSH
2806: LD_INT 3
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2815: LD_ADDR_OWVAR 29
2819: PUSH
2820: LD_INT 10
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: ST_TO_ADDR
// hc_name := Brian Palmer ;
2830: LD_ADDR_OWVAR 26
2834: PUSH
2835: LD_STRING Brian Palmer
2837: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2838: LD_ADDR_OWVAR 33
2842: PUSH
2843: LD_STRING Beta_Skirmish
2845: ST_TO_ADDR
// hc_face_number := 3 ;
2846: LD_ADDR_OWVAR 34
2850: PUSH
2851: LD_INT 3
2853: ST_TO_ADDR
// Palmer := CreateHuman ;
2854: LD_ADDR_EXP 10
2858: PUSH
2859: CALL_OW 44
2863: ST_TO_ADDR
// hc_class = class_scientistic ;
2864: LD_ADDR_OWVAR 28
2868: PUSH
2869: LD_INT 4
2871: ST_TO_ADDR
// uc_nation := nation_american ;
2872: LD_ADDR_OWVAR 21
2876: PUSH
2877: LD_INT 1
2879: ST_TO_ADDR
// hc_importance = 70 ;
2880: LD_ADDR_OWVAR 32
2884: PUSH
2885: LD_INT 70
2887: ST_TO_ADDR
// hc_sex = sex_female ;
2888: LD_ADDR_OWVAR 27
2892: PUSH
2893: LD_INT 2
2895: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2896: LD_ADDR_OWVAR 30
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 2
2906: PUSH
2907: LD_INT 4
2909: PUSH
2910: LD_INT 6
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: LIST
2917: LIST
2918: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2919: LD_ADDR_OWVAR 31
2923: PUSH
2924: LD_INT 4
2926: PUSH
2927: LD_INT 2
2929: PUSH
2930: LD_INT 5
2932: PUSH
2933: LD_INT 8
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2942: LD_ADDR_OWVAR 29
2946: PUSH
2947: LD_INT 10
2949: PUSH
2950: LD_INT 10
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: ST_TO_ADDR
// hc_name := Megan Armitage ;
2957: LD_ADDR_OWVAR 26
2961: PUSH
2962: LD_STRING Megan Armitage
2964: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2965: LD_ADDR_OWVAR 33
2969: PUSH
2970: LD_STRING Beta_Skirmish
2972: ST_TO_ADDR
// hc_face_number := 4 ;
2973: LD_ADDR_OWVAR 34
2977: PUSH
2978: LD_INT 4
2980: ST_TO_ADDR
// Megan := CreateHuman ;
2981: LD_ADDR_EXP 11
2985: PUSH
2986: CALL_OW 44
2990: ST_TO_ADDR
// end ;
2991: LD_VAR 0 1
2995: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
2996: LD_INT 0
2998: PPUSH
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
// uc_side := 1 ;
3003: LD_ADDR_OWVAR 20
3007: PUSH
3008: LD_INT 1
3010: ST_TO_ADDR
// uc_nation := nation_american ;
3011: LD_ADDR_OWVAR 21
3015: PUSH
3016: LD_INT 1
3018: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
3019: LD_ADDR_VAR 0 2
3023: PUSH
3024: LD_INT 22
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 30
3036: PUSH
3037: LD_INT 32
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PPUSH
3048: CALL_OW 69
3052: PUSH
3053: FOR_IN
3054: IFFALSE 3109
// PlaceWeaponTurret ( i , [ us_light_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
3056: LD_VAR 0 2
3060: PPUSH
3061: LD_INT 3
3063: PUSH
3064: LD_INT 3
3066: PUSH
3067: LD_INT 4
3069: PUSH
3070: LD_INT 5
3072: PUSH
3073: LD_INT 11
3075: PUSH
3076: LD_INT 3
3078: PUSH
3079: LD_INT 4
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 1
3093: PPUSH
3094: LD_INT 7
3096: PPUSH
3097: CALL_OW 12
3101: ARRAY
3102: PPUSH
3103: CALL_OW 431
3107: GO 3053
3109: POP
3110: POP
// hc_name :=  ;
3111: LD_ADDR_OWVAR 26
3115: PUSH
3116: LD_STRING 
3118: ST_TO_ADDR
// hc_gallery :=  ;
3119: LD_ADDR_OWVAR 33
3123: PUSH
3124: LD_STRING 
3126: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
3127: LD_ADDR_VAR 0 2
3131: PUSH
3132: DOUBLE
3133: LD_INT 1
3135: DEC
3136: ST_TO_ADDR
3137: LD_INT 6
3139: PUSH
3140: LD_INT 5
3142: PUSH
3143: LD_INT 5
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_OWVAR 67
3155: ARRAY
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3216
// begin PrepareSoldier ( 1 , game_skill ) ;
3160: LD_INT 1
3162: PPUSH
3163: LD_EXP 39
3167: PPUSH
3168: CALL_OW 381
// un := CreateHuman ;
3172: LD_ADDR_VAR 0 4
3176: PUSH
3177: CALL_OW 44
3181: ST_TO_ADDR
// filter := filter ^ un ;
3182: LD_ADDR_VAR 0 3
3186: PUSH
3187: LD_VAR 0 3
3191: PUSH
3192: LD_VAR 0 4
3196: ADD
3197: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3198: LD_ADDR_VAR 0 5
3202: PUSH
3203: LD_VAR 0 5
3207: PUSH
3208: LD_VAR 0 4
3212: ADD
3213: ST_TO_ADDR
// end ;
3214: GO 3157
3216: POP
3217: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
3218: LD_ADDR_VAR 0 2
3222: PUSH
3223: DOUBLE
3224: LD_INT 1
3226: DEC
3227: ST_TO_ADDR
3228: LD_INT 3
3230: PUSH
3231: LD_INT 2
3233: PUSH
3234: LD_INT 2
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PUSH
3242: LD_OWVAR 67
3246: ARRAY
3247: PUSH
3248: FOR_TO
3249: IFFALSE 3303
// begin PrepareEngineer ( 0 , game_skill ) ;
3251: LD_INT 0
3253: PPUSH
3254: LD_EXP 39
3258: PPUSH
3259: CALL_OW 382
// un := CreateHuman ;
3263: LD_ADDR_VAR 0 4
3267: PUSH
3268: CALL_OW 44
3272: ST_TO_ADDR
// filter := filter ^ un ;
3273: LD_ADDR_VAR 0 3
3277: PUSH
3278: LD_VAR 0 3
3282: PUSH
3283: LD_VAR 0 4
3287: ADD
3288: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3289: LD_VAR 0 4
3293: PPUSH
3294: LD_INT 3
3296: PPUSH
3297: CALL_OW 52
// end ;
3301: GO 3248
3303: POP
3304: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3305: LD_ADDR_VAR 0 2
3309: PUSH
3310: DOUBLE
3311: LD_INT 1
3313: DEC
3314: ST_TO_ADDR
3315: LD_INT 4
3317: PUSH
3318: LD_INT 3
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: PUSH
3335: FOR_TO
3336: IFFALSE 3390
// begin PrepareMechanic ( 0 , game_skill ) ;
3338: LD_INT 0
3340: PPUSH
3341: LD_EXP 39
3345: PPUSH
3346: CALL_OW 383
// un := CreateHuman ;
3350: LD_ADDR_VAR 0 4
3354: PUSH
3355: CALL_OW 44
3359: ST_TO_ADDR
// filter := filter ^ un ;
3360: LD_ADDR_VAR 0 3
3364: PUSH
3365: LD_VAR 0 3
3369: PUSH
3370: LD_VAR 0 4
3374: ADD
3375: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3376: LD_VAR 0 4
3380: PPUSH
3381: LD_INT 8
3383: PPUSH
3384: CALL_OW 52
// end ;
3388: GO 3335
3390: POP
3391: POP
// for i = 1 to 2 do
3392: LD_ADDR_VAR 0 2
3396: PUSH
3397: DOUBLE
3398: LD_INT 1
3400: DEC
3401: ST_TO_ADDR
3402: LD_INT 2
3404: PUSH
3405: FOR_TO
3406: IFFALSE 3460
// begin PrepareScientist ( 0 , game_skill ) ;
3408: LD_INT 0
3410: PPUSH
3411: LD_EXP 39
3415: PPUSH
3416: CALL_OW 384
// un := CreateHuman ;
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: CALL_OW 44
3429: ST_TO_ADDR
// filter := filter ^ un ;
3430: LD_ADDR_VAR 0 3
3434: PUSH
3435: LD_VAR 0 3
3439: PUSH
3440: LD_VAR 0 4
3444: ADD
3445: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_INT 14
3453: PPUSH
3454: CALL_OW 52
// end ;
3458: GO 3405
3460: POP
3461: POP
// for i = 1 to soldiers do
3462: LD_ADDR_VAR 0 2
3466: PUSH
3467: DOUBLE
3468: LD_INT 1
3470: DEC
3471: ST_TO_ADDR
3472: LD_VAR 0 5
3476: PUSH
3477: FOR_TO
3478: IFFALSE 3503
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3480: LD_VAR 0 5
3484: PUSH
3485: LD_VAR 0 2
3489: ARRAY
3490: PPUSH
3491: LD_INT 1
3493: PPUSH
3494: LD_INT 0
3496: PPUSH
3497: CALL_OW 49
3501: GO 3477
3503: POP
3504: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3505: LD_EXP 9
3509: PPUSH
3510: LD_INT 51
3512: PPUSH
3513: LD_INT 43
3515: PPUSH
3516: LD_INT 0
3518: PPUSH
3519: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3523: LD_EXP 10
3527: PPUSH
3528: LD_INT 55
3530: PPUSH
3531: LD_INT 58
3533: PPUSH
3534: LD_INT 0
3536: PPUSH
3537: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3541: LD_EXP 11
3545: PPUSH
3546: LD_INT 39
3548: PPUSH
3549: LD_INT 36
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// BetaSquad := filter diff 0 ;
3559: LD_ADDR_EXP 12
3563: PUSH
3564: LD_VAR 0 3
3568: PUSH
3569: LD_INT 0
3571: DIFF
3572: ST_TO_ADDR
// end ;
3573: LD_VAR 0 1
3577: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3578: LD_INT 0
3580: PPUSH
3581: PPUSH
3582: PPUSH
3583: PPUSH
3584: PPUSH
3585: PPUSH
// uc_side := 6 ;
3586: LD_ADDR_OWVAR 20
3590: PUSH
3591: LD_INT 6
3593: ST_TO_ADDR
// uc_nation := nation_russian ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// soldiers := [ ] ;
3602: LD_ADDR_VAR 0 4
3606: PUSH
3607: EMPTY
3608: ST_TO_ADDR
// vehs := [ ] ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: EMPTY
3615: ST_TO_ADDR
// RUArmada := [ ] ;
3616: LD_ADDR_EXP 17
3620: PUSH
3621: EMPTY
3622: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3623: LD_ADDR_EXP 13
3627: PUSH
3628: LD_STRING Yashin
3630: PPUSH
3631: CALL_OW 25
3635: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3636: LD_ADDR_EXP 14
3640: PUSH
3641: LD_STRING Popov
3643: PPUSH
3644: CALL_OW 25
3648: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3649: LD_ADDR_EXP 15
3653: PUSH
3654: LD_STRING Gaydar
3656: PPUSH
3657: CALL_OW 25
3661: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3662: LD_ADDR_EXP 16
3666: PUSH
3667: LD_STRING Vsevolod
3669: PPUSH
3670: CALL_OW 25
3674: ST_TO_ADDR
// for i = 1 to 16 do
3675: LD_ADDR_VAR 0 2
3679: PUSH
3680: DOUBLE
3681: LD_INT 1
3683: DEC
3684: ST_TO_ADDR
3685: LD_INT 16
3687: PUSH
3688: FOR_TO
3689: IFFALSE 3731
// begin PrepareSoldier ( 0 , game_eskill ) ;
3691: LD_INT 0
3693: PPUSH
3694: LD_EXP 40
3698: PPUSH
3699: CALL_OW 381
// un := CreateHuman ;
3703: LD_ADDR_VAR 0 5
3707: PUSH
3708: CALL_OW 44
3712: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3713: LD_ADDR_VAR 0 4
3717: PUSH
3718: LD_VAR 0 4
3722: PUSH
3723: LD_VAR 0 5
3727: ADD
3728: ST_TO_ADDR
// end ;
3729: GO 3688
3731: POP
3732: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: LD_EXP 13
3742: PUSH
3743: LD_EXP 14
3747: ADD
3748: PUSH
3749: LD_EXP 15
3753: ADD
3754: PUSH
3755: LD_EXP 16
3759: ADD
3760: PUSH
3761: LD_VAR 0 4
3765: ADD
3766: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3767: LD_INT 24
3769: PPUSH
3770: LD_INT 3
3772: PPUSH
3773: LD_INT 1
3775: PPUSH
3776: LD_INT 46
3778: PPUSH
3779: LD_INT 100
3781: PPUSH
3782: CALL 18466 0 5
// for i = 1 to 8 do
3786: LD_ADDR_VAR 0 2
3790: PUSH
3791: DOUBLE
3792: LD_INT 1
3794: DEC
3795: ST_TO_ADDR
3796: LD_INT 8
3798: PUSH
3799: FOR_TO
3800: IFFALSE 3883
// begin vehicle := CreateVehicle ;
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: CALL_OW 45
3811: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3812: LD_VAR 0 4
3816: PUSH
3817: LD_INT 1
3819: ARRAY
3820: PPUSH
3821: LD_VAR 0 3
3825: PPUSH
3826: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3830: LD_ADDR_VAR 0 4
3834: PUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_VAR 0 4
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: DIFF
3849: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3850: LD_VAR 0 3
3854: PPUSH
3855: LD_INT 5
3857: PPUSH
3858: LD_INT 0
3860: PPUSH
3861: CALL_OW 49
// vehs := vehs ^ vehicle ;
3865: LD_ADDR_VAR 0 6
3869: PUSH
3870: LD_VAR 0 6
3874: PUSH
3875: LD_VAR 0 3
3879: ADD
3880: ST_TO_ADDR
// end ;
3881: GO 3799
3883: POP
3884: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3885: LD_INT 24
3887: PPUSH
3888: LD_INT 3
3890: PPUSH
3891: LD_INT 1
3893: PPUSH
3894: LD_INT 43
3896: PPUSH
3897: LD_INT 100
3899: PPUSH
3900: CALL 18466 0 5
// for i = 1 to 8 do
3904: LD_ADDR_VAR 0 2
3908: PUSH
3909: DOUBLE
3910: LD_INT 1
3912: DEC
3913: ST_TO_ADDR
3914: LD_INT 8
3916: PUSH
3917: FOR_TO
3918: IFFALSE 4001
// begin vehicle := CreateVehicle ;
3920: LD_ADDR_VAR 0 3
3924: PUSH
3925: CALL_OW 45
3929: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3930: LD_VAR 0 4
3934: PUSH
3935: LD_INT 1
3937: ARRAY
3938: PPUSH
3939: LD_VAR 0 3
3943: PPUSH
3944: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3948: LD_ADDR_VAR 0 4
3952: PUSH
3953: LD_VAR 0 4
3957: PUSH
3958: LD_VAR 0 4
3962: PUSH
3963: LD_INT 1
3965: ARRAY
3966: DIFF
3967: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3968: LD_VAR 0 3
3972: PPUSH
3973: LD_INT 5
3975: PPUSH
3976: LD_INT 0
3978: PPUSH
3979: CALL_OW 49
// vehs := vehs ^ vehicle ;
3983: LD_ADDR_VAR 0 6
3987: PUSH
3988: LD_VAR 0 6
3992: PUSH
3993: LD_VAR 0 3
3997: ADD
3998: ST_TO_ADDR
// end ;
3999: GO 3917
4001: POP
4002: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
4003: LD_INT 22
4005: PPUSH
4006: LD_INT 3
4008: PPUSH
4009: LD_INT 1
4011: PPUSH
4012: LD_INT 44
4014: PPUSH
4015: LD_INT 100
4017: PPUSH
4018: CALL 18466 0 5
// for i = 1 to 4 do
4022: LD_ADDR_VAR 0 2
4026: PUSH
4027: DOUBLE
4028: LD_INT 1
4030: DEC
4031: ST_TO_ADDR
4032: LD_INT 4
4034: PUSH
4035: FOR_TO
4036: IFFALSE 4119
// begin vehicle := CreateVehicle ;
4038: LD_ADDR_VAR 0 3
4042: PUSH
4043: CALL_OW 45
4047: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4048: LD_VAR 0 4
4052: PUSH
4053: LD_INT 1
4055: ARRAY
4056: PPUSH
4057: LD_VAR 0 3
4061: PPUSH
4062: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4066: LD_ADDR_VAR 0 4
4070: PUSH
4071: LD_VAR 0 4
4075: PUSH
4076: LD_VAR 0 4
4080: PUSH
4081: LD_INT 1
4083: ARRAY
4084: DIFF
4085: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_INT 5
4093: PPUSH
4094: LD_INT 0
4096: PPUSH
4097: CALL_OW 49
// vehs := vehs ^ vehicle ;
4101: LD_ADDR_VAR 0 6
4105: PUSH
4106: LD_VAR 0 6
4110: PUSH
4111: LD_VAR 0 3
4115: ADD
4116: ST_TO_ADDR
// end ;
4117: GO 4035
4119: POP
4120: POP
// RUArmada := vehs ;
4121: LD_ADDR_EXP 17
4125: PUSH
4126: LD_VAR 0 6
4130: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
4131: LD_EXP 13
4135: PPUSH
4136: CALL_OW 310
4140: PUSH
4141: LD_EXP 14
4145: PPUSH
4146: CALL_OW 310
4150: PUSH
4151: LD_EXP 15
4155: PPUSH
4156: CALL_OW 310
4160: PUSH
4161: LD_EXP 16
4165: PPUSH
4166: CALL_OW 310
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: LIST
4176: PPUSH
4177: LD_INT 6
4179: NEG
4180: PPUSH
4181: CALL_OW 242
// end ;
4185: LD_VAR 0 1
4189: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
4190: LD_INT 0
4192: PPUSH
4193: PPUSH
4194: PPUSH
// uc_side := 6 ;
4195: LD_ADDR_OWVAR 20
4199: PUSH
4200: LD_INT 6
4202: ST_TO_ADDR
// uc_nation := nation_russian ;
4203: LD_ADDR_OWVAR 21
4207: PUSH
4208: LD_INT 3
4210: ST_TO_ADDR
// Bulldozers := [ ] ;
4211: LD_ADDR_EXP 18
4215: PUSH
4216: EMPTY
4217: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
4218: LD_INT 24
4220: PPUSH
4221: LD_INT 3
4223: PPUSH
4224: LD_INT 3
4226: PPUSH
4227: LD_INT 53
4229: PPUSH
4230: LD_INT 100
4232: PPUSH
4233: CALL 18466 0 5
// for i = 1 to 2 do
4237: LD_ADDR_VAR 0 2
4241: PUSH
4242: DOUBLE
4243: LD_INT 1
4245: DEC
4246: ST_TO_ADDR
4247: LD_INT 2
4249: PUSH
4250: FOR_TO
4251: IFFALSE 4296
// begin vehicle := CreateVehicle ;
4253: LD_ADDR_VAR 0 3
4257: PUSH
4258: CALL_OW 45
4262: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4263: LD_VAR 0 3
4267: PPUSH
4268: LD_INT 5
4270: PPUSH
4271: LD_INT 0
4273: PPUSH
4274: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4278: LD_ADDR_EXP 18
4282: PUSH
4283: LD_EXP 18
4287: PUSH
4288: LD_VAR 0 3
4292: ADD
4293: ST_TO_ADDR
// end ;
4294: GO 4250
4296: POP
4297: POP
// end ;
4298: LD_VAR 0 1
4302: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4303: LD_INT 0
4305: PPUSH
4306: PPUSH
4307: PPUSH
4308: PPUSH
// uc_side := 3 ;
4309: LD_ADDR_OWVAR 20
4313: PUSH
4314: LD_INT 3
4316: ST_TO_ADDR
// uc_nation := nation_russian ;
4317: LD_ADDR_OWVAR 21
4321: PUSH
4322: LD_INT 3
4324: ST_TO_ADDR
// hc_name :=  ;
4325: LD_ADDR_OWVAR 26
4329: PUSH
4330: LD_STRING 
4332: ST_TO_ADDR
// hc_gallery :=  ;
4333: LD_ADDR_OWVAR 33
4337: PUSH
4338: LD_STRING 
4340: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4341: LD_ADDR_EXP 19
4345: PUSH
4346: LD_STRING Burlak
4348: PPUSH
4349: CALL_OW 25
4353: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4354: LD_ADDR_EXP 20
4358: PUSH
4359: LD_STRING Gleb
4361: PPUSH
4362: CALL_OW 25
4366: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4367: LD_ADDR_EXP 21
4371: PUSH
4372: LD_STRING Furmanov
4374: PPUSH
4375: CALL_OW 25
4379: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4380: LD_ADDR_EXP 22
4384: PUSH
4385: LD_STRING Titov
4387: PPUSH
4388: CALL_OW 25
4392: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4393: LD_ADDR_EXP 23
4397: PUSH
4398: LD_STRING Scholtze
4400: PPUSH
4401: CALL_OW 25
4405: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4406: LD_ADDR_EXP 24
4410: PUSH
4411: LD_STRING Dolgov
4413: PPUSH
4414: CALL_OW 25
4418: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4419: LD_ADDR_EXP 25
4423: PUSH
4424: LD_STRING Kapitsova
4426: PPUSH
4427: CALL_OW 25
4431: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4432: LD_ADDR_EXP 26
4436: PUSH
4437: LD_STRING Karamazov
4439: PPUSH
4440: CALL_OW 25
4444: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4445: LD_ADDR_EXP 27
4449: PUSH
4450: LD_STRING Kirlenkova
4452: PPUSH
4453: CALL_OW 25
4457: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4458: LD_ADDR_EXP 28
4462: PUSH
4463: LD_STRING Kovalyuk
4465: PPUSH
4466: CALL_OW 25
4470: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4471: LD_ADDR_EXP 29
4475: PUSH
4476: LD_STRING Kozlov
4478: PPUSH
4479: CALL_OW 25
4483: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4484: LD_ADDR_EXP 30
4488: PUSH
4489: LD_STRING Kuzmov
4491: PPUSH
4492: CALL_OW 25
4496: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4497: LD_ADDR_EXP 31
4501: PUSH
4502: LD_STRING Lipshchin
4504: PPUSH
4505: CALL_OW 25
4509: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4510: LD_ADDR_EXP 32
4514: PUSH
4515: LD_STRING Oblukov
4517: PPUSH
4518: CALL_OW 25
4522: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4523: LD_ADDR_EXP 33
4527: PUSH
4528: LD_STRING Xavier2
4530: PPUSH
4531: CALL_OW 25
4535: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4536: LD_ADDR_EXP 34
4540: PUSH
4541: LD_STRING Gnyevko
4543: PPUSH
4544: CALL_OW 25
4548: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4549: LD_ADDR_EXP 35
4553: PUSH
4554: LD_STRING Belkov
4556: PPUSH
4557: CALL_OW 25
4561: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4562: LD_ADDR_VAR 0 3
4566: PUSH
4567: LD_EXP 19
4571: PUSH
4572: LD_EXP 20
4576: PUSH
4577: LD_EXP 21
4581: PUSH
4582: LD_EXP 22
4586: PUSH
4587: LD_EXP 23
4591: PUSH
4592: LD_EXP 24
4596: PUSH
4597: LD_EXP 25
4601: PUSH
4602: LD_EXP 26
4606: PUSH
4607: LD_EXP 27
4611: PUSH
4612: LD_EXP 28
4616: PUSH
4617: LD_EXP 29
4621: PUSH
4622: LD_EXP 30
4626: PUSH
4627: LD_EXP 31
4631: PUSH
4632: LD_EXP 32
4636: PUSH
4637: LD_EXP 33
4641: PUSH
4642: LD_EXP 34
4646: PUSH
4647: LD_EXP 35
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ST_TO_ADDR
// for i = 1 to filter do
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: DOUBLE
4677: LD_INT 1
4679: DEC
4680: ST_TO_ADDR
4681: LD_VAR 0 3
4685: PUSH
4686: FOR_TO
4687: IFFALSE 4712
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4689: LD_VAR 0 3
4693: PUSH
4694: LD_VAR 0 2
4698: ARRAY
4699: PPUSH
4700: LD_INT 6
4702: PPUSH
4703: LD_INT 0
4705: PPUSH
4706: CALL_OW 49
4710: GO 4686
4712: POP
4713: POP
// end ;
4714: LD_VAR 0 1
4718: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4719: LD_INT 0
4721: PPUSH
4722: PPUSH
4723: PPUSH
4724: PPUSH
// uc_side := 3 ;
4725: LD_ADDR_OWVAR 20
4729: PUSH
4730: LD_INT 3
4732: ST_TO_ADDR
// uc_nation := nation_russian ;
4733: LD_ADDR_OWVAR 21
4737: PUSH
4738: LD_INT 3
4740: ST_TO_ADDR
// hc_name :=  ;
4741: LD_ADDR_OWVAR 26
4745: PUSH
4746: LD_STRING 
4748: ST_TO_ADDR
// hc_gallery :=  ;
4749: LD_ADDR_OWVAR 33
4753: PUSH
4754: LD_STRING 
4756: ST_TO_ADDR
// for i = 1 to 8 do
4757: LD_ADDR_VAR 0 2
4761: PUSH
4762: DOUBLE
4763: LD_INT 1
4765: DEC
4766: ST_TO_ADDR
4767: LD_INT 8
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4813
// begin PrepareSoldier ( 0 , game_eskill ) ;
4773: LD_INT 0
4775: PPUSH
4776: LD_EXP 40
4780: PPUSH
4781: CALL_OW 381
// un := CreateHuman ;
4785: LD_ADDR_VAR 0 4
4789: PUSH
4790: CALL_OW 44
4794: ST_TO_ADDR
// filter := filter ^ un ;
4795: LD_ADDR_VAR 0 3
4799: PUSH
4800: LD_VAR 0 3
4804: PUSH
4805: LD_VAR 0 4
4809: ADD
4810: ST_TO_ADDR
// end ;
4811: GO 4770
4813: POP
4814: POP
// for i = 1 to 4 do
4815: LD_ADDR_VAR 0 2
4819: PUSH
4820: DOUBLE
4821: LD_INT 1
4823: DEC
4824: ST_TO_ADDR
4825: LD_INT 4
4827: PUSH
4828: FOR_TO
4829: IFFALSE 4871
// begin PrepareEngineer ( 0 , game_eskill ) ;
4831: LD_INT 0
4833: PPUSH
4834: LD_EXP 40
4838: PPUSH
4839: CALL_OW 382
// un := CreateHuman ;
4843: LD_ADDR_VAR 0 4
4847: PUSH
4848: CALL_OW 44
4852: ST_TO_ADDR
// filter := filter ^ un ;
4853: LD_ADDR_VAR 0 3
4857: PUSH
4858: LD_VAR 0 3
4862: PUSH
4863: LD_VAR 0 4
4867: ADD
4868: ST_TO_ADDR
// end ;
4869: GO 4828
4871: POP
4872: POP
// for i = 1 to 6 do
4873: LD_ADDR_VAR 0 2
4877: PUSH
4878: DOUBLE
4879: LD_INT 1
4881: DEC
4882: ST_TO_ADDR
4883: LD_INT 6
4885: PUSH
4886: FOR_TO
4887: IFFALSE 4929
// begin PrepareMechanic ( 0 , game_eskill ) ;
4889: LD_INT 0
4891: PPUSH
4892: LD_EXP 40
4896: PPUSH
4897: CALL_OW 383
// un := CreateHuman ;
4901: LD_ADDR_VAR 0 4
4905: PUSH
4906: CALL_OW 44
4910: ST_TO_ADDR
// filter := filter ^ un ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_VAR 0 3
4920: PUSH
4921: LD_VAR 0 4
4925: ADD
4926: ST_TO_ADDR
// end ;
4927: GO 4886
4929: POP
4930: POP
// for i = 1 to 4 do
4931: LD_ADDR_VAR 0 2
4935: PUSH
4936: DOUBLE
4937: LD_INT 1
4939: DEC
4940: ST_TO_ADDR
4941: LD_INT 4
4943: PUSH
4944: FOR_TO
4945: IFFALSE 4987
// begin PrepareScientist ( 0 , game_eskill ) ;
4947: LD_INT 0
4949: PPUSH
4950: LD_EXP 40
4954: PPUSH
4955: CALL_OW 384
// un := CreateHuman ;
4959: LD_ADDR_VAR 0 4
4963: PUSH
4964: CALL_OW 44
4968: ST_TO_ADDR
// filter := filter ^ un ;
4969: LD_ADDR_VAR 0 3
4973: PUSH
4974: LD_VAR 0 3
4978: PUSH
4979: LD_VAR 0 4
4983: ADD
4984: ST_TO_ADDR
// end ;
4985: GO 4944
4987: POP
4988: POP
// for i = 1 to filter do
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: DOUBLE
4995: LD_INT 1
4997: DEC
4998: ST_TO_ADDR
4999: LD_VAR 0 3
5003: PUSH
5004: FOR_TO
5005: IFFALSE 5030
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
5007: LD_VAR 0 3
5011: PUSH
5012: LD_VAR 0 2
5016: ARRAY
5017: PPUSH
5018: LD_INT 6
5020: PPUSH
5021: LD_INT 0
5023: PPUSH
5024: CALL_OW 49
5028: GO 5004
5030: POP
5031: POP
// RU_SecondPersonnel := filter ;
5032: LD_ADDR_EXP 36
5036: PUSH
5037: LD_VAR 0 3
5041: ST_TO_ADDR
// end ;
5042: LD_VAR 0 1
5046: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
5047: LD_INT 0
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
5055: PPUSH
// uc_side := 1 ;
5056: LD_ADDR_OWVAR 20
5060: PUSH
5061: LD_INT 1
5063: ST_TO_ADDR
// uc_nation := nation_american ;
5064: LD_ADDR_OWVAR 21
5068: PUSH
5069: LD_INT 1
5071: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
5072: LD_ADDR_EXP 37
5076: PUSH
5077: LD_STRING JMM
5079: PPUSH
5080: CALL_OW 25
5084: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
5085: LD_EXP 37
5089: PPUSH
5090: LD_INT 1
5092: PPUSH
5093: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
5097: LD_EXP 37
5101: PPUSH
5102: LD_INT 7
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 49
// mechs := [ ] ;
5112: LD_ADDR_VAR 0 7
5116: PUSH
5117: EMPTY
5118: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
5119: LD_ADDR_VAR 0 2
5123: PUSH
5124: DOUBLE
5125: LD_INT 1
5127: DEC
5128: ST_TO_ADDR
5129: LD_INT 4
5131: PUSH
5132: LD_INT 3
5134: PUSH
5135: LD_INT 3
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: LIST
5142: PUSH
5143: LD_OWVAR 67
5147: ARRAY
5148: PUSH
5149: FOR_TO
5150: IFFALSE 5211
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_EXP 39
5159: PUSH
5160: LD_INT 1
5162: PLUS
5163: PPUSH
5164: CALL_OW 381
// un := CreateHuman ;
5168: LD_ADDR_VAR 0 4
5172: PUSH
5173: CALL_OW 44
5177: ST_TO_ADDR
// soldiers := soldiers ^ un ;
5178: LD_ADDR_VAR 0 3
5182: PUSH
5183: LD_VAR 0 3
5187: PUSH
5188: LD_VAR 0 4
5192: ADD
5193: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
5194: LD_VAR 0 4
5198: PPUSH
5199: LD_INT 7
5201: PPUSH
5202: LD_INT 0
5204: PPUSH
5205: CALL_OW 49
// end ;
5209: GO 5149
5211: POP
5212: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5213: LD_ADDR_VAR 0 2
5217: PUSH
5218: DOUBLE
5219: LD_INT 1
5221: DEC
5222: ST_TO_ADDR
5223: LD_INT 7
5225: PUSH
5226: LD_INT 6
5228: PUSH
5229: LD_INT 4
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: LIST
5236: PUSH
5237: LD_OWVAR 67
5241: ARRAY
5242: PUSH
5243: FOR_TO
5244: IFFALSE 5290
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5246: LD_INT 0
5248: PPUSH
5249: LD_EXP 39
5253: PUSH
5254: LD_INT 1
5256: PLUS
5257: PPUSH
5258: CALL_OW 383
// un := CreateHuman ;
5262: LD_ADDR_VAR 0 4
5266: PUSH
5267: CALL_OW 44
5271: ST_TO_ADDR
// mechs := mechs ^ un ;
5272: LD_ADDR_VAR 0 7
5276: PUSH
5277: LD_VAR 0 7
5281: PUSH
5282: LD_VAR 0 4
5286: ADD
5287: ST_TO_ADDR
// end ;
5288: GO 5243
5290: POP
5291: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5292: LD_INT 3
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 1
5300: PPUSH
5301: LD_INT 5
5303: PPUSH
5304: LD_INT 100
5306: PPUSH
5307: CALL 18466 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5311: LD_ADDR_VAR 0 2
5315: PUSH
5316: DOUBLE
5317: LD_INT 1
5319: DEC
5320: ST_TO_ADDR
5321: LD_INT 7
5323: PUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 4
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: LIST
5334: PUSH
5335: LD_OWVAR 67
5339: ARRAY
5340: PUSH
5341: FOR_TO
5342: IFFALSE 5437
// begin vehicle := CreateVehicle ;
5344: LD_ADDR_VAR 0 6
5348: PUSH
5349: CALL_OW 45
5353: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5354: LD_VAR 0 7
5358: PUSH
5359: LD_INT 1
5361: ARRAY
5362: PPUSH
5363: LD_VAR 0 6
5367: PPUSH
5368: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5372: LD_ADDR_VAR 0 7
5376: PUSH
5377: LD_VAR 0 7
5381: PUSH
5382: LD_VAR 0 7
5386: PUSH
5387: LD_INT 1
5389: ARRAY
5390: DIFF
5391: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5392: LD_VAR 0 6
5396: PPUSH
5397: LD_INT 1
5399: PPUSH
5400: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5404: LD_VAR 0 6
5408: PPUSH
5409: LD_INT 7
5411: PPUSH
5412: LD_INT 0
5414: PPUSH
5415: CALL_OW 49
// vehs := vehs ^ vehicle ;
5419: LD_ADDR_VAR 0 5
5423: PUSH
5424: LD_VAR 0 5
5428: PUSH
5429: LD_VAR 0 6
5433: ADD
5434: ST_TO_ADDR
// end ;
5435: GO 5341
5437: POP
5438: POP
// end ; end_of_file
5439: LD_VAR 0 1
5443: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export startCrates ; export function GameType ; var i , ruStartTechs ; begin
5444: LD_INT 0
5446: PPUSH
5447: PPUSH
5448: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5449: LD_ADDR_OWVAR 67
5453: PUSH
5454: LD_INT 0
5456: PPUSH
5457: CALL_OW 426
5461: ST_TO_ADDR
// game_diff := Difficulty ;
5462: LD_ADDR_EXP 38
5466: PUSH
5467: LD_OWVAR 67
5471: ST_TO_ADDR
// game_skill := [ 7 , 6 , 5 ] [ game_diff ] ;
5472: LD_ADDR_EXP 39
5476: PUSH
5477: LD_INT 7
5479: PUSH
5480: LD_INT 6
5482: PUSH
5483: LD_INT 5
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: LD_EXP 38
5495: ARRAY
5496: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5497: LD_ADDR_EXP 40
5501: PUSH
5502: LD_INT 6
5504: PUSH
5505: LD_INT 7
5507: PUSH
5508: LD_INT 8
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_EXP 38
5520: ARRAY
5521: ST_TO_ADDR
// ruArrival := [ 3 3$00 , 2 2$00 , 1 1$00 ] [ game_diff ] ;
5522: LD_ADDR_EXP 42
5526: PUSH
5527: LD_INT 6300
5529: PUSH
5530: LD_INT 4200
5532: PUSH
5533: LD_INT 2100
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: LIST
5540: PUSH
5541: LD_EXP 38
5545: ARRAY
5546: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5547: LD_ADDR_EXP 41
5551: PUSH
5552: LD_INT 73500
5554: PUSH
5555: LD_INT 94500
5557: PUSH
5558: LD_INT 115500
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: PUSH
5566: LD_EXP 38
5570: ARRAY
5571: ST_TO_ADDR
// ruStartTechs = [ [ tech_Weap1 ] , [ tech_Weap1 , tech_Comp1 ] , [ tech_Weap1 , tech_Weap2 , tech_Comp1 ] ] ;
5572: LD_ADDR_VAR 0 3
5576: PUSH
5577: LD_INT 51
5579: PUSH
5580: EMPTY
5581: LIST
5582: PUSH
5583: LD_INT 51
5585: PUSH
5586: LD_INT 57
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 51
5595: PUSH
5596: LD_INT 52
5598: PUSH
5599: LD_INT 57
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: ST_TO_ADDR
// startCrates = [ [ 300 , 350 ] , [ 230 , 200 ] , [ 150 , 100 ] ] [ game_diff ] ;
5612: LD_ADDR_EXP 43
5616: PUSH
5617: LD_INT 300
5619: PUSH
5620: LD_INT 350
5622: PUSH
5623: EMPTY
5624: LIST
5625: LIST
5626: PUSH
5627: LD_INT 230
5629: PUSH
5630: LD_INT 200
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 150
5639: PUSH
5640: LD_INT 100
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_EXP 38
5656: ARRAY
5657: ST_TO_ADDR
// for i := 1 to ruStartTechs [ game_diff ] do
5658: LD_ADDR_VAR 0 2
5662: PUSH
5663: DOUBLE
5664: LD_INT 1
5666: DEC
5667: ST_TO_ADDR
5668: LD_VAR 0 3
5672: PUSH
5673: LD_EXP 38
5677: ARRAY
5678: PUSH
5679: FOR_TO
5680: IFFALSE 5738
// begin SetTech ( ruStartTechs [ game_diff ] [ i ] , 3 , state_researched ) ;
5682: LD_VAR 0 3
5686: PUSH
5687: LD_EXP 38
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: LD_INT 3
5701: PPUSH
5702: LD_INT 2
5704: PPUSH
5705: CALL_OW 322
// SetTech ( ruStartTechs [ game_diff ] [ i ] , 6 , state_researched ) ;
5709: LD_VAR 0 3
5713: PUSH
5714: LD_EXP 38
5718: ARRAY
5719: PUSH
5720: LD_VAR 0 2
5724: ARRAY
5725: PPUSH
5726: LD_INT 6
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 322
// end ;
5736: GO 5679
5738: POP
5739: POP
// end ; end_of_file
5740: LD_VAR 0 1
5744: RET
// export function CustomEvent ( event ) ; begin
5745: LD_INT 0
5747: PPUSH
// end ;
5748: LD_VAR 0 2
5752: RET
// export function CustomInitMacro ( ) ; begin
5753: LD_INT 0
5755: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5756: LD_INT 1
5758: PPUSH
5759: LD_INT 3
5761: PPUSH
5762: CALL 79354 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5766: LD_INT 1
5768: PPUSH
5769: LD_INT 4
5771: PPUSH
5772: CALL 79298 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5776: LD_INT 1
5778: PPUSH
5779: LD_INT 136
5781: PUSH
5782: LD_INT 130
5784: PUSH
5785: LD_INT 0
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 145
5795: PUSH
5796: LD_INT 123
5798: PUSH
5799: LD_INT 0
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: CALL 78357 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5815: LD_INT 1
5817: PPUSH
5818: LD_INT 43
5820: PUSH
5821: LD_INT 46
5823: PUSH
5824: LD_INT 45
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PPUSH
5832: CALL 79186 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5836: LD_INT 1
5838: PPUSH
5839: LD_INT 3
5841: PPUSH
5842: CALL 78868 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5846: LD_INT 1
5848: PPUSH
5849: LD_INT 3
5851: PPUSH
5852: CALL 78599 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5856: LD_INT 1
5858: PPUSH
5859: LD_INT 8
5861: PPUSH
5862: CALL 78218 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5866: LD_INT 1
5868: PPUSH
5869: LD_INT 22
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: LD_INT 3
5877: PUSH
5878: LD_INT 43
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: PUSH
5887: LD_INT 22
5889: PUSH
5890: LD_INT 1
5892: PUSH
5893: LD_INT 3
5895: PUSH
5896: LD_INT 44
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 22
5907: PUSH
5908: LD_INT 1
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: LD_INT 45
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: PUSH
5923: LD_INT 24
5925: PUSH
5926: LD_INT 1
5928: PUSH
5929: LD_INT 3
5931: PUSH
5932: LD_INT 43
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_INT 24
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 3
5949: PUSH
5950: LD_INT 43
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 24
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: LD_INT 3
5967: PUSH
5968: LD_INT 46
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: PUSH
5977: LD_INT 22
5979: PUSH
5980: LD_INT 1
5982: PUSH
5983: LD_INT 3
5985: PUSH
5986: LD_INT 43
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 22
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: LD_INT 3
6003: PUSH
6004: LD_INT 44
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: LIST
6011: LIST
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PPUSH
6023: CALL 78033 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
6027: LD_INT 1
6029: PPUSH
6030: LD_INT 0
6032: PUSH
6033: LD_INT 127
6035: PUSH
6036: LD_INT 125
6038: PUSH
6039: LD_INT 5
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 6
6050: PUSH
6051: LD_INT 124
6053: PUSH
6054: LD_INT 132
6056: PUSH
6057: LD_INT 0
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 29
6068: PUSH
6069: LD_INT 136
6071: PUSH
6072: LD_INT 130
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 4
6086: PUSH
6087: LD_INT 118
6089: PUSH
6090: LD_INT 114
6092: PUSH
6093: LD_INT 2
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 29
6104: PUSH
6105: LD_INT 145
6107: PUSH
6108: LD_INT 123
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 26
6122: PUSH
6123: LD_INT 150
6125: PUSH
6126: LD_INT 135
6128: PUSH
6129: LD_INT 1
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 26
6140: PUSH
6141: LD_INT 140
6143: PUSH
6144: LD_INT 134
6146: PUSH
6147: LD_INT 2
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_INT 26
6158: PUSH
6159: LD_INT 137
6161: PUSH
6162: LD_INT 121
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 2
6176: PUSH
6177: LD_INT 155
6179: PUSH
6180: LD_INT 130
6182: PUSH
6183: LD_INT 0
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 32
6194: PUSH
6195: LD_INT 155
6197: PUSH
6198: LD_INT 130
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 32
6212: PUSH
6213: LD_INT 130
6215: PUSH
6216: LD_INT 114
6218: PUSH
6219: LD_INT 3
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 32
6230: PUSH
6231: LD_INT 142
6233: PUSH
6234: LD_INT 115
6236: PUSH
6237: LD_INT 3
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 32
6248: PUSH
6249: LD_INT 153
6251: PUSH
6252: LD_INT 120
6254: PUSH
6255: LD_INT 3
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: PPUSH
6279: CALL 77925 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
6283: LD_INT 1
6285: PPUSH
6286: LD_INT 10
6288: PUSH
6289: LD_INT 12
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: PPUSH
6296: CALL 78775 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6300: LD_INT 1
6302: PPUSH
6303: LD_INT 155
6305: PPUSH
6306: LD_INT 130
6308: PPUSH
6309: LD_INT 0
6311: PPUSH
6312: LD_INT 24
6314: PUSH
6315: LD_INT 16
6317: PUSH
6318: LD_INT 17
6320: PUSH
6321: LD_INT 18
6323: PUSH
6324: LD_INT 21
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL 78980 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
6338: LD_INT 2
6340: PPUSH
6341: LD_INT 3
6343: PPUSH
6344: CALL 79354 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 4
6353: PPUSH
6354: CALL 79298 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
6358: LD_INT 2
6360: PPUSH
6361: LD_INT 84
6363: PUSH
6364: LD_INT 125
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: EMPTY
6376: LIST
6377: PPUSH
6378: CALL 78357 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
6382: LD_INT 2
6384: PPUSH
6385: LD_INT 43
6387: PUSH
6388: LD_INT 46
6390: PUSH
6391: LD_INT 45
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: LIST
6398: PPUSH
6399: CALL 79186 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
6403: LD_INT 2
6405: PPUSH
6406: LD_INT 3
6408: PPUSH
6409: CALL 78868 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6413: LD_INT 2
6415: PPUSH
6416: LD_INT 3
6418: PPUSH
6419: CALL 78599 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6423: LD_INT 2
6425: PPUSH
6426: LD_INT 8
6428: PPUSH
6429: CALL 78218 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6433: LD_INT 2
6435: PPUSH
6436: LD_INT 22
6438: PUSH
6439: LD_INT 3
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: LD_INT 43
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 22
6456: PUSH
6457: LD_INT 3
6459: PUSH
6460: LD_INT 3
6462: PUSH
6463: LD_INT 44
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 22
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: LD_INT 3
6480: PUSH
6481: LD_INT 45
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 24
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 43
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 24
6510: PUSH
6511: LD_INT 3
6513: PUSH
6514: LD_INT 3
6516: PUSH
6517: LD_INT 43
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 24
6528: PUSH
6529: LD_INT 3
6531: PUSH
6532: LD_INT 3
6534: PUSH
6535: LD_INT 46
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 22
6546: PUSH
6547: LD_INT 3
6549: PUSH
6550: LD_INT 3
6552: PUSH
6553: LD_INT 43
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 22
6564: PUSH
6565: LD_INT 3
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 44
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: LIST
6588: LIST
6589: PPUSH
6590: CALL 78033 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6594: LD_INT 2
6596: PPUSH
6597: LD_INT 0
6599: PUSH
6600: LD_INT 96
6602: PUSH
6603: LD_INT 125
6605: PUSH
6606: LD_INT 0
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 6
6617: PUSH
6618: LD_INT 74
6620: PUSH
6621: LD_INT 122
6623: PUSH
6624: LD_INT 1
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 30
6635: PUSH
6636: LD_INT 84
6638: PUSH
6639: LD_INT 125
6641: PUSH
6642: LD_INT 1
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 28
6653: PUSH
6654: LD_INT 86
6656: PUSH
6657: LD_INT 128
6659: PUSH
6660: LD_INT 1
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 28
6671: PUSH
6672: LD_INT 85
6674: PUSH
6675: LD_INT 130
6677: PUSH
6678: LD_INT 2
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 28
6689: PUSH
6690: LD_INT 88
6692: PUSH
6693: LD_INT 132
6695: PUSH
6696: LD_INT 5
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: LD_INT 2
6707: PUSH
6708: LD_INT 106
6710: PUSH
6711: LD_INT 130
6713: PUSH
6714: LD_INT 0
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 4
6725: PUSH
6726: LD_INT 99
6728: PUSH
6729: LD_INT 114
6731: PUSH
6732: LD_INT 3
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: PUSH
6741: LD_INT 32
6743: PUSH
6744: LD_INT 72
6746: PUSH
6747: LD_INT 112
6749: PUSH
6750: LD_INT 2
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 32
6761: PUSH
6762: LD_INT 78
6764: PUSH
6765: LD_INT 110
6767: PUSH
6768: LD_INT 3
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: PUSH
6777: LD_INT 32
6779: PUSH
6780: LD_INT 84
6782: PUSH
6783: LD_INT 110
6785: PUSH
6786: LD_INT 2
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: PUSH
6795: LD_INT 32
6797: PUSH
6798: LD_INT 105
6800: PUSH
6801: LD_INT 117
6803: PUSH
6804: LD_INT 3
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: LIST
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL 77925 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6831: LD_INT 2
6833: PPUSH
6834: LD_INT 14
6836: PUSH
6837: LD_INT 11
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PPUSH
6844: CALL 78775 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6848: LD_INT 2
6850: PPUSH
6851: LD_INT 106
6853: PPUSH
6854: LD_INT 130
6856: PPUSH
6857: LD_INT 0
6859: PPUSH
6860: LD_INT 24
6862: PUSH
6863: LD_INT 16
6865: PUSH
6866: LD_INT 17
6868: PUSH
6869: LD_INT 18
6871: PUSH
6872: LD_INT 21
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: LIST
6879: LIST
6880: LIST
6881: PPUSH
6882: CALL 78980 0 5
// end ;
6886: LD_VAR 0 1
6890: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6891: LD_INT 22
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 30
6903: PUSH
6904: LD_INT 3
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PPUSH
6915: CALL_OW 69
6919: IFFALSE 8062
6921: GO 6923
6923: DISABLE
6924: LD_INT 0
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
6931: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
6932: LD_INT 6300
6934: PUSH
6935: LD_INT 4200
6937: PUSH
6938: LD_INT 2100
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: LIST
6945: PUSH
6946: LD_OWVAR 67
6950: ARRAY
6951: PPUSH
6952: CALL_OW 67
// base := 2 ;
6956: LD_ADDR_VAR 0 2
6960: PUSH
6961: LD_INT 2
6963: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
6964: LD_INT 22
6966: PUSH
6967: LD_INT 3
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 30
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PPUSH
6988: CALL_OW 69
6992: NOT
6993: IFFALSE 6997
// continue ;
6995: GO 6932
// case Rand ( 1 , 3 ) of 1 :
6997: LD_INT 1
6999: PPUSH
7000: LD_INT 3
7002: PPUSH
7003: CALL_OW 12
7007: PUSH
7008: LD_INT 1
7010: DOUBLE
7011: EQUAL
7012: IFTRUE 7016
7014: GO 7192
7016: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7017: LD_ADDR_VAR 0 3
7021: PUSH
7022: LD_INT 22
7024: PUSH
7025: LD_INT 3
7027: PUSH
7028: LD_INT 3
7030: PUSH
7031: LD_INT 43
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 24
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 3
7048: PUSH
7049: LD_INT 46
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 24
7060: PUSH
7061: LD_INT 3
7063: PUSH
7064: LD_INT 3
7066: PUSH
7067: LD_INT 43
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 24
7078: PUSH
7079: LD_INT 3
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: LD_INT 46
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PUSH
7094: LD_INT 22
7096: PUSH
7097: LD_INT 3
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 45
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: LD_INT 3
7120: PUSH
7121: LD_INT 43
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: PUSH
7130: LD_INT 24
7132: PUSH
7133: LD_INT 3
7135: PUSH
7136: LD_INT 3
7138: PUSH
7139: LD_INT 46
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: PUSH
7148: LD_INT 22
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 3
7156: PUSH
7157: LD_INT 45
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7176: LD_VAR 0 2
7180: PPUSH
7181: LD_VAR 0 3
7185: PPUSH
7186: CALL 78081 0 2
// end ; 2 :
7190: GO 7523
7192: LD_INT 2
7194: DOUBLE
7195: EQUAL
7196: IFTRUE 7200
7198: GO 7338
7200: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7201: LD_ADDR_VAR 0 3
7205: PUSH
7206: LD_INT 24
7208: PUSH
7209: LD_INT 3
7211: PUSH
7212: LD_INT 3
7214: PUSH
7215: LD_INT 43
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: PUSH
7224: LD_INT 24
7226: PUSH
7227: LD_INT 3
7229: PUSH
7230: LD_INT 3
7232: PUSH
7233: LD_INT 46
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: PUSH
7242: LD_INT 24
7244: PUSH
7245: LD_INT 3
7247: PUSH
7248: LD_INT 3
7250: PUSH
7251: LD_INT 43
7253: PUSH
7254: EMPTY
7255: LIST
7256: LIST
7257: LIST
7258: LIST
7259: PUSH
7260: LD_INT 24
7262: PUSH
7263: LD_INT 3
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: LD_INT 46
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: PUSH
7278: LD_INT 22
7280: PUSH
7281: LD_INT 3
7283: PUSH
7284: LD_INT 3
7286: PUSH
7287: LD_INT 45
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 22
7298: PUSH
7299: LD_INT 3
7301: PUSH
7302: LD_INT 3
7304: PUSH
7305: LD_INT 45
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: LIST
7318: LIST
7319: LIST
7320: LIST
7321: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7322: LD_VAR 0 2
7326: PPUSH
7327: LD_VAR 0 3
7331: PPUSH
7332: CALL 78081 0 2
// end ; 3 :
7336: GO 7523
7338: LD_INT 3
7340: DOUBLE
7341: EQUAL
7342: IFTRUE 7346
7344: GO 7522
7346: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7347: LD_ADDR_VAR 0 3
7351: PUSH
7352: LD_INT 22
7354: PUSH
7355: LD_INT 3
7357: PUSH
7358: LD_INT 3
7360: PUSH
7361: LD_INT 43
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 24
7372: PUSH
7373: LD_INT 3
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: LD_INT 46
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: LD_INT 3
7396: PUSH
7397: LD_INT 43
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: LD_INT 24
7408: PUSH
7409: LD_INT 3
7411: PUSH
7412: LD_INT 3
7414: PUSH
7415: LD_INT 46
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_INT 3
7429: PUSH
7430: LD_INT 3
7432: PUSH
7433: LD_INT 45
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: LD_INT 22
7444: PUSH
7445: LD_INT 3
7447: PUSH
7448: LD_INT 3
7450: PUSH
7451: LD_INT 43
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 24
7462: PUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: LD_INT 46
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: LIST
7476: LIST
7477: PUSH
7478: LD_INT 22
7480: PUSH
7481: LD_INT 3
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 45
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7506: LD_VAR 0 2
7510: PPUSH
7511: LD_VAR 0 3
7515: PPUSH
7516: CALL 78081 0 2
// end ; end ;
7520: GO 7523
7522: POP
// repeat wait ( 0 0$1 ) ;
7523: LD_INT 35
7525: PPUSH
7526: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7530: LD_VAR 0 2
7534: PPUSH
7535: CALL 78429 0 1
7539: PUSH
7540: LD_INT 0
7542: EQUAL
7543: IFFALSE 7523
// wait ( 0 0$30 ) ;
7545: LD_INT 1050
7547: PPUSH
7548: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7552: LD_ADDR_VAR 0 5
7556: PUSH
7557: LD_INT 86
7559: PUSH
7560: LD_INT 77
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 63
7569: PUSH
7570: LD_INT 38
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7581: LD_ADDR_VAR 0 4
7585: PUSH
7586: LD_INT 0
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: LD_INT 0
7594: PUSH
7595: LD_INT 1
7597: PUSH
7598: LD_INT 0
7600: PUSH
7601: LD_INT 0
7603: PUSH
7604: LD_INT 0
7606: PUSH
7607: LD_INT 0
7609: PUSH
7610: LD_INT 1
7612: PUSH
7613: LD_INT 0
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7628: LD_ADDR_VAR 0 6
7632: PUSH
7633: LD_EXP 88
7637: PUSH
7638: LD_VAR 0 2
7642: ARRAY
7643: PUSH
7644: LD_EXP 91
7648: PUSH
7649: LD_VAR 0 2
7653: ARRAY
7654: DIFF
7655: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7656: LD_ADDR_EXP 88
7660: PUSH
7661: LD_EXP 88
7665: PPUSH
7666: LD_VAR 0 2
7670: PPUSH
7671: LD_EXP 88
7675: PUSH
7676: LD_VAR 0 2
7680: ARRAY
7681: PUSH
7682: LD_VAR 0 6
7686: DIFF
7687: PPUSH
7688: CALL_OW 1
7692: ST_TO_ADDR
// if not attackers then
7693: LD_VAR 0 6
7697: NOT
7698: IFFALSE 7702
// continue ;
7700: GO 6932
// repeat wait ( 0 0$1 ) ;
7702: LD_INT 35
7704: PPUSH
7705: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7709: LD_VAR 0 6
7713: PPUSH
7714: LD_INT 60
7716: PUSH
7717: EMPTY
7718: LIST
7719: PPUSH
7720: CALL_OW 72
7724: NOT
7725: IFFALSE 7702
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// for i in attackers do
7734: LD_ADDR_VAR 0 1
7738: PUSH
7739: LD_VAR 0 6
7743: PUSH
7744: FOR_IN
7745: IFFALSE 8029
// begin if IsDead ( i ) then
7747: LD_VAR 0 1
7751: PPUSH
7752: CALL_OW 301
7756: IFFALSE 7774
// attackers := attackers diff i ;
7758: LD_ADDR_VAR 0 6
7762: PUSH
7763: LD_VAR 0 6
7767: PUSH
7768: LD_VAR 0 1
7772: DIFF
7773: ST_TO_ADDR
// if not HasTask ( i ) then
7774: LD_VAR 0 1
7778: PPUSH
7779: CALL_OW 314
7783: NOT
7784: IFFALSE 8027
// begin if not GetTag ( i ) then
7786: LD_VAR 0 1
7790: PPUSH
7791: CALL_OW 110
7795: NOT
7796: IFFALSE 7888
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
7798: LD_VAR 0 1
7802: PPUSH
7803: LD_VAR 0 5
7807: PUSH
7808: LD_INT 1
7810: ARRAY
7811: PUSH
7812: LD_INT 1
7814: ARRAY
7815: PPUSH
7816: LD_VAR 0 5
7820: PUSH
7821: LD_INT 1
7823: ARRAY
7824: PUSH
7825: LD_INT 2
7827: ARRAY
7828: PPUSH
7829: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
7833: LD_VAR 0 1
7837: PPUSH
7838: LD_VAR 0 5
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PUSH
7847: LD_INT 1
7849: ARRAY
7850: PPUSH
7851: LD_VAR 0 5
7855: PUSH
7856: LD_INT 1
7858: ARRAY
7859: PUSH
7860: LD_INT 2
7862: ARRAY
7863: PPUSH
7864: CALL_OW 297
7868: PUSH
7869: LD_INT 8
7871: LESS
7872: IFFALSE 7886
// SetTag ( i , 1 ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_INT 1
7881: PPUSH
7882: CALL_OW 109
// end else
7886: GO 8027
// if GetTag ( i ) = 1 then
7888: LD_VAR 0 1
7892: PPUSH
7893: CALL_OW 110
7897: PUSH
7898: LD_INT 1
7900: EQUAL
7901: IFFALSE 7993
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
7903: LD_VAR 0 1
7907: PPUSH
7908: LD_VAR 0 5
7912: PUSH
7913: LD_INT 2
7915: ARRAY
7916: PUSH
7917: LD_INT 1
7919: ARRAY
7920: PPUSH
7921: LD_VAR 0 5
7925: PUSH
7926: LD_INT 2
7928: ARRAY
7929: PUSH
7930: LD_INT 2
7932: ARRAY
7933: PPUSH
7934: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
7938: LD_VAR 0 1
7942: PPUSH
7943: LD_VAR 0 5
7947: PUSH
7948: LD_INT 2
7950: ARRAY
7951: PUSH
7952: LD_INT 1
7954: ARRAY
7955: PPUSH
7956: LD_VAR 0 5
7960: PUSH
7961: LD_INT 2
7963: ARRAY
7964: PUSH
7965: LD_INT 2
7967: ARRAY
7968: PPUSH
7969: CALL_OW 297
7973: PUSH
7974: LD_INT 8
7976: LESS
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// end else
7991: GO 8027
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_INT 81
8000: PUSH
8001: LD_INT 3
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PPUSH
8008: CALL_OW 69
8012: PPUSH
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL_OW 74
8022: PPUSH
8023: CALL_OW 115
// end ; end ;
8027: GO 7744
8029: POP
8030: POP
// until not attackers ;
8031: LD_VAR 0 6
8035: NOT
8036: IFFALSE 7727
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8038: LD_EXP 69
8042: PUSH
8043: LD_VAR 0 2
8047: ARRAY
8048: PPUSH
8049: LD_INT 50
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 72
8059: NOT
8060: IFFALSE 6932
// end ;
8062: PPOPN 6
8064: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
8065: LD_INT 22
8067: PUSH
8068: LD_INT 3
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: LD_INT 30
8077: PUSH
8078: LD_INT 3
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PPUSH
8089: CALL_OW 69
8093: IFFALSE 9277
8095: GO 8097
8097: DISABLE
8098: LD_INT 0
8100: PPUSH
8101: PPUSH
8102: PPUSH
8103: PPUSH
8104: PPUSH
8105: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
8106: LD_INT 6300
8108: PUSH
8109: LD_INT 4200
8111: PUSH
8112: LD_INT 2100
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PPUSH
8126: CALL_OW 67
// base := 1 ;
8130: LD_ADDR_VAR 0 2
8134: PUSH
8135: LD_INT 1
8137: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8138: LD_INT 22
8140: PUSH
8141: LD_INT 3
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 30
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PPUSH
8162: CALL_OW 69
8166: NOT
8167: IFFALSE 8171
// continue ;
8169: GO 8106
// case Rand ( 1 , 3 ) of 1 :
8171: LD_INT 1
8173: PPUSH
8174: LD_INT 3
8176: PPUSH
8177: CALL_OW 12
8181: PUSH
8182: LD_INT 1
8184: DOUBLE
8185: EQUAL
8186: IFTRUE 8190
8188: GO 8366
8190: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8191: LD_ADDR_VAR 0 3
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 1
8201: PUSH
8202: LD_INT 3
8204: PUSH
8205: LD_INT 43
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 24
8216: PUSH
8217: LD_INT 1
8219: PUSH
8220: LD_INT 3
8222: PUSH
8223: LD_INT 46
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 24
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: LD_INT 3
8240: PUSH
8241: LD_INT 43
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: PUSH
8250: LD_INT 24
8252: PUSH
8253: LD_INT 1
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: LD_INT 46
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: PUSH
8268: LD_INT 22
8270: PUSH
8271: LD_INT 1
8273: PUSH
8274: LD_INT 3
8276: PUSH
8277: LD_INT 45
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: LIST
8284: LIST
8285: PUSH
8286: LD_INT 22
8288: PUSH
8289: LD_INT 1
8291: PUSH
8292: LD_INT 3
8294: PUSH
8295: LD_INT 43
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: LIST
8302: LIST
8303: PUSH
8304: LD_INT 24
8306: PUSH
8307: LD_INT 1
8309: PUSH
8310: LD_INT 3
8312: PUSH
8313: LD_INT 46
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_INT 22
8324: PUSH
8325: LD_INT 1
8327: PUSH
8328: LD_INT 3
8330: PUSH
8331: LD_INT 45
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: LIST
8349: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_VAR 0 3
8359: PPUSH
8360: CALL 78081 0 2
// end ; 2 :
8364: GO 8735
8366: LD_INT 2
8368: DOUBLE
8369: EQUAL
8370: IFTRUE 8374
8372: GO 8550
8374: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8375: LD_ADDR_VAR 0 3
8379: PUSH
8380: LD_INT 24
8382: PUSH
8383: LD_INT 1
8385: PUSH
8386: LD_INT 3
8388: PUSH
8389: LD_INT 43
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 24
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: LD_INT 3
8406: PUSH
8407: LD_INT 46
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 24
8418: PUSH
8419: LD_INT 1
8421: PUSH
8422: LD_INT 3
8424: PUSH
8425: LD_INT 43
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 24
8436: PUSH
8437: LD_INT 1
8439: PUSH
8440: LD_INT 3
8442: PUSH
8443: LD_INT 46
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: LIST
8451: PUSH
8452: LD_INT 22
8454: PUSH
8455: LD_INT 1
8457: PUSH
8458: LD_INT 3
8460: PUSH
8461: LD_INT 45
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 22
8472: PUSH
8473: LD_INT 1
8475: PUSH
8476: LD_INT 3
8478: PUSH
8479: LD_INT 45
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 22
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 3
8496: PUSH
8497: LD_INT 45
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 1
8511: PUSH
8512: LD_INT 3
8514: PUSH
8515: LD_INT 45
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: LIST
8533: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8534: LD_VAR 0 2
8538: PPUSH
8539: LD_VAR 0 3
8543: PPUSH
8544: CALL 78081 0 2
// end ; 3 :
8548: GO 8735
8550: LD_INT 3
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8734
8558: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: LD_INT 22
8566: PUSH
8567: LD_INT 1
8569: PUSH
8570: LD_INT 3
8572: PUSH
8573: LD_INT 43
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_INT 24
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: LD_INT 3
8590: PUSH
8591: LD_INT 46
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 22
8602: PUSH
8603: LD_INT 1
8605: PUSH
8606: LD_INT 3
8608: PUSH
8609: LD_INT 43
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: LIST
8616: LIST
8617: PUSH
8618: LD_INT 24
8620: PUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: LD_INT 46
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: LIST
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: LD_INT 45
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: PUSH
8654: LD_INT 22
8656: PUSH
8657: LD_INT 1
8659: PUSH
8660: LD_INT 3
8662: PUSH
8663: LD_INT 43
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: LIST
8670: LIST
8671: PUSH
8672: LD_INT 24
8674: PUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: LD_INT 46
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 22
8692: PUSH
8693: LD_INT 1
8695: PUSH
8696: LD_INT 3
8698: PUSH
8699: LD_INT 45
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: LIST
8706: LIST
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8718: LD_VAR 0 2
8722: PPUSH
8723: LD_VAR 0 3
8727: PPUSH
8728: CALL 78081 0 2
// end ; end ;
8732: GO 8735
8734: POP
// repeat wait ( 0 0$1 ) ;
8735: LD_INT 35
8737: PPUSH
8738: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8742: LD_VAR 0 2
8746: PPUSH
8747: LD_INT 1
8749: PPUSH
8750: CALL 79499 0 2
8754: PUSH
8755: LD_INT 8
8757: GREATEREQUAL
8758: IFFALSE 8735
// wait ( 0 0$30 ) ;
8760: LD_INT 1050
8762: PPUSH
8763: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8767: LD_ADDR_VAR 0 5
8771: PUSH
8772: LD_INT 144
8774: PUSH
8775: LD_INT 65
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 63
8784: PUSH
8785: LD_INT 38
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: PUSH
8792: EMPTY
8793: LIST
8794: LIST
8795: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8796: LD_ADDR_VAR 0 4
8800: PUSH
8801: LD_INT 0
8803: PUSH
8804: LD_INT 0
8806: PUSH
8807: LD_INT 0
8809: PUSH
8810: LD_INT 1
8812: PUSH
8813: LD_INT 0
8815: PUSH
8816: LD_INT 0
8818: PUSH
8819: LD_INT 0
8821: PUSH
8822: LD_INT 0
8824: PUSH
8825: LD_INT 1
8827: PUSH
8828: LD_INT 0
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_EXP 88
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PUSH
8859: LD_EXP 91
8863: PUSH
8864: LD_VAR 0 2
8868: ARRAY
8869: DIFF
8870: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8871: LD_ADDR_EXP 88
8875: PUSH
8876: LD_EXP 88
8880: PPUSH
8881: LD_VAR 0 2
8885: PPUSH
8886: LD_EXP 88
8890: PUSH
8891: LD_VAR 0 2
8895: ARRAY
8896: PUSH
8897: LD_VAR 0 6
8901: DIFF
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// if not attackers then
8908: LD_VAR 0 6
8912: NOT
8913: IFFALSE 8917
// continue ;
8915: GO 8106
// repeat wait ( 0 0$1 ) ;
8917: LD_INT 35
8919: PPUSH
8920: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8924: LD_VAR 0 6
8928: PPUSH
8929: LD_INT 60
8931: PUSH
8932: EMPTY
8933: LIST
8934: PPUSH
8935: CALL_OW 72
8939: NOT
8940: IFFALSE 8917
// repeat wait ( 0 0$1 ) ;
8942: LD_INT 35
8944: PPUSH
8945: CALL_OW 67
// for i in attackers do
8949: LD_ADDR_VAR 0 1
8953: PUSH
8954: LD_VAR 0 6
8958: PUSH
8959: FOR_IN
8960: IFFALSE 9244
// begin if IsDead ( i ) then
8962: LD_VAR 0 1
8966: PPUSH
8967: CALL_OW 301
8971: IFFALSE 8989
// attackers := attackers diff i ;
8973: LD_ADDR_VAR 0 6
8977: PUSH
8978: LD_VAR 0 6
8982: PUSH
8983: LD_VAR 0 1
8987: DIFF
8988: ST_TO_ADDR
// if not HasTask ( i ) then
8989: LD_VAR 0 1
8993: PPUSH
8994: CALL_OW 314
8998: NOT
8999: IFFALSE 9242
// begin if not GetTag ( i ) then
9001: LD_VAR 0 1
9005: PPUSH
9006: CALL_OW 110
9010: NOT
9011: IFFALSE 9103
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
9013: LD_VAR 0 1
9017: PPUSH
9018: LD_VAR 0 5
9022: PUSH
9023: LD_INT 1
9025: ARRAY
9026: PUSH
9027: LD_INT 1
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 5
9035: PUSH
9036: LD_INT 1
9038: ARRAY
9039: PUSH
9040: LD_INT 2
9042: ARRAY
9043: PPUSH
9044: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
9048: LD_VAR 0 1
9052: PPUSH
9053: LD_VAR 0 5
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PUSH
9062: LD_INT 1
9064: ARRAY
9065: PPUSH
9066: LD_VAR 0 5
9070: PUSH
9071: LD_INT 1
9073: ARRAY
9074: PUSH
9075: LD_INT 2
9077: ARRAY
9078: PPUSH
9079: CALL_OW 297
9083: PUSH
9084: LD_INT 8
9086: LESS
9087: IFFALSE 9101
// SetTag ( i , 1 ) ;
9089: LD_VAR 0 1
9093: PPUSH
9094: LD_INT 1
9096: PPUSH
9097: CALL_OW 109
// end else
9101: GO 9242
// if GetTag ( i ) = 1 then
9103: LD_VAR 0 1
9107: PPUSH
9108: CALL_OW 110
9112: PUSH
9113: LD_INT 1
9115: EQUAL
9116: IFFALSE 9208
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
9118: LD_VAR 0 1
9122: PPUSH
9123: LD_VAR 0 5
9127: PUSH
9128: LD_INT 2
9130: ARRAY
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_VAR 0 5
9140: PUSH
9141: LD_INT 2
9143: ARRAY
9144: PUSH
9145: LD_INT 2
9147: ARRAY
9148: PPUSH
9149: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
9153: LD_VAR 0 1
9157: PPUSH
9158: LD_VAR 0 5
9162: PUSH
9163: LD_INT 2
9165: ARRAY
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 5
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PUSH
9180: LD_INT 2
9182: ARRAY
9183: PPUSH
9184: CALL_OW 297
9188: PUSH
9189: LD_INT 8
9191: LESS
9192: IFFALSE 9206
// SetTag ( i , 2 ) ;
9194: LD_VAR 0 1
9198: PPUSH
9199: LD_INT 2
9201: PPUSH
9202: CALL_OW 109
// end else
9206: GO 9242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9208: LD_VAR 0 1
9212: PPUSH
9213: LD_INT 81
9215: PUSH
9216: LD_INT 3
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: PPUSH
9223: CALL_OW 69
9227: PPUSH
9228: LD_VAR 0 1
9232: PPUSH
9233: CALL_OW 74
9237: PPUSH
9238: CALL_OW 115
// end ; end ;
9242: GO 8959
9244: POP
9245: POP
// until not attackers ;
9246: LD_VAR 0 6
9250: NOT
9251: IFFALSE 8942
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
9253: LD_EXP 69
9257: PUSH
9258: LD_VAR 0 2
9262: ARRAY
9263: PPUSH
9264: LD_INT 50
9266: PUSH
9267: EMPTY
9268: LIST
9269: PPUSH
9270: CALL_OW 72
9274: NOT
9275: IFFALSE 8106
// end ;
9277: PPOPN 6
9279: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9280: LD_EXP 4
9284: PUSH
9285: LD_INT 22
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 21
9297: PUSH
9298: LD_INT 1
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 69
9313: PUSH
9314: LD_INT 0
9316: EQUAL
9317: AND
9318: IFFALSE 9331
9320: GO 9322
9322: DISABLE
// RussiansDefeated := true ;
9323: LD_ADDR_EXP 44
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
9331: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
9332: LD_EXP 4
9336: PUSH
9337: LD_EXP 6
9341: NOT
9342: AND
9343: IFFALSE 10767
9345: GO 9347
9347: DISABLE
9348: LD_INT 0
9350: PPUSH
9351: PPUSH
9352: PPUSH
9353: PPUSH
9354: PPUSH
9355: PPUSH
9356: PPUSH
9357: PPUSH
9358: PPUSH
9359: PPUSH
9360: PPUSH
9361: PPUSH
// begin wait ( [ Rand ( 4 4$00 , 4 4$30 ) , Rand ( 4 4$30 , 3 3$30 ) , Rand ( 3 3$00 , 2 2$00 ) ] [ Difficulty ] ) ;
9362: LD_INT 8400
9364: PPUSH
9365: LD_INT 9450
9367: PPUSH
9368: CALL_OW 12
9372: PUSH
9373: LD_INT 9450
9375: PPUSH
9376: LD_INT 7350
9378: PPUSH
9379: CALL_OW 12
9383: PUSH
9384: LD_INT 6300
9386: PPUSH
9387: LD_INT 4200
9389: PPUSH
9390: CALL_OW 12
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: LD_OWVAR 67
9404: ARRAY
9405: PPUSH
9406: CALL_OW 67
// filter := [ ] ;
9410: LD_ADDR_VAR 0 3
9414: PUSH
9415: EMPTY
9416: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9417: LD_ADDR_VAR 0 4
9421: PUSH
9422: LD_INT 2
9424: PPUSH
9425: LD_INT 3
9427: PPUSH
9428: CALL_OW 12
9432: PUSH
9433: LD_INT 3
9435: PPUSH
9436: LD_INT 4
9438: PPUSH
9439: CALL_OW 12
9443: PUSH
9444: LD_INT 3
9446: PPUSH
9447: LD_INT 5
9449: PPUSH
9450: CALL_OW 12
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: LIST
9459: PUSH
9460: LD_OWVAR 67
9464: ARRAY
9465: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 1
9473: PUSH
9474: LD_INT 1
9476: PPUSH
9477: LD_INT 2
9479: PPUSH
9480: CALL_OW 12
9484: PUSH
9485: LD_INT 2
9487: PPUSH
9488: LD_INT 3
9490: PPUSH
9491: CALL_OW 12
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: LIST
9500: PUSH
9501: LD_OWVAR 67
9505: ARRAY
9506: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9507: LD_ADDR_VAR 0 6
9511: PUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: PUSH
9523: LD_INT 2
9525: PPUSH
9526: LD_INT 4
9528: PPUSH
9529: CALL_OW 12
9533: PUSH
9534: LD_INT 3
9536: PPUSH
9537: LD_INT 5
9539: PPUSH
9540: CALL_OW 12
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_OWVAR 67
9554: ARRAY
9555: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
9556: LD_ADDR_VAR 0 8
9560: PUSH
9561: LD_INT 1
9563: PUSH
9564: LD_INT 2
9566: PUSH
9567: LD_INT 2
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: LD_OWVAR 67
9579: ARRAY
9580: ST_TO_ADDR
// uc_side := 3 ;
9581: LD_ADDR_OWVAR 20
9585: PUSH
9586: LD_INT 3
9588: ST_TO_ADDR
// uc_nation := nation_russian ;
9589: LD_ADDR_OWVAR 21
9593: PUSH
9594: LD_INT 3
9596: ST_TO_ADDR
// for i = 1 to soldiers do
9597: LD_ADDR_VAR 0 1
9601: PUSH
9602: DOUBLE
9603: LD_INT 1
9605: DEC
9606: ST_TO_ADDR
9607: LD_VAR 0 4
9611: PUSH
9612: FOR_TO
9613: IFFALSE 9655
// begin PrepareSoldier ( 0 , game_eskill ) ;
9615: LD_INT 0
9617: PPUSH
9618: LD_EXP 40
9622: PPUSH
9623: CALL_OW 381
// un := CreateHuman ;
9627: LD_ADDR_VAR 0 2
9631: PUSH
9632: CALL_OW 44
9636: ST_TO_ADDR
// filter := filter ^ un ;
9637: LD_ADDR_VAR 0 3
9641: PUSH
9642: LD_VAR 0 3
9646: PUSH
9647: LD_VAR 0 2
9651: ADD
9652: ST_TO_ADDR
// end ;
9653: GO 9612
9655: POP
9656: POP
// for i = 1 to bazookas do
9657: LD_ADDR_VAR 0 1
9661: PUSH
9662: DOUBLE
9663: LD_INT 1
9665: DEC
9666: ST_TO_ADDR
9667: LD_VAR 0 5
9671: PUSH
9672: FOR_TO
9673: IFFALSE 9723
// begin PrepareSoldier ( 0 , game_eskill ) ;
9675: LD_INT 0
9677: PPUSH
9678: LD_EXP 40
9682: PPUSH
9683: CALL_OW 381
// hc_class := class_bazooker ;
9687: LD_ADDR_OWVAR 28
9691: PUSH
9692: LD_INT 9
9694: ST_TO_ADDR
// un := CreateHuman ;
9695: LD_ADDR_VAR 0 2
9699: PUSH
9700: CALL_OW 44
9704: ST_TO_ADDR
// filter := filter ^ un ;
9705: LD_ADDR_VAR 0 3
9709: PUSH
9710: LD_VAR 0 3
9714: PUSH
9715: LD_VAR 0 2
9719: ADD
9720: ST_TO_ADDR
// end ;
9721: GO 9672
9723: POP
9724: POP
// for i = 1 to medics do
9725: LD_ADDR_VAR 0 1
9729: PUSH
9730: DOUBLE
9731: LD_INT 1
9733: DEC
9734: ST_TO_ADDR
9735: LD_VAR 0 8
9739: PUSH
9740: FOR_TO
9741: IFFALSE 9783
// begin PrepareScientist ( 0 , game_eskill ) ;
9743: LD_INT 0
9745: PPUSH
9746: LD_EXP 40
9750: PPUSH
9751: CALL_OW 384
// un := CreateHuman ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: CALL_OW 44
9764: ST_TO_ADDR
// filter := filter ^ un ;
9765: LD_ADDR_VAR 0 3
9769: PUSH
9770: LD_VAR 0 3
9774: PUSH
9775: LD_VAR 0 2
9779: ADD
9780: ST_TO_ADDR
// end ;
9781: GO 9740
9783: POP
9784: POP
// for i = 1 to vehs do
9785: LD_ADDR_VAR 0 1
9789: PUSH
9790: DOUBLE
9791: LD_INT 1
9793: DEC
9794: ST_TO_ADDR
9795: LD_VAR 0 6
9799: PUSH
9800: FOR_TO
9801: IFFALSE 9993
// begin case Rand ( 1 , 5 ) of 1 :
9803: LD_INT 1
9805: PPUSH
9806: LD_INT 5
9808: PPUSH
9809: CALL_OW 12
9813: PUSH
9814: LD_INT 1
9816: DOUBLE
9817: EQUAL
9818: IFTRUE 9822
9820: GO 9844
9822: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
9823: LD_INT 22
9825: PPUSH
9826: LD_INT 3
9828: PPUSH
9829: LD_INT 3
9831: PPUSH
9832: LD_INT 43
9834: PPUSH
9835: LD_INT 100
9837: PPUSH
9838: CALL 18466 0 5
9842: GO 9965
9844: LD_INT 2
9846: DOUBLE
9847: EQUAL
9848: IFTRUE 9852
9850: GO 9874
9852: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
9853: LD_INT 22
9855: PPUSH
9856: LD_INT 3
9858: PPUSH
9859: LD_INT 3
9861: PPUSH
9862: LD_INT 44
9864: PPUSH
9865: LD_INT 100
9867: PPUSH
9868: CALL 18466 0 5
9872: GO 9965
9874: LD_INT 3
9876: DOUBLE
9877: EQUAL
9878: IFTRUE 9882
9880: GO 9904
9882: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
9883: LD_INT 22
9885: PPUSH
9886: LD_INT 3
9888: PPUSH
9889: LD_INT 3
9891: PPUSH
9892: LD_INT 45
9894: PPUSH
9895: LD_INT 100
9897: PPUSH
9898: CALL 18466 0 5
9902: GO 9965
9904: LD_INT 4
9906: DOUBLE
9907: EQUAL
9908: IFTRUE 9912
9910: GO 9934
9912: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
9913: LD_INT 24
9915: PPUSH
9916: LD_INT 3
9918: PPUSH
9919: LD_INT 3
9921: PPUSH
9922: LD_INT 43
9924: PPUSH
9925: LD_INT 100
9927: PPUSH
9928: CALL 18466 0 5
9932: GO 9965
9934: LD_INT 5
9936: DOUBLE
9937: EQUAL
9938: IFTRUE 9942
9940: GO 9964
9942: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
9943: LD_INT 24
9945: PPUSH
9946: LD_INT 3
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 46
9954: PPUSH
9955: LD_INT 100
9957: PPUSH
9958: CALL 18466 0 5
9962: GO 9965
9964: POP
// vehicle := CreateVehicle ;
9965: LD_ADDR_VAR 0 7
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// filter := filter ^ vehicle ;
9975: LD_ADDR_VAR 0 3
9979: PUSH
9980: LD_VAR 0 3
9984: PUSH
9985: LD_VAR 0 7
9989: ADD
9990: ST_TO_ADDR
// end ;
9991: GO 9800
9993: POP
9994: POP
// for i = 1 to filter do
9995: LD_ADDR_VAR 0 1
9999: PUSH
10000: DOUBLE
10001: LD_INT 1
10003: DEC
10004: ST_TO_ADDR
10005: LD_VAR 0 3
10009: PUSH
10010: FOR_TO
10011: IFFALSE 10036
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
10013: LD_VAR 0 3
10017: PUSH
10018: LD_VAR 0 1
10022: ARRAY
10023: PPUSH
10024: LD_INT 14
10026: PPUSH
10027: LD_INT 0
10029: PPUSH
10030: CALL_OW 49
10034: GO 10010
10036: POP
10037: POP
// case Rand ( 1 , 3 ) of 1 :
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 3
10043: PPUSH
10044: CALL_OW 12
10048: PUSH
10049: LD_INT 1
10051: DOUBLE
10052: EQUAL
10053: IFTRUE 10057
10055: GO 10111
10057: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
10058: LD_ADDR_VAR 0 11
10062: PUSH
10063: LD_INT 165
10065: PUSH
10066: LD_INT 114
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PUSH
10073: LD_INT 104
10075: PUSH
10076: LD_INT 108
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PUSH
10083: LD_INT 86
10085: PUSH
10086: LD_INT 77
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PUSH
10093: LD_INT 63
10095: PUSH
10096: LD_INT 38
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: ST_TO_ADDR
10109: GO 10236
10111: LD_INT 2
10113: DOUBLE
10114: EQUAL
10115: IFTRUE 10119
10117: GO 10173
10119: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
10120: LD_ADDR_VAR 0 11
10124: PUSH
10125: LD_INT 165
10127: PUSH
10128: LD_INT 114
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 146
10137: PUSH
10138: LD_INT 71
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: LD_INT 112
10147: PUSH
10148: LD_INT 41
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PUSH
10155: LD_INT 63
10157: PUSH
10158: LD_INT 38
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: ST_TO_ADDR
10171: GO 10236
10173: LD_INT 3
10175: DOUBLE
10176: EQUAL
10177: IFTRUE 10181
10179: GO 10235
10181: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
10182: LD_ADDR_VAR 0 11
10186: PUSH
10187: LD_INT 165
10189: PUSH
10190: LD_INT 114
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 63
10199: PUSH
10200: LD_INT 99
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 55
10209: PUSH
10210: LD_INT 77
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PUSH
10217: LD_INT 63
10219: PUSH
10220: LD_INT 38
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: ST_TO_ADDR
10233: GO 10236
10235: POP
// attackers := filter ;
10236: LD_ADDR_VAR 0 10
10240: PUSH
10241: LD_VAR 0 3
10245: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// for i in attackers do
10253: LD_ADDR_VAR 0 1
10257: PUSH
10258: LD_VAR 0 10
10262: PUSH
10263: FOR_IN
10264: IFFALSE 10758
// begin if IsDead ( i ) then
10266: LD_VAR 0 1
10270: PPUSH
10271: CALL_OW 301
10275: IFFALSE 10293
// attackers := attackers diff i ;
10277: LD_ADDR_VAR 0 10
10281: PUSH
10282: LD_VAR 0 10
10286: PUSH
10287: LD_VAR 0 1
10291: DIFF
10292: ST_TO_ADDR
// if not HasTask ( i ) then
10293: LD_VAR 0 1
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10756
// begin if not GetTag ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 110
10314: NOT
10315: IFFALSE 10407
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
10317: LD_VAR 0 1
10321: PPUSH
10322: LD_VAR 0 11
10326: PUSH
10327: LD_INT 1
10329: ARRAY
10330: PUSH
10331: LD_INT 1
10333: ARRAY
10334: PPUSH
10335: LD_VAR 0 11
10339: PUSH
10340: LD_INT 1
10342: ARRAY
10343: PUSH
10344: LD_INT 2
10346: ARRAY
10347: PPUSH
10348: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
10352: LD_VAR 0 1
10356: PPUSH
10357: LD_VAR 0 11
10361: PUSH
10362: LD_INT 1
10364: ARRAY
10365: PUSH
10366: LD_INT 1
10368: ARRAY
10369: PPUSH
10370: LD_VAR 0 11
10374: PUSH
10375: LD_INT 1
10377: ARRAY
10378: PUSH
10379: LD_INT 2
10381: ARRAY
10382: PPUSH
10383: CALL_OW 297
10387: PUSH
10388: LD_INT 8
10390: LESS
10391: IFFALSE 10405
// SetTag ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 109
// end else
10405: GO 10756
// if GetTag ( i ) = 1 then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 110
10416: PUSH
10417: LD_INT 1
10419: EQUAL
10420: IFFALSE 10512
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
10422: LD_VAR 0 1
10426: PPUSH
10427: LD_VAR 0 11
10431: PUSH
10432: LD_INT 2
10434: ARRAY
10435: PUSH
10436: LD_INT 1
10438: ARRAY
10439: PPUSH
10440: LD_VAR 0 11
10444: PUSH
10445: LD_INT 2
10447: ARRAY
10448: PUSH
10449: LD_INT 2
10451: ARRAY
10452: PPUSH
10453: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
10457: LD_VAR 0 1
10461: PPUSH
10462: LD_VAR 0 11
10466: PUSH
10467: LD_INT 2
10469: ARRAY
10470: PUSH
10471: LD_INT 1
10473: ARRAY
10474: PPUSH
10475: LD_VAR 0 11
10479: PUSH
10480: LD_INT 2
10482: ARRAY
10483: PUSH
10484: LD_INT 2
10486: ARRAY
10487: PPUSH
10488: CALL_OW 297
10492: PUSH
10493: LD_INT 8
10495: LESS
10496: IFFALSE 10510
// SetTag ( i , 2 ) ;
10498: LD_VAR 0 1
10502: PPUSH
10503: LD_INT 2
10505: PPUSH
10506: CALL_OW 109
// end else
10510: GO 10756
// if GetTag ( i ) = 2 then
10512: LD_VAR 0 1
10516: PPUSH
10517: CALL_OW 110
10521: PUSH
10522: LD_INT 2
10524: EQUAL
10525: IFFALSE 10617
// begin ComAgressiveMove ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) ;
10527: LD_VAR 0 1
10531: PPUSH
10532: LD_VAR 0 11
10536: PUSH
10537: LD_INT 3
10539: ARRAY
10540: PUSH
10541: LD_INT 1
10543: ARRAY
10544: PPUSH
10545: LD_VAR 0 11
10549: PUSH
10550: LD_INT 3
10552: ARRAY
10553: PUSH
10554: LD_INT 2
10556: ARRAY
10557: PPUSH
10558: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) < 8 then
10562: LD_VAR 0 1
10566: PPUSH
10567: LD_VAR 0 11
10571: PUSH
10572: LD_INT 3
10574: ARRAY
10575: PUSH
10576: LD_INT 1
10578: ARRAY
10579: PPUSH
10580: LD_VAR 0 11
10584: PUSH
10585: LD_INT 3
10587: ARRAY
10588: PUSH
10589: LD_INT 2
10591: ARRAY
10592: PPUSH
10593: CALL_OW 297
10597: PUSH
10598: LD_INT 8
10600: LESS
10601: IFFALSE 10615
// SetTag ( i , 3 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_INT 3
10610: PPUSH
10611: CALL_OW 109
// end else
10615: GO 10756
// if GetTag ( i ) = 3 then
10617: LD_VAR 0 1
10621: PPUSH
10622: CALL_OW 110
10626: PUSH
10627: LD_INT 3
10629: EQUAL
10630: IFFALSE 10722
// begin ComAgressiveMove ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) ;
10632: LD_VAR 0 1
10636: PPUSH
10637: LD_VAR 0 11
10641: PUSH
10642: LD_INT 4
10644: ARRAY
10645: PUSH
10646: LD_INT 1
10648: ARRAY
10649: PPUSH
10650: LD_VAR 0 11
10654: PUSH
10655: LD_INT 4
10657: ARRAY
10658: PUSH
10659: LD_INT 2
10661: ARRAY
10662: PPUSH
10663: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) < 8 then
10667: LD_VAR 0 1
10671: PPUSH
10672: LD_VAR 0 11
10676: PUSH
10677: LD_INT 4
10679: ARRAY
10680: PUSH
10681: LD_INT 1
10683: ARRAY
10684: PPUSH
10685: LD_VAR 0 11
10689: PUSH
10690: LD_INT 4
10692: ARRAY
10693: PUSH
10694: LD_INT 2
10696: ARRAY
10697: PPUSH
10698: CALL_OW 297
10702: PUSH
10703: LD_INT 8
10705: LESS
10706: IFFALSE 10720
// SetTag ( i , 4 ) ;
10708: LD_VAR 0 1
10712: PPUSH
10713: LD_INT 4
10715: PPUSH
10716: CALL_OW 109
// end else
10720: GO 10756
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10722: LD_VAR 0 1
10726: PPUSH
10727: LD_INT 81
10729: PUSH
10730: LD_INT 3
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PPUSH
10737: CALL_OW 69
10741: PPUSH
10742: LD_VAR 0 1
10746: PPUSH
10747: CALL_OW 74
10751: PPUSH
10752: CALL_OW 115
// end ; end ;
10756: GO 10263
10758: POP
10759: POP
// until not attackers ;
10760: LD_VAR 0 10
10764: NOT
10765: IFFALSE 10246
// end ;
10767: PPOPN 12
10769: END
// every 0 0$1 do var i , tmp ;
10770: GO 10772
10772: DISABLE
10773: LD_INT 0
10775: PPUSH
10776: PPUSH
// begin enable ;
10777: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
10778: LD_ADDR_VAR 0 2
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: LD_INT 22
10788: PUSH
10789: LD_INT 1
10791: PUSH
10792: EMPTY
10793: LIST
10794: LIST
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 32
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 69
10818: ST_TO_ADDR
// if tmp then
10819: LD_VAR 0 2
10823: IFFALSE 10869
// for i in tmp do
10825: LD_ADDR_VAR 0 1
10829: PUSH
10830: LD_VAR 0 2
10834: PUSH
10835: FOR_IN
10836: IFFALSE 10867
// if GetFuel ( i ) < 3 then
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 261
10847: PUSH
10848: LD_INT 3
10850: LESS
10851: IFFALSE 10865
// SetFuel ( i , 3 ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: LD_INT 3
10860: PPUSH
10861: CALL_OW 240
10865: GO 10835
10867: POP
10868: POP
// end ;
10869: PPOPN 2
10871: END
// every 0 0$1 trigger ( FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) and not JMMArrival ) or ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) and not FirstAssaultRepelled ) do
10872: LD_INT 3
10874: PPUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 1
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PPUSH
10885: CALL_OW 70
10889: PUSH
10890: LD_EXP 41
10894: NOT
10895: AND
10896: PUSH
10897: LD_INT 10
10899: PPUSH
10900: LD_INT 22
10902: PUSH
10903: LD_INT 1
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PPUSH
10910: CALL_OW 70
10914: PUSH
10915: LD_EXP 4
10919: NOT
10920: AND
10921: OR
10922: IFFALSE 10931
10924: GO 10926
10926: DISABLE
// Antirush ;
10927: CALL 10932 0 0
10931: END
// export function Antirush ; var i , veh , tmp , num ; begin
10932: LD_INT 0
10934: PPUSH
10935: PPUSH
10936: PPUSH
10937: PPUSH
10938: PPUSH
// tmp := [ ] ;
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: EMPTY
10945: ST_TO_ADDR
// if not FirstAssaultRepelled then
10946: LD_EXP 4
10950: NOT
10951: IFFALSE 10963
// num := 12 else
10953: LD_ADDR_VAR 0 5
10957: PUSH
10958: LD_INT 12
10960: ST_TO_ADDR
10961: GO 10971
// num := 10 ;
10963: LD_ADDR_VAR 0 5
10967: PUSH
10968: LD_INT 10
10970: ST_TO_ADDR
// num := num - [ 4 , 2 , 0 ] [ Difficulty ] ;
10971: LD_ADDR_VAR 0 5
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: LD_INT 4
10983: PUSH
10984: LD_INT 2
10986: PUSH
10987: LD_INT 0
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_OWVAR 67
10999: ARRAY
11000: MINUS
11001: ST_TO_ADDR
// for i := 1 to num do
11002: LD_ADDR_VAR 0 2
11006: PUSH
11007: DOUBLE
11008: LD_INT 1
11010: DEC
11011: ST_TO_ADDR
11012: LD_VAR 0 5
11016: PUSH
11017: FOR_TO
11018: IFFALSE 11157
// begin uc_side := 3 ;
11020: LD_ADDR_OWVAR 20
11024: PUSH
11025: LD_INT 3
11027: ST_TO_ADDR
// uc_nation := 3 ;
11028: LD_ADDR_OWVAR 21
11032: PUSH
11033: LD_INT 3
11035: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
11036: LD_INT 23
11038: PPUSH
11039: LD_INT 3
11041: PPUSH
11042: LD_INT 3
11044: PPUSH
11045: LD_INT 46
11047: PUSH
11048: LD_INT 43
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: PUSH
11055: LD_INT 1
11057: PPUSH
11058: LD_INT 2
11060: PPUSH
11061: CALL_OW 12
11065: ARRAY
11066: PPUSH
11067: LD_INT 100
11069: PPUSH
11070: CALL 18466 0 5
// veh := CreateVehicle ;
11074: LD_ADDR_VAR 0 3
11078: PUSH
11079: CALL_OW 45
11083: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
11084: LD_VAR 0 3
11088: PPUSH
11089: LD_INT 5
11091: PPUSH
11092: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
11096: LD_VAR 0 3
11100: PPUSH
11101: LD_INT 199
11103: PPUSH
11104: LD_INT 135
11106: PPUSH
11107: LD_INT 3
11109: PPUSH
11110: LD_INT 0
11112: PPUSH
11113: CALL_OW 50
// tmp := tmp ^ veh ;
11117: LD_ADDR_VAR 0 4
11121: PUSH
11122: LD_VAR 0 4
11126: PUSH
11127: LD_VAR 0 3
11131: ADD
11132: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
11133: LD_VAR 0 3
11137: PPUSH
11138: LD_INT 173
11140: PPUSH
11141: LD_INT 118
11143: PPUSH
11144: CALL_OW 111
// wait ( 0 0$2 ) ;
11148: LD_INT 70
11150: PPUSH
11151: CALL_OW 67
// end ;
11155: GO 11017
11157: POP
11158: POP
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// for i in tmp do
11166: LD_ADDR_VAR 0 2
11170: PUSH
11171: LD_VAR 0 4
11175: PUSH
11176: FOR_IN
11177: IFFALSE 11244
// if IsDead ( i ) then
11179: LD_VAR 0 2
11183: PPUSH
11184: CALL_OW 301
11188: IFFALSE 11208
// tmp := tmp diff i else
11190: LD_ADDR_VAR 0 4
11194: PUSH
11195: LD_VAR 0 4
11199: PUSH
11200: LD_VAR 0 2
11204: DIFF
11205: ST_TO_ADDR
11206: GO 11242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 22
11215: PUSH
11216: LD_INT 1
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PPUSH
11223: CALL_OW 69
11227: PPUSH
11228: LD_VAR 0 2
11232: PPUSH
11233: CALL_OW 74
11237: PPUSH
11238: CALL_OW 115
11242: GO 11176
11244: POP
11245: POP
// until not tmp ;
11246: LD_VAR 0 4
11250: NOT
11251: IFFALSE 11159
// end ; end_of_file
11253: LD_VAR 0 1
11257: RET
// export Losses ; on UnitDestroyed ( un ) do begin if un = Brighton then
11258: LD_VAR 0 1
11262: PUSH
11263: LD_EXP 9
11267: EQUAL
11268: IFFALSE 11284
// begin wait ( 0 0$1 ) ;
11270: LD_INT 35
11272: PPUSH
11273: CALL_OW 67
// YouLost ( Brighton ) ;
11277: LD_STRING Brighton
11279: PPUSH
11280: CALL_OW 104
// end ; if un = JMM then
11284: LD_VAR 0 1
11288: PUSH
11289: LD_EXP 37
11293: EQUAL
11294: IFFALSE 11310
// begin wait ( 0 0$1 ) ;
11296: LD_INT 35
11298: PPUSH
11299: CALL_OW 67
// YouLost ( JMM ) ;
11303: LD_STRING JMM
11305: PPUSH
11306: CALL_OW 104
// end ; if un = Megan then
11310: LD_VAR 0 1
11314: PUSH
11315: LD_EXP 11
11319: EQUAL
11320: IFFALSE 11334
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
11322: LD_EXP 9
11326: PPUSH
11327: LD_STRING DBrighton-MeganDeath
11329: PPUSH
11330: CALL_OW 88
// end ; if un = Palmer then
11334: LD_VAR 0 1
11338: PUSH
11339: LD_EXP 10
11343: EQUAL
11344: IFFALSE 11358
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
11346: LD_EXP 9
11350: PPUSH
11351: LD_STRING DBrighton-PalmerDeath
11353: PPUSH
11354: CALL_OW 88
// end ; if un = Burlak then
11358: LD_VAR 0 1
11362: PUSH
11363: LD_EXP 19
11367: EQUAL
11368: IFFALSE 11400
// begin if JMM_Arrived then
11370: LD_EXP 6
11374: IFFALSE 11388
// Say ( JMM , DJMM-BurlakDead ) ;
11376: LD_EXP 37
11380: PPUSH
11381: LD_STRING DJMM-BurlakDead
11383: PPUSH
11384: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
11388: LD_EXP 10
11392: PPUSH
11393: LD_STRING DSol-BurlakDead
11395: PPUSH
11396: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
11400: LD_VAR 0 1
11404: PUSH
11405: LD_INT 1
11407: EQUAL
11408: PUSH
11409: LD_VAR 0 1
11413: PUSH
11414: LD_INT 3
11416: EQUAL
11417: OR
11418: IFFALSE 11434
// begin wait ( 0 0$1 ) ;
11420: LD_INT 35
11422: PPUSH
11423: CALL_OW 67
// YouLost ( Depot ) ;
11427: LD_STRING Depot
11429: PPUSH
11430: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
11434: LD_VAR 0 1
11438: PPUSH
11439: CALL_OW 255
11443: PUSH
11444: LD_INT 1
11446: EQUAL
11447: PUSH
11448: LD_VAR 0 1
11452: PPUSH
11453: CALL_OW 247
11457: PUSH
11458: LD_INT 1
11460: EQUAL
11461: AND
11462: IFFALSE 11478
// Losses := Losses + 1 ;
11464: LD_ADDR_EXP 45
11468: PUSH
11469: LD_EXP 45
11473: PUSH
11474: LD_INT 1
11476: PLUS
11477: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11478: LD_VAR 0 1
11482: PPUSH
11483: CALL 81501 0 1
// end ;
11487: PPOPN 1
11489: END
// on UnitGoesToRed ( un ) do begin if GetType ( un ) = unit_vehicle and un in RUArmada then
11490: LD_VAR 0 1
11494: PPUSH
11495: CALL_OW 247
11499: PUSH
11500: LD_INT 2
11502: EQUAL
11503: PUSH
11504: LD_VAR 0 1
11508: PUSH
11509: LD_EXP 17
11513: IN
11514: AND
11515: IFFALSE 11529
// SetLives ( un , 0 ) ;
11517: LD_VAR 0 1
11521: PPUSH
11522: LD_INT 0
11524: PPUSH
11525: CALL_OW 234
// if un = Yashin then
11529: LD_VAR 0 1
11533: PUSH
11534: LD_EXP 13
11538: EQUAL
11539: IFFALSE 11553
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
11541: LD_EXP 13
11545: PPUSH
11546: LD_STRING DDeath-Yas-3
11548: PPUSH
11549: CALL_OW 91
// if un = Popov then
11553: LD_VAR 0 1
11557: PUSH
11558: LD_EXP 14
11562: EQUAL
11563: IFFALSE 11577
// ForceSay ( Popov , DDeath-Pop-3 ) ;
11565: LD_EXP 14
11569: PPUSH
11570: LD_STRING DDeath-Pop-3
11572: PPUSH
11573: CALL_OW 91
// if un = Gaydar then
11577: LD_VAR 0 1
11581: PUSH
11582: LD_EXP 15
11586: EQUAL
11587: IFFALSE 11601
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
11589: LD_EXP 15
11593: PPUSH
11594: LD_STRING DDeath-Gay-3
11596: PPUSH
11597: CALL_OW 91
// if un = Sevi then
11601: LD_VAR 0 1
11605: PUSH
11606: LD_EXP 16
11610: EQUAL
11611: IFFALSE 11625
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
11613: LD_EXP 16
11617: PPUSH
11618: LD_STRING DDeath-Vse-3
11620: PPUSH
11621: CALL_OW 91
// end ;
11625: PPOPN 1
11627: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
11628: LD_VAR 0 1
11632: PUSH
11633: LD_INT 10
11635: EQUAL
11636: IFFALSE 11674
// begin Say ( Brighton , DBrighton-C1 ) ;
11638: LD_EXP 9
11642: PPUSH
11643: LD_STRING DBrighton-C1
11645: PPUSH
11646: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
11650: LD_EXP 11
11654: PPUSH
11655: LD_STRING DMegan-C1
11657: PPUSH
11658: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
11662: LD_EXP 9
11666: PPUSH
11667: LD_STRING DBrighton-C2
11669: PPUSH
11670: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
11674: LD_VAR 0 1
11678: PPUSH
11679: LD_VAR 0 2
11683: PPUSH
11684: CALL 81197 0 2
// end ;
11688: PPOPN 2
11690: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11691: LD_VAR 0 1
11695: PPUSH
11696: LD_VAR 0 2
11700: PPUSH
11701: CALL 83835 0 2
// end ;
11705: PPOPN 2
11707: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11708: LD_VAR 0 1
11712: PPUSH
11713: CALL 82903 0 1
// end ;
11717: PPOPN 1
11719: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
11720: LD_VAR 0 1
11724: PPUSH
11725: CALL_OW 266
11729: PUSH
11730: LD_INT 0
11732: EQUAL
11733: PUSH
11734: LD_VAR 0 1
11738: PPUSH
11739: CALL_OW 255
11743: PUSH
11744: LD_INT 3
11746: EQUAL
11747: AND
11748: IFFALSE 11810
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
11750: LD_VAR 0 1
11754: PPUSH
11755: CALL_OW 274
11759: PPUSH
11760: LD_INT 1
11762: PPUSH
11763: LD_INT 10000
11765: PPUSH
11766: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
11770: LD_VAR 0 1
11774: PPUSH
11775: CALL_OW 274
11779: PPUSH
11780: LD_INT 2
11782: PPUSH
11783: LD_INT 250
11785: PPUSH
11786: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
11790: LD_VAR 0 1
11794: PPUSH
11795: CALL_OW 274
11799: PPUSH
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 100
11805: PPUSH
11806: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
11810: LD_VAR 0 1
11814: PPUSH
11815: CALL 83144 0 1
// end ;
11819: PPOPN 1
11821: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11822: LD_VAR 0 1
11826: PPUSH
11827: LD_VAR 0 2
11831: PPUSH
11832: LD_VAR 0 3
11836: PPUSH
11837: LD_VAR 0 4
11841: PPUSH
11842: LD_VAR 0 5
11846: PPUSH
11847: CALL 80817 0 5
// end ;
11851: PPOPN 5
11853: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11854: LD_VAR 0 1
11858: PPUSH
11859: LD_VAR 0 2
11863: PPUSH
11864: CALL 80398 0 2
// end ;
11868: PPOPN 2
11870: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11871: LD_VAR 0 1
11875: PPUSH
11876: LD_VAR 0 2
11880: PPUSH
11881: LD_VAR 0 3
11885: PPUSH
11886: LD_VAR 0 4
11890: PPUSH
11891: CALL 80236 0 4
// end ;
11895: PPOPN 4
11897: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11898: LD_VAR 0 1
11902: PPUSH
11903: LD_VAR 0 2
11907: PPUSH
11908: LD_VAR 0 3
11912: PPUSH
11913: CALL 80011 0 3
// end ;
11917: PPOPN 3
11919: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11920: LD_VAR 0 1
11924: PPUSH
11925: LD_VAR 0 2
11929: PPUSH
11930: CALL 79896 0 2
// end ;
11934: PPOPN 2
11936: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11937: LD_VAR 0 1
11941: PPUSH
11942: LD_VAR 0 2
11946: PPUSH
11947: CALL 84130 0 2
// end ;
11951: PPOPN 2
11953: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
11954: LD_VAR 0 1
11958: PPUSH
11959: CALL_OW 255
11963: PUSH
11964: LD_INT 6
11966: EQUAL
11967: IFFALSE 12097
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
11969: LD_VAR 0 1
11973: PUSH
11974: LD_EXP 13
11978: PUSH
11979: LD_EXP 16
11983: PUSH
11984: LD_EXP 15
11988: PUSH
11989: LD_EXP 14
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: IN
12000: IFFALSE 12004
// exit ;
12002: GO 12121
// if AssaultStarted then
12004: LD_EXP 8
12008: IFFALSE 12082
// case Rand ( 1 , 4 ) of 1 .. 3 :
12010: LD_INT 1
12012: PPUSH
12013: LD_INT 4
12015: PPUSH
12016: CALL_OW 12
12020: PUSH
12021: LD_INT 1
12023: DOUBLE
12024: GREATEREQUAL
12025: IFFALSE 12033
12027: LD_INT 3
12029: DOUBLE
12030: LESSEQUAL
12031: IFTRUE 12035
12033: GO 12053
12035: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
12036: LD_VAR 0 1
12040: PPUSH
12041: LD_INT 67
12043: PPUSH
12044: LD_INT 37
12046: PPUSH
12047: CALL_OW 114
12051: GO 12080
12053: LD_INT 4
12055: DOUBLE
12056: EQUAL
12057: IFTRUE 12061
12059: GO 12079
12061: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
12062: LD_VAR 0 1
12066: PPUSH
12067: LD_INT 120
12069: PPUSH
12070: LD_INT 131
12072: PPUSH
12073: CALL_OW 111
12077: GO 12080
12079: POP
12080: GO 12097
// ComMoveXY ( driver , 120 , 131 ) ;
12082: LD_VAR 0 1
12086: PPUSH
12087: LD_INT 120
12089: PPUSH
12090: LD_INT 131
12092: PPUSH
12093: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12097: LD_VAR 0 1
12101: PPUSH
12102: LD_VAR 0 2
12106: PPUSH
12107: LD_VAR 0 3
12111: PPUSH
12112: LD_VAR 0 4
12116: PPUSH
12117: CALL 84346 0 4
// end ;
12121: PPOPN 4
12123: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12124: LD_VAR 0 1
12128: PPUSH
12129: LD_VAR 0 2
12133: PPUSH
12134: CALL 79705 0 2
// end ;
12138: PPOPN 2
12140: END
// on Command ( cmd ) do var i ;
12141: LD_INT 0
12143: PPUSH
// begin if cmd = 77 and southAreaBlocker then
12144: LD_VAR 0 1
12148: PUSH
12149: LD_INT 77
12151: EQUAL
12152: PUSH
12153: LD_EXP 2
12157: AND
12158: IFFALSE 12234
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12160: LD_ADDR_VAR 0 2
12164: PUSH
12165: LD_INT 22
12167: PUSH
12168: LD_INT 1
12170: PUSH
12171: EMPTY
12172: LIST
12173: LIST
12174: PUSH
12175: LD_INT 2
12177: PUSH
12178: LD_INT 21
12180: PUSH
12181: LD_INT 1
12183: PUSH
12184: EMPTY
12185: LIST
12186: LIST
12187: PUSH
12188: LD_INT 21
12190: PUSH
12191: LD_INT 2
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: LIST
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PPUSH
12207: CALL_OW 69
12211: PUSH
12212: FOR_IN
12213: IFFALSE 12232
// NotGoToAreaUnit ( i , SouthAreaBlock , SouthAreaGoAway ) ;
12215: LD_VAR 0 2
12219: PPUSH
12220: LD_INT 20
12222: PPUSH
12223: LD_INT 19
12225: PPUSH
12226: CALL 50993 0 3
12230: GO 12212
12232: POP
12233: POP
// end ; SOS_Command ( cmd ) ;
12234: LD_VAR 0 1
12238: PPUSH
12239: CALL 98922 0 1
// end ;
12243: PPOPN 2
12245: END
// every 0 0$1 trigger southAreaBlocker and FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do var i ;
12246: LD_EXP 2
12250: PUSH
12251: LD_INT 16
12253: PPUSH
12254: LD_INT 22
12256: PUSH
12257: LD_INT 1
12259: PUSH
12260: EMPTY
12261: LIST
12262: LIST
12263: PUSH
12264: LD_INT 2
12266: PUSH
12267: LD_INT 21
12269: PUSH
12270: LD_INT 1
12272: PUSH
12273: EMPTY
12274: LIST
12275: LIST
12276: PUSH
12277: LD_INT 21
12279: PUSH
12280: LD_INT 2
12282: PUSH
12283: EMPTY
12284: LIST
12285: LIST
12286: PUSH
12287: EMPTY
12288: LIST
12289: LIST
12290: LIST
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PPUSH
12296: CALL_OW 70
12300: AND
12301: IFFALSE 12387
12303: GO 12305
12305: DISABLE
12306: LD_INT 0
12308: PPUSH
// begin enable ;
12309: ENABLE
// for i in FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12310: LD_ADDR_VAR 0 1
12314: PUSH
12315: LD_INT 16
12317: PPUSH
12318: LD_INT 22
12320: PUSH
12321: LD_INT 1
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PUSH
12328: LD_INT 2
12330: PUSH
12331: LD_INT 21
12333: PUSH
12334: LD_INT 1
12336: PUSH
12337: EMPTY
12338: LIST
12339: LIST
12340: PUSH
12341: LD_INT 21
12343: PUSH
12344: LD_INT 2
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: PUSH
12351: EMPTY
12352: LIST
12353: LIST
12354: LIST
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PPUSH
12360: CALL_OW 70
12364: PUSH
12365: FOR_IN
12366: IFFALSE 12385
// NotGoToAreaUnit ( i , SouthAreaOutside , SouthAreaGoAway ) ;
12368: LD_VAR 0 1
12372: PPUSH
12373: LD_INT 18
12375: PPUSH
12376: LD_INT 19
12378: PPUSH
12379: CALL 50993 0 3
12383: GO 12365
12385: POP
12386: POP
// end ; end_of_file
12387: PPOPN 1
12389: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
12390: LD_EXP 6
12394: PUSH
12395: LD_EXP 44
12399: AND
12400: IFFALSE 12571
12402: GO 12404
12404: DISABLE
// begin wait ( 0 0$2 ) ;
12405: LD_INT 70
12407: PPUSH
12408: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
12412: LD_EXP 9
12416: PPUSH
12417: LD_STRING DBrighton-G1
12419: PPUSH
12420: CALL_OW 88
// if Losses < 1 then
12424: LD_EXP 45
12428: PUSH
12429: LD_INT 1
12431: LESS
12432: IFFALSE 12446
// AddMedal ( Losses , 1 ) else
12434: LD_STRING Losses
12436: PPUSH
12437: LD_INT 1
12439: PPUSH
12440: CALL_OW 101
12444: GO 12479
// if Losses < 5 then
12446: LD_EXP 45
12450: PUSH
12451: LD_INT 5
12453: LESS
12454: IFFALSE 12468
// AddMedal ( Losses , 2 ) else
12456: LD_STRING Losses
12458: PPUSH
12459: LD_INT 2
12461: PPUSH
12462: CALL_OW 101
12466: GO 12479
// AddMedal ( Losses , - 1 ) ;
12468: LD_STRING Losses
12470: PPUSH
12471: LD_INT 1
12473: NEG
12474: PPUSH
12475: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12479: LD_EXP 7
12483: PUSH
12484: LD_INT 10
12486: PPUSH
12487: LD_INT 1
12489: PPUSH
12490: CALL_OW 321
12494: PUSH
12495: LD_INT 2
12497: EQUAL
12498: AND
12499: IFFALSE 12513
// AddMedal ( Laser , 1 ) else
12501: LD_STRING Laser
12503: PPUSH
12504: LD_INT 1
12506: PPUSH
12507: CALL_OW 101
12511: GO 12560
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12513: LD_EXP 7
12517: NOT
12518: PUSH
12519: LD_INT 10
12521: PPUSH
12522: LD_INT 1
12524: PPUSH
12525: CALL_OW 321
12529: PUSH
12530: LD_INT 2
12532: EQUAL
12533: AND
12534: IFFALSE 12549
// AddMedal ( Laser , - 1 ) else
12536: LD_STRING Laser
12538: PPUSH
12539: LD_INT 1
12541: NEG
12542: PPUSH
12543: CALL_OW 101
12547: GO 12560
// AddMedal ( Laser , - 2 ) ;
12549: LD_STRING Laser
12551: PPUSH
12552: LD_INT 2
12554: NEG
12555: PPUSH
12556: CALL_OW 101
// GiveMedals ( BaseMain ) ;
12560: LD_STRING BaseMain
12562: PPUSH
12563: CALL_OW 102
// YouWin ;
12567: CALL_OW 103
// end ; end_of_file
12571: END
// export rows ; export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
12572: LD_INT 0
12574: PPUSH
12575: PPUSH
// area = ListEnvironmentArea ( area ) ;
12576: LD_ADDR_VAR 0 2
12580: PUSH
12581: LD_VAR 0 2
12585: PPUSH
12586: CALL_OW 353
12590: ST_TO_ADDR
// if bulldozer > 0 then
12591: LD_VAR 0 1
12595: PUSH
12596: LD_INT 0
12598: GREATER
12599: IFFALSE 12710
// for i = area downto 1 do
12601: LD_ADDR_VAR 0 4
12605: PUSH
12606: DOUBLE
12607: LD_VAR 0 2
12611: INC
12612: ST_TO_ADDR
12613: LD_INT 1
12615: PUSH
12616: FOR_DOWNTO
12617: IFFALSE 12708
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
12619: LD_VAR 0 2
12623: PUSH
12624: LD_VAR 0 4
12628: ARRAY
12629: PUSH
12630: LD_INT 1
12632: ARRAY
12633: PPUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_VAR 0 4
12643: ARRAY
12644: PUSH
12645: LD_INT 2
12647: ARRAY
12648: PPUSH
12649: CALL_OW 351
12653: IFFALSE 12706
// if not HasTask ( bulldozer ) then
12655: LD_VAR 0 1
12659: PPUSH
12660: CALL_OW 314
12664: NOT
12665: IFFALSE 12706
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
12667: LD_VAR 0 1
12671: PPUSH
12672: LD_VAR 0 2
12676: PUSH
12677: LD_VAR 0 4
12681: ARRAY
12682: PUSH
12683: LD_INT 1
12685: ARRAY
12686: PPUSH
12687: LD_VAR 0 2
12691: PUSH
12692: LD_VAR 0 4
12696: ARRAY
12697: PUSH
12698: LD_INT 2
12700: ARRAY
12701: PPUSH
12702: CALL_OW 171
12706: GO 12616
12708: POP
12709: POP
// end ;
12710: LD_VAR 0 3
12714: RET
// export function ComMeeting ( team , area ) ; var i , x , tmp , offset , sold_team , civil_team ; begin
12715: LD_INT 0
12717: PPUSH
12718: PPUSH
12719: PPUSH
12720: PPUSH
12721: PPUSH
12722: PPUSH
12723: PPUSH
// sold_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , class_soldier ] ] ) ;
12724: LD_ADDR_VAR 0 8
12728: PUSH
12729: LD_VAR 0 1
12733: PPUSH
12734: LD_INT 22
12736: PUSH
12737: LD_INT 1
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: PUSH
12744: LD_INT 21
12746: PUSH
12747: LD_INT 1
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 25
12756: PUSH
12757: LD_INT 1
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: LIST
12768: PPUSH
12769: CALL_OW 72
12773: ST_TO_ADDR
// civil_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , class_soldier ] ] ] ) ;
12774: LD_ADDR_VAR 0 9
12778: PUSH
12779: LD_VAR 0 1
12783: PPUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 1
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 21
12796: PUSH
12797: LD_INT 1
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 3
12806: PUSH
12807: LD_INT 25
12809: PUSH
12810: LD_INT 1
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: LIST
12825: PPUSH
12826: CALL_OW 72
12830: ST_TO_ADDR
// rows = MakeRows ( sold_team , civil_team ) ;
12831: LD_ADDR_EXP 47
12835: PUSH
12836: LD_VAR 0 8
12840: PPUSH
12841: LD_VAR 0 9
12845: PPUSH
12846: CALL 13239 0 2
12850: ST_TO_ADDR
// offset = 0 ;
12851: LD_ADDR_VAR 0 7
12855: PUSH
12856: LD_INT 0
12858: ST_TO_ADDR
// for i := 1 to sold_team do
12859: LD_ADDR_VAR 0 4
12863: PUSH
12864: DOUBLE
12865: LD_INT 1
12867: DEC
12868: ST_TO_ADDR
12869: LD_VAR 0 8
12873: PUSH
12874: FOR_TO
12875: IFFALSE 13006
// begin if IsInUnit ( sold_team [ i ] ) then
12877: LD_VAR 0 8
12881: PUSH
12882: LD_VAR 0 4
12886: ARRAY
12887: PPUSH
12888: CALL_OW 310
12892: IFFALSE 12909
// ComExitBuilding ( sold_team [ i ] ) ;
12894: LD_VAR 0 8
12898: PUSH
12899: LD_VAR 0 4
12903: ARRAY
12904: PPUSH
12905: CALL_OW 122
// AddComMoveXY ( sold_team [ i ] , rows [ 1 ] [ i + offset ] , rows [ 1 ] [ i + 1 + offset ] ) ;
12909: LD_VAR 0 8
12913: PUSH
12914: LD_VAR 0 4
12918: ARRAY
12919: PPUSH
12920: LD_EXP 47
12924: PUSH
12925: LD_INT 1
12927: ARRAY
12928: PUSH
12929: LD_VAR 0 4
12933: PUSH
12934: LD_VAR 0 7
12938: PLUS
12939: ARRAY
12940: PPUSH
12941: LD_EXP 47
12945: PUSH
12946: LD_INT 1
12948: ARRAY
12949: PUSH
12950: LD_VAR 0 4
12954: PUSH
12955: LD_INT 1
12957: PLUS
12958: PUSH
12959: LD_VAR 0 7
12963: PLUS
12964: ARRAY
12965: PPUSH
12966: CALL_OW 171
// AddComTurnUnit ( sold_team [ i ] , Brighton ) ;
12970: LD_VAR 0 8
12974: PUSH
12975: LD_VAR 0 4
12979: ARRAY
12980: PPUSH
12981: LD_EXP 9
12985: PPUSH
12986: CALL_OW 179
// offset = offset + 1 ;
12990: LD_ADDR_VAR 0 7
12994: PUSH
12995: LD_VAR 0 7
12999: PUSH
13000: LD_INT 1
13002: PLUS
13003: ST_TO_ADDR
// end ;
13004: GO 12874
13006: POP
13007: POP
// offset = 0 ;
13008: LD_ADDR_VAR 0 7
13012: PUSH
13013: LD_INT 0
13015: ST_TO_ADDR
// tmp = 1 ;
13016: LD_ADDR_VAR 0 6
13020: PUSH
13021: LD_INT 1
13023: ST_TO_ADDR
// for i := 2 to rows do
13024: LD_ADDR_VAR 0 4
13028: PUSH
13029: DOUBLE
13030: LD_INT 2
13032: DEC
13033: ST_TO_ADDR
13034: LD_EXP 47
13038: PUSH
13039: FOR_TO
13040: IFFALSE 13232
// begin for x := 1 to sold_team do
13042: LD_ADDR_VAR 0 5
13046: PUSH
13047: DOUBLE
13048: LD_INT 1
13050: DEC
13051: ST_TO_ADDR
13052: LD_VAR 0 8
13056: PUSH
13057: FOR_TO
13058: IFFALSE 13220
// begin if IsInUnit ( civil_team [ tmp ] ) then
13060: LD_VAR 0 9
13064: PUSH
13065: LD_VAR 0 6
13069: ARRAY
13070: PPUSH
13071: CALL_OW 310
13075: IFFALSE 13092
// ComExitBuilding ( civil_team [ tmp ] ) ;
13077: LD_VAR 0 9
13081: PUSH
13082: LD_VAR 0 6
13086: ARRAY
13087: PPUSH
13088: CALL_OW 122
// AddComMoveXY ( civil_team [ tmp ] , rows [ i ] [ x + offset ] , rows [ i ] [ x + 1 + offset ] ) ;
13092: LD_VAR 0 9
13096: PUSH
13097: LD_VAR 0 6
13101: ARRAY
13102: PPUSH
13103: LD_EXP 47
13107: PUSH
13108: LD_VAR 0 4
13112: ARRAY
13113: PUSH
13114: LD_VAR 0 5
13118: PUSH
13119: LD_VAR 0 7
13123: PLUS
13124: ARRAY
13125: PPUSH
13126: LD_EXP 47
13130: PUSH
13131: LD_VAR 0 4
13135: ARRAY
13136: PUSH
13137: LD_VAR 0 5
13141: PUSH
13142: LD_INT 1
13144: PLUS
13145: PUSH
13146: LD_VAR 0 7
13150: PLUS
13151: ARRAY
13152: PPUSH
13153: CALL_OW 171
// AddComTurnUnit ( civil_team [ tmp ] , Brighton ) ;
13157: LD_VAR 0 9
13161: PUSH
13162: LD_VAR 0 6
13166: ARRAY
13167: PPUSH
13168: LD_EXP 9
13172: PPUSH
13173: CALL_OW 179
// offset = offset + 1 ;
13177: LD_ADDR_VAR 0 7
13181: PUSH
13182: LD_VAR 0 7
13186: PUSH
13187: LD_INT 1
13189: PLUS
13190: ST_TO_ADDR
// if not ( tmp = civil_team ) then
13191: LD_VAR 0 6
13195: PUSH
13196: LD_VAR 0 9
13200: EQUAL
13201: NOT
13202: IFFALSE 13218
// tmp = tmp + 1 ;
13204: LD_ADDR_VAR 0 6
13208: PUSH
13209: LD_VAR 0 6
13213: PUSH
13214: LD_INT 1
13216: PLUS
13217: ST_TO_ADDR
// end ;
13218: GO 13057
13220: POP
13221: POP
// offset = 0 ;
13222: LD_ADDR_VAR 0 7
13226: PUSH
13227: LD_INT 0
13229: ST_TO_ADDR
// end ;
13230: GO 13039
13232: POP
13233: POP
// end ;
13234: LD_VAR 0 3
13238: RET
// export function MakeRows ( sold_team , civil_team ) ; var i , x , start_pos , row_size , new_row , result_rows , civil_rows , offsetX , offsetY ; begin
13239: LD_INT 0
13241: PPUSH
13242: PPUSH
13243: PPUSH
13244: PPUSH
13245: PPUSH
13246: PPUSH
13247: PPUSH
13248: PPUSH
13249: PPUSH
13250: PPUSH
// start_pos = [ 65 , 34 ] ;
13251: LD_ADDR_VAR 0 6
13255: PUSH
13256: LD_INT 65
13258: PUSH
13259: LD_INT 34
13261: PUSH
13262: EMPTY
13263: LIST
13264: LIST
13265: ST_TO_ADDR
// row_size = 0 ;
13266: LD_ADDR_VAR 0 7
13270: PUSH
13271: LD_INT 0
13273: ST_TO_ADDR
// result_rows = [ ] ;
13274: LD_ADDR_VAR 0 9
13278: PUSH
13279: EMPTY
13280: ST_TO_ADDR
// new_row = [ ] ;
13281: LD_ADDR_VAR 0 8
13285: PUSH
13286: EMPTY
13287: ST_TO_ADDR
// for i := 1 to sold_team do
13288: LD_ADDR_VAR 0 4
13292: PUSH
13293: DOUBLE
13294: LD_INT 1
13296: DEC
13297: ST_TO_ADDR
13298: LD_VAR 0 1
13302: PUSH
13303: FOR_TO
13304: IFFALSE 13358
// begin new_row = new_row ^ start_pos [ 1 ] ^ start_pos [ 2 ] + i ;
13306: LD_ADDR_VAR 0 8
13310: PUSH
13311: LD_VAR 0 8
13315: PUSH
13316: LD_VAR 0 6
13320: PUSH
13321: LD_INT 1
13323: ARRAY
13324: ADD
13325: PUSH
13326: LD_VAR 0 6
13330: PUSH
13331: LD_INT 2
13333: ARRAY
13334: PUSH
13335: LD_VAR 0 4
13339: PLUS
13340: ADD
13341: ST_TO_ADDR
// row_size = row_size + 1 ;
13342: LD_ADDR_VAR 0 7
13346: PUSH
13347: LD_VAR 0 7
13351: PUSH
13352: LD_INT 1
13354: PLUS
13355: ST_TO_ADDR
// end ;
13356: GO 13303
13358: POP
13359: POP
// result_rows = result_rows ^ [ new_row ] ;
13360: LD_ADDR_VAR 0 9
13364: PUSH
13365: LD_VAR 0 9
13369: PUSH
13370: LD_VAR 0 8
13374: PUSH
13375: EMPTY
13376: LIST
13377: ADD
13378: ST_TO_ADDR
// civil_rows = civil_team div sold_team ;
13379: LD_ADDR_VAR 0 10
13383: PUSH
13384: LD_VAR 0 2
13388: PUSH
13389: LD_VAR 0 1
13393: DIV
13394: ST_TO_ADDR
// if ( civil_rows mod sold_team > 0 ) then
13395: LD_VAR 0 10
13399: PUSH
13400: LD_VAR 0 1
13404: MOD
13405: PUSH
13406: LD_INT 0
13408: GREATER
13409: IFFALSE 13425
// civil_rows = civil_rows + 1 ;
13411: LD_ADDR_VAR 0 10
13415: PUSH
13416: LD_VAR 0 10
13420: PUSH
13421: LD_INT 1
13423: PLUS
13424: ST_TO_ADDR
// offsetX = 2 ;
13425: LD_ADDR_VAR 0 11
13429: PUSH
13430: LD_INT 2
13432: ST_TO_ADDR
// offsetY = 1 ;
13433: LD_ADDR_VAR 0 12
13437: PUSH
13438: LD_INT 1
13440: ST_TO_ADDR
// for i := 1 to civil_rows do
13441: LD_ADDR_VAR 0 4
13445: PUSH
13446: DOUBLE
13447: LD_INT 1
13449: DEC
13450: ST_TO_ADDR
13451: LD_VAR 0 10
13455: PUSH
13456: FOR_TO
13457: IFFALSE 13585
// begin new_row = [ ] ;
13459: LD_ADDR_VAR 0 8
13463: PUSH
13464: EMPTY
13465: ST_TO_ADDR
// for x := 1 to row_size do
13466: LD_ADDR_VAR 0 5
13470: PUSH
13471: DOUBLE
13472: LD_INT 1
13474: DEC
13475: ST_TO_ADDR
13476: LD_VAR 0 7
13480: PUSH
13481: FOR_TO
13482: IFFALSE 13534
// begin new_row = new_row ^ start_pos [ 1 ] + offsetX ^ start_pos [ 2 ] + offsetY + x ;
13484: LD_ADDR_VAR 0 8
13488: PUSH
13489: LD_VAR 0 8
13493: PUSH
13494: LD_VAR 0 6
13498: PUSH
13499: LD_INT 1
13501: ARRAY
13502: PUSH
13503: LD_VAR 0 11
13507: PLUS
13508: ADD
13509: PUSH
13510: LD_VAR 0 6
13514: PUSH
13515: LD_INT 2
13517: ARRAY
13518: PUSH
13519: LD_VAR 0 12
13523: PLUS
13524: PUSH
13525: LD_VAR 0 5
13529: PLUS
13530: ADD
13531: ST_TO_ADDR
// end ;
13532: GO 13481
13534: POP
13535: POP
// result_rows = result_rows ^ [ new_row ] ;
13536: LD_ADDR_VAR 0 9
13540: PUSH
13541: LD_VAR 0 9
13545: PUSH
13546: LD_VAR 0 8
13550: PUSH
13551: EMPTY
13552: LIST
13553: ADD
13554: ST_TO_ADDR
// offsetX = offsetX + 2 ;
13555: LD_ADDR_VAR 0 11
13559: PUSH
13560: LD_VAR 0 11
13564: PUSH
13565: LD_INT 2
13567: PLUS
13568: ST_TO_ADDR
// offsetY = offsetY + 1 ;
13569: LD_ADDR_VAR 0 12
13573: PUSH
13574: LD_VAR 0 12
13578: PUSH
13579: LD_INT 1
13581: PLUS
13582: ST_TO_ADDR
// end ;
13583: GO 13456
13585: POP
13586: POP
// result = result_rows ;
13587: LD_ADDR_VAR 0 3
13591: PUSH
13592: LD_VAR 0 9
13596: ST_TO_ADDR
// end ; end_of_file
13597: LD_VAR 0 3
13601: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13602: LD_INT 0
13604: PPUSH
13605: PPUSH
// if exist_mode then
13606: LD_VAR 0 2
13610: IFFALSE 13635
// unit := CreateCharacter ( prefix & ident ) else
13612: LD_ADDR_VAR 0 5
13616: PUSH
13617: LD_VAR 0 3
13621: PUSH
13622: LD_VAR 0 1
13626: STR
13627: PPUSH
13628: CALL_OW 34
13632: ST_TO_ADDR
13633: GO 13650
// unit := NewCharacter ( ident ) ;
13635: LD_ADDR_VAR 0 5
13639: PUSH
13640: LD_VAR 0 1
13644: PPUSH
13645: CALL_OW 25
13649: ST_TO_ADDR
// result := unit ;
13650: LD_ADDR_VAR 0 4
13654: PUSH
13655: LD_VAR 0 5
13659: ST_TO_ADDR
// end ;
13660: LD_VAR 0 4
13664: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13665: LD_INT 0
13667: PPUSH
13668: PPUSH
// if not side or not nation then
13669: LD_VAR 0 1
13673: NOT
13674: PUSH
13675: LD_VAR 0 2
13679: NOT
13680: OR
13681: IFFALSE 13685
// exit ;
13683: GO 14453
// case nation of nation_american :
13685: LD_VAR 0 2
13689: PUSH
13690: LD_INT 1
13692: DOUBLE
13693: EQUAL
13694: IFTRUE 13698
13696: GO 13912
13698: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
13699: LD_ADDR_VAR 0 4
13703: PUSH
13704: LD_INT 35
13706: PUSH
13707: LD_INT 45
13709: PUSH
13710: LD_INT 46
13712: PUSH
13713: LD_INT 47
13715: PUSH
13716: LD_INT 82
13718: PUSH
13719: LD_INT 83
13721: PUSH
13722: LD_INT 84
13724: PUSH
13725: LD_INT 85
13727: PUSH
13728: LD_INT 86
13730: PUSH
13731: LD_INT 1
13733: PUSH
13734: LD_INT 2
13736: PUSH
13737: LD_INT 6
13739: PUSH
13740: LD_INT 15
13742: PUSH
13743: LD_INT 16
13745: PUSH
13746: LD_INT 7
13748: PUSH
13749: LD_INT 12
13751: PUSH
13752: LD_INT 13
13754: PUSH
13755: LD_INT 10
13757: PUSH
13758: LD_INT 14
13760: PUSH
13761: LD_INT 20
13763: PUSH
13764: LD_INT 21
13766: PUSH
13767: LD_INT 22
13769: PUSH
13770: LD_INT 25
13772: PUSH
13773: LD_INT 32
13775: PUSH
13776: LD_INT 27
13778: PUSH
13779: LD_INT 36
13781: PUSH
13782: LD_INT 69
13784: PUSH
13785: LD_INT 39
13787: PUSH
13788: LD_INT 34
13790: PUSH
13791: LD_INT 40
13793: PUSH
13794: LD_INT 48
13796: PUSH
13797: LD_INT 49
13799: PUSH
13800: LD_INT 50
13802: PUSH
13803: LD_INT 51
13805: PUSH
13806: LD_INT 52
13808: PUSH
13809: LD_INT 53
13811: PUSH
13812: LD_INT 54
13814: PUSH
13815: LD_INT 55
13817: PUSH
13818: LD_INT 56
13820: PUSH
13821: LD_INT 57
13823: PUSH
13824: LD_INT 58
13826: PUSH
13827: LD_INT 59
13829: PUSH
13830: LD_INT 60
13832: PUSH
13833: LD_INT 61
13835: PUSH
13836: LD_INT 62
13838: PUSH
13839: LD_INT 80
13841: PUSH
13842: LD_INT 82
13844: PUSH
13845: LD_INT 83
13847: PUSH
13848: LD_INT 84
13850: PUSH
13851: LD_INT 85
13853: PUSH
13854: LD_INT 86
13856: PUSH
13857: EMPTY
13858: LIST
13859: LIST
13860: LIST
13861: LIST
13862: LIST
13863: LIST
13864: LIST
13865: LIST
13866: LIST
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: ST_TO_ADDR
13910: GO 14377
13912: LD_INT 2
13914: DOUBLE
13915: EQUAL
13916: IFTRUE 13920
13918: GO 14146
13920: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
13921: LD_ADDR_VAR 0 4
13925: PUSH
13926: LD_INT 35
13928: PUSH
13929: LD_INT 45
13931: PUSH
13932: LD_INT 46
13934: PUSH
13935: LD_INT 47
13937: PUSH
13938: LD_INT 82
13940: PUSH
13941: LD_INT 83
13943: PUSH
13944: LD_INT 84
13946: PUSH
13947: LD_INT 85
13949: PUSH
13950: LD_INT 87
13952: PUSH
13953: LD_INT 70
13955: PUSH
13956: LD_INT 1
13958: PUSH
13959: LD_INT 11
13961: PUSH
13962: LD_INT 3
13964: PUSH
13965: LD_INT 4
13967: PUSH
13968: LD_INT 5
13970: PUSH
13971: LD_INT 6
13973: PUSH
13974: LD_INT 15
13976: PUSH
13977: LD_INT 18
13979: PUSH
13980: LD_INT 7
13982: PUSH
13983: LD_INT 17
13985: PUSH
13986: LD_INT 8
13988: PUSH
13989: LD_INT 20
13991: PUSH
13992: LD_INT 21
13994: PUSH
13995: LD_INT 22
13997: PUSH
13998: LD_INT 72
14000: PUSH
14001: LD_INT 26
14003: PUSH
14004: LD_INT 69
14006: PUSH
14007: LD_INT 39
14009: PUSH
14010: LD_INT 40
14012: PUSH
14013: LD_INT 41
14015: PUSH
14016: LD_INT 42
14018: PUSH
14019: LD_INT 43
14021: PUSH
14022: LD_INT 48
14024: PUSH
14025: LD_INT 49
14027: PUSH
14028: LD_INT 50
14030: PUSH
14031: LD_INT 51
14033: PUSH
14034: LD_INT 52
14036: PUSH
14037: LD_INT 53
14039: PUSH
14040: LD_INT 54
14042: PUSH
14043: LD_INT 55
14045: PUSH
14046: LD_INT 56
14048: PUSH
14049: LD_INT 60
14051: PUSH
14052: LD_INT 61
14054: PUSH
14055: LD_INT 62
14057: PUSH
14058: LD_INT 66
14060: PUSH
14061: LD_INT 67
14063: PUSH
14064: LD_INT 68
14066: PUSH
14067: LD_INT 81
14069: PUSH
14070: LD_INT 82
14072: PUSH
14073: LD_INT 83
14075: PUSH
14076: LD_INT 84
14078: PUSH
14079: LD_INT 85
14081: PUSH
14082: LD_INT 87
14084: PUSH
14085: LD_INT 88
14087: PUSH
14088: EMPTY
14089: LIST
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: ST_TO_ADDR
14144: GO 14377
14146: LD_INT 3
14148: DOUBLE
14149: EQUAL
14150: IFTRUE 14154
14152: GO 14376
14154: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14155: LD_ADDR_VAR 0 4
14159: PUSH
14160: LD_INT 46
14162: PUSH
14163: LD_INT 47
14165: PUSH
14166: LD_INT 1
14168: PUSH
14169: LD_INT 2
14171: PUSH
14172: LD_INT 82
14174: PUSH
14175: LD_INT 83
14177: PUSH
14178: LD_INT 84
14180: PUSH
14181: LD_INT 85
14183: PUSH
14184: LD_INT 86
14186: PUSH
14187: LD_INT 11
14189: PUSH
14190: LD_INT 9
14192: PUSH
14193: LD_INT 20
14195: PUSH
14196: LD_INT 19
14198: PUSH
14199: LD_INT 21
14201: PUSH
14202: LD_INT 24
14204: PUSH
14205: LD_INT 22
14207: PUSH
14208: LD_INT 25
14210: PUSH
14211: LD_INT 28
14213: PUSH
14214: LD_INT 29
14216: PUSH
14217: LD_INT 30
14219: PUSH
14220: LD_INT 31
14222: PUSH
14223: LD_INT 37
14225: PUSH
14226: LD_INT 38
14228: PUSH
14229: LD_INT 32
14231: PUSH
14232: LD_INT 27
14234: PUSH
14235: LD_INT 33
14237: PUSH
14238: LD_INT 69
14240: PUSH
14241: LD_INT 39
14243: PUSH
14244: LD_INT 34
14246: PUSH
14247: LD_INT 40
14249: PUSH
14250: LD_INT 71
14252: PUSH
14253: LD_INT 23
14255: PUSH
14256: LD_INT 44
14258: PUSH
14259: LD_INT 48
14261: PUSH
14262: LD_INT 49
14264: PUSH
14265: LD_INT 50
14267: PUSH
14268: LD_INT 51
14270: PUSH
14271: LD_INT 52
14273: PUSH
14274: LD_INT 53
14276: PUSH
14277: LD_INT 54
14279: PUSH
14280: LD_INT 55
14282: PUSH
14283: LD_INT 56
14285: PUSH
14286: LD_INT 57
14288: PUSH
14289: LD_INT 58
14291: PUSH
14292: LD_INT 59
14294: PUSH
14295: LD_INT 63
14297: PUSH
14298: LD_INT 64
14300: PUSH
14301: LD_INT 65
14303: PUSH
14304: LD_INT 82
14306: PUSH
14307: LD_INT 83
14309: PUSH
14310: LD_INT 84
14312: PUSH
14313: LD_INT 85
14315: PUSH
14316: LD_INT 86
14318: PUSH
14319: EMPTY
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: ST_TO_ADDR
14374: GO 14377
14376: POP
// if state > - 1 and state < 3 then
14377: LD_VAR 0 3
14381: PUSH
14382: LD_INT 1
14384: NEG
14385: GREATER
14386: PUSH
14387: LD_VAR 0 3
14391: PUSH
14392: LD_INT 3
14394: LESS
14395: AND
14396: IFFALSE 14453
// for i in result do
14398: LD_ADDR_VAR 0 5
14402: PUSH
14403: LD_VAR 0 4
14407: PUSH
14408: FOR_IN
14409: IFFALSE 14451
// if GetTech ( i , side ) <> state then
14411: LD_VAR 0 5
14415: PPUSH
14416: LD_VAR 0 1
14420: PPUSH
14421: CALL_OW 321
14425: PUSH
14426: LD_VAR 0 3
14430: NONEQUAL
14431: IFFALSE 14449
// result := result diff i ;
14433: LD_ADDR_VAR 0 4
14437: PUSH
14438: LD_VAR 0 4
14442: PUSH
14443: LD_VAR 0 5
14447: DIFF
14448: ST_TO_ADDR
14449: GO 14408
14451: POP
14452: POP
// end ;
14453: LD_VAR 0 4
14457: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14458: LD_INT 0
14460: PPUSH
14461: PPUSH
14462: PPUSH
// result := true ;
14463: LD_ADDR_VAR 0 3
14467: PUSH
14468: LD_INT 1
14470: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14471: LD_ADDR_VAR 0 5
14475: PUSH
14476: LD_VAR 0 2
14480: PPUSH
14481: CALL_OW 480
14485: ST_TO_ADDR
// if not tmp then
14486: LD_VAR 0 5
14490: NOT
14491: IFFALSE 14495
// exit ;
14493: GO 14544
// for i in tmp do
14495: LD_ADDR_VAR 0 4
14499: PUSH
14500: LD_VAR 0 5
14504: PUSH
14505: FOR_IN
14506: IFFALSE 14542
// if GetTech ( i , side ) <> state_researched then
14508: LD_VAR 0 4
14512: PPUSH
14513: LD_VAR 0 1
14517: PPUSH
14518: CALL_OW 321
14522: PUSH
14523: LD_INT 2
14525: NONEQUAL
14526: IFFALSE 14540
// begin result := false ;
14528: LD_ADDR_VAR 0 3
14532: PUSH
14533: LD_INT 0
14535: ST_TO_ADDR
// exit ;
14536: POP
14537: POP
14538: GO 14544
// end ;
14540: GO 14505
14542: POP
14543: POP
// end ;
14544: LD_VAR 0 3
14548: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14549: LD_INT 0
14551: PPUSH
14552: PPUSH
14553: PPUSH
14554: PPUSH
14555: PPUSH
14556: PPUSH
14557: PPUSH
14558: PPUSH
14559: PPUSH
14560: PPUSH
14561: PPUSH
14562: PPUSH
14563: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14564: LD_VAR 0 1
14568: NOT
14569: PUSH
14570: LD_VAR 0 1
14574: PPUSH
14575: CALL_OW 257
14579: PUSH
14580: LD_INT 9
14582: NONEQUAL
14583: OR
14584: IFFALSE 14588
// exit ;
14586: GO 15161
// side := GetSide ( unit ) ;
14588: LD_ADDR_VAR 0 9
14592: PUSH
14593: LD_VAR 0 1
14597: PPUSH
14598: CALL_OW 255
14602: ST_TO_ADDR
// tech_space := tech_spacanom ;
14603: LD_ADDR_VAR 0 12
14607: PUSH
14608: LD_INT 29
14610: ST_TO_ADDR
// tech_time := tech_taurad ;
14611: LD_ADDR_VAR 0 13
14615: PUSH
14616: LD_INT 28
14618: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14619: LD_ADDR_VAR 0 11
14623: PUSH
14624: LD_VAR 0 1
14628: PPUSH
14629: CALL_OW 310
14633: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14634: LD_VAR 0 11
14638: PPUSH
14639: CALL_OW 247
14643: PUSH
14644: LD_INT 2
14646: EQUAL
14647: IFFALSE 14651
// exit ;
14649: GO 15161
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14651: LD_ADDR_VAR 0 8
14655: PUSH
14656: LD_INT 81
14658: PUSH
14659: LD_VAR 0 9
14663: PUSH
14664: EMPTY
14665: LIST
14666: LIST
14667: PUSH
14668: LD_INT 3
14670: PUSH
14671: LD_INT 21
14673: PUSH
14674: LD_INT 3
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: PPUSH
14689: CALL_OW 69
14693: ST_TO_ADDR
// if not tmp then
14694: LD_VAR 0 8
14698: NOT
14699: IFFALSE 14703
// exit ;
14701: GO 15161
// if in_unit then
14703: LD_VAR 0 11
14707: IFFALSE 14731
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14709: LD_ADDR_VAR 0 10
14713: PUSH
14714: LD_VAR 0 8
14718: PPUSH
14719: LD_VAR 0 11
14723: PPUSH
14724: CALL_OW 74
14728: ST_TO_ADDR
14729: GO 14751
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14731: LD_ADDR_VAR 0 10
14735: PUSH
14736: LD_VAR 0 8
14740: PPUSH
14741: LD_VAR 0 1
14745: PPUSH
14746: CALL_OW 74
14750: ST_TO_ADDR
// if not enemy then
14751: LD_VAR 0 10
14755: NOT
14756: IFFALSE 14760
// exit ;
14758: GO 15161
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14760: LD_VAR 0 11
14764: PUSH
14765: LD_VAR 0 11
14769: PPUSH
14770: LD_VAR 0 10
14774: PPUSH
14775: CALL_OW 296
14779: PUSH
14780: LD_INT 13
14782: GREATER
14783: AND
14784: PUSH
14785: LD_VAR 0 1
14789: PPUSH
14790: LD_VAR 0 10
14794: PPUSH
14795: CALL_OW 296
14799: PUSH
14800: LD_INT 12
14802: GREATER
14803: OR
14804: IFFALSE 14808
// exit ;
14806: GO 15161
// missile := [ 1 ] ;
14808: LD_ADDR_VAR 0 14
14812: PUSH
14813: LD_INT 1
14815: PUSH
14816: EMPTY
14817: LIST
14818: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14819: LD_VAR 0 9
14823: PPUSH
14824: LD_VAR 0 12
14828: PPUSH
14829: CALL_OW 325
14833: IFFALSE 14862
// missile := Insert ( missile , missile + 1 , 2 ) ;
14835: LD_ADDR_VAR 0 14
14839: PUSH
14840: LD_VAR 0 14
14844: PPUSH
14845: LD_VAR 0 14
14849: PUSH
14850: LD_INT 1
14852: PLUS
14853: PPUSH
14854: LD_INT 2
14856: PPUSH
14857: CALL_OW 2
14861: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14862: LD_VAR 0 9
14866: PPUSH
14867: LD_VAR 0 13
14871: PPUSH
14872: CALL_OW 325
14876: PUSH
14877: LD_VAR 0 10
14881: PPUSH
14882: CALL_OW 255
14886: PPUSH
14887: LD_VAR 0 13
14891: PPUSH
14892: CALL_OW 325
14896: NOT
14897: AND
14898: IFFALSE 14927
// missile := Insert ( missile , missile + 1 , 3 ) ;
14900: LD_ADDR_VAR 0 14
14904: PUSH
14905: LD_VAR 0 14
14909: PPUSH
14910: LD_VAR 0 14
14914: PUSH
14915: LD_INT 1
14917: PLUS
14918: PPUSH
14919: LD_INT 3
14921: PPUSH
14922: CALL_OW 2
14926: ST_TO_ADDR
// if missile < 2 then
14927: LD_VAR 0 14
14931: PUSH
14932: LD_INT 2
14934: LESS
14935: IFFALSE 14939
// exit ;
14937: GO 15161
// x := GetX ( enemy ) ;
14939: LD_ADDR_VAR 0 4
14943: PUSH
14944: LD_VAR 0 10
14948: PPUSH
14949: CALL_OW 250
14953: ST_TO_ADDR
// y := GetY ( enemy ) ;
14954: LD_ADDR_VAR 0 5
14958: PUSH
14959: LD_VAR 0 10
14963: PPUSH
14964: CALL_OW 251
14968: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14969: LD_ADDR_VAR 0 6
14973: PUSH
14974: LD_VAR 0 4
14978: PUSH
14979: LD_INT 1
14981: NEG
14982: PPUSH
14983: LD_INT 1
14985: PPUSH
14986: CALL_OW 12
14990: PLUS
14991: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
14992: LD_ADDR_VAR 0 7
14996: PUSH
14997: LD_VAR 0 5
15001: PUSH
15002: LD_INT 1
15004: NEG
15005: PPUSH
15006: LD_INT 1
15008: PPUSH
15009: CALL_OW 12
15013: PLUS
15014: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15015: LD_VAR 0 6
15019: PPUSH
15020: LD_VAR 0 7
15024: PPUSH
15025: CALL_OW 488
15029: NOT
15030: IFFALSE 15052
// begin _x := x ;
15032: LD_ADDR_VAR 0 6
15036: PUSH
15037: LD_VAR 0 4
15041: ST_TO_ADDR
// _y := y ;
15042: LD_ADDR_VAR 0 7
15046: PUSH
15047: LD_VAR 0 5
15051: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15052: LD_ADDR_VAR 0 3
15056: PUSH
15057: LD_INT 1
15059: PPUSH
15060: LD_VAR 0 14
15064: PPUSH
15065: CALL_OW 12
15069: ST_TO_ADDR
// case i of 1 :
15070: LD_VAR 0 3
15074: PUSH
15075: LD_INT 1
15077: DOUBLE
15078: EQUAL
15079: IFTRUE 15083
15081: GO 15100
15083: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15084: LD_VAR 0 1
15088: PPUSH
15089: LD_VAR 0 10
15093: PPUSH
15094: CALL_OW 115
15098: GO 15161
15100: LD_INT 2
15102: DOUBLE
15103: EQUAL
15104: IFTRUE 15108
15106: GO 15130
15108: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15109: LD_VAR 0 1
15113: PPUSH
15114: LD_VAR 0 6
15118: PPUSH
15119: LD_VAR 0 7
15123: PPUSH
15124: CALL_OW 153
15128: GO 15161
15130: LD_INT 3
15132: DOUBLE
15133: EQUAL
15134: IFTRUE 15138
15136: GO 15160
15138: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15139: LD_VAR 0 1
15143: PPUSH
15144: LD_VAR 0 6
15148: PPUSH
15149: LD_VAR 0 7
15153: PPUSH
15154: CALL_OW 154
15158: GO 15161
15160: POP
// end ;
15161: LD_VAR 0 2
15165: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15166: LD_INT 0
15168: PPUSH
15169: PPUSH
15170: PPUSH
15171: PPUSH
15172: PPUSH
15173: PPUSH
// if not unit or not building then
15174: LD_VAR 0 1
15178: NOT
15179: PUSH
15180: LD_VAR 0 2
15184: NOT
15185: OR
15186: IFFALSE 15190
// exit ;
15188: GO 15348
// x := GetX ( building ) ;
15190: LD_ADDR_VAR 0 5
15194: PUSH
15195: LD_VAR 0 2
15199: PPUSH
15200: CALL_OW 250
15204: ST_TO_ADDR
// y := GetY ( building ) ;
15205: LD_ADDR_VAR 0 6
15209: PUSH
15210: LD_VAR 0 2
15214: PPUSH
15215: CALL_OW 251
15219: ST_TO_ADDR
// for i = 0 to 5 do
15220: LD_ADDR_VAR 0 4
15224: PUSH
15225: DOUBLE
15226: LD_INT 0
15228: DEC
15229: ST_TO_ADDR
15230: LD_INT 5
15232: PUSH
15233: FOR_TO
15234: IFFALSE 15346
// begin _x := ShiftX ( x , i , 3 ) ;
15236: LD_ADDR_VAR 0 7
15240: PUSH
15241: LD_VAR 0 5
15245: PPUSH
15246: LD_VAR 0 4
15250: PPUSH
15251: LD_INT 3
15253: PPUSH
15254: CALL_OW 272
15258: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15259: LD_ADDR_VAR 0 8
15263: PUSH
15264: LD_VAR 0 6
15268: PPUSH
15269: LD_VAR 0 4
15273: PPUSH
15274: LD_INT 3
15276: PPUSH
15277: CALL_OW 273
15281: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15282: LD_VAR 0 7
15286: PPUSH
15287: LD_VAR 0 8
15291: PPUSH
15292: CALL_OW 488
15296: NOT
15297: IFFALSE 15301
// continue ;
15299: GO 15233
// if HexInfo ( _x , _y ) = 0 then
15301: LD_VAR 0 7
15305: PPUSH
15306: LD_VAR 0 8
15310: PPUSH
15311: CALL_OW 428
15315: PUSH
15316: LD_INT 0
15318: EQUAL
15319: IFFALSE 15344
// begin ComMoveXY ( unit , _x , _y ) ;
15321: LD_VAR 0 1
15325: PPUSH
15326: LD_VAR 0 7
15330: PPUSH
15331: LD_VAR 0 8
15335: PPUSH
15336: CALL_OW 111
// exit ;
15340: POP
15341: POP
15342: GO 15348
// end ; end ;
15344: GO 15233
15346: POP
15347: POP
// end ;
15348: LD_VAR 0 3
15352: RET
// export function ScanBase ( side , base_area ) ; begin
15353: LD_INT 0
15355: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15356: LD_ADDR_VAR 0 3
15360: PUSH
15361: LD_VAR 0 2
15365: PPUSH
15366: LD_INT 81
15368: PUSH
15369: LD_VAR 0 1
15373: PUSH
15374: EMPTY
15375: LIST
15376: LIST
15377: PPUSH
15378: CALL_OW 70
15382: ST_TO_ADDR
// end ;
15383: LD_VAR 0 3
15387: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15388: LD_INT 0
15390: PPUSH
15391: PPUSH
15392: PPUSH
15393: PPUSH
// result := false ;
15394: LD_ADDR_VAR 0 2
15398: PUSH
15399: LD_INT 0
15401: ST_TO_ADDR
// side := GetSide ( unit ) ;
15402: LD_ADDR_VAR 0 3
15406: PUSH
15407: LD_VAR 0 1
15411: PPUSH
15412: CALL_OW 255
15416: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15417: LD_ADDR_VAR 0 4
15421: PUSH
15422: LD_VAR 0 1
15426: PPUSH
15427: CALL_OW 248
15431: ST_TO_ADDR
// case nat of 1 :
15432: LD_VAR 0 4
15436: PUSH
15437: LD_INT 1
15439: DOUBLE
15440: EQUAL
15441: IFTRUE 15445
15443: GO 15456
15445: POP
// tech := tech_lassight ; 2 :
15446: LD_ADDR_VAR 0 5
15450: PUSH
15451: LD_INT 12
15453: ST_TO_ADDR
15454: GO 15495
15456: LD_INT 2
15458: DOUBLE
15459: EQUAL
15460: IFTRUE 15464
15462: GO 15475
15464: POP
// tech := tech_mortar ; 3 :
15465: LD_ADDR_VAR 0 5
15469: PUSH
15470: LD_INT 41
15472: ST_TO_ADDR
15473: GO 15495
15475: LD_INT 3
15477: DOUBLE
15478: EQUAL
15479: IFTRUE 15483
15481: GO 15494
15483: POP
// tech := tech_bazooka ; end ;
15484: LD_ADDR_VAR 0 5
15488: PUSH
15489: LD_INT 44
15491: ST_TO_ADDR
15492: GO 15495
15494: POP
// if Researched ( side , tech ) then
15495: LD_VAR 0 3
15499: PPUSH
15500: LD_VAR 0 5
15504: PPUSH
15505: CALL_OW 325
15509: IFFALSE 15536
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15511: LD_ADDR_VAR 0 2
15515: PUSH
15516: LD_INT 5
15518: PUSH
15519: LD_INT 8
15521: PUSH
15522: LD_INT 9
15524: PUSH
15525: EMPTY
15526: LIST
15527: LIST
15528: LIST
15529: PUSH
15530: LD_VAR 0 4
15534: ARRAY
15535: ST_TO_ADDR
// end ;
15536: LD_VAR 0 2
15540: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15541: LD_INT 0
15543: PPUSH
15544: PPUSH
15545: PPUSH
// if not mines then
15546: LD_VAR 0 2
15550: NOT
15551: IFFALSE 15555
// exit ;
15553: GO 15699
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15555: LD_ADDR_VAR 0 5
15559: PUSH
15560: LD_INT 81
15562: PUSH
15563: LD_VAR 0 1
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: LD_INT 3
15574: PUSH
15575: LD_INT 21
15577: PUSH
15578: LD_INT 3
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PUSH
15589: EMPTY
15590: LIST
15591: LIST
15592: PPUSH
15593: CALL_OW 69
15597: ST_TO_ADDR
// for i in mines do
15598: LD_ADDR_VAR 0 4
15602: PUSH
15603: LD_VAR 0 2
15607: PUSH
15608: FOR_IN
15609: IFFALSE 15697
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15611: LD_VAR 0 4
15615: PUSH
15616: LD_INT 1
15618: ARRAY
15619: PPUSH
15620: LD_VAR 0 4
15624: PUSH
15625: LD_INT 2
15627: ARRAY
15628: PPUSH
15629: CALL_OW 458
15633: NOT
15634: IFFALSE 15638
// continue ;
15636: GO 15608
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15638: LD_VAR 0 4
15642: PUSH
15643: LD_INT 1
15645: ARRAY
15646: PPUSH
15647: LD_VAR 0 4
15651: PUSH
15652: LD_INT 2
15654: ARRAY
15655: PPUSH
15656: CALL_OW 428
15660: PUSH
15661: LD_VAR 0 5
15665: IN
15666: IFFALSE 15695
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15668: LD_VAR 0 4
15672: PUSH
15673: LD_INT 1
15675: ARRAY
15676: PPUSH
15677: LD_VAR 0 4
15681: PUSH
15682: LD_INT 2
15684: ARRAY
15685: PPUSH
15686: LD_VAR 0 1
15690: PPUSH
15691: CALL_OW 456
// end ;
15695: GO 15608
15697: POP
15698: POP
// end ;
15699: LD_VAR 0 3
15703: RET
// export function Count ( array ) ; var i ; begin
15704: LD_INT 0
15706: PPUSH
15707: PPUSH
// result := 0 ;
15708: LD_ADDR_VAR 0 2
15712: PUSH
15713: LD_INT 0
15715: ST_TO_ADDR
// for i in array do
15716: LD_ADDR_VAR 0 3
15720: PUSH
15721: LD_VAR 0 1
15725: PUSH
15726: FOR_IN
15727: IFFALSE 15751
// if i then
15729: LD_VAR 0 3
15733: IFFALSE 15749
// result := result + 1 ;
15735: LD_ADDR_VAR 0 2
15739: PUSH
15740: LD_VAR 0 2
15744: PUSH
15745: LD_INT 1
15747: PLUS
15748: ST_TO_ADDR
15749: GO 15726
15751: POP
15752: POP
// end ;
15753: LD_VAR 0 2
15757: RET
// export function IsEmpty ( building ) ; begin
15758: LD_INT 0
15760: PPUSH
// if not building then
15761: LD_VAR 0 1
15765: NOT
15766: IFFALSE 15770
// exit ;
15768: GO 15813
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15770: LD_ADDR_VAR 0 2
15774: PUSH
15775: LD_VAR 0 1
15779: PUSH
15780: LD_INT 22
15782: PUSH
15783: LD_VAR 0 1
15787: PPUSH
15788: CALL_OW 255
15792: PUSH
15793: EMPTY
15794: LIST
15795: LIST
15796: PUSH
15797: LD_INT 58
15799: PUSH
15800: EMPTY
15801: LIST
15802: PUSH
15803: EMPTY
15804: LIST
15805: LIST
15806: PPUSH
15807: CALL_OW 69
15811: IN
15812: ST_TO_ADDR
// end ;
15813: LD_VAR 0 2
15817: RET
// export function IsNotFull ( building ) ; begin
15818: LD_INT 0
15820: PPUSH
// if not building then
15821: LD_VAR 0 1
15825: NOT
15826: IFFALSE 15830
// exit ;
15828: GO 15849
// result := UnitsInside ( building ) < 6 ;
15830: LD_ADDR_VAR 0 2
15834: PUSH
15835: LD_VAR 0 1
15839: PPUSH
15840: CALL_OW 313
15844: PUSH
15845: LD_INT 6
15847: LESS
15848: ST_TO_ADDR
// end ;
15849: LD_VAR 0 2
15853: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
15854: LD_INT 0
15856: PPUSH
15857: PPUSH
15858: PPUSH
15859: PPUSH
// tmp := [ ] ;
15860: LD_ADDR_VAR 0 3
15864: PUSH
15865: EMPTY
15866: ST_TO_ADDR
// list := [ ] ;
15867: LD_ADDR_VAR 0 5
15871: PUSH
15872: EMPTY
15873: ST_TO_ADDR
// for i = 16 to 25 do
15874: LD_ADDR_VAR 0 4
15878: PUSH
15879: DOUBLE
15880: LD_INT 16
15882: DEC
15883: ST_TO_ADDR
15884: LD_INT 25
15886: PUSH
15887: FOR_TO
15888: IFFALSE 15961
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
15890: LD_ADDR_VAR 0 3
15894: PUSH
15895: LD_VAR 0 3
15899: PUSH
15900: LD_INT 22
15902: PUSH
15903: LD_VAR 0 1
15907: PPUSH
15908: CALL_OW 255
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: PUSH
15917: LD_INT 91
15919: PUSH
15920: LD_VAR 0 1
15924: PUSH
15925: LD_INT 6
15927: PUSH
15928: EMPTY
15929: LIST
15930: LIST
15931: LIST
15932: PUSH
15933: LD_INT 30
15935: PUSH
15936: LD_VAR 0 4
15940: PUSH
15941: EMPTY
15942: LIST
15943: LIST
15944: PUSH
15945: EMPTY
15946: LIST
15947: LIST
15948: LIST
15949: PUSH
15950: EMPTY
15951: LIST
15952: PPUSH
15953: CALL_OW 69
15957: ADD
15958: ST_TO_ADDR
15959: GO 15887
15961: POP
15962: POP
// for i = 1 to tmp do
15963: LD_ADDR_VAR 0 4
15967: PUSH
15968: DOUBLE
15969: LD_INT 1
15971: DEC
15972: ST_TO_ADDR
15973: LD_VAR 0 3
15977: PUSH
15978: FOR_TO
15979: IFFALSE 16067
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
15981: LD_ADDR_VAR 0 5
15985: PUSH
15986: LD_VAR 0 5
15990: PUSH
15991: LD_VAR 0 3
15995: PUSH
15996: LD_VAR 0 4
16000: ARRAY
16001: PPUSH
16002: CALL_OW 266
16006: PUSH
16007: LD_VAR 0 3
16011: PUSH
16012: LD_VAR 0 4
16016: ARRAY
16017: PPUSH
16018: CALL_OW 250
16022: PUSH
16023: LD_VAR 0 3
16027: PUSH
16028: LD_VAR 0 4
16032: ARRAY
16033: PPUSH
16034: CALL_OW 251
16038: PUSH
16039: LD_VAR 0 3
16043: PUSH
16044: LD_VAR 0 4
16048: ARRAY
16049: PPUSH
16050: CALL_OW 254
16054: PUSH
16055: EMPTY
16056: LIST
16057: LIST
16058: LIST
16059: LIST
16060: PUSH
16061: EMPTY
16062: LIST
16063: ADD
16064: ST_TO_ADDR
16065: GO 15978
16067: POP
16068: POP
// result := list ;
16069: LD_ADDR_VAR 0 2
16073: PUSH
16074: LD_VAR 0 5
16078: ST_TO_ADDR
// end ;
16079: LD_VAR 0 2
16083: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16084: LD_INT 0
16086: PPUSH
16087: PPUSH
16088: PPUSH
16089: PPUSH
16090: PPUSH
16091: PPUSH
16092: PPUSH
// if not factory then
16093: LD_VAR 0 1
16097: NOT
16098: IFFALSE 16102
// exit ;
16100: GO 16695
// if control = control_apeman then
16102: LD_VAR 0 4
16106: PUSH
16107: LD_INT 5
16109: EQUAL
16110: IFFALSE 16219
// begin tmp := UnitsInside ( factory ) ;
16112: LD_ADDR_VAR 0 8
16116: PUSH
16117: LD_VAR 0 1
16121: PPUSH
16122: CALL_OW 313
16126: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16127: LD_VAR 0 8
16131: PPUSH
16132: LD_INT 25
16134: PUSH
16135: LD_INT 12
16137: PUSH
16138: EMPTY
16139: LIST
16140: LIST
16141: PPUSH
16142: CALL_OW 72
16146: NOT
16147: IFFALSE 16157
// control := control_manual ;
16149: LD_ADDR_VAR 0 4
16153: PUSH
16154: LD_INT 1
16156: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16157: LD_ADDR_VAR 0 8
16161: PUSH
16162: LD_VAR 0 1
16166: PPUSH
16167: CALL 15854 0 1
16171: ST_TO_ADDR
// if tmp then
16172: LD_VAR 0 8
16176: IFFALSE 16219
// begin for i in tmp do
16178: LD_ADDR_VAR 0 7
16182: PUSH
16183: LD_VAR 0 8
16187: PUSH
16188: FOR_IN
16189: IFFALSE 16217
// if i [ 1 ] = b_ext_radio then
16191: LD_VAR 0 7
16195: PUSH
16196: LD_INT 1
16198: ARRAY
16199: PUSH
16200: LD_INT 22
16202: EQUAL
16203: IFFALSE 16215
// begin control := control_remote ;
16205: LD_ADDR_VAR 0 4
16209: PUSH
16210: LD_INT 2
16212: ST_TO_ADDR
// break ;
16213: GO 16217
// end ;
16215: GO 16188
16217: POP
16218: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16219: LD_VAR 0 1
16223: PPUSH
16224: LD_VAR 0 2
16228: PPUSH
16229: LD_VAR 0 3
16233: PPUSH
16234: LD_VAR 0 4
16238: PPUSH
16239: LD_VAR 0 5
16243: PPUSH
16244: CALL_OW 448
16248: IFFALSE 16283
// begin result := [ chassis , engine , control , weapon ] ;
16250: LD_ADDR_VAR 0 6
16254: PUSH
16255: LD_VAR 0 2
16259: PUSH
16260: LD_VAR 0 3
16264: PUSH
16265: LD_VAR 0 4
16269: PUSH
16270: LD_VAR 0 5
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: LIST
16279: LIST
16280: ST_TO_ADDR
// exit ;
16281: GO 16695
// end ; _chassis := AvailableChassisList ( factory ) ;
16283: LD_ADDR_VAR 0 9
16287: PUSH
16288: LD_VAR 0 1
16292: PPUSH
16293: CALL_OW 475
16297: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16298: LD_ADDR_VAR 0 11
16302: PUSH
16303: LD_VAR 0 1
16307: PPUSH
16308: CALL_OW 476
16312: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16313: LD_ADDR_VAR 0 12
16317: PUSH
16318: LD_VAR 0 1
16322: PPUSH
16323: CALL_OW 477
16327: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
16328: LD_ADDR_VAR 0 10
16332: PUSH
16333: LD_VAR 0 1
16337: PPUSH
16338: CALL_OW 478
16342: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
16343: LD_VAR 0 9
16347: NOT
16348: PUSH
16349: LD_VAR 0 11
16353: NOT
16354: OR
16355: PUSH
16356: LD_VAR 0 12
16360: NOT
16361: OR
16362: PUSH
16363: LD_VAR 0 10
16367: NOT
16368: OR
16369: IFFALSE 16404
// begin result := [ chassis , engine , control , weapon ] ;
16371: LD_ADDR_VAR 0 6
16375: PUSH
16376: LD_VAR 0 2
16380: PUSH
16381: LD_VAR 0 3
16385: PUSH
16386: LD_VAR 0 4
16390: PUSH
16391: LD_VAR 0 5
16395: PUSH
16396: EMPTY
16397: LIST
16398: LIST
16399: LIST
16400: LIST
16401: ST_TO_ADDR
// exit ;
16402: GO 16695
// end ; if not chassis in _chassis then
16404: LD_VAR 0 2
16408: PUSH
16409: LD_VAR 0 9
16413: IN
16414: NOT
16415: IFFALSE 16441
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: LD_VAR 0 9
16426: PUSH
16427: LD_INT 1
16429: PPUSH
16430: LD_VAR 0 9
16434: PPUSH
16435: CALL_OW 12
16439: ARRAY
16440: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16441: LD_VAR 0 2
16445: PPUSH
16446: LD_VAR 0 3
16450: PPUSH
16451: CALL 16700 0 2
16455: NOT
16456: IFFALSE 16515
// repeat engine := _engine [ 1 ] ;
16458: LD_ADDR_VAR 0 3
16462: PUSH
16463: LD_VAR 0 11
16467: PUSH
16468: LD_INT 1
16470: ARRAY
16471: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16472: LD_ADDR_VAR 0 11
16476: PUSH
16477: LD_VAR 0 11
16481: PPUSH
16482: LD_INT 1
16484: PPUSH
16485: CALL_OW 3
16489: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16490: LD_VAR 0 2
16494: PPUSH
16495: LD_VAR 0 3
16499: PPUSH
16500: CALL 16700 0 2
16504: PUSH
16505: LD_VAR 0 11
16509: PUSH
16510: EMPTY
16511: EQUAL
16512: OR
16513: IFFALSE 16458
// if not control in _control then
16515: LD_VAR 0 4
16519: PUSH
16520: LD_VAR 0 12
16524: IN
16525: NOT
16526: IFFALSE 16552
// control := _control [ rand ( 1 , _control ) ] ;
16528: LD_ADDR_VAR 0 4
16532: PUSH
16533: LD_VAR 0 12
16537: PUSH
16538: LD_INT 1
16540: PPUSH
16541: LD_VAR 0 12
16545: PPUSH
16546: CALL_OW 12
16550: ARRAY
16551: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16552: LD_VAR 0 2
16556: PPUSH
16557: LD_VAR 0 5
16561: PPUSH
16562: CALL 16920 0 2
16566: NOT
16567: IFFALSE 16626
// repeat weapon := _weapon [ 1 ] ;
16569: LD_ADDR_VAR 0 5
16573: PUSH
16574: LD_VAR 0 10
16578: PUSH
16579: LD_INT 1
16581: ARRAY
16582: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16583: LD_ADDR_VAR 0 10
16587: PUSH
16588: LD_VAR 0 10
16592: PPUSH
16593: LD_INT 1
16595: PPUSH
16596: CALL_OW 3
16600: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16601: LD_VAR 0 2
16605: PPUSH
16606: LD_VAR 0 5
16610: PPUSH
16611: CALL 16920 0 2
16615: PUSH
16616: LD_VAR 0 10
16620: PUSH
16621: EMPTY
16622: EQUAL
16623: OR
16624: IFFALSE 16569
// result := [ ] ;
16626: LD_ADDR_VAR 0 6
16630: PUSH
16631: EMPTY
16632: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16633: LD_VAR 0 1
16637: PPUSH
16638: LD_VAR 0 2
16642: PPUSH
16643: LD_VAR 0 3
16647: PPUSH
16648: LD_VAR 0 4
16652: PPUSH
16653: LD_VAR 0 5
16657: PPUSH
16658: CALL_OW 448
16662: IFFALSE 16695
// result := [ chassis , engine , control , weapon ] ;
16664: LD_ADDR_VAR 0 6
16668: PUSH
16669: LD_VAR 0 2
16673: PUSH
16674: LD_VAR 0 3
16678: PUSH
16679: LD_VAR 0 4
16683: PUSH
16684: LD_VAR 0 5
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: LIST
16693: LIST
16694: ST_TO_ADDR
// end ;
16695: LD_VAR 0 6
16699: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16700: LD_INT 0
16702: PPUSH
// if not chassis or not engine then
16703: LD_VAR 0 1
16707: NOT
16708: PUSH
16709: LD_VAR 0 2
16713: NOT
16714: OR
16715: IFFALSE 16719
// exit ;
16717: GO 16915
// case engine of engine_solar :
16719: LD_VAR 0 2
16723: PUSH
16724: LD_INT 2
16726: DOUBLE
16727: EQUAL
16728: IFTRUE 16732
16730: GO 16770
16732: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16733: LD_ADDR_VAR 0 3
16737: PUSH
16738: LD_INT 11
16740: PUSH
16741: LD_INT 12
16743: PUSH
16744: LD_INT 13
16746: PUSH
16747: LD_INT 14
16749: PUSH
16750: LD_INT 1
16752: PUSH
16753: LD_INT 2
16755: PUSH
16756: LD_INT 3
16758: PUSH
16759: EMPTY
16760: LIST
16761: LIST
16762: LIST
16763: LIST
16764: LIST
16765: LIST
16766: LIST
16767: ST_TO_ADDR
16768: GO 16899
16770: LD_INT 1
16772: DOUBLE
16773: EQUAL
16774: IFTRUE 16778
16776: GO 16840
16778: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16779: LD_ADDR_VAR 0 3
16783: PUSH
16784: LD_INT 11
16786: PUSH
16787: LD_INT 12
16789: PUSH
16790: LD_INT 13
16792: PUSH
16793: LD_INT 14
16795: PUSH
16796: LD_INT 1
16798: PUSH
16799: LD_INT 2
16801: PUSH
16802: LD_INT 3
16804: PUSH
16805: LD_INT 4
16807: PUSH
16808: LD_INT 5
16810: PUSH
16811: LD_INT 21
16813: PUSH
16814: LD_INT 23
16816: PUSH
16817: LD_INT 22
16819: PUSH
16820: LD_INT 24
16822: PUSH
16823: EMPTY
16824: LIST
16825: LIST
16826: LIST
16827: LIST
16828: LIST
16829: LIST
16830: LIST
16831: LIST
16832: LIST
16833: LIST
16834: LIST
16835: LIST
16836: LIST
16837: ST_TO_ADDR
16838: GO 16899
16840: LD_INT 3
16842: DOUBLE
16843: EQUAL
16844: IFTRUE 16848
16846: GO 16898
16848: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
16849: LD_ADDR_VAR 0 3
16853: PUSH
16854: LD_INT 13
16856: PUSH
16857: LD_INT 14
16859: PUSH
16860: LD_INT 2
16862: PUSH
16863: LD_INT 3
16865: PUSH
16866: LD_INT 4
16868: PUSH
16869: LD_INT 5
16871: PUSH
16872: LD_INT 21
16874: PUSH
16875: LD_INT 22
16877: PUSH
16878: LD_INT 23
16880: PUSH
16881: LD_INT 24
16883: PUSH
16884: EMPTY
16885: LIST
16886: LIST
16887: LIST
16888: LIST
16889: LIST
16890: LIST
16891: LIST
16892: LIST
16893: LIST
16894: LIST
16895: ST_TO_ADDR
16896: GO 16899
16898: POP
// result := ( chassis in result ) ;
16899: LD_ADDR_VAR 0 3
16903: PUSH
16904: LD_VAR 0 1
16908: PUSH
16909: LD_VAR 0 3
16913: IN
16914: ST_TO_ADDR
// end ;
16915: LD_VAR 0 3
16919: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
16920: LD_INT 0
16922: PPUSH
// if not chassis or not weapon then
16923: LD_VAR 0 1
16927: NOT
16928: PUSH
16929: LD_VAR 0 2
16933: NOT
16934: OR
16935: IFFALSE 16939
// exit ;
16937: GO 18001
// case weapon of us_machine_gun :
16939: LD_VAR 0 2
16943: PUSH
16944: LD_INT 2
16946: DOUBLE
16947: EQUAL
16948: IFTRUE 16952
16950: GO 16982
16952: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
16953: LD_ADDR_VAR 0 3
16957: PUSH
16958: LD_INT 1
16960: PUSH
16961: LD_INT 2
16963: PUSH
16964: LD_INT 3
16966: PUSH
16967: LD_INT 4
16969: PUSH
16970: LD_INT 5
16972: PUSH
16973: EMPTY
16974: LIST
16975: LIST
16976: LIST
16977: LIST
16978: LIST
16979: ST_TO_ADDR
16980: GO 17985
16982: LD_INT 3
16984: DOUBLE
16985: EQUAL
16986: IFTRUE 16990
16988: GO 17020
16990: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
16991: LD_ADDR_VAR 0 3
16995: PUSH
16996: LD_INT 1
16998: PUSH
16999: LD_INT 2
17001: PUSH
17002: LD_INT 3
17004: PUSH
17005: LD_INT 4
17007: PUSH
17008: LD_INT 5
17010: PUSH
17011: EMPTY
17012: LIST
17013: LIST
17014: LIST
17015: LIST
17016: LIST
17017: ST_TO_ADDR
17018: GO 17985
17020: LD_INT 11
17022: DOUBLE
17023: EQUAL
17024: IFTRUE 17028
17026: GO 17058
17028: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17029: LD_ADDR_VAR 0 3
17033: PUSH
17034: LD_INT 1
17036: PUSH
17037: LD_INT 2
17039: PUSH
17040: LD_INT 3
17042: PUSH
17043: LD_INT 4
17045: PUSH
17046: LD_INT 5
17048: PUSH
17049: EMPTY
17050: LIST
17051: LIST
17052: LIST
17053: LIST
17054: LIST
17055: ST_TO_ADDR
17056: GO 17985
17058: LD_INT 4
17060: DOUBLE
17061: EQUAL
17062: IFTRUE 17066
17064: GO 17092
17066: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17067: LD_ADDR_VAR 0 3
17071: PUSH
17072: LD_INT 2
17074: PUSH
17075: LD_INT 3
17077: PUSH
17078: LD_INT 4
17080: PUSH
17081: LD_INT 5
17083: PUSH
17084: EMPTY
17085: LIST
17086: LIST
17087: LIST
17088: LIST
17089: ST_TO_ADDR
17090: GO 17985
17092: LD_INT 5
17094: DOUBLE
17095: EQUAL
17096: IFTRUE 17100
17098: GO 17126
17100: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17101: LD_ADDR_VAR 0 3
17105: PUSH
17106: LD_INT 2
17108: PUSH
17109: LD_INT 3
17111: PUSH
17112: LD_INT 4
17114: PUSH
17115: LD_INT 5
17117: PUSH
17118: EMPTY
17119: LIST
17120: LIST
17121: LIST
17122: LIST
17123: ST_TO_ADDR
17124: GO 17985
17126: LD_INT 9
17128: DOUBLE
17129: EQUAL
17130: IFTRUE 17134
17132: GO 17160
17134: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17135: LD_ADDR_VAR 0 3
17139: PUSH
17140: LD_INT 2
17142: PUSH
17143: LD_INT 3
17145: PUSH
17146: LD_INT 4
17148: PUSH
17149: LD_INT 5
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: LIST
17156: LIST
17157: ST_TO_ADDR
17158: GO 17985
17160: LD_INT 7
17162: DOUBLE
17163: EQUAL
17164: IFTRUE 17168
17166: GO 17194
17168: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17169: LD_ADDR_VAR 0 3
17173: PUSH
17174: LD_INT 2
17176: PUSH
17177: LD_INT 3
17179: PUSH
17180: LD_INT 4
17182: PUSH
17183: LD_INT 5
17185: PUSH
17186: EMPTY
17187: LIST
17188: LIST
17189: LIST
17190: LIST
17191: ST_TO_ADDR
17192: GO 17985
17194: LD_INT 12
17196: DOUBLE
17197: EQUAL
17198: IFTRUE 17202
17200: GO 17228
17202: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17203: LD_ADDR_VAR 0 3
17207: PUSH
17208: LD_INT 2
17210: PUSH
17211: LD_INT 3
17213: PUSH
17214: LD_INT 4
17216: PUSH
17217: LD_INT 5
17219: PUSH
17220: EMPTY
17221: LIST
17222: LIST
17223: LIST
17224: LIST
17225: ST_TO_ADDR
17226: GO 17985
17228: LD_INT 13
17230: DOUBLE
17231: EQUAL
17232: IFTRUE 17236
17234: GO 17262
17236: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17237: LD_ADDR_VAR 0 3
17241: PUSH
17242: LD_INT 2
17244: PUSH
17245: LD_INT 3
17247: PUSH
17248: LD_INT 4
17250: PUSH
17251: LD_INT 5
17253: PUSH
17254: EMPTY
17255: LIST
17256: LIST
17257: LIST
17258: LIST
17259: ST_TO_ADDR
17260: GO 17985
17262: LD_INT 14
17264: DOUBLE
17265: EQUAL
17266: IFTRUE 17270
17268: GO 17288
17270: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17271: LD_ADDR_VAR 0 3
17275: PUSH
17276: LD_INT 4
17278: PUSH
17279: LD_INT 5
17281: PUSH
17282: EMPTY
17283: LIST
17284: LIST
17285: ST_TO_ADDR
17286: GO 17985
17288: LD_INT 6
17290: DOUBLE
17291: EQUAL
17292: IFTRUE 17296
17294: GO 17314
17296: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17297: LD_ADDR_VAR 0 3
17301: PUSH
17302: LD_INT 4
17304: PUSH
17305: LD_INT 5
17307: PUSH
17308: EMPTY
17309: LIST
17310: LIST
17311: ST_TO_ADDR
17312: GO 17985
17314: LD_INT 10
17316: DOUBLE
17317: EQUAL
17318: IFTRUE 17322
17320: GO 17340
17322: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
17323: LD_ADDR_VAR 0 3
17327: PUSH
17328: LD_INT 4
17330: PUSH
17331: LD_INT 5
17333: PUSH
17334: EMPTY
17335: LIST
17336: LIST
17337: ST_TO_ADDR
17338: GO 17985
17340: LD_INT 22
17342: DOUBLE
17343: EQUAL
17344: IFTRUE 17348
17346: GO 17374
17348: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
17349: LD_ADDR_VAR 0 3
17353: PUSH
17354: LD_INT 11
17356: PUSH
17357: LD_INT 12
17359: PUSH
17360: LD_INT 13
17362: PUSH
17363: LD_INT 14
17365: PUSH
17366: EMPTY
17367: LIST
17368: LIST
17369: LIST
17370: LIST
17371: ST_TO_ADDR
17372: GO 17985
17374: LD_INT 23
17376: DOUBLE
17377: EQUAL
17378: IFTRUE 17382
17380: GO 17408
17382: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
17383: LD_ADDR_VAR 0 3
17387: PUSH
17388: LD_INT 11
17390: PUSH
17391: LD_INT 12
17393: PUSH
17394: LD_INT 13
17396: PUSH
17397: LD_INT 14
17399: PUSH
17400: EMPTY
17401: LIST
17402: LIST
17403: LIST
17404: LIST
17405: ST_TO_ADDR
17406: GO 17985
17408: LD_INT 24
17410: DOUBLE
17411: EQUAL
17412: IFTRUE 17416
17414: GO 17442
17416: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17417: LD_ADDR_VAR 0 3
17421: PUSH
17422: LD_INT 11
17424: PUSH
17425: LD_INT 12
17427: PUSH
17428: LD_INT 13
17430: PUSH
17431: LD_INT 14
17433: PUSH
17434: EMPTY
17435: LIST
17436: LIST
17437: LIST
17438: LIST
17439: ST_TO_ADDR
17440: GO 17985
17442: LD_INT 30
17444: DOUBLE
17445: EQUAL
17446: IFTRUE 17450
17448: GO 17476
17450: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17451: LD_ADDR_VAR 0 3
17455: PUSH
17456: LD_INT 11
17458: PUSH
17459: LD_INT 12
17461: PUSH
17462: LD_INT 13
17464: PUSH
17465: LD_INT 14
17467: PUSH
17468: EMPTY
17469: LIST
17470: LIST
17471: LIST
17472: LIST
17473: ST_TO_ADDR
17474: GO 17985
17476: LD_INT 25
17478: DOUBLE
17479: EQUAL
17480: IFTRUE 17484
17482: GO 17502
17484: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17485: LD_ADDR_VAR 0 3
17489: PUSH
17490: LD_INT 13
17492: PUSH
17493: LD_INT 14
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: ST_TO_ADDR
17500: GO 17985
17502: LD_INT 27
17504: DOUBLE
17505: EQUAL
17506: IFTRUE 17510
17508: GO 17528
17510: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
17511: LD_ADDR_VAR 0 3
17515: PUSH
17516: LD_INT 13
17518: PUSH
17519: LD_INT 14
17521: PUSH
17522: EMPTY
17523: LIST
17524: LIST
17525: ST_TO_ADDR
17526: GO 17985
17528: LD_EXP 53
17532: DOUBLE
17533: EQUAL
17534: IFTRUE 17538
17536: GO 17564
17538: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17539: LD_ADDR_VAR 0 3
17543: PUSH
17544: LD_INT 11
17546: PUSH
17547: LD_INT 12
17549: PUSH
17550: LD_INT 13
17552: PUSH
17553: LD_INT 14
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: LIST
17560: LIST
17561: ST_TO_ADDR
17562: GO 17985
17564: LD_INT 28
17566: DOUBLE
17567: EQUAL
17568: IFTRUE 17572
17570: GO 17590
17572: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17573: LD_ADDR_VAR 0 3
17577: PUSH
17578: LD_INT 13
17580: PUSH
17581: LD_INT 14
17583: PUSH
17584: EMPTY
17585: LIST
17586: LIST
17587: ST_TO_ADDR
17588: GO 17985
17590: LD_INT 29
17592: DOUBLE
17593: EQUAL
17594: IFTRUE 17598
17596: GO 17616
17598: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17599: LD_ADDR_VAR 0 3
17603: PUSH
17604: LD_INT 13
17606: PUSH
17607: LD_INT 14
17609: PUSH
17610: EMPTY
17611: LIST
17612: LIST
17613: ST_TO_ADDR
17614: GO 17985
17616: LD_INT 31
17618: DOUBLE
17619: EQUAL
17620: IFTRUE 17624
17622: GO 17642
17624: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17625: LD_ADDR_VAR 0 3
17629: PUSH
17630: LD_INT 13
17632: PUSH
17633: LD_INT 14
17635: PUSH
17636: EMPTY
17637: LIST
17638: LIST
17639: ST_TO_ADDR
17640: GO 17985
17642: LD_INT 26
17644: DOUBLE
17645: EQUAL
17646: IFTRUE 17650
17648: GO 17668
17650: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17651: LD_ADDR_VAR 0 3
17655: PUSH
17656: LD_INT 13
17658: PUSH
17659: LD_INT 14
17661: PUSH
17662: EMPTY
17663: LIST
17664: LIST
17665: ST_TO_ADDR
17666: GO 17985
17668: LD_INT 42
17670: DOUBLE
17671: EQUAL
17672: IFTRUE 17676
17674: GO 17702
17676: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17677: LD_ADDR_VAR 0 3
17681: PUSH
17682: LD_INT 21
17684: PUSH
17685: LD_INT 22
17687: PUSH
17688: LD_INT 23
17690: PUSH
17691: LD_INT 24
17693: PUSH
17694: EMPTY
17695: LIST
17696: LIST
17697: LIST
17698: LIST
17699: ST_TO_ADDR
17700: GO 17985
17702: LD_INT 43
17704: DOUBLE
17705: EQUAL
17706: IFTRUE 17710
17708: GO 17736
17710: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17711: LD_ADDR_VAR 0 3
17715: PUSH
17716: LD_INT 21
17718: PUSH
17719: LD_INT 22
17721: PUSH
17722: LD_INT 23
17724: PUSH
17725: LD_INT 24
17727: PUSH
17728: EMPTY
17729: LIST
17730: LIST
17731: LIST
17732: LIST
17733: ST_TO_ADDR
17734: GO 17985
17736: LD_INT 44
17738: DOUBLE
17739: EQUAL
17740: IFTRUE 17744
17742: GO 17770
17744: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17745: LD_ADDR_VAR 0 3
17749: PUSH
17750: LD_INT 21
17752: PUSH
17753: LD_INT 22
17755: PUSH
17756: LD_INT 23
17758: PUSH
17759: LD_INT 24
17761: PUSH
17762: EMPTY
17763: LIST
17764: LIST
17765: LIST
17766: LIST
17767: ST_TO_ADDR
17768: GO 17985
17770: LD_INT 45
17772: DOUBLE
17773: EQUAL
17774: IFTRUE 17778
17776: GO 17804
17778: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17779: LD_ADDR_VAR 0 3
17783: PUSH
17784: LD_INT 21
17786: PUSH
17787: LD_INT 22
17789: PUSH
17790: LD_INT 23
17792: PUSH
17793: LD_INT 24
17795: PUSH
17796: EMPTY
17797: LIST
17798: LIST
17799: LIST
17800: LIST
17801: ST_TO_ADDR
17802: GO 17985
17804: LD_INT 49
17806: DOUBLE
17807: EQUAL
17808: IFTRUE 17812
17810: GO 17838
17812: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17813: LD_ADDR_VAR 0 3
17817: PUSH
17818: LD_INT 21
17820: PUSH
17821: LD_INT 22
17823: PUSH
17824: LD_INT 23
17826: PUSH
17827: LD_INT 24
17829: PUSH
17830: EMPTY
17831: LIST
17832: LIST
17833: LIST
17834: LIST
17835: ST_TO_ADDR
17836: GO 17985
17838: LD_INT 51
17840: DOUBLE
17841: EQUAL
17842: IFTRUE 17846
17844: GO 17872
17846: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
17847: LD_ADDR_VAR 0 3
17851: PUSH
17852: LD_INT 21
17854: PUSH
17855: LD_INT 22
17857: PUSH
17858: LD_INT 23
17860: PUSH
17861: LD_INT 24
17863: PUSH
17864: EMPTY
17865: LIST
17866: LIST
17867: LIST
17868: LIST
17869: ST_TO_ADDR
17870: GO 17985
17872: LD_INT 52
17874: DOUBLE
17875: EQUAL
17876: IFTRUE 17880
17878: GO 17906
17880: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
17881: LD_ADDR_VAR 0 3
17885: PUSH
17886: LD_INT 21
17888: PUSH
17889: LD_INT 22
17891: PUSH
17892: LD_INT 23
17894: PUSH
17895: LD_INT 24
17897: PUSH
17898: EMPTY
17899: LIST
17900: LIST
17901: LIST
17902: LIST
17903: ST_TO_ADDR
17904: GO 17985
17906: LD_INT 53
17908: DOUBLE
17909: EQUAL
17910: IFTRUE 17914
17912: GO 17932
17914: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
17915: LD_ADDR_VAR 0 3
17919: PUSH
17920: LD_INT 23
17922: PUSH
17923: LD_INT 24
17925: PUSH
17926: EMPTY
17927: LIST
17928: LIST
17929: ST_TO_ADDR
17930: GO 17985
17932: LD_INT 46
17934: DOUBLE
17935: EQUAL
17936: IFTRUE 17940
17938: GO 17958
17940: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
17941: LD_ADDR_VAR 0 3
17945: PUSH
17946: LD_INT 23
17948: PUSH
17949: LD_INT 24
17951: PUSH
17952: EMPTY
17953: LIST
17954: LIST
17955: ST_TO_ADDR
17956: GO 17985
17958: LD_INT 47
17960: DOUBLE
17961: EQUAL
17962: IFTRUE 17966
17964: GO 17984
17966: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17967: LD_ADDR_VAR 0 3
17971: PUSH
17972: LD_INT 23
17974: PUSH
17975: LD_INT 24
17977: PUSH
17978: EMPTY
17979: LIST
17980: LIST
17981: ST_TO_ADDR
17982: GO 17985
17984: POP
// result := ( chassis in result ) ;
17985: LD_ADDR_VAR 0 3
17989: PUSH
17990: LD_VAR 0 1
17994: PUSH
17995: LD_VAR 0 3
17999: IN
18000: ST_TO_ADDR
// end ;
18001: LD_VAR 0 3
18005: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
18006: LD_INT 0
18008: PPUSH
18009: PPUSH
18010: PPUSH
18011: PPUSH
18012: PPUSH
18013: PPUSH
18014: PPUSH
// result := array ;
18015: LD_ADDR_VAR 0 5
18019: PUSH
18020: LD_VAR 0 1
18024: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18025: LD_VAR 0 1
18029: NOT
18030: PUSH
18031: LD_VAR 0 2
18035: NOT
18036: OR
18037: PUSH
18038: LD_VAR 0 3
18042: NOT
18043: OR
18044: PUSH
18045: LD_VAR 0 2
18049: PUSH
18050: LD_VAR 0 1
18054: GREATER
18055: OR
18056: PUSH
18057: LD_VAR 0 3
18061: PUSH
18062: LD_VAR 0 1
18066: GREATER
18067: OR
18068: IFFALSE 18072
// exit ;
18070: GO 18368
// if direction then
18072: LD_VAR 0 4
18076: IFFALSE 18140
// begin d := 1 ;
18078: LD_ADDR_VAR 0 9
18082: PUSH
18083: LD_INT 1
18085: ST_TO_ADDR
// if i_from > i_to then
18086: LD_VAR 0 2
18090: PUSH
18091: LD_VAR 0 3
18095: GREATER
18096: IFFALSE 18122
// length := ( array - i_from ) + i_to else
18098: LD_ADDR_VAR 0 11
18102: PUSH
18103: LD_VAR 0 1
18107: PUSH
18108: LD_VAR 0 2
18112: MINUS
18113: PUSH
18114: LD_VAR 0 3
18118: PLUS
18119: ST_TO_ADDR
18120: GO 18138
// length := i_to - i_from ;
18122: LD_ADDR_VAR 0 11
18126: PUSH
18127: LD_VAR 0 3
18131: PUSH
18132: LD_VAR 0 2
18136: MINUS
18137: ST_TO_ADDR
// end else
18138: GO 18201
// begin d := - 1 ;
18140: LD_ADDR_VAR 0 9
18144: PUSH
18145: LD_INT 1
18147: NEG
18148: ST_TO_ADDR
// if i_from > i_to then
18149: LD_VAR 0 2
18153: PUSH
18154: LD_VAR 0 3
18158: GREATER
18159: IFFALSE 18179
// length := i_from - i_to else
18161: LD_ADDR_VAR 0 11
18165: PUSH
18166: LD_VAR 0 2
18170: PUSH
18171: LD_VAR 0 3
18175: MINUS
18176: ST_TO_ADDR
18177: GO 18201
// length := ( array - i_to ) + i_from ;
18179: LD_ADDR_VAR 0 11
18183: PUSH
18184: LD_VAR 0 1
18188: PUSH
18189: LD_VAR 0 3
18193: MINUS
18194: PUSH
18195: LD_VAR 0 2
18199: PLUS
18200: ST_TO_ADDR
// end ; if not length then
18201: LD_VAR 0 11
18205: NOT
18206: IFFALSE 18210
// exit ;
18208: GO 18368
// tmp := array ;
18210: LD_ADDR_VAR 0 10
18214: PUSH
18215: LD_VAR 0 1
18219: ST_TO_ADDR
// for i = 1 to length do
18220: LD_ADDR_VAR 0 6
18224: PUSH
18225: DOUBLE
18226: LD_INT 1
18228: DEC
18229: ST_TO_ADDR
18230: LD_VAR 0 11
18234: PUSH
18235: FOR_TO
18236: IFFALSE 18356
// begin for j = 1 to array do
18238: LD_ADDR_VAR 0 7
18242: PUSH
18243: DOUBLE
18244: LD_INT 1
18246: DEC
18247: ST_TO_ADDR
18248: LD_VAR 0 1
18252: PUSH
18253: FOR_TO
18254: IFFALSE 18342
// begin k := j + d ;
18256: LD_ADDR_VAR 0 8
18260: PUSH
18261: LD_VAR 0 7
18265: PUSH
18266: LD_VAR 0 9
18270: PLUS
18271: ST_TO_ADDR
// if k > array then
18272: LD_VAR 0 8
18276: PUSH
18277: LD_VAR 0 1
18281: GREATER
18282: IFFALSE 18292
// k := 1 ;
18284: LD_ADDR_VAR 0 8
18288: PUSH
18289: LD_INT 1
18291: ST_TO_ADDR
// if not k then
18292: LD_VAR 0 8
18296: NOT
18297: IFFALSE 18309
// k := array ;
18299: LD_ADDR_VAR 0 8
18303: PUSH
18304: LD_VAR 0 1
18308: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18309: LD_ADDR_VAR 0 10
18313: PUSH
18314: LD_VAR 0 10
18318: PPUSH
18319: LD_VAR 0 8
18323: PPUSH
18324: LD_VAR 0 1
18328: PUSH
18329: LD_VAR 0 7
18333: ARRAY
18334: PPUSH
18335: CALL_OW 1
18339: ST_TO_ADDR
// end ;
18340: GO 18253
18342: POP
18343: POP
// array := tmp ;
18344: LD_ADDR_VAR 0 1
18348: PUSH
18349: LD_VAR 0 10
18353: ST_TO_ADDR
// end ;
18354: GO 18235
18356: POP
18357: POP
// result := array ;
18358: LD_ADDR_VAR 0 5
18362: PUSH
18363: LD_VAR 0 1
18367: ST_TO_ADDR
// end ;
18368: LD_VAR 0 5
18372: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
18373: LD_INT 0
18375: PPUSH
18376: PPUSH
// result := 0 ;
18377: LD_ADDR_VAR 0 3
18381: PUSH
18382: LD_INT 0
18384: ST_TO_ADDR
// if not array or not value in array then
18385: LD_VAR 0 1
18389: NOT
18390: PUSH
18391: LD_VAR 0 2
18395: PUSH
18396: LD_VAR 0 1
18400: IN
18401: NOT
18402: OR
18403: IFFALSE 18407
// exit ;
18405: GO 18461
// for i = 1 to array do
18407: LD_ADDR_VAR 0 4
18411: PUSH
18412: DOUBLE
18413: LD_INT 1
18415: DEC
18416: ST_TO_ADDR
18417: LD_VAR 0 1
18421: PUSH
18422: FOR_TO
18423: IFFALSE 18459
// if value = array [ i ] then
18425: LD_VAR 0 2
18429: PUSH
18430: LD_VAR 0 1
18434: PUSH
18435: LD_VAR 0 4
18439: ARRAY
18440: EQUAL
18441: IFFALSE 18457
// begin result := i ;
18443: LD_ADDR_VAR 0 3
18447: PUSH
18448: LD_VAR 0 4
18452: ST_TO_ADDR
// exit ;
18453: POP
18454: POP
18455: GO 18461
// end ;
18457: GO 18422
18459: POP
18460: POP
// end ;
18461: LD_VAR 0 3
18465: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18466: LD_INT 0
18468: PPUSH
// vc_chassis := chassis ;
18469: LD_ADDR_OWVAR 37
18473: PUSH
18474: LD_VAR 0 1
18478: ST_TO_ADDR
// vc_engine := engine ;
18479: LD_ADDR_OWVAR 39
18483: PUSH
18484: LD_VAR 0 2
18488: ST_TO_ADDR
// vc_control := control ;
18489: LD_ADDR_OWVAR 38
18493: PUSH
18494: LD_VAR 0 3
18498: ST_TO_ADDR
// vc_weapon := weapon ;
18499: LD_ADDR_OWVAR 40
18503: PUSH
18504: LD_VAR 0 4
18508: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18509: LD_ADDR_OWVAR 41
18513: PUSH
18514: LD_VAR 0 5
18518: ST_TO_ADDR
// end ;
18519: LD_VAR 0 6
18523: RET
// export function WantPlant ( unit ) ; var task ; begin
18524: LD_INT 0
18526: PPUSH
18527: PPUSH
// result := false ;
18528: LD_ADDR_VAR 0 2
18532: PUSH
18533: LD_INT 0
18535: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18536: LD_ADDR_VAR 0 3
18540: PUSH
18541: LD_VAR 0 1
18545: PPUSH
18546: CALL_OW 437
18550: ST_TO_ADDR
// if task then
18551: LD_VAR 0 3
18555: IFFALSE 18583
// if task [ 1 ] [ 1 ] = p then
18557: LD_VAR 0 3
18561: PUSH
18562: LD_INT 1
18564: ARRAY
18565: PUSH
18566: LD_INT 1
18568: ARRAY
18569: PUSH
18570: LD_STRING p
18572: EQUAL
18573: IFFALSE 18583
// result := true ;
18575: LD_ADDR_VAR 0 2
18579: PUSH
18580: LD_INT 1
18582: ST_TO_ADDR
// end ;
18583: LD_VAR 0 2
18587: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18588: LD_INT 0
18590: PPUSH
18591: PPUSH
18592: PPUSH
18593: PPUSH
// if pos < 1 then
18594: LD_VAR 0 2
18598: PUSH
18599: LD_INT 1
18601: LESS
18602: IFFALSE 18606
// exit ;
18604: GO 18909
// if pos = 1 then
18606: LD_VAR 0 2
18610: PUSH
18611: LD_INT 1
18613: EQUAL
18614: IFFALSE 18647
// result := Replace ( arr , pos [ 1 ] , value ) else
18616: LD_ADDR_VAR 0 4
18620: PUSH
18621: LD_VAR 0 1
18625: PPUSH
18626: LD_VAR 0 2
18630: PUSH
18631: LD_INT 1
18633: ARRAY
18634: PPUSH
18635: LD_VAR 0 3
18639: PPUSH
18640: CALL_OW 1
18644: ST_TO_ADDR
18645: GO 18909
// begin tmp := arr ;
18647: LD_ADDR_VAR 0 6
18651: PUSH
18652: LD_VAR 0 1
18656: ST_TO_ADDR
// s_arr := [ tmp ] ;
18657: LD_ADDR_VAR 0 7
18661: PUSH
18662: LD_VAR 0 6
18666: PUSH
18667: EMPTY
18668: LIST
18669: ST_TO_ADDR
// for i = 1 to pos - 1 do
18670: LD_ADDR_VAR 0 5
18674: PUSH
18675: DOUBLE
18676: LD_INT 1
18678: DEC
18679: ST_TO_ADDR
18680: LD_VAR 0 2
18684: PUSH
18685: LD_INT 1
18687: MINUS
18688: PUSH
18689: FOR_TO
18690: IFFALSE 18735
// begin tmp := tmp [ pos [ i ] ] ;
18692: LD_ADDR_VAR 0 6
18696: PUSH
18697: LD_VAR 0 6
18701: PUSH
18702: LD_VAR 0 2
18706: PUSH
18707: LD_VAR 0 5
18711: ARRAY
18712: ARRAY
18713: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18714: LD_ADDR_VAR 0 7
18718: PUSH
18719: LD_VAR 0 7
18723: PUSH
18724: LD_VAR 0 6
18728: PUSH
18729: EMPTY
18730: LIST
18731: ADD
18732: ST_TO_ADDR
// end ;
18733: GO 18689
18735: POP
18736: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18737: LD_ADDR_VAR 0 6
18741: PUSH
18742: LD_VAR 0 6
18746: PPUSH
18747: LD_VAR 0 2
18751: PUSH
18752: LD_VAR 0 2
18756: ARRAY
18757: PPUSH
18758: LD_VAR 0 3
18762: PPUSH
18763: CALL_OW 1
18767: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18768: LD_ADDR_VAR 0 7
18772: PUSH
18773: LD_VAR 0 7
18777: PPUSH
18778: LD_VAR 0 7
18782: PPUSH
18783: LD_VAR 0 6
18787: PPUSH
18788: CALL_OW 1
18792: ST_TO_ADDR
// for i = s_arr downto 2 do
18793: LD_ADDR_VAR 0 5
18797: PUSH
18798: DOUBLE
18799: LD_VAR 0 7
18803: INC
18804: ST_TO_ADDR
18805: LD_INT 2
18807: PUSH
18808: FOR_DOWNTO
18809: IFFALSE 18893
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18811: LD_ADDR_VAR 0 6
18815: PUSH
18816: LD_VAR 0 7
18820: PUSH
18821: LD_VAR 0 5
18825: PUSH
18826: LD_INT 1
18828: MINUS
18829: ARRAY
18830: PPUSH
18831: LD_VAR 0 2
18835: PUSH
18836: LD_VAR 0 5
18840: PUSH
18841: LD_INT 1
18843: MINUS
18844: ARRAY
18845: PPUSH
18846: LD_VAR 0 7
18850: PUSH
18851: LD_VAR 0 5
18855: ARRAY
18856: PPUSH
18857: CALL_OW 1
18861: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
18862: LD_ADDR_VAR 0 7
18866: PUSH
18867: LD_VAR 0 7
18871: PPUSH
18872: LD_VAR 0 5
18876: PUSH
18877: LD_INT 1
18879: MINUS
18880: PPUSH
18881: LD_VAR 0 6
18885: PPUSH
18886: CALL_OW 1
18890: ST_TO_ADDR
// end ;
18891: GO 18808
18893: POP
18894: POP
// result := s_arr [ 1 ] ;
18895: LD_ADDR_VAR 0 4
18899: PUSH
18900: LD_VAR 0 7
18904: PUSH
18905: LD_INT 1
18907: ARRAY
18908: ST_TO_ADDR
// end ; end ;
18909: LD_VAR 0 4
18913: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
18914: LD_INT 0
18916: PPUSH
18917: PPUSH
// if not list then
18918: LD_VAR 0 1
18922: NOT
18923: IFFALSE 18927
// exit ;
18925: GO 19018
// i := list [ pos1 ] ;
18927: LD_ADDR_VAR 0 5
18931: PUSH
18932: LD_VAR 0 1
18936: PUSH
18937: LD_VAR 0 2
18941: ARRAY
18942: ST_TO_ADDR
// if not i then
18943: LD_VAR 0 5
18947: NOT
18948: IFFALSE 18952
// exit ;
18950: GO 19018
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
18952: LD_ADDR_VAR 0 1
18956: PUSH
18957: LD_VAR 0 1
18961: PPUSH
18962: LD_VAR 0 2
18966: PPUSH
18967: LD_VAR 0 1
18971: PUSH
18972: LD_VAR 0 3
18976: ARRAY
18977: PPUSH
18978: CALL_OW 1
18982: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
18983: LD_ADDR_VAR 0 1
18987: PUSH
18988: LD_VAR 0 1
18992: PPUSH
18993: LD_VAR 0 3
18997: PPUSH
18998: LD_VAR 0 5
19002: PPUSH
19003: CALL_OW 1
19007: ST_TO_ADDR
// result := list ;
19008: LD_ADDR_VAR 0 4
19012: PUSH
19013: LD_VAR 0 1
19017: ST_TO_ADDR
// end ;
19018: LD_VAR 0 4
19022: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19023: LD_INT 0
19025: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19026: LD_ADDR_VAR 0 5
19030: PUSH
19031: LD_VAR 0 1
19035: PPUSH
19036: CALL_OW 250
19040: PPUSH
19041: LD_VAR 0 1
19045: PPUSH
19046: CALL_OW 251
19050: PPUSH
19051: LD_VAR 0 2
19055: PPUSH
19056: LD_VAR 0 3
19060: PPUSH
19061: LD_VAR 0 4
19065: PPUSH
19066: CALL 19076 0 5
19070: ST_TO_ADDR
// end ;
19071: LD_VAR 0 5
19075: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19076: LD_INT 0
19078: PPUSH
19079: PPUSH
19080: PPUSH
19081: PPUSH
// if not list then
19082: LD_VAR 0 3
19086: NOT
19087: IFFALSE 19091
// exit ;
19089: GO 19479
// result := [ ] ;
19091: LD_ADDR_VAR 0 6
19095: PUSH
19096: EMPTY
19097: ST_TO_ADDR
// for i in list do
19098: LD_ADDR_VAR 0 7
19102: PUSH
19103: LD_VAR 0 3
19107: PUSH
19108: FOR_IN
19109: IFFALSE 19311
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19111: LD_ADDR_VAR 0 9
19115: PUSH
19116: LD_VAR 0 7
19120: PPUSH
19121: LD_VAR 0 1
19125: PPUSH
19126: LD_VAR 0 2
19130: PPUSH
19131: CALL_OW 297
19135: ST_TO_ADDR
// if not result then
19136: LD_VAR 0 6
19140: NOT
19141: IFFALSE 19167
// result := [ [ i , tmp ] ] else
19143: LD_ADDR_VAR 0 6
19147: PUSH
19148: LD_VAR 0 7
19152: PUSH
19153: LD_VAR 0 9
19157: PUSH
19158: EMPTY
19159: LIST
19160: LIST
19161: PUSH
19162: EMPTY
19163: LIST
19164: ST_TO_ADDR
19165: GO 19309
// begin if result [ result ] [ 2 ] < tmp then
19167: LD_VAR 0 6
19171: PUSH
19172: LD_VAR 0 6
19176: ARRAY
19177: PUSH
19178: LD_INT 2
19180: ARRAY
19181: PUSH
19182: LD_VAR 0 9
19186: LESS
19187: IFFALSE 19229
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19189: LD_ADDR_VAR 0 6
19193: PUSH
19194: LD_VAR 0 6
19198: PPUSH
19199: LD_VAR 0 6
19203: PUSH
19204: LD_INT 1
19206: PLUS
19207: PPUSH
19208: LD_VAR 0 7
19212: PUSH
19213: LD_VAR 0 9
19217: PUSH
19218: EMPTY
19219: LIST
19220: LIST
19221: PPUSH
19222: CALL_OW 2
19226: ST_TO_ADDR
19227: GO 19309
// for j = 1 to result do
19229: LD_ADDR_VAR 0 8
19233: PUSH
19234: DOUBLE
19235: LD_INT 1
19237: DEC
19238: ST_TO_ADDR
19239: LD_VAR 0 6
19243: PUSH
19244: FOR_TO
19245: IFFALSE 19307
// begin if tmp < result [ j ] [ 2 ] then
19247: LD_VAR 0 9
19251: PUSH
19252: LD_VAR 0 6
19256: PUSH
19257: LD_VAR 0 8
19261: ARRAY
19262: PUSH
19263: LD_INT 2
19265: ARRAY
19266: LESS
19267: IFFALSE 19305
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19269: LD_ADDR_VAR 0 6
19273: PUSH
19274: LD_VAR 0 6
19278: PPUSH
19279: LD_VAR 0 8
19283: PPUSH
19284: LD_VAR 0 7
19288: PUSH
19289: LD_VAR 0 9
19293: PUSH
19294: EMPTY
19295: LIST
19296: LIST
19297: PPUSH
19298: CALL_OW 2
19302: ST_TO_ADDR
// break ;
19303: GO 19307
// end ; end ;
19305: GO 19244
19307: POP
19308: POP
// end ; end ;
19309: GO 19108
19311: POP
19312: POP
// if result and not asc then
19313: LD_VAR 0 6
19317: PUSH
19318: LD_VAR 0 4
19322: NOT
19323: AND
19324: IFFALSE 19399
// begin tmp := result ;
19326: LD_ADDR_VAR 0 9
19330: PUSH
19331: LD_VAR 0 6
19335: ST_TO_ADDR
// for i = tmp downto 1 do
19336: LD_ADDR_VAR 0 7
19340: PUSH
19341: DOUBLE
19342: LD_VAR 0 9
19346: INC
19347: ST_TO_ADDR
19348: LD_INT 1
19350: PUSH
19351: FOR_DOWNTO
19352: IFFALSE 19397
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
19354: LD_ADDR_VAR 0 6
19358: PUSH
19359: LD_VAR 0 6
19363: PPUSH
19364: LD_VAR 0 9
19368: PUSH
19369: LD_VAR 0 7
19373: MINUS
19374: PUSH
19375: LD_INT 1
19377: PLUS
19378: PPUSH
19379: LD_VAR 0 9
19383: PUSH
19384: LD_VAR 0 7
19388: ARRAY
19389: PPUSH
19390: CALL_OW 1
19394: ST_TO_ADDR
19395: GO 19351
19397: POP
19398: POP
// end ; tmp := [ ] ;
19399: LD_ADDR_VAR 0 9
19403: PUSH
19404: EMPTY
19405: ST_TO_ADDR
// if mode then
19406: LD_VAR 0 5
19410: IFFALSE 19479
// begin for i = 1 to result do
19412: LD_ADDR_VAR 0 7
19416: PUSH
19417: DOUBLE
19418: LD_INT 1
19420: DEC
19421: ST_TO_ADDR
19422: LD_VAR 0 6
19426: PUSH
19427: FOR_TO
19428: IFFALSE 19467
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19430: LD_ADDR_VAR 0 9
19434: PUSH
19435: LD_VAR 0 9
19439: PPUSH
19440: LD_VAR 0 7
19444: PPUSH
19445: LD_VAR 0 6
19449: PUSH
19450: LD_VAR 0 7
19454: ARRAY
19455: PUSH
19456: LD_INT 1
19458: ARRAY
19459: PPUSH
19460: CALL_OW 1
19464: ST_TO_ADDR
19465: GO 19427
19467: POP
19468: POP
// result := tmp ;
19469: LD_ADDR_VAR 0 6
19473: PUSH
19474: LD_VAR 0 9
19478: ST_TO_ADDR
// end ; end ;
19479: LD_VAR 0 6
19483: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19484: LD_INT 0
19486: PPUSH
19487: PPUSH
19488: PPUSH
19489: PPUSH
19490: PPUSH
19491: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19492: LD_ADDR_VAR 0 5
19496: PUSH
19497: LD_INT 0
19499: PUSH
19500: LD_INT 0
19502: PUSH
19503: LD_INT 0
19505: PUSH
19506: EMPTY
19507: PUSH
19508: EMPTY
19509: LIST
19510: LIST
19511: LIST
19512: LIST
19513: ST_TO_ADDR
// if not x or not y then
19514: LD_VAR 0 2
19518: NOT
19519: PUSH
19520: LD_VAR 0 3
19524: NOT
19525: OR
19526: IFFALSE 19530
// exit ;
19528: GO 21182
// if not range then
19530: LD_VAR 0 4
19534: NOT
19535: IFFALSE 19545
// range := 10 ;
19537: LD_ADDR_VAR 0 4
19541: PUSH
19542: LD_INT 10
19544: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19545: LD_ADDR_VAR 0 8
19549: PUSH
19550: LD_INT 81
19552: PUSH
19553: LD_VAR 0 1
19557: PUSH
19558: EMPTY
19559: LIST
19560: LIST
19561: PUSH
19562: LD_INT 92
19564: PUSH
19565: LD_VAR 0 2
19569: PUSH
19570: LD_VAR 0 3
19574: PUSH
19575: LD_VAR 0 4
19579: PUSH
19580: EMPTY
19581: LIST
19582: LIST
19583: LIST
19584: LIST
19585: PUSH
19586: LD_INT 3
19588: PUSH
19589: LD_INT 21
19591: PUSH
19592: LD_INT 3
19594: PUSH
19595: EMPTY
19596: LIST
19597: LIST
19598: PUSH
19599: EMPTY
19600: LIST
19601: LIST
19602: PUSH
19603: EMPTY
19604: LIST
19605: LIST
19606: LIST
19607: PPUSH
19608: CALL_OW 69
19612: ST_TO_ADDR
// if not tmp then
19613: LD_VAR 0 8
19617: NOT
19618: IFFALSE 19622
// exit ;
19620: GO 21182
// for i in tmp do
19622: LD_ADDR_VAR 0 6
19626: PUSH
19627: LD_VAR 0 8
19631: PUSH
19632: FOR_IN
19633: IFFALSE 21157
// begin points := [ 0 , 0 , 0 ] ;
19635: LD_ADDR_VAR 0 9
19639: PUSH
19640: LD_INT 0
19642: PUSH
19643: LD_INT 0
19645: PUSH
19646: LD_INT 0
19648: PUSH
19649: EMPTY
19650: LIST
19651: LIST
19652: LIST
19653: ST_TO_ADDR
// bpoints := 1 ;
19654: LD_ADDR_VAR 0 10
19658: PUSH
19659: LD_INT 1
19661: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19662: LD_VAR 0 6
19666: PPUSH
19667: CALL_OW 247
19671: PUSH
19672: LD_INT 1
19674: DOUBLE
19675: EQUAL
19676: IFTRUE 19680
19678: GO 20258
19680: POP
// begin if GetClass ( i ) = 1 then
19681: LD_VAR 0 6
19685: PPUSH
19686: CALL_OW 257
19690: PUSH
19691: LD_INT 1
19693: EQUAL
19694: IFFALSE 19715
// points := [ 10 , 5 , 3 ] ;
19696: LD_ADDR_VAR 0 9
19700: PUSH
19701: LD_INT 10
19703: PUSH
19704: LD_INT 5
19706: PUSH
19707: LD_INT 3
19709: PUSH
19710: EMPTY
19711: LIST
19712: LIST
19713: LIST
19714: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19715: LD_VAR 0 6
19719: PPUSH
19720: CALL_OW 257
19724: PUSH
19725: LD_INT 2
19727: PUSH
19728: LD_INT 3
19730: PUSH
19731: LD_INT 4
19733: PUSH
19734: EMPTY
19735: LIST
19736: LIST
19737: LIST
19738: IN
19739: IFFALSE 19760
// points := [ 3 , 2 , 1 ] ;
19741: LD_ADDR_VAR 0 9
19745: PUSH
19746: LD_INT 3
19748: PUSH
19749: LD_INT 2
19751: PUSH
19752: LD_INT 1
19754: PUSH
19755: EMPTY
19756: LIST
19757: LIST
19758: LIST
19759: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19760: LD_VAR 0 6
19764: PPUSH
19765: CALL_OW 257
19769: PUSH
19770: LD_INT 5
19772: EQUAL
19773: IFFALSE 19794
// points := [ 130 , 5 , 2 ] ;
19775: LD_ADDR_VAR 0 9
19779: PUSH
19780: LD_INT 130
19782: PUSH
19783: LD_INT 5
19785: PUSH
19786: LD_INT 2
19788: PUSH
19789: EMPTY
19790: LIST
19791: LIST
19792: LIST
19793: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19794: LD_VAR 0 6
19798: PPUSH
19799: CALL_OW 257
19803: PUSH
19804: LD_INT 8
19806: EQUAL
19807: IFFALSE 19828
// points := [ 35 , 35 , 30 ] ;
19809: LD_ADDR_VAR 0 9
19813: PUSH
19814: LD_INT 35
19816: PUSH
19817: LD_INT 35
19819: PUSH
19820: LD_INT 30
19822: PUSH
19823: EMPTY
19824: LIST
19825: LIST
19826: LIST
19827: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19828: LD_VAR 0 6
19832: PPUSH
19833: CALL_OW 257
19837: PUSH
19838: LD_INT 9
19840: EQUAL
19841: IFFALSE 19862
// points := [ 20 , 55 , 40 ] ;
19843: LD_ADDR_VAR 0 9
19847: PUSH
19848: LD_INT 20
19850: PUSH
19851: LD_INT 55
19853: PUSH
19854: LD_INT 40
19856: PUSH
19857: EMPTY
19858: LIST
19859: LIST
19860: LIST
19861: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
19862: LD_VAR 0 6
19866: PPUSH
19867: CALL_OW 257
19871: PUSH
19872: LD_INT 12
19874: PUSH
19875: LD_INT 16
19877: PUSH
19878: EMPTY
19879: LIST
19880: LIST
19881: IN
19882: IFFALSE 19903
// points := [ 5 , 3 , 2 ] ;
19884: LD_ADDR_VAR 0 9
19888: PUSH
19889: LD_INT 5
19891: PUSH
19892: LD_INT 3
19894: PUSH
19895: LD_INT 2
19897: PUSH
19898: EMPTY
19899: LIST
19900: LIST
19901: LIST
19902: ST_TO_ADDR
// if GetClass ( i ) = 17 then
19903: LD_VAR 0 6
19907: PPUSH
19908: CALL_OW 257
19912: PUSH
19913: LD_INT 17
19915: EQUAL
19916: IFFALSE 19937
// points := [ 100 , 50 , 75 ] ;
19918: LD_ADDR_VAR 0 9
19922: PUSH
19923: LD_INT 100
19925: PUSH
19926: LD_INT 50
19928: PUSH
19929: LD_INT 75
19931: PUSH
19932: EMPTY
19933: LIST
19934: LIST
19935: LIST
19936: ST_TO_ADDR
// if GetClass ( i ) = 15 then
19937: LD_VAR 0 6
19941: PPUSH
19942: CALL_OW 257
19946: PUSH
19947: LD_INT 15
19949: EQUAL
19950: IFFALSE 19971
// points := [ 10 , 5 , 3 ] ;
19952: LD_ADDR_VAR 0 9
19956: PUSH
19957: LD_INT 10
19959: PUSH
19960: LD_INT 5
19962: PUSH
19963: LD_INT 3
19965: PUSH
19966: EMPTY
19967: LIST
19968: LIST
19969: LIST
19970: ST_TO_ADDR
// if GetClass ( i ) = 14 then
19971: LD_VAR 0 6
19975: PPUSH
19976: CALL_OW 257
19980: PUSH
19981: LD_INT 14
19983: EQUAL
19984: IFFALSE 20005
// points := [ 10 , 0 , 0 ] ;
19986: LD_ADDR_VAR 0 9
19990: PUSH
19991: LD_INT 10
19993: PUSH
19994: LD_INT 0
19996: PUSH
19997: LD_INT 0
19999: PUSH
20000: EMPTY
20001: LIST
20002: LIST
20003: LIST
20004: ST_TO_ADDR
// if GetClass ( i ) = 11 then
20005: LD_VAR 0 6
20009: PPUSH
20010: CALL_OW 257
20014: PUSH
20015: LD_INT 11
20017: EQUAL
20018: IFFALSE 20039
// points := [ 30 , 10 , 5 ] ;
20020: LD_ADDR_VAR 0 9
20024: PUSH
20025: LD_INT 30
20027: PUSH
20028: LD_INT 10
20030: PUSH
20031: LD_INT 5
20033: PUSH
20034: EMPTY
20035: LIST
20036: LIST
20037: LIST
20038: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20039: LD_VAR 0 1
20043: PPUSH
20044: LD_INT 5
20046: PPUSH
20047: CALL_OW 321
20051: PUSH
20052: LD_INT 2
20054: EQUAL
20055: IFFALSE 20072
// bpoints := bpoints * 1.8 ;
20057: LD_ADDR_VAR 0 10
20061: PUSH
20062: LD_VAR 0 10
20066: PUSH
20067: LD_REAL  1.80000000000000E+0000
20070: MUL
20071: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20072: LD_VAR 0 6
20076: PPUSH
20077: CALL_OW 257
20081: PUSH
20082: LD_INT 1
20084: PUSH
20085: LD_INT 2
20087: PUSH
20088: LD_INT 3
20090: PUSH
20091: LD_INT 4
20093: PUSH
20094: EMPTY
20095: LIST
20096: LIST
20097: LIST
20098: LIST
20099: IN
20100: PUSH
20101: LD_VAR 0 1
20105: PPUSH
20106: LD_INT 51
20108: PPUSH
20109: CALL_OW 321
20113: PUSH
20114: LD_INT 2
20116: EQUAL
20117: AND
20118: IFFALSE 20135
// bpoints := bpoints * 1.2 ;
20120: LD_ADDR_VAR 0 10
20124: PUSH
20125: LD_VAR 0 10
20129: PUSH
20130: LD_REAL  1.20000000000000E+0000
20133: MUL
20134: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20135: LD_VAR 0 6
20139: PPUSH
20140: CALL_OW 257
20144: PUSH
20145: LD_INT 5
20147: PUSH
20148: LD_INT 7
20150: PUSH
20151: LD_INT 9
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: LIST
20158: IN
20159: PUSH
20160: LD_VAR 0 1
20164: PPUSH
20165: LD_INT 52
20167: PPUSH
20168: CALL_OW 321
20172: PUSH
20173: LD_INT 2
20175: EQUAL
20176: AND
20177: IFFALSE 20194
// bpoints := bpoints * 1.5 ;
20179: LD_ADDR_VAR 0 10
20183: PUSH
20184: LD_VAR 0 10
20188: PUSH
20189: LD_REAL  1.50000000000000E+0000
20192: MUL
20193: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20194: LD_VAR 0 1
20198: PPUSH
20199: LD_INT 66
20201: PPUSH
20202: CALL_OW 321
20206: PUSH
20207: LD_INT 2
20209: EQUAL
20210: IFFALSE 20227
// bpoints := bpoints * 1.1 ;
20212: LD_ADDR_VAR 0 10
20216: PUSH
20217: LD_VAR 0 10
20221: PUSH
20222: LD_REAL  1.10000000000000E+0000
20225: MUL
20226: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20227: LD_ADDR_VAR 0 10
20231: PUSH
20232: LD_VAR 0 10
20236: PUSH
20237: LD_VAR 0 6
20241: PPUSH
20242: LD_INT 1
20244: PPUSH
20245: CALL_OW 259
20249: PUSH
20250: LD_REAL  1.15000000000000E+0000
20253: MUL
20254: MUL
20255: ST_TO_ADDR
// end ; unit_vehicle :
20256: GO 21086
20258: LD_INT 2
20260: DOUBLE
20261: EQUAL
20262: IFTRUE 20266
20264: GO 21074
20266: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20267: LD_VAR 0 6
20271: PPUSH
20272: CALL_OW 264
20276: PUSH
20277: LD_INT 2
20279: PUSH
20280: LD_INT 42
20282: PUSH
20283: LD_INT 24
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: LIST
20290: IN
20291: IFFALSE 20312
// points := [ 25 , 5 , 3 ] ;
20293: LD_ADDR_VAR 0 9
20297: PUSH
20298: LD_INT 25
20300: PUSH
20301: LD_INT 5
20303: PUSH
20304: LD_INT 3
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: LIST
20311: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20312: LD_VAR 0 6
20316: PPUSH
20317: CALL_OW 264
20321: PUSH
20322: LD_INT 4
20324: PUSH
20325: LD_INT 43
20327: PUSH
20328: LD_INT 25
20330: PUSH
20331: EMPTY
20332: LIST
20333: LIST
20334: LIST
20335: IN
20336: IFFALSE 20357
// points := [ 40 , 15 , 5 ] ;
20338: LD_ADDR_VAR 0 9
20342: PUSH
20343: LD_INT 40
20345: PUSH
20346: LD_INT 15
20348: PUSH
20349: LD_INT 5
20351: PUSH
20352: EMPTY
20353: LIST
20354: LIST
20355: LIST
20356: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
20357: LD_VAR 0 6
20361: PPUSH
20362: CALL_OW 264
20366: PUSH
20367: LD_INT 3
20369: PUSH
20370: LD_INT 23
20372: PUSH
20373: EMPTY
20374: LIST
20375: LIST
20376: IN
20377: IFFALSE 20398
// points := [ 7 , 25 , 8 ] ;
20379: LD_ADDR_VAR 0 9
20383: PUSH
20384: LD_INT 7
20386: PUSH
20387: LD_INT 25
20389: PUSH
20390: LD_INT 8
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: LIST
20397: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
20398: LD_VAR 0 6
20402: PPUSH
20403: CALL_OW 264
20407: PUSH
20408: LD_INT 5
20410: PUSH
20411: LD_INT 27
20413: PUSH
20414: LD_INT 44
20416: PUSH
20417: EMPTY
20418: LIST
20419: LIST
20420: LIST
20421: IN
20422: IFFALSE 20443
// points := [ 14 , 50 , 16 ] ;
20424: LD_ADDR_VAR 0 9
20428: PUSH
20429: LD_INT 14
20431: PUSH
20432: LD_INT 50
20434: PUSH
20435: LD_INT 16
20437: PUSH
20438: EMPTY
20439: LIST
20440: LIST
20441: LIST
20442: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20443: LD_VAR 0 6
20447: PPUSH
20448: CALL_OW 264
20452: PUSH
20453: LD_INT 6
20455: PUSH
20456: LD_INT 46
20458: PUSH
20459: EMPTY
20460: LIST
20461: LIST
20462: IN
20463: IFFALSE 20484
// points := [ 32 , 120 , 70 ] ;
20465: LD_ADDR_VAR 0 9
20469: PUSH
20470: LD_INT 32
20472: PUSH
20473: LD_INT 120
20475: PUSH
20476: LD_INT 70
20478: PUSH
20479: EMPTY
20480: LIST
20481: LIST
20482: LIST
20483: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
20484: LD_VAR 0 6
20488: PPUSH
20489: CALL_OW 264
20493: PUSH
20494: LD_INT 7
20496: PUSH
20497: LD_INT 28
20499: PUSH
20500: LD_INT 45
20502: PUSH
20503: LD_EXP 53
20507: PUSH
20508: EMPTY
20509: LIST
20510: LIST
20511: LIST
20512: LIST
20513: IN
20514: IFFALSE 20535
// points := [ 35 , 20 , 45 ] ;
20516: LD_ADDR_VAR 0 9
20520: PUSH
20521: LD_INT 35
20523: PUSH
20524: LD_INT 20
20526: PUSH
20527: LD_INT 45
20529: PUSH
20530: EMPTY
20531: LIST
20532: LIST
20533: LIST
20534: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20535: LD_VAR 0 6
20539: PPUSH
20540: CALL_OW 264
20544: PUSH
20545: LD_INT 47
20547: PUSH
20548: EMPTY
20549: LIST
20550: IN
20551: IFFALSE 20572
// points := [ 67 , 45 , 75 ] ;
20553: LD_ADDR_VAR 0 9
20557: PUSH
20558: LD_INT 67
20560: PUSH
20561: LD_INT 45
20563: PUSH
20564: LD_INT 75
20566: PUSH
20567: EMPTY
20568: LIST
20569: LIST
20570: LIST
20571: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20572: LD_VAR 0 6
20576: PPUSH
20577: CALL_OW 264
20581: PUSH
20582: LD_INT 26
20584: PUSH
20585: EMPTY
20586: LIST
20587: IN
20588: IFFALSE 20609
// points := [ 120 , 30 , 80 ] ;
20590: LD_ADDR_VAR 0 9
20594: PUSH
20595: LD_INT 120
20597: PUSH
20598: LD_INT 30
20600: PUSH
20601: LD_INT 80
20603: PUSH
20604: EMPTY
20605: LIST
20606: LIST
20607: LIST
20608: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20609: LD_VAR 0 6
20613: PPUSH
20614: CALL_OW 264
20618: PUSH
20619: LD_INT 22
20621: PUSH
20622: EMPTY
20623: LIST
20624: IN
20625: IFFALSE 20646
// points := [ 40 , 1 , 1 ] ;
20627: LD_ADDR_VAR 0 9
20631: PUSH
20632: LD_INT 40
20634: PUSH
20635: LD_INT 1
20637: PUSH
20638: LD_INT 1
20640: PUSH
20641: EMPTY
20642: LIST
20643: LIST
20644: LIST
20645: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20646: LD_VAR 0 6
20650: PPUSH
20651: CALL_OW 264
20655: PUSH
20656: LD_INT 29
20658: PUSH
20659: EMPTY
20660: LIST
20661: IN
20662: IFFALSE 20683
// points := [ 70 , 200 , 400 ] ;
20664: LD_ADDR_VAR 0 9
20668: PUSH
20669: LD_INT 70
20671: PUSH
20672: LD_INT 200
20674: PUSH
20675: LD_INT 400
20677: PUSH
20678: EMPTY
20679: LIST
20680: LIST
20681: LIST
20682: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20683: LD_VAR 0 6
20687: PPUSH
20688: CALL_OW 264
20692: PUSH
20693: LD_INT 14
20695: PUSH
20696: LD_INT 53
20698: PUSH
20699: EMPTY
20700: LIST
20701: LIST
20702: IN
20703: IFFALSE 20724
// points := [ 40 , 10 , 20 ] ;
20705: LD_ADDR_VAR 0 9
20709: PUSH
20710: LD_INT 40
20712: PUSH
20713: LD_INT 10
20715: PUSH
20716: LD_INT 20
20718: PUSH
20719: EMPTY
20720: LIST
20721: LIST
20722: LIST
20723: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20724: LD_VAR 0 6
20728: PPUSH
20729: CALL_OW 264
20733: PUSH
20734: LD_INT 9
20736: PUSH
20737: EMPTY
20738: LIST
20739: IN
20740: IFFALSE 20761
// points := [ 5 , 70 , 20 ] ;
20742: LD_ADDR_VAR 0 9
20746: PUSH
20747: LD_INT 5
20749: PUSH
20750: LD_INT 70
20752: PUSH
20753: LD_INT 20
20755: PUSH
20756: EMPTY
20757: LIST
20758: LIST
20759: LIST
20760: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20761: LD_VAR 0 6
20765: PPUSH
20766: CALL_OW 264
20770: PUSH
20771: LD_INT 10
20773: PUSH
20774: EMPTY
20775: LIST
20776: IN
20777: IFFALSE 20798
// points := [ 35 , 110 , 70 ] ;
20779: LD_ADDR_VAR 0 9
20783: PUSH
20784: LD_INT 35
20786: PUSH
20787: LD_INT 110
20789: PUSH
20790: LD_INT 70
20792: PUSH
20793: EMPTY
20794: LIST
20795: LIST
20796: LIST
20797: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20798: LD_VAR 0 6
20802: PPUSH
20803: CALL_OW 265
20807: PUSH
20808: LD_INT 25
20810: EQUAL
20811: IFFALSE 20832
// points := [ 80 , 65 , 100 ] ;
20813: LD_ADDR_VAR 0 9
20817: PUSH
20818: LD_INT 80
20820: PUSH
20821: LD_INT 65
20823: PUSH
20824: LD_INT 100
20826: PUSH
20827: EMPTY
20828: LIST
20829: LIST
20830: LIST
20831: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20832: LD_VAR 0 6
20836: PPUSH
20837: CALL_OW 263
20841: PUSH
20842: LD_INT 1
20844: EQUAL
20845: IFFALSE 20880
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
20847: LD_ADDR_VAR 0 10
20851: PUSH
20852: LD_VAR 0 10
20856: PUSH
20857: LD_VAR 0 6
20861: PPUSH
20862: CALL_OW 311
20866: PPUSH
20867: LD_INT 3
20869: PPUSH
20870: CALL_OW 259
20874: PUSH
20875: LD_INT 4
20877: MUL
20878: MUL
20879: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
20880: LD_VAR 0 6
20884: PPUSH
20885: CALL_OW 263
20889: PUSH
20890: LD_INT 2
20892: EQUAL
20893: IFFALSE 20944
// begin j := IsControledBy ( i ) ;
20895: LD_ADDR_VAR 0 7
20899: PUSH
20900: LD_VAR 0 6
20904: PPUSH
20905: CALL_OW 312
20909: ST_TO_ADDR
// if j then
20910: LD_VAR 0 7
20914: IFFALSE 20944
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
20916: LD_ADDR_VAR 0 10
20920: PUSH
20921: LD_VAR 0 10
20925: PUSH
20926: LD_VAR 0 7
20930: PPUSH
20931: LD_INT 3
20933: PPUSH
20934: CALL_OW 259
20938: PUSH
20939: LD_INT 3
20941: MUL
20942: MUL
20943: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
20944: LD_VAR 0 6
20948: PPUSH
20949: CALL_OW 264
20953: PUSH
20954: LD_INT 5
20956: PUSH
20957: LD_INT 6
20959: PUSH
20960: LD_INT 46
20962: PUSH
20963: LD_INT 44
20965: PUSH
20966: LD_INT 47
20968: PUSH
20969: LD_INT 45
20971: PUSH
20972: LD_INT 28
20974: PUSH
20975: LD_INT 7
20977: PUSH
20978: LD_INT 27
20980: PUSH
20981: LD_INT 29
20983: PUSH
20984: EMPTY
20985: LIST
20986: LIST
20987: LIST
20988: LIST
20989: LIST
20990: LIST
20991: LIST
20992: LIST
20993: LIST
20994: LIST
20995: IN
20996: PUSH
20997: LD_VAR 0 1
21001: PPUSH
21002: LD_INT 52
21004: PPUSH
21005: CALL_OW 321
21009: PUSH
21010: LD_INT 2
21012: EQUAL
21013: AND
21014: IFFALSE 21031
// bpoints := bpoints * 1.2 ;
21016: LD_ADDR_VAR 0 10
21020: PUSH
21021: LD_VAR 0 10
21025: PUSH
21026: LD_REAL  1.20000000000000E+0000
21029: MUL
21030: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21031: LD_VAR 0 6
21035: PPUSH
21036: CALL_OW 264
21040: PUSH
21041: LD_INT 6
21043: PUSH
21044: LD_INT 46
21046: PUSH
21047: LD_INT 47
21049: PUSH
21050: EMPTY
21051: LIST
21052: LIST
21053: LIST
21054: IN
21055: IFFALSE 21072
// bpoints := bpoints * 1.2 ;
21057: LD_ADDR_VAR 0 10
21061: PUSH
21062: LD_VAR 0 10
21066: PUSH
21067: LD_REAL  1.20000000000000E+0000
21070: MUL
21071: ST_TO_ADDR
// end ; unit_building :
21072: GO 21086
21074: LD_INT 3
21076: DOUBLE
21077: EQUAL
21078: IFTRUE 21082
21080: GO 21085
21082: POP
// ; end ;
21083: GO 21086
21085: POP
// for j = 1 to 3 do
21086: LD_ADDR_VAR 0 7
21090: PUSH
21091: DOUBLE
21092: LD_INT 1
21094: DEC
21095: ST_TO_ADDR
21096: LD_INT 3
21098: PUSH
21099: FOR_TO
21100: IFFALSE 21153
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21102: LD_ADDR_VAR 0 5
21106: PUSH
21107: LD_VAR 0 5
21111: PPUSH
21112: LD_VAR 0 7
21116: PPUSH
21117: LD_VAR 0 5
21121: PUSH
21122: LD_VAR 0 7
21126: ARRAY
21127: PUSH
21128: LD_VAR 0 9
21132: PUSH
21133: LD_VAR 0 7
21137: ARRAY
21138: PUSH
21139: LD_VAR 0 10
21143: MUL
21144: PLUS
21145: PPUSH
21146: CALL_OW 1
21150: ST_TO_ADDR
21151: GO 21099
21153: POP
21154: POP
// end ;
21155: GO 19632
21157: POP
21158: POP
// result := Replace ( result , 4 , tmp ) ;
21159: LD_ADDR_VAR 0 5
21163: PUSH
21164: LD_VAR 0 5
21168: PPUSH
21169: LD_INT 4
21171: PPUSH
21172: LD_VAR 0 8
21176: PPUSH
21177: CALL_OW 1
21181: ST_TO_ADDR
// end ;
21182: LD_VAR 0 5
21186: RET
// export function DangerAtRange ( unit , range ) ; begin
21187: LD_INT 0
21189: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21190: LD_ADDR_VAR 0 3
21194: PUSH
21195: LD_VAR 0 1
21199: PPUSH
21200: CALL_OW 255
21204: PPUSH
21205: LD_VAR 0 1
21209: PPUSH
21210: CALL_OW 250
21214: PPUSH
21215: LD_VAR 0 1
21219: PPUSH
21220: CALL_OW 251
21224: PPUSH
21225: LD_VAR 0 2
21229: PPUSH
21230: CALL 19484 0 4
21234: ST_TO_ADDR
// end ;
21235: LD_VAR 0 3
21239: RET
// export function DangerInArea ( side , area ) ; begin
21240: LD_INT 0
21242: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21243: LD_ADDR_VAR 0 3
21247: PUSH
21248: LD_VAR 0 2
21252: PPUSH
21253: LD_INT 81
21255: PUSH
21256: LD_VAR 0 1
21260: PUSH
21261: EMPTY
21262: LIST
21263: LIST
21264: PPUSH
21265: CALL_OW 70
21269: ST_TO_ADDR
// end ;
21270: LD_VAR 0 3
21274: RET
// export function IsExtension ( b ) ; begin
21275: LD_INT 0
21277: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21278: LD_ADDR_VAR 0 2
21282: PUSH
21283: LD_VAR 0 1
21287: PUSH
21288: LD_INT 23
21290: PUSH
21291: LD_INT 20
21293: PUSH
21294: LD_INT 22
21296: PUSH
21297: LD_INT 17
21299: PUSH
21300: LD_INT 24
21302: PUSH
21303: LD_INT 21
21305: PUSH
21306: LD_INT 19
21308: PUSH
21309: LD_INT 16
21311: PUSH
21312: LD_INT 25
21314: PUSH
21315: LD_INT 18
21317: PUSH
21318: EMPTY
21319: LIST
21320: LIST
21321: LIST
21322: LIST
21323: LIST
21324: LIST
21325: LIST
21326: LIST
21327: LIST
21328: LIST
21329: IN
21330: ST_TO_ADDR
// end ;
21331: LD_VAR 0 2
21335: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
21336: LD_INT 0
21338: PPUSH
21339: PPUSH
21340: PPUSH
// result := [ ] ;
21341: LD_ADDR_VAR 0 4
21345: PUSH
21346: EMPTY
21347: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21348: LD_ADDR_VAR 0 5
21352: PUSH
21353: LD_VAR 0 2
21357: PPUSH
21358: LD_INT 21
21360: PUSH
21361: LD_INT 3
21363: PUSH
21364: EMPTY
21365: LIST
21366: LIST
21367: PPUSH
21368: CALL_OW 70
21372: ST_TO_ADDR
// if not tmp then
21373: LD_VAR 0 5
21377: NOT
21378: IFFALSE 21382
// exit ;
21380: GO 21446
// if checkLink then
21382: LD_VAR 0 3
21386: IFFALSE 21436
// begin for i in tmp do
21388: LD_ADDR_VAR 0 6
21392: PUSH
21393: LD_VAR 0 5
21397: PUSH
21398: FOR_IN
21399: IFFALSE 21434
// if GetBase ( i ) <> base then
21401: LD_VAR 0 6
21405: PPUSH
21406: CALL_OW 274
21410: PUSH
21411: LD_VAR 0 1
21415: NONEQUAL
21416: IFFALSE 21432
// ComLinkToBase ( base , i ) ;
21418: LD_VAR 0 1
21422: PPUSH
21423: LD_VAR 0 6
21427: PPUSH
21428: CALL_OW 169
21432: GO 21398
21434: POP
21435: POP
// end ; result := tmp ;
21436: LD_ADDR_VAR 0 4
21440: PUSH
21441: LD_VAR 0 5
21445: ST_TO_ADDR
// end ;
21446: LD_VAR 0 4
21450: RET
// export function ComComplete ( units , b ) ; var i ; begin
21451: LD_INT 0
21453: PPUSH
21454: PPUSH
// if not units then
21455: LD_VAR 0 1
21459: NOT
21460: IFFALSE 21464
// exit ;
21462: GO 21554
// for i in units do
21464: LD_ADDR_VAR 0 4
21468: PUSH
21469: LD_VAR 0 1
21473: PUSH
21474: FOR_IN
21475: IFFALSE 21552
// if BuildingStatus ( b ) = bs_build then
21477: LD_VAR 0 2
21481: PPUSH
21482: CALL_OW 461
21486: PUSH
21487: LD_INT 1
21489: EQUAL
21490: IFFALSE 21550
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21492: LD_VAR 0 4
21496: PPUSH
21497: LD_STRING h
21499: PUSH
21500: LD_VAR 0 2
21504: PPUSH
21505: CALL_OW 250
21509: PUSH
21510: LD_VAR 0 2
21514: PPUSH
21515: CALL_OW 251
21519: PUSH
21520: LD_VAR 0 2
21524: PUSH
21525: LD_INT 0
21527: PUSH
21528: LD_INT 0
21530: PUSH
21531: LD_INT 0
21533: PUSH
21534: EMPTY
21535: LIST
21536: LIST
21537: LIST
21538: LIST
21539: LIST
21540: LIST
21541: LIST
21542: PUSH
21543: EMPTY
21544: LIST
21545: PPUSH
21546: CALL_OW 446
21550: GO 21474
21552: POP
21553: POP
// end ;
21554: LD_VAR 0 3
21558: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21559: LD_INT 0
21561: PPUSH
21562: PPUSH
21563: PPUSH
21564: PPUSH
21565: PPUSH
21566: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
21567: LD_VAR 0 1
21571: NOT
21572: PUSH
21573: LD_VAR 0 1
21577: PPUSH
21578: CALL_OW 263
21582: PUSH
21583: LD_INT 2
21585: NONEQUAL
21586: OR
21587: IFFALSE 21591
// exit ;
21589: GO 21907
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21591: LD_ADDR_VAR 0 6
21595: PUSH
21596: LD_INT 22
21598: PUSH
21599: LD_VAR 0 1
21603: PPUSH
21604: CALL_OW 255
21608: PUSH
21609: EMPTY
21610: LIST
21611: LIST
21612: PUSH
21613: LD_INT 2
21615: PUSH
21616: LD_INT 30
21618: PUSH
21619: LD_INT 36
21621: PUSH
21622: EMPTY
21623: LIST
21624: LIST
21625: PUSH
21626: LD_INT 34
21628: PUSH
21629: LD_INT 31
21631: PUSH
21632: EMPTY
21633: LIST
21634: LIST
21635: PUSH
21636: EMPTY
21637: LIST
21638: LIST
21639: LIST
21640: PUSH
21641: EMPTY
21642: LIST
21643: LIST
21644: PPUSH
21645: CALL_OW 69
21649: ST_TO_ADDR
// if not tmp then
21650: LD_VAR 0 6
21654: NOT
21655: IFFALSE 21659
// exit ;
21657: GO 21907
// result := [ ] ;
21659: LD_ADDR_VAR 0 2
21663: PUSH
21664: EMPTY
21665: ST_TO_ADDR
// for i in tmp do
21666: LD_ADDR_VAR 0 3
21670: PUSH
21671: LD_VAR 0 6
21675: PUSH
21676: FOR_IN
21677: IFFALSE 21748
// begin t := UnitsInside ( i ) ;
21679: LD_ADDR_VAR 0 4
21683: PUSH
21684: LD_VAR 0 3
21688: PPUSH
21689: CALL_OW 313
21693: ST_TO_ADDR
// if t then
21694: LD_VAR 0 4
21698: IFFALSE 21746
// for j in t do
21700: LD_ADDR_VAR 0 7
21704: PUSH
21705: LD_VAR 0 4
21709: PUSH
21710: FOR_IN
21711: IFFALSE 21744
// result := Replace ( result , result + 1 , j ) ;
21713: LD_ADDR_VAR 0 2
21717: PUSH
21718: LD_VAR 0 2
21722: PPUSH
21723: LD_VAR 0 2
21727: PUSH
21728: LD_INT 1
21730: PLUS
21731: PPUSH
21732: LD_VAR 0 7
21736: PPUSH
21737: CALL_OW 1
21741: ST_TO_ADDR
21742: GO 21710
21744: POP
21745: POP
// end ;
21746: GO 21676
21748: POP
21749: POP
// if not result then
21750: LD_VAR 0 2
21754: NOT
21755: IFFALSE 21759
// exit ;
21757: GO 21907
// mech := result [ 1 ] ;
21759: LD_ADDR_VAR 0 5
21763: PUSH
21764: LD_VAR 0 2
21768: PUSH
21769: LD_INT 1
21771: ARRAY
21772: ST_TO_ADDR
// if result > 1 then
21773: LD_VAR 0 2
21777: PUSH
21778: LD_INT 1
21780: GREATER
21781: IFFALSE 21893
// begin for i = 2 to result do
21783: LD_ADDR_VAR 0 3
21787: PUSH
21788: DOUBLE
21789: LD_INT 2
21791: DEC
21792: ST_TO_ADDR
21793: LD_VAR 0 2
21797: PUSH
21798: FOR_TO
21799: IFFALSE 21891
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21801: LD_ADDR_VAR 0 4
21805: PUSH
21806: LD_VAR 0 2
21810: PUSH
21811: LD_VAR 0 3
21815: ARRAY
21816: PPUSH
21817: LD_INT 3
21819: PPUSH
21820: CALL_OW 259
21824: PUSH
21825: LD_VAR 0 2
21829: PUSH
21830: LD_VAR 0 3
21834: ARRAY
21835: PPUSH
21836: CALL_OW 432
21840: MINUS
21841: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
21842: LD_VAR 0 4
21846: PUSH
21847: LD_VAR 0 5
21851: PPUSH
21852: LD_INT 3
21854: PPUSH
21855: CALL_OW 259
21859: PUSH
21860: LD_VAR 0 5
21864: PPUSH
21865: CALL_OW 432
21869: MINUS
21870: GREATEREQUAL
21871: IFFALSE 21889
// mech := result [ i ] ;
21873: LD_ADDR_VAR 0 5
21877: PUSH
21878: LD_VAR 0 2
21882: PUSH
21883: LD_VAR 0 3
21887: ARRAY
21888: ST_TO_ADDR
// end ;
21889: GO 21798
21891: POP
21892: POP
// end ; ComLinkTo ( vehicle , mech ) ;
21893: LD_VAR 0 1
21897: PPUSH
21898: LD_VAR 0 5
21902: PPUSH
21903: CALL_OW 135
// end ;
21907: LD_VAR 0 2
21911: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
21912: LD_INT 0
21914: PPUSH
21915: PPUSH
21916: PPUSH
21917: PPUSH
21918: PPUSH
21919: PPUSH
21920: PPUSH
21921: PPUSH
21922: PPUSH
21923: PPUSH
21924: PPUSH
21925: PPUSH
21926: PPUSH
// result := [ ] ;
21927: LD_ADDR_VAR 0 7
21931: PUSH
21932: EMPTY
21933: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
21934: LD_VAR 0 1
21938: PPUSH
21939: CALL_OW 266
21943: PUSH
21944: LD_INT 0
21946: PUSH
21947: LD_INT 1
21949: PUSH
21950: EMPTY
21951: LIST
21952: LIST
21953: IN
21954: NOT
21955: IFFALSE 21959
// exit ;
21957: GO 23593
// if name then
21959: LD_VAR 0 3
21963: IFFALSE 21979
// SetBName ( base_dep , name ) ;
21965: LD_VAR 0 1
21969: PPUSH
21970: LD_VAR 0 3
21974: PPUSH
21975: CALL_OW 500
// base := GetBase ( base_dep ) ;
21979: LD_ADDR_VAR 0 15
21983: PUSH
21984: LD_VAR 0 1
21988: PPUSH
21989: CALL_OW 274
21993: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
21994: LD_ADDR_VAR 0 16
21998: PUSH
21999: LD_VAR 0 1
22003: PPUSH
22004: CALL_OW 255
22008: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22009: LD_ADDR_VAR 0 17
22013: PUSH
22014: LD_VAR 0 1
22018: PPUSH
22019: CALL_OW 248
22023: ST_TO_ADDR
// if sources then
22024: LD_VAR 0 5
22028: IFFALSE 22075
// for i = 1 to 3 do
22030: LD_ADDR_VAR 0 8
22034: PUSH
22035: DOUBLE
22036: LD_INT 1
22038: DEC
22039: ST_TO_ADDR
22040: LD_INT 3
22042: PUSH
22043: FOR_TO
22044: IFFALSE 22073
// AddResourceType ( base , i , sources [ i ] ) ;
22046: LD_VAR 0 15
22050: PPUSH
22051: LD_VAR 0 8
22055: PPUSH
22056: LD_VAR 0 5
22060: PUSH
22061: LD_VAR 0 8
22065: ARRAY
22066: PPUSH
22067: CALL_OW 276
22071: GO 22043
22073: POP
22074: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
22075: LD_ADDR_VAR 0 18
22079: PUSH
22080: LD_VAR 0 15
22084: PPUSH
22085: LD_VAR 0 2
22089: PPUSH
22090: LD_INT 1
22092: PPUSH
22093: CALL 21336 0 3
22097: ST_TO_ADDR
// InitHc ;
22098: CALL_OW 19
// InitUc ;
22102: CALL_OW 18
// uc_side := side ;
22106: LD_ADDR_OWVAR 20
22110: PUSH
22111: LD_VAR 0 16
22115: ST_TO_ADDR
// uc_nation := nation ;
22116: LD_ADDR_OWVAR 21
22120: PUSH
22121: LD_VAR 0 17
22125: ST_TO_ADDR
// if buildings then
22126: LD_VAR 0 18
22130: IFFALSE 23452
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22132: LD_ADDR_VAR 0 19
22136: PUSH
22137: LD_VAR 0 18
22141: PPUSH
22142: LD_INT 2
22144: PUSH
22145: LD_INT 30
22147: PUSH
22148: LD_INT 29
22150: PUSH
22151: EMPTY
22152: LIST
22153: LIST
22154: PUSH
22155: LD_INT 30
22157: PUSH
22158: LD_INT 30
22160: PUSH
22161: EMPTY
22162: LIST
22163: LIST
22164: PUSH
22165: EMPTY
22166: LIST
22167: LIST
22168: LIST
22169: PPUSH
22170: CALL_OW 72
22174: ST_TO_ADDR
// if tmp then
22175: LD_VAR 0 19
22179: IFFALSE 22227
// for i in tmp do
22181: LD_ADDR_VAR 0 8
22185: PUSH
22186: LD_VAR 0 19
22190: PUSH
22191: FOR_IN
22192: IFFALSE 22225
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22194: LD_VAR 0 8
22198: PPUSH
22199: CALL_OW 250
22203: PPUSH
22204: LD_VAR 0 8
22208: PPUSH
22209: CALL_OW 251
22213: PPUSH
22214: LD_VAR 0 16
22218: PPUSH
22219: CALL_OW 441
22223: GO 22191
22225: POP
22226: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22227: LD_VAR 0 18
22231: PPUSH
22232: LD_INT 2
22234: PUSH
22235: LD_INT 30
22237: PUSH
22238: LD_INT 32
22240: PUSH
22241: EMPTY
22242: LIST
22243: LIST
22244: PUSH
22245: LD_INT 30
22247: PUSH
22248: LD_INT 33
22250: PUSH
22251: EMPTY
22252: LIST
22253: LIST
22254: PUSH
22255: EMPTY
22256: LIST
22257: LIST
22258: LIST
22259: PPUSH
22260: CALL_OW 72
22264: IFFALSE 22352
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22266: LD_ADDR_VAR 0 8
22270: PUSH
22271: LD_VAR 0 18
22275: PPUSH
22276: LD_INT 2
22278: PUSH
22279: LD_INT 30
22281: PUSH
22282: LD_INT 32
22284: PUSH
22285: EMPTY
22286: LIST
22287: LIST
22288: PUSH
22289: LD_INT 30
22291: PUSH
22292: LD_INT 33
22294: PUSH
22295: EMPTY
22296: LIST
22297: LIST
22298: PUSH
22299: EMPTY
22300: LIST
22301: LIST
22302: LIST
22303: PPUSH
22304: CALL_OW 72
22308: PUSH
22309: FOR_IN
22310: IFFALSE 22350
// begin if not GetBWeapon ( i ) then
22312: LD_VAR 0 8
22316: PPUSH
22317: CALL_OW 269
22321: NOT
22322: IFFALSE 22348
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22324: LD_VAR 0 8
22328: PPUSH
22329: LD_VAR 0 8
22333: PPUSH
22334: LD_VAR 0 2
22338: PPUSH
22339: CALL 23598 0 2
22343: PPUSH
22344: CALL_OW 431
// end ;
22348: GO 22309
22350: POP
22351: POP
// end ; for i = 1 to personel do
22352: LD_ADDR_VAR 0 8
22356: PUSH
22357: DOUBLE
22358: LD_INT 1
22360: DEC
22361: ST_TO_ADDR
22362: LD_VAR 0 6
22366: PUSH
22367: FOR_TO
22368: IFFALSE 23432
// begin if i > 4 then
22370: LD_VAR 0 8
22374: PUSH
22375: LD_INT 4
22377: GREATER
22378: IFFALSE 22382
// break ;
22380: GO 23432
// case i of 1 :
22382: LD_VAR 0 8
22386: PUSH
22387: LD_INT 1
22389: DOUBLE
22390: EQUAL
22391: IFTRUE 22395
22393: GO 22475
22395: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
22396: LD_ADDR_VAR 0 12
22400: PUSH
22401: LD_VAR 0 18
22405: PPUSH
22406: LD_INT 22
22408: PUSH
22409: LD_VAR 0 16
22413: PUSH
22414: EMPTY
22415: LIST
22416: LIST
22417: PUSH
22418: LD_INT 58
22420: PUSH
22421: EMPTY
22422: LIST
22423: PUSH
22424: LD_INT 2
22426: PUSH
22427: LD_INT 30
22429: PUSH
22430: LD_INT 32
22432: PUSH
22433: EMPTY
22434: LIST
22435: LIST
22436: PUSH
22437: LD_INT 30
22439: PUSH
22440: LD_INT 4
22442: PUSH
22443: EMPTY
22444: LIST
22445: LIST
22446: PUSH
22447: LD_INT 30
22449: PUSH
22450: LD_INT 5
22452: PUSH
22453: EMPTY
22454: LIST
22455: LIST
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: LIST
22461: LIST
22462: PUSH
22463: EMPTY
22464: LIST
22465: LIST
22466: LIST
22467: PPUSH
22468: CALL_OW 72
22472: ST_TO_ADDR
22473: GO 22697
22475: LD_INT 2
22477: DOUBLE
22478: EQUAL
22479: IFTRUE 22483
22481: GO 22545
22483: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22484: LD_ADDR_VAR 0 12
22488: PUSH
22489: LD_VAR 0 18
22493: PPUSH
22494: LD_INT 22
22496: PUSH
22497: LD_VAR 0 16
22501: PUSH
22502: EMPTY
22503: LIST
22504: LIST
22505: PUSH
22506: LD_INT 2
22508: PUSH
22509: LD_INT 30
22511: PUSH
22512: LD_INT 0
22514: PUSH
22515: EMPTY
22516: LIST
22517: LIST
22518: PUSH
22519: LD_INT 30
22521: PUSH
22522: LD_INT 1
22524: PUSH
22525: EMPTY
22526: LIST
22527: LIST
22528: PUSH
22529: EMPTY
22530: LIST
22531: LIST
22532: LIST
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PPUSH
22538: CALL_OW 72
22542: ST_TO_ADDR
22543: GO 22697
22545: LD_INT 3
22547: DOUBLE
22548: EQUAL
22549: IFTRUE 22553
22551: GO 22615
22553: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22554: LD_ADDR_VAR 0 12
22558: PUSH
22559: LD_VAR 0 18
22563: PPUSH
22564: LD_INT 22
22566: PUSH
22567: LD_VAR 0 16
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: LD_INT 2
22578: PUSH
22579: LD_INT 30
22581: PUSH
22582: LD_INT 2
22584: PUSH
22585: EMPTY
22586: LIST
22587: LIST
22588: PUSH
22589: LD_INT 30
22591: PUSH
22592: LD_INT 3
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: PUSH
22599: EMPTY
22600: LIST
22601: LIST
22602: LIST
22603: PUSH
22604: EMPTY
22605: LIST
22606: LIST
22607: PPUSH
22608: CALL_OW 72
22612: ST_TO_ADDR
22613: GO 22697
22615: LD_INT 4
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22696
22623: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22624: LD_ADDR_VAR 0 12
22628: PUSH
22629: LD_VAR 0 18
22633: PPUSH
22634: LD_INT 22
22636: PUSH
22637: LD_VAR 0 16
22641: PUSH
22642: EMPTY
22643: LIST
22644: LIST
22645: PUSH
22646: LD_INT 2
22648: PUSH
22649: LD_INT 30
22651: PUSH
22652: LD_INT 6
22654: PUSH
22655: EMPTY
22656: LIST
22657: LIST
22658: PUSH
22659: LD_INT 30
22661: PUSH
22662: LD_INT 7
22664: PUSH
22665: EMPTY
22666: LIST
22667: LIST
22668: PUSH
22669: LD_INT 30
22671: PUSH
22672: LD_INT 8
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: PUSH
22679: EMPTY
22680: LIST
22681: LIST
22682: LIST
22683: LIST
22684: PUSH
22685: EMPTY
22686: LIST
22687: LIST
22688: PPUSH
22689: CALL_OW 72
22693: ST_TO_ADDR
22694: GO 22697
22696: POP
// if i = 1 then
22697: LD_VAR 0 8
22701: PUSH
22702: LD_INT 1
22704: EQUAL
22705: IFFALSE 22816
// begin tmp := [ ] ;
22707: LD_ADDR_VAR 0 19
22711: PUSH
22712: EMPTY
22713: ST_TO_ADDR
// for j in f do
22714: LD_ADDR_VAR 0 9
22718: PUSH
22719: LD_VAR 0 12
22723: PUSH
22724: FOR_IN
22725: IFFALSE 22798
// if GetBType ( j ) = b_bunker then
22727: LD_VAR 0 9
22731: PPUSH
22732: CALL_OW 266
22736: PUSH
22737: LD_INT 32
22739: EQUAL
22740: IFFALSE 22767
// tmp := Insert ( tmp , 1 , j ) else
22742: LD_ADDR_VAR 0 19
22746: PUSH
22747: LD_VAR 0 19
22751: PPUSH
22752: LD_INT 1
22754: PPUSH
22755: LD_VAR 0 9
22759: PPUSH
22760: CALL_OW 2
22764: ST_TO_ADDR
22765: GO 22796
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22767: LD_ADDR_VAR 0 19
22771: PUSH
22772: LD_VAR 0 19
22776: PPUSH
22777: LD_VAR 0 19
22781: PUSH
22782: LD_INT 1
22784: PLUS
22785: PPUSH
22786: LD_VAR 0 9
22790: PPUSH
22791: CALL_OW 2
22795: ST_TO_ADDR
22796: GO 22724
22798: POP
22799: POP
// if tmp then
22800: LD_VAR 0 19
22804: IFFALSE 22816
// f := tmp ;
22806: LD_ADDR_VAR 0 12
22810: PUSH
22811: LD_VAR 0 19
22815: ST_TO_ADDR
// end ; x := personel [ i ] ;
22816: LD_ADDR_VAR 0 13
22820: PUSH
22821: LD_VAR 0 6
22825: PUSH
22826: LD_VAR 0 8
22830: ARRAY
22831: ST_TO_ADDR
// if x = - 1 then
22832: LD_VAR 0 13
22836: PUSH
22837: LD_INT 1
22839: NEG
22840: EQUAL
22841: IFFALSE 23050
// begin for j in f do
22843: LD_ADDR_VAR 0 9
22847: PUSH
22848: LD_VAR 0 12
22852: PUSH
22853: FOR_IN
22854: IFFALSE 23046
// repeat InitHc ;
22856: CALL_OW 19
// if GetBType ( j ) = b_barracks then
22860: LD_VAR 0 9
22864: PPUSH
22865: CALL_OW 266
22869: PUSH
22870: LD_INT 5
22872: EQUAL
22873: IFFALSE 22943
// begin if UnitsInside ( j ) < 3 then
22875: LD_VAR 0 9
22879: PPUSH
22880: CALL_OW 313
22884: PUSH
22885: LD_INT 3
22887: LESS
22888: IFFALSE 22924
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22890: LD_INT 0
22892: PPUSH
22893: LD_INT 5
22895: PUSH
22896: LD_INT 8
22898: PUSH
22899: LD_INT 9
22901: PUSH
22902: EMPTY
22903: LIST
22904: LIST
22905: LIST
22906: PUSH
22907: LD_VAR 0 17
22911: ARRAY
22912: PPUSH
22913: LD_VAR 0 4
22917: PPUSH
22918: CALL_OW 380
22922: GO 22941
// PrepareHuman ( false , i , skill ) ;
22924: LD_INT 0
22926: PPUSH
22927: LD_VAR 0 8
22931: PPUSH
22932: LD_VAR 0 4
22936: PPUSH
22937: CALL_OW 380
// end else
22941: GO 22960
// PrepareHuman ( false , i , skill ) ;
22943: LD_INT 0
22945: PPUSH
22946: LD_VAR 0 8
22950: PPUSH
22951: LD_VAR 0 4
22955: PPUSH
22956: CALL_OW 380
// un := CreateHuman ;
22960: LD_ADDR_VAR 0 14
22964: PUSH
22965: CALL_OW 44
22969: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22970: LD_ADDR_VAR 0 7
22974: PUSH
22975: LD_VAR 0 7
22979: PPUSH
22980: LD_INT 1
22982: PPUSH
22983: LD_VAR 0 14
22987: PPUSH
22988: CALL_OW 2
22992: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
22993: LD_VAR 0 14
22997: PPUSH
22998: LD_VAR 0 9
23002: PPUSH
23003: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
23007: LD_VAR 0 9
23011: PPUSH
23012: CALL_OW 313
23016: PUSH
23017: LD_INT 6
23019: EQUAL
23020: PUSH
23021: LD_VAR 0 9
23025: PPUSH
23026: CALL_OW 266
23030: PUSH
23031: LD_INT 32
23033: PUSH
23034: LD_INT 31
23036: PUSH
23037: EMPTY
23038: LIST
23039: LIST
23040: IN
23041: OR
23042: IFFALSE 22856
23044: GO 22853
23046: POP
23047: POP
// end else
23048: GO 23430
// for j = 1 to x do
23050: LD_ADDR_VAR 0 9
23054: PUSH
23055: DOUBLE
23056: LD_INT 1
23058: DEC
23059: ST_TO_ADDR
23060: LD_VAR 0 13
23064: PUSH
23065: FOR_TO
23066: IFFALSE 23428
// begin InitHc ;
23068: CALL_OW 19
// if not f then
23072: LD_VAR 0 12
23076: NOT
23077: IFFALSE 23166
// begin PrepareHuman ( false , i , skill ) ;
23079: LD_INT 0
23081: PPUSH
23082: LD_VAR 0 8
23086: PPUSH
23087: LD_VAR 0 4
23091: PPUSH
23092: CALL_OW 380
// un := CreateHuman ;
23096: LD_ADDR_VAR 0 14
23100: PUSH
23101: CALL_OW 44
23105: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23106: LD_ADDR_VAR 0 7
23110: PUSH
23111: LD_VAR 0 7
23115: PPUSH
23116: LD_INT 1
23118: PPUSH
23119: LD_VAR 0 14
23123: PPUSH
23124: CALL_OW 2
23128: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23129: LD_VAR 0 14
23133: PPUSH
23134: LD_VAR 0 1
23138: PPUSH
23139: CALL_OW 250
23143: PPUSH
23144: LD_VAR 0 1
23148: PPUSH
23149: CALL_OW 251
23153: PPUSH
23154: LD_INT 10
23156: PPUSH
23157: LD_INT 0
23159: PPUSH
23160: CALL_OW 50
// continue ;
23164: GO 23065
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23166: LD_VAR 0 12
23170: PUSH
23171: LD_INT 1
23173: ARRAY
23174: PPUSH
23175: CALL_OW 313
23179: PUSH
23180: LD_VAR 0 12
23184: PUSH
23185: LD_INT 1
23187: ARRAY
23188: PPUSH
23189: CALL_OW 266
23193: PUSH
23194: LD_INT 32
23196: PUSH
23197: LD_INT 31
23199: PUSH
23200: EMPTY
23201: LIST
23202: LIST
23203: IN
23204: AND
23205: PUSH
23206: LD_VAR 0 12
23210: PUSH
23211: LD_INT 1
23213: ARRAY
23214: PPUSH
23215: CALL_OW 313
23219: PUSH
23220: LD_INT 6
23222: EQUAL
23223: OR
23224: IFFALSE 23244
// f := Delete ( f , 1 ) ;
23226: LD_ADDR_VAR 0 12
23230: PUSH
23231: LD_VAR 0 12
23235: PPUSH
23236: LD_INT 1
23238: PPUSH
23239: CALL_OW 3
23243: ST_TO_ADDR
// if not f then
23244: LD_VAR 0 12
23248: NOT
23249: IFFALSE 23267
// begin x := x + 2 ;
23251: LD_ADDR_VAR 0 13
23255: PUSH
23256: LD_VAR 0 13
23260: PUSH
23261: LD_INT 2
23263: PLUS
23264: ST_TO_ADDR
// continue ;
23265: GO 23065
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23267: LD_VAR 0 12
23271: PUSH
23272: LD_INT 1
23274: ARRAY
23275: PPUSH
23276: CALL_OW 266
23280: PUSH
23281: LD_INT 5
23283: EQUAL
23284: IFFALSE 23358
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23286: LD_VAR 0 12
23290: PUSH
23291: LD_INT 1
23293: ARRAY
23294: PPUSH
23295: CALL_OW 313
23299: PUSH
23300: LD_INT 3
23302: LESS
23303: IFFALSE 23339
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23305: LD_INT 0
23307: PPUSH
23308: LD_INT 5
23310: PUSH
23311: LD_INT 8
23313: PUSH
23314: LD_INT 9
23316: PUSH
23317: EMPTY
23318: LIST
23319: LIST
23320: LIST
23321: PUSH
23322: LD_VAR 0 17
23326: ARRAY
23327: PPUSH
23328: LD_VAR 0 4
23332: PPUSH
23333: CALL_OW 380
23337: GO 23356
// PrepareHuman ( false , i , skill ) ;
23339: LD_INT 0
23341: PPUSH
23342: LD_VAR 0 8
23346: PPUSH
23347: LD_VAR 0 4
23351: PPUSH
23352: CALL_OW 380
// end else
23356: GO 23375
// PrepareHuman ( false , i , skill ) ;
23358: LD_INT 0
23360: PPUSH
23361: LD_VAR 0 8
23365: PPUSH
23366: LD_VAR 0 4
23370: PPUSH
23371: CALL_OW 380
// un := CreateHuman ;
23375: LD_ADDR_VAR 0 14
23379: PUSH
23380: CALL_OW 44
23384: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23385: LD_ADDR_VAR 0 7
23389: PUSH
23390: LD_VAR 0 7
23394: PPUSH
23395: LD_INT 1
23397: PPUSH
23398: LD_VAR 0 14
23402: PPUSH
23403: CALL_OW 2
23407: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
23408: LD_VAR 0 14
23412: PPUSH
23413: LD_VAR 0 12
23417: PUSH
23418: LD_INT 1
23420: ARRAY
23421: PPUSH
23422: CALL_OW 52
// end ;
23426: GO 23065
23428: POP
23429: POP
// end ;
23430: GO 22367
23432: POP
23433: POP
// result := result ^ buildings ;
23434: LD_ADDR_VAR 0 7
23438: PUSH
23439: LD_VAR 0 7
23443: PUSH
23444: LD_VAR 0 18
23448: ADD
23449: ST_TO_ADDR
// end else
23450: GO 23593
// begin for i = 1 to personel do
23452: LD_ADDR_VAR 0 8
23456: PUSH
23457: DOUBLE
23458: LD_INT 1
23460: DEC
23461: ST_TO_ADDR
23462: LD_VAR 0 6
23466: PUSH
23467: FOR_TO
23468: IFFALSE 23591
// begin if i > 4 then
23470: LD_VAR 0 8
23474: PUSH
23475: LD_INT 4
23477: GREATER
23478: IFFALSE 23482
// break ;
23480: GO 23591
// x := personel [ i ] ;
23482: LD_ADDR_VAR 0 13
23486: PUSH
23487: LD_VAR 0 6
23491: PUSH
23492: LD_VAR 0 8
23496: ARRAY
23497: ST_TO_ADDR
// if x = - 1 then
23498: LD_VAR 0 13
23502: PUSH
23503: LD_INT 1
23505: NEG
23506: EQUAL
23507: IFFALSE 23511
// continue ;
23509: GO 23467
// PrepareHuman ( false , i , skill ) ;
23511: LD_INT 0
23513: PPUSH
23514: LD_VAR 0 8
23518: PPUSH
23519: LD_VAR 0 4
23523: PPUSH
23524: CALL_OW 380
// un := CreateHuman ;
23528: LD_ADDR_VAR 0 14
23532: PUSH
23533: CALL_OW 44
23537: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23538: LD_VAR 0 14
23542: PPUSH
23543: LD_VAR 0 1
23547: PPUSH
23548: CALL_OW 250
23552: PPUSH
23553: LD_VAR 0 1
23557: PPUSH
23558: CALL_OW 251
23562: PPUSH
23563: LD_INT 10
23565: PPUSH
23566: LD_INT 0
23568: PPUSH
23569: CALL_OW 50
// result := result ^ un ;
23573: LD_ADDR_VAR 0 7
23577: PUSH
23578: LD_VAR 0 7
23582: PUSH
23583: LD_VAR 0 14
23587: ADD
23588: ST_TO_ADDR
// end ;
23589: GO 23467
23591: POP
23592: POP
// end ; end ;
23593: LD_VAR 0 7
23597: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23598: LD_INT 0
23600: PPUSH
23601: PPUSH
23602: PPUSH
23603: PPUSH
23604: PPUSH
23605: PPUSH
23606: PPUSH
23607: PPUSH
23608: PPUSH
23609: PPUSH
23610: PPUSH
23611: PPUSH
23612: PPUSH
23613: PPUSH
23614: PPUSH
23615: PPUSH
// result := false ;
23616: LD_ADDR_VAR 0 3
23620: PUSH
23621: LD_INT 0
23623: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23624: LD_VAR 0 1
23628: NOT
23629: PUSH
23630: LD_VAR 0 1
23634: PPUSH
23635: CALL_OW 266
23639: PUSH
23640: LD_INT 32
23642: PUSH
23643: LD_INT 33
23645: PUSH
23646: EMPTY
23647: LIST
23648: LIST
23649: IN
23650: NOT
23651: OR
23652: IFFALSE 23656
// exit ;
23654: GO 24765
// nat := GetNation ( tower ) ;
23656: LD_ADDR_VAR 0 12
23660: PUSH
23661: LD_VAR 0 1
23665: PPUSH
23666: CALL_OW 248
23670: ST_TO_ADDR
// side := GetSide ( tower ) ;
23671: LD_ADDR_VAR 0 16
23675: PUSH
23676: LD_VAR 0 1
23680: PPUSH
23681: CALL_OW 255
23685: ST_TO_ADDR
// x := GetX ( tower ) ;
23686: LD_ADDR_VAR 0 10
23690: PUSH
23691: LD_VAR 0 1
23695: PPUSH
23696: CALL_OW 250
23700: ST_TO_ADDR
// y := GetY ( tower ) ;
23701: LD_ADDR_VAR 0 11
23705: PUSH
23706: LD_VAR 0 1
23710: PPUSH
23711: CALL_OW 251
23715: ST_TO_ADDR
// if not x or not y then
23716: LD_VAR 0 10
23720: NOT
23721: PUSH
23722: LD_VAR 0 11
23726: NOT
23727: OR
23728: IFFALSE 23732
// exit ;
23730: GO 24765
// weapon := 0 ;
23732: LD_ADDR_VAR 0 18
23736: PUSH
23737: LD_INT 0
23739: ST_TO_ADDR
// fac_list := [ ] ;
23740: LD_ADDR_VAR 0 17
23744: PUSH
23745: EMPTY
23746: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
23747: LD_ADDR_VAR 0 6
23751: PUSH
23752: LD_VAR 0 1
23756: PPUSH
23757: CALL_OW 274
23761: PPUSH
23762: LD_VAR 0 2
23766: PPUSH
23767: LD_INT 0
23769: PPUSH
23770: CALL 21336 0 3
23774: PPUSH
23775: LD_INT 30
23777: PUSH
23778: LD_INT 3
23780: PUSH
23781: EMPTY
23782: LIST
23783: LIST
23784: PPUSH
23785: CALL_OW 72
23789: ST_TO_ADDR
// if not factories then
23790: LD_VAR 0 6
23794: NOT
23795: IFFALSE 23799
// exit ;
23797: GO 24765
// for i in factories do
23799: LD_ADDR_VAR 0 8
23803: PUSH
23804: LD_VAR 0 6
23808: PUSH
23809: FOR_IN
23810: IFFALSE 23835
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23812: LD_ADDR_VAR 0 17
23816: PUSH
23817: LD_VAR 0 17
23821: PUSH
23822: LD_VAR 0 8
23826: PPUSH
23827: CALL_OW 478
23831: UNION
23832: ST_TO_ADDR
23833: GO 23809
23835: POP
23836: POP
// if not fac_list then
23837: LD_VAR 0 17
23841: NOT
23842: IFFALSE 23846
// exit ;
23844: GO 24765
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
23846: LD_ADDR_VAR 0 5
23850: PUSH
23851: LD_INT 4
23853: PUSH
23854: LD_INT 5
23856: PUSH
23857: LD_INT 9
23859: PUSH
23860: LD_INT 10
23862: PUSH
23863: LD_INT 6
23865: PUSH
23866: LD_INT 7
23868: PUSH
23869: LD_INT 11
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: LIST
23876: LIST
23877: LIST
23878: LIST
23879: LIST
23880: PUSH
23881: LD_INT 27
23883: PUSH
23884: LD_INT 28
23886: PUSH
23887: LD_INT 26
23889: PUSH
23890: LD_INT 30
23892: PUSH
23893: EMPTY
23894: LIST
23895: LIST
23896: LIST
23897: LIST
23898: PUSH
23899: LD_INT 43
23901: PUSH
23902: LD_INT 44
23904: PUSH
23905: LD_INT 46
23907: PUSH
23908: LD_INT 45
23910: PUSH
23911: LD_INT 47
23913: PUSH
23914: LD_INT 49
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: LIST
23921: LIST
23922: LIST
23923: LIST
23924: PUSH
23925: EMPTY
23926: LIST
23927: LIST
23928: LIST
23929: PUSH
23930: LD_VAR 0 12
23934: ARRAY
23935: ST_TO_ADDR
// list := list isect fac_list ;
23936: LD_ADDR_VAR 0 5
23940: PUSH
23941: LD_VAR 0 5
23945: PUSH
23946: LD_VAR 0 17
23950: ISECT
23951: ST_TO_ADDR
// if not list then
23952: LD_VAR 0 5
23956: NOT
23957: IFFALSE 23961
// exit ;
23959: GO 24765
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
23961: LD_VAR 0 12
23965: PUSH
23966: LD_INT 3
23968: EQUAL
23969: PUSH
23970: LD_INT 49
23972: PUSH
23973: LD_VAR 0 5
23977: IN
23978: AND
23979: PUSH
23980: LD_INT 31
23982: PPUSH
23983: LD_VAR 0 16
23987: PPUSH
23988: CALL_OW 321
23992: PUSH
23993: LD_INT 2
23995: EQUAL
23996: AND
23997: IFFALSE 24057
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
23999: LD_INT 22
24001: PUSH
24002: LD_VAR 0 16
24006: PUSH
24007: EMPTY
24008: LIST
24009: LIST
24010: PUSH
24011: LD_INT 35
24013: PUSH
24014: LD_INT 49
24016: PUSH
24017: EMPTY
24018: LIST
24019: LIST
24020: PUSH
24021: LD_INT 91
24023: PUSH
24024: LD_VAR 0 1
24028: PUSH
24029: LD_INT 10
24031: PUSH
24032: EMPTY
24033: LIST
24034: LIST
24035: LIST
24036: PUSH
24037: EMPTY
24038: LIST
24039: LIST
24040: LIST
24041: PPUSH
24042: CALL_OW 69
24046: NOT
24047: IFFALSE 24057
// weapon := ru_time_lapser ;
24049: LD_ADDR_VAR 0 18
24053: PUSH
24054: LD_INT 49
24056: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24057: LD_VAR 0 12
24061: PUSH
24062: LD_INT 1
24064: PUSH
24065: LD_INT 2
24067: PUSH
24068: EMPTY
24069: LIST
24070: LIST
24071: IN
24072: PUSH
24073: LD_INT 11
24075: PUSH
24076: LD_VAR 0 5
24080: IN
24081: PUSH
24082: LD_INT 30
24084: PUSH
24085: LD_VAR 0 5
24089: IN
24090: OR
24091: AND
24092: PUSH
24093: LD_INT 6
24095: PPUSH
24096: LD_VAR 0 16
24100: PPUSH
24101: CALL_OW 321
24105: PUSH
24106: LD_INT 2
24108: EQUAL
24109: AND
24110: IFFALSE 24275
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24112: LD_INT 22
24114: PUSH
24115: LD_VAR 0 16
24119: PUSH
24120: EMPTY
24121: LIST
24122: LIST
24123: PUSH
24124: LD_INT 2
24126: PUSH
24127: LD_INT 35
24129: PUSH
24130: LD_INT 11
24132: PUSH
24133: EMPTY
24134: LIST
24135: LIST
24136: PUSH
24137: LD_INT 35
24139: PUSH
24140: LD_INT 30
24142: PUSH
24143: EMPTY
24144: LIST
24145: LIST
24146: PUSH
24147: EMPTY
24148: LIST
24149: LIST
24150: LIST
24151: PUSH
24152: LD_INT 91
24154: PUSH
24155: LD_VAR 0 1
24159: PUSH
24160: LD_INT 18
24162: PUSH
24163: EMPTY
24164: LIST
24165: LIST
24166: LIST
24167: PUSH
24168: EMPTY
24169: LIST
24170: LIST
24171: LIST
24172: PPUSH
24173: CALL_OW 69
24177: NOT
24178: PUSH
24179: LD_INT 22
24181: PUSH
24182: LD_VAR 0 16
24186: PUSH
24187: EMPTY
24188: LIST
24189: LIST
24190: PUSH
24191: LD_INT 2
24193: PUSH
24194: LD_INT 30
24196: PUSH
24197: LD_INT 32
24199: PUSH
24200: EMPTY
24201: LIST
24202: LIST
24203: PUSH
24204: LD_INT 30
24206: PUSH
24207: LD_INT 33
24209: PUSH
24210: EMPTY
24211: LIST
24212: LIST
24213: PUSH
24214: EMPTY
24215: LIST
24216: LIST
24217: LIST
24218: PUSH
24219: LD_INT 91
24221: PUSH
24222: LD_VAR 0 1
24226: PUSH
24227: LD_INT 12
24229: PUSH
24230: EMPTY
24231: LIST
24232: LIST
24233: LIST
24234: PUSH
24235: EMPTY
24236: LIST
24237: LIST
24238: LIST
24239: PUSH
24240: EMPTY
24241: LIST
24242: PPUSH
24243: CALL_OW 69
24247: PUSH
24248: LD_INT 2
24250: GREATER
24251: AND
24252: IFFALSE 24275
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24254: LD_ADDR_VAR 0 18
24258: PUSH
24259: LD_INT 11
24261: PUSH
24262: LD_INT 30
24264: PUSH
24265: EMPTY
24266: LIST
24267: LIST
24268: PUSH
24269: LD_VAR 0 12
24273: ARRAY
24274: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24275: LD_VAR 0 18
24279: NOT
24280: PUSH
24281: LD_INT 40
24283: PPUSH
24284: LD_VAR 0 16
24288: PPUSH
24289: CALL_OW 321
24293: PUSH
24294: LD_INT 2
24296: EQUAL
24297: AND
24298: PUSH
24299: LD_INT 7
24301: PUSH
24302: LD_VAR 0 5
24306: IN
24307: PUSH
24308: LD_INT 28
24310: PUSH
24311: LD_VAR 0 5
24315: IN
24316: OR
24317: PUSH
24318: LD_INT 45
24320: PUSH
24321: LD_VAR 0 5
24325: IN
24326: OR
24327: AND
24328: IFFALSE 24582
// begin hex := GetHexInfo ( x , y ) ;
24330: LD_ADDR_VAR 0 4
24334: PUSH
24335: LD_VAR 0 10
24339: PPUSH
24340: LD_VAR 0 11
24344: PPUSH
24345: CALL_OW 546
24349: ST_TO_ADDR
// if hex [ 1 ] then
24350: LD_VAR 0 4
24354: PUSH
24355: LD_INT 1
24357: ARRAY
24358: IFFALSE 24362
// exit ;
24360: GO 24765
// height := hex [ 2 ] ;
24362: LD_ADDR_VAR 0 15
24366: PUSH
24367: LD_VAR 0 4
24371: PUSH
24372: LD_INT 2
24374: ARRAY
24375: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
24376: LD_ADDR_VAR 0 14
24380: PUSH
24381: LD_INT 0
24383: PUSH
24384: LD_INT 2
24386: PUSH
24387: LD_INT 3
24389: PUSH
24390: LD_INT 5
24392: PUSH
24393: EMPTY
24394: LIST
24395: LIST
24396: LIST
24397: LIST
24398: ST_TO_ADDR
// for i in tmp do
24399: LD_ADDR_VAR 0 8
24403: PUSH
24404: LD_VAR 0 14
24408: PUSH
24409: FOR_IN
24410: IFFALSE 24580
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
24412: LD_ADDR_VAR 0 9
24416: PUSH
24417: LD_VAR 0 10
24421: PPUSH
24422: LD_VAR 0 8
24426: PPUSH
24427: LD_INT 5
24429: PPUSH
24430: CALL_OW 272
24434: PUSH
24435: LD_VAR 0 11
24439: PPUSH
24440: LD_VAR 0 8
24444: PPUSH
24445: LD_INT 5
24447: PPUSH
24448: CALL_OW 273
24452: PUSH
24453: EMPTY
24454: LIST
24455: LIST
24456: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24457: LD_VAR 0 9
24461: PUSH
24462: LD_INT 1
24464: ARRAY
24465: PPUSH
24466: LD_VAR 0 9
24470: PUSH
24471: LD_INT 2
24473: ARRAY
24474: PPUSH
24475: CALL_OW 488
24479: IFFALSE 24578
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24481: LD_ADDR_VAR 0 4
24485: PUSH
24486: LD_VAR 0 9
24490: PUSH
24491: LD_INT 1
24493: ARRAY
24494: PPUSH
24495: LD_VAR 0 9
24499: PUSH
24500: LD_INT 2
24502: ARRAY
24503: PPUSH
24504: CALL_OW 546
24508: ST_TO_ADDR
// if hex [ 1 ] then
24509: LD_VAR 0 4
24513: PUSH
24514: LD_INT 1
24516: ARRAY
24517: IFFALSE 24521
// continue ;
24519: GO 24409
// h := hex [ 2 ] ;
24521: LD_ADDR_VAR 0 13
24525: PUSH
24526: LD_VAR 0 4
24530: PUSH
24531: LD_INT 2
24533: ARRAY
24534: ST_TO_ADDR
// if h + 7 < height then
24535: LD_VAR 0 13
24539: PUSH
24540: LD_INT 7
24542: PLUS
24543: PUSH
24544: LD_VAR 0 15
24548: LESS
24549: IFFALSE 24578
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24551: LD_ADDR_VAR 0 18
24555: PUSH
24556: LD_INT 7
24558: PUSH
24559: LD_INT 28
24561: PUSH
24562: LD_INT 45
24564: PUSH
24565: EMPTY
24566: LIST
24567: LIST
24568: LIST
24569: PUSH
24570: LD_VAR 0 12
24574: ARRAY
24575: ST_TO_ADDR
// break ;
24576: GO 24580
// end ; end ; end ;
24578: GO 24409
24580: POP
24581: POP
// end ; if not weapon then
24582: LD_VAR 0 18
24586: NOT
24587: IFFALSE 24647
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24589: LD_ADDR_VAR 0 5
24593: PUSH
24594: LD_VAR 0 5
24598: PUSH
24599: LD_INT 11
24601: PUSH
24602: LD_INT 30
24604: PUSH
24605: LD_INT 49
24607: PUSH
24608: EMPTY
24609: LIST
24610: LIST
24611: LIST
24612: DIFF
24613: ST_TO_ADDR
// if not list then
24614: LD_VAR 0 5
24618: NOT
24619: IFFALSE 24623
// exit ;
24621: GO 24765
// weapon := list [ rand ( 1 , list ) ] ;
24623: LD_ADDR_VAR 0 18
24627: PUSH
24628: LD_VAR 0 5
24632: PUSH
24633: LD_INT 1
24635: PPUSH
24636: LD_VAR 0 5
24640: PPUSH
24641: CALL_OW 12
24645: ARRAY
24646: ST_TO_ADDR
// end ; if weapon then
24647: LD_VAR 0 18
24651: IFFALSE 24765
// begin tmp := CostOfWeapon ( weapon ) ;
24653: LD_ADDR_VAR 0 14
24657: PUSH
24658: LD_VAR 0 18
24662: PPUSH
24663: CALL_OW 451
24667: ST_TO_ADDR
// j := GetBase ( tower ) ;
24668: LD_ADDR_VAR 0 9
24672: PUSH
24673: LD_VAR 0 1
24677: PPUSH
24678: CALL_OW 274
24682: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24683: LD_VAR 0 9
24687: PPUSH
24688: LD_INT 1
24690: PPUSH
24691: CALL_OW 275
24695: PUSH
24696: LD_VAR 0 14
24700: PUSH
24701: LD_INT 1
24703: ARRAY
24704: GREATEREQUAL
24705: PUSH
24706: LD_VAR 0 9
24710: PPUSH
24711: LD_INT 2
24713: PPUSH
24714: CALL_OW 275
24718: PUSH
24719: LD_VAR 0 14
24723: PUSH
24724: LD_INT 2
24726: ARRAY
24727: GREATEREQUAL
24728: AND
24729: PUSH
24730: LD_VAR 0 9
24734: PPUSH
24735: LD_INT 3
24737: PPUSH
24738: CALL_OW 275
24742: PUSH
24743: LD_VAR 0 14
24747: PUSH
24748: LD_INT 3
24750: ARRAY
24751: GREATEREQUAL
24752: AND
24753: IFFALSE 24765
// result := weapon ;
24755: LD_ADDR_VAR 0 3
24759: PUSH
24760: LD_VAR 0 18
24764: ST_TO_ADDR
// end ; end ;
24765: LD_VAR 0 3
24769: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24770: LD_INT 0
24772: PPUSH
24773: PPUSH
// result := true ;
24774: LD_ADDR_VAR 0 3
24778: PUSH
24779: LD_INT 1
24781: ST_TO_ADDR
// if array1 = array2 then
24782: LD_VAR 0 1
24786: PUSH
24787: LD_VAR 0 2
24791: EQUAL
24792: IFFALSE 24852
// begin for i = 1 to array1 do
24794: LD_ADDR_VAR 0 4
24798: PUSH
24799: DOUBLE
24800: LD_INT 1
24802: DEC
24803: ST_TO_ADDR
24804: LD_VAR 0 1
24808: PUSH
24809: FOR_TO
24810: IFFALSE 24848
// if array1 [ i ] <> array2 [ i ] then
24812: LD_VAR 0 1
24816: PUSH
24817: LD_VAR 0 4
24821: ARRAY
24822: PUSH
24823: LD_VAR 0 2
24827: PUSH
24828: LD_VAR 0 4
24832: ARRAY
24833: NONEQUAL
24834: IFFALSE 24846
// begin result := false ;
24836: LD_ADDR_VAR 0 3
24840: PUSH
24841: LD_INT 0
24843: ST_TO_ADDR
// break ;
24844: GO 24848
// end ;
24846: GO 24809
24848: POP
24849: POP
// end else
24850: GO 24860
// result := false ;
24852: LD_ADDR_VAR 0 3
24856: PUSH
24857: LD_INT 0
24859: ST_TO_ADDR
// end ;
24860: LD_VAR 0 3
24864: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
24865: LD_INT 0
24867: PPUSH
24868: PPUSH
// if not array1 or not array2 then
24869: LD_VAR 0 1
24873: NOT
24874: PUSH
24875: LD_VAR 0 2
24879: NOT
24880: OR
24881: IFFALSE 24885
// exit ;
24883: GO 24949
// result := true ;
24885: LD_ADDR_VAR 0 3
24889: PUSH
24890: LD_INT 1
24892: ST_TO_ADDR
// for i = 1 to array1 do
24893: LD_ADDR_VAR 0 4
24897: PUSH
24898: DOUBLE
24899: LD_INT 1
24901: DEC
24902: ST_TO_ADDR
24903: LD_VAR 0 1
24907: PUSH
24908: FOR_TO
24909: IFFALSE 24947
// if array1 [ i ] <> array2 [ i ] then
24911: LD_VAR 0 1
24915: PUSH
24916: LD_VAR 0 4
24920: ARRAY
24921: PUSH
24922: LD_VAR 0 2
24926: PUSH
24927: LD_VAR 0 4
24931: ARRAY
24932: NONEQUAL
24933: IFFALSE 24945
// begin result := false ;
24935: LD_ADDR_VAR 0 3
24939: PUSH
24940: LD_INT 0
24942: ST_TO_ADDR
// break ;
24943: GO 24947
// end ;
24945: GO 24908
24947: POP
24948: POP
// end ;
24949: LD_VAR 0 3
24953: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
24954: LD_INT 0
24956: PPUSH
24957: PPUSH
24958: PPUSH
// pom := GetBase ( fac ) ;
24959: LD_ADDR_VAR 0 5
24963: PUSH
24964: LD_VAR 0 1
24968: PPUSH
24969: CALL_OW 274
24973: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24974: LD_ADDR_VAR 0 4
24978: PUSH
24979: LD_VAR 0 2
24983: PUSH
24984: LD_INT 1
24986: ARRAY
24987: PPUSH
24988: LD_VAR 0 2
24992: PUSH
24993: LD_INT 2
24995: ARRAY
24996: PPUSH
24997: LD_VAR 0 2
25001: PUSH
25002: LD_INT 3
25004: ARRAY
25005: PPUSH
25006: LD_VAR 0 2
25010: PUSH
25011: LD_INT 4
25013: ARRAY
25014: PPUSH
25015: CALL_OW 449
25019: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25020: LD_ADDR_VAR 0 3
25024: PUSH
25025: LD_VAR 0 5
25029: PPUSH
25030: LD_INT 1
25032: PPUSH
25033: CALL_OW 275
25037: PUSH
25038: LD_VAR 0 4
25042: PUSH
25043: LD_INT 1
25045: ARRAY
25046: GREATEREQUAL
25047: PUSH
25048: LD_VAR 0 5
25052: PPUSH
25053: LD_INT 2
25055: PPUSH
25056: CALL_OW 275
25060: PUSH
25061: LD_VAR 0 4
25065: PUSH
25066: LD_INT 2
25068: ARRAY
25069: GREATEREQUAL
25070: AND
25071: PUSH
25072: LD_VAR 0 5
25076: PPUSH
25077: LD_INT 3
25079: PPUSH
25080: CALL_OW 275
25084: PUSH
25085: LD_VAR 0 4
25089: PUSH
25090: LD_INT 3
25092: ARRAY
25093: GREATEREQUAL
25094: AND
25095: ST_TO_ADDR
// end ;
25096: LD_VAR 0 3
25100: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25101: LD_INT 0
25103: PPUSH
25104: PPUSH
25105: PPUSH
25106: PPUSH
// pom := GetBase ( building ) ;
25107: LD_ADDR_VAR 0 3
25111: PUSH
25112: LD_VAR 0 1
25116: PPUSH
25117: CALL_OW 274
25121: ST_TO_ADDR
// if not pom then
25122: LD_VAR 0 3
25126: NOT
25127: IFFALSE 25131
// exit ;
25129: GO 25301
// btype := GetBType ( building ) ;
25131: LD_ADDR_VAR 0 5
25135: PUSH
25136: LD_VAR 0 1
25140: PPUSH
25141: CALL_OW 266
25145: ST_TO_ADDR
// if btype = b_armoury then
25146: LD_VAR 0 5
25150: PUSH
25151: LD_INT 4
25153: EQUAL
25154: IFFALSE 25164
// btype := b_barracks ;
25156: LD_ADDR_VAR 0 5
25160: PUSH
25161: LD_INT 5
25163: ST_TO_ADDR
// if btype = b_depot then
25164: LD_VAR 0 5
25168: PUSH
25169: LD_INT 0
25171: EQUAL
25172: IFFALSE 25182
// btype := b_warehouse ;
25174: LD_ADDR_VAR 0 5
25178: PUSH
25179: LD_INT 1
25181: ST_TO_ADDR
// if btype = b_workshop then
25182: LD_VAR 0 5
25186: PUSH
25187: LD_INT 2
25189: EQUAL
25190: IFFALSE 25200
// btype := b_factory ;
25192: LD_ADDR_VAR 0 5
25196: PUSH
25197: LD_INT 3
25199: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25200: LD_ADDR_VAR 0 4
25204: PUSH
25205: LD_VAR 0 5
25209: PPUSH
25210: LD_VAR 0 1
25214: PPUSH
25215: CALL_OW 248
25219: PPUSH
25220: CALL_OW 450
25224: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25225: LD_ADDR_VAR 0 2
25229: PUSH
25230: LD_VAR 0 3
25234: PPUSH
25235: LD_INT 1
25237: PPUSH
25238: CALL_OW 275
25242: PUSH
25243: LD_VAR 0 4
25247: PUSH
25248: LD_INT 1
25250: ARRAY
25251: GREATEREQUAL
25252: PUSH
25253: LD_VAR 0 3
25257: PPUSH
25258: LD_INT 2
25260: PPUSH
25261: CALL_OW 275
25265: PUSH
25266: LD_VAR 0 4
25270: PUSH
25271: LD_INT 2
25273: ARRAY
25274: GREATEREQUAL
25275: AND
25276: PUSH
25277: LD_VAR 0 3
25281: PPUSH
25282: LD_INT 3
25284: PPUSH
25285: CALL_OW 275
25289: PUSH
25290: LD_VAR 0 4
25294: PUSH
25295: LD_INT 3
25297: ARRAY
25298: GREATEREQUAL
25299: AND
25300: ST_TO_ADDR
// end ;
25301: LD_VAR 0 2
25305: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25306: LD_INT 0
25308: PPUSH
25309: PPUSH
25310: PPUSH
// pom := GetBase ( building ) ;
25311: LD_ADDR_VAR 0 4
25315: PUSH
25316: LD_VAR 0 1
25320: PPUSH
25321: CALL_OW 274
25325: ST_TO_ADDR
// if not pom then
25326: LD_VAR 0 4
25330: NOT
25331: IFFALSE 25335
// exit ;
25333: GO 25436
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25335: LD_ADDR_VAR 0 5
25339: PUSH
25340: LD_VAR 0 2
25344: PPUSH
25345: LD_VAR 0 1
25349: PPUSH
25350: CALL_OW 248
25354: PPUSH
25355: CALL_OW 450
25359: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25360: LD_ADDR_VAR 0 3
25364: PUSH
25365: LD_VAR 0 4
25369: PPUSH
25370: LD_INT 1
25372: PPUSH
25373: CALL_OW 275
25377: PUSH
25378: LD_VAR 0 5
25382: PUSH
25383: LD_INT 1
25385: ARRAY
25386: GREATEREQUAL
25387: PUSH
25388: LD_VAR 0 4
25392: PPUSH
25393: LD_INT 2
25395: PPUSH
25396: CALL_OW 275
25400: PUSH
25401: LD_VAR 0 5
25405: PUSH
25406: LD_INT 2
25408: ARRAY
25409: GREATEREQUAL
25410: AND
25411: PUSH
25412: LD_VAR 0 4
25416: PPUSH
25417: LD_INT 3
25419: PPUSH
25420: CALL_OW 275
25424: PUSH
25425: LD_VAR 0 5
25429: PUSH
25430: LD_INT 3
25432: ARRAY
25433: GREATEREQUAL
25434: AND
25435: ST_TO_ADDR
// end ;
25436: LD_VAR 0 3
25440: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
25441: LD_INT 0
25443: PPUSH
25444: PPUSH
25445: PPUSH
25446: PPUSH
25447: PPUSH
25448: PPUSH
25449: PPUSH
25450: PPUSH
25451: PPUSH
25452: PPUSH
25453: PPUSH
// result := false ;
25454: LD_ADDR_VAR 0 8
25458: PUSH
25459: LD_INT 0
25461: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
25462: LD_VAR 0 5
25466: NOT
25467: PUSH
25468: LD_VAR 0 1
25472: NOT
25473: OR
25474: PUSH
25475: LD_VAR 0 2
25479: NOT
25480: OR
25481: PUSH
25482: LD_VAR 0 3
25486: NOT
25487: OR
25488: IFFALSE 25492
// exit ;
25490: GO 26306
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
25492: LD_ADDR_VAR 0 14
25496: PUSH
25497: LD_VAR 0 1
25501: PPUSH
25502: LD_VAR 0 2
25506: PPUSH
25507: LD_VAR 0 3
25511: PPUSH
25512: LD_VAR 0 4
25516: PPUSH
25517: LD_VAR 0 5
25521: PUSH
25522: LD_INT 1
25524: ARRAY
25525: PPUSH
25526: CALL_OW 248
25530: PPUSH
25531: LD_INT 0
25533: PPUSH
25534: CALL 27543 0 6
25538: ST_TO_ADDR
// if not hexes then
25539: LD_VAR 0 14
25543: NOT
25544: IFFALSE 25548
// exit ;
25546: GO 26306
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25548: LD_ADDR_VAR 0 17
25552: PUSH
25553: LD_VAR 0 5
25557: PPUSH
25558: LD_INT 22
25560: PUSH
25561: LD_VAR 0 13
25565: PPUSH
25566: CALL_OW 255
25570: PUSH
25571: EMPTY
25572: LIST
25573: LIST
25574: PUSH
25575: LD_INT 2
25577: PUSH
25578: LD_INT 30
25580: PUSH
25581: LD_INT 0
25583: PUSH
25584: EMPTY
25585: LIST
25586: LIST
25587: PUSH
25588: LD_INT 30
25590: PUSH
25591: LD_INT 1
25593: PUSH
25594: EMPTY
25595: LIST
25596: LIST
25597: PUSH
25598: EMPTY
25599: LIST
25600: LIST
25601: LIST
25602: PUSH
25603: EMPTY
25604: LIST
25605: LIST
25606: PPUSH
25607: CALL_OW 72
25611: ST_TO_ADDR
// for i = 1 to hexes do
25612: LD_ADDR_VAR 0 9
25616: PUSH
25617: DOUBLE
25618: LD_INT 1
25620: DEC
25621: ST_TO_ADDR
25622: LD_VAR 0 14
25626: PUSH
25627: FOR_TO
25628: IFFALSE 26304
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25630: LD_ADDR_VAR 0 13
25634: PUSH
25635: LD_VAR 0 14
25639: PUSH
25640: LD_VAR 0 9
25644: ARRAY
25645: PUSH
25646: LD_INT 1
25648: ARRAY
25649: PPUSH
25650: LD_VAR 0 14
25654: PUSH
25655: LD_VAR 0 9
25659: ARRAY
25660: PUSH
25661: LD_INT 2
25663: ARRAY
25664: PPUSH
25665: CALL_OW 428
25669: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25670: LD_VAR 0 14
25674: PUSH
25675: LD_VAR 0 9
25679: ARRAY
25680: PUSH
25681: LD_INT 1
25683: ARRAY
25684: PPUSH
25685: LD_VAR 0 14
25689: PUSH
25690: LD_VAR 0 9
25694: ARRAY
25695: PUSH
25696: LD_INT 2
25698: ARRAY
25699: PPUSH
25700: CALL_OW 351
25704: PUSH
25705: LD_VAR 0 14
25709: PUSH
25710: LD_VAR 0 9
25714: ARRAY
25715: PUSH
25716: LD_INT 1
25718: ARRAY
25719: PPUSH
25720: LD_VAR 0 14
25724: PUSH
25725: LD_VAR 0 9
25729: ARRAY
25730: PUSH
25731: LD_INT 2
25733: ARRAY
25734: PPUSH
25735: CALL_OW 488
25739: NOT
25740: OR
25741: PUSH
25742: LD_VAR 0 13
25746: PPUSH
25747: CALL_OW 247
25751: PUSH
25752: LD_INT 3
25754: EQUAL
25755: OR
25756: IFFALSE 25762
// exit ;
25758: POP
25759: POP
25760: GO 26306
// if not tmp then
25762: LD_VAR 0 13
25766: NOT
25767: IFFALSE 25771
// continue ;
25769: GO 25627
// result := true ;
25771: LD_ADDR_VAR 0 8
25775: PUSH
25776: LD_INT 1
25778: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
25779: LD_VAR 0 6
25783: PUSH
25784: LD_VAR 0 13
25788: PPUSH
25789: CALL_OW 247
25793: PUSH
25794: LD_INT 2
25796: EQUAL
25797: AND
25798: PUSH
25799: LD_VAR 0 13
25803: PPUSH
25804: CALL_OW 263
25808: PUSH
25809: LD_INT 1
25811: EQUAL
25812: AND
25813: IFFALSE 25977
// begin if IsDrivenBy ( tmp ) then
25815: LD_VAR 0 13
25819: PPUSH
25820: CALL_OW 311
25824: IFFALSE 25828
// continue ;
25826: GO 25627
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
25828: LD_VAR 0 6
25832: PPUSH
25833: LD_INT 3
25835: PUSH
25836: LD_INT 60
25838: PUSH
25839: EMPTY
25840: LIST
25841: PUSH
25842: EMPTY
25843: LIST
25844: LIST
25845: PUSH
25846: LD_INT 3
25848: PUSH
25849: LD_INT 55
25851: PUSH
25852: EMPTY
25853: LIST
25854: PUSH
25855: EMPTY
25856: LIST
25857: LIST
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: PPUSH
25863: CALL_OW 72
25867: IFFALSE 25975
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
25869: LD_ADDR_VAR 0 18
25873: PUSH
25874: LD_VAR 0 6
25878: PPUSH
25879: LD_INT 3
25881: PUSH
25882: LD_INT 60
25884: PUSH
25885: EMPTY
25886: LIST
25887: PUSH
25888: EMPTY
25889: LIST
25890: LIST
25891: PUSH
25892: LD_INT 3
25894: PUSH
25895: LD_INT 55
25897: PUSH
25898: EMPTY
25899: LIST
25900: PUSH
25901: EMPTY
25902: LIST
25903: LIST
25904: PUSH
25905: EMPTY
25906: LIST
25907: LIST
25908: PPUSH
25909: CALL_OW 72
25913: PUSH
25914: LD_INT 1
25916: ARRAY
25917: ST_TO_ADDR
// if IsInUnit ( driver ) then
25918: LD_VAR 0 18
25922: PPUSH
25923: CALL_OW 310
25927: IFFALSE 25938
// ComExit ( driver ) ;
25929: LD_VAR 0 18
25933: PPUSH
25934: CALL 50727 0 1
// AddComEnterUnit ( driver , tmp ) ;
25938: LD_VAR 0 18
25942: PPUSH
25943: LD_VAR 0 13
25947: PPUSH
25948: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
25952: LD_VAR 0 18
25956: PPUSH
25957: LD_VAR 0 7
25961: PPUSH
25962: CALL_OW 173
// AddComExitVehicle ( driver ) ;
25966: LD_VAR 0 18
25970: PPUSH
25971: CALL_OW 181
// end ; continue ;
25975: GO 25627
// end ; if not cleaners or not tmp in cleaners then
25977: LD_VAR 0 6
25981: NOT
25982: PUSH
25983: LD_VAR 0 13
25987: PUSH
25988: LD_VAR 0 6
25992: IN
25993: NOT
25994: OR
25995: IFFALSE 26302
// begin if dep then
25997: LD_VAR 0 17
26001: IFFALSE 26137
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
26003: LD_ADDR_VAR 0 16
26007: PUSH
26008: LD_VAR 0 17
26012: PUSH
26013: LD_INT 1
26015: ARRAY
26016: PPUSH
26017: CALL_OW 250
26021: PPUSH
26022: LD_VAR 0 17
26026: PUSH
26027: LD_INT 1
26029: ARRAY
26030: PPUSH
26031: CALL_OW 254
26035: PPUSH
26036: LD_INT 5
26038: PPUSH
26039: CALL_OW 272
26043: PUSH
26044: LD_VAR 0 17
26048: PUSH
26049: LD_INT 1
26051: ARRAY
26052: PPUSH
26053: CALL_OW 251
26057: PPUSH
26058: LD_VAR 0 17
26062: PUSH
26063: LD_INT 1
26065: ARRAY
26066: PPUSH
26067: CALL_OW 254
26071: PPUSH
26072: LD_INT 5
26074: PPUSH
26075: CALL_OW 273
26079: PUSH
26080: EMPTY
26081: LIST
26082: LIST
26083: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26084: LD_VAR 0 16
26088: PUSH
26089: LD_INT 1
26091: ARRAY
26092: PPUSH
26093: LD_VAR 0 16
26097: PUSH
26098: LD_INT 2
26100: ARRAY
26101: PPUSH
26102: CALL_OW 488
26106: IFFALSE 26137
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26108: LD_VAR 0 13
26112: PPUSH
26113: LD_VAR 0 16
26117: PUSH
26118: LD_INT 1
26120: ARRAY
26121: PPUSH
26122: LD_VAR 0 16
26126: PUSH
26127: LD_INT 2
26129: ARRAY
26130: PPUSH
26131: CALL_OW 111
// continue ;
26135: GO 25627
// end ; end ; r := GetDir ( tmp ) ;
26137: LD_ADDR_VAR 0 15
26141: PUSH
26142: LD_VAR 0 13
26146: PPUSH
26147: CALL_OW 254
26151: ST_TO_ADDR
// if r = 5 then
26152: LD_VAR 0 15
26156: PUSH
26157: LD_INT 5
26159: EQUAL
26160: IFFALSE 26170
// r := 0 ;
26162: LD_ADDR_VAR 0 15
26166: PUSH
26167: LD_INT 0
26169: ST_TO_ADDR
// for j = r to 5 do
26170: LD_ADDR_VAR 0 10
26174: PUSH
26175: DOUBLE
26176: LD_VAR 0 15
26180: DEC
26181: ST_TO_ADDR
26182: LD_INT 5
26184: PUSH
26185: FOR_TO
26186: IFFALSE 26300
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26188: LD_ADDR_VAR 0 11
26192: PUSH
26193: LD_VAR 0 13
26197: PPUSH
26198: CALL_OW 250
26202: PPUSH
26203: LD_VAR 0 10
26207: PPUSH
26208: LD_INT 2
26210: PPUSH
26211: CALL_OW 272
26215: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26216: LD_ADDR_VAR 0 12
26220: PUSH
26221: LD_VAR 0 13
26225: PPUSH
26226: CALL_OW 251
26230: PPUSH
26231: LD_VAR 0 10
26235: PPUSH
26236: LD_INT 2
26238: PPUSH
26239: CALL_OW 273
26243: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26244: LD_VAR 0 11
26248: PPUSH
26249: LD_VAR 0 12
26253: PPUSH
26254: CALL_OW 488
26258: PUSH
26259: LD_VAR 0 11
26263: PPUSH
26264: LD_VAR 0 12
26268: PPUSH
26269: CALL_OW 428
26273: NOT
26274: AND
26275: IFFALSE 26298
// begin ComMoveXY ( tmp , _x , _y ) ;
26277: LD_VAR 0 13
26281: PPUSH
26282: LD_VAR 0 11
26286: PPUSH
26287: LD_VAR 0 12
26291: PPUSH
26292: CALL_OW 111
// break ;
26296: GO 26300
// end ; end ;
26298: GO 26185
26300: POP
26301: POP
// end ; end ;
26302: GO 25627
26304: POP
26305: POP
// end ;
26306: LD_VAR 0 8
26310: RET
// export function BuildingTechInvented ( side , btype ) ; begin
26311: LD_INT 0
26313: PPUSH
// result := true ;
26314: LD_ADDR_VAR 0 3
26318: PUSH
26319: LD_INT 1
26321: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
26322: LD_VAR 0 2
26326: PUSH
26327: LD_INT 24
26329: DOUBLE
26330: EQUAL
26331: IFTRUE 26341
26333: LD_INT 33
26335: DOUBLE
26336: EQUAL
26337: IFTRUE 26341
26339: GO 26366
26341: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
26342: LD_ADDR_VAR 0 3
26346: PUSH
26347: LD_INT 32
26349: PPUSH
26350: LD_VAR 0 1
26354: PPUSH
26355: CALL_OW 321
26359: PUSH
26360: LD_INT 2
26362: EQUAL
26363: ST_TO_ADDR
26364: GO 26686
26366: LD_INT 20
26368: DOUBLE
26369: EQUAL
26370: IFTRUE 26374
26372: GO 26399
26374: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
26375: LD_ADDR_VAR 0 3
26379: PUSH
26380: LD_INT 6
26382: PPUSH
26383: LD_VAR 0 1
26387: PPUSH
26388: CALL_OW 321
26392: PUSH
26393: LD_INT 2
26395: EQUAL
26396: ST_TO_ADDR
26397: GO 26686
26399: LD_INT 22
26401: DOUBLE
26402: EQUAL
26403: IFTRUE 26413
26405: LD_INT 36
26407: DOUBLE
26408: EQUAL
26409: IFTRUE 26413
26411: GO 26438
26413: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
26414: LD_ADDR_VAR 0 3
26418: PUSH
26419: LD_INT 15
26421: PPUSH
26422: LD_VAR 0 1
26426: PPUSH
26427: CALL_OW 321
26431: PUSH
26432: LD_INT 2
26434: EQUAL
26435: ST_TO_ADDR
26436: GO 26686
26438: LD_INT 30
26440: DOUBLE
26441: EQUAL
26442: IFTRUE 26446
26444: GO 26471
26446: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
26447: LD_ADDR_VAR 0 3
26451: PUSH
26452: LD_INT 20
26454: PPUSH
26455: LD_VAR 0 1
26459: PPUSH
26460: CALL_OW 321
26464: PUSH
26465: LD_INT 2
26467: EQUAL
26468: ST_TO_ADDR
26469: GO 26686
26471: LD_INT 28
26473: DOUBLE
26474: EQUAL
26475: IFTRUE 26485
26477: LD_INT 21
26479: DOUBLE
26480: EQUAL
26481: IFTRUE 26485
26483: GO 26510
26485: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
26486: LD_ADDR_VAR 0 3
26490: PUSH
26491: LD_INT 21
26493: PPUSH
26494: LD_VAR 0 1
26498: PPUSH
26499: CALL_OW 321
26503: PUSH
26504: LD_INT 2
26506: EQUAL
26507: ST_TO_ADDR
26508: GO 26686
26510: LD_INT 16
26512: DOUBLE
26513: EQUAL
26514: IFTRUE 26518
26516: GO 26545
26518: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
26519: LD_ADDR_VAR 0 3
26523: PUSH
26524: LD_EXP 60
26528: PPUSH
26529: LD_VAR 0 1
26533: PPUSH
26534: CALL_OW 321
26538: PUSH
26539: LD_INT 2
26541: EQUAL
26542: ST_TO_ADDR
26543: GO 26686
26545: LD_INT 19
26547: DOUBLE
26548: EQUAL
26549: IFTRUE 26559
26551: LD_INT 23
26553: DOUBLE
26554: EQUAL
26555: IFTRUE 26559
26557: GO 26586
26559: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
26560: LD_ADDR_VAR 0 3
26564: PUSH
26565: LD_EXP 59
26569: PPUSH
26570: LD_VAR 0 1
26574: PPUSH
26575: CALL_OW 321
26579: PUSH
26580: LD_INT 2
26582: EQUAL
26583: ST_TO_ADDR
26584: GO 26686
26586: LD_INT 17
26588: DOUBLE
26589: EQUAL
26590: IFTRUE 26594
26592: GO 26619
26594: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
26595: LD_ADDR_VAR 0 3
26599: PUSH
26600: LD_INT 39
26602: PPUSH
26603: LD_VAR 0 1
26607: PPUSH
26608: CALL_OW 321
26612: PUSH
26613: LD_INT 2
26615: EQUAL
26616: ST_TO_ADDR
26617: GO 26686
26619: LD_INT 18
26621: DOUBLE
26622: EQUAL
26623: IFTRUE 26627
26625: GO 26652
26627: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
26628: LD_ADDR_VAR 0 3
26632: PUSH
26633: LD_INT 40
26635: PPUSH
26636: LD_VAR 0 1
26640: PPUSH
26641: CALL_OW 321
26645: PUSH
26646: LD_INT 2
26648: EQUAL
26649: ST_TO_ADDR
26650: GO 26686
26652: LD_INT 27
26654: DOUBLE
26655: EQUAL
26656: IFTRUE 26660
26658: GO 26685
26660: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
26661: LD_ADDR_VAR 0 3
26665: PUSH
26666: LD_INT 35
26668: PPUSH
26669: LD_VAR 0 1
26673: PPUSH
26674: CALL_OW 321
26678: PUSH
26679: LD_INT 2
26681: EQUAL
26682: ST_TO_ADDR
26683: GO 26686
26685: POP
// end ;
26686: LD_VAR 0 3
26690: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
26691: LD_INT 0
26693: PPUSH
26694: PPUSH
26695: PPUSH
26696: PPUSH
26697: PPUSH
26698: PPUSH
26699: PPUSH
26700: PPUSH
26701: PPUSH
26702: PPUSH
26703: PPUSH
// result := false ;
26704: LD_ADDR_VAR 0 6
26708: PUSH
26709: LD_INT 0
26711: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26712: LD_VAR 0 1
26716: NOT
26717: PUSH
26718: LD_VAR 0 1
26722: PPUSH
26723: CALL_OW 266
26727: PUSH
26728: LD_INT 0
26730: PUSH
26731: LD_INT 1
26733: PUSH
26734: EMPTY
26735: LIST
26736: LIST
26737: IN
26738: NOT
26739: OR
26740: PUSH
26741: LD_VAR 0 2
26745: NOT
26746: OR
26747: PUSH
26748: LD_VAR 0 5
26752: PUSH
26753: LD_INT 0
26755: PUSH
26756: LD_INT 1
26758: PUSH
26759: LD_INT 2
26761: PUSH
26762: LD_INT 3
26764: PUSH
26765: LD_INT 4
26767: PUSH
26768: LD_INT 5
26770: PUSH
26771: EMPTY
26772: LIST
26773: LIST
26774: LIST
26775: LIST
26776: LIST
26777: LIST
26778: IN
26779: NOT
26780: OR
26781: PUSH
26782: LD_VAR 0 3
26786: PPUSH
26787: LD_VAR 0 4
26791: PPUSH
26792: CALL_OW 488
26796: NOT
26797: OR
26798: IFFALSE 26802
// exit ;
26800: GO 27538
// side := GetSide ( depot ) ;
26802: LD_ADDR_VAR 0 9
26806: PUSH
26807: LD_VAR 0 1
26811: PPUSH
26812: CALL_OW 255
26816: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
26817: LD_VAR 0 9
26821: PPUSH
26822: LD_VAR 0 2
26826: PPUSH
26827: CALL 26311 0 2
26831: NOT
26832: IFFALSE 26836
// exit ;
26834: GO 27538
// pom := GetBase ( depot ) ;
26836: LD_ADDR_VAR 0 10
26840: PUSH
26841: LD_VAR 0 1
26845: PPUSH
26846: CALL_OW 274
26850: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26851: LD_ADDR_VAR 0 11
26855: PUSH
26856: LD_VAR 0 2
26860: PPUSH
26861: LD_VAR 0 1
26865: PPUSH
26866: CALL_OW 248
26870: PPUSH
26871: CALL_OW 450
26875: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26876: LD_VAR 0 10
26880: PPUSH
26881: LD_INT 1
26883: PPUSH
26884: CALL_OW 275
26888: PUSH
26889: LD_VAR 0 11
26893: PUSH
26894: LD_INT 1
26896: ARRAY
26897: GREATEREQUAL
26898: PUSH
26899: LD_VAR 0 10
26903: PPUSH
26904: LD_INT 2
26906: PPUSH
26907: CALL_OW 275
26911: PUSH
26912: LD_VAR 0 11
26916: PUSH
26917: LD_INT 2
26919: ARRAY
26920: GREATEREQUAL
26921: AND
26922: PUSH
26923: LD_VAR 0 10
26927: PPUSH
26928: LD_INT 3
26930: PPUSH
26931: CALL_OW 275
26935: PUSH
26936: LD_VAR 0 11
26940: PUSH
26941: LD_INT 3
26943: ARRAY
26944: GREATEREQUAL
26945: AND
26946: NOT
26947: IFFALSE 26951
// exit ;
26949: GO 27538
// if GetBType ( depot ) = b_depot then
26951: LD_VAR 0 1
26955: PPUSH
26956: CALL_OW 266
26960: PUSH
26961: LD_INT 0
26963: EQUAL
26964: IFFALSE 26976
// dist := 28 else
26966: LD_ADDR_VAR 0 14
26970: PUSH
26971: LD_INT 28
26973: ST_TO_ADDR
26974: GO 26984
// dist := 36 ;
26976: LD_ADDR_VAR 0 14
26980: PUSH
26981: LD_INT 36
26983: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26984: LD_VAR 0 1
26988: PPUSH
26989: LD_VAR 0 3
26993: PPUSH
26994: LD_VAR 0 4
26998: PPUSH
26999: CALL_OW 297
27003: PUSH
27004: LD_VAR 0 14
27008: GREATER
27009: IFFALSE 27013
// exit ;
27011: GO 27538
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
27013: LD_ADDR_VAR 0 12
27017: PUSH
27018: LD_VAR 0 2
27022: PPUSH
27023: LD_VAR 0 3
27027: PPUSH
27028: LD_VAR 0 4
27032: PPUSH
27033: LD_VAR 0 5
27037: PPUSH
27038: LD_VAR 0 1
27042: PPUSH
27043: CALL_OW 248
27047: PPUSH
27048: LD_INT 0
27050: PPUSH
27051: CALL 27543 0 6
27055: ST_TO_ADDR
// if not hexes then
27056: LD_VAR 0 12
27060: NOT
27061: IFFALSE 27065
// exit ;
27063: GO 27538
// hex := GetHexInfo ( x , y ) ;
27065: LD_ADDR_VAR 0 15
27069: PUSH
27070: LD_VAR 0 3
27074: PPUSH
27075: LD_VAR 0 4
27079: PPUSH
27080: CALL_OW 546
27084: ST_TO_ADDR
// if hex [ 1 ] then
27085: LD_VAR 0 15
27089: PUSH
27090: LD_INT 1
27092: ARRAY
27093: IFFALSE 27097
// exit ;
27095: GO 27538
// height := hex [ 2 ] ;
27097: LD_ADDR_VAR 0 13
27101: PUSH
27102: LD_VAR 0 15
27106: PUSH
27107: LD_INT 2
27109: ARRAY
27110: ST_TO_ADDR
// for i = 1 to hexes do
27111: LD_ADDR_VAR 0 7
27115: PUSH
27116: DOUBLE
27117: LD_INT 1
27119: DEC
27120: ST_TO_ADDR
27121: LD_VAR 0 12
27125: PUSH
27126: FOR_TO
27127: IFFALSE 27457
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27129: LD_VAR 0 12
27133: PUSH
27134: LD_VAR 0 7
27138: ARRAY
27139: PUSH
27140: LD_INT 1
27142: ARRAY
27143: PPUSH
27144: LD_VAR 0 12
27148: PUSH
27149: LD_VAR 0 7
27153: ARRAY
27154: PUSH
27155: LD_INT 2
27157: ARRAY
27158: PPUSH
27159: CALL_OW 488
27163: NOT
27164: PUSH
27165: LD_VAR 0 12
27169: PUSH
27170: LD_VAR 0 7
27174: ARRAY
27175: PUSH
27176: LD_INT 1
27178: ARRAY
27179: PPUSH
27180: LD_VAR 0 12
27184: PUSH
27185: LD_VAR 0 7
27189: ARRAY
27190: PUSH
27191: LD_INT 2
27193: ARRAY
27194: PPUSH
27195: CALL_OW 428
27199: PUSH
27200: LD_INT 0
27202: GREATER
27203: OR
27204: PUSH
27205: LD_VAR 0 12
27209: PUSH
27210: LD_VAR 0 7
27214: ARRAY
27215: PUSH
27216: LD_INT 1
27218: ARRAY
27219: PPUSH
27220: LD_VAR 0 12
27224: PUSH
27225: LD_VAR 0 7
27229: ARRAY
27230: PUSH
27231: LD_INT 2
27233: ARRAY
27234: PPUSH
27235: CALL_OW 351
27239: OR
27240: IFFALSE 27246
// exit ;
27242: POP
27243: POP
27244: GO 27538
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27246: LD_ADDR_VAR 0 8
27250: PUSH
27251: LD_VAR 0 12
27255: PUSH
27256: LD_VAR 0 7
27260: ARRAY
27261: PUSH
27262: LD_INT 1
27264: ARRAY
27265: PPUSH
27266: LD_VAR 0 12
27270: PUSH
27271: LD_VAR 0 7
27275: ARRAY
27276: PUSH
27277: LD_INT 2
27279: ARRAY
27280: PPUSH
27281: CALL_OW 546
27285: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27286: LD_VAR 0 8
27290: PUSH
27291: LD_INT 1
27293: ARRAY
27294: PUSH
27295: LD_VAR 0 8
27299: PUSH
27300: LD_INT 2
27302: ARRAY
27303: PUSH
27304: LD_VAR 0 13
27308: PUSH
27309: LD_INT 2
27311: PLUS
27312: GREATER
27313: OR
27314: PUSH
27315: LD_VAR 0 8
27319: PUSH
27320: LD_INT 2
27322: ARRAY
27323: PUSH
27324: LD_VAR 0 13
27328: PUSH
27329: LD_INT 2
27331: MINUS
27332: LESS
27333: OR
27334: PUSH
27335: LD_VAR 0 8
27339: PUSH
27340: LD_INT 3
27342: ARRAY
27343: PUSH
27344: LD_INT 0
27346: PUSH
27347: LD_INT 8
27349: PUSH
27350: LD_INT 9
27352: PUSH
27353: LD_INT 10
27355: PUSH
27356: LD_INT 11
27358: PUSH
27359: LD_INT 12
27361: PUSH
27362: LD_INT 13
27364: PUSH
27365: LD_INT 16
27367: PUSH
27368: LD_INT 17
27370: PUSH
27371: LD_INT 18
27373: PUSH
27374: LD_INT 19
27376: PUSH
27377: LD_INT 20
27379: PUSH
27380: LD_INT 21
27382: PUSH
27383: EMPTY
27384: LIST
27385: LIST
27386: LIST
27387: LIST
27388: LIST
27389: LIST
27390: LIST
27391: LIST
27392: LIST
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: IN
27398: NOT
27399: OR
27400: PUSH
27401: LD_VAR 0 8
27405: PUSH
27406: LD_INT 5
27408: ARRAY
27409: NOT
27410: OR
27411: PUSH
27412: LD_VAR 0 8
27416: PUSH
27417: LD_INT 6
27419: ARRAY
27420: PUSH
27421: LD_INT 1
27423: PUSH
27424: LD_INT 2
27426: PUSH
27427: LD_INT 7
27429: PUSH
27430: LD_INT 9
27432: PUSH
27433: LD_INT 10
27435: PUSH
27436: LD_INT 11
27438: PUSH
27439: EMPTY
27440: LIST
27441: LIST
27442: LIST
27443: LIST
27444: LIST
27445: LIST
27446: IN
27447: NOT
27448: OR
27449: IFFALSE 27455
// exit ;
27451: POP
27452: POP
27453: GO 27538
// end ;
27455: GO 27126
27457: POP
27458: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27459: LD_VAR 0 9
27463: PPUSH
27464: LD_VAR 0 3
27468: PPUSH
27469: LD_VAR 0 4
27473: PPUSH
27474: LD_INT 20
27476: PPUSH
27477: CALL 19484 0 4
27481: PUSH
27482: LD_INT 4
27484: ARRAY
27485: IFFALSE 27489
// exit ;
27487: GO 27538
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27489: LD_VAR 0 2
27493: PUSH
27494: LD_INT 29
27496: PUSH
27497: LD_INT 30
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: IN
27504: PUSH
27505: LD_VAR 0 3
27509: PPUSH
27510: LD_VAR 0 4
27514: PPUSH
27515: LD_VAR 0 9
27519: PPUSH
27520: CALL_OW 440
27524: NOT
27525: AND
27526: IFFALSE 27530
// exit ;
27528: GO 27538
// result := true ;
27530: LD_ADDR_VAR 0 6
27534: PUSH
27535: LD_INT 1
27537: ST_TO_ADDR
// end ;
27538: LD_VAR 0 6
27542: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
27543: LD_INT 0
27545: PPUSH
27546: PPUSH
27547: PPUSH
27548: PPUSH
27549: PPUSH
27550: PPUSH
27551: PPUSH
27552: PPUSH
27553: PPUSH
27554: PPUSH
27555: PPUSH
27556: PPUSH
27557: PPUSH
27558: PPUSH
27559: PPUSH
27560: PPUSH
27561: PPUSH
27562: PPUSH
27563: PPUSH
27564: PPUSH
27565: PPUSH
27566: PPUSH
27567: PPUSH
27568: PPUSH
27569: PPUSH
27570: PPUSH
27571: PPUSH
27572: PPUSH
27573: PPUSH
27574: PPUSH
27575: PPUSH
27576: PPUSH
27577: PPUSH
27578: PPUSH
27579: PPUSH
27580: PPUSH
27581: PPUSH
27582: PPUSH
27583: PPUSH
27584: PPUSH
27585: PPUSH
27586: PPUSH
27587: PPUSH
27588: PPUSH
27589: PPUSH
27590: PPUSH
27591: PPUSH
27592: PPUSH
27593: PPUSH
27594: PPUSH
27595: PPUSH
27596: PPUSH
27597: PPUSH
27598: PPUSH
27599: PPUSH
27600: PPUSH
27601: PPUSH
27602: PPUSH
// result = [ ] ;
27603: LD_ADDR_VAR 0 7
27607: PUSH
27608: EMPTY
27609: ST_TO_ADDR
// temp_list = [ ] ;
27610: LD_ADDR_VAR 0 9
27614: PUSH
27615: EMPTY
27616: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27617: LD_VAR 0 4
27621: PUSH
27622: LD_INT 0
27624: PUSH
27625: LD_INT 1
27627: PUSH
27628: LD_INT 2
27630: PUSH
27631: LD_INT 3
27633: PUSH
27634: LD_INT 4
27636: PUSH
27637: LD_INT 5
27639: PUSH
27640: EMPTY
27641: LIST
27642: LIST
27643: LIST
27644: LIST
27645: LIST
27646: LIST
27647: IN
27648: NOT
27649: PUSH
27650: LD_VAR 0 1
27654: PUSH
27655: LD_INT 0
27657: PUSH
27658: LD_INT 1
27660: PUSH
27661: EMPTY
27662: LIST
27663: LIST
27664: IN
27665: PUSH
27666: LD_VAR 0 5
27670: PUSH
27671: LD_INT 1
27673: PUSH
27674: LD_INT 2
27676: PUSH
27677: LD_INT 3
27679: PUSH
27680: EMPTY
27681: LIST
27682: LIST
27683: LIST
27684: IN
27685: NOT
27686: AND
27687: OR
27688: IFFALSE 27692
// exit ;
27690: GO 46083
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27692: LD_VAR 0 1
27696: PUSH
27697: LD_INT 6
27699: PUSH
27700: LD_INT 7
27702: PUSH
27703: LD_INT 8
27705: PUSH
27706: LD_INT 13
27708: PUSH
27709: LD_INT 12
27711: PUSH
27712: LD_INT 15
27714: PUSH
27715: LD_INT 11
27717: PUSH
27718: LD_INT 14
27720: PUSH
27721: LD_INT 10
27723: PUSH
27724: EMPTY
27725: LIST
27726: LIST
27727: LIST
27728: LIST
27729: LIST
27730: LIST
27731: LIST
27732: LIST
27733: LIST
27734: IN
27735: IFFALSE 27745
// btype = b_lab ;
27737: LD_ADDR_VAR 0 1
27741: PUSH
27742: LD_INT 6
27744: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27745: LD_VAR 0 6
27749: PUSH
27750: LD_INT 0
27752: PUSH
27753: LD_INT 1
27755: PUSH
27756: LD_INT 2
27758: PUSH
27759: EMPTY
27760: LIST
27761: LIST
27762: LIST
27763: IN
27764: NOT
27765: PUSH
27766: LD_VAR 0 1
27770: PUSH
27771: LD_INT 0
27773: PUSH
27774: LD_INT 1
27776: PUSH
27777: LD_INT 2
27779: PUSH
27780: LD_INT 3
27782: PUSH
27783: LD_INT 6
27785: PUSH
27786: LD_INT 36
27788: PUSH
27789: LD_INT 4
27791: PUSH
27792: LD_INT 5
27794: PUSH
27795: LD_INT 31
27797: PUSH
27798: LD_INT 32
27800: PUSH
27801: LD_INT 33
27803: PUSH
27804: EMPTY
27805: LIST
27806: LIST
27807: LIST
27808: LIST
27809: LIST
27810: LIST
27811: LIST
27812: LIST
27813: LIST
27814: LIST
27815: LIST
27816: IN
27817: NOT
27818: PUSH
27819: LD_VAR 0 6
27823: PUSH
27824: LD_INT 1
27826: EQUAL
27827: AND
27828: OR
27829: PUSH
27830: LD_VAR 0 1
27834: PUSH
27835: LD_INT 2
27837: PUSH
27838: LD_INT 3
27840: PUSH
27841: EMPTY
27842: LIST
27843: LIST
27844: IN
27845: NOT
27846: PUSH
27847: LD_VAR 0 6
27851: PUSH
27852: LD_INT 2
27854: EQUAL
27855: AND
27856: OR
27857: IFFALSE 27867
// mode = 0 ;
27859: LD_ADDR_VAR 0 6
27863: PUSH
27864: LD_INT 0
27866: ST_TO_ADDR
// case mode of 0 :
27867: LD_VAR 0 6
27871: PUSH
27872: LD_INT 0
27874: DOUBLE
27875: EQUAL
27876: IFTRUE 27880
27878: GO 39333
27880: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27881: LD_ADDR_VAR 0 11
27885: PUSH
27886: LD_INT 0
27888: PUSH
27889: LD_INT 0
27891: PUSH
27892: EMPTY
27893: LIST
27894: LIST
27895: PUSH
27896: LD_INT 0
27898: PUSH
27899: LD_INT 1
27901: NEG
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: PUSH
27907: LD_INT 1
27909: PUSH
27910: LD_INT 0
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PUSH
27917: LD_INT 1
27919: PUSH
27920: LD_INT 1
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PUSH
27927: LD_INT 0
27929: PUSH
27930: LD_INT 1
27932: PUSH
27933: EMPTY
27934: LIST
27935: LIST
27936: PUSH
27937: LD_INT 1
27939: NEG
27940: PUSH
27941: LD_INT 0
27943: PUSH
27944: EMPTY
27945: LIST
27946: LIST
27947: PUSH
27948: LD_INT 1
27950: NEG
27951: PUSH
27952: LD_INT 1
27954: NEG
27955: PUSH
27956: EMPTY
27957: LIST
27958: LIST
27959: PUSH
27960: LD_INT 1
27962: NEG
27963: PUSH
27964: LD_INT 2
27966: NEG
27967: PUSH
27968: EMPTY
27969: LIST
27970: LIST
27971: PUSH
27972: LD_INT 0
27974: PUSH
27975: LD_INT 2
27977: NEG
27978: PUSH
27979: EMPTY
27980: LIST
27981: LIST
27982: PUSH
27983: LD_INT 1
27985: PUSH
27986: LD_INT 1
27988: NEG
27989: PUSH
27990: EMPTY
27991: LIST
27992: LIST
27993: PUSH
27994: LD_INT 1
27996: PUSH
27997: LD_INT 2
27999: PUSH
28000: EMPTY
28001: LIST
28002: LIST
28003: PUSH
28004: LD_INT 0
28006: PUSH
28007: LD_INT 2
28009: PUSH
28010: EMPTY
28011: LIST
28012: LIST
28013: PUSH
28014: LD_INT 1
28016: NEG
28017: PUSH
28018: LD_INT 1
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: PUSH
28025: LD_INT 1
28027: PUSH
28028: LD_INT 3
28030: PUSH
28031: EMPTY
28032: LIST
28033: LIST
28034: PUSH
28035: LD_INT 0
28037: PUSH
28038: LD_INT 3
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: PUSH
28045: LD_INT 1
28047: NEG
28048: PUSH
28049: LD_INT 2
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: LIST
28060: LIST
28061: LIST
28062: LIST
28063: LIST
28064: LIST
28065: LIST
28066: LIST
28067: LIST
28068: LIST
28069: LIST
28070: LIST
28071: LIST
28072: LIST
28073: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28074: LD_ADDR_VAR 0 12
28078: PUSH
28079: LD_INT 0
28081: PUSH
28082: LD_INT 0
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: PUSH
28089: LD_INT 0
28091: PUSH
28092: LD_INT 1
28094: NEG
28095: PUSH
28096: EMPTY
28097: LIST
28098: LIST
28099: PUSH
28100: LD_INT 1
28102: PUSH
28103: LD_INT 0
28105: PUSH
28106: EMPTY
28107: LIST
28108: LIST
28109: PUSH
28110: LD_INT 1
28112: PUSH
28113: LD_INT 1
28115: PUSH
28116: EMPTY
28117: LIST
28118: LIST
28119: PUSH
28120: LD_INT 0
28122: PUSH
28123: LD_INT 1
28125: PUSH
28126: EMPTY
28127: LIST
28128: LIST
28129: PUSH
28130: LD_INT 1
28132: NEG
28133: PUSH
28134: LD_INT 0
28136: PUSH
28137: EMPTY
28138: LIST
28139: LIST
28140: PUSH
28141: LD_INT 1
28143: NEG
28144: PUSH
28145: LD_INT 1
28147: NEG
28148: PUSH
28149: EMPTY
28150: LIST
28151: LIST
28152: PUSH
28153: LD_INT 1
28155: PUSH
28156: LD_INT 1
28158: NEG
28159: PUSH
28160: EMPTY
28161: LIST
28162: LIST
28163: PUSH
28164: LD_INT 2
28166: PUSH
28167: LD_INT 0
28169: PUSH
28170: EMPTY
28171: LIST
28172: LIST
28173: PUSH
28174: LD_INT 2
28176: PUSH
28177: LD_INT 1
28179: PUSH
28180: EMPTY
28181: LIST
28182: LIST
28183: PUSH
28184: LD_INT 1
28186: NEG
28187: PUSH
28188: LD_INT 1
28190: PUSH
28191: EMPTY
28192: LIST
28193: LIST
28194: PUSH
28195: LD_INT 2
28197: NEG
28198: PUSH
28199: LD_INT 0
28201: PUSH
28202: EMPTY
28203: LIST
28204: LIST
28205: PUSH
28206: LD_INT 2
28208: NEG
28209: PUSH
28210: LD_INT 1
28212: NEG
28213: PUSH
28214: EMPTY
28215: LIST
28216: LIST
28217: PUSH
28218: LD_INT 2
28220: NEG
28221: PUSH
28222: LD_INT 1
28224: PUSH
28225: EMPTY
28226: LIST
28227: LIST
28228: PUSH
28229: LD_INT 3
28231: NEG
28232: PUSH
28233: LD_INT 0
28235: PUSH
28236: EMPTY
28237: LIST
28238: LIST
28239: PUSH
28240: LD_INT 3
28242: NEG
28243: PUSH
28244: LD_INT 1
28246: NEG
28247: PUSH
28248: EMPTY
28249: LIST
28250: LIST
28251: PUSH
28252: EMPTY
28253: LIST
28254: LIST
28255: LIST
28256: LIST
28257: LIST
28258: LIST
28259: LIST
28260: LIST
28261: LIST
28262: LIST
28263: LIST
28264: LIST
28265: LIST
28266: LIST
28267: LIST
28268: LIST
28269: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28270: LD_ADDR_VAR 0 13
28274: PUSH
28275: LD_INT 0
28277: PUSH
28278: LD_INT 0
28280: PUSH
28281: EMPTY
28282: LIST
28283: LIST
28284: PUSH
28285: LD_INT 0
28287: PUSH
28288: LD_INT 1
28290: NEG
28291: PUSH
28292: EMPTY
28293: LIST
28294: LIST
28295: PUSH
28296: LD_INT 1
28298: PUSH
28299: LD_INT 0
28301: PUSH
28302: EMPTY
28303: LIST
28304: LIST
28305: PUSH
28306: LD_INT 1
28308: PUSH
28309: LD_INT 1
28311: PUSH
28312: EMPTY
28313: LIST
28314: LIST
28315: PUSH
28316: LD_INT 0
28318: PUSH
28319: LD_INT 1
28321: PUSH
28322: EMPTY
28323: LIST
28324: LIST
28325: PUSH
28326: LD_INT 1
28328: NEG
28329: PUSH
28330: LD_INT 0
28332: PUSH
28333: EMPTY
28334: LIST
28335: LIST
28336: PUSH
28337: LD_INT 1
28339: NEG
28340: PUSH
28341: LD_INT 1
28343: NEG
28344: PUSH
28345: EMPTY
28346: LIST
28347: LIST
28348: PUSH
28349: LD_INT 1
28351: NEG
28352: PUSH
28353: LD_INT 2
28355: NEG
28356: PUSH
28357: EMPTY
28358: LIST
28359: LIST
28360: PUSH
28361: LD_INT 2
28363: PUSH
28364: LD_INT 1
28366: PUSH
28367: EMPTY
28368: LIST
28369: LIST
28370: PUSH
28371: LD_INT 2
28373: PUSH
28374: LD_INT 2
28376: PUSH
28377: EMPTY
28378: LIST
28379: LIST
28380: PUSH
28381: LD_INT 1
28383: PUSH
28384: LD_INT 2
28386: PUSH
28387: EMPTY
28388: LIST
28389: LIST
28390: PUSH
28391: LD_INT 2
28393: NEG
28394: PUSH
28395: LD_INT 1
28397: NEG
28398: PUSH
28399: EMPTY
28400: LIST
28401: LIST
28402: PUSH
28403: LD_INT 2
28405: NEG
28406: PUSH
28407: LD_INT 2
28409: NEG
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 2
28417: NEG
28418: PUSH
28419: LD_INT 3
28421: NEG
28422: PUSH
28423: EMPTY
28424: LIST
28425: LIST
28426: PUSH
28427: LD_INT 3
28429: NEG
28430: PUSH
28431: LD_INT 2
28433: NEG
28434: PUSH
28435: EMPTY
28436: LIST
28437: LIST
28438: PUSH
28439: LD_INT 3
28441: NEG
28442: PUSH
28443: LD_INT 3
28445: NEG
28446: PUSH
28447: EMPTY
28448: LIST
28449: LIST
28450: PUSH
28451: EMPTY
28452: LIST
28453: LIST
28454: LIST
28455: LIST
28456: LIST
28457: LIST
28458: LIST
28459: LIST
28460: LIST
28461: LIST
28462: LIST
28463: LIST
28464: LIST
28465: LIST
28466: LIST
28467: LIST
28468: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28469: LD_ADDR_VAR 0 14
28473: PUSH
28474: LD_INT 0
28476: PUSH
28477: LD_INT 0
28479: PUSH
28480: EMPTY
28481: LIST
28482: LIST
28483: PUSH
28484: LD_INT 0
28486: PUSH
28487: LD_INT 1
28489: NEG
28490: PUSH
28491: EMPTY
28492: LIST
28493: LIST
28494: PUSH
28495: LD_INT 1
28497: PUSH
28498: LD_INT 0
28500: PUSH
28501: EMPTY
28502: LIST
28503: LIST
28504: PUSH
28505: LD_INT 1
28507: PUSH
28508: LD_INT 1
28510: PUSH
28511: EMPTY
28512: LIST
28513: LIST
28514: PUSH
28515: LD_INT 0
28517: PUSH
28518: LD_INT 1
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PUSH
28525: LD_INT 1
28527: NEG
28528: PUSH
28529: LD_INT 0
28531: PUSH
28532: EMPTY
28533: LIST
28534: LIST
28535: PUSH
28536: LD_INT 1
28538: NEG
28539: PUSH
28540: LD_INT 1
28542: NEG
28543: PUSH
28544: EMPTY
28545: LIST
28546: LIST
28547: PUSH
28548: LD_INT 1
28550: NEG
28551: PUSH
28552: LD_INT 2
28554: NEG
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: PUSH
28560: LD_INT 0
28562: PUSH
28563: LD_INT 2
28565: NEG
28566: PUSH
28567: EMPTY
28568: LIST
28569: LIST
28570: PUSH
28571: LD_INT 1
28573: PUSH
28574: LD_INT 1
28576: NEG
28577: PUSH
28578: EMPTY
28579: LIST
28580: LIST
28581: PUSH
28582: LD_INT 1
28584: PUSH
28585: LD_INT 2
28587: PUSH
28588: EMPTY
28589: LIST
28590: LIST
28591: PUSH
28592: LD_INT 0
28594: PUSH
28595: LD_INT 2
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: PUSH
28602: LD_INT 1
28604: NEG
28605: PUSH
28606: LD_INT 1
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: PUSH
28613: LD_INT 1
28615: NEG
28616: PUSH
28617: LD_INT 3
28619: NEG
28620: PUSH
28621: EMPTY
28622: LIST
28623: LIST
28624: PUSH
28625: LD_INT 0
28627: PUSH
28628: LD_INT 3
28630: NEG
28631: PUSH
28632: EMPTY
28633: LIST
28634: LIST
28635: PUSH
28636: LD_INT 1
28638: PUSH
28639: LD_INT 2
28641: NEG
28642: PUSH
28643: EMPTY
28644: LIST
28645: LIST
28646: PUSH
28647: EMPTY
28648: LIST
28649: LIST
28650: LIST
28651: LIST
28652: LIST
28653: LIST
28654: LIST
28655: LIST
28656: LIST
28657: LIST
28658: LIST
28659: LIST
28660: LIST
28661: LIST
28662: LIST
28663: LIST
28664: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28665: LD_ADDR_VAR 0 15
28669: PUSH
28670: LD_INT 0
28672: PUSH
28673: LD_INT 0
28675: PUSH
28676: EMPTY
28677: LIST
28678: LIST
28679: PUSH
28680: LD_INT 0
28682: PUSH
28683: LD_INT 1
28685: NEG
28686: PUSH
28687: EMPTY
28688: LIST
28689: LIST
28690: PUSH
28691: LD_INT 1
28693: PUSH
28694: LD_INT 0
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: LD_INT 1
28703: PUSH
28704: LD_INT 1
28706: PUSH
28707: EMPTY
28708: LIST
28709: LIST
28710: PUSH
28711: LD_INT 0
28713: PUSH
28714: LD_INT 1
28716: PUSH
28717: EMPTY
28718: LIST
28719: LIST
28720: PUSH
28721: LD_INT 1
28723: NEG
28724: PUSH
28725: LD_INT 0
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: LD_INT 1
28734: NEG
28735: PUSH
28736: LD_INT 1
28738: NEG
28739: PUSH
28740: EMPTY
28741: LIST
28742: LIST
28743: PUSH
28744: LD_INT 1
28746: PUSH
28747: LD_INT 1
28749: NEG
28750: PUSH
28751: EMPTY
28752: LIST
28753: LIST
28754: PUSH
28755: LD_INT 2
28757: PUSH
28758: LD_INT 0
28760: PUSH
28761: EMPTY
28762: LIST
28763: LIST
28764: PUSH
28765: LD_INT 2
28767: PUSH
28768: LD_INT 1
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: PUSH
28775: LD_INT 1
28777: NEG
28778: PUSH
28779: LD_INT 1
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 2
28788: NEG
28789: PUSH
28790: LD_INT 0
28792: PUSH
28793: EMPTY
28794: LIST
28795: LIST
28796: PUSH
28797: LD_INT 2
28799: NEG
28800: PUSH
28801: LD_INT 1
28803: NEG
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 2
28811: PUSH
28812: LD_INT 1
28814: NEG
28815: PUSH
28816: EMPTY
28817: LIST
28818: LIST
28819: PUSH
28820: LD_INT 3
28822: PUSH
28823: LD_INT 0
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: PUSH
28830: LD_INT 3
28832: PUSH
28833: LD_INT 1
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: EMPTY
28841: LIST
28842: LIST
28843: LIST
28844: LIST
28845: LIST
28846: LIST
28847: LIST
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28858: LD_ADDR_VAR 0 16
28862: PUSH
28863: LD_INT 0
28865: PUSH
28866: LD_INT 0
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PUSH
28873: LD_INT 0
28875: PUSH
28876: LD_INT 1
28878: NEG
28879: PUSH
28880: EMPTY
28881: LIST
28882: LIST
28883: PUSH
28884: LD_INT 1
28886: PUSH
28887: LD_INT 0
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PUSH
28894: LD_INT 1
28896: PUSH
28897: LD_INT 1
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: LD_INT 0
28906: PUSH
28907: LD_INT 1
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: LD_INT 1
28916: NEG
28917: PUSH
28918: LD_INT 0
28920: PUSH
28921: EMPTY
28922: LIST
28923: LIST
28924: PUSH
28925: LD_INT 1
28927: NEG
28928: PUSH
28929: LD_INT 1
28931: NEG
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: LD_INT 1
28939: NEG
28940: PUSH
28941: LD_INT 2
28943: NEG
28944: PUSH
28945: EMPTY
28946: LIST
28947: LIST
28948: PUSH
28949: LD_INT 2
28951: PUSH
28952: LD_INT 1
28954: PUSH
28955: EMPTY
28956: LIST
28957: LIST
28958: PUSH
28959: LD_INT 2
28961: PUSH
28962: LD_INT 2
28964: PUSH
28965: EMPTY
28966: LIST
28967: LIST
28968: PUSH
28969: LD_INT 1
28971: PUSH
28972: LD_INT 2
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: PUSH
28979: LD_INT 2
28981: NEG
28982: PUSH
28983: LD_INT 1
28985: NEG
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: PUSH
28991: LD_INT 2
28993: NEG
28994: PUSH
28995: LD_INT 2
28997: NEG
28998: PUSH
28999: EMPTY
29000: LIST
29001: LIST
29002: PUSH
29003: LD_INT 3
29005: PUSH
29006: LD_INT 2
29008: PUSH
29009: EMPTY
29010: LIST
29011: LIST
29012: PUSH
29013: LD_INT 3
29015: PUSH
29016: LD_INT 3
29018: PUSH
29019: EMPTY
29020: LIST
29021: LIST
29022: PUSH
29023: LD_INT 2
29025: PUSH
29026: LD_INT 3
29028: PUSH
29029: EMPTY
29030: LIST
29031: LIST
29032: PUSH
29033: EMPTY
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: LIST
29050: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29051: LD_ADDR_VAR 0 17
29055: PUSH
29056: LD_INT 0
29058: PUSH
29059: LD_INT 0
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 0
29068: PUSH
29069: LD_INT 1
29071: NEG
29072: PUSH
29073: EMPTY
29074: LIST
29075: LIST
29076: PUSH
29077: LD_INT 1
29079: PUSH
29080: LD_INT 0
29082: PUSH
29083: EMPTY
29084: LIST
29085: LIST
29086: PUSH
29087: LD_INT 1
29089: PUSH
29090: LD_INT 1
29092: PUSH
29093: EMPTY
29094: LIST
29095: LIST
29096: PUSH
29097: LD_INT 0
29099: PUSH
29100: LD_INT 1
29102: PUSH
29103: EMPTY
29104: LIST
29105: LIST
29106: PUSH
29107: LD_INT 1
29109: NEG
29110: PUSH
29111: LD_INT 0
29113: PUSH
29114: EMPTY
29115: LIST
29116: LIST
29117: PUSH
29118: LD_INT 1
29120: NEG
29121: PUSH
29122: LD_INT 1
29124: NEG
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 1
29132: NEG
29133: PUSH
29134: LD_INT 2
29136: NEG
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: PUSH
29142: LD_INT 0
29144: PUSH
29145: LD_INT 2
29147: NEG
29148: PUSH
29149: EMPTY
29150: LIST
29151: LIST
29152: PUSH
29153: LD_INT 1
29155: PUSH
29156: LD_INT 1
29158: NEG
29159: PUSH
29160: EMPTY
29161: LIST
29162: LIST
29163: PUSH
29164: LD_INT 2
29166: PUSH
29167: LD_INT 0
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: LD_INT 2
29176: PUSH
29177: LD_INT 1
29179: PUSH
29180: EMPTY
29181: LIST
29182: LIST
29183: PUSH
29184: LD_INT 2
29186: PUSH
29187: LD_INT 2
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: LD_INT 1
29196: PUSH
29197: LD_INT 2
29199: PUSH
29200: EMPTY
29201: LIST
29202: LIST
29203: PUSH
29204: LD_INT 0
29206: PUSH
29207: LD_INT 2
29209: PUSH
29210: EMPTY
29211: LIST
29212: LIST
29213: PUSH
29214: LD_INT 1
29216: NEG
29217: PUSH
29218: LD_INT 1
29220: PUSH
29221: EMPTY
29222: LIST
29223: LIST
29224: PUSH
29225: LD_INT 2
29227: NEG
29228: PUSH
29229: LD_INT 0
29231: PUSH
29232: EMPTY
29233: LIST
29234: LIST
29235: PUSH
29236: LD_INT 2
29238: NEG
29239: PUSH
29240: LD_INT 1
29242: NEG
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: LD_INT 2
29250: NEG
29251: PUSH
29252: LD_INT 2
29254: NEG
29255: PUSH
29256: EMPTY
29257: LIST
29258: LIST
29259: PUSH
29260: EMPTY
29261: LIST
29262: LIST
29263: LIST
29264: LIST
29265: LIST
29266: LIST
29267: LIST
29268: LIST
29269: LIST
29270: LIST
29271: LIST
29272: LIST
29273: LIST
29274: LIST
29275: LIST
29276: LIST
29277: LIST
29278: LIST
29279: LIST
29280: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29281: LD_ADDR_VAR 0 18
29285: PUSH
29286: LD_INT 0
29288: PUSH
29289: LD_INT 0
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PUSH
29296: LD_INT 0
29298: PUSH
29299: LD_INT 1
29301: NEG
29302: PUSH
29303: EMPTY
29304: LIST
29305: LIST
29306: PUSH
29307: LD_INT 1
29309: PUSH
29310: LD_INT 0
29312: PUSH
29313: EMPTY
29314: LIST
29315: LIST
29316: PUSH
29317: LD_INT 1
29319: PUSH
29320: LD_INT 1
29322: PUSH
29323: EMPTY
29324: LIST
29325: LIST
29326: PUSH
29327: LD_INT 0
29329: PUSH
29330: LD_INT 1
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: PUSH
29337: LD_INT 1
29339: NEG
29340: PUSH
29341: LD_INT 0
29343: PUSH
29344: EMPTY
29345: LIST
29346: LIST
29347: PUSH
29348: LD_INT 1
29350: NEG
29351: PUSH
29352: LD_INT 1
29354: NEG
29355: PUSH
29356: EMPTY
29357: LIST
29358: LIST
29359: PUSH
29360: LD_INT 1
29362: NEG
29363: PUSH
29364: LD_INT 2
29366: NEG
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 0
29374: PUSH
29375: LD_INT 2
29377: NEG
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: LD_INT 1
29385: PUSH
29386: LD_INT 1
29388: NEG
29389: PUSH
29390: EMPTY
29391: LIST
29392: LIST
29393: PUSH
29394: LD_INT 2
29396: PUSH
29397: LD_INT 0
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PUSH
29404: LD_INT 2
29406: PUSH
29407: LD_INT 1
29409: PUSH
29410: EMPTY
29411: LIST
29412: LIST
29413: PUSH
29414: LD_INT 2
29416: PUSH
29417: LD_INT 2
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: PUSH
29424: LD_INT 1
29426: PUSH
29427: LD_INT 2
29429: PUSH
29430: EMPTY
29431: LIST
29432: LIST
29433: PUSH
29434: LD_INT 0
29436: PUSH
29437: LD_INT 2
29439: PUSH
29440: EMPTY
29441: LIST
29442: LIST
29443: PUSH
29444: LD_INT 1
29446: NEG
29447: PUSH
29448: LD_INT 1
29450: PUSH
29451: EMPTY
29452: LIST
29453: LIST
29454: PUSH
29455: LD_INT 2
29457: NEG
29458: PUSH
29459: LD_INT 0
29461: PUSH
29462: EMPTY
29463: LIST
29464: LIST
29465: PUSH
29466: LD_INT 2
29468: NEG
29469: PUSH
29470: LD_INT 1
29472: NEG
29473: PUSH
29474: EMPTY
29475: LIST
29476: LIST
29477: PUSH
29478: LD_INT 2
29480: NEG
29481: PUSH
29482: LD_INT 2
29484: NEG
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: PUSH
29490: EMPTY
29491: LIST
29492: LIST
29493: LIST
29494: LIST
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: LIST
29501: LIST
29502: LIST
29503: LIST
29504: LIST
29505: LIST
29506: LIST
29507: LIST
29508: LIST
29509: LIST
29510: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29511: LD_ADDR_VAR 0 19
29515: PUSH
29516: LD_INT 0
29518: PUSH
29519: LD_INT 0
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: PUSH
29526: LD_INT 0
29528: PUSH
29529: LD_INT 1
29531: NEG
29532: PUSH
29533: EMPTY
29534: LIST
29535: LIST
29536: PUSH
29537: LD_INT 1
29539: PUSH
29540: LD_INT 0
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PUSH
29547: LD_INT 1
29549: PUSH
29550: LD_INT 1
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 0
29559: PUSH
29560: LD_INT 1
29562: PUSH
29563: EMPTY
29564: LIST
29565: LIST
29566: PUSH
29567: LD_INT 1
29569: NEG
29570: PUSH
29571: LD_INT 0
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PUSH
29578: LD_INT 1
29580: NEG
29581: PUSH
29582: LD_INT 1
29584: NEG
29585: PUSH
29586: EMPTY
29587: LIST
29588: LIST
29589: PUSH
29590: LD_INT 1
29592: NEG
29593: PUSH
29594: LD_INT 2
29596: NEG
29597: PUSH
29598: EMPTY
29599: LIST
29600: LIST
29601: PUSH
29602: LD_INT 0
29604: PUSH
29605: LD_INT 2
29607: NEG
29608: PUSH
29609: EMPTY
29610: LIST
29611: LIST
29612: PUSH
29613: LD_INT 1
29615: PUSH
29616: LD_INT 1
29618: NEG
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: LD_INT 2
29626: PUSH
29627: LD_INT 0
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 2
29636: PUSH
29637: LD_INT 1
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: LD_INT 2
29646: PUSH
29647: LD_INT 2
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 1
29656: PUSH
29657: LD_INT 2
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: PUSH
29664: LD_INT 0
29666: PUSH
29667: LD_INT 2
29669: PUSH
29670: EMPTY
29671: LIST
29672: LIST
29673: PUSH
29674: LD_INT 1
29676: NEG
29677: PUSH
29678: LD_INT 1
29680: PUSH
29681: EMPTY
29682: LIST
29683: LIST
29684: PUSH
29685: LD_INT 2
29687: NEG
29688: PUSH
29689: LD_INT 0
29691: PUSH
29692: EMPTY
29693: LIST
29694: LIST
29695: PUSH
29696: LD_INT 2
29698: NEG
29699: PUSH
29700: LD_INT 1
29702: NEG
29703: PUSH
29704: EMPTY
29705: LIST
29706: LIST
29707: PUSH
29708: LD_INT 2
29710: NEG
29711: PUSH
29712: LD_INT 2
29714: NEG
29715: PUSH
29716: EMPTY
29717: LIST
29718: LIST
29719: PUSH
29720: EMPTY
29721: LIST
29722: LIST
29723: LIST
29724: LIST
29725: LIST
29726: LIST
29727: LIST
29728: LIST
29729: LIST
29730: LIST
29731: LIST
29732: LIST
29733: LIST
29734: LIST
29735: LIST
29736: LIST
29737: LIST
29738: LIST
29739: LIST
29740: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29741: LD_ADDR_VAR 0 20
29745: PUSH
29746: LD_INT 0
29748: PUSH
29749: LD_INT 0
29751: PUSH
29752: EMPTY
29753: LIST
29754: LIST
29755: PUSH
29756: LD_INT 0
29758: PUSH
29759: LD_INT 1
29761: NEG
29762: PUSH
29763: EMPTY
29764: LIST
29765: LIST
29766: PUSH
29767: LD_INT 1
29769: PUSH
29770: LD_INT 0
29772: PUSH
29773: EMPTY
29774: LIST
29775: LIST
29776: PUSH
29777: LD_INT 1
29779: PUSH
29780: LD_INT 1
29782: PUSH
29783: EMPTY
29784: LIST
29785: LIST
29786: PUSH
29787: LD_INT 0
29789: PUSH
29790: LD_INT 1
29792: PUSH
29793: EMPTY
29794: LIST
29795: LIST
29796: PUSH
29797: LD_INT 1
29799: NEG
29800: PUSH
29801: LD_INT 0
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 1
29810: NEG
29811: PUSH
29812: LD_INT 1
29814: NEG
29815: PUSH
29816: EMPTY
29817: LIST
29818: LIST
29819: PUSH
29820: LD_INT 1
29822: NEG
29823: PUSH
29824: LD_INT 2
29826: NEG
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: PUSH
29832: LD_INT 0
29834: PUSH
29835: LD_INT 2
29837: NEG
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: LD_INT 1
29845: PUSH
29846: LD_INT 1
29848: NEG
29849: PUSH
29850: EMPTY
29851: LIST
29852: LIST
29853: PUSH
29854: LD_INT 2
29856: PUSH
29857: LD_INT 0
29859: PUSH
29860: EMPTY
29861: LIST
29862: LIST
29863: PUSH
29864: LD_INT 2
29866: PUSH
29867: LD_INT 1
29869: PUSH
29870: EMPTY
29871: LIST
29872: LIST
29873: PUSH
29874: LD_INT 2
29876: PUSH
29877: LD_INT 2
29879: PUSH
29880: EMPTY
29881: LIST
29882: LIST
29883: PUSH
29884: LD_INT 1
29886: PUSH
29887: LD_INT 2
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 0
29896: PUSH
29897: LD_INT 2
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 1
29906: NEG
29907: PUSH
29908: LD_INT 1
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: PUSH
29915: LD_INT 2
29917: NEG
29918: PUSH
29919: LD_INT 0
29921: PUSH
29922: EMPTY
29923: LIST
29924: LIST
29925: PUSH
29926: LD_INT 2
29928: NEG
29929: PUSH
29930: LD_INT 1
29932: NEG
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: PUSH
29938: LD_INT 2
29940: NEG
29941: PUSH
29942: LD_INT 2
29944: NEG
29945: PUSH
29946: EMPTY
29947: LIST
29948: LIST
29949: PUSH
29950: EMPTY
29951: LIST
29952: LIST
29953: LIST
29954: LIST
29955: LIST
29956: LIST
29957: LIST
29958: LIST
29959: LIST
29960: LIST
29961: LIST
29962: LIST
29963: LIST
29964: LIST
29965: LIST
29966: LIST
29967: LIST
29968: LIST
29969: LIST
29970: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29971: LD_ADDR_VAR 0 21
29975: PUSH
29976: LD_INT 0
29978: PUSH
29979: LD_INT 0
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: LD_INT 0
29988: PUSH
29989: LD_INT 1
29991: NEG
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 1
29999: PUSH
30000: LD_INT 0
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: LD_INT 1
30009: PUSH
30010: LD_INT 1
30012: PUSH
30013: EMPTY
30014: LIST
30015: LIST
30016: PUSH
30017: LD_INT 0
30019: PUSH
30020: LD_INT 1
30022: PUSH
30023: EMPTY
30024: LIST
30025: LIST
30026: PUSH
30027: LD_INT 1
30029: NEG
30030: PUSH
30031: LD_INT 0
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: PUSH
30038: LD_INT 1
30040: NEG
30041: PUSH
30042: LD_INT 1
30044: NEG
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: LD_INT 1
30052: NEG
30053: PUSH
30054: LD_INT 2
30056: NEG
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 0
30064: PUSH
30065: LD_INT 2
30067: NEG
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 1
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: EMPTY
30081: LIST
30082: LIST
30083: PUSH
30084: LD_INT 2
30086: PUSH
30087: LD_INT 0
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: PUSH
30094: LD_INT 2
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 2
30106: PUSH
30107: LD_INT 2
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: LD_INT 1
30116: PUSH
30117: LD_INT 2
30119: PUSH
30120: EMPTY
30121: LIST
30122: LIST
30123: PUSH
30124: LD_INT 0
30126: PUSH
30127: LD_INT 2
30129: PUSH
30130: EMPTY
30131: LIST
30132: LIST
30133: PUSH
30134: LD_INT 1
30136: NEG
30137: PUSH
30138: LD_INT 1
30140: PUSH
30141: EMPTY
30142: LIST
30143: LIST
30144: PUSH
30145: LD_INT 2
30147: NEG
30148: PUSH
30149: LD_INT 0
30151: PUSH
30152: EMPTY
30153: LIST
30154: LIST
30155: PUSH
30156: LD_INT 2
30158: NEG
30159: PUSH
30160: LD_INT 1
30162: NEG
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: PUSH
30168: LD_INT 2
30170: NEG
30171: PUSH
30172: LD_INT 2
30174: NEG
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: EMPTY
30181: LIST
30182: LIST
30183: LIST
30184: LIST
30185: LIST
30186: LIST
30187: LIST
30188: LIST
30189: LIST
30190: LIST
30191: LIST
30192: LIST
30193: LIST
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30201: LD_ADDR_VAR 0 22
30205: PUSH
30206: LD_INT 0
30208: PUSH
30209: LD_INT 0
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: LD_INT 0
30218: PUSH
30219: LD_INT 1
30221: NEG
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: PUSH
30227: LD_INT 1
30229: PUSH
30230: LD_INT 0
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: PUSH
30237: LD_INT 1
30239: PUSH
30240: LD_INT 1
30242: PUSH
30243: EMPTY
30244: LIST
30245: LIST
30246: PUSH
30247: LD_INT 0
30249: PUSH
30250: LD_INT 1
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: PUSH
30257: LD_INT 1
30259: NEG
30260: PUSH
30261: LD_INT 0
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 1
30270: NEG
30271: PUSH
30272: LD_INT 1
30274: NEG
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 1
30282: NEG
30283: PUSH
30284: LD_INT 2
30286: NEG
30287: PUSH
30288: EMPTY
30289: LIST
30290: LIST
30291: PUSH
30292: LD_INT 0
30294: PUSH
30295: LD_INT 2
30297: NEG
30298: PUSH
30299: EMPTY
30300: LIST
30301: LIST
30302: PUSH
30303: LD_INT 1
30305: PUSH
30306: LD_INT 1
30308: NEG
30309: PUSH
30310: EMPTY
30311: LIST
30312: LIST
30313: PUSH
30314: LD_INT 2
30316: PUSH
30317: LD_INT 0
30319: PUSH
30320: EMPTY
30321: LIST
30322: LIST
30323: PUSH
30324: LD_INT 2
30326: PUSH
30327: LD_INT 1
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: PUSH
30334: LD_INT 2
30336: PUSH
30337: LD_INT 2
30339: PUSH
30340: EMPTY
30341: LIST
30342: LIST
30343: PUSH
30344: LD_INT 1
30346: PUSH
30347: LD_INT 2
30349: PUSH
30350: EMPTY
30351: LIST
30352: LIST
30353: PUSH
30354: LD_INT 0
30356: PUSH
30357: LD_INT 2
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: LD_INT 1
30366: NEG
30367: PUSH
30368: LD_INT 1
30370: PUSH
30371: EMPTY
30372: LIST
30373: LIST
30374: PUSH
30375: LD_INT 2
30377: NEG
30378: PUSH
30379: LD_INT 0
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: LD_INT 2
30388: NEG
30389: PUSH
30390: LD_INT 1
30392: NEG
30393: PUSH
30394: EMPTY
30395: LIST
30396: LIST
30397: PUSH
30398: LD_INT 2
30400: NEG
30401: PUSH
30402: LD_INT 2
30404: NEG
30405: PUSH
30406: EMPTY
30407: LIST
30408: LIST
30409: PUSH
30410: EMPTY
30411: LIST
30412: LIST
30413: LIST
30414: LIST
30415: LIST
30416: LIST
30417: LIST
30418: LIST
30419: LIST
30420: LIST
30421: LIST
30422: LIST
30423: LIST
30424: LIST
30425: LIST
30426: LIST
30427: LIST
30428: LIST
30429: LIST
30430: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30431: LD_ADDR_VAR 0 23
30435: PUSH
30436: LD_INT 0
30438: PUSH
30439: LD_INT 0
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: PUSH
30446: LD_INT 0
30448: PUSH
30449: LD_INT 1
30451: NEG
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: PUSH
30457: LD_INT 1
30459: PUSH
30460: LD_INT 0
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: PUSH
30467: LD_INT 1
30469: PUSH
30470: LD_INT 1
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: LD_INT 0
30479: PUSH
30480: LD_INT 1
30482: PUSH
30483: EMPTY
30484: LIST
30485: LIST
30486: PUSH
30487: LD_INT 1
30489: NEG
30490: PUSH
30491: LD_INT 0
30493: PUSH
30494: EMPTY
30495: LIST
30496: LIST
30497: PUSH
30498: LD_INT 1
30500: NEG
30501: PUSH
30502: LD_INT 1
30504: NEG
30505: PUSH
30506: EMPTY
30507: LIST
30508: LIST
30509: PUSH
30510: LD_INT 1
30512: NEG
30513: PUSH
30514: LD_INT 2
30516: NEG
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: PUSH
30522: LD_INT 0
30524: PUSH
30525: LD_INT 2
30527: NEG
30528: PUSH
30529: EMPTY
30530: LIST
30531: LIST
30532: PUSH
30533: LD_INT 1
30535: PUSH
30536: LD_INT 1
30538: NEG
30539: PUSH
30540: EMPTY
30541: LIST
30542: LIST
30543: PUSH
30544: LD_INT 2
30546: PUSH
30547: LD_INT 0
30549: PUSH
30550: EMPTY
30551: LIST
30552: LIST
30553: PUSH
30554: LD_INT 2
30556: PUSH
30557: LD_INT 1
30559: PUSH
30560: EMPTY
30561: LIST
30562: LIST
30563: PUSH
30564: LD_INT 2
30566: PUSH
30567: LD_INT 2
30569: PUSH
30570: EMPTY
30571: LIST
30572: LIST
30573: PUSH
30574: LD_INT 1
30576: PUSH
30577: LD_INT 2
30579: PUSH
30580: EMPTY
30581: LIST
30582: LIST
30583: PUSH
30584: LD_INT 0
30586: PUSH
30587: LD_INT 2
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: LD_INT 1
30600: PUSH
30601: EMPTY
30602: LIST
30603: LIST
30604: PUSH
30605: LD_INT 2
30607: NEG
30608: PUSH
30609: LD_INT 0
30611: PUSH
30612: EMPTY
30613: LIST
30614: LIST
30615: PUSH
30616: LD_INT 2
30618: NEG
30619: PUSH
30620: LD_INT 1
30622: NEG
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: LD_INT 2
30630: NEG
30631: PUSH
30632: LD_INT 2
30634: NEG
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: PUSH
30640: LD_INT 2
30642: NEG
30643: PUSH
30644: LD_INT 3
30646: NEG
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 1
30654: NEG
30655: PUSH
30656: LD_INT 3
30658: NEG
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: LD_INT 1
30666: PUSH
30667: LD_INT 2
30669: NEG
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: PUSH
30675: LD_INT 2
30677: PUSH
30678: LD_INT 1
30680: NEG
30681: PUSH
30682: EMPTY
30683: LIST
30684: LIST
30685: PUSH
30686: EMPTY
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: LIST
30694: LIST
30695: LIST
30696: LIST
30697: LIST
30698: LIST
30699: LIST
30700: LIST
30701: LIST
30702: LIST
30703: LIST
30704: LIST
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: LIST
30710: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30711: LD_ADDR_VAR 0 24
30715: PUSH
30716: LD_INT 0
30718: PUSH
30719: LD_INT 0
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: PUSH
30726: LD_INT 0
30728: PUSH
30729: LD_INT 1
30731: NEG
30732: PUSH
30733: EMPTY
30734: LIST
30735: LIST
30736: PUSH
30737: LD_INT 1
30739: PUSH
30740: LD_INT 0
30742: PUSH
30743: EMPTY
30744: LIST
30745: LIST
30746: PUSH
30747: LD_INT 1
30749: PUSH
30750: LD_INT 1
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: PUSH
30757: LD_INT 0
30759: PUSH
30760: LD_INT 1
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: LD_INT 1
30769: NEG
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: LD_INT 1
30780: NEG
30781: PUSH
30782: LD_INT 1
30784: NEG
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 1
30792: NEG
30793: PUSH
30794: LD_INT 2
30796: NEG
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 0
30804: PUSH
30805: LD_INT 2
30807: NEG
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PUSH
30813: LD_INT 1
30815: PUSH
30816: LD_INT 1
30818: NEG
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 2
30826: PUSH
30827: LD_INT 0
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: PUSH
30834: LD_INT 2
30836: PUSH
30837: LD_INT 1
30839: PUSH
30840: EMPTY
30841: LIST
30842: LIST
30843: PUSH
30844: LD_INT 2
30846: PUSH
30847: LD_INT 2
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: PUSH
30854: LD_INT 1
30856: PUSH
30857: LD_INT 2
30859: PUSH
30860: EMPTY
30861: LIST
30862: LIST
30863: PUSH
30864: LD_INT 0
30866: PUSH
30867: LD_INT 2
30869: PUSH
30870: EMPTY
30871: LIST
30872: LIST
30873: PUSH
30874: LD_INT 1
30876: NEG
30877: PUSH
30878: LD_INT 1
30880: PUSH
30881: EMPTY
30882: LIST
30883: LIST
30884: PUSH
30885: LD_INT 2
30887: NEG
30888: PUSH
30889: LD_INT 0
30891: PUSH
30892: EMPTY
30893: LIST
30894: LIST
30895: PUSH
30896: LD_INT 2
30898: NEG
30899: PUSH
30900: LD_INT 1
30902: NEG
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 2
30910: NEG
30911: PUSH
30912: LD_INT 2
30914: NEG
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: PUSH
30920: LD_INT 1
30922: PUSH
30923: LD_INT 2
30925: NEG
30926: PUSH
30927: EMPTY
30928: LIST
30929: LIST
30930: PUSH
30931: LD_INT 2
30933: PUSH
30934: LD_INT 1
30936: NEG
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 3
30944: PUSH
30945: LD_INT 1
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: PUSH
30952: LD_INT 3
30954: PUSH
30955: LD_INT 2
30957: PUSH
30958: EMPTY
30959: LIST
30960: LIST
30961: PUSH
30962: EMPTY
30963: LIST
30964: LIST
30965: LIST
30966: LIST
30967: LIST
30968: LIST
30969: LIST
30970: LIST
30971: LIST
30972: LIST
30973: LIST
30974: LIST
30975: LIST
30976: LIST
30977: LIST
30978: LIST
30979: LIST
30980: LIST
30981: LIST
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30987: LD_ADDR_VAR 0 25
30991: PUSH
30992: LD_INT 0
30994: PUSH
30995: LD_INT 0
30997: PUSH
30998: EMPTY
30999: LIST
31000: LIST
31001: PUSH
31002: LD_INT 0
31004: PUSH
31005: LD_INT 1
31007: NEG
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: LD_INT 1
31015: PUSH
31016: LD_INT 0
31018: PUSH
31019: EMPTY
31020: LIST
31021: LIST
31022: PUSH
31023: LD_INT 1
31025: PUSH
31026: LD_INT 1
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 0
31035: PUSH
31036: LD_INT 1
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PUSH
31043: LD_INT 1
31045: NEG
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: PUSH
31054: LD_INT 1
31056: NEG
31057: PUSH
31058: LD_INT 1
31060: NEG
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 1
31068: NEG
31069: PUSH
31070: LD_INT 2
31072: NEG
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 0
31080: PUSH
31081: LD_INT 2
31083: NEG
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: PUSH
31089: LD_INT 1
31091: PUSH
31092: LD_INT 1
31094: NEG
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: LD_INT 2
31102: PUSH
31103: LD_INT 0
31105: PUSH
31106: EMPTY
31107: LIST
31108: LIST
31109: PUSH
31110: LD_INT 2
31112: PUSH
31113: LD_INT 1
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PUSH
31120: LD_INT 2
31122: PUSH
31123: LD_INT 2
31125: PUSH
31126: EMPTY
31127: LIST
31128: LIST
31129: PUSH
31130: LD_INT 1
31132: PUSH
31133: LD_INT 2
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 0
31142: PUSH
31143: LD_INT 2
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: LD_INT 1
31152: NEG
31153: PUSH
31154: LD_INT 1
31156: PUSH
31157: EMPTY
31158: LIST
31159: LIST
31160: PUSH
31161: LD_INT 2
31163: NEG
31164: PUSH
31165: LD_INT 0
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 2
31174: NEG
31175: PUSH
31176: LD_INT 1
31178: NEG
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 2
31186: NEG
31187: PUSH
31188: LD_INT 2
31190: NEG
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PUSH
31196: LD_INT 3
31198: PUSH
31199: LD_INT 1
31201: PUSH
31202: EMPTY
31203: LIST
31204: LIST
31205: PUSH
31206: LD_INT 3
31208: PUSH
31209: LD_INT 2
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: PUSH
31216: LD_INT 2
31218: PUSH
31219: LD_INT 3
31221: PUSH
31222: EMPTY
31223: LIST
31224: LIST
31225: PUSH
31226: LD_INT 1
31228: PUSH
31229: LD_INT 3
31231: PUSH
31232: EMPTY
31233: LIST
31234: LIST
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: LIST
31240: LIST
31241: LIST
31242: LIST
31243: LIST
31244: LIST
31245: LIST
31246: LIST
31247: LIST
31248: LIST
31249: LIST
31250: LIST
31251: LIST
31252: LIST
31253: LIST
31254: LIST
31255: LIST
31256: LIST
31257: LIST
31258: LIST
31259: LIST
31260: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31261: LD_ADDR_VAR 0 26
31265: PUSH
31266: LD_INT 0
31268: PUSH
31269: LD_INT 0
31271: PUSH
31272: EMPTY
31273: LIST
31274: LIST
31275: PUSH
31276: LD_INT 0
31278: PUSH
31279: LD_INT 1
31281: NEG
31282: PUSH
31283: EMPTY
31284: LIST
31285: LIST
31286: PUSH
31287: LD_INT 1
31289: PUSH
31290: LD_INT 0
31292: PUSH
31293: EMPTY
31294: LIST
31295: LIST
31296: PUSH
31297: LD_INT 1
31299: PUSH
31300: LD_INT 1
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: PUSH
31307: LD_INT 0
31309: PUSH
31310: LD_INT 1
31312: PUSH
31313: EMPTY
31314: LIST
31315: LIST
31316: PUSH
31317: LD_INT 1
31319: NEG
31320: PUSH
31321: LD_INT 0
31323: PUSH
31324: EMPTY
31325: LIST
31326: LIST
31327: PUSH
31328: LD_INT 1
31330: NEG
31331: PUSH
31332: LD_INT 1
31334: NEG
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 1
31342: NEG
31343: PUSH
31344: LD_INT 2
31346: NEG
31347: PUSH
31348: EMPTY
31349: LIST
31350: LIST
31351: PUSH
31352: LD_INT 0
31354: PUSH
31355: LD_INT 2
31357: NEG
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 1
31365: PUSH
31366: LD_INT 1
31368: NEG
31369: PUSH
31370: EMPTY
31371: LIST
31372: LIST
31373: PUSH
31374: LD_INT 2
31376: PUSH
31377: LD_INT 0
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 2
31386: PUSH
31387: LD_INT 1
31389: PUSH
31390: EMPTY
31391: LIST
31392: LIST
31393: PUSH
31394: LD_INT 2
31396: PUSH
31397: LD_INT 2
31399: PUSH
31400: EMPTY
31401: LIST
31402: LIST
31403: PUSH
31404: LD_INT 1
31406: PUSH
31407: LD_INT 2
31409: PUSH
31410: EMPTY
31411: LIST
31412: LIST
31413: PUSH
31414: LD_INT 0
31416: PUSH
31417: LD_INT 2
31419: PUSH
31420: EMPTY
31421: LIST
31422: LIST
31423: PUSH
31424: LD_INT 1
31426: NEG
31427: PUSH
31428: LD_INT 1
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: LD_INT 2
31437: NEG
31438: PUSH
31439: LD_INT 0
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: PUSH
31446: LD_INT 2
31448: NEG
31449: PUSH
31450: LD_INT 1
31452: NEG
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: PUSH
31458: LD_INT 2
31460: NEG
31461: PUSH
31462: LD_INT 2
31464: NEG
31465: PUSH
31466: EMPTY
31467: LIST
31468: LIST
31469: PUSH
31470: LD_INT 2
31472: PUSH
31473: LD_INT 3
31475: PUSH
31476: EMPTY
31477: LIST
31478: LIST
31479: PUSH
31480: LD_INT 1
31482: PUSH
31483: LD_INT 3
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: PUSH
31490: LD_INT 1
31492: NEG
31493: PUSH
31494: LD_INT 2
31496: PUSH
31497: EMPTY
31498: LIST
31499: LIST
31500: PUSH
31501: LD_INT 2
31503: NEG
31504: PUSH
31505: LD_INT 1
31507: PUSH
31508: EMPTY
31509: LIST
31510: LIST
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: LIST
31516: LIST
31517: LIST
31518: LIST
31519: LIST
31520: LIST
31521: LIST
31522: LIST
31523: LIST
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: LIST
31529: LIST
31530: LIST
31531: LIST
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31537: LD_ADDR_VAR 0 27
31541: PUSH
31542: LD_INT 0
31544: PUSH
31545: LD_INT 0
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: LD_INT 0
31554: PUSH
31555: LD_INT 1
31557: NEG
31558: PUSH
31559: EMPTY
31560: LIST
31561: LIST
31562: PUSH
31563: LD_INT 1
31565: PUSH
31566: LD_INT 0
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 1
31575: PUSH
31576: LD_INT 1
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 0
31585: PUSH
31586: LD_INT 1
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 1
31595: NEG
31596: PUSH
31597: LD_INT 0
31599: PUSH
31600: EMPTY
31601: LIST
31602: LIST
31603: PUSH
31604: LD_INT 1
31606: NEG
31607: PUSH
31608: LD_INT 1
31610: NEG
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: PUSH
31616: LD_INT 1
31618: NEG
31619: PUSH
31620: LD_INT 2
31622: NEG
31623: PUSH
31624: EMPTY
31625: LIST
31626: LIST
31627: PUSH
31628: LD_INT 0
31630: PUSH
31631: LD_INT 2
31633: NEG
31634: PUSH
31635: EMPTY
31636: LIST
31637: LIST
31638: PUSH
31639: LD_INT 1
31641: PUSH
31642: LD_INT 1
31644: NEG
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PUSH
31650: LD_INT 2
31652: PUSH
31653: LD_INT 0
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: LD_INT 2
31662: PUSH
31663: LD_INT 1
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: LD_INT 2
31672: PUSH
31673: LD_INT 2
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 1
31682: PUSH
31683: LD_INT 2
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: LD_INT 2
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 1
31702: NEG
31703: PUSH
31704: LD_INT 1
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 2
31713: NEG
31714: PUSH
31715: LD_INT 0
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: LD_INT 2
31724: NEG
31725: PUSH
31726: LD_INT 1
31728: NEG
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: LD_INT 2
31736: NEG
31737: PUSH
31738: LD_INT 2
31740: NEG
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 1
31748: NEG
31749: PUSH
31750: LD_INT 2
31752: PUSH
31753: EMPTY
31754: LIST
31755: LIST
31756: PUSH
31757: LD_INT 2
31759: NEG
31760: PUSH
31761: LD_INT 1
31763: PUSH
31764: EMPTY
31765: LIST
31766: LIST
31767: PUSH
31768: LD_INT 3
31770: NEG
31771: PUSH
31772: LD_INT 1
31774: NEG
31775: PUSH
31776: EMPTY
31777: LIST
31778: LIST
31779: PUSH
31780: LD_INT 3
31782: NEG
31783: PUSH
31784: LD_INT 2
31786: NEG
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: LIST
31796: LIST
31797: LIST
31798: LIST
31799: LIST
31800: LIST
31801: LIST
31802: LIST
31803: LIST
31804: LIST
31805: LIST
31806: LIST
31807: LIST
31808: LIST
31809: LIST
31810: LIST
31811: LIST
31812: LIST
31813: LIST
31814: LIST
31815: LIST
31816: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31817: LD_ADDR_VAR 0 28
31821: PUSH
31822: LD_INT 0
31824: PUSH
31825: LD_INT 0
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PUSH
31832: LD_INT 0
31834: PUSH
31835: LD_INT 1
31837: NEG
31838: PUSH
31839: EMPTY
31840: LIST
31841: LIST
31842: PUSH
31843: LD_INT 1
31845: PUSH
31846: LD_INT 0
31848: PUSH
31849: EMPTY
31850: LIST
31851: LIST
31852: PUSH
31853: LD_INT 1
31855: PUSH
31856: LD_INT 1
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: PUSH
31863: LD_INT 0
31865: PUSH
31866: LD_INT 1
31868: PUSH
31869: EMPTY
31870: LIST
31871: LIST
31872: PUSH
31873: LD_INT 1
31875: NEG
31876: PUSH
31877: LD_INT 0
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PUSH
31884: LD_INT 1
31886: NEG
31887: PUSH
31888: LD_INT 1
31890: NEG
31891: PUSH
31892: EMPTY
31893: LIST
31894: LIST
31895: PUSH
31896: LD_INT 1
31898: NEG
31899: PUSH
31900: LD_INT 2
31902: NEG
31903: PUSH
31904: EMPTY
31905: LIST
31906: LIST
31907: PUSH
31908: LD_INT 0
31910: PUSH
31911: LD_INT 2
31913: NEG
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: LD_INT 1
31921: PUSH
31922: LD_INT 1
31924: NEG
31925: PUSH
31926: EMPTY
31927: LIST
31928: LIST
31929: PUSH
31930: LD_INT 2
31932: PUSH
31933: LD_INT 0
31935: PUSH
31936: EMPTY
31937: LIST
31938: LIST
31939: PUSH
31940: LD_INT 2
31942: PUSH
31943: LD_INT 1
31945: PUSH
31946: EMPTY
31947: LIST
31948: LIST
31949: PUSH
31950: LD_INT 2
31952: PUSH
31953: LD_INT 2
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PUSH
31960: LD_INT 1
31962: PUSH
31963: LD_INT 2
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: PUSH
31970: LD_INT 0
31972: PUSH
31973: LD_INT 2
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 1
31982: NEG
31983: PUSH
31984: LD_INT 1
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 2
31993: NEG
31994: PUSH
31995: LD_INT 0
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PUSH
32002: LD_INT 2
32004: NEG
32005: PUSH
32006: LD_INT 1
32008: NEG
32009: PUSH
32010: EMPTY
32011: LIST
32012: LIST
32013: PUSH
32014: LD_INT 2
32016: NEG
32017: PUSH
32018: LD_INT 2
32020: NEG
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 2
32028: NEG
32029: PUSH
32030: LD_INT 3
32032: NEG
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 1
32040: NEG
32041: PUSH
32042: LD_INT 3
32044: NEG
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PUSH
32050: LD_INT 3
32052: NEG
32053: PUSH
32054: LD_INT 1
32056: NEG
32057: PUSH
32058: EMPTY
32059: LIST
32060: LIST
32061: PUSH
32062: LD_INT 3
32064: NEG
32065: PUSH
32066: LD_INT 2
32068: NEG
32069: PUSH
32070: EMPTY
32071: LIST
32072: LIST
32073: PUSH
32074: EMPTY
32075: LIST
32076: LIST
32077: LIST
32078: LIST
32079: LIST
32080: LIST
32081: LIST
32082: LIST
32083: LIST
32084: LIST
32085: LIST
32086: LIST
32087: LIST
32088: LIST
32089: LIST
32090: LIST
32091: LIST
32092: LIST
32093: LIST
32094: LIST
32095: LIST
32096: LIST
32097: LIST
32098: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32099: LD_ADDR_VAR 0 29
32103: PUSH
32104: LD_INT 0
32106: PUSH
32107: LD_INT 0
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 0
32116: PUSH
32117: LD_INT 1
32119: NEG
32120: PUSH
32121: EMPTY
32122: LIST
32123: LIST
32124: PUSH
32125: LD_INT 1
32127: PUSH
32128: LD_INT 0
32130: PUSH
32131: EMPTY
32132: LIST
32133: LIST
32134: PUSH
32135: LD_INT 1
32137: PUSH
32138: LD_INT 1
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: PUSH
32145: LD_INT 0
32147: PUSH
32148: LD_INT 1
32150: PUSH
32151: EMPTY
32152: LIST
32153: LIST
32154: PUSH
32155: LD_INT 1
32157: NEG
32158: PUSH
32159: LD_INT 0
32161: PUSH
32162: EMPTY
32163: LIST
32164: LIST
32165: PUSH
32166: LD_INT 1
32168: NEG
32169: PUSH
32170: LD_INT 1
32172: NEG
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: LD_INT 1
32180: NEG
32181: PUSH
32182: LD_INT 2
32184: NEG
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 0
32192: PUSH
32193: LD_INT 2
32195: NEG
32196: PUSH
32197: EMPTY
32198: LIST
32199: LIST
32200: PUSH
32201: LD_INT 1
32203: PUSH
32204: LD_INT 1
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 2
32214: PUSH
32215: LD_INT 0
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 2
32224: PUSH
32225: LD_INT 1
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 1
32234: PUSH
32235: LD_INT 2
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 0
32244: PUSH
32245: LD_INT 2
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 1
32254: NEG
32255: PUSH
32256: LD_INT 1
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: PUSH
32263: LD_INT 2
32265: NEG
32266: PUSH
32267: LD_INT 1
32269: NEG
32270: PUSH
32271: EMPTY
32272: LIST
32273: LIST
32274: PUSH
32275: LD_INT 2
32277: NEG
32278: PUSH
32279: LD_INT 2
32281: NEG
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 2
32289: NEG
32290: PUSH
32291: LD_INT 3
32293: NEG
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: LD_INT 2
32301: PUSH
32302: LD_INT 1
32304: NEG
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 3
32312: PUSH
32313: LD_INT 1
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 1
32322: PUSH
32323: LD_INT 3
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 1
32332: NEG
32333: PUSH
32334: LD_INT 2
32336: PUSH
32337: EMPTY
32338: LIST
32339: LIST
32340: PUSH
32341: LD_INT 3
32343: NEG
32344: PUSH
32345: LD_INT 2
32347: NEG
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: LIST
32357: LIST
32358: LIST
32359: LIST
32360: LIST
32361: LIST
32362: LIST
32363: LIST
32364: LIST
32365: LIST
32366: LIST
32367: LIST
32368: LIST
32369: LIST
32370: LIST
32371: LIST
32372: LIST
32373: LIST
32374: LIST
32375: LIST
32376: LIST
32377: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32378: LD_ADDR_VAR 0 30
32382: PUSH
32383: LD_INT 0
32385: PUSH
32386: LD_INT 0
32388: PUSH
32389: EMPTY
32390: LIST
32391: LIST
32392: PUSH
32393: LD_INT 0
32395: PUSH
32396: LD_INT 1
32398: NEG
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 1
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 1
32416: PUSH
32417: LD_INT 1
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PUSH
32424: LD_INT 0
32426: PUSH
32427: LD_INT 1
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: LD_INT 1
32436: NEG
32437: PUSH
32438: LD_INT 0
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: LD_INT 1
32447: NEG
32448: PUSH
32449: LD_INT 1
32451: NEG
32452: PUSH
32453: EMPTY
32454: LIST
32455: LIST
32456: PUSH
32457: LD_INT 1
32459: NEG
32460: PUSH
32461: LD_INT 2
32463: NEG
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 0
32471: PUSH
32472: LD_INT 2
32474: NEG
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: LD_INT 1
32482: PUSH
32483: LD_INT 1
32485: NEG
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: LD_INT 2
32493: PUSH
32494: LD_INT 0
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 2
32503: PUSH
32504: LD_INT 1
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 2
32513: PUSH
32514: LD_INT 2
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: LD_INT 1
32523: PUSH
32524: LD_INT 2
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 1
32533: NEG
32534: PUSH
32535: LD_INT 1
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 2
32544: NEG
32545: PUSH
32546: LD_INT 0
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 2
32555: NEG
32556: PUSH
32557: LD_INT 1
32559: NEG
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 1
32567: NEG
32568: PUSH
32569: LD_INT 3
32571: NEG
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: PUSH
32577: LD_INT 1
32579: PUSH
32580: LD_INT 2
32582: NEG
32583: PUSH
32584: EMPTY
32585: LIST
32586: LIST
32587: PUSH
32588: LD_INT 3
32590: PUSH
32591: LD_INT 2
32593: PUSH
32594: EMPTY
32595: LIST
32596: LIST
32597: PUSH
32598: LD_INT 2
32600: PUSH
32601: LD_INT 3
32603: PUSH
32604: EMPTY
32605: LIST
32606: LIST
32607: PUSH
32608: LD_INT 2
32610: NEG
32611: PUSH
32612: LD_INT 1
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PUSH
32619: LD_INT 3
32621: NEG
32622: PUSH
32623: LD_INT 1
32625: NEG
32626: PUSH
32627: EMPTY
32628: LIST
32629: LIST
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: LIST
32635: LIST
32636: LIST
32637: LIST
32638: LIST
32639: LIST
32640: LIST
32641: LIST
32642: LIST
32643: LIST
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32656: LD_ADDR_VAR 0 31
32660: PUSH
32661: LD_INT 0
32663: PUSH
32664: LD_INT 0
32666: PUSH
32667: EMPTY
32668: LIST
32669: LIST
32670: PUSH
32671: LD_INT 0
32673: PUSH
32674: LD_INT 1
32676: NEG
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 1
32684: PUSH
32685: LD_INT 0
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 1
32694: PUSH
32695: LD_INT 1
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 0
32704: PUSH
32705: LD_INT 1
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: LD_INT 1
32714: NEG
32715: PUSH
32716: LD_INT 0
32718: PUSH
32719: EMPTY
32720: LIST
32721: LIST
32722: PUSH
32723: LD_INT 1
32725: NEG
32726: PUSH
32727: LD_INT 1
32729: NEG
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 1
32737: NEG
32738: PUSH
32739: LD_INT 2
32741: NEG
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 1
32749: PUSH
32750: LD_INT 1
32752: NEG
32753: PUSH
32754: EMPTY
32755: LIST
32756: LIST
32757: PUSH
32758: LD_INT 2
32760: PUSH
32761: LD_INT 0
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PUSH
32768: LD_INT 2
32770: PUSH
32771: LD_INT 1
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 2
32780: PUSH
32781: LD_INT 2
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 1
32790: PUSH
32791: LD_INT 2
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: LD_INT 0
32800: PUSH
32801: LD_INT 2
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 1
32810: NEG
32811: PUSH
32812: LD_INT 1
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 2
32821: NEG
32822: PUSH
32823: LD_INT 1
32825: NEG
32826: PUSH
32827: EMPTY
32828: LIST
32829: LIST
32830: PUSH
32831: LD_INT 2
32833: NEG
32834: PUSH
32835: LD_INT 2
32837: NEG
32838: PUSH
32839: EMPTY
32840: LIST
32841: LIST
32842: PUSH
32843: LD_INT 2
32845: NEG
32846: PUSH
32847: LD_INT 3
32849: NEG
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: PUSH
32855: LD_INT 2
32857: PUSH
32858: LD_INT 1
32860: NEG
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: PUSH
32866: LD_INT 3
32868: PUSH
32869: LD_INT 1
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 1
32878: PUSH
32879: LD_INT 3
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: PUSH
32886: LD_INT 1
32888: NEG
32889: PUSH
32890: LD_INT 2
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 3
32899: NEG
32900: PUSH
32901: LD_INT 2
32903: NEG
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: EMPTY
32910: LIST
32911: LIST
32912: LIST
32913: LIST
32914: LIST
32915: LIST
32916: LIST
32917: LIST
32918: LIST
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32934: LD_ADDR_VAR 0 32
32938: PUSH
32939: LD_INT 0
32941: PUSH
32942: LD_INT 0
32944: PUSH
32945: EMPTY
32946: LIST
32947: LIST
32948: PUSH
32949: LD_INT 0
32951: PUSH
32952: LD_INT 1
32954: NEG
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PUSH
32960: LD_INT 1
32962: PUSH
32963: LD_INT 0
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 1
32972: PUSH
32973: LD_INT 1
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: LD_INT 0
32982: PUSH
32983: LD_INT 1
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: PUSH
32990: LD_INT 1
32992: NEG
32993: PUSH
32994: LD_INT 0
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: LD_INT 1
33003: NEG
33004: PUSH
33005: LD_INT 1
33007: NEG
33008: PUSH
33009: EMPTY
33010: LIST
33011: LIST
33012: PUSH
33013: LD_INT 1
33015: NEG
33016: PUSH
33017: LD_INT 2
33019: NEG
33020: PUSH
33021: EMPTY
33022: LIST
33023: LIST
33024: PUSH
33025: LD_INT 0
33027: PUSH
33028: LD_INT 2
33030: NEG
33031: PUSH
33032: EMPTY
33033: LIST
33034: LIST
33035: PUSH
33036: LD_INT 1
33038: PUSH
33039: LD_INT 1
33041: NEG
33042: PUSH
33043: EMPTY
33044: LIST
33045: LIST
33046: PUSH
33047: LD_INT 2
33049: PUSH
33050: LD_INT 1
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: LD_INT 2
33059: PUSH
33060: LD_INT 2
33062: PUSH
33063: EMPTY
33064: LIST
33065: LIST
33066: PUSH
33067: LD_INT 1
33069: PUSH
33070: LD_INT 2
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: PUSH
33077: LD_INT 0
33079: PUSH
33080: LD_INT 2
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 1
33089: NEG
33090: PUSH
33091: LD_INT 1
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 2
33100: NEG
33101: PUSH
33102: LD_INT 0
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: PUSH
33109: LD_INT 2
33111: NEG
33112: PUSH
33113: LD_INT 1
33115: NEG
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 1
33123: NEG
33124: PUSH
33125: LD_INT 3
33127: NEG
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: PUSH
33133: LD_INT 1
33135: PUSH
33136: LD_INT 2
33138: NEG
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: LD_INT 3
33146: PUSH
33147: LD_INT 2
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: PUSH
33154: LD_INT 2
33156: PUSH
33157: LD_INT 3
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: PUSH
33164: LD_INT 2
33166: NEG
33167: PUSH
33168: LD_INT 1
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 3
33177: NEG
33178: PUSH
33179: LD_INT 1
33181: NEG
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: LIST
33191: LIST
33192: LIST
33193: LIST
33194: LIST
33195: LIST
33196: LIST
33197: LIST
33198: LIST
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33212: LD_ADDR_VAR 0 33
33216: PUSH
33217: LD_INT 0
33219: PUSH
33220: LD_INT 0
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 0
33229: PUSH
33230: LD_INT 1
33232: NEG
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: LD_INT 1
33240: PUSH
33241: LD_INT 0
33243: PUSH
33244: EMPTY
33245: LIST
33246: LIST
33247: PUSH
33248: LD_INT 1
33250: PUSH
33251: LD_INT 1
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 0
33260: PUSH
33261: LD_INT 1
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: LD_INT 1
33270: NEG
33271: PUSH
33272: LD_INT 0
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 1
33281: NEG
33282: PUSH
33283: LD_INT 1
33285: NEG
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: PUSH
33291: LD_INT 1
33293: NEG
33294: PUSH
33295: LD_INT 2
33297: NEG
33298: PUSH
33299: EMPTY
33300: LIST
33301: LIST
33302: PUSH
33303: LD_INT 1
33305: PUSH
33306: LD_INT 1
33308: NEG
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 2
33316: PUSH
33317: LD_INT 0
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: LD_INT 2
33326: PUSH
33327: LD_INT 1
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 1
33336: PUSH
33337: LD_INT 2
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: PUSH
33344: LD_INT 0
33346: PUSH
33347: LD_INT 2
33349: PUSH
33350: EMPTY
33351: LIST
33352: LIST
33353: PUSH
33354: LD_INT 1
33356: NEG
33357: PUSH
33358: LD_INT 1
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 2
33367: NEG
33368: PUSH
33369: LD_INT 0
33371: PUSH
33372: EMPTY
33373: LIST
33374: LIST
33375: PUSH
33376: LD_INT 2
33378: NEG
33379: PUSH
33380: LD_INT 1
33382: NEG
33383: PUSH
33384: EMPTY
33385: LIST
33386: LIST
33387: PUSH
33388: LD_INT 2
33390: NEG
33391: PUSH
33392: LD_INT 2
33394: NEG
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: LD_INT 2
33402: NEG
33403: PUSH
33404: LD_INT 3
33406: NEG
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: PUSH
33412: LD_INT 2
33414: PUSH
33415: LD_INT 1
33417: NEG
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PUSH
33423: LD_INT 3
33425: PUSH
33426: LD_INT 1
33428: PUSH
33429: EMPTY
33430: LIST
33431: LIST
33432: PUSH
33433: LD_INT 1
33435: PUSH
33436: LD_INT 3
33438: PUSH
33439: EMPTY
33440: LIST
33441: LIST
33442: PUSH
33443: LD_INT 1
33445: NEG
33446: PUSH
33447: LD_INT 2
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 3
33456: NEG
33457: PUSH
33458: LD_INT 2
33460: NEG
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: LIST
33470: LIST
33471: LIST
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: LIST
33486: LIST
33487: LIST
33488: LIST
33489: LIST
33490: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33491: LD_ADDR_VAR 0 34
33495: PUSH
33496: LD_INT 0
33498: PUSH
33499: LD_INT 0
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 0
33508: PUSH
33509: LD_INT 1
33511: NEG
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 1
33519: PUSH
33520: LD_INT 0
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 1
33529: PUSH
33530: LD_INT 1
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 0
33539: PUSH
33540: LD_INT 1
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: NEG
33550: PUSH
33551: LD_INT 0
33553: PUSH
33554: EMPTY
33555: LIST
33556: LIST
33557: PUSH
33558: LD_INT 1
33560: NEG
33561: PUSH
33562: LD_INT 1
33564: NEG
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: PUSH
33570: LD_INT 1
33572: NEG
33573: PUSH
33574: LD_INT 2
33576: NEG
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: LD_INT 0
33584: PUSH
33585: LD_INT 2
33587: NEG
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 1
33595: PUSH
33596: LD_INT 1
33598: NEG
33599: PUSH
33600: EMPTY
33601: LIST
33602: LIST
33603: PUSH
33604: LD_INT 2
33606: PUSH
33607: LD_INT 1
33609: PUSH
33610: EMPTY
33611: LIST
33612: LIST
33613: PUSH
33614: LD_INT 2
33616: PUSH
33617: LD_INT 2
33619: PUSH
33620: EMPTY
33621: LIST
33622: LIST
33623: PUSH
33624: LD_INT 1
33626: PUSH
33627: LD_INT 2
33629: PUSH
33630: EMPTY
33631: LIST
33632: LIST
33633: PUSH
33634: LD_INT 1
33636: NEG
33637: PUSH
33638: LD_INT 1
33640: PUSH
33641: EMPTY
33642: LIST
33643: LIST
33644: PUSH
33645: LD_INT 2
33647: NEG
33648: PUSH
33649: LD_INT 0
33651: PUSH
33652: EMPTY
33653: LIST
33654: LIST
33655: PUSH
33656: LD_INT 2
33658: NEG
33659: PUSH
33660: LD_INT 1
33662: NEG
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 2
33670: NEG
33671: PUSH
33672: LD_INT 2
33674: NEG
33675: PUSH
33676: EMPTY
33677: LIST
33678: LIST
33679: PUSH
33680: LD_INT 1
33682: NEG
33683: PUSH
33684: LD_INT 3
33686: NEG
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: LD_INT 1
33694: PUSH
33695: LD_INT 2
33697: NEG
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 3
33705: PUSH
33706: LD_INT 2
33708: PUSH
33709: EMPTY
33710: LIST
33711: LIST
33712: PUSH
33713: LD_INT 2
33715: PUSH
33716: LD_INT 3
33718: PUSH
33719: EMPTY
33720: LIST
33721: LIST
33722: PUSH
33723: LD_INT 2
33725: NEG
33726: PUSH
33727: LD_INT 1
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 3
33736: NEG
33737: PUSH
33738: LD_INT 1
33740: NEG
33741: PUSH
33742: EMPTY
33743: LIST
33744: LIST
33745: PUSH
33746: EMPTY
33747: LIST
33748: LIST
33749: LIST
33750: LIST
33751: LIST
33752: LIST
33753: LIST
33754: LIST
33755: LIST
33756: LIST
33757: LIST
33758: LIST
33759: LIST
33760: LIST
33761: LIST
33762: LIST
33763: LIST
33764: LIST
33765: LIST
33766: LIST
33767: LIST
33768: LIST
33769: LIST
33770: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33771: LD_ADDR_VAR 0 35
33775: PUSH
33776: LD_INT 0
33778: PUSH
33779: LD_INT 0
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 0
33788: PUSH
33789: LD_INT 1
33791: NEG
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 1
33799: PUSH
33800: LD_INT 0
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: LD_INT 1
33809: PUSH
33810: LD_INT 1
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 0
33819: PUSH
33820: LD_INT 1
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 1
33829: NEG
33830: PUSH
33831: LD_INT 0
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 1
33840: NEG
33841: PUSH
33842: LD_INT 1
33844: NEG
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 2
33852: PUSH
33853: LD_INT 1
33855: PUSH
33856: EMPTY
33857: LIST
33858: LIST
33859: PUSH
33860: LD_INT 2
33862: NEG
33863: PUSH
33864: LD_INT 1
33866: NEG
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: EMPTY
33873: LIST
33874: LIST
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33883: LD_ADDR_VAR 0 36
33887: PUSH
33888: LD_INT 0
33890: PUSH
33891: LD_INT 0
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PUSH
33898: LD_INT 0
33900: PUSH
33901: LD_INT 1
33903: NEG
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: PUSH
33909: LD_INT 1
33911: PUSH
33912: LD_INT 0
33914: PUSH
33915: EMPTY
33916: LIST
33917: LIST
33918: PUSH
33919: LD_INT 1
33921: PUSH
33922: LD_INT 1
33924: PUSH
33925: EMPTY
33926: LIST
33927: LIST
33928: PUSH
33929: LD_INT 0
33931: PUSH
33932: LD_INT 1
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: LD_INT 1
33941: NEG
33942: PUSH
33943: LD_INT 0
33945: PUSH
33946: EMPTY
33947: LIST
33948: LIST
33949: PUSH
33950: LD_INT 1
33952: NEG
33953: PUSH
33954: LD_INT 1
33956: NEG
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 1
33964: NEG
33965: PUSH
33966: LD_INT 2
33968: NEG
33969: PUSH
33970: EMPTY
33971: LIST
33972: LIST
33973: PUSH
33974: LD_INT 1
33976: PUSH
33977: LD_INT 2
33979: PUSH
33980: EMPTY
33981: LIST
33982: LIST
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: LIST
33988: LIST
33989: LIST
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33995: LD_ADDR_VAR 0 37
33999: PUSH
34000: LD_INT 0
34002: PUSH
34003: LD_INT 0
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: PUSH
34010: LD_INT 0
34012: PUSH
34013: LD_INT 1
34015: NEG
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 1
34023: PUSH
34024: LD_INT 0
34026: PUSH
34027: EMPTY
34028: LIST
34029: LIST
34030: PUSH
34031: LD_INT 1
34033: PUSH
34034: LD_INT 1
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 0
34043: PUSH
34044: LD_INT 1
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: PUSH
34051: LD_INT 1
34053: NEG
34054: PUSH
34055: LD_INT 0
34057: PUSH
34058: EMPTY
34059: LIST
34060: LIST
34061: PUSH
34062: LD_INT 1
34064: NEG
34065: PUSH
34066: LD_INT 1
34068: NEG
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 1
34076: PUSH
34077: LD_INT 1
34079: NEG
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 1
34087: NEG
34088: PUSH
34089: LD_INT 1
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: LIST
34100: LIST
34101: LIST
34102: LIST
34103: LIST
34104: LIST
34105: LIST
34106: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34107: LD_ADDR_VAR 0 38
34111: PUSH
34112: LD_INT 0
34114: PUSH
34115: LD_INT 0
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: LD_INT 0
34124: PUSH
34125: LD_INT 1
34127: NEG
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 1
34135: PUSH
34136: LD_INT 0
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: LD_INT 1
34145: PUSH
34146: LD_INT 1
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 0
34155: PUSH
34156: LD_INT 1
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PUSH
34163: LD_INT 1
34165: NEG
34166: PUSH
34167: LD_INT 0
34169: PUSH
34170: EMPTY
34171: LIST
34172: LIST
34173: PUSH
34174: LD_INT 1
34176: NEG
34177: PUSH
34178: LD_INT 1
34180: NEG
34181: PUSH
34182: EMPTY
34183: LIST
34184: LIST
34185: PUSH
34186: LD_INT 2
34188: PUSH
34189: LD_INT 1
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: PUSH
34196: LD_INT 2
34198: NEG
34199: PUSH
34200: LD_INT 1
34202: NEG
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PUSH
34208: EMPTY
34209: LIST
34210: LIST
34211: LIST
34212: LIST
34213: LIST
34214: LIST
34215: LIST
34216: LIST
34217: LIST
34218: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34219: LD_ADDR_VAR 0 39
34223: PUSH
34224: LD_INT 0
34226: PUSH
34227: LD_INT 0
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 0
34236: PUSH
34237: LD_INT 1
34239: NEG
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PUSH
34245: LD_INT 1
34247: PUSH
34248: LD_INT 0
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 1
34257: PUSH
34258: LD_INT 1
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PUSH
34265: LD_INT 0
34267: PUSH
34268: LD_INT 1
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 1
34277: NEG
34278: PUSH
34279: LD_INT 0
34281: PUSH
34282: EMPTY
34283: LIST
34284: LIST
34285: PUSH
34286: LD_INT 1
34288: NEG
34289: PUSH
34290: LD_INT 1
34292: NEG
34293: PUSH
34294: EMPTY
34295: LIST
34296: LIST
34297: PUSH
34298: LD_INT 1
34300: NEG
34301: PUSH
34302: LD_INT 2
34304: NEG
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: PUSH
34310: LD_INT 1
34312: PUSH
34313: LD_INT 2
34315: PUSH
34316: EMPTY
34317: LIST
34318: LIST
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: LIST
34324: LIST
34325: LIST
34326: LIST
34327: LIST
34328: LIST
34329: LIST
34330: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34331: LD_ADDR_VAR 0 40
34335: PUSH
34336: LD_INT 0
34338: PUSH
34339: LD_INT 0
34341: PUSH
34342: EMPTY
34343: LIST
34344: LIST
34345: PUSH
34346: LD_INT 0
34348: PUSH
34349: LD_INT 1
34351: NEG
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 1
34359: PUSH
34360: LD_INT 0
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 1
34369: PUSH
34370: LD_INT 1
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 0
34379: PUSH
34380: LD_INT 1
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: NEG
34390: PUSH
34391: LD_INT 0
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 1
34400: NEG
34401: PUSH
34402: LD_INT 1
34404: NEG
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 1
34412: PUSH
34413: LD_INT 1
34415: NEG
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: NEG
34424: PUSH
34425: LD_INT 1
34427: PUSH
34428: EMPTY
34429: LIST
34430: LIST
34431: PUSH
34432: EMPTY
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34443: LD_ADDR_VAR 0 41
34447: PUSH
34448: LD_INT 0
34450: PUSH
34451: LD_INT 0
34453: PUSH
34454: EMPTY
34455: LIST
34456: LIST
34457: PUSH
34458: LD_INT 0
34460: PUSH
34461: LD_INT 1
34463: NEG
34464: PUSH
34465: EMPTY
34466: LIST
34467: LIST
34468: PUSH
34469: LD_INT 1
34471: PUSH
34472: LD_INT 0
34474: PUSH
34475: EMPTY
34476: LIST
34477: LIST
34478: PUSH
34479: LD_INT 1
34481: PUSH
34482: LD_INT 1
34484: PUSH
34485: EMPTY
34486: LIST
34487: LIST
34488: PUSH
34489: LD_INT 0
34491: PUSH
34492: LD_INT 1
34494: PUSH
34495: EMPTY
34496: LIST
34497: LIST
34498: PUSH
34499: LD_INT 1
34501: NEG
34502: PUSH
34503: LD_INT 0
34505: PUSH
34506: EMPTY
34507: LIST
34508: LIST
34509: PUSH
34510: LD_INT 1
34512: NEG
34513: PUSH
34514: LD_INT 1
34516: NEG
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 1
34524: NEG
34525: PUSH
34526: LD_INT 2
34528: NEG
34529: PUSH
34530: EMPTY
34531: LIST
34532: LIST
34533: PUSH
34534: LD_INT 1
34536: PUSH
34537: LD_INT 1
34539: NEG
34540: PUSH
34541: EMPTY
34542: LIST
34543: LIST
34544: PUSH
34545: LD_INT 2
34547: PUSH
34548: LD_INT 0
34550: PUSH
34551: EMPTY
34552: LIST
34553: LIST
34554: PUSH
34555: LD_INT 2
34557: PUSH
34558: LD_INT 1
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: LD_INT 2
34567: PUSH
34568: LD_INT 2
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: PUSH
34575: LD_INT 1
34577: PUSH
34578: LD_INT 2
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 1
34587: NEG
34588: PUSH
34589: LD_INT 1
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 2
34598: NEG
34599: PUSH
34600: LD_INT 0
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: LD_INT 2
34609: NEG
34610: PUSH
34611: LD_INT 1
34613: NEG
34614: PUSH
34615: EMPTY
34616: LIST
34617: LIST
34618: PUSH
34619: LD_INT 2
34621: NEG
34622: PUSH
34623: LD_INT 2
34625: NEG
34626: PUSH
34627: EMPTY
34628: LIST
34629: LIST
34630: PUSH
34631: LD_INT 2
34633: NEG
34634: PUSH
34635: LD_INT 3
34637: NEG
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 2
34645: PUSH
34646: LD_INT 1
34648: NEG
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 3
34656: PUSH
34657: LD_INT 0
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: PUSH
34664: LD_INT 3
34666: PUSH
34667: LD_INT 1
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PUSH
34674: LD_INT 3
34676: PUSH
34677: LD_INT 2
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PUSH
34684: LD_INT 3
34686: PUSH
34687: LD_INT 3
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 2
34696: PUSH
34697: LD_INT 3
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 2
34706: NEG
34707: PUSH
34708: LD_INT 1
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PUSH
34715: LD_INT 3
34717: NEG
34718: PUSH
34719: LD_INT 0
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PUSH
34726: LD_INT 3
34728: NEG
34729: PUSH
34730: LD_INT 1
34732: NEG
34733: PUSH
34734: EMPTY
34735: LIST
34736: LIST
34737: PUSH
34738: LD_INT 3
34740: NEG
34741: PUSH
34742: LD_INT 2
34744: NEG
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 3
34752: NEG
34753: PUSH
34754: LD_INT 3
34756: NEG
34757: PUSH
34758: EMPTY
34759: LIST
34760: LIST
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: LIST
34766: LIST
34767: LIST
34768: LIST
34769: LIST
34770: LIST
34771: LIST
34772: LIST
34773: LIST
34774: LIST
34775: LIST
34776: LIST
34777: LIST
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: LIST
34783: LIST
34784: LIST
34785: LIST
34786: LIST
34787: LIST
34788: LIST
34789: LIST
34790: LIST
34791: LIST
34792: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34793: LD_ADDR_VAR 0 42
34797: PUSH
34798: LD_INT 0
34800: PUSH
34801: LD_INT 0
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: PUSH
34808: LD_INT 0
34810: PUSH
34811: LD_INT 1
34813: NEG
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PUSH
34819: LD_INT 1
34821: PUSH
34822: LD_INT 0
34824: PUSH
34825: EMPTY
34826: LIST
34827: LIST
34828: PUSH
34829: LD_INT 1
34831: PUSH
34832: LD_INT 1
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 0
34841: PUSH
34842: LD_INT 1
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: PUSH
34849: LD_INT 1
34851: NEG
34852: PUSH
34853: LD_INT 0
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: LD_INT 1
34862: NEG
34863: PUSH
34864: LD_INT 1
34866: NEG
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 1
34874: NEG
34875: PUSH
34876: LD_INT 2
34878: NEG
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: LD_INT 0
34886: PUSH
34887: LD_INT 2
34889: NEG
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 1
34897: PUSH
34898: LD_INT 1
34900: NEG
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 2
34908: PUSH
34909: LD_INT 1
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 2
34918: PUSH
34919: LD_INT 2
34921: PUSH
34922: EMPTY
34923: LIST
34924: LIST
34925: PUSH
34926: LD_INT 1
34928: PUSH
34929: LD_INT 2
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 0
34938: PUSH
34939: LD_INT 2
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: PUSH
34946: LD_INT 1
34948: NEG
34949: PUSH
34950: LD_INT 1
34952: PUSH
34953: EMPTY
34954: LIST
34955: LIST
34956: PUSH
34957: LD_INT 2
34959: NEG
34960: PUSH
34961: LD_INT 1
34963: NEG
34964: PUSH
34965: EMPTY
34966: LIST
34967: LIST
34968: PUSH
34969: LD_INT 2
34971: NEG
34972: PUSH
34973: LD_INT 2
34975: NEG
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: LD_INT 2
34983: NEG
34984: PUSH
34985: LD_INT 3
34987: NEG
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 1
34995: NEG
34996: PUSH
34997: LD_INT 3
34999: NEG
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: LD_INT 0
35007: PUSH
35008: LD_INT 3
35010: NEG
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: LD_INT 1
35018: PUSH
35019: LD_INT 2
35021: NEG
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 3
35029: PUSH
35030: LD_INT 2
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 3
35039: PUSH
35040: LD_INT 3
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: PUSH
35047: LD_INT 2
35049: PUSH
35050: LD_INT 3
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: LD_INT 1
35059: PUSH
35060: LD_INT 3
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: LD_INT 0
35069: PUSH
35070: LD_INT 3
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 1
35079: NEG
35080: PUSH
35081: LD_INT 2
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 3
35090: NEG
35091: PUSH
35092: LD_INT 2
35094: NEG
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 3
35102: NEG
35103: PUSH
35104: LD_INT 3
35106: NEG
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: LIST
35133: LIST
35134: LIST
35135: LIST
35136: LIST
35137: LIST
35138: LIST
35139: LIST
35140: LIST
35141: LIST
35142: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35143: LD_ADDR_VAR 0 43
35147: PUSH
35148: LD_INT 0
35150: PUSH
35151: LD_INT 0
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: LD_INT 0
35160: PUSH
35161: LD_INT 1
35163: NEG
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 1
35171: PUSH
35172: LD_INT 0
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 1
35181: PUSH
35182: LD_INT 1
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 0
35191: PUSH
35192: LD_INT 1
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 1
35201: NEG
35202: PUSH
35203: LD_INT 0
35205: PUSH
35206: EMPTY
35207: LIST
35208: LIST
35209: PUSH
35210: LD_INT 1
35212: NEG
35213: PUSH
35214: LD_INT 1
35216: NEG
35217: PUSH
35218: EMPTY
35219: LIST
35220: LIST
35221: PUSH
35222: LD_INT 1
35224: NEG
35225: PUSH
35226: LD_INT 2
35228: NEG
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 0
35236: PUSH
35237: LD_INT 2
35239: NEG
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: PUSH
35245: LD_INT 1
35247: PUSH
35248: LD_INT 1
35250: NEG
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 2
35258: PUSH
35259: LD_INT 0
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 2
35268: PUSH
35269: LD_INT 1
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: LD_INT 1
35278: PUSH
35279: LD_INT 2
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 0
35288: PUSH
35289: LD_INT 2
35291: PUSH
35292: EMPTY
35293: LIST
35294: LIST
35295: PUSH
35296: LD_INT 1
35298: NEG
35299: PUSH
35300: LD_INT 1
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PUSH
35307: LD_INT 2
35309: NEG
35310: PUSH
35311: LD_INT 0
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: LD_INT 2
35320: NEG
35321: PUSH
35322: LD_INT 1
35324: NEG
35325: PUSH
35326: EMPTY
35327: LIST
35328: LIST
35329: PUSH
35330: LD_INT 1
35332: NEG
35333: PUSH
35334: LD_INT 3
35336: NEG
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: LD_INT 0
35344: PUSH
35345: LD_INT 3
35347: NEG
35348: PUSH
35349: EMPTY
35350: LIST
35351: LIST
35352: PUSH
35353: LD_INT 1
35355: PUSH
35356: LD_INT 2
35358: NEG
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 2
35366: PUSH
35367: LD_INT 1
35369: NEG
35370: PUSH
35371: EMPTY
35372: LIST
35373: LIST
35374: PUSH
35375: LD_INT 3
35377: PUSH
35378: LD_INT 0
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: PUSH
35385: LD_INT 3
35387: PUSH
35388: LD_INT 1
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: PUSH
35395: LD_INT 1
35397: PUSH
35398: LD_INT 3
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: PUSH
35405: LD_INT 0
35407: PUSH
35408: LD_INT 3
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: LD_INT 1
35417: NEG
35418: PUSH
35419: LD_INT 2
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 2
35428: NEG
35429: PUSH
35430: LD_INT 1
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 3
35439: NEG
35440: PUSH
35441: LD_INT 0
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 3
35450: NEG
35451: PUSH
35452: LD_INT 1
35454: NEG
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: LIST
35469: LIST
35470: LIST
35471: LIST
35472: LIST
35473: LIST
35474: LIST
35475: LIST
35476: LIST
35477: LIST
35478: LIST
35479: LIST
35480: LIST
35481: LIST
35482: LIST
35483: LIST
35484: LIST
35485: LIST
35486: LIST
35487: LIST
35488: LIST
35489: LIST
35490: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35491: LD_ADDR_VAR 0 44
35495: PUSH
35496: LD_INT 0
35498: PUSH
35499: LD_INT 0
35501: PUSH
35502: EMPTY
35503: LIST
35504: LIST
35505: PUSH
35506: LD_INT 0
35508: PUSH
35509: LD_INT 1
35511: NEG
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 1
35519: PUSH
35520: LD_INT 0
35522: PUSH
35523: EMPTY
35524: LIST
35525: LIST
35526: PUSH
35527: LD_INT 1
35529: PUSH
35530: LD_INT 1
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 0
35539: PUSH
35540: LD_INT 1
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 1
35549: NEG
35550: PUSH
35551: LD_INT 0
35553: PUSH
35554: EMPTY
35555: LIST
35556: LIST
35557: PUSH
35558: LD_INT 1
35560: NEG
35561: PUSH
35562: LD_INT 1
35564: NEG
35565: PUSH
35566: EMPTY
35567: LIST
35568: LIST
35569: PUSH
35570: LD_INT 1
35572: NEG
35573: PUSH
35574: LD_INT 2
35576: NEG
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 1
35584: PUSH
35585: LD_INT 1
35587: NEG
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: LD_INT 2
35595: PUSH
35596: LD_INT 0
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 2
35605: PUSH
35606: LD_INT 1
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 2
35615: PUSH
35616: LD_INT 2
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: LD_INT 1
35625: PUSH
35626: LD_INT 2
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 1
35635: NEG
35636: PUSH
35637: LD_INT 1
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 2
35646: NEG
35647: PUSH
35648: LD_INT 0
35650: PUSH
35651: EMPTY
35652: LIST
35653: LIST
35654: PUSH
35655: LD_INT 2
35657: NEG
35658: PUSH
35659: LD_INT 1
35661: NEG
35662: PUSH
35663: EMPTY
35664: LIST
35665: LIST
35666: PUSH
35667: LD_INT 2
35669: NEG
35670: PUSH
35671: LD_INT 2
35673: NEG
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 2
35681: NEG
35682: PUSH
35683: LD_INT 3
35685: NEG
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 2
35693: PUSH
35694: LD_INT 1
35696: NEG
35697: PUSH
35698: EMPTY
35699: LIST
35700: LIST
35701: PUSH
35702: LD_INT 3
35704: PUSH
35705: LD_INT 0
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 3
35714: PUSH
35715: LD_INT 1
35717: PUSH
35718: EMPTY
35719: LIST
35720: LIST
35721: PUSH
35722: LD_INT 3
35724: PUSH
35725: LD_INT 2
35727: PUSH
35728: EMPTY
35729: LIST
35730: LIST
35731: PUSH
35732: LD_INT 3
35734: PUSH
35735: LD_INT 3
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 2
35744: PUSH
35745: LD_INT 3
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: LD_INT 2
35754: NEG
35755: PUSH
35756: LD_INT 1
35758: PUSH
35759: EMPTY
35760: LIST
35761: LIST
35762: PUSH
35763: LD_INT 3
35765: NEG
35766: PUSH
35767: LD_INT 0
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: PUSH
35774: LD_INT 3
35776: NEG
35777: PUSH
35778: LD_INT 1
35780: NEG
35781: PUSH
35782: EMPTY
35783: LIST
35784: LIST
35785: PUSH
35786: LD_INT 3
35788: NEG
35789: PUSH
35790: LD_INT 2
35792: NEG
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 3
35800: NEG
35801: PUSH
35802: LD_INT 3
35804: NEG
35805: PUSH
35806: EMPTY
35807: LIST
35808: LIST
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: LIST
35822: LIST
35823: LIST
35824: LIST
35825: LIST
35826: LIST
35827: LIST
35828: LIST
35829: LIST
35830: LIST
35831: LIST
35832: LIST
35833: LIST
35834: LIST
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: LIST
35840: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35841: LD_ADDR_VAR 0 45
35845: PUSH
35846: LD_INT 0
35848: PUSH
35849: LD_INT 0
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PUSH
35856: LD_INT 0
35858: PUSH
35859: LD_INT 1
35861: NEG
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: LD_INT 1
35869: PUSH
35870: LD_INT 0
35872: PUSH
35873: EMPTY
35874: LIST
35875: LIST
35876: PUSH
35877: LD_INT 1
35879: PUSH
35880: LD_INT 1
35882: PUSH
35883: EMPTY
35884: LIST
35885: LIST
35886: PUSH
35887: LD_INT 0
35889: PUSH
35890: LD_INT 1
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: LD_INT 1
35899: NEG
35900: PUSH
35901: LD_INT 0
35903: PUSH
35904: EMPTY
35905: LIST
35906: LIST
35907: PUSH
35908: LD_INT 1
35910: NEG
35911: PUSH
35912: LD_INT 1
35914: NEG
35915: PUSH
35916: EMPTY
35917: LIST
35918: LIST
35919: PUSH
35920: LD_INT 1
35922: NEG
35923: PUSH
35924: LD_INT 2
35926: NEG
35927: PUSH
35928: EMPTY
35929: LIST
35930: LIST
35931: PUSH
35932: LD_INT 0
35934: PUSH
35935: LD_INT 2
35937: NEG
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PUSH
35943: LD_INT 1
35945: PUSH
35946: LD_INT 1
35948: NEG
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: LD_INT 2
35956: PUSH
35957: LD_INT 1
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PUSH
35964: LD_INT 2
35966: PUSH
35967: LD_INT 2
35969: PUSH
35970: EMPTY
35971: LIST
35972: LIST
35973: PUSH
35974: LD_INT 1
35976: PUSH
35977: LD_INT 2
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: PUSH
35984: LD_INT 0
35986: PUSH
35987: LD_INT 2
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 1
35996: NEG
35997: PUSH
35998: LD_INT 1
36000: PUSH
36001: EMPTY
36002: LIST
36003: LIST
36004: PUSH
36005: LD_INT 2
36007: NEG
36008: PUSH
36009: LD_INT 1
36011: NEG
36012: PUSH
36013: EMPTY
36014: LIST
36015: LIST
36016: PUSH
36017: LD_INT 2
36019: NEG
36020: PUSH
36021: LD_INT 2
36023: NEG
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 2
36031: NEG
36032: PUSH
36033: LD_INT 3
36035: NEG
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: LD_INT 1
36043: NEG
36044: PUSH
36045: LD_INT 3
36047: NEG
36048: PUSH
36049: EMPTY
36050: LIST
36051: LIST
36052: PUSH
36053: LD_INT 0
36055: PUSH
36056: LD_INT 3
36058: NEG
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: LD_INT 1
36066: PUSH
36067: LD_INT 2
36069: NEG
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 3
36077: PUSH
36078: LD_INT 2
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 3
36087: PUSH
36088: LD_INT 3
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: LD_INT 2
36097: PUSH
36098: LD_INT 3
36100: PUSH
36101: EMPTY
36102: LIST
36103: LIST
36104: PUSH
36105: LD_INT 1
36107: PUSH
36108: LD_INT 3
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: LD_INT 0
36117: PUSH
36118: LD_INT 3
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: PUSH
36125: LD_INT 1
36127: NEG
36128: PUSH
36129: LD_INT 2
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PUSH
36136: LD_INT 3
36138: NEG
36139: PUSH
36140: LD_INT 2
36142: NEG
36143: PUSH
36144: EMPTY
36145: LIST
36146: LIST
36147: PUSH
36148: LD_INT 3
36150: NEG
36151: PUSH
36152: LD_INT 3
36154: NEG
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: LIST
36164: LIST
36165: LIST
36166: LIST
36167: LIST
36168: LIST
36169: LIST
36170: LIST
36171: LIST
36172: LIST
36173: LIST
36174: LIST
36175: LIST
36176: LIST
36177: LIST
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: LIST
36184: LIST
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36191: LD_ADDR_VAR 0 46
36195: PUSH
36196: LD_INT 0
36198: PUSH
36199: LD_INT 0
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 0
36208: PUSH
36209: LD_INT 1
36211: NEG
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: PUSH
36217: LD_INT 1
36219: PUSH
36220: LD_INT 0
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: PUSH
36227: LD_INT 1
36229: PUSH
36230: LD_INT 1
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 0
36239: PUSH
36240: LD_INT 1
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 1
36249: NEG
36250: PUSH
36251: LD_INT 0
36253: PUSH
36254: EMPTY
36255: LIST
36256: LIST
36257: PUSH
36258: LD_INT 1
36260: NEG
36261: PUSH
36262: LD_INT 1
36264: NEG
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 1
36272: NEG
36273: PUSH
36274: LD_INT 2
36276: NEG
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: PUSH
36282: LD_INT 0
36284: PUSH
36285: LD_INT 2
36287: NEG
36288: PUSH
36289: EMPTY
36290: LIST
36291: LIST
36292: PUSH
36293: LD_INT 1
36295: PUSH
36296: LD_INT 1
36298: NEG
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PUSH
36304: LD_INT 2
36306: PUSH
36307: LD_INT 0
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: LD_INT 2
36316: PUSH
36317: LD_INT 1
36319: PUSH
36320: EMPTY
36321: LIST
36322: LIST
36323: PUSH
36324: LD_INT 1
36326: PUSH
36327: LD_INT 2
36329: PUSH
36330: EMPTY
36331: LIST
36332: LIST
36333: PUSH
36334: LD_INT 0
36336: PUSH
36337: LD_INT 2
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: PUSH
36344: LD_INT 1
36346: NEG
36347: PUSH
36348: LD_INT 1
36350: PUSH
36351: EMPTY
36352: LIST
36353: LIST
36354: PUSH
36355: LD_INT 2
36357: NEG
36358: PUSH
36359: LD_INT 0
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: PUSH
36366: LD_INT 2
36368: NEG
36369: PUSH
36370: LD_INT 1
36372: NEG
36373: PUSH
36374: EMPTY
36375: LIST
36376: LIST
36377: PUSH
36378: LD_INT 1
36380: NEG
36381: PUSH
36382: LD_INT 3
36384: NEG
36385: PUSH
36386: EMPTY
36387: LIST
36388: LIST
36389: PUSH
36390: LD_INT 0
36392: PUSH
36393: LD_INT 3
36395: NEG
36396: PUSH
36397: EMPTY
36398: LIST
36399: LIST
36400: PUSH
36401: LD_INT 1
36403: PUSH
36404: LD_INT 2
36406: NEG
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 2
36414: PUSH
36415: LD_INT 1
36417: NEG
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: LD_INT 3
36425: PUSH
36426: LD_INT 0
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: LD_INT 3
36435: PUSH
36436: LD_INT 1
36438: PUSH
36439: EMPTY
36440: LIST
36441: LIST
36442: PUSH
36443: LD_INT 1
36445: PUSH
36446: LD_INT 3
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: PUSH
36453: LD_INT 0
36455: PUSH
36456: LD_INT 3
36458: PUSH
36459: EMPTY
36460: LIST
36461: LIST
36462: PUSH
36463: LD_INT 1
36465: NEG
36466: PUSH
36467: LD_INT 2
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: PUSH
36474: LD_INT 2
36476: NEG
36477: PUSH
36478: LD_INT 1
36480: PUSH
36481: EMPTY
36482: LIST
36483: LIST
36484: PUSH
36485: LD_INT 3
36487: NEG
36488: PUSH
36489: LD_INT 0
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 3
36498: NEG
36499: PUSH
36500: LD_INT 1
36502: NEG
36503: PUSH
36504: EMPTY
36505: LIST
36506: LIST
36507: PUSH
36508: EMPTY
36509: LIST
36510: LIST
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: LIST
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: LIST
36522: LIST
36523: LIST
36524: LIST
36525: LIST
36526: LIST
36527: LIST
36528: LIST
36529: LIST
36530: LIST
36531: LIST
36532: LIST
36533: LIST
36534: LIST
36535: LIST
36536: LIST
36537: LIST
36538: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36539: LD_ADDR_VAR 0 47
36543: PUSH
36544: LD_INT 0
36546: PUSH
36547: LD_INT 0
36549: PUSH
36550: EMPTY
36551: LIST
36552: LIST
36553: PUSH
36554: LD_INT 0
36556: PUSH
36557: LD_INT 1
36559: NEG
36560: PUSH
36561: EMPTY
36562: LIST
36563: LIST
36564: PUSH
36565: LD_INT 1
36567: PUSH
36568: LD_INT 0
36570: PUSH
36571: EMPTY
36572: LIST
36573: LIST
36574: PUSH
36575: LD_INT 1
36577: PUSH
36578: LD_INT 1
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 0
36587: PUSH
36588: LD_INT 1
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: PUSH
36595: LD_INT 1
36597: NEG
36598: PUSH
36599: LD_INT 0
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: LD_INT 1
36608: NEG
36609: PUSH
36610: LD_INT 1
36612: NEG
36613: PUSH
36614: EMPTY
36615: LIST
36616: LIST
36617: PUSH
36618: LD_INT 1
36620: NEG
36621: PUSH
36622: LD_INT 2
36624: NEG
36625: PUSH
36626: EMPTY
36627: LIST
36628: LIST
36629: PUSH
36630: LD_INT 0
36632: PUSH
36633: LD_INT 2
36635: NEG
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: LD_INT 1
36643: PUSH
36644: LD_INT 1
36646: NEG
36647: PUSH
36648: EMPTY
36649: LIST
36650: LIST
36651: PUSH
36652: LD_INT 2
36654: NEG
36655: PUSH
36656: LD_INT 1
36658: NEG
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: LD_INT 2
36666: NEG
36667: PUSH
36668: LD_INT 2
36670: NEG
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: EMPTY
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36690: LD_ADDR_VAR 0 48
36694: PUSH
36695: LD_INT 0
36697: PUSH
36698: LD_INT 0
36700: PUSH
36701: EMPTY
36702: LIST
36703: LIST
36704: PUSH
36705: LD_INT 0
36707: PUSH
36708: LD_INT 1
36710: NEG
36711: PUSH
36712: EMPTY
36713: LIST
36714: LIST
36715: PUSH
36716: LD_INT 1
36718: PUSH
36719: LD_INT 0
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PUSH
36726: LD_INT 1
36728: PUSH
36729: LD_INT 1
36731: PUSH
36732: EMPTY
36733: LIST
36734: LIST
36735: PUSH
36736: LD_INT 0
36738: PUSH
36739: LD_INT 1
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: PUSH
36746: LD_INT 1
36748: NEG
36749: PUSH
36750: LD_INT 0
36752: PUSH
36753: EMPTY
36754: LIST
36755: LIST
36756: PUSH
36757: LD_INT 1
36759: NEG
36760: PUSH
36761: LD_INT 1
36763: NEG
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PUSH
36769: LD_INT 1
36771: NEG
36772: PUSH
36773: LD_INT 2
36775: NEG
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 0
36783: PUSH
36784: LD_INT 2
36786: NEG
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 1
36794: PUSH
36795: LD_INT 1
36797: NEG
36798: PUSH
36799: EMPTY
36800: LIST
36801: LIST
36802: PUSH
36803: LD_INT 2
36805: PUSH
36806: LD_INT 0
36808: PUSH
36809: EMPTY
36810: LIST
36811: LIST
36812: PUSH
36813: LD_INT 2
36815: PUSH
36816: LD_INT 1
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: LIST
36827: LIST
36828: LIST
36829: LIST
36830: LIST
36831: LIST
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36837: LD_ADDR_VAR 0 49
36841: PUSH
36842: LD_INT 0
36844: PUSH
36845: LD_INT 0
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 0
36854: PUSH
36855: LD_INT 1
36857: NEG
36858: PUSH
36859: EMPTY
36860: LIST
36861: LIST
36862: PUSH
36863: LD_INT 1
36865: PUSH
36866: LD_INT 0
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PUSH
36873: LD_INT 1
36875: PUSH
36876: LD_INT 1
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 0
36885: PUSH
36886: LD_INT 1
36888: PUSH
36889: EMPTY
36890: LIST
36891: LIST
36892: PUSH
36893: LD_INT 1
36895: NEG
36896: PUSH
36897: LD_INT 0
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 1
36906: NEG
36907: PUSH
36908: LD_INT 1
36910: NEG
36911: PUSH
36912: EMPTY
36913: LIST
36914: LIST
36915: PUSH
36916: LD_INT 1
36918: PUSH
36919: LD_INT 1
36921: NEG
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: LD_INT 2
36929: PUSH
36930: LD_INT 0
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 2
36939: PUSH
36940: LD_INT 1
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 2
36949: PUSH
36950: LD_INT 2
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 1
36959: PUSH
36960: LD_INT 2
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36981: LD_ADDR_VAR 0 50
36985: PUSH
36986: LD_INT 0
36988: PUSH
36989: LD_INT 0
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 0
36998: PUSH
36999: LD_INT 1
37001: NEG
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: PUSH
37007: LD_INT 1
37009: PUSH
37010: LD_INT 0
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 1
37019: PUSH
37020: LD_INT 1
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: LD_INT 0
37029: PUSH
37030: LD_INT 1
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 1
37039: NEG
37040: PUSH
37041: LD_INT 0
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 1
37050: NEG
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 2
37062: PUSH
37063: LD_INT 1
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 2
37072: PUSH
37073: LD_INT 2
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 1
37082: PUSH
37083: LD_INT 2
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 0
37092: PUSH
37093: LD_INT 2
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 1
37102: NEG
37103: PUSH
37104: LD_INT 1
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: PUSH
37111: EMPTY
37112: LIST
37113: LIST
37114: LIST
37115: LIST
37116: LIST
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: LIST
37124: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37125: LD_ADDR_VAR 0 51
37129: PUSH
37130: LD_INT 0
37132: PUSH
37133: LD_INT 0
37135: PUSH
37136: EMPTY
37137: LIST
37138: LIST
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: LD_INT 1
37145: NEG
37146: PUSH
37147: EMPTY
37148: LIST
37149: LIST
37150: PUSH
37151: LD_INT 1
37153: PUSH
37154: LD_INT 0
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 1
37163: PUSH
37164: LD_INT 1
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 0
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PUSH
37181: LD_INT 1
37183: NEG
37184: PUSH
37185: LD_INT 0
37187: PUSH
37188: EMPTY
37189: LIST
37190: LIST
37191: PUSH
37192: LD_INT 1
37194: NEG
37195: PUSH
37196: LD_INT 1
37198: NEG
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 1
37206: PUSH
37207: LD_INT 2
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 0
37216: PUSH
37217: LD_INT 2
37219: PUSH
37220: EMPTY
37221: LIST
37222: LIST
37223: PUSH
37224: LD_INT 1
37226: NEG
37227: PUSH
37228: LD_INT 1
37230: PUSH
37231: EMPTY
37232: LIST
37233: LIST
37234: PUSH
37235: LD_INT 2
37237: NEG
37238: PUSH
37239: LD_INT 0
37241: PUSH
37242: EMPTY
37243: LIST
37244: LIST
37245: PUSH
37246: LD_INT 2
37248: NEG
37249: PUSH
37250: LD_INT 1
37252: NEG
37253: PUSH
37254: EMPTY
37255: LIST
37256: LIST
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: LIST
37262: LIST
37263: LIST
37264: LIST
37265: LIST
37266: LIST
37267: LIST
37268: LIST
37269: LIST
37270: LIST
37271: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37272: LD_ADDR_VAR 0 52
37276: PUSH
37277: LD_INT 0
37279: PUSH
37280: LD_INT 0
37282: PUSH
37283: EMPTY
37284: LIST
37285: LIST
37286: PUSH
37287: LD_INT 0
37289: PUSH
37290: LD_INT 1
37292: NEG
37293: PUSH
37294: EMPTY
37295: LIST
37296: LIST
37297: PUSH
37298: LD_INT 1
37300: PUSH
37301: LD_INT 0
37303: PUSH
37304: EMPTY
37305: LIST
37306: LIST
37307: PUSH
37308: LD_INT 1
37310: PUSH
37311: LD_INT 1
37313: PUSH
37314: EMPTY
37315: LIST
37316: LIST
37317: PUSH
37318: LD_INT 0
37320: PUSH
37321: LD_INT 1
37323: PUSH
37324: EMPTY
37325: LIST
37326: LIST
37327: PUSH
37328: LD_INT 1
37330: NEG
37331: PUSH
37332: LD_INT 0
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: PUSH
37339: LD_INT 1
37341: NEG
37342: PUSH
37343: LD_INT 1
37345: NEG
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: LD_INT 1
37353: NEG
37354: PUSH
37355: LD_INT 2
37357: NEG
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 1
37365: NEG
37366: PUSH
37367: LD_INT 1
37369: PUSH
37370: EMPTY
37371: LIST
37372: LIST
37373: PUSH
37374: LD_INT 2
37376: NEG
37377: PUSH
37378: LD_INT 0
37380: PUSH
37381: EMPTY
37382: LIST
37383: LIST
37384: PUSH
37385: LD_INT 2
37387: NEG
37388: PUSH
37389: LD_INT 1
37391: NEG
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: LD_INT 2
37399: NEG
37400: PUSH
37401: LD_INT 2
37403: NEG
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: PUSH
37409: EMPTY
37410: LIST
37411: LIST
37412: LIST
37413: LIST
37414: LIST
37415: LIST
37416: LIST
37417: LIST
37418: LIST
37419: LIST
37420: LIST
37421: LIST
37422: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37423: LD_ADDR_VAR 0 53
37427: PUSH
37428: LD_INT 0
37430: PUSH
37431: LD_INT 0
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 0
37440: PUSH
37441: LD_INT 1
37443: NEG
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 1
37451: PUSH
37452: LD_INT 0
37454: PUSH
37455: EMPTY
37456: LIST
37457: LIST
37458: PUSH
37459: LD_INT 1
37461: PUSH
37462: LD_INT 1
37464: PUSH
37465: EMPTY
37466: LIST
37467: LIST
37468: PUSH
37469: LD_INT 0
37471: PUSH
37472: LD_INT 1
37474: PUSH
37475: EMPTY
37476: LIST
37477: LIST
37478: PUSH
37479: LD_INT 1
37481: NEG
37482: PUSH
37483: LD_INT 0
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 1
37492: NEG
37493: PUSH
37494: LD_INT 1
37496: NEG
37497: PUSH
37498: EMPTY
37499: LIST
37500: LIST
37501: PUSH
37502: LD_INT 1
37504: NEG
37505: PUSH
37506: LD_INT 2
37508: NEG
37509: PUSH
37510: EMPTY
37511: LIST
37512: LIST
37513: PUSH
37514: LD_INT 0
37516: PUSH
37517: LD_INT 2
37519: NEG
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: PUSH
37525: LD_INT 1
37527: PUSH
37528: LD_INT 1
37530: NEG
37531: PUSH
37532: EMPTY
37533: LIST
37534: LIST
37535: PUSH
37536: LD_INT 2
37538: PUSH
37539: LD_INT 0
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PUSH
37546: LD_INT 2
37548: PUSH
37549: LD_INT 1
37551: PUSH
37552: EMPTY
37553: LIST
37554: LIST
37555: PUSH
37556: LD_INT 2
37558: PUSH
37559: LD_INT 2
37561: PUSH
37562: EMPTY
37563: LIST
37564: LIST
37565: PUSH
37566: LD_INT 1
37568: PUSH
37569: LD_INT 2
37571: PUSH
37572: EMPTY
37573: LIST
37574: LIST
37575: PUSH
37576: LD_INT 0
37578: PUSH
37579: LD_INT 2
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 1
37588: NEG
37589: PUSH
37590: LD_INT 1
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 2
37599: NEG
37600: PUSH
37601: LD_INT 0
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 2
37610: NEG
37611: PUSH
37612: LD_INT 1
37614: NEG
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 2
37622: NEG
37623: PUSH
37624: LD_INT 2
37626: NEG
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: LIST
37636: LIST
37637: LIST
37638: LIST
37639: LIST
37640: LIST
37641: LIST
37642: LIST
37643: LIST
37644: LIST
37645: LIST
37646: LIST
37647: LIST
37648: LIST
37649: LIST
37650: LIST
37651: LIST
37652: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37653: LD_ADDR_VAR 0 54
37657: PUSH
37658: LD_INT 0
37660: PUSH
37661: LD_INT 0
37663: PUSH
37664: EMPTY
37665: LIST
37666: LIST
37667: PUSH
37668: LD_INT 0
37670: PUSH
37671: LD_INT 1
37673: NEG
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 1
37681: PUSH
37682: LD_INT 0
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: LD_INT 1
37691: PUSH
37692: LD_INT 1
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 0
37701: PUSH
37702: LD_INT 1
37704: PUSH
37705: EMPTY
37706: LIST
37707: LIST
37708: PUSH
37709: LD_INT 1
37711: NEG
37712: PUSH
37713: LD_INT 0
37715: PUSH
37716: EMPTY
37717: LIST
37718: LIST
37719: PUSH
37720: LD_INT 1
37722: NEG
37723: PUSH
37724: LD_INT 1
37726: NEG
37727: PUSH
37728: EMPTY
37729: LIST
37730: LIST
37731: PUSH
37732: LD_INT 1
37734: NEG
37735: PUSH
37736: LD_INT 2
37738: NEG
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 0
37746: PUSH
37747: LD_INT 2
37749: NEG
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 1
37757: PUSH
37758: LD_INT 1
37760: NEG
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: LD_INT 2
37768: PUSH
37769: LD_INT 0
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: LD_INT 2
37778: PUSH
37779: LD_INT 1
37781: PUSH
37782: EMPTY
37783: LIST
37784: LIST
37785: PUSH
37786: LD_INT 2
37788: PUSH
37789: LD_INT 2
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: LD_INT 1
37798: PUSH
37799: LD_INT 2
37801: PUSH
37802: EMPTY
37803: LIST
37804: LIST
37805: PUSH
37806: LD_INT 0
37808: PUSH
37809: LD_INT 2
37811: PUSH
37812: EMPTY
37813: LIST
37814: LIST
37815: PUSH
37816: LD_INT 1
37818: NEG
37819: PUSH
37820: LD_INT 1
37822: PUSH
37823: EMPTY
37824: LIST
37825: LIST
37826: PUSH
37827: LD_INT 2
37829: NEG
37830: PUSH
37831: LD_INT 0
37833: PUSH
37834: EMPTY
37835: LIST
37836: LIST
37837: PUSH
37838: LD_INT 2
37840: NEG
37841: PUSH
37842: LD_INT 1
37844: NEG
37845: PUSH
37846: EMPTY
37847: LIST
37848: LIST
37849: PUSH
37850: LD_INT 2
37852: NEG
37853: PUSH
37854: LD_INT 2
37856: NEG
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: PUSH
37862: EMPTY
37863: LIST
37864: LIST
37865: LIST
37866: LIST
37867: LIST
37868: LIST
37869: LIST
37870: LIST
37871: LIST
37872: LIST
37873: LIST
37874: LIST
37875: LIST
37876: LIST
37877: LIST
37878: LIST
37879: LIST
37880: LIST
37881: LIST
37882: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37883: LD_ADDR_VAR 0 55
37887: PUSH
37888: LD_INT 0
37890: PUSH
37891: LD_INT 0
37893: PUSH
37894: EMPTY
37895: LIST
37896: LIST
37897: PUSH
37898: LD_INT 0
37900: PUSH
37901: LD_INT 1
37903: NEG
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 1
37911: PUSH
37912: LD_INT 0
37914: PUSH
37915: EMPTY
37916: LIST
37917: LIST
37918: PUSH
37919: LD_INT 1
37921: PUSH
37922: LD_INT 1
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 0
37931: PUSH
37932: LD_INT 1
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: LD_INT 1
37941: NEG
37942: PUSH
37943: LD_INT 0
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: LD_INT 1
37952: NEG
37953: PUSH
37954: LD_INT 1
37956: NEG
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 1
37964: NEG
37965: PUSH
37966: LD_INT 2
37968: NEG
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: LD_INT 0
37976: PUSH
37977: LD_INT 2
37979: NEG
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 1
37987: PUSH
37988: LD_INT 1
37990: NEG
37991: PUSH
37992: EMPTY
37993: LIST
37994: LIST
37995: PUSH
37996: LD_INT 2
37998: PUSH
37999: LD_INT 0
38001: PUSH
38002: EMPTY
38003: LIST
38004: LIST
38005: PUSH
38006: LD_INT 2
38008: PUSH
38009: LD_INT 1
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: LD_INT 2
38018: PUSH
38019: LD_INT 2
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 1
38028: PUSH
38029: LD_INT 2
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 0
38038: PUSH
38039: LD_INT 2
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: LD_INT 1
38048: NEG
38049: PUSH
38050: LD_INT 1
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PUSH
38057: LD_INT 2
38059: NEG
38060: PUSH
38061: LD_INT 0
38063: PUSH
38064: EMPTY
38065: LIST
38066: LIST
38067: PUSH
38068: LD_INT 2
38070: NEG
38071: PUSH
38072: LD_INT 1
38074: NEG
38075: PUSH
38076: EMPTY
38077: LIST
38078: LIST
38079: PUSH
38080: LD_INT 2
38082: NEG
38083: PUSH
38084: LD_INT 2
38086: NEG
38087: PUSH
38088: EMPTY
38089: LIST
38090: LIST
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: LIST
38096: LIST
38097: LIST
38098: LIST
38099: LIST
38100: LIST
38101: LIST
38102: LIST
38103: LIST
38104: LIST
38105: LIST
38106: LIST
38107: LIST
38108: LIST
38109: LIST
38110: LIST
38111: LIST
38112: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38113: LD_ADDR_VAR 0 56
38117: PUSH
38118: LD_INT 0
38120: PUSH
38121: LD_INT 0
38123: PUSH
38124: EMPTY
38125: LIST
38126: LIST
38127: PUSH
38128: LD_INT 0
38130: PUSH
38131: LD_INT 1
38133: NEG
38134: PUSH
38135: EMPTY
38136: LIST
38137: LIST
38138: PUSH
38139: LD_INT 1
38141: PUSH
38142: LD_INT 0
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 1
38151: PUSH
38152: LD_INT 1
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PUSH
38159: LD_INT 0
38161: PUSH
38162: LD_INT 1
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: LD_INT 1
38171: NEG
38172: PUSH
38173: LD_INT 0
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: LD_INT 1
38182: NEG
38183: PUSH
38184: LD_INT 1
38186: NEG
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 1
38194: NEG
38195: PUSH
38196: LD_INT 2
38198: NEG
38199: PUSH
38200: EMPTY
38201: LIST
38202: LIST
38203: PUSH
38204: LD_INT 0
38206: PUSH
38207: LD_INT 2
38209: NEG
38210: PUSH
38211: EMPTY
38212: LIST
38213: LIST
38214: PUSH
38215: LD_INT 1
38217: PUSH
38218: LD_INT 1
38220: NEG
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: PUSH
38226: LD_INT 2
38228: PUSH
38229: LD_INT 0
38231: PUSH
38232: EMPTY
38233: LIST
38234: LIST
38235: PUSH
38236: LD_INT 2
38238: PUSH
38239: LD_INT 1
38241: PUSH
38242: EMPTY
38243: LIST
38244: LIST
38245: PUSH
38246: LD_INT 2
38248: PUSH
38249: LD_INT 2
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: PUSH
38256: LD_INT 1
38258: PUSH
38259: LD_INT 2
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: LD_INT 0
38268: PUSH
38269: LD_INT 2
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: PUSH
38276: LD_INT 1
38278: NEG
38279: PUSH
38280: LD_INT 1
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: LD_INT 2
38289: NEG
38290: PUSH
38291: LD_INT 0
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 2
38300: NEG
38301: PUSH
38302: LD_INT 1
38304: NEG
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 2
38312: NEG
38313: PUSH
38314: LD_INT 2
38316: NEG
38317: PUSH
38318: EMPTY
38319: LIST
38320: LIST
38321: PUSH
38322: EMPTY
38323: LIST
38324: LIST
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38343: LD_ADDR_VAR 0 57
38347: PUSH
38348: LD_INT 0
38350: PUSH
38351: LD_INT 0
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 0
38360: PUSH
38361: LD_INT 1
38363: NEG
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 1
38371: PUSH
38372: LD_INT 0
38374: PUSH
38375: EMPTY
38376: LIST
38377: LIST
38378: PUSH
38379: LD_INT 1
38381: PUSH
38382: LD_INT 1
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: LD_INT 0
38391: PUSH
38392: LD_INT 1
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: PUSH
38399: LD_INT 1
38401: NEG
38402: PUSH
38403: LD_INT 0
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 1
38412: NEG
38413: PUSH
38414: LD_INT 1
38416: NEG
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 1
38424: NEG
38425: PUSH
38426: LD_INT 2
38428: NEG
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 0
38436: PUSH
38437: LD_INT 2
38439: NEG
38440: PUSH
38441: EMPTY
38442: LIST
38443: LIST
38444: PUSH
38445: LD_INT 1
38447: PUSH
38448: LD_INT 1
38450: NEG
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PUSH
38456: LD_INT 2
38458: PUSH
38459: LD_INT 0
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PUSH
38466: LD_INT 2
38468: PUSH
38469: LD_INT 1
38471: PUSH
38472: EMPTY
38473: LIST
38474: LIST
38475: PUSH
38476: LD_INT 2
38478: PUSH
38479: LD_INT 2
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: LD_INT 1
38488: PUSH
38489: LD_INT 2
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: PUSH
38496: LD_INT 0
38498: PUSH
38499: LD_INT 2
38501: PUSH
38502: EMPTY
38503: LIST
38504: LIST
38505: PUSH
38506: LD_INT 1
38508: NEG
38509: PUSH
38510: LD_INT 1
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: PUSH
38517: LD_INT 2
38519: NEG
38520: PUSH
38521: LD_INT 0
38523: PUSH
38524: EMPTY
38525: LIST
38526: LIST
38527: PUSH
38528: LD_INT 2
38530: NEG
38531: PUSH
38532: LD_INT 1
38534: NEG
38535: PUSH
38536: EMPTY
38537: LIST
38538: LIST
38539: PUSH
38540: LD_INT 2
38542: NEG
38543: PUSH
38544: LD_INT 2
38546: NEG
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: LIST
38556: LIST
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: LIST
38564: LIST
38565: LIST
38566: LIST
38567: LIST
38568: LIST
38569: LIST
38570: LIST
38571: LIST
38572: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38573: LD_ADDR_VAR 0 58
38577: PUSH
38578: LD_INT 0
38580: PUSH
38581: LD_INT 0
38583: PUSH
38584: EMPTY
38585: LIST
38586: LIST
38587: PUSH
38588: LD_INT 0
38590: PUSH
38591: LD_INT 1
38593: NEG
38594: PUSH
38595: EMPTY
38596: LIST
38597: LIST
38598: PUSH
38599: LD_INT 1
38601: PUSH
38602: LD_INT 0
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: LD_INT 1
38611: PUSH
38612: LD_INT 1
38614: PUSH
38615: EMPTY
38616: LIST
38617: LIST
38618: PUSH
38619: LD_INT 0
38621: PUSH
38622: LD_INT 1
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: PUSH
38629: LD_INT 1
38631: NEG
38632: PUSH
38633: LD_INT 0
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: PUSH
38640: LD_INT 1
38642: NEG
38643: PUSH
38644: LD_INT 1
38646: NEG
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: PUSH
38652: LD_INT 1
38654: NEG
38655: PUSH
38656: LD_INT 2
38658: NEG
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: PUSH
38664: LD_INT 0
38666: PUSH
38667: LD_INT 2
38669: NEG
38670: PUSH
38671: EMPTY
38672: LIST
38673: LIST
38674: PUSH
38675: LD_INT 1
38677: PUSH
38678: LD_INT 1
38680: NEG
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: LD_INT 2
38688: PUSH
38689: LD_INT 0
38691: PUSH
38692: EMPTY
38693: LIST
38694: LIST
38695: PUSH
38696: LD_INT 2
38698: PUSH
38699: LD_INT 1
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 2
38708: PUSH
38709: LD_INT 2
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 1
38718: PUSH
38719: LD_INT 2
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: LD_INT 0
38728: PUSH
38729: LD_INT 2
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 1
38738: NEG
38739: PUSH
38740: LD_INT 1
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 2
38749: NEG
38750: PUSH
38751: LD_INT 0
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: PUSH
38758: LD_INT 2
38760: NEG
38761: PUSH
38762: LD_INT 1
38764: NEG
38765: PUSH
38766: EMPTY
38767: LIST
38768: LIST
38769: PUSH
38770: LD_INT 2
38772: NEG
38773: PUSH
38774: LD_INT 2
38776: NEG
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: LIST
38786: LIST
38787: LIST
38788: LIST
38789: LIST
38790: LIST
38791: LIST
38792: LIST
38793: LIST
38794: LIST
38795: LIST
38796: LIST
38797: LIST
38798: LIST
38799: LIST
38800: LIST
38801: LIST
38802: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38803: LD_ADDR_VAR 0 59
38807: PUSH
38808: LD_INT 0
38810: PUSH
38811: LD_INT 0
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: LD_INT 0
38820: PUSH
38821: LD_INT 1
38823: NEG
38824: PUSH
38825: EMPTY
38826: LIST
38827: LIST
38828: PUSH
38829: LD_INT 1
38831: PUSH
38832: LD_INT 0
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: PUSH
38839: LD_INT 1
38841: PUSH
38842: LD_INT 1
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: PUSH
38849: LD_INT 0
38851: PUSH
38852: LD_INT 1
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 1
38861: NEG
38862: PUSH
38863: LD_INT 0
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: LD_INT 1
38872: NEG
38873: PUSH
38874: LD_INT 1
38876: NEG
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38891: LD_ADDR_VAR 0 60
38895: PUSH
38896: LD_INT 0
38898: PUSH
38899: LD_INT 0
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: PUSH
38906: LD_INT 0
38908: PUSH
38909: LD_INT 1
38911: NEG
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: LD_INT 1
38919: PUSH
38920: LD_INT 0
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PUSH
38927: LD_INT 1
38929: PUSH
38930: LD_INT 1
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: LD_INT 0
38939: PUSH
38940: LD_INT 1
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: LD_INT 1
38949: NEG
38950: PUSH
38951: LD_INT 0
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 1
38960: NEG
38961: PUSH
38962: LD_INT 1
38964: NEG
38965: PUSH
38966: EMPTY
38967: LIST
38968: LIST
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: LIST
38974: LIST
38975: LIST
38976: LIST
38977: LIST
38978: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38979: LD_ADDR_VAR 0 61
38983: PUSH
38984: LD_INT 0
38986: PUSH
38987: LD_INT 0
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PUSH
38994: LD_INT 0
38996: PUSH
38997: LD_INT 1
38999: NEG
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: LD_INT 1
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 1
39017: PUSH
39018: LD_INT 1
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 0
39027: PUSH
39028: LD_INT 1
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 1
39037: NEG
39038: PUSH
39039: LD_INT 0
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 1
39048: NEG
39049: PUSH
39050: LD_INT 1
39052: NEG
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39067: LD_ADDR_VAR 0 62
39071: PUSH
39072: LD_INT 0
39074: PUSH
39075: LD_INT 0
39077: PUSH
39078: EMPTY
39079: LIST
39080: LIST
39081: PUSH
39082: LD_INT 0
39084: PUSH
39085: LD_INT 1
39087: NEG
39088: PUSH
39089: EMPTY
39090: LIST
39091: LIST
39092: PUSH
39093: LD_INT 1
39095: PUSH
39096: LD_INT 0
39098: PUSH
39099: EMPTY
39100: LIST
39101: LIST
39102: PUSH
39103: LD_INT 1
39105: PUSH
39106: LD_INT 1
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: LD_INT 0
39115: PUSH
39116: LD_INT 1
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PUSH
39123: LD_INT 1
39125: NEG
39126: PUSH
39127: LD_INT 0
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 1
39136: NEG
39137: PUSH
39138: LD_INT 1
39140: NEG
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: LIST
39150: LIST
39151: LIST
39152: LIST
39153: LIST
39154: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39155: LD_ADDR_VAR 0 63
39159: PUSH
39160: LD_INT 0
39162: PUSH
39163: LD_INT 0
39165: PUSH
39166: EMPTY
39167: LIST
39168: LIST
39169: PUSH
39170: LD_INT 0
39172: PUSH
39173: LD_INT 1
39175: NEG
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: PUSH
39181: LD_INT 1
39183: PUSH
39184: LD_INT 0
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: PUSH
39191: LD_INT 1
39193: PUSH
39194: LD_INT 1
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 0
39203: PUSH
39204: LD_INT 1
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PUSH
39211: LD_INT 1
39213: NEG
39214: PUSH
39215: LD_INT 0
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PUSH
39222: LD_INT 1
39224: NEG
39225: PUSH
39226: LD_INT 1
39228: NEG
39229: PUSH
39230: EMPTY
39231: LIST
39232: LIST
39233: PUSH
39234: EMPTY
39235: LIST
39236: LIST
39237: LIST
39238: LIST
39239: LIST
39240: LIST
39241: LIST
39242: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39243: LD_ADDR_VAR 0 64
39247: PUSH
39248: LD_INT 0
39250: PUSH
39251: LD_INT 0
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 0
39260: PUSH
39261: LD_INT 1
39263: NEG
39264: PUSH
39265: EMPTY
39266: LIST
39267: LIST
39268: PUSH
39269: LD_INT 1
39271: PUSH
39272: LD_INT 0
39274: PUSH
39275: EMPTY
39276: LIST
39277: LIST
39278: PUSH
39279: LD_INT 1
39281: PUSH
39282: LD_INT 1
39284: PUSH
39285: EMPTY
39286: LIST
39287: LIST
39288: PUSH
39289: LD_INT 0
39291: PUSH
39292: LD_INT 1
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: LD_INT 1
39301: NEG
39302: PUSH
39303: LD_INT 0
39305: PUSH
39306: EMPTY
39307: LIST
39308: LIST
39309: PUSH
39310: LD_INT 1
39312: NEG
39313: PUSH
39314: LD_INT 1
39316: NEG
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: LIST
39326: LIST
39327: LIST
39328: LIST
39329: LIST
39330: ST_TO_ADDR
// end ; 1 :
39331: GO 45228
39333: LD_INT 1
39335: DOUBLE
39336: EQUAL
39337: IFTRUE 39341
39339: GO 41964
39341: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39342: LD_ADDR_VAR 0 11
39346: PUSH
39347: LD_INT 1
39349: NEG
39350: PUSH
39351: LD_INT 3
39353: NEG
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: LD_INT 0
39361: PUSH
39362: LD_INT 3
39364: NEG
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: LD_INT 1
39372: PUSH
39373: LD_INT 2
39375: NEG
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: LIST
39385: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39386: LD_ADDR_VAR 0 12
39390: PUSH
39391: LD_INT 2
39393: PUSH
39394: LD_INT 1
39396: NEG
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: LD_INT 3
39404: PUSH
39405: LD_INT 0
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 3
39414: PUSH
39415: LD_INT 1
39417: PUSH
39418: EMPTY
39419: LIST
39420: LIST
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: LIST
39426: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39427: LD_ADDR_VAR 0 13
39431: PUSH
39432: LD_INT 3
39434: PUSH
39435: LD_INT 2
39437: PUSH
39438: EMPTY
39439: LIST
39440: LIST
39441: PUSH
39442: LD_INT 3
39444: PUSH
39445: LD_INT 3
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 2
39454: PUSH
39455: LD_INT 3
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PUSH
39462: EMPTY
39463: LIST
39464: LIST
39465: LIST
39466: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39467: LD_ADDR_VAR 0 14
39471: PUSH
39472: LD_INT 1
39474: PUSH
39475: LD_INT 3
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 0
39484: PUSH
39485: LD_INT 3
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 1
39494: NEG
39495: PUSH
39496: LD_INT 2
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: LIST
39507: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39508: LD_ADDR_VAR 0 15
39512: PUSH
39513: LD_INT 2
39515: NEG
39516: PUSH
39517: LD_INT 1
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: LD_INT 3
39526: NEG
39527: PUSH
39528: LD_INT 0
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: LD_INT 3
39537: NEG
39538: PUSH
39539: LD_INT 1
39541: NEG
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: LIST
39551: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39552: LD_ADDR_VAR 0 16
39556: PUSH
39557: LD_INT 2
39559: NEG
39560: PUSH
39561: LD_INT 3
39563: NEG
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: PUSH
39569: LD_INT 3
39571: NEG
39572: PUSH
39573: LD_INT 2
39575: NEG
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: LD_INT 3
39583: NEG
39584: PUSH
39585: LD_INT 3
39587: NEG
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: LIST
39597: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39598: LD_ADDR_VAR 0 17
39602: PUSH
39603: LD_INT 1
39605: NEG
39606: PUSH
39607: LD_INT 3
39609: NEG
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 0
39617: PUSH
39618: LD_INT 3
39620: NEG
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: LD_INT 1
39628: PUSH
39629: LD_INT 2
39631: NEG
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: LIST
39641: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39642: LD_ADDR_VAR 0 18
39646: PUSH
39647: LD_INT 2
39649: PUSH
39650: LD_INT 1
39652: NEG
39653: PUSH
39654: EMPTY
39655: LIST
39656: LIST
39657: PUSH
39658: LD_INT 3
39660: PUSH
39661: LD_INT 0
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PUSH
39668: LD_INT 3
39670: PUSH
39671: LD_INT 1
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: LIST
39682: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39683: LD_ADDR_VAR 0 19
39687: PUSH
39688: LD_INT 3
39690: PUSH
39691: LD_INT 2
39693: PUSH
39694: EMPTY
39695: LIST
39696: LIST
39697: PUSH
39698: LD_INT 3
39700: PUSH
39701: LD_INT 3
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: LD_INT 2
39710: PUSH
39711: LD_INT 3
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: LIST
39722: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39723: LD_ADDR_VAR 0 20
39727: PUSH
39728: LD_INT 1
39730: PUSH
39731: LD_INT 3
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 0
39740: PUSH
39741: LD_INT 3
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: PUSH
39748: LD_INT 1
39750: NEG
39751: PUSH
39752: LD_INT 2
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: EMPTY
39760: LIST
39761: LIST
39762: LIST
39763: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39764: LD_ADDR_VAR 0 21
39768: PUSH
39769: LD_INT 2
39771: NEG
39772: PUSH
39773: LD_INT 1
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 3
39782: NEG
39783: PUSH
39784: LD_INT 0
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 3
39793: NEG
39794: PUSH
39795: LD_INT 1
39797: NEG
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: LIST
39807: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39808: LD_ADDR_VAR 0 22
39812: PUSH
39813: LD_INT 2
39815: NEG
39816: PUSH
39817: LD_INT 3
39819: NEG
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: LD_INT 3
39827: NEG
39828: PUSH
39829: LD_INT 2
39831: NEG
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 3
39839: NEG
39840: PUSH
39841: LD_INT 3
39843: NEG
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: EMPTY
39850: LIST
39851: LIST
39852: LIST
39853: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39854: LD_ADDR_VAR 0 23
39858: PUSH
39859: LD_INT 0
39861: PUSH
39862: LD_INT 3
39864: NEG
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: PUSH
39870: LD_INT 1
39872: NEG
39873: PUSH
39874: LD_INT 4
39876: NEG
39877: PUSH
39878: EMPTY
39879: LIST
39880: LIST
39881: PUSH
39882: LD_INT 1
39884: PUSH
39885: LD_INT 3
39887: NEG
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: LIST
39897: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39898: LD_ADDR_VAR 0 24
39902: PUSH
39903: LD_INT 3
39905: PUSH
39906: LD_INT 0
39908: PUSH
39909: EMPTY
39910: LIST
39911: LIST
39912: PUSH
39913: LD_INT 3
39915: PUSH
39916: LD_INT 1
39918: NEG
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PUSH
39924: LD_INT 4
39926: PUSH
39927: LD_INT 1
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: LIST
39938: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39939: LD_ADDR_VAR 0 25
39943: PUSH
39944: LD_INT 3
39946: PUSH
39947: LD_INT 3
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: LD_INT 4
39956: PUSH
39957: LD_INT 3
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 3
39966: PUSH
39967: LD_INT 4
39969: PUSH
39970: EMPTY
39971: LIST
39972: LIST
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: LIST
39978: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39979: LD_ADDR_VAR 0 26
39983: PUSH
39984: LD_INT 0
39986: PUSH
39987: LD_INT 3
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: PUSH
39994: LD_INT 1
39996: PUSH
39997: LD_INT 4
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: PUSH
40004: LD_INT 1
40006: NEG
40007: PUSH
40008: LD_INT 3
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: EMPTY
40016: LIST
40017: LIST
40018: LIST
40019: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40020: LD_ADDR_VAR 0 27
40024: PUSH
40025: LD_INT 3
40027: NEG
40028: PUSH
40029: LD_INT 0
40031: PUSH
40032: EMPTY
40033: LIST
40034: LIST
40035: PUSH
40036: LD_INT 3
40038: NEG
40039: PUSH
40040: LD_INT 1
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 4
40049: NEG
40050: PUSH
40051: LD_INT 1
40053: NEG
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PUSH
40059: EMPTY
40060: LIST
40061: LIST
40062: LIST
40063: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40064: LD_ADDR_VAR 0 28
40068: PUSH
40069: LD_INT 3
40071: NEG
40072: PUSH
40073: LD_INT 3
40075: NEG
40076: PUSH
40077: EMPTY
40078: LIST
40079: LIST
40080: PUSH
40081: LD_INT 3
40083: NEG
40084: PUSH
40085: LD_INT 4
40087: NEG
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 4
40095: NEG
40096: PUSH
40097: LD_INT 3
40099: NEG
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: LIST
40109: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40110: LD_ADDR_VAR 0 29
40114: PUSH
40115: LD_INT 1
40117: NEG
40118: PUSH
40119: LD_INT 3
40121: NEG
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: LD_INT 0
40129: PUSH
40130: LD_INT 3
40132: NEG
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: LD_INT 1
40140: PUSH
40141: LD_INT 2
40143: NEG
40144: PUSH
40145: EMPTY
40146: LIST
40147: LIST
40148: PUSH
40149: LD_INT 1
40151: NEG
40152: PUSH
40153: LD_INT 4
40155: NEG
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PUSH
40161: LD_INT 0
40163: PUSH
40164: LD_INT 4
40166: NEG
40167: PUSH
40168: EMPTY
40169: LIST
40170: LIST
40171: PUSH
40172: LD_INT 1
40174: PUSH
40175: LD_INT 3
40177: NEG
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: LD_INT 1
40185: NEG
40186: PUSH
40187: LD_INT 5
40189: NEG
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: LD_INT 0
40197: PUSH
40198: LD_INT 5
40200: NEG
40201: PUSH
40202: EMPTY
40203: LIST
40204: LIST
40205: PUSH
40206: LD_INT 1
40208: PUSH
40209: LD_INT 4
40211: NEG
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 1
40219: NEG
40220: PUSH
40221: LD_INT 6
40223: NEG
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 0
40231: PUSH
40232: LD_INT 6
40234: NEG
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PUSH
40240: LD_INT 1
40242: PUSH
40243: LD_INT 5
40245: NEG
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: LIST
40255: LIST
40256: LIST
40257: LIST
40258: LIST
40259: LIST
40260: LIST
40261: LIST
40262: LIST
40263: LIST
40264: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40265: LD_ADDR_VAR 0 30
40269: PUSH
40270: LD_INT 2
40272: PUSH
40273: LD_INT 1
40275: NEG
40276: PUSH
40277: EMPTY
40278: LIST
40279: LIST
40280: PUSH
40281: LD_INT 3
40283: PUSH
40284: LD_INT 0
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 3
40293: PUSH
40294: LD_INT 1
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 3
40303: PUSH
40304: LD_INT 1
40306: NEG
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PUSH
40312: LD_INT 4
40314: PUSH
40315: LD_INT 0
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 4
40324: PUSH
40325: LD_INT 1
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 4
40334: PUSH
40335: LD_INT 1
40337: NEG
40338: PUSH
40339: EMPTY
40340: LIST
40341: LIST
40342: PUSH
40343: LD_INT 5
40345: PUSH
40346: LD_INT 0
40348: PUSH
40349: EMPTY
40350: LIST
40351: LIST
40352: PUSH
40353: LD_INT 5
40355: PUSH
40356: LD_INT 1
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: PUSH
40363: LD_INT 5
40365: PUSH
40366: LD_INT 1
40368: NEG
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 6
40376: PUSH
40377: LD_INT 0
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: LD_INT 6
40386: PUSH
40387: LD_INT 1
40389: PUSH
40390: EMPTY
40391: LIST
40392: LIST
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: LIST
40405: LIST
40406: LIST
40407: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40408: LD_ADDR_VAR 0 31
40412: PUSH
40413: LD_INT 3
40415: PUSH
40416: LD_INT 2
40418: PUSH
40419: EMPTY
40420: LIST
40421: LIST
40422: PUSH
40423: LD_INT 3
40425: PUSH
40426: LD_INT 3
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 2
40435: PUSH
40436: LD_INT 3
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: PUSH
40443: LD_INT 4
40445: PUSH
40446: LD_INT 3
40448: PUSH
40449: EMPTY
40450: LIST
40451: LIST
40452: PUSH
40453: LD_INT 4
40455: PUSH
40456: LD_INT 4
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: PUSH
40463: LD_INT 3
40465: PUSH
40466: LD_INT 4
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: PUSH
40473: LD_INT 5
40475: PUSH
40476: LD_INT 4
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: LD_INT 5
40485: PUSH
40486: LD_INT 5
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: PUSH
40493: LD_INT 4
40495: PUSH
40496: LD_INT 5
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: PUSH
40503: LD_INT 6
40505: PUSH
40506: LD_INT 5
40508: PUSH
40509: EMPTY
40510: LIST
40511: LIST
40512: PUSH
40513: LD_INT 6
40515: PUSH
40516: LD_INT 6
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: LD_INT 5
40525: PUSH
40526: LD_INT 6
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40547: LD_ADDR_VAR 0 32
40551: PUSH
40552: LD_INT 1
40554: PUSH
40555: LD_INT 3
40557: PUSH
40558: EMPTY
40559: LIST
40560: LIST
40561: PUSH
40562: LD_INT 0
40564: PUSH
40565: LD_INT 3
40567: PUSH
40568: EMPTY
40569: LIST
40570: LIST
40571: PUSH
40572: LD_INT 1
40574: NEG
40575: PUSH
40576: LD_INT 2
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PUSH
40583: LD_INT 1
40585: PUSH
40586: LD_INT 4
40588: PUSH
40589: EMPTY
40590: LIST
40591: LIST
40592: PUSH
40593: LD_INT 0
40595: PUSH
40596: LD_INT 4
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: LD_INT 1
40605: NEG
40606: PUSH
40607: LD_INT 3
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 1
40616: PUSH
40617: LD_INT 5
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 0
40626: PUSH
40627: LD_INT 5
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: LD_INT 1
40636: NEG
40637: PUSH
40638: LD_INT 4
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 1
40647: PUSH
40648: LD_INT 6
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 0
40657: PUSH
40658: LD_INT 6
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 1
40667: NEG
40668: PUSH
40669: LD_INT 5
40671: PUSH
40672: EMPTY
40673: LIST
40674: LIST
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: LIST
40680: LIST
40681: LIST
40682: LIST
40683: LIST
40684: LIST
40685: LIST
40686: LIST
40687: LIST
40688: LIST
40689: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40690: LD_ADDR_VAR 0 33
40694: PUSH
40695: LD_INT 2
40697: NEG
40698: PUSH
40699: LD_INT 1
40701: PUSH
40702: EMPTY
40703: LIST
40704: LIST
40705: PUSH
40706: LD_INT 3
40708: NEG
40709: PUSH
40710: LD_INT 0
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 3
40719: NEG
40720: PUSH
40721: LD_INT 1
40723: NEG
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: PUSH
40729: LD_INT 3
40731: NEG
40732: PUSH
40733: LD_INT 1
40735: PUSH
40736: EMPTY
40737: LIST
40738: LIST
40739: PUSH
40740: LD_INT 4
40742: NEG
40743: PUSH
40744: LD_INT 0
40746: PUSH
40747: EMPTY
40748: LIST
40749: LIST
40750: PUSH
40751: LD_INT 4
40753: NEG
40754: PUSH
40755: LD_INT 1
40757: NEG
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 4
40765: NEG
40766: PUSH
40767: LD_INT 1
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 5
40776: NEG
40777: PUSH
40778: LD_INT 0
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: LD_INT 5
40787: NEG
40788: PUSH
40789: LD_INT 1
40791: NEG
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 5
40799: NEG
40800: PUSH
40801: LD_INT 1
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 6
40810: NEG
40811: PUSH
40812: LD_INT 0
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: PUSH
40819: LD_INT 6
40821: NEG
40822: PUSH
40823: LD_INT 1
40825: NEG
40826: PUSH
40827: EMPTY
40828: LIST
40829: LIST
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: LIST
40835: LIST
40836: LIST
40837: LIST
40838: LIST
40839: LIST
40840: LIST
40841: LIST
40842: LIST
40843: LIST
40844: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40845: LD_ADDR_VAR 0 34
40849: PUSH
40850: LD_INT 2
40852: NEG
40853: PUSH
40854: LD_INT 3
40856: NEG
40857: PUSH
40858: EMPTY
40859: LIST
40860: LIST
40861: PUSH
40862: LD_INT 3
40864: NEG
40865: PUSH
40866: LD_INT 2
40868: NEG
40869: PUSH
40870: EMPTY
40871: LIST
40872: LIST
40873: PUSH
40874: LD_INT 3
40876: NEG
40877: PUSH
40878: LD_INT 3
40880: NEG
40881: PUSH
40882: EMPTY
40883: LIST
40884: LIST
40885: PUSH
40886: LD_INT 3
40888: NEG
40889: PUSH
40890: LD_INT 4
40892: NEG
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: LD_INT 4
40900: NEG
40901: PUSH
40902: LD_INT 3
40904: NEG
40905: PUSH
40906: EMPTY
40907: LIST
40908: LIST
40909: PUSH
40910: LD_INT 4
40912: NEG
40913: PUSH
40914: LD_INT 4
40916: NEG
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: PUSH
40922: LD_INT 4
40924: NEG
40925: PUSH
40926: LD_INT 5
40928: NEG
40929: PUSH
40930: EMPTY
40931: LIST
40932: LIST
40933: PUSH
40934: LD_INT 5
40936: NEG
40937: PUSH
40938: LD_INT 4
40940: NEG
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: PUSH
40946: LD_INT 5
40948: NEG
40949: PUSH
40950: LD_INT 5
40952: NEG
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: PUSH
40958: LD_INT 5
40960: NEG
40961: PUSH
40962: LD_INT 6
40964: NEG
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PUSH
40970: LD_INT 6
40972: NEG
40973: PUSH
40974: LD_INT 5
40976: NEG
40977: PUSH
40978: EMPTY
40979: LIST
40980: LIST
40981: PUSH
40982: LD_INT 6
40984: NEG
40985: PUSH
40986: LD_INT 6
40988: NEG
40989: PUSH
40990: EMPTY
40991: LIST
40992: LIST
40993: PUSH
40994: EMPTY
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41008: LD_ADDR_VAR 0 41
41012: PUSH
41013: LD_INT 0
41015: PUSH
41016: LD_INT 2
41018: NEG
41019: PUSH
41020: EMPTY
41021: LIST
41022: LIST
41023: PUSH
41024: LD_INT 1
41026: NEG
41027: PUSH
41028: LD_INT 3
41030: NEG
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 1
41038: PUSH
41039: LD_INT 2
41041: NEG
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: LIST
41051: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41052: LD_ADDR_VAR 0 42
41056: PUSH
41057: LD_INT 2
41059: PUSH
41060: LD_INT 0
41062: PUSH
41063: EMPTY
41064: LIST
41065: LIST
41066: PUSH
41067: LD_INT 2
41069: PUSH
41070: LD_INT 1
41072: NEG
41073: PUSH
41074: EMPTY
41075: LIST
41076: LIST
41077: PUSH
41078: LD_INT 3
41080: PUSH
41081: LD_INT 1
41083: PUSH
41084: EMPTY
41085: LIST
41086: LIST
41087: PUSH
41088: EMPTY
41089: LIST
41090: LIST
41091: LIST
41092: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41093: LD_ADDR_VAR 0 43
41097: PUSH
41098: LD_INT 2
41100: PUSH
41101: LD_INT 2
41103: PUSH
41104: EMPTY
41105: LIST
41106: LIST
41107: PUSH
41108: LD_INT 3
41110: PUSH
41111: LD_INT 2
41113: PUSH
41114: EMPTY
41115: LIST
41116: LIST
41117: PUSH
41118: LD_INT 2
41120: PUSH
41121: LD_INT 3
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: LIST
41132: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41133: LD_ADDR_VAR 0 44
41137: PUSH
41138: LD_INT 0
41140: PUSH
41141: LD_INT 2
41143: PUSH
41144: EMPTY
41145: LIST
41146: LIST
41147: PUSH
41148: LD_INT 1
41150: PUSH
41151: LD_INT 3
41153: PUSH
41154: EMPTY
41155: LIST
41156: LIST
41157: PUSH
41158: LD_INT 1
41160: NEG
41161: PUSH
41162: LD_INT 2
41164: PUSH
41165: EMPTY
41166: LIST
41167: LIST
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: LIST
41173: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41174: LD_ADDR_VAR 0 45
41178: PUSH
41179: LD_INT 2
41181: NEG
41182: PUSH
41183: LD_INT 0
41185: PUSH
41186: EMPTY
41187: LIST
41188: LIST
41189: PUSH
41190: LD_INT 2
41192: NEG
41193: PUSH
41194: LD_INT 1
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: LD_INT 3
41203: NEG
41204: PUSH
41205: LD_INT 1
41207: NEG
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: LIST
41217: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41218: LD_ADDR_VAR 0 46
41222: PUSH
41223: LD_INT 2
41225: NEG
41226: PUSH
41227: LD_INT 2
41229: NEG
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: LD_INT 2
41237: NEG
41238: PUSH
41239: LD_INT 3
41241: NEG
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 3
41249: NEG
41250: PUSH
41251: LD_INT 2
41253: NEG
41254: PUSH
41255: EMPTY
41256: LIST
41257: LIST
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: LIST
41263: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41264: LD_ADDR_VAR 0 47
41268: PUSH
41269: LD_INT 2
41271: NEG
41272: PUSH
41273: LD_INT 3
41275: NEG
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 1
41283: NEG
41284: PUSH
41285: LD_INT 3
41287: NEG
41288: PUSH
41289: EMPTY
41290: LIST
41291: LIST
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41297: LD_ADDR_VAR 0 48
41301: PUSH
41302: LD_INT 1
41304: PUSH
41305: LD_INT 2
41307: NEG
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: PUSH
41313: LD_INT 2
41315: PUSH
41316: LD_INT 1
41318: NEG
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41328: LD_ADDR_VAR 0 49
41332: PUSH
41333: LD_INT 3
41335: PUSH
41336: LD_INT 1
41338: PUSH
41339: EMPTY
41340: LIST
41341: LIST
41342: PUSH
41343: LD_INT 3
41345: PUSH
41346: LD_INT 2
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41357: LD_ADDR_VAR 0 50
41361: PUSH
41362: LD_INT 2
41364: PUSH
41365: LD_INT 3
41367: PUSH
41368: EMPTY
41369: LIST
41370: LIST
41371: PUSH
41372: LD_INT 1
41374: PUSH
41375: LD_INT 3
41377: PUSH
41378: EMPTY
41379: LIST
41380: LIST
41381: PUSH
41382: EMPTY
41383: LIST
41384: LIST
41385: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41386: LD_ADDR_VAR 0 51
41390: PUSH
41391: LD_INT 1
41393: NEG
41394: PUSH
41395: LD_INT 2
41397: PUSH
41398: EMPTY
41399: LIST
41400: LIST
41401: PUSH
41402: LD_INT 2
41404: NEG
41405: PUSH
41406: LD_INT 1
41408: PUSH
41409: EMPTY
41410: LIST
41411: LIST
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41417: LD_ADDR_VAR 0 52
41421: PUSH
41422: LD_INT 3
41424: NEG
41425: PUSH
41426: LD_INT 1
41428: NEG
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: PUSH
41434: LD_INT 3
41436: NEG
41437: PUSH
41438: LD_INT 2
41440: NEG
41441: PUSH
41442: EMPTY
41443: LIST
41444: LIST
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41450: LD_ADDR_VAR 0 53
41454: PUSH
41455: LD_INT 1
41457: NEG
41458: PUSH
41459: LD_INT 3
41461: NEG
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: LD_INT 0
41469: PUSH
41470: LD_INT 3
41472: NEG
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 1
41480: PUSH
41481: LD_INT 2
41483: NEG
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: EMPTY
41490: LIST
41491: LIST
41492: LIST
41493: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41494: LD_ADDR_VAR 0 54
41498: PUSH
41499: LD_INT 2
41501: PUSH
41502: LD_INT 1
41504: NEG
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: LD_INT 3
41512: PUSH
41513: LD_INT 0
41515: PUSH
41516: EMPTY
41517: LIST
41518: LIST
41519: PUSH
41520: LD_INT 3
41522: PUSH
41523: LD_INT 1
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: LIST
41534: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41535: LD_ADDR_VAR 0 55
41539: PUSH
41540: LD_INT 3
41542: PUSH
41543: LD_INT 2
41545: PUSH
41546: EMPTY
41547: LIST
41548: LIST
41549: PUSH
41550: LD_INT 3
41552: PUSH
41553: LD_INT 3
41555: PUSH
41556: EMPTY
41557: LIST
41558: LIST
41559: PUSH
41560: LD_INT 2
41562: PUSH
41563: LD_INT 3
41565: PUSH
41566: EMPTY
41567: LIST
41568: LIST
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: LIST
41574: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41575: LD_ADDR_VAR 0 56
41579: PUSH
41580: LD_INT 1
41582: PUSH
41583: LD_INT 3
41585: PUSH
41586: EMPTY
41587: LIST
41588: LIST
41589: PUSH
41590: LD_INT 0
41592: PUSH
41593: LD_INT 3
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: PUSH
41600: LD_INT 1
41602: NEG
41603: PUSH
41604: LD_INT 2
41606: PUSH
41607: EMPTY
41608: LIST
41609: LIST
41610: PUSH
41611: EMPTY
41612: LIST
41613: LIST
41614: LIST
41615: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41616: LD_ADDR_VAR 0 57
41620: PUSH
41621: LD_INT 2
41623: NEG
41624: PUSH
41625: LD_INT 1
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: LD_INT 3
41634: NEG
41635: PUSH
41636: LD_INT 0
41638: PUSH
41639: EMPTY
41640: LIST
41641: LIST
41642: PUSH
41643: LD_INT 3
41645: NEG
41646: PUSH
41647: LD_INT 1
41649: NEG
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: LIST
41659: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41660: LD_ADDR_VAR 0 58
41664: PUSH
41665: LD_INT 2
41667: NEG
41668: PUSH
41669: LD_INT 3
41671: NEG
41672: PUSH
41673: EMPTY
41674: LIST
41675: LIST
41676: PUSH
41677: LD_INT 3
41679: NEG
41680: PUSH
41681: LD_INT 2
41683: NEG
41684: PUSH
41685: EMPTY
41686: LIST
41687: LIST
41688: PUSH
41689: LD_INT 3
41691: NEG
41692: PUSH
41693: LD_INT 3
41695: NEG
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: PUSH
41701: EMPTY
41702: LIST
41703: LIST
41704: LIST
41705: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41706: LD_ADDR_VAR 0 59
41710: PUSH
41711: LD_INT 1
41713: NEG
41714: PUSH
41715: LD_INT 2
41717: NEG
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PUSH
41723: LD_INT 0
41725: PUSH
41726: LD_INT 2
41728: NEG
41729: PUSH
41730: EMPTY
41731: LIST
41732: LIST
41733: PUSH
41734: LD_INT 1
41736: PUSH
41737: LD_INT 1
41739: NEG
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: LIST
41749: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41750: LD_ADDR_VAR 0 60
41754: PUSH
41755: LD_INT 1
41757: PUSH
41758: LD_INT 1
41760: NEG
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: PUSH
41766: LD_INT 2
41768: PUSH
41769: LD_INT 0
41771: PUSH
41772: EMPTY
41773: LIST
41774: LIST
41775: PUSH
41776: LD_INT 2
41778: PUSH
41779: LD_INT 1
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: PUSH
41786: EMPTY
41787: LIST
41788: LIST
41789: LIST
41790: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41791: LD_ADDR_VAR 0 61
41795: PUSH
41796: LD_INT 2
41798: PUSH
41799: LD_INT 1
41801: PUSH
41802: EMPTY
41803: LIST
41804: LIST
41805: PUSH
41806: LD_INT 2
41808: PUSH
41809: LD_INT 2
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: LD_INT 1
41818: PUSH
41819: LD_INT 2
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: LIST
41830: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41831: LD_ADDR_VAR 0 62
41835: PUSH
41836: LD_INT 1
41838: PUSH
41839: LD_INT 2
41841: PUSH
41842: EMPTY
41843: LIST
41844: LIST
41845: PUSH
41846: LD_INT 0
41848: PUSH
41849: LD_INT 2
41851: PUSH
41852: EMPTY
41853: LIST
41854: LIST
41855: PUSH
41856: LD_INT 1
41858: NEG
41859: PUSH
41860: LD_INT 1
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PUSH
41867: EMPTY
41868: LIST
41869: LIST
41870: LIST
41871: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41872: LD_ADDR_VAR 0 63
41876: PUSH
41877: LD_INT 1
41879: NEG
41880: PUSH
41881: LD_INT 1
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: PUSH
41888: LD_INT 2
41890: NEG
41891: PUSH
41892: LD_INT 0
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: LD_INT 2
41901: NEG
41902: PUSH
41903: LD_INT 1
41905: NEG
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: LIST
41915: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41916: LD_ADDR_VAR 0 64
41920: PUSH
41921: LD_INT 1
41923: NEG
41924: PUSH
41925: LD_INT 2
41927: NEG
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: LD_INT 2
41935: NEG
41936: PUSH
41937: LD_INT 1
41939: NEG
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: PUSH
41945: LD_INT 2
41947: NEG
41948: PUSH
41949: LD_INT 2
41951: NEG
41952: PUSH
41953: EMPTY
41954: LIST
41955: LIST
41956: PUSH
41957: EMPTY
41958: LIST
41959: LIST
41960: LIST
41961: ST_TO_ADDR
// end ; 2 :
41962: GO 45228
41964: LD_INT 2
41966: DOUBLE
41967: EQUAL
41968: IFTRUE 41972
41970: GO 45227
41972: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41973: LD_ADDR_VAR 0 29
41977: PUSH
41978: LD_INT 4
41980: PUSH
41981: LD_INT 0
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: LD_INT 4
41990: PUSH
41991: LD_INT 1
41993: NEG
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: LD_INT 5
42001: PUSH
42002: LD_INT 0
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 5
42011: PUSH
42012: LD_INT 1
42014: PUSH
42015: EMPTY
42016: LIST
42017: LIST
42018: PUSH
42019: LD_INT 4
42021: PUSH
42022: LD_INT 1
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: LD_INT 3
42031: PUSH
42032: LD_INT 0
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 3
42041: PUSH
42042: LD_INT 1
42044: NEG
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 3
42052: PUSH
42053: LD_INT 2
42055: NEG
42056: PUSH
42057: EMPTY
42058: LIST
42059: LIST
42060: PUSH
42061: LD_INT 5
42063: PUSH
42064: LD_INT 2
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: PUSH
42071: LD_INT 3
42073: PUSH
42074: LD_INT 3
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 3
42083: PUSH
42084: LD_INT 2
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: LD_INT 4
42093: PUSH
42094: LD_INT 3
42096: PUSH
42097: EMPTY
42098: LIST
42099: LIST
42100: PUSH
42101: LD_INT 4
42103: PUSH
42104: LD_INT 4
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 3
42113: PUSH
42114: LD_INT 4
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 2
42123: PUSH
42124: LD_INT 3
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: LD_INT 2
42133: PUSH
42134: LD_INT 2
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 4
42143: PUSH
42144: LD_INT 2
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 2
42153: PUSH
42154: LD_INT 4
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 0
42163: PUSH
42164: LD_INT 4
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 0
42173: PUSH
42174: LD_INT 3
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 1
42183: PUSH
42184: LD_INT 4
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_INT 1
42193: PUSH
42194: LD_INT 5
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 0
42203: PUSH
42204: LD_INT 5
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 1
42213: NEG
42214: PUSH
42215: LD_INT 4
42217: PUSH
42218: EMPTY
42219: LIST
42220: LIST
42221: PUSH
42222: LD_INT 1
42224: NEG
42225: PUSH
42226: LD_INT 3
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 2
42235: PUSH
42236: LD_INT 5
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 2
42245: NEG
42246: PUSH
42247: LD_INT 3
42249: PUSH
42250: EMPTY
42251: LIST
42252: LIST
42253: PUSH
42254: LD_INT 3
42256: NEG
42257: PUSH
42258: LD_INT 0
42260: PUSH
42261: EMPTY
42262: LIST
42263: LIST
42264: PUSH
42265: LD_INT 3
42267: NEG
42268: PUSH
42269: LD_INT 1
42271: NEG
42272: PUSH
42273: EMPTY
42274: LIST
42275: LIST
42276: PUSH
42277: LD_INT 2
42279: NEG
42280: PUSH
42281: LD_INT 0
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: PUSH
42288: LD_INT 2
42290: NEG
42291: PUSH
42292: LD_INT 1
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 3
42301: NEG
42302: PUSH
42303: LD_INT 1
42305: PUSH
42306: EMPTY
42307: LIST
42308: LIST
42309: PUSH
42310: LD_INT 4
42312: NEG
42313: PUSH
42314: LD_INT 0
42316: PUSH
42317: EMPTY
42318: LIST
42319: LIST
42320: PUSH
42321: LD_INT 4
42323: NEG
42324: PUSH
42325: LD_INT 1
42327: NEG
42328: PUSH
42329: EMPTY
42330: LIST
42331: LIST
42332: PUSH
42333: LD_INT 4
42335: NEG
42336: PUSH
42337: LD_INT 2
42339: NEG
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: LD_INT 2
42347: NEG
42348: PUSH
42349: LD_INT 2
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: PUSH
42356: LD_INT 4
42358: NEG
42359: PUSH
42360: LD_INT 4
42362: NEG
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 4
42370: NEG
42371: PUSH
42372: LD_INT 5
42374: NEG
42375: PUSH
42376: EMPTY
42377: LIST
42378: LIST
42379: PUSH
42380: LD_INT 3
42382: NEG
42383: PUSH
42384: LD_INT 4
42386: NEG
42387: PUSH
42388: EMPTY
42389: LIST
42390: LIST
42391: PUSH
42392: LD_INT 3
42394: NEG
42395: PUSH
42396: LD_INT 3
42398: NEG
42399: PUSH
42400: EMPTY
42401: LIST
42402: LIST
42403: PUSH
42404: LD_INT 4
42406: NEG
42407: PUSH
42408: LD_INT 3
42410: NEG
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: PUSH
42416: LD_INT 5
42418: NEG
42419: PUSH
42420: LD_INT 4
42422: NEG
42423: PUSH
42424: EMPTY
42425: LIST
42426: LIST
42427: PUSH
42428: LD_INT 5
42430: NEG
42431: PUSH
42432: LD_INT 5
42434: NEG
42435: PUSH
42436: EMPTY
42437: LIST
42438: LIST
42439: PUSH
42440: LD_INT 3
42442: NEG
42443: PUSH
42444: LD_INT 5
42446: NEG
42447: PUSH
42448: EMPTY
42449: LIST
42450: LIST
42451: PUSH
42452: LD_INT 5
42454: NEG
42455: PUSH
42456: LD_INT 3
42458: NEG
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: LIST
42468: LIST
42469: LIST
42470: LIST
42471: LIST
42472: LIST
42473: LIST
42474: LIST
42475: LIST
42476: LIST
42477: LIST
42478: LIST
42479: LIST
42480: LIST
42481: LIST
42482: LIST
42483: LIST
42484: LIST
42485: LIST
42486: LIST
42487: LIST
42488: LIST
42489: LIST
42490: LIST
42491: LIST
42492: LIST
42493: LIST
42494: LIST
42495: LIST
42496: LIST
42497: LIST
42498: LIST
42499: LIST
42500: LIST
42501: LIST
42502: LIST
42503: LIST
42504: LIST
42505: LIST
42506: LIST
42507: LIST
42508: LIST
42509: LIST
42510: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42511: LD_ADDR_VAR 0 30
42515: PUSH
42516: LD_INT 4
42518: PUSH
42519: LD_INT 4
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 4
42528: PUSH
42529: LD_INT 3
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: PUSH
42536: LD_INT 5
42538: PUSH
42539: LD_INT 4
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PUSH
42546: LD_INT 5
42548: PUSH
42549: LD_INT 5
42551: PUSH
42552: EMPTY
42553: LIST
42554: LIST
42555: PUSH
42556: LD_INT 4
42558: PUSH
42559: LD_INT 5
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: PUSH
42566: LD_INT 3
42568: PUSH
42569: LD_INT 4
42571: PUSH
42572: EMPTY
42573: LIST
42574: LIST
42575: PUSH
42576: LD_INT 3
42578: PUSH
42579: LD_INT 3
42581: PUSH
42582: EMPTY
42583: LIST
42584: LIST
42585: PUSH
42586: LD_INT 5
42588: PUSH
42589: LD_INT 3
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: PUSH
42596: LD_INT 3
42598: PUSH
42599: LD_INT 5
42601: PUSH
42602: EMPTY
42603: LIST
42604: LIST
42605: PUSH
42606: LD_INT 0
42608: PUSH
42609: LD_INT 3
42611: PUSH
42612: EMPTY
42613: LIST
42614: LIST
42615: PUSH
42616: LD_INT 0
42618: PUSH
42619: LD_INT 2
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: PUSH
42626: LD_INT 1
42628: PUSH
42629: LD_INT 3
42631: PUSH
42632: EMPTY
42633: LIST
42634: LIST
42635: PUSH
42636: LD_INT 1
42638: PUSH
42639: LD_INT 4
42641: PUSH
42642: EMPTY
42643: LIST
42644: LIST
42645: PUSH
42646: LD_INT 0
42648: PUSH
42649: LD_INT 4
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PUSH
42656: LD_INT 1
42658: NEG
42659: PUSH
42660: LD_INT 3
42662: PUSH
42663: EMPTY
42664: LIST
42665: LIST
42666: PUSH
42667: LD_INT 1
42669: NEG
42670: PUSH
42671: LD_INT 2
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PUSH
42678: LD_INT 2
42680: PUSH
42681: LD_INT 4
42683: PUSH
42684: EMPTY
42685: LIST
42686: LIST
42687: PUSH
42688: LD_INT 2
42690: NEG
42691: PUSH
42692: LD_INT 2
42694: PUSH
42695: EMPTY
42696: LIST
42697: LIST
42698: PUSH
42699: LD_INT 4
42701: NEG
42702: PUSH
42703: LD_INT 0
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: PUSH
42710: LD_INT 4
42712: NEG
42713: PUSH
42714: LD_INT 1
42716: NEG
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 3
42724: NEG
42725: PUSH
42726: LD_INT 0
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: LD_INT 3
42735: NEG
42736: PUSH
42737: LD_INT 1
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: PUSH
42744: LD_INT 4
42746: NEG
42747: PUSH
42748: LD_INT 1
42750: PUSH
42751: EMPTY
42752: LIST
42753: LIST
42754: PUSH
42755: LD_INT 5
42757: NEG
42758: PUSH
42759: LD_INT 0
42761: PUSH
42762: EMPTY
42763: LIST
42764: LIST
42765: PUSH
42766: LD_INT 5
42768: NEG
42769: PUSH
42770: LD_INT 1
42772: NEG
42773: PUSH
42774: EMPTY
42775: LIST
42776: LIST
42777: PUSH
42778: LD_INT 5
42780: NEG
42781: PUSH
42782: LD_INT 2
42784: NEG
42785: PUSH
42786: EMPTY
42787: LIST
42788: LIST
42789: PUSH
42790: LD_INT 3
42792: NEG
42793: PUSH
42794: LD_INT 2
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: PUSH
42801: LD_INT 3
42803: NEG
42804: PUSH
42805: LD_INT 3
42807: NEG
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: LD_INT 3
42815: NEG
42816: PUSH
42817: LD_INT 4
42819: NEG
42820: PUSH
42821: EMPTY
42822: LIST
42823: LIST
42824: PUSH
42825: LD_INT 2
42827: NEG
42828: PUSH
42829: LD_INT 3
42831: NEG
42832: PUSH
42833: EMPTY
42834: LIST
42835: LIST
42836: PUSH
42837: LD_INT 2
42839: NEG
42840: PUSH
42841: LD_INT 2
42843: NEG
42844: PUSH
42845: EMPTY
42846: LIST
42847: LIST
42848: PUSH
42849: LD_INT 3
42851: NEG
42852: PUSH
42853: LD_INT 2
42855: NEG
42856: PUSH
42857: EMPTY
42858: LIST
42859: LIST
42860: PUSH
42861: LD_INT 4
42863: NEG
42864: PUSH
42865: LD_INT 3
42867: NEG
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: PUSH
42873: LD_INT 4
42875: NEG
42876: PUSH
42877: LD_INT 4
42879: NEG
42880: PUSH
42881: EMPTY
42882: LIST
42883: LIST
42884: PUSH
42885: LD_INT 2
42887: NEG
42888: PUSH
42889: LD_INT 4
42891: NEG
42892: PUSH
42893: EMPTY
42894: LIST
42895: LIST
42896: PUSH
42897: LD_INT 4
42899: NEG
42900: PUSH
42901: LD_INT 2
42903: NEG
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: LD_INT 0
42911: PUSH
42912: LD_INT 4
42914: NEG
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: PUSH
42920: LD_INT 0
42922: PUSH
42923: LD_INT 5
42925: NEG
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: PUSH
42931: LD_INT 1
42933: PUSH
42934: LD_INT 4
42936: NEG
42937: PUSH
42938: EMPTY
42939: LIST
42940: LIST
42941: PUSH
42942: LD_INT 1
42944: PUSH
42945: LD_INT 3
42947: NEG
42948: PUSH
42949: EMPTY
42950: LIST
42951: LIST
42952: PUSH
42953: LD_INT 0
42955: PUSH
42956: LD_INT 3
42958: NEG
42959: PUSH
42960: EMPTY
42961: LIST
42962: LIST
42963: PUSH
42964: LD_INT 1
42966: NEG
42967: PUSH
42968: LD_INT 4
42970: NEG
42971: PUSH
42972: EMPTY
42973: LIST
42974: LIST
42975: PUSH
42976: LD_INT 1
42978: NEG
42979: PUSH
42980: LD_INT 5
42982: NEG
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: PUSH
42988: LD_INT 2
42990: PUSH
42991: LD_INT 3
42993: NEG
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: LD_INT 2
43001: NEG
43002: PUSH
43003: LD_INT 5
43005: NEG
43006: PUSH
43007: EMPTY
43008: LIST
43009: LIST
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: LIST
43015: LIST
43016: LIST
43017: LIST
43018: LIST
43019: LIST
43020: LIST
43021: LIST
43022: LIST
43023: LIST
43024: LIST
43025: LIST
43026: LIST
43027: LIST
43028: LIST
43029: LIST
43030: LIST
43031: LIST
43032: LIST
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: LIST
43043: LIST
43044: LIST
43045: LIST
43046: LIST
43047: LIST
43048: LIST
43049: LIST
43050: LIST
43051: LIST
43052: LIST
43053: LIST
43054: LIST
43055: LIST
43056: LIST
43057: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43058: LD_ADDR_VAR 0 31
43062: PUSH
43063: LD_INT 0
43065: PUSH
43066: LD_INT 4
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: PUSH
43073: LD_INT 0
43075: PUSH
43076: LD_INT 3
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 1
43085: PUSH
43086: LD_INT 4
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 1
43095: PUSH
43096: LD_INT 5
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: LD_INT 0
43105: PUSH
43106: LD_INT 5
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: LD_INT 1
43115: NEG
43116: PUSH
43117: LD_INT 4
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 1
43126: NEG
43127: PUSH
43128: LD_INT 3
43130: PUSH
43131: EMPTY
43132: LIST
43133: LIST
43134: PUSH
43135: LD_INT 2
43137: PUSH
43138: LD_INT 5
43140: PUSH
43141: EMPTY
43142: LIST
43143: LIST
43144: PUSH
43145: LD_INT 2
43147: NEG
43148: PUSH
43149: LD_INT 3
43151: PUSH
43152: EMPTY
43153: LIST
43154: LIST
43155: PUSH
43156: LD_INT 3
43158: NEG
43159: PUSH
43160: LD_INT 0
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 3
43169: NEG
43170: PUSH
43171: LD_INT 1
43173: NEG
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: LD_INT 2
43181: NEG
43182: PUSH
43183: LD_INT 0
43185: PUSH
43186: EMPTY
43187: LIST
43188: LIST
43189: PUSH
43190: LD_INT 2
43192: NEG
43193: PUSH
43194: LD_INT 1
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PUSH
43201: LD_INT 3
43203: NEG
43204: PUSH
43205: LD_INT 1
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: PUSH
43212: LD_INT 4
43214: NEG
43215: PUSH
43216: LD_INT 0
43218: PUSH
43219: EMPTY
43220: LIST
43221: LIST
43222: PUSH
43223: LD_INT 4
43225: NEG
43226: PUSH
43227: LD_INT 1
43229: NEG
43230: PUSH
43231: EMPTY
43232: LIST
43233: LIST
43234: PUSH
43235: LD_INT 4
43237: NEG
43238: PUSH
43239: LD_INT 2
43241: NEG
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PUSH
43247: LD_INT 2
43249: NEG
43250: PUSH
43251: LD_INT 2
43253: PUSH
43254: EMPTY
43255: LIST
43256: LIST
43257: PUSH
43258: LD_INT 4
43260: NEG
43261: PUSH
43262: LD_INT 4
43264: NEG
43265: PUSH
43266: EMPTY
43267: LIST
43268: LIST
43269: PUSH
43270: LD_INT 4
43272: NEG
43273: PUSH
43274: LD_INT 5
43276: NEG
43277: PUSH
43278: EMPTY
43279: LIST
43280: LIST
43281: PUSH
43282: LD_INT 3
43284: NEG
43285: PUSH
43286: LD_INT 4
43288: NEG
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: PUSH
43294: LD_INT 3
43296: NEG
43297: PUSH
43298: LD_INT 3
43300: NEG
43301: PUSH
43302: EMPTY
43303: LIST
43304: LIST
43305: PUSH
43306: LD_INT 4
43308: NEG
43309: PUSH
43310: LD_INT 3
43312: NEG
43313: PUSH
43314: EMPTY
43315: LIST
43316: LIST
43317: PUSH
43318: LD_INT 5
43320: NEG
43321: PUSH
43322: LD_INT 4
43324: NEG
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 5
43332: NEG
43333: PUSH
43334: LD_INT 5
43336: NEG
43337: PUSH
43338: EMPTY
43339: LIST
43340: LIST
43341: PUSH
43342: LD_INT 3
43344: NEG
43345: PUSH
43346: LD_INT 5
43348: NEG
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 5
43356: NEG
43357: PUSH
43358: LD_INT 3
43360: NEG
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: PUSH
43366: LD_INT 0
43368: PUSH
43369: LD_INT 3
43371: NEG
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 0
43379: PUSH
43380: LD_INT 4
43382: NEG
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: PUSH
43388: LD_INT 1
43390: PUSH
43391: LD_INT 3
43393: NEG
43394: PUSH
43395: EMPTY
43396: LIST
43397: LIST
43398: PUSH
43399: LD_INT 1
43401: PUSH
43402: LD_INT 2
43404: NEG
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: PUSH
43410: LD_INT 0
43412: PUSH
43413: LD_INT 2
43415: NEG
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: PUSH
43421: LD_INT 1
43423: NEG
43424: PUSH
43425: LD_INT 3
43427: NEG
43428: PUSH
43429: EMPTY
43430: LIST
43431: LIST
43432: PUSH
43433: LD_INT 1
43435: NEG
43436: PUSH
43437: LD_INT 4
43439: NEG
43440: PUSH
43441: EMPTY
43442: LIST
43443: LIST
43444: PUSH
43445: LD_INT 2
43447: PUSH
43448: LD_INT 2
43450: NEG
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 2
43458: NEG
43459: PUSH
43460: LD_INT 4
43462: NEG
43463: PUSH
43464: EMPTY
43465: LIST
43466: LIST
43467: PUSH
43468: LD_INT 4
43470: PUSH
43471: LD_INT 0
43473: PUSH
43474: EMPTY
43475: LIST
43476: LIST
43477: PUSH
43478: LD_INT 4
43480: PUSH
43481: LD_INT 1
43483: NEG
43484: PUSH
43485: EMPTY
43486: LIST
43487: LIST
43488: PUSH
43489: LD_INT 5
43491: PUSH
43492: LD_INT 0
43494: PUSH
43495: EMPTY
43496: LIST
43497: LIST
43498: PUSH
43499: LD_INT 5
43501: PUSH
43502: LD_INT 1
43504: PUSH
43505: EMPTY
43506: LIST
43507: LIST
43508: PUSH
43509: LD_INT 4
43511: PUSH
43512: LD_INT 1
43514: PUSH
43515: EMPTY
43516: LIST
43517: LIST
43518: PUSH
43519: LD_INT 3
43521: PUSH
43522: LD_INT 0
43524: PUSH
43525: EMPTY
43526: LIST
43527: LIST
43528: PUSH
43529: LD_INT 3
43531: PUSH
43532: LD_INT 1
43534: NEG
43535: PUSH
43536: EMPTY
43537: LIST
43538: LIST
43539: PUSH
43540: LD_INT 3
43542: PUSH
43543: LD_INT 2
43545: NEG
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 5
43553: PUSH
43554: LD_INT 2
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: EMPTY
43562: LIST
43563: LIST
43564: LIST
43565: LIST
43566: LIST
43567: LIST
43568: LIST
43569: LIST
43570: LIST
43571: LIST
43572: LIST
43573: LIST
43574: LIST
43575: LIST
43576: LIST
43577: LIST
43578: LIST
43579: LIST
43580: LIST
43581: LIST
43582: LIST
43583: LIST
43584: LIST
43585: LIST
43586: LIST
43587: LIST
43588: LIST
43589: LIST
43590: LIST
43591: LIST
43592: LIST
43593: LIST
43594: LIST
43595: LIST
43596: LIST
43597: LIST
43598: LIST
43599: LIST
43600: LIST
43601: LIST
43602: LIST
43603: LIST
43604: LIST
43605: LIST
43606: LIST
43607: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43608: LD_ADDR_VAR 0 32
43612: PUSH
43613: LD_INT 4
43615: NEG
43616: PUSH
43617: LD_INT 0
43619: PUSH
43620: EMPTY
43621: LIST
43622: LIST
43623: PUSH
43624: LD_INT 4
43626: NEG
43627: PUSH
43628: LD_INT 1
43630: NEG
43631: PUSH
43632: EMPTY
43633: LIST
43634: LIST
43635: PUSH
43636: LD_INT 3
43638: NEG
43639: PUSH
43640: LD_INT 0
43642: PUSH
43643: EMPTY
43644: LIST
43645: LIST
43646: PUSH
43647: LD_INT 3
43649: NEG
43650: PUSH
43651: LD_INT 1
43653: PUSH
43654: EMPTY
43655: LIST
43656: LIST
43657: PUSH
43658: LD_INT 4
43660: NEG
43661: PUSH
43662: LD_INT 1
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: PUSH
43669: LD_INT 5
43671: NEG
43672: PUSH
43673: LD_INT 0
43675: PUSH
43676: EMPTY
43677: LIST
43678: LIST
43679: PUSH
43680: LD_INT 5
43682: NEG
43683: PUSH
43684: LD_INT 1
43686: NEG
43687: PUSH
43688: EMPTY
43689: LIST
43690: LIST
43691: PUSH
43692: LD_INT 5
43694: NEG
43695: PUSH
43696: LD_INT 2
43698: NEG
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 3
43706: NEG
43707: PUSH
43708: LD_INT 2
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: PUSH
43715: LD_INT 3
43717: NEG
43718: PUSH
43719: LD_INT 3
43721: NEG
43722: PUSH
43723: EMPTY
43724: LIST
43725: LIST
43726: PUSH
43727: LD_INT 3
43729: NEG
43730: PUSH
43731: LD_INT 4
43733: NEG
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: PUSH
43739: LD_INT 2
43741: NEG
43742: PUSH
43743: LD_INT 3
43745: NEG
43746: PUSH
43747: EMPTY
43748: LIST
43749: LIST
43750: PUSH
43751: LD_INT 2
43753: NEG
43754: PUSH
43755: LD_INT 2
43757: NEG
43758: PUSH
43759: EMPTY
43760: LIST
43761: LIST
43762: PUSH
43763: LD_INT 3
43765: NEG
43766: PUSH
43767: LD_INT 2
43769: NEG
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: LD_INT 4
43777: NEG
43778: PUSH
43779: LD_INT 3
43781: NEG
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: PUSH
43787: LD_INT 4
43789: NEG
43790: PUSH
43791: LD_INT 4
43793: NEG
43794: PUSH
43795: EMPTY
43796: LIST
43797: LIST
43798: PUSH
43799: LD_INT 2
43801: NEG
43802: PUSH
43803: LD_INT 4
43805: NEG
43806: PUSH
43807: EMPTY
43808: LIST
43809: LIST
43810: PUSH
43811: LD_INT 4
43813: NEG
43814: PUSH
43815: LD_INT 2
43817: NEG
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PUSH
43823: LD_INT 0
43825: PUSH
43826: LD_INT 4
43828: NEG
43829: PUSH
43830: EMPTY
43831: LIST
43832: LIST
43833: PUSH
43834: LD_INT 0
43836: PUSH
43837: LD_INT 5
43839: NEG
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PUSH
43845: LD_INT 1
43847: PUSH
43848: LD_INT 4
43850: NEG
43851: PUSH
43852: EMPTY
43853: LIST
43854: LIST
43855: PUSH
43856: LD_INT 1
43858: PUSH
43859: LD_INT 3
43861: NEG
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 0
43869: PUSH
43870: LD_INT 3
43872: NEG
43873: PUSH
43874: EMPTY
43875: LIST
43876: LIST
43877: PUSH
43878: LD_INT 1
43880: NEG
43881: PUSH
43882: LD_INT 4
43884: NEG
43885: PUSH
43886: EMPTY
43887: LIST
43888: LIST
43889: PUSH
43890: LD_INT 1
43892: NEG
43893: PUSH
43894: LD_INT 5
43896: NEG
43897: PUSH
43898: EMPTY
43899: LIST
43900: LIST
43901: PUSH
43902: LD_INT 2
43904: PUSH
43905: LD_INT 3
43907: NEG
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: LD_INT 2
43915: NEG
43916: PUSH
43917: LD_INT 5
43919: NEG
43920: PUSH
43921: EMPTY
43922: LIST
43923: LIST
43924: PUSH
43925: LD_INT 3
43927: PUSH
43928: LD_INT 0
43930: PUSH
43931: EMPTY
43932: LIST
43933: LIST
43934: PUSH
43935: LD_INT 3
43937: PUSH
43938: LD_INT 1
43940: NEG
43941: PUSH
43942: EMPTY
43943: LIST
43944: LIST
43945: PUSH
43946: LD_INT 4
43948: PUSH
43949: LD_INT 0
43951: PUSH
43952: EMPTY
43953: LIST
43954: LIST
43955: PUSH
43956: LD_INT 4
43958: PUSH
43959: LD_INT 1
43961: PUSH
43962: EMPTY
43963: LIST
43964: LIST
43965: PUSH
43966: LD_INT 3
43968: PUSH
43969: LD_INT 1
43971: PUSH
43972: EMPTY
43973: LIST
43974: LIST
43975: PUSH
43976: LD_INT 2
43978: PUSH
43979: LD_INT 0
43981: PUSH
43982: EMPTY
43983: LIST
43984: LIST
43985: PUSH
43986: LD_INT 2
43988: PUSH
43989: LD_INT 1
43991: NEG
43992: PUSH
43993: EMPTY
43994: LIST
43995: LIST
43996: PUSH
43997: LD_INT 2
43999: PUSH
44000: LD_INT 2
44002: NEG
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: LD_INT 4
44010: PUSH
44011: LD_INT 2
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: LD_INT 4
44020: PUSH
44021: LD_INT 4
44023: PUSH
44024: EMPTY
44025: LIST
44026: LIST
44027: PUSH
44028: LD_INT 4
44030: PUSH
44031: LD_INT 3
44033: PUSH
44034: EMPTY
44035: LIST
44036: LIST
44037: PUSH
44038: LD_INT 5
44040: PUSH
44041: LD_INT 4
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 5
44050: PUSH
44051: LD_INT 5
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 4
44060: PUSH
44061: LD_INT 5
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: LD_INT 3
44070: PUSH
44071: LD_INT 4
44073: PUSH
44074: EMPTY
44075: LIST
44076: LIST
44077: PUSH
44078: LD_INT 3
44080: PUSH
44081: LD_INT 3
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PUSH
44088: LD_INT 5
44090: PUSH
44091: LD_INT 3
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 3
44100: PUSH
44101: LD_INT 5
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: LIST
44112: LIST
44113: LIST
44114: LIST
44115: LIST
44116: LIST
44117: LIST
44118: LIST
44119: LIST
44120: LIST
44121: LIST
44122: LIST
44123: LIST
44124: LIST
44125: LIST
44126: LIST
44127: LIST
44128: LIST
44129: LIST
44130: LIST
44131: LIST
44132: LIST
44133: LIST
44134: LIST
44135: LIST
44136: LIST
44137: LIST
44138: LIST
44139: LIST
44140: LIST
44141: LIST
44142: LIST
44143: LIST
44144: LIST
44145: LIST
44146: LIST
44147: LIST
44148: LIST
44149: LIST
44150: LIST
44151: LIST
44152: LIST
44153: LIST
44154: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44155: LD_ADDR_VAR 0 33
44159: PUSH
44160: LD_INT 4
44162: NEG
44163: PUSH
44164: LD_INT 4
44166: NEG
44167: PUSH
44168: EMPTY
44169: LIST
44170: LIST
44171: PUSH
44172: LD_INT 4
44174: NEG
44175: PUSH
44176: LD_INT 5
44178: NEG
44179: PUSH
44180: EMPTY
44181: LIST
44182: LIST
44183: PUSH
44184: LD_INT 3
44186: NEG
44187: PUSH
44188: LD_INT 4
44190: NEG
44191: PUSH
44192: EMPTY
44193: LIST
44194: LIST
44195: PUSH
44196: LD_INT 3
44198: NEG
44199: PUSH
44200: LD_INT 3
44202: NEG
44203: PUSH
44204: EMPTY
44205: LIST
44206: LIST
44207: PUSH
44208: LD_INT 4
44210: NEG
44211: PUSH
44212: LD_INT 3
44214: NEG
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 5
44222: NEG
44223: PUSH
44224: LD_INT 4
44226: NEG
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 5
44234: NEG
44235: PUSH
44236: LD_INT 5
44238: NEG
44239: PUSH
44240: EMPTY
44241: LIST
44242: LIST
44243: PUSH
44244: LD_INT 3
44246: NEG
44247: PUSH
44248: LD_INT 5
44250: NEG
44251: PUSH
44252: EMPTY
44253: LIST
44254: LIST
44255: PUSH
44256: LD_INT 5
44258: NEG
44259: PUSH
44260: LD_INT 3
44262: NEG
44263: PUSH
44264: EMPTY
44265: LIST
44266: LIST
44267: PUSH
44268: LD_INT 0
44270: PUSH
44271: LD_INT 3
44273: NEG
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: PUSH
44279: LD_INT 0
44281: PUSH
44282: LD_INT 4
44284: NEG
44285: PUSH
44286: EMPTY
44287: LIST
44288: LIST
44289: PUSH
44290: LD_INT 1
44292: PUSH
44293: LD_INT 3
44295: NEG
44296: PUSH
44297: EMPTY
44298: LIST
44299: LIST
44300: PUSH
44301: LD_INT 1
44303: PUSH
44304: LD_INT 2
44306: NEG
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: PUSH
44312: LD_INT 0
44314: PUSH
44315: LD_INT 2
44317: NEG
44318: PUSH
44319: EMPTY
44320: LIST
44321: LIST
44322: PUSH
44323: LD_INT 1
44325: NEG
44326: PUSH
44327: LD_INT 3
44329: NEG
44330: PUSH
44331: EMPTY
44332: LIST
44333: LIST
44334: PUSH
44335: LD_INT 1
44337: NEG
44338: PUSH
44339: LD_INT 4
44341: NEG
44342: PUSH
44343: EMPTY
44344: LIST
44345: LIST
44346: PUSH
44347: LD_INT 2
44349: PUSH
44350: LD_INT 2
44352: NEG
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 2
44360: NEG
44361: PUSH
44362: LD_INT 4
44364: NEG
44365: PUSH
44366: EMPTY
44367: LIST
44368: LIST
44369: PUSH
44370: LD_INT 4
44372: PUSH
44373: LD_INT 0
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: LD_INT 4
44382: PUSH
44383: LD_INT 1
44385: NEG
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: LD_INT 5
44393: PUSH
44394: LD_INT 0
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 5
44403: PUSH
44404: LD_INT 1
44406: PUSH
44407: EMPTY
44408: LIST
44409: LIST
44410: PUSH
44411: LD_INT 4
44413: PUSH
44414: LD_INT 1
44416: PUSH
44417: EMPTY
44418: LIST
44419: LIST
44420: PUSH
44421: LD_INT 3
44423: PUSH
44424: LD_INT 0
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: PUSH
44431: LD_INT 3
44433: PUSH
44434: LD_INT 1
44436: NEG
44437: PUSH
44438: EMPTY
44439: LIST
44440: LIST
44441: PUSH
44442: LD_INT 3
44444: PUSH
44445: LD_INT 2
44447: NEG
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: LD_INT 5
44455: PUSH
44456: LD_INT 2
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 3
44465: PUSH
44466: LD_INT 3
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 3
44475: PUSH
44476: LD_INT 2
44478: PUSH
44479: EMPTY
44480: LIST
44481: LIST
44482: PUSH
44483: LD_INT 4
44485: PUSH
44486: LD_INT 3
44488: PUSH
44489: EMPTY
44490: LIST
44491: LIST
44492: PUSH
44493: LD_INT 4
44495: PUSH
44496: LD_INT 4
44498: PUSH
44499: EMPTY
44500: LIST
44501: LIST
44502: PUSH
44503: LD_INT 3
44505: PUSH
44506: LD_INT 4
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: LD_INT 2
44515: PUSH
44516: LD_INT 3
44518: PUSH
44519: EMPTY
44520: LIST
44521: LIST
44522: PUSH
44523: LD_INT 2
44525: PUSH
44526: LD_INT 2
44528: PUSH
44529: EMPTY
44530: LIST
44531: LIST
44532: PUSH
44533: LD_INT 4
44535: PUSH
44536: LD_INT 2
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: PUSH
44543: LD_INT 2
44545: PUSH
44546: LD_INT 4
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: PUSH
44553: LD_INT 0
44555: PUSH
44556: LD_INT 4
44558: PUSH
44559: EMPTY
44560: LIST
44561: LIST
44562: PUSH
44563: LD_INT 0
44565: PUSH
44566: LD_INT 3
44568: PUSH
44569: EMPTY
44570: LIST
44571: LIST
44572: PUSH
44573: LD_INT 1
44575: PUSH
44576: LD_INT 4
44578: PUSH
44579: EMPTY
44580: LIST
44581: LIST
44582: PUSH
44583: LD_INT 1
44585: PUSH
44586: LD_INT 5
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 0
44595: PUSH
44596: LD_INT 5
44598: PUSH
44599: EMPTY
44600: LIST
44601: LIST
44602: PUSH
44603: LD_INT 1
44605: NEG
44606: PUSH
44607: LD_INT 4
44609: PUSH
44610: EMPTY
44611: LIST
44612: LIST
44613: PUSH
44614: LD_INT 1
44616: NEG
44617: PUSH
44618: LD_INT 3
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: PUSH
44625: LD_INT 2
44627: PUSH
44628: LD_INT 5
44630: PUSH
44631: EMPTY
44632: LIST
44633: LIST
44634: PUSH
44635: LD_INT 2
44637: NEG
44638: PUSH
44639: LD_INT 3
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: LIST
44650: LIST
44651: LIST
44652: LIST
44653: LIST
44654: LIST
44655: LIST
44656: LIST
44657: LIST
44658: LIST
44659: LIST
44660: LIST
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: LIST
44669: LIST
44670: LIST
44671: LIST
44672: LIST
44673: LIST
44674: LIST
44675: LIST
44676: LIST
44677: LIST
44678: LIST
44679: LIST
44680: LIST
44681: LIST
44682: LIST
44683: LIST
44684: LIST
44685: LIST
44686: LIST
44687: LIST
44688: LIST
44689: LIST
44690: LIST
44691: LIST
44692: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44693: LD_ADDR_VAR 0 34
44697: PUSH
44698: LD_INT 0
44700: PUSH
44701: LD_INT 4
44703: NEG
44704: PUSH
44705: EMPTY
44706: LIST
44707: LIST
44708: PUSH
44709: LD_INT 0
44711: PUSH
44712: LD_INT 5
44714: NEG
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: PUSH
44720: LD_INT 1
44722: PUSH
44723: LD_INT 4
44725: NEG
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: LD_INT 1
44733: PUSH
44734: LD_INT 3
44736: NEG
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: PUSH
44742: LD_INT 0
44744: PUSH
44745: LD_INT 3
44747: NEG
44748: PUSH
44749: EMPTY
44750: LIST
44751: LIST
44752: PUSH
44753: LD_INT 1
44755: NEG
44756: PUSH
44757: LD_INT 4
44759: NEG
44760: PUSH
44761: EMPTY
44762: LIST
44763: LIST
44764: PUSH
44765: LD_INT 1
44767: NEG
44768: PUSH
44769: LD_INT 5
44771: NEG
44772: PUSH
44773: EMPTY
44774: LIST
44775: LIST
44776: PUSH
44777: LD_INT 2
44779: PUSH
44780: LD_INT 3
44782: NEG
44783: PUSH
44784: EMPTY
44785: LIST
44786: LIST
44787: PUSH
44788: LD_INT 2
44790: NEG
44791: PUSH
44792: LD_INT 5
44794: NEG
44795: PUSH
44796: EMPTY
44797: LIST
44798: LIST
44799: PUSH
44800: LD_INT 3
44802: PUSH
44803: LD_INT 0
44805: PUSH
44806: EMPTY
44807: LIST
44808: LIST
44809: PUSH
44810: LD_INT 3
44812: PUSH
44813: LD_INT 1
44815: NEG
44816: PUSH
44817: EMPTY
44818: LIST
44819: LIST
44820: PUSH
44821: LD_INT 4
44823: PUSH
44824: LD_INT 0
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PUSH
44831: LD_INT 4
44833: PUSH
44834: LD_INT 1
44836: PUSH
44837: EMPTY
44838: LIST
44839: LIST
44840: PUSH
44841: LD_INT 3
44843: PUSH
44844: LD_INT 1
44846: PUSH
44847: EMPTY
44848: LIST
44849: LIST
44850: PUSH
44851: LD_INT 2
44853: PUSH
44854: LD_INT 0
44856: PUSH
44857: EMPTY
44858: LIST
44859: LIST
44860: PUSH
44861: LD_INT 2
44863: PUSH
44864: LD_INT 1
44866: NEG
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: LD_INT 2
44874: PUSH
44875: LD_INT 2
44877: NEG
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: PUSH
44883: LD_INT 4
44885: PUSH
44886: LD_INT 2
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 4
44895: PUSH
44896: LD_INT 4
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 4
44905: PUSH
44906: LD_INT 3
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 5
44915: PUSH
44916: LD_INT 4
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: PUSH
44923: LD_INT 5
44925: PUSH
44926: LD_INT 5
44928: PUSH
44929: EMPTY
44930: LIST
44931: LIST
44932: PUSH
44933: LD_INT 4
44935: PUSH
44936: LD_INT 5
44938: PUSH
44939: EMPTY
44940: LIST
44941: LIST
44942: PUSH
44943: LD_INT 3
44945: PUSH
44946: LD_INT 4
44948: PUSH
44949: EMPTY
44950: LIST
44951: LIST
44952: PUSH
44953: LD_INT 3
44955: PUSH
44956: LD_INT 3
44958: PUSH
44959: EMPTY
44960: LIST
44961: LIST
44962: PUSH
44963: LD_INT 5
44965: PUSH
44966: LD_INT 3
44968: PUSH
44969: EMPTY
44970: LIST
44971: LIST
44972: PUSH
44973: LD_INT 3
44975: PUSH
44976: LD_INT 5
44978: PUSH
44979: EMPTY
44980: LIST
44981: LIST
44982: PUSH
44983: LD_INT 0
44985: PUSH
44986: LD_INT 3
44988: PUSH
44989: EMPTY
44990: LIST
44991: LIST
44992: PUSH
44993: LD_INT 0
44995: PUSH
44996: LD_INT 2
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: LD_INT 1
45005: PUSH
45006: LD_INT 3
45008: PUSH
45009: EMPTY
45010: LIST
45011: LIST
45012: PUSH
45013: LD_INT 1
45015: PUSH
45016: LD_INT 4
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PUSH
45023: LD_INT 0
45025: PUSH
45026: LD_INT 4
45028: PUSH
45029: EMPTY
45030: LIST
45031: LIST
45032: PUSH
45033: LD_INT 1
45035: NEG
45036: PUSH
45037: LD_INT 3
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: LD_INT 1
45046: NEG
45047: PUSH
45048: LD_INT 2
45050: PUSH
45051: EMPTY
45052: LIST
45053: LIST
45054: PUSH
45055: LD_INT 2
45057: PUSH
45058: LD_INT 4
45060: PUSH
45061: EMPTY
45062: LIST
45063: LIST
45064: PUSH
45065: LD_INT 2
45067: NEG
45068: PUSH
45069: LD_INT 2
45071: PUSH
45072: EMPTY
45073: LIST
45074: LIST
45075: PUSH
45076: LD_INT 4
45078: NEG
45079: PUSH
45080: LD_INT 0
45082: PUSH
45083: EMPTY
45084: LIST
45085: LIST
45086: PUSH
45087: LD_INT 4
45089: NEG
45090: PUSH
45091: LD_INT 1
45093: NEG
45094: PUSH
45095: EMPTY
45096: LIST
45097: LIST
45098: PUSH
45099: LD_INT 3
45101: NEG
45102: PUSH
45103: LD_INT 0
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: PUSH
45110: LD_INT 3
45112: NEG
45113: PUSH
45114: LD_INT 1
45116: PUSH
45117: EMPTY
45118: LIST
45119: LIST
45120: PUSH
45121: LD_INT 4
45123: NEG
45124: PUSH
45125: LD_INT 1
45127: PUSH
45128: EMPTY
45129: LIST
45130: LIST
45131: PUSH
45132: LD_INT 5
45134: NEG
45135: PUSH
45136: LD_INT 0
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: PUSH
45143: LD_INT 5
45145: NEG
45146: PUSH
45147: LD_INT 1
45149: NEG
45150: PUSH
45151: EMPTY
45152: LIST
45153: LIST
45154: PUSH
45155: LD_INT 5
45157: NEG
45158: PUSH
45159: LD_INT 2
45161: NEG
45162: PUSH
45163: EMPTY
45164: LIST
45165: LIST
45166: PUSH
45167: LD_INT 3
45169: NEG
45170: PUSH
45171: LD_INT 2
45173: PUSH
45174: EMPTY
45175: LIST
45176: LIST
45177: PUSH
45178: EMPTY
45179: LIST
45180: LIST
45181: LIST
45182: LIST
45183: LIST
45184: LIST
45185: LIST
45186: LIST
45187: LIST
45188: LIST
45189: LIST
45190: LIST
45191: LIST
45192: LIST
45193: LIST
45194: LIST
45195: LIST
45196: LIST
45197: LIST
45198: LIST
45199: LIST
45200: LIST
45201: LIST
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: LIST
45219: LIST
45220: LIST
45221: LIST
45222: LIST
45223: LIST
45224: ST_TO_ADDR
// end ; end ;
45225: GO 45228
45227: POP
// case btype of b_depot , b_warehouse :
45228: LD_VAR 0 1
45232: PUSH
45233: LD_INT 0
45235: DOUBLE
45236: EQUAL
45237: IFTRUE 45247
45239: LD_INT 1
45241: DOUBLE
45242: EQUAL
45243: IFTRUE 45247
45245: GO 45448
45247: POP
// case nation of nation_american :
45248: LD_VAR 0 5
45252: PUSH
45253: LD_INT 1
45255: DOUBLE
45256: EQUAL
45257: IFTRUE 45261
45259: GO 45317
45261: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
45262: LD_ADDR_VAR 0 9
45266: PUSH
45267: LD_VAR 0 11
45271: PUSH
45272: LD_VAR 0 12
45276: PUSH
45277: LD_VAR 0 13
45281: PUSH
45282: LD_VAR 0 14
45286: PUSH
45287: LD_VAR 0 15
45291: PUSH
45292: LD_VAR 0 16
45296: PUSH
45297: EMPTY
45298: LIST
45299: LIST
45300: LIST
45301: LIST
45302: LIST
45303: LIST
45304: PUSH
45305: LD_VAR 0 4
45309: PUSH
45310: LD_INT 1
45312: PLUS
45313: ARRAY
45314: ST_TO_ADDR
45315: GO 45446
45317: LD_INT 2
45319: DOUBLE
45320: EQUAL
45321: IFTRUE 45325
45323: GO 45381
45325: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
45326: LD_ADDR_VAR 0 9
45330: PUSH
45331: LD_VAR 0 17
45335: PUSH
45336: LD_VAR 0 18
45340: PUSH
45341: LD_VAR 0 19
45345: PUSH
45346: LD_VAR 0 20
45350: PUSH
45351: LD_VAR 0 21
45355: PUSH
45356: LD_VAR 0 22
45360: PUSH
45361: EMPTY
45362: LIST
45363: LIST
45364: LIST
45365: LIST
45366: LIST
45367: LIST
45368: PUSH
45369: LD_VAR 0 4
45373: PUSH
45374: LD_INT 1
45376: PLUS
45377: ARRAY
45378: ST_TO_ADDR
45379: GO 45446
45381: LD_INT 3
45383: DOUBLE
45384: EQUAL
45385: IFTRUE 45389
45387: GO 45445
45389: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45390: LD_ADDR_VAR 0 9
45394: PUSH
45395: LD_VAR 0 23
45399: PUSH
45400: LD_VAR 0 24
45404: PUSH
45405: LD_VAR 0 25
45409: PUSH
45410: LD_VAR 0 26
45414: PUSH
45415: LD_VAR 0 27
45419: PUSH
45420: LD_VAR 0 28
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: LIST
45429: LIST
45430: LIST
45431: LIST
45432: PUSH
45433: LD_VAR 0 4
45437: PUSH
45438: LD_INT 1
45440: PLUS
45441: ARRAY
45442: ST_TO_ADDR
45443: GO 45446
45445: POP
45446: GO 46001
45448: LD_INT 2
45450: DOUBLE
45451: EQUAL
45452: IFTRUE 45462
45454: LD_INT 3
45456: DOUBLE
45457: EQUAL
45458: IFTRUE 45462
45460: GO 45518
45462: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45463: LD_ADDR_VAR 0 9
45467: PUSH
45468: LD_VAR 0 29
45472: PUSH
45473: LD_VAR 0 30
45477: PUSH
45478: LD_VAR 0 31
45482: PUSH
45483: LD_VAR 0 32
45487: PUSH
45488: LD_VAR 0 33
45492: PUSH
45493: LD_VAR 0 34
45497: PUSH
45498: EMPTY
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: PUSH
45506: LD_VAR 0 4
45510: PUSH
45511: LD_INT 1
45513: PLUS
45514: ARRAY
45515: ST_TO_ADDR
45516: GO 46001
45518: LD_INT 16
45520: DOUBLE
45521: EQUAL
45522: IFTRUE 45580
45524: LD_INT 17
45526: DOUBLE
45527: EQUAL
45528: IFTRUE 45580
45530: LD_INT 18
45532: DOUBLE
45533: EQUAL
45534: IFTRUE 45580
45536: LD_INT 19
45538: DOUBLE
45539: EQUAL
45540: IFTRUE 45580
45542: LD_INT 22
45544: DOUBLE
45545: EQUAL
45546: IFTRUE 45580
45548: LD_INT 20
45550: DOUBLE
45551: EQUAL
45552: IFTRUE 45580
45554: LD_INT 21
45556: DOUBLE
45557: EQUAL
45558: IFTRUE 45580
45560: LD_INT 23
45562: DOUBLE
45563: EQUAL
45564: IFTRUE 45580
45566: LD_INT 24
45568: DOUBLE
45569: EQUAL
45570: IFTRUE 45580
45572: LD_INT 25
45574: DOUBLE
45575: EQUAL
45576: IFTRUE 45580
45578: GO 45636
45580: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45581: LD_ADDR_VAR 0 9
45585: PUSH
45586: LD_VAR 0 35
45590: PUSH
45591: LD_VAR 0 36
45595: PUSH
45596: LD_VAR 0 37
45600: PUSH
45601: LD_VAR 0 38
45605: PUSH
45606: LD_VAR 0 39
45610: PUSH
45611: LD_VAR 0 40
45615: PUSH
45616: EMPTY
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: LIST
45622: LIST
45623: PUSH
45624: LD_VAR 0 4
45628: PUSH
45629: LD_INT 1
45631: PLUS
45632: ARRAY
45633: ST_TO_ADDR
45634: GO 46001
45636: LD_INT 6
45638: DOUBLE
45639: EQUAL
45640: IFTRUE 45692
45642: LD_INT 7
45644: DOUBLE
45645: EQUAL
45646: IFTRUE 45692
45648: LD_INT 8
45650: DOUBLE
45651: EQUAL
45652: IFTRUE 45692
45654: LD_INT 13
45656: DOUBLE
45657: EQUAL
45658: IFTRUE 45692
45660: LD_INT 12
45662: DOUBLE
45663: EQUAL
45664: IFTRUE 45692
45666: LD_INT 15
45668: DOUBLE
45669: EQUAL
45670: IFTRUE 45692
45672: LD_INT 11
45674: DOUBLE
45675: EQUAL
45676: IFTRUE 45692
45678: LD_INT 14
45680: DOUBLE
45681: EQUAL
45682: IFTRUE 45692
45684: LD_INT 10
45686: DOUBLE
45687: EQUAL
45688: IFTRUE 45692
45690: GO 45748
45692: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
45693: LD_ADDR_VAR 0 9
45697: PUSH
45698: LD_VAR 0 41
45702: PUSH
45703: LD_VAR 0 42
45707: PUSH
45708: LD_VAR 0 43
45712: PUSH
45713: LD_VAR 0 44
45717: PUSH
45718: LD_VAR 0 45
45722: PUSH
45723: LD_VAR 0 46
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: LIST
45732: LIST
45733: LIST
45734: LIST
45735: PUSH
45736: LD_VAR 0 4
45740: PUSH
45741: LD_INT 1
45743: PLUS
45744: ARRAY
45745: ST_TO_ADDR
45746: GO 46001
45748: LD_INT 36
45750: DOUBLE
45751: EQUAL
45752: IFTRUE 45756
45754: GO 45812
45756: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45757: LD_ADDR_VAR 0 9
45761: PUSH
45762: LD_VAR 0 47
45766: PUSH
45767: LD_VAR 0 48
45771: PUSH
45772: LD_VAR 0 49
45776: PUSH
45777: LD_VAR 0 50
45781: PUSH
45782: LD_VAR 0 51
45786: PUSH
45787: LD_VAR 0 52
45791: PUSH
45792: EMPTY
45793: LIST
45794: LIST
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: PUSH
45800: LD_VAR 0 4
45804: PUSH
45805: LD_INT 1
45807: PLUS
45808: ARRAY
45809: ST_TO_ADDR
45810: GO 46001
45812: LD_INT 4
45814: DOUBLE
45815: EQUAL
45816: IFTRUE 45838
45818: LD_INT 5
45820: DOUBLE
45821: EQUAL
45822: IFTRUE 45838
45824: LD_INT 34
45826: DOUBLE
45827: EQUAL
45828: IFTRUE 45838
45830: LD_INT 37
45832: DOUBLE
45833: EQUAL
45834: IFTRUE 45838
45836: GO 45894
45838: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45839: LD_ADDR_VAR 0 9
45843: PUSH
45844: LD_VAR 0 53
45848: PUSH
45849: LD_VAR 0 54
45853: PUSH
45854: LD_VAR 0 55
45858: PUSH
45859: LD_VAR 0 56
45863: PUSH
45864: LD_VAR 0 57
45868: PUSH
45869: LD_VAR 0 58
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: PUSH
45882: LD_VAR 0 4
45886: PUSH
45887: LD_INT 1
45889: PLUS
45890: ARRAY
45891: ST_TO_ADDR
45892: GO 46001
45894: LD_INT 31
45896: DOUBLE
45897: EQUAL
45898: IFTRUE 45944
45900: LD_INT 32
45902: DOUBLE
45903: EQUAL
45904: IFTRUE 45944
45906: LD_INT 33
45908: DOUBLE
45909: EQUAL
45910: IFTRUE 45944
45912: LD_INT 27
45914: DOUBLE
45915: EQUAL
45916: IFTRUE 45944
45918: LD_INT 26
45920: DOUBLE
45921: EQUAL
45922: IFTRUE 45944
45924: LD_INT 28
45926: DOUBLE
45927: EQUAL
45928: IFTRUE 45944
45930: LD_INT 29
45932: DOUBLE
45933: EQUAL
45934: IFTRUE 45944
45936: LD_INT 30
45938: DOUBLE
45939: EQUAL
45940: IFTRUE 45944
45942: GO 46000
45944: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
45945: LD_ADDR_VAR 0 9
45949: PUSH
45950: LD_VAR 0 59
45954: PUSH
45955: LD_VAR 0 60
45959: PUSH
45960: LD_VAR 0 61
45964: PUSH
45965: LD_VAR 0 62
45969: PUSH
45970: LD_VAR 0 63
45974: PUSH
45975: LD_VAR 0 64
45979: PUSH
45980: EMPTY
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: PUSH
45988: LD_VAR 0 4
45992: PUSH
45993: LD_INT 1
45995: PLUS
45996: ARRAY
45997: ST_TO_ADDR
45998: GO 46001
46000: POP
// temp_list2 = [ ] ;
46001: LD_ADDR_VAR 0 10
46005: PUSH
46006: EMPTY
46007: ST_TO_ADDR
// for i in temp_list do
46008: LD_ADDR_VAR 0 8
46012: PUSH
46013: LD_VAR 0 9
46017: PUSH
46018: FOR_IN
46019: IFFALSE 46071
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46021: LD_ADDR_VAR 0 10
46025: PUSH
46026: LD_VAR 0 10
46030: PUSH
46031: LD_VAR 0 8
46035: PUSH
46036: LD_INT 1
46038: ARRAY
46039: PUSH
46040: LD_VAR 0 2
46044: PLUS
46045: PUSH
46046: LD_VAR 0 8
46050: PUSH
46051: LD_INT 2
46053: ARRAY
46054: PUSH
46055: LD_VAR 0 3
46059: PLUS
46060: PUSH
46061: EMPTY
46062: LIST
46063: LIST
46064: PUSH
46065: EMPTY
46066: LIST
46067: ADD
46068: ST_TO_ADDR
46069: GO 46018
46071: POP
46072: POP
// result = temp_list2 ;
46073: LD_ADDR_VAR 0 7
46077: PUSH
46078: LD_VAR 0 10
46082: ST_TO_ADDR
// end ;
46083: LD_VAR 0 7
46087: RET
// export function EnemyInRange ( unit , dist ) ; begin
46088: LD_INT 0
46090: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46091: LD_ADDR_VAR 0 3
46095: PUSH
46096: LD_VAR 0 1
46100: PPUSH
46101: CALL_OW 255
46105: PPUSH
46106: LD_VAR 0 1
46110: PPUSH
46111: CALL_OW 250
46115: PPUSH
46116: LD_VAR 0 1
46120: PPUSH
46121: CALL_OW 251
46125: PPUSH
46126: LD_VAR 0 2
46130: PPUSH
46131: CALL 19484 0 4
46135: PUSH
46136: LD_INT 4
46138: ARRAY
46139: ST_TO_ADDR
// end ;
46140: LD_VAR 0 3
46144: RET
// export function PlayerSeeMe ( unit ) ; begin
46145: LD_INT 0
46147: PPUSH
// result := See ( your_side , unit ) ;
46148: LD_ADDR_VAR 0 2
46152: PUSH
46153: LD_OWVAR 2
46157: PPUSH
46158: LD_VAR 0 1
46162: PPUSH
46163: CALL_OW 292
46167: ST_TO_ADDR
// end ;
46168: LD_VAR 0 2
46172: RET
// export function ReverseDir ( unit ) ; begin
46173: LD_INT 0
46175: PPUSH
// if not unit then
46176: LD_VAR 0 1
46180: NOT
46181: IFFALSE 46185
// exit ;
46183: GO 46208
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46185: LD_ADDR_VAR 0 2
46189: PUSH
46190: LD_VAR 0 1
46194: PPUSH
46195: CALL_OW 254
46199: PUSH
46200: LD_INT 3
46202: PLUS
46203: PUSH
46204: LD_INT 6
46206: MOD
46207: ST_TO_ADDR
// end ;
46208: LD_VAR 0 2
46212: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46213: LD_INT 0
46215: PPUSH
46216: PPUSH
46217: PPUSH
46218: PPUSH
46219: PPUSH
// if not hexes then
46220: LD_VAR 0 2
46224: NOT
46225: IFFALSE 46229
// exit ;
46227: GO 46377
// dist := 9999 ;
46229: LD_ADDR_VAR 0 5
46233: PUSH
46234: LD_INT 9999
46236: ST_TO_ADDR
// for i = 1 to hexes do
46237: LD_ADDR_VAR 0 4
46241: PUSH
46242: DOUBLE
46243: LD_INT 1
46245: DEC
46246: ST_TO_ADDR
46247: LD_VAR 0 2
46251: PUSH
46252: FOR_TO
46253: IFFALSE 46365
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
46255: LD_VAR 0 1
46259: PPUSH
46260: LD_VAR 0 2
46264: PUSH
46265: LD_VAR 0 4
46269: ARRAY
46270: PUSH
46271: LD_INT 1
46273: ARRAY
46274: PPUSH
46275: LD_VAR 0 2
46279: PUSH
46280: LD_VAR 0 4
46284: ARRAY
46285: PUSH
46286: LD_INT 2
46288: ARRAY
46289: PPUSH
46290: CALL_OW 297
46294: PUSH
46295: LD_VAR 0 5
46299: LESS
46300: IFFALSE 46363
// begin hex := hexes [ i ] ;
46302: LD_ADDR_VAR 0 7
46306: PUSH
46307: LD_VAR 0 2
46311: PUSH
46312: LD_VAR 0 4
46316: ARRAY
46317: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46318: LD_ADDR_VAR 0 5
46322: PUSH
46323: LD_VAR 0 1
46327: PPUSH
46328: LD_VAR 0 2
46332: PUSH
46333: LD_VAR 0 4
46337: ARRAY
46338: PUSH
46339: LD_INT 1
46341: ARRAY
46342: PPUSH
46343: LD_VAR 0 2
46347: PUSH
46348: LD_VAR 0 4
46352: ARRAY
46353: PUSH
46354: LD_INT 2
46356: ARRAY
46357: PPUSH
46358: CALL_OW 297
46362: ST_TO_ADDR
// end ; end ;
46363: GO 46252
46365: POP
46366: POP
// result := hex ;
46367: LD_ADDR_VAR 0 3
46371: PUSH
46372: LD_VAR 0 7
46376: ST_TO_ADDR
// end ;
46377: LD_VAR 0 3
46381: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46382: LD_INT 0
46384: PPUSH
46385: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46386: LD_VAR 0 1
46390: NOT
46391: PUSH
46392: LD_VAR 0 1
46396: PUSH
46397: LD_INT 21
46399: PUSH
46400: LD_INT 2
46402: PUSH
46403: EMPTY
46404: LIST
46405: LIST
46406: PUSH
46407: LD_INT 23
46409: PUSH
46410: LD_INT 2
46412: PUSH
46413: EMPTY
46414: LIST
46415: LIST
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: PPUSH
46421: CALL_OW 69
46425: IN
46426: NOT
46427: OR
46428: IFFALSE 46432
// exit ;
46430: GO 46479
// for i = 1 to 3 do
46432: LD_ADDR_VAR 0 3
46436: PUSH
46437: DOUBLE
46438: LD_INT 1
46440: DEC
46441: ST_TO_ADDR
46442: LD_INT 3
46444: PUSH
46445: FOR_TO
46446: IFFALSE 46477
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46448: LD_VAR 0 1
46452: PPUSH
46453: CALL_OW 250
46457: PPUSH
46458: LD_VAR 0 1
46462: PPUSH
46463: CALL_OW 251
46467: PPUSH
46468: LD_INT 1
46470: PPUSH
46471: CALL_OW 453
46475: GO 46445
46477: POP
46478: POP
// end ;
46479: LD_VAR 0 2
46483: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46484: LD_INT 0
46486: PPUSH
46487: PPUSH
46488: PPUSH
46489: PPUSH
46490: PPUSH
46491: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46492: LD_VAR 0 1
46496: NOT
46497: PUSH
46498: LD_VAR 0 2
46502: NOT
46503: OR
46504: PUSH
46505: LD_VAR 0 1
46509: PPUSH
46510: CALL_OW 314
46514: OR
46515: IFFALSE 46519
// exit ;
46517: GO 46960
// x := GetX ( enemy_unit ) ;
46519: LD_ADDR_VAR 0 7
46523: PUSH
46524: LD_VAR 0 2
46528: PPUSH
46529: CALL_OW 250
46533: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46534: LD_ADDR_VAR 0 8
46538: PUSH
46539: LD_VAR 0 2
46543: PPUSH
46544: CALL_OW 251
46548: ST_TO_ADDR
// if not x or not y then
46549: LD_VAR 0 7
46553: NOT
46554: PUSH
46555: LD_VAR 0 8
46559: NOT
46560: OR
46561: IFFALSE 46565
// exit ;
46563: GO 46960
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46565: LD_ADDR_VAR 0 6
46569: PUSH
46570: LD_VAR 0 7
46574: PPUSH
46575: LD_INT 0
46577: PPUSH
46578: LD_INT 4
46580: PPUSH
46581: CALL_OW 272
46585: PUSH
46586: LD_VAR 0 8
46590: PPUSH
46591: LD_INT 0
46593: PPUSH
46594: LD_INT 4
46596: PPUSH
46597: CALL_OW 273
46601: PUSH
46602: EMPTY
46603: LIST
46604: LIST
46605: PUSH
46606: LD_VAR 0 7
46610: PPUSH
46611: LD_INT 1
46613: PPUSH
46614: LD_INT 4
46616: PPUSH
46617: CALL_OW 272
46621: PUSH
46622: LD_VAR 0 8
46626: PPUSH
46627: LD_INT 1
46629: PPUSH
46630: LD_INT 4
46632: PPUSH
46633: CALL_OW 273
46637: PUSH
46638: EMPTY
46639: LIST
46640: LIST
46641: PUSH
46642: LD_VAR 0 7
46646: PPUSH
46647: LD_INT 2
46649: PPUSH
46650: LD_INT 4
46652: PPUSH
46653: CALL_OW 272
46657: PUSH
46658: LD_VAR 0 8
46662: PPUSH
46663: LD_INT 2
46665: PPUSH
46666: LD_INT 4
46668: PPUSH
46669: CALL_OW 273
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: LD_VAR 0 7
46682: PPUSH
46683: LD_INT 3
46685: PPUSH
46686: LD_INT 4
46688: PPUSH
46689: CALL_OW 272
46693: PUSH
46694: LD_VAR 0 8
46698: PPUSH
46699: LD_INT 3
46701: PPUSH
46702: LD_INT 4
46704: PPUSH
46705: CALL_OW 273
46709: PUSH
46710: EMPTY
46711: LIST
46712: LIST
46713: PUSH
46714: LD_VAR 0 7
46718: PPUSH
46719: LD_INT 4
46721: PPUSH
46722: LD_INT 4
46724: PPUSH
46725: CALL_OW 272
46729: PUSH
46730: LD_VAR 0 8
46734: PPUSH
46735: LD_INT 4
46737: PPUSH
46738: LD_INT 4
46740: PPUSH
46741: CALL_OW 273
46745: PUSH
46746: EMPTY
46747: LIST
46748: LIST
46749: PUSH
46750: LD_VAR 0 7
46754: PPUSH
46755: LD_INT 5
46757: PPUSH
46758: LD_INT 4
46760: PPUSH
46761: CALL_OW 272
46765: PUSH
46766: LD_VAR 0 8
46770: PPUSH
46771: LD_INT 5
46773: PPUSH
46774: LD_INT 4
46776: PPUSH
46777: CALL_OW 273
46781: PUSH
46782: EMPTY
46783: LIST
46784: LIST
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: LIST
46790: LIST
46791: LIST
46792: LIST
46793: ST_TO_ADDR
// for i = tmp downto 1 do
46794: LD_ADDR_VAR 0 4
46798: PUSH
46799: DOUBLE
46800: LD_VAR 0 6
46804: INC
46805: ST_TO_ADDR
46806: LD_INT 1
46808: PUSH
46809: FOR_DOWNTO
46810: IFFALSE 46911
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46812: LD_VAR 0 6
46816: PUSH
46817: LD_VAR 0 4
46821: ARRAY
46822: PUSH
46823: LD_INT 1
46825: ARRAY
46826: PPUSH
46827: LD_VAR 0 6
46831: PUSH
46832: LD_VAR 0 4
46836: ARRAY
46837: PUSH
46838: LD_INT 2
46840: ARRAY
46841: PPUSH
46842: CALL_OW 488
46846: NOT
46847: PUSH
46848: LD_VAR 0 6
46852: PUSH
46853: LD_VAR 0 4
46857: ARRAY
46858: PUSH
46859: LD_INT 1
46861: ARRAY
46862: PPUSH
46863: LD_VAR 0 6
46867: PUSH
46868: LD_VAR 0 4
46872: ARRAY
46873: PUSH
46874: LD_INT 2
46876: ARRAY
46877: PPUSH
46878: CALL_OW 428
46882: PUSH
46883: LD_INT 0
46885: NONEQUAL
46886: OR
46887: IFFALSE 46909
// tmp := Delete ( tmp , i ) ;
46889: LD_ADDR_VAR 0 6
46893: PUSH
46894: LD_VAR 0 6
46898: PPUSH
46899: LD_VAR 0 4
46903: PPUSH
46904: CALL_OW 3
46908: ST_TO_ADDR
46909: GO 46809
46911: POP
46912: POP
// j := GetClosestHex ( unit , tmp ) ;
46913: LD_ADDR_VAR 0 5
46917: PUSH
46918: LD_VAR 0 1
46922: PPUSH
46923: LD_VAR 0 6
46927: PPUSH
46928: CALL 46213 0 2
46932: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46933: LD_VAR 0 1
46937: PPUSH
46938: LD_VAR 0 5
46942: PUSH
46943: LD_INT 1
46945: ARRAY
46946: PPUSH
46947: LD_VAR 0 5
46951: PUSH
46952: LD_INT 2
46954: ARRAY
46955: PPUSH
46956: CALL_OW 111
// end ;
46960: LD_VAR 0 3
46964: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46965: LD_INT 0
46967: PPUSH
46968: PPUSH
46969: PPUSH
// uc_side = 0 ;
46970: LD_ADDR_OWVAR 20
46974: PUSH
46975: LD_INT 0
46977: ST_TO_ADDR
// uc_nation = 0 ;
46978: LD_ADDR_OWVAR 21
46982: PUSH
46983: LD_INT 0
46985: ST_TO_ADDR
// InitHc_All ( ) ;
46986: CALL_OW 584
// InitVc ;
46990: CALL_OW 20
// if mastodonts then
46994: LD_VAR 0 6
46998: IFFALSE 47065
// for i = 1 to mastodonts do
47000: LD_ADDR_VAR 0 11
47004: PUSH
47005: DOUBLE
47006: LD_INT 1
47008: DEC
47009: ST_TO_ADDR
47010: LD_VAR 0 6
47014: PUSH
47015: FOR_TO
47016: IFFALSE 47063
// begin vc_chassis := 31 ;
47018: LD_ADDR_OWVAR 37
47022: PUSH
47023: LD_INT 31
47025: ST_TO_ADDR
// vc_control := control_rider ;
47026: LD_ADDR_OWVAR 38
47030: PUSH
47031: LD_INT 4
47033: ST_TO_ADDR
// animal := CreateVehicle ;
47034: LD_ADDR_VAR 0 12
47038: PUSH
47039: CALL_OW 45
47043: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47044: LD_VAR 0 12
47048: PPUSH
47049: LD_VAR 0 8
47053: PPUSH
47054: LD_INT 0
47056: PPUSH
47057: CALL 49253 0 3
// end ;
47061: GO 47015
47063: POP
47064: POP
// if horses then
47065: LD_VAR 0 5
47069: IFFALSE 47136
// for i = 1 to horses do
47071: LD_ADDR_VAR 0 11
47075: PUSH
47076: DOUBLE
47077: LD_INT 1
47079: DEC
47080: ST_TO_ADDR
47081: LD_VAR 0 5
47085: PUSH
47086: FOR_TO
47087: IFFALSE 47134
// begin hc_class := 21 ;
47089: LD_ADDR_OWVAR 28
47093: PUSH
47094: LD_INT 21
47096: ST_TO_ADDR
// hc_gallery :=  ;
47097: LD_ADDR_OWVAR 33
47101: PUSH
47102: LD_STRING 
47104: ST_TO_ADDR
// animal := CreateHuman ;
47105: LD_ADDR_VAR 0 12
47109: PUSH
47110: CALL_OW 44
47114: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47115: LD_VAR 0 12
47119: PPUSH
47120: LD_VAR 0 8
47124: PPUSH
47125: LD_INT 0
47127: PPUSH
47128: CALL 49253 0 3
// end ;
47132: GO 47086
47134: POP
47135: POP
// if birds then
47136: LD_VAR 0 1
47140: IFFALSE 47207
// for i = 1 to birds do
47142: LD_ADDR_VAR 0 11
47146: PUSH
47147: DOUBLE
47148: LD_INT 1
47150: DEC
47151: ST_TO_ADDR
47152: LD_VAR 0 1
47156: PUSH
47157: FOR_TO
47158: IFFALSE 47205
// begin hc_class = 18 ;
47160: LD_ADDR_OWVAR 28
47164: PUSH
47165: LD_INT 18
47167: ST_TO_ADDR
// hc_gallery =  ;
47168: LD_ADDR_OWVAR 33
47172: PUSH
47173: LD_STRING 
47175: ST_TO_ADDR
// animal := CreateHuman ;
47176: LD_ADDR_VAR 0 12
47180: PUSH
47181: CALL_OW 44
47185: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47186: LD_VAR 0 12
47190: PPUSH
47191: LD_VAR 0 8
47195: PPUSH
47196: LD_INT 0
47198: PPUSH
47199: CALL 49253 0 3
// end ;
47203: GO 47157
47205: POP
47206: POP
// if tigers then
47207: LD_VAR 0 2
47211: IFFALSE 47295
// for i = 1 to tigers do
47213: LD_ADDR_VAR 0 11
47217: PUSH
47218: DOUBLE
47219: LD_INT 1
47221: DEC
47222: ST_TO_ADDR
47223: LD_VAR 0 2
47227: PUSH
47228: FOR_TO
47229: IFFALSE 47293
// begin hc_class = class_tiger ;
47231: LD_ADDR_OWVAR 28
47235: PUSH
47236: LD_INT 14
47238: ST_TO_ADDR
// hc_gallery =  ;
47239: LD_ADDR_OWVAR 33
47243: PUSH
47244: LD_STRING 
47246: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47247: LD_ADDR_OWVAR 35
47251: PUSH
47252: LD_INT 7
47254: NEG
47255: PPUSH
47256: LD_INT 7
47258: PPUSH
47259: CALL_OW 12
47263: ST_TO_ADDR
// animal := CreateHuman ;
47264: LD_ADDR_VAR 0 12
47268: PUSH
47269: CALL_OW 44
47273: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47274: LD_VAR 0 12
47278: PPUSH
47279: LD_VAR 0 8
47283: PPUSH
47284: LD_INT 0
47286: PPUSH
47287: CALL 49253 0 3
// end ;
47291: GO 47228
47293: POP
47294: POP
// if apemans then
47295: LD_VAR 0 3
47299: IFFALSE 47422
// for i = 1 to apemans do
47301: LD_ADDR_VAR 0 11
47305: PUSH
47306: DOUBLE
47307: LD_INT 1
47309: DEC
47310: ST_TO_ADDR
47311: LD_VAR 0 3
47315: PUSH
47316: FOR_TO
47317: IFFALSE 47420
// begin hc_class = class_apeman ;
47319: LD_ADDR_OWVAR 28
47323: PUSH
47324: LD_INT 12
47326: ST_TO_ADDR
// hc_gallery =  ;
47327: LD_ADDR_OWVAR 33
47331: PUSH
47332: LD_STRING 
47334: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
47335: LD_ADDR_OWVAR 35
47339: PUSH
47340: LD_INT 2
47342: NEG
47343: PPUSH
47344: LD_INT 2
47346: PPUSH
47347: CALL_OW 12
47351: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
47352: LD_ADDR_OWVAR 31
47356: PUSH
47357: LD_INT 1
47359: PPUSH
47360: LD_INT 3
47362: PPUSH
47363: CALL_OW 12
47367: PUSH
47368: LD_INT 1
47370: PPUSH
47371: LD_INT 3
47373: PPUSH
47374: CALL_OW 12
47378: PUSH
47379: LD_INT 0
47381: PUSH
47382: LD_INT 0
47384: PUSH
47385: EMPTY
47386: LIST
47387: LIST
47388: LIST
47389: LIST
47390: ST_TO_ADDR
// animal := CreateHuman ;
47391: LD_ADDR_VAR 0 12
47395: PUSH
47396: CALL_OW 44
47400: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47401: LD_VAR 0 12
47405: PPUSH
47406: LD_VAR 0 8
47410: PPUSH
47411: LD_INT 0
47413: PPUSH
47414: CALL 49253 0 3
// end ;
47418: GO 47316
47420: POP
47421: POP
// if enchidnas then
47422: LD_VAR 0 4
47426: IFFALSE 47493
// for i = 1 to enchidnas do
47428: LD_ADDR_VAR 0 11
47432: PUSH
47433: DOUBLE
47434: LD_INT 1
47436: DEC
47437: ST_TO_ADDR
47438: LD_VAR 0 4
47442: PUSH
47443: FOR_TO
47444: IFFALSE 47491
// begin hc_class = 13 ;
47446: LD_ADDR_OWVAR 28
47450: PUSH
47451: LD_INT 13
47453: ST_TO_ADDR
// hc_gallery =  ;
47454: LD_ADDR_OWVAR 33
47458: PUSH
47459: LD_STRING 
47461: ST_TO_ADDR
// animal := CreateHuman ;
47462: LD_ADDR_VAR 0 12
47466: PUSH
47467: CALL_OW 44
47471: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47472: LD_VAR 0 12
47476: PPUSH
47477: LD_VAR 0 8
47481: PPUSH
47482: LD_INT 0
47484: PPUSH
47485: CALL 49253 0 3
// end ;
47489: GO 47443
47491: POP
47492: POP
// if fishes then
47493: LD_VAR 0 7
47497: IFFALSE 47564
// for i = 1 to fishes do
47499: LD_ADDR_VAR 0 11
47503: PUSH
47504: DOUBLE
47505: LD_INT 1
47507: DEC
47508: ST_TO_ADDR
47509: LD_VAR 0 7
47513: PUSH
47514: FOR_TO
47515: IFFALSE 47562
// begin hc_class = 20 ;
47517: LD_ADDR_OWVAR 28
47521: PUSH
47522: LD_INT 20
47524: ST_TO_ADDR
// hc_gallery =  ;
47525: LD_ADDR_OWVAR 33
47529: PUSH
47530: LD_STRING 
47532: ST_TO_ADDR
// animal := CreateHuman ;
47533: LD_ADDR_VAR 0 12
47537: PUSH
47538: CALL_OW 44
47542: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
47543: LD_VAR 0 12
47547: PPUSH
47548: LD_VAR 0 9
47552: PPUSH
47553: LD_INT 0
47555: PPUSH
47556: CALL 49253 0 3
// end ;
47560: GO 47514
47562: POP
47563: POP
// end ;
47564: LD_VAR 0 10
47568: RET
// export function WantHeal ( sci , unit ) ; begin
47569: LD_INT 0
47571: PPUSH
// if GetTaskList ( sci ) > 0 then
47572: LD_VAR 0 1
47576: PPUSH
47577: CALL_OW 437
47581: PUSH
47582: LD_INT 0
47584: GREATER
47585: IFFALSE 47655
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
47587: LD_VAR 0 1
47591: PPUSH
47592: CALL_OW 437
47596: PUSH
47597: LD_INT 1
47599: ARRAY
47600: PUSH
47601: LD_INT 1
47603: ARRAY
47604: PUSH
47605: LD_STRING l
47607: EQUAL
47608: PUSH
47609: LD_VAR 0 1
47613: PPUSH
47614: CALL_OW 437
47618: PUSH
47619: LD_INT 1
47621: ARRAY
47622: PUSH
47623: LD_INT 4
47625: ARRAY
47626: PUSH
47627: LD_VAR 0 2
47631: EQUAL
47632: AND
47633: IFFALSE 47645
// result := true else
47635: LD_ADDR_VAR 0 3
47639: PUSH
47640: LD_INT 1
47642: ST_TO_ADDR
47643: GO 47653
// result := false ;
47645: LD_ADDR_VAR 0 3
47649: PUSH
47650: LD_INT 0
47652: ST_TO_ADDR
// end else
47653: GO 47663
// result := false ;
47655: LD_ADDR_VAR 0 3
47659: PUSH
47660: LD_INT 0
47662: ST_TO_ADDR
// end ;
47663: LD_VAR 0 3
47667: RET
// export function HealTarget ( sci ) ; begin
47668: LD_INT 0
47670: PPUSH
// if not sci then
47671: LD_VAR 0 1
47675: NOT
47676: IFFALSE 47680
// exit ;
47678: GO 47745
// result := 0 ;
47680: LD_ADDR_VAR 0 2
47684: PUSH
47685: LD_INT 0
47687: ST_TO_ADDR
// if GetTaskList ( sci ) then
47688: LD_VAR 0 1
47692: PPUSH
47693: CALL_OW 437
47697: IFFALSE 47745
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
47699: LD_VAR 0 1
47703: PPUSH
47704: CALL_OW 437
47708: PUSH
47709: LD_INT 1
47711: ARRAY
47712: PUSH
47713: LD_INT 1
47715: ARRAY
47716: PUSH
47717: LD_STRING l
47719: EQUAL
47720: IFFALSE 47745
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
47722: LD_ADDR_VAR 0 2
47726: PUSH
47727: LD_VAR 0 1
47731: PPUSH
47732: CALL_OW 437
47736: PUSH
47737: LD_INT 1
47739: ARRAY
47740: PUSH
47741: LD_INT 4
47743: ARRAY
47744: ST_TO_ADDR
// end ;
47745: LD_VAR 0 2
47749: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
47750: LD_INT 0
47752: PPUSH
47753: PPUSH
47754: PPUSH
47755: PPUSH
// if not base_units then
47756: LD_VAR 0 1
47760: NOT
47761: IFFALSE 47765
// exit ;
47763: GO 47852
// result := false ;
47765: LD_ADDR_VAR 0 2
47769: PUSH
47770: LD_INT 0
47772: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
47773: LD_ADDR_VAR 0 5
47777: PUSH
47778: LD_VAR 0 1
47782: PPUSH
47783: LD_INT 21
47785: PUSH
47786: LD_INT 3
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: PPUSH
47793: CALL_OW 72
47797: ST_TO_ADDR
// if not tmp then
47798: LD_VAR 0 5
47802: NOT
47803: IFFALSE 47807
// exit ;
47805: GO 47852
// for i in tmp do
47807: LD_ADDR_VAR 0 3
47811: PUSH
47812: LD_VAR 0 5
47816: PUSH
47817: FOR_IN
47818: IFFALSE 47850
// begin result := EnemyInRange ( i , 22 ) ;
47820: LD_ADDR_VAR 0 2
47824: PUSH
47825: LD_VAR 0 3
47829: PPUSH
47830: LD_INT 22
47832: PPUSH
47833: CALL 46088 0 2
47837: ST_TO_ADDR
// if result then
47838: LD_VAR 0 2
47842: IFFALSE 47848
// exit ;
47844: POP
47845: POP
47846: GO 47852
// end ;
47848: GO 47817
47850: POP
47851: POP
// end ;
47852: LD_VAR 0 2
47856: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
47857: LD_INT 0
47859: PPUSH
47860: PPUSH
// if not units then
47861: LD_VAR 0 1
47865: NOT
47866: IFFALSE 47870
// exit ;
47868: GO 47940
// result := [ ] ;
47870: LD_ADDR_VAR 0 3
47874: PUSH
47875: EMPTY
47876: ST_TO_ADDR
// for i in units do
47877: LD_ADDR_VAR 0 4
47881: PUSH
47882: LD_VAR 0 1
47886: PUSH
47887: FOR_IN
47888: IFFALSE 47938
// if GetTag ( i ) = tag then
47890: LD_VAR 0 4
47894: PPUSH
47895: CALL_OW 110
47899: PUSH
47900: LD_VAR 0 2
47904: EQUAL
47905: IFFALSE 47936
// result := Replace ( result , result + 1 , i ) ;
47907: LD_ADDR_VAR 0 3
47911: PUSH
47912: LD_VAR 0 3
47916: PPUSH
47917: LD_VAR 0 3
47921: PUSH
47922: LD_INT 1
47924: PLUS
47925: PPUSH
47926: LD_VAR 0 4
47930: PPUSH
47931: CALL_OW 1
47935: ST_TO_ADDR
47936: GO 47887
47938: POP
47939: POP
// end ;
47940: LD_VAR 0 3
47944: RET
// export function IsDriver ( un ) ; begin
47945: LD_INT 0
47947: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47948: LD_ADDR_VAR 0 2
47952: PUSH
47953: LD_VAR 0 1
47957: PUSH
47958: LD_INT 55
47960: PUSH
47961: EMPTY
47962: LIST
47963: PPUSH
47964: CALL_OW 69
47968: IN
47969: ST_TO_ADDR
// end ;
47970: LD_VAR 0 2
47974: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47975: LD_INT 0
47977: PPUSH
47978: PPUSH
// list := [ ] ;
47979: LD_ADDR_VAR 0 5
47983: PUSH
47984: EMPTY
47985: ST_TO_ADDR
// case d of 0 :
47986: LD_VAR 0 3
47990: PUSH
47991: LD_INT 0
47993: DOUBLE
47994: EQUAL
47995: IFTRUE 47999
47997: GO 48132
47999: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
48000: LD_ADDR_VAR 0 5
48004: PUSH
48005: LD_VAR 0 1
48009: PUSH
48010: LD_INT 4
48012: MINUS
48013: PUSH
48014: LD_VAR 0 2
48018: PUSH
48019: LD_INT 4
48021: MINUS
48022: PUSH
48023: LD_INT 2
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: LIST
48030: PUSH
48031: LD_VAR 0 1
48035: PUSH
48036: LD_INT 3
48038: MINUS
48039: PUSH
48040: LD_VAR 0 2
48044: PUSH
48045: LD_INT 1
48047: PUSH
48048: EMPTY
48049: LIST
48050: LIST
48051: LIST
48052: PUSH
48053: LD_VAR 0 1
48057: PUSH
48058: LD_INT 4
48060: PLUS
48061: PUSH
48062: LD_VAR 0 2
48066: PUSH
48067: LD_INT 4
48069: PUSH
48070: EMPTY
48071: LIST
48072: LIST
48073: LIST
48074: PUSH
48075: LD_VAR 0 1
48079: PUSH
48080: LD_INT 3
48082: PLUS
48083: PUSH
48084: LD_VAR 0 2
48088: PUSH
48089: LD_INT 3
48091: PLUS
48092: PUSH
48093: LD_INT 5
48095: PUSH
48096: EMPTY
48097: LIST
48098: LIST
48099: LIST
48100: PUSH
48101: LD_VAR 0 1
48105: PUSH
48106: LD_VAR 0 2
48110: PUSH
48111: LD_INT 4
48113: PLUS
48114: PUSH
48115: LD_INT 0
48117: PUSH
48118: EMPTY
48119: LIST
48120: LIST
48121: LIST
48122: PUSH
48123: EMPTY
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: ST_TO_ADDR
// end ; 1 :
48130: GO 48830
48132: LD_INT 1
48134: DOUBLE
48135: EQUAL
48136: IFTRUE 48140
48138: GO 48273
48140: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48141: LD_ADDR_VAR 0 5
48145: PUSH
48146: LD_VAR 0 1
48150: PUSH
48151: LD_VAR 0 2
48155: PUSH
48156: LD_INT 4
48158: MINUS
48159: PUSH
48160: LD_INT 3
48162: PUSH
48163: EMPTY
48164: LIST
48165: LIST
48166: LIST
48167: PUSH
48168: LD_VAR 0 1
48172: PUSH
48173: LD_INT 3
48175: MINUS
48176: PUSH
48177: LD_VAR 0 2
48181: PUSH
48182: LD_INT 3
48184: MINUS
48185: PUSH
48186: LD_INT 2
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: LIST
48193: PUSH
48194: LD_VAR 0 1
48198: PUSH
48199: LD_INT 4
48201: MINUS
48202: PUSH
48203: LD_VAR 0 2
48207: PUSH
48208: LD_INT 1
48210: PUSH
48211: EMPTY
48212: LIST
48213: LIST
48214: LIST
48215: PUSH
48216: LD_VAR 0 1
48220: PUSH
48221: LD_VAR 0 2
48225: PUSH
48226: LD_INT 3
48228: PLUS
48229: PUSH
48230: LD_INT 0
48232: PUSH
48233: EMPTY
48234: LIST
48235: LIST
48236: LIST
48237: PUSH
48238: LD_VAR 0 1
48242: PUSH
48243: LD_INT 4
48245: PLUS
48246: PUSH
48247: LD_VAR 0 2
48251: PUSH
48252: LD_INT 4
48254: PLUS
48255: PUSH
48256: LD_INT 5
48258: PUSH
48259: EMPTY
48260: LIST
48261: LIST
48262: LIST
48263: PUSH
48264: EMPTY
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: ST_TO_ADDR
// end ; 2 :
48271: GO 48830
48273: LD_INT 2
48275: DOUBLE
48276: EQUAL
48277: IFTRUE 48281
48279: GO 48410
48281: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48282: LD_ADDR_VAR 0 5
48286: PUSH
48287: LD_VAR 0 1
48291: PUSH
48292: LD_VAR 0 2
48296: PUSH
48297: LD_INT 3
48299: MINUS
48300: PUSH
48301: LD_INT 3
48303: PUSH
48304: EMPTY
48305: LIST
48306: LIST
48307: LIST
48308: PUSH
48309: LD_VAR 0 1
48313: PUSH
48314: LD_INT 4
48316: PLUS
48317: PUSH
48318: LD_VAR 0 2
48322: PUSH
48323: LD_INT 4
48325: PUSH
48326: EMPTY
48327: LIST
48328: LIST
48329: LIST
48330: PUSH
48331: LD_VAR 0 1
48335: PUSH
48336: LD_VAR 0 2
48340: PUSH
48341: LD_INT 4
48343: PLUS
48344: PUSH
48345: LD_INT 0
48347: PUSH
48348: EMPTY
48349: LIST
48350: LIST
48351: LIST
48352: PUSH
48353: LD_VAR 0 1
48357: PUSH
48358: LD_INT 3
48360: MINUS
48361: PUSH
48362: LD_VAR 0 2
48366: PUSH
48367: LD_INT 1
48369: PUSH
48370: EMPTY
48371: LIST
48372: LIST
48373: LIST
48374: PUSH
48375: LD_VAR 0 1
48379: PUSH
48380: LD_INT 4
48382: MINUS
48383: PUSH
48384: LD_VAR 0 2
48388: PUSH
48389: LD_INT 4
48391: MINUS
48392: PUSH
48393: LD_INT 2
48395: PUSH
48396: EMPTY
48397: LIST
48398: LIST
48399: LIST
48400: PUSH
48401: EMPTY
48402: LIST
48403: LIST
48404: LIST
48405: LIST
48406: LIST
48407: ST_TO_ADDR
// end ; 3 :
48408: GO 48830
48410: LD_INT 3
48412: DOUBLE
48413: EQUAL
48414: IFTRUE 48418
48416: GO 48551
48418: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
48419: LD_ADDR_VAR 0 5
48423: PUSH
48424: LD_VAR 0 1
48428: PUSH
48429: LD_INT 3
48431: PLUS
48432: PUSH
48433: LD_VAR 0 2
48437: PUSH
48438: LD_INT 4
48440: PUSH
48441: EMPTY
48442: LIST
48443: LIST
48444: LIST
48445: PUSH
48446: LD_VAR 0 1
48450: PUSH
48451: LD_INT 4
48453: PLUS
48454: PUSH
48455: LD_VAR 0 2
48459: PUSH
48460: LD_INT 4
48462: PLUS
48463: PUSH
48464: LD_INT 5
48466: PUSH
48467: EMPTY
48468: LIST
48469: LIST
48470: LIST
48471: PUSH
48472: LD_VAR 0 1
48476: PUSH
48477: LD_INT 4
48479: MINUS
48480: PUSH
48481: LD_VAR 0 2
48485: PUSH
48486: LD_INT 1
48488: PUSH
48489: EMPTY
48490: LIST
48491: LIST
48492: LIST
48493: PUSH
48494: LD_VAR 0 1
48498: PUSH
48499: LD_VAR 0 2
48503: PUSH
48504: LD_INT 4
48506: MINUS
48507: PUSH
48508: LD_INT 3
48510: PUSH
48511: EMPTY
48512: LIST
48513: LIST
48514: LIST
48515: PUSH
48516: LD_VAR 0 1
48520: PUSH
48521: LD_INT 3
48523: MINUS
48524: PUSH
48525: LD_VAR 0 2
48529: PUSH
48530: LD_INT 3
48532: MINUS
48533: PUSH
48534: LD_INT 2
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: LIST
48541: PUSH
48542: EMPTY
48543: LIST
48544: LIST
48545: LIST
48546: LIST
48547: LIST
48548: ST_TO_ADDR
// end ; 4 :
48549: GO 48830
48551: LD_INT 4
48553: DOUBLE
48554: EQUAL
48555: IFTRUE 48559
48557: GO 48692
48559: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
48560: LD_ADDR_VAR 0 5
48564: PUSH
48565: LD_VAR 0 1
48569: PUSH
48570: LD_VAR 0 2
48574: PUSH
48575: LD_INT 4
48577: PLUS
48578: PUSH
48579: LD_INT 0
48581: PUSH
48582: EMPTY
48583: LIST
48584: LIST
48585: LIST
48586: PUSH
48587: LD_VAR 0 1
48591: PUSH
48592: LD_INT 3
48594: PLUS
48595: PUSH
48596: LD_VAR 0 2
48600: PUSH
48601: LD_INT 3
48603: PLUS
48604: PUSH
48605: LD_INT 5
48607: PUSH
48608: EMPTY
48609: LIST
48610: LIST
48611: LIST
48612: PUSH
48613: LD_VAR 0 1
48617: PUSH
48618: LD_INT 4
48620: PLUS
48621: PUSH
48622: LD_VAR 0 2
48626: PUSH
48627: LD_INT 4
48629: PUSH
48630: EMPTY
48631: LIST
48632: LIST
48633: LIST
48634: PUSH
48635: LD_VAR 0 1
48639: PUSH
48640: LD_VAR 0 2
48644: PUSH
48645: LD_INT 3
48647: MINUS
48648: PUSH
48649: LD_INT 3
48651: PUSH
48652: EMPTY
48653: LIST
48654: LIST
48655: LIST
48656: PUSH
48657: LD_VAR 0 1
48661: PUSH
48662: LD_INT 4
48664: MINUS
48665: PUSH
48666: LD_VAR 0 2
48670: PUSH
48671: LD_INT 4
48673: MINUS
48674: PUSH
48675: LD_INT 2
48677: PUSH
48678: EMPTY
48679: LIST
48680: LIST
48681: LIST
48682: PUSH
48683: EMPTY
48684: LIST
48685: LIST
48686: LIST
48687: LIST
48688: LIST
48689: ST_TO_ADDR
// end ; 5 :
48690: GO 48830
48692: LD_INT 5
48694: DOUBLE
48695: EQUAL
48696: IFTRUE 48700
48698: GO 48829
48700: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
48701: LD_ADDR_VAR 0 5
48705: PUSH
48706: LD_VAR 0 1
48710: PUSH
48711: LD_INT 4
48713: MINUS
48714: PUSH
48715: LD_VAR 0 2
48719: PUSH
48720: LD_INT 1
48722: PUSH
48723: EMPTY
48724: LIST
48725: LIST
48726: LIST
48727: PUSH
48728: LD_VAR 0 1
48732: PUSH
48733: LD_VAR 0 2
48737: PUSH
48738: LD_INT 4
48740: MINUS
48741: PUSH
48742: LD_INT 3
48744: PUSH
48745: EMPTY
48746: LIST
48747: LIST
48748: LIST
48749: PUSH
48750: LD_VAR 0 1
48754: PUSH
48755: LD_INT 4
48757: PLUS
48758: PUSH
48759: LD_VAR 0 2
48763: PUSH
48764: LD_INT 4
48766: PLUS
48767: PUSH
48768: LD_INT 5
48770: PUSH
48771: EMPTY
48772: LIST
48773: LIST
48774: LIST
48775: PUSH
48776: LD_VAR 0 1
48780: PUSH
48781: LD_INT 3
48783: PLUS
48784: PUSH
48785: LD_VAR 0 2
48789: PUSH
48790: LD_INT 4
48792: PUSH
48793: EMPTY
48794: LIST
48795: LIST
48796: LIST
48797: PUSH
48798: LD_VAR 0 1
48802: PUSH
48803: LD_VAR 0 2
48807: PUSH
48808: LD_INT 3
48810: PLUS
48811: PUSH
48812: LD_INT 0
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: LIST
48819: PUSH
48820: EMPTY
48821: LIST
48822: LIST
48823: LIST
48824: LIST
48825: LIST
48826: ST_TO_ADDR
// end ; end ;
48827: GO 48830
48829: POP
// result := list ;
48830: LD_ADDR_VAR 0 4
48834: PUSH
48835: LD_VAR 0 5
48839: ST_TO_ADDR
// end ;
48840: LD_VAR 0 4
48844: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48845: LD_INT 0
48847: PPUSH
48848: PPUSH
48849: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48850: LD_VAR 0 1
48854: NOT
48855: PUSH
48856: LD_VAR 0 2
48860: PUSH
48861: LD_INT 1
48863: PUSH
48864: LD_INT 2
48866: PUSH
48867: LD_INT 3
48869: PUSH
48870: LD_INT 4
48872: PUSH
48873: EMPTY
48874: LIST
48875: LIST
48876: LIST
48877: LIST
48878: IN
48879: NOT
48880: OR
48881: IFFALSE 48885
// exit ;
48883: GO 48977
// tmp := [ ] ;
48885: LD_ADDR_VAR 0 5
48889: PUSH
48890: EMPTY
48891: ST_TO_ADDR
// for i in units do
48892: LD_ADDR_VAR 0 4
48896: PUSH
48897: LD_VAR 0 1
48901: PUSH
48902: FOR_IN
48903: IFFALSE 48946
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48905: LD_ADDR_VAR 0 5
48909: PUSH
48910: LD_VAR 0 5
48914: PPUSH
48915: LD_VAR 0 5
48919: PUSH
48920: LD_INT 1
48922: PLUS
48923: PPUSH
48924: LD_VAR 0 4
48928: PPUSH
48929: LD_VAR 0 2
48933: PPUSH
48934: CALL_OW 259
48938: PPUSH
48939: CALL_OW 2
48943: ST_TO_ADDR
48944: GO 48902
48946: POP
48947: POP
// if not tmp then
48948: LD_VAR 0 5
48952: NOT
48953: IFFALSE 48957
// exit ;
48955: GO 48977
// result := SortListByListDesc ( units , tmp ) ;
48957: LD_ADDR_VAR 0 3
48961: PUSH
48962: LD_VAR 0 1
48966: PPUSH
48967: LD_VAR 0 5
48971: PPUSH
48972: CALL_OW 77
48976: ST_TO_ADDR
// end ;
48977: LD_VAR 0 3
48981: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48982: LD_INT 0
48984: PPUSH
48985: PPUSH
48986: PPUSH
// result := false ;
48987: LD_ADDR_VAR 0 3
48991: PUSH
48992: LD_INT 0
48994: ST_TO_ADDR
// x := GetX ( building ) ;
48995: LD_ADDR_VAR 0 4
48999: PUSH
49000: LD_VAR 0 2
49004: PPUSH
49005: CALL_OW 250
49009: ST_TO_ADDR
// y := GetY ( building ) ;
49010: LD_ADDR_VAR 0 5
49014: PUSH
49015: LD_VAR 0 2
49019: PPUSH
49020: CALL_OW 251
49024: ST_TO_ADDR
// if not building or not x or not y then
49025: LD_VAR 0 2
49029: NOT
49030: PUSH
49031: LD_VAR 0 4
49035: NOT
49036: OR
49037: PUSH
49038: LD_VAR 0 5
49042: NOT
49043: OR
49044: IFFALSE 49048
// exit ;
49046: GO 49140
// if GetTaskList ( unit ) then
49048: LD_VAR 0 1
49052: PPUSH
49053: CALL_OW 437
49057: IFFALSE 49140
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49059: LD_STRING e
49061: PUSH
49062: LD_VAR 0 1
49066: PPUSH
49067: CALL_OW 437
49071: PUSH
49072: LD_INT 1
49074: ARRAY
49075: PUSH
49076: LD_INT 1
49078: ARRAY
49079: EQUAL
49080: PUSH
49081: LD_VAR 0 4
49085: PUSH
49086: LD_VAR 0 1
49090: PPUSH
49091: CALL_OW 437
49095: PUSH
49096: LD_INT 1
49098: ARRAY
49099: PUSH
49100: LD_INT 2
49102: ARRAY
49103: EQUAL
49104: AND
49105: PUSH
49106: LD_VAR 0 5
49110: PUSH
49111: LD_VAR 0 1
49115: PPUSH
49116: CALL_OW 437
49120: PUSH
49121: LD_INT 1
49123: ARRAY
49124: PUSH
49125: LD_INT 3
49127: ARRAY
49128: EQUAL
49129: AND
49130: IFFALSE 49140
// result := true end ;
49132: LD_ADDR_VAR 0 3
49136: PUSH
49137: LD_INT 1
49139: ST_TO_ADDR
// end ;
49140: LD_VAR 0 3
49144: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
49145: LD_INT 0
49147: PPUSH
// result := false ;
49148: LD_ADDR_VAR 0 4
49152: PUSH
49153: LD_INT 0
49155: ST_TO_ADDR
// if GetTaskList ( unit ) then
49156: LD_VAR 0 1
49160: PPUSH
49161: CALL_OW 437
49165: IFFALSE 49248
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49167: LD_STRING M
49169: PUSH
49170: LD_VAR 0 1
49174: PPUSH
49175: CALL_OW 437
49179: PUSH
49180: LD_INT 1
49182: ARRAY
49183: PUSH
49184: LD_INT 1
49186: ARRAY
49187: EQUAL
49188: PUSH
49189: LD_VAR 0 2
49193: PUSH
49194: LD_VAR 0 1
49198: PPUSH
49199: CALL_OW 437
49203: PUSH
49204: LD_INT 1
49206: ARRAY
49207: PUSH
49208: LD_INT 2
49210: ARRAY
49211: EQUAL
49212: AND
49213: PUSH
49214: LD_VAR 0 3
49218: PUSH
49219: LD_VAR 0 1
49223: PPUSH
49224: CALL_OW 437
49228: PUSH
49229: LD_INT 1
49231: ARRAY
49232: PUSH
49233: LD_INT 3
49235: ARRAY
49236: EQUAL
49237: AND
49238: IFFALSE 49248
// result := true ;
49240: LD_ADDR_VAR 0 4
49244: PUSH
49245: LD_INT 1
49247: ST_TO_ADDR
// end ; end ;
49248: LD_VAR 0 4
49252: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49253: LD_INT 0
49255: PPUSH
49256: PPUSH
49257: PPUSH
49258: PPUSH
// if not unit or not area then
49259: LD_VAR 0 1
49263: NOT
49264: PUSH
49265: LD_VAR 0 2
49269: NOT
49270: OR
49271: IFFALSE 49275
// exit ;
49273: GO 49439
// tmp := AreaToList ( area , i ) ;
49275: LD_ADDR_VAR 0 6
49279: PUSH
49280: LD_VAR 0 2
49284: PPUSH
49285: LD_VAR 0 5
49289: PPUSH
49290: CALL_OW 517
49294: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49295: LD_ADDR_VAR 0 5
49299: PUSH
49300: DOUBLE
49301: LD_INT 1
49303: DEC
49304: ST_TO_ADDR
49305: LD_VAR 0 6
49309: PUSH
49310: LD_INT 1
49312: ARRAY
49313: PUSH
49314: FOR_TO
49315: IFFALSE 49437
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49317: LD_ADDR_VAR 0 7
49321: PUSH
49322: LD_VAR 0 6
49326: PUSH
49327: LD_INT 1
49329: ARRAY
49330: PUSH
49331: LD_VAR 0 5
49335: ARRAY
49336: PUSH
49337: LD_VAR 0 6
49341: PUSH
49342: LD_INT 2
49344: ARRAY
49345: PUSH
49346: LD_VAR 0 5
49350: ARRAY
49351: PUSH
49352: EMPTY
49353: LIST
49354: LIST
49355: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
49356: LD_VAR 0 7
49360: PUSH
49361: LD_INT 1
49363: ARRAY
49364: PPUSH
49365: LD_VAR 0 7
49369: PUSH
49370: LD_INT 2
49372: ARRAY
49373: PPUSH
49374: CALL_OW 428
49378: PUSH
49379: LD_INT 0
49381: EQUAL
49382: IFFALSE 49435
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
49384: LD_VAR 0 1
49388: PPUSH
49389: LD_VAR 0 7
49393: PUSH
49394: LD_INT 1
49396: ARRAY
49397: PPUSH
49398: LD_VAR 0 7
49402: PUSH
49403: LD_INT 2
49405: ARRAY
49406: PPUSH
49407: LD_VAR 0 3
49411: PPUSH
49412: CALL_OW 48
// result := IsPlaced ( unit ) ;
49416: LD_ADDR_VAR 0 4
49420: PUSH
49421: LD_VAR 0 1
49425: PPUSH
49426: CALL_OW 305
49430: ST_TO_ADDR
// exit ;
49431: POP
49432: POP
49433: GO 49439
// end ; end ;
49435: GO 49314
49437: POP
49438: POP
// end ;
49439: LD_VAR 0 4
49443: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
49444: LD_INT 0
49446: PPUSH
49447: PPUSH
49448: PPUSH
// if not side or side > 8 then
49449: LD_VAR 0 1
49453: NOT
49454: PUSH
49455: LD_VAR 0 1
49459: PUSH
49460: LD_INT 8
49462: GREATER
49463: OR
49464: IFFALSE 49468
// exit ;
49466: GO 49655
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
49468: LD_ADDR_VAR 0 4
49472: PUSH
49473: LD_INT 22
49475: PUSH
49476: LD_VAR 0 1
49480: PUSH
49481: EMPTY
49482: LIST
49483: LIST
49484: PUSH
49485: LD_INT 21
49487: PUSH
49488: LD_INT 3
49490: PUSH
49491: EMPTY
49492: LIST
49493: LIST
49494: PUSH
49495: EMPTY
49496: LIST
49497: LIST
49498: PPUSH
49499: CALL_OW 69
49503: ST_TO_ADDR
// if not tmp then
49504: LD_VAR 0 4
49508: NOT
49509: IFFALSE 49513
// exit ;
49511: GO 49655
// enable_addtolog := true ;
49513: LD_ADDR_OWVAR 81
49517: PUSH
49518: LD_INT 1
49520: ST_TO_ADDR
// AddToLog ( [ ) ;
49521: LD_STRING [
49523: PPUSH
49524: CALL_OW 561
// for i in tmp do
49528: LD_ADDR_VAR 0 3
49532: PUSH
49533: LD_VAR 0 4
49537: PUSH
49538: FOR_IN
49539: IFFALSE 49646
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
49541: LD_STRING [
49543: PUSH
49544: LD_VAR 0 3
49548: PPUSH
49549: CALL_OW 266
49553: STR
49554: PUSH
49555: LD_STRING , 
49557: STR
49558: PUSH
49559: LD_VAR 0 3
49563: PPUSH
49564: CALL_OW 250
49568: STR
49569: PUSH
49570: LD_STRING , 
49572: STR
49573: PUSH
49574: LD_VAR 0 3
49578: PPUSH
49579: CALL_OW 251
49583: STR
49584: PUSH
49585: LD_STRING , 
49587: STR
49588: PUSH
49589: LD_VAR 0 3
49593: PPUSH
49594: CALL_OW 254
49598: STR
49599: PUSH
49600: LD_STRING , 
49602: STR
49603: PUSH
49604: LD_VAR 0 3
49608: PPUSH
49609: LD_INT 1
49611: PPUSH
49612: CALL_OW 268
49616: STR
49617: PUSH
49618: LD_STRING , 
49620: STR
49621: PUSH
49622: LD_VAR 0 3
49626: PPUSH
49627: LD_INT 2
49629: PPUSH
49630: CALL_OW 268
49634: STR
49635: PUSH
49636: LD_STRING ],
49638: STR
49639: PPUSH
49640: CALL_OW 561
// end ;
49644: GO 49538
49646: POP
49647: POP
// AddToLog ( ]; ) ;
49648: LD_STRING ];
49650: PPUSH
49651: CALL_OW 561
// end ;
49655: LD_VAR 0 2
49659: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
49660: LD_INT 0
49662: PPUSH
49663: PPUSH
49664: PPUSH
49665: PPUSH
49666: PPUSH
// if not area or not rate or not max then
49667: LD_VAR 0 1
49671: NOT
49672: PUSH
49673: LD_VAR 0 2
49677: NOT
49678: OR
49679: PUSH
49680: LD_VAR 0 4
49684: NOT
49685: OR
49686: IFFALSE 49690
// exit ;
49688: GO 49882
// while 1 do
49690: LD_INT 1
49692: IFFALSE 49882
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
49694: LD_ADDR_VAR 0 9
49698: PUSH
49699: LD_VAR 0 1
49703: PPUSH
49704: LD_INT 1
49706: PPUSH
49707: CALL_OW 287
49711: PUSH
49712: LD_INT 10
49714: MUL
49715: ST_TO_ADDR
// r := rate / 10 ;
49716: LD_ADDR_VAR 0 7
49720: PUSH
49721: LD_VAR 0 2
49725: PUSH
49726: LD_INT 10
49728: DIVREAL
49729: ST_TO_ADDR
// time := 1 1$00 ;
49730: LD_ADDR_VAR 0 8
49734: PUSH
49735: LD_INT 2100
49737: ST_TO_ADDR
// if amount < min then
49738: LD_VAR 0 9
49742: PUSH
49743: LD_VAR 0 3
49747: LESS
49748: IFFALSE 49766
// r := r * 2 else
49750: LD_ADDR_VAR 0 7
49754: PUSH
49755: LD_VAR 0 7
49759: PUSH
49760: LD_INT 2
49762: MUL
49763: ST_TO_ADDR
49764: GO 49792
// if amount > max then
49766: LD_VAR 0 9
49770: PUSH
49771: LD_VAR 0 4
49775: GREATER
49776: IFFALSE 49792
// r := r / 2 ;
49778: LD_ADDR_VAR 0 7
49782: PUSH
49783: LD_VAR 0 7
49787: PUSH
49788: LD_INT 2
49790: DIVREAL
49791: ST_TO_ADDR
// time := time / r ;
49792: LD_ADDR_VAR 0 8
49796: PUSH
49797: LD_VAR 0 8
49801: PUSH
49802: LD_VAR 0 7
49806: DIVREAL
49807: ST_TO_ADDR
// if time < 0 then
49808: LD_VAR 0 8
49812: PUSH
49813: LD_INT 0
49815: LESS
49816: IFFALSE 49833
// time := time * - 1 ;
49818: LD_ADDR_VAR 0 8
49822: PUSH
49823: LD_VAR 0 8
49827: PUSH
49828: LD_INT 1
49830: NEG
49831: MUL
49832: ST_TO_ADDR
// wait ( time ) ;
49833: LD_VAR 0 8
49837: PPUSH
49838: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
49842: LD_INT 35
49844: PPUSH
49845: LD_INT 875
49847: PPUSH
49848: CALL_OW 12
49852: PPUSH
49853: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
49857: LD_INT 1
49859: PPUSH
49860: LD_INT 5
49862: PPUSH
49863: CALL_OW 12
49867: PPUSH
49868: LD_VAR 0 1
49872: PPUSH
49873: LD_INT 1
49875: PPUSH
49876: CALL_OW 55
// end ;
49880: GO 49690
// end ;
49882: LD_VAR 0 5
49886: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
49887: LD_INT 0
49889: PPUSH
49890: PPUSH
49891: PPUSH
49892: PPUSH
49893: PPUSH
49894: PPUSH
49895: PPUSH
49896: PPUSH
// if not turrets or not factories then
49897: LD_VAR 0 1
49901: NOT
49902: PUSH
49903: LD_VAR 0 2
49907: NOT
49908: OR
49909: IFFALSE 49913
// exit ;
49911: GO 50220
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49913: LD_ADDR_VAR 0 10
49917: PUSH
49918: LD_INT 5
49920: PUSH
49921: LD_INT 6
49923: PUSH
49924: EMPTY
49925: LIST
49926: LIST
49927: PUSH
49928: LD_INT 2
49930: PUSH
49931: LD_INT 4
49933: PUSH
49934: EMPTY
49935: LIST
49936: LIST
49937: PUSH
49938: LD_INT 3
49940: PUSH
49941: LD_INT 5
49943: PUSH
49944: EMPTY
49945: LIST
49946: LIST
49947: PUSH
49948: EMPTY
49949: LIST
49950: LIST
49951: LIST
49952: PUSH
49953: LD_INT 24
49955: PUSH
49956: LD_INT 25
49958: PUSH
49959: EMPTY
49960: LIST
49961: LIST
49962: PUSH
49963: LD_INT 23
49965: PUSH
49966: LD_INT 27
49968: PUSH
49969: EMPTY
49970: LIST
49971: LIST
49972: PUSH
49973: EMPTY
49974: LIST
49975: LIST
49976: PUSH
49977: LD_INT 42
49979: PUSH
49980: LD_INT 43
49982: PUSH
49983: EMPTY
49984: LIST
49985: LIST
49986: PUSH
49987: LD_INT 44
49989: PUSH
49990: LD_INT 46
49992: PUSH
49993: EMPTY
49994: LIST
49995: LIST
49996: PUSH
49997: LD_INT 45
49999: PUSH
50000: LD_INT 47
50002: PUSH
50003: EMPTY
50004: LIST
50005: LIST
50006: PUSH
50007: EMPTY
50008: LIST
50009: LIST
50010: LIST
50011: PUSH
50012: EMPTY
50013: LIST
50014: LIST
50015: LIST
50016: ST_TO_ADDR
// result := [ ] ;
50017: LD_ADDR_VAR 0 3
50021: PUSH
50022: EMPTY
50023: ST_TO_ADDR
// for i in turrets do
50024: LD_ADDR_VAR 0 4
50028: PUSH
50029: LD_VAR 0 1
50033: PUSH
50034: FOR_IN
50035: IFFALSE 50218
// begin nat := GetNation ( i ) ;
50037: LD_ADDR_VAR 0 7
50041: PUSH
50042: LD_VAR 0 4
50046: PPUSH
50047: CALL_OW 248
50051: ST_TO_ADDR
// weapon := 0 ;
50052: LD_ADDR_VAR 0 8
50056: PUSH
50057: LD_INT 0
50059: ST_TO_ADDR
// if not nat then
50060: LD_VAR 0 7
50064: NOT
50065: IFFALSE 50069
// continue ;
50067: GO 50034
// for j in list [ nat ] do
50069: LD_ADDR_VAR 0 5
50073: PUSH
50074: LD_VAR 0 10
50078: PUSH
50079: LD_VAR 0 7
50083: ARRAY
50084: PUSH
50085: FOR_IN
50086: IFFALSE 50127
// if GetBWeapon ( i ) = j [ 1 ] then
50088: LD_VAR 0 4
50092: PPUSH
50093: CALL_OW 269
50097: PUSH
50098: LD_VAR 0 5
50102: PUSH
50103: LD_INT 1
50105: ARRAY
50106: EQUAL
50107: IFFALSE 50125
// begin weapon := j [ 2 ] ;
50109: LD_ADDR_VAR 0 8
50113: PUSH
50114: LD_VAR 0 5
50118: PUSH
50119: LD_INT 2
50121: ARRAY
50122: ST_TO_ADDR
// break ;
50123: GO 50127
// end ;
50125: GO 50085
50127: POP
50128: POP
// if not weapon then
50129: LD_VAR 0 8
50133: NOT
50134: IFFALSE 50138
// continue ;
50136: GO 50034
// for k in factories do
50138: LD_ADDR_VAR 0 6
50142: PUSH
50143: LD_VAR 0 2
50147: PUSH
50148: FOR_IN
50149: IFFALSE 50214
// begin weapons := AvailableWeaponList ( k ) ;
50151: LD_ADDR_VAR 0 9
50155: PUSH
50156: LD_VAR 0 6
50160: PPUSH
50161: CALL_OW 478
50165: ST_TO_ADDR
// if not weapons then
50166: LD_VAR 0 9
50170: NOT
50171: IFFALSE 50175
// continue ;
50173: GO 50148
// if weapon in weapons then
50175: LD_VAR 0 8
50179: PUSH
50180: LD_VAR 0 9
50184: IN
50185: IFFALSE 50212
// begin result := [ i , weapon ] ;
50187: LD_ADDR_VAR 0 3
50191: PUSH
50192: LD_VAR 0 4
50196: PUSH
50197: LD_VAR 0 8
50201: PUSH
50202: EMPTY
50203: LIST
50204: LIST
50205: ST_TO_ADDR
// exit ;
50206: POP
50207: POP
50208: POP
50209: POP
50210: GO 50220
// end ; end ;
50212: GO 50148
50214: POP
50215: POP
// end ;
50216: GO 50034
50218: POP
50219: POP
// end ;
50220: LD_VAR 0 3
50224: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50225: LD_INT 0
50227: PPUSH
// if not side or side > 8 then
50228: LD_VAR 0 3
50232: NOT
50233: PUSH
50234: LD_VAR 0 3
50238: PUSH
50239: LD_INT 8
50241: GREATER
50242: OR
50243: IFFALSE 50247
// exit ;
50245: GO 50306
// if not range then
50247: LD_VAR 0 4
50251: NOT
50252: IFFALSE 50263
// range := - 12 ;
50254: LD_ADDR_VAR 0 4
50258: PUSH
50259: LD_INT 12
50261: NEG
50262: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50263: LD_VAR 0 1
50267: PPUSH
50268: LD_VAR 0 2
50272: PPUSH
50273: LD_VAR 0 3
50277: PPUSH
50278: LD_VAR 0 4
50282: PPUSH
50283: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50287: LD_VAR 0 1
50291: PPUSH
50292: LD_VAR 0 2
50296: PPUSH
50297: LD_VAR 0 3
50301: PPUSH
50302: CALL_OW 331
// end ;
50306: LD_VAR 0 5
50310: RET
// export function Video ( mode ) ; begin
50311: LD_INT 0
50313: PPUSH
// ingame_video = mode ;
50314: LD_ADDR_OWVAR 52
50318: PUSH
50319: LD_VAR 0 1
50323: ST_TO_ADDR
// interface_hidden = mode ;
50324: LD_ADDR_OWVAR 54
50328: PUSH
50329: LD_VAR 0 1
50333: ST_TO_ADDR
// end ;
50334: LD_VAR 0 2
50338: RET
// export function Join ( array , element ) ; begin
50339: LD_INT 0
50341: PPUSH
// result := Replace ( array , array + 1 , element ) ;
50342: LD_ADDR_VAR 0 3
50346: PUSH
50347: LD_VAR 0 1
50351: PPUSH
50352: LD_VAR 0 1
50356: PUSH
50357: LD_INT 1
50359: PLUS
50360: PPUSH
50361: LD_VAR 0 2
50365: PPUSH
50366: CALL_OW 1
50370: ST_TO_ADDR
// end ;
50371: LD_VAR 0 3
50375: RET
// export function JoinUnion ( array , element ) ; begin
50376: LD_INT 0
50378: PPUSH
// result := array union element ;
50379: LD_ADDR_VAR 0 3
50383: PUSH
50384: LD_VAR 0 1
50388: PUSH
50389: LD_VAR 0 2
50393: UNION
50394: ST_TO_ADDR
// end ;
50395: LD_VAR 0 3
50399: RET
// export function GetBehemoths ( side ) ; begin
50400: LD_INT 0
50402: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
50403: LD_ADDR_VAR 0 2
50407: PUSH
50408: LD_INT 22
50410: PUSH
50411: LD_VAR 0 1
50415: PUSH
50416: EMPTY
50417: LIST
50418: LIST
50419: PUSH
50420: LD_INT 31
50422: PUSH
50423: LD_INT 25
50425: PUSH
50426: EMPTY
50427: LIST
50428: LIST
50429: PUSH
50430: EMPTY
50431: LIST
50432: LIST
50433: PPUSH
50434: CALL_OW 69
50438: ST_TO_ADDR
// end ;
50439: LD_VAR 0 2
50443: RET
// export function Shuffle ( array ) ; var i , index ; begin
50444: LD_INT 0
50446: PPUSH
50447: PPUSH
50448: PPUSH
// result := [ ] ;
50449: LD_ADDR_VAR 0 2
50453: PUSH
50454: EMPTY
50455: ST_TO_ADDR
// if not array then
50456: LD_VAR 0 1
50460: NOT
50461: IFFALSE 50465
// exit ;
50463: GO 50564
// Randomize ;
50465: CALL_OW 10
// for i = array downto 1 do
50469: LD_ADDR_VAR 0 3
50473: PUSH
50474: DOUBLE
50475: LD_VAR 0 1
50479: INC
50480: ST_TO_ADDR
50481: LD_INT 1
50483: PUSH
50484: FOR_DOWNTO
50485: IFFALSE 50562
// begin index := rand ( 1 , array ) ;
50487: LD_ADDR_VAR 0 4
50491: PUSH
50492: LD_INT 1
50494: PPUSH
50495: LD_VAR 0 1
50499: PPUSH
50500: CALL_OW 12
50504: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
50505: LD_ADDR_VAR 0 2
50509: PUSH
50510: LD_VAR 0 2
50514: PPUSH
50515: LD_VAR 0 2
50519: PUSH
50520: LD_INT 1
50522: PLUS
50523: PPUSH
50524: LD_VAR 0 1
50528: PUSH
50529: LD_VAR 0 4
50533: ARRAY
50534: PPUSH
50535: CALL_OW 2
50539: ST_TO_ADDR
// array := Delete ( array , index ) ;
50540: LD_ADDR_VAR 0 1
50544: PUSH
50545: LD_VAR 0 1
50549: PPUSH
50550: LD_VAR 0 4
50554: PPUSH
50555: CALL_OW 3
50559: ST_TO_ADDR
// end ;
50560: GO 50484
50562: POP
50563: POP
// end ;
50564: LD_VAR 0 2
50568: RET
// export function GetBaseMaterials ( base ) ; begin
50569: LD_INT 0
50571: PPUSH
// result := [ 0 , 0 , 0 ] ;
50572: LD_ADDR_VAR 0 2
50576: PUSH
50577: LD_INT 0
50579: PUSH
50580: LD_INT 0
50582: PUSH
50583: LD_INT 0
50585: PUSH
50586: EMPTY
50587: LIST
50588: LIST
50589: LIST
50590: ST_TO_ADDR
// if not base then
50591: LD_VAR 0 1
50595: NOT
50596: IFFALSE 50600
// exit ;
50598: GO 50649
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
50600: LD_ADDR_VAR 0 2
50604: PUSH
50605: LD_VAR 0 1
50609: PPUSH
50610: LD_INT 1
50612: PPUSH
50613: CALL_OW 275
50617: PUSH
50618: LD_VAR 0 1
50622: PPUSH
50623: LD_INT 2
50625: PPUSH
50626: CALL_OW 275
50630: PUSH
50631: LD_VAR 0 1
50635: PPUSH
50636: LD_INT 3
50638: PPUSH
50639: CALL_OW 275
50643: PUSH
50644: EMPTY
50645: LIST
50646: LIST
50647: LIST
50648: ST_TO_ADDR
// end ;
50649: LD_VAR 0 2
50653: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
50654: LD_INT 0
50656: PPUSH
50657: PPUSH
// result := array ;
50658: LD_ADDR_VAR 0 3
50662: PUSH
50663: LD_VAR 0 1
50667: ST_TO_ADDR
// if size > 0 then
50668: LD_VAR 0 2
50672: PUSH
50673: LD_INT 0
50675: GREATER
50676: IFFALSE 50722
// for i := array downto size do
50678: LD_ADDR_VAR 0 4
50682: PUSH
50683: DOUBLE
50684: LD_VAR 0 1
50688: INC
50689: ST_TO_ADDR
50690: LD_VAR 0 2
50694: PUSH
50695: FOR_DOWNTO
50696: IFFALSE 50720
// result := Delete ( result , result ) ;
50698: LD_ADDR_VAR 0 3
50702: PUSH
50703: LD_VAR 0 3
50707: PPUSH
50708: LD_VAR 0 3
50712: PPUSH
50713: CALL_OW 3
50717: ST_TO_ADDR
50718: GO 50695
50720: POP
50721: POP
// end ;
50722: LD_VAR 0 3
50726: RET
// export function ComExit ( unit ) ; var tmp ; begin
50727: LD_INT 0
50729: PPUSH
50730: PPUSH
// if not IsInUnit ( unit ) then
50731: LD_VAR 0 1
50735: PPUSH
50736: CALL_OW 310
50740: NOT
50741: IFFALSE 50745
// exit ;
50743: GO 50805
// tmp := IsInUnit ( unit ) ;
50745: LD_ADDR_VAR 0 3
50749: PUSH
50750: LD_VAR 0 1
50754: PPUSH
50755: CALL_OW 310
50759: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
50760: LD_VAR 0 3
50764: PPUSH
50765: CALL_OW 247
50769: PUSH
50770: LD_INT 2
50772: EQUAL
50773: IFFALSE 50786
// ComExitVehicle ( unit ) else
50775: LD_VAR 0 1
50779: PPUSH
50780: CALL_OW 121
50784: GO 50795
// ComExitBuilding ( unit ) ;
50786: LD_VAR 0 1
50790: PPUSH
50791: CALL_OW 122
// result := tmp ;
50795: LD_ADDR_VAR 0 2
50799: PUSH
50800: LD_VAR 0 3
50804: ST_TO_ADDR
// end ;
50805: LD_VAR 0 2
50809: RET
// export function ComExitAll ( units ) ; var i ; begin
50810: LD_INT 0
50812: PPUSH
50813: PPUSH
// if not units then
50814: LD_VAR 0 1
50818: NOT
50819: IFFALSE 50823
// exit ;
50821: GO 50849
// for i in units do
50823: LD_ADDR_VAR 0 3
50827: PUSH
50828: LD_VAR 0 1
50832: PUSH
50833: FOR_IN
50834: IFFALSE 50847
// ComExit ( i ) ;
50836: LD_VAR 0 3
50840: PPUSH
50841: CALL 50727 0 1
50845: GO 50833
50847: POP
50848: POP
// end ;
50849: LD_VAR 0 2
50853: RET
// export function ResetHc ; begin
50854: LD_INT 0
50856: PPUSH
// InitHc ;
50857: CALL_OW 19
// hc_importance := 0 ;
50861: LD_ADDR_OWVAR 32
50865: PUSH
50866: LD_INT 0
50868: ST_TO_ADDR
// end ;
50869: LD_VAR 0 1
50873: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
50874: LD_INT 0
50876: PPUSH
50877: PPUSH
50878: PPUSH
// _x := ( x1 + x2 ) div 2 ;
50879: LD_ADDR_VAR 0 6
50883: PUSH
50884: LD_VAR 0 1
50888: PUSH
50889: LD_VAR 0 3
50893: PLUS
50894: PUSH
50895: LD_INT 2
50897: DIV
50898: ST_TO_ADDR
// if _x < 0 then
50899: LD_VAR 0 6
50903: PUSH
50904: LD_INT 0
50906: LESS
50907: IFFALSE 50924
// _x := _x * - 1 ;
50909: LD_ADDR_VAR 0 6
50913: PUSH
50914: LD_VAR 0 6
50918: PUSH
50919: LD_INT 1
50921: NEG
50922: MUL
50923: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
50924: LD_ADDR_VAR 0 7
50928: PUSH
50929: LD_VAR 0 2
50933: PUSH
50934: LD_VAR 0 4
50938: PLUS
50939: PUSH
50940: LD_INT 2
50942: DIV
50943: ST_TO_ADDR
// if _y < 0 then
50944: LD_VAR 0 7
50948: PUSH
50949: LD_INT 0
50951: LESS
50952: IFFALSE 50969
// _y := _y * - 1 ;
50954: LD_ADDR_VAR 0 7
50958: PUSH
50959: LD_VAR 0 7
50963: PUSH
50964: LD_INT 1
50966: NEG
50967: MUL
50968: ST_TO_ADDR
// result := [ _x , _y ] ;
50969: LD_ADDR_VAR 0 5
50973: PUSH
50974: LD_VAR 0 6
50978: PUSH
50979: LD_VAR 0 7
50983: PUSH
50984: EMPTY
50985: LIST
50986: LIST
50987: ST_TO_ADDR
// end ;
50988: LD_VAR 0 5
50992: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
50993: LD_INT 0
50995: PPUSH
50996: PPUSH
50997: PPUSH
50998: PPUSH
// task := GetTaskList ( unit ) ;
50999: LD_ADDR_VAR 0 7
51003: PUSH
51004: LD_VAR 0 1
51008: PPUSH
51009: CALL_OW 437
51013: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
51014: LD_VAR 0 7
51018: NOT
51019: PUSH
51020: LD_VAR 0 1
51024: PPUSH
51025: LD_VAR 0 2
51029: PPUSH
51030: CALL_OW 308
51034: NOT
51035: AND
51036: IFFALSE 51040
// exit ;
51038: GO 51158
// if IsInArea ( unit , area ) then
51040: LD_VAR 0 1
51044: PPUSH
51045: LD_VAR 0 2
51049: PPUSH
51050: CALL_OW 308
51054: IFFALSE 51072
// begin ComMoveToArea ( unit , goAway ) ;
51056: LD_VAR 0 1
51060: PPUSH
51061: LD_VAR 0 3
51065: PPUSH
51066: CALL_OW 113
// exit ;
51070: GO 51158
// end ; if task [ 1 ] [ 1 ] <> M then
51072: LD_VAR 0 7
51076: PUSH
51077: LD_INT 1
51079: ARRAY
51080: PUSH
51081: LD_INT 1
51083: ARRAY
51084: PUSH
51085: LD_STRING M
51087: NONEQUAL
51088: IFFALSE 51092
// exit ;
51090: GO 51158
// x := task [ 1 ] [ 2 ] ;
51092: LD_ADDR_VAR 0 5
51096: PUSH
51097: LD_VAR 0 7
51101: PUSH
51102: LD_INT 1
51104: ARRAY
51105: PUSH
51106: LD_INT 2
51108: ARRAY
51109: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
51110: LD_ADDR_VAR 0 6
51114: PUSH
51115: LD_VAR 0 7
51119: PUSH
51120: LD_INT 1
51122: ARRAY
51123: PUSH
51124: LD_INT 3
51126: ARRAY
51127: ST_TO_ADDR
// if InArea ( x , y , area ) then
51128: LD_VAR 0 5
51132: PPUSH
51133: LD_VAR 0 6
51137: PPUSH
51138: LD_VAR 0 2
51142: PPUSH
51143: CALL_OW 309
51147: IFFALSE 51158
// ComStop ( unit ) ;
51149: LD_VAR 0 1
51153: PPUSH
51154: CALL_OW 141
// end ;
51158: LD_VAR 0 4
51162: RET
// export function Abs ( value ) ; begin
51163: LD_INT 0
51165: PPUSH
// result := value ;
51166: LD_ADDR_VAR 0 2
51170: PUSH
51171: LD_VAR 0 1
51175: ST_TO_ADDR
// if value < 0 then
51176: LD_VAR 0 1
51180: PUSH
51181: LD_INT 0
51183: LESS
51184: IFFALSE 51201
// result := value * - 1 ;
51186: LD_ADDR_VAR 0 2
51190: PUSH
51191: LD_VAR 0 1
51195: PUSH
51196: LD_INT 1
51198: NEG
51199: MUL
51200: ST_TO_ADDR
// end ;
51201: LD_VAR 0 2
51205: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
51206: LD_INT 0
51208: PPUSH
51209: PPUSH
51210: PPUSH
51211: PPUSH
51212: PPUSH
51213: PPUSH
51214: PPUSH
51215: PPUSH
// if not unit or not building then
51216: LD_VAR 0 1
51220: NOT
51221: PUSH
51222: LD_VAR 0 2
51226: NOT
51227: OR
51228: IFFALSE 51232
// exit ;
51230: GO 51458
// x := GetX ( building ) ;
51232: LD_ADDR_VAR 0 4
51236: PUSH
51237: LD_VAR 0 2
51241: PPUSH
51242: CALL_OW 250
51246: ST_TO_ADDR
// y := GetY ( building ) ;
51247: LD_ADDR_VAR 0 6
51251: PUSH
51252: LD_VAR 0 2
51256: PPUSH
51257: CALL_OW 251
51261: ST_TO_ADDR
// d := GetDir ( building ) ;
51262: LD_ADDR_VAR 0 8
51266: PUSH
51267: LD_VAR 0 2
51271: PPUSH
51272: CALL_OW 254
51276: ST_TO_ADDR
// r := 4 ;
51277: LD_ADDR_VAR 0 9
51281: PUSH
51282: LD_INT 4
51284: ST_TO_ADDR
// for i := 1 to 5 do
51285: LD_ADDR_VAR 0 10
51289: PUSH
51290: DOUBLE
51291: LD_INT 1
51293: DEC
51294: ST_TO_ADDR
51295: LD_INT 5
51297: PUSH
51298: FOR_TO
51299: IFFALSE 51456
// begin _x := ShiftX ( x , d , r + i ) ;
51301: LD_ADDR_VAR 0 5
51305: PUSH
51306: LD_VAR 0 4
51310: PPUSH
51311: LD_VAR 0 8
51315: PPUSH
51316: LD_VAR 0 9
51320: PUSH
51321: LD_VAR 0 10
51325: PLUS
51326: PPUSH
51327: CALL_OW 272
51331: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
51332: LD_ADDR_VAR 0 7
51336: PUSH
51337: LD_VAR 0 6
51341: PPUSH
51342: LD_VAR 0 8
51346: PPUSH
51347: LD_VAR 0 9
51351: PUSH
51352: LD_VAR 0 10
51356: PLUS
51357: PPUSH
51358: CALL_OW 273
51362: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
51363: LD_VAR 0 5
51367: PPUSH
51368: LD_VAR 0 7
51372: PPUSH
51373: CALL_OW 488
51377: PUSH
51378: LD_VAR 0 5
51382: PPUSH
51383: LD_VAR 0 7
51387: PPUSH
51388: CALL_OW 428
51392: PPUSH
51393: CALL_OW 247
51397: PUSH
51398: LD_INT 3
51400: PUSH
51401: LD_INT 2
51403: PUSH
51404: EMPTY
51405: LIST
51406: LIST
51407: IN
51408: NOT
51409: AND
51410: IFFALSE 51454
// begin ComMoveXY ( unit , _x , _y ) ;
51412: LD_VAR 0 1
51416: PPUSH
51417: LD_VAR 0 5
51421: PPUSH
51422: LD_VAR 0 7
51426: PPUSH
51427: CALL_OW 111
// result := [ _x , _y ] ;
51431: LD_ADDR_VAR 0 3
51435: PUSH
51436: LD_VAR 0 5
51440: PUSH
51441: LD_VAR 0 7
51445: PUSH
51446: EMPTY
51447: LIST
51448: LIST
51449: ST_TO_ADDR
// exit ;
51450: POP
51451: POP
51452: GO 51458
// end ; end ;
51454: GO 51298
51456: POP
51457: POP
// end ;
51458: LD_VAR 0 3
51462: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
51463: LD_INT 0
51465: PPUSH
51466: PPUSH
51467: PPUSH
// result := 0 ;
51468: LD_ADDR_VAR 0 3
51472: PUSH
51473: LD_INT 0
51475: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
51476: LD_VAR 0 1
51480: PUSH
51481: LD_INT 0
51483: LESS
51484: PUSH
51485: LD_VAR 0 1
51489: PUSH
51490: LD_INT 8
51492: GREATER
51493: OR
51494: PUSH
51495: LD_VAR 0 2
51499: PUSH
51500: LD_INT 0
51502: LESS
51503: OR
51504: PUSH
51505: LD_VAR 0 2
51509: PUSH
51510: LD_INT 8
51512: GREATER
51513: OR
51514: IFFALSE 51518
// exit ;
51516: GO 51593
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
51518: LD_ADDR_VAR 0 4
51522: PUSH
51523: LD_INT 22
51525: PUSH
51526: LD_VAR 0 2
51530: PUSH
51531: EMPTY
51532: LIST
51533: LIST
51534: PPUSH
51535: CALL_OW 69
51539: PUSH
51540: FOR_IN
51541: IFFALSE 51591
// begin un := UnitShoot ( i ) ;
51543: LD_ADDR_VAR 0 5
51547: PUSH
51548: LD_VAR 0 4
51552: PPUSH
51553: CALL_OW 504
51557: ST_TO_ADDR
// if GetSide ( un ) = side1 then
51558: LD_VAR 0 5
51562: PPUSH
51563: CALL_OW 255
51567: PUSH
51568: LD_VAR 0 1
51572: EQUAL
51573: IFFALSE 51589
// begin result := un ;
51575: LD_ADDR_VAR 0 3
51579: PUSH
51580: LD_VAR 0 5
51584: ST_TO_ADDR
// exit ;
51585: POP
51586: POP
51587: GO 51593
// end ; end ;
51589: GO 51540
51591: POP
51592: POP
// end ;
51593: LD_VAR 0 3
51597: RET
// export function GetCargoBay ( units ) ; begin
51598: LD_INT 0
51600: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
51601: LD_ADDR_VAR 0 2
51605: PUSH
51606: LD_VAR 0 1
51610: PPUSH
51611: LD_INT 2
51613: PUSH
51614: LD_INT 34
51616: PUSH
51617: LD_INT 12
51619: PUSH
51620: EMPTY
51621: LIST
51622: LIST
51623: PUSH
51624: LD_INT 34
51626: PUSH
51627: LD_INT 51
51629: PUSH
51630: EMPTY
51631: LIST
51632: LIST
51633: PUSH
51634: LD_INT 34
51636: PUSH
51637: LD_INT 32
51639: PUSH
51640: EMPTY
51641: LIST
51642: LIST
51643: PUSH
51644: LD_INT 34
51646: PUSH
51647: LD_EXP 49
51651: PUSH
51652: EMPTY
51653: LIST
51654: LIST
51655: PUSH
51656: EMPTY
51657: LIST
51658: LIST
51659: LIST
51660: LIST
51661: LIST
51662: PPUSH
51663: CALL_OW 72
51667: ST_TO_ADDR
// end ;
51668: LD_VAR 0 2
51672: RET
// export function Negate ( value ) ; begin
51673: LD_INT 0
51675: PPUSH
// result := not value ;
51676: LD_ADDR_VAR 0 2
51680: PUSH
51681: LD_VAR 0 1
51685: NOT
51686: ST_TO_ADDR
// end ;
51687: LD_VAR 0 2
51691: RET
// export function Inc ( value ) ; begin
51692: LD_INT 0
51694: PPUSH
// result := value + 1 ;
51695: LD_ADDR_VAR 0 2
51699: PUSH
51700: LD_VAR 0 1
51704: PUSH
51705: LD_INT 1
51707: PLUS
51708: ST_TO_ADDR
// end ;
51709: LD_VAR 0 2
51713: RET
// export function Dec ( value ) ; begin
51714: LD_INT 0
51716: PPUSH
// result := value - 1 ;
51717: LD_ADDR_VAR 0 2
51721: PUSH
51722: LD_VAR 0 1
51726: PUSH
51727: LD_INT 1
51729: MINUS
51730: ST_TO_ADDR
// end ;
51731: LD_VAR 0 2
51735: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
51736: LD_INT 0
51738: PPUSH
51739: PPUSH
51740: PPUSH
51741: PPUSH
51742: PPUSH
51743: PPUSH
51744: PPUSH
51745: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
51746: LD_VAR 0 1
51750: PPUSH
51751: LD_VAR 0 2
51755: PPUSH
51756: CALL_OW 488
51760: NOT
51761: PUSH
51762: LD_VAR 0 3
51766: PPUSH
51767: LD_VAR 0 4
51771: PPUSH
51772: CALL_OW 488
51776: NOT
51777: OR
51778: IFFALSE 51791
// begin result := - 1 ;
51780: LD_ADDR_VAR 0 5
51784: PUSH
51785: LD_INT 1
51787: NEG
51788: ST_TO_ADDR
// exit ;
51789: GO 52026
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
51791: LD_ADDR_VAR 0 12
51795: PUSH
51796: LD_VAR 0 1
51800: PPUSH
51801: LD_VAR 0 2
51805: PPUSH
51806: LD_VAR 0 3
51810: PPUSH
51811: LD_VAR 0 4
51815: PPUSH
51816: CALL 50874 0 4
51820: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
51821: LD_ADDR_VAR 0 11
51825: PUSH
51826: LD_VAR 0 1
51830: PPUSH
51831: LD_VAR 0 2
51835: PPUSH
51836: LD_VAR 0 12
51840: PUSH
51841: LD_INT 1
51843: ARRAY
51844: PPUSH
51845: LD_VAR 0 12
51849: PUSH
51850: LD_INT 2
51852: ARRAY
51853: PPUSH
51854: CALL_OW 298
51858: ST_TO_ADDR
// distance := 9999 ;
51859: LD_ADDR_VAR 0 10
51863: PUSH
51864: LD_INT 9999
51866: ST_TO_ADDR
// for i := 0 to 5 do
51867: LD_ADDR_VAR 0 6
51871: PUSH
51872: DOUBLE
51873: LD_INT 0
51875: DEC
51876: ST_TO_ADDR
51877: LD_INT 5
51879: PUSH
51880: FOR_TO
51881: IFFALSE 52024
// begin _x := ShiftX ( x1 , i , centerDist ) ;
51883: LD_ADDR_VAR 0 7
51887: PUSH
51888: LD_VAR 0 1
51892: PPUSH
51893: LD_VAR 0 6
51897: PPUSH
51898: LD_VAR 0 11
51902: PPUSH
51903: CALL_OW 272
51907: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
51908: LD_ADDR_VAR 0 8
51912: PUSH
51913: LD_VAR 0 2
51917: PPUSH
51918: LD_VAR 0 6
51922: PPUSH
51923: LD_VAR 0 11
51927: PPUSH
51928: CALL_OW 273
51932: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51933: LD_VAR 0 7
51937: PPUSH
51938: LD_VAR 0 8
51942: PPUSH
51943: CALL_OW 488
51947: NOT
51948: IFFALSE 51952
// continue ;
51950: GO 51880
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
51952: LD_ADDR_VAR 0 9
51956: PUSH
51957: LD_VAR 0 12
51961: PUSH
51962: LD_INT 1
51964: ARRAY
51965: PPUSH
51966: LD_VAR 0 12
51970: PUSH
51971: LD_INT 2
51973: ARRAY
51974: PPUSH
51975: LD_VAR 0 7
51979: PPUSH
51980: LD_VAR 0 8
51984: PPUSH
51985: CALL_OW 298
51989: ST_TO_ADDR
// if tmp < distance then
51990: LD_VAR 0 9
51994: PUSH
51995: LD_VAR 0 10
51999: LESS
52000: IFFALSE 52022
// begin result := i ;
52002: LD_ADDR_VAR 0 5
52006: PUSH
52007: LD_VAR 0 6
52011: ST_TO_ADDR
// distance := tmp ;
52012: LD_ADDR_VAR 0 10
52016: PUSH
52017: LD_VAR 0 9
52021: ST_TO_ADDR
// end ; end ;
52022: GO 51880
52024: POP
52025: POP
// end ;
52026: LD_VAR 0 5
52030: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
52031: LD_INT 0
52033: PPUSH
52034: PPUSH
// if not driver or not IsInUnit ( driver ) then
52035: LD_VAR 0 1
52039: NOT
52040: PUSH
52041: LD_VAR 0 1
52045: PPUSH
52046: CALL_OW 310
52050: NOT
52051: OR
52052: IFFALSE 52056
// exit ;
52054: GO 52146
// vehicle := IsInUnit ( driver ) ;
52056: LD_ADDR_VAR 0 3
52060: PUSH
52061: LD_VAR 0 1
52065: PPUSH
52066: CALL_OW 310
52070: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
52071: LD_VAR 0 1
52075: PPUSH
52076: LD_STRING \
52078: PUSH
52079: LD_INT 0
52081: PUSH
52082: LD_INT 0
52084: PUSH
52085: LD_INT 0
52087: PUSH
52088: LD_INT 0
52090: PUSH
52091: LD_INT 0
52093: PUSH
52094: LD_INT 0
52096: PUSH
52097: EMPTY
52098: LIST
52099: LIST
52100: LIST
52101: LIST
52102: LIST
52103: LIST
52104: LIST
52105: PUSH
52106: LD_STRING E
52108: PUSH
52109: LD_INT 0
52111: PUSH
52112: LD_INT 0
52114: PUSH
52115: LD_VAR 0 3
52119: PUSH
52120: LD_INT 0
52122: PUSH
52123: LD_INT 0
52125: PUSH
52126: LD_INT 0
52128: PUSH
52129: EMPTY
52130: LIST
52131: LIST
52132: LIST
52133: LIST
52134: LIST
52135: LIST
52136: LIST
52137: PUSH
52138: EMPTY
52139: LIST
52140: LIST
52141: PPUSH
52142: CALL_OW 446
// end ;
52146: LD_VAR 0 2
52150: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
52151: LD_INT 0
52153: PPUSH
52154: PPUSH
// if not driver or not IsInUnit ( driver ) then
52155: LD_VAR 0 1
52159: NOT
52160: PUSH
52161: LD_VAR 0 1
52165: PPUSH
52166: CALL_OW 310
52170: NOT
52171: OR
52172: IFFALSE 52176
// exit ;
52174: GO 52266
// vehicle := IsInUnit ( driver ) ;
52176: LD_ADDR_VAR 0 3
52180: PUSH
52181: LD_VAR 0 1
52185: PPUSH
52186: CALL_OW 310
52190: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
52191: LD_VAR 0 1
52195: PPUSH
52196: LD_STRING \
52198: PUSH
52199: LD_INT 0
52201: PUSH
52202: LD_INT 0
52204: PUSH
52205: LD_INT 0
52207: PUSH
52208: LD_INT 0
52210: PUSH
52211: LD_INT 0
52213: PUSH
52214: LD_INT 0
52216: PUSH
52217: EMPTY
52218: LIST
52219: LIST
52220: LIST
52221: LIST
52222: LIST
52223: LIST
52224: LIST
52225: PUSH
52226: LD_STRING E
52228: PUSH
52229: LD_INT 0
52231: PUSH
52232: LD_INT 0
52234: PUSH
52235: LD_VAR 0 3
52239: PUSH
52240: LD_INT 0
52242: PUSH
52243: LD_INT 0
52245: PUSH
52246: LD_INT 0
52248: PUSH
52249: EMPTY
52250: LIST
52251: LIST
52252: LIST
52253: LIST
52254: LIST
52255: LIST
52256: LIST
52257: PUSH
52258: EMPTY
52259: LIST
52260: LIST
52261: PPUSH
52262: CALL_OW 447
// end ;
52266: LD_VAR 0 2
52270: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
52271: LD_INT 0
52273: PPUSH
52274: PPUSH
52275: PPUSH
// tmp := [ ] ;
52276: LD_ADDR_VAR 0 5
52280: PUSH
52281: EMPTY
52282: ST_TO_ADDR
// for i in units do
52283: LD_ADDR_VAR 0 4
52287: PUSH
52288: LD_VAR 0 1
52292: PUSH
52293: FOR_IN
52294: IFFALSE 52332
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
52296: LD_ADDR_VAR 0 5
52300: PUSH
52301: LD_VAR 0 5
52305: PPUSH
52306: LD_VAR 0 5
52310: PUSH
52311: LD_INT 1
52313: PLUS
52314: PPUSH
52315: LD_VAR 0 4
52319: PPUSH
52320: CALL_OW 256
52324: PPUSH
52325: CALL_OW 2
52329: ST_TO_ADDR
52330: GO 52293
52332: POP
52333: POP
// if not tmp then
52334: LD_VAR 0 5
52338: NOT
52339: IFFALSE 52343
// exit ;
52341: GO 52391
// if asc then
52343: LD_VAR 0 2
52347: IFFALSE 52371
// result := SortListByListAsc ( units , tmp ) else
52349: LD_ADDR_VAR 0 3
52353: PUSH
52354: LD_VAR 0 1
52358: PPUSH
52359: LD_VAR 0 5
52363: PPUSH
52364: CALL_OW 76
52368: ST_TO_ADDR
52369: GO 52391
// result := SortListByListDesc ( units , tmp ) ;
52371: LD_ADDR_VAR 0 3
52375: PUSH
52376: LD_VAR 0 1
52380: PPUSH
52381: LD_VAR 0 5
52385: PPUSH
52386: CALL_OW 77
52390: ST_TO_ADDR
// end ;
52391: LD_VAR 0 3
52395: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
52396: LD_INT 0
52398: PPUSH
52399: PPUSH
// task := GetTaskList ( mech ) ;
52400: LD_ADDR_VAR 0 4
52404: PUSH
52405: LD_VAR 0 1
52409: PPUSH
52410: CALL_OW 437
52414: ST_TO_ADDR
// if not task then
52415: LD_VAR 0 4
52419: NOT
52420: IFFALSE 52424
// exit ;
52422: GO 52466
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
52424: LD_ADDR_VAR 0 3
52428: PUSH
52429: LD_VAR 0 4
52433: PUSH
52434: LD_INT 1
52436: ARRAY
52437: PUSH
52438: LD_INT 1
52440: ARRAY
52441: PUSH
52442: LD_STRING r
52444: EQUAL
52445: PUSH
52446: LD_VAR 0 4
52450: PUSH
52451: LD_INT 1
52453: ARRAY
52454: PUSH
52455: LD_INT 4
52457: ARRAY
52458: PUSH
52459: LD_VAR 0 2
52463: EQUAL
52464: AND
52465: ST_TO_ADDR
// end ;
52466: LD_VAR 0 3
52470: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
52471: LD_INT 0
52473: PPUSH
// SetDir ( unit , d ) ;
52474: LD_VAR 0 1
52478: PPUSH
52479: LD_VAR 0 4
52483: PPUSH
52484: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
52488: LD_VAR 0 1
52492: PPUSH
52493: LD_VAR 0 2
52497: PPUSH
52498: LD_VAR 0 3
52502: PPUSH
52503: LD_VAR 0 5
52507: PPUSH
52508: CALL_OW 48
// end ;
52512: LD_VAR 0 6
52516: RET
// export function ToNaturalNumber ( number ) ; begin
52517: LD_INT 0
52519: PPUSH
// result := number div 1 ;
52520: LD_ADDR_VAR 0 2
52524: PUSH
52525: LD_VAR 0 1
52529: PUSH
52530: LD_INT 1
52532: DIV
52533: ST_TO_ADDR
// if number < 0 then
52534: LD_VAR 0 1
52538: PUSH
52539: LD_INT 0
52541: LESS
52542: IFFALSE 52552
// result := 0 ;
52544: LD_ADDR_VAR 0 2
52548: PUSH
52549: LD_INT 0
52551: ST_TO_ADDR
// end ;
52552: LD_VAR 0 2
52556: RET
// export function SortByClass ( units , class ) ; var un ; begin
52557: LD_INT 0
52559: PPUSH
52560: PPUSH
// if not units or not class then
52561: LD_VAR 0 1
52565: NOT
52566: PUSH
52567: LD_VAR 0 2
52571: NOT
52572: OR
52573: IFFALSE 52577
// exit ;
52575: GO 52672
// result := [ ] ;
52577: LD_ADDR_VAR 0 3
52581: PUSH
52582: EMPTY
52583: ST_TO_ADDR
// for un in units do
52584: LD_ADDR_VAR 0 4
52588: PUSH
52589: LD_VAR 0 1
52593: PUSH
52594: FOR_IN
52595: IFFALSE 52670
// if GetClass ( un ) = class then
52597: LD_VAR 0 4
52601: PPUSH
52602: CALL_OW 257
52606: PUSH
52607: LD_VAR 0 2
52611: EQUAL
52612: IFFALSE 52639
// result := Insert ( result , 1 , un ) else
52614: LD_ADDR_VAR 0 3
52618: PUSH
52619: LD_VAR 0 3
52623: PPUSH
52624: LD_INT 1
52626: PPUSH
52627: LD_VAR 0 4
52631: PPUSH
52632: CALL_OW 2
52636: ST_TO_ADDR
52637: GO 52668
// result := Replace ( result , result + 1 , un ) ;
52639: LD_ADDR_VAR 0 3
52643: PUSH
52644: LD_VAR 0 3
52648: PPUSH
52649: LD_VAR 0 3
52653: PUSH
52654: LD_INT 1
52656: PLUS
52657: PPUSH
52658: LD_VAR 0 4
52662: PPUSH
52663: CALL_OW 1
52667: ST_TO_ADDR
52668: GO 52594
52670: POP
52671: POP
// end ;
52672: LD_VAR 0 3
52676: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
52677: LD_INT 0
52679: PPUSH
52680: PPUSH
52681: PPUSH
52682: PPUSH
52683: PPUSH
52684: PPUSH
52685: PPUSH
// result := [ ] ;
52686: LD_ADDR_VAR 0 4
52690: PUSH
52691: EMPTY
52692: ST_TO_ADDR
// if x - r < 0 then
52693: LD_VAR 0 1
52697: PUSH
52698: LD_VAR 0 3
52702: MINUS
52703: PUSH
52704: LD_INT 0
52706: LESS
52707: IFFALSE 52719
// min_x := 0 else
52709: LD_ADDR_VAR 0 8
52713: PUSH
52714: LD_INT 0
52716: ST_TO_ADDR
52717: GO 52735
// min_x := x - r ;
52719: LD_ADDR_VAR 0 8
52723: PUSH
52724: LD_VAR 0 1
52728: PUSH
52729: LD_VAR 0 3
52733: MINUS
52734: ST_TO_ADDR
// if y - r < 0 then
52735: LD_VAR 0 2
52739: PUSH
52740: LD_VAR 0 3
52744: MINUS
52745: PUSH
52746: LD_INT 0
52748: LESS
52749: IFFALSE 52761
// min_y := 0 else
52751: LD_ADDR_VAR 0 7
52755: PUSH
52756: LD_INT 0
52758: ST_TO_ADDR
52759: GO 52777
// min_y := y - r ;
52761: LD_ADDR_VAR 0 7
52765: PUSH
52766: LD_VAR 0 2
52770: PUSH
52771: LD_VAR 0 3
52775: MINUS
52776: ST_TO_ADDR
// max_x := x + r ;
52777: LD_ADDR_VAR 0 9
52781: PUSH
52782: LD_VAR 0 1
52786: PUSH
52787: LD_VAR 0 3
52791: PLUS
52792: ST_TO_ADDR
// max_y := y + r ;
52793: LD_ADDR_VAR 0 10
52797: PUSH
52798: LD_VAR 0 2
52802: PUSH
52803: LD_VAR 0 3
52807: PLUS
52808: ST_TO_ADDR
// for _x = min_x to max_x do
52809: LD_ADDR_VAR 0 5
52813: PUSH
52814: DOUBLE
52815: LD_VAR 0 8
52819: DEC
52820: ST_TO_ADDR
52821: LD_VAR 0 9
52825: PUSH
52826: FOR_TO
52827: IFFALSE 52928
// for _y = min_y to max_y do
52829: LD_ADDR_VAR 0 6
52833: PUSH
52834: DOUBLE
52835: LD_VAR 0 7
52839: DEC
52840: ST_TO_ADDR
52841: LD_VAR 0 10
52845: PUSH
52846: FOR_TO
52847: IFFALSE 52924
// begin if not ValidHex ( _x , _y ) then
52849: LD_VAR 0 5
52853: PPUSH
52854: LD_VAR 0 6
52858: PPUSH
52859: CALL_OW 488
52863: NOT
52864: IFFALSE 52868
// continue ;
52866: GO 52846
// if GetResourceTypeXY ( _x , _y ) then
52868: LD_VAR 0 5
52872: PPUSH
52873: LD_VAR 0 6
52877: PPUSH
52878: CALL_OW 283
52882: IFFALSE 52922
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
52884: LD_ADDR_VAR 0 4
52888: PUSH
52889: LD_VAR 0 4
52893: PPUSH
52894: LD_VAR 0 4
52898: PUSH
52899: LD_INT 1
52901: PLUS
52902: PPUSH
52903: LD_VAR 0 5
52907: PUSH
52908: LD_VAR 0 6
52912: PUSH
52913: EMPTY
52914: LIST
52915: LIST
52916: PPUSH
52917: CALL_OW 1
52921: ST_TO_ADDR
// end ;
52922: GO 52846
52924: POP
52925: POP
52926: GO 52826
52928: POP
52929: POP
// end ;
52930: LD_VAR 0 4
52934: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
52935: LD_INT 0
52937: PPUSH
52938: PPUSH
52939: PPUSH
52940: PPUSH
52941: PPUSH
52942: PPUSH
52943: PPUSH
52944: PPUSH
// if not units then
52945: LD_VAR 0 1
52949: NOT
52950: IFFALSE 52954
// exit ;
52952: GO 53379
// result := UnitFilter ( units , [ f_ok ] ) ;
52954: LD_ADDR_VAR 0 3
52958: PUSH
52959: LD_VAR 0 1
52963: PPUSH
52964: LD_INT 50
52966: PUSH
52967: EMPTY
52968: LIST
52969: PPUSH
52970: CALL_OW 72
52974: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
52975: LD_ADDR_VAR 0 8
52979: PUSH
52980: LD_VAR 0 1
52984: PUSH
52985: LD_INT 1
52987: ARRAY
52988: PPUSH
52989: CALL_OW 255
52993: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
52994: LD_ADDR_VAR 0 10
52998: PUSH
52999: LD_INT 29
53001: PUSH
53002: LD_EXP 52
53006: PUSH
53007: EMPTY
53008: LIST
53009: LIST
53010: ST_TO_ADDR
// if not result then
53011: LD_VAR 0 3
53015: NOT
53016: IFFALSE 53020
// exit ;
53018: GO 53379
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
53020: LD_ADDR_VAR 0 5
53024: PUSH
53025: LD_INT 81
53027: PUSH
53028: LD_VAR 0 8
53032: PUSH
53033: EMPTY
53034: LIST
53035: LIST
53036: PPUSH
53037: CALL_OW 69
53041: ST_TO_ADDR
// for i in result do
53042: LD_ADDR_VAR 0 4
53046: PUSH
53047: LD_VAR 0 3
53051: PUSH
53052: FOR_IN
53053: IFFALSE 53377
// begin tag := GetTag ( i ) + 1 ;
53055: LD_ADDR_VAR 0 9
53059: PUSH
53060: LD_VAR 0 4
53064: PPUSH
53065: CALL_OW 110
53069: PUSH
53070: LD_INT 1
53072: PLUS
53073: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
53074: LD_ADDR_VAR 0 7
53078: PUSH
53079: LD_VAR 0 4
53083: PPUSH
53084: CALL_OW 250
53088: PPUSH
53089: LD_VAR 0 4
53093: PPUSH
53094: CALL_OW 251
53098: PPUSH
53099: LD_INT 6
53101: PPUSH
53102: CALL 52677 0 3
53106: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
53107: LD_VAR 0 7
53111: PUSH
53112: LD_VAR 0 4
53116: PPUSH
53117: CALL_OW 264
53121: PUSH
53122: LD_VAR 0 10
53126: IN
53127: NOT
53128: AND
53129: IFFALSE 53168
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
53131: LD_VAR 0 4
53135: PPUSH
53136: LD_VAR 0 7
53140: PUSH
53141: LD_INT 1
53143: ARRAY
53144: PUSH
53145: LD_INT 1
53147: ARRAY
53148: PPUSH
53149: LD_VAR 0 7
53153: PUSH
53154: LD_INT 1
53156: ARRAY
53157: PUSH
53158: LD_INT 2
53160: ARRAY
53161: PPUSH
53162: CALL_OW 116
53166: GO 53375
// if path > tag then
53168: LD_VAR 0 2
53172: PUSH
53173: LD_VAR 0 9
53177: GREATER
53178: IFFALSE 53345
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
53180: LD_ADDR_VAR 0 6
53184: PUSH
53185: LD_VAR 0 5
53189: PPUSH
53190: LD_INT 91
53192: PUSH
53193: LD_VAR 0 4
53197: PUSH
53198: LD_INT 12
53200: PUSH
53201: EMPTY
53202: LIST
53203: LIST
53204: LIST
53205: PPUSH
53206: CALL_OW 72
53210: ST_TO_ADDR
// if nearEnemy then
53211: LD_VAR 0 6
53215: IFFALSE 53243
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
53217: LD_VAR 0 4
53221: PPUSH
53222: LD_VAR 0 6
53226: PPUSH
53227: LD_VAR 0 4
53231: PPUSH
53232: CALL_OW 74
53236: PPUSH
53237: CALL_OW 115
53241: GO 53343
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
53243: LD_VAR 0 4
53247: PPUSH
53248: LD_VAR 0 2
53252: PUSH
53253: LD_VAR 0 9
53257: ARRAY
53258: PUSH
53259: LD_INT 1
53261: ARRAY
53262: PPUSH
53263: LD_VAR 0 2
53267: PUSH
53268: LD_VAR 0 9
53272: ARRAY
53273: PUSH
53274: LD_INT 2
53276: ARRAY
53277: PPUSH
53278: CALL_OW 297
53282: PUSH
53283: LD_INT 6
53285: GREATER
53286: IFFALSE 53329
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
53288: LD_VAR 0 4
53292: PPUSH
53293: LD_VAR 0 2
53297: PUSH
53298: LD_VAR 0 9
53302: ARRAY
53303: PUSH
53304: LD_INT 1
53306: ARRAY
53307: PPUSH
53308: LD_VAR 0 2
53312: PUSH
53313: LD_VAR 0 9
53317: ARRAY
53318: PUSH
53319: LD_INT 2
53321: ARRAY
53322: PPUSH
53323: CALL_OW 114
53327: GO 53343
// SetTag ( i , tag ) ;
53329: LD_VAR 0 4
53333: PPUSH
53334: LD_VAR 0 9
53338: PPUSH
53339: CALL_OW 109
// end else
53343: GO 53375
// if enemy then
53345: LD_VAR 0 5
53349: IFFALSE 53375
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
53351: LD_VAR 0 4
53355: PPUSH
53356: LD_VAR 0 5
53360: PPUSH
53361: LD_VAR 0 4
53365: PPUSH
53366: CALL_OW 74
53370: PPUSH
53371: CALL_OW 115
// end ;
53375: GO 53052
53377: POP
53378: POP
// end ;
53379: LD_VAR 0 3
53383: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
53384: LD_INT 0
53386: PPUSH
53387: PPUSH
53388: PPUSH
// if not unit or IsInUnit ( unit ) then
53389: LD_VAR 0 1
53393: NOT
53394: PUSH
53395: LD_VAR 0 1
53399: PPUSH
53400: CALL_OW 310
53404: OR
53405: IFFALSE 53409
// exit ;
53407: GO 53500
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
53409: LD_ADDR_VAR 0 4
53413: PUSH
53414: LD_VAR 0 1
53418: PPUSH
53419: CALL_OW 250
53423: PPUSH
53424: LD_VAR 0 2
53428: PPUSH
53429: LD_INT 1
53431: PPUSH
53432: CALL_OW 272
53436: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
53437: LD_ADDR_VAR 0 5
53441: PUSH
53442: LD_VAR 0 1
53446: PPUSH
53447: CALL_OW 251
53451: PPUSH
53452: LD_VAR 0 2
53456: PPUSH
53457: LD_INT 1
53459: PPUSH
53460: CALL_OW 273
53464: ST_TO_ADDR
// if ValidHex ( x , y ) then
53465: LD_VAR 0 4
53469: PPUSH
53470: LD_VAR 0 5
53474: PPUSH
53475: CALL_OW 488
53479: IFFALSE 53500
// ComTurnXY ( unit , x , y ) ;
53481: LD_VAR 0 1
53485: PPUSH
53486: LD_VAR 0 4
53490: PPUSH
53491: LD_VAR 0 5
53495: PPUSH
53496: CALL_OW 118
// end ;
53500: LD_VAR 0 3
53504: RET
// export function SeeUnits ( side , units ) ; var i ; begin
53505: LD_INT 0
53507: PPUSH
53508: PPUSH
// result := false ;
53509: LD_ADDR_VAR 0 3
53513: PUSH
53514: LD_INT 0
53516: ST_TO_ADDR
// if not units then
53517: LD_VAR 0 2
53521: NOT
53522: IFFALSE 53526
// exit ;
53524: GO 53571
// for i in units do
53526: LD_ADDR_VAR 0 4
53530: PUSH
53531: LD_VAR 0 2
53535: PUSH
53536: FOR_IN
53537: IFFALSE 53569
// if See ( side , i ) then
53539: LD_VAR 0 1
53543: PPUSH
53544: LD_VAR 0 4
53548: PPUSH
53549: CALL_OW 292
53553: IFFALSE 53567
// begin result := true ;
53555: LD_ADDR_VAR 0 3
53559: PUSH
53560: LD_INT 1
53562: ST_TO_ADDR
// exit ;
53563: POP
53564: POP
53565: GO 53571
// end ;
53567: GO 53536
53569: POP
53570: POP
// end ;
53571: LD_VAR 0 3
53575: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
53576: LD_INT 0
53578: PPUSH
53579: PPUSH
53580: PPUSH
53581: PPUSH
// if not unit or not points then
53582: LD_VAR 0 1
53586: NOT
53587: PUSH
53588: LD_VAR 0 2
53592: NOT
53593: OR
53594: IFFALSE 53598
// exit ;
53596: GO 53688
// dist := 99999 ;
53598: LD_ADDR_VAR 0 5
53602: PUSH
53603: LD_INT 99999
53605: ST_TO_ADDR
// for i in points do
53606: LD_ADDR_VAR 0 4
53610: PUSH
53611: LD_VAR 0 2
53615: PUSH
53616: FOR_IN
53617: IFFALSE 53686
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
53619: LD_ADDR_VAR 0 6
53623: PUSH
53624: LD_VAR 0 1
53628: PPUSH
53629: LD_VAR 0 4
53633: PUSH
53634: LD_INT 1
53636: ARRAY
53637: PPUSH
53638: LD_VAR 0 4
53642: PUSH
53643: LD_INT 2
53645: ARRAY
53646: PPUSH
53647: CALL_OW 297
53651: ST_TO_ADDR
// if tmpDist < dist then
53652: LD_VAR 0 6
53656: PUSH
53657: LD_VAR 0 5
53661: LESS
53662: IFFALSE 53684
// begin result := i ;
53664: LD_ADDR_VAR 0 3
53668: PUSH
53669: LD_VAR 0 4
53673: ST_TO_ADDR
// dist := tmpDist ;
53674: LD_ADDR_VAR 0 5
53678: PUSH
53679: LD_VAR 0 6
53683: ST_TO_ADDR
// end ; end ;
53684: GO 53616
53686: POP
53687: POP
// end ; end_of_file
53688: LD_VAR 0 3
53692: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
53693: LD_INT 0
53695: PPUSH
// ar_miner := 81 ;
53696: LD_ADDR_EXP 55
53700: PUSH
53701: LD_INT 81
53703: ST_TO_ADDR
// ar_crane := 88 ;
53704: LD_ADDR_EXP 54
53708: PUSH
53709: LD_INT 88
53711: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
53712: LD_ADDR_EXP 49
53716: PUSH
53717: LD_INT 89
53719: ST_TO_ADDR
// us_hack := 99 ;
53720: LD_ADDR_EXP 50
53724: PUSH
53725: LD_INT 99
53727: ST_TO_ADDR
// us_artillery := 97 ;
53728: LD_ADDR_EXP 51
53732: PUSH
53733: LD_INT 97
53735: ST_TO_ADDR
// ar_bio_bomb := 91 ;
53736: LD_ADDR_EXP 52
53740: PUSH
53741: LD_INT 91
53743: ST_TO_ADDR
// ar_mortar := 92 ;
53744: LD_ADDR_EXP 53
53748: PUSH
53749: LD_INT 92
53751: ST_TO_ADDR
// ru_radar := 98 ;
53752: LD_ADDR_EXP 48
53756: PUSH
53757: LD_INT 98
53759: ST_TO_ADDR
// tech_Artillery := 80 ;
53760: LD_ADDR_EXP 56
53764: PUSH
53765: LD_INT 80
53767: ST_TO_ADDR
// tech_RadMat := 81 ;
53768: LD_ADDR_EXP 57
53772: PUSH
53773: LD_INT 81
53775: ST_TO_ADDR
// tech_BasicTools := 82 ;
53776: LD_ADDR_EXP 58
53780: PUSH
53781: LD_INT 82
53783: ST_TO_ADDR
// tech_Cargo := 83 ;
53784: LD_ADDR_EXP 59
53788: PUSH
53789: LD_INT 83
53791: ST_TO_ADDR
// tech_Track := 84 ;
53792: LD_ADDR_EXP 60
53796: PUSH
53797: LD_INT 84
53799: ST_TO_ADDR
// tech_Crane := 85 ;
53800: LD_ADDR_EXP 61
53804: PUSH
53805: LD_INT 85
53807: ST_TO_ADDR
// tech_Bulldozer := 86 ;
53808: LD_ADDR_EXP 62
53812: PUSH
53813: LD_INT 86
53815: ST_TO_ADDR
// tech_Hovercraft := 87 ;
53816: LD_ADDR_EXP 63
53820: PUSH
53821: LD_INT 87
53823: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
53824: LD_ADDR_EXP 64
53828: PUSH
53829: LD_INT 88
53831: ST_TO_ADDR
// class_mastodont := 31 ;
53832: LD_ADDR_EXP 65
53836: PUSH
53837: LD_INT 31
53839: ST_TO_ADDR
// class_horse := 21 ;
53840: LD_ADDR_EXP 66
53844: PUSH
53845: LD_INT 21
53847: ST_TO_ADDR
// end ;
53848: LD_VAR 0 1
53852: RET
// every 1 do
53853: GO 53855
53855: DISABLE
// InitGlobalVariables ; end_of_file
53856: CALL 53693 0 0
53860: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
53861: LD_INT 0
53863: PPUSH
53864: PPUSH
// skirmish := false ;
53865: LD_ADDR_EXP 67
53869: PUSH
53870: LD_INT 0
53872: ST_TO_ADDR
// debug_mc := false ;
53873: LD_ADDR_EXP 68
53877: PUSH
53878: LD_INT 0
53880: ST_TO_ADDR
// mc_bases := [ ] ;
53881: LD_ADDR_EXP 69
53885: PUSH
53886: EMPTY
53887: ST_TO_ADDR
// mc_sides := [ ] ;
53888: LD_ADDR_EXP 95
53892: PUSH
53893: EMPTY
53894: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
53895: LD_ADDR_EXP 70
53899: PUSH
53900: EMPTY
53901: ST_TO_ADDR
// mc_building_repairs := [ ] ;
53902: LD_ADDR_EXP 71
53906: PUSH
53907: EMPTY
53908: ST_TO_ADDR
// mc_need_heal := [ ] ;
53909: LD_ADDR_EXP 72
53913: PUSH
53914: EMPTY
53915: ST_TO_ADDR
// mc_healers := [ ] ;
53916: LD_ADDR_EXP 73
53920: PUSH
53921: EMPTY
53922: ST_TO_ADDR
// mc_build_list := [ ] ;
53923: LD_ADDR_EXP 74
53927: PUSH
53928: EMPTY
53929: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
53930: LD_ADDR_EXP 101
53934: PUSH
53935: EMPTY
53936: ST_TO_ADDR
// mc_builders := [ ] ;
53937: LD_ADDR_EXP 75
53941: PUSH
53942: EMPTY
53943: ST_TO_ADDR
// mc_construct_list := [ ] ;
53944: LD_ADDR_EXP 76
53948: PUSH
53949: EMPTY
53950: ST_TO_ADDR
// mc_turret_list := [ ] ;
53951: LD_ADDR_EXP 77
53955: PUSH
53956: EMPTY
53957: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
53958: LD_ADDR_EXP 78
53962: PUSH
53963: EMPTY
53964: ST_TO_ADDR
// mc_miners := [ ] ;
53965: LD_ADDR_EXP 83
53969: PUSH
53970: EMPTY
53971: ST_TO_ADDR
// mc_mines := [ ] ;
53972: LD_ADDR_EXP 82
53976: PUSH
53977: EMPTY
53978: ST_TO_ADDR
// mc_minefields := [ ] ;
53979: LD_ADDR_EXP 84
53983: PUSH
53984: EMPTY
53985: ST_TO_ADDR
// mc_crates := [ ] ;
53986: LD_ADDR_EXP 85
53990: PUSH
53991: EMPTY
53992: ST_TO_ADDR
// mc_crates_collector := [ ] ;
53993: LD_ADDR_EXP 86
53997: PUSH
53998: EMPTY
53999: ST_TO_ADDR
// mc_crates_area := [ ] ;
54000: LD_ADDR_EXP 87
54004: PUSH
54005: EMPTY
54006: ST_TO_ADDR
// mc_vehicles := [ ] ;
54007: LD_ADDR_EXP 88
54011: PUSH
54012: EMPTY
54013: ST_TO_ADDR
// mc_attack := [ ] ;
54014: LD_ADDR_EXP 89
54018: PUSH
54019: EMPTY
54020: ST_TO_ADDR
// mc_produce := [ ] ;
54021: LD_ADDR_EXP 90
54025: PUSH
54026: EMPTY
54027: ST_TO_ADDR
// mc_defender := [ ] ;
54028: LD_ADDR_EXP 91
54032: PUSH
54033: EMPTY
54034: ST_TO_ADDR
// mc_parking := [ ] ;
54035: LD_ADDR_EXP 93
54039: PUSH
54040: EMPTY
54041: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
54042: LD_ADDR_EXP 79
54046: PUSH
54047: EMPTY
54048: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
54049: LD_ADDR_EXP 81
54053: PUSH
54054: EMPTY
54055: ST_TO_ADDR
// mc_scan := [ ] ;
54056: LD_ADDR_EXP 92
54060: PUSH
54061: EMPTY
54062: ST_TO_ADDR
// mc_scan_area := [ ] ;
54063: LD_ADDR_EXP 94
54067: PUSH
54068: EMPTY
54069: ST_TO_ADDR
// mc_tech := [ ] ;
54070: LD_ADDR_EXP 96
54074: PUSH
54075: EMPTY
54076: ST_TO_ADDR
// mc_class := [ ] ;
54077: LD_ADDR_EXP 110
54081: PUSH
54082: EMPTY
54083: ST_TO_ADDR
// mc_class_case_use := [ ] ;
54084: LD_ADDR_EXP 111
54088: PUSH
54089: EMPTY
54090: ST_TO_ADDR
// mc_is_defending := [ ] ;
54091: LD_ADDR_EXP 112
54095: PUSH
54096: EMPTY
54097: ST_TO_ADDR
// end ;
54098: LD_VAR 0 1
54102: RET
// export function MC_Kill ( base ) ; begin
54103: LD_INT 0
54105: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
54106: LD_ADDR_EXP 69
54110: PUSH
54111: LD_EXP 69
54115: PPUSH
54116: LD_VAR 0 1
54120: PPUSH
54121: EMPTY
54122: PPUSH
54123: CALL_OW 1
54127: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
54128: LD_ADDR_EXP 70
54132: PUSH
54133: LD_EXP 70
54137: PPUSH
54138: LD_VAR 0 1
54142: PPUSH
54143: EMPTY
54144: PPUSH
54145: CALL_OW 1
54149: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
54150: LD_ADDR_EXP 71
54154: PUSH
54155: LD_EXP 71
54159: PPUSH
54160: LD_VAR 0 1
54164: PPUSH
54165: EMPTY
54166: PPUSH
54167: CALL_OW 1
54171: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
54172: LD_ADDR_EXP 72
54176: PUSH
54177: LD_EXP 72
54181: PPUSH
54182: LD_VAR 0 1
54186: PPUSH
54187: EMPTY
54188: PPUSH
54189: CALL_OW 1
54193: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
54194: LD_ADDR_EXP 73
54198: PUSH
54199: LD_EXP 73
54203: PPUSH
54204: LD_VAR 0 1
54208: PPUSH
54209: EMPTY
54210: PPUSH
54211: CALL_OW 1
54215: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
54216: LD_ADDR_EXP 74
54220: PUSH
54221: LD_EXP 74
54225: PPUSH
54226: LD_VAR 0 1
54230: PPUSH
54231: EMPTY
54232: PPUSH
54233: CALL_OW 1
54237: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
54238: LD_ADDR_EXP 75
54242: PUSH
54243: LD_EXP 75
54247: PPUSH
54248: LD_VAR 0 1
54252: PPUSH
54253: EMPTY
54254: PPUSH
54255: CALL_OW 1
54259: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
54260: LD_ADDR_EXP 76
54264: PUSH
54265: LD_EXP 76
54269: PPUSH
54270: LD_VAR 0 1
54274: PPUSH
54275: EMPTY
54276: PPUSH
54277: CALL_OW 1
54281: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
54282: LD_ADDR_EXP 77
54286: PUSH
54287: LD_EXP 77
54291: PPUSH
54292: LD_VAR 0 1
54296: PPUSH
54297: EMPTY
54298: PPUSH
54299: CALL_OW 1
54303: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
54304: LD_ADDR_EXP 78
54308: PUSH
54309: LD_EXP 78
54313: PPUSH
54314: LD_VAR 0 1
54318: PPUSH
54319: EMPTY
54320: PPUSH
54321: CALL_OW 1
54325: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
54326: LD_ADDR_EXP 79
54330: PUSH
54331: LD_EXP 79
54335: PPUSH
54336: LD_VAR 0 1
54340: PPUSH
54341: EMPTY
54342: PPUSH
54343: CALL_OW 1
54347: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
54348: LD_ADDR_EXP 80
54352: PUSH
54353: LD_EXP 80
54357: PPUSH
54358: LD_VAR 0 1
54362: PPUSH
54363: LD_INT 0
54365: PPUSH
54366: CALL_OW 1
54370: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
54371: LD_ADDR_EXP 81
54375: PUSH
54376: LD_EXP 81
54380: PPUSH
54381: LD_VAR 0 1
54385: PPUSH
54386: EMPTY
54387: PPUSH
54388: CALL_OW 1
54392: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
54393: LD_ADDR_EXP 82
54397: PUSH
54398: LD_EXP 82
54402: PPUSH
54403: LD_VAR 0 1
54407: PPUSH
54408: EMPTY
54409: PPUSH
54410: CALL_OW 1
54414: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
54415: LD_ADDR_EXP 83
54419: PUSH
54420: LD_EXP 83
54424: PPUSH
54425: LD_VAR 0 1
54429: PPUSH
54430: EMPTY
54431: PPUSH
54432: CALL_OW 1
54436: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
54437: LD_ADDR_EXP 84
54441: PUSH
54442: LD_EXP 84
54446: PPUSH
54447: LD_VAR 0 1
54451: PPUSH
54452: EMPTY
54453: PPUSH
54454: CALL_OW 1
54458: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
54459: LD_ADDR_EXP 85
54463: PUSH
54464: LD_EXP 85
54468: PPUSH
54469: LD_VAR 0 1
54473: PPUSH
54474: EMPTY
54475: PPUSH
54476: CALL_OW 1
54480: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
54481: LD_ADDR_EXP 86
54485: PUSH
54486: LD_EXP 86
54490: PPUSH
54491: LD_VAR 0 1
54495: PPUSH
54496: EMPTY
54497: PPUSH
54498: CALL_OW 1
54502: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
54503: LD_ADDR_EXP 87
54507: PUSH
54508: LD_EXP 87
54512: PPUSH
54513: LD_VAR 0 1
54517: PPUSH
54518: EMPTY
54519: PPUSH
54520: CALL_OW 1
54524: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54525: LD_ADDR_EXP 88
54529: PUSH
54530: LD_EXP 88
54534: PPUSH
54535: LD_VAR 0 1
54539: PPUSH
54540: EMPTY
54541: PPUSH
54542: CALL_OW 1
54546: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54547: LD_ADDR_EXP 89
54551: PUSH
54552: LD_EXP 89
54556: PPUSH
54557: LD_VAR 0 1
54561: PPUSH
54562: EMPTY
54563: PPUSH
54564: CALL_OW 1
54568: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54569: LD_ADDR_EXP 90
54573: PUSH
54574: LD_EXP 90
54578: PPUSH
54579: LD_VAR 0 1
54583: PPUSH
54584: EMPTY
54585: PPUSH
54586: CALL_OW 1
54590: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54591: LD_ADDR_EXP 91
54595: PUSH
54596: LD_EXP 91
54600: PPUSH
54601: LD_VAR 0 1
54605: PPUSH
54606: EMPTY
54607: PPUSH
54608: CALL_OW 1
54612: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54613: LD_ADDR_EXP 92
54617: PUSH
54618: LD_EXP 92
54622: PPUSH
54623: LD_VAR 0 1
54627: PPUSH
54628: EMPTY
54629: PPUSH
54630: CALL_OW 1
54634: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54635: LD_ADDR_EXP 93
54639: PUSH
54640: LD_EXP 93
54644: PPUSH
54645: LD_VAR 0 1
54649: PPUSH
54650: EMPTY
54651: PPUSH
54652: CALL_OW 1
54656: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54657: LD_ADDR_EXP 94
54661: PUSH
54662: LD_EXP 94
54666: PPUSH
54667: LD_VAR 0 1
54671: PPUSH
54672: EMPTY
54673: PPUSH
54674: CALL_OW 1
54678: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54679: LD_ADDR_EXP 96
54683: PUSH
54684: LD_EXP 96
54688: PPUSH
54689: LD_VAR 0 1
54693: PPUSH
54694: EMPTY
54695: PPUSH
54696: CALL_OW 1
54700: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54701: LD_ADDR_EXP 98
54705: PUSH
54706: LD_EXP 98
54710: PPUSH
54711: LD_VAR 0 1
54715: PPUSH
54716: EMPTY
54717: PPUSH
54718: CALL_OW 1
54722: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54723: LD_ADDR_EXP 99
54727: PUSH
54728: LD_EXP 99
54732: PPUSH
54733: LD_VAR 0 1
54737: PPUSH
54738: EMPTY
54739: PPUSH
54740: CALL_OW 1
54744: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54745: LD_ADDR_EXP 100
54749: PUSH
54750: LD_EXP 100
54754: PPUSH
54755: LD_VAR 0 1
54759: PPUSH
54760: EMPTY
54761: PPUSH
54762: CALL_OW 1
54766: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54767: LD_ADDR_EXP 101
54771: PUSH
54772: LD_EXP 101
54776: PPUSH
54777: LD_VAR 0 1
54781: PPUSH
54782: EMPTY
54783: PPUSH
54784: CALL_OW 1
54788: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54789: LD_ADDR_EXP 102
54793: PUSH
54794: LD_EXP 102
54798: PPUSH
54799: LD_VAR 0 1
54803: PPUSH
54804: EMPTY
54805: PPUSH
54806: CALL_OW 1
54810: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54811: LD_ADDR_EXP 103
54815: PUSH
54816: LD_EXP 103
54820: PPUSH
54821: LD_VAR 0 1
54825: PPUSH
54826: EMPTY
54827: PPUSH
54828: CALL_OW 1
54832: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54833: LD_ADDR_EXP 104
54837: PUSH
54838: LD_EXP 104
54842: PPUSH
54843: LD_VAR 0 1
54847: PPUSH
54848: EMPTY
54849: PPUSH
54850: CALL_OW 1
54854: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54855: LD_ADDR_EXP 105
54859: PUSH
54860: LD_EXP 105
54864: PPUSH
54865: LD_VAR 0 1
54869: PPUSH
54870: EMPTY
54871: PPUSH
54872: CALL_OW 1
54876: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54877: LD_ADDR_EXP 106
54881: PUSH
54882: LD_EXP 106
54886: PPUSH
54887: LD_VAR 0 1
54891: PPUSH
54892: EMPTY
54893: PPUSH
54894: CALL_OW 1
54898: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54899: LD_ADDR_EXP 107
54903: PUSH
54904: LD_EXP 107
54908: PPUSH
54909: LD_VAR 0 1
54913: PPUSH
54914: EMPTY
54915: PPUSH
54916: CALL_OW 1
54920: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54921: LD_ADDR_EXP 108
54925: PUSH
54926: LD_EXP 108
54930: PPUSH
54931: LD_VAR 0 1
54935: PPUSH
54936: EMPTY
54937: PPUSH
54938: CALL_OW 1
54942: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54943: LD_ADDR_EXP 109
54947: PUSH
54948: LD_EXP 109
54952: PPUSH
54953: LD_VAR 0 1
54957: PPUSH
54958: EMPTY
54959: PPUSH
54960: CALL_OW 1
54964: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54965: LD_ADDR_EXP 110
54969: PUSH
54970: LD_EXP 110
54974: PPUSH
54975: LD_VAR 0 1
54979: PPUSH
54980: EMPTY
54981: PPUSH
54982: CALL_OW 1
54986: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54987: LD_ADDR_EXP 111
54991: PUSH
54992: LD_EXP 111
54996: PPUSH
54997: LD_VAR 0 1
55001: PPUSH
55002: LD_INT 0
55004: PPUSH
55005: CALL_OW 1
55009: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
55010: LD_ADDR_EXP 112
55014: PUSH
55015: LD_EXP 112
55019: PPUSH
55020: LD_VAR 0 1
55024: PPUSH
55025: LD_INT 0
55027: PPUSH
55028: CALL_OW 1
55032: ST_TO_ADDR
// end ;
55033: LD_VAR 0 2
55037: RET
// export function MC_Add ( side , units ) ; var base ; begin
55038: LD_INT 0
55040: PPUSH
55041: PPUSH
// base := mc_bases + 1 ;
55042: LD_ADDR_VAR 0 4
55046: PUSH
55047: LD_EXP 69
55051: PUSH
55052: LD_INT 1
55054: PLUS
55055: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
55056: LD_ADDR_EXP 95
55060: PUSH
55061: LD_EXP 95
55065: PPUSH
55066: LD_VAR 0 4
55070: PPUSH
55071: LD_VAR 0 1
55075: PPUSH
55076: CALL_OW 1
55080: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
55081: LD_ADDR_EXP 69
55085: PUSH
55086: LD_EXP 69
55090: PPUSH
55091: LD_VAR 0 4
55095: PPUSH
55096: LD_VAR 0 2
55100: PPUSH
55101: CALL_OW 1
55105: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55106: LD_ADDR_EXP 70
55110: PUSH
55111: LD_EXP 70
55115: PPUSH
55116: LD_VAR 0 4
55120: PPUSH
55121: EMPTY
55122: PPUSH
55123: CALL_OW 1
55127: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55128: LD_ADDR_EXP 71
55132: PUSH
55133: LD_EXP 71
55137: PPUSH
55138: LD_VAR 0 4
55142: PPUSH
55143: EMPTY
55144: PPUSH
55145: CALL_OW 1
55149: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55150: LD_ADDR_EXP 72
55154: PUSH
55155: LD_EXP 72
55159: PPUSH
55160: LD_VAR 0 4
55164: PPUSH
55165: EMPTY
55166: PPUSH
55167: CALL_OW 1
55171: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55172: LD_ADDR_EXP 73
55176: PUSH
55177: LD_EXP 73
55181: PPUSH
55182: LD_VAR 0 4
55186: PPUSH
55187: EMPTY
55188: PPUSH
55189: CALL_OW 1
55193: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55194: LD_ADDR_EXP 74
55198: PUSH
55199: LD_EXP 74
55203: PPUSH
55204: LD_VAR 0 4
55208: PPUSH
55209: EMPTY
55210: PPUSH
55211: CALL_OW 1
55215: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55216: LD_ADDR_EXP 75
55220: PUSH
55221: LD_EXP 75
55225: PPUSH
55226: LD_VAR 0 4
55230: PPUSH
55231: EMPTY
55232: PPUSH
55233: CALL_OW 1
55237: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55238: LD_ADDR_EXP 76
55242: PUSH
55243: LD_EXP 76
55247: PPUSH
55248: LD_VAR 0 4
55252: PPUSH
55253: EMPTY
55254: PPUSH
55255: CALL_OW 1
55259: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55260: LD_ADDR_EXP 77
55264: PUSH
55265: LD_EXP 77
55269: PPUSH
55270: LD_VAR 0 4
55274: PPUSH
55275: EMPTY
55276: PPUSH
55277: CALL_OW 1
55281: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55282: LD_ADDR_EXP 78
55286: PUSH
55287: LD_EXP 78
55291: PPUSH
55292: LD_VAR 0 4
55296: PPUSH
55297: EMPTY
55298: PPUSH
55299: CALL_OW 1
55303: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55304: LD_ADDR_EXP 79
55308: PUSH
55309: LD_EXP 79
55313: PPUSH
55314: LD_VAR 0 4
55318: PPUSH
55319: EMPTY
55320: PPUSH
55321: CALL_OW 1
55325: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55326: LD_ADDR_EXP 80
55330: PUSH
55331: LD_EXP 80
55335: PPUSH
55336: LD_VAR 0 4
55340: PPUSH
55341: LD_INT 0
55343: PPUSH
55344: CALL_OW 1
55348: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55349: LD_ADDR_EXP 81
55353: PUSH
55354: LD_EXP 81
55358: PPUSH
55359: LD_VAR 0 4
55363: PPUSH
55364: EMPTY
55365: PPUSH
55366: CALL_OW 1
55370: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55371: LD_ADDR_EXP 82
55375: PUSH
55376: LD_EXP 82
55380: PPUSH
55381: LD_VAR 0 4
55385: PPUSH
55386: EMPTY
55387: PPUSH
55388: CALL_OW 1
55392: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55393: LD_ADDR_EXP 83
55397: PUSH
55398: LD_EXP 83
55402: PPUSH
55403: LD_VAR 0 4
55407: PPUSH
55408: EMPTY
55409: PPUSH
55410: CALL_OW 1
55414: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55415: LD_ADDR_EXP 84
55419: PUSH
55420: LD_EXP 84
55424: PPUSH
55425: LD_VAR 0 4
55429: PPUSH
55430: EMPTY
55431: PPUSH
55432: CALL_OW 1
55436: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55437: LD_ADDR_EXP 85
55441: PUSH
55442: LD_EXP 85
55446: PPUSH
55447: LD_VAR 0 4
55451: PPUSH
55452: EMPTY
55453: PPUSH
55454: CALL_OW 1
55458: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55459: LD_ADDR_EXP 86
55463: PUSH
55464: LD_EXP 86
55468: PPUSH
55469: LD_VAR 0 4
55473: PPUSH
55474: EMPTY
55475: PPUSH
55476: CALL_OW 1
55480: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55481: LD_ADDR_EXP 87
55485: PUSH
55486: LD_EXP 87
55490: PPUSH
55491: LD_VAR 0 4
55495: PPUSH
55496: EMPTY
55497: PPUSH
55498: CALL_OW 1
55502: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55503: LD_ADDR_EXP 88
55507: PUSH
55508: LD_EXP 88
55512: PPUSH
55513: LD_VAR 0 4
55517: PPUSH
55518: EMPTY
55519: PPUSH
55520: CALL_OW 1
55524: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55525: LD_ADDR_EXP 89
55529: PUSH
55530: LD_EXP 89
55534: PPUSH
55535: LD_VAR 0 4
55539: PPUSH
55540: EMPTY
55541: PPUSH
55542: CALL_OW 1
55546: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55547: LD_ADDR_EXP 90
55551: PUSH
55552: LD_EXP 90
55556: PPUSH
55557: LD_VAR 0 4
55561: PPUSH
55562: EMPTY
55563: PPUSH
55564: CALL_OW 1
55568: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55569: LD_ADDR_EXP 91
55573: PUSH
55574: LD_EXP 91
55578: PPUSH
55579: LD_VAR 0 4
55583: PPUSH
55584: EMPTY
55585: PPUSH
55586: CALL_OW 1
55590: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55591: LD_ADDR_EXP 92
55595: PUSH
55596: LD_EXP 92
55600: PPUSH
55601: LD_VAR 0 4
55605: PPUSH
55606: EMPTY
55607: PPUSH
55608: CALL_OW 1
55612: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55613: LD_ADDR_EXP 93
55617: PUSH
55618: LD_EXP 93
55622: PPUSH
55623: LD_VAR 0 4
55627: PPUSH
55628: EMPTY
55629: PPUSH
55630: CALL_OW 1
55634: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55635: LD_ADDR_EXP 94
55639: PUSH
55640: LD_EXP 94
55644: PPUSH
55645: LD_VAR 0 4
55649: PPUSH
55650: EMPTY
55651: PPUSH
55652: CALL_OW 1
55656: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55657: LD_ADDR_EXP 96
55661: PUSH
55662: LD_EXP 96
55666: PPUSH
55667: LD_VAR 0 4
55671: PPUSH
55672: EMPTY
55673: PPUSH
55674: CALL_OW 1
55678: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55679: LD_ADDR_EXP 98
55683: PUSH
55684: LD_EXP 98
55688: PPUSH
55689: LD_VAR 0 4
55693: PPUSH
55694: EMPTY
55695: PPUSH
55696: CALL_OW 1
55700: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55701: LD_ADDR_EXP 99
55705: PUSH
55706: LD_EXP 99
55710: PPUSH
55711: LD_VAR 0 4
55715: PPUSH
55716: EMPTY
55717: PPUSH
55718: CALL_OW 1
55722: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55723: LD_ADDR_EXP 100
55727: PUSH
55728: LD_EXP 100
55732: PPUSH
55733: LD_VAR 0 4
55737: PPUSH
55738: EMPTY
55739: PPUSH
55740: CALL_OW 1
55744: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55745: LD_ADDR_EXP 101
55749: PUSH
55750: LD_EXP 101
55754: PPUSH
55755: LD_VAR 0 4
55759: PPUSH
55760: EMPTY
55761: PPUSH
55762: CALL_OW 1
55766: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55767: LD_ADDR_EXP 102
55771: PUSH
55772: LD_EXP 102
55776: PPUSH
55777: LD_VAR 0 4
55781: PPUSH
55782: EMPTY
55783: PPUSH
55784: CALL_OW 1
55788: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55789: LD_ADDR_EXP 103
55793: PUSH
55794: LD_EXP 103
55798: PPUSH
55799: LD_VAR 0 4
55803: PPUSH
55804: EMPTY
55805: PPUSH
55806: CALL_OW 1
55810: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55811: LD_ADDR_EXP 104
55815: PUSH
55816: LD_EXP 104
55820: PPUSH
55821: LD_VAR 0 4
55825: PPUSH
55826: EMPTY
55827: PPUSH
55828: CALL_OW 1
55832: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55833: LD_ADDR_EXP 105
55837: PUSH
55838: LD_EXP 105
55842: PPUSH
55843: LD_VAR 0 4
55847: PPUSH
55848: EMPTY
55849: PPUSH
55850: CALL_OW 1
55854: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55855: LD_ADDR_EXP 106
55859: PUSH
55860: LD_EXP 106
55864: PPUSH
55865: LD_VAR 0 4
55869: PPUSH
55870: EMPTY
55871: PPUSH
55872: CALL_OW 1
55876: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55877: LD_ADDR_EXP 107
55881: PUSH
55882: LD_EXP 107
55886: PPUSH
55887: LD_VAR 0 4
55891: PPUSH
55892: EMPTY
55893: PPUSH
55894: CALL_OW 1
55898: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55899: LD_ADDR_EXP 108
55903: PUSH
55904: LD_EXP 108
55908: PPUSH
55909: LD_VAR 0 4
55913: PPUSH
55914: EMPTY
55915: PPUSH
55916: CALL_OW 1
55920: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55921: LD_ADDR_EXP 109
55925: PUSH
55926: LD_EXP 109
55930: PPUSH
55931: LD_VAR 0 4
55935: PPUSH
55936: EMPTY
55937: PPUSH
55938: CALL_OW 1
55942: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55943: LD_ADDR_EXP 110
55947: PUSH
55948: LD_EXP 110
55952: PPUSH
55953: LD_VAR 0 4
55957: PPUSH
55958: EMPTY
55959: PPUSH
55960: CALL_OW 1
55964: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55965: LD_ADDR_EXP 111
55969: PUSH
55970: LD_EXP 111
55974: PPUSH
55975: LD_VAR 0 4
55979: PPUSH
55980: LD_INT 0
55982: PPUSH
55983: CALL_OW 1
55987: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
55988: LD_ADDR_EXP 112
55992: PUSH
55993: LD_EXP 112
55997: PPUSH
55998: LD_VAR 0 4
56002: PPUSH
56003: LD_INT 0
56005: PPUSH
56006: CALL_OW 1
56010: ST_TO_ADDR
// result := base ;
56011: LD_ADDR_VAR 0 3
56015: PUSH
56016: LD_VAR 0 4
56020: ST_TO_ADDR
// end ;
56021: LD_VAR 0 3
56025: RET
// export function MC_Start ( ) ; var i ; begin
56026: LD_INT 0
56028: PPUSH
56029: PPUSH
// for i = 1 to mc_bases do
56030: LD_ADDR_VAR 0 2
56034: PUSH
56035: DOUBLE
56036: LD_INT 1
56038: DEC
56039: ST_TO_ADDR
56040: LD_EXP 69
56044: PUSH
56045: FOR_TO
56046: IFFALSE 57146
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
56048: LD_ADDR_EXP 69
56052: PUSH
56053: LD_EXP 69
56057: PPUSH
56058: LD_VAR 0 2
56062: PPUSH
56063: LD_EXP 69
56067: PUSH
56068: LD_VAR 0 2
56072: ARRAY
56073: PUSH
56074: LD_INT 0
56076: DIFF
56077: PPUSH
56078: CALL_OW 1
56082: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
56083: LD_ADDR_EXP 70
56087: PUSH
56088: LD_EXP 70
56092: PPUSH
56093: LD_VAR 0 2
56097: PPUSH
56098: EMPTY
56099: PPUSH
56100: CALL_OW 1
56104: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56105: LD_ADDR_EXP 71
56109: PUSH
56110: LD_EXP 71
56114: PPUSH
56115: LD_VAR 0 2
56119: PPUSH
56120: EMPTY
56121: PPUSH
56122: CALL_OW 1
56126: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
56127: LD_ADDR_EXP 72
56131: PUSH
56132: LD_EXP 72
56136: PPUSH
56137: LD_VAR 0 2
56141: PPUSH
56142: EMPTY
56143: PPUSH
56144: CALL_OW 1
56148: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
56149: LD_ADDR_EXP 73
56153: PUSH
56154: LD_EXP 73
56158: PPUSH
56159: LD_VAR 0 2
56163: PPUSH
56164: EMPTY
56165: PUSH
56166: EMPTY
56167: PUSH
56168: EMPTY
56169: LIST
56170: LIST
56171: PPUSH
56172: CALL_OW 1
56176: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
56177: LD_ADDR_EXP 74
56181: PUSH
56182: LD_EXP 74
56186: PPUSH
56187: LD_VAR 0 2
56191: PPUSH
56192: EMPTY
56193: PPUSH
56194: CALL_OW 1
56198: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
56199: LD_ADDR_EXP 101
56203: PUSH
56204: LD_EXP 101
56208: PPUSH
56209: LD_VAR 0 2
56213: PPUSH
56214: EMPTY
56215: PPUSH
56216: CALL_OW 1
56220: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
56221: LD_ADDR_EXP 75
56225: PUSH
56226: LD_EXP 75
56230: PPUSH
56231: LD_VAR 0 2
56235: PPUSH
56236: EMPTY
56237: PPUSH
56238: CALL_OW 1
56242: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
56243: LD_ADDR_EXP 76
56247: PUSH
56248: LD_EXP 76
56252: PPUSH
56253: LD_VAR 0 2
56257: PPUSH
56258: EMPTY
56259: PPUSH
56260: CALL_OW 1
56264: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
56265: LD_ADDR_EXP 77
56269: PUSH
56270: LD_EXP 77
56274: PPUSH
56275: LD_VAR 0 2
56279: PPUSH
56280: LD_EXP 69
56284: PUSH
56285: LD_VAR 0 2
56289: ARRAY
56290: PPUSH
56291: LD_INT 2
56293: PUSH
56294: LD_INT 30
56296: PUSH
56297: LD_INT 32
56299: PUSH
56300: EMPTY
56301: LIST
56302: LIST
56303: PUSH
56304: LD_INT 30
56306: PUSH
56307: LD_INT 33
56309: PUSH
56310: EMPTY
56311: LIST
56312: LIST
56313: PUSH
56314: EMPTY
56315: LIST
56316: LIST
56317: LIST
56318: PPUSH
56319: CALL_OW 72
56323: PPUSH
56324: CALL_OW 1
56328: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
56329: LD_ADDR_EXP 78
56333: PUSH
56334: LD_EXP 78
56338: PPUSH
56339: LD_VAR 0 2
56343: PPUSH
56344: LD_EXP 69
56348: PUSH
56349: LD_VAR 0 2
56353: ARRAY
56354: PPUSH
56355: LD_INT 2
56357: PUSH
56358: LD_INT 30
56360: PUSH
56361: LD_INT 32
56363: PUSH
56364: EMPTY
56365: LIST
56366: LIST
56367: PUSH
56368: LD_INT 30
56370: PUSH
56371: LD_INT 31
56373: PUSH
56374: EMPTY
56375: LIST
56376: LIST
56377: PUSH
56378: EMPTY
56379: LIST
56380: LIST
56381: LIST
56382: PUSH
56383: LD_INT 58
56385: PUSH
56386: EMPTY
56387: LIST
56388: PUSH
56389: EMPTY
56390: LIST
56391: LIST
56392: PPUSH
56393: CALL_OW 72
56397: PPUSH
56398: CALL_OW 1
56402: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
56403: LD_ADDR_EXP 79
56407: PUSH
56408: LD_EXP 79
56412: PPUSH
56413: LD_VAR 0 2
56417: PPUSH
56418: EMPTY
56419: PPUSH
56420: CALL_OW 1
56424: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
56425: LD_ADDR_EXP 83
56429: PUSH
56430: LD_EXP 83
56434: PPUSH
56435: LD_VAR 0 2
56439: PPUSH
56440: EMPTY
56441: PPUSH
56442: CALL_OW 1
56446: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
56447: LD_ADDR_EXP 82
56451: PUSH
56452: LD_EXP 82
56456: PPUSH
56457: LD_VAR 0 2
56461: PPUSH
56462: EMPTY
56463: PPUSH
56464: CALL_OW 1
56468: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
56469: LD_ADDR_EXP 84
56473: PUSH
56474: LD_EXP 84
56478: PPUSH
56479: LD_VAR 0 2
56483: PPUSH
56484: EMPTY
56485: PPUSH
56486: CALL_OW 1
56490: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
56491: LD_ADDR_EXP 85
56495: PUSH
56496: LD_EXP 85
56500: PPUSH
56501: LD_VAR 0 2
56505: PPUSH
56506: EMPTY
56507: PPUSH
56508: CALL_OW 1
56512: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
56513: LD_ADDR_EXP 86
56517: PUSH
56518: LD_EXP 86
56522: PPUSH
56523: LD_VAR 0 2
56527: PPUSH
56528: EMPTY
56529: PPUSH
56530: CALL_OW 1
56534: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
56535: LD_ADDR_EXP 87
56539: PUSH
56540: LD_EXP 87
56544: PPUSH
56545: LD_VAR 0 2
56549: PPUSH
56550: EMPTY
56551: PPUSH
56552: CALL_OW 1
56556: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
56557: LD_ADDR_EXP 88
56561: PUSH
56562: LD_EXP 88
56566: PPUSH
56567: LD_VAR 0 2
56571: PPUSH
56572: EMPTY
56573: PPUSH
56574: CALL_OW 1
56578: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
56579: LD_ADDR_EXP 89
56583: PUSH
56584: LD_EXP 89
56588: PPUSH
56589: LD_VAR 0 2
56593: PPUSH
56594: EMPTY
56595: PPUSH
56596: CALL_OW 1
56600: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
56601: LD_ADDR_EXP 90
56605: PUSH
56606: LD_EXP 90
56610: PPUSH
56611: LD_VAR 0 2
56615: PPUSH
56616: EMPTY
56617: PPUSH
56618: CALL_OW 1
56622: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56623: LD_ADDR_EXP 91
56627: PUSH
56628: LD_EXP 91
56632: PPUSH
56633: LD_VAR 0 2
56637: PPUSH
56638: EMPTY
56639: PPUSH
56640: CALL_OW 1
56644: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
56645: LD_ADDR_EXP 80
56649: PUSH
56650: LD_EXP 80
56654: PPUSH
56655: LD_VAR 0 2
56659: PPUSH
56660: LD_INT 0
56662: PPUSH
56663: CALL_OW 1
56667: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
56668: LD_ADDR_EXP 93
56672: PUSH
56673: LD_EXP 93
56677: PPUSH
56678: LD_VAR 0 2
56682: PPUSH
56683: LD_INT 0
56685: PPUSH
56686: CALL_OW 1
56690: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
56691: LD_ADDR_EXP 81
56695: PUSH
56696: LD_EXP 81
56700: PPUSH
56701: LD_VAR 0 2
56705: PPUSH
56706: EMPTY
56707: PPUSH
56708: CALL_OW 1
56712: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
56713: LD_ADDR_EXP 92
56717: PUSH
56718: LD_EXP 92
56722: PPUSH
56723: LD_VAR 0 2
56727: PPUSH
56728: LD_INT 0
56730: PPUSH
56731: CALL_OW 1
56735: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
56736: LD_ADDR_EXP 94
56740: PUSH
56741: LD_EXP 94
56745: PPUSH
56746: LD_VAR 0 2
56750: PPUSH
56751: EMPTY
56752: PPUSH
56753: CALL_OW 1
56757: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
56758: LD_ADDR_EXP 97
56762: PUSH
56763: LD_EXP 97
56767: PPUSH
56768: LD_VAR 0 2
56772: PPUSH
56773: LD_INT 0
56775: PPUSH
56776: CALL_OW 1
56780: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
56781: LD_ADDR_EXP 98
56785: PUSH
56786: LD_EXP 98
56790: PPUSH
56791: LD_VAR 0 2
56795: PPUSH
56796: EMPTY
56797: PPUSH
56798: CALL_OW 1
56802: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
56803: LD_ADDR_EXP 99
56807: PUSH
56808: LD_EXP 99
56812: PPUSH
56813: LD_VAR 0 2
56817: PPUSH
56818: EMPTY
56819: PPUSH
56820: CALL_OW 1
56824: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
56825: LD_ADDR_EXP 100
56829: PUSH
56830: LD_EXP 100
56834: PPUSH
56835: LD_VAR 0 2
56839: PPUSH
56840: EMPTY
56841: PPUSH
56842: CALL_OW 1
56846: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
56847: LD_ADDR_EXP 102
56851: PUSH
56852: LD_EXP 102
56856: PPUSH
56857: LD_VAR 0 2
56861: PPUSH
56862: LD_EXP 69
56866: PUSH
56867: LD_VAR 0 2
56871: ARRAY
56872: PPUSH
56873: LD_INT 2
56875: PUSH
56876: LD_INT 30
56878: PUSH
56879: LD_INT 6
56881: PUSH
56882: EMPTY
56883: LIST
56884: LIST
56885: PUSH
56886: LD_INT 30
56888: PUSH
56889: LD_INT 7
56891: PUSH
56892: EMPTY
56893: LIST
56894: LIST
56895: PUSH
56896: LD_INT 30
56898: PUSH
56899: LD_INT 8
56901: PUSH
56902: EMPTY
56903: LIST
56904: LIST
56905: PUSH
56906: EMPTY
56907: LIST
56908: LIST
56909: LIST
56910: LIST
56911: PPUSH
56912: CALL_OW 72
56916: PPUSH
56917: CALL_OW 1
56921: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
56922: LD_ADDR_EXP 103
56926: PUSH
56927: LD_EXP 103
56931: PPUSH
56932: LD_VAR 0 2
56936: PPUSH
56937: EMPTY
56938: PPUSH
56939: CALL_OW 1
56943: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
56944: LD_ADDR_EXP 104
56948: PUSH
56949: LD_EXP 104
56953: PPUSH
56954: LD_VAR 0 2
56958: PPUSH
56959: EMPTY
56960: PPUSH
56961: CALL_OW 1
56965: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
56966: LD_ADDR_EXP 105
56970: PUSH
56971: LD_EXP 105
56975: PPUSH
56976: LD_VAR 0 2
56980: PPUSH
56981: EMPTY
56982: PPUSH
56983: CALL_OW 1
56987: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
56988: LD_ADDR_EXP 106
56992: PUSH
56993: LD_EXP 106
56997: PPUSH
56998: LD_VAR 0 2
57002: PPUSH
57003: EMPTY
57004: PPUSH
57005: CALL_OW 1
57009: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57010: LD_ADDR_EXP 107
57014: PUSH
57015: LD_EXP 107
57019: PPUSH
57020: LD_VAR 0 2
57024: PPUSH
57025: EMPTY
57026: PPUSH
57027: CALL_OW 1
57031: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
57032: LD_ADDR_EXP 108
57036: PUSH
57037: LD_EXP 108
57041: PPUSH
57042: LD_VAR 0 2
57046: PPUSH
57047: EMPTY
57048: PPUSH
57049: CALL_OW 1
57053: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
57054: LD_ADDR_EXP 109
57058: PUSH
57059: LD_EXP 109
57063: PPUSH
57064: LD_VAR 0 2
57068: PPUSH
57069: EMPTY
57070: PPUSH
57071: CALL_OW 1
57075: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
57076: LD_ADDR_EXP 110
57080: PUSH
57081: LD_EXP 110
57085: PPUSH
57086: LD_VAR 0 2
57090: PPUSH
57091: EMPTY
57092: PPUSH
57093: CALL_OW 1
57097: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
57098: LD_ADDR_EXP 111
57102: PUSH
57103: LD_EXP 111
57107: PPUSH
57108: LD_VAR 0 2
57112: PPUSH
57113: LD_INT 0
57115: PPUSH
57116: CALL_OW 1
57120: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
57121: LD_ADDR_EXP 112
57125: PUSH
57126: LD_EXP 112
57130: PPUSH
57131: LD_VAR 0 2
57135: PPUSH
57136: LD_INT 0
57138: PPUSH
57139: CALL_OW 1
57143: ST_TO_ADDR
// end ;
57144: GO 56045
57146: POP
57147: POP
// MC_InitSides ( ) ;
57148: CALL 57434 0 0
// MC_InitResearch ( ) ;
57152: CALL 57173 0 0
// CustomInitMacro ( ) ;
57156: CALL 5753 0 0
// skirmish := true ;
57160: LD_ADDR_EXP 67
57164: PUSH
57165: LD_INT 1
57167: ST_TO_ADDR
// end ;
57168: LD_VAR 0 1
57172: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
57173: LD_INT 0
57175: PPUSH
57176: PPUSH
57177: PPUSH
57178: PPUSH
57179: PPUSH
57180: PPUSH
// if not mc_bases then
57181: LD_EXP 69
57185: NOT
57186: IFFALSE 57190
// exit ;
57188: GO 57429
// for i = 1 to 8 do
57190: LD_ADDR_VAR 0 2
57194: PUSH
57195: DOUBLE
57196: LD_INT 1
57198: DEC
57199: ST_TO_ADDR
57200: LD_INT 8
57202: PUSH
57203: FOR_TO
57204: IFFALSE 57230
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
57206: LD_ADDR_EXP 96
57210: PUSH
57211: LD_EXP 96
57215: PPUSH
57216: LD_VAR 0 2
57220: PPUSH
57221: EMPTY
57222: PPUSH
57223: CALL_OW 1
57227: ST_TO_ADDR
57228: GO 57203
57230: POP
57231: POP
// tmp := [ ] ;
57232: LD_ADDR_VAR 0 5
57236: PUSH
57237: EMPTY
57238: ST_TO_ADDR
// for i = 1 to mc_sides do
57239: LD_ADDR_VAR 0 2
57243: PUSH
57244: DOUBLE
57245: LD_INT 1
57247: DEC
57248: ST_TO_ADDR
57249: LD_EXP 95
57253: PUSH
57254: FOR_TO
57255: IFFALSE 57313
// if not mc_sides [ i ] in tmp then
57257: LD_EXP 95
57261: PUSH
57262: LD_VAR 0 2
57266: ARRAY
57267: PUSH
57268: LD_VAR 0 5
57272: IN
57273: NOT
57274: IFFALSE 57311
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
57276: LD_ADDR_VAR 0 5
57280: PUSH
57281: LD_VAR 0 5
57285: PPUSH
57286: LD_VAR 0 5
57290: PUSH
57291: LD_INT 1
57293: PLUS
57294: PPUSH
57295: LD_EXP 95
57299: PUSH
57300: LD_VAR 0 2
57304: ARRAY
57305: PPUSH
57306: CALL_OW 2
57310: ST_TO_ADDR
57311: GO 57254
57313: POP
57314: POP
// if not tmp then
57315: LD_VAR 0 5
57319: NOT
57320: IFFALSE 57324
// exit ;
57322: GO 57429
// for j in tmp do
57324: LD_ADDR_VAR 0 3
57328: PUSH
57329: LD_VAR 0 5
57333: PUSH
57334: FOR_IN
57335: IFFALSE 57427
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
57337: LD_ADDR_VAR 0 6
57341: PUSH
57342: LD_INT 22
57344: PUSH
57345: LD_VAR 0 3
57349: PUSH
57350: EMPTY
57351: LIST
57352: LIST
57353: PPUSH
57354: CALL_OW 69
57358: ST_TO_ADDR
// if not un then
57359: LD_VAR 0 6
57363: NOT
57364: IFFALSE 57368
// continue ;
57366: GO 57334
// nation := GetNation ( un [ 1 ] ) ;
57368: LD_ADDR_VAR 0 4
57372: PUSH
57373: LD_VAR 0 6
57377: PUSH
57378: LD_INT 1
57380: ARRAY
57381: PPUSH
57382: CALL_OW 248
57386: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
57387: LD_ADDR_EXP 96
57391: PUSH
57392: LD_EXP 96
57396: PPUSH
57397: LD_VAR 0 3
57401: PPUSH
57402: LD_VAR 0 3
57406: PPUSH
57407: LD_VAR 0 4
57411: PPUSH
57412: LD_INT 1
57414: PPUSH
57415: CALL 13665 0 3
57419: PPUSH
57420: CALL_OW 1
57424: ST_TO_ADDR
// end ;
57425: GO 57334
57427: POP
57428: POP
// end ;
57429: LD_VAR 0 1
57433: RET
// export function MC_InitSides ( ) ; var i ; begin
57434: LD_INT 0
57436: PPUSH
57437: PPUSH
// if not mc_bases then
57438: LD_EXP 69
57442: NOT
57443: IFFALSE 57447
// exit ;
57445: GO 57521
// for i = 1 to mc_bases do
57447: LD_ADDR_VAR 0 2
57451: PUSH
57452: DOUBLE
57453: LD_INT 1
57455: DEC
57456: ST_TO_ADDR
57457: LD_EXP 69
57461: PUSH
57462: FOR_TO
57463: IFFALSE 57519
// if mc_bases [ i ] then
57465: LD_EXP 69
57469: PUSH
57470: LD_VAR 0 2
57474: ARRAY
57475: IFFALSE 57517
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
57477: LD_ADDR_EXP 95
57481: PUSH
57482: LD_EXP 95
57486: PPUSH
57487: LD_VAR 0 2
57491: PPUSH
57492: LD_EXP 69
57496: PUSH
57497: LD_VAR 0 2
57501: ARRAY
57502: PUSH
57503: LD_INT 1
57505: ARRAY
57506: PPUSH
57507: CALL_OW 255
57511: PPUSH
57512: CALL_OW 1
57516: ST_TO_ADDR
57517: GO 57462
57519: POP
57520: POP
// end ;
57521: LD_VAR 0 1
57525: RET
// every 0 0$03 trigger skirmish do
57526: LD_EXP 67
57530: IFFALSE 57684
57532: GO 57534
57534: DISABLE
// begin enable ;
57535: ENABLE
// MC_CheckBuildings ( ) ;
57536: CALL 62182 0 0
// MC_CheckPeopleLife ( ) ;
57540: CALL 62343 0 0
// RaiseSailEvent ( 100 ) ;
57544: LD_INT 100
57546: PPUSH
57547: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
57551: LD_INT 103
57553: PPUSH
57554: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
57558: LD_INT 104
57560: PPUSH
57561: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
57565: LD_INT 105
57567: PPUSH
57568: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
57572: LD_INT 106
57574: PPUSH
57575: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
57579: LD_INT 107
57581: PPUSH
57582: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
57586: LD_INT 108
57588: PPUSH
57589: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
57593: LD_INT 109
57595: PPUSH
57596: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
57600: LD_INT 110
57602: PPUSH
57603: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
57607: LD_INT 111
57609: PPUSH
57610: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
57614: LD_INT 112
57616: PPUSH
57617: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
57621: LD_INT 113
57623: PPUSH
57624: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
57628: LD_INT 120
57630: PPUSH
57631: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
57635: LD_INT 121
57637: PPUSH
57638: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
57642: LD_INT 122
57644: PPUSH
57645: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
57649: LD_INT 123
57651: PPUSH
57652: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
57656: LD_INT 124
57658: PPUSH
57659: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
57663: LD_INT 125
57665: PPUSH
57666: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
57670: LD_INT 126
57672: PPUSH
57673: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
57677: LD_INT 200
57679: PPUSH
57680: CALL_OW 427
// end ;
57684: END
// on SailEvent ( event ) do begin if event < 100 then
57685: LD_VAR 0 1
57689: PUSH
57690: LD_INT 100
57692: LESS
57693: IFFALSE 57704
// CustomEvent ( event ) ;
57695: LD_VAR 0 1
57699: PPUSH
57700: CALL 5745 0 1
// if event = 100 then
57704: LD_VAR 0 1
57708: PUSH
57709: LD_INT 100
57711: EQUAL
57712: IFFALSE 57718
// MC_ClassManager ( ) ;
57714: CALL 58110 0 0
// if event = 101 then
57718: LD_VAR 0 1
57722: PUSH
57723: LD_INT 101
57725: EQUAL
57726: IFFALSE 57732
// MC_RepairBuildings ( ) ;
57728: CALL 62928 0 0
// if event = 102 then
57732: LD_VAR 0 1
57736: PUSH
57737: LD_INT 102
57739: EQUAL
57740: IFFALSE 57746
// MC_Heal ( ) ;
57742: CALL 63835 0 0
// if event = 103 then
57746: LD_VAR 0 1
57750: PUSH
57751: LD_INT 103
57753: EQUAL
57754: IFFALSE 57760
// MC_Build ( ) ;
57756: CALL 64257 0 0
// if event = 104 then
57760: LD_VAR 0 1
57764: PUSH
57765: LD_INT 104
57767: EQUAL
57768: IFFALSE 57774
// MC_TurretWeapon ( ) ;
57770: CALL 65898 0 0
// if event = 105 then
57774: LD_VAR 0 1
57778: PUSH
57779: LD_INT 105
57781: EQUAL
57782: IFFALSE 57788
// MC_BuildUpgrade ( ) ;
57784: CALL 65449 0 0
// if event = 106 then
57788: LD_VAR 0 1
57792: PUSH
57793: LD_INT 106
57795: EQUAL
57796: IFFALSE 57802
// MC_PlantMines ( ) ;
57798: CALL 66328 0 0
// if event = 107 then
57802: LD_VAR 0 1
57806: PUSH
57807: LD_INT 107
57809: EQUAL
57810: IFFALSE 57816
// MC_CollectCrates ( ) ;
57812: CALL 67119 0 0
// if event = 108 then
57816: LD_VAR 0 1
57820: PUSH
57821: LD_INT 108
57823: EQUAL
57824: IFFALSE 57830
// MC_LinkRemoteControl ( ) ;
57826: CALL 68969 0 0
// if event = 109 then
57830: LD_VAR 0 1
57834: PUSH
57835: LD_INT 109
57837: EQUAL
57838: IFFALSE 57844
// MC_ProduceVehicle ( ) ;
57840: CALL 69150 0 0
// if event = 110 then
57844: LD_VAR 0 1
57848: PUSH
57849: LD_INT 110
57851: EQUAL
57852: IFFALSE 57858
// MC_SendAttack ( ) ;
57854: CALL 69616 0 0
// if event = 111 then
57858: LD_VAR 0 1
57862: PUSH
57863: LD_INT 111
57865: EQUAL
57866: IFFALSE 57872
// MC_Defend ( ) ;
57868: CALL 69724 0 0
// if event = 112 then
57872: LD_VAR 0 1
57876: PUSH
57877: LD_INT 112
57879: EQUAL
57880: IFFALSE 57886
// MC_Research ( ) ;
57882: CALL 70604 0 0
// if event = 113 then
57886: LD_VAR 0 1
57890: PUSH
57891: LD_INT 113
57893: EQUAL
57894: IFFALSE 57900
// MC_MinesTrigger ( ) ;
57896: CALL 71718 0 0
// if event = 120 then
57900: LD_VAR 0 1
57904: PUSH
57905: LD_INT 120
57907: EQUAL
57908: IFFALSE 57914
// MC_RepairVehicle ( ) ;
57910: CALL 71817 0 0
// if event = 121 then
57914: LD_VAR 0 1
57918: PUSH
57919: LD_INT 121
57921: EQUAL
57922: IFFALSE 57928
// MC_TameApe ( ) ;
57924: CALL 72558 0 0
// if event = 122 then
57928: LD_VAR 0 1
57932: PUSH
57933: LD_INT 122
57935: EQUAL
57936: IFFALSE 57942
// MC_ChangeApeClass ( ) ;
57938: CALL 73387 0 0
// if event = 123 then
57942: LD_VAR 0 1
57946: PUSH
57947: LD_INT 123
57949: EQUAL
57950: IFFALSE 57956
// MC_Bazooka ( ) ;
57952: CALL 74037 0 0
// if event = 124 then
57956: LD_VAR 0 1
57960: PUSH
57961: LD_INT 124
57963: EQUAL
57964: IFFALSE 57970
// MC_TeleportExit ( ) ;
57966: CALL 74235 0 0
// if event = 125 then
57970: LD_VAR 0 1
57974: PUSH
57975: LD_INT 125
57977: EQUAL
57978: IFFALSE 57984
// MC_Deposits ( ) ;
57980: CALL 74882 0 0
// if event = 126 then
57984: LD_VAR 0 1
57988: PUSH
57989: LD_INT 126
57991: EQUAL
57992: IFFALSE 57998
// MC_RemoteDriver ( ) ;
57994: CALL 75507 0 0
// if event = 200 then
57998: LD_VAR 0 1
58002: PUSH
58003: LD_INT 200
58005: EQUAL
58006: IFFALSE 58012
// MC_Idle ( ) ;
58008: CALL 77456 0 0
// end ;
58012: PPOPN 1
58014: END
// export function MC_Reset ( base , tag ) ; var i ; begin
58015: LD_INT 0
58017: PPUSH
58018: PPUSH
// if not mc_bases [ base ] or not tag then
58019: LD_EXP 69
58023: PUSH
58024: LD_VAR 0 1
58028: ARRAY
58029: NOT
58030: PUSH
58031: LD_VAR 0 2
58035: NOT
58036: OR
58037: IFFALSE 58041
// exit ;
58039: GO 58105
// for i in mc_bases [ base ] union mc_ape [ base ] do
58041: LD_ADDR_VAR 0 4
58045: PUSH
58046: LD_EXP 69
58050: PUSH
58051: LD_VAR 0 1
58055: ARRAY
58056: PUSH
58057: LD_EXP 98
58061: PUSH
58062: LD_VAR 0 1
58066: ARRAY
58067: UNION
58068: PUSH
58069: FOR_IN
58070: IFFALSE 58103
// if GetTag ( i ) = tag then
58072: LD_VAR 0 4
58076: PPUSH
58077: CALL_OW 110
58081: PUSH
58082: LD_VAR 0 2
58086: EQUAL
58087: IFFALSE 58101
// SetTag ( i , 0 ) ;
58089: LD_VAR 0 4
58093: PPUSH
58094: LD_INT 0
58096: PPUSH
58097: CALL_OW 109
58101: GO 58069
58103: POP
58104: POP
// end ;
58105: LD_VAR 0 3
58109: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
58110: LD_INT 0
58112: PPUSH
58113: PPUSH
58114: PPUSH
58115: PPUSH
58116: PPUSH
58117: PPUSH
58118: PPUSH
58119: PPUSH
// if not mc_bases then
58120: LD_EXP 69
58124: NOT
58125: IFFALSE 58129
// exit ;
58127: GO 58587
// for i = 1 to mc_bases do
58129: LD_ADDR_VAR 0 2
58133: PUSH
58134: DOUBLE
58135: LD_INT 1
58137: DEC
58138: ST_TO_ADDR
58139: LD_EXP 69
58143: PUSH
58144: FOR_TO
58145: IFFALSE 58585
// begin tmp := MC_ClassCheckReq ( i ) ;
58147: LD_ADDR_VAR 0 4
58151: PUSH
58152: LD_VAR 0 2
58156: PPUSH
58157: CALL 58592 0 1
58161: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
58162: LD_ADDR_EXP 110
58166: PUSH
58167: LD_EXP 110
58171: PPUSH
58172: LD_VAR 0 2
58176: PPUSH
58177: LD_VAR 0 4
58181: PPUSH
58182: CALL_OW 1
58186: ST_TO_ADDR
// if not tmp then
58187: LD_VAR 0 4
58191: NOT
58192: IFFALSE 58196
// continue ;
58194: GO 58144
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
58196: LD_ADDR_VAR 0 6
58200: PUSH
58201: LD_EXP 69
58205: PUSH
58206: LD_VAR 0 2
58210: ARRAY
58211: PPUSH
58212: LD_INT 2
58214: PUSH
58215: LD_INT 30
58217: PUSH
58218: LD_INT 4
58220: PUSH
58221: EMPTY
58222: LIST
58223: LIST
58224: PUSH
58225: LD_INT 30
58227: PUSH
58228: LD_INT 5
58230: PUSH
58231: EMPTY
58232: LIST
58233: LIST
58234: PUSH
58235: EMPTY
58236: LIST
58237: LIST
58238: LIST
58239: PPUSH
58240: CALL_OW 72
58244: PUSH
58245: LD_EXP 69
58249: PUSH
58250: LD_VAR 0 2
58254: ARRAY
58255: PPUSH
58256: LD_INT 2
58258: PUSH
58259: LD_INT 30
58261: PUSH
58262: LD_INT 0
58264: PUSH
58265: EMPTY
58266: LIST
58267: LIST
58268: PUSH
58269: LD_INT 30
58271: PUSH
58272: LD_INT 1
58274: PUSH
58275: EMPTY
58276: LIST
58277: LIST
58278: PUSH
58279: EMPTY
58280: LIST
58281: LIST
58282: LIST
58283: PPUSH
58284: CALL_OW 72
58288: PUSH
58289: LD_EXP 69
58293: PUSH
58294: LD_VAR 0 2
58298: ARRAY
58299: PPUSH
58300: LD_INT 30
58302: PUSH
58303: LD_INT 3
58305: PUSH
58306: EMPTY
58307: LIST
58308: LIST
58309: PPUSH
58310: CALL_OW 72
58314: PUSH
58315: LD_EXP 69
58319: PUSH
58320: LD_VAR 0 2
58324: ARRAY
58325: PPUSH
58326: LD_INT 2
58328: PUSH
58329: LD_INT 30
58331: PUSH
58332: LD_INT 6
58334: PUSH
58335: EMPTY
58336: LIST
58337: LIST
58338: PUSH
58339: LD_INT 30
58341: PUSH
58342: LD_INT 7
58344: PUSH
58345: EMPTY
58346: LIST
58347: LIST
58348: PUSH
58349: LD_INT 30
58351: PUSH
58352: LD_INT 8
58354: PUSH
58355: EMPTY
58356: LIST
58357: LIST
58358: PUSH
58359: EMPTY
58360: LIST
58361: LIST
58362: LIST
58363: LIST
58364: PPUSH
58365: CALL_OW 72
58369: PUSH
58370: EMPTY
58371: LIST
58372: LIST
58373: LIST
58374: LIST
58375: ST_TO_ADDR
// for j = 1 to 4 do
58376: LD_ADDR_VAR 0 3
58380: PUSH
58381: DOUBLE
58382: LD_INT 1
58384: DEC
58385: ST_TO_ADDR
58386: LD_INT 4
58388: PUSH
58389: FOR_TO
58390: IFFALSE 58581
// begin if not tmp [ j ] then
58392: LD_VAR 0 4
58396: PUSH
58397: LD_VAR 0 3
58401: ARRAY
58402: NOT
58403: IFFALSE 58407
// continue ;
58405: GO 58389
// for p in tmp [ j ] do
58407: LD_ADDR_VAR 0 5
58411: PUSH
58412: LD_VAR 0 4
58416: PUSH
58417: LD_VAR 0 3
58421: ARRAY
58422: PUSH
58423: FOR_IN
58424: IFFALSE 58577
// begin if not b [ j ] then
58426: LD_VAR 0 6
58430: PUSH
58431: LD_VAR 0 3
58435: ARRAY
58436: NOT
58437: IFFALSE 58441
// break ;
58439: GO 58577
// e := 0 ;
58441: LD_ADDR_VAR 0 7
58445: PUSH
58446: LD_INT 0
58448: ST_TO_ADDR
// for k in b [ j ] do
58449: LD_ADDR_VAR 0 8
58453: PUSH
58454: LD_VAR 0 6
58458: PUSH
58459: LD_VAR 0 3
58463: ARRAY
58464: PUSH
58465: FOR_IN
58466: IFFALSE 58493
// if IsNotFull ( k ) then
58468: LD_VAR 0 8
58472: PPUSH
58473: CALL 15818 0 1
58477: IFFALSE 58491
// begin e := k ;
58479: LD_ADDR_VAR 0 7
58483: PUSH
58484: LD_VAR 0 8
58488: ST_TO_ADDR
// break ;
58489: GO 58493
// end ;
58491: GO 58465
58493: POP
58494: POP
// if e and not UnitGoingToBuilding ( p , e ) then
58495: LD_VAR 0 7
58499: PUSH
58500: LD_VAR 0 5
58504: PPUSH
58505: LD_VAR 0 7
58509: PPUSH
58510: CALL 48982 0 2
58514: NOT
58515: AND
58516: IFFALSE 58575
// begin if IsInUnit ( p ) then
58518: LD_VAR 0 5
58522: PPUSH
58523: CALL_OW 310
58527: IFFALSE 58538
// ComExitBuilding ( p ) ;
58529: LD_VAR 0 5
58533: PPUSH
58534: CALL_OW 122
// ComEnterUnit ( p , e ) ;
58538: LD_VAR 0 5
58542: PPUSH
58543: LD_VAR 0 7
58547: PPUSH
58548: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
58552: LD_VAR 0 5
58556: PPUSH
58557: LD_VAR 0 3
58561: PPUSH
58562: CALL_OW 183
// AddComExitBuilding ( p ) ;
58566: LD_VAR 0 5
58570: PPUSH
58571: CALL_OW 182
// end ; end ;
58575: GO 58423
58577: POP
58578: POP
// end ;
58579: GO 58389
58581: POP
58582: POP
// end ;
58583: GO 58144
58585: POP
58586: POP
// end ;
58587: LD_VAR 0 1
58591: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
58592: LD_INT 0
58594: PPUSH
58595: PPUSH
58596: PPUSH
58597: PPUSH
58598: PPUSH
58599: PPUSH
58600: PPUSH
58601: PPUSH
58602: PPUSH
58603: PPUSH
58604: PPUSH
58605: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
58606: LD_VAR 0 1
58610: NOT
58611: PUSH
58612: LD_EXP 69
58616: PUSH
58617: LD_VAR 0 1
58621: ARRAY
58622: NOT
58623: OR
58624: PUSH
58625: LD_EXP 69
58629: PUSH
58630: LD_VAR 0 1
58634: ARRAY
58635: PPUSH
58636: LD_INT 2
58638: PUSH
58639: LD_INT 30
58641: PUSH
58642: LD_INT 0
58644: PUSH
58645: EMPTY
58646: LIST
58647: LIST
58648: PUSH
58649: LD_INT 30
58651: PUSH
58652: LD_INT 1
58654: PUSH
58655: EMPTY
58656: LIST
58657: LIST
58658: PUSH
58659: EMPTY
58660: LIST
58661: LIST
58662: LIST
58663: PPUSH
58664: CALL_OW 72
58668: NOT
58669: OR
58670: IFFALSE 58674
// exit ;
58672: GO 62177
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58674: LD_ADDR_VAR 0 4
58678: PUSH
58679: LD_EXP 69
58683: PUSH
58684: LD_VAR 0 1
58688: ARRAY
58689: PPUSH
58690: LD_INT 2
58692: PUSH
58693: LD_INT 25
58695: PUSH
58696: LD_INT 1
58698: PUSH
58699: EMPTY
58700: LIST
58701: LIST
58702: PUSH
58703: LD_INT 25
58705: PUSH
58706: LD_INT 2
58708: PUSH
58709: EMPTY
58710: LIST
58711: LIST
58712: PUSH
58713: LD_INT 25
58715: PUSH
58716: LD_INT 3
58718: PUSH
58719: EMPTY
58720: LIST
58721: LIST
58722: PUSH
58723: LD_INT 25
58725: PUSH
58726: LD_INT 4
58728: PUSH
58729: EMPTY
58730: LIST
58731: LIST
58732: PUSH
58733: LD_INT 25
58735: PUSH
58736: LD_INT 5
58738: PUSH
58739: EMPTY
58740: LIST
58741: LIST
58742: PUSH
58743: LD_INT 25
58745: PUSH
58746: LD_INT 8
58748: PUSH
58749: EMPTY
58750: LIST
58751: LIST
58752: PUSH
58753: LD_INT 25
58755: PUSH
58756: LD_INT 9
58758: PUSH
58759: EMPTY
58760: LIST
58761: LIST
58762: PUSH
58763: EMPTY
58764: LIST
58765: LIST
58766: LIST
58767: LIST
58768: LIST
58769: LIST
58770: LIST
58771: LIST
58772: PPUSH
58773: CALL_OW 72
58777: ST_TO_ADDR
// if not tmp then
58778: LD_VAR 0 4
58782: NOT
58783: IFFALSE 58787
// exit ;
58785: GO 62177
// for i in tmp do
58787: LD_ADDR_VAR 0 3
58791: PUSH
58792: LD_VAR 0 4
58796: PUSH
58797: FOR_IN
58798: IFFALSE 58829
// if GetTag ( i ) then
58800: LD_VAR 0 3
58804: PPUSH
58805: CALL_OW 110
58809: IFFALSE 58827
// tmp := tmp diff i ;
58811: LD_ADDR_VAR 0 4
58815: PUSH
58816: LD_VAR 0 4
58820: PUSH
58821: LD_VAR 0 3
58825: DIFF
58826: ST_TO_ADDR
58827: GO 58797
58829: POP
58830: POP
// if not tmp then
58831: LD_VAR 0 4
58835: NOT
58836: IFFALSE 58840
// exit ;
58838: GO 62177
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58840: LD_ADDR_VAR 0 5
58844: PUSH
58845: LD_EXP 69
58849: PUSH
58850: LD_VAR 0 1
58854: ARRAY
58855: PPUSH
58856: LD_INT 2
58858: PUSH
58859: LD_INT 25
58861: PUSH
58862: LD_INT 1
58864: PUSH
58865: EMPTY
58866: LIST
58867: LIST
58868: PUSH
58869: LD_INT 25
58871: PUSH
58872: LD_INT 5
58874: PUSH
58875: EMPTY
58876: LIST
58877: LIST
58878: PUSH
58879: LD_INT 25
58881: PUSH
58882: LD_INT 8
58884: PUSH
58885: EMPTY
58886: LIST
58887: LIST
58888: PUSH
58889: LD_INT 25
58891: PUSH
58892: LD_INT 9
58894: PUSH
58895: EMPTY
58896: LIST
58897: LIST
58898: PUSH
58899: EMPTY
58900: LIST
58901: LIST
58902: LIST
58903: LIST
58904: LIST
58905: PPUSH
58906: CALL_OW 72
58910: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
58911: LD_ADDR_VAR 0 6
58915: PUSH
58916: LD_EXP 69
58920: PUSH
58921: LD_VAR 0 1
58925: ARRAY
58926: PPUSH
58927: LD_INT 25
58929: PUSH
58930: LD_INT 2
58932: PUSH
58933: EMPTY
58934: LIST
58935: LIST
58936: PPUSH
58937: CALL_OW 72
58941: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
58942: LD_ADDR_VAR 0 7
58946: PUSH
58947: LD_EXP 69
58951: PUSH
58952: LD_VAR 0 1
58956: ARRAY
58957: PPUSH
58958: LD_INT 25
58960: PUSH
58961: LD_INT 3
58963: PUSH
58964: EMPTY
58965: LIST
58966: LIST
58967: PPUSH
58968: CALL_OW 72
58972: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
58973: LD_ADDR_VAR 0 8
58977: PUSH
58978: LD_EXP 69
58982: PUSH
58983: LD_VAR 0 1
58987: ARRAY
58988: PPUSH
58989: LD_INT 25
58991: PUSH
58992: LD_INT 4
58994: PUSH
58995: EMPTY
58996: LIST
58997: LIST
58998: PUSH
58999: LD_INT 24
59001: PUSH
59002: LD_INT 251
59004: PUSH
59005: EMPTY
59006: LIST
59007: LIST
59008: PUSH
59009: EMPTY
59010: LIST
59011: LIST
59012: PPUSH
59013: CALL_OW 72
59017: ST_TO_ADDR
// if mc_is_defending [ base ] then
59018: LD_EXP 112
59022: PUSH
59023: LD_VAR 0 1
59027: ARRAY
59028: IFFALSE 59489
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
59030: LD_ADDR_EXP 111
59034: PUSH
59035: LD_EXP 111
59039: PPUSH
59040: LD_VAR 0 1
59044: PPUSH
59045: LD_INT 4
59047: PPUSH
59048: CALL_OW 1
59052: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59053: LD_ADDR_VAR 0 12
59057: PUSH
59058: LD_EXP 69
59062: PUSH
59063: LD_VAR 0 1
59067: ARRAY
59068: PPUSH
59069: LD_INT 2
59071: PUSH
59072: LD_INT 30
59074: PUSH
59075: LD_INT 4
59077: PUSH
59078: EMPTY
59079: LIST
59080: LIST
59081: PUSH
59082: LD_INT 30
59084: PUSH
59085: LD_INT 5
59087: PUSH
59088: EMPTY
59089: LIST
59090: LIST
59091: PUSH
59092: EMPTY
59093: LIST
59094: LIST
59095: LIST
59096: PPUSH
59097: CALL_OW 72
59101: ST_TO_ADDR
// if not b then
59102: LD_VAR 0 12
59106: NOT
59107: IFFALSE 59111
// exit ;
59109: GO 62177
// p := [ ] ;
59111: LD_ADDR_VAR 0 11
59115: PUSH
59116: EMPTY
59117: ST_TO_ADDR
// if sci >= 2 then
59118: LD_VAR 0 8
59122: PUSH
59123: LD_INT 2
59125: GREATEREQUAL
59126: IFFALSE 59157
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
59128: LD_ADDR_VAR 0 8
59132: PUSH
59133: LD_VAR 0 8
59137: PUSH
59138: LD_INT 1
59140: ARRAY
59141: PUSH
59142: LD_VAR 0 8
59146: PUSH
59147: LD_INT 2
59149: ARRAY
59150: PUSH
59151: EMPTY
59152: LIST
59153: LIST
59154: ST_TO_ADDR
59155: GO 59218
// if sci = 1 then
59157: LD_VAR 0 8
59161: PUSH
59162: LD_INT 1
59164: EQUAL
59165: IFFALSE 59186
// sci := [ sci [ 1 ] ] else
59167: LD_ADDR_VAR 0 8
59171: PUSH
59172: LD_VAR 0 8
59176: PUSH
59177: LD_INT 1
59179: ARRAY
59180: PUSH
59181: EMPTY
59182: LIST
59183: ST_TO_ADDR
59184: GO 59218
// if sci = 0 then
59186: LD_VAR 0 8
59190: PUSH
59191: LD_INT 0
59193: EQUAL
59194: IFFALSE 59218
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
59196: LD_ADDR_VAR 0 11
59200: PUSH
59201: LD_VAR 0 4
59205: PPUSH
59206: LD_INT 4
59208: PPUSH
59209: CALL 48845 0 2
59213: PUSH
59214: LD_INT 1
59216: ARRAY
59217: ST_TO_ADDR
// if eng > 4 then
59218: LD_VAR 0 6
59222: PUSH
59223: LD_INT 4
59225: GREATER
59226: IFFALSE 59272
// for i = eng downto 4 do
59228: LD_ADDR_VAR 0 3
59232: PUSH
59233: DOUBLE
59234: LD_VAR 0 6
59238: INC
59239: ST_TO_ADDR
59240: LD_INT 4
59242: PUSH
59243: FOR_DOWNTO
59244: IFFALSE 59270
// eng := eng diff eng [ i ] ;
59246: LD_ADDR_VAR 0 6
59250: PUSH
59251: LD_VAR 0 6
59255: PUSH
59256: LD_VAR 0 6
59260: PUSH
59261: LD_VAR 0 3
59265: ARRAY
59266: DIFF
59267: ST_TO_ADDR
59268: GO 59243
59270: POP
59271: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
59272: LD_ADDR_VAR 0 4
59276: PUSH
59277: LD_VAR 0 4
59281: PUSH
59282: LD_VAR 0 5
59286: PUSH
59287: LD_VAR 0 6
59291: UNION
59292: PUSH
59293: LD_VAR 0 7
59297: UNION
59298: PUSH
59299: LD_VAR 0 8
59303: UNION
59304: DIFF
59305: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
59306: LD_ADDR_VAR 0 13
59310: PUSH
59311: LD_EXP 69
59315: PUSH
59316: LD_VAR 0 1
59320: ARRAY
59321: PPUSH
59322: LD_INT 2
59324: PUSH
59325: LD_INT 30
59327: PUSH
59328: LD_INT 32
59330: PUSH
59331: EMPTY
59332: LIST
59333: LIST
59334: PUSH
59335: LD_INT 30
59337: PUSH
59338: LD_INT 31
59340: PUSH
59341: EMPTY
59342: LIST
59343: LIST
59344: PUSH
59345: EMPTY
59346: LIST
59347: LIST
59348: LIST
59349: PPUSH
59350: CALL_OW 72
59354: PUSH
59355: LD_EXP 69
59359: PUSH
59360: LD_VAR 0 1
59364: ARRAY
59365: PPUSH
59366: LD_INT 2
59368: PUSH
59369: LD_INT 30
59371: PUSH
59372: LD_INT 4
59374: PUSH
59375: EMPTY
59376: LIST
59377: LIST
59378: PUSH
59379: LD_INT 30
59381: PUSH
59382: LD_INT 5
59384: PUSH
59385: EMPTY
59386: LIST
59387: LIST
59388: PUSH
59389: EMPTY
59390: LIST
59391: LIST
59392: LIST
59393: PPUSH
59394: CALL_OW 72
59398: PUSH
59399: LD_INT 6
59401: MUL
59402: PLUS
59403: ST_TO_ADDR
// if bcount < tmp then
59404: LD_VAR 0 13
59408: PUSH
59409: LD_VAR 0 4
59413: LESS
59414: IFFALSE 59460
// for i = tmp downto bcount do
59416: LD_ADDR_VAR 0 3
59420: PUSH
59421: DOUBLE
59422: LD_VAR 0 4
59426: INC
59427: ST_TO_ADDR
59428: LD_VAR 0 13
59432: PUSH
59433: FOR_DOWNTO
59434: IFFALSE 59458
// tmp := Delete ( tmp , tmp ) ;
59436: LD_ADDR_VAR 0 4
59440: PUSH
59441: LD_VAR 0 4
59445: PPUSH
59446: LD_VAR 0 4
59450: PPUSH
59451: CALL_OW 3
59455: ST_TO_ADDR
59456: GO 59433
59458: POP
59459: POP
// result := [ tmp , 0 , 0 , p ] ;
59460: LD_ADDR_VAR 0 2
59464: PUSH
59465: LD_VAR 0 4
59469: PUSH
59470: LD_INT 0
59472: PUSH
59473: LD_INT 0
59475: PUSH
59476: LD_VAR 0 11
59480: PUSH
59481: EMPTY
59482: LIST
59483: LIST
59484: LIST
59485: LIST
59486: ST_TO_ADDR
// exit ;
59487: GO 62177
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59489: LD_EXP 69
59493: PUSH
59494: LD_VAR 0 1
59498: ARRAY
59499: PPUSH
59500: LD_INT 2
59502: PUSH
59503: LD_INT 30
59505: PUSH
59506: LD_INT 6
59508: PUSH
59509: EMPTY
59510: LIST
59511: LIST
59512: PUSH
59513: LD_INT 30
59515: PUSH
59516: LD_INT 7
59518: PUSH
59519: EMPTY
59520: LIST
59521: LIST
59522: PUSH
59523: LD_INT 30
59525: PUSH
59526: LD_INT 8
59528: PUSH
59529: EMPTY
59530: LIST
59531: LIST
59532: PUSH
59533: EMPTY
59534: LIST
59535: LIST
59536: LIST
59537: LIST
59538: PPUSH
59539: CALL_OW 72
59543: NOT
59544: PUSH
59545: LD_EXP 69
59549: PUSH
59550: LD_VAR 0 1
59554: ARRAY
59555: PPUSH
59556: LD_INT 30
59558: PUSH
59559: LD_INT 3
59561: PUSH
59562: EMPTY
59563: LIST
59564: LIST
59565: PPUSH
59566: CALL_OW 72
59570: NOT
59571: AND
59572: IFFALSE 59644
// begin if eng = tmp then
59574: LD_VAR 0 6
59578: PUSH
59579: LD_VAR 0 4
59583: EQUAL
59584: IFFALSE 59588
// exit ;
59586: GO 62177
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
59588: LD_ADDR_EXP 111
59592: PUSH
59593: LD_EXP 111
59597: PPUSH
59598: LD_VAR 0 1
59602: PPUSH
59603: LD_INT 1
59605: PPUSH
59606: CALL_OW 1
59610: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
59611: LD_ADDR_VAR 0 2
59615: PUSH
59616: LD_INT 0
59618: PUSH
59619: LD_VAR 0 4
59623: PUSH
59624: LD_VAR 0 6
59628: DIFF
59629: PUSH
59630: LD_INT 0
59632: PUSH
59633: LD_INT 0
59635: PUSH
59636: EMPTY
59637: LIST
59638: LIST
59639: LIST
59640: LIST
59641: ST_TO_ADDR
// exit ;
59642: GO 62177
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59644: LD_EXP 96
59648: PUSH
59649: LD_EXP 95
59653: PUSH
59654: LD_VAR 0 1
59658: ARRAY
59659: ARRAY
59660: PUSH
59661: LD_EXP 69
59665: PUSH
59666: LD_VAR 0 1
59670: ARRAY
59671: PPUSH
59672: LD_INT 2
59674: PUSH
59675: LD_INT 30
59677: PUSH
59678: LD_INT 6
59680: PUSH
59681: EMPTY
59682: LIST
59683: LIST
59684: PUSH
59685: LD_INT 30
59687: PUSH
59688: LD_INT 7
59690: PUSH
59691: EMPTY
59692: LIST
59693: LIST
59694: PUSH
59695: LD_INT 30
59697: PUSH
59698: LD_INT 8
59700: PUSH
59701: EMPTY
59702: LIST
59703: LIST
59704: PUSH
59705: EMPTY
59706: LIST
59707: LIST
59708: LIST
59709: LIST
59710: PPUSH
59711: CALL_OW 72
59715: AND
59716: PUSH
59717: LD_EXP 69
59721: PUSH
59722: LD_VAR 0 1
59726: ARRAY
59727: PPUSH
59728: LD_INT 30
59730: PUSH
59731: LD_INT 3
59733: PUSH
59734: EMPTY
59735: LIST
59736: LIST
59737: PPUSH
59738: CALL_OW 72
59742: NOT
59743: AND
59744: IFFALSE 59958
// begin if sci >= 6 then
59746: LD_VAR 0 8
59750: PUSH
59751: LD_INT 6
59753: GREATEREQUAL
59754: IFFALSE 59758
// exit ;
59756: GO 62177
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
59758: LD_ADDR_EXP 111
59762: PUSH
59763: LD_EXP 111
59767: PPUSH
59768: LD_VAR 0 1
59772: PPUSH
59773: LD_INT 2
59775: PPUSH
59776: CALL_OW 1
59780: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
59781: LD_ADDR_VAR 0 9
59785: PUSH
59786: LD_VAR 0 4
59790: PUSH
59791: LD_VAR 0 8
59795: DIFF
59796: PPUSH
59797: LD_INT 4
59799: PPUSH
59800: CALL 48845 0 2
59804: ST_TO_ADDR
// p := [ ] ;
59805: LD_ADDR_VAR 0 11
59809: PUSH
59810: EMPTY
59811: ST_TO_ADDR
// if sci < 6 and sort > 6 then
59812: LD_VAR 0 8
59816: PUSH
59817: LD_INT 6
59819: LESS
59820: PUSH
59821: LD_VAR 0 9
59825: PUSH
59826: LD_INT 6
59828: GREATER
59829: AND
59830: IFFALSE 59911
// begin for i = 1 to 6 - sci do
59832: LD_ADDR_VAR 0 3
59836: PUSH
59837: DOUBLE
59838: LD_INT 1
59840: DEC
59841: ST_TO_ADDR
59842: LD_INT 6
59844: PUSH
59845: LD_VAR 0 8
59849: MINUS
59850: PUSH
59851: FOR_TO
59852: IFFALSE 59907
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
59854: LD_ADDR_VAR 0 11
59858: PUSH
59859: LD_VAR 0 11
59863: PPUSH
59864: LD_VAR 0 11
59868: PUSH
59869: LD_INT 1
59871: PLUS
59872: PPUSH
59873: LD_VAR 0 9
59877: PUSH
59878: LD_INT 1
59880: ARRAY
59881: PPUSH
59882: CALL_OW 2
59886: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
59887: LD_ADDR_VAR 0 9
59891: PUSH
59892: LD_VAR 0 9
59896: PPUSH
59897: LD_INT 1
59899: PPUSH
59900: CALL_OW 3
59904: ST_TO_ADDR
// end ;
59905: GO 59851
59907: POP
59908: POP
// end else
59909: GO 59931
// if sort then
59911: LD_VAR 0 9
59915: IFFALSE 59931
// p := sort [ 1 ] ;
59917: LD_ADDR_VAR 0 11
59921: PUSH
59922: LD_VAR 0 9
59926: PUSH
59927: LD_INT 1
59929: ARRAY
59930: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
59931: LD_ADDR_VAR 0 2
59935: PUSH
59936: LD_INT 0
59938: PUSH
59939: LD_INT 0
59941: PUSH
59942: LD_INT 0
59944: PUSH
59945: LD_VAR 0 11
59949: PUSH
59950: EMPTY
59951: LIST
59952: LIST
59953: LIST
59954: LIST
59955: ST_TO_ADDR
// exit ;
59956: GO 62177
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59958: LD_EXP 96
59962: PUSH
59963: LD_EXP 95
59967: PUSH
59968: LD_VAR 0 1
59972: ARRAY
59973: ARRAY
59974: PUSH
59975: LD_EXP 69
59979: PUSH
59980: LD_VAR 0 1
59984: ARRAY
59985: PPUSH
59986: LD_INT 2
59988: PUSH
59989: LD_INT 30
59991: PUSH
59992: LD_INT 6
59994: PUSH
59995: EMPTY
59996: LIST
59997: LIST
59998: PUSH
59999: LD_INT 30
60001: PUSH
60002: LD_INT 7
60004: PUSH
60005: EMPTY
60006: LIST
60007: LIST
60008: PUSH
60009: LD_INT 30
60011: PUSH
60012: LD_INT 8
60014: PUSH
60015: EMPTY
60016: LIST
60017: LIST
60018: PUSH
60019: EMPTY
60020: LIST
60021: LIST
60022: LIST
60023: LIST
60024: PPUSH
60025: CALL_OW 72
60029: AND
60030: PUSH
60031: LD_EXP 69
60035: PUSH
60036: LD_VAR 0 1
60040: ARRAY
60041: PPUSH
60042: LD_INT 30
60044: PUSH
60045: LD_INT 3
60047: PUSH
60048: EMPTY
60049: LIST
60050: LIST
60051: PPUSH
60052: CALL_OW 72
60056: AND
60057: IFFALSE 60791
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
60059: LD_ADDR_EXP 111
60063: PUSH
60064: LD_EXP 111
60068: PPUSH
60069: LD_VAR 0 1
60073: PPUSH
60074: LD_INT 3
60076: PPUSH
60077: CALL_OW 1
60081: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60082: LD_ADDR_VAR 0 2
60086: PUSH
60087: LD_INT 0
60089: PUSH
60090: LD_INT 0
60092: PUSH
60093: LD_INT 0
60095: PUSH
60096: LD_INT 0
60098: PUSH
60099: EMPTY
60100: LIST
60101: LIST
60102: LIST
60103: LIST
60104: ST_TO_ADDR
// if not eng then
60105: LD_VAR 0 6
60109: NOT
60110: IFFALSE 60173
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
60112: LD_ADDR_VAR 0 11
60116: PUSH
60117: LD_VAR 0 4
60121: PPUSH
60122: LD_INT 2
60124: PPUSH
60125: CALL 48845 0 2
60129: PUSH
60130: LD_INT 1
60132: ARRAY
60133: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
60134: LD_ADDR_VAR 0 2
60138: PUSH
60139: LD_VAR 0 2
60143: PPUSH
60144: LD_INT 2
60146: PPUSH
60147: LD_VAR 0 11
60151: PPUSH
60152: CALL_OW 1
60156: ST_TO_ADDR
// tmp := tmp diff p ;
60157: LD_ADDR_VAR 0 4
60161: PUSH
60162: LD_VAR 0 4
60166: PUSH
60167: LD_VAR 0 11
60171: DIFF
60172: ST_TO_ADDR
// end ; if tmp and sci < 6 then
60173: LD_VAR 0 4
60177: PUSH
60178: LD_VAR 0 8
60182: PUSH
60183: LD_INT 6
60185: LESS
60186: AND
60187: IFFALSE 60375
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
60189: LD_ADDR_VAR 0 9
60193: PUSH
60194: LD_VAR 0 4
60198: PUSH
60199: LD_VAR 0 8
60203: PUSH
60204: LD_VAR 0 7
60208: UNION
60209: DIFF
60210: PPUSH
60211: LD_INT 4
60213: PPUSH
60214: CALL 48845 0 2
60218: ST_TO_ADDR
// p := [ ] ;
60219: LD_ADDR_VAR 0 11
60223: PUSH
60224: EMPTY
60225: ST_TO_ADDR
// if sort then
60226: LD_VAR 0 9
60230: IFFALSE 60346
// for i = 1 to 6 - sci do
60232: LD_ADDR_VAR 0 3
60236: PUSH
60237: DOUBLE
60238: LD_INT 1
60240: DEC
60241: ST_TO_ADDR
60242: LD_INT 6
60244: PUSH
60245: LD_VAR 0 8
60249: MINUS
60250: PUSH
60251: FOR_TO
60252: IFFALSE 60344
// begin if i = sort then
60254: LD_VAR 0 3
60258: PUSH
60259: LD_VAR 0 9
60263: EQUAL
60264: IFFALSE 60268
// break ;
60266: GO 60344
// if GetClass ( i ) = 4 then
60268: LD_VAR 0 3
60272: PPUSH
60273: CALL_OW 257
60277: PUSH
60278: LD_INT 4
60280: EQUAL
60281: IFFALSE 60285
// continue ;
60283: GO 60251
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60285: LD_ADDR_VAR 0 11
60289: PUSH
60290: LD_VAR 0 11
60294: PPUSH
60295: LD_VAR 0 11
60299: PUSH
60300: LD_INT 1
60302: PLUS
60303: PPUSH
60304: LD_VAR 0 9
60308: PUSH
60309: LD_VAR 0 3
60313: ARRAY
60314: PPUSH
60315: CALL_OW 2
60319: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60320: LD_ADDR_VAR 0 4
60324: PUSH
60325: LD_VAR 0 4
60329: PUSH
60330: LD_VAR 0 9
60334: PUSH
60335: LD_VAR 0 3
60339: ARRAY
60340: DIFF
60341: ST_TO_ADDR
// end ;
60342: GO 60251
60344: POP
60345: POP
// if p then
60346: LD_VAR 0 11
60350: IFFALSE 60375
// result := Replace ( result , 4 , p ) ;
60352: LD_ADDR_VAR 0 2
60356: PUSH
60357: LD_VAR 0 2
60361: PPUSH
60362: LD_INT 4
60364: PPUSH
60365: LD_VAR 0 11
60369: PPUSH
60370: CALL_OW 1
60374: ST_TO_ADDR
// end ; if tmp and mech < 6 then
60375: LD_VAR 0 4
60379: PUSH
60380: LD_VAR 0 7
60384: PUSH
60385: LD_INT 6
60387: LESS
60388: AND
60389: IFFALSE 60577
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
60391: LD_ADDR_VAR 0 9
60395: PUSH
60396: LD_VAR 0 4
60400: PUSH
60401: LD_VAR 0 8
60405: PUSH
60406: LD_VAR 0 7
60410: UNION
60411: DIFF
60412: PPUSH
60413: LD_INT 3
60415: PPUSH
60416: CALL 48845 0 2
60420: ST_TO_ADDR
// p := [ ] ;
60421: LD_ADDR_VAR 0 11
60425: PUSH
60426: EMPTY
60427: ST_TO_ADDR
// if sort then
60428: LD_VAR 0 9
60432: IFFALSE 60548
// for i = 1 to 6 - mech do
60434: LD_ADDR_VAR 0 3
60438: PUSH
60439: DOUBLE
60440: LD_INT 1
60442: DEC
60443: ST_TO_ADDR
60444: LD_INT 6
60446: PUSH
60447: LD_VAR 0 7
60451: MINUS
60452: PUSH
60453: FOR_TO
60454: IFFALSE 60546
// begin if i = sort then
60456: LD_VAR 0 3
60460: PUSH
60461: LD_VAR 0 9
60465: EQUAL
60466: IFFALSE 60470
// break ;
60468: GO 60546
// if GetClass ( i ) = 3 then
60470: LD_VAR 0 3
60474: PPUSH
60475: CALL_OW 257
60479: PUSH
60480: LD_INT 3
60482: EQUAL
60483: IFFALSE 60487
// continue ;
60485: GO 60453
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60487: LD_ADDR_VAR 0 11
60491: PUSH
60492: LD_VAR 0 11
60496: PPUSH
60497: LD_VAR 0 11
60501: PUSH
60502: LD_INT 1
60504: PLUS
60505: PPUSH
60506: LD_VAR 0 9
60510: PUSH
60511: LD_VAR 0 3
60515: ARRAY
60516: PPUSH
60517: CALL_OW 2
60521: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60522: LD_ADDR_VAR 0 4
60526: PUSH
60527: LD_VAR 0 4
60531: PUSH
60532: LD_VAR 0 9
60536: PUSH
60537: LD_VAR 0 3
60541: ARRAY
60542: DIFF
60543: ST_TO_ADDR
// end ;
60544: GO 60453
60546: POP
60547: POP
// if p then
60548: LD_VAR 0 11
60552: IFFALSE 60577
// result := Replace ( result , 3 , p ) ;
60554: LD_ADDR_VAR 0 2
60558: PUSH
60559: LD_VAR 0 2
60563: PPUSH
60564: LD_INT 3
60566: PPUSH
60567: LD_VAR 0 11
60571: PPUSH
60572: CALL_OW 1
60576: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
60577: LD_VAR 0 4
60581: PUSH
60582: LD_INT 6
60584: GREATER
60585: PUSH
60586: LD_VAR 0 6
60590: PUSH
60591: LD_INT 6
60593: LESS
60594: AND
60595: IFFALSE 60789
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
60597: LD_ADDR_VAR 0 9
60601: PUSH
60602: LD_VAR 0 4
60606: PUSH
60607: LD_VAR 0 8
60611: PUSH
60612: LD_VAR 0 7
60616: UNION
60617: PUSH
60618: LD_VAR 0 6
60622: UNION
60623: DIFF
60624: PPUSH
60625: LD_INT 2
60627: PPUSH
60628: CALL 48845 0 2
60632: ST_TO_ADDR
// p := [ ] ;
60633: LD_ADDR_VAR 0 11
60637: PUSH
60638: EMPTY
60639: ST_TO_ADDR
// if sort then
60640: LD_VAR 0 9
60644: IFFALSE 60760
// for i = 1 to 6 - eng do
60646: LD_ADDR_VAR 0 3
60650: PUSH
60651: DOUBLE
60652: LD_INT 1
60654: DEC
60655: ST_TO_ADDR
60656: LD_INT 6
60658: PUSH
60659: LD_VAR 0 6
60663: MINUS
60664: PUSH
60665: FOR_TO
60666: IFFALSE 60758
// begin if i = sort then
60668: LD_VAR 0 3
60672: PUSH
60673: LD_VAR 0 9
60677: EQUAL
60678: IFFALSE 60682
// break ;
60680: GO 60758
// if GetClass ( i ) = 2 then
60682: LD_VAR 0 3
60686: PPUSH
60687: CALL_OW 257
60691: PUSH
60692: LD_INT 2
60694: EQUAL
60695: IFFALSE 60699
// continue ;
60697: GO 60665
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60699: LD_ADDR_VAR 0 11
60703: PUSH
60704: LD_VAR 0 11
60708: PPUSH
60709: LD_VAR 0 11
60713: PUSH
60714: LD_INT 1
60716: PLUS
60717: PPUSH
60718: LD_VAR 0 9
60722: PUSH
60723: LD_VAR 0 3
60727: ARRAY
60728: PPUSH
60729: CALL_OW 2
60733: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60734: LD_ADDR_VAR 0 4
60738: PUSH
60739: LD_VAR 0 4
60743: PUSH
60744: LD_VAR 0 9
60748: PUSH
60749: LD_VAR 0 3
60753: ARRAY
60754: DIFF
60755: ST_TO_ADDR
// end ;
60756: GO 60665
60758: POP
60759: POP
// if p then
60760: LD_VAR 0 11
60764: IFFALSE 60789
// result := Replace ( result , 2 , p ) ;
60766: LD_ADDR_VAR 0 2
60770: PUSH
60771: LD_VAR 0 2
60775: PPUSH
60776: LD_INT 2
60778: PPUSH
60779: LD_VAR 0 11
60783: PPUSH
60784: CALL_OW 1
60788: ST_TO_ADDR
// end ; exit ;
60789: GO 62177
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
60791: LD_EXP 96
60795: PUSH
60796: LD_EXP 95
60800: PUSH
60801: LD_VAR 0 1
60805: ARRAY
60806: ARRAY
60807: NOT
60808: PUSH
60809: LD_EXP 69
60813: PUSH
60814: LD_VAR 0 1
60818: ARRAY
60819: PPUSH
60820: LD_INT 30
60822: PUSH
60823: LD_INT 3
60825: PUSH
60826: EMPTY
60827: LIST
60828: LIST
60829: PPUSH
60830: CALL_OW 72
60834: AND
60835: PUSH
60836: LD_EXP 74
60840: PUSH
60841: LD_VAR 0 1
60845: ARRAY
60846: AND
60847: IFFALSE 61455
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
60849: LD_ADDR_EXP 111
60853: PUSH
60854: LD_EXP 111
60858: PPUSH
60859: LD_VAR 0 1
60863: PPUSH
60864: LD_INT 5
60866: PPUSH
60867: CALL_OW 1
60871: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60872: LD_ADDR_VAR 0 2
60876: PUSH
60877: LD_INT 0
60879: PUSH
60880: LD_INT 0
60882: PUSH
60883: LD_INT 0
60885: PUSH
60886: LD_INT 0
60888: PUSH
60889: EMPTY
60890: LIST
60891: LIST
60892: LIST
60893: LIST
60894: ST_TO_ADDR
// if sci > 1 then
60895: LD_VAR 0 8
60899: PUSH
60900: LD_INT 1
60902: GREATER
60903: IFFALSE 60931
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
60905: LD_ADDR_VAR 0 4
60909: PUSH
60910: LD_VAR 0 4
60914: PUSH
60915: LD_VAR 0 8
60919: PUSH
60920: LD_VAR 0 8
60924: PUSH
60925: LD_INT 1
60927: ARRAY
60928: DIFF
60929: DIFF
60930: ST_TO_ADDR
// if tmp and not sci then
60931: LD_VAR 0 4
60935: PUSH
60936: LD_VAR 0 8
60940: NOT
60941: AND
60942: IFFALSE 61011
// begin sort := SortBySkill ( tmp , 4 ) ;
60944: LD_ADDR_VAR 0 9
60948: PUSH
60949: LD_VAR 0 4
60953: PPUSH
60954: LD_INT 4
60956: PPUSH
60957: CALL 48845 0 2
60961: ST_TO_ADDR
// if sort then
60962: LD_VAR 0 9
60966: IFFALSE 60982
// p := sort [ 1 ] ;
60968: LD_ADDR_VAR 0 11
60972: PUSH
60973: LD_VAR 0 9
60977: PUSH
60978: LD_INT 1
60980: ARRAY
60981: ST_TO_ADDR
// if p then
60982: LD_VAR 0 11
60986: IFFALSE 61011
// result := Replace ( result , 4 , p ) ;
60988: LD_ADDR_VAR 0 2
60992: PUSH
60993: LD_VAR 0 2
60997: PPUSH
60998: LD_INT 4
61000: PPUSH
61001: LD_VAR 0 11
61005: PPUSH
61006: CALL_OW 1
61010: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61011: LD_ADDR_VAR 0 4
61015: PUSH
61016: LD_VAR 0 4
61020: PUSH
61021: LD_VAR 0 7
61025: DIFF
61026: ST_TO_ADDR
// if tmp and mech < 6 then
61027: LD_VAR 0 4
61031: PUSH
61032: LD_VAR 0 7
61036: PUSH
61037: LD_INT 6
61039: LESS
61040: AND
61041: IFFALSE 61229
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61043: LD_ADDR_VAR 0 9
61047: PUSH
61048: LD_VAR 0 4
61052: PUSH
61053: LD_VAR 0 8
61057: PUSH
61058: LD_VAR 0 7
61062: UNION
61063: DIFF
61064: PPUSH
61065: LD_INT 3
61067: PPUSH
61068: CALL 48845 0 2
61072: ST_TO_ADDR
// p := [ ] ;
61073: LD_ADDR_VAR 0 11
61077: PUSH
61078: EMPTY
61079: ST_TO_ADDR
// if sort then
61080: LD_VAR 0 9
61084: IFFALSE 61200
// for i = 1 to 6 - mech do
61086: LD_ADDR_VAR 0 3
61090: PUSH
61091: DOUBLE
61092: LD_INT 1
61094: DEC
61095: ST_TO_ADDR
61096: LD_INT 6
61098: PUSH
61099: LD_VAR 0 7
61103: MINUS
61104: PUSH
61105: FOR_TO
61106: IFFALSE 61198
// begin if i = sort then
61108: LD_VAR 0 3
61112: PUSH
61113: LD_VAR 0 9
61117: EQUAL
61118: IFFALSE 61122
// break ;
61120: GO 61198
// if GetClass ( i ) = 3 then
61122: LD_VAR 0 3
61126: PPUSH
61127: CALL_OW 257
61131: PUSH
61132: LD_INT 3
61134: EQUAL
61135: IFFALSE 61139
// continue ;
61137: GO 61105
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61139: LD_ADDR_VAR 0 11
61143: PUSH
61144: LD_VAR 0 11
61148: PPUSH
61149: LD_VAR 0 11
61153: PUSH
61154: LD_INT 1
61156: PLUS
61157: PPUSH
61158: LD_VAR 0 9
61162: PUSH
61163: LD_VAR 0 3
61167: ARRAY
61168: PPUSH
61169: CALL_OW 2
61173: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61174: LD_ADDR_VAR 0 4
61178: PUSH
61179: LD_VAR 0 4
61183: PUSH
61184: LD_VAR 0 9
61188: PUSH
61189: LD_VAR 0 3
61193: ARRAY
61194: DIFF
61195: ST_TO_ADDR
// end ;
61196: GO 61105
61198: POP
61199: POP
// if p then
61200: LD_VAR 0 11
61204: IFFALSE 61229
// result := Replace ( result , 3 , p ) ;
61206: LD_ADDR_VAR 0 2
61210: PUSH
61211: LD_VAR 0 2
61215: PPUSH
61216: LD_INT 3
61218: PPUSH
61219: LD_VAR 0 11
61223: PPUSH
61224: CALL_OW 1
61228: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61229: LD_ADDR_VAR 0 4
61233: PUSH
61234: LD_VAR 0 4
61238: PUSH
61239: LD_VAR 0 6
61243: DIFF
61244: ST_TO_ADDR
// if tmp and eng < 6 then
61245: LD_VAR 0 4
61249: PUSH
61250: LD_VAR 0 6
61254: PUSH
61255: LD_INT 6
61257: LESS
61258: AND
61259: IFFALSE 61453
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61261: LD_ADDR_VAR 0 9
61265: PUSH
61266: LD_VAR 0 4
61270: PUSH
61271: LD_VAR 0 8
61275: PUSH
61276: LD_VAR 0 7
61280: UNION
61281: PUSH
61282: LD_VAR 0 6
61286: UNION
61287: DIFF
61288: PPUSH
61289: LD_INT 2
61291: PPUSH
61292: CALL 48845 0 2
61296: ST_TO_ADDR
// p := [ ] ;
61297: LD_ADDR_VAR 0 11
61301: PUSH
61302: EMPTY
61303: ST_TO_ADDR
// if sort then
61304: LD_VAR 0 9
61308: IFFALSE 61424
// for i = 1 to 6 - eng do
61310: LD_ADDR_VAR 0 3
61314: PUSH
61315: DOUBLE
61316: LD_INT 1
61318: DEC
61319: ST_TO_ADDR
61320: LD_INT 6
61322: PUSH
61323: LD_VAR 0 6
61327: MINUS
61328: PUSH
61329: FOR_TO
61330: IFFALSE 61422
// begin if i = sort then
61332: LD_VAR 0 3
61336: PUSH
61337: LD_VAR 0 9
61341: EQUAL
61342: IFFALSE 61346
// break ;
61344: GO 61422
// if GetClass ( i ) = 2 then
61346: LD_VAR 0 3
61350: PPUSH
61351: CALL_OW 257
61355: PUSH
61356: LD_INT 2
61358: EQUAL
61359: IFFALSE 61363
// continue ;
61361: GO 61329
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61363: LD_ADDR_VAR 0 11
61367: PUSH
61368: LD_VAR 0 11
61372: PPUSH
61373: LD_VAR 0 11
61377: PUSH
61378: LD_INT 1
61380: PLUS
61381: PPUSH
61382: LD_VAR 0 9
61386: PUSH
61387: LD_VAR 0 3
61391: ARRAY
61392: PPUSH
61393: CALL_OW 2
61397: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61398: LD_ADDR_VAR 0 4
61402: PUSH
61403: LD_VAR 0 4
61407: PUSH
61408: LD_VAR 0 9
61412: PUSH
61413: LD_VAR 0 3
61417: ARRAY
61418: DIFF
61419: ST_TO_ADDR
// end ;
61420: GO 61329
61422: POP
61423: POP
// if p then
61424: LD_VAR 0 11
61428: IFFALSE 61453
// result := Replace ( result , 2 , p ) ;
61430: LD_ADDR_VAR 0 2
61434: PUSH
61435: LD_VAR 0 2
61439: PPUSH
61440: LD_INT 2
61442: PPUSH
61443: LD_VAR 0 11
61447: PPUSH
61448: CALL_OW 1
61452: ST_TO_ADDR
// end ; exit ;
61453: GO 62177
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
61455: LD_EXP 96
61459: PUSH
61460: LD_EXP 95
61464: PUSH
61465: LD_VAR 0 1
61469: ARRAY
61470: ARRAY
61471: NOT
61472: PUSH
61473: LD_EXP 69
61477: PUSH
61478: LD_VAR 0 1
61482: ARRAY
61483: PPUSH
61484: LD_INT 30
61486: PUSH
61487: LD_INT 3
61489: PUSH
61490: EMPTY
61491: LIST
61492: LIST
61493: PPUSH
61494: CALL_OW 72
61498: AND
61499: PUSH
61500: LD_EXP 74
61504: PUSH
61505: LD_VAR 0 1
61509: ARRAY
61510: NOT
61511: AND
61512: IFFALSE 62177
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
61514: LD_ADDR_EXP 111
61518: PUSH
61519: LD_EXP 111
61523: PPUSH
61524: LD_VAR 0 1
61528: PPUSH
61529: LD_INT 6
61531: PPUSH
61532: CALL_OW 1
61536: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61537: LD_ADDR_VAR 0 2
61541: PUSH
61542: LD_INT 0
61544: PUSH
61545: LD_INT 0
61547: PUSH
61548: LD_INT 0
61550: PUSH
61551: LD_INT 0
61553: PUSH
61554: EMPTY
61555: LIST
61556: LIST
61557: LIST
61558: LIST
61559: ST_TO_ADDR
// if sci >= 1 then
61560: LD_VAR 0 8
61564: PUSH
61565: LD_INT 1
61567: GREATEREQUAL
61568: IFFALSE 61590
// tmp := tmp diff sci [ 1 ] ;
61570: LD_ADDR_VAR 0 4
61574: PUSH
61575: LD_VAR 0 4
61579: PUSH
61580: LD_VAR 0 8
61584: PUSH
61585: LD_INT 1
61587: ARRAY
61588: DIFF
61589: ST_TO_ADDR
// if tmp and not sci then
61590: LD_VAR 0 4
61594: PUSH
61595: LD_VAR 0 8
61599: NOT
61600: AND
61601: IFFALSE 61670
// begin sort := SortBySkill ( tmp , 4 ) ;
61603: LD_ADDR_VAR 0 9
61607: PUSH
61608: LD_VAR 0 4
61612: PPUSH
61613: LD_INT 4
61615: PPUSH
61616: CALL 48845 0 2
61620: ST_TO_ADDR
// if sort then
61621: LD_VAR 0 9
61625: IFFALSE 61641
// p := sort [ 1 ] ;
61627: LD_ADDR_VAR 0 11
61631: PUSH
61632: LD_VAR 0 9
61636: PUSH
61637: LD_INT 1
61639: ARRAY
61640: ST_TO_ADDR
// if p then
61641: LD_VAR 0 11
61645: IFFALSE 61670
// result := Replace ( result , 4 , p ) ;
61647: LD_ADDR_VAR 0 2
61651: PUSH
61652: LD_VAR 0 2
61656: PPUSH
61657: LD_INT 4
61659: PPUSH
61660: LD_VAR 0 11
61664: PPUSH
61665: CALL_OW 1
61669: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61670: LD_ADDR_VAR 0 4
61674: PUSH
61675: LD_VAR 0 4
61679: PUSH
61680: LD_VAR 0 7
61684: DIFF
61685: ST_TO_ADDR
// if tmp and mech < 6 then
61686: LD_VAR 0 4
61690: PUSH
61691: LD_VAR 0 7
61695: PUSH
61696: LD_INT 6
61698: LESS
61699: AND
61700: IFFALSE 61882
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
61702: LD_ADDR_VAR 0 9
61706: PUSH
61707: LD_VAR 0 4
61711: PUSH
61712: LD_VAR 0 7
61716: DIFF
61717: PPUSH
61718: LD_INT 3
61720: PPUSH
61721: CALL 48845 0 2
61725: ST_TO_ADDR
// p := [ ] ;
61726: LD_ADDR_VAR 0 11
61730: PUSH
61731: EMPTY
61732: ST_TO_ADDR
// if sort then
61733: LD_VAR 0 9
61737: IFFALSE 61853
// for i = 1 to 6 - mech do
61739: LD_ADDR_VAR 0 3
61743: PUSH
61744: DOUBLE
61745: LD_INT 1
61747: DEC
61748: ST_TO_ADDR
61749: LD_INT 6
61751: PUSH
61752: LD_VAR 0 7
61756: MINUS
61757: PUSH
61758: FOR_TO
61759: IFFALSE 61851
// begin if i = sort then
61761: LD_VAR 0 3
61765: PUSH
61766: LD_VAR 0 9
61770: EQUAL
61771: IFFALSE 61775
// break ;
61773: GO 61851
// if GetClass ( i ) = 3 then
61775: LD_VAR 0 3
61779: PPUSH
61780: CALL_OW 257
61784: PUSH
61785: LD_INT 3
61787: EQUAL
61788: IFFALSE 61792
// continue ;
61790: GO 61758
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61792: LD_ADDR_VAR 0 11
61796: PUSH
61797: LD_VAR 0 11
61801: PPUSH
61802: LD_VAR 0 11
61806: PUSH
61807: LD_INT 1
61809: PLUS
61810: PPUSH
61811: LD_VAR 0 9
61815: PUSH
61816: LD_VAR 0 3
61820: ARRAY
61821: PPUSH
61822: CALL_OW 2
61826: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61827: LD_ADDR_VAR 0 4
61831: PUSH
61832: LD_VAR 0 4
61836: PUSH
61837: LD_VAR 0 9
61841: PUSH
61842: LD_VAR 0 3
61846: ARRAY
61847: DIFF
61848: ST_TO_ADDR
// end ;
61849: GO 61758
61851: POP
61852: POP
// if p then
61853: LD_VAR 0 11
61857: IFFALSE 61882
// result := Replace ( result , 3 , p ) ;
61859: LD_ADDR_VAR 0 2
61863: PUSH
61864: LD_VAR 0 2
61868: PPUSH
61869: LD_INT 3
61871: PPUSH
61872: LD_VAR 0 11
61876: PPUSH
61877: CALL_OW 1
61881: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61882: LD_ADDR_VAR 0 4
61886: PUSH
61887: LD_VAR 0 4
61891: PUSH
61892: LD_VAR 0 6
61896: DIFF
61897: ST_TO_ADDR
// if tmp and eng < 4 then
61898: LD_VAR 0 4
61902: PUSH
61903: LD_VAR 0 6
61907: PUSH
61908: LD_INT 4
61910: LESS
61911: AND
61912: IFFALSE 62102
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
61914: LD_ADDR_VAR 0 9
61918: PUSH
61919: LD_VAR 0 4
61923: PUSH
61924: LD_VAR 0 7
61928: PUSH
61929: LD_VAR 0 6
61933: UNION
61934: DIFF
61935: PPUSH
61936: LD_INT 2
61938: PPUSH
61939: CALL 48845 0 2
61943: ST_TO_ADDR
// p := [ ] ;
61944: LD_ADDR_VAR 0 11
61948: PUSH
61949: EMPTY
61950: ST_TO_ADDR
// if sort then
61951: LD_VAR 0 9
61955: IFFALSE 62071
// for i = 1 to 4 - eng do
61957: LD_ADDR_VAR 0 3
61961: PUSH
61962: DOUBLE
61963: LD_INT 1
61965: DEC
61966: ST_TO_ADDR
61967: LD_INT 4
61969: PUSH
61970: LD_VAR 0 6
61974: MINUS
61975: PUSH
61976: FOR_TO
61977: IFFALSE 62069
// begin if i = sort then
61979: LD_VAR 0 3
61983: PUSH
61984: LD_VAR 0 9
61988: EQUAL
61989: IFFALSE 61993
// break ;
61991: GO 62069
// if GetClass ( i ) = 2 then
61993: LD_VAR 0 3
61997: PPUSH
61998: CALL_OW 257
62002: PUSH
62003: LD_INT 2
62005: EQUAL
62006: IFFALSE 62010
// continue ;
62008: GO 61976
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62010: LD_ADDR_VAR 0 11
62014: PUSH
62015: LD_VAR 0 11
62019: PPUSH
62020: LD_VAR 0 11
62024: PUSH
62025: LD_INT 1
62027: PLUS
62028: PPUSH
62029: LD_VAR 0 9
62033: PUSH
62034: LD_VAR 0 3
62038: ARRAY
62039: PPUSH
62040: CALL_OW 2
62044: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62045: LD_ADDR_VAR 0 4
62049: PUSH
62050: LD_VAR 0 4
62054: PUSH
62055: LD_VAR 0 9
62059: PUSH
62060: LD_VAR 0 3
62064: ARRAY
62065: DIFF
62066: ST_TO_ADDR
// end ;
62067: GO 61976
62069: POP
62070: POP
// if p then
62071: LD_VAR 0 11
62075: IFFALSE 62100
// result := Replace ( result , 2 , p ) ;
62077: LD_ADDR_VAR 0 2
62081: PUSH
62082: LD_VAR 0 2
62086: PPUSH
62087: LD_INT 2
62089: PPUSH
62090: LD_VAR 0 11
62094: PPUSH
62095: CALL_OW 1
62099: ST_TO_ADDR
// end else
62100: GO 62146
// for i = eng downto 5 do
62102: LD_ADDR_VAR 0 3
62106: PUSH
62107: DOUBLE
62108: LD_VAR 0 6
62112: INC
62113: ST_TO_ADDR
62114: LD_INT 5
62116: PUSH
62117: FOR_DOWNTO
62118: IFFALSE 62144
// tmp := tmp union eng [ i ] ;
62120: LD_ADDR_VAR 0 4
62124: PUSH
62125: LD_VAR 0 4
62129: PUSH
62130: LD_VAR 0 6
62134: PUSH
62135: LD_VAR 0 3
62139: ARRAY
62140: UNION
62141: ST_TO_ADDR
62142: GO 62117
62144: POP
62145: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
62146: LD_ADDR_VAR 0 2
62150: PUSH
62151: LD_VAR 0 2
62155: PPUSH
62156: LD_INT 1
62158: PPUSH
62159: LD_VAR 0 4
62163: PUSH
62164: LD_VAR 0 5
62168: DIFF
62169: PPUSH
62170: CALL_OW 1
62174: ST_TO_ADDR
// exit ;
62175: GO 62177
// end ; end ;
62177: LD_VAR 0 2
62181: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
62182: LD_INT 0
62184: PPUSH
62185: PPUSH
62186: PPUSH
// if not mc_bases then
62187: LD_EXP 69
62191: NOT
62192: IFFALSE 62196
// exit ;
62194: GO 62338
// for i = 1 to mc_bases do
62196: LD_ADDR_VAR 0 2
62200: PUSH
62201: DOUBLE
62202: LD_INT 1
62204: DEC
62205: ST_TO_ADDR
62206: LD_EXP 69
62210: PUSH
62211: FOR_TO
62212: IFFALSE 62329
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
62214: LD_ADDR_VAR 0 3
62218: PUSH
62219: LD_EXP 69
62223: PUSH
62224: LD_VAR 0 2
62228: ARRAY
62229: PPUSH
62230: LD_INT 21
62232: PUSH
62233: LD_INT 3
62235: PUSH
62236: EMPTY
62237: LIST
62238: LIST
62239: PUSH
62240: LD_INT 3
62242: PUSH
62243: LD_INT 2
62245: PUSH
62246: LD_INT 30
62248: PUSH
62249: LD_INT 29
62251: PUSH
62252: EMPTY
62253: LIST
62254: LIST
62255: PUSH
62256: LD_INT 30
62258: PUSH
62259: LD_INT 30
62261: PUSH
62262: EMPTY
62263: LIST
62264: LIST
62265: PUSH
62266: EMPTY
62267: LIST
62268: LIST
62269: LIST
62270: PUSH
62271: EMPTY
62272: LIST
62273: LIST
62274: PUSH
62275: LD_INT 3
62277: PUSH
62278: LD_INT 24
62280: PUSH
62281: LD_INT 1000
62283: PUSH
62284: EMPTY
62285: LIST
62286: LIST
62287: PUSH
62288: EMPTY
62289: LIST
62290: LIST
62291: PUSH
62292: EMPTY
62293: LIST
62294: LIST
62295: LIST
62296: PPUSH
62297: CALL_OW 72
62301: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
62302: LD_ADDR_EXP 70
62306: PUSH
62307: LD_EXP 70
62311: PPUSH
62312: LD_VAR 0 2
62316: PPUSH
62317: LD_VAR 0 3
62321: PPUSH
62322: CALL_OW 1
62326: ST_TO_ADDR
// end ;
62327: GO 62211
62329: POP
62330: POP
// RaiseSailEvent ( 101 ) ;
62331: LD_INT 101
62333: PPUSH
62334: CALL_OW 427
// end ;
62338: LD_VAR 0 1
62342: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
62343: LD_INT 0
62345: PPUSH
62346: PPUSH
62347: PPUSH
62348: PPUSH
62349: PPUSH
62350: PPUSH
62351: PPUSH
// if not mc_bases then
62352: LD_EXP 69
62356: NOT
62357: IFFALSE 62361
// exit ;
62359: GO 62923
// for i = 1 to mc_bases do
62361: LD_ADDR_VAR 0 2
62365: PUSH
62366: DOUBLE
62367: LD_INT 1
62369: DEC
62370: ST_TO_ADDR
62371: LD_EXP 69
62375: PUSH
62376: FOR_TO
62377: IFFALSE 62914
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
62379: LD_ADDR_VAR 0 5
62383: PUSH
62384: LD_EXP 69
62388: PUSH
62389: LD_VAR 0 2
62393: ARRAY
62394: PUSH
62395: LD_EXP 98
62399: PUSH
62400: LD_VAR 0 2
62404: ARRAY
62405: UNION
62406: PPUSH
62407: LD_INT 21
62409: PUSH
62410: LD_INT 1
62412: PUSH
62413: EMPTY
62414: LIST
62415: LIST
62416: PUSH
62417: LD_INT 1
62419: PUSH
62420: LD_INT 3
62422: PUSH
62423: LD_INT 54
62425: PUSH
62426: EMPTY
62427: LIST
62428: PUSH
62429: EMPTY
62430: LIST
62431: LIST
62432: PUSH
62433: LD_INT 3
62435: PUSH
62436: LD_INT 24
62438: PUSH
62439: LD_INT 1000
62441: PUSH
62442: EMPTY
62443: LIST
62444: LIST
62445: PUSH
62446: EMPTY
62447: LIST
62448: LIST
62449: PUSH
62450: EMPTY
62451: LIST
62452: LIST
62453: LIST
62454: PUSH
62455: EMPTY
62456: LIST
62457: LIST
62458: PPUSH
62459: CALL_OW 72
62463: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
62464: LD_ADDR_VAR 0 6
62468: PUSH
62469: LD_EXP 69
62473: PUSH
62474: LD_VAR 0 2
62478: ARRAY
62479: PPUSH
62480: LD_INT 21
62482: PUSH
62483: LD_INT 1
62485: PUSH
62486: EMPTY
62487: LIST
62488: LIST
62489: PUSH
62490: LD_INT 1
62492: PUSH
62493: LD_INT 3
62495: PUSH
62496: LD_INT 54
62498: PUSH
62499: EMPTY
62500: LIST
62501: PUSH
62502: EMPTY
62503: LIST
62504: LIST
62505: PUSH
62506: LD_INT 3
62508: PUSH
62509: LD_INT 24
62511: PUSH
62512: LD_INT 250
62514: PUSH
62515: EMPTY
62516: LIST
62517: LIST
62518: PUSH
62519: EMPTY
62520: LIST
62521: LIST
62522: PUSH
62523: EMPTY
62524: LIST
62525: LIST
62526: LIST
62527: PUSH
62528: EMPTY
62529: LIST
62530: LIST
62531: PPUSH
62532: CALL_OW 72
62536: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
62537: LD_ADDR_VAR 0 7
62541: PUSH
62542: LD_VAR 0 5
62546: PUSH
62547: LD_VAR 0 6
62551: DIFF
62552: ST_TO_ADDR
// if not need_heal_1 then
62553: LD_VAR 0 6
62557: NOT
62558: IFFALSE 62591
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
62560: LD_ADDR_EXP 72
62564: PUSH
62565: LD_EXP 72
62569: PPUSH
62570: LD_VAR 0 2
62574: PUSH
62575: LD_INT 1
62577: PUSH
62578: EMPTY
62579: LIST
62580: LIST
62581: PPUSH
62582: EMPTY
62583: PPUSH
62584: CALL 18588 0 3
62588: ST_TO_ADDR
62589: GO 62661
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
62591: LD_ADDR_EXP 72
62595: PUSH
62596: LD_EXP 72
62600: PPUSH
62601: LD_VAR 0 2
62605: PUSH
62606: LD_INT 1
62608: PUSH
62609: EMPTY
62610: LIST
62611: LIST
62612: PPUSH
62613: LD_EXP 72
62617: PUSH
62618: LD_VAR 0 2
62622: ARRAY
62623: PUSH
62624: LD_INT 1
62626: ARRAY
62627: PPUSH
62628: LD_INT 3
62630: PUSH
62631: LD_INT 24
62633: PUSH
62634: LD_INT 1000
62636: PUSH
62637: EMPTY
62638: LIST
62639: LIST
62640: PUSH
62641: EMPTY
62642: LIST
62643: LIST
62644: PPUSH
62645: CALL_OW 72
62649: PUSH
62650: LD_VAR 0 6
62654: UNION
62655: PPUSH
62656: CALL 18588 0 3
62660: ST_TO_ADDR
// if not need_heal_2 then
62661: LD_VAR 0 7
62665: NOT
62666: IFFALSE 62699
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
62668: LD_ADDR_EXP 72
62672: PUSH
62673: LD_EXP 72
62677: PPUSH
62678: LD_VAR 0 2
62682: PUSH
62683: LD_INT 2
62685: PUSH
62686: EMPTY
62687: LIST
62688: LIST
62689: PPUSH
62690: EMPTY
62691: PPUSH
62692: CALL 18588 0 3
62696: ST_TO_ADDR
62697: GO 62731
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
62699: LD_ADDR_EXP 72
62703: PUSH
62704: LD_EXP 72
62708: PPUSH
62709: LD_VAR 0 2
62713: PUSH
62714: LD_INT 2
62716: PUSH
62717: EMPTY
62718: LIST
62719: LIST
62720: PPUSH
62721: LD_VAR 0 7
62725: PPUSH
62726: CALL 18588 0 3
62730: ST_TO_ADDR
// if need_heal_2 then
62731: LD_VAR 0 7
62735: IFFALSE 62896
// for j in need_heal_2 do
62737: LD_ADDR_VAR 0 3
62741: PUSH
62742: LD_VAR 0 7
62746: PUSH
62747: FOR_IN
62748: IFFALSE 62894
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62750: LD_ADDR_VAR 0 5
62754: PUSH
62755: LD_EXP 69
62759: PUSH
62760: LD_VAR 0 2
62764: ARRAY
62765: PPUSH
62766: LD_INT 2
62768: PUSH
62769: LD_INT 30
62771: PUSH
62772: LD_INT 6
62774: PUSH
62775: EMPTY
62776: LIST
62777: LIST
62778: PUSH
62779: LD_INT 30
62781: PUSH
62782: LD_INT 7
62784: PUSH
62785: EMPTY
62786: LIST
62787: LIST
62788: PUSH
62789: LD_INT 30
62791: PUSH
62792: LD_INT 8
62794: PUSH
62795: EMPTY
62796: LIST
62797: LIST
62798: PUSH
62799: LD_INT 30
62801: PUSH
62802: LD_INT 0
62804: PUSH
62805: EMPTY
62806: LIST
62807: LIST
62808: PUSH
62809: LD_INT 30
62811: PUSH
62812: LD_INT 1
62814: PUSH
62815: EMPTY
62816: LIST
62817: LIST
62818: PUSH
62819: EMPTY
62820: LIST
62821: LIST
62822: LIST
62823: LIST
62824: LIST
62825: LIST
62826: PPUSH
62827: CALL_OW 72
62831: ST_TO_ADDR
// if tmp then
62832: LD_VAR 0 5
62836: IFFALSE 62892
// begin k := NearestUnitToUnit ( tmp , j ) ;
62838: LD_ADDR_VAR 0 4
62842: PUSH
62843: LD_VAR 0 5
62847: PPUSH
62848: LD_VAR 0 3
62852: PPUSH
62853: CALL_OW 74
62857: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
62858: LD_VAR 0 3
62862: PPUSH
62863: LD_VAR 0 4
62867: PPUSH
62868: CALL_OW 296
62872: PUSH
62873: LD_INT 5
62875: GREATER
62876: IFFALSE 62892
// ComMoveToNearbyEntrance ( j , k ) ;
62878: LD_VAR 0 3
62882: PPUSH
62883: LD_VAR 0 4
62887: PPUSH
62888: CALL 51206 0 2
// end ; end ;
62892: GO 62747
62894: POP
62895: POP
// if not need_heal_1 and not need_heal_2 then
62896: LD_VAR 0 6
62900: NOT
62901: PUSH
62902: LD_VAR 0 7
62906: NOT
62907: AND
62908: IFFALSE 62912
// continue ;
62910: GO 62376
// end ;
62912: GO 62376
62914: POP
62915: POP
// RaiseSailEvent ( 102 ) ;
62916: LD_INT 102
62918: PPUSH
62919: CALL_OW 427
// end ;
62923: LD_VAR 0 1
62927: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
62928: LD_INT 0
62930: PPUSH
62931: PPUSH
62932: PPUSH
62933: PPUSH
62934: PPUSH
62935: PPUSH
62936: PPUSH
62937: PPUSH
// if not mc_bases then
62938: LD_EXP 69
62942: NOT
62943: IFFALSE 62947
// exit ;
62945: GO 63830
// for i = 1 to mc_bases do
62947: LD_ADDR_VAR 0 2
62951: PUSH
62952: DOUBLE
62953: LD_INT 1
62955: DEC
62956: ST_TO_ADDR
62957: LD_EXP 69
62961: PUSH
62962: FOR_TO
62963: IFFALSE 63828
// begin if not mc_building_need_repair [ i ] then
62965: LD_EXP 70
62969: PUSH
62970: LD_VAR 0 2
62974: ARRAY
62975: NOT
62976: IFFALSE 63163
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
62978: LD_ADDR_VAR 0 6
62982: PUSH
62983: LD_EXP 88
62987: PUSH
62988: LD_VAR 0 2
62992: ARRAY
62993: PPUSH
62994: LD_INT 3
62996: PUSH
62997: LD_INT 24
62999: PUSH
63000: LD_INT 1000
63002: PUSH
63003: EMPTY
63004: LIST
63005: LIST
63006: PUSH
63007: EMPTY
63008: LIST
63009: LIST
63010: PUSH
63011: LD_INT 2
63013: PUSH
63014: LD_INT 34
63016: PUSH
63017: LD_INT 13
63019: PUSH
63020: EMPTY
63021: LIST
63022: LIST
63023: PUSH
63024: LD_INT 34
63026: PUSH
63027: LD_INT 52
63029: PUSH
63030: EMPTY
63031: LIST
63032: LIST
63033: PUSH
63034: LD_INT 34
63036: PUSH
63037: LD_EXP 54
63041: PUSH
63042: EMPTY
63043: LIST
63044: LIST
63045: PUSH
63046: EMPTY
63047: LIST
63048: LIST
63049: LIST
63050: LIST
63051: PUSH
63052: EMPTY
63053: LIST
63054: LIST
63055: PPUSH
63056: CALL_OW 72
63060: ST_TO_ADDR
// if cranes then
63061: LD_VAR 0 6
63065: IFFALSE 63127
// for j in cranes do
63067: LD_ADDR_VAR 0 3
63071: PUSH
63072: LD_VAR 0 6
63076: PUSH
63077: FOR_IN
63078: IFFALSE 63125
// if not IsInArea ( j , mc_parking [ i ] ) then
63080: LD_VAR 0 3
63084: PPUSH
63085: LD_EXP 93
63089: PUSH
63090: LD_VAR 0 2
63094: ARRAY
63095: PPUSH
63096: CALL_OW 308
63100: NOT
63101: IFFALSE 63123
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63103: LD_VAR 0 3
63107: PPUSH
63108: LD_EXP 93
63112: PUSH
63113: LD_VAR 0 2
63117: ARRAY
63118: PPUSH
63119: CALL_OW 113
63123: GO 63077
63125: POP
63126: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63127: LD_ADDR_EXP 71
63131: PUSH
63132: LD_EXP 71
63136: PPUSH
63137: LD_VAR 0 2
63141: PPUSH
63142: EMPTY
63143: PPUSH
63144: CALL_OW 1
63148: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
63149: LD_VAR 0 2
63153: PPUSH
63154: LD_INT 101
63156: PPUSH
63157: CALL 58015 0 2
// continue ;
63161: GO 62962
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
63163: LD_ADDR_EXP 75
63167: PUSH
63168: LD_EXP 75
63172: PPUSH
63173: LD_VAR 0 2
63177: PPUSH
63178: EMPTY
63179: PPUSH
63180: CALL_OW 1
63184: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63185: LD_VAR 0 2
63189: PPUSH
63190: LD_INT 103
63192: PPUSH
63193: CALL 58015 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
63197: LD_ADDR_VAR 0 5
63201: PUSH
63202: LD_EXP 69
63206: PUSH
63207: LD_VAR 0 2
63211: ARRAY
63212: PUSH
63213: LD_EXP 98
63217: PUSH
63218: LD_VAR 0 2
63222: ARRAY
63223: UNION
63224: PPUSH
63225: LD_INT 2
63227: PUSH
63228: LD_INT 25
63230: PUSH
63231: LD_INT 2
63233: PUSH
63234: EMPTY
63235: LIST
63236: LIST
63237: PUSH
63238: LD_INT 25
63240: PUSH
63241: LD_INT 16
63243: PUSH
63244: EMPTY
63245: LIST
63246: LIST
63247: PUSH
63248: EMPTY
63249: LIST
63250: LIST
63251: LIST
63252: PUSH
63253: EMPTY
63254: LIST
63255: PPUSH
63256: CALL_OW 72
63260: ST_TO_ADDR
// if mc_need_heal [ i ] then
63261: LD_EXP 72
63265: PUSH
63266: LD_VAR 0 2
63270: ARRAY
63271: IFFALSE 63315
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
63273: LD_ADDR_VAR 0 5
63277: PUSH
63278: LD_VAR 0 5
63282: PUSH
63283: LD_EXP 72
63287: PUSH
63288: LD_VAR 0 2
63292: ARRAY
63293: PUSH
63294: LD_INT 1
63296: ARRAY
63297: PUSH
63298: LD_EXP 72
63302: PUSH
63303: LD_VAR 0 2
63307: ARRAY
63308: PUSH
63309: LD_INT 2
63311: ARRAY
63312: UNION
63313: DIFF
63314: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
63315: LD_ADDR_VAR 0 6
63319: PUSH
63320: LD_EXP 88
63324: PUSH
63325: LD_VAR 0 2
63329: ARRAY
63330: PPUSH
63331: LD_INT 2
63333: PUSH
63334: LD_INT 34
63336: PUSH
63337: LD_INT 13
63339: PUSH
63340: EMPTY
63341: LIST
63342: LIST
63343: PUSH
63344: LD_INT 34
63346: PUSH
63347: LD_INT 52
63349: PUSH
63350: EMPTY
63351: LIST
63352: LIST
63353: PUSH
63354: LD_INT 34
63356: PUSH
63357: LD_EXP 54
63361: PUSH
63362: EMPTY
63363: LIST
63364: LIST
63365: PUSH
63366: EMPTY
63367: LIST
63368: LIST
63369: LIST
63370: LIST
63371: PPUSH
63372: CALL_OW 72
63376: ST_TO_ADDR
// if cranes then
63377: LD_VAR 0 6
63381: IFFALSE 63517
// begin for j in cranes do
63383: LD_ADDR_VAR 0 3
63387: PUSH
63388: LD_VAR 0 6
63392: PUSH
63393: FOR_IN
63394: IFFALSE 63515
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
63396: LD_VAR 0 3
63400: PPUSH
63401: CALL_OW 256
63405: PUSH
63406: LD_INT 1000
63408: EQUAL
63409: PUSH
63410: LD_VAR 0 3
63414: PPUSH
63415: CALL_OW 314
63419: NOT
63420: AND
63421: IFFALSE 63455
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
63423: LD_VAR 0 3
63427: PPUSH
63428: LD_EXP 70
63432: PUSH
63433: LD_VAR 0 2
63437: ARRAY
63438: PPUSH
63439: LD_VAR 0 3
63443: PPUSH
63444: CALL_OW 74
63448: PPUSH
63449: CALL_OW 130
63453: GO 63513
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
63455: LD_VAR 0 3
63459: PPUSH
63460: CALL_OW 256
63464: PUSH
63465: LD_INT 500
63467: LESS
63468: PUSH
63469: LD_VAR 0 3
63473: PPUSH
63474: LD_EXP 93
63478: PUSH
63479: LD_VAR 0 2
63483: ARRAY
63484: PPUSH
63485: CALL_OW 308
63489: NOT
63490: AND
63491: IFFALSE 63513
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63493: LD_VAR 0 3
63497: PPUSH
63498: LD_EXP 93
63502: PUSH
63503: LD_VAR 0 2
63507: ARRAY
63508: PPUSH
63509: CALL_OW 113
// end ;
63513: GO 63393
63515: POP
63516: POP
// end ; if tmp > 3 then
63517: LD_VAR 0 5
63521: PUSH
63522: LD_INT 3
63524: GREATER
63525: IFFALSE 63545
// tmp := ShrinkArray ( tmp , 4 ) ;
63527: LD_ADDR_VAR 0 5
63531: PUSH
63532: LD_VAR 0 5
63536: PPUSH
63537: LD_INT 4
63539: PPUSH
63540: CALL 50654 0 2
63544: ST_TO_ADDR
// if not tmp then
63545: LD_VAR 0 5
63549: NOT
63550: IFFALSE 63554
// continue ;
63552: GO 62962
// for j in tmp do
63554: LD_ADDR_VAR 0 3
63558: PUSH
63559: LD_VAR 0 5
63563: PUSH
63564: FOR_IN
63565: IFFALSE 63824
// begin if IsInUnit ( j ) then
63567: LD_VAR 0 3
63571: PPUSH
63572: CALL_OW 310
63576: IFFALSE 63587
// ComExitBuilding ( j ) ;
63578: LD_VAR 0 3
63582: PPUSH
63583: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
63587: LD_VAR 0 3
63591: PUSH
63592: LD_EXP 71
63596: PUSH
63597: LD_VAR 0 2
63601: ARRAY
63602: IN
63603: NOT
63604: IFFALSE 63662
// begin SetTag ( j , 101 ) ;
63606: LD_VAR 0 3
63610: PPUSH
63611: LD_INT 101
63613: PPUSH
63614: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
63618: LD_ADDR_EXP 71
63622: PUSH
63623: LD_EXP 71
63627: PPUSH
63628: LD_VAR 0 2
63632: PUSH
63633: LD_EXP 71
63637: PUSH
63638: LD_VAR 0 2
63642: ARRAY
63643: PUSH
63644: LD_INT 1
63646: PLUS
63647: PUSH
63648: EMPTY
63649: LIST
63650: LIST
63651: PPUSH
63652: LD_VAR 0 3
63656: PPUSH
63657: CALL 18588 0 3
63661: ST_TO_ADDR
// end ; wait ( 1 ) ;
63662: LD_INT 1
63664: PPUSH
63665: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
63669: LD_ADDR_VAR 0 7
63673: PUSH
63674: LD_EXP 70
63678: PUSH
63679: LD_VAR 0 2
63683: ARRAY
63684: ST_TO_ADDR
// if mc_scan [ i ] then
63685: LD_EXP 92
63689: PUSH
63690: LD_VAR 0 2
63694: ARRAY
63695: IFFALSE 63757
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
63697: LD_ADDR_VAR 0 7
63701: PUSH
63702: LD_EXP 70
63706: PUSH
63707: LD_VAR 0 2
63711: ARRAY
63712: PPUSH
63713: LD_INT 3
63715: PUSH
63716: LD_INT 30
63718: PUSH
63719: LD_INT 32
63721: PUSH
63722: EMPTY
63723: LIST
63724: LIST
63725: PUSH
63726: LD_INT 30
63728: PUSH
63729: LD_INT 33
63731: PUSH
63732: EMPTY
63733: LIST
63734: LIST
63735: PUSH
63736: LD_INT 30
63738: PUSH
63739: LD_INT 31
63741: PUSH
63742: EMPTY
63743: LIST
63744: LIST
63745: PUSH
63746: EMPTY
63747: LIST
63748: LIST
63749: LIST
63750: LIST
63751: PPUSH
63752: CALL_OW 72
63756: ST_TO_ADDR
// if not to_repair_tmp then
63757: LD_VAR 0 7
63761: NOT
63762: IFFALSE 63766
// continue ;
63764: GO 63564
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
63766: LD_ADDR_VAR 0 8
63770: PUSH
63771: LD_VAR 0 7
63775: PPUSH
63776: LD_VAR 0 3
63780: PPUSH
63781: CALL_OW 74
63785: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
63786: LD_VAR 0 8
63790: PPUSH
63791: LD_INT 16
63793: PPUSH
63794: CALL 21187 0 2
63798: PUSH
63799: LD_INT 4
63801: ARRAY
63802: PUSH
63803: LD_INT 10
63805: LESS
63806: IFFALSE 63822
// ComRepairBuilding ( j , to_repair ) ;
63808: LD_VAR 0 3
63812: PPUSH
63813: LD_VAR 0 8
63817: PPUSH
63818: CALL_OW 130
// end ;
63822: GO 63564
63824: POP
63825: POP
// end ;
63826: GO 62962
63828: POP
63829: POP
// end ;
63830: LD_VAR 0 1
63834: RET
// export function MC_Heal ; var i , j , tmp ; begin
63835: LD_INT 0
63837: PPUSH
63838: PPUSH
63839: PPUSH
63840: PPUSH
// if not mc_bases then
63841: LD_EXP 69
63845: NOT
63846: IFFALSE 63850
// exit ;
63848: GO 64252
// for i = 1 to mc_bases do
63850: LD_ADDR_VAR 0 2
63854: PUSH
63855: DOUBLE
63856: LD_INT 1
63858: DEC
63859: ST_TO_ADDR
63860: LD_EXP 69
63864: PUSH
63865: FOR_TO
63866: IFFALSE 64250
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
63868: LD_EXP 72
63872: PUSH
63873: LD_VAR 0 2
63877: ARRAY
63878: PUSH
63879: LD_INT 1
63881: ARRAY
63882: NOT
63883: PUSH
63884: LD_EXP 72
63888: PUSH
63889: LD_VAR 0 2
63893: ARRAY
63894: PUSH
63895: LD_INT 2
63897: ARRAY
63898: NOT
63899: AND
63900: IFFALSE 63938
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
63902: LD_ADDR_EXP 73
63906: PUSH
63907: LD_EXP 73
63911: PPUSH
63912: LD_VAR 0 2
63916: PPUSH
63917: EMPTY
63918: PPUSH
63919: CALL_OW 1
63923: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
63924: LD_VAR 0 2
63928: PPUSH
63929: LD_INT 102
63931: PPUSH
63932: CALL 58015 0 2
// continue ;
63936: GO 63865
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
63938: LD_ADDR_VAR 0 4
63942: PUSH
63943: LD_EXP 69
63947: PUSH
63948: LD_VAR 0 2
63952: ARRAY
63953: PPUSH
63954: LD_INT 25
63956: PUSH
63957: LD_INT 4
63959: PUSH
63960: EMPTY
63961: LIST
63962: LIST
63963: PPUSH
63964: CALL_OW 72
63968: ST_TO_ADDR
// if not tmp then
63969: LD_VAR 0 4
63973: NOT
63974: IFFALSE 63978
// continue ;
63976: GO 63865
// if mc_taming [ i ] then
63978: LD_EXP 100
63982: PUSH
63983: LD_VAR 0 2
63987: ARRAY
63988: IFFALSE 64012
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63990: LD_ADDR_EXP 100
63994: PUSH
63995: LD_EXP 100
63999: PPUSH
64000: LD_VAR 0 2
64004: PPUSH
64005: EMPTY
64006: PPUSH
64007: CALL_OW 1
64011: ST_TO_ADDR
// for j in tmp do
64012: LD_ADDR_VAR 0 3
64016: PUSH
64017: LD_VAR 0 4
64021: PUSH
64022: FOR_IN
64023: IFFALSE 64246
// begin if IsInUnit ( j ) then
64025: LD_VAR 0 3
64029: PPUSH
64030: CALL_OW 310
64034: IFFALSE 64045
// ComExitBuilding ( j ) ;
64036: LD_VAR 0 3
64040: PPUSH
64041: CALL_OW 122
// if not j in mc_healers [ i ] then
64045: LD_VAR 0 3
64049: PUSH
64050: LD_EXP 73
64054: PUSH
64055: LD_VAR 0 2
64059: ARRAY
64060: IN
64061: NOT
64062: IFFALSE 64108
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
64064: LD_ADDR_EXP 73
64068: PUSH
64069: LD_EXP 73
64073: PPUSH
64074: LD_VAR 0 2
64078: PUSH
64079: LD_EXP 73
64083: PUSH
64084: LD_VAR 0 2
64088: ARRAY
64089: PUSH
64090: LD_INT 1
64092: PLUS
64093: PUSH
64094: EMPTY
64095: LIST
64096: LIST
64097: PPUSH
64098: LD_VAR 0 3
64102: PPUSH
64103: CALL 18588 0 3
64107: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
64108: LD_VAR 0 3
64112: PPUSH
64113: CALL_OW 110
64117: PUSH
64118: LD_INT 102
64120: NONEQUAL
64121: IFFALSE 64135
// SetTag ( j , 102 ) ;
64123: LD_VAR 0 3
64127: PPUSH
64128: LD_INT 102
64130: PPUSH
64131: CALL_OW 109
// Wait ( 3 ) ;
64135: LD_INT 3
64137: PPUSH
64138: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
64142: LD_EXP 72
64146: PUSH
64147: LD_VAR 0 2
64151: ARRAY
64152: PUSH
64153: LD_INT 1
64155: ARRAY
64156: IFFALSE 64188
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
64158: LD_VAR 0 3
64162: PPUSH
64163: LD_EXP 72
64167: PUSH
64168: LD_VAR 0 2
64172: ARRAY
64173: PUSH
64174: LD_INT 1
64176: ARRAY
64177: PUSH
64178: LD_INT 1
64180: ARRAY
64181: PPUSH
64182: CALL_OW 128
64186: GO 64244
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
64188: LD_VAR 0 3
64192: PPUSH
64193: CALL_OW 314
64197: NOT
64198: PUSH
64199: LD_EXP 72
64203: PUSH
64204: LD_VAR 0 2
64208: ARRAY
64209: PUSH
64210: LD_INT 2
64212: ARRAY
64213: AND
64214: IFFALSE 64244
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
64216: LD_VAR 0 3
64220: PPUSH
64221: LD_EXP 72
64225: PUSH
64226: LD_VAR 0 2
64230: ARRAY
64231: PUSH
64232: LD_INT 2
64234: ARRAY
64235: PUSH
64236: LD_INT 1
64238: ARRAY
64239: PPUSH
64240: CALL_OW 128
// end ;
64244: GO 64022
64246: POP
64247: POP
// end ;
64248: GO 63865
64250: POP
64251: POP
// end ;
64252: LD_VAR 0 1
64256: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
64257: LD_INT 0
64259: PPUSH
64260: PPUSH
64261: PPUSH
64262: PPUSH
64263: PPUSH
// if not mc_bases then
64264: LD_EXP 69
64268: NOT
64269: IFFALSE 64273
// exit ;
64271: GO 65444
// for i = 1 to mc_bases do
64273: LD_ADDR_VAR 0 2
64277: PUSH
64278: DOUBLE
64279: LD_INT 1
64281: DEC
64282: ST_TO_ADDR
64283: LD_EXP 69
64287: PUSH
64288: FOR_TO
64289: IFFALSE 65442
// begin if mc_scan [ i ] then
64291: LD_EXP 92
64295: PUSH
64296: LD_VAR 0 2
64300: ARRAY
64301: IFFALSE 64305
// continue ;
64303: GO 64288
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
64305: LD_EXP 74
64309: PUSH
64310: LD_VAR 0 2
64314: ARRAY
64315: NOT
64316: PUSH
64317: LD_EXP 76
64321: PUSH
64322: LD_VAR 0 2
64326: ARRAY
64327: NOT
64328: AND
64329: PUSH
64330: LD_EXP 75
64334: PUSH
64335: LD_VAR 0 2
64339: ARRAY
64340: AND
64341: IFFALSE 64379
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
64343: LD_ADDR_EXP 75
64347: PUSH
64348: LD_EXP 75
64352: PPUSH
64353: LD_VAR 0 2
64357: PPUSH
64358: EMPTY
64359: PPUSH
64360: CALL_OW 1
64364: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64365: LD_VAR 0 2
64369: PPUSH
64370: LD_INT 103
64372: PPUSH
64373: CALL 58015 0 2
// continue ;
64377: GO 64288
// end ; if mc_construct_list [ i ] then
64379: LD_EXP 76
64383: PUSH
64384: LD_VAR 0 2
64388: ARRAY
64389: IFFALSE 64609
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64391: LD_ADDR_VAR 0 4
64395: PUSH
64396: LD_EXP 69
64400: PUSH
64401: LD_VAR 0 2
64405: ARRAY
64406: PPUSH
64407: LD_INT 25
64409: PUSH
64410: LD_INT 2
64412: PUSH
64413: EMPTY
64414: LIST
64415: LIST
64416: PPUSH
64417: CALL_OW 72
64421: PUSH
64422: LD_EXP 71
64426: PUSH
64427: LD_VAR 0 2
64431: ARRAY
64432: DIFF
64433: ST_TO_ADDR
// if not tmp then
64434: LD_VAR 0 4
64438: NOT
64439: IFFALSE 64443
// continue ;
64441: GO 64288
// for j in tmp do
64443: LD_ADDR_VAR 0 3
64447: PUSH
64448: LD_VAR 0 4
64452: PUSH
64453: FOR_IN
64454: IFFALSE 64605
// begin if not mc_builders [ i ] then
64456: LD_EXP 75
64460: PUSH
64461: LD_VAR 0 2
64465: ARRAY
64466: NOT
64467: IFFALSE 64525
// begin SetTag ( j , 103 ) ;
64469: LD_VAR 0 3
64473: PPUSH
64474: LD_INT 103
64476: PPUSH
64477: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64481: LD_ADDR_EXP 75
64485: PUSH
64486: LD_EXP 75
64490: PPUSH
64491: LD_VAR 0 2
64495: PUSH
64496: LD_EXP 75
64500: PUSH
64501: LD_VAR 0 2
64505: ARRAY
64506: PUSH
64507: LD_INT 1
64509: PLUS
64510: PUSH
64511: EMPTY
64512: LIST
64513: LIST
64514: PPUSH
64515: LD_VAR 0 3
64519: PPUSH
64520: CALL 18588 0 3
64524: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64525: LD_VAR 0 3
64529: PPUSH
64530: CALL_OW 310
64534: IFFALSE 64545
// ComExitBuilding ( j ) ;
64536: LD_VAR 0 3
64540: PPUSH
64541: CALL_OW 122
// wait ( 3 ) ;
64545: LD_INT 3
64547: PPUSH
64548: CALL_OW 67
// if not mc_construct_list [ i ] then
64552: LD_EXP 76
64556: PUSH
64557: LD_VAR 0 2
64561: ARRAY
64562: NOT
64563: IFFALSE 64567
// break ;
64565: GO 64605
// if not HasTask ( j ) then
64567: LD_VAR 0 3
64571: PPUSH
64572: CALL_OW 314
64576: NOT
64577: IFFALSE 64603
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
64579: LD_VAR 0 3
64583: PPUSH
64584: LD_EXP 76
64588: PUSH
64589: LD_VAR 0 2
64593: ARRAY
64594: PUSH
64595: LD_INT 1
64597: ARRAY
64598: PPUSH
64599: CALL 21451 0 2
// end ;
64603: GO 64453
64605: POP
64606: POP
// end else
64607: GO 65440
// if mc_build_list [ i ] then
64609: LD_EXP 74
64613: PUSH
64614: LD_VAR 0 2
64618: ARRAY
64619: IFFALSE 65440
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64621: LD_ADDR_VAR 0 5
64625: PUSH
64626: LD_EXP 69
64630: PUSH
64631: LD_VAR 0 2
64635: ARRAY
64636: PPUSH
64637: LD_INT 2
64639: PUSH
64640: LD_INT 30
64642: PUSH
64643: LD_INT 0
64645: PUSH
64646: EMPTY
64647: LIST
64648: LIST
64649: PUSH
64650: LD_INT 30
64652: PUSH
64653: LD_INT 1
64655: PUSH
64656: EMPTY
64657: LIST
64658: LIST
64659: PUSH
64660: EMPTY
64661: LIST
64662: LIST
64663: LIST
64664: PPUSH
64665: CALL_OW 72
64669: ST_TO_ADDR
// if depot then
64670: LD_VAR 0 5
64674: IFFALSE 64692
// depot := depot [ 1 ] else
64676: LD_ADDR_VAR 0 5
64680: PUSH
64681: LD_VAR 0 5
64685: PUSH
64686: LD_INT 1
64688: ARRAY
64689: ST_TO_ADDR
64690: GO 64700
// depot := 0 ;
64692: LD_ADDR_VAR 0 5
64696: PUSH
64697: LD_INT 0
64699: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
64700: LD_EXP 74
64704: PUSH
64705: LD_VAR 0 2
64709: ARRAY
64710: PUSH
64711: LD_INT 1
64713: ARRAY
64714: PUSH
64715: LD_INT 1
64717: ARRAY
64718: PPUSH
64719: CALL 21275 0 1
64723: PUSH
64724: LD_EXP 69
64728: PUSH
64729: LD_VAR 0 2
64733: ARRAY
64734: PPUSH
64735: LD_INT 2
64737: PUSH
64738: LD_INT 30
64740: PUSH
64741: LD_INT 2
64743: PUSH
64744: EMPTY
64745: LIST
64746: LIST
64747: PUSH
64748: LD_INT 30
64750: PUSH
64751: LD_INT 3
64753: PUSH
64754: EMPTY
64755: LIST
64756: LIST
64757: PUSH
64758: EMPTY
64759: LIST
64760: LIST
64761: LIST
64762: PPUSH
64763: CALL_OW 72
64767: NOT
64768: AND
64769: IFFALSE 64874
// begin for j = 1 to mc_build_list [ i ] do
64771: LD_ADDR_VAR 0 3
64775: PUSH
64776: DOUBLE
64777: LD_INT 1
64779: DEC
64780: ST_TO_ADDR
64781: LD_EXP 74
64785: PUSH
64786: LD_VAR 0 2
64790: ARRAY
64791: PUSH
64792: FOR_TO
64793: IFFALSE 64872
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
64795: LD_EXP 74
64799: PUSH
64800: LD_VAR 0 2
64804: ARRAY
64805: PUSH
64806: LD_VAR 0 3
64810: ARRAY
64811: PUSH
64812: LD_INT 1
64814: ARRAY
64815: PUSH
64816: LD_INT 2
64818: EQUAL
64819: IFFALSE 64870
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
64821: LD_ADDR_EXP 74
64825: PUSH
64826: LD_EXP 74
64830: PPUSH
64831: LD_VAR 0 2
64835: PPUSH
64836: LD_EXP 74
64840: PUSH
64841: LD_VAR 0 2
64845: ARRAY
64846: PPUSH
64847: LD_VAR 0 3
64851: PPUSH
64852: LD_INT 1
64854: PPUSH
64855: LD_INT 0
64857: PPUSH
64858: CALL 18006 0 4
64862: PPUSH
64863: CALL_OW 1
64867: ST_TO_ADDR
// break ;
64868: GO 64872
// end ;
64870: GO 64792
64872: POP
64873: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
64874: LD_EXP 74
64878: PUSH
64879: LD_VAR 0 2
64883: ARRAY
64884: PUSH
64885: LD_INT 1
64887: ARRAY
64888: PUSH
64889: LD_INT 1
64891: ARRAY
64892: PUSH
64893: LD_INT 0
64895: EQUAL
64896: PUSH
64897: LD_VAR 0 5
64901: PUSH
64902: LD_VAR 0 5
64906: PPUSH
64907: LD_EXP 74
64911: PUSH
64912: LD_VAR 0 2
64916: ARRAY
64917: PUSH
64918: LD_INT 1
64920: ARRAY
64921: PUSH
64922: LD_INT 1
64924: ARRAY
64925: PPUSH
64926: LD_EXP 74
64930: PUSH
64931: LD_VAR 0 2
64935: ARRAY
64936: PUSH
64937: LD_INT 1
64939: ARRAY
64940: PUSH
64941: LD_INT 2
64943: ARRAY
64944: PPUSH
64945: LD_EXP 74
64949: PUSH
64950: LD_VAR 0 2
64954: ARRAY
64955: PUSH
64956: LD_INT 1
64958: ARRAY
64959: PUSH
64960: LD_INT 3
64962: ARRAY
64963: PPUSH
64964: LD_EXP 74
64968: PUSH
64969: LD_VAR 0 2
64973: ARRAY
64974: PUSH
64975: LD_INT 1
64977: ARRAY
64978: PUSH
64979: LD_INT 4
64981: ARRAY
64982: PPUSH
64983: CALL 26691 0 5
64987: AND
64988: OR
64989: IFFALSE 65270
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64991: LD_ADDR_VAR 0 4
64995: PUSH
64996: LD_EXP 69
65000: PUSH
65001: LD_VAR 0 2
65005: ARRAY
65006: PPUSH
65007: LD_INT 25
65009: PUSH
65010: LD_INT 2
65012: PUSH
65013: EMPTY
65014: LIST
65015: LIST
65016: PPUSH
65017: CALL_OW 72
65021: PUSH
65022: LD_EXP 71
65026: PUSH
65027: LD_VAR 0 2
65031: ARRAY
65032: DIFF
65033: ST_TO_ADDR
// if not tmp then
65034: LD_VAR 0 4
65038: NOT
65039: IFFALSE 65043
// continue ;
65041: GO 64288
// for j in tmp do
65043: LD_ADDR_VAR 0 3
65047: PUSH
65048: LD_VAR 0 4
65052: PUSH
65053: FOR_IN
65054: IFFALSE 65266
// begin if not mc_builders [ i ] then
65056: LD_EXP 75
65060: PUSH
65061: LD_VAR 0 2
65065: ARRAY
65066: NOT
65067: IFFALSE 65125
// begin SetTag ( j , 103 ) ;
65069: LD_VAR 0 3
65073: PPUSH
65074: LD_INT 103
65076: PPUSH
65077: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65081: LD_ADDR_EXP 75
65085: PUSH
65086: LD_EXP 75
65090: PPUSH
65091: LD_VAR 0 2
65095: PUSH
65096: LD_EXP 75
65100: PUSH
65101: LD_VAR 0 2
65105: ARRAY
65106: PUSH
65107: LD_INT 1
65109: PLUS
65110: PUSH
65111: EMPTY
65112: LIST
65113: LIST
65114: PPUSH
65115: LD_VAR 0 3
65119: PPUSH
65120: CALL 18588 0 3
65124: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65125: LD_VAR 0 3
65129: PPUSH
65130: CALL_OW 310
65134: IFFALSE 65145
// ComExitBuilding ( j ) ;
65136: LD_VAR 0 3
65140: PPUSH
65141: CALL_OW 122
// wait ( 3 ) ;
65145: LD_INT 3
65147: PPUSH
65148: CALL_OW 67
// if not mc_build_list [ i ] then
65152: LD_EXP 74
65156: PUSH
65157: LD_VAR 0 2
65161: ARRAY
65162: NOT
65163: IFFALSE 65167
// break ;
65165: GO 65266
// if not HasTask ( j ) then
65167: LD_VAR 0 3
65171: PPUSH
65172: CALL_OW 314
65176: NOT
65177: IFFALSE 65264
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
65179: LD_VAR 0 3
65183: PPUSH
65184: LD_EXP 74
65188: PUSH
65189: LD_VAR 0 2
65193: ARRAY
65194: PUSH
65195: LD_INT 1
65197: ARRAY
65198: PUSH
65199: LD_INT 1
65201: ARRAY
65202: PPUSH
65203: LD_EXP 74
65207: PUSH
65208: LD_VAR 0 2
65212: ARRAY
65213: PUSH
65214: LD_INT 1
65216: ARRAY
65217: PUSH
65218: LD_INT 2
65220: ARRAY
65221: PPUSH
65222: LD_EXP 74
65226: PUSH
65227: LD_VAR 0 2
65231: ARRAY
65232: PUSH
65233: LD_INT 1
65235: ARRAY
65236: PUSH
65237: LD_INT 3
65239: ARRAY
65240: PPUSH
65241: LD_EXP 74
65245: PUSH
65246: LD_VAR 0 2
65250: ARRAY
65251: PUSH
65252: LD_INT 1
65254: ARRAY
65255: PUSH
65256: LD_INT 4
65258: ARRAY
65259: PPUSH
65260: CALL_OW 145
// end ;
65264: GO 65053
65266: POP
65267: POP
// end else
65268: GO 65440
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
65270: LD_EXP 69
65274: PUSH
65275: LD_VAR 0 2
65279: ARRAY
65280: PPUSH
65281: LD_EXP 74
65285: PUSH
65286: LD_VAR 0 2
65290: ARRAY
65291: PUSH
65292: LD_INT 1
65294: ARRAY
65295: PUSH
65296: LD_INT 1
65298: ARRAY
65299: PPUSH
65300: LD_EXP 74
65304: PUSH
65305: LD_VAR 0 2
65309: ARRAY
65310: PUSH
65311: LD_INT 1
65313: ARRAY
65314: PUSH
65315: LD_INT 2
65317: ARRAY
65318: PPUSH
65319: LD_EXP 74
65323: PUSH
65324: LD_VAR 0 2
65328: ARRAY
65329: PUSH
65330: LD_INT 1
65332: ARRAY
65333: PUSH
65334: LD_INT 3
65336: ARRAY
65337: PPUSH
65338: LD_EXP 74
65342: PUSH
65343: LD_VAR 0 2
65347: ARRAY
65348: PUSH
65349: LD_INT 1
65351: ARRAY
65352: PUSH
65353: LD_INT 4
65355: ARRAY
65356: PPUSH
65357: LD_EXP 69
65361: PUSH
65362: LD_VAR 0 2
65366: ARRAY
65367: PPUSH
65368: LD_INT 21
65370: PUSH
65371: LD_INT 3
65373: PUSH
65374: EMPTY
65375: LIST
65376: LIST
65377: PPUSH
65378: CALL_OW 72
65382: PPUSH
65383: EMPTY
65384: PPUSH
65385: CALL 25441 0 7
65389: NOT
65390: IFFALSE 65440
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
65392: LD_ADDR_EXP 74
65396: PUSH
65397: LD_EXP 74
65401: PPUSH
65402: LD_VAR 0 2
65406: PPUSH
65407: LD_EXP 74
65411: PUSH
65412: LD_VAR 0 2
65416: ARRAY
65417: PPUSH
65418: LD_INT 1
65420: PPUSH
65421: LD_INT 1
65423: NEG
65424: PPUSH
65425: LD_INT 0
65427: PPUSH
65428: CALL 18006 0 4
65432: PPUSH
65433: CALL_OW 1
65437: ST_TO_ADDR
// continue ;
65438: GO 64288
// end ; end ; end ;
65440: GO 64288
65442: POP
65443: POP
// end ;
65444: LD_VAR 0 1
65448: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
65449: LD_INT 0
65451: PPUSH
65452: PPUSH
65453: PPUSH
65454: PPUSH
65455: PPUSH
65456: PPUSH
// if not mc_bases then
65457: LD_EXP 69
65461: NOT
65462: IFFALSE 65466
// exit ;
65464: GO 65893
// for i = 1 to mc_bases do
65466: LD_ADDR_VAR 0 2
65470: PUSH
65471: DOUBLE
65472: LD_INT 1
65474: DEC
65475: ST_TO_ADDR
65476: LD_EXP 69
65480: PUSH
65481: FOR_TO
65482: IFFALSE 65891
// begin tmp := mc_build_upgrade [ i ] ;
65484: LD_ADDR_VAR 0 4
65488: PUSH
65489: LD_EXP 101
65493: PUSH
65494: LD_VAR 0 2
65498: ARRAY
65499: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
65500: LD_ADDR_VAR 0 6
65504: PUSH
65505: LD_EXP 102
65509: PUSH
65510: LD_VAR 0 2
65514: ARRAY
65515: PPUSH
65516: LD_INT 2
65518: PUSH
65519: LD_INT 30
65521: PUSH
65522: LD_INT 6
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: PUSH
65529: LD_INT 30
65531: PUSH
65532: LD_INT 7
65534: PUSH
65535: EMPTY
65536: LIST
65537: LIST
65538: PUSH
65539: EMPTY
65540: LIST
65541: LIST
65542: LIST
65543: PPUSH
65544: CALL_OW 72
65548: ST_TO_ADDR
// if not tmp and not lab then
65549: LD_VAR 0 4
65553: NOT
65554: PUSH
65555: LD_VAR 0 6
65559: NOT
65560: AND
65561: IFFALSE 65565
// continue ;
65563: GO 65481
// if tmp then
65565: LD_VAR 0 4
65569: IFFALSE 65689
// for j in tmp do
65571: LD_ADDR_VAR 0 3
65575: PUSH
65576: LD_VAR 0 4
65580: PUSH
65581: FOR_IN
65582: IFFALSE 65687
// begin if UpgradeCost ( j ) then
65584: LD_VAR 0 3
65588: PPUSH
65589: CALL 25101 0 1
65593: IFFALSE 65685
// begin ComUpgrade ( j ) ;
65595: LD_VAR 0 3
65599: PPUSH
65600: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
65604: LD_ADDR_EXP 101
65608: PUSH
65609: LD_EXP 101
65613: PPUSH
65614: LD_VAR 0 2
65618: PPUSH
65619: LD_EXP 101
65623: PUSH
65624: LD_VAR 0 2
65628: ARRAY
65629: PUSH
65630: LD_VAR 0 3
65634: DIFF
65635: PPUSH
65636: CALL_OW 1
65640: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65641: LD_ADDR_EXP 76
65645: PUSH
65646: LD_EXP 76
65650: PPUSH
65651: LD_VAR 0 2
65655: PUSH
65656: LD_EXP 76
65660: PUSH
65661: LD_VAR 0 2
65665: ARRAY
65666: PUSH
65667: LD_INT 1
65669: PLUS
65670: PUSH
65671: EMPTY
65672: LIST
65673: LIST
65674: PPUSH
65675: LD_VAR 0 3
65679: PPUSH
65680: CALL 18588 0 3
65684: ST_TO_ADDR
// end ; end ;
65685: GO 65581
65687: POP
65688: POP
// if not lab or not mc_lab_upgrade [ i ] then
65689: LD_VAR 0 6
65693: NOT
65694: PUSH
65695: LD_EXP 103
65699: PUSH
65700: LD_VAR 0 2
65704: ARRAY
65705: NOT
65706: OR
65707: IFFALSE 65711
// continue ;
65709: GO 65481
// for j in lab do
65711: LD_ADDR_VAR 0 3
65715: PUSH
65716: LD_VAR 0 6
65720: PUSH
65721: FOR_IN
65722: IFFALSE 65887
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
65724: LD_VAR 0 3
65728: PPUSH
65729: CALL_OW 266
65733: PUSH
65734: LD_INT 6
65736: PUSH
65737: LD_INT 7
65739: PUSH
65740: EMPTY
65741: LIST
65742: LIST
65743: IN
65744: PUSH
65745: LD_VAR 0 3
65749: PPUSH
65750: CALL_OW 461
65754: PUSH
65755: LD_INT 1
65757: NONEQUAL
65758: AND
65759: IFFALSE 65885
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
65761: LD_VAR 0 3
65765: PPUSH
65766: LD_EXP 103
65770: PUSH
65771: LD_VAR 0 2
65775: ARRAY
65776: PUSH
65777: LD_INT 1
65779: ARRAY
65780: PPUSH
65781: CALL 25306 0 2
65785: IFFALSE 65885
// begin ComCancel ( j ) ;
65787: LD_VAR 0 3
65791: PPUSH
65792: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
65796: LD_VAR 0 3
65800: PPUSH
65801: LD_EXP 103
65805: PUSH
65806: LD_VAR 0 2
65810: ARRAY
65811: PUSH
65812: LD_INT 1
65814: ARRAY
65815: PPUSH
65816: CALL_OW 207
// if not j in mc_construct_list [ i ] then
65820: LD_VAR 0 3
65824: PUSH
65825: LD_EXP 76
65829: PUSH
65830: LD_VAR 0 2
65834: ARRAY
65835: IN
65836: NOT
65837: IFFALSE 65883
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65839: LD_ADDR_EXP 76
65843: PUSH
65844: LD_EXP 76
65848: PPUSH
65849: LD_VAR 0 2
65853: PUSH
65854: LD_EXP 76
65858: PUSH
65859: LD_VAR 0 2
65863: ARRAY
65864: PUSH
65865: LD_INT 1
65867: PLUS
65868: PUSH
65869: EMPTY
65870: LIST
65871: LIST
65872: PPUSH
65873: LD_VAR 0 3
65877: PPUSH
65878: CALL 18588 0 3
65882: ST_TO_ADDR
// break ;
65883: GO 65887
// end ; end ; end ;
65885: GO 65721
65887: POP
65888: POP
// end ;
65889: GO 65481
65891: POP
65892: POP
// end ;
65893: LD_VAR 0 1
65897: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
65898: LD_INT 0
65900: PPUSH
65901: PPUSH
65902: PPUSH
65903: PPUSH
65904: PPUSH
65905: PPUSH
65906: PPUSH
65907: PPUSH
65908: PPUSH
// if not mc_bases then
65909: LD_EXP 69
65913: NOT
65914: IFFALSE 65918
// exit ;
65916: GO 66323
// for i = 1 to mc_bases do
65918: LD_ADDR_VAR 0 2
65922: PUSH
65923: DOUBLE
65924: LD_INT 1
65926: DEC
65927: ST_TO_ADDR
65928: LD_EXP 69
65932: PUSH
65933: FOR_TO
65934: IFFALSE 66321
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
65936: LD_EXP 77
65940: PUSH
65941: LD_VAR 0 2
65945: ARRAY
65946: NOT
65947: PUSH
65948: LD_EXP 69
65952: PUSH
65953: LD_VAR 0 2
65957: ARRAY
65958: PPUSH
65959: LD_INT 30
65961: PUSH
65962: LD_INT 3
65964: PUSH
65965: EMPTY
65966: LIST
65967: LIST
65968: PPUSH
65969: CALL_OW 72
65973: NOT
65974: OR
65975: IFFALSE 65979
// continue ;
65977: GO 65933
// busy := false ;
65979: LD_ADDR_VAR 0 8
65983: PUSH
65984: LD_INT 0
65986: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65987: LD_ADDR_VAR 0 4
65991: PUSH
65992: LD_EXP 69
65996: PUSH
65997: LD_VAR 0 2
66001: ARRAY
66002: PPUSH
66003: LD_INT 30
66005: PUSH
66006: LD_INT 3
66008: PUSH
66009: EMPTY
66010: LIST
66011: LIST
66012: PPUSH
66013: CALL_OW 72
66017: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66018: LD_ADDR_VAR 0 6
66022: PUSH
66023: LD_EXP 77
66027: PUSH
66028: LD_VAR 0 2
66032: ARRAY
66033: PPUSH
66034: LD_INT 2
66036: PUSH
66037: LD_INT 30
66039: PUSH
66040: LD_INT 32
66042: PUSH
66043: EMPTY
66044: LIST
66045: LIST
66046: PUSH
66047: LD_INT 30
66049: PUSH
66050: LD_INT 33
66052: PUSH
66053: EMPTY
66054: LIST
66055: LIST
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: LIST
66061: PPUSH
66062: CALL_OW 72
66066: ST_TO_ADDR
// if not t then
66067: LD_VAR 0 6
66071: NOT
66072: IFFALSE 66076
// continue ;
66074: GO 65933
// for j in tmp do
66076: LD_ADDR_VAR 0 3
66080: PUSH
66081: LD_VAR 0 4
66085: PUSH
66086: FOR_IN
66087: IFFALSE 66117
// if not BuildingStatus ( j ) = bs_idle then
66089: LD_VAR 0 3
66093: PPUSH
66094: CALL_OW 461
66098: PUSH
66099: LD_INT 2
66101: EQUAL
66102: NOT
66103: IFFALSE 66115
// begin busy := true ;
66105: LD_ADDR_VAR 0 8
66109: PUSH
66110: LD_INT 1
66112: ST_TO_ADDR
// break ;
66113: GO 66117
// end ;
66115: GO 66086
66117: POP
66118: POP
// if busy then
66119: LD_VAR 0 8
66123: IFFALSE 66127
// continue ;
66125: GO 65933
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
66127: LD_ADDR_VAR 0 7
66131: PUSH
66132: LD_VAR 0 6
66136: PPUSH
66137: LD_INT 35
66139: PUSH
66140: LD_INT 0
66142: PUSH
66143: EMPTY
66144: LIST
66145: LIST
66146: PPUSH
66147: CALL_OW 72
66151: ST_TO_ADDR
// if tw then
66152: LD_VAR 0 7
66156: IFFALSE 66233
// begin tw := tw [ 1 ] ;
66158: LD_ADDR_VAR 0 7
66162: PUSH
66163: LD_VAR 0 7
66167: PUSH
66168: LD_INT 1
66170: ARRAY
66171: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
66172: LD_ADDR_VAR 0 9
66176: PUSH
66177: LD_VAR 0 7
66181: PPUSH
66182: LD_EXP 94
66186: PUSH
66187: LD_VAR 0 2
66191: ARRAY
66192: PPUSH
66193: CALL 23598 0 2
66197: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
66198: LD_EXP 108
66202: PUSH
66203: LD_VAR 0 2
66207: ARRAY
66208: IFFALSE 66231
// if not weapon in mc_allowed_tower_weapons [ i ] then
66210: LD_VAR 0 9
66214: PUSH
66215: LD_EXP 108
66219: PUSH
66220: LD_VAR 0 2
66224: ARRAY
66225: IN
66226: NOT
66227: IFFALSE 66231
// continue ;
66229: GO 65933
// end else
66231: GO 66296
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
66233: LD_ADDR_VAR 0 5
66237: PUSH
66238: LD_EXP 77
66242: PUSH
66243: LD_VAR 0 2
66247: ARRAY
66248: PPUSH
66249: LD_VAR 0 4
66253: PPUSH
66254: CALL 49887 0 2
66258: ST_TO_ADDR
// if not tmp2 then
66259: LD_VAR 0 5
66263: NOT
66264: IFFALSE 66268
// continue ;
66266: GO 65933
// tw := tmp2 [ 1 ] ;
66268: LD_ADDR_VAR 0 7
66272: PUSH
66273: LD_VAR 0 5
66277: PUSH
66278: LD_INT 1
66280: ARRAY
66281: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
66282: LD_ADDR_VAR 0 9
66286: PUSH
66287: LD_VAR 0 5
66291: PUSH
66292: LD_INT 2
66294: ARRAY
66295: ST_TO_ADDR
// end ; if not weapon then
66296: LD_VAR 0 9
66300: NOT
66301: IFFALSE 66305
// continue ;
66303: GO 65933
// ComPlaceWeapon ( tw , weapon ) ;
66305: LD_VAR 0 7
66309: PPUSH
66310: LD_VAR 0 9
66314: PPUSH
66315: CALL_OW 148
// end ;
66319: GO 65933
66321: POP
66322: POP
// end ;
66323: LD_VAR 0 1
66327: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
66328: LD_INT 0
66330: PPUSH
66331: PPUSH
66332: PPUSH
66333: PPUSH
66334: PPUSH
66335: PPUSH
66336: PPUSH
// if not mc_bases then
66337: LD_EXP 69
66341: NOT
66342: IFFALSE 66346
// exit ;
66344: GO 67114
// for i = 1 to mc_bases do
66346: LD_ADDR_VAR 0 2
66350: PUSH
66351: DOUBLE
66352: LD_INT 1
66354: DEC
66355: ST_TO_ADDR
66356: LD_EXP 69
66360: PUSH
66361: FOR_TO
66362: IFFALSE 67112
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
66364: LD_EXP 82
66368: PUSH
66369: LD_VAR 0 2
66373: ARRAY
66374: NOT
66375: PUSH
66376: LD_EXP 82
66380: PUSH
66381: LD_VAR 0 2
66385: ARRAY
66386: PUSH
66387: LD_EXP 83
66391: PUSH
66392: LD_VAR 0 2
66396: ARRAY
66397: EQUAL
66398: OR
66399: PUSH
66400: LD_EXP 92
66404: PUSH
66405: LD_VAR 0 2
66409: ARRAY
66410: OR
66411: IFFALSE 66415
// continue ;
66413: GO 66361
// if mc_miners [ i ] then
66415: LD_EXP 83
66419: PUSH
66420: LD_VAR 0 2
66424: ARRAY
66425: IFFALSE 66799
// begin for j = mc_miners [ i ] downto 1 do
66427: LD_ADDR_VAR 0 3
66431: PUSH
66432: DOUBLE
66433: LD_EXP 83
66437: PUSH
66438: LD_VAR 0 2
66442: ARRAY
66443: INC
66444: ST_TO_ADDR
66445: LD_INT 1
66447: PUSH
66448: FOR_DOWNTO
66449: IFFALSE 66797
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
66451: LD_EXP 83
66455: PUSH
66456: LD_VAR 0 2
66460: ARRAY
66461: PUSH
66462: LD_VAR 0 3
66466: ARRAY
66467: PPUSH
66468: CALL_OW 301
66472: PUSH
66473: LD_EXP 83
66477: PUSH
66478: LD_VAR 0 2
66482: ARRAY
66483: PUSH
66484: LD_VAR 0 3
66488: ARRAY
66489: PPUSH
66490: CALL_OW 257
66494: PUSH
66495: LD_INT 1
66497: NONEQUAL
66498: OR
66499: IFFALSE 66562
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
66501: LD_ADDR_VAR 0 5
66505: PUSH
66506: LD_EXP 83
66510: PUSH
66511: LD_VAR 0 2
66515: ARRAY
66516: PUSH
66517: LD_EXP 83
66521: PUSH
66522: LD_VAR 0 2
66526: ARRAY
66527: PUSH
66528: LD_VAR 0 3
66532: ARRAY
66533: DIFF
66534: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
66535: LD_ADDR_EXP 83
66539: PUSH
66540: LD_EXP 83
66544: PPUSH
66545: LD_VAR 0 2
66549: PPUSH
66550: LD_VAR 0 5
66554: PPUSH
66555: CALL_OW 1
66559: ST_TO_ADDR
// continue ;
66560: GO 66448
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
66562: LD_EXP 83
66566: PUSH
66567: LD_VAR 0 2
66571: ARRAY
66572: PUSH
66573: LD_VAR 0 3
66577: ARRAY
66578: PPUSH
66579: CALL_OW 257
66583: PUSH
66584: LD_INT 1
66586: EQUAL
66587: PUSH
66588: LD_EXP 83
66592: PUSH
66593: LD_VAR 0 2
66597: ARRAY
66598: PUSH
66599: LD_VAR 0 3
66603: ARRAY
66604: PPUSH
66605: CALL_OW 459
66609: NOT
66610: AND
66611: PUSH
66612: LD_EXP 83
66616: PUSH
66617: LD_VAR 0 2
66621: ARRAY
66622: PUSH
66623: LD_VAR 0 3
66627: ARRAY
66628: PPUSH
66629: CALL_OW 314
66633: NOT
66634: AND
66635: IFFALSE 66795
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
66637: LD_EXP 83
66641: PUSH
66642: LD_VAR 0 2
66646: ARRAY
66647: PUSH
66648: LD_VAR 0 3
66652: ARRAY
66653: PPUSH
66654: CALL_OW 310
66658: IFFALSE 66681
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
66660: LD_EXP 83
66664: PUSH
66665: LD_VAR 0 2
66669: ARRAY
66670: PUSH
66671: LD_VAR 0 3
66675: ARRAY
66676: PPUSH
66677: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
66681: LD_EXP 83
66685: PUSH
66686: LD_VAR 0 2
66690: ARRAY
66691: PUSH
66692: LD_VAR 0 3
66696: ARRAY
66697: PPUSH
66698: CALL_OW 314
66702: NOT
66703: IFFALSE 66795
// begin r := rand ( 1 , mc_mines [ i ] ) ;
66705: LD_ADDR_VAR 0 7
66709: PUSH
66710: LD_INT 1
66712: PPUSH
66713: LD_EXP 82
66717: PUSH
66718: LD_VAR 0 2
66722: ARRAY
66723: PPUSH
66724: CALL_OW 12
66728: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
66729: LD_EXP 83
66733: PUSH
66734: LD_VAR 0 2
66738: ARRAY
66739: PUSH
66740: LD_VAR 0 3
66744: ARRAY
66745: PPUSH
66746: LD_EXP 82
66750: PUSH
66751: LD_VAR 0 2
66755: ARRAY
66756: PUSH
66757: LD_VAR 0 7
66761: ARRAY
66762: PUSH
66763: LD_INT 1
66765: ARRAY
66766: PPUSH
66767: LD_EXP 82
66771: PUSH
66772: LD_VAR 0 2
66776: ARRAY
66777: PUSH
66778: LD_VAR 0 7
66782: ARRAY
66783: PUSH
66784: LD_INT 2
66786: ARRAY
66787: PPUSH
66788: LD_INT 0
66790: PPUSH
66791: CALL_OW 193
// end ; end ; end ;
66795: GO 66448
66797: POP
66798: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
66799: LD_ADDR_VAR 0 5
66803: PUSH
66804: LD_EXP 69
66808: PUSH
66809: LD_VAR 0 2
66813: ARRAY
66814: PPUSH
66815: LD_INT 2
66817: PUSH
66818: LD_INT 30
66820: PUSH
66821: LD_INT 4
66823: PUSH
66824: EMPTY
66825: LIST
66826: LIST
66827: PUSH
66828: LD_INT 30
66830: PUSH
66831: LD_INT 5
66833: PUSH
66834: EMPTY
66835: LIST
66836: LIST
66837: PUSH
66838: LD_INT 30
66840: PUSH
66841: LD_INT 32
66843: PUSH
66844: EMPTY
66845: LIST
66846: LIST
66847: PUSH
66848: EMPTY
66849: LIST
66850: LIST
66851: LIST
66852: LIST
66853: PPUSH
66854: CALL_OW 72
66858: ST_TO_ADDR
// if not tmp then
66859: LD_VAR 0 5
66863: NOT
66864: IFFALSE 66868
// continue ;
66866: GO 66361
// list := [ ] ;
66868: LD_ADDR_VAR 0 6
66872: PUSH
66873: EMPTY
66874: ST_TO_ADDR
// for j in tmp do
66875: LD_ADDR_VAR 0 3
66879: PUSH
66880: LD_VAR 0 5
66884: PUSH
66885: FOR_IN
66886: IFFALSE 66955
// begin for k in UnitsInside ( j ) do
66888: LD_ADDR_VAR 0 4
66892: PUSH
66893: LD_VAR 0 3
66897: PPUSH
66898: CALL_OW 313
66902: PUSH
66903: FOR_IN
66904: IFFALSE 66951
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
66906: LD_VAR 0 4
66910: PPUSH
66911: CALL_OW 257
66915: PUSH
66916: LD_INT 1
66918: EQUAL
66919: PUSH
66920: LD_VAR 0 4
66924: PPUSH
66925: CALL_OW 459
66929: NOT
66930: AND
66931: IFFALSE 66949
// list := list ^ k ;
66933: LD_ADDR_VAR 0 6
66937: PUSH
66938: LD_VAR 0 6
66942: PUSH
66943: LD_VAR 0 4
66947: ADD
66948: ST_TO_ADDR
66949: GO 66903
66951: POP
66952: POP
// end ;
66953: GO 66885
66955: POP
66956: POP
// list := list diff mc_miners [ i ] ;
66957: LD_ADDR_VAR 0 6
66961: PUSH
66962: LD_VAR 0 6
66966: PUSH
66967: LD_EXP 83
66971: PUSH
66972: LD_VAR 0 2
66976: ARRAY
66977: DIFF
66978: ST_TO_ADDR
// if not list then
66979: LD_VAR 0 6
66983: NOT
66984: IFFALSE 66988
// continue ;
66986: GO 66361
// k := mc_mines [ i ] - mc_miners [ i ] ;
66988: LD_ADDR_VAR 0 4
66992: PUSH
66993: LD_EXP 82
66997: PUSH
66998: LD_VAR 0 2
67002: ARRAY
67003: PUSH
67004: LD_EXP 83
67008: PUSH
67009: LD_VAR 0 2
67013: ARRAY
67014: MINUS
67015: ST_TO_ADDR
// if k > list then
67016: LD_VAR 0 4
67020: PUSH
67021: LD_VAR 0 6
67025: GREATER
67026: IFFALSE 67038
// k := list ;
67028: LD_ADDR_VAR 0 4
67032: PUSH
67033: LD_VAR 0 6
67037: ST_TO_ADDR
// for j = 1 to k do
67038: LD_ADDR_VAR 0 3
67042: PUSH
67043: DOUBLE
67044: LD_INT 1
67046: DEC
67047: ST_TO_ADDR
67048: LD_VAR 0 4
67052: PUSH
67053: FOR_TO
67054: IFFALSE 67108
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
67056: LD_ADDR_EXP 83
67060: PUSH
67061: LD_EXP 83
67065: PPUSH
67066: LD_VAR 0 2
67070: PUSH
67071: LD_EXP 83
67075: PUSH
67076: LD_VAR 0 2
67080: ARRAY
67081: PUSH
67082: LD_INT 1
67084: PLUS
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: PPUSH
67090: LD_VAR 0 6
67094: PUSH
67095: LD_VAR 0 3
67099: ARRAY
67100: PPUSH
67101: CALL 18588 0 3
67105: ST_TO_ADDR
67106: GO 67053
67108: POP
67109: POP
// end ;
67110: GO 66361
67112: POP
67113: POP
// end ;
67114: LD_VAR 0 1
67118: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
67119: LD_INT 0
67121: PPUSH
67122: PPUSH
67123: PPUSH
67124: PPUSH
67125: PPUSH
67126: PPUSH
67127: PPUSH
67128: PPUSH
67129: PPUSH
67130: PPUSH
67131: PPUSH
// if not mc_bases then
67132: LD_EXP 69
67136: NOT
67137: IFFALSE 67141
// exit ;
67139: GO 68964
// for i = 1 to mc_bases do
67141: LD_ADDR_VAR 0 2
67145: PUSH
67146: DOUBLE
67147: LD_INT 1
67149: DEC
67150: ST_TO_ADDR
67151: LD_EXP 69
67155: PUSH
67156: FOR_TO
67157: IFFALSE 68962
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
67159: LD_EXP 69
67163: PUSH
67164: LD_VAR 0 2
67168: ARRAY
67169: NOT
67170: PUSH
67171: LD_EXP 76
67175: PUSH
67176: LD_VAR 0 2
67180: ARRAY
67181: OR
67182: IFFALSE 67186
// continue ;
67184: GO 67156
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
67186: LD_EXP 85
67190: PUSH
67191: LD_VAR 0 2
67195: ARRAY
67196: NOT
67197: PUSH
67198: LD_EXP 86
67202: PUSH
67203: LD_VAR 0 2
67207: ARRAY
67208: AND
67209: IFFALSE 67247
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
67211: LD_ADDR_EXP 86
67215: PUSH
67216: LD_EXP 86
67220: PPUSH
67221: LD_VAR 0 2
67225: PPUSH
67226: EMPTY
67227: PPUSH
67228: CALL_OW 1
67232: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
67233: LD_VAR 0 2
67237: PPUSH
67238: LD_INT 107
67240: PPUSH
67241: CALL 58015 0 2
// continue ;
67245: GO 67156
// end ; target := [ ] ;
67247: LD_ADDR_VAR 0 7
67251: PUSH
67252: EMPTY
67253: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
67254: LD_ADDR_VAR 0 6
67258: PUSH
67259: LD_EXP 69
67263: PUSH
67264: LD_VAR 0 2
67268: ARRAY
67269: PUSH
67270: LD_INT 1
67272: ARRAY
67273: PPUSH
67274: CALL_OW 255
67278: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67279: LD_ADDR_VAR 0 9
67283: PUSH
67284: LD_EXP 69
67288: PUSH
67289: LD_VAR 0 2
67293: ARRAY
67294: PPUSH
67295: LD_INT 2
67297: PUSH
67298: LD_INT 30
67300: PUSH
67301: LD_INT 0
67303: PUSH
67304: EMPTY
67305: LIST
67306: LIST
67307: PUSH
67308: LD_INT 30
67310: PUSH
67311: LD_INT 1
67313: PUSH
67314: EMPTY
67315: LIST
67316: LIST
67317: PUSH
67318: EMPTY
67319: LIST
67320: LIST
67321: LIST
67322: PPUSH
67323: CALL_OW 72
67327: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
67328: LD_ADDR_VAR 0 3
67332: PUSH
67333: DOUBLE
67334: LD_EXP 85
67338: PUSH
67339: LD_VAR 0 2
67343: ARRAY
67344: INC
67345: ST_TO_ADDR
67346: LD_INT 1
67348: PUSH
67349: FOR_DOWNTO
67350: IFFALSE 67595
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
67352: LD_EXP 85
67356: PUSH
67357: LD_VAR 0 2
67361: ARRAY
67362: PUSH
67363: LD_VAR 0 3
67367: ARRAY
67368: PUSH
67369: LD_INT 2
67371: ARRAY
67372: PPUSH
67373: LD_EXP 85
67377: PUSH
67378: LD_VAR 0 2
67382: ARRAY
67383: PUSH
67384: LD_VAR 0 3
67388: ARRAY
67389: PUSH
67390: LD_INT 3
67392: ARRAY
67393: PPUSH
67394: CALL_OW 488
67398: PUSH
67399: LD_EXP 85
67403: PUSH
67404: LD_VAR 0 2
67408: ARRAY
67409: PUSH
67410: LD_VAR 0 3
67414: ARRAY
67415: PUSH
67416: LD_INT 2
67418: ARRAY
67419: PPUSH
67420: LD_EXP 85
67424: PUSH
67425: LD_VAR 0 2
67429: ARRAY
67430: PUSH
67431: LD_VAR 0 3
67435: ARRAY
67436: PUSH
67437: LD_INT 3
67439: ARRAY
67440: PPUSH
67441: CALL_OW 284
67445: PUSH
67446: LD_INT 0
67448: EQUAL
67449: AND
67450: IFFALSE 67505
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
67452: LD_ADDR_VAR 0 5
67456: PUSH
67457: LD_EXP 85
67461: PUSH
67462: LD_VAR 0 2
67466: ARRAY
67467: PPUSH
67468: LD_VAR 0 3
67472: PPUSH
67473: CALL_OW 3
67477: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
67478: LD_ADDR_EXP 85
67482: PUSH
67483: LD_EXP 85
67487: PPUSH
67488: LD_VAR 0 2
67492: PPUSH
67493: LD_VAR 0 5
67497: PPUSH
67498: CALL_OW 1
67502: ST_TO_ADDR
// continue ;
67503: GO 67349
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
67505: LD_VAR 0 6
67509: PPUSH
67510: LD_EXP 85
67514: PUSH
67515: LD_VAR 0 2
67519: ARRAY
67520: PUSH
67521: LD_VAR 0 3
67525: ARRAY
67526: PUSH
67527: LD_INT 2
67529: ARRAY
67530: PPUSH
67531: LD_EXP 85
67535: PUSH
67536: LD_VAR 0 2
67540: ARRAY
67541: PUSH
67542: LD_VAR 0 3
67546: ARRAY
67547: PUSH
67548: LD_INT 3
67550: ARRAY
67551: PPUSH
67552: LD_INT 30
67554: PPUSH
67555: CALL 19484 0 4
67559: PUSH
67560: LD_INT 4
67562: ARRAY
67563: PUSH
67564: LD_INT 0
67566: EQUAL
67567: IFFALSE 67593
// begin target := mc_crates [ i ] [ j ] ;
67569: LD_ADDR_VAR 0 7
67573: PUSH
67574: LD_EXP 85
67578: PUSH
67579: LD_VAR 0 2
67583: ARRAY
67584: PUSH
67585: LD_VAR 0 3
67589: ARRAY
67590: ST_TO_ADDR
// break ;
67591: GO 67595
// end ; end ;
67593: GO 67349
67595: POP
67596: POP
// if not target then
67597: LD_VAR 0 7
67601: NOT
67602: IFFALSE 67606
// continue ;
67604: GO 67156
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
67606: LD_ADDR_VAR 0 8
67610: PUSH
67611: LD_EXP 88
67615: PUSH
67616: LD_VAR 0 2
67620: ARRAY
67621: PPUSH
67622: LD_INT 2
67624: PUSH
67625: LD_INT 3
67627: PUSH
67628: LD_INT 58
67630: PUSH
67631: EMPTY
67632: LIST
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PUSH
67638: LD_INT 61
67640: PUSH
67641: EMPTY
67642: LIST
67643: PUSH
67644: LD_INT 33
67646: PUSH
67647: LD_INT 5
67649: PUSH
67650: EMPTY
67651: LIST
67652: LIST
67653: PUSH
67654: LD_INT 33
67656: PUSH
67657: LD_INT 3
67659: PUSH
67660: EMPTY
67661: LIST
67662: LIST
67663: PUSH
67664: EMPTY
67665: LIST
67666: LIST
67667: LIST
67668: LIST
67669: LIST
67670: PUSH
67671: LD_INT 2
67673: PUSH
67674: LD_INT 34
67676: PUSH
67677: LD_INT 32
67679: PUSH
67680: EMPTY
67681: LIST
67682: LIST
67683: PUSH
67684: LD_INT 34
67686: PUSH
67687: LD_INT 51
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: PUSH
67694: LD_INT 34
67696: PUSH
67697: LD_INT 12
67699: PUSH
67700: EMPTY
67701: LIST
67702: LIST
67703: PUSH
67704: EMPTY
67705: LIST
67706: LIST
67707: LIST
67708: LIST
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: PPUSH
67714: CALL_OW 72
67718: ST_TO_ADDR
// if not cargo then
67719: LD_VAR 0 8
67723: NOT
67724: IFFALSE 68430
// begin if mc_crates_collector [ i ] < 5 then
67726: LD_EXP 86
67730: PUSH
67731: LD_VAR 0 2
67735: ARRAY
67736: PUSH
67737: LD_INT 5
67739: LESS
67740: IFFALSE 68106
// begin if mc_ape [ i ] then
67742: LD_EXP 98
67746: PUSH
67747: LD_VAR 0 2
67751: ARRAY
67752: IFFALSE 67799
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
67754: LD_ADDR_VAR 0 5
67758: PUSH
67759: LD_EXP 98
67763: PUSH
67764: LD_VAR 0 2
67768: ARRAY
67769: PPUSH
67770: LD_INT 25
67772: PUSH
67773: LD_INT 16
67775: PUSH
67776: EMPTY
67777: LIST
67778: LIST
67779: PUSH
67780: LD_INT 24
67782: PUSH
67783: LD_INT 750
67785: PUSH
67786: EMPTY
67787: LIST
67788: LIST
67789: PUSH
67790: EMPTY
67791: LIST
67792: LIST
67793: PPUSH
67794: CALL_OW 72
67798: ST_TO_ADDR
// if not tmp then
67799: LD_VAR 0 5
67803: NOT
67804: IFFALSE 67851
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
67806: LD_ADDR_VAR 0 5
67810: PUSH
67811: LD_EXP 69
67815: PUSH
67816: LD_VAR 0 2
67820: ARRAY
67821: PPUSH
67822: LD_INT 25
67824: PUSH
67825: LD_INT 2
67827: PUSH
67828: EMPTY
67829: LIST
67830: LIST
67831: PUSH
67832: LD_INT 24
67834: PUSH
67835: LD_INT 750
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: PUSH
67842: EMPTY
67843: LIST
67844: LIST
67845: PPUSH
67846: CALL_OW 72
67850: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
67851: LD_EXP 98
67855: PUSH
67856: LD_VAR 0 2
67860: ARRAY
67861: PUSH
67862: LD_EXP 69
67866: PUSH
67867: LD_VAR 0 2
67871: ARRAY
67872: PPUSH
67873: LD_INT 25
67875: PUSH
67876: LD_INT 2
67878: PUSH
67879: EMPTY
67880: LIST
67881: LIST
67882: PUSH
67883: LD_INT 24
67885: PUSH
67886: LD_INT 750
67888: PUSH
67889: EMPTY
67890: LIST
67891: LIST
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: PPUSH
67897: CALL_OW 72
67901: AND
67902: PUSH
67903: LD_VAR 0 5
67907: PUSH
67908: LD_INT 5
67910: LESS
67911: AND
67912: IFFALSE 67994
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
67914: LD_ADDR_VAR 0 3
67918: PUSH
67919: LD_EXP 69
67923: PUSH
67924: LD_VAR 0 2
67928: ARRAY
67929: PPUSH
67930: LD_INT 25
67932: PUSH
67933: LD_INT 2
67935: PUSH
67936: EMPTY
67937: LIST
67938: LIST
67939: PUSH
67940: LD_INT 24
67942: PUSH
67943: LD_INT 750
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: EMPTY
67951: LIST
67952: LIST
67953: PPUSH
67954: CALL_OW 72
67958: PUSH
67959: FOR_IN
67960: IFFALSE 67992
// begin tmp := tmp union j ;
67962: LD_ADDR_VAR 0 5
67966: PUSH
67967: LD_VAR 0 5
67971: PUSH
67972: LD_VAR 0 3
67976: UNION
67977: ST_TO_ADDR
// if tmp >= 5 then
67978: LD_VAR 0 5
67982: PUSH
67983: LD_INT 5
67985: GREATEREQUAL
67986: IFFALSE 67990
// break ;
67988: GO 67992
// end ;
67990: GO 67959
67992: POP
67993: POP
// end ; if not tmp then
67994: LD_VAR 0 5
67998: NOT
67999: IFFALSE 68003
// continue ;
68001: GO 67156
// for j in tmp do
68003: LD_ADDR_VAR 0 3
68007: PUSH
68008: LD_VAR 0 5
68012: PUSH
68013: FOR_IN
68014: IFFALSE 68104
// if not GetTag ( j ) then
68016: LD_VAR 0 3
68020: PPUSH
68021: CALL_OW 110
68025: NOT
68026: IFFALSE 68102
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
68028: LD_ADDR_EXP 86
68032: PUSH
68033: LD_EXP 86
68037: PPUSH
68038: LD_VAR 0 2
68042: PUSH
68043: LD_EXP 86
68047: PUSH
68048: LD_VAR 0 2
68052: ARRAY
68053: PUSH
68054: LD_INT 1
68056: PLUS
68057: PUSH
68058: EMPTY
68059: LIST
68060: LIST
68061: PPUSH
68062: LD_VAR 0 3
68066: PPUSH
68067: CALL 18588 0 3
68071: ST_TO_ADDR
// SetTag ( j , 107 ) ;
68072: LD_VAR 0 3
68076: PPUSH
68077: LD_INT 107
68079: PPUSH
68080: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
68084: LD_EXP 86
68088: PUSH
68089: LD_VAR 0 2
68093: ARRAY
68094: PUSH
68095: LD_INT 5
68097: GREATEREQUAL
68098: IFFALSE 68102
// break ;
68100: GO 68104
// end ;
68102: GO 68013
68104: POP
68105: POP
// end ; if mc_crates_collector [ i ] and target then
68106: LD_EXP 86
68110: PUSH
68111: LD_VAR 0 2
68115: ARRAY
68116: PUSH
68117: LD_VAR 0 7
68121: AND
68122: IFFALSE 68428
// begin if mc_crates_collector [ i ] < target [ 1 ] then
68124: LD_EXP 86
68128: PUSH
68129: LD_VAR 0 2
68133: ARRAY
68134: PUSH
68135: LD_VAR 0 7
68139: PUSH
68140: LD_INT 1
68142: ARRAY
68143: LESS
68144: IFFALSE 68164
// tmp := mc_crates_collector [ i ] else
68146: LD_ADDR_VAR 0 5
68150: PUSH
68151: LD_EXP 86
68155: PUSH
68156: LD_VAR 0 2
68160: ARRAY
68161: ST_TO_ADDR
68162: GO 68178
// tmp := target [ 1 ] ;
68164: LD_ADDR_VAR 0 5
68168: PUSH
68169: LD_VAR 0 7
68173: PUSH
68174: LD_INT 1
68176: ARRAY
68177: ST_TO_ADDR
// k := 0 ;
68178: LD_ADDR_VAR 0 4
68182: PUSH
68183: LD_INT 0
68185: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
68186: LD_ADDR_VAR 0 3
68190: PUSH
68191: LD_EXP 86
68195: PUSH
68196: LD_VAR 0 2
68200: ARRAY
68201: PUSH
68202: FOR_IN
68203: IFFALSE 68426
// begin k := k + 1 ;
68205: LD_ADDR_VAR 0 4
68209: PUSH
68210: LD_VAR 0 4
68214: PUSH
68215: LD_INT 1
68217: PLUS
68218: ST_TO_ADDR
// if k > tmp then
68219: LD_VAR 0 4
68223: PUSH
68224: LD_VAR 0 5
68228: GREATER
68229: IFFALSE 68233
// break ;
68231: GO 68426
// if not GetClass ( j ) in [ 2 , 16 ] then
68233: LD_VAR 0 3
68237: PPUSH
68238: CALL_OW 257
68242: PUSH
68243: LD_INT 2
68245: PUSH
68246: LD_INT 16
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: IN
68253: NOT
68254: IFFALSE 68307
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
68256: LD_ADDR_EXP 86
68260: PUSH
68261: LD_EXP 86
68265: PPUSH
68266: LD_VAR 0 2
68270: PPUSH
68271: LD_EXP 86
68275: PUSH
68276: LD_VAR 0 2
68280: ARRAY
68281: PUSH
68282: LD_VAR 0 3
68286: DIFF
68287: PPUSH
68288: CALL_OW 1
68292: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68293: LD_VAR 0 3
68297: PPUSH
68298: LD_INT 0
68300: PPUSH
68301: CALL_OW 109
// continue ;
68305: GO 68202
// end ; if IsInUnit ( j ) then
68307: LD_VAR 0 3
68311: PPUSH
68312: CALL_OW 310
68316: IFFALSE 68327
// ComExitBuilding ( j ) ;
68318: LD_VAR 0 3
68322: PPUSH
68323: CALL_OW 122
// wait ( 3 ) ;
68327: LD_INT 3
68329: PPUSH
68330: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
68334: LD_VAR 0 3
68338: PPUSH
68339: CALL_OW 314
68343: PUSH
68344: LD_VAR 0 6
68348: PPUSH
68349: LD_VAR 0 7
68353: PUSH
68354: LD_INT 2
68356: ARRAY
68357: PPUSH
68358: LD_VAR 0 7
68362: PUSH
68363: LD_INT 3
68365: ARRAY
68366: PPUSH
68367: LD_INT 30
68369: PPUSH
68370: CALL 19484 0 4
68374: PUSH
68375: LD_INT 4
68377: ARRAY
68378: AND
68379: IFFALSE 68397
// ComStandNearbyBuilding ( j , depot ) else
68381: LD_VAR 0 3
68385: PPUSH
68386: LD_VAR 0 9
68390: PPUSH
68391: CALL 15166 0 2
68395: GO 68424
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68397: LD_VAR 0 3
68401: PPUSH
68402: LD_VAR 0 7
68406: PUSH
68407: LD_INT 2
68409: ARRAY
68410: PPUSH
68411: LD_VAR 0 7
68415: PUSH
68416: LD_INT 3
68418: ARRAY
68419: PPUSH
68420: CALL_OW 117
// end ;
68424: GO 68202
68426: POP
68427: POP
// end ; end else
68428: GO 68960
// begin for j in cargo do
68430: LD_ADDR_VAR 0 3
68434: PUSH
68435: LD_VAR 0 8
68439: PUSH
68440: FOR_IN
68441: IFFALSE 68958
// begin if GetTag ( j ) <> 0 then
68443: LD_VAR 0 3
68447: PPUSH
68448: CALL_OW 110
68452: PUSH
68453: LD_INT 0
68455: NONEQUAL
68456: IFFALSE 68460
// continue ;
68458: GO 68440
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
68460: LD_VAR 0 3
68464: PPUSH
68465: CALL_OW 256
68469: PUSH
68470: LD_INT 1000
68472: LESS
68473: PUSH
68474: LD_VAR 0 3
68478: PPUSH
68479: LD_EXP 93
68483: PUSH
68484: LD_VAR 0 2
68488: ARRAY
68489: PPUSH
68490: CALL_OW 308
68494: NOT
68495: AND
68496: IFFALSE 68518
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68498: LD_VAR 0 3
68502: PPUSH
68503: LD_EXP 93
68507: PUSH
68508: LD_VAR 0 2
68512: ARRAY
68513: PPUSH
68514: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
68518: LD_VAR 0 3
68522: PPUSH
68523: CALL_OW 256
68527: PUSH
68528: LD_INT 1000
68530: LESS
68531: PUSH
68532: LD_VAR 0 3
68536: PPUSH
68537: LD_EXP 93
68541: PUSH
68542: LD_VAR 0 2
68546: ARRAY
68547: PPUSH
68548: CALL_OW 308
68552: AND
68553: IFFALSE 68557
// continue ;
68555: GO 68440
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
68557: LD_VAR 0 3
68561: PPUSH
68562: CALL_OW 262
68566: PUSH
68567: LD_INT 2
68569: EQUAL
68570: PUSH
68571: LD_VAR 0 3
68575: PPUSH
68576: CALL_OW 261
68580: PUSH
68581: LD_INT 15
68583: LESS
68584: AND
68585: IFFALSE 68589
// continue ;
68587: GO 68440
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
68589: LD_VAR 0 3
68593: PPUSH
68594: CALL_OW 262
68598: PUSH
68599: LD_INT 1
68601: EQUAL
68602: PUSH
68603: LD_VAR 0 3
68607: PPUSH
68608: CALL_OW 261
68612: PUSH
68613: LD_INT 10
68615: LESS
68616: AND
68617: IFFALSE 68897
// begin if not depot then
68619: LD_VAR 0 9
68623: NOT
68624: IFFALSE 68628
// continue ;
68626: GO 68440
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
68628: LD_VAR 0 3
68632: PPUSH
68633: LD_VAR 0 9
68637: PPUSH
68638: LD_VAR 0 3
68642: PPUSH
68643: CALL_OW 74
68647: PPUSH
68648: CALL_OW 296
68652: PUSH
68653: LD_INT 6
68655: LESS
68656: IFFALSE 68672
// SetFuel ( j , 100 ) else
68658: LD_VAR 0 3
68662: PPUSH
68663: LD_INT 100
68665: PPUSH
68666: CALL_OW 240
68670: GO 68897
// if GetFuel ( j ) = 0 then
68672: LD_VAR 0 3
68676: PPUSH
68677: CALL_OW 261
68681: PUSH
68682: LD_INT 0
68684: EQUAL
68685: IFFALSE 68897
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
68687: LD_ADDR_EXP 88
68691: PUSH
68692: LD_EXP 88
68696: PPUSH
68697: LD_VAR 0 2
68701: PPUSH
68702: LD_EXP 88
68706: PUSH
68707: LD_VAR 0 2
68711: ARRAY
68712: PUSH
68713: LD_VAR 0 3
68717: DIFF
68718: PPUSH
68719: CALL_OW 1
68723: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
68724: LD_VAR 0 3
68728: PPUSH
68729: CALL_OW 263
68733: PUSH
68734: LD_INT 1
68736: EQUAL
68737: IFFALSE 68753
// ComExitVehicle ( IsInUnit ( j ) ) ;
68739: LD_VAR 0 3
68743: PPUSH
68744: CALL_OW 310
68748: PPUSH
68749: CALL_OW 121
// if GetControl ( j ) = control_remote then
68753: LD_VAR 0 3
68757: PPUSH
68758: CALL_OW 263
68762: PUSH
68763: LD_INT 2
68765: EQUAL
68766: IFFALSE 68777
// ComUnlink ( j ) ;
68768: LD_VAR 0 3
68772: PPUSH
68773: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
68777: LD_ADDR_VAR 0 10
68781: PUSH
68782: LD_VAR 0 2
68786: PPUSH
68787: LD_INT 3
68789: PPUSH
68790: CALL 78536 0 2
68794: ST_TO_ADDR
// if fac then
68795: LD_VAR 0 10
68799: IFFALSE 68895
// begin for k in fac do
68801: LD_ADDR_VAR 0 4
68805: PUSH
68806: LD_VAR 0 10
68810: PUSH
68811: FOR_IN
68812: IFFALSE 68893
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
68814: LD_ADDR_VAR 0 11
68818: PUSH
68819: LD_VAR 0 10
68823: PPUSH
68824: LD_VAR 0 3
68828: PPUSH
68829: CALL_OW 265
68833: PPUSH
68834: LD_VAR 0 3
68838: PPUSH
68839: CALL_OW 262
68843: PPUSH
68844: LD_VAR 0 3
68848: PPUSH
68849: CALL_OW 263
68853: PPUSH
68854: LD_VAR 0 3
68858: PPUSH
68859: CALL_OW 264
68863: PPUSH
68864: CALL 16084 0 5
68868: ST_TO_ADDR
// if components then
68869: LD_VAR 0 11
68873: IFFALSE 68891
// begin MC_InsertProduceList ( i , components ) ;
68875: LD_VAR 0 2
68879: PPUSH
68880: LD_VAR 0 11
68884: PPUSH
68885: CALL 78081 0 2
// break ;
68889: GO 68893
// end ; end ;
68891: GO 68811
68893: POP
68894: POP
// end ; continue ;
68895: GO 68440
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
68897: LD_VAR 0 3
68901: PPUSH
68902: LD_INT 1
68904: PPUSH
68905: CALL_OW 289
68909: PUSH
68910: LD_INT 100
68912: LESS
68913: PUSH
68914: LD_VAR 0 3
68918: PPUSH
68919: CALL_OW 314
68923: NOT
68924: AND
68925: IFFALSE 68954
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68927: LD_VAR 0 3
68931: PPUSH
68932: LD_VAR 0 7
68936: PUSH
68937: LD_INT 2
68939: ARRAY
68940: PPUSH
68941: LD_VAR 0 7
68945: PUSH
68946: LD_INT 3
68948: ARRAY
68949: PPUSH
68950: CALL_OW 117
// break ;
68954: GO 68958
// end ;
68956: GO 68440
68958: POP
68959: POP
// end ; end ;
68960: GO 67156
68962: POP
68963: POP
// end ;
68964: LD_VAR 0 1
68968: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
68969: LD_INT 0
68971: PPUSH
68972: PPUSH
68973: PPUSH
68974: PPUSH
// if not mc_bases then
68975: LD_EXP 69
68979: NOT
68980: IFFALSE 68984
// exit ;
68982: GO 69145
// for i = 1 to mc_bases do
68984: LD_ADDR_VAR 0 2
68988: PUSH
68989: DOUBLE
68990: LD_INT 1
68992: DEC
68993: ST_TO_ADDR
68994: LD_EXP 69
68998: PUSH
68999: FOR_TO
69000: IFFALSE 69143
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
69002: LD_ADDR_VAR 0 4
69006: PUSH
69007: LD_EXP 88
69011: PUSH
69012: LD_VAR 0 2
69016: ARRAY
69017: PUSH
69018: LD_EXP 91
69022: PUSH
69023: LD_VAR 0 2
69027: ARRAY
69028: UNION
69029: PPUSH
69030: LD_INT 33
69032: PUSH
69033: LD_INT 2
69035: PUSH
69036: EMPTY
69037: LIST
69038: LIST
69039: PPUSH
69040: CALL_OW 72
69044: ST_TO_ADDR
// if tmp then
69045: LD_VAR 0 4
69049: IFFALSE 69141
// for j in tmp do
69051: LD_ADDR_VAR 0 3
69055: PUSH
69056: LD_VAR 0 4
69060: PUSH
69061: FOR_IN
69062: IFFALSE 69139
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
69064: LD_VAR 0 3
69068: PPUSH
69069: CALL_OW 312
69073: NOT
69074: PUSH
69075: LD_VAR 0 3
69079: PPUSH
69080: CALL_OW 256
69084: PUSH
69085: LD_INT 250
69087: GREATEREQUAL
69088: AND
69089: IFFALSE 69102
// Connect ( j ) else
69091: LD_VAR 0 3
69095: PPUSH
69096: CALL 21559 0 1
69100: GO 69137
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
69102: LD_VAR 0 3
69106: PPUSH
69107: CALL_OW 256
69111: PUSH
69112: LD_INT 250
69114: LESS
69115: PUSH
69116: LD_VAR 0 3
69120: PPUSH
69121: CALL_OW 312
69125: AND
69126: IFFALSE 69137
// ComUnlink ( j ) ;
69128: LD_VAR 0 3
69132: PPUSH
69133: CALL_OW 136
69137: GO 69061
69139: POP
69140: POP
// end ;
69141: GO 68999
69143: POP
69144: POP
// end ;
69145: LD_VAR 0 1
69149: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
69150: LD_INT 0
69152: PPUSH
69153: PPUSH
69154: PPUSH
69155: PPUSH
69156: PPUSH
// if not mc_bases then
69157: LD_EXP 69
69161: NOT
69162: IFFALSE 69166
// exit ;
69164: GO 69611
// for i = 1 to mc_bases do
69166: LD_ADDR_VAR 0 2
69170: PUSH
69171: DOUBLE
69172: LD_INT 1
69174: DEC
69175: ST_TO_ADDR
69176: LD_EXP 69
69180: PUSH
69181: FOR_TO
69182: IFFALSE 69609
// begin if not mc_produce [ i ] then
69184: LD_EXP 90
69188: PUSH
69189: LD_VAR 0 2
69193: ARRAY
69194: NOT
69195: IFFALSE 69199
// continue ;
69197: GO 69181
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69199: LD_ADDR_VAR 0 5
69203: PUSH
69204: LD_EXP 69
69208: PUSH
69209: LD_VAR 0 2
69213: ARRAY
69214: PPUSH
69215: LD_INT 30
69217: PUSH
69218: LD_INT 3
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: PPUSH
69225: CALL_OW 72
69229: ST_TO_ADDR
// if not fac then
69230: LD_VAR 0 5
69234: NOT
69235: IFFALSE 69239
// continue ;
69237: GO 69181
// for j in fac do
69239: LD_ADDR_VAR 0 3
69243: PUSH
69244: LD_VAR 0 5
69248: PUSH
69249: FOR_IN
69250: IFFALSE 69605
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
69252: LD_VAR 0 3
69256: PPUSH
69257: CALL_OW 461
69261: PUSH
69262: LD_INT 2
69264: NONEQUAL
69265: PUSH
69266: LD_VAR 0 3
69270: PPUSH
69271: LD_INT 15
69273: PPUSH
69274: CALL 21187 0 2
69278: PUSH
69279: LD_INT 4
69281: ARRAY
69282: OR
69283: IFFALSE 69287
// continue ;
69285: GO 69249
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
69287: LD_VAR 0 3
69291: PPUSH
69292: LD_EXP 90
69296: PUSH
69297: LD_VAR 0 2
69301: ARRAY
69302: PUSH
69303: LD_INT 1
69305: ARRAY
69306: PUSH
69307: LD_INT 1
69309: ARRAY
69310: PPUSH
69311: LD_EXP 90
69315: PUSH
69316: LD_VAR 0 2
69320: ARRAY
69321: PUSH
69322: LD_INT 1
69324: ARRAY
69325: PUSH
69326: LD_INT 2
69328: ARRAY
69329: PPUSH
69330: LD_EXP 90
69334: PUSH
69335: LD_VAR 0 2
69339: ARRAY
69340: PUSH
69341: LD_INT 1
69343: ARRAY
69344: PUSH
69345: LD_INT 3
69347: ARRAY
69348: PPUSH
69349: LD_EXP 90
69353: PUSH
69354: LD_VAR 0 2
69358: ARRAY
69359: PUSH
69360: LD_INT 1
69362: ARRAY
69363: PUSH
69364: LD_INT 4
69366: ARRAY
69367: PPUSH
69368: CALL_OW 448
69372: PUSH
69373: LD_VAR 0 3
69377: PPUSH
69378: LD_EXP 90
69382: PUSH
69383: LD_VAR 0 2
69387: ARRAY
69388: PUSH
69389: LD_INT 1
69391: ARRAY
69392: PUSH
69393: LD_INT 1
69395: ARRAY
69396: PUSH
69397: LD_EXP 90
69401: PUSH
69402: LD_VAR 0 2
69406: ARRAY
69407: PUSH
69408: LD_INT 1
69410: ARRAY
69411: PUSH
69412: LD_INT 2
69414: ARRAY
69415: PUSH
69416: LD_EXP 90
69420: PUSH
69421: LD_VAR 0 2
69425: ARRAY
69426: PUSH
69427: LD_INT 1
69429: ARRAY
69430: PUSH
69431: LD_INT 3
69433: ARRAY
69434: PUSH
69435: LD_EXP 90
69439: PUSH
69440: LD_VAR 0 2
69444: ARRAY
69445: PUSH
69446: LD_INT 1
69448: ARRAY
69449: PUSH
69450: LD_INT 4
69452: ARRAY
69453: PUSH
69454: EMPTY
69455: LIST
69456: LIST
69457: LIST
69458: LIST
69459: PPUSH
69460: CALL 24954 0 2
69464: AND
69465: IFFALSE 69603
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
69467: LD_VAR 0 3
69471: PPUSH
69472: LD_EXP 90
69476: PUSH
69477: LD_VAR 0 2
69481: ARRAY
69482: PUSH
69483: LD_INT 1
69485: ARRAY
69486: PUSH
69487: LD_INT 1
69489: ARRAY
69490: PPUSH
69491: LD_EXP 90
69495: PUSH
69496: LD_VAR 0 2
69500: ARRAY
69501: PUSH
69502: LD_INT 1
69504: ARRAY
69505: PUSH
69506: LD_INT 2
69508: ARRAY
69509: PPUSH
69510: LD_EXP 90
69514: PUSH
69515: LD_VAR 0 2
69519: ARRAY
69520: PUSH
69521: LD_INT 1
69523: ARRAY
69524: PUSH
69525: LD_INT 3
69527: ARRAY
69528: PPUSH
69529: LD_EXP 90
69533: PUSH
69534: LD_VAR 0 2
69538: ARRAY
69539: PUSH
69540: LD_INT 1
69542: ARRAY
69543: PUSH
69544: LD_INT 4
69546: ARRAY
69547: PPUSH
69548: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
69552: LD_ADDR_VAR 0 4
69556: PUSH
69557: LD_EXP 90
69561: PUSH
69562: LD_VAR 0 2
69566: ARRAY
69567: PPUSH
69568: LD_INT 1
69570: PPUSH
69571: CALL_OW 3
69575: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
69576: LD_ADDR_EXP 90
69580: PUSH
69581: LD_EXP 90
69585: PPUSH
69586: LD_VAR 0 2
69590: PPUSH
69591: LD_VAR 0 4
69595: PPUSH
69596: CALL_OW 1
69600: ST_TO_ADDR
// break ;
69601: GO 69605
// end ; end ;
69603: GO 69249
69605: POP
69606: POP
// end ;
69607: GO 69181
69609: POP
69610: POP
// end ;
69611: LD_VAR 0 1
69615: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
69616: LD_INT 0
69618: PPUSH
69619: PPUSH
69620: PPUSH
// if not mc_bases then
69621: LD_EXP 69
69625: NOT
69626: IFFALSE 69630
// exit ;
69628: GO 69719
// for i = 1 to mc_bases do
69630: LD_ADDR_VAR 0 2
69634: PUSH
69635: DOUBLE
69636: LD_INT 1
69638: DEC
69639: ST_TO_ADDR
69640: LD_EXP 69
69644: PUSH
69645: FOR_TO
69646: IFFALSE 69717
// begin if mc_attack [ i ] then
69648: LD_EXP 89
69652: PUSH
69653: LD_VAR 0 2
69657: ARRAY
69658: IFFALSE 69715
// begin tmp := mc_attack [ i ] [ 1 ] ;
69660: LD_ADDR_VAR 0 3
69664: PUSH
69665: LD_EXP 89
69669: PUSH
69670: LD_VAR 0 2
69674: ARRAY
69675: PUSH
69676: LD_INT 1
69678: ARRAY
69679: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
69680: LD_ADDR_EXP 89
69684: PUSH
69685: LD_EXP 89
69689: PPUSH
69690: LD_VAR 0 2
69694: PPUSH
69695: EMPTY
69696: PPUSH
69697: CALL_OW 1
69701: ST_TO_ADDR
// Attack ( tmp ) ;
69702: LD_VAR 0 3
69706: PPUSH
69707: CALL 103456 0 1
// exit ;
69711: POP
69712: POP
69713: GO 69719
// end ; end ;
69715: GO 69645
69717: POP
69718: POP
// end ;
69719: LD_VAR 0 1
69723: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
69724: LD_INT 0
69726: PPUSH
69727: PPUSH
69728: PPUSH
69729: PPUSH
69730: PPUSH
69731: PPUSH
69732: PPUSH
// if not mc_bases then
69733: LD_EXP 69
69737: NOT
69738: IFFALSE 69742
// exit ;
69740: GO 70599
// for i = 1 to mc_bases do
69742: LD_ADDR_VAR 0 2
69746: PUSH
69747: DOUBLE
69748: LD_INT 1
69750: DEC
69751: ST_TO_ADDR
69752: LD_EXP 69
69756: PUSH
69757: FOR_TO
69758: IFFALSE 70597
// begin if not mc_bases [ i ] then
69760: LD_EXP 69
69764: PUSH
69765: LD_VAR 0 2
69769: ARRAY
69770: NOT
69771: IFFALSE 69775
// continue ;
69773: GO 69757
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
69775: LD_ADDR_VAR 0 7
69779: PUSH
69780: LD_EXP 69
69784: PUSH
69785: LD_VAR 0 2
69789: ARRAY
69790: PUSH
69791: LD_INT 1
69793: ARRAY
69794: PPUSH
69795: CALL 15388 0 1
69799: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
69800: LD_ADDR_EXP 92
69804: PUSH
69805: LD_EXP 92
69809: PPUSH
69810: LD_VAR 0 2
69814: PPUSH
69815: LD_EXP 69
69819: PUSH
69820: LD_VAR 0 2
69824: ARRAY
69825: PUSH
69826: LD_INT 1
69828: ARRAY
69829: PPUSH
69830: CALL_OW 255
69834: PPUSH
69835: LD_EXP 94
69839: PUSH
69840: LD_VAR 0 2
69844: ARRAY
69845: PPUSH
69846: CALL 15353 0 2
69850: PPUSH
69851: CALL_OW 1
69855: ST_TO_ADDR
// if not mc_scan [ i ] then
69856: LD_EXP 92
69860: PUSH
69861: LD_VAR 0 2
69865: ARRAY
69866: NOT
69867: IFFALSE 70045
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
69869: LD_ADDR_EXP 112
69873: PUSH
69874: LD_EXP 112
69878: PPUSH
69879: LD_VAR 0 2
69883: PPUSH
69884: LD_INT 0
69886: PPUSH
69887: CALL_OW 1
69891: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69892: LD_ADDR_VAR 0 4
69896: PUSH
69897: LD_EXP 69
69901: PUSH
69902: LD_VAR 0 2
69906: ARRAY
69907: PPUSH
69908: LD_INT 2
69910: PUSH
69911: LD_INT 25
69913: PUSH
69914: LD_INT 5
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 25
69923: PUSH
69924: LD_INT 8
69926: PUSH
69927: EMPTY
69928: LIST
69929: LIST
69930: PUSH
69931: LD_INT 25
69933: PUSH
69934: LD_INT 9
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: PPUSH
69947: CALL_OW 72
69951: ST_TO_ADDR
// if not tmp then
69952: LD_VAR 0 4
69956: NOT
69957: IFFALSE 69961
// continue ;
69959: GO 69757
// for j in tmp do
69961: LD_ADDR_VAR 0 3
69965: PUSH
69966: LD_VAR 0 4
69970: PUSH
69971: FOR_IN
69972: IFFALSE 70043
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
69974: LD_VAR 0 3
69978: PPUSH
69979: CALL_OW 310
69983: PPUSH
69984: CALL_OW 266
69988: PUSH
69989: LD_INT 5
69991: EQUAL
69992: PUSH
69993: LD_VAR 0 3
69997: PPUSH
69998: CALL_OW 257
70002: PUSH
70003: LD_INT 1
70005: EQUAL
70006: AND
70007: PUSH
70008: LD_VAR 0 3
70012: PPUSH
70013: CALL_OW 459
70017: NOT
70018: AND
70019: PUSH
70020: LD_VAR 0 7
70024: AND
70025: IFFALSE 70041
// ComChangeProfession ( j , class ) ;
70027: LD_VAR 0 3
70031: PPUSH
70032: LD_VAR 0 7
70036: PPUSH
70037: CALL_OW 123
70041: GO 69971
70043: POP
70044: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
70045: LD_EXP 92
70049: PUSH
70050: LD_VAR 0 2
70054: ARRAY
70055: PUSH
70056: LD_EXP 112
70060: PUSH
70061: LD_VAR 0 2
70065: ARRAY
70066: NOT
70067: AND
70068: PUSH
70069: LD_EXP 91
70073: PUSH
70074: LD_VAR 0 2
70078: ARRAY
70079: NOT
70080: AND
70081: PUSH
70082: LD_EXP 69
70086: PUSH
70087: LD_VAR 0 2
70091: ARRAY
70092: PPUSH
70093: LD_INT 50
70095: PUSH
70096: EMPTY
70097: LIST
70098: PUSH
70099: LD_INT 2
70101: PUSH
70102: LD_INT 30
70104: PUSH
70105: LD_INT 32
70107: PUSH
70108: EMPTY
70109: LIST
70110: LIST
70111: PUSH
70112: LD_INT 30
70114: PUSH
70115: LD_INT 33
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: PUSH
70122: LD_INT 30
70124: PUSH
70125: LD_INT 4
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: LD_INT 30
70134: PUSH
70135: LD_INT 5
70137: PUSH
70138: EMPTY
70139: LIST
70140: LIST
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: LIST
70146: LIST
70147: LIST
70148: PUSH
70149: EMPTY
70150: LIST
70151: LIST
70152: PPUSH
70153: CALL_OW 72
70157: PUSH
70158: LD_INT 4
70160: LESS
70161: PUSH
70162: LD_EXP 69
70166: PUSH
70167: LD_VAR 0 2
70171: ARRAY
70172: PPUSH
70173: LD_INT 3
70175: PUSH
70176: LD_INT 24
70178: PUSH
70179: LD_INT 1000
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: LD_INT 2
70192: PUSH
70193: LD_INT 30
70195: PUSH
70196: LD_INT 0
70198: PUSH
70199: EMPTY
70200: LIST
70201: LIST
70202: PUSH
70203: LD_INT 30
70205: PUSH
70206: LD_INT 1
70208: PUSH
70209: EMPTY
70210: LIST
70211: LIST
70212: PUSH
70213: EMPTY
70214: LIST
70215: LIST
70216: LIST
70217: PUSH
70218: EMPTY
70219: LIST
70220: LIST
70221: PPUSH
70222: CALL_OW 72
70226: OR
70227: AND
70228: IFFALSE 70479
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
70230: LD_ADDR_EXP 112
70234: PUSH
70235: LD_EXP 112
70239: PPUSH
70240: LD_VAR 0 2
70244: PPUSH
70245: LD_INT 1
70247: PPUSH
70248: CALL_OW 1
70252: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70253: LD_ADDR_VAR 0 4
70257: PUSH
70258: LD_EXP 69
70262: PUSH
70263: LD_VAR 0 2
70267: ARRAY
70268: PPUSH
70269: LD_INT 2
70271: PUSH
70272: LD_INT 25
70274: PUSH
70275: LD_INT 1
70277: PUSH
70278: EMPTY
70279: LIST
70280: LIST
70281: PUSH
70282: LD_INT 25
70284: PUSH
70285: LD_INT 5
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: PUSH
70292: LD_INT 25
70294: PUSH
70295: LD_INT 8
70297: PUSH
70298: EMPTY
70299: LIST
70300: LIST
70301: PUSH
70302: LD_INT 25
70304: PUSH
70305: LD_INT 9
70307: PUSH
70308: EMPTY
70309: LIST
70310: LIST
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: LIST
70316: LIST
70317: LIST
70318: PPUSH
70319: CALL_OW 72
70323: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
70324: LD_ADDR_VAR 0 4
70328: PUSH
70329: LD_VAR 0 4
70333: PUSH
70334: LD_VAR 0 4
70338: PPUSH
70339: LD_INT 18
70341: PPUSH
70342: CALL 47857 0 2
70346: DIFF
70347: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
70348: LD_VAR 0 4
70352: NOT
70353: PUSH
70354: LD_EXP 69
70358: PUSH
70359: LD_VAR 0 2
70363: ARRAY
70364: PPUSH
70365: LD_INT 2
70367: PUSH
70368: LD_INT 30
70370: PUSH
70371: LD_INT 4
70373: PUSH
70374: EMPTY
70375: LIST
70376: LIST
70377: PUSH
70378: LD_INT 30
70380: PUSH
70381: LD_INT 5
70383: PUSH
70384: EMPTY
70385: LIST
70386: LIST
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: LIST
70392: PPUSH
70393: CALL_OW 72
70397: NOT
70398: AND
70399: IFFALSE 70461
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
70401: LD_ADDR_VAR 0 4
70405: PUSH
70406: LD_EXP 69
70410: PUSH
70411: LD_VAR 0 2
70415: ARRAY
70416: PPUSH
70417: LD_INT 2
70419: PUSH
70420: LD_INT 25
70422: PUSH
70423: LD_INT 2
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: PUSH
70430: LD_INT 25
70432: PUSH
70433: LD_INT 3
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: PUSH
70440: LD_INT 25
70442: PUSH
70443: LD_INT 4
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: LIST
70454: LIST
70455: PPUSH
70456: CALL_OW 72
70460: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
70461: LD_VAR 0 2
70465: PPUSH
70466: LD_VAR 0 4
70470: PPUSH
70471: CALL 108165 0 2
// exit ;
70475: POP
70476: POP
70477: GO 70599
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
70479: LD_EXP 92
70483: PUSH
70484: LD_VAR 0 2
70488: ARRAY
70489: PUSH
70490: LD_EXP 112
70494: PUSH
70495: LD_VAR 0 2
70499: ARRAY
70500: NOT
70501: AND
70502: PUSH
70503: LD_EXP 91
70507: PUSH
70508: LD_VAR 0 2
70512: ARRAY
70513: AND
70514: IFFALSE 70595
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
70516: LD_ADDR_EXP 112
70520: PUSH
70521: LD_EXP 112
70525: PPUSH
70526: LD_VAR 0 2
70530: PPUSH
70531: LD_INT 1
70533: PPUSH
70534: CALL_OW 1
70538: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
70539: LD_ADDR_VAR 0 4
70543: PUSH
70544: LD_EXP 91
70548: PUSH
70549: LD_VAR 0 2
70553: ARRAY
70554: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
70555: LD_ADDR_EXP 91
70559: PUSH
70560: LD_EXP 91
70564: PPUSH
70565: LD_VAR 0 2
70569: PPUSH
70570: EMPTY
70571: PPUSH
70572: CALL_OW 1
70576: ST_TO_ADDR
// Defend ( i , tmp ) ;
70577: LD_VAR 0 2
70581: PPUSH
70582: LD_VAR 0 4
70586: PPUSH
70587: CALL 108761 0 2
// exit ;
70591: POP
70592: POP
70593: GO 70599
// end ; end ;
70595: GO 69757
70597: POP
70598: POP
// end ;
70599: LD_VAR 0 1
70603: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
70604: LD_INT 0
70606: PPUSH
70607: PPUSH
70608: PPUSH
70609: PPUSH
70610: PPUSH
70611: PPUSH
70612: PPUSH
70613: PPUSH
70614: PPUSH
70615: PPUSH
70616: PPUSH
// if not mc_bases then
70617: LD_EXP 69
70621: NOT
70622: IFFALSE 70626
// exit ;
70624: GO 71713
// for i = 1 to mc_bases do
70626: LD_ADDR_VAR 0 2
70630: PUSH
70631: DOUBLE
70632: LD_INT 1
70634: DEC
70635: ST_TO_ADDR
70636: LD_EXP 69
70640: PUSH
70641: FOR_TO
70642: IFFALSE 71711
// begin tmp := mc_lab [ i ] ;
70644: LD_ADDR_VAR 0 6
70648: PUSH
70649: LD_EXP 102
70653: PUSH
70654: LD_VAR 0 2
70658: ARRAY
70659: ST_TO_ADDR
// if not tmp then
70660: LD_VAR 0 6
70664: NOT
70665: IFFALSE 70669
// continue ;
70667: GO 70641
// idle_lab := 0 ;
70669: LD_ADDR_VAR 0 11
70673: PUSH
70674: LD_INT 0
70676: ST_TO_ADDR
// for j in tmp do
70677: LD_ADDR_VAR 0 3
70681: PUSH
70682: LD_VAR 0 6
70686: PUSH
70687: FOR_IN
70688: IFFALSE 71707
// begin researching := false ;
70690: LD_ADDR_VAR 0 10
70694: PUSH
70695: LD_INT 0
70697: ST_TO_ADDR
// side := GetSide ( j ) ;
70698: LD_ADDR_VAR 0 4
70702: PUSH
70703: LD_VAR 0 3
70707: PPUSH
70708: CALL_OW 255
70712: ST_TO_ADDR
// if not mc_tech [ side ] then
70713: LD_EXP 96
70717: PUSH
70718: LD_VAR 0 4
70722: ARRAY
70723: NOT
70724: IFFALSE 70728
// continue ;
70726: GO 70687
// if BuildingStatus ( j ) = bs_idle then
70728: LD_VAR 0 3
70732: PPUSH
70733: CALL_OW 461
70737: PUSH
70738: LD_INT 2
70740: EQUAL
70741: IFFALSE 70929
// begin if idle_lab and UnitsInside ( j ) < 6 then
70743: LD_VAR 0 11
70747: PUSH
70748: LD_VAR 0 3
70752: PPUSH
70753: CALL_OW 313
70757: PUSH
70758: LD_INT 6
70760: LESS
70761: AND
70762: IFFALSE 70833
// begin tmp2 := UnitsInside ( idle_lab ) ;
70764: LD_ADDR_VAR 0 9
70768: PUSH
70769: LD_VAR 0 11
70773: PPUSH
70774: CALL_OW 313
70778: ST_TO_ADDR
// if tmp2 then
70779: LD_VAR 0 9
70783: IFFALSE 70825
// for x in tmp2 do
70785: LD_ADDR_VAR 0 7
70789: PUSH
70790: LD_VAR 0 9
70794: PUSH
70795: FOR_IN
70796: IFFALSE 70823
// begin ComExitBuilding ( x ) ;
70798: LD_VAR 0 7
70802: PPUSH
70803: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70807: LD_VAR 0 7
70811: PPUSH
70812: LD_VAR 0 3
70816: PPUSH
70817: CALL_OW 180
// end ;
70821: GO 70795
70823: POP
70824: POP
// idle_lab := 0 ;
70825: LD_ADDR_VAR 0 11
70829: PUSH
70830: LD_INT 0
70832: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
70833: LD_ADDR_VAR 0 5
70837: PUSH
70838: LD_EXP 96
70842: PUSH
70843: LD_VAR 0 4
70847: ARRAY
70848: PUSH
70849: FOR_IN
70850: IFFALSE 70910
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
70852: LD_VAR 0 3
70856: PPUSH
70857: LD_VAR 0 5
70861: PPUSH
70862: CALL_OW 430
70866: PUSH
70867: LD_VAR 0 4
70871: PPUSH
70872: LD_VAR 0 5
70876: PPUSH
70877: CALL 14458 0 2
70881: AND
70882: IFFALSE 70908
// begin researching := true ;
70884: LD_ADDR_VAR 0 10
70888: PUSH
70889: LD_INT 1
70891: ST_TO_ADDR
// ComResearch ( j , t ) ;
70892: LD_VAR 0 3
70896: PPUSH
70897: LD_VAR 0 5
70901: PPUSH
70902: CALL_OW 124
// break ;
70906: GO 70910
// end ;
70908: GO 70849
70910: POP
70911: POP
// if not researching then
70912: LD_VAR 0 10
70916: NOT
70917: IFFALSE 70929
// idle_lab := j ;
70919: LD_ADDR_VAR 0 11
70923: PUSH
70924: LD_VAR 0 3
70928: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
70929: LD_VAR 0 3
70933: PPUSH
70934: CALL_OW 461
70938: PUSH
70939: LD_INT 10
70941: EQUAL
70942: IFFALSE 71530
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
70944: LD_EXP 98
70948: PUSH
70949: LD_VAR 0 2
70953: ARRAY
70954: NOT
70955: PUSH
70956: LD_EXP 99
70960: PUSH
70961: LD_VAR 0 2
70965: ARRAY
70966: NOT
70967: AND
70968: PUSH
70969: LD_EXP 96
70973: PUSH
70974: LD_VAR 0 4
70978: ARRAY
70979: PUSH
70980: LD_INT 1
70982: GREATER
70983: AND
70984: IFFALSE 71115
// begin ComCancel ( j ) ;
70986: LD_VAR 0 3
70990: PPUSH
70991: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
70995: LD_ADDR_EXP 96
70999: PUSH
71000: LD_EXP 96
71004: PPUSH
71005: LD_VAR 0 4
71009: PPUSH
71010: LD_EXP 96
71014: PUSH
71015: LD_VAR 0 4
71019: ARRAY
71020: PPUSH
71021: LD_EXP 96
71025: PUSH
71026: LD_VAR 0 4
71030: ARRAY
71031: PUSH
71032: LD_INT 1
71034: MINUS
71035: PPUSH
71036: LD_EXP 96
71040: PUSH
71041: LD_VAR 0 4
71045: ARRAY
71046: PPUSH
71047: LD_INT 0
71049: PPUSH
71050: CALL 18006 0 4
71054: PPUSH
71055: CALL_OW 1
71059: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
71060: LD_ADDR_EXP 96
71064: PUSH
71065: LD_EXP 96
71069: PPUSH
71070: LD_VAR 0 4
71074: PPUSH
71075: LD_EXP 96
71079: PUSH
71080: LD_VAR 0 4
71084: ARRAY
71085: PPUSH
71086: LD_EXP 96
71090: PUSH
71091: LD_VAR 0 4
71095: ARRAY
71096: PPUSH
71097: LD_INT 1
71099: PPUSH
71100: LD_INT 0
71102: PPUSH
71103: CALL 18006 0 4
71107: PPUSH
71108: CALL_OW 1
71112: ST_TO_ADDR
// continue ;
71113: GO 70687
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
71115: LD_EXP 98
71119: PUSH
71120: LD_VAR 0 2
71124: ARRAY
71125: PUSH
71126: LD_EXP 99
71130: PUSH
71131: LD_VAR 0 2
71135: ARRAY
71136: NOT
71137: AND
71138: IFFALSE 71265
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
71140: LD_ADDR_EXP 99
71144: PUSH
71145: LD_EXP 99
71149: PPUSH
71150: LD_VAR 0 2
71154: PUSH
71155: LD_EXP 99
71159: PUSH
71160: LD_VAR 0 2
71164: ARRAY
71165: PUSH
71166: LD_INT 1
71168: PLUS
71169: PUSH
71170: EMPTY
71171: LIST
71172: LIST
71173: PPUSH
71174: LD_EXP 98
71178: PUSH
71179: LD_VAR 0 2
71183: ARRAY
71184: PUSH
71185: LD_INT 1
71187: ARRAY
71188: PPUSH
71189: CALL 18588 0 3
71193: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
71194: LD_EXP 98
71198: PUSH
71199: LD_VAR 0 2
71203: ARRAY
71204: PUSH
71205: LD_INT 1
71207: ARRAY
71208: PPUSH
71209: LD_INT 112
71211: PPUSH
71212: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
71216: LD_ADDR_VAR 0 9
71220: PUSH
71221: LD_EXP 98
71225: PUSH
71226: LD_VAR 0 2
71230: ARRAY
71231: PPUSH
71232: LD_INT 1
71234: PPUSH
71235: CALL_OW 3
71239: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
71240: LD_ADDR_EXP 98
71244: PUSH
71245: LD_EXP 98
71249: PPUSH
71250: LD_VAR 0 2
71254: PPUSH
71255: LD_VAR 0 9
71259: PPUSH
71260: CALL_OW 1
71264: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
71265: LD_EXP 98
71269: PUSH
71270: LD_VAR 0 2
71274: ARRAY
71275: PUSH
71276: LD_EXP 99
71280: PUSH
71281: LD_VAR 0 2
71285: ARRAY
71286: AND
71287: PUSH
71288: LD_EXP 99
71292: PUSH
71293: LD_VAR 0 2
71297: ARRAY
71298: PUSH
71299: LD_INT 1
71301: ARRAY
71302: PPUSH
71303: CALL_OW 310
71307: NOT
71308: AND
71309: PUSH
71310: LD_VAR 0 3
71314: PPUSH
71315: CALL_OW 313
71319: PUSH
71320: LD_INT 6
71322: EQUAL
71323: AND
71324: IFFALSE 71380
// begin tmp2 := UnitsInside ( j ) ;
71326: LD_ADDR_VAR 0 9
71330: PUSH
71331: LD_VAR 0 3
71335: PPUSH
71336: CALL_OW 313
71340: ST_TO_ADDR
// if tmp2 = 6 then
71341: LD_VAR 0 9
71345: PUSH
71346: LD_INT 6
71348: EQUAL
71349: IFFALSE 71380
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
71351: LD_VAR 0 9
71355: PUSH
71356: LD_INT 1
71358: ARRAY
71359: PPUSH
71360: LD_INT 112
71362: PPUSH
71363: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
71367: LD_VAR 0 9
71371: PUSH
71372: LD_INT 1
71374: ARRAY
71375: PPUSH
71376: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
71380: LD_EXP 99
71384: PUSH
71385: LD_VAR 0 2
71389: ARRAY
71390: PUSH
71391: LD_EXP 99
71395: PUSH
71396: LD_VAR 0 2
71400: ARRAY
71401: PUSH
71402: LD_INT 1
71404: ARRAY
71405: PPUSH
71406: CALL_OW 314
71410: NOT
71411: AND
71412: PUSH
71413: LD_EXP 99
71417: PUSH
71418: LD_VAR 0 2
71422: ARRAY
71423: PUSH
71424: LD_INT 1
71426: ARRAY
71427: PPUSH
71428: CALL_OW 310
71432: NOT
71433: AND
71434: IFFALSE 71460
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
71436: LD_EXP 99
71440: PUSH
71441: LD_VAR 0 2
71445: ARRAY
71446: PUSH
71447: LD_INT 1
71449: ARRAY
71450: PPUSH
71451: LD_VAR 0 3
71455: PPUSH
71456: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
71460: LD_EXP 99
71464: PUSH
71465: LD_VAR 0 2
71469: ARRAY
71470: PUSH
71471: LD_INT 1
71473: ARRAY
71474: PPUSH
71475: CALL_OW 310
71479: PUSH
71480: LD_EXP 99
71484: PUSH
71485: LD_VAR 0 2
71489: ARRAY
71490: PUSH
71491: LD_INT 1
71493: ARRAY
71494: PPUSH
71495: CALL_OW 310
71499: PPUSH
71500: CALL_OW 461
71504: PUSH
71505: LD_INT 3
71507: NONEQUAL
71508: AND
71509: IFFALSE 71530
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
71511: LD_EXP 99
71515: PUSH
71516: LD_VAR 0 2
71520: ARRAY
71521: PUSH
71522: LD_INT 1
71524: ARRAY
71525: PPUSH
71526: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
71530: LD_VAR 0 3
71534: PPUSH
71535: CALL_OW 461
71539: PUSH
71540: LD_INT 6
71542: EQUAL
71543: PUSH
71544: LD_VAR 0 6
71548: PUSH
71549: LD_INT 1
71551: GREATER
71552: AND
71553: IFFALSE 71705
// begin sci := [ ] ;
71555: LD_ADDR_VAR 0 8
71559: PUSH
71560: EMPTY
71561: ST_TO_ADDR
// for x in ( tmp diff j ) do
71562: LD_ADDR_VAR 0 7
71566: PUSH
71567: LD_VAR 0 6
71571: PUSH
71572: LD_VAR 0 3
71576: DIFF
71577: PUSH
71578: FOR_IN
71579: IFFALSE 71631
// begin if sci = 6 then
71581: LD_VAR 0 8
71585: PUSH
71586: LD_INT 6
71588: EQUAL
71589: IFFALSE 71593
// break ;
71591: GO 71631
// if BuildingStatus ( x ) = bs_idle then
71593: LD_VAR 0 7
71597: PPUSH
71598: CALL_OW 461
71602: PUSH
71603: LD_INT 2
71605: EQUAL
71606: IFFALSE 71629
// sci := sci ^ UnitsInside ( x ) ;
71608: LD_ADDR_VAR 0 8
71612: PUSH
71613: LD_VAR 0 8
71617: PUSH
71618: LD_VAR 0 7
71622: PPUSH
71623: CALL_OW 313
71627: ADD
71628: ST_TO_ADDR
// end ;
71629: GO 71578
71631: POP
71632: POP
// if not sci then
71633: LD_VAR 0 8
71637: NOT
71638: IFFALSE 71642
// continue ;
71640: GO 70687
// for x in sci do
71642: LD_ADDR_VAR 0 7
71646: PUSH
71647: LD_VAR 0 8
71651: PUSH
71652: FOR_IN
71653: IFFALSE 71703
// if IsInUnit ( x ) and not HasTask ( x ) then
71655: LD_VAR 0 7
71659: PPUSH
71660: CALL_OW 310
71664: PUSH
71665: LD_VAR 0 7
71669: PPUSH
71670: CALL_OW 314
71674: NOT
71675: AND
71676: IFFALSE 71701
// begin ComExitBuilding ( x ) ;
71678: LD_VAR 0 7
71682: PPUSH
71683: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71687: LD_VAR 0 7
71691: PPUSH
71692: LD_VAR 0 3
71696: PPUSH
71697: CALL_OW 180
// end ;
71701: GO 71652
71703: POP
71704: POP
// end ; end ;
71705: GO 70687
71707: POP
71708: POP
// end ;
71709: GO 70641
71711: POP
71712: POP
// end ;
71713: LD_VAR 0 1
71717: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
71718: LD_INT 0
71720: PPUSH
71721: PPUSH
// if not mc_bases then
71722: LD_EXP 69
71726: NOT
71727: IFFALSE 71731
// exit ;
71729: GO 71812
// for i = 1 to mc_bases do
71731: LD_ADDR_VAR 0 2
71735: PUSH
71736: DOUBLE
71737: LD_INT 1
71739: DEC
71740: ST_TO_ADDR
71741: LD_EXP 69
71745: PUSH
71746: FOR_TO
71747: IFFALSE 71810
// if mc_mines [ i ] and mc_miners [ i ] then
71749: LD_EXP 82
71753: PUSH
71754: LD_VAR 0 2
71758: ARRAY
71759: PUSH
71760: LD_EXP 83
71764: PUSH
71765: LD_VAR 0 2
71769: ARRAY
71770: AND
71771: IFFALSE 71808
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
71773: LD_EXP 83
71777: PUSH
71778: LD_VAR 0 2
71782: ARRAY
71783: PUSH
71784: LD_INT 1
71786: ARRAY
71787: PPUSH
71788: CALL_OW 255
71792: PPUSH
71793: LD_EXP 82
71797: PUSH
71798: LD_VAR 0 2
71802: ARRAY
71803: PPUSH
71804: CALL 15541 0 2
71808: GO 71746
71810: POP
71811: POP
// end ;
71812: LD_VAR 0 1
71816: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
71817: LD_INT 0
71819: PPUSH
71820: PPUSH
71821: PPUSH
71822: PPUSH
71823: PPUSH
71824: PPUSH
71825: PPUSH
71826: PPUSH
// if not mc_bases or not mc_parking then
71827: LD_EXP 69
71831: NOT
71832: PUSH
71833: LD_EXP 93
71837: NOT
71838: OR
71839: IFFALSE 71843
// exit ;
71841: GO 72553
// for i = 1 to mc_bases do
71843: LD_ADDR_VAR 0 2
71847: PUSH
71848: DOUBLE
71849: LD_INT 1
71851: DEC
71852: ST_TO_ADDR
71853: LD_EXP 69
71857: PUSH
71858: FOR_TO
71859: IFFALSE 72551
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
71861: LD_EXP 69
71865: PUSH
71866: LD_VAR 0 2
71870: ARRAY
71871: NOT
71872: PUSH
71873: LD_EXP 93
71877: PUSH
71878: LD_VAR 0 2
71882: ARRAY
71883: NOT
71884: OR
71885: IFFALSE 71889
// continue ;
71887: GO 71858
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
71889: LD_ADDR_VAR 0 5
71893: PUSH
71894: LD_EXP 69
71898: PUSH
71899: LD_VAR 0 2
71903: ARRAY
71904: PUSH
71905: LD_INT 1
71907: ARRAY
71908: PPUSH
71909: CALL_OW 255
71913: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71914: LD_ADDR_VAR 0 6
71918: PUSH
71919: LD_EXP 69
71923: PUSH
71924: LD_VAR 0 2
71928: ARRAY
71929: PPUSH
71930: LD_INT 30
71932: PUSH
71933: LD_INT 3
71935: PUSH
71936: EMPTY
71937: LIST
71938: LIST
71939: PPUSH
71940: CALL_OW 72
71944: ST_TO_ADDR
// if not fac then
71945: LD_VAR 0 6
71949: NOT
71950: IFFALSE 72001
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71952: LD_ADDR_VAR 0 6
71956: PUSH
71957: LD_EXP 69
71961: PUSH
71962: LD_VAR 0 2
71966: ARRAY
71967: PPUSH
71968: LD_INT 2
71970: PUSH
71971: LD_INT 30
71973: PUSH
71974: LD_INT 0
71976: PUSH
71977: EMPTY
71978: LIST
71979: LIST
71980: PUSH
71981: LD_INT 30
71983: PUSH
71984: LD_INT 1
71986: PUSH
71987: EMPTY
71988: LIST
71989: LIST
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: LIST
71995: PPUSH
71996: CALL_OW 72
72000: ST_TO_ADDR
// if not fac then
72001: LD_VAR 0 6
72005: NOT
72006: IFFALSE 72010
// continue ;
72008: GO 71858
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72010: LD_ADDR_VAR 0 7
72014: PUSH
72015: LD_EXP 93
72019: PUSH
72020: LD_VAR 0 2
72024: ARRAY
72025: PPUSH
72026: LD_INT 22
72028: PUSH
72029: LD_VAR 0 5
72033: PUSH
72034: EMPTY
72035: LIST
72036: LIST
72037: PUSH
72038: LD_INT 21
72040: PUSH
72041: LD_INT 2
72043: PUSH
72044: EMPTY
72045: LIST
72046: LIST
72047: PUSH
72048: LD_INT 3
72050: PUSH
72051: LD_INT 24
72053: PUSH
72054: LD_INT 1000
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: PUSH
72061: EMPTY
72062: LIST
72063: LIST
72064: PUSH
72065: EMPTY
72066: LIST
72067: LIST
72068: LIST
72069: PPUSH
72070: CALL_OW 70
72074: ST_TO_ADDR
// for j in fac do
72075: LD_ADDR_VAR 0 3
72079: PUSH
72080: LD_VAR 0 6
72084: PUSH
72085: FOR_IN
72086: IFFALSE 72167
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72088: LD_ADDR_VAR 0 7
72092: PUSH
72093: LD_VAR 0 7
72097: PUSH
72098: LD_INT 22
72100: PUSH
72101: LD_VAR 0 5
72105: PUSH
72106: EMPTY
72107: LIST
72108: LIST
72109: PUSH
72110: LD_INT 91
72112: PUSH
72113: LD_VAR 0 3
72117: PUSH
72118: LD_INT 15
72120: PUSH
72121: EMPTY
72122: LIST
72123: LIST
72124: LIST
72125: PUSH
72126: LD_INT 21
72128: PUSH
72129: LD_INT 2
72131: PUSH
72132: EMPTY
72133: LIST
72134: LIST
72135: PUSH
72136: LD_INT 3
72138: PUSH
72139: LD_INT 24
72141: PUSH
72142: LD_INT 1000
72144: PUSH
72145: EMPTY
72146: LIST
72147: LIST
72148: PUSH
72149: EMPTY
72150: LIST
72151: LIST
72152: PUSH
72153: EMPTY
72154: LIST
72155: LIST
72156: LIST
72157: LIST
72158: PPUSH
72159: CALL_OW 69
72163: UNION
72164: ST_TO_ADDR
72165: GO 72085
72167: POP
72168: POP
// if not vehs then
72169: LD_VAR 0 7
72173: NOT
72174: IFFALSE 72200
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72176: LD_ADDR_EXP 81
72180: PUSH
72181: LD_EXP 81
72185: PPUSH
72186: LD_VAR 0 2
72190: PPUSH
72191: EMPTY
72192: PPUSH
72193: CALL_OW 1
72197: ST_TO_ADDR
// continue ;
72198: GO 71858
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72200: LD_ADDR_VAR 0 8
72204: PUSH
72205: LD_EXP 69
72209: PUSH
72210: LD_VAR 0 2
72214: ARRAY
72215: PPUSH
72216: LD_INT 30
72218: PUSH
72219: LD_INT 3
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PPUSH
72226: CALL_OW 72
72230: ST_TO_ADDR
// if tmp then
72231: LD_VAR 0 8
72235: IFFALSE 72338
// begin for j in tmp do
72237: LD_ADDR_VAR 0 3
72241: PUSH
72242: LD_VAR 0 8
72246: PUSH
72247: FOR_IN
72248: IFFALSE 72336
// for k in UnitsInside ( j ) do
72250: LD_ADDR_VAR 0 4
72254: PUSH
72255: LD_VAR 0 3
72259: PPUSH
72260: CALL_OW 313
72264: PUSH
72265: FOR_IN
72266: IFFALSE 72332
// if k then
72268: LD_VAR 0 4
72272: IFFALSE 72330
// if not k in mc_repair_vehicle [ i ] then
72274: LD_VAR 0 4
72278: PUSH
72279: LD_EXP 81
72283: PUSH
72284: LD_VAR 0 2
72288: ARRAY
72289: IN
72290: NOT
72291: IFFALSE 72330
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
72293: LD_ADDR_EXP 81
72297: PUSH
72298: LD_EXP 81
72302: PPUSH
72303: LD_VAR 0 2
72307: PPUSH
72308: LD_EXP 81
72312: PUSH
72313: LD_VAR 0 2
72317: ARRAY
72318: PUSH
72319: LD_VAR 0 4
72323: UNION
72324: PPUSH
72325: CALL_OW 1
72329: ST_TO_ADDR
72330: GO 72265
72332: POP
72333: POP
72334: GO 72247
72336: POP
72337: POP
// end ; if not mc_repair_vehicle [ i ] then
72338: LD_EXP 81
72342: PUSH
72343: LD_VAR 0 2
72347: ARRAY
72348: NOT
72349: IFFALSE 72353
// continue ;
72351: GO 71858
// for j in mc_repair_vehicle [ i ] do
72353: LD_ADDR_VAR 0 3
72357: PUSH
72358: LD_EXP 81
72362: PUSH
72363: LD_VAR 0 2
72367: ARRAY
72368: PUSH
72369: FOR_IN
72370: IFFALSE 72547
// begin if GetClass ( j ) <> 3 then
72372: LD_VAR 0 3
72376: PPUSH
72377: CALL_OW 257
72381: PUSH
72382: LD_INT 3
72384: NONEQUAL
72385: IFFALSE 72426
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
72387: LD_ADDR_EXP 81
72391: PUSH
72392: LD_EXP 81
72396: PPUSH
72397: LD_VAR 0 2
72401: PPUSH
72402: LD_EXP 81
72406: PUSH
72407: LD_VAR 0 2
72411: ARRAY
72412: PUSH
72413: LD_VAR 0 3
72417: DIFF
72418: PPUSH
72419: CALL_OW 1
72423: ST_TO_ADDR
// continue ;
72424: GO 72369
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72426: LD_VAR 0 3
72430: PPUSH
72431: CALL_OW 311
72435: NOT
72436: PUSH
72437: LD_VAR 0 3
72441: PUSH
72442: LD_EXP 72
72446: PUSH
72447: LD_VAR 0 2
72451: ARRAY
72452: PUSH
72453: LD_INT 1
72455: ARRAY
72456: IN
72457: NOT
72458: AND
72459: PUSH
72460: LD_VAR 0 3
72464: PUSH
72465: LD_EXP 72
72469: PUSH
72470: LD_VAR 0 2
72474: ARRAY
72475: PUSH
72476: LD_INT 2
72478: ARRAY
72479: IN
72480: NOT
72481: AND
72482: IFFALSE 72545
// begin if IsInUnit ( j ) then
72484: LD_VAR 0 3
72488: PPUSH
72489: CALL_OW 310
72493: IFFALSE 72506
// ComExitBuilding ( j ) else
72495: LD_VAR 0 3
72499: PPUSH
72500: CALL_OW 122
72504: GO 72545
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
72506: LD_VAR 0 3
72510: PPUSH
72511: LD_VAR 0 7
72515: PUSH
72516: LD_INT 1
72518: ARRAY
72519: PPUSH
72520: CALL 52396 0 2
72524: NOT
72525: IFFALSE 72545
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
72527: LD_VAR 0 3
72531: PPUSH
72532: LD_VAR 0 7
72536: PUSH
72537: LD_INT 1
72539: ARRAY
72540: PPUSH
72541: CALL_OW 129
// end ; end ;
72545: GO 72369
72547: POP
72548: POP
// end ;
72549: GO 71858
72551: POP
72552: POP
// end ;
72553: LD_VAR 0 1
72557: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
72558: LD_INT 0
72560: PPUSH
72561: PPUSH
72562: PPUSH
72563: PPUSH
72564: PPUSH
72565: PPUSH
72566: PPUSH
72567: PPUSH
72568: PPUSH
72569: PPUSH
72570: PPUSH
// if not mc_bases then
72571: LD_EXP 69
72575: NOT
72576: IFFALSE 72580
// exit ;
72578: GO 73382
// for i = 1 to mc_bases do
72580: LD_ADDR_VAR 0 2
72584: PUSH
72585: DOUBLE
72586: LD_INT 1
72588: DEC
72589: ST_TO_ADDR
72590: LD_EXP 69
72594: PUSH
72595: FOR_TO
72596: IFFALSE 73380
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
72598: LD_EXP 97
72602: PUSH
72603: LD_VAR 0 2
72607: ARRAY
72608: NOT
72609: PUSH
72610: LD_EXP 72
72614: PUSH
72615: LD_VAR 0 2
72619: ARRAY
72620: PUSH
72621: LD_INT 1
72623: ARRAY
72624: OR
72625: PUSH
72626: LD_EXP 72
72630: PUSH
72631: LD_VAR 0 2
72635: ARRAY
72636: PUSH
72637: LD_INT 2
72639: ARRAY
72640: OR
72641: PUSH
72642: LD_EXP 95
72646: PUSH
72647: LD_VAR 0 2
72651: ARRAY
72652: PPUSH
72653: LD_INT 1
72655: PPUSH
72656: CALL_OW 325
72660: NOT
72661: OR
72662: PUSH
72663: LD_EXP 92
72667: PUSH
72668: LD_VAR 0 2
72672: ARRAY
72673: OR
72674: IFFALSE 72678
// continue ;
72676: GO 72595
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
72678: LD_ADDR_VAR 0 8
72682: PUSH
72683: LD_EXP 69
72687: PUSH
72688: LD_VAR 0 2
72692: ARRAY
72693: PPUSH
72694: LD_INT 25
72696: PUSH
72697: LD_INT 4
72699: PUSH
72700: EMPTY
72701: LIST
72702: LIST
72703: PUSH
72704: LD_INT 50
72706: PUSH
72707: EMPTY
72708: LIST
72709: PUSH
72710: LD_INT 3
72712: PUSH
72713: LD_INT 60
72715: PUSH
72716: EMPTY
72717: LIST
72718: PUSH
72719: EMPTY
72720: LIST
72721: LIST
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: LIST
72727: PPUSH
72728: CALL_OW 72
72732: PUSH
72733: LD_EXP 73
72737: PUSH
72738: LD_VAR 0 2
72742: ARRAY
72743: DIFF
72744: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72745: LD_ADDR_VAR 0 9
72749: PUSH
72750: LD_EXP 69
72754: PUSH
72755: LD_VAR 0 2
72759: ARRAY
72760: PPUSH
72761: LD_INT 2
72763: PUSH
72764: LD_INT 30
72766: PUSH
72767: LD_INT 0
72769: PUSH
72770: EMPTY
72771: LIST
72772: LIST
72773: PUSH
72774: LD_INT 30
72776: PUSH
72777: LD_INT 1
72779: PUSH
72780: EMPTY
72781: LIST
72782: LIST
72783: PUSH
72784: EMPTY
72785: LIST
72786: LIST
72787: LIST
72788: PPUSH
72789: CALL_OW 72
72793: ST_TO_ADDR
// if not tmp or not dep then
72794: LD_VAR 0 8
72798: NOT
72799: PUSH
72800: LD_VAR 0 9
72804: NOT
72805: OR
72806: IFFALSE 72810
// continue ;
72808: GO 72595
// side := GetSide ( tmp [ 1 ] ) ;
72810: LD_ADDR_VAR 0 11
72814: PUSH
72815: LD_VAR 0 8
72819: PUSH
72820: LD_INT 1
72822: ARRAY
72823: PPUSH
72824: CALL_OW 255
72828: ST_TO_ADDR
// dep := dep [ 1 ] ;
72829: LD_ADDR_VAR 0 9
72833: PUSH
72834: LD_VAR 0 9
72838: PUSH
72839: LD_INT 1
72841: ARRAY
72842: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
72843: LD_ADDR_VAR 0 7
72847: PUSH
72848: LD_EXP 97
72852: PUSH
72853: LD_VAR 0 2
72857: ARRAY
72858: PPUSH
72859: LD_INT 22
72861: PUSH
72862: LD_INT 0
72864: PUSH
72865: EMPTY
72866: LIST
72867: LIST
72868: PUSH
72869: LD_INT 25
72871: PUSH
72872: LD_INT 12
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: PPUSH
72883: CALL_OW 70
72887: PUSH
72888: LD_INT 22
72890: PUSH
72891: LD_INT 0
72893: PUSH
72894: EMPTY
72895: LIST
72896: LIST
72897: PUSH
72898: LD_INT 25
72900: PUSH
72901: LD_INT 12
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 91
72910: PUSH
72911: LD_VAR 0 9
72915: PUSH
72916: LD_INT 20
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: LIST
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: LIST
72928: PPUSH
72929: CALL_OW 69
72933: UNION
72934: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
72935: LD_ADDR_VAR 0 10
72939: PUSH
72940: LD_EXP 97
72944: PUSH
72945: LD_VAR 0 2
72949: ARRAY
72950: PPUSH
72951: LD_INT 81
72953: PUSH
72954: LD_VAR 0 11
72958: PUSH
72959: EMPTY
72960: LIST
72961: LIST
72962: PPUSH
72963: CALL_OW 70
72967: ST_TO_ADDR
// if not apes or danger_at_area then
72968: LD_VAR 0 7
72972: NOT
72973: PUSH
72974: LD_VAR 0 10
72978: OR
72979: IFFALSE 73029
// begin if mc_taming [ i ] then
72981: LD_EXP 100
72985: PUSH
72986: LD_VAR 0 2
72990: ARRAY
72991: IFFALSE 73027
// begin MC_Reset ( i , 121 ) ;
72993: LD_VAR 0 2
72997: PPUSH
72998: LD_INT 121
73000: PPUSH
73001: CALL 58015 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
73005: LD_ADDR_EXP 100
73009: PUSH
73010: LD_EXP 100
73014: PPUSH
73015: LD_VAR 0 2
73019: PPUSH
73020: EMPTY
73021: PPUSH
73022: CALL_OW 1
73026: ST_TO_ADDR
// end ; continue ;
73027: GO 72595
// end ; for j in tmp do
73029: LD_ADDR_VAR 0 3
73033: PUSH
73034: LD_VAR 0 8
73038: PUSH
73039: FOR_IN
73040: IFFALSE 73376
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
73042: LD_VAR 0 3
73046: PUSH
73047: LD_EXP 100
73051: PUSH
73052: LD_VAR 0 2
73056: ARRAY
73057: IN
73058: NOT
73059: PUSH
73060: LD_EXP 100
73064: PUSH
73065: LD_VAR 0 2
73069: ARRAY
73070: PUSH
73071: LD_INT 3
73073: LESS
73074: AND
73075: IFFALSE 73133
// begin SetTag ( j , 121 ) ;
73077: LD_VAR 0 3
73081: PPUSH
73082: LD_INT 121
73084: PPUSH
73085: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
73089: LD_ADDR_EXP 100
73093: PUSH
73094: LD_EXP 100
73098: PPUSH
73099: LD_VAR 0 2
73103: PUSH
73104: LD_EXP 100
73108: PUSH
73109: LD_VAR 0 2
73113: ARRAY
73114: PUSH
73115: LD_INT 1
73117: PLUS
73118: PUSH
73119: EMPTY
73120: LIST
73121: LIST
73122: PPUSH
73123: LD_VAR 0 3
73127: PPUSH
73128: CALL 18588 0 3
73132: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
73133: LD_VAR 0 3
73137: PUSH
73138: LD_EXP 100
73142: PUSH
73143: LD_VAR 0 2
73147: ARRAY
73148: IN
73149: IFFALSE 73374
// begin if GetClass ( j ) <> 4 then
73151: LD_VAR 0 3
73155: PPUSH
73156: CALL_OW 257
73160: PUSH
73161: LD_INT 4
73163: NONEQUAL
73164: IFFALSE 73217
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
73166: LD_ADDR_EXP 100
73170: PUSH
73171: LD_EXP 100
73175: PPUSH
73176: LD_VAR 0 2
73180: PPUSH
73181: LD_EXP 100
73185: PUSH
73186: LD_VAR 0 2
73190: ARRAY
73191: PUSH
73192: LD_VAR 0 3
73196: DIFF
73197: PPUSH
73198: CALL_OW 1
73202: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73203: LD_VAR 0 3
73207: PPUSH
73208: LD_INT 0
73210: PPUSH
73211: CALL_OW 109
// continue ;
73215: GO 73039
// end ; if IsInUnit ( j ) then
73217: LD_VAR 0 3
73221: PPUSH
73222: CALL_OW 310
73226: IFFALSE 73237
// ComExitBuilding ( j ) ;
73228: LD_VAR 0 3
73232: PPUSH
73233: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
73237: LD_ADDR_VAR 0 6
73241: PUSH
73242: LD_VAR 0 7
73246: PPUSH
73247: LD_VAR 0 3
73251: PPUSH
73252: CALL_OW 74
73256: ST_TO_ADDR
// if not ape then
73257: LD_VAR 0 6
73261: NOT
73262: IFFALSE 73266
// break ;
73264: GO 73376
// x := GetX ( ape ) ;
73266: LD_ADDR_VAR 0 4
73270: PUSH
73271: LD_VAR 0 6
73275: PPUSH
73276: CALL_OW 250
73280: ST_TO_ADDR
// y := GetY ( ape ) ;
73281: LD_ADDR_VAR 0 5
73285: PUSH
73286: LD_VAR 0 6
73290: PPUSH
73291: CALL_OW 251
73295: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
73296: LD_VAR 0 4
73300: PPUSH
73301: LD_VAR 0 5
73305: PPUSH
73306: CALL_OW 488
73310: NOT
73311: PUSH
73312: LD_VAR 0 11
73316: PPUSH
73317: LD_VAR 0 4
73321: PPUSH
73322: LD_VAR 0 5
73326: PPUSH
73327: LD_INT 20
73329: PPUSH
73330: CALL 19484 0 4
73334: PUSH
73335: LD_INT 4
73337: ARRAY
73338: OR
73339: IFFALSE 73343
// break ;
73341: GO 73376
// if not HasTask ( j ) then
73343: LD_VAR 0 3
73347: PPUSH
73348: CALL_OW 314
73352: NOT
73353: IFFALSE 73374
// ComTameXY ( j , x , y ) ;
73355: LD_VAR 0 3
73359: PPUSH
73360: LD_VAR 0 4
73364: PPUSH
73365: LD_VAR 0 5
73369: PPUSH
73370: CALL_OW 131
// end ; end ;
73374: GO 73039
73376: POP
73377: POP
// end ;
73378: GO 72595
73380: POP
73381: POP
// end ;
73382: LD_VAR 0 1
73386: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
73387: LD_INT 0
73389: PPUSH
73390: PPUSH
73391: PPUSH
73392: PPUSH
73393: PPUSH
73394: PPUSH
73395: PPUSH
73396: PPUSH
// if not mc_bases then
73397: LD_EXP 69
73401: NOT
73402: IFFALSE 73406
// exit ;
73404: GO 74032
// for i = 1 to mc_bases do
73406: LD_ADDR_VAR 0 2
73410: PUSH
73411: DOUBLE
73412: LD_INT 1
73414: DEC
73415: ST_TO_ADDR
73416: LD_EXP 69
73420: PUSH
73421: FOR_TO
73422: IFFALSE 74030
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
73424: LD_EXP 98
73428: PUSH
73429: LD_VAR 0 2
73433: ARRAY
73434: NOT
73435: PUSH
73436: LD_EXP 98
73440: PUSH
73441: LD_VAR 0 2
73445: ARRAY
73446: PPUSH
73447: LD_INT 25
73449: PUSH
73450: LD_INT 12
73452: PUSH
73453: EMPTY
73454: LIST
73455: LIST
73456: PPUSH
73457: CALL_OW 72
73461: NOT
73462: OR
73463: IFFALSE 73467
// continue ;
73465: GO 73421
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
73467: LD_ADDR_VAR 0 5
73471: PUSH
73472: LD_EXP 98
73476: PUSH
73477: LD_VAR 0 2
73481: ARRAY
73482: PUSH
73483: LD_INT 1
73485: ARRAY
73486: PPUSH
73487: CALL_OW 255
73491: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
73492: LD_VAR 0 5
73496: PPUSH
73497: LD_INT 2
73499: PPUSH
73500: CALL_OW 325
73504: IFFALSE 73757
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73506: LD_ADDR_VAR 0 4
73510: PUSH
73511: LD_EXP 98
73515: PUSH
73516: LD_VAR 0 2
73520: ARRAY
73521: PPUSH
73522: LD_INT 25
73524: PUSH
73525: LD_INT 16
73527: PUSH
73528: EMPTY
73529: LIST
73530: LIST
73531: PPUSH
73532: CALL_OW 72
73536: ST_TO_ADDR
// if tmp < 6 then
73537: LD_VAR 0 4
73541: PUSH
73542: LD_INT 6
73544: LESS
73545: IFFALSE 73757
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73547: LD_ADDR_VAR 0 6
73551: PUSH
73552: LD_EXP 69
73556: PUSH
73557: LD_VAR 0 2
73561: ARRAY
73562: PPUSH
73563: LD_INT 2
73565: PUSH
73566: LD_INT 30
73568: PUSH
73569: LD_INT 0
73571: PUSH
73572: EMPTY
73573: LIST
73574: LIST
73575: PUSH
73576: LD_INT 30
73578: PUSH
73579: LD_INT 1
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: PUSH
73586: EMPTY
73587: LIST
73588: LIST
73589: LIST
73590: PPUSH
73591: CALL_OW 72
73595: ST_TO_ADDR
// if depot then
73596: LD_VAR 0 6
73600: IFFALSE 73757
// begin selected := 0 ;
73602: LD_ADDR_VAR 0 7
73606: PUSH
73607: LD_INT 0
73609: ST_TO_ADDR
// for j in depot do
73610: LD_ADDR_VAR 0 3
73614: PUSH
73615: LD_VAR 0 6
73619: PUSH
73620: FOR_IN
73621: IFFALSE 73652
// begin if UnitsInside ( j ) < 6 then
73623: LD_VAR 0 3
73627: PPUSH
73628: CALL_OW 313
73632: PUSH
73633: LD_INT 6
73635: LESS
73636: IFFALSE 73650
// begin selected := j ;
73638: LD_ADDR_VAR 0 7
73642: PUSH
73643: LD_VAR 0 3
73647: ST_TO_ADDR
// break ;
73648: GO 73652
// end ; end ;
73650: GO 73620
73652: POP
73653: POP
// if selected then
73654: LD_VAR 0 7
73658: IFFALSE 73757
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73660: LD_ADDR_VAR 0 3
73664: PUSH
73665: LD_EXP 98
73669: PUSH
73670: LD_VAR 0 2
73674: ARRAY
73675: PPUSH
73676: LD_INT 25
73678: PUSH
73679: LD_INT 12
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: PPUSH
73686: CALL_OW 72
73690: PUSH
73691: FOR_IN
73692: IFFALSE 73755
// if not HasTask ( j ) then
73694: LD_VAR 0 3
73698: PPUSH
73699: CALL_OW 314
73703: NOT
73704: IFFALSE 73753
// begin if not IsInUnit ( j ) then
73706: LD_VAR 0 3
73710: PPUSH
73711: CALL_OW 310
73715: NOT
73716: IFFALSE 73732
// ComEnterUnit ( j , selected ) ;
73718: LD_VAR 0 3
73722: PPUSH
73723: LD_VAR 0 7
73727: PPUSH
73728: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
73732: LD_VAR 0 3
73736: PPUSH
73737: LD_INT 16
73739: PPUSH
73740: CALL_OW 183
// AddComExitBuilding ( j ) ;
73744: LD_VAR 0 3
73748: PPUSH
73749: CALL_OW 182
// end ;
73753: GO 73691
73755: POP
73756: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
73757: LD_VAR 0 5
73761: PPUSH
73762: LD_INT 11
73764: PPUSH
73765: CALL_OW 325
73769: IFFALSE 74028
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73771: LD_ADDR_VAR 0 4
73775: PUSH
73776: LD_EXP 98
73780: PUSH
73781: LD_VAR 0 2
73785: ARRAY
73786: PPUSH
73787: LD_INT 25
73789: PUSH
73790: LD_INT 16
73792: PUSH
73793: EMPTY
73794: LIST
73795: LIST
73796: PPUSH
73797: CALL_OW 72
73801: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
73802: LD_VAR 0 4
73806: PUSH
73807: LD_INT 6
73809: GREATEREQUAL
73810: PUSH
73811: LD_VAR 0 5
73815: PPUSH
73816: LD_INT 2
73818: PPUSH
73819: CALL_OW 325
73823: NOT
73824: OR
73825: IFFALSE 74028
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
73827: LD_ADDR_VAR 0 8
73831: PUSH
73832: LD_EXP 69
73836: PUSH
73837: LD_VAR 0 2
73841: ARRAY
73842: PPUSH
73843: LD_INT 2
73845: PUSH
73846: LD_INT 30
73848: PUSH
73849: LD_INT 4
73851: PUSH
73852: EMPTY
73853: LIST
73854: LIST
73855: PUSH
73856: LD_INT 30
73858: PUSH
73859: LD_INT 5
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: LIST
73870: PPUSH
73871: CALL_OW 72
73875: ST_TO_ADDR
// if barracks then
73876: LD_VAR 0 8
73880: IFFALSE 74028
// begin selected := 0 ;
73882: LD_ADDR_VAR 0 7
73886: PUSH
73887: LD_INT 0
73889: ST_TO_ADDR
// for j in barracks do
73890: LD_ADDR_VAR 0 3
73894: PUSH
73895: LD_VAR 0 8
73899: PUSH
73900: FOR_IN
73901: IFFALSE 73932
// begin if UnitsInside ( j ) < 6 then
73903: LD_VAR 0 3
73907: PPUSH
73908: CALL_OW 313
73912: PUSH
73913: LD_INT 6
73915: LESS
73916: IFFALSE 73930
// begin selected := j ;
73918: LD_ADDR_VAR 0 7
73922: PUSH
73923: LD_VAR 0 3
73927: ST_TO_ADDR
// break ;
73928: GO 73932
// end ; end ;
73930: GO 73900
73932: POP
73933: POP
// if selected then
73934: LD_VAR 0 7
73938: IFFALSE 74028
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73940: LD_ADDR_VAR 0 3
73944: PUSH
73945: LD_EXP 98
73949: PUSH
73950: LD_VAR 0 2
73954: ARRAY
73955: PPUSH
73956: LD_INT 25
73958: PUSH
73959: LD_INT 12
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PPUSH
73966: CALL_OW 72
73970: PUSH
73971: FOR_IN
73972: IFFALSE 74026
// if not IsInUnit ( j ) and not HasTask ( j ) then
73974: LD_VAR 0 3
73978: PPUSH
73979: CALL_OW 310
73983: NOT
73984: PUSH
73985: LD_VAR 0 3
73989: PPUSH
73990: CALL_OW 314
73994: NOT
73995: AND
73996: IFFALSE 74024
// begin ComEnterUnit ( j , selected ) ;
73998: LD_VAR 0 3
74002: PPUSH
74003: LD_VAR 0 7
74007: PPUSH
74008: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
74012: LD_VAR 0 3
74016: PPUSH
74017: LD_INT 15
74019: PPUSH
74020: CALL_OW 183
// end ;
74024: GO 73971
74026: POP
74027: POP
// end ; end ; end ; end ; end ;
74028: GO 73421
74030: POP
74031: POP
// end ;
74032: LD_VAR 0 1
74036: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
74037: LD_INT 0
74039: PPUSH
74040: PPUSH
74041: PPUSH
74042: PPUSH
// if not mc_bases then
74043: LD_EXP 69
74047: NOT
74048: IFFALSE 74052
// exit ;
74050: GO 74230
// for i = 1 to mc_bases do
74052: LD_ADDR_VAR 0 2
74056: PUSH
74057: DOUBLE
74058: LD_INT 1
74060: DEC
74061: ST_TO_ADDR
74062: LD_EXP 69
74066: PUSH
74067: FOR_TO
74068: IFFALSE 74228
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
74070: LD_ADDR_VAR 0 4
74074: PUSH
74075: LD_EXP 69
74079: PUSH
74080: LD_VAR 0 2
74084: ARRAY
74085: PPUSH
74086: LD_INT 25
74088: PUSH
74089: LD_INT 9
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PPUSH
74096: CALL_OW 72
74100: ST_TO_ADDR
// if not tmp then
74101: LD_VAR 0 4
74105: NOT
74106: IFFALSE 74110
// continue ;
74108: GO 74067
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
74110: LD_EXP 95
74114: PUSH
74115: LD_VAR 0 2
74119: ARRAY
74120: PPUSH
74121: LD_INT 29
74123: PPUSH
74124: CALL_OW 325
74128: NOT
74129: PUSH
74130: LD_EXP 95
74134: PUSH
74135: LD_VAR 0 2
74139: ARRAY
74140: PPUSH
74141: LD_INT 28
74143: PPUSH
74144: CALL_OW 325
74148: NOT
74149: AND
74150: IFFALSE 74154
// continue ;
74152: GO 74067
// for j in tmp do
74154: LD_ADDR_VAR 0 3
74158: PUSH
74159: LD_VAR 0 4
74163: PUSH
74164: FOR_IN
74165: IFFALSE 74224
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74167: LD_VAR 0 3
74171: PUSH
74172: LD_EXP 72
74176: PUSH
74177: LD_VAR 0 2
74181: ARRAY
74182: PUSH
74183: LD_INT 1
74185: ARRAY
74186: IN
74187: NOT
74188: PUSH
74189: LD_VAR 0 3
74193: PUSH
74194: LD_EXP 72
74198: PUSH
74199: LD_VAR 0 2
74203: ARRAY
74204: PUSH
74205: LD_INT 2
74207: ARRAY
74208: IN
74209: NOT
74210: AND
74211: IFFALSE 74222
// ComSpaceTimeShoot ( j ) ;
74213: LD_VAR 0 3
74217: PPUSH
74218: CALL 14549 0 1
74222: GO 74164
74224: POP
74225: POP
// end ;
74226: GO 74067
74228: POP
74229: POP
// end ;
74230: LD_VAR 0 1
74234: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
74235: LD_INT 0
74237: PPUSH
74238: PPUSH
74239: PPUSH
74240: PPUSH
74241: PPUSH
74242: PPUSH
74243: PPUSH
74244: PPUSH
74245: PPUSH
// if not mc_bases then
74246: LD_EXP 69
74250: NOT
74251: IFFALSE 74255
// exit ;
74253: GO 74877
// for i = 1 to mc_bases do
74255: LD_ADDR_VAR 0 2
74259: PUSH
74260: DOUBLE
74261: LD_INT 1
74263: DEC
74264: ST_TO_ADDR
74265: LD_EXP 69
74269: PUSH
74270: FOR_TO
74271: IFFALSE 74875
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
74273: LD_EXP 104
74277: PUSH
74278: LD_VAR 0 2
74282: ARRAY
74283: NOT
74284: PUSH
74285: LD_INT 38
74287: PPUSH
74288: LD_EXP 95
74292: PUSH
74293: LD_VAR 0 2
74297: ARRAY
74298: PPUSH
74299: CALL_OW 321
74303: PUSH
74304: LD_INT 2
74306: NONEQUAL
74307: OR
74308: IFFALSE 74312
// continue ;
74310: GO 74270
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
74312: LD_ADDR_VAR 0 8
74316: PUSH
74317: LD_EXP 69
74321: PUSH
74322: LD_VAR 0 2
74326: ARRAY
74327: PPUSH
74328: LD_INT 30
74330: PUSH
74331: LD_INT 34
74333: PUSH
74334: EMPTY
74335: LIST
74336: LIST
74337: PPUSH
74338: CALL_OW 72
74342: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
74343: LD_ADDR_VAR 0 9
74347: PUSH
74348: LD_EXP 69
74352: PUSH
74353: LD_VAR 0 2
74357: ARRAY
74358: PPUSH
74359: LD_INT 25
74361: PUSH
74362: LD_INT 4
74364: PUSH
74365: EMPTY
74366: LIST
74367: LIST
74368: PPUSH
74369: CALL_OW 72
74373: PPUSH
74374: LD_INT 0
74376: PPUSH
74377: CALL 47857 0 2
74381: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
74382: LD_VAR 0 9
74386: NOT
74387: PUSH
74388: LD_VAR 0 8
74392: NOT
74393: OR
74394: PUSH
74395: LD_EXP 69
74399: PUSH
74400: LD_VAR 0 2
74404: ARRAY
74405: PPUSH
74406: LD_INT 124
74408: PPUSH
74409: CALL 47857 0 2
74413: OR
74414: IFFALSE 74418
// continue ;
74416: GO 74270
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
74418: LD_EXP 105
74422: PUSH
74423: LD_VAR 0 2
74427: ARRAY
74428: PUSH
74429: LD_EXP 104
74433: PUSH
74434: LD_VAR 0 2
74438: ARRAY
74439: LESS
74440: PUSH
74441: LD_EXP 105
74445: PUSH
74446: LD_VAR 0 2
74450: ARRAY
74451: PUSH
74452: LD_VAR 0 8
74456: LESS
74457: AND
74458: IFFALSE 74873
// begin tmp := sci [ 1 ] ;
74460: LD_ADDR_VAR 0 7
74464: PUSH
74465: LD_VAR 0 9
74469: PUSH
74470: LD_INT 1
74472: ARRAY
74473: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
74474: LD_VAR 0 7
74478: PPUSH
74479: LD_INT 124
74481: PPUSH
74482: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
74486: LD_ADDR_VAR 0 3
74490: PUSH
74491: DOUBLE
74492: LD_EXP 104
74496: PUSH
74497: LD_VAR 0 2
74501: ARRAY
74502: INC
74503: ST_TO_ADDR
74504: LD_EXP 104
74508: PUSH
74509: LD_VAR 0 2
74513: ARRAY
74514: PUSH
74515: FOR_DOWNTO
74516: IFFALSE 74859
// begin if IsInUnit ( tmp ) then
74518: LD_VAR 0 7
74522: PPUSH
74523: CALL_OW 310
74527: IFFALSE 74538
// ComExitBuilding ( tmp ) ;
74529: LD_VAR 0 7
74533: PPUSH
74534: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
74538: LD_INT 35
74540: PPUSH
74541: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
74545: LD_VAR 0 7
74549: PPUSH
74550: CALL_OW 310
74554: NOT
74555: PUSH
74556: LD_VAR 0 7
74560: PPUSH
74561: CALL_OW 314
74565: NOT
74566: AND
74567: IFFALSE 74538
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
74569: LD_ADDR_VAR 0 6
74573: PUSH
74574: LD_VAR 0 7
74578: PPUSH
74579: CALL_OW 250
74583: PUSH
74584: LD_VAR 0 7
74588: PPUSH
74589: CALL_OW 251
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74598: LD_INT 35
74600: PPUSH
74601: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
74605: LD_ADDR_VAR 0 4
74609: PUSH
74610: LD_EXP 104
74614: PUSH
74615: LD_VAR 0 2
74619: ARRAY
74620: PUSH
74621: LD_VAR 0 3
74625: ARRAY
74626: PUSH
74627: LD_INT 1
74629: ARRAY
74630: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
74631: LD_ADDR_VAR 0 5
74635: PUSH
74636: LD_EXP 104
74640: PUSH
74641: LD_VAR 0 2
74645: ARRAY
74646: PUSH
74647: LD_VAR 0 3
74651: ARRAY
74652: PUSH
74653: LD_INT 2
74655: ARRAY
74656: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
74657: LD_VAR 0 7
74661: PPUSH
74662: LD_INT 10
74664: PPUSH
74665: CALL 21187 0 2
74669: PUSH
74670: LD_INT 4
74672: ARRAY
74673: IFFALSE 74711
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
74675: LD_VAR 0 7
74679: PPUSH
74680: LD_VAR 0 6
74684: PUSH
74685: LD_INT 1
74687: ARRAY
74688: PPUSH
74689: LD_VAR 0 6
74693: PUSH
74694: LD_INT 2
74696: ARRAY
74697: PPUSH
74698: CALL_OW 111
// wait ( 0 0$10 ) ;
74702: LD_INT 350
74704: PPUSH
74705: CALL_OW 67
// end else
74709: GO 74737
// begin ComMoveXY ( tmp , x , y ) ;
74711: LD_VAR 0 7
74715: PPUSH
74716: LD_VAR 0 4
74720: PPUSH
74721: LD_VAR 0 5
74725: PPUSH
74726: CALL_OW 111
// wait ( 0 0$3 ) ;
74730: LD_INT 105
74732: PPUSH
74733: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
74737: LD_VAR 0 7
74741: PPUSH
74742: LD_VAR 0 4
74746: PPUSH
74747: LD_VAR 0 5
74751: PPUSH
74752: CALL_OW 307
74756: IFFALSE 74598
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
74758: LD_VAR 0 7
74762: PPUSH
74763: LD_VAR 0 4
74767: PPUSH
74768: LD_VAR 0 5
74772: PPUSH
74773: LD_VAR 0 8
74777: PUSH
74778: LD_VAR 0 3
74782: ARRAY
74783: PPUSH
74784: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
74788: LD_INT 35
74790: PPUSH
74791: CALL_OW 67
// until not HasTask ( tmp ) ;
74795: LD_VAR 0 7
74799: PPUSH
74800: CALL_OW 314
74804: NOT
74805: IFFALSE 74788
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
74807: LD_ADDR_EXP 105
74811: PUSH
74812: LD_EXP 105
74816: PPUSH
74817: LD_VAR 0 2
74821: PUSH
74822: LD_EXP 105
74826: PUSH
74827: LD_VAR 0 2
74831: ARRAY
74832: PUSH
74833: LD_INT 1
74835: PLUS
74836: PUSH
74837: EMPTY
74838: LIST
74839: LIST
74840: PPUSH
74841: LD_VAR 0 8
74845: PUSH
74846: LD_VAR 0 3
74850: ARRAY
74851: PPUSH
74852: CALL 18588 0 3
74856: ST_TO_ADDR
// end ;
74857: GO 74515
74859: POP
74860: POP
// MC_Reset ( i , 124 ) ;
74861: LD_VAR 0 2
74865: PPUSH
74866: LD_INT 124
74868: PPUSH
74869: CALL 58015 0 2
// end ; end ;
74873: GO 74270
74875: POP
74876: POP
// end ;
74877: LD_VAR 0 1
74881: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
74882: LD_INT 0
74884: PPUSH
74885: PPUSH
74886: PPUSH
// if not mc_bases then
74887: LD_EXP 69
74891: NOT
74892: IFFALSE 74896
// exit ;
74894: GO 75502
// for i = 1 to mc_bases do
74896: LD_ADDR_VAR 0 2
74900: PUSH
74901: DOUBLE
74902: LD_INT 1
74904: DEC
74905: ST_TO_ADDR
74906: LD_EXP 69
74910: PUSH
74911: FOR_TO
74912: IFFALSE 75500
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
74914: LD_ADDR_VAR 0 3
74918: PUSH
74919: LD_EXP 69
74923: PUSH
74924: LD_VAR 0 2
74928: ARRAY
74929: PPUSH
74930: LD_INT 25
74932: PUSH
74933: LD_INT 4
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: PPUSH
74940: CALL_OW 72
74944: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
74945: LD_VAR 0 3
74949: NOT
74950: PUSH
74951: LD_EXP 106
74955: PUSH
74956: LD_VAR 0 2
74960: ARRAY
74961: NOT
74962: OR
74963: PUSH
74964: LD_EXP 69
74968: PUSH
74969: LD_VAR 0 2
74973: ARRAY
74974: PPUSH
74975: LD_INT 2
74977: PUSH
74978: LD_INT 30
74980: PUSH
74981: LD_INT 0
74983: PUSH
74984: EMPTY
74985: LIST
74986: LIST
74987: PUSH
74988: LD_INT 30
74990: PUSH
74991: LD_INT 1
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: PUSH
74998: EMPTY
74999: LIST
75000: LIST
75001: LIST
75002: PPUSH
75003: CALL_OW 72
75007: NOT
75008: OR
75009: IFFALSE 75059
// begin if mc_deposits_finder [ i ] then
75011: LD_EXP 107
75015: PUSH
75016: LD_VAR 0 2
75020: ARRAY
75021: IFFALSE 75057
// begin MC_Reset ( i , 125 ) ;
75023: LD_VAR 0 2
75027: PPUSH
75028: LD_INT 125
75030: PPUSH
75031: CALL 58015 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75035: LD_ADDR_EXP 107
75039: PUSH
75040: LD_EXP 107
75044: PPUSH
75045: LD_VAR 0 2
75049: PPUSH
75050: EMPTY
75051: PPUSH
75052: CALL_OW 1
75056: ST_TO_ADDR
// end ; continue ;
75057: GO 74911
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
75059: LD_EXP 106
75063: PUSH
75064: LD_VAR 0 2
75068: ARRAY
75069: PUSH
75070: LD_INT 1
75072: ARRAY
75073: PUSH
75074: LD_INT 3
75076: ARRAY
75077: PUSH
75078: LD_INT 1
75080: EQUAL
75081: PUSH
75082: LD_INT 20
75084: PPUSH
75085: LD_EXP 95
75089: PUSH
75090: LD_VAR 0 2
75094: ARRAY
75095: PPUSH
75096: CALL_OW 321
75100: PUSH
75101: LD_INT 2
75103: NONEQUAL
75104: AND
75105: IFFALSE 75155
// begin if mc_deposits_finder [ i ] then
75107: LD_EXP 107
75111: PUSH
75112: LD_VAR 0 2
75116: ARRAY
75117: IFFALSE 75153
// begin MC_Reset ( i , 125 ) ;
75119: LD_VAR 0 2
75123: PPUSH
75124: LD_INT 125
75126: PPUSH
75127: CALL 58015 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75131: LD_ADDR_EXP 107
75135: PUSH
75136: LD_EXP 107
75140: PPUSH
75141: LD_VAR 0 2
75145: PPUSH
75146: EMPTY
75147: PPUSH
75148: CALL_OW 1
75152: ST_TO_ADDR
// end ; continue ;
75153: GO 74911
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
75155: LD_EXP 106
75159: PUSH
75160: LD_VAR 0 2
75164: ARRAY
75165: PUSH
75166: LD_INT 1
75168: ARRAY
75169: PUSH
75170: LD_INT 1
75172: ARRAY
75173: PPUSH
75174: LD_EXP 106
75178: PUSH
75179: LD_VAR 0 2
75183: ARRAY
75184: PUSH
75185: LD_INT 1
75187: ARRAY
75188: PUSH
75189: LD_INT 2
75191: ARRAY
75192: PPUSH
75193: LD_EXP 95
75197: PUSH
75198: LD_VAR 0 2
75202: ARRAY
75203: PPUSH
75204: CALL_OW 440
75208: IFFALSE 75251
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
75210: LD_ADDR_EXP 106
75214: PUSH
75215: LD_EXP 106
75219: PPUSH
75220: LD_VAR 0 2
75224: PPUSH
75225: LD_EXP 106
75229: PUSH
75230: LD_VAR 0 2
75234: ARRAY
75235: PPUSH
75236: LD_INT 1
75238: PPUSH
75239: CALL_OW 3
75243: PPUSH
75244: CALL_OW 1
75248: ST_TO_ADDR
75249: GO 75498
// begin if not mc_deposits_finder [ i ] then
75251: LD_EXP 107
75255: PUSH
75256: LD_VAR 0 2
75260: ARRAY
75261: NOT
75262: IFFALSE 75314
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
75264: LD_ADDR_EXP 107
75268: PUSH
75269: LD_EXP 107
75273: PPUSH
75274: LD_VAR 0 2
75278: PPUSH
75279: LD_VAR 0 3
75283: PUSH
75284: LD_INT 1
75286: ARRAY
75287: PUSH
75288: EMPTY
75289: LIST
75290: PPUSH
75291: CALL_OW 1
75295: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
75296: LD_VAR 0 3
75300: PUSH
75301: LD_INT 1
75303: ARRAY
75304: PPUSH
75305: LD_INT 125
75307: PPUSH
75308: CALL_OW 109
// end else
75312: GO 75498
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
75314: LD_EXP 107
75318: PUSH
75319: LD_VAR 0 2
75323: ARRAY
75324: PUSH
75325: LD_INT 1
75327: ARRAY
75328: PPUSH
75329: CALL_OW 310
75333: IFFALSE 75356
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
75335: LD_EXP 107
75339: PUSH
75340: LD_VAR 0 2
75344: ARRAY
75345: PUSH
75346: LD_INT 1
75348: ARRAY
75349: PPUSH
75350: CALL_OW 122
75354: GO 75498
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
75356: LD_EXP 107
75360: PUSH
75361: LD_VAR 0 2
75365: ARRAY
75366: PUSH
75367: LD_INT 1
75369: ARRAY
75370: PPUSH
75371: CALL_OW 314
75375: NOT
75376: PUSH
75377: LD_EXP 107
75381: PUSH
75382: LD_VAR 0 2
75386: ARRAY
75387: PUSH
75388: LD_INT 1
75390: ARRAY
75391: PPUSH
75392: LD_EXP 106
75396: PUSH
75397: LD_VAR 0 2
75401: ARRAY
75402: PUSH
75403: LD_INT 1
75405: ARRAY
75406: PUSH
75407: LD_INT 1
75409: ARRAY
75410: PPUSH
75411: LD_EXP 106
75415: PUSH
75416: LD_VAR 0 2
75420: ARRAY
75421: PUSH
75422: LD_INT 1
75424: ARRAY
75425: PUSH
75426: LD_INT 2
75428: ARRAY
75429: PPUSH
75430: CALL_OW 297
75434: PUSH
75435: LD_INT 6
75437: GREATER
75438: AND
75439: IFFALSE 75498
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
75441: LD_EXP 107
75445: PUSH
75446: LD_VAR 0 2
75450: ARRAY
75451: PUSH
75452: LD_INT 1
75454: ARRAY
75455: PPUSH
75456: LD_EXP 106
75460: PUSH
75461: LD_VAR 0 2
75465: ARRAY
75466: PUSH
75467: LD_INT 1
75469: ARRAY
75470: PUSH
75471: LD_INT 1
75473: ARRAY
75474: PPUSH
75475: LD_EXP 106
75479: PUSH
75480: LD_VAR 0 2
75484: ARRAY
75485: PUSH
75486: LD_INT 1
75488: ARRAY
75489: PUSH
75490: LD_INT 2
75492: ARRAY
75493: PPUSH
75494: CALL_OW 111
// end ; end ; end ;
75498: GO 74911
75500: POP
75501: POP
// end ;
75502: LD_VAR 0 1
75506: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
75507: LD_INT 0
75509: PPUSH
75510: PPUSH
75511: PPUSH
75512: PPUSH
75513: PPUSH
75514: PPUSH
75515: PPUSH
75516: PPUSH
75517: PPUSH
75518: PPUSH
75519: PPUSH
// if not mc_bases then
75520: LD_EXP 69
75524: NOT
75525: IFFALSE 75529
// exit ;
75527: GO 76469
// for i = 1 to mc_bases do
75529: LD_ADDR_VAR 0 2
75533: PUSH
75534: DOUBLE
75535: LD_INT 1
75537: DEC
75538: ST_TO_ADDR
75539: LD_EXP 69
75543: PUSH
75544: FOR_TO
75545: IFFALSE 76467
// begin if not mc_bases [ i ] or mc_scan [ i ] then
75547: LD_EXP 69
75551: PUSH
75552: LD_VAR 0 2
75556: ARRAY
75557: NOT
75558: PUSH
75559: LD_EXP 92
75563: PUSH
75564: LD_VAR 0 2
75568: ARRAY
75569: OR
75570: IFFALSE 75574
// continue ;
75572: GO 75544
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
75574: LD_ADDR_VAR 0 7
75578: PUSH
75579: LD_EXP 69
75583: PUSH
75584: LD_VAR 0 2
75588: ARRAY
75589: PUSH
75590: LD_INT 1
75592: ARRAY
75593: PPUSH
75594: CALL_OW 248
75598: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
75599: LD_VAR 0 7
75603: PUSH
75604: LD_INT 3
75606: EQUAL
75607: PUSH
75608: LD_EXP 88
75612: PUSH
75613: LD_VAR 0 2
75617: ARRAY
75618: PUSH
75619: LD_EXP 91
75623: PUSH
75624: LD_VAR 0 2
75628: ARRAY
75629: UNION
75630: PPUSH
75631: LD_INT 33
75633: PUSH
75634: LD_INT 2
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PPUSH
75641: CALL_OW 72
75645: NOT
75646: OR
75647: IFFALSE 75651
// continue ;
75649: GO 75544
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
75651: LD_ADDR_VAR 0 9
75655: PUSH
75656: LD_EXP 69
75660: PUSH
75661: LD_VAR 0 2
75665: ARRAY
75666: PPUSH
75667: LD_INT 30
75669: PUSH
75670: LD_INT 36
75672: PUSH
75673: EMPTY
75674: LIST
75675: LIST
75676: PPUSH
75677: CALL_OW 72
75681: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
75682: LD_ADDR_VAR 0 10
75686: PUSH
75687: LD_EXP 88
75691: PUSH
75692: LD_VAR 0 2
75696: ARRAY
75697: PPUSH
75698: LD_INT 34
75700: PUSH
75701: LD_INT 31
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: PPUSH
75708: CALL_OW 72
75712: ST_TO_ADDR
// if not cts and not mcts then
75713: LD_VAR 0 9
75717: NOT
75718: PUSH
75719: LD_VAR 0 10
75723: NOT
75724: AND
75725: IFFALSE 75729
// continue ;
75727: GO 75544
// x := cts ;
75729: LD_ADDR_VAR 0 11
75733: PUSH
75734: LD_VAR 0 9
75738: ST_TO_ADDR
// if not x then
75739: LD_VAR 0 11
75743: NOT
75744: IFFALSE 75756
// x := mcts ;
75746: LD_ADDR_VAR 0 11
75750: PUSH
75751: LD_VAR 0 10
75755: ST_TO_ADDR
// if not x then
75756: LD_VAR 0 11
75760: NOT
75761: IFFALSE 75765
// continue ;
75763: GO 75544
// if mc_remote_driver [ i ] then
75765: LD_EXP 109
75769: PUSH
75770: LD_VAR 0 2
75774: ARRAY
75775: IFFALSE 76162
// for j in mc_remote_driver [ i ] do
75777: LD_ADDR_VAR 0 3
75781: PUSH
75782: LD_EXP 109
75786: PUSH
75787: LD_VAR 0 2
75791: ARRAY
75792: PUSH
75793: FOR_IN
75794: IFFALSE 76160
// begin if GetClass ( j ) <> 3 then
75796: LD_VAR 0 3
75800: PPUSH
75801: CALL_OW 257
75805: PUSH
75806: LD_INT 3
75808: NONEQUAL
75809: IFFALSE 75862
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
75811: LD_ADDR_EXP 109
75815: PUSH
75816: LD_EXP 109
75820: PPUSH
75821: LD_VAR 0 2
75825: PPUSH
75826: LD_EXP 109
75830: PUSH
75831: LD_VAR 0 2
75835: ARRAY
75836: PUSH
75837: LD_VAR 0 3
75841: DIFF
75842: PPUSH
75843: CALL_OW 1
75847: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75848: LD_VAR 0 3
75852: PPUSH
75853: LD_INT 0
75855: PPUSH
75856: CALL_OW 109
// continue ;
75860: GO 75793
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
75862: LD_EXP 88
75866: PUSH
75867: LD_VAR 0 2
75871: ARRAY
75872: PPUSH
75873: LD_INT 34
75875: PUSH
75876: LD_INT 31
75878: PUSH
75879: EMPTY
75880: LIST
75881: LIST
75882: PUSH
75883: LD_INT 58
75885: PUSH
75886: EMPTY
75887: LIST
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: PPUSH
75893: CALL_OW 72
75897: PUSH
75898: LD_VAR 0 3
75902: PPUSH
75903: CALL 47945 0 1
75907: NOT
75908: AND
75909: IFFALSE 75980
// begin if IsInUnit ( j ) then
75911: LD_VAR 0 3
75915: PPUSH
75916: CALL_OW 310
75920: IFFALSE 75931
// ComExitBuilding ( j ) ;
75922: LD_VAR 0 3
75926: PPUSH
75927: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
75931: LD_VAR 0 3
75935: PPUSH
75936: LD_EXP 88
75940: PUSH
75941: LD_VAR 0 2
75945: ARRAY
75946: PPUSH
75947: LD_INT 34
75949: PUSH
75950: LD_INT 31
75952: PUSH
75953: EMPTY
75954: LIST
75955: LIST
75956: PUSH
75957: LD_INT 58
75959: PUSH
75960: EMPTY
75961: LIST
75962: PUSH
75963: EMPTY
75964: LIST
75965: LIST
75966: PPUSH
75967: CALL_OW 72
75971: PUSH
75972: LD_INT 1
75974: ARRAY
75975: PPUSH
75976: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
75980: LD_VAR 0 3
75984: PPUSH
75985: CALL_OW 310
75989: NOT
75990: PUSH
75991: LD_VAR 0 3
75995: PPUSH
75996: CALL_OW 310
76000: PPUSH
76001: CALL_OW 266
76005: PUSH
76006: LD_INT 36
76008: NONEQUAL
76009: PUSH
76010: LD_VAR 0 3
76014: PPUSH
76015: CALL 47945 0 1
76019: NOT
76020: AND
76021: OR
76022: IFFALSE 76158
// begin if IsInUnit ( j ) then
76024: LD_VAR 0 3
76028: PPUSH
76029: CALL_OW 310
76033: IFFALSE 76044
// ComExitBuilding ( j ) ;
76035: LD_VAR 0 3
76039: PPUSH
76040: CALL_OW 122
// ct := 0 ;
76044: LD_ADDR_VAR 0 8
76048: PUSH
76049: LD_INT 0
76051: ST_TO_ADDR
// for k in x do
76052: LD_ADDR_VAR 0 4
76056: PUSH
76057: LD_VAR 0 11
76061: PUSH
76062: FOR_IN
76063: IFFALSE 76136
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
76065: LD_VAR 0 4
76069: PPUSH
76070: CALL_OW 264
76074: PUSH
76075: LD_INT 31
76077: EQUAL
76078: PUSH
76079: LD_VAR 0 4
76083: PPUSH
76084: CALL_OW 311
76088: NOT
76089: AND
76090: PUSH
76091: LD_VAR 0 4
76095: PPUSH
76096: CALL_OW 266
76100: PUSH
76101: LD_INT 36
76103: EQUAL
76104: PUSH
76105: LD_VAR 0 4
76109: PPUSH
76110: CALL_OW 313
76114: PUSH
76115: LD_INT 3
76117: LESS
76118: AND
76119: OR
76120: IFFALSE 76134
// begin ct := k ;
76122: LD_ADDR_VAR 0 8
76126: PUSH
76127: LD_VAR 0 4
76131: ST_TO_ADDR
// break ;
76132: GO 76136
// end ;
76134: GO 76062
76136: POP
76137: POP
// if ct then
76138: LD_VAR 0 8
76142: IFFALSE 76158
// ComEnterUnit ( j , ct ) ;
76144: LD_VAR 0 3
76148: PPUSH
76149: LD_VAR 0 8
76153: PPUSH
76154: CALL_OW 120
// end ; end ;
76158: GO 75793
76160: POP
76161: POP
// places := 0 ;
76162: LD_ADDR_VAR 0 5
76166: PUSH
76167: LD_INT 0
76169: ST_TO_ADDR
// for j = 1 to x do
76170: LD_ADDR_VAR 0 3
76174: PUSH
76175: DOUBLE
76176: LD_INT 1
76178: DEC
76179: ST_TO_ADDR
76180: LD_VAR 0 11
76184: PUSH
76185: FOR_TO
76186: IFFALSE 76262
// if GetWeapon ( x [ j ] ) = ar_control_tower then
76188: LD_VAR 0 11
76192: PUSH
76193: LD_VAR 0 3
76197: ARRAY
76198: PPUSH
76199: CALL_OW 264
76203: PUSH
76204: LD_INT 31
76206: EQUAL
76207: IFFALSE 76225
// places := places + 1 else
76209: LD_ADDR_VAR 0 5
76213: PUSH
76214: LD_VAR 0 5
76218: PUSH
76219: LD_INT 1
76221: PLUS
76222: ST_TO_ADDR
76223: GO 76260
// if GetBType ( x [ j ] ) = b_control_tower then
76225: LD_VAR 0 11
76229: PUSH
76230: LD_VAR 0 3
76234: ARRAY
76235: PPUSH
76236: CALL_OW 266
76240: PUSH
76241: LD_INT 36
76243: EQUAL
76244: IFFALSE 76260
// places := places + 3 ;
76246: LD_ADDR_VAR 0 5
76250: PUSH
76251: LD_VAR 0 5
76255: PUSH
76256: LD_INT 3
76258: PLUS
76259: ST_TO_ADDR
76260: GO 76185
76262: POP
76263: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
76264: LD_VAR 0 5
76268: PUSH
76269: LD_INT 0
76271: EQUAL
76272: PUSH
76273: LD_VAR 0 5
76277: PUSH
76278: LD_EXP 109
76282: PUSH
76283: LD_VAR 0 2
76287: ARRAY
76288: LESSEQUAL
76289: OR
76290: IFFALSE 76294
// continue ;
76292: GO 75544
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
76294: LD_ADDR_VAR 0 6
76298: PUSH
76299: LD_EXP 69
76303: PUSH
76304: LD_VAR 0 2
76308: ARRAY
76309: PPUSH
76310: LD_INT 25
76312: PUSH
76313: LD_INT 3
76315: PUSH
76316: EMPTY
76317: LIST
76318: LIST
76319: PPUSH
76320: CALL_OW 72
76324: PUSH
76325: LD_EXP 109
76329: PUSH
76330: LD_VAR 0 2
76334: ARRAY
76335: DIFF
76336: PPUSH
76337: LD_INT 3
76339: PPUSH
76340: CALL 48845 0 2
76344: ST_TO_ADDR
// for j in tmp do
76345: LD_ADDR_VAR 0 3
76349: PUSH
76350: LD_VAR 0 6
76354: PUSH
76355: FOR_IN
76356: IFFALSE 76391
// if GetTag ( j ) > 0 then
76358: LD_VAR 0 3
76362: PPUSH
76363: CALL_OW 110
76367: PUSH
76368: LD_INT 0
76370: GREATER
76371: IFFALSE 76389
// tmp := tmp diff j ;
76373: LD_ADDR_VAR 0 6
76377: PUSH
76378: LD_VAR 0 6
76382: PUSH
76383: LD_VAR 0 3
76387: DIFF
76388: ST_TO_ADDR
76389: GO 76355
76391: POP
76392: POP
// if not tmp then
76393: LD_VAR 0 6
76397: NOT
76398: IFFALSE 76402
// continue ;
76400: GO 75544
// if places then
76402: LD_VAR 0 5
76406: IFFALSE 76465
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
76408: LD_ADDR_EXP 109
76412: PUSH
76413: LD_EXP 109
76417: PPUSH
76418: LD_VAR 0 2
76422: PPUSH
76423: LD_EXP 109
76427: PUSH
76428: LD_VAR 0 2
76432: ARRAY
76433: PUSH
76434: LD_VAR 0 6
76438: PUSH
76439: LD_INT 1
76441: ARRAY
76442: UNION
76443: PPUSH
76444: CALL_OW 1
76448: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
76449: LD_VAR 0 6
76453: PUSH
76454: LD_INT 1
76456: ARRAY
76457: PPUSH
76458: LD_INT 126
76460: PPUSH
76461: CALL_OW 109
// end ; end ;
76465: GO 75544
76467: POP
76468: POP
// end ;
76469: LD_VAR 0 1
76473: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
76474: LD_INT 0
76476: PPUSH
76477: PPUSH
76478: PPUSH
76479: PPUSH
76480: PPUSH
76481: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
76482: LD_VAR 0 1
76486: NOT
76487: PUSH
76488: LD_VAR 0 2
76492: NOT
76493: OR
76494: PUSH
76495: LD_VAR 0 3
76499: NOT
76500: OR
76501: PUSH
76502: LD_VAR 0 4
76506: PUSH
76507: LD_INT 1
76509: PUSH
76510: LD_INT 2
76512: PUSH
76513: LD_INT 3
76515: PUSH
76516: LD_INT 4
76518: PUSH
76519: LD_INT 5
76521: PUSH
76522: LD_INT 8
76524: PUSH
76525: LD_INT 9
76527: PUSH
76528: LD_INT 15
76530: PUSH
76531: LD_INT 16
76533: PUSH
76534: EMPTY
76535: LIST
76536: LIST
76537: LIST
76538: LIST
76539: LIST
76540: LIST
76541: LIST
76542: LIST
76543: LIST
76544: IN
76545: NOT
76546: OR
76547: IFFALSE 76551
// exit ;
76549: GO 77451
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
76551: LD_ADDR_VAR 0 2
76555: PUSH
76556: LD_VAR 0 2
76560: PPUSH
76561: LD_INT 21
76563: PUSH
76564: LD_INT 3
76566: PUSH
76567: EMPTY
76568: LIST
76569: LIST
76570: PUSH
76571: LD_INT 24
76573: PUSH
76574: LD_INT 250
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: PPUSH
76585: CALL_OW 72
76589: ST_TO_ADDR
// case class of 1 , 15 :
76590: LD_VAR 0 4
76594: PUSH
76595: LD_INT 1
76597: DOUBLE
76598: EQUAL
76599: IFTRUE 76609
76601: LD_INT 15
76603: DOUBLE
76604: EQUAL
76605: IFTRUE 76609
76607: GO 76694
76609: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
76610: LD_ADDR_VAR 0 8
76614: PUSH
76615: LD_VAR 0 2
76619: PPUSH
76620: LD_INT 2
76622: PUSH
76623: LD_INT 30
76625: PUSH
76626: LD_INT 32
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 30
76635: PUSH
76636: LD_INT 31
76638: PUSH
76639: EMPTY
76640: LIST
76641: LIST
76642: PUSH
76643: EMPTY
76644: LIST
76645: LIST
76646: LIST
76647: PPUSH
76648: CALL_OW 72
76652: PUSH
76653: LD_VAR 0 2
76657: PPUSH
76658: LD_INT 2
76660: PUSH
76661: LD_INT 30
76663: PUSH
76664: LD_INT 4
76666: PUSH
76667: EMPTY
76668: LIST
76669: LIST
76670: PUSH
76671: LD_INT 30
76673: PUSH
76674: LD_INT 5
76676: PUSH
76677: EMPTY
76678: LIST
76679: LIST
76680: PUSH
76681: EMPTY
76682: LIST
76683: LIST
76684: LIST
76685: PPUSH
76686: CALL_OW 72
76690: ADD
76691: ST_TO_ADDR
76692: GO 76940
76694: LD_INT 2
76696: DOUBLE
76697: EQUAL
76698: IFTRUE 76708
76700: LD_INT 16
76702: DOUBLE
76703: EQUAL
76704: IFTRUE 76708
76706: GO 76754
76708: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
76709: LD_ADDR_VAR 0 8
76713: PUSH
76714: LD_VAR 0 2
76718: PPUSH
76719: LD_INT 2
76721: PUSH
76722: LD_INT 30
76724: PUSH
76725: LD_INT 0
76727: PUSH
76728: EMPTY
76729: LIST
76730: LIST
76731: PUSH
76732: LD_INT 30
76734: PUSH
76735: LD_INT 1
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: PUSH
76742: EMPTY
76743: LIST
76744: LIST
76745: LIST
76746: PPUSH
76747: CALL_OW 72
76751: ST_TO_ADDR
76752: GO 76940
76754: LD_INT 3
76756: DOUBLE
76757: EQUAL
76758: IFTRUE 76762
76760: GO 76808
76762: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
76763: LD_ADDR_VAR 0 8
76767: PUSH
76768: LD_VAR 0 2
76772: PPUSH
76773: LD_INT 2
76775: PUSH
76776: LD_INT 30
76778: PUSH
76779: LD_INT 2
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: LD_INT 30
76788: PUSH
76789: LD_INT 3
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: PUSH
76796: EMPTY
76797: LIST
76798: LIST
76799: LIST
76800: PPUSH
76801: CALL_OW 72
76805: ST_TO_ADDR
76806: GO 76940
76808: LD_INT 4
76810: DOUBLE
76811: EQUAL
76812: IFTRUE 76816
76814: GO 76873
76816: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
76817: LD_ADDR_VAR 0 8
76821: PUSH
76822: LD_VAR 0 2
76826: PPUSH
76827: LD_INT 2
76829: PUSH
76830: LD_INT 30
76832: PUSH
76833: LD_INT 6
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: PUSH
76840: LD_INT 30
76842: PUSH
76843: LD_INT 7
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: LD_INT 30
76852: PUSH
76853: LD_INT 8
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: PUSH
76860: EMPTY
76861: LIST
76862: LIST
76863: LIST
76864: LIST
76865: PPUSH
76866: CALL_OW 72
76870: ST_TO_ADDR
76871: GO 76940
76873: LD_INT 5
76875: DOUBLE
76876: EQUAL
76877: IFTRUE 76893
76879: LD_INT 8
76881: DOUBLE
76882: EQUAL
76883: IFTRUE 76893
76885: LD_INT 9
76887: DOUBLE
76888: EQUAL
76889: IFTRUE 76893
76891: GO 76939
76893: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
76894: LD_ADDR_VAR 0 8
76898: PUSH
76899: LD_VAR 0 2
76903: PPUSH
76904: LD_INT 2
76906: PUSH
76907: LD_INT 30
76909: PUSH
76910: LD_INT 4
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: LD_INT 30
76919: PUSH
76920: LD_INT 5
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: EMPTY
76928: LIST
76929: LIST
76930: LIST
76931: PPUSH
76932: CALL_OW 72
76936: ST_TO_ADDR
76937: GO 76940
76939: POP
// if not tmp then
76940: LD_VAR 0 8
76944: NOT
76945: IFFALSE 76949
// exit ;
76947: GO 77451
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
76949: LD_VAR 0 4
76953: PUSH
76954: LD_INT 1
76956: PUSH
76957: LD_INT 15
76959: PUSH
76960: EMPTY
76961: LIST
76962: LIST
76963: IN
76964: PUSH
76965: LD_EXP 78
76969: PUSH
76970: LD_VAR 0 1
76974: ARRAY
76975: AND
76976: IFFALSE 77132
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
76978: LD_ADDR_VAR 0 9
76982: PUSH
76983: LD_EXP 78
76987: PUSH
76988: LD_VAR 0 1
76992: ARRAY
76993: PUSH
76994: LD_INT 1
76996: ARRAY
76997: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
76998: LD_VAR 0 9
77002: PUSH
77003: LD_EXP 79
77007: PUSH
77008: LD_VAR 0 1
77012: ARRAY
77013: IN
77014: NOT
77015: IFFALSE 77130
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
77017: LD_ADDR_EXP 79
77021: PUSH
77022: LD_EXP 79
77026: PPUSH
77027: LD_VAR 0 1
77031: PUSH
77032: LD_EXP 79
77036: PUSH
77037: LD_VAR 0 1
77041: ARRAY
77042: PUSH
77043: LD_INT 1
77045: PLUS
77046: PUSH
77047: EMPTY
77048: LIST
77049: LIST
77050: PPUSH
77051: LD_VAR 0 9
77055: PPUSH
77056: CALL 18588 0 3
77060: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
77061: LD_ADDR_EXP 78
77065: PUSH
77066: LD_EXP 78
77070: PPUSH
77071: LD_VAR 0 1
77075: PPUSH
77076: LD_EXP 78
77080: PUSH
77081: LD_VAR 0 1
77085: ARRAY
77086: PUSH
77087: LD_VAR 0 9
77091: DIFF
77092: PPUSH
77093: CALL_OW 1
77097: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
77098: LD_VAR 0 3
77102: PPUSH
77103: LD_EXP 79
77107: PUSH
77108: LD_VAR 0 1
77112: ARRAY
77113: PUSH
77114: LD_EXP 79
77118: PUSH
77119: LD_VAR 0 1
77123: ARRAY
77124: ARRAY
77125: PPUSH
77126: CALL_OW 120
// end ; exit ;
77130: GO 77451
// end ; if tmp > 1 then
77132: LD_VAR 0 8
77136: PUSH
77137: LD_INT 1
77139: GREATER
77140: IFFALSE 77244
// for i = 2 to tmp do
77142: LD_ADDR_VAR 0 6
77146: PUSH
77147: DOUBLE
77148: LD_INT 2
77150: DEC
77151: ST_TO_ADDR
77152: LD_VAR 0 8
77156: PUSH
77157: FOR_TO
77158: IFFALSE 77242
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
77160: LD_VAR 0 8
77164: PUSH
77165: LD_VAR 0 6
77169: ARRAY
77170: PPUSH
77171: CALL_OW 461
77175: PUSH
77176: LD_INT 6
77178: EQUAL
77179: IFFALSE 77240
// begin x := tmp [ i ] ;
77181: LD_ADDR_VAR 0 9
77185: PUSH
77186: LD_VAR 0 8
77190: PUSH
77191: LD_VAR 0 6
77195: ARRAY
77196: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
77197: LD_ADDR_VAR 0 8
77201: PUSH
77202: LD_VAR 0 8
77206: PPUSH
77207: LD_VAR 0 6
77211: PPUSH
77212: CALL_OW 3
77216: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
77217: LD_ADDR_VAR 0 8
77221: PUSH
77222: LD_VAR 0 8
77226: PPUSH
77227: LD_INT 1
77229: PPUSH
77230: LD_VAR 0 9
77234: PPUSH
77235: CALL_OW 2
77239: ST_TO_ADDR
// end ;
77240: GO 77157
77242: POP
77243: POP
// for i in tmp do
77244: LD_ADDR_VAR 0 6
77248: PUSH
77249: LD_VAR 0 8
77253: PUSH
77254: FOR_IN
77255: IFFALSE 77324
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
77257: LD_VAR 0 6
77261: PPUSH
77262: CALL_OW 313
77266: PUSH
77267: LD_INT 6
77269: LESS
77270: PUSH
77271: LD_VAR 0 6
77275: PPUSH
77276: CALL_OW 266
77280: PUSH
77281: LD_INT 31
77283: PUSH
77284: LD_INT 32
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: IN
77291: NOT
77292: AND
77293: PUSH
77294: LD_VAR 0 6
77298: PPUSH
77299: CALL_OW 313
77303: PUSH
77304: LD_INT 0
77306: EQUAL
77307: OR
77308: IFFALSE 77322
// begin j := i ;
77310: LD_ADDR_VAR 0 7
77314: PUSH
77315: LD_VAR 0 6
77319: ST_TO_ADDR
// break ;
77320: GO 77324
// end ; end ;
77322: GO 77254
77324: POP
77325: POP
// if j then
77326: LD_VAR 0 7
77330: IFFALSE 77348
// ComEnterUnit ( unit , j ) else
77332: LD_VAR 0 3
77336: PPUSH
77337: LD_VAR 0 7
77341: PPUSH
77342: CALL_OW 120
77346: GO 77451
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77348: LD_ADDR_VAR 0 10
77352: PUSH
77353: LD_VAR 0 2
77357: PPUSH
77358: LD_INT 2
77360: PUSH
77361: LD_INT 30
77363: PUSH
77364: LD_INT 0
77366: PUSH
77367: EMPTY
77368: LIST
77369: LIST
77370: PUSH
77371: LD_INT 30
77373: PUSH
77374: LD_INT 1
77376: PUSH
77377: EMPTY
77378: LIST
77379: LIST
77380: PUSH
77381: EMPTY
77382: LIST
77383: LIST
77384: LIST
77385: PPUSH
77386: CALL_OW 72
77390: ST_TO_ADDR
// if depot then
77391: LD_VAR 0 10
77395: IFFALSE 77451
// begin depot := NearestUnitToUnit ( depot , unit ) ;
77397: LD_ADDR_VAR 0 10
77401: PUSH
77402: LD_VAR 0 10
77406: PPUSH
77407: LD_VAR 0 3
77411: PPUSH
77412: CALL_OW 74
77416: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
77417: LD_VAR 0 3
77421: PPUSH
77422: LD_VAR 0 10
77426: PPUSH
77427: CALL_OW 296
77431: PUSH
77432: LD_INT 10
77434: GREATER
77435: IFFALSE 77451
// ComStandNearbyBuilding ( unit , depot ) ;
77437: LD_VAR 0 3
77441: PPUSH
77442: LD_VAR 0 10
77446: PPUSH
77447: CALL 15166 0 2
// end ; end ; end ;
77451: LD_VAR 0 5
77455: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
77456: LD_INT 0
77458: PPUSH
77459: PPUSH
77460: PPUSH
77461: PPUSH
// if not mc_bases then
77462: LD_EXP 69
77466: NOT
77467: IFFALSE 77471
// exit ;
77469: GO 77710
// for i = 1 to mc_bases do
77471: LD_ADDR_VAR 0 2
77475: PUSH
77476: DOUBLE
77477: LD_INT 1
77479: DEC
77480: ST_TO_ADDR
77481: LD_EXP 69
77485: PUSH
77486: FOR_TO
77487: IFFALSE 77708
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
77489: LD_ADDR_VAR 0 4
77493: PUSH
77494: LD_EXP 69
77498: PUSH
77499: LD_VAR 0 2
77503: ARRAY
77504: PPUSH
77505: LD_INT 21
77507: PUSH
77508: LD_INT 1
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: PPUSH
77515: CALL_OW 72
77519: PUSH
77520: LD_EXP 98
77524: PUSH
77525: LD_VAR 0 2
77529: ARRAY
77530: UNION
77531: ST_TO_ADDR
// if not tmp then
77532: LD_VAR 0 4
77536: NOT
77537: IFFALSE 77541
// continue ;
77539: GO 77486
// for j in tmp do
77541: LD_ADDR_VAR 0 3
77545: PUSH
77546: LD_VAR 0 4
77550: PUSH
77551: FOR_IN
77552: IFFALSE 77704
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
77554: LD_VAR 0 3
77558: PPUSH
77559: CALL_OW 110
77563: NOT
77564: PUSH
77565: LD_VAR 0 3
77569: PPUSH
77570: CALL_OW 314
77574: NOT
77575: AND
77576: PUSH
77577: LD_VAR 0 3
77581: PPUSH
77582: CALL_OW 311
77586: NOT
77587: AND
77588: PUSH
77589: LD_VAR 0 3
77593: PPUSH
77594: CALL_OW 310
77598: NOT
77599: AND
77600: PUSH
77601: LD_VAR 0 3
77605: PUSH
77606: LD_EXP 72
77610: PUSH
77611: LD_VAR 0 2
77615: ARRAY
77616: PUSH
77617: LD_INT 1
77619: ARRAY
77620: IN
77621: NOT
77622: AND
77623: PUSH
77624: LD_VAR 0 3
77628: PUSH
77629: LD_EXP 72
77633: PUSH
77634: LD_VAR 0 2
77638: ARRAY
77639: PUSH
77640: LD_INT 2
77642: ARRAY
77643: IN
77644: NOT
77645: AND
77646: PUSH
77647: LD_VAR 0 3
77651: PUSH
77652: LD_EXP 81
77656: PUSH
77657: LD_VAR 0 2
77661: ARRAY
77662: IN
77663: NOT
77664: AND
77665: IFFALSE 77702
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
77667: LD_VAR 0 2
77671: PPUSH
77672: LD_EXP 69
77676: PUSH
77677: LD_VAR 0 2
77681: ARRAY
77682: PPUSH
77683: LD_VAR 0 3
77687: PPUSH
77688: LD_VAR 0 3
77692: PPUSH
77693: CALL_OW 257
77697: PPUSH
77698: CALL 76474 0 4
// end ;
77702: GO 77551
77704: POP
77705: POP
// end ;
77706: GO 77486
77708: POP
77709: POP
// end ;
77710: LD_VAR 0 1
77714: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
77715: LD_INT 0
77717: PPUSH
77718: PPUSH
77719: PPUSH
77720: PPUSH
77721: PPUSH
77722: PPUSH
// if not mc_bases [ base ] then
77723: LD_EXP 69
77727: PUSH
77728: LD_VAR 0 1
77732: ARRAY
77733: NOT
77734: IFFALSE 77738
// exit ;
77736: GO 77920
// tmp := [ ] ;
77738: LD_ADDR_VAR 0 6
77742: PUSH
77743: EMPTY
77744: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
77745: LD_ADDR_VAR 0 7
77749: PUSH
77750: LD_VAR 0 3
77754: PPUSH
77755: LD_INT 0
77757: PPUSH
77758: CALL_OW 517
77762: ST_TO_ADDR
// if not list then
77763: LD_VAR 0 7
77767: NOT
77768: IFFALSE 77772
// exit ;
77770: GO 77920
// for i = 1 to amount do
77772: LD_ADDR_VAR 0 5
77776: PUSH
77777: DOUBLE
77778: LD_INT 1
77780: DEC
77781: ST_TO_ADDR
77782: LD_VAR 0 2
77786: PUSH
77787: FOR_TO
77788: IFFALSE 77868
// begin x := rand ( 1 , list [ 1 ] ) ;
77790: LD_ADDR_VAR 0 8
77794: PUSH
77795: LD_INT 1
77797: PPUSH
77798: LD_VAR 0 7
77802: PUSH
77803: LD_INT 1
77805: ARRAY
77806: PPUSH
77807: CALL_OW 12
77811: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
77812: LD_ADDR_VAR 0 6
77816: PUSH
77817: LD_VAR 0 6
77821: PPUSH
77822: LD_VAR 0 5
77826: PPUSH
77827: LD_VAR 0 7
77831: PUSH
77832: LD_INT 1
77834: ARRAY
77835: PUSH
77836: LD_VAR 0 8
77840: ARRAY
77841: PUSH
77842: LD_VAR 0 7
77846: PUSH
77847: LD_INT 2
77849: ARRAY
77850: PUSH
77851: LD_VAR 0 8
77855: ARRAY
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PPUSH
77861: CALL_OW 1
77865: ST_TO_ADDR
// end ;
77866: GO 77787
77868: POP
77869: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
77870: LD_ADDR_EXP 82
77874: PUSH
77875: LD_EXP 82
77879: PPUSH
77880: LD_VAR 0 1
77884: PPUSH
77885: LD_VAR 0 6
77889: PPUSH
77890: CALL_OW 1
77894: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
77895: LD_ADDR_EXP 84
77899: PUSH
77900: LD_EXP 84
77904: PPUSH
77905: LD_VAR 0 1
77909: PPUSH
77910: LD_VAR 0 3
77914: PPUSH
77915: CALL_OW 1
77919: ST_TO_ADDR
// end ;
77920: LD_VAR 0 4
77924: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
77925: LD_INT 0
77927: PPUSH
// if not mc_bases [ base ] then
77928: LD_EXP 69
77932: PUSH
77933: LD_VAR 0 1
77937: ARRAY
77938: NOT
77939: IFFALSE 77943
// exit ;
77941: GO 77968
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
77943: LD_ADDR_EXP 74
77947: PUSH
77948: LD_EXP 74
77952: PPUSH
77953: LD_VAR 0 1
77957: PPUSH
77958: LD_VAR 0 2
77962: PPUSH
77963: CALL_OW 1
77967: ST_TO_ADDR
// end ;
77968: LD_VAR 0 3
77972: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
77973: LD_INT 0
77975: PPUSH
// if not mc_bases [ base ] then
77976: LD_EXP 69
77980: PUSH
77981: LD_VAR 0 1
77985: ARRAY
77986: NOT
77987: IFFALSE 77991
// exit ;
77989: GO 78028
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
77991: LD_ADDR_EXP 74
77995: PUSH
77996: LD_EXP 74
78000: PPUSH
78001: LD_VAR 0 1
78005: PPUSH
78006: LD_EXP 74
78010: PUSH
78011: LD_VAR 0 1
78015: ARRAY
78016: PUSH
78017: LD_VAR 0 2
78021: UNION
78022: PPUSH
78023: CALL_OW 1
78027: ST_TO_ADDR
// end ;
78028: LD_VAR 0 3
78032: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
78033: LD_INT 0
78035: PPUSH
// if not mc_bases [ base ] then
78036: LD_EXP 69
78040: PUSH
78041: LD_VAR 0 1
78045: ARRAY
78046: NOT
78047: IFFALSE 78051
// exit ;
78049: GO 78076
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
78051: LD_ADDR_EXP 90
78055: PUSH
78056: LD_EXP 90
78060: PPUSH
78061: LD_VAR 0 1
78065: PPUSH
78066: LD_VAR 0 2
78070: PPUSH
78071: CALL_OW 1
78075: ST_TO_ADDR
// end ;
78076: LD_VAR 0 3
78080: RET
// export function MC_InsertProduceList ( base , components ) ; begin
78081: LD_INT 0
78083: PPUSH
// if not mc_bases [ base ] then
78084: LD_EXP 69
78088: PUSH
78089: LD_VAR 0 1
78093: ARRAY
78094: NOT
78095: IFFALSE 78099
// exit ;
78097: GO 78136
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
78099: LD_ADDR_EXP 90
78103: PUSH
78104: LD_EXP 90
78108: PPUSH
78109: LD_VAR 0 1
78113: PPUSH
78114: LD_EXP 90
78118: PUSH
78119: LD_VAR 0 1
78123: ARRAY
78124: PUSH
78125: LD_VAR 0 2
78129: ADD
78130: PPUSH
78131: CALL_OW 1
78135: ST_TO_ADDR
// end ;
78136: LD_VAR 0 3
78140: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
78141: LD_INT 0
78143: PPUSH
// if not mc_bases [ base ] then
78144: LD_EXP 69
78148: PUSH
78149: LD_VAR 0 1
78153: ARRAY
78154: NOT
78155: IFFALSE 78159
// exit ;
78157: GO 78213
// mc_defender := Replace ( mc_defender , base , deflist ) ;
78159: LD_ADDR_EXP 91
78163: PUSH
78164: LD_EXP 91
78168: PPUSH
78169: LD_VAR 0 1
78173: PPUSH
78174: LD_VAR 0 2
78178: PPUSH
78179: CALL_OW 1
78183: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
78184: LD_ADDR_EXP 80
78188: PUSH
78189: LD_EXP 80
78193: PPUSH
78194: LD_VAR 0 1
78198: PPUSH
78199: LD_VAR 0 2
78203: PUSH
78204: LD_INT 0
78206: PLUS
78207: PPUSH
78208: CALL_OW 1
78212: ST_TO_ADDR
// end ;
78213: LD_VAR 0 3
78217: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
78218: LD_INT 0
78220: PPUSH
// if not mc_bases [ base ] then
78221: LD_EXP 69
78225: PUSH
78226: LD_VAR 0 1
78230: ARRAY
78231: NOT
78232: IFFALSE 78236
// exit ;
78234: GO 78261
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
78236: LD_ADDR_EXP 80
78240: PUSH
78241: LD_EXP 80
78245: PPUSH
78246: LD_VAR 0 1
78250: PPUSH
78251: LD_VAR 0 2
78255: PPUSH
78256: CALL_OW 1
78260: ST_TO_ADDR
// end ;
78261: LD_VAR 0 3
78265: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
78266: LD_INT 0
78268: PPUSH
78269: PPUSH
78270: PPUSH
78271: PPUSH
// if not mc_bases [ base ] then
78272: LD_EXP 69
78276: PUSH
78277: LD_VAR 0 1
78281: ARRAY
78282: NOT
78283: IFFALSE 78287
// exit ;
78285: GO 78352
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
78287: LD_ADDR_EXP 89
78291: PUSH
78292: LD_EXP 89
78296: PPUSH
78297: LD_VAR 0 1
78301: PUSH
78302: LD_EXP 89
78306: PUSH
78307: LD_VAR 0 1
78311: ARRAY
78312: PUSH
78313: LD_INT 1
78315: PLUS
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: PPUSH
78321: LD_VAR 0 1
78325: PUSH
78326: LD_VAR 0 2
78330: PUSH
78331: LD_VAR 0 3
78335: PUSH
78336: LD_VAR 0 4
78340: PUSH
78341: EMPTY
78342: LIST
78343: LIST
78344: LIST
78345: LIST
78346: PPUSH
78347: CALL 18588 0 3
78351: ST_TO_ADDR
// end ;
78352: LD_VAR 0 5
78356: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
78357: LD_INT 0
78359: PPUSH
// if not mc_bases [ base ] then
78360: LD_EXP 69
78364: PUSH
78365: LD_VAR 0 1
78369: ARRAY
78370: NOT
78371: IFFALSE 78375
// exit ;
78373: GO 78400
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
78375: LD_ADDR_EXP 106
78379: PUSH
78380: LD_EXP 106
78384: PPUSH
78385: LD_VAR 0 1
78389: PPUSH
78390: LD_VAR 0 2
78394: PPUSH
78395: CALL_OW 1
78399: ST_TO_ADDR
// end ;
78400: LD_VAR 0 3
78404: RET
// export function MC_GetMinesField ( base ) ; begin
78405: LD_INT 0
78407: PPUSH
// result := mc_mines [ base ] ;
78408: LD_ADDR_VAR 0 2
78412: PUSH
78413: LD_EXP 82
78417: PUSH
78418: LD_VAR 0 1
78422: ARRAY
78423: ST_TO_ADDR
// end ;
78424: LD_VAR 0 2
78428: RET
// export function MC_GetProduceList ( base ) ; begin
78429: LD_INT 0
78431: PPUSH
// result := mc_produce [ base ] ;
78432: LD_ADDR_VAR 0 2
78436: PUSH
78437: LD_EXP 90
78441: PUSH
78442: LD_VAR 0 1
78446: ARRAY
78447: ST_TO_ADDR
// end ;
78448: LD_VAR 0 2
78452: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
78453: LD_INT 0
78455: PPUSH
78456: PPUSH
// if not mc_bases then
78457: LD_EXP 69
78461: NOT
78462: IFFALSE 78466
// exit ;
78464: GO 78531
// if mc_bases [ base ] then
78466: LD_EXP 69
78470: PUSH
78471: LD_VAR 0 1
78475: ARRAY
78476: IFFALSE 78531
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78478: LD_ADDR_VAR 0 3
78482: PUSH
78483: LD_EXP 69
78487: PUSH
78488: LD_VAR 0 1
78492: ARRAY
78493: PPUSH
78494: LD_INT 30
78496: PUSH
78497: LD_VAR 0 2
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PPUSH
78506: CALL_OW 72
78510: ST_TO_ADDR
// if result then
78511: LD_VAR 0 3
78515: IFFALSE 78531
// result := result [ 1 ] ;
78517: LD_ADDR_VAR 0 3
78521: PUSH
78522: LD_VAR 0 3
78526: PUSH
78527: LD_INT 1
78529: ARRAY
78530: ST_TO_ADDR
// end ; end ;
78531: LD_VAR 0 3
78535: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
78536: LD_INT 0
78538: PPUSH
78539: PPUSH
// if not mc_bases then
78540: LD_EXP 69
78544: NOT
78545: IFFALSE 78549
// exit ;
78547: GO 78594
// if mc_bases [ base ] then
78549: LD_EXP 69
78553: PUSH
78554: LD_VAR 0 1
78558: ARRAY
78559: IFFALSE 78594
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78561: LD_ADDR_VAR 0 3
78565: PUSH
78566: LD_EXP 69
78570: PUSH
78571: LD_VAR 0 1
78575: ARRAY
78576: PPUSH
78577: LD_INT 30
78579: PUSH
78580: LD_VAR 0 2
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PPUSH
78589: CALL_OW 72
78593: ST_TO_ADDR
// end ;
78594: LD_VAR 0 3
78598: RET
// export function MC_SetTame ( base , area ) ; begin
78599: LD_INT 0
78601: PPUSH
// if not mc_bases or not base then
78602: LD_EXP 69
78606: NOT
78607: PUSH
78608: LD_VAR 0 1
78612: NOT
78613: OR
78614: IFFALSE 78618
// exit ;
78616: GO 78643
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
78618: LD_ADDR_EXP 97
78622: PUSH
78623: LD_EXP 97
78627: PPUSH
78628: LD_VAR 0 1
78632: PPUSH
78633: LD_VAR 0 2
78637: PPUSH
78638: CALL_OW 1
78642: ST_TO_ADDR
// end ;
78643: LD_VAR 0 3
78647: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
78648: LD_INT 0
78650: PPUSH
78651: PPUSH
// if not mc_bases or not base then
78652: LD_EXP 69
78656: NOT
78657: PUSH
78658: LD_VAR 0 1
78662: NOT
78663: OR
78664: IFFALSE 78668
// exit ;
78666: GO 78770
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78668: LD_ADDR_VAR 0 4
78672: PUSH
78673: LD_EXP 69
78677: PUSH
78678: LD_VAR 0 1
78682: ARRAY
78683: PPUSH
78684: LD_INT 30
78686: PUSH
78687: LD_VAR 0 2
78691: PUSH
78692: EMPTY
78693: LIST
78694: LIST
78695: PPUSH
78696: CALL_OW 72
78700: ST_TO_ADDR
// if not tmp then
78701: LD_VAR 0 4
78705: NOT
78706: IFFALSE 78710
// exit ;
78708: GO 78770
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
78710: LD_ADDR_EXP 101
78714: PUSH
78715: LD_EXP 101
78719: PPUSH
78720: LD_VAR 0 1
78724: PPUSH
78725: LD_EXP 101
78729: PUSH
78730: LD_VAR 0 1
78734: ARRAY
78735: PPUSH
78736: LD_EXP 101
78740: PUSH
78741: LD_VAR 0 1
78745: ARRAY
78746: PUSH
78747: LD_INT 1
78749: PLUS
78750: PPUSH
78751: LD_VAR 0 4
78755: PUSH
78756: LD_INT 1
78758: ARRAY
78759: PPUSH
78760: CALL_OW 2
78764: PPUSH
78765: CALL_OW 1
78769: ST_TO_ADDR
// end ;
78770: LD_VAR 0 3
78774: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
78775: LD_INT 0
78777: PPUSH
78778: PPUSH
// if not mc_bases or not base or not kinds then
78779: LD_EXP 69
78783: NOT
78784: PUSH
78785: LD_VAR 0 1
78789: NOT
78790: OR
78791: PUSH
78792: LD_VAR 0 2
78796: NOT
78797: OR
78798: IFFALSE 78802
// exit ;
78800: GO 78863
// for i in kinds do
78802: LD_ADDR_VAR 0 4
78806: PUSH
78807: LD_VAR 0 2
78811: PUSH
78812: FOR_IN
78813: IFFALSE 78861
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
78815: LD_ADDR_EXP 103
78819: PUSH
78820: LD_EXP 103
78824: PPUSH
78825: LD_VAR 0 1
78829: PUSH
78830: LD_EXP 103
78834: PUSH
78835: LD_VAR 0 1
78839: ARRAY
78840: PUSH
78841: LD_INT 1
78843: PLUS
78844: PUSH
78845: EMPTY
78846: LIST
78847: LIST
78848: PPUSH
78849: LD_VAR 0 4
78853: PPUSH
78854: CALL 18588 0 3
78858: ST_TO_ADDR
78859: GO 78812
78861: POP
78862: POP
// end ;
78863: LD_VAR 0 3
78867: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
78868: LD_INT 0
78870: PPUSH
// if not mc_bases or not base or not areas then
78871: LD_EXP 69
78875: NOT
78876: PUSH
78877: LD_VAR 0 1
78881: NOT
78882: OR
78883: PUSH
78884: LD_VAR 0 2
78888: NOT
78889: OR
78890: IFFALSE 78894
// exit ;
78892: GO 78919
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
78894: LD_ADDR_EXP 87
78898: PUSH
78899: LD_EXP 87
78903: PPUSH
78904: LD_VAR 0 1
78908: PPUSH
78909: LD_VAR 0 2
78913: PPUSH
78914: CALL_OW 1
78918: ST_TO_ADDR
// end ;
78919: LD_VAR 0 3
78923: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
78924: LD_INT 0
78926: PPUSH
// if not mc_bases or not base or not teleports_exit then
78927: LD_EXP 69
78931: NOT
78932: PUSH
78933: LD_VAR 0 1
78937: NOT
78938: OR
78939: PUSH
78940: LD_VAR 0 2
78944: NOT
78945: OR
78946: IFFALSE 78950
// exit ;
78948: GO 78975
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
78950: LD_ADDR_EXP 104
78954: PUSH
78955: LD_EXP 104
78959: PPUSH
78960: LD_VAR 0 1
78964: PPUSH
78965: LD_VAR 0 2
78969: PPUSH
78970: CALL_OW 1
78974: ST_TO_ADDR
// end ;
78975: LD_VAR 0 3
78979: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
78980: LD_INT 0
78982: PPUSH
78983: PPUSH
78984: PPUSH
// if not mc_bases or not base or not ext_list then
78985: LD_EXP 69
78989: NOT
78990: PUSH
78991: LD_VAR 0 1
78995: NOT
78996: OR
78997: PUSH
78998: LD_VAR 0 5
79002: NOT
79003: OR
79004: IFFALSE 79008
// exit ;
79006: GO 79181
// tmp := GetFacExtXYD ( x , y , d ) ;
79008: LD_ADDR_VAR 0 8
79012: PUSH
79013: LD_VAR 0 2
79017: PPUSH
79018: LD_VAR 0 3
79022: PPUSH
79023: LD_VAR 0 4
79027: PPUSH
79028: CALL 47975 0 3
79032: ST_TO_ADDR
// if not tmp then
79033: LD_VAR 0 8
79037: NOT
79038: IFFALSE 79042
// exit ;
79040: GO 79181
// for i in tmp do
79042: LD_ADDR_VAR 0 7
79046: PUSH
79047: LD_VAR 0 8
79051: PUSH
79052: FOR_IN
79053: IFFALSE 79179
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
79055: LD_ADDR_EXP 74
79059: PUSH
79060: LD_EXP 74
79064: PPUSH
79065: LD_VAR 0 1
79069: PPUSH
79070: LD_EXP 74
79074: PUSH
79075: LD_VAR 0 1
79079: ARRAY
79080: PPUSH
79081: LD_EXP 74
79085: PUSH
79086: LD_VAR 0 1
79090: ARRAY
79091: PUSH
79092: LD_INT 1
79094: PLUS
79095: PPUSH
79096: LD_VAR 0 5
79100: PUSH
79101: LD_INT 1
79103: ARRAY
79104: PUSH
79105: LD_VAR 0 7
79109: PUSH
79110: LD_INT 1
79112: ARRAY
79113: PUSH
79114: LD_VAR 0 7
79118: PUSH
79119: LD_INT 2
79121: ARRAY
79122: PUSH
79123: LD_VAR 0 7
79127: PUSH
79128: LD_INT 3
79130: ARRAY
79131: PUSH
79132: EMPTY
79133: LIST
79134: LIST
79135: LIST
79136: LIST
79137: PPUSH
79138: CALL_OW 2
79142: PPUSH
79143: CALL_OW 1
79147: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
79148: LD_ADDR_VAR 0 5
79152: PUSH
79153: LD_VAR 0 5
79157: PPUSH
79158: LD_INT 1
79160: PPUSH
79161: CALL_OW 3
79165: ST_TO_ADDR
// if not ext_list then
79166: LD_VAR 0 5
79170: NOT
79171: IFFALSE 79177
// exit ;
79173: POP
79174: POP
79175: GO 79181
// end ;
79177: GO 79052
79179: POP
79180: POP
// end ;
79181: LD_VAR 0 6
79185: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
79186: LD_INT 0
79188: PPUSH
// if not mc_bases or not base or not weapon_list then
79189: LD_EXP 69
79193: NOT
79194: PUSH
79195: LD_VAR 0 1
79199: NOT
79200: OR
79201: PUSH
79202: LD_VAR 0 2
79206: NOT
79207: OR
79208: IFFALSE 79212
// exit ;
79210: GO 79237
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
79212: LD_ADDR_EXP 108
79216: PUSH
79217: LD_EXP 108
79221: PPUSH
79222: LD_VAR 0 1
79226: PPUSH
79227: LD_VAR 0 2
79231: PPUSH
79232: CALL_OW 1
79236: ST_TO_ADDR
// end ;
79237: LD_VAR 0 3
79241: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
79242: LD_INT 0
79244: PPUSH
// if not mc_bases or not base or not tech_list then
79245: LD_EXP 69
79249: NOT
79250: PUSH
79251: LD_VAR 0 1
79255: NOT
79256: OR
79257: PUSH
79258: LD_VAR 0 2
79262: NOT
79263: OR
79264: IFFALSE 79268
// exit ;
79266: GO 79293
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
79268: LD_ADDR_EXP 96
79272: PUSH
79273: LD_EXP 96
79277: PPUSH
79278: LD_VAR 0 1
79282: PPUSH
79283: LD_VAR 0 2
79287: PPUSH
79288: CALL_OW 1
79292: ST_TO_ADDR
// end ;
79293: LD_VAR 0 3
79297: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
79298: LD_INT 0
79300: PPUSH
// if not mc_bases or not parking_area or not base then
79301: LD_EXP 69
79305: NOT
79306: PUSH
79307: LD_VAR 0 2
79311: NOT
79312: OR
79313: PUSH
79314: LD_VAR 0 1
79318: NOT
79319: OR
79320: IFFALSE 79324
// exit ;
79322: GO 79349
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
79324: LD_ADDR_EXP 93
79328: PUSH
79329: LD_EXP 93
79333: PPUSH
79334: LD_VAR 0 1
79338: PPUSH
79339: LD_VAR 0 2
79343: PPUSH
79344: CALL_OW 1
79348: ST_TO_ADDR
// end ;
79349: LD_VAR 0 3
79353: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
79354: LD_INT 0
79356: PPUSH
// if not mc_bases or not base or not scan_area then
79357: LD_EXP 69
79361: NOT
79362: PUSH
79363: LD_VAR 0 1
79367: NOT
79368: OR
79369: PUSH
79370: LD_VAR 0 2
79374: NOT
79375: OR
79376: IFFALSE 79380
// exit ;
79378: GO 79405
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
79380: LD_ADDR_EXP 94
79384: PUSH
79385: LD_EXP 94
79389: PPUSH
79390: LD_VAR 0 1
79394: PPUSH
79395: LD_VAR 0 2
79399: PPUSH
79400: CALL_OW 1
79404: ST_TO_ADDR
// end ;
79405: LD_VAR 0 3
79409: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
79410: LD_INT 0
79412: PPUSH
79413: PPUSH
// if not mc_bases or not base then
79414: LD_EXP 69
79418: NOT
79419: PUSH
79420: LD_VAR 0 1
79424: NOT
79425: OR
79426: IFFALSE 79430
// exit ;
79428: GO 79494
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
79430: LD_ADDR_VAR 0 3
79434: PUSH
79435: LD_INT 1
79437: PUSH
79438: LD_INT 2
79440: PUSH
79441: LD_INT 3
79443: PUSH
79444: LD_INT 4
79446: PUSH
79447: LD_INT 11
79449: PUSH
79450: EMPTY
79451: LIST
79452: LIST
79453: LIST
79454: LIST
79455: LIST
79456: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
79457: LD_ADDR_EXP 96
79461: PUSH
79462: LD_EXP 96
79466: PPUSH
79467: LD_VAR 0 1
79471: PPUSH
79472: LD_EXP 96
79476: PUSH
79477: LD_VAR 0 1
79481: ARRAY
79482: PUSH
79483: LD_VAR 0 3
79487: DIFF
79488: PPUSH
79489: CALL_OW 1
79493: ST_TO_ADDR
// end ;
79494: LD_VAR 0 2
79498: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
79499: LD_INT 0
79501: PPUSH
// result := mc_vehicles [ base ] ;
79502: LD_ADDR_VAR 0 3
79506: PUSH
79507: LD_EXP 88
79511: PUSH
79512: LD_VAR 0 1
79516: ARRAY
79517: ST_TO_ADDR
// if onlyCombat then
79518: LD_VAR 0 2
79522: IFFALSE 79700
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
79524: LD_ADDR_VAR 0 3
79528: PUSH
79529: LD_VAR 0 3
79533: PUSH
79534: LD_VAR 0 3
79538: PPUSH
79539: LD_INT 2
79541: PUSH
79542: LD_INT 34
79544: PUSH
79545: LD_INT 12
79547: PUSH
79548: EMPTY
79549: LIST
79550: LIST
79551: PUSH
79552: LD_INT 34
79554: PUSH
79555: LD_INT 51
79557: PUSH
79558: EMPTY
79559: LIST
79560: LIST
79561: PUSH
79562: LD_INT 34
79564: PUSH
79565: LD_EXP 49
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: LD_INT 34
79576: PUSH
79577: LD_INT 32
79579: PUSH
79580: EMPTY
79581: LIST
79582: LIST
79583: PUSH
79584: LD_INT 34
79586: PUSH
79587: LD_INT 13
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PUSH
79594: LD_INT 34
79596: PUSH
79597: LD_INT 52
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: PUSH
79604: LD_INT 34
79606: PUSH
79607: LD_EXP 54
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 34
79618: PUSH
79619: LD_INT 14
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: PUSH
79626: LD_INT 34
79628: PUSH
79629: LD_INT 53
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: PUSH
79636: LD_INT 34
79638: PUSH
79639: LD_EXP 48
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 34
79650: PUSH
79651: LD_INT 31
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 34
79660: PUSH
79661: LD_INT 48
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: PUSH
79668: LD_INT 34
79670: PUSH
79671: LD_INT 8
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: PUSH
79678: EMPTY
79679: LIST
79680: LIST
79681: LIST
79682: LIST
79683: LIST
79684: LIST
79685: LIST
79686: LIST
79687: LIST
79688: LIST
79689: LIST
79690: LIST
79691: LIST
79692: LIST
79693: PPUSH
79694: CALL_OW 72
79698: DIFF
79699: ST_TO_ADDR
// end ; end_of_file
79700: LD_VAR 0 3
79704: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
79705: LD_INT 0
79707: PPUSH
79708: PPUSH
79709: PPUSH
// if not mc_bases or not skirmish then
79710: LD_EXP 69
79714: NOT
79715: PUSH
79716: LD_EXP 67
79720: NOT
79721: OR
79722: IFFALSE 79726
// exit ;
79724: GO 79891
// for i = 1 to mc_bases do
79726: LD_ADDR_VAR 0 4
79730: PUSH
79731: DOUBLE
79732: LD_INT 1
79734: DEC
79735: ST_TO_ADDR
79736: LD_EXP 69
79740: PUSH
79741: FOR_TO
79742: IFFALSE 79889
// begin if sci in mc_bases [ i ] then
79744: LD_VAR 0 2
79748: PUSH
79749: LD_EXP 69
79753: PUSH
79754: LD_VAR 0 4
79758: ARRAY
79759: IN
79760: IFFALSE 79887
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
79762: LD_ADDR_EXP 98
79766: PUSH
79767: LD_EXP 98
79771: PPUSH
79772: LD_VAR 0 4
79776: PUSH
79777: LD_EXP 98
79781: PUSH
79782: LD_VAR 0 4
79786: ARRAY
79787: PUSH
79788: LD_INT 1
79790: PLUS
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: PPUSH
79796: LD_VAR 0 1
79800: PPUSH
79801: CALL 18588 0 3
79805: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
79806: LD_ADDR_VAR 0 5
79810: PUSH
79811: LD_EXP 69
79815: PUSH
79816: LD_VAR 0 4
79820: ARRAY
79821: PPUSH
79822: LD_INT 2
79824: PUSH
79825: LD_INT 30
79827: PUSH
79828: LD_INT 0
79830: PUSH
79831: EMPTY
79832: LIST
79833: LIST
79834: PUSH
79835: LD_INT 30
79837: PUSH
79838: LD_INT 1
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: LIST
79849: PPUSH
79850: CALL_OW 72
79854: PPUSH
79855: LD_VAR 0 1
79859: PPUSH
79860: CALL_OW 74
79864: ST_TO_ADDR
// if tmp then
79865: LD_VAR 0 5
79869: IFFALSE 79885
// ComStandNearbyBuilding ( ape , tmp ) ;
79871: LD_VAR 0 1
79875: PPUSH
79876: LD_VAR 0 5
79880: PPUSH
79881: CALL 15166 0 2
// break ;
79885: GO 79889
// end ; end ;
79887: GO 79741
79889: POP
79890: POP
// end ;
79891: LD_VAR 0 3
79895: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
79896: LD_INT 0
79898: PPUSH
79899: PPUSH
79900: PPUSH
// if not mc_bases or not skirmish then
79901: LD_EXP 69
79905: NOT
79906: PUSH
79907: LD_EXP 67
79911: NOT
79912: OR
79913: IFFALSE 79917
// exit ;
79915: GO 80006
// for i = 1 to mc_bases do
79917: LD_ADDR_VAR 0 4
79921: PUSH
79922: DOUBLE
79923: LD_INT 1
79925: DEC
79926: ST_TO_ADDR
79927: LD_EXP 69
79931: PUSH
79932: FOR_TO
79933: IFFALSE 80004
// begin if building in mc_busy_turret_list [ i ] then
79935: LD_VAR 0 1
79939: PUSH
79940: LD_EXP 79
79944: PUSH
79945: LD_VAR 0 4
79949: ARRAY
79950: IN
79951: IFFALSE 80002
// begin tmp := mc_busy_turret_list [ i ] diff building ;
79953: LD_ADDR_VAR 0 5
79957: PUSH
79958: LD_EXP 79
79962: PUSH
79963: LD_VAR 0 4
79967: ARRAY
79968: PUSH
79969: LD_VAR 0 1
79973: DIFF
79974: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
79975: LD_ADDR_EXP 79
79979: PUSH
79980: LD_EXP 79
79984: PPUSH
79985: LD_VAR 0 4
79989: PPUSH
79990: LD_VAR 0 5
79994: PPUSH
79995: CALL_OW 1
79999: ST_TO_ADDR
// break ;
80000: GO 80004
// end ; end ;
80002: GO 79932
80004: POP
80005: POP
// end ;
80006: LD_VAR 0 3
80010: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
80011: LD_INT 0
80013: PPUSH
80014: PPUSH
80015: PPUSH
// if not mc_bases or not skirmish then
80016: LD_EXP 69
80020: NOT
80021: PUSH
80022: LD_EXP 67
80026: NOT
80027: OR
80028: IFFALSE 80032
// exit ;
80030: GO 80231
// for i = 1 to mc_bases do
80032: LD_ADDR_VAR 0 5
80036: PUSH
80037: DOUBLE
80038: LD_INT 1
80040: DEC
80041: ST_TO_ADDR
80042: LD_EXP 69
80046: PUSH
80047: FOR_TO
80048: IFFALSE 80229
// if building in mc_bases [ i ] then
80050: LD_VAR 0 1
80054: PUSH
80055: LD_EXP 69
80059: PUSH
80060: LD_VAR 0 5
80064: ARRAY
80065: IN
80066: IFFALSE 80227
// begin tmp := mc_bases [ i ] diff building ;
80068: LD_ADDR_VAR 0 6
80072: PUSH
80073: LD_EXP 69
80077: PUSH
80078: LD_VAR 0 5
80082: ARRAY
80083: PUSH
80084: LD_VAR 0 1
80088: DIFF
80089: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
80090: LD_ADDR_EXP 69
80094: PUSH
80095: LD_EXP 69
80099: PPUSH
80100: LD_VAR 0 5
80104: PPUSH
80105: LD_VAR 0 6
80109: PPUSH
80110: CALL_OW 1
80114: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
80115: LD_VAR 0 1
80119: PUSH
80120: LD_EXP 77
80124: PUSH
80125: LD_VAR 0 5
80129: ARRAY
80130: IN
80131: IFFALSE 80170
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
80133: LD_ADDR_EXP 77
80137: PUSH
80138: LD_EXP 77
80142: PPUSH
80143: LD_VAR 0 5
80147: PPUSH
80148: LD_EXP 77
80152: PUSH
80153: LD_VAR 0 5
80157: ARRAY
80158: PUSH
80159: LD_VAR 0 1
80163: DIFF
80164: PPUSH
80165: CALL_OW 1
80169: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
80170: LD_VAR 0 1
80174: PUSH
80175: LD_EXP 78
80179: PUSH
80180: LD_VAR 0 5
80184: ARRAY
80185: IN
80186: IFFALSE 80225
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
80188: LD_ADDR_EXP 78
80192: PUSH
80193: LD_EXP 78
80197: PPUSH
80198: LD_VAR 0 5
80202: PPUSH
80203: LD_EXP 78
80207: PUSH
80208: LD_VAR 0 5
80212: ARRAY
80213: PUSH
80214: LD_VAR 0 1
80218: DIFF
80219: PPUSH
80220: CALL_OW 1
80224: ST_TO_ADDR
// break ;
80225: GO 80229
// end ;
80227: GO 80047
80229: POP
80230: POP
// end ;
80231: LD_VAR 0 4
80235: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
80236: LD_INT 0
80238: PPUSH
80239: PPUSH
80240: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
80241: LD_EXP 69
80245: NOT
80246: PUSH
80247: LD_EXP 67
80251: NOT
80252: OR
80253: PUSH
80254: LD_VAR 0 3
80258: PUSH
80259: LD_EXP 95
80263: IN
80264: NOT
80265: OR
80266: IFFALSE 80270
// exit ;
80268: GO 80393
// for i = 1 to mc_vehicles do
80270: LD_ADDR_VAR 0 6
80274: PUSH
80275: DOUBLE
80276: LD_INT 1
80278: DEC
80279: ST_TO_ADDR
80280: LD_EXP 88
80284: PUSH
80285: FOR_TO
80286: IFFALSE 80391
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
80288: LD_VAR 0 2
80292: PUSH
80293: LD_EXP 88
80297: PUSH
80298: LD_VAR 0 6
80302: ARRAY
80303: IN
80304: PUSH
80305: LD_VAR 0 1
80309: PUSH
80310: LD_EXP 88
80314: PUSH
80315: LD_VAR 0 6
80319: ARRAY
80320: IN
80321: OR
80322: IFFALSE 80389
// begin tmp := mc_vehicles [ i ] diff old ;
80324: LD_ADDR_VAR 0 7
80328: PUSH
80329: LD_EXP 88
80333: PUSH
80334: LD_VAR 0 6
80338: ARRAY
80339: PUSH
80340: LD_VAR 0 2
80344: DIFF
80345: ST_TO_ADDR
// tmp := tmp diff new ;
80346: LD_ADDR_VAR 0 7
80350: PUSH
80351: LD_VAR 0 7
80355: PUSH
80356: LD_VAR 0 1
80360: DIFF
80361: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
80362: LD_ADDR_EXP 88
80366: PUSH
80367: LD_EXP 88
80371: PPUSH
80372: LD_VAR 0 6
80376: PPUSH
80377: LD_VAR 0 7
80381: PPUSH
80382: CALL_OW 1
80386: ST_TO_ADDR
// break ;
80387: GO 80391
// end ;
80389: GO 80285
80391: POP
80392: POP
// end ;
80393: LD_VAR 0 5
80397: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
80398: LD_INT 0
80400: PPUSH
80401: PPUSH
80402: PPUSH
80403: PPUSH
// if not mc_bases or not skirmish then
80404: LD_EXP 69
80408: NOT
80409: PUSH
80410: LD_EXP 67
80414: NOT
80415: OR
80416: IFFALSE 80420
// exit ;
80418: GO 80812
// side := GetSide ( vehicle ) ;
80420: LD_ADDR_VAR 0 5
80424: PUSH
80425: LD_VAR 0 1
80429: PPUSH
80430: CALL_OW 255
80434: ST_TO_ADDR
// for i = 1 to mc_bases do
80435: LD_ADDR_VAR 0 4
80439: PUSH
80440: DOUBLE
80441: LD_INT 1
80443: DEC
80444: ST_TO_ADDR
80445: LD_EXP 69
80449: PUSH
80450: FOR_TO
80451: IFFALSE 80810
// begin if factory in mc_bases [ i ] then
80453: LD_VAR 0 2
80457: PUSH
80458: LD_EXP 69
80462: PUSH
80463: LD_VAR 0 4
80467: ARRAY
80468: IN
80469: IFFALSE 80808
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
80471: LD_EXP 91
80475: PUSH
80476: LD_VAR 0 4
80480: ARRAY
80481: PUSH
80482: LD_EXP 80
80486: PUSH
80487: LD_VAR 0 4
80491: ARRAY
80492: LESS
80493: PUSH
80494: LD_VAR 0 1
80498: PPUSH
80499: CALL_OW 264
80503: PUSH
80504: LD_INT 31
80506: PUSH
80507: LD_INT 32
80509: PUSH
80510: LD_INT 51
80512: PUSH
80513: LD_EXP 49
80517: PUSH
80518: LD_INT 12
80520: PUSH
80521: LD_INT 30
80523: PUSH
80524: LD_EXP 48
80528: PUSH
80529: LD_INT 11
80531: PUSH
80532: LD_INT 53
80534: PUSH
80535: LD_INT 14
80537: PUSH
80538: LD_EXP 52
80542: PUSH
80543: LD_INT 29
80545: PUSH
80546: LD_EXP 50
80550: PUSH
80551: LD_INT 13
80553: PUSH
80554: LD_INT 52
80556: PUSH
80557: LD_EXP 54
80561: PUSH
80562: LD_INT 48
80564: PUSH
80565: LD_INT 8
80567: PUSH
80568: EMPTY
80569: LIST
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: LIST
80576: LIST
80577: LIST
80578: LIST
80579: LIST
80580: LIST
80581: LIST
80582: LIST
80583: LIST
80584: LIST
80585: LIST
80586: LIST
80587: IN
80588: NOT
80589: AND
80590: IFFALSE 80638
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
80592: LD_ADDR_EXP 91
80596: PUSH
80597: LD_EXP 91
80601: PPUSH
80602: LD_VAR 0 4
80606: PUSH
80607: LD_EXP 91
80611: PUSH
80612: LD_VAR 0 4
80616: ARRAY
80617: PUSH
80618: LD_INT 1
80620: PLUS
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: PPUSH
80626: LD_VAR 0 1
80630: PPUSH
80631: CALL 18588 0 3
80635: ST_TO_ADDR
80636: GO 80682
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
80638: LD_ADDR_EXP 88
80642: PUSH
80643: LD_EXP 88
80647: PPUSH
80648: LD_VAR 0 4
80652: PUSH
80653: LD_EXP 88
80657: PUSH
80658: LD_VAR 0 4
80662: ARRAY
80663: PUSH
80664: LD_INT 1
80666: PLUS
80667: PUSH
80668: EMPTY
80669: LIST
80670: LIST
80671: PPUSH
80672: LD_VAR 0 1
80676: PPUSH
80677: CALL 18588 0 3
80681: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
80682: LD_VAR 0 1
80686: PPUSH
80687: CALL_OW 263
80691: PUSH
80692: LD_INT 2
80694: EQUAL
80695: IFFALSE 80724
// begin repeat wait ( 0 0$3 ) ;
80697: LD_INT 105
80699: PPUSH
80700: CALL_OW 67
// Connect ( vehicle ) ;
80704: LD_VAR 0 1
80708: PPUSH
80709: CALL 21559 0 1
// until IsControledBy ( vehicle ) ;
80713: LD_VAR 0 1
80717: PPUSH
80718: CALL_OW 312
80722: IFFALSE 80697
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
80724: LD_VAR 0 1
80728: PPUSH
80729: LD_EXP 93
80733: PUSH
80734: LD_VAR 0 4
80738: ARRAY
80739: PPUSH
80740: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
80744: LD_VAR 0 1
80748: PPUSH
80749: CALL_OW 263
80753: PUSH
80754: LD_INT 1
80756: NONEQUAL
80757: IFFALSE 80761
// break ;
80759: GO 80810
// repeat wait ( 0 0$1 ) ;
80761: LD_INT 35
80763: PPUSH
80764: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
80768: LD_VAR 0 1
80772: PPUSH
80773: LD_EXP 93
80777: PUSH
80778: LD_VAR 0 4
80782: ARRAY
80783: PPUSH
80784: CALL_OW 308
80788: IFFALSE 80761
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
80790: LD_VAR 0 1
80794: PPUSH
80795: CALL_OW 311
80799: PPUSH
80800: CALL_OW 121
// exit ;
80804: POP
80805: POP
80806: GO 80812
// end ; end ;
80808: GO 80450
80810: POP
80811: POP
// end ;
80812: LD_VAR 0 3
80816: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
80817: LD_INT 0
80819: PPUSH
80820: PPUSH
80821: PPUSH
80822: PPUSH
// if not mc_bases or not skirmish then
80823: LD_EXP 69
80827: NOT
80828: PUSH
80829: LD_EXP 67
80833: NOT
80834: OR
80835: IFFALSE 80839
// exit ;
80837: GO 81192
// repeat wait ( 0 0$1 ) ;
80839: LD_INT 35
80841: PPUSH
80842: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
80846: LD_VAR 0 2
80850: PPUSH
80851: LD_VAR 0 3
80855: PPUSH
80856: CALL_OW 284
80860: IFFALSE 80839
// if GetResourceTypeXY ( x , y ) = mat_artefact then
80862: LD_VAR 0 2
80866: PPUSH
80867: LD_VAR 0 3
80871: PPUSH
80872: CALL_OW 283
80876: PUSH
80877: LD_INT 4
80879: EQUAL
80880: IFFALSE 80884
// exit ;
80882: GO 81192
// for i = 1 to mc_bases do
80884: LD_ADDR_VAR 0 7
80888: PUSH
80889: DOUBLE
80890: LD_INT 1
80892: DEC
80893: ST_TO_ADDR
80894: LD_EXP 69
80898: PUSH
80899: FOR_TO
80900: IFFALSE 81190
// begin if mc_crates_area [ i ] then
80902: LD_EXP 87
80906: PUSH
80907: LD_VAR 0 7
80911: ARRAY
80912: IFFALSE 81023
// for j in mc_crates_area [ i ] do
80914: LD_ADDR_VAR 0 8
80918: PUSH
80919: LD_EXP 87
80923: PUSH
80924: LD_VAR 0 7
80928: ARRAY
80929: PUSH
80930: FOR_IN
80931: IFFALSE 81021
// if InArea ( x , y , j ) then
80933: LD_VAR 0 2
80937: PPUSH
80938: LD_VAR 0 3
80942: PPUSH
80943: LD_VAR 0 8
80947: PPUSH
80948: CALL_OW 309
80952: IFFALSE 81019
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80954: LD_ADDR_EXP 85
80958: PUSH
80959: LD_EXP 85
80963: PPUSH
80964: LD_VAR 0 7
80968: PUSH
80969: LD_EXP 85
80973: PUSH
80974: LD_VAR 0 7
80978: ARRAY
80979: PUSH
80980: LD_INT 1
80982: PLUS
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PPUSH
80988: LD_VAR 0 4
80992: PUSH
80993: LD_VAR 0 2
80997: PUSH
80998: LD_VAR 0 3
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: LIST
81007: PPUSH
81008: CALL 18588 0 3
81012: ST_TO_ADDR
// exit ;
81013: POP
81014: POP
81015: POP
81016: POP
81017: GO 81192
// end ;
81019: GO 80930
81021: POP
81022: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81023: LD_ADDR_VAR 0 9
81027: PUSH
81028: LD_EXP 69
81032: PUSH
81033: LD_VAR 0 7
81037: ARRAY
81038: PPUSH
81039: LD_INT 2
81041: PUSH
81042: LD_INT 30
81044: PUSH
81045: LD_INT 0
81047: PUSH
81048: EMPTY
81049: LIST
81050: LIST
81051: PUSH
81052: LD_INT 30
81054: PUSH
81055: LD_INT 1
81057: PUSH
81058: EMPTY
81059: LIST
81060: LIST
81061: PUSH
81062: EMPTY
81063: LIST
81064: LIST
81065: LIST
81066: PPUSH
81067: CALL_OW 72
81071: ST_TO_ADDR
// if not depot then
81072: LD_VAR 0 9
81076: NOT
81077: IFFALSE 81081
// continue ;
81079: GO 80899
// for j in depot do
81081: LD_ADDR_VAR 0 8
81085: PUSH
81086: LD_VAR 0 9
81090: PUSH
81091: FOR_IN
81092: IFFALSE 81186
// if GetDistUnitXY ( j , x , y ) < 30 then
81094: LD_VAR 0 8
81098: PPUSH
81099: LD_VAR 0 2
81103: PPUSH
81104: LD_VAR 0 3
81108: PPUSH
81109: CALL_OW 297
81113: PUSH
81114: LD_INT 30
81116: LESS
81117: IFFALSE 81184
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81119: LD_ADDR_EXP 85
81123: PUSH
81124: LD_EXP 85
81128: PPUSH
81129: LD_VAR 0 7
81133: PUSH
81134: LD_EXP 85
81138: PUSH
81139: LD_VAR 0 7
81143: ARRAY
81144: PUSH
81145: LD_INT 1
81147: PLUS
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PPUSH
81153: LD_VAR 0 4
81157: PUSH
81158: LD_VAR 0 2
81162: PUSH
81163: LD_VAR 0 3
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: LIST
81172: PPUSH
81173: CALL 18588 0 3
81177: ST_TO_ADDR
// exit ;
81178: POP
81179: POP
81180: POP
81181: POP
81182: GO 81192
// end ;
81184: GO 81091
81186: POP
81187: POP
// end ;
81188: GO 80899
81190: POP
81191: POP
// end ;
81192: LD_VAR 0 6
81196: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
81197: LD_INT 0
81199: PPUSH
81200: PPUSH
81201: PPUSH
81202: PPUSH
// if not mc_bases or not skirmish then
81203: LD_EXP 69
81207: NOT
81208: PUSH
81209: LD_EXP 67
81213: NOT
81214: OR
81215: IFFALSE 81219
// exit ;
81217: GO 81496
// side := GetSide ( lab ) ;
81219: LD_ADDR_VAR 0 4
81223: PUSH
81224: LD_VAR 0 2
81228: PPUSH
81229: CALL_OW 255
81233: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
81234: LD_VAR 0 4
81238: PUSH
81239: LD_EXP 95
81243: IN
81244: NOT
81245: PUSH
81246: LD_EXP 96
81250: NOT
81251: OR
81252: PUSH
81253: LD_EXP 69
81257: NOT
81258: OR
81259: IFFALSE 81263
// exit ;
81261: GO 81496
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
81263: LD_ADDR_EXP 96
81267: PUSH
81268: LD_EXP 96
81272: PPUSH
81273: LD_VAR 0 4
81277: PPUSH
81278: LD_EXP 96
81282: PUSH
81283: LD_VAR 0 4
81287: ARRAY
81288: PUSH
81289: LD_VAR 0 1
81293: DIFF
81294: PPUSH
81295: CALL_OW 1
81299: ST_TO_ADDR
// for i = 1 to mc_bases do
81300: LD_ADDR_VAR 0 5
81304: PUSH
81305: DOUBLE
81306: LD_INT 1
81308: DEC
81309: ST_TO_ADDR
81310: LD_EXP 69
81314: PUSH
81315: FOR_TO
81316: IFFALSE 81494
// begin if lab in mc_bases [ i ] then
81318: LD_VAR 0 2
81322: PUSH
81323: LD_EXP 69
81327: PUSH
81328: LD_VAR 0 5
81332: ARRAY
81333: IN
81334: IFFALSE 81492
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
81336: LD_VAR 0 1
81340: PUSH
81341: LD_INT 11
81343: PUSH
81344: LD_INT 4
81346: PUSH
81347: LD_INT 3
81349: PUSH
81350: LD_INT 2
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: LIST
81357: LIST
81358: IN
81359: PUSH
81360: LD_EXP 99
81364: PUSH
81365: LD_VAR 0 5
81369: ARRAY
81370: AND
81371: IFFALSE 81492
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
81373: LD_ADDR_VAR 0 6
81377: PUSH
81378: LD_EXP 99
81382: PUSH
81383: LD_VAR 0 5
81387: ARRAY
81388: PUSH
81389: LD_INT 1
81391: ARRAY
81392: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81393: LD_ADDR_EXP 99
81397: PUSH
81398: LD_EXP 99
81402: PPUSH
81403: LD_VAR 0 5
81407: PPUSH
81408: EMPTY
81409: PPUSH
81410: CALL_OW 1
81414: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
81415: LD_VAR 0 6
81419: PPUSH
81420: LD_INT 0
81422: PPUSH
81423: CALL_OW 109
// ComExitBuilding ( tmp ) ;
81427: LD_VAR 0 6
81431: PPUSH
81432: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
81436: LD_ADDR_EXP 98
81440: PUSH
81441: LD_EXP 98
81445: PPUSH
81446: LD_VAR 0 5
81450: PPUSH
81451: LD_EXP 98
81455: PUSH
81456: LD_VAR 0 5
81460: ARRAY
81461: PPUSH
81462: LD_INT 1
81464: PPUSH
81465: LD_VAR 0 6
81469: PPUSH
81470: CALL_OW 2
81474: PPUSH
81475: CALL_OW 1
81479: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
81480: LD_VAR 0 5
81484: PPUSH
81485: LD_INT 112
81487: PPUSH
81488: CALL 58015 0 2
// end ; end ; end ;
81492: GO 81315
81494: POP
81495: POP
// end ;
81496: LD_VAR 0 3
81500: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
81501: LD_INT 0
81503: PPUSH
81504: PPUSH
81505: PPUSH
81506: PPUSH
81507: PPUSH
81508: PPUSH
81509: PPUSH
81510: PPUSH
// if not mc_bases or not skirmish then
81511: LD_EXP 69
81515: NOT
81516: PUSH
81517: LD_EXP 67
81521: NOT
81522: OR
81523: IFFALSE 81527
// exit ;
81525: GO 82898
// for i = 1 to mc_bases do
81527: LD_ADDR_VAR 0 3
81531: PUSH
81532: DOUBLE
81533: LD_INT 1
81535: DEC
81536: ST_TO_ADDR
81537: LD_EXP 69
81541: PUSH
81542: FOR_TO
81543: IFFALSE 82896
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
81545: LD_VAR 0 1
81549: PUSH
81550: LD_EXP 69
81554: PUSH
81555: LD_VAR 0 3
81559: ARRAY
81560: IN
81561: PUSH
81562: LD_VAR 0 1
81566: PUSH
81567: LD_EXP 76
81571: PUSH
81572: LD_VAR 0 3
81576: ARRAY
81577: IN
81578: OR
81579: PUSH
81580: LD_VAR 0 1
81584: PUSH
81585: LD_EXP 91
81589: PUSH
81590: LD_VAR 0 3
81594: ARRAY
81595: IN
81596: OR
81597: PUSH
81598: LD_VAR 0 1
81602: PUSH
81603: LD_EXP 88
81607: PUSH
81608: LD_VAR 0 3
81612: ARRAY
81613: IN
81614: OR
81615: PUSH
81616: LD_VAR 0 1
81620: PUSH
81621: LD_EXP 98
81625: PUSH
81626: LD_VAR 0 3
81630: ARRAY
81631: IN
81632: OR
81633: PUSH
81634: LD_VAR 0 1
81638: PUSH
81639: LD_EXP 99
81643: PUSH
81644: LD_VAR 0 3
81648: ARRAY
81649: IN
81650: OR
81651: IFFALSE 82894
// begin if un in mc_ape [ i ] then
81653: LD_VAR 0 1
81657: PUSH
81658: LD_EXP 98
81662: PUSH
81663: LD_VAR 0 3
81667: ARRAY
81668: IN
81669: IFFALSE 81708
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
81671: LD_ADDR_EXP 98
81675: PUSH
81676: LD_EXP 98
81680: PPUSH
81681: LD_VAR 0 3
81685: PPUSH
81686: LD_EXP 98
81690: PUSH
81691: LD_VAR 0 3
81695: ARRAY
81696: PUSH
81697: LD_VAR 0 1
81701: DIFF
81702: PPUSH
81703: CALL_OW 1
81707: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
81708: LD_VAR 0 1
81712: PUSH
81713: LD_EXP 99
81717: PUSH
81718: LD_VAR 0 3
81722: ARRAY
81723: IN
81724: IFFALSE 81748
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81726: LD_ADDR_EXP 99
81730: PUSH
81731: LD_EXP 99
81735: PPUSH
81736: LD_VAR 0 3
81740: PPUSH
81741: EMPTY
81742: PPUSH
81743: CALL_OW 1
81747: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
81748: LD_VAR 0 1
81752: PPUSH
81753: CALL_OW 247
81757: PUSH
81758: LD_INT 2
81760: EQUAL
81761: PUSH
81762: LD_VAR 0 1
81766: PPUSH
81767: CALL_OW 110
81771: PUSH
81772: LD_INT 20
81774: EQUAL
81775: PUSH
81776: LD_VAR 0 1
81780: PUSH
81781: LD_EXP 91
81785: PUSH
81786: LD_VAR 0 3
81790: ARRAY
81791: IN
81792: OR
81793: PUSH
81794: LD_VAR 0 1
81798: PPUSH
81799: CALL_OW 264
81803: PUSH
81804: LD_INT 12
81806: PUSH
81807: LD_INT 51
81809: PUSH
81810: LD_EXP 49
81814: PUSH
81815: LD_INT 32
81817: PUSH
81818: LD_INT 13
81820: PUSH
81821: LD_INT 52
81823: PUSH
81824: LD_INT 31
81826: PUSH
81827: EMPTY
81828: LIST
81829: LIST
81830: LIST
81831: LIST
81832: LIST
81833: LIST
81834: LIST
81835: IN
81836: OR
81837: AND
81838: IFFALSE 82146
// begin if un in mc_defender [ i ] then
81840: LD_VAR 0 1
81844: PUSH
81845: LD_EXP 91
81849: PUSH
81850: LD_VAR 0 3
81854: ARRAY
81855: IN
81856: IFFALSE 81895
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81858: LD_ADDR_EXP 91
81862: PUSH
81863: LD_EXP 91
81867: PPUSH
81868: LD_VAR 0 3
81872: PPUSH
81873: LD_EXP 91
81877: PUSH
81878: LD_VAR 0 3
81882: ARRAY
81883: PUSH
81884: LD_VAR 0 1
81888: DIFF
81889: PPUSH
81890: CALL_OW 1
81894: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
81895: LD_ADDR_VAR 0 8
81899: PUSH
81900: LD_VAR 0 3
81904: PPUSH
81905: LD_INT 3
81907: PPUSH
81908: CALL 78536 0 2
81912: ST_TO_ADDR
// if fac then
81913: LD_VAR 0 8
81917: IFFALSE 82146
// begin for j in fac do
81919: LD_ADDR_VAR 0 4
81923: PUSH
81924: LD_VAR 0 8
81928: PUSH
81929: FOR_IN
81930: IFFALSE 82144
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
81932: LD_ADDR_VAR 0 9
81936: PUSH
81937: LD_VAR 0 8
81941: PPUSH
81942: LD_VAR 0 1
81946: PPUSH
81947: CALL_OW 265
81951: PPUSH
81952: LD_VAR 0 1
81956: PPUSH
81957: CALL_OW 262
81961: PPUSH
81962: LD_VAR 0 1
81966: PPUSH
81967: CALL_OW 263
81971: PPUSH
81972: LD_VAR 0 1
81976: PPUSH
81977: CALL_OW 264
81981: PPUSH
81982: CALL 16084 0 5
81986: ST_TO_ADDR
// if components then
81987: LD_VAR 0 9
81991: IFFALSE 82142
// begin if GetWeapon ( un ) = ar_control_tower then
81993: LD_VAR 0 1
81997: PPUSH
81998: CALL_OW 264
82002: PUSH
82003: LD_INT 31
82005: EQUAL
82006: IFFALSE 82123
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
82008: LD_VAR 0 1
82012: PPUSH
82013: CALL_OW 311
82017: PPUSH
82018: LD_INT 0
82020: PPUSH
82021: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
82025: LD_ADDR_EXP 109
82029: PUSH
82030: LD_EXP 109
82034: PPUSH
82035: LD_VAR 0 3
82039: PPUSH
82040: LD_EXP 109
82044: PUSH
82045: LD_VAR 0 3
82049: ARRAY
82050: PUSH
82051: LD_VAR 0 1
82055: PPUSH
82056: CALL_OW 311
82060: DIFF
82061: PPUSH
82062: CALL_OW 1
82066: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
82067: LD_ADDR_VAR 0 7
82071: PUSH
82072: LD_EXP 90
82076: PUSH
82077: LD_VAR 0 3
82081: ARRAY
82082: PPUSH
82083: LD_INT 1
82085: PPUSH
82086: LD_VAR 0 9
82090: PPUSH
82091: CALL_OW 2
82095: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
82096: LD_ADDR_EXP 90
82100: PUSH
82101: LD_EXP 90
82105: PPUSH
82106: LD_VAR 0 3
82110: PPUSH
82111: LD_VAR 0 7
82115: PPUSH
82116: CALL_OW 1
82120: ST_TO_ADDR
// end else
82121: GO 82140
// MC_InsertProduceList ( i , [ components ] ) ;
82123: LD_VAR 0 3
82127: PPUSH
82128: LD_VAR 0 9
82132: PUSH
82133: EMPTY
82134: LIST
82135: PPUSH
82136: CALL 78081 0 2
// break ;
82140: GO 82144
// end ; end ;
82142: GO 81929
82144: POP
82145: POP
// end ; end ; if GetType ( un ) = unit_building then
82146: LD_VAR 0 1
82150: PPUSH
82151: CALL_OW 247
82155: PUSH
82156: LD_INT 3
82158: EQUAL
82159: IFFALSE 82562
// begin btype := GetBType ( un ) ;
82161: LD_ADDR_VAR 0 5
82165: PUSH
82166: LD_VAR 0 1
82170: PPUSH
82171: CALL_OW 266
82175: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
82176: LD_VAR 0 5
82180: PUSH
82181: LD_INT 29
82183: PUSH
82184: LD_INT 30
82186: PUSH
82187: EMPTY
82188: LIST
82189: LIST
82190: IN
82191: IFFALSE 82264
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
82193: LD_VAR 0 1
82197: PPUSH
82198: CALL_OW 250
82202: PPUSH
82203: LD_VAR 0 1
82207: PPUSH
82208: CALL_OW 251
82212: PPUSH
82213: LD_VAR 0 1
82217: PPUSH
82218: CALL_OW 255
82222: PPUSH
82223: CALL_OW 440
82227: NOT
82228: IFFALSE 82264
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
82230: LD_VAR 0 1
82234: PPUSH
82235: CALL_OW 250
82239: PPUSH
82240: LD_VAR 0 1
82244: PPUSH
82245: CALL_OW 251
82249: PPUSH
82250: LD_VAR 0 1
82254: PPUSH
82255: CALL_OW 255
82259: PPUSH
82260: CALL_OW 441
// end ; if btype = b_warehouse then
82264: LD_VAR 0 5
82268: PUSH
82269: LD_INT 1
82271: EQUAL
82272: IFFALSE 82290
// begin btype := b_depot ;
82274: LD_ADDR_VAR 0 5
82278: PUSH
82279: LD_INT 0
82281: ST_TO_ADDR
// pos := 1 ;
82282: LD_ADDR_VAR 0 6
82286: PUSH
82287: LD_INT 1
82289: ST_TO_ADDR
// end ; if btype = b_factory then
82290: LD_VAR 0 5
82294: PUSH
82295: LD_INT 3
82297: EQUAL
82298: IFFALSE 82316
// begin btype := b_workshop ;
82300: LD_ADDR_VAR 0 5
82304: PUSH
82305: LD_INT 2
82307: ST_TO_ADDR
// pos := 1 ;
82308: LD_ADDR_VAR 0 6
82312: PUSH
82313: LD_INT 1
82315: ST_TO_ADDR
// end ; if btype = b_barracks then
82316: LD_VAR 0 5
82320: PUSH
82321: LD_INT 5
82323: EQUAL
82324: IFFALSE 82334
// btype := b_armoury ;
82326: LD_ADDR_VAR 0 5
82330: PUSH
82331: LD_INT 4
82333: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
82334: LD_VAR 0 5
82338: PUSH
82339: LD_INT 7
82341: PUSH
82342: LD_INT 8
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: IN
82349: IFFALSE 82359
// btype := b_lab ;
82351: LD_ADDR_VAR 0 5
82355: PUSH
82356: LD_INT 6
82358: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
82359: LD_ADDR_EXP 74
82363: PUSH
82364: LD_EXP 74
82368: PPUSH
82369: LD_VAR 0 3
82373: PUSH
82374: LD_EXP 74
82378: PUSH
82379: LD_VAR 0 3
82383: ARRAY
82384: PUSH
82385: LD_INT 1
82387: PLUS
82388: PUSH
82389: EMPTY
82390: LIST
82391: LIST
82392: PPUSH
82393: LD_VAR 0 5
82397: PUSH
82398: LD_VAR 0 1
82402: PPUSH
82403: CALL_OW 250
82407: PUSH
82408: LD_VAR 0 1
82412: PPUSH
82413: CALL_OW 251
82417: PUSH
82418: LD_VAR 0 1
82422: PPUSH
82423: CALL_OW 254
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: LIST
82432: LIST
82433: PPUSH
82434: CALL 18588 0 3
82438: ST_TO_ADDR
// if pos = 1 then
82439: LD_VAR 0 6
82443: PUSH
82444: LD_INT 1
82446: EQUAL
82447: IFFALSE 82562
// begin tmp := mc_build_list [ i ] ;
82449: LD_ADDR_VAR 0 7
82453: PUSH
82454: LD_EXP 74
82458: PUSH
82459: LD_VAR 0 3
82463: ARRAY
82464: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82465: LD_VAR 0 7
82469: PPUSH
82470: LD_INT 2
82472: PUSH
82473: LD_INT 30
82475: PUSH
82476: LD_INT 0
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: PUSH
82483: LD_INT 30
82485: PUSH
82486: LD_INT 1
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: LIST
82497: PPUSH
82498: CALL_OW 72
82502: IFFALSE 82512
// pos := 2 ;
82504: LD_ADDR_VAR 0 6
82508: PUSH
82509: LD_INT 2
82511: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
82512: LD_ADDR_VAR 0 7
82516: PUSH
82517: LD_VAR 0 7
82521: PPUSH
82522: LD_VAR 0 6
82526: PPUSH
82527: LD_VAR 0 7
82531: PPUSH
82532: CALL 18914 0 3
82536: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
82537: LD_ADDR_EXP 74
82541: PUSH
82542: LD_EXP 74
82546: PPUSH
82547: LD_VAR 0 3
82551: PPUSH
82552: LD_VAR 0 7
82556: PPUSH
82557: CALL_OW 1
82561: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
82562: LD_VAR 0 1
82566: PUSH
82567: LD_EXP 69
82571: PUSH
82572: LD_VAR 0 3
82576: ARRAY
82577: IN
82578: IFFALSE 82617
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
82580: LD_ADDR_EXP 69
82584: PUSH
82585: LD_EXP 69
82589: PPUSH
82590: LD_VAR 0 3
82594: PPUSH
82595: LD_EXP 69
82599: PUSH
82600: LD_VAR 0 3
82604: ARRAY
82605: PUSH
82606: LD_VAR 0 1
82610: DIFF
82611: PPUSH
82612: CALL_OW 1
82616: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
82617: LD_VAR 0 1
82621: PUSH
82622: LD_EXP 76
82626: PUSH
82627: LD_VAR 0 3
82631: ARRAY
82632: IN
82633: IFFALSE 82672
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
82635: LD_ADDR_EXP 76
82639: PUSH
82640: LD_EXP 76
82644: PPUSH
82645: LD_VAR 0 3
82649: PPUSH
82650: LD_EXP 76
82654: PUSH
82655: LD_VAR 0 3
82659: ARRAY
82660: PUSH
82661: LD_VAR 0 1
82665: DIFF
82666: PPUSH
82667: CALL_OW 1
82671: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
82672: LD_VAR 0 1
82676: PUSH
82677: LD_EXP 88
82681: PUSH
82682: LD_VAR 0 3
82686: ARRAY
82687: IN
82688: IFFALSE 82727
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
82690: LD_ADDR_EXP 88
82694: PUSH
82695: LD_EXP 88
82699: PPUSH
82700: LD_VAR 0 3
82704: PPUSH
82705: LD_EXP 88
82709: PUSH
82710: LD_VAR 0 3
82714: ARRAY
82715: PUSH
82716: LD_VAR 0 1
82720: DIFF
82721: PPUSH
82722: CALL_OW 1
82726: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
82727: LD_VAR 0 1
82731: PUSH
82732: LD_EXP 91
82736: PUSH
82737: LD_VAR 0 3
82741: ARRAY
82742: IN
82743: IFFALSE 82782
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82745: LD_ADDR_EXP 91
82749: PUSH
82750: LD_EXP 91
82754: PPUSH
82755: LD_VAR 0 3
82759: PPUSH
82760: LD_EXP 91
82764: PUSH
82765: LD_VAR 0 3
82769: ARRAY
82770: PUSH
82771: LD_VAR 0 1
82775: DIFF
82776: PPUSH
82777: CALL_OW 1
82781: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
82782: LD_VAR 0 1
82786: PUSH
82787: LD_EXP 78
82791: PUSH
82792: LD_VAR 0 3
82796: ARRAY
82797: IN
82798: IFFALSE 82837
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
82800: LD_ADDR_EXP 78
82804: PUSH
82805: LD_EXP 78
82809: PPUSH
82810: LD_VAR 0 3
82814: PPUSH
82815: LD_EXP 78
82819: PUSH
82820: LD_VAR 0 3
82824: ARRAY
82825: PUSH
82826: LD_VAR 0 1
82830: DIFF
82831: PPUSH
82832: CALL_OW 1
82836: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
82837: LD_VAR 0 1
82841: PUSH
82842: LD_EXP 77
82846: PUSH
82847: LD_VAR 0 3
82851: ARRAY
82852: IN
82853: IFFALSE 82892
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
82855: LD_ADDR_EXP 77
82859: PUSH
82860: LD_EXP 77
82864: PPUSH
82865: LD_VAR 0 3
82869: PPUSH
82870: LD_EXP 77
82874: PUSH
82875: LD_VAR 0 3
82879: ARRAY
82880: PUSH
82881: LD_VAR 0 1
82885: DIFF
82886: PPUSH
82887: CALL_OW 1
82891: ST_TO_ADDR
// end ; break ;
82892: GO 82896
// end ;
82894: GO 81542
82896: POP
82897: POP
// end ;
82898: LD_VAR 0 2
82902: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
82903: LD_INT 0
82905: PPUSH
82906: PPUSH
82907: PPUSH
// if not mc_bases or not skirmish then
82908: LD_EXP 69
82912: NOT
82913: PUSH
82914: LD_EXP 67
82918: NOT
82919: OR
82920: IFFALSE 82924
// exit ;
82922: GO 83139
// for i = 1 to mc_bases do
82924: LD_ADDR_VAR 0 3
82928: PUSH
82929: DOUBLE
82930: LD_INT 1
82932: DEC
82933: ST_TO_ADDR
82934: LD_EXP 69
82938: PUSH
82939: FOR_TO
82940: IFFALSE 83137
// begin if building in mc_construct_list [ i ] then
82942: LD_VAR 0 1
82946: PUSH
82947: LD_EXP 76
82951: PUSH
82952: LD_VAR 0 3
82956: ARRAY
82957: IN
82958: IFFALSE 83135
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82960: LD_ADDR_EXP 76
82964: PUSH
82965: LD_EXP 76
82969: PPUSH
82970: LD_VAR 0 3
82974: PPUSH
82975: LD_EXP 76
82979: PUSH
82980: LD_VAR 0 3
82984: ARRAY
82985: PUSH
82986: LD_VAR 0 1
82990: DIFF
82991: PPUSH
82992: CALL_OW 1
82996: ST_TO_ADDR
// if building in mc_lab [ i ] then
82997: LD_VAR 0 1
83001: PUSH
83002: LD_EXP 102
83006: PUSH
83007: LD_VAR 0 3
83011: ARRAY
83012: IN
83013: IFFALSE 83068
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
83015: LD_ADDR_EXP 103
83019: PUSH
83020: LD_EXP 103
83024: PPUSH
83025: LD_VAR 0 3
83029: PPUSH
83030: LD_EXP 103
83034: PUSH
83035: LD_VAR 0 3
83039: ARRAY
83040: PPUSH
83041: LD_INT 1
83043: PPUSH
83044: LD_EXP 103
83048: PUSH
83049: LD_VAR 0 3
83053: ARRAY
83054: PPUSH
83055: LD_INT 0
83057: PPUSH
83058: CALL 18006 0 4
83062: PPUSH
83063: CALL_OW 1
83067: ST_TO_ADDR
// if not building in mc_bases [ i ] then
83068: LD_VAR 0 1
83072: PUSH
83073: LD_EXP 69
83077: PUSH
83078: LD_VAR 0 3
83082: ARRAY
83083: IN
83084: NOT
83085: IFFALSE 83131
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83087: LD_ADDR_EXP 69
83091: PUSH
83092: LD_EXP 69
83096: PPUSH
83097: LD_VAR 0 3
83101: PUSH
83102: LD_EXP 69
83106: PUSH
83107: LD_VAR 0 3
83111: ARRAY
83112: PUSH
83113: LD_INT 1
83115: PLUS
83116: PUSH
83117: EMPTY
83118: LIST
83119: LIST
83120: PPUSH
83121: LD_VAR 0 1
83125: PPUSH
83126: CALL 18588 0 3
83130: ST_TO_ADDR
// exit ;
83131: POP
83132: POP
83133: GO 83139
// end ; end ;
83135: GO 82939
83137: POP
83138: POP
// end ;
83139: LD_VAR 0 2
83143: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
83144: LD_INT 0
83146: PPUSH
83147: PPUSH
83148: PPUSH
83149: PPUSH
83150: PPUSH
83151: PPUSH
83152: PPUSH
// if not mc_bases or not skirmish then
83153: LD_EXP 69
83157: NOT
83158: PUSH
83159: LD_EXP 67
83163: NOT
83164: OR
83165: IFFALSE 83169
// exit ;
83167: GO 83830
// for i = 1 to mc_bases do
83169: LD_ADDR_VAR 0 3
83173: PUSH
83174: DOUBLE
83175: LD_INT 1
83177: DEC
83178: ST_TO_ADDR
83179: LD_EXP 69
83183: PUSH
83184: FOR_TO
83185: IFFALSE 83828
// begin if building in mc_construct_list [ i ] then
83187: LD_VAR 0 1
83191: PUSH
83192: LD_EXP 76
83196: PUSH
83197: LD_VAR 0 3
83201: ARRAY
83202: IN
83203: IFFALSE 83826
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83205: LD_ADDR_EXP 76
83209: PUSH
83210: LD_EXP 76
83214: PPUSH
83215: LD_VAR 0 3
83219: PPUSH
83220: LD_EXP 76
83224: PUSH
83225: LD_VAR 0 3
83229: ARRAY
83230: PUSH
83231: LD_VAR 0 1
83235: DIFF
83236: PPUSH
83237: CALL_OW 1
83241: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83242: LD_ADDR_EXP 69
83246: PUSH
83247: LD_EXP 69
83251: PPUSH
83252: LD_VAR 0 3
83256: PUSH
83257: LD_EXP 69
83261: PUSH
83262: LD_VAR 0 3
83266: ARRAY
83267: PUSH
83268: LD_INT 1
83270: PLUS
83271: PUSH
83272: EMPTY
83273: LIST
83274: LIST
83275: PPUSH
83276: LD_VAR 0 1
83280: PPUSH
83281: CALL 18588 0 3
83285: ST_TO_ADDR
// btype := GetBType ( building ) ;
83286: LD_ADDR_VAR 0 5
83290: PUSH
83291: LD_VAR 0 1
83295: PPUSH
83296: CALL_OW 266
83300: ST_TO_ADDR
// side := GetSide ( building ) ;
83301: LD_ADDR_VAR 0 8
83305: PUSH
83306: LD_VAR 0 1
83310: PPUSH
83311: CALL_OW 255
83315: ST_TO_ADDR
// if btype = b_lab then
83316: LD_VAR 0 5
83320: PUSH
83321: LD_INT 6
83323: EQUAL
83324: IFFALSE 83374
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
83326: LD_ADDR_EXP 102
83330: PUSH
83331: LD_EXP 102
83335: PPUSH
83336: LD_VAR 0 3
83340: PUSH
83341: LD_EXP 102
83345: PUSH
83346: LD_VAR 0 3
83350: ARRAY
83351: PUSH
83352: LD_INT 1
83354: PLUS
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: PPUSH
83360: LD_VAR 0 1
83364: PPUSH
83365: CALL 18588 0 3
83369: ST_TO_ADDR
// exit ;
83370: POP
83371: POP
83372: GO 83830
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
83374: LD_VAR 0 5
83378: PUSH
83379: LD_INT 0
83381: PUSH
83382: LD_INT 2
83384: PUSH
83385: LD_INT 4
83387: PUSH
83388: EMPTY
83389: LIST
83390: LIST
83391: LIST
83392: IN
83393: IFFALSE 83517
// begin if btype = b_armoury then
83395: LD_VAR 0 5
83399: PUSH
83400: LD_INT 4
83402: EQUAL
83403: IFFALSE 83413
// btype := b_barracks ;
83405: LD_ADDR_VAR 0 5
83409: PUSH
83410: LD_INT 5
83412: ST_TO_ADDR
// if btype = b_depot then
83413: LD_VAR 0 5
83417: PUSH
83418: LD_INT 0
83420: EQUAL
83421: IFFALSE 83431
// btype := b_warehouse ;
83423: LD_ADDR_VAR 0 5
83427: PUSH
83428: LD_INT 1
83430: ST_TO_ADDR
// if btype = b_workshop then
83431: LD_VAR 0 5
83435: PUSH
83436: LD_INT 2
83438: EQUAL
83439: IFFALSE 83449
// btype := b_factory ;
83441: LD_ADDR_VAR 0 5
83445: PUSH
83446: LD_INT 3
83448: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
83449: LD_VAR 0 5
83453: PPUSH
83454: LD_VAR 0 8
83458: PPUSH
83459: CALL_OW 323
83463: PUSH
83464: LD_INT 1
83466: EQUAL
83467: IFFALSE 83513
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
83469: LD_ADDR_EXP 101
83473: PUSH
83474: LD_EXP 101
83478: PPUSH
83479: LD_VAR 0 3
83483: PUSH
83484: LD_EXP 101
83488: PUSH
83489: LD_VAR 0 3
83493: ARRAY
83494: PUSH
83495: LD_INT 1
83497: PLUS
83498: PUSH
83499: EMPTY
83500: LIST
83501: LIST
83502: PPUSH
83503: LD_VAR 0 1
83507: PPUSH
83508: CALL 18588 0 3
83512: ST_TO_ADDR
// exit ;
83513: POP
83514: POP
83515: GO 83830
// end ; if btype in [ b_bunker , b_turret ] then
83517: LD_VAR 0 5
83521: PUSH
83522: LD_INT 32
83524: PUSH
83525: LD_INT 33
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: IN
83532: IFFALSE 83822
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
83534: LD_ADDR_EXP 77
83538: PUSH
83539: LD_EXP 77
83543: PPUSH
83544: LD_VAR 0 3
83548: PUSH
83549: LD_EXP 77
83553: PUSH
83554: LD_VAR 0 3
83558: ARRAY
83559: PUSH
83560: LD_INT 1
83562: PLUS
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: PPUSH
83568: LD_VAR 0 1
83572: PPUSH
83573: CALL 18588 0 3
83577: ST_TO_ADDR
// if btype = b_bunker then
83578: LD_VAR 0 5
83582: PUSH
83583: LD_INT 32
83585: EQUAL
83586: IFFALSE 83822
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83588: LD_ADDR_EXP 78
83592: PUSH
83593: LD_EXP 78
83597: PPUSH
83598: LD_VAR 0 3
83602: PUSH
83603: LD_EXP 78
83607: PUSH
83608: LD_VAR 0 3
83612: ARRAY
83613: PUSH
83614: LD_INT 1
83616: PLUS
83617: PUSH
83618: EMPTY
83619: LIST
83620: LIST
83621: PPUSH
83622: LD_VAR 0 1
83626: PPUSH
83627: CALL 18588 0 3
83631: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
83632: LD_ADDR_VAR 0 6
83636: PUSH
83637: LD_EXP 69
83641: PUSH
83642: LD_VAR 0 3
83646: ARRAY
83647: PPUSH
83648: LD_INT 25
83650: PUSH
83651: LD_INT 1
83653: PUSH
83654: EMPTY
83655: LIST
83656: LIST
83657: PUSH
83658: LD_INT 3
83660: PUSH
83661: LD_INT 54
83663: PUSH
83664: EMPTY
83665: LIST
83666: PUSH
83667: EMPTY
83668: LIST
83669: LIST
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PPUSH
83675: CALL_OW 72
83679: ST_TO_ADDR
// if tmp then
83680: LD_VAR 0 6
83684: IFFALSE 83690
// exit ;
83686: POP
83687: POP
83688: GO 83830
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
83690: LD_ADDR_VAR 0 6
83694: PUSH
83695: LD_EXP 69
83699: PUSH
83700: LD_VAR 0 3
83704: ARRAY
83705: PPUSH
83706: LD_INT 2
83708: PUSH
83709: LD_INT 30
83711: PUSH
83712: LD_INT 4
83714: PUSH
83715: EMPTY
83716: LIST
83717: LIST
83718: PUSH
83719: LD_INT 30
83721: PUSH
83722: LD_INT 5
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PUSH
83729: EMPTY
83730: LIST
83731: LIST
83732: LIST
83733: PPUSH
83734: CALL_OW 72
83738: ST_TO_ADDR
// if not tmp then
83739: LD_VAR 0 6
83743: NOT
83744: IFFALSE 83750
// exit ;
83746: POP
83747: POP
83748: GO 83830
// for j in tmp do
83750: LD_ADDR_VAR 0 4
83754: PUSH
83755: LD_VAR 0 6
83759: PUSH
83760: FOR_IN
83761: IFFALSE 83820
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
83763: LD_ADDR_VAR 0 7
83767: PUSH
83768: LD_VAR 0 4
83772: PPUSH
83773: CALL_OW 313
83777: PPUSH
83778: LD_INT 25
83780: PUSH
83781: LD_INT 1
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: PPUSH
83788: CALL_OW 72
83792: ST_TO_ADDR
// if units then
83793: LD_VAR 0 7
83797: IFFALSE 83818
// begin ComExitBuilding ( units [ 1 ] ) ;
83799: LD_VAR 0 7
83803: PUSH
83804: LD_INT 1
83806: ARRAY
83807: PPUSH
83808: CALL_OW 122
// exit ;
83812: POP
83813: POP
83814: POP
83815: POP
83816: GO 83830
// end ; end ;
83818: GO 83760
83820: POP
83821: POP
// end ; end ; exit ;
83822: POP
83823: POP
83824: GO 83830
// end ; end ;
83826: GO 83184
83828: POP
83829: POP
// end ;
83830: LD_VAR 0 2
83834: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
83835: LD_INT 0
83837: PPUSH
83838: PPUSH
83839: PPUSH
83840: PPUSH
83841: PPUSH
83842: PPUSH
83843: PPUSH
// if not mc_bases or not skirmish then
83844: LD_EXP 69
83848: NOT
83849: PUSH
83850: LD_EXP 67
83854: NOT
83855: OR
83856: IFFALSE 83860
// exit ;
83858: GO 84125
// btype := GetBType ( building ) ;
83860: LD_ADDR_VAR 0 6
83864: PUSH
83865: LD_VAR 0 1
83869: PPUSH
83870: CALL_OW 266
83874: ST_TO_ADDR
// x := GetX ( building ) ;
83875: LD_ADDR_VAR 0 7
83879: PUSH
83880: LD_VAR 0 1
83884: PPUSH
83885: CALL_OW 250
83889: ST_TO_ADDR
// y := GetY ( building ) ;
83890: LD_ADDR_VAR 0 8
83894: PUSH
83895: LD_VAR 0 1
83899: PPUSH
83900: CALL_OW 251
83904: ST_TO_ADDR
// d := GetDir ( building ) ;
83905: LD_ADDR_VAR 0 9
83909: PUSH
83910: LD_VAR 0 1
83914: PPUSH
83915: CALL_OW 254
83919: ST_TO_ADDR
// for i = 1 to mc_bases do
83920: LD_ADDR_VAR 0 4
83924: PUSH
83925: DOUBLE
83926: LD_INT 1
83928: DEC
83929: ST_TO_ADDR
83930: LD_EXP 69
83934: PUSH
83935: FOR_TO
83936: IFFALSE 84123
// begin if not mc_build_list [ i ] then
83938: LD_EXP 74
83942: PUSH
83943: LD_VAR 0 4
83947: ARRAY
83948: NOT
83949: IFFALSE 83953
// continue ;
83951: GO 83935
// for j := 1 to mc_build_list [ i ] do
83953: LD_ADDR_VAR 0 5
83957: PUSH
83958: DOUBLE
83959: LD_INT 1
83961: DEC
83962: ST_TO_ADDR
83963: LD_EXP 74
83967: PUSH
83968: LD_VAR 0 4
83972: ARRAY
83973: PUSH
83974: FOR_TO
83975: IFFALSE 84119
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
83977: LD_VAR 0 6
83981: PUSH
83982: LD_VAR 0 7
83986: PUSH
83987: LD_VAR 0 8
83991: PUSH
83992: LD_VAR 0 9
83996: PUSH
83997: EMPTY
83998: LIST
83999: LIST
84000: LIST
84001: LIST
84002: PPUSH
84003: LD_EXP 74
84007: PUSH
84008: LD_VAR 0 4
84012: ARRAY
84013: PUSH
84014: LD_VAR 0 5
84018: ARRAY
84019: PPUSH
84020: CALL 24770 0 2
84024: IFFALSE 84117
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
84026: LD_ADDR_EXP 74
84030: PUSH
84031: LD_EXP 74
84035: PPUSH
84036: LD_VAR 0 4
84040: PPUSH
84041: LD_EXP 74
84045: PUSH
84046: LD_VAR 0 4
84050: ARRAY
84051: PPUSH
84052: LD_VAR 0 5
84056: PPUSH
84057: CALL_OW 3
84061: PPUSH
84062: CALL_OW 1
84066: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
84067: LD_ADDR_EXP 76
84071: PUSH
84072: LD_EXP 76
84076: PPUSH
84077: LD_VAR 0 4
84081: PUSH
84082: LD_EXP 76
84086: PUSH
84087: LD_VAR 0 4
84091: ARRAY
84092: PUSH
84093: LD_INT 1
84095: PLUS
84096: PUSH
84097: EMPTY
84098: LIST
84099: LIST
84100: PPUSH
84101: LD_VAR 0 1
84105: PPUSH
84106: CALL 18588 0 3
84110: ST_TO_ADDR
// exit ;
84111: POP
84112: POP
84113: POP
84114: POP
84115: GO 84125
// end ;
84117: GO 83974
84119: POP
84120: POP
// end ;
84121: GO 83935
84123: POP
84124: POP
// end ;
84125: LD_VAR 0 3
84129: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
84130: LD_INT 0
84132: PPUSH
84133: PPUSH
84134: PPUSH
// if not mc_bases or not skirmish then
84135: LD_EXP 69
84139: NOT
84140: PUSH
84141: LD_EXP 67
84145: NOT
84146: OR
84147: IFFALSE 84151
// exit ;
84149: GO 84341
// for i = 1 to mc_bases do
84151: LD_ADDR_VAR 0 4
84155: PUSH
84156: DOUBLE
84157: LD_INT 1
84159: DEC
84160: ST_TO_ADDR
84161: LD_EXP 69
84165: PUSH
84166: FOR_TO
84167: IFFALSE 84254
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
84169: LD_VAR 0 1
84173: PUSH
84174: LD_EXP 77
84178: PUSH
84179: LD_VAR 0 4
84183: ARRAY
84184: IN
84185: PUSH
84186: LD_VAR 0 1
84190: PUSH
84191: LD_EXP 78
84195: PUSH
84196: LD_VAR 0 4
84200: ARRAY
84201: IN
84202: NOT
84203: AND
84204: IFFALSE 84252
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84206: LD_ADDR_EXP 78
84210: PUSH
84211: LD_EXP 78
84215: PPUSH
84216: LD_VAR 0 4
84220: PUSH
84221: LD_EXP 78
84225: PUSH
84226: LD_VAR 0 4
84230: ARRAY
84231: PUSH
84232: LD_INT 1
84234: PLUS
84235: PUSH
84236: EMPTY
84237: LIST
84238: LIST
84239: PPUSH
84240: LD_VAR 0 1
84244: PPUSH
84245: CALL 18588 0 3
84249: ST_TO_ADDR
// break ;
84250: GO 84254
// end ; end ;
84252: GO 84166
84254: POP
84255: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
84256: LD_VAR 0 1
84260: PPUSH
84261: CALL_OW 257
84265: PUSH
84266: LD_EXP 95
84270: IN
84271: PUSH
84272: LD_VAR 0 1
84276: PPUSH
84277: CALL_OW 266
84281: PUSH
84282: LD_INT 5
84284: EQUAL
84285: AND
84286: PUSH
84287: LD_VAR 0 2
84291: PPUSH
84292: CALL_OW 110
84296: PUSH
84297: LD_INT 18
84299: NONEQUAL
84300: AND
84301: IFFALSE 84341
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
84303: LD_VAR 0 2
84307: PPUSH
84308: CALL_OW 257
84312: PUSH
84313: LD_INT 5
84315: PUSH
84316: LD_INT 8
84318: PUSH
84319: LD_INT 9
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: LIST
84326: IN
84327: IFFALSE 84341
// SetClass ( unit , 1 ) ;
84329: LD_VAR 0 2
84333: PPUSH
84334: LD_INT 1
84336: PPUSH
84337: CALL_OW 336
// end ;
84341: LD_VAR 0 3
84345: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
84346: LD_INT 0
84348: PPUSH
84349: PPUSH
// if not mc_bases or not skirmish then
84350: LD_EXP 69
84354: NOT
84355: PUSH
84356: LD_EXP 67
84360: NOT
84361: OR
84362: IFFALSE 84366
// exit ;
84364: GO 84482
// if GetLives ( abandoned_vehicle ) > 250 then
84366: LD_VAR 0 2
84370: PPUSH
84371: CALL_OW 256
84375: PUSH
84376: LD_INT 250
84378: GREATER
84379: IFFALSE 84383
// exit ;
84381: GO 84482
// for i = 1 to mc_bases do
84383: LD_ADDR_VAR 0 6
84387: PUSH
84388: DOUBLE
84389: LD_INT 1
84391: DEC
84392: ST_TO_ADDR
84393: LD_EXP 69
84397: PUSH
84398: FOR_TO
84399: IFFALSE 84480
// begin if driver in mc_bases [ i ] then
84401: LD_VAR 0 1
84405: PUSH
84406: LD_EXP 69
84410: PUSH
84411: LD_VAR 0 6
84415: ARRAY
84416: IN
84417: IFFALSE 84478
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
84419: LD_VAR 0 1
84423: PPUSH
84424: LD_EXP 69
84428: PUSH
84429: LD_VAR 0 6
84433: ARRAY
84434: PPUSH
84435: LD_INT 2
84437: PUSH
84438: LD_INT 30
84440: PUSH
84441: LD_INT 0
84443: PUSH
84444: EMPTY
84445: LIST
84446: LIST
84447: PUSH
84448: LD_INT 30
84450: PUSH
84451: LD_INT 1
84453: PUSH
84454: EMPTY
84455: LIST
84456: LIST
84457: PUSH
84458: EMPTY
84459: LIST
84460: LIST
84461: LIST
84462: PPUSH
84463: CALL_OW 72
84467: PUSH
84468: LD_INT 1
84470: ARRAY
84471: PPUSH
84472: CALL 51206 0 2
// break ;
84476: GO 84480
// end ; end ;
84478: GO 84398
84480: POP
84481: POP
// end ; end_of_file end_of_file
84482: LD_VAR 0 5
84486: RET
// every 0 0$1 do
84487: GO 84489
84489: DISABLE
// begin enable ;
84490: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
84491: LD_STRING updateTimer(
84493: PUSH
84494: LD_OWVAR 1
84498: STR
84499: PUSH
84500: LD_STRING );
84502: STR
84503: PPUSH
84504: CALL_OW 559
// end ;
84508: END
// on MapStart ( p ) do begin if streamModeActive then
84509: LD_EXP 113
84513: IFFALSE 84522
// DefineStreamItems ( true ) ;
84515: LD_INT 1
84517: PPUSH
84518: CALL 86170 0 1
// UpdateFactoryWaypoints ( ) ;
84522: CALL 99754 0 0
// end ;
84526: PPOPN 1
84528: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
84529: LD_INT 0
84531: PPUSH
// if p2 = 100 then
84532: LD_VAR 0 2
84536: PUSH
84537: LD_INT 100
84539: EQUAL
84540: IFFALSE 85543
// begin if not StreamModeActive then
84542: LD_EXP 113
84546: NOT
84547: IFFALSE 84557
// StreamModeActive := true ;
84549: LD_ADDR_EXP 113
84553: PUSH
84554: LD_INT 1
84556: ST_TO_ADDR
// if p3 = 0 then
84557: LD_VAR 0 3
84561: PUSH
84562: LD_INT 0
84564: EQUAL
84565: IFFALSE 84571
// InitStreamMode ;
84567: CALL 85706 0 0
// if p3 = 1 then
84571: LD_VAR 0 3
84575: PUSH
84576: LD_INT 1
84578: EQUAL
84579: IFFALSE 84589
// sRocket := true ;
84581: LD_ADDR_EXP 118
84585: PUSH
84586: LD_INT 1
84588: ST_TO_ADDR
// if p3 = 2 then
84589: LD_VAR 0 3
84593: PUSH
84594: LD_INT 2
84596: EQUAL
84597: IFFALSE 84607
// sSpeed := true ;
84599: LD_ADDR_EXP 117
84603: PUSH
84604: LD_INT 1
84606: ST_TO_ADDR
// if p3 = 3 then
84607: LD_VAR 0 3
84611: PUSH
84612: LD_INT 3
84614: EQUAL
84615: IFFALSE 84625
// sEngine := true ;
84617: LD_ADDR_EXP 119
84621: PUSH
84622: LD_INT 1
84624: ST_TO_ADDR
// if p3 = 4 then
84625: LD_VAR 0 3
84629: PUSH
84630: LD_INT 4
84632: EQUAL
84633: IFFALSE 84643
// sSpec := true ;
84635: LD_ADDR_EXP 116
84639: PUSH
84640: LD_INT 1
84642: ST_TO_ADDR
// if p3 = 5 then
84643: LD_VAR 0 3
84647: PUSH
84648: LD_INT 5
84650: EQUAL
84651: IFFALSE 84661
// sLevel := true ;
84653: LD_ADDR_EXP 120
84657: PUSH
84658: LD_INT 1
84660: ST_TO_ADDR
// if p3 = 6 then
84661: LD_VAR 0 3
84665: PUSH
84666: LD_INT 6
84668: EQUAL
84669: IFFALSE 84679
// sArmoury := true ;
84671: LD_ADDR_EXP 121
84675: PUSH
84676: LD_INT 1
84678: ST_TO_ADDR
// if p3 = 7 then
84679: LD_VAR 0 3
84683: PUSH
84684: LD_INT 7
84686: EQUAL
84687: IFFALSE 84697
// sRadar := true ;
84689: LD_ADDR_EXP 122
84693: PUSH
84694: LD_INT 1
84696: ST_TO_ADDR
// if p3 = 8 then
84697: LD_VAR 0 3
84701: PUSH
84702: LD_INT 8
84704: EQUAL
84705: IFFALSE 84715
// sBunker := true ;
84707: LD_ADDR_EXP 123
84711: PUSH
84712: LD_INT 1
84714: ST_TO_ADDR
// if p3 = 9 then
84715: LD_VAR 0 3
84719: PUSH
84720: LD_INT 9
84722: EQUAL
84723: IFFALSE 84733
// sHack := true ;
84725: LD_ADDR_EXP 124
84729: PUSH
84730: LD_INT 1
84732: ST_TO_ADDR
// if p3 = 10 then
84733: LD_VAR 0 3
84737: PUSH
84738: LD_INT 10
84740: EQUAL
84741: IFFALSE 84751
// sFire := true ;
84743: LD_ADDR_EXP 125
84747: PUSH
84748: LD_INT 1
84750: ST_TO_ADDR
// if p3 = 11 then
84751: LD_VAR 0 3
84755: PUSH
84756: LD_INT 11
84758: EQUAL
84759: IFFALSE 84769
// sRefresh := true ;
84761: LD_ADDR_EXP 126
84765: PUSH
84766: LD_INT 1
84768: ST_TO_ADDR
// if p3 = 12 then
84769: LD_VAR 0 3
84773: PUSH
84774: LD_INT 12
84776: EQUAL
84777: IFFALSE 84787
// sExp := true ;
84779: LD_ADDR_EXP 127
84783: PUSH
84784: LD_INT 1
84786: ST_TO_ADDR
// if p3 = 13 then
84787: LD_VAR 0 3
84791: PUSH
84792: LD_INT 13
84794: EQUAL
84795: IFFALSE 84805
// sDepot := true ;
84797: LD_ADDR_EXP 128
84801: PUSH
84802: LD_INT 1
84804: ST_TO_ADDR
// if p3 = 14 then
84805: LD_VAR 0 3
84809: PUSH
84810: LD_INT 14
84812: EQUAL
84813: IFFALSE 84823
// sFlag := true ;
84815: LD_ADDR_EXP 129
84819: PUSH
84820: LD_INT 1
84822: ST_TO_ADDR
// if p3 = 15 then
84823: LD_VAR 0 3
84827: PUSH
84828: LD_INT 15
84830: EQUAL
84831: IFFALSE 84841
// sKamikadze := true ;
84833: LD_ADDR_EXP 137
84837: PUSH
84838: LD_INT 1
84840: ST_TO_ADDR
// if p3 = 16 then
84841: LD_VAR 0 3
84845: PUSH
84846: LD_INT 16
84848: EQUAL
84849: IFFALSE 84859
// sTroll := true ;
84851: LD_ADDR_EXP 138
84855: PUSH
84856: LD_INT 1
84858: ST_TO_ADDR
// if p3 = 17 then
84859: LD_VAR 0 3
84863: PUSH
84864: LD_INT 17
84866: EQUAL
84867: IFFALSE 84877
// sSlow := true ;
84869: LD_ADDR_EXP 139
84873: PUSH
84874: LD_INT 1
84876: ST_TO_ADDR
// if p3 = 18 then
84877: LD_VAR 0 3
84881: PUSH
84882: LD_INT 18
84884: EQUAL
84885: IFFALSE 84895
// sLack := true ;
84887: LD_ADDR_EXP 140
84891: PUSH
84892: LD_INT 1
84894: ST_TO_ADDR
// if p3 = 19 then
84895: LD_VAR 0 3
84899: PUSH
84900: LD_INT 19
84902: EQUAL
84903: IFFALSE 84913
// sTank := true ;
84905: LD_ADDR_EXP 142
84909: PUSH
84910: LD_INT 1
84912: ST_TO_ADDR
// if p3 = 20 then
84913: LD_VAR 0 3
84917: PUSH
84918: LD_INT 20
84920: EQUAL
84921: IFFALSE 84931
// sRemote := true ;
84923: LD_ADDR_EXP 143
84927: PUSH
84928: LD_INT 1
84930: ST_TO_ADDR
// if p3 = 21 then
84931: LD_VAR 0 3
84935: PUSH
84936: LD_INT 21
84938: EQUAL
84939: IFFALSE 84949
// sPowell := true ;
84941: LD_ADDR_EXP 144
84945: PUSH
84946: LD_INT 1
84948: ST_TO_ADDR
// if p3 = 22 then
84949: LD_VAR 0 3
84953: PUSH
84954: LD_INT 22
84956: EQUAL
84957: IFFALSE 84967
// sTeleport := true ;
84959: LD_ADDR_EXP 147
84963: PUSH
84964: LD_INT 1
84966: ST_TO_ADDR
// if p3 = 23 then
84967: LD_VAR 0 3
84971: PUSH
84972: LD_INT 23
84974: EQUAL
84975: IFFALSE 84985
// sOilTower := true ;
84977: LD_ADDR_EXP 149
84981: PUSH
84982: LD_INT 1
84984: ST_TO_ADDR
// if p3 = 24 then
84985: LD_VAR 0 3
84989: PUSH
84990: LD_INT 24
84992: EQUAL
84993: IFFALSE 85003
// sShovel := true ;
84995: LD_ADDR_EXP 150
84999: PUSH
85000: LD_INT 1
85002: ST_TO_ADDR
// if p3 = 25 then
85003: LD_VAR 0 3
85007: PUSH
85008: LD_INT 25
85010: EQUAL
85011: IFFALSE 85021
// sSheik := true ;
85013: LD_ADDR_EXP 151
85017: PUSH
85018: LD_INT 1
85020: ST_TO_ADDR
// if p3 = 26 then
85021: LD_VAR 0 3
85025: PUSH
85026: LD_INT 26
85028: EQUAL
85029: IFFALSE 85039
// sEarthquake := true ;
85031: LD_ADDR_EXP 153
85035: PUSH
85036: LD_INT 1
85038: ST_TO_ADDR
// if p3 = 27 then
85039: LD_VAR 0 3
85043: PUSH
85044: LD_INT 27
85046: EQUAL
85047: IFFALSE 85057
// sAI := true ;
85049: LD_ADDR_EXP 154
85053: PUSH
85054: LD_INT 1
85056: ST_TO_ADDR
// if p3 = 28 then
85057: LD_VAR 0 3
85061: PUSH
85062: LD_INT 28
85064: EQUAL
85065: IFFALSE 85075
// sCargo := true ;
85067: LD_ADDR_EXP 157
85071: PUSH
85072: LD_INT 1
85074: ST_TO_ADDR
// if p3 = 29 then
85075: LD_VAR 0 3
85079: PUSH
85080: LD_INT 29
85082: EQUAL
85083: IFFALSE 85093
// sDLaser := true ;
85085: LD_ADDR_EXP 158
85089: PUSH
85090: LD_INT 1
85092: ST_TO_ADDR
// if p3 = 30 then
85093: LD_VAR 0 3
85097: PUSH
85098: LD_INT 30
85100: EQUAL
85101: IFFALSE 85111
// sExchange := true ;
85103: LD_ADDR_EXP 159
85107: PUSH
85108: LD_INT 1
85110: ST_TO_ADDR
// if p3 = 31 then
85111: LD_VAR 0 3
85115: PUSH
85116: LD_INT 31
85118: EQUAL
85119: IFFALSE 85129
// sFac := true ;
85121: LD_ADDR_EXP 160
85125: PUSH
85126: LD_INT 1
85128: ST_TO_ADDR
// if p3 = 32 then
85129: LD_VAR 0 3
85133: PUSH
85134: LD_INT 32
85136: EQUAL
85137: IFFALSE 85147
// sPower := true ;
85139: LD_ADDR_EXP 161
85143: PUSH
85144: LD_INT 1
85146: ST_TO_ADDR
// if p3 = 33 then
85147: LD_VAR 0 3
85151: PUSH
85152: LD_INT 33
85154: EQUAL
85155: IFFALSE 85165
// sRandom := true ;
85157: LD_ADDR_EXP 162
85161: PUSH
85162: LD_INT 1
85164: ST_TO_ADDR
// if p3 = 34 then
85165: LD_VAR 0 3
85169: PUSH
85170: LD_INT 34
85172: EQUAL
85173: IFFALSE 85183
// sShield := true ;
85175: LD_ADDR_EXP 163
85179: PUSH
85180: LD_INT 1
85182: ST_TO_ADDR
// if p3 = 35 then
85183: LD_VAR 0 3
85187: PUSH
85188: LD_INT 35
85190: EQUAL
85191: IFFALSE 85201
// sTime := true ;
85193: LD_ADDR_EXP 164
85197: PUSH
85198: LD_INT 1
85200: ST_TO_ADDR
// if p3 = 36 then
85201: LD_VAR 0 3
85205: PUSH
85206: LD_INT 36
85208: EQUAL
85209: IFFALSE 85219
// sTools := true ;
85211: LD_ADDR_EXP 165
85215: PUSH
85216: LD_INT 1
85218: ST_TO_ADDR
// if p3 = 101 then
85219: LD_VAR 0 3
85223: PUSH
85224: LD_INT 101
85226: EQUAL
85227: IFFALSE 85237
// sSold := true ;
85229: LD_ADDR_EXP 130
85233: PUSH
85234: LD_INT 1
85236: ST_TO_ADDR
// if p3 = 102 then
85237: LD_VAR 0 3
85241: PUSH
85242: LD_INT 102
85244: EQUAL
85245: IFFALSE 85255
// sDiff := true ;
85247: LD_ADDR_EXP 131
85251: PUSH
85252: LD_INT 1
85254: ST_TO_ADDR
// if p3 = 103 then
85255: LD_VAR 0 3
85259: PUSH
85260: LD_INT 103
85262: EQUAL
85263: IFFALSE 85273
// sFog := true ;
85265: LD_ADDR_EXP 134
85269: PUSH
85270: LD_INT 1
85272: ST_TO_ADDR
// if p3 = 104 then
85273: LD_VAR 0 3
85277: PUSH
85278: LD_INT 104
85280: EQUAL
85281: IFFALSE 85291
// sReset := true ;
85283: LD_ADDR_EXP 135
85287: PUSH
85288: LD_INT 1
85290: ST_TO_ADDR
// if p3 = 105 then
85291: LD_VAR 0 3
85295: PUSH
85296: LD_INT 105
85298: EQUAL
85299: IFFALSE 85309
// sSun := true ;
85301: LD_ADDR_EXP 136
85305: PUSH
85306: LD_INT 1
85308: ST_TO_ADDR
// if p3 = 106 then
85309: LD_VAR 0 3
85313: PUSH
85314: LD_INT 106
85316: EQUAL
85317: IFFALSE 85327
// sTiger := true ;
85319: LD_ADDR_EXP 132
85323: PUSH
85324: LD_INT 1
85326: ST_TO_ADDR
// if p3 = 107 then
85327: LD_VAR 0 3
85331: PUSH
85332: LD_INT 107
85334: EQUAL
85335: IFFALSE 85345
// sBomb := true ;
85337: LD_ADDR_EXP 133
85341: PUSH
85342: LD_INT 1
85344: ST_TO_ADDR
// if p3 = 108 then
85345: LD_VAR 0 3
85349: PUSH
85350: LD_INT 108
85352: EQUAL
85353: IFFALSE 85363
// sWound := true ;
85355: LD_ADDR_EXP 141
85359: PUSH
85360: LD_INT 1
85362: ST_TO_ADDR
// if p3 = 109 then
85363: LD_VAR 0 3
85367: PUSH
85368: LD_INT 109
85370: EQUAL
85371: IFFALSE 85381
// sBetray := true ;
85373: LD_ADDR_EXP 145
85377: PUSH
85378: LD_INT 1
85380: ST_TO_ADDR
// if p3 = 110 then
85381: LD_VAR 0 3
85385: PUSH
85386: LD_INT 110
85388: EQUAL
85389: IFFALSE 85399
// sContamin := true ;
85391: LD_ADDR_EXP 146
85395: PUSH
85396: LD_INT 1
85398: ST_TO_ADDR
// if p3 = 111 then
85399: LD_VAR 0 3
85403: PUSH
85404: LD_INT 111
85406: EQUAL
85407: IFFALSE 85417
// sOil := true ;
85409: LD_ADDR_EXP 148
85413: PUSH
85414: LD_INT 1
85416: ST_TO_ADDR
// if p3 = 112 then
85417: LD_VAR 0 3
85421: PUSH
85422: LD_INT 112
85424: EQUAL
85425: IFFALSE 85435
// sStu := true ;
85427: LD_ADDR_EXP 152
85431: PUSH
85432: LD_INT 1
85434: ST_TO_ADDR
// if p3 = 113 then
85435: LD_VAR 0 3
85439: PUSH
85440: LD_INT 113
85442: EQUAL
85443: IFFALSE 85453
// sBazooka := true ;
85445: LD_ADDR_EXP 155
85449: PUSH
85450: LD_INT 1
85452: ST_TO_ADDR
// if p3 = 114 then
85453: LD_VAR 0 3
85457: PUSH
85458: LD_INT 114
85460: EQUAL
85461: IFFALSE 85471
// sMortar := true ;
85463: LD_ADDR_EXP 156
85467: PUSH
85468: LD_INT 1
85470: ST_TO_ADDR
// if p3 = 115 then
85471: LD_VAR 0 3
85475: PUSH
85476: LD_INT 115
85478: EQUAL
85479: IFFALSE 85489
// sRanger := true ;
85481: LD_ADDR_EXP 166
85485: PUSH
85486: LD_INT 1
85488: ST_TO_ADDR
// if p3 = 116 then
85489: LD_VAR 0 3
85493: PUSH
85494: LD_INT 116
85496: EQUAL
85497: IFFALSE 85507
// sComputer := true ;
85499: LD_ADDR_EXP 167
85503: PUSH
85504: LD_INT 1
85506: ST_TO_ADDR
// if p3 = 117 then
85507: LD_VAR 0 3
85511: PUSH
85512: LD_INT 117
85514: EQUAL
85515: IFFALSE 85525
// s30 := true ;
85517: LD_ADDR_EXP 168
85521: PUSH
85522: LD_INT 1
85524: ST_TO_ADDR
// if p3 = 118 then
85525: LD_VAR 0 3
85529: PUSH
85530: LD_INT 118
85532: EQUAL
85533: IFFALSE 85543
// s60 := true ;
85535: LD_ADDR_EXP 169
85539: PUSH
85540: LD_INT 1
85542: ST_TO_ADDR
// end ; if p2 = 101 then
85543: LD_VAR 0 2
85547: PUSH
85548: LD_INT 101
85550: EQUAL
85551: IFFALSE 85679
// begin case p3 of 1 :
85553: LD_VAR 0 3
85557: PUSH
85558: LD_INT 1
85560: DOUBLE
85561: EQUAL
85562: IFTRUE 85566
85564: GO 85573
85566: POP
// hHackUnlimitedResources ; 2 :
85567: CALL 97777 0 0
85571: GO 85679
85573: LD_INT 2
85575: DOUBLE
85576: EQUAL
85577: IFTRUE 85581
85579: GO 85588
85581: POP
// hHackSetLevel10 ; 3 :
85582: CALL 97910 0 0
85586: GO 85679
85588: LD_INT 3
85590: DOUBLE
85591: EQUAL
85592: IFTRUE 85596
85594: GO 85603
85596: POP
// hHackSetLevel10YourUnits ; 4 :
85597: CALL 97995 0 0
85601: GO 85679
85603: LD_INT 4
85605: DOUBLE
85606: EQUAL
85607: IFTRUE 85611
85609: GO 85618
85611: POP
// hHackInvincible ; 5 :
85612: CALL 98443 0 0
85616: GO 85679
85618: LD_INT 5
85620: DOUBLE
85621: EQUAL
85622: IFTRUE 85626
85624: GO 85633
85626: POP
// hHackInvisible ; 6 :
85627: CALL 98554 0 0
85631: GO 85679
85633: LD_INT 6
85635: DOUBLE
85636: EQUAL
85637: IFTRUE 85641
85639: GO 85648
85641: POP
// hHackChangeYourSide ; 7 :
85642: CALL 98611 0 0
85646: GO 85679
85648: LD_INT 7
85650: DOUBLE
85651: EQUAL
85652: IFTRUE 85656
85654: GO 85663
85656: POP
// hHackChangeUnitSide ; 8 :
85657: CALL 98653 0 0
85661: GO 85679
85663: LD_INT 8
85665: DOUBLE
85666: EQUAL
85667: IFTRUE 85671
85669: GO 85678
85671: POP
// hHackFog ; end ;
85672: CALL 98754 0 0
85676: GO 85679
85678: POP
// end ; end ;
85679: LD_VAR 0 7
85683: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
85684: GO 85686
85686: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
85687: LD_STRING initStreamRollete();
85689: PPUSH
85690: CALL_OW 559
// InitStreamMode ;
85694: CALL 85706 0 0
// DefineStreamItems ( false ) ;
85698: LD_INT 0
85700: PPUSH
85701: CALL 86170 0 1
// end ;
85705: END
// function InitStreamMode ; begin
85706: LD_INT 0
85708: PPUSH
// streamModeActive := false ;
85709: LD_ADDR_EXP 113
85713: PUSH
85714: LD_INT 0
85716: ST_TO_ADDR
// normalCounter := 36 ;
85717: LD_ADDR_EXP 114
85721: PUSH
85722: LD_INT 36
85724: ST_TO_ADDR
// hardcoreCounter := 18 ;
85725: LD_ADDR_EXP 115
85729: PUSH
85730: LD_INT 18
85732: ST_TO_ADDR
// sRocket := false ;
85733: LD_ADDR_EXP 118
85737: PUSH
85738: LD_INT 0
85740: ST_TO_ADDR
// sSpeed := false ;
85741: LD_ADDR_EXP 117
85745: PUSH
85746: LD_INT 0
85748: ST_TO_ADDR
// sEngine := false ;
85749: LD_ADDR_EXP 119
85753: PUSH
85754: LD_INT 0
85756: ST_TO_ADDR
// sSpec := false ;
85757: LD_ADDR_EXP 116
85761: PUSH
85762: LD_INT 0
85764: ST_TO_ADDR
// sLevel := false ;
85765: LD_ADDR_EXP 120
85769: PUSH
85770: LD_INT 0
85772: ST_TO_ADDR
// sArmoury := false ;
85773: LD_ADDR_EXP 121
85777: PUSH
85778: LD_INT 0
85780: ST_TO_ADDR
// sRadar := false ;
85781: LD_ADDR_EXP 122
85785: PUSH
85786: LD_INT 0
85788: ST_TO_ADDR
// sBunker := false ;
85789: LD_ADDR_EXP 123
85793: PUSH
85794: LD_INT 0
85796: ST_TO_ADDR
// sHack := false ;
85797: LD_ADDR_EXP 124
85801: PUSH
85802: LD_INT 0
85804: ST_TO_ADDR
// sFire := false ;
85805: LD_ADDR_EXP 125
85809: PUSH
85810: LD_INT 0
85812: ST_TO_ADDR
// sRefresh := false ;
85813: LD_ADDR_EXP 126
85817: PUSH
85818: LD_INT 0
85820: ST_TO_ADDR
// sExp := false ;
85821: LD_ADDR_EXP 127
85825: PUSH
85826: LD_INT 0
85828: ST_TO_ADDR
// sDepot := false ;
85829: LD_ADDR_EXP 128
85833: PUSH
85834: LD_INT 0
85836: ST_TO_ADDR
// sFlag := false ;
85837: LD_ADDR_EXP 129
85841: PUSH
85842: LD_INT 0
85844: ST_TO_ADDR
// sKamikadze := false ;
85845: LD_ADDR_EXP 137
85849: PUSH
85850: LD_INT 0
85852: ST_TO_ADDR
// sTroll := false ;
85853: LD_ADDR_EXP 138
85857: PUSH
85858: LD_INT 0
85860: ST_TO_ADDR
// sSlow := false ;
85861: LD_ADDR_EXP 139
85865: PUSH
85866: LD_INT 0
85868: ST_TO_ADDR
// sLack := false ;
85869: LD_ADDR_EXP 140
85873: PUSH
85874: LD_INT 0
85876: ST_TO_ADDR
// sTank := false ;
85877: LD_ADDR_EXP 142
85881: PUSH
85882: LD_INT 0
85884: ST_TO_ADDR
// sRemote := false ;
85885: LD_ADDR_EXP 143
85889: PUSH
85890: LD_INT 0
85892: ST_TO_ADDR
// sPowell := false ;
85893: LD_ADDR_EXP 144
85897: PUSH
85898: LD_INT 0
85900: ST_TO_ADDR
// sTeleport := false ;
85901: LD_ADDR_EXP 147
85905: PUSH
85906: LD_INT 0
85908: ST_TO_ADDR
// sOilTower := false ;
85909: LD_ADDR_EXP 149
85913: PUSH
85914: LD_INT 0
85916: ST_TO_ADDR
// sShovel := false ;
85917: LD_ADDR_EXP 150
85921: PUSH
85922: LD_INT 0
85924: ST_TO_ADDR
// sSheik := false ;
85925: LD_ADDR_EXP 151
85929: PUSH
85930: LD_INT 0
85932: ST_TO_ADDR
// sEarthquake := false ;
85933: LD_ADDR_EXP 153
85937: PUSH
85938: LD_INT 0
85940: ST_TO_ADDR
// sAI := false ;
85941: LD_ADDR_EXP 154
85945: PUSH
85946: LD_INT 0
85948: ST_TO_ADDR
// sCargo := false ;
85949: LD_ADDR_EXP 157
85953: PUSH
85954: LD_INT 0
85956: ST_TO_ADDR
// sDLaser := false ;
85957: LD_ADDR_EXP 158
85961: PUSH
85962: LD_INT 0
85964: ST_TO_ADDR
// sExchange := false ;
85965: LD_ADDR_EXP 159
85969: PUSH
85970: LD_INT 0
85972: ST_TO_ADDR
// sFac := false ;
85973: LD_ADDR_EXP 160
85977: PUSH
85978: LD_INT 0
85980: ST_TO_ADDR
// sPower := false ;
85981: LD_ADDR_EXP 161
85985: PUSH
85986: LD_INT 0
85988: ST_TO_ADDR
// sRandom := false ;
85989: LD_ADDR_EXP 162
85993: PUSH
85994: LD_INT 0
85996: ST_TO_ADDR
// sShield := false ;
85997: LD_ADDR_EXP 163
86001: PUSH
86002: LD_INT 0
86004: ST_TO_ADDR
// sTime := false ;
86005: LD_ADDR_EXP 164
86009: PUSH
86010: LD_INT 0
86012: ST_TO_ADDR
// sTools := false ;
86013: LD_ADDR_EXP 165
86017: PUSH
86018: LD_INT 0
86020: ST_TO_ADDR
// sSold := false ;
86021: LD_ADDR_EXP 130
86025: PUSH
86026: LD_INT 0
86028: ST_TO_ADDR
// sDiff := false ;
86029: LD_ADDR_EXP 131
86033: PUSH
86034: LD_INT 0
86036: ST_TO_ADDR
// sFog := false ;
86037: LD_ADDR_EXP 134
86041: PUSH
86042: LD_INT 0
86044: ST_TO_ADDR
// sReset := false ;
86045: LD_ADDR_EXP 135
86049: PUSH
86050: LD_INT 0
86052: ST_TO_ADDR
// sSun := false ;
86053: LD_ADDR_EXP 136
86057: PUSH
86058: LD_INT 0
86060: ST_TO_ADDR
// sTiger := false ;
86061: LD_ADDR_EXP 132
86065: PUSH
86066: LD_INT 0
86068: ST_TO_ADDR
// sBomb := false ;
86069: LD_ADDR_EXP 133
86073: PUSH
86074: LD_INT 0
86076: ST_TO_ADDR
// sWound := false ;
86077: LD_ADDR_EXP 141
86081: PUSH
86082: LD_INT 0
86084: ST_TO_ADDR
// sBetray := false ;
86085: LD_ADDR_EXP 145
86089: PUSH
86090: LD_INT 0
86092: ST_TO_ADDR
// sContamin := false ;
86093: LD_ADDR_EXP 146
86097: PUSH
86098: LD_INT 0
86100: ST_TO_ADDR
// sOil := false ;
86101: LD_ADDR_EXP 148
86105: PUSH
86106: LD_INT 0
86108: ST_TO_ADDR
// sStu := false ;
86109: LD_ADDR_EXP 152
86113: PUSH
86114: LD_INT 0
86116: ST_TO_ADDR
// sBazooka := false ;
86117: LD_ADDR_EXP 155
86121: PUSH
86122: LD_INT 0
86124: ST_TO_ADDR
// sMortar := false ;
86125: LD_ADDR_EXP 156
86129: PUSH
86130: LD_INT 0
86132: ST_TO_ADDR
// sRanger := false ;
86133: LD_ADDR_EXP 166
86137: PUSH
86138: LD_INT 0
86140: ST_TO_ADDR
// sComputer := false ;
86141: LD_ADDR_EXP 167
86145: PUSH
86146: LD_INT 0
86148: ST_TO_ADDR
// s30 := false ;
86149: LD_ADDR_EXP 168
86153: PUSH
86154: LD_INT 0
86156: ST_TO_ADDR
// s60 := false ;
86157: LD_ADDR_EXP 169
86161: PUSH
86162: LD_INT 0
86164: ST_TO_ADDR
// end ;
86165: LD_VAR 0 1
86169: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
86170: LD_INT 0
86172: PPUSH
86173: PPUSH
86174: PPUSH
86175: PPUSH
86176: PPUSH
86177: PPUSH
86178: PPUSH
// result := [ ] ;
86179: LD_ADDR_VAR 0 2
86183: PUSH
86184: EMPTY
86185: ST_TO_ADDR
// if campaign_id = 1 then
86186: LD_OWVAR 69
86190: PUSH
86191: LD_INT 1
86193: EQUAL
86194: IFFALSE 89360
// begin case mission_number of 1 :
86196: LD_OWVAR 70
86200: PUSH
86201: LD_INT 1
86203: DOUBLE
86204: EQUAL
86205: IFTRUE 86209
86207: GO 86285
86209: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
86210: LD_ADDR_VAR 0 2
86214: PUSH
86215: LD_INT 2
86217: PUSH
86218: LD_INT 4
86220: PUSH
86221: LD_INT 11
86223: PUSH
86224: LD_INT 12
86226: PUSH
86227: LD_INT 15
86229: PUSH
86230: LD_INT 16
86232: PUSH
86233: LD_INT 22
86235: PUSH
86236: LD_INT 23
86238: PUSH
86239: LD_INT 26
86241: PUSH
86242: EMPTY
86243: LIST
86244: LIST
86245: LIST
86246: LIST
86247: LIST
86248: LIST
86249: LIST
86250: LIST
86251: LIST
86252: PUSH
86253: LD_INT 101
86255: PUSH
86256: LD_INT 102
86258: PUSH
86259: LD_INT 106
86261: PUSH
86262: LD_INT 116
86264: PUSH
86265: LD_INT 117
86267: PUSH
86268: LD_INT 118
86270: PUSH
86271: EMPTY
86272: LIST
86273: LIST
86274: LIST
86275: LIST
86276: LIST
86277: LIST
86278: PUSH
86279: EMPTY
86280: LIST
86281: LIST
86282: ST_TO_ADDR
86283: GO 89358
86285: LD_INT 2
86287: DOUBLE
86288: EQUAL
86289: IFTRUE 86293
86291: GO 86377
86293: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
86294: LD_ADDR_VAR 0 2
86298: PUSH
86299: LD_INT 2
86301: PUSH
86302: LD_INT 4
86304: PUSH
86305: LD_INT 11
86307: PUSH
86308: LD_INT 12
86310: PUSH
86311: LD_INT 15
86313: PUSH
86314: LD_INT 16
86316: PUSH
86317: LD_INT 22
86319: PUSH
86320: LD_INT 23
86322: PUSH
86323: LD_INT 26
86325: PUSH
86326: EMPTY
86327: LIST
86328: LIST
86329: LIST
86330: LIST
86331: LIST
86332: LIST
86333: LIST
86334: LIST
86335: LIST
86336: PUSH
86337: LD_INT 101
86339: PUSH
86340: LD_INT 102
86342: PUSH
86343: LD_INT 105
86345: PUSH
86346: LD_INT 106
86348: PUSH
86349: LD_INT 108
86351: PUSH
86352: LD_INT 116
86354: PUSH
86355: LD_INT 117
86357: PUSH
86358: LD_INT 118
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: LIST
86365: LIST
86366: LIST
86367: LIST
86368: LIST
86369: LIST
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: ST_TO_ADDR
86375: GO 89358
86377: LD_INT 3
86379: DOUBLE
86380: EQUAL
86381: IFTRUE 86385
86383: GO 86473
86385: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
86386: LD_ADDR_VAR 0 2
86390: PUSH
86391: LD_INT 2
86393: PUSH
86394: LD_INT 4
86396: PUSH
86397: LD_INT 5
86399: PUSH
86400: LD_INT 11
86402: PUSH
86403: LD_INT 12
86405: PUSH
86406: LD_INT 15
86408: PUSH
86409: LD_INT 16
86411: PUSH
86412: LD_INT 22
86414: PUSH
86415: LD_INT 26
86417: PUSH
86418: LD_INT 36
86420: PUSH
86421: EMPTY
86422: LIST
86423: LIST
86424: LIST
86425: LIST
86426: LIST
86427: LIST
86428: LIST
86429: LIST
86430: LIST
86431: LIST
86432: PUSH
86433: LD_INT 101
86435: PUSH
86436: LD_INT 102
86438: PUSH
86439: LD_INT 105
86441: PUSH
86442: LD_INT 106
86444: PUSH
86445: LD_INT 108
86447: PUSH
86448: LD_INT 116
86450: PUSH
86451: LD_INT 117
86453: PUSH
86454: LD_INT 118
86456: PUSH
86457: EMPTY
86458: LIST
86459: LIST
86460: LIST
86461: LIST
86462: LIST
86463: LIST
86464: LIST
86465: LIST
86466: PUSH
86467: EMPTY
86468: LIST
86469: LIST
86470: ST_TO_ADDR
86471: GO 89358
86473: LD_INT 4
86475: DOUBLE
86476: EQUAL
86477: IFTRUE 86481
86479: GO 86577
86481: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
86482: LD_ADDR_VAR 0 2
86486: PUSH
86487: LD_INT 2
86489: PUSH
86490: LD_INT 4
86492: PUSH
86493: LD_INT 5
86495: PUSH
86496: LD_INT 8
86498: PUSH
86499: LD_INT 11
86501: PUSH
86502: LD_INT 12
86504: PUSH
86505: LD_INT 15
86507: PUSH
86508: LD_INT 16
86510: PUSH
86511: LD_INT 22
86513: PUSH
86514: LD_INT 23
86516: PUSH
86517: LD_INT 26
86519: PUSH
86520: LD_INT 36
86522: PUSH
86523: EMPTY
86524: LIST
86525: LIST
86526: LIST
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: LIST
86532: LIST
86533: LIST
86534: LIST
86535: LIST
86536: PUSH
86537: LD_INT 101
86539: PUSH
86540: LD_INT 102
86542: PUSH
86543: LD_INT 105
86545: PUSH
86546: LD_INT 106
86548: PUSH
86549: LD_INT 108
86551: PUSH
86552: LD_INT 116
86554: PUSH
86555: LD_INT 117
86557: PUSH
86558: LD_INT 118
86560: PUSH
86561: EMPTY
86562: LIST
86563: LIST
86564: LIST
86565: LIST
86566: LIST
86567: LIST
86568: LIST
86569: LIST
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: ST_TO_ADDR
86575: GO 89358
86577: LD_INT 5
86579: DOUBLE
86580: EQUAL
86581: IFTRUE 86585
86583: GO 86697
86585: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
86586: LD_ADDR_VAR 0 2
86590: PUSH
86591: LD_INT 2
86593: PUSH
86594: LD_INT 4
86596: PUSH
86597: LD_INT 5
86599: PUSH
86600: LD_INT 6
86602: PUSH
86603: LD_INT 8
86605: PUSH
86606: LD_INT 11
86608: PUSH
86609: LD_INT 12
86611: PUSH
86612: LD_INT 15
86614: PUSH
86615: LD_INT 16
86617: PUSH
86618: LD_INT 22
86620: PUSH
86621: LD_INT 23
86623: PUSH
86624: LD_INT 25
86626: PUSH
86627: LD_INT 26
86629: PUSH
86630: LD_INT 36
86632: PUSH
86633: EMPTY
86634: LIST
86635: LIST
86636: LIST
86637: LIST
86638: LIST
86639: LIST
86640: LIST
86641: LIST
86642: LIST
86643: LIST
86644: LIST
86645: LIST
86646: LIST
86647: LIST
86648: PUSH
86649: LD_INT 101
86651: PUSH
86652: LD_INT 102
86654: PUSH
86655: LD_INT 105
86657: PUSH
86658: LD_INT 106
86660: PUSH
86661: LD_INT 108
86663: PUSH
86664: LD_INT 109
86666: PUSH
86667: LD_INT 112
86669: PUSH
86670: LD_INT 116
86672: PUSH
86673: LD_INT 117
86675: PUSH
86676: LD_INT 118
86678: PUSH
86679: EMPTY
86680: LIST
86681: LIST
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: LIST
86690: PUSH
86691: EMPTY
86692: LIST
86693: LIST
86694: ST_TO_ADDR
86695: GO 89358
86697: LD_INT 6
86699: DOUBLE
86700: EQUAL
86701: IFTRUE 86705
86703: GO 86837
86705: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
86706: LD_ADDR_VAR 0 2
86710: PUSH
86711: LD_INT 2
86713: PUSH
86714: LD_INT 4
86716: PUSH
86717: LD_INT 5
86719: PUSH
86720: LD_INT 6
86722: PUSH
86723: LD_INT 8
86725: PUSH
86726: LD_INT 11
86728: PUSH
86729: LD_INT 12
86731: PUSH
86732: LD_INT 15
86734: PUSH
86735: LD_INT 16
86737: PUSH
86738: LD_INT 20
86740: PUSH
86741: LD_INT 21
86743: PUSH
86744: LD_INT 22
86746: PUSH
86747: LD_INT 23
86749: PUSH
86750: LD_INT 25
86752: PUSH
86753: LD_INT 26
86755: PUSH
86756: LD_INT 30
86758: PUSH
86759: LD_INT 31
86761: PUSH
86762: LD_INT 32
86764: PUSH
86765: LD_INT 36
86767: PUSH
86768: EMPTY
86769: LIST
86770: LIST
86771: LIST
86772: LIST
86773: LIST
86774: LIST
86775: LIST
86776: LIST
86777: LIST
86778: LIST
86779: LIST
86780: LIST
86781: LIST
86782: LIST
86783: LIST
86784: LIST
86785: LIST
86786: LIST
86787: LIST
86788: PUSH
86789: LD_INT 101
86791: PUSH
86792: LD_INT 102
86794: PUSH
86795: LD_INT 105
86797: PUSH
86798: LD_INT 106
86800: PUSH
86801: LD_INT 108
86803: PUSH
86804: LD_INT 109
86806: PUSH
86807: LD_INT 112
86809: PUSH
86810: LD_INT 116
86812: PUSH
86813: LD_INT 117
86815: PUSH
86816: LD_INT 118
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: LIST
86823: LIST
86824: LIST
86825: LIST
86826: LIST
86827: LIST
86828: LIST
86829: LIST
86830: PUSH
86831: EMPTY
86832: LIST
86833: LIST
86834: ST_TO_ADDR
86835: GO 89358
86837: LD_INT 7
86839: DOUBLE
86840: EQUAL
86841: IFTRUE 86845
86843: GO 86957
86845: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
86846: LD_ADDR_VAR 0 2
86850: PUSH
86851: LD_INT 2
86853: PUSH
86854: LD_INT 4
86856: PUSH
86857: LD_INT 5
86859: PUSH
86860: LD_INT 7
86862: PUSH
86863: LD_INT 11
86865: PUSH
86866: LD_INT 12
86868: PUSH
86869: LD_INT 15
86871: PUSH
86872: LD_INT 16
86874: PUSH
86875: LD_INT 20
86877: PUSH
86878: LD_INT 21
86880: PUSH
86881: LD_INT 22
86883: PUSH
86884: LD_INT 23
86886: PUSH
86887: LD_INT 25
86889: PUSH
86890: LD_INT 26
86892: PUSH
86893: EMPTY
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: LIST
86903: LIST
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: PUSH
86909: LD_INT 101
86911: PUSH
86912: LD_INT 102
86914: PUSH
86915: LD_INT 103
86917: PUSH
86918: LD_INT 105
86920: PUSH
86921: LD_INT 106
86923: PUSH
86924: LD_INT 108
86926: PUSH
86927: LD_INT 112
86929: PUSH
86930: LD_INT 116
86932: PUSH
86933: LD_INT 117
86935: PUSH
86936: LD_INT 118
86938: PUSH
86939: EMPTY
86940: LIST
86941: LIST
86942: LIST
86943: LIST
86944: LIST
86945: LIST
86946: LIST
86947: LIST
86948: LIST
86949: LIST
86950: PUSH
86951: EMPTY
86952: LIST
86953: LIST
86954: ST_TO_ADDR
86955: GO 89358
86957: LD_INT 8
86959: DOUBLE
86960: EQUAL
86961: IFTRUE 86965
86963: GO 87105
86965: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
86966: LD_ADDR_VAR 0 2
86970: PUSH
86971: LD_INT 2
86973: PUSH
86974: LD_INT 4
86976: PUSH
86977: LD_INT 5
86979: PUSH
86980: LD_INT 6
86982: PUSH
86983: LD_INT 7
86985: PUSH
86986: LD_INT 8
86988: PUSH
86989: LD_INT 11
86991: PUSH
86992: LD_INT 12
86994: PUSH
86995: LD_INT 15
86997: PUSH
86998: LD_INT 16
87000: PUSH
87001: LD_INT 20
87003: PUSH
87004: LD_INT 21
87006: PUSH
87007: LD_INT 22
87009: PUSH
87010: LD_INT 23
87012: PUSH
87013: LD_INT 25
87015: PUSH
87016: LD_INT 26
87018: PUSH
87019: LD_INT 30
87021: PUSH
87022: LD_INT 31
87024: PUSH
87025: LD_INT 32
87027: PUSH
87028: LD_INT 36
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: LIST
87037: LIST
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: PUSH
87053: LD_INT 101
87055: PUSH
87056: LD_INT 102
87058: PUSH
87059: LD_INT 103
87061: PUSH
87062: LD_INT 105
87064: PUSH
87065: LD_INT 106
87067: PUSH
87068: LD_INT 108
87070: PUSH
87071: LD_INT 109
87073: PUSH
87074: LD_INT 112
87076: PUSH
87077: LD_INT 116
87079: PUSH
87080: LD_INT 117
87082: PUSH
87083: LD_INT 118
87085: PUSH
87086: EMPTY
87087: LIST
87088: LIST
87089: LIST
87090: LIST
87091: LIST
87092: LIST
87093: LIST
87094: LIST
87095: LIST
87096: LIST
87097: LIST
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: ST_TO_ADDR
87103: GO 89358
87105: LD_INT 9
87107: DOUBLE
87108: EQUAL
87109: IFTRUE 87113
87111: GO 87261
87113: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
87114: LD_ADDR_VAR 0 2
87118: PUSH
87119: LD_INT 2
87121: PUSH
87122: LD_INT 4
87124: PUSH
87125: LD_INT 5
87127: PUSH
87128: LD_INT 6
87130: PUSH
87131: LD_INT 7
87133: PUSH
87134: LD_INT 8
87136: PUSH
87137: LD_INT 11
87139: PUSH
87140: LD_INT 12
87142: PUSH
87143: LD_INT 15
87145: PUSH
87146: LD_INT 16
87148: PUSH
87149: LD_INT 20
87151: PUSH
87152: LD_INT 21
87154: PUSH
87155: LD_INT 22
87157: PUSH
87158: LD_INT 23
87160: PUSH
87161: LD_INT 25
87163: PUSH
87164: LD_INT 26
87166: PUSH
87167: LD_INT 28
87169: PUSH
87170: LD_INT 30
87172: PUSH
87173: LD_INT 31
87175: PUSH
87176: LD_INT 32
87178: PUSH
87179: LD_INT 36
87181: PUSH
87182: EMPTY
87183: LIST
87184: LIST
87185: LIST
87186: LIST
87187: LIST
87188: LIST
87189: LIST
87190: LIST
87191: LIST
87192: LIST
87193: LIST
87194: LIST
87195: LIST
87196: LIST
87197: LIST
87198: LIST
87199: LIST
87200: LIST
87201: LIST
87202: LIST
87203: LIST
87204: PUSH
87205: LD_INT 101
87207: PUSH
87208: LD_INT 102
87210: PUSH
87211: LD_INT 103
87213: PUSH
87214: LD_INT 105
87216: PUSH
87217: LD_INT 106
87219: PUSH
87220: LD_INT 108
87222: PUSH
87223: LD_INT 109
87225: PUSH
87226: LD_INT 112
87228: PUSH
87229: LD_INT 114
87231: PUSH
87232: LD_INT 116
87234: PUSH
87235: LD_INT 117
87237: PUSH
87238: LD_INT 118
87240: PUSH
87241: EMPTY
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: PUSH
87255: EMPTY
87256: LIST
87257: LIST
87258: ST_TO_ADDR
87259: GO 89358
87261: LD_INT 10
87263: DOUBLE
87264: EQUAL
87265: IFTRUE 87269
87267: GO 87465
87269: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
87270: LD_ADDR_VAR 0 2
87274: PUSH
87275: LD_INT 2
87277: PUSH
87278: LD_INT 4
87280: PUSH
87281: LD_INT 5
87283: PUSH
87284: LD_INT 6
87286: PUSH
87287: LD_INT 7
87289: PUSH
87290: LD_INT 8
87292: PUSH
87293: LD_INT 9
87295: PUSH
87296: LD_INT 10
87298: PUSH
87299: LD_INT 11
87301: PUSH
87302: LD_INT 12
87304: PUSH
87305: LD_INT 13
87307: PUSH
87308: LD_INT 14
87310: PUSH
87311: LD_INT 15
87313: PUSH
87314: LD_INT 16
87316: PUSH
87317: LD_INT 17
87319: PUSH
87320: LD_INT 18
87322: PUSH
87323: LD_INT 19
87325: PUSH
87326: LD_INT 20
87328: PUSH
87329: LD_INT 21
87331: PUSH
87332: LD_INT 22
87334: PUSH
87335: LD_INT 23
87337: PUSH
87338: LD_INT 24
87340: PUSH
87341: LD_INT 25
87343: PUSH
87344: LD_INT 26
87346: PUSH
87347: LD_INT 28
87349: PUSH
87350: LD_INT 30
87352: PUSH
87353: LD_INT 31
87355: PUSH
87356: LD_INT 32
87358: PUSH
87359: LD_INT 36
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: LIST
87366: LIST
87367: LIST
87368: LIST
87369: LIST
87370: LIST
87371: LIST
87372: LIST
87373: LIST
87374: LIST
87375: LIST
87376: LIST
87377: LIST
87378: LIST
87379: LIST
87380: LIST
87381: LIST
87382: LIST
87383: LIST
87384: LIST
87385: LIST
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: PUSH
87393: LD_INT 101
87395: PUSH
87396: LD_INT 102
87398: PUSH
87399: LD_INT 103
87401: PUSH
87402: LD_INT 104
87404: PUSH
87405: LD_INT 105
87407: PUSH
87408: LD_INT 106
87410: PUSH
87411: LD_INT 107
87413: PUSH
87414: LD_INT 108
87416: PUSH
87417: LD_INT 109
87419: PUSH
87420: LD_INT 110
87422: PUSH
87423: LD_INT 111
87425: PUSH
87426: LD_INT 112
87428: PUSH
87429: LD_INT 114
87431: PUSH
87432: LD_INT 116
87434: PUSH
87435: LD_INT 117
87437: PUSH
87438: LD_INT 118
87440: PUSH
87441: EMPTY
87442: LIST
87443: LIST
87444: LIST
87445: LIST
87446: LIST
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: PUSH
87459: EMPTY
87460: LIST
87461: LIST
87462: ST_TO_ADDR
87463: GO 89358
87465: LD_INT 11
87467: DOUBLE
87468: EQUAL
87469: IFTRUE 87473
87471: GO 87677
87473: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
87474: LD_ADDR_VAR 0 2
87478: PUSH
87479: LD_INT 2
87481: PUSH
87482: LD_INT 3
87484: PUSH
87485: LD_INT 4
87487: PUSH
87488: LD_INT 5
87490: PUSH
87491: LD_INT 6
87493: PUSH
87494: LD_INT 7
87496: PUSH
87497: LD_INT 8
87499: PUSH
87500: LD_INT 9
87502: PUSH
87503: LD_INT 10
87505: PUSH
87506: LD_INT 11
87508: PUSH
87509: LD_INT 12
87511: PUSH
87512: LD_INT 13
87514: PUSH
87515: LD_INT 14
87517: PUSH
87518: LD_INT 15
87520: PUSH
87521: LD_INT 16
87523: PUSH
87524: LD_INT 17
87526: PUSH
87527: LD_INT 18
87529: PUSH
87530: LD_INT 19
87532: PUSH
87533: LD_INT 20
87535: PUSH
87536: LD_INT 21
87538: PUSH
87539: LD_INT 22
87541: PUSH
87542: LD_INT 23
87544: PUSH
87545: LD_INT 24
87547: PUSH
87548: LD_INT 25
87550: PUSH
87551: LD_INT 26
87553: PUSH
87554: LD_INT 28
87556: PUSH
87557: LD_INT 30
87559: PUSH
87560: LD_INT 31
87562: PUSH
87563: LD_INT 32
87565: PUSH
87566: LD_INT 34
87568: PUSH
87569: LD_INT 36
87571: PUSH
87572: EMPTY
87573: LIST
87574: LIST
87575: LIST
87576: LIST
87577: LIST
87578: LIST
87579: LIST
87580: LIST
87581: LIST
87582: LIST
87583: LIST
87584: LIST
87585: LIST
87586: LIST
87587: LIST
87588: LIST
87589: LIST
87590: LIST
87591: LIST
87592: LIST
87593: LIST
87594: LIST
87595: LIST
87596: LIST
87597: LIST
87598: LIST
87599: LIST
87600: LIST
87601: LIST
87602: LIST
87603: LIST
87604: PUSH
87605: LD_INT 101
87607: PUSH
87608: LD_INT 102
87610: PUSH
87611: LD_INT 103
87613: PUSH
87614: LD_INT 104
87616: PUSH
87617: LD_INT 105
87619: PUSH
87620: LD_INT 106
87622: PUSH
87623: LD_INT 107
87625: PUSH
87626: LD_INT 108
87628: PUSH
87629: LD_INT 109
87631: PUSH
87632: LD_INT 110
87634: PUSH
87635: LD_INT 111
87637: PUSH
87638: LD_INT 112
87640: PUSH
87641: LD_INT 114
87643: PUSH
87644: LD_INT 116
87646: PUSH
87647: LD_INT 117
87649: PUSH
87650: LD_INT 118
87652: PUSH
87653: EMPTY
87654: LIST
87655: LIST
87656: LIST
87657: LIST
87658: LIST
87659: LIST
87660: LIST
87661: LIST
87662: LIST
87663: LIST
87664: LIST
87665: LIST
87666: LIST
87667: LIST
87668: LIST
87669: LIST
87670: PUSH
87671: EMPTY
87672: LIST
87673: LIST
87674: ST_TO_ADDR
87675: GO 89358
87677: LD_INT 12
87679: DOUBLE
87680: EQUAL
87681: IFTRUE 87685
87683: GO 87905
87685: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
87686: LD_ADDR_VAR 0 2
87690: PUSH
87691: LD_INT 1
87693: PUSH
87694: LD_INT 2
87696: PUSH
87697: LD_INT 3
87699: PUSH
87700: LD_INT 4
87702: PUSH
87703: LD_INT 5
87705: PUSH
87706: LD_INT 6
87708: PUSH
87709: LD_INT 7
87711: PUSH
87712: LD_INT 8
87714: PUSH
87715: LD_INT 9
87717: PUSH
87718: LD_INT 10
87720: PUSH
87721: LD_INT 11
87723: PUSH
87724: LD_INT 12
87726: PUSH
87727: LD_INT 13
87729: PUSH
87730: LD_INT 14
87732: PUSH
87733: LD_INT 15
87735: PUSH
87736: LD_INT 16
87738: PUSH
87739: LD_INT 17
87741: PUSH
87742: LD_INT 18
87744: PUSH
87745: LD_INT 19
87747: PUSH
87748: LD_INT 20
87750: PUSH
87751: LD_INT 21
87753: PUSH
87754: LD_INT 22
87756: PUSH
87757: LD_INT 23
87759: PUSH
87760: LD_INT 24
87762: PUSH
87763: LD_INT 25
87765: PUSH
87766: LD_INT 26
87768: PUSH
87769: LD_INT 27
87771: PUSH
87772: LD_INT 28
87774: PUSH
87775: LD_INT 30
87777: PUSH
87778: LD_INT 31
87780: PUSH
87781: LD_INT 32
87783: PUSH
87784: LD_INT 33
87786: PUSH
87787: LD_INT 34
87789: PUSH
87790: LD_INT 36
87792: PUSH
87793: EMPTY
87794: LIST
87795: LIST
87796: LIST
87797: LIST
87798: LIST
87799: LIST
87800: LIST
87801: LIST
87802: LIST
87803: LIST
87804: LIST
87805: LIST
87806: LIST
87807: LIST
87808: LIST
87809: LIST
87810: LIST
87811: LIST
87812: LIST
87813: LIST
87814: LIST
87815: LIST
87816: LIST
87817: LIST
87818: LIST
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: PUSH
87829: LD_INT 101
87831: PUSH
87832: LD_INT 102
87834: PUSH
87835: LD_INT 103
87837: PUSH
87838: LD_INT 104
87840: PUSH
87841: LD_INT 105
87843: PUSH
87844: LD_INT 106
87846: PUSH
87847: LD_INT 107
87849: PUSH
87850: LD_INT 108
87852: PUSH
87853: LD_INT 109
87855: PUSH
87856: LD_INT 110
87858: PUSH
87859: LD_INT 111
87861: PUSH
87862: LD_INT 112
87864: PUSH
87865: LD_INT 113
87867: PUSH
87868: LD_INT 114
87870: PUSH
87871: LD_INT 116
87873: PUSH
87874: LD_INT 117
87876: PUSH
87877: LD_INT 118
87879: PUSH
87880: EMPTY
87881: LIST
87882: LIST
87883: LIST
87884: LIST
87885: LIST
87886: LIST
87887: LIST
87888: LIST
87889: LIST
87890: LIST
87891: LIST
87892: LIST
87893: LIST
87894: LIST
87895: LIST
87896: LIST
87897: LIST
87898: PUSH
87899: EMPTY
87900: LIST
87901: LIST
87902: ST_TO_ADDR
87903: GO 89358
87905: LD_INT 13
87907: DOUBLE
87908: EQUAL
87909: IFTRUE 87913
87911: GO 88121
87913: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
87914: LD_ADDR_VAR 0 2
87918: PUSH
87919: LD_INT 1
87921: PUSH
87922: LD_INT 2
87924: PUSH
87925: LD_INT 3
87927: PUSH
87928: LD_INT 4
87930: PUSH
87931: LD_INT 5
87933: PUSH
87934: LD_INT 8
87936: PUSH
87937: LD_INT 9
87939: PUSH
87940: LD_INT 10
87942: PUSH
87943: LD_INT 11
87945: PUSH
87946: LD_INT 12
87948: PUSH
87949: LD_INT 14
87951: PUSH
87952: LD_INT 15
87954: PUSH
87955: LD_INT 16
87957: PUSH
87958: LD_INT 17
87960: PUSH
87961: LD_INT 18
87963: PUSH
87964: LD_INT 19
87966: PUSH
87967: LD_INT 20
87969: PUSH
87970: LD_INT 21
87972: PUSH
87973: LD_INT 22
87975: PUSH
87976: LD_INT 23
87978: PUSH
87979: LD_INT 24
87981: PUSH
87982: LD_INT 25
87984: PUSH
87985: LD_INT 26
87987: PUSH
87988: LD_INT 27
87990: PUSH
87991: LD_INT 28
87993: PUSH
87994: LD_INT 30
87996: PUSH
87997: LD_INT 31
87999: PUSH
88000: LD_INT 32
88002: PUSH
88003: LD_INT 33
88005: PUSH
88006: LD_INT 34
88008: PUSH
88009: LD_INT 36
88011: PUSH
88012: EMPTY
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: LIST
88028: LIST
88029: LIST
88030: LIST
88031: LIST
88032: LIST
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: PUSH
88045: LD_INT 101
88047: PUSH
88048: LD_INT 102
88050: PUSH
88051: LD_INT 103
88053: PUSH
88054: LD_INT 104
88056: PUSH
88057: LD_INT 105
88059: PUSH
88060: LD_INT 106
88062: PUSH
88063: LD_INT 107
88065: PUSH
88066: LD_INT 108
88068: PUSH
88069: LD_INT 109
88071: PUSH
88072: LD_INT 110
88074: PUSH
88075: LD_INT 111
88077: PUSH
88078: LD_INT 112
88080: PUSH
88081: LD_INT 113
88083: PUSH
88084: LD_INT 114
88086: PUSH
88087: LD_INT 116
88089: PUSH
88090: LD_INT 117
88092: PUSH
88093: LD_INT 118
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: LIST
88104: LIST
88105: LIST
88106: LIST
88107: LIST
88108: LIST
88109: LIST
88110: LIST
88111: LIST
88112: LIST
88113: LIST
88114: PUSH
88115: EMPTY
88116: LIST
88117: LIST
88118: ST_TO_ADDR
88119: GO 89358
88121: LD_INT 14
88123: DOUBLE
88124: EQUAL
88125: IFTRUE 88129
88127: GO 88353
88129: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
88130: LD_ADDR_VAR 0 2
88134: PUSH
88135: LD_INT 1
88137: PUSH
88138: LD_INT 2
88140: PUSH
88141: LD_INT 3
88143: PUSH
88144: LD_INT 4
88146: PUSH
88147: LD_INT 5
88149: PUSH
88150: LD_INT 6
88152: PUSH
88153: LD_INT 7
88155: PUSH
88156: LD_INT 8
88158: PUSH
88159: LD_INT 9
88161: PUSH
88162: LD_INT 10
88164: PUSH
88165: LD_INT 11
88167: PUSH
88168: LD_INT 12
88170: PUSH
88171: LD_INT 13
88173: PUSH
88174: LD_INT 14
88176: PUSH
88177: LD_INT 15
88179: PUSH
88180: LD_INT 16
88182: PUSH
88183: LD_INT 17
88185: PUSH
88186: LD_INT 18
88188: PUSH
88189: LD_INT 19
88191: PUSH
88192: LD_INT 20
88194: PUSH
88195: LD_INT 21
88197: PUSH
88198: LD_INT 22
88200: PUSH
88201: LD_INT 23
88203: PUSH
88204: LD_INT 24
88206: PUSH
88207: LD_INT 25
88209: PUSH
88210: LD_INT 26
88212: PUSH
88213: LD_INT 27
88215: PUSH
88216: LD_INT 28
88218: PUSH
88219: LD_INT 29
88221: PUSH
88222: LD_INT 30
88224: PUSH
88225: LD_INT 31
88227: PUSH
88228: LD_INT 32
88230: PUSH
88231: LD_INT 33
88233: PUSH
88234: LD_INT 34
88236: PUSH
88237: LD_INT 36
88239: PUSH
88240: EMPTY
88241: LIST
88242: LIST
88243: LIST
88244: LIST
88245: LIST
88246: LIST
88247: LIST
88248: LIST
88249: LIST
88250: LIST
88251: LIST
88252: LIST
88253: LIST
88254: LIST
88255: LIST
88256: LIST
88257: LIST
88258: LIST
88259: LIST
88260: LIST
88261: LIST
88262: LIST
88263: LIST
88264: LIST
88265: LIST
88266: LIST
88267: LIST
88268: LIST
88269: LIST
88270: LIST
88271: LIST
88272: LIST
88273: LIST
88274: LIST
88275: LIST
88276: PUSH
88277: LD_INT 101
88279: PUSH
88280: LD_INT 102
88282: PUSH
88283: LD_INT 103
88285: PUSH
88286: LD_INT 104
88288: PUSH
88289: LD_INT 105
88291: PUSH
88292: LD_INT 106
88294: PUSH
88295: LD_INT 107
88297: PUSH
88298: LD_INT 108
88300: PUSH
88301: LD_INT 109
88303: PUSH
88304: LD_INT 110
88306: PUSH
88307: LD_INT 111
88309: PUSH
88310: LD_INT 112
88312: PUSH
88313: LD_INT 113
88315: PUSH
88316: LD_INT 114
88318: PUSH
88319: LD_INT 116
88321: PUSH
88322: LD_INT 117
88324: PUSH
88325: LD_INT 118
88327: PUSH
88328: EMPTY
88329: LIST
88330: LIST
88331: LIST
88332: LIST
88333: LIST
88334: LIST
88335: LIST
88336: LIST
88337: LIST
88338: LIST
88339: LIST
88340: LIST
88341: LIST
88342: LIST
88343: LIST
88344: LIST
88345: LIST
88346: PUSH
88347: EMPTY
88348: LIST
88349: LIST
88350: ST_TO_ADDR
88351: GO 89358
88353: LD_INT 15
88355: DOUBLE
88356: EQUAL
88357: IFTRUE 88361
88359: GO 88585
88361: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
88362: LD_ADDR_VAR 0 2
88366: PUSH
88367: LD_INT 1
88369: PUSH
88370: LD_INT 2
88372: PUSH
88373: LD_INT 3
88375: PUSH
88376: LD_INT 4
88378: PUSH
88379: LD_INT 5
88381: PUSH
88382: LD_INT 6
88384: PUSH
88385: LD_INT 7
88387: PUSH
88388: LD_INT 8
88390: PUSH
88391: LD_INT 9
88393: PUSH
88394: LD_INT 10
88396: PUSH
88397: LD_INT 11
88399: PUSH
88400: LD_INT 12
88402: PUSH
88403: LD_INT 13
88405: PUSH
88406: LD_INT 14
88408: PUSH
88409: LD_INT 15
88411: PUSH
88412: LD_INT 16
88414: PUSH
88415: LD_INT 17
88417: PUSH
88418: LD_INT 18
88420: PUSH
88421: LD_INT 19
88423: PUSH
88424: LD_INT 20
88426: PUSH
88427: LD_INT 21
88429: PUSH
88430: LD_INT 22
88432: PUSH
88433: LD_INT 23
88435: PUSH
88436: LD_INT 24
88438: PUSH
88439: LD_INT 25
88441: PUSH
88442: LD_INT 26
88444: PUSH
88445: LD_INT 27
88447: PUSH
88448: LD_INT 28
88450: PUSH
88451: LD_INT 29
88453: PUSH
88454: LD_INT 30
88456: PUSH
88457: LD_INT 31
88459: PUSH
88460: LD_INT 32
88462: PUSH
88463: LD_INT 33
88465: PUSH
88466: LD_INT 34
88468: PUSH
88469: LD_INT 36
88471: PUSH
88472: EMPTY
88473: LIST
88474: LIST
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: LIST
88480: LIST
88481: LIST
88482: LIST
88483: LIST
88484: LIST
88485: LIST
88486: LIST
88487: LIST
88488: LIST
88489: LIST
88490: LIST
88491: LIST
88492: LIST
88493: LIST
88494: LIST
88495: LIST
88496: LIST
88497: LIST
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: LIST
88507: LIST
88508: PUSH
88509: LD_INT 101
88511: PUSH
88512: LD_INT 102
88514: PUSH
88515: LD_INT 103
88517: PUSH
88518: LD_INT 104
88520: PUSH
88521: LD_INT 105
88523: PUSH
88524: LD_INT 106
88526: PUSH
88527: LD_INT 107
88529: PUSH
88530: LD_INT 108
88532: PUSH
88533: LD_INT 109
88535: PUSH
88536: LD_INT 110
88538: PUSH
88539: LD_INT 111
88541: PUSH
88542: LD_INT 112
88544: PUSH
88545: LD_INT 113
88547: PUSH
88548: LD_INT 114
88550: PUSH
88551: LD_INT 116
88553: PUSH
88554: LD_INT 117
88556: PUSH
88557: LD_INT 118
88559: PUSH
88560: EMPTY
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: PUSH
88579: EMPTY
88580: LIST
88581: LIST
88582: ST_TO_ADDR
88583: GO 89358
88585: LD_INT 16
88587: DOUBLE
88588: EQUAL
88589: IFTRUE 88593
88591: GO 88729
88593: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
88594: LD_ADDR_VAR 0 2
88598: PUSH
88599: LD_INT 2
88601: PUSH
88602: LD_INT 4
88604: PUSH
88605: LD_INT 5
88607: PUSH
88608: LD_INT 7
88610: PUSH
88611: LD_INT 11
88613: PUSH
88614: LD_INT 12
88616: PUSH
88617: LD_INT 15
88619: PUSH
88620: LD_INT 16
88622: PUSH
88623: LD_INT 20
88625: PUSH
88626: LD_INT 21
88628: PUSH
88629: LD_INT 22
88631: PUSH
88632: LD_INT 23
88634: PUSH
88635: LD_INT 25
88637: PUSH
88638: LD_INT 26
88640: PUSH
88641: LD_INT 30
88643: PUSH
88644: LD_INT 31
88646: PUSH
88647: LD_INT 32
88649: PUSH
88650: LD_INT 33
88652: PUSH
88653: LD_INT 34
88655: PUSH
88656: EMPTY
88657: LIST
88658: LIST
88659: LIST
88660: LIST
88661: LIST
88662: LIST
88663: LIST
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: LIST
88672: LIST
88673: LIST
88674: LIST
88675: LIST
88676: PUSH
88677: LD_INT 101
88679: PUSH
88680: LD_INT 102
88682: PUSH
88683: LD_INT 103
88685: PUSH
88686: LD_INT 106
88688: PUSH
88689: LD_INT 108
88691: PUSH
88692: LD_INT 112
88694: PUSH
88695: LD_INT 113
88697: PUSH
88698: LD_INT 114
88700: PUSH
88701: LD_INT 116
88703: PUSH
88704: LD_INT 117
88706: PUSH
88707: LD_INT 118
88709: PUSH
88710: EMPTY
88711: LIST
88712: LIST
88713: LIST
88714: LIST
88715: LIST
88716: LIST
88717: LIST
88718: LIST
88719: LIST
88720: LIST
88721: LIST
88722: PUSH
88723: EMPTY
88724: LIST
88725: LIST
88726: ST_TO_ADDR
88727: GO 89358
88729: LD_INT 17
88731: DOUBLE
88732: EQUAL
88733: IFTRUE 88737
88735: GO 88961
88737: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
88738: LD_ADDR_VAR 0 2
88742: PUSH
88743: LD_INT 1
88745: PUSH
88746: LD_INT 2
88748: PUSH
88749: LD_INT 3
88751: PUSH
88752: LD_INT 4
88754: PUSH
88755: LD_INT 5
88757: PUSH
88758: LD_INT 6
88760: PUSH
88761: LD_INT 7
88763: PUSH
88764: LD_INT 8
88766: PUSH
88767: LD_INT 9
88769: PUSH
88770: LD_INT 10
88772: PUSH
88773: LD_INT 11
88775: PUSH
88776: LD_INT 12
88778: PUSH
88779: LD_INT 13
88781: PUSH
88782: LD_INT 14
88784: PUSH
88785: LD_INT 15
88787: PUSH
88788: LD_INT 16
88790: PUSH
88791: LD_INT 17
88793: PUSH
88794: LD_INT 18
88796: PUSH
88797: LD_INT 19
88799: PUSH
88800: LD_INT 20
88802: PUSH
88803: LD_INT 21
88805: PUSH
88806: LD_INT 22
88808: PUSH
88809: LD_INT 23
88811: PUSH
88812: LD_INT 24
88814: PUSH
88815: LD_INT 25
88817: PUSH
88818: LD_INT 26
88820: PUSH
88821: LD_INT 27
88823: PUSH
88824: LD_INT 28
88826: PUSH
88827: LD_INT 29
88829: PUSH
88830: LD_INT 30
88832: PUSH
88833: LD_INT 31
88835: PUSH
88836: LD_INT 32
88838: PUSH
88839: LD_INT 33
88841: PUSH
88842: LD_INT 34
88844: PUSH
88845: LD_INT 36
88847: PUSH
88848: EMPTY
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: LIST
88861: LIST
88862: LIST
88863: LIST
88864: LIST
88865: LIST
88866: LIST
88867: LIST
88868: LIST
88869: LIST
88870: LIST
88871: LIST
88872: LIST
88873: LIST
88874: LIST
88875: LIST
88876: LIST
88877: LIST
88878: LIST
88879: LIST
88880: LIST
88881: LIST
88882: LIST
88883: LIST
88884: PUSH
88885: LD_INT 101
88887: PUSH
88888: LD_INT 102
88890: PUSH
88891: LD_INT 103
88893: PUSH
88894: LD_INT 104
88896: PUSH
88897: LD_INT 105
88899: PUSH
88900: LD_INT 106
88902: PUSH
88903: LD_INT 107
88905: PUSH
88906: LD_INT 108
88908: PUSH
88909: LD_INT 109
88911: PUSH
88912: LD_INT 110
88914: PUSH
88915: LD_INT 111
88917: PUSH
88918: LD_INT 112
88920: PUSH
88921: LD_INT 113
88923: PUSH
88924: LD_INT 114
88926: PUSH
88927: LD_INT 116
88929: PUSH
88930: LD_INT 117
88932: PUSH
88933: LD_INT 118
88935: PUSH
88936: EMPTY
88937: LIST
88938: LIST
88939: LIST
88940: LIST
88941: LIST
88942: LIST
88943: LIST
88944: LIST
88945: LIST
88946: LIST
88947: LIST
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: LIST
88954: PUSH
88955: EMPTY
88956: LIST
88957: LIST
88958: ST_TO_ADDR
88959: GO 89358
88961: LD_INT 18
88963: DOUBLE
88964: EQUAL
88965: IFTRUE 88969
88967: GO 89117
88969: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
88970: LD_ADDR_VAR 0 2
88974: PUSH
88975: LD_INT 2
88977: PUSH
88978: LD_INT 4
88980: PUSH
88981: LD_INT 5
88983: PUSH
88984: LD_INT 7
88986: PUSH
88987: LD_INT 11
88989: PUSH
88990: LD_INT 12
88992: PUSH
88993: LD_INT 15
88995: PUSH
88996: LD_INT 16
88998: PUSH
88999: LD_INT 20
89001: PUSH
89002: LD_INT 21
89004: PUSH
89005: LD_INT 22
89007: PUSH
89008: LD_INT 23
89010: PUSH
89011: LD_INT 25
89013: PUSH
89014: LD_INT 26
89016: PUSH
89017: LD_INT 30
89019: PUSH
89020: LD_INT 31
89022: PUSH
89023: LD_INT 32
89025: PUSH
89026: LD_INT 33
89028: PUSH
89029: LD_INT 34
89031: PUSH
89032: LD_INT 35
89034: PUSH
89035: LD_INT 36
89037: PUSH
89038: EMPTY
89039: LIST
89040: LIST
89041: LIST
89042: LIST
89043: LIST
89044: LIST
89045: LIST
89046: LIST
89047: LIST
89048: LIST
89049: LIST
89050: LIST
89051: LIST
89052: LIST
89053: LIST
89054: LIST
89055: LIST
89056: LIST
89057: LIST
89058: LIST
89059: LIST
89060: PUSH
89061: LD_INT 101
89063: PUSH
89064: LD_INT 102
89066: PUSH
89067: LD_INT 103
89069: PUSH
89070: LD_INT 106
89072: PUSH
89073: LD_INT 108
89075: PUSH
89076: LD_INT 112
89078: PUSH
89079: LD_INT 113
89081: PUSH
89082: LD_INT 114
89084: PUSH
89085: LD_INT 115
89087: PUSH
89088: LD_INT 116
89090: PUSH
89091: LD_INT 117
89093: PUSH
89094: LD_INT 118
89096: PUSH
89097: EMPTY
89098: LIST
89099: LIST
89100: LIST
89101: LIST
89102: LIST
89103: LIST
89104: LIST
89105: LIST
89106: LIST
89107: LIST
89108: LIST
89109: LIST
89110: PUSH
89111: EMPTY
89112: LIST
89113: LIST
89114: ST_TO_ADDR
89115: GO 89358
89117: LD_INT 19
89119: DOUBLE
89120: EQUAL
89121: IFTRUE 89125
89123: GO 89357
89125: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
89126: LD_ADDR_VAR 0 2
89130: PUSH
89131: LD_INT 1
89133: PUSH
89134: LD_INT 2
89136: PUSH
89137: LD_INT 3
89139: PUSH
89140: LD_INT 4
89142: PUSH
89143: LD_INT 5
89145: PUSH
89146: LD_INT 6
89148: PUSH
89149: LD_INT 7
89151: PUSH
89152: LD_INT 8
89154: PUSH
89155: LD_INT 9
89157: PUSH
89158: LD_INT 10
89160: PUSH
89161: LD_INT 11
89163: PUSH
89164: LD_INT 12
89166: PUSH
89167: LD_INT 13
89169: PUSH
89170: LD_INT 14
89172: PUSH
89173: LD_INT 15
89175: PUSH
89176: LD_INT 16
89178: PUSH
89179: LD_INT 17
89181: PUSH
89182: LD_INT 18
89184: PUSH
89185: LD_INT 19
89187: PUSH
89188: LD_INT 20
89190: PUSH
89191: LD_INT 21
89193: PUSH
89194: LD_INT 22
89196: PUSH
89197: LD_INT 23
89199: PUSH
89200: LD_INT 24
89202: PUSH
89203: LD_INT 25
89205: PUSH
89206: LD_INT 26
89208: PUSH
89209: LD_INT 27
89211: PUSH
89212: LD_INT 28
89214: PUSH
89215: LD_INT 29
89217: PUSH
89218: LD_INT 30
89220: PUSH
89221: LD_INT 31
89223: PUSH
89224: LD_INT 32
89226: PUSH
89227: LD_INT 33
89229: PUSH
89230: LD_INT 34
89232: PUSH
89233: LD_INT 35
89235: PUSH
89236: LD_INT 36
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: LIST
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: LIST
89263: LIST
89264: LIST
89265: LIST
89266: LIST
89267: LIST
89268: LIST
89269: LIST
89270: LIST
89271: LIST
89272: LIST
89273: LIST
89274: LIST
89275: LIST
89276: PUSH
89277: LD_INT 101
89279: PUSH
89280: LD_INT 102
89282: PUSH
89283: LD_INT 103
89285: PUSH
89286: LD_INT 104
89288: PUSH
89289: LD_INT 105
89291: PUSH
89292: LD_INT 106
89294: PUSH
89295: LD_INT 107
89297: PUSH
89298: LD_INT 108
89300: PUSH
89301: LD_INT 109
89303: PUSH
89304: LD_INT 110
89306: PUSH
89307: LD_INT 111
89309: PUSH
89310: LD_INT 112
89312: PUSH
89313: LD_INT 113
89315: PUSH
89316: LD_INT 114
89318: PUSH
89319: LD_INT 115
89321: PUSH
89322: LD_INT 116
89324: PUSH
89325: LD_INT 117
89327: PUSH
89328: LD_INT 118
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: LIST
89335: LIST
89336: LIST
89337: LIST
89338: LIST
89339: LIST
89340: LIST
89341: LIST
89342: LIST
89343: LIST
89344: LIST
89345: LIST
89346: LIST
89347: LIST
89348: LIST
89349: LIST
89350: PUSH
89351: EMPTY
89352: LIST
89353: LIST
89354: ST_TO_ADDR
89355: GO 89358
89357: POP
// end else
89358: GO 89589
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
89360: LD_ADDR_VAR 0 2
89364: PUSH
89365: LD_INT 1
89367: PUSH
89368: LD_INT 2
89370: PUSH
89371: LD_INT 3
89373: PUSH
89374: LD_INT 4
89376: PUSH
89377: LD_INT 5
89379: PUSH
89380: LD_INT 6
89382: PUSH
89383: LD_INT 7
89385: PUSH
89386: LD_INT 8
89388: PUSH
89389: LD_INT 9
89391: PUSH
89392: LD_INT 10
89394: PUSH
89395: LD_INT 11
89397: PUSH
89398: LD_INT 12
89400: PUSH
89401: LD_INT 13
89403: PUSH
89404: LD_INT 14
89406: PUSH
89407: LD_INT 15
89409: PUSH
89410: LD_INT 16
89412: PUSH
89413: LD_INT 17
89415: PUSH
89416: LD_INT 18
89418: PUSH
89419: LD_INT 19
89421: PUSH
89422: LD_INT 20
89424: PUSH
89425: LD_INT 21
89427: PUSH
89428: LD_INT 22
89430: PUSH
89431: LD_INT 23
89433: PUSH
89434: LD_INT 24
89436: PUSH
89437: LD_INT 25
89439: PUSH
89440: LD_INT 26
89442: PUSH
89443: LD_INT 27
89445: PUSH
89446: LD_INT 28
89448: PUSH
89449: LD_INT 29
89451: PUSH
89452: LD_INT 30
89454: PUSH
89455: LD_INT 31
89457: PUSH
89458: LD_INT 32
89460: PUSH
89461: LD_INT 33
89463: PUSH
89464: LD_INT 34
89466: PUSH
89467: LD_INT 35
89469: PUSH
89470: LD_INT 36
89472: PUSH
89473: EMPTY
89474: LIST
89475: LIST
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: LIST
89484: LIST
89485: LIST
89486: LIST
89487: LIST
89488: LIST
89489: LIST
89490: LIST
89491: LIST
89492: LIST
89493: LIST
89494: LIST
89495: LIST
89496: LIST
89497: LIST
89498: LIST
89499: LIST
89500: LIST
89501: LIST
89502: LIST
89503: LIST
89504: LIST
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: LIST
89510: PUSH
89511: LD_INT 101
89513: PUSH
89514: LD_INT 102
89516: PUSH
89517: LD_INT 103
89519: PUSH
89520: LD_INT 104
89522: PUSH
89523: LD_INT 105
89525: PUSH
89526: LD_INT 106
89528: PUSH
89529: LD_INT 107
89531: PUSH
89532: LD_INT 108
89534: PUSH
89535: LD_INT 109
89537: PUSH
89538: LD_INT 110
89540: PUSH
89541: LD_INT 111
89543: PUSH
89544: LD_INT 112
89546: PUSH
89547: LD_INT 113
89549: PUSH
89550: LD_INT 114
89552: PUSH
89553: LD_INT 115
89555: PUSH
89556: LD_INT 116
89558: PUSH
89559: LD_INT 117
89561: PUSH
89562: LD_INT 118
89564: PUSH
89565: EMPTY
89566: LIST
89567: LIST
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: LIST
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: ST_TO_ADDR
// if result then
89589: LD_VAR 0 2
89593: IFFALSE 90379
// begin normal :=  ;
89595: LD_ADDR_VAR 0 5
89599: PUSH
89600: LD_STRING 
89602: ST_TO_ADDR
// hardcore :=  ;
89603: LD_ADDR_VAR 0 6
89607: PUSH
89608: LD_STRING 
89610: ST_TO_ADDR
// active :=  ;
89611: LD_ADDR_VAR 0 7
89615: PUSH
89616: LD_STRING 
89618: ST_TO_ADDR
// for i = 1 to normalCounter do
89619: LD_ADDR_VAR 0 8
89623: PUSH
89624: DOUBLE
89625: LD_INT 1
89627: DEC
89628: ST_TO_ADDR
89629: LD_EXP 114
89633: PUSH
89634: FOR_TO
89635: IFFALSE 89736
// begin tmp := 0 ;
89637: LD_ADDR_VAR 0 3
89641: PUSH
89642: LD_STRING 0
89644: ST_TO_ADDR
// if result [ 1 ] then
89645: LD_VAR 0 2
89649: PUSH
89650: LD_INT 1
89652: ARRAY
89653: IFFALSE 89718
// if result [ 1 ] [ 1 ] = i then
89655: LD_VAR 0 2
89659: PUSH
89660: LD_INT 1
89662: ARRAY
89663: PUSH
89664: LD_INT 1
89666: ARRAY
89667: PUSH
89668: LD_VAR 0 8
89672: EQUAL
89673: IFFALSE 89718
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
89675: LD_ADDR_VAR 0 2
89679: PUSH
89680: LD_VAR 0 2
89684: PPUSH
89685: LD_INT 1
89687: PPUSH
89688: LD_VAR 0 2
89692: PUSH
89693: LD_INT 1
89695: ARRAY
89696: PPUSH
89697: LD_INT 1
89699: PPUSH
89700: CALL_OW 3
89704: PPUSH
89705: CALL_OW 1
89709: ST_TO_ADDR
// tmp := 1 ;
89710: LD_ADDR_VAR 0 3
89714: PUSH
89715: LD_STRING 1
89717: ST_TO_ADDR
// end ; normal := normal & tmp ;
89718: LD_ADDR_VAR 0 5
89722: PUSH
89723: LD_VAR 0 5
89727: PUSH
89728: LD_VAR 0 3
89732: STR
89733: ST_TO_ADDR
// end ;
89734: GO 89634
89736: POP
89737: POP
// for i = 1 to hardcoreCounter do
89738: LD_ADDR_VAR 0 8
89742: PUSH
89743: DOUBLE
89744: LD_INT 1
89746: DEC
89747: ST_TO_ADDR
89748: LD_EXP 115
89752: PUSH
89753: FOR_TO
89754: IFFALSE 89859
// begin tmp := 0 ;
89756: LD_ADDR_VAR 0 3
89760: PUSH
89761: LD_STRING 0
89763: ST_TO_ADDR
// if result [ 2 ] then
89764: LD_VAR 0 2
89768: PUSH
89769: LD_INT 2
89771: ARRAY
89772: IFFALSE 89841
// if result [ 2 ] [ 1 ] = 100 + i then
89774: LD_VAR 0 2
89778: PUSH
89779: LD_INT 2
89781: ARRAY
89782: PUSH
89783: LD_INT 1
89785: ARRAY
89786: PUSH
89787: LD_INT 100
89789: PUSH
89790: LD_VAR 0 8
89794: PLUS
89795: EQUAL
89796: IFFALSE 89841
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
89798: LD_ADDR_VAR 0 2
89802: PUSH
89803: LD_VAR 0 2
89807: PPUSH
89808: LD_INT 2
89810: PPUSH
89811: LD_VAR 0 2
89815: PUSH
89816: LD_INT 2
89818: ARRAY
89819: PPUSH
89820: LD_INT 1
89822: PPUSH
89823: CALL_OW 3
89827: PPUSH
89828: CALL_OW 1
89832: ST_TO_ADDR
// tmp := 1 ;
89833: LD_ADDR_VAR 0 3
89837: PUSH
89838: LD_STRING 1
89840: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
89841: LD_ADDR_VAR 0 6
89845: PUSH
89846: LD_VAR 0 6
89850: PUSH
89851: LD_VAR 0 3
89855: STR
89856: ST_TO_ADDR
// end ;
89857: GO 89753
89859: POP
89860: POP
// if isGameLoad then
89861: LD_VAR 0 1
89865: IFFALSE 90340
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
89867: LD_ADDR_VAR 0 4
89871: PUSH
89872: LD_EXP 118
89876: PUSH
89877: LD_EXP 117
89881: PUSH
89882: LD_EXP 119
89886: PUSH
89887: LD_EXP 116
89891: PUSH
89892: LD_EXP 120
89896: PUSH
89897: LD_EXP 121
89901: PUSH
89902: LD_EXP 122
89906: PUSH
89907: LD_EXP 123
89911: PUSH
89912: LD_EXP 124
89916: PUSH
89917: LD_EXP 125
89921: PUSH
89922: LD_EXP 126
89926: PUSH
89927: LD_EXP 127
89931: PUSH
89932: LD_EXP 128
89936: PUSH
89937: LD_EXP 129
89941: PUSH
89942: LD_EXP 137
89946: PUSH
89947: LD_EXP 138
89951: PUSH
89952: LD_EXP 139
89956: PUSH
89957: LD_EXP 140
89961: PUSH
89962: LD_EXP 142
89966: PUSH
89967: LD_EXP 143
89971: PUSH
89972: LD_EXP 144
89976: PUSH
89977: LD_EXP 147
89981: PUSH
89982: LD_EXP 149
89986: PUSH
89987: LD_EXP 150
89991: PUSH
89992: LD_EXP 151
89996: PUSH
89997: LD_EXP 153
90001: PUSH
90002: LD_EXP 154
90006: PUSH
90007: LD_EXP 157
90011: PUSH
90012: LD_EXP 158
90016: PUSH
90017: LD_EXP 159
90021: PUSH
90022: LD_EXP 160
90026: PUSH
90027: LD_EXP 161
90031: PUSH
90032: LD_EXP 162
90036: PUSH
90037: LD_EXP 163
90041: PUSH
90042: LD_EXP 164
90046: PUSH
90047: LD_EXP 165
90051: PUSH
90052: LD_EXP 130
90056: PUSH
90057: LD_EXP 131
90061: PUSH
90062: LD_EXP 134
90066: PUSH
90067: LD_EXP 135
90071: PUSH
90072: LD_EXP 136
90076: PUSH
90077: LD_EXP 132
90081: PUSH
90082: LD_EXP 133
90086: PUSH
90087: LD_EXP 141
90091: PUSH
90092: LD_EXP 145
90096: PUSH
90097: LD_EXP 146
90101: PUSH
90102: LD_EXP 148
90106: PUSH
90107: LD_EXP 152
90111: PUSH
90112: LD_EXP 155
90116: PUSH
90117: LD_EXP 156
90121: PUSH
90122: LD_EXP 166
90126: PUSH
90127: LD_EXP 167
90131: PUSH
90132: LD_EXP 168
90136: PUSH
90137: LD_EXP 169
90141: PUSH
90142: EMPTY
90143: LIST
90144: LIST
90145: LIST
90146: LIST
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: LIST
90154: LIST
90155: LIST
90156: LIST
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: LIST
90166: LIST
90167: LIST
90168: LIST
90169: LIST
90170: LIST
90171: LIST
90172: LIST
90173: LIST
90174: LIST
90175: LIST
90176: LIST
90177: LIST
90178: LIST
90179: LIST
90180: LIST
90181: LIST
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: LIST
90192: LIST
90193: LIST
90194: LIST
90195: LIST
90196: LIST
90197: ST_TO_ADDR
// tmp :=  ;
90198: LD_ADDR_VAR 0 3
90202: PUSH
90203: LD_STRING 
90205: ST_TO_ADDR
// for i = 1 to normalCounter do
90206: LD_ADDR_VAR 0 8
90210: PUSH
90211: DOUBLE
90212: LD_INT 1
90214: DEC
90215: ST_TO_ADDR
90216: LD_EXP 114
90220: PUSH
90221: FOR_TO
90222: IFFALSE 90258
// begin if flags [ i ] then
90224: LD_VAR 0 4
90228: PUSH
90229: LD_VAR 0 8
90233: ARRAY
90234: IFFALSE 90256
// tmp := tmp & i & ; ;
90236: LD_ADDR_VAR 0 3
90240: PUSH
90241: LD_VAR 0 3
90245: PUSH
90246: LD_VAR 0 8
90250: STR
90251: PUSH
90252: LD_STRING ;
90254: STR
90255: ST_TO_ADDR
// end ;
90256: GO 90221
90258: POP
90259: POP
// for i = 1 to hardcoreCounter do
90260: LD_ADDR_VAR 0 8
90264: PUSH
90265: DOUBLE
90266: LD_INT 1
90268: DEC
90269: ST_TO_ADDR
90270: LD_EXP 115
90274: PUSH
90275: FOR_TO
90276: IFFALSE 90322
// begin if flags [ normalCounter + i ] then
90278: LD_VAR 0 4
90282: PUSH
90283: LD_EXP 114
90287: PUSH
90288: LD_VAR 0 8
90292: PLUS
90293: ARRAY
90294: IFFALSE 90320
// tmp := tmp & ( 100 + i ) & ; ;
90296: LD_ADDR_VAR 0 3
90300: PUSH
90301: LD_VAR 0 3
90305: PUSH
90306: LD_INT 100
90308: PUSH
90309: LD_VAR 0 8
90313: PLUS
90314: STR
90315: PUSH
90316: LD_STRING ;
90318: STR
90319: ST_TO_ADDR
// end ;
90320: GO 90275
90322: POP
90323: POP
// if tmp then
90324: LD_VAR 0 3
90328: IFFALSE 90340
// active := tmp ;
90330: LD_ADDR_VAR 0 7
90334: PUSH
90335: LD_VAR 0 3
90339: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
90340: LD_STRING getStreamItemsFromMission("
90342: PUSH
90343: LD_VAR 0 5
90347: STR
90348: PUSH
90349: LD_STRING ","
90351: STR
90352: PUSH
90353: LD_VAR 0 6
90357: STR
90358: PUSH
90359: LD_STRING ","
90361: STR
90362: PUSH
90363: LD_VAR 0 7
90367: STR
90368: PUSH
90369: LD_STRING ")
90371: STR
90372: PPUSH
90373: CALL_OW 559
// end else
90377: GO 90386
// ToLua ( getStreamItemsFromMission("","","") ) ;
90379: LD_STRING getStreamItemsFromMission("","","")
90381: PPUSH
90382: CALL_OW 559
// end ;
90386: LD_VAR 0 2
90390: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
90391: LD_EXP 113
90395: PUSH
90396: LD_EXP 118
90400: AND
90401: IFFALSE 90525
90403: GO 90405
90405: DISABLE
90406: LD_INT 0
90408: PPUSH
90409: PPUSH
// begin enable ;
90410: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
90411: LD_ADDR_VAR 0 2
90415: PUSH
90416: LD_INT 22
90418: PUSH
90419: LD_OWVAR 2
90423: PUSH
90424: EMPTY
90425: LIST
90426: LIST
90427: PUSH
90428: LD_INT 2
90430: PUSH
90431: LD_INT 34
90433: PUSH
90434: LD_INT 7
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: PUSH
90441: LD_INT 34
90443: PUSH
90444: LD_INT 45
90446: PUSH
90447: EMPTY
90448: LIST
90449: LIST
90450: PUSH
90451: LD_INT 34
90453: PUSH
90454: LD_INT 28
90456: PUSH
90457: EMPTY
90458: LIST
90459: LIST
90460: PUSH
90461: LD_INT 34
90463: PUSH
90464: LD_INT 47
90466: PUSH
90467: EMPTY
90468: LIST
90469: LIST
90470: PUSH
90471: EMPTY
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: PUSH
90478: EMPTY
90479: LIST
90480: LIST
90481: PPUSH
90482: CALL_OW 69
90486: ST_TO_ADDR
// if not tmp then
90487: LD_VAR 0 2
90491: NOT
90492: IFFALSE 90496
// exit ;
90494: GO 90525
// for i in tmp do
90496: LD_ADDR_VAR 0 1
90500: PUSH
90501: LD_VAR 0 2
90505: PUSH
90506: FOR_IN
90507: IFFALSE 90523
// begin SetLives ( i , 0 ) ;
90509: LD_VAR 0 1
90513: PPUSH
90514: LD_INT 0
90516: PPUSH
90517: CALL_OW 234
// end ;
90521: GO 90506
90523: POP
90524: POP
// end ;
90525: PPOPN 2
90527: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
90528: LD_EXP 113
90532: PUSH
90533: LD_EXP 119
90537: AND
90538: IFFALSE 90622
90540: GO 90542
90542: DISABLE
90543: LD_INT 0
90545: PPUSH
90546: PPUSH
// begin enable ;
90547: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
90548: LD_ADDR_VAR 0 2
90552: PUSH
90553: LD_INT 22
90555: PUSH
90556: LD_OWVAR 2
90560: PUSH
90561: EMPTY
90562: LIST
90563: LIST
90564: PUSH
90565: LD_INT 32
90567: PUSH
90568: LD_INT 3
90570: PUSH
90571: EMPTY
90572: LIST
90573: LIST
90574: PUSH
90575: EMPTY
90576: LIST
90577: LIST
90578: PPUSH
90579: CALL_OW 69
90583: ST_TO_ADDR
// if not tmp then
90584: LD_VAR 0 2
90588: NOT
90589: IFFALSE 90593
// exit ;
90591: GO 90622
// for i in tmp do
90593: LD_ADDR_VAR 0 1
90597: PUSH
90598: LD_VAR 0 2
90602: PUSH
90603: FOR_IN
90604: IFFALSE 90620
// begin SetLives ( i , 0 ) ;
90606: LD_VAR 0 1
90610: PPUSH
90611: LD_INT 0
90613: PPUSH
90614: CALL_OW 234
// end ;
90618: GO 90603
90620: POP
90621: POP
// end ;
90622: PPOPN 2
90624: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
90625: LD_EXP 113
90629: PUSH
90630: LD_EXP 116
90634: AND
90635: IFFALSE 90728
90637: GO 90639
90639: DISABLE
90640: LD_INT 0
90642: PPUSH
// begin enable ;
90643: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
90644: LD_ADDR_VAR 0 1
90648: PUSH
90649: LD_INT 22
90651: PUSH
90652: LD_OWVAR 2
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: PUSH
90661: LD_INT 2
90663: PUSH
90664: LD_INT 25
90666: PUSH
90667: LD_INT 5
90669: PUSH
90670: EMPTY
90671: LIST
90672: LIST
90673: PUSH
90674: LD_INT 25
90676: PUSH
90677: LD_INT 9
90679: PUSH
90680: EMPTY
90681: LIST
90682: LIST
90683: PUSH
90684: LD_INT 25
90686: PUSH
90687: LD_INT 8
90689: PUSH
90690: EMPTY
90691: LIST
90692: LIST
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: LIST
90698: LIST
90699: PUSH
90700: EMPTY
90701: LIST
90702: LIST
90703: PPUSH
90704: CALL_OW 69
90708: PUSH
90709: FOR_IN
90710: IFFALSE 90726
// begin SetClass ( i , 1 ) ;
90712: LD_VAR 0 1
90716: PPUSH
90717: LD_INT 1
90719: PPUSH
90720: CALL_OW 336
// end ;
90724: GO 90709
90726: POP
90727: POP
// end ;
90728: PPOPN 1
90730: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
90731: LD_EXP 113
90735: PUSH
90736: LD_EXP 117
90740: AND
90741: PUSH
90742: LD_OWVAR 65
90746: PUSH
90747: LD_INT 7
90749: LESS
90750: AND
90751: IFFALSE 90765
90753: GO 90755
90755: DISABLE
// begin enable ;
90756: ENABLE
// game_speed := 7 ;
90757: LD_ADDR_OWVAR 65
90761: PUSH
90762: LD_INT 7
90764: ST_TO_ADDR
// end ;
90765: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
90766: LD_EXP 113
90770: PUSH
90771: LD_EXP 120
90775: AND
90776: IFFALSE 90978
90778: GO 90780
90780: DISABLE
90781: LD_INT 0
90783: PPUSH
90784: PPUSH
90785: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
90786: LD_ADDR_VAR 0 3
90790: PUSH
90791: LD_INT 81
90793: PUSH
90794: LD_OWVAR 2
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: PUSH
90803: LD_INT 21
90805: PUSH
90806: LD_INT 1
90808: PUSH
90809: EMPTY
90810: LIST
90811: LIST
90812: PUSH
90813: EMPTY
90814: LIST
90815: LIST
90816: PPUSH
90817: CALL_OW 69
90821: ST_TO_ADDR
// if not tmp then
90822: LD_VAR 0 3
90826: NOT
90827: IFFALSE 90831
// exit ;
90829: GO 90978
// if tmp > 5 then
90831: LD_VAR 0 3
90835: PUSH
90836: LD_INT 5
90838: GREATER
90839: IFFALSE 90851
// k := 5 else
90841: LD_ADDR_VAR 0 2
90845: PUSH
90846: LD_INT 5
90848: ST_TO_ADDR
90849: GO 90861
// k := tmp ;
90851: LD_ADDR_VAR 0 2
90855: PUSH
90856: LD_VAR 0 3
90860: ST_TO_ADDR
// for i := 1 to k do
90861: LD_ADDR_VAR 0 1
90865: PUSH
90866: DOUBLE
90867: LD_INT 1
90869: DEC
90870: ST_TO_ADDR
90871: LD_VAR 0 2
90875: PUSH
90876: FOR_TO
90877: IFFALSE 90976
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
90879: LD_VAR 0 3
90883: PUSH
90884: LD_VAR 0 1
90888: ARRAY
90889: PPUSH
90890: LD_VAR 0 1
90894: PUSH
90895: LD_INT 4
90897: MOD
90898: PUSH
90899: LD_INT 1
90901: PLUS
90902: PPUSH
90903: CALL_OW 259
90907: PUSH
90908: LD_INT 10
90910: LESS
90911: IFFALSE 90974
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
90913: LD_VAR 0 3
90917: PUSH
90918: LD_VAR 0 1
90922: ARRAY
90923: PPUSH
90924: LD_VAR 0 1
90928: PUSH
90929: LD_INT 4
90931: MOD
90932: PUSH
90933: LD_INT 1
90935: PLUS
90936: PPUSH
90937: LD_VAR 0 3
90941: PUSH
90942: LD_VAR 0 1
90946: ARRAY
90947: PPUSH
90948: LD_VAR 0 1
90952: PUSH
90953: LD_INT 4
90955: MOD
90956: PUSH
90957: LD_INT 1
90959: PLUS
90960: PPUSH
90961: CALL_OW 259
90965: PUSH
90966: LD_INT 1
90968: PLUS
90969: PPUSH
90970: CALL_OW 237
90974: GO 90876
90976: POP
90977: POP
// end ;
90978: PPOPN 3
90980: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
90981: LD_EXP 113
90985: PUSH
90986: LD_EXP 121
90990: AND
90991: IFFALSE 91011
90993: GO 90995
90995: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
90996: LD_INT 4
90998: PPUSH
90999: LD_OWVAR 2
91003: PPUSH
91004: LD_INT 0
91006: PPUSH
91007: CALL_OW 324
91011: END
// every 0 0$1 trigger StreamModeActive and sShovel do
91012: LD_EXP 113
91016: PUSH
91017: LD_EXP 150
91021: AND
91022: IFFALSE 91042
91024: GO 91026
91026: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
91027: LD_INT 19
91029: PPUSH
91030: LD_OWVAR 2
91034: PPUSH
91035: LD_INT 0
91037: PPUSH
91038: CALL_OW 324
91042: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
91043: LD_EXP 113
91047: PUSH
91048: LD_EXP 122
91052: AND
91053: IFFALSE 91155
91055: GO 91057
91057: DISABLE
91058: LD_INT 0
91060: PPUSH
91061: PPUSH
// begin enable ;
91062: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
91063: LD_ADDR_VAR 0 2
91067: PUSH
91068: LD_INT 22
91070: PUSH
91071: LD_OWVAR 2
91075: PUSH
91076: EMPTY
91077: LIST
91078: LIST
91079: PUSH
91080: LD_INT 2
91082: PUSH
91083: LD_INT 34
91085: PUSH
91086: LD_INT 11
91088: PUSH
91089: EMPTY
91090: LIST
91091: LIST
91092: PUSH
91093: LD_INT 34
91095: PUSH
91096: LD_INT 30
91098: PUSH
91099: EMPTY
91100: LIST
91101: LIST
91102: PUSH
91103: EMPTY
91104: LIST
91105: LIST
91106: LIST
91107: PUSH
91108: EMPTY
91109: LIST
91110: LIST
91111: PPUSH
91112: CALL_OW 69
91116: ST_TO_ADDR
// if not tmp then
91117: LD_VAR 0 2
91121: NOT
91122: IFFALSE 91126
// exit ;
91124: GO 91155
// for i in tmp do
91126: LD_ADDR_VAR 0 1
91130: PUSH
91131: LD_VAR 0 2
91135: PUSH
91136: FOR_IN
91137: IFFALSE 91153
// begin SetLives ( i , 0 ) ;
91139: LD_VAR 0 1
91143: PPUSH
91144: LD_INT 0
91146: PPUSH
91147: CALL_OW 234
// end ;
91151: GO 91136
91153: POP
91154: POP
// end ;
91155: PPOPN 2
91157: END
// every 0 0$1 trigger StreamModeActive and sBunker do
91158: LD_EXP 113
91162: PUSH
91163: LD_EXP 123
91167: AND
91168: IFFALSE 91188
91170: GO 91172
91172: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
91173: LD_INT 32
91175: PPUSH
91176: LD_OWVAR 2
91180: PPUSH
91181: LD_INT 0
91183: PPUSH
91184: CALL_OW 324
91188: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
91189: LD_EXP 113
91193: PUSH
91194: LD_EXP 124
91198: AND
91199: IFFALSE 91380
91201: GO 91203
91203: DISABLE
91204: LD_INT 0
91206: PPUSH
91207: PPUSH
91208: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
91209: LD_ADDR_VAR 0 2
91213: PUSH
91214: LD_INT 22
91216: PUSH
91217: LD_OWVAR 2
91221: PUSH
91222: EMPTY
91223: LIST
91224: LIST
91225: PUSH
91226: LD_INT 33
91228: PUSH
91229: LD_INT 3
91231: PUSH
91232: EMPTY
91233: LIST
91234: LIST
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: PPUSH
91240: CALL_OW 69
91244: ST_TO_ADDR
// if not tmp then
91245: LD_VAR 0 2
91249: NOT
91250: IFFALSE 91254
// exit ;
91252: GO 91380
// side := 0 ;
91254: LD_ADDR_VAR 0 3
91258: PUSH
91259: LD_INT 0
91261: ST_TO_ADDR
// for i := 1 to 8 do
91262: LD_ADDR_VAR 0 1
91266: PUSH
91267: DOUBLE
91268: LD_INT 1
91270: DEC
91271: ST_TO_ADDR
91272: LD_INT 8
91274: PUSH
91275: FOR_TO
91276: IFFALSE 91324
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
91278: LD_OWVAR 2
91282: PUSH
91283: LD_VAR 0 1
91287: NONEQUAL
91288: PUSH
91289: LD_OWVAR 2
91293: PPUSH
91294: LD_VAR 0 1
91298: PPUSH
91299: CALL_OW 81
91303: PUSH
91304: LD_INT 2
91306: EQUAL
91307: AND
91308: IFFALSE 91322
// begin side := i ;
91310: LD_ADDR_VAR 0 3
91314: PUSH
91315: LD_VAR 0 1
91319: ST_TO_ADDR
// break ;
91320: GO 91324
// end ;
91322: GO 91275
91324: POP
91325: POP
// if not side then
91326: LD_VAR 0 3
91330: NOT
91331: IFFALSE 91335
// exit ;
91333: GO 91380
// for i := 1 to tmp do
91335: LD_ADDR_VAR 0 1
91339: PUSH
91340: DOUBLE
91341: LD_INT 1
91343: DEC
91344: ST_TO_ADDR
91345: LD_VAR 0 2
91349: PUSH
91350: FOR_TO
91351: IFFALSE 91378
// if Prob ( 60 ) then
91353: LD_INT 60
91355: PPUSH
91356: CALL_OW 13
91360: IFFALSE 91376
// SetSide ( i , side ) ;
91362: LD_VAR 0 1
91366: PPUSH
91367: LD_VAR 0 3
91371: PPUSH
91372: CALL_OW 235
91376: GO 91350
91378: POP
91379: POP
// end ;
91380: PPOPN 3
91382: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
91383: LD_EXP 113
91387: PUSH
91388: LD_EXP 126
91392: AND
91393: IFFALSE 91512
91395: GO 91397
91397: DISABLE
91398: LD_INT 0
91400: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
91401: LD_ADDR_VAR 0 1
91405: PUSH
91406: LD_INT 22
91408: PUSH
91409: LD_OWVAR 2
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: PUSH
91418: LD_INT 21
91420: PUSH
91421: LD_INT 1
91423: PUSH
91424: EMPTY
91425: LIST
91426: LIST
91427: PUSH
91428: LD_INT 3
91430: PUSH
91431: LD_INT 23
91433: PUSH
91434: LD_INT 0
91436: PUSH
91437: EMPTY
91438: LIST
91439: LIST
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: PUSH
91445: EMPTY
91446: LIST
91447: LIST
91448: LIST
91449: PPUSH
91450: CALL_OW 69
91454: PUSH
91455: FOR_IN
91456: IFFALSE 91510
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
91458: LD_VAR 0 1
91462: PPUSH
91463: CALL_OW 257
91467: PUSH
91468: LD_INT 1
91470: PUSH
91471: LD_INT 2
91473: PUSH
91474: LD_INT 3
91476: PUSH
91477: LD_INT 4
91479: PUSH
91480: EMPTY
91481: LIST
91482: LIST
91483: LIST
91484: LIST
91485: IN
91486: IFFALSE 91508
// SetClass ( un , rand ( 1 , 4 ) ) ;
91488: LD_VAR 0 1
91492: PPUSH
91493: LD_INT 1
91495: PPUSH
91496: LD_INT 4
91498: PPUSH
91499: CALL_OW 12
91503: PPUSH
91504: CALL_OW 336
91508: GO 91455
91510: POP
91511: POP
// end ;
91512: PPOPN 1
91514: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
91515: LD_EXP 113
91519: PUSH
91520: LD_EXP 125
91524: AND
91525: IFFALSE 91604
91527: GO 91529
91529: DISABLE
91530: LD_INT 0
91532: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91533: LD_ADDR_VAR 0 1
91537: PUSH
91538: LD_INT 22
91540: PUSH
91541: LD_OWVAR 2
91545: PUSH
91546: EMPTY
91547: LIST
91548: LIST
91549: PUSH
91550: LD_INT 21
91552: PUSH
91553: LD_INT 3
91555: PUSH
91556: EMPTY
91557: LIST
91558: LIST
91559: PUSH
91560: EMPTY
91561: LIST
91562: LIST
91563: PPUSH
91564: CALL_OW 69
91568: ST_TO_ADDR
// if not tmp then
91569: LD_VAR 0 1
91573: NOT
91574: IFFALSE 91578
// exit ;
91576: GO 91604
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
91578: LD_VAR 0 1
91582: PUSH
91583: LD_INT 1
91585: PPUSH
91586: LD_VAR 0 1
91590: PPUSH
91591: CALL_OW 12
91595: ARRAY
91596: PPUSH
91597: LD_INT 100
91599: PPUSH
91600: CALL_OW 234
// end ;
91604: PPOPN 1
91606: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
91607: LD_EXP 113
91611: PUSH
91612: LD_EXP 127
91616: AND
91617: IFFALSE 91715
91619: GO 91621
91621: DISABLE
91622: LD_INT 0
91624: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91625: LD_ADDR_VAR 0 1
91629: PUSH
91630: LD_INT 22
91632: PUSH
91633: LD_OWVAR 2
91637: PUSH
91638: EMPTY
91639: LIST
91640: LIST
91641: PUSH
91642: LD_INT 21
91644: PUSH
91645: LD_INT 1
91647: PUSH
91648: EMPTY
91649: LIST
91650: LIST
91651: PUSH
91652: EMPTY
91653: LIST
91654: LIST
91655: PPUSH
91656: CALL_OW 69
91660: ST_TO_ADDR
// if not tmp then
91661: LD_VAR 0 1
91665: NOT
91666: IFFALSE 91670
// exit ;
91668: GO 91715
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
91670: LD_VAR 0 1
91674: PUSH
91675: LD_INT 1
91677: PPUSH
91678: LD_VAR 0 1
91682: PPUSH
91683: CALL_OW 12
91687: ARRAY
91688: PPUSH
91689: LD_INT 1
91691: PPUSH
91692: LD_INT 4
91694: PPUSH
91695: CALL_OW 12
91699: PPUSH
91700: LD_INT 3000
91702: PPUSH
91703: LD_INT 9000
91705: PPUSH
91706: CALL_OW 12
91710: PPUSH
91711: CALL_OW 492
// end ;
91715: PPOPN 1
91717: END
// every 0 0$1 trigger StreamModeActive and sDepot do
91718: LD_EXP 113
91722: PUSH
91723: LD_EXP 128
91727: AND
91728: IFFALSE 91748
91730: GO 91732
91732: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
91733: LD_INT 1
91735: PPUSH
91736: LD_OWVAR 2
91740: PPUSH
91741: LD_INT 0
91743: PPUSH
91744: CALL_OW 324
91748: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
91749: LD_EXP 113
91753: PUSH
91754: LD_EXP 129
91758: AND
91759: IFFALSE 91842
91761: GO 91763
91763: DISABLE
91764: LD_INT 0
91766: PPUSH
91767: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91768: LD_ADDR_VAR 0 2
91772: PUSH
91773: LD_INT 22
91775: PUSH
91776: LD_OWVAR 2
91780: PUSH
91781: EMPTY
91782: LIST
91783: LIST
91784: PUSH
91785: LD_INT 21
91787: PUSH
91788: LD_INT 3
91790: PUSH
91791: EMPTY
91792: LIST
91793: LIST
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PPUSH
91799: CALL_OW 69
91803: ST_TO_ADDR
// if not tmp then
91804: LD_VAR 0 2
91808: NOT
91809: IFFALSE 91813
// exit ;
91811: GO 91842
// for i in tmp do
91813: LD_ADDR_VAR 0 1
91817: PUSH
91818: LD_VAR 0 2
91822: PUSH
91823: FOR_IN
91824: IFFALSE 91840
// SetBLevel ( i , 10 ) ;
91826: LD_VAR 0 1
91830: PPUSH
91831: LD_INT 10
91833: PPUSH
91834: CALL_OW 241
91838: GO 91823
91840: POP
91841: POP
// end ;
91842: PPOPN 2
91844: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
91845: LD_EXP 113
91849: PUSH
91850: LD_EXP 130
91854: AND
91855: IFFALSE 91966
91857: GO 91859
91859: DISABLE
91860: LD_INT 0
91862: PPUSH
91863: PPUSH
91864: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91865: LD_ADDR_VAR 0 3
91869: PUSH
91870: LD_INT 22
91872: PUSH
91873: LD_OWVAR 2
91877: PUSH
91878: EMPTY
91879: LIST
91880: LIST
91881: PUSH
91882: LD_INT 25
91884: PUSH
91885: LD_INT 1
91887: PUSH
91888: EMPTY
91889: LIST
91890: LIST
91891: PUSH
91892: EMPTY
91893: LIST
91894: LIST
91895: PPUSH
91896: CALL_OW 69
91900: ST_TO_ADDR
// if not tmp then
91901: LD_VAR 0 3
91905: NOT
91906: IFFALSE 91910
// exit ;
91908: GO 91966
// un := tmp [ rand ( 1 , tmp ) ] ;
91910: LD_ADDR_VAR 0 2
91914: PUSH
91915: LD_VAR 0 3
91919: PUSH
91920: LD_INT 1
91922: PPUSH
91923: LD_VAR 0 3
91927: PPUSH
91928: CALL_OW 12
91932: ARRAY
91933: ST_TO_ADDR
// if Crawls ( un ) then
91934: LD_VAR 0 2
91938: PPUSH
91939: CALL_OW 318
91943: IFFALSE 91954
// ComWalk ( un ) ;
91945: LD_VAR 0 2
91949: PPUSH
91950: CALL_OW 138
// SetClass ( un , class_sniper ) ;
91954: LD_VAR 0 2
91958: PPUSH
91959: LD_INT 5
91961: PPUSH
91962: CALL_OW 336
// end ;
91966: PPOPN 3
91968: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
91969: LD_EXP 113
91973: PUSH
91974: LD_EXP 131
91978: AND
91979: PUSH
91980: LD_OWVAR 67
91984: PUSH
91985: LD_INT 4
91987: LESS
91988: AND
91989: IFFALSE 92008
91991: GO 91993
91993: DISABLE
// begin Difficulty := Difficulty + 1 ;
91994: LD_ADDR_OWVAR 67
91998: PUSH
91999: LD_OWVAR 67
92003: PUSH
92004: LD_INT 1
92006: PLUS
92007: ST_TO_ADDR
// end ;
92008: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
92009: LD_EXP 113
92013: PUSH
92014: LD_EXP 132
92018: AND
92019: IFFALSE 92122
92021: GO 92023
92023: DISABLE
92024: LD_INT 0
92026: PPUSH
// begin for i := 1 to 5 do
92027: LD_ADDR_VAR 0 1
92031: PUSH
92032: DOUBLE
92033: LD_INT 1
92035: DEC
92036: ST_TO_ADDR
92037: LD_INT 5
92039: PUSH
92040: FOR_TO
92041: IFFALSE 92120
// begin uc_nation := nation_nature ;
92043: LD_ADDR_OWVAR 21
92047: PUSH
92048: LD_INT 0
92050: ST_TO_ADDR
// uc_side := 0 ;
92051: LD_ADDR_OWVAR 20
92055: PUSH
92056: LD_INT 0
92058: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
92059: LD_ADDR_OWVAR 29
92063: PUSH
92064: LD_INT 12
92066: PUSH
92067: LD_INT 12
92069: PUSH
92070: EMPTY
92071: LIST
92072: LIST
92073: ST_TO_ADDR
// hc_agressivity := 20 ;
92074: LD_ADDR_OWVAR 35
92078: PUSH
92079: LD_INT 20
92081: ST_TO_ADDR
// hc_class := class_tiger ;
92082: LD_ADDR_OWVAR 28
92086: PUSH
92087: LD_INT 14
92089: ST_TO_ADDR
// hc_gallery :=  ;
92090: LD_ADDR_OWVAR 33
92094: PUSH
92095: LD_STRING 
92097: ST_TO_ADDR
// hc_name :=  ;
92098: LD_ADDR_OWVAR 26
92102: PUSH
92103: LD_STRING 
92105: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
92106: CALL_OW 44
92110: PPUSH
92111: LD_INT 0
92113: PPUSH
92114: CALL_OW 51
// end ;
92118: GO 92040
92120: POP
92121: POP
// end ;
92122: PPOPN 1
92124: END
// every 0 0$1 trigger StreamModeActive and sBomb do
92125: LD_EXP 113
92129: PUSH
92130: LD_EXP 133
92134: AND
92135: IFFALSE 92144
92137: GO 92139
92139: DISABLE
// StreamSibBomb ;
92140: CALL 92145 0 0
92144: END
// export function StreamSibBomb ; var i , x , y ; begin
92145: LD_INT 0
92147: PPUSH
92148: PPUSH
92149: PPUSH
92150: PPUSH
// result := false ;
92151: LD_ADDR_VAR 0 1
92155: PUSH
92156: LD_INT 0
92158: ST_TO_ADDR
// for i := 1 to 16 do
92159: LD_ADDR_VAR 0 2
92163: PUSH
92164: DOUBLE
92165: LD_INT 1
92167: DEC
92168: ST_TO_ADDR
92169: LD_INT 16
92171: PUSH
92172: FOR_TO
92173: IFFALSE 92372
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
92175: LD_ADDR_VAR 0 3
92179: PUSH
92180: LD_INT 10
92182: PUSH
92183: LD_INT 20
92185: PUSH
92186: LD_INT 30
92188: PUSH
92189: LD_INT 40
92191: PUSH
92192: LD_INT 50
92194: PUSH
92195: LD_INT 60
92197: PUSH
92198: LD_INT 70
92200: PUSH
92201: LD_INT 80
92203: PUSH
92204: LD_INT 90
92206: PUSH
92207: LD_INT 100
92209: PUSH
92210: LD_INT 110
92212: PUSH
92213: LD_INT 120
92215: PUSH
92216: LD_INT 130
92218: PUSH
92219: LD_INT 140
92221: PUSH
92222: LD_INT 150
92224: PUSH
92225: EMPTY
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: LIST
92231: LIST
92232: LIST
92233: LIST
92234: LIST
92235: LIST
92236: LIST
92237: LIST
92238: LIST
92239: LIST
92240: LIST
92241: PUSH
92242: LD_INT 1
92244: PPUSH
92245: LD_INT 15
92247: PPUSH
92248: CALL_OW 12
92252: ARRAY
92253: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
92254: LD_ADDR_VAR 0 4
92258: PUSH
92259: LD_INT 10
92261: PUSH
92262: LD_INT 20
92264: PUSH
92265: LD_INT 30
92267: PUSH
92268: LD_INT 40
92270: PUSH
92271: LD_INT 50
92273: PUSH
92274: LD_INT 60
92276: PUSH
92277: LD_INT 70
92279: PUSH
92280: LD_INT 80
92282: PUSH
92283: LD_INT 90
92285: PUSH
92286: LD_INT 100
92288: PUSH
92289: LD_INT 110
92291: PUSH
92292: LD_INT 120
92294: PUSH
92295: LD_INT 130
92297: PUSH
92298: LD_INT 140
92300: PUSH
92301: LD_INT 150
92303: PUSH
92304: EMPTY
92305: LIST
92306: LIST
92307: LIST
92308: LIST
92309: LIST
92310: LIST
92311: LIST
92312: LIST
92313: LIST
92314: LIST
92315: LIST
92316: LIST
92317: LIST
92318: LIST
92319: LIST
92320: PUSH
92321: LD_INT 1
92323: PPUSH
92324: LD_INT 15
92326: PPUSH
92327: CALL_OW 12
92331: ARRAY
92332: ST_TO_ADDR
// if ValidHex ( x , y ) then
92333: LD_VAR 0 3
92337: PPUSH
92338: LD_VAR 0 4
92342: PPUSH
92343: CALL_OW 488
92347: IFFALSE 92370
// begin result := [ x , y ] ;
92349: LD_ADDR_VAR 0 1
92353: PUSH
92354: LD_VAR 0 3
92358: PUSH
92359: LD_VAR 0 4
92363: PUSH
92364: EMPTY
92365: LIST
92366: LIST
92367: ST_TO_ADDR
// break ;
92368: GO 92372
// end ; end ;
92370: GO 92172
92372: POP
92373: POP
// if result then
92374: LD_VAR 0 1
92378: IFFALSE 92438
// begin ToLua ( playSibBomb() ) ;
92380: LD_STRING playSibBomb()
92382: PPUSH
92383: CALL_OW 559
// wait ( 0 0$14 ) ;
92387: LD_INT 490
92389: PPUSH
92390: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
92394: LD_VAR 0 1
92398: PUSH
92399: LD_INT 1
92401: ARRAY
92402: PPUSH
92403: LD_VAR 0 1
92407: PUSH
92408: LD_INT 2
92410: ARRAY
92411: PPUSH
92412: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
92416: LD_VAR 0 1
92420: PUSH
92421: LD_INT 1
92423: ARRAY
92424: PPUSH
92425: LD_VAR 0 1
92429: PUSH
92430: LD_INT 2
92432: ARRAY
92433: PPUSH
92434: CALL_OW 429
// end ; end ;
92438: LD_VAR 0 1
92442: RET
// every 0 0$1 trigger StreamModeActive and sReset do
92443: LD_EXP 113
92447: PUSH
92448: LD_EXP 135
92452: AND
92453: IFFALSE 92465
92455: GO 92457
92457: DISABLE
// YouLost (  ) ;
92458: LD_STRING 
92460: PPUSH
92461: CALL_OW 104
92465: END
// every 0 0$1 trigger StreamModeActive and sFog do
92466: LD_EXP 113
92470: PUSH
92471: LD_EXP 134
92475: AND
92476: IFFALSE 92490
92478: GO 92480
92480: DISABLE
// FogOff ( your_side ) ;
92481: LD_OWVAR 2
92485: PPUSH
92486: CALL_OW 344
92490: END
// every 0 0$1 trigger StreamModeActive and sSun do
92491: LD_EXP 113
92495: PUSH
92496: LD_EXP 136
92500: AND
92501: IFFALSE 92529
92503: GO 92505
92505: DISABLE
// begin solar_recharge_percent := 0 ;
92506: LD_ADDR_OWVAR 79
92510: PUSH
92511: LD_INT 0
92513: ST_TO_ADDR
// wait ( 5 5$00 ) ;
92514: LD_INT 10500
92516: PPUSH
92517: CALL_OW 67
// solar_recharge_percent := 100 ;
92521: LD_ADDR_OWVAR 79
92525: PUSH
92526: LD_INT 100
92528: ST_TO_ADDR
// end ;
92529: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
92530: LD_EXP 113
92534: PUSH
92535: LD_EXP 137
92539: AND
92540: IFFALSE 92779
92542: GO 92544
92544: DISABLE
92545: LD_INT 0
92547: PPUSH
92548: PPUSH
92549: PPUSH
// begin tmp := [ ] ;
92550: LD_ADDR_VAR 0 3
92554: PUSH
92555: EMPTY
92556: ST_TO_ADDR
// for i := 1 to 6 do
92557: LD_ADDR_VAR 0 1
92561: PUSH
92562: DOUBLE
92563: LD_INT 1
92565: DEC
92566: ST_TO_ADDR
92567: LD_INT 6
92569: PUSH
92570: FOR_TO
92571: IFFALSE 92676
// begin uc_nation := nation_nature ;
92573: LD_ADDR_OWVAR 21
92577: PUSH
92578: LD_INT 0
92580: ST_TO_ADDR
// uc_side := 0 ;
92581: LD_ADDR_OWVAR 20
92585: PUSH
92586: LD_INT 0
92588: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
92589: LD_ADDR_OWVAR 29
92593: PUSH
92594: LD_INT 12
92596: PUSH
92597: LD_INT 12
92599: PUSH
92600: EMPTY
92601: LIST
92602: LIST
92603: ST_TO_ADDR
// hc_agressivity := 20 ;
92604: LD_ADDR_OWVAR 35
92608: PUSH
92609: LD_INT 20
92611: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
92612: LD_ADDR_OWVAR 28
92616: PUSH
92617: LD_INT 17
92619: ST_TO_ADDR
// hc_gallery :=  ;
92620: LD_ADDR_OWVAR 33
92624: PUSH
92625: LD_STRING 
92627: ST_TO_ADDR
// hc_name :=  ;
92628: LD_ADDR_OWVAR 26
92632: PUSH
92633: LD_STRING 
92635: ST_TO_ADDR
// un := CreateHuman ;
92636: LD_ADDR_VAR 0 2
92640: PUSH
92641: CALL_OW 44
92645: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
92646: LD_VAR 0 2
92650: PPUSH
92651: LD_INT 1
92653: PPUSH
92654: CALL_OW 51
// tmp := tmp ^ un ;
92658: LD_ADDR_VAR 0 3
92662: PUSH
92663: LD_VAR 0 3
92667: PUSH
92668: LD_VAR 0 2
92672: ADD
92673: ST_TO_ADDR
// end ;
92674: GO 92570
92676: POP
92677: POP
// repeat wait ( 0 0$1 ) ;
92678: LD_INT 35
92680: PPUSH
92681: CALL_OW 67
// for un in tmp do
92685: LD_ADDR_VAR 0 2
92689: PUSH
92690: LD_VAR 0 3
92694: PUSH
92695: FOR_IN
92696: IFFALSE 92770
// begin if IsDead ( un ) then
92698: LD_VAR 0 2
92702: PPUSH
92703: CALL_OW 301
92707: IFFALSE 92727
// begin tmp := tmp diff un ;
92709: LD_ADDR_VAR 0 3
92713: PUSH
92714: LD_VAR 0 3
92718: PUSH
92719: LD_VAR 0 2
92723: DIFF
92724: ST_TO_ADDR
// continue ;
92725: GO 92695
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
92727: LD_VAR 0 2
92731: PPUSH
92732: LD_INT 3
92734: PUSH
92735: LD_INT 22
92737: PUSH
92738: LD_INT 0
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PPUSH
92749: CALL_OW 69
92753: PPUSH
92754: LD_VAR 0 2
92758: PPUSH
92759: CALL_OW 74
92763: PPUSH
92764: CALL_OW 115
// end ;
92768: GO 92695
92770: POP
92771: POP
// until not tmp ;
92772: LD_VAR 0 3
92776: NOT
92777: IFFALSE 92678
// end ;
92779: PPOPN 3
92781: END
// every 0 0$1 trigger StreamModeActive and sTroll do
92782: LD_EXP 113
92786: PUSH
92787: LD_EXP 138
92791: AND
92792: IFFALSE 92846
92794: GO 92796
92796: DISABLE
// begin ToLua ( displayTroll(); ) ;
92797: LD_STRING displayTroll();
92799: PPUSH
92800: CALL_OW 559
// wait ( 3 3$00 ) ;
92804: LD_INT 6300
92806: PPUSH
92807: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92811: LD_STRING hideTroll();
92813: PPUSH
92814: CALL_OW 559
// wait ( 1 1$00 ) ;
92818: LD_INT 2100
92820: PPUSH
92821: CALL_OW 67
// ToLua ( displayTroll(); ) ;
92825: LD_STRING displayTroll();
92827: PPUSH
92828: CALL_OW 559
// wait ( 1 1$00 ) ;
92832: LD_INT 2100
92834: PPUSH
92835: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92839: LD_STRING hideTroll();
92841: PPUSH
92842: CALL_OW 559
// end ;
92846: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
92847: LD_EXP 113
92851: PUSH
92852: LD_EXP 139
92856: AND
92857: IFFALSE 92920
92859: GO 92861
92861: DISABLE
92862: LD_INT 0
92864: PPUSH
// begin p := 0 ;
92865: LD_ADDR_VAR 0 1
92869: PUSH
92870: LD_INT 0
92872: ST_TO_ADDR
// repeat game_speed := 1 ;
92873: LD_ADDR_OWVAR 65
92877: PUSH
92878: LD_INT 1
92880: ST_TO_ADDR
// wait ( 0 0$1 ) ;
92881: LD_INT 35
92883: PPUSH
92884: CALL_OW 67
// p := p + 1 ;
92888: LD_ADDR_VAR 0 1
92892: PUSH
92893: LD_VAR 0 1
92897: PUSH
92898: LD_INT 1
92900: PLUS
92901: ST_TO_ADDR
// until p >= 60 ;
92902: LD_VAR 0 1
92906: PUSH
92907: LD_INT 60
92909: GREATEREQUAL
92910: IFFALSE 92873
// game_speed := 4 ;
92912: LD_ADDR_OWVAR 65
92916: PUSH
92917: LD_INT 4
92919: ST_TO_ADDR
// end ;
92920: PPOPN 1
92922: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
92923: LD_EXP 113
92927: PUSH
92928: LD_EXP 140
92932: AND
92933: IFFALSE 93079
92935: GO 92937
92937: DISABLE
92938: LD_INT 0
92940: PPUSH
92941: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92942: LD_ADDR_VAR 0 1
92946: PUSH
92947: LD_INT 22
92949: PUSH
92950: LD_OWVAR 2
92954: PUSH
92955: EMPTY
92956: LIST
92957: LIST
92958: PUSH
92959: LD_INT 2
92961: PUSH
92962: LD_INT 30
92964: PUSH
92965: LD_INT 0
92967: PUSH
92968: EMPTY
92969: LIST
92970: LIST
92971: PUSH
92972: LD_INT 30
92974: PUSH
92975: LD_INT 1
92977: PUSH
92978: EMPTY
92979: LIST
92980: LIST
92981: PUSH
92982: EMPTY
92983: LIST
92984: LIST
92985: LIST
92986: PUSH
92987: EMPTY
92988: LIST
92989: LIST
92990: PPUSH
92991: CALL_OW 69
92995: ST_TO_ADDR
// if not depot then
92996: LD_VAR 0 1
93000: NOT
93001: IFFALSE 93005
// exit ;
93003: GO 93079
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
93005: LD_ADDR_VAR 0 2
93009: PUSH
93010: LD_VAR 0 1
93014: PUSH
93015: LD_INT 1
93017: PPUSH
93018: LD_VAR 0 1
93022: PPUSH
93023: CALL_OW 12
93027: ARRAY
93028: PPUSH
93029: CALL_OW 274
93033: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
93034: LD_VAR 0 2
93038: PPUSH
93039: LD_INT 1
93041: PPUSH
93042: LD_INT 0
93044: PPUSH
93045: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
93049: LD_VAR 0 2
93053: PPUSH
93054: LD_INT 2
93056: PPUSH
93057: LD_INT 0
93059: PPUSH
93060: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
93064: LD_VAR 0 2
93068: PPUSH
93069: LD_INT 3
93071: PPUSH
93072: LD_INT 0
93074: PPUSH
93075: CALL_OW 277
// end ;
93079: PPOPN 2
93081: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
93082: LD_EXP 113
93086: PUSH
93087: LD_EXP 141
93091: AND
93092: IFFALSE 93189
93094: GO 93096
93096: DISABLE
93097: LD_INT 0
93099: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93100: LD_ADDR_VAR 0 1
93104: PUSH
93105: LD_INT 22
93107: PUSH
93108: LD_OWVAR 2
93112: PUSH
93113: EMPTY
93114: LIST
93115: LIST
93116: PUSH
93117: LD_INT 21
93119: PUSH
93120: LD_INT 1
93122: PUSH
93123: EMPTY
93124: LIST
93125: LIST
93126: PUSH
93127: LD_INT 3
93129: PUSH
93130: LD_INT 23
93132: PUSH
93133: LD_INT 0
93135: PUSH
93136: EMPTY
93137: LIST
93138: LIST
93139: PUSH
93140: EMPTY
93141: LIST
93142: LIST
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: LIST
93148: PPUSH
93149: CALL_OW 69
93153: ST_TO_ADDR
// if not tmp then
93154: LD_VAR 0 1
93158: NOT
93159: IFFALSE 93163
// exit ;
93161: GO 93189
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
93163: LD_VAR 0 1
93167: PUSH
93168: LD_INT 1
93170: PPUSH
93171: LD_VAR 0 1
93175: PPUSH
93176: CALL_OW 12
93180: ARRAY
93181: PPUSH
93182: LD_INT 200
93184: PPUSH
93185: CALL_OW 234
// end ;
93189: PPOPN 1
93191: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
93192: LD_EXP 113
93196: PUSH
93197: LD_EXP 142
93201: AND
93202: IFFALSE 93281
93204: GO 93206
93206: DISABLE
93207: LD_INT 0
93209: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
93210: LD_ADDR_VAR 0 1
93214: PUSH
93215: LD_INT 22
93217: PUSH
93218: LD_OWVAR 2
93222: PUSH
93223: EMPTY
93224: LIST
93225: LIST
93226: PUSH
93227: LD_INT 21
93229: PUSH
93230: LD_INT 2
93232: PUSH
93233: EMPTY
93234: LIST
93235: LIST
93236: PUSH
93237: EMPTY
93238: LIST
93239: LIST
93240: PPUSH
93241: CALL_OW 69
93245: ST_TO_ADDR
// if not tmp then
93246: LD_VAR 0 1
93250: NOT
93251: IFFALSE 93255
// exit ;
93253: GO 93281
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
93255: LD_VAR 0 1
93259: PUSH
93260: LD_INT 1
93262: PPUSH
93263: LD_VAR 0 1
93267: PPUSH
93268: CALL_OW 12
93272: ARRAY
93273: PPUSH
93274: LD_INT 60
93276: PPUSH
93277: CALL_OW 234
// end ;
93281: PPOPN 1
93283: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
93284: LD_EXP 113
93288: PUSH
93289: LD_EXP 143
93293: AND
93294: IFFALSE 93393
93296: GO 93298
93298: DISABLE
93299: LD_INT 0
93301: PPUSH
93302: PPUSH
// begin enable ;
93303: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
93304: LD_ADDR_VAR 0 1
93308: PUSH
93309: LD_INT 22
93311: PUSH
93312: LD_OWVAR 2
93316: PUSH
93317: EMPTY
93318: LIST
93319: LIST
93320: PUSH
93321: LD_INT 61
93323: PUSH
93324: EMPTY
93325: LIST
93326: PUSH
93327: LD_INT 33
93329: PUSH
93330: LD_INT 2
93332: PUSH
93333: EMPTY
93334: LIST
93335: LIST
93336: PUSH
93337: EMPTY
93338: LIST
93339: LIST
93340: LIST
93341: PPUSH
93342: CALL_OW 69
93346: ST_TO_ADDR
// if not tmp then
93347: LD_VAR 0 1
93351: NOT
93352: IFFALSE 93356
// exit ;
93354: GO 93393
// for i in tmp do
93356: LD_ADDR_VAR 0 2
93360: PUSH
93361: LD_VAR 0 1
93365: PUSH
93366: FOR_IN
93367: IFFALSE 93391
// if IsControledBy ( i ) then
93369: LD_VAR 0 2
93373: PPUSH
93374: CALL_OW 312
93378: IFFALSE 93389
// ComUnlink ( i ) ;
93380: LD_VAR 0 2
93384: PPUSH
93385: CALL_OW 136
93389: GO 93366
93391: POP
93392: POP
// end ;
93393: PPOPN 2
93395: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
93396: LD_EXP 113
93400: PUSH
93401: LD_EXP 144
93405: AND
93406: IFFALSE 93546
93408: GO 93410
93410: DISABLE
93411: LD_INT 0
93413: PPUSH
93414: PPUSH
// begin ToLua ( displayPowell(); ) ;
93415: LD_STRING displayPowell();
93417: PPUSH
93418: CALL_OW 559
// uc_side := 0 ;
93422: LD_ADDR_OWVAR 20
93426: PUSH
93427: LD_INT 0
93429: ST_TO_ADDR
// uc_nation := 2 ;
93430: LD_ADDR_OWVAR 21
93434: PUSH
93435: LD_INT 2
93437: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
93438: LD_ADDR_OWVAR 37
93442: PUSH
93443: LD_INT 14
93445: ST_TO_ADDR
// vc_engine := engine_siberite ;
93446: LD_ADDR_OWVAR 39
93450: PUSH
93451: LD_INT 3
93453: ST_TO_ADDR
// vc_control := control_apeman ;
93454: LD_ADDR_OWVAR 38
93458: PUSH
93459: LD_INT 5
93461: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
93462: LD_ADDR_OWVAR 40
93466: PUSH
93467: LD_INT 29
93469: ST_TO_ADDR
// un := CreateVehicle ;
93470: LD_ADDR_VAR 0 2
93474: PUSH
93475: CALL_OW 45
93479: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93480: LD_VAR 0 2
93484: PPUSH
93485: LD_INT 1
93487: PPUSH
93488: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
93492: LD_INT 35
93494: PPUSH
93495: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
93499: LD_VAR 0 2
93503: PPUSH
93504: LD_INT 22
93506: PUSH
93507: LD_OWVAR 2
93511: PUSH
93512: EMPTY
93513: LIST
93514: LIST
93515: PPUSH
93516: CALL_OW 69
93520: PPUSH
93521: LD_VAR 0 2
93525: PPUSH
93526: CALL_OW 74
93530: PPUSH
93531: CALL_OW 115
// until IsDead ( un ) ;
93535: LD_VAR 0 2
93539: PPUSH
93540: CALL_OW 301
93544: IFFALSE 93492
// end ;
93546: PPOPN 2
93548: END
// every 0 0$1 trigger StreamModeActive and sStu do
93549: LD_EXP 113
93553: PUSH
93554: LD_EXP 152
93558: AND
93559: IFFALSE 93575
93561: GO 93563
93563: DISABLE
// begin ToLua ( displayStucuk(); ) ;
93564: LD_STRING displayStucuk();
93566: PPUSH
93567: CALL_OW 559
// ResetFog ;
93571: CALL_OW 335
// end ;
93575: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
93576: LD_EXP 113
93580: PUSH
93581: LD_EXP 145
93585: AND
93586: IFFALSE 93727
93588: GO 93590
93590: DISABLE
93591: LD_INT 0
93593: PPUSH
93594: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93595: LD_ADDR_VAR 0 2
93599: PUSH
93600: LD_INT 22
93602: PUSH
93603: LD_OWVAR 2
93607: PUSH
93608: EMPTY
93609: LIST
93610: LIST
93611: PUSH
93612: LD_INT 21
93614: PUSH
93615: LD_INT 1
93617: PUSH
93618: EMPTY
93619: LIST
93620: LIST
93621: PUSH
93622: EMPTY
93623: LIST
93624: LIST
93625: PPUSH
93626: CALL_OW 69
93630: ST_TO_ADDR
// if not tmp then
93631: LD_VAR 0 2
93635: NOT
93636: IFFALSE 93640
// exit ;
93638: GO 93727
// un := tmp [ rand ( 1 , tmp ) ] ;
93640: LD_ADDR_VAR 0 1
93644: PUSH
93645: LD_VAR 0 2
93649: PUSH
93650: LD_INT 1
93652: PPUSH
93653: LD_VAR 0 2
93657: PPUSH
93658: CALL_OW 12
93662: ARRAY
93663: ST_TO_ADDR
// SetSide ( un , 0 ) ;
93664: LD_VAR 0 1
93668: PPUSH
93669: LD_INT 0
93671: PPUSH
93672: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
93676: LD_VAR 0 1
93680: PPUSH
93681: LD_OWVAR 3
93685: PUSH
93686: LD_VAR 0 1
93690: DIFF
93691: PPUSH
93692: LD_VAR 0 1
93696: PPUSH
93697: CALL_OW 74
93701: PPUSH
93702: CALL_OW 115
// wait ( 0 0$20 ) ;
93706: LD_INT 700
93708: PPUSH
93709: CALL_OW 67
// SetSide ( un , your_side ) ;
93713: LD_VAR 0 1
93717: PPUSH
93718: LD_OWVAR 2
93722: PPUSH
93723: CALL_OW 235
// end ;
93727: PPOPN 2
93729: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
93730: LD_EXP 113
93734: PUSH
93735: LD_EXP 146
93739: AND
93740: IFFALSE 93846
93742: GO 93744
93744: DISABLE
93745: LD_INT 0
93747: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93748: LD_ADDR_VAR 0 1
93752: PUSH
93753: LD_INT 22
93755: PUSH
93756: LD_OWVAR 2
93760: PUSH
93761: EMPTY
93762: LIST
93763: LIST
93764: PUSH
93765: LD_INT 2
93767: PUSH
93768: LD_INT 30
93770: PUSH
93771: LD_INT 0
93773: PUSH
93774: EMPTY
93775: LIST
93776: LIST
93777: PUSH
93778: LD_INT 30
93780: PUSH
93781: LD_INT 1
93783: PUSH
93784: EMPTY
93785: LIST
93786: LIST
93787: PUSH
93788: EMPTY
93789: LIST
93790: LIST
93791: LIST
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PPUSH
93797: CALL_OW 69
93801: ST_TO_ADDR
// if not depot then
93802: LD_VAR 0 1
93806: NOT
93807: IFFALSE 93811
// exit ;
93809: GO 93846
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
93811: LD_VAR 0 1
93815: PUSH
93816: LD_INT 1
93818: ARRAY
93819: PPUSH
93820: CALL_OW 250
93824: PPUSH
93825: LD_VAR 0 1
93829: PUSH
93830: LD_INT 1
93832: ARRAY
93833: PPUSH
93834: CALL_OW 251
93838: PPUSH
93839: LD_INT 70
93841: PPUSH
93842: CALL_OW 495
// end ;
93846: PPOPN 1
93848: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
93849: LD_EXP 113
93853: PUSH
93854: LD_EXP 147
93858: AND
93859: IFFALSE 94070
93861: GO 93863
93863: DISABLE
93864: LD_INT 0
93866: PPUSH
93867: PPUSH
93868: PPUSH
93869: PPUSH
93870: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93871: LD_ADDR_VAR 0 5
93875: PUSH
93876: LD_INT 22
93878: PUSH
93879: LD_OWVAR 2
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: PUSH
93888: LD_INT 21
93890: PUSH
93891: LD_INT 1
93893: PUSH
93894: EMPTY
93895: LIST
93896: LIST
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: PPUSH
93902: CALL_OW 69
93906: ST_TO_ADDR
// if not tmp then
93907: LD_VAR 0 5
93911: NOT
93912: IFFALSE 93916
// exit ;
93914: GO 94070
// for i in tmp do
93916: LD_ADDR_VAR 0 1
93920: PUSH
93921: LD_VAR 0 5
93925: PUSH
93926: FOR_IN
93927: IFFALSE 94068
// begin d := rand ( 0 , 5 ) ;
93929: LD_ADDR_VAR 0 4
93933: PUSH
93934: LD_INT 0
93936: PPUSH
93937: LD_INT 5
93939: PPUSH
93940: CALL_OW 12
93944: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
93945: LD_ADDR_VAR 0 2
93949: PUSH
93950: LD_VAR 0 1
93954: PPUSH
93955: CALL_OW 250
93959: PPUSH
93960: LD_VAR 0 4
93964: PPUSH
93965: LD_INT 3
93967: PPUSH
93968: LD_INT 12
93970: PPUSH
93971: CALL_OW 12
93975: PPUSH
93976: CALL_OW 272
93980: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
93981: LD_ADDR_VAR 0 3
93985: PUSH
93986: LD_VAR 0 1
93990: PPUSH
93991: CALL_OW 251
93995: PPUSH
93996: LD_VAR 0 4
94000: PPUSH
94001: LD_INT 3
94003: PPUSH
94004: LD_INT 12
94006: PPUSH
94007: CALL_OW 12
94011: PPUSH
94012: CALL_OW 273
94016: ST_TO_ADDR
// if ValidHex ( x , y ) then
94017: LD_VAR 0 2
94021: PPUSH
94022: LD_VAR 0 3
94026: PPUSH
94027: CALL_OW 488
94031: IFFALSE 94066
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
94033: LD_VAR 0 1
94037: PPUSH
94038: LD_VAR 0 2
94042: PPUSH
94043: LD_VAR 0 3
94047: PPUSH
94048: LD_INT 3
94050: PPUSH
94051: LD_INT 6
94053: PPUSH
94054: CALL_OW 12
94058: PPUSH
94059: LD_INT 1
94061: PPUSH
94062: CALL_OW 483
// end ;
94066: GO 93926
94068: POP
94069: POP
// end ;
94070: PPOPN 5
94072: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
94073: LD_EXP 113
94077: PUSH
94078: LD_EXP 148
94082: AND
94083: IFFALSE 94177
94085: GO 94087
94087: DISABLE
94088: LD_INT 0
94090: PPUSH
94091: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
94092: LD_ADDR_VAR 0 2
94096: PUSH
94097: LD_INT 22
94099: PUSH
94100: LD_OWVAR 2
94104: PUSH
94105: EMPTY
94106: LIST
94107: LIST
94108: PUSH
94109: LD_INT 32
94111: PUSH
94112: LD_INT 1
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: PUSH
94119: LD_INT 21
94121: PUSH
94122: LD_INT 2
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: PUSH
94129: EMPTY
94130: LIST
94131: LIST
94132: LIST
94133: PPUSH
94134: CALL_OW 69
94138: ST_TO_ADDR
// if not tmp then
94139: LD_VAR 0 2
94143: NOT
94144: IFFALSE 94148
// exit ;
94146: GO 94177
// for i in tmp do
94148: LD_ADDR_VAR 0 1
94152: PUSH
94153: LD_VAR 0 2
94157: PUSH
94158: FOR_IN
94159: IFFALSE 94175
// SetFuel ( i , 0 ) ;
94161: LD_VAR 0 1
94165: PPUSH
94166: LD_INT 0
94168: PPUSH
94169: CALL_OW 240
94173: GO 94158
94175: POP
94176: POP
// end ;
94177: PPOPN 2
94179: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
94180: LD_EXP 113
94184: PUSH
94185: LD_EXP 149
94189: AND
94190: IFFALSE 94256
94192: GO 94194
94194: DISABLE
94195: LD_INT 0
94197: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
94198: LD_ADDR_VAR 0 1
94202: PUSH
94203: LD_INT 22
94205: PUSH
94206: LD_OWVAR 2
94210: PUSH
94211: EMPTY
94212: LIST
94213: LIST
94214: PUSH
94215: LD_INT 30
94217: PUSH
94218: LD_INT 29
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: PUSH
94225: EMPTY
94226: LIST
94227: LIST
94228: PPUSH
94229: CALL_OW 69
94233: ST_TO_ADDR
// if not tmp then
94234: LD_VAR 0 1
94238: NOT
94239: IFFALSE 94243
// exit ;
94241: GO 94256
// DestroyUnit ( tmp [ 1 ] ) ;
94243: LD_VAR 0 1
94247: PUSH
94248: LD_INT 1
94250: ARRAY
94251: PPUSH
94252: CALL_OW 65
// end ;
94256: PPOPN 1
94258: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
94259: LD_EXP 113
94263: PUSH
94264: LD_EXP 151
94268: AND
94269: IFFALSE 94398
94271: GO 94273
94273: DISABLE
94274: LD_INT 0
94276: PPUSH
// begin uc_side := 0 ;
94277: LD_ADDR_OWVAR 20
94281: PUSH
94282: LD_INT 0
94284: ST_TO_ADDR
// uc_nation := nation_arabian ;
94285: LD_ADDR_OWVAR 21
94289: PUSH
94290: LD_INT 2
94292: ST_TO_ADDR
// hc_gallery :=  ;
94293: LD_ADDR_OWVAR 33
94297: PUSH
94298: LD_STRING 
94300: ST_TO_ADDR
// hc_name :=  ;
94301: LD_ADDR_OWVAR 26
94305: PUSH
94306: LD_STRING 
94308: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
94309: LD_INT 1
94311: PPUSH
94312: LD_INT 11
94314: PPUSH
94315: LD_INT 10
94317: PPUSH
94318: CALL_OW 380
// un := CreateHuman ;
94322: LD_ADDR_VAR 0 1
94326: PUSH
94327: CALL_OW 44
94331: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94332: LD_VAR 0 1
94336: PPUSH
94337: LD_INT 1
94339: PPUSH
94340: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94344: LD_INT 35
94346: PPUSH
94347: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94351: LD_VAR 0 1
94355: PPUSH
94356: LD_INT 22
94358: PUSH
94359: LD_OWVAR 2
94363: PUSH
94364: EMPTY
94365: LIST
94366: LIST
94367: PPUSH
94368: CALL_OW 69
94372: PPUSH
94373: LD_VAR 0 1
94377: PPUSH
94378: CALL_OW 74
94382: PPUSH
94383: CALL_OW 115
// until IsDead ( un ) ;
94387: LD_VAR 0 1
94391: PPUSH
94392: CALL_OW 301
94396: IFFALSE 94344
// end ;
94398: PPOPN 1
94400: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
94401: LD_EXP 113
94405: PUSH
94406: LD_EXP 153
94410: AND
94411: IFFALSE 94423
94413: GO 94415
94415: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
94416: LD_STRING earthquake(getX(game), 0, 32)
94418: PPUSH
94419: CALL_OW 559
94423: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
94424: LD_EXP 113
94428: PUSH
94429: LD_EXP 154
94433: AND
94434: IFFALSE 94525
94436: GO 94438
94438: DISABLE
94439: LD_INT 0
94441: PPUSH
// begin enable ;
94442: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
94443: LD_ADDR_VAR 0 1
94447: PUSH
94448: LD_INT 22
94450: PUSH
94451: LD_OWVAR 2
94455: PUSH
94456: EMPTY
94457: LIST
94458: LIST
94459: PUSH
94460: LD_INT 21
94462: PUSH
94463: LD_INT 2
94465: PUSH
94466: EMPTY
94467: LIST
94468: LIST
94469: PUSH
94470: LD_INT 33
94472: PUSH
94473: LD_INT 3
94475: PUSH
94476: EMPTY
94477: LIST
94478: LIST
94479: PUSH
94480: EMPTY
94481: LIST
94482: LIST
94483: LIST
94484: PPUSH
94485: CALL_OW 69
94489: ST_TO_ADDR
// if not tmp then
94490: LD_VAR 0 1
94494: NOT
94495: IFFALSE 94499
// exit ;
94497: GO 94525
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
94499: LD_VAR 0 1
94503: PUSH
94504: LD_INT 1
94506: PPUSH
94507: LD_VAR 0 1
94511: PPUSH
94512: CALL_OW 12
94516: ARRAY
94517: PPUSH
94518: LD_INT 1
94520: PPUSH
94521: CALL_OW 234
// end ;
94525: PPOPN 1
94527: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
94528: LD_EXP 113
94532: PUSH
94533: LD_EXP 155
94537: AND
94538: IFFALSE 94679
94540: GO 94542
94542: DISABLE
94543: LD_INT 0
94545: PPUSH
94546: PPUSH
94547: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94548: LD_ADDR_VAR 0 3
94552: PUSH
94553: LD_INT 22
94555: PUSH
94556: LD_OWVAR 2
94560: PUSH
94561: EMPTY
94562: LIST
94563: LIST
94564: PUSH
94565: LD_INT 25
94567: PUSH
94568: LD_INT 1
94570: PUSH
94571: EMPTY
94572: LIST
94573: LIST
94574: PUSH
94575: EMPTY
94576: LIST
94577: LIST
94578: PPUSH
94579: CALL_OW 69
94583: ST_TO_ADDR
// if not tmp then
94584: LD_VAR 0 3
94588: NOT
94589: IFFALSE 94593
// exit ;
94591: GO 94679
// un := tmp [ rand ( 1 , tmp ) ] ;
94593: LD_ADDR_VAR 0 2
94597: PUSH
94598: LD_VAR 0 3
94602: PUSH
94603: LD_INT 1
94605: PPUSH
94606: LD_VAR 0 3
94610: PPUSH
94611: CALL_OW 12
94615: ARRAY
94616: ST_TO_ADDR
// if Crawls ( un ) then
94617: LD_VAR 0 2
94621: PPUSH
94622: CALL_OW 318
94626: IFFALSE 94637
// ComWalk ( un ) ;
94628: LD_VAR 0 2
94632: PPUSH
94633: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
94637: LD_VAR 0 2
94641: PPUSH
94642: LD_INT 9
94644: PPUSH
94645: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
94649: LD_INT 28
94651: PPUSH
94652: LD_OWVAR 2
94656: PPUSH
94657: LD_INT 2
94659: PPUSH
94660: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
94664: LD_INT 29
94666: PPUSH
94667: LD_OWVAR 2
94671: PPUSH
94672: LD_INT 2
94674: PPUSH
94675: CALL_OW 322
// end ;
94679: PPOPN 3
94681: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
94682: LD_EXP 113
94686: PUSH
94687: LD_EXP 156
94691: AND
94692: IFFALSE 94803
94694: GO 94696
94696: DISABLE
94697: LD_INT 0
94699: PPUSH
94700: PPUSH
94701: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94702: LD_ADDR_VAR 0 3
94706: PUSH
94707: LD_INT 22
94709: PUSH
94710: LD_OWVAR 2
94714: PUSH
94715: EMPTY
94716: LIST
94717: LIST
94718: PUSH
94719: LD_INT 25
94721: PUSH
94722: LD_INT 1
94724: PUSH
94725: EMPTY
94726: LIST
94727: LIST
94728: PUSH
94729: EMPTY
94730: LIST
94731: LIST
94732: PPUSH
94733: CALL_OW 69
94737: ST_TO_ADDR
// if not tmp then
94738: LD_VAR 0 3
94742: NOT
94743: IFFALSE 94747
// exit ;
94745: GO 94803
// un := tmp [ rand ( 1 , tmp ) ] ;
94747: LD_ADDR_VAR 0 2
94751: PUSH
94752: LD_VAR 0 3
94756: PUSH
94757: LD_INT 1
94759: PPUSH
94760: LD_VAR 0 3
94764: PPUSH
94765: CALL_OW 12
94769: ARRAY
94770: ST_TO_ADDR
// if Crawls ( un ) then
94771: LD_VAR 0 2
94775: PPUSH
94776: CALL_OW 318
94780: IFFALSE 94791
// ComWalk ( un ) ;
94782: LD_VAR 0 2
94786: PPUSH
94787: CALL_OW 138
// SetClass ( un , class_mortar ) ;
94791: LD_VAR 0 2
94795: PPUSH
94796: LD_INT 8
94798: PPUSH
94799: CALL_OW 336
// end ;
94803: PPOPN 3
94805: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
94806: LD_EXP 113
94810: PUSH
94811: LD_EXP 157
94815: AND
94816: IFFALSE 94960
94818: GO 94820
94820: DISABLE
94821: LD_INT 0
94823: PPUSH
94824: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
94825: LD_ADDR_VAR 0 2
94829: PUSH
94830: LD_INT 22
94832: PUSH
94833: LD_OWVAR 2
94837: PUSH
94838: EMPTY
94839: LIST
94840: LIST
94841: PUSH
94842: LD_INT 21
94844: PUSH
94845: LD_INT 2
94847: PUSH
94848: EMPTY
94849: LIST
94850: LIST
94851: PUSH
94852: LD_INT 2
94854: PUSH
94855: LD_INT 34
94857: PUSH
94858: LD_INT 12
94860: PUSH
94861: EMPTY
94862: LIST
94863: LIST
94864: PUSH
94865: LD_INT 34
94867: PUSH
94868: LD_INT 51
94870: PUSH
94871: EMPTY
94872: LIST
94873: LIST
94874: PUSH
94875: LD_INT 34
94877: PUSH
94878: LD_INT 32
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: PUSH
94885: EMPTY
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: PUSH
94891: EMPTY
94892: LIST
94893: LIST
94894: LIST
94895: PPUSH
94896: CALL_OW 69
94900: ST_TO_ADDR
// if not tmp then
94901: LD_VAR 0 2
94905: NOT
94906: IFFALSE 94910
// exit ;
94908: GO 94960
// for i in tmp do
94910: LD_ADDR_VAR 0 1
94914: PUSH
94915: LD_VAR 0 2
94919: PUSH
94920: FOR_IN
94921: IFFALSE 94958
// if GetCargo ( i , mat_artifact ) = 0 then
94923: LD_VAR 0 1
94927: PPUSH
94928: LD_INT 4
94930: PPUSH
94931: CALL_OW 289
94935: PUSH
94936: LD_INT 0
94938: EQUAL
94939: IFFALSE 94956
// SetCargo ( i , mat_siberit , 100 ) ;
94941: LD_VAR 0 1
94945: PPUSH
94946: LD_INT 3
94948: PPUSH
94949: LD_INT 100
94951: PPUSH
94952: CALL_OW 290
94956: GO 94920
94958: POP
94959: POP
// end ;
94960: PPOPN 2
94962: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
94963: LD_EXP 113
94967: PUSH
94968: LD_EXP 158
94972: AND
94973: IFFALSE 95156
94975: GO 94977
94977: DISABLE
94978: LD_INT 0
94980: PPUSH
94981: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
94982: LD_ADDR_VAR 0 2
94986: PUSH
94987: LD_INT 22
94989: PUSH
94990: LD_OWVAR 2
94994: PUSH
94995: EMPTY
94996: LIST
94997: LIST
94998: PPUSH
94999: CALL_OW 69
95003: ST_TO_ADDR
// if not tmp then
95004: LD_VAR 0 2
95008: NOT
95009: IFFALSE 95013
// exit ;
95011: GO 95156
// for i := 1 to 2 do
95013: LD_ADDR_VAR 0 1
95017: PUSH
95018: DOUBLE
95019: LD_INT 1
95021: DEC
95022: ST_TO_ADDR
95023: LD_INT 2
95025: PUSH
95026: FOR_TO
95027: IFFALSE 95154
// begin uc_side := your_side ;
95029: LD_ADDR_OWVAR 20
95033: PUSH
95034: LD_OWVAR 2
95038: ST_TO_ADDR
// uc_nation := nation_american ;
95039: LD_ADDR_OWVAR 21
95043: PUSH
95044: LD_INT 1
95046: ST_TO_ADDR
// vc_chassis := us_morphling ;
95047: LD_ADDR_OWVAR 37
95051: PUSH
95052: LD_INT 5
95054: ST_TO_ADDR
// vc_engine := engine_siberite ;
95055: LD_ADDR_OWVAR 39
95059: PUSH
95060: LD_INT 3
95062: ST_TO_ADDR
// vc_control := control_computer ;
95063: LD_ADDR_OWVAR 38
95067: PUSH
95068: LD_INT 3
95070: ST_TO_ADDR
// vc_weapon := us_double_laser ;
95071: LD_ADDR_OWVAR 40
95075: PUSH
95076: LD_INT 10
95078: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
95079: LD_VAR 0 2
95083: PUSH
95084: LD_INT 1
95086: ARRAY
95087: PPUSH
95088: CALL_OW 310
95092: NOT
95093: IFFALSE 95140
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
95095: CALL_OW 45
95099: PPUSH
95100: LD_VAR 0 2
95104: PUSH
95105: LD_INT 1
95107: ARRAY
95108: PPUSH
95109: CALL_OW 250
95113: PPUSH
95114: LD_VAR 0 2
95118: PUSH
95119: LD_INT 1
95121: ARRAY
95122: PPUSH
95123: CALL_OW 251
95127: PPUSH
95128: LD_INT 12
95130: PPUSH
95131: LD_INT 1
95133: PPUSH
95134: CALL_OW 50
95138: GO 95152
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
95140: CALL_OW 45
95144: PPUSH
95145: LD_INT 1
95147: PPUSH
95148: CALL_OW 51
// end ;
95152: GO 95026
95154: POP
95155: POP
// end ;
95156: PPOPN 2
95158: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
95159: LD_EXP 113
95163: PUSH
95164: LD_EXP 159
95168: AND
95169: IFFALSE 95391
95171: GO 95173
95173: DISABLE
95174: LD_INT 0
95176: PPUSH
95177: PPUSH
95178: PPUSH
95179: PPUSH
95180: PPUSH
95181: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95182: LD_ADDR_VAR 0 6
95186: PUSH
95187: LD_INT 22
95189: PUSH
95190: LD_OWVAR 2
95194: PUSH
95195: EMPTY
95196: LIST
95197: LIST
95198: PUSH
95199: LD_INT 21
95201: PUSH
95202: LD_INT 1
95204: PUSH
95205: EMPTY
95206: LIST
95207: LIST
95208: PUSH
95209: LD_INT 3
95211: PUSH
95212: LD_INT 23
95214: PUSH
95215: LD_INT 0
95217: PUSH
95218: EMPTY
95219: LIST
95220: LIST
95221: PUSH
95222: EMPTY
95223: LIST
95224: LIST
95225: PUSH
95226: EMPTY
95227: LIST
95228: LIST
95229: LIST
95230: PPUSH
95231: CALL_OW 69
95235: ST_TO_ADDR
// if not tmp then
95236: LD_VAR 0 6
95240: NOT
95241: IFFALSE 95245
// exit ;
95243: GO 95391
// s1 := rand ( 1 , 4 ) ;
95245: LD_ADDR_VAR 0 2
95249: PUSH
95250: LD_INT 1
95252: PPUSH
95253: LD_INT 4
95255: PPUSH
95256: CALL_OW 12
95260: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
95261: LD_ADDR_VAR 0 4
95265: PUSH
95266: LD_VAR 0 6
95270: PUSH
95271: LD_INT 1
95273: ARRAY
95274: PPUSH
95275: LD_VAR 0 2
95279: PPUSH
95280: CALL_OW 259
95284: ST_TO_ADDR
// if s1 = 1 then
95285: LD_VAR 0 2
95289: PUSH
95290: LD_INT 1
95292: EQUAL
95293: IFFALSE 95313
// s2 := rand ( 2 , 4 ) else
95295: LD_ADDR_VAR 0 3
95299: PUSH
95300: LD_INT 2
95302: PPUSH
95303: LD_INT 4
95305: PPUSH
95306: CALL_OW 12
95310: ST_TO_ADDR
95311: GO 95321
// s2 := 1 ;
95313: LD_ADDR_VAR 0 3
95317: PUSH
95318: LD_INT 1
95320: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
95321: LD_ADDR_VAR 0 5
95325: PUSH
95326: LD_VAR 0 6
95330: PUSH
95331: LD_INT 1
95333: ARRAY
95334: PPUSH
95335: LD_VAR 0 3
95339: PPUSH
95340: CALL_OW 259
95344: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
95345: LD_VAR 0 6
95349: PUSH
95350: LD_INT 1
95352: ARRAY
95353: PPUSH
95354: LD_VAR 0 2
95358: PPUSH
95359: LD_VAR 0 5
95363: PPUSH
95364: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
95368: LD_VAR 0 6
95372: PUSH
95373: LD_INT 1
95375: ARRAY
95376: PPUSH
95377: LD_VAR 0 3
95381: PPUSH
95382: LD_VAR 0 4
95386: PPUSH
95387: CALL_OW 237
// end ;
95391: PPOPN 6
95393: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
95394: LD_EXP 113
95398: PUSH
95399: LD_EXP 160
95403: AND
95404: IFFALSE 95483
95406: GO 95408
95408: DISABLE
95409: LD_INT 0
95411: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
95412: LD_ADDR_VAR 0 1
95416: PUSH
95417: LD_INT 22
95419: PUSH
95420: LD_OWVAR 2
95424: PUSH
95425: EMPTY
95426: LIST
95427: LIST
95428: PUSH
95429: LD_INT 30
95431: PUSH
95432: LD_INT 3
95434: PUSH
95435: EMPTY
95436: LIST
95437: LIST
95438: PUSH
95439: EMPTY
95440: LIST
95441: LIST
95442: PPUSH
95443: CALL_OW 69
95447: ST_TO_ADDR
// if not tmp then
95448: LD_VAR 0 1
95452: NOT
95453: IFFALSE 95457
// exit ;
95455: GO 95483
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
95457: LD_VAR 0 1
95461: PUSH
95462: LD_INT 1
95464: PPUSH
95465: LD_VAR 0 1
95469: PPUSH
95470: CALL_OW 12
95474: ARRAY
95475: PPUSH
95476: LD_INT 1
95478: PPUSH
95479: CALL_OW 234
// end ;
95483: PPOPN 1
95485: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
95486: LD_EXP 113
95490: PUSH
95491: LD_EXP 161
95495: AND
95496: IFFALSE 95608
95498: GO 95500
95500: DISABLE
95501: LD_INT 0
95503: PPUSH
95504: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
95505: LD_ADDR_VAR 0 2
95509: PUSH
95510: LD_INT 22
95512: PUSH
95513: LD_OWVAR 2
95517: PUSH
95518: EMPTY
95519: LIST
95520: LIST
95521: PUSH
95522: LD_INT 2
95524: PUSH
95525: LD_INT 30
95527: PUSH
95528: LD_INT 27
95530: PUSH
95531: EMPTY
95532: LIST
95533: LIST
95534: PUSH
95535: LD_INT 30
95537: PUSH
95538: LD_INT 26
95540: PUSH
95541: EMPTY
95542: LIST
95543: LIST
95544: PUSH
95545: LD_INT 30
95547: PUSH
95548: LD_INT 28
95550: PUSH
95551: EMPTY
95552: LIST
95553: LIST
95554: PUSH
95555: EMPTY
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: PUSH
95561: EMPTY
95562: LIST
95563: LIST
95564: PPUSH
95565: CALL_OW 69
95569: ST_TO_ADDR
// if not tmp then
95570: LD_VAR 0 2
95574: NOT
95575: IFFALSE 95579
// exit ;
95577: GO 95608
// for i in tmp do
95579: LD_ADDR_VAR 0 1
95583: PUSH
95584: LD_VAR 0 2
95588: PUSH
95589: FOR_IN
95590: IFFALSE 95606
// SetLives ( i , 1 ) ;
95592: LD_VAR 0 1
95596: PPUSH
95597: LD_INT 1
95599: PPUSH
95600: CALL_OW 234
95604: GO 95589
95606: POP
95607: POP
// end ;
95608: PPOPN 2
95610: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
95611: LD_EXP 113
95615: PUSH
95616: LD_EXP 162
95620: AND
95621: IFFALSE 95908
95623: GO 95625
95625: DISABLE
95626: LD_INT 0
95628: PPUSH
95629: PPUSH
95630: PPUSH
// begin i := rand ( 1 , 7 ) ;
95631: LD_ADDR_VAR 0 1
95635: PUSH
95636: LD_INT 1
95638: PPUSH
95639: LD_INT 7
95641: PPUSH
95642: CALL_OW 12
95646: ST_TO_ADDR
// case i of 1 :
95647: LD_VAR 0 1
95651: PUSH
95652: LD_INT 1
95654: DOUBLE
95655: EQUAL
95656: IFTRUE 95660
95658: GO 95670
95660: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
95661: LD_STRING earthquake(getX(game), 0, 32)
95663: PPUSH
95664: CALL_OW 559
95668: GO 95908
95670: LD_INT 2
95672: DOUBLE
95673: EQUAL
95674: IFTRUE 95678
95676: GO 95692
95678: POP
// begin ToLua ( displayStucuk(); ) ;
95679: LD_STRING displayStucuk();
95681: PPUSH
95682: CALL_OW 559
// ResetFog ;
95686: CALL_OW 335
// end ; 3 :
95690: GO 95908
95692: LD_INT 3
95694: DOUBLE
95695: EQUAL
95696: IFTRUE 95700
95698: GO 95804
95700: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95701: LD_ADDR_VAR 0 2
95705: PUSH
95706: LD_INT 22
95708: PUSH
95709: LD_OWVAR 2
95713: PUSH
95714: EMPTY
95715: LIST
95716: LIST
95717: PUSH
95718: LD_INT 25
95720: PUSH
95721: LD_INT 1
95723: PUSH
95724: EMPTY
95725: LIST
95726: LIST
95727: PUSH
95728: EMPTY
95729: LIST
95730: LIST
95731: PPUSH
95732: CALL_OW 69
95736: ST_TO_ADDR
// if not tmp then
95737: LD_VAR 0 2
95741: NOT
95742: IFFALSE 95746
// exit ;
95744: GO 95908
// un := tmp [ rand ( 1 , tmp ) ] ;
95746: LD_ADDR_VAR 0 3
95750: PUSH
95751: LD_VAR 0 2
95755: PUSH
95756: LD_INT 1
95758: PPUSH
95759: LD_VAR 0 2
95763: PPUSH
95764: CALL_OW 12
95768: ARRAY
95769: ST_TO_ADDR
// if Crawls ( un ) then
95770: LD_VAR 0 3
95774: PPUSH
95775: CALL_OW 318
95779: IFFALSE 95790
// ComWalk ( un ) ;
95781: LD_VAR 0 3
95785: PPUSH
95786: CALL_OW 138
// SetClass ( un , class_mortar ) ;
95790: LD_VAR 0 3
95794: PPUSH
95795: LD_INT 8
95797: PPUSH
95798: CALL_OW 336
// end ; 4 :
95802: GO 95908
95804: LD_INT 4
95806: DOUBLE
95807: EQUAL
95808: IFTRUE 95812
95810: GO 95886
95812: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95813: LD_ADDR_VAR 0 2
95817: PUSH
95818: LD_INT 22
95820: PUSH
95821: LD_OWVAR 2
95825: PUSH
95826: EMPTY
95827: LIST
95828: LIST
95829: PUSH
95830: LD_INT 30
95832: PUSH
95833: LD_INT 29
95835: PUSH
95836: EMPTY
95837: LIST
95838: LIST
95839: PUSH
95840: EMPTY
95841: LIST
95842: LIST
95843: PPUSH
95844: CALL_OW 69
95848: ST_TO_ADDR
// if not tmp then
95849: LD_VAR 0 2
95853: NOT
95854: IFFALSE 95858
// exit ;
95856: GO 95908
// CenterNowOnUnits ( tmp [ 1 ] ) ;
95858: LD_VAR 0 2
95862: PUSH
95863: LD_INT 1
95865: ARRAY
95866: PPUSH
95867: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
95871: LD_VAR 0 2
95875: PUSH
95876: LD_INT 1
95878: ARRAY
95879: PPUSH
95880: CALL_OW 65
// end ; 5 .. 7 :
95884: GO 95908
95886: LD_INT 5
95888: DOUBLE
95889: GREATEREQUAL
95890: IFFALSE 95898
95892: LD_INT 7
95894: DOUBLE
95895: LESSEQUAL
95896: IFTRUE 95900
95898: GO 95907
95900: POP
// StreamSibBomb ; end ;
95901: CALL 92145 0 0
95905: GO 95908
95907: POP
// end ;
95908: PPOPN 3
95910: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
95911: LD_EXP 113
95915: PUSH
95916: LD_EXP 163
95920: AND
95921: IFFALSE 96077
95923: GO 95925
95925: DISABLE
95926: LD_INT 0
95928: PPUSH
95929: PPUSH
95930: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
95931: LD_ADDR_VAR 0 2
95935: PUSH
95936: LD_INT 81
95938: PUSH
95939: LD_OWVAR 2
95943: PUSH
95944: EMPTY
95945: LIST
95946: LIST
95947: PUSH
95948: LD_INT 2
95950: PUSH
95951: LD_INT 21
95953: PUSH
95954: LD_INT 1
95956: PUSH
95957: EMPTY
95958: LIST
95959: LIST
95960: PUSH
95961: LD_INT 21
95963: PUSH
95964: LD_INT 2
95966: PUSH
95967: EMPTY
95968: LIST
95969: LIST
95970: PUSH
95971: EMPTY
95972: LIST
95973: LIST
95974: LIST
95975: PUSH
95976: EMPTY
95977: LIST
95978: LIST
95979: PPUSH
95980: CALL_OW 69
95984: ST_TO_ADDR
// if not tmp then
95985: LD_VAR 0 2
95989: NOT
95990: IFFALSE 95994
// exit ;
95992: GO 96077
// p := 0 ;
95994: LD_ADDR_VAR 0 3
95998: PUSH
95999: LD_INT 0
96001: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
96002: LD_INT 35
96004: PPUSH
96005: CALL_OW 67
// p := p + 1 ;
96009: LD_ADDR_VAR 0 3
96013: PUSH
96014: LD_VAR 0 3
96018: PUSH
96019: LD_INT 1
96021: PLUS
96022: ST_TO_ADDR
// for i in tmp do
96023: LD_ADDR_VAR 0 1
96027: PUSH
96028: LD_VAR 0 2
96032: PUSH
96033: FOR_IN
96034: IFFALSE 96065
// if GetLives ( i ) < 1000 then
96036: LD_VAR 0 1
96040: PPUSH
96041: CALL_OW 256
96045: PUSH
96046: LD_INT 1000
96048: LESS
96049: IFFALSE 96063
// SetLives ( i , 1000 ) ;
96051: LD_VAR 0 1
96055: PPUSH
96056: LD_INT 1000
96058: PPUSH
96059: CALL_OW 234
96063: GO 96033
96065: POP
96066: POP
// until p > 20 ;
96067: LD_VAR 0 3
96071: PUSH
96072: LD_INT 20
96074: GREATER
96075: IFFALSE 96002
// end ;
96077: PPOPN 3
96079: END
// every 0 0$1 trigger StreamModeActive and sTime do
96080: LD_EXP 113
96084: PUSH
96085: LD_EXP 164
96089: AND
96090: IFFALSE 96125
96092: GO 96094
96094: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
96095: LD_INT 28
96097: PPUSH
96098: LD_OWVAR 2
96102: PPUSH
96103: LD_INT 2
96105: PPUSH
96106: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
96110: LD_INT 30
96112: PPUSH
96113: LD_OWVAR 2
96117: PPUSH
96118: LD_INT 2
96120: PPUSH
96121: CALL_OW 322
// end ;
96125: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
96126: LD_EXP 113
96130: PUSH
96131: LD_EXP 165
96135: AND
96136: IFFALSE 96257
96138: GO 96140
96140: DISABLE
96141: LD_INT 0
96143: PPUSH
96144: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96145: LD_ADDR_VAR 0 2
96149: PUSH
96150: LD_INT 22
96152: PUSH
96153: LD_OWVAR 2
96157: PUSH
96158: EMPTY
96159: LIST
96160: LIST
96161: PUSH
96162: LD_INT 21
96164: PUSH
96165: LD_INT 1
96167: PUSH
96168: EMPTY
96169: LIST
96170: LIST
96171: PUSH
96172: LD_INT 3
96174: PUSH
96175: LD_INT 23
96177: PUSH
96178: LD_INT 0
96180: PUSH
96181: EMPTY
96182: LIST
96183: LIST
96184: PUSH
96185: EMPTY
96186: LIST
96187: LIST
96188: PUSH
96189: EMPTY
96190: LIST
96191: LIST
96192: LIST
96193: PPUSH
96194: CALL_OW 69
96198: ST_TO_ADDR
// if not tmp then
96199: LD_VAR 0 2
96203: NOT
96204: IFFALSE 96208
// exit ;
96206: GO 96257
// for i in tmp do
96208: LD_ADDR_VAR 0 1
96212: PUSH
96213: LD_VAR 0 2
96217: PUSH
96218: FOR_IN
96219: IFFALSE 96255
// begin if Crawls ( i ) then
96221: LD_VAR 0 1
96225: PPUSH
96226: CALL_OW 318
96230: IFFALSE 96241
// ComWalk ( i ) ;
96232: LD_VAR 0 1
96236: PPUSH
96237: CALL_OW 138
// SetClass ( i , 2 ) ;
96241: LD_VAR 0 1
96245: PPUSH
96246: LD_INT 2
96248: PPUSH
96249: CALL_OW 336
// end ;
96253: GO 96218
96255: POP
96256: POP
// end ;
96257: PPOPN 2
96259: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
96260: LD_EXP 113
96264: PUSH
96265: LD_EXP 166
96269: AND
96270: IFFALSE 96558
96272: GO 96274
96274: DISABLE
96275: LD_INT 0
96277: PPUSH
96278: PPUSH
96279: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
96280: LD_OWVAR 2
96284: PPUSH
96285: LD_INT 9
96287: PPUSH
96288: LD_INT 1
96290: PPUSH
96291: LD_INT 1
96293: PPUSH
96294: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
96298: LD_INT 9
96300: PPUSH
96301: LD_OWVAR 2
96305: PPUSH
96306: CALL_OW 343
// uc_side := 9 ;
96310: LD_ADDR_OWVAR 20
96314: PUSH
96315: LD_INT 9
96317: ST_TO_ADDR
// uc_nation := 2 ;
96318: LD_ADDR_OWVAR 21
96322: PUSH
96323: LD_INT 2
96325: ST_TO_ADDR
// hc_name := Dark Warrior ;
96326: LD_ADDR_OWVAR 26
96330: PUSH
96331: LD_STRING Dark Warrior
96333: ST_TO_ADDR
// hc_gallery :=  ;
96334: LD_ADDR_OWVAR 33
96338: PUSH
96339: LD_STRING 
96341: ST_TO_ADDR
// hc_noskilllimit := true ;
96342: LD_ADDR_OWVAR 76
96346: PUSH
96347: LD_INT 1
96349: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
96350: LD_ADDR_OWVAR 31
96354: PUSH
96355: LD_INT 30
96357: PUSH
96358: LD_INT 30
96360: PUSH
96361: LD_INT 30
96363: PUSH
96364: LD_INT 30
96366: PUSH
96367: EMPTY
96368: LIST
96369: LIST
96370: LIST
96371: LIST
96372: ST_TO_ADDR
// un := CreateHuman ;
96373: LD_ADDR_VAR 0 3
96377: PUSH
96378: CALL_OW 44
96382: ST_TO_ADDR
// hc_noskilllimit := false ;
96383: LD_ADDR_OWVAR 76
96387: PUSH
96388: LD_INT 0
96390: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96391: LD_VAR 0 3
96395: PPUSH
96396: LD_INT 1
96398: PPUSH
96399: CALL_OW 51
// ToLua ( playRanger() ) ;
96403: LD_STRING playRanger()
96405: PPUSH
96406: CALL_OW 559
// p := 0 ;
96410: LD_ADDR_VAR 0 2
96414: PUSH
96415: LD_INT 0
96417: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
96418: LD_INT 35
96420: PPUSH
96421: CALL_OW 67
// p := p + 1 ;
96425: LD_ADDR_VAR 0 2
96429: PUSH
96430: LD_VAR 0 2
96434: PUSH
96435: LD_INT 1
96437: PLUS
96438: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
96439: LD_VAR 0 3
96443: PPUSH
96444: CALL_OW 256
96448: PUSH
96449: LD_INT 1000
96451: LESS
96452: IFFALSE 96466
// SetLives ( un , 1000 ) ;
96454: LD_VAR 0 3
96458: PPUSH
96459: LD_INT 1000
96461: PPUSH
96462: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
96466: LD_VAR 0 3
96470: PPUSH
96471: LD_INT 81
96473: PUSH
96474: LD_OWVAR 2
96478: PUSH
96479: EMPTY
96480: LIST
96481: LIST
96482: PUSH
96483: LD_INT 91
96485: PUSH
96486: LD_VAR 0 3
96490: PUSH
96491: LD_INT 30
96493: PUSH
96494: EMPTY
96495: LIST
96496: LIST
96497: LIST
96498: PUSH
96499: EMPTY
96500: LIST
96501: LIST
96502: PPUSH
96503: CALL_OW 69
96507: PPUSH
96508: LD_VAR 0 3
96512: PPUSH
96513: CALL_OW 74
96517: PPUSH
96518: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
96522: LD_VAR 0 2
96526: PUSH
96527: LD_INT 80
96529: GREATER
96530: PUSH
96531: LD_VAR 0 3
96535: PPUSH
96536: CALL_OW 301
96540: OR
96541: IFFALSE 96418
// if un then
96543: LD_VAR 0 3
96547: IFFALSE 96558
// RemoveUnit ( un ) ;
96549: LD_VAR 0 3
96553: PPUSH
96554: CALL_OW 64
// end ;
96558: PPOPN 3
96560: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
96561: LD_EXP 167
96565: IFFALSE 96681
96567: GO 96569
96569: DISABLE
96570: LD_INT 0
96572: PPUSH
96573: PPUSH
96574: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96575: LD_ADDR_VAR 0 2
96579: PUSH
96580: LD_INT 81
96582: PUSH
96583: LD_OWVAR 2
96587: PUSH
96588: EMPTY
96589: LIST
96590: LIST
96591: PUSH
96592: LD_INT 21
96594: PUSH
96595: LD_INT 1
96597: PUSH
96598: EMPTY
96599: LIST
96600: LIST
96601: PUSH
96602: EMPTY
96603: LIST
96604: LIST
96605: PPUSH
96606: CALL_OW 69
96610: ST_TO_ADDR
// ToLua ( playComputer() ) ;
96611: LD_STRING playComputer()
96613: PPUSH
96614: CALL_OW 559
// if not tmp then
96618: LD_VAR 0 2
96622: NOT
96623: IFFALSE 96627
// exit ;
96625: GO 96681
// for i in tmp do
96627: LD_ADDR_VAR 0 1
96631: PUSH
96632: LD_VAR 0 2
96636: PUSH
96637: FOR_IN
96638: IFFALSE 96679
// for j := 1 to 4 do
96640: LD_ADDR_VAR 0 3
96644: PUSH
96645: DOUBLE
96646: LD_INT 1
96648: DEC
96649: ST_TO_ADDR
96650: LD_INT 4
96652: PUSH
96653: FOR_TO
96654: IFFALSE 96675
// SetSkill ( i , j , 10 ) ;
96656: LD_VAR 0 1
96660: PPUSH
96661: LD_VAR 0 3
96665: PPUSH
96666: LD_INT 10
96668: PPUSH
96669: CALL_OW 237
96673: GO 96653
96675: POP
96676: POP
96677: GO 96637
96679: POP
96680: POP
// end ;
96681: PPOPN 3
96683: END
// every 0 0$1 trigger s30 do var i , tmp ;
96684: LD_EXP 168
96688: IFFALSE 96757
96690: GO 96692
96692: DISABLE
96693: LD_INT 0
96695: PPUSH
96696: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96697: LD_ADDR_VAR 0 2
96701: PUSH
96702: LD_INT 22
96704: PUSH
96705: LD_OWVAR 2
96709: PUSH
96710: EMPTY
96711: LIST
96712: LIST
96713: PPUSH
96714: CALL_OW 69
96718: ST_TO_ADDR
// if not tmp then
96719: LD_VAR 0 2
96723: NOT
96724: IFFALSE 96728
// exit ;
96726: GO 96757
// for i in tmp do
96728: LD_ADDR_VAR 0 1
96732: PUSH
96733: LD_VAR 0 2
96737: PUSH
96738: FOR_IN
96739: IFFALSE 96755
// SetLives ( i , 300 ) ;
96741: LD_VAR 0 1
96745: PPUSH
96746: LD_INT 300
96748: PPUSH
96749: CALL_OW 234
96753: GO 96738
96755: POP
96756: POP
// end ;
96757: PPOPN 2
96759: END
// every 0 0$1 trigger s60 do var i , tmp ;
96760: LD_EXP 169
96764: IFFALSE 96833
96766: GO 96768
96768: DISABLE
96769: LD_INT 0
96771: PPUSH
96772: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96773: LD_ADDR_VAR 0 2
96777: PUSH
96778: LD_INT 22
96780: PUSH
96781: LD_OWVAR 2
96785: PUSH
96786: EMPTY
96787: LIST
96788: LIST
96789: PPUSH
96790: CALL_OW 69
96794: ST_TO_ADDR
// if not tmp then
96795: LD_VAR 0 2
96799: NOT
96800: IFFALSE 96804
// exit ;
96802: GO 96833
// for i in tmp do
96804: LD_ADDR_VAR 0 1
96808: PUSH
96809: LD_VAR 0 2
96813: PUSH
96814: FOR_IN
96815: IFFALSE 96831
// SetLives ( i , 600 ) ;
96817: LD_VAR 0 1
96821: PPUSH
96822: LD_INT 600
96824: PPUSH
96825: CALL_OW 234
96829: GO 96814
96831: POP
96832: POP
// end ;
96833: PPOPN 2
96835: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
96836: LD_INT 0
96838: PPUSH
// case cmd of 301 :
96839: LD_VAR 0 1
96843: PUSH
96844: LD_INT 301
96846: DOUBLE
96847: EQUAL
96848: IFTRUE 96852
96850: GO 96884
96852: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
96853: LD_VAR 0 6
96857: PPUSH
96858: LD_VAR 0 7
96862: PPUSH
96863: LD_VAR 0 8
96867: PPUSH
96868: LD_VAR 0 4
96872: PPUSH
96873: LD_VAR 0 5
96877: PPUSH
96878: CALL 98085 0 5
96882: GO 97005
96884: LD_INT 302
96886: DOUBLE
96887: EQUAL
96888: IFTRUE 96892
96890: GO 96929
96892: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
96893: LD_VAR 0 6
96897: PPUSH
96898: LD_VAR 0 7
96902: PPUSH
96903: LD_VAR 0 8
96907: PPUSH
96908: LD_VAR 0 9
96912: PPUSH
96913: LD_VAR 0 4
96917: PPUSH
96918: LD_VAR 0 5
96922: PPUSH
96923: CALL 98176 0 6
96927: GO 97005
96929: LD_INT 303
96931: DOUBLE
96932: EQUAL
96933: IFTRUE 96937
96935: GO 96974
96937: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
96938: LD_VAR 0 6
96942: PPUSH
96943: LD_VAR 0 7
96947: PPUSH
96948: LD_VAR 0 8
96952: PPUSH
96953: LD_VAR 0 9
96957: PPUSH
96958: LD_VAR 0 4
96962: PPUSH
96963: LD_VAR 0 5
96967: PPUSH
96968: CALL 97010 0 6
96972: GO 97005
96974: LD_INT 304
96976: DOUBLE
96977: EQUAL
96978: IFTRUE 96982
96980: GO 97004
96982: POP
// hHackTeleport ( unit , x , y ) ; end ;
96983: LD_VAR 0 2
96987: PPUSH
96988: LD_VAR 0 4
96992: PPUSH
96993: LD_VAR 0 5
96997: PPUSH
96998: CALL 98769 0 3
97002: GO 97005
97004: POP
// end ;
97005: LD_VAR 0 12
97009: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
97010: LD_INT 0
97012: PPUSH
97013: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
97014: LD_VAR 0 1
97018: PUSH
97019: LD_INT 1
97021: LESS
97022: PUSH
97023: LD_VAR 0 1
97027: PUSH
97028: LD_INT 3
97030: GREATER
97031: OR
97032: PUSH
97033: LD_VAR 0 5
97037: PPUSH
97038: LD_VAR 0 6
97042: PPUSH
97043: CALL_OW 428
97047: OR
97048: IFFALSE 97052
// exit ;
97050: GO 97772
// uc_side := your_side ;
97052: LD_ADDR_OWVAR 20
97056: PUSH
97057: LD_OWVAR 2
97061: ST_TO_ADDR
// uc_nation := nation ;
97062: LD_ADDR_OWVAR 21
97066: PUSH
97067: LD_VAR 0 1
97071: ST_TO_ADDR
// bc_level = 1 ;
97072: LD_ADDR_OWVAR 43
97076: PUSH
97077: LD_INT 1
97079: ST_TO_ADDR
// case btype of 1 :
97080: LD_VAR 0 2
97084: PUSH
97085: LD_INT 1
97087: DOUBLE
97088: EQUAL
97089: IFTRUE 97093
97091: GO 97104
97093: POP
// bc_type := b_depot ; 2 :
97094: LD_ADDR_OWVAR 42
97098: PUSH
97099: LD_INT 0
97101: ST_TO_ADDR
97102: GO 97716
97104: LD_INT 2
97106: DOUBLE
97107: EQUAL
97108: IFTRUE 97112
97110: GO 97123
97112: POP
// bc_type := b_warehouse ; 3 :
97113: LD_ADDR_OWVAR 42
97117: PUSH
97118: LD_INT 1
97120: ST_TO_ADDR
97121: GO 97716
97123: LD_INT 3
97125: DOUBLE
97126: EQUAL
97127: IFTRUE 97131
97129: GO 97142
97131: POP
// bc_type := b_lab ; 4 .. 9 :
97132: LD_ADDR_OWVAR 42
97136: PUSH
97137: LD_INT 6
97139: ST_TO_ADDR
97140: GO 97716
97142: LD_INT 4
97144: DOUBLE
97145: GREATEREQUAL
97146: IFFALSE 97154
97148: LD_INT 9
97150: DOUBLE
97151: LESSEQUAL
97152: IFTRUE 97156
97154: GO 97208
97156: POP
// begin bc_type := b_lab_half ;
97157: LD_ADDR_OWVAR 42
97161: PUSH
97162: LD_INT 7
97164: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
97165: LD_ADDR_OWVAR 44
97169: PUSH
97170: LD_INT 10
97172: PUSH
97173: LD_INT 11
97175: PUSH
97176: LD_INT 12
97178: PUSH
97179: LD_INT 15
97181: PUSH
97182: LD_INT 14
97184: PUSH
97185: LD_INT 13
97187: PUSH
97188: EMPTY
97189: LIST
97190: LIST
97191: LIST
97192: LIST
97193: LIST
97194: LIST
97195: PUSH
97196: LD_VAR 0 2
97200: PUSH
97201: LD_INT 3
97203: MINUS
97204: ARRAY
97205: ST_TO_ADDR
// end ; 10 .. 13 :
97206: GO 97716
97208: LD_INT 10
97210: DOUBLE
97211: GREATEREQUAL
97212: IFFALSE 97220
97214: LD_INT 13
97216: DOUBLE
97217: LESSEQUAL
97218: IFTRUE 97222
97220: GO 97299
97222: POP
// begin bc_type := b_lab_full ;
97223: LD_ADDR_OWVAR 42
97227: PUSH
97228: LD_INT 8
97230: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
97231: LD_ADDR_OWVAR 44
97235: PUSH
97236: LD_INT 10
97238: PUSH
97239: LD_INT 12
97241: PUSH
97242: LD_INT 14
97244: PUSH
97245: LD_INT 13
97247: PUSH
97248: EMPTY
97249: LIST
97250: LIST
97251: LIST
97252: LIST
97253: PUSH
97254: LD_VAR 0 2
97258: PUSH
97259: LD_INT 9
97261: MINUS
97262: ARRAY
97263: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
97264: LD_ADDR_OWVAR 45
97268: PUSH
97269: LD_INT 11
97271: PUSH
97272: LD_INT 15
97274: PUSH
97275: LD_INT 12
97277: PUSH
97278: LD_INT 15
97280: PUSH
97281: EMPTY
97282: LIST
97283: LIST
97284: LIST
97285: LIST
97286: PUSH
97287: LD_VAR 0 2
97291: PUSH
97292: LD_INT 9
97294: MINUS
97295: ARRAY
97296: ST_TO_ADDR
// end ; 14 :
97297: GO 97716
97299: LD_INT 14
97301: DOUBLE
97302: EQUAL
97303: IFTRUE 97307
97305: GO 97318
97307: POP
// bc_type := b_workshop ; 15 :
97308: LD_ADDR_OWVAR 42
97312: PUSH
97313: LD_INT 2
97315: ST_TO_ADDR
97316: GO 97716
97318: LD_INT 15
97320: DOUBLE
97321: EQUAL
97322: IFTRUE 97326
97324: GO 97337
97326: POP
// bc_type := b_factory ; 16 :
97327: LD_ADDR_OWVAR 42
97331: PUSH
97332: LD_INT 3
97334: ST_TO_ADDR
97335: GO 97716
97337: LD_INT 16
97339: DOUBLE
97340: EQUAL
97341: IFTRUE 97345
97343: GO 97356
97345: POP
// bc_type := b_ext_gun ; 17 :
97346: LD_ADDR_OWVAR 42
97350: PUSH
97351: LD_INT 17
97353: ST_TO_ADDR
97354: GO 97716
97356: LD_INT 17
97358: DOUBLE
97359: EQUAL
97360: IFTRUE 97364
97362: GO 97392
97364: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
97365: LD_ADDR_OWVAR 42
97369: PUSH
97370: LD_INT 19
97372: PUSH
97373: LD_INT 23
97375: PUSH
97376: LD_INT 19
97378: PUSH
97379: EMPTY
97380: LIST
97381: LIST
97382: LIST
97383: PUSH
97384: LD_VAR 0 1
97388: ARRAY
97389: ST_TO_ADDR
97390: GO 97716
97392: LD_INT 18
97394: DOUBLE
97395: EQUAL
97396: IFTRUE 97400
97398: GO 97411
97400: POP
// bc_type := b_ext_radar ; 19 :
97401: LD_ADDR_OWVAR 42
97405: PUSH
97406: LD_INT 20
97408: ST_TO_ADDR
97409: GO 97716
97411: LD_INT 19
97413: DOUBLE
97414: EQUAL
97415: IFTRUE 97419
97417: GO 97430
97419: POP
// bc_type := b_ext_radio ; 20 :
97420: LD_ADDR_OWVAR 42
97424: PUSH
97425: LD_INT 22
97427: ST_TO_ADDR
97428: GO 97716
97430: LD_INT 20
97432: DOUBLE
97433: EQUAL
97434: IFTRUE 97438
97436: GO 97449
97438: POP
// bc_type := b_ext_siberium ; 21 :
97439: LD_ADDR_OWVAR 42
97443: PUSH
97444: LD_INT 21
97446: ST_TO_ADDR
97447: GO 97716
97449: LD_INT 21
97451: DOUBLE
97452: EQUAL
97453: IFTRUE 97457
97455: GO 97468
97457: POP
// bc_type := b_ext_computer ; 22 :
97458: LD_ADDR_OWVAR 42
97462: PUSH
97463: LD_INT 24
97465: ST_TO_ADDR
97466: GO 97716
97468: LD_INT 22
97470: DOUBLE
97471: EQUAL
97472: IFTRUE 97476
97474: GO 97487
97476: POP
// bc_type := b_ext_track ; 23 :
97477: LD_ADDR_OWVAR 42
97481: PUSH
97482: LD_INT 16
97484: ST_TO_ADDR
97485: GO 97716
97487: LD_INT 23
97489: DOUBLE
97490: EQUAL
97491: IFTRUE 97495
97493: GO 97506
97495: POP
// bc_type := b_ext_laser ; 24 :
97496: LD_ADDR_OWVAR 42
97500: PUSH
97501: LD_INT 25
97503: ST_TO_ADDR
97504: GO 97716
97506: LD_INT 24
97508: DOUBLE
97509: EQUAL
97510: IFTRUE 97514
97512: GO 97525
97514: POP
// bc_type := b_control_tower ; 25 :
97515: LD_ADDR_OWVAR 42
97519: PUSH
97520: LD_INT 36
97522: ST_TO_ADDR
97523: GO 97716
97525: LD_INT 25
97527: DOUBLE
97528: EQUAL
97529: IFTRUE 97533
97531: GO 97544
97533: POP
// bc_type := b_breastwork ; 26 :
97534: LD_ADDR_OWVAR 42
97538: PUSH
97539: LD_INT 31
97541: ST_TO_ADDR
97542: GO 97716
97544: LD_INT 26
97546: DOUBLE
97547: EQUAL
97548: IFTRUE 97552
97550: GO 97563
97552: POP
// bc_type := b_bunker ; 27 :
97553: LD_ADDR_OWVAR 42
97557: PUSH
97558: LD_INT 32
97560: ST_TO_ADDR
97561: GO 97716
97563: LD_INT 27
97565: DOUBLE
97566: EQUAL
97567: IFTRUE 97571
97569: GO 97582
97571: POP
// bc_type := b_turret ; 28 :
97572: LD_ADDR_OWVAR 42
97576: PUSH
97577: LD_INT 33
97579: ST_TO_ADDR
97580: GO 97716
97582: LD_INT 28
97584: DOUBLE
97585: EQUAL
97586: IFTRUE 97590
97588: GO 97601
97590: POP
// bc_type := b_armoury ; 29 :
97591: LD_ADDR_OWVAR 42
97595: PUSH
97596: LD_INT 4
97598: ST_TO_ADDR
97599: GO 97716
97601: LD_INT 29
97603: DOUBLE
97604: EQUAL
97605: IFTRUE 97609
97607: GO 97620
97609: POP
// bc_type := b_barracks ; 30 :
97610: LD_ADDR_OWVAR 42
97614: PUSH
97615: LD_INT 5
97617: ST_TO_ADDR
97618: GO 97716
97620: LD_INT 30
97622: DOUBLE
97623: EQUAL
97624: IFTRUE 97628
97626: GO 97639
97628: POP
// bc_type := b_solar_power ; 31 :
97629: LD_ADDR_OWVAR 42
97633: PUSH
97634: LD_INT 27
97636: ST_TO_ADDR
97637: GO 97716
97639: LD_INT 31
97641: DOUBLE
97642: EQUAL
97643: IFTRUE 97647
97645: GO 97658
97647: POP
// bc_type := b_oil_power ; 32 :
97648: LD_ADDR_OWVAR 42
97652: PUSH
97653: LD_INT 26
97655: ST_TO_ADDR
97656: GO 97716
97658: LD_INT 32
97660: DOUBLE
97661: EQUAL
97662: IFTRUE 97666
97664: GO 97677
97666: POP
// bc_type := b_siberite_power ; 33 :
97667: LD_ADDR_OWVAR 42
97671: PUSH
97672: LD_INT 28
97674: ST_TO_ADDR
97675: GO 97716
97677: LD_INT 33
97679: DOUBLE
97680: EQUAL
97681: IFTRUE 97685
97683: GO 97696
97685: POP
// bc_type := b_oil_mine ; 34 :
97686: LD_ADDR_OWVAR 42
97690: PUSH
97691: LD_INT 29
97693: ST_TO_ADDR
97694: GO 97716
97696: LD_INT 34
97698: DOUBLE
97699: EQUAL
97700: IFTRUE 97704
97702: GO 97715
97704: POP
// bc_type := b_siberite_mine ; end ;
97705: LD_ADDR_OWVAR 42
97709: PUSH
97710: LD_INT 30
97712: ST_TO_ADDR
97713: GO 97716
97715: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
97716: LD_ADDR_VAR 0 8
97720: PUSH
97721: LD_VAR 0 5
97725: PPUSH
97726: LD_VAR 0 6
97730: PPUSH
97731: LD_VAR 0 3
97735: PPUSH
97736: CALL_OW 47
97740: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
97741: LD_OWVAR 42
97745: PUSH
97746: LD_INT 32
97748: PUSH
97749: LD_INT 33
97751: PUSH
97752: EMPTY
97753: LIST
97754: LIST
97755: IN
97756: IFFALSE 97772
// PlaceWeaponTurret ( b , weapon ) ;
97758: LD_VAR 0 8
97762: PPUSH
97763: LD_VAR 0 4
97767: PPUSH
97768: CALL_OW 431
// end ;
97772: LD_VAR 0 7
97776: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
97777: LD_INT 0
97779: PPUSH
97780: PPUSH
97781: PPUSH
97782: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97783: LD_ADDR_VAR 0 4
97787: PUSH
97788: LD_INT 22
97790: PUSH
97791: LD_OWVAR 2
97795: PUSH
97796: EMPTY
97797: LIST
97798: LIST
97799: PUSH
97800: LD_INT 2
97802: PUSH
97803: LD_INT 30
97805: PUSH
97806: LD_INT 0
97808: PUSH
97809: EMPTY
97810: LIST
97811: LIST
97812: PUSH
97813: LD_INT 30
97815: PUSH
97816: LD_INT 1
97818: PUSH
97819: EMPTY
97820: LIST
97821: LIST
97822: PUSH
97823: EMPTY
97824: LIST
97825: LIST
97826: LIST
97827: PUSH
97828: EMPTY
97829: LIST
97830: LIST
97831: PPUSH
97832: CALL_OW 69
97836: ST_TO_ADDR
// if not tmp then
97837: LD_VAR 0 4
97841: NOT
97842: IFFALSE 97846
// exit ;
97844: GO 97905
// for i in tmp do
97846: LD_ADDR_VAR 0 2
97850: PUSH
97851: LD_VAR 0 4
97855: PUSH
97856: FOR_IN
97857: IFFALSE 97903
// for j = 1 to 3 do
97859: LD_ADDR_VAR 0 3
97863: PUSH
97864: DOUBLE
97865: LD_INT 1
97867: DEC
97868: ST_TO_ADDR
97869: LD_INT 3
97871: PUSH
97872: FOR_TO
97873: IFFALSE 97899
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
97875: LD_VAR 0 2
97879: PPUSH
97880: CALL_OW 274
97884: PPUSH
97885: LD_VAR 0 3
97889: PPUSH
97890: LD_INT 99999
97892: PPUSH
97893: CALL_OW 277
97897: GO 97872
97899: POP
97900: POP
97901: GO 97856
97903: POP
97904: POP
// end ;
97905: LD_VAR 0 1
97909: RET
// export function hHackSetLevel10 ; var i , j ; begin
97910: LD_INT 0
97912: PPUSH
97913: PPUSH
97914: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
97915: LD_ADDR_VAR 0 2
97919: PUSH
97920: LD_INT 21
97922: PUSH
97923: LD_INT 1
97925: PUSH
97926: EMPTY
97927: LIST
97928: LIST
97929: PPUSH
97930: CALL_OW 69
97934: PUSH
97935: FOR_IN
97936: IFFALSE 97988
// if IsSelected ( i ) then
97938: LD_VAR 0 2
97942: PPUSH
97943: CALL_OW 306
97947: IFFALSE 97986
// begin for j := 1 to 4 do
97949: LD_ADDR_VAR 0 3
97953: PUSH
97954: DOUBLE
97955: LD_INT 1
97957: DEC
97958: ST_TO_ADDR
97959: LD_INT 4
97961: PUSH
97962: FOR_TO
97963: IFFALSE 97984
// SetSkill ( i , j , 10 ) ;
97965: LD_VAR 0 2
97969: PPUSH
97970: LD_VAR 0 3
97974: PPUSH
97975: LD_INT 10
97977: PPUSH
97978: CALL_OW 237
97982: GO 97962
97984: POP
97985: POP
// end ;
97986: GO 97935
97988: POP
97989: POP
// end ;
97990: LD_VAR 0 1
97994: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
97995: LD_INT 0
97997: PPUSH
97998: PPUSH
97999: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
98000: LD_ADDR_VAR 0 2
98004: PUSH
98005: LD_INT 22
98007: PUSH
98008: LD_OWVAR 2
98012: PUSH
98013: EMPTY
98014: LIST
98015: LIST
98016: PUSH
98017: LD_INT 21
98019: PUSH
98020: LD_INT 1
98022: PUSH
98023: EMPTY
98024: LIST
98025: LIST
98026: PUSH
98027: EMPTY
98028: LIST
98029: LIST
98030: PPUSH
98031: CALL_OW 69
98035: PUSH
98036: FOR_IN
98037: IFFALSE 98078
// begin for j := 1 to 4 do
98039: LD_ADDR_VAR 0 3
98043: PUSH
98044: DOUBLE
98045: LD_INT 1
98047: DEC
98048: ST_TO_ADDR
98049: LD_INT 4
98051: PUSH
98052: FOR_TO
98053: IFFALSE 98074
// SetSkill ( i , j , 10 ) ;
98055: LD_VAR 0 2
98059: PPUSH
98060: LD_VAR 0 3
98064: PPUSH
98065: LD_INT 10
98067: PPUSH
98068: CALL_OW 237
98072: GO 98052
98074: POP
98075: POP
// end ;
98076: GO 98036
98078: POP
98079: POP
// end ;
98080: LD_VAR 0 1
98084: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
98085: LD_INT 0
98087: PPUSH
// uc_side := your_side ;
98088: LD_ADDR_OWVAR 20
98092: PUSH
98093: LD_OWVAR 2
98097: ST_TO_ADDR
// uc_nation := nation ;
98098: LD_ADDR_OWVAR 21
98102: PUSH
98103: LD_VAR 0 1
98107: ST_TO_ADDR
// InitHc ;
98108: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
98112: LD_INT 0
98114: PPUSH
98115: LD_VAR 0 2
98119: PPUSH
98120: LD_VAR 0 3
98124: PPUSH
98125: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
98129: LD_VAR 0 4
98133: PPUSH
98134: LD_VAR 0 5
98138: PPUSH
98139: CALL_OW 428
98143: PUSH
98144: LD_INT 0
98146: EQUAL
98147: IFFALSE 98171
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
98149: CALL_OW 44
98153: PPUSH
98154: LD_VAR 0 4
98158: PPUSH
98159: LD_VAR 0 5
98163: PPUSH
98164: LD_INT 1
98166: PPUSH
98167: CALL_OW 48
// end ;
98171: LD_VAR 0 6
98175: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
98176: LD_INT 0
98178: PPUSH
98179: PPUSH
// uc_side := your_side ;
98180: LD_ADDR_OWVAR 20
98184: PUSH
98185: LD_OWVAR 2
98189: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
98190: LD_VAR 0 1
98194: PUSH
98195: LD_INT 1
98197: PUSH
98198: LD_INT 2
98200: PUSH
98201: LD_INT 3
98203: PUSH
98204: LD_INT 4
98206: PUSH
98207: LD_INT 5
98209: PUSH
98210: EMPTY
98211: LIST
98212: LIST
98213: LIST
98214: LIST
98215: LIST
98216: IN
98217: IFFALSE 98229
// uc_nation := nation_american else
98219: LD_ADDR_OWVAR 21
98223: PUSH
98224: LD_INT 1
98226: ST_TO_ADDR
98227: GO 98272
// if chassis in [ 11 , 12 , 13 , 14 ] then
98229: LD_VAR 0 1
98233: PUSH
98234: LD_INT 11
98236: PUSH
98237: LD_INT 12
98239: PUSH
98240: LD_INT 13
98242: PUSH
98243: LD_INT 14
98245: PUSH
98246: EMPTY
98247: LIST
98248: LIST
98249: LIST
98250: LIST
98251: IN
98252: IFFALSE 98264
// uc_nation := nation_arabian else
98254: LD_ADDR_OWVAR 21
98258: PUSH
98259: LD_INT 2
98261: ST_TO_ADDR
98262: GO 98272
// uc_nation := nation_russian ;
98264: LD_ADDR_OWVAR 21
98268: PUSH
98269: LD_INT 3
98271: ST_TO_ADDR
// vc_chassis := chassis ;
98272: LD_ADDR_OWVAR 37
98276: PUSH
98277: LD_VAR 0 1
98281: ST_TO_ADDR
// vc_engine := engine ;
98282: LD_ADDR_OWVAR 39
98286: PUSH
98287: LD_VAR 0 2
98291: ST_TO_ADDR
// vc_control := control ;
98292: LD_ADDR_OWVAR 38
98296: PUSH
98297: LD_VAR 0 3
98301: ST_TO_ADDR
// vc_weapon := weapon ;
98302: LD_ADDR_OWVAR 40
98306: PUSH
98307: LD_VAR 0 4
98311: ST_TO_ADDR
// un := CreateVehicle ;
98312: LD_ADDR_VAR 0 8
98316: PUSH
98317: CALL_OW 45
98321: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
98322: LD_VAR 0 8
98326: PPUSH
98327: LD_INT 0
98329: PPUSH
98330: LD_INT 5
98332: PPUSH
98333: CALL_OW 12
98337: PPUSH
98338: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
98342: LD_VAR 0 8
98346: PPUSH
98347: LD_VAR 0 5
98351: PPUSH
98352: LD_VAR 0 6
98356: PPUSH
98357: LD_INT 1
98359: PPUSH
98360: CALL_OW 48
// end ;
98364: LD_VAR 0 7
98368: RET
// export hInvincible ; every 1 do
98369: GO 98371
98371: DISABLE
// hInvincible := [ ] ;
98372: LD_ADDR_EXP 170
98376: PUSH
98377: EMPTY
98378: ST_TO_ADDR
98379: END
// every 10 do var i ;
98380: GO 98382
98382: DISABLE
98383: LD_INT 0
98385: PPUSH
// begin enable ;
98386: ENABLE
// if not hInvincible then
98387: LD_EXP 170
98391: NOT
98392: IFFALSE 98396
// exit ;
98394: GO 98440
// for i in hInvincible do
98396: LD_ADDR_VAR 0 1
98400: PUSH
98401: LD_EXP 170
98405: PUSH
98406: FOR_IN
98407: IFFALSE 98438
// if GetLives ( i ) < 1000 then
98409: LD_VAR 0 1
98413: PPUSH
98414: CALL_OW 256
98418: PUSH
98419: LD_INT 1000
98421: LESS
98422: IFFALSE 98436
// SetLives ( i , 1000 ) ;
98424: LD_VAR 0 1
98428: PPUSH
98429: LD_INT 1000
98431: PPUSH
98432: CALL_OW 234
98436: GO 98406
98438: POP
98439: POP
// end ;
98440: PPOPN 1
98442: END
// export function hHackInvincible ; var i ; begin
98443: LD_INT 0
98445: PPUSH
98446: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
98447: LD_ADDR_VAR 0 2
98451: PUSH
98452: LD_INT 2
98454: PUSH
98455: LD_INT 21
98457: PUSH
98458: LD_INT 1
98460: PUSH
98461: EMPTY
98462: LIST
98463: LIST
98464: PUSH
98465: LD_INT 21
98467: PUSH
98468: LD_INT 2
98470: PUSH
98471: EMPTY
98472: LIST
98473: LIST
98474: PUSH
98475: EMPTY
98476: LIST
98477: LIST
98478: LIST
98479: PPUSH
98480: CALL_OW 69
98484: PUSH
98485: FOR_IN
98486: IFFALSE 98547
// if IsSelected ( i ) then
98488: LD_VAR 0 2
98492: PPUSH
98493: CALL_OW 306
98497: IFFALSE 98545
// begin if i in hInvincible then
98499: LD_VAR 0 2
98503: PUSH
98504: LD_EXP 170
98508: IN
98509: IFFALSE 98529
// hInvincible := hInvincible diff i else
98511: LD_ADDR_EXP 170
98515: PUSH
98516: LD_EXP 170
98520: PUSH
98521: LD_VAR 0 2
98525: DIFF
98526: ST_TO_ADDR
98527: GO 98545
// hInvincible := hInvincible union i ;
98529: LD_ADDR_EXP 170
98533: PUSH
98534: LD_EXP 170
98538: PUSH
98539: LD_VAR 0 2
98543: UNION
98544: ST_TO_ADDR
// end ;
98545: GO 98485
98547: POP
98548: POP
// end ;
98549: LD_VAR 0 1
98553: RET
// export function hHackInvisible ; var i , j ; begin
98554: LD_INT 0
98556: PPUSH
98557: PPUSH
98558: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
98559: LD_ADDR_VAR 0 2
98563: PUSH
98564: LD_INT 21
98566: PUSH
98567: LD_INT 1
98569: PUSH
98570: EMPTY
98571: LIST
98572: LIST
98573: PPUSH
98574: CALL_OW 69
98578: PUSH
98579: FOR_IN
98580: IFFALSE 98604
// if IsSelected ( i ) then
98582: LD_VAR 0 2
98586: PPUSH
98587: CALL_OW 306
98591: IFFALSE 98602
// ComForceInvisible ( i ) ;
98593: LD_VAR 0 2
98597: PPUSH
98598: CALL_OW 496
98602: GO 98579
98604: POP
98605: POP
// end ;
98606: LD_VAR 0 1
98610: RET
// export function hHackChangeYourSide ; begin
98611: LD_INT 0
98613: PPUSH
// if your_side = 8 then
98614: LD_OWVAR 2
98618: PUSH
98619: LD_INT 8
98621: EQUAL
98622: IFFALSE 98634
// your_side := 0 else
98624: LD_ADDR_OWVAR 2
98628: PUSH
98629: LD_INT 0
98631: ST_TO_ADDR
98632: GO 98648
// your_side := your_side + 1 ;
98634: LD_ADDR_OWVAR 2
98638: PUSH
98639: LD_OWVAR 2
98643: PUSH
98644: LD_INT 1
98646: PLUS
98647: ST_TO_ADDR
// end ;
98648: LD_VAR 0 1
98652: RET
// export function hHackChangeUnitSide ; var i , j ; begin
98653: LD_INT 0
98655: PPUSH
98656: PPUSH
98657: PPUSH
// for i in all_units do
98658: LD_ADDR_VAR 0 2
98662: PUSH
98663: LD_OWVAR 3
98667: PUSH
98668: FOR_IN
98669: IFFALSE 98747
// if IsSelected ( i ) then
98671: LD_VAR 0 2
98675: PPUSH
98676: CALL_OW 306
98680: IFFALSE 98745
// begin j := GetSide ( i ) ;
98682: LD_ADDR_VAR 0 3
98686: PUSH
98687: LD_VAR 0 2
98691: PPUSH
98692: CALL_OW 255
98696: ST_TO_ADDR
// if j = 8 then
98697: LD_VAR 0 3
98701: PUSH
98702: LD_INT 8
98704: EQUAL
98705: IFFALSE 98717
// j := 0 else
98707: LD_ADDR_VAR 0 3
98711: PUSH
98712: LD_INT 0
98714: ST_TO_ADDR
98715: GO 98731
// j := j + 1 ;
98717: LD_ADDR_VAR 0 3
98721: PUSH
98722: LD_VAR 0 3
98726: PUSH
98727: LD_INT 1
98729: PLUS
98730: ST_TO_ADDR
// SetSide ( i , j ) ;
98731: LD_VAR 0 2
98735: PPUSH
98736: LD_VAR 0 3
98740: PPUSH
98741: CALL_OW 235
// end ;
98745: GO 98668
98747: POP
98748: POP
// end ;
98749: LD_VAR 0 1
98753: RET
// export function hHackFog ; begin
98754: LD_INT 0
98756: PPUSH
// FogOff ( true ) ;
98757: LD_INT 1
98759: PPUSH
98760: CALL_OW 344
// end ;
98764: LD_VAR 0 1
98768: RET
// export function hHackTeleport ( unit , x , y ) ; begin
98769: LD_INT 0
98771: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
98772: LD_VAR 0 1
98776: PPUSH
98777: LD_VAR 0 2
98781: PPUSH
98782: LD_VAR 0 3
98786: PPUSH
98787: LD_INT 1
98789: PPUSH
98790: LD_INT 1
98792: PPUSH
98793: CALL_OW 483
// CenterOnXY ( x , y ) ;
98797: LD_VAR 0 2
98801: PPUSH
98802: LD_VAR 0 3
98806: PPUSH
98807: CALL_OW 84
// end ; end_of_file
98811: LD_VAR 0 4
98815: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
98816: LD_INT 0
98818: PPUSH
98819: PPUSH
98820: PPUSH
98821: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
98822: LD_VAR 0 1
98826: PPUSH
98827: CALL_OW 264
98831: PUSH
98832: LD_EXP 52
98836: EQUAL
98837: IFFALSE 98909
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
98839: LD_INT 68
98841: PPUSH
98842: LD_VAR 0 1
98846: PPUSH
98847: CALL_OW 255
98851: PPUSH
98852: CALL_OW 321
98856: PUSH
98857: LD_INT 2
98859: EQUAL
98860: IFFALSE 98872
// eff := 70 else
98862: LD_ADDR_VAR 0 4
98866: PUSH
98867: LD_INT 70
98869: ST_TO_ADDR
98870: GO 98880
// eff := 30 ;
98872: LD_ADDR_VAR 0 4
98876: PUSH
98877: LD_INT 30
98879: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
98880: LD_VAR 0 1
98884: PPUSH
98885: CALL_OW 250
98889: PPUSH
98890: LD_VAR 0 1
98894: PPUSH
98895: CALL_OW 251
98899: PPUSH
98900: LD_VAR 0 4
98904: PPUSH
98905: CALL_OW 495
// end ; end ;
98909: LD_VAR 0 2
98913: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
98914: LD_INT 0
98916: PPUSH
// end ;
98917: LD_VAR 0 4
98921: RET
// export function SOS_Command ( cmd ) ; begin
98922: LD_INT 0
98924: PPUSH
// end ;
98925: LD_VAR 0 2
98929: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
98930: LD_INT 0
98932: PPUSH
// end ;
98933: LD_VAR 0 6
98937: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
98938: LD_INT 0
98940: PPUSH
98941: PPUSH
// if not vehicle or not factory then
98942: LD_VAR 0 1
98946: NOT
98947: PUSH
98948: LD_VAR 0 2
98952: NOT
98953: OR
98954: IFFALSE 98958
// exit ;
98956: GO 99189
// if factoryWaypoints >= factory then
98958: LD_EXP 171
98962: PUSH
98963: LD_VAR 0 2
98967: GREATEREQUAL
98968: IFFALSE 99189
// if factoryWaypoints [ factory ] then
98970: LD_EXP 171
98974: PUSH
98975: LD_VAR 0 2
98979: ARRAY
98980: IFFALSE 99189
// begin if GetControl ( vehicle ) = control_manual then
98982: LD_VAR 0 1
98986: PPUSH
98987: CALL_OW 263
98991: PUSH
98992: LD_INT 1
98994: EQUAL
98995: IFFALSE 99076
// begin driver := IsDrivenBy ( vehicle ) ;
98997: LD_ADDR_VAR 0 4
99001: PUSH
99002: LD_VAR 0 1
99006: PPUSH
99007: CALL_OW 311
99011: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
99012: LD_VAR 0 4
99016: PPUSH
99017: LD_EXP 171
99021: PUSH
99022: LD_VAR 0 2
99026: ARRAY
99027: PUSH
99028: LD_INT 1
99030: ARRAY
99031: PPUSH
99032: LD_EXP 171
99036: PUSH
99037: LD_VAR 0 2
99041: ARRAY
99042: PUSH
99043: LD_INT 2
99045: ARRAY
99046: PPUSH
99047: CALL_OW 171
// AddComExitVehicle ( driver ) ;
99051: LD_VAR 0 4
99055: PPUSH
99056: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
99060: LD_VAR 0 4
99064: PPUSH
99065: LD_VAR 0 2
99069: PPUSH
99070: CALL_OW 180
// end else
99074: GO 99189
// if GetControl ( vehicle ) = control_remote then
99076: LD_VAR 0 1
99080: PPUSH
99081: CALL_OW 263
99085: PUSH
99086: LD_INT 2
99088: EQUAL
99089: IFFALSE 99150
// begin wait ( 0 0$2 ) ;
99091: LD_INT 70
99093: PPUSH
99094: CALL_OW 67
// if Connect ( vehicle ) then
99098: LD_VAR 0 1
99102: PPUSH
99103: CALL 21559 0 1
99107: IFFALSE 99148
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
99109: LD_VAR 0 1
99113: PPUSH
99114: LD_EXP 171
99118: PUSH
99119: LD_VAR 0 2
99123: ARRAY
99124: PUSH
99125: LD_INT 1
99127: ARRAY
99128: PPUSH
99129: LD_EXP 171
99133: PUSH
99134: LD_VAR 0 2
99138: ARRAY
99139: PUSH
99140: LD_INT 2
99142: ARRAY
99143: PPUSH
99144: CALL_OW 171
// end else
99148: GO 99189
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
99150: LD_VAR 0 1
99154: PPUSH
99155: LD_EXP 171
99159: PUSH
99160: LD_VAR 0 2
99164: ARRAY
99165: PUSH
99166: LD_INT 1
99168: ARRAY
99169: PPUSH
99170: LD_EXP 171
99174: PUSH
99175: LD_VAR 0 2
99179: ARRAY
99180: PUSH
99181: LD_INT 2
99183: ARRAY
99184: PPUSH
99185: CALL_OW 171
// end ; end ;
99189: LD_VAR 0 3
99193: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
99194: LD_INT 0
99196: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
99197: LD_VAR 0 1
99201: PUSH
99202: LD_INT 250
99204: EQUAL
99205: PUSH
99206: LD_VAR 0 2
99210: PPUSH
99211: CALL_OW 264
99215: PUSH
99216: LD_EXP 55
99220: EQUAL
99221: AND
99222: IFFALSE 99243
// MinerPlaceMine ( unit , x , y ) ;
99224: LD_VAR 0 2
99228: PPUSH
99229: LD_VAR 0 4
99233: PPUSH
99234: LD_VAR 0 5
99238: PPUSH
99239: CALL 101971 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
99243: LD_VAR 0 1
99247: PUSH
99248: LD_INT 251
99250: EQUAL
99251: PUSH
99252: LD_VAR 0 2
99256: PPUSH
99257: CALL_OW 264
99261: PUSH
99262: LD_EXP 55
99266: EQUAL
99267: AND
99268: IFFALSE 99289
// MinerDetonateMine ( unit , x , y ) ;
99270: LD_VAR 0 2
99274: PPUSH
99275: LD_VAR 0 4
99279: PPUSH
99280: LD_VAR 0 5
99284: PPUSH
99285: CALL 102248 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
99289: LD_VAR 0 1
99293: PUSH
99294: LD_INT 252
99296: EQUAL
99297: PUSH
99298: LD_VAR 0 2
99302: PPUSH
99303: CALL_OW 264
99307: PUSH
99308: LD_EXP 55
99312: EQUAL
99313: AND
99314: IFFALSE 99335
// MinerCreateMinefield ( unit , x , y ) ;
99316: LD_VAR 0 2
99320: PPUSH
99321: LD_VAR 0 4
99325: PPUSH
99326: LD_VAR 0 5
99330: PPUSH
99331: CALL 102665 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
99335: LD_VAR 0 1
99339: PUSH
99340: LD_INT 253
99342: EQUAL
99343: PUSH
99344: LD_VAR 0 2
99348: PPUSH
99349: CALL_OW 257
99353: PUSH
99354: LD_INT 5
99356: EQUAL
99357: AND
99358: IFFALSE 99379
// ComBinocular ( unit , x , y ) ;
99360: LD_VAR 0 2
99364: PPUSH
99365: LD_VAR 0 4
99369: PPUSH
99370: LD_VAR 0 5
99374: PPUSH
99375: CALL 103036 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
99379: LD_VAR 0 1
99383: PUSH
99384: LD_INT 254
99386: EQUAL
99387: PUSH
99388: LD_VAR 0 2
99392: PPUSH
99393: CALL_OW 264
99397: PUSH
99398: LD_EXP 50
99402: EQUAL
99403: AND
99404: PUSH
99405: LD_VAR 0 3
99409: PPUSH
99410: CALL_OW 263
99414: PUSH
99415: LD_INT 3
99417: EQUAL
99418: AND
99419: IFFALSE 99435
// HackDestroyVehicle ( unit , selectedUnit ) ;
99421: LD_VAR 0 2
99425: PPUSH
99426: LD_VAR 0 3
99430: PPUSH
99431: CALL 101331 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
99435: LD_VAR 0 1
99439: PUSH
99440: LD_INT 255
99442: EQUAL
99443: PUSH
99444: LD_VAR 0 2
99448: PPUSH
99449: CALL_OW 264
99453: PUSH
99454: LD_INT 14
99456: PUSH
99457: LD_INT 53
99459: PUSH
99460: EMPTY
99461: LIST
99462: LIST
99463: IN
99464: AND
99465: PUSH
99466: LD_VAR 0 4
99470: PPUSH
99471: LD_VAR 0 5
99475: PPUSH
99476: CALL_OW 488
99480: AND
99481: IFFALSE 99505
// CutTreeXYR ( unit , x , y , 12 ) ;
99483: LD_VAR 0 2
99487: PPUSH
99488: LD_VAR 0 4
99492: PPUSH
99493: LD_VAR 0 5
99497: PPUSH
99498: LD_INT 12
99500: PPUSH
99501: CALL 99897 0 4
// if cmd = 256 then
99505: LD_VAR 0 1
99509: PUSH
99510: LD_INT 256
99512: EQUAL
99513: IFFALSE 99534
// SetFactoryWaypoint ( unit , x , y ) ;
99515: LD_VAR 0 2
99519: PPUSH
99520: LD_VAR 0 4
99524: PPUSH
99525: LD_VAR 0 5
99529: PPUSH
99530: CALL 99539 0 3
// end ;
99534: LD_VAR 0 6
99538: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
99539: LD_INT 0
99541: PPUSH
99542: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
99543: LD_VAR 0 1
99547: NOT
99548: PUSH
99549: LD_VAR 0 2
99553: PPUSH
99554: LD_VAR 0 3
99558: PPUSH
99559: CALL_OW 488
99563: NOT
99564: OR
99565: PUSH
99566: LD_VAR 0 1
99570: PPUSH
99571: CALL_OW 266
99575: PUSH
99576: LD_INT 3
99578: NONEQUAL
99579: PUSH
99580: LD_VAR 0 1
99584: PPUSH
99585: CALL_OW 247
99589: PUSH
99590: LD_INT 1
99592: EQUAL
99593: NOT
99594: AND
99595: OR
99596: IFFALSE 99600
// exit ;
99598: GO 99749
// if GetType ( factory ) = unit_human then
99600: LD_VAR 0 1
99604: PPUSH
99605: CALL_OW 247
99609: PUSH
99610: LD_INT 1
99612: EQUAL
99613: IFFALSE 99630
// factory := IsInUnit ( factory ) ;
99615: LD_ADDR_VAR 0 1
99619: PUSH
99620: LD_VAR 0 1
99624: PPUSH
99625: CALL_OW 310
99629: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
99630: LD_VAR 0 1
99634: PPUSH
99635: CALL_OW 266
99639: PUSH
99640: LD_INT 3
99642: NONEQUAL
99643: IFFALSE 99647
// exit ;
99645: GO 99749
// if HexInfo ( x , y ) = factory then
99647: LD_VAR 0 2
99651: PPUSH
99652: LD_VAR 0 3
99656: PPUSH
99657: CALL_OW 428
99661: PUSH
99662: LD_VAR 0 1
99666: EQUAL
99667: IFFALSE 99694
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
99669: LD_ADDR_EXP 171
99673: PUSH
99674: LD_EXP 171
99678: PPUSH
99679: LD_VAR 0 1
99683: PPUSH
99684: LD_INT 0
99686: PPUSH
99687: CALL_OW 1
99691: ST_TO_ADDR
99692: GO 99745
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
99694: LD_ADDR_EXP 171
99698: PUSH
99699: LD_EXP 171
99703: PPUSH
99704: LD_VAR 0 1
99708: PPUSH
99709: LD_VAR 0 1
99713: PPUSH
99714: CALL_OW 255
99718: PUSH
99719: LD_VAR 0 1
99723: PUSH
99724: LD_VAR 0 2
99728: PUSH
99729: LD_VAR 0 3
99733: PUSH
99734: EMPTY
99735: LIST
99736: LIST
99737: LIST
99738: LIST
99739: PPUSH
99740: CALL_OW 1
99744: ST_TO_ADDR
// UpdateFactoryWaypoints ;
99745: CALL 99754 0 0
// end ;
99749: LD_VAR 0 4
99753: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
99754: LD_INT 0
99756: PPUSH
99757: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
99758: LD_STRING resetFactoryWaypoint();
99760: PPUSH
99761: CALL_OW 559
// if factoryWaypoints then
99765: LD_EXP 171
99769: IFFALSE 99892
// begin for i := 1 to factoryWaypoints do
99771: LD_ADDR_VAR 0 2
99775: PUSH
99776: DOUBLE
99777: LD_INT 1
99779: DEC
99780: ST_TO_ADDR
99781: LD_EXP 171
99785: PUSH
99786: FOR_TO
99787: IFFALSE 99890
// if factoryWaypoints [ i ] then
99789: LD_EXP 171
99793: PUSH
99794: LD_VAR 0 2
99798: ARRAY
99799: IFFALSE 99888
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
99801: LD_STRING setFactoryWaypointXY(
99803: PUSH
99804: LD_EXP 171
99808: PUSH
99809: LD_VAR 0 2
99813: ARRAY
99814: PUSH
99815: LD_INT 1
99817: ARRAY
99818: STR
99819: PUSH
99820: LD_STRING ,
99822: STR
99823: PUSH
99824: LD_EXP 171
99828: PUSH
99829: LD_VAR 0 2
99833: ARRAY
99834: PUSH
99835: LD_INT 2
99837: ARRAY
99838: STR
99839: PUSH
99840: LD_STRING ,
99842: STR
99843: PUSH
99844: LD_EXP 171
99848: PUSH
99849: LD_VAR 0 2
99853: ARRAY
99854: PUSH
99855: LD_INT 3
99857: ARRAY
99858: STR
99859: PUSH
99860: LD_STRING ,
99862: STR
99863: PUSH
99864: LD_EXP 171
99868: PUSH
99869: LD_VAR 0 2
99873: ARRAY
99874: PUSH
99875: LD_INT 4
99877: ARRAY
99878: STR
99879: PUSH
99880: LD_STRING )
99882: STR
99883: PPUSH
99884: CALL_OW 559
99888: GO 99786
99890: POP
99891: POP
// end ; end ;
99892: LD_VAR 0 1
99896: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
99897: LD_INT 0
99899: PPUSH
99900: PPUSH
99901: PPUSH
99902: PPUSH
99903: PPUSH
99904: PPUSH
99905: PPUSH
99906: PPUSH
99907: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
99908: LD_VAR 0 1
99912: NOT
99913: PUSH
99914: LD_VAR 0 2
99918: PPUSH
99919: LD_VAR 0 3
99923: PPUSH
99924: CALL_OW 488
99928: NOT
99929: OR
99930: PUSH
99931: LD_VAR 0 4
99935: NOT
99936: OR
99937: IFFALSE 99941
// exit ;
99939: GO 100281
// list := [ ] ;
99941: LD_ADDR_VAR 0 13
99945: PUSH
99946: EMPTY
99947: ST_TO_ADDR
// if x - r < 0 then
99948: LD_VAR 0 2
99952: PUSH
99953: LD_VAR 0 4
99957: MINUS
99958: PUSH
99959: LD_INT 0
99961: LESS
99962: IFFALSE 99974
// min_x := 0 else
99964: LD_ADDR_VAR 0 7
99968: PUSH
99969: LD_INT 0
99971: ST_TO_ADDR
99972: GO 99990
// min_x := x - r ;
99974: LD_ADDR_VAR 0 7
99978: PUSH
99979: LD_VAR 0 2
99983: PUSH
99984: LD_VAR 0 4
99988: MINUS
99989: ST_TO_ADDR
// if y - r < 0 then
99990: LD_VAR 0 3
99994: PUSH
99995: LD_VAR 0 4
99999: MINUS
100000: PUSH
100001: LD_INT 0
100003: LESS
100004: IFFALSE 100016
// min_y := 0 else
100006: LD_ADDR_VAR 0 8
100010: PUSH
100011: LD_INT 0
100013: ST_TO_ADDR
100014: GO 100032
// min_y := y - r ;
100016: LD_ADDR_VAR 0 8
100020: PUSH
100021: LD_VAR 0 3
100025: PUSH
100026: LD_VAR 0 4
100030: MINUS
100031: ST_TO_ADDR
// max_x := x + r ;
100032: LD_ADDR_VAR 0 9
100036: PUSH
100037: LD_VAR 0 2
100041: PUSH
100042: LD_VAR 0 4
100046: PLUS
100047: ST_TO_ADDR
// max_y := y + r ;
100048: LD_ADDR_VAR 0 10
100052: PUSH
100053: LD_VAR 0 3
100057: PUSH
100058: LD_VAR 0 4
100062: PLUS
100063: ST_TO_ADDR
// for _x = min_x to max_x do
100064: LD_ADDR_VAR 0 11
100068: PUSH
100069: DOUBLE
100070: LD_VAR 0 7
100074: DEC
100075: ST_TO_ADDR
100076: LD_VAR 0 9
100080: PUSH
100081: FOR_TO
100082: IFFALSE 100199
// for _y = min_y to max_y do
100084: LD_ADDR_VAR 0 12
100088: PUSH
100089: DOUBLE
100090: LD_VAR 0 8
100094: DEC
100095: ST_TO_ADDR
100096: LD_VAR 0 10
100100: PUSH
100101: FOR_TO
100102: IFFALSE 100195
// begin if not ValidHex ( _x , _y ) then
100104: LD_VAR 0 11
100108: PPUSH
100109: LD_VAR 0 12
100113: PPUSH
100114: CALL_OW 488
100118: NOT
100119: IFFALSE 100123
// continue ;
100121: GO 100101
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
100123: LD_VAR 0 11
100127: PPUSH
100128: LD_VAR 0 12
100132: PPUSH
100133: CALL_OW 351
100137: PUSH
100138: LD_VAR 0 11
100142: PPUSH
100143: LD_VAR 0 12
100147: PPUSH
100148: CALL_OW 554
100152: AND
100153: IFFALSE 100193
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
100155: LD_ADDR_VAR 0 13
100159: PUSH
100160: LD_VAR 0 13
100164: PPUSH
100165: LD_VAR 0 13
100169: PUSH
100170: LD_INT 1
100172: PLUS
100173: PPUSH
100174: LD_VAR 0 11
100178: PUSH
100179: LD_VAR 0 12
100183: PUSH
100184: EMPTY
100185: LIST
100186: LIST
100187: PPUSH
100188: CALL_OW 2
100192: ST_TO_ADDR
// end ;
100193: GO 100101
100195: POP
100196: POP
100197: GO 100081
100199: POP
100200: POP
// if not list then
100201: LD_VAR 0 13
100205: NOT
100206: IFFALSE 100210
// exit ;
100208: GO 100281
// for i in list do
100210: LD_ADDR_VAR 0 6
100214: PUSH
100215: LD_VAR 0 13
100219: PUSH
100220: FOR_IN
100221: IFFALSE 100279
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
100223: LD_VAR 0 1
100227: PPUSH
100228: LD_STRING M
100230: PUSH
100231: LD_VAR 0 6
100235: PUSH
100236: LD_INT 1
100238: ARRAY
100239: PUSH
100240: LD_VAR 0 6
100244: PUSH
100245: LD_INT 2
100247: ARRAY
100248: PUSH
100249: LD_INT 0
100251: PUSH
100252: LD_INT 0
100254: PUSH
100255: LD_INT 0
100257: PUSH
100258: LD_INT 0
100260: PUSH
100261: EMPTY
100262: LIST
100263: LIST
100264: LIST
100265: LIST
100266: LIST
100267: LIST
100268: LIST
100269: PUSH
100270: EMPTY
100271: LIST
100272: PPUSH
100273: CALL_OW 447
100277: GO 100220
100279: POP
100280: POP
// end ;
100281: LD_VAR 0 5
100285: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
100286: LD_EXP 172
100290: NOT
100291: IFFALSE 100341
100293: GO 100295
100295: DISABLE
// begin initHack := true ;
100296: LD_ADDR_EXP 172
100300: PUSH
100301: LD_INT 1
100303: ST_TO_ADDR
// hackTanks := [ ] ;
100304: LD_ADDR_EXP 173
100308: PUSH
100309: EMPTY
100310: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
100311: LD_ADDR_EXP 174
100315: PUSH
100316: EMPTY
100317: ST_TO_ADDR
// hackLimit := 3 ;
100318: LD_ADDR_EXP 175
100322: PUSH
100323: LD_INT 3
100325: ST_TO_ADDR
// hackDist := 12 ;
100326: LD_ADDR_EXP 176
100330: PUSH
100331: LD_INT 12
100333: ST_TO_ADDR
// hackCounter := [ ] ;
100334: LD_ADDR_EXP 177
100338: PUSH
100339: EMPTY
100340: ST_TO_ADDR
// end ;
100341: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
100342: LD_EXP 172
100346: PUSH
100347: LD_INT 34
100349: PUSH
100350: LD_EXP 50
100354: PUSH
100355: EMPTY
100356: LIST
100357: LIST
100358: PPUSH
100359: CALL_OW 69
100363: AND
100364: IFFALSE 100619
100366: GO 100368
100368: DISABLE
100369: LD_INT 0
100371: PPUSH
100372: PPUSH
// begin enable ;
100373: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
100374: LD_ADDR_VAR 0 1
100378: PUSH
100379: LD_INT 34
100381: PUSH
100382: LD_EXP 50
100386: PUSH
100387: EMPTY
100388: LIST
100389: LIST
100390: PPUSH
100391: CALL_OW 69
100395: PUSH
100396: FOR_IN
100397: IFFALSE 100617
// begin if not i in hackTanks then
100399: LD_VAR 0 1
100403: PUSH
100404: LD_EXP 173
100408: IN
100409: NOT
100410: IFFALSE 100493
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
100412: LD_ADDR_EXP 173
100416: PUSH
100417: LD_EXP 173
100421: PPUSH
100422: LD_EXP 173
100426: PUSH
100427: LD_INT 1
100429: PLUS
100430: PPUSH
100431: LD_VAR 0 1
100435: PPUSH
100436: CALL_OW 1
100440: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
100441: LD_ADDR_EXP 174
100445: PUSH
100446: LD_EXP 174
100450: PPUSH
100451: LD_EXP 174
100455: PUSH
100456: LD_INT 1
100458: PLUS
100459: PPUSH
100460: EMPTY
100461: PPUSH
100462: CALL_OW 1
100466: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
100467: LD_ADDR_EXP 177
100471: PUSH
100472: LD_EXP 177
100476: PPUSH
100477: LD_EXP 177
100481: PUSH
100482: LD_INT 1
100484: PLUS
100485: PPUSH
100486: EMPTY
100487: PPUSH
100488: CALL_OW 1
100492: ST_TO_ADDR
// end ; if not IsOk ( i ) then
100493: LD_VAR 0 1
100497: PPUSH
100498: CALL_OW 302
100502: NOT
100503: IFFALSE 100516
// begin HackUnlinkAll ( i ) ;
100505: LD_VAR 0 1
100509: PPUSH
100510: CALL 100622 0 1
// continue ;
100514: GO 100396
// end ; HackCheckCapturedStatus ( i ) ;
100516: LD_VAR 0 1
100520: PPUSH
100521: CALL 101065 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
100525: LD_ADDR_VAR 0 2
100529: PUSH
100530: LD_INT 81
100532: PUSH
100533: LD_VAR 0 1
100537: PPUSH
100538: CALL_OW 255
100542: PUSH
100543: EMPTY
100544: LIST
100545: LIST
100546: PUSH
100547: LD_INT 33
100549: PUSH
100550: LD_INT 3
100552: PUSH
100553: EMPTY
100554: LIST
100555: LIST
100556: PUSH
100557: LD_INT 91
100559: PUSH
100560: LD_VAR 0 1
100564: PUSH
100565: LD_EXP 176
100569: PUSH
100570: EMPTY
100571: LIST
100572: LIST
100573: LIST
100574: PUSH
100575: LD_INT 50
100577: PUSH
100578: EMPTY
100579: LIST
100580: PUSH
100581: EMPTY
100582: LIST
100583: LIST
100584: LIST
100585: LIST
100586: PPUSH
100587: CALL_OW 69
100591: ST_TO_ADDR
// if not tmp then
100592: LD_VAR 0 2
100596: NOT
100597: IFFALSE 100601
// continue ;
100599: GO 100396
// HackLink ( i , tmp ) ;
100601: LD_VAR 0 1
100605: PPUSH
100606: LD_VAR 0 2
100610: PPUSH
100611: CALL 100758 0 2
// end ;
100615: GO 100396
100617: POP
100618: POP
// end ;
100619: PPOPN 2
100621: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
100622: LD_INT 0
100624: PPUSH
100625: PPUSH
100626: PPUSH
// if not hack in hackTanks then
100627: LD_VAR 0 1
100631: PUSH
100632: LD_EXP 173
100636: IN
100637: NOT
100638: IFFALSE 100642
// exit ;
100640: GO 100753
// index := GetElementIndex ( hackTanks , hack ) ;
100642: LD_ADDR_VAR 0 4
100646: PUSH
100647: LD_EXP 173
100651: PPUSH
100652: LD_VAR 0 1
100656: PPUSH
100657: CALL 18373 0 2
100661: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
100662: LD_EXP 174
100666: PUSH
100667: LD_VAR 0 4
100671: ARRAY
100672: IFFALSE 100753
// begin for i in hackTanksCaptured [ index ] do
100674: LD_ADDR_VAR 0 3
100678: PUSH
100679: LD_EXP 174
100683: PUSH
100684: LD_VAR 0 4
100688: ARRAY
100689: PUSH
100690: FOR_IN
100691: IFFALSE 100717
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
100693: LD_VAR 0 3
100697: PUSH
100698: LD_INT 1
100700: ARRAY
100701: PPUSH
100702: LD_VAR 0 3
100706: PUSH
100707: LD_INT 2
100709: ARRAY
100710: PPUSH
100711: CALL_OW 235
100715: GO 100690
100717: POP
100718: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
100719: LD_ADDR_EXP 174
100723: PUSH
100724: LD_EXP 174
100728: PPUSH
100729: LD_VAR 0 4
100733: PPUSH
100734: EMPTY
100735: PPUSH
100736: CALL_OW 1
100740: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
100741: LD_VAR 0 1
100745: PPUSH
100746: LD_INT 0
100748: PPUSH
100749: CALL_OW 505
// end ; end ;
100753: LD_VAR 0 2
100757: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
100758: LD_INT 0
100760: PPUSH
100761: PPUSH
100762: PPUSH
// if not hack in hackTanks or not vehicles then
100763: LD_VAR 0 1
100767: PUSH
100768: LD_EXP 173
100772: IN
100773: NOT
100774: PUSH
100775: LD_VAR 0 2
100779: NOT
100780: OR
100781: IFFALSE 100785
// exit ;
100783: GO 101060
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
100785: LD_ADDR_VAR 0 2
100789: PUSH
100790: LD_VAR 0 1
100794: PPUSH
100795: LD_VAR 0 2
100799: PPUSH
100800: LD_INT 1
100802: PPUSH
100803: LD_INT 1
100805: PPUSH
100806: CALL 19023 0 4
100810: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
100811: LD_ADDR_VAR 0 5
100815: PUSH
100816: LD_EXP 173
100820: PPUSH
100821: LD_VAR 0 1
100825: PPUSH
100826: CALL 18373 0 2
100830: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
100831: LD_EXP 174
100835: PUSH
100836: LD_VAR 0 5
100840: ARRAY
100841: PUSH
100842: LD_EXP 175
100846: LESS
100847: IFFALSE 101036
// begin for i := 1 to vehicles do
100849: LD_ADDR_VAR 0 4
100853: PUSH
100854: DOUBLE
100855: LD_INT 1
100857: DEC
100858: ST_TO_ADDR
100859: LD_VAR 0 2
100863: PUSH
100864: FOR_TO
100865: IFFALSE 101034
// begin if hackTanksCaptured [ index ] = hackLimit then
100867: LD_EXP 174
100871: PUSH
100872: LD_VAR 0 5
100876: ARRAY
100877: PUSH
100878: LD_EXP 175
100882: EQUAL
100883: IFFALSE 100887
// break ;
100885: GO 101034
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
100887: LD_ADDR_EXP 177
100891: PUSH
100892: LD_EXP 177
100896: PPUSH
100897: LD_VAR 0 5
100901: PPUSH
100902: LD_EXP 177
100906: PUSH
100907: LD_VAR 0 5
100911: ARRAY
100912: PUSH
100913: LD_INT 1
100915: PLUS
100916: PPUSH
100917: CALL_OW 1
100921: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
100922: LD_ADDR_EXP 174
100926: PUSH
100927: LD_EXP 174
100931: PPUSH
100932: LD_VAR 0 5
100936: PUSH
100937: LD_EXP 174
100941: PUSH
100942: LD_VAR 0 5
100946: ARRAY
100947: PUSH
100948: LD_INT 1
100950: PLUS
100951: PUSH
100952: EMPTY
100953: LIST
100954: LIST
100955: PPUSH
100956: LD_VAR 0 2
100960: PUSH
100961: LD_VAR 0 4
100965: ARRAY
100966: PUSH
100967: LD_VAR 0 2
100971: PUSH
100972: LD_VAR 0 4
100976: ARRAY
100977: PPUSH
100978: CALL_OW 255
100982: PUSH
100983: EMPTY
100984: LIST
100985: LIST
100986: PPUSH
100987: CALL 18588 0 3
100991: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
100992: LD_VAR 0 2
100996: PUSH
100997: LD_VAR 0 4
101001: ARRAY
101002: PPUSH
101003: LD_VAR 0 1
101007: PPUSH
101008: CALL_OW 255
101012: PPUSH
101013: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
101017: LD_VAR 0 2
101021: PUSH
101022: LD_VAR 0 4
101026: ARRAY
101027: PPUSH
101028: CALL_OW 141
// end ;
101032: GO 100864
101034: POP
101035: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
101036: LD_VAR 0 1
101040: PPUSH
101041: LD_EXP 174
101045: PUSH
101046: LD_VAR 0 5
101050: ARRAY
101051: PUSH
101052: LD_INT 0
101054: PLUS
101055: PPUSH
101056: CALL_OW 505
// end ;
101060: LD_VAR 0 3
101064: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
101065: LD_INT 0
101067: PPUSH
101068: PPUSH
101069: PPUSH
101070: PPUSH
// if not hack in hackTanks then
101071: LD_VAR 0 1
101075: PUSH
101076: LD_EXP 173
101080: IN
101081: NOT
101082: IFFALSE 101086
// exit ;
101084: GO 101326
// index := GetElementIndex ( hackTanks , hack ) ;
101086: LD_ADDR_VAR 0 4
101090: PUSH
101091: LD_EXP 173
101095: PPUSH
101096: LD_VAR 0 1
101100: PPUSH
101101: CALL 18373 0 2
101105: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
101106: LD_ADDR_VAR 0 3
101110: PUSH
101111: DOUBLE
101112: LD_EXP 174
101116: PUSH
101117: LD_VAR 0 4
101121: ARRAY
101122: INC
101123: ST_TO_ADDR
101124: LD_INT 1
101126: PUSH
101127: FOR_DOWNTO
101128: IFFALSE 101300
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
101130: LD_ADDR_VAR 0 5
101134: PUSH
101135: LD_EXP 174
101139: PUSH
101140: LD_VAR 0 4
101144: ARRAY
101145: PUSH
101146: LD_VAR 0 3
101150: ARRAY
101151: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
101152: LD_VAR 0 5
101156: PUSH
101157: LD_INT 1
101159: ARRAY
101160: PPUSH
101161: CALL_OW 302
101165: NOT
101166: PUSH
101167: LD_VAR 0 5
101171: PUSH
101172: LD_INT 1
101174: ARRAY
101175: PPUSH
101176: CALL_OW 255
101180: PUSH
101181: LD_VAR 0 1
101185: PPUSH
101186: CALL_OW 255
101190: NONEQUAL
101191: OR
101192: IFFALSE 101298
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
101194: LD_VAR 0 5
101198: PUSH
101199: LD_INT 1
101201: ARRAY
101202: PPUSH
101203: CALL_OW 305
101207: PUSH
101208: LD_VAR 0 5
101212: PUSH
101213: LD_INT 1
101215: ARRAY
101216: PPUSH
101217: CALL_OW 255
101221: PUSH
101222: LD_VAR 0 1
101226: PPUSH
101227: CALL_OW 255
101231: EQUAL
101232: AND
101233: IFFALSE 101257
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
101235: LD_VAR 0 5
101239: PUSH
101240: LD_INT 1
101242: ARRAY
101243: PPUSH
101244: LD_VAR 0 5
101248: PUSH
101249: LD_INT 2
101251: ARRAY
101252: PPUSH
101253: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
101257: LD_ADDR_EXP 174
101261: PUSH
101262: LD_EXP 174
101266: PPUSH
101267: LD_VAR 0 4
101271: PPUSH
101272: LD_EXP 174
101276: PUSH
101277: LD_VAR 0 4
101281: ARRAY
101282: PPUSH
101283: LD_VAR 0 3
101287: PPUSH
101288: CALL_OW 3
101292: PPUSH
101293: CALL_OW 1
101297: ST_TO_ADDR
// end ; end ;
101298: GO 101127
101300: POP
101301: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
101302: LD_VAR 0 1
101306: PPUSH
101307: LD_EXP 174
101311: PUSH
101312: LD_VAR 0 4
101316: ARRAY
101317: PUSH
101318: LD_INT 0
101320: PLUS
101321: PPUSH
101322: CALL_OW 505
// end ;
101326: LD_VAR 0 2
101330: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
101331: LD_INT 0
101333: PPUSH
101334: PPUSH
101335: PPUSH
101336: PPUSH
// if not hack in hackTanks then
101337: LD_VAR 0 1
101341: PUSH
101342: LD_EXP 173
101346: IN
101347: NOT
101348: IFFALSE 101352
// exit ;
101350: GO 101437
// index := GetElementIndex ( hackTanks , hack ) ;
101352: LD_ADDR_VAR 0 5
101356: PUSH
101357: LD_EXP 173
101361: PPUSH
101362: LD_VAR 0 1
101366: PPUSH
101367: CALL 18373 0 2
101371: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
101372: LD_ADDR_VAR 0 4
101376: PUSH
101377: DOUBLE
101378: LD_INT 1
101380: DEC
101381: ST_TO_ADDR
101382: LD_EXP 174
101386: PUSH
101387: LD_VAR 0 5
101391: ARRAY
101392: PUSH
101393: FOR_TO
101394: IFFALSE 101435
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
101396: LD_EXP 174
101400: PUSH
101401: LD_VAR 0 5
101405: ARRAY
101406: PUSH
101407: LD_VAR 0 4
101411: ARRAY
101412: PUSH
101413: LD_INT 1
101415: ARRAY
101416: PUSH
101417: LD_VAR 0 2
101421: EQUAL
101422: IFFALSE 101433
// KillUnit ( vehicle ) ;
101424: LD_VAR 0 2
101428: PPUSH
101429: CALL_OW 66
101433: GO 101393
101435: POP
101436: POP
// end ;
101437: LD_VAR 0 3
101441: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
101442: LD_EXP 178
101446: NOT
101447: IFFALSE 101482
101449: GO 101451
101451: DISABLE
// begin initMiner := true ;
101452: LD_ADDR_EXP 178
101456: PUSH
101457: LD_INT 1
101459: ST_TO_ADDR
// minersList := [ ] ;
101460: LD_ADDR_EXP 179
101464: PUSH
101465: EMPTY
101466: ST_TO_ADDR
// minerMinesList := [ ] ;
101467: LD_ADDR_EXP 180
101471: PUSH
101472: EMPTY
101473: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
101474: LD_ADDR_EXP 181
101478: PUSH
101479: LD_INT 5
101481: ST_TO_ADDR
// end ;
101482: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
101483: LD_EXP 178
101487: PUSH
101488: LD_INT 34
101490: PUSH
101491: LD_EXP 55
101495: PUSH
101496: EMPTY
101497: LIST
101498: LIST
101499: PPUSH
101500: CALL_OW 69
101504: AND
101505: IFFALSE 101968
101507: GO 101509
101509: DISABLE
101510: LD_INT 0
101512: PPUSH
101513: PPUSH
101514: PPUSH
101515: PPUSH
// begin enable ;
101516: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
101517: LD_ADDR_VAR 0 1
101521: PUSH
101522: LD_INT 34
101524: PUSH
101525: LD_EXP 55
101529: PUSH
101530: EMPTY
101531: LIST
101532: LIST
101533: PPUSH
101534: CALL_OW 69
101538: PUSH
101539: FOR_IN
101540: IFFALSE 101612
// begin if not i in minersList then
101542: LD_VAR 0 1
101546: PUSH
101547: LD_EXP 179
101551: IN
101552: NOT
101553: IFFALSE 101610
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
101555: LD_ADDR_EXP 179
101559: PUSH
101560: LD_EXP 179
101564: PPUSH
101565: LD_EXP 179
101569: PUSH
101570: LD_INT 1
101572: PLUS
101573: PPUSH
101574: LD_VAR 0 1
101578: PPUSH
101579: CALL_OW 1
101583: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
101584: LD_ADDR_EXP 180
101588: PUSH
101589: LD_EXP 180
101593: PPUSH
101594: LD_EXP 180
101598: PUSH
101599: LD_INT 1
101601: PLUS
101602: PPUSH
101603: EMPTY
101604: PPUSH
101605: CALL_OW 1
101609: ST_TO_ADDR
// end end ;
101610: GO 101539
101612: POP
101613: POP
// for i := minerMinesList downto 1 do
101614: LD_ADDR_VAR 0 1
101618: PUSH
101619: DOUBLE
101620: LD_EXP 180
101624: INC
101625: ST_TO_ADDR
101626: LD_INT 1
101628: PUSH
101629: FOR_DOWNTO
101630: IFFALSE 101966
// begin if IsLive ( minersList [ i ] ) then
101632: LD_EXP 179
101636: PUSH
101637: LD_VAR 0 1
101641: ARRAY
101642: PPUSH
101643: CALL_OW 300
101647: IFFALSE 101675
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
101649: LD_EXP 179
101653: PUSH
101654: LD_VAR 0 1
101658: ARRAY
101659: PPUSH
101660: LD_EXP 180
101664: PUSH
101665: LD_VAR 0 1
101669: ARRAY
101670: PPUSH
101671: CALL_OW 505
// if not minerMinesList [ i ] then
101675: LD_EXP 180
101679: PUSH
101680: LD_VAR 0 1
101684: ARRAY
101685: NOT
101686: IFFALSE 101690
// continue ;
101688: GO 101629
// for j := minerMinesList [ i ] downto 1 do
101690: LD_ADDR_VAR 0 2
101694: PUSH
101695: DOUBLE
101696: LD_EXP 180
101700: PUSH
101701: LD_VAR 0 1
101705: ARRAY
101706: INC
101707: ST_TO_ADDR
101708: LD_INT 1
101710: PUSH
101711: FOR_DOWNTO
101712: IFFALSE 101962
// begin side := GetSide ( minersList [ i ] ) ;
101714: LD_ADDR_VAR 0 3
101718: PUSH
101719: LD_EXP 179
101723: PUSH
101724: LD_VAR 0 1
101728: ARRAY
101729: PPUSH
101730: CALL_OW 255
101734: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
101735: LD_ADDR_VAR 0 4
101739: PUSH
101740: LD_EXP 180
101744: PUSH
101745: LD_VAR 0 1
101749: ARRAY
101750: PUSH
101751: LD_VAR 0 2
101755: ARRAY
101756: PUSH
101757: LD_INT 1
101759: ARRAY
101760: PPUSH
101761: LD_EXP 180
101765: PUSH
101766: LD_VAR 0 1
101770: ARRAY
101771: PUSH
101772: LD_VAR 0 2
101776: ARRAY
101777: PUSH
101778: LD_INT 2
101780: ARRAY
101781: PPUSH
101782: CALL_OW 428
101786: ST_TO_ADDR
// if not tmp then
101787: LD_VAR 0 4
101791: NOT
101792: IFFALSE 101796
// continue ;
101794: GO 101711
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
101796: LD_VAR 0 4
101800: PUSH
101801: LD_INT 81
101803: PUSH
101804: LD_VAR 0 3
101808: PUSH
101809: EMPTY
101810: LIST
101811: LIST
101812: PPUSH
101813: CALL_OW 69
101817: IN
101818: PUSH
101819: LD_EXP 180
101823: PUSH
101824: LD_VAR 0 1
101828: ARRAY
101829: PUSH
101830: LD_VAR 0 2
101834: ARRAY
101835: PUSH
101836: LD_INT 1
101838: ARRAY
101839: PPUSH
101840: LD_EXP 180
101844: PUSH
101845: LD_VAR 0 1
101849: ARRAY
101850: PUSH
101851: LD_VAR 0 2
101855: ARRAY
101856: PUSH
101857: LD_INT 2
101859: ARRAY
101860: PPUSH
101861: CALL_OW 458
101865: AND
101866: IFFALSE 101960
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
101868: LD_EXP 180
101872: PUSH
101873: LD_VAR 0 1
101877: ARRAY
101878: PUSH
101879: LD_VAR 0 2
101883: ARRAY
101884: PUSH
101885: LD_INT 1
101887: ARRAY
101888: PPUSH
101889: LD_EXP 180
101893: PUSH
101894: LD_VAR 0 1
101898: ARRAY
101899: PUSH
101900: LD_VAR 0 2
101904: ARRAY
101905: PUSH
101906: LD_INT 2
101908: ARRAY
101909: PPUSH
101910: LD_VAR 0 3
101914: PPUSH
101915: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
101919: LD_ADDR_EXP 180
101923: PUSH
101924: LD_EXP 180
101928: PPUSH
101929: LD_VAR 0 1
101933: PPUSH
101934: LD_EXP 180
101938: PUSH
101939: LD_VAR 0 1
101943: ARRAY
101944: PPUSH
101945: LD_VAR 0 2
101949: PPUSH
101950: CALL_OW 3
101954: PPUSH
101955: CALL_OW 1
101959: ST_TO_ADDR
// end ; end ;
101960: GO 101711
101962: POP
101963: POP
// end ;
101964: GO 101629
101966: POP
101967: POP
// end ;
101968: PPOPN 4
101970: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
101971: LD_INT 0
101973: PPUSH
101974: PPUSH
// result := false ;
101975: LD_ADDR_VAR 0 4
101979: PUSH
101980: LD_INT 0
101982: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
101983: LD_VAR 0 1
101987: PPUSH
101988: CALL_OW 264
101992: PUSH
101993: LD_EXP 55
101997: EQUAL
101998: NOT
101999: IFFALSE 102003
// exit ;
102001: GO 102243
// index := GetElementIndex ( minersList , unit ) ;
102003: LD_ADDR_VAR 0 5
102007: PUSH
102008: LD_EXP 179
102012: PPUSH
102013: LD_VAR 0 1
102017: PPUSH
102018: CALL 18373 0 2
102022: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
102023: LD_EXP 180
102027: PUSH
102028: LD_VAR 0 5
102032: ARRAY
102033: PUSH
102034: LD_EXP 181
102038: GREATEREQUAL
102039: IFFALSE 102043
// exit ;
102041: GO 102243
// ComMoveXY ( unit , x , y ) ;
102043: LD_VAR 0 1
102047: PPUSH
102048: LD_VAR 0 2
102052: PPUSH
102053: LD_VAR 0 3
102057: PPUSH
102058: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
102062: LD_INT 35
102064: PPUSH
102065: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
102069: LD_VAR 0 1
102073: PPUSH
102074: LD_VAR 0 2
102078: PPUSH
102079: LD_VAR 0 3
102083: PPUSH
102084: CALL 49145 0 3
102088: NOT
102089: PUSH
102090: LD_VAR 0 1
102094: PPUSH
102095: CALL_OW 314
102099: AND
102100: IFFALSE 102104
// exit ;
102102: GO 102243
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
102104: LD_VAR 0 2
102108: PPUSH
102109: LD_VAR 0 3
102113: PPUSH
102114: CALL_OW 428
102118: PUSH
102119: LD_VAR 0 1
102123: EQUAL
102124: PUSH
102125: LD_VAR 0 1
102129: PPUSH
102130: CALL_OW 314
102134: NOT
102135: AND
102136: IFFALSE 102062
// PlaySoundXY ( x , y , PlantMine ) ;
102138: LD_VAR 0 2
102142: PPUSH
102143: LD_VAR 0 3
102147: PPUSH
102148: LD_STRING PlantMine
102150: PPUSH
102151: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
102155: LD_VAR 0 2
102159: PPUSH
102160: LD_VAR 0 3
102164: PPUSH
102165: LD_VAR 0 1
102169: PPUSH
102170: CALL_OW 255
102174: PPUSH
102175: LD_INT 0
102177: PPUSH
102178: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
102182: LD_ADDR_EXP 180
102186: PUSH
102187: LD_EXP 180
102191: PPUSH
102192: LD_VAR 0 5
102196: PUSH
102197: LD_EXP 180
102201: PUSH
102202: LD_VAR 0 5
102206: ARRAY
102207: PUSH
102208: LD_INT 1
102210: PLUS
102211: PUSH
102212: EMPTY
102213: LIST
102214: LIST
102215: PPUSH
102216: LD_VAR 0 2
102220: PUSH
102221: LD_VAR 0 3
102225: PUSH
102226: EMPTY
102227: LIST
102228: LIST
102229: PPUSH
102230: CALL 18588 0 3
102234: ST_TO_ADDR
// result := true ;
102235: LD_ADDR_VAR 0 4
102239: PUSH
102240: LD_INT 1
102242: ST_TO_ADDR
// end ;
102243: LD_VAR 0 4
102247: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
102248: LD_INT 0
102250: PPUSH
102251: PPUSH
102252: PPUSH
// if not unit in minersList then
102253: LD_VAR 0 1
102257: PUSH
102258: LD_EXP 179
102262: IN
102263: NOT
102264: IFFALSE 102268
// exit ;
102266: GO 102660
// index := GetElementIndex ( minersList , unit ) ;
102268: LD_ADDR_VAR 0 6
102272: PUSH
102273: LD_EXP 179
102277: PPUSH
102278: LD_VAR 0 1
102282: PPUSH
102283: CALL 18373 0 2
102287: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
102288: LD_ADDR_VAR 0 5
102292: PUSH
102293: DOUBLE
102294: LD_EXP 180
102298: PUSH
102299: LD_VAR 0 6
102303: ARRAY
102304: INC
102305: ST_TO_ADDR
102306: LD_INT 1
102308: PUSH
102309: FOR_DOWNTO
102310: IFFALSE 102471
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
102312: LD_EXP 180
102316: PUSH
102317: LD_VAR 0 6
102321: ARRAY
102322: PUSH
102323: LD_VAR 0 5
102327: ARRAY
102328: PUSH
102329: LD_INT 1
102331: ARRAY
102332: PUSH
102333: LD_VAR 0 2
102337: EQUAL
102338: PUSH
102339: LD_EXP 180
102343: PUSH
102344: LD_VAR 0 6
102348: ARRAY
102349: PUSH
102350: LD_VAR 0 5
102354: ARRAY
102355: PUSH
102356: LD_INT 2
102358: ARRAY
102359: PUSH
102360: LD_VAR 0 3
102364: EQUAL
102365: AND
102366: IFFALSE 102469
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
102368: LD_EXP 180
102372: PUSH
102373: LD_VAR 0 6
102377: ARRAY
102378: PUSH
102379: LD_VAR 0 5
102383: ARRAY
102384: PUSH
102385: LD_INT 1
102387: ARRAY
102388: PPUSH
102389: LD_EXP 180
102393: PUSH
102394: LD_VAR 0 6
102398: ARRAY
102399: PUSH
102400: LD_VAR 0 5
102404: ARRAY
102405: PUSH
102406: LD_INT 2
102408: ARRAY
102409: PPUSH
102410: LD_VAR 0 1
102414: PPUSH
102415: CALL_OW 255
102419: PPUSH
102420: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
102424: LD_ADDR_EXP 180
102428: PUSH
102429: LD_EXP 180
102433: PPUSH
102434: LD_VAR 0 6
102438: PPUSH
102439: LD_EXP 180
102443: PUSH
102444: LD_VAR 0 6
102448: ARRAY
102449: PPUSH
102450: LD_VAR 0 5
102454: PPUSH
102455: CALL_OW 3
102459: PPUSH
102460: CALL_OW 1
102464: ST_TO_ADDR
// exit ;
102465: POP
102466: POP
102467: GO 102660
// end ; end ;
102469: GO 102309
102471: POP
102472: POP
// for i := minerMinesList [ index ] downto 1 do
102473: LD_ADDR_VAR 0 5
102477: PUSH
102478: DOUBLE
102479: LD_EXP 180
102483: PUSH
102484: LD_VAR 0 6
102488: ARRAY
102489: INC
102490: ST_TO_ADDR
102491: LD_INT 1
102493: PUSH
102494: FOR_DOWNTO
102495: IFFALSE 102658
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
102497: LD_EXP 180
102501: PUSH
102502: LD_VAR 0 6
102506: ARRAY
102507: PUSH
102508: LD_VAR 0 5
102512: ARRAY
102513: PUSH
102514: LD_INT 1
102516: ARRAY
102517: PPUSH
102518: LD_EXP 180
102522: PUSH
102523: LD_VAR 0 6
102527: ARRAY
102528: PUSH
102529: LD_VAR 0 5
102533: ARRAY
102534: PUSH
102535: LD_INT 2
102537: ARRAY
102538: PPUSH
102539: LD_VAR 0 2
102543: PPUSH
102544: LD_VAR 0 3
102548: PPUSH
102549: CALL_OW 298
102553: PUSH
102554: LD_INT 6
102556: LESS
102557: IFFALSE 102656
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
102559: LD_EXP 180
102563: PUSH
102564: LD_VAR 0 6
102568: ARRAY
102569: PUSH
102570: LD_VAR 0 5
102574: ARRAY
102575: PUSH
102576: LD_INT 1
102578: ARRAY
102579: PPUSH
102580: LD_EXP 180
102584: PUSH
102585: LD_VAR 0 6
102589: ARRAY
102590: PUSH
102591: LD_VAR 0 5
102595: ARRAY
102596: PUSH
102597: LD_INT 2
102599: ARRAY
102600: PPUSH
102601: LD_VAR 0 1
102605: PPUSH
102606: CALL_OW 255
102610: PPUSH
102611: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
102615: LD_ADDR_EXP 180
102619: PUSH
102620: LD_EXP 180
102624: PPUSH
102625: LD_VAR 0 6
102629: PPUSH
102630: LD_EXP 180
102634: PUSH
102635: LD_VAR 0 6
102639: ARRAY
102640: PPUSH
102641: LD_VAR 0 5
102645: PPUSH
102646: CALL_OW 3
102650: PPUSH
102651: CALL_OW 1
102655: ST_TO_ADDR
// end ; end ;
102656: GO 102494
102658: POP
102659: POP
// end ;
102660: LD_VAR 0 4
102664: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
102665: LD_INT 0
102667: PPUSH
102668: PPUSH
102669: PPUSH
102670: PPUSH
102671: PPUSH
102672: PPUSH
102673: PPUSH
102674: PPUSH
102675: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
102676: LD_VAR 0 1
102680: PPUSH
102681: CALL_OW 264
102685: PUSH
102686: LD_EXP 55
102690: EQUAL
102691: NOT
102692: PUSH
102693: LD_VAR 0 1
102697: PUSH
102698: LD_EXP 179
102702: IN
102703: NOT
102704: OR
102705: IFFALSE 102709
// exit ;
102707: GO 103031
// index := GetElementIndex ( minersList , unit ) ;
102709: LD_ADDR_VAR 0 6
102713: PUSH
102714: LD_EXP 179
102718: PPUSH
102719: LD_VAR 0 1
102723: PPUSH
102724: CALL 18373 0 2
102728: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
102729: LD_ADDR_VAR 0 8
102733: PUSH
102734: LD_EXP 181
102738: PUSH
102739: LD_EXP 180
102743: PUSH
102744: LD_VAR 0 6
102748: ARRAY
102749: MINUS
102750: ST_TO_ADDR
// if not minesFreeAmount then
102751: LD_VAR 0 8
102755: NOT
102756: IFFALSE 102760
// exit ;
102758: GO 103031
// tmp := [ ] ;
102760: LD_ADDR_VAR 0 7
102764: PUSH
102765: EMPTY
102766: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
102767: LD_ADDR_VAR 0 5
102771: PUSH
102772: DOUBLE
102773: LD_INT 1
102775: DEC
102776: ST_TO_ADDR
102777: LD_VAR 0 8
102781: PUSH
102782: FOR_TO
102783: IFFALSE 102978
// begin _d := rand ( 0 , 5 ) ;
102785: LD_ADDR_VAR 0 11
102789: PUSH
102790: LD_INT 0
102792: PPUSH
102793: LD_INT 5
102795: PPUSH
102796: CALL_OW 12
102800: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
102801: LD_ADDR_VAR 0 12
102805: PUSH
102806: LD_INT 2
102808: PPUSH
102809: LD_INT 6
102811: PPUSH
102812: CALL_OW 12
102816: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
102817: LD_ADDR_VAR 0 9
102821: PUSH
102822: LD_VAR 0 2
102826: PPUSH
102827: LD_VAR 0 11
102831: PPUSH
102832: LD_VAR 0 12
102836: PPUSH
102837: CALL_OW 272
102841: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
102842: LD_ADDR_VAR 0 10
102846: PUSH
102847: LD_VAR 0 3
102851: PPUSH
102852: LD_VAR 0 11
102856: PPUSH
102857: LD_VAR 0 12
102861: PPUSH
102862: CALL_OW 273
102866: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
102867: LD_VAR 0 9
102871: PPUSH
102872: LD_VAR 0 10
102876: PPUSH
102877: CALL_OW 488
102881: PUSH
102882: LD_VAR 0 9
102886: PUSH
102887: LD_VAR 0 10
102891: PUSH
102892: EMPTY
102893: LIST
102894: LIST
102895: PUSH
102896: LD_VAR 0 7
102900: IN
102901: NOT
102902: AND
102903: PUSH
102904: LD_VAR 0 9
102908: PPUSH
102909: LD_VAR 0 10
102913: PPUSH
102914: CALL_OW 458
102918: NOT
102919: AND
102920: IFFALSE 102962
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
102922: LD_ADDR_VAR 0 7
102926: PUSH
102927: LD_VAR 0 7
102931: PPUSH
102932: LD_VAR 0 7
102936: PUSH
102937: LD_INT 1
102939: PLUS
102940: PPUSH
102941: LD_VAR 0 9
102945: PUSH
102946: LD_VAR 0 10
102950: PUSH
102951: EMPTY
102952: LIST
102953: LIST
102954: PPUSH
102955: CALL_OW 1
102959: ST_TO_ADDR
102960: GO 102976
// i := i - 1 ;
102962: LD_ADDR_VAR 0 5
102966: PUSH
102967: LD_VAR 0 5
102971: PUSH
102972: LD_INT 1
102974: MINUS
102975: ST_TO_ADDR
// end ;
102976: GO 102782
102978: POP
102979: POP
// for i in tmp do
102980: LD_ADDR_VAR 0 5
102984: PUSH
102985: LD_VAR 0 7
102989: PUSH
102990: FOR_IN
102991: IFFALSE 103029
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
102993: LD_VAR 0 1
102997: PPUSH
102998: LD_VAR 0 5
103002: PUSH
103003: LD_INT 1
103005: ARRAY
103006: PPUSH
103007: LD_VAR 0 5
103011: PUSH
103012: LD_INT 2
103014: ARRAY
103015: PPUSH
103016: CALL 101971 0 3
103020: NOT
103021: IFFALSE 103027
// exit ;
103023: POP
103024: POP
103025: GO 103031
103027: GO 102990
103029: POP
103030: POP
// end ;
103031: LD_VAR 0 4
103035: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
103036: LD_INT 0
103038: PPUSH
103039: PPUSH
103040: PPUSH
103041: PPUSH
103042: PPUSH
103043: PPUSH
103044: PPUSH
// if not GetClass ( unit ) = class_sniper then
103045: LD_VAR 0 1
103049: PPUSH
103050: CALL_OW 257
103054: PUSH
103055: LD_INT 5
103057: EQUAL
103058: NOT
103059: IFFALSE 103063
// exit ;
103061: GO 103451
// dist := 8 ;
103063: LD_ADDR_VAR 0 5
103067: PUSH
103068: LD_INT 8
103070: ST_TO_ADDR
// viewRange := 12 ;
103071: LD_ADDR_VAR 0 7
103075: PUSH
103076: LD_INT 12
103078: ST_TO_ADDR
// side := GetSide ( unit ) ;
103079: LD_ADDR_VAR 0 6
103083: PUSH
103084: LD_VAR 0 1
103088: PPUSH
103089: CALL_OW 255
103093: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
103094: LD_INT 61
103096: PPUSH
103097: LD_VAR 0 6
103101: PPUSH
103102: CALL_OW 321
103106: PUSH
103107: LD_INT 2
103109: EQUAL
103110: IFFALSE 103120
// viewRange := 16 ;
103112: LD_ADDR_VAR 0 7
103116: PUSH
103117: LD_INT 16
103119: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
103120: LD_VAR 0 1
103124: PPUSH
103125: LD_VAR 0 2
103129: PPUSH
103130: LD_VAR 0 3
103134: PPUSH
103135: CALL_OW 297
103139: PUSH
103140: LD_VAR 0 5
103144: GREATER
103145: IFFALSE 103224
// begin ComMoveXY ( unit , x , y ) ;
103147: LD_VAR 0 1
103151: PPUSH
103152: LD_VAR 0 2
103156: PPUSH
103157: LD_VAR 0 3
103161: PPUSH
103162: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
103166: LD_INT 35
103168: PPUSH
103169: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
103173: LD_VAR 0 1
103177: PPUSH
103178: LD_VAR 0 2
103182: PPUSH
103183: LD_VAR 0 3
103187: PPUSH
103188: CALL 49145 0 3
103192: NOT
103193: IFFALSE 103197
// exit ;
103195: GO 103451
// until GetDistUnitXY ( unit , x , y ) < dist ;
103197: LD_VAR 0 1
103201: PPUSH
103202: LD_VAR 0 2
103206: PPUSH
103207: LD_VAR 0 3
103211: PPUSH
103212: CALL_OW 297
103216: PUSH
103217: LD_VAR 0 5
103221: LESS
103222: IFFALSE 103166
// end ; ComTurnXY ( unit , x , y ) ;
103224: LD_VAR 0 1
103228: PPUSH
103229: LD_VAR 0 2
103233: PPUSH
103234: LD_VAR 0 3
103238: PPUSH
103239: CALL_OW 118
// wait ( 5 ) ;
103243: LD_INT 5
103245: PPUSH
103246: CALL_OW 67
// _d := GetDir ( unit ) ;
103250: LD_ADDR_VAR 0 10
103254: PUSH
103255: LD_VAR 0 1
103259: PPUSH
103260: CALL_OW 254
103264: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
103265: LD_ADDR_VAR 0 8
103269: PUSH
103270: LD_VAR 0 1
103274: PPUSH
103275: CALL_OW 250
103279: PPUSH
103280: LD_VAR 0 10
103284: PPUSH
103285: LD_VAR 0 5
103289: PPUSH
103290: CALL_OW 272
103294: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
103295: LD_ADDR_VAR 0 9
103299: PUSH
103300: LD_VAR 0 1
103304: PPUSH
103305: CALL_OW 251
103309: PPUSH
103310: LD_VAR 0 10
103314: PPUSH
103315: LD_VAR 0 5
103319: PPUSH
103320: CALL_OW 273
103324: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
103325: LD_VAR 0 8
103329: PPUSH
103330: LD_VAR 0 9
103334: PPUSH
103335: CALL_OW 488
103339: NOT
103340: IFFALSE 103344
// exit ;
103342: GO 103451
// ComAnimCustom ( unit , 1 ) ;
103344: LD_VAR 0 1
103348: PPUSH
103349: LD_INT 1
103351: PPUSH
103352: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
103356: LD_VAR 0 8
103360: PPUSH
103361: LD_VAR 0 9
103365: PPUSH
103366: LD_VAR 0 6
103370: PPUSH
103371: LD_VAR 0 7
103375: PPUSH
103376: CALL_OW 330
// repeat wait ( 1 ) ;
103380: LD_INT 1
103382: PPUSH
103383: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
103387: LD_VAR 0 1
103391: PPUSH
103392: CALL_OW 316
103396: PUSH
103397: LD_VAR 0 1
103401: PPUSH
103402: CALL_OW 314
103406: OR
103407: PUSH
103408: LD_VAR 0 1
103412: PPUSH
103413: CALL_OW 302
103417: NOT
103418: OR
103419: PUSH
103420: LD_VAR 0 1
103424: PPUSH
103425: CALL_OW 301
103429: OR
103430: IFFALSE 103380
// RemoveSeeing ( _x , _y , side ) ;
103432: LD_VAR 0 8
103436: PPUSH
103437: LD_VAR 0 9
103441: PPUSH
103442: LD_VAR 0 6
103446: PPUSH
103447: CALL_OW 331
// end ; end_of_file
103451: LD_VAR 0 4
103455: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
103456: LD_INT 0
103458: PPUSH
103459: PPUSH
103460: PPUSH
103461: PPUSH
103462: PPUSH
103463: PPUSH
103464: PPUSH
103465: PPUSH
103466: PPUSH
103467: PPUSH
103468: PPUSH
103469: PPUSH
103470: PPUSH
103471: PPUSH
103472: PPUSH
103473: PPUSH
103474: PPUSH
103475: PPUSH
103476: PPUSH
103477: PPUSH
103478: PPUSH
103479: PPUSH
103480: PPUSH
103481: PPUSH
103482: PPUSH
103483: PPUSH
103484: PPUSH
103485: PPUSH
103486: PPUSH
103487: PPUSH
103488: PPUSH
103489: PPUSH
103490: PPUSH
103491: PPUSH
// if not list then
103492: LD_VAR 0 1
103496: NOT
103497: IFFALSE 103501
// exit ;
103499: GO 108160
// base := list [ 1 ] ;
103501: LD_ADDR_VAR 0 3
103505: PUSH
103506: LD_VAR 0 1
103510: PUSH
103511: LD_INT 1
103513: ARRAY
103514: ST_TO_ADDR
// group := list [ 2 ] ;
103515: LD_ADDR_VAR 0 4
103519: PUSH
103520: LD_VAR 0 1
103524: PUSH
103525: LD_INT 2
103527: ARRAY
103528: ST_TO_ADDR
// path := list [ 3 ] ;
103529: LD_ADDR_VAR 0 5
103533: PUSH
103534: LD_VAR 0 1
103538: PUSH
103539: LD_INT 3
103541: ARRAY
103542: ST_TO_ADDR
// flags := list [ 4 ] ;
103543: LD_ADDR_VAR 0 6
103547: PUSH
103548: LD_VAR 0 1
103552: PUSH
103553: LD_INT 4
103555: ARRAY
103556: ST_TO_ADDR
// mined := [ ] ;
103557: LD_ADDR_VAR 0 27
103561: PUSH
103562: EMPTY
103563: ST_TO_ADDR
// bombed := [ ] ;
103564: LD_ADDR_VAR 0 28
103568: PUSH
103569: EMPTY
103570: ST_TO_ADDR
// healers := [ ] ;
103571: LD_ADDR_VAR 0 31
103575: PUSH
103576: EMPTY
103577: ST_TO_ADDR
// to_heal := [ ] ;
103578: LD_ADDR_VAR 0 30
103582: PUSH
103583: EMPTY
103584: ST_TO_ADDR
// repairs := [ ] ;
103585: LD_ADDR_VAR 0 33
103589: PUSH
103590: EMPTY
103591: ST_TO_ADDR
// to_repair := [ ] ;
103592: LD_ADDR_VAR 0 32
103596: PUSH
103597: EMPTY
103598: ST_TO_ADDR
// if not group or not path then
103599: LD_VAR 0 4
103603: NOT
103604: PUSH
103605: LD_VAR 0 5
103609: NOT
103610: OR
103611: IFFALSE 103615
// exit ;
103613: GO 108160
// side := GetSide ( group [ 1 ] ) ;
103615: LD_ADDR_VAR 0 35
103619: PUSH
103620: LD_VAR 0 4
103624: PUSH
103625: LD_INT 1
103627: ARRAY
103628: PPUSH
103629: CALL_OW 255
103633: ST_TO_ADDR
// if flags then
103634: LD_VAR 0 6
103638: IFFALSE 103782
// begin f_ignore_area := flags [ 1 ] ;
103640: LD_ADDR_VAR 0 17
103644: PUSH
103645: LD_VAR 0 6
103649: PUSH
103650: LD_INT 1
103652: ARRAY
103653: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
103654: LD_ADDR_VAR 0 18
103658: PUSH
103659: LD_VAR 0 6
103663: PUSH
103664: LD_INT 2
103666: ARRAY
103667: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
103668: LD_ADDR_VAR 0 19
103672: PUSH
103673: LD_VAR 0 6
103677: PUSH
103678: LD_INT 3
103680: ARRAY
103681: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
103682: LD_ADDR_VAR 0 20
103686: PUSH
103687: LD_VAR 0 6
103691: PUSH
103692: LD_INT 4
103694: ARRAY
103695: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
103696: LD_ADDR_VAR 0 21
103700: PUSH
103701: LD_VAR 0 6
103705: PUSH
103706: LD_INT 5
103708: ARRAY
103709: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
103710: LD_ADDR_VAR 0 22
103714: PUSH
103715: LD_VAR 0 6
103719: PUSH
103720: LD_INT 6
103722: ARRAY
103723: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
103724: LD_ADDR_VAR 0 23
103728: PUSH
103729: LD_VAR 0 6
103733: PUSH
103734: LD_INT 7
103736: ARRAY
103737: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
103738: LD_ADDR_VAR 0 24
103742: PUSH
103743: LD_VAR 0 6
103747: PUSH
103748: LD_INT 8
103750: ARRAY
103751: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
103752: LD_ADDR_VAR 0 25
103756: PUSH
103757: LD_VAR 0 6
103761: PUSH
103762: LD_INT 9
103764: ARRAY
103765: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
103766: LD_ADDR_VAR 0 26
103770: PUSH
103771: LD_VAR 0 6
103775: PUSH
103776: LD_INT 10
103778: ARRAY
103779: ST_TO_ADDR
// end else
103780: GO 103862
// begin f_ignore_area := false ;
103782: LD_ADDR_VAR 0 17
103786: PUSH
103787: LD_INT 0
103789: ST_TO_ADDR
// f_capture := false ;
103790: LD_ADDR_VAR 0 18
103794: PUSH
103795: LD_INT 0
103797: ST_TO_ADDR
// f_ignore_civ := false ;
103798: LD_ADDR_VAR 0 19
103802: PUSH
103803: LD_INT 0
103805: ST_TO_ADDR
// f_murder := false ;
103806: LD_ADDR_VAR 0 20
103810: PUSH
103811: LD_INT 0
103813: ST_TO_ADDR
// f_mines := false ;
103814: LD_ADDR_VAR 0 21
103818: PUSH
103819: LD_INT 0
103821: ST_TO_ADDR
// f_repair := false ;
103822: LD_ADDR_VAR 0 22
103826: PUSH
103827: LD_INT 0
103829: ST_TO_ADDR
// f_heal := false ;
103830: LD_ADDR_VAR 0 23
103834: PUSH
103835: LD_INT 0
103837: ST_TO_ADDR
// f_spacetime := false ;
103838: LD_ADDR_VAR 0 24
103842: PUSH
103843: LD_INT 0
103845: ST_TO_ADDR
// f_attack_depot := false ;
103846: LD_ADDR_VAR 0 25
103850: PUSH
103851: LD_INT 0
103853: ST_TO_ADDR
// f_crawl := false ;
103854: LD_ADDR_VAR 0 26
103858: PUSH
103859: LD_INT 0
103861: ST_TO_ADDR
// end ; if f_heal then
103862: LD_VAR 0 23
103866: IFFALSE 103893
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
103868: LD_ADDR_VAR 0 31
103872: PUSH
103873: LD_VAR 0 4
103877: PPUSH
103878: LD_INT 25
103880: PUSH
103881: LD_INT 4
103883: PUSH
103884: EMPTY
103885: LIST
103886: LIST
103887: PPUSH
103888: CALL_OW 72
103892: ST_TO_ADDR
// if f_repair then
103893: LD_VAR 0 22
103897: IFFALSE 103924
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
103899: LD_ADDR_VAR 0 33
103903: PUSH
103904: LD_VAR 0 4
103908: PPUSH
103909: LD_INT 25
103911: PUSH
103912: LD_INT 3
103914: PUSH
103915: EMPTY
103916: LIST
103917: LIST
103918: PPUSH
103919: CALL_OW 72
103923: ST_TO_ADDR
// units_path := [ ] ;
103924: LD_ADDR_VAR 0 16
103928: PUSH
103929: EMPTY
103930: ST_TO_ADDR
// for i = 1 to group do
103931: LD_ADDR_VAR 0 7
103935: PUSH
103936: DOUBLE
103937: LD_INT 1
103939: DEC
103940: ST_TO_ADDR
103941: LD_VAR 0 4
103945: PUSH
103946: FOR_TO
103947: IFFALSE 103976
// units_path := Replace ( units_path , i , path ) ;
103949: LD_ADDR_VAR 0 16
103953: PUSH
103954: LD_VAR 0 16
103958: PPUSH
103959: LD_VAR 0 7
103963: PPUSH
103964: LD_VAR 0 5
103968: PPUSH
103969: CALL_OW 1
103973: ST_TO_ADDR
103974: GO 103946
103976: POP
103977: POP
// repeat for i = group downto 1 do
103978: LD_ADDR_VAR 0 7
103982: PUSH
103983: DOUBLE
103984: LD_VAR 0 4
103988: INC
103989: ST_TO_ADDR
103990: LD_INT 1
103992: PUSH
103993: FOR_DOWNTO
103994: IFFALSE 108116
// begin wait ( 5 ) ;
103996: LD_INT 5
103998: PPUSH
103999: CALL_OW 67
// tmp := [ ] ;
104003: LD_ADDR_VAR 0 14
104007: PUSH
104008: EMPTY
104009: ST_TO_ADDR
// attacking := false ;
104010: LD_ADDR_VAR 0 29
104014: PUSH
104015: LD_INT 0
104017: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
104018: LD_VAR 0 4
104022: PUSH
104023: LD_VAR 0 7
104027: ARRAY
104028: PPUSH
104029: CALL_OW 301
104033: PUSH
104034: LD_VAR 0 4
104038: PUSH
104039: LD_VAR 0 7
104043: ARRAY
104044: NOT
104045: OR
104046: IFFALSE 104155
// begin if GetType ( group [ i ] ) = unit_human then
104048: LD_VAR 0 4
104052: PUSH
104053: LD_VAR 0 7
104057: ARRAY
104058: PPUSH
104059: CALL_OW 247
104063: PUSH
104064: LD_INT 1
104066: EQUAL
104067: IFFALSE 104113
// begin to_heal := to_heal diff group [ i ] ;
104069: LD_ADDR_VAR 0 30
104073: PUSH
104074: LD_VAR 0 30
104078: PUSH
104079: LD_VAR 0 4
104083: PUSH
104084: LD_VAR 0 7
104088: ARRAY
104089: DIFF
104090: ST_TO_ADDR
// healers := healers diff group [ i ] ;
104091: LD_ADDR_VAR 0 31
104095: PUSH
104096: LD_VAR 0 31
104100: PUSH
104101: LD_VAR 0 4
104105: PUSH
104106: LD_VAR 0 7
104110: ARRAY
104111: DIFF
104112: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
104113: LD_ADDR_VAR 0 4
104117: PUSH
104118: LD_VAR 0 4
104122: PPUSH
104123: LD_VAR 0 7
104127: PPUSH
104128: CALL_OW 3
104132: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
104133: LD_ADDR_VAR 0 16
104137: PUSH
104138: LD_VAR 0 16
104142: PPUSH
104143: LD_VAR 0 7
104147: PPUSH
104148: CALL_OW 3
104152: ST_TO_ADDR
// continue ;
104153: GO 103993
// end ; if f_repair then
104155: LD_VAR 0 22
104159: IFFALSE 104648
// begin if GetType ( group [ i ] ) = unit_vehicle then
104161: LD_VAR 0 4
104165: PUSH
104166: LD_VAR 0 7
104170: ARRAY
104171: PPUSH
104172: CALL_OW 247
104176: PUSH
104177: LD_INT 2
104179: EQUAL
104180: IFFALSE 104370
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
104182: LD_VAR 0 4
104186: PUSH
104187: LD_VAR 0 7
104191: ARRAY
104192: PPUSH
104193: CALL_OW 256
104197: PUSH
104198: LD_INT 700
104200: LESS
104201: PUSH
104202: LD_VAR 0 4
104206: PUSH
104207: LD_VAR 0 7
104211: ARRAY
104212: PUSH
104213: LD_VAR 0 32
104217: IN
104218: NOT
104219: AND
104220: IFFALSE 104244
// to_repair := to_repair union group [ i ] ;
104222: LD_ADDR_VAR 0 32
104226: PUSH
104227: LD_VAR 0 32
104231: PUSH
104232: LD_VAR 0 4
104236: PUSH
104237: LD_VAR 0 7
104241: ARRAY
104242: UNION
104243: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
104244: LD_VAR 0 4
104248: PUSH
104249: LD_VAR 0 7
104253: ARRAY
104254: PPUSH
104255: CALL_OW 256
104259: PUSH
104260: LD_INT 1000
104262: EQUAL
104263: PUSH
104264: LD_VAR 0 4
104268: PUSH
104269: LD_VAR 0 7
104273: ARRAY
104274: PUSH
104275: LD_VAR 0 32
104279: IN
104280: AND
104281: IFFALSE 104305
// to_repair := to_repair diff group [ i ] ;
104283: LD_ADDR_VAR 0 32
104287: PUSH
104288: LD_VAR 0 32
104292: PUSH
104293: LD_VAR 0 4
104297: PUSH
104298: LD_VAR 0 7
104302: ARRAY
104303: DIFF
104304: ST_TO_ADDR
// if group [ i ] in to_repair then
104305: LD_VAR 0 4
104309: PUSH
104310: LD_VAR 0 7
104314: ARRAY
104315: PUSH
104316: LD_VAR 0 32
104320: IN
104321: IFFALSE 104368
// begin if not IsInArea ( group [ i ] , f_repair ) then
104323: LD_VAR 0 4
104327: PUSH
104328: LD_VAR 0 7
104332: ARRAY
104333: PPUSH
104334: LD_VAR 0 22
104338: PPUSH
104339: CALL_OW 308
104343: NOT
104344: IFFALSE 104366
// ComMoveToArea ( group [ i ] , f_repair ) ;
104346: LD_VAR 0 4
104350: PUSH
104351: LD_VAR 0 7
104355: ARRAY
104356: PPUSH
104357: LD_VAR 0 22
104361: PPUSH
104362: CALL_OW 113
// continue ;
104366: GO 103993
// end ; end else
104368: GO 104648
// if group [ i ] in repairs then
104370: LD_VAR 0 4
104374: PUSH
104375: LD_VAR 0 7
104379: ARRAY
104380: PUSH
104381: LD_VAR 0 33
104385: IN
104386: IFFALSE 104648
// begin if IsInUnit ( group [ i ] ) then
104388: LD_VAR 0 4
104392: PUSH
104393: LD_VAR 0 7
104397: ARRAY
104398: PPUSH
104399: CALL_OW 310
104403: IFFALSE 104471
// begin z := IsInUnit ( group [ i ] ) ;
104405: LD_ADDR_VAR 0 13
104409: PUSH
104410: LD_VAR 0 4
104414: PUSH
104415: LD_VAR 0 7
104419: ARRAY
104420: PPUSH
104421: CALL_OW 310
104425: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
104426: LD_VAR 0 13
104430: PUSH
104431: LD_VAR 0 32
104435: IN
104436: PUSH
104437: LD_VAR 0 13
104441: PPUSH
104442: LD_VAR 0 22
104446: PPUSH
104447: CALL_OW 308
104451: AND
104452: IFFALSE 104469
// ComExitVehicle ( group [ i ] ) ;
104454: LD_VAR 0 4
104458: PUSH
104459: LD_VAR 0 7
104463: ARRAY
104464: PPUSH
104465: CALL_OW 121
// end else
104469: GO 104648
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
104471: LD_ADDR_VAR 0 13
104475: PUSH
104476: LD_VAR 0 4
104480: PPUSH
104481: LD_INT 95
104483: PUSH
104484: LD_VAR 0 22
104488: PUSH
104489: EMPTY
104490: LIST
104491: LIST
104492: PUSH
104493: LD_INT 58
104495: PUSH
104496: EMPTY
104497: LIST
104498: PUSH
104499: EMPTY
104500: LIST
104501: LIST
104502: PPUSH
104503: CALL_OW 72
104507: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
104508: LD_VAR 0 4
104512: PUSH
104513: LD_VAR 0 7
104517: ARRAY
104518: PPUSH
104519: CALL_OW 314
104523: NOT
104524: IFFALSE 104646
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
104526: LD_ADDR_VAR 0 10
104530: PUSH
104531: LD_VAR 0 13
104535: PPUSH
104536: LD_VAR 0 4
104540: PUSH
104541: LD_VAR 0 7
104545: ARRAY
104546: PPUSH
104547: CALL_OW 74
104551: ST_TO_ADDR
// if not x then
104552: LD_VAR 0 10
104556: NOT
104557: IFFALSE 104561
// continue ;
104559: GO 103993
// if GetLives ( x ) < 1000 then
104561: LD_VAR 0 10
104565: PPUSH
104566: CALL_OW 256
104570: PUSH
104571: LD_INT 1000
104573: LESS
104574: IFFALSE 104598
// ComRepairVehicle ( group [ i ] , x ) else
104576: LD_VAR 0 4
104580: PUSH
104581: LD_VAR 0 7
104585: ARRAY
104586: PPUSH
104587: LD_VAR 0 10
104591: PPUSH
104592: CALL_OW 129
104596: GO 104646
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
104598: LD_VAR 0 23
104602: PUSH
104603: LD_VAR 0 4
104607: PUSH
104608: LD_VAR 0 7
104612: ARRAY
104613: PPUSH
104614: CALL_OW 256
104618: PUSH
104619: LD_INT 1000
104621: LESS
104622: AND
104623: NOT
104624: IFFALSE 104646
// ComEnterUnit ( group [ i ] , x ) ;
104626: LD_VAR 0 4
104630: PUSH
104631: LD_VAR 0 7
104635: ARRAY
104636: PPUSH
104637: LD_VAR 0 10
104641: PPUSH
104642: CALL_OW 120
// end ; continue ;
104646: GO 103993
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
104648: LD_VAR 0 23
104652: PUSH
104653: LD_VAR 0 4
104657: PUSH
104658: LD_VAR 0 7
104662: ARRAY
104663: PPUSH
104664: CALL_OW 247
104668: PUSH
104669: LD_INT 1
104671: EQUAL
104672: AND
104673: IFFALSE 105151
// begin if group [ i ] in healers then
104675: LD_VAR 0 4
104679: PUSH
104680: LD_VAR 0 7
104684: ARRAY
104685: PUSH
104686: LD_VAR 0 31
104690: IN
104691: IFFALSE 104964
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
104693: LD_VAR 0 4
104697: PUSH
104698: LD_VAR 0 7
104702: ARRAY
104703: PPUSH
104704: LD_VAR 0 23
104708: PPUSH
104709: CALL_OW 308
104713: NOT
104714: PUSH
104715: LD_VAR 0 4
104719: PUSH
104720: LD_VAR 0 7
104724: ARRAY
104725: PPUSH
104726: CALL_OW 314
104730: NOT
104731: AND
104732: IFFALSE 104756
// ComMoveToArea ( group [ i ] , f_heal ) else
104734: LD_VAR 0 4
104738: PUSH
104739: LD_VAR 0 7
104743: ARRAY
104744: PPUSH
104745: LD_VAR 0 23
104749: PPUSH
104750: CALL_OW 113
104754: GO 104962
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
104756: LD_VAR 0 4
104760: PUSH
104761: LD_VAR 0 7
104765: ARRAY
104766: PPUSH
104767: CALL 47668 0 1
104771: PPUSH
104772: CALL_OW 256
104776: PUSH
104777: LD_INT 1000
104779: EQUAL
104780: IFFALSE 104799
// ComStop ( group [ i ] ) else
104782: LD_VAR 0 4
104786: PUSH
104787: LD_VAR 0 7
104791: ARRAY
104792: PPUSH
104793: CALL_OW 141
104797: GO 104962
// if not HasTask ( group [ i ] ) and to_heal then
104799: LD_VAR 0 4
104803: PUSH
104804: LD_VAR 0 7
104808: ARRAY
104809: PPUSH
104810: CALL_OW 314
104814: NOT
104815: PUSH
104816: LD_VAR 0 30
104820: AND
104821: IFFALSE 104962
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
104823: LD_ADDR_VAR 0 13
104827: PUSH
104828: LD_VAR 0 30
104832: PPUSH
104833: LD_INT 3
104835: PUSH
104836: LD_INT 54
104838: PUSH
104839: EMPTY
104840: LIST
104841: PUSH
104842: EMPTY
104843: LIST
104844: LIST
104845: PPUSH
104846: CALL_OW 72
104850: PPUSH
104851: LD_VAR 0 4
104855: PUSH
104856: LD_VAR 0 7
104860: ARRAY
104861: PPUSH
104862: CALL_OW 74
104866: ST_TO_ADDR
// if z then
104867: LD_VAR 0 13
104871: IFFALSE 104962
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
104873: LD_INT 91
104875: PUSH
104876: LD_VAR 0 13
104880: PUSH
104881: LD_INT 10
104883: PUSH
104884: EMPTY
104885: LIST
104886: LIST
104887: LIST
104888: PUSH
104889: LD_INT 81
104891: PUSH
104892: LD_VAR 0 13
104896: PPUSH
104897: CALL_OW 255
104901: PUSH
104902: EMPTY
104903: LIST
104904: LIST
104905: PUSH
104906: EMPTY
104907: LIST
104908: LIST
104909: PPUSH
104910: CALL_OW 69
104914: PUSH
104915: LD_INT 0
104917: EQUAL
104918: IFFALSE 104942
// ComHeal ( group [ i ] , z ) else
104920: LD_VAR 0 4
104924: PUSH
104925: LD_VAR 0 7
104929: ARRAY
104930: PPUSH
104931: LD_VAR 0 13
104935: PPUSH
104936: CALL_OW 128
104940: GO 104962
// ComMoveToArea ( group [ i ] , f_heal ) ;
104942: LD_VAR 0 4
104946: PUSH
104947: LD_VAR 0 7
104951: ARRAY
104952: PPUSH
104953: LD_VAR 0 23
104957: PPUSH
104958: CALL_OW 113
// end ; continue ;
104962: GO 103993
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
104964: LD_VAR 0 4
104968: PUSH
104969: LD_VAR 0 7
104973: ARRAY
104974: PPUSH
104975: CALL_OW 256
104979: PUSH
104980: LD_INT 700
104982: LESS
104983: PUSH
104984: LD_VAR 0 4
104988: PUSH
104989: LD_VAR 0 7
104993: ARRAY
104994: PUSH
104995: LD_VAR 0 30
104999: IN
105000: NOT
105001: AND
105002: IFFALSE 105026
// to_heal := to_heal union group [ i ] ;
105004: LD_ADDR_VAR 0 30
105008: PUSH
105009: LD_VAR 0 30
105013: PUSH
105014: LD_VAR 0 4
105018: PUSH
105019: LD_VAR 0 7
105023: ARRAY
105024: UNION
105025: ST_TO_ADDR
// if group [ i ] in to_heal then
105026: LD_VAR 0 4
105030: PUSH
105031: LD_VAR 0 7
105035: ARRAY
105036: PUSH
105037: LD_VAR 0 30
105041: IN
105042: IFFALSE 105151
// begin if GetLives ( group [ i ] ) = 1000 then
105044: LD_VAR 0 4
105048: PUSH
105049: LD_VAR 0 7
105053: ARRAY
105054: PPUSH
105055: CALL_OW 256
105059: PUSH
105060: LD_INT 1000
105062: EQUAL
105063: IFFALSE 105089
// to_heal := to_heal diff group [ i ] else
105065: LD_ADDR_VAR 0 30
105069: PUSH
105070: LD_VAR 0 30
105074: PUSH
105075: LD_VAR 0 4
105079: PUSH
105080: LD_VAR 0 7
105084: ARRAY
105085: DIFF
105086: ST_TO_ADDR
105087: GO 105151
// begin if not IsInArea ( group [ i ] , to_heal ) then
105089: LD_VAR 0 4
105093: PUSH
105094: LD_VAR 0 7
105098: ARRAY
105099: PPUSH
105100: LD_VAR 0 30
105104: PPUSH
105105: CALL_OW 308
105109: NOT
105110: IFFALSE 105134
// ComMoveToArea ( group [ i ] , f_heal ) else
105112: LD_VAR 0 4
105116: PUSH
105117: LD_VAR 0 7
105121: ARRAY
105122: PPUSH
105123: LD_VAR 0 23
105127: PPUSH
105128: CALL_OW 113
105132: GO 105149
// ComHold ( group [ i ] ) ;
105134: LD_VAR 0 4
105138: PUSH
105139: LD_VAR 0 7
105143: ARRAY
105144: PPUSH
105145: CALL_OW 140
// continue ;
105149: GO 103993
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
105151: LD_VAR 0 4
105155: PUSH
105156: LD_VAR 0 7
105160: ARRAY
105161: PPUSH
105162: LD_INT 10
105164: PPUSH
105165: CALL 46088 0 2
105169: NOT
105170: PUSH
105171: LD_VAR 0 16
105175: PUSH
105176: LD_VAR 0 7
105180: ARRAY
105181: PUSH
105182: EMPTY
105183: EQUAL
105184: NOT
105185: AND
105186: IFFALSE 105452
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
105188: LD_VAR 0 4
105192: PUSH
105193: LD_VAR 0 7
105197: ARRAY
105198: PPUSH
105199: CALL_OW 262
105203: PUSH
105204: LD_INT 1
105206: PUSH
105207: LD_INT 2
105209: PUSH
105210: EMPTY
105211: LIST
105212: LIST
105213: IN
105214: IFFALSE 105255
// if GetFuel ( group [ i ] ) < 10 then
105216: LD_VAR 0 4
105220: PUSH
105221: LD_VAR 0 7
105225: ARRAY
105226: PPUSH
105227: CALL_OW 261
105231: PUSH
105232: LD_INT 10
105234: LESS
105235: IFFALSE 105255
// SetFuel ( group [ i ] , 12 ) ;
105237: LD_VAR 0 4
105241: PUSH
105242: LD_VAR 0 7
105246: ARRAY
105247: PPUSH
105248: LD_INT 12
105250: PPUSH
105251: CALL_OW 240
// if units_path [ i ] then
105255: LD_VAR 0 16
105259: PUSH
105260: LD_VAR 0 7
105264: ARRAY
105265: IFFALSE 105450
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
105267: LD_VAR 0 4
105271: PUSH
105272: LD_VAR 0 7
105276: ARRAY
105277: PPUSH
105278: LD_VAR 0 16
105282: PUSH
105283: LD_VAR 0 7
105287: ARRAY
105288: PUSH
105289: LD_INT 1
105291: ARRAY
105292: PUSH
105293: LD_INT 1
105295: ARRAY
105296: PPUSH
105297: LD_VAR 0 16
105301: PUSH
105302: LD_VAR 0 7
105306: ARRAY
105307: PUSH
105308: LD_INT 1
105310: ARRAY
105311: PUSH
105312: LD_INT 2
105314: ARRAY
105315: PPUSH
105316: CALL_OW 297
105320: PUSH
105321: LD_INT 6
105323: GREATER
105324: IFFALSE 105399
// begin if not HasTask ( group [ i ] ) then
105326: LD_VAR 0 4
105330: PUSH
105331: LD_VAR 0 7
105335: ARRAY
105336: PPUSH
105337: CALL_OW 314
105341: NOT
105342: IFFALSE 105397
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
105344: LD_VAR 0 4
105348: PUSH
105349: LD_VAR 0 7
105353: ARRAY
105354: PPUSH
105355: LD_VAR 0 16
105359: PUSH
105360: LD_VAR 0 7
105364: ARRAY
105365: PUSH
105366: LD_INT 1
105368: ARRAY
105369: PUSH
105370: LD_INT 1
105372: ARRAY
105373: PPUSH
105374: LD_VAR 0 16
105378: PUSH
105379: LD_VAR 0 7
105383: ARRAY
105384: PUSH
105385: LD_INT 1
105387: ARRAY
105388: PUSH
105389: LD_INT 2
105391: ARRAY
105392: PPUSH
105393: CALL_OW 114
// end else
105397: GO 105450
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
105399: LD_ADDR_VAR 0 15
105403: PUSH
105404: LD_VAR 0 16
105408: PUSH
105409: LD_VAR 0 7
105413: ARRAY
105414: PPUSH
105415: LD_INT 1
105417: PPUSH
105418: CALL_OW 3
105422: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
105423: LD_ADDR_VAR 0 16
105427: PUSH
105428: LD_VAR 0 16
105432: PPUSH
105433: LD_VAR 0 7
105437: PPUSH
105438: LD_VAR 0 15
105442: PPUSH
105443: CALL_OW 1
105447: ST_TO_ADDR
// continue ;
105448: GO 103993
// end ; end ; end else
105450: GO 108114
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
105452: LD_ADDR_VAR 0 14
105456: PUSH
105457: LD_INT 81
105459: PUSH
105460: LD_VAR 0 4
105464: PUSH
105465: LD_VAR 0 7
105469: ARRAY
105470: PPUSH
105471: CALL_OW 255
105475: PUSH
105476: EMPTY
105477: LIST
105478: LIST
105479: PPUSH
105480: CALL_OW 69
105484: ST_TO_ADDR
// if not tmp then
105485: LD_VAR 0 14
105489: NOT
105490: IFFALSE 105494
// continue ;
105492: GO 103993
// if f_ignore_area then
105494: LD_VAR 0 17
105498: IFFALSE 105586
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
105500: LD_ADDR_VAR 0 15
105504: PUSH
105505: LD_VAR 0 14
105509: PPUSH
105510: LD_INT 3
105512: PUSH
105513: LD_INT 92
105515: PUSH
105516: LD_VAR 0 17
105520: PUSH
105521: LD_INT 1
105523: ARRAY
105524: PUSH
105525: LD_VAR 0 17
105529: PUSH
105530: LD_INT 2
105532: ARRAY
105533: PUSH
105534: LD_VAR 0 17
105538: PUSH
105539: LD_INT 3
105541: ARRAY
105542: PUSH
105543: EMPTY
105544: LIST
105545: LIST
105546: LIST
105547: LIST
105548: PUSH
105549: EMPTY
105550: LIST
105551: LIST
105552: PPUSH
105553: CALL_OW 72
105557: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
105558: LD_VAR 0 14
105562: PUSH
105563: LD_VAR 0 15
105567: DIFF
105568: IFFALSE 105586
// tmp := tmp diff tmp2 ;
105570: LD_ADDR_VAR 0 14
105574: PUSH
105575: LD_VAR 0 14
105579: PUSH
105580: LD_VAR 0 15
105584: DIFF
105585: ST_TO_ADDR
// end ; if not f_murder then
105586: LD_VAR 0 20
105590: NOT
105591: IFFALSE 105649
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
105593: LD_ADDR_VAR 0 15
105597: PUSH
105598: LD_VAR 0 14
105602: PPUSH
105603: LD_INT 3
105605: PUSH
105606: LD_INT 50
105608: PUSH
105609: EMPTY
105610: LIST
105611: PUSH
105612: EMPTY
105613: LIST
105614: LIST
105615: PPUSH
105616: CALL_OW 72
105620: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
105621: LD_VAR 0 14
105625: PUSH
105626: LD_VAR 0 15
105630: DIFF
105631: IFFALSE 105649
// tmp := tmp diff tmp2 ;
105633: LD_ADDR_VAR 0 14
105637: PUSH
105638: LD_VAR 0 14
105642: PUSH
105643: LD_VAR 0 15
105647: DIFF
105648: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
105649: LD_ADDR_VAR 0 14
105653: PUSH
105654: LD_VAR 0 4
105658: PUSH
105659: LD_VAR 0 7
105663: ARRAY
105664: PPUSH
105665: LD_VAR 0 14
105669: PPUSH
105670: LD_INT 1
105672: PPUSH
105673: LD_INT 1
105675: PPUSH
105676: CALL 19023 0 4
105680: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
105681: LD_VAR 0 4
105685: PUSH
105686: LD_VAR 0 7
105690: ARRAY
105691: PPUSH
105692: CALL_OW 257
105696: PUSH
105697: LD_INT 1
105699: EQUAL
105700: IFFALSE 106148
// begin if WantPlant ( group [ i ] ) then
105702: LD_VAR 0 4
105706: PUSH
105707: LD_VAR 0 7
105711: ARRAY
105712: PPUSH
105713: CALL 18524 0 1
105717: IFFALSE 105721
// continue ;
105719: GO 103993
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
105721: LD_VAR 0 18
105725: PUSH
105726: LD_VAR 0 4
105730: PUSH
105731: LD_VAR 0 7
105735: ARRAY
105736: PPUSH
105737: CALL_OW 310
105741: NOT
105742: AND
105743: PUSH
105744: LD_VAR 0 14
105748: PUSH
105749: LD_INT 1
105751: ARRAY
105752: PUSH
105753: LD_VAR 0 14
105757: PPUSH
105758: LD_INT 21
105760: PUSH
105761: LD_INT 2
105763: PUSH
105764: EMPTY
105765: LIST
105766: LIST
105767: PUSH
105768: LD_INT 58
105770: PUSH
105771: EMPTY
105772: LIST
105773: PUSH
105774: EMPTY
105775: LIST
105776: LIST
105777: PPUSH
105778: CALL_OW 72
105782: IN
105783: AND
105784: IFFALSE 105820
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
105786: LD_VAR 0 4
105790: PUSH
105791: LD_VAR 0 7
105795: ARRAY
105796: PPUSH
105797: LD_VAR 0 14
105801: PUSH
105802: LD_INT 1
105804: ARRAY
105805: PPUSH
105806: CALL_OW 120
// attacking := true ;
105810: LD_ADDR_VAR 0 29
105814: PUSH
105815: LD_INT 1
105817: ST_TO_ADDR
// continue ;
105818: GO 103993
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
105820: LD_VAR 0 26
105824: PUSH
105825: LD_VAR 0 4
105829: PUSH
105830: LD_VAR 0 7
105834: ARRAY
105835: PPUSH
105836: CALL_OW 257
105840: PUSH
105841: LD_INT 1
105843: EQUAL
105844: AND
105845: PUSH
105846: LD_VAR 0 4
105850: PUSH
105851: LD_VAR 0 7
105855: ARRAY
105856: PPUSH
105857: CALL_OW 256
105861: PUSH
105862: LD_INT 800
105864: LESS
105865: AND
105866: PUSH
105867: LD_VAR 0 4
105871: PUSH
105872: LD_VAR 0 7
105876: ARRAY
105877: PPUSH
105878: CALL_OW 318
105882: NOT
105883: AND
105884: IFFALSE 105901
// ComCrawl ( group [ i ] ) ;
105886: LD_VAR 0 4
105890: PUSH
105891: LD_VAR 0 7
105895: ARRAY
105896: PPUSH
105897: CALL_OW 137
// if f_mines then
105901: LD_VAR 0 21
105905: IFFALSE 106148
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
105907: LD_VAR 0 14
105911: PUSH
105912: LD_INT 1
105914: ARRAY
105915: PPUSH
105916: CALL_OW 247
105920: PUSH
105921: LD_INT 3
105923: EQUAL
105924: PUSH
105925: LD_VAR 0 14
105929: PUSH
105930: LD_INT 1
105932: ARRAY
105933: PUSH
105934: LD_VAR 0 27
105938: IN
105939: NOT
105940: AND
105941: IFFALSE 106148
// begin x := GetX ( tmp [ 1 ] ) ;
105943: LD_ADDR_VAR 0 10
105947: PUSH
105948: LD_VAR 0 14
105952: PUSH
105953: LD_INT 1
105955: ARRAY
105956: PPUSH
105957: CALL_OW 250
105961: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
105962: LD_ADDR_VAR 0 11
105966: PUSH
105967: LD_VAR 0 14
105971: PUSH
105972: LD_INT 1
105974: ARRAY
105975: PPUSH
105976: CALL_OW 251
105980: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
105981: LD_ADDR_VAR 0 12
105985: PUSH
105986: LD_VAR 0 4
105990: PUSH
105991: LD_VAR 0 7
105995: ARRAY
105996: PPUSH
105997: CALL 46173 0 1
106001: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
106002: LD_VAR 0 4
106006: PUSH
106007: LD_VAR 0 7
106011: ARRAY
106012: PPUSH
106013: LD_VAR 0 10
106017: PPUSH
106018: LD_VAR 0 11
106022: PPUSH
106023: LD_VAR 0 14
106027: PUSH
106028: LD_INT 1
106030: ARRAY
106031: PPUSH
106032: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
106036: LD_VAR 0 4
106040: PUSH
106041: LD_VAR 0 7
106045: ARRAY
106046: PPUSH
106047: LD_VAR 0 10
106051: PPUSH
106052: LD_VAR 0 12
106056: PPUSH
106057: LD_INT 7
106059: PPUSH
106060: CALL_OW 272
106064: PPUSH
106065: LD_VAR 0 11
106069: PPUSH
106070: LD_VAR 0 12
106074: PPUSH
106075: LD_INT 7
106077: PPUSH
106078: CALL_OW 273
106082: PPUSH
106083: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
106087: LD_VAR 0 4
106091: PUSH
106092: LD_VAR 0 7
106096: ARRAY
106097: PPUSH
106098: LD_INT 71
106100: PPUSH
106101: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
106105: LD_ADDR_VAR 0 27
106109: PUSH
106110: LD_VAR 0 27
106114: PPUSH
106115: LD_VAR 0 27
106119: PUSH
106120: LD_INT 1
106122: PLUS
106123: PPUSH
106124: LD_VAR 0 14
106128: PUSH
106129: LD_INT 1
106131: ARRAY
106132: PPUSH
106133: CALL_OW 1
106137: ST_TO_ADDR
// attacking := true ;
106138: LD_ADDR_VAR 0 29
106142: PUSH
106143: LD_INT 1
106145: ST_TO_ADDR
// continue ;
106146: GO 103993
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
106148: LD_VAR 0 4
106152: PUSH
106153: LD_VAR 0 7
106157: ARRAY
106158: PPUSH
106159: CALL_OW 257
106163: PUSH
106164: LD_INT 17
106166: EQUAL
106167: PUSH
106168: LD_VAR 0 4
106172: PUSH
106173: LD_VAR 0 7
106177: ARRAY
106178: PPUSH
106179: CALL_OW 110
106183: PUSH
106184: LD_INT 71
106186: EQUAL
106187: NOT
106188: AND
106189: IFFALSE 106335
// begin attacking := false ;
106191: LD_ADDR_VAR 0 29
106195: PUSH
106196: LD_INT 0
106198: ST_TO_ADDR
// k := 5 ;
106199: LD_ADDR_VAR 0 9
106203: PUSH
106204: LD_INT 5
106206: ST_TO_ADDR
// if tmp < k then
106207: LD_VAR 0 14
106211: PUSH
106212: LD_VAR 0 9
106216: LESS
106217: IFFALSE 106229
// k := tmp ;
106219: LD_ADDR_VAR 0 9
106223: PUSH
106224: LD_VAR 0 14
106228: ST_TO_ADDR
// for j = 1 to k do
106229: LD_ADDR_VAR 0 8
106233: PUSH
106234: DOUBLE
106235: LD_INT 1
106237: DEC
106238: ST_TO_ADDR
106239: LD_VAR 0 9
106243: PUSH
106244: FOR_TO
106245: IFFALSE 106333
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
106247: LD_VAR 0 14
106251: PUSH
106252: LD_VAR 0 8
106256: ARRAY
106257: PUSH
106258: LD_VAR 0 14
106262: PPUSH
106263: LD_INT 58
106265: PUSH
106266: EMPTY
106267: LIST
106268: PPUSH
106269: CALL_OW 72
106273: IN
106274: NOT
106275: IFFALSE 106331
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
106277: LD_VAR 0 4
106281: PUSH
106282: LD_VAR 0 7
106286: ARRAY
106287: PPUSH
106288: LD_VAR 0 14
106292: PUSH
106293: LD_VAR 0 8
106297: ARRAY
106298: PPUSH
106299: CALL_OW 115
// attacking := true ;
106303: LD_ADDR_VAR 0 29
106307: PUSH
106308: LD_INT 1
106310: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
106311: LD_VAR 0 4
106315: PUSH
106316: LD_VAR 0 7
106320: ARRAY
106321: PPUSH
106322: LD_INT 71
106324: PPUSH
106325: CALL_OW 109
// continue ;
106329: GO 106244
// end ; end ;
106331: GO 106244
106333: POP
106334: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
106335: LD_VAR 0 4
106339: PUSH
106340: LD_VAR 0 7
106344: ARRAY
106345: PPUSH
106346: CALL_OW 257
106350: PUSH
106351: LD_INT 8
106353: EQUAL
106354: PUSH
106355: LD_VAR 0 4
106359: PUSH
106360: LD_VAR 0 7
106364: ARRAY
106365: PPUSH
106366: CALL_OW 264
106370: PUSH
106371: LD_INT 28
106373: PUSH
106374: LD_INT 45
106376: PUSH
106377: LD_INT 7
106379: PUSH
106380: LD_INT 47
106382: PUSH
106383: EMPTY
106384: LIST
106385: LIST
106386: LIST
106387: LIST
106388: IN
106389: OR
106390: IFFALSE 106646
// begin attacking := false ;
106392: LD_ADDR_VAR 0 29
106396: PUSH
106397: LD_INT 0
106399: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
106400: LD_VAR 0 14
106404: PUSH
106405: LD_INT 1
106407: ARRAY
106408: PPUSH
106409: CALL_OW 266
106413: PUSH
106414: LD_INT 32
106416: PUSH
106417: LD_INT 31
106419: PUSH
106420: LD_INT 33
106422: PUSH
106423: LD_INT 4
106425: PUSH
106426: LD_INT 5
106428: PUSH
106429: EMPTY
106430: LIST
106431: LIST
106432: LIST
106433: LIST
106434: LIST
106435: IN
106436: IFFALSE 106622
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
106438: LD_ADDR_VAR 0 9
106442: PUSH
106443: LD_VAR 0 14
106447: PUSH
106448: LD_INT 1
106450: ARRAY
106451: PPUSH
106452: CALL_OW 266
106456: PPUSH
106457: LD_VAR 0 14
106461: PUSH
106462: LD_INT 1
106464: ARRAY
106465: PPUSH
106466: CALL_OW 250
106470: PPUSH
106471: LD_VAR 0 14
106475: PUSH
106476: LD_INT 1
106478: ARRAY
106479: PPUSH
106480: CALL_OW 251
106484: PPUSH
106485: LD_VAR 0 14
106489: PUSH
106490: LD_INT 1
106492: ARRAY
106493: PPUSH
106494: CALL_OW 254
106498: PPUSH
106499: LD_VAR 0 14
106503: PUSH
106504: LD_INT 1
106506: ARRAY
106507: PPUSH
106508: CALL_OW 248
106512: PPUSH
106513: LD_INT 0
106515: PPUSH
106516: CALL 27543 0 6
106520: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
106521: LD_ADDR_VAR 0 8
106525: PUSH
106526: LD_VAR 0 4
106530: PUSH
106531: LD_VAR 0 7
106535: ARRAY
106536: PPUSH
106537: LD_VAR 0 9
106541: PPUSH
106542: CALL 46213 0 2
106546: ST_TO_ADDR
// if j then
106547: LD_VAR 0 8
106551: IFFALSE 106620
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
106553: LD_VAR 0 8
106557: PUSH
106558: LD_INT 1
106560: ARRAY
106561: PPUSH
106562: LD_VAR 0 8
106566: PUSH
106567: LD_INT 2
106569: ARRAY
106570: PPUSH
106571: CALL_OW 488
106575: IFFALSE 106620
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
106577: LD_VAR 0 4
106581: PUSH
106582: LD_VAR 0 7
106586: ARRAY
106587: PPUSH
106588: LD_VAR 0 8
106592: PUSH
106593: LD_INT 1
106595: ARRAY
106596: PPUSH
106597: LD_VAR 0 8
106601: PUSH
106602: LD_INT 2
106604: ARRAY
106605: PPUSH
106606: CALL_OW 116
// attacking := true ;
106610: LD_ADDR_VAR 0 29
106614: PUSH
106615: LD_INT 1
106617: ST_TO_ADDR
// continue ;
106618: GO 103993
// end ; end else
106620: GO 106646
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106622: LD_VAR 0 4
106626: PUSH
106627: LD_VAR 0 7
106631: ARRAY
106632: PPUSH
106633: LD_VAR 0 14
106637: PUSH
106638: LD_INT 1
106640: ARRAY
106641: PPUSH
106642: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
106646: LD_VAR 0 4
106650: PUSH
106651: LD_VAR 0 7
106655: ARRAY
106656: PPUSH
106657: CALL_OW 265
106661: PUSH
106662: LD_INT 11
106664: EQUAL
106665: IFFALSE 106943
// begin k := 10 ;
106667: LD_ADDR_VAR 0 9
106671: PUSH
106672: LD_INT 10
106674: ST_TO_ADDR
// x := 0 ;
106675: LD_ADDR_VAR 0 10
106679: PUSH
106680: LD_INT 0
106682: ST_TO_ADDR
// if tmp < k then
106683: LD_VAR 0 14
106687: PUSH
106688: LD_VAR 0 9
106692: LESS
106693: IFFALSE 106705
// k := tmp ;
106695: LD_ADDR_VAR 0 9
106699: PUSH
106700: LD_VAR 0 14
106704: ST_TO_ADDR
// for j = k downto 1 do
106705: LD_ADDR_VAR 0 8
106709: PUSH
106710: DOUBLE
106711: LD_VAR 0 9
106715: INC
106716: ST_TO_ADDR
106717: LD_INT 1
106719: PUSH
106720: FOR_DOWNTO
106721: IFFALSE 106796
// begin if GetType ( tmp [ j ] ) = unit_human then
106723: LD_VAR 0 14
106727: PUSH
106728: LD_VAR 0 8
106732: ARRAY
106733: PPUSH
106734: CALL_OW 247
106738: PUSH
106739: LD_INT 1
106741: EQUAL
106742: IFFALSE 106794
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
106744: LD_VAR 0 4
106748: PUSH
106749: LD_VAR 0 7
106753: ARRAY
106754: PPUSH
106755: LD_VAR 0 14
106759: PUSH
106760: LD_VAR 0 8
106764: ARRAY
106765: PPUSH
106766: CALL 46484 0 2
// x := tmp [ j ] ;
106770: LD_ADDR_VAR 0 10
106774: PUSH
106775: LD_VAR 0 14
106779: PUSH
106780: LD_VAR 0 8
106784: ARRAY
106785: ST_TO_ADDR
// attacking := true ;
106786: LD_ADDR_VAR 0 29
106790: PUSH
106791: LD_INT 1
106793: ST_TO_ADDR
// end ; end ;
106794: GO 106720
106796: POP
106797: POP
// if not x then
106798: LD_VAR 0 10
106802: NOT
106803: IFFALSE 106943
// begin attacking := true ;
106805: LD_ADDR_VAR 0 29
106809: PUSH
106810: LD_INT 1
106812: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
106813: LD_VAR 0 4
106817: PUSH
106818: LD_VAR 0 7
106822: ARRAY
106823: PPUSH
106824: CALL_OW 250
106828: PPUSH
106829: LD_VAR 0 4
106833: PUSH
106834: LD_VAR 0 7
106838: ARRAY
106839: PPUSH
106840: CALL_OW 251
106844: PPUSH
106845: CALL_OW 546
106849: PUSH
106850: LD_INT 2
106852: ARRAY
106853: PUSH
106854: LD_VAR 0 14
106858: PUSH
106859: LD_INT 1
106861: ARRAY
106862: PPUSH
106863: CALL_OW 250
106867: PPUSH
106868: LD_VAR 0 14
106872: PUSH
106873: LD_INT 1
106875: ARRAY
106876: PPUSH
106877: CALL_OW 251
106881: PPUSH
106882: CALL_OW 546
106886: PUSH
106887: LD_INT 2
106889: ARRAY
106890: EQUAL
106891: IFFALSE 106919
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
106893: LD_VAR 0 4
106897: PUSH
106898: LD_VAR 0 7
106902: ARRAY
106903: PPUSH
106904: LD_VAR 0 14
106908: PUSH
106909: LD_INT 1
106911: ARRAY
106912: PPUSH
106913: CALL 46484 0 2
106917: GO 106943
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106919: LD_VAR 0 4
106923: PUSH
106924: LD_VAR 0 7
106928: ARRAY
106929: PPUSH
106930: LD_VAR 0 14
106934: PUSH
106935: LD_INT 1
106937: ARRAY
106938: PPUSH
106939: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
106943: LD_VAR 0 4
106947: PUSH
106948: LD_VAR 0 7
106952: ARRAY
106953: PPUSH
106954: CALL_OW 264
106958: PUSH
106959: LD_INT 29
106961: EQUAL
106962: IFFALSE 107328
// begin if WantsToAttack ( group [ i ] ) in bombed then
106964: LD_VAR 0 4
106968: PUSH
106969: LD_VAR 0 7
106973: ARRAY
106974: PPUSH
106975: CALL_OW 319
106979: PUSH
106980: LD_VAR 0 28
106984: IN
106985: IFFALSE 106989
// continue ;
106987: GO 103993
// k := 8 ;
106989: LD_ADDR_VAR 0 9
106993: PUSH
106994: LD_INT 8
106996: ST_TO_ADDR
// x := 0 ;
106997: LD_ADDR_VAR 0 10
107001: PUSH
107002: LD_INT 0
107004: ST_TO_ADDR
// if tmp < k then
107005: LD_VAR 0 14
107009: PUSH
107010: LD_VAR 0 9
107014: LESS
107015: IFFALSE 107027
// k := tmp ;
107017: LD_ADDR_VAR 0 9
107021: PUSH
107022: LD_VAR 0 14
107026: ST_TO_ADDR
// for j = 1 to k do
107027: LD_ADDR_VAR 0 8
107031: PUSH
107032: DOUBLE
107033: LD_INT 1
107035: DEC
107036: ST_TO_ADDR
107037: LD_VAR 0 9
107041: PUSH
107042: FOR_TO
107043: IFFALSE 107175
// begin if GetType ( tmp [ j ] ) = unit_building then
107045: LD_VAR 0 14
107049: PUSH
107050: LD_VAR 0 8
107054: ARRAY
107055: PPUSH
107056: CALL_OW 247
107060: PUSH
107061: LD_INT 3
107063: EQUAL
107064: IFFALSE 107173
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
107066: LD_VAR 0 14
107070: PUSH
107071: LD_VAR 0 8
107075: ARRAY
107076: PUSH
107077: LD_VAR 0 28
107081: IN
107082: NOT
107083: PUSH
107084: LD_VAR 0 14
107088: PUSH
107089: LD_VAR 0 8
107093: ARRAY
107094: PPUSH
107095: CALL_OW 313
107099: AND
107100: IFFALSE 107173
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
107102: LD_VAR 0 4
107106: PUSH
107107: LD_VAR 0 7
107111: ARRAY
107112: PPUSH
107113: LD_VAR 0 14
107117: PUSH
107118: LD_VAR 0 8
107122: ARRAY
107123: PPUSH
107124: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
107128: LD_ADDR_VAR 0 28
107132: PUSH
107133: LD_VAR 0 28
107137: PPUSH
107138: LD_VAR 0 28
107142: PUSH
107143: LD_INT 1
107145: PLUS
107146: PPUSH
107147: LD_VAR 0 14
107151: PUSH
107152: LD_VAR 0 8
107156: ARRAY
107157: PPUSH
107158: CALL_OW 1
107162: ST_TO_ADDR
// attacking := true ;
107163: LD_ADDR_VAR 0 29
107167: PUSH
107168: LD_INT 1
107170: ST_TO_ADDR
// break ;
107171: GO 107175
// end ; end ;
107173: GO 107042
107175: POP
107176: POP
// if not attacking and f_attack_depot then
107177: LD_VAR 0 29
107181: NOT
107182: PUSH
107183: LD_VAR 0 25
107187: AND
107188: IFFALSE 107283
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107190: LD_ADDR_VAR 0 13
107194: PUSH
107195: LD_VAR 0 14
107199: PPUSH
107200: LD_INT 2
107202: PUSH
107203: LD_INT 30
107205: PUSH
107206: LD_INT 0
107208: PUSH
107209: EMPTY
107210: LIST
107211: LIST
107212: PUSH
107213: LD_INT 30
107215: PUSH
107216: LD_INT 1
107218: PUSH
107219: EMPTY
107220: LIST
107221: LIST
107222: PUSH
107223: EMPTY
107224: LIST
107225: LIST
107226: LIST
107227: PPUSH
107228: CALL_OW 72
107232: ST_TO_ADDR
// if z then
107233: LD_VAR 0 13
107237: IFFALSE 107283
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
107239: LD_VAR 0 4
107243: PUSH
107244: LD_VAR 0 7
107248: ARRAY
107249: PPUSH
107250: LD_VAR 0 13
107254: PPUSH
107255: LD_VAR 0 4
107259: PUSH
107260: LD_VAR 0 7
107264: ARRAY
107265: PPUSH
107266: CALL_OW 74
107270: PPUSH
107271: CALL_OW 115
// attacking := true ;
107275: LD_ADDR_VAR 0 29
107279: PUSH
107280: LD_INT 1
107282: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
107283: LD_VAR 0 4
107287: PUSH
107288: LD_VAR 0 7
107292: ARRAY
107293: PPUSH
107294: CALL_OW 256
107298: PUSH
107299: LD_INT 500
107301: LESS
107302: IFFALSE 107328
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
107304: LD_VAR 0 4
107308: PUSH
107309: LD_VAR 0 7
107313: ARRAY
107314: PPUSH
107315: LD_VAR 0 14
107319: PUSH
107320: LD_INT 1
107322: ARRAY
107323: PPUSH
107324: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
107328: LD_VAR 0 4
107332: PUSH
107333: LD_VAR 0 7
107337: ARRAY
107338: PPUSH
107339: CALL_OW 264
107343: PUSH
107344: LD_INT 49
107346: EQUAL
107347: IFFALSE 107468
// begin if not HasTask ( group [ i ] ) then
107349: LD_VAR 0 4
107353: PUSH
107354: LD_VAR 0 7
107358: ARRAY
107359: PPUSH
107360: CALL_OW 314
107364: NOT
107365: IFFALSE 107468
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
107367: LD_ADDR_VAR 0 9
107371: PUSH
107372: LD_INT 81
107374: PUSH
107375: LD_VAR 0 4
107379: PUSH
107380: LD_VAR 0 7
107384: ARRAY
107385: PPUSH
107386: CALL_OW 255
107390: PUSH
107391: EMPTY
107392: LIST
107393: LIST
107394: PPUSH
107395: CALL_OW 69
107399: PPUSH
107400: LD_VAR 0 4
107404: PUSH
107405: LD_VAR 0 7
107409: ARRAY
107410: PPUSH
107411: CALL_OW 74
107415: ST_TO_ADDR
// if k then
107416: LD_VAR 0 9
107420: IFFALSE 107468
// if GetDistUnits ( group [ i ] , k ) > 10 then
107422: LD_VAR 0 4
107426: PUSH
107427: LD_VAR 0 7
107431: ARRAY
107432: PPUSH
107433: LD_VAR 0 9
107437: PPUSH
107438: CALL_OW 296
107442: PUSH
107443: LD_INT 10
107445: GREATER
107446: IFFALSE 107468
// ComMoveUnit ( group [ i ] , k ) ;
107448: LD_VAR 0 4
107452: PUSH
107453: LD_VAR 0 7
107457: ARRAY
107458: PPUSH
107459: LD_VAR 0 9
107463: PPUSH
107464: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
107468: LD_VAR 0 4
107472: PUSH
107473: LD_VAR 0 7
107477: ARRAY
107478: PPUSH
107479: CALL_OW 256
107483: PUSH
107484: LD_INT 250
107486: LESS
107487: PUSH
107488: LD_VAR 0 4
107492: PUSH
107493: LD_VAR 0 7
107497: ARRAY
107498: PUSH
107499: LD_INT 21
107501: PUSH
107502: LD_INT 2
107504: PUSH
107505: EMPTY
107506: LIST
107507: LIST
107508: PUSH
107509: LD_INT 23
107511: PUSH
107512: LD_INT 2
107514: PUSH
107515: EMPTY
107516: LIST
107517: LIST
107518: PUSH
107519: EMPTY
107520: LIST
107521: LIST
107522: PPUSH
107523: CALL_OW 69
107527: IN
107528: AND
107529: IFFALSE 107654
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
107531: LD_ADDR_VAR 0 9
107535: PUSH
107536: LD_OWVAR 3
107540: PUSH
107541: LD_VAR 0 4
107545: PUSH
107546: LD_VAR 0 7
107550: ARRAY
107551: DIFF
107552: PPUSH
107553: LD_VAR 0 4
107557: PUSH
107558: LD_VAR 0 7
107562: ARRAY
107563: PPUSH
107564: CALL_OW 74
107568: ST_TO_ADDR
// if not k then
107569: LD_VAR 0 9
107573: NOT
107574: IFFALSE 107578
// continue ;
107576: GO 103993
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
107578: LD_VAR 0 9
107582: PUSH
107583: LD_INT 81
107585: PUSH
107586: LD_VAR 0 4
107590: PUSH
107591: LD_VAR 0 7
107595: ARRAY
107596: PPUSH
107597: CALL_OW 255
107601: PUSH
107602: EMPTY
107603: LIST
107604: LIST
107605: PPUSH
107606: CALL_OW 69
107610: IN
107611: PUSH
107612: LD_VAR 0 9
107616: PPUSH
107617: LD_VAR 0 4
107621: PUSH
107622: LD_VAR 0 7
107626: ARRAY
107627: PPUSH
107628: CALL_OW 296
107632: PUSH
107633: LD_INT 5
107635: LESS
107636: AND
107637: IFFALSE 107654
// ComAutodestruct ( group [ i ] ) ;
107639: LD_VAR 0 4
107643: PUSH
107644: LD_VAR 0 7
107648: ARRAY
107649: PPUSH
107650: CALL 46382 0 1
// end ; if f_attack_depot then
107654: LD_VAR 0 25
107658: IFFALSE 107770
// begin k := 6 ;
107660: LD_ADDR_VAR 0 9
107664: PUSH
107665: LD_INT 6
107667: ST_TO_ADDR
// if tmp < k then
107668: LD_VAR 0 14
107672: PUSH
107673: LD_VAR 0 9
107677: LESS
107678: IFFALSE 107690
// k := tmp ;
107680: LD_ADDR_VAR 0 9
107684: PUSH
107685: LD_VAR 0 14
107689: ST_TO_ADDR
// for j = 1 to k do
107690: LD_ADDR_VAR 0 8
107694: PUSH
107695: DOUBLE
107696: LD_INT 1
107698: DEC
107699: ST_TO_ADDR
107700: LD_VAR 0 9
107704: PUSH
107705: FOR_TO
107706: IFFALSE 107768
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
107708: LD_VAR 0 8
107712: PPUSH
107713: CALL_OW 266
107717: PUSH
107718: LD_INT 0
107720: PUSH
107721: LD_INT 1
107723: PUSH
107724: EMPTY
107725: LIST
107726: LIST
107727: IN
107728: IFFALSE 107766
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
107730: LD_VAR 0 4
107734: PUSH
107735: LD_VAR 0 7
107739: ARRAY
107740: PPUSH
107741: LD_VAR 0 14
107745: PUSH
107746: LD_VAR 0 8
107750: ARRAY
107751: PPUSH
107752: CALL_OW 115
// attacking := true ;
107756: LD_ADDR_VAR 0 29
107760: PUSH
107761: LD_INT 1
107763: ST_TO_ADDR
// break ;
107764: GO 107768
// end ;
107766: GO 107705
107768: POP
107769: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
107770: LD_VAR 0 4
107774: PUSH
107775: LD_VAR 0 7
107779: ARRAY
107780: PPUSH
107781: CALL_OW 302
107785: PUSH
107786: LD_VAR 0 29
107790: NOT
107791: AND
107792: IFFALSE 108114
// begin if GetTag ( group [ i ] ) = 71 then
107794: LD_VAR 0 4
107798: PUSH
107799: LD_VAR 0 7
107803: ARRAY
107804: PPUSH
107805: CALL_OW 110
107809: PUSH
107810: LD_INT 71
107812: EQUAL
107813: IFFALSE 107854
// begin if HasTask ( group [ i ] ) then
107815: LD_VAR 0 4
107819: PUSH
107820: LD_VAR 0 7
107824: ARRAY
107825: PPUSH
107826: CALL_OW 314
107830: IFFALSE 107836
// continue else
107832: GO 103993
107834: GO 107854
// SetTag ( group [ i ] , 0 ) ;
107836: LD_VAR 0 4
107840: PUSH
107841: LD_VAR 0 7
107845: ARRAY
107846: PPUSH
107847: LD_INT 0
107849: PPUSH
107850: CALL_OW 109
// end ; k := 8 ;
107854: LD_ADDR_VAR 0 9
107858: PUSH
107859: LD_INT 8
107861: ST_TO_ADDR
// x := 0 ;
107862: LD_ADDR_VAR 0 10
107866: PUSH
107867: LD_INT 0
107869: ST_TO_ADDR
// if tmp < k then
107870: LD_VAR 0 14
107874: PUSH
107875: LD_VAR 0 9
107879: LESS
107880: IFFALSE 107892
// k := tmp ;
107882: LD_ADDR_VAR 0 9
107886: PUSH
107887: LD_VAR 0 14
107891: ST_TO_ADDR
// for j = 1 to k do
107892: LD_ADDR_VAR 0 8
107896: PUSH
107897: DOUBLE
107898: LD_INT 1
107900: DEC
107901: ST_TO_ADDR
107902: LD_VAR 0 9
107906: PUSH
107907: FOR_TO
107908: IFFALSE 108006
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
107910: LD_VAR 0 14
107914: PUSH
107915: LD_VAR 0 8
107919: ARRAY
107920: PPUSH
107921: CALL_OW 247
107925: PUSH
107926: LD_INT 1
107928: EQUAL
107929: PUSH
107930: LD_VAR 0 14
107934: PUSH
107935: LD_VAR 0 8
107939: ARRAY
107940: PPUSH
107941: CALL_OW 256
107945: PUSH
107946: LD_INT 250
107948: LESS
107949: PUSH
107950: LD_VAR 0 20
107954: AND
107955: PUSH
107956: LD_VAR 0 20
107960: NOT
107961: PUSH
107962: LD_VAR 0 14
107966: PUSH
107967: LD_VAR 0 8
107971: ARRAY
107972: PPUSH
107973: CALL_OW 256
107977: PUSH
107978: LD_INT 250
107980: GREATEREQUAL
107981: AND
107982: OR
107983: AND
107984: IFFALSE 108004
// begin x := tmp [ j ] ;
107986: LD_ADDR_VAR 0 10
107990: PUSH
107991: LD_VAR 0 14
107995: PUSH
107996: LD_VAR 0 8
108000: ARRAY
108001: ST_TO_ADDR
// break ;
108002: GO 108006
// end ;
108004: GO 107907
108006: POP
108007: POP
// if x then
108008: LD_VAR 0 10
108012: IFFALSE 108036
// ComAttackUnit ( group [ i ] , x ) else
108014: LD_VAR 0 4
108018: PUSH
108019: LD_VAR 0 7
108023: ARRAY
108024: PPUSH
108025: LD_VAR 0 10
108029: PPUSH
108030: CALL_OW 115
108034: GO 108060
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108036: LD_VAR 0 4
108040: PUSH
108041: LD_VAR 0 7
108045: ARRAY
108046: PPUSH
108047: LD_VAR 0 14
108051: PUSH
108052: LD_INT 1
108054: ARRAY
108055: PPUSH
108056: CALL_OW 115
// if not HasTask ( group [ i ] ) then
108060: LD_VAR 0 4
108064: PUSH
108065: LD_VAR 0 7
108069: ARRAY
108070: PPUSH
108071: CALL_OW 314
108075: NOT
108076: IFFALSE 108114
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
108078: LD_VAR 0 4
108082: PUSH
108083: LD_VAR 0 7
108087: ARRAY
108088: PPUSH
108089: LD_VAR 0 14
108093: PPUSH
108094: LD_VAR 0 4
108098: PUSH
108099: LD_VAR 0 7
108103: ARRAY
108104: PPUSH
108105: CALL_OW 74
108109: PPUSH
108110: CALL_OW 115
// end ; end ; end ;
108114: GO 103993
108116: POP
108117: POP
// wait ( 0 0$2 ) ;
108118: LD_INT 70
108120: PPUSH
108121: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
108125: LD_VAR 0 4
108129: NOT
108130: PUSH
108131: LD_VAR 0 4
108135: PUSH
108136: EMPTY
108137: EQUAL
108138: OR
108139: PUSH
108140: LD_INT 81
108142: PUSH
108143: LD_VAR 0 35
108147: PUSH
108148: EMPTY
108149: LIST
108150: LIST
108151: PPUSH
108152: CALL_OW 69
108156: NOT
108157: OR
108158: IFFALSE 103978
// end ;
108160: LD_VAR 0 2
108164: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
108165: LD_INT 0
108167: PPUSH
108168: PPUSH
108169: PPUSH
108170: PPUSH
108171: PPUSH
108172: PPUSH
// if not base or not mc_bases [ base ] or not solds then
108173: LD_VAR 0 1
108177: NOT
108178: PUSH
108179: LD_EXP 69
108183: PUSH
108184: LD_VAR 0 1
108188: ARRAY
108189: NOT
108190: OR
108191: PUSH
108192: LD_VAR 0 2
108196: NOT
108197: OR
108198: IFFALSE 108202
// exit ;
108200: GO 108756
// side := mc_sides [ base ] ;
108202: LD_ADDR_VAR 0 6
108206: PUSH
108207: LD_EXP 95
108211: PUSH
108212: LD_VAR 0 1
108216: ARRAY
108217: ST_TO_ADDR
// if not side then
108218: LD_VAR 0 6
108222: NOT
108223: IFFALSE 108227
// exit ;
108225: GO 108756
// for i in solds do
108227: LD_ADDR_VAR 0 7
108231: PUSH
108232: LD_VAR 0 2
108236: PUSH
108237: FOR_IN
108238: IFFALSE 108299
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
108240: LD_VAR 0 7
108244: PPUSH
108245: CALL_OW 310
108249: PPUSH
108250: CALL_OW 266
108254: PUSH
108255: LD_INT 32
108257: PUSH
108258: LD_INT 31
108260: PUSH
108261: EMPTY
108262: LIST
108263: LIST
108264: IN
108265: IFFALSE 108285
// solds := solds diff i else
108267: LD_ADDR_VAR 0 2
108271: PUSH
108272: LD_VAR 0 2
108276: PUSH
108277: LD_VAR 0 7
108281: DIFF
108282: ST_TO_ADDR
108283: GO 108297
// SetTag ( i , 18 ) ;
108285: LD_VAR 0 7
108289: PPUSH
108290: LD_INT 18
108292: PPUSH
108293: CALL_OW 109
108297: GO 108237
108299: POP
108300: POP
// if not solds then
108301: LD_VAR 0 2
108305: NOT
108306: IFFALSE 108310
// exit ;
108308: GO 108756
// repeat wait ( 0 0$2 ) ;
108310: LD_INT 70
108312: PPUSH
108313: CALL_OW 67
// enemy := mc_scan [ base ] ;
108317: LD_ADDR_VAR 0 4
108321: PUSH
108322: LD_EXP 92
108326: PUSH
108327: LD_VAR 0 1
108331: ARRAY
108332: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
108333: LD_EXP 69
108337: PUSH
108338: LD_VAR 0 1
108342: ARRAY
108343: NOT
108344: PUSH
108345: LD_EXP 69
108349: PUSH
108350: LD_VAR 0 1
108354: ARRAY
108355: PUSH
108356: EMPTY
108357: EQUAL
108358: OR
108359: IFFALSE 108396
// begin for i in solds do
108361: LD_ADDR_VAR 0 7
108365: PUSH
108366: LD_VAR 0 2
108370: PUSH
108371: FOR_IN
108372: IFFALSE 108385
// ComStop ( i ) ;
108374: LD_VAR 0 7
108378: PPUSH
108379: CALL_OW 141
108383: GO 108371
108385: POP
108386: POP
// solds := [ ] ;
108387: LD_ADDR_VAR 0 2
108391: PUSH
108392: EMPTY
108393: ST_TO_ADDR
// exit ;
108394: GO 108756
// end ; for i in solds do
108396: LD_ADDR_VAR 0 7
108400: PUSH
108401: LD_VAR 0 2
108405: PUSH
108406: FOR_IN
108407: IFFALSE 108728
// begin if IsInUnit ( i ) then
108409: LD_VAR 0 7
108413: PPUSH
108414: CALL_OW 310
108418: IFFALSE 108429
// ComExitBuilding ( i ) ;
108420: LD_VAR 0 7
108424: PPUSH
108425: CALL_OW 122
// if GetLives ( i ) > 500 then
108429: LD_VAR 0 7
108433: PPUSH
108434: CALL_OW 256
108438: PUSH
108439: LD_INT 500
108441: GREATER
108442: IFFALSE 108495
// begin e := NearestUnitToUnit ( enemy , i ) ;
108444: LD_ADDR_VAR 0 5
108448: PUSH
108449: LD_VAR 0 4
108453: PPUSH
108454: LD_VAR 0 7
108458: PPUSH
108459: CALL_OW 74
108463: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
108464: LD_VAR 0 7
108468: PPUSH
108469: LD_VAR 0 5
108473: PPUSH
108474: CALL_OW 250
108478: PPUSH
108479: LD_VAR 0 5
108483: PPUSH
108484: CALL_OW 251
108488: PPUSH
108489: CALL_OW 114
// end else
108493: GO 108726
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
108495: LD_VAR 0 7
108499: PPUSH
108500: LD_EXP 69
108504: PUSH
108505: LD_VAR 0 1
108509: ARRAY
108510: PPUSH
108511: LD_INT 2
108513: PUSH
108514: LD_INT 30
108516: PUSH
108517: LD_INT 0
108519: PUSH
108520: EMPTY
108521: LIST
108522: LIST
108523: PUSH
108524: LD_INT 30
108526: PUSH
108527: LD_INT 1
108529: PUSH
108530: EMPTY
108531: LIST
108532: LIST
108533: PUSH
108534: LD_INT 30
108536: PUSH
108537: LD_INT 6
108539: PUSH
108540: EMPTY
108541: LIST
108542: LIST
108543: PUSH
108544: EMPTY
108545: LIST
108546: LIST
108547: LIST
108548: LIST
108549: PPUSH
108550: CALL_OW 72
108554: PPUSH
108555: LD_VAR 0 7
108559: PPUSH
108560: CALL_OW 74
108564: PPUSH
108565: CALL_OW 296
108569: PUSH
108570: LD_INT 10
108572: GREATER
108573: IFFALSE 108726
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
108575: LD_ADDR_VAR 0 8
108579: PUSH
108580: LD_EXP 69
108584: PUSH
108585: LD_VAR 0 1
108589: ARRAY
108590: PPUSH
108591: LD_INT 2
108593: PUSH
108594: LD_INT 30
108596: PUSH
108597: LD_INT 0
108599: PUSH
108600: EMPTY
108601: LIST
108602: LIST
108603: PUSH
108604: LD_INT 30
108606: PUSH
108607: LD_INT 1
108609: PUSH
108610: EMPTY
108611: LIST
108612: LIST
108613: PUSH
108614: LD_INT 30
108616: PUSH
108617: LD_INT 6
108619: PUSH
108620: EMPTY
108621: LIST
108622: LIST
108623: PUSH
108624: EMPTY
108625: LIST
108626: LIST
108627: LIST
108628: LIST
108629: PPUSH
108630: CALL_OW 72
108634: PPUSH
108635: LD_VAR 0 7
108639: PPUSH
108640: CALL_OW 74
108644: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
108645: LD_VAR 0 7
108649: PPUSH
108650: LD_VAR 0 8
108654: PPUSH
108655: CALL_OW 250
108659: PPUSH
108660: LD_INT 3
108662: PPUSH
108663: LD_INT 5
108665: PPUSH
108666: CALL_OW 272
108670: PPUSH
108671: LD_VAR 0 8
108675: PPUSH
108676: CALL_OW 251
108680: PPUSH
108681: LD_INT 3
108683: PPUSH
108684: LD_INT 5
108686: PPUSH
108687: CALL_OW 273
108691: PPUSH
108692: CALL_OW 111
// SetTag ( i , 0 ) ;
108696: LD_VAR 0 7
108700: PPUSH
108701: LD_INT 0
108703: PPUSH
108704: CALL_OW 109
// solds := solds diff i ;
108708: LD_ADDR_VAR 0 2
108712: PUSH
108713: LD_VAR 0 2
108717: PUSH
108718: LD_VAR 0 7
108722: DIFF
108723: ST_TO_ADDR
// continue ;
108724: GO 108406
// end ; end ;
108726: GO 108406
108728: POP
108729: POP
// until not solds or not enemy ;
108730: LD_VAR 0 2
108734: NOT
108735: PUSH
108736: LD_VAR 0 4
108740: NOT
108741: OR
108742: IFFALSE 108310
// MC_Reset ( base , 18 ) ;
108744: LD_VAR 0 1
108748: PPUSH
108749: LD_INT 18
108751: PPUSH
108752: CALL 58015 0 2
// end ;
108756: LD_VAR 0 3
108760: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
108761: LD_INT 0
108763: PPUSH
108764: PPUSH
108765: PPUSH
108766: PPUSH
108767: PPUSH
108768: PPUSH
108769: PPUSH
108770: PPUSH
108771: PPUSH
108772: PPUSH
108773: PPUSH
108774: PPUSH
108775: PPUSH
108776: PPUSH
108777: PPUSH
108778: PPUSH
108779: PPUSH
108780: PPUSH
108781: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
108782: LD_ADDR_VAR 0 12
108786: PUSH
108787: LD_EXP 69
108791: PUSH
108792: LD_VAR 0 1
108796: ARRAY
108797: PPUSH
108798: LD_INT 25
108800: PUSH
108801: LD_INT 3
108803: PUSH
108804: EMPTY
108805: LIST
108806: LIST
108807: PPUSH
108808: CALL_OW 72
108812: ST_TO_ADDR
// if mc_remote_driver [ base ] then
108813: LD_EXP 109
108817: PUSH
108818: LD_VAR 0 1
108822: ARRAY
108823: IFFALSE 108847
// mechs := mechs diff mc_remote_driver [ base ] ;
108825: LD_ADDR_VAR 0 12
108829: PUSH
108830: LD_VAR 0 12
108834: PUSH
108835: LD_EXP 109
108839: PUSH
108840: LD_VAR 0 1
108844: ARRAY
108845: DIFF
108846: ST_TO_ADDR
// for i in mechs do
108847: LD_ADDR_VAR 0 4
108851: PUSH
108852: LD_VAR 0 12
108856: PUSH
108857: FOR_IN
108858: IFFALSE 108893
// if GetTag ( i ) > 0 then
108860: LD_VAR 0 4
108864: PPUSH
108865: CALL_OW 110
108869: PUSH
108870: LD_INT 0
108872: GREATER
108873: IFFALSE 108891
// mechs := mechs diff i ;
108875: LD_ADDR_VAR 0 12
108879: PUSH
108880: LD_VAR 0 12
108884: PUSH
108885: LD_VAR 0 4
108889: DIFF
108890: ST_TO_ADDR
108891: GO 108857
108893: POP
108894: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
108895: LD_ADDR_VAR 0 8
108899: PUSH
108900: LD_EXP 69
108904: PUSH
108905: LD_VAR 0 1
108909: ARRAY
108910: PPUSH
108911: LD_INT 2
108913: PUSH
108914: LD_INT 25
108916: PUSH
108917: LD_INT 1
108919: PUSH
108920: EMPTY
108921: LIST
108922: LIST
108923: PUSH
108924: LD_INT 25
108926: PUSH
108927: LD_INT 5
108929: PUSH
108930: EMPTY
108931: LIST
108932: LIST
108933: PUSH
108934: LD_INT 25
108936: PUSH
108937: LD_INT 8
108939: PUSH
108940: EMPTY
108941: LIST
108942: LIST
108943: PUSH
108944: LD_INT 25
108946: PUSH
108947: LD_INT 9
108949: PUSH
108950: EMPTY
108951: LIST
108952: LIST
108953: PUSH
108954: EMPTY
108955: LIST
108956: LIST
108957: LIST
108958: LIST
108959: LIST
108960: PPUSH
108961: CALL_OW 72
108965: ST_TO_ADDR
// if not defenders and not solds then
108966: LD_VAR 0 2
108970: NOT
108971: PUSH
108972: LD_VAR 0 8
108976: NOT
108977: AND
108978: IFFALSE 108982
// exit ;
108980: GO 110752
// depot_under_attack := false ;
108982: LD_ADDR_VAR 0 16
108986: PUSH
108987: LD_INT 0
108989: ST_TO_ADDR
// sold_defenders := [ ] ;
108990: LD_ADDR_VAR 0 17
108994: PUSH
108995: EMPTY
108996: ST_TO_ADDR
// if mechs then
108997: LD_VAR 0 12
109001: IFFALSE 109154
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
109003: LD_ADDR_VAR 0 4
109007: PUSH
109008: LD_VAR 0 2
109012: PPUSH
109013: LD_INT 21
109015: PUSH
109016: LD_INT 2
109018: PUSH
109019: EMPTY
109020: LIST
109021: LIST
109022: PPUSH
109023: CALL_OW 72
109027: PUSH
109028: FOR_IN
109029: IFFALSE 109152
// begin if GetTag ( i ) <> 20 then
109031: LD_VAR 0 4
109035: PPUSH
109036: CALL_OW 110
109040: PUSH
109041: LD_INT 20
109043: NONEQUAL
109044: IFFALSE 109058
// SetTag ( i , 20 ) ;
109046: LD_VAR 0 4
109050: PPUSH
109051: LD_INT 20
109053: PPUSH
109054: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
109058: LD_VAR 0 4
109062: PPUSH
109063: CALL_OW 263
109067: PUSH
109068: LD_INT 1
109070: EQUAL
109071: PUSH
109072: LD_VAR 0 4
109076: PPUSH
109077: CALL_OW 311
109081: NOT
109082: AND
109083: IFFALSE 109150
// begin un := mechs [ 1 ] ;
109085: LD_ADDR_VAR 0 10
109089: PUSH
109090: LD_VAR 0 12
109094: PUSH
109095: LD_INT 1
109097: ARRAY
109098: ST_TO_ADDR
// ComExit ( un ) ;
109099: LD_VAR 0 10
109103: PPUSH
109104: CALL 50727 0 1
// AddComEnterUnit ( un , i ) ;
109108: LD_VAR 0 10
109112: PPUSH
109113: LD_VAR 0 4
109117: PPUSH
109118: CALL_OW 180
// SetTag ( un , 19 ) ;
109122: LD_VAR 0 10
109126: PPUSH
109127: LD_INT 19
109129: PPUSH
109130: CALL_OW 109
// mechs := mechs diff un ;
109134: LD_ADDR_VAR 0 12
109138: PUSH
109139: LD_VAR 0 12
109143: PUSH
109144: LD_VAR 0 10
109148: DIFF
109149: ST_TO_ADDR
// end ; end ;
109150: GO 109028
109152: POP
109153: POP
// if solds then
109154: LD_VAR 0 8
109158: IFFALSE 109217
// for i in solds do
109160: LD_ADDR_VAR 0 4
109164: PUSH
109165: LD_VAR 0 8
109169: PUSH
109170: FOR_IN
109171: IFFALSE 109215
// if not GetTag ( i ) then
109173: LD_VAR 0 4
109177: PPUSH
109178: CALL_OW 110
109182: NOT
109183: IFFALSE 109213
// begin defenders := defenders union i ;
109185: LD_ADDR_VAR 0 2
109189: PUSH
109190: LD_VAR 0 2
109194: PUSH
109195: LD_VAR 0 4
109199: UNION
109200: ST_TO_ADDR
// SetTag ( i , 18 ) ;
109201: LD_VAR 0 4
109205: PPUSH
109206: LD_INT 18
109208: PPUSH
109209: CALL_OW 109
// end ;
109213: GO 109170
109215: POP
109216: POP
// repeat wait ( 0 0$2 ) ;
109217: LD_INT 70
109219: PPUSH
109220: CALL_OW 67
// enemy := mc_scan [ base ] ;
109224: LD_ADDR_VAR 0 21
109228: PUSH
109229: LD_EXP 92
109233: PUSH
109234: LD_VAR 0 1
109238: ARRAY
109239: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
109240: LD_EXP 69
109244: PUSH
109245: LD_VAR 0 1
109249: ARRAY
109250: NOT
109251: PUSH
109252: LD_EXP 69
109256: PUSH
109257: LD_VAR 0 1
109261: ARRAY
109262: PUSH
109263: EMPTY
109264: EQUAL
109265: OR
109266: IFFALSE 109303
// begin for i in defenders do
109268: LD_ADDR_VAR 0 4
109272: PUSH
109273: LD_VAR 0 2
109277: PUSH
109278: FOR_IN
109279: IFFALSE 109292
// ComStop ( i ) ;
109281: LD_VAR 0 4
109285: PPUSH
109286: CALL_OW 141
109290: GO 109278
109292: POP
109293: POP
// defenders := [ ] ;
109294: LD_ADDR_VAR 0 2
109298: PUSH
109299: EMPTY
109300: ST_TO_ADDR
// exit ;
109301: GO 110752
// end ; for i in defenders do
109303: LD_ADDR_VAR 0 4
109307: PUSH
109308: LD_VAR 0 2
109312: PUSH
109313: FOR_IN
109314: IFFALSE 110212
// begin e := NearestUnitToUnit ( enemy , i ) ;
109316: LD_ADDR_VAR 0 13
109320: PUSH
109321: LD_VAR 0 21
109325: PPUSH
109326: LD_VAR 0 4
109330: PPUSH
109331: CALL_OW 74
109335: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
109336: LD_ADDR_VAR 0 7
109340: PUSH
109341: LD_EXP 69
109345: PUSH
109346: LD_VAR 0 1
109350: ARRAY
109351: PPUSH
109352: LD_INT 2
109354: PUSH
109355: LD_INT 30
109357: PUSH
109358: LD_INT 0
109360: PUSH
109361: EMPTY
109362: LIST
109363: LIST
109364: PUSH
109365: LD_INT 30
109367: PUSH
109368: LD_INT 1
109370: PUSH
109371: EMPTY
109372: LIST
109373: LIST
109374: PUSH
109375: EMPTY
109376: LIST
109377: LIST
109378: LIST
109379: PPUSH
109380: CALL_OW 72
109384: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
109385: LD_ADDR_VAR 0 16
109389: PUSH
109390: LD_VAR 0 7
109394: NOT
109395: PUSH
109396: LD_VAR 0 7
109400: PPUSH
109401: LD_INT 3
109403: PUSH
109404: LD_INT 24
109406: PUSH
109407: LD_INT 600
109409: PUSH
109410: EMPTY
109411: LIST
109412: LIST
109413: PUSH
109414: EMPTY
109415: LIST
109416: LIST
109417: PPUSH
109418: CALL_OW 72
109422: OR
109423: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
109424: LD_VAR 0 4
109428: PPUSH
109429: CALL_OW 247
109433: PUSH
109434: LD_INT 2
109436: DOUBLE
109437: EQUAL
109438: IFTRUE 109442
109440: GO 109838
109442: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
109443: LD_VAR 0 4
109447: PPUSH
109448: CALL_OW 256
109452: PUSH
109453: LD_INT 1000
109455: EQUAL
109456: PUSH
109457: LD_VAR 0 4
109461: PPUSH
109462: LD_VAR 0 13
109466: PPUSH
109467: CALL_OW 296
109471: PUSH
109472: LD_INT 40
109474: LESS
109475: PUSH
109476: LD_VAR 0 13
109480: PPUSH
109481: LD_EXP 94
109485: PUSH
109486: LD_VAR 0 1
109490: ARRAY
109491: PPUSH
109492: CALL_OW 308
109496: OR
109497: AND
109498: IFFALSE 109620
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
109500: LD_VAR 0 4
109504: PPUSH
109505: CALL_OW 262
109509: PUSH
109510: LD_INT 1
109512: EQUAL
109513: PUSH
109514: LD_VAR 0 4
109518: PPUSH
109519: CALL_OW 261
109523: PUSH
109524: LD_INT 30
109526: LESS
109527: AND
109528: PUSH
109529: LD_VAR 0 7
109533: AND
109534: IFFALSE 109604
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
109536: LD_VAR 0 4
109540: PPUSH
109541: LD_VAR 0 7
109545: PPUSH
109546: LD_VAR 0 4
109550: PPUSH
109551: CALL_OW 74
109555: PPUSH
109556: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
109560: LD_VAR 0 4
109564: PPUSH
109565: LD_VAR 0 7
109569: PPUSH
109570: LD_VAR 0 4
109574: PPUSH
109575: CALL_OW 74
109579: PPUSH
109580: CALL_OW 296
109584: PUSH
109585: LD_INT 6
109587: LESS
109588: IFFALSE 109602
// SetFuel ( i , 100 ) ;
109590: LD_VAR 0 4
109594: PPUSH
109595: LD_INT 100
109597: PPUSH
109598: CALL_OW 240
// end else
109602: GO 109618
// ComAttackUnit ( i , e ) ;
109604: LD_VAR 0 4
109608: PPUSH
109609: LD_VAR 0 13
109613: PPUSH
109614: CALL_OW 115
// end else
109618: GO 109721
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
109620: LD_VAR 0 13
109624: PPUSH
109625: LD_EXP 94
109629: PUSH
109630: LD_VAR 0 1
109634: ARRAY
109635: PPUSH
109636: CALL_OW 308
109640: NOT
109641: PUSH
109642: LD_VAR 0 4
109646: PPUSH
109647: LD_VAR 0 13
109651: PPUSH
109652: CALL_OW 296
109656: PUSH
109657: LD_INT 40
109659: GREATEREQUAL
109660: AND
109661: PUSH
109662: LD_VAR 0 4
109666: PPUSH
109667: CALL_OW 256
109671: PUSH
109672: LD_INT 650
109674: LESSEQUAL
109675: OR
109676: PUSH
109677: LD_VAR 0 4
109681: PPUSH
109682: LD_EXP 93
109686: PUSH
109687: LD_VAR 0 1
109691: ARRAY
109692: PPUSH
109693: CALL_OW 308
109697: NOT
109698: AND
109699: IFFALSE 109721
// ComMoveToArea ( i , mc_parking [ base ] ) ;
109701: LD_VAR 0 4
109705: PPUSH
109706: LD_EXP 93
109710: PUSH
109711: LD_VAR 0 1
109715: ARRAY
109716: PPUSH
109717: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
109721: LD_VAR 0 4
109725: PPUSH
109726: CALL_OW 256
109730: PUSH
109731: LD_INT 1000
109733: LESS
109734: PUSH
109735: LD_VAR 0 4
109739: PPUSH
109740: CALL_OW 263
109744: PUSH
109745: LD_INT 1
109747: EQUAL
109748: AND
109749: PUSH
109750: LD_VAR 0 4
109754: PPUSH
109755: CALL_OW 311
109759: AND
109760: PUSH
109761: LD_VAR 0 4
109765: PPUSH
109766: LD_EXP 93
109770: PUSH
109771: LD_VAR 0 1
109775: ARRAY
109776: PPUSH
109777: CALL_OW 308
109781: AND
109782: IFFALSE 109836
// begin mech := IsDrivenBy ( i ) ;
109784: LD_ADDR_VAR 0 9
109788: PUSH
109789: LD_VAR 0 4
109793: PPUSH
109794: CALL_OW 311
109798: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
109799: LD_VAR 0 9
109803: PPUSH
109804: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
109808: LD_VAR 0 9
109812: PPUSH
109813: LD_VAR 0 4
109817: PPUSH
109818: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
109822: LD_VAR 0 9
109826: PPUSH
109827: LD_VAR 0 4
109831: PPUSH
109832: CALL_OW 180
// end ; end ; unit_human :
109836: GO 110183
109838: LD_INT 1
109840: DOUBLE
109841: EQUAL
109842: IFTRUE 109846
109844: GO 110182
109846: POP
// begin b := IsInUnit ( i ) ;
109847: LD_ADDR_VAR 0 18
109851: PUSH
109852: LD_VAR 0 4
109856: PPUSH
109857: CALL_OW 310
109861: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
109862: LD_ADDR_VAR 0 19
109866: PUSH
109867: LD_VAR 0 18
109871: NOT
109872: PUSH
109873: LD_VAR 0 18
109877: PPUSH
109878: CALL_OW 266
109882: PUSH
109883: LD_INT 32
109885: PUSH
109886: LD_INT 31
109888: PUSH
109889: EMPTY
109890: LIST
109891: LIST
109892: IN
109893: OR
109894: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
109895: LD_VAR 0 18
109899: PPUSH
109900: CALL_OW 266
109904: PUSH
109905: LD_INT 5
109907: EQUAL
109908: PUSH
109909: LD_VAR 0 4
109913: PPUSH
109914: CALL_OW 257
109918: PUSH
109919: LD_INT 1
109921: PUSH
109922: LD_INT 2
109924: PUSH
109925: LD_INT 3
109927: PUSH
109928: LD_INT 4
109930: PUSH
109931: EMPTY
109932: LIST
109933: LIST
109934: LIST
109935: LIST
109936: IN
109937: AND
109938: IFFALSE 109975
// begin class := AllowSpecClass ( i ) ;
109940: LD_ADDR_VAR 0 20
109944: PUSH
109945: LD_VAR 0 4
109949: PPUSH
109950: CALL 15388 0 1
109954: ST_TO_ADDR
// if class then
109955: LD_VAR 0 20
109959: IFFALSE 109975
// ComChangeProfession ( i , class ) ;
109961: LD_VAR 0 4
109965: PPUSH
109966: LD_VAR 0 20
109970: PPUSH
109971: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
109975: LD_VAR 0 16
109979: PUSH
109980: LD_VAR 0 2
109984: PPUSH
109985: LD_INT 21
109987: PUSH
109988: LD_INT 2
109990: PUSH
109991: EMPTY
109992: LIST
109993: LIST
109994: PPUSH
109995: CALL_OW 72
109999: PUSH
110000: LD_INT 1
110002: LESSEQUAL
110003: OR
110004: PUSH
110005: LD_VAR 0 19
110009: AND
110010: PUSH
110011: LD_VAR 0 4
110015: PUSH
110016: LD_VAR 0 17
110020: IN
110021: NOT
110022: AND
110023: IFFALSE 110116
// begin if b then
110025: LD_VAR 0 18
110029: IFFALSE 110078
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
110031: LD_VAR 0 18
110035: PPUSH
110036: LD_VAR 0 21
110040: PPUSH
110041: LD_VAR 0 18
110045: PPUSH
110046: CALL_OW 74
110050: PPUSH
110051: CALL_OW 296
110055: PUSH
110056: LD_INT 10
110058: LESS
110059: PUSH
110060: LD_VAR 0 18
110064: PPUSH
110065: CALL_OW 461
110069: PUSH
110070: LD_INT 7
110072: NONEQUAL
110073: AND
110074: IFFALSE 110078
// continue ;
110076: GO 109313
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
110078: LD_ADDR_VAR 0 17
110082: PUSH
110083: LD_VAR 0 17
110087: PPUSH
110088: LD_VAR 0 17
110092: PUSH
110093: LD_INT 1
110095: PLUS
110096: PPUSH
110097: LD_VAR 0 4
110101: PPUSH
110102: CALL_OW 1
110106: ST_TO_ADDR
// ComExitBuilding ( i ) ;
110107: LD_VAR 0 4
110111: PPUSH
110112: CALL_OW 122
// end ; if sold_defenders then
110116: LD_VAR 0 17
110120: IFFALSE 110180
// if i in sold_defenders then
110122: LD_VAR 0 4
110126: PUSH
110127: LD_VAR 0 17
110131: IN
110132: IFFALSE 110180
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
110134: LD_VAR 0 4
110138: PPUSH
110139: CALL_OW 314
110143: NOT
110144: PUSH
110145: LD_VAR 0 4
110149: PPUSH
110150: LD_VAR 0 13
110154: PPUSH
110155: CALL_OW 296
110159: PUSH
110160: LD_INT 30
110162: LESS
110163: AND
110164: IFFALSE 110180
// ComAttackUnit ( i , e ) ;
110166: LD_VAR 0 4
110170: PPUSH
110171: LD_VAR 0 13
110175: PPUSH
110176: CALL_OW 115
// end ; end ; end ;
110180: GO 110183
110182: POP
// if IsDead ( i ) then
110183: LD_VAR 0 4
110187: PPUSH
110188: CALL_OW 301
110192: IFFALSE 110210
// defenders := defenders diff i ;
110194: LD_ADDR_VAR 0 2
110198: PUSH
110199: LD_VAR 0 2
110203: PUSH
110204: LD_VAR 0 4
110208: DIFF
110209: ST_TO_ADDR
// end ;
110210: GO 109313
110212: POP
110213: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
110214: LD_VAR 0 21
110218: NOT
110219: PUSH
110220: LD_VAR 0 2
110224: NOT
110225: OR
110226: PUSH
110227: LD_EXP 69
110231: PUSH
110232: LD_VAR 0 1
110236: ARRAY
110237: NOT
110238: OR
110239: IFFALSE 109217
// MC_Reset ( base , 18 ) ;
110241: LD_VAR 0 1
110245: PPUSH
110246: LD_INT 18
110248: PPUSH
110249: CALL 58015 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
110253: LD_ADDR_VAR 0 2
110257: PUSH
110258: LD_VAR 0 2
110262: PUSH
110263: LD_VAR 0 2
110267: PPUSH
110268: LD_INT 2
110270: PUSH
110271: LD_INT 25
110273: PUSH
110274: LD_INT 1
110276: PUSH
110277: EMPTY
110278: LIST
110279: LIST
110280: PUSH
110281: LD_INT 25
110283: PUSH
110284: LD_INT 5
110286: PUSH
110287: EMPTY
110288: LIST
110289: LIST
110290: PUSH
110291: LD_INT 25
110293: PUSH
110294: LD_INT 8
110296: PUSH
110297: EMPTY
110298: LIST
110299: LIST
110300: PUSH
110301: LD_INT 25
110303: PUSH
110304: LD_INT 9
110306: PUSH
110307: EMPTY
110308: LIST
110309: LIST
110310: PUSH
110311: EMPTY
110312: LIST
110313: LIST
110314: LIST
110315: LIST
110316: LIST
110317: PPUSH
110318: CALL_OW 72
110322: DIFF
110323: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
110324: LD_VAR 0 21
110328: NOT
110329: PUSH
110330: LD_VAR 0 2
110334: PPUSH
110335: LD_INT 21
110337: PUSH
110338: LD_INT 2
110340: PUSH
110341: EMPTY
110342: LIST
110343: LIST
110344: PPUSH
110345: CALL_OW 72
110349: AND
110350: IFFALSE 110688
// begin tmp := FilterByTag ( defenders , 19 ) ;
110352: LD_ADDR_VAR 0 11
110356: PUSH
110357: LD_VAR 0 2
110361: PPUSH
110362: LD_INT 19
110364: PPUSH
110365: CALL 47857 0 2
110369: ST_TO_ADDR
// if tmp then
110370: LD_VAR 0 11
110374: IFFALSE 110444
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
110376: LD_ADDR_VAR 0 11
110380: PUSH
110381: LD_VAR 0 11
110385: PPUSH
110386: LD_INT 25
110388: PUSH
110389: LD_INT 3
110391: PUSH
110392: EMPTY
110393: LIST
110394: LIST
110395: PPUSH
110396: CALL_OW 72
110400: ST_TO_ADDR
// if tmp then
110401: LD_VAR 0 11
110405: IFFALSE 110444
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
110407: LD_ADDR_EXP 81
110411: PUSH
110412: LD_EXP 81
110416: PPUSH
110417: LD_VAR 0 1
110421: PPUSH
110422: LD_EXP 81
110426: PUSH
110427: LD_VAR 0 1
110431: ARRAY
110432: PUSH
110433: LD_VAR 0 11
110437: UNION
110438: PPUSH
110439: CALL_OW 1
110443: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
110444: LD_VAR 0 1
110448: PPUSH
110449: LD_INT 19
110451: PPUSH
110452: CALL 58015 0 2
// repeat wait ( 0 0$1 ) ;
110456: LD_INT 35
110458: PPUSH
110459: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110463: LD_EXP 69
110467: PUSH
110468: LD_VAR 0 1
110472: ARRAY
110473: NOT
110474: PUSH
110475: LD_EXP 69
110479: PUSH
110480: LD_VAR 0 1
110484: ARRAY
110485: PUSH
110486: EMPTY
110487: EQUAL
110488: OR
110489: IFFALSE 110526
// begin for i in defenders do
110491: LD_ADDR_VAR 0 4
110495: PUSH
110496: LD_VAR 0 2
110500: PUSH
110501: FOR_IN
110502: IFFALSE 110515
// ComStop ( i ) ;
110504: LD_VAR 0 4
110508: PPUSH
110509: CALL_OW 141
110513: GO 110501
110515: POP
110516: POP
// defenders := [ ] ;
110517: LD_ADDR_VAR 0 2
110521: PUSH
110522: EMPTY
110523: ST_TO_ADDR
// exit ;
110524: GO 110752
// end ; for i in defenders do
110526: LD_ADDR_VAR 0 4
110530: PUSH
110531: LD_VAR 0 2
110535: PUSH
110536: FOR_IN
110537: IFFALSE 110626
// begin if not IsInArea ( i , mc_parking [ base ] ) then
110539: LD_VAR 0 4
110543: PPUSH
110544: LD_EXP 93
110548: PUSH
110549: LD_VAR 0 1
110553: ARRAY
110554: PPUSH
110555: CALL_OW 308
110559: NOT
110560: IFFALSE 110584
// ComMoveToArea ( i , mc_parking [ base ] ) else
110562: LD_VAR 0 4
110566: PPUSH
110567: LD_EXP 93
110571: PUSH
110572: LD_VAR 0 1
110576: ARRAY
110577: PPUSH
110578: CALL_OW 113
110582: GO 110624
// if GetControl ( i ) = control_manual then
110584: LD_VAR 0 4
110588: PPUSH
110589: CALL_OW 263
110593: PUSH
110594: LD_INT 1
110596: EQUAL
110597: IFFALSE 110624
// if IsDrivenBy ( i ) then
110599: LD_VAR 0 4
110603: PPUSH
110604: CALL_OW 311
110608: IFFALSE 110624
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
110610: LD_VAR 0 4
110614: PPUSH
110615: CALL_OW 311
110619: PPUSH
110620: CALL_OW 121
// end ;
110624: GO 110536
110626: POP
110627: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
110628: LD_VAR 0 2
110632: PPUSH
110633: LD_INT 95
110635: PUSH
110636: LD_EXP 93
110640: PUSH
110641: LD_VAR 0 1
110645: ARRAY
110646: PUSH
110647: EMPTY
110648: LIST
110649: LIST
110650: PPUSH
110651: CALL_OW 72
110655: PUSH
110656: LD_VAR 0 2
110660: EQUAL
110661: PUSH
110662: LD_EXP 92
110666: PUSH
110667: LD_VAR 0 1
110671: ARRAY
110672: OR
110673: PUSH
110674: LD_EXP 69
110678: PUSH
110679: LD_VAR 0 1
110683: ARRAY
110684: NOT
110685: OR
110686: IFFALSE 110456
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
110688: LD_ADDR_EXP 91
110692: PUSH
110693: LD_EXP 91
110697: PPUSH
110698: LD_VAR 0 1
110702: PPUSH
110703: LD_VAR 0 2
110707: PPUSH
110708: LD_INT 21
110710: PUSH
110711: LD_INT 2
110713: PUSH
110714: EMPTY
110715: LIST
110716: LIST
110717: PPUSH
110718: CALL_OW 72
110722: PPUSH
110723: CALL_OW 1
110727: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
110728: LD_VAR 0 1
110732: PPUSH
110733: LD_INT 19
110735: PPUSH
110736: CALL 58015 0 2
// MC_Reset ( base , 20 ) ;
110740: LD_VAR 0 1
110744: PPUSH
110745: LD_INT 20
110747: PPUSH
110748: CALL 58015 0 2
// end ; end_of_file
110752: LD_VAR 0 3
110756: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
110757: LD_VAR 0 1
110761: PUSH
110762: LD_INT 200
110764: DOUBLE
110765: GREATEREQUAL
110766: IFFALSE 110774
110768: LD_INT 299
110770: DOUBLE
110771: LESSEQUAL
110772: IFTRUE 110776
110774: GO 110808
110776: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
110777: LD_VAR 0 1
110781: PPUSH
110782: LD_VAR 0 2
110786: PPUSH
110787: LD_VAR 0 3
110791: PPUSH
110792: LD_VAR 0 4
110796: PPUSH
110797: LD_VAR 0 5
110801: PPUSH
110802: CALL 99194 0 5
110806: GO 110885
110808: LD_INT 300
110810: DOUBLE
110811: GREATEREQUAL
110812: IFFALSE 110820
110814: LD_INT 399
110816: DOUBLE
110817: LESSEQUAL
110818: IFTRUE 110822
110820: GO 110884
110822: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
110823: LD_VAR 0 1
110827: PPUSH
110828: LD_VAR 0 2
110832: PPUSH
110833: LD_VAR 0 3
110837: PPUSH
110838: LD_VAR 0 4
110842: PPUSH
110843: LD_VAR 0 5
110847: PPUSH
110848: LD_VAR 0 6
110852: PPUSH
110853: LD_VAR 0 7
110857: PPUSH
110858: LD_VAR 0 8
110862: PPUSH
110863: LD_VAR 0 9
110867: PPUSH
110868: LD_VAR 0 10
110872: PPUSH
110873: LD_VAR 0 11
110877: PPUSH
110878: CALL 96836 0 11
110882: GO 110885
110884: POP
// end ;
110885: PPOPN 11
110887: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
110888: LD_VAR 0 1
110892: PPUSH
110893: LD_VAR 0 2
110897: PPUSH
110898: LD_VAR 0 3
110902: PPUSH
110903: LD_VAR 0 4
110907: PPUSH
110908: LD_VAR 0 5
110912: PPUSH
110913: CALL 98930 0 5
// end ; end_of_file
110917: PPOPN 5
110919: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
110920: LD_VAR 0 1
110924: PPUSH
110925: LD_VAR 0 2
110929: PPUSH
110930: LD_VAR 0 3
110934: PPUSH
110935: LD_VAR 0 4
110939: PPUSH
110940: LD_VAR 0 5
110944: PPUSH
110945: LD_VAR 0 6
110949: PPUSH
110950: CALL 84529 0 6
// end ;
110954: PPOPN 6
110956: END
