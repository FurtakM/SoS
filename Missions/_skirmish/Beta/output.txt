// export MissionStart ; export southAreaBlocker ; starting begin southAreaBlocker = true ;
   0: LD_ADDR_EXP 2
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// ResetFog ;
   8: CALL_OW 335
// AnimateTrees ( true ) ;
  12: LD_INT 1
  14: PPUSH
  15: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  19: LD_INT 1
  21: PPUSH
  22: LD_INT 8
  24: PPUSH
  25: CALL_OW 332
// GameType ;
  29: CALL 5444 0 0
// SetBName ( BetaA , beta ) ;
  33: LD_INT 1
  35: PPUSH
  36: LD_STRING beta
  38: PPUSH
  39: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  43: LD_INT 3
  45: PPUSH
  46: LD_STRING beta
  48: PPUSH
  49: CALL_OW 500
// SetResourceType ( GetBase ( BetaA ) , mat_cans , startCrates [ 1 ] ) ;
  53: LD_INT 1
  55: PPUSH
  56: CALL_OW 274
  60: PPUSH
  61: LD_INT 1
  63: PPUSH
  64: LD_EXP 43
  68: PUSH
  69: LD_INT 1
  71: ARRAY
  72: PPUSH
  73: CALL_OW 277
// SetResourceType ( GetBase ( BetaB ) , mat_cans , startCrates [ 2 ] ) ;
  77: LD_INT 3
  79: PPUSH
  80: CALL_OW 274
  84: PPUSH
  85: LD_INT 1
  87: PPUSH
  88: LD_EXP 43
  92: PUSH
  93: LD_INT 2
  95: ARRAY
  96: PPUSH
  97: CALL_OW 277
// PrepareHeroes ;
 101: CALL 2607 0 0
// PrepareBeta ;
 105: CALL 2996 0 0
// HideArea ( 1 , SouthArea ) ;
 109: LD_INT 1
 111: PPUSH
 112: LD_INT 16
 114: PPUSH
 115: CALL_OW 333
// InGameOn ;
 119: CALL_OW 8
// ComHold ( Brighton ) ;
 123: LD_EXP 9
 127: PPUSH
 128: CALL_OW 140
// CenterNowOnUnits ( Brighton ) ;
 132: LD_EXP 9
 136: PPUSH
 137: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
 141: LD_EXP 11
 145: PPUSH
 146: LD_INT 50
 148: PPUSH
 149: LD_INT 42
 151: PPUSH
 152: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
 156: LD_INT 35
 158: PPUSH
 159: CALL_OW 67
 163: LD_EXP 11
 167: PPUSH
 168: LD_EXP 9
 172: PPUSH
 173: CALL_OW 296
 177: PUSH
 178: LD_INT 3
 180: LESS
 181: IFFALSE 156
// ComTurnUnit ( Megan , Brighton ) ;
 183: LD_EXP 11
 187: PPUSH
 188: LD_EXP 9
 192: PPUSH
 193: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 197: LD_EXP 11
 201: PPUSH
 202: LD_STRING DMegan-1a
 204: PPUSH
 205: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 209: LD_INT 10
 211: PPUSH
 212: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 216: LD_EXP 9
 220: PPUSH
 221: LD_EXP 11
 225: PPUSH
 226: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 230: LD_EXP 9
 234: PPUSH
 235: LD_STRING DBrighton-1a
 237: PPUSH
 238: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 242: LD_EXP 11
 246: PPUSH
 247: LD_STRING DMegan-2a
 249: PPUSH
 250: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 254: LD_EXP 9
 258: PPUSH
 259: LD_STRING DBrighton-2a
 261: PPUSH
 262: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 266: LD_EXP 11
 270: PPUSH
 271: LD_INT 40
 273: PPUSH
 274: LD_INT 37
 276: PPUSH
 277: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 281: LD_EXP 11
 285: PPUSH
 286: LD_EXP 9
 290: PPUSH
 291: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 295: LD_EXP 10
 299: PPUSH
 300: LD_INT 50
 302: PPUSH
 303: LD_INT 42
 305: PPUSH
 306: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 310: LD_INT 35
 312: PPUSH
 313: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 317: LD_EXP 9
 321: PPUSH
 322: LD_EXP 10
 326: PPUSH
 327: CALL_OW 296
 331: PUSH
 332: LD_INT 6
 334: LESS
 335: IFFALSE 310
// ComTurnUnit ( Brighton , Palmer ) ;
 337: LD_EXP 9
 341: PPUSH
 342: LD_EXP 10
 346: PPUSH
 347: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 351: LD_EXP 10
 355: PPUSH
 356: LD_EXP 9
 360: PPUSH
 361: CALL_OW 119
// Say ( Palmer , DPalmer-1 ) ;
 365: LD_EXP 10
 369: PPUSH
 370: LD_STRING DPalmer-1
 372: PPUSH
 373: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 377: LD_EXP 9
 381: PPUSH
 382: LD_STRING DBrighton-1
 384: PPUSH
 385: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 389: LD_EXP 10
 393: PPUSH
 394: LD_STRING DPalmer-2
 396: PPUSH
 397: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 401: LD_EXP 9
 405: PPUSH
 406: LD_STRING DBrighton-2
 408: PPUSH
 409: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 413: LD_EXP 10
 417: PPUSH
 418: LD_STRING DPalmer-3
 420: PPUSH
 421: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 425: LD_EXP 9
 429: PPUSH
 430: LD_STRING DBrighton-3
 432: PPUSH
 433: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 437: LD_EXP 10
 441: PPUSH
 442: LD_STRING DPalmer-4
 444: PPUSH
 445: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 449: LD_EXP 10
 453: PPUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 461: LD_INT 35
 463: PPUSH
 464: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 468: LD_EXP 10
 472: PPUSH
 473: CALL_OW 310
 477: PUSH
 478: LD_INT 6
 480: EQUAL
 481: IFFALSE 461
// SayRadio ( Palmer , DPalmer-5 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_STRING DPalmer-5
 490: PPUSH
 491: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 495: LD_EXP 9
 499: PPUSH
 500: LD_INT 59
 502: PPUSH
 503: LD_INT 36
 505: PPUSH
 506: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 510: LD_EXP 11
 514: PPUSH
 515: LD_INT 60
 517: PPUSH
 518: LD_INT 35
 520: PPUSH
 521: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 525: LD_EXP 10
 529: PPUSH
 530: LD_INT 60
 532: PPUSH
 533: LD_INT 34
 535: PPUSH
 536: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 540: LD_EXP 9
 544: PPUSH
 545: LD_INT 99
 547: PPUSH
 548: LD_INT 37
 550: PPUSH
 551: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 555: LD_EXP 11
 559: PPUSH
 560: LD_EXP 9
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 569: LD_EXP 10
 573: PPUSH
 574: LD_EXP 9
 578: PPUSH
 579: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 583: LD_INT 64
 585: PPUSH
 586: LD_INT 40
 588: PPUSH
 589: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 593: LD_EXP 12
 597: PPUSH
 598: LD_INT 13
 600: PPUSH
 601: CALL 12715 0 2
// wait ( 0 0$30 ) ;
 605: LD_INT 1050
 607: PPUSH
 608: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 612: LD_EXP 9
 616: PPUSH
 617: LD_STRING DBrighton-4
 619: PPUSH
 620: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 624: LD_EXP 9
 628: PPUSH
 629: LD_STRING DBrighton-5
 631: PPUSH
 632: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 636: LD_EXP 9
 640: PPUSH
 641: LD_EXP 11
 645: PPUSH
 646: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 650: LD_EXP 9
 654: PPUSH
 655: LD_STRING DBrighton-6
 657: PPUSH
 658: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 662: LD_EXP 11
 666: PPUSH
 667: LD_STRING DMegan-1
 669: PPUSH
 670: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 674: LD_EXP 9
 678: PPUSH
 679: LD_STRING DBrighton-7
 681: PPUSH
 682: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 686: LD_EXP 9
 690: PPUSH
 691: LD_INT 99
 693: PPUSH
 694: LD_INT 37
 696: PPUSH
 697: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 701: LD_EXP 9
 705: PPUSH
 706: LD_STRING DBrighton-8
 708: PPUSH
 709: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 713: LD_STRING C1
 715: PPUSH
 716: CALL_OW 337
// InGameOff ;
 720: CALL_OW 9
// SaveForQuickRestart ;
 724: CALL_OW 22
// MissionStart := true ;
 728: LD_ADDR_EXP 1
 732: PUSH
 733: LD_INT 1
 735: ST_TO_ADDR
// PrepareRUBase_v2 ;
 736: CALL 4719 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 740: LD_ADDR_EXP 69
 744: PUSH
 745: LD_EXP 69
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: PPUSH
 763: CALL_OW 69
 767: PPUSH
 768: CALL_OW 1
 772: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 773: LD_ADDR_EXP 69
 777: PUSH
 778: LD_EXP 69
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: LD_EXP 36
 790: PPUSH
 791: CALL_OW 1
 795: ST_TO_ADDR
// MC_Start ( ) ;
 796: CALL 55490 0 0
// music_nat := 1 ;
 800: LD_ADDR_OWVAR 71
 804: PUSH
 805: LD_INT 1
 807: ST_TO_ADDR
// end ;
 808: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var i , tmp ;
 809: LD_EXP 1
 813: IFFALSE 1237
 815: GO 817
 817: DISABLE
 818: LD_INT 0
 820: PPUSH
 821: PPUSH
// begin wait ( ruArrival ) ;
 822: LD_EXP 42
 826: PPUSH
 827: CALL_OW 67
// PrepareRUArmada ;
 831: CALL 3578 0 0
// wait ( 0 0$3 ) ;
 835: LD_INT 105
 837: PPUSH
 838: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 842: LD_ADDR_VAR 0 2
 846: PUSH
 847: LD_INT 15
 849: PPUSH
 850: LD_INT 0
 852: PPUSH
 853: CALL_OW 517
 857: ST_TO_ADDR
// for i = 1 to RUArmada do
 858: LD_ADDR_VAR 0 1
 862: PUSH
 863: DOUBLE
 864: LD_INT 1
 866: DEC
 867: ST_TO_ADDR
 868: LD_EXP 17
 872: PUSH
 873: FOR_TO
 874: IFFALSE 923
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 876: LD_EXP 17
 880: PUSH
 881: LD_VAR 0 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 1
 894: ARRAY
 895: PUSH
 896: LD_VAR 0 1
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 2
 909: ARRAY
 910: PUSH
 911: LD_VAR 0 1
 915: ARRAY
 916: PPUSH
 917: CALL_OW 111
 921: GO 873
 923: POP
 924: POP
// ArmadaArrived := true ;
 925: LD_ADDR_EXP 3
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 933: LD_EXP 10
 937: PPUSH
 938: LD_STRING DPalmer-A1
 940: PPUSH
 941: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 945: LD_EXP 9
 949: PPUSH
 950: LD_STRING DBrighton-A1
 952: PPUSH
 953: CALL_OW 88
// wait ( 0 0$20 ) ;
 957: LD_INT 700
 959: PPUSH
 960: CALL_OW 67
// PrepareRUBase ;
 964: CALL 4303 0 0
// wait ( 1 1$20 ) ;
 968: LD_INT 2800
 970: PPUSH
 971: CALL_OW 67
// PrepareRUBulldozers ;
 975: CALL 4190 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 979: LD_EXP 18
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: LD_INT 9
 990: PPUSH
 991: CALL 12572 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 995: LD_EXP 18
 999: PUSH
1000: LD_INT 2
1002: ARRAY
1003: PPUSH
1004: LD_INT 11
1006: PPUSH
1007: CALL 12572 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
1011: LD_INT 1
1013: PPUSH
1014: LD_EXP 18
1018: PUSH
1019: LD_INT 1
1021: ARRAY
1022: PPUSH
1023: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1027: LD_INT 1
1029: PPUSH
1030: LD_EXP 18
1034: PUSH
1035: LD_INT 2
1037: ARRAY
1038: PPUSH
1039: CALL_OW 471
// wait ( 1 1$20 ) ;
1043: LD_INT 2800
1045: PPUSH
1046: CALL_OW 67
// ComMoveXY ( Bulldozers , 64 , 114 ) ;
1050: LD_EXP 18
1054: PPUSH
1055: LD_INT 64
1057: PPUSH
1058: LD_INT 114
1060: PPUSH
1061: CALL_OW 111
// wait ( 0 0$10 ) ;
1065: LD_INT 350
1067: PPUSH
1068: CALL_OW 67
// for i := 1 to 2 do
1072: LD_ADDR_VAR 0 1
1076: PUSH
1077: DOUBLE
1078: LD_INT 1
1080: DEC
1081: ST_TO_ADDR
1082: LD_INT 2
1084: PUSH
1085: FOR_TO
1086: IFFALSE 1105
// RemoveUnit ( Bulldozers [ i ] ) ;
1088: LD_EXP 18
1092: PUSH
1093: LD_VAR 0 1
1097: ARRAY
1098: PPUSH
1099: CALL_OW 64
1103: GO 1085
1105: POP
1106: POP
// RemoveEnvironmentArea ( BulldozerArea ) ;
1107: LD_INT 9
1109: PPUSH
1110: CALL_OW 355
// RemoveEnvironmentArea ( BulldozerArea2 ) ;
1114: LD_INT 11
1116: PPUSH
1117: CALL_OW 355
// SayEffect ( DRuSol-A1 ) ;
1121: LD_STRING DRuSol-A1
1123: PPUSH
1124: CALL_OW 96
// AssaultStarted := true ;
1128: LD_ADDR_EXP 8
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// wait ( 0 0$2 ) ;
1136: LD_INT 70
1138: PPUSH
1139: CALL_OW 67
// Say ( Yashin , DDeath-Yas-1 ) ;
1143: LD_EXP 13
1147: PPUSH
1148: LD_STRING DDeath-Yas-1
1150: PPUSH
1151: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-2 ) ;
1155: LD_EXP 15
1159: PPUSH
1160: LD_STRING DDeath-Gay-2
1162: PPUSH
1163: CALL_OW 88
// wait ( 0 0$2 ) ;
1167: LD_INT 70
1169: PPUSH
1170: CALL_OW 67
// Say ( Popov , DDeath-Pop-1 ) ;
1174: LD_EXP 14
1178: PPUSH
1179: LD_STRING DDeath-Pop-1
1181: PPUSH
1182: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1186: LD_EXP 15
1190: PPUSH
1191: LD_STRING DDeath-Gay-1
1193: PPUSH
1194: CALL_OW 88
// wait ( 0 0$5 ) ;
1198: LD_INT 175
1200: PPUSH
1201: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1205: LD_EXP 16
1209: PPUSH
1210: LD_STRING DDeath-Vse-1
1212: PPUSH
1213: CALL_OW 88
// Say ( Popov , DDeath-Pop-2 ) ;
1217: LD_EXP 14
1221: PPUSH
1222: LD_STRING DDeath-Pop-2
1224: PPUSH
1225: CALL_OW 88
// southAreaBlocker = false ;
1229: LD_ADDR_EXP 2
1233: PUSH
1234: LD_INT 0
1236: ST_TO_ADDR
// end ;
1237: PPOPN 2
1239: END
// every 0 0$1 trigger AssaultStarted do var i , tmp ;
1240: LD_EXP 8
1244: IFFALSE 1835
1246: GO 1248
1248: DISABLE
1249: LD_INT 0
1251: PPUSH
1252: PPUSH
// begin PriorityAttack ( 6 , BetaA ) ;
1253: LD_INT 6
1255: PPUSH
1256: LD_INT 1
1258: PPUSH
1259: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1263: LD_INT 6
1265: PPUSH
1266: LD_INT 3
1268: PPUSH
1269: CALL_OW 470
// repeat for i in RuArmada do
1273: LD_ADDR_VAR 0 1
1277: PUSH
1278: LD_EXP 17
1282: PUSH
1283: FOR_IN
1284: IFFALSE 1487
// begin if GetDistUnitXY ( i , 87 , 77 ) < 10 and not GetTag ( i ) then
1286: LD_VAR 0 1
1290: PPUSH
1291: LD_INT 87
1293: PPUSH
1294: LD_INT 77
1296: PPUSH
1297: CALL_OW 297
1301: PUSH
1302: LD_INT 10
1304: LESS
1305: PUSH
1306: LD_VAR 0 1
1310: PPUSH
1311: CALL_OW 110
1315: NOT
1316: AND
1317: IFFALSE 1331
// SetTag ( i , 1 ) ;
1319: LD_VAR 0 1
1323: PPUSH
1324: LD_INT 1
1326: PPUSH
1327: CALL_OW 109
// if GetDistUnitXY ( i , 62 , 48 ) < 10 and GetTag ( i ) < 2 then
1331: LD_VAR 0 1
1335: PPUSH
1336: LD_INT 62
1338: PPUSH
1339: LD_INT 48
1341: PPUSH
1342: CALL_OW 297
1346: PUSH
1347: LD_INT 10
1349: LESS
1350: PUSH
1351: LD_VAR 0 1
1355: PPUSH
1356: CALL_OW 110
1360: PUSH
1361: LD_INT 2
1363: LESS
1364: AND
1365: IFFALSE 1379
// SetTag ( i , 2 ) ;
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_INT 2
1374: PPUSH
1375: CALL_OW 109
// if not GetTag ( i ) then
1379: LD_VAR 0 1
1383: PPUSH
1384: CALL_OW 110
1388: NOT
1389: IFFALSE 1406
// ComAgressiveMove ( i , 87 , 77 ) ;
1391: LD_VAR 0 1
1395: PPUSH
1396: LD_INT 87
1398: PPUSH
1399: LD_INT 77
1401: PPUSH
1402: CALL_OW 114
// if GetTag ( i ) = 1 then
1406: LD_VAR 0 1
1410: PPUSH
1411: CALL_OW 110
1415: PUSH
1416: LD_INT 1
1418: EQUAL
1419: IFFALSE 1436
// ComAgressiveMove ( i , 62 , 48 ) ;
1421: LD_VAR 0 1
1425: PPUSH
1426: LD_INT 62
1428: PPUSH
1429: LD_INT 48
1431: PPUSH
1432: CALL_OW 114
// if GetTag ( i ) = 2 then
1436: LD_VAR 0 1
1440: PPUSH
1441: CALL_OW 110
1445: PUSH
1446: LD_INT 2
1448: EQUAL
1449: IFFALSE 1485
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1451: LD_VAR 0 1
1455: PPUSH
1456: LD_INT 22
1458: PUSH
1459: LD_INT 1
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PPUSH
1466: CALL_OW 69
1470: PPUSH
1471: LD_VAR 0 1
1475: PPUSH
1476: CALL_OW 74
1480: PPUSH
1481: CALL_OW 115
// end ;
1485: GO 1283
1487: POP
1488: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1489: LD_INT 35
1491: PPUSH
1492: CALL_OW 67
1496: LD_INT 1
1498: PUSH
1499: LD_INT 22
1501: PUSH
1502: LD_INT 6
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: PUSH
1509: LD_INT 21
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: EMPTY
1516: LIST
1517: LIST
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PPUSH
1524: CALL_OW 69
1528: PUSH
1529: LD_INT 10
1531: LESS
1532: PUSH
1533: LD_EXP 13
1537: PPUSH
1538: CALL_OW 301
1542: AND
1543: PUSH
1544: LD_EXP 14
1548: PPUSH
1549: CALL_OW 301
1553: AND
1554: PUSH
1555: LD_EXP 15
1559: PPUSH
1560: CALL_OW 301
1564: AND
1565: PUSH
1566: LD_EXP 16
1570: PPUSH
1571: CALL_OW 301
1575: AND
1576: IFFALSE 1273
// AssaultStarted := false ;
1578: LD_ADDR_EXP 8
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 6 ] ) , RUArrivalArea ) ;
1586: LD_INT 22
1588: PUSH
1589: LD_INT 6
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PPUSH
1596: CALL_OW 69
1600: PPUSH
1601: LD_INT 5
1603: PPUSH
1604: CALL_OW 113
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1608: LD_ADDR_EXP 5
1612: PUSH
1613: LD_INT 1
1615: PUSH
1616: LD_INT 22
1618: PUSH
1619: LD_INT 6
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: LD_INT 26
1628: PUSH
1629: LD_INT 1
1631: PUSH
1632: EMPTY
1633: LIST
1634: LIST
1635: PUSH
1636: LD_INT 21
1638: PUSH
1639: LD_INT 1
1641: PUSH
1642: EMPTY
1643: LIST
1644: LIST
1645: PUSH
1646: LD_INT 24
1648: PUSH
1649: LD_INT 500
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: PPUSH
1663: CALL_OW 69
1667: ST_TO_ADDR
// if RuSpeaker then
1668: LD_EXP 5
1672: IFFALSE 1690
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1674: LD_EXP 5
1678: PUSH
1679: LD_INT 1
1681: ARRAY
1682: PPUSH
1683: LD_STRING DRuSol-A2
1685: PPUSH
1686: CALL_OW 88
// wait ( 0 0$30 ) ;
1690: LD_INT 1050
1692: PPUSH
1693: CALL_OW 67
// DialogueOn ;
1697: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1701: LD_EXP 9
1705: PPUSH
1706: LD_STRING DBrighton-B1
1708: PPUSH
1709: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1713: LD_EXP 10
1717: PPUSH
1718: LD_STRING DPalmer-B1
1720: PPUSH
1721: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1725: LD_EXP 9
1729: PPUSH
1730: LD_STRING DBrighton-B2
1732: PPUSH
1733: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1737: LD_EXP 19
1741: PPUSH
1742: LD_STRING DBurlak-B1
1744: PPUSH
1745: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1749: LD_EXP 9
1753: PPUSH
1754: LD_STRING DBrighton-B3
1756: PPUSH
1757: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1761: LD_EXP 10
1765: PPUSH
1766: LD_STRING DPalmer-B2
1768: PPUSH
1769: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1773: LD_EXP 9
1777: PPUSH
1778: LD_STRING DBrighton-B4
1780: PPUSH
1781: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1785: LD_EXP 9
1789: PPUSH
1790: LD_STRING DBrighton-B5
1792: PPUSH
1793: CALL_OW 88
// DialogueOff ;
1797: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1801: LD_STRING C2
1803: PPUSH
1804: CALL_OW 337
// FirstAssaultRepelled := true ;
1808: LD_ADDR_EXP 4
1812: PUSH
1813: LD_INT 1
1815: ST_TO_ADDR
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1816: LD_INT 22
1818: PUSH
1819: LD_INT 6
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 69
1830: PPUSH
1831: CALL_OW 181
// end ;
1835: PPOPN 2
1837: END
// every 0 0$1 trigger FirstAssaultRepelled do var unit , insideUnit ;
1838: LD_EXP 4
1842: IFFALSE 2007
1844: GO 1846
1846: DISABLE
1847: LD_INT 0
1849: PPUSH
1850: PPUSH
// begin enable ;
1851: ENABLE
// if FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) = 0 then
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 22
1857: PUSH
1858: LD_INT 6
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: PPUSH
1868: CALL_OW 70
1872: PUSH
1873: LD_INT 0
1875: EQUAL
1876: IFFALSE 1880
// exit ;
1878: GO 2007
// for unit in FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) do
1880: LD_ADDR_VAR 0 1
1884: PUSH
1885: LD_INT 5
1887: PPUSH
1888: LD_INT 22
1890: PUSH
1891: LD_INT 6
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: PUSH
1898: EMPTY
1899: LIST
1900: PPUSH
1901: CALL_OW 70
1905: PUSH
1906: FOR_IN
1907: IFFALSE 2005
// begin SetSide ( unit , 3 ) ;
1909: LD_VAR 0 1
1913: PPUSH
1914: LD_INT 3
1916: PPUSH
1917: CALL_OW 235
// if ( GetType ( unit ) = unit_vehicle ) then
1921: LD_VAR 0 1
1925: PPUSH
1926: CALL_OW 247
1930: PUSH
1931: LD_INT 2
1933: EQUAL
1934: IFFALSE 1970
// for insideUnit in UnitsInside ( unit ) do
1936: LD_ADDR_VAR 0 2
1940: PUSH
1941: LD_VAR 0 1
1945: PPUSH
1946: CALL_OW 313
1950: PUSH
1951: FOR_IN
1952: IFFALSE 1968
// SetSide ( insideUnit , 3 ) ;
1954: LD_VAR 0 2
1958: PPUSH
1959: LD_INT 3
1961: PPUSH
1962: CALL_OW 235
1966: GO 1951
1968: POP
1969: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
1970: LD_ADDR_EXP 69
1974: PUSH
1975: LD_EXP 69
1979: PPUSH
1980: LD_INT 1
1982: PPUSH
1983: LD_INT 22
1985: PUSH
1986: LD_INT 3
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: PPUSH
1993: CALL_OW 69
1997: PPUSH
1998: CALL_OW 1
2002: ST_TO_ADDR
// end ;
2003: GO 1906
2005: POP
2006: POP
// end ;
2007: PPOPN 2
2009: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
2010: LD_EXP 4
2014: PUSH
2015: LD_EXP 41
2019: PUSH
2020: LD_INT 0
2022: GREATER
2023: AND
2024: IFFALSE 2044
2026: GO 2028
2028: DISABLE
// begin enable ;
2029: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
2030: LD_ADDR_EXP 41
2034: PUSH
2035: LD_EXP 41
2039: PUSH
2040: LD_INT 35
2042: MINUS
2043: ST_TO_ADDR
// end ;
2044: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
2045: LD_EXP 41
2049: PUSH
2050: LD_INT 0
2052: EQUAL
2053: IFFALSE 2159
2055: GO 2057
2057: DISABLE
// begin JMMReinforcement ;
2058: CALL 5047 0 0
// DialogueOn ;
2062: CALL_OW 6
// CenterOnUnits ( JMM ) ;
2066: LD_EXP 37
2070: PPUSH
2071: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
2075: LD_EXP 37
2079: PPUSH
2080: LD_STRING DJMM-F1
2082: PPUSH
2083: CALL_OW 88
// if RussiansDefeated then
2087: LD_EXP 44
2091: IFFALSE 2117
// begin AddMedal ( Russians , 1 ) ;
2093: LD_STRING Russians
2095: PPUSH
2096: LD_INT 1
2098: PPUSH
2099: CALL_OW 101
// Say ( Brighton , DBrighton-F1a ) ;
2103: LD_EXP 9
2107: PPUSH
2108: LD_STRING DBrighton-F1a
2110: PPUSH
2111: CALL_OW 88
// end else
2115: GO 2147
// begin AddMedal ( Russians , - 1 ) ;
2117: LD_STRING Russians
2119: PPUSH
2120: LD_INT 1
2122: NEG
2123: PPUSH
2124: CALL_OW 101
// Say ( Brighton , DBrighton-F1 ) ;
2128: LD_EXP 9
2132: PPUSH
2133: LD_STRING DBrighton-F1
2135: PPUSH
2136: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2140: LD_STRING C3
2142: PPUSH
2143: CALL_OW 337
// end ; DialogueOff ;
2147: CALL_OW 7
// JMM_Arrived := true ;
2151: LD_ADDR_EXP 6
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// end ;
2159: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2160: LD_EXP 6
2164: PUSH
2165: LD_INT 1
2167: PPUSH
2168: LD_EXP 19
2172: PPUSH
2173: CALL_OW 292
2177: AND
2178: IFFALSE 2207
2180: GO 2182
2182: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2183: LD_EXP 19
2187: PPUSH
2188: LD_STRING DBurlak
2190: PPUSH
2191: CALL_OW 88
// Say ( JMM , DJMM ) ;
2195: LD_EXP 37
2199: PPUSH
2200: LD_STRING DJMM
2202: PPUSH
2203: CALL_OW 88
// end ;
2207: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2208: LD_INT 1
2210: PUSH
2211: LD_INT 22
2213: PUSH
2214: LD_INT 1
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PUSH
2221: LD_INT 2
2223: PUSH
2224: LD_INT 34
2226: PUSH
2227: LD_INT 9
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: PUSH
2234: LD_INT 35
2236: PUSH
2237: LD_INT 9
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: PUSH
2259: LD_INT 1
2261: GREATER
2262: IFFALSE 2275
2264: GO 2266
2266: DISABLE
// LaserBuilt := true ;
2267: LD_ADDR_EXP 7
2271: PUSH
2272: LD_INT 1
2274: ST_TO_ADDR
2275: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2276: LD_EXP 8
2280: PUSH
2281: LD_INT 6
2283: PPUSH
2284: LD_INT 1
2286: PUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: LD_INT 35
2299: PUSH
2300: LD_INT 9
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PUSH
2307: EMPTY
2308: LIST
2309: LIST
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PPUSH
2320: LD_EXP 16
2324: PPUSH
2325: CALL_OW 310
2329: PPUSH
2330: CALL_OW 74
2334: PPUSH
2335: CALL_OW 292
2339: AND
2340: IFFALSE 2369
2342: GO 2344
2344: DISABLE
// begin Say ( Sevi , DDeath-Vse-2 ) ;
2345: LD_EXP 16
2349: PPUSH
2350: LD_STRING DDeath-Vse-2
2352: PPUSH
2353: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2357: LD_EXP 13
2361: PPUSH
2362: LD_STRING DDeath-Yas-2
2364: PPUSH
2365: CALL_OW 88
// end ;
2369: END
// every 0 0$1 trigger MissionStart and GetResourceArea ( CratesArea , mat_cans ) < 20 do
2370: LD_EXP 1
2374: PUSH
2375: LD_INT 12
2377: PPUSH
2378: LD_INT 1
2380: PPUSH
2381: CALL_OW 287
2385: PUSH
2386: LD_INT 20
2388: LESS
2389: AND
2390: IFFALSE 2432
2392: GO 2394
2394: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2395: LD_INT 1750
2397: PPUSH
2398: LD_INT 4900
2400: PPUSH
2401: CALL_OW 12
2405: PPUSH
2406: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2410: LD_INT 2
2412: PPUSH
2413: LD_INT 5
2415: PPUSH
2416: CALL_OW 12
2420: PPUSH
2421: LD_INT 12
2423: PPUSH
2424: LD_INT 1
2426: PPUSH
2427: CALL_OW 55
// enable ;
2431: ENABLE
// end ;
2432: END
// every 0 0$1 trigger FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) do var un , x , y ;
2433: LD_INT 17
2435: PPUSH
2436: LD_INT 81
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PPUSH
2446: CALL_OW 70
2450: IFFALSE 2576
2452: GO 2454
2454: DISABLE
2455: LD_INT 0
2457: PPUSH
2458: PPUSH
2459: PPUSH
// begin un := FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) [ 1 ] ;
2460: LD_ADDR_VAR 0 1
2464: PUSH
2465: LD_INT 17
2467: PPUSH
2468: LD_INT 81
2470: PUSH
2471: LD_INT 1
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: PPUSH
2478: CALL_OW 70
2482: PUSH
2483: LD_INT 1
2485: ARRAY
2486: ST_TO_ADDR
// x := GetX ( un ) ;
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: LD_VAR 0 1
2496: PPUSH
2497: CALL_OW 250
2501: ST_TO_ADDR
// y := GetY ( un ) ;
2502: LD_ADDR_VAR 0 3
2506: PUSH
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 251
2516: ST_TO_ADDR
// PlaceSeeing ( x , y , 1 , - 12 ) ;
2517: LD_VAR 0 2
2521: PPUSH
2522: LD_VAR 0 3
2526: PPUSH
2527: LD_INT 1
2529: PPUSH
2530: LD_INT 12
2532: NEG
2533: PPUSH
2534: CALL_OW 330
// CenterNowOnUnits ( un ) ;
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 87
// Say ( Brighton , DBrighton-E1 ) ;
2547: LD_EXP 9
2551: PPUSH
2552: LD_STRING DBrighton-E1
2554: PPUSH
2555: CALL_OW 88
// RemoveSeeing ( x , y , 1 ) ;
2559: LD_VAR 0 2
2563: PPUSH
2564: LD_VAR 0 3
2568: PPUSH
2569: LD_INT 1
2571: PPUSH
2572: CALL_OW 331
// end ;
2576: PPOPN 3
2578: END
// every 0 0$1 trigger MissionStart do
2579: LD_EXP 1
2583: IFFALSE 2606
2585: GO 2587
2587: DISABLE
// begin enable ;
2588: ENABLE
// display_Strings := [ #tick , tick ] ;
2589: LD_ADDR_OWVAR 47
2593: PUSH
2594: LD_STRING #tick
2596: PUSH
2597: LD_OWVAR 1
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: ST_TO_ADDR
// end ; end_of_file
2606: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2607: LD_INT 0
2609: PPUSH
// uc_side := 1 ;
2610: LD_ADDR_OWVAR 20
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// hc_class = class_soldier ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 1
2625: ST_TO_ADDR
// uc_nation := nation_american ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_sex = sex_male ;
2634: LD_ADDR_OWVAR 27
2638: PUSH
2639: LD_INT 1
2641: ST_TO_ADDR
// hc_importance = 110 ;
2642: LD_ADDR_OWVAR 32
2646: PUSH
2647: LD_INT 110
2649: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2650: LD_ADDR_OWVAR 30
2654: PUSH
2655: LD_INT 5
2657: PUSH
2658: LD_INT 4
2660: PUSH
2661: LD_INT 5
2663: PUSH
2664: LD_INT 3
2666: PUSH
2667: EMPTY
2668: LIST
2669: LIST
2670: LIST
2671: LIST
2672: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2673: LD_ADDR_OWVAR 31
2677: PUSH
2678: LD_INT 9
2680: PUSH
2681: LD_INT 6
2683: PUSH
2684: LD_INT 7
2686: PUSH
2687: LD_INT 6
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: LIST
2695: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2696: LD_ADDR_OWVAR 29
2700: PUSH
2701: LD_INT 12
2703: PUSH
2704: LD_INT 10
2706: PUSH
2707: EMPTY
2708: LIST
2709: LIST
2710: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING Gerard Brighton
2718: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2719: LD_ADDR_OWVAR 33
2723: PUSH
2724: LD_STRING Beta_Skirmish
2726: ST_TO_ADDR
// hc_face_number := 1 ;
2727: LD_ADDR_OWVAR 34
2731: PUSH
2732: LD_INT 1
2734: ST_TO_ADDR
// Brighton := CreateHuman ;
2735: LD_ADDR_EXP 9
2739: PUSH
2740: CALL_OW 44
2744: ST_TO_ADDR
// uc_nation := nation_american ;
2745: LD_ADDR_OWVAR 21
2749: PUSH
2750: LD_INT 1
2752: ST_TO_ADDR
// hc_importance = 80 ;
2753: LD_ADDR_OWVAR 32
2757: PUSH
2758: LD_INT 80
2760: ST_TO_ADDR
// hc_sex = sex_male ;
2761: LD_ADDR_OWVAR 27
2765: PUSH
2766: LD_INT 1
2768: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2769: LD_ADDR_OWVAR 30
2773: PUSH
2774: LD_INT 5
2776: PUSH
2777: LD_INT 5
2779: PUSH
2780: LD_INT 3
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: LIST
2790: LIST
2791: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2792: LD_ADDR_OWVAR 31
2796: PUSH
2797: LD_INT 7
2799: PUSH
2800: LD_INT 6
2802: PUSH
2803: LD_INT 5
2805: PUSH
2806: LD_INT 3
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2815: LD_ADDR_OWVAR 29
2819: PUSH
2820: LD_INT 10
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: ST_TO_ADDR
// hc_name := Brian Palmer ;
2830: LD_ADDR_OWVAR 26
2834: PUSH
2835: LD_STRING Brian Palmer
2837: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2838: LD_ADDR_OWVAR 33
2842: PUSH
2843: LD_STRING Beta_Skirmish
2845: ST_TO_ADDR
// hc_face_number := 3 ;
2846: LD_ADDR_OWVAR 34
2850: PUSH
2851: LD_INT 3
2853: ST_TO_ADDR
// Palmer := CreateHuman ;
2854: LD_ADDR_EXP 10
2858: PUSH
2859: CALL_OW 44
2863: ST_TO_ADDR
// hc_class = class_scientistic ;
2864: LD_ADDR_OWVAR 28
2868: PUSH
2869: LD_INT 4
2871: ST_TO_ADDR
// uc_nation := nation_american ;
2872: LD_ADDR_OWVAR 21
2876: PUSH
2877: LD_INT 1
2879: ST_TO_ADDR
// hc_importance = 70 ;
2880: LD_ADDR_OWVAR 32
2884: PUSH
2885: LD_INT 70
2887: ST_TO_ADDR
// hc_sex = sex_female ;
2888: LD_ADDR_OWVAR 27
2892: PUSH
2893: LD_INT 2
2895: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2896: LD_ADDR_OWVAR 30
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 2
2906: PUSH
2907: LD_INT 4
2909: PUSH
2910: LD_INT 6
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: LIST
2917: LIST
2918: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2919: LD_ADDR_OWVAR 31
2923: PUSH
2924: LD_INT 4
2926: PUSH
2927: LD_INT 2
2929: PUSH
2930: LD_INT 5
2932: PUSH
2933: LD_INT 8
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2942: LD_ADDR_OWVAR 29
2946: PUSH
2947: LD_INT 10
2949: PUSH
2950: LD_INT 10
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: ST_TO_ADDR
// hc_name := Megan Armitage ;
2957: LD_ADDR_OWVAR 26
2961: PUSH
2962: LD_STRING Megan Armitage
2964: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2965: LD_ADDR_OWVAR 33
2969: PUSH
2970: LD_STRING Beta_Skirmish
2972: ST_TO_ADDR
// hc_face_number := 4 ;
2973: LD_ADDR_OWVAR 34
2977: PUSH
2978: LD_INT 4
2980: ST_TO_ADDR
// Megan := CreateHuman ;
2981: LD_ADDR_EXP 11
2985: PUSH
2986: CALL_OW 44
2990: ST_TO_ADDR
// end ;
2991: LD_VAR 0 1
2995: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
2996: LD_INT 0
2998: PPUSH
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
// uc_side := 1 ;
3003: LD_ADDR_OWVAR 20
3007: PUSH
3008: LD_INT 1
3010: ST_TO_ADDR
// uc_nation := nation_american ;
3011: LD_ADDR_OWVAR 21
3015: PUSH
3016: LD_INT 1
3018: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
3019: LD_ADDR_VAR 0 2
3023: PUSH
3024: LD_INT 22
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 30
3036: PUSH
3037: LD_INT 32
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PPUSH
3048: CALL_OW 69
3052: PUSH
3053: FOR_IN
3054: IFFALSE 3109
// PlaceWeaponTurret ( i , [ us_light_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
3056: LD_VAR 0 2
3060: PPUSH
3061: LD_INT 3
3063: PUSH
3064: LD_INT 3
3066: PUSH
3067: LD_INT 4
3069: PUSH
3070: LD_INT 5
3072: PUSH
3073: LD_INT 11
3075: PUSH
3076: LD_INT 3
3078: PUSH
3079: LD_INT 4
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 1
3093: PPUSH
3094: LD_INT 7
3096: PPUSH
3097: CALL_OW 12
3101: ARRAY
3102: PPUSH
3103: CALL_OW 431
3107: GO 3053
3109: POP
3110: POP
// hc_name :=  ;
3111: LD_ADDR_OWVAR 26
3115: PUSH
3116: LD_STRING 
3118: ST_TO_ADDR
// hc_gallery :=  ;
3119: LD_ADDR_OWVAR 33
3123: PUSH
3124: LD_STRING 
3126: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
3127: LD_ADDR_VAR 0 2
3131: PUSH
3132: DOUBLE
3133: LD_INT 1
3135: DEC
3136: ST_TO_ADDR
3137: LD_INT 6
3139: PUSH
3140: LD_INT 5
3142: PUSH
3143: LD_INT 5
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_OWVAR 67
3155: ARRAY
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3216
// begin PrepareSoldier ( 1 , game_skill ) ;
3160: LD_INT 1
3162: PPUSH
3163: LD_EXP 39
3167: PPUSH
3168: CALL_OW 381
// un := CreateHuman ;
3172: LD_ADDR_VAR 0 4
3176: PUSH
3177: CALL_OW 44
3181: ST_TO_ADDR
// filter := filter ^ un ;
3182: LD_ADDR_VAR 0 3
3186: PUSH
3187: LD_VAR 0 3
3191: PUSH
3192: LD_VAR 0 4
3196: ADD
3197: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3198: LD_ADDR_VAR 0 5
3202: PUSH
3203: LD_VAR 0 5
3207: PUSH
3208: LD_VAR 0 4
3212: ADD
3213: ST_TO_ADDR
// end ;
3214: GO 3157
3216: POP
3217: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
3218: LD_ADDR_VAR 0 2
3222: PUSH
3223: DOUBLE
3224: LD_INT 1
3226: DEC
3227: ST_TO_ADDR
3228: LD_INT 3
3230: PUSH
3231: LD_INT 2
3233: PUSH
3234: LD_INT 2
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PUSH
3242: LD_OWVAR 67
3246: ARRAY
3247: PUSH
3248: FOR_TO
3249: IFFALSE 3303
// begin PrepareEngineer ( 0 , game_skill ) ;
3251: LD_INT 0
3253: PPUSH
3254: LD_EXP 39
3258: PPUSH
3259: CALL_OW 382
// un := CreateHuman ;
3263: LD_ADDR_VAR 0 4
3267: PUSH
3268: CALL_OW 44
3272: ST_TO_ADDR
// filter := filter ^ un ;
3273: LD_ADDR_VAR 0 3
3277: PUSH
3278: LD_VAR 0 3
3282: PUSH
3283: LD_VAR 0 4
3287: ADD
3288: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3289: LD_VAR 0 4
3293: PPUSH
3294: LD_INT 3
3296: PPUSH
3297: CALL_OW 52
// end ;
3301: GO 3248
3303: POP
3304: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3305: LD_ADDR_VAR 0 2
3309: PUSH
3310: DOUBLE
3311: LD_INT 1
3313: DEC
3314: ST_TO_ADDR
3315: LD_INT 4
3317: PUSH
3318: LD_INT 3
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: PUSH
3335: FOR_TO
3336: IFFALSE 3390
// begin PrepareMechanic ( 0 , game_skill ) ;
3338: LD_INT 0
3340: PPUSH
3341: LD_EXP 39
3345: PPUSH
3346: CALL_OW 383
// un := CreateHuman ;
3350: LD_ADDR_VAR 0 4
3354: PUSH
3355: CALL_OW 44
3359: ST_TO_ADDR
// filter := filter ^ un ;
3360: LD_ADDR_VAR 0 3
3364: PUSH
3365: LD_VAR 0 3
3369: PUSH
3370: LD_VAR 0 4
3374: ADD
3375: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3376: LD_VAR 0 4
3380: PPUSH
3381: LD_INT 8
3383: PPUSH
3384: CALL_OW 52
// end ;
3388: GO 3335
3390: POP
3391: POP
// for i = 1 to 2 do
3392: LD_ADDR_VAR 0 2
3396: PUSH
3397: DOUBLE
3398: LD_INT 1
3400: DEC
3401: ST_TO_ADDR
3402: LD_INT 2
3404: PUSH
3405: FOR_TO
3406: IFFALSE 3460
// begin PrepareScientist ( 0 , game_skill ) ;
3408: LD_INT 0
3410: PPUSH
3411: LD_EXP 39
3415: PPUSH
3416: CALL_OW 384
// un := CreateHuman ;
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: CALL_OW 44
3429: ST_TO_ADDR
// filter := filter ^ un ;
3430: LD_ADDR_VAR 0 3
3434: PUSH
3435: LD_VAR 0 3
3439: PUSH
3440: LD_VAR 0 4
3444: ADD
3445: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_INT 14
3453: PPUSH
3454: CALL_OW 52
// end ;
3458: GO 3405
3460: POP
3461: POP
// for i = 1 to soldiers do
3462: LD_ADDR_VAR 0 2
3466: PUSH
3467: DOUBLE
3468: LD_INT 1
3470: DEC
3471: ST_TO_ADDR
3472: LD_VAR 0 5
3476: PUSH
3477: FOR_TO
3478: IFFALSE 3503
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3480: LD_VAR 0 5
3484: PUSH
3485: LD_VAR 0 2
3489: ARRAY
3490: PPUSH
3491: LD_INT 1
3493: PPUSH
3494: LD_INT 0
3496: PPUSH
3497: CALL_OW 49
3501: GO 3477
3503: POP
3504: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3505: LD_EXP 9
3509: PPUSH
3510: LD_INT 51
3512: PPUSH
3513: LD_INT 43
3515: PPUSH
3516: LD_INT 0
3518: PPUSH
3519: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3523: LD_EXP 10
3527: PPUSH
3528: LD_INT 55
3530: PPUSH
3531: LD_INT 58
3533: PPUSH
3534: LD_INT 0
3536: PPUSH
3537: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3541: LD_EXP 11
3545: PPUSH
3546: LD_INT 39
3548: PPUSH
3549: LD_INT 36
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// BetaSquad := filter diff 0 ;
3559: LD_ADDR_EXP 12
3563: PUSH
3564: LD_VAR 0 3
3568: PUSH
3569: LD_INT 0
3571: DIFF
3572: ST_TO_ADDR
// end ;
3573: LD_VAR 0 1
3577: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3578: LD_INT 0
3580: PPUSH
3581: PPUSH
3582: PPUSH
3583: PPUSH
3584: PPUSH
3585: PPUSH
// uc_side := 6 ;
3586: LD_ADDR_OWVAR 20
3590: PUSH
3591: LD_INT 6
3593: ST_TO_ADDR
// uc_nation := nation_russian ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// soldiers := [ ] ;
3602: LD_ADDR_VAR 0 4
3606: PUSH
3607: EMPTY
3608: ST_TO_ADDR
// vehs := [ ] ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: EMPTY
3615: ST_TO_ADDR
// RUArmada := [ ] ;
3616: LD_ADDR_EXP 17
3620: PUSH
3621: EMPTY
3622: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3623: LD_ADDR_EXP 13
3627: PUSH
3628: LD_STRING Yashin
3630: PPUSH
3631: CALL_OW 25
3635: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3636: LD_ADDR_EXP 14
3640: PUSH
3641: LD_STRING Popov
3643: PPUSH
3644: CALL_OW 25
3648: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3649: LD_ADDR_EXP 15
3653: PUSH
3654: LD_STRING Gaydar
3656: PPUSH
3657: CALL_OW 25
3661: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3662: LD_ADDR_EXP 16
3666: PUSH
3667: LD_STRING Vsevolod
3669: PPUSH
3670: CALL_OW 25
3674: ST_TO_ADDR
// for i = 1 to 16 do
3675: LD_ADDR_VAR 0 2
3679: PUSH
3680: DOUBLE
3681: LD_INT 1
3683: DEC
3684: ST_TO_ADDR
3685: LD_INT 16
3687: PUSH
3688: FOR_TO
3689: IFFALSE 3731
// begin PrepareSoldier ( 0 , game_eskill ) ;
3691: LD_INT 0
3693: PPUSH
3694: LD_EXP 40
3698: PPUSH
3699: CALL_OW 381
// un := CreateHuman ;
3703: LD_ADDR_VAR 0 5
3707: PUSH
3708: CALL_OW 44
3712: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3713: LD_ADDR_VAR 0 4
3717: PUSH
3718: LD_VAR 0 4
3722: PUSH
3723: LD_VAR 0 5
3727: ADD
3728: ST_TO_ADDR
// end ;
3729: GO 3688
3731: POP
3732: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: LD_EXP 13
3742: PUSH
3743: LD_EXP 14
3747: ADD
3748: PUSH
3749: LD_EXP 15
3753: ADD
3754: PUSH
3755: LD_EXP 16
3759: ADD
3760: PUSH
3761: LD_VAR 0 4
3765: ADD
3766: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3767: LD_INT 24
3769: PPUSH
3770: LD_INT 3
3772: PPUSH
3773: LD_INT 1
3775: PPUSH
3776: LD_INT 46
3778: PPUSH
3779: LD_INT 100
3781: PPUSH
3782: CALL 18466 0 5
// for i = 1 to 8 do
3786: LD_ADDR_VAR 0 2
3790: PUSH
3791: DOUBLE
3792: LD_INT 1
3794: DEC
3795: ST_TO_ADDR
3796: LD_INT 8
3798: PUSH
3799: FOR_TO
3800: IFFALSE 3883
// begin vehicle := CreateVehicle ;
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: CALL_OW 45
3811: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3812: LD_VAR 0 4
3816: PUSH
3817: LD_INT 1
3819: ARRAY
3820: PPUSH
3821: LD_VAR 0 3
3825: PPUSH
3826: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3830: LD_ADDR_VAR 0 4
3834: PUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_VAR 0 4
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: DIFF
3849: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3850: LD_VAR 0 3
3854: PPUSH
3855: LD_INT 5
3857: PPUSH
3858: LD_INT 0
3860: PPUSH
3861: CALL_OW 49
// vehs := vehs ^ vehicle ;
3865: LD_ADDR_VAR 0 6
3869: PUSH
3870: LD_VAR 0 6
3874: PUSH
3875: LD_VAR 0 3
3879: ADD
3880: ST_TO_ADDR
// end ;
3881: GO 3799
3883: POP
3884: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3885: LD_INT 24
3887: PPUSH
3888: LD_INT 3
3890: PPUSH
3891: LD_INT 1
3893: PPUSH
3894: LD_INT 43
3896: PPUSH
3897: LD_INT 100
3899: PPUSH
3900: CALL 18466 0 5
// for i = 1 to 8 do
3904: LD_ADDR_VAR 0 2
3908: PUSH
3909: DOUBLE
3910: LD_INT 1
3912: DEC
3913: ST_TO_ADDR
3914: LD_INT 8
3916: PUSH
3917: FOR_TO
3918: IFFALSE 4001
// begin vehicle := CreateVehicle ;
3920: LD_ADDR_VAR 0 3
3924: PUSH
3925: CALL_OW 45
3929: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3930: LD_VAR 0 4
3934: PUSH
3935: LD_INT 1
3937: ARRAY
3938: PPUSH
3939: LD_VAR 0 3
3943: PPUSH
3944: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3948: LD_ADDR_VAR 0 4
3952: PUSH
3953: LD_VAR 0 4
3957: PUSH
3958: LD_VAR 0 4
3962: PUSH
3963: LD_INT 1
3965: ARRAY
3966: DIFF
3967: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3968: LD_VAR 0 3
3972: PPUSH
3973: LD_INT 5
3975: PPUSH
3976: LD_INT 0
3978: PPUSH
3979: CALL_OW 49
// vehs := vehs ^ vehicle ;
3983: LD_ADDR_VAR 0 6
3987: PUSH
3988: LD_VAR 0 6
3992: PUSH
3993: LD_VAR 0 3
3997: ADD
3998: ST_TO_ADDR
// end ;
3999: GO 3917
4001: POP
4002: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
4003: LD_INT 22
4005: PPUSH
4006: LD_INT 3
4008: PPUSH
4009: LD_INT 1
4011: PPUSH
4012: LD_INT 44
4014: PPUSH
4015: LD_INT 100
4017: PPUSH
4018: CALL 18466 0 5
// for i = 1 to 4 do
4022: LD_ADDR_VAR 0 2
4026: PUSH
4027: DOUBLE
4028: LD_INT 1
4030: DEC
4031: ST_TO_ADDR
4032: LD_INT 4
4034: PUSH
4035: FOR_TO
4036: IFFALSE 4119
// begin vehicle := CreateVehicle ;
4038: LD_ADDR_VAR 0 3
4042: PUSH
4043: CALL_OW 45
4047: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4048: LD_VAR 0 4
4052: PUSH
4053: LD_INT 1
4055: ARRAY
4056: PPUSH
4057: LD_VAR 0 3
4061: PPUSH
4062: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4066: LD_ADDR_VAR 0 4
4070: PUSH
4071: LD_VAR 0 4
4075: PUSH
4076: LD_VAR 0 4
4080: PUSH
4081: LD_INT 1
4083: ARRAY
4084: DIFF
4085: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_INT 5
4093: PPUSH
4094: LD_INT 0
4096: PPUSH
4097: CALL_OW 49
// vehs := vehs ^ vehicle ;
4101: LD_ADDR_VAR 0 6
4105: PUSH
4106: LD_VAR 0 6
4110: PUSH
4111: LD_VAR 0 3
4115: ADD
4116: ST_TO_ADDR
// end ;
4117: GO 4035
4119: POP
4120: POP
// RUArmada := vehs ;
4121: LD_ADDR_EXP 17
4125: PUSH
4126: LD_VAR 0 6
4130: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
4131: LD_EXP 13
4135: PPUSH
4136: CALL_OW 310
4140: PUSH
4141: LD_EXP 14
4145: PPUSH
4146: CALL_OW 310
4150: PUSH
4151: LD_EXP 15
4155: PPUSH
4156: CALL_OW 310
4160: PUSH
4161: LD_EXP 16
4165: PPUSH
4166: CALL_OW 310
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: LIST
4176: PPUSH
4177: LD_INT 6
4179: NEG
4180: PPUSH
4181: CALL_OW 242
// end ;
4185: LD_VAR 0 1
4189: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
4190: LD_INT 0
4192: PPUSH
4193: PPUSH
4194: PPUSH
// uc_side := 6 ;
4195: LD_ADDR_OWVAR 20
4199: PUSH
4200: LD_INT 6
4202: ST_TO_ADDR
// uc_nation := nation_russian ;
4203: LD_ADDR_OWVAR 21
4207: PUSH
4208: LD_INT 3
4210: ST_TO_ADDR
// Bulldozers := [ ] ;
4211: LD_ADDR_EXP 18
4215: PUSH
4216: EMPTY
4217: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
4218: LD_INT 24
4220: PPUSH
4221: LD_INT 3
4223: PPUSH
4224: LD_INT 3
4226: PPUSH
4227: LD_INT 53
4229: PPUSH
4230: LD_INT 100
4232: PPUSH
4233: CALL 18466 0 5
// for i = 1 to 2 do
4237: LD_ADDR_VAR 0 2
4241: PUSH
4242: DOUBLE
4243: LD_INT 1
4245: DEC
4246: ST_TO_ADDR
4247: LD_INT 2
4249: PUSH
4250: FOR_TO
4251: IFFALSE 4296
// begin vehicle := CreateVehicle ;
4253: LD_ADDR_VAR 0 3
4257: PUSH
4258: CALL_OW 45
4262: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4263: LD_VAR 0 3
4267: PPUSH
4268: LD_INT 5
4270: PPUSH
4271: LD_INT 0
4273: PPUSH
4274: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4278: LD_ADDR_EXP 18
4282: PUSH
4283: LD_EXP 18
4287: PUSH
4288: LD_VAR 0 3
4292: ADD
4293: ST_TO_ADDR
// end ;
4294: GO 4250
4296: POP
4297: POP
// end ;
4298: LD_VAR 0 1
4302: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4303: LD_INT 0
4305: PPUSH
4306: PPUSH
4307: PPUSH
4308: PPUSH
// uc_side := 3 ;
4309: LD_ADDR_OWVAR 20
4313: PUSH
4314: LD_INT 3
4316: ST_TO_ADDR
// uc_nation := nation_russian ;
4317: LD_ADDR_OWVAR 21
4321: PUSH
4322: LD_INT 3
4324: ST_TO_ADDR
// hc_name :=  ;
4325: LD_ADDR_OWVAR 26
4329: PUSH
4330: LD_STRING 
4332: ST_TO_ADDR
// hc_gallery :=  ;
4333: LD_ADDR_OWVAR 33
4337: PUSH
4338: LD_STRING 
4340: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4341: LD_ADDR_EXP 19
4345: PUSH
4346: LD_STRING Burlak
4348: PPUSH
4349: CALL_OW 25
4353: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4354: LD_ADDR_EXP 20
4358: PUSH
4359: LD_STRING Gleb
4361: PPUSH
4362: CALL_OW 25
4366: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4367: LD_ADDR_EXP 21
4371: PUSH
4372: LD_STRING Furmanov
4374: PPUSH
4375: CALL_OW 25
4379: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4380: LD_ADDR_EXP 22
4384: PUSH
4385: LD_STRING Titov
4387: PPUSH
4388: CALL_OW 25
4392: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4393: LD_ADDR_EXP 23
4397: PUSH
4398: LD_STRING Scholtze
4400: PPUSH
4401: CALL_OW 25
4405: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4406: LD_ADDR_EXP 24
4410: PUSH
4411: LD_STRING Dolgov
4413: PPUSH
4414: CALL_OW 25
4418: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4419: LD_ADDR_EXP 25
4423: PUSH
4424: LD_STRING Kapitsova
4426: PPUSH
4427: CALL_OW 25
4431: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4432: LD_ADDR_EXP 26
4436: PUSH
4437: LD_STRING Karamazov
4439: PPUSH
4440: CALL_OW 25
4444: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4445: LD_ADDR_EXP 27
4449: PUSH
4450: LD_STRING Kirlenkova
4452: PPUSH
4453: CALL_OW 25
4457: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4458: LD_ADDR_EXP 28
4462: PUSH
4463: LD_STRING Kovalyuk
4465: PPUSH
4466: CALL_OW 25
4470: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4471: LD_ADDR_EXP 29
4475: PUSH
4476: LD_STRING Kozlov
4478: PPUSH
4479: CALL_OW 25
4483: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4484: LD_ADDR_EXP 30
4488: PUSH
4489: LD_STRING Kuzmov
4491: PPUSH
4492: CALL_OW 25
4496: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4497: LD_ADDR_EXP 31
4501: PUSH
4502: LD_STRING Lipshchin
4504: PPUSH
4505: CALL_OW 25
4509: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4510: LD_ADDR_EXP 32
4514: PUSH
4515: LD_STRING Oblukov
4517: PPUSH
4518: CALL_OW 25
4522: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4523: LD_ADDR_EXP 33
4527: PUSH
4528: LD_STRING Xavier2
4530: PPUSH
4531: CALL_OW 25
4535: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4536: LD_ADDR_EXP 34
4540: PUSH
4541: LD_STRING Gnyevko
4543: PPUSH
4544: CALL_OW 25
4548: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4549: LD_ADDR_EXP 35
4553: PUSH
4554: LD_STRING Belkov
4556: PPUSH
4557: CALL_OW 25
4561: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4562: LD_ADDR_VAR 0 3
4566: PUSH
4567: LD_EXP 19
4571: PUSH
4572: LD_EXP 20
4576: PUSH
4577: LD_EXP 21
4581: PUSH
4582: LD_EXP 22
4586: PUSH
4587: LD_EXP 23
4591: PUSH
4592: LD_EXP 24
4596: PUSH
4597: LD_EXP 25
4601: PUSH
4602: LD_EXP 26
4606: PUSH
4607: LD_EXP 27
4611: PUSH
4612: LD_EXP 28
4616: PUSH
4617: LD_EXP 29
4621: PUSH
4622: LD_EXP 30
4626: PUSH
4627: LD_EXP 31
4631: PUSH
4632: LD_EXP 32
4636: PUSH
4637: LD_EXP 33
4641: PUSH
4642: LD_EXP 34
4646: PUSH
4647: LD_EXP 35
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ST_TO_ADDR
// for i = 1 to filter do
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: DOUBLE
4677: LD_INT 1
4679: DEC
4680: ST_TO_ADDR
4681: LD_VAR 0 3
4685: PUSH
4686: FOR_TO
4687: IFFALSE 4712
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4689: LD_VAR 0 3
4693: PUSH
4694: LD_VAR 0 2
4698: ARRAY
4699: PPUSH
4700: LD_INT 6
4702: PPUSH
4703: LD_INT 0
4705: PPUSH
4706: CALL_OW 49
4710: GO 4686
4712: POP
4713: POP
// end ;
4714: LD_VAR 0 1
4718: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4719: LD_INT 0
4721: PPUSH
4722: PPUSH
4723: PPUSH
4724: PPUSH
// uc_side := 3 ;
4725: LD_ADDR_OWVAR 20
4729: PUSH
4730: LD_INT 3
4732: ST_TO_ADDR
// uc_nation := nation_russian ;
4733: LD_ADDR_OWVAR 21
4737: PUSH
4738: LD_INT 3
4740: ST_TO_ADDR
// hc_name :=  ;
4741: LD_ADDR_OWVAR 26
4745: PUSH
4746: LD_STRING 
4748: ST_TO_ADDR
// hc_gallery :=  ;
4749: LD_ADDR_OWVAR 33
4753: PUSH
4754: LD_STRING 
4756: ST_TO_ADDR
// for i = 1 to 8 do
4757: LD_ADDR_VAR 0 2
4761: PUSH
4762: DOUBLE
4763: LD_INT 1
4765: DEC
4766: ST_TO_ADDR
4767: LD_INT 8
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4813
// begin PrepareSoldier ( 0 , game_eskill ) ;
4773: LD_INT 0
4775: PPUSH
4776: LD_EXP 40
4780: PPUSH
4781: CALL_OW 381
// un := CreateHuman ;
4785: LD_ADDR_VAR 0 4
4789: PUSH
4790: CALL_OW 44
4794: ST_TO_ADDR
// filter := filter ^ un ;
4795: LD_ADDR_VAR 0 3
4799: PUSH
4800: LD_VAR 0 3
4804: PUSH
4805: LD_VAR 0 4
4809: ADD
4810: ST_TO_ADDR
// end ;
4811: GO 4770
4813: POP
4814: POP
// for i = 1 to 4 do
4815: LD_ADDR_VAR 0 2
4819: PUSH
4820: DOUBLE
4821: LD_INT 1
4823: DEC
4824: ST_TO_ADDR
4825: LD_INT 4
4827: PUSH
4828: FOR_TO
4829: IFFALSE 4871
// begin PrepareEngineer ( 0 , game_eskill ) ;
4831: LD_INT 0
4833: PPUSH
4834: LD_EXP 40
4838: PPUSH
4839: CALL_OW 382
// un := CreateHuman ;
4843: LD_ADDR_VAR 0 4
4847: PUSH
4848: CALL_OW 44
4852: ST_TO_ADDR
// filter := filter ^ un ;
4853: LD_ADDR_VAR 0 3
4857: PUSH
4858: LD_VAR 0 3
4862: PUSH
4863: LD_VAR 0 4
4867: ADD
4868: ST_TO_ADDR
// end ;
4869: GO 4828
4871: POP
4872: POP
// for i = 1 to 6 do
4873: LD_ADDR_VAR 0 2
4877: PUSH
4878: DOUBLE
4879: LD_INT 1
4881: DEC
4882: ST_TO_ADDR
4883: LD_INT 6
4885: PUSH
4886: FOR_TO
4887: IFFALSE 4929
// begin PrepareMechanic ( 0 , game_eskill ) ;
4889: LD_INT 0
4891: PPUSH
4892: LD_EXP 40
4896: PPUSH
4897: CALL_OW 383
// un := CreateHuman ;
4901: LD_ADDR_VAR 0 4
4905: PUSH
4906: CALL_OW 44
4910: ST_TO_ADDR
// filter := filter ^ un ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_VAR 0 3
4920: PUSH
4921: LD_VAR 0 4
4925: ADD
4926: ST_TO_ADDR
// end ;
4927: GO 4886
4929: POP
4930: POP
// for i = 1 to 4 do
4931: LD_ADDR_VAR 0 2
4935: PUSH
4936: DOUBLE
4937: LD_INT 1
4939: DEC
4940: ST_TO_ADDR
4941: LD_INT 4
4943: PUSH
4944: FOR_TO
4945: IFFALSE 4987
// begin PrepareScientist ( 0 , game_eskill ) ;
4947: LD_INT 0
4949: PPUSH
4950: LD_EXP 40
4954: PPUSH
4955: CALL_OW 384
// un := CreateHuman ;
4959: LD_ADDR_VAR 0 4
4963: PUSH
4964: CALL_OW 44
4968: ST_TO_ADDR
// filter := filter ^ un ;
4969: LD_ADDR_VAR 0 3
4973: PUSH
4974: LD_VAR 0 3
4978: PUSH
4979: LD_VAR 0 4
4983: ADD
4984: ST_TO_ADDR
// end ;
4985: GO 4944
4987: POP
4988: POP
// for i = 1 to filter do
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: DOUBLE
4995: LD_INT 1
4997: DEC
4998: ST_TO_ADDR
4999: LD_VAR 0 3
5003: PUSH
5004: FOR_TO
5005: IFFALSE 5030
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
5007: LD_VAR 0 3
5011: PUSH
5012: LD_VAR 0 2
5016: ARRAY
5017: PPUSH
5018: LD_INT 6
5020: PPUSH
5021: LD_INT 0
5023: PPUSH
5024: CALL_OW 49
5028: GO 5004
5030: POP
5031: POP
// RU_SecondPersonnel := filter ;
5032: LD_ADDR_EXP 36
5036: PUSH
5037: LD_VAR 0 3
5041: ST_TO_ADDR
// end ;
5042: LD_VAR 0 1
5046: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
5047: LD_INT 0
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
5055: PPUSH
// uc_side := 1 ;
5056: LD_ADDR_OWVAR 20
5060: PUSH
5061: LD_INT 1
5063: ST_TO_ADDR
// uc_nation := nation_american ;
5064: LD_ADDR_OWVAR 21
5068: PUSH
5069: LD_INT 1
5071: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
5072: LD_ADDR_EXP 37
5076: PUSH
5077: LD_STRING JMM
5079: PPUSH
5080: CALL_OW 25
5084: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
5085: LD_EXP 37
5089: PPUSH
5090: LD_INT 1
5092: PPUSH
5093: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
5097: LD_EXP 37
5101: PPUSH
5102: LD_INT 7
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 49
// mechs := [ ] ;
5112: LD_ADDR_VAR 0 7
5116: PUSH
5117: EMPTY
5118: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
5119: LD_ADDR_VAR 0 2
5123: PUSH
5124: DOUBLE
5125: LD_INT 1
5127: DEC
5128: ST_TO_ADDR
5129: LD_INT 4
5131: PUSH
5132: LD_INT 3
5134: PUSH
5135: LD_INT 3
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: LIST
5142: PUSH
5143: LD_OWVAR 67
5147: ARRAY
5148: PUSH
5149: FOR_TO
5150: IFFALSE 5211
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_EXP 39
5159: PUSH
5160: LD_INT 1
5162: PLUS
5163: PPUSH
5164: CALL_OW 381
// un := CreateHuman ;
5168: LD_ADDR_VAR 0 4
5172: PUSH
5173: CALL_OW 44
5177: ST_TO_ADDR
// soldiers := soldiers ^ un ;
5178: LD_ADDR_VAR 0 3
5182: PUSH
5183: LD_VAR 0 3
5187: PUSH
5188: LD_VAR 0 4
5192: ADD
5193: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
5194: LD_VAR 0 4
5198: PPUSH
5199: LD_INT 7
5201: PPUSH
5202: LD_INT 0
5204: PPUSH
5205: CALL_OW 49
// end ;
5209: GO 5149
5211: POP
5212: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5213: LD_ADDR_VAR 0 2
5217: PUSH
5218: DOUBLE
5219: LD_INT 1
5221: DEC
5222: ST_TO_ADDR
5223: LD_INT 7
5225: PUSH
5226: LD_INT 6
5228: PUSH
5229: LD_INT 4
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: LIST
5236: PUSH
5237: LD_OWVAR 67
5241: ARRAY
5242: PUSH
5243: FOR_TO
5244: IFFALSE 5290
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5246: LD_INT 0
5248: PPUSH
5249: LD_EXP 39
5253: PUSH
5254: LD_INT 1
5256: PLUS
5257: PPUSH
5258: CALL_OW 383
// un := CreateHuman ;
5262: LD_ADDR_VAR 0 4
5266: PUSH
5267: CALL_OW 44
5271: ST_TO_ADDR
// mechs := mechs ^ un ;
5272: LD_ADDR_VAR 0 7
5276: PUSH
5277: LD_VAR 0 7
5281: PUSH
5282: LD_VAR 0 4
5286: ADD
5287: ST_TO_ADDR
// end ;
5288: GO 5243
5290: POP
5291: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5292: LD_INT 3
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 1
5300: PPUSH
5301: LD_INT 5
5303: PPUSH
5304: LD_INT 100
5306: PPUSH
5307: CALL 18466 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5311: LD_ADDR_VAR 0 2
5315: PUSH
5316: DOUBLE
5317: LD_INT 1
5319: DEC
5320: ST_TO_ADDR
5321: LD_INT 7
5323: PUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 4
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: LIST
5334: PUSH
5335: LD_OWVAR 67
5339: ARRAY
5340: PUSH
5341: FOR_TO
5342: IFFALSE 5437
// begin vehicle := CreateVehicle ;
5344: LD_ADDR_VAR 0 6
5348: PUSH
5349: CALL_OW 45
5353: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5354: LD_VAR 0 7
5358: PUSH
5359: LD_INT 1
5361: ARRAY
5362: PPUSH
5363: LD_VAR 0 6
5367: PPUSH
5368: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5372: LD_ADDR_VAR 0 7
5376: PUSH
5377: LD_VAR 0 7
5381: PUSH
5382: LD_VAR 0 7
5386: PUSH
5387: LD_INT 1
5389: ARRAY
5390: DIFF
5391: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5392: LD_VAR 0 6
5396: PPUSH
5397: LD_INT 1
5399: PPUSH
5400: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5404: LD_VAR 0 6
5408: PPUSH
5409: LD_INT 7
5411: PPUSH
5412: LD_INT 0
5414: PPUSH
5415: CALL_OW 49
// vehs := vehs ^ vehicle ;
5419: LD_ADDR_VAR 0 5
5423: PUSH
5424: LD_VAR 0 5
5428: PUSH
5429: LD_VAR 0 6
5433: ADD
5434: ST_TO_ADDR
// end ;
5435: GO 5341
5437: POP
5438: POP
// end ; end_of_file
5439: LD_VAR 0 1
5443: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export startCrates ; export function GameType ; var i , ruStartTechs ; begin
5444: LD_INT 0
5446: PPUSH
5447: PPUSH
5448: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5449: LD_ADDR_OWVAR 67
5453: PUSH
5454: LD_INT 0
5456: PPUSH
5457: CALL_OW 426
5461: ST_TO_ADDR
// game_diff := Difficulty ;
5462: LD_ADDR_EXP 38
5466: PUSH
5467: LD_OWVAR 67
5471: ST_TO_ADDR
// game_skill := [ 7 , 6 , 5 ] [ game_diff ] ;
5472: LD_ADDR_EXP 39
5476: PUSH
5477: LD_INT 7
5479: PUSH
5480: LD_INT 6
5482: PUSH
5483: LD_INT 5
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: LD_EXP 38
5495: ARRAY
5496: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5497: LD_ADDR_EXP 40
5501: PUSH
5502: LD_INT 6
5504: PUSH
5505: LD_INT 7
5507: PUSH
5508: LD_INT 8
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_EXP 38
5520: ARRAY
5521: ST_TO_ADDR
// ruArrival := [ 3 3$00 , 2 2$00 , 1 1$00 ] [ game_diff ] ;
5522: LD_ADDR_EXP 42
5526: PUSH
5527: LD_INT 6300
5529: PUSH
5530: LD_INT 4200
5532: PUSH
5533: LD_INT 2100
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: LIST
5540: PUSH
5541: LD_EXP 38
5545: ARRAY
5546: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5547: LD_ADDR_EXP 41
5551: PUSH
5552: LD_INT 73500
5554: PUSH
5555: LD_INT 94500
5557: PUSH
5558: LD_INT 115500
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: PUSH
5566: LD_EXP 38
5570: ARRAY
5571: ST_TO_ADDR
// ruStartTechs = [ [ tech_Weap1 ] , [ tech_Weap1 , tech_Comp1 ] , [ tech_Weap1 , tech_Weap2 , tech_Comp1 ] ] ;
5572: LD_ADDR_VAR 0 3
5576: PUSH
5577: LD_INT 51
5579: PUSH
5580: EMPTY
5581: LIST
5582: PUSH
5583: LD_INT 51
5585: PUSH
5586: LD_INT 57
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 51
5595: PUSH
5596: LD_INT 52
5598: PUSH
5599: LD_INT 57
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: ST_TO_ADDR
// startCrates = [ [ 300 , 350 ] , [ 230 , 200 ] , [ 150 , 100 ] ] [ game_diff ] ;
5612: LD_ADDR_EXP 43
5616: PUSH
5617: LD_INT 300
5619: PUSH
5620: LD_INT 350
5622: PUSH
5623: EMPTY
5624: LIST
5625: LIST
5626: PUSH
5627: LD_INT 230
5629: PUSH
5630: LD_INT 200
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 150
5639: PUSH
5640: LD_INT 100
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_EXP 38
5656: ARRAY
5657: ST_TO_ADDR
// for i := 1 to ruStartTechs [ game_diff ] do
5658: LD_ADDR_VAR 0 2
5662: PUSH
5663: DOUBLE
5664: LD_INT 1
5666: DEC
5667: ST_TO_ADDR
5668: LD_VAR 0 3
5672: PUSH
5673: LD_EXP 38
5677: ARRAY
5678: PUSH
5679: FOR_TO
5680: IFFALSE 5738
// begin SetTech ( ruStartTechs [ game_diff ] [ i ] , 3 , state_researched ) ;
5682: LD_VAR 0 3
5686: PUSH
5687: LD_EXP 38
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: LD_INT 3
5701: PPUSH
5702: LD_INT 2
5704: PPUSH
5705: CALL_OW 322
// SetTech ( ruStartTechs [ game_diff ] [ i ] , 6 , state_researched ) ;
5709: LD_VAR 0 3
5713: PUSH
5714: LD_EXP 38
5718: ARRAY
5719: PUSH
5720: LD_VAR 0 2
5724: ARRAY
5725: PPUSH
5726: LD_INT 6
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 322
// end ;
5736: GO 5679
5738: POP
5739: POP
// end ; end_of_file
5740: LD_VAR 0 1
5744: RET
// export function CustomEvent ( event ) ; begin
5745: LD_INT 0
5747: PPUSH
// end ;
5748: LD_VAR 0 2
5752: RET
// export function CustomInitMacro ( ) ; begin
5753: LD_INT 0
5755: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5756: LD_INT 1
5758: PPUSH
5759: LD_INT 3
5761: PPUSH
5762: CALL 78818 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5766: LD_INT 1
5768: PPUSH
5769: LD_INT 4
5771: PPUSH
5772: CALL 78762 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5776: LD_INT 1
5778: PPUSH
5779: LD_INT 136
5781: PUSH
5782: LD_INT 130
5784: PUSH
5785: LD_INT 0
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 145
5795: PUSH
5796: LD_INT 123
5798: PUSH
5799: LD_INT 0
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: CALL 77821 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5815: LD_INT 1
5817: PPUSH
5818: LD_INT 43
5820: PUSH
5821: LD_INT 46
5823: PUSH
5824: LD_INT 45
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PPUSH
5832: CALL 78650 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5836: LD_INT 1
5838: PPUSH
5839: LD_INT 3
5841: PPUSH
5842: CALL 78332 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5846: LD_INT 1
5848: PPUSH
5849: LD_INT 3
5851: PPUSH
5852: CALL 78063 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5856: LD_INT 1
5858: PPUSH
5859: LD_INT 8
5861: PPUSH
5862: CALL 77682 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5866: LD_INT 1
5868: PPUSH
5869: LD_INT 22
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: LD_INT 3
5877: PUSH
5878: LD_INT 43
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: PUSH
5887: LD_INT 22
5889: PUSH
5890: LD_INT 1
5892: PUSH
5893: LD_INT 3
5895: PUSH
5896: LD_INT 44
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 22
5907: PUSH
5908: LD_INT 1
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: LD_INT 45
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: PUSH
5923: LD_INT 24
5925: PUSH
5926: LD_INT 1
5928: PUSH
5929: LD_INT 3
5931: PUSH
5932: LD_INT 43
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_INT 24
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 3
5949: PUSH
5950: LD_INT 43
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 24
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: LD_INT 3
5967: PUSH
5968: LD_INT 46
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: PUSH
5977: LD_INT 22
5979: PUSH
5980: LD_INT 1
5982: PUSH
5983: LD_INT 3
5985: PUSH
5986: LD_INT 43
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 22
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: LD_INT 3
6003: PUSH
6004: LD_INT 44
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: LIST
6011: LIST
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PPUSH
6023: CALL 77497 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
6027: LD_INT 1
6029: PPUSH
6030: LD_INT 0
6032: PUSH
6033: LD_INT 127
6035: PUSH
6036: LD_INT 125
6038: PUSH
6039: LD_INT 5
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 6
6050: PUSH
6051: LD_INT 124
6053: PUSH
6054: LD_INT 132
6056: PUSH
6057: LD_INT 0
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 29
6068: PUSH
6069: LD_INT 136
6071: PUSH
6072: LD_INT 130
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 4
6086: PUSH
6087: LD_INT 118
6089: PUSH
6090: LD_INT 114
6092: PUSH
6093: LD_INT 2
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 29
6104: PUSH
6105: LD_INT 145
6107: PUSH
6108: LD_INT 123
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 26
6122: PUSH
6123: LD_INT 150
6125: PUSH
6126: LD_INT 135
6128: PUSH
6129: LD_INT 1
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 26
6140: PUSH
6141: LD_INT 140
6143: PUSH
6144: LD_INT 134
6146: PUSH
6147: LD_INT 2
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_INT 26
6158: PUSH
6159: LD_INT 137
6161: PUSH
6162: LD_INT 121
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 2
6176: PUSH
6177: LD_INT 155
6179: PUSH
6180: LD_INT 130
6182: PUSH
6183: LD_INT 0
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 32
6194: PUSH
6195: LD_INT 155
6197: PUSH
6198: LD_INT 130
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 32
6212: PUSH
6213: LD_INT 130
6215: PUSH
6216: LD_INT 114
6218: PUSH
6219: LD_INT 3
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 32
6230: PUSH
6231: LD_INT 142
6233: PUSH
6234: LD_INT 115
6236: PUSH
6237: LD_INT 3
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 32
6248: PUSH
6249: LD_INT 153
6251: PUSH
6252: LD_INT 120
6254: PUSH
6255: LD_INT 3
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: PPUSH
6279: CALL 77389 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
6283: LD_INT 1
6285: PPUSH
6286: LD_INT 10
6288: PUSH
6289: LD_INT 12
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: PPUSH
6296: CALL 78239 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6300: LD_INT 1
6302: PPUSH
6303: LD_INT 155
6305: PPUSH
6306: LD_INT 130
6308: PPUSH
6309: LD_INT 0
6311: PPUSH
6312: LD_INT 24
6314: PUSH
6315: LD_INT 16
6317: PUSH
6318: LD_INT 17
6320: PUSH
6321: LD_INT 18
6323: PUSH
6324: LD_INT 21
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL 78444 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
6338: LD_INT 2
6340: PPUSH
6341: LD_INT 3
6343: PPUSH
6344: CALL 78818 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 4
6353: PPUSH
6354: CALL 78762 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
6358: LD_INT 2
6360: PPUSH
6361: LD_INT 84
6363: PUSH
6364: LD_INT 125
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: EMPTY
6376: LIST
6377: PPUSH
6378: CALL 77821 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
6382: LD_INT 2
6384: PPUSH
6385: LD_INT 43
6387: PUSH
6388: LD_INT 46
6390: PUSH
6391: LD_INT 45
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: LIST
6398: PPUSH
6399: CALL 78650 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
6403: LD_INT 2
6405: PPUSH
6406: LD_INT 3
6408: PPUSH
6409: CALL 78332 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6413: LD_INT 2
6415: PPUSH
6416: LD_INT 3
6418: PPUSH
6419: CALL 78063 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6423: LD_INT 2
6425: PPUSH
6426: LD_INT 8
6428: PPUSH
6429: CALL 77682 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6433: LD_INT 2
6435: PPUSH
6436: LD_INT 22
6438: PUSH
6439: LD_INT 3
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: LD_INT 43
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 22
6456: PUSH
6457: LD_INT 3
6459: PUSH
6460: LD_INT 3
6462: PUSH
6463: LD_INT 44
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 22
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: LD_INT 3
6480: PUSH
6481: LD_INT 45
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 24
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 43
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 24
6510: PUSH
6511: LD_INT 3
6513: PUSH
6514: LD_INT 3
6516: PUSH
6517: LD_INT 43
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 24
6528: PUSH
6529: LD_INT 3
6531: PUSH
6532: LD_INT 3
6534: PUSH
6535: LD_INT 46
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 22
6546: PUSH
6547: LD_INT 3
6549: PUSH
6550: LD_INT 3
6552: PUSH
6553: LD_INT 43
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 22
6564: PUSH
6565: LD_INT 3
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 44
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: LIST
6588: LIST
6589: PPUSH
6590: CALL 77497 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6594: LD_INT 2
6596: PPUSH
6597: LD_INT 0
6599: PUSH
6600: LD_INT 96
6602: PUSH
6603: LD_INT 125
6605: PUSH
6606: LD_INT 0
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 6
6617: PUSH
6618: LD_INT 74
6620: PUSH
6621: LD_INT 122
6623: PUSH
6624: LD_INT 1
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 30
6635: PUSH
6636: LD_INT 84
6638: PUSH
6639: LD_INT 125
6641: PUSH
6642: LD_INT 1
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 28
6653: PUSH
6654: LD_INT 86
6656: PUSH
6657: LD_INT 128
6659: PUSH
6660: LD_INT 1
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 28
6671: PUSH
6672: LD_INT 85
6674: PUSH
6675: LD_INT 130
6677: PUSH
6678: LD_INT 2
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 28
6689: PUSH
6690: LD_INT 88
6692: PUSH
6693: LD_INT 132
6695: PUSH
6696: LD_INT 5
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: LD_INT 2
6707: PUSH
6708: LD_INT 106
6710: PUSH
6711: LD_INT 130
6713: PUSH
6714: LD_INT 0
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 4
6725: PUSH
6726: LD_INT 99
6728: PUSH
6729: LD_INT 114
6731: PUSH
6732: LD_INT 3
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: PUSH
6741: LD_INT 32
6743: PUSH
6744: LD_INT 72
6746: PUSH
6747: LD_INT 112
6749: PUSH
6750: LD_INT 2
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 32
6761: PUSH
6762: LD_INT 78
6764: PUSH
6765: LD_INT 110
6767: PUSH
6768: LD_INT 3
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: PUSH
6777: LD_INT 32
6779: PUSH
6780: LD_INT 84
6782: PUSH
6783: LD_INT 110
6785: PUSH
6786: LD_INT 2
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: PUSH
6795: LD_INT 32
6797: PUSH
6798: LD_INT 105
6800: PUSH
6801: LD_INT 117
6803: PUSH
6804: LD_INT 3
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: LIST
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL 77389 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6831: LD_INT 2
6833: PPUSH
6834: LD_INT 14
6836: PUSH
6837: LD_INT 11
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PPUSH
6844: CALL 78239 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6848: LD_INT 2
6850: PPUSH
6851: LD_INT 106
6853: PPUSH
6854: LD_INT 130
6856: PPUSH
6857: LD_INT 0
6859: PPUSH
6860: LD_INT 24
6862: PUSH
6863: LD_INT 16
6865: PUSH
6866: LD_INT 17
6868: PUSH
6869: LD_INT 18
6871: PUSH
6872: LD_INT 21
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: LIST
6879: LIST
6880: LIST
6881: PPUSH
6882: CALL 78444 0 5
// end ;
6886: LD_VAR 0 1
6890: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6891: LD_INT 22
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 30
6903: PUSH
6904: LD_INT 3
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PPUSH
6915: CALL_OW 69
6919: IFFALSE 8062
6921: GO 6923
6923: DISABLE
6924: LD_INT 0
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
6931: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
6932: LD_INT 6300
6934: PUSH
6935: LD_INT 4200
6937: PUSH
6938: LD_INT 2100
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: LIST
6945: PUSH
6946: LD_OWVAR 67
6950: ARRAY
6951: PPUSH
6952: CALL_OW 67
// base := 2 ;
6956: LD_ADDR_VAR 0 2
6960: PUSH
6961: LD_INT 2
6963: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
6964: LD_INT 22
6966: PUSH
6967: LD_INT 3
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 30
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PPUSH
6988: CALL_OW 69
6992: NOT
6993: IFFALSE 6997
// continue ;
6995: GO 6932
// case Rand ( 1 , 3 ) of 1 :
6997: LD_INT 1
6999: PPUSH
7000: LD_INT 3
7002: PPUSH
7003: CALL_OW 12
7007: PUSH
7008: LD_INT 1
7010: DOUBLE
7011: EQUAL
7012: IFTRUE 7016
7014: GO 7192
7016: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7017: LD_ADDR_VAR 0 3
7021: PUSH
7022: LD_INT 22
7024: PUSH
7025: LD_INT 3
7027: PUSH
7028: LD_INT 3
7030: PUSH
7031: LD_INT 43
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 24
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 3
7048: PUSH
7049: LD_INT 46
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 24
7060: PUSH
7061: LD_INT 3
7063: PUSH
7064: LD_INT 3
7066: PUSH
7067: LD_INT 43
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 24
7078: PUSH
7079: LD_INT 3
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: LD_INT 46
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PUSH
7094: LD_INT 22
7096: PUSH
7097: LD_INT 3
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 45
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: LD_INT 3
7120: PUSH
7121: LD_INT 43
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: PUSH
7130: LD_INT 24
7132: PUSH
7133: LD_INT 3
7135: PUSH
7136: LD_INT 3
7138: PUSH
7139: LD_INT 46
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: PUSH
7148: LD_INT 22
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 3
7156: PUSH
7157: LD_INT 45
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7176: LD_VAR 0 2
7180: PPUSH
7181: LD_VAR 0 3
7185: PPUSH
7186: CALL 77545 0 2
// end ; 2 :
7190: GO 7523
7192: LD_INT 2
7194: DOUBLE
7195: EQUAL
7196: IFTRUE 7200
7198: GO 7338
7200: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7201: LD_ADDR_VAR 0 3
7205: PUSH
7206: LD_INT 24
7208: PUSH
7209: LD_INT 3
7211: PUSH
7212: LD_INT 3
7214: PUSH
7215: LD_INT 43
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: PUSH
7224: LD_INT 24
7226: PUSH
7227: LD_INT 3
7229: PUSH
7230: LD_INT 3
7232: PUSH
7233: LD_INT 46
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: PUSH
7242: LD_INT 24
7244: PUSH
7245: LD_INT 3
7247: PUSH
7248: LD_INT 3
7250: PUSH
7251: LD_INT 43
7253: PUSH
7254: EMPTY
7255: LIST
7256: LIST
7257: LIST
7258: LIST
7259: PUSH
7260: LD_INT 24
7262: PUSH
7263: LD_INT 3
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: LD_INT 46
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: PUSH
7278: LD_INT 22
7280: PUSH
7281: LD_INT 3
7283: PUSH
7284: LD_INT 3
7286: PUSH
7287: LD_INT 45
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 22
7298: PUSH
7299: LD_INT 3
7301: PUSH
7302: LD_INT 3
7304: PUSH
7305: LD_INT 45
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: LIST
7318: LIST
7319: LIST
7320: LIST
7321: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7322: LD_VAR 0 2
7326: PPUSH
7327: LD_VAR 0 3
7331: PPUSH
7332: CALL 77545 0 2
// end ; 3 :
7336: GO 7523
7338: LD_INT 3
7340: DOUBLE
7341: EQUAL
7342: IFTRUE 7346
7344: GO 7522
7346: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7347: LD_ADDR_VAR 0 3
7351: PUSH
7352: LD_INT 22
7354: PUSH
7355: LD_INT 3
7357: PUSH
7358: LD_INT 3
7360: PUSH
7361: LD_INT 43
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 24
7372: PUSH
7373: LD_INT 3
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: LD_INT 46
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: LD_INT 3
7396: PUSH
7397: LD_INT 43
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: LD_INT 24
7408: PUSH
7409: LD_INT 3
7411: PUSH
7412: LD_INT 3
7414: PUSH
7415: LD_INT 46
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_INT 3
7429: PUSH
7430: LD_INT 3
7432: PUSH
7433: LD_INT 45
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: LD_INT 22
7444: PUSH
7445: LD_INT 3
7447: PUSH
7448: LD_INT 3
7450: PUSH
7451: LD_INT 43
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 24
7462: PUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: LD_INT 46
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: LIST
7476: LIST
7477: PUSH
7478: LD_INT 22
7480: PUSH
7481: LD_INT 3
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 45
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7506: LD_VAR 0 2
7510: PPUSH
7511: LD_VAR 0 3
7515: PPUSH
7516: CALL 77545 0 2
// end ; end ;
7520: GO 7523
7522: POP
// repeat wait ( 0 0$1 ) ;
7523: LD_INT 35
7525: PPUSH
7526: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7530: LD_VAR 0 2
7534: PPUSH
7535: CALL 77893 0 1
7539: PUSH
7540: LD_INT 0
7542: EQUAL
7543: IFFALSE 7523
// wait ( 0 0$30 ) ;
7545: LD_INT 1050
7547: PPUSH
7548: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7552: LD_ADDR_VAR 0 5
7556: PUSH
7557: LD_INT 86
7559: PUSH
7560: LD_INT 77
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 63
7569: PUSH
7570: LD_INT 38
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7581: LD_ADDR_VAR 0 4
7585: PUSH
7586: LD_INT 0
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: LD_INT 0
7594: PUSH
7595: LD_INT 1
7597: PUSH
7598: LD_INT 0
7600: PUSH
7601: LD_INT 0
7603: PUSH
7604: LD_INT 0
7606: PUSH
7607: LD_INT 0
7609: PUSH
7610: LD_INT 1
7612: PUSH
7613: LD_INT 0
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7628: LD_ADDR_VAR 0 6
7632: PUSH
7633: LD_EXP 88
7637: PUSH
7638: LD_VAR 0 2
7642: ARRAY
7643: PUSH
7644: LD_EXP 91
7648: PUSH
7649: LD_VAR 0 2
7653: ARRAY
7654: DIFF
7655: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7656: LD_ADDR_EXP 88
7660: PUSH
7661: LD_EXP 88
7665: PPUSH
7666: LD_VAR 0 2
7670: PPUSH
7671: LD_EXP 88
7675: PUSH
7676: LD_VAR 0 2
7680: ARRAY
7681: PUSH
7682: LD_VAR 0 6
7686: DIFF
7687: PPUSH
7688: CALL_OW 1
7692: ST_TO_ADDR
// if not attackers then
7693: LD_VAR 0 6
7697: NOT
7698: IFFALSE 7702
// continue ;
7700: GO 6932
// repeat wait ( 0 0$1 ) ;
7702: LD_INT 35
7704: PPUSH
7705: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7709: LD_VAR 0 6
7713: PPUSH
7714: LD_INT 60
7716: PUSH
7717: EMPTY
7718: LIST
7719: PPUSH
7720: CALL_OW 72
7724: NOT
7725: IFFALSE 7702
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// for i in attackers do
7734: LD_ADDR_VAR 0 1
7738: PUSH
7739: LD_VAR 0 6
7743: PUSH
7744: FOR_IN
7745: IFFALSE 8029
// begin if IsDead ( i ) then
7747: LD_VAR 0 1
7751: PPUSH
7752: CALL_OW 301
7756: IFFALSE 7774
// attackers := attackers diff i ;
7758: LD_ADDR_VAR 0 6
7762: PUSH
7763: LD_VAR 0 6
7767: PUSH
7768: LD_VAR 0 1
7772: DIFF
7773: ST_TO_ADDR
// if not HasTask ( i ) then
7774: LD_VAR 0 1
7778: PPUSH
7779: CALL_OW 314
7783: NOT
7784: IFFALSE 8027
// begin if not GetTag ( i ) then
7786: LD_VAR 0 1
7790: PPUSH
7791: CALL_OW 110
7795: NOT
7796: IFFALSE 7888
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
7798: LD_VAR 0 1
7802: PPUSH
7803: LD_VAR 0 5
7807: PUSH
7808: LD_INT 1
7810: ARRAY
7811: PUSH
7812: LD_INT 1
7814: ARRAY
7815: PPUSH
7816: LD_VAR 0 5
7820: PUSH
7821: LD_INT 1
7823: ARRAY
7824: PUSH
7825: LD_INT 2
7827: ARRAY
7828: PPUSH
7829: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
7833: LD_VAR 0 1
7837: PPUSH
7838: LD_VAR 0 5
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PUSH
7847: LD_INT 1
7849: ARRAY
7850: PPUSH
7851: LD_VAR 0 5
7855: PUSH
7856: LD_INT 1
7858: ARRAY
7859: PUSH
7860: LD_INT 2
7862: ARRAY
7863: PPUSH
7864: CALL_OW 297
7868: PUSH
7869: LD_INT 8
7871: LESS
7872: IFFALSE 7886
// SetTag ( i , 1 ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_INT 1
7881: PPUSH
7882: CALL_OW 109
// end else
7886: GO 8027
// if GetTag ( i ) = 1 then
7888: LD_VAR 0 1
7892: PPUSH
7893: CALL_OW 110
7897: PUSH
7898: LD_INT 1
7900: EQUAL
7901: IFFALSE 7993
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
7903: LD_VAR 0 1
7907: PPUSH
7908: LD_VAR 0 5
7912: PUSH
7913: LD_INT 2
7915: ARRAY
7916: PUSH
7917: LD_INT 1
7919: ARRAY
7920: PPUSH
7921: LD_VAR 0 5
7925: PUSH
7926: LD_INT 2
7928: ARRAY
7929: PUSH
7930: LD_INT 2
7932: ARRAY
7933: PPUSH
7934: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
7938: LD_VAR 0 1
7942: PPUSH
7943: LD_VAR 0 5
7947: PUSH
7948: LD_INT 2
7950: ARRAY
7951: PUSH
7952: LD_INT 1
7954: ARRAY
7955: PPUSH
7956: LD_VAR 0 5
7960: PUSH
7961: LD_INT 2
7963: ARRAY
7964: PUSH
7965: LD_INT 2
7967: ARRAY
7968: PPUSH
7969: CALL_OW 297
7973: PUSH
7974: LD_INT 8
7976: LESS
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// end else
7991: GO 8027
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_INT 81
8000: PUSH
8001: LD_INT 3
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PPUSH
8008: CALL_OW 69
8012: PPUSH
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL_OW 74
8022: PPUSH
8023: CALL_OW 115
// end ; end ;
8027: GO 7744
8029: POP
8030: POP
// until not attackers ;
8031: LD_VAR 0 6
8035: NOT
8036: IFFALSE 7727
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8038: LD_EXP 69
8042: PUSH
8043: LD_VAR 0 2
8047: ARRAY
8048: PPUSH
8049: LD_INT 50
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 72
8059: NOT
8060: IFFALSE 6932
// end ;
8062: PPOPN 6
8064: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
8065: LD_INT 22
8067: PUSH
8068: LD_INT 3
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: LD_INT 30
8077: PUSH
8078: LD_INT 3
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PPUSH
8089: CALL_OW 69
8093: IFFALSE 9277
8095: GO 8097
8097: DISABLE
8098: LD_INT 0
8100: PPUSH
8101: PPUSH
8102: PPUSH
8103: PPUSH
8104: PPUSH
8105: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
8106: LD_INT 6300
8108: PUSH
8109: LD_INT 4200
8111: PUSH
8112: LD_INT 2100
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PPUSH
8126: CALL_OW 67
// base := 1 ;
8130: LD_ADDR_VAR 0 2
8134: PUSH
8135: LD_INT 1
8137: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8138: LD_INT 22
8140: PUSH
8141: LD_INT 3
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 30
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PPUSH
8162: CALL_OW 69
8166: NOT
8167: IFFALSE 8171
// continue ;
8169: GO 8106
// case Rand ( 1 , 3 ) of 1 :
8171: LD_INT 1
8173: PPUSH
8174: LD_INT 3
8176: PPUSH
8177: CALL_OW 12
8181: PUSH
8182: LD_INT 1
8184: DOUBLE
8185: EQUAL
8186: IFTRUE 8190
8188: GO 8366
8190: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8191: LD_ADDR_VAR 0 3
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 1
8201: PUSH
8202: LD_INT 3
8204: PUSH
8205: LD_INT 43
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 24
8216: PUSH
8217: LD_INT 1
8219: PUSH
8220: LD_INT 3
8222: PUSH
8223: LD_INT 46
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 24
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: LD_INT 3
8240: PUSH
8241: LD_INT 43
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: PUSH
8250: LD_INT 24
8252: PUSH
8253: LD_INT 1
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: LD_INT 46
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: PUSH
8268: LD_INT 22
8270: PUSH
8271: LD_INT 1
8273: PUSH
8274: LD_INT 3
8276: PUSH
8277: LD_INT 45
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: LIST
8284: LIST
8285: PUSH
8286: LD_INT 22
8288: PUSH
8289: LD_INT 1
8291: PUSH
8292: LD_INT 3
8294: PUSH
8295: LD_INT 43
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: LIST
8302: LIST
8303: PUSH
8304: LD_INT 24
8306: PUSH
8307: LD_INT 1
8309: PUSH
8310: LD_INT 3
8312: PUSH
8313: LD_INT 46
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_INT 22
8324: PUSH
8325: LD_INT 1
8327: PUSH
8328: LD_INT 3
8330: PUSH
8331: LD_INT 45
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: LIST
8349: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_VAR 0 3
8359: PPUSH
8360: CALL 77545 0 2
// end ; 2 :
8364: GO 8735
8366: LD_INT 2
8368: DOUBLE
8369: EQUAL
8370: IFTRUE 8374
8372: GO 8550
8374: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8375: LD_ADDR_VAR 0 3
8379: PUSH
8380: LD_INT 24
8382: PUSH
8383: LD_INT 1
8385: PUSH
8386: LD_INT 3
8388: PUSH
8389: LD_INT 43
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 24
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: LD_INT 3
8406: PUSH
8407: LD_INT 46
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 24
8418: PUSH
8419: LD_INT 1
8421: PUSH
8422: LD_INT 3
8424: PUSH
8425: LD_INT 43
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 24
8436: PUSH
8437: LD_INT 1
8439: PUSH
8440: LD_INT 3
8442: PUSH
8443: LD_INT 46
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: LIST
8451: PUSH
8452: LD_INT 22
8454: PUSH
8455: LD_INT 1
8457: PUSH
8458: LD_INT 3
8460: PUSH
8461: LD_INT 45
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 22
8472: PUSH
8473: LD_INT 1
8475: PUSH
8476: LD_INT 3
8478: PUSH
8479: LD_INT 45
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 22
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 3
8496: PUSH
8497: LD_INT 45
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 1
8511: PUSH
8512: LD_INT 3
8514: PUSH
8515: LD_INT 45
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: LIST
8533: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8534: LD_VAR 0 2
8538: PPUSH
8539: LD_VAR 0 3
8543: PPUSH
8544: CALL 77545 0 2
// end ; 3 :
8548: GO 8735
8550: LD_INT 3
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8734
8558: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: LD_INT 22
8566: PUSH
8567: LD_INT 1
8569: PUSH
8570: LD_INT 3
8572: PUSH
8573: LD_INT 43
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_INT 24
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: LD_INT 3
8590: PUSH
8591: LD_INT 46
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 22
8602: PUSH
8603: LD_INT 1
8605: PUSH
8606: LD_INT 3
8608: PUSH
8609: LD_INT 43
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: LIST
8616: LIST
8617: PUSH
8618: LD_INT 24
8620: PUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: LD_INT 46
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: LIST
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: LD_INT 45
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: PUSH
8654: LD_INT 22
8656: PUSH
8657: LD_INT 1
8659: PUSH
8660: LD_INT 3
8662: PUSH
8663: LD_INT 43
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: LIST
8670: LIST
8671: PUSH
8672: LD_INT 24
8674: PUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: LD_INT 46
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 22
8692: PUSH
8693: LD_INT 1
8695: PUSH
8696: LD_INT 3
8698: PUSH
8699: LD_INT 45
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: LIST
8706: LIST
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8718: LD_VAR 0 2
8722: PPUSH
8723: LD_VAR 0 3
8727: PPUSH
8728: CALL 77545 0 2
// end ; end ;
8732: GO 8735
8734: POP
// repeat wait ( 0 0$1 ) ;
8735: LD_INT 35
8737: PPUSH
8738: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8742: LD_VAR 0 2
8746: PPUSH
8747: LD_INT 1
8749: PPUSH
8750: CALL 78963 0 2
8754: PUSH
8755: LD_INT 8
8757: GREATEREQUAL
8758: IFFALSE 8735
// wait ( 0 0$30 ) ;
8760: LD_INT 1050
8762: PPUSH
8763: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8767: LD_ADDR_VAR 0 5
8771: PUSH
8772: LD_INT 144
8774: PUSH
8775: LD_INT 65
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 63
8784: PUSH
8785: LD_INT 38
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: PUSH
8792: EMPTY
8793: LIST
8794: LIST
8795: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8796: LD_ADDR_VAR 0 4
8800: PUSH
8801: LD_INT 0
8803: PUSH
8804: LD_INT 0
8806: PUSH
8807: LD_INT 0
8809: PUSH
8810: LD_INT 1
8812: PUSH
8813: LD_INT 0
8815: PUSH
8816: LD_INT 0
8818: PUSH
8819: LD_INT 0
8821: PUSH
8822: LD_INT 0
8824: PUSH
8825: LD_INT 1
8827: PUSH
8828: LD_INT 0
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_EXP 88
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PUSH
8859: LD_EXP 91
8863: PUSH
8864: LD_VAR 0 2
8868: ARRAY
8869: DIFF
8870: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8871: LD_ADDR_EXP 88
8875: PUSH
8876: LD_EXP 88
8880: PPUSH
8881: LD_VAR 0 2
8885: PPUSH
8886: LD_EXP 88
8890: PUSH
8891: LD_VAR 0 2
8895: ARRAY
8896: PUSH
8897: LD_VAR 0 6
8901: DIFF
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// if not attackers then
8908: LD_VAR 0 6
8912: NOT
8913: IFFALSE 8917
// continue ;
8915: GO 8106
// repeat wait ( 0 0$1 ) ;
8917: LD_INT 35
8919: PPUSH
8920: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8924: LD_VAR 0 6
8928: PPUSH
8929: LD_INT 60
8931: PUSH
8932: EMPTY
8933: LIST
8934: PPUSH
8935: CALL_OW 72
8939: NOT
8940: IFFALSE 8917
// repeat wait ( 0 0$1 ) ;
8942: LD_INT 35
8944: PPUSH
8945: CALL_OW 67
// for i in attackers do
8949: LD_ADDR_VAR 0 1
8953: PUSH
8954: LD_VAR 0 6
8958: PUSH
8959: FOR_IN
8960: IFFALSE 9244
// begin if IsDead ( i ) then
8962: LD_VAR 0 1
8966: PPUSH
8967: CALL_OW 301
8971: IFFALSE 8989
// attackers := attackers diff i ;
8973: LD_ADDR_VAR 0 6
8977: PUSH
8978: LD_VAR 0 6
8982: PUSH
8983: LD_VAR 0 1
8987: DIFF
8988: ST_TO_ADDR
// if not HasTask ( i ) then
8989: LD_VAR 0 1
8993: PPUSH
8994: CALL_OW 314
8998: NOT
8999: IFFALSE 9242
// begin if not GetTag ( i ) then
9001: LD_VAR 0 1
9005: PPUSH
9006: CALL_OW 110
9010: NOT
9011: IFFALSE 9103
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
9013: LD_VAR 0 1
9017: PPUSH
9018: LD_VAR 0 5
9022: PUSH
9023: LD_INT 1
9025: ARRAY
9026: PUSH
9027: LD_INT 1
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 5
9035: PUSH
9036: LD_INT 1
9038: ARRAY
9039: PUSH
9040: LD_INT 2
9042: ARRAY
9043: PPUSH
9044: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
9048: LD_VAR 0 1
9052: PPUSH
9053: LD_VAR 0 5
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PUSH
9062: LD_INT 1
9064: ARRAY
9065: PPUSH
9066: LD_VAR 0 5
9070: PUSH
9071: LD_INT 1
9073: ARRAY
9074: PUSH
9075: LD_INT 2
9077: ARRAY
9078: PPUSH
9079: CALL_OW 297
9083: PUSH
9084: LD_INT 8
9086: LESS
9087: IFFALSE 9101
// SetTag ( i , 1 ) ;
9089: LD_VAR 0 1
9093: PPUSH
9094: LD_INT 1
9096: PPUSH
9097: CALL_OW 109
// end else
9101: GO 9242
// if GetTag ( i ) = 1 then
9103: LD_VAR 0 1
9107: PPUSH
9108: CALL_OW 110
9112: PUSH
9113: LD_INT 1
9115: EQUAL
9116: IFFALSE 9208
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
9118: LD_VAR 0 1
9122: PPUSH
9123: LD_VAR 0 5
9127: PUSH
9128: LD_INT 2
9130: ARRAY
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_VAR 0 5
9140: PUSH
9141: LD_INT 2
9143: ARRAY
9144: PUSH
9145: LD_INT 2
9147: ARRAY
9148: PPUSH
9149: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
9153: LD_VAR 0 1
9157: PPUSH
9158: LD_VAR 0 5
9162: PUSH
9163: LD_INT 2
9165: ARRAY
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 5
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PUSH
9180: LD_INT 2
9182: ARRAY
9183: PPUSH
9184: CALL_OW 297
9188: PUSH
9189: LD_INT 8
9191: LESS
9192: IFFALSE 9206
// SetTag ( i , 2 ) ;
9194: LD_VAR 0 1
9198: PPUSH
9199: LD_INT 2
9201: PPUSH
9202: CALL_OW 109
// end else
9206: GO 9242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9208: LD_VAR 0 1
9212: PPUSH
9213: LD_INT 81
9215: PUSH
9216: LD_INT 3
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: PPUSH
9223: CALL_OW 69
9227: PPUSH
9228: LD_VAR 0 1
9232: PPUSH
9233: CALL_OW 74
9237: PPUSH
9238: CALL_OW 115
// end ; end ;
9242: GO 8959
9244: POP
9245: POP
// until not attackers ;
9246: LD_VAR 0 6
9250: NOT
9251: IFFALSE 8942
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
9253: LD_EXP 69
9257: PUSH
9258: LD_VAR 0 2
9262: ARRAY
9263: PPUSH
9264: LD_INT 50
9266: PUSH
9267: EMPTY
9268: LIST
9269: PPUSH
9270: CALL_OW 72
9274: NOT
9275: IFFALSE 8106
// end ;
9277: PPOPN 6
9279: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9280: LD_EXP 4
9284: PUSH
9285: LD_INT 22
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 21
9297: PUSH
9298: LD_INT 1
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 69
9313: PUSH
9314: LD_INT 0
9316: EQUAL
9317: AND
9318: IFFALSE 9331
9320: GO 9322
9322: DISABLE
// RussiansDefeated := true ;
9323: LD_ADDR_EXP 44
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
9331: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
9332: LD_EXP 4
9336: PUSH
9337: LD_EXP 6
9341: NOT
9342: AND
9343: IFFALSE 10767
9345: GO 9347
9347: DISABLE
9348: LD_INT 0
9350: PPUSH
9351: PPUSH
9352: PPUSH
9353: PPUSH
9354: PPUSH
9355: PPUSH
9356: PPUSH
9357: PPUSH
9358: PPUSH
9359: PPUSH
9360: PPUSH
9361: PPUSH
// begin wait ( [ Rand ( 4 4$00 , 4 4$30 ) , Rand ( 4 4$30 , 3 3$30 ) , Rand ( 3 3$00 , 2 2$00 ) ] [ Difficulty ] ) ;
9362: LD_INT 8400
9364: PPUSH
9365: LD_INT 9450
9367: PPUSH
9368: CALL_OW 12
9372: PUSH
9373: LD_INT 9450
9375: PPUSH
9376: LD_INT 7350
9378: PPUSH
9379: CALL_OW 12
9383: PUSH
9384: LD_INT 6300
9386: PPUSH
9387: LD_INT 4200
9389: PPUSH
9390: CALL_OW 12
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: LD_OWVAR 67
9404: ARRAY
9405: PPUSH
9406: CALL_OW 67
// filter := [ ] ;
9410: LD_ADDR_VAR 0 3
9414: PUSH
9415: EMPTY
9416: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9417: LD_ADDR_VAR 0 4
9421: PUSH
9422: LD_INT 2
9424: PPUSH
9425: LD_INT 3
9427: PPUSH
9428: CALL_OW 12
9432: PUSH
9433: LD_INT 3
9435: PPUSH
9436: LD_INT 4
9438: PPUSH
9439: CALL_OW 12
9443: PUSH
9444: LD_INT 3
9446: PPUSH
9447: LD_INT 5
9449: PPUSH
9450: CALL_OW 12
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: LIST
9459: PUSH
9460: LD_OWVAR 67
9464: ARRAY
9465: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 1
9473: PUSH
9474: LD_INT 1
9476: PPUSH
9477: LD_INT 2
9479: PPUSH
9480: CALL_OW 12
9484: PUSH
9485: LD_INT 2
9487: PPUSH
9488: LD_INT 3
9490: PPUSH
9491: CALL_OW 12
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: LIST
9500: PUSH
9501: LD_OWVAR 67
9505: ARRAY
9506: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9507: LD_ADDR_VAR 0 6
9511: PUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: PUSH
9523: LD_INT 2
9525: PPUSH
9526: LD_INT 4
9528: PPUSH
9529: CALL_OW 12
9533: PUSH
9534: LD_INT 3
9536: PPUSH
9537: LD_INT 5
9539: PPUSH
9540: CALL_OW 12
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_OWVAR 67
9554: ARRAY
9555: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
9556: LD_ADDR_VAR 0 8
9560: PUSH
9561: LD_INT 1
9563: PUSH
9564: LD_INT 2
9566: PUSH
9567: LD_INT 2
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: LD_OWVAR 67
9579: ARRAY
9580: ST_TO_ADDR
// uc_side := 3 ;
9581: LD_ADDR_OWVAR 20
9585: PUSH
9586: LD_INT 3
9588: ST_TO_ADDR
// uc_nation := nation_russian ;
9589: LD_ADDR_OWVAR 21
9593: PUSH
9594: LD_INT 3
9596: ST_TO_ADDR
// for i = 1 to soldiers do
9597: LD_ADDR_VAR 0 1
9601: PUSH
9602: DOUBLE
9603: LD_INT 1
9605: DEC
9606: ST_TO_ADDR
9607: LD_VAR 0 4
9611: PUSH
9612: FOR_TO
9613: IFFALSE 9655
// begin PrepareSoldier ( 0 , game_eskill ) ;
9615: LD_INT 0
9617: PPUSH
9618: LD_EXP 40
9622: PPUSH
9623: CALL_OW 381
// un := CreateHuman ;
9627: LD_ADDR_VAR 0 2
9631: PUSH
9632: CALL_OW 44
9636: ST_TO_ADDR
// filter := filter ^ un ;
9637: LD_ADDR_VAR 0 3
9641: PUSH
9642: LD_VAR 0 3
9646: PUSH
9647: LD_VAR 0 2
9651: ADD
9652: ST_TO_ADDR
// end ;
9653: GO 9612
9655: POP
9656: POP
// for i = 1 to bazookas do
9657: LD_ADDR_VAR 0 1
9661: PUSH
9662: DOUBLE
9663: LD_INT 1
9665: DEC
9666: ST_TO_ADDR
9667: LD_VAR 0 5
9671: PUSH
9672: FOR_TO
9673: IFFALSE 9723
// begin PrepareSoldier ( 0 , game_eskill ) ;
9675: LD_INT 0
9677: PPUSH
9678: LD_EXP 40
9682: PPUSH
9683: CALL_OW 381
// hc_class := class_bazooker ;
9687: LD_ADDR_OWVAR 28
9691: PUSH
9692: LD_INT 9
9694: ST_TO_ADDR
// un := CreateHuman ;
9695: LD_ADDR_VAR 0 2
9699: PUSH
9700: CALL_OW 44
9704: ST_TO_ADDR
// filter := filter ^ un ;
9705: LD_ADDR_VAR 0 3
9709: PUSH
9710: LD_VAR 0 3
9714: PUSH
9715: LD_VAR 0 2
9719: ADD
9720: ST_TO_ADDR
// end ;
9721: GO 9672
9723: POP
9724: POP
// for i = 1 to medics do
9725: LD_ADDR_VAR 0 1
9729: PUSH
9730: DOUBLE
9731: LD_INT 1
9733: DEC
9734: ST_TO_ADDR
9735: LD_VAR 0 8
9739: PUSH
9740: FOR_TO
9741: IFFALSE 9783
// begin PrepareScientist ( 0 , game_eskill ) ;
9743: LD_INT 0
9745: PPUSH
9746: LD_EXP 40
9750: PPUSH
9751: CALL_OW 384
// un := CreateHuman ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: CALL_OW 44
9764: ST_TO_ADDR
// filter := filter ^ un ;
9765: LD_ADDR_VAR 0 3
9769: PUSH
9770: LD_VAR 0 3
9774: PUSH
9775: LD_VAR 0 2
9779: ADD
9780: ST_TO_ADDR
// end ;
9781: GO 9740
9783: POP
9784: POP
// for i = 1 to vehs do
9785: LD_ADDR_VAR 0 1
9789: PUSH
9790: DOUBLE
9791: LD_INT 1
9793: DEC
9794: ST_TO_ADDR
9795: LD_VAR 0 6
9799: PUSH
9800: FOR_TO
9801: IFFALSE 9993
// begin case Rand ( 1 , 5 ) of 1 :
9803: LD_INT 1
9805: PPUSH
9806: LD_INT 5
9808: PPUSH
9809: CALL_OW 12
9813: PUSH
9814: LD_INT 1
9816: DOUBLE
9817: EQUAL
9818: IFTRUE 9822
9820: GO 9844
9822: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
9823: LD_INT 22
9825: PPUSH
9826: LD_INT 3
9828: PPUSH
9829: LD_INT 3
9831: PPUSH
9832: LD_INT 43
9834: PPUSH
9835: LD_INT 100
9837: PPUSH
9838: CALL 18466 0 5
9842: GO 9965
9844: LD_INT 2
9846: DOUBLE
9847: EQUAL
9848: IFTRUE 9852
9850: GO 9874
9852: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
9853: LD_INT 22
9855: PPUSH
9856: LD_INT 3
9858: PPUSH
9859: LD_INT 3
9861: PPUSH
9862: LD_INT 44
9864: PPUSH
9865: LD_INT 100
9867: PPUSH
9868: CALL 18466 0 5
9872: GO 9965
9874: LD_INT 3
9876: DOUBLE
9877: EQUAL
9878: IFTRUE 9882
9880: GO 9904
9882: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
9883: LD_INT 22
9885: PPUSH
9886: LD_INT 3
9888: PPUSH
9889: LD_INT 3
9891: PPUSH
9892: LD_INT 45
9894: PPUSH
9895: LD_INT 100
9897: PPUSH
9898: CALL 18466 0 5
9902: GO 9965
9904: LD_INT 4
9906: DOUBLE
9907: EQUAL
9908: IFTRUE 9912
9910: GO 9934
9912: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
9913: LD_INT 24
9915: PPUSH
9916: LD_INT 3
9918: PPUSH
9919: LD_INT 3
9921: PPUSH
9922: LD_INT 43
9924: PPUSH
9925: LD_INT 100
9927: PPUSH
9928: CALL 18466 0 5
9932: GO 9965
9934: LD_INT 5
9936: DOUBLE
9937: EQUAL
9938: IFTRUE 9942
9940: GO 9964
9942: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
9943: LD_INT 24
9945: PPUSH
9946: LD_INT 3
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 46
9954: PPUSH
9955: LD_INT 100
9957: PPUSH
9958: CALL 18466 0 5
9962: GO 9965
9964: POP
// vehicle := CreateVehicle ;
9965: LD_ADDR_VAR 0 7
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// filter := filter ^ vehicle ;
9975: LD_ADDR_VAR 0 3
9979: PUSH
9980: LD_VAR 0 3
9984: PUSH
9985: LD_VAR 0 7
9989: ADD
9990: ST_TO_ADDR
// end ;
9991: GO 9800
9993: POP
9994: POP
// for i = 1 to filter do
9995: LD_ADDR_VAR 0 1
9999: PUSH
10000: DOUBLE
10001: LD_INT 1
10003: DEC
10004: ST_TO_ADDR
10005: LD_VAR 0 3
10009: PUSH
10010: FOR_TO
10011: IFFALSE 10036
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
10013: LD_VAR 0 3
10017: PUSH
10018: LD_VAR 0 1
10022: ARRAY
10023: PPUSH
10024: LD_INT 14
10026: PPUSH
10027: LD_INT 0
10029: PPUSH
10030: CALL_OW 49
10034: GO 10010
10036: POP
10037: POP
// case Rand ( 1 , 3 ) of 1 :
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 3
10043: PPUSH
10044: CALL_OW 12
10048: PUSH
10049: LD_INT 1
10051: DOUBLE
10052: EQUAL
10053: IFTRUE 10057
10055: GO 10111
10057: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
10058: LD_ADDR_VAR 0 11
10062: PUSH
10063: LD_INT 165
10065: PUSH
10066: LD_INT 114
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PUSH
10073: LD_INT 104
10075: PUSH
10076: LD_INT 108
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PUSH
10083: LD_INT 86
10085: PUSH
10086: LD_INT 77
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PUSH
10093: LD_INT 63
10095: PUSH
10096: LD_INT 38
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: ST_TO_ADDR
10109: GO 10236
10111: LD_INT 2
10113: DOUBLE
10114: EQUAL
10115: IFTRUE 10119
10117: GO 10173
10119: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
10120: LD_ADDR_VAR 0 11
10124: PUSH
10125: LD_INT 165
10127: PUSH
10128: LD_INT 114
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 146
10137: PUSH
10138: LD_INT 71
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: LD_INT 112
10147: PUSH
10148: LD_INT 41
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PUSH
10155: LD_INT 63
10157: PUSH
10158: LD_INT 38
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: ST_TO_ADDR
10171: GO 10236
10173: LD_INT 3
10175: DOUBLE
10176: EQUAL
10177: IFTRUE 10181
10179: GO 10235
10181: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
10182: LD_ADDR_VAR 0 11
10186: PUSH
10187: LD_INT 165
10189: PUSH
10190: LD_INT 114
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 63
10199: PUSH
10200: LD_INT 99
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 55
10209: PUSH
10210: LD_INT 77
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PUSH
10217: LD_INT 63
10219: PUSH
10220: LD_INT 38
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: ST_TO_ADDR
10233: GO 10236
10235: POP
// attackers := filter ;
10236: LD_ADDR_VAR 0 10
10240: PUSH
10241: LD_VAR 0 3
10245: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// for i in attackers do
10253: LD_ADDR_VAR 0 1
10257: PUSH
10258: LD_VAR 0 10
10262: PUSH
10263: FOR_IN
10264: IFFALSE 10758
// begin if IsDead ( i ) then
10266: LD_VAR 0 1
10270: PPUSH
10271: CALL_OW 301
10275: IFFALSE 10293
// attackers := attackers diff i ;
10277: LD_ADDR_VAR 0 10
10281: PUSH
10282: LD_VAR 0 10
10286: PUSH
10287: LD_VAR 0 1
10291: DIFF
10292: ST_TO_ADDR
// if not HasTask ( i ) then
10293: LD_VAR 0 1
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10756
// begin if not GetTag ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 110
10314: NOT
10315: IFFALSE 10407
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
10317: LD_VAR 0 1
10321: PPUSH
10322: LD_VAR 0 11
10326: PUSH
10327: LD_INT 1
10329: ARRAY
10330: PUSH
10331: LD_INT 1
10333: ARRAY
10334: PPUSH
10335: LD_VAR 0 11
10339: PUSH
10340: LD_INT 1
10342: ARRAY
10343: PUSH
10344: LD_INT 2
10346: ARRAY
10347: PPUSH
10348: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
10352: LD_VAR 0 1
10356: PPUSH
10357: LD_VAR 0 11
10361: PUSH
10362: LD_INT 1
10364: ARRAY
10365: PUSH
10366: LD_INT 1
10368: ARRAY
10369: PPUSH
10370: LD_VAR 0 11
10374: PUSH
10375: LD_INT 1
10377: ARRAY
10378: PUSH
10379: LD_INT 2
10381: ARRAY
10382: PPUSH
10383: CALL_OW 297
10387: PUSH
10388: LD_INT 8
10390: LESS
10391: IFFALSE 10405
// SetTag ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 109
// end else
10405: GO 10756
// if GetTag ( i ) = 1 then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 110
10416: PUSH
10417: LD_INT 1
10419: EQUAL
10420: IFFALSE 10512
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
10422: LD_VAR 0 1
10426: PPUSH
10427: LD_VAR 0 11
10431: PUSH
10432: LD_INT 2
10434: ARRAY
10435: PUSH
10436: LD_INT 1
10438: ARRAY
10439: PPUSH
10440: LD_VAR 0 11
10444: PUSH
10445: LD_INT 2
10447: ARRAY
10448: PUSH
10449: LD_INT 2
10451: ARRAY
10452: PPUSH
10453: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
10457: LD_VAR 0 1
10461: PPUSH
10462: LD_VAR 0 11
10466: PUSH
10467: LD_INT 2
10469: ARRAY
10470: PUSH
10471: LD_INT 1
10473: ARRAY
10474: PPUSH
10475: LD_VAR 0 11
10479: PUSH
10480: LD_INT 2
10482: ARRAY
10483: PUSH
10484: LD_INT 2
10486: ARRAY
10487: PPUSH
10488: CALL_OW 297
10492: PUSH
10493: LD_INT 8
10495: LESS
10496: IFFALSE 10510
// SetTag ( i , 2 ) ;
10498: LD_VAR 0 1
10502: PPUSH
10503: LD_INT 2
10505: PPUSH
10506: CALL_OW 109
// end else
10510: GO 10756
// if GetTag ( i ) = 2 then
10512: LD_VAR 0 1
10516: PPUSH
10517: CALL_OW 110
10521: PUSH
10522: LD_INT 2
10524: EQUAL
10525: IFFALSE 10617
// begin ComAgressiveMove ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) ;
10527: LD_VAR 0 1
10531: PPUSH
10532: LD_VAR 0 11
10536: PUSH
10537: LD_INT 3
10539: ARRAY
10540: PUSH
10541: LD_INT 1
10543: ARRAY
10544: PPUSH
10545: LD_VAR 0 11
10549: PUSH
10550: LD_INT 3
10552: ARRAY
10553: PUSH
10554: LD_INT 2
10556: ARRAY
10557: PPUSH
10558: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) < 8 then
10562: LD_VAR 0 1
10566: PPUSH
10567: LD_VAR 0 11
10571: PUSH
10572: LD_INT 3
10574: ARRAY
10575: PUSH
10576: LD_INT 1
10578: ARRAY
10579: PPUSH
10580: LD_VAR 0 11
10584: PUSH
10585: LD_INT 3
10587: ARRAY
10588: PUSH
10589: LD_INT 2
10591: ARRAY
10592: PPUSH
10593: CALL_OW 297
10597: PUSH
10598: LD_INT 8
10600: LESS
10601: IFFALSE 10615
// SetTag ( i , 3 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_INT 3
10610: PPUSH
10611: CALL_OW 109
// end else
10615: GO 10756
// if GetTag ( i ) = 3 then
10617: LD_VAR 0 1
10621: PPUSH
10622: CALL_OW 110
10626: PUSH
10627: LD_INT 3
10629: EQUAL
10630: IFFALSE 10722
// begin ComAgressiveMove ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) ;
10632: LD_VAR 0 1
10636: PPUSH
10637: LD_VAR 0 11
10641: PUSH
10642: LD_INT 4
10644: ARRAY
10645: PUSH
10646: LD_INT 1
10648: ARRAY
10649: PPUSH
10650: LD_VAR 0 11
10654: PUSH
10655: LD_INT 4
10657: ARRAY
10658: PUSH
10659: LD_INT 2
10661: ARRAY
10662: PPUSH
10663: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) < 8 then
10667: LD_VAR 0 1
10671: PPUSH
10672: LD_VAR 0 11
10676: PUSH
10677: LD_INT 4
10679: ARRAY
10680: PUSH
10681: LD_INT 1
10683: ARRAY
10684: PPUSH
10685: LD_VAR 0 11
10689: PUSH
10690: LD_INT 4
10692: ARRAY
10693: PUSH
10694: LD_INT 2
10696: ARRAY
10697: PPUSH
10698: CALL_OW 297
10702: PUSH
10703: LD_INT 8
10705: LESS
10706: IFFALSE 10720
// SetTag ( i , 4 ) ;
10708: LD_VAR 0 1
10712: PPUSH
10713: LD_INT 4
10715: PPUSH
10716: CALL_OW 109
// end else
10720: GO 10756
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10722: LD_VAR 0 1
10726: PPUSH
10727: LD_INT 81
10729: PUSH
10730: LD_INT 3
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PPUSH
10737: CALL_OW 69
10741: PPUSH
10742: LD_VAR 0 1
10746: PPUSH
10747: CALL_OW 74
10751: PPUSH
10752: CALL_OW 115
// end ; end ;
10756: GO 10263
10758: POP
10759: POP
// until not attackers ;
10760: LD_VAR 0 10
10764: NOT
10765: IFFALSE 10246
// end ;
10767: PPOPN 12
10769: END
// every 0 0$1 do var i , tmp ;
10770: GO 10772
10772: DISABLE
10773: LD_INT 0
10775: PPUSH
10776: PPUSH
// begin enable ;
10777: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
10778: LD_ADDR_VAR 0 2
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: LD_INT 22
10788: PUSH
10789: LD_INT 1
10791: PUSH
10792: EMPTY
10793: LIST
10794: LIST
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 32
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 69
10818: ST_TO_ADDR
// if tmp then
10819: LD_VAR 0 2
10823: IFFALSE 10869
// for i in tmp do
10825: LD_ADDR_VAR 0 1
10829: PUSH
10830: LD_VAR 0 2
10834: PUSH
10835: FOR_IN
10836: IFFALSE 10867
// if GetFuel ( i ) < 3 then
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 261
10847: PUSH
10848: LD_INT 3
10850: LESS
10851: IFFALSE 10865
// SetFuel ( i , 3 ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: LD_INT 3
10860: PPUSH
10861: CALL_OW 240
10865: GO 10835
10867: POP
10868: POP
// end ;
10869: PPOPN 2
10871: END
// every 0 0$1 trigger ( FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) and not JMMArrival ) or ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) and not FirstAssaultRepelled ) do
10872: LD_INT 3
10874: PPUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 1
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PPUSH
10885: CALL_OW 70
10889: PUSH
10890: LD_EXP 41
10894: NOT
10895: AND
10896: PUSH
10897: LD_INT 10
10899: PPUSH
10900: LD_INT 22
10902: PUSH
10903: LD_INT 1
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PPUSH
10910: CALL_OW 70
10914: PUSH
10915: LD_EXP 4
10919: NOT
10920: AND
10921: OR
10922: IFFALSE 10931
10924: GO 10926
10926: DISABLE
// Antirush ;
10927: CALL 10932 0 0
10931: END
// export function Antirush ; var i , veh , tmp , num ; begin
10932: LD_INT 0
10934: PPUSH
10935: PPUSH
10936: PPUSH
10937: PPUSH
10938: PPUSH
// tmp := [ ] ;
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: EMPTY
10945: ST_TO_ADDR
// if not FirstAssaultRepelled then
10946: LD_EXP 4
10950: NOT
10951: IFFALSE 10963
// num := 12 else
10953: LD_ADDR_VAR 0 5
10957: PUSH
10958: LD_INT 12
10960: ST_TO_ADDR
10961: GO 10971
// num := 10 ;
10963: LD_ADDR_VAR 0 5
10967: PUSH
10968: LD_INT 10
10970: ST_TO_ADDR
// num := num - [ 4 , 2 , 0 ] [ Difficulty ] ;
10971: LD_ADDR_VAR 0 5
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: LD_INT 4
10983: PUSH
10984: LD_INT 2
10986: PUSH
10987: LD_INT 0
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_OWVAR 67
10999: ARRAY
11000: MINUS
11001: ST_TO_ADDR
// for i := 1 to num do
11002: LD_ADDR_VAR 0 2
11006: PUSH
11007: DOUBLE
11008: LD_INT 1
11010: DEC
11011: ST_TO_ADDR
11012: LD_VAR 0 5
11016: PUSH
11017: FOR_TO
11018: IFFALSE 11157
// begin uc_side := 3 ;
11020: LD_ADDR_OWVAR 20
11024: PUSH
11025: LD_INT 3
11027: ST_TO_ADDR
// uc_nation := 3 ;
11028: LD_ADDR_OWVAR 21
11032: PUSH
11033: LD_INT 3
11035: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
11036: LD_INT 23
11038: PPUSH
11039: LD_INT 3
11041: PPUSH
11042: LD_INT 3
11044: PPUSH
11045: LD_INT 46
11047: PUSH
11048: LD_INT 43
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: PUSH
11055: LD_INT 1
11057: PPUSH
11058: LD_INT 2
11060: PPUSH
11061: CALL_OW 12
11065: ARRAY
11066: PPUSH
11067: LD_INT 100
11069: PPUSH
11070: CALL 18466 0 5
// veh := CreateVehicle ;
11074: LD_ADDR_VAR 0 3
11078: PUSH
11079: CALL_OW 45
11083: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
11084: LD_VAR 0 3
11088: PPUSH
11089: LD_INT 5
11091: PPUSH
11092: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
11096: LD_VAR 0 3
11100: PPUSH
11101: LD_INT 199
11103: PPUSH
11104: LD_INT 135
11106: PPUSH
11107: LD_INT 3
11109: PPUSH
11110: LD_INT 0
11112: PPUSH
11113: CALL_OW 50
// tmp := tmp ^ veh ;
11117: LD_ADDR_VAR 0 4
11121: PUSH
11122: LD_VAR 0 4
11126: PUSH
11127: LD_VAR 0 3
11131: ADD
11132: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
11133: LD_VAR 0 3
11137: PPUSH
11138: LD_INT 173
11140: PPUSH
11141: LD_INT 118
11143: PPUSH
11144: CALL_OW 111
// wait ( 0 0$2 ) ;
11148: LD_INT 70
11150: PPUSH
11151: CALL_OW 67
// end ;
11155: GO 11017
11157: POP
11158: POP
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// for i in tmp do
11166: LD_ADDR_VAR 0 2
11170: PUSH
11171: LD_VAR 0 4
11175: PUSH
11176: FOR_IN
11177: IFFALSE 11244
// if IsDead ( i ) then
11179: LD_VAR 0 2
11183: PPUSH
11184: CALL_OW 301
11188: IFFALSE 11208
// tmp := tmp diff i else
11190: LD_ADDR_VAR 0 4
11194: PUSH
11195: LD_VAR 0 4
11199: PUSH
11200: LD_VAR 0 2
11204: DIFF
11205: ST_TO_ADDR
11206: GO 11242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 22
11215: PUSH
11216: LD_INT 1
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PPUSH
11223: CALL_OW 69
11227: PPUSH
11228: LD_VAR 0 2
11232: PPUSH
11233: CALL_OW 74
11237: PPUSH
11238: CALL_OW 115
11242: GO 11176
11244: POP
11245: POP
// until not tmp ;
11246: LD_VAR 0 4
11250: NOT
11251: IFFALSE 11159
// end ; end_of_file
11253: LD_VAR 0 1
11257: RET
// export Losses ; on UnitDestroyed ( un ) do begin if un = Brighton then
11258: LD_VAR 0 1
11262: PUSH
11263: LD_EXP 9
11267: EQUAL
11268: IFFALSE 11284
// begin wait ( 0 0$1 ) ;
11270: LD_INT 35
11272: PPUSH
11273: CALL_OW 67
// YouLost ( Brighton ) ;
11277: LD_STRING Brighton
11279: PPUSH
11280: CALL_OW 104
// end ; if un = JMM then
11284: LD_VAR 0 1
11288: PUSH
11289: LD_EXP 37
11293: EQUAL
11294: IFFALSE 11310
// begin wait ( 0 0$1 ) ;
11296: LD_INT 35
11298: PPUSH
11299: CALL_OW 67
// YouLost ( JMM ) ;
11303: LD_STRING JMM
11305: PPUSH
11306: CALL_OW 104
// end ; if un = Megan then
11310: LD_VAR 0 1
11314: PUSH
11315: LD_EXP 11
11319: EQUAL
11320: IFFALSE 11334
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
11322: LD_EXP 9
11326: PPUSH
11327: LD_STRING DBrighton-MeganDeath
11329: PPUSH
11330: CALL_OW 88
// end ; if un = Palmer then
11334: LD_VAR 0 1
11338: PUSH
11339: LD_EXP 10
11343: EQUAL
11344: IFFALSE 11358
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
11346: LD_EXP 9
11350: PPUSH
11351: LD_STRING DBrighton-PalmerDeath
11353: PPUSH
11354: CALL_OW 88
// end ; if un = Burlak then
11358: LD_VAR 0 1
11362: PUSH
11363: LD_EXP 19
11367: EQUAL
11368: IFFALSE 11400
// begin if JMM_Arrived then
11370: LD_EXP 6
11374: IFFALSE 11388
// Say ( JMM , DJMM-BurlakDead ) ;
11376: LD_EXP 37
11380: PPUSH
11381: LD_STRING DJMM-BurlakDead
11383: PPUSH
11384: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
11388: LD_EXP 10
11392: PPUSH
11393: LD_STRING DSol-BurlakDead
11395: PPUSH
11396: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
11400: LD_VAR 0 1
11404: PUSH
11405: LD_INT 1
11407: EQUAL
11408: PUSH
11409: LD_VAR 0 1
11413: PUSH
11414: LD_INT 3
11416: EQUAL
11417: OR
11418: IFFALSE 11434
// begin wait ( 0 0$1 ) ;
11420: LD_INT 35
11422: PPUSH
11423: CALL_OW 67
// YouLost ( Depot ) ;
11427: LD_STRING Depot
11429: PPUSH
11430: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
11434: LD_VAR 0 1
11438: PPUSH
11439: CALL_OW 255
11443: PUSH
11444: LD_INT 1
11446: EQUAL
11447: PUSH
11448: LD_VAR 0 1
11452: PPUSH
11453: CALL_OW 247
11457: PUSH
11458: LD_INT 1
11460: EQUAL
11461: AND
11462: IFFALSE 11478
// Losses := Losses + 1 ;
11464: LD_ADDR_EXP 45
11468: PUSH
11469: LD_EXP 45
11473: PUSH
11474: LD_INT 1
11476: PLUS
11477: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11478: LD_VAR 0 1
11482: PPUSH
11483: CALL 80965 0 1
// end ;
11487: PPOPN 1
11489: END
// on UnitGoesToRed ( un ) do begin if GetType ( un ) = unit_vehicle and un in RUArmada then
11490: LD_VAR 0 1
11494: PPUSH
11495: CALL_OW 247
11499: PUSH
11500: LD_INT 2
11502: EQUAL
11503: PUSH
11504: LD_VAR 0 1
11508: PUSH
11509: LD_EXP 17
11513: IN
11514: AND
11515: IFFALSE 11529
// SetLives ( un , 0 ) ;
11517: LD_VAR 0 1
11521: PPUSH
11522: LD_INT 0
11524: PPUSH
11525: CALL_OW 234
// if un = Yashin then
11529: LD_VAR 0 1
11533: PUSH
11534: LD_EXP 13
11538: EQUAL
11539: IFFALSE 11553
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
11541: LD_EXP 13
11545: PPUSH
11546: LD_STRING DDeath-Yas-3
11548: PPUSH
11549: CALL_OW 91
// if un = Popov then
11553: LD_VAR 0 1
11557: PUSH
11558: LD_EXP 14
11562: EQUAL
11563: IFFALSE 11577
// ForceSay ( Popov , DDeath-Pop-3 ) ;
11565: LD_EXP 14
11569: PPUSH
11570: LD_STRING DDeath-Pop-3
11572: PPUSH
11573: CALL_OW 91
// if un = Gaydar then
11577: LD_VAR 0 1
11581: PUSH
11582: LD_EXP 15
11586: EQUAL
11587: IFFALSE 11601
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
11589: LD_EXP 15
11593: PPUSH
11594: LD_STRING DDeath-Gay-3
11596: PPUSH
11597: CALL_OW 91
// if un = Sevi then
11601: LD_VAR 0 1
11605: PUSH
11606: LD_EXP 16
11610: EQUAL
11611: IFFALSE 11625
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
11613: LD_EXP 16
11617: PPUSH
11618: LD_STRING DDeath-Vse-3
11620: PPUSH
11621: CALL_OW 91
// end ;
11625: PPOPN 1
11627: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
11628: LD_VAR 0 1
11632: PUSH
11633: LD_INT 10
11635: EQUAL
11636: IFFALSE 11674
// begin Say ( Brighton , DBrighton-C1 ) ;
11638: LD_EXP 9
11642: PPUSH
11643: LD_STRING DBrighton-C1
11645: PPUSH
11646: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
11650: LD_EXP 11
11654: PPUSH
11655: LD_STRING DMegan-C1
11657: PPUSH
11658: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
11662: LD_EXP 9
11666: PPUSH
11667: LD_STRING DBrighton-C2
11669: PPUSH
11670: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
11674: LD_VAR 0 1
11678: PPUSH
11679: LD_VAR 0 2
11683: PPUSH
11684: CALL 80661 0 2
// end ;
11688: PPOPN 2
11690: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11691: LD_VAR 0 1
11695: PPUSH
11696: LD_VAR 0 2
11700: PPUSH
11701: CALL 83299 0 2
// end ;
11705: PPOPN 2
11707: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11708: LD_VAR 0 1
11712: PPUSH
11713: CALL 82367 0 1
// end ;
11717: PPOPN 1
11719: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
11720: LD_VAR 0 1
11724: PPUSH
11725: CALL_OW 266
11729: PUSH
11730: LD_INT 0
11732: EQUAL
11733: PUSH
11734: LD_VAR 0 1
11738: PPUSH
11739: CALL_OW 255
11743: PUSH
11744: LD_INT 3
11746: EQUAL
11747: AND
11748: IFFALSE 11810
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
11750: LD_VAR 0 1
11754: PPUSH
11755: CALL_OW 274
11759: PPUSH
11760: LD_INT 1
11762: PPUSH
11763: LD_INT 10000
11765: PPUSH
11766: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
11770: LD_VAR 0 1
11774: PPUSH
11775: CALL_OW 274
11779: PPUSH
11780: LD_INT 2
11782: PPUSH
11783: LD_INT 250
11785: PPUSH
11786: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
11790: LD_VAR 0 1
11794: PPUSH
11795: CALL_OW 274
11799: PPUSH
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 100
11805: PPUSH
11806: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
11810: LD_VAR 0 1
11814: PPUSH
11815: CALL 82608 0 1
// end ;
11819: PPOPN 1
11821: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11822: LD_VAR 0 1
11826: PPUSH
11827: LD_VAR 0 2
11831: PPUSH
11832: LD_VAR 0 3
11836: PPUSH
11837: LD_VAR 0 4
11841: PPUSH
11842: LD_VAR 0 5
11846: PPUSH
11847: CALL 80281 0 5
// end ;
11851: PPOPN 5
11853: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11854: LD_VAR 0 1
11858: PPUSH
11859: LD_VAR 0 2
11863: PPUSH
11864: CALL 79862 0 2
// end ;
11868: PPOPN 2
11870: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11871: LD_VAR 0 1
11875: PPUSH
11876: LD_VAR 0 2
11880: PPUSH
11881: LD_VAR 0 3
11885: PPUSH
11886: LD_VAR 0 4
11890: PPUSH
11891: CALL 79700 0 4
// end ;
11895: PPOPN 4
11897: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11898: LD_VAR 0 1
11902: PPUSH
11903: LD_VAR 0 2
11907: PPUSH
11908: LD_VAR 0 3
11912: PPUSH
11913: CALL 79475 0 3
// end ;
11917: PPOPN 3
11919: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11920: LD_VAR 0 1
11924: PPUSH
11925: LD_VAR 0 2
11929: PPUSH
11930: CALL 79360 0 2
// end ;
11934: PPOPN 2
11936: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11937: LD_VAR 0 1
11941: PPUSH
11942: LD_VAR 0 2
11946: PPUSH
11947: CALL 83594 0 2
// end ;
11951: PPOPN 2
11953: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
11954: LD_VAR 0 1
11958: PPUSH
11959: CALL_OW 255
11963: PUSH
11964: LD_INT 6
11966: EQUAL
11967: IFFALSE 12097
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
11969: LD_VAR 0 1
11973: PUSH
11974: LD_EXP 13
11978: PUSH
11979: LD_EXP 16
11983: PUSH
11984: LD_EXP 15
11988: PUSH
11989: LD_EXP 14
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: IN
12000: IFFALSE 12004
// exit ;
12002: GO 12121
// if AssaultStarted then
12004: LD_EXP 8
12008: IFFALSE 12082
// case Rand ( 1 , 4 ) of 1 .. 3 :
12010: LD_INT 1
12012: PPUSH
12013: LD_INT 4
12015: PPUSH
12016: CALL_OW 12
12020: PUSH
12021: LD_INT 1
12023: DOUBLE
12024: GREATEREQUAL
12025: IFFALSE 12033
12027: LD_INT 3
12029: DOUBLE
12030: LESSEQUAL
12031: IFTRUE 12035
12033: GO 12053
12035: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
12036: LD_VAR 0 1
12040: PPUSH
12041: LD_INT 67
12043: PPUSH
12044: LD_INT 37
12046: PPUSH
12047: CALL_OW 114
12051: GO 12080
12053: LD_INT 4
12055: DOUBLE
12056: EQUAL
12057: IFTRUE 12061
12059: GO 12079
12061: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
12062: LD_VAR 0 1
12066: PPUSH
12067: LD_INT 120
12069: PPUSH
12070: LD_INT 131
12072: PPUSH
12073: CALL_OW 111
12077: GO 12080
12079: POP
12080: GO 12097
// ComMoveXY ( driver , 120 , 131 ) ;
12082: LD_VAR 0 1
12086: PPUSH
12087: LD_INT 120
12089: PPUSH
12090: LD_INT 131
12092: PPUSH
12093: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12097: LD_VAR 0 1
12101: PPUSH
12102: LD_VAR 0 2
12106: PPUSH
12107: LD_VAR 0 3
12111: PPUSH
12112: LD_VAR 0 4
12116: PPUSH
12117: CALL 83810 0 4
// end ;
12121: PPOPN 4
12123: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12124: LD_VAR 0 1
12128: PPUSH
12129: LD_VAR 0 2
12133: PPUSH
12134: CALL 79169 0 2
// end ;
12138: PPOPN 2
12140: END
// on Command ( cmd ) do var i ;
12141: LD_INT 0
12143: PPUSH
// begin if cmd = 77 and southAreaBlocker then
12144: LD_VAR 0 1
12148: PUSH
12149: LD_INT 77
12151: EQUAL
12152: PUSH
12153: LD_EXP 2
12157: AND
12158: IFFALSE 12234
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12160: LD_ADDR_VAR 0 2
12164: PUSH
12165: LD_INT 22
12167: PUSH
12168: LD_INT 1
12170: PUSH
12171: EMPTY
12172: LIST
12173: LIST
12174: PUSH
12175: LD_INT 2
12177: PUSH
12178: LD_INT 21
12180: PUSH
12181: LD_INT 1
12183: PUSH
12184: EMPTY
12185: LIST
12186: LIST
12187: PUSH
12188: LD_INT 21
12190: PUSH
12191: LD_INT 2
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: LIST
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PPUSH
12207: CALL_OW 69
12211: PUSH
12212: FOR_IN
12213: IFFALSE 12232
// NotGoToAreaUnit ( i , SouthAreaBlock , SouthAreaGoAway ) ;
12215: LD_VAR 0 2
12219: PPUSH
12220: LD_INT 20
12222: PPUSH
12223: LD_INT 19
12225: PPUSH
12226: CALL 50993 0 3
12230: GO 12212
12232: POP
12233: POP
// end ; SOS_Command ( cmd ) ;
12234: LD_VAR 0 1
12238: PPUSH
12239: CALL 97842 0 1
// end ;
12243: PPOPN 2
12245: END
// every 0 0$1 trigger southAreaBlocker and FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do var i ;
12246: LD_EXP 2
12250: PUSH
12251: LD_INT 16
12253: PPUSH
12254: LD_INT 22
12256: PUSH
12257: LD_INT 1
12259: PUSH
12260: EMPTY
12261: LIST
12262: LIST
12263: PUSH
12264: LD_INT 2
12266: PUSH
12267: LD_INT 21
12269: PUSH
12270: LD_INT 1
12272: PUSH
12273: EMPTY
12274: LIST
12275: LIST
12276: PUSH
12277: LD_INT 21
12279: PUSH
12280: LD_INT 2
12282: PUSH
12283: EMPTY
12284: LIST
12285: LIST
12286: PUSH
12287: EMPTY
12288: LIST
12289: LIST
12290: LIST
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PPUSH
12296: CALL_OW 70
12300: AND
12301: IFFALSE 12387
12303: GO 12305
12305: DISABLE
12306: LD_INT 0
12308: PPUSH
// begin enable ;
12309: ENABLE
// for i in FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12310: LD_ADDR_VAR 0 1
12314: PUSH
12315: LD_INT 16
12317: PPUSH
12318: LD_INT 22
12320: PUSH
12321: LD_INT 1
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PUSH
12328: LD_INT 2
12330: PUSH
12331: LD_INT 21
12333: PUSH
12334: LD_INT 1
12336: PUSH
12337: EMPTY
12338: LIST
12339: LIST
12340: PUSH
12341: LD_INT 21
12343: PUSH
12344: LD_INT 2
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: PUSH
12351: EMPTY
12352: LIST
12353: LIST
12354: LIST
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PPUSH
12360: CALL_OW 70
12364: PUSH
12365: FOR_IN
12366: IFFALSE 12385
// NotGoToAreaUnit ( i , SouthAreaOutside , SouthAreaGoAway ) ;
12368: LD_VAR 0 1
12372: PPUSH
12373: LD_INT 18
12375: PPUSH
12376: LD_INT 19
12378: PPUSH
12379: CALL 50993 0 3
12383: GO 12365
12385: POP
12386: POP
// end ; end_of_file
12387: PPOPN 1
12389: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
12390: LD_EXP 6
12394: PUSH
12395: LD_EXP 44
12399: AND
12400: IFFALSE 12571
12402: GO 12404
12404: DISABLE
// begin wait ( 0 0$2 ) ;
12405: LD_INT 70
12407: PPUSH
12408: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
12412: LD_EXP 9
12416: PPUSH
12417: LD_STRING DBrighton-G1
12419: PPUSH
12420: CALL_OW 88
// if Losses < 1 then
12424: LD_EXP 45
12428: PUSH
12429: LD_INT 1
12431: LESS
12432: IFFALSE 12446
// AddMedal ( Losses , 1 ) else
12434: LD_STRING Losses
12436: PPUSH
12437: LD_INT 1
12439: PPUSH
12440: CALL_OW 101
12444: GO 12479
// if Losses < 5 then
12446: LD_EXP 45
12450: PUSH
12451: LD_INT 5
12453: LESS
12454: IFFALSE 12468
// AddMedal ( Losses , 2 ) else
12456: LD_STRING Losses
12458: PPUSH
12459: LD_INT 2
12461: PPUSH
12462: CALL_OW 101
12466: GO 12479
// AddMedal ( Losses , - 1 ) ;
12468: LD_STRING Losses
12470: PPUSH
12471: LD_INT 1
12473: NEG
12474: PPUSH
12475: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12479: LD_EXP 7
12483: PUSH
12484: LD_INT 10
12486: PPUSH
12487: LD_INT 1
12489: PPUSH
12490: CALL_OW 321
12494: PUSH
12495: LD_INT 2
12497: EQUAL
12498: AND
12499: IFFALSE 12513
// AddMedal ( Laser , 1 ) else
12501: LD_STRING Laser
12503: PPUSH
12504: LD_INT 1
12506: PPUSH
12507: CALL_OW 101
12511: GO 12560
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12513: LD_EXP 7
12517: NOT
12518: PUSH
12519: LD_INT 10
12521: PPUSH
12522: LD_INT 1
12524: PPUSH
12525: CALL_OW 321
12529: PUSH
12530: LD_INT 2
12532: EQUAL
12533: AND
12534: IFFALSE 12549
// AddMedal ( Laser , - 1 ) else
12536: LD_STRING Laser
12538: PPUSH
12539: LD_INT 1
12541: NEG
12542: PPUSH
12543: CALL_OW 101
12547: GO 12560
// AddMedal ( Laser , - 2 ) ;
12549: LD_STRING Laser
12551: PPUSH
12552: LD_INT 2
12554: NEG
12555: PPUSH
12556: CALL_OW 101
// GiveMedals ( BaseMain ) ;
12560: LD_STRING BaseMain
12562: PPUSH
12563: CALL_OW 102
// YouWin ;
12567: CALL_OW 103
// end ; end_of_file
12571: END
// export rows ; export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
12572: LD_INT 0
12574: PPUSH
12575: PPUSH
// area = ListEnvironmentArea ( area ) ;
12576: LD_ADDR_VAR 0 2
12580: PUSH
12581: LD_VAR 0 2
12585: PPUSH
12586: CALL_OW 353
12590: ST_TO_ADDR
// if bulldozer > 0 then
12591: LD_VAR 0 1
12595: PUSH
12596: LD_INT 0
12598: GREATER
12599: IFFALSE 12710
// for i = area downto 1 do
12601: LD_ADDR_VAR 0 4
12605: PUSH
12606: DOUBLE
12607: LD_VAR 0 2
12611: INC
12612: ST_TO_ADDR
12613: LD_INT 1
12615: PUSH
12616: FOR_DOWNTO
12617: IFFALSE 12708
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
12619: LD_VAR 0 2
12623: PUSH
12624: LD_VAR 0 4
12628: ARRAY
12629: PUSH
12630: LD_INT 1
12632: ARRAY
12633: PPUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_VAR 0 4
12643: ARRAY
12644: PUSH
12645: LD_INT 2
12647: ARRAY
12648: PPUSH
12649: CALL_OW 351
12653: IFFALSE 12706
// if not HasTask ( bulldozer ) then
12655: LD_VAR 0 1
12659: PPUSH
12660: CALL_OW 314
12664: NOT
12665: IFFALSE 12706
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
12667: LD_VAR 0 1
12671: PPUSH
12672: LD_VAR 0 2
12676: PUSH
12677: LD_VAR 0 4
12681: ARRAY
12682: PUSH
12683: LD_INT 1
12685: ARRAY
12686: PPUSH
12687: LD_VAR 0 2
12691: PUSH
12692: LD_VAR 0 4
12696: ARRAY
12697: PUSH
12698: LD_INT 2
12700: ARRAY
12701: PPUSH
12702: CALL_OW 171
12706: GO 12616
12708: POP
12709: POP
// end ;
12710: LD_VAR 0 3
12714: RET
// export function ComMeeting ( team , area ) ; var i , x , tmp , offset , sold_team , civil_team ; begin
12715: LD_INT 0
12717: PPUSH
12718: PPUSH
12719: PPUSH
12720: PPUSH
12721: PPUSH
12722: PPUSH
12723: PPUSH
// sold_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , class_soldier ] ] ) ;
12724: LD_ADDR_VAR 0 8
12728: PUSH
12729: LD_VAR 0 1
12733: PPUSH
12734: LD_INT 22
12736: PUSH
12737: LD_INT 1
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: PUSH
12744: LD_INT 21
12746: PUSH
12747: LD_INT 1
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 25
12756: PUSH
12757: LD_INT 1
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: LIST
12768: PPUSH
12769: CALL_OW 72
12773: ST_TO_ADDR
// civil_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , class_soldier ] ] ] ) ;
12774: LD_ADDR_VAR 0 9
12778: PUSH
12779: LD_VAR 0 1
12783: PPUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 1
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 21
12796: PUSH
12797: LD_INT 1
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 3
12806: PUSH
12807: LD_INT 25
12809: PUSH
12810: LD_INT 1
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: LIST
12825: PPUSH
12826: CALL_OW 72
12830: ST_TO_ADDR
// rows = MakeRows ( sold_team , civil_team ) ;
12831: LD_ADDR_EXP 47
12835: PUSH
12836: LD_VAR 0 8
12840: PPUSH
12841: LD_VAR 0 9
12845: PPUSH
12846: CALL 13239 0 2
12850: ST_TO_ADDR
// offset = 0 ;
12851: LD_ADDR_VAR 0 7
12855: PUSH
12856: LD_INT 0
12858: ST_TO_ADDR
// for i := 1 to sold_team do
12859: LD_ADDR_VAR 0 4
12863: PUSH
12864: DOUBLE
12865: LD_INT 1
12867: DEC
12868: ST_TO_ADDR
12869: LD_VAR 0 8
12873: PUSH
12874: FOR_TO
12875: IFFALSE 13006
// begin if IsInUnit ( sold_team [ i ] ) then
12877: LD_VAR 0 8
12881: PUSH
12882: LD_VAR 0 4
12886: ARRAY
12887: PPUSH
12888: CALL_OW 310
12892: IFFALSE 12909
// ComExitBuilding ( sold_team [ i ] ) ;
12894: LD_VAR 0 8
12898: PUSH
12899: LD_VAR 0 4
12903: ARRAY
12904: PPUSH
12905: CALL_OW 122
// AddComMoveXY ( sold_team [ i ] , rows [ 1 ] [ i + offset ] , rows [ 1 ] [ i + 1 + offset ] ) ;
12909: LD_VAR 0 8
12913: PUSH
12914: LD_VAR 0 4
12918: ARRAY
12919: PPUSH
12920: LD_EXP 47
12924: PUSH
12925: LD_INT 1
12927: ARRAY
12928: PUSH
12929: LD_VAR 0 4
12933: PUSH
12934: LD_VAR 0 7
12938: PLUS
12939: ARRAY
12940: PPUSH
12941: LD_EXP 47
12945: PUSH
12946: LD_INT 1
12948: ARRAY
12949: PUSH
12950: LD_VAR 0 4
12954: PUSH
12955: LD_INT 1
12957: PLUS
12958: PUSH
12959: LD_VAR 0 7
12963: PLUS
12964: ARRAY
12965: PPUSH
12966: CALL_OW 171
// AddComTurnUnit ( sold_team [ i ] , Brighton ) ;
12970: LD_VAR 0 8
12974: PUSH
12975: LD_VAR 0 4
12979: ARRAY
12980: PPUSH
12981: LD_EXP 9
12985: PPUSH
12986: CALL_OW 179
// offset = offset + 1 ;
12990: LD_ADDR_VAR 0 7
12994: PUSH
12995: LD_VAR 0 7
12999: PUSH
13000: LD_INT 1
13002: PLUS
13003: ST_TO_ADDR
// end ;
13004: GO 12874
13006: POP
13007: POP
// offset = 0 ;
13008: LD_ADDR_VAR 0 7
13012: PUSH
13013: LD_INT 0
13015: ST_TO_ADDR
// tmp = 1 ;
13016: LD_ADDR_VAR 0 6
13020: PUSH
13021: LD_INT 1
13023: ST_TO_ADDR
// for i := 2 to rows do
13024: LD_ADDR_VAR 0 4
13028: PUSH
13029: DOUBLE
13030: LD_INT 2
13032: DEC
13033: ST_TO_ADDR
13034: LD_EXP 47
13038: PUSH
13039: FOR_TO
13040: IFFALSE 13232
// begin for x := 1 to sold_team do
13042: LD_ADDR_VAR 0 5
13046: PUSH
13047: DOUBLE
13048: LD_INT 1
13050: DEC
13051: ST_TO_ADDR
13052: LD_VAR 0 8
13056: PUSH
13057: FOR_TO
13058: IFFALSE 13220
// begin if IsInUnit ( civil_team [ tmp ] ) then
13060: LD_VAR 0 9
13064: PUSH
13065: LD_VAR 0 6
13069: ARRAY
13070: PPUSH
13071: CALL_OW 310
13075: IFFALSE 13092
// ComExitBuilding ( civil_team [ tmp ] ) ;
13077: LD_VAR 0 9
13081: PUSH
13082: LD_VAR 0 6
13086: ARRAY
13087: PPUSH
13088: CALL_OW 122
// AddComMoveXY ( civil_team [ tmp ] , rows [ i ] [ x + offset ] , rows [ i ] [ x + 1 + offset ] ) ;
13092: LD_VAR 0 9
13096: PUSH
13097: LD_VAR 0 6
13101: ARRAY
13102: PPUSH
13103: LD_EXP 47
13107: PUSH
13108: LD_VAR 0 4
13112: ARRAY
13113: PUSH
13114: LD_VAR 0 5
13118: PUSH
13119: LD_VAR 0 7
13123: PLUS
13124: ARRAY
13125: PPUSH
13126: LD_EXP 47
13130: PUSH
13131: LD_VAR 0 4
13135: ARRAY
13136: PUSH
13137: LD_VAR 0 5
13141: PUSH
13142: LD_INT 1
13144: PLUS
13145: PUSH
13146: LD_VAR 0 7
13150: PLUS
13151: ARRAY
13152: PPUSH
13153: CALL_OW 171
// AddComTurnUnit ( civil_team [ tmp ] , Brighton ) ;
13157: LD_VAR 0 9
13161: PUSH
13162: LD_VAR 0 6
13166: ARRAY
13167: PPUSH
13168: LD_EXP 9
13172: PPUSH
13173: CALL_OW 179
// offset = offset + 1 ;
13177: LD_ADDR_VAR 0 7
13181: PUSH
13182: LD_VAR 0 7
13186: PUSH
13187: LD_INT 1
13189: PLUS
13190: ST_TO_ADDR
// if not ( tmp = civil_team ) then
13191: LD_VAR 0 6
13195: PUSH
13196: LD_VAR 0 9
13200: EQUAL
13201: NOT
13202: IFFALSE 13218
// tmp = tmp + 1 ;
13204: LD_ADDR_VAR 0 6
13208: PUSH
13209: LD_VAR 0 6
13213: PUSH
13214: LD_INT 1
13216: PLUS
13217: ST_TO_ADDR
// end ;
13218: GO 13057
13220: POP
13221: POP
// offset = 0 ;
13222: LD_ADDR_VAR 0 7
13226: PUSH
13227: LD_INT 0
13229: ST_TO_ADDR
// end ;
13230: GO 13039
13232: POP
13233: POP
// end ;
13234: LD_VAR 0 3
13238: RET
// export function MakeRows ( sold_team , civil_team ) ; var i , x , start_pos , row_size , new_row , result_rows , civil_rows , offsetX , offsetY ; begin
13239: LD_INT 0
13241: PPUSH
13242: PPUSH
13243: PPUSH
13244: PPUSH
13245: PPUSH
13246: PPUSH
13247: PPUSH
13248: PPUSH
13249: PPUSH
13250: PPUSH
// start_pos = [ 65 , 34 ] ;
13251: LD_ADDR_VAR 0 6
13255: PUSH
13256: LD_INT 65
13258: PUSH
13259: LD_INT 34
13261: PUSH
13262: EMPTY
13263: LIST
13264: LIST
13265: ST_TO_ADDR
// row_size = 0 ;
13266: LD_ADDR_VAR 0 7
13270: PUSH
13271: LD_INT 0
13273: ST_TO_ADDR
// result_rows = [ ] ;
13274: LD_ADDR_VAR 0 9
13278: PUSH
13279: EMPTY
13280: ST_TO_ADDR
// new_row = [ ] ;
13281: LD_ADDR_VAR 0 8
13285: PUSH
13286: EMPTY
13287: ST_TO_ADDR
// for i := 1 to sold_team do
13288: LD_ADDR_VAR 0 4
13292: PUSH
13293: DOUBLE
13294: LD_INT 1
13296: DEC
13297: ST_TO_ADDR
13298: LD_VAR 0 1
13302: PUSH
13303: FOR_TO
13304: IFFALSE 13358
// begin new_row = new_row ^ start_pos [ 1 ] ^ start_pos [ 2 ] + i ;
13306: LD_ADDR_VAR 0 8
13310: PUSH
13311: LD_VAR 0 8
13315: PUSH
13316: LD_VAR 0 6
13320: PUSH
13321: LD_INT 1
13323: ARRAY
13324: ADD
13325: PUSH
13326: LD_VAR 0 6
13330: PUSH
13331: LD_INT 2
13333: ARRAY
13334: PUSH
13335: LD_VAR 0 4
13339: PLUS
13340: ADD
13341: ST_TO_ADDR
// row_size = row_size + 1 ;
13342: LD_ADDR_VAR 0 7
13346: PUSH
13347: LD_VAR 0 7
13351: PUSH
13352: LD_INT 1
13354: PLUS
13355: ST_TO_ADDR
// end ;
13356: GO 13303
13358: POP
13359: POP
// result_rows = result_rows ^ [ new_row ] ;
13360: LD_ADDR_VAR 0 9
13364: PUSH
13365: LD_VAR 0 9
13369: PUSH
13370: LD_VAR 0 8
13374: PUSH
13375: EMPTY
13376: LIST
13377: ADD
13378: ST_TO_ADDR
// civil_rows = civil_team div sold_team ;
13379: LD_ADDR_VAR 0 10
13383: PUSH
13384: LD_VAR 0 2
13388: PUSH
13389: LD_VAR 0 1
13393: DIV
13394: ST_TO_ADDR
// if ( civil_rows mod sold_team > 0 ) then
13395: LD_VAR 0 10
13399: PUSH
13400: LD_VAR 0 1
13404: MOD
13405: PUSH
13406: LD_INT 0
13408: GREATER
13409: IFFALSE 13425
// civil_rows = civil_rows + 1 ;
13411: LD_ADDR_VAR 0 10
13415: PUSH
13416: LD_VAR 0 10
13420: PUSH
13421: LD_INT 1
13423: PLUS
13424: ST_TO_ADDR
// offsetX = 2 ;
13425: LD_ADDR_VAR 0 11
13429: PUSH
13430: LD_INT 2
13432: ST_TO_ADDR
// offsetY = 1 ;
13433: LD_ADDR_VAR 0 12
13437: PUSH
13438: LD_INT 1
13440: ST_TO_ADDR
// for i := 1 to civil_rows do
13441: LD_ADDR_VAR 0 4
13445: PUSH
13446: DOUBLE
13447: LD_INT 1
13449: DEC
13450: ST_TO_ADDR
13451: LD_VAR 0 10
13455: PUSH
13456: FOR_TO
13457: IFFALSE 13585
// begin new_row = [ ] ;
13459: LD_ADDR_VAR 0 8
13463: PUSH
13464: EMPTY
13465: ST_TO_ADDR
// for x := 1 to row_size do
13466: LD_ADDR_VAR 0 5
13470: PUSH
13471: DOUBLE
13472: LD_INT 1
13474: DEC
13475: ST_TO_ADDR
13476: LD_VAR 0 7
13480: PUSH
13481: FOR_TO
13482: IFFALSE 13534
// begin new_row = new_row ^ start_pos [ 1 ] + offsetX ^ start_pos [ 2 ] + offsetY + x ;
13484: LD_ADDR_VAR 0 8
13488: PUSH
13489: LD_VAR 0 8
13493: PUSH
13494: LD_VAR 0 6
13498: PUSH
13499: LD_INT 1
13501: ARRAY
13502: PUSH
13503: LD_VAR 0 11
13507: PLUS
13508: ADD
13509: PUSH
13510: LD_VAR 0 6
13514: PUSH
13515: LD_INT 2
13517: ARRAY
13518: PUSH
13519: LD_VAR 0 12
13523: PLUS
13524: PUSH
13525: LD_VAR 0 5
13529: PLUS
13530: ADD
13531: ST_TO_ADDR
// end ;
13532: GO 13481
13534: POP
13535: POP
// result_rows = result_rows ^ [ new_row ] ;
13536: LD_ADDR_VAR 0 9
13540: PUSH
13541: LD_VAR 0 9
13545: PUSH
13546: LD_VAR 0 8
13550: PUSH
13551: EMPTY
13552: LIST
13553: ADD
13554: ST_TO_ADDR
// offsetX = offsetX + 2 ;
13555: LD_ADDR_VAR 0 11
13559: PUSH
13560: LD_VAR 0 11
13564: PUSH
13565: LD_INT 2
13567: PLUS
13568: ST_TO_ADDR
// offsetY = offsetY + 1 ;
13569: LD_ADDR_VAR 0 12
13573: PUSH
13574: LD_VAR 0 12
13578: PUSH
13579: LD_INT 1
13581: PLUS
13582: ST_TO_ADDR
// end ;
13583: GO 13456
13585: POP
13586: POP
// result = result_rows ;
13587: LD_ADDR_VAR 0 3
13591: PUSH
13592: LD_VAR 0 9
13596: ST_TO_ADDR
// end ; end_of_file
13597: LD_VAR 0 3
13601: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13602: LD_INT 0
13604: PPUSH
13605: PPUSH
// if exist_mode then
13606: LD_VAR 0 2
13610: IFFALSE 13635
// unit := CreateCharacter ( prefix & ident ) else
13612: LD_ADDR_VAR 0 5
13616: PUSH
13617: LD_VAR 0 3
13621: PUSH
13622: LD_VAR 0 1
13626: STR
13627: PPUSH
13628: CALL_OW 34
13632: ST_TO_ADDR
13633: GO 13650
// unit := NewCharacter ( ident ) ;
13635: LD_ADDR_VAR 0 5
13639: PUSH
13640: LD_VAR 0 1
13644: PPUSH
13645: CALL_OW 25
13649: ST_TO_ADDR
// result := unit ;
13650: LD_ADDR_VAR 0 4
13654: PUSH
13655: LD_VAR 0 5
13659: ST_TO_ADDR
// end ;
13660: LD_VAR 0 4
13664: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13665: LD_INT 0
13667: PPUSH
13668: PPUSH
// if not side or not nation then
13669: LD_VAR 0 1
13673: NOT
13674: PUSH
13675: LD_VAR 0 2
13679: NOT
13680: OR
13681: IFFALSE 13685
// exit ;
13683: GO 14453
// case nation of nation_american :
13685: LD_VAR 0 2
13689: PUSH
13690: LD_INT 1
13692: DOUBLE
13693: EQUAL
13694: IFTRUE 13698
13696: GO 13912
13698: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
13699: LD_ADDR_VAR 0 4
13703: PUSH
13704: LD_INT 35
13706: PUSH
13707: LD_INT 45
13709: PUSH
13710: LD_INT 46
13712: PUSH
13713: LD_INT 47
13715: PUSH
13716: LD_INT 82
13718: PUSH
13719: LD_INT 83
13721: PUSH
13722: LD_INT 84
13724: PUSH
13725: LD_INT 85
13727: PUSH
13728: LD_INT 86
13730: PUSH
13731: LD_INT 1
13733: PUSH
13734: LD_INT 2
13736: PUSH
13737: LD_INT 6
13739: PUSH
13740: LD_INT 15
13742: PUSH
13743: LD_INT 16
13745: PUSH
13746: LD_INT 7
13748: PUSH
13749: LD_INT 12
13751: PUSH
13752: LD_INT 13
13754: PUSH
13755: LD_INT 10
13757: PUSH
13758: LD_INT 14
13760: PUSH
13761: LD_INT 20
13763: PUSH
13764: LD_INT 21
13766: PUSH
13767: LD_INT 22
13769: PUSH
13770: LD_INT 25
13772: PUSH
13773: LD_INT 32
13775: PUSH
13776: LD_INT 27
13778: PUSH
13779: LD_INT 36
13781: PUSH
13782: LD_INT 69
13784: PUSH
13785: LD_INT 39
13787: PUSH
13788: LD_INT 34
13790: PUSH
13791: LD_INT 40
13793: PUSH
13794: LD_INT 48
13796: PUSH
13797: LD_INT 49
13799: PUSH
13800: LD_INT 50
13802: PUSH
13803: LD_INT 51
13805: PUSH
13806: LD_INT 52
13808: PUSH
13809: LD_INT 53
13811: PUSH
13812: LD_INT 54
13814: PUSH
13815: LD_INT 55
13817: PUSH
13818: LD_INT 56
13820: PUSH
13821: LD_INT 57
13823: PUSH
13824: LD_INT 58
13826: PUSH
13827: LD_INT 59
13829: PUSH
13830: LD_INT 60
13832: PUSH
13833: LD_INT 61
13835: PUSH
13836: LD_INT 62
13838: PUSH
13839: LD_INT 80
13841: PUSH
13842: LD_INT 82
13844: PUSH
13845: LD_INT 83
13847: PUSH
13848: LD_INT 84
13850: PUSH
13851: LD_INT 85
13853: PUSH
13854: LD_INT 86
13856: PUSH
13857: EMPTY
13858: LIST
13859: LIST
13860: LIST
13861: LIST
13862: LIST
13863: LIST
13864: LIST
13865: LIST
13866: LIST
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: ST_TO_ADDR
13910: GO 14377
13912: LD_INT 2
13914: DOUBLE
13915: EQUAL
13916: IFTRUE 13920
13918: GO 14146
13920: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
13921: LD_ADDR_VAR 0 4
13925: PUSH
13926: LD_INT 35
13928: PUSH
13929: LD_INT 45
13931: PUSH
13932: LD_INT 46
13934: PUSH
13935: LD_INT 47
13937: PUSH
13938: LD_INT 82
13940: PUSH
13941: LD_INT 83
13943: PUSH
13944: LD_INT 84
13946: PUSH
13947: LD_INT 85
13949: PUSH
13950: LD_INT 87
13952: PUSH
13953: LD_INT 70
13955: PUSH
13956: LD_INT 1
13958: PUSH
13959: LD_INT 11
13961: PUSH
13962: LD_INT 3
13964: PUSH
13965: LD_INT 4
13967: PUSH
13968: LD_INT 5
13970: PUSH
13971: LD_INT 6
13973: PUSH
13974: LD_INT 15
13976: PUSH
13977: LD_INT 18
13979: PUSH
13980: LD_INT 7
13982: PUSH
13983: LD_INT 17
13985: PUSH
13986: LD_INT 8
13988: PUSH
13989: LD_INT 20
13991: PUSH
13992: LD_INT 21
13994: PUSH
13995: LD_INT 22
13997: PUSH
13998: LD_INT 72
14000: PUSH
14001: LD_INT 26
14003: PUSH
14004: LD_INT 69
14006: PUSH
14007: LD_INT 39
14009: PUSH
14010: LD_INT 40
14012: PUSH
14013: LD_INT 41
14015: PUSH
14016: LD_INT 42
14018: PUSH
14019: LD_INT 43
14021: PUSH
14022: LD_INT 48
14024: PUSH
14025: LD_INT 49
14027: PUSH
14028: LD_INT 50
14030: PUSH
14031: LD_INT 51
14033: PUSH
14034: LD_INT 52
14036: PUSH
14037: LD_INT 53
14039: PUSH
14040: LD_INT 54
14042: PUSH
14043: LD_INT 55
14045: PUSH
14046: LD_INT 56
14048: PUSH
14049: LD_INT 60
14051: PUSH
14052: LD_INT 61
14054: PUSH
14055: LD_INT 62
14057: PUSH
14058: LD_INT 66
14060: PUSH
14061: LD_INT 67
14063: PUSH
14064: LD_INT 68
14066: PUSH
14067: LD_INT 81
14069: PUSH
14070: LD_INT 82
14072: PUSH
14073: LD_INT 83
14075: PUSH
14076: LD_INT 84
14078: PUSH
14079: LD_INT 85
14081: PUSH
14082: LD_INT 87
14084: PUSH
14085: LD_INT 88
14087: PUSH
14088: EMPTY
14089: LIST
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: ST_TO_ADDR
14144: GO 14377
14146: LD_INT 3
14148: DOUBLE
14149: EQUAL
14150: IFTRUE 14154
14152: GO 14376
14154: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14155: LD_ADDR_VAR 0 4
14159: PUSH
14160: LD_INT 46
14162: PUSH
14163: LD_INT 47
14165: PUSH
14166: LD_INT 1
14168: PUSH
14169: LD_INT 2
14171: PUSH
14172: LD_INT 82
14174: PUSH
14175: LD_INT 83
14177: PUSH
14178: LD_INT 84
14180: PUSH
14181: LD_INT 85
14183: PUSH
14184: LD_INT 86
14186: PUSH
14187: LD_INT 11
14189: PUSH
14190: LD_INT 9
14192: PUSH
14193: LD_INT 20
14195: PUSH
14196: LD_INT 19
14198: PUSH
14199: LD_INT 21
14201: PUSH
14202: LD_INT 24
14204: PUSH
14205: LD_INT 22
14207: PUSH
14208: LD_INT 25
14210: PUSH
14211: LD_INT 28
14213: PUSH
14214: LD_INT 29
14216: PUSH
14217: LD_INT 30
14219: PUSH
14220: LD_INT 31
14222: PUSH
14223: LD_INT 37
14225: PUSH
14226: LD_INT 38
14228: PUSH
14229: LD_INT 32
14231: PUSH
14232: LD_INT 27
14234: PUSH
14235: LD_INT 33
14237: PUSH
14238: LD_INT 69
14240: PUSH
14241: LD_INT 39
14243: PUSH
14244: LD_INT 34
14246: PUSH
14247: LD_INT 40
14249: PUSH
14250: LD_INT 71
14252: PUSH
14253: LD_INT 23
14255: PUSH
14256: LD_INT 44
14258: PUSH
14259: LD_INT 48
14261: PUSH
14262: LD_INT 49
14264: PUSH
14265: LD_INT 50
14267: PUSH
14268: LD_INT 51
14270: PUSH
14271: LD_INT 52
14273: PUSH
14274: LD_INT 53
14276: PUSH
14277: LD_INT 54
14279: PUSH
14280: LD_INT 55
14282: PUSH
14283: LD_INT 56
14285: PUSH
14286: LD_INT 57
14288: PUSH
14289: LD_INT 58
14291: PUSH
14292: LD_INT 59
14294: PUSH
14295: LD_INT 63
14297: PUSH
14298: LD_INT 64
14300: PUSH
14301: LD_INT 65
14303: PUSH
14304: LD_INT 82
14306: PUSH
14307: LD_INT 83
14309: PUSH
14310: LD_INT 84
14312: PUSH
14313: LD_INT 85
14315: PUSH
14316: LD_INT 86
14318: PUSH
14319: EMPTY
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: ST_TO_ADDR
14374: GO 14377
14376: POP
// if state > - 1 and state < 3 then
14377: LD_VAR 0 3
14381: PUSH
14382: LD_INT 1
14384: NEG
14385: GREATER
14386: PUSH
14387: LD_VAR 0 3
14391: PUSH
14392: LD_INT 3
14394: LESS
14395: AND
14396: IFFALSE 14453
// for i in result do
14398: LD_ADDR_VAR 0 5
14402: PUSH
14403: LD_VAR 0 4
14407: PUSH
14408: FOR_IN
14409: IFFALSE 14451
// if GetTech ( i , side ) <> state then
14411: LD_VAR 0 5
14415: PPUSH
14416: LD_VAR 0 1
14420: PPUSH
14421: CALL_OW 321
14425: PUSH
14426: LD_VAR 0 3
14430: NONEQUAL
14431: IFFALSE 14449
// result := result diff i ;
14433: LD_ADDR_VAR 0 4
14437: PUSH
14438: LD_VAR 0 4
14442: PUSH
14443: LD_VAR 0 5
14447: DIFF
14448: ST_TO_ADDR
14449: GO 14408
14451: POP
14452: POP
// end ;
14453: LD_VAR 0 4
14457: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14458: LD_INT 0
14460: PPUSH
14461: PPUSH
14462: PPUSH
// result := true ;
14463: LD_ADDR_VAR 0 3
14467: PUSH
14468: LD_INT 1
14470: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14471: LD_ADDR_VAR 0 5
14475: PUSH
14476: LD_VAR 0 2
14480: PPUSH
14481: CALL_OW 480
14485: ST_TO_ADDR
// if not tmp then
14486: LD_VAR 0 5
14490: NOT
14491: IFFALSE 14495
// exit ;
14493: GO 14544
// for i in tmp do
14495: LD_ADDR_VAR 0 4
14499: PUSH
14500: LD_VAR 0 5
14504: PUSH
14505: FOR_IN
14506: IFFALSE 14542
// if GetTech ( i , side ) <> state_researched then
14508: LD_VAR 0 4
14512: PPUSH
14513: LD_VAR 0 1
14517: PPUSH
14518: CALL_OW 321
14522: PUSH
14523: LD_INT 2
14525: NONEQUAL
14526: IFFALSE 14540
// begin result := false ;
14528: LD_ADDR_VAR 0 3
14532: PUSH
14533: LD_INT 0
14535: ST_TO_ADDR
// exit ;
14536: POP
14537: POP
14538: GO 14544
// end ;
14540: GO 14505
14542: POP
14543: POP
// end ;
14544: LD_VAR 0 3
14548: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14549: LD_INT 0
14551: PPUSH
14552: PPUSH
14553: PPUSH
14554: PPUSH
14555: PPUSH
14556: PPUSH
14557: PPUSH
14558: PPUSH
14559: PPUSH
14560: PPUSH
14561: PPUSH
14562: PPUSH
14563: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14564: LD_VAR 0 1
14568: NOT
14569: PUSH
14570: LD_VAR 0 1
14574: PPUSH
14575: CALL_OW 257
14579: PUSH
14580: LD_INT 9
14582: NONEQUAL
14583: OR
14584: IFFALSE 14588
// exit ;
14586: GO 15161
// side := GetSide ( unit ) ;
14588: LD_ADDR_VAR 0 9
14592: PUSH
14593: LD_VAR 0 1
14597: PPUSH
14598: CALL_OW 255
14602: ST_TO_ADDR
// tech_space := tech_spacanom ;
14603: LD_ADDR_VAR 0 12
14607: PUSH
14608: LD_INT 29
14610: ST_TO_ADDR
// tech_time := tech_taurad ;
14611: LD_ADDR_VAR 0 13
14615: PUSH
14616: LD_INT 28
14618: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14619: LD_ADDR_VAR 0 11
14623: PUSH
14624: LD_VAR 0 1
14628: PPUSH
14629: CALL_OW 310
14633: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14634: LD_VAR 0 11
14638: PPUSH
14639: CALL_OW 247
14643: PUSH
14644: LD_INT 2
14646: EQUAL
14647: IFFALSE 14651
// exit ;
14649: GO 15161
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14651: LD_ADDR_VAR 0 8
14655: PUSH
14656: LD_INT 81
14658: PUSH
14659: LD_VAR 0 9
14663: PUSH
14664: EMPTY
14665: LIST
14666: LIST
14667: PUSH
14668: LD_INT 3
14670: PUSH
14671: LD_INT 21
14673: PUSH
14674: LD_INT 3
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: PPUSH
14689: CALL_OW 69
14693: ST_TO_ADDR
// if not tmp then
14694: LD_VAR 0 8
14698: NOT
14699: IFFALSE 14703
// exit ;
14701: GO 15161
// if in_unit then
14703: LD_VAR 0 11
14707: IFFALSE 14731
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14709: LD_ADDR_VAR 0 10
14713: PUSH
14714: LD_VAR 0 8
14718: PPUSH
14719: LD_VAR 0 11
14723: PPUSH
14724: CALL_OW 74
14728: ST_TO_ADDR
14729: GO 14751
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14731: LD_ADDR_VAR 0 10
14735: PUSH
14736: LD_VAR 0 8
14740: PPUSH
14741: LD_VAR 0 1
14745: PPUSH
14746: CALL_OW 74
14750: ST_TO_ADDR
// if not enemy then
14751: LD_VAR 0 10
14755: NOT
14756: IFFALSE 14760
// exit ;
14758: GO 15161
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14760: LD_VAR 0 11
14764: PUSH
14765: LD_VAR 0 11
14769: PPUSH
14770: LD_VAR 0 10
14774: PPUSH
14775: CALL_OW 296
14779: PUSH
14780: LD_INT 13
14782: GREATER
14783: AND
14784: PUSH
14785: LD_VAR 0 1
14789: PPUSH
14790: LD_VAR 0 10
14794: PPUSH
14795: CALL_OW 296
14799: PUSH
14800: LD_INT 12
14802: GREATER
14803: OR
14804: IFFALSE 14808
// exit ;
14806: GO 15161
// missile := [ 1 ] ;
14808: LD_ADDR_VAR 0 14
14812: PUSH
14813: LD_INT 1
14815: PUSH
14816: EMPTY
14817: LIST
14818: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14819: LD_VAR 0 9
14823: PPUSH
14824: LD_VAR 0 12
14828: PPUSH
14829: CALL_OW 325
14833: IFFALSE 14862
// missile := Insert ( missile , missile + 1 , 2 ) ;
14835: LD_ADDR_VAR 0 14
14839: PUSH
14840: LD_VAR 0 14
14844: PPUSH
14845: LD_VAR 0 14
14849: PUSH
14850: LD_INT 1
14852: PLUS
14853: PPUSH
14854: LD_INT 2
14856: PPUSH
14857: CALL_OW 2
14861: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14862: LD_VAR 0 9
14866: PPUSH
14867: LD_VAR 0 13
14871: PPUSH
14872: CALL_OW 325
14876: PUSH
14877: LD_VAR 0 10
14881: PPUSH
14882: CALL_OW 255
14886: PPUSH
14887: LD_VAR 0 13
14891: PPUSH
14892: CALL_OW 325
14896: NOT
14897: AND
14898: IFFALSE 14927
// missile := Insert ( missile , missile + 1 , 3 ) ;
14900: LD_ADDR_VAR 0 14
14904: PUSH
14905: LD_VAR 0 14
14909: PPUSH
14910: LD_VAR 0 14
14914: PUSH
14915: LD_INT 1
14917: PLUS
14918: PPUSH
14919: LD_INT 3
14921: PPUSH
14922: CALL_OW 2
14926: ST_TO_ADDR
// if missile < 2 then
14927: LD_VAR 0 14
14931: PUSH
14932: LD_INT 2
14934: LESS
14935: IFFALSE 14939
// exit ;
14937: GO 15161
// x := GetX ( enemy ) ;
14939: LD_ADDR_VAR 0 4
14943: PUSH
14944: LD_VAR 0 10
14948: PPUSH
14949: CALL_OW 250
14953: ST_TO_ADDR
// y := GetY ( enemy ) ;
14954: LD_ADDR_VAR 0 5
14958: PUSH
14959: LD_VAR 0 10
14963: PPUSH
14964: CALL_OW 251
14968: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14969: LD_ADDR_VAR 0 6
14973: PUSH
14974: LD_VAR 0 4
14978: PUSH
14979: LD_INT 1
14981: NEG
14982: PPUSH
14983: LD_INT 1
14985: PPUSH
14986: CALL_OW 12
14990: PLUS
14991: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
14992: LD_ADDR_VAR 0 7
14996: PUSH
14997: LD_VAR 0 5
15001: PUSH
15002: LD_INT 1
15004: NEG
15005: PPUSH
15006: LD_INT 1
15008: PPUSH
15009: CALL_OW 12
15013: PLUS
15014: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15015: LD_VAR 0 6
15019: PPUSH
15020: LD_VAR 0 7
15024: PPUSH
15025: CALL_OW 488
15029: NOT
15030: IFFALSE 15052
// begin _x := x ;
15032: LD_ADDR_VAR 0 6
15036: PUSH
15037: LD_VAR 0 4
15041: ST_TO_ADDR
// _y := y ;
15042: LD_ADDR_VAR 0 7
15046: PUSH
15047: LD_VAR 0 5
15051: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15052: LD_ADDR_VAR 0 3
15056: PUSH
15057: LD_INT 1
15059: PPUSH
15060: LD_VAR 0 14
15064: PPUSH
15065: CALL_OW 12
15069: ST_TO_ADDR
// case i of 1 :
15070: LD_VAR 0 3
15074: PUSH
15075: LD_INT 1
15077: DOUBLE
15078: EQUAL
15079: IFTRUE 15083
15081: GO 15100
15083: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15084: LD_VAR 0 1
15088: PPUSH
15089: LD_VAR 0 10
15093: PPUSH
15094: CALL_OW 115
15098: GO 15161
15100: LD_INT 2
15102: DOUBLE
15103: EQUAL
15104: IFTRUE 15108
15106: GO 15130
15108: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15109: LD_VAR 0 1
15113: PPUSH
15114: LD_VAR 0 6
15118: PPUSH
15119: LD_VAR 0 7
15123: PPUSH
15124: CALL_OW 153
15128: GO 15161
15130: LD_INT 3
15132: DOUBLE
15133: EQUAL
15134: IFTRUE 15138
15136: GO 15160
15138: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15139: LD_VAR 0 1
15143: PPUSH
15144: LD_VAR 0 6
15148: PPUSH
15149: LD_VAR 0 7
15153: PPUSH
15154: CALL_OW 154
15158: GO 15161
15160: POP
// end ;
15161: LD_VAR 0 2
15165: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15166: LD_INT 0
15168: PPUSH
15169: PPUSH
15170: PPUSH
15171: PPUSH
15172: PPUSH
15173: PPUSH
// if not unit or not building then
15174: LD_VAR 0 1
15178: NOT
15179: PUSH
15180: LD_VAR 0 2
15184: NOT
15185: OR
15186: IFFALSE 15190
// exit ;
15188: GO 15348
// x := GetX ( building ) ;
15190: LD_ADDR_VAR 0 5
15194: PUSH
15195: LD_VAR 0 2
15199: PPUSH
15200: CALL_OW 250
15204: ST_TO_ADDR
// y := GetY ( building ) ;
15205: LD_ADDR_VAR 0 6
15209: PUSH
15210: LD_VAR 0 2
15214: PPUSH
15215: CALL_OW 251
15219: ST_TO_ADDR
// for i = 0 to 5 do
15220: LD_ADDR_VAR 0 4
15224: PUSH
15225: DOUBLE
15226: LD_INT 0
15228: DEC
15229: ST_TO_ADDR
15230: LD_INT 5
15232: PUSH
15233: FOR_TO
15234: IFFALSE 15346
// begin _x := ShiftX ( x , i , 3 ) ;
15236: LD_ADDR_VAR 0 7
15240: PUSH
15241: LD_VAR 0 5
15245: PPUSH
15246: LD_VAR 0 4
15250: PPUSH
15251: LD_INT 3
15253: PPUSH
15254: CALL_OW 272
15258: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15259: LD_ADDR_VAR 0 8
15263: PUSH
15264: LD_VAR 0 6
15268: PPUSH
15269: LD_VAR 0 4
15273: PPUSH
15274: LD_INT 3
15276: PPUSH
15277: CALL_OW 273
15281: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15282: LD_VAR 0 7
15286: PPUSH
15287: LD_VAR 0 8
15291: PPUSH
15292: CALL_OW 488
15296: NOT
15297: IFFALSE 15301
// continue ;
15299: GO 15233
// if HexInfo ( _x , _y ) = 0 then
15301: LD_VAR 0 7
15305: PPUSH
15306: LD_VAR 0 8
15310: PPUSH
15311: CALL_OW 428
15315: PUSH
15316: LD_INT 0
15318: EQUAL
15319: IFFALSE 15344
// begin ComMoveXY ( unit , _x , _y ) ;
15321: LD_VAR 0 1
15325: PPUSH
15326: LD_VAR 0 7
15330: PPUSH
15331: LD_VAR 0 8
15335: PPUSH
15336: CALL_OW 111
// exit ;
15340: POP
15341: POP
15342: GO 15348
// end ; end ;
15344: GO 15233
15346: POP
15347: POP
// end ;
15348: LD_VAR 0 3
15352: RET
// export function ScanBase ( side , base_area ) ; begin
15353: LD_INT 0
15355: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15356: LD_ADDR_VAR 0 3
15360: PUSH
15361: LD_VAR 0 2
15365: PPUSH
15366: LD_INT 81
15368: PUSH
15369: LD_VAR 0 1
15373: PUSH
15374: EMPTY
15375: LIST
15376: LIST
15377: PPUSH
15378: CALL_OW 70
15382: ST_TO_ADDR
// end ;
15383: LD_VAR 0 3
15387: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15388: LD_INT 0
15390: PPUSH
15391: PPUSH
15392: PPUSH
15393: PPUSH
// result := false ;
15394: LD_ADDR_VAR 0 2
15398: PUSH
15399: LD_INT 0
15401: ST_TO_ADDR
// side := GetSide ( unit ) ;
15402: LD_ADDR_VAR 0 3
15406: PUSH
15407: LD_VAR 0 1
15411: PPUSH
15412: CALL_OW 255
15416: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15417: LD_ADDR_VAR 0 4
15421: PUSH
15422: LD_VAR 0 1
15426: PPUSH
15427: CALL_OW 248
15431: ST_TO_ADDR
// case nat of 1 :
15432: LD_VAR 0 4
15436: PUSH
15437: LD_INT 1
15439: DOUBLE
15440: EQUAL
15441: IFTRUE 15445
15443: GO 15456
15445: POP
// tech := tech_lassight ; 2 :
15446: LD_ADDR_VAR 0 5
15450: PUSH
15451: LD_INT 12
15453: ST_TO_ADDR
15454: GO 15495
15456: LD_INT 2
15458: DOUBLE
15459: EQUAL
15460: IFTRUE 15464
15462: GO 15475
15464: POP
// tech := tech_mortar ; 3 :
15465: LD_ADDR_VAR 0 5
15469: PUSH
15470: LD_INT 41
15472: ST_TO_ADDR
15473: GO 15495
15475: LD_INT 3
15477: DOUBLE
15478: EQUAL
15479: IFTRUE 15483
15481: GO 15494
15483: POP
// tech := tech_bazooka ; end ;
15484: LD_ADDR_VAR 0 5
15488: PUSH
15489: LD_INT 44
15491: ST_TO_ADDR
15492: GO 15495
15494: POP
// if Researched ( side , tech ) then
15495: LD_VAR 0 3
15499: PPUSH
15500: LD_VAR 0 5
15504: PPUSH
15505: CALL_OW 325
15509: IFFALSE 15536
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15511: LD_ADDR_VAR 0 2
15515: PUSH
15516: LD_INT 5
15518: PUSH
15519: LD_INT 8
15521: PUSH
15522: LD_INT 9
15524: PUSH
15525: EMPTY
15526: LIST
15527: LIST
15528: LIST
15529: PUSH
15530: LD_VAR 0 4
15534: ARRAY
15535: ST_TO_ADDR
// end ;
15536: LD_VAR 0 2
15540: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15541: LD_INT 0
15543: PPUSH
15544: PPUSH
15545: PPUSH
// if not mines then
15546: LD_VAR 0 2
15550: NOT
15551: IFFALSE 15555
// exit ;
15553: GO 15699
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15555: LD_ADDR_VAR 0 5
15559: PUSH
15560: LD_INT 81
15562: PUSH
15563: LD_VAR 0 1
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: LD_INT 3
15574: PUSH
15575: LD_INT 21
15577: PUSH
15578: LD_INT 3
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PUSH
15589: EMPTY
15590: LIST
15591: LIST
15592: PPUSH
15593: CALL_OW 69
15597: ST_TO_ADDR
// for i in mines do
15598: LD_ADDR_VAR 0 4
15602: PUSH
15603: LD_VAR 0 2
15607: PUSH
15608: FOR_IN
15609: IFFALSE 15697
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15611: LD_VAR 0 4
15615: PUSH
15616: LD_INT 1
15618: ARRAY
15619: PPUSH
15620: LD_VAR 0 4
15624: PUSH
15625: LD_INT 2
15627: ARRAY
15628: PPUSH
15629: CALL_OW 458
15633: NOT
15634: IFFALSE 15638
// continue ;
15636: GO 15608
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15638: LD_VAR 0 4
15642: PUSH
15643: LD_INT 1
15645: ARRAY
15646: PPUSH
15647: LD_VAR 0 4
15651: PUSH
15652: LD_INT 2
15654: ARRAY
15655: PPUSH
15656: CALL_OW 428
15660: PUSH
15661: LD_VAR 0 5
15665: IN
15666: IFFALSE 15695
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15668: LD_VAR 0 4
15672: PUSH
15673: LD_INT 1
15675: ARRAY
15676: PPUSH
15677: LD_VAR 0 4
15681: PUSH
15682: LD_INT 2
15684: ARRAY
15685: PPUSH
15686: LD_VAR 0 1
15690: PPUSH
15691: CALL_OW 456
// end ;
15695: GO 15608
15697: POP
15698: POP
// end ;
15699: LD_VAR 0 3
15703: RET
// export function Count ( array ) ; var i ; begin
15704: LD_INT 0
15706: PPUSH
15707: PPUSH
// result := 0 ;
15708: LD_ADDR_VAR 0 2
15712: PUSH
15713: LD_INT 0
15715: ST_TO_ADDR
// for i in array do
15716: LD_ADDR_VAR 0 3
15720: PUSH
15721: LD_VAR 0 1
15725: PUSH
15726: FOR_IN
15727: IFFALSE 15751
// if i then
15729: LD_VAR 0 3
15733: IFFALSE 15749
// result := result + 1 ;
15735: LD_ADDR_VAR 0 2
15739: PUSH
15740: LD_VAR 0 2
15744: PUSH
15745: LD_INT 1
15747: PLUS
15748: ST_TO_ADDR
15749: GO 15726
15751: POP
15752: POP
// end ;
15753: LD_VAR 0 2
15757: RET
// export function IsEmpty ( building ) ; begin
15758: LD_INT 0
15760: PPUSH
// if not building then
15761: LD_VAR 0 1
15765: NOT
15766: IFFALSE 15770
// exit ;
15768: GO 15813
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15770: LD_ADDR_VAR 0 2
15774: PUSH
15775: LD_VAR 0 1
15779: PUSH
15780: LD_INT 22
15782: PUSH
15783: LD_VAR 0 1
15787: PPUSH
15788: CALL_OW 255
15792: PUSH
15793: EMPTY
15794: LIST
15795: LIST
15796: PUSH
15797: LD_INT 58
15799: PUSH
15800: EMPTY
15801: LIST
15802: PUSH
15803: EMPTY
15804: LIST
15805: LIST
15806: PPUSH
15807: CALL_OW 69
15811: IN
15812: ST_TO_ADDR
// end ;
15813: LD_VAR 0 2
15817: RET
// export function IsNotFull ( building ) ; begin
15818: LD_INT 0
15820: PPUSH
// if not building then
15821: LD_VAR 0 1
15825: NOT
15826: IFFALSE 15830
// exit ;
15828: GO 15849
// result := UnitsInside ( building ) < 6 ;
15830: LD_ADDR_VAR 0 2
15834: PUSH
15835: LD_VAR 0 1
15839: PPUSH
15840: CALL_OW 313
15844: PUSH
15845: LD_INT 6
15847: LESS
15848: ST_TO_ADDR
// end ;
15849: LD_VAR 0 2
15853: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
15854: LD_INT 0
15856: PPUSH
15857: PPUSH
15858: PPUSH
15859: PPUSH
// tmp := [ ] ;
15860: LD_ADDR_VAR 0 3
15864: PUSH
15865: EMPTY
15866: ST_TO_ADDR
// list := [ ] ;
15867: LD_ADDR_VAR 0 5
15871: PUSH
15872: EMPTY
15873: ST_TO_ADDR
// for i = 16 to 25 do
15874: LD_ADDR_VAR 0 4
15878: PUSH
15879: DOUBLE
15880: LD_INT 16
15882: DEC
15883: ST_TO_ADDR
15884: LD_INT 25
15886: PUSH
15887: FOR_TO
15888: IFFALSE 15961
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
15890: LD_ADDR_VAR 0 3
15894: PUSH
15895: LD_VAR 0 3
15899: PUSH
15900: LD_INT 22
15902: PUSH
15903: LD_VAR 0 1
15907: PPUSH
15908: CALL_OW 255
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: PUSH
15917: LD_INT 91
15919: PUSH
15920: LD_VAR 0 1
15924: PUSH
15925: LD_INT 6
15927: PUSH
15928: EMPTY
15929: LIST
15930: LIST
15931: LIST
15932: PUSH
15933: LD_INT 30
15935: PUSH
15936: LD_VAR 0 4
15940: PUSH
15941: EMPTY
15942: LIST
15943: LIST
15944: PUSH
15945: EMPTY
15946: LIST
15947: LIST
15948: LIST
15949: PUSH
15950: EMPTY
15951: LIST
15952: PPUSH
15953: CALL_OW 69
15957: ADD
15958: ST_TO_ADDR
15959: GO 15887
15961: POP
15962: POP
// for i = 1 to tmp do
15963: LD_ADDR_VAR 0 4
15967: PUSH
15968: DOUBLE
15969: LD_INT 1
15971: DEC
15972: ST_TO_ADDR
15973: LD_VAR 0 3
15977: PUSH
15978: FOR_TO
15979: IFFALSE 16067
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
15981: LD_ADDR_VAR 0 5
15985: PUSH
15986: LD_VAR 0 5
15990: PUSH
15991: LD_VAR 0 3
15995: PUSH
15996: LD_VAR 0 4
16000: ARRAY
16001: PPUSH
16002: CALL_OW 266
16006: PUSH
16007: LD_VAR 0 3
16011: PUSH
16012: LD_VAR 0 4
16016: ARRAY
16017: PPUSH
16018: CALL_OW 250
16022: PUSH
16023: LD_VAR 0 3
16027: PUSH
16028: LD_VAR 0 4
16032: ARRAY
16033: PPUSH
16034: CALL_OW 251
16038: PUSH
16039: LD_VAR 0 3
16043: PUSH
16044: LD_VAR 0 4
16048: ARRAY
16049: PPUSH
16050: CALL_OW 254
16054: PUSH
16055: EMPTY
16056: LIST
16057: LIST
16058: LIST
16059: LIST
16060: PUSH
16061: EMPTY
16062: LIST
16063: ADD
16064: ST_TO_ADDR
16065: GO 15978
16067: POP
16068: POP
// result := list ;
16069: LD_ADDR_VAR 0 2
16073: PUSH
16074: LD_VAR 0 5
16078: ST_TO_ADDR
// end ;
16079: LD_VAR 0 2
16083: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16084: LD_INT 0
16086: PPUSH
16087: PPUSH
16088: PPUSH
16089: PPUSH
16090: PPUSH
16091: PPUSH
16092: PPUSH
// if not factory then
16093: LD_VAR 0 1
16097: NOT
16098: IFFALSE 16102
// exit ;
16100: GO 16695
// if control = control_apeman then
16102: LD_VAR 0 4
16106: PUSH
16107: LD_INT 5
16109: EQUAL
16110: IFFALSE 16219
// begin tmp := UnitsInside ( factory ) ;
16112: LD_ADDR_VAR 0 8
16116: PUSH
16117: LD_VAR 0 1
16121: PPUSH
16122: CALL_OW 313
16126: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16127: LD_VAR 0 8
16131: PPUSH
16132: LD_INT 25
16134: PUSH
16135: LD_INT 12
16137: PUSH
16138: EMPTY
16139: LIST
16140: LIST
16141: PPUSH
16142: CALL_OW 72
16146: NOT
16147: IFFALSE 16157
// control := control_manual ;
16149: LD_ADDR_VAR 0 4
16153: PUSH
16154: LD_INT 1
16156: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16157: LD_ADDR_VAR 0 8
16161: PUSH
16162: LD_VAR 0 1
16166: PPUSH
16167: CALL 15854 0 1
16171: ST_TO_ADDR
// if tmp then
16172: LD_VAR 0 8
16176: IFFALSE 16219
// begin for i in tmp do
16178: LD_ADDR_VAR 0 7
16182: PUSH
16183: LD_VAR 0 8
16187: PUSH
16188: FOR_IN
16189: IFFALSE 16217
// if i [ 1 ] = b_ext_radio then
16191: LD_VAR 0 7
16195: PUSH
16196: LD_INT 1
16198: ARRAY
16199: PUSH
16200: LD_INT 22
16202: EQUAL
16203: IFFALSE 16215
// begin control := control_remote ;
16205: LD_ADDR_VAR 0 4
16209: PUSH
16210: LD_INT 2
16212: ST_TO_ADDR
// break ;
16213: GO 16217
// end ;
16215: GO 16188
16217: POP
16218: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16219: LD_VAR 0 1
16223: PPUSH
16224: LD_VAR 0 2
16228: PPUSH
16229: LD_VAR 0 3
16233: PPUSH
16234: LD_VAR 0 4
16238: PPUSH
16239: LD_VAR 0 5
16243: PPUSH
16244: CALL_OW 448
16248: IFFALSE 16283
// begin result := [ chassis , engine , control , weapon ] ;
16250: LD_ADDR_VAR 0 6
16254: PUSH
16255: LD_VAR 0 2
16259: PUSH
16260: LD_VAR 0 3
16264: PUSH
16265: LD_VAR 0 4
16269: PUSH
16270: LD_VAR 0 5
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: LIST
16279: LIST
16280: ST_TO_ADDR
// exit ;
16281: GO 16695
// end ; _chassis := AvailableChassisList ( factory ) ;
16283: LD_ADDR_VAR 0 9
16287: PUSH
16288: LD_VAR 0 1
16292: PPUSH
16293: CALL_OW 475
16297: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16298: LD_ADDR_VAR 0 11
16302: PUSH
16303: LD_VAR 0 1
16307: PPUSH
16308: CALL_OW 476
16312: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16313: LD_ADDR_VAR 0 12
16317: PUSH
16318: LD_VAR 0 1
16322: PPUSH
16323: CALL_OW 477
16327: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
16328: LD_ADDR_VAR 0 10
16332: PUSH
16333: LD_VAR 0 1
16337: PPUSH
16338: CALL_OW 478
16342: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
16343: LD_VAR 0 9
16347: NOT
16348: PUSH
16349: LD_VAR 0 11
16353: NOT
16354: OR
16355: PUSH
16356: LD_VAR 0 12
16360: NOT
16361: OR
16362: PUSH
16363: LD_VAR 0 10
16367: NOT
16368: OR
16369: IFFALSE 16404
// begin result := [ chassis , engine , control , weapon ] ;
16371: LD_ADDR_VAR 0 6
16375: PUSH
16376: LD_VAR 0 2
16380: PUSH
16381: LD_VAR 0 3
16385: PUSH
16386: LD_VAR 0 4
16390: PUSH
16391: LD_VAR 0 5
16395: PUSH
16396: EMPTY
16397: LIST
16398: LIST
16399: LIST
16400: LIST
16401: ST_TO_ADDR
// exit ;
16402: GO 16695
// end ; if not chassis in _chassis then
16404: LD_VAR 0 2
16408: PUSH
16409: LD_VAR 0 9
16413: IN
16414: NOT
16415: IFFALSE 16441
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: LD_VAR 0 9
16426: PUSH
16427: LD_INT 1
16429: PPUSH
16430: LD_VAR 0 9
16434: PPUSH
16435: CALL_OW 12
16439: ARRAY
16440: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16441: LD_VAR 0 2
16445: PPUSH
16446: LD_VAR 0 3
16450: PPUSH
16451: CALL 16700 0 2
16455: NOT
16456: IFFALSE 16515
// repeat engine := _engine [ 1 ] ;
16458: LD_ADDR_VAR 0 3
16462: PUSH
16463: LD_VAR 0 11
16467: PUSH
16468: LD_INT 1
16470: ARRAY
16471: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16472: LD_ADDR_VAR 0 11
16476: PUSH
16477: LD_VAR 0 11
16481: PPUSH
16482: LD_INT 1
16484: PPUSH
16485: CALL_OW 3
16489: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16490: LD_VAR 0 2
16494: PPUSH
16495: LD_VAR 0 3
16499: PPUSH
16500: CALL 16700 0 2
16504: PUSH
16505: LD_VAR 0 11
16509: PUSH
16510: EMPTY
16511: EQUAL
16512: OR
16513: IFFALSE 16458
// if not control in _control then
16515: LD_VAR 0 4
16519: PUSH
16520: LD_VAR 0 12
16524: IN
16525: NOT
16526: IFFALSE 16552
// control := _control [ rand ( 1 , _control ) ] ;
16528: LD_ADDR_VAR 0 4
16532: PUSH
16533: LD_VAR 0 12
16537: PUSH
16538: LD_INT 1
16540: PPUSH
16541: LD_VAR 0 12
16545: PPUSH
16546: CALL_OW 12
16550: ARRAY
16551: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16552: LD_VAR 0 2
16556: PPUSH
16557: LD_VAR 0 5
16561: PPUSH
16562: CALL 16920 0 2
16566: NOT
16567: IFFALSE 16626
// repeat weapon := _weapon [ 1 ] ;
16569: LD_ADDR_VAR 0 5
16573: PUSH
16574: LD_VAR 0 10
16578: PUSH
16579: LD_INT 1
16581: ARRAY
16582: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16583: LD_ADDR_VAR 0 10
16587: PUSH
16588: LD_VAR 0 10
16592: PPUSH
16593: LD_INT 1
16595: PPUSH
16596: CALL_OW 3
16600: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16601: LD_VAR 0 2
16605: PPUSH
16606: LD_VAR 0 5
16610: PPUSH
16611: CALL 16920 0 2
16615: PUSH
16616: LD_VAR 0 10
16620: PUSH
16621: EMPTY
16622: EQUAL
16623: OR
16624: IFFALSE 16569
// result := [ ] ;
16626: LD_ADDR_VAR 0 6
16630: PUSH
16631: EMPTY
16632: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16633: LD_VAR 0 1
16637: PPUSH
16638: LD_VAR 0 2
16642: PPUSH
16643: LD_VAR 0 3
16647: PPUSH
16648: LD_VAR 0 4
16652: PPUSH
16653: LD_VAR 0 5
16657: PPUSH
16658: CALL_OW 448
16662: IFFALSE 16695
// result := [ chassis , engine , control , weapon ] ;
16664: LD_ADDR_VAR 0 6
16668: PUSH
16669: LD_VAR 0 2
16673: PUSH
16674: LD_VAR 0 3
16678: PUSH
16679: LD_VAR 0 4
16683: PUSH
16684: LD_VAR 0 5
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: LIST
16693: LIST
16694: ST_TO_ADDR
// end ;
16695: LD_VAR 0 6
16699: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16700: LD_INT 0
16702: PPUSH
// if not chassis or not engine then
16703: LD_VAR 0 1
16707: NOT
16708: PUSH
16709: LD_VAR 0 2
16713: NOT
16714: OR
16715: IFFALSE 16719
// exit ;
16717: GO 16915
// case engine of engine_solar :
16719: LD_VAR 0 2
16723: PUSH
16724: LD_INT 2
16726: DOUBLE
16727: EQUAL
16728: IFTRUE 16732
16730: GO 16770
16732: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16733: LD_ADDR_VAR 0 3
16737: PUSH
16738: LD_INT 11
16740: PUSH
16741: LD_INT 12
16743: PUSH
16744: LD_INT 13
16746: PUSH
16747: LD_INT 14
16749: PUSH
16750: LD_INT 1
16752: PUSH
16753: LD_INT 2
16755: PUSH
16756: LD_INT 3
16758: PUSH
16759: EMPTY
16760: LIST
16761: LIST
16762: LIST
16763: LIST
16764: LIST
16765: LIST
16766: LIST
16767: ST_TO_ADDR
16768: GO 16899
16770: LD_INT 1
16772: DOUBLE
16773: EQUAL
16774: IFTRUE 16778
16776: GO 16840
16778: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16779: LD_ADDR_VAR 0 3
16783: PUSH
16784: LD_INT 11
16786: PUSH
16787: LD_INT 12
16789: PUSH
16790: LD_INT 13
16792: PUSH
16793: LD_INT 14
16795: PUSH
16796: LD_INT 1
16798: PUSH
16799: LD_INT 2
16801: PUSH
16802: LD_INT 3
16804: PUSH
16805: LD_INT 4
16807: PUSH
16808: LD_INT 5
16810: PUSH
16811: LD_INT 21
16813: PUSH
16814: LD_INT 23
16816: PUSH
16817: LD_INT 22
16819: PUSH
16820: LD_INT 24
16822: PUSH
16823: EMPTY
16824: LIST
16825: LIST
16826: LIST
16827: LIST
16828: LIST
16829: LIST
16830: LIST
16831: LIST
16832: LIST
16833: LIST
16834: LIST
16835: LIST
16836: LIST
16837: ST_TO_ADDR
16838: GO 16899
16840: LD_INT 3
16842: DOUBLE
16843: EQUAL
16844: IFTRUE 16848
16846: GO 16898
16848: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
16849: LD_ADDR_VAR 0 3
16853: PUSH
16854: LD_INT 13
16856: PUSH
16857: LD_INT 14
16859: PUSH
16860: LD_INT 2
16862: PUSH
16863: LD_INT 3
16865: PUSH
16866: LD_INT 4
16868: PUSH
16869: LD_INT 5
16871: PUSH
16872: LD_INT 21
16874: PUSH
16875: LD_INT 22
16877: PUSH
16878: LD_INT 23
16880: PUSH
16881: LD_INT 24
16883: PUSH
16884: EMPTY
16885: LIST
16886: LIST
16887: LIST
16888: LIST
16889: LIST
16890: LIST
16891: LIST
16892: LIST
16893: LIST
16894: LIST
16895: ST_TO_ADDR
16896: GO 16899
16898: POP
// result := ( chassis in result ) ;
16899: LD_ADDR_VAR 0 3
16903: PUSH
16904: LD_VAR 0 1
16908: PUSH
16909: LD_VAR 0 3
16913: IN
16914: ST_TO_ADDR
// end ;
16915: LD_VAR 0 3
16919: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
16920: LD_INT 0
16922: PPUSH
// if not chassis or not weapon then
16923: LD_VAR 0 1
16927: NOT
16928: PUSH
16929: LD_VAR 0 2
16933: NOT
16934: OR
16935: IFFALSE 16939
// exit ;
16937: GO 18001
// case weapon of us_machine_gun :
16939: LD_VAR 0 2
16943: PUSH
16944: LD_INT 2
16946: DOUBLE
16947: EQUAL
16948: IFTRUE 16952
16950: GO 16982
16952: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
16953: LD_ADDR_VAR 0 3
16957: PUSH
16958: LD_INT 1
16960: PUSH
16961: LD_INT 2
16963: PUSH
16964: LD_INT 3
16966: PUSH
16967: LD_INT 4
16969: PUSH
16970: LD_INT 5
16972: PUSH
16973: EMPTY
16974: LIST
16975: LIST
16976: LIST
16977: LIST
16978: LIST
16979: ST_TO_ADDR
16980: GO 17985
16982: LD_INT 3
16984: DOUBLE
16985: EQUAL
16986: IFTRUE 16990
16988: GO 17020
16990: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
16991: LD_ADDR_VAR 0 3
16995: PUSH
16996: LD_INT 1
16998: PUSH
16999: LD_INT 2
17001: PUSH
17002: LD_INT 3
17004: PUSH
17005: LD_INT 4
17007: PUSH
17008: LD_INT 5
17010: PUSH
17011: EMPTY
17012: LIST
17013: LIST
17014: LIST
17015: LIST
17016: LIST
17017: ST_TO_ADDR
17018: GO 17985
17020: LD_INT 11
17022: DOUBLE
17023: EQUAL
17024: IFTRUE 17028
17026: GO 17058
17028: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17029: LD_ADDR_VAR 0 3
17033: PUSH
17034: LD_INT 1
17036: PUSH
17037: LD_INT 2
17039: PUSH
17040: LD_INT 3
17042: PUSH
17043: LD_INT 4
17045: PUSH
17046: LD_INT 5
17048: PUSH
17049: EMPTY
17050: LIST
17051: LIST
17052: LIST
17053: LIST
17054: LIST
17055: ST_TO_ADDR
17056: GO 17985
17058: LD_INT 4
17060: DOUBLE
17061: EQUAL
17062: IFTRUE 17066
17064: GO 17092
17066: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17067: LD_ADDR_VAR 0 3
17071: PUSH
17072: LD_INT 2
17074: PUSH
17075: LD_INT 3
17077: PUSH
17078: LD_INT 4
17080: PUSH
17081: LD_INT 5
17083: PUSH
17084: EMPTY
17085: LIST
17086: LIST
17087: LIST
17088: LIST
17089: ST_TO_ADDR
17090: GO 17985
17092: LD_INT 5
17094: DOUBLE
17095: EQUAL
17096: IFTRUE 17100
17098: GO 17126
17100: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17101: LD_ADDR_VAR 0 3
17105: PUSH
17106: LD_INT 2
17108: PUSH
17109: LD_INT 3
17111: PUSH
17112: LD_INT 4
17114: PUSH
17115: LD_INT 5
17117: PUSH
17118: EMPTY
17119: LIST
17120: LIST
17121: LIST
17122: LIST
17123: ST_TO_ADDR
17124: GO 17985
17126: LD_INT 9
17128: DOUBLE
17129: EQUAL
17130: IFTRUE 17134
17132: GO 17160
17134: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17135: LD_ADDR_VAR 0 3
17139: PUSH
17140: LD_INT 2
17142: PUSH
17143: LD_INT 3
17145: PUSH
17146: LD_INT 4
17148: PUSH
17149: LD_INT 5
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: LIST
17156: LIST
17157: ST_TO_ADDR
17158: GO 17985
17160: LD_INT 7
17162: DOUBLE
17163: EQUAL
17164: IFTRUE 17168
17166: GO 17194
17168: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17169: LD_ADDR_VAR 0 3
17173: PUSH
17174: LD_INT 2
17176: PUSH
17177: LD_INT 3
17179: PUSH
17180: LD_INT 4
17182: PUSH
17183: LD_INT 5
17185: PUSH
17186: EMPTY
17187: LIST
17188: LIST
17189: LIST
17190: LIST
17191: ST_TO_ADDR
17192: GO 17985
17194: LD_INT 12
17196: DOUBLE
17197: EQUAL
17198: IFTRUE 17202
17200: GO 17228
17202: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17203: LD_ADDR_VAR 0 3
17207: PUSH
17208: LD_INT 2
17210: PUSH
17211: LD_INT 3
17213: PUSH
17214: LD_INT 4
17216: PUSH
17217: LD_INT 5
17219: PUSH
17220: EMPTY
17221: LIST
17222: LIST
17223: LIST
17224: LIST
17225: ST_TO_ADDR
17226: GO 17985
17228: LD_INT 13
17230: DOUBLE
17231: EQUAL
17232: IFTRUE 17236
17234: GO 17262
17236: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17237: LD_ADDR_VAR 0 3
17241: PUSH
17242: LD_INT 2
17244: PUSH
17245: LD_INT 3
17247: PUSH
17248: LD_INT 4
17250: PUSH
17251: LD_INT 5
17253: PUSH
17254: EMPTY
17255: LIST
17256: LIST
17257: LIST
17258: LIST
17259: ST_TO_ADDR
17260: GO 17985
17262: LD_INT 14
17264: DOUBLE
17265: EQUAL
17266: IFTRUE 17270
17268: GO 17288
17270: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17271: LD_ADDR_VAR 0 3
17275: PUSH
17276: LD_INT 4
17278: PUSH
17279: LD_INT 5
17281: PUSH
17282: EMPTY
17283: LIST
17284: LIST
17285: ST_TO_ADDR
17286: GO 17985
17288: LD_INT 6
17290: DOUBLE
17291: EQUAL
17292: IFTRUE 17296
17294: GO 17314
17296: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17297: LD_ADDR_VAR 0 3
17301: PUSH
17302: LD_INT 4
17304: PUSH
17305: LD_INT 5
17307: PUSH
17308: EMPTY
17309: LIST
17310: LIST
17311: ST_TO_ADDR
17312: GO 17985
17314: LD_INT 10
17316: DOUBLE
17317: EQUAL
17318: IFTRUE 17322
17320: GO 17340
17322: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
17323: LD_ADDR_VAR 0 3
17327: PUSH
17328: LD_INT 4
17330: PUSH
17331: LD_INT 5
17333: PUSH
17334: EMPTY
17335: LIST
17336: LIST
17337: ST_TO_ADDR
17338: GO 17985
17340: LD_INT 22
17342: DOUBLE
17343: EQUAL
17344: IFTRUE 17348
17346: GO 17374
17348: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
17349: LD_ADDR_VAR 0 3
17353: PUSH
17354: LD_INT 11
17356: PUSH
17357: LD_INT 12
17359: PUSH
17360: LD_INT 13
17362: PUSH
17363: LD_INT 14
17365: PUSH
17366: EMPTY
17367: LIST
17368: LIST
17369: LIST
17370: LIST
17371: ST_TO_ADDR
17372: GO 17985
17374: LD_INT 23
17376: DOUBLE
17377: EQUAL
17378: IFTRUE 17382
17380: GO 17408
17382: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
17383: LD_ADDR_VAR 0 3
17387: PUSH
17388: LD_INT 11
17390: PUSH
17391: LD_INT 12
17393: PUSH
17394: LD_INT 13
17396: PUSH
17397: LD_INT 14
17399: PUSH
17400: EMPTY
17401: LIST
17402: LIST
17403: LIST
17404: LIST
17405: ST_TO_ADDR
17406: GO 17985
17408: LD_INT 24
17410: DOUBLE
17411: EQUAL
17412: IFTRUE 17416
17414: GO 17442
17416: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17417: LD_ADDR_VAR 0 3
17421: PUSH
17422: LD_INT 11
17424: PUSH
17425: LD_INT 12
17427: PUSH
17428: LD_INT 13
17430: PUSH
17431: LD_INT 14
17433: PUSH
17434: EMPTY
17435: LIST
17436: LIST
17437: LIST
17438: LIST
17439: ST_TO_ADDR
17440: GO 17985
17442: LD_INT 30
17444: DOUBLE
17445: EQUAL
17446: IFTRUE 17450
17448: GO 17476
17450: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17451: LD_ADDR_VAR 0 3
17455: PUSH
17456: LD_INT 11
17458: PUSH
17459: LD_INT 12
17461: PUSH
17462: LD_INT 13
17464: PUSH
17465: LD_INT 14
17467: PUSH
17468: EMPTY
17469: LIST
17470: LIST
17471: LIST
17472: LIST
17473: ST_TO_ADDR
17474: GO 17985
17476: LD_INT 25
17478: DOUBLE
17479: EQUAL
17480: IFTRUE 17484
17482: GO 17502
17484: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17485: LD_ADDR_VAR 0 3
17489: PUSH
17490: LD_INT 13
17492: PUSH
17493: LD_INT 14
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: ST_TO_ADDR
17500: GO 17985
17502: LD_INT 27
17504: DOUBLE
17505: EQUAL
17506: IFTRUE 17510
17508: GO 17528
17510: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
17511: LD_ADDR_VAR 0 3
17515: PUSH
17516: LD_INT 13
17518: PUSH
17519: LD_INT 14
17521: PUSH
17522: EMPTY
17523: LIST
17524: LIST
17525: ST_TO_ADDR
17526: GO 17985
17528: LD_EXP 53
17532: DOUBLE
17533: EQUAL
17534: IFTRUE 17538
17536: GO 17564
17538: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17539: LD_ADDR_VAR 0 3
17543: PUSH
17544: LD_INT 11
17546: PUSH
17547: LD_INT 12
17549: PUSH
17550: LD_INT 13
17552: PUSH
17553: LD_INT 14
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: LIST
17560: LIST
17561: ST_TO_ADDR
17562: GO 17985
17564: LD_INT 28
17566: DOUBLE
17567: EQUAL
17568: IFTRUE 17572
17570: GO 17590
17572: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17573: LD_ADDR_VAR 0 3
17577: PUSH
17578: LD_INT 13
17580: PUSH
17581: LD_INT 14
17583: PUSH
17584: EMPTY
17585: LIST
17586: LIST
17587: ST_TO_ADDR
17588: GO 17985
17590: LD_INT 29
17592: DOUBLE
17593: EQUAL
17594: IFTRUE 17598
17596: GO 17616
17598: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17599: LD_ADDR_VAR 0 3
17603: PUSH
17604: LD_INT 13
17606: PUSH
17607: LD_INT 14
17609: PUSH
17610: EMPTY
17611: LIST
17612: LIST
17613: ST_TO_ADDR
17614: GO 17985
17616: LD_INT 31
17618: DOUBLE
17619: EQUAL
17620: IFTRUE 17624
17622: GO 17642
17624: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17625: LD_ADDR_VAR 0 3
17629: PUSH
17630: LD_INT 13
17632: PUSH
17633: LD_INT 14
17635: PUSH
17636: EMPTY
17637: LIST
17638: LIST
17639: ST_TO_ADDR
17640: GO 17985
17642: LD_INT 26
17644: DOUBLE
17645: EQUAL
17646: IFTRUE 17650
17648: GO 17668
17650: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17651: LD_ADDR_VAR 0 3
17655: PUSH
17656: LD_INT 13
17658: PUSH
17659: LD_INT 14
17661: PUSH
17662: EMPTY
17663: LIST
17664: LIST
17665: ST_TO_ADDR
17666: GO 17985
17668: LD_INT 42
17670: DOUBLE
17671: EQUAL
17672: IFTRUE 17676
17674: GO 17702
17676: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17677: LD_ADDR_VAR 0 3
17681: PUSH
17682: LD_INT 21
17684: PUSH
17685: LD_INT 22
17687: PUSH
17688: LD_INT 23
17690: PUSH
17691: LD_INT 24
17693: PUSH
17694: EMPTY
17695: LIST
17696: LIST
17697: LIST
17698: LIST
17699: ST_TO_ADDR
17700: GO 17985
17702: LD_INT 43
17704: DOUBLE
17705: EQUAL
17706: IFTRUE 17710
17708: GO 17736
17710: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17711: LD_ADDR_VAR 0 3
17715: PUSH
17716: LD_INT 21
17718: PUSH
17719: LD_INT 22
17721: PUSH
17722: LD_INT 23
17724: PUSH
17725: LD_INT 24
17727: PUSH
17728: EMPTY
17729: LIST
17730: LIST
17731: LIST
17732: LIST
17733: ST_TO_ADDR
17734: GO 17985
17736: LD_INT 44
17738: DOUBLE
17739: EQUAL
17740: IFTRUE 17744
17742: GO 17770
17744: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17745: LD_ADDR_VAR 0 3
17749: PUSH
17750: LD_INT 21
17752: PUSH
17753: LD_INT 22
17755: PUSH
17756: LD_INT 23
17758: PUSH
17759: LD_INT 24
17761: PUSH
17762: EMPTY
17763: LIST
17764: LIST
17765: LIST
17766: LIST
17767: ST_TO_ADDR
17768: GO 17985
17770: LD_INT 45
17772: DOUBLE
17773: EQUAL
17774: IFTRUE 17778
17776: GO 17804
17778: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17779: LD_ADDR_VAR 0 3
17783: PUSH
17784: LD_INT 21
17786: PUSH
17787: LD_INT 22
17789: PUSH
17790: LD_INT 23
17792: PUSH
17793: LD_INT 24
17795: PUSH
17796: EMPTY
17797: LIST
17798: LIST
17799: LIST
17800: LIST
17801: ST_TO_ADDR
17802: GO 17985
17804: LD_INT 49
17806: DOUBLE
17807: EQUAL
17808: IFTRUE 17812
17810: GO 17838
17812: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17813: LD_ADDR_VAR 0 3
17817: PUSH
17818: LD_INT 21
17820: PUSH
17821: LD_INT 22
17823: PUSH
17824: LD_INT 23
17826: PUSH
17827: LD_INT 24
17829: PUSH
17830: EMPTY
17831: LIST
17832: LIST
17833: LIST
17834: LIST
17835: ST_TO_ADDR
17836: GO 17985
17838: LD_INT 51
17840: DOUBLE
17841: EQUAL
17842: IFTRUE 17846
17844: GO 17872
17846: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
17847: LD_ADDR_VAR 0 3
17851: PUSH
17852: LD_INT 21
17854: PUSH
17855: LD_INT 22
17857: PUSH
17858: LD_INT 23
17860: PUSH
17861: LD_INT 24
17863: PUSH
17864: EMPTY
17865: LIST
17866: LIST
17867: LIST
17868: LIST
17869: ST_TO_ADDR
17870: GO 17985
17872: LD_INT 52
17874: DOUBLE
17875: EQUAL
17876: IFTRUE 17880
17878: GO 17906
17880: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
17881: LD_ADDR_VAR 0 3
17885: PUSH
17886: LD_INT 21
17888: PUSH
17889: LD_INT 22
17891: PUSH
17892: LD_INT 23
17894: PUSH
17895: LD_INT 24
17897: PUSH
17898: EMPTY
17899: LIST
17900: LIST
17901: LIST
17902: LIST
17903: ST_TO_ADDR
17904: GO 17985
17906: LD_INT 53
17908: DOUBLE
17909: EQUAL
17910: IFTRUE 17914
17912: GO 17932
17914: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
17915: LD_ADDR_VAR 0 3
17919: PUSH
17920: LD_INT 23
17922: PUSH
17923: LD_INT 24
17925: PUSH
17926: EMPTY
17927: LIST
17928: LIST
17929: ST_TO_ADDR
17930: GO 17985
17932: LD_INT 46
17934: DOUBLE
17935: EQUAL
17936: IFTRUE 17940
17938: GO 17958
17940: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
17941: LD_ADDR_VAR 0 3
17945: PUSH
17946: LD_INT 23
17948: PUSH
17949: LD_INT 24
17951: PUSH
17952: EMPTY
17953: LIST
17954: LIST
17955: ST_TO_ADDR
17956: GO 17985
17958: LD_INT 47
17960: DOUBLE
17961: EQUAL
17962: IFTRUE 17966
17964: GO 17984
17966: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17967: LD_ADDR_VAR 0 3
17971: PUSH
17972: LD_INT 23
17974: PUSH
17975: LD_INT 24
17977: PUSH
17978: EMPTY
17979: LIST
17980: LIST
17981: ST_TO_ADDR
17982: GO 17985
17984: POP
// result := ( chassis in result ) ;
17985: LD_ADDR_VAR 0 3
17989: PUSH
17990: LD_VAR 0 1
17994: PUSH
17995: LD_VAR 0 3
17999: IN
18000: ST_TO_ADDR
// end ;
18001: LD_VAR 0 3
18005: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
18006: LD_INT 0
18008: PPUSH
18009: PPUSH
18010: PPUSH
18011: PPUSH
18012: PPUSH
18013: PPUSH
18014: PPUSH
// result := array ;
18015: LD_ADDR_VAR 0 5
18019: PUSH
18020: LD_VAR 0 1
18024: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18025: LD_VAR 0 1
18029: NOT
18030: PUSH
18031: LD_VAR 0 2
18035: NOT
18036: OR
18037: PUSH
18038: LD_VAR 0 3
18042: NOT
18043: OR
18044: PUSH
18045: LD_VAR 0 2
18049: PUSH
18050: LD_VAR 0 1
18054: GREATER
18055: OR
18056: PUSH
18057: LD_VAR 0 3
18061: PUSH
18062: LD_VAR 0 1
18066: GREATER
18067: OR
18068: IFFALSE 18072
// exit ;
18070: GO 18368
// if direction then
18072: LD_VAR 0 4
18076: IFFALSE 18140
// begin d := 1 ;
18078: LD_ADDR_VAR 0 9
18082: PUSH
18083: LD_INT 1
18085: ST_TO_ADDR
// if i_from > i_to then
18086: LD_VAR 0 2
18090: PUSH
18091: LD_VAR 0 3
18095: GREATER
18096: IFFALSE 18122
// length := ( array - i_from ) + i_to else
18098: LD_ADDR_VAR 0 11
18102: PUSH
18103: LD_VAR 0 1
18107: PUSH
18108: LD_VAR 0 2
18112: MINUS
18113: PUSH
18114: LD_VAR 0 3
18118: PLUS
18119: ST_TO_ADDR
18120: GO 18138
// length := i_to - i_from ;
18122: LD_ADDR_VAR 0 11
18126: PUSH
18127: LD_VAR 0 3
18131: PUSH
18132: LD_VAR 0 2
18136: MINUS
18137: ST_TO_ADDR
// end else
18138: GO 18201
// begin d := - 1 ;
18140: LD_ADDR_VAR 0 9
18144: PUSH
18145: LD_INT 1
18147: NEG
18148: ST_TO_ADDR
// if i_from > i_to then
18149: LD_VAR 0 2
18153: PUSH
18154: LD_VAR 0 3
18158: GREATER
18159: IFFALSE 18179
// length := i_from - i_to else
18161: LD_ADDR_VAR 0 11
18165: PUSH
18166: LD_VAR 0 2
18170: PUSH
18171: LD_VAR 0 3
18175: MINUS
18176: ST_TO_ADDR
18177: GO 18201
// length := ( array - i_to ) + i_from ;
18179: LD_ADDR_VAR 0 11
18183: PUSH
18184: LD_VAR 0 1
18188: PUSH
18189: LD_VAR 0 3
18193: MINUS
18194: PUSH
18195: LD_VAR 0 2
18199: PLUS
18200: ST_TO_ADDR
// end ; if not length then
18201: LD_VAR 0 11
18205: NOT
18206: IFFALSE 18210
// exit ;
18208: GO 18368
// tmp := array ;
18210: LD_ADDR_VAR 0 10
18214: PUSH
18215: LD_VAR 0 1
18219: ST_TO_ADDR
// for i = 1 to length do
18220: LD_ADDR_VAR 0 6
18224: PUSH
18225: DOUBLE
18226: LD_INT 1
18228: DEC
18229: ST_TO_ADDR
18230: LD_VAR 0 11
18234: PUSH
18235: FOR_TO
18236: IFFALSE 18356
// begin for j = 1 to array do
18238: LD_ADDR_VAR 0 7
18242: PUSH
18243: DOUBLE
18244: LD_INT 1
18246: DEC
18247: ST_TO_ADDR
18248: LD_VAR 0 1
18252: PUSH
18253: FOR_TO
18254: IFFALSE 18342
// begin k := j + d ;
18256: LD_ADDR_VAR 0 8
18260: PUSH
18261: LD_VAR 0 7
18265: PUSH
18266: LD_VAR 0 9
18270: PLUS
18271: ST_TO_ADDR
// if k > array then
18272: LD_VAR 0 8
18276: PUSH
18277: LD_VAR 0 1
18281: GREATER
18282: IFFALSE 18292
// k := 1 ;
18284: LD_ADDR_VAR 0 8
18288: PUSH
18289: LD_INT 1
18291: ST_TO_ADDR
// if not k then
18292: LD_VAR 0 8
18296: NOT
18297: IFFALSE 18309
// k := array ;
18299: LD_ADDR_VAR 0 8
18303: PUSH
18304: LD_VAR 0 1
18308: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18309: LD_ADDR_VAR 0 10
18313: PUSH
18314: LD_VAR 0 10
18318: PPUSH
18319: LD_VAR 0 8
18323: PPUSH
18324: LD_VAR 0 1
18328: PUSH
18329: LD_VAR 0 7
18333: ARRAY
18334: PPUSH
18335: CALL_OW 1
18339: ST_TO_ADDR
// end ;
18340: GO 18253
18342: POP
18343: POP
// array := tmp ;
18344: LD_ADDR_VAR 0 1
18348: PUSH
18349: LD_VAR 0 10
18353: ST_TO_ADDR
// end ;
18354: GO 18235
18356: POP
18357: POP
// result := array ;
18358: LD_ADDR_VAR 0 5
18362: PUSH
18363: LD_VAR 0 1
18367: ST_TO_ADDR
// end ;
18368: LD_VAR 0 5
18372: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
18373: LD_INT 0
18375: PPUSH
18376: PPUSH
// result := 0 ;
18377: LD_ADDR_VAR 0 3
18381: PUSH
18382: LD_INT 0
18384: ST_TO_ADDR
// if not array or not value in array then
18385: LD_VAR 0 1
18389: NOT
18390: PUSH
18391: LD_VAR 0 2
18395: PUSH
18396: LD_VAR 0 1
18400: IN
18401: NOT
18402: OR
18403: IFFALSE 18407
// exit ;
18405: GO 18461
// for i = 1 to array do
18407: LD_ADDR_VAR 0 4
18411: PUSH
18412: DOUBLE
18413: LD_INT 1
18415: DEC
18416: ST_TO_ADDR
18417: LD_VAR 0 1
18421: PUSH
18422: FOR_TO
18423: IFFALSE 18459
// if value = array [ i ] then
18425: LD_VAR 0 2
18429: PUSH
18430: LD_VAR 0 1
18434: PUSH
18435: LD_VAR 0 4
18439: ARRAY
18440: EQUAL
18441: IFFALSE 18457
// begin result := i ;
18443: LD_ADDR_VAR 0 3
18447: PUSH
18448: LD_VAR 0 4
18452: ST_TO_ADDR
// exit ;
18453: POP
18454: POP
18455: GO 18461
// end ;
18457: GO 18422
18459: POP
18460: POP
// end ;
18461: LD_VAR 0 3
18465: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18466: LD_INT 0
18468: PPUSH
// vc_chassis := chassis ;
18469: LD_ADDR_OWVAR 37
18473: PUSH
18474: LD_VAR 0 1
18478: ST_TO_ADDR
// vc_engine := engine ;
18479: LD_ADDR_OWVAR 39
18483: PUSH
18484: LD_VAR 0 2
18488: ST_TO_ADDR
// vc_control := control ;
18489: LD_ADDR_OWVAR 38
18493: PUSH
18494: LD_VAR 0 3
18498: ST_TO_ADDR
// vc_weapon := weapon ;
18499: LD_ADDR_OWVAR 40
18503: PUSH
18504: LD_VAR 0 4
18508: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18509: LD_ADDR_OWVAR 41
18513: PUSH
18514: LD_VAR 0 5
18518: ST_TO_ADDR
// end ;
18519: LD_VAR 0 6
18523: RET
// export function WantPlant ( unit ) ; var task ; begin
18524: LD_INT 0
18526: PPUSH
18527: PPUSH
// result := false ;
18528: LD_ADDR_VAR 0 2
18532: PUSH
18533: LD_INT 0
18535: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18536: LD_ADDR_VAR 0 3
18540: PUSH
18541: LD_VAR 0 1
18545: PPUSH
18546: CALL_OW 437
18550: ST_TO_ADDR
// if task then
18551: LD_VAR 0 3
18555: IFFALSE 18583
// if task [ 1 ] [ 1 ] = p then
18557: LD_VAR 0 3
18561: PUSH
18562: LD_INT 1
18564: ARRAY
18565: PUSH
18566: LD_INT 1
18568: ARRAY
18569: PUSH
18570: LD_STRING p
18572: EQUAL
18573: IFFALSE 18583
// result := true ;
18575: LD_ADDR_VAR 0 2
18579: PUSH
18580: LD_INT 1
18582: ST_TO_ADDR
// end ;
18583: LD_VAR 0 2
18587: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18588: LD_INT 0
18590: PPUSH
18591: PPUSH
18592: PPUSH
18593: PPUSH
// if pos < 1 then
18594: LD_VAR 0 2
18598: PUSH
18599: LD_INT 1
18601: LESS
18602: IFFALSE 18606
// exit ;
18604: GO 18909
// if pos = 1 then
18606: LD_VAR 0 2
18610: PUSH
18611: LD_INT 1
18613: EQUAL
18614: IFFALSE 18647
// result := Replace ( arr , pos [ 1 ] , value ) else
18616: LD_ADDR_VAR 0 4
18620: PUSH
18621: LD_VAR 0 1
18625: PPUSH
18626: LD_VAR 0 2
18630: PUSH
18631: LD_INT 1
18633: ARRAY
18634: PPUSH
18635: LD_VAR 0 3
18639: PPUSH
18640: CALL_OW 1
18644: ST_TO_ADDR
18645: GO 18909
// begin tmp := arr ;
18647: LD_ADDR_VAR 0 6
18651: PUSH
18652: LD_VAR 0 1
18656: ST_TO_ADDR
// s_arr := [ tmp ] ;
18657: LD_ADDR_VAR 0 7
18661: PUSH
18662: LD_VAR 0 6
18666: PUSH
18667: EMPTY
18668: LIST
18669: ST_TO_ADDR
// for i = 1 to pos - 1 do
18670: LD_ADDR_VAR 0 5
18674: PUSH
18675: DOUBLE
18676: LD_INT 1
18678: DEC
18679: ST_TO_ADDR
18680: LD_VAR 0 2
18684: PUSH
18685: LD_INT 1
18687: MINUS
18688: PUSH
18689: FOR_TO
18690: IFFALSE 18735
// begin tmp := tmp [ pos [ i ] ] ;
18692: LD_ADDR_VAR 0 6
18696: PUSH
18697: LD_VAR 0 6
18701: PUSH
18702: LD_VAR 0 2
18706: PUSH
18707: LD_VAR 0 5
18711: ARRAY
18712: ARRAY
18713: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18714: LD_ADDR_VAR 0 7
18718: PUSH
18719: LD_VAR 0 7
18723: PUSH
18724: LD_VAR 0 6
18728: PUSH
18729: EMPTY
18730: LIST
18731: ADD
18732: ST_TO_ADDR
// end ;
18733: GO 18689
18735: POP
18736: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18737: LD_ADDR_VAR 0 6
18741: PUSH
18742: LD_VAR 0 6
18746: PPUSH
18747: LD_VAR 0 2
18751: PUSH
18752: LD_VAR 0 2
18756: ARRAY
18757: PPUSH
18758: LD_VAR 0 3
18762: PPUSH
18763: CALL_OW 1
18767: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18768: LD_ADDR_VAR 0 7
18772: PUSH
18773: LD_VAR 0 7
18777: PPUSH
18778: LD_VAR 0 7
18782: PPUSH
18783: LD_VAR 0 6
18787: PPUSH
18788: CALL_OW 1
18792: ST_TO_ADDR
// for i = s_arr downto 2 do
18793: LD_ADDR_VAR 0 5
18797: PUSH
18798: DOUBLE
18799: LD_VAR 0 7
18803: INC
18804: ST_TO_ADDR
18805: LD_INT 2
18807: PUSH
18808: FOR_DOWNTO
18809: IFFALSE 18893
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18811: LD_ADDR_VAR 0 6
18815: PUSH
18816: LD_VAR 0 7
18820: PUSH
18821: LD_VAR 0 5
18825: PUSH
18826: LD_INT 1
18828: MINUS
18829: ARRAY
18830: PPUSH
18831: LD_VAR 0 2
18835: PUSH
18836: LD_VAR 0 5
18840: PUSH
18841: LD_INT 1
18843: MINUS
18844: ARRAY
18845: PPUSH
18846: LD_VAR 0 7
18850: PUSH
18851: LD_VAR 0 5
18855: ARRAY
18856: PPUSH
18857: CALL_OW 1
18861: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
18862: LD_ADDR_VAR 0 7
18866: PUSH
18867: LD_VAR 0 7
18871: PPUSH
18872: LD_VAR 0 5
18876: PUSH
18877: LD_INT 1
18879: MINUS
18880: PPUSH
18881: LD_VAR 0 6
18885: PPUSH
18886: CALL_OW 1
18890: ST_TO_ADDR
// end ;
18891: GO 18808
18893: POP
18894: POP
// result := s_arr [ 1 ] ;
18895: LD_ADDR_VAR 0 4
18899: PUSH
18900: LD_VAR 0 7
18904: PUSH
18905: LD_INT 1
18907: ARRAY
18908: ST_TO_ADDR
// end ; end ;
18909: LD_VAR 0 4
18913: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
18914: LD_INT 0
18916: PPUSH
18917: PPUSH
// if not list then
18918: LD_VAR 0 1
18922: NOT
18923: IFFALSE 18927
// exit ;
18925: GO 19018
// i := list [ pos1 ] ;
18927: LD_ADDR_VAR 0 5
18931: PUSH
18932: LD_VAR 0 1
18936: PUSH
18937: LD_VAR 0 2
18941: ARRAY
18942: ST_TO_ADDR
// if not i then
18943: LD_VAR 0 5
18947: NOT
18948: IFFALSE 18952
// exit ;
18950: GO 19018
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
18952: LD_ADDR_VAR 0 1
18956: PUSH
18957: LD_VAR 0 1
18961: PPUSH
18962: LD_VAR 0 2
18966: PPUSH
18967: LD_VAR 0 1
18971: PUSH
18972: LD_VAR 0 3
18976: ARRAY
18977: PPUSH
18978: CALL_OW 1
18982: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
18983: LD_ADDR_VAR 0 1
18987: PUSH
18988: LD_VAR 0 1
18992: PPUSH
18993: LD_VAR 0 3
18997: PPUSH
18998: LD_VAR 0 5
19002: PPUSH
19003: CALL_OW 1
19007: ST_TO_ADDR
// result := list ;
19008: LD_ADDR_VAR 0 4
19012: PUSH
19013: LD_VAR 0 1
19017: ST_TO_ADDR
// end ;
19018: LD_VAR 0 4
19022: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19023: LD_INT 0
19025: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19026: LD_ADDR_VAR 0 5
19030: PUSH
19031: LD_VAR 0 1
19035: PPUSH
19036: CALL_OW 250
19040: PPUSH
19041: LD_VAR 0 1
19045: PPUSH
19046: CALL_OW 251
19050: PPUSH
19051: LD_VAR 0 2
19055: PPUSH
19056: LD_VAR 0 3
19060: PPUSH
19061: LD_VAR 0 4
19065: PPUSH
19066: CALL 19076 0 5
19070: ST_TO_ADDR
// end ;
19071: LD_VAR 0 5
19075: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19076: LD_INT 0
19078: PPUSH
19079: PPUSH
19080: PPUSH
19081: PPUSH
// if not list then
19082: LD_VAR 0 3
19086: NOT
19087: IFFALSE 19091
// exit ;
19089: GO 19479
// result := [ ] ;
19091: LD_ADDR_VAR 0 6
19095: PUSH
19096: EMPTY
19097: ST_TO_ADDR
// for i in list do
19098: LD_ADDR_VAR 0 7
19102: PUSH
19103: LD_VAR 0 3
19107: PUSH
19108: FOR_IN
19109: IFFALSE 19311
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19111: LD_ADDR_VAR 0 9
19115: PUSH
19116: LD_VAR 0 7
19120: PPUSH
19121: LD_VAR 0 1
19125: PPUSH
19126: LD_VAR 0 2
19130: PPUSH
19131: CALL_OW 297
19135: ST_TO_ADDR
// if not result then
19136: LD_VAR 0 6
19140: NOT
19141: IFFALSE 19167
// result := [ [ i , tmp ] ] else
19143: LD_ADDR_VAR 0 6
19147: PUSH
19148: LD_VAR 0 7
19152: PUSH
19153: LD_VAR 0 9
19157: PUSH
19158: EMPTY
19159: LIST
19160: LIST
19161: PUSH
19162: EMPTY
19163: LIST
19164: ST_TO_ADDR
19165: GO 19309
// begin if result [ result ] [ 2 ] < tmp then
19167: LD_VAR 0 6
19171: PUSH
19172: LD_VAR 0 6
19176: ARRAY
19177: PUSH
19178: LD_INT 2
19180: ARRAY
19181: PUSH
19182: LD_VAR 0 9
19186: LESS
19187: IFFALSE 19229
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19189: LD_ADDR_VAR 0 6
19193: PUSH
19194: LD_VAR 0 6
19198: PPUSH
19199: LD_VAR 0 6
19203: PUSH
19204: LD_INT 1
19206: PLUS
19207: PPUSH
19208: LD_VAR 0 7
19212: PUSH
19213: LD_VAR 0 9
19217: PUSH
19218: EMPTY
19219: LIST
19220: LIST
19221: PPUSH
19222: CALL_OW 2
19226: ST_TO_ADDR
19227: GO 19309
// for j = 1 to result do
19229: LD_ADDR_VAR 0 8
19233: PUSH
19234: DOUBLE
19235: LD_INT 1
19237: DEC
19238: ST_TO_ADDR
19239: LD_VAR 0 6
19243: PUSH
19244: FOR_TO
19245: IFFALSE 19307
// begin if tmp < result [ j ] [ 2 ] then
19247: LD_VAR 0 9
19251: PUSH
19252: LD_VAR 0 6
19256: PUSH
19257: LD_VAR 0 8
19261: ARRAY
19262: PUSH
19263: LD_INT 2
19265: ARRAY
19266: LESS
19267: IFFALSE 19305
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19269: LD_ADDR_VAR 0 6
19273: PUSH
19274: LD_VAR 0 6
19278: PPUSH
19279: LD_VAR 0 8
19283: PPUSH
19284: LD_VAR 0 7
19288: PUSH
19289: LD_VAR 0 9
19293: PUSH
19294: EMPTY
19295: LIST
19296: LIST
19297: PPUSH
19298: CALL_OW 2
19302: ST_TO_ADDR
// break ;
19303: GO 19307
// end ; end ;
19305: GO 19244
19307: POP
19308: POP
// end ; end ;
19309: GO 19108
19311: POP
19312: POP
// if result and not asc then
19313: LD_VAR 0 6
19317: PUSH
19318: LD_VAR 0 4
19322: NOT
19323: AND
19324: IFFALSE 19399
// begin tmp := result ;
19326: LD_ADDR_VAR 0 9
19330: PUSH
19331: LD_VAR 0 6
19335: ST_TO_ADDR
// for i = tmp downto 1 do
19336: LD_ADDR_VAR 0 7
19340: PUSH
19341: DOUBLE
19342: LD_VAR 0 9
19346: INC
19347: ST_TO_ADDR
19348: LD_INT 1
19350: PUSH
19351: FOR_DOWNTO
19352: IFFALSE 19397
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
19354: LD_ADDR_VAR 0 6
19358: PUSH
19359: LD_VAR 0 6
19363: PPUSH
19364: LD_VAR 0 9
19368: PUSH
19369: LD_VAR 0 7
19373: MINUS
19374: PUSH
19375: LD_INT 1
19377: PLUS
19378: PPUSH
19379: LD_VAR 0 9
19383: PUSH
19384: LD_VAR 0 7
19388: ARRAY
19389: PPUSH
19390: CALL_OW 1
19394: ST_TO_ADDR
19395: GO 19351
19397: POP
19398: POP
// end ; tmp := [ ] ;
19399: LD_ADDR_VAR 0 9
19403: PUSH
19404: EMPTY
19405: ST_TO_ADDR
// if mode then
19406: LD_VAR 0 5
19410: IFFALSE 19479
// begin for i = 1 to result do
19412: LD_ADDR_VAR 0 7
19416: PUSH
19417: DOUBLE
19418: LD_INT 1
19420: DEC
19421: ST_TO_ADDR
19422: LD_VAR 0 6
19426: PUSH
19427: FOR_TO
19428: IFFALSE 19467
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19430: LD_ADDR_VAR 0 9
19434: PUSH
19435: LD_VAR 0 9
19439: PPUSH
19440: LD_VAR 0 7
19444: PPUSH
19445: LD_VAR 0 6
19449: PUSH
19450: LD_VAR 0 7
19454: ARRAY
19455: PUSH
19456: LD_INT 1
19458: ARRAY
19459: PPUSH
19460: CALL_OW 1
19464: ST_TO_ADDR
19465: GO 19427
19467: POP
19468: POP
// result := tmp ;
19469: LD_ADDR_VAR 0 6
19473: PUSH
19474: LD_VAR 0 9
19478: ST_TO_ADDR
// end ; end ;
19479: LD_VAR 0 6
19483: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19484: LD_INT 0
19486: PPUSH
19487: PPUSH
19488: PPUSH
19489: PPUSH
19490: PPUSH
19491: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19492: LD_ADDR_VAR 0 5
19496: PUSH
19497: LD_INT 0
19499: PUSH
19500: LD_INT 0
19502: PUSH
19503: LD_INT 0
19505: PUSH
19506: EMPTY
19507: PUSH
19508: EMPTY
19509: LIST
19510: LIST
19511: LIST
19512: LIST
19513: ST_TO_ADDR
// if not x or not y then
19514: LD_VAR 0 2
19518: NOT
19519: PUSH
19520: LD_VAR 0 3
19524: NOT
19525: OR
19526: IFFALSE 19530
// exit ;
19528: GO 21182
// if not range then
19530: LD_VAR 0 4
19534: NOT
19535: IFFALSE 19545
// range := 10 ;
19537: LD_ADDR_VAR 0 4
19541: PUSH
19542: LD_INT 10
19544: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19545: LD_ADDR_VAR 0 8
19549: PUSH
19550: LD_INT 81
19552: PUSH
19553: LD_VAR 0 1
19557: PUSH
19558: EMPTY
19559: LIST
19560: LIST
19561: PUSH
19562: LD_INT 92
19564: PUSH
19565: LD_VAR 0 2
19569: PUSH
19570: LD_VAR 0 3
19574: PUSH
19575: LD_VAR 0 4
19579: PUSH
19580: EMPTY
19581: LIST
19582: LIST
19583: LIST
19584: LIST
19585: PUSH
19586: LD_INT 3
19588: PUSH
19589: LD_INT 21
19591: PUSH
19592: LD_INT 3
19594: PUSH
19595: EMPTY
19596: LIST
19597: LIST
19598: PUSH
19599: EMPTY
19600: LIST
19601: LIST
19602: PUSH
19603: EMPTY
19604: LIST
19605: LIST
19606: LIST
19607: PPUSH
19608: CALL_OW 69
19612: ST_TO_ADDR
// if not tmp then
19613: LD_VAR 0 8
19617: NOT
19618: IFFALSE 19622
// exit ;
19620: GO 21182
// for i in tmp do
19622: LD_ADDR_VAR 0 6
19626: PUSH
19627: LD_VAR 0 8
19631: PUSH
19632: FOR_IN
19633: IFFALSE 21157
// begin points := [ 0 , 0 , 0 ] ;
19635: LD_ADDR_VAR 0 9
19639: PUSH
19640: LD_INT 0
19642: PUSH
19643: LD_INT 0
19645: PUSH
19646: LD_INT 0
19648: PUSH
19649: EMPTY
19650: LIST
19651: LIST
19652: LIST
19653: ST_TO_ADDR
// bpoints := 1 ;
19654: LD_ADDR_VAR 0 10
19658: PUSH
19659: LD_INT 1
19661: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19662: LD_VAR 0 6
19666: PPUSH
19667: CALL_OW 247
19671: PUSH
19672: LD_INT 1
19674: DOUBLE
19675: EQUAL
19676: IFTRUE 19680
19678: GO 20258
19680: POP
// begin if GetClass ( i ) = 1 then
19681: LD_VAR 0 6
19685: PPUSH
19686: CALL_OW 257
19690: PUSH
19691: LD_INT 1
19693: EQUAL
19694: IFFALSE 19715
// points := [ 10 , 5 , 3 ] ;
19696: LD_ADDR_VAR 0 9
19700: PUSH
19701: LD_INT 10
19703: PUSH
19704: LD_INT 5
19706: PUSH
19707: LD_INT 3
19709: PUSH
19710: EMPTY
19711: LIST
19712: LIST
19713: LIST
19714: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19715: LD_VAR 0 6
19719: PPUSH
19720: CALL_OW 257
19724: PUSH
19725: LD_INT 2
19727: PUSH
19728: LD_INT 3
19730: PUSH
19731: LD_INT 4
19733: PUSH
19734: EMPTY
19735: LIST
19736: LIST
19737: LIST
19738: IN
19739: IFFALSE 19760
// points := [ 3 , 2 , 1 ] ;
19741: LD_ADDR_VAR 0 9
19745: PUSH
19746: LD_INT 3
19748: PUSH
19749: LD_INT 2
19751: PUSH
19752: LD_INT 1
19754: PUSH
19755: EMPTY
19756: LIST
19757: LIST
19758: LIST
19759: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19760: LD_VAR 0 6
19764: PPUSH
19765: CALL_OW 257
19769: PUSH
19770: LD_INT 5
19772: EQUAL
19773: IFFALSE 19794
// points := [ 130 , 5 , 2 ] ;
19775: LD_ADDR_VAR 0 9
19779: PUSH
19780: LD_INT 130
19782: PUSH
19783: LD_INT 5
19785: PUSH
19786: LD_INT 2
19788: PUSH
19789: EMPTY
19790: LIST
19791: LIST
19792: LIST
19793: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19794: LD_VAR 0 6
19798: PPUSH
19799: CALL_OW 257
19803: PUSH
19804: LD_INT 8
19806: EQUAL
19807: IFFALSE 19828
// points := [ 35 , 35 , 30 ] ;
19809: LD_ADDR_VAR 0 9
19813: PUSH
19814: LD_INT 35
19816: PUSH
19817: LD_INT 35
19819: PUSH
19820: LD_INT 30
19822: PUSH
19823: EMPTY
19824: LIST
19825: LIST
19826: LIST
19827: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19828: LD_VAR 0 6
19832: PPUSH
19833: CALL_OW 257
19837: PUSH
19838: LD_INT 9
19840: EQUAL
19841: IFFALSE 19862
// points := [ 20 , 55 , 40 ] ;
19843: LD_ADDR_VAR 0 9
19847: PUSH
19848: LD_INT 20
19850: PUSH
19851: LD_INT 55
19853: PUSH
19854: LD_INT 40
19856: PUSH
19857: EMPTY
19858: LIST
19859: LIST
19860: LIST
19861: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
19862: LD_VAR 0 6
19866: PPUSH
19867: CALL_OW 257
19871: PUSH
19872: LD_INT 12
19874: PUSH
19875: LD_INT 16
19877: PUSH
19878: EMPTY
19879: LIST
19880: LIST
19881: IN
19882: IFFALSE 19903
// points := [ 5 , 3 , 2 ] ;
19884: LD_ADDR_VAR 0 9
19888: PUSH
19889: LD_INT 5
19891: PUSH
19892: LD_INT 3
19894: PUSH
19895: LD_INT 2
19897: PUSH
19898: EMPTY
19899: LIST
19900: LIST
19901: LIST
19902: ST_TO_ADDR
// if GetClass ( i ) = 17 then
19903: LD_VAR 0 6
19907: PPUSH
19908: CALL_OW 257
19912: PUSH
19913: LD_INT 17
19915: EQUAL
19916: IFFALSE 19937
// points := [ 100 , 50 , 75 ] ;
19918: LD_ADDR_VAR 0 9
19922: PUSH
19923: LD_INT 100
19925: PUSH
19926: LD_INT 50
19928: PUSH
19929: LD_INT 75
19931: PUSH
19932: EMPTY
19933: LIST
19934: LIST
19935: LIST
19936: ST_TO_ADDR
// if GetClass ( i ) = 15 then
19937: LD_VAR 0 6
19941: PPUSH
19942: CALL_OW 257
19946: PUSH
19947: LD_INT 15
19949: EQUAL
19950: IFFALSE 19971
// points := [ 10 , 5 , 3 ] ;
19952: LD_ADDR_VAR 0 9
19956: PUSH
19957: LD_INT 10
19959: PUSH
19960: LD_INT 5
19962: PUSH
19963: LD_INT 3
19965: PUSH
19966: EMPTY
19967: LIST
19968: LIST
19969: LIST
19970: ST_TO_ADDR
// if GetClass ( i ) = 14 then
19971: LD_VAR 0 6
19975: PPUSH
19976: CALL_OW 257
19980: PUSH
19981: LD_INT 14
19983: EQUAL
19984: IFFALSE 20005
// points := [ 10 , 0 , 0 ] ;
19986: LD_ADDR_VAR 0 9
19990: PUSH
19991: LD_INT 10
19993: PUSH
19994: LD_INT 0
19996: PUSH
19997: LD_INT 0
19999: PUSH
20000: EMPTY
20001: LIST
20002: LIST
20003: LIST
20004: ST_TO_ADDR
// if GetClass ( i ) = 11 then
20005: LD_VAR 0 6
20009: PPUSH
20010: CALL_OW 257
20014: PUSH
20015: LD_INT 11
20017: EQUAL
20018: IFFALSE 20039
// points := [ 30 , 10 , 5 ] ;
20020: LD_ADDR_VAR 0 9
20024: PUSH
20025: LD_INT 30
20027: PUSH
20028: LD_INT 10
20030: PUSH
20031: LD_INT 5
20033: PUSH
20034: EMPTY
20035: LIST
20036: LIST
20037: LIST
20038: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20039: LD_VAR 0 1
20043: PPUSH
20044: LD_INT 5
20046: PPUSH
20047: CALL_OW 321
20051: PUSH
20052: LD_INT 2
20054: EQUAL
20055: IFFALSE 20072
// bpoints := bpoints * 1.8 ;
20057: LD_ADDR_VAR 0 10
20061: PUSH
20062: LD_VAR 0 10
20066: PUSH
20067: LD_REAL  1.80000000000000E+0000
20070: MUL
20071: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20072: LD_VAR 0 6
20076: PPUSH
20077: CALL_OW 257
20081: PUSH
20082: LD_INT 1
20084: PUSH
20085: LD_INT 2
20087: PUSH
20088: LD_INT 3
20090: PUSH
20091: LD_INT 4
20093: PUSH
20094: EMPTY
20095: LIST
20096: LIST
20097: LIST
20098: LIST
20099: IN
20100: PUSH
20101: LD_VAR 0 1
20105: PPUSH
20106: LD_INT 51
20108: PPUSH
20109: CALL_OW 321
20113: PUSH
20114: LD_INT 2
20116: EQUAL
20117: AND
20118: IFFALSE 20135
// bpoints := bpoints * 1.2 ;
20120: LD_ADDR_VAR 0 10
20124: PUSH
20125: LD_VAR 0 10
20129: PUSH
20130: LD_REAL  1.20000000000000E+0000
20133: MUL
20134: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20135: LD_VAR 0 6
20139: PPUSH
20140: CALL_OW 257
20144: PUSH
20145: LD_INT 5
20147: PUSH
20148: LD_INT 7
20150: PUSH
20151: LD_INT 9
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: LIST
20158: IN
20159: PUSH
20160: LD_VAR 0 1
20164: PPUSH
20165: LD_INT 52
20167: PPUSH
20168: CALL_OW 321
20172: PUSH
20173: LD_INT 2
20175: EQUAL
20176: AND
20177: IFFALSE 20194
// bpoints := bpoints * 1.5 ;
20179: LD_ADDR_VAR 0 10
20183: PUSH
20184: LD_VAR 0 10
20188: PUSH
20189: LD_REAL  1.50000000000000E+0000
20192: MUL
20193: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20194: LD_VAR 0 1
20198: PPUSH
20199: LD_INT 66
20201: PPUSH
20202: CALL_OW 321
20206: PUSH
20207: LD_INT 2
20209: EQUAL
20210: IFFALSE 20227
// bpoints := bpoints * 1.1 ;
20212: LD_ADDR_VAR 0 10
20216: PUSH
20217: LD_VAR 0 10
20221: PUSH
20222: LD_REAL  1.10000000000000E+0000
20225: MUL
20226: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20227: LD_ADDR_VAR 0 10
20231: PUSH
20232: LD_VAR 0 10
20236: PUSH
20237: LD_VAR 0 6
20241: PPUSH
20242: LD_INT 1
20244: PPUSH
20245: CALL_OW 259
20249: PUSH
20250: LD_REAL  1.15000000000000E+0000
20253: MUL
20254: MUL
20255: ST_TO_ADDR
// end ; unit_vehicle :
20256: GO 21086
20258: LD_INT 2
20260: DOUBLE
20261: EQUAL
20262: IFTRUE 20266
20264: GO 21074
20266: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20267: LD_VAR 0 6
20271: PPUSH
20272: CALL_OW 264
20276: PUSH
20277: LD_INT 2
20279: PUSH
20280: LD_INT 42
20282: PUSH
20283: LD_INT 24
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: LIST
20290: IN
20291: IFFALSE 20312
// points := [ 25 , 5 , 3 ] ;
20293: LD_ADDR_VAR 0 9
20297: PUSH
20298: LD_INT 25
20300: PUSH
20301: LD_INT 5
20303: PUSH
20304: LD_INT 3
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: LIST
20311: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20312: LD_VAR 0 6
20316: PPUSH
20317: CALL_OW 264
20321: PUSH
20322: LD_INT 4
20324: PUSH
20325: LD_INT 43
20327: PUSH
20328: LD_INT 25
20330: PUSH
20331: EMPTY
20332: LIST
20333: LIST
20334: LIST
20335: IN
20336: IFFALSE 20357
// points := [ 40 , 15 , 5 ] ;
20338: LD_ADDR_VAR 0 9
20342: PUSH
20343: LD_INT 40
20345: PUSH
20346: LD_INT 15
20348: PUSH
20349: LD_INT 5
20351: PUSH
20352: EMPTY
20353: LIST
20354: LIST
20355: LIST
20356: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
20357: LD_VAR 0 6
20361: PPUSH
20362: CALL_OW 264
20366: PUSH
20367: LD_INT 3
20369: PUSH
20370: LD_INT 23
20372: PUSH
20373: EMPTY
20374: LIST
20375: LIST
20376: IN
20377: IFFALSE 20398
// points := [ 7 , 25 , 8 ] ;
20379: LD_ADDR_VAR 0 9
20383: PUSH
20384: LD_INT 7
20386: PUSH
20387: LD_INT 25
20389: PUSH
20390: LD_INT 8
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: LIST
20397: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
20398: LD_VAR 0 6
20402: PPUSH
20403: CALL_OW 264
20407: PUSH
20408: LD_INT 5
20410: PUSH
20411: LD_INT 27
20413: PUSH
20414: LD_INT 44
20416: PUSH
20417: EMPTY
20418: LIST
20419: LIST
20420: LIST
20421: IN
20422: IFFALSE 20443
// points := [ 14 , 50 , 16 ] ;
20424: LD_ADDR_VAR 0 9
20428: PUSH
20429: LD_INT 14
20431: PUSH
20432: LD_INT 50
20434: PUSH
20435: LD_INT 16
20437: PUSH
20438: EMPTY
20439: LIST
20440: LIST
20441: LIST
20442: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20443: LD_VAR 0 6
20447: PPUSH
20448: CALL_OW 264
20452: PUSH
20453: LD_INT 6
20455: PUSH
20456: LD_INT 46
20458: PUSH
20459: EMPTY
20460: LIST
20461: LIST
20462: IN
20463: IFFALSE 20484
// points := [ 32 , 120 , 70 ] ;
20465: LD_ADDR_VAR 0 9
20469: PUSH
20470: LD_INT 32
20472: PUSH
20473: LD_INT 120
20475: PUSH
20476: LD_INT 70
20478: PUSH
20479: EMPTY
20480: LIST
20481: LIST
20482: LIST
20483: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
20484: LD_VAR 0 6
20488: PPUSH
20489: CALL_OW 264
20493: PUSH
20494: LD_INT 7
20496: PUSH
20497: LD_INT 28
20499: PUSH
20500: LD_INT 45
20502: PUSH
20503: LD_EXP 53
20507: PUSH
20508: EMPTY
20509: LIST
20510: LIST
20511: LIST
20512: LIST
20513: IN
20514: IFFALSE 20535
// points := [ 35 , 20 , 45 ] ;
20516: LD_ADDR_VAR 0 9
20520: PUSH
20521: LD_INT 35
20523: PUSH
20524: LD_INT 20
20526: PUSH
20527: LD_INT 45
20529: PUSH
20530: EMPTY
20531: LIST
20532: LIST
20533: LIST
20534: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20535: LD_VAR 0 6
20539: PPUSH
20540: CALL_OW 264
20544: PUSH
20545: LD_INT 47
20547: PUSH
20548: EMPTY
20549: LIST
20550: IN
20551: IFFALSE 20572
// points := [ 67 , 45 , 75 ] ;
20553: LD_ADDR_VAR 0 9
20557: PUSH
20558: LD_INT 67
20560: PUSH
20561: LD_INT 45
20563: PUSH
20564: LD_INT 75
20566: PUSH
20567: EMPTY
20568: LIST
20569: LIST
20570: LIST
20571: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20572: LD_VAR 0 6
20576: PPUSH
20577: CALL_OW 264
20581: PUSH
20582: LD_INT 26
20584: PUSH
20585: EMPTY
20586: LIST
20587: IN
20588: IFFALSE 20609
// points := [ 120 , 30 , 80 ] ;
20590: LD_ADDR_VAR 0 9
20594: PUSH
20595: LD_INT 120
20597: PUSH
20598: LD_INT 30
20600: PUSH
20601: LD_INT 80
20603: PUSH
20604: EMPTY
20605: LIST
20606: LIST
20607: LIST
20608: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20609: LD_VAR 0 6
20613: PPUSH
20614: CALL_OW 264
20618: PUSH
20619: LD_INT 22
20621: PUSH
20622: EMPTY
20623: LIST
20624: IN
20625: IFFALSE 20646
// points := [ 40 , 1 , 1 ] ;
20627: LD_ADDR_VAR 0 9
20631: PUSH
20632: LD_INT 40
20634: PUSH
20635: LD_INT 1
20637: PUSH
20638: LD_INT 1
20640: PUSH
20641: EMPTY
20642: LIST
20643: LIST
20644: LIST
20645: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20646: LD_VAR 0 6
20650: PPUSH
20651: CALL_OW 264
20655: PUSH
20656: LD_INT 29
20658: PUSH
20659: EMPTY
20660: LIST
20661: IN
20662: IFFALSE 20683
// points := [ 70 , 200 , 400 ] ;
20664: LD_ADDR_VAR 0 9
20668: PUSH
20669: LD_INT 70
20671: PUSH
20672: LD_INT 200
20674: PUSH
20675: LD_INT 400
20677: PUSH
20678: EMPTY
20679: LIST
20680: LIST
20681: LIST
20682: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20683: LD_VAR 0 6
20687: PPUSH
20688: CALL_OW 264
20692: PUSH
20693: LD_INT 14
20695: PUSH
20696: LD_INT 53
20698: PUSH
20699: EMPTY
20700: LIST
20701: LIST
20702: IN
20703: IFFALSE 20724
// points := [ 40 , 10 , 20 ] ;
20705: LD_ADDR_VAR 0 9
20709: PUSH
20710: LD_INT 40
20712: PUSH
20713: LD_INT 10
20715: PUSH
20716: LD_INT 20
20718: PUSH
20719: EMPTY
20720: LIST
20721: LIST
20722: LIST
20723: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20724: LD_VAR 0 6
20728: PPUSH
20729: CALL_OW 264
20733: PUSH
20734: LD_INT 9
20736: PUSH
20737: EMPTY
20738: LIST
20739: IN
20740: IFFALSE 20761
// points := [ 5 , 70 , 20 ] ;
20742: LD_ADDR_VAR 0 9
20746: PUSH
20747: LD_INT 5
20749: PUSH
20750: LD_INT 70
20752: PUSH
20753: LD_INT 20
20755: PUSH
20756: EMPTY
20757: LIST
20758: LIST
20759: LIST
20760: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20761: LD_VAR 0 6
20765: PPUSH
20766: CALL_OW 264
20770: PUSH
20771: LD_INT 10
20773: PUSH
20774: EMPTY
20775: LIST
20776: IN
20777: IFFALSE 20798
// points := [ 35 , 110 , 70 ] ;
20779: LD_ADDR_VAR 0 9
20783: PUSH
20784: LD_INT 35
20786: PUSH
20787: LD_INT 110
20789: PUSH
20790: LD_INT 70
20792: PUSH
20793: EMPTY
20794: LIST
20795: LIST
20796: LIST
20797: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20798: LD_VAR 0 6
20802: PPUSH
20803: CALL_OW 265
20807: PUSH
20808: LD_INT 25
20810: EQUAL
20811: IFFALSE 20832
// points := [ 80 , 65 , 100 ] ;
20813: LD_ADDR_VAR 0 9
20817: PUSH
20818: LD_INT 80
20820: PUSH
20821: LD_INT 65
20823: PUSH
20824: LD_INT 100
20826: PUSH
20827: EMPTY
20828: LIST
20829: LIST
20830: LIST
20831: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20832: LD_VAR 0 6
20836: PPUSH
20837: CALL_OW 263
20841: PUSH
20842: LD_INT 1
20844: EQUAL
20845: IFFALSE 20880
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
20847: LD_ADDR_VAR 0 10
20851: PUSH
20852: LD_VAR 0 10
20856: PUSH
20857: LD_VAR 0 6
20861: PPUSH
20862: CALL_OW 311
20866: PPUSH
20867: LD_INT 3
20869: PPUSH
20870: CALL_OW 259
20874: PUSH
20875: LD_INT 4
20877: MUL
20878: MUL
20879: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
20880: LD_VAR 0 6
20884: PPUSH
20885: CALL_OW 263
20889: PUSH
20890: LD_INT 2
20892: EQUAL
20893: IFFALSE 20944
// begin j := IsControledBy ( i ) ;
20895: LD_ADDR_VAR 0 7
20899: PUSH
20900: LD_VAR 0 6
20904: PPUSH
20905: CALL_OW 312
20909: ST_TO_ADDR
// if j then
20910: LD_VAR 0 7
20914: IFFALSE 20944
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
20916: LD_ADDR_VAR 0 10
20920: PUSH
20921: LD_VAR 0 10
20925: PUSH
20926: LD_VAR 0 7
20930: PPUSH
20931: LD_INT 3
20933: PPUSH
20934: CALL_OW 259
20938: PUSH
20939: LD_INT 3
20941: MUL
20942: MUL
20943: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
20944: LD_VAR 0 6
20948: PPUSH
20949: CALL_OW 264
20953: PUSH
20954: LD_INT 5
20956: PUSH
20957: LD_INT 6
20959: PUSH
20960: LD_INT 46
20962: PUSH
20963: LD_INT 44
20965: PUSH
20966: LD_INT 47
20968: PUSH
20969: LD_INT 45
20971: PUSH
20972: LD_INT 28
20974: PUSH
20975: LD_INT 7
20977: PUSH
20978: LD_INT 27
20980: PUSH
20981: LD_INT 29
20983: PUSH
20984: EMPTY
20985: LIST
20986: LIST
20987: LIST
20988: LIST
20989: LIST
20990: LIST
20991: LIST
20992: LIST
20993: LIST
20994: LIST
20995: IN
20996: PUSH
20997: LD_VAR 0 1
21001: PPUSH
21002: LD_INT 52
21004: PPUSH
21005: CALL_OW 321
21009: PUSH
21010: LD_INT 2
21012: EQUAL
21013: AND
21014: IFFALSE 21031
// bpoints := bpoints * 1.2 ;
21016: LD_ADDR_VAR 0 10
21020: PUSH
21021: LD_VAR 0 10
21025: PUSH
21026: LD_REAL  1.20000000000000E+0000
21029: MUL
21030: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21031: LD_VAR 0 6
21035: PPUSH
21036: CALL_OW 264
21040: PUSH
21041: LD_INT 6
21043: PUSH
21044: LD_INT 46
21046: PUSH
21047: LD_INT 47
21049: PUSH
21050: EMPTY
21051: LIST
21052: LIST
21053: LIST
21054: IN
21055: IFFALSE 21072
// bpoints := bpoints * 1.2 ;
21057: LD_ADDR_VAR 0 10
21061: PUSH
21062: LD_VAR 0 10
21066: PUSH
21067: LD_REAL  1.20000000000000E+0000
21070: MUL
21071: ST_TO_ADDR
// end ; unit_building :
21072: GO 21086
21074: LD_INT 3
21076: DOUBLE
21077: EQUAL
21078: IFTRUE 21082
21080: GO 21085
21082: POP
// ; end ;
21083: GO 21086
21085: POP
// for j = 1 to 3 do
21086: LD_ADDR_VAR 0 7
21090: PUSH
21091: DOUBLE
21092: LD_INT 1
21094: DEC
21095: ST_TO_ADDR
21096: LD_INT 3
21098: PUSH
21099: FOR_TO
21100: IFFALSE 21153
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21102: LD_ADDR_VAR 0 5
21106: PUSH
21107: LD_VAR 0 5
21111: PPUSH
21112: LD_VAR 0 7
21116: PPUSH
21117: LD_VAR 0 5
21121: PUSH
21122: LD_VAR 0 7
21126: ARRAY
21127: PUSH
21128: LD_VAR 0 9
21132: PUSH
21133: LD_VAR 0 7
21137: ARRAY
21138: PUSH
21139: LD_VAR 0 10
21143: MUL
21144: PLUS
21145: PPUSH
21146: CALL_OW 1
21150: ST_TO_ADDR
21151: GO 21099
21153: POP
21154: POP
// end ;
21155: GO 19632
21157: POP
21158: POP
// result := Replace ( result , 4 , tmp ) ;
21159: LD_ADDR_VAR 0 5
21163: PUSH
21164: LD_VAR 0 5
21168: PPUSH
21169: LD_INT 4
21171: PPUSH
21172: LD_VAR 0 8
21176: PPUSH
21177: CALL_OW 1
21181: ST_TO_ADDR
// end ;
21182: LD_VAR 0 5
21186: RET
// export function DangerAtRange ( unit , range ) ; begin
21187: LD_INT 0
21189: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21190: LD_ADDR_VAR 0 3
21194: PUSH
21195: LD_VAR 0 1
21199: PPUSH
21200: CALL_OW 255
21204: PPUSH
21205: LD_VAR 0 1
21209: PPUSH
21210: CALL_OW 250
21214: PPUSH
21215: LD_VAR 0 1
21219: PPUSH
21220: CALL_OW 251
21224: PPUSH
21225: LD_VAR 0 2
21229: PPUSH
21230: CALL 19484 0 4
21234: ST_TO_ADDR
// end ;
21235: LD_VAR 0 3
21239: RET
// export function DangerInArea ( side , area ) ; begin
21240: LD_INT 0
21242: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21243: LD_ADDR_VAR 0 3
21247: PUSH
21248: LD_VAR 0 2
21252: PPUSH
21253: LD_INT 81
21255: PUSH
21256: LD_VAR 0 1
21260: PUSH
21261: EMPTY
21262: LIST
21263: LIST
21264: PPUSH
21265: CALL_OW 70
21269: ST_TO_ADDR
// end ;
21270: LD_VAR 0 3
21274: RET
// export function IsExtension ( b ) ; begin
21275: LD_INT 0
21277: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21278: LD_ADDR_VAR 0 2
21282: PUSH
21283: LD_VAR 0 1
21287: PUSH
21288: LD_INT 23
21290: PUSH
21291: LD_INT 20
21293: PUSH
21294: LD_INT 22
21296: PUSH
21297: LD_INT 17
21299: PUSH
21300: LD_INT 24
21302: PUSH
21303: LD_INT 21
21305: PUSH
21306: LD_INT 19
21308: PUSH
21309: LD_INT 16
21311: PUSH
21312: LD_INT 25
21314: PUSH
21315: LD_INT 18
21317: PUSH
21318: EMPTY
21319: LIST
21320: LIST
21321: LIST
21322: LIST
21323: LIST
21324: LIST
21325: LIST
21326: LIST
21327: LIST
21328: LIST
21329: IN
21330: ST_TO_ADDR
// end ;
21331: LD_VAR 0 2
21335: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
21336: LD_INT 0
21338: PPUSH
21339: PPUSH
21340: PPUSH
// result := [ ] ;
21341: LD_ADDR_VAR 0 4
21345: PUSH
21346: EMPTY
21347: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21348: LD_ADDR_VAR 0 5
21352: PUSH
21353: LD_VAR 0 2
21357: PPUSH
21358: LD_INT 21
21360: PUSH
21361: LD_INT 3
21363: PUSH
21364: EMPTY
21365: LIST
21366: LIST
21367: PPUSH
21368: CALL_OW 70
21372: ST_TO_ADDR
// if not tmp then
21373: LD_VAR 0 5
21377: NOT
21378: IFFALSE 21382
// exit ;
21380: GO 21446
// if checkLink then
21382: LD_VAR 0 3
21386: IFFALSE 21436
// begin for i in tmp do
21388: LD_ADDR_VAR 0 6
21392: PUSH
21393: LD_VAR 0 5
21397: PUSH
21398: FOR_IN
21399: IFFALSE 21434
// if GetBase ( i ) <> base then
21401: LD_VAR 0 6
21405: PPUSH
21406: CALL_OW 274
21410: PUSH
21411: LD_VAR 0 1
21415: NONEQUAL
21416: IFFALSE 21432
// ComLinkToBase ( base , i ) ;
21418: LD_VAR 0 1
21422: PPUSH
21423: LD_VAR 0 6
21427: PPUSH
21428: CALL_OW 169
21432: GO 21398
21434: POP
21435: POP
// end ; result := tmp ;
21436: LD_ADDR_VAR 0 4
21440: PUSH
21441: LD_VAR 0 5
21445: ST_TO_ADDR
// end ;
21446: LD_VAR 0 4
21450: RET
// export function ComComplete ( units , b ) ; var i ; begin
21451: LD_INT 0
21453: PPUSH
21454: PPUSH
// if not units then
21455: LD_VAR 0 1
21459: NOT
21460: IFFALSE 21464
// exit ;
21462: GO 21554
// for i in units do
21464: LD_ADDR_VAR 0 4
21468: PUSH
21469: LD_VAR 0 1
21473: PUSH
21474: FOR_IN
21475: IFFALSE 21552
// if BuildingStatus ( b ) = bs_build then
21477: LD_VAR 0 2
21481: PPUSH
21482: CALL_OW 461
21486: PUSH
21487: LD_INT 1
21489: EQUAL
21490: IFFALSE 21550
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21492: LD_VAR 0 4
21496: PPUSH
21497: LD_STRING h
21499: PUSH
21500: LD_VAR 0 2
21504: PPUSH
21505: CALL_OW 250
21509: PUSH
21510: LD_VAR 0 2
21514: PPUSH
21515: CALL_OW 251
21519: PUSH
21520: LD_VAR 0 2
21524: PUSH
21525: LD_INT 0
21527: PUSH
21528: LD_INT 0
21530: PUSH
21531: LD_INT 0
21533: PUSH
21534: EMPTY
21535: LIST
21536: LIST
21537: LIST
21538: LIST
21539: LIST
21540: LIST
21541: LIST
21542: PUSH
21543: EMPTY
21544: LIST
21545: PPUSH
21546: CALL_OW 446
21550: GO 21474
21552: POP
21553: POP
// end ;
21554: LD_VAR 0 3
21558: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21559: LD_INT 0
21561: PPUSH
21562: PPUSH
21563: PPUSH
21564: PPUSH
21565: PPUSH
21566: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
21567: LD_VAR 0 1
21571: NOT
21572: PUSH
21573: LD_VAR 0 1
21577: PPUSH
21578: CALL_OW 263
21582: PUSH
21583: LD_INT 2
21585: NONEQUAL
21586: OR
21587: IFFALSE 21591
// exit ;
21589: GO 21907
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21591: LD_ADDR_VAR 0 6
21595: PUSH
21596: LD_INT 22
21598: PUSH
21599: LD_VAR 0 1
21603: PPUSH
21604: CALL_OW 255
21608: PUSH
21609: EMPTY
21610: LIST
21611: LIST
21612: PUSH
21613: LD_INT 2
21615: PUSH
21616: LD_INT 30
21618: PUSH
21619: LD_INT 36
21621: PUSH
21622: EMPTY
21623: LIST
21624: LIST
21625: PUSH
21626: LD_INT 34
21628: PUSH
21629: LD_INT 31
21631: PUSH
21632: EMPTY
21633: LIST
21634: LIST
21635: PUSH
21636: EMPTY
21637: LIST
21638: LIST
21639: LIST
21640: PUSH
21641: EMPTY
21642: LIST
21643: LIST
21644: PPUSH
21645: CALL_OW 69
21649: ST_TO_ADDR
// if not tmp then
21650: LD_VAR 0 6
21654: NOT
21655: IFFALSE 21659
// exit ;
21657: GO 21907
// result := [ ] ;
21659: LD_ADDR_VAR 0 2
21663: PUSH
21664: EMPTY
21665: ST_TO_ADDR
// for i in tmp do
21666: LD_ADDR_VAR 0 3
21670: PUSH
21671: LD_VAR 0 6
21675: PUSH
21676: FOR_IN
21677: IFFALSE 21748
// begin t := UnitsInside ( i ) ;
21679: LD_ADDR_VAR 0 4
21683: PUSH
21684: LD_VAR 0 3
21688: PPUSH
21689: CALL_OW 313
21693: ST_TO_ADDR
// if t then
21694: LD_VAR 0 4
21698: IFFALSE 21746
// for j in t do
21700: LD_ADDR_VAR 0 7
21704: PUSH
21705: LD_VAR 0 4
21709: PUSH
21710: FOR_IN
21711: IFFALSE 21744
// result := Replace ( result , result + 1 , j ) ;
21713: LD_ADDR_VAR 0 2
21717: PUSH
21718: LD_VAR 0 2
21722: PPUSH
21723: LD_VAR 0 2
21727: PUSH
21728: LD_INT 1
21730: PLUS
21731: PPUSH
21732: LD_VAR 0 7
21736: PPUSH
21737: CALL_OW 1
21741: ST_TO_ADDR
21742: GO 21710
21744: POP
21745: POP
// end ;
21746: GO 21676
21748: POP
21749: POP
// if not result then
21750: LD_VAR 0 2
21754: NOT
21755: IFFALSE 21759
// exit ;
21757: GO 21907
// mech := result [ 1 ] ;
21759: LD_ADDR_VAR 0 5
21763: PUSH
21764: LD_VAR 0 2
21768: PUSH
21769: LD_INT 1
21771: ARRAY
21772: ST_TO_ADDR
// if result > 1 then
21773: LD_VAR 0 2
21777: PUSH
21778: LD_INT 1
21780: GREATER
21781: IFFALSE 21893
// begin for i = 2 to result do
21783: LD_ADDR_VAR 0 3
21787: PUSH
21788: DOUBLE
21789: LD_INT 2
21791: DEC
21792: ST_TO_ADDR
21793: LD_VAR 0 2
21797: PUSH
21798: FOR_TO
21799: IFFALSE 21891
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21801: LD_ADDR_VAR 0 4
21805: PUSH
21806: LD_VAR 0 2
21810: PUSH
21811: LD_VAR 0 3
21815: ARRAY
21816: PPUSH
21817: LD_INT 3
21819: PPUSH
21820: CALL_OW 259
21824: PUSH
21825: LD_VAR 0 2
21829: PUSH
21830: LD_VAR 0 3
21834: ARRAY
21835: PPUSH
21836: CALL_OW 432
21840: MINUS
21841: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
21842: LD_VAR 0 4
21846: PUSH
21847: LD_VAR 0 5
21851: PPUSH
21852: LD_INT 3
21854: PPUSH
21855: CALL_OW 259
21859: PUSH
21860: LD_VAR 0 5
21864: PPUSH
21865: CALL_OW 432
21869: MINUS
21870: GREATEREQUAL
21871: IFFALSE 21889
// mech := result [ i ] ;
21873: LD_ADDR_VAR 0 5
21877: PUSH
21878: LD_VAR 0 2
21882: PUSH
21883: LD_VAR 0 3
21887: ARRAY
21888: ST_TO_ADDR
// end ;
21889: GO 21798
21891: POP
21892: POP
// end ; ComLinkTo ( vehicle , mech ) ;
21893: LD_VAR 0 1
21897: PPUSH
21898: LD_VAR 0 5
21902: PPUSH
21903: CALL_OW 135
// end ;
21907: LD_VAR 0 2
21911: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
21912: LD_INT 0
21914: PPUSH
21915: PPUSH
21916: PPUSH
21917: PPUSH
21918: PPUSH
21919: PPUSH
21920: PPUSH
21921: PPUSH
21922: PPUSH
21923: PPUSH
21924: PPUSH
21925: PPUSH
21926: PPUSH
// result := [ ] ;
21927: LD_ADDR_VAR 0 7
21931: PUSH
21932: EMPTY
21933: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
21934: LD_VAR 0 1
21938: PPUSH
21939: CALL_OW 266
21943: PUSH
21944: LD_INT 0
21946: PUSH
21947: LD_INT 1
21949: PUSH
21950: EMPTY
21951: LIST
21952: LIST
21953: IN
21954: NOT
21955: IFFALSE 21959
// exit ;
21957: GO 23593
// if name then
21959: LD_VAR 0 3
21963: IFFALSE 21979
// SetBName ( base_dep , name ) ;
21965: LD_VAR 0 1
21969: PPUSH
21970: LD_VAR 0 3
21974: PPUSH
21975: CALL_OW 500
// base := GetBase ( base_dep ) ;
21979: LD_ADDR_VAR 0 15
21983: PUSH
21984: LD_VAR 0 1
21988: PPUSH
21989: CALL_OW 274
21993: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
21994: LD_ADDR_VAR 0 16
21998: PUSH
21999: LD_VAR 0 1
22003: PPUSH
22004: CALL_OW 255
22008: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22009: LD_ADDR_VAR 0 17
22013: PUSH
22014: LD_VAR 0 1
22018: PPUSH
22019: CALL_OW 248
22023: ST_TO_ADDR
// if sources then
22024: LD_VAR 0 5
22028: IFFALSE 22075
// for i = 1 to 3 do
22030: LD_ADDR_VAR 0 8
22034: PUSH
22035: DOUBLE
22036: LD_INT 1
22038: DEC
22039: ST_TO_ADDR
22040: LD_INT 3
22042: PUSH
22043: FOR_TO
22044: IFFALSE 22073
// AddResourceType ( base , i , sources [ i ] ) ;
22046: LD_VAR 0 15
22050: PPUSH
22051: LD_VAR 0 8
22055: PPUSH
22056: LD_VAR 0 5
22060: PUSH
22061: LD_VAR 0 8
22065: ARRAY
22066: PPUSH
22067: CALL_OW 276
22071: GO 22043
22073: POP
22074: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
22075: LD_ADDR_VAR 0 18
22079: PUSH
22080: LD_VAR 0 15
22084: PPUSH
22085: LD_VAR 0 2
22089: PPUSH
22090: LD_INT 1
22092: PPUSH
22093: CALL 21336 0 3
22097: ST_TO_ADDR
// InitHc ;
22098: CALL_OW 19
// InitUc ;
22102: CALL_OW 18
// uc_side := side ;
22106: LD_ADDR_OWVAR 20
22110: PUSH
22111: LD_VAR 0 16
22115: ST_TO_ADDR
// uc_nation := nation ;
22116: LD_ADDR_OWVAR 21
22120: PUSH
22121: LD_VAR 0 17
22125: ST_TO_ADDR
// if buildings then
22126: LD_VAR 0 18
22130: IFFALSE 23452
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22132: LD_ADDR_VAR 0 19
22136: PUSH
22137: LD_VAR 0 18
22141: PPUSH
22142: LD_INT 2
22144: PUSH
22145: LD_INT 30
22147: PUSH
22148: LD_INT 29
22150: PUSH
22151: EMPTY
22152: LIST
22153: LIST
22154: PUSH
22155: LD_INT 30
22157: PUSH
22158: LD_INT 30
22160: PUSH
22161: EMPTY
22162: LIST
22163: LIST
22164: PUSH
22165: EMPTY
22166: LIST
22167: LIST
22168: LIST
22169: PPUSH
22170: CALL_OW 72
22174: ST_TO_ADDR
// if tmp then
22175: LD_VAR 0 19
22179: IFFALSE 22227
// for i in tmp do
22181: LD_ADDR_VAR 0 8
22185: PUSH
22186: LD_VAR 0 19
22190: PUSH
22191: FOR_IN
22192: IFFALSE 22225
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22194: LD_VAR 0 8
22198: PPUSH
22199: CALL_OW 250
22203: PPUSH
22204: LD_VAR 0 8
22208: PPUSH
22209: CALL_OW 251
22213: PPUSH
22214: LD_VAR 0 16
22218: PPUSH
22219: CALL_OW 441
22223: GO 22191
22225: POP
22226: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22227: LD_VAR 0 18
22231: PPUSH
22232: LD_INT 2
22234: PUSH
22235: LD_INT 30
22237: PUSH
22238: LD_INT 32
22240: PUSH
22241: EMPTY
22242: LIST
22243: LIST
22244: PUSH
22245: LD_INT 30
22247: PUSH
22248: LD_INT 33
22250: PUSH
22251: EMPTY
22252: LIST
22253: LIST
22254: PUSH
22255: EMPTY
22256: LIST
22257: LIST
22258: LIST
22259: PPUSH
22260: CALL_OW 72
22264: IFFALSE 22352
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22266: LD_ADDR_VAR 0 8
22270: PUSH
22271: LD_VAR 0 18
22275: PPUSH
22276: LD_INT 2
22278: PUSH
22279: LD_INT 30
22281: PUSH
22282: LD_INT 32
22284: PUSH
22285: EMPTY
22286: LIST
22287: LIST
22288: PUSH
22289: LD_INT 30
22291: PUSH
22292: LD_INT 33
22294: PUSH
22295: EMPTY
22296: LIST
22297: LIST
22298: PUSH
22299: EMPTY
22300: LIST
22301: LIST
22302: LIST
22303: PPUSH
22304: CALL_OW 72
22308: PUSH
22309: FOR_IN
22310: IFFALSE 22350
// begin if not GetBWeapon ( i ) then
22312: LD_VAR 0 8
22316: PPUSH
22317: CALL_OW 269
22321: NOT
22322: IFFALSE 22348
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22324: LD_VAR 0 8
22328: PPUSH
22329: LD_VAR 0 8
22333: PPUSH
22334: LD_VAR 0 2
22338: PPUSH
22339: CALL 23598 0 2
22343: PPUSH
22344: CALL_OW 431
// end ;
22348: GO 22309
22350: POP
22351: POP
// end ; for i = 1 to personel do
22352: LD_ADDR_VAR 0 8
22356: PUSH
22357: DOUBLE
22358: LD_INT 1
22360: DEC
22361: ST_TO_ADDR
22362: LD_VAR 0 6
22366: PUSH
22367: FOR_TO
22368: IFFALSE 23432
// begin if i > 4 then
22370: LD_VAR 0 8
22374: PUSH
22375: LD_INT 4
22377: GREATER
22378: IFFALSE 22382
// break ;
22380: GO 23432
// case i of 1 :
22382: LD_VAR 0 8
22386: PUSH
22387: LD_INT 1
22389: DOUBLE
22390: EQUAL
22391: IFTRUE 22395
22393: GO 22475
22395: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
22396: LD_ADDR_VAR 0 12
22400: PUSH
22401: LD_VAR 0 18
22405: PPUSH
22406: LD_INT 22
22408: PUSH
22409: LD_VAR 0 16
22413: PUSH
22414: EMPTY
22415: LIST
22416: LIST
22417: PUSH
22418: LD_INT 58
22420: PUSH
22421: EMPTY
22422: LIST
22423: PUSH
22424: LD_INT 2
22426: PUSH
22427: LD_INT 30
22429: PUSH
22430: LD_INT 32
22432: PUSH
22433: EMPTY
22434: LIST
22435: LIST
22436: PUSH
22437: LD_INT 30
22439: PUSH
22440: LD_INT 4
22442: PUSH
22443: EMPTY
22444: LIST
22445: LIST
22446: PUSH
22447: LD_INT 30
22449: PUSH
22450: LD_INT 5
22452: PUSH
22453: EMPTY
22454: LIST
22455: LIST
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: LIST
22461: LIST
22462: PUSH
22463: EMPTY
22464: LIST
22465: LIST
22466: LIST
22467: PPUSH
22468: CALL_OW 72
22472: ST_TO_ADDR
22473: GO 22697
22475: LD_INT 2
22477: DOUBLE
22478: EQUAL
22479: IFTRUE 22483
22481: GO 22545
22483: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22484: LD_ADDR_VAR 0 12
22488: PUSH
22489: LD_VAR 0 18
22493: PPUSH
22494: LD_INT 22
22496: PUSH
22497: LD_VAR 0 16
22501: PUSH
22502: EMPTY
22503: LIST
22504: LIST
22505: PUSH
22506: LD_INT 2
22508: PUSH
22509: LD_INT 30
22511: PUSH
22512: LD_INT 0
22514: PUSH
22515: EMPTY
22516: LIST
22517: LIST
22518: PUSH
22519: LD_INT 30
22521: PUSH
22522: LD_INT 1
22524: PUSH
22525: EMPTY
22526: LIST
22527: LIST
22528: PUSH
22529: EMPTY
22530: LIST
22531: LIST
22532: LIST
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PPUSH
22538: CALL_OW 72
22542: ST_TO_ADDR
22543: GO 22697
22545: LD_INT 3
22547: DOUBLE
22548: EQUAL
22549: IFTRUE 22553
22551: GO 22615
22553: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22554: LD_ADDR_VAR 0 12
22558: PUSH
22559: LD_VAR 0 18
22563: PPUSH
22564: LD_INT 22
22566: PUSH
22567: LD_VAR 0 16
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: LD_INT 2
22578: PUSH
22579: LD_INT 30
22581: PUSH
22582: LD_INT 2
22584: PUSH
22585: EMPTY
22586: LIST
22587: LIST
22588: PUSH
22589: LD_INT 30
22591: PUSH
22592: LD_INT 3
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: PUSH
22599: EMPTY
22600: LIST
22601: LIST
22602: LIST
22603: PUSH
22604: EMPTY
22605: LIST
22606: LIST
22607: PPUSH
22608: CALL_OW 72
22612: ST_TO_ADDR
22613: GO 22697
22615: LD_INT 4
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22696
22623: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22624: LD_ADDR_VAR 0 12
22628: PUSH
22629: LD_VAR 0 18
22633: PPUSH
22634: LD_INT 22
22636: PUSH
22637: LD_VAR 0 16
22641: PUSH
22642: EMPTY
22643: LIST
22644: LIST
22645: PUSH
22646: LD_INT 2
22648: PUSH
22649: LD_INT 30
22651: PUSH
22652: LD_INT 6
22654: PUSH
22655: EMPTY
22656: LIST
22657: LIST
22658: PUSH
22659: LD_INT 30
22661: PUSH
22662: LD_INT 7
22664: PUSH
22665: EMPTY
22666: LIST
22667: LIST
22668: PUSH
22669: LD_INT 30
22671: PUSH
22672: LD_INT 8
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: PUSH
22679: EMPTY
22680: LIST
22681: LIST
22682: LIST
22683: LIST
22684: PUSH
22685: EMPTY
22686: LIST
22687: LIST
22688: PPUSH
22689: CALL_OW 72
22693: ST_TO_ADDR
22694: GO 22697
22696: POP
// if i = 1 then
22697: LD_VAR 0 8
22701: PUSH
22702: LD_INT 1
22704: EQUAL
22705: IFFALSE 22816
// begin tmp := [ ] ;
22707: LD_ADDR_VAR 0 19
22711: PUSH
22712: EMPTY
22713: ST_TO_ADDR
// for j in f do
22714: LD_ADDR_VAR 0 9
22718: PUSH
22719: LD_VAR 0 12
22723: PUSH
22724: FOR_IN
22725: IFFALSE 22798
// if GetBType ( j ) = b_bunker then
22727: LD_VAR 0 9
22731: PPUSH
22732: CALL_OW 266
22736: PUSH
22737: LD_INT 32
22739: EQUAL
22740: IFFALSE 22767
// tmp := Insert ( tmp , 1 , j ) else
22742: LD_ADDR_VAR 0 19
22746: PUSH
22747: LD_VAR 0 19
22751: PPUSH
22752: LD_INT 1
22754: PPUSH
22755: LD_VAR 0 9
22759: PPUSH
22760: CALL_OW 2
22764: ST_TO_ADDR
22765: GO 22796
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22767: LD_ADDR_VAR 0 19
22771: PUSH
22772: LD_VAR 0 19
22776: PPUSH
22777: LD_VAR 0 19
22781: PUSH
22782: LD_INT 1
22784: PLUS
22785: PPUSH
22786: LD_VAR 0 9
22790: PPUSH
22791: CALL_OW 2
22795: ST_TO_ADDR
22796: GO 22724
22798: POP
22799: POP
// if tmp then
22800: LD_VAR 0 19
22804: IFFALSE 22816
// f := tmp ;
22806: LD_ADDR_VAR 0 12
22810: PUSH
22811: LD_VAR 0 19
22815: ST_TO_ADDR
// end ; x := personel [ i ] ;
22816: LD_ADDR_VAR 0 13
22820: PUSH
22821: LD_VAR 0 6
22825: PUSH
22826: LD_VAR 0 8
22830: ARRAY
22831: ST_TO_ADDR
// if x = - 1 then
22832: LD_VAR 0 13
22836: PUSH
22837: LD_INT 1
22839: NEG
22840: EQUAL
22841: IFFALSE 23050
// begin for j in f do
22843: LD_ADDR_VAR 0 9
22847: PUSH
22848: LD_VAR 0 12
22852: PUSH
22853: FOR_IN
22854: IFFALSE 23046
// repeat InitHc ;
22856: CALL_OW 19
// if GetBType ( j ) = b_barracks then
22860: LD_VAR 0 9
22864: PPUSH
22865: CALL_OW 266
22869: PUSH
22870: LD_INT 5
22872: EQUAL
22873: IFFALSE 22943
// begin if UnitsInside ( j ) < 3 then
22875: LD_VAR 0 9
22879: PPUSH
22880: CALL_OW 313
22884: PUSH
22885: LD_INT 3
22887: LESS
22888: IFFALSE 22924
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22890: LD_INT 0
22892: PPUSH
22893: LD_INT 5
22895: PUSH
22896: LD_INT 8
22898: PUSH
22899: LD_INT 9
22901: PUSH
22902: EMPTY
22903: LIST
22904: LIST
22905: LIST
22906: PUSH
22907: LD_VAR 0 17
22911: ARRAY
22912: PPUSH
22913: LD_VAR 0 4
22917: PPUSH
22918: CALL_OW 380
22922: GO 22941
// PrepareHuman ( false , i , skill ) ;
22924: LD_INT 0
22926: PPUSH
22927: LD_VAR 0 8
22931: PPUSH
22932: LD_VAR 0 4
22936: PPUSH
22937: CALL_OW 380
// end else
22941: GO 22960
// PrepareHuman ( false , i , skill ) ;
22943: LD_INT 0
22945: PPUSH
22946: LD_VAR 0 8
22950: PPUSH
22951: LD_VAR 0 4
22955: PPUSH
22956: CALL_OW 380
// un := CreateHuman ;
22960: LD_ADDR_VAR 0 14
22964: PUSH
22965: CALL_OW 44
22969: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22970: LD_ADDR_VAR 0 7
22974: PUSH
22975: LD_VAR 0 7
22979: PPUSH
22980: LD_INT 1
22982: PPUSH
22983: LD_VAR 0 14
22987: PPUSH
22988: CALL_OW 2
22992: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
22993: LD_VAR 0 14
22997: PPUSH
22998: LD_VAR 0 9
23002: PPUSH
23003: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
23007: LD_VAR 0 9
23011: PPUSH
23012: CALL_OW 313
23016: PUSH
23017: LD_INT 6
23019: EQUAL
23020: PUSH
23021: LD_VAR 0 9
23025: PPUSH
23026: CALL_OW 266
23030: PUSH
23031: LD_INT 32
23033: PUSH
23034: LD_INT 31
23036: PUSH
23037: EMPTY
23038: LIST
23039: LIST
23040: IN
23041: OR
23042: IFFALSE 22856
23044: GO 22853
23046: POP
23047: POP
// end else
23048: GO 23430
// for j = 1 to x do
23050: LD_ADDR_VAR 0 9
23054: PUSH
23055: DOUBLE
23056: LD_INT 1
23058: DEC
23059: ST_TO_ADDR
23060: LD_VAR 0 13
23064: PUSH
23065: FOR_TO
23066: IFFALSE 23428
// begin InitHc ;
23068: CALL_OW 19
// if not f then
23072: LD_VAR 0 12
23076: NOT
23077: IFFALSE 23166
// begin PrepareHuman ( false , i , skill ) ;
23079: LD_INT 0
23081: PPUSH
23082: LD_VAR 0 8
23086: PPUSH
23087: LD_VAR 0 4
23091: PPUSH
23092: CALL_OW 380
// un := CreateHuman ;
23096: LD_ADDR_VAR 0 14
23100: PUSH
23101: CALL_OW 44
23105: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23106: LD_ADDR_VAR 0 7
23110: PUSH
23111: LD_VAR 0 7
23115: PPUSH
23116: LD_INT 1
23118: PPUSH
23119: LD_VAR 0 14
23123: PPUSH
23124: CALL_OW 2
23128: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23129: LD_VAR 0 14
23133: PPUSH
23134: LD_VAR 0 1
23138: PPUSH
23139: CALL_OW 250
23143: PPUSH
23144: LD_VAR 0 1
23148: PPUSH
23149: CALL_OW 251
23153: PPUSH
23154: LD_INT 10
23156: PPUSH
23157: LD_INT 0
23159: PPUSH
23160: CALL_OW 50
// continue ;
23164: GO 23065
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23166: LD_VAR 0 12
23170: PUSH
23171: LD_INT 1
23173: ARRAY
23174: PPUSH
23175: CALL_OW 313
23179: PUSH
23180: LD_VAR 0 12
23184: PUSH
23185: LD_INT 1
23187: ARRAY
23188: PPUSH
23189: CALL_OW 266
23193: PUSH
23194: LD_INT 32
23196: PUSH
23197: LD_INT 31
23199: PUSH
23200: EMPTY
23201: LIST
23202: LIST
23203: IN
23204: AND
23205: PUSH
23206: LD_VAR 0 12
23210: PUSH
23211: LD_INT 1
23213: ARRAY
23214: PPUSH
23215: CALL_OW 313
23219: PUSH
23220: LD_INT 6
23222: EQUAL
23223: OR
23224: IFFALSE 23244
// f := Delete ( f , 1 ) ;
23226: LD_ADDR_VAR 0 12
23230: PUSH
23231: LD_VAR 0 12
23235: PPUSH
23236: LD_INT 1
23238: PPUSH
23239: CALL_OW 3
23243: ST_TO_ADDR
// if not f then
23244: LD_VAR 0 12
23248: NOT
23249: IFFALSE 23267
// begin x := x + 2 ;
23251: LD_ADDR_VAR 0 13
23255: PUSH
23256: LD_VAR 0 13
23260: PUSH
23261: LD_INT 2
23263: PLUS
23264: ST_TO_ADDR
// continue ;
23265: GO 23065
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23267: LD_VAR 0 12
23271: PUSH
23272: LD_INT 1
23274: ARRAY
23275: PPUSH
23276: CALL_OW 266
23280: PUSH
23281: LD_INT 5
23283: EQUAL
23284: IFFALSE 23358
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23286: LD_VAR 0 12
23290: PUSH
23291: LD_INT 1
23293: ARRAY
23294: PPUSH
23295: CALL_OW 313
23299: PUSH
23300: LD_INT 3
23302: LESS
23303: IFFALSE 23339
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23305: LD_INT 0
23307: PPUSH
23308: LD_INT 5
23310: PUSH
23311: LD_INT 8
23313: PUSH
23314: LD_INT 9
23316: PUSH
23317: EMPTY
23318: LIST
23319: LIST
23320: LIST
23321: PUSH
23322: LD_VAR 0 17
23326: ARRAY
23327: PPUSH
23328: LD_VAR 0 4
23332: PPUSH
23333: CALL_OW 380
23337: GO 23356
// PrepareHuman ( false , i , skill ) ;
23339: LD_INT 0
23341: PPUSH
23342: LD_VAR 0 8
23346: PPUSH
23347: LD_VAR 0 4
23351: PPUSH
23352: CALL_OW 380
// end else
23356: GO 23375
// PrepareHuman ( false , i , skill ) ;
23358: LD_INT 0
23360: PPUSH
23361: LD_VAR 0 8
23365: PPUSH
23366: LD_VAR 0 4
23370: PPUSH
23371: CALL_OW 380
// un := CreateHuman ;
23375: LD_ADDR_VAR 0 14
23379: PUSH
23380: CALL_OW 44
23384: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23385: LD_ADDR_VAR 0 7
23389: PUSH
23390: LD_VAR 0 7
23394: PPUSH
23395: LD_INT 1
23397: PPUSH
23398: LD_VAR 0 14
23402: PPUSH
23403: CALL_OW 2
23407: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
23408: LD_VAR 0 14
23412: PPUSH
23413: LD_VAR 0 12
23417: PUSH
23418: LD_INT 1
23420: ARRAY
23421: PPUSH
23422: CALL_OW 52
// end ;
23426: GO 23065
23428: POP
23429: POP
// end ;
23430: GO 22367
23432: POP
23433: POP
// result := result ^ buildings ;
23434: LD_ADDR_VAR 0 7
23438: PUSH
23439: LD_VAR 0 7
23443: PUSH
23444: LD_VAR 0 18
23448: ADD
23449: ST_TO_ADDR
// end else
23450: GO 23593
// begin for i = 1 to personel do
23452: LD_ADDR_VAR 0 8
23456: PUSH
23457: DOUBLE
23458: LD_INT 1
23460: DEC
23461: ST_TO_ADDR
23462: LD_VAR 0 6
23466: PUSH
23467: FOR_TO
23468: IFFALSE 23591
// begin if i > 4 then
23470: LD_VAR 0 8
23474: PUSH
23475: LD_INT 4
23477: GREATER
23478: IFFALSE 23482
// break ;
23480: GO 23591
// x := personel [ i ] ;
23482: LD_ADDR_VAR 0 13
23486: PUSH
23487: LD_VAR 0 6
23491: PUSH
23492: LD_VAR 0 8
23496: ARRAY
23497: ST_TO_ADDR
// if x = - 1 then
23498: LD_VAR 0 13
23502: PUSH
23503: LD_INT 1
23505: NEG
23506: EQUAL
23507: IFFALSE 23511
// continue ;
23509: GO 23467
// PrepareHuman ( false , i , skill ) ;
23511: LD_INT 0
23513: PPUSH
23514: LD_VAR 0 8
23518: PPUSH
23519: LD_VAR 0 4
23523: PPUSH
23524: CALL_OW 380
// un := CreateHuman ;
23528: LD_ADDR_VAR 0 14
23532: PUSH
23533: CALL_OW 44
23537: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23538: LD_VAR 0 14
23542: PPUSH
23543: LD_VAR 0 1
23547: PPUSH
23548: CALL_OW 250
23552: PPUSH
23553: LD_VAR 0 1
23557: PPUSH
23558: CALL_OW 251
23562: PPUSH
23563: LD_INT 10
23565: PPUSH
23566: LD_INT 0
23568: PPUSH
23569: CALL_OW 50
// result := result ^ un ;
23573: LD_ADDR_VAR 0 7
23577: PUSH
23578: LD_VAR 0 7
23582: PUSH
23583: LD_VAR 0 14
23587: ADD
23588: ST_TO_ADDR
// end ;
23589: GO 23467
23591: POP
23592: POP
// end ; end ;
23593: LD_VAR 0 7
23597: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23598: LD_INT 0
23600: PPUSH
23601: PPUSH
23602: PPUSH
23603: PPUSH
23604: PPUSH
23605: PPUSH
23606: PPUSH
23607: PPUSH
23608: PPUSH
23609: PPUSH
23610: PPUSH
23611: PPUSH
23612: PPUSH
23613: PPUSH
23614: PPUSH
23615: PPUSH
// result := false ;
23616: LD_ADDR_VAR 0 3
23620: PUSH
23621: LD_INT 0
23623: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23624: LD_VAR 0 1
23628: NOT
23629: PUSH
23630: LD_VAR 0 1
23634: PPUSH
23635: CALL_OW 266
23639: PUSH
23640: LD_INT 32
23642: PUSH
23643: LD_INT 33
23645: PUSH
23646: EMPTY
23647: LIST
23648: LIST
23649: IN
23650: NOT
23651: OR
23652: IFFALSE 23656
// exit ;
23654: GO 24765
// nat := GetNation ( tower ) ;
23656: LD_ADDR_VAR 0 12
23660: PUSH
23661: LD_VAR 0 1
23665: PPUSH
23666: CALL_OW 248
23670: ST_TO_ADDR
// side := GetSide ( tower ) ;
23671: LD_ADDR_VAR 0 16
23675: PUSH
23676: LD_VAR 0 1
23680: PPUSH
23681: CALL_OW 255
23685: ST_TO_ADDR
// x := GetX ( tower ) ;
23686: LD_ADDR_VAR 0 10
23690: PUSH
23691: LD_VAR 0 1
23695: PPUSH
23696: CALL_OW 250
23700: ST_TO_ADDR
// y := GetY ( tower ) ;
23701: LD_ADDR_VAR 0 11
23705: PUSH
23706: LD_VAR 0 1
23710: PPUSH
23711: CALL_OW 251
23715: ST_TO_ADDR
// if not x or not y then
23716: LD_VAR 0 10
23720: NOT
23721: PUSH
23722: LD_VAR 0 11
23726: NOT
23727: OR
23728: IFFALSE 23732
// exit ;
23730: GO 24765
// weapon := 0 ;
23732: LD_ADDR_VAR 0 18
23736: PUSH
23737: LD_INT 0
23739: ST_TO_ADDR
// fac_list := [ ] ;
23740: LD_ADDR_VAR 0 17
23744: PUSH
23745: EMPTY
23746: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
23747: LD_ADDR_VAR 0 6
23751: PUSH
23752: LD_VAR 0 1
23756: PPUSH
23757: CALL_OW 274
23761: PPUSH
23762: LD_VAR 0 2
23766: PPUSH
23767: LD_INT 0
23769: PPUSH
23770: CALL 21336 0 3
23774: PPUSH
23775: LD_INT 30
23777: PUSH
23778: LD_INT 3
23780: PUSH
23781: EMPTY
23782: LIST
23783: LIST
23784: PPUSH
23785: CALL_OW 72
23789: ST_TO_ADDR
// if not factories then
23790: LD_VAR 0 6
23794: NOT
23795: IFFALSE 23799
// exit ;
23797: GO 24765
// for i in factories do
23799: LD_ADDR_VAR 0 8
23803: PUSH
23804: LD_VAR 0 6
23808: PUSH
23809: FOR_IN
23810: IFFALSE 23835
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23812: LD_ADDR_VAR 0 17
23816: PUSH
23817: LD_VAR 0 17
23821: PUSH
23822: LD_VAR 0 8
23826: PPUSH
23827: CALL_OW 478
23831: UNION
23832: ST_TO_ADDR
23833: GO 23809
23835: POP
23836: POP
// if not fac_list then
23837: LD_VAR 0 17
23841: NOT
23842: IFFALSE 23846
// exit ;
23844: GO 24765
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
23846: LD_ADDR_VAR 0 5
23850: PUSH
23851: LD_INT 4
23853: PUSH
23854: LD_INT 5
23856: PUSH
23857: LD_INT 9
23859: PUSH
23860: LD_INT 10
23862: PUSH
23863: LD_INT 6
23865: PUSH
23866: LD_INT 7
23868: PUSH
23869: LD_INT 11
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: LIST
23876: LIST
23877: LIST
23878: LIST
23879: LIST
23880: PUSH
23881: LD_INT 27
23883: PUSH
23884: LD_INT 28
23886: PUSH
23887: LD_INT 26
23889: PUSH
23890: LD_INT 30
23892: PUSH
23893: EMPTY
23894: LIST
23895: LIST
23896: LIST
23897: LIST
23898: PUSH
23899: LD_INT 43
23901: PUSH
23902: LD_INT 44
23904: PUSH
23905: LD_INT 46
23907: PUSH
23908: LD_INT 45
23910: PUSH
23911: LD_INT 47
23913: PUSH
23914: LD_INT 49
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: LIST
23921: LIST
23922: LIST
23923: LIST
23924: PUSH
23925: EMPTY
23926: LIST
23927: LIST
23928: LIST
23929: PUSH
23930: LD_VAR 0 12
23934: ARRAY
23935: ST_TO_ADDR
// list := list isect fac_list ;
23936: LD_ADDR_VAR 0 5
23940: PUSH
23941: LD_VAR 0 5
23945: PUSH
23946: LD_VAR 0 17
23950: ISECT
23951: ST_TO_ADDR
// if not list then
23952: LD_VAR 0 5
23956: NOT
23957: IFFALSE 23961
// exit ;
23959: GO 24765
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
23961: LD_VAR 0 12
23965: PUSH
23966: LD_INT 3
23968: EQUAL
23969: PUSH
23970: LD_INT 49
23972: PUSH
23973: LD_VAR 0 5
23977: IN
23978: AND
23979: PUSH
23980: LD_INT 31
23982: PPUSH
23983: LD_VAR 0 16
23987: PPUSH
23988: CALL_OW 321
23992: PUSH
23993: LD_INT 2
23995: EQUAL
23996: AND
23997: IFFALSE 24057
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
23999: LD_INT 22
24001: PUSH
24002: LD_VAR 0 16
24006: PUSH
24007: EMPTY
24008: LIST
24009: LIST
24010: PUSH
24011: LD_INT 35
24013: PUSH
24014: LD_INT 49
24016: PUSH
24017: EMPTY
24018: LIST
24019: LIST
24020: PUSH
24021: LD_INT 91
24023: PUSH
24024: LD_VAR 0 1
24028: PUSH
24029: LD_INT 10
24031: PUSH
24032: EMPTY
24033: LIST
24034: LIST
24035: LIST
24036: PUSH
24037: EMPTY
24038: LIST
24039: LIST
24040: LIST
24041: PPUSH
24042: CALL_OW 69
24046: NOT
24047: IFFALSE 24057
// weapon := ru_time_lapser ;
24049: LD_ADDR_VAR 0 18
24053: PUSH
24054: LD_INT 49
24056: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24057: LD_VAR 0 12
24061: PUSH
24062: LD_INT 1
24064: PUSH
24065: LD_INT 2
24067: PUSH
24068: EMPTY
24069: LIST
24070: LIST
24071: IN
24072: PUSH
24073: LD_INT 11
24075: PUSH
24076: LD_VAR 0 5
24080: IN
24081: PUSH
24082: LD_INT 30
24084: PUSH
24085: LD_VAR 0 5
24089: IN
24090: OR
24091: AND
24092: PUSH
24093: LD_INT 6
24095: PPUSH
24096: LD_VAR 0 16
24100: PPUSH
24101: CALL_OW 321
24105: PUSH
24106: LD_INT 2
24108: EQUAL
24109: AND
24110: IFFALSE 24275
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24112: LD_INT 22
24114: PUSH
24115: LD_VAR 0 16
24119: PUSH
24120: EMPTY
24121: LIST
24122: LIST
24123: PUSH
24124: LD_INT 2
24126: PUSH
24127: LD_INT 35
24129: PUSH
24130: LD_INT 11
24132: PUSH
24133: EMPTY
24134: LIST
24135: LIST
24136: PUSH
24137: LD_INT 35
24139: PUSH
24140: LD_INT 30
24142: PUSH
24143: EMPTY
24144: LIST
24145: LIST
24146: PUSH
24147: EMPTY
24148: LIST
24149: LIST
24150: LIST
24151: PUSH
24152: LD_INT 91
24154: PUSH
24155: LD_VAR 0 1
24159: PUSH
24160: LD_INT 18
24162: PUSH
24163: EMPTY
24164: LIST
24165: LIST
24166: LIST
24167: PUSH
24168: EMPTY
24169: LIST
24170: LIST
24171: LIST
24172: PPUSH
24173: CALL_OW 69
24177: NOT
24178: PUSH
24179: LD_INT 22
24181: PUSH
24182: LD_VAR 0 16
24186: PUSH
24187: EMPTY
24188: LIST
24189: LIST
24190: PUSH
24191: LD_INT 2
24193: PUSH
24194: LD_INT 30
24196: PUSH
24197: LD_INT 32
24199: PUSH
24200: EMPTY
24201: LIST
24202: LIST
24203: PUSH
24204: LD_INT 30
24206: PUSH
24207: LD_INT 33
24209: PUSH
24210: EMPTY
24211: LIST
24212: LIST
24213: PUSH
24214: EMPTY
24215: LIST
24216: LIST
24217: LIST
24218: PUSH
24219: LD_INT 91
24221: PUSH
24222: LD_VAR 0 1
24226: PUSH
24227: LD_INT 12
24229: PUSH
24230: EMPTY
24231: LIST
24232: LIST
24233: LIST
24234: PUSH
24235: EMPTY
24236: LIST
24237: LIST
24238: LIST
24239: PUSH
24240: EMPTY
24241: LIST
24242: PPUSH
24243: CALL_OW 69
24247: PUSH
24248: LD_INT 2
24250: GREATER
24251: AND
24252: IFFALSE 24275
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24254: LD_ADDR_VAR 0 18
24258: PUSH
24259: LD_INT 11
24261: PUSH
24262: LD_INT 30
24264: PUSH
24265: EMPTY
24266: LIST
24267: LIST
24268: PUSH
24269: LD_VAR 0 12
24273: ARRAY
24274: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24275: LD_VAR 0 18
24279: NOT
24280: PUSH
24281: LD_INT 40
24283: PPUSH
24284: LD_VAR 0 16
24288: PPUSH
24289: CALL_OW 321
24293: PUSH
24294: LD_INT 2
24296: EQUAL
24297: AND
24298: PUSH
24299: LD_INT 7
24301: PUSH
24302: LD_VAR 0 5
24306: IN
24307: PUSH
24308: LD_INT 28
24310: PUSH
24311: LD_VAR 0 5
24315: IN
24316: OR
24317: PUSH
24318: LD_INT 45
24320: PUSH
24321: LD_VAR 0 5
24325: IN
24326: OR
24327: AND
24328: IFFALSE 24582
// begin hex := GetHexInfo ( x , y ) ;
24330: LD_ADDR_VAR 0 4
24334: PUSH
24335: LD_VAR 0 10
24339: PPUSH
24340: LD_VAR 0 11
24344: PPUSH
24345: CALL_OW 546
24349: ST_TO_ADDR
// if hex [ 1 ] then
24350: LD_VAR 0 4
24354: PUSH
24355: LD_INT 1
24357: ARRAY
24358: IFFALSE 24362
// exit ;
24360: GO 24765
// height := hex [ 2 ] ;
24362: LD_ADDR_VAR 0 15
24366: PUSH
24367: LD_VAR 0 4
24371: PUSH
24372: LD_INT 2
24374: ARRAY
24375: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
24376: LD_ADDR_VAR 0 14
24380: PUSH
24381: LD_INT 0
24383: PUSH
24384: LD_INT 2
24386: PUSH
24387: LD_INT 3
24389: PUSH
24390: LD_INT 5
24392: PUSH
24393: EMPTY
24394: LIST
24395: LIST
24396: LIST
24397: LIST
24398: ST_TO_ADDR
// for i in tmp do
24399: LD_ADDR_VAR 0 8
24403: PUSH
24404: LD_VAR 0 14
24408: PUSH
24409: FOR_IN
24410: IFFALSE 24580
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
24412: LD_ADDR_VAR 0 9
24416: PUSH
24417: LD_VAR 0 10
24421: PPUSH
24422: LD_VAR 0 8
24426: PPUSH
24427: LD_INT 5
24429: PPUSH
24430: CALL_OW 272
24434: PUSH
24435: LD_VAR 0 11
24439: PPUSH
24440: LD_VAR 0 8
24444: PPUSH
24445: LD_INT 5
24447: PPUSH
24448: CALL_OW 273
24452: PUSH
24453: EMPTY
24454: LIST
24455: LIST
24456: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24457: LD_VAR 0 9
24461: PUSH
24462: LD_INT 1
24464: ARRAY
24465: PPUSH
24466: LD_VAR 0 9
24470: PUSH
24471: LD_INT 2
24473: ARRAY
24474: PPUSH
24475: CALL_OW 488
24479: IFFALSE 24578
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24481: LD_ADDR_VAR 0 4
24485: PUSH
24486: LD_VAR 0 9
24490: PUSH
24491: LD_INT 1
24493: ARRAY
24494: PPUSH
24495: LD_VAR 0 9
24499: PUSH
24500: LD_INT 2
24502: ARRAY
24503: PPUSH
24504: CALL_OW 546
24508: ST_TO_ADDR
// if hex [ 1 ] then
24509: LD_VAR 0 4
24513: PUSH
24514: LD_INT 1
24516: ARRAY
24517: IFFALSE 24521
// continue ;
24519: GO 24409
// h := hex [ 2 ] ;
24521: LD_ADDR_VAR 0 13
24525: PUSH
24526: LD_VAR 0 4
24530: PUSH
24531: LD_INT 2
24533: ARRAY
24534: ST_TO_ADDR
// if h + 7 < height then
24535: LD_VAR 0 13
24539: PUSH
24540: LD_INT 7
24542: PLUS
24543: PUSH
24544: LD_VAR 0 15
24548: LESS
24549: IFFALSE 24578
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24551: LD_ADDR_VAR 0 18
24555: PUSH
24556: LD_INT 7
24558: PUSH
24559: LD_INT 28
24561: PUSH
24562: LD_INT 45
24564: PUSH
24565: EMPTY
24566: LIST
24567: LIST
24568: LIST
24569: PUSH
24570: LD_VAR 0 12
24574: ARRAY
24575: ST_TO_ADDR
// break ;
24576: GO 24580
// end ; end ; end ;
24578: GO 24409
24580: POP
24581: POP
// end ; if not weapon then
24582: LD_VAR 0 18
24586: NOT
24587: IFFALSE 24647
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24589: LD_ADDR_VAR 0 5
24593: PUSH
24594: LD_VAR 0 5
24598: PUSH
24599: LD_INT 11
24601: PUSH
24602: LD_INT 30
24604: PUSH
24605: LD_INT 49
24607: PUSH
24608: EMPTY
24609: LIST
24610: LIST
24611: LIST
24612: DIFF
24613: ST_TO_ADDR
// if not list then
24614: LD_VAR 0 5
24618: NOT
24619: IFFALSE 24623
// exit ;
24621: GO 24765
// weapon := list [ rand ( 1 , list ) ] ;
24623: LD_ADDR_VAR 0 18
24627: PUSH
24628: LD_VAR 0 5
24632: PUSH
24633: LD_INT 1
24635: PPUSH
24636: LD_VAR 0 5
24640: PPUSH
24641: CALL_OW 12
24645: ARRAY
24646: ST_TO_ADDR
// end ; if weapon then
24647: LD_VAR 0 18
24651: IFFALSE 24765
// begin tmp := CostOfWeapon ( weapon ) ;
24653: LD_ADDR_VAR 0 14
24657: PUSH
24658: LD_VAR 0 18
24662: PPUSH
24663: CALL_OW 451
24667: ST_TO_ADDR
// j := GetBase ( tower ) ;
24668: LD_ADDR_VAR 0 9
24672: PUSH
24673: LD_VAR 0 1
24677: PPUSH
24678: CALL_OW 274
24682: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24683: LD_VAR 0 9
24687: PPUSH
24688: LD_INT 1
24690: PPUSH
24691: CALL_OW 275
24695: PUSH
24696: LD_VAR 0 14
24700: PUSH
24701: LD_INT 1
24703: ARRAY
24704: GREATEREQUAL
24705: PUSH
24706: LD_VAR 0 9
24710: PPUSH
24711: LD_INT 2
24713: PPUSH
24714: CALL_OW 275
24718: PUSH
24719: LD_VAR 0 14
24723: PUSH
24724: LD_INT 2
24726: ARRAY
24727: GREATEREQUAL
24728: AND
24729: PUSH
24730: LD_VAR 0 9
24734: PPUSH
24735: LD_INT 3
24737: PPUSH
24738: CALL_OW 275
24742: PUSH
24743: LD_VAR 0 14
24747: PUSH
24748: LD_INT 3
24750: ARRAY
24751: GREATEREQUAL
24752: AND
24753: IFFALSE 24765
// result := weapon ;
24755: LD_ADDR_VAR 0 3
24759: PUSH
24760: LD_VAR 0 18
24764: ST_TO_ADDR
// end ; end ;
24765: LD_VAR 0 3
24769: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24770: LD_INT 0
24772: PPUSH
24773: PPUSH
// result := true ;
24774: LD_ADDR_VAR 0 3
24778: PUSH
24779: LD_INT 1
24781: ST_TO_ADDR
// if array1 = array2 then
24782: LD_VAR 0 1
24786: PUSH
24787: LD_VAR 0 2
24791: EQUAL
24792: IFFALSE 24852
// begin for i = 1 to array1 do
24794: LD_ADDR_VAR 0 4
24798: PUSH
24799: DOUBLE
24800: LD_INT 1
24802: DEC
24803: ST_TO_ADDR
24804: LD_VAR 0 1
24808: PUSH
24809: FOR_TO
24810: IFFALSE 24848
// if array1 [ i ] <> array2 [ i ] then
24812: LD_VAR 0 1
24816: PUSH
24817: LD_VAR 0 4
24821: ARRAY
24822: PUSH
24823: LD_VAR 0 2
24827: PUSH
24828: LD_VAR 0 4
24832: ARRAY
24833: NONEQUAL
24834: IFFALSE 24846
// begin result := false ;
24836: LD_ADDR_VAR 0 3
24840: PUSH
24841: LD_INT 0
24843: ST_TO_ADDR
// break ;
24844: GO 24848
// end ;
24846: GO 24809
24848: POP
24849: POP
// end else
24850: GO 24860
// result := false ;
24852: LD_ADDR_VAR 0 3
24856: PUSH
24857: LD_INT 0
24859: ST_TO_ADDR
// end ;
24860: LD_VAR 0 3
24864: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
24865: LD_INT 0
24867: PPUSH
24868: PPUSH
// if not array1 or not array2 then
24869: LD_VAR 0 1
24873: NOT
24874: PUSH
24875: LD_VAR 0 2
24879: NOT
24880: OR
24881: IFFALSE 24885
// exit ;
24883: GO 24949
// result := true ;
24885: LD_ADDR_VAR 0 3
24889: PUSH
24890: LD_INT 1
24892: ST_TO_ADDR
// for i = 1 to array1 do
24893: LD_ADDR_VAR 0 4
24897: PUSH
24898: DOUBLE
24899: LD_INT 1
24901: DEC
24902: ST_TO_ADDR
24903: LD_VAR 0 1
24907: PUSH
24908: FOR_TO
24909: IFFALSE 24947
// if array1 [ i ] <> array2 [ i ] then
24911: LD_VAR 0 1
24915: PUSH
24916: LD_VAR 0 4
24920: ARRAY
24921: PUSH
24922: LD_VAR 0 2
24926: PUSH
24927: LD_VAR 0 4
24931: ARRAY
24932: NONEQUAL
24933: IFFALSE 24945
// begin result := false ;
24935: LD_ADDR_VAR 0 3
24939: PUSH
24940: LD_INT 0
24942: ST_TO_ADDR
// break ;
24943: GO 24947
// end ;
24945: GO 24908
24947: POP
24948: POP
// end ;
24949: LD_VAR 0 3
24953: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
24954: LD_INT 0
24956: PPUSH
24957: PPUSH
24958: PPUSH
// pom := GetBase ( fac ) ;
24959: LD_ADDR_VAR 0 5
24963: PUSH
24964: LD_VAR 0 1
24968: PPUSH
24969: CALL_OW 274
24973: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24974: LD_ADDR_VAR 0 4
24978: PUSH
24979: LD_VAR 0 2
24983: PUSH
24984: LD_INT 1
24986: ARRAY
24987: PPUSH
24988: LD_VAR 0 2
24992: PUSH
24993: LD_INT 2
24995: ARRAY
24996: PPUSH
24997: LD_VAR 0 2
25001: PUSH
25002: LD_INT 3
25004: ARRAY
25005: PPUSH
25006: LD_VAR 0 2
25010: PUSH
25011: LD_INT 4
25013: ARRAY
25014: PPUSH
25015: CALL_OW 449
25019: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25020: LD_ADDR_VAR 0 3
25024: PUSH
25025: LD_VAR 0 5
25029: PPUSH
25030: LD_INT 1
25032: PPUSH
25033: CALL_OW 275
25037: PUSH
25038: LD_VAR 0 4
25042: PUSH
25043: LD_INT 1
25045: ARRAY
25046: GREATEREQUAL
25047: PUSH
25048: LD_VAR 0 5
25052: PPUSH
25053: LD_INT 2
25055: PPUSH
25056: CALL_OW 275
25060: PUSH
25061: LD_VAR 0 4
25065: PUSH
25066: LD_INT 2
25068: ARRAY
25069: GREATEREQUAL
25070: AND
25071: PUSH
25072: LD_VAR 0 5
25076: PPUSH
25077: LD_INT 3
25079: PPUSH
25080: CALL_OW 275
25084: PUSH
25085: LD_VAR 0 4
25089: PUSH
25090: LD_INT 3
25092: ARRAY
25093: GREATEREQUAL
25094: AND
25095: ST_TO_ADDR
// end ;
25096: LD_VAR 0 3
25100: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25101: LD_INT 0
25103: PPUSH
25104: PPUSH
25105: PPUSH
25106: PPUSH
// pom := GetBase ( building ) ;
25107: LD_ADDR_VAR 0 3
25111: PUSH
25112: LD_VAR 0 1
25116: PPUSH
25117: CALL_OW 274
25121: ST_TO_ADDR
// if not pom then
25122: LD_VAR 0 3
25126: NOT
25127: IFFALSE 25131
// exit ;
25129: GO 25301
// btype := GetBType ( building ) ;
25131: LD_ADDR_VAR 0 5
25135: PUSH
25136: LD_VAR 0 1
25140: PPUSH
25141: CALL_OW 266
25145: ST_TO_ADDR
// if btype = b_armoury then
25146: LD_VAR 0 5
25150: PUSH
25151: LD_INT 4
25153: EQUAL
25154: IFFALSE 25164
// btype := b_barracks ;
25156: LD_ADDR_VAR 0 5
25160: PUSH
25161: LD_INT 5
25163: ST_TO_ADDR
// if btype = b_depot then
25164: LD_VAR 0 5
25168: PUSH
25169: LD_INT 0
25171: EQUAL
25172: IFFALSE 25182
// btype := b_warehouse ;
25174: LD_ADDR_VAR 0 5
25178: PUSH
25179: LD_INT 1
25181: ST_TO_ADDR
// if btype = b_workshop then
25182: LD_VAR 0 5
25186: PUSH
25187: LD_INT 2
25189: EQUAL
25190: IFFALSE 25200
// btype := b_factory ;
25192: LD_ADDR_VAR 0 5
25196: PUSH
25197: LD_INT 3
25199: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25200: LD_ADDR_VAR 0 4
25204: PUSH
25205: LD_VAR 0 5
25209: PPUSH
25210: LD_VAR 0 1
25214: PPUSH
25215: CALL_OW 248
25219: PPUSH
25220: CALL_OW 450
25224: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25225: LD_ADDR_VAR 0 2
25229: PUSH
25230: LD_VAR 0 3
25234: PPUSH
25235: LD_INT 1
25237: PPUSH
25238: CALL_OW 275
25242: PUSH
25243: LD_VAR 0 4
25247: PUSH
25248: LD_INT 1
25250: ARRAY
25251: GREATEREQUAL
25252: PUSH
25253: LD_VAR 0 3
25257: PPUSH
25258: LD_INT 2
25260: PPUSH
25261: CALL_OW 275
25265: PUSH
25266: LD_VAR 0 4
25270: PUSH
25271: LD_INT 2
25273: ARRAY
25274: GREATEREQUAL
25275: AND
25276: PUSH
25277: LD_VAR 0 3
25281: PPUSH
25282: LD_INT 3
25284: PPUSH
25285: CALL_OW 275
25289: PUSH
25290: LD_VAR 0 4
25294: PUSH
25295: LD_INT 3
25297: ARRAY
25298: GREATEREQUAL
25299: AND
25300: ST_TO_ADDR
// end ;
25301: LD_VAR 0 2
25305: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25306: LD_INT 0
25308: PPUSH
25309: PPUSH
25310: PPUSH
// pom := GetBase ( building ) ;
25311: LD_ADDR_VAR 0 4
25315: PUSH
25316: LD_VAR 0 1
25320: PPUSH
25321: CALL_OW 274
25325: ST_TO_ADDR
// if not pom then
25326: LD_VAR 0 4
25330: NOT
25331: IFFALSE 25335
// exit ;
25333: GO 25436
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25335: LD_ADDR_VAR 0 5
25339: PUSH
25340: LD_VAR 0 2
25344: PPUSH
25345: LD_VAR 0 1
25349: PPUSH
25350: CALL_OW 248
25354: PPUSH
25355: CALL_OW 450
25359: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25360: LD_ADDR_VAR 0 3
25364: PUSH
25365: LD_VAR 0 4
25369: PPUSH
25370: LD_INT 1
25372: PPUSH
25373: CALL_OW 275
25377: PUSH
25378: LD_VAR 0 5
25382: PUSH
25383: LD_INT 1
25385: ARRAY
25386: GREATEREQUAL
25387: PUSH
25388: LD_VAR 0 4
25392: PPUSH
25393: LD_INT 2
25395: PPUSH
25396: CALL_OW 275
25400: PUSH
25401: LD_VAR 0 5
25405: PUSH
25406: LD_INT 2
25408: ARRAY
25409: GREATEREQUAL
25410: AND
25411: PUSH
25412: LD_VAR 0 4
25416: PPUSH
25417: LD_INT 3
25419: PPUSH
25420: CALL_OW 275
25424: PUSH
25425: LD_VAR 0 5
25429: PUSH
25430: LD_INT 3
25432: ARRAY
25433: GREATEREQUAL
25434: AND
25435: ST_TO_ADDR
// end ;
25436: LD_VAR 0 3
25440: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
25441: LD_INT 0
25443: PPUSH
25444: PPUSH
25445: PPUSH
25446: PPUSH
25447: PPUSH
25448: PPUSH
25449: PPUSH
25450: PPUSH
25451: PPUSH
25452: PPUSH
25453: PPUSH
// result := false ;
25454: LD_ADDR_VAR 0 8
25458: PUSH
25459: LD_INT 0
25461: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
25462: LD_VAR 0 5
25466: NOT
25467: PUSH
25468: LD_VAR 0 1
25472: NOT
25473: OR
25474: PUSH
25475: LD_VAR 0 2
25479: NOT
25480: OR
25481: PUSH
25482: LD_VAR 0 3
25486: NOT
25487: OR
25488: IFFALSE 25492
// exit ;
25490: GO 26306
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
25492: LD_ADDR_VAR 0 14
25496: PUSH
25497: LD_VAR 0 1
25501: PPUSH
25502: LD_VAR 0 2
25506: PPUSH
25507: LD_VAR 0 3
25511: PPUSH
25512: LD_VAR 0 4
25516: PPUSH
25517: LD_VAR 0 5
25521: PUSH
25522: LD_INT 1
25524: ARRAY
25525: PPUSH
25526: CALL_OW 248
25530: PPUSH
25531: LD_INT 0
25533: PPUSH
25534: CALL 27543 0 6
25538: ST_TO_ADDR
// if not hexes then
25539: LD_VAR 0 14
25543: NOT
25544: IFFALSE 25548
// exit ;
25546: GO 26306
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25548: LD_ADDR_VAR 0 17
25552: PUSH
25553: LD_VAR 0 5
25557: PPUSH
25558: LD_INT 22
25560: PUSH
25561: LD_VAR 0 13
25565: PPUSH
25566: CALL_OW 255
25570: PUSH
25571: EMPTY
25572: LIST
25573: LIST
25574: PUSH
25575: LD_INT 2
25577: PUSH
25578: LD_INT 30
25580: PUSH
25581: LD_INT 0
25583: PUSH
25584: EMPTY
25585: LIST
25586: LIST
25587: PUSH
25588: LD_INT 30
25590: PUSH
25591: LD_INT 1
25593: PUSH
25594: EMPTY
25595: LIST
25596: LIST
25597: PUSH
25598: EMPTY
25599: LIST
25600: LIST
25601: LIST
25602: PUSH
25603: EMPTY
25604: LIST
25605: LIST
25606: PPUSH
25607: CALL_OW 72
25611: ST_TO_ADDR
// for i = 1 to hexes do
25612: LD_ADDR_VAR 0 9
25616: PUSH
25617: DOUBLE
25618: LD_INT 1
25620: DEC
25621: ST_TO_ADDR
25622: LD_VAR 0 14
25626: PUSH
25627: FOR_TO
25628: IFFALSE 26304
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25630: LD_ADDR_VAR 0 13
25634: PUSH
25635: LD_VAR 0 14
25639: PUSH
25640: LD_VAR 0 9
25644: ARRAY
25645: PUSH
25646: LD_INT 1
25648: ARRAY
25649: PPUSH
25650: LD_VAR 0 14
25654: PUSH
25655: LD_VAR 0 9
25659: ARRAY
25660: PUSH
25661: LD_INT 2
25663: ARRAY
25664: PPUSH
25665: CALL_OW 428
25669: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25670: LD_VAR 0 14
25674: PUSH
25675: LD_VAR 0 9
25679: ARRAY
25680: PUSH
25681: LD_INT 1
25683: ARRAY
25684: PPUSH
25685: LD_VAR 0 14
25689: PUSH
25690: LD_VAR 0 9
25694: ARRAY
25695: PUSH
25696: LD_INT 2
25698: ARRAY
25699: PPUSH
25700: CALL_OW 351
25704: PUSH
25705: LD_VAR 0 14
25709: PUSH
25710: LD_VAR 0 9
25714: ARRAY
25715: PUSH
25716: LD_INT 1
25718: ARRAY
25719: PPUSH
25720: LD_VAR 0 14
25724: PUSH
25725: LD_VAR 0 9
25729: ARRAY
25730: PUSH
25731: LD_INT 2
25733: ARRAY
25734: PPUSH
25735: CALL_OW 488
25739: NOT
25740: OR
25741: PUSH
25742: LD_VAR 0 13
25746: PPUSH
25747: CALL_OW 247
25751: PUSH
25752: LD_INT 3
25754: EQUAL
25755: OR
25756: IFFALSE 25762
// exit ;
25758: POP
25759: POP
25760: GO 26306
// if not tmp then
25762: LD_VAR 0 13
25766: NOT
25767: IFFALSE 25771
// continue ;
25769: GO 25627
// result := true ;
25771: LD_ADDR_VAR 0 8
25775: PUSH
25776: LD_INT 1
25778: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
25779: LD_VAR 0 6
25783: PUSH
25784: LD_VAR 0 13
25788: PPUSH
25789: CALL_OW 247
25793: PUSH
25794: LD_INT 2
25796: EQUAL
25797: AND
25798: PUSH
25799: LD_VAR 0 13
25803: PPUSH
25804: CALL_OW 263
25808: PUSH
25809: LD_INT 1
25811: EQUAL
25812: AND
25813: IFFALSE 25977
// begin if IsDrivenBy ( tmp ) then
25815: LD_VAR 0 13
25819: PPUSH
25820: CALL_OW 311
25824: IFFALSE 25828
// continue ;
25826: GO 25627
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
25828: LD_VAR 0 6
25832: PPUSH
25833: LD_INT 3
25835: PUSH
25836: LD_INT 60
25838: PUSH
25839: EMPTY
25840: LIST
25841: PUSH
25842: EMPTY
25843: LIST
25844: LIST
25845: PUSH
25846: LD_INT 3
25848: PUSH
25849: LD_INT 55
25851: PUSH
25852: EMPTY
25853: LIST
25854: PUSH
25855: EMPTY
25856: LIST
25857: LIST
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: PPUSH
25863: CALL_OW 72
25867: IFFALSE 25975
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
25869: LD_ADDR_VAR 0 18
25873: PUSH
25874: LD_VAR 0 6
25878: PPUSH
25879: LD_INT 3
25881: PUSH
25882: LD_INT 60
25884: PUSH
25885: EMPTY
25886: LIST
25887: PUSH
25888: EMPTY
25889: LIST
25890: LIST
25891: PUSH
25892: LD_INT 3
25894: PUSH
25895: LD_INT 55
25897: PUSH
25898: EMPTY
25899: LIST
25900: PUSH
25901: EMPTY
25902: LIST
25903: LIST
25904: PUSH
25905: EMPTY
25906: LIST
25907: LIST
25908: PPUSH
25909: CALL_OW 72
25913: PUSH
25914: LD_INT 1
25916: ARRAY
25917: ST_TO_ADDR
// if IsInUnit ( driver ) then
25918: LD_VAR 0 18
25922: PPUSH
25923: CALL_OW 310
25927: IFFALSE 25938
// ComExit ( driver ) ;
25929: LD_VAR 0 18
25933: PPUSH
25934: CALL 50727 0 1
// AddComEnterUnit ( driver , tmp ) ;
25938: LD_VAR 0 18
25942: PPUSH
25943: LD_VAR 0 13
25947: PPUSH
25948: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
25952: LD_VAR 0 18
25956: PPUSH
25957: LD_VAR 0 7
25961: PPUSH
25962: CALL_OW 173
// AddComExitVehicle ( driver ) ;
25966: LD_VAR 0 18
25970: PPUSH
25971: CALL_OW 181
// end ; continue ;
25975: GO 25627
// end ; if not cleaners or not tmp in cleaners then
25977: LD_VAR 0 6
25981: NOT
25982: PUSH
25983: LD_VAR 0 13
25987: PUSH
25988: LD_VAR 0 6
25992: IN
25993: NOT
25994: OR
25995: IFFALSE 26302
// begin if dep then
25997: LD_VAR 0 17
26001: IFFALSE 26137
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
26003: LD_ADDR_VAR 0 16
26007: PUSH
26008: LD_VAR 0 17
26012: PUSH
26013: LD_INT 1
26015: ARRAY
26016: PPUSH
26017: CALL_OW 250
26021: PPUSH
26022: LD_VAR 0 17
26026: PUSH
26027: LD_INT 1
26029: ARRAY
26030: PPUSH
26031: CALL_OW 254
26035: PPUSH
26036: LD_INT 5
26038: PPUSH
26039: CALL_OW 272
26043: PUSH
26044: LD_VAR 0 17
26048: PUSH
26049: LD_INT 1
26051: ARRAY
26052: PPUSH
26053: CALL_OW 251
26057: PPUSH
26058: LD_VAR 0 17
26062: PUSH
26063: LD_INT 1
26065: ARRAY
26066: PPUSH
26067: CALL_OW 254
26071: PPUSH
26072: LD_INT 5
26074: PPUSH
26075: CALL_OW 273
26079: PUSH
26080: EMPTY
26081: LIST
26082: LIST
26083: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26084: LD_VAR 0 16
26088: PUSH
26089: LD_INT 1
26091: ARRAY
26092: PPUSH
26093: LD_VAR 0 16
26097: PUSH
26098: LD_INT 2
26100: ARRAY
26101: PPUSH
26102: CALL_OW 488
26106: IFFALSE 26137
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26108: LD_VAR 0 13
26112: PPUSH
26113: LD_VAR 0 16
26117: PUSH
26118: LD_INT 1
26120: ARRAY
26121: PPUSH
26122: LD_VAR 0 16
26126: PUSH
26127: LD_INT 2
26129: ARRAY
26130: PPUSH
26131: CALL_OW 111
// continue ;
26135: GO 25627
// end ; end ; r := GetDir ( tmp ) ;
26137: LD_ADDR_VAR 0 15
26141: PUSH
26142: LD_VAR 0 13
26146: PPUSH
26147: CALL_OW 254
26151: ST_TO_ADDR
// if r = 5 then
26152: LD_VAR 0 15
26156: PUSH
26157: LD_INT 5
26159: EQUAL
26160: IFFALSE 26170
// r := 0 ;
26162: LD_ADDR_VAR 0 15
26166: PUSH
26167: LD_INT 0
26169: ST_TO_ADDR
// for j = r to 5 do
26170: LD_ADDR_VAR 0 10
26174: PUSH
26175: DOUBLE
26176: LD_VAR 0 15
26180: DEC
26181: ST_TO_ADDR
26182: LD_INT 5
26184: PUSH
26185: FOR_TO
26186: IFFALSE 26300
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26188: LD_ADDR_VAR 0 11
26192: PUSH
26193: LD_VAR 0 13
26197: PPUSH
26198: CALL_OW 250
26202: PPUSH
26203: LD_VAR 0 10
26207: PPUSH
26208: LD_INT 2
26210: PPUSH
26211: CALL_OW 272
26215: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26216: LD_ADDR_VAR 0 12
26220: PUSH
26221: LD_VAR 0 13
26225: PPUSH
26226: CALL_OW 251
26230: PPUSH
26231: LD_VAR 0 10
26235: PPUSH
26236: LD_INT 2
26238: PPUSH
26239: CALL_OW 273
26243: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26244: LD_VAR 0 11
26248: PPUSH
26249: LD_VAR 0 12
26253: PPUSH
26254: CALL_OW 488
26258: PUSH
26259: LD_VAR 0 11
26263: PPUSH
26264: LD_VAR 0 12
26268: PPUSH
26269: CALL_OW 428
26273: NOT
26274: AND
26275: IFFALSE 26298
// begin ComMoveXY ( tmp , _x , _y ) ;
26277: LD_VAR 0 13
26281: PPUSH
26282: LD_VAR 0 11
26286: PPUSH
26287: LD_VAR 0 12
26291: PPUSH
26292: CALL_OW 111
// break ;
26296: GO 26300
// end ; end ;
26298: GO 26185
26300: POP
26301: POP
// end ; end ;
26302: GO 25627
26304: POP
26305: POP
// end ;
26306: LD_VAR 0 8
26310: RET
// export function BuildingTechInvented ( side , btype ) ; begin
26311: LD_INT 0
26313: PPUSH
// result := true ;
26314: LD_ADDR_VAR 0 3
26318: PUSH
26319: LD_INT 1
26321: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
26322: LD_VAR 0 2
26326: PUSH
26327: LD_INT 24
26329: DOUBLE
26330: EQUAL
26331: IFTRUE 26341
26333: LD_INT 33
26335: DOUBLE
26336: EQUAL
26337: IFTRUE 26341
26339: GO 26366
26341: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
26342: LD_ADDR_VAR 0 3
26346: PUSH
26347: LD_INT 32
26349: PPUSH
26350: LD_VAR 0 1
26354: PPUSH
26355: CALL_OW 321
26359: PUSH
26360: LD_INT 2
26362: EQUAL
26363: ST_TO_ADDR
26364: GO 26686
26366: LD_INT 20
26368: DOUBLE
26369: EQUAL
26370: IFTRUE 26374
26372: GO 26399
26374: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
26375: LD_ADDR_VAR 0 3
26379: PUSH
26380: LD_INT 6
26382: PPUSH
26383: LD_VAR 0 1
26387: PPUSH
26388: CALL_OW 321
26392: PUSH
26393: LD_INT 2
26395: EQUAL
26396: ST_TO_ADDR
26397: GO 26686
26399: LD_INT 22
26401: DOUBLE
26402: EQUAL
26403: IFTRUE 26413
26405: LD_INT 36
26407: DOUBLE
26408: EQUAL
26409: IFTRUE 26413
26411: GO 26438
26413: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
26414: LD_ADDR_VAR 0 3
26418: PUSH
26419: LD_INT 15
26421: PPUSH
26422: LD_VAR 0 1
26426: PPUSH
26427: CALL_OW 321
26431: PUSH
26432: LD_INT 2
26434: EQUAL
26435: ST_TO_ADDR
26436: GO 26686
26438: LD_INT 30
26440: DOUBLE
26441: EQUAL
26442: IFTRUE 26446
26444: GO 26471
26446: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
26447: LD_ADDR_VAR 0 3
26451: PUSH
26452: LD_INT 20
26454: PPUSH
26455: LD_VAR 0 1
26459: PPUSH
26460: CALL_OW 321
26464: PUSH
26465: LD_INT 2
26467: EQUAL
26468: ST_TO_ADDR
26469: GO 26686
26471: LD_INT 28
26473: DOUBLE
26474: EQUAL
26475: IFTRUE 26485
26477: LD_INT 21
26479: DOUBLE
26480: EQUAL
26481: IFTRUE 26485
26483: GO 26510
26485: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
26486: LD_ADDR_VAR 0 3
26490: PUSH
26491: LD_INT 21
26493: PPUSH
26494: LD_VAR 0 1
26498: PPUSH
26499: CALL_OW 321
26503: PUSH
26504: LD_INT 2
26506: EQUAL
26507: ST_TO_ADDR
26508: GO 26686
26510: LD_INT 16
26512: DOUBLE
26513: EQUAL
26514: IFTRUE 26518
26516: GO 26545
26518: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
26519: LD_ADDR_VAR 0 3
26523: PUSH
26524: LD_EXP 60
26528: PPUSH
26529: LD_VAR 0 1
26533: PPUSH
26534: CALL_OW 321
26538: PUSH
26539: LD_INT 2
26541: EQUAL
26542: ST_TO_ADDR
26543: GO 26686
26545: LD_INT 19
26547: DOUBLE
26548: EQUAL
26549: IFTRUE 26559
26551: LD_INT 23
26553: DOUBLE
26554: EQUAL
26555: IFTRUE 26559
26557: GO 26586
26559: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
26560: LD_ADDR_VAR 0 3
26564: PUSH
26565: LD_EXP 59
26569: PPUSH
26570: LD_VAR 0 1
26574: PPUSH
26575: CALL_OW 321
26579: PUSH
26580: LD_INT 2
26582: EQUAL
26583: ST_TO_ADDR
26584: GO 26686
26586: LD_INT 17
26588: DOUBLE
26589: EQUAL
26590: IFTRUE 26594
26592: GO 26619
26594: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
26595: LD_ADDR_VAR 0 3
26599: PUSH
26600: LD_INT 39
26602: PPUSH
26603: LD_VAR 0 1
26607: PPUSH
26608: CALL_OW 321
26612: PUSH
26613: LD_INT 2
26615: EQUAL
26616: ST_TO_ADDR
26617: GO 26686
26619: LD_INT 18
26621: DOUBLE
26622: EQUAL
26623: IFTRUE 26627
26625: GO 26652
26627: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
26628: LD_ADDR_VAR 0 3
26632: PUSH
26633: LD_INT 40
26635: PPUSH
26636: LD_VAR 0 1
26640: PPUSH
26641: CALL_OW 321
26645: PUSH
26646: LD_INT 2
26648: EQUAL
26649: ST_TO_ADDR
26650: GO 26686
26652: LD_INT 27
26654: DOUBLE
26655: EQUAL
26656: IFTRUE 26660
26658: GO 26685
26660: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
26661: LD_ADDR_VAR 0 3
26665: PUSH
26666: LD_INT 35
26668: PPUSH
26669: LD_VAR 0 1
26673: PPUSH
26674: CALL_OW 321
26678: PUSH
26679: LD_INT 2
26681: EQUAL
26682: ST_TO_ADDR
26683: GO 26686
26685: POP
// end ;
26686: LD_VAR 0 3
26690: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
26691: LD_INT 0
26693: PPUSH
26694: PPUSH
26695: PPUSH
26696: PPUSH
26697: PPUSH
26698: PPUSH
26699: PPUSH
26700: PPUSH
26701: PPUSH
26702: PPUSH
26703: PPUSH
// result := false ;
26704: LD_ADDR_VAR 0 6
26708: PUSH
26709: LD_INT 0
26711: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26712: LD_VAR 0 1
26716: NOT
26717: PUSH
26718: LD_VAR 0 1
26722: PPUSH
26723: CALL_OW 266
26727: PUSH
26728: LD_INT 0
26730: PUSH
26731: LD_INT 1
26733: PUSH
26734: EMPTY
26735: LIST
26736: LIST
26737: IN
26738: NOT
26739: OR
26740: PUSH
26741: LD_VAR 0 2
26745: NOT
26746: OR
26747: PUSH
26748: LD_VAR 0 5
26752: PUSH
26753: LD_INT 0
26755: PUSH
26756: LD_INT 1
26758: PUSH
26759: LD_INT 2
26761: PUSH
26762: LD_INT 3
26764: PUSH
26765: LD_INT 4
26767: PUSH
26768: LD_INT 5
26770: PUSH
26771: EMPTY
26772: LIST
26773: LIST
26774: LIST
26775: LIST
26776: LIST
26777: LIST
26778: IN
26779: NOT
26780: OR
26781: PUSH
26782: LD_VAR 0 3
26786: PPUSH
26787: LD_VAR 0 4
26791: PPUSH
26792: CALL_OW 488
26796: NOT
26797: OR
26798: IFFALSE 26802
// exit ;
26800: GO 27538
// side := GetSide ( depot ) ;
26802: LD_ADDR_VAR 0 9
26806: PUSH
26807: LD_VAR 0 1
26811: PPUSH
26812: CALL_OW 255
26816: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
26817: LD_VAR 0 9
26821: PPUSH
26822: LD_VAR 0 2
26826: PPUSH
26827: CALL 26311 0 2
26831: NOT
26832: IFFALSE 26836
// exit ;
26834: GO 27538
// pom := GetBase ( depot ) ;
26836: LD_ADDR_VAR 0 10
26840: PUSH
26841: LD_VAR 0 1
26845: PPUSH
26846: CALL_OW 274
26850: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26851: LD_ADDR_VAR 0 11
26855: PUSH
26856: LD_VAR 0 2
26860: PPUSH
26861: LD_VAR 0 1
26865: PPUSH
26866: CALL_OW 248
26870: PPUSH
26871: CALL_OW 450
26875: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26876: LD_VAR 0 10
26880: PPUSH
26881: LD_INT 1
26883: PPUSH
26884: CALL_OW 275
26888: PUSH
26889: LD_VAR 0 11
26893: PUSH
26894: LD_INT 1
26896: ARRAY
26897: GREATEREQUAL
26898: PUSH
26899: LD_VAR 0 10
26903: PPUSH
26904: LD_INT 2
26906: PPUSH
26907: CALL_OW 275
26911: PUSH
26912: LD_VAR 0 11
26916: PUSH
26917: LD_INT 2
26919: ARRAY
26920: GREATEREQUAL
26921: AND
26922: PUSH
26923: LD_VAR 0 10
26927: PPUSH
26928: LD_INT 3
26930: PPUSH
26931: CALL_OW 275
26935: PUSH
26936: LD_VAR 0 11
26940: PUSH
26941: LD_INT 3
26943: ARRAY
26944: GREATEREQUAL
26945: AND
26946: NOT
26947: IFFALSE 26951
// exit ;
26949: GO 27538
// if GetBType ( depot ) = b_depot then
26951: LD_VAR 0 1
26955: PPUSH
26956: CALL_OW 266
26960: PUSH
26961: LD_INT 0
26963: EQUAL
26964: IFFALSE 26976
// dist := 28 else
26966: LD_ADDR_VAR 0 14
26970: PUSH
26971: LD_INT 28
26973: ST_TO_ADDR
26974: GO 26984
// dist := 36 ;
26976: LD_ADDR_VAR 0 14
26980: PUSH
26981: LD_INT 36
26983: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26984: LD_VAR 0 1
26988: PPUSH
26989: LD_VAR 0 3
26993: PPUSH
26994: LD_VAR 0 4
26998: PPUSH
26999: CALL_OW 297
27003: PUSH
27004: LD_VAR 0 14
27008: GREATER
27009: IFFALSE 27013
// exit ;
27011: GO 27538
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
27013: LD_ADDR_VAR 0 12
27017: PUSH
27018: LD_VAR 0 2
27022: PPUSH
27023: LD_VAR 0 3
27027: PPUSH
27028: LD_VAR 0 4
27032: PPUSH
27033: LD_VAR 0 5
27037: PPUSH
27038: LD_VAR 0 1
27042: PPUSH
27043: CALL_OW 248
27047: PPUSH
27048: LD_INT 0
27050: PPUSH
27051: CALL 27543 0 6
27055: ST_TO_ADDR
// if not hexes then
27056: LD_VAR 0 12
27060: NOT
27061: IFFALSE 27065
// exit ;
27063: GO 27538
// hex := GetHexInfo ( x , y ) ;
27065: LD_ADDR_VAR 0 15
27069: PUSH
27070: LD_VAR 0 3
27074: PPUSH
27075: LD_VAR 0 4
27079: PPUSH
27080: CALL_OW 546
27084: ST_TO_ADDR
// if hex [ 1 ] then
27085: LD_VAR 0 15
27089: PUSH
27090: LD_INT 1
27092: ARRAY
27093: IFFALSE 27097
// exit ;
27095: GO 27538
// height := hex [ 2 ] ;
27097: LD_ADDR_VAR 0 13
27101: PUSH
27102: LD_VAR 0 15
27106: PUSH
27107: LD_INT 2
27109: ARRAY
27110: ST_TO_ADDR
// for i = 1 to hexes do
27111: LD_ADDR_VAR 0 7
27115: PUSH
27116: DOUBLE
27117: LD_INT 1
27119: DEC
27120: ST_TO_ADDR
27121: LD_VAR 0 12
27125: PUSH
27126: FOR_TO
27127: IFFALSE 27457
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27129: LD_VAR 0 12
27133: PUSH
27134: LD_VAR 0 7
27138: ARRAY
27139: PUSH
27140: LD_INT 1
27142: ARRAY
27143: PPUSH
27144: LD_VAR 0 12
27148: PUSH
27149: LD_VAR 0 7
27153: ARRAY
27154: PUSH
27155: LD_INT 2
27157: ARRAY
27158: PPUSH
27159: CALL_OW 488
27163: NOT
27164: PUSH
27165: LD_VAR 0 12
27169: PUSH
27170: LD_VAR 0 7
27174: ARRAY
27175: PUSH
27176: LD_INT 1
27178: ARRAY
27179: PPUSH
27180: LD_VAR 0 12
27184: PUSH
27185: LD_VAR 0 7
27189: ARRAY
27190: PUSH
27191: LD_INT 2
27193: ARRAY
27194: PPUSH
27195: CALL_OW 428
27199: PUSH
27200: LD_INT 0
27202: GREATER
27203: OR
27204: PUSH
27205: LD_VAR 0 12
27209: PUSH
27210: LD_VAR 0 7
27214: ARRAY
27215: PUSH
27216: LD_INT 1
27218: ARRAY
27219: PPUSH
27220: LD_VAR 0 12
27224: PUSH
27225: LD_VAR 0 7
27229: ARRAY
27230: PUSH
27231: LD_INT 2
27233: ARRAY
27234: PPUSH
27235: CALL_OW 351
27239: OR
27240: IFFALSE 27246
// exit ;
27242: POP
27243: POP
27244: GO 27538
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27246: LD_ADDR_VAR 0 8
27250: PUSH
27251: LD_VAR 0 12
27255: PUSH
27256: LD_VAR 0 7
27260: ARRAY
27261: PUSH
27262: LD_INT 1
27264: ARRAY
27265: PPUSH
27266: LD_VAR 0 12
27270: PUSH
27271: LD_VAR 0 7
27275: ARRAY
27276: PUSH
27277: LD_INT 2
27279: ARRAY
27280: PPUSH
27281: CALL_OW 546
27285: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27286: LD_VAR 0 8
27290: PUSH
27291: LD_INT 1
27293: ARRAY
27294: PUSH
27295: LD_VAR 0 8
27299: PUSH
27300: LD_INT 2
27302: ARRAY
27303: PUSH
27304: LD_VAR 0 13
27308: PUSH
27309: LD_INT 2
27311: PLUS
27312: GREATER
27313: OR
27314: PUSH
27315: LD_VAR 0 8
27319: PUSH
27320: LD_INT 2
27322: ARRAY
27323: PUSH
27324: LD_VAR 0 13
27328: PUSH
27329: LD_INT 2
27331: MINUS
27332: LESS
27333: OR
27334: PUSH
27335: LD_VAR 0 8
27339: PUSH
27340: LD_INT 3
27342: ARRAY
27343: PUSH
27344: LD_INT 0
27346: PUSH
27347: LD_INT 8
27349: PUSH
27350: LD_INT 9
27352: PUSH
27353: LD_INT 10
27355: PUSH
27356: LD_INT 11
27358: PUSH
27359: LD_INT 12
27361: PUSH
27362: LD_INT 13
27364: PUSH
27365: LD_INT 16
27367: PUSH
27368: LD_INT 17
27370: PUSH
27371: LD_INT 18
27373: PUSH
27374: LD_INT 19
27376: PUSH
27377: LD_INT 20
27379: PUSH
27380: LD_INT 21
27382: PUSH
27383: EMPTY
27384: LIST
27385: LIST
27386: LIST
27387: LIST
27388: LIST
27389: LIST
27390: LIST
27391: LIST
27392: LIST
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: IN
27398: NOT
27399: OR
27400: PUSH
27401: LD_VAR 0 8
27405: PUSH
27406: LD_INT 5
27408: ARRAY
27409: NOT
27410: OR
27411: PUSH
27412: LD_VAR 0 8
27416: PUSH
27417: LD_INT 6
27419: ARRAY
27420: PUSH
27421: LD_INT 1
27423: PUSH
27424: LD_INT 2
27426: PUSH
27427: LD_INT 7
27429: PUSH
27430: LD_INT 9
27432: PUSH
27433: LD_INT 10
27435: PUSH
27436: LD_INT 11
27438: PUSH
27439: EMPTY
27440: LIST
27441: LIST
27442: LIST
27443: LIST
27444: LIST
27445: LIST
27446: IN
27447: NOT
27448: OR
27449: IFFALSE 27455
// exit ;
27451: POP
27452: POP
27453: GO 27538
// end ;
27455: GO 27126
27457: POP
27458: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27459: LD_VAR 0 9
27463: PPUSH
27464: LD_VAR 0 3
27468: PPUSH
27469: LD_VAR 0 4
27473: PPUSH
27474: LD_INT 20
27476: PPUSH
27477: CALL 19484 0 4
27481: PUSH
27482: LD_INT 4
27484: ARRAY
27485: IFFALSE 27489
// exit ;
27487: GO 27538
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27489: LD_VAR 0 2
27493: PUSH
27494: LD_INT 29
27496: PUSH
27497: LD_INT 30
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: IN
27504: PUSH
27505: LD_VAR 0 3
27509: PPUSH
27510: LD_VAR 0 4
27514: PPUSH
27515: LD_VAR 0 9
27519: PPUSH
27520: CALL_OW 440
27524: NOT
27525: AND
27526: IFFALSE 27530
// exit ;
27528: GO 27538
// result := true ;
27530: LD_ADDR_VAR 0 6
27534: PUSH
27535: LD_INT 1
27537: ST_TO_ADDR
// end ;
27538: LD_VAR 0 6
27542: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
27543: LD_INT 0
27545: PPUSH
27546: PPUSH
27547: PPUSH
27548: PPUSH
27549: PPUSH
27550: PPUSH
27551: PPUSH
27552: PPUSH
27553: PPUSH
27554: PPUSH
27555: PPUSH
27556: PPUSH
27557: PPUSH
27558: PPUSH
27559: PPUSH
27560: PPUSH
27561: PPUSH
27562: PPUSH
27563: PPUSH
27564: PPUSH
27565: PPUSH
27566: PPUSH
27567: PPUSH
27568: PPUSH
27569: PPUSH
27570: PPUSH
27571: PPUSH
27572: PPUSH
27573: PPUSH
27574: PPUSH
27575: PPUSH
27576: PPUSH
27577: PPUSH
27578: PPUSH
27579: PPUSH
27580: PPUSH
27581: PPUSH
27582: PPUSH
27583: PPUSH
27584: PPUSH
27585: PPUSH
27586: PPUSH
27587: PPUSH
27588: PPUSH
27589: PPUSH
27590: PPUSH
27591: PPUSH
27592: PPUSH
27593: PPUSH
27594: PPUSH
27595: PPUSH
27596: PPUSH
27597: PPUSH
27598: PPUSH
27599: PPUSH
27600: PPUSH
27601: PPUSH
27602: PPUSH
// result = [ ] ;
27603: LD_ADDR_VAR 0 7
27607: PUSH
27608: EMPTY
27609: ST_TO_ADDR
// temp_list = [ ] ;
27610: LD_ADDR_VAR 0 9
27614: PUSH
27615: EMPTY
27616: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27617: LD_VAR 0 4
27621: PUSH
27622: LD_INT 0
27624: PUSH
27625: LD_INT 1
27627: PUSH
27628: LD_INT 2
27630: PUSH
27631: LD_INT 3
27633: PUSH
27634: LD_INT 4
27636: PUSH
27637: LD_INT 5
27639: PUSH
27640: EMPTY
27641: LIST
27642: LIST
27643: LIST
27644: LIST
27645: LIST
27646: LIST
27647: IN
27648: NOT
27649: PUSH
27650: LD_VAR 0 1
27654: PUSH
27655: LD_INT 0
27657: PUSH
27658: LD_INT 1
27660: PUSH
27661: EMPTY
27662: LIST
27663: LIST
27664: IN
27665: PUSH
27666: LD_VAR 0 5
27670: PUSH
27671: LD_INT 1
27673: PUSH
27674: LD_INT 2
27676: PUSH
27677: LD_INT 3
27679: PUSH
27680: EMPTY
27681: LIST
27682: LIST
27683: LIST
27684: IN
27685: NOT
27686: AND
27687: OR
27688: IFFALSE 27692
// exit ;
27690: GO 46083
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27692: LD_VAR 0 1
27696: PUSH
27697: LD_INT 6
27699: PUSH
27700: LD_INT 7
27702: PUSH
27703: LD_INT 8
27705: PUSH
27706: LD_INT 13
27708: PUSH
27709: LD_INT 12
27711: PUSH
27712: LD_INT 15
27714: PUSH
27715: LD_INT 11
27717: PUSH
27718: LD_INT 14
27720: PUSH
27721: LD_INT 10
27723: PUSH
27724: EMPTY
27725: LIST
27726: LIST
27727: LIST
27728: LIST
27729: LIST
27730: LIST
27731: LIST
27732: LIST
27733: LIST
27734: IN
27735: IFFALSE 27745
// btype = b_lab ;
27737: LD_ADDR_VAR 0 1
27741: PUSH
27742: LD_INT 6
27744: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27745: LD_VAR 0 6
27749: PUSH
27750: LD_INT 0
27752: PUSH
27753: LD_INT 1
27755: PUSH
27756: LD_INT 2
27758: PUSH
27759: EMPTY
27760: LIST
27761: LIST
27762: LIST
27763: IN
27764: NOT
27765: PUSH
27766: LD_VAR 0 1
27770: PUSH
27771: LD_INT 0
27773: PUSH
27774: LD_INT 1
27776: PUSH
27777: LD_INT 2
27779: PUSH
27780: LD_INT 3
27782: PUSH
27783: LD_INT 6
27785: PUSH
27786: LD_INT 36
27788: PUSH
27789: LD_INT 4
27791: PUSH
27792: LD_INT 5
27794: PUSH
27795: LD_INT 31
27797: PUSH
27798: LD_INT 32
27800: PUSH
27801: LD_INT 33
27803: PUSH
27804: EMPTY
27805: LIST
27806: LIST
27807: LIST
27808: LIST
27809: LIST
27810: LIST
27811: LIST
27812: LIST
27813: LIST
27814: LIST
27815: LIST
27816: IN
27817: NOT
27818: PUSH
27819: LD_VAR 0 6
27823: PUSH
27824: LD_INT 1
27826: EQUAL
27827: AND
27828: OR
27829: PUSH
27830: LD_VAR 0 1
27834: PUSH
27835: LD_INT 2
27837: PUSH
27838: LD_INT 3
27840: PUSH
27841: EMPTY
27842: LIST
27843: LIST
27844: IN
27845: NOT
27846: PUSH
27847: LD_VAR 0 6
27851: PUSH
27852: LD_INT 2
27854: EQUAL
27855: AND
27856: OR
27857: IFFALSE 27867
// mode = 0 ;
27859: LD_ADDR_VAR 0 6
27863: PUSH
27864: LD_INT 0
27866: ST_TO_ADDR
// case mode of 0 :
27867: LD_VAR 0 6
27871: PUSH
27872: LD_INT 0
27874: DOUBLE
27875: EQUAL
27876: IFTRUE 27880
27878: GO 39333
27880: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27881: LD_ADDR_VAR 0 11
27885: PUSH
27886: LD_INT 0
27888: PUSH
27889: LD_INT 0
27891: PUSH
27892: EMPTY
27893: LIST
27894: LIST
27895: PUSH
27896: LD_INT 0
27898: PUSH
27899: LD_INT 1
27901: NEG
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: PUSH
27907: LD_INT 1
27909: PUSH
27910: LD_INT 0
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PUSH
27917: LD_INT 1
27919: PUSH
27920: LD_INT 1
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PUSH
27927: LD_INT 0
27929: PUSH
27930: LD_INT 1
27932: PUSH
27933: EMPTY
27934: LIST
27935: LIST
27936: PUSH
27937: LD_INT 1
27939: NEG
27940: PUSH
27941: LD_INT 0
27943: PUSH
27944: EMPTY
27945: LIST
27946: LIST
27947: PUSH
27948: LD_INT 1
27950: NEG
27951: PUSH
27952: LD_INT 1
27954: NEG
27955: PUSH
27956: EMPTY
27957: LIST
27958: LIST
27959: PUSH
27960: LD_INT 1
27962: NEG
27963: PUSH
27964: LD_INT 2
27966: NEG
27967: PUSH
27968: EMPTY
27969: LIST
27970: LIST
27971: PUSH
27972: LD_INT 0
27974: PUSH
27975: LD_INT 2
27977: NEG
27978: PUSH
27979: EMPTY
27980: LIST
27981: LIST
27982: PUSH
27983: LD_INT 1
27985: PUSH
27986: LD_INT 1
27988: NEG
27989: PUSH
27990: EMPTY
27991: LIST
27992: LIST
27993: PUSH
27994: LD_INT 1
27996: PUSH
27997: LD_INT 2
27999: PUSH
28000: EMPTY
28001: LIST
28002: LIST
28003: PUSH
28004: LD_INT 0
28006: PUSH
28007: LD_INT 2
28009: PUSH
28010: EMPTY
28011: LIST
28012: LIST
28013: PUSH
28014: LD_INT 1
28016: NEG
28017: PUSH
28018: LD_INT 1
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: PUSH
28025: LD_INT 1
28027: PUSH
28028: LD_INT 3
28030: PUSH
28031: EMPTY
28032: LIST
28033: LIST
28034: PUSH
28035: LD_INT 0
28037: PUSH
28038: LD_INT 3
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: PUSH
28045: LD_INT 1
28047: NEG
28048: PUSH
28049: LD_INT 2
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: LIST
28060: LIST
28061: LIST
28062: LIST
28063: LIST
28064: LIST
28065: LIST
28066: LIST
28067: LIST
28068: LIST
28069: LIST
28070: LIST
28071: LIST
28072: LIST
28073: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28074: LD_ADDR_VAR 0 12
28078: PUSH
28079: LD_INT 0
28081: PUSH
28082: LD_INT 0
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: PUSH
28089: LD_INT 0
28091: PUSH
28092: LD_INT 1
28094: NEG
28095: PUSH
28096: EMPTY
28097: LIST
28098: LIST
28099: PUSH
28100: LD_INT 1
28102: PUSH
28103: LD_INT 0
28105: PUSH
28106: EMPTY
28107: LIST
28108: LIST
28109: PUSH
28110: LD_INT 1
28112: PUSH
28113: LD_INT 1
28115: PUSH
28116: EMPTY
28117: LIST
28118: LIST
28119: PUSH
28120: LD_INT 0
28122: PUSH
28123: LD_INT 1
28125: PUSH
28126: EMPTY
28127: LIST
28128: LIST
28129: PUSH
28130: LD_INT 1
28132: NEG
28133: PUSH
28134: LD_INT 0
28136: PUSH
28137: EMPTY
28138: LIST
28139: LIST
28140: PUSH
28141: LD_INT 1
28143: NEG
28144: PUSH
28145: LD_INT 1
28147: NEG
28148: PUSH
28149: EMPTY
28150: LIST
28151: LIST
28152: PUSH
28153: LD_INT 1
28155: PUSH
28156: LD_INT 1
28158: NEG
28159: PUSH
28160: EMPTY
28161: LIST
28162: LIST
28163: PUSH
28164: LD_INT 2
28166: PUSH
28167: LD_INT 0
28169: PUSH
28170: EMPTY
28171: LIST
28172: LIST
28173: PUSH
28174: LD_INT 2
28176: PUSH
28177: LD_INT 1
28179: PUSH
28180: EMPTY
28181: LIST
28182: LIST
28183: PUSH
28184: LD_INT 1
28186: NEG
28187: PUSH
28188: LD_INT 1
28190: PUSH
28191: EMPTY
28192: LIST
28193: LIST
28194: PUSH
28195: LD_INT 2
28197: NEG
28198: PUSH
28199: LD_INT 0
28201: PUSH
28202: EMPTY
28203: LIST
28204: LIST
28205: PUSH
28206: LD_INT 2
28208: NEG
28209: PUSH
28210: LD_INT 1
28212: NEG
28213: PUSH
28214: EMPTY
28215: LIST
28216: LIST
28217: PUSH
28218: LD_INT 2
28220: NEG
28221: PUSH
28222: LD_INT 1
28224: PUSH
28225: EMPTY
28226: LIST
28227: LIST
28228: PUSH
28229: LD_INT 3
28231: NEG
28232: PUSH
28233: LD_INT 0
28235: PUSH
28236: EMPTY
28237: LIST
28238: LIST
28239: PUSH
28240: LD_INT 3
28242: NEG
28243: PUSH
28244: LD_INT 1
28246: NEG
28247: PUSH
28248: EMPTY
28249: LIST
28250: LIST
28251: PUSH
28252: EMPTY
28253: LIST
28254: LIST
28255: LIST
28256: LIST
28257: LIST
28258: LIST
28259: LIST
28260: LIST
28261: LIST
28262: LIST
28263: LIST
28264: LIST
28265: LIST
28266: LIST
28267: LIST
28268: LIST
28269: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28270: LD_ADDR_VAR 0 13
28274: PUSH
28275: LD_INT 0
28277: PUSH
28278: LD_INT 0
28280: PUSH
28281: EMPTY
28282: LIST
28283: LIST
28284: PUSH
28285: LD_INT 0
28287: PUSH
28288: LD_INT 1
28290: NEG
28291: PUSH
28292: EMPTY
28293: LIST
28294: LIST
28295: PUSH
28296: LD_INT 1
28298: PUSH
28299: LD_INT 0
28301: PUSH
28302: EMPTY
28303: LIST
28304: LIST
28305: PUSH
28306: LD_INT 1
28308: PUSH
28309: LD_INT 1
28311: PUSH
28312: EMPTY
28313: LIST
28314: LIST
28315: PUSH
28316: LD_INT 0
28318: PUSH
28319: LD_INT 1
28321: PUSH
28322: EMPTY
28323: LIST
28324: LIST
28325: PUSH
28326: LD_INT 1
28328: NEG
28329: PUSH
28330: LD_INT 0
28332: PUSH
28333: EMPTY
28334: LIST
28335: LIST
28336: PUSH
28337: LD_INT 1
28339: NEG
28340: PUSH
28341: LD_INT 1
28343: NEG
28344: PUSH
28345: EMPTY
28346: LIST
28347: LIST
28348: PUSH
28349: LD_INT 1
28351: NEG
28352: PUSH
28353: LD_INT 2
28355: NEG
28356: PUSH
28357: EMPTY
28358: LIST
28359: LIST
28360: PUSH
28361: LD_INT 2
28363: PUSH
28364: LD_INT 1
28366: PUSH
28367: EMPTY
28368: LIST
28369: LIST
28370: PUSH
28371: LD_INT 2
28373: PUSH
28374: LD_INT 2
28376: PUSH
28377: EMPTY
28378: LIST
28379: LIST
28380: PUSH
28381: LD_INT 1
28383: PUSH
28384: LD_INT 2
28386: PUSH
28387: EMPTY
28388: LIST
28389: LIST
28390: PUSH
28391: LD_INT 2
28393: NEG
28394: PUSH
28395: LD_INT 1
28397: NEG
28398: PUSH
28399: EMPTY
28400: LIST
28401: LIST
28402: PUSH
28403: LD_INT 2
28405: NEG
28406: PUSH
28407: LD_INT 2
28409: NEG
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 2
28417: NEG
28418: PUSH
28419: LD_INT 3
28421: NEG
28422: PUSH
28423: EMPTY
28424: LIST
28425: LIST
28426: PUSH
28427: LD_INT 3
28429: NEG
28430: PUSH
28431: LD_INT 2
28433: NEG
28434: PUSH
28435: EMPTY
28436: LIST
28437: LIST
28438: PUSH
28439: LD_INT 3
28441: NEG
28442: PUSH
28443: LD_INT 3
28445: NEG
28446: PUSH
28447: EMPTY
28448: LIST
28449: LIST
28450: PUSH
28451: EMPTY
28452: LIST
28453: LIST
28454: LIST
28455: LIST
28456: LIST
28457: LIST
28458: LIST
28459: LIST
28460: LIST
28461: LIST
28462: LIST
28463: LIST
28464: LIST
28465: LIST
28466: LIST
28467: LIST
28468: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28469: LD_ADDR_VAR 0 14
28473: PUSH
28474: LD_INT 0
28476: PUSH
28477: LD_INT 0
28479: PUSH
28480: EMPTY
28481: LIST
28482: LIST
28483: PUSH
28484: LD_INT 0
28486: PUSH
28487: LD_INT 1
28489: NEG
28490: PUSH
28491: EMPTY
28492: LIST
28493: LIST
28494: PUSH
28495: LD_INT 1
28497: PUSH
28498: LD_INT 0
28500: PUSH
28501: EMPTY
28502: LIST
28503: LIST
28504: PUSH
28505: LD_INT 1
28507: PUSH
28508: LD_INT 1
28510: PUSH
28511: EMPTY
28512: LIST
28513: LIST
28514: PUSH
28515: LD_INT 0
28517: PUSH
28518: LD_INT 1
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PUSH
28525: LD_INT 1
28527: NEG
28528: PUSH
28529: LD_INT 0
28531: PUSH
28532: EMPTY
28533: LIST
28534: LIST
28535: PUSH
28536: LD_INT 1
28538: NEG
28539: PUSH
28540: LD_INT 1
28542: NEG
28543: PUSH
28544: EMPTY
28545: LIST
28546: LIST
28547: PUSH
28548: LD_INT 1
28550: NEG
28551: PUSH
28552: LD_INT 2
28554: NEG
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: PUSH
28560: LD_INT 0
28562: PUSH
28563: LD_INT 2
28565: NEG
28566: PUSH
28567: EMPTY
28568: LIST
28569: LIST
28570: PUSH
28571: LD_INT 1
28573: PUSH
28574: LD_INT 1
28576: NEG
28577: PUSH
28578: EMPTY
28579: LIST
28580: LIST
28581: PUSH
28582: LD_INT 1
28584: PUSH
28585: LD_INT 2
28587: PUSH
28588: EMPTY
28589: LIST
28590: LIST
28591: PUSH
28592: LD_INT 0
28594: PUSH
28595: LD_INT 2
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: PUSH
28602: LD_INT 1
28604: NEG
28605: PUSH
28606: LD_INT 1
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: PUSH
28613: LD_INT 1
28615: NEG
28616: PUSH
28617: LD_INT 3
28619: NEG
28620: PUSH
28621: EMPTY
28622: LIST
28623: LIST
28624: PUSH
28625: LD_INT 0
28627: PUSH
28628: LD_INT 3
28630: NEG
28631: PUSH
28632: EMPTY
28633: LIST
28634: LIST
28635: PUSH
28636: LD_INT 1
28638: PUSH
28639: LD_INT 2
28641: NEG
28642: PUSH
28643: EMPTY
28644: LIST
28645: LIST
28646: PUSH
28647: EMPTY
28648: LIST
28649: LIST
28650: LIST
28651: LIST
28652: LIST
28653: LIST
28654: LIST
28655: LIST
28656: LIST
28657: LIST
28658: LIST
28659: LIST
28660: LIST
28661: LIST
28662: LIST
28663: LIST
28664: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28665: LD_ADDR_VAR 0 15
28669: PUSH
28670: LD_INT 0
28672: PUSH
28673: LD_INT 0
28675: PUSH
28676: EMPTY
28677: LIST
28678: LIST
28679: PUSH
28680: LD_INT 0
28682: PUSH
28683: LD_INT 1
28685: NEG
28686: PUSH
28687: EMPTY
28688: LIST
28689: LIST
28690: PUSH
28691: LD_INT 1
28693: PUSH
28694: LD_INT 0
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: LD_INT 1
28703: PUSH
28704: LD_INT 1
28706: PUSH
28707: EMPTY
28708: LIST
28709: LIST
28710: PUSH
28711: LD_INT 0
28713: PUSH
28714: LD_INT 1
28716: PUSH
28717: EMPTY
28718: LIST
28719: LIST
28720: PUSH
28721: LD_INT 1
28723: NEG
28724: PUSH
28725: LD_INT 0
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: LD_INT 1
28734: NEG
28735: PUSH
28736: LD_INT 1
28738: NEG
28739: PUSH
28740: EMPTY
28741: LIST
28742: LIST
28743: PUSH
28744: LD_INT 1
28746: PUSH
28747: LD_INT 1
28749: NEG
28750: PUSH
28751: EMPTY
28752: LIST
28753: LIST
28754: PUSH
28755: LD_INT 2
28757: PUSH
28758: LD_INT 0
28760: PUSH
28761: EMPTY
28762: LIST
28763: LIST
28764: PUSH
28765: LD_INT 2
28767: PUSH
28768: LD_INT 1
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: PUSH
28775: LD_INT 1
28777: NEG
28778: PUSH
28779: LD_INT 1
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 2
28788: NEG
28789: PUSH
28790: LD_INT 0
28792: PUSH
28793: EMPTY
28794: LIST
28795: LIST
28796: PUSH
28797: LD_INT 2
28799: NEG
28800: PUSH
28801: LD_INT 1
28803: NEG
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 2
28811: PUSH
28812: LD_INT 1
28814: NEG
28815: PUSH
28816: EMPTY
28817: LIST
28818: LIST
28819: PUSH
28820: LD_INT 3
28822: PUSH
28823: LD_INT 0
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: PUSH
28830: LD_INT 3
28832: PUSH
28833: LD_INT 1
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: EMPTY
28841: LIST
28842: LIST
28843: LIST
28844: LIST
28845: LIST
28846: LIST
28847: LIST
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28858: LD_ADDR_VAR 0 16
28862: PUSH
28863: LD_INT 0
28865: PUSH
28866: LD_INT 0
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PUSH
28873: LD_INT 0
28875: PUSH
28876: LD_INT 1
28878: NEG
28879: PUSH
28880: EMPTY
28881: LIST
28882: LIST
28883: PUSH
28884: LD_INT 1
28886: PUSH
28887: LD_INT 0
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PUSH
28894: LD_INT 1
28896: PUSH
28897: LD_INT 1
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: LD_INT 0
28906: PUSH
28907: LD_INT 1
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: LD_INT 1
28916: NEG
28917: PUSH
28918: LD_INT 0
28920: PUSH
28921: EMPTY
28922: LIST
28923: LIST
28924: PUSH
28925: LD_INT 1
28927: NEG
28928: PUSH
28929: LD_INT 1
28931: NEG
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: LD_INT 1
28939: NEG
28940: PUSH
28941: LD_INT 2
28943: NEG
28944: PUSH
28945: EMPTY
28946: LIST
28947: LIST
28948: PUSH
28949: LD_INT 2
28951: PUSH
28952: LD_INT 1
28954: PUSH
28955: EMPTY
28956: LIST
28957: LIST
28958: PUSH
28959: LD_INT 2
28961: PUSH
28962: LD_INT 2
28964: PUSH
28965: EMPTY
28966: LIST
28967: LIST
28968: PUSH
28969: LD_INT 1
28971: PUSH
28972: LD_INT 2
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: PUSH
28979: LD_INT 2
28981: NEG
28982: PUSH
28983: LD_INT 1
28985: NEG
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: PUSH
28991: LD_INT 2
28993: NEG
28994: PUSH
28995: LD_INT 2
28997: NEG
28998: PUSH
28999: EMPTY
29000: LIST
29001: LIST
29002: PUSH
29003: LD_INT 3
29005: PUSH
29006: LD_INT 2
29008: PUSH
29009: EMPTY
29010: LIST
29011: LIST
29012: PUSH
29013: LD_INT 3
29015: PUSH
29016: LD_INT 3
29018: PUSH
29019: EMPTY
29020: LIST
29021: LIST
29022: PUSH
29023: LD_INT 2
29025: PUSH
29026: LD_INT 3
29028: PUSH
29029: EMPTY
29030: LIST
29031: LIST
29032: PUSH
29033: EMPTY
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: LIST
29050: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29051: LD_ADDR_VAR 0 17
29055: PUSH
29056: LD_INT 0
29058: PUSH
29059: LD_INT 0
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 0
29068: PUSH
29069: LD_INT 1
29071: NEG
29072: PUSH
29073: EMPTY
29074: LIST
29075: LIST
29076: PUSH
29077: LD_INT 1
29079: PUSH
29080: LD_INT 0
29082: PUSH
29083: EMPTY
29084: LIST
29085: LIST
29086: PUSH
29087: LD_INT 1
29089: PUSH
29090: LD_INT 1
29092: PUSH
29093: EMPTY
29094: LIST
29095: LIST
29096: PUSH
29097: LD_INT 0
29099: PUSH
29100: LD_INT 1
29102: PUSH
29103: EMPTY
29104: LIST
29105: LIST
29106: PUSH
29107: LD_INT 1
29109: NEG
29110: PUSH
29111: LD_INT 0
29113: PUSH
29114: EMPTY
29115: LIST
29116: LIST
29117: PUSH
29118: LD_INT 1
29120: NEG
29121: PUSH
29122: LD_INT 1
29124: NEG
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 1
29132: NEG
29133: PUSH
29134: LD_INT 2
29136: NEG
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: PUSH
29142: LD_INT 0
29144: PUSH
29145: LD_INT 2
29147: NEG
29148: PUSH
29149: EMPTY
29150: LIST
29151: LIST
29152: PUSH
29153: LD_INT 1
29155: PUSH
29156: LD_INT 1
29158: NEG
29159: PUSH
29160: EMPTY
29161: LIST
29162: LIST
29163: PUSH
29164: LD_INT 2
29166: PUSH
29167: LD_INT 0
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: LD_INT 2
29176: PUSH
29177: LD_INT 1
29179: PUSH
29180: EMPTY
29181: LIST
29182: LIST
29183: PUSH
29184: LD_INT 2
29186: PUSH
29187: LD_INT 2
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: LD_INT 1
29196: PUSH
29197: LD_INT 2
29199: PUSH
29200: EMPTY
29201: LIST
29202: LIST
29203: PUSH
29204: LD_INT 0
29206: PUSH
29207: LD_INT 2
29209: PUSH
29210: EMPTY
29211: LIST
29212: LIST
29213: PUSH
29214: LD_INT 1
29216: NEG
29217: PUSH
29218: LD_INT 1
29220: PUSH
29221: EMPTY
29222: LIST
29223: LIST
29224: PUSH
29225: LD_INT 2
29227: NEG
29228: PUSH
29229: LD_INT 0
29231: PUSH
29232: EMPTY
29233: LIST
29234: LIST
29235: PUSH
29236: LD_INT 2
29238: NEG
29239: PUSH
29240: LD_INT 1
29242: NEG
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: LD_INT 2
29250: NEG
29251: PUSH
29252: LD_INT 2
29254: NEG
29255: PUSH
29256: EMPTY
29257: LIST
29258: LIST
29259: PUSH
29260: EMPTY
29261: LIST
29262: LIST
29263: LIST
29264: LIST
29265: LIST
29266: LIST
29267: LIST
29268: LIST
29269: LIST
29270: LIST
29271: LIST
29272: LIST
29273: LIST
29274: LIST
29275: LIST
29276: LIST
29277: LIST
29278: LIST
29279: LIST
29280: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29281: LD_ADDR_VAR 0 18
29285: PUSH
29286: LD_INT 0
29288: PUSH
29289: LD_INT 0
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PUSH
29296: LD_INT 0
29298: PUSH
29299: LD_INT 1
29301: NEG
29302: PUSH
29303: EMPTY
29304: LIST
29305: LIST
29306: PUSH
29307: LD_INT 1
29309: PUSH
29310: LD_INT 0
29312: PUSH
29313: EMPTY
29314: LIST
29315: LIST
29316: PUSH
29317: LD_INT 1
29319: PUSH
29320: LD_INT 1
29322: PUSH
29323: EMPTY
29324: LIST
29325: LIST
29326: PUSH
29327: LD_INT 0
29329: PUSH
29330: LD_INT 1
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: PUSH
29337: LD_INT 1
29339: NEG
29340: PUSH
29341: LD_INT 0
29343: PUSH
29344: EMPTY
29345: LIST
29346: LIST
29347: PUSH
29348: LD_INT 1
29350: NEG
29351: PUSH
29352: LD_INT 1
29354: NEG
29355: PUSH
29356: EMPTY
29357: LIST
29358: LIST
29359: PUSH
29360: LD_INT 1
29362: NEG
29363: PUSH
29364: LD_INT 2
29366: NEG
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 0
29374: PUSH
29375: LD_INT 2
29377: NEG
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: LD_INT 1
29385: PUSH
29386: LD_INT 1
29388: NEG
29389: PUSH
29390: EMPTY
29391: LIST
29392: LIST
29393: PUSH
29394: LD_INT 2
29396: PUSH
29397: LD_INT 0
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PUSH
29404: LD_INT 2
29406: PUSH
29407: LD_INT 1
29409: PUSH
29410: EMPTY
29411: LIST
29412: LIST
29413: PUSH
29414: LD_INT 2
29416: PUSH
29417: LD_INT 2
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: PUSH
29424: LD_INT 1
29426: PUSH
29427: LD_INT 2
29429: PUSH
29430: EMPTY
29431: LIST
29432: LIST
29433: PUSH
29434: LD_INT 0
29436: PUSH
29437: LD_INT 2
29439: PUSH
29440: EMPTY
29441: LIST
29442: LIST
29443: PUSH
29444: LD_INT 1
29446: NEG
29447: PUSH
29448: LD_INT 1
29450: PUSH
29451: EMPTY
29452: LIST
29453: LIST
29454: PUSH
29455: LD_INT 2
29457: NEG
29458: PUSH
29459: LD_INT 0
29461: PUSH
29462: EMPTY
29463: LIST
29464: LIST
29465: PUSH
29466: LD_INT 2
29468: NEG
29469: PUSH
29470: LD_INT 1
29472: NEG
29473: PUSH
29474: EMPTY
29475: LIST
29476: LIST
29477: PUSH
29478: LD_INT 2
29480: NEG
29481: PUSH
29482: LD_INT 2
29484: NEG
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: PUSH
29490: EMPTY
29491: LIST
29492: LIST
29493: LIST
29494: LIST
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: LIST
29501: LIST
29502: LIST
29503: LIST
29504: LIST
29505: LIST
29506: LIST
29507: LIST
29508: LIST
29509: LIST
29510: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29511: LD_ADDR_VAR 0 19
29515: PUSH
29516: LD_INT 0
29518: PUSH
29519: LD_INT 0
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: PUSH
29526: LD_INT 0
29528: PUSH
29529: LD_INT 1
29531: NEG
29532: PUSH
29533: EMPTY
29534: LIST
29535: LIST
29536: PUSH
29537: LD_INT 1
29539: PUSH
29540: LD_INT 0
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PUSH
29547: LD_INT 1
29549: PUSH
29550: LD_INT 1
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 0
29559: PUSH
29560: LD_INT 1
29562: PUSH
29563: EMPTY
29564: LIST
29565: LIST
29566: PUSH
29567: LD_INT 1
29569: NEG
29570: PUSH
29571: LD_INT 0
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PUSH
29578: LD_INT 1
29580: NEG
29581: PUSH
29582: LD_INT 1
29584: NEG
29585: PUSH
29586: EMPTY
29587: LIST
29588: LIST
29589: PUSH
29590: LD_INT 1
29592: NEG
29593: PUSH
29594: LD_INT 2
29596: NEG
29597: PUSH
29598: EMPTY
29599: LIST
29600: LIST
29601: PUSH
29602: LD_INT 0
29604: PUSH
29605: LD_INT 2
29607: NEG
29608: PUSH
29609: EMPTY
29610: LIST
29611: LIST
29612: PUSH
29613: LD_INT 1
29615: PUSH
29616: LD_INT 1
29618: NEG
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: LD_INT 2
29626: PUSH
29627: LD_INT 0
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 2
29636: PUSH
29637: LD_INT 1
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: LD_INT 2
29646: PUSH
29647: LD_INT 2
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 1
29656: PUSH
29657: LD_INT 2
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: PUSH
29664: LD_INT 0
29666: PUSH
29667: LD_INT 2
29669: PUSH
29670: EMPTY
29671: LIST
29672: LIST
29673: PUSH
29674: LD_INT 1
29676: NEG
29677: PUSH
29678: LD_INT 1
29680: PUSH
29681: EMPTY
29682: LIST
29683: LIST
29684: PUSH
29685: LD_INT 2
29687: NEG
29688: PUSH
29689: LD_INT 0
29691: PUSH
29692: EMPTY
29693: LIST
29694: LIST
29695: PUSH
29696: LD_INT 2
29698: NEG
29699: PUSH
29700: LD_INT 1
29702: NEG
29703: PUSH
29704: EMPTY
29705: LIST
29706: LIST
29707: PUSH
29708: LD_INT 2
29710: NEG
29711: PUSH
29712: LD_INT 2
29714: NEG
29715: PUSH
29716: EMPTY
29717: LIST
29718: LIST
29719: PUSH
29720: EMPTY
29721: LIST
29722: LIST
29723: LIST
29724: LIST
29725: LIST
29726: LIST
29727: LIST
29728: LIST
29729: LIST
29730: LIST
29731: LIST
29732: LIST
29733: LIST
29734: LIST
29735: LIST
29736: LIST
29737: LIST
29738: LIST
29739: LIST
29740: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29741: LD_ADDR_VAR 0 20
29745: PUSH
29746: LD_INT 0
29748: PUSH
29749: LD_INT 0
29751: PUSH
29752: EMPTY
29753: LIST
29754: LIST
29755: PUSH
29756: LD_INT 0
29758: PUSH
29759: LD_INT 1
29761: NEG
29762: PUSH
29763: EMPTY
29764: LIST
29765: LIST
29766: PUSH
29767: LD_INT 1
29769: PUSH
29770: LD_INT 0
29772: PUSH
29773: EMPTY
29774: LIST
29775: LIST
29776: PUSH
29777: LD_INT 1
29779: PUSH
29780: LD_INT 1
29782: PUSH
29783: EMPTY
29784: LIST
29785: LIST
29786: PUSH
29787: LD_INT 0
29789: PUSH
29790: LD_INT 1
29792: PUSH
29793: EMPTY
29794: LIST
29795: LIST
29796: PUSH
29797: LD_INT 1
29799: NEG
29800: PUSH
29801: LD_INT 0
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 1
29810: NEG
29811: PUSH
29812: LD_INT 1
29814: NEG
29815: PUSH
29816: EMPTY
29817: LIST
29818: LIST
29819: PUSH
29820: LD_INT 1
29822: NEG
29823: PUSH
29824: LD_INT 2
29826: NEG
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: PUSH
29832: LD_INT 0
29834: PUSH
29835: LD_INT 2
29837: NEG
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: LD_INT 1
29845: PUSH
29846: LD_INT 1
29848: NEG
29849: PUSH
29850: EMPTY
29851: LIST
29852: LIST
29853: PUSH
29854: LD_INT 2
29856: PUSH
29857: LD_INT 0
29859: PUSH
29860: EMPTY
29861: LIST
29862: LIST
29863: PUSH
29864: LD_INT 2
29866: PUSH
29867: LD_INT 1
29869: PUSH
29870: EMPTY
29871: LIST
29872: LIST
29873: PUSH
29874: LD_INT 2
29876: PUSH
29877: LD_INT 2
29879: PUSH
29880: EMPTY
29881: LIST
29882: LIST
29883: PUSH
29884: LD_INT 1
29886: PUSH
29887: LD_INT 2
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 0
29896: PUSH
29897: LD_INT 2
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 1
29906: NEG
29907: PUSH
29908: LD_INT 1
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: PUSH
29915: LD_INT 2
29917: NEG
29918: PUSH
29919: LD_INT 0
29921: PUSH
29922: EMPTY
29923: LIST
29924: LIST
29925: PUSH
29926: LD_INT 2
29928: NEG
29929: PUSH
29930: LD_INT 1
29932: NEG
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: PUSH
29938: LD_INT 2
29940: NEG
29941: PUSH
29942: LD_INT 2
29944: NEG
29945: PUSH
29946: EMPTY
29947: LIST
29948: LIST
29949: PUSH
29950: EMPTY
29951: LIST
29952: LIST
29953: LIST
29954: LIST
29955: LIST
29956: LIST
29957: LIST
29958: LIST
29959: LIST
29960: LIST
29961: LIST
29962: LIST
29963: LIST
29964: LIST
29965: LIST
29966: LIST
29967: LIST
29968: LIST
29969: LIST
29970: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29971: LD_ADDR_VAR 0 21
29975: PUSH
29976: LD_INT 0
29978: PUSH
29979: LD_INT 0
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: LD_INT 0
29988: PUSH
29989: LD_INT 1
29991: NEG
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 1
29999: PUSH
30000: LD_INT 0
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: LD_INT 1
30009: PUSH
30010: LD_INT 1
30012: PUSH
30013: EMPTY
30014: LIST
30015: LIST
30016: PUSH
30017: LD_INT 0
30019: PUSH
30020: LD_INT 1
30022: PUSH
30023: EMPTY
30024: LIST
30025: LIST
30026: PUSH
30027: LD_INT 1
30029: NEG
30030: PUSH
30031: LD_INT 0
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: PUSH
30038: LD_INT 1
30040: NEG
30041: PUSH
30042: LD_INT 1
30044: NEG
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: LD_INT 1
30052: NEG
30053: PUSH
30054: LD_INT 2
30056: NEG
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 0
30064: PUSH
30065: LD_INT 2
30067: NEG
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 1
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: EMPTY
30081: LIST
30082: LIST
30083: PUSH
30084: LD_INT 2
30086: PUSH
30087: LD_INT 0
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: PUSH
30094: LD_INT 2
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 2
30106: PUSH
30107: LD_INT 2
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: LD_INT 1
30116: PUSH
30117: LD_INT 2
30119: PUSH
30120: EMPTY
30121: LIST
30122: LIST
30123: PUSH
30124: LD_INT 0
30126: PUSH
30127: LD_INT 2
30129: PUSH
30130: EMPTY
30131: LIST
30132: LIST
30133: PUSH
30134: LD_INT 1
30136: NEG
30137: PUSH
30138: LD_INT 1
30140: PUSH
30141: EMPTY
30142: LIST
30143: LIST
30144: PUSH
30145: LD_INT 2
30147: NEG
30148: PUSH
30149: LD_INT 0
30151: PUSH
30152: EMPTY
30153: LIST
30154: LIST
30155: PUSH
30156: LD_INT 2
30158: NEG
30159: PUSH
30160: LD_INT 1
30162: NEG
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: PUSH
30168: LD_INT 2
30170: NEG
30171: PUSH
30172: LD_INT 2
30174: NEG
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: EMPTY
30181: LIST
30182: LIST
30183: LIST
30184: LIST
30185: LIST
30186: LIST
30187: LIST
30188: LIST
30189: LIST
30190: LIST
30191: LIST
30192: LIST
30193: LIST
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30201: LD_ADDR_VAR 0 22
30205: PUSH
30206: LD_INT 0
30208: PUSH
30209: LD_INT 0
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: LD_INT 0
30218: PUSH
30219: LD_INT 1
30221: NEG
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: PUSH
30227: LD_INT 1
30229: PUSH
30230: LD_INT 0
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: PUSH
30237: LD_INT 1
30239: PUSH
30240: LD_INT 1
30242: PUSH
30243: EMPTY
30244: LIST
30245: LIST
30246: PUSH
30247: LD_INT 0
30249: PUSH
30250: LD_INT 1
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: PUSH
30257: LD_INT 1
30259: NEG
30260: PUSH
30261: LD_INT 0
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 1
30270: NEG
30271: PUSH
30272: LD_INT 1
30274: NEG
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 1
30282: NEG
30283: PUSH
30284: LD_INT 2
30286: NEG
30287: PUSH
30288: EMPTY
30289: LIST
30290: LIST
30291: PUSH
30292: LD_INT 0
30294: PUSH
30295: LD_INT 2
30297: NEG
30298: PUSH
30299: EMPTY
30300: LIST
30301: LIST
30302: PUSH
30303: LD_INT 1
30305: PUSH
30306: LD_INT 1
30308: NEG
30309: PUSH
30310: EMPTY
30311: LIST
30312: LIST
30313: PUSH
30314: LD_INT 2
30316: PUSH
30317: LD_INT 0
30319: PUSH
30320: EMPTY
30321: LIST
30322: LIST
30323: PUSH
30324: LD_INT 2
30326: PUSH
30327: LD_INT 1
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: PUSH
30334: LD_INT 2
30336: PUSH
30337: LD_INT 2
30339: PUSH
30340: EMPTY
30341: LIST
30342: LIST
30343: PUSH
30344: LD_INT 1
30346: PUSH
30347: LD_INT 2
30349: PUSH
30350: EMPTY
30351: LIST
30352: LIST
30353: PUSH
30354: LD_INT 0
30356: PUSH
30357: LD_INT 2
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: LD_INT 1
30366: NEG
30367: PUSH
30368: LD_INT 1
30370: PUSH
30371: EMPTY
30372: LIST
30373: LIST
30374: PUSH
30375: LD_INT 2
30377: NEG
30378: PUSH
30379: LD_INT 0
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: LD_INT 2
30388: NEG
30389: PUSH
30390: LD_INT 1
30392: NEG
30393: PUSH
30394: EMPTY
30395: LIST
30396: LIST
30397: PUSH
30398: LD_INT 2
30400: NEG
30401: PUSH
30402: LD_INT 2
30404: NEG
30405: PUSH
30406: EMPTY
30407: LIST
30408: LIST
30409: PUSH
30410: EMPTY
30411: LIST
30412: LIST
30413: LIST
30414: LIST
30415: LIST
30416: LIST
30417: LIST
30418: LIST
30419: LIST
30420: LIST
30421: LIST
30422: LIST
30423: LIST
30424: LIST
30425: LIST
30426: LIST
30427: LIST
30428: LIST
30429: LIST
30430: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30431: LD_ADDR_VAR 0 23
30435: PUSH
30436: LD_INT 0
30438: PUSH
30439: LD_INT 0
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: PUSH
30446: LD_INT 0
30448: PUSH
30449: LD_INT 1
30451: NEG
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: PUSH
30457: LD_INT 1
30459: PUSH
30460: LD_INT 0
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: PUSH
30467: LD_INT 1
30469: PUSH
30470: LD_INT 1
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: LD_INT 0
30479: PUSH
30480: LD_INT 1
30482: PUSH
30483: EMPTY
30484: LIST
30485: LIST
30486: PUSH
30487: LD_INT 1
30489: NEG
30490: PUSH
30491: LD_INT 0
30493: PUSH
30494: EMPTY
30495: LIST
30496: LIST
30497: PUSH
30498: LD_INT 1
30500: NEG
30501: PUSH
30502: LD_INT 1
30504: NEG
30505: PUSH
30506: EMPTY
30507: LIST
30508: LIST
30509: PUSH
30510: LD_INT 1
30512: NEG
30513: PUSH
30514: LD_INT 2
30516: NEG
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: PUSH
30522: LD_INT 0
30524: PUSH
30525: LD_INT 2
30527: NEG
30528: PUSH
30529: EMPTY
30530: LIST
30531: LIST
30532: PUSH
30533: LD_INT 1
30535: PUSH
30536: LD_INT 1
30538: NEG
30539: PUSH
30540: EMPTY
30541: LIST
30542: LIST
30543: PUSH
30544: LD_INT 2
30546: PUSH
30547: LD_INT 0
30549: PUSH
30550: EMPTY
30551: LIST
30552: LIST
30553: PUSH
30554: LD_INT 2
30556: PUSH
30557: LD_INT 1
30559: PUSH
30560: EMPTY
30561: LIST
30562: LIST
30563: PUSH
30564: LD_INT 2
30566: PUSH
30567: LD_INT 2
30569: PUSH
30570: EMPTY
30571: LIST
30572: LIST
30573: PUSH
30574: LD_INT 1
30576: PUSH
30577: LD_INT 2
30579: PUSH
30580: EMPTY
30581: LIST
30582: LIST
30583: PUSH
30584: LD_INT 0
30586: PUSH
30587: LD_INT 2
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: LD_INT 1
30600: PUSH
30601: EMPTY
30602: LIST
30603: LIST
30604: PUSH
30605: LD_INT 2
30607: NEG
30608: PUSH
30609: LD_INT 0
30611: PUSH
30612: EMPTY
30613: LIST
30614: LIST
30615: PUSH
30616: LD_INT 2
30618: NEG
30619: PUSH
30620: LD_INT 1
30622: NEG
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: LD_INT 2
30630: NEG
30631: PUSH
30632: LD_INT 2
30634: NEG
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: PUSH
30640: LD_INT 2
30642: NEG
30643: PUSH
30644: LD_INT 3
30646: NEG
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 1
30654: NEG
30655: PUSH
30656: LD_INT 3
30658: NEG
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: LD_INT 1
30666: PUSH
30667: LD_INT 2
30669: NEG
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: PUSH
30675: LD_INT 2
30677: PUSH
30678: LD_INT 1
30680: NEG
30681: PUSH
30682: EMPTY
30683: LIST
30684: LIST
30685: PUSH
30686: EMPTY
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: LIST
30694: LIST
30695: LIST
30696: LIST
30697: LIST
30698: LIST
30699: LIST
30700: LIST
30701: LIST
30702: LIST
30703: LIST
30704: LIST
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: LIST
30710: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30711: LD_ADDR_VAR 0 24
30715: PUSH
30716: LD_INT 0
30718: PUSH
30719: LD_INT 0
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: PUSH
30726: LD_INT 0
30728: PUSH
30729: LD_INT 1
30731: NEG
30732: PUSH
30733: EMPTY
30734: LIST
30735: LIST
30736: PUSH
30737: LD_INT 1
30739: PUSH
30740: LD_INT 0
30742: PUSH
30743: EMPTY
30744: LIST
30745: LIST
30746: PUSH
30747: LD_INT 1
30749: PUSH
30750: LD_INT 1
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: PUSH
30757: LD_INT 0
30759: PUSH
30760: LD_INT 1
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: LD_INT 1
30769: NEG
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: LD_INT 1
30780: NEG
30781: PUSH
30782: LD_INT 1
30784: NEG
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 1
30792: NEG
30793: PUSH
30794: LD_INT 2
30796: NEG
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 0
30804: PUSH
30805: LD_INT 2
30807: NEG
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PUSH
30813: LD_INT 1
30815: PUSH
30816: LD_INT 1
30818: NEG
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 2
30826: PUSH
30827: LD_INT 0
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: PUSH
30834: LD_INT 2
30836: PUSH
30837: LD_INT 1
30839: PUSH
30840: EMPTY
30841: LIST
30842: LIST
30843: PUSH
30844: LD_INT 2
30846: PUSH
30847: LD_INT 2
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: PUSH
30854: LD_INT 1
30856: PUSH
30857: LD_INT 2
30859: PUSH
30860: EMPTY
30861: LIST
30862: LIST
30863: PUSH
30864: LD_INT 0
30866: PUSH
30867: LD_INT 2
30869: PUSH
30870: EMPTY
30871: LIST
30872: LIST
30873: PUSH
30874: LD_INT 1
30876: NEG
30877: PUSH
30878: LD_INT 1
30880: PUSH
30881: EMPTY
30882: LIST
30883: LIST
30884: PUSH
30885: LD_INT 2
30887: NEG
30888: PUSH
30889: LD_INT 0
30891: PUSH
30892: EMPTY
30893: LIST
30894: LIST
30895: PUSH
30896: LD_INT 2
30898: NEG
30899: PUSH
30900: LD_INT 1
30902: NEG
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 2
30910: NEG
30911: PUSH
30912: LD_INT 2
30914: NEG
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: PUSH
30920: LD_INT 1
30922: PUSH
30923: LD_INT 2
30925: NEG
30926: PUSH
30927: EMPTY
30928: LIST
30929: LIST
30930: PUSH
30931: LD_INT 2
30933: PUSH
30934: LD_INT 1
30936: NEG
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 3
30944: PUSH
30945: LD_INT 1
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: PUSH
30952: LD_INT 3
30954: PUSH
30955: LD_INT 2
30957: PUSH
30958: EMPTY
30959: LIST
30960: LIST
30961: PUSH
30962: EMPTY
30963: LIST
30964: LIST
30965: LIST
30966: LIST
30967: LIST
30968: LIST
30969: LIST
30970: LIST
30971: LIST
30972: LIST
30973: LIST
30974: LIST
30975: LIST
30976: LIST
30977: LIST
30978: LIST
30979: LIST
30980: LIST
30981: LIST
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30987: LD_ADDR_VAR 0 25
30991: PUSH
30992: LD_INT 0
30994: PUSH
30995: LD_INT 0
30997: PUSH
30998: EMPTY
30999: LIST
31000: LIST
31001: PUSH
31002: LD_INT 0
31004: PUSH
31005: LD_INT 1
31007: NEG
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: LD_INT 1
31015: PUSH
31016: LD_INT 0
31018: PUSH
31019: EMPTY
31020: LIST
31021: LIST
31022: PUSH
31023: LD_INT 1
31025: PUSH
31026: LD_INT 1
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 0
31035: PUSH
31036: LD_INT 1
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PUSH
31043: LD_INT 1
31045: NEG
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: PUSH
31054: LD_INT 1
31056: NEG
31057: PUSH
31058: LD_INT 1
31060: NEG
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 1
31068: NEG
31069: PUSH
31070: LD_INT 2
31072: NEG
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 0
31080: PUSH
31081: LD_INT 2
31083: NEG
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: PUSH
31089: LD_INT 1
31091: PUSH
31092: LD_INT 1
31094: NEG
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: LD_INT 2
31102: PUSH
31103: LD_INT 0
31105: PUSH
31106: EMPTY
31107: LIST
31108: LIST
31109: PUSH
31110: LD_INT 2
31112: PUSH
31113: LD_INT 1
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PUSH
31120: LD_INT 2
31122: PUSH
31123: LD_INT 2
31125: PUSH
31126: EMPTY
31127: LIST
31128: LIST
31129: PUSH
31130: LD_INT 1
31132: PUSH
31133: LD_INT 2
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 0
31142: PUSH
31143: LD_INT 2
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: LD_INT 1
31152: NEG
31153: PUSH
31154: LD_INT 1
31156: PUSH
31157: EMPTY
31158: LIST
31159: LIST
31160: PUSH
31161: LD_INT 2
31163: NEG
31164: PUSH
31165: LD_INT 0
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 2
31174: NEG
31175: PUSH
31176: LD_INT 1
31178: NEG
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 2
31186: NEG
31187: PUSH
31188: LD_INT 2
31190: NEG
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PUSH
31196: LD_INT 3
31198: PUSH
31199: LD_INT 1
31201: PUSH
31202: EMPTY
31203: LIST
31204: LIST
31205: PUSH
31206: LD_INT 3
31208: PUSH
31209: LD_INT 2
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: PUSH
31216: LD_INT 2
31218: PUSH
31219: LD_INT 3
31221: PUSH
31222: EMPTY
31223: LIST
31224: LIST
31225: PUSH
31226: LD_INT 1
31228: PUSH
31229: LD_INT 3
31231: PUSH
31232: EMPTY
31233: LIST
31234: LIST
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: LIST
31240: LIST
31241: LIST
31242: LIST
31243: LIST
31244: LIST
31245: LIST
31246: LIST
31247: LIST
31248: LIST
31249: LIST
31250: LIST
31251: LIST
31252: LIST
31253: LIST
31254: LIST
31255: LIST
31256: LIST
31257: LIST
31258: LIST
31259: LIST
31260: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31261: LD_ADDR_VAR 0 26
31265: PUSH
31266: LD_INT 0
31268: PUSH
31269: LD_INT 0
31271: PUSH
31272: EMPTY
31273: LIST
31274: LIST
31275: PUSH
31276: LD_INT 0
31278: PUSH
31279: LD_INT 1
31281: NEG
31282: PUSH
31283: EMPTY
31284: LIST
31285: LIST
31286: PUSH
31287: LD_INT 1
31289: PUSH
31290: LD_INT 0
31292: PUSH
31293: EMPTY
31294: LIST
31295: LIST
31296: PUSH
31297: LD_INT 1
31299: PUSH
31300: LD_INT 1
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: PUSH
31307: LD_INT 0
31309: PUSH
31310: LD_INT 1
31312: PUSH
31313: EMPTY
31314: LIST
31315: LIST
31316: PUSH
31317: LD_INT 1
31319: NEG
31320: PUSH
31321: LD_INT 0
31323: PUSH
31324: EMPTY
31325: LIST
31326: LIST
31327: PUSH
31328: LD_INT 1
31330: NEG
31331: PUSH
31332: LD_INT 1
31334: NEG
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 1
31342: NEG
31343: PUSH
31344: LD_INT 2
31346: NEG
31347: PUSH
31348: EMPTY
31349: LIST
31350: LIST
31351: PUSH
31352: LD_INT 0
31354: PUSH
31355: LD_INT 2
31357: NEG
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 1
31365: PUSH
31366: LD_INT 1
31368: NEG
31369: PUSH
31370: EMPTY
31371: LIST
31372: LIST
31373: PUSH
31374: LD_INT 2
31376: PUSH
31377: LD_INT 0
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 2
31386: PUSH
31387: LD_INT 1
31389: PUSH
31390: EMPTY
31391: LIST
31392: LIST
31393: PUSH
31394: LD_INT 2
31396: PUSH
31397: LD_INT 2
31399: PUSH
31400: EMPTY
31401: LIST
31402: LIST
31403: PUSH
31404: LD_INT 1
31406: PUSH
31407: LD_INT 2
31409: PUSH
31410: EMPTY
31411: LIST
31412: LIST
31413: PUSH
31414: LD_INT 0
31416: PUSH
31417: LD_INT 2
31419: PUSH
31420: EMPTY
31421: LIST
31422: LIST
31423: PUSH
31424: LD_INT 1
31426: NEG
31427: PUSH
31428: LD_INT 1
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: LD_INT 2
31437: NEG
31438: PUSH
31439: LD_INT 0
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: PUSH
31446: LD_INT 2
31448: NEG
31449: PUSH
31450: LD_INT 1
31452: NEG
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: PUSH
31458: LD_INT 2
31460: NEG
31461: PUSH
31462: LD_INT 2
31464: NEG
31465: PUSH
31466: EMPTY
31467: LIST
31468: LIST
31469: PUSH
31470: LD_INT 2
31472: PUSH
31473: LD_INT 3
31475: PUSH
31476: EMPTY
31477: LIST
31478: LIST
31479: PUSH
31480: LD_INT 1
31482: PUSH
31483: LD_INT 3
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: PUSH
31490: LD_INT 1
31492: NEG
31493: PUSH
31494: LD_INT 2
31496: PUSH
31497: EMPTY
31498: LIST
31499: LIST
31500: PUSH
31501: LD_INT 2
31503: NEG
31504: PUSH
31505: LD_INT 1
31507: PUSH
31508: EMPTY
31509: LIST
31510: LIST
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: LIST
31516: LIST
31517: LIST
31518: LIST
31519: LIST
31520: LIST
31521: LIST
31522: LIST
31523: LIST
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: LIST
31529: LIST
31530: LIST
31531: LIST
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31537: LD_ADDR_VAR 0 27
31541: PUSH
31542: LD_INT 0
31544: PUSH
31545: LD_INT 0
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: LD_INT 0
31554: PUSH
31555: LD_INT 1
31557: NEG
31558: PUSH
31559: EMPTY
31560: LIST
31561: LIST
31562: PUSH
31563: LD_INT 1
31565: PUSH
31566: LD_INT 0
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 1
31575: PUSH
31576: LD_INT 1
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 0
31585: PUSH
31586: LD_INT 1
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 1
31595: NEG
31596: PUSH
31597: LD_INT 0
31599: PUSH
31600: EMPTY
31601: LIST
31602: LIST
31603: PUSH
31604: LD_INT 1
31606: NEG
31607: PUSH
31608: LD_INT 1
31610: NEG
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: PUSH
31616: LD_INT 1
31618: NEG
31619: PUSH
31620: LD_INT 2
31622: NEG
31623: PUSH
31624: EMPTY
31625: LIST
31626: LIST
31627: PUSH
31628: LD_INT 0
31630: PUSH
31631: LD_INT 2
31633: NEG
31634: PUSH
31635: EMPTY
31636: LIST
31637: LIST
31638: PUSH
31639: LD_INT 1
31641: PUSH
31642: LD_INT 1
31644: NEG
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PUSH
31650: LD_INT 2
31652: PUSH
31653: LD_INT 0
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: LD_INT 2
31662: PUSH
31663: LD_INT 1
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: LD_INT 2
31672: PUSH
31673: LD_INT 2
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 1
31682: PUSH
31683: LD_INT 2
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: LD_INT 2
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 1
31702: NEG
31703: PUSH
31704: LD_INT 1
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 2
31713: NEG
31714: PUSH
31715: LD_INT 0
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: LD_INT 2
31724: NEG
31725: PUSH
31726: LD_INT 1
31728: NEG
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: LD_INT 2
31736: NEG
31737: PUSH
31738: LD_INT 2
31740: NEG
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 1
31748: NEG
31749: PUSH
31750: LD_INT 2
31752: PUSH
31753: EMPTY
31754: LIST
31755: LIST
31756: PUSH
31757: LD_INT 2
31759: NEG
31760: PUSH
31761: LD_INT 1
31763: PUSH
31764: EMPTY
31765: LIST
31766: LIST
31767: PUSH
31768: LD_INT 3
31770: NEG
31771: PUSH
31772: LD_INT 1
31774: NEG
31775: PUSH
31776: EMPTY
31777: LIST
31778: LIST
31779: PUSH
31780: LD_INT 3
31782: NEG
31783: PUSH
31784: LD_INT 2
31786: NEG
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: LIST
31796: LIST
31797: LIST
31798: LIST
31799: LIST
31800: LIST
31801: LIST
31802: LIST
31803: LIST
31804: LIST
31805: LIST
31806: LIST
31807: LIST
31808: LIST
31809: LIST
31810: LIST
31811: LIST
31812: LIST
31813: LIST
31814: LIST
31815: LIST
31816: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31817: LD_ADDR_VAR 0 28
31821: PUSH
31822: LD_INT 0
31824: PUSH
31825: LD_INT 0
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PUSH
31832: LD_INT 0
31834: PUSH
31835: LD_INT 1
31837: NEG
31838: PUSH
31839: EMPTY
31840: LIST
31841: LIST
31842: PUSH
31843: LD_INT 1
31845: PUSH
31846: LD_INT 0
31848: PUSH
31849: EMPTY
31850: LIST
31851: LIST
31852: PUSH
31853: LD_INT 1
31855: PUSH
31856: LD_INT 1
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: PUSH
31863: LD_INT 0
31865: PUSH
31866: LD_INT 1
31868: PUSH
31869: EMPTY
31870: LIST
31871: LIST
31872: PUSH
31873: LD_INT 1
31875: NEG
31876: PUSH
31877: LD_INT 0
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PUSH
31884: LD_INT 1
31886: NEG
31887: PUSH
31888: LD_INT 1
31890: NEG
31891: PUSH
31892: EMPTY
31893: LIST
31894: LIST
31895: PUSH
31896: LD_INT 1
31898: NEG
31899: PUSH
31900: LD_INT 2
31902: NEG
31903: PUSH
31904: EMPTY
31905: LIST
31906: LIST
31907: PUSH
31908: LD_INT 0
31910: PUSH
31911: LD_INT 2
31913: NEG
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: LD_INT 1
31921: PUSH
31922: LD_INT 1
31924: NEG
31925: PUSH
31926: EMPTY
31927: LIST
31928: LIST
31929: PUSH
31930: LD_INT 2
31932: PUSH
31933: LD_INT 0
31935: PUSH
31936: EMPTY
31937: LIST
31938: LIST
31939: PUSH
31940: LD_INT 2
31942: PUSH
31943: LD_INT 1
31945: PUSH
31946: EMPTY
31947: LIST
31948: LIST
31949: PUSH
31950: LD_INT 2
31952: PUSH
31953: LD_INT 2
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PUSH
31960: LD_INT 1
31962: PUSH
31963: LD_INT 2
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: PUSH
31970: LD_INT 0
31972: PUSH
31973: LD_INT 2
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 1
31982: NEG
31983: PUSH
31984: LD_INT 1
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 2
31993: NEG
31994: PUSH
31995: LD_INT 0
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PUSH
32002: LD_INT 2
32004: NEG
32005: PUSH
32006: LD_INT 1
32008: NEG
32009: PUSH
32010: EMPTY
32011: LIST
32012: LIST
32013: PUSH
32014: LD_INT 2
32016: NEG
32017: PUSH
32018: LD_INT 2
32020: NEG
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 2
32028: NEG
32029: PUSH
32030: LD_INT 3
32032: NEG
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 1
32040: NEG
32041: PUSH
32042: LD_INT 3
32044: NEG
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PUSH
32050: LD_INT 3
32052: NEG
32053: PUSH
32054: LD_INT 1
32056: NEG
32057: PUSH
32058: EMPTY
32059: LIST
32060: LIST
32061: PUSH
32062: LD_INT 3
32064: NEG
32065: PUSH
32066: LD_INT 2
32068: NEG
32069: PUSH
32070: EMPTY
32071: LIST
32072: LIST
32073: PUSH
32074: EMPTY
32075: LIST
32076: LIST
32077: LIST
32078: LIST
32079: LIST
32080: LIST
32081: LIST
32082: LIST
32083: LIST
32084: LIST
32085: LIST
32086: LIST
32087: LIST
32088: LIST
32089: LIST
32090: LIST
32091: LIST
32092: LIST
32093: LIST
32094: LIST
32095: LIST
32096: LIST
32097: LIST
32098: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32099: LD_ADDR_VAR 0 29
32103: PUSH
32104: LD_INT 0
32106: PUSH
32107: LD_INT 0
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 0
32116: PUSH
32117: LD_INT 1
32119: NEG
32120: PUSH
32121: EMPTY
32122: LIST
32123: LIST
32124: PUSH
32125: LD_INT 1
32127: PUSH
32128: LD_INT 0
32130: PUSH
32131: EMPTY
32132: LIST
32133: LIST
32134: PUSH
32135: LD_INT 1
32137: PUSH
32138: LD_INT 1
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: PUSH
32145: LD_INT 0
32147: PUSH
32148: LD_INT 1
32150: PUSH
32151: EMPTY
32152: LIST
32153: LIST
32154: PUSH
32155: LD_INT 1
32157: NEG
32158: PUSH
32159: LD_INT 0
32161: PUSH
32162: EMPTY
32163: LIST
32164: LIST
32165: PUSH
32166: LD_INT 1
32168: NEG
32169: PUSH
32170: LD_INT 1
32172: NEG
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: LD_INT 1
32180: NEG
32181: PUSH
32182: LD_INT 2
32184: NEG
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 0
32192: PUSH
32193: LD_INT 2
32195: NEG
32196: PUSH
32197: EMPTY
32198: LIST
32199: LIST
32200: PUSH
32201: LD_INT 1
32203: PUSH
32204: LD_INT 1
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 2
32214: PUSH
32215: LD_INT 0
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 2
32224: PUSH
32225: LD_INT 1
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 1
32234: PUSH
32235: LD_INT 2
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 0
32244: PUSH
32245: LD_INT 2
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 1
32254: NEG
32255: PUSH
32256: LD_INT 1
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: PUSH
32263: LD_INT 2
32265: NEG
32266: PUSH
32267: LD_INT 1
32269: NEG
32270: PUSH
32271: EMPTY
32272: LIST
32273: LIST
32274: PUSH
32275: LD_INT 2
32277: NEG
32278: PUSH
32279: LD_INT 2
32281: NEG
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 2
32289: NEG
32290: PUSH
32291: LD_INT 3
32293: NEG
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: LD_INT 2
32301: PUSH
32302: LD_INT 1
32304: NEG
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 3
32312: PUSH
32313: LD_INT 1
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 1
32322: PUSH
32323: LD_INT 3
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 1
32332: NEG
32333: PUSH
32334: LD_INT 2
32336: PUSH
32337: EMPTY
32338: LIST
32339: LIST
32340: PUSH
32341: LD_INT 3
32343: NEG
32344: PUSH
32345: LD_INT 2
32347: NEG
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: LIST
32357: LIST
32358: LIST
32359: LIST
32360: LIST
32361: LIST
32362: LIST
32363: LIST
32364: LIST
32365: LIST
32366: LIST
32367: LIST
32368: LIST
32369: LIST
32370: LIST
32371: LIST
32372: LIST
32373: LIST
32374: LIST
32375: LIST
32376: LIST
32377: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32378: LD_ADDR_VAR 0 30
32382: PUSH
32383: LD_INT 0
32385: PUSH
32386: LD_INT 0
32388: PUSH
32389: EMPTY
32390: LIST
32391: LIST
32392: PUSH
32393: LD_INT 0
32395: PUSH
32396: LD_INT 1
32398: NEG
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 1
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 1
32416: PUSH
32417: LD_INT 1
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PUSH
32424: LD_INT 0
32426: PUSH
32427: LD_INT 1
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: LD_INT 1
32436: NEG
32437: PUSH
32438: LD_INT 0
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: LD_INT 1
32447: NEG
32448: PUSH
32449: LD_INT 1
32451: NEG
32452: PUSH
32453: EMPTY
32454: LIST
32455: LIST
32456: PUSH
32457: LD_INT 1
32459: NEG
32460: PUSH
32461: LD_INT 2
32463: NEG
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 0
32471: PUSH
32472: LD_INT 2
32474: NEG
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: LD_INT 1
32482: PUSH
32483: LD_INT 1
32485: NEG
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: LD_INT 2
32493: PUSH
32494: LD_INT 0
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 2
32503: PUSH
32504: LD_INT 1
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 2
32513: PUSH
32514: LD_INT 2
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: LD_INT 1
32523: PUSH
32524: LD_INT 2
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 1
32533: NEG
32534: PUSH
32535: LD_INT 1
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 2
32544: NEG
32545: PUSH
32546: LD_INT 0
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 2
32555: NEG
32556: PUSH
32557: LD_INT 1
32559: NEG
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 1
32567: NEG
32568: PUSH
32569: LD_INT 3
32571: NEG
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: PUSH
32577: LD_INT 1
32579: PUSH
32580: LD_INT 2
32582: NEG
32583: PUSH
32584: EMPTY
32585: LIST
32586: LIST
32587: PUSH
32588: LD_INT 3
32590: PUSH
32591: LD_INT 2
32593: PUSH
32594: EMPTY
32595: LIST
32596: LIST
32597: PUSH
32598: LD_INT 2
32600: PUSH
32601: LD_INT 3
32603: PUSH
32604: EMPTY
32605: LIST
32606: LIST
32607: PUSH
32608: LD_INT 2
32610: NEG
32611: PUSH
32612: LD_INT 1
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PUSH
32619: LD_INT 3
32621: NEG
32622: PUSH
32623: LD_INT 1
32625: NEG
32626: PUSH
32627: EMPTY
32628: LIST
32629: LIST
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: LIST
32635: LIST
32636: LIST
32637: LIST
32638: LIST
32639: LIST
32640: LIST
32641: LIST
32642: LIST
32643: LIST
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32656: LD_ADDR_VAR 0 31
32660: PUSH
32661: LD_INT 0
32663: PUSH
32664: LD_INT 0
32666: PUSH
32667: EMPTY
32668: LIST
32669: LIST
32670: PUSH
32671: LD_INT 0
32673: PUSH
32674: LD_INT 1
32676: NEG
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 1
32684: PUSH
32685: LD_INT 0
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 1
32694: PUSH
32695: LD_INT 1
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 0
32704: PUSH
32705: LD_INT 1
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: LD_INT 1
32714: NEG
32715: PUSH
32716: LD_INT 0
32718: PUSH
32719: EMPTY
32720: LIST
32721: LIST
32722: PUSH
32723: LD_INT 1
32725: NEG
32726: PUSH
32727: LD_INT 1
32729: NEG
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 1
32737: NEG
32738: PUSH
32739: LD_INT 2
32741: NEG
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 1
32749: PUSH
32750: LD_INT 1
32752: NEG
32753: PUSH
32754: EMPTY
32755: LIST
32756: LIST
32757: PUSH
32758: LD_INT 2
32760: PUSH
32761: LD_INT 0
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PUSH
32768: LD_INT 2
32770: PUSH
32771: LD_INT 1
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 2
32780: PUSH
32781: LD_INT 2
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 1
32790: PUSH
32791: LD_INT 2
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: LD_INT 0
32800: PUSH
32801: LD_INT 2
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 1
32810: NEG
32811: PUSH
32812: LD_INT 1
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 2
32821: NEG
32822: PUSH
32823: LD_INT 1
32825: NEG
32826: PUSH
32827: EMPTY
32828: LIST
32829: LIST
32830: PUSH
32831: LD_INT 2
32833: NEG
32834: PUSH
32835: LD_INT 2
32837: NEG
32838: PUSH
32839: EMPTY
32840: LIST
32841: LIST
32842: PUSH
32843: LD_INT 2
32845: NEG
32846: PUSH
32847: LD_INT 3
32849: NEG
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: PUSH
32855: LD_INT 2
32857: PUSH
32858: LD_INT 1
32860: NEG
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: PUSH
32866: LD_INT 3
32868: PUSH
32869: LD_INT 1
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 1
32878: PUSH
32879: LD_INT 3
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: PUSH
32886: LD_INT 1
32888: NEG
32889: PUSH
32890: LD_INT 2
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 3
32899: NEG
32900: PUSH
32901: LD_INT 2
32903: NEG
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: EMPTY
32910: LIST
32911: LIST
32912: LIST
32913: LIST
32914: LIST
32915: LIST
32916: LIST
32917: LIST
32918: LIST
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32934: LD_ADDR_VAR 0 32
32938: PUSH
32939: LD_INT 0
32941: PUSH
32942: LD_INT 0
32944: PUSH
32945: EMPTY
32946: LIST
32947: LIST
32948: PUSH
32949: LD_INT 0
32951: PUSH
32952: LD_INT 1
32954: NEG
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PUSH
32960: LD_INT 1
32962: PUSH
32963: LD_INT 0
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 1
32972: PUSH
32973: LD_INT 1
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: LD_INT 0
32982: PUSH
32983: LD_INT 1
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: PUSH
32990: LD_INT 1
32992: NEG
32993: PUSH
32994: LD_INT 0
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: LD_INT 1
33003: NEG
33004: PUSH
33005: LD_INT 1
33007: NEG
33008: PUSH
33009: EMPTY
33010: LIST
33011: LIST
33012: PUSH
33013: LD_INT 1
33015: NEG
33016: PUSH
33017: LD_INT 2
33019: NEG
33020: PUSH
33021: EMPTY
33022: LIST
33023: LIST
33024: PUSH
33025: LD_INT 0
33027: PUSH
33028: LD_INT 2
33030: NEG
33031: PUSH
33032: EMPTY
33033: LIST
33034: LIST
33035: PUSH
33036: LD_INT 1
33038: PUSH
33039: LD_INT 1
33041: NEG
33042: PUSH
33043: EMPTY
33044: LIST
33045: LIST
33046: PUSH
33047: LD_INT 2
33049: PUSH
33050: LD_INT 1
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: LD_INT 2
33059: PUSH
33060: LD_INT 2
33062: PUSH
33063: EMPTY
33064: LIST
33065: LIST
33066: PUSH
33067: LD_INT 1
33069: PUSH
33070: LD_INT 2
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: PUSH
33077: LD_INT 0
33079: PUSH
33080: LD_INT 2
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 1
33089: NEG
33090: PUSH
33091: LD_INT 1
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 2
33100: NEG
33101: PUSH
33102: LD_INT 0
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: PUSH
33109: LD_INT 2
33111: NEG
33112: PUSH
33113: LD_INT 1
33115: NEG
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 1
33123: NEG
33124: PUSH
33125: LD_INT 3
33127: NEG
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: PUSH
33133: LD_INT 1
33135: PUSH
33136: LD_INT 2
33138: NEG
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: LD_INT 3
33146: PUSH
33147: LD_INT 2
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: PUSH
33154: LD_INT 2
33156: PUSH
33157: LD_INT 3
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: PUSH
33164: LD_INT 2
33166: NEG
33167: PUSH
33168: LD_INT 1
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 3
33177: NEG
33178: PUSH
33179: LD_INT 1
33181: NEG
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: LIST
33191: LIST
33192: LIST
33193: LIST
33194: LIST
33195: LIST
33196: LIST
33197: LIST
33198: LIST
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33212: LD_ADDR_VAR 0 33
33216: PUSH
33217: LD_INT 0
33219: PUSH
33220: LD_INT 0
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 0
33229: PUSH
33230: LD_INT 1
33232: NEG
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: LD_INT 1
33240: PUSH
33241: LD_INT 0
33243: PUSH
33244: EMPTY
33245: LIST
33246: LIST
33247: PUSH
33248: LD_INT 1
33250: PUSH
33251: LD_INT 1
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 0
33260: PUSH
33261: LD_INT 1
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: LD_INT 1
33270: NEG
33271: PUSH
33272: LD_INT 0
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 1
33281: NEG
33282: PUSH
33283: LD_INT 1
33285: NEG
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: PUSH
33291: LD_INT 1
33293: NEG
33294: PUSH
33295: LD_INT 2
33297: NEG
33298: PUSH
33299: EMPTY
33300: LIST
33301: LIST
33302: PUSH
33303: LD_INT 1
33305: PUSH
33306: LD_INT 1
33308: NEG
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 2
33316: PUSH
33317: LD_INT 0
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: LD_INT 2
33326: PUSH
33327: LD_INT 1
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 1
33336: PUSH
33337: LD_INT 2
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: PUSH
33344: LD_INT 0
33346: PUSH
33347: LD_INT 2
33349: PUSH
33350: EMPTY
33351: LIST
33352: LIST
33353: PUSH
33354: LD_INT 1
33356: NEG
33357: PUSH
33358: LD_INT 1
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 2
33367: NEG
33368: PUSH
33369: LD_INT 0
33371: PUSH
33372: EMPTY
33373: LIST
33374: LIST
33375: PUSH
33376: LD_INT 2
33378: NEG
33379: PUSH
33380: LD_INT 1
33382: NEG
33383: PUSH
33384: EMPTY
33385: LIST
33386: LIST
33387: PUSH
33388: LD_INT 2
33390: NEG
33391: PUSH
33392: LD_INT 2
33394: NEG
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: LD_INT 2
33402: NEG
33403: PUSH
33404: LD_INT 3
33406: NEG
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: PUSH
33412: LD_INT 2
33414: PUSH
33415: LD_INT 1
33417: NEG
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PUSH
33423: LD_INT 3
33425: PUSH
33426: LD_INT 1
33428: PUSH
33429: EMPTY
33430: LIST
33431: LIST
33432: PUSH
33433: LD_INT 1
33435: PUSH
33436: LD_INT 3
33438: PUSH
33439: EMPTY
33440: LIST
33441: LIST
33442: PUSH
33443: LD_INT 1
33445: NEG
33446: PUSH
33447: LD_INT 2
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 3
33456: NEG
33457: PUSH
33458: LD_INT 2
33460: NEG
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: LIST
33470: LIST
33471: LIST
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: LIST
33486: LIST
33487: LIST
33488: LIST
33489: LIST
33490: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33491: LD_ADDR_VAR 0 34
33495: PUSH
33496: LD_INT 0
33498: PUSH
33499: LD_INT 0
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 0
33508: PUSH
33509: LD_INT 1
33511: NEG
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 1
33519: PUSH
33520: LD_INT 0
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 1
33529: PUSH
33530: LD_INT 1
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 0
33539: PUSH
33540: LD_INT 1
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: NEG
33550: PUSH
33551: LD_INT 0
33553: PUSH
33554: EMPTY
33555: LIST
33556: LIST
33557: PUSH
33558: LD_INT 1
33560: NEG
33561: PUSH
33562: LD_INT 1
33564: NEG
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: PUSH
33570: LD_INT 1
33572: NEG
33573: PUSH
33574: LD_INT 2
33576: NEG
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: LD_INT 0
33584: PUSH
33585: LD_INT 2
33587: NEG
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 1
33595: PUSH
33596: LD_INT 1
33598: NEG
33599: PUSH
33600: EMPTY
33601: LIST
33602: LIST
33603: PUSH
33604: LD_INT 2
33606: PUSH
33607: LD_INT 1
33609: PUSH
33610: EMPTY
33611: LIST
33612: LIST
33613: PUSH
33614: LD_INT 2
33616: PUSH
33617: LD_INT 2
33619: PUSH
33620: EMPTY
33621: LIST
33622: LIST
33623: PUSH
33624: LD_INT 1
33626: PUSH
33627: LD_INT 2
33629: PUSH
33630: EMPTY
33631: LIST
33632: LIST
33633: PUSH
33634: LD_INT 1
33636: NEG
33637: PUSH
33638: LD_INT 1
33640: PUSH
33641: EMPTY
33642: LIST
33643: LIST
33644: PUSH
33645: LD_INT 2
33647: NEG
33648: PUSH
33649: LD_INT 0
33651: PUSH
33652: EMPTY
33653: LIST
33654: LIST
33655: PUSH
33656: LD_INT 2
33658: NEG
33659: PUSH
33660: LD_INT 1
33662: NEG
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 2
33670: NEG
33671: PUSH
33672: LD_INT 2
33674: NEG
33675: PUSH
33676: EMPTY
33677: LIST
33678: LIST
33679: PUSH
33680: LD_INT 1
33682: NEG
33683: PUSH
33684: LD_INT 3
33686: NEG
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: LD_INT 1
33694: PUSH
33695: LD_INT 2
33697: NEG
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 3
33705: PUSH
33706: LD_INT 2
33708: PUSH
33709: EMPTY
33710: LIST
33711: LIST
33712: PUSH
33713: LD_INT 2
33715: PUSH
33716: LD_INT 3
33718: PUSH
33719: EMPTY
33720: LIST
33721: LIST
33722: PUSH
33723: LD_INT 2
33725: NEG
33726: PUSH
33727: LD_INT 1
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 3
33736: NEG
33737: PUSH
33738: LD_INT 1
33740: NEG
33741: PUSH
33742: EMPTY
33743: LIST
33744: LIST
33745: PUSH
33746: EMPTY
33747: LIST
33748: LIST
33749: LIST
33750: LIST
33751: LIST
33752: LIST
33753: LIST
33754: LIST
33755: LIST
33756: LIST
33757: LIST
33758: LIST
33759: LIST
33760: LIST
33761: LIST
33762: LIST
33763: LIST
33764: LIST
33765: LIST
33766: LIST
33767: LIST
33768: LIST
33769: LIST
33770: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33771: LD_ADDR_VAR 0 35
33775: PUSH
33776: LD_INT 0
33778: PUSH
33779: LD_INT 0
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 0
33788: PUSH
33789: LD_INT 1
33791: NEG
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 1
33799: PUSH
33800: LD_INT 0
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: LD_INT 1
33809: PUSH
33810: LD_INT 1
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 0
33819: PUSH
33820: LD_INT 1
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 1
33829: NEG
33830: PUSH
33831: LD_INT 0
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 1
33840: NEG
33841: PUSH
33842: LD_INT 1
33844: NEG
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 2
33852: PUSH
33853: LD_INT 1
33855: PUSH
33856: EMPTY
33857: LIST
33858: LIST
33859: PUSH
33860: LD_INT 2
33862: NEG
33863: PUSH
33864: LD_INT 1
33866: NEG
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: EMPTY
33873: LIST
33874: LIST
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33883: LD_ADDR_VAR 0 36
33887: PUSH
33888: LD_INT 0
33890: PUSH
33891: LD_INT 0
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PUSH
33898: LD_INT 0
33900: PUSH
33901: LD_INT 1
33903: NEG
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: PUSH
33909: LD_INT 1
33911: PUSH
33912: LD_INT 0
33914: PUSH
33915: EMPTY
33916: LIST
33917: LIST
33918: PUSH
33919: LD_INT 1
33921: PUSH
33922: LD_INT 1
33924: PUSH
33925: EMPTY
33926: LIST
33927: LIST
33928: PUSH
33929: LD_INT 0
33931: PUSH
33932: LD_INT 1
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: LD_INT 1
33941: NEG
33942: PUSH
33943: LD_INT 0
33945: PUSH
33946: EMPTY
33947: LIST
33948: LIST
33949: PUSH
33950: LD_INT 1
33952: NEG
33953: PUSH
33954: LD_INT 1
33956: NEG
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 1
33964: NEG
33965: PUSH
33966: LD_INT 2
33968: NEG
33969: PUSH
33970: EMPTY
33971: LIST
33972: LIST
33973: PUSH
33974: LD_INT 1
33976: PUSH
33977: LD_INT 2
33979: PUSH
33980: EMPTY
33981: LIST
33982: LIST
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: LIST
33988: LIST
33989: LIST
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33995: LD_ADDR_VAR 0 37
33999: PUSH
34000: LD_INT 0
34002: PUSH
34003: LD_INT 0
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: PUSH
34010: LD_INT 0
34012: PUSH
34013: LD_INT 1
34015: NEG
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 1
34023: PUSH
34024: LD_INT 0
34026: PUSH
34027: EMPTY
34028: LIST
34029: LIST
34030: PUSH
34031: LD_INT 1
34033: PUSH
34034: LD_INT 1
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 0
34043: PUSH
34044: LD_INT 1
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: PUSH
34051: LD_INT 1
34053: NEG
34054: PUSH
34055: LD_INT 0
34057: PUSH
34058: EMPTY
34059: LIST
34060: LIST
34061: PUSH
34062: LD_INT 1
34064: NEG
34065: PUSH
34066: LD_INT 1
34068: NEG
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 1
34076: PUSH
34077: LD_INT 1
34079: NEG
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 1
34087: NEG
34088: PUSH
34089: LD_INT 1
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: LIST
34100: LIST
34101: LIST
34102: LIST
34103: LIST
34104: LIST
34105: LIST
34106: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34107: LD_ADDR_VAR 0 38
34111: PUSH
34112: LD_INT 0
34114: PUSH
34115: LD_INT 0
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: LD_INT 0
34124: PUSH
34125: LD_INT 1
34127: NEG
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 1
34135: PUSH
34136: LD_INT 0
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: LD_INT 1
34145: PUSH
34146: LD_INT 1
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 0
34155: PUSH
34156: LD_INT 1
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PUSH
34163: LD_INT 1
34165: NEG
34166: PUSH
34167: LD_INT 0
34169: PUSH
34170: EMPTY
34171: LIST
34172: LIST
34173: PUSH
34174: LD_INT 1
34176: NEG
34177: PUSH
34178: LD_INT 1
34180: NEG
34181: PUSH
34182: EMPTY
34183: LIST
34184: LIST
34185: PUSH
34186: LD_INT 2
34188: PUSH
34189: LD_INT 1
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: PUSH
34196: LD_INT 2
34198: NEG
34199: PUSH
34200: LD_INT 1
34202: NEG
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PUSH
34208: EMPTY
34209: LIST
34210: LIST
34211: LIST
34212: LIST
34213: LIST
34214: LIST
34215: LIST
34216: LIST
34217: LIST
34218: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34219: LD_ADDR_VAR 0 39
34223: PUSH
34224: LD_INT 0
34226: PUSH
34227: LD_INT 0
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 0
34236: PUSH
34237: LD_INT 1
34239: NEG
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PUSH
34245: LD_INT 1
34247: PUSH
34248: LD_INT 0
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 1
34257: PUSH
34258: LD_INT 1
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PUSH
34265: LD_INT 0
34267: PUSH
34268: LD_INT 1
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 1
34277: NEG
34278: PUSH
34279: LD_INT 0
34281: PUSH
34282: EMPTY
34283: LIST
34284: LIST
34285: PUSH
34286: LD_INT 1
34288: NEG
34289: PUSH
34290: LD_INT 1
34292: NEG
34293: PUSH
34294: EMPTY
34295: LIST
34296: LIST
34297: PUSH
34298: LD_INT 1
34300: NEG
34301: PUSH
34302: LD_INT 2
34304: NEG
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: PUSH
34310: LD_INT 1
34312: PUSH
34313: LD_INT 2
34315: PUSH
34316: EMPTY
34317: LIST
34318: LIST
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: LIST
34324: LIST
34325: LIST
34326: LIST
34327: LIST
34328: LIST
34329: LIST
34330: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34331: LD_ADDR_VAR 0 40
34335: PUSH
34336: LD_INT 0
34338: PUSH
34339: LD_INT 0
34341: PUSH
34342: EMPTY
34343: LIST
34344: LIST
34345: PUSH
34346: LD_INT 0
34348: PUSH
34349: LD_INT 1
34351: NEG
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 1
34359: PUSH
34360: LD_INT 0
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 1
34369: PUSH
34370: LD_INT 1
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 0
34379: PUSH
34380: LD_INT 1
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: NEG
34390: PUSH
34391: LD_INT 0
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 1
34400: NEG
34401: PUSH
34402: LD_INT 1
34404: NEG
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 1
34412: PUSH
34413: LD_INT 1
34415: NEG
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: NEG
34424: PUSH
34425: LD_INT 1
34427: PUSH
34428: EMPTY
34429: LIST
34430: LIST
34431: PUSH
34432: EMPTY
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34443: LD_ADDR_VAR 0 41
34447: PUSH
34448: LD_INT 0
34450: PUSH
34451: LD_INT 0
34453: PUSH
34454: EMPTY
34455: LIST
34456: LIST
34457: PUSH
34458: LD_INT 0
34460: PUSH
34461: LD_INT 1
34463: NEG
34464: PUSH
34465: EMPTY
34466: LIST
34467: LIST
34468: PUSH
34469: LD_INT 1
34471: PUSH
34472: LD_INT 0
34474: PUSH
34475: EMPTY
34476: LIST
34477: LIST
34478: PUSH
34479: LD_INT 1
34481: PUSH
34482: LD_INT 1
34484: PUSH
34485: EMPTY
34486: LIST
34487: LIST
34488: PUSH
34489: LD_INT 0
34491: PUSH
34492: LD_INT 1
34494: PUSH
34495: EMPTY
34496: LIST
34497: LIST
34498: PUSH
34499: LD_INT 1
34501: NEG
34502: PUSH
34503: LD_INT 0
34505: PUSH
34506: EMPTY
34507: LIST
34508: LIST
34509: PUSH
34510: LD_INT 1
34512: NEG
34513: PUSH
34514: LD_INT 1
34516: NEG
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 1
34524: NEG
34525: PUSH
34526: LD_INT 2
34528: NEG
34529: PUSH
34530: EMPTY
34531: LIST
34532: LIST
34533: PUSH
34534: LD_INT 1
34536: PUSH
34537: LD_INT 1
34539: NEG
34540: PUSH
34541: EMPTY
34542: LIST
34543: LIST
34544: PUSH
34545: LD_INT 2
34547: PUSH
34548: LD_INT 0
34550: PUSH
34551: EMPTY
34552: LIST
34553: LIST
34554: PUSH
34555: LD_INT 2
34557: PUSH
34558: LD_INT 1
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: LD_INT 2
34567: PUSH
34568: LD_INT 2
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: PUSH
34575: LD_INT 1
34577: PUSH
34578: LD_INT 2
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 1
34587: NEG
34588: PUSH
34589: LD_INT 1
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 2
34598: NEG
34599: PUSH
34600: LD_INT 0
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: LD_INT 2
34609: NEG
34610: PUSH
34611: LD_INT 1
34613: NEG
34614: PUSH
34615: EMPTY
34616: LIST
34617: LIST
34618: PUSH
34619: LD_INT 2
34621: NEG
34622: PUSH
34623: LD_INT 2
34625: NEG
34626: PUSH
34627: EMPTY
34628: LIST
34629: LIST
34630: PUSH
34631: LD_INT 2
34633: NEG
34634: PUSH
34635: LD_INT 3
34637: NEG
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 2
34645: PUSH
34646: LD_INT 1
34648: NEG
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 3
34656: PUSH
34657: LD_INT 0
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: PUSH
34664: LD_INT 3
34666: PUSH
34667: LD_INT 1
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PUSH
34674: LD_INT 3
34676: PUSH
34677: LD_INT 2
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PUSH
34684: LD_INT 3
34686: PUSH
34687: LD_INT 3
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 2
34696: PUSH
34697: LD_INT 3
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 2
34706: NEG
34707: PUSH
34708: LD_INT 1
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PUSH
34715: LD_INT 3
34717: NEG
34718: PUSH
34719: LD_INT 0
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PUSH
34726: LD_INT 3
34728: NEG
34729: PUSH
34730: LD_INT 1
34732: NEG
34733: PUSH
34734: EMPTY
34735: LIST
34736: LIST
34737: PUSH
34738: LD_INT 3
34740: NEG
34741: PUSH
34742: LD_INT 2
34744: NEG
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 3
34752: NEG
34753: PUSH
34754: LD_INT 3
34756: NEG
34757: PUSH
34758: EMPTY
34759: LIST
34760: LIST
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: LIST
34766: LIST
34767: LIST
34768: LIST
34769: LIST
34770: LIST
34771: LIST
34772: LIST
34773: LIST
34774: LIST
34775: LIST
34776: LIST
34777: LIST
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: LIST
34783: LIST
34784: LIST
34785: LIST
34786: LIST
34787: LIST
34788: LIST
34789: LIST
34790: LIST
34791: LIST
34792: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34793: LD_ADDR_VAR 0 42
34797: PUSH
34798: LD_INT 0
34800: PUSH
34801: LD_INT 0
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: PUSH
34808: LD_INT 0
34810: PUSH
34811: LD_INT 1
34813: NEG
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PUSH
34819: LD_INT 1
34821: PUSH
34822: LD_INT 0
34824: PUSH
34825: EMPTY
34826: LIST
34827: LIST
34828: PUSH
34829: LD_INT 1
34831: PUSH
34832: LD_INT 1
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 0
34841: PUSH
34842: LD_INT 1
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: PUSH
34849: LD_INT 1
34851: NEG
34852: PUSH
34853: LD_INT 0
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: LD_INT 1
34862: NEG
34863: PUSH
34864: LD_INT 1
34866: NEG
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 1
34874: NEG
34875: PUSH
34876: LD_INT 2
34878: NEG
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: LD_INT 0
34886: PUSH
34887: LD_INT 2
34889: NEG
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 1
34897: PUSH
34898: LD_INT 1
34900: NEG
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 2
34908: PUSH
34909: LD_INT 1
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 2
34918: PUSH
34919: LD_INT 2
34921: PUSH
34922: EMPTY
34923: LIST
34924: LIST
34925: PUSH
34926: LD_INT 1
34928: PUSH
34929: LD_INT 2
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 0
34938: PUSH
34939: LD_INT 2
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: PUSH
34946: LD_INT 1
34948: NEG
34949: PUSH
34950: LD_INT 1
34952: PUSH
34953: EMPTY
34954: LIST
34955: LIST
34956: PUSH
34957: LD_INT 2
34959: NEG
34960: PUSH
34961: LD_INT 1
34963: NEG
34964: PUSH
34965: EMPTY
34966: LIST
34967: LIST
34968: PUSH
34969: LD_INT 2
34971: NEG
34972: PUSH
34973: LD_INT 2
34975: NEG
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: LD_INT 2
34983: NEG
34984: PUSH
34985: LD_INT 3
34987: NEG
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 1
34995: NEG
34996: PUSH
34997: LD_INT 3
34999: NEG
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: LD_INT 0
35007: PUSH
35008: LD_INT 3
35010: NEG
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: LD_INT 1
35018: PUSH
35019: LD_INT 2
35021: NEG
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 3
35029: PUSH
35030: LD_INT 2
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 3
35039: PUSH
35040: LD_INT 3
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: PUSH
35047: LD_INT 2
35049: PUSH
35050: LD_INT 3
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: LD_INT 1
35059: PUSH
35060: LD_INT 3
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: LD_INT 0
35069: PUSH
35070: LD_INT 3
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 1
35079: NEG
35080: PUSH
35081: LD_INT 2
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 3
35090: NEG
35091: PUSH
35092: LD_INT 2
35094: NEG
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 3
35102: NEG
35103: PUSH
35104: LD_INT 3
35106: NEG
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: LIST
35133: LIST
35134: LIST
35135: LIST
35136: LIST
35137: LIST
35138: LIST
35139: LIST
35140: LIST
35141: LIST
35142: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35143: LD_ADDR_VAR 0 43
35147: PUSH
35148: LD_INT 0
35150: PUSH
35151: LD_INT 0
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: LD_INT 0
35160: PUSH
35161: LD_INT 1
35163: NEG
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 1
35171: PUSH
35172: LD_INT 0
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 1
35181: PUSH
35182: LD_INT 1
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 0
35191: PUSH
35192: LD_INT 1
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 1
35201: NEG
35202: PUSH
35203: LD_INT 0
35205: PUSH
35206: EMPTY
35207: LIST
35208: LIST
35209: PUSH
35210: LD_INT 1
35212: NEG
35213: PUSH
35214: LD_INT 1
35216: NEG
35217: PUSH
35218: EMPTY
35219: LIST
35220: LIST
35221: PUSH
35222: LD_INT 1
35224: NEG
35225: PUSH
35226: LD_INT 2
35228: NEG
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 0
35236: PUSH
35237: LD_INT 2
35239: NEG
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: PUSH
35245: LD_INT 1
35247: PUSH
35248: LD_INT 1
35250: NEG
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 2
35258: PUSH
35259: LD_INT 0
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 2
35268: PUSH
35269: LD_INT 1
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: LD_INT 1
35278: PUSH
35279: LD_INT 2
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 0
35288: PUSH
35289: LD_INT 2
35291: PUSH
35292: EMPTY
35293: LIST
35294: LIST
35295: PUSH
35296: LD_INT 1
35298: NEG
35299: PUSH
35300: LD_INT 1
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PUSH
35307: LD_INT 2
35309: NEG
35310: PUSH
35311: LD_INT 0
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: LD_INT 2
35320: NEG
35321: PUSH
35322: LD_INT 1
35324: NEG
35325: PUSH
35326: EMPTY
35327: LIST
35328: LIST
35329: PUSH
35330: LD_INT 1
35332: NEG
35333: PUSH
35334: LD_INT 3
35336: NEG
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: LD_INT 0
35344: PUSH
35345: LD_INT 3
35347: NEG
35348: PUSH
35349: EMPTY
35350: LIST
35351: LIST
35352: PUSH
35353: LD_INT 1
35355: PUSH
35356: LD_INT 2
35358: NEG
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 2
35366: PUSH
35367: LD_INT 1
35369: NEG
35370: PUSH
35371: EMPTY
35372: LIST
35373: LIST
35374: PUSH
35375: LD_INT 3
35377: PUSH
35378: LD_INT 0
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: PUSH
35385: LD_INT 3
35387: PUSH
35388: LD_INT 1
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: PUSH
35395: LD_INT 1
35397: PUSH
35398: LD_INT 3
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: PUSH
35405: LD_INT 0
35407: PUSH
35408: LD_INT 3
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: LD_INT 1
35417: NEG
35418: PUSH
35419: LD_INT 2
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 2
35428: NEG
35429: PUSH
35430: LD_INT 1
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 3
35439: NEG
35440: PUSH
35441: LD_INT 0
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 3
35450: NEG
35451: PUSH
35452: LD_INT 1
35454: NEG
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: LIST
35469: LIST
35470: LIST
35471: LIST
35472: LIST
35473: LIST
35474: LIST
35475: LIST
35476: LIST
35477: LIST
35478: LIST
35479: LIST
35480: LIST
35481: LIST
35482: LIST
35483: LIST
35484: LIST
35485: LIST
35486: LIST
35487: LIST
35488: LIST
35489: LIST
35490: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35491: LD_ADDR_VAR 0 44
35495: PUSH
35496: LD_INT 0
35498: PUSH
35499: LD_INT 0
35501: PUSH
35502: EMPTY
35503: LIST
35504: LIST
35505: PUSH
35506: LD_INT 0
35508: PUSH
35509: LD_INT 1
35511: NEG
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 1
35519: PUSH
35520: LD_INT 0
35522: PUSH
35523: EMPTY
35524: LIST
35525: LIST
35526: PUSH
35527: LD_INT 1
35529: PUSH
35530: LD_INT 1
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 0
35539: PUSH
35540: LD_INT 1
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 1
35549: NEG
35550: PUSH
35551: LD_INT 0
35553: PUSH
35554: EMPTY
35555: LIST
35556: LIST
35557: PUSH
35558: LD_INT 1
35560: NEG
35561: PUSH
35562: LD_INT 1
35564: NEG
35565: PUSH
35566: EMPTY
35567: LIST
35568: LIST
35569: PUSH
35570: LD_INT 1
35572: NEG
35573: PUSH
35574: LD_INT 2
35576: NEG
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 1
35584: PUSH
35585: LD_INT 1
35587: NEG
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: LD_INT 2
35595: PUSH
35596: LD_INT 0
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 2
35605: PUSH
35606: LD_INT 1
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 2
35615: PUSH
35616: LD_INT 2
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: LD_INT 1
35625: PUSH
35626: LD_INT 2
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 1
35635: NEG
35636: PUSH
35637: LD_INT 1
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 2
35646: NEG
35647: PUSH
35648: LD_INT 0
35650: PUSH
35651: EMPTY
35652: LIST
35653: LIST
35654: PUSH
35655: LD_INT 2
35657: NEG
35658: PUSH
35659: LD_INT 1
35661: NEG
35662: PUSH
35663: EMPTY
35664: LIST
35665: LIST
35666: PUSH
35667: LD_INT 2
35669: NEG
35670: PUSH
35671: LD_INT 2
35673: NEG
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 2
35681: NEG
35682: PUSH
35683: LD_INT 3
35685: NEG
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 2
35693: PUSH
35694: LD_INT 1
35696: NEG
35697: PUSH
35698: EMPTY
35699: LIST
35700: LIST
35701: PUSH
35702: LD_INT 3
35704: PUSH
35705: LD_INT 0
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 3
35714: PUSH
35715: LD_INT 1
35717: PUSH
35718: EMPTY
35719: LIST
35720: LIST
35721: PUSH
35722: LD_INT 3
35724: PUSH
35725: LD_INT 2
35727: PUSH
35728: EMPTY
35729: LIST
35730: LIST
35731: PUSH
35732: LD_INT 3
35734: PUSH
35735: LD_INT 3
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 2
35744: PUSH
35745: LD_INT 3
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: LD_INT 2
35754: NEG
35755: PUSH
35756: LD_INT 1
35758: PUSH
35759: EMPTY
35760: LIST
35761: LIST
35762: PUSH
35763: LD_INT 3
35765: NEG
35766: PUSH
35767: LD_INT 0
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: PUSH
35774: LD_INT 3
35776: NEG
35777: PUSH
35778: LD_INT 1
35780: NEG
35781: PUSH
35782: EMPTY
35783: LIST
35784: LIST
35785: PUSH
35786: LD_INT 3
35788: NEG
35789: PUSH
35790: LD_INT 2
35792: NEG
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 3
35800: NEG
35801: PUSH
35802: LD_INT 3
35804: NEG
35805: PUSH
35806: EMPTY
35807: LIST
35808: LIST
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: LIST
35822: LIST
35823: LIST
35824: LIST
35825: LIST
35826: LIST
35827: LIST
35828: LIST
35829: LIST
35830: LIST
35831: LIST
35832: LIST
35833: LIST
35834: LIST
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: LIST
35840: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35841: LD_ADDR_VAR 0 45
35845: PUSH
35846: LD_INT 0
35848: PUSH
35849: LD_INT 0
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PUSH
35856: LD_INT 0
35858: PUSH
35859: LD_INT 1
35861: NEG
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: LD_INT 1
35869: PUSH
35870: LD_INT 0
35872: PUSH
35873: EMPTY
35874: LIST
35875: LIST
35876: PUSH
35877: LD_INT 1
35879: PUSH
35880: LD_INT 1
35882: PUSH
35883: EMPTY
35884: LIST
35885: LIST
35886: PUSH
35887: LD_INT 0
35889: PUSH
35890: LD_INT 1
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: LD_INT 1
35899: NEG
35900: PUSH
35901: LD_INT 0
35903: PUSH
35904: EMPTY
35905: LIST
35906: LIST
35907: PUSH
35908: LD_INT 1
35910: NEG
35911: PUSH
35912: LD_INT 1
35914: NEG
35915: PUSH
35916: EMPTY
35917: LIST
35918: LIST
35919: PUSH
35920: LD_INT 1
35922: NEG
35923: PUSH
35924: LD_INT 2
35926: NEG
35927: PUSH
35928: EMPTY
35929: LIST
35930: LIST
35931: PUSH
35932: LD_INT 0
35934: PUSH
35935: LD_INT 2
35937: NEG
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PUSH
35943: LD_INT 1
35945: PUSH
35946: LD_INT 1
35948: NEG
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: LD_INT 2
35956: PUSH
35957: LD_INT 1
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PUSH
35964: LD_INT 2
35966: PUSH
35967: LD_INT 2
35969: PUSH
35970: EMPTY
35971: LIST
35972: LIST
35973: PUSH
35974: LD_INT 1
35976: PUSH
35977: LD_INT 2
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: PUSH
35984: LD_INT 0
35986: PUSH
35987: LD_INT 2
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 1
35996: NEG
35997: PUSH
35998: LD_INT 1
36000: PUSH
36001: EMPTY
36002: LIST
36003: LIST
36004: PUSH
36005: LD_INT 2
36007: NEG
36008: PUSH
36009: LD_INT 1
36011: NEG
36012: PUSH
36013: EMPTY
36014: LIST
36015: LIST
36016: PUSH
36017: LD_INT 2
36019: NEG
36020: PUSH
36021: LD_INT 2
36023: NEG
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 2
36031: NEG
36032: PUSH
36033: LD_INT 3
36035: NEG
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: LD_INT 1
36043: NEG
36044: PUSH
36045: LD_INT 3
36047: NEG
36048: PUSH
36049: EMPTY
36050: LIST
36051: LIST
36052: PUSH
36053: LD_INT 0
36055: PUSH
36056: LD_INT 3
36058: NEG
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: LD_INT 1
36066: PUSH
36067: LD_INT 2
36069: NEG
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 3
36077: PUSH
36078: LD_INT 2
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 3
36087: PUSH
36088: LD_INT 3
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: LD_INT 2
36097: PUSH
36098: LD_INT 3
36100: PUSH
36101: EMPTY
36102: LIST
36103: LIST
36104: PUSH
36105: LD_INT 1
36107: PUSH
36108: LD_INT 3
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: LD_INT 0
36117: PUSH
36118: LD_INT 3
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: PUSH
36125: LD_INT 1
36127: NEG
36128: PUSH
36129: LD_INT 2
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PUSH
36136: LD_INT 3
36138: NEG
36139: PUSH
36140: LD_INT 2
36142: NEG
36143: PUSH
36144: EMPTY
36145: LIST
36146: LIST
36147: PUSH
36148: LD_INT 3
36150: NEG
36151: PUSH
36152: LD_INT 3
36154: NEG
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: LIST
36164: LIST
36165: LIST
36166: LIST
36167: LIST
36168: LIST
36169: LIST
36170: LIST
36171: LIST
36172: LIST
36173: LIST
36174: LIST
36175: LIST
36176: LIST
36177: LIST
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: LIST
36184: LIST
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36191: LD_ADDR_VAR 0 46
36195: PUSH
36196: LD_INT 0
36198: PUSH
36199: LD_INT 0
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 0
36208: PUSH
36209: LD_INT 1
36211: NEG
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: PUSH
36217: LD_INT 1
36219: PUSH
36220: LD_INT 0
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: PUSH
36227: LD_INT 1
36229: PUSH
36230: LD_INT 1
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 0
36239: PUSH
36240: LD_INT 1
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 1
36249: NEG
36250: PUSH
36251: LD_INT 0
36253: PUSH
36254: EMPTY
36255: LIST
36256: LIST
36257: PUSH
36258: LD_INT 1
36260: NEG
36261: PUSH
36262: LD_INT 1
36264: NEG
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 1
36272: NEG
36273: PUSH
36274: LD_INT 2
36276: NEG
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: PUSH
36282: LD_INT 0
36284: PUSH
36285: LD_INT 2
36287: NEG
36288: PUSH
36289: EMPTY
36290: LIST
36291: LIST
36292: PUSH
36293: LD_INT 1
36295: PUSH
36296: LD_INT 1
36298: NEG
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PUSH
36304: LD_INT 2
36306: PUSH
36307: LD_INT 0
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: LD_INT 2
36316: PUSH
36317: LD_INT 1
36319: PUSH
36320: EMPTY
36321: LIST
36322: LIST
36323: PUSH
36324: LD_INT 1
36326: PUSH
36327: LD_INT 2
36329: PUSH
36330: EMPTY
36331: LIST
36332: LIST
36333: PUSH
36334: LD_INT 0
36336: PUSH
36337: LD_INT 2
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: PUSH
36344: LD_INT 1
36346: NEG
36347: PUSH
36348: LD_INT 1
36350: PUSH
36351: EMPTY
36352: LIST
36353: LIST
36354: PUSH
36355: LD_INT 2
36357: NEG
36358: PUSH
36359: LD_INT 0
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: PUSH
36366: LD_INT 2
36368: NEG
36369: PUSH
36370: LD_INT 1
36372: NEG
36373: PUSH
36374: EMPTY
36375: LIST
36376: LIST
36377: PUSH
36378: LD_INT 1
36380: NEG
36381: PUSH
36382: LD_INT 3
36384: NEG
36385: PUSH
36386: EMPTY
36387: LIST
36388: LIST
36389: PUSH
36390: LD_INT 0
36392: PUSH
36393: LD_INT 3
36395: NEG
36396: PUSH
36397: EMPTY
36398: LIST
36399: LIST
36400: PUSH
36401: LD_INT 1
36403: PUSH
36404: LD_INT 2
36406: NEG
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 2
36414: PUSH
36415: LD_INT 1
36417: NEG
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: LD_INT 3
36425: PUSH
36426: LD_INT 0
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: LD_INT 3
36435: PUSH
36436: LD_INT 1
36438: PUSH
36439: EMPTY
36440: LIST
36441: LIST
36442: PUSH
36443: LD_INT 1
36445: PUSH
36446: LD_INT 3
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: PUSH
36453: LD_INT 0
36455: PUSH
36456: LD_INT 3
36458: PUSH
36459: EMPTY
36460: LIST
36461: LIST
36462: PUSH
36463: LD_INT 1
36465: NEG
36466: PUSH
36467: LD_INT 2
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: PUSH
36474: LD_INT 2
36476: NEG
36477: PUSH
36478: LD_INT 1
36480: PUSH
36481: EMPTY
36482: LIST
36483: LIST
36484: PUSH
36485: LD_INT 3
36487: NEG
36488: PUSH
36489: LD_INT 0
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 3
36498: NEG
36499: PUSH
36500: LD_INT 1
36502: NEG
36503: PUSH
36504: EMPTY
36505: LIST
36506: LIST
36507: PUSH
36508: EMPTY
36509: LIST
36510: LIST
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: LIST
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: LIST
36522: LIST
36523: LIST
36524: LIST
36525: LIST
36526: LIST
36527: LIST
36528: LIST
36529: LIST
36530: LIST
36531: LIST
36532: LIST
36533: LIST
36534: LIST
36535: LIST
36536: LIST
36537: LIST
36538: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36539: LD_ADDR_VAR 0 47
36543: PUSH
36544: LD_INT 0
36546: PUSH
36547: LD_INT 0
36549: PUSH
36550: EMPTY
36551: LIST
36552: LIST
36553: PUSH
36554: LD_INT 0
36556: PUSH
36557: LD_INT 1
36559: NEG
36560: PUSH
36561: EMPTY
36562: LIST
36563: LIST
36564: PUSH
36565: LD_INT 1
36567: PUSH
36568: LD_INT 0
36570: PUSH
36571: EMPTY
36572: LIST
36573: LIST
36574: PUSH
36575: LD_INT 1
36577: PUSH
36578: LD_INT 1
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 0
36587: PUSH
36588: LD_INT 1
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: PUSH
36595: LD_INT 1
36597: NEG
36598: PUSH
36599: LD_INT 0
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: LD_INT 1
36608: NEG
36609: PUSH
36610: LD_INT 1
36612: NEG
36613: PUSH
36614: EMPTY
36615: LIST
36616: LIST
36617: PUSH
36618: LD_INT 1
36620: NEG
36621: PUSH
36622: LD_INT 2
36624: NEG
36625: PUSH
36626: EMPTY
36627: LIST
36628: LIST
36629: PUSH
36630: LD_INT 0
36632: PUSH
36633: LD_INT 2
36635: NEG
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: LD_INT 1
36643: PUSH
36644: LD_INT 1
36646: NEG
36647: PUSH
36648: EMPTY
36649: LIST
36650: LIST
36651: PUSH
36652: LD_INT 2
36654: NEG
36655: PUSH
36656: LD_INT 1
36658: NEG
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: LD_INT 2
36666: NEG
36667: PUSH
36668: LD_INT 2
36670: NEG
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: EMPTY
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36690: LD_ADDR_VAR 0 48
36694: PUSH
36695: LD_INT 0
36697: PUSH
36698: LD_INT 0
36700: PUSH
36701: EMPTY
36702: LIST
36703: LIST
36704: PUSH
36705: LD_INT 0
36707: PUSH
36708: LD_INT 1
36710: NEG
36711: PUSH
36712: EMPTY
36713: LIST
36714: LIST
36715: PUSH
36716: LD_INT 1
36718: PUSH
36719: LD_INT 0
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PUSH
36726: LD_INT 1
36728: PUSH
36729: LD_INT 1
36731: PUSH
36732: EMPTY
36733: LIST
36734: LIST
36735: PUSH
36736: LD_INT 0
36738: PUSH
36739: LD_INT 1
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: PUSH
36746: LD_INT 1
36748: NEG
36749: PUSH
36750: LD_INT 0
36752: PUSH
36753: EMPTY
36754: LIST
36755: LIST
36756: PUSH
36757: LD_INT 1
36759: NEG
36760: PUSH
36761: LD_INT 1
36763: NEG
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PUSH
36769: LD_INT 1
36771: NEG
36772: PUSH
36773: LD_INT 2
36775: NEG
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 0
36783: PUSH
36784: LD_INT 2
36786: NEG
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 1
36794: PUSH
36795: LD_INT 1
36797: NEG
36798: PUSH
36799: EMPTY
36800: LIST
36801: LIST
36802: PUSH
36803: LD_INT 2
36805: PUSH
36806: LD_INT 0
36808: PUSH
36809: EMPTY
36810: LIST
36811: LIST
36812: PUSH
36813: LD_INT 2
36815: PUSH
36816: LD_INT 1
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: LIST
36827: LIST
36828: LIST
36829: LIST
36830: LIST
36831: LIST
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36837: LD_ADDR_VAR 0 49
36841: PUSH
36842: LD_INT 0
36844: PUSH
36845: LD_INT 0
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 0
36854: PUSH
36855: LD_INT 1
36857: NEG
36858: PUSH
36859: EMPTY
36860: LIST
36861: LIST
36862: PUSH
36863: LD_INT 1
36865: PUSH
36866: LD_INT 0
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PUSH
36873: LD_INT 1
36875: PUSH
36876: LD_INT 1
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 0
36885: PUSH
36886: LD_INT 1
36888: PUSH
36889: EMPTY
36890: LIST
36891: LIST
36892: PUSH
36893: LD_INT 1
36895: NEG
36896: PUSH
36897: LD_INT 0
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 1
36906: NEG
36907: PUSH
36908: LD_INT 1
36910: NEG
36911: PUSH
36912: EMPTY
36913: LIST
36914: LIST
36915: PUSH
36916: LD_INT 1
36918: PUSH
36919: LD_INT 1
36921: NEG
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: LD_INT 2
36929: PUSH
36930: LD_INT 0
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 2
36939: PUSH
36940: LD_INT 1
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 2
36949: PUSH
36950: LD_INT 2
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 1
36959: PUSH
36960: LD_INT 2
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36981: LD_ADDR_VAR 0 50
36985: PUSH
36986: LD_INT 0
36988: PUSH
36989: LD_INT 0
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 0
36998: PUSH
36999: LD_INT 1
37001: NEG
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: PUSH
37007: LD_INT 1
37009: PUSH
37010: LD_INT 0
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 1
37019: PUSH
37020: LD_INT 1
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: LD_INT 0
37029: PUSH
37030: LD_INT 1
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 1
37039: NEG
37040: PUSH
37041: LD_INT 0
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 1
37050: NEG
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 2
37062: PUSH
37063: LD_INT 1
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 2
37072: PUSH
37073: LD_INT 2
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 1
37082: PUSH
37083: LD_INT 2
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 0
37092: PUSH
37093: LD_INT 2
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 1
37102: NEG
37103: PUSH
37104: LD_INT 1
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: PUSH
37111: EMPTY
37112: LIST
37113: LIST
37114: LIST
37115: LIST
37116: LIST
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: LIST
37124: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37125: LD_ADDR_VAR 0 51
37129: PUSH
37130: LD_INT 0
37132: PUSH
37133: LD_INT 0
37135: PUSH
37136: EMPTY
37137: LIST
37138: LIST
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: LD_INT 1
37145: NEG
37146: PUSH
37147: EMPTY
37148: LIST
37149: LIST
37150: PUSH
37151: LD_INT 1
37153: PUSH
37154: LD_INT 0
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 1
37163: PUSH
37164: LD_INT 1
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 0
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PUSH
37181: LD_INT 1
37183: NEG
37184: PUSH
37185: LD_INT 0
37187: PUSH
37188: EMPTY
37189: LIST
37190: LIST
37191: PUSH
37192: LD_INT 1
37194: NEG
37195: PUSH
37196: LD_INT 1
37198: NEG
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 1
37206: PUSH
37207: LD_INT 2
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 0
37216: PUSH
37217: LD_INT 2
37219: PUSH
37220: EMPTY
37221: LIST
37222: LIST
37223: PUSH
37224: LD_INT 1
37226: NEG
37227: PUSH
37228: LD_INT 1
37230: PUSH
37231: EMPTY
37232: LIST
37233: LIST
37234: PUSH
37235: LD_INT 2
37237: NEG
37238: PUSH
37239: LD_INT 0
37241: PUSH
37242: EMPTY
37243: LIST
37244: LIST
37245: PUSH
37246: LD_INT 2
37248: NEG
37249: PUSH
37250: LD_INT 1
37252: NEG
37253: PUSH
37254: EMPTY
37255: LIST
37256: LIST
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: LIST
37262: LIST
37263: LIST
37264: LIST
37265: LIST
37266: LIST
37267: LIST
37268: LIST
37269: LIST
37270: LIST
37271: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37272: LD_ADDR_VAR 0 52
37276: PUSH
37277: LD_INT 0
37279: PUSH
37280: LD_INT 0
37282: PUSH
37283: EMPTY
37284: LIST
37285: LIST
37286: PUSH
37287: LD_INT 0
37289: PUSH
37290: LD_INT 1
37292: NEG
37293: PUSH
37294: EMPTY
37295: LIST
37296: LIST
37297: PUSH
37298: LD_INT 1
37300: PUSH
37301: LD_INT 0
37303: PUSH
37304: EMPTY
37305: LIST
37306: LIST
37307: PUSH
37308: LD_INT 1
37310: PUSH
37311: LD_INT 1
37313: PUSH
37314: EMPTY
37315: LIST
37316: LIST
37317: PUSH
37318: LD_INT 0
37320: PUSH
37321: LD_INT 1
37323: PUSH
37324: EMPTY
37325: LIST
37326: LIST
37327: PUSH
37328: LD_INT 1
37330: NEG
37331: PUSH
37332: LD_INT 0
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: PUSH
37339: LD_INT 1
37341: NEG
37342: PUSH
37343: LD_INT 1
37345: NEG
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: LD_INT 1
37353: NEG
37354: PUSH
37355: LD_INT 2
37357: NEG
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 1
37365: NEG
37366: PUSH
37367: LD_INT 1
37369: PUSH
37370: EMPTY
37371: LIST
37372: LIST
37373: PUSH
37374: LD_INT 2
37376: NEG
37377: PUSH
37378: LD_INT 0
37380: PUSH
37381: EMPTY
37382: LIST
37383: LIST
37384: PUSH
37385: LD_INT 2
37387: NEG
37388: PUSH
37389: LD_INT 1
37391: NEG
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: LD_INT 2
37399: NEG
37400: PUSH
37401: LD_INT 2
37403: NEG
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: PUSH
37409: EMPTY
37410: LIST
37411: LIST
37412: LIST
37413: LIST
37414: LIST
37415: LIST
37416: LIST
37417: LIST
37418: LIST
37419: LIST
37420: LIST
37421: LIST
37422: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37423: LD_ADDR_VAR 0 53
37427: PUSH
37428: LD_INT 0
37430: PUSH
37431: LD_INT 0
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 0
37440: PUSH
37441: LD_INT 1
37443: NEG
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 1
37451: PUSH
37452: LD_INT 0
37454: PUSH
37455: EMPTY
37456: LIST
37457: LIST
37458: PUSH
37459: LD_INT 1
37461: PUSH
37462: LD_INT 1
37464: PUSH
37465: EMPTY
37466: LIST
37467: LIST
37468: PUSH
37469: LD_INT 0
37471: PUSH
37472: LD_INT 1
37474: PUSH
37475: EMPTY
37476: LIST
37477: LIST
37478: PUSH
37479: LD_INT 1
37481: NEG
37482: PUSH
37483: LD_INT 0
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 1
37492: NEG
37493: PUSH
37494: LD_INT 1
37496: NEG
37497: PUSH
37498: EMPTY
37499: LIST
37500: LIST
37501: PUSH
37502: LD_INT 1
37504: NEG
37505: PUSH
37506: LD_INT 2
37508: NEG
37509: PUSH
37510: EMPTY
37511: LIST
37512: LIST
37513: PUSH
37514: LD_INT 0
37516: PUSH
37517: LD_INT 2
37519: NEG
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: PUSH
37525: LD_INT 1
37527: PUSH
37528: LD_INT 1
37530: NEG
37531: PUSH
37532: EMPTY
37533: LIST
37534: LIST
37535: PUSH
37536: LD_INT 2
37538: PUSH
37539: LD_INT 0
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PUSH
37546: LD_INT 2
37548: PUSH
37549: LD_INT 1
37551: PUSH
37552: EMPTY
37553: LIST
37554: LIST
37555: PUSH
37556: LD_INT 2
37558: PUSH
37559: LD_INT 2
37561: PUSH
37562: EMPTY
37563: LIST
37564: LIST
37565: PUSH
37566: LD_INT 1
37568: PUSH
37569: LD_INT 2
37571: PUSH
37572: EMPTY
37573: LIST
37574: LIST
37575: PUSH
37576: LD_INT 0
37578: PUSH
37579: LD_INT 2
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 1
37588: NEG
37589: PUSH
37590: LD_INT 1
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 2
37599: NEG
37600: PUSH
37601: LD_INT 0
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 2
37610: NEG
37611: PUSH
37612: LD_INT 1
37614: NEG
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 2
37622: NEG
37623: PUSH
37624: LD_INT 2
37626: NEG
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: LIST
37636: LIST
37637: LIST
37638: LIST
37639: LIST
37640: LIST
37641: LIST
37642: LIST
37643: LIST
37644: LIST
37645: LIST
37646: LIST
37647: LIST
37648: LIST
37649: LIST
37650: LIST
37651: LIST
37652: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37653: LD_ADDR_VAR 0 54
37657: PUSH
37658: LD_INT 0
37660: PUSH
37661: LD_INT 0
37663: PUSH
37664: EMPTY
37665: LIST
37666: LIST
37667: PUSH
37668: LD_INT 0
37670: PUSH
37671: LD_INT 1
37673: NEG
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 1
37681: PUSH
37682: LD_INT 0
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: LD_INT 1
37691: PUSH
37692: LD_INT 1
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 0
37701: PUSH
37702: LD_INT 1
37704: PUSH
37705: EMPTY
37706: LIST
37707: LIST
37708: PUSH
37709: LD_INT 1
37711: NEG
37712: PUSH
37713: LD_INT 0
37715: PUSH
37716: EMPTY
37717: LIST
37718: LIST
37719: PUSH
37720: LD_INT 1
37722: NEG
37723: PUSH
37724: LD_INT 1
37726: NEG
37727: PUSH
37728: EMPTY
37729: LIST
37730: LIST
37731: PUSH
37732: LD_INT 1
37734: NEG
37735: PUSH
37736: LD_INT 2
37738: NEG
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 0
37746: PUSH
37747: LD_INT 2
37749: NEG
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 1
37757: PUSH
37758: LD_INT 1
37760: NEG
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: LD_INT 2
37768: PUSH
37769: LD_INT 0
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: LD_INT 2
37778: PUSH
37779: LD_INT 1
37781: PUSH
37782: EMPTY
37783: LIST
37784: LIST
37785: PUSH
37786: LD_INT 2
37788: PUSH
37789: LD_INT 2
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: LD_INT 1
37798: PUSH
37799: LD_INT 2
37801: PUSH
37802: EMPTY
37803: LIST
37804: LIST
37805: PUSH
37806: LD_INT 0
37808: PUSH
37809: LD_INT 2
37811: PUSH
37812: EMPTY
37813: LIST
37814: LIST
37815: PUSH
37816: LD_INT 1
37818: NEG
37819: PUSH
37820: LD_INT 1
37822: PUSH
37823: EMPTY
37824: LIST
37825: LIST
37826: PUSH
37827: LD_INT 2
37829: NEG
37830: PUSH
37831: LD_INT 0
37833: PUSH
37834: EMPTY
37835: LIST
37836: LIST
37837: PUSH
37838: LD_INT 2
37840: NEG
37841: PUSH
37842: LD_INT 1
37844: NEG
37845: PUSH
37846: EMPTY
37847: LIST
37848: LIST
37849: PUSH
37850: LD_INT 2
37852: NEG
37853: PUSH
37854: LD_INT 2
37856: NEG
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: PUSH
37862: EMPTY
37863: LIST
37864: LIST
37865: LIST
37866: LIST
37867: LIST
37868: LIST
37869: LIST
37870: LIST
37871: LIST
37872: LIST
37873: LIST
37874: LIST
37875: LIST
37876: LIST
37877: LIST
37878: LIST
37879: LIST
37880: LIST
37881: LIST
37882: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37883: LD_ADDR_VAR 0 55
37887: PUSH
37888: LD_INT 0
37890: PUSH
37891: LD_INT 0
37893: PUSH
37894: EMPTY
37895: LIST
37896: LIST
37897: PUSH
37898: LD_INT 0
37900: PUSH
37901: LD_INT 1
37903: NEG
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 1
37911: PUSH
37912: LD_INT 0
37914: PUSH
37915: EMPTY
37916: LIST
37917: LIST
37918: PUSH
37919: LD_INT 1
37921: PUSH
37922: LD_INT 1
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 0
37931: PUSH
37932: LD_INT 1
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: LD_INT 1
37941: NEG
37942: PUSH
37943: LD_INT 0
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: LD_INT 1
37952: NEG
37953: PUSH
37954: LD_INT 1
37956: NEG
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 1
37964: NEG
37965: PUSH
37966: LD_INT 2
37968: NEG
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: LD_INT 0
37976: PUSH
37977: LD_INT 2
37979: NEG
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 1
37987: PUSH
37988: LD_INT 1
37990: NEG
37991: PUSH
37992: EMPTY
37993: LIST
37994: LIST
37995: PUSH
37996: LD_INT 2
37998: PUSH
37999: LD_INT 0
38001: PUSH
38002: EMPTY
38003: LIST
38004: LIST
38005: PUSH
38006: LD_INT 2
38008: PUSH
38009: LD_INT 1
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: LD_INT 2
38018: PUSH
38019: LD_INT 2
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 1
38028: PUSH
38029: LD_INT 2
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 0
38038: PUSH
38039: LD_INT 2
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: LD_INT 1
38048: NEG
38049: PUSH
38050: LD_INT 1
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PUSH
38057: LD_INT 2
38059: NEG
38060: PUSH
38061: LD_INT 0
38063: PUSH
38064: EMPTY
38065: LIST
38066: LIST
38067: PUSH
38068: LD_INT 2
38070: NEG
38071: PUSH
38072: LD_INT 1
38074: NEG
38075: PUSH
38076: EMPTY
38077: LIST
38078: LIST
38079: PUSH
38080: LD_INT 2
38082: NEG
38083: PUSH
38084: LD_INT 2
38086: NEG
38087: PUSH
38088: EMPTY
38089: LIST
38090: LIST
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: LIST
38096: LIST
38097: LIST
38098: LIST
38099: LIST
38100: LIST
38101: LIST
38102: LIST
38103: LIST
38104: LIST
38105: LIST
38106: LIST
38107: LIST
38108: LIST
38109: LIST
38110: LIST
38111: LIST
38112: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38113: LD_ADDR_VAR 0 56
38117: PUSH
38118: LD_INT 0
38120: PUSH
38121: LD_INT 0
38123: PUSH
38124: EMPTY
38125: LIST
38126: LIST
38127: PUSH
38128: LD_INT 0
38130: PUSH
38131: LD_INT 1
38133: NEG
38134: PUSH
38135: EMPTY
38136: LIST
38137: LIST
38138: PUSH
38139: LD_INT 1
38141: PUSH
38142: LD_INT 0
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 1
38151: PUSH
38152: LD_INT 1
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PUSH
38159: LD_INT 0
38161: PUSH
38162: LD_INT 1
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: LD_INT 1
38171: NEG
38172: PUSH
38173: LD_INT 0
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: LD_INT 1
38182: NEG
38183: PUSH
38184: LD_INT 1
38186: NEG
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 1
38194: NEG
38195: PUSH
38196: LD_INT 2
38198: NEG
38199: PUSH
38200: EMPTY
38201: LIST
38202: LIST
38203: PUSH
38204: LD_INT 0
38206: PUSH
38207: LD_INT 2
38209: NEG
38210: PUSH
38211: EMPTY
38212: LIST
38213: LIST
38214: PUSH
38215: LD_INT 1
38217: PUSH
38218: LD_INT 1
38220: NEG
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: PUSH
38226: LD_INT 2
38228: PUSH
38229: LD_INT 0
38231: PUSH
38232: EMPTY
38233: LIST
38234: LIST
38235: PUSH
38236: LD_INT 2
38238: PUSH
38239: LD_INT 1
38241: PUSH
38242: EMPTY
38243: LIST
38244: LIST
38245: PUSH
38246: LD_INT 2
38248: PUSH
38249: LD_INT 2
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: PUSH
38256: LD_INT 1
38258: PUSH
38259: LD_INT 2
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: LD_INT 0
38268: PUSH
38269: LD_INT 2
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: PUSH
38276: LD_INT 1
38278: NEG
38279: PUSH
38280: LD_INT 1
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: LD_INT 2
38289: NEG
38290: PUSH
38291: LD_INT 0
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 2
38300: NEG
38301: PUSH
38302: LD_INT 1
38304: NEG
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 2
38312: NEG
38313: PUSH
38314: LD_INT 2
38316: NEG
38317: PUSH
38318: EMPTY
38319: LIST
38320: LIST
38321: PUSH
38322: EMPTY
38323: LIST
38324: LIST
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38343: LD_ADDR_VAR 0 57
38347: PUSH
38348: LD_INT 0
38350: PUSH
38351: LD_INT 0
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 0
38360: PUSH
38361: LD_INT 1
38363: NEG
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 1
38371: PUSH
38372: LD_INT 0
38374: PUSH
38375: EMPTY
38376: LIST
38377: LIST
38378: PUSH
38379: LD_INT 1
38381: PUSH
38382: LD_INT 1
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: LD_INT 0
38391: PUSH
38392: LD_INT 1
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: PUSH
38399: LD_INT 1
38401: NEG
38402: PUSH
38403: LD_INT 0
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 1
38412: NEG
38413: PUSH
38414: LD_INT 1
38416: NEG
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 1
38424: NEG
38425: PUSH
38426: LD_INT 2
38428: NEG
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 0
38436: PUSH
38437: LD_INT 2
38439: NEG
38440: PUSH
38441: EMPTY
38442: LIST
38443: LIST
38444: PUSH
38445: LD_INT 1
38447: PUSH
38448: LD_INT 1
38450: NEG
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PUSH
38456: LD_INT 2
38458: PUSH
38459: LD_INT 0
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PUSH
38466: LD_INT 2
38468: PUSH
38469: LD_INT 1
38471: PUSH
38472: EMPTY
38473: LIST
38474: LIST
38475: PUSH
38476: LD_INT 2
38478: PUSH
38479: LD_INT 2
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: LD_INT 1
38488: PUSH
38489: LD_INT 2
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: PUSH
38496: LD_INT 0
38498: PUSH
38499: LD_INT 2
38501: PUSH
38502: EMPTY
38503: LIST
38504: LIST
38505: PUSH
38506: LD_INT 1
38508: NEG
38509: PUSH
38510: LD_INT 1
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: PUSH
38517: LD_INT 2
38519: NEG
38520: PUSH
38521: LD_INT 0
38523: PUSH
38524: EMPTY
38525: LIST
38526: LIST
38527: PUSH
38528: LD_INT 2
38530: NEG
38531: PUSH
38532: LD_INT 1
38534: NEG
38535: PUSH
38536: EMPTY
38537: LIST
38538: LIST
38539: PUSH
38540: LD_INT 2
38542: NEG
38543: PUSH
38544: LD_INT 2
38546: NEG
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: LIST
38556: LIST
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: LIST
38564: LIST
38565: LIST
38566: LIST
38567: LIST
38568: LIST
38569: LIST
38570: LIST
38571: LIST
38572: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38573: LD_ADDR_VAR 0 58
38577: PUSH
38578: LD_INT 0
38580: PUSH
38581: LD_INT 0
38583: PUSH
38584: EMPTY
38585: LIST
38586: LIST
38587: PUSH
38588: LD_INT 0
38590: PUSH
38591: LD_INT 1
38593: NEG
38594: PUSH
38595: EMPTY
38596: LIST
38597: LIST
38598: PUSH
38599: LD_INT 1
38601: PUSH
38602: LD_INT 0
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: LD_INT 1
38611: PUSH
38612: LD_INT 1
38614: PUSH
38615: EMPTY
38616: LIST
38617: LIST
38618: PUSH
38619: LD_INT 0
38621: PUSH
38622: LD_INT 1
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: PUSH
38629: LD_INT 1
38631: NEG
38632: PUSH
38633: LD_INT 0
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: PUSH
38640: LD_INT 1
38642: NEG
38643: PUSH
38644: LD_INT 1
38646: NEG
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: PUSH
38652: LD_INT 1
38654: NEG
38655: PUSH
38656: LD_INT 2
38658: NEG
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: PUSH
38664: LD_INT 0
38666: PUSH
38667: LD_INT 2
38669: NEG
38670: PUSH
38671: EMPTY
38672: LIST
38673: LIST
38674: PUSH
38675: LD_INT 1
38677: PUSH
38678: LD_INT 1
38680: NEG
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: LD_INT 2
38688: PUSH
38689: LD_INT 0
38691: PUSH
38692: EMPTY
38693: LIST
38694: LIST
38695: PUSH
38696: LD_INT 2
38698: PUSH
38699: LD_INT 1
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 2
38708: PUSH
38709: LD_INT 2
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 1
38718: PUSH
38719: LD_INT 2
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: LD_INT 0
38728: PUSH
38729: LD_INT 2
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 1
38738: NEG
38739: PUSH
38740: LD_INT 1
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 2
38749: NEG
38750: PUSH
38751: LD_INT 0
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: PUSH
38758: LD_INT 2
38760: NEG
38761: PUSH
38762: LD_INT 1
38764: NEG
38765: PUSH
38766: EMPTY
38767: LIST
38768: LIST
38769: PUSH
38770: LD_INT 2
38772: NEG
38773: PUSH
38774: LD_INT 2
38776: NEG
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: LIST
38786: LIST
38787: LIST
38788: LIST
38789: LIST
38790: LIST
38791: LIST
38792: LIST
38793: LIST
38794: LIST
38795: LIST
38796: LIST
38797: LIST
38798: LIST
38799: LIST
38800: LIST
38801: LIST
38802: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38803: LD_ADDR_VAR 0 59
38807: PUSH
38808: LD_INT 0
38810: PUSH
38811: LD_INT 0
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: LD_INT 0
38820: PUSH
38821: LD_INT 1
38823: NEG
38824: PUSH
38825: EMPTY
38826: LIST
38827: LIST
38828: PUSH
38829: LD_INT 1
38831: PUSH
38832: LD_INT 0
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: PUSH
38839: LD_INT 1
38841: PUSH
38842: LD_INT 1
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: PUSH
38849: LD_INT 0
38851: PUSH
38852: LD_INT 1
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 1
38861: NEG
38862: PUSH
38863: LD_INT 0
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: LD_INT 1
38872: NEG
38873: PUSH
38874: LD_INT 1
38876: NEG
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38891: LD_ADDR_VAR 0 60
38895: PUSH
38896: LD_INT 0
38898: PUSH
38899: LD_INT 0
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: PUSH
38906: LD_INT 0
38908: PUSH
38909: LD_INT 1
38911: NEG
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: LD_INT 1
38919: PUSH
38920: LD_INT 0
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PUSH
38927: LD_INT 1
38929: PUSH
38930: LD_INT 1
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: LD_INT 0
38939: PUSH
38940: LD_INT 1
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: LD_INT 1
38949: NEG
38950: PUSH
38951: LD_INT 0
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 1
38960: NEG
38961: PUSH
38962: LD_INT 1
38964: NEG
38965: PUSH
38966: EMPTY
38967: LIST
38968: LIST
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: LIST
38974: LIST
38975: LIST
38976: LIST
38977: LIST
38978: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38979: LD_ADDR_VAR 0 61
38983: PUSH
38984: LD_INT 0
38986: PUSH
38987: LD_INT 0
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PUSH
38994: LD_INT 0
38996: PUSH
38997: LD_INT 1
38999: NEG
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: LD_INT 1
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 1
39017: PUSH
39018: LD_INT 1
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 0
39027: PUSH
39028: LD_INT 1
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 1
39037: NEG
39038: PUSH
39039: LD_INT 0
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 1
39048: NEG
39049: PUSH
39050: LD_INT 1
39052: NEG
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39067: LD_ADDR_VAR 0 62
39071: PUSH
39072: LD_INT 0
39074: PUSH
39075: LD_INT 0
39077: PUSH
39078: EMPTY
39079: LIST
39080: LIST
39081: PUSH
39082: LD_INT 0
39084: PUSH
39085: LD_INT 1
39087: NEG
39088: PUSH
39089: EMPTY
39090: LIST
39091: LIST
39092: PUSH
39093: LD_INT 1
39095: PUSH
39096: LD_INT 0
39098: PUSH
39099: EMPTY
39100: LIST
39101: LIST
39102: PUSH
39103: LD_INT 1
39105: PUSH
39106: LD_INT 1
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: LD_INT 0
39115: PUSH
39116: LD_INT 1
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PUSH
39123: LD_INT 1
39125: NEG
39126: PUSH
39127: LD_INT 0
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 1
39136: NEG
39137: PUSH
39138: LD_INT 1
39140: NEG
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: LIST
39150: LIST
39151: LIST
39152: LIST
39153: LIST
39154: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39155: LD_ADDR_VAR 0 63
39159: PUSH
39160: LD_INT 0
39162: PUSH
39163: LD_INT 0
39165: PUSH
39166: EMPTY
39167: LIST
39168: LIST
39169: PUSH
39170: LD_INT 0
39172: PUSH
39173: LD_INT 1
39175: NEG
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: PUSH
39181: LD_INT 1
39183: PUSH
39184: LD_INT 0
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: PUSH
39191: LD_INT 1
39193: PUSH
39194: LD_INT 1
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 0
39203: PUSH
39204: LD_INT 1
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PUSH
39211: LD_INT 1
39213: NEG
39214: PUSH
39215: LD_INT 0
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PUSH
39222: LD_INT 1
39224: NEG
39225: PUSH
39226: LD_INT 1
39228: NEG
39229: PUSH
39230: EMPTY
39231: LIST
39232: LIST
39233: PUSH
39234: EMPTY
39235: LIST
39236: LIST
39237: LIST
39238: LIST
39239: LIST
39240: LIST
39241: LIST
39242: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39243: LD_ADDR_VAR 0 64
39247: PUSH
39248: LD_INT 0
39250: PUSH
39251: LD_INT 0
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 0
39260: PUSH
39261: LD_INT 1
39263: NEG
39264: PUSH
39265: EMPTY
39266: LIST
39267: LIST
39268: PUSH
39269: LD_INT 1
39271: PUSH
39272: LD_INT 0
39274: PUSH
39275: EMPTY
39276: LIST
39277: LIST
39278: PUSH
39279: LD_INT 1
39281: PUSH
39282: LD_INT 1
39284: PUSH
39285: EMPTY
39286: LIST
39287: LIST
39288: PUSH
39289: LD_INT 0
39291: PUSH
39292: LD_INT 1
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: LD_INT 1
39301: NEG
39302: PUSH
39303: LD_INT 0
39305: PUSH
39306: EMPTY
39307: LIST
39308: LIST
39309: PUSH
39310: LD_INT 1
39312: NEG
39313: PUSH
39314: LD_INT 1
39316: NEG
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: LIST
39326: LIST
39327: LIST
39328: LIST
39329: LIST
39330: ST_TO_ADDR
// end ; 1 :
39331: GO 45228
39333: LD_INT 1
39335: DOUBLE
39336: EQUAL
39337: IFTRUE 39341
39339: GO 41964
39341: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39342: LD_ADDR_VAR 0 11
39346: PUSH
39347: LD_INT 1
39349: NEG
39350: PUSH
39351: LD_INT 3
39353: NEG
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: LD_INT 0
39361: PUSH
39362: LD_INT 3
39364: NEG
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: LD_INT 1
39372: PUSH
39373: LD_INT 2
39375: NEG
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: LIST
39385: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39386: LD_ADDR_VAR 0 12
39390: PUSH
39391: LD_INT 2
39393: PUSH
39394: LD_INT 1
39396: NEG
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: LD_INT 3
39404: PUSH
39405: LD_INT 0
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 3
39414: PUSH
39415: LD_INT 1
39417: PUSH
39418: EMPTY
39419: LIST
39420: LIST
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: LIST
39426: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39427: LD_ADDR_VAR 0 13
39431: PUSH
39432: LD_INT 3
39434: PUSH
39435: LD_INT 2
39437: PUSH
39438: EMPTY
39439: LIST
39440: LIST
39441: PUSH
39442: LD_INT 3
39444: PUSH
39445: LD_INT 3
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 2
39454: PUSH
39455: LD_INT 3
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PUSH
39462: EMPTY
39463: LIST
39464: LIST
39465: LIST
39466: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39467: LD_ADDR_VAR 0 14
39471: PUSH
39472: LD_INT 1
39474: PUSH
39475: LD_INT 3
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 0
39484: PUSH
39485: LD_INT 3
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 1
39494: NEG
39495: PUSH
39496: LD_INT 2
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: LIST
39507: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39508: LD_ADDR_VAR 0 15
39512: PUSH
39513: LD_INT 2
39515: NEG
39516: PUSH
39517: LD_INT 1
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: LD_INT 3
39526: NEG
39527: PUSH
39528: LD_INT 0
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: LD_INT 3
39537: NEG
39538: PUSH
39539: LD_INT 1
39541: NEG
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: LIST
39551: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39552: LD_ADDR_VAR 0 16
39556: PUSH
39557: LD_INT 2
39559: NEG
39560: PUSH
39561: LD_INT 3
39563: NEG
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: PUSH
39569: LD_INT 3
39571: NEG
39572: PUSH
39573: LD_INT 2
39575: NEG
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: LD_INT 3
39583: NEG
39584: PUSH
39585: LD_INT 3
39587: NEG
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: LIST
39597: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39598: LD_ADDR_VAR 0 17
39602: PUSH
39603: LD_INT 1
39605: NEG
39606: PUSH
39607: LD_INT 3
39609: NEG
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 0
39617: PUSH
39618: LD_INT 3
39620: NEG
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: LD_INT 1
39628: PUSH
39629: LD_INT 2
39631: NEG
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: LIST
39641: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39642: LD_ADDR_VAR 0 18
39646: PUSH
39647: LD_INT 2
39649: PUSH
39650: LD_INT 1
39652: NEG
39653: PUSH
39654: EMPTY
39655: LIST
39656: LIST
39657: PUSH
39658: LD_INT 3
39660: PUSH
39661: LD_INT 0
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PUSH
39668: LD_INT 3
39670: PUSH
39671: LD_INT 1
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: LIST
39682: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39683: LD_ADDR_VAR 0 19
39687: PUSH
39688: LD_INT 3
39690: PUSH
39691: LD_INT 2
39693: PUSH
39694: EMPTY
39695: LIST
39696: LIST
39697: PUSH
39698: LD_INT 3
39700: PUSH
39701: LD_INT 3
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: LD_INT 2
39710: PUSH
39711: LD_INT 3
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: LIST
39722: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39723: LD_ADDR_VAR 0 20
39727: PUSH
39728: LD_INT 1
39730: PUSH
39731: LD_INT 3
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 0
39740: PUSH
39741: LD_INT 3
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: PUSH
39748: LD_INT 1
39750: NEG
39751: PUSH
39752: LD_INT 2
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: EMPTY
39760: LIST
39761: LIST
39762: LIST
39763: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39764: LD_ADDR_VAR 0 21
39768: PUSH
39769: LD_INT 2
39771: NEG
39772: PUSH
39773: LD_INT 1
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 3
39782: NEG
39783: PUSH
39784: LD_INT 0
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 3
39793: NEG
39794: PUSH
39795: LD_INT 1
39797: NEG
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: LIST
39807: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39808: LD_ADDR_VAR 0 22
39812: PUSH
39813: LD_INT 2
39815: NEG
39816: PUSH
39817: LD_INT 3
39819: NEG
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: LD_INT 3
39827: NEG
39828: PUSH
39829: LD_INT 2
39831: NEG
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 3
39839: NEG
39840: PUSH
39841: LD_INT 3
39843: NEG
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: EMPTY
39850: LIST
39851: LIST
39852: LIST
39853: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39854: LD_ADDR_VAR 0 23
39858: PUSH
39859: LD_INT 0
39861: PUSH
39862: LD_INT 3
39864: NEG
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: PUSH
39870: LD_INT 1
39872: NEG
39873: PUSH
39874: LD_INT 4
39876: NEG
39877: PUSH
39878: EMPTY
39879: LIST
39880: LIST
39881: PUSH
39882: LD_INT 1
39884: PUSH
39885: LD_INT 3
39887: NEG
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: LIST
39897: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39898: LD_ADDR_VAR 0 24
39902: PUSH
39903: LD_INT 3
39905: PUSH
39906: LD_INT 0
39908: PUSH
39909: EMPTY
39910: LIST
39911: LIST
39912: PUSH
39913: LD_INT 3
39915: PUSH
39916: LD_INT 1
39918: NEG
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PUSH
39924: LD_INT 4
39926: PUSH
39927: LD_INT 1
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: LIST
39938: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39939: LD_ADDR_VAR 0 25
39943: PUSH
39944: LD_INT 3
39946: PUSH
39947: LD_INT 3
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: LD_INT 4
39956: PUSH
39957: LD_INT 3
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 3
39966: PUSH
39967: LD_INT 4
39969: PUSH
39970: EMPTY
39971: LIST
39972: LIST
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: LIST
39978: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39979: LD_ADDR_VAR 0 26
39983: PUSH
39984: LD_INT 0
39986: PUSH
39987: LD_INT 3
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: PUSH
39994: LD_INT 1
39996: PUSH
39997: LD_INT 4
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: PUSH
40004: LD_INT 1
40006: NEG
40007: PUSH
40008: LD_INT 3
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: EMPTY
40016: LIST
40017: LIST
40018: LIST
40019: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40020: LD_ADDR_VAR 0 27
40024: PUSH
40025: LD_INT 3
40027: NEG
40028: PUSH
40029: LD_INT 0
40031: PUSH
40032: EMPTY
40033: LIST
40034: LIST
40035: PUSH
40036: LD_INT 3
40038: NEG
40039: PUSH
40040: LD_INT 1
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 4
40049: NEG
40050: PUSH
40051: LD_INT 1
40053: NEG
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PUSH
40059: EMPTY
40060: LIST
40061: LIST
40062: LIST
40063: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40064: LD_ADDR_VAR 0 28
40068: PUSH
40069: LD_INT 3
40071: NEG
40072: PUSH
40073: LD_INT 3
40075: NEG
40076: PUSH
40077: EMPTY
40078: LIST
40079: LIST
40080: PUSH
40081: LD_INT 3
40083: NEG
40084: PUSH
40085: LD_INT 4
40087: NEG
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 4
40095: NEG
40096: PUSH
40097: LD_INT 3
40099: NEG
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: LIST
40109: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40110: LD_ADDR_VAR 0 29
40114: PUSH
40115: LD_INT 1
40117: NEG
40118: PUSH
40119: LD_INT 3
40121: NEG
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: LD_INT 0
40129: PUSH
40130: LD_INT 3
40132: NEG
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: LD_INT 1
40140: PUSH
40141: LD_INT 2
40143: NEG
40144: PUSH
40145: EMPTY
40146: LIST
40147: LIST
40148: PUSH
40149: LD_INT 1
40151: NEG
40152: PUSH
40153: LD_INT 4
40155: NEG
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PUSH
40161: LD_INT 0
40163: PUSH
40164: LD_INT 4
40166: NEG
40167: PUSH
40168: EMPTY
40169: LIST
40170: LIST
40171: PUSH
40172: LD_INT 1
40174: PUSH
40175: LD_INT 3
40177: NEG
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: LD_INT 1
40185: NEG
40186: PUSH
40187: LD_INT 5
40189: NEG
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: LD_INT 0
40197: PUSH
40198: LD_INT 5
40200: NEG
40201: PUSH
40202: EMPTY
40203: LIST
40204: LIST
40205: PUSH
40206: LD_INT 1
40208: PUSH
40209: LD_INT 4
40211: NEG
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 1
40219: NEG
40220: PUSH
40221: LD_INT 6
40223: NEG
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 0
40231: PUSH
40232: LD_INT 6
40234: NEG
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PUSH
40240: LD_INT 1
40242: PUSH
40243: LD_INT 5
40245: NEG
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: LIST
40255: LIST
40256: LIST
40257: LIST
40258: LIST
40259: LIST
40260: LIST
40261: LIST
40262: LIST
40263: LIST
40264: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40265: LD_ADDR_VAR 0 30
40269: PUSH
40270: LD_INT 2
40272: PUSH
40273: LD_INT 1
40275: NEG
40276: PUSH
40277: EMPTY
40278: LIST
40279: LIST
40280: PUSH
40281: LD_INT 3
40283: PUSH
40284: LD_INT 0
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 3
40293: PUSH
40294: LD_INT 1
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 3
40303: PUSH
40304: LD_INT 1
40306: NEG
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PUSH
40312: LD_INT 4
40314: PUSH
40315: LD_INT 0
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 4
40324: PUSH
40325: LD_INT 1
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 4
40334: PUSH
40335: LD_INT 1
40337: NEG
40338: PUSH
40339: EMPTY
40340: LIST
40341: LIST
40342: PUSH
40343: LD_INT 5
40345: PUSH
40346: LD_INT 0
40348: PUSH
40349: EMPTY
40350: LIST
40351: LIST
40352: PUSH
40353: LD_INT 5
40355: PUSH
40356: LD_INT 1
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: PUSH
40363: LD_INT 5
40365: PUSH
40366: LD_INT 1
40368: NEG
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 6
40376: PUSH
40377: LD_INT 0
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: LD_INT 6
40386: PUSH
40387: LD_INT 1
40389: PUSH
40390: EMPTY
40391: LIST
40392: LIST
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: LIST
40405: LIST
40406: LIST
40407: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40408: LD_ADDR_VAR 0 31
40412: PUSH
40413: LD_INT 3
40415: PUSH
40416: LD_INT 2
40418: PUSH
40419: EMPTY
40420: LIST
40421: LIST
40422: PUSH
40423: LD_INT 3
40425: PUSH
40426: LD_INT 3
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 2
40435: PUSH
40436: LD_INT 3
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: PUSH
40443: LD_INT 4
40445: PUSH
40446: LD_INT 3
40448: PUSH
40449: EMPTY
40450: LIST
40451: LIST
40452: PUSH
40453: LD_INT 4
40455: PUSH
40456: LD_INT 4
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: PUSH
40463: LD_INT 3
40465: PUSH
40466: LD_INT 4
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: PUSH
40473: LD_INT 5
40475: PUSH
40476: LD_INT 4
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: LD_INT 5
40485: PUSH
40486: LD_INT 5
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: PUSH
40493: LD_INT 4
40495: PUSH
40496: LD_INT 5
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: PUSH
40503: LD_INT 6
40505: PUSH
40506: LD_INT 5
40508: PUSH
40509: EMPTY
40510: LIST
40511: LIST
40512: PUSH
40513: LD_INT 6
40515: PUSH
40516: LD_INT 6
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: LD_INT 5
40525: PUSH
40526: LD_INT 6
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40547: LD_ADDR_VAR 0 32
40551: PUSH
40552: LD_INT 1
40554: PUSH
40555: LD_INT 3
40557: PUSH
40558: EMPTY
40559: LIST
40560: LIST
40561: PUSH
40562: LD_INT 0
40564: PUSH
40565: LD_INT 3
40567: PUSH
40568: EMPTY
40569: LIST
40570: LIST
40571: PUSH
40572: LD_INT 1
40574: NEG
40575: PUSH
40576: LD_INT 2
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PUSH
40583: LD_INT 1
40585: PUSH
40586: LD_INT 4
40588: PUSH
40589: EMPTY
40590: LIST
40591: LIST
40592: PUSH
40593: LD_INT 0
40595: PUSH
40596: LD_INT 4
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: LD_INT 1
40605: NEG
40606: PUSH
40607: LD_INT 3
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 1
40616: PUSH
40617: LD_INT 5
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 0
40626: PUSH
40627: LD_INT 5
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: LD_INT 1
40636: NEG
40637: PUSH
40638: LD_INT 4
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 1
40647: PUSH
40648: LD_INT 6
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 0
40657: PUSH
40658: LD_INT 6
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 1
40667: NEG
40668: PUSH
40669: LD_INT 5
40671: PUSH
40672: EMPTY
40673: LIST
40674: LIST
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: LIST
40680: LIST
40681: LIST
40682: LIST
40683: LIST
40684: LIST
40685: LIST
40686: LIST
40687: LIST
40688: LIST
40689: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40690: LD_ADDR_VAR 0 33
40694: PUSH
40695: LD_INT 2
40697: NEG
40698: PUSH
40699: LD_INT 1
40701: PUSH
40702: EMPTY
40703: LIST
40704: LIST
40705: PUSH
40706: LD_INT 3
40708: NEG
40709: PUSH
40710: LD_INT 0
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 3
40719: NEG
40720: PUSH
40721: LD_INT 1
40723: NEG
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: PUSH
40729: LD_INT 3
40731: NEG
40732: PUSH
40733: LD_INT 1
40735: PUSH
40736: EMPTY
40737: LIST
40738: LIST
40739: PUSH
40740: LD_INT 4
40742: NEG
40743: PUSH
40744: LD_INT 0
40746: PUSH
40747: EMPTY
40748: LIST
40749: LIST
40750: PUSH
40751: LD_INT 4
40753: NEG
40754: PUSH
40755: LD_INT 1
40757: NEG
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 4
40765: NEG
40766: PUSH
40767: LD_INT 1
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 5
40776: NEG
40777: PUSH
40778: LD_INT 0
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: LD_INT 5
40787: NEG
40788: PUSH
40789: LD_INT 1
40791: NEG
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 5
40799: NEG
40800: PUSH
40801: LD_INT 1
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 6
40810: NEG
40811: PUSH
40812: LD_INT 0
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: PUSH
40819: LD_INT 6
40821: NEG
40822: PUSH
40823: LD_INT 1
40825: NEG
40826: PUSH
40827: EMPTY
40828: LIST
40829: LIST
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: LIST
40835: LIST
40836: LIST
40837: LIST
40838: LIST
40839: LIST
40840: LIST
40841: LIST
40842: LIST
40843: LIST
40844: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40845: LD_ADDR_VAR 0 34
40849: PUSH
40850: LD_INT 2
40852: NEG
40853: PUSH
40854: LD_INT 3
40856: NEG
40857: PUSH
40858: EMPTY
40859: LIST
40860: LIST
40861: PUSH
40862: LD_INT 3
40864: NEG
40865: PUSH
40866: LD_INT 2
40868: NEG
40869: PUSH
40870: EMPTY
40871: LIST
40872: LIST
40873: PUSH
40874: LD_INT 3
40876: NEG
40877: PUSH
40878: LD_INT 3
40880: NEG
40881: PUSH
40882: EMPTY
40883: LIST
40884: LIST
40885: PUSH
40886: LD_INT 3
40888: NEG
40889: PUSH
40890: LD_INT 4
40892: NEG
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: LD_INT 4
40900: NEG
40901: PUSH
40902: LD_INT 3
40904: NEG
40905: PUSH
40906: EMPTY
40907: LIST
40908: LIST
40909: PUSH
40910: LD_INT 4
40912: NEG
40913: PUSH
40914: LD_INT 4
40916: NEG
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: PUSH
40922: LD_INT 4
40924: NEG
40925: PUSH
40926: LD_INT 5
40928: NEG
40929: PUSH
40930: EMPTY
40931: LIST
40932: LIST
40933: PUSH
40934: LD_INT 5
40936: NEG
40937: PUSH
40938: LD_INT 4
40940: NEG
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: PUSH
40946: LD_INT 5
40948: NEG
40949: PUSH
40950: LD_INT 5
40952: NEG
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: PUSH
40958: LD_INT 5
40960: NEG
40961: PUSH
40962: LD_INT 6
40964: NEG
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PUSH
40970: LD_INT 6
40972: NEG
40973: PUSH
40974: LD_INT 5
40976: NEG
40977: PUSH
40978: EMPTY
40979: LIST
40980: LIST
40981: PUSH
40982: LD_INT 6
40984: NEG
40985: PUSH
40986: LD_INT 6
40988: NEG
40989: PUSH
40990: EMPTY
40991: LIST
40992: LIST
40993: PUSH
40994: EMPTY
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41008: LD_ADDR_VAR 0 41
41012: PUSH
41013: LD_INT 0
41015: PUSH
41016: LD_INT 2
41018: NEG
41019: PUSH
41020: EMPTY
41021: LIST
41022: LIST
41023: PUSH
41024: LD_INT 1
41026: NEG
41027: PUSH
41028: LD_INT 3
41030: NEG
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 1
41038: PUSH
41039: LD_INT 2
41041: NEG
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: LIST
41051: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41052: LD_ADDR_VAR 0 42
41056: PUSH
41057: LD_INT 2
41059: PUSH
41060: LD_INT 0
41062: PUSH
41063: EMPTY
41064: LIST
41065: LIST
41066: PUSH
41067: LD_INT 2
41069: PUSH
41070: LD_INT 1
41072: NEG
41073: PUSH
41074: EMPTY
41075: LIST
41076: LIST
41077: PUSH
41078: LD_INT 3
41080: PUSH
41081: LD_INT 1
41083: PUSH
41084: EMPTY
41085: LIST
41086: LIST
41087: PUSH
41088: EMPTY
41089: LIST
41090: LIST
41091: LIST
41092: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41093: LD_ADDR_VAR 0 43
41097: PUSH
41098: LD_INT 2
41100: PUSH
41101: LD_INT 2
41103: PUSH
41104: EMPTY
41105: LIST
41106: LIST
41107: PUSH
41108: LD_INT 3
41110: PUSH
41111: LD_INT 2
41113: PUSH
41114: EMPTY
41115: LIST
41116: LIST
41117: PUSH
41118: LD_INT 2
41120: PUSH
41121: LD_INT 3
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: LIST
41132: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41133: LD_ADDR_VAR 0 44
41137: PUSH
41138: LD_INT 0
41140: PUSH
41141: LD_INT 2
41143: PUSH
41144: EMPTY
41145: LIST
41146: LIST
41147: PUSH
41148: LD_INT 1
41150: PUSH
41151: LD_INT 3
41153: PUSH
41154: EMPTY
41155: LIST
41156: LIST
41157: PUSH
41158: LD_INT 1
41160: NEG
41161: PUSH
41162: LD_INT 2
41164: PUSH
41165: EMPTY
41166: LIST
41167: LIST
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: LIST
41173: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41174: LD_ADDR_VAR 0 45
41178: PUSH
41179: LD_INT 2
41181: NEG
41182: PUSH
41183: LD_INT 0
41185: PUSH
41186: EMPTY
41187: LIST
41188: LIST
41189: PUSH
41190: LD_INT 2
41192: NEG
41193: PUSH
41194: LD_INT 1
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: LD_INT 3
41203: NEG
41204: PUSH
41205: LD_INT 1
41207: NEG
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: LIST
41217: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41218: LD_ADDR_VAR 0 46
41222: PUSH
41223: LD_INT 2
41225: NEG
41226: PUSH
41227: LD_INT 2
41229: NEG
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: LD_INT 2
41237: NEG
41238: PUSH
41239: LD_INT 3
41241: NEG
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 3
41249: NEG
41250: PUSH
41251: LD_INT 2
41253: NEG
41254: PUSH
41255: EMPTY
41256: LIST
41257: LIST
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: LIST
41263: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41264: LD_ADDR_VAR 0 47
41268: PUSH
41269: LD_INT 2
41271: NEG
41272: PUSH
41273: LD_INT 3
41275: NEG
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 1
41283: NEG
41284: PUSH
41285: LD_INT 3
41287: NEG
41288: PUSH
41289: EMPTY
41290: LIST
41291: LIST
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41297: LD_ADDR_VAR 0 48
41301: PUSH
41302: LD_INT 1
41304: PUSH
41305: LD_INT 2
41307: NEG
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: PUSH
41313: LD_INT 2
41315: PUSH
41316: LD_INT 1
41318: NEG
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41328: LD_ADDR_VAR 0 49
41332: PUSH
41333: LD_INT 3
41335: PUSH
41336: LD_INT 1
41338: PUSH
41339: EMPTY
41340: LIST
41341: LIST
41342: PUSH
41343: LD_INT 3
41345: PUSH
41346: LD_INT 2
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41357: LD_ADDR_VAR 0 50
41361: PUSH
41362: LD_INT 2
41364: PUSH
41365: LD_INT 3
41367: PUSH
41368: EMPTY
41369: LIST
41370: LIST
41371: PUSH
41372: LD_INT 1
41374: PUSH
41375: LD_INT 3
41377: PUSH
41378: EMPTY
41379: LIST
41380: LIST
41381: PUSH
41382: EMPTY
41383: LIST
41384: LIST
41385: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41386: LD_ADDR_VAR 0 51
41390: PUSH
41391: LD_INT 1
41393: NEG
41394: PUSH
41395: LD_INT 2
41397: PUSH
41398: EMPTY
41399: LIST
41400: LIST
41401: PUSH
41402: LD_INT 2
41404: NEG
41405: PUSH
41406: LD_INT 1
41408: PUSH
41409: EMPTY
41410: LIST
41411: LIST
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41417: LD_ADDR_VAR 0 52
41421: PUSH
41422: LD_INT 3
41424: NEG
41425: PUSH
41426: LD_INT 1
41428: NEG
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: PUSH
41434: LD_INT 3
41436: NEG
41437: PUSH
41438: LD_INT 2
41440: NEG
41441: PUSH
41442: EMPTY
41443: LIST
41444: LIST
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41450: LD_ADDR_VAR 0 53
41454: PUSH
41455: LD_INT 1
41457: NEG
41458: PUSH
41459: LD_INT 3
41461: NEG
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: LD_INT 0
41469: PUSH
41470: LD_INT 3
41472: NEG
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 1
41480: PUSH
41481: LD_INT 2
41483: NEG
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: EMPTY
41490: LIST
41491: LIST
41492: LIST
41493: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41494: LD_ADDR_VAR 0 54
41498: PUSH
41499: LD_INT 2
41501: PUSH
41502: LD_INT 1
41504: NEG
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: LD_INT 3
41512: PUSH
41513: LD_INT 0
41515: PUSH
41516: EMPTY
41517: LIST
41518: LIST
41519: PUSH
41520: LD_INT 3
41522: PUSH
41523: LD_INT 1
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: LIST
41534: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41535: LD_ADDR_VAR 0 55
41539: PUSH
41540: LD_INT 3
41542: PUSH
41543: LD_INT 2
41545: PUSH
41546: EMPTY
41547: LIST
41548: LIST
41549: PUSH
41550: LD_INT 3
41552: PUSH
41553: LD_INT 3
41555: PUSH
41556: EMPTY
41557: LIST
41558: LIST
41559: PUSH
41560: LD_INT 2
41562: PUSH
41563: LD_INT 3
41565: PUSH
41566: EMPTY
41567: LIST
41568: LIST
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: LIST
41574: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41575: LD_ADDR_VAR 0 56
41579: PUSH
41580: LD_INT 1
41582: PUSH
41583: LD_INT 3
41585: PUSH
41586: EMPTY
41587: LIST
41588: LIST
41589: PUSH
41590: LD_INT 0
41592: PUSH
41593: LD_INT 3
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: PUSH
41600: LD_INT 1
41602: NEG
41603: PUSH
41604: LD_INT 2
41606: PUSH
41607: EMPTY
41608: LIST
41609: LIST
41610: PUSH
41611: EMPTY
41612: LIST
41613: LIST
41614: LIST
41615: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41616: LD_ADDR_VAR 0 57
41620: PUSH
41621: LD_INT 2
41623: NEG
41624: PUSH
41625: LD_INT 1
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: LD_INT 3
41634: NEG
41635: PUSH
41636: LD_INT 0
41638: PUSH
41639: EMPTY
41640: LIST
41641: LIST
41642: PUSH
41643: LD_INT 3
41645: NEG
41646: PUSH
41647: LD_INT 1
41649: NEG
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: LIST
41659: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41660: LD_ADDR_VAR 0 58
41664: PUSH
41665: LD_INT 2
41667: NEG
41668: PUSH
41669: LD_INT 3
41671: NEG
41672: PUSH
41673: EMPTY
41674: LIST
41675: LIST
41676: PUSH
41677: LD_INT 3
41679: NEG
41680: PUSH
41681: LD_INT 2
41683: NEG
41684: PUSH
41685: EMPTY
41686: LIST
41687: LIST
41688: PUSH
41689: LD_INT 3
41691: NEG
41692: PUSH
41693: LD_INT 3
41695: NEG
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: PUSH
41701: EMPTY
41702: LIST
41703: LIST
41704: LIST
41705: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41706: LD_ADDR_VAR 0 59
41710: PUSH
41711: LD_INT 1
41713: NEG
41714: PUSH
41715: LD_INT 2
41717: NEG
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PUSH
41723: LD_INT 0
41725: PUSH
41726: LD_INT 2
41728: NEG
41729: PUSH
41730: EMPTY
41731: LIST
41732: LIST
41733: PUSH
41734: LD_INT 1
41736: PUSH
41737: LD_INT 1
41739: NEG
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: LIST
41749: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41750: LD_ADDR_VAR 0 60
41754: PUSH
41755: LD_INT 1
41757: PUSH
41758: LD_INT 1
41760: NEG
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: PUSH
41766: LD_INT 2
41768: PUSH
41769: LD_INT 0
41771: PUSH
41772: EMPTY
41773: LIST
41774: LIST
41775: PUSH
41776: LD_INT 2
41778: PUSH
41779: LD_INT 1
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: PUSH
41786: EMPTY
41787: LIST
41788: LIST
41789: LIST
41790: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41791: LD_ADDR_VAR 0 61
41795: PUSH
41796: LD_INT 2
41798: PUSH
41799: LD_INT 1
41801: PUSH
41802: EMPTY
41803: LIST
41804: LIST
41805: PUSH
41806: LD_INT 2
41808: PUSH
41809: LD_INT 2
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: LD_INT 1
41818: PUSH
41819: LD_INT 2
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: LIST
41830: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41831: LD_ADDR_VAR 0 62
41835: PUSH
41836: LD_INT 1
41838: PUSH
41839: LD_INT 2
41841: PUSH
41842: EMPTY
41843: LIST
41844: LIST
41845: PUSH
41846: LD_INT 0
41848: PUSH
41849: LD_INT 2
41851: PUSH
41852: EMPTY
41853: LIST
41854: LIST
41855: PUSH
41856: LD_INT 1
41858: NEG
41859: PUSH
41860: LD_INT 1
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PUSH
41867: EMPTY
41868: LIST
41869: LIST
41870: LIST
41871: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41872: LD_ADDR_VAR 0 63
41876: PUSH
41877: LD_INT 1
41879: NEG
41880: PUSH
41881: LD_INT 1
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: PUSH
41888: LD_INT 2
41890: NEG
41891: PUSH
41892: LD_INT 0
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: LD_INT 2
41901: NEG
41902: PUSH
41903: LD_INT 1
41905: NEG
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: LIST
41915: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41916: LD_ADDR_VAR 0 64
41920: PUSH
41921: LD_INT 1
41923: NEG
41924: PUSH
41925: LD_INT 2
41927: NEG
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: LD_INT 2
41935: NEG
41936: PUSH
41937: LD_INT 1
41939: NEG
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: PUSH
41945: LD_INT 2
41947: NEG
41948: PUSH
41949: LD_INT 2
41951: NEG
41952: PUSH
41953: EMPTY
41954: LIST
41955: LIST
41956: PUSH
41957: EMPTY
41958: LIST
41959: LIST
41960: LIST
41961: ST_TO_ADDR
// end ; 2 :
41962: GO 45228
41964: LD_INT 2
41966: DOUBLE
41967: EQUAL
41968: IFTRUE 41972
41970: GO 45227
41972: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41973: LD_ADDR_VAR 0 29
41977: PUSH
41978: LD_INT 4
41980: PUSH
41981: LD_INT 0
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: LD_INT 4
41990: PUSH
41991: LD_INT 1
41993: NEG
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: LD_INT 5
42001: PUSH
42002: LD_INT 0
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 5
42011: PUSH
42012: LD_INT 1
42014: PUSH
42015: EMPTY
42016: LIST
42017: LIST
42018: PUSH
42019: LD_INT 4
42021: PUSH
42022: LD_INT 1
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: LD_INT 3
42031: PUSH
42032: LD_INT 0
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 3
42041: PUSH
42042: LD_INT 1
42044: NEG
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 3
42052: PUSH
42053: LD_INT 2
42055: NEG
42056: PUSH
42057: EMPTY
42058: LIST
42059: LIST
42060: PUSH
42061: LD_INT 5
42063: PUSH
42064: LD_INT 2
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: PUSH
42071: LD_INT 3
42073: PUSH
42074: LD_INT 3
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 3
42083: PUSH
42084: LD_INT 2
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: LD_INT 4
42093: PUSH
42094: LD_INT 3
42096: PUSH
42097: EMPTY
42098: LIST
42099: LIST
42100: PUSH
42101: LD_INT 4
42103: PUSH
42104: LD_INT 4
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 3
42113: PUSH
42114: LD_INT 4
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 2
42123: PUSH
42124: LD_INT 3
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: LD_INT 2
42133: PUSH
42134: LD_INT 2
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 4
42143: PUSH
42144: LD_INT 2
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 2
42153: PUSH
42154: LD_INT 4
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 0
42163: PUSH
42164: LD_INT 4
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 0
42173: PUSH
42174: LD_INT 3
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 1
42183: PUSH
42184: LD_INT 4
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_INT 1
42193: PUSH
42194: LD_INT 5
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 0
42203: PUSH
42204: LD_INT 5
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 1
42213: NEG
42214: PUSH
42215: LD_INT 4
42217: PUSH
42218: EMPTY
42219: LIST
42220: LIST
42221: PUSH
42222: LD_INT 1
42224: NEG
42225: PUSH
42226: LD_INT 3
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 2
42235: PUSH
42236: LD_INT 5
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 2
42245: NEG
42246: PUSH
42247: LD_INT 3
42249: PUSH
42250: EMPTY
42251: LIST
42252: LIST
42253: PUSH
42254: LD_INT 3
42256: NEG
42257: PUSH
42258: LD_INT 0
42260: PUSH
42261: EMPTY
42262: LIST
42263: LIST
42264: PUSH
42265: LD_INT 3
42267: NEG
42268: PUSH
42269: LD_INT 1
42271: NEG
42272: PUSH
42273: EMPTY
42274: LIST
42275: LIST
42276: PUSH
42277: LD_INT 2
42279: NEG
42280: PUSH
42281: LD_INT 0
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: PUSH
42288: LD_INT 2
42290: NEG
42291: PUSH
42292: LD_INT 1
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 3
42301: NEG
42302: PUSH
42303: LD_INT 1
42305: PUSH
42306: EMPTY
42307: LIST
42308: LIST
42309: PUSH
42310: LD_INT 4
42312: NEG
42313: PUSH
42314: LD_INT 0
42316: PUSH
42317: EMPTY
42318: LIST
42319: LIST
42320: PUSH
42321: LD_INT 4
42323: NEG
42324: PUSH
42325: LD_INT 1
42327: NEG
42328: PUSH
42329: EMPTY
42330: LIST
42331: LIST
42332: PUSH
42333: LD_INT 4
42335: NEG
42336: PUSH
42337: LD_INT 2
42339: NEG
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: LD_INT 2
42347: NEG
42348: PUSH
42349: LD_INT 2
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: PUSH
42356: LD_INT 4
42358: NEG
42359: PUSH
42360: LD_INT 4
42362: NEG
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 4
42370: NEG
42371: PUSH
42372: LD_INT 5
42374: NEG
42375: PUSH
42376: EMPTY
42377: LIST
42378: LIST
42379: PUSH
42380: LD_INT 3
42382: NEG
42383: PUSH
42384: LD_INT 4
42386: NEG
42387: PUSH
42388: EMPTY
42389: LIST
42390: LIST
42391: PUSH
42392: LD_INT 3
42394: NEG
42395: PUSH
42396: LD_INT 3
42398: NEG
42399: PUSH
42400: EMPTY
42401: LIST
42402: LIST
42403: PUSH
42404: LD_INT 4
42406: NEG
42407: PUSH
42408: LD_INT 3
42410: NEG
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: PUSH
42416: LD_INT 5
42418: NEG
42419: PUSH
42420: LD_INT 4
42422: NEG
42423: PUSH
42424: EMPTY
42425: LIST
42426: LIST
42427: PUSH
42428: LD_INT 5
42430: NEG
42431: PUSH
42432: LD_INT 5
42434: NEG
42435: PUSH
42436: EMPTY
42437: LIST
42438: LIST
42439: PUSH
42440: LD_INT 3
42442: NEG
42443: PUSH
42444: LD_INT 5
42446: NEG
42447: PUSH
42448: EMPTY
42449: LIST
42450: LIST
42451: PUSH
42452: LD_INT 5
42454: NEG
42455: PUSH
42456: LD_INT 3
42458: NEG
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: LIST
42468: LIST
42469: LIST
42470: LIST
42471: LIST
42472: LIST
42473: LIST
42474: LIST
42475: LIST
42476: LIST
42477: LIST
42478: LIST
42479: LIST
42480: LIST
42481: LIST
42482: LIST
42483: LIST
42484: LIST
42485: LIST
42486: LIST
42487: LIST
42488: LIST
42489: LIST
42490: LIST
42491: LIST
42492: LIST
42493: LIST
42494: LIST
42495: LIST
42496: LIST
42497: LIST
42498: LIST
42499: LIST
42500: LIST
42501: LIST
42502: LIST
42503: LIST
42504: LIST
42505: LIST
42506: LIST
42507: LIST
42508: LIST
42509: LIST
42510: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42511: LD_ADDR_VAR 0 30
42515: PUSH
42516: LD_INT 4
42518: PUSH
42519: LD_INT 4
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 4
42528: PUSH
42529: LD_INT 3
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: PUSH
42536: LD_INT 5
42538: PUSH
42539: LD_INT 4
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PUSH
42546: LD_INT 5
42548: PUSH
42549: LD_INT 5
42551: PUSH
42552: EMPTY
42553: LIST
42554: LIST
42555: PUSH
42556: LD_INT 4
42558: PUSH
42559: LD_INT 5
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: PUSH
42566: LD_INT 3
42568: PUSH
42569: LD_INT 4
42571: PUSH
42572: EMPTY
42573: LIST
42574: LIST
42575: PUSH
42576: LD_INT 3
42578: PUSH
42579: LD_INT 3
42581: PUSH
42582: EMPTY
42583: LIST
42584: LIST
42585: PUSH
42586: LD_INT 5
42588: PUSH
42589: LD_INT 3
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: PUSH
42596: LD_INT 3
42598: PUSH
42599: LD_INT 5
42601: PUSH
42602: EMPTY
42603: LIST
42604: LIST
42605: PUSH
42606: LD_INT 0
42608: PUSH
42609: LD_INT 3
42611: PUSH
42612: EMPTY
42613: LIST
42614: LIST
42615: PUSH
42616: LD_INT 0
42618: PUSH
42619: LD_INT 2
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: PUSH
42626: LD_INT 1
42628: PUSH
42629: LD_INT 3
42631: PUSH
42632: EMPTY
42633: LIST
42634: LIST
42635: PUSH
42636: LD_INT 1
42638: PUSH
42639: LD_INT 4
42641: PUSH
42642: EMPTY
42643: LIST
42644: LIST
42645: PUSH
42646: LD_INT 0
42648: PUSH
42649: LD_INT 4
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PUSH
42656: LD_INT 1
42658: NEG
42659: PUSH
42660: LD_INT 3
42662: PUSH
42663: EMPTY
42664: LIST
42665: LIST
42666: PUSH
42667: LD_INT 1
42669: NEG
42670: PUSH
42671: LD_INT 2
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PUSH
42678: LD_INT 2
42680: PUSH
42681: LD_INT 4
42683: PUSH
42684: EMPTY
42685: LIST
42686: LIST
42687: PUSH
42688: LD_INT 2
42690: NEG
42691: PUSH
42692: LD_INT 2
42694: PUSH
42695: EMPTY
42696: LIST
42697: LIST
42698: PUSH
42699: LD_INT 4
42701: NEG
42702: PUSH
42703: LD_INT 0
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: PUSH
42710: LD_INT 4
42712: NEG
42713: PUSH
42714: LD_INT 1
42716: NEG
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 3
42724: NEG
42725: PUSH
42726: LD_INT 0
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: LD_INT 3
42735: NEG
42736: PUSH
42737: LD_INT 1
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: PUSH
42744: LD_INT 4
42746: NEG
42747: PUSH
42748: LD_INT 1
42750: PUSH
42751: EMPTY
42752: LIST
42753: LIST
42754: PUSH
42755: LD_INT 5
42757: NEG
42758: PUSH
42759: LD_INT 0
42761: PUSH
42762: EMPTY
42763: LIST
42764: LIST
42765: PUSH
42766: LD_INT 5
42768: NEG
42769: PUSH
42770: LD_INT 1
42772: NEG
42773: PUSH
42774: EMPTY
42775: LIST
42776: LIST
42777: PUSH
42778: LD_INT 5
42780: NEG
42781: PUSH
42782: LD_INT 2
42784: NEG
42785: PUSH
42786: EMPTY
42787: LIST
42788: LIST
42789: PUSH
42790: LD_INT 3
42792: NEG
42793: PUSH
42794: LD_INT 2
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: PUSH
42801: LD_INT 3
42803: NEG
42804: PUSH
42805: LD_INT 3
42807: NEG
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: LD_INT 3
42815: NEG
42816: PUSH
42817: LD_INT 4
42819: NEG
42820: PUSH
42821: EMPTY
42822: LIST
42823: LIST
42824: PUSH
42825: LD_INT 2
42827: NEG
42828: PUSH
42829: LD_INT 3
42831: NEG
42832: PUSH
42833: EMPTY
42834: LIST
42835: LIST
42836: PUSH
42837: LD_INT 2
42839: NEG
42840: PUSH
42841: LD_INT 2
42843: NEG
42844: PUSH
42845: EMPTY
42846: LIST
42847: LIST
42848: PUSH
42849: LD_INT 3
42851: NEG
42852: PUSH
42853: LD_INT 2
42855: NEG
42856: PUSH
42857: EMPTY
42858: LIST
42859: LIST
42860: PUSH
42861: LD_INT 4
42863: NEG
42864: PUSH
42865: LD_INT 3
42867: NEG
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: PUSH
42873: LD_INT 4
42875: NEG
42876: PUSH
42877: LD_INT 4
42879: NEG
42880: PUSH
42881: EMPTY
42882: LIST
42883: LIST
42884: PUSH
42885: LD_INT 2
42887: NEG
42888: PUSH
42889: LD_INT 4
42891: NEG
42892: PUSH
42893: EMPTY
42894: LIST
42895: LIST
42896: PUSH
42897: LD_INT 4
42899: NEG
42900: PUSH
42901: LD_INT 2
42903: NEG
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: LD_INT 0
42911: PUSH
42912: LD_INT 4
42914: NEG
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: PUSH
42920: LD_INT 0
42922: PUSH
42923: LD_INT 5
42925: NEG
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: PUSH
42931: LD_INT 1
42933: PUSH
42934: LD_INT 4
42936: NEG
42937: PUSH
42938: EMPTY
42939: LIST
42940: LIST
42941: PUSH
42942: LD_INT 1
42944: PUSH
42945: LD_INT 3
42947: NEG
42948: PUSH
42949: EMPTY
42950: LIST
42951: LIST
42952: PUSH
42953: LD_INT 0
42955: PUSH
42956: LD_INT 3
42958: NEG
42959: PUSH
42960: EMPTY
42961: LIST
42962: LIST
42963: PUSH
42964: LD_INT 1
42966: NEG
42967: PUSH
42968: LD_INT 4
42970: NEG
42971: PUSH
42972: EMPTY
42973: LIST
42974: LIST
42975: PUSH
42976: LD_INT 1
42978: NEG
42979: PUSH
42980: LD_INT 5
42982: NEG
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: PUSH
42988: LD_INT 2
42990: PUSH
42991: LD_INT 3
42993: NEG
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: LD_INT 2
43001: NEG
43002: PUSH
43003: LD_INT 5
43005: NEG
43006: PUSH
43007: EMPTY
43008: LIST
43009: LIST
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: LIST
43015: LIST
43016: LIST
43017: LIST
43018: LIST
43019: LIST
43020: LIST
43021: LIST
43022: LIST
43023: LIST
43024: LIST
43025: LIST
43026: LIST
43027: LIST
43028: LIST
43029: LIST
43030: LIST
43031: LIST
43032: LIST
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: LIST
43043: LIST
43044: LIST
43045: LIST
43046: LIST
43047: LIST
43048: LIST
43049: LIST
43050: LIST
43051: LIST
43052: LIST
43053: LIST
43054: LIST
43055: LIST
43056: LIST
43057: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43058: LD_ADDR_VAR 0 31
43062: PUSH
43063: LD_INT 0
43065: PUSH
43066: LD_INT 4
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: PUSH
43073: LD_INT 0
43075: PUSH
43076: LD_INT 3
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 1
43085: PUSH
43086: LD_INT 4
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 1
43095: PUSH
43096: LD_INT 5
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: LD_INT 0
43105: PUSH
43106: LD_INT 5
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: LD_INT 1
43115: NEG
43116: PUSH
43117: LD_INT 4
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 1
43126: NEG
43127: PUSH
43128: LD_INT 3
43130: PUSH
43131: EMPTY
43132: LIST
43133: LIST
43134: PUSH
43135: LD_INT 2
43137: PUSH
43138: LD_INT 5
43140: PUSH
43141: EMPTY
43142: LIST
43143: LIST
43144: PUSH
43145: LD_INT 2
43147: NEG
43148: PUSH
43149: LD_INT 3
43151: PUSH
43152: EMPTY
43153: LIST
43154: LIST
43155: PUSH
43156: LD_INT 3
43158: NEG
43159: PUSH
43160: LD_INT 0
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 3
43169: NEG
43170: PUSH
43171: LD_INT 1
43173: NEG
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: LD_INT 2
43181: NEG
43182: PUSH
43183: LD_INT 0
43185: PUSH
43186: EMPTY
43187: LIST
43188: LIST
43189: PUSH
43190: LD_INT 2
43192: NEG
43193: PUSH
43194: LD_INT 1
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PUSH
43201: LD_INT 3
43203: NEG
43204: PUSH
43205: LD_INT 1
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: PUSH
43212: LD_INT 4
43214: NEG
43215: PUSH
43216: LD_INT 0
43218: PUSH
43219: EMPTY
43220: LIST
43221: LIST
43222: PUSH
43223: LD_INT 4
43225: NEG
43226: PUSH
43227: LD_INT 1
43229: NEG
43230: PUSH
43231: EMPTY
43232: LIST
43233: LIST
43234: PUSH
43235: LD_INT 4
43237: NEG
43238: PUSH
43239: LD_INT 2
43241: NEG
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PUSH
43247: LD_INT 2
43249: NEG
43250: PUSH
43251: LD_INT 2
43253: PUSH
43254: EMPTY
43255: LIST
43256: LIST
43257: PUSH
43258: LD_INT 4
43260: NEG
43261: PUSH
43262: LD_INT 4
43264: NEG
43265: PUSH
43266: EMPTY
43267: LIST
43268: LIST
43269: PUSH
43270: LD_INT 4
43272: NEG
43273: PUSH
43274: LD_INT 5
43276: NEG
43277: PUSH
43278: EMPTY
43279: LIST
43280: LIST
43281: PUSH
43282: LD_INT 3
43284: NEG
43285: PUSH
43286: LD_INT 4
43288: NEG
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: PUSH
43294: LD_INT 3
43296: NEG
43297: PUSH
43298: LD_INT 3
43300: NEG
43301: PUSH
43302: EMPTY
43303: LIST
43304: LIST
43305: PUSH
43306: LD_INT 4
43308: NEG
43309: PUSH
43310: LD_INT 3
43312: NEG
43313: PUSH
43314: EMPTY
43315: LIST
43316: LIST
43317: PUSH
43318: LD_INT 5
43320: NEG
43321: PUSH
43322: LD_INT 4
43324: NEG
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 5
43332: NEG
43333: PUSH
43334: LD_INT 5
43336: NEG
43337: PUSH
43338: EMPTY
43339: LIST
43340: LIST
43341: PUSH
43342: LD_INT 3
43344: NEG
43345: PUSH
43346: LD_INT 5
43348: NEG
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 5
43356: NEG
43357: PUSH
43358: LD_INT 3
43360: NEG
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: PUSH
43366: LD_INT 0
43368: PUSH
43369: LD_INT 3
43371: NEG
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 0
43379: PUSH
43380: LD_INT 4
43382: NEG
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: PUSH
43388: LD_INT 1
43390: PUSH
43391: LD_INT 3
43393: NEG
43394: PUSH
43395: EMPTY
43396: LIST
43397: LIST
43398: PUSH
43399: LD_INT 1
43401: PUSH
43402: LD_INT 2
43404: NEG
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: PUSH
43410: LD_INT 0
43412: PUSH
43413: LD_INT 2
43415: NEG
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: PUSH
43421: LD_INT 1
43423: NEG
43424: PUSH
43425: LD_INT 3
43427: NEG
43428: PUSH
43429: EMPTY
43430: LIST
43431: LIST
43432: PUSH
43433: LD_INT 1
43435: NEG
43436: PUSH
43437: LD_INT 4
43439: NEG
43440: PUSH
43441: EMPTY
43442: LIST
43443: LIST
43444: PUSH
43445: LD_INT 2
43447: PUSH
43448: LD_INT 2
43450: NEG
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 2
43458: NEG
43459: PUSH
43460: LD_INT 4
43462: NEG
43463: PUSH
43464: EMPTY
43465: LIST
43466: LIST
43467: PUSH
43468: LD_INT 4
43470: PUSH
43471: LD_INT 0
43473: PUSH
43474: EMPTY
43475: LIST
43476: LIST
43477: PUSH
43478: LD_INT 4
43480: PUSH
43481: LD_INT 1
43483: NEG
43484: PUSH
43485: EMPTY
43486: LIST
43487: LIST
43488: PUSH
43489: LD_INT 5
43491: PUSH
43492: LD_INT 0
43494: PUSH
43495: EMPTY
43496: LIST
43497: LIST
43498: PUSH
43499: LD_INT 5
43501: PUSH
43502: LD_INT 1
43504: PUSH
43505: EMPTY
43506: LIST
43507: LIST
43508: PUSH
43509: LD_INT 4
43511: PUSH
43512: LD_INT 1
43514: PUSH
43515: EMPTY
43516: LIST
43517: LIST
43518: PUSH
43519: LD_INT 3
43521: PUSH
43522: LD_INT 0
43524: PUSH
43525: EMPTY
43526: LIST
43527: LIST
43528: PUSH
43529: LD_INT 3
43531: PUSH
43532: LD_INT 1
43534: NEG
43535: PUSH
43536: EMPTY
43537: LIST
43538: LIST
43539: PUSH
43540: LD_INT 3
43542: PUSH
43543: LD_INT 2
43545: NEG
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 5
43553: PUSH
43554: LD_INT 2
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: EMPTY
43562: LIST
43563: LIST
43564: LIST
43565: LIST
43566: LIST
43567: LIST
43568: LIST
43569: LIST
43570: LIST
43571: LIST
43572: LIST
43573: LIST
43574: LIST
43575: LIST
43576: LIST
43577: LIST
43578: LIST
43579: LIST
43580: LIST
43581: LIST
43582: LIST
43583: LIST
43584: LIST
43585: LIST
43586: LIST
43587: LIST
43588: LIST
43589: LIST
43590: LIST
43591: LIST
43592: LIST
43593: LIST
43594: LIST
43595: LIST
43596: LIST
43597: LIST
43598: LIST
43599: LIST
43600: LIST
43601: LIST
43602: LIST
43603: LIST
43604: LIST
43605: LIST
43606: LIST
43607: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43608: LD_ADDR_VAR 0 32
43612: PUSH
43613: LD_INT 4
43615: NEG
43616: PUSH
43617: LD_INT 0
43619: PUSH
43620: EMPTY
43621: LIST
43622: LIST
43623: PUSH
43624: LD_INT 4
43626: NEG
43627: PUSH
43628: LD_INT 1
43630: NEG
43631: PUSH
43632: EMPTY
43633: LIST
43634: LIST
43635: PUSH
43636: LD_INT 3
43638: NEG
43639: PUSH
43640: LD_INT 0
43642: PUSH
43643: EMPTY
43644: LIST
43645: LIST
43646: PUSH
43647: LD_INT 3
43649: NEG
43650: PUSH
43651: LD_INT 1
43653: PUSH
43654: EMPTY
43655: LIST
43656: LIST
43657: PUSH
43658: LD_INT 4
43660: NEG
43661: PUSH
43662: LD_INT 1
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: PUSH
43669: LD_INT 5
43671: NEG
43672: PUSH
43673: LD_INT 0
43675: PUSH
43676: EMPTY
43677: LIST
43678: LIST
43679: PUSH
43680: LD_INT 5
43682: NEG
43683: PUSH
43684: LD_INT 1
43686: NEG
43687: PUSH
43688: EMPTY
43689: LIST
43690: LIST
43691: PUSH
43692: LD_INT 5
43694: NEG
43695: PUSH
43696: LD_INT 2
43698: NEG
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 3
43706: NEG
43707: PUSH
43708: LD_INT 2
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: PUSH
43715: LD_INT 3
43717: NEG
43718: PUSH
43719: LD_INT 3
43721: NEG
43722: PUSH
43723: EMPTY
43724: LIST
43725: LIST
43726: PUSH
43727: LD_INT 3
43729: NEG
43730: PUSH
43731: LD_INT 4
43733: NEG
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: PUSH
43739: LD_INT 2
43741: NEG
43742: PUSH
43743: LD_INT 3
43745: NEG
43746: PUSH
43747: EMPTY
43748: LIST
43749: LIST
43750: PUSH
43751: LD_INT 2
43753: NEG
43754: PUSH
43755: LD_INT 2
43757: NEG
43758: PUSH
43759: EMPTY
43760: LIST
43761: LIST
43762: PUSH
43763: LD_INT 3
43765: NEG
43766: PUSH
43767: LD_INT 2
43769: NEG
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: LD_INT 4
43777: NEG
43778: PUSH
43779: LD_INT 3
43781: NEG
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: PUSH
43787: LD_INT 4
43789: NEG
43790: PUSH
43791: LD_INT 4
43793: NEG
43794: PUSH
43795: EMPTY
43796: LIST
43797: LIST
43798: PUSH
43799: LD_INT 2
43801: NEG
43802: PUSH
43803: LD_INT 4
43805: NEG
43806: PUSH
43807: EMPTY
43808: LIST
43809: LIST
43810: PUSH
43811: LD_INT 4
43813: NEG
43814: PUSH
43815: LD_INT 2
43817: NEG
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PUSH
43823: LD_INT 0
43825: PUSH
43826: LD_INT 4
43828: NEG
43829: PUSH
43830: EMPTY
43831: LIST
43832: LIST
43833: PUSH
43834: LD_INT 0
43836: PUSH
43837: LD_INT 5
43839: NEG
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PUSH
43845: LD_INT 1
43847: PUSH
43848: LD_INT 4
43850: NEG
43851: PUSH
43852: EMPTY
43853: LIST
43854: LIST
43855: PUSH
43856: LD_INT 1
43858: PUSH
43859: LD_INT 3
43861: NEG
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 0
43869: PUSH
43870: LD_INT 3
43872: NEG
43873: PUSH
43874: EMPTY
43875: LIST
43876: LIST
43877: PUSH
43878: LD_INT 1
43880: NEG
43881: PUSH
43882: LD_INT 4
43884: NEG
43885: PUSH
43886: EMPTY
43887: LIST
43888: LIST
43889: PUSH
43890: LD_INT 1
43892: NEG
43893: PUSH
43894: LD_INT 5
43896: NEG
43897: PUSH
43898: EMPTY
43899: LIST
43900: LIST
43901: PUSH
43902: LD_INT 2
43904: PUSH
43905: LD_INT 3
43907: NEG
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: LD_INT 2
43915: NEG
43916: PUSH
43917: LD_INT 5
43919: NEG
43920: PUSH
43921: EMPTY
43922: LIST
43923: LIST
43924: PUSH
43925: LD_INT 3
43927: PUSH
43928: LD_INT 0
43930: PUSH
43931: EMPTY
43932: LIST
43933: LIST
43934: PUSH
43935: LD_INT 3
43937: PUSH
43938: LD_INT 1
43940: NEG
43941: PUSH
43942: EMPTY
43943: LIST
43944: LIST
43945: PUSH
43946: LD_INT 4
43948: PUSH
43949: LD_INT 0
43951: PUSH
43952: EMPTY
43953: LIST
43954: LIST
43955: PUSH
43956: LD_INT 4
43958: PUSH
43959: LD_INT 1
43961: PUSH
43962: EMPTY
43963: LIST
43964: LIST
43965: PUSH
43966: LD_INT 3
43968: PUSH
43969: LD_INT 1
43971: PUSH
43972: EMPTY
43973: LIST
43974: LIST
43975: PUSH
43976: LD_INT 2
43978: PUSH
43979: LD_INT 0
43981: PUSH
43982: EMPTY
43983: LIST
43984: LIST
43985: PUSH
43986: LD_INT 2
43988: PUSH
43989: LD_INT 1
43991: NEG
43992: PUSH
43993: EMPTY
43994: LIST
43995: LIST
43996: PUSH
43997: LD_INT 2
43999: PUSH
44000: LD_INT 2
44002: NEG
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: LD_INT 4
44010: PUSH
44011: LD_INT 2
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: LD_INT 4
44020: PUSH
44021: LD_INT 4
44023: PUSH
44024: EMPTY
44025: LIST
44026: LIST
44027: PUSH
44028: LD_INT 4
44030: PUSH
44031: LD_INT 3
44033: PUSH
44034: EMPTY
44035: LIST
44036: LIST
44037: PUSH
44038: LD_INT 5
44040: PUSH
44041: LD_INT 4
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 5
44050: PUSH
44051: LD_INT 5
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 4
44060: PUSH
44061: LD_INT 5
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: LD_INT 3
44070: PUSH
44071: LD_INT 4
44073: PUSH
44074: EMPTY
44075: LIST
44076: LIST
44077: PUSH
44078: LD_INT 3
44080: PUSH
44081: LD_INT 3
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PUSH
44088: LD_INT 5
44090: PUSH
44091: LD_INT 3
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 3
44100: PUSH
44101: LD_INT 5
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: LIST
44112: LIST
44113: LIST
44114: LIST
44115: LIST
44116: LIST
44117: LIST
44118: LIST
44119: LIST
44120: LIST
44121: LIST
44122: LIST
44123: LIST
44124: LIST
44125: LIST
44126: LIST
44127: LIST
44128: LIST
44129: LIST
44130: LIST
44131: LIST
44132: LIST
44133: LIST
44134: LIST
44135: LIST
44136: LIST
44137: LIST
44138: LIST
44139: LIST
44140: LIST
44141: LIST
44142: LIST
44143: LIST
44144: LIST
44145: LIST
44146: LIST
44147: LIST
44148: LIST
44149: LIST
44150: LIST
44151: LIST
44152: LIST
44153: LIST
44154: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44155: LD_ADDR_VAR 0 33
44159: PUSH
44160: LD_INT 4
44162: NEG
44163: PUSH
44164: LD_INT 4
44166: NEG
44167: PUSH
44168: EMPTY
44169: LIST
44170: LIST
44171: PUSH
44172: LD_INT 4
44174: NEG
44175: PUSH
44176: LD_INT 5
44178: NEG
44179: PUSH
44180: EMPTY
44181: LIST
44182: LIST
44183: PUSH
44184: LD_INT 3
44186: NEG
44187: PUSH
44188: LD_INT 4
44190: NEG
44191: PUSH
44192: EMPTY
44193: LIST
44194: LIST
44195: PUSH
44196: LD_INT 3
44198: NEG
44199: PUSH
44200: LD_INT 3
44202: NEG
44203: PUSH
44204: EMPTY
44205: LIST
44206: LIST
44207: PUSH
44208: LD_INT 4
44210: NEG
44211: PUSH
44212: LD_INT 3
44214: NEG
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 5
44222: NEG
44223: PUSH
44224: LD_INT 4
44226: NEG
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 5
44234: NEG
44235: PUSH
44236: LD_INT 5
44238: NEG
44239: PUSH
44240: EMPTY
44241: LIST
44242: LIST
44243: PUSH
44244: LD_INT 3
44246: NEG
44247: PUSH
44248: LD_INT 5
44250: NEG
44251: PUSH
44252: EMPTY
44253: LIST
44254: LIST
44255: PUSH
44256: LD_INT 5
44258: NEG
44259: PUSH
44260: LD_INT 3
44262: NEG
44263: PUSH
44264: EMPTY
44265: LIST
44266: LIST
44267: PUSH
44268: LD_INT 0
44270: PUSH
44271: LD_INT 3
44273: NEG
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: PUSH
44279: LD_INT 0
44281: PUSH
44282: LD_INT 4
44284: NEG
44285: PUSH
44286: EMPTY
44287: LIST
44288: LIST
44289: PUSH
44290: LD_INT 1
44292: PUSH
44293: LD_INT 3
44295: NEG
44296: PUSH
44297: EMPTY
44298: LIST
44299: LIST
44300: PUSH
44301: LD_INT 1
44303: PUSH
44304: LD_INT 2
44306: NEG
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: PUSH
44312: LD_INT 0
44314: PUSH
44315: LD_INT 2
44317: NEG
44318: PUSH
44319: EMPTY
44320: LIST
44321: LIST
44322: PUSH
44323: LD_INT 1
44325: NEG
44326: PUSH
44327: LD_INT 3
44329: NEG
44330: PUSH
44331: EMPTY
44332: LIST
44333: LIST
44334: PUSH
44335: LD_INT 1
44337: NEG
44338: PUSH
44339: LD_INT 4
44341: NEG
44342: PUSH
44343: EMPTY
44344: LIST
44345: LIST
44346: PUSH
44347: LD_INT 2
44349: PUSH
44350: LD_INT 2
44352: NEG
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 2
44360: NEG
44361: PUSH
44362: LD_INT 4
44364: NEG
44365: PUSH
44366: EMPTY
44367: LIST
44368: LIST
44369: PUSH
44370: LD_INT 4
44372: PUSH
44373: LD_INT 0
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: LD_INT 4
44382: PUSH
44383: LD_INT 1
44385: NEG
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: LD_INT 5
44393: PUSH
44394: LD_INT 0
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 5
44403: PUSH
44404: LD_INT 1
44406: PUSH
44407: EMPTY
44408: LIST
44409: LIST
44410: PUSH
44411: LD_INT 4
44413: PUSH
44414: LD_INT 1
44416: PUSH
44417: EMPTY
44418: LIST
44419: LIST
44420: PUSH
44421: LD_INT 3
44423: PUSH
44424: LD_INT 0
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: PUSH
44431: LD_INT 3
44433: PUSH
44434: LD_INT 1
44436: NEG
44437: PUSH
44438: EMPTY
44439: LIST
44440: LIST
44441: PUSH
44442: LD_INT 3
44444: PUSH
44445: LD_INT 2
44447: NEG
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: LD_INT 5
44455: PUSH
44456: LD_INT 2
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 3
44465: PUSH
44466: LD_INT 3
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 3
44475: PUSH
44476: LD_INT 2
44478: PUSH
44479: EMPTY
44480: LIST
44481: LIST
44482: PUSH
44483: LD_INT 4
44485: PUSH
44486: LD_INT 3
44488: PUSH
44489: EMPTY
44490: LIST
44491: LIST
44492: PUSH
44493: LD_INT 4
44495: PUSH
44496: LD_INT 4
44498: PUSH
44499: EMPTY
44500: LIST
44501: LIST
44502: PUSH
44503: LD_INT 3
44505: PUSH
44506: LD_INT 4
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: LD_INT 2
44515: PUSH
44516: LD_INT 3
44518: PUSH
44519: EMPTY
44520: LIST
44521: LIST
44522: PUSH
44523: LD_INT 2
44525: PUSH
44526: LD_INT 2
44528: PUSH
44529: EMPTY
44530: LIST
44531: LIST
44532: PUSH
44533: LD_INT 4
44535: PUSH
44536: LD_INT 2
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: PUSH
44543: LD_INT 2
44545: PUSH
44546: LD_INT 4
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: PUSH
44553: LD_INT 0
44555: PUSH
44556: LD_INT 4
44558: PUSH
44559: EMPTY
44560: LIST
44561: LIST
44562: PUSH
44563: LD_INT 0
44565: PUSH
44566: LD_INT 3
44568: PUSH
44569: EMPTY
44570: LIST
44571: LIST
44572: PUSH
44573: LD_INT 1
44575: PUSH
44576: LD_INT 4
44578: PUSH
44579: EMPTY
44580: LIST
44581: LIST
44582: PUSH
44583: LD_INT 1
44585: PUSH
44586: LD_INT 5
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 0
44595: PUSH
44596: LD_INT 5
44598: PUSH
44599: EMPTY
44600: LIST
44601: LIST
44602: PUSH
44603: LD_INT 1
44605: NEG
44606: PUSH
44607: LD_INT 4
44609: PUSH
44610: EMPTY
44611: LIST
44612: LIST
44613: PUSH
44614: LD_INT 1
44616: NEG
44617: PUSH
44618: LD_INT 3
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: PUSH
44625: LD_INT 2
44627: PUSH
44628: LD_INT 5
44630: PUSH
44631: EMPTY
44632: LIST
44633: LIST
44634: PUSH
44635: LD_INT 2
44637: NEG
44638: PUSH
44639: LD_INT 3
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: LIST
44650: LIST
44651: LIST
44652: LIST
44653: LIST
44654: LIST
44655: LIST
44656: LIST
44657: LIST
44658: LIST
44659: LIST
44660: LIST
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: LIST
44669: LIST
44670: LIST
44671: LIST
44672: LIST
44673: LIST
44674: LIST
44675: LIST
44676: LIST
44677: LIST
44678: LIST
44679: LIST
44680: LIST
44681: LIST
44682: LIST
44683: LIST
44684: LIST
44685: LIST
44686: LIST
44687: LIST
44688: LIST
44689: LIST
44690: LIST
44691: LIST
44692: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44693: LD_ADDR_VAR 0 34
44697: PUSH
44698: LD_INT 0
44700: PUSH
44701: LD_INT 4
44703: NEG
44704: PUSH
44705: EMPTY
44706: LIST
44707: LIST
44708: PUSH
44709: LD_INT 0
44711: PUSH
44712: LD_INT 5
44714: NEG
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: PUSH
44720: LD_INT 1
44722: PUSH
44723: LD_INT 4
44725: NEG
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: LD_INT 1
44733: PUSH
44734: LD_INT 3
44736: NEG
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: PUSH
44742: LD_INT 0
44744: PUSH
44745: LD_INT 3
44747: NEG
44748: PUSH
44749: EMPTY
44750: LIST
44751: LIST
44752: PUSH
44753: LD_INT 1
44755: NEG
44756: PUSH
44757: LD_INT 4
44759: NEG
44760: PUSH
44761: EMPTY
44762: LIST
44763: LIST
44764: PUSH
44765: LD_INT 1
44767: NEG
44768: PUSH
44769: LD_INT 5
44771: NEG
44772: PUSH
44773: EMPTY
44774: LIST
44775: LIST
44776: PUSH
44777: LD_INT 2
44779: PUSH
44780: LD_INT 3
44782: NEG
44783: PUSH
44784: EMPTY
44785: LIST
44786: LIST
44787: PUSH
44788: LD_INT 2
44790: NEG
44791: PUSH
44792: LD_INT 5
44794: NEG
44795: PUSH
44796: EMPTY
44797: LIST
44798: LIST
44799: PUSH
44800: LD_INT 3
44802: PUSH
44803: LD_INT 0
44805: PUSH
44806: EMPTY
44807: LIST
44808: LIST
44809: PUSH
44810: LD_INT 3
44812: PUSH
44813: LD_INT 1
44815: NEG
44816: PUSH
44817: EMPTY
44818: LIST
44819: LIST
44820: PUSH
44821: LD_INT 4
44823: PUSH
44824: LD_INT 0
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PUSH
44831: LD_INT 4
44833: PUSH
44834: LD_INT 1
44836: PUSH
44837: EMPTY
44838: LIST
44839: LIST
44840: PUSH
44841: LD_INT 3
44843: PUSH
44844: LD_INT 1
44846: PUSH
44847: EMPTY
44848: LIST
44849: LIST
44850: PUSH
44851: LD_INT 2
44853: PUSH
44854: LD_INT 0
44856: PUSH
44857: EMPTY
44858: LIST
44859: LIST
44860: PUSH
44861: LD_INT 2
44863: PUSH
44864: LD_INT 1
44866: NEG
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: LD_INT 2
44874: PUSH
44875: LD_INT 2
44877: NEG
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: PUSH
44883: LD_INT 4
44885: PUSH
44886: LD_INT 2
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 4
44895: PUSH
44896: LD_INT 4
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 4
44905: PUSH
44906: LD_INT 3
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 5
44915: PUSH
44916: LD_INT 4
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: PUSH
44923: LD_INT 5
44925: PUSH
44926: LD_INT 5
44928: PUSH
44929: EMPTY
44930: LIST
44931: LIST
44932: PUSH
44933: LD_INT 4
44935: PUSH
44936: LD_INT 5
44938: PUSH
44939: EMPTY
44940: LIST
44941: LIST
44942: PUSH
44943: LD_INT 3
44945: PUSH
44946: LD_INT 4
44948: PUSH
44949: EMPTY
44950: LIST
44951: LIST
44952: PUSH
44953: LD_INT 3
44955: PUSH
44956: LD_INT 3
44958: PUSH
44959: EMPTY
44960: LIST
44961: LIST
44962: PUSH
44963: LD_INT 5
44965: PUSH
44966: LD_INT 3
44968: PUSH
44969: EMPTY
44970: LIST
44971: LIST
44972: PUSH
44973: LD_INT 3
44975: PUSH
44976: LD_INT 5
44978: PUSH
44979: EMPTY
44980: LIST
44981: LIST
44982: PUSH
44983: LD_INT 0
44985: PUSH
44986: LD_INT 3
44988: PUSH
44989: EMPTY
44990: LIST
44991: LIST
44992: PUSH
44993: LD_INT 0
44995: PUSH
44996: LD_INT 2
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: LD_INT 1
45005: PUSH
45006: LD_INT 3
45008: PUSH
45009: EMPTY
45010: LIST
45011: LIST
45012: PUSH
45013: LD_INT 1
45015: PUSH
45016: LD_INT 4
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PUSH
45023: LD_INT 0
45025: PUSH
45026: LD_INT 4
45028: PUSH
45029: EMPTY
45030: LIST
45031: LIST
45032: PUSH
45033: LD_INT 1
45035: NEG
45036: PUSH
45037: LD_INT 3
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: LD_INT 1
45046: NEG
45047: PUSH
45048: LD_INT 2
45050: PUSH
45051: EMPTY
45052: LIST
45053: LIST
45054: PUSH
45055: LD_INT 2
45057: PUSH
45058: LD_INT 4
45060: PUSH
45061: EMPTY
45062: LIST
45063: LIST
45064: PUSH
45065: LD_INT 2
45067: NEG
45068: PUSH
45069: LD_INT 2
45071: PUSH
45072: EMPTY
45073: LIST
45074: LIST
45075: PUSH
45076: LD_INT 4
45078: NEG
45079: PUSH
45080: LD_INT 0
45082: PUSH
45083: EMPTY
45084: LIST
45085: LIST
45086: PUSH
45087: LD_INT 4
45089: NEG
45090: PUSH
45091: LD_INT 1
45093: NEG
45094: PUSH
45095: EMPTY
45096: LIST
45097: LIST
45098: PUSH
45099: LD_INT 3
45101: NEG
45102: PUSH
45103: LD_INT 0
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: PUSH
45110: LD_INT 3
45112: NEG
45113: PUSH
45114: LD_INT 1
45116: PUSH
45117: EMPTY
45118: LIST
45119: LIST
45120: PUSH
45121: LD_INT 4
45123: NEG
45124: PUSH
45125: LD_INT 1
45127: PUSH
45128: EMPTY
45129: LIST
45130: LIST
45131: PUSH
45132: LD_INT 5
45134: NEG
45135: PUSH
45136: LD_INT 0
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: PUSH
45143: LD_INT 5
45145: NEG
45146: PUSH
45147: LD_INT 1
45149: NEG
45150: PUSH
45151: EMPTY
45152: LIST
45153: LIST
45154: PUSH
45155: LD_INT 5
45157: NEG
45158: PUSH
45159: LD_INT 2
45161: NEG
45162: PUSH
45163: EMPTY
45164: LIST
45165: LIST
45166: PUSH
45167: LD_INT 3
45169: NEG
45170: PUSH
45171: LD_INT 2
45173: PUSH
45174: EMPTY
45175: LIST
45176: LIST
45177: PUSH
45178: EMPTY
45179: LIST
45180: LIST
45181: LIST
45182: LIST
45183: LIST
45184: LIST
45185: LIST
45186: LIST
45187: LIST
45188: LIST
45189: LIST
45190: LIST
45191: LIST
45192: LIST
45193: LIST
45194: LIST
45195: LIST
45196: LIST
45197: LIST
45198: LIST
45199: LIST
45200: LIST
45201: LIST
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: LIST
45219: LIST
45220: LIST
45221: LIST
45222: LIST
45223: LIST
45224: ST_TO_ADDR
// end ; end ;
45225: GO 45228
45227: POP
// case btype of b_depot , b_warehouse :
45228: LD_VAR 0 1
45232: PUSH
45233: LD_INT 0
45235: DOUBLE
45236: EQUAL
45237: IFTRUE 45247
45239: LD_INT 1
45241: DOUBLE
45242: EQUAL
45243: IFTRUE 45247
45245: GO 45448
45247: POP
// case nation of nation_american :
45248: LD_VAR 0 5
45252: PUSH
45253: LD_INT 1
45255: DOUBLE
45256: EQUAL
45257: IFTRUE 45261
45259: GO 45317
45261: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
45262: LD_ADDR_VAR 0 9
45266: PUSH
45267: LD_VAR 0 11
45271: PUSH
45272: LD_VAR 0 12
45276: PUSH
45277: LD_VAR 0 13
45281: PUSH
45282: LD_VAR 0 14
45286: PUSH
45287: LD_VAR 0 15
45291: PUSH
45292: LD_VAR 0 16
45296: PUSH
45297: EMPTY
45298: LIST
45299: LIST
45300: LIST
45301: LIST
45302: LIST
45303: LIST
45304: PUSH
45305: LD_VAR 0 4
45309: PUSH
45310: LD_INT 1
45312: PLUS
45313: ARRAY
45314: ST_TO_ADDR
45315: GO 45446
45317: LD_INT 2
45319: DOUBLE
45320: EQUAL
45321: IFTRUE 45325
45323: GO 45381
45325: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
45326: LD_ADDR_VAR 0 9
45330: PUSH
45331: LD_VAR 0 17
45335: PUSH
45336: LD_VAR 0 18
45340: PUSH
45341: LD_VAR 0 19
45345: PUSH
45346: LD_VAR 0 20
45350: PUSH
45351: LD_VAR 0 21
45355: PUSH
45356: LD_VAR 0 22
45360: PUSH
45361: EMPTY
45362: LIST
45363: LIST
45364: LIST
45365: LIST
45366: LIST
45367: LIST
45368: PUSH
45369: LD_VAR 0 4
45373: PUSH
45374: LD_INT 1
45376: PLUS
45377: ARRAY
45378: ST_TO_ADDR
45379: GO 45446
45381: LD_INT 3
45383: DOUBLE
45384: EQUAL
45385: IFTRUE 45389
45387: GO 45445
45389: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45390: LD_ADDR_VAR 0 9
45394: PUSH
45395: LD_VAR 0 23
45399: PUSH
45400: LD_VAR 0 24
45404: PUSH
45405: LD_VAR 0 25
45409: PUSH
45410: LD_VAR 0 26
45414: PUSH
45415: LD_VAR 0 27
45419: PUSH
45420: LD_VAR 0 28
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: LIST
45429: LIST
45430: LIST
45431: LIST
45432: PUSH
45433: LD_VAR 0 4
45437: PUSH
45438: LD_INT 1
45440: PLUS
45441: ARRAY
45442: ST_TO_ADDR
45443: GO 45446
45445: POP
45446: GO 46001
45448: LD_INT 2
45450: DOUBLE
45451: EQUAL
45452: IFTRUE 45462
45454: LD_INT 3
45456: DOUBLE
45457: EQUAL
45458: IFTRUE 45462
45460: GO 45518
45462: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45463: LD_ADDR_VAR 0 9
45467: PUSH
45468: LD_VAR 0 29
45472: PUSH
45473: LD_VAR 0 30
45477: PUSH
45478: LD_VAR 0 31
45482: PUSH
45483: LD_VAR 0 32
45487: PUSH
45488: LD_VAR 0 33
45492: PUSH
45493: LD_VAR 0 34
45497: PUSH
45498: EMPTY
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: PUSH
45506: LD_VAR 0 4
45510: PUSH
45511: LD_INT 1
45513: PLUS
45514: ARRAY
45515: ST_TO_ADDR
45516: GO 46001
45518: LD_INT 16
45520: DOUBLE
45521: EQUAL
45522: IFTRUE 45580
45524: LD_INT 17
45526: DOUBLE
45527: EQUAL
45528: IFTRUE 45580
45530: LD_INT 18
45532: DOUBLE
45533: EQUAL
45534: IFTRUE 45580
45536: LD_INT 19
45538: DOUBLE
45539: EQUAL
45540: IFTRUE 45580
45542: LD_INT 22
45544: DOUBLE
45545: EQUAL
45546: IFTRUE 45580
45548: LD_INT 20
45550: DOUBLE
45551: EQUAL
45552: IFTRUE 45580
45554: LD_INT 21
45556: DOUBLE
45557: EQUAL
45558: IFTRUE 45580
45560: LD_INT 23
45562: DOUBLE
45563: EQUAL
45564: IFTRUE 45580
45566: LD_INT 24
45568: DOUBLE
45569: EQUAL
45570: IFTRUE 45580
45572: LD_INT 25
45574: DOUBLE
45575: EQUAL
45576: IFTRUE 45580
45578: GO 45636
45580: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45581: LD_ADDR_VAR 0 9
45585: PUSH
45586: LD_VAR 0 35
45590: PUSH
45591: LD_VAR 0 36
45595: PUSH
45596: LD_VAR 0 37
45600: PUSH
45601: LD_VAR 0 38
45605: PUSH
45606: LD_VAR 0 39
45610: PUSH
45611: LD_VAR 0 40
45615: PUSH
45616: EMPTY
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: LIST
45622: LIST
45623: PUSH
45624: LD_VAR 0 4
45628: PUSH
45629: LD_INT 1
45631: PLUS
45632: ARRAY
45633: ST_TO_ADDR
45634: GO 46001
45636: LD_INT 6
45638: DOUBLE
45639: EQUAL
45640: IFTRUE 45692
45642: LD_INT 7
45644: DOUBLE
45645: EQUAL
45646: IFTRUE 45692
45648: LD_INT 8
45650: DOUBLE
45651: EQUAL
45652: IFTRUE 45692
45654: LD_INT 13
45656: DOUBLE
45657: EQUAL
45658: IFTRUE 45692
45660: LD_INT 12
45662: DOUBLE
45663: EQUAL
45664: IFTRUE 45692
45666: LD_INT 15
45668: DOUBLE
45669: EQUAL
45670: IFTRUE 45692
45672: LD_INT 11
45674: DOUBLE
45675: EQUAL
45676: IFTRUE 45692
45678: LD_INT 14
45680: DOUBLE
45681: EQUAL
45682: IFTRUE 45692
45684: LD_INT 10
45686: DOUBLE
45687: EQUAL
45688: IFTRUE 45692
45690: GO 45748
45692: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
45693: LD_ADDR_VAR 0 9
45697: PUSH
45698: LD_VAR 0 41
45702: PUSH
45703: LD_VAR 0 42
45707: PUSH
45708: LD_VAR 0 43
45712: PUSH
45713: LD_VAR 0 44
45717: PUSH
45718: LD_VAR 0 45
45722: PUSH
45723: LD_VAR 0 46
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: LIST
45732: LIST
45733: LIST
45734: LIST
45735: PUSH
45736: LD_VAR 0 4
45740: PUSH
45741: LD_INT 1
45743: PLUS
45744: ARRAY
45745: ST_TO_ADDR
45746: GO 46001
45748: LD_INT 36
45750: DOUBLE
45751: EQUAL
45752: IFTRUE 45756
45754: GO 45812
45756: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45757: LD_ADDR_VAR 0 9
45761: PUSH
45762: LD_VAR 0 47
45766: PUSH
45767: LD_VAR 0 48
45771: PUSH
45772: LD_VAR 0 49
45776: PUSH
45777: LD_VAR 0 50
45781: PUSH
45782: LD_VAR 0 51
45786: PUSH
45787: LD_VAR 0 52
45791: PUSH
45792: EMPTY
45793: LIST
45794: LIST
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: PUSH
45800: LD_VAR 0 4
45804: PUSH
45805: LD_INT 1
45807: PLUS
45808: ARRAY
45809: ST_TO_ADDR
45810: GO 46001
45812: LD_INT 4
45814: DOUBLE
45815: EQUAL
45816: IFTRUE 45838
45818: LD_INT 5
45820: DOUBLE
45821: EQUAL
45822: IFTRUE 45838
45824: LD_INT 34
45826: DOUBLE
45827: EQUAL
45828: IFTRUE 45838
45830: LD_INT 37
45832: DOUBLE
45833: EQUAL
45834: IFTRUE 45838
45836: GO 45894
45838: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45839: LD_ADDR_VAR 0 9
45843: PUSH
45844: LD_VAR 0 53
45848: PUSH
45849: LD_VAR 0 54
45853: PUSH
45854: LD_VAR 0 55
45858: PUSH
45859: LD_VAR 0 56
45863: PUSH
45864: LD_VAR 0 57
45868: PUSH
45869: LD_VAR 0 58
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: PUSH
45882: LD_VAR 0 4
45886: PUSH
45887: LD_INT 1
45889: PLUS
45890: ARRAY
45891: ST_TO_ADDR
45892: GO 46001
45894: LD_INT 31
45896: DOUBLE
45897: EQUAL
45898: IFTRUE 45944
45900: LD_INT 32
45902: DOUBLE
45903: EQUAL
45904: IFTRUE 45944
45906: LD_INT 33
45908: DOUBLE
45909: EQUAL
45910: IFTRUE 45944
45912: LD_INT 27
45914: DOUBLE
45915: EQUAL
45916: IFTRUE 45944
45918: LD_INT 26
45920: DOUBLE
45921: EQUAL
45922: IFTRUE 45944
45924: LD_INT 28
45926: DOUBLE
45927: EQUAL
45928: IFTRUE 45944
45930: LD_INT 29
45932: DOUBLE
45933: EQUAL
45934: IFTRUE 45944
45936: LD_INT 30
45938: DOUBLE
45939: EQUAL
45940: IFTRUE 45944
45942: GO 46000
45944: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
45945: LD_ADDR_VAR 0 9
45949: PUSH
45950: LD_VAR 0 59
45954: PUSH
45955: LD_VAR 0 60
45959: PUSH
45960: LD_VAR 0 61
45964: PUSH
45965: LD_VAR 0 62
45969: PUSH
45970: LD_VAR 0 63
45974: PUSH
45975: LD_VAR 0 64
45979: PUSH
45980: EMPTY
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: PUSH
45988: LD_VAR 0 4
45992: PUSH
45993: LD_INT 1
45995: PLUS
45996: ARRAY
45997: ST_TO_ADDR
45998: GO 46001
46000: POP
// temp_list2 = [ ] ;
46001: LD_ADDR_VAR 0 10
46005: PUSH
46006: EMPTY
46007: ST_TO_ADDR
// for i in temp_list do
46008: LD_ADDR_VAR 0 8
46012: PUSH
46013: LD_VAR 0 9
46017: PUSH
46018: FOR_IN
46019: IFFALSE 46071
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46021: LD_ADDR_VAR 0 10
46025: PUSH
46026: LD_VAR 0 10
46030: PUSH
46031: LD_VAR 0 8
46035: PUSH
46036: LD_INT 1
46038: ARRAY
46039: PUSH
46040: LD_VAR 0 2
46044: PLUS
46045: PUSH
46046: LD_VAR 0 8
46050: PUSH
46051: LD_INT 2
46053: ARRAY
46054: PUSH
46055: LD_VAR 0 3
46059: PLUS
46060: PUSH
46061: EMPTY
46062: LIST
46063: LIST
46064: PUSH
46065: EMPTY
46066: LIST
46067: ADD
46068: ST_TO_ADDR
46069: GO 46018
46071: POP
46072: POP
// result = temp_list2 ;
46073: LD_ADDR_VAR 0 7
46077: PUSH
46078: LD_VAR 0 10
46082: ST_TO_ADDR
// end ;
46083: LD_VAR 0 7
46087: RET
// export function EnemyInRange ( unit , dist ) ; begin
46088: LD_INT 0
46090: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46091: LD_ADDR_VAR 0 3
46095: PUSH
46096: LD_VAR 0 1
46100: PPUSH
46101: CALL_OW 255
46105: PPUSH
46106: LD_VAR 0 1
46110: PPUSH
46111: CALL_OW 250
46115: PPUSH
46116: LD_VAR 0 1
46120: PPUSH
46121: CALL_OW 251
46125: PPUSH
46126: LD_VAR 0 2
46130: PPUSH
46131: CALL 19484 0 4
46135: PUSH
46136: LD_INT 4
46138: ARRAY
46139: ST_TO_ADDR
// end ;
46140: LD_VAR 0 3
46144: RET
// export function PlayerSeeMe ( unit ) ; begin
46145: LD_INT 0
46147: PPUSH
// result := See ( your_side , unit ) ;
46148: LD_ADDR_VAR 0 2
46152: PUSH
46153: LD_OWVAR 2
46157: PPUSH
46158: LD_VAR 0 1
46162: PPUSH
46163: CALL_OW 292
46167: ST_TO_ADDR
// end ;
46168: LD_VAR 0 2
46172: RET
// export function ReverseDir ( unit ) ; begin
46173: LD_INT 0
46175: PPUSH
// if not unit then
46176: LD_VAR 0 1
46180: NOT
46181: IFFALSE 46185
// exit ;
46183: GO 46208
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46185: LD_ADDR_VAR 0 2
46189: PUSH
46190: LD_VAR 0 1
46194: PPUSH
46195: CALL_OW 254
46199: PUSH
46200: LD_INT 3
46202: PLUS
46203: PUSH
46204: LD_INT 6
46206: MOD
46207: ST_TO_ADDR
// end ;
46208: LD_VAR 0 2
46212: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46213: LD_INT 0
46215: PPUSH
46216: PPUSH
46217: PPUSH
46218: PPUSH
46219: PPUSH
// if not hexes then
46220: LD_VAR 0 2
46224: NOT
46225: IFFALSE 46229
// exit ;
46227: GO 46377
// dist := 9999 ;
46229: LD_ADDR_VAR 0 5
46233: PUSH
46234: LD_INT 9999
46236: ST_TO_ADDR
// for i = 1 to hexes do
46237: LD_ADDR_VAR 0 4
46241: PUSH
46242: DOUBLE
46243: LD_INT 1
46245: DEC
46246: ST_TO_ADDR
46247: LD_VAR 0 2
46251: PUSH
46252: FOR_TO
46253: IFFALSE 46365
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
46255: LD_VAR 0 1
46259: PPUSH
46260: LD_VAR 0 2
46264: PUSH
46265: LD_VAR 0 4
46269: ARRAY
46270: PUSH
46271: LD_INT 1
46273: ARRAY
46274: PPUSH
46275: LD_VAR 0 2
46279: PUSH
46280: LD_VAR 0 4
46284: ARRAY
46285: PUSH
46286: LD_INT 2
46288: ARRAY
46289: PPUSH
46290: CALL_OW 297
46294: PUSH
46295: LD_VAR 0 5
46299: LESS
46300: IFFALSE 46363
// begin hex := hexes [ i ] ;
46302: LD_ADDR_VAR 0 7
46306: PUSH
46307: LD_VAR 0 2
46311: PUSH
46312: LD_VAR 0 4
46316: ARRAY
46317: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46318: LD_ADDR_VAR 0 5
46322: PUSH
46323: LD_VAR 0 1
46327: PPUSH
46328: LD_VAR 0 2
46332: PUSH
46333: LD_VAR 0 4
46337: ARRAY
46338: PUSH
46339: LD_INT 1
46341: ARRAY
46342: PPUSH
46343: LD_VAR 0 2
46347: PUSH
46348: LD_VAR 0 4
46352: ARRAY
46353: PUSH
46354: LD_INT 2
46356: ARRAY
46357: PPUSH
46358: CALL_OW 297
46362: ST_TO_ADDR
// end ; end ;
46363: GO 46252
46365: POP
46366: POP
// result := hex ;
46367: LD_ADDR_VAR 0 3
46371: PUSH
46372: LD_VAR 0 7
46376: ST_TO_ADDR
// end ;
46377: LD_VAR 0 3
46381: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46382: LD_INT 0
46384: PPUSH
46385: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46386: LD_VAR 0 1
46390: NOT
46391: PUSH
46392: LD_VAR 0 1
46396: PUSH
46397: LD_INT 21
46399: PUSH
46400: LD_INT 2
46402: PUSH
46403: EMPTY
46404: LIST
46405: LIST
46406: PUSH
46407: LD_INT 23
46409: PUSH
46410: LD_INT 2
46412: PUSH
46413: EMPTY
46414: LIST
46415: LIST
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: PPUSH
46421: CALL_OW 69
46425: IN
46426: NOT
46427: OR
46428: IFFALSE 46432
// exit ;
46430: GO 46479
// for i = 1 to 3 do
46432: LD_ADDR_VAR 0 3
46436: PUSH
46437: DOUBLE
46438: LD_INT 1
46440: DEC
46441: ST_TO_ADDR
46442: LD_INT 3
46444: PUSH
46445: FOR_TO
46446: IFFALSE 46477
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46448: LD_VAR 0 1
46452: PPUSH
46453: CALL_OW 250
46457: PPUSH
46458: LD_VAR 0 1
46462: PPUSH
46463: CALL_OW 251
46467: PPUSH
46468: LD_INT 1
46470: PPUSH
46471: CALL_OW 453
46475: GO 46445
46477: POP
46478: POP
// end ;
46479: LD_VAR 0 2
46483: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46484: LD_INT 0
46486: PPUSH
46487: PPUSH
46488: PPUSH
46489: PPUSH
46490: PPUSH
46491: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46492: LD_VAR 0 1
46496: NOT
46497: PUSH
46498: LD_VAR 0 2
46502: NOT
46503: OR
46504: PUSH
46505: LD_VAR 0 1
46509: PPUSH
46510: CALL_OW 314
46514: OR
46515: IFFALSE 46519
// exit ;
46517: GO 46960
// x := GetX ( enemy_unit ) ;
46519: LD_ADDR_VAR 0 7
46523: PUSH
46524: LD_VAR 0 2
46528: PPUSH
46529: CALL_OW 250
46533: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46534: LD_ADDR_VAR 0 8
46538: PUSH
46539: LD_VAR 0 2
46543: PPUSH
46544: CALL_OW 251
46548: ST_TO_ADDR
// if not x or not y then
46549: LD_VAR 0 7
46553: NOT
46554: PUSH
46555: LD_VAR 0 8
46559: NOT
46560: OR
46561: IFFALSE 46565
// exit ;
46563: GO 46960
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46565: LD_ADDR_VAR 0 6
46569: PUSH
46570: LD_VAR 0 7
46574: PPUSH
46575: LD_INT 0
46577: PPUSH
46578: LD_INT 4
46580: PPUSH
46581: CALL_OW 272
46585: PUSH
46586: LD_VAR 0 8
46590: PPUSH
46591: LD_INT 0
46593: PPUSH
46594: LD_INT 4
46596: PPUSH
46597: CALL_OW 273
46601: PUSH
46602: EMPTY
46603: LIST
46604: LIST
46605: PUSH
46606: LD_VAR 0 7
46610: PPUSH
46611: LD_INT 1
46613: PPUSH
46614: LD_INT 4
46616: PPUSH
46617: CALL_OW 272
46621: PUSH
46622: LD_VAR 0 8
46626: PPUSH
46627: LD_INT 1
46629: PPUSH
46630: LD_INT 4
46632: PPUSH
46633: CALL_OW 273
46637: PUSH
46638: EMPTY
46639: LIST
46640: LIST
46641: PUSH
46642: LD_VAR 0 7
46646: PPUSH
46647: LD_INT 2
46649: PPUSH
46650: LD_INT 4
46652: PPUSH
46653: CALL_OW 272
46657: PUSH
46658: LD_VAR 0 8
46662: PPUSH
46663: LD_INT 2
46665: PPUSH
46666: LD_INT 4
46668: PPUSH
46669: CALL_OW 273
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: LD_VAR 0 7
46682: PPUSH
46683: LD_INT 3
46685: PPUSH
46686: LD_INT 4
46688: PPUSH
46689: CALL_OW 272
46693: PUSH
46694: LD_VAR 0 8
46698: PPUSH
46699: LD_INT 3
46701: PPUSH
46702: LD_INT 4
46704: PPUSH
46705: CALL_OW 273
46709: PUSH
46710: EMPTY
46711: LIST
46712: LIST
46713: PUSH
46714: LD_VAR 0 7
46718: PPUSH
46719: LD_INT 4
46721: PPUSH
46722: LD_INT 4
46724: PPUSH
46725: CALL_OW 272
46729: PUSH
46730: LD_VAR 0 8
46734: PPUSH
46735: LD_INT 4
46737: PPUSH
46738: LD_INT 4
46740: PPUSH
46741: CALL_OW 273
46745: PUSH
46746: EMPTY
46747: LIST
46748: LIST
46749: PUSH
46750: LD_VAR 0 7
46754: PPUSH
46755: LD_INT 5
46757: PPUSH
46758: LD_INT 4
46760: PPUSH
46761: CALL_OW 272
46765: PUSH
46766: LD_VAR 0 8
46770: PPUSH
46771: LD_INT 5
46773: PPUSH
46774: LD_INT 4
46776: PPUSH
46777: CALL_OW 273
46781: PUSH
46782: EMPTY
46783: LIST
46784: LIST
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: LIST
46790: LIST
46791: LIST
46792: LIST
46793: ST_TO_ADDR
// for i = tmp downto 1 do
46794: LD_ADDR_VAR 0 4
46798: PUSH
46799: DOUBLE
46800: LD_VAR 0 6
46804: INC
46805: ST_TO_ADDR
46806: LD_INT 1
46808: PUSH
46809: FOR_DOWNTO
46810: IFFALSE 46911
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46812: LD_VAR 0 6
46816: PUSH
46817: LD_VAR 0 4
46821: ARRAY
46822: PUSH
46823: LD_INT 1
46825: ARRAY
46826: PPUSH
46827: LD_VAR 0 6
46831: PUSH
46832: LD_VAR 0 4
46836: ARRAY
46837: PUSH
46838: LD_INT 2
46840: ARRAY
46841: PPUSH
46842: CALL_OW 488
46846: NOT
46847: PUSH
46848: LD_VAR 0 6
46852: PUSH
46853: LD_VAR 0 4
46857: ARRAY
46858: PUSH
46859: LD_INT 1
46861: ARRAY
46862: PPUSH
46863: LD_VAR 0 6
46867: PUSH
46868: LD_VAR 0 4
46872: ARRAY
46873: PUSH
46874: LD_INT 2
46876: ARRAY
46877: PPUSH
46878: CALL_OW 428
46882: PUSH
46883: LD_INT 0
46885: NONEQUAL
46886: OR
46887: IFFALSE 46909
// tmp := Delete ( tmp , i ) ;
46889: LD_ADDR_VAR 0 6
46893: PUSH
46894: LD_VAR 0 6
46898: PPUSH
46899: LD_VAR 0 4
46903: PPUSH
46904: CALL_OW 3
46908: ST_TO_ADDR
46909: GO 46809
46911: POP
46912: POP
// j := GetClosestHex ( unit , tmp ) ;
46913: LD_ADDR_VAR 0 5
46917: PUSH
46918: LD_VAR 0 1
46922: PPUSH
46923: LD_VAR 0 6
46927: PPUSH
46928: CALL 46213 0 2
46932: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46933: LD_VAR 0 1
46937: PPUSH
46938: LD_VAR 0 5
46942: PUSH
46943: LD_INT 1
46945: ARRAY
46946: PPUSH
46947: LD_VAR 0 5
46951: PUSH
46952: LD_INT 2
46954: ARRAY
46955: PPUSH
46956: CALL_OW 111
// end ;
46960: LD_VAR 0 3
46964: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46965: LD_INT 0
46967: PPUSH
46968: PPUSH
46969: PPUSH
// uc_side = 0 ;
46970: LD_ADDR_OWVAR 20
46974: PUSH
46975: LD_INT 0
46977: ST_TO_ADDR
// uc_nation = 0 ;
46978: LD_ADDR_OWVAR 21
46982: PUSH
46983: LD_INT 0
46985: ST_TO_ADDR
// InitHc_All ( ) ;
46986: CALL_OW 584
// InitVc ;
46990: CALL_OW 20
// if mastodonts then
46994: LD_VAR 0 6
46998: IFFALSE 47065
// for i = 1 to mastodonts do
47000: LD_ADDR_VAR 0 11
47004: PUSH
47005: DOUBLE
47006: LD_INT 1
47008: DEC
47009: ST_TO_ADDR
47010: LD_VAR 0 6
47014: PUSH
47015: FOR_TO
47016: IFFALSE 47063
// begin vc_chassis := 31 ;
47018: LD_ADDR_OWVAR 37
47022: PUSH
47023: LD_INT 31
47025: ST_TO_ADDR
// vc_control := control_rider ;
47026: LD_ADDR_OWVAR 38
47030: PUSH
47031: LD_INT 4
47033: ST_TO_ADDR
// animal := CreateVehicle ;
47034: LD_ADDR_VAR 0 12
47038: PUSH
47039: CALL_OW 45
47043: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47044: LD_VAR 0 12
47048: PPUSH
47049: LD_VAR 0 8
47053: PPUSH
47054: LD_INT 0
47056: PPUSH
47057: CALL 49253 0 3
// end ;
47061: GO 47015
47063: POP
47064: POP
// if horses then
47065: LD_VAR 0 5
47069: IFFALSE 47136
// for i = 1 to horses do
47071: LD_ADDR_VAR 0 11
47075: PUSH
47076: DOUBLE
47077: LD_INT 1
47079: DEC
47080: ST_TO_ADDR
47081: LD_VAR 0 5
47085: PUSH
47086: FOR_TO
47087: IFFALSE 47134
// begin hc_class := 21 ;
47089: LD_ADDR_OWVAR 28
47093: PUSH
47094: LD_INT 21
47096: ST_TO_ADDR
// hc_gallery :=  ;
47097: LD_ADDR_OWVAR 33
47101: PUSH
47102: LD_STRING 
47104: ST_TO_ADDR
// animal := CreateHuman ;
47105: LD_ADDR_VAR 0 12
47109: PUSH
47110: CALL_OW 44
47114: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47115: LD_VAR 0 12
47119: PPUSH
47120: LD_VAR 0 8
47124: PPUSH
47125: LD_INT 0
47127: PPUSH
47128: CALL 49253 0 3
// end ;
47132: GO 47086
47134: POP
47135: POP
// if birds then
47136: LD_VAR 0 1
47140: IFFALSE 47207
// for i = 1 to birds do
47142: LD_ADDR_VAR 0 11
47146: PUSH
47147: DOUBLE
47148: LD_INT 1
47150: DEC
47151: ST_TO_ADDR
47152: LD_VAR 0 1
47156: PUSH
47157: FOR_TO
47158: IFFALSE 47205
// begin hc_class = 18 ;
47160: LD_ADDR_OWVAR 28
47164: PUSH
47165: LD_INT 18
47167: ST_TO_ADDR
// hc_gallery =  ;
47168: LD_ADDR_OWVAR 33
47172: PUSH
47173: LD_STRING 
47175: ST_TO_ADDR
// animal := CreateHuman ;
47176: LD_ADDR_VAR 0 12
47180: PUSH
47181: CALL_OW 44
47185: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47186: LD_VAR 0 12
47190: PPUSH
47191: LD_VAR 0 8
47195: PPUSH
47196: LD_INT 0
47198: PPUSH
47199: CALL 49253 0 3
// end ;
47203: GO 47157
47205: POP
47206: POP
// if tigers then
47207: LD_VAR 0 2
47211: IFFALSE 47295
// for i = 1 to tigers do
47213: LD_ADDR_VAR 0 11
47217: PUSH
47218: DOUBLE
47219: LD_INT 1
47221: DEC
47222: ST_TO_ADDR
47223: LD_VAR 0 2
47227: PUSH
47228: FOR_TO
47229: IFFALSE 47293
// begin hc_class = class_tiger ;
47231: LD_ADDR_OWVAR 28
47235: PUSH
47236: LD_INT 14
47238: ST_TO_ADDR
// hc_gallery =  ;
47239: LD_ADDR_OWVAR 33
47243: PUSH
47244: LD_STRING 
47246: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47247: LD_ADDR_OWVAR 35
47251: PUSH
47252: LD_INT 7
47254: NEG
47255: PPUSH
47256: LD_INT 7
47258: PPUSH
47259: CALL_OW 12
47263: ST_TO_ADDR
// animal := CreateHuman ;
47264: LD_ADDR_VAR 0 12
47268: PUSH
47269: CALL_OW 44
47273: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47274: LD_VAR 0 12
47278: PPUSH
47279: LD_VAR 0 8
47283: PPUSH
47284: LD_INT 0
47286: PPUSH
47287: CALL 49253 0 3
// end ;
47291: GO 47228
47293: POP
47294: POP
// if apemans then
47295: LD_VAR 0 3
47299: IFFALSE 47422
// for i = 1 to apemans do
47301: LD_ADDR_VAR 0 11
47305: PUSH
47306: DOUBLE
47307: LD_INT 1
47309: DEC
47310: ST_TO_ADDR
47311: LD_VAR 0 3
47315: PUSH
47316: FOR_TO
47317: IFFALSE 47420
// begin hc_class = class_apeman ;
47319: LD_ADDR_OWVAR 28
47323: PUSH
47324: LD_INT 12
47326: ST_TO_ADDR
// hc_gallery =  ;
47327: LD_ADDR_OWVAR 33
47331: PUSH
47332: LD_STRING 
47334: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
47335: LD_ADDR_OWVAR 35
47339: PUSH
47340: LD_INT 2
47342: NEG
47343: PPUSH
47344: LD_INT 2
47346: PPUSH
47347: CALL_OW 12
47351: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
47352: LD_ADDR_OWVAR 31
47356: PUSH
47357: LD_INT 1
47359: PPUSH
47360: LD_INT 3
47362: PPUSH
47363: CALL_OW 12
47367: PUSH
47368: LD_INT 1
47370: PPUSH
47371: LD_INT 3
47373: PPUSH
47374: CALL_OW 12
47378: PUSH
47379: LD_INT 0
47381: PUSH
47382: LD_INT 0
47384: PUSH
47385: EMPTY
47386: LIST
47387: LIST
47388: LIST
47389: LIST
47390: ST_TO_ADDR
// animal := CreateHuman ;
47391: LD_ADDR_VAR 0 12
47395: PUSH
47396: CALL_OW 44
47400: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47401: LD_VAR 0 12
47405: PPUSH
47406: LD_VAR 0 8
47410: PPUSH
47411: LD_INT 0
47413: PPUSH
47414: CALL 49253 0 3
// end ;
47418: GO 47316
47420: POP
47421: POP
// if enchidnas then
47422: LD_VAR 0 4
47426: IFFALSE 47493
// for i = 1 to enchidnas do
47428: LD_ADDR_VAR 0 11
47432: PUSH
47433: DOUBLE
47434: LD_INT 1
47436: DEC
47437: ST_TO_ADDR
47438: LD_VAR 0 4
47442: PUSH
47443: FOR_TO
47444: IFFALSE 47491
// begin hc_class = 13 ;
47446: LD_ADDR_OWVAR 28
47450: PUSH
47451: LD_INT 13
47453: ST_TO_ADDR
// hc_gallery =  ;
47454: LD_ADDR_OWVAR 33
47458: PUSH
47459: LD_STRING 
47461: ST_TO_ADDR
// animal := CreateHuman ;
47462: LD_ADDR_VAR 0 12
47466: PUSH
47467: CALL_OW 44
47471: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47472: LD_VAR 0 12
47476: PPUSH
47477: LD_VAR 0 8
47481: PPUSH
47482: LD_INT 0
47484: PPUSH
47485: CALL 49253 0 3
// end ;
47489: GO 47443
47491: POP
47492: POP
// if fishes then
47493: LD_VAR 0 7
47497: IFFALSE 47564
// for i = 1 to fishes do
47499: LD_ADDR_VAR 0 11
47503: PUSH
47504: DOUBLE
47505: LD_INT 1
47507: DEC
47508: ST_TO_ADDR
47509: LD_VAR 0 7
47513: PUSH
47514: FOR_TO
47515: IFFALSE 47562
// begin hc_class = 20 ;
47517: LD_ADDR_OWVAR 28
47521: PUSH
47522: LD_INT 20
47524: ST_TO_ADDR
// hc_gallery =  ;
47525: LD_ADDR_OWVAR 33
47529: PUSH
47530: LD_STRING 
47532: ST_TO_ADDR
// animal := CreateHuman ;
47533: LD_ADDR_VAR 0 12
47537: PUSH
47538: CALL_OW 44
47542: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
47543: LD_VAR 0 12
47547: PPUSH
47548: LD_VAR 0 9
47552: PPUSH
47553: LD_INT 0
47555: PPUSH
47556: CALL 49253 0 3
// end ;
47560: GO 47514
47562: POP
47563: POP
// end ;
47564: LD_VAR 0 10
47568: RET
// export function WantHeal ( sci , unit ) ; begin
47569: LD_INT 0
47571: PPUSH
// if GetTaskList ( sci ) > 0 then
47572: LD_VAR 0 1
47576: PPUSH
47577: CALL_OW 437
47581: PUSH
47582: LD_INT 0
47584: GREATER
47585: IFFALSE 47655
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
47587: LD_VAR 0 1
47591: PPUSH
47592: CALL_OW 437
47596: PUSH
47597: LD_INT 1
47599: ARRAY
47600: PUSH
47601: LD_INT 1
47603: ARRAY
47604: PUSH
47605: LD_STRING l
47607: EQUAL
47608: PUSH
47609: LD_VAR 0 1
47613: PPUSH
47614: CALL_OW 437
47618: PUSH
47619: LD_INT 1
47621: ARRAY
47622: PUSH
47623: LD_INT 4
47625: ARRAY
47626: PUSH
47627: LD_VAR 0 2
47631: EQUAL
47632: AND
47633: IFFALSE 47645
// result := true else
47635: LD_ADDR_VAR 0 3
47639: PUSH
47640: LD_INT 1
47642: ST_TO_ADDR
47643: GO 47653
// result := false ;
47645: LD_ADDR_VAR 0 3
47649: PUSH
47650: LD_INT 0
47652: ST_TO_ADDR
// end else
47653: GO 47663
// result := false ;
47655: LD_ADDR_VAR 0 3
47659: PUSH
47660: LD_INT 0
47662: ST_TO_ADDR
// end ;
47663: LD_VAR 0 3
47667: RET
// export function HealTarget ( sci ) ; begin
47668: LD_INT 0
47670: PPUSH
// if not sci then
47671: LD_VAR 0 1
47675: NOT
47676: IFFALSE 47680
// exit ;
47678: GO 47745
// result := 0 ;
47680: LD_ADDR_VAR 0 2
47684: PUSH
47685: LD_INT 0
47687: ST_TO_ADDR
// if GetTaskList ( sci ) then
47688: LD_VAR 0 1
47692: PPUSH
47693: CALL_OW 437
47697: IFFALSE 47745
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
47699: LD_VAR 0 1
47703: PPUSH
47704: CALL_OW 437
47708: PUSH
47709: LD_INT 1
47711: ARRAY
47712: PUSH
47713: LD_INT 1
47715: ARRAY
47716: PUSH
47717: LD_STRING l
47719: EQUAL
47720: IFFALSE 47745
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
47722: LD_ADDR_VAR 0 2
47726: PUSH
47727: LD_VAR 0 1
47731: PPUSH
47732: CALL_OW 437
47736: PUSH
47737: LD_INT 1
47739: ARRAY
47740: PUSH
47741: LD_INT 4
47743: ARRAY
47744: ST_TO_ADDR
// end ;
47745: LD_VAR 0 2
47749: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
47750: LD_INT 0
47752: PPUSH
47753: PPUSH
47754: PPUSH
47755: PPUSH
// if not base_units then
47756: LD_VAR 0 1
47760: NOT
47761: IFFALSE 47765
// exit ;
47763: GO 47852
// result := false ;
47765: LD_ADDR_VAR 0 2
47769: PUSH
47770: LD_INT 0
47772: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
47773: LD_ADDR_VAR 0 5
47777: PUSH
47778: LD_VAR 0 1
47782: PPUSH
47783: LD_INT 21
47785: PUSH
47786: LD_INT 3
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: PPUSH
47793: CALL_OW 72
47797: ST_TO_ADDR
// if not tmp then
47798: LD_VAR 0 5
47802: NOT
47803: IFFALSE 47807
// exit ;
47805: GO 47852
// for i in tmp do
47807: LD_ADDR_VAR 0 3
47811: PUSH
47812: LD_VAR 0 5
47816: PUSH
47817: FOR_IN
47818: IFFALSE 47850
// begin result := EnemyInRange ( i , 22 ) ;
47820: LD_ADDR_VAR 0 2
47824: PUSH
47825: LD_VAR 0 3
47829: PPUSH
47830: LD_INT 22
47832: PPUSH
47833: CALL 46088 0 2
47837: ST_TO_ADDR
// if result then
47838: LD_VAR 0 2
47842: IFFALSE 47848
// exit ;
47844: POP
47845: POP
47846: GO 47852
// end ;
47848: GO 47817
47850: POP
47851: POP
// end ;
47852: LD_VAR 0 2
47856: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
47857: LD_INT 0
47859: PPUSH
47860: PPUSH
// if not units then
47861: LD_VAR 0 1
47865: NOT
47866: IFFALSE 47870
// exit ;
47868: GO 47940
// result := [ ] ;
47870: LD_ADDR_VAR 0 3
47874: PUSH
47875: EMPTY
47876: ST_TO_ADDR
// for i in units do
47877: LD_ADDR_VAR 0 4
47881: PUSH
47882: LD_VAR 0 1
47886: PUSH
47887: FOR_IN
47888: IFFALSE 47938
// if GetTag ( i ) = tag then
47890: LD_VAR 0 4
47894: PPUSH
47895: CALL_OW 110
47899: PUSH
47900: LD_VAR 0 2
47904: EQUAL
47905: IFFALSE 47936
// result := Replace ( result , result + 1 , i ) ;
47907: LD_ADDR_VAR 0 3
47911: PUSH
47912: LD_VAR 0 3
47916: PPUSH
47917: LD_VAR 0 3
47921: PUSH
47922: LD_INT 1
47924: PLUS
47925: PPUSH
47926: LD_VAR 0 4
47930: PPUSH
47931: CALL_OW 1
47935: ST_TO_ADDR
47936: GO 47887
47938: POP
47939: POP
// end ;
47940: LD_VAR 0 3
47944: RET
// export function IsDriver ( un ) ; begin
47945: LD_INT 0
47947: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47948: LD_ADDR_VAR 0 2
47952: PUSH
47953: LD_VAR 0 1
47957: PUSH
47958: LD_INT 55
47960: PUSH
47961: EMPTY
47962: LIST
47963: PPUSH
47964: CALL_OW 69
47968: IN
47969: ST_TO_ADDR
// end ;
47970: LD_VAR 0 2
47974: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47975: LD_INT 0
47977: PPUSH
47978: PPUSH
// list := [ ] ;
47979: LD_ADDR_VAR 0 5
47983: PUSH
47984: EMPTY
47985: ST_TO_ADDR
// case d of 0 :
47986: LD_VAR 0 3
47990: PUSH
47991: LD_INT 0
47993: DOUBLE
47994: EQUAL
47995: IFTRUE 47999
47997: GO 48132
47999: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
48000: LD_ADDR_VAR 0 5
48004: PUSH
48005: LD_VAR 0 1
48009: PUSH
48010: LD_INT 4
48012: MINUS
48013: PUSH
48014: LD_VAR 0 2
48018: PUSH
48019: LD_INT 4
48021: MINUS
48022: PUSH
48023: LD_INT 2
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: LIST
48030: PUSH
48031: LD_VAR 0 1
48035: PUSH
48036: LD_INT 3
48038: MINUS
48039: PUSH
48040: LD_VAR 0 2
48044: PUSH
48045: LD_INT 1
48047: PUSH
48048: EMPTY
48049: LIST
48050: LIST
48051: LIST
48052: PUSH
48053: LD_VAR 0 1
48057: PUSH
48058: LD_INT 4
48060: PLUS
48061: PUSH
48062: LD_VAR 0 2
48066: PUSH
48067: LD_INT 4
48069: PUSH
48070: EMPTY
48071: LIST
48072: LIST
48073: LIST
48074: PUSH
48075: LD_VAR 0 1
48079: PUSH
48080: LD_INT 3
48082: PLUS
48083: PUSH
48084: LD_VAR 0 2
48088: PUSH
48089: LD_INT 3
48091: PLUS
48092: PUSH
48093: LD_INT 5
48095: PUSH
48096: EMPTY
48097: LIST
48098: LIST
48099: LIST
48100: PUSH
48101: LD_VAR 0 1
48105: PUSH
48106: LD_VAR 0 2
48110: PUSH
48111: LD_INT 4
48113: PLUS
48114: PUSH
48115: LD_INT 0
48117: PUSH
48118: EMPTY
48119: LIST
48120: LIST
48121: LIST
48122: PUSH
48123: EMPTY
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: ST_TO_ADDR
// end ; 1 :
48130: GO 48830
48132: LD_INT 1
48134: DOUBLE
48135: EQUAL
48136: IFTRUE 48140
48138: GO 48273
48140: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48141: LD_ADDR_VAR 0 5
48145: PUSH
48146: LD_VAR 0 1
48150: PUSH
48151: LD_VAR 0 2
48155: PUSH
48156: LD_INT 4
48158: MINUS
48159: PUSH
48160: LD_INT 3
48162: PUSH
48163: EMPTY
48164: LIST
48165: LIST
48166: LIST
48167: PUSH
48168: LD_VAR 0 1
48172: PUSH
48173: LD_INT 3
48175: MINUS
48176: PUSH
48177: LD_VAR 0 2
48181: PUSH
48182: LD_INT 3
48184: MINUS
48185: PUSH
48186: LD_INT 2
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: LIST
48193: PUSH
48194: LD_VAR 0 1
48198: PUSH
48199: LD_INT 4
48201: MINUS
48202: PUSH
48203: LD_VAR 0 2
48207: PUSH
48208: LD_INT 1
48210: PUSH
48211: EMPTY
48212: LIST
48213: LIST
48214: LIST
48215: PUSH
48216: LD_VAR 0 1
48220: PUSH
48221: LD_VAR 0 2
48225: PUSH
48226: LD_INT 3
48228: PLUS
48229: PUSH
48230: LD_INT 0
48232: PUSH
48233: EMPTY
48234: LIST
48235: LIST
48236: LIST
48237: PUSH
48238: LD_VAR 0 1
48242: PUSH
48243: LD_INT 4
48245: PLUS
48246: PUSH
48247: LD_VAR 0 2
48251: PUSH
48252: LD_INT 4
48254: PLUS
48255: PUSH
48256: LD_INT 5
48258: PUSH
48259: EMPTY
48260: LIST
48261: LIST
48262: LIST
48263: PUSH
48264: EMPTY
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: ST_TO_ADDR
// end ; 2 :
48271: GO 48830
48273: LD_INT 2
48275: DOUBLE
48276: EQUAL
48277: IFTRUE 48281
48279: GO 48410
48281: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48282: LD_ADDR_VAR 0 5
48286: PUSH
48287: LD_VAR 0 1
48291: PUSH
48292: LD_VAR 0 2
48296: PUSH
48297: LD_INT 3
48299: MINUS
48300: PUSH
48301: LD_INT 3
48303: PUSH
48304: EMPTY
48305: LIST
48306: LIST
48307: LIST
48308: PUSH
48309: LD_VAR 0 1
48313: PUSH
48314: LD_INT 4
48316: PLUS
48317: PUSH
48318: LD_VAR 0 2
48322: PUSH
48323: LD_INT 4
48325: PUSH
48326: EMPTY
48327: LIST
48328: LIST
48329: LIST
48330: PUSH
48331: LD_VAR 0 1
48335: PUSH
48336: LD_VAR 0 2
48340: PUSH
48341: LD_INT 4
48343: PLUS
48344: PUSH
48345: LD_INT 0
48347: PUSH
48348: EMPTY
48349: LIST
48350: LIST
48351: LIST
48352: PUSH
48353: LD_VAR 0 1
48357: PUSH
48358: LD_INT 3
48360: MINUS
48361: PUSH
48362: LD_VAR 0 2
48366: PUSH
48367: LD_INT 1
48369: PUSH
48370: EMPTY
48371: LIST
48372: LIST
48373: LIST
48374: PUSH
48375: LD_VAR 0 1
48379: PUSH
48380: LD_INT 4
48382: MINUS
48383: PUSH
48384: LD_VAR 0 2
48388: PUSH
48389: LD_INT 4
48391: MINUS
48392: PUSH
48393: LD_INT 2
48395: PUSH
48396: EMPTY
48397: LIST
48398: LIST
48399: LIST
48400: PUSH
48401: EMPTY
48402: LIST
48403: LIST
48404: LIST
48405: LIST
48406: LIST
48407: ST_TO_ADDR
// end ; 3 :
48408: GO 48830
48410: LD_INT 3
48412: DOUBLE
48413: EQUAL
48414: IFTRUE 48418
48416: GO 48551
48418: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
48419: LD_ADDR_VAR 0 5
48423: PUSH
48424: LD_VAR 0 1
48428: PUSH
48429: LD_INT 3
48431: PLUS
48432: PUSH
48433: LD_VAR 0 2
48437: PUSH
48438: LD_INT 4
48440: PUSH
48441: EMPTY
48442: LIST
48443: LIST
48444: LIST
48445: PUSH
48446: LD_VAR 0 1
48450: PUSH
48451: LD_INT 4
48453: PLUS
48454: PUSH
48455: LD_VAR 0 2
48459: PUSH
48460: LD_INT 4
48462: PLUS
48463: PUSH
48464: LD_INT 5
48466: PUSH
48467: EMPTY
48468: LIST
48469: LIST
48470: LIST
48471: PUSH
48472: LD_VAR 0 1
48476: PUSH
48477: LD_INT 4
48479: MINUS
48480: PUSH
48481: LD_VAR 0 2
48485: PUSH
48486: LD_INT 1
48488: PUSH
48489: EMPTY
48490: LIST
48491: LIST
48492: LIST
48493: PUSH
48494: LD_VAR 0 1
48498: PUSH
48499: LD_VAR 0 2
48503: PUSH
48504: LD_INT 4
48506: MINUS
48507: PUSH
48508: LD_INT 3
48510: PUSH
48511: EMPTY
48512: LIST
48513: LIST
48514: LIST
48515: PUSH
48516: LD_VAR 0 1
48520: PUSH
48521: LD_INT 3
48523: MINUS
48524: PUSH
48525: LD_VAR 0 2
48529: PUSH
48530: LD_INT 3
48532: MINUS
48533: PUSH
48534: LD_INT 2
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: LIST
48541: PUSH
48542: EMPTY
48543: LIST
48544: LIST
48545: LIST
48546: LIST
48547: LIST
48548: ST_TO_ADDR
// end ; 4 :
48549: GO 48830
48551: LD_INT 4
48553: DOUBLE
48554: EQUAL
48555: IFTRUE 48559
48557: GO 48692
48559: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
48560: LD_ADDR_VAR 0 5
48564: PUSH
48565: LD_VAR 0 1
48569: PUSH
48570: LD_VAR 0 2
48574: PUSH
48575: LD_INT 4
48577: PLUS
48578: PUSH
48579: LD_INT 0
48581: PUSH
48582: EMPTY
48583: LIST
48584: LIST
48585: LIST
48586: PUSH
48587: LD_VAR 0 1
48591: PUSH
48592: LD_INT 3
48594: PLUS
48595: PUSH
48596: LD_VAR 0 2
48600: PUSH
48601: LD_INT 3
48603: PLUS
48604: PUSH
48605: LD_INT 5
48607: PUSH
48608: EMPTY
48609: LIST
48610: LIST
48611: LIST
48612: PUSH
48613: LD_VAR 0 1
48617: PUSH
48618: LD_INT 4
48620: PLUS
48621: PUSH
48622: LD_VAR 0 2
48626: PUSH
48627: LD_INT 4
48629: PUSH
48630: EMPTY
48631: LIST
48632: LIST
48633: LIST
48634: PUSH
48635: LD_VAR 0 1
48639: PUSH
48640: LD_VAR 0 2
48644: PUSH
48645: LD_INT 3
48647: MINUS
48648: PUSH
48649: LD_INT 3
48651: PUSH
48652: EMPTY
48653: LIST
48654: LIST
48655: LIST
48656: PUSH
48657: LD_VAR 0 1
48661: PUSH
48662: LD_INT 4
48664: MINUS
48665: PUSH
48666: LD_VAR 0 2
48670: PUSH
48671: LD_INT 4
48673: MINUS
48674: PUSH
48675: LD_INT 2
48677: PUSH
48678: EMPTY
48679: LIST
48680: LIST
48681: LIST
48682: PUSH
48683: EMPTY
48684: LIST
48685: LIST
48686: LIST
48687: LIST
48688: LIST
48689: ST_TO_ADDR
// end ; 5 :
48690: GO 48830
48692: LD_INT 5
48694: DOUBLE
48695: EQUAL
48696: IFTRUE 48700
48698: GO 48829
48700: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
48701: LD_ADDR_VAR 0 5
48705: PUSH
48706: LD_VAR 0 1
48710: PUSH
48711: LD_INT 4
48713: MINUS
48714: PUSH
48715: LD_VAR 0 2
48719: PUSH
48720: LD_INT 1
48722: PUSH
48723: EMPTY
48724: LIST
48725: LIST
48726: LIST
48727: PUSH
48728: LD_VAR 0 1
48732: PUSH
48733: LD_VAR 0 2
48737: PUSH
48738: LD_INT 4
48740: MINUS
48741: PUSH
48742: LD_INT 3
48744: PUSH
48745: EMPTY
48746: LIST
48747: LIST
48748: LIST
48749: PUSH
48750: LD_VAR 0 1
48754: PUSH
48755: LD_INT 4
48757: PLUS
48758: PUSH
48759: LD_VAR 0 2
48763: PUSH
48764: LD_INT 4
48766: PLUS
48767: PUSH
48768: LD_INT 5
48770: PUSH
48771: EMPTY
48772: LIST
48773: LIST
48774: LIST
48775: PUSH
48776: LD_VAR 0 1
48780: PUSH
48781: LD_INT 3
48783: PLUS
48784: PUSH
48785: LD_VAR 0 2
48789: PUSH
48790: LD_INT 4
48792: PUSH
48793: EMPTY
48794: LIST
48795: LIST
48796: LIST
48797: PUSH
48798: LD_VAR 0 1
48802: PUSH
48803: LD_VAR 0 2
48807: PUSH
48808: LD_INT 3
48810: PLUS
48811: PUSH
48812: LD_INT 0
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: LIST
48819: PUSH
48820: EMPTY
48821: LIST
48822: LIST
48823: LIST
48824: LIST
48825: LIST
48826: ST_TO_ADDR
// end ; end ;
48827: GO 48830
48829: POP
// result := list ;
48830: LD_ADDR_VAR 0 4
48834: PUSH
48835: LD_VAR 0 5
48839: ST_TO_ADDR
// end ;
48840: LD_VAR 0 4
48844: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48845: LD_INT 0
48847: PPUSH
48848: PPUSH
48849: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48850: LD_VAR 0 1
48854: NOT
48855: PUSH
48856: LD_VAR 0 2
48860: PUSH
48861: LD_INT 1
48863: PUSH
48864: LD_INT 2
48866: PUSH
48867: LD_INT 3
48869: PUSH
48870: LD_INT 4
48872: PUSH
48873: EMPTY
48874: LIST
48875: LIST
48876: LIST
48877: LIST
48878: IN
48879: NOT
48880: OR
48881: IFFALSE 48885
// exit ;
48883: GO 48977
// tmp := [ ] ;
48885: LD_ADDR_VAR 0 5
48889: PUSH
48890: EMPTY
48891: ST_TO_ADDR
// for i in units do
48892: LD_ADDR_VAR 0 4
48896: PUSH
48897: LD_VAR 0 1
48901: PUSH
48902: FOR_IN
48903: IFFALSE 48946
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48905: LD_ADDR_VAR 0 5
48909: PUSH
48910: LD_VAR 0 5
48914: PPUSH
48915: LD_VAR 0 5
48919: PUSH
48920: LD_INT 1
48922: PLUS
48923: PPUSH
48924: LD_VAR 0 4
48928: PPUSH
48929: LD_VAR 0 2
48933: PPUSH
48934: CALL_OW 259
48938: PPUSH
48939: CALL_OW 2
48943: ST_TO_ADDR
48944: GO 48902
48946: POP
48947: POP
// if not tmp then
48948: LD_VAR 0 5
48952: NOT
48953: IFFALSE 48957
// exit ;
48955: GO 48977
// result := SortListByListDesc ( units , tmp ) ;
48957: LD_ADDR_VAR 0 3
48961: PUSH
48962: LD_VAR 0 1
48966: PPUSH
48967: LD_VAR 0 5
48971: PPUSH
48972: CALL_OW 77
48976: ST_TO_ADDR
// end ;
48977: LD_VAR 0 3
48981: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48982: LD_INT 0
48984: PPUSH
48985: PPUSH
48986: PPUSH
// result := false ;
48987: LD_ADDR_VAR 0 3
48991: PUSH
48992: LD_INT 0
48994: ST_TO_ADDR
// x := GetX ( building ) ;
48995: LD_ADDR_VAR 0 4
48999: PUSH
49000: LD_VAR 0 2
49004: PPUSH
49005: CALL_OW 250
49009: ST_TO_ADDR
// y := GetY ( building ) ;
49010: LD_ADDR_VAR 0 5
49014: PUSH
49015: LD_VAR 0 2
49019: PPUSH
49020: CALL_OW 251
49024: ST_TO_ADDR
// if not building or not x or not y then
49025: LD_VAR 0 2
49029: NOT
49030: PUSH
49031: LD_VAR 0 4
49035: NOT
49036: OR
49037: PUSH
49038: LD_VAR 0 5
49042: NOT
49043: OR
49044: IFFALSE 49048
// exit ;
49046: GO 49140
// if GetTaskList ( unit ) then
49048: LD_VAR 0 1
49052: PPUSH
49053: CALL_OW 437
49057: IFFALSE 49140
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49059: LD_STRING e
49061: PUSH
49062: LD_VAR 0 1
49066: PPUSH
49067: CALL_OW 437
49071: PUSH
49072: LD_INT 1
49074: ARRAY
49075: PUSH
49076: LD_INT 1
49078: ARRAY
49079: EQUAL
49080: PUSH
49081: LD_VAR 0 4
49085: PUSH
49086: LD_VAR 0 1
49090: PPUSH
49091: CALL_OW 437
49095: PUSH
49096: LD_INT 1
49098: ARRAY
49099: PUSH
49100: LD_INT 2
49102: ARRAY
49103: EQUAL
49104: AND
49105: PUSH
49106: LD_VAR 0 5
49110: PUSH
49111: LD_VAR 0 1
49115: PPUSH
49116: CALL_OW 437
49120: PUSH
49121: LD_INT 1
49123: ARRAY
49124: PUSH
49125: LD_INT 3
49127: ARRAY
49128: EQUAL
49129: AND
49130: IFFALSE 49140
// result := true end ;
49132: LD_ADDR_VAR 0 3
49136: PUSH
49137: LD_INT 1
49139: ST_TO_ADDR
// end ;
49140: LD_VAR 0 3
49144: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
49145: LD_INT 0
49147: PPUSH
// result := false ;
49148: LD_ADDR_VAR 0 4
49152: PUSH
49153: LD_INT 0
49155: ST_TO_ADDR
// if GetTaskList ( unit ) then
49156: LD_VAR 0 1
49160: PPUSH
49161: CALL_OW 437
49165: IFFALSE 49248
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49167: LD_STRING M
49169: PUSH
49170: LD_VAR 0 1
49174: PPUSH
49175: CALL_OW 437
49179: PUSH
49180: LD_INT 1
49182: ARRAY
49183: PUSH
49184: LD_INT 1
49186: ARRAY
49187: EQUAL
49188: PUSH
49189: LD_VAR 0 2
49193: PUSH
49194: LD_VAR 0 1
49198: PPUSH
49199: CALL_OW 437
49203: PUSH
49204: LD_INT 1
49206: ARRAY
49207: PUSH
49208: LD_INT 2
49210: ARRAY
49211: EQUAL
49212: AND
49213: PUSH
49214: LD_VAR 0 3
49218: PUSH
49219: LD_VAR 0 1
49223: PPUSH
49224: CALL_OW 437
49228: PUSH
49229: LD_INT 1
49231: ARRAY
49232: PUSH
49233: LD_INT 3
49235: ARRAY
49236: EQUAL
49237: AND
49238: IFFALSE 49248
// result := true ;
49240: LD_ADDR_VAR 0 4
49244: PUSH
49245: LD_INT 1
49247: ST_TO_ADDR
// end ; end ;
49248: LD_VAR 0 4
49252: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49253: LD_INT 0
49255: PPUSH
49256: PPUSH
49257: PPUSH
49258: PPUSH
// if not unit or not area then
49259: LD_VAR 0 1
49263: NOT
49264: PUSH
49265: LD_VAR 0 2
49269: NOT
49270: OR
49271: IFFALSE 49275
// exit ;
49273: GO 49439
// tmp := AreaToList ( area , i ) ;
49275: LD_ADDR_VAR 0 6
49279: PUSH
49280: LD_VAR 0 2
49284: PPUSH
49285: LD_VAR 0 5
49289: PPUSH
49290: CALL_OW 517
49294: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49295: LD_ADDR_VAR 0 5
49299: PUSH
49300: DOUBLE
49301: LD_INT 1
49303: DEC
49304: ST_TO_ADDR
49305: LD_VAR 0 6
49309: PUSH
49310: LD_INT 1
49312: ARRAY
49313: PUSH
49314: FOR_TO
49315: IFFALSE 49437
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49317: LD_ADDR_VAR 0 7
49321: PUSH
49322: LD_VAR 0 6
49326: PUSH
49327: LD_INT 1
49329: ARRAY
49330: PUSH
49331: LD_VAR 0 5
49335: ARRAY
49336: PUSH
49337: LD_VAR 0 6
49341: PUSH
49342: LD_INT 2
49344: ARRAY
49345: PUSH
49346: LD_VAR 0 5
49350: ARRAY
49351: PUSH
49352: EMPTY
49353: LIST
49354: LIST
49355: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
49356: LD_VAR 0 7
49360: PUSH
49361: LD_INT 1
49363: ARRAY
49364: PPUSH
49365: LD_VAR 0 7
49369: PUSH
49370: LD_INT 2
49372: ARRAY
49373: PPUSH
49374: CALL_OW 428
49378: PUSH
49379: LD_INT 0
49381: EQUAL
49382: IFFALSE 49435
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
49384: LD_VAR 0 1
49388: PPUSH
49389: LD_VAR 0 7
49393: PUSH
49394: LD_INT 1
49396: ARRAY
49397: PPUSH
49398: LD_VAR 0 7
49402: PUSH
49403: LD_INT 2
49405: ARRAY
49406: PPUSH
49407: LD_VAR 0 3
49411: PPUSH
49412: CALL_OW 48
// result := IsPlaced ( unit ) ;
49416: LD_ADDR_VAR 0 4
49420: PUSH
49421: LD_VAR 0 1
49425: PPUSH
49426: CALL_OW 305
49430: ST_TO_ADDR
// exit ;
49431: POP
49432: POP
49433: GO 49439
// end ; end ;
49435: GO 49314
49437: POP
49438: POP
// end ;
49439: LD_VAR 0 4
49443: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
49444: LD_INT 0
49446: PPUSH
49447: PPUSH
49448: PPUSH
// if not side or side > 8 then
49449: LD_VAR 0 1
49453: NOT
49454: PUSH
49455: LD_VAR 0 1
49459: PUSH
49460: LD_INT 8
49462: GREATER
49463: OR
49464: IFFALSE 49468
// exit ;
49466: GO 49655
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
49468: LD_ADDR_VAR 0 4
49472: PUSH
49473: LD_INT 22
49475: PUSH
49476: LD_VAR 0 1
49480: PUSH
49481: EMPTY
49482: LIST
49483: LIST
49484: PUSH
49485: LD_INT 21
49487: PUSH
49488: LD_INT 3
49490: PUSH
49491: EMPTY
49492: LIST
49493: LIST
49494: PUSH
49495: EMPTY
49496: LIST
49497: LIST
49498: PPUSH
49499: CALL_OW 69
49503: ST_TO_ADDR
// if not tmp then
49504: LD_VAR 0 4
49508: NOT
49509: IFFALSE 49513
// exit ;
49511: GO 49655
// enable_addtolog := true ;
49513: LD_ADDR_OWVAR 81
49517: PUSH
49518: LD_INT 1
49520: ST_TO_ADDR
// AddToLog ( [ ) ;
49521: LD_STRING [
49523: PPUSH
49524: CALL_OW 561
// for i in tmp do
49528: LD_ADDR_VAR 0 3
49532: PUSH
49533: LD_VAR 0 4
49537: PUSH
49538: FOR_IN
49539: IFFALSE 49646
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
49541: LD_STRING [
49543: PUSH
49544: LD_VAR 0 3
49548: PPUSH
49549: CALL_OW 266
49553: STR
49554: PUSH
49555: LD_STRING , 
49557: STR
49558: PUSH
49559: LD_VAR 0 3
49563: PPUSH
49564: CALL_OW 250
49568: STR
49569: PUSH
49570: LD_STRING , 
49572: STR
49573: PUSH
49574: LD_VAR 0 3
49578: PPUSH
49579: CALL_OW 251
49583: STR
49584: PUSH
49585: LD_STRING , 
49587: STR
49588: PUSH
49589: LD_VAR 0 3
49593: PPUSH
49594: CALL_OW 254
49598: STR
49599: PUSH
49600: LD_STRING , 
49602: STR
49603: PUSH
49604: LD_VAR 0 3
49608: PPUSH
49609: LD_INT 1
49611: PPUSH
49612: CALL_OW 268
49616: STR
49617: PUSH
49618: LD_STRING , 
49620: STR
49621: PUSH
49622: LD_VAR 0 3
49626: PPUSH
49627: LD_INT 2
49629: PPUSH
49630: CALL_OW 268
49634: STR
49635: PUSH
49636: LD_STRING ],
49638: STR
49639: PPUSH
49640: CALL_OW 561
// end ;
49644: GO 49538
49646: POP
49647: POP
// AddToLog ( ]; ) ;
49648: LD_STRING ];
49650: PPUSH
49651: CALL_OW 561
// end ;
49655: LD_VAR 0 2
49659: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
49660: LD_INT 0
49662: PPUSH
49663: PPUSH
49664: PPUSH
49665: PPUSH
49666: PPUSH
// if not area or not rate or not max then
49667: LD_VAR 0 1
49671: NOT
49672: PUSH
49673: LD_VAR 0 2
49677: NOT
49678: OR
49679: PUSH
49680: LD_VAR 0 4
49684: NOT
49685: OR
49686: IFFALSE 49690
// exit ;
49688: GO 49882
// while 1 do
49690: LD_INT 1
49692: IFFALSE 49882
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
49694: LD_ADDR_VAR 0 9
49698: PUSH
49699: LD_VAR 0 1
49703: PPUSH
49704: LD_INT 1
49706: PPUSH
49707: CALL_OW 287
49711: PUSH
49712: LD_INT 10
49714: MUL
49715: ST_TO_ADDR
// r := rate / 10 ;
49716: LD_ADDR_VAR 0 7
49720: PUSH
49721: LD_VAR 0 2
49725: PUSH
49726: LD_INT 10
49728: DIVREAL
49729: ST_TO_ADDR
// time := 1 1$00 ;
49730: LD_ADDR_VAR 0 8
49734: PUSH
49735: LD_INT 2100
49737: ST_TO_ADDR
// if amount < min then
49738: LD_VAR 0 9
49742: PUSH
49743: LD_VAR 0 3
49747: LESS
49748: IFFALSE 49766
// r := r * 2 else
49750: LD_ADDR_VAR 0 7
49754: PUSH
49755: LD_VAR 0 7
49759: PUSH
49760: LD_INT 2
49762: MUL
49763: ST_TO_ADDR
49764: GO 49792
// if amount > max then
49766: LD_VAR 0 9
49770: PUSH
49771: LD_VAR 0 4
49775: GREATER
49776: IFFALSE 49792
// r := r / 2 ;
49778: LD_ADDR_VAR 0 7
49782: PUSH
49783: LD_VAR 0 7
49787: PUSH
49788: LD_INT 2
49790: DIVREAL
49791: ST_TO_ADDR
// time := time / r ;
49792: LD_ADDR_VAR 0 8
49796: PUSH
49797: LD_VAR 0 8
49801: PUSH
49802: LD_VAR 0 7
49806: DIVREAL
49807: ST_TO_ADDR
// if time < 0 then
49808: LD_VAR 0 8
49812: PUSH
49813: LD_INT 0
49815: LESS
49816: IFFALSE 49833
// time := time * - 1 ;
49818: LD_ADDR_VAR 0 8
49822: PUSH
49823: LD_VAR 0 8
49827: PUSH
49828: LD_INT 1
49830: NEG
49831: MUL
49832: ST_TO_ADDR
// wait ( time ) ;
49833: LD_VAR 0 8
49837: PPUSH
49838: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
49842: LD_INT 35
49844: PPUSH
49845: LD_INT 875
49847: PPUSH
49848: CALL_OW 12
49852: PPUSH
49853: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
49857: LD_INT 1
49859: PPUSH
49860: LD_INT 5
49862: PPUSH
49863: CALL_OW 12
49867: PPUSH
49868: LD_VAR 0 1
49872: PPUSH
49873: LD_INT 1
49875: PPUSH
49876: CALL_OW 55
// end ;
49880: GO 49690
// end ;
49882: LD_VAR 0 5
49886: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
49887: LD_INT 0
49889: PPUSH
49890: PPUSH
49891: PPUSH
49892: PPUSH
49893: PPUSH
49894: PPUSH
49895: PPUSH
49896: PPUSH
// if not turrets or not factories then
49897: LD_VAR 0 1
49901: NOT
49902: PUSH
49903: LD_VAR 0 2
49907: NOT
49908: OR
49909: IFFALSE 49913
// exit ;
49911: GO 50220
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49913: LD_ADDR_VAR 0 10
49917: PUSH
49918: LD_INT 5
49920: PUSH
49921: LD_INT 6
49923: PUSH
49924: EMPTY
49925: LIST
49926: LIST
49927: PUSH
49928: LD_INT 2
49930: PUSH
49931: LD_INT 4
49933: PUSH
49934: EMPTY
49935: LIST
49936: LIST
49937: PUSH
49938: LD_INT 3
49940: PUSH
49941: LD_INT 5
49943: PUSH
49944: EMPTY
49945: LIST
49946: LIST
49947: PUSH
49948: EMPTY
49949: LIST
49950: LIST
49951: LIST
49952: PUSH
49953: LD_INT 24
49955: PUSH
49956: LD_INT 25
49958: PUSH
49959: EMPTY
49960: LIST
49961: LIST
49962: PUSH
49963: LD_INT 23
49965: PUSH
49966: LD_INT 27
49968: PUSH
49969: EMPTY
49970: LIST
49971: LIST
49972: PUSH
49973: EMPTY
49974: LIST
49975: LIST
49976: PUSH
49977: LD_INT 42
49979: PUSH
49980: LD_INT 43
49982: PUSH
49983: EMPTY
49984: LIST
49985: LIST
49986: PUSH
49987: LD_INT 44
49989: PUSH
49990: LD_INT 46
49992: PUSH
49993: EMPTY
49994: LIST
49995: LIST
49996: PUSH
49997: LD_INT 45
49999: PUSH
50000: LD_INT 47
50002: PUSH
50003: EMPTY
50004: LIST
50005: LIST
50006: PUSH
50007: EMPTY
50008: LIST
50009: LIST
50010: LIST
50011: PUSH
50012: EMPTY
50013: LIST
50014: LIST
50015: LIST
50016: ST_TO_ADDR
// result := [ ] ;
50017: LD_ADDR_VAR 0 3
50021: PUSH
50022: EMPTY
50023: ST_TO_ADDR
// for i in turrets do
50024: LD_ADDR_VAR 0 4
50028: PUSH
50029: LD_VAR 0 1
50033: PUSH
50034: FOR_IN
50035: IFFALSE 50218
// begin nat := GetNation ( i ) ;
50037: LD_ADDR_VAR 0 7
50041: PUSH
50042: LD_VAR 0 4
50046: PPUSH
50047: CALL_OW 248
50051: ST_TO_ADDR
// weapon := 0 ;
50052: LD_ADDR_VAR 0 8
50056: PUSH
50057: LD_INT 0
50059: ST_TO_ADDR
// if not nat then
50060: LD_VAR 0 7
50064: NOT
50065: IFFALSE 50069
// continue ;
50067: GO 50034
// for j in list [ nat ] do
50069: LD_ADDR_VAR 0 5
50073: PUSH
50074: LD_VAR 0 10
50078: PUSH
50079: LD_VAR 0 7
50083: ARRAY
50084: PUSH
50085: FOR_IN
50086: IFFALSE 50127
// if GetBWeapon ( i ) = j [ 1 ] then
50088: LD_VAR 0 4
50092: PPUSH
50093: CALL_OW 269
50097: PUSH
50098: LD_VAR 0 5
50102: PUSH
50103: LD_INT 1
50105: ARRAY
50106: EQUAL
50107: IFFALSE 50125
// begin weapon := j [ 2 ] ;
50109: LD_ADDR_VAR 0 8
50113: PUSH
50114: LD_VAR 0 5
50118: PUSH
50119: LD_INT 2
50121: ARRAY
50122: ST_TO_ADDR
// break ;
50123: GO 50127
// end ;
50125: GO 50085
50127: POP
50128: POP
// if not weapon then
50129: LD_VAR 0 8
50133: NOT
50134: IFFALSE 50138
// continue ;
50136: GO 50034
// for k in factories do
50138: LD_ADDR_VAR 0 6
50142: PUSH
50143: LD_VAR 0 2
50147: PUSH
50148: FOR_IN
50149: IFFALSE 50214
// begin weapons := AvailableWeaponList ( k ) ;
50151: LD_ADDR_VAR 0 9
50155: PUSH
50156: LD_VAR 0 6
50160: PPUSH
50161: CALL_OW 478
50165: ST_TO_ADDR
// if not weapons then
50166: LD_VAR 0 9
50170: NOT
50171: IFFALSE 50175
// continue ;
50173: GO 50148
// if weapon in weapons then
50175: LD_VAR 0 8
50179: PUSH
50180: LD_VAR 0 9
50184: IN
50185: IFFALSE 50212
// begin result := [ i , weapon ] ;
50187: LD_ADDR_VAR 0 3
50191: PUSH
50192: LD_VAR 0 4
50196: PUSH
50197: LD_VAR 0 8
50201: PUSH
50202: EMPTY
50203: LIST
50204: LIST
50205: ST_TO_ADDR
// exit ;
50206: POP
50207: POP
50208: POP
50209: POP
50210: GO 50220
// end ; end ;
50212: GO 50148
50214: POP
50215: POP
// end ;
50216: GO 50034
50218: POP
50219: POP
// end ;
50220: LD_VAR 0 3
50224: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50225: LD_INT 0
50227: PPUSH
// if not side or side > 8 then
50228: LD_VAR 0 3
50232: NOT
50233: PUSH
50234: LD_VAR 0 3
50238: PUSH
50239: LD_INT 8
50241: GREATER
50242: OR
50243: IFFALSE 50247
// exit ;
50245: GO 50306
// if not range then
50247: LD_VAR 0 4
50251: NOT
50252: IFFALSE 50263
// range := - 12 ;
50254: LD_ADDR_VAR 0 4
50258: PUSH
50259: LD_INT 12
50261: NEG
50262: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50263: LD_VAR 0 1
50267: PPUSH
50268: LD_VAR 0 2
50272: PPUSH
50273: LD_VAR 0 3
50277: PPUSH
50278: LD_VAR 0 4
50282: PPUSH
50283: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50287: LD_VAR 0 1
50291: PPUSH
50292: LD_VAR 0 2
50296: PPUSH
50297: LD_VAR 0 3
50301: PPUSH
50302: CALL_OW 331
// end ;
50306: LD_VAR 0 5
50310: RET
// export function Video ( mode ) ; begin
50311: LD_INT 0
50313: PPUSH
// ingame_video = mode ;
50314: LD_ADDR_OWVAR 52
50318: PUSH
50319: LD_VAR 0 1
50323: ST_TO_ADDR
// interface_hidden = mode ;
50324: LD_ADDR_OWVAR 54
50328: PUSH
50329: LD_VAR 0 1
50333: ST_TO_ADDR
// end ;
50334: LD_VAR 0 2
50338: RET
// export function Join ( array , element ) ; begin
50339: LD_INT 0
50341: PPUSH
// result := Replace ( array , array + 1 , element ) ;
50342: LD_ADDR_VAR 0 3
50346: PUSH
50347: LD_VAR 0 1
50351: PPUSH
50352: LD_VAR 0 1
50356: PUSH
50357: LD_INT 1
50359: PLUS
50360: PPUSH
50361: LD_VAR 0 2
50365: PPUSH
50366: CALL_OW 1
50370: ST_TO_ADDR
// end ;
50371: LD_VAR 0 3
50375: RET
// export function JoinUnion ( array , element ) ; begin
50376: LD_INT 0
50378: PPUSH
// result := array union element ;
50379: LD_ADDR_VAR 0 3
50383: PUSH
50384: LD_VAR 0 1
50388: PUSH
50389: LD_VAR 0 2
50393: UNION
50394: ST_TO_ADDR
// end ;
50395: LD_VAR 0 3
50399: RET
// export function GetBehemoths ( side ) ; begin
50400: LD_INT 0
50402: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
50403: LD_ADDR_VAR 0 2
50407: PUSH
50408: LD_INT 22
50410: PUSH
50411: LD_VAR 0 1
50415: PUSH
50416: EMPTY
50417: LIST
50418: LIST
50419: PUSH
50420: LD_INT 31
50422: PUSH
50423: LD_INT 25
50425: PUSH
50426: EMPTY
50427: LIST
50428: LIST
50429: PUSH
50430: EMPTY
50431: LIST
50432: LIST
50433: PPUSH
50434: CALL_OW 69
50438: ST_TO_ADDR
// end ;
50439: LD_VAR 0 2
50443: RET
// export function Shuffle ( array ) ; var i , index ; begin
50444: LD_INT 0
50446: PPUSH
50447: PPUSH
50448: PPUSH
// result := [ ] ;
50449: LD_ADDR_VAR 0 2
50453: PUSH
50454: EMPTY
50455: ST_TO_ADDR
// if not array then
50456: LD_VAR 0 1
50460: NOT
50461: IFFALSE 50465
// exit ;
50463: GO 50564
// Randomize ;
50465: CALL_OW 10
// for i = array downto 1 do
50469: LD_ADDR_VAR 0 3
50473: PUSH
50474: DOUBLE
50475: LD_VAR 0 1
50479: INC
50480: ST_TO_ADDR
50481: LD_INT 1
50483: PUSH
50484: FOR_DOWNTO
50485: IFFALSE 50562
// begin index := rand ( 1 , array ) ;
50487: LD_ADDR_VAR 0 4
50491: PUSH
50492: LD_INT 1
50494: PPUSH
50495: LD_VAR 0 1
50499: PPUSH
50500: CALL_OW 12
50504: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
50505: LD_ADDR_VAR 0 2
50509: PUSH
50510: LD_VAR 0 2
50514: PPUSH
50515: LD_VAR 0 2
50519: PUSH
50520: LD_INT 1
50522: PLUS
50523: PPUSH
50524: LD_VAR 0 1
50528: PUSH
50529: LD_VAR 0 4
50533: ARRAY
50534: PPUSH
50535: CALL_OW 2
50539: ST_TO_ADDR
// array := Delete ( array , index ) ;
50540: LD_ADDR_VAR 0 1
50544: PUSH
50545: LD_VAR 0 1
50549: PPUSH
50550: LD_VAR 0 4
50554: PPUSH
50555: CALL_OW 3
50559: ST_TO_ADDR
// end ;
50560: GO 50484
50562: POP
50563: POP
// end ;
50564: LD_VAR 0 2
50568: RET
// export function GetBaseMaterials ( base ) ; begin
50569: LD_INT 0
50571: PPUSH
// result := [ 0 , 0 , 0 ] ;
50572: LD_ADDR_VAR 0 2
50576: PUSH
50577: LD_INT 0
50579: PUSH
50580: LD_INT 0
50582: PUSH
50583: LD_INT 0
50585: PUSH
50586: EMPTY
50587: LIST
50588: LIST
50589: LIST
50590: ST_TO_ADDR
// if not base then
50591: LD_VAR 0 1
50595: NOT
50596: IFFALSE 50600
// exit ;
50598: GO 50649
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
50600: LD_ADDR_VAR 0 2
50604: PUSH
50605: LD_VAR 0 1
50609: PPUSH
50610: LD_INT 1
50612: PPUSH
50613: CALL_OW 275
50617: PUSH
50618: LD_VAR 0 1
50622: PPUSH
50623: LD_INT 2
50625: PPUSH
50626: CALL_OW 275
50630: PUSH
50631: LD_VAR 0 1
50635: PPUSH
50636: LD_INT 3
50638: PPUSH
50639: CALL_OW 275
50643: PUSH
50644: EMPTY
50645: LIST
50646: LIST
50647: LIST
50648: ST_TO_ADDR
// end ;
50649: LD_VAR 0 2
50653: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
50654: LD_INT 0
50656: PPUSH
50657: PPUSH
// result := array ;
50658: LD_ADDR_VAR 0 3
50662: PUSH
50663: LD_VAR 0 1
50667: ST_TO_ADDR
// if size > 0 then
50668: LD_VAR 0 2
50672: PUSH
50673: LD_INT 0
50675: GREATER
50676: IFFALSE 50722
// for i := array downto size do
50678: LD_ADDR_VAR 0 4
50682: PUSH
50683: DOUBLE
50684: LD_VAR 0 1
50688: INC
50689: ST_TO_ADDR
50690: LD_VAR 0 2
50694: PUSH
50695: FOR_DOWNTO
50696: IFFALSE 50720
// result := Delete ( result , result ) ;
50698: LD_ADDR_VAR 0 3
50702: PUSH
50703: LD_VAR 0 3
50707: PPUSH
50708: LD_VAR 0 3
50712: PPUSH
50713: CALL_OW 3
50717: ST_TO_ADDR
50718: GO 50695
50720: POP
50721: POP
// end ;
50722: LD_VAR 0 3
50726: RET
// export function ComExit ( unit ) ; var tmp ; begin
50727: LD_INT 0
50729: PPUSH
50730: PPUSH
// if not IsInUnit ( unit ) then
50731: LD_VAR 0 1
50735: PPUSH
50736: CALL_OW 310
50740: NOT
50741: IFFALSE 50745
// exit ;
50743: GO 50805
// tmp := IsInUnit ( unit ) ;
50745: LD_ADDR_VAR 0 3
50749: PUSH
50750: LD_VAR 0 1
50754: PPUSH
50755: CALL_OW 310
50759: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
50760: LD_VAR 0 3
50764: PPUSH
50765: CALL_OW 247
50769: PUSH
50770: LD_INT 2
50772: EQUAL
50773: IFFALSE 50786
// ComExitVehicle ( unit ) else
50775: LD_VAR 0 1
50779: PPUSH
50780: CALL_OW 121
50784: GO 50795
// ComExitBuilding ( unit ) ;
50786: LD_VAR 0 1
50790: PPUSH
50791: CALL_OW 122
// result := tmp ;
50795: LD_ADDR_VAR 0 2
50799: PUSH
50800: LD_VAR 0 3
50804: ST_TO_ADDR
// end ;
50805: LD_VAR 0 2
50809: RET
// export function ComExitAll ( units ) ; var i ; begin
50810: LD_INT 0
50812: PPUSH
50813: PPUSH
// if not units then
50814: LD_VAR 0 1
50818: NOT
50819: IFFALSE 50823
// exit ;
50821: GO 50849
// for i in units do
50823: LD_ADDR_VAR 0 3
50827: PUSH
50828: LD_VAR 0 1
50832: PUSH
50833: FOR_IN
50834: IFFALSE 50847
// ComExit ( i ) ;
50836: LD_VAR 0 3
50840: PPUSH
50841: CALL 50727 0 1
50845: GO 50833
50847: POP
50848: POP
// end ;
50849: LD_VAR 0 2
50853: RET
// export function ResetHc ; begin
50854: LD_INT 0
50856: PPUSH
// InitHc ;
50857: CALL_OW 19
// hc_importance := 0 ;
50861: LD_ADDR_OWVAR 32
50865: PUSH
50866: LD_INT 0
50868: ST_TO_ADDR
// end ;
50869: LD_VAR 0 1
50873: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
50874: LD_INT 0
50876: PPUSH
50877: PPUSH
50878: PPUSH
// _x := ( x1 + x2 ) div 2 ;
50879: LD_ADDR_VAR 0 6
50883: PUSH
50884: LD_VAR 0 1
50888: PUSH
50889: LD_VAR 0 3
50893: PLUS
50894: PUSH
50895: LD_INT 2
50897: DIV
50898: ST_TO_ADDR
// if _x < 0 then
50899: LD_VAR 0 6
50903: PUSH
50904: LD_INT 0
50906: LESS
50907: IFFALSE 50924
// _x := _x * - 1 ;
50909: LD_ADDR_VAR 0 6
50913: PUSH
50914: LD_VAR 0 6
50918: PUSH
50919: LD_INT 1
50921: NEG
50922: MUL
50923: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
50924: LD_ADDR_VAR 0 7
50928: PUSH
50929: LD_VAR 0 2
50933: PUSH
50934: LD_VAR 0 4
50938: PLUS
50939: PUSH
50940: LD_INT 2
50942: DIV
50943: ST_TO_ADDR
// if _y < 0 then
50944: LD_VAR 0 7
50948: PUSH
50949: LD_INT 0
50951: LESS
50952: IFFALSE 50969
// _y := _y * - 1 ;
50954: LD_ADDR_VAR 0 7
50958: PUSH
50959: LD_VAR 0 7
50963: PUSH
50964: LD_INT 1
50966: NEG
50967: MUL
50968: ST_TO_ADDR
// result := [ _x , _y ] ;
50969: LD_ADDR_VAR 0 5
50973: PUSH
50974: LD_VAR 0 6
50978: PUSH
50979: LD_VAR 0 7
50983: PUSH
50984: EMPTY
50985: LIST
50986: LIST
50987: ST_TO_ADDR
// end ;
50988: LD_VAR 0 5
50992: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
50993: LD_INT 0
50995: PPUSH
50996: PPUSH
50997: PPUSH
50998: PPUSH
// task := GetTaskList ( unit ) ;
50999: LD_ADDR_VAR 0 7
51003: PUSH
51004: LD_VAR 0 1
51008: PPUSH
51009: CALL_OW 437
51013: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
51014: LD_VAR 0 7
51018: NOT
51019: PUSH
51020: LD_VAR 0 1
51024: PPUSH
51025: LD_VAR 0 2
51029: PPUSH
51030: CALL_OW 308
51034: NOT
51035: AND
51036: IFFALSE 51040
// exit ;
51038: GO 51158
// if IsInArea ( unit , area ) then
51040: LD_VAR 0 1
51044: PPUSH
51045: LD_VAR 0 2
51049: PPUSH
51050: CALL_OW 308
51054: IFFALSE 51072
// begin ComMoveToArea ( unit , goAway ) ;
51056: LD_VAR 0 1
51060: PPUSH
51061: LD_VAR 0 3
51065: PPUSH
51066: CALL_OW 113
// exit ;
51070: GO 51158
// end ; if task [ 1 ] [ 1 ] <> M then
51072: LD_VAR 0 7
51076: PUSH
51077: LD_INT 1
51079: ARRAY
51080: PUSH
51081: LD_INT 1
51083: ARRAY
51084: PUSH
51085: LD_STRING M
51087: NONEQUAL
51088: IFFALSE 51092
// exit ;
51090: GO 51158
// x := task [ 1 ] [ 2 ] ;
51092: LD_ADDR_VAR 0 5
51096: PUSH
51097: LD_VAR 0 7
51101: PUSH
51102: LD_INT 1
51104: ARRAY
51105: PUSH
51106: LD_INT 2
51108: ARRAY
51109: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
51110: LD_ADDR_VAR 0 6
51114: PUSH
51115: LD_VAR 0 7
51119: PUSH
51120: LD_INT 1
51122: ARRAY
51123: PUSH
51124: LD_INT 3
51126: ARRAY
51127: ST_TO_ADDR
// if InArea ( x , y , area ) then
51128: LD_VAR 0 5
51132: PPUSH
51133: LD_VAR 0 6
51137: PPUSH
51138: LD_VAR 0 2
51142: PPUSH
51143: CALL_OW 309
51147: IFFALSE 51158
// ComStop ( unit ) ;
51149: LD_VAR 0 1
51153: PPUSH
51154: CALL_OW 141
// end ;
51158: LD_VAR 0 4
51162: RET
// export function Abs ( value ) ; begin
51163: LD_INT 0
51165: PPUSH
// result := value ;
51166: LD_ADDR_VAR 0 2
51170: PUSH
51171: LD_VAR 0 1
51175: ST_TO_ADDR
// if value < 0 then
51176: LD_VAR 0 1
51180: PUSH
51181: LD_INT 0
51183: LESS
51184: IFFALSE 51201
// result := value * - 1 ;
51186: LD_ADDR_VAR 0 2
51190: PUSH
51191: LD_VAR 0 1
51195: PUSH
51196: LD_INT 1
51198: NEG
51199: MUL
51200: ST_TO_ADDR
// end ;
51201: LD_VAR 0 2
51205: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
51206: LD_INT 0
51208: PPUSH
51209: PPUSH
51210: PPUSH
51211: PPUSH
51212: PPUSH
51213: PPUSH
51214: PPUSH
51215: PPUSH
// if not unit or not building then
51216: LD_VAR 0 1
51220: NOT
51221: PUSH
51222: LD_VAR 0 2
51226: NOT
51227: OR
51228: IFFALSE 51232
// exit ;
51230: GO 51458
// x := GetX ( building ) ;
51232: LD_ADDR_VAR 0 4
51236: PUSH
51237: LD_VAR 0 2
51241: PPUSH
51242: CALL_OW 250
51246: ST_TO_ADDR
// y := GetY ( building ) ;
51247: LD_ADDR_VAR 0 6
51251: PUSH
51252: LD_VAR 0 2
51256: PPUSH
51257: CALL_OW 251
51261: ST_TO_ADDR
// d := GetDir ( building ) ;
51262: LD_ADDR_VAR 0 8
51266: PUSH
51267: LD_VAR 0 2
51271: PPUSH
51272: CALL_OW 254
51276: ST_TO_ADDR
// r := 4 ;
51277: LD_ADDR_VAR 0 9
51281: PUSH
51282: LD_INT 4
51284: ST_TO_ADDR
// for i := 1 to 5 do
51285: LD_ADDR_VAR 0 10
51289: PUSH
51290: DOUBLE
51291: LD_INT 1
51293: DEC
51294: ST_TO_ADDR
51295: LD_INT 5
51297: PUSH
51298: FOR_TO
51299: IFFALSE 51456
// begin _x := ShiftX ( x , d , r + i ) ;
51301: LD_ADDR_VAR 0 5
51305: PUSH
51306: LD_VAR 0 4
51310: PPUSH
51311: LD_VAR 0 8
51315: PPUSH
51316: LD_VAR 0 9
51320: PUSH
51321: LD_VAR 0 10
51325: PLUS
51326: PPUSH
51327: CALL_OW 272
51331: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
51332: LD_ADDR_VAR 0 7
51336: PUSH
51337: LD_VAR 0 6
51341: PPUSH
51342: LD_VAR 0 8
51346: PPUSH
51347: LD_VAR 0 9
51351: PUSH
51352: LD_VAR 0 10
51356: PLUS
51357: PPUSH
51358: CALL_OW 273
51362: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
51363: LD_VAR 0 5
51367: PPUSH
51368: LD_VAR 0 7
51372: PPUSH
51373: CALL_OW 488
51377: PUSH
51378: LD_VAR 0 5
51382: PPUSH
51383: LD_VAR 0 7
51387: PPUSH
51388: CALL_OW 428
51392: PPUSH
51393: CALL_OW 247
51397: PUSH
51398: LD_INT 3
51400: PUSH
51401: LD_INT 2
51403: PUSH
51404: EMPTY
51405: LIST
51406: LIST
51407: IN
51408: NOT
51409: AND
51410: IFFALSE 51454
// begin ComMoveXY ( unit , _x , _y ) ;
51412: LD_VAR 0 1
51416: PPUSH
51417: LD_VAR 0 5
51421: PPUSH
51422: LD_VAR 0 7
51426: PPUSH
51427: CALL_OW 111
// result := [ _x , _y ] ;
51431: LD_ADDR_VAR 0 3
51435: PUSH
51436: LD_VAR 0 5
51440: PUSH
51441: LD_VAR 0 7
51445: PUSH
51446: EMPTY
51447: LIST
51448: LIST
51449: ST_TO_ADDR
// exit ;
51450: POP
51451: POP
51452: GO 51458
// end ; end ;
51454: GO 51298
51456: POP
51457: POP
// end ;
51458: LD_VAR 0 3
51462: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
51463: LD_INT 0
51465: PPUSH
51466: PPUSH
51467: PPUSH
// result := 0 ;
51468: LD_ADDR_VAR 0 3
51472: PUSH
51473: LD_INT 0
51475: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
51476: LD_VAR 0 1
51480: PUSH
51481: LD_INT 0
51483: LESS
51484: PUSH
51485: LD_VAR 0 1
51489: PUSH
51490: LD_INT 8
51492: GREATER
51493: OR
51494: PUSH
51495: LD_VAR 0 2
51499: PUSH
51500: LD_INT 0
51502: LESS
51503: OR
51504: PUSH
51505: LD_VAR 0 2
51509: PUSH
51510: LD_INT 8
51512: GREATER
51513: OR
51514: IFFALSE 51518
// exit ;
51516: GO 51593
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
51518: LD_ADDR_VAR 0 4
51522: PUSH
51523: LD_INT 22
51525: PUSH
51526: LD_VAR 0 2
51530: PUSH
51531: EMPTY
51532: LIST
51533: LIST
51534: PPUSH
51535: CALL_OW 69
51539: PUSH
51540: FOR_IN
51541: IFFALSE 51591
// begin un := UnitShoot ( i ) ;
51543: LD_ADDR_VAR 0 5
51547: PUSH
51548: LD_VAR 0 4
51552: PPUSH
51553: CALL_OW 504
51557: ST_TO_ADDR
// if GetSide ( un ) = side1 then
51558: LD_VAR 0 5
51562: PPUSH
51563: CALL_OW 255
51567: PUSH
51568: LD_VAR 0 1
51572: EQUAL
51573: IFFALSE 51589
// begin result := un ;
51575: LD_ADDR_VAR 0 3
51579: PUSH
51580: LD_VAR 0 5
51584: ST_TO_ADDR
// exit ;
51585: POP
51586: POP
51587: GO 51593
// end ; end ;
51589: GO 51540
51591: POP
51592: POP
// end ;
51593: LD_VAR 0 3
51597: RET
// export function GetCargoBay ( units ) ; begin
51598: LD_INT 0
51600: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
51601: LD_ADDR_VAR 0 2
51605: PUSH
51606: LD_VAR 0 1
51610: PPUSH
51611: LD_INT 2
51613: PUSH
51614: LD_INT 34
51616: PUSH
51617: LD_INT 12
51619: PUSH
51620: EMPTY
51621: LIST
51622: LIST
51623: PUSH
51624: LD_INT 34
51626: PUSH
51627: LD_INT 51
51629: PUSH
51630: EMPTY
51631: LIST
51632: LIST
51633: PUSH
51634: LD_INT 34
51636: PUSH
51637: LD_INT 32
51639: PUSH
51640: EMPTY
51641: LIST
51642: LIST
51643: PUSH
51644: LD_INT 34
51646: PUSH
51647: LD_EXP 49
51651: PUSH
51652: EMPTY
51653: LIST
51654: LIST
51655: PUSH
51656: EMPTY
51657: LIST
51658: LIST
51659: LIST
51660: LIST
51661: LIST
51662: PPUSH
51663: CALL_OW 72
51667: ST_TO_ADDR
// end ;
51668: LD_VAR 0 2
51672: RET
// export function Negate ( value ) ; begin
51673: LD_INT 0
51675: PPUSH
// result := not value ;
51676: LD_ADDR_VAR 0 2
51680: PUSH
51681: LD_VAR 0 1
51685: NOT
51686: ST_TO_ADDR
// end ;
51687: LD_VAR 0 2
51691: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
51692: LD_INT 0
51694: PPUSH
// if x1 = x2 then
51695: LD_VAR 0 1
51699: PUSH
51700: LD_VAR 0 3
51704: EQUAL
51705: IFFALSE 51739
// begin if y1 > y2 then
51707: LD_VAR 0 2
51711: PUSH
51712: LD_VAR 0 4
51716: GREATER
51717: IFFALSE 51729
// result := 0 else
51719: LD_ADDR_VAR 0 5
51723: PUSH
51724: LD_INT 0
51726: ST_TO_ADDR
51727: GO 51737
// result := 3 ;
51729: LD_ADDR_VAR 0 5
51733: PUSH
51734: LD_INT 3
51736: ST_TO_ADDR
// exit ;
51737: GO 51825
// end ; if y1 = y2 then
51739: LD_VAR 0 2
51743: PUSH
51744: LD_VAR 0 4
51748: EQUAL
51749: IFFALSE 51783
// begin if x1 > x2 then
51751: LD_VAR 0 1
51755: PUSH
51756: LD_VAR 0 3
51760: GREATER
51761: IFFALSE 51773
// result := 1 else
51763: LD_ADDR_VAR 0 5
51767: PUSH
51768: LD_INT 1
51770: ST_TO_ADDR
51771: GO 51781
// result := 4 ;
51773: LD_ADDR_VAR 0 5
51777: PUSH
51778: LD_INT 4
51780: ST_TO_ADDR
// exit ;
51781: GO 51825
// end ; if x1 > x2 and y1 > y2 then
51783: LD_VAR 0 1
51787: PUSH
51788: LD_VAR 0 3
51792: GREATER
51793: PUSH
51794: LD_VAR 0 2
51798: PUSH
51799: LD_VAR 0 4
51803: GREATER
51804: AND
51805: IFFALSE 51817
// result := 2 else
51807: LD_ADDR_VAR 0 5
51811: PUSH
51812: LD_INT 2
51814: ST_TO_ADDR
51815: GO 51825
// result := 5 ;
51817: LD_ADDR_VAR 0 5
51821: PUSH
51822: LD_INT 5
51824: ST_TO_ADDR
// end ;
51825: LD_VAR 0 5
51829: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
51830: LD_INT 0
51832: PPUSH
51833: PPUSH
// if not driver or not IsInUnit ( driver ) then
51834: LD_VAR 0 1
51838: NOT
51839: PUSH
51840: LD_VAR 0 1
51844: PPUSH
51845: CALL_OW 310
51849: NOT
51850: OR
51851: IFFALSE 51855
// exit ;
51853: GO 51945
// vehicle := IsInUnit ( driver ) ;
51855: LD_ADDR_VAR 0 3
51859: PUSH
51860: LD_VAR 0 1
51864: PPUSH
51865: CALL_OW 310
51869: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
51870: LD_VAR 0 1
51874: PPUSH
51875: LD_STRING \
51877: PUSH
51878: LD_INT 0
51880: PUSH
51881: LD_INT 0
51883: PUSH
51884: LD_INT 0
51886: PUSH
51887: LD_INT 0
51889: PUSH
51890: LD_INT 0
51892: PUSH
51893: LD_INT 0
51895: PUSH
51896: EMPTY
51897: LIST
51898: LIST
51899: LIST
51900: LIST
51901: LIST
51902: LIST
51903: LIST
51904: PUSH
51905: LD_STRING E
51907: PUSH
51908: LD_INT 0
51910: PUSH
51911: LD_INT 0
51913: PUSH
51914: LD_VAR 0 3
51918: PUSH
51919: LD_INT 0
51921: PUSH
51922: LD_INT 0
51924: PUSH
51925: LD_INT 0
51927: PUSH
51928: EMPTY
51929: LIST
51930: LIST
51931: LIST
51932: LIST
51933: LIST
51934: LIST
51935: LIST
51936: PUSH
51937: EMPTY
51938: LIST
51939: LIST
51940: PPUSH
51941: CALL_OW 446
// end ;
51945: LD_VAR 0 2
51949: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
51950: LD_INT 0
51952: PPUSH
51953: PPUSH
// if not driver or not IsInUnit ( driver ) then
51954: LD_VAR 0 1
51958: NOT
51959: PUSH
51960: LD_VAR 0 1
51964: PPUSH
51965: CALL_OW 310
51969: NOT
51970: OR
51971: IFFALSE 51975
// exit ;
51973: GO 52065
// vehicle := IsInUnit ( driver ) ;
51975: LD_ADDR_VAR 0 3
51979: PUSH
51980: LD_VAR 0 1
51984: PPUSH
51985: CALL_OW 310
51989: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
51990: LD_VAR 0 1
51994: PPUSH
51995: LD_STRING \
51997: PUSH
51998: LD_INT 0
52000: PUSH
52001: LD_INT 0
52003: PUSH
52004: LD_INT 0
52006: PUSH
52007: LD_INT 0
52009: PUSH
52010: LD_INT 0
52012: PUSH
52013: LD_INT 0
52015: PUSH
52016: EMPTY
52017: LIST
52018: LIST
52019: LIST
52020: LIST
52021: LIST
52022: LIST
52023: LIST
52024: PUSH
52025: LD_STRING E
52027: PUSH
52028: LD_INT 0
52030: PUSH
52031: LD_INT 0
52033: PUSH
52034: LD_VAR 0 3
52038: PUSH
52039: LD_INT 0
52041: PUSH
52042: LD_INT 0
52044: PUSH
52045: LD_INT 0
52047: PUSH
52048: EMPTY
52049: LIST
52050: LIST
52051: LIST
52052: LIST
52053: LIST
52054: LIST
52055: LIST
52056: PUSH
52057: EMPTY
52058: LIST
52059: LIST
52060: PPUSH
52061: CALL_OW 447
// end ;
52065: LD_VAR 0 2
52069: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
52070: LD_INT 0
52072: PPUSH
52073: PPUSH
52074: PPUSH
// tmp := [ ] ;
52075: LD_ADDR_VAR 0 5
52079: PUSH
52080: EMPTY
52081: ST_TO_ADDR
// for i in units do
52082: LD_ADDR_VAR 0 4
52086: PUSH
52087: LD_VAR 0 1
52091: PUSH
52092: FOR_IN
52093: IFFALSE 52131
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
52095: LD_ADDR_VAR 0 5
52099: PUSH
52100: LD_VAR 0 5
52104: PPUSH
52105: LD_VAR 0 5
52109: PUSH
52110: LD_INT 1
52112: PLUS
52113: PPUSH
52114: LD_VAR 0 4
52118: PPUSH
52119: CALL_OW 256
52123: PPUSH
52124: CALL_OW 2
52128: ST_TO_ADDR
52129: GO 52092
52131: POP
52132: POP
// if not tmp then
52133: LD_VAR 0 5
52137: NOT
52138: IFFALSE 52142
// exit ;
52140: GO 52190
// if asc then
52142: LD_VAR 0 2
52146: IFFALSE 52170
// result := SortListByListAsc ( units , tmp ) else
52148: LD_ADDR_VAR 0 3
52152: PUSH
52153: LD_VAR 0 1
52157: PPUSH
52158: LD_VAR 0 5
52162: PPUSH
52163: CALL_OW 76
52167: ST_TO_ADDR
52168: GO 52190
// result := SortListByListDesc ( units , tmp ) ;
52170: LD_ADDR_VAR 0 3
52174: PUSH
52175: LD_VAR 0 1
52179: PPUSH
52180: LD_VAR 0 5
52184: PPUSH
52185: CALL_OW 77
52189: ST_TO_ADDR
// end ;
52190: LD_VAR 0 3
52194: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
52195: LD_INT 0
52197: PPUSH
52198: PPUSH
// task := GetTaskList ( mech ) ;
52199: LD_ADDR_VAR 0 4
52203: PUSH
52204: LD_VAR 0 1
52208: PPUSH
52209: CALL_OW 437
52213: ST_TO_ADDR
// if not task then
52214: LD_VAR 0 4
52218: NOT
52219: IFFALSE 52223
// exit ;
52221: GO 52265
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
52223: LD_ADDR_VAR 0 3
52227: PUSH
52228: LD_VAR 0 4
52232: PUSH
52233: LD_INT 1
52235: ARRAY
52236: PUSH
52237: LD_INT 1
52239: ARRAY
52240: PUSH
52241: LD_STRING r
52243: EQUAL
52244: PUSH
52245: LD_VAR 0 4
52249: PUSH
52250: LD_INT 1
52252: ARRAY
52253: PUSH
52254: LD_INT 4
52256: ARRAY
52257: PUSH
52258: LD_VAR 0 2
52262: EQUAL
52263: AND
52264: ST_TO_ADDR
// end ;
52265: LD_VAR 0 3
52269: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
52270: LD_INT 0
52272: PPUSH
// SetDir ( unit , d ) ;
52273: LD_VAR 0 1
52277: PPUSH
52278: LD_VAR 0 4
52282: PPUSH
52283: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
52287: LD_VAR 0 1
52291: PPUSH
52292: LD_VAR 0 2
52296: PPUSH
52297: LD_VAR 0 3
52301: PPUSH
52302: LD_VAR 0 5
52306: PPUSH
52307: CALL_OW 48
// end ;
52311: LD_VAR 0 6
52315: RET
// export function ToNaturalNumber ( number ) ; begin
52316: LD_INT 0
52318: PPUSH
// result := number div 1 ;
52319: LD_ADDR_VAR 0 2
52323: PUSH
52324: LD_VAR 0 1
52328: PUSH
52329: LD_INT 1
52331: DIV
52332: ST_TO_ADDR
// if number < 0 then
52333: LD_VAR 0 1
52337: PUSH
52338: LD_INT 0
52340: LESS
52341: IFFALSE 52351
// result := 0 ;
52343: LD_ADDR_VAR 0 2
52347: PUSH
52348: LD_INT 0
52350: ST_TO_ADDR
// end ;
52351: LD_VAR 0 2
52355: RET
// export function SortByClass ( units , class ) ; var un ; begin
52356: LD_INT 0
52358: PPUSH
52359: PPUSH
// if not units or not class then
52360: LD_VAR 0 1
52364: NOT
52365: PUSH
52366: LD_VAR 0 2
52370: NOT
52371: OR
52372: IFFALSE 52376
// exit ;
52374: GO 52471
// result := [ ] ;
52376: LD_ADDR_VAR 0 3
52380: PUSH
52381: EMPTY
52382: ST_TO_ADDR
// for un in units do
52383: LD_ADDR_VAR 0 4
52387: PUSH
52388: LD_VAR 0 1
52392: PUSH
52393: FOR_IN
52394: IFFALSE 52469
// if GetClass ( un ) = class then
52396: LD_VAR 0 4
52400: PPUSH
52401: CALL_OW 257
52405: PUSH
52406: LD_VAR 0 2
52410: EQUAL
52411: IFFALSE 52438
// result := Insert ( result , 1 , un ) else
52413: LD_ADDR_VAR 0 3
52417: PUSH
52418: LD_VAR 0 3
52422: PPUSH
52423: LD_INT 1
52425: PPUSH
52426: LD_VAR 0 4
52430: PPUSH
52431: CALL_OW 2
52435: ST_TO_ADDR
52436: GO 52467
// result := Replace ( result , result + 1 , un ) ;
52438: LD_ADDR_VAR 0 3
52442: PUSH
52443: LD_VAR 0 3
52447: PPUSH
52448: LD_VAR 0 3
52452: PUSH
52453: LD_INT 1
52455: PLUS
52456: PPUSH
52457: LD_VAR 0 4
52461: PPUSH
52462: CALL_OW 1
52466: ST_TO_ADDR
52467: GO 52393
52469: POP
52470: POP
// end ;
52471: LD_VAR 0 3
52475: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
52476: LD_INT 0
52478: PPUSH
52479: PPUSH
52480: PPUSH
52481: PPUSH
52482: PPUSH
52483: PPUSH
52484: PPUSH
// result := [ ] ;
52485: LD_ADDR_VAR 0 4
52489: PUSH
52490: EMPTY
52491: ST_TO_ADDR
// if x - r < 0 then
52492: LD_VAR 0 1
52496: PUSH
52497: LD_VAR 0 3
52501: MINUS
52502: PUSH
52503: LD_INT 0
52505: LESS
52506: IFFALSE 52518
// min_x := 0 else
52508: LD_ADDR_VAR 0 8
52512: PUSH
52513: LD_INT 0
52515: ST_TO_ADDR
52516: GO 52534
// min_x := x - r ;
52518: LD_ADDR_VAR 0 8
52522: PUSH
52523: LD_VAR 0 1
52527: PUSH
52528: LD_VAR 0 3
52532: MINUS
52533: ST_TO_ADDR
// if y - r < 0 then
52534: LD_VAR 0 2
52538: PUSH
52539: LD_VAR 0 3
52543: MINUS
52544: PUSH
52545: LD_INT 0
52547: LESS
52548: IFFALSE 52560
// min_y := 0 else
52550: LD_ADDR_VAR 0 7
52554: PUSH
52555: LD_INT 0
52557: ST_TO_ADDR
52558: GO 52576
// min_y := y - r ;
52560: LD_ADDR_VAR 0 7
52564: PUSH
52565: LD_VAR 0 2
52569: PUSH
52570: LD_VAR 0 3
52574: MINUS
52575: ST_TO_ADDR
// max_x := x + r ;
52576: LD_ADDR_VAR 0 9
52580: PUSH
52581: LD_VAR 0 1
52585: PUSH
52586: LD_VAR 0 3
52590: PLUS
52591: ST_TO_ADDR
// max_y := y + r ;
52592: LD_ADDR_VAR 0 10
52596: PUSH
52597: LD_VAR 0 2
52601: PUSH
52602: LD_VAR 0 3
52606: PLUS
52607: ST_TO_ADDR
// for _x = min_x to max_x do
52608: LD_ADDR_VAR 0 5
52612: PUSH
52613: DOUBLE
52614: LD_VAR 0 8
52618: DEC
52619: ST_TO_ADDR
52620: LD_VAR 0 9
52624: PUSH
52625: FOR_TO
52626: IFFALSE 52727
// for _y = min_y to max_y do
52628: LD_ADDR_VAR 0 6
52632: PUSH
52633: DOUBLE
52634: LD_VAR 0 7
52638: DEC
52639: ST_TO_ADDR
52640: LD_VAR 0 10
52644: PUSH
52645: FOR_TO
52646: IFFALSE 52723
// begin if not ValidHex ( _x , _y ) then
52648: LD_VAR 0 5
52652: PPUSH
52653: LD_VAR 0 6
52657: PPUSH
52658: CALL_OW 488
52662: NOT
52663: IFFALSE 52667
// continue ;
52665: GO 52645
// if GetResourceTypeXY ( _x , _y ) then
52667: LD_VAR 0 5
52671: PPUSH
52672: LD_VAR 0 6
52676: PPUSH
52677: CALL_OW 283
52681: IFFALSE 52721
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
52683: LD_ADDR_VAR 0 4
52687: PUSH
52688: LD_VAR 0 4
52692: PPUSH
52693: LD_VAR 0 4
52697: PUSH
52698: LD_INT 1
52700: PLUS
52701: PPUSH
52702: LD_VAR 0 5
52706: PUSH
52707: LD_VAR 0 6
52711: PUSH
52712: EMPTY
52713: LIST
52714: LIST
52715: PPUSH
52716: CALL_OW 1
52720: ST_TO_ADDR
// end ;
52721: GO 52645
52723: POP
52724: POP
52725: GO 52625
52727: POP
52728: POP
// end ;
52729: LD_VAR 0 4
52733: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
52734: LD_INT 0
52736: PPUSH
52737: PPUSH
52738: PPUSH
52739: PPUSH
52740: PPUSH
52741: PPUSH
// if not units then
52742: LD_VAR 0 1
52746: NOT
52747: IFFALSE 52751
// exit ;
52749: GO 53152
// result := UnitFilter ( units , [ f_ok ] ) ;
52751: LD_ADDR_VAR 0 3
52755: PUSH
52756: LD_VAR 0 1
52760: PPUSH
52761: LD_INT 50
52763: PUSH
52764: EMPTY
52765: LIST
52766: PPUSH
52767: CALL_OW 72
52771: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
52772: LD_ADDR_VAR 0 7
52776: PUSH
52777: LD_VAR 0 1
52781: PUSH
52782: LD_INT 1
52784: ARRAY
52785: PPUSH
52786: CALL_OW 255
52790: ST_TO_ADDR
// if not result then
52791: LD_VAR 0 3
52795: NOT
52796: IFFALSE 52800
// exit ;
52798: GO 53152
// for i in result do
52800: LD_ADDR_VAR 0 4
52804: PUSH
52805: LD_VAR 0 3
52809: PUSH
52810: FOR_IN
52811: IFFALSE 53150
// begin tag := GetTag ( i ) + 1 ;
52813: LD_ADDR_VAR 0 8
52817: PUSH
52818: LD_VAR 0 4
52822: PPUSH
52823: CALL_OW 110
52827: PUSH
52828: LD_INT 1
52830: PLUS
52831: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
52832: LD_ADDR_VAR 0 6
52836: PUSH
52837: LD_VAR 0 4
52841: PPUSH
52842: CALL_OW 250
52846: PPUSH
52847: LD_VAR 0 4
52851: PPUSH
52852: CALL_OW 251
52856: PPUSH
52857: LD_INT 6
52859: PPUSH
52860: CALL 52476 0 3
52864: ST_TO_ADDR
// if cr then
52865: LD_VAR 0 6
52869: IFFALSE 52908
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
52871: LD_VAR 0 4
52875: PPUSH
52876: LD_VAR 0 6
52880: PUSH
52881: LD_INT 1
52883: ARRAY
52884: PUSH
52885: LD_INT 1
52887: ARRAY
52888: PPUSH
52889: LD_VAR 0 6
52893: PUSH
52894: LD_INT 1
52896: ARRAY
52897: PUSH
52898: LD_INT 2
52900: ARRAY
52901: PPUSH
52902: CALL_OW 116
52906: GO 53148
// if path > tag then
52908: LD_VAR 0 2
52912: PUSH
52913: LD_VAR 0 8
52917: GREATER
52918: IFFALSE 53096
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
52920: LD_ADDR_VAR 0 5
52924: PUSH
52925: LD_INT 81
52927: PUSH
52928: LD_VAR 0 7
52932: PUSH
52933: EMPTY
52934: LIST
52935: LIST
52936: PUSH
52937: LD_INT 91
52939: PUSH
52940: LD_VAR 0 4
52944: PUSH
52945: LD_INT 12
52947: PUSH
52948: EMPTY
52949: LIST
52950: LIST
52951: LIST
52952: PUSH
52953: EMPTY
52954: LIST
52955: LIST
52956: PPUSH
52957: CALL_OW 69
52961: ST_TO_ADDR
// if enemy then
52962: LD_VAR 0 5
52966: IFFALSE 52994
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
52968: LD_VAR 0 4
52972: PPUSH
52973: LD_VAR 0 5
52977: PPUSH
52978: LD_VAR 0 4
52982: PPUSH
52983: CALL_OW 74
52987: PPUSH
52988: CALL_OW 115
52992: GO 53094
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
52994: LD_VAR 0 4
52998: PPUSH
52999: LD_VAR 0 2
53003: PUSH
53004: LD_VAR 0 8
53008: ARRAY
53009: PUSH
53010: LD_INT 1
53012: ARRAY
53013: PPUSH
53014: LD_VAR 0 2
53018: PUSH
53019: LD_VAR 0 8
53023: ARRAY
53024: PUSH
53025: LD_INT 2
53027: ARRAY
53028: PPUSH
53029: CALL_OW 297
53033: PUSH
53034: LD_INT 6
53036: GREATER
53037: IFFALSE 53080
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
53039: LD_VAR 0 4
53043: PPUSH
53044: LD_VAR 0 2
53048: PUSH
53049: LD_VAR 0 8
53053: ARRAY
53054: PUSH
53055: LD_INT 1
53057: ARRAY
53058: PPUSH
53059: LD_VAR 0 2
53063: PUSH
53064: LD_VAR 0 8
53068: ARRAY
53069: PUSH
53070: LD_INT 2
53072: ARRAY
53073: PPUSH
53074: CALL_OW 114
53078: GO 53094
// SetTag ( i , tag ) ;
53080: LD_VAR 0 4
53084: PPUSH
53085: LD_VAR 0 8
53089: PPUSH
53090: CALL_OW 109
// end else
53094: GO 53148
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
53096: LD_ADDR_VAR 0 5
53100: PUSH
53101: LD_INT 81
53103: PUSH
53104: LD_VAR 0 7
53108: PUSH
53109: EMPTY
53110: LIST
53111: LIST
53112: PPUSH
53113: CALL_OW 69
53117: ST_TO_ADDR
// if enemy then
53118: LD_VAR 0 5
53122: IFFALSE 53148
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
53124: LD_VAR 0 4
53128: PPUSH
53129: LD_VAR 0 5
53133: PPUSH
53134: LD_VAR 0 4
53138: PPUSH
53139: CALL_OW 74
53143: PPUSH
53144: CALL_OW 115
// end ; end ;
53148: GO 52810
53150: POP
53151: POP
// end ; end_of_file
53152: LD_VAR 0 3
53156: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
53157: LD_INT 0
53159: PPUSH
// ar_miner := 81 ;
53160: LD_ADDR_EXP 55
53164: PUSH
53165: LD_INT 81
53167: ST_TO_ADDR
// ar_crane := 88 ;
53168: LD_ADDR_EXP 54
53172: PUSH
53173: LD_INT 88
53175: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
53176: LD_ADDR_EXP 49
53180: PUSH
53181: LD_INT 89
53183: ST_TO_ADDR
// us_hack := 99 ;
53184: LD_ADDR_EXP 50
53188: PUSH
53189: LD_INT 99
53191: ST_TO_ADDR
// us_artillery := 97 ;
53192: LD_ADDR_EXP 51
53196: PUSH
53197: LD_INT 97
53199: ST_TO_ADDR
// ar_bio_bomb := 91 ;
53200: LD_ADDR_EXP 52
53204: PUSH
53205: LD_INT 91
53207: ST_TO_ADDR
// ar_mortar := 92 ;
53208: LD_ADDR_EXP 53
53212: PUSH
53213: LD_INT 92
53215: ST_TO_ADDR
// ru_radar := 98 ;
53216: LD_ADDR_EXP 48
53220: PUSH
53221: LD_INT 98
53223: ST_TO_ADDR
// tech_Artillery := 80 ;
53224: LD_ADDR_EXP 56
53228: PUSH
53229: LD_INT 80
53231: ST_TO_ADDR
// tech_RadMat := 81 ;
53232: LD_ADDR_EXP 57
53236: PUSH
53237: LD_INT 81
53239: ST_TO_ADDR
// tech_BasicTools := 82 ;
53240: LD_ADDR_EXP 58
53244: PUSH
53245: LD_INT 82
53247: ST_TO_ADDR
// tech_Cargo := 83 ;
53248: LD_ADDR_EXP 59
53252: PUSH
53253: LD_INT 83
53255: ST_TO_ADDR
// tech_Track := 84 ;
53256: LD_ADDR_EXP 60
53260: PUSH
53261: LD_INT 84
53263: ST_TO_ADDR
// tech_Crane := 85 ;
53264: LD_ADDR_EXP 61
53268: PUSH
53269: LD_INT 85
53271: ST_TO_ADDR
// tech_Bulldozer := 86 ;
53272: LD_ADDR_EXP 62
53276: PUSH
53277: LD_INT 86
53279: ST_TO_ADDR
// tech_Hovercraft := 87 ;
53280: LD_ADDR_EXP 63
53284: PUSH
53285: LD_INT 87
53287: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
53288: LD_ADDR_EXP 64
53292: PUSH
53293: LD_INT 88
53295: ST_TO_ADDR
// class_mastodont := 31 ;
53296: LD_ADDR_EXP 65
53300: PUSH
53301: LD_INT 31
53303: ST_TO_ADDR
// class_horse := 21 ;
53304: LD_ADDR_EXP 66
53308: PUSH
53309: LD_INT 21
53311: ST_TO_ADDR
// end ;
53312: LD_VAR 0 1
53316: RET
// every 1 do
53317: GO 53319
53319: DISABLE
// InitGlobalVariables ; end_of_file
53320: CALL 53157 0 0
53324: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
53325: LD_INT 0
53327: PPUSH
53328: PPUSH
// skirmish := false ;
53329: LD_ADDR_EXP 67
53333: PUSH
53334: LD_INT 0
53336: ST_TO_ADDR
// debug_mc := false ;
53337: LD_ADDR_EXP 68
53341: PUSH
53342: LD_INT 0
53344: ST_TO_ADDR
// mc_bases := [ ] ;
53345: LD_ADDR_EXP 69
53349: PUSH
53350: EMPTY
53351: ST_TO_ADDR
// mc_sides := [ ] ;
53352: LD_ADDR_EXP 95
53356: PUSH
53357: EMPTY
53358: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
53359: LD_ADDR_EXP 70
53363: PUSH
53364: EMPTY
53365: ST_TO_ADDR
// mc_building_repairs := [ ] ;
53366: LD_ADDR_EXP 71
53370: PUSH
53371: EMPTY
53372: ST_TO_ADDR
// mc_need_heal := [ ] ;
53373: LD_ADDR_EXP 72
53377: PUSH
53378: EMPTY
53379: ST_TO_ADDR
// mc_healers := [ ] ;
53380: LD_ADDR_EXP 73
53384: PUSH
53385: EMPTY
53386: ST_TO_ADDR
// mc_build_list := [ ] ;
53387: LD_ADDR_EXP 74
53391: PUSH
53392: EMPTY
53393: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
53394: LD_ADDR_EXP 101
53398: PUSH
53399: EMPTY
53400: ST_TO_ADDR
// mc_builders := [ ] ;
53401: LD_ADDR_EXP 75
53405: PUSH
53406: EMPTY
53407: ST_TO_ADDR
// mc_construct_list := [ ] ;
53408: LD_ADDR_EXP 76
53412: PUSH
53413: EMPTY
53414: ST_TO_ADDR
// mc_turret_list := [ ] ;
53415: LD_ADDR_EXP 77
53419: PUSH
53420: EMPTY
53421: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
53422: LD_ADDR_EXP 78
53426: PUSH
53427: EMPTY
53428: ST_TO_ADDR
// mc_miners := [ ] ;
53429: LD_ADDR_EXP 83
53433: PUSH
53434: EMPTY
53435: ST_TO_ADDR
// mc_mines := [ ] ;
53436: LD_ADDR_EXP 82
53440: PUSH
53441: EMPTY
53442: ST_TO_ADDR
// mc_minefields := [ ] ;
53443: LD_ADDR_EXP 84
53447: PUSH
53448: EMPTY
53449: ST_TO_ADDR
// mc_crates := [ ] ;
53450: LD_ADDR_EXP 85
53454: PUSH
53455: EMPTY
53456: ST_TO_ADDR
// mc_crates_collector := [ ] ;
53457: LD_ADDR_EXP 86
53461: PUSH
53462: EMPTY
53463: ST_TO_ADDR
// mc_crates_area := [ ] ;
53464: LD_ADDR_EXP 87
53468: PUSH
53469: EMPTY
53470: ST_TO_ADDR
// mc_vehicles := [ ] ;
53471: LD_ADDR_EXP 88
53475: PUSH
53476: EMPTY
53477: ST_TO_ADDR
// mc_attack := [ ] ;
53478: LD_ADDR_EXP 89
53482: PUSH
53483: EMPTY
53484: ST_TO_ADDR
// mc_produce := [ ] ;
53485: LD_ADDR_EXP 90
53489: PUSH
53490: EMPTY
53491: ST_TO_ADDR
// mc_defender := [ ] ;
53492: LD_ADDR_EXP 91
53496: PUSH
53497: EMPTY
53498: ST_TO_ADDR
// mc_parking := [ ] ;
53499: LD_ADDR_EXP 93
53503: PUSH
53504: EMPTY
53505: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
53506: LD_ADDR_EXP 79
53510: PUSH
53511: EMPTY
53512: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
53513: LD_ADDR_EXP 81
53517: PUSH
53518: EMPTY
53519: ST_TO_ADDR
// mc_scan := [ ] ;
53520: LD_ADDR_EXP 92
53524: PUSH
53525: EMPTY
53526: ST_TO_ADDR
// mc_scan_area := [ ] ;
53527: LD_ADDR_EXP 94
53531: PUSH
53532: EMPTY
53533: ST_TO_ADDR
// mc_tech := [ ] ;
53534: LD_ADDR_EXP 96
53538: PUSH
53539: EMPTY
53540: ST_TO_ADDR
// mc_class := [ ] ;
53541: LD_ADDR_EXP 110
53545: PUSH
53546: EMPTY
53547: ST_TO_ADDR
// mc_class_case_use := [ ] ;
53548: LD_ADDR_EXP 111
53552: PUSH
53553: EMPTY
53554: ST_TO_ADDR
// mc_is_defending := [ ] ;
53555: LD_ADDR_EXP 112
53559: PUSH
53560: EMPTY
53561: ST_TO_ADDR
// end ;
53562: LD_VAR 0 1
53566: RET
// export function MC_Kill ( base ) ; begin
53567: LD_INT 0
53569: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
53570: LD_ADDR_EXP 69
53574: PUSH
53575: LD_EXP 69
53579: PPUSH
53580: LD_VAR 0 1
53584: PPUSH
53585: EMPTY
53586: PPUSH
53587: CALL_OW 1
53591: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53592: LD_ADDR_EXP 70
53596: PUSH
53597: LD_EXP 70
53601: PPUSH
53602: LD_VAR 0 1
53606: PPUSH
53607: EMPTY
53608: PPUSH
53609: CALL_OW 1
53613: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53614: LD_ADDR_EXP 71
53618: PUSH
53619: LD_EXP 71
53623: PPUSH
53624: LD_VAR 0 1
53628: PPUSH
53629: EMPTY
53630: PPUSH
53631: CALL_OW 1
53635: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53636: LD_ADDR_EXP 72
53640: PUSH
53641: LD_EXP 72
53645: PPUSH
53646: LD_VAR 0 1
53650: PPUSH
53651: EMPTY
53652: PPUSH
53653: CALL_OW 1
53657: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53658: LD_ADDR_EXP 73
53662: PUSH
53663: LD_EXP 73
53667: PPUSH
53668: LD_VAR 0 1
53672: PPUSH
53673: EMPTY
53674: PPUSH
53675: CALL_OW 1
53679: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53680: LD_ADDR_EXP 74
53684: PUSH
53685: LD_EXP 74
53689: PPUSH
53690: LD_VAR 0 1
53694: PPUSH
53695: EMPTY
53696: PPUSH
53697: CALL_OW 1
53701: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53702: LD_ADDR_EXP 75
53706: PUSH
53707: LD_EXP 75
53711: PPUSH
53712: LD_VAR 0 1
53716: PPUSH
53717: EMPTY
53718: PPUSH
53719: CALL_OW 1
53723: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53724: LD_ADDR_EXP 76
53728: PUSH
53729: LD_EXP 76
53733: PPUSH
53734: LD_VAR 0 1
53738: PPUSH
53739: EMPTY
53740: PPUSH
53741: CALL_OW 1
53745: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53746: LD_ADDR_EXP 77
53750: PUSH
53751: LD_EXP 77
53755: PPUSH
53756: LD_VAR 0 1
53760: PPUSH
53761: EMPTY
53762: PPUSH
53763: CALL_OW 1
53767: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53768: LD_ADDR_EXP 78
53772: PUSH
53773: LD_EXP 78
53777: PPUSH
53778: LD_VAR 0 1
53782: PPUSH
53783: EMPTY
53784: PPUSH
53785: CALL_OW 1
53789: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53790: LD_ADDR_EXP 79
53794: PUSH
53795: LD_EXP 79
53799: PPUSH
53800: LD_VAR 0 1
53804: PPUSH
53805: EMPTY
53806: PPUSH
53807: CALL_OW 1
53811: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53812: LD_ADDR_EXP 80
53816: PUSH
53817: LD_EXP 80
53821: PPUSH
53822: LD_VAR 0 1
53826: PPUSH
53827: LD_INT 0
53829: PPUSH
53830: CALL_OW 1
53834: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53835: LD_ADDR_EXP 81
53839: PUSH
53840: LD_EXP 81
53844: PPUSH
53845: LD_VAR 0 1
53849: PPUSH
53850: EMPTY
53851: PPUSH
53852: CALL_OW 1
53856: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53857: LD_ADDR_EXP 82
53861: PUSH
53862: LD_EXP 82
53866: PPUSH
53867: LD_VAR 0 1
53871: PPUSH
53872: EMPTY
53873: PPUSH
53874: CALL_OW 1
53878: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53879: LD_ADDR_EXP 83
53883: PUSH
53884: LD_EXP 83
53888: PPUSH
53889: LD_VAR 0 1
53893: PPUSH
53894: EMPTY
53895: PPUSH
53896: CALL_OW 1
53900: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53901: LD_ADDR_EXP 84
53905: PUSH
53906: LD_EXP 84
53910: PPUSH
53911: LD_VAR 0 1
53915: PPUSH
53916: EMPTY
53917: PPUSH
53918: CALL_OW 1
53922: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53923: LD_ADDR_EXP 85
53927: PUSH
53928: LD_EXP 85
53932: PPUSH
53933: LD_VAR 0 1
53937: PPUSH
53938: EMPTY
53939: PPUSH
53940: CALL_OW 1
53944: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53945: LD_ADDR_EXP 86
53949: PUSH
53950: LD_EXP 86
53954: PPUSH
53955: LD_VAR 0 1
53959: PPUSH
53960: EMPTY
53961: PPUSH
53962: CALL_OW 1
53966: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53967: LD_ADDR_EXP 87
53971: PUSH
53972: LD_EXP 87
53976: PPUSH
53977: LD_VAR 0 1
53981: PPUSH
53982: EMPTY
53983: PPUSH
53984: CALL_OW 1
53988: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53989: LD_ADDR_EXP 88
53993: PUSH
53994: LD_EXP 88
53998: PPUSH
53999: LD_VAR 0 1
54003: PPUSH
54004: EMPTY
54005: PPUSH
54006: CALL_OW 1
54010: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54011: LD_ADDR_EXP 89
54015: PUSH
54016: LD_EXP 89
54020: PPUSH
54021: LD_VAR 0 1
54025: PPUSH
54026: EMPTY
54027: PPUSH
54028: CALL_OW 1
54032: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54033: LD_ADDR_EXP 90
54037: PUSH
54038: LD_EXP 90
54042: PPUSH
54043: LD_VAR 0 1
54047: PPUSH
54048: EMPTY
54049: PPUSH
54050: CALL_OW 1
54054: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54055: LD_ADDR_EXP 91
54059: PUSH
54060: LD_EXP 91
54064: PPUSH
54065: LD_VAR 0 1
54069: PPUSH
54070: EMPTY
54071: PPUSH
54072: CALL_OW 1
54076: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54077: LD_ADDR_EXP 92
54081: PUSH
54082: LD_EXP 92
54086: PPUSH
54087: LD_VAR 0 1
54091: PPUSH
54092: EMPTY
54093: PPUSH
54094: CALL_OW 1
54098: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54099: LD_ADDR_EXP 93
54103: PUSH
54104: LD_EXP 93
54108: PPUSH
54109: LD_VAR 0 1
54113: PPUSH
54114: EMPTY
54115: PPUSH
54116: CALL_OW 1
54120: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54121: LD_ADDR_EXP 94
54125: PUSH
54126: LD_EXP 94
54130: PPUSH
54131: LD_VAR 0 1
54135: PPUSH
54136: EMPTY
54137: PPUSH
54138: CALL_OW 1
54142: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54143: LD_ADDR_EXP 96
54147: PUSH
54148: LD_EXP 96
54152: PPUSH
54153: LD_VAR 0 1
54157: PPUSH
54158: EMPTY
54159: PPUSH
54160: CALL_OW 1
54164: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54165: LD_ADDR_EXP 98
54169: PUSH
54170: LD_EXP 98
54174: PPUSH
54175: LD_VAR 0 1
54179: PPUSH
54180: EMPTY
54181: PPUSH
54182: CALL_OW 1
54186: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54187: LD_ADDR_EXP 99
54191: PUSH
54192: LD_EXP 99
54196: PPUSH
54197: LD_VAR 0 1
54201: PPUSH
54202: EMPTY
54203: PPUSH
54204: CALL_OW 1
54208: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54209: LD_ADDR_EXP 100
54213: PUSH
54214: LD_EXP 100
54218: PPUSH
54219: LD_VAR 0 1
54223: PPUSH
54224: EMPTY
54225: PPUSH
54226: CALL_OW 1
54230: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54231: LD_ADDR_EXP 101
54235: PUSH
54236: LD_EXP 101
54240: PPUSH
54241: LD_VAR 0 1
54245: PPUSH
54246: EMPTY
54247: PPUSH
54248: CALL_OW 1
54252: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54253: LD_ADDR_EXP 102
54257: PUSH
54258: LD_EXP 102
54262: PPUSH
54263: LD_VAR 0 1
54267: PPUSH
54268: EMPTY
54269: PPUSH
54270: CALL_OW 1
54274: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54275: LD_ADDR_EXP 103
54279: PUSH
54280: LD_EXP 103
54284: PPUSH
54285: LD_VAR 0 1
54289: PPUSH
54290: EMPTY
54291: PPUSH
54292: CALL_OW 1
54296: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54297: LD_ADDR_EXP 104
54301: PUSH
54302: LD_EXP 104
54306: PPUSH
54307: LD_VAR 0 1
54311: PPUSH
54312: EMPTY
54313: PPUSH
54314: CALL_OW 1
54318: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54319: LD_ADDR_EXP 105
54323: PUSH
54324: LD_EXP 105
54328: PPUSH
54329: LD_VAR 0 1
54333: PPUSH
54334: EMPTY
54335: PPUSH
54336: CALL_OW 1
54340: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54341: LD_ADDR_EXP 106
54345: PUSH
54346: LD_EXP 106
54350: PPUSH
54351: LD_VAR 0 1
54355: PPUSH
54356: EMPTY
54357: PPUSH
54358: CALL_OW 1
54362: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54363: LD_ADDR_EXP 107
54367: PUSH
54368: LD_EXP 107
54372: PPUSH
54373: LD_VAR 0 1
54377: PPUSH
54378: EMPTY
54379: PPUSH
54380: CALL_OW 1
54384: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54385: LD_ADDR_EXP 108
54389: PUSH
54390: LD_EXP 108
54394: PPUSH
54395: LD_VAR 0 1
54399: PPUSH
54400: EMPTY
54401: PPUSH
54402: CALL_OW 1
54406: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54407: LD_ADDR_EXP 109
54411: PUSH
54412: LD_EXP 109
54416: PPUSH
54417: LD_VAR 0 1
54421: PPUSH
54422: EMPTY
54423: PPUSH
54424: CALL_OW 1
54428: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54429: LD_ADDR_EXP 110
54433: PUSH
54434: LD_EXP 110
54438: PPUSH
54439: LD_VAR 0 1
54443: PPUSH
54444: EMPTY
54445: PPUSH
54446: CALL_OW 1
54450: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54451: LD_ADDR_EXP 111
54455: PUSH
54456: LD_EXP 111
54460: PPUSH
54461: LD_VAR 0 1
54465: PPUSH
54466: LD_INT 0
54468: PPUSH
54469: CALL_OW 1
54473: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
54474: LD_ADDR_EXP 112
54478: PUSH
54479: LD_EXP 112
54483: PPUSH
54484: LD_VAR 0 1
54488: PPUSH
54489: LD_INT 0
54491: PPUSH
54492: CALL_OW 1
54496: ST_TO_ADDR
// end ;
54497: LD_VAR 0 2
54501: RET
// export function MC_Add ( side , units ) ; var base ; begin
54502: LD_INT 0
54504: PPUSH
54505: PPUSH
// base := mc_bases + 1 ;
54506: LD_ADDR_VAR 0 4
54510: PUSH
54511: LD_EXP 69
54515: PUSH
54516: LD_INT 1
54518: PLUS
54519: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
54520: LD_ADDR_EXP 95
54524: PUSH
54525: LD_EXP 95
54529: PPUSH
54530: LD_VAR 0 4
54534: PPUSH
54535: LD_VAR 0 1
54539: PPUSH
54540: CALL_OW 1
54544: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
54545: LD_ADDR_EXP 69
54549: PUSH
54550: LD_EXP 69
54554: PPUSH
54555: LD_VAR 0 4
54559: PPUSH
54560: LD_VAR 0 2
54564: PPUSH
54565: CALL_OW 1
54569: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
54570: LD_ADDR_EXP 70
54574: PUSH
54575: LD_EXP 70
54579: PPUSH
54580: LD_VAR 0 4
54584: PPUSH
54585: EMPTY
54586: PPUSH
54587: CALL_OW 1
54591: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
54592: LD_ADDR_EXP 71
54596: PUSH
54597: LD_EXP 71
54601: PPUSH
54602: LD_VAR 0 4
54606: PPUSH
54607: EMPTY
54608: PPUSH
54609: CALL_OW 1
54613: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
54614: LD_ADDR_EXP 72
54618: PUSH
54619: LD_EXP 72
54623: PPUSH
54624: LD_VAR 0 4
54628: PPUSH
54629: EMPTY
54630: PPUSH
54631: CALL_OW 1
54635: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
54636: LD_ADDR_EXP 73
54640: PUSH
54641: LD_EXP 73
54645: PPUSH
54646: LD_VAR 0 4
54650: PPUSH
54651: EMPTY
54652: PPUSH
54653: CALL_OW 1
54657: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
54658: LD_ADDR_EXP 74
54662: PUSH
54663: LD_EXP 74
54667: PPUSH
54668: LD_VAR 0 4
54672: PPUSH
54673: EMPTY
54674: PPUSH
54675: CALL_OW 1
54679: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
54680: LD_ADDR_EXP 75
54684: PUSH
54685: LD_EXP 75
54689: PPUSH
54690: LD_VAR 0 4
54694: PPUSH
54695: EMPTY
54696: PPUSH
54697: CALL_OW 1
54701: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
54702: LD_ADDR_EXP 76
54706: PUSH
54707: LD_EXP 76
54711: PPUSH
54712: LD_VAR 0 4
54716: PPUSH
54717: EMPTY
54718: PPUSH
54719: CALL_OW 1
54723: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
54724: LD_ADDR_EXP 77
54728: PUSH
54729: LD_EXP 77
54733: PPUSH
54734: LD_VAR 0 4
54738: PPUSH
54739: EMPTY
54740: PPUSH
54741: CALL_OW 1
54745: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
54746: LD_ADDR_EXP 78
54750: PUSH
54751: LD_EXP 78
54755: PPUSH
54756: LD_VAR 0 4
54760: PPUSH
54761: EMPTY
54762: PPUSH
54763: CALL_OW 1
54767: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
54768: LD_ADDR_EXP 79
54772: PUSH
54773: LD_EXP 79
54777: PPUSH
54778: LD_VAR 0 4
54782: PPUSH
54783: EMPTY
54784: PPUSH
54785: CALL_OW 1
54789: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
54790: LD_ADDR_EXP 80
54794: PUSH
54795: LD_EXP 80
54799: PPUSH
54800: LD_VAR 0 4
54804: PPUSH
54805: LD_INT 0
54807: PPUSH
54808: CALL_OW 1
54812: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
54813: LD_ADDR_EXP 81
54817: PUSH
54818: LD_EXP 81
54822: PPUSH
54823: LD_VAR 0 4
54827: PPUSH
54828: EMPTY
54829: PPUSH
54830: CALL_OW 1
54834: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
54835: LD_ADDR_EXP 82
54839: PUSH
54840: LD_EXP 82
54844: PPUSH
54845: LD_VAR 0 4
54849: PPUSH
54850: EMPTY
54851: PPUSH
54852: CALL_OW 1
54856: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
54857: LD_ADDR_EXP 83
54861: PUSH
54862: LD_EXP 83
54866: PPUSH
54867: LD_VAR 0 4
54871: PPUSH
54872: EMPTY
54873: PPUSH
54874: CALL_OW 1
54878: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
54879: LD_ADDR_EXP 84
54883: PUSH
54884: LD_EXP 84
54888: PPUSH
54889: LD_VAR 0 4
54893: PPUSH
54894: EMPTY
54895: PPUSH
54896: CALL_OW 1
54900: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
54901: LD_ADDR_EXP 85
54905: PUSH
54906: LD_EXP 85
54910: PPUSH
54911: LD_VAR 0 4
54915: PPUSH
54916: EMPTY
54917: PPUSH
54918: CALL_OW 1
54922: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
54923: LD_ADDR_EXP 86
54927: PUSH
54928: LD_EXP 86
54932: PPUSH
54933: LD_VAR 0 4
54937: PPUSH
54938: EMPTY
54939: PPUSH
54940: CALL_OW 1
54944: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
54945: LD_ADDR_EXP 87
54949: PUSH
54950: LD_EXP 87
54954: PPUSH
54955: LD_VAR 0 4
54959: PPUSH
54960: EMPTY
54961: PPUSH
54962: CALL_OW 1
54966: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54967: LD_ADDR_EXP 88
54971: PUSH
54972: LD_EXP 88
54976: PPUSH
54977: LD_VAR 0 4
54981: PPUSH
54982: EMPTY
54983: PPUSH
54984: CALL_OW 1
54988: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54989: LD_ADDR_EXP 89
54993: PUSH
54994: LD_EXP 89
54998: PPUSH
54999: LD_VAR 0 4
55003: PPUSH
55004: EMPTY
55005: PPUSH
55006: CALL_OW 1
55010: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55011: LD_ADDR_EXP 90
55015: PUSH
55016: LD_EXP 90
55020: PPUSH
55021: LD_VAR 0 4
55025: PPUSH
55026: EMPTY
55027: PPUSH
55028: CALL_OW 1
55032: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55033: LD_ADDR_EXP 91
55037: PUSH
55038: LD_EXP 91
55042: PPUSH
55043: LD_VAR 0 4
55047: PPUSH
55048: EMPTY
55049: PPUSH
55050: CALL_OW 1
55054: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55055: LD_ADDR_EXP 92
55059: PUSH
55060: LD_EXP 92
55064: PPUSH
55065: LD_VAR 0 4
55069: PPUSH
55070: EMPTY
55071: PPUSH
55072: CALL_OW 1
55076: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55077: LD_ADDR_EXP 93
55081: PUSH
55082: LD_EXP 93
55086: PPUSH
55087: LD_VAR 0 4
55091: PPUSH
55092: EMPTY
55093: PPUSH
55094: CALL_OW 1
55098: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55099: LD_ADDR_EXP 94
55103: PUSH
55104: LD_EXP 94
55108: PPUSH
55109: LD_VAR 0 4
55113: PPUSH
55114: EMPTY
55115: PPUSH
55116: CALL_OW 1
55120: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55121: LD_ADDR_EXP 96
55125: PUSH
55126: LD_EXP 96
55130: PPUSH
55131: LD_VAR 0 4
55135: PPUSH
55136: EMPTY
55137: PPUSH
55138: CALL_OW 1
55142: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55143: LD_ADDR_EXP 98
55147: PUSH
55148: LD_EXP 98
55152: PPUSH
55153: LD_VAR 0 4
55157: PPUSH
55158: EMPTY
55159: PPUSH
55160: CALL_OW 1
55164: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55165: LD_ADDR_EXP 99
55169: PUSH
55170: LD_EXP 99
55174: PPUSH
55175: LD_VAR 0 4
55179: PPUSH
55180: EMPTY
55181: PPUSH
55182: CALL_OW 1
55186: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55187: LD_ADDR_EXP 100
55191: PUSH
55192: LD_EXP 100
55196: PPUSH
55197: LD_VAR 0 4
55201: PPUSH
55202: EMPTY
55203: PPUSH
55204: CALL_OW 1
55208: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55209: LD_ADDR_EXP 101
55213: PUSH
55214: LD_EXP 101
55218: PPUSH
55219: LD_VAR 0 4
55223: PPUSH
55224: EMPTY
55225: PPUSH
55226: CALL_OW 1
55230: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55231: LD_ADDR_EXP 102
55235: PUSH
55236: LD_EXP 102
55240: PPUSH
55241: LD_VAR 0 4
55245: PPUSH
55246: EMPTY
55247: PPUSH
55248: CALL_OW 1
55252: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55253: LD_ADDR_EXP 103
55257: PUSH
55258: LD_EXP 103
55262: PPUSH
55263: LD_VAR 0 4
55267: PPUSH
55268: EMPTY
55269: PPUSH
55270: CALL_OW 1
55274: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55275: LD_ADDR_EXP 104
55279: PUSH
55280: LD_EXP 104
55284: PPUSH
55285: LD_VAR 0 4
55289: PPUSH
55290: EMPTY
55291: PPUSH
55292: CALL_OW 1
55296: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55297: LD_ADDR_EXP 105
55301: PUSH
55302: LD_EXP 105
55306: PPUSH
55307: LD_VAR 0 4
55311: PPUSH
55312: EMPTY
55313: PPUSH
55314: CALL_OW 1
55318: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55319: LD_ADDR_EXP 106
55323: PUSH
55324: LD_EXP 106
55328: PPUSH
55329: LD_VAR 0 4
55333: PPUSH
55334: EMPTY
55335: PPUSH
55336: CALL_OW 1
55340: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55341: LD_ADDR_EXP 107
55345: PUSH
55346: LD_EXP 107
55350: PPUSH
55351: LD_VAR 0 4
55355: PPUSH
55356: EMPTY
55357: PPUSH
55358: CALL_OW 1
55362: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55363: LD_ADDR_EXP 108
55367: PUSH
55368: LD_EXP 108
55372: PPUSH
55373: LD_VAR 0 4
55377: PPUSH
55378: EMPTY
55379: PPUSH
55380: CALL_OW 1
55384: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55385: LD_ADDR_EXP 109
55389: PUSH
55390: LD_EXP 109
55394: PPUSH
55395: LD_VAR 0 4
55399: PPUSH
55400: EMPTY
55401: PPUSH
55402: CALL_OW 1
55406: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55407: LD_ADDR_EXP 110
55411: PUSH
55412: LD_EXP 110
55416: PPUSH
55417: LD_VAR 0 4
55421: PPUSH
55422: EMPTY
55423: PPUSH
55424: CALL_OW 1
55428: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55429: LD_ADDR_EXP 111
55433: PUSH
55434: LD_EXP 111
55438: PPUSH
55439: LD_VAR 0 4
55443: PPUSH
55444: LD_INT 0
55446: PPUSH
55447: CALL_OW 1
55451: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
55452: LD_ADDR_EXP 112
55456: PUSH
55457: LD_EXP 112
55461: PPUSH
55462: LD_VAR 0 4
55466: PPUSH
55467: LD_INT 0
55469: PPUSH
55470: CALL_OW 1
55474: ST_TO_ADDR
// result := base ;
55475: LD_ADDR_VAR 0 3
55479: PUSH
55480: LD_VAR 0 4
55484: ST_TO_ADDR
// end ;
55485: LD_VAR 0 3
55489: RET
// export function MC_Start ( ) ; var i ; begin
55490: LD_INT 0
55492: PPUSH
55493: PPUSH
// for i = 1 to mc_bases do
55494: LD_ADDR_VAR 0 2
55498: PUSH
55499: DOUBLE
55500: LD_INT 1
55502: DEC
55503: ST_TO_ADDR
55504: LD_EXP 69
55508: PUSH
55509: FOR_TO
55510: IFFALSE 56610
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
55512: LD_ADDR_EXP 69
55516: PUSH
55517: LD_EXP 69
55521: PPUSH
55522: LD_VAR 0 2
55526: PPUSH
55527: LD_EXP 69
55531: PUSH
55532: LD_VAR 0 2
55536: ARRAY
55537: PUSH
55538: LD_INT 0
55540: DIFF
55541: PPUSH
55542: CALL_OW 1
55546: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
55547: LD_ADDR_EXP 70
55551: PUSH
55552: LD_EXP 70
55556: PPUSH
55557: LD_VAR 0 2
55561: PPUSH
55562: EMPTY
55563: PPUSH
55564: CALL_OW 1
55568: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
55569: LD_ADDR_EXP 71
55573: PUSH
55574: LD_EXP 71
55578: PPUSH
55579: LD_VAR 0 2
55583: PPUSH
55584: EMPTY
55585: PPUSH
55586: CALL_OW 1
55590: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
55591: LD_ADDR_EXP 72
55595: PUSH
55596: LD_EXP 72
55600: PPUSH
55601: LD_VAR 0 2
55605: PPUSH
55606: EMPTY
55607: PPUSH
55608: CALL_OW 1
55612: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
55613: LD_ADDR_EXP 73
55617: PUSH
55618: LD_EXP 73
55622: PPUSH
55623: LD_VAR 0 2
55627: PPUSH
55628: EMPTY
55629: PUSH
55630: EMPTY
55631: PUSH
55632: EMPTY
55633: LIST
55634: LIST
55635: PPUSH
55636: CALL_OW 1
55640: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
55641: LD_ADDR_EXP 74
55645: PUSH
55646: LD_EXP 74
55650: PPUSH
55651: LD_VAR 0 2
55655: PPUSH
55656: EMPTY
55657: PPUSH
55658: CALL_OW 1
55662: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
55663: LD_ADDR_EXP 101
55667: PUSH
55668: LD_EXP 101
55672: PPUSH
55673: LD_VAR 0 2
55677: PPUSH
55678: EMPTY
55679: PPUSH
55680: CALL_OW 1
55684: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
55685: LD_ADDR_EXP 75
55689: PUSH
55690: LD_EXP 75
55694: PPUSH
55695: LD_VAR 0 2
55699: PPUSH
55700: EMPTY
55701: PPUSH
55702: CALL_OW 1
55706: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
55707: LD_ADDR_EXP 76
55711: PUSH
55712: LD_EXP 76
55716: PPUSH
55717: LD_VAR 0 2
55721: PPUSH
55722: EMPTY
55723: PPUSH
55724: CALL_OW 1
55728: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
55729: LD_ADDR_EXP 77
55733: PUSH
55734: LD_EXP 77
55738: PPUSH
55739: LD_VAR 0 2
55743: PPUSH
55744: LD_EXP 69
55748: PUSH
55749: LD_VAR 0 2
55753: ARRAY
55754: PPUSH
55755: LD_INT 2
55757: PUSH
55758: LD_INT 30
55760: PUSH
55761: LD_INT 32
55763: PUSH
55764: EMPTY
55765: LIST
55766: LIST
55767: PUSH
55768: LD_INT 30
55770: PUSH
55771: LD_INT 33
55773: PUSH
55774: EMPTY
55775: LIST
55776: LIST
55777: PUSH
55778: EMPTY
55779: LIST
55780: LIST
55781: LIST
55782: PPUSH
55783: CALL_OW 72
55787: PPUSH
55788: CALL_OW 1
55792: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
55793: LD_ADDR_EXP 78
55797: PUSH
55798: LD_EXP 78
55802: PPUSH
55803: LD_VAR 0 2
55807: PPUSH
55808: LD_EXP 69
55812: PUSH
55813: LD_VAR 0 2
55817: ARRAY
55818: PPUSH
55819: LD_INT 2
55821: PUSH
55822: LD_INT 30
55824: PUSH
55825: LD_INT 32
55827: PUSH
55828: EMPTY
55829: LIST
55830: LIST
55831: PUSH
55832: LD_INT 30
55834: PUSH
55835: LD_INT 31
55837: PUSH
55838: EMPTY
55839: LIST
55840: LIST
55841: PUSH
55842: EMPTY
55843: LIST
55844: LIST
55845: LIST
55846: PUSH
55847: LD_INT 58
55849: PUSH
55850: EMPTY
55851: LIST
55852: PUSH
55853: EMPTY
55854: LIST
55855: LIST
55856: PPUSH
55857: CALL_OW 72
55861: PPUSH
55862: CALL_OW 1
55866: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
55867: LD_ADDR_EXP 79
55871: PUSH
55872: LD_EXP 79
55876: PPUSH
55877: LD_VAR 0 2
55881: PPUSH
55882: EMPTY
55883: PPUSH
55884: CALL_OW 1
55888: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
55889: LD_ADDR_EXP 83
55893: PUSH
55894: LD_EXP 83
55898: PPUSH
55899: LD_VAR 0 2
55903: PPUSH
55904: EMPTY
55905: PPUSH
55906: CALL_OW 1
55910: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
55911: LD_ADDR_EXP 82
55915: PUSH
55916: LD_EXP 82
55920: PPUSH
55921: LD_VAR 0 2
55925: PPUSH
55926: EMPTY
55927: PPUSH
55928: CALL_OW 1
55932: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
55933: LD_ADDR_EXP 84
55937: PUSH
55938: LD_EXP 84
55942: PPUSH
55943: LD_VAR 0 2
55947: PPUSH
55948: EMPTY
55949: PPUSH
55950: CALL_OW 1
55954: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
55955: LD_ADDR_EXP 85
55959: PUSH
55960: LD_EXP 85
55964: PPUSH
55965: LD_VAR 0 2
55969: PPUSH
55970: EMPTY
55971: PPUSH
55972: CALL_OW 1
55976: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
55977: LD_ADDR_EXP 86
55981: PUSH
55982: LD_EXP 86
55986: PPUSH
55987: LD_VAR 0 2
55991: PPUSH
55992: EMPTY
55993: PPUSH
55994: CALL_OW 1
55998: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
55999: LD_ADDR_EXP 87
56003: PUSH
56004: LD_EXP 87
56008: PPUSH
56009: LD_VAR 0 2
56013: PPUSH
56014: EMPTY
56015: PPUSH
56016: CALL_OW 1
56020: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
56021: LD_ADDR_EXP 88
56025: PUSH
56026: LD_EXP 88
56030: PPUSH
56031: LD_VAR 0 2
56035: PPUSH
56036: EMPTY
56037: PPUSH
56038: CALL_OW 1
56042: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
56043: LD_ADDR_EXP 89
56047: PUSH
56048: LD_EXP 89
56052: PPUSH
56053: LD_VAR 0 2
56057: PPUSH
56058: EMPTY
56059: PPUSH
56060: CALL_OW 1
56064: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
56065: LD_ADDR_EXP 90
56069: PUSH
56070: LD_EXP 90
56074: PPUSH
56075: LD_VAR 0 2
56079: PPUSH
56080: EMPTY
56081: PPUSH
56082: CALL_OW 1
56086: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56087: LD_ADDR_EXP 91
56091: PUSH
56092: LD_EXP 91
56096: PPUSH
56097: LD_VAR 0 2
56101: PPUSH
56102: EMPTY
56103: PPUSH
56104: CALL_OW 1
56108: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
56109: LD_ADDR_EXP 80
56113: PUSH
56114: LD_EXP 80
56118: PPUSH
56119: LD_VAR 0 2
56123: PPUSH
56124: LD_INT 0
56126: PPUSH
56127: CALL_OW 1
56131: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
56132: LD_ADDR_EXP 93
56136: PUSH
56137: LD_EXP 93
56141: PPUSH
56142: LD_VAR 0 2
56146: PPUSH
56147: LD_INT 0
56149: PPUSH
56150: CALL_OW 1
56154: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
56155: LD_ADDR_EXP 81
56159: PUSH
56160: LD_EXP 81
56164: PPUSH
56165: LD_VAR 0 2
56169: PPUSH
56170: EMPTY
56171: PPUSH
56172: CALL_OW 1
56176: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
56177: LD_ADDR_EXP 92
56181: PUSH
56182: LD_EXP 92
56186: PPUSH
56187: LD_VAR 0 2
56191: PPUSH
56192: LD_INT 0
56194: PPUSH
56195: CALL_OW 1
56199: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
56200: LD_ADDR_EXP 94
56204: PUSH
56205: LD_EXP 94
56209: PPUSH
56210: LD_VAR 0 2
56214: PPUSH
56215: EMPTY
56216: PPUSH
56217: CALL_OW 1
56221: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
56222: LD_ADDR_EXP 97
56226: PUSH
56227: LD_EXP 97
56231: PPUSH
56232: LD_VAR 0 2
56236: PPUSH
56237: LD_INT 0
56239: PPUSH
56240: CALL_OW 1
56244: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
56245: LD_ADDR_EXP 98
56249: PUSH
56250: LD_EXP 98
56254: PPUSH
56255: LD_VAR 0 2
56259: PPUSH
56260: EMPTY
56261: PPUSH
56262: CALL_OW 1
56266: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
56267: LD_ADDR_EXP 99
56271: PUSH
56272: LD_EXP 99
56276: PPUSH
56277: LD_VAR 0 2
56281: PPUSH
56282: EMPTY
56283: PPUSH
56284: CALL_OW 1
56288: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
56289: LD_ADDR_EXP 100
56293: PUSH
56294: LD_EXP 100
56298: PPUSH
56299: LD_VAR 0 2
56303: PPUSH
56304: EMPTY
56305: PPUSH
56306: CALL_OW 1
56310: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
56311: LD_ADDR_EXP 102
56315: PUSH
56316: LD_EXP 102
56320: PPUSH
56321: LD_VAR 0 2
56325: PPUSH
56326: LD_EXP 69
56330: PUSH
56331: LD_VAR 0 2
56335: ARRAY
56336: PPUSH
56337: LD_INT 2
56339: PUSH
56340: LD_INT 30
56342: PUSH
56343: LD_INT 6
56345: PUSH
56346: EMPTY
56347: LIST
56348: LIST
56349: PUSH
56350: LD_INT 30
56352: PUSH
56353: LD_INT 7
56355: PUSH
56356: EMPTY
56357: LIST
56358: LIST
56359: PUSH
56360: LD_INT 30
56362: PUSH
56363: LD_INT 8
56365: PUSH
56366: EMPTY
56367: LIST
56368: LIST
56369: PUSH
56370: EMPTY
56371: LIST
56372: LIST
56373: LIST
56374: LIST
56375: PPUSH
56376: CALL_OW 72
56380: PPUSH
56381: CALL_OW 1
56385: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
56386: LD_ADDR_EXP 103
56390: PUSH
56391: LD_EXP 103
56395: PPUSH
56396: LD_VAR 0 2
56400: PPUSH
56401: EMPTY
56402: PPUSH
56403: CALL_OW 1
56407: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
56408: LD_ADDR_EXP 104
56412: PUSH
56413: LD_EXP 104
56417: PPUSH
56418: LD_VAR 0 2
56422: PPUSH
56423: EMPTY
56424: PPUSH
56425: CALL_OW 1
56429: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
56430: LD_ADDR_EXP 105
56434: PUSH
56435: LD_EXP 105
56439: PPUSH
56440: LD_VAR 0 2
56444: PPUSH
56445: EMPTY
56446: PPUSH
56447: CALL_OW 1
56451: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
56452: LD_ADDR_EXP 106
56456: PUSH
56457: LD_EXP 106
56461: PPUSH
56462: LD_VAR 0 2
56466: PPUSH
56467: EMPTY
56468: PPUSH
56469: CALL_OW 1
56473: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56474: LD_ADDR_EXP 107
56478: PUSH
56479: LD_EXP 107
56483: PPUSH
56484: LD_VAR 0 2
56488: PPUSH
56489: EMPTY
56490: PPUSH
56491: CALL_OW 1
56495: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
56496: LD_ADDR_EXP 108
56500: PUSH
56501: LD_EXP 108
56505: PPUSH
56506: LD_VAR 0 2
56510: PPUSH
56511: EMPTY
56512: PPUSH
56513: CALL_OW 1
56517: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
56518: LD_ADDR_EXP 109
56522: PUSH
56523: LD_EXP 109
56527: PPUSH
56528: LD_VAR 0 2
56532: PPUSH
56533: EMPTY
56534: PPUSH
56535: CALL_OW 1
56539: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
56540: LD_ADDR_EXP 110
56544: PUSH
56545: LD_EXP 110
56549: PPUSH
56550: LD_VAR 0 2
56554: PPUSH
56555: EMPTY
56556: PPUSH
56557: CALL_OW 1
56561: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
56562: LD_ADDR_EXP 111
56566: PUSH
56567: LD_EXP 111
56571: PPUSH
56572: LD_VAR 0 2
56576: PPUSH
56577: LD_INT 0
56579: PPUSH
56580: CALL_OW 1
56584: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
56585: LD_ADDR_EXP 112
56589: PUSH
56590: LD_EXP 112
56594: PPUSH
56595: LD_VAR 0 2
56599: PPUSH
56600: LD_INT 0
56602: PPUSH
56603: CALL_OW 1
56607: ST_TO_ADDR
// end ;
56608: GO 55509
56610: POP
56611: POP
// MC_InitSides ( ) ;
56612: CALL 56898 0 0
// MC_InitResearch ( ) ;
56616: CALL 56637 0 0
// CustomInitMacro ( ) ;
56620: CALL 5753 0 0
// skirmish := true ;
56624: LD_ADDR_EXP 67
56628: PUSH
56629: LD_INT 1
56631: ST_TO_ADDR
// end ;
56632: LD_VAR 0 1
56636: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
56637: LD_INT 0
56639: PPUSH
56640: PPUSH
56641: PPUSH
56642: PPUSH
56643: PPUSH
56644: PPUSH
// if not mc_bases then
56645: LD_EXP 69
56649: NOT
56650: IFFALSE 56654
// exit ;
56652: GO 56893
// for i = 1 to 8 do
56654: LD_ADDR_VAR 0 2
56658: PUSH
56659: DOUBLE
56660: LD_INT 1
56662: DEC
56663: ST_TO_ADDR
56664: LD_INT 8
56666: PUSH
56667: FOR_TO
56668: IFFALSE 56694
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
56670: LD_ADDR_EXP 96
56674: PUSH
56675: LD_EXP 96
56679: PPUSH
56680: LD_VAR 0 2
56684: PPUSH
56685: EMPTY
56686: PPUSH
56687: CALL_OW 1
56691: ST_TO_ADDR
56692: GO 56667
56694: POP
56695: POP
// tmp := [ ] ;
56696: LD_ADDR_VAR 0 5
56700: PUSH
56701: EMPTY
56702: ST_TO_ADDR
// for i = 1 to mc_sides do
56703: LD_ADDR_VAR 0 2
56707: PUSH
56708: DOUBLE
56709: LD_INT 1
56711: DEC
56712: ST_TO_ADDR
56713: LD_EXP 95
56717: PUSH
56718: FOR_TO
56719: IFFALSE 56777
// if not mc_sides [ i ] in tmp then
56721: LD_EXP 95
56725: PUSH
56726: LD_VAR 0 2
56730: ARRAY
56731: PUSH
56732: LD_VAR 0 5
56736: IN
56737: NOT
56738: IFFALSE 56775
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
56740: LD_ADDR_VAR 0 5
56744: PUSH
56745: LD_VAR 0 5
56749: PPUSH
56750: LD_VAR 0 5
56754: PUSH
56755: LD_INT 1
56757: PLUS
56758: PPUSH
56759: LD_EXP 95
56763: PUSH
56764: LD_VAR 0 2
56768: ARRAY
56769: PPUSH
56770: CALL_OW 2
56774: ST_TO_ADDR
56775: GO 56718
56777: POP
56778: POP
// if not tmp then
56779: LD_VAR 0 5
56783: NOT
56784: IFFALSE 56788
// exit ;
56786: GO 56893
// for j in tmp do
56788: LD_ADDR_VAR 0 3
56792: PUSH
56793: LD_VAR 0 5
56797: PUSH
56798: FOR_IN
56799: IFFALSE 56891
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
56801: LD_ADDR_VAR 0 6
56805: PUSH
56806: LD_INT 22
56808: PUSH
56809: LD_VAR 0 3
56813: PUSH
56814: EMPTY
56815: LIST
56816: LIST
56817: PPUSH
56818: CALL_OW 69
56822: ST_TO_ADDR
// if not un then
56823: LD_VAR 0 6
56827: NOT
56828: IFFALSE 56832
// continue ;
56830: GO 56798
// nation := GetNation ( un [ 1 ] ) ;
56832: LD_ADDR_VAR 0 4
56836: PUSH
56837: LD_VAR 0 6
56841: PUSH
56842: LD_INT 1
56844: ARRAY
56845: PPUSH
56846: CALL_OW 248
56850: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
56851: LD_ADDR_EXP 96
56855: PUSH
56856: LD_EXP 96
56860: PPUSH
56861: LD_VAR 0 3
56865: PPUSH
56866: LD_VAR 0 3
56870: PPUSH
56871: LD_VAR 0 4
56875: PPUSH
56876: LD_INT 1
56878: PPUSH
56879: CALL 13665 0 3
56883: PPUSH
56884: CALL_OW 1
56888: ST_TO_ADDR
// end ;
56889: GO 56798
56891: POP
56892: POP
// end ;
56893: LD_VAR 0 1
56897: RET
// export function MC_InitSides ( ) ; var i ; begin
56898: LD_INT 0
56900: PPUSH
56901: PPUSH
// if not mc_bases then
56902: LD_EXP 69
56906: NOT
56907: IFFALSE 56911
// exit ;
56909: GO 56985
// for i = 1 to mc_bases do
56911: LD_ADDR_VAR 0 2
56915: PUSH
56916: DOUBLE
56917: LD_INT 1
56919: DEC
56920: ST_TO_ADDR
56921: LD_EXP 69
56925: PUSH
56926: FOR_TO
56927: IFFALSE 56983
// if mc_bases [ i ] then
56929: LD_EXP 69
56933: PUSH
56934: LD_VAR 0 2
56938: ARRAY
56939: IFFALSE 56981
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
56941: LD_ADDR_EXP 95
56945: PUSH
56946: LD_EXP 95
56950: PPUSH
56951: LD_VAR 0 2
56955: PPUSH
56956: LD_EXP 69
56960: PUSH
56961: LD_VAR 0 2
56965: ARRAY
56966: PUSH
56967: LD_INT 1
56969: ARRAY
56970: PPUSH
56971: CALL_OW 255
56975: PPUSH
56976: CALL_OW 1
56980: ST_TO_ADDR
56981: GO 56926
56983: POP
56984: POP
// end ;
56985: LD_VAR 0 1
56989: RET
// every 0 0$03 trigger skirmish do
56990: LD_EXP 67
56994: IFFALSE 57148
56996: GO 56998
56998: DISABLE
// begin enable ;
56999: ENABLE
// MC_CheckBuildings ( ) ;
57000: CALL 61646 0 0
// MC_CheckPeopleLife ( ) ;
57004: CALL 61807 0 0
// RaiseSailEvent ( 100 ) ;
57008: LD_INT 100
57010: PPUSH
57011: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
57015: LD_INT 103
57017: PPUSH
57018: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
57022: LD_INT 104
57024: PPUSH
57025: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
57029: LD_INT 105
57031: PPUSH
57032: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
57036: LD_INT 106
57038: PPUSH
57039: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
57043: LD_INT 107
57045: PPUSH
57046: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
57050: LD_INT 108
57052: PPUSH
57053: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
57057: LD_INT 109
57059: PPUSH
57060: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
57064: LD_INT 110
57066: PPUSH
57067: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
57071: LD_INT 111
57073: PPUSH
57074: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
57078: LD_INT 112
57080: PPUSH
57081: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
57085: LD_INT 113
57087: PPUSH
57088: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
57092: LD_INT 120
57094: PPUSH
57095: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
57099: LD_INT 121
57101: PPUSH
57102: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
57106: LD_INT 122
57108: PPUSH
57109: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
57113: LD_INT 123
57115: PPUSH
57116: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
57120: LD_INT 124
57122: PPUSH
57123: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
57127: LD_INT 125
57129: PPUSH
57130: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
57134: LD_INT 126
57136: PPUSH
57137: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
57141: LD_INT 200
57143: PPUSH
57144: CALL_OW 427
// end ;
57148: END
// on SailEvent ( event ) do begin if event < 100 then
57149: LD_VAR 0 1
57153: PUSH
57154: LD_INT 100
57156: LESS
57157: IFFALSE 57168
// CustomEvent ( event ) ;
57159: LD_VAR 0 1
57163: PPUSH
57164: CALL 5745 0 1
// if event = 100 then
57168: LD_VAR 0 1
57172: PUSH
57173: LD_INT 100
57175: EQUAL
57176: IFFALSE 57182
// MC_ClassManager ( ) ;
57178: CALL 57574 0 0
// if event = 101 then
57182: LD_VAR 0 1
57186: PUSH
57187: LD_INT 101
57189: EQUAL
57190: IFFALSE 57196
// MC_RepairBuildings ( ) ;
57192: CALL 62392 0 0
// if event = 102 then
57196: LD_VAR 0 1
57200: PUSH
57201: LD_INT 102
57203: EQUAL
57204: IFFALSE 57210
// MC_Heal ( ) ;
57206: CALL 63299 0 0
// if event = 103 then
57210: LD_VAR 0 1
57214: PUSH
57215: LD_INT 103
57217: EQUAL
57218: IFFALSE 57224
// MC_Build ( ) ;
57220: CALL 63721 0 0
// if event = 104 then
57224: LD_VAR 0 1
57228: PUSH
57229: LD_INT 104
57231: EQUAL
57232: IFFALSE 57238
// MC_TurretWeapon ( ) ;
57234: CALL 65362 0 0
// if event = 105 then
57238: LD_VAR 0 1
57242: PUSH
57243: LD_INT 105
57245: EQUAL
57246: IFFALSE 57252
// MC_BuildUpgrade ( ) ;
57248: CALL 64913 0 0
// if event = 106 then
57252: LD_VAR 0 1
57256: PUSH
57257: LD_INT 106
57259: EQUAL
57260: IFFALSE 57266
// MC_PlantMines ( ) ;
57262: CALL 65792 0 0
// if event = 107 then
57266: LD_VAR 0 1
57270: PUSH
57271: LD_INT 107
57273: EQUAL
57274: IFFALSE 57280
// MC_CollectCrates ( ) ;
57276: CALL 66583 0 0
// if event = 108 then
57280: LD_VAR 0 1
57284: PUSH
57285: LD_INT 108
57287: EQUAL
57288: IFFALSE 57294
// MC_LinkRemoteControl ( ) ;
57290: CALL 68433 0 0
// if event = 109 then
57294: LD_VAR 0 1
57298: PUSH
57299: LD_INT 109
57301: EQUAL
57302: IFFALSE 57308
// MC_ProduceVehicle ( ) ;
57304: CALL 68614 0 0
// if event = 110 then
57308: LD_VAR 0 1
57312: PUSH
57313: LD_INT 110
57315: EQUAL
57316: IFFALSE 57322
// MC_SendAttack ( ) ;
57318: CALL 69080 0 0
// if event = 111 then
57322: LD_VAR 0 1
57326: PUSH
57327: LD_INT 111
57329: EQUAL
57330: IFFALSE 57336
// MC_Defend ( ) ;
57332: CALL 69188 0 0
// if event = 112 then
57336: LD_VAR 0 1
57340: PUSH
57341: LD_INT 112
57343: EQUAL
57344: IFFALSE 57350
// MC_Research ( ) ;
57346: CALL 70068 0 0
// if event = 113 then
57350: LD_VAR 0 1
57354: PUSH
57355: LD_INT 113
57357: EQUAL
57358: IFFALSE 57364
// MC_MinesTrigger ( ) ;
57360: CALL 71182 0 0
// if event = 120 then
57364: LD_VAR 0 1
57368: PUSH
57369: LD_INT 120
57371: EQUAL
57372: IFFALSE 57378
// MC_RepairVehicle ( ) ;
57374: CALL 71281 0 0
// if event = 121 then
57378: LD_VAR 0 1
57382: PUSH
57383: LD_INT 121
57385: EQUAL
57386: IFFALSE 57392
// MC_TameApe ( ) ;
57388: CALL 72022 0 0
// if event = 122 then
57392: LD_VAR 0 1
57396: PUSH
57397: LD_INT 122
57399: EQUAL
57400: IFFALSE 57406
// MC_ChangeApeClass ( ) ;
57402: CALL 72851 0 0
// if event = 123 then
57406: LD_VAR 0 1
57410: PUSH
57411: LD_INT 123
57413: EQUAL
57414: IFFALSE 57420
// MC_Bazooka ( ) ;
57416: CALL 73501 0 0
// if event = 124 then
57420: LD_VAR 0 1
57424: PUSH
57425: LD_INT 124
57427: EQUAL
57428: IFFALSE 57434
// MC_TeleportExit ( ) ;
57430: CALL 73699 0 0
// if event = 125 then
57434: LD_VAR 0 1
57438: PUSH
57439: LD_INT 125
57441: EQUAL
57442: IFFALSE 57448
// MC_Deposits ( ) ;
57444: CALL 74346 0 0
// if event = 126 then
57448: LD_VAR 0 1
57452: PUSH
57453: LD_INT 126
57455: EQUAL
57456: IFFALSE 57462
// MC_RemoteDriver ( ) ;
57458: CALL 74971 0 0
// if event = 200 then
57462: LD_VAR 0 1
57466: PUSH
57467: LD_INT 200
57469: EQUAL
57470: IFFALSE 57476
// MC_Idle ( ) ;
57472: CALL 76920 0 0
// end ;
57476: PPOPN 1
57478: END
// export function MC_Reset ( base , tag ) ; var i ; begin
57479: LD_INT 0
57481: PPUSH
57482: PPUSH
// if not mc_bases [ base ] or not tag then
57483: LD_EXP 69
57487: PUSH
57488: LD_VAR 0 1
57492: ARRAY
57493: NOT
57494: PUSH
57495: LD_VAR 0 2
57499: NOT
57500: OR
57501: IFFALSE 57505
// exit ;
57503: GO 57569
// for i in mc_bases [ base ] union mc_ape [ base ] do
57505: LD_ADDR_VAR 0 4
57509: PUSH
57510: LD_EXP 69
57514: PUSH
57515: LD_VAR 0 1
57519: ARRAY
57520: PUSH
57521: LD_EXP 98
57525: PUSH
57526: LD_VAR 0 1
57530: ARRAY
57531: UNION
57532: PUSH
57533: FOR_IN
57534: IFFALSE 57567
// if GetTag ( i ) = tag then
57536: LD_VAR 0 4
57540: PPUSH
57541: CALL_OW 110
57545: PUSH
57546: LD_VAR 0 2
57550: EQUAL
57551: IFFALSE 57565
// SetTag ( i , 0 ) ;
57553: LD_VAR 0 4
57557: PPUSH
57558: LD_INT 0
57560: PPUSH
57561: CALL_OW 109
57565: GO 57533
57567: POP
57568: POP
// end ;
57569: LD_VAR 0 3
57573: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
57574: LD_INT 0
57576: PPUSH
57577: PPUSH
57578: PPUSH
57579: PPUSH
57580: PPUSH
57581: PPUSH
57582: PPUSH
57583: PPUSH
// if not mc_bases then
57584: LD_EXP 69
57588: NOT
57589: IFFALSE 57593
// exit ;
57591: GO 58051
// for i = 1 to mc_bases do
57593: LD_ADDR_VAR 0 2
57597: PUSH
57598: DOUBLE
57599: LD_INT 1
57601: DEC
57602: ST_TO_ADDR
57603: LD_EXP 69
57607: PUSH
57608: FOR_TO
57609: IFFALSE 58049
// begin tmp := MC_ClassCheckReq ( i ) ;
57611: LD_ADDR_VAR 0 4
57615: PUSH
57616: LD_VAR 0 2
57620: PPUSH
57621: CALL 58056 0 1
57625: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
57626: LD_ADDR_EXP 110
57630: PUSH
57631: LD_EXP 110
57635: PPUSH
57636: LD_VAR 0 2
57640: PPUSH
57641: LD_VAR 0 4
57645: PPUSH
57646: CALL_OW 1
57650: ST_TO_ADDR
// if not tmp then
57651: LD_VAR 0 4
57655: NOT
57656: IFFALSE 57660
// continue ;
57658: GO 57608
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
57660: LD_ADDR_VAR 0 6
57664: PUSH
57665: LD_EXP 69
57669: PUSH
57670: LD_VAR 0 2
57674: ARRAY
57675: PPUSH
57676: LD_INT 2
57678: PUSH
57679: LD_INT 30
57681: PUSH
57682: LD_INT 4
57684: PUSH
57685: EMPTY
57686: LIST
57687: LIST
57688: PUSH
57689: LD_INT 30
57691: PUSH
57692: LD_INT 5
57694: PUSH
57695: EMPTY
57696: LIST
57697: LIST
57698: PUSH
57699: EMPTY
57700: LIST
57701: LIST
57702: LIST
57703: PPUSH
57704: CALL_OW 72
57708: PUSH
57709: LD_EXP 69
57713: PUSH
57714: LD_VAR 0 2
57718: ARRAY
57719: PPUSH
57720: LD_INT 2
57722: PUSH
57723: LD_INT 30
57725: PUSH
57726: LD_INT 0
57728: PUSH
57729: EMPTY
57730: LIST
57731: LIST
57732: PUSH
57733: LD_INT 30
57735: PUSH
57736: LD_INT 1
57738: PUSH
57739: EMPTY
57740: LIST
57741: LIST
57742: PUSH
57743: EMPTY
57744: LIST
57745: LIST
57746: LIST
57747: PPUSH
57748: CALL_OW 72
57752: PUSH
57753: LD_EXP 69
57757: PUSH
57758: LD_VAR 0 2
57762: ARRAY
57763: PPUSH
57764: LD_INT 30
57766: PUSH
57767: LD_INT 3
57769: PUSH
57770: EMPTY
57771: LIST
57772: LIST
57773: PPUSH
57774: CALL_OW 72
57778: PUSH
57779: LD_EXP 69
57783: PUSH
57784: LD_VAR 0 2
57788: ARRAY
57789: PPUSH
57790: LD_INT 2
57792: PUSH
57793: LD_INT 30
57795: PUSH
57796: LD_INT 6
57798: PUSH
57799: EMPTY
57800: LIST
57801: LIST
57802: PUSH
57803: LD_INT 30
57805: PUSH
57806: LD_INT 7
57808: PUSH
57809: EMPTY
57810: LIST
57811: LIST
57812: PUSH
57813: LD_INT 30
57815: PUSH
57816: LD_INT 8
57818: PUSH
57819: EMPTY
57820: LIST
57821: LIST
57822: PUSH
57823: EMPTY
57824: LIST
57825: LIST
57826: LIST
57827: LIST
57828: PPUSH
57829: CALL_OW 72
57833: PUSH
57834: EMPTY
57835: LIST
57836: LIST
57837: LIST
57838: LIST
57839: ST_TO_ADDR
// for j = 1 to 4 do
57840: LD_ADDR_VAR 0 3
57844: PUSH
57845: DOUBLE
57846: LD_INT 1
57848: DEC
57849: ST_TO_ADDR
57850: LD_INT 4
57852: PUSH
57853: FOR_TO
57854: IFFALSE 58045
// begin if not tmp [ j ] then
57856: LD_VAR 0 4
57860: PUSH
57861: LD_VAR 0 3
57865: ARRAY
57866: NOT
57867: IFFALSE 57871
// continue ;
57869: GO 57853
// for p in tmp [ j ] do
57871: LD_ADDR_VAR 0 5
57875: PUSH
57876: LD_VAR 0 4
57880: PUSH
57881: LD_VAR 0 3
57885: ARRAY
57886: PUSH
57887: FOR_IN
57888: IFFALSE 58041
// begin if not b [ j ] then
57890: LD_VAR 0 6
57894: PUSH
57895: LD_VAR 0 3
57899: ARRAY
57900: NOT
57901: IFFALSE 57905
// break ;
57903: GO 58041
// e := 0 ;
57905: LD_ADDR_VAR 0 7
57909: PUSH
57910: LD_INT 0
57912: ST_TO_ADDR
// for k in b [ j ] do
57913: LD_ADDR_VAR 0 8
57917: PUSH
57918: LD_VAR 0 6
57922: PUSH
57923: LD_VAR 0 3
57927: ARRAY
57928: PUSH
57929: FOR_IN
57930: IFFALSE 57957
// if IsNotFull ( k ) then
57932: LD_VAR 0 8
57936: PPUSH
57937: CALL 15818 0 1
57941: IFFALSE 57955
// begin e := k ;
57943: LD_ADDR_VAR 0 7
57947: PUSH
57948: LD_VAR 0 8
57952: ST_TO_ADDR
// break ;
57953: GO 57957
// end ;
57955: GO 57929
57957: POP
57958: POP
// if e and not UnitGoingToBuilding ( p , e ) then
57959: LD_VAR 0 7
57963: PUSH
57964: LD_VAR 0 5
57968: PPUSH
57969: LD_VAR 0 7
57973: PPUSH
57974: CALL 48982 0 2
57978: NOT
57979: AND
57980: IFFALSE 58039
// begin if IsInUnit ( p ) then
57982: LD_VAR 0 5
57986: PPUSH
57987: CALL_OW 310
57991: IFFALSE 58002
// ComExitBuilding ( p ) ;
57993: LD_VAR 0 5
57997: PPUSH
57998: CALL_OW 122
// ComEnterUnit ( p , e ) ;
58002: LD_VAR 0 5
58006: PPUSH
58007: LD_VAR 0 7
58011: PPUSH
58012: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
58016: LD_VAR 0 5
58020: PPUSH
58021: LD_VAR 0 3
58025: PPUSH
58026: CALL_OW 183
// AddComExitBuilding ( p ) ;
58030: LD_VAR 0 5
58034: PPUSH
58035: CALL_OW 182
// end ; end ;
58039: GO 57887
58041: POP
58042: POP
// end ;
58043: GO 57853
58045: POP
58046: POP
// end ;
58047: GO 57608
58049: POP
58050: POP
// end ;
58051: LD_VAR 0 1
58055: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
58056: LD_INT 0
58058: PPUSH
58059: PPUSH
58060: PPUSH
58061: PPUSH
58062: PPUSH
58063: PPUSH
58064: PPUSH
58065: PPUSH
58066: PPUSH
58067: PPUSH
58068: PPUSH
58069: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
58070: LD_VAR 0 1
58074: NOT
58075: PUSH
58076: LD_EXP 69
58080: PUSH
58081: LD_VAR 0 1
58085: ARRAY
58086: NOT
58087: OR
58088: PUSH
58089: LD_EXP 69
58093: PUSH
58094: LD_VAR 0 1
58098: ARRAY
58099: PPUSH
58100: LD_INT 2
58102: PUSH
58103: LD_INT 30
58105: PUSH
58106: LD_INT 0
58108: PUSH
58109: EMPTY
58110: LIST
58111: LIST
58112: PUSH
58113: LD_INT 30
58115: PUSH
58116: LD_INT 1
58118: PUSH
58119: EMPTY
58120: LIST
58121: LIST
58122: PUSH
58123: EMPTY
58124: LIST
58125: LIST
58126: LIST
58127: PPUSH
58128: CALL_OW 72
58132: NOT
58133: OR
58134: IFFALSE 58138
// exit ;
58136: GO 61641
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58138: LD_ADDR_VAR 0 4
58142: PUSH
58143: LD_EXP 69
58147: PUSH
58148: LD_VAR 0 1
58152: ARRAY
58153: PPUSH
58154: LD_INT 2
58156: PUSH
58157: LD_INT 25
58159: PUSH
58160: LD_INT 1
58162: PUSH
58163: EMPTY
58164: LIST
58165: LIST
58166: PUSH
58167: LD_INT 25
58169: PUSH
58170: LD_INT 2
58172: PUSH
58173: EMPTY
58174: LIST
58175: LIST
58176: PUSH
58177: LD_INT 25
58179: PUSH
58180: LD_INT 3
58182: PUSH
58183: EMPTY
58184: LIST
58185: LIST
58186: PUSH
58187: LD_INT 25
58189: PUSH
58190: LD_INT 4
58192: PUSH
58193: EMPTY
58194: LIST
58195: LIST
58196: PUSH
58197: LD_INT 25
58199: PUSH
58200: LD_INT 5
58202: PUSH
58203: EMPTY
58204: LIST
58205: LIST
58206: PUSH
58207: LD_INT 25
58209: PUSH
58210: LD_INT 8
58212: PUSH
58213: EMPTY
58214: LIST
58215: LIST
58216: PUSH
58217: LD_INT 25
58219: PUSH
58220: LD_INT 9
58222: PUSH
58223: EMPTY
58224: LIST
58225: LIST
58226: PUSH
58227: EMPTY
58228: LIST
58229: LIST
58230: LIST
58231: LIST
58232: LIST
58233: LIST
58234: LIST
58235: LIST
58236: PPUSH
58237: CALL_OW 72
58241: ST_TO_ADDR
// if not tmp then
58242: LD_VAR 0 4
58246: NOT
58247: IFFALSE 58251
// exit ;
58249: GO 61641
// for i in tmp do
58251: LD_ADDR_VAR 0 3
58255: PUSH
58256: LD_VAR 0 4
58260: PUSH
58261: FOR_IN
58262: IFFALSE 58293
// if GetTag ( i ) then
58264: LD_VAR 0 3
58268: PPUSH
58269: CALL_OW 110
58273: IFFALSE 58291
// tmp := tmp diff i ;
58275: LD_ADDR_VAR 0 4
58279: PUSH
58280: LD_VAR 0 4
58284: PUSH
58285: LD_VAR 0 3
58289: DIFF
58290: ST_TO_ADDR
58291: GO 58261
58293: POP
58294: POP
// if not tmp then
58295: LD_VAR 0 4
58299: NOT
58300: IFFALSE 58304
// exit ;
58302: GO 61641
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58304: LD_ADDR_VAR 0 5
58308: PUSH
58309: LD_EXP 69
58313: PUSH
58314: LD_VAR 0 1
58318: ARRAY
58319: PPUSH
58320: LD_INT 2
58322: PUSH
58323: LD_INT 25
58325: PUSH
58326: LD_INT 1
58328: PUSH
58329: EMPTY
58330: LIST
58331: LIST
58332: PUSH
58333: LD_INT 25
58335: PUSH
58336: LD_INT 5
58338: PUSH
58339: EMPTY
58340: LIST
58341: LIST
58342: PUSH
58343: LD_INT 25
58345: PUSH
58346: LD_INT 8
58348: PUSH
58349: EMPTY
58350: LIST
58351: LIST
58352: PUSH
58353: LD_INT 25
58355: PUSH
58356: LD_INT 9
58358: PUSH
58359: EMPTY
58360: LIST
58361: LIST
58362: PUSH
58363: EMPTY
58364: LIST
58365: LIST
58366: LIST
58367: LIST
58368: LIST
58369: PPUSH
58370: CALL_OW 72
58374: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
58375: LD_ADDR_VAR 0 6
58379: PUSH
58380: LD_EXP 69
58384: PUSH
58385: LD_VAR 0 1
58389: ARRAY
58390: PPUSH
58391: LD_INT 25
58393: PUSH
58394: LD_INT 2
58396: PUSH
58397: EMPTY
58398: LIST
58399: LIST
58400: PPUSH
58401: CALL_OW 72
58405: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
58406: LD_ADDR_VAR 0 7
58410: PUSH
58411: LD_EXP 69
58415: PUSH
58416: LD_VAR 0 1
58420: ARRAY
58421: PPUSH
58422: LD_INT 25
58424: PUSH
58425: LD_INT 3
58427: PUSH
58428: EMPTY
58429: LIST
58430: LIST
58431: PPUSH
58432: CALL_OW 72
58436: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
58437: LD_ADDR_VAR 0 8
58441: PUSH
58442: LD_EXP 69
58446: PUSH
58447: LD_VAR 0 1
58451: ARRAY
58452: PPUSH
58453: LD_INT 25
58455: PUSH
58456: LD_INT 4
58458: PUSH
58459: EMPTY
58460: LIST
58461: LIST
58462: PUSH
58463: LD_INT 24
58465: PUSH
58466: LD_INT 251
58468: PUSH
58469: EMPTY
58470: LIST
58471: LIST
58472: PUSH
58473: EMPTY
58474: LIST
58475: LIST
58476: PPUSH
58477: CALL_OW 72
58481: ST_TO_ADDR
// if mc_is_defending [ base ] then
58482: LD_EXP 112
58486: PUSH
58487: LD_VAR 0 1
58491: ARRAY
58492: IFFALSE 58953
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
58494: LD_ADDR_EXP 111
58498: PUSH
58499: LD_EXP 111
58503: PPUSH
58504: LD_VAR 0 1
58508: PPUSH
58509: LD_INT 4
58511: PPUSH
58512: CALL_OW 1
58516: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
58517: LD_ADDR_VAR 0 12
58521: PUSH
58522: LD_EXP 69
58526: PUSH
58527: LD_VAR 0 1
58531: ARRAY
58532: PPUSH
58533: LD_INT 2
58535: PUSH
58536: LD_INT 30
58538: PUSH
58539: LD_INT 4
58541: PUSH
58542: EMPTY
58543: LIST
58544: LIST
58545: PUSH
58546: LD_INT 30
58548: PUSH
58549: LD_INT 5
58551: PUSH
58552: EMPTY
58553: LIST
58554: LIST
58555: PUSH
58556: EMPTY
58557: LIST
58558: LIST
58559: LIST
58560: PPUSH
58561: CALL_OW 72
58565: ST_TO_ADDR
// if not b then
58566: LD_VAR 0 12
58570: NOT
58571: IFFALSE 58575
// exit ;
58573: GO 61641
// p := [ ] ;
58575: LD_ADDR_VAR 0 11
58579: PUSH
58580: EMPTY
58581: ST_TO_ADDR
// if sci >= 2 then
58582: LD_VAR 0 8
58586: PUSH
58587: LD_INT 2
58589: GREATEREQUAL
58590: IFFALSE 58621
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
58592: LD_ADDR_VAR 0 8
58596: PUSH
58597: LD_VAR 0 8
58601: PUSH
58602: LD_INT 1
58604: ARRAY
58605: PUSH
58606: LD_VAR 0 8
58610: PUSH
58611: LD_INT 2
58613: ARRAY
58614: PUSH
58615: EMPTY
58616: LIST
58617: LIST
58618: ST_TO_ADDR
58619: GO 58682
// if sci = 1 then
58621: LD_VAR 0 8
58625: PUSH
58626: LD_INT 1
58628: EQUAL
58629: IFFALSE 58650
// sci := [ sci [ 1 ] ] else
58631: LD_ADDR_VAR 0 8
58635: PUSH
58636: LD_VAR 0 8
58640: PUSH
58641: LD_INT 1
58643: ARRAY
58644: PUSH
58645: EMPTY
58646: LIST
58647: ST_TO_ADDR
58648: GO 58682
// if sci = 0 then
58650: LD_VAR 0 8
58654: PUSH
58655: LD_INT 0
58657: EQUAL
58658: IFFALSE 58682
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
58660: LD_ADDR_VAR 0 11
58664: PUSH
58665: LD_VAR 0 4
58669: PPUSH
58670: LD_INT 4
58672: PPUSH
58673: CALL 48845 0 2
58677: PUSH
58678: LD_INT 1
58680: ARRAY
58681: ST_TO_ADDR
// if eng > 4 then
58682: LD_VAR 0 6
58686: PUSH
58687: LD_INT 4
58689: GREATER
58690: IFFALSE 58736
// for i = eng downto 4 do
58692: LD_ADDR_VAR 0 3
58696: PUSH
58697: DOUBLE
58698: LD_VAR 0 6
58702: INC
58703: ST_TO_ADDR
58704: LD_INT 4
58706: PUSH
58707: FOR_DOWNTO
58708: IFFALSE 58734
// eng := eng diff eng [ i ] ;
58710: LD_ADDR_VAR 0 6
58714: PUSH
58715: LD_VAR 0 6
58719: PUSH
58720: LD_VAR 0 6
58724: PUSH
58725: LD_VAR 0 3
58729: ARRAY
58730: DIFF
58731: ST_TO_ADDR
58732: GO 58707
58734: POP
58735: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
58736: LD_ADDR_VAR 0 4
58740: PUSH
58741: LD_VAR 0 4
58745: PUSH
58746: LD_VAR 0 5
58750: PUSH
58751: LD_VAR 0 6
58755: UNION
58756: PUSH
58757: LD_VAR 0 7
58761: UNION
58762: PUSH
58763: LD_VAR 0 8
58767: UNION
58768: DIFF
58769: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
58770: LD_ADDR_VAR 0 13
58774: PUSH
58775: LD_EXP 69
58779: PUSH
58780: LD_VAR 0 1
58784: ARRAY
58785: PPUSH
58786: LD_INT 2
58788: PUSH
58789: LD_INT 30
58791: PUSH
58792: LD_INT 32
58794: PUSH
58795: EMPTY
58796: LIST
58797: LIST
58798: PUSH
58799: LD_INT 30
58801: PUSH
58802: LD_INT 31
58804: PUSH
58805: EMPTY
58806: LIST
58807: LIST
58808: PUSH
58809: EMPTY
58810: LIST
58811: LIST
58812: LIST
58813: PPUSH
58814: CALL_OW 72
58818: PUSH
58819: LD_EXP 69
58823: PUSH
58824: LD_VAR 0 1
58828: ARRAY
58829: PPUSH
58830: LD_INT 2
58832: PUSH
58833: LD_INT 30
58835: PUSH
58836: LD_INT 4
58838: PUSH
58839: EMPTY
58840: LIST
58841: LIST
58842: PUSH
58843: LD_INT 30
58845: PUSH
58846: LD_INT 5
58848: PUSH
58849: EMPTY
58850: LIST
58851: LIST
58852: PUSH
58853: EMPTY
58854: LIST
58855: LIST
58856: LIST
58857: PPUSH
58858: CALL_OW 72
58862: PUSH
58863: LD_INT 6
58865: MUL
58866: PLUS
58867: ST_TO_ADDR
// if bcount < tmp then
58868: LD_VAR 0 13
58872: PUSH
58873: LD_VAR 0 4
58877: LESS
58878: IFFALSE 58924
// for i = tmp downto bcount do
58880: LD_ADDR_VAR 0 3
58884: PUSH
58885: DOUBLE
58886: LD_VAR 0 4
58890: INC
58891: ST_TO_ADDR
58892: LD_VAR 0 13
58896: PUSH
58897: FOR_DOWNTO
58898: IFFALSE 58922
// tmp := Delete ( tmp , tmp ) ;
58900: LD_ADDR_VAR 0 4
58904: PUSH
58905: LD_VAR 0 4
58909: PPUSH
58910: LD_VAR 0 4
58914: PPUSH
58915: CALL_OW 3
58919: ST_TO_ADDR
58920: GO 58897
58922: POP
58923: POP
// result := [ tmp , 0 , 0 , p ] ;
58924: LD_ADDR_VAR 0 2
58928: PUSH
58929: LD_VAR 0 4
58933: PUSH
58934: LD_INT 0
58936: PUSH
58937: LD_INT 0
58939: PUSH
58940: LD_VAR 0 11
58944: PUSH
58945: EMPTY
58946: LIST
58947: LIST
58948: LIST
58949: LIST
58950: ST_TO_ADDR
// exit ;
58951: GO 61641
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58953: LD_EXP 69
58957: PUSH
58958: LD_VAR 0 1
58962: ARRAY
58963: PPUSH
58964: LD_INT 2
58966: PUSH
58967: LD_INT 30
58969: PUSH
58970: LD_INT 6
58972: PUSH
58973: EMPTY
58974: LIST
58975: LIST
58976: PUSH
58977: LD_INT 30
58979: PUSH
58980: LD_INT 7
58982: PUSH
58983: EMPTY
58984: LIST
58985: LIST
58986: PUSH
58987: LD_INT 30
58989: PUSH
58990: LD_INT 8
58992: PUSH
58993: EMPTY
58994: LIST
58995: LIST
58996: PUSH
58997: EMPTY
58998: LIST
58999: LIST
59000: LIST
59001: LIST
59002: PPUSH
59003: CALL_OW 72
59007: NOT
59008: PUSH
59009: LD_EXP 69
59013: PUSH
59014: LD_VAR 0 1
59018: ARRAY
59019: PPUSH
59020: LD_INT 30
59022: PUSH
59023: LD_INT 3
59025: PUSH
59026: EMPTY
59027: LIST
59028: LIST
59029: PPUSH
59030: CALL_OW 72
59034: NOT
59035: AND
59036: IFFALSE 59108
// begin if eng = tmp then
59038: LD_VAR 0 6
59042: PUSH
59043: LD_VAR 0 4
59047: EQUAL
59048: IFFALSE 59052
// exit ;
59050: GO 61641
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
59052: LD_ADDR_EXP 111
59056: PUSH
59057: LD_EXP 111
59061: PPUSH
59062: LD_VAR 0 1
59066: PPUSH
59067: LD_INT 1
59069: PPUSH
59070: CALL_OW 1
59074: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
59075: LD_ADDR_VAR 0 2
59079: PUSH
59080: LD_INT 0
59082: PUSH
59083: LD_VAR 0 4
59087: PUSH
59088: LD_VAR 0 6
59092: DIFF
59093: PUSH
59094: LD_INT 0
59096: PUSH
59097: LD_INT 0
59099: PUSH
59100: EMPTY
59101: LIST
59102: LIST
59103: LIST
59104: LIST
59105: ST_TO_ADDR
// exit ;
59106: GO 61641
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59108: LD_EXP 96
59112: PUSH
59113: LD_EXP 95
59117: PUSH
59118: LD_VAR 0 1
59122: ARRAY
59123: ARRAY
59124: PUSH
59125: LD_EXP 69
59129: PUSH
59130: LD_VAR 0 1
59134: ARRAY
59135: PPUSH
59136: LD_INT 2
59138: PUSH
59139: LD_INT 30
59141: PUSH
59142: LD_INT 6
59144: PUSH
59145: EMPTY
59146: LIST
59147: LIST
59148: PUSH
59149: LD_INT 30
59151: PUSH
59152: LD_INT 7
59154: PUSH
59155: EMPTY
59156: LIST
59157: LIST
59158: PUSH
59159: LD_INT 30
59161: PUSH
59162: LD_INT 8
59164: PUSH
59165: EMPTY
59166: LIST
59167: LIST
59168: PUSH
59169: EMPTY
59170: LIST
59171: LIST
59172: LIST
59173: LIST
59174: PPUSH
59175: CALL_OW 72
59179: AND
59180: PUSH
59181: LD_EXP 69
59185: PUSH
59186: LD_VAR 0 1
59190: ARRAY
59191: PPUSH
59192: LD_INT 30
59194: PUSH
59195: LD_INT 3
59197: PUSH
59198: EMPTY
59199: LIST
59200: LIST
59201: PPUSH
59202: CALL_OW 72
59206: NOT
59207: AND
59208: IFFALSE 59422
// begin if sci >= 6 then
59210: LD_VAR 0 8
59214: PUSH
59215: LD_INT 6
59217: GREATEREQUAL
59218: IFFALSE 59222
// exit ;
59220: GO 61641
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
59222: LD_ADDR_EXP 111
59226: PUSH
59227: LD_EXP 111
59231: PPUSH
59232: LD_VAR 0 1
59236: PPUSH
59237: LD_INT 2
59239: PPUSH
59240: CALL_OW 1
59244: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
59245: LD_ADDR_VAR 0 9
59249: PUSH
59250: LD_VAR 0 4
59254: PUSH
59255: LD_VAR 0 8
59259: DIFF
59260: PPUSH
59261: LD_INT 4
59263: PPUSH
59264: CALL 48845 0 2
59268: ST_TO_ADDR
// p := [ ] ;
59269: LD_ADDR_VAR 0 11
59273: PUSH
59274: EMPTY
59275: ST_TO_ADDR
// if sci < 6 and sort > 6 then
59276: LD_VAR 0 8
59280: PUSH
59281: LD_INT 6
59283: LESS
59284: PUSH
59285: LD_VAR 0 9
59289: PUSH
59290: LD_INT 6
59292: GREATER
59293: AND
59294: IFFALSE 59375
// begin for i = 1 to 6 - sci do
59296: LD_ADDR_VAR 0 3
59300: PUSH
59301: DOUBLE
59302: LD_INT 1
59304: DEC
59305: ST_TO_ADDR
59306: LD_INT 6
59308: PUSH
59309: LD_VAR 0 8
59313: MINUS
59314: PUSH
59315: FOR_TO
59316: IFFALSE 59371
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
59318: LD_ADDR_VAR 0 11
59322: PUSH
59323: LD_VAR 0 11
59327: PPUSH
59328: LD_VAR 0 11
59332: PUSH
59333: LD_INT 1
59335: PLUS
59336: PPUSH
59337: LD_VAR 0 9
59341: PUSH
59342: LD_INT 1
59344: ARRAY
59345: PPUSH
59346: CALL_OW 2
59350: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
59351: LD_ADDR_VAR 0 9
59355: PUSH
59356: LD_VAR 0 9
59360: PPUSH
59361: LD_INT 1
59363: PPUSH
59364: CALL_OW 3
59368: ST_TO_ADDR
// end ;
59369: GO 59315
59371: POP
59372: POP
// end else
59373: GO 59395
// if sort then
59375: LD_VAR 0 9
59379: IFFALSE 59395
// p := sort [ 1 ] ;
59381: LD_ADDR_VAR 0 11
59385: PUSH
59386: LD_VAR 0 9
59390: PUSH
59391: LD_INT 1
59393: ARRAY
59394: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
59395: LD_ADDR_VAR 0 2
59399: PUSH
59400: LD_INT 0
59402: PUSH
59403: LD_INT 0
59405: PUSH
59406: LD_INT 0
59408: PUSH
59409: LD_VAR 0 11
59413: PUSH
59414: EMPTY
59415: LIST
59416: LIST
59417: LIST
59418: LIST
59419: ST_TO_ADDR
// exit ;
59420: GO 61641
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59422: LD_EXP 96
59426: PUSH
59427: LD_EXP 95
59431: PUSH
59432: LD_VAR 0 1
59436: ARRAY
59437: ARRAY
59438: PUSH
59439: LD_EXP 69
59443: PUSH
59444: LD_VAR 0 1
59448: ARRAY
59449: PPUSH
59450: LD_INT 2
59452: PUSH
59453: LD_INT 30
59455: PUSH
59456: LD_INT 6
59458: PUSH
59459: EMPTY
59460: LIST
59461: LIST
59462: PUSH
59463: LD_INT 30
59465: PUSH
59466: LD_INT 7
59468: PUSH
59469: EMPTY
59470: LIST
59471: LIST
59472: PUSH
59473: LD_INT 30
59475: PUSH
59476: LD_INT 8
59478: PUSH
59479: EMPTY
59480: LIST
59481: LIST
59482: PUSH
59483: EMPTY
59484: LIST
59485: LIST
59486: LIST
59487: LIST
59488: PPUSH
59489: CALL_OW 72
59493: AND
59494: PUSH
59495: LD_EXP 69
59499: PUSH
59500: LD_VAR 0 1
59504: ARRAY
59505: PPUSH
59506: LD_INT 30
59508: PUSH
59509: LD_INT 3
59511: PUSH
59512: EMPTY
59513: LIST
59514: LIST
59515: PPUSH
59516: CALL_OW 72
59520: AND
59521: IFFALSE 60255
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
59523: LD_ADDR_EXP 111
59527: PUSH
59528: LD_EXP 111
59532: PPUSH
59533: LD_VAR 0 1
59537: PPUSH
59538: LD_INT 3
59540: PPUSH
59541: CALL_OW 1
59545: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59546: LD_ADDR_VAR 0 2
59550: PUSH
59551: LD_INT 0
59553: PUSH
59554: LD_INT 0
59556: PUSH
59557: LD_INT 0
59559: PUSH
59560: LD_INT 0
59562: PUSH
59563: EMPTY
59564: LIST
59565: LIST
59566: LIST
59567: LIST
59568: ST_TO_ADDR
// if not eng then
59569: LD_VAR 0 6
59573: NOT
59574: IFFALSE 59637
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
59576: LD_ADDR_VAR 0 11
59580: PUSH
59581: LD_VAR 0 4
59585: PPUSH
59586: LD_INT 2
59588: PPUSH
59589: CALL 48845 0 2
59593: PUSH
59594: LD_INT 1
59596: ARRAY
59597: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
59598: LD_ADDR_VAR 0 2
59602: PUSH
59603: LD_VAR 0 2
59607: PPUSH
59608: LD_INT 2
59610: PPUSH
59611: LD_VAR 0 11
59615: PPUSH
59616: CALL_OW 1
59620: ST_TO_ADDR
// tmp := tmp diff p ;
59621: LD_ADDR_VAR 0 4
59625: PUSH
59626: LD_VAR 0 4
59630: PUSH
59631: LD_VAR 0 11
59635: DIFF
59636: ST_TO_ADDR
// end ; if tmp and sci < 6 then
59637: LD_VAR 0 4
59641: PUSH
59642: LD_VAR 0 8
59646: PUSH
59647: LD_INT 6
59649: LESS
59650: AND
59651: IFFALSE 59839
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
59653: LD_ADDR_VAR 0 9
59657: PUSH
59658: LD_VAR 0 4
59662: PUSH
59663: LD_VAR 0 8
59667: PUSH
59668: LD_VAR 0 7
59672: UNION
59673: DIFF
59674: PPUSH
59675: LD_INT 4
59677: PPUSH
59678: CALL 48845 0 2
59682: ST_TO_ADDR
// p := [ ] ;
59683: LD_ADDR_VAR 0 11
59687: PUSH
59688: EMPTY
59689: ST_TO_ADDR
// if sort then
59690: LD_VAR 0 9
59694: IFFALSE 59810
// for i = 1 to 6 - sci do
59696: LD_ADDR_VAR 0 3
59700: PUSH
59701: DOUBLE
59702: LD_INT 1
59704: DEC
59705: ST_TO_ADDR
59706: LD_INT 6
59708: PUSH
59709: LD_VAR 0 8
59713: MINUS
59714: PUSH
59715: FOR_TO
59716: IFFALSE 59808
// begin if i = sort then
59718: LD_VAR 0 3
59722: PUSH
59723: LD_VAR 0 9
59727: EQUAL
59728: IFFALSE 59732
// break ;
59730: GO 59808
// if GetClass ( i ) = 4 then
59732: LD_VAR 0 3
59736: PPUSH
59737: CALL_OW 257
59741: PUSH
59742: LD_INT 4
59744: EQUAL
59745: IFFALSE 59749
// continue ;
59747: GO 59715
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59749: LD_ADDR_VAR 0 11
59753: PUSH
59754: LD_VAR 0 11
59758: PPUSH
59759: LD_VAR 0 11
59763: PUSH
59764: LD_INT 1
59766: PLUS
59767: PPUSH
59768: LD_VAR 0 9
59772: PUSH
59773: LD_VAR 0 3
59777: ARRAY
59778: PPUSH
59779: CALL_OW 2
59783: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59784: LD_ADDR_VAR 0 4
59788: PUSH
59789: LD_VAR 0 4
59793: PUSH
59794: LD_VAR 0 9
59798: PUSH
59799: LD_VAR 0 3
59803: ARRAY
59804: DIFF
59805: ST_TO_ADDR
// end ;
59806: GO 59715
59808: POP
59809: POP
// if p then
59810: LD_VAR 0 11
59814: IFFALSE 59839
// result := Replace ( result , 4 , p ) ;
59816: LD_ADDR_VAR 0 2
59820: PUSH
59821: LD_VAR 0 2
59825: PPUSH
59826: LD_INT 4
59828: PPUSH
59829: LD_VAR 0 11
59833: PPUSH
59834: CALL_OW 1
59838: ST_TO_ADDR
// end ; if tmp and mech < 6 then
59839: LD_VAR 0 4
59843: PUSH
59844: LD_VAR 0 7
59848: PUSH
59849: LD_INT 6
59851: LESS
59852: AND
59853: IFFALSE 60041
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59855: LD_ADDR_VAR 0 9
59859: PUSH
59860: LD_VAR 0 4
59864: PUSH
59865: LD_VAR 0 8
59869: PUSH
59870: LD_VAR 0 7
59874: UNION
59875: DIFF
59876: PPUSH
59877: LD_INT 3
59879: PPUSH
59880: CALL 48845 0 2
59884: ST_TO_ADDR
// p := [ ] ;
59885: LD_ADDR_VAR 0 11
59889: PUSH
59890: EMPTY
59891: ST_TO_ADDR
// if sort then
59892: LD_VAR 0 9
59896: IFFALSE 60012
// for i = 1 to 6 - mech do
59898: LD_ADDR_VAR 0 3
59902: PUSH
59903: DOUBLE
59904: LD_INT 1
59906: DEC
59907: ST_TO_ADDR
59908: LD_INT 6
59910: PUSH
59911: LD_VAR 0 7
59915: MINUS
59916: PUSH
59917: FOR_TO
59918: IFFALSE 60010
// begin if i = sort then
59920: LD_VAR 0 3
59924: PUSH
59925: LD_VAR 0 9
59929: EQUAL
59930: IFFALSE 59934
// break ;
59932: GO 60010
// if GetClass ( i ) = 3 then
59934: LD_VAR 0 3
59938: PPUSH
59939: CALL_OW 257
59943: PUSH
59944: LD_INT 3
59946: EQUAL
59947: IFFALSE 59951
// continue ;
59949: GO 59917
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59951: LD_ADDR_VAR 0 11
59955: PUSH
59956: LD_VAR 0 11
59960: PPUSH
59961: LD_VAR 0 11
59965: PUSH
59966: LD_INT 1
59968: PLUS
59969: PPUSH
59970: LD_VAR 0 9
59974: PUSH
59975: LD_VAR 0 3
59979: ARRAY
59980: PPUSH
59981: CALL_OW 2
59985: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59986: LD_ADDR_VAR 0 4
59990: PUSH
59991: LD_VAR 0 4
59995: PUSH
59996: LD_VAR 0 9
60000: PUSH
60001: LD_VAR 0 3
60005: ARRAY
60006: DIFF
60007: ST_TO_ADDR
// end ;
60008: GO 59917
60010: POP
60011: POP
// if p then
60012: LD_VAR 0 11
60016: IFFALSE 60041
// result := Replace ( result , 3 , p ) ;
60018: LD_ADDR_VAR 0 2
60022: PUSH
60023: LD_VAR 0 2
60027: PPUSH
60028: LD_INT 3
60030: PPUSH
60031: LD_VAR 0 11
60035: PPUSH
60036: CALL_OW 1
60040: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
60041: LD_VAR 0 4
60045: PUSH
60046: LD_INT 6
60048: GREATER
60049: PUSH
60050: LD_VAR 0 6
60054: PUSH
60055: LD_INT 6
60057: LESS
60058: AND
60059: IFFALSE 60253
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
60061: LD_ADDR_VAR 0 9
60065: PUSH
60066: LD_VAR 0 4
60070: PUSH
60071: LD_VAR 0 8
60075: PUSH
60076: LD_VAR 0 7
60080: UNION
60081: PUSH
60082: LD_VAR 0 6
60086: UNION
60087: DIFF
60088: PPUSH
60089: LD_INT 2
60091: PPUSH
60092: CALL 48845 0 2
60096: ST_TO_ADDR
// p := [ ] ;
60097: LD_ADDR_VAR 0 11
60101: PUSH
60102: EMPTY
60103: ST_TO_ADDR
// if sort then
60104: LD_VAR 0 9
60108: IFFALSE 60224
// for i = 1 to 6 - eng do
60110: LD_ADDR_VAR 0 3
60114: PUSH
60115: DOUBLE
60116: LD_INT 1
60118: DEC
60119: ST_TO_ADDR
60120: LD_INT 6
60122: PUSH
60123: LD_VAR 0 6
60127: MINUS
60128: PUSH
60129: FOR_TO
60130: IFFALSE 60222
// begin if i = sort then
60132: LD_VAR 0 3
60136: PUSH
60137: LD_VAR 0 9
60141: EQUAL
60142: IFFALSE 60146
// break ;
60144: GO 60222
// if GetClass ( i ) = 2 then
60146: LD_VAR 0 3
60150: PPUSH
60151: CALL_OW 257
60155: PUSH
60156: LD_INT 2
60158: EQUAL
60159: IFFALSE 60163
// continue ;
60161: GO 60129
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60163: LD_ADDR_VAR 0 11
60167: PUSH
60168: LD_VAR 0 11
60172: PPUSH
60173: LD_VAR 0 11
60177: PUSH
60178: LD_INT 1
60180: PLUS
60181: PPUSH
60182: LD_VAR 0 9
60186: PUSH
60187: LD_VAR 0 3
60191: ARRAY
60192: PPUSH
60193: CALL_OW 2
60197: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60198: LD_ADDR_VAR 0 4
60202: PUSH
60203: LD_VAR 0 4
60207: PUSH
60208: LD_VAR 0 9
60212: PUSH
60213: LD_VAR 0 3
60217: ARRAY
60218: DIFF
60219: ST_TO_ADDR
// end ;
60220: GO 60129
60222: POP
60223: POP
// if p then
60224: LD_VAR 0 11
60228: IFFALSE 60253
// result := Replace ( result , 2 , p ) ;
60230: LD_ADDR_VAR 0 2
60234: PUSH
60235: LD_VAR 0 2
60239: PPUSH
60240: LD_INT 2
60242: PPUSH
60243: LD_VAR 0 11
60247: PPUSH
60248: CALL_OW 1
60252: ST_TO_ADDR
// end ; exit ;
60253: GO 61641
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
60255: LD_EXP 96
60259: PUSH
60260: LD_EXP 95
60264: PUSH
60265: LD_VAR 0 1
60269: ARRAY
60270: ARRAY
60271: NOT
60272: PUSH
60273: LD_EXP 69
60277: PUSH
60278: LD_VAR 0 1
60282: ARRAY
60283: PPUSH
60284: LD_INT 30
60286: PUSH
60287: LD_INT 3
60289: PUSH
60290: EMPTY
60291: LIST
60292: LIST
60293: PPUSH
60294: CALL_OW 72
60298: AND
60299: PUSH
60300: LD_EXP 74
60304: PUSH
60305: LD_VAR 0 1
60309: ARRAY
60310: AND
60311: IFFALSE 60919
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
60313: LD_ADDR_EXP 111
60317: PUSH
60318: LD_EXP 111
60322: PPUSH
60323: LD_VAR 0 1
60327: PPUSH
60328: LD_INT 5
60330: PPUSH
60331: CALL_OW 1
60335: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60336: LD_ADDR_VAR 0 2
60340: PUSH
60341: LD_INT 0
60343: PUSH
60344: LD_INT 0
60346: PUSH
60347: LD_INT 0
60349: PUSH
60350: LD_INT 0
60352: PUSH
60353: EMPTY
60354: LIST
60355: LIST
60356: LIST
60357: LIST
60358: ST_TO_ADDR
// if sci > 1 then
60359: LD_VAR 0 8
60363: PUSH
60364: LD_INT 1
60366: GREATER
60367: IFFALSE 60395
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
60369: LD_ADDR_VAR 0 4
60373: PUSH
60374: LD_VAR 0 4
60378: PUSH
60379: LD_VAR 0 8
60383: PUSH
60384: LD_VAR 0 8
60388: PUSH
60389: LD_INT 1
60391: ARRAY
60392: DIFF
60393: DIFF
60394: ST_TO_ADDR
// if tmp and not sci then
60395: LD_VAR 0 4
60399: PUSH
60400: LD_VAR 0 8
60404: NOT
60405: AND
60406: IFFALSE 60475
// begin sort := SortBySkill ( tmp , 4 ) ;
60408: LD_ADDR_VAR 0 9
60412: PUSH
60413: LD_VAR 0 4
60417: PPUSH
60418: LD_INT 4
60420: PPUSH
60421: CALL 48845 0 2
60425: ST_TO_ADDR
// if sort then
60426: LD_VAR 0 9
60430: IFFALSE 60446
// p := sort [ 1 ] ;
60432: LD_ADDR_VAR 0 11
60436: PUSH
60437: LD_VAR 0 9
60441: PUSH
60442: LD_INT 1
60444: ARRAY
60445: ST_TO_ADDR
// if p then
60446: LD_VAR 0 11
60450: IFFALSE 60475
// result := Replace ( result , 4 , p ) ;
60452: LD_ADDR_VAR 0 2
60456: PUSH
60457: LD_VAR 0 2
60461: PPUSH
60462: LD_INT 4
60464: PPUSH
60465: LD_VAR 0 11
60469: PPUSH
60470: CALL_OW 1
60474: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60475: LD_ADDR_VAR 0 4
60479: PUSH
60480: LD_VAR 0 4
60484: PUSH
60485: LD_VAR 0 7
60489: DIFF
60490: ST_TO_ADDR
// if tmp and mech < 6 then
60491: LD_VAR 0 4
60495: PUSH
60496: LD_VAR 0 7
60500: PUSH
60501: LD_INT 6
60503: LESS
60504: AND
60505: IFFALSE 60693
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
60507: LD_ADDR_VAR 0 9
60511: PUSH
60512: LD_VAR 0 4
60516: PUSH
60517: LD_VAR 0 8
60521: PUSH
60522: LD_VAR 0 7
60526: UNION
60527: DIFF
60528: PPUSH
60529: LD_INT 3
60531: PPUSH
60532: CALL 48845 0 2
60536: ST_TO_ADDR
// p := [ ] ;
60537: LD_ADDR_VAR 0 11
60541: PUSH
60542: EMPTY
60543: ST_TO_ADDR
// if sort then
60544: LD_VAR 0 9
60548: IFFALSE 60664
// for i = 1 to 6 - mech do
60550: LD_ADDR_VAR 0 3
60554: PUSH
60555: DOUBLE
60556: LD_INT 1
60558: DEC
60559: ST_TO_ADDR
60560: LD_INT 6
60562: PUSH
60563: LD_VAR 0 7
60567: MINUS
60568: PUSH
60569: FOR_TO
60570: IFFALSE 60662
// begin if i = sort then
60572: LD_VAR 0 3
60576: PUSH
60577: LD_VAR 0 9
60581: EQUAL
60582: IFFALSE 60586
// break ;
60584: GO 60662
// if GetClass ( i ) = 3 then
60586: LD_VAR 0 3
60590: PPUSH
60591: CALL_OW 257
60595: PUSH
60596: LD_INT 3
60598: EQUAL
60599: IFFALSE 60603
// continue ;
60601: GO 60569
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60603: LD_ADDR_VAR 0 11
60607: PUSH
60608: LD_VAR 0 11
60612: PPUSH
60613: LD_VAR 0 11
60617: PUSH
60618: LD_INT 1
60620: PLUS
60621: PPUSH
60622: LD_VAR 0 9
60626: PUSH
60627: LD_VAR 0 3
60631: ARRAY
60632: PPUSH
60633: CALL_OW 2
60637: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60638: LD_ADDR_VAR 0 4
60642: PUSH
60643: LD_VAR 0 4
60647: PUSH
60648: LD_VAR 0 9
60652: PUSH
60653: LD_VAR 0 3
60657: ARRAY
60658: DIFF
60659: ST_TO_ADDR
// end ;
60660: GO 60569
60662: POP
60663: POP
// if p then
60664: LD_VAR 0 11
60668: IFFALSE 60693
// result := Replace ( result , 3 , p ) ;
60670: LD_ADDR_VAR 0 2
60674: PUSH
60675: LD_VAR 0 2
60679: PPUSH
60680: LD_INT 3
60682: PPUSH
60683: LD_VAR 0 11
60687: PPUSH
60688: CALL_OW 1
60692: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60693: LD_ADDR_VAR 0 4
60697: PUSH
60698: LD_VAR 0 4
60702: PUSH
60703: LD_VAR 0 6
60707: DIFF
60708: ST_TO_ADDR
// if tmp and eng < 6 then
60709: LD_VAR 0 4
60713: PUSH
60714: LD_VAR 0 6
60718: PUSH
60719: LD_INT 6
60721: LESS
60722: AND
60723: IFFALSE 60917
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
60725: LD_ADDR_VAR 0 9
60729: PUSH
60730: LD_VAR 0 4
60734: PUSH
60735: LD_VAR 0 8
60739: PUSH
60740: LD_VAR 0 7
60744: UNION
60745: PUSH
60746: LD_VAR 0 6
60750: UNION
60751: DIFF
60752: PPUSH
60753: LD_INT 2
60755: PPUSH
60756: CALL 48845 0 2
60760: ST_TO_ADDR
// p := [ ] ;
60761: LD_ADDR_VAR 0 11
60765: PUSH
60766: EMPTY
60767: ST_TO_ADDR
// if sort then
60768: LD_VAR 0 9
60772: IFFALSE 60888
// for i = 1 to 6 - eng do
60774: LD_ADDR_VAR 0 3
60778: PUSH
60779: DOUBLE
60780: LD_INT 1
60782: DEC
60783: ST_TO_ADDR
60784: LD_INT 6
60786: PUSH
60787: LD_VAR 0 6
60791: MINUS
60792: PUSH
60793: FOR_TO
60794: IFFALSE 60886
// begin if i = sort then
60796: LD_VAR 0 3
60800: PUSH
60801: LD_VAR 0 9
60805: EQUAL
60806: IFFALSE 60810
// break ;
60808: GO 60886
// if GetClass ( i ) = 2 then
60810: LD_VAR 0 3
60814: PPUSH
60815: CALL_OW 257
60819: PUSH
60820: LD_INT 2
60822: EQUAL
60823: IFFALSE 60827
// continue ;
60825: GO 60793
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60827: LD_ADDR_VAR 0 11
60831: PUSH
60832: LD_VAR 0 11
60836: PPUSH
60837: LD_VAR 0 11
60841: PUSH
60842: LD_INT 1
60844: PLUS
60845: PPUSH
60846: LD_VAR 0 9
60850: PUSH
60851: LD_VAR 0 3
60855: ARRAY
60856: PPUSH
60857: CALL_OW 2
60861: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60862: LD_ADDR_VAR 0 4
60866: PUSH
60867: LD_VAR 0 4
60871: PUSH
60872: LD_VAR 0 9
60876: PUSH
60877: LD_VAR 0 3
60881: ARRAY
60882: DIFF
60883: ST_TO_ADDR
// end ;
60884: GO 60793
60886: POP
60887: POP
// if p then
60888: LD_VAR 0 11
60892: IFFALSE 60917
// result := Replace ( result , 2 , p ) ;
60894: LD_ADDR_VAR 0 2
60898: PUSH
60899: LD_VAR 0 2
60903: PPUSH
60904: LD_INT 2
60906: PPUSH
60907: LD_VAR 0 11
60911: PPUSH
60912: CALL_OW 1
60916: ST_TO_ADDR
// end ; exit ;
60917: GO 61641
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
60919: LD_EXP 96
60923: PUSH
60924: LD_EXP 95
60928: PUSH
60929: LD_VAR 0 1
60933: ARRAY
60934: ARRAY
60935: NOT
60936: PUSH
60937: LD_EXP 69
60941: PUSH
60942: LD_VAR 0 1
60946: ARRAY
60947: PPUSH
60948: LD_INT 30
60950: PUSH
60951: LD_INT 3
60953: PUSH
60954: EMPTY
60955: LIST
60956: LIST
60957: PPUSH
60958: CALL_OW 72
60962: AND
60963: PUSH
60964: LD_EXP 74
60968: PUSH
60969: LD_VAR 0 1
60973: ARRAY
60974: NOT
60975: AND
60976: IFFALSE 61641
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
60978: LD_ADDR_EXP 111
60982: PUSH
60983: LD_EXP 111
60987: PPUSH
60988: LD_VAR 0 1
60992: PPUSH
60993: LD_INT 6
60995: PPUSH
60996: CALL_OW 1
61000: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61001: LD_ADDR_VAR 0 2
61005: PUSH
61006: LD_INT 0
61008: PUSH
61009: LD_INT 0
61011: PUSH
61012: LD_INT 0
61014: PUSH
61015: LD_INT 0
61017: PUSH
61018: EMPTY
61019: LIST
61020: LIST
61021: LIST
61022: LIST
61023: ST_TO_ADDR
// if sci >= 1 then
61024: LD_VAR 0 8
61028: PUSH
61029: LD_INT 1
61031: GREATEREQUAL
61032: IFFALSE 61054
// tmp := tmp diff sci [ 1 ] ;
61034: LD_ADDR_VAR 0 4
61038: PUSH
61039: LD_VAR 0 4
61043: PUSH
61044: LD_VAR 0 8
61048: PUSH
61049: LD_INT 1
61051: ARRAY
61052: DIFF
61053: ST_TO_ADDR
// if tmp and not sci then
61054: LD_VAR 0 4
61058: PUSH
61059: LD_VAR 0 8
61063: NOT
61064: AND
61065: IFFALSE 61134
// begin sort := SortBySkill ( tmp , 4 ) ;
61067: LD_ADDR_VAR 0 9
61071: PUSH
61072: LD_VAR 0 4
61076: PPUSH
61077: LD_INT 4
61079: PPUSH
61080: CALL 48845 0 2
61084: ST_TO_ADDR
// if sort then
61085: LD_VAR 0 9
61089: IFFALSE 61105
// p := sort [ 1 ] ;
61091: LD_ADDR_VAR 0 11
61095: PUSH
61096: LD_VAR 0 9
61100: PUSH
61101: LD_INT 1
61103: ARRAY
61104: ST_TO_ADDR
// if p then
61105: LD_VAR 0 11
61109: IFFALSE 61134
// result := Replace ( result , 4 , p ) ;
61111: LD_ADDR_VAR 0 2
61115: PUSH
61116: LD_VAR 0 2
61120: PPUSH
61121: LD_INT 4
61123: PPUSH
61124: LD_VAR 0 11
61128: PPUSH
61129: CALL_OW 1
61133: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61134: LD_ADDR_VAR 0 4
61138: PUSH
61139: LD_VAR 0 4
61143: PUSH
61144: LD_VAR 0 7
61148: DIFF
61149: ST_TO_ADDR
// if tmp and mech < 6 then
61150: LD_VAR 0 4
61154: PUSH
61155: LD_VAR 0 7
61159: PUSH
61160: LD_INT 6
61162: LESS
61163: AND
61164: IFFALSE 61346
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
61166: LD_ADDR_VAR 0 9
61170: PUSH
61171: LD_VAR 0 4
61175: PUSH
61176: LD_VAR 0 7
61180: DIFF
61181: PPUSH
61182: LD_INT 3
61184: PPUSH
61185: CALL 48845 0 2
61189: ST_TO_ADDR
// p := [ ] ;
61190: LD_ADDR_VAR 0 11
61194: PUSH
61195: EMPTY
61196: ST_TO_ADDR
// if sort then
61197: LD_VAR 0 9
61201: IFFALSE 61317
// for i = 1 to 6 - mech do
61203: LD_ADDR_VAR 0 3
61207: PUSH
61208: DOUBLE
61209: LD_INT 1
61211: DEC
61212: ST_TO_ADDR
61213: LD_INT 6
61215: PUSH
61216: LD_VAR 0 7
61220: MINUS
61221: PUSH
61222: FOR_TO
61223: IFFALSE 61315
// begin if i = sort then
61225: LD_VAR 0 3
61229: PUSH
61230: LD_VAR 0 9
61234: EQUAL
61235: IFFALSE 61239
// break ;
61237: GO 61315
// if GetClass ( i ) = 3 then
61239: LD_VAR 0 3
61243: PPUSH
61244: CALL_OW 257
61248: PUSH
61249: LD_INT 3
61251: EQUAL
61252: IFFALSE 61256
// continue ;
61254: GO 61222
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61256: LD_ADDR_VAR 0 11
61260: PUSH
61261: LD_VAR 0 11
61265: PPUSH
61266: LD_VAR 0 11
61270: PUSH
61271: LD_INT 1
61273: PLUS
61274: PPUSH
61275: LD_VAR 0 9
61279: PUSH
61280: LD_VAR 0 3
61284: ARRAY
61285: PPUSH
61286: CALL_OW 2
61290: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61291: LD_ADDR_VAR 0 4
61295: PUSH
61296: LD_VAR 0 4
61300: PUSH
61301: LD_VAR 0 9
61305: PUSH
61306: LD_VAR 0 3
61310: ARRAY
61311: DIFF
61312: ST_TO_ADDR
// end ;
61313: GO 61222
61315: POP
61316: POP
// if p then
61317: LD_VAR 0 11
61321: IFFALSE 61346
// result := Replace ( result , 3 , p ) ;
61323: LD_ADDR_VAR 0 2
61327: PUSH
61328: LD_VAR 0 2
61332: PPUSH
61333: LD_INT 3
61335: PPUSH
61336: LD_VAR 0 11
61340: PPUSH
61341: CALL_OW 1
61345: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61346: LD_ADDR_VAR 0 4
61350: PUSH
61351: LD_VAR 0 4
61355: PUSH
61356: LD_VAR 0 6
61360: DIFF
61361: ST_TO_ADDR
// if tmp and eng < 4 then
61362: LD_VAR 0 4
61366: PUSH
61367: LD_VAR 0 6
61371: PUSH
61372: LD_INT 4
61374: LESS
61375: AND
61376: IFFALSE 61566
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
61378: LD_ADDR_VAR 0 9
61382: PUSH
61383: LD_VAR 0 4
61387: PUSH
61388: LD_VAR 0 7
61392: PUSH
61393: LD_VAR 0 6
61397: UNION
61398: DIFF
61399: PPUSH
61400: LD_INT 2
61402: PPUSH
61403: CALL 48845 0 2
61407: ST_TO_ADDR
// p := [ ] ;
61408: LD_ADDR_VAR 0 11
61412: PUSH
61413: EMPTY
61414: ST_TO_ADDR
// if sort then
61415: LD_VAR 0 9
61419: IFFALSE 61535
// for i = 1 to 4 - eng do
61421: LD_ADDR_VAR 0 3
61425: PUSH
61426: DOUBLE
61427: LD_INT 1
61429: DEC
61430: ST_TO_ADDR
61431: LD_INT 4
61433: PUSH
61434: LD_VAR 0 6
61438: MINUS
61439: PUSH
61440: FOR_TO
61441: IFFALSE 61533
// begin if i = sort then
61443: LD_VAR 0 3
61447: PUSH
61448: LD_VAR 0 9
61452: EQUAL
61453: IFFALSE 61457
// break ;
61455: GO 61533
// if GetClass ( i ) = 2 then
61457: LD_VAR 0 3
61461: PPUSH
61462: CALL_OW 257
61466: PUSH
61467: LD_INT 2
61469: EQUAL
61470: IFFALSE 61474
// continue ;
61472: GO 61440
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61474: LD_ADDR_VAR 0 11
61478: PUSH
61479: LD_VAR 0 11
61483: PPUSH
61484: LD_VAR 0 11
61488: PUSH
61489: LD_INT 1
61491: PLUS
61492: PPUSH
61493: LD_VAR 0 9
61497: PUSH
61498: LD_VAR 0 3
61502: ARRAY
61503: PPUSH
61504: CALL_OW 2
61508: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61509: LD_ADDR_VAR 0 4
61513: PUSH
61514: LD_VAR 0 4
61518: PUSH
61519: LD_VAR 0 9
61523: PUSH
61524: LD_VAR 0 3
61528: ARRAY
61529: DIFF
61530: ST_TO_ADDR
// end ;
61531: GO 61440
61533: POP
61534: POP
// if p then
61535: LD_VAR 0 11
61539: IFFALSE 61564
// result := Replace ( result , 2 , p ) ;
61541: LD_ADDR_VAR 0 2
61545: PUSH
61546: LD_VAR 0 2
61550: PPUSH
61551: LD_INT 2
61553: PPUSH
61554: LD_VAR 0 11
61558: PPUSH
61559: CALL_OW 1
61563: ST_TO_ADDR
// end else
61564: GO 61610
// for i = eng downto 5 do
61566: LD_ADDR_VAR 0 3
61570: PUSH
61571: DOUBLE
61572: LD_VAR 0 6
61576: INC
61577: ST_TO_ADDR
61578: LD_INT 5
61580: PUSH
61581: FOR_DOWNTO
61582: IFFALSE 61608
// tmp := tmp union eng [ i ] ;
61584: LD_ADDR_VAR 0 4
61588: PUSH
61589: LD_VAR 0 4
61593: PUSH
61594: LD_VAR 0 6
61598: PUSH
61599: LD_VAR 0 3
61603: ARRAY
61604: UNION
61605: ST_TO_ADDR
61606: GO 61581
61608: POP
61609: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
61610: LD_ADDR_VAR 0 2
61614: PUSH
61615: LD_VAR 0 2
61619: PPUSH
61620: LD_INT 1
61622: PPUSH
61623: LD_VAR 0 4
61627: PUSH
61628: LD_VAR 0 5
61632: DIFF
61633: PPUSH
61634: CALL_OW 1
61638: ST_TO_ADDR
// exit ;
61639: GO 61641
// end ; end ;
61641: LD_VAR 0 2
61645: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
61646: LD_INT 0
61648: PPUSH
61649: PPUSH
61650: PPUSH
// if not mc_bases then
61651: LD_EXP 69
61655: NOT
61656: IFFALSE 61660
// exit ;
61658: GO 61802
// for i = 1 to mc_bases do
61660: LD_ADDR_VAR 0 2
61664: PUSH
61665: DOUBLE
61666: LD_INT 1
61668: DEC
61669: ST_TO_ADDR
61670: LD_EXP 69
61674: PUSH
61675: FOR_TO
61676: IFFALSE 61793
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
61678: LD_ADDR_VAR 0 3
61682: PUSH
61683: LD_EXP 69
61687: PUSH
61688: LD_VAR 0 2
61692: ARRAY
61693: PPUSH
61694: LD_INT 21
61696: PUSH
61697: LD_INT 3
61699: PUSH
61700: EMPTY
61701: LIST
61702: LIST
61703: PUSH
61704: LD_INT 3
61706: PUSH
61707: LD_INT 2
61709: PUSH
61710: LD_INT 30
61712: PUSH
61713: LD_INT 29
61715: PUSH
61716: EMPTY
61717: LIST
61718: LIST
61719: PUSH
61720: LD_INT 30
61722: PUSH
61723: LD_INT 30
61725: PUSH
61726: EMPTY
61727: LIST
61728: LIST
61729: PUSH
61730: EMPTY
61731: LIST
61732: LIST
61733: LIST
61734: PUSH
61735: EMPTY
61736: LIST
61737: LIST
61738: PUSH
61739: LD_INT 3
61741: PUSH
61742: LD_INT 24
61744: PUSH
61745: LD_INT 1000
61747: PUSH
61748: EMPTY
61749: LIST
61750: LIST
61751: PUSH
61752: EMPTY
61753: LIST
61754: LIST
61755: PUSH
61756: EMPTY
61757: LIST
61758: LIST
61759: LIST
61760: PPUSH
61761: CALL_OW 72
61765: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
61766: LD_ADDR_EXP 70
61770: PUSH
61771: LD_EXP 70
61775: PPUSH
61776: LD_VAR 0 2
61780: PPUSH
61781: LD_VAR 0 3
61785: PPUSH
61786: CALL_OW 1
61790: ST_TO_ADDR
// end ;
61791: GO 61675
61793: POP
61794: POP
// RaiseSailEvent ( 101 ) ;
61795: LD_INT 101
61797: PPUSH
61798: CALL_OW 427
// end ;
61802: LD_VAR 0 1
61806: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
61807: LD_INT 0
61809: PPUSH
61810: PPUSH
61811: PPUSH
61812: PPUSH
61813: PPUSH
61814: PPUSH
61815: PPUSH
// if not mc_bases then
61816: LD_EXP 69
61820: NOT
61821: IFFALSE 61825
// exit ;
61823: GO 62387
// for i = 1 to mc_bases do
61825: LD_ADDR_VAR 0 2
61829: PUSH
61830: DOUBLE
61831: LD_INT 1
61833: DEC
61834: ST_TO_ADDR
61835: LD_EXP 69
61839: PUSH
61840: FOR_TO
61841: IFFALSE 62378
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
61843: LD_ADDR_VAR 0 5
61847: PUSH
61848: LD_EXP 69
61852: PUSH
61853: LD_VAR 0 2
61857: ARRAY
61858: PUSH
61859: LD_EXP 98
61863: PUSH
61864: LD_VAR 0 2
61868: ARRAY
61869: UNION
61870: PPUSH
61871: LD_INT 21
61873: PUSH
61874: LD_INT 1
61876: PUSH
61877: EMPTY
61878: LIST
61879: LIST
61880: PUSH
61881: LD_INT 1
61883: PUSH
61884: LD_INT 3
61886: PUSH
61887: LD_INT 54
61889: PUSH
61890: EMPTY
61891: LIST
61892: PUSH
61893: EMPTY
61894: LIST
61895: LIST
61896: PUSH
61897: LD_INT 3
61899: PUSH
61900: LD_INT 24
61902: PUSH
61903: LD_INT 1000
61905: PUSH
61906: EMPTY
61907: LIST
61908: LIST
61909: PUSH
61910: EMPTY
61911: LIST
61912: LIST
61913: PUSH
61914: EMPTY
61915: LIST
61916: LIST
61917: LIST
61918: PUSH
61919: EMPTY
61920: LIST
61921: LIST
61922: PPUSH
61923: CALL_OW 72
61927: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
61928: LD_ADDR_VAR 0 6
61932: PUSH
61933: LD_EXP 69
61937: PUSH
61938: LD_VAR 0 2
61942: ARRAY
61943: PPUSH
61944: LD_INT 21
61946: PUSH
61947: LD_INT 1
61949: PUSH
61950: EMPTY
61951: LIST
61952: LIST
61953: PUSH
61954: LD_INT 1
61956: PUSH
61957: LD_INT 3
61959: PUSH
61960: LD_INT 54
61962: PUSH
61963: EMPTY
61964: LIST
61965: PUSH
61966: EMPTY
61967: LIST
61968: LIST
61969: PUSH
61970: LD_INT 3
61972: PUSH
61973: LD_INT 24
61975: PUSH
61976: LD_INT 250
61978: PUSH
61979: EMPTY
61980: LIST
61981: LIST
61982: PUSH
61983: EMPTY
61984: LIST
61985: LIST
61986: PUSH
61987: EMPTY
61988: LIST
61989: LIST
61990: LIST
61991: PUSH
61992: EMPTY
61993: LIST
61994: LIST
61995: PPUSH
61996: CALL_OW 72
62000: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
62001: LD_ADDR_VAR 0 7
62005: PUSH
62006: LD_VAR 0 5
62010: PUSH
62011: LD_VAR 0 6
62015: DIFF
62016: ST_TO_ADDR
// if not need_heal_1 then
62017: LD_VAR 0 6
62021: NOT
62022: IFFALSE 62055
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
62024: LD_ADDR_EXP 72
62028: PUSH
62029: LD_EXP 72
62033: PPUSH
62034: LD_VAR 0 2
62038: PUSH
62039: LD_INT 1
62041: PUSH
62042: EMPTY
62043: LIST
62044: LIST
62045: PPUSH
62046: EMPTY
62047: PPUSH
62048: CALL 18588 0 3
62052: ST_TO_ADDR
62053: GO 62125
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
62055: LD_ADDR_EXP 72
62059: PUSH
62060: LD_EXP 72
62064: PPUSH
62065: LD_VAR 0 2
62069: PUSH
62070: LD_INT 1
62072: PUSH
62073: EMPTY
62074: LIST
62075: LIST
62076: PPUSH
62077: LD_EXP 72
62081: PUSH
62082: LD_VAR 0 2
62086: ARRAY
62087: PUSH
62088: LD_INT 1
62090: ARRAY
62091: PPUSH
62092: LD_INT 3
62094: PUSH
62095: LD_INT 24
62097: PUSH
62098: LD_INT 1000
62100: PUSH
62101: EMPTY
62102: LIST
62103: LIST
62104: PUSH
62105: EMPTY
62106: LIST
62107: LIST
62108: PPUSH
62109: CALL_OW 72
62113: PUSH
62114: LD_VAR 0 6
62118: UNION
62119: PPUSH
62120: CALL 18588 0 3
62124: ST_TO_ADDR
// if not need_heal_2 then
62125: LD_VAR 0 7
62129: NOT
62130: IFFALSE 62163
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
62132: LD_ADDR_EXP 72
62136: PUSH
62137: LD_EXP 72
62141: PPUSH
62142: LD_VAR 0 2
62146: PUSH
62147: LD_INT 2
62149: PUSH
62150: EMPTY
62151: LIST
62152: LIST
62153: PPUSH
62154: EMPTY
62155: PPUSH
62156: CALL 18588 0 3
62160: ST_TO_ADDR
62161: GO 62195
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
62163: LD_ADDR_EXP 72
62167: PUSH
62168: LD_EXP 72
62172: PPUSH
62173: LD_VAR 0 2
62177: PUSH
62178: LD_INT 2
62180: PUSH
62181: EMPTY
62182: LIST
62183: LIST
62184: PPUSH
62185: LD_VAR 0 7
62189: PPUSH
62190: CALL 18588 0 3
62194: ST_TO_ADDR
// if need_heal_2 then
62195: LD_VAR 0 7
62199: IFFALSE 62360
// for j in need_heal_2 do
62201: LD_ADDR_VAR 0 3
62205: PUSH
62206: LD_VAR 0 7
62210: PUSH
62211: FOR_IN
62212: IFFALSE 62358
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62214: LD_ADDR_VAR 0 5
62218: PUSH
62219: LD_EXP 69
62223: PUSH
62224: LD_VAR 0 2
62228: ARRAY
62229: PPUSH
62230: LD_INT 2
62232: PUSH
62233: LD_INT 30
62235: PUSH
62236: LD_INT 6
62238: PUSH
62239: EMPTY
62240: LIST
62241: LIST
62242: PUSH
62243: LD_INT 30
62245: PUSH
62246: LD_INT 7
62248: PUSH
62249: EMPTY
62250: LIST
62251: LIST
62252: PUSH
62253: LD_INT 30
62255: PUSH
62256: LD_INT 8
62258: PUSH
62259: EMPTY
62260: LIST
62261: LIST
62262: PUSH
62263: LD_INT 30
62265: PUSH
62266: LD_INT 0
62268: PUSH
62269: EMPTY
62270: LIST
62271: LIST
62272: PUSH
62273: LD_INT 30
62275: PUSH
62276: LD_INT 1
62278: PUSH
62279: EMPTY
62280: LIST
62281: LIST
62282: PUSH
62283: EMPTY
62284: LIST
62285: LIST
62286: LIST
62287: LIST
62288: LIST
62289: LIST
62290: PPUSH
62291: CALL_OW 72
62295: ST_TO_ADDR
// if tmp then
62296: LD_VAR 0 5
62300: IFFALSE 62356
// begin k := NearestUnitToUnit ( tmp , j ) ;
62302: LD_ADDR_VAR 0 4
62306: PUSH
62307: LD_VAR 0 5
62311: PPUSH
62312: LD_VAR 0 3
62316: PPUSH
62317: CALL_OW 74
62321: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
62322: LD_VAR 0 3
62326: PPUSH
62327: LD_VAR 0 4
62331: PPUSH
62332: CALL_OW 296
62336: PUSH
62337: LD_INT 5
62339: GREATER
62340: IFFALSE 62356
// ComMoveToNearbyEntrance ( j , k ) ;
62342: LD_VAR 0 3
62346: PPUSH
62347: LD_VAR 0 4
62351: PPUSH
62352: CALL 51206 0 2
// end ; end ;
62356: GO 62211
62358: POP
62359: POP
// if not need_heal_1 and not need_heal_2 then
62360: LD_VAR 0 6
62364: NOT
62365: PUSH
62366: LD_VAR 0 7
62370: NOT
62371: AND
62372: IFFALSE 62376
// continue ;
62374: GO 61840
// end ;
62376: GO 61840
62378: POP
62379: POP
// RaiseSailEvent ( 102 ) ;
62380: LD_INT 102
62382: PPUSH
62383: CALL_OW 427
// end ;
62387: LD_VAR 0 1
62391: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
62392: LD_INT 0
62394: PPUSH
62395: PPUSH
62396: PPUSH
62397: PPUSH
62398: PPUSH
62399: PPUSH
62400: PPUSH
62401: PPUSH
// if not mc_bases then
62402: LD_EXP 69
62406: NOT
62407: IFFALSE 62411
// exit ;
62409: GO 63294
// for i = 1 to mc_bases do
62411: LD_ADDR_VAR 0 2
62415: PUSH
62416: DOUBLE
62417: LD_INT 1
62419: DEC
62420: ST_TO_ADDR
62421: LD_EXP 69
62425: PUSH
62426: FOR_TO
62427: IFFALSE 63292
// begin if not mc_building_need_repair [ i ] then
62429: LD_EXP 70
62433: PUSH
62434: LD_VAR 0 2
62438: ARRAY
62439: NOT
62440: IFFALSE 62627
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
62442: LD_ADDR_VAR 0 6
62446: PUSH
62447: LD_EXP 88
62451: PUSH
62452: LD_VAR 0 2
62456: ARRAY
62457: PPUSH
62458: LD_INT 3
62460: PUSH
62461: LD_INT 24
62463: PUSH
62464: LD_INT 1000
62466: PUSH
62467: EMPTY
62468: LIST
62469: LIST
62470: PUSH
62471: EMPTY
62472: LIST
62473: LIST
62474: PUSH
62475: LD_INT 2
62477: PUSH
62478: LD_INT 34
62480: PUSH
62481: LD_INT 13
62483: PUSH
62484: EMPTY
62485: LIST
62486: LIST
62487: PUSH
62488: LD_INT 34
62490: PUSH
62491: LD_INT 52
62493: PUSH
62494: EMPTY
62495: LIST
62496: LIST
62497: PUSH
62498: LD_INT 34
62500: PUSH
62501: LD_EXP 54
62505: PUSH
62506: EMPTY
62507: LIST
62508: LIST
62509: PUSH
62510: EMPTY
62511: LIST
62512: LIST
62513: LIST
62514: LIST
62515: PUSH
62516: EMPTY
62517: LIST
62518: LIST
62519: PPUSH
62520: CALL_OW 72
62524: ST_TO_ADDR
// if cranes then
62525: LD_VAR 0 6
62529: IFFALSE 62591
// for j in cranes do
62531: LD_ADDR_VAR 0 3
62535: PUSH
62536: LD_VAR 0 6
62540: PUSH
62541: FOR_IN
62542: IFFALSE 62589
// if not IsInArea ( j , mc_parking [ i ] ) then
62544: LD_VAR 0 3
62548: PPUSH
62549: LD_EXP 93
62553: PUSH
62554: LD_VAR 0 2
62558: ARRAY
62559: PPUSH
62560: CALL_OW 308
62564: NOT
62565: IFFALSE 62587
// ComMoveToArea ( j , mc_parking [ i ] ) ;
62567: LD_VAR 0 3
62571: PPUSH
62572: LD_EXP 93
62576: PUSH
62577: LD_VAR 0 2
62581: ARRAY
62582: PPUSH
62583: CALL_OW 113
62587: GO 62541
62589: POP
62590: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
62591: LD_ADDR_EXP 71
62595: PUSH
62596: LD_EXP 71
62600: PPUSH
62601: LD_VAR 0 2
62605: PPUSH
62606: EMPTY
62607: PPUSH
62608: CALL_OW 1
62612: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
62613: LD_VAR 0 2
62617: PPUSH
62618: LD_INT 101
62620: PPUSH
62621: CALL 57479 0 2
// continue ;
62625: GO 62426
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
62627: LD_ADDR_EXP 75
62631: PUSH
62632: LD_EXP 75
62636: PPUSH
62637: LD_VAR 0 2
62641: PPUSH
62642: EMPTY
62643: PPUSH
62644: CALL_OW 1
62648: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62649: LD_VAR 0 2
62653: PPUSH
62654: LD_INT 103
62656: PPUSH
62657: CALL 57479 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
62661: LD_ADDR_VAR 0 5
62665: PUSH
62666: LD_EXP 69
62670: PUSH
62671: LD_VAR 0 2
62675: ARRAY
62676: PUSH
62677: LD_EXP 98
62681: PUSH
62682: LD_VAR 0 2
62686: ARRAY
62687: UNION
62688: PPUSH
62689: LD_INT 2
62691: PUSH
62692: LD_INT 25
62694: PUSH
62695: LD_INT 2
62697: PUSH
62698: EMPTY
62699: LIST
62700: LIST
62701: PUSH
62702: LD_INT 25
62704: PUSH
62705: LD_INT 16
62707: PUSH
62708: EMPTY
62709: LIST
62710: LIST
62711: PUSH
62712: EMPTY
62713: LIST
62714: LIST
62715: LIST
62716: PUSH
62717: EMPTY
62718: LIST
62719: PPUSH
62720: CALL_OW 72
62724: ST_TO_ADDR
// if mc_need_heal [ i ] then
62725: LD_EXP 72
62729: PUSH
62730: LD_VAR 0 2
62734: ARRAY
62735: IFFALSE 62779
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
62737: LD_ADDR_VAR 0 5
62741: PUSH
62742: LD_VAR 0 5
62746: PUSH
62747: LD_EXP 72
62751: PUSH
62752: LD_VAR 0 2
62756: ARRAY
62757: PUSH
62758: LD_INT 1
62760: ARRAY
62761: PUSH
62762: LD_EXP 72
62766: PUSH
62767: LD_VAR 0 2
62771: ARRAY
62772: PUSH
62773: LD_INT 2
62775: ARRAY
62776: UNION
62777: DIFF
62778: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
62779: LD_ADDR_VAR 0 6
62783: PUSH
62784: LD_EXP 88
62788: PUSH
62789: LD_VAR 0 2
62793: ARRAY
62794: PPUSH
62795: LD_INT 2
62797: PUSH
62798: LD_INT 34
62800: PUSH
62801: LD_INT 13
62803: PUSH
62804: EMPTY
62805: LIST
62806: LIST
62807: PUSH
62808: LD_INT 34
62810: PUSH
62811: LD_INT 52
62813: PUSH
62814: EMPTY
62815: LIST
62816: LIST
62817: PUSH
62818: LD_INT 34
62820: PUSH
62821: LD_EXP 54
62825: PUSH
62826: EMPTY
62827: LIST
62828: LIST
62829: PUSH
62830: EMPTY
62831: LIST
62832: LIST
62833: LIST
62834: LIST
62835: PPUSH
62836: CALL_OW 72
62840: ST_TO_ADDR
// if cranes then
62841: LD_VAR 0 6
62845: IFFALSE 62981
// begin for j in cranes do
62847: LD_ADDR_VAR 0 3
62851: PUSH
62852: LD_VAR 0 6
62856: PUSH
62857: FOR_IN
62858: IFFALSE 62979
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
62860: LD_VAR 0 3
62864: PPUSH
62865: CALL_OW 256
62869: PUSH
62870: LD_INT 1000
62872: EQUAL
62873: PUSH
62874: LD_VAR 0 3
62878: PPUSH
62879: CALL_OW 314
62883: NOT
62884: AND
62885: IFFALSE 62919
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
62887: LD_VAR 0 3
62891: PPUSH
62892: LD_EXP 70
62896: PUSH
62897: LD_VAR 0 2
62901: ARRAY
62902: PPUSH
62903: LD_VAR 0 3
62907: PPUSH
62908: CALL_OW 74
62912: PPUSH
62913: CALL_OW 130
62917: GO 62977
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
62919: LD_VAR 0 3
62923: PPUSH
62924: CALL_OW 256
62928: PUSH
62929: LD_INT 500
62931: LESS
62932: PUSH
62933: LD_VAR 0 3
62937: PPUSH
62938: LD_EXP 93
62942: PUSH
62943: LD_VAR 0 2
62947: ARRAY
62948: PPUSH
62949: CALL_OW 308
62953: NOT
62954: AND
62955: IFFALSE 62977
// ComMoveToArea ( j , mc_parking [ i ] ) ;
62957: LD_VAR 0 3
62961: PPUSH
62962: LD_EXP 93
62966: PUSH
62967: LD_VAR 0 2
62971: ARRAY
62972: PPUSH
62973: CALL_OW 113
// end ;
62977: GO 62857
62979: POP
62980: POP
// end ; if tmp > 3 then
62981: LD_VAR 0 5
62985: PUSH
62986: LD_INT 3
62988: GREATER
62989: IFFALSE 63009
// tmp := ShrinkArray ( tmp , 4 ) ;
62991: LD_ADDR_VAR 0 5
62995: PUSH
62996: LD_VAR 0 5
63000: PPUSH
63001: LD_INT 4
63003: PPUSH
63004: CALL 50654 0 2
63008: ST_TO_ADDR
// if not tmp then
63009: LD_VAR 0 5
63013: NOT
63014: IFFALSE 63018
// continue ;
63016: GO 62426
// for j in tmp do
63018: LD_ADDR_VAR 0 3
63022: PUSH
63023: LD_VAR 0 5
63027: PUSH
63028: FOR_IN
63029: IFFALSE 63288
// begin if IsInUnit ( j ) then
63031: LD_VAR 0 3
63035: PPUSH
63036: CALL_OW 310
63040: IFFALSE 63051
// ComExitBuilding ( j ) ;
63042: LD_VAR 0 3
63046: PPUSH
63047: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
63051: LD_VAR 0 3
63055: PUSH
63056: LD_EXP 71
63060: PUSH
63061: LD_VAR 0 2
63065: ARRAY
63066: IN
63067: NOT
63068: IFFALSE 63126
// begin SetTag ( j , 101 ) ;
63070: LD_VAR 0 3
63074: PPUSH
63075: LD_INT 101
63077: PPUSH
63078: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
63082: LD_ADDR_EXP 71
63086: PUSH
63087: LD_EXP 71
63091: PPUSH
63092: LD_VAR 0 2
63096: PUSH
63097: LD_EXP 71
63101: PUSH
63102: LD_VAR 0 2
63106: ARRAY
63107: PUSH
63108: LD_INT 1
63110: PLUS
63111: PUSH
63112: EMPTY
63113: LIST
63114: LIST
63115: PPUSH
63116: LD_VAR 0 3
63120: PPUSH
63121: CALL 18588 0 3
63125: ST_TO_ADDR
// end ; wait ( 1 ) ;
63126: LD_INT 1
63128: PPUSH
63129: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
63133: LD_ADDR_VAR 0 7
63137: PUSH
63138: LD_EXP 70
63142: PUSH
63143: LD_VAR 0 2
63147: ARRAY
63148: ST_TO_ADDR
// if mc_scan [ i ] then
63149: LD_EXP 92
63153: PUSH
63154: LD_VAR 0 2
63158: ARRAY
63159: IFFALSE 63221
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
63161: LD_ADDR_VAR 0 7
63165: PUSH
63166: LD_EXP 70
63170: PUSH
63171: LD_VAR 0 2
63175: ARRAY
63176: PPUSH
63177: LD_INT 3
63179: PUSH
63180: LD_INT 30
63182: PUSH
63183: LD_INT 32
63185: PUSH
63186: EMPTY
63187: LIST
63188: LIST
63189: PUSH
63190: LD_INT 30
63192: PUSH
63193: LD_INT 33
63195: PUSH
63196: EMPTY
63197: LIST
63198: LIST
63199: PUSH
63200: LD_INT 30
63202: PUSH
63203: LD_INT 31
63205: PUSH
63206: EMPTY
63207: LIST
63208: LIST
63209: PUSH
63210: EMPTY
63211: LIST
63212: LIST
63213: LIST
63214: LIST
63215: PPUSH
63216: CALL_OW 72
63220: ST_TO_ADDR
// if not to_repair_tmp then
63221: LD_VAR 0 7
63225: NOT
63226: IFFALSE 63230
// continue ;
63228: GO 63028
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
63230: LD_ADDR_VAR 0 8
63234: PUSH
63235: LD_VAR 0 7
63239: PPUSH
63240: LD_VAR 0 3
63244: PPUSH
63245: CALL_OW 74
63249: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
63250: LD_VAR 0 8
63254: PPUSH
63255: LD_INT 16
63257: PPUSH
63258: CALL 21187 0 2
63262: PUSH
63263: LD_INT 4
63265: ARRAY
63266: PUSH
63267: LD_INT 10
63269: LESS
63270: IFFALSE 63286
// ComRepairBuilding ( j , to_repair ) ;
63272: LD_VAR 0 3
63276: PPUSH
63277: LD_VAR 0 8
63281: PPUSH
63282: CALL_OW 130
// end ;
63286: GO 63028
63288: POP
63289: POP
// end ;
63290: GO 62426
63292: POP
63293: POP
// end ;
63294: LD_VAR 0 1
63298: RET
// export function MC_Heal ; var i , j , tmp ; begin
63299: LD_INT 0
63301: PPUSH
63302: PPUSH
63303: PPUSH
63304: PPUSH
// if not mc_bases then
63305: LD_EXP 69
63309: NOT
63310: IFFALSE 63314
// exit ;
63312: GO 63716
// for i = 1 to mc_bases do
63314: LD_ADDR_VAR 0 2
63318: PUSH
63319: DOUBLE
63320: LD_INT 1
63322: DEC
63323: ST_TO_ADDR
63324: LD_EXP 69
63328: PUSH
63329: FOR_TO
63330: IFFALSE 63714
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
63332: LD_EXP 72
63336: PUSH
63337: LD_VAR 0 2
63341: ARRAY
63342: PUSH
63343: LD_INT 1
63345: ARRAY
63346: NOT
63347: PUSH
63348: LD_EXP 72
63352: PUSH
63353: LD_VAR 0 2
63357: ARRAY
63358: PUSH
63359: LD_INT 2
63361: ARRAY
63362: NOT
63363: AND
63364: IFFALSE 63402
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
63366: LD_ADDR_EXP 73
63370: PUSH
63371: LD_EXP 73
63375: PPUSH
63376: LD_VAR 0 2
63380: PPUSH
63381: EMPTY
63382: PPUSH
63383: CALL_OW 1
63387: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
63388: LD_VAR 0 2
63392: PPUSH
63393: LD_INT 102
63395: PPUSH
63396: CALL 57479 0 2
// continue ;
63400: GO 63329
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
63402: LD_ADDR_VAR 0 4
63406: PUSH
63407: LD_EXP 69
63411: PUSH
63412: LD_VAR 0 2
63416: ARRAY
63417: PPUSH
63418: LD_INT 25
63420: PUSH
63421: LD_INT 4
63423: PUSH
63424: EMPTY
63425: LIST
63426: LIST
63427: PPUSH
63428: CALL_OW 72
63432: ST_TO_ADDR
// if not tmp then
63433: LD_VAR 0 4
63437: NOT
63438: IFFALSE 63442
// continue ;
63440: GO 63329
// if mc_taming [ i ] then
63442: LD_EXP 100
63446: PUSH
63447: LD_VAR 0 2
63451: ARRAY
63452: IFFALSE 63476
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63454: LD_ADDR_EXP 100
63458: PUSH
63459: LD_EXP 100
63463: PPUSH
63464: LD_VAR 0 2
63468: PPUSH
63469: EMPTY
63470: PPUSH
63471: CALL_OW 1
63475: ST_TO_ADDR
// for j in tmp do
63476: LD_ADDR_VAR 0 3
63480: PUSH
63481: LD_VAR 0 4
63485: PUSH
63486: FOR_IN
63487: IFFALSE 63710
// begin if IsInUnit ( j ) then
63489: LD_VAR 0 3
63493: PPUSH
63494: CALL_OW 310
63498: IFFALSE 63509
// ComExitBuilding ( j ) ;
63500: LD_VAR 0 3
63504: PPUSH
63505: CALL_OW 122
// if not j in mc_healers [ i ] then
63509: LD_VAR 0 3
63513: PUSH
63514: LD_EXP 73
63518: PUSH
63519: LD_VAR 0 2
63523: ARRAY
63524: IN
63525: NOT
63526: IFFALSE 63572
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
63528: LD_ADDR_EXP 73
63532: PUSH
63533: LD_EXP 73
63537: PPUSH
63538: LD_VAR 0 2
63542: PUSH
63543: LD_EXP 73
63547: PUSH
63548: LD_VAR 0 2
63552: ARRAY
63553: PUSH
63554: LD_INT 1
63556: PLUS
63557: PUSH
63558: EMPTY
63559: LIST
63560: LIST
63561: PPUSH
63562: LD_VAR 0 3
63566: PPUSH
63567: CALL 18588 0 3
63571: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
63572: LD_VAR 0 3
63576: PPUSH
63577: CALL_OW 110
63581: PUSH
63582: LD_INT 102
63584: NONEQUAL
63585: IFFALSE 63599
// SetTag ( j , 102 ) ;
63587: LD_VAR 0 3
63591: PPUSH
63592: LD_INT 102
63594: PPUSH
63595: CALL_OW 109
// Wait ( 3 ) ;
63599: LD_INT 3
63601: PPUSH
63602: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
63606: LD_EXP 72
63610: PUSH
63611: LD_VAR 0 2
63615: ARRAY
63616: PUSH
63617: LD_INT 1
63619: ARRAY
63620: IFFALSE 63652
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
63622: LD_VAR 0 3
63626: PPUSH
63627: LD_EXP 72
63631: PUSH
63632: LD_VAR 0 2
63636: ARRAY
63637: PUSH
63638: LD_INT 1
63640: ARRAY
63641: PUSH
63642: LD_INT 1
63644: ARRAY
63645: PPUSH
63646: CALL_OW 128
63650: GO 63708
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
63652: LD_VAR 0 3
63656: PPUSH
63657: CALL_OW 314
63661: NOT
63662: PUSH
63663: LD_EXP 72
63667: PUSH
63668: LD_VAR 0 2
63672: ARRAY
63673: PUSH
63674: LD_INT 2
63676: ARRAY
63677: AND
63678: IFFALSE 63708
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
63680: LD_VAR 0 3
63684: PPUSH
63685: LD_EXP 72
63689: PUSH
63690: LD_VAR 0 2
63694: ARRAY
63695: PUSH
63696: LD_INT 2
63698: ARRAY
63699: PUSH
63700: LD_INT 1
63702: ARRAY
63703: PPUSH
63704: CALL_OW 128
// end ;
63708: GO 63486
63710: POP
63711: POP
// end ;
63712: GO 63329
63714: POP
63715: POP
// end ;
63716: LD_VAR 0 1
63720: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
63721: LD_INT 0
63723: PPUSH
63724: PPUSH
63725: PPUSH
63726: PPUSH
63727: PPUSH
// if not mc_bases then
63728: LD_EXP 69
63732: NOT
63733: IFFALSE 63737
// exit ;
63735: GO 64908
// for i = 1 to mc_bases do
63737: LD_ADDR_VAR 0 2
63741: PUSH
63742: DOUBLE
63743: LD_INT 1
63745: DEC
63746: ST_TO_ADDR
63747: LD_EXP 69
63751: PUSH
63752: FOR_TO
63753: IFFALSE 64906
// begin if mc_scan [ i ] then
63755: LD_EXP 92
63759: PUSH
63760: LD_VAR 0 2
63764: ARRAY
63765: IFFALSE 63769
// continue ;
63767: GO 63752
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
63769: LD_EXP 74
63773: PUSH
63774: LD_VAR 0 2
63778: ARRAY
63779: NOT
63780: PUSH
63781: LD_EXP 76
63785: PUSH
63786: LD_VAR 0 2
63790: ARRAY
63791: NOT
63792: AND
63793: PUSH
63794: LD_EXP 75
63798: PUSH
63799: LD_VAR 0 2
63803: ARRAY
63804: AND
63805: IFFALSE 63843
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
63807: LD_ADDR_EXP 75
63811: PUSH
63812: LD_EXP 75
63816: PPUSH
63817: LD_VAR 0 2
63821: PPUSH
63822: EMPTY
63823: PPUSH
63824: CALL_OW 1
63828: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63829: LD_VAR 0 2
63833: PPUSH
63834: LD_INT 103
63836: PPUSH
63837: CALL 57479 0 2
// continue ;
63841: GO 63752
// end ; if mc_construct_list [ i ] then
63843: LD_EXP 76
63847: PUSH
63848: LD_VAR 0 2
63852: ARRAY
63853: IFFALSE 64073
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63855: LD_ADDR_VAR 0 4
63859: PUSH
63860: LD_EXP 69
63864: PUSH
63865: LD_VAR 0 2
63869: ARRAY
63870: PPUSH
63871: LD_INT 25
63873: PUSH
63874: LD_INT 2
63876: PUSH
63877: EMPTY
63878: LIST
63879: LIST
63880: PPUSH
63881: CALL_OW 72
63885: PUSH
63886: LD_EXP 71
63890: PUSH
63891: LD_VAR 0 2
63895: ARRAY
63896: DIFF
63897: ST_TO_ADDR
// if not tmp then
63898: LD_VAR 0 4
63902: NOT
63903: IFFALSE 63907
// continue ;
63905: GO 63752
// for j in tmp do
63907: LD_ADDR_VAR 0 3
63911: PUSH
63912: LD_VAR 0 4
63916: PUSH
63917: FOR_IN
63918: IFFALSE 64069
// begin if not mc_builders [ i ] then
63920: LD_EXP 75
63924: PUSH
63925: LD_VAR 0 2
63929: ARRAY
63930: NOT
63931: IFFALSE 63989
// begin SetTag ( j , 103 ) ;
63933: LD_VAR 0 3
63937: PPUSH
63938: LD_INT 103
63940: PPUSH
63941: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63945: LD_ADDR_EXP 75
63949: PUSH
63950: LD_EXP 75
63954: PPUSH
63955: LD_VAR 0 2
63959: PUSH
63960: LD_EXP 75
63964: PUSH
63965: LD_VAR 0 2
63969: ARRAY
63970: PUSH
63971: LD_INT 1
63973: PLUS
63974: PUSH
63975: EMPTY
63976: LIST
63977: LIST
63978: PPUSH
63979: LD_VAR 0 3
63983: PPUSH
63984: CALL 18588 0 3
63988: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63989: LD_VAR 0 3
63993: PPUSH
63994: CALL_OW 310
63998: IFFALSE 64009
// ComExitBuilding ( j ) ;
64000: LD_VAR 0 3
64004: PPUSH
64005: CALL_OW 122
// wait ( 3 ) ;
64009: LD_INT 3
64011: PPUSH
64012: CALL_OW 67
// if not mc_construct_list [ i ] then
64016: LD_EXP 76
64020: PUSH
64021: LD_VAR 0 2
64025: ARRAY
64026: NOT
64027: IFFALSE 64031
// break ;
64029: GO 64069
// if not HasTask ( j ) then
64031: LD_VAR 0 3
64035: PPUSH
64036: CALL_OW 314
64040: NOT
64041: IFFALSE 64067
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
64043: LD_VAR 0 3
64047: PPUSH
64048: LD_EXP 76
64052: PUSH
64053: LD_VAR 0 2
64057: ARRAY
64058: PUSH
64059: LD_INT 1
64061: ARRAY
64062: PPUSH
64063: CALL 21451 0 2
// end ;
64067: GO 63917
64069: POP
64070: POP
// end else
64071: GO 64904
// if mc_build_list [ i ] then
64073: LD_EXP 74
64077: PUSH
64078: LD_VAR 0 2
64082: ARRAY
64083: IFFALSE 64904
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64085: LD_ADDR_VAR 0 5
64089: PUSH
64090: LD_EXP 69
64094: PUSH
64095: LD_VAR 0 2
64099: ARRAY
64100: PPUSH
64101: LD_INT 2
64103: PUSH
64104: LD_INT 30
64106: PUSH
64107: LD_INT 0
64109: PUSH
64110: EMPTY
64111: LIST
64112: LIST
64113: PUSH
64114: LD_INT 30
64116: PUSH
64117: LD_INT 1
64119: PUSH
64120: EMPTY
64121: LIST
64122: LIST
64123: PUSH
64124: EMPTY
64125: LIST
64126: LIST
64127: LIST
64128: PPUSH
64129: CALL_OW 72
64133: ST_TO_ADDR
// if depot then
64134: LD_VAR 0 5
64138: IFFALSE 64156
// depot := depot [ 1 ] else
64140: LD_ADDR_VAR 0 5
64144: PUSH
64145: LD_VAR 0 5
64149: PUSH
64150: LD_INT 1
64152: ARRAY
64153: ST_TO_ADDR
64154: GO 64164
// depot := 0 ;
64156: LD_ADDR_VAR 0 5
64160: PUSH
64161: LD_INT 0
64163: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
64164: LD_EXP 74
64168: PUSH
64169: LD_VAR 0 2
64173: ARRAY
64174: PUSH
64175: LD_INT 1
64177: ARRAY
64178: PUSH
64179: LD_INT 1
64181: ARRAY
64182: PPUSH
64183: CALL 21275 0 1
64187: PUSH
64188: LD_EXP 69
64192: PUSH
64193: LD_VAR 0 2
64197: ARRAY
64198: PPUSH
64199: LD_INT 2
64201: PUSH
64202: LD_INT 30
64204: PUSH
64205: LD_INT 2
64207: PUSH
64208: EMPTY
64209: LIST
64210: LIST
64211: PUSH
64212: LD_INT 30
64214: PUSH
64215: LD_INT 3
64217: PUSH
64218: EMPTY
64219: LIST
64220: LIST
64221: PUSH
64222: EMPTY
64223: LIST
64224: LIST
64225: LIST
64226: PPUSH
64227: CALL_OW 72
64231: NOT
64232: AND
64233: IFFALSE 64338
// begin for j = 1 to mc_build_list [ i ] do
64235: LD_ADDR_VAR 0 3
64239: PUSH
64240: DOUBLE
64241: LD_INT 1
64243: DEC
64244: ST_TO_ADDR
64245: LD_EXP 74
64249: PUSH
64250: LD_VAR 0 2
64254: ARRAY
64255: PUSH
64256: FOR_TO
64257: IFFALSE 64336
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
64259: LD_EXP 74
64263: PUSH
64264: LD_VAR 0 2
64268: ARRAY
64269: PUSH
64270: LD_VAR 0 3
64274: ARRAY
64275: PUSH
64276: LD_INT 1
64278: ARRAY
64279: PUSH
64280: LD_INT 2
64282: EQUAL
64283: IFFALSE 64334
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
64285: LD_ADDR_EXP 74
64289: PUSH
64290: LD_EXP 74
64294: PPUSH
64295: LD_VAR 0 2
64299: PPUSH
64300: LD_EXP 74
64304: PUSH
64305: LD_VAR 0 2
64309: ARRAY
64310: PPUSH
64311: LD_VAR 0 3
64315: PPUSH
64316: LD_INT 1
64318: PPUSH
64319: LD_INT 0
64321: PPUSH
64322: CALL 18006 0 4
64326: PPUSH
64327: CALL_OW 1
64331: ST_TO_ADDR
// break ;
64332: GO 64336
// end ;
64334: GO 64256
64336: POP
64337: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
64338: LD_EXP 74
64342: PUSH
64343: LD_VAR 0 2
64347: ARRAY
64348: PUSH
64349: LD_INT 1
64351: ARRAY
64352: PUSH
64353: LD_INT 1
64355: ARRAY
64356: PUSH
64357: LD_INT 0
64359: EQUAL
64360: PUSH
64361: LD_VAR 0 5
64365: PUSH
64366: LD_VAR 0 5
64370: PPUSH
64371: LD_EXP 74
64375: PUSH
64376: LD_VAR 0 2
64380: ARRAY
64381: PUSH
64382: LD_INT 1
64384: ARRAY
64385: PUSH
64386: LD_INT 1
64388: ARRAY
64389: PPUSH
64390: LD_EXP 74
64394: PUSH
64395: LD_VAR 0 2
64399: ARRAY
64400: PUSH
64401: LD_INT 1
64403: ARRAY
64404: PUSH
64405: LD_INT 2
64407: ARRAY
64408: PPUSH
64409: LD_EXP 74
64413: PUSH
64414: LD_VAR 0 2
64418: ARRAY
64419: PUSH
64420: LD_INT 1
64422: ARRAY
64423: PUSH
64424: LD_INT 3
64426: ARRAY
64427: PPUSH
64428: LD_EXP 74
64432: PUSH
64433: LD_VAR 0 2
64437: ARRAY
64438: PUSH
64439: LD_INT 1
64441: ARRAY
64442: PUSH
64443: LD_INT 4
64445: ARRAY
64446: PPUSH
64447: CALL 26691 0 5
64451: AND
64452: OR
64453: IFFALSE 64734
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64455: LD_ADDR_VAR 0 4
64459: PUSH
64460: LD_EXP 69
64464: PUSH
64465: LD_VAR 0 2
64469: ARRAY
64470: PPUSH
64471: LD_INT 25
64473: PUSH
64474: LD_INT 2
64476: PUSH
64477: EMPTY
64478: LIST
64479: LIST
64480: PPUSH
64481: CALL_OW 72
64485: PUSH
64486: LD_EXP 71
64490: PUSH
64491: LD_VAR 0 2
64495: ARRAY
64496: DIFF
64497: ST_TO_ADDR
// if not tmp then
64498: LD_VAR 0 4
64502: NOT
64503: IFFALSE 64507
// continue ;
64505: GO 63752
// for j in tmp do
64507: LD_ADDR_VAR 0 3
64511: PUSH
64512: LD_VAR 0 4
64516: PUSH
64517: FOR_IN
64518: IFFALSE 64730
// begin if not mc_builders [ i ] then
64520: LD_EXP 75
64524: PUSH
64525: LD_VAR 0 2
64529: ARRAY
64530: NOT
64531: IFFALSE 64589
// begin SetTag ( j , 103 ) ;
64533: LD_VAR 0 3
64537: PPUSH
64538: LD_INT 103
64540: PPUSH
64541: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64545: LD_ADDR_EXP 75
64549: PUSH
64550: LD_EXP 75
64554: PPUSH
64555: LD_VAR 0 2
64559: PUSH
64560: LD_EXP 75
64564: PUSH
64565: LD_VAR 0 2
64569: ARRAY
64570: PUSH
64571: LD_INT 1
64573: PLUS
64574: PUSH
64575: EMPTY
64576: LIST
64577: LIST
64578: PPUSH
64579: LD_VAR 0 3
64583: PPUSH
64584: CALL 18588 0 3
64588: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64589: LD_VAR 0 3
64593: PPUSH
64594: CALL_OW 310
64598: IFFALSE 64609
// ComExitBuilding ( j ) ;
64600: LD_VAR 0 3
64604: PPUSH
64605: CALL_OW 122
// wait ( 3 ) ;
64609: LD_INT 3
64611: PPUSH
64612: CALL_OW 67
// if not mc_build_list [ i ] then
64616: LD_EXP 74
64620: PUSH
64621: LD_VAR 0 2
64625: ARRAY
64626: NOT
64627: IFFALSE 64631
// break ;
64629: GO 64730
// if not HasTask ( j ) then
64631: LD_VAR 0 3
64635: PPUSH
64636: CALL_OW 314
64640: NOT
64641: IFFALSE 64728
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
64643: LD_VAR 0 3
64647: PPUSH
64648: LD_EXP 74
64652: PUSH
64653: LD_VAR 0 2
64657: ARRAY
64658: PUSH
64659: LD_INT 1
64661: ARRAY
64662: PUSH
64663: LD_INT 1
64665: ARRAY
64666: PPUSH
64667: LD_EXP 74
64671: PUSH
64672: LD_VAR 0 2
64676: ARRAY
64677: PUSH
64678: LD_INT 1
64680: ARRAY
64681: PUSH
64682: LD_INT 2
64684: ARRAY
64685: PPUSH
64686: LD_EXP 74
64690: PUSH
64691: LD_VAR 0 2
64695: ARRAY
64696: PUSH
64697: LD_INT 1
64699: ARRAY
64700: PUSH
64701: LD_INT 3
64703: ARRAY
64704: PPUSH
64705: LD_EXP 74
64709: PUSH
64710: LD_VAR 0 2
64714: ARRAY
64715: PUSH
64716: LD_INT 1
64718: ARRAY
64719: PUSH
64720: LD_INT 4
64722: ARRAY
64723: PPUSH
64724: CALL_OW 145
// end ;
64728: GO 64517
64730: POP
64731: POP
// end else
64732: GO 64904
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
64734: LD_EXP 69
64738: PUSH
64739: LD_VAR 0 2
64743: ARRAY
64744: PPUSH
64745: LD_EXP 74
64749: PUSH
64750: LD_VAR 0 2
64754: ARRAY
64755: PUSH
64756: LD_INT 1
64758: ARRAY
64759: PUSH
64760: LD_INT 1
64762: ARRAY
64763: PPUSH
64764: LD_EXP 74
64768: PUSH
64769: LD_VAR 0 2
64773: ARRAY
64774: PUSH
64775: LD_INT 1
64777: ARRAY
64778: PUSH
64779: LD_INT 2
64781: ARRAY
64782: PPUSH
64783: LD_EXP 74
64787: PUSH
64788: LD_VAR 0 2
64792: ARRAY
64793: PUSH
64794: LD_INT 1
64796: ARRAY
64797: PUSH
64798: LD_INT 3
64800: ARRAY
64801: PPUSH
64802: LD_EXP 74
64806: PUSH
64807: LD_VAR 0 2
64811: ARRAY
64812: PUSH
64813: LD_INT 1
64815: ARRAY
64816: PUSH
64817: LD_INT 4
64819: ARRAY
64820: PPUSH
64821: LD_EXP 69
64825: PUSH
64826: LD_VAR 0 2
64830: ARRAY
64831: PPUSH
64832: LD_INT 21
64834: PUSH
64835: LD_INT 3
64837: PUSH
64838: EMPTY
64839: LIST
64840: LIST
64841: PPUSH
64842: CALL_OW 72
64846: PPUSH
64847: EMPTY
64848: PPUSH
64849: CALL 25441 0 7
64853: NOT
64854: IFFALSE 64904
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
64856: LD_ADDR_EXP 74
64860: PUSH
64861: LD_EXP 74
64865: PPUSH
64866: LD_VAR 0 2
64870: PPUSH
64871: LD_EXP 74
64875: PUSH
64876: LD_VAR 0 2
64880: ARRAY
64881: PPUSH
64882: LD_INT 1
64884: PPUSH
64885: LD_INT 1
64887: NEG
64888: PPUSH
64889: LD_INT 0
64891: PPUSH
64892: CALL 18006 0 4
64896: PPUSH
64897: CALL_OW 1
64901: ST_TO_ADDR
// continue ;
64902: GO 63752
// end ; end ; end ;
64904: GO 63752
64906: POP
64907: POP
// end ;
64908: LD_VAR 0 1
64912: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
64913: LD_INT 0
64915: PPUSH
64916: PPUSH
64917: PPUSH
64918: PPUSH
64919: PPUSH
64920: PPUSH
// if not mc_bases then
64921: LD_EXP 69
64925: NOT
64926: IFFALSE 64930
// exit ;
64928: GO 65357
// for i = 1 to mc_bases do
64930: LD_ADDR_VAR 0 2
64934: PUSH
64935: DOUBLE
64936: LD_INT 1
64938: DEC
64939: ST_TO_ADDR
64940: LD_EXP 69
64944: PUSH
64945: FOR_TO
64946: IFFALSE 65355
// begin tmp := mc_build_upgrade [ i ] ;
64948: LD_ADDR_VAR 0 4
64952: PUSH
64953: LD_EXP 101
64957: PUSH
64958: LD_VAR 0 2
64962: ARRAY
64963: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
64964: LD_ADDR_VAR 0 6
64968: PUSH
64969: LD_EXP 102
64973: PUSH
64974: LD_VAR 0 2
64978: ARRAY
64979: PPUSH
64980: LD_INT 2
64982: PUSH
64983: LD_INT 30
64985: PUSH
64986: LD_INT 6
64988: PUSH
64989: EMPTY
64990: LIST
64991: LIST
64992: PUSH
64993: LD_INT 30
64995: PUSH
64996: LD_INT 7
64998: PUSH
64999: EMPTY
65000: LIST
65001: LIST
65002: PUSH
65003: EMPTY
65004: LIST
65005: LIST
65006: LIST
65007: PPUSH
65008: CALL_OW 72
65012: ST_TO_ADDR
// if not tmp and not lab then
65013: LD_VAR 0 4
65017: NOT
65018: PUSH
65019: LD_VAR 0 6
65023: NOT
65024: AND
65025: IFFALSE 65029
// continue ;
65027: GO 64945
// if tmp then
65029: LD_VAR 0 4
65033: IFFALSE 65153
// for j in tmp do
65035: LD_ADDR_VAR 0 3
65039: PUSH
65040: LD_VAR 0 4
65044: PUSH
65045: FOR_IN
65046: IFFALSE 65151
// begin if UpgradeCost ( j ) then
65048: LD_VAR 0 3
65052: PPUSH
65053: CALL 25101 0 1
65057: IFFALSE 65149
// begin ComUpgrade ( j ) ;
65059: LD_VAR 0 3
65063: PPUSH
65064: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
65068: LD_ADDR_EXP 101
65072: PUSH
65073: LD_EXP 101
65077: PPUSH
65078: LD_VAR 0 2
65082: PPUSH
65083: LD_EXP 101
65087: PUSH
65088: LD_VAR 0 2
65092: ARRAY
65093: PUSH
65094: LD_VAR 0 3
65098: DIFF
65099: PPUSH
65100: CALL_OW 1
65104: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65105: LD_ADDR_EXP 76
65109: PUSH
65110: LD_EXP 76
65114: PPUSH
65115: LD_VAR 0 2
65119: PUSH
65120: LD_EXP 76
65124: PUSH
65125: LD_VAR 0 2
65129: ARRAY
65130: PUSH
65131: LD_INT 1
65133: PLUS
65134: PUSH
65135: EMPTY
65136: LIST
65137: LIST
65138: PPUSH
65139: LD_VAR 0 3
65143: PPUSH
65144: CALL 18588 0 3
65148: ST_TO_ADDR
// end ; end ;
65149: GO 65045
65151: POP
65152: POP
// if not lab or not mc_lab_upgrade [ i ] then
65153: LD_VAR 0 6
65157: NOT
65158: PUSH
65159: LD_EXP 103
65163: PUSH
65164: LD_VAR 0 2
65168: ARRAY
65169: NOT
65170: OR
65171: IFFALSE 65175
// continue ;
65173: GO 64945
// for j in lab do
65175: LD_ADDR_VAR 0 3
65179: PUSH
65180: LD_VAR 0 6
65184: PUSH
65185: FOR_IN
65186: IFFALSE 65351
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
65188: LD_VAR 0 3
65192: PPUSH
65193: CALL_OW 266
65197: PUSH
65198: LD_INT 6
65200: PUSH
65201: LD_INT 7
65203: PUSH
65204: EMPTY
65205: LIST
65206: LIST
65207: IN
65208: PUSH
65209: LD_VAR 0 3
65213: PPUSH
65214: CALL_OW 461
65218: PUSH
65219: LD_INT 1
65221: NONEQUAL
65222: AND
65223: IFFALSE 65349
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
65225: LD_VAR 0 3
65229: PPUSH
65230: LD_EXP 103
65234: PUSH
65235: LD_VAR 0 2
65239: ARRAY
65240: PUSH
65241: LD_INT 1
65243: ARRAY
65244: PPUSH
65245: CALL 25306 0 2
65249: IFFALSE 65349
// begin ComCancel ( j ) ;
65251: LD_VAR 0 3
65255: PPUSH
65256: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
65260: LD_VAR 0 3
65264: PPUSH
65265: LD_EXP 103
65269: PUSH
65270: LD_VAR 0 2
65274: ARRAY
65275: PUSH
65276: LD_INT 1
65278: ARRAY
65279: PPUSH
65280: CALL_OW 207
// if not j in mc_construct_list [ i ] then
65284: LD_VAR 0 3
65288: PUSH
65289: LD_EXP 76
65293: PUSH
65294: LD_VAR 0 2
65298: ARRAY
65299: IN
65300: NOT
65301: IFFALSE 65347
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65303: LD_ADDR_EXP 76
65307: PUSH
65308: LD_EXP 76
65312: PPUSH
65313: LD_VAR 0 2
65317: PUSH
65318: LD_EXP 76
65322: PUSH
65323: LD_VAR 0 2
65327: ARRAY
65328: PUSH
65329: LD_INT 1
65331: PLUS
65332: PUSH
65333: EMPTY
65334: LIST
65335: LIST
65336: PPUSH
65337: LD_VAR 0 3
65341: PPUSH
65342: CALL 18588 0 3
65346: ST_TO_ADDR
// break ;
65347: GO 65351
// end ; end ; end ;
65349: GO 65185
65351: POP
65352: POP
// end ;
65353: GO 64945
65355: POP
65356: POP
// end ;
65357: LD_VAR 0 1
65361: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
65362: LD_INT 0
65364: PPUSH
65365: PPUSH
65366: PPUSH
65367: PPUSH
65368: PPUSH
65369: PPUSH
65370: PPUSH
65371: PPUSH
65372: PPUSH
// if not mc_bases then
65373: LD_EXP 69
65377: NOT
65378: IFFALSE 65382
// exit ;
65380: GO 65787
// for i = 1 to mc_bases do
65382: LD_ADDR_VAR 0 2
65386: PUSH
65387: DOUBLE
65388: LD_INT 1
65390: DEC
65391: ST_TO_ADDR
65392: LD_EXP 69
65396: PUSH
65397: FOR_TO
65398: IFFALSE 65785
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
65400: LD_EXP 77
65404: PUSH
65405: LD_VAR 0 2
65409: ARRAY
65410: NOT
65411: PUSH
65412: LD_EXP 69
65416: PUSH
65417: LD_VAR 0 2
65421: ARRAY
65422: PPUSH
65423: LD_INT 30
65425: PUSH
65426: LD_INT 3
65428: PUSH
65429: EMPTY
65430: LIST
65431: LIST
65432: PPUSH
65433: CALL_OW 72
65437: NOT
65438: OR
65439: IFFALSE 65443
// continue ;
65441: GO 65397
// busy := false ;
65443: LD_ADDR_VAR 0 8
65447: PUSH
65448: LD_INT 0
65450: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65451: LD_ADDR_VAR 0 4
65455: PUSH
65456: LD_EXP 69
65460: PUSH
65461: LD_VAR 0 2
65465: ARRAY
65466: PPUSH
65467: LD_INT 30
65469: PUSH
65470: LD_INT 3
65472: PUSH
65473: EMPTY
65474: LIST
65475: LIST
65476: PPUSH
65477: CALL_OW 72
65481: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
65482: LD_ADDR_VAR 0 6
65486: PUSH
65487: LD_EXP 77
65491: PUSH
65492: LD_VAR 0 2
65496: ARRAY
65497: PPUSH
65498: LD_INT 2
65500: PUSH
65501: LD_INT 30
65503: PUSH
65504: LD_INT 32
65506: PUSH
65507: EMPTY
65508: LIST
65509: LIST
65510: PUSH
65511: LD_INT 30
65513: PUSH
65514: LD_INT 33
65516: PUSH
65517: EMPTY
65518: LIST
65519: LIST
65520: PUSH
65521: EMPTY
65522: LIST
65523: LIST
65524: LIST
65525: PPUSH
65526: CALL_OW 72
65530: ST_TO_ADDR
// if not t then
65531: LD_VAR 0 6
65535: NOT
65536: IFFALSE 65540
// continue ;
65538: GO 65397
// for j in tmp do
65540: LD_ADDR_VAR 0 3
65544: PUSH
65545: LD_VAR 0 4
65549: PUSH
65550: FOR_IN
65551: IFFALSE 65581
// if not BuildingStatus ( j ) = bs_idle then
65553: LD_VAR 0 3
65557: PPUSH
65558: CALL_OW 461
65562: PUSH
65563: LD_INT 2
65565: EQUAL
65566: NOT
65567: IFFALSE 65579
// begin busy := true ;
65569: LD_ADDR_VAR 0 8
65573: PUSH
65574: LD_INT 1
65576: ST_TO_ADDR
// break ;
65577: GO 65581
// end ;
65579: GO 65550
65581: POP
65582: POP
// if busy then
65583: LD_VAR 0 8
65587: IFFALSE 65591
// continue ;
65589: GO 65397
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
65591: LD_ADDR_VAR 0 7
65595: PUSH
65596: LD_VAR 0 6
65600: PPUSH
65601: LD_INT 35
65603: PUSH
65604: LD_INT 0
65606: PUSH
65607: EMPTY
65608: LIST
65609: LIST
65610: PPUSH
65611: CALL_OW 72
65615: ST_TO_ADDR
// if tw then
65616: LD_VAR 0 7
65620: IFFALSE 65697
// begin tw := tw [ 1 ] ;
65622: LD_ADDR_VAR 0 7
65626: PUSH
65627: LD_VAR 0 7
65631: PUSH
65632: LD_INT 1
65634: ARRAY
65635: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
65636: LD_ADDR_VAR 0 9
65640: PUSH
65641: LD_VAR 0 7
65645: PPUSH
65646: LD_EXP 94
65650: PUSH
65651: LD_VAR 0 2
65655: ARRAY
65656: PPUSH
65657: CALL 23598 0 2
65661: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
65662: LD_EXP 108
65666: PUSH
65667: LD_VAR 0 2
65671: ARRAY
65672: IFFALSE 65695
// if not weapon in mc_allowed_tower_weapons [ i ] then
65674: LD_VAR 0 9
65678: PUSH
65679: LD_EXP 108
65683: PUSH
65684: LD_VAR 0 2
65688: ARRAY
65689: IN
65690: NOT
65691: IFFALSE 65695
// continue ;
65693: GO 65397
// end else
65695: GO 65760
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
65697: LD_ADDR_VAR 0 5
65701: PUSH
65702: LD_EXP 77
65706: PUSH
65707: LD_VAR 0 2
65711: ARRAY
65712: PPUSH
65713: LD_VAR 0 4
65717: PPUSH
65718: CALL 49887 0 2
65722: ST_TO_ADDR
// if not tmp2 then
65723: LD_VAR 0 5
65727: NOT
65728: IFFALSE 65732
// continue ;
65730: GO 65397
// tw := tmp2 [ 1 ] ;
65732: LD_ADDR_VAR 0 7
65736: PUSH
65737: LD_VAR 0 5
65741: PUSH
65742: LD_INT 1
65744: ARRAY
65745: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
65746: LD_ADDR_VAR 0 9
65750: PUSH
65751: LD_VAR 0 5
65755: PUSH
65756: LD_INT 2
65758: ARRAY
65759: ST_TO_ADDR
// end ; if not weapon then
65760: LD_VAR 0 9
65764: NOT
65765: IFFALSE 65769
// continue ;
65767: GO 65397
// ComPlaceWeapon ( tw , weapon ) ;
65769: LD_VAR 0 7
65773: PPUSH
65774: LD_VAR 0 9
65778: PPUSH
65779: CALL_OW 148
// end ;
65783: GO 65397
65785: POP
65786: POP
// end ;
65787: LD_VAR 0 1
65791: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
65792: LD_INT 0
65794: PPUSH
65795: PPUSH
65796: PPUSH
65797: PPUSH
65798: PPUSH
65799: PPUSH
65800: PPUSH
// if not mc_bases then
65801: LD_EXP 69
65805: NOT
65806: IFFALSE 65810
// exit ;
65808: GO 66578
// for i = 1 to mc_bases do
65810: LD_ADDR_VAR 0 2
65814: PUSH
65815: DOUBLE
65816: LD_INT 1
65818: DEC
65819: ST_TO_ADDR
65820: LD_EXP 69
65824: PUSH
65825: FOR_TO
65826: IFFALSE 66576
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
65828: LD_EXP 82
65832: PUSH
65833: LD_VAR 0 2
65837: ARRAY
65838: NOT
65839: PUSH
65840: LD_EXP 82
65844: PUSH
65845: LD_VAR 0 2
65849: ARRAY
65850: PUSH
65851: LD_EXP 83
65855: PUSH
65856: LD_VAR 0 2
65860: ARRAY
65861: EQUAL
65862: OR
65863: PUSH
65864: LD_EXP 92
65868: PUSH
65869: LD_VAR 0 2
65873: ARRAY
65874: OR
65875: IFFALSE 65879
// continue ;
65877: GO 65825
// if mc_miners [ i ] then
65879: LD_EXP 83
65883: PUSH
65884: LD_VAR 0 2
65888: ARRAY
65889: IFFALSE 66263
// begin for j = mc_miners [ i ] downto 1 do
65891: LD_ADDR_VAR 0 3
65895: PUSH
65896: DOUBLE
65897: LD_EXP 83
65901: PUSH
65902: LD_VAR 0 2
65906: ARRAY
65907: INC
65908: ST_TO_ADDR
65909: LD_INT 1
65911: PUSH
65912: FOR_DOWNTO
65913: IFFALSE 66261
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
65915: LD_EXP 83
65919: PUSH
65920: LD_VAR 0 2
65924: ARRAY
65925: PUSH
65926: LD_VAR 0 3
65930: ARRAY
65931: PPUSH
65932: CALL_OW 301
65936: PUSH
65937: LD_EXP 83
65941: PUSH
65942: LD_VAR 0 2
65946: ARRAY
65947: PUSH
65948: LD_VAR 0 3
65952: ARRAY
65953: PPUSH
65954: CALL_OW 257
65958: PUSH
65959: LD_INT 1
65961: NONEQUAL
65962: OR
65963: IFFALSE 66026
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
65965: LD_ADDR_VAR 0 5
65969: PUSH
65970: LD_EXP 83
65974: PUSH
65975: LD_VAR 0 2
65979: ARRAY
65980: PUSH
65981: LD_EXP 83
65985: PUSH
65986: LD_VAR 0 2
65990: ARRAY
65991: PUSH
65992: LD_VAR 0 3
65996: ARRAY
65997: DIFF
65998: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
65999: LD_ADDR_EXP 83
66003: PUSH
66004: LD_EXP 83
66008: PPUSH
66009: LD_VAR 0 2
66013: PPUSH
66014: LD_VAR 0 5
66018: PPUSH
66019: CALL_OW 1
66023: ST_TO_ADDR
// continue ;
66024: GO 65912
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
66026: LD_EXP 83
66030: PUSH
66031: LD_VAR 0 2
66035: ARRAY
66036: PUSH
66037: LD_VAR 0 3
66041: ARRAY
66042: PPUSH
66043: CALL_OW 257
66047: PUSH
66048: LD_INT 1
66050: EQUAL
66051: PUSH
66052: LD_EXP 83
66056: PUSH
66057: LD_VAR 0 2
66061: ARRAY
66062: PUSH
66063: LD_VAR 0 3
66067: ARRAY
66068: PPUSH
66069: CALL_OW 459
66073: NOT
66074: AND
66075: PUSH
66076: LD_EXP 83
66080: PUSH
66081: LD_VAR 0 2
66085: ARRAY
66086: PUSH
66087: LD_VAR 0 3
66091: ARRAY
66092: PPUSH
66093: CALL_OW 314
66097: NOT
66098: AND
66099: IFFALSE 66259
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
66101: LD_EXP 83
66105: PUSH
66106: LD_VAR 0 2
66110: ARRAY
66111: PUSH
66112: LD_VAR 0 3
66116: ARRAY
66117: PPUSH
66118: CALL_OW 310
66122: IFFALSE 66145
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
66124: LD_EXP 83
66128: PUSH
66129: LD_VAR 0 2
66133: ARRAY
66134: PUSH
66135: LD_VAR 0 3
66139: ARRAY
66140: PPUSH
66141: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
66145: LD_EXP 83
66149: PUSH
66150: LD_VAR 0 2
66154: ARRAY
66155: PUSH
66156: LD_VAR 0 3
66160: ARRAY
66161: PPUSH
66162: CALL_OW 314
66166: NOT
66167: IFFALSE 66259
// begin r := rand ( 1 , mc_mines [ i ] ) ;
66169: LD_ADDR_VAR 0 7
66173: PUSH
66174: LD_INT 1
66176: PPUSH
66177: LD_EXP 82
66181: PUSH
66182: LD_VAR 0 2
66186: ARRAY
66187: PPUSH
66188: CALL_OW 12
66192: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
66193: LD_EXP 83
66197: PUSH
66198: LD_VAR 0 2
66202: ARRAY
66203: PUSH
66204: LD_VAR 0 3
66208: ARRAY
66209: PPUSH
66210: LD_EXP 82
66214: PUSH
66215: LD_VAR 0 2
66219: ARRAY
66220: PUSH
66221: LD_VAR 0 7
66225: ARRAY
66226: PUSH
66227: LD_INT 1
66229: ARRAY
66230: PPUSH
66231: LD_EXP 82
66235: PUSH
66236: LD_VAR 0 2
66240: ARRAY
66241: PUSH
66242: LD_VAR 0 7
66246: ARRAY
66247: PUSH
66248: LD_INT 2
66250: ARRAY
66251: PPUSH
66252: LD_INT 0
66254: PPUSH
66255: CALL_OW 193
// end ; end ; end ;
66259: GO 65912
66261: POP
66262: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
66263: LD_ADDR_VAR 0 5
66267: PUSH
66268: LD_EXP 69
66272: PUSH
66273: LD_VAR 0 2
66277: ARRAY
66278: PPUSH
66279: LD_INT 2
66281: PUSH
66282: LD_INT 30
66284: PUSH
66285: LD_INT 4
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: PUSH
66292: LD_INT 30
66294: PUSH
66295: LD_INT 5
66297: PUSH
66298: EMPTY
66299: LIST
66300: LIST
66301: PUSH
66302: LD_INT 30
66304: PUSH
66305: LD_INT 32
66307: PUSH
66308: EMPTY
66309: LIST
66310: LIST
66311: PUSH
66312: EMPTY
66313: LIST
66314: LIST
66315: LIST
66316: LIST
66317: PPUSH
66318: CALL_OW 72
66322: ST_TO_ADDR
// if not tmp then
66323: LD_VAR 0 5
66327: NOT
66328: IFFALSE 66332
// continue ;
66330: GO 65825
// list := [ ] ;
66332: LD_ADDR_VAR 0 6
66336: PUSH
66337: EMPTY
66338: ST_TO_ADDR
// for j in tmp do
66339: LD_ADDR_VAR 0 3
66343: PUSH
66344: LD_VAR 0 5
66348: PUSH
66349: FOR_IN
66350: IFFALSE 66419
// begin for k in UnitsInside ( j ) do
66352: LD_ADDR_VAR 0 4
66356: PUSH
66357: LD_VAR 0 3
66361: PPUSH
66362: CALL_OW 313
66366: PUSH
66367: FOR_IN
66368: IFFALSE 66415
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
66370: LD_VAR 0 4
66374: PPUSH
66375: CALL_OW 257
66379: PUSH
66380: LD_INT 1
66382: EQUAL
66383: PUSH
66384: LD_VAR 0 4
66388: PPUSH
66389: CALL_OW 459
66393: NOT
66394: AND
66395: IFFALSE 66413
// list := list ^ k ;
66397: LD_ADDR_VAR 0 6
66401: PUSH
66402: LD_VAR 0 6
66406: PUSH
66407: LD_VAR 0 4
66411: ADD
66412: ST_TO_ADDR
66413: GO 66367
66415: POP
66416: POP
// end ;
66417: GO 66349
66419: POP
66420: POP
// list := list diff mc_miners [ i ] ;
66421: LD_ADDR_VAR 0 6
66425: PUSH
66426: LD_VAR 0 6
66430: PUSH
66431: LD_EXP 83
66435: PUSH
66436: LD_VAR 0 2
66440: ARRAY
66441: DIFF
66442: ST_TO_ADDR
// if not list then
66443: LD_VAR 0 6
66447: NOT
66448: IFFALSE 66452
// continue ;
66450: GO 65825
// k := mc_mines [ i ] - mc_miners [ i ] ;
66452: LD_ADDR_VAR 0 4
66456: PUSH
66457: LD_EXP 82
66461: PUSH
66462: LD_VAR 0 2
66466: ARRAY
66467: PUSH
66468: LD_EXP 83
66472: PUSH
66473: LD_VAR 0 2
66477: ARRAY
66478: MINUS
66479: ST_TO_ADDR
// if k > list then
66480: LD_VAR 0 4
66484: PUSH
66485: LD_VAR 0 6
66489: GREATER
66490: IFFALSE 66502
// k := list ;
66492: LD_ADDR_VAR 0 4
66496: PUSH
66497: LD_VAR 0 6
66501: ST_TO_ADDR
// for j = 1 to k do
66502: LD_ADDR_VAR 0 3
66506: PUSH
66507: DOUBLE
66508: LD_INT 1
66510: DEC
66511: ST_TO_ADDR
66512: LD_VAR 0 4
66516: PUSH
66517: FOR_TO
66518: IFFALSE 66572
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
66520: LD_ADDR_EXP 83
66524: PUSH
66525: LD_EXP 83
66529: PPUSH
66530: LD_VAR 0 2
66534: PUSH
66535: LD_EXP 83
66539: PUSH
66540: LD_VAR 0 2
66544: ARRAY
66545: PUSH
66546: LD_INT 1
66548: PLUS
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: PPUSH
66554: LD_VAR 0 6
66558: PUSH
66559: LD_VAR 0 3
66563: ARRAY
66564: PPUSH
66565: CALL 18588 0 3
66569: ST_TO_ADDR
66570: GO 66517
66572: POP
66573: POP
// end ;
66574: GO 65825
66576: POP
66577: POP
// end ;
66578: LD_VAR 0 1
66582: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
66583: LD_INT 0
66585: PPUSH
66586: PPUSH
66587: PPUSH
66588: PPUSH
66589: PPUSH
66590: PPUSH
66591: PPUSH
66592: PPUSH
66593: PPUSH
66594: PPUSH
66595: PPUSH
// if not mc_bases then
66596: LD_EXP 69
66600: NOT
66601: IFFALSE 66605
// exit ;
66603: GO 68428
// for i = 1 to mc_bases do
66605: LD_ADDR_VAR 0 2
66609: PUSH
66610: DOUBLE
66611: LD_INT 1
66613: DEC
66614: ST_TO_ADDR
66615: LD_EXP 69
66619: PUSH
66620: FOR_TO
66621: IFFALSE 68426
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
66623: LD_EXP 69
66627: PUSH
66628: LD_VAR 0 2
66632: ARRAY
66633: NOT
66634: PUSH
66635: LD_EXP 76
66639: PUSH
66640: LD_VAR 0 2
66644: ARRAY
66645: OR
66646: IFFALSE 66650
// continue ;
66648: GO 66620
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
66650: LD_EXP 85
66654: PUSH
66655: LD_VAR 0 2
66659: ARRAY
66660: NOT
66661: PUSH
66662: LD_EXP 86
66666: PUSH
66667: LD_VAR 0 2
66671: ARRAY
66672: AND
66673: IFFALSE 66711
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
66675: LD_ADDR_EXP 86
66679: PUSH
66680: LD_EXP 86
66684: PPUSH
66685: LD_VAR 0 2
66689: PPUSH
66690: EMPTY
66691: PPUSH
66692: CALL_OW 1
66696: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
66697: LD_VAR 0 2
66701: PPUSH
66702: LD_INT 107
66704: PPUSH
66705: CALL 57479 0 2
// continue ;
66709: GO 66620
// end ; target := [ ] ;
66711: LD_ADDR_VAR 0 7
66715: PUSH
66716: EMPTY
66717: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
66718: LD_ADDR_VAR 0 6
66722: PUSH
66723: LD_EXP 69
66727: PUSH
66728: LD_VAR 0 2
66732: ARRAY
66733: PUSH
66734: LD_INT 1
66736: ARRAY
66737: PPUSH
66738: CALL_OW 255
66742: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66743: LD_ADDR_VAR 0 9
66747: PUSH
66748: LD_EXP 69
66752: PUSH
66753: LD_VAR 0 2
66757: ARRAY
66758: PPUSH
66759: LD_INT 2
66761: PUSH
66762: LD_INT 30
66764: PUSH
66765: LD_INT 0
66767: PUSH
66768: EMPTY
66769: LIST
66770: LIST
66771: PUSH
66772: LD_INT 30
66774: PUSH
66775: LD_INT 1
66777: PUSH
66778: EMPTY
66779: LIST
66780: LIST
66781: PUSH
66782: EMPTY
66783: LIST
66784: LIST
66785: LIST
66786: PPUSH
66787: CALL_OW 72
66791: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
66792: LD_ADDR_VAR 0 3
66796: PUSH
66797: DOUBLE
66798: LD_EXP 85
66802: PUSH
66803: LD_VAR 0 2
66807: ARRAY
66808: INC
66809: ST_TO_ADDR
66810: LD_INT 1
66812: PUSH
66813: FOR_DOWNTO
66814: IFFALSE 67059
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
66816: LD_EXP 85
66820: PUSH
66821: LD_VAR 0 2
66825: ARRAY
66826: PUSH
66827: LD_VAR 0 3
66831: ARRAY
66832: PUSH
66833: LD_INT 2
66835: ARRAY
66836: PPUSH
66837: LD_EXP 85
66841: PUSH
66842: LD_VAR 0 2
66846: ARRAY
66847: PUSH
66848: LD_VAR 0 3
66852: ARRAY
66853: PUSH
66854: LD_INT 3
66856: ARRAY
66857: PPUSH
66858: CALL_OW 488
66862: PUSH
66863: LD_EXP 85
66867: PUSH
66868: LD_VAR 0 2
66872: ARRAY
66873: PUSH
66874: LD_VAR 0 3
66878: ARRAY
66879: PUSH
66880: LD_INT 2
66882: ARRAY
66883: PPUSH
66884: LD_EXP 85
66888: PUSH
66889: LD_VAR 0 2
66893: ARRAY
66894: PUSH
66895: LD_VAR 0 3
66899: ARRAY
66900: PUSH
66901: LD_INT 3
66903: ARRAY
66904: PPUSH
66905: CALL_OW 284
66909: PUSH
66910: LD_INT 0
66912: EQUAL
66913: AND
66914: IFFALSE 66969
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
66916: LD_ADDR_VAR 0 5
66920: PUSH
66921: LD_EXP 85
66925: PUSH
66926: LD_VAR 0 2
66930: ARRAY
66931: PPUSH
66932: LD_VAR 0 3
66936: PPUSH
66937: CALL_OW 3
66941: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
66942: LD_ADDR_EXP 85
66946: PUSH
66947: LD_EXP 85
66951: PPUSH
66952: LD_VAR 0 2
66956: PPUSH
66957: LD_VAR 0 5
66961: PPUSH
66962: CALL_OW 1
66966: ST_TO_ADDR
// continue ;
66967: GO 66813
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
66969: LD_VAR 0 6
66973: PPUSH
66974: LD_EXP 85
66978: PUSH
66979: LD_VAR 0 2
66983: ARRAY
66984: PUSH
66985: LD_VAR 0 3
66989: ARRAY
66990: PUSH
66991: LD_INT 2
66993: ARRAY
66994: PPUSH
66995: LD_EXP 85
66999: PUSH
67000: LD_VAR 0 2
67004: ARRAY
67005: PUSH
67006: LD_VAR 0 3
67010: ARRAY
67011: PUSH
67012: LD_INT 3
67014: ARRAY
67015: PPUSH
67016: LD_INT 30
67018: PPUSH
67019: CALL 19484 0 4
67023: PUSH
67024: LD_INT 4
67026: ARRAY
67027: PUSH
67028: LD_INT 0
67030: EQUAL
67031: IFFALSE 67057
// begin target := mc_crates [ i ] [ j ] ;
67033: LD_ADDR_VAR 0 7
67037: PUSH
67038: LD_EXP 85
67042: PUSH
67043: LD_VAR 0 2
67047: ARRAY
67048: PUSH
67049: LD_VAR 0 3
67053: ARRAY
67054: ST_TO_ADDR
// break ;
67055: GO 67059
// end ; end ;
67057: GO 66813
67059: POP
67060: POP
// if not target then
67061: LD_VAR 0 7
67065: NOT
67066: IFFALSE 67070
// continue ;
67068: GO 66620
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
67070: LD_ADDR_VAR 0 8
67074: PUSH
67075: LD_EXP 88
67079: PUSH
67080: LD_VAR 0 2
67084: ARRAY
67085: PPUSH
67086: LD_INT 2
67088: PUSH
67089: LD_INT 3
67091: PUSH
67092: LD_INT 58
67094: PUSH
67095: EMPTY
67096: LIST
67097: PUSH
67098: EMPTY
67099: LIST
67100: LIST
67101: PUSH
67102: LD_INT 61
67104: PUSH
67105: EMPTY
67106: LIST
67107: PUSH
67108: LD_INT 33
67110: PUSH
67111: LD_INT 5
67113: PUSH
67114: EMPTY
67115: LIST
67116: LIST
67117: PUSH
67118: LD_INT 33
67120: PUSH
67121: LD_INT 3
67123: PUSH
67124: EMPTY
67125: LIST
67126: LIST
67127: PUSH
67128: EMPTY
67129: LIST
67130: LIST
67131: LIST
67132: LIST
67133: LIST
67134: PUSH
67135: LD_INT 2
67137: PUSH
67138: LD_INT 34
67140: PUSH
67141: LD_INT 32
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: PUSH
67148: LD_INT 34
67150: PUSH
67151: LD_INT 51
67153: PUSH
67154: EMPTY
67155: LIST
67156: LIST
67157: PUSH
67158: LD_INT 34
67160: PUSH
67161: LD_INT 12
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: PUSH
67168: EMPTY
67169: LIST
67170: LIST
67171: LIST
67172: LIST
67173: PUSH
67174: EMPTY
67175: LIST
67176: LIST
67177: PPUSH
67178: CALL_OW 72
67182: ST_TO_ADDR
// if not cargo then
67183: LD_VAR 0 8
67187: NOT
67188: IFFALSE 67894
// begin if mc_crates_collector [ i ] < 5 then
67190: LD_EXP 86
67194: PUSH
67195: LD_VAR 0 2
67199: ARRAY
67200: PUSH
67201: LD_INT 5
67203: LESS
67204: IFFALSE 67570
// begin if mc_ape [ i ] then
67206: LD_EXP 98
67210: PUSH
67211: LD_VAR 0 2
67215: ARRAY
67216: IFFALSE 67263
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
67218: LD_ADDR_VAR 0 5
67222: PUSH
67223: LD_EXP 98
67227: PUSH
67228: LD_VAR 0 2
67232: ARRAY
67233: PPUSH
67234: LD_INT 25
67236: PUSH
67237: LD_INT 16
67239: PUSH
67240: EMPTY
67241: LIST
67242: LIST
67243: PUSH
67244: LD_INT 24
67246: PUSH
67247: LD_INT 750
67249: PUSH
67250: EMPTY
67251: LIST
67252: LIST
67253: PUSH
67254: EMPTY
67255: LIST
67256: LIST
67257: PPUSH
67258: CALL_OW 72
67262: ST_TO_ADDR
// if not tmp then
67263: LD_VAR 0 5
67267: NOT
67268: IFFALSE 67315
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
67270: LD_ADDR_VAR 0 5
67274: PUSH
67275: LD_EXP 69
67279: PUSH
67280: LD_VAR 0 2
67284: ARRAY
67285: PPUSH
67286: LD_INT 25
67288: PUSH
67289: LD_INT 2
67291: PUSH
67292: EMPTY
67293: LIST
67294: LIST
67295: PUSH
67296: LD_INT 24
67298: PUSH
67299: LD_INT 750
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: PUSH
67306: EMPTY
67307: LIST
67308: LIST
67309: PPUSH
67310: CALL_OW 72
67314: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
67315: LD_EXP 98
67319: PUSH
67320: LD_VAR 0 2
67324: ARRAY
67325: PUSH
67326: LD_EXP 69
67330: PUSH
67331: LD_VAR 0 2
67335: ARRAY
67336: PPUSH
67337: LD_INT 25
67339: PUSH
67340: LD_INT 2
67342: PUSH
67343: EMPTY
67344: LIST
67345: LIST
67346: PUSH
67347: LD_INT 24
67349: PUSH
67350: LD_INT 750
67352: PUSH
67353: EMPTY
67354: LIST
67355: LIST
67356: PUSH
67357: EMPTY
67358: LIST
67359: LIST
67360: PPUSH
67361: CALL_OW 72
67365: AND
67366: PUSH
67367: LD_VAR 0 5
67371: PUSH
67372: LD_INT 5
67374: LESS
67375: AND
67376: IFFALSE 67458
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
67378: LD_ADDR_VAR 0 3
67382: PUSH
67383: LD_EXP 69
67387: PUSH
67388: LD_VAR 0 2
67392: ARRAY
67393: PPUSH
67394: LD_INT 25
67396: PUSH
67397: LD_INT 2
67399: PUSH
67400: EMPTY
67401: LIST
67402: LIST
67403: PUSH
67404: LD_INT 24
67406: PUSH
67407: LD_INT 750
67409: PUSH
67410: EMPTY
67411: LIST
67412: LIST
67413: PUSH
67414: EMPTY
67415: LIST
67416: LIST
67417: PPUSH
67418: CALL_OW 72
67422: PUSH
67423: FOR_IN
67424: IFFALSE 67456
// begin tmp := tmp union j ;
67426: LD_ADDR_VAR 0 5
67430: PUSH
67431: LD_VAR 0 5
67435: PUSH
67436: LD_VAR 0 3
67440: UNION
67441: ST_TO_ADDR
// if tmp >= 5 then
67442: LD_VAR 0 5
67446: PUSH
67447: LD_INT 5
67449: GREATEREQUAL
67450: IFFALSE 67454
// break ;
67452: GO 67456
// end ;
67454: GO 67423
67456: POP
67457: POP
// end ; if not tmp then
67458: LD_VAR 0 5
67462: NOT
67463: IFFALSE 67467
// continue ;
67465: GO 66620
// for j in tmp do
67467: LD_ADDR_VAR 0 3
67471: PUSH
67472: LD_VAR 0 5
67476: PUSH
67477: FOR_IN
67478: IFFALSE 67568
// if not GetTag ( j ) then
67480: LD_VAR 0 3
67484: PPUSH
67485: CALL_OW 110
67489: NOT
67490: IFFALSE 67566
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
67492: LD_ADDR_EXP 86
67496: PUSH
67497: LD_EXP 86
67501: PPUSH
67502: LD_VAR 0 2
67506: PUSH
67507: LD_EXP 86
67511: PUSH
67512: LD_VAR 0 2
67516: ARRAY
67517: PUSH
67518: LD_INT 1
67520: PLUS
67521: PUSH
67522: EMPTY
67523: LIST
67524: LIST
67525: PPUSH
67526: LD_VAR 0 3
67530: PPUSH
67531: CALL 18588 0 3
67535: ST_TO_ADDR
// SetTag ( j , 107 ) ;
67536: LD_VAR 0 3
67540: PPUSH
67541: LD_INT 107
67543: PPUSH
67544: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
67548: LD_EXP 86
67552: PUSH
67553: LD_VAR 0 2
67557: ARRAY
67558: PUSH
67559: LD_INT 5
67561: GREATEREQUAL
67562: IFFALSE 67566
// break ;
67564: GO 67568
// end ;
67566: GO 67477
67568: POP
67569: POP
// end ; if mc_crates_collector [ i ] and target then
67570: LD_EXP 86
67574: PUSH
67575: LD_VAR 0 2
67579: ARRAY
67580: PUSH
67581: LD_VAR 0 7
67585: AND
67586: IFFALSE 67892
// begin if mc_crates_collector [ i ] < target [ 1 ] then
67588: LD_EXP 86
67592: PUSH
67593: LD_VAR 0 2
67597: ARRAY
67598: PUSH
67599: LD_VAR 0 7
67603: PUSH
67604: LD_INT 1
67606: ARRAY
67607: LESS
67608: IFFALSE 67628
// tmp := mc_crates_collector [ i ] else
67610: LD_ADDR_VAR 0 5
67614: PUSH
67615: LD_EXP 86
67619: PUSH
67620: LD_VAR 0 2
67624: ARRAY
67625: ST_TO_ADDR
67626: GO 67642
// tmp := target [ 1 ] ;
67628: LD_ADDR_VAR 0 5
67632: PUSH
67633: LD_VAR 0 7
67637: PUSH
67638: LD_INT 1
67640: ARRAY
67641: ST_TO_ADDR
// k := 0 ;
67642: LD_ADDR_VAR 0 4
67646: PUSH
67647: LD_INT 0
67649: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
67650: LD_ADDR_VAR 0 3
67654: PUSH
67655: LD_EXP 86
67659: PUSH
67660: LD_VAR 0 2
67664: ARRAY
67665: PUSH
67666: FOR_IN
67667: IFFALSE 67890
// begin k := k + 1 ;
67669: LD_ADDR_VAR 0 4
67673: PUSH
67674: LD_VAR 0 4
67678: PUSH
67679: LD_INT 1
67681: PLUS
67682: ST_TO_ADDR
// if k > tmp then
67683: LD_VAR 0 4
67687: PUSH
67688: LD_VAR 0 5
67692: GREATER
67693: IFFALSE 67697
// break ;
67695: GO 67890
// if not GetClass ( j ) in [ 2 , 16 ] then
67697: LD_VAR 0 3
67701: PPUSH
67702: CALL_OW 257
67706: PUSH
67707: LD_INT 2
67709: PUSH
67710: LD_INT 16
67712: PUSH
67713: EMPTY
67714: LIST
67715: LIST
67716: IN
67717: NOT
67718: IFFALSE 67771
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
67720: LD_ADDR_EXP 86
67724: PUSH
67725: LD_EXP 86
67729: PPUSH
67730: LD_VAR 0 2
67734: PPUSH
67735: LD_EXP 86
67739: PUSH
67740: LD_VAR 0 2
67744: ARRAY
67745: PUSH
67746: LD_VAR 0 3
67750: DIFF
67751: PPUSH
67752: CALL_OW 1
67756: ST_TO_ADDR
// SetTag ( j , 0 ) ;
67757: LD_VAR 0 3
67761: PPUSH
67762: LD_INT 0
67764: PPUSH
67765: CALL_OW 109
// continue ;
67769: GO 67666
// end ; if IsInUnit ( j ) then
67771: LD_VAR 0 3
67775: PPUSH
67776: CALL_OW 310
67780: IFFALSE 67791
// ComExitBuilding ( j ) ;
67782: LD_VAR 0 3
67786: PPUSH
67787: CALL_OW 122
// wait ( 3 ) ;
67791: LD_INT 3
67793: PPUSH
67794: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
67798: LD_VAR 0 3
67802: PPUSH
67803: CALL_OW 314
67807: PUSH
67808: LD_VAR 0 6
67812: PPUSH
67813: LD_VAR 0 7
67817: PUSH
67818: LD_INT 2
67820: ARRAY
67821: PPUSH
67822: LD_VAR 0 7
67826: PUSH
67827: LD_INT 3
67829: ARRAY
67830: PPUSH
67831: LD_INT 30
67833: PPUSH
67834: CALL 19484 0 4
67838: PUSH
67839: LD_INT 4
67841: ARRAY
67842: AND
67843: IFFALSE 67861
// ComStandNearbyBuilding ( j , depot ) else
67845: LD_VAR 0 3
67849: PPUSH
67850: LD_VAR 0 9
67854: PPUSH
67855: CALL 15166 0 2
67859: GO 67888
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67861: LD_VAR 0 3
67865: PPUSH
67866: LD_VAR 0 7
67870: PUSH
67871: LD_INT 2
67873: ARRAY
67874: PPUSH
67875: LD_VAR 0 7
67879: PUSH
67880: LD_INT 3
67882: ARRAY
67883: PPUSH
67884: CALL_OW 117
// end ;
67888: GO 67666
67890: POP
67891: POP
// end ; end else
67892: GO 68424
// begin for j in cargo do
67894: LD_ADDR_VAR 0 3
67898: PUSH
67899: LD_VAR 0 8
67903: PUSH
67904: FOR_IN
67905: IFFALSE 68422
// begin if GetTag ( j ) <> 0 then
67907: LD_VAR 0 3
67911: PPUSH
67912: CALL_OW 110
67916: PUSH
67917: LD_INT 0
67919: NONEQUAL
67920: IFFALSE 67924
// continue ;
67922: GO 67904
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
67924: LD_VAR 0 3
67928: PPUSH
67929: CALL_OW 256
67933: PUSH
67934: LD_INT 1000
67936: LESS
67937: PUSH
67938: LD_VAR 0 3
67942: PPUSH
67943: LD_EXP 93
67947: PUSH
67948: LD_VAR 0 2
67952: ARRAY
67953: PPUSH
67954: CALL_OW 308
67958: NOT
67959: AND
67960: IFFALSE 67982
// ComMoveToArea ( j , mc_parking [ i ] ) ;
67962: LD_VAR 0 3
67966: PPUSH
67967: LD_EXP 93
67971: PUSH
67972: LD_VAR 0 2
67976: ARRAY
67977: PPUSH
67978: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
67982: LD_VAR 0 3
67986: PPUSH
67987: CALL_OW 256
67991: PUSH
67992: LD_INT 1000
67994: LESS
67995: PUSH
67996: LD_VAR 0 3
68000: PPUSH
68001: LD_EXP 93
68005: PUSH
68006: LD_VAR 0 2
68010: ARRAY
68011: PPUSH
68012: CALL_OW 308
68016: AND
68017: IFFALSE 68021
// continue ;
68019: GO 67904
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
68021: LD_VAR 0 3
68025: PPUSH
68026: CALL_OW 262
68030: PUSH
68031: LD_INT 2
68033: EQUAL
68034: PUSH
68035: LD_VAR 0 3
68039: PPUSH
68040: CALL_OW 261
68044: PUSH
68045: LD_INT 15
68047: LESS
68048: AND
68049: IFFALSE 68053
// continue ;
68051: GO 67904
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
68053: LD_VAR 0 3
68057: PPUSH
68058: CALL_OW 262
68062: PUSH
68063: LD_INT 1
68065: EQUAL
68066: PUSH
68067: LD_VAR 0 3
68071: PPUSH
68072: CALL_OW 261
68076: PUSH
68077: LD_INT 10
68079: LESS
68080: AND
68081: IFFALSE 68361
// begin if not depot then
68083: LD_VAR 0 9
68087: NOT
68088: IFFALSE 68092
// continue ;
68090: GO 67904
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
68092: LD_VAR 0 3
68096: PPUSH
68097: LD_VAR 0 9
68101: PPUSH
68102: LD_VAR 0 3
68106: PPUSH
68107: CALL_OW 74
68111: PPUSH
68112: CALL_OW 296
68116: PUSH
68117: LD_INT 6
68119: LESS
68120: IFFALSE 68136
// SetFuel ( j , 100 ) else
68122: LD_VAR 0 3
68126: PPUSH
68127: LD_INT 100
68129: PPUSH
68130: CALL_OW 240
68134: GO 68361
// if GetFuel ( j ) = 0 then
68136: LD_VAR 0 3
68140: PPUSH
68141: CALL_OW 261
68145: PUSH
68146: LD_INT 0
68148: EQUAL
68149: IFFALSE 68361
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
68151: LD_ADDR_EXP 88
68155: PUSH
68156: LD_EXP 88
68160: PPUSH
68161: LD_VAR 0 2
68165: PPUSH
68166: LD_EXP 88
68170: PUSH
68171: LD_VAR 0 2
68175: ARRAY
68176: PUSH
68177: LD_VAR 0 3
68181: DIFF
68182: PPUSH
68183: CALL_OW 1
68187: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
68188: LD_VAR 0 3
68192: PPUSH
68193: CALL_OW 263
68197: PUSH
68198: LD_INT 1
68200: EQUAL
68201: IFFALSE 68217
// ComExitVehicle ( IsInUnit ( j ) ) ;
68203: LD_VAR 0 3
68207: PPUSH
68208: CALL_OW 310
68212: PPUSH
68213: CALL_OW 121
// if GetControl ( j ) = control_remote then
68217: LD_VAR 0 3
68221: PPUSH
68222: CALL_OW 263
68226: PUSH
68227: LD_INT 2
68229: EQUAL
68230: IFFALSE 68241
// ComUnlink ( j ) ;
68232: LD_VAR 0 3
68236: PPUSH
68237: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
68241: LD_ADDR_VAR 0 10
68245: PUSH
68246: LD_VAR 0 2
68250: PPUSH
68251: LD_INT 3
68253: PPUSH
68254: CALL 78000 0 2
68258: ST_TO_ADDR
// if fac then
68259: LD_VAR 0 10
68263: IFFALSE 68359
// begin for k in fac do
68265: LD_ADDR_VAR 0 4
68269: PUSH
68270: LD_VAR 0 10
68274: PUSH
68275: FOR_IN
68276: IFFALSE 68357
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
68278: LD_ADDR_VAR 0 11
68282: PUSH
68283: LD_VAR 0 10
68287: PPUSH
68288: LD_VAR 0 3
68292: PPUSH
68293: CALL_OW 265
68297: PPUSH
68298: LD_VAR 0 3
68302: PPUSH
68303: CALL_OW 262
68307: PPUSH
68308: LD_VAR 0 3
68312: PPUSH
68313: CALL_OW 263
68317: PPUSH
68318: LD_VAR 0 3
68322: PPUSH
68323: CALL_OW 264
68327: PPUSH
68328: CALL 16084 0 5
68332: ST_TO_ADDR
// if components then
68333: LD_VAR 0 11
68337: IFFALSE 68355
// begin MC_InsertProduceList ( i , components ) ;
68339: LD_VAR 0 2
68343: PPUSH
68344: LD_VAR 0 11
68348: PPUSH
68349: CALL 77545 0 2
// break ;
68353: GO 68357
// end ; end ;
68355: GO 68275
68357: POP
68358: POP
// end ; continue ;
68359: GO 67904
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
68361: LD_VAR 0 3
68365: PPUSH
68366: LD_INT 1
68368: PPUSH
68369: CALL_OW 289
68373: PUSH
68374: LD_INT 100
68376: LESS
68377: PUSH
68378: LD_VAR 0 3
68382: PPUSH
68383: CALL_OW 314
68387: NOT
68388: AND
68389: IFFALSE 68418
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68391: LD_VAR 0 3
68395: PPUSH
68396: LD_VAR 0 7
68400: PUSH
68401: LD_INT 2
68403: ARRAY
68404: PPUSH
68405: LD_VAR 0 7
68409: PUSH
68410: LD_INT 3
68412: ARRAY
68413: PPUSH
68414: CALL_OW 117
// break ;
68418: GO 68422
// end ;
68420: GO 67904
68422: POP
68423: POP
// end ; end ;
68424: GO 66620
68426: POP
68427: POP
// end ;
68428: LD_VAR 0 1
68432: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
68433: LD_INT 0
68435: PPUSH
68436: PPUSH
68437: PPUSH
68438: PPUSH
// if not mc_bases then
68439: LD_EXP 69
68443: NOT
68444: IFFALSE 68448
// exit ;
68446: GO 68609
// for i = 1 to mc_bases do
68448: LD_ADDR_VAR 0 2
68452: PUSH
68453: DOUBLE
68454: LD_INT 1
68456: DEC
68457: ST_TO_ADDR
68458: LD_EXP 69
68462: PUSH
68463: FOR_TO
68464: IFFALSE 68607
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
68466: LD_ADDR_VAR 0 4
68470: PUSH
68471: LD_EXP 88
68475: PUSH
68476: LD_VAR 0 2
68480: ARRAY
68481: PUSH
68482: LD_EXP 91
68486: PUSH
68487: LD_VAR 0 2
68491: ARRAY
68492: UNION
68493: PPUSH
68494: LD_INT 33
68496: PUSH
68497: LD_INT 2
68499: PUSH
68500: EMPTY
68501: LIST
68502: LIST
68503: PPUSH
68504: CALL_OW 72
68508: ST_TO_ADDR
// if tmp then
68509: LD_VAR 0 4
68513: IFFALSE 68605
// for j in tmp do
68515: LD_ADDR_VAR 0 3
68519: PUSH
68520: LD_VAR 0 4
68524: PUSH
68525: FOR_IN
68526: IFFALSE 68603
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
68528: LD_VAR 0 3
68532: PPUSH
68533: CALL_OW 312
68537: NOT
68538: PUSH
68539: LD_VAR 0 3
68543: PPUSH
68544: CALL_OW 256
68548: PUSH
68549: LD_INT 250
68551: GREATEREQUAL
68552: AND
68553: IFFALSE 68566
// Connect ( j ) else
68555: LD_VAR 0 3
68559: PPUSH
68560: CALL 21559 0 1
68564: GO 68601
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
68566: LD_VAR 0 3
68570: PPUSH
68571: CALL_OW 256
68575: PUSH
68576: LD_INT 250
68578: LESS
68579: PUSH
68580: LD_VAR 0 3
68584: PPUSH
68585: CALL_OW 312
68589: AND
68590: IFFALSE 68601
// ComUnlink ( j ) ;
68592: LD_VAR 0 3
68596: PPUSH
68597: CALL_OW 136
68601: GO 68525
68603: POP
68604: POP
// end ;
68605: GO 68463
68607: POP
68608: POP
// end ;
68609: LD_VAR 0 1
68613: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
68614: LD_INT 0
68616: PPUSH
68617: PPUSH
68618: PPUSH
68619: PPUSH
68620: PPUSH
// if not mc_bases then
68621: LD_EXP 69
68625: NOT
68626: IFFALSE 68630
// exit ;
68628: GO 69075
// for i = 1 to mc_bases do
68630: LD_ADDR_VAR 0 2
68634: PUSH
68635: DOUBLE
68636: LD_INT 1
68638: DEC
68639: ST_TO_ADDR
68640: LD_EXP 69
68644: PUSH
68645: FOR_TO
68646: IFFALSE 69073
// begin if not mc_produce [ i ] then
68648: LD_EXP 90
68652: PUSH
68653: LD_VAR 0 2
68657: ARRAY
68658: NOT
68659: IFFALSE 68663
// continue ;
68661: GO 68645
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68663: LD_ADDR_VAR 0 5
68667: PUSH
68668: LD_EXP 69
68672: PUSH
68673: LD_VAR 0 2
68677: ARRAY
68678: PPUSH
68679: LD_INT 30
68681: PUSH
68682: LD_INT 3
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PPUSH
68689: CALL_OW 72
68693: ST_TO_ADDR
// if not fac then
68694: LD_VAR 0 5
68698: NOT
68699: IFFALSE 68703
// continue ;
68701: GO 68645
// for j in fac do
68703: LD_ADDR_VAR 0 3
68707: PUSH
68708: LD_VAR 0 5
68712: PUSH
68713: FOR_IN
68714: IFFALSE 69069
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
68716: LD_VAR 0 3
68720: PPUSH
68721: CALL_OW 461
68725: PUSH
68726: LD_INT 2
68728: NONEQUAL
68729: PUSH
68730: LD_VAR 0 3
68734: PPUSH
68735: LD_INT 15
68737: PPUSH
68738: CALL 21187 0 2
68742: PUSH
68743: LD_INT 4
68745: ARRAY
68746: OR
68747: IFFALSE 68751
// continue ;
68749: GO 68713
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
68751: LD_VAR 0 3
68755: PPUSH
68756: LD_EXP 90
68760: PUSH
68761: LD_VAR 0 2
68765: ARRAY
68766: PUSH
68767: LD_INT 1
68769: ARRAY
68770: PUSH
68771: LD_INT 1
68773: ARRAY
68774: PPUSH
68775: LD_EXP 90
68779: PUSH
68780: LD_VAR 0 2
68784: ARRAY
68785: PUSH
68786: LD_INT 1
68788: ARRAY
68789: PUSH
68790: LD_INT 2
68792: ARRAY
68793: PPUSH
68794: LD_EXP 90
68798: PUSH
68799: LD_VAR 0 2
68803: ARRAY
68804: PUSH
68805: LD_INT 1
68807: ARRAY
68808: PUSH
68809: LD_INT 3
68811: ARRAY
68812: PPUSH
68813: LD_EXP 90
68817: PUSH
68818: LD_VAR 0 2
68822: ARRAY
68823: PUSH
68824: LD_INT 1
68826: ARRAY
68827: PUSH
68828: LD_INT 4
68830: ARRAY
68831: PPUSH
68832: CALL_OW 448
68836: PUSH
68837: LD_VAR 0 3
68841: PPUSH
68842: LD_EXP 90
68846: PUSH
68847: LD_VAR 0 2
68851: ARRAY
68852: PUSH
68853: LD_INT 1
68855: ARRAY
68856: PUSH
68857: LD_INT 1
68859: ARRAY
68860: PUSH
68861: LD_EXP 90
68865: PUSH
68866: LD_VAR 0 2
68870: ARRAY
68871: PUSH
68872: LD_INT 1
68874: ARRAY
68875: PUSH
68876: LD_INT 2
68878: ARRAY
68879: PUSH
68880: LD_EXP 90
68884: PUSH
68885: LD_VAR 0 2
68889: ARRAY
68890: PUSH
68891: LD_INT 1
68893: ARRAY
68894: PUSH
68895: LD_INT 3
68897: ARRAY
68898: PUSH
68899: LD_EXP 90
68903: PUSH
68904: LD_VAR 0 2
68908: ARRAY
68909: PUSH
68910: LD_INT 1
68912: ARRAY
68913: PUSH
68914: LD_INT 4
68916: ARRAY
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: LIST
68922: LIST
68923: PPUSH
68924: CALL 24954 0 2
68928: AND
68929: IFFALSE 69067
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
68931: LD_VAR 0 3
68935: PPUSH
68936: LD_EXP 90
68940: PUSH
68941: LD_VAR 0 2
68945: ARRAY
68946: PUSH
68947: LD_INT 1
68949: ARRAY
68950: PUSH
68951: LD_INT 1
68953: ARRAY
68954: PPUSH
68955: LD_EXP 90
68959: PUSH
68960: LD_VAR 0 2
68964: ARRAY
68965: PUSH
68966: LD_INT 1
68968: ARRAY
68969: PUSH
68970: LD_INT 2
68972: ARRAY
68973: PPUSH
68974: LD_EXP 90
68978: PUSH
68979: LD_VAR 0 2
68983: ARRAY
68984: PUSH
68985: LD_INT 1
68987: ARRAY
68988: PUSH
68989: LD_INT 3
68991: ARRAY
68992: PPUSH
68993: LD_EXP 90
68997: PUSH
68998: LD_VAR 0 2
69002: ARRAY
69003: PUSH
69004: LD_INT 1
69006: ARRAY
69007: PUSH
69008: LD_INT 4
69010: ARRAY
69011: PPUSH
69012: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
69016: LD_ADDR_VAR 0 4
69020: PUSH
69021: LD_EXP 90
69025: PUSH
69026: LD_VAR 0 2
69030: ARRAY
69031: PPUSH
69032: LD_INT 1
69034: PPUSH
69035: CALL_OW 3
69039: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
69040: LD_ADDR_EXP 90
69044: PUSH
69045: LD_EXP 90
69049: PPUSH
69050: LD_VAR 0 2
69054: PPUSH
69055: LD_VAR 0 4
69059: PPUSH
69060: CALL_OW 1
69064: ST_TO_ADDR
// break ;
69065: GO 69069
// end ; end ;
69067: GO 68713
69069: POP
69070: POP
// end ;
69071: GO 68645
69073: POP
69074: POP
// end ;
69075: LD_VAR 0 1
69079: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
69080: LD_INT 0
69082: PPUSH
69083: PPUSH
69084: PPUSH
// if not mc_bases then
69085: LD_EXP 69
69089: NOT
69090: IFFALSE 69094
// exit ;
69092: GO 69183
// for i = 1 to mc_bases do
69094: LD_ADDR_VAR 0 2
69098: PUSH
69099: DOUBLE
69100: LD_INT 1
69102: DEC
69103: ST_TO_ADDR
69104: LD_EXP 69
69108: PUSH
69109: FOR_TO
69110: IFFALSE 69181
// begin if mc_attack [ i ] then
69112: LD_EXP 89
69116: PUSH
69117: LD_VAR 0 2
69121: ARRAY
69122: IFFALSE 69179
// begin tmp := mc_attack [ i ] [ 1 ] ;
69124: LD_ADDR_VAR 0 3
69128: PUSH
69129: LD_EXP 89
69133: PUSH
69134: LD_VAR 0 2
69138: ARRAY
69139: PUSH
69140: LD_INT 1
69142: ARRAY
69143: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
69144: LD_ADDR_EXP 89
69148: PUSH
69149: LD_EXP 89
69153: PPUSH
69154: LD_VAR 0 2
69158: PPUSH
69159: EMPTY
69160: PPUSH
69161: CALL_OW 1
69165: ST_TO_ADDR
// Attack ( tmp ) ;
69166: LD_VAR 0 3
69170: PPUSH
69171: CALL 101741 0 1
// exit ;
69175: POP
69176: POP
69177: GO 69183
// end ; end ;
69179: GO 69109
69181: POP
69182: POP
// end ;
69183: LD_VAR 0 1
69187: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
69188: LD_INT 0
69190: PPUSH
69191: PPUSH
69192: PPUSH
69193: PPUSH
69194: PPUSH
69195: PPUSH
69196: PPUSH
// if not mc_bases then
69197: LD_EXP 69
69201: NOT
69202: IFFALSE 69206
// exit ;
69204: GO 70063
// for i = 1 to mc_bases do
69206: LD_ADDR_VAR 0 2
69210: PUSH
69211: DOUBLE
69212: LD_INT 1
69214: DEC
69215: ST_TO_ADDR
69216: LD_EXP 69
69220: PUSH
69221: FOR_TO
69222: IFFALSE 70061
// begin if not mc_bases [ i ] then
69224: LD_EXP 69
69228: PUSH
69229: LD_VAR 0 2
69233: ARRAY
69234: NOT
69235: IFFALSE 69239
// continue ;
69237: GO 69221
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
69239: LD_ADDR_VAR 0 7
69243: PUSH
69244: LD_EXP 69
69248: PUSH
69249: LD_VAR 0 2
69253: ARRAY
69254: PUSH
69255: LD_INT 1
69257: ARRAY
69258: PPUSH
69259: CALL 15388 0 1
69263: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
69264: LD_ADDR_EXP 92
69268: PUSH
69269: LD_EXP 92
69273: PPUSH
69274: LD_VAR 0 2
69278: PPUSH
69279: LD_EXP 69
69283: PUSH
69284: LD_VAR 0 2
69288: ARRAY
69289: PUSH
69290: LD_INT 1
69292: ARRAY
69293: PPUSH
69294: CALL_OW 255
69298: PPUSH
69299: LD_EXP 94
69303: PUSH
69304: LD_VAR 0 2
69308: ARRAY
69309: PPUSH
69310: CALL 15353 0 2
69314: PPUSH
69315: CALL_OW 1
69319: ST_TO_ADDR
// if not mc_scan [ i ] then
69320: LD_EXP 92
69324: PUSH
69325: LD_VAR 0 2
69329: ARRAY
69330: NOT
69331: IFFALSE 69509
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
69333: LD_ADDR_EXP 112
69337: PUSH
69338: LD_EXP 112
69342: PPUSH
69343: LD_VAR 0 2
69347: PPUSH
69348: LD_INT 0
69350: PPUSH
69351: CALL_OW 1
69355: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69356: LD_ADDR_VAR 0 4
69360: PUSH
69361: LD_EXP 69
69365: PUSH
69366: LD_VAR 0 2
69370: ARRAY
69371: PPUSH
69372: LD_INT 2
69374: PUSH
69375: LD_INT 25
69377: PUSH
69378: LD_INT 5
69380: PUSH
69381: EMPTY
69382: LIST
69383: LIST
69384: PUSH
69385: LD_INT 25
69387: PUSH
69388: LD_INT 8
69390: PUSH
69391: EMPTY
69392: LIST
69393: LIST
69394: PUSH
69395: LD_INT 25
69397: PUSH
69398: LD_INT 9
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: PUSH
69405: EMPTY
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: PPUSH
69411: CALL_OW 72
69415: ST_TO_ADDR
// if not tmp then
69416: LD_VAR 0 4
69420: NOT
69421: IFFALSE 69425
// continue ;
69423: GO 69221
// for j in tmp do
69425: LD_ADDR_VAR 0 3
69429: PUSH
69430: LD_VAR 0 4
69434: PUSH
69435: FOR_IN
69436: IFFALSE 69507
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
69438: LD_VAR 0 3
69442: PPUSH
69443: CALL_OW 310
69447: PPUSH
69448: CALL_OW 266
69452: PUSH
69453: LD_INT 5
69455: EQUAL
69456: PUSH
69457: LD_VAR 0 3
69461: PPUSH
69462: CALL_OW 257
69466: PUSH
69467: LD_INT 1
69469: EQUAL
69470: AND
69471: PUSH
69472: LD_VAR 0 3
69476: PPUSH
69477: CALL_OW 459
69481: NOT
69482: AND
69483: PUSH
69484: LD_VAR 0 7
69488: AND
69489: IFFALSE 69505
// ComChangeProfession ( j , class ) ;
69491: LD_VAR 0 3
69495: PPUSH
69496: LD_VAR 0 7
69500: PPUSH
69501: CALL_OW 123
69505: GO 69435
69507: POP
69508: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
69509: LD_EXP 92
69513: PUSH
69514: LD_VAR 0 2
69518: ARRAY
69519: PUSH
69520: LD_EXP 112
69524: PUSH
69525: LD_VAR 0 2
69529: ARRAY
69530: NOT
69531: AND
69532: PUSH
69533: LD_EXP 91
69537: PUSH
69538: LD_VAR 0 2
69542: ARRAY
69543: NOT
69544: AND
69545: PUSH
69546: LD_EXP 69
69550: PUSH
69551: LD_VAR 0 2
69555: ARRAY
69556: PPUSH
69557: LD_INT 50
69559: PUSH
69560: EMPTY
69561: LIST
69562: PUSH
69563: LD_INT 2
69565: PUSH
69566: LD_INT 30
69568: PUSH
69569: LD_INT 32
69571: PUSH
69572: EMPTY
69573: LIST
69574: LIST
69575: PUSH
69576: LD_INT 30
69578: PUSH
69579: LD_INT 33
69581: PUSH
69582: EMPTY
69583: LIST
69584: LIST
69585: PUSH
69586: LD_INT 30
69588: PUSH
69589: LD_INT 4
69591: PUSH
69592: EMPTY
69593: LIST
69594: LIST
69595: PUSH
69596: LD_INT 30
69598: PUSH
69599: LD_INT 5
69601: PUSH
69602: EMPTY
69603: LIST
69604: LIST
69605: PUSH
69606: EMPTY
69607: LIST
69608: LIST
69609: LIST
69610: LIST
69611: LIST
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: PPUSH
69617: CALL_OW 72
69621: PUSH
69622: LD_INT 4
69624: LESS
69625: PUSH
69626: LD_EXP 69
69630: PUSH
69631: LD_VAR 0 2
69635: ARRAY
69636: PPUSH
69637: LD_INT 3
69639: PUSH
69640: LD_INT 24
69642: PUSH
69643: LD_INT 1000
69645: PUSH
69646: EMPTY
69647: LIST
69648: LIST
69649: PUSH
69650: EMPTY
69651: LIST
69652: LIST
69653: PUSH
69654: LD_INT 2
69656: PUSH
69657: LD_INT 30
69659: PUSH
69660: LD_INT 0
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: LD_INT 30
69669: PUSH
69670: LD_INT 1
69672: PUSH
69673: EMPTY
69674: LIST
69675: LIST
69676: PUSH
69677: EMPTY
69678: LIST
69679: LIST
69680: LIST
69681: PUSH
69682: EMPTY
69683: LIST
69684: LIST
69685: PPUSH
69686: CALL_OW 72
69690: OR
69691: AND
69692: IFFALSE 69943
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
69694: LD_ADDR_EXP 112
69698: PUSH
69699: LD_EXP 112
69703: PPUSH
69704: LD_VAR 0 2
69708: PPUSH
69709: LD_INT 1
69711: PPUSH
69712: CALL_OW 1
69716: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69717: LD_ADDR_VAR 0 4
69721: PUSH
69722: LD_EXP 69
69726: PUSH
69727: LD_VAR 0 2
69731: ARRAY
69732: PPUSH
69733: LD_INT 2
69735: PUSH
69736: LD_INT 25
69738: PUSH
69739: LD_INT 1
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: PUSH
69746: LD_INT 25
69748: PUSH
69749: LD_INT 5
69751: PUSH
69752: EMPTY
69753: LIST
69754: LIST
69755: PUSH
69756: LD_INT 25
69758: PUSH
69759: LD_INT 8
69761: PUSH
69762: EMPTY
69763: LIST
69764: LIST
69765: PUSH
69766: LD_INT 25
69768: PUSH
69769: LD_INT 9
69771: PUSH
69772: EMPTY
69773: LIST
69774: LIST
69775: PUSH
69776: EMPTY
69777: LIST
69778: LIST
69779: LIST
69780: LIST
69781: LIST
69782: PPUSH
69783: CALL_OW 72
69787: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
69788: LD_ADDR_VAR 0 4
69792: PUSH
69793: LD_VAR 0 4
69797: PUSH
69798: LD_VAR 0 4
69802: PPUSH
69803: LD_INT 18
69805: PPUSH
69806: CALL 47857 0 2
69810: DIFF
69811: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
69812: LD_VAR 0 4
69816: NOT
69817: PUSH
69818: LD_EXP 69
69822: PUSH
69823: LD_VAR 0 2
69827: ARRAY
69828: PPUSH
69829: LD_INT 2
69831: PUSH
69832: LD_INT 30
69834: PUSH
69835: LD_INT 4
69837: PUSH
69838: EMPTY
69839: LIST
69840: LIST
69841: PUSH
69842: LD_INT 30
69844: PUSH
69845: LD_INT 5
69847: PUSH
69848: EMPTY
69849: LIST
69850: LIST
69851: PUSH
69852: EMPTY
69853: LIST
69854: LIST
69855: LIST
69856: PPUSH
69857: CALL_OW 72
69861: NOT
69862: AND
69863: IFFALSE 69925
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
69865: LD_ADDR_VAR 0 4
69869: PUSH
69870: LD_EXP 69
69874: PUSH
69875: LD_VAR 0 2
69879: ARRAY
69880: PPUSH
69881: LD_INT 2
69883: PUSH
69884: LD_INT 25
69886: PUSH
69887: LD_INT 2
69889: PUSH
69890: EMPTY
69891: LIST
69892: LIST
69893: PUSH
69894: LD_INT 25
69896: PUSH
69897: LD_INT 3
69899: PUSH
69900: EMPTY
69901: LIST
69902: LIST
69903: PUSH
69904: LD_INT 25
69906: PUSH
69907: LD_INT 4
69909: PUSH
69910: EMPTY
69911: LIST
69912: LIST
69913: PUSH
69914: EMPTY
69915: LIST
69916: LIST
69917: LIST
69918: LIST
69919: PPUSH
69920: CALL_OW 72
69924: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
69925: LD_VAR 0 2
69929: PPUSH
69930: LD_VAR 0 4
69934: PPUSH
69935: CALL 106450 0 2
// exit ;
69939: POP
69940: POP
69941: GO 70063
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
69943: LD_EXP 92
69947: PUSH
69948: LD_VAR 0 2
69952: ARRAY
69953: PUSH
69954: LD_EXP 112
69958: PUSH
69959: LD_VAR 0 2
69963: ARRAY
69964: NOT
69965: AND
69966: PUSH
69967: LD_EXP 91
69971: PUSH
69972: LD_VAR 0 2
69976: ARRAY
69977: AND
69978: IFFALSE 70059
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
69980: LD_ADDR_EXP 112
69984: PUSH
69985: LD_EXP 112
69989: PPUSH
69990: LD_VAR 0 2
69994: PPUSH
69995: LD_INT 1
69997: PPUSH
69998: CALL_OW 1
70002: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
70003: LD_ADDR_VAR 0 4
70007: PUSH
70008: LD_EXP 91
70012: PUSH
70013: LD_VAR 0 2
70017: ARRAY
70018: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
70019: LD_ADDR_EXP 91
70023: PUSH
70024: LD_EXP 91
70028: PPUSH
70029: LD_VAR 0 2
70033: PPUSH
70034: EMPTY
70035: PPUSH
70036: CALL_OW 1
70040: ST_TO_ADDR
// Defend ( i , tmp ) ;
70041: LD_VAR 0 2
70045: PPUSH
70046: LD_VAR 0 4
70050: PPUSH
70051: CALL 107046 0 2
// exit ;
70055: POP
70056: POP
70057: GO 70063
// end ; end ;
70059: GO 69221
70061: POP
70062: POP
// end ;
70063: LD_VAR 0 1
70067: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
70068: LD_INT 0
70070: PPUSH
70071: PPUSH
70072: PPUSH
70073: PPUSH
70074: PPUSH
70075: PPUSH
70076: PPUSH
70077: PPUSH
70078: PPUSH
70079: PPUSH
70080: PPUSH
// if not mc_bases then
70081: LD_EXP 69
70085: NOT
70086: IFFALSE 70090
// exit ;
70088: GO 71177
// for i = 1 to mc_bases do
70090: LD_ADDR_VAR 0 2
70094: PUSH
70095: DOUBLE
70096: LD_INT 1
70098: DEC
70099: ST_TO_ADDR
70100: LD_EXP 69
70104: PUSH
70105: FOR_TO
70106: IFFALSE 71175
// begin tmp := mc_lab [ i ] ;
70108: LD_ADDR_VAR 0 6
70112: PUSH
70113: LD_EXP 102
70117: PUSH
70118: LD_VAR 0 2
70122: ARRAY
70123: ST_TO_ADDR
// if not tmp then
70124: LD_VAR 0 6
70128: NOT
70129: IFFALSE 70133
// continue ;
70131: GO 70105
// idle_lab := 0 ;
70133: LD_ADDR_VAR 0 11
70137: PUSH
70138: LD_INT 0
70140: ST_TO_ADDR
// for j in tmp do
70141: LD_ADDR_VAR 0 3
70145: PUSH
70146: LD_VAR 0 6
70150: PUSH
70151: FOR_IN
70152: IFFALSE 71171
// begin researching := false ;
70154: LD_ADDR_VAR 0 10
70158: PUSH
70159: LD_INT 0
70161: ST_TO_ADDR
// side := GetSide ( j ) ;
70162: LD_ADDR_VAR 0 4
70166: PUSH
70167: LD_VAR 0 3
70171: PPUSH
70172: CALL_OW 255
70176: ST_TO_ADDR
// if not mc_tech [ side ] then
70177: LD_EXP 96
70181: PUSH
70182: LD_VAR 0 4
70186: ARRAY
70187: NOT
70188: IFFALSE 70192
// continue ;
70190: GO 70151
// if BuildingStatus ( j ) = bs_idle then
70192: LD_VAR 0 3
70196: PPUSH
70197: CALL_OW 461
70201: PUSH
70202: LD_INT 2
70204: EQUAL
70205: IFFALSE 70393
// begin if idle_lab and UnitsInside ( j ) < 6 then
70207: LD_VAR 0 11
70211: PUSH
70212: LD_VAR 0 3
70216: PPUSH
70217: CALL_OW 313
70221: PUSH
70222: LD_INT 6
70224: LESS
70225: AND
70226: IFFALSE 70297
// begin tmp2 := UnitsInside ( idle_lab ) ;
70228: LD_ADDR_VAR 0 9
70232: PUSH
70233: LD_VAR 0 11
70237: PPUSH
70238: CALL_OW 313
70242: ST_TO_ADDR
// if tmp2 then
70243: LD_VAR 0 9
70247: IFFALSE 70289
// for x in tmp2 do
70249: LD_ADDR_VAR 0 7
70253: PUSH
70254: LD_VAR 0 9
70258: PUSH
70259: FOR_IN
70260: IFFALSE 70287
// begin ComExitBuilding ( x ) ;
70262: LD_VAR 0 7
70266: PPUSH
70267: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70271: LD_VAR 0 7
70275: PPUSH
70276: LD_VAR 0 3
70280: PPUSH
70281: CALL_OW 180
// end ;
70285: GO 70259
70287: POP
70288: POP
// idle_lab := 0 ;
70289: LD_ADDR_VAR 0 11
70293: PUSH
70294: LD_INT 0
70296: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
70297: LD_ADDR_VAR 0 5
70301: PUSH
70302: LD_EXP 96
70306: PUSH
70307: LD_VAR 0 4
70311: ARRAY
70312: PUSH
70313: FOR_IN
70314: IFFALSE 70374
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
70316: LD_VAR 0 3
70320: PPUSH
70321: LD_VAR 0 5
70325: PPUSH
70326: CALL_OW 430
70330: PUSH
70331: LD_VAR 0 4
70335: PPUSH
70336: LD_VAR 0 5
70340: PPUSH
70341: CALL 14458 0 2
70345: AND
70346: IFFALSE 70372
// begin researching := true ;
70348: LD_ADDR_VAR 0 10
70352: PUSH
70353: LD_INT 1
70355: ST_TO_ADDR
// ComResearch ( j , t ) ;
70356: LD_VAR 0 3
70360: PPUSH
70361: LD_VAR 0 5
70365: PPUSH
70366: CALL_OW 124
// break ;
70370: GO 70374
// end ;
70372: GO 70313
70374: POP
70375: POP
// if not researching then
70376: LD_VAR 0 10
70380: NOT
70381: IFFALSE 70393
// idle_lab := j ;
70383: LD_ADDR_VAR 0 11
70387: PUSH
70388: LD_VAR 0 3
70392: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
70393: LD_VAR 0 3
70397: PPUSH
70398: CALL_OW 461
70402: PUSH
70403: LD_INT 10
70405: EQUAL
70406: IFFALSE 70994
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
70408: LD_EXP 98
70412: PUSH
70413: LD_VAR 0 2
70417: ARRAY
70418: NOT
70419: PUSH
70420: LD_EXP 99
70424: PUSH
70425: LD_VAR 0 2
70429: ARRAY
70430: NOT
70431: AND
70432: PUSH
70433: LD_EXP 96
70437: PUSH
70438: LD_VAR 0 4
70442: ARRAY
70443: PUSH
70444: LD_INT 1
70446: GREATER
70447: AND
70448: IFFALSE 70579
// begin ComCancel ( j ) ;
70450: LD_VAR 0 3
70454: PPUSH
70455: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
70459: LD_ADDR_EXP 96
70463: PUSH
70464: LD_EXP 96
70468: PPUSH
70469: LD_VAR 0 4
70473: PPUSH
70474: LD_EXP 96
70478: PUSH
70479: LD_VAR 0 4
70483: ARRAY
70484: PPUSH
70485: LD_EXP 96
70489: PUSH
70490: LD_VAR 0 4
70494: ARRAY
70495: PUSH
70496: LD_INT 1
70498: MINUS
70499: PPUSH
70500: LD_EXP 96
70504: PUSH
70505: LD_VAR 0 4
70509: ARRAY
70510: PPUSH
70511: LD_INT 0
70513: PPUSH
70514: CALL 18006 0 4
70518: PPUSH
70519: CALL_OW 1
70523: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
70524: LD_ADDR_EXP 96
70528: PUSH
70529: LD_EXP 96
70533: PPUSH
70534: LD_VAR 0 4
70538: PPUSH
70539: LD_EXP 96
70543: PUSH
70544: LD_VAR 0 4
70548: ARRAY
70549: PPUSH
70550: LD_EXP 96
70554: PUSH
70555: LD_VAR 0 4
70559: ARRAY
70560: PPUSH
70561: LD_INT 1
70563: PPUSH
70564: LD_INT 0
70566: PPUSH
70567: CALL 18006 0 4
70571: PPUSH
70572: CALL_OW 1
70576: ST_TO_ADDR
// continue ;
70577: GO 70151
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
70579: LD_EXP 98
70583: PUSH
70584: LD_VAR 0 2
70588: ARRAY
70589: PUSH
70590: LD_EXP 99
70594: PUSH
70595: LD_VAR 0 2
70599: ARRAY
70600: NOT
70601: AND
70602: IFFALSE 70729
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
70604: LD_ADDR_EXP 99
70608: PUSH
70609: LD_EXP 99
70613: PPUSH
70614: LD_VAR 0 2
70618: PUSH
70619: LD_EXP 99
70623: PUSH
70624: LD_VAR 0 2
70628: ARRAY
70629: PUSH
70630: LD_INT 1
70632: PLUS
70633: PUSH
70634: EMPTY
70635: LIST
70636: LIST
70637: PPUSH
70638: LD_EXP 98
70642: PUSH
70643: LD_VAR 0 2
70647: ARRAY
70648: PUSH
70649: LD_INT 1
70651: ARRAY
70652: PPUSH
70653: CALL 18588 0 3
70657: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
70658: LD_EXP 98
70662: PUSH
70663: LD_VAR 0 2
70667: ARRAY
70668: PUSH
70669: LD_INT 1
70671: ARRAY
70672: PPUSH
70673: LD_INT 112
70675: PPUSH
70676: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
70680: LD_ADDR_VAR 0 9
70684: PUSH
70685: LD_EXP 98
70689: PUSH
70690: LD_VAR 0 2
70694: ARRAY
70695: PPUSH
70696: LD_INT 1
70698: PPUSH
70699: CALL_OW 3
70703: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
70704: LD_ADDR_EXP 98
70708: PUSH
70709: LD_EXP 98
70713: PPUSH
70714: LD_VAR 0 2
70718: PPUSH
70719: LD_VAR 0 9
70723: PPUSH
70724: CALL_OW 1
70728: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
70729: LD_EXP 98
70733: PUSH
70734: LD_VAR 0 2
70738: ARRAY
70739: PUSH
70740: LD_EXP 99
70744: PUSH
70745: LD_VAR 0 2
70749: ARRAY
70750: AND
70751: PUSH
70752: LD_EXP 99
70756: PUSH
70757: LD_VAR 0 2
70761: ARRAY
70762: PUSH
70763: LD_INT 1
70765: ARRAY
70766: PPUSH
70767: CALL_OW 310
70771: NOT
70772: AND
70773: PUSH
70774: LD_VAR 0 3
70778: PPUSH
70779: CALL_OW 313
70783: PUSH
70784: LD_INT 6
70786: EQUAL
70787: AND
70788: IFFALSE 70844
// begin tmp2 := UnitsInside ( j ) ;
70790: LD_ADDR_VAR 0 9
70794: PUSH
70795: LD_VAR 0 3
70799: PPUSH
70800: CALL_OW 313
70804: ST_TO_ADDR
// if tmp2 = 6 then
70805: LD_VAR 0 9
70809: PUSH
70810: LD_INT 6
70812: EQUAL
70813: IFFALSE 70844
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
70815: LD_VAR 0 9
70819: PUSH
70820: LD_INT 1
70822: ARRAY
70823: PPUSH
70824: LD_INT 112
70826: PPUSH
70827: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
70831: LD_VAR 0 9
70835: PUSH
70836: LD_INT 1
70838: ARRAY
70839: PPUSH
70840: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
70844: LD_EXP 99
70848: PUSH
70849: LD_VAR 0 2
70853: ARRAY
70854: PUSH
70855: LD_EXP 99
70859: PUSH
70860: LD_VAR 0 2
70864: ARRAY
70865: PUSH
70866: LD_INT 1
70868: ARRAY
70869: PPUSH
70870: CALL_OW 314
70874: NOT
70875: AND
70876: PUSH
70877: LD_EXP 99
70881: PUSH
70882: LD_VAR 0 2
70886: ARRAY
70887: PUSH
70888: LD_INT 1
70890: ARRAY
70891: PPUSH
70892: CALL_OW 310
70896: NOT
70897: AND
70898: IFFALSE 70924
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
70900: LD_EXP 99
70904: PUSH
70905: LD_VAR 0 2
70909: ARRAY
70910: PUSH
70911: LD_INT 1
70913: ARRAY
70914: PPUSH
70915: LD_VAR 0 3
70919: PPUSH
70920: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
70924: LD_EXP 99
70928: PUSH
70929: LD_VAR 0 2
70933: ARRAY
70934: PUSH
70935: LD_INT 1
70937: ARRAY
70938: PPUSH
70939: CALL_OW 310
70943: PUSH
70944: LD_EXP 99
70948: PUSH
70949: LD_VAR 0 2
70953: ARRAY
70954: PUSH
70955: LD_INT 1
70957: ARRAY
70958: PPUSH
70959: CALL_OW 310
70963: PPUSH
70964: CALL_OW 461
70968: PUSH
70969: LD_INT 3
70971: NONEQUAL
70972: AND
70973: IFFALSE 70994
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
70975: LD_EXP 99
70979: PUSH
70980: LD_VAR 0 2
70984: ARRAY
70985: PUSH
70986: LD_INT 1
70988: ARRAY
70989: PPUSH
70990: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
70994: LD_VAR 0 3
70998: PPUSH
70999: CALL_OW 461
71003: PUSH
71004: LD_INT 6
71006: EQUAL
71007: PUSH
71008: LD_VAR 0 6
71012: PUSH
71013: LD_INT 1
71015: GREATER
71016: AND
71017: IFFALSE 71169
// begin sci := [ ] ;
71019: LD_ADDR_VAR 0 8
71023: PUSH
71024: EMPTY
71025: ST_TO_ADDR
// for x in ( tmp diff j ) do
71026: LD_ADDR_VAR 0 7
71030: PUSH
71031: LD_VAR 0 6
71035: PUSH
71036: LD_VAR 0 3
71040: DIFF
71041: PUSH
71042: FOR_IN
71043: IFFALSE 71095
// begin if sci = 6 then
71045: LD_VAR 0 8
71049: PUSH
71050: LD_INT 6
71052: EQUAL
71053: IFFALSE 71057
// break ;
71055: GO 71095
// if BuildingStatus ( x ) = bs_idle then
71057: LD_VAR 0 7
71061: PPUSH
71062: CALL_OW 461
71066: PUSH
71067: LD_INT 2
71069: EQUAL
71070: IFFALSE 71093
// sci := sci ^ UnitsInside ( x ) ;
71072: LD_ADDR_VAR 0 8
71076: PUSH
71077: LD_VAR 0 8
71081: PUSH
71082: LD_VAR 0 7
71086: PPUSH
71087: CALL_OW 313
71091: ADD
71092: ST_TO_ADDR
// end ;
71093: GO 71042
71095: POP
71096: POP
// if not sci then
71097: LD_VAR 0 8
71101: NOT
71102: IFFALSE 71106
// continue ;
71104: GO 70151
// for x in sci do
71106: LD_ADDR_VAR 0 7
71110: PUSH
71111: LD_VAR 0 8
71115: PUSH
71116: FOR_IN
71117: IFFALSE 71167
// if IsInUnit ( x ) and not HasTask ( x ) then
71119: LD_VAR 0 7
71123: PPUSH
71124: CALL_OW 310
71128: PUSH
71129: LD_VAR 0 7
71133: PPUSH
71134: CALL_OW 314
71138: NOT
71139: AND
71140: IFFALSE 71165
// begin ComExitBuilding ( x ) ;
71142: LD_VAR 0 7
71146: PPUSH
71147: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71151: LD_VAR 0 7
71155: PPUSH
71156: LD_VAR 0 3
71160: PPUSH
71161: CALL_OW 180
// end ;
71165: GO 71116
71167: POP
71168: POP
// end ; end ;
71169: GO 70151
71171: POP
71172: POP
// end ;
71173: GO 70105
71175: POP
71176: POP
// end ;
71177: LD_VAR 0 1
71181: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
71182: LD_INT 0
71184: PPUSH
71185: PPUSH
// if not mc_bases then
71186: LD_EXP 69
71190: NOT
71191: IFFALSE 71195
// exit ;
71193: GO 71276
// for i = 1 to mc_bases do
71195: LD_ADDR_VAR 0 2
71199: PUSH
71200: DOUBLE
71201: LD_INT 1
71203: DEC
71204: ST_TO_ADDR
71205: LD_EXP 69
71209: PUSH
71210: FOR_TO
71211: IFFALSE 71274
// if mc_mines [ i ] and mc_miners [ i ] then
71213: LD_EXP 82
71217: PUSH
71218: LD_VAR 0 2
71222: ARRAY
71223: PUSH
71224: LD_EXP 83
71228: PUSH
71229: LD_VAR 0 2
71233: ARRAY
71234: AND
71235: IFFALSE 71272
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
71237: LD_EXP 83
71241: PUSH
71242: LD_VAR 0 2
71246: ARRAY
71247: PUSH
71248: LD_INT 1
71250: ARRAY
71251: PPUSH
71252: CALL_OW 255
71256: PPUSH
71257: LD_EXP 82
71261: PUSH
71262: LD_VAR 0 2
71266: ARRAY
71267: PPUSH
71268: CALL 15541 0 2
71272: GO 71210
71274: POP
71275: POP
// end ;
71276: LD_VAR 0 1
71280: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
71281: LD_INT 0
71283: PPUSH
71284: PPUSH
71285: PPUSH
71286: PPUSH
71287: PPUSH
71288: PPUSH
71289: PPUSH
71290: PPUSH
// if not mc_bases or not mc_parking then
71291: LD_EXP 69
71295: NOT
71296: PUSH
71297: LD_EXP 93
71301: NOT
71302: OR
71303: IFFALSE 71307
// exit ;
71305: GO 72017
// for i = 1 to mc_bases do
71307: LD_ADDR_VAR 0 2
71311: PUSH
71312: DOUBLE
71313: LD_INT 1
71315: DEC
71316: ST_TO_ADDR
71317: LD_EXP 69
71321: PUSH
71322: FOR_TO
71323: IFFALSE 72015
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
71325: LD_EXP 69
71329: PUSH
71330: LD_VAR 0 2
71334: ARRAY
71335: NOT
71336: PUSH
71337: LD_EXP 93
71341: PUSH
71342: LD_VAR 0 2
71346: ARRAY
71347: NOT
71348: OR
71349: IFFALSE 71353
// continue ;
71351: GO 71322
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
71353: LD_ADDR_VAR 0 5
71357: PUSH
71358: LD_EXP 69
71362: PUSH
71363: LD_VAR 0 2
71367: ARRAY
71368: PUSH
71369: LD_INT 1
71371: ARRAY
71372: PPUSH
71373: CALL_OW 255
71377: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71378: LD_ADDR_VAR 0 6
71382: PUSH
71383: LD_EXP 69
71387: PUSH
71388: LD_VAR 0 2
71392: ARRAY
71393: PPUSH
71394: LD_INT 30
71396: PUSH
71397: LD_INT 3
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: PPUSH
71404: CALL_OW 72
71408: ST_TO_ADDR
// if not fac then
71409: LD_VAR 0 6
71413: NOT
71414: IFFALSE 71465
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71416: LD_ADDR_VAR 0 6
71420: PUSH
71421: LD_EXP 69
71425: PUSH
71426: LD_VAR 0 2
71430: ARRAY
71431: PPUSH
71432: LD_INT 2
71434: PUSH
71435: LD_INT 30
71437: PUSH
71438: LD_INT 0
71440: PUSH
71441: EMPTY
71442: LIST
71443: LIST
71444: PUSH
71445: LD_INT 30
71447: PUSH
71448: LD_INT 1
71450: PUSH
71451: EMPTY
71452: LIST
71453: LIST
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: LIST
71459: PPUSH
71460: CALL_OW 72
71464: ST_TO_ADDR
// if not fac then
71465: LD_VAR 0 6
71469: NOT
71470: IFFALSE 71474
// continue ;
71472: GO 71322
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71474: LD_ADDR_VAR 0 7
71478: PUSH
71479: LD_EXP 93
71483: PUSH
71484: LD_VAR 0 2
71488: ARRAY
71489: PPUSH
71490: LD_INT 22
71492: PUSH
71493: LD_VAR 0 5
71497: PUSH
71498: EMPTY
71499: LIST
71500: LIST
71501: PUSH
71502: LD_INT 21
71504: PUSH
71505: LD_INT 2
71507: PUSH
71508: EMPTY
71509: LIST
71510: LIST
71511: PUSH
71512: LD_INT 3
71514: PUSH
71515: LD_INT 24
71517: PUSH
71518: LD_INT 1000
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: PUSH
71529: EMPTY
71530: LIST
71531: LIST
71532: LIST
71533: PPUSH
71534: CALL_OW 70
71538: ST_TO_ADDR
// for j in fac do
71539: LD_ADDR_VAR 0 3
71543: PUSH
71544: LD_VAR 0 6
71548: PUSH
71549: FOR_IN
71550: IFFALSE 71631
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71552: LD_ADDR_VAR 0 7
71556: PUSH
71557: LD_VAR 0 7
71561: PUSH
71562: LD_INT 22
71564: PUSH
71565: LD_VAR 0 5
71569: PUSH
71570: EMPTY
71571: LIST
71572: LIST
71573: PUSH
71574: LD_INT 91
71576: PUSH
71577: LD_VAR 0 3
71581: PUSH
71582: LD_INT 15
71584: PUSH
71585: EMPTY
71586: LIST
71587: LIST
71588: LIST
71589: PUSH
71590: LD_INT 21
71592: PUSH
71593: LD_INT 2
71595: PUSH
71596: EMPTY
71597: LIST
71598: LIST
71599: PUSH
71600: LD_INT 3
71602: PUSH
71603: LD_INT 24
71605: PUSH
71606: LD_INT 1000
71608: PUSH
71609: EMPTY
71610: LIST
71611: LIST
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: PUSH
71617: EMPTY
71618: LIST
71619: LIST
71620: LIST
71621: LIST
71622: PPUSH
71623: CALL_OW 69
71627: UNION
71628: ST_TO_ADDR
71629: GO 71549
71631: POP
71632: POP
// if not vehs then
71633: LD_VAR 0 7
71637: NOT
71638: IFFALSE 71664
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
71640: LD_ADDR_EXP 81
71644: PUSH
71645: LD_EXP 81
71649: PPUSH
71650: LD_VAR 0 2
71654: PPUSH
71655: EMPTY
71656: PPUSH
71657: CALL_OW 1
71661: ST_TO_ADDR
// continue ;
71662: GO 71322
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71664: LD_ADDR_VAR 0 8
71668: PUSH
71669: LD_EXP 69
71673: PUSH
71674: LD_VAR 0 2
71678: ARRAY
71679: PPUSH
71680: LD_INT 30
71682: PUSH
71683: LD_INT 3
71685: PUSH
71686: EMPTY
71687: LIST
71688: LIST
71689: PPUSH
71690: CALL_OW 72
71694: ST_TO_ADDR
// if tmp then
71695: LD_VAR 0 8
71699: IFFALSE 71802
// begin for j in tmp do
71701: LD_ADDR_VAR 0 3
71705: PUSH
71706: LD_VAR 0 8
71710: PUSH
71711: FOR_IN
71712: IFFALSE 71800
// for k in UnitsInside ( j ) do
71714: LD_ADDR_VAR 0 4
71718: PUSH
71719: LD_VAR 0 3
71723: PPUSH
71724: CALL_OW 313
71728: PUSH
71729: FOR_IN
71730: IFFALSE 71796
// if k then
71732: LD_VAR 0 4
71736: IFFALSE 71794
// if not k in mc_repair_vehicle [ i ] then
71738: LD_VAR 0 4
71742: PUSH
71743: LD_EXP 81
71747: PUSH
71748: LD_VAR 0 2
71752: ARRAY
71753: IN
71754: NOT
71755: IFFALSE 71794
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
71757: LD_ADDR_EXP 81
71761: PUSH
71762: LD_EXP 81
71766: PPUSH
71767: LD_VAR 0 2
71771: PPUSH
71772: LD_EXP 81
71776: PUSH
71777: LD_VAR 0 2
71781: ARRAY
71782: PUSH
71783: LD_VAR 0 4
71787: UNION
71788: PPUSH
71789: CALL_OW 1
71793: ST_TO_ADDR
71794: GO 71729
71796: POP
71797: POP
71798: GO 71711
71800: POP
71801: POP
// end ; if not mc_repair_vehicle [ i ] then
71802: LD_EXP 81
71806: PUSH
71807: LD_VAR 0 2
71811: ARRAY
71812: NOT
71813: IFFALSE 71817
// continue ;
71815: GO 71322
// for j in mc_repair_vehicle [ i ] do
71817: LD_ADDR_VAR 0 3
71821: PUSH
71822: LD_EXP 81
71826: PUSH
71827: LD_VAR 0 2
71831: ARRAY
71832: PUSH
71833: FOR_IN
71834: IFFALSE 72011
// begin if GetClass ( j ) <> 3 then
71836: LD_VAR 0 3
71840: PPUSH
71841: CALL_OW 257
71845: PUSH
71846: LD_INT 3
71848: NONEQUAL
71849: IFFALSE 71890
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
71851: LD_ADDR_EXP 81
71855: PUSH
71856: LD_EXP 81
71860: PPUSH
71861: LD_VAR 0 2
71865: PPUSH
71866: LD_EXP 81
71870: PUSH
71871: LD_VAR 0 2
71875: ARRAY
71876: PUSH
71877: LD_VAR 0 3
71881: DIFF
71882: PPUSH
71883: CALL_OW 1
71887: ST_TO_ADDR
// continue ;
71888: GO 71833
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71890: LD_VAR 0 3
71894: PPUSH
71895: CALL_OW 311
71899: NOT
71900: PUSH
71901: LD_VAR 0 3
71905: PUSH
71906: LD_EXP 72
71910: PUSH
71911: LD_VAR 0 2
71915: ARRAY
71916: PUSH
71917: LD_INT 1
71919: ARRAY
71920: IN
71921: NOT
71922: AND
71923: PUSH
71924: LD_VAR 0 3
71928: PUSH
71929: LD_EXP 72
71933: PUSH
71934: LD_VAR 0 2
71938: ARRAY
71939: PUSH
71940: LD_INT 2
71942: ARRAY
71943: IN
71944: NOT
71945: AND
71946: IFFALSE 72009
// begin if IsInUnit ( j ) then
71948: LD_VAR 0 3
71952: PPUSH
71953: CALL_OW 310
71957: IFFALSE 71970
// ComExitBuilding ( j ) else
71959: LD_VAR 0 3
71963: PPUSH
71964: CALL_OW 122
71968: GO 72009
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
71970: LD_VAR 0 3
71974: PPUSH
71975: LD_VAR 0 7
71979: PUSH
71980: LD_INT 1
71982: ARRAY
71983: PPUSH
71984: CALL 52195 0 2
71988: NOT
71989: IFFALSE 72009
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
71991: LD_VAR 0 3
71995: PPUSH
71996: LD_VAR 0 7
72000: PUSH
72001: LD_INT 1
72003: ARRAY
72004: PPUSH
72005: CALL_OW 129
// end ; end ;
72009: GO 71833
72011: POP
72012: POP
// end ;
72013: GO 71322
72015: POP
72016: POP
// end ;
72017: LD_VAR 0 1
72021: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
72022: LD_INT 0
72024: PPUSH
72025: PPUSH
72026: PPUSH
72027: PPUSH
72028: PPUSH
72029: PPUSH
72030: PPUSH
72031: PPUSH
72032: PPUSH
72033: PPUSH
72034: PPUSH
// if not mc_bases then
72035: LD_EXP 69
72039: NOT
72040: IFFALSE 72044
// exit ;
72042: GO 72846
// for i = 1 to mc_bases do
72044: LD_ADDR_VAR 0 2
72048: PUSH
72049: DOUBLE
72050: LD_INT 1
72052: DEC
72053: ST_TO_ADDR
72054: LD_EXP 69
72058: PUSH
72059: FOR_TO
72060: IFFALSE 72844
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
72062: LD_EXP 97
72066: PUSH
72067: LD_VAR 0 2
72071: ARRAY
72072: NOT
72073: PUSH
72074: LD_EXP 72
72078: PUSH
72079: LD_VAR 0 2
72083: ARRAY
72084: PUSH
72085: LD_INT 1
72087: ARRAY
72088: OR
72089: PUSH
72090: LD_EXP 72
72094: PUSH
72095: LD_VAR 0 2
72099: ARRAY
72100: PUSH
72101: LD_INT 2
72103: ARRAY
72104: OR
72105: PUSH
72106: LD_EXP 95
72110: PUSH
72111: LD_VAR 0 2
72115: ARRAY
72116: PPUSH
72117: LD_INT 1
72119: PPUSH
72120: CALL_OW 325
72124: NOT
72125: OR
72126: PUSH
72127: LD_EXP 92
72131: PUSH
72132: LD_VAR 0 2
72136: ARRAY
72137: OR
72138: IFFALSE 72142
// continue ;
72140: GO 72059
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
72142: LD_ADDR_VAR 0 8
72146: PUSH
72147: LD_EXP 69
72151: PUSH
72152: LD_VAR 0 2
72156: ARRAY
72157: PPUSH
72158: LD_INT 25
72160: PUSH
72161: LD_INT 4
72163: PUSH
72164: EMPTY
72165: LIST
72166: LIST
72167: PUSH
72168: LD_INT 50
72170: PUSH
72171: EMPTY
72172: LIST
72173: PUSH
72174: LD_INT 3
72176: PUSH
72177: LD_INT 60
72179: PUSH
72180: EMPTY
72181: LIST
72182: PUSH
72183: EMPTY
72184: LIST
72185: LIST
72186: PUSH
72187: EMPTY
72188: LIST
72189: LIST
72190: LIST
72191: PPUSH
72192: CALL_OW 72
72196: PUSH
72197: LD_EXP 73
72201: PUSH
72202: LD_VAR 0 2
72206: ARRAY
72207: DIFF
72208: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72209: LD_ADDR_VAR 0 9
72213: PUSH
72214: LD_EXP 69
72218: PUSH
72219: LD_VAR 0 2
72223: ARRAY
72224: PPUSH
72225: LD_INT 2
72227: PUSH
72228: LD_INT 30
72230: PUSH
72231: LD_INT 0
72233: PUSH
72234: EMPTY
72235: LIST
72236: LIST
72237: PUSH
72238: LD_INT 30
72240: PUSH
72241: LD_INT 1
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: PUSH
72248: EMPTY
72249: LIST
72250: LIST
72251: LIST
72252: PPUSH
72253: CALL_OW 72
72257: ST_TO_ADDR
// if not tmp or not dep then
72258: LD_VAR 0 8
72262: NOT
72263: PUSH
72264: LD_VAR 0 9
72268: NOT
72269: OR
72270: IFFALSE 72274
// continue ;
72272: GO 72059
// side := GetSide ( tmp [ 1 ] ) ;
72274: LD_ADDR_VAR 0 11
72278: PUSH
72279: LD_VAR 0 8
72283: PUSH
72284: LD_INT 1
72286: ARRAY
72287: PPUSH
72288: CALL_OW 255
72292: ST_TO_ADDR
// dep := dep [ 1 ] ;
72293: LD_ADDR_VAR 0 9
72297: PUSH
72298: LD_VAR 0 9
72302: PUSH
72303: LD_INT 1
72305: ARRAY
72306: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
72307: LD_ADDR_VAR 0 7
72311: PUSH
72312: LD_EXP 97
72316: PUSH
72317: LD_VAR 0 2
72321: ARRAY
72322: PPUSH
72323: LD_INT 22
72325: PUSH
72326: LD_INT 0
72328: PUSH
72329: EMPTY
72330: LIST
72331: LIST
72332: PUSH
72333: LD_INT 25
72335: PUSH
72336: LD_INT 12
72338: PUSH
72339: EMPTY
72340: LIST
72341: LIST
72342: PUSH
72343: EMPTY
72344: LIST
72345: LIST
72346: PPUSH
72347: CALL_OW 70
72351: PUSH
72352: LD_INT 22
72354: PUSH
72355: LD_INT 0
72357: PUSH
72358: EMPTY
72359: LIST
72360: LIST
72361: PUSH
72362: LD_INT 25
72364: PUSH
72365: LD_INT 12
72367: PUSH
72368: EMPTY
72369: LIST
72370: LIST
72371: PUSH
72372: LD_INT 91
72374: PUSH
72375: LD_VAR 0 9
72379: PUSH
72380: LD_INT 20
72382: PUSH
72383: EMPTY
72384: LIST
72385: LIST
72386: LIST
72387: PUSH
72388: EMPTY
72389: LIST
72390: LIST
72391: LIST
72392: PPUSH
72393: CALL_OW 69
72397: UNION
72398: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
72399: LD_ADDR_VAR 0 10
72403: PUSH
72404: LD_EXP 97
72408: PUSH
72409: LD_VAR 0 2
72413: ARRAY
72414: PPUSH
72415: LD_INT 81
72417: PUSH
72418: LD_VAR 0 11
72422: PUSH
72423: EMPTY
72424: LIST
72425: LIST
72426: PPUSH
72427: CALL_OW 70
72431: ST_TO_ADDR
// if not apes or danger_at_area then
72432: LD_VAR 0 7
72436: NOT
72437: PUSH
72438: LD_VAR 0 10
72442: OR
72443: IFFALSE 72493
// begin if mc_taming [ i ] then
72445: LD_EXP 100
72449: PUSH
72450: LD_VAR 0 2
72454: ARRAY
72455: IFFALSE 72491
// begin MC_Reset ( i , 121 ) ;
72457: LD_VAR 0 2
72461: PPUSH
72462: LD_INT 121
72464: PPUSH
72465: CALL 57479 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
72469: LD_ADDR_EXP 100
72473: PUSH
72474: LD_EXP 100
72478: PPUSH
72479: LD_VAR 0 2
72483: PPUSH
72484: EMPTY
72485: PPUSH
72486: CALL_OW 1
72490: ST_TO_ADDR
// end ; continue ;
72491: GO 72059
// end ; for j in tmp do
72493: LD_ADDR_VAR 0 3
72497: PUSH
72498: LD_VAR 0 8
72502: PUSH
72503: FOR_IN
72504: IFFALSE 72840
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
72506: LD_VAR 0 3
72510: PUSH
72511: LD_EXP 100
72515: PUSH
72516: LD_VAR 0 2
72520: ARRAY
72521: IN
72522: NOT
72523: PUSH
72524: LD_EXP 100
72528: PUSH
72529: LD_VAR 0 2
72533: ARRAY
72534: PUSH
72535: LD_INT 3
72537: LESS
72538: AND
72539: IFFALSE 72597
// begin SetTag ( j , 121 ) ;
72541: LD_VAR 0 3
72545: PPUSH
72546: LD_INT 121
72548: PPUSH
72549: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
72553: LD_ADDR_EXP 100
72557: PUSH
72558: LD_EXP 100
72562: PPUSH
72563: LD_VAR 0 2
72567: PUSH
72568: LD_EXP 100
72572: PUSH
72573: LD_VAR 0 2
72577: ARRAY
72578: PUSH
72579: LD_INT 1
72581: PLUS
72582: PUSH
72583: EMPTY
72584: LIST
72585: LIST
72586: PPUSH
72587: LD_VAR 0 3
72591: PPUSH
72592: CALL 18588 0 3
72596: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
72597: LD_VAR 0 3
72601: PUSH
72602: LD_EXP 100
72606: PUSH
72607: LD_VAR 0 2
72611: ARRAY
72612: IN
72613: IFFALSE 72838
// begin if GetClass ( j ) <> 4 then
72615: LD_VAR 0 3
72619: PPUSH
72620: CALL_OW 257
72624: PUSH
72625: LD_INT 4
72627: NONEQUAL
72628: IFFALSE 72681
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
72630: LD_ADDR_EXP 100
72634: PUSH
72635: LD_EXP 100
72639: PPUSH
72640: LD_VAR 0 2
72644: PPUSH
72645: LD_EXP 100
72649: PUSH
72650: LD_VAR 0 2
72654: ARRAY
72655: PUSH
72656: LD_VAR 0 3
72660: DIFF
72661: PPUSH
72662: CALL_OW 1
72666: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72667: LD_VAR 0 3
72671: PPUSH
72672: LD_INT 0
72674: PPUSH
72675: CALL_OW 109
// continue ;
72679: GO 72503
// end ; if IsInUnit ( j ) then
72681: LD_VAR 0 3
72685: PPUSH
72686: CALL_OW 310
72690: IFFALSE 72701
// ComExitBuilding ( j ) ;
72692: LD_VAR 0 3
72696: PPUSH
72697: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
72701: LD_ADDR_VAR 0 6
72705: PUSH
72706: LD_VAR 0 7
72710: PPUSH
72711: LD_VAR 0 3
72715: PPUSH
72716: CALL_OW 74
72720: ST_TO_ADDR
// if not ape then
72721: LD_VAR 0 6
72725: NOT
72726: IFFALSE 72730
// break ;
72728: GO 72840
// x := GetX ( ape ) ;
72730: LD_ADDR_VAR 0 4
72734: PUSH
72735: LD_VAR 0 6
72739: PPUSH
72740: CALL_OW 250
72744: ST_TO_ADDR
// y := GetY ( ape ) ;
72745: LD_ADDR_VAR 0 5
72749: PUSH
72750: LD_VAR 0 6
72754: PPUSH
72755: CALL_OW 251
72759: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
72760: LD_VAR 0 4
72764: PPUSH
72765: LD_VAR 0 5
72769: PPUSH
72770: CALL_OW 488
72774: NOT
72775: PUSH
72776: LD_VAR 0 11
72780: PPUSH
72781: LD_VAR 0 4
72785: PPUSH
72786: LD_VAR 0 5
72790: PPUSH
72791: LD_INT 20
72793: PPUSH
72794: CALL 19484 0 4
72798: PUSH
72799: LD_INT 4
72801: ARRAY
72802: OR
72803: IFFALSE 72807
// break ;
72805: GO 72840
// if not HasTask ( j ) then
72807: LD_VAR 0 3
72811: PPUSH
72812: CALL_OW 314
72816: NOT
72817: IFFALSE 72838
// ComTameXY ( j , x , y ) ;
72819: LD_VAR 0 3
72823: PPUSH
72824: LD_VAR 0 4
72828: PPUSH
72829: LD_VAR 0 5
72833: PPUSH
72834: CALL_OW 131
// end ; end ;
72838: GO 72503
72840: POP
72841: POP
// end ;
72842: GO 72059
72844: POP
72845: POP
// end ;
72846: LD_VAR 0 1
72850: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
72851: LD_INT 0
72853: PPUSH
72854: PPUSH
72855: PPUSH
72856: PPUSH
72857: PPUSH
72858: PPUSH
72859: PPUSH
72860: PPUSH
// if not mc_bases then
72861: LD_EXP 69
72865: NOT
72866: IFFALSE 72870
// exit ;
72868: GO 73496
// for i = 1 to mc_bases do
72870: LD_ADDR_VAR 0 2
72874: PUSH
72875: DOUBLE
72876: LD_INT 1
72878: DEC
72879: ST_TO_ADDR
72880: LD_EXP 69
72884: PUSH
72885: FOR_TO
72886: IFFALSE 73494
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
72888: LD_EXP 98
72892: PUSH
72893: LD_VAR 0 2
72897: ARRAY
72898: NOT
72899: PUSH
72900: LD_EXP 98
72904: PUSH
72905: LD_VAR 0 2
72909: ARRAY
72910: PPUSH
72911: LD_INT 25
72913: PUSH
72914: LD_INT 12
72916: PUSH
72917: EMPTY
72918: LIST
72919: LIST
72920: PPUSH
72921: CALL_OW 72
72925: NOT
72926: OR
72927: IFFALSE 72931
// continue ;
72929: GO 72885
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
72931: LD_ADDR_VAR 0 5
72935: PUSH
72936: LD_EXP 98
72940: PUSH
72941: LD_VAR 0 2
72945: ARRAY
72946: PUSH
72947: LD_INT 1
72949: ARRAY
72950: PPUSH
72951: CALL_OW 255
72955: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
72956: LD_VAR 0 5
72960: PPUSH
72961: LD_INT 2
72963: PPUSH
72964: CALL_OW 325
72968: IFFALSE 73221
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72970: LD_ADDR_VAR 0 4
72974: PUSH
72975: LD_EXP 98
72979: PUSH
72980: LD_VAR 0 2
72984: ARRAY
72985: PPUSH
72986: LD_INT 25
72988: PUSH
72989: LD_INT 16
72991: PUSH
72992: EMPTY
72993: LIST
72994: LIST
72995: PPUSH
72996: CALL_OW 72
73000: ST_TO_ADDR
// if tmp < 6 then
73001: LD_VAR 0 4
73005: PUSH
73006: LD_INT 6
73008: LESS
73009: IFFALSE 73221
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73011: LD_ADDR_VAR 0 6
73015: PUSH
73016: LD_EXP 69
73020: PUSH
73021: LD_VAR 0 2
73025: ARRAY
73026: PPUSH
73027: LD_INT 2
73029: PUSH
73030: LD_INT 30
73032: PUSH
73033: LD_INT 0
73035: PUSH
73036: EMPTY
73037: LIST
73038: LIST
73039: PUSH
73040: LD_INT 30
73042: PUSH
73043: LD_INT 1
73045: PUSH
73046: EMPTY
73047: LIST
73048: LIST
73049: PUSH
73050: EMPTY
73051: LIST
73052: LIST
73053: LIST
73054: PPUSH
73055: CALL_OW 72
73059: ST_TO_ADDR
// if depot then
73060: LD_VAR 0 6
73064: IFFALSE 73221
// begin selected := 0 ;
73066: LD_ADDR_VAR 0 7
73070: PUSH
73071: LD_INT 0
73073: ST_TO_ADDR
// for j in depot do
73074: LD_ADDR_VAR 0 3
73078: PUSH
73079: LD_VAR 0 6
73083: PUSH
73084: FOR_IN
73085: IFFALSE 73116
// begin if UnitsInside ( j ) < 6 then
73087: LD_VAR 0 3
73091: PPUSH
73092: CALL_OW 313
73096: PUSH
73097: LD_INT 6
73099: LESS
73100: IFFALSE 73114
// begin selected := j ;
73102: LD_ADDR_VAR 0 7
73106: PUSH
73107: LD_VAR 0 3
73111: ST_TO_ADDR
// break ;
73112: GO 73116
// end ; end ;
73114: GO 73084
73116: POP
73117: POP
// if selected then
73118: LD_VAR 0 7
73122: IFFALSE 73221
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73124: LD_ADDR_VAR 0 3
73128: PUSH
73129: LD_EXP 98
73133: PUSH
73134: LD_VAR 0 2
73138: ARRAY
73139: PPUSH
73140: LD_INT 25
73142: PUSH
73143: LD_INT 12
73145: PUSH
73146: EMPTY
73147: LIST
73148: LIST
73149: PPUSH
73150: CALL_OW 72
73154: PUSH
73155: FOR_IN
73156: IFFALSE 73219
// if not HasTask ( j ) then
73158: LD_VAR 0 3
73162: PPUSH
73163: CALL_OW 314
73167: NOT
73168: IFFALSE 73217
// begin if not IsInUnit ( j ) then
73170: LD_VAR 0 3
73174: PPUSH
73175: CALL_OW 310
73179: NOT
73180: IFFALSE 73196
// ComEnterUnit ( j , selected ) ;
73182: LD_VAR 0 3
73186: PPUSH
73187: LD_VAR 0 7
73191: PPUSH
73192: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
73196: LD_VAR 0 3
73200: PPUSH
73201: LD_INT 16
73203: PPUSH
73204: CALL_OW 183
// AddComExitBuilding ( j ) ;
73208: LD_VAR 0 3
73212: PPUSH
73213: CALL_OW 182
// end ;
73217: GO 73155
73219: POP
73220: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
73221: LD_VAR 0 5
73225: PPUSH
73226: LD_INT 11
73228: PPUSH
73229: CALL_OW 325
73233: IFFALSE 73492
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73235: LD_ADDR_VAR 0 4
73239: PUSH
73240: LD_EXP 98
73244: PUSH
73245: LD_VAR 0 2
73249: ARRAY
73250: PPUSH
73251: LD_INT 25
73253: PUSH
73254: LD_INT 16
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: PPUSH
73261: CALL_OW 72
73265: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
73266: LD_VAR 0 4
73270: PUSH
73271: LD_INT 6
73273: GREATEREQUAL
73274: PUSH
73275: LD_VAR 0 5
73279: PPUSH
73280: LD_INT 2
73282: PPUSH
73283: CALL_OW 325
73287: NOT
73288: OR
73289: IFFALSE 73492
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
73291: LD_ADDR_VAR 0 8
73295: PUSH
73296: LD_EXP 69
73300: PUSH
73301: LD_VAR 0 2
73305: ARRAY
73306: PPUSH
73307: LD_INT 2
73309: PUSH
73310: LD_INT 30
73312: PUSH
73313: LD_INT 4
73315: PUSH
73316: EMPTY
73317: LIST
73318: LIST
73319: PUSH
73320: LD_INT 30
73322: PUSH
73323: LD_INT 5
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: LIST
73334: PPUSH
73335: CALL_OW 72
73339: ST_TO_ADDR
// if barracks then
73340: LD_VAR 0 8
73344: IFFALSE 73492
// begin selected := 0 ;
73346: LD_ADDR_VAR 0 7
73350: PUSH
73351: LD_INT 0
73353: ST_TO_ADDR
// for j in barracks do
73354: LD_ADDR_VAR 0 3
73358: PUSH
73359: LD_VAR 0 8
73363: PUSH
73364: FOR_IN
73365: IFFALSE 73396
// begin if UnitsInside ( j ) < 6 then
73367: LD_VAR 0 3
73371: PPUSH
73372: CALL_OW 313
73376: PUSH
73377: LD_INT 6
73379: LESS
73380: IFFALSE 73394
// begin selected := j ;
73382: LD_ADDR_VAR 0 7
73386: PUSH
73387: LD_VAR 0 3
73391: ST_TO_ADDR
// break ;
73392: GO 73396
// end ; end ;
73394: GO 73364
73396: POP
73397: POP
// if selected then
73398: LD_VAR 0 7
73402: IFFALSE 73492
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73404: LD_ADDR_VAR 0 3
73408: PUSH
73409: LD_EXP 98
73413: PUSH
73414: LD_VAR 0 2
73418: ARRAY
73419: PPUSH
73420: LD_INT 25
73422: PUSH
73423: LD_INT 12
73425: PUSH
73426: EMPTY
73427: LIST
73428: LIST
73429: PPUSH
73430: CALL_OW 72
73434: PUSH
73435: FOR_IN
73436: IFFALSE 73490
// if not IsInUnit ( j ) and not HasTask ( j ) then
73438: LD_VAR 0 3
73442: PPUSH
73443: CALL_OW 310
73447: NOT
73448: PUSH
73449: LD_VAR 0 3
73453: PPUSH
73454: CALL_OW 314
73458: NOT
73459: AND
73460: IFFALSE 73488
// begin ComEnterUnit ( j , selected ) ;
73462: LD_VAR 0 3
73466: PPUSH
73467: LD_VAR 0 7
73471: PPUSH
73472: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
73476: LD_VAR 0 3
73480: PPUSH
73481: LD_INT 15
73483: PPUSH
73484: CALL_OW 183
// end ;
73488: GO 73435
73490: POP
73491: POP
// end ; end ; end ; end ; end ;
73492: GO 72885
73494: POP
73495: POP
// end ;
73496: LD_VAR 0 1
73500: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
73501: LD_INT 0
73503: PPUSH
73504: PPUSH
73505: PPUSH
73506: PPUSH
// if not mc_bases then
73507: LD_EXP 69
73511: NOT
73512: IFFALSE 73516
// exit ;
73514: GO 73694
// for i = 1 to mc_bases do
73516: LD_ADDR_VAR 0 2
73520: PUSH
73521: DOUBLE
73522: LD_INT 1
73524: DEC
73525: ST_TO_ADDR
73526: LD_EXP 69
73530: PUSH
73531: FOR_TO
73532: IFFALSE 73692
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
73534: LD_ADDR_VAR 0 4
73538: PUSH
73539: LD_EXP 69
73543: PUSH
73544: LD_VAR 0 2
73548: ARRAY
73549: PPUSH
73550: LD_INT 25
73552: PUSH
73553: LD_INT 9
73555: PUSH
73556: EMPTY
73557: LIST
73558: LIST
73559: PPUSH
73560: CALL_OW 72
73564: ST_TO_ADDR
// if not tmp then
73565: LD_VAR 0 4
73569: NOT
73570: IFFALSE 73574
// continue ;
73572: GO 73531
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
73574: LD_EXP 95
73578: PUSH
73579: LD_VAR 0 2
73583: ARRAY
73584: PPUSH
73585: LD_INT 29
73587: PPUSH
73588: CALL_OW 325
73592: NOT
73593: PUSH
73594: LD_EXP 95
73598: PUSH
73599: LD_VAR 0 2
73603: ARRAY
73604: PPUSH
73605: LD_INT 28
73607: PPUSH
73608: CALL_OW 325
73612: NOT
73613: AND
73614: IFFALSE 73618
// continue ;
73616: GO 73531
// for j in tmp do
73618: LD_ADDR_VAR 0 3
73622: PUSH
73623: LD_VAR 0 4
73627: PUSH
73628: FOR_IN
73629: IFFALSE 73688
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73631: LD_VAR 0 3
73635: PUSH
73636: LD_EXP 72
73640: PUSH
73641: LD_VAR 0 2
73645: ARRAY
73646: PUSH
73647: LD_INT 1
73649: ARRAY
73650: IN
73651: NOT
73652: PUSH
73653: LD_VAR 0 3
73657: PUSH
73658: LD_EXP 72
73662: PUSH
73663: LD_VAR 0 2
73667: ARRAY
73668: PUSH
73669: LD_INT 2
73671: ARRAY
73672: IN
73673: NOT
73674: AND
73675: IFFALSE 73686
// ComSpaceTimeShoot ( j ) ;
73677: LD_VAR 0 3
73681: PPUSH
73682: CALL 14549 0 1
73686: GO 73628
73688: POP
73689: POP
// end ;
73690: GO 73531
73692: POP
73693: POP
// end ;
73694: LD_VAR 0 1
73698: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
73699: LD_INT 0
73701: PPUSH
73702: PPUSH
73703: PPUSH
73704: PPUSH
73705: PPUSH
73706: PPUSH
73707: PPUSH
73708: PPUSH
73709: PPUSH
// if not mc_bases then
73710: LD_EXP 69
73714: NOT
73715: IFFALSE 73719
// exit ;
73717: GO 74341
// for i = 1 to mc_bases do
73719: LD_ADDR_VAR 0 2
73723: PUSH
73724: DOUBLE
73725: LD_INT 1
73727: DEC
73728: ST_TO_ADDR
73729: LD_EXP 69
73733: PUSH
73734: FOR_TO
73735: IFFALSE 74339
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
73737: LD_EXP 104
73741: PUSH
73742: LD_VAR 0 2
73746: ARRAY
73747: NOT
73748: PUSH
73749: LD_INT 38
73751: PPUSH
73752: LD_EXP 95
73756: PUSH
73757: LD_VAR 0 2
73761: ARRAY
73762: PPUSH
73763: CALL_OW 321
73767: PUSH
73768: LD_INT 2
73770: NONEQUAL
73771: OR
73772: IFFALSE 73776
// continue ;
73774: GO 73734
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
73776: LD_ADDR_VAR 0 8
73780: PUSH
73781: LD_EXP 69
73785: PUSH
73786: LD_VAR 0 2
73790: ARRAY
73791: PPUSH
73792: LD_INT 30
73794: PUSH
73795: LD_INT 34
73797: PUSH
73798: EMPTY
73799: LIST
73800: LIST
73801: PPUSH
73802: CALL_OW 72
73806: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
73807: LD_ADDR_VAR 0 9
73811: PUSH
73812: LD_EXP 69
73816: PUSH
73817: LD_VAR 0 2
73821: ARRAY
73822: PPUSH
73823: LD_INT 25
73825: PUSH
73826: LD_INT 4
73828: PUSH
73829: EMPTY
73830: LIST
73831: LIST
73832: PPUSH
73833: CALL_OW 72
73837: PPUSH
73838: LD_INT 0
73840: PPUSH
73841: CALL 47857 0 2
73845: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
73846: LD_VAR 0 9
73850: NOT
73851: PUSH
73852: LD_VAR 0 8
73856: NOT
73857: OR
73858: PUSH
73859: LD_EXP 69
73863: PUSH
73864: LD_VAR 0 2
73868: ARRAY
73869: PPUSH
73870: LD_INT 124
73872: PPUSH
73873: CALL 47857 0 2
73877: OR
73878: IFFALSE 73882
// continue ;
73880: GO 73734
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
73882: LD_EXP 105
73886: PUSH
73887: LD_VAR 0 2
73891: ARRAY
73892: PUSH
73893: LD_EXP 104
73897: PUSH
73898: LD_VAR 0 2
73902: ARRAY
73903: LESS
73904: PUSH
73905: LD_EXP 105
73909: PUSH
73910: LD_VAR 0 2
73914: ARRAY
73915: PUSH
73916: LD_VAR 0 8
73920: LESS
73921: AND
73922: IFFALSE 74337
// begin tmp := sci [ 1 ] ;
73924: LD_ADDR_VAR 0 7
73928: PUSH
73929: LD_VAR 0 9
73933: PUSH
73934: LD_INT 1
73936: ARRAY
73937: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
73938: LD_VAR 0 7
73942: PPUSH
73943: LD_INT 124
73945: PPUSH
73946: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
73950: LD_ADDR_VAR 0 3
73954: PUSH
73955: DOUBLE
73956: LD_EXP 104
73960: PUSH
73961: LD_VAR 0 2
73965: ARRAY
73966: INC
73967: ST_TO_ADDR
73968: LD_EXP 104
73972: PUSH
73973: LD_VAR 0 2
73977: ARRAY
73978: PUSH
73979: FOR_DOWNTO
73980: IFFALSE 74323
// begin if IsInUnit ( tmp ) then
73982: LD_VAR 0 7
73986: PPUSH
73987: CALL_OW 310
73991: IFFALSE 74002
// ComExitBuilding ( tmp ) ;
73993: LD_VAR 0 7
73997: PPUSH
73998: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
74002: LD_INT 35
74004: PPUSH
74005: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
74009: LD_VAR 0 7
74013: PPUSH
74014: CALL_OW 310
74018: NOT
74019: PUSH
74020: LD_VAR 0 7
74024: PPUSH
74025: CALL_OW 314
74029: NOT
74030: AND
74031: IFFALSE 74002
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
74033: LD_ADDR_VAR 0 6
74037: PUSH
74038: LD_VAR 0 7
74042: PPUSH
74043: CALL_OW 250
74047: PUSH
74048: LD_VAR 0 7
74052: PPUSH
74053: CALL_OW 251
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74062: LD_INT 35
74064: PPUSH
74065: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
74069: LD_ADDR_VAR 0 4
74073: PUSH
74074: LD_EXP 104
74078: PUSH
74079: LD_VAR 0 2
74083: ARRAY
74084: PUSH
74085: LD_VAR 0 3
74089: ARRAY
74090: PUSH
74091: LD_INT 1
74093: ARRAY
74094: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
74095: LD_ADDR_VAR 0 5
74099: PUSH
74100: LD_EXP 104
74104: PUSH
74105: LD_VAR 0 2
74109: ARRAY
74110: PUSH
74111: LD_VAR 0 3
74115: ARRAY
74116: PUSH
74117: LD_INT 2
74119: ARRAY
74120: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
74121: LD_VAR 0 7
74125: PPUSH
74126: LD_INT 10
74128: PPUSH
74129: CALL 21187 0 2
74133: PUSH
74134: LD_INT 4
74136: ARRAY
74137: IFFALSE 74175
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
74139: LD_VAR 0 7
74143: PPUSH
74144: LD_VAR 0 6
74148: PUSH
74149: LD_INT 1
74151: ARRAY
74152: PPUSH
74153: LD_VAR 0 6
74157: PUSH
74158: LD_INT 2
74160: ARRAY
74161: PPUSH
74162: CALL_OW 111
// wait ( 0 0$10 ) ;
74166: LD_INT 350
74168: PPUSH
74169: CALL_OW 67
// end else
74173: GO 74201
// begin ComMoveXY ( tmp , x , y ) ;
74175: LD_VAR 0 7
74179: PPUSH
74180: LD_VAR 0 4
74184: PPUSH
74185: LD_VAR 0 5
74189: PPUSH
74190: CALL_OW 111
// wait ( 0 0$3 ) ;
74194: LD_INT 105
74196: PPUSH
74197: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
74201: LD_VAR 0 7
74205: PPUSH
74206: LD_VAR 0 4
74210: PPUSH
74211: LD_VAR 0 5
74215: PPUSH
74216: CALL_OW 307
74220: IFFALSE 74062
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
74222: LD_VAR 0 7
74226: PPUSH
74227: LD_VAR 0 4
74231: PPUSH
74232: LD_VAR 0 5
74236: PPUSH
74237: LD_VAR 0 8
74241: PUSH
74242: LD_VAR 0 3
74246: ARRAY
74247: PPUSH
74248: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
74252: LD_INT 35
74254: PPUSH
74255: CALL_OW 67
// until not HasTask ( tmp ) ;
74259: LD_VAR 0 7
74263: PPUSH
74264: CALL_OW 314
74268: NOT
74269: IFFALSE 74252
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
74271: LD_ADDR_EXP 105
74275: PUSH
74276: LD_EXP 105
74280: PPUSH
74281: LD_VAR 0 2
74285: PUSH
74286: LD_EXP 105
74290: PUSH
74291: LD_VAR 0 2
74295: ARRAY
74296: PUSH
74297: LD_INT 1
74299: PLUS
74300: PUSH
74301: EMPTY
74302: LIST
74303: LIST
74304: PPUSH
74305: LD_VAR 0 8
74309: PUSH
74310: LD_VAR 0 3
74314: ARRAY
74315: PPUSH
74316: CALL 18588 0 3
74320: ST_TO_ADDR
// end ;
74321: GO 73979
74323: POP
74324: POP
// MC_Reset ( i , 124 ) ;
74325: LD_VAR 0 2
74329: PPUSH
74330: LD_INT 124
74332: PPUSH
74333: CALL 57479 0 2
// end ; end ;
74337: GO 73734
74339: POP
74340: POP
// end ;
74341: LD_VAR 0 1
74345: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
74346: LD_INT 0
74348: PPUSH
74349: PPUSH
74350: PPUSH
// if not mc_bases then
74351: LD_EXP 69
74355: NOT
74356: IFFALSE 74360
// exit ;
74358: GO 74966
// for i = 1 to mc_bases do
74360: LD_ADDR_VAR 0 2
74364: PUSH
74365: DOUBLE
74366: LD_INT 1
74368: DEC
74369: ST_TO_ADDR
74370: LD_EXP 69
74374: PUSH
74375: FOR_TO
74376: IFFALSE 74964
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
74378: LD_ADDR_VAR 0 3
74382: PUSH
74383: LD_EXP 69
74387: PUSH
74388: LD_VAR 0 2
74392: ARRAY
74393: PPUSH
74394: LD_INT 25
74396: PUSH
74397: LD_INT 4
74399: PUSH
74400: EMPTY
74401: LIST
74402: LIST
74403: PPUSH
74404: CALL_OW 72
74408: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
74409: LD_VAR 0 3
74413: NOT
74414: PUSH
74415: LD_EXP 106
74419: PUSH
74420: LD_VAR 0 2
74424: ARRAY
74425: NOT
74426: OR
74427: PUSH
74428: LD_EXP 69
74432: PUSH
74433: LD_VAR 0 2
74437: ARRAY
74438: PPUSH
74439: LD_INT 2
74441: PUSH
74442: LD_INT 30
74444: PUSH
74445: LD_INT 0
74447: PUSH
74448: EMPTY
74449: LIST
74450: LIST
74451: PUSH
74452: LD_INT 30
74454: PUSH
74455: LD_INT 1
74457: PUSH
74458: EMPTY
74459: LIST
74460: LIST
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: LIST
74466: PPUSH
74467: CALL_OW 72
74471: NOT
74472: OR
74473: IFFALSE 74523
// begin if mc_deposits_finder [ i ] then
74475: LD_EXP 107
74479: PUSH
74480: LD_VAR 0 2
74484: ARRAY
74485: IFFALSE 74521
// begin MC_Reset ( i , 125 ) ;
74487: LD_VAR 0 2
74491: PPUSH
74492: LD_INT 125
74494: PPUSH
74495: CALL 57479 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74499: LD_ADDR_EXP 107
74503: PUSH
74504: LD_EXP 107
74508: PPUSH
74509: LD_VAR 0 2
74513: PPUSH
74514: EMPTY
74515: PPUSH
74516: CALL_OW 1
74520: ST_TO_ADDR
// end ; continue ;
74521: GO 74375
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
74523: LD_EXP 106
74527: PUSH
74528: LD_VAR 0 2
74532: ARRAY
74533: PUSH
74534: LD_INT 1
74536: ARRAY
74537: PUSH
74538: LD_INT 3
74540: ARRAY
74541: PUSH
74542: LD_INT 1
74544: EQUAL
74545: PUSH
74546: LD_INT 20
74548: PPUSH
74549: LD_EXP 95
74553: PUSH
74554: LD_VAR 0 2
74558: ARRAY
74559: PPUSH
74560: CALL_OW 321
74564: PUSH
74565: LD_INT 2
74567: NONEQUAL
74568: AND
74569: IFFALSE 74619
// begin if mc_deposits_finder [ i ] then
74571: LD_EXP 107
74575: PUSH
74576: LD_VAR 0 2
74580: ARRAY
74581: IFFALSE 74617
// begin MC_Reset ( i , 125 ) ;
74583: LD_VAR 0 2
74587: PPUSH
74588: LD_INT 125
74590: PPUSH
74591: CALL 57479 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74595: LD_ADDR_EXP 107
74599: PUSH
74600: LD_EXP 107
74604: PPUSH
74605: LD_VAR 0 2
74609: PPUSH
74610: EMPTY
74611: PPUSH
74612: CALL_OW 1
74616: ST_TO_ADDR
// end ; continue ;
74617: GO 74375
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
74619: LD_EXP 106
74623: PUSH
74624: LD_VAR 0 2
74628: ARRAY
74629: PUSH
74630: LD_INT 1
74632: ARRAY
74633: PUSH
74634: LD_INT 1
74636: ARRAY
74637: PPUSH
74638: LD_EXP 106
74642: PUSH
74643: LD_VAR 0 2
74647: ARRAY
74648: PUSH
74649: LD_INT 1
74651: ARRAY
74652: PUSH
74653: LD_INT 2
74655: ARRAY
74656: PPUSH
74657: LD_EXP 95
74661: PUSH
74662: LD_VAR 0 2
74666: ARRAY
74667: PPUSH
74668: CALL_OW 440
74672: IFFALSE 74715
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
74674: LD_ADDR_EXP 106
74678: PUSH
74679: LD_EXP 106
74683: PPUSH
74684: LD_VAR 0 2
74688: PPUSH
74689: LD_EXP 106
74693: PUSH
74694: LD_VAR 0 2
74698: ARRAY
74699: PPUSH
74700: LD_INT 1
74702: PPUSH
74703: CALL_OW 3
74707: PPUSH
74708: CALL_OW 1
74712: ST_TO_ADDR
74713: GO 74962
// begin if not mc_deposits_finder [ i ] then
74715: LD_EXP 107
74719: PUSH
74720: LD_VAR 0 2
74724: ARRAY
74725: NOT
74726: IFFALSE 74778
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
74728: LD_ADDR_EXP 107
74732: PUSH
74733: LD_EXP 107
74737: PPUSH
74738: LD_VAR 0 2
74742: PPUSH
74743: LD_VAR 0 3
74747: PUSH
74748: LD_INT 1
74750: ARRAY
74751: PUSH
74752: EMPTY
74753: LIST
74754: PPUSH
74755: CALL_OW 1
74759: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
74760: LD_VAR 0 3
74764: PUSH
74765: LD_INT 1
74767: ARRAY
74768: PPUSH
74769: LD_INT 125
74771: PPUSH
74772: CALL_OW 109
// end else
74776: GO 74962
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
74778: LD_EXP 107
74782: PUSH
74783: LD_VAR 0 2
74787: ARRAY
74788: PUSH
74789: LD_INT 1
74791: ARRAY
74792: PPUSH
74793: CALL_OW 310
74797: IFFALSE 74820
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
74799: LD_EXP 107
74803: PUSH
74804: LD_VAR 0 2
74808: ARRAY
74809: PUSH
74810: LD_INT 1
74812: ARRAY
74813: PPUSH
74814: CALL_OW 122
74818: GO 74962
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
74820: LD_EXP 107
74824: PUSH
74825: LD_VAR 0 2
74829: ARRAY
74830: PUSH
74831: LD_INT 1
74833: ARRAY
74834: PPUSH
74835: CALL_OW 314
74839: NOT
74840: PUSH
74841: LD_EXP 107
74845: PUSH
74846: LD_VAR 0 2
74850: ARRAY
74851: PUSH
74852: LD_INT 1
74854: ARRAY
74855: PPUSH
74856: LD_EXP 106
74860: PUSH
74861: LD_VAR 0 2
74865: ARRAY
74866: PUSH
74867: LD_INT 1
74869: ARRAY
74870: PUSH
74871: LD_INT 1
74873: ARRAY
74874: PPUSH
74875: LD_EXP 106
74879: PUSH
74880: LD_VAR 0 2
74884: ARRAY
74885: PUSH
74886: LD_INT 1
74888: ARRAY
74889: PUSH
74890: LD_INT 2
74892: ARRAY
74893: PPUSH
74894: CALL_OW 297
74898: PUSH
74899: LD_INT 6
74901: GREATER
74902: AND
74903: IFFALSE 74962
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
74905: LD_EXP 107
74909: PUSH
74910: LD_VAR 0 2
74914: ARRAY
74915: PUSH
74916: LD_INT 1
74918: ARRAY
74919: PPUSH
74920: LD_EXP 106
74924: PUSH
74925: LD_VAR 0 2
74929: ARRAY
74930: PUSH
74931: LD_INT 1
74933: ARRAY
74934: PUSH
74935: LD_INT 1
74937: ARRAY
74938: PPUSH
74939: LD_EXP 106
74943: PUSH
74944: LD_VAR 0 2
74948: ARRAY
74949: PUSH
74950: LD_INT 1
74952: ARRAY
74953: PUSH
74954: LD_INT 2
74956: ARRAY
74957: PPUSH
74958: CALL_OW 111
// end ; end ; end ;
74962: GO 74375
74964: POP
74965: POP
// end ;
74966: LD_VAR 0 1
74970: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
74971: LD_INT 0
74973: PPUSH
74974: PPUSH
74975: PPUSH
74976: PPUSH
74977: PPUSH
74978: PPUSH
74979: PPUSH
74980: PPUSH
74981: PPUSH
74982: PPUSH
74983: PPUSH
// if not mc_bases then
74984: LD_EXP 69
74988: NOT
74989: IFFALSE 74993
// exit ;
74991: GO 75933
// for i = 1 to mc_bases do
74993: LD_ADDR_VAR 0 2
74997: PUSH
74998: DOUBLE
74999: LD_INT 1
75001: DEC
75002: ST_TO_ADDR
75003: LD_EXP 69
75007: PUSH
75008: FOR_TO
75009: IFFALSE 75931
// begin if not mc_bases [ i ] or mc_scan [ i ] then
75011: LD_EXP 69
75015: PUSH
75016: LD_VAR 0 2
75020: ARRAY
75021: NOT
75022: PUSH
75023: LD_EXP 92
75027: PUSH
75028: LD_VAR 0 2
75032: ARRAY
75033: OR
75034: IFFALSE 75038
// continue ;
75036: GO 75008
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
75038: LD_ADDR_VAR 0 7
75042: PUSH
75043: LD_EXP 69
75047: PUSH
75048: LD_VAR 0 2
75052: ARRAY
75053: PUSH
75054: LD_INT 1
75056: ARRAY
75057: PPUSH
75058: CALL_OW 248
75062: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
75063: LD_VAR 0 7
75067: PUSH
75068: LD_INT 3
75070: EQUAL
75071: PUSH
75072: LD_EXP 88
75076: PUSH
75077: LD_VAR 0 2
75081: ARRAY
75082: PUSH
75083: LD_EXP 91
75087: PUSH
75088: LD_VAR 0 2
75092: ARRAY
75093: UNION
75094: PPUSH
75095: LD_INT 33
75097: PUSH
75098: LD_INT 2
75100: PUSH
75101: EMPTY
75102: LIST
75103: LIST
75104: PPUSH
75105: CALL_OW 72
75109: NOT
75110: OR
75111: IFFALSE 75115
// continue ;
75113: GO 75008
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
75115: LD_ADDR_VAR 0 9
75119: PUSH
75120: LD_EXP 69
75124: PUSH
75125: LD_VAR 0 2
75129: ARRAY
75130: PPUSH
75131: LD_INT 30
75133: PUSH
75134: LD_INT 36
75136: PUSH
75137: EMPTY
75138: LIST
75139: LIST
75140: PPUSH
75141: CALL_OW 72
75145: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
75146: LD_ADDR_VAR 0 10
75150: PUSH
75151: LD_EXP 88
75155: PUSH
75156: LD_VAR 0 2
75160: ARRAY
75161: PPUSH
75162: LD_INT 34
75164: PUSH
75165: LD_INT 31
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PPUSH
75172: CALL_OW 72
75176: ST_TO_ADDR
// if not cts and not mcts then
75177: LD_VAR 0 9
75181: NOT
75182: PUSH
75183: LD_VAR 0 10
75187: NOT
75188: AND
75189: IFFALSE 75193
// continue ;
75191: GO 75008
// x := cts ;
75193: LD_ADDR_VAR 0 11
75197: PUSH
75198: LD_VAR 0 9
75202: ST_TO_ADDR
// if not x then
75203: LD_VAR 0 11
75207: NOT
75208: IFFALSE 75220
// x := mcts ;
75210: LD_ADDR_VAR 0 11
75214: PUSH
75215: LD_VAR 0 10
75219: ST_TO_ADDR
// if not x then
75220: LD_VAR 0 11
75224: NOT
75225: IFFALSE 75229
// continue ;
75227: GO 75008
// if mc_remote_driver [ i ] then
75229: LD_EXP 109
75233: PUSH
75234: LD_VAR 0 2
75238: ARRAY
75239: IFFALSE 75626
// for j in mc_remote_driver [ i ] do
75241: LD_ADDR_VAR 0 3
75245: PUSH
75246: LD_EXP 109
75250: PUSH
75251: LD_VAR 0 2
75255: ARRAY
75256: PUSH
75257: FOR_IN
75258: IFFALSE 75624
// begin if GetClass ( j ) <> 3 then
75260: LD_VAR 0 3
75264: PPUSH
75265: CALL_OW 257
75269: PUSH
75270: LD_INT 3
75272: NONEQUAL
75273: IFFALSE 75326
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
75275: LD_ADDR_EXP 109
75279: PUSH
75280: LD_EXP 109
75284: PPUSH
75285: LD_VAR 0 2
75289: PPUSH
75290: LD_EXP 109
75294: PUSH
75295: LD_VAR 0 2
75299: ARRAY
75300: PUSH
75301: LD_VAR 0 3
75305: DIFF
75306: PPUSH
75307: CALL_OW 1
75311: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75312: LD_VAR 0 3
75316: PPUSH
75317: LD_INT 0
75319: PPUSH
75320: CALL_OW 109
// continue ;
75324: GO 75257
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
75326: LD_EXP 88
75330: PUSH
75331: LD_VAR 0 2
75335: ARRAY
75336: PPUSH
75337: LD_INT 34
75339: PUSH
75340: LD_INT 31
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: LD_INT 58
75349: PUSH
75350: EMPTY
75351: LIST
75352: PUSH
75353: EMPTY
75354: LIST
75355: LIST
75356: PPUSH
75357: CALL_OW 72
75361: PUSH
75362: LD_VAR 0 3
75366: PPUSH
75367: CALL 47945 0 1
75371: NOT
75372: AND
75373: IFFALSE 75444
// begin if IsInUnit ( j ) then
75375: LD_VAR 0 3
75379: PPUSH
75380: CALL_OW 310
75384: IFFALSE 75395
// ComExitBuilding ( j ) ;
75386: LD_VAR 0 3
75390: PPUSH
75391: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
75395: LD_VAR 0 3
75399: PPUSH
75400: LD_EXP 88
75404: PUSH
75405: LD_VAR 0 2
75409: ARRAY
75410: PPUSH
75411: LD_INT 34
75413: PUSH
75414: LD_INT 31
75416: PUSH
75417: EMPTY
75418: LIST
75419: LIST
75420: PUSH
75421: LD_INT 58
75423: PUSH
75424: EMPTY
75425: LIST
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: PPUSH
75431: CALL_OW 72
75435: PUSH
75436: LD_INT 1
75438: ARRAY
75439: PPUSH
75440: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
75444: LD_VAR 0 3
75448: PPUSH
75449: CALL_OW 310
75453: NOT
75454: PUSH
75455: LD_VAR 0 3
75459: PPUSH
75460: CALL_OW 310
75464: PPUSH
75465: CALL_OW 266
75469: PUSH
75470: LD_INT 36
75472: NONEQUAL
75473: PUSH
75474: LD_VAR 0 3
75478: PPUSH
75479: CALL 47945 0 1
75483: NOT
75484: AND
75485: OR
75486: IFFALSE 75622
// begin if IsInUnit ( j ) then
75488: LD_VAR 0 3
75492: PPUSH
75493: CALL_OW 310
75497: IFFALSE 75508
// ComExitBuilding ( j ) ;
75499: LD_VAR 0 3
75503: PPUSH
75504: CALL_OW 122
// ct := 0 ;
75508: LD_ADDR_VAR 0 8
75512: PUSH
75513: LD_INT 0
75515: ST_TO_ADDR
// for k in x do
75516: LD_ADDR_VAR 0 4
75520: PUSH
75521: LD_VAR 0 11
75525: PUSH
75526: FOR_IN
75527: IFFALSE 75600
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
75529: LD_VAR 0 4
75533: PPUSH
75534: CALL_OW 264
75538: PUSH
75539: LD_INT 31
75541: EQUAL
75542: PUSH
75543: LD_VAR 0 4
75547: PPUSH
75548: CALL_OW 311
75552: NOT
75553: AND
75554: PUSH
75555: LD_VAR 0 4
75559: PPUSH
75560: CALL_OW 266
75564: PUSH
75565: LD_INT 36
75567: EQUAL
75568: PUSH
75569: LD_VAR 0 4
75573: PPUSH
75574: CALL_OW 313
75578: PUSH
75579: LD_INT 3
75581: LESS
75582: AND
75583: OR
75584: IFFALSE 75598
// begin ct := k ;
75586: LD_ADDR_VAR 0 8
75590: PUSH
75591: LD_VAR 0 4
75595: ST_TO_ADDR
// break ;
75596: GO 75600
// end ;
75598: GO 75526
75600: POP
75601: POP
// if ct then
75602: LD_VAR 0 8
75606: IFFALSE 75622
// ComEnterUnit ( j , ct ) ;
75608: LD_VAR 0 3
75612: PPUSH
75613: LD_VAR 0 8
75617: PPUSH
75618: CALL_OW 120
// end ; end ;
75622: GO 75257
75624: POP
75625: POP
// places := 0 ;
75626: LD_ADDR_VAR 0 5
75630: PUSH
75631: LD_INT 0
75633: ST_TO_ADDR
// for j = 1 to x do
75634: LD_ADDR_VAR 0 3
75638: PUSH
75639: DOUBLE
75640: LD_INT 1
75642: DEC
75643: ST_TO_ADDR
75644: LD_VAR 0 11
75648: PUSH
75649: FOR_TO
75650: IFFALSE 75726
// if GetWeapon ( x [ j ] ) = ar_control_tower then
75652: LD_VAR 0 11
75656: PUSH
75657: LD_VAR 0 3
75661: ARRAY
75662: PPUSH
75663: CALL_OW 264
75667: PUSH
75668: LD_INT 31
75670: EQUAL
75671: IFFALSE 75689
// places := places + 1 else
75673: LD_ADDR_VAR 0 5
75677: PUSH
75678: LD_VAR 0 5
75682: PUSH
75683: LD_INT 1
75685: PLUS
75686: ST_TO_ADDR
75687: GO 75724
// if GetBType ( x [ j ] ) = b_control_tower then
75689: LD_VAR 0 11
75693: PUSH
75694: LD_VAR 0 3
75698: ARRAY
75699: PPUSH
75700: CALL_OW 266
75704: PUSH
75705: LD_INT 36
75707: EQUAL
75708: IFFALSE 75724
// places := places + 3 ;
75710: LD_ADDR_VAR 0 5
75714: PUSH
75715: LD_VAR 0 5
75719: PUSH
75720: LD_INT 3
75722: PLUS
75723: ST_TO_ADDR
75724: GO 75649
75726: POP
75727: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
75728: LD_VAR 0 5
75732: PUSH
75733: LD_INT 0
75735: EQUAL
75736: PUSH
75737: LD_VAR 0 5
75741: PUSH
75742: LD_EXP 109
75746: PUSH
75747: LD_VAR 0 2
75751: ARRAY
75752: LESSEQUAL
75753: OR
75754: IFFALSE 75758
// continue ;
75756: GO 75008
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
75758: LD_ADDR_VAR 0 6
75762: PUSH
75763: LD_EXP 69
75767: PUSH
75768: LD_VAR 0 2
75772: ARRAY
75773: PPUSH
75774: LD_INT 25
75776: PUSH
75777: LD_INT 3
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: PPUSH
75784: CALL_OW 72
75788: PUSH
75789: LD_EXP 109
75793: PUSH
75794: LD_VAR 0 2
75798: ARRAY
75799: DIFF
75800: PPUSH
75801: LD_INT 3
75803: PPUSH
75804: CALL 48845 0 2
75808: ST_TO_ADDR
// for j in tmp do
75809: LD_ADDR_VAR 0 3
75813: PUSH
75814: LD_VAR 0 6
75818: PUSH
75819: FOR_IN
75820: IFFALSE 75855
// if GetTag ( j ) > 0 then
75822: LD_VAR 0 3
75826: PPUSH
75827: CALL_OW 110
75831: PUSH
75832: LD_INT 0
75834: GREATER
75835: IFFALSE 75853
// tmp := tmp diff j ;
75837: LD_ADDR_VAR 0 6
75841: PUSH
75842: LD_VAR 0 6
75846: PUSH
75847: LD_VAR 0 3
75851: DIFF
75852: ST_TO_ADDR
75853: GO 75819
75855: POP
75856: POP
// if not tmp then
75857: LD_VAR 0 6
75861: NOT
75862: IFFALSE 75866
// continue ;
75864: GO 75008
// if places then
75866: LD_VAR 0 5
75870: IFFALSE 75929
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
75872: LD_ADDR_EXP 109
75876: PUSH
75877: LD_EXP 109
75881: PPUSH
75882: LD_VAR 0 2
75886: PPUSH
75887: LD_EXP 109
75891: PUSH
75892: LD_VAR 0 2
75896: ARRAY
75897: PUSH
75898: LD_VAR 0 6
75902: PUSH
75903: LD_INT 1
75905: ARRAY
75906: UNION
75907: PPUSH
75908: CALL_OW 1
75912: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
75913: LD_VAR 0 6
75917: PUSH
75918: LD_INT 1
75920: ARRAY
75921: PPUSH
75922: LD_INT 126
75924: PPUSH
75925: CALL_OW 109
// end ; end ;
75929: GO 75008
75931: POP
75932: POP
// end ;
75933: LD_VAR 0 1
75937: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
75938: LD_INT 0
75940: PPUSH
75941: PPUSH
75942: PPUSH
75943: PPUSH
75944: PPUSH
75945: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
75946: LD_VAR 0 1
75950: NOT
75951: PUSH
75952: LD_VAR 0 2
75956: NOT
75957: OR
75958: PUSH
75959: LD_VAR 0 3
75963: NOT
75964: OR
75965: PUSH
75966: LD_VAR 0 4
75970: PUSH
75971: LD_INT 1
75973: PUSH
75974: LD_INT 2
75976: PUSH
75977: LD_INT 3
75979: PUSH
75980: LD_INT 4
75982: PUSH
75983: LD_INT 5
75985: PUSH
75986: LD_INT 8
75988: PUSH
75989: LD_INT 9
75991: PUSH
75992: LD_INT 15
75994: PUSH
75995: LD_INT 16
75997: PUSH
75998: EMPTY
75999: LIST
76000: LIST
76001: LIST
76002: LIST
76003: LIST
76004: LIST
76005: LIST
76006: LIST
76007: LIST
76008: IN
76009: NOT
76010: OR
76011: IFFALSE 76015
// exit ;
76013: GO 76915
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
76015: LD_ADDR_VAR 0 2
76019: PUSH
76020: LD_VAR 0 2
76024: PPUSH
76025: LD_INT 21
76027: PUSH
76028: LD_INT 3
76030: PUSH
76031: EMPTY
76032: LIST
76033: LIST
76034: PUSH
76035: LD_INT 24
76037: PUSH
76038: LD_INT 250
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: PUSH
76045: EMPTY
76046: LIST
76047: LIST
76048: PPUSH
76049: CALL_OW 72
76053: ST_TO_ADDR
// case class of 1 , 15 :
76054: LD_VAR 0 4
76058: PUSH
76059: LD_INT 1
76061: DOUBLE
76062: EQUAL
76063: IFTRUE 76073
76065: LD_INT 15
76067: DOUBLE
76068: EQUAL
76069: IFTRUE 76073
76071: GO 76158
76073: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
76074: LD_ADDR_VAR 0 8
76078: PUSH
76079: LD_VAR 0 2
76083: PPUSH
76084: LD_INT 2
76086: PUSH
76087: LD_INT 30
76089: PUSH
76090: LD_INT 32
76092: PUSH
76093: EMPTY
76094: LIST
76095: LIST
76096: PUSH
76097: LD_INT 30
76099: PUSH
76100: LD_INT 31
76102: PUSH
76103: EMPTY
76104: LIST
76105: LIST
76106: PUSH
76107: EMPTY
76108: LIST
76109: LIST
76110: LIST
76111: PPUSH
76112: CALL_OW 72
76116: PUSH
76117: LD_VAR 0 2
76121: PPUSH
76122: LD_INT 2
76124: PUSH
76125: LD_INT 30
76127: PUSH
76128: LD_INT 4
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: PUSH
76135: LD_INT 30
76137: PUSH
76138: LD_INT 5
76140: PUSH
76141: EMPTY
76142: LIST
76143: LIST
76144: PUSH
76145: EMPTY
76146: LIST
76147: LIST
76148: LIST
76149: PPUSH
76150: CALL_OW 72
76154: ADD
76155: ST_TO_ADDR
76156: GO 76404
76158: LD_INT 2
76160: DOUBLE
76161: EQUAL
76162: IFTRUE 76172
76164: LD_INT 16
76166: DOUBLE
76167: EQUAL
76168: IFTRUE 76172
76170: GO 76218
76172: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
76173: LD_ADDR_VAR 0 8
76177: PUSH
76178: LD_VAR 0 2
76182: PPUSH
76183: LD_INT 2
76185: PUSH
76186: LD_INT 30
76188: PUSH
76189: LD_INT 0
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: PUSH
76196: LD_INT 30
76198: PUSH
76199: LD_INT 1
76201: PUSH
76202: EMPTY
76203: LIST
76204: LIST
76205: PUSH
76206: EMPTY
76207: LIST
76208: LIST
76209: LIST
76210: PPUSH
76211: CALL_OW 72
76215: ST_TO_ADDR
76216: GO 76404
76218: LD_INT 3
76220: DOUBLE
76221: EQUAL
76222: IFTRUE 76226
76224: GO 76272
76226: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
76227: LD_ADDR_VAR 0 8
76231: PUSH
76232: LD_VAR 0 2
76236: PPUSH
76237: LD_INT 2
76239: PUSH
76240: LD_INT 30
76242: PUSH
76243: LD_INT 2
76245: PUSH
76246: EMPTY
76247: LIST
76248: LIST
76249: PUSH
76250: LD_INT 30
76252: PUSH
76253: LD_INT 3
76255: PUSH
76256: EMPTY
76257: LIST
76258: LIST
76259: PUSH
76260: EMPTY
76261: LIST
76262: LIST
76263: LIST
76264: PPUSH
76265: CALL_OW 72
76269: ST_TO_ADDR
76270: GO 76404
76272: LD_INT 4
76274: DOUBLE
76275: EQUAL
76276: IFTRUE 76280
76278: GO 76337
76280: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
76281: LD_ADDR_VAR 0 8
76285: PUSH
76286: LD_VAR 0 2
76290: PPUSH
76291: LD_INT 2
76293: PUSH
76294: LD_INT 30
76296: PUSH
76297: LD_INT 6
76299: PUSH
76300: EMPTY
76301: LIST
76302: LIST
76303: PUSH
76304: LD_INT 30
76306: PUSH
76307: LD_INT 7
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: PUSH
76314: LD_INT 30
76316: PUSH
76317: LD_INT 8
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: PUSH
76324: EMPTY
76325: LIST
76326: LIST
76327: LIST
76328: LIST
76329: PPUSH
76330: CALL_OW 72
76334: ST_TO_ADDR
76335: GO 76404
76337: LD_INT 5
76339: DOUBLE
76340: EQUAL
76341: IFTRUE 76357
76343: LD_INT 8
76345: DOUBLE
76346: EQUAL
76347: IFTRUE 76357
76349: LD_INT 9
76351: DOUBLE
76352: EQUAL
76353: IFTRUE 76357
76355: GO 76403
76357: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
76358: LD_ADDR_VAR 0 8
76362: PUSH
76363: LD_VAR 0 2
76367: PPUSH
76368: LD_INT 2
76370: PUSH
76371: LD_INT 30
76373: PUSH
76374: LD_INT 4
76376: PUSH
76377: EMPTY
76378: LIST
76379: LIST
76380: PUSH
76381: LD_INT 30
76383: PUSH
76384: LD_INT 5
76386: PUSH
76387: EMPTY
76388: LIST
76389: LIST
76390: PUSH
76391: EMPTY
76392: LIST
76393: LIST
76394: LIST
76395: PPUSH
76396: CALL_OW 72
76400: ST_TO_ADDR
76401: GO 76404
76403: POP
// if not tmp then
76404: LD_VAR 0 8
76408: NOT
76409: IFFALSE 76413
// exit ;
76411: GO 76915
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
76413: LD_VAR 0 4
76417: PUSH
76418: LD_INT 1
76420: PUSH
76421: LD_INT 15
76423: PUSH
76424: EMPTY
76425: LIST
76426: LIST
76427: IN
76428: PUSH
76429: LD_EXP 78
76433: PUSH
76434: LD_VAR 0 1
76438: ARRAY
76439: AND
76440: IFFALSE 76596
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
76442: LD_ADDR_VAR 0 9
76446: PUSH
76447: LD_EXP 78
76451: PUSH
76452: LD_VAR 0 1
76456: ARRAY
76457: PUSH
76458: LD_INT 1
76460: ARRAY
76461: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
76462: LD_VAR 0 9
76466: PUSH
76467: LD_EXP 79
76471: PUSH
76472: LD_VAR 0 1
76476: ARRAY
76477: IN
76478: NOT
76479: IFFALSE 76594
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
76481: LD_ADDR_EXP 79
76485: PUSH
76486: LD_EXP 79
76490: PPUSH
76491: LD_VAR 0 1
76495: PUSH
76496: LD_EXP 79
76500: PUSH
76501: LD_VAR 0 1
76505: ARRAY
76506: PUSH
76507: LD_INT 1
76509: PLUS
76510: PUSH
76511: EMPTY
76512: LIST
76513: LIST
76514: PPUSH
76515: LD_VAR 0 9
76519: PPUSH
76520: CALL 18588 0 3
76524: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
76525: LD_ADDR_EXP 78
76529: PUSH
76530: LD_EXP 78
76534: PPUSH
76535: LD_VAR 0 1
76539: PPUSH
76540: LD_EXP 78
76544: PUSH
76545: LD_VAR 0 1
76549: ARRAY
76550: PUSH
76551: LD_VAR 0 9
76555: DIFF
76556: PPUSH
76557: CALL_OW 1
76561: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
76562: LD_VAR 0 3
76566: PPUSH
76567: LD_EXP 79
76571: PUSH
76572: LD_VAR 0 1
76576: ARRAY
76577: PUSH
76578: LD_EXP 79
76582: PUSH
76583: LD_VAR 0 1
76587: ARRAY
76588: ARRAY
76589: PPUSH
76590: CALL_OW 120
// end ; exit ;
76594: GO 76915
// end ; if tmp > 1 then
76596: LD_VAR 0 8
76600: PUSH
76601: LD_INT 1
76603: GREATER
76604: IFFALSE 76708
// for i = 2 to tmp do
76606: LD_ADDR_VAR 0 6
76610: PUSH
76611: DOUBLE
76612: LD_INT 2
76614: DEC
76615: ST_TO_ADDR
76616: LD_VAR 0 8
76620: PUSH
76621: FOR_TO
76622: IFFALSE 76706
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
76624: LD_VAR 0 8
76628: PUSH
76629: LD_VAR 0 6
76633: ARRAY
76634: PPUSH
76635: CALL_OW 461
76639: PUSH
76640: LD_INT 6
76642: EQUAL
76643: IFFALSE 76704
// begin x := tmp [ i ] ;
76645: LD_ADDR_VAR 0 9
76649: PUSH
76650: LD_VAR 0 8
76654: PUSH
76655: LD_VAR 0 6
76659: ARRAY
76660: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
76661: LD_ADDR_VAR 0 8
76665: PUSH
76666: LD_VAR 0 8
76670: PPUSH
76671: LD_VAR 0 6
76675: PPUSH
76676: CALL_OW 3
76680: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
76681: LD_ADDR_VAR 0 8
76685: PUSH
76686: LD_VAR 0 8
76690: PPUSH
76691: LD_INT 1
76693: PPUSH
76694: LD_VAR 0 9
76698: PPUSH
76699: CALL_OW 2
76703: ST_TO_ADDR
// end ;
76704: GO 76621
76706: POP
76707: POP
// for i in tmp do
76708: LD_ADDR_VAR 0 6
76712: PUSH
76713: LD_VAR 0 8
76717: PUSH
76718: FOR_IN
76719: IFFALSE 76788
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
76721: LD_VAR 0 6
76725: PPUSH
76726: CALL_OW 313
76730: PUSH
76731: LD_INT 6
76733: LESS
76734: PUSH
76735: LD_VAR 0 6
76739: PPUSH
76740: CALL_OW 266
76744: PUSH
76745: LD_INT 31
76747: PUSH
76748: LD_INT 32
76750: PUSH
76751: EMPTY
76752: LIST
76753: LIST
76754: IN
76755: NOT
76756: AND
76757: PUSH
76758: LD_VAR 0 6
76762: PPUSH
76763: CALL_OW 313
76767: PUSH
76768: LD_INT 0
76770: EQUAL
76771: OR
76772: IFFALSE 76786
// begin j := i ;
76774: LD_ADDR_VAR 0 7
76778: PUSH
76779: LD_VAR 0 6
76783: ST_TO_ADDR
// break ;
76784: GO 76788
// end ; end ;
76786: GO 76718
76788: POP
76789: POP
// if j then
76790: LD_VAR 0 7
76794: IFFALSE 76812
// ComEnterUnit ( unit , j ) else
76796: LD_VAR 0 3
76800: PPUSH
76801: LD_VAR 0 7
76805: PPUSH
76806: CALL_OW 120
76810: GO 76915
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76812: LD_ADDR_VAR 0 10
76816: PUSH
76817: LD_VAR 0 2
76821: PPUSH
76822: LD_INT 2
76824: PUSH
76825: LD_INT 30
76827: PUSH
76828: LD_INT 0
76830: PUSH
76831: EMPTY
76832: LIST
76833: LIST
76834: PUSH
76835: LD_INT 30
76837: PUSH
76838: LD_INT 1
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: LIST
76849: PPUSH
76850: CALL_OW 72
76854: ST_TO_ADDR
// if depot then
76855: LD_VAR 0 10
76859: IFFALSE 76915
// begin depot := NearestUnitToUnit ( depot , unit ) ;
76861: LD_ADDR_VAR 0 10
76865: PUSH
76866: LD_VAR 0 10
76870: PPUSH
76871: LD_VAR 0 3
76875: PPUSH
76876: CALL_OW 74
76880: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
76881: LD_VAR 0 3
76885: PPUSH
76886: LD_VAR 0 10
76890: PPUSH
76891: CALL_OW 296
76895: PUSH
76896: LD_INT 10
76898: GREATER
76899: IFFALSE 76915
// ComStandNearbyBuilding ( unit , depot ) ;
76901: LD_VAR 0 3
76905: PPUSH
76906: LD_VAR 0 10
76910: PPUSH
76911: CALL 15166 0 2
// end ; end ; end ;
76915: LD_VAR 0 5
76919: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
76920: LD_INT 0
76922: PPUSH
76923: PPUSH
76924: PPUSH
76925: PPUSH
// if not mc_bases then
76926: LD_EXP 69
76930: NOT
76931: IFFALSE 76935
// exit ;
76933: GO 77174
// for i = 1 to mc_bases do
76935: LD_ADDR_VAR 0 2
76939: PUSH
76940: DOUBLE
76941: LD_INT 1
76943: DEC
76944: ST_TO_ADDR
76945: LD_EXP 69
76949: PUSH
76950: FOR_TO
76951: IFFALSE 77172
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
76953: LD_ADDR_VAR 0 4
76957: PUSH
76958: LD_EXP 69
76962: PUSH
76963: LD_VAR 0 2
76967: ARRAY
76968: PPUSH
76969: LD_INT 21
76971: PUSH
76972: LD_INT 1
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: PPUSH
76979: CALL_OW 72
76983: PUSH
76984: LD_EXP 98
76988: PUSH
76989: LD_VAR 0 2
76993: ARRAY
76994: UNION
76995: ST_TO_ADDR
// if not tmp then
76996: LD_VAR 0 4
77000: NOT
77001: IFFALSE 77005
// continue ;
77003: GO 76950
// for j in tmp do
77005: LD_ADDR_VAR 0 3
77009: PUSH
77010: LD_VAR 0 4
77014: PUSH
77015: FOR_IN
77016: IFFALSE 77168
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
77018: LD_VAR 0 3
77022: PPUSH
77023: CALL_OW 110
77027: NOT
77028: PUSH
77029: LD_VAR 0 3
77033: PPUSH
77034: CALL_OW 314
77038: NOT
77039: AND
77040: PUSH
77041: LD_VAR 0 3
77045: PPUSH
77046: CALL_OW 311
77050: NOT
77051: AND
77052: PUSH
77053: LD_VAR 0 3
77057: PPUSH
77058: CALL_OW 310
77062: NOT
77063: AND
77064: PUSH
77065: LD_VAR 0 3
77069: PUSH
77070: LD_EXP 72
77074: PUSH
77075: LD_VAR 0 2
77079: ARRAY
77080: PUSH
77081: LD_INT 1
77083: ARRAY
77084: IN
77085: NOT
77086: AND
77087: PUSH
77088: LD_VAR 0 3
77092: PUSH
77093: LD_EXP 72
77097: PUSH
77098: LD_VAR 0 2
77102: ARRAY
77103: PUSH
77104: LD_INT 2
77106: ARRAY
77107: IN
77108: NOT
77109: AND
77110: PUSH
77111: LD_VAR 0 3
77115: PUSH
77116: LD_EXP 81
77120: PUSH
77121: LD_VAR 0 2
77125: ARRAY
77126: IN
77127: NOT
77128: AND
77129: IFFALSE 77166
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
77131: LD_VAR 0 2
77135: PPUSH
77136: LD_EXP 69
77140: PUSH
77141: LD_VAR 0 2
77145: ARRAY
77146: PPUSH
77147: LD_VAR 0 3
77151: PPUSH
77152: LD_VAR 0 3
77156: PPUSH
77157: CALL_OW 257
77161: PPUSH
77162: CALL 75938 0 4
// end ;
77166: GO 77015
77168: POP
77169: POP
// end ;
77170: GO 76950
77172: POP
77173: POP
// end ;
77174: LD_VAR 0 1
77178: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
77179: LD_INT 0
77181: PPUSH
77182: PPUSH
77183: PPUSH
77184: PPUSH
77185: PPUSH
77186: PPUSH
// if not mc_bases [ base ] then
77187: LD_EXP 69
77191: PUSH
77192: LD_VAR 0 1
77196: ARRAY
77197: NOT
77198: IFFALSE 77202
// exit ;
77200: GO 77384
// tmp := [ ] ;
77202: LD_ADDR_VAR 0 6
77206: PUSH
77207: EMPTY
77208: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
77209: LD_ADDR_VAR 0 7
77213: PUSH
77214: LD_VAR 0 3
77218: PPUSH
77219: LD_INT 0
77221: PPUSH
77222: CALL_OW 517
77226: ST_TO_ADDR
// if not list then
77227: LD_VAR 0 7
77231: NOT
77232: IFFALSE 77236
// exit ;
77234: GO 77384
// for i = 1 to amount do
77236: LD_ADDR_VAR 0 5
77240: PUSH
77241: DOUBLE
77242: LD_INT 1
77244: DEC
77245: ST_TO_ADDR
77246: LD_VAR 0 2
77250: PUSH
77251: FOR_TO
77252: IFFALSE 77332
// begin x := rand ( 1 , list [ 1 ] ) ;
77254: LD_ADDR_VAR 0 8
77258: PUSH
77259: LD_INT 1
77261: PPUSH
77262: LD_VAR 0 7
77266: PUSH
77267: LD_INT 1
77269: ARRAY
77270: PPUSH
77271: CALL_OW 12
77275: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
77276: LD_ADDR_VAR 0 6
77280: PUSH
77281: LD_VAR 0 6
77285: PPUSH
77286: LD_VAR 0 5
77290: PPUSH
77291: LD_VAR 0 7
77295: PUSH
77296: LD_INT 1
77298: ARRAY
77299: PUSH
77300: LD_VAR 0 8
77304: ARRAY
77305: PUSH
77306: LD_VAR 0 7
77310: PUSH
77311: LD_INT 2
77313: ARRAY
77314: PUSH
77315: LD_VAR 0 8
77319: ARRAY
77320: PUSH
77321: EMPTY
77322: LIST
77323: LIST
77324: PPUSH
77325: CALL_OW 1
77329: ST_TO_ADDR
// end ;
77330: GO 77251
77332: POP
77333: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
77334: LD_ADDR_EXP 82
77338: PUSH
77339: LD_EXP 82
77343: PPUSH
77344: LD_VAR 0 1
77348: PPUSH
77349: LD_VAR 0 6
77353: PPUSH
77354: CALL_OW 1
77358: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
77359: LD_ADDR_EXP 84
77363: PUSH
77364: LD_EXP 84
77368: PPUSH
77369: LD_VAR 0 1
77373: PPUSH
77374: LD_VAR 0 3
77378: PPUSH
77379: CALL_OW 1
77383: ST_TO_ADDR
// end ;
77384: LD_VAR 0 4
77388: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
77389: LD_INT 0
77391: PPUSH
// if not mc_bases [ base ] then
77392: LD_EXP 69
77396: PUSH
77397: LD_VAR 0 1
77401: ARRAY
77402: NOT
77403: IFFALSE 77407
// exit ;
77405: GO 77432
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
77407: LD_ADDR_EXP 74
77411: PUSH
77412: LD_EXP 74
77416: PPUSH
77417: LD_VAR 0 1
77421: PPUSH
77422: LD_VAR 0 2
77426: PPUSH
77427: CALL_OW 1
77431: ST_TO_ADDR
// end ;
77432: LD_VAR 0 3
77436: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
77437: LD_INT 0
77439: PPUSH
// if not mc_bases [ base ] then
77440: LD_EXP 69
77444: PUSH
77445: LD_VAR 0 1
77449: ARRAY
77450: NOT
77451: IFFALSE 77455
// exit ;
77453: GO 77492
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
77455: LD_ADDR_EXP 74
77459: PUSH
77460: LD_EXP 74
77464: PPUSH
77465: LD_VAR 0 1
77469: PPUSH
77470: LD_EXP 74
77474: PUSH
77475: LD_VAR 0 1
77479: ARRAY
77480: PUSH
77481: LD_VAR 0 2
77485: UNION
77486: PPUSH
77487: CALL_OW 1
77491: ST_TO_ADDR
// end ;
77492: LD_VAR 0 3
77496: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
77497: LD_INT 0
77499: PPUSH
// if not mc_bases [ base ] then
77500: LD_EXP 69
77504: PUSH
77505: LD_VAR 0 1
77509: ARRAY
77510: NOT
77511: IFFALSE 77515
// exit ;
77513: GO 77540
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
77515: LD_ADDR_EXP 90
77519: PUSH
77520: LD_EXP 90
77524: PPUSH
77525: LD_VAR 0 1
77529: PPUSH
77530: LD_VAR 0 2
77534: PPUSH
77535: CALL_OW 1
77539: ST_TO_ADDR
// end ;
77540: LD_VAR 0 3
77544: RET
// export function MC_InsertProduceList ( base , components ) ; begin
77545: LD_INT 0
77547: PPUSH
// if not mc_bases [ base ] then
77548: LD_EXP 69
77552: PUSH
77553: LD_VAR 0 1
77557: ARRAY
77558: NOT
77559: IFFALSE 77563
// exit ;
77561: GO 77600
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
77563: LD_ADDR_EXP 90
77567: PUSH
77568: LD_EXP 90
77572: PPUSH
77573: LD_VAR 0 1
77577: PPUSH
77578: LD_EXP 90
77582: PUSH
77583: LD_VAR 0 1
77587: ARRAY
77588: PUSH
77589: LD_VAR 0 2
77593: ADD
77594: PPUSH
77595: CALL_OW 1
77599: ST_TO_ADDR
// end ;
77600: LD_VAR 0 3
77604: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
77605: LD_INT 0
77607: PPUSH
// if not mc_bases [ base ] then
77608: LD_EXP 69
77612: PUSH
77613: LD_VAR 0 1
77617: ARRAY
77618: NOT
77619: IFFALSE 77623
// exit ;
77621: GO 77677
// mc_defender := Replace ( mc_defender , base , deflist ) ;
77623: LD_ADDR_EXP 91
77627: PUSH
77628: LD_EXP 91
77632: PPUSH
77633: LD_VAR 0 1
77637: PPUSH
77638: LD_VAR 0 2
77642: PPUSH
77643: CALL_OW 1
77647: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
77648: LD_ADDR_EXP 80
77652: PUSH
77653: LD_EXP 80
77657: PPUSH
77658: LD_VAR 0 1
77662: PPUSH
77663: LD_VAR 0 2
77667: PUSH
77668: LD_INT 0
77670: PLUS
77671: PPUSH
77672: CALL_OW 1
77676: ST_TO_ADDR
// end ;
77677: LD_VAR 0 3
77681: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
77682: LD_INT 0
77684: PPUSH
// if not mc_bases [ base ] then
77685: LD_EXP 69
77689: PUSH
77690: LD_VAR 0 1
77694: ARRAY
77695: NOT
77696: IFFALSE 77700
// exit ;
77698: GO 77725
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
77700: LD_ADDR_EXP 80
77704: PUSH
77705: LD_EXP 80
77709: PPUSH
77710: LD_VAR 0 1
77714: PPUSH
77715: LD_VAR 0 2
77719: PPUSH
77720: CALL_OW 1
77724: ST_TO_ADDR
// end ;
77725: LD_VAR 0 3
77729: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
77730: LD_INT 0
77732: PPUSH
77733: PPUSH
77734: PPUSH
77735: PPUSH
// if not mc_bases [ base ] then
77736: LD_EXP 69
77740: PUSH
77741: LD_VAR 0 1
77745: ARRAY
77746: NOT
77747: IFFALSE 77751
// exit ;
77749: GO 77816
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
77751: LD_ADDR_EXP 89
77755: PUSH
77756: LD_EXP 89
77760: PPUSH
77761: LD_VAR 0 1
77765: PUSH
77766: LD_EXP 89
77770: PUSH
77771: LD_VAR 0 1
77775: ARRAY
77776: PUSH
77777: LD_INT 1
77779: PLUS
77780: PUSH
77781: EMPTY
77782: LIST
77783: LIST
77784: PPUSH
77785: LD_VAR 0 1
77789: PUSH
77790: LD_VAR 0 2
77794: PUSH
77795: LD_VAR 0 3
77799: PUSH
77800: LD_VAR 0 4
77804: PUSH
77805: EMPTY
77806: LIST
77807: LIST
77808: LIST
77809: LIST
77810: PPUSH
77811: CALL 18588 0 3
77815: ST_TO_ADDR
// end ;
77816: LD_VAR 0 5
77820: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
77821: LD_INT 0
77823: PPUSH
// if not mc_bases [ base ] then
77824: LD_EXP 69
77828: PUSH
77829: LD_VAR 0 1
77833: ARRAY
77834: NOT
77835: IFFALSE 77839
// exit ;
77837: GO 77864
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
77839: LD_ADDR_EXP 106
77843: PUSH
77844: LD_EXP 106
77848: PPUSH
77849: LD_VAR 0 1
77853: PPUSH
77854: LD_VAR 0 2
77858: PPUSH
77859: CALL_OW 1
77863: ST_TO_ADDR
// end ;
77864: LD_VAR 0 3
77868: RET
// export function MC_GetMinesField ( base ) ; begin
77869: LD_INT 0
77871: PPUSH
// result := mc_mines [ base ] ;
77872: LD_ADDR_VAR 0 2
77876: PUSH
77877: LD_EXP 82
77881: PUSH
77882: LD_VAR 0 1
77886: ARRAY
77887: ST_TO_ADDR
// end ;
77888: LD_VAR 0 2
77892: RET
// export function MC_GetProduceList ( base ) ; begin
77893: LD_INT 0
77895: PPUSH
// result := mc_produce [ base ] ;
77896: LD_ADDR_VAR 0 2
77900: PUSH
77901: LD_EXP 90
77905: PUSH
77906: LD_VAR 0 1
77910: ARRAY
77911: ST_TO_ADDR
// end ;
77912: LD_VAR 0 2
77916: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
77917: LD_INT 0
77919: PPUSH
77920: PPUSH
// if not mc_bases then
77921: LD_EXP 69
77925: NOT
77926: IFFALSE 77930
// exit ;
77928: GO 77995
// if mc_bases [ base ] then
77930: LD_EXP 69
77934: PUSH
77935: LD_VAR 0 1
77939: ARRAY
77940: IFFALSE 77995
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77942: LD_ADDR_VAR 0 3
77946: PUSH
77947: LD_EXP 69
77951: PUSH
77952: LD_VAR 0 1
77956: ARRAY
77957: PPUSH
77958: LD_INT 30
77960: PUSH
77961: LD_VAR 0 2
77965: PUSH
77966: EMPTY
77967: LIST
77968: LIST
77969: PPUSH
77970: CALL_OW 72
77974: ST_TO_ADDR
// if result then
77975: LD_VAR 0 3
77979: IFFALSE 77995
// result := result [ 1 ] ;
77981: LD_ADDR_VAR 0 3
77985: PUSH
77986: LD_VAR 0 3
77990: PUSH
77991: LD_INT 1
77993: ARRAY
77994: ST_TO_ADDR
// end ; end ;
77995: LD_VAR 0 3
77999: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
78000: LD_INT 0
78002: PPUSH
78003: PPUSH
// if not mc_bases then
78004: LD_EXP 69
78008: NOT
78009: IFFALSE 78013
// exit ;
78011: GO 78058
// if mc_bases [ base ] then
78013: LD_EXP 69
78017: PUSH
78018: LD_VAR 0 1
78022: ARRAY
78023: IFFALSE 78058
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78025: LD_ADDR_VAR 0 3
78029: PUSH
78030: LD_EXP 69
78034: PUSH
78035: LD_VAR 0 1
78039: ARRAY
78040: PPUSH
78041: LD_INT 30
78043: PUSH
78044: LD_VAR 0 2
78048: PUSH
78049: EMPTY
78050: LIST
78051: LIST
78052: PPUSH
78053: CALL_OW 72
78057: ST_TO_ADDR
// end ;
78058: LD_VAR 0 3
78062: RET
// export function MC_SetTame ( base , area ) ; begin
78063: LD_INT 0
78065: PPUSH
// if not mc_bases or not base then
78066: LD_EXP 69
78070: NOT
78071: PUSH
78072: LD_VAR 0 1
78076: NOT
78077: OR
78078: IFFALSE 78082
// exit ;
78080: GO 78107
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
78082: LD_ADDR_EXP 97
78086: PUSH
78087: LD_EXP 97
78091: PPUSH
78092: LD_VAR 0 1
78096: PPUSH
78097: LD_VAR 0 2
78101: PPUSH
78102: CALL_OW 1
78106: ST_TO_ADDR
// end ;
78107: LD_VAR 0 3
78111: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
78112: LD_INT 0
78114: PPUSH
78115: PPUSH
// if not mc_bases or not base then
78116: LD_EXP 69
78120: NOT
78121: PUSH
78122: LD_VAR 0 1
78126: NOT
78127: OR
78128: IFFALSE 78132
// exit ;
78130: GO 78234
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78132: LD_ADDR_VAR 0 4
78136: PUSH
78137: LD_EXP 69
78141: PUSH
78142: LD_VAR 0 1
78146: ARRAY
78147: PPUSH
78148: LD_INT 30
78150: PUSH
78151: LD_VAR 0 2
78155: PUSH
78156: EMPTY
78157: LIST
78158: LIST
78159: PPUSH
78160: CALL_OW 72
78164: ST_TO_ADDR
// if not tmp then
78165: LD_VAR 0 4
78169: NOT
78170: IFFALSE 78174
// exit ;
78172: GO 78234
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
78174: LD_ADDR_EXP 101
78178: PUSH
78179: LD_EXP 101
78183: PPUSH
78184: LD_VAR 0 1
78188: PPUSH
78189: LD_EXP 101
78193: PUSH
78194: LD_VAR 0 1
78198: ARRAY
78199: PPUSH
78200: LD_EXP 101
78204: PUSH
78205: LD_VAR 0 1
78209: ARRAY
78210: PUSH
78211: LD_INT 1
78213: PLUS
78214: PPUSH
78215: LD_VAR 0 4
78219: PUSH
78220: LD_INT 1
78222: ARRAY
78223: PPUSH
78224: CALL_OW 2
78228: PPUSH
78229: CALL_OW 1
78233: ST_TO_ADDR
// end ;
78234: LD_VAR 0 3
78238: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
78239: LD_INT 0
78241: PPUSH
78242: PPUSH
// if not mc_bases or not base or not kinds then
78243: LD_EXP 69
78247: NOT
78248: PUSH
78249: LD_VAR 0 1
78253: NOT
78254: OR
78255: PUSH
78256: LD_VAR 0 2
78260: NOT
78261: OR
78262: IFFALSE 78266
// exit ;
78264: GO 78327
// for i in kinds do
78266: LD_ADDR_VAR 0 4
78270: PUSH
78271: LD_VAR 0 2
78275: PUSH
78276: FOR_IN
78277: IFFALSE 78325
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
78279: LD_ADDR_EXP 103
78283: PUSH
78284: LD_EXP 103
78288: PPUSH
78289: LD_VAR 0 1
78293: PUSH
78294: LD_EXP 103
78298: PUSH
78299: LD_VAR 0 1
78303: ARRAY
78304: PUSH
78305: LD_INT 1
78307: PLUS
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PPUSH
78313: LD_VAR 0 4
78317: PPUSH
78318: CALL 18588 0 3
78322: ST_TO_ADDR
78323: GO 78276
78325: POP
78326: POP
// end ;
78327: LD_VAR 0 3
78331: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
78332: LD_INT 0
78334: PPUSH
// if not mc_bases or not base or not areas then
78335: LD_EXP 69
78339: NOT
78340: PUSH
78341: LD_VAR 0 1
78345: NOT
78346: OR
78347: PUSH
78348: LD_VAR 0 2
78352: NOT
78353: OR
78354: IFFALSE 78358
// exit ;
78356: GO 78383
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
78358: LD_ADDR_EXP 87
78362: PUSH
78363: LD_EXP 87
78367: PPUSH
78368: LD_VAR 0 1
78372: PPUSH
78373: LD_VAR 0 2
78377: PPUSH
78378: CALL_OW 1
78382: ST_TO_ADDR
// end ;
78383: LD_VAR 0 3
78387: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
78388: LD_INT 0
78390: PPUSH
// if not mc_bases or not base or not teleports_exit then
78391: LD_EXP 69
78395: NOT
78396: PUSH
78397: LD_VAR 0 1
78401: NOT
78402: OR
78403: PUSH
78404: LD_VAR 0 2
78408: NOT
78409: OR
78410: IFFALSE 78414
// exit ;
78412: GO 78439
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
78414: LD_ADDR_EXP 104
78418: PUSH
78419: LD_EXP 104
78423: PPUSH
78424: LD_VAR 0 1
78428: PPUSH
78429: LD_VAR 0 2
78433: PPUSH
78434: CALL_OW 1
78438: ST_TO_ADDR
// end ;
78439: LD_VAR 0 3
78443: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
78444: LD_INT 0
78446: PPUSH
78447: PPUSH
78448: PPUSH
// if not mc_bases or not base or not ext_list then
78449: LD_EXP 69
78453: NOT
78454: PUSH
78455: LD_VAR 0 1
78459: NOT
78460: OR
78461: PUSH
78462: LD_VAR 0 5
78466: NOT
78467: OR
78468: IFFALSE 78472
// exit ;
78470: GO 78645
// tmp := GetFacExtXYD ( x , y , d ) ;
78472: LD_ADDR_VAR 0 8
78476: PUSH
78477: LD_VAR 0 2
78481: PPUSH
78482: LD_VAR 0 3
78486: PPUSH
78487: LD_VAR 0 4
78491: PPUSH
78492: CALL 47975 0 3
78496: ST_TO_ADDR
// if not tmp then
78497: LD_VAR 0 8
78501: NOT
78502: IFFALSE 78506
// exit ;
78504: GO 78645
// for i in tmp do
78506: LD_ADDR_VAR 0 7
78510: PUSH
78511: LD_VAR 0 8
78515: PUSH
78516: FOR_IN
78517: IFFALSE 78643
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
78519: LD_ADDR_EXP 74
78523: PUSH
78524: LD_EXP 74
78528: PPUSH
78529: LD_VAR 0 1
78533: PPUSH
78534: LD_EXP 74
78538: PUSH
78539: LD_VAR 0 1
78543: ARRAY
78544: PPUSH
78545: LD_EXP 74
78549: PUSH
78550: LD_VAR 0 1
78554: ARRAY
78555: PUSH
78556: LD_INT 1
78558: PLUS
78559: PPUSH
78560: LD_VAR 0 5
78564: PUSH
78565: LD_INT 1
78567: ARRAY
78568: PUSH
78569: LD_VAR 0 7
78573: PUSH
78574: LD_INT 1
78576: ARRAY
78577: PUSH
78578: LD_VAR 0 7
78582: PUSH
78583: LD_INT 2
78585: ARRAY
78586: PUSH
78587: LD_VAR 0 7
78591: PUSH
78592: LD_INT 3
78594: ARRAY
78595: PUSH
78596: EMPTY
78597: LIST
78598: LIST
78599: LIST
78600: LIST
78601: PPUSH
78602: CALL_OW 2
78606: PPUSH
78607: CALL_OW 1
78611: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
78612: LD_ADDR_VAR 0 5
78616: PUSH
78617: LD_VAR 0 5
78621: PPUSH
78622: LD_INT 1
78624: PPUSH
78625: CALL_OW 3
78629: ST_TO_ADDR
// if not ext_list then
78630: LD_VAR 0 5
78634: NOT
78635: IFFALSE 78641
// exit ;
78637: POP
78638: POP
78639: GO 78645
// end ;
78641: GO 78516
78643: POP
78644: POP
// end ;
78645: LD_VAR 0 6
78649: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
78650: LD_INT 0
78652: PPUSH
// if not mc_bases or not base or not weapon_list then
78653: LD_EXP 69
78657: NOT
78658: PUSH
78659: LD_VAR 0 1
78663: NOT
78664: OR
78665: PUSH
78666: LD_VAR 0 2
78670: NOT
78671: OR
78672: IFFALSE 78676
// exit ;
78674: GO 78701
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
78676: LD_ADDR_EXP 108
78680: PUSH
78681: LD_EXP 108
78685: PPUSH
78686: LD_VAR 0 1
78690: PPUSH
78691: LD_VAR 0 2
78695: PPUSH
78696: CALL_OW 1
78700: ST_TO_ADDR
// end ;
78701: LD_VAR 0 3
78705: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
78706: LD_INT 0
78708: PPUSH
// if not mc_bases or not base or not tech_list then
78709: LD_EXP 69
78713: NOT
78714: PUSH
78715: LD_VAR 0 1
78719: NOT
78720: OR
78721: PUSH
78722: LD_VAR 0 2
78726: NOT
78727: OR
78728: IFFALSE 78732
// exit ;
78730: GO 78757
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
78732: LD_ADDR_EXP 96
78736: PUSH
78737: LD_EXP 96
78741: PPUSH
78742: LD_VAR 0 1
78746: PPUSH
78747: LD_VAR 0 2
78751: PPUSH
78752: CALL_OW 1
78756: ST_TO_ADDR
// end ;
78757: LD_VAR 0 3
78761: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
78762: LD_INT 0
78764: PPUSH
// if not mc_bases or not parking_area or not base then
78765: LD_EXP 69
78769: NOT
78770: PUSH
78771: LD_VAR 0 2
78775: NOT
78776: OR
78777: PUSH
78778: LD_VAR 0 1
78782: NOT
78783: OR
78784: IFFALSE 78788
// exit ;
78786: GO 78813
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
78788: LD_ADDR_EXP 93
78792: PUSH
78793: LD_EXP 93
78797: PPUSH
78798: LD_VAR 0 1
78802: PPUSH
78803: LD_VAR 0 2
78807: PPUSH
78808: CALL_OW 1
78812: ST_TO_ADDR
// end ;
78813: LD_VAR 0 3
78817: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
78818: LD_INT 0
78820: PPUSH
// if not mc_bases or not base or not scan_area then
78821: LD_EXP 69
78825: NOT
78826: PUSH
78827: LD_VAR 0 1
78831: NOT
78832: OR
78833: PUSH
78834: LD_VAR 0 2
78838: NOT
78839: OR
78840: IFFALSE 78844
// exit ;
78842: GO 78869
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
78844: LD_ADDR_EXP 94
78848: PUSH
78849: LD_EXP 94
78853: PPUSH
78854: LD_VAR 0 1
78858: PPUSH
78859: LD_VAR 0 2
78863: PPUSH
78864: CALL_OW 1
78868: ST_TO_ADDR
// end ;
78869: LD_VAR 0 3
78873: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
78874: LD_INT 0
78876: PPUSH
78877: PPUSH
// if not mc_bases or not base then
78878: LD_EXP 69
78882: NOT
78883: PUSH
78884: LD_VAR 0 1
78888: NOT
78889: OR
78890: IFFALSE 78894
// exit ;
78892: GO 78958
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
78894: LD_ADDR_VAR 0 3
78898: PUSH
78899: LD_INT 1
78901: PUSH
78902: LD_INT 2
78904: PUSH
78905: LD_INT 3
78907: PUSH
78908: LD_INT 4
78910: PUSH
78911: LD_INT 11
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: LIST
78918: LIST
78919: LIST
78920: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
78921: LD_ADDR_EXP 96
78925: PUSH
78926: LD_EXP 96
78930: PPUSH
78931: LD_VAR 0 1
78935: PPUSH
78936: LD_EXP 96
78940: PUSH
78941: LD_VAR 0 1
78945: ARRAY
78946: PUSH
78947: LD_VAR 0 3
78951: DIFF
78952: PPUSH
78953: CALL_OW 1
78957: ST_TO_ADDR
// end ;
78958: LD_VAR 0 2
78962: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
78963: LD_INT 0
78965: PPUSH
// result := mc_vehicles [ base ] ;
78966: LD_ADDR_VAR 0 3
78970: PUSH
78971: LD_EXP 88
78975: PUSH
78976: LD_VAR 0 1
78980: ARRAY
78981: ST_TO_ADDR
// if onlyCombat then
78982: LD_VAR 0 2
78986: IFFALSE 79164
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
78988: LD_ADDR_VAR 0 3
78992: PUSH
78993: LD_VAR 0 3
78997: PUSH
78998: LD_VAR 0 3
79002: PPUSH
79003: LD_INT 2
79005: PUSH
79006: LD_INT 34
79008: PUSH
79009: LD_INT 12
79011: PUSH
79012: EMPTY
79013: LIST
79014: LIST
79015: PUSH
79016: LD_INT 34
79018: PUSH
79019: LD_INT 51
79021: PUSH
79022: EMPTY
79023: LIST
79024: LIST
79025: PUSH
79026: LD_INT 34
79028: PUSH
79029: LD_EXP 49
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 34
79040: PUSH
79041: LD_INT 32
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 34
79050: PUSH
79051: LD_INT 13
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 34
79060: PUSH
79061: LD_INT 52
79063: PUSH
79064: EMPTY
79065: LIST
79066: LIST
79067: PUSH
79068: LD_INT 34
79070: PUSH
79071: LD_EXP 54
79075: PUSH
79076: EMPTY
79077: LIST
79078: LIST
79079: PUSH
79080: LD_INT 34
79082: PUSH
79083: LD_INT 14
79085: PUSH
79086: EMPTY
79087: LIST
79088: LIST
79089: PUSH
79090: LD_INT 34
79092: PUSH
79093: LD_INT 53
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: LD_INT 34
79102: PUSH
79103: LD_EXP 48
79107: PUSH
79108: EMPTY
79109: LIST
79110: LIST
79111: PUSH
79112: LD_INT 34
79114: PUSH
79115: LD_INT 31
79117: PUSH
79118: EMPTY
79119: LIST
79120: LIST
79121: PUSH
79122: LD_INT 34
79124: PUSH
79125: LD_INT 48
79127: PUSH
79128: EMPTY
79129: LIST
79130: LIST
79131: PUSH
79132: LD_INT 34
79134: PUSH
79135: LD_INT 8
79137: PUSH
79138: EMPTY
79139: LIST
79140: LIST
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: LIST
79146: LIST
79147: LIST
79148: LIST
79149: LIST
79150: LIST
79151: LIST
79152: LIST
79153: LIST
79154: LIST
79155: LIST
79156: LIST
79157: PPUSH
79158: CALL_OW 72
79162: DIFF
79163: ST_TO_ADDR
// end ; end_of_file
79164: LD_VAR 0 3
79168: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
79169: LD_INT 0
79171: PPUSH
79172: PPUSH
79173: PPUSH
// if not mc_bases or not skirmish then
79174: LD_EXP 69
79178: NOT
79179: PUSH
79180: LD_EXP 67
79184: NOT
79185: OR
79186: IFFALSE 79190
// exit ;
79188: GO 79355
// for i = 1 to mc_bases do
79190: LD_ADDR_VAR 0 4
79194: PUSH
79195: DOUBLE
79196: LD_INT 1
79198: DEC
79199: ST_TO_ADDR
79200: LD_EXP 69
79204: PUSH
79205: FOR_TO
79206: IFFALSE 79353
// begin if sci in mc_bases [ i ] then
79208: LD_VAR 0 2
79212: PUSH
79213: LD_EXP 69
79217: PUSH
79218: LD_VAR 0 4
79222: ARRAY
79223: IN
79224: IFFALSE 79351
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
79226: LD_ADDR_EXP 98
79230: PUSH
79231: LD_EXP 98
79235: PPUSH
79236: LD_VAR 0 4
79240: PUSH
79241: LD_EXP 98
79245: PUSH
79246: LD_VAR 0 4
79250: ARRAY
79251: PUSH
79252: LD_INT 1
79254: PLUS
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PPUSH
79260: LD_VAR 0 1
79264: PPUSH
79265: CALL 18588 0 3
79269: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
79270: LD_ADDR_VAR 0 5
79274: PUSH
79275: LD_EXP 69
79279: PUSH
79280: LD_VAR 0 4
79284: ARRAY
79285: PPUSH
79286: LD_INT 2
79288: PUSH
79289: LD_INT 30
79291: PUSH
79292: LD_INT 0
79294: PUSH
79295: EMPTY
79296: LIST
79297: LIST
79298: PUSH
79299: LD_INT 30
79301: PUSH
79302: LD_INT 1
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: LIST
79313: PPUSH
79314: CALL_OW 72
79318: PPUSH
79319: LD_VAR 0 1
79323: PPUSH
79324: CALL_OW 74
79328: ST_TO_ADDR
// if tmp then
79329: LD_VAR 0 5
79333: IFFALSE 79349
// ComStandNearbyBuilding ( ape , tmp ) ;
79335: LD_VAR 0 1
79339: PPUSH
79340: LD_VAR 0 5
79344: PPUSH
79345: CALL 15166 0 2
// break ;
79349: GO 79353
// end ; end ;
79351: GO 79205
79353: POP
79354: POP
// end ;
79355: LD_VAR 0 3
79359: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
79360: LD_INT 0
79362: PPUSH
79363: PPUSH
79364: PPUSH
// if not mc_bases or not skirmish then
79365: LD_EXP 69
79369: NOT
79370: PUSH
79371: LD_EXP 67
79375: NOT
79376: OR
79377: IFFALSE 79381
// exit ;
79379: GO 79470
// for i = 1 to mc_bases do
79381: LD_ADDR_VAR 0 4
79385: PUSH
79386: DOUBLE
79387: LD_INT 1
79389: DEC
79390: ST_TO_ADDR
79391: LD_EXP 69
79395: PUSH
79396: FOR_TO
79397: IFFALSE 79468
// begin if building in mc_busy_turret_list [ i ] then
79399: LD_VAR 0 1
79403: PUSH
79404: LD_EXP 79
79408: PUSH
79409: LD_VAR 0 4
79413: ARRAY
79414: IN
79415: IFFALSE 79466
// begin tmp := mc_busy_turret_list [ i ] diff building ;
79417: LD_ADDR_VAR 0 5
79421: PUSH
79422: LD_EXP 79
79426: PUSH
79427: LD_VAR 0 4
79431: ARRAY
79432: PUSH
79433: LD_VAR 0 1
79437: DIFF
79438: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
79439: LD_ADDR_EXP 79
79443: PUSH
79444: LD_EXP 79
79448: PPUSH
79449: LD_VAR 0 4
79453: PPUSH
79454: LD_VAR 0 5
79458: PPUSH
79459: CALL_OW 1
79463: ST_TO_ADDR
// break ;
79464: GO 79468
// end ; end ;
79466: GO 79396
79468: POP
79469: POP
// end ;
79470: LD_VAR 0 3
79474: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
79475: LD_INT 0
79477: PPUSH
79478: PPUSH
79479: PPUSH
// if not mc_bases or not skirmish then
79480: LD_EXP 69
79484: NOT
79485: PUSH
79486: LD_EXP 67
79490: NOT
79491: OR
79492: IFFALSE 79496
// exit ;
79494: GO 79695
// for i = 1 to mc_bases do
79496: LD_ADDR_VAR 0 5
79500: PUSH
79501: DOUBLE
79502: LD_INT 1
79504: DEC
79505: ST_TO_ADDR
79506: LD_EXP 69
79510: PUSH
79511: FOR_TO
79512: IFFALSE 79693
// if building in mc_bases [ i ] then
79514: LD_VAR 0 1
79518: PUSH
79519: LD_EXP 69
79523: PUSH
79524: LD_VAR 0 5
79528: ARRAY
79529: IN
79530: IFFALSE 79691
// begin tmp := mc_bases [ i ] diff building ;
79532: LD_ADDR_VAR 0 6
79536: PUSH
79537: LD_EXP 69
79541: PUSH
79542: LD_VAR 0 5
79546: ARRAY
79547: PUSH
79548: LD_VAR 0 1
79552: DIFF
79553: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
79554: LD_ADDR_EXP 69
79558: PUSH
79559: LD_EXP 69
79563: PPUSH
79564: LD_VAR 0 5
79568: PPUSH
79569: LD_VAR 0 6
79573: PPUSH
79574: CALL_OW 1
79578: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
79579: LD_VAR 0 1
79583: PUSH
79584: LD_EXP 77
79588: PUSH
79589: LD_VAR 0 5
79593: ARRAY
79594: IN
79595: IFFALSE 79634
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
79597: LD_ADDR_EXP 77
79601: PUSH
79602: LD_EXP 77
79606: PPUSH
79607: LD_VAR 0 5
79611: PPUSH
79612: LD_EXP 77
79616: PUSH
79617: LD_VAR 0 5
79621: ARRAY
79622: PUSH
79623: LD_VAR 0 1
79627: DIFF
79628: PPUSH
79629: CALL_OW 1
79633: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
79634: LD_VAR 0 1
79638: PUSH
79639: LD_EXP 78
79643: PUSH
79644: LD_VAR 0 5
79648: ARRAY
79649: IN
79650: IFFALSE 79689
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
79652: LD_ADDR_EXP 78
79656: PUSH
79657: LD_EXP 78
79661: PPUSH
79662: LD_VAR 0 5
79666: PPUSH
79667: LD_EXP 78
79671: PUSH
79672: LD_VAR 0 5
79676: ARRAY
79677: PUSH
79678: LD_VAR 0 1
79682: DIFF
79683: PPUSH
79684: CALL_OW 1
79688: ST_TO_ADDR
// break ;
79689: GO 79693
// end ;
79691: GO 79511
79693: POP
79694: POP
// end ;
79695: LD_VAR 0 4
79699: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
79700: LD_INT 0
79702: PPUSH
79703: PPUSH
79704: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
79705: LD_EXP 69
79709: NOT
79710: PUSH
79711: LD_EXP 67
79715: NOT
79716: OR
79717: PUSH
79718: LD_VAR 0 3
79722: PUSH
79723: LD_EXP 95
79727: IN
79728: NOT
79729: OR
79730: IFFALSE 79734
// exit ;
79732: GO 79857
// for i = 1 to mc_vehicles do
79734: LD_ADDR_VAR 0 6
79738: PUSH
79739: DOUBLE
79740: LD_INT 1
79742: DEC
79743: ST_TO_ADDR
79744: LD_EXP 88
79748: PUSH
79749: FOR_TO
79750: IFFALSE 79855
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
79752: LD_VAR 0 2
79756: PUSH
79757: LD_EXP 88
79761: PUSH
79762: LD_VAR 0 6
79766: ARRAY
79767: IN
79768: PUSH
79769: LD_VAR 0 1
79773: PUSH
79774: LD_EXP 88
79778: PUSH
79779: LD_VAR 0 6
79783: ARRAY
79784: IN
79785: OR
79786: IFFALSE 79853
// begin tmp := mc_vehicles [ i ] diff old ;
79788: LD_ADDR_VAR 0 7
79792: PUSH
79793: LD_EXP 88
79797: PUSH
79798: LD_VAR 0 6
79802: ARRAY
79803: PUSH
79804: LD_VAR 0 2
79808: DIFF
79809: ST_TO_ADDR
// tmp := tmp diff new ;
79810: LD_ADDR_VAR 0 7
79814: PUSH
79815: LD_VAR 0 7
79819: PUSH
79820: LD_VAR 0 1
79824: DIFF
79825: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
79826: LD_ADDR_EXP 88
79830: PUSH
79831: LD_EXP 88
79835: PPUSH
79836: LD_VAR 0 6
79840: PPUSH
79841: LD_VAR 0 7
79845: PPUSH
79846: CALL_OW 1
79850: ST_TO_ADDR
// break ;
79851: GO 79855
// end ;
79853: GO 79749
79855: POP
79856: POP
// end ;
79857: LD_VAR 0 5
79861: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
79862: LD_INT 0
79864: PPUSH
79865: PPUSH
79866: PPUSH
79867: PPUSH
// if not mc_bases or not skirmish then
79868: LD_EXP 69
79872: NOT
79873: PUSH
79874: LD_EXP 67
79878: NOT
79879: OR
79880: IFFALSE 79884
// exit ;
79882: GO 80276
// side := GetSide ( vehicle ) ;
79884: LD_ADDR_VAR 0 5
79888: PUSH
79889: LD_VAR 0 1
79893: PPUSH
79894: CALL_OW 255
79898: ST_TO_ADDR
// for i = 1 to mc_bases do
79899: LD_ADDR_VAR 0 4
79903: PUSH
79904: DOUBLE
79905: LD_INT 1
79907: DEC
79908: ST_TO_ADDR
79909: LD_EXP 69
79913: PUSH
79914: FOR_TO
79915: IFFALSE 80274
// begin if factory in mc_bases [ i ] then
79917: LD_VAR 0 2
79921: PUSH
79922: LD_EXP 69
79926: PUSH
79927: LD_VAR 0 4
79931: ARRAY
79932: IN
79933: IFFALSE 80272
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
79935: LD_EXP 91
79939: PUSH
79940: LD_VAR 0 4
79944: ARRAY
79945: PUSH
79946: LD_EXP 80
79950: PUSH
79951: LD_VAR 0 4
79955: ARRAY
79956: LESS
79957: PUSH
79958: LD_VAR 0 1
79962: PPUSH
79963: CALL_OW 264
79967: PUSH
79968: LD_INT 31
79970: PUSH
79971: LD_INT 32
79973: PUSH
79974: LD_INT 51
79976: PUSH
79977: LD_EXP 49
79981: PUSH
79982: LD_INT 12
79984: PUSH
79985: LD_INT 30
79987: PUSH
79988: LD_EXP 48
79992: PUSH
79993: LD_INT 11
79995: PUSH
79996: LD_INT 53
79998: PUSH
79999: LD_INT 14
80001: PUSH
80002: LD_EXP 52
80006: PUSH
80007: LD_INT 29
80009: PUSH
80010: LD_EXP 50
80014: PUSH
80015: LD_INT 13
80017: PUSH
80018: LD_INT 52
80020: PUSH
80021: LD_EXP 54
80025: PUSH
80026: LD_INT 48
80028: PUSH
80029: LD_INT 8
80031: PUSH
80032: EMPTY
80033: LIST
80034: LIST
80035: LIST
80036: LIST
80037: LIST
80038: LIST
80039: LIST
80040: LIST
80041: LIST
80042: LIST
80043: LIST
80044: LIST
80045: LIST
80046: LIST
80047: LIST
80048: LIST
80049: LIST
80050: LIST
80051: IN
80052: NOT
80053: AND
80054: IFFALSE 80102
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
80056: LD_ADDR_EXP 91
80060: PUSH
80061: LD_EXP 91
80065: PPUSH
80066: LD_VAR 0 4
80070: PUSH
80071: LD_EXP 91
80075: PUSH
80076: LD_VAR 0 4
80080: ARRAY
80081: PUSH
80082: LD_INT 1
80084: PLUS
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PPUSH
80090: LD_VAR 0 1
80094: PPUSH
80095: CALL 18588 0 3
80099: ST_TO_ADDR
80100: GO 80146
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
80102: LD_ADDR_EXP 88
80106: PUSH
80107: LD_EXP 88
80111: PPUSH
80112: LD_VAR 0 4
80116: PUSH
80117: LD_EXP 88
80121: PUSH
80122: LD_VAR 0 4
80126: ARRAY
80127: PUSH
80128: LD_INT 1
80130: PLUS
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PPUSH
80136: LD_VAR 0 1
80140: PPUSH
80141: CALL 18588 0 3
80145: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
80146: LD_VAR 0 1
80150: PPUSH
80151: CALL_OW 263
80155: PUSH
80156: LD_INT 2
80158: EQUAL
80159: IFFALSE 80188
// begin repeat wait ( 0 0$3 ) ;
80161: LD_INT 105
80163: PPUSH
80164: CALL_OW 67
// Connect ( vehicle ) ;
80168: LD_VAR 0 1
80172: PPUSH
80173: CALL 21559 0 1
// until IsControledBy ( vehicle ) ;
80177: LD_VAR 0 1
80181: PPUSH
80182: CALL_OW 312
80186: IFFALSE 80161
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
80188: LD_VAR 0 1
80192: PPUSH
80193: LD_EXP 93
80197: PUSH
80198: LD_VAR 0 4
80202: ARRAY
80203: PPUSH
80204: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
80208: LD_VAR 0 1
80212: PPUSH
80213: CALL_OW 263
80217: PUSH
80218: LD_INT 1
80220: NONEQUAL
80221: IFFALSE 80225
// break ;
80223: GO 80274
// repeat wait ( 0 0$1 ) ;
80225: LD_INT 35
80227: PPUSH
80228: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
80232: LD_VAR 0 1
80236: PPUSH
80237: LD_EXP 93
80241: PUSH
80242: LD_VAR 0 4
80246: ARRAY
80247: PPUSH
80248: CALL_OW 308
80252: IFFALSE 80225
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
80254: LD_VAR 0 1
80258: PPUSH
80259: CALL_OW 311
80263: PPUSH
80264: CALL_OW 121
// exit ;
80268: POP
80269: POP
80270: GO 80276
// end ; end ;
80272: GO 79914
80274: POP
80275: POP
// end ;
80276: LD_VAR 0 3
80280: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
80281: LD_INT 0
80283: PPUSH
80284: PPUSH
80285: PPUSH
80286: PPUSH
// if not mc_bases or not skirmish then
80287: LD_EXP 69
80291: NOT
80292: PUSH
80293: LD_EXP 67
80297: NOT
80298: OR
80299: IFFALSE 80303
// exit ;
80301: GO 80656
// repeat wait ( 0 0$1 ) ;
80303: LD_INT 35
80305: PPUSH
80306: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
80310: LD_VAR 0 2
80314: PPUSH
80315: LD_VAR 0 3
80319: PPUSH
80320: CALL_OW 284
80324: IFFALSE 80303
// if GetResourceTypeXY ( x , y ) = mat_artefact then
80326: LD_VAR 0 2
80330: PPUSH
80331: LD_VAR 0 3
80335: PPUSH
80336: CALL_OW 283
80340: PUSH
80341: LD_INT 4
80343: EQUAL
80344: IFFALSE 80348
// exit ;
80346: GO 80656
// for i = 1 to mc_bases do
80348: LD_ADDR_VAR 0 7
80352: PUSH
80353: DOUBLE
80354: LD_INT 1
80356: DEC
80357: ST_TO_ADDR
80358: LD_EXP 69
80362: PUSH
80363: FOR_TO
80364: IFFALSE 80654
// begin if mc_crates_area [ i ] then
80366: LD_EXP 87
80370: PUSH
80371: LD_VAR 0 7
80375: ARRAY
80376: IFFALSE 80487
// for j in mc_crates_area [ i ] do
80378: LD_ADDR_VAR 0 8
80382: PUSH
80383: LD_EXP 87
80387: PUSH
80388: LD_VAR 0 7
80392: ARRAY
80393: PUSH
80394: FOR_IN
80395: IFFALSE 80485
// if InArea ( x , y , j ) then
80397: LD_VAR 0 2
80401: PPUSH
80402: LD_VAR 0 3
80406: PPUSH
80407: LD_VAR 0 8
80411: PPUSH
80412: CALL_OW 309
80416: IFFALSE 80483
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80418: LD_ADDR_EXP 85
80422: PUSH
80423: LD_EXP 85
80427: PPUSH
80428: LD_VAR 0 7
80432: PUSH
80433: LD_EXP 85
80437: PUSH
80438: LD_VAR 0 7
80442: ARRAY
80443: PUSH
80444: LD_INT 1
80446: PLUS
80447: PUSH
80448: EMPTY
80449: LIST
80450: LIST
80451: PPUSH
80452: LD_VAR 0 4
80456: PUSH
80457: LD_VAR 0 2
80461: PUSH
80462: LD_VAR 0 3
80466: PUSH
80467: EMPTY
80468: LIST
80469: LIST
80470: LIST
80471: PPUSH
80472: CALL 18588 0 3
80476: ST_TO_ADDR
// exit ;
80477: POP
80478: POP
80479: POP
80480: POP
80481: GO 80656
// end ;
80483: GO 80394
80485: POP
80486: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80487: LD_ADDR_VAR 0 9
80491: PUSH
80492: LD_EXP 69
80496: PUSH
80497: LD_VAR 0 7
80501: ARRAY
80502: PPUSH
80503: LD_INT 2
80505: PUSH
80506: LD_INT 30
80508: PUSH
80509: LD_INT 0
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: LD_INT 30
80518: PUSH
80519: LD_INT 1
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: LIST
80530: PPUSH
80531: CALL_OW 72
80535: ST_TO_ADDR
// if not depot then
80536: LD_VAR 0 9
80540: NOT
80541: IFFALSE 80545
// continue ;
80543: GO 80363
// for j in depot do
80545: LD_ADDR_VAR 0 8
80549: PUSH
80550: LD_VAR 0 9
80554: PUSH
80555: FOR_IN
80556: IFFALSE 80650
// if GetDistUnitXY ( j , x , y ) < 30 then
80558: LD_VAR 0 8
80562: PPUSH
80563: LD_VAR 0 2
80567: PPUSH
80568: LD_VAR 0 3
80572: PPUSH
80573: CALL_OW 297
80577: PUSH
80578: LD_INT 30
80580: LESS
80581: IFFALSE 80648
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80583: LD_ADDR_EXP 85
80587: PUSH
80588: LD_EXP 85
80592: PPUSH
80593: LD_VAR 0 7
80597: PUSH
80598: LD_EXP 85
80602: PUSH
80603: LD_VAR 0 7
80607: ARRAY
80608: PUSH
80609: LD_INT 1
80611: PLUS
80612: PUSH
80613: EMPTY
80614: LIST
80615: LIST
80616: PPUSH
80617: LD_VAR 0 4
80621: PUSH
80622: LD_VAR 0 2
80626: PUSH
80627: LD_VAR 0 3
80631: PUSH
80632: EMPTY
80633: LIST
80634: LIST
80635: LIST
80636: PPUSH
80637: CALL 18588 0 3
80641: ST_TO_ADDR
// exit ;
80642: POP
80643: POP
80644: POP
80645: POP
80646: GO 80656
// end ;
80648: GO 80555
80650: POP
80651: POP
// end ;
80652: GO 80363
80654: POP
80655: POP
// end ;
80656: LD_VAR 0 6
80660: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
80661: LD_INT 0
80663: PPUSH
80664: PPUSH
80665: PPUSH
80666: PPUSH
// if not mc_bases or not skirmish then
80667: LD_EXP 69
80671: NOT
80672: PUSH
80673: LD_EXP 67
80677: NOT
80678: OR
80679: IFFALSE 80683
// exit ;
80681: GO 80960
// side := GetSide ( lab ) ;
80683: LD_ADDR_VAR 0 4
80687: PUSH
80688: LD_VAR 0 2
80692: PPUSH
80693: CALL_OW 255
80697: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
80698: LD_VAR 0 4
80702: PUSH
80703: LD_EXP 95
80707: IN
80708: NOT
80709: PUSH
80710: LD_EXP 96
80714: NOT
80715: OR
80716: PUSH
80717: LD_EXP 69
80721: NOT
80722: OR
80723: IFFALSE 80727
// exit ;
80725: GO 80960
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
80727: LD_ADDR_EXP 96
80731: PUSH
80732: LD_EXP 96
80736: PPUSH
80737: LD_VAR 0 4
80741: PPUSH
80742: LD_EXP 96
80746: PUSH
80747: LD_VAR 0 4
80751: ARRAY
80752: PUSH
80753: LD_VAR 0 1
80757: DIFF
80758: PPUSH
80759: CALL_OW 1
80763: ST_TO_ADDR
// for i = 1 to mc_bases do
80764: LD_ADDR_VAR 0 5
80768: PUSH
80769: DOUBLE
80770: LD_INT 1
80772: DEC
80773: ST_TO_ADDR
80774: LD_EXP 69
80778: PUSH
80779: FOR_TO
80780: IFFALSE 80958
// begin if lab in mc_bases [ i ] then
80782: LD_VAR 0 2
80786: PUSH
80787: LD_EXP 69
80791: PUSH
80792: LD_VAR 0 5
80796: ARRAY
80797: IN
80798: IFFALSE 80956
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
80800: LD_VAR 0 1
80804: PUSH
80805: LD_INT 11
80807: PUSH
80808: LD_INT 4
80810: PUSH
80811: LD_INT 3
80813: PUSH
80814: LD_INT 2
80816: PUSH
80817: EMPTY
80818: LIST
80819: LIST
80820: LIST
80821: LIST
80822: IN
80823: PUSH
80824: LD_EXP 99
80828: PUSH
80829: LD_VAR 0 5
80833: ARRAY
80834: AND
80835: IFFALSE 80956
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
80837: LD_ADDR_VAR 0 6
80841: PUSH
80842: LD_EXP 99
80846: PUSH
80847: LD_VAR 0 5
80851: ARRAY
80852: PUSH
80853: LD_INT 1
80855: ARRAY
80856: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80857: LD_ADDR_EXP 99
80861: PUSH
80862: LD_EXP 99
80866: PPUSH
80867: LD_VAR 0 5
80871: PPUSH
80872: EMPTY
80873: PPUSH
80874: CALL_OW 1
80878: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
80879: LD_VAR 0 6
80883: PPUSH
80884: LD_INT 0
80886: PPUSH
80887: CALL_OW 109
// ComExitBuilding ( tmp ) ;
80891: LD_VAR 0 6
80895: PPUSH
80896: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
80900: LD_ADDR_EXP 98
80904: PUSH
80905: LD_EXP 98
80909: PPUSH
80910: LD_VAR 0 5
80914: PPUSH
80915: LD_EXP 98
80919: PUSH
80920: LD_VAR 0 5
80924: ARRAY
80925: PPUSH
80926: LD_INT 1
80928: PPUSH
80929: LD_VAR 0 6
80933: PPUSH
80934: CALL_OW 2
80938: PPUSH
80939: CALL_OW 1
80943: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
80944: LD_VAR 0 5
80948: PPUSH
80949: LD_INT 112
80951: PPUSH
80952: CALL 57479 0 2
// end ; end ; end ;
80956: GO 80779
80958: POP
80959: POP
// end ;
80960: LD_VAR 0 3
80964: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
80965: LD_INT 0
80967: PPUSH
80968: PPUSH
80969: PPUSH
80970: PPUSH
80971: PPUSH
80972: PPUSH
80973: PPUSH
80974: PPUSH
// if not mc_bases or not skirmish then
80975: LD_EXP 69
80979: NOT
80980: PUSH
80981: LD_EXP 67
80985: NOT
80986: OR
80987: IFFALSE 80991
// exit ;
80989: GO 82362
// for i = 1 to mc_bases do
80991: LD_ADDR_VAR 0 3
80995: PUSH
80996: DOUBLE
80997: LD_INT 1
80999: DEC
81000: ST_TO_ADDR
81001: LD_EXP 69
81005: PUSH
81006: FOR_TO
81007: IFFALSE 82360
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
81009: LD_VAR 0 1
81013: PUSH
81014: LD_EXP 69
81018: PUSH
81019: LD_VAR 0 3
81023: ARRAY
81024: IN
81025: PUSH
81026: LD_VAR 0 1
81030: PUSH
81031: LD_EXP 76
81035: PUSH
81036: LD_VAR 0 3
81040: ARRAY
81041: IN
81042: OR
81043: PUSH
81044: LD_VAR 0 1
81048: PUSH
81049: LD_EXP 91
81053: PUSH
81054: LD_VAR 0 3
81058: ARRAY
81059: IN
81060: OR
81061: PUSH
81062: LD_VAR 0 1
81066: PUSH
81067: LD_EXP 88
81071: PUSH
81072: LD_VAR 0 3
81076: ARRAY
81077: IN
81078: OR
81079: PUSH
81080: LD_VAR 0 1
81084: PUSH
81085: LD_EXP 98
81089: PUSH
81090: LD_VAR 0 3
81094: ARRAY
81095: IN
81096: OR
81097: PUSH
81098: LD_VAR 0 1
81102: PUSH
81103: LD_EXP 99
81107: PUSH
81108: LD_VAR 0 3
81112: ARRAY
81113: IN
81114: OR
81115: IFFALSE 82358
// begin if un in mc_ape [ i ] then
81117: LD_VAR 0 1
81121: PUSH
81122: LD_EXP 98
81126: PUSH
81127: LD_VAR 0 3
81131: ARRAY
81132: IN
81133: IFFALSE 81172
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
81135: LD_ADDR_EXP 98
81139: PUSH
81140: LD_EXP 98
81144: PPUSH
81145: LD_VAR 0 3
81149: PPUSH
81150: LD_EXP 98
81154: PUSH
81155: LD_VAR 0 3
81159: ARRAY
81160: PUSH
81161: LD_VAR 0 1
81165: DIFF
81166: PPUSH
81167: CALL_OW 1
81171: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
81172: LD_VAR 0 1
81176: PUSH
81177: LD_EXP 99
81181: PUSH
81182: LD_VAR 0 3
81186: ARRAY
81187: IN
81188: IFFALSE 81212
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81190: LD_ADDR_EXP 99
81194: PUSH
81195: LD_EXP 99
81199: PPUSH
81200: LD_VAR 0 3
81204: PPUSH
81205: EMPTY
81206: PPUSH
81207: CALL_OW 1
81211: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
81212: LD_VAR 0 1
81216: PPUSH
81217: CALL_OW 247
81221: PUSH
81222: LD_INT 2
81224: EQUAL
81225: PUSH
81226: LD_VAR 0 1
81230: PPUSH
81231: CALL_OW 110
81235: PUSH
81236: LD_INT 20
81238: EQUAL
81239: PUSH
81240: LD_VAR 0 1
81244: PUSH
81245: LD_EXP 91
81249: PUSH
81250: LD_VAR 0 3
81254: ARRAY
81255: IN
81256: OR
81257: PUSH
81258: LD_VAR 0 1
81262: PPUSH
81263: CALL_OW 264
81267: PUSH
81268: LD_INT 12
81270: PUSH
81271: LD_INT 51
81273: PUSH
81274: LD_EXP 49
81278: PUSH
81279: LD_INT 32
81281: PUSH
81282: LD_INT 13
81284: PUSH
81285: LD_INT 52
81287: PUSH
81288: LD_INT 31
81290: PUSH
81291: EMPTY
81292: LIST
81293: LIST
81294: LIST
81295: LIST
81296: LIST
81297: LIST
81298: LIST
81299: IN
81300: OR
81301: AND
81302: IFFALSE 81610
// begin if un in mc_defender [ i ] then
81304: LD_VAR 0 1
81308: PUSH
81309: LD_EXP 91
81313: PUSH
81314: LD_VAR 0 3
81318: ARRAY
81319: IN
81320: IFFALSE 81359
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81322: LD_ADDR_EXP 91
81326: PUSH
81327: LD_EXP 91
81331: PPUSH
81332: LD_VAR 0 3
81336: PPUSH
81337: LD_EXP 91
81341: PUSH
81342: LD_VAR 0 3
81346: ARRAY
81347: PUSH
81348: LD_VAR 0 1
81352: DIFF
81353: PPUSH
81354: CALL_OW 1
81358: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
81359: LD_ADDR_VAR 0 8
81363: PUSH
81364: LD_VAR 0 3
81368: PPUSH
81369: LD_INT 3
81371: PPUSH
81372: CALL 78000 0 2
81376: ST_TO_ADDR
// if fac then
81377: LD_VAR 0 8
81381: IFFALSE 81610
// begin for j in fac do
81383: LD_ADDR_VAR 0 4
81387: PUSH
81388: LD_VAR 0 8
81392: PUSH
81393: FOR_IN
81394: IFFALSE 81608
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
81396: LD_ADDR_VAR 0 9
81400: PUSH
81401: LD_VAR 0 8
81405: PPUSH
81406: LD_VAR 0 1
81410: PPUSH
81411: CALL_OW 265
81415: PPUSH
81416: LD_VAR 0 1
81420: PPUSH
81421: CALL_OW 262
81425: PPUSH
81426: LD_VAR 0 1
81430: PPUSH
81431: CALL_OW 263
81435: PPUSH
81436: LD_VAR 0 1
81440: PPUSH
81441: CALL_OW 264
81445: PPUSH
81446: CALL 16084 0 5
81450: ST_TO_ADDR
// if components then
81451: LD_VAR 0 9
81455: IFFALSE 81606
// begin if GetWeapon ( un ) = ar_control_tower then
81457: LD_VAR 0 1
81461: PPUSH
81462: CALL_OW 264
81466: PUSH
81467: LD_INT 31
81469: EQUAL
81470: IFFALSE 81587
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
81472: LD_VAR 0 1
81476: PPUSH
81477: CALL_OW 311
81481: PPUSH
81482: LD_INT 0
81484: PPUSH
81485: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
81489: LD_ADDR_EXP 109
81493: PUSH
81494: LD_EXP 109
81498: PPUSH
81499: LD_VAR 0 3
81503: PPUSH
81504: LD_EXP 109
81508: PUSH
81509: LD_VAR 0 3
81513: ARRAY
81514: PUSH
81515: LD_VAR 0 1
81519: PPUSH
81520: CALL_OW 311
81524: DIFF
81525: PPUSH
81526: CALL_OW 1
81530: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
81531: LD_ADDR_VAR 0 7
81535: PUSH
81536: LD_EXP 90
81540: PUSH
81541: LD_VAR 0 3
81545: ARRAY
81546: PPUSH
81547: LD_INT 1
81549: PPUSH
81550: LD_VAR 0 9
81554: PPUSH
81555: CALL_OW 2
81559: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
81560: LD_ADDR_EXP 90
81564: PUSH
81565: LD_EXP 90
81569: PPUSH
81570: LD_VAR 0 3
81574: PPUSH
81575: LD_VAR 0 7
81579: PPUSH
81580: CALL_OW 1
81584: ST_TO_ADDR
// end else
81585: GO 81604
// MC_InsertProduceList ( i , [ components ] ) ;
81587: LD_VAR 0 3
81591: PPUSH
81592: LD_VAR 0 9
81596: PUSH
81597: EMPTY
81598: LIST
81599: PPUSH
81600: CALL 77545 0 2
// break ;
81604: GO 81608
// end ; end ;
81606: GO 81393
81608: POP
81609: POP
// end ; end ; if GetType ( un ) = unit_building then
81610: LD_VAR 0 1
81614: PPUSH
81615: CALL_OW 247
81619: PUSH
81620: LD_INT 3
81622: EQUAL
81623: IFFALSE 82026
// begin btype := GetBType ( un ) ;
81625: LD_ADDR_VAR 0 5
81629: PUSH
81630: LD_VAR 0 1
81634: PPUSH
81635: CALL_OW 266
81639: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
81640: LD_VAR 0 5
81644: PUSH
81645: LD_INT 29
81647: PUSH
81648: LD_INT 30
81650: PUSH
81651: EMPTY
81652: LIST
81653: LIST
81654: IN
81655: IFFALSE 81728
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
81657: LD_VAR 0 1
81661: PPUSH
81662: CALL_OW 250
81666: PPUSH
81667: LD_VAR 0 1
81671: PPUSH
81672: CALL_OW 251
81676: PPUSH
81677: LD_VAR 0 1
81681: PPUSH
81682: CALL_OW 255
81686: PPUSH
81687: CALL_OW 440
81691: NOT
81692: IFFALSE 81728
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
81694: LD_VAR 0 1
81698: PPUSH
81699: CALL_OW 250
81703: PPUSH
81704: LD_VAR 0 1
81708: PPUSH
81709: CALL_OW 251
81713: PPUSH
81714: LD_VAR 0 1
81718: PPUSH
81719: CALL_OW 255
81723: PPUSH
81724: CALL_OW 441
// end ; if btype = b_warehouse then
81728: LD_VAR 0 5
81732: PUSH
81733: LD_INT 1
81735: EQUAL
81736: IFFALSE 81754
// begin btype := b_depot ;
81738: LD_ADDR_VAR 0 5
81742: PUSH
81743: LD_INT 0
81745: ST_TO_ADDR
// pos := 1 ;
81746: LD_ADDR_VAR 0 6
81750: PUSH
81751: LD_INT 1
81753: ST_TO_ADDR
// end ; if btype = b_factory then
81754: LD_VAR 0 5
81758: PUSH
81759: LD_INT 3
81761: EQUAL
81762: IFFALSE 81780
// begin btype := b_workshop ;
81764: LD_ADDR_VAR 0 5
81768: PUSH
81769: LD_INT 2
81771: ST_TO_ADDR
// pos := 1 ;
81772: LD_ADDR_VAR 0 6
81776: PUSH
81777: LD_INT 1
81779: ST_TO_ADDR
// end ; if btype = b_barracks then
81780: LD_VAR 0 5
81784: PUSH
81785: LD_INT 5
81787: EQUAL
81788: IFFALSE 81798
// btype := b_armoury ;
81790: LD_ADDR_VAR 0 5
81794: PUSH
81795: LD_INT 4
81797: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
81798: LD_VAR 0 5
81802: PUSH
81803: LD_INT 7
81805: PUSH
81806: LD_INT 8
81808: PUSH
81809: EMPTY
81810: LIST
81811: LIST
81812: IN
81813: IFFALSE 81823
// btype := b_lab ;
81815: LD_ADDR_VAR 0 5
81819: PUSH
81820: LD_INT 6
81822: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
81823: LD_ADDR_EXP 74
81827: PUSH
81828: LD_EXP 74
81832: PPUSH
81833: LD_VAR 0 3
81837: PUSH
81838: LD_EXP 74
81842: PUSH
81843: LD_VAR 0 3
81847: ARRAY
81848: PUSH
81849: LD_INT 1
81851: PLUS
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: PPUSH
81857: LD_VAR 0 5
81861: PUSH
81862: LD_VAR 0 1
81866: PPUSH
81867: CALL_OW 250
81871: PUSH
81872: LD_VAR 0 1
81876: PPUSH
81877: CALL_OW 251
81881: PUSH
81882: LD_VAR 0 1
81886: PPUSH
81887: CALL_OW 254
81891: PUSH
81892: EMPTY
81893: LIST
81894: LIST
81895: LIST
81896: LIST
81897: PPUSH
81898: CALL 18588 0 3
81902: ST_TO_ADDR
// if pos = 1 then
81903: LD_VAR 0 6
81907: PUSH
81908: LD_INT 1
81910: EQUAL
81911: IFFALSE 82026
// begin tmp := mc_build_list [ i ] ;
81913: LD_ADDR_VAR 0 7
81917: PUSH
81918: LD_EXP 74
81922: PUSH
81923: LD_VAR 0 3
81927: ARRAY
81928: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81929: LD_VAR 0 7
81933: PPUSH
81934: LD_INT 2
81936: PUSH
81937: LD_INT 30
81939: PUSH
81940: LD_INT 0
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: LD_INT 30
81949: PUSH
81950: LD_INT 1
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PUSH
81957: EMPTY
81958: LIST
81959: LIST
81960: LIST
81961: PPUSH
81962: CALL_OW 72
81966: IFFALSE 81976
// pos := 2 ;
81968: LD_ADDR_VAR 0 6
81972: PUSH
81973: LD_INT 2
81975: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
81976: LD_ADDR_VAR 0 7
81980: PUSH
81981: LD_VAR 0 7
81985: PPUSH
81986: LD_VAR 0 6
81990: PPUSH
81991: LD_VAR 0 7
81995: PPUSH
81996: CALL 18914 0 3
82000: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
82001: LD_ADDR_EXP 74
82005: PUSH
82006: LD_EXP 74
82010: PPUSH
82011: LD_VAR 0 3
82015: PPUSH
82016: LD_VAR 0 7
82020: PPUSH
82021: CALL_OW 1
82025: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
82026: LD_VAR 0 1
82030: PUSH
82031: LD_EXP 69
82035: PUSH
82036: LD_VAR 0 3
82040: ARRAY
82041: IN
82042: IFFALSE 82081
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
82044: LD_ADDR_EXP 69
82048: PUSH
82049: LD_EXP 69
82053: PPUSH
82054: LD_VAR 0 3
82058: PPUSH
82059: LD_EXP 69
82063: PUSH
82064: LD_VAR 0 3
82068: ARRAY
82069: PUSH
82070: LD_VAR 0 1
82074: DIFF
82075: PPUSH
82076: CALL_OW 1
82080: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
82081: LD_VAR 0 1
82085: PUSH
82086: LD_EXP 76
82090: PUSH
82091: LD_VAR 0 3
82095: ARRAY
82096: IN
82097: IFFALSE 82136
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
82099: LD_ADDR_EXP 76
82103: PUSH
82104: LD_EXP 76
82108: PPUSH
82109: LD_VAR 0 3
82113: PPUSH
82114: LD_EXP 76
82118: PUSH
82119: LD_VAR 0 3
82123: ARRAY
82124: PUSH
82125: LD_VAR 0 1
82129: DIFF
82130: PPUSH
82131: CALL_OW 1
82135: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
82136: LD_VAR 0 1
82140: PUSH
82141: LD_EXP 88
82145: PUSH
82146: LD_VAR 0 3
82150: ARRAY
82151: IN
82152: IFFALSE 82191
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
82154: LD_ADDR_EXP 88
82158: PUSH
82159: LD_EXP 88
82163: PPUSH
82164: LD_VAR 0 3
82168: PPUSH
82169: LD_EXP 88
82173: PUSH
82174: LD_VAR 0 3
82178: ARRAY
82179: PUSH
82180: LD_VAR 0 1
82184: DIFF
82185: PPUSH
82186: CALL_OW 1
82190: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
82191: LD_VAR 0 1
82195: PUSH
82196: LD_EXP 91
82200: PUSH
82201: LD_VAR 0 3
82205: ARRAY
82206: IN
82207: IFFALSE 82246
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82209: LD_ADDR_EXP 91
82213: PUSH
82214: LD_EXP 91
82218: PPUSH
82219: LD_VAR 0 3
82223: PPUSH
82224: LD_EXP 91
82228: PUSH
82229: LD_VAR 0 3
82233: ARRAY
82234: PUSH
82235: LD_VAR 0 1
82239: DIFF
82240: PPUSH
82241: CALL_OW 1
82245: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
82246: LD_VAR 0 1
82250: PUSH
82251: LD_EXP 78
82255: PUSH
82256: LD_VAR 0 3
82260: ARRAY
82261: IN
82262: IFFALSE 82301
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
82264: LD_ADDR_EXP 78
82268: PUSH
82269: LD_EXP 78
82273: PPUSH
82274: LD_VAR 0 3
82278: PPUSH
82279: LD_EXP 78
82283: PUSH
82284: LD_VAR 0 3
82288: ARRAY
82289: PUSH
82290: LD_VAR 0 1
82294: DIFF
82295: PPUSH
82296: CALL_OW 1
82300: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
82301: LD_VAR 0 1
82305: PUSH
82306: LD_EXP 77
82310: PUSH
82311: LD_VAR 0 3
82315: ARRAY
82316: IN
82317: IFFALSE 82356
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
82319: LD_ADDR_EXP 77
82323: PUSH
82324: LD_EXP 77
82328: PPUSH
82329: LD_VAR 0 3
82333: PPUSH
82334: LD_EXP 77
82338: PUSH
82339: LD_VAR 0 3
82343: ARRAY
82344: PUSH
82345: LD_VAR 0 1
82349: DIFF
82350: PPUSH
82351: CALL_OW 1
82355: ST_TO_ADDR
// end ; break ;
82356: GO 82360
// end ;
82358: GO 81006
82360: POP
82361: POP
// end ;
82362: LD_VAR 0 2
82366: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
82367: LD_INT 0
82369: PPUSH
82370: PPUSH
82371: PPUSH
// if not mc_bases or not skirmish then
82372: LD_EXP 69
82376: NOT
82377: PUSH
82378: LD_EXP 67
82382: NOT
82383: OR
82384: IFFALSE 82388
// exit ;
82386: GO 82603
// for i = 1 to mc_bases do
82388: LD_ADDR_VAR 0 3
82392: PUSH
82393: DOUBLE
82394: LD_INT 1
82396: DEC
82397: ST_TO_ADDR
82398: LD_EXP 69
82402: PUSH
82403: FOR_TO
82404: IFFALSE 82601
// begin if building in mc_construct_list [ i ] then
82406: LD_VAR 0 1
82410: PUSH
82411: LD_EXP 76
82415: PUSH
82416: LD_VAR 0 3
82420: ARRAY
82421: IN
82422: IFFALSE 82599
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82424: LD_ADDR_EXP 76
82428: PUSH
82429: LD_EXP 76
82433: PPUSH
82434: LD_VAR 0 3
82438: PPUSH
82439: LD_EXP 76
82443: PUSH
82444: LD_VAR 0 3
82448: ARRAY
82449: PUSH
82450: LD_VAR 0 1
82454: DIFF
82455: PPUSH
82456: CALL_OW 1
82460: ST_TO_ADDR
// if building in mc_lab [ i ] then
82461: LD_VAR 0 1
82465: PUSH
82466: LD_EXP 102
82470: PUSH
82471: LD_VAR 0 3
82475: ARRAY
82476: IN
82477: IFFALSE 82532
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
82479: LD_ADDR_EXP 103
82483: PUSH
82484: LD_EXP 103
82488: PPUSH
82489: LD_VAR 0 3
82493: PPUSH
82494: LD_EXP 103
82498: PUSH
82499: LD_VAR 0 3
82503: ARRAY
82504: PPUSH
82505: LD_INT 1
82507: PPUSH
82508: LD_EXP 103
82512: PUSH
82513: LD_VAR 0 3
82517: ARRAY
82518: PPUSH
82519: LD_INT 0
82521: PPUSH
82522: CALL 18006 0 4
82526: PPUSH
82527: CALL_OW 1
82531: ST_TO_ADDR
// if not building in mc_bases [ i ] then
82532: LD_VAR 0 1
82536: PUSH
82537: LD_EXP 69
82541: PUSH
82542: LD_VAR 0 3
82546: ARRAY
82547: IN
82548: NOT
82549: IFFALSE 82595
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82551: LD_ADDR_EXP 69
82555: PUSH
82556: LD_EXP 69
82560: PPUSH
82561: LD_VAR 0 3
82565: PUSH
82566: LD_EXP 69
82570: PUSH
82571: LD_VAR 0 3
82575: ARRAY
82576: PUSH
82577: LD_INT 1
82579: PLUS
82580: PUSH
82581: EMPTY
82582: LIST
82583: LIST
82584: PPUSH
82585: LD_VAR 0 1
82589: PPUSH
82590: CALL 18588 0 3
82594: ST_TO_ADDR
// exit ;
82595: POP
82596: POP
82597: GO 82603
// end ; end ;
82599: GO 82403
82601: POP
82602: POP
// end ;
82603: LD_VAR 0 2
82607: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
82608: LD_INT 0
82610: PPUSH
82611: PPUSH
82612: PPUSH
82613: PPUSH
82614: PPUSH
82615: PPUSH
82616: PPUSH
// if not mc_bases or not skirmish then
82617: LD_EXP 69
82621: NOT
82622: PUSH
82623: LD_EXP 67
82627: NOT
82628: OR
82629: IFFALSE 82633
// exit ;
82631: GO 83294
// for i = 1 to mc_bases do
82633: LD_ADDR_VAR 0 3
82637: PUSH
82638: DOUBLE
82639: LD_INT 1
82641: DEC
82642: ST_TO_ADDR
82643: LD_EXP 69
82647: PUSH
82648: FOR_TO
82649: IFFALSE 83292
// begin if building in mc_construct_list [ i ] then
82651: LD_VAR 0 1
82655: PUSH
82656: LD_EXP 76
82660: PUSH
82661: LD_VAR 0 3
82665: ARRAY
82666: IN
82667: IFFALSE 83290
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82669: LD_ADDR_EXP 76
82673: PUSH
82674: LD_EXP 76
82678: PPUSH
82679: LD_VAR 0 3
82683: PPUSH
82684: LD_EXP 76
82688: PUSH
82689: LD_VAR 0 3
82693: ARRAY
82694: PUSH
82695: LD_VAR 0 1
82699: DIFF
82700: PPUSH
82701: CALL_OW 1
82705: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82706: LD_ADDR_EXP 69
82710: PUSH
82711: LD_EXP 69
82715: PPUSH
82716: LD_VAR 0 3
82720: PUSH
82721: LD_EXP 69
82725: PUSH
82726: LD_VAR 0 3
82730: ARRAY
82731: PUSH
82732: LD_INT 1
82734: PLUS
82735: PUSH
82736: EMPTY
82737: LIST
82738: LIST
82739: PPUSH
82740: LD_VAR 0 1
82744: PPUSH
82745: CALL 18588 0 3
82749: ST_TO_ADDR
// btype := GetBType ( building ) ;
82750: LD_ADDR_VAR 0 5
82754: PUSH
82755: LD_VAR 0 1
82759: PPUSH
82760: CALL_OW 266
82764: ST_TO_ADDR
// side := GetSide ( building ) ;
82765: LD_ADDR_VAR 0 8
82769: PUSH
82770: LD_VAR 0 1
82774: PPUSH
82775: CALL_OW 255
82779: ST_TO_ADDR
// if btype = b_lab then
82780: LD_VAR 0 5
82784: PUSH
82785: LD_INT 6
82787: EQUAL
82788: IFFALSE 82838
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
82790: LD_ADDR_EXP 102
82794: PUSH
82795: LD_EXP 102
82799: PPUSH
82800: LD_VAR 0 3
82804: PUSH
82805: LD_EXP 102
82809: PUSH
82810: LD_VAR 0 3
82814: ARRAY
82815: PUSH
82816: LD_INT 1
82818: PLUS
82819: PUSH
82820: EMPTY
82821: LIST
82822: LIST
82823: PPUSH
82824: LD_VAR 0 1
82828: PPUSH
82829: CALL 18588 0 3
82833: ST_TO_ADDR
// exit ;
82834: POP
82835: POP
82836: GO 83294
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
82838: LD_VAR 0 5
82842: PUSH
82843: LD_INT 0
82845: PUSH
82846: LD_INT 2
82848: PUSH
82849: LD_INT 4
82851: PUSH
82852: EMPTY
82853: LIST
82854: LIST
82855: LIST
82856: IN
82857: IFFALSE 82981
// begin if btype = b_armoury then
82859: LD_VAR 0 5
82863: PUSH
82864: LD_INT 4
82866: EQUAL
82867: IFFALSE 82877
// btype := b_barracks ;
82869: LD_ADDR_VAR 0 5
82873: PUSH
82874: LD_INT 5
82876: ST_TO_ADDR
// if btype = b_depot then
82877: LD_VAR 0 5
82881: PUSH
82882: LD_INT 0
82884: EQUAL
82885: IFFALSE 82895
// btype := b_warehouse ;
82887: LD_ADDR_VAR 0 5
82891: PUSH
82892: LD_INT 1
82894: ST_TO_ADDR
// if btype = b_workshop then
82895: LD_VAR 0 5
82899: PUSH
82900: LD_INT 2
82902: EQUAL
82903: IFFALSE 82913
// btype := b_factory ;
82905: LD_ADDR_VAR 0 5
82909: PUSH
82910: LD_INT 3
82912: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
82913: LD_VAR 0 5
82917: PPUSH
82918: LD_VAR 0 8
82922: PPUSH
82923: CALL_OW 323
82927: PUSH
82928: LD_INT 1
82930: EQUAL
82931: IFFALSE 82977
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
82933: LD_ADDR_EXP 101
82937: PUSH
82938: LD_EXP 101
82942: PPUSH
82943: LD_VAR 0 3
82947: PUSH
82948: LD_EXP 101
82952: PUSH
82953: LD_VAR 0 3
82957: ARRAY
82958: PUSH
82959: LD_INT 1
82961: PLUS
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PPUSH
82967: LD_VAR 0 1
82971: PPUSH
82972: CALL 18588 0 3
82976: ST_TO_ADDR
// exit ;
82977: POP
82978: POP
82979: GO 83294
// end ; if btype in [ b_bunker , b_turret ] then
82981: LD_VAR 0 5
82985: PUSH
82986: LD_INT 32
82988: PUSH
82989: LD_INT 33
82991: PUSH
82992: EMPTY
82993: LIST
82994: LIST
82995: IN
82996: IFFALSE 83286
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
82998: LD_ADDR_EXP 77
83002: PUSH
83003: LD_EXP 77
83007: PPUSH
83008: LD_VAR 0 3
83012: PUSH
83013: LD_EXP 77
83017: PUSH
83018: LD_VAR 0 3
83022: ARRAY
83023: PUSH
83024: LD_INT 1
83026: PLUS
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: PPUSH
83032: LD_VAR 0 1
83036: PPUSH
83037: CALL 18588 0 3
83041: ST_TO_ADDR
// if btype = b_bunker then
83042: LD_VAR 0 5
83046: PUSH
83047: LD_INT 32
83049: EQUAL
83050: IFFALSE 83286
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83052: LD_ADDR_EXP 78
83056: PUSH
83057: LD_EXP 78
83061: PPUSH
83062: LD_VAR 0 3
83066: PUSH
83067: LD_EXP 78
83071: PUSH
83072: LD_VAR 0 3
83076: ARRAY
83077: PUSH
83078: LD_INT 1
83080: PLUS
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PPUSH
83086: LD_VAR 0 1
83090: PPUSH
83091: CALL 18588 0 3
83095: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
83096: LD_ADDR_VAR 0 6
83100: PUSH
83101: LD_EXP 69
83105: PUSH
83106: LD_VAR 0 3
83110: ARRAY
83111: PPUSH
83112: LD_INT 25
83114: PUSH
83115: LD_INT 1
83117: PUSH
83118: EMPTY
83119: LIST
83120: LIST
83121: PUSH
83122: LD_INT 3
83124: PUSH
83125: LD_INT 54
83127: PUSH
83128: EMPTY
83129: LIST
83130: PUSH
83131: EMPTY
83132: LIST
83133: LIST
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: PPUSH
83139: CALL_OW 72
83143: ST_TO_ADDR
// if tmp then
83144: LD_VAR 0 6
83148: IFFALSE 83154
// exit ;
83150: POP
83151: POP
83152: GO 83294
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
83154: LD_ADDR_VAR 0 6
83158: PUSH
83159: LD_EXP 69
83163: PUSH
83164: LD_VAR 0 3
83168: ARRAY
83169: PPUSH
83170: LD_INT 2
83172: PUSH
83173: LD_INT 30
83175: PUSH
83176: LD_INT 4
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: PUSH
83183: LD_INT 30
83185: PUSH
83186: LD_INT 5
83188: PUSH
83189: EMPTY
83190: LIST
83191: LIST
83192: PUSH
83193: EMPTY
83194: LIST
83195: LIST
83196: LIST
83197: PPUSH
83198: CALL_OW 72
83202: ST_TO_ADDR
// if not tmp then
83203: LD_VAR 0 6
83207: NOT
83208: IFFALSE 83214
// exit ;
83210: POP
83211: POP
83212: GO 83294
// for j in tmp do
83214: LD_ADDR_VAR 0 4
83218: PUSH
83219: LD_VAR 0 6
83223: PUSH
83224: FOR_IN
83225: IFFALSE 83284
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
83227: LD_ADDR_VAR 0 7
83231: PUSH
83232: LD_VAR 0 4
83236: PPUSH
83237: CALL_OW 313
83241: PPUSH
83242: LD_INT 25
83244: PUSH
83245: LD_INT 1
83247: PUSH
83248: EMPTY
83249: LIST
83250: LIST
83251: PPUSH
83252: CALL_OW 72
83256: ST_TO_ADDR
// if units then
83257: LD_VAR 0 7
83261: IFFALSE 83282
// begin ComExitBuilding ( units [ 1 ] ) ;
83263: LD_VAR 0 7
83267: PUSH
83268: LD_INT 1
83270: ARRAY
83271: PPUSH
83272: CALL_OW 122
// exit ;
83276: POP
83277: POP
83278: POP
83279: POP
83280: GO 83294
// end ; end ;
83282: GO 83224
83284: POP
83285: POP
// end ; end ; exit ;
83286: POP
83287: POP
83288: GO 83294
// end ; end ;
83290: GO 82648
83292: POP
83293: POP
// end ;
83294: LD_VAR 0 2
83298: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
83299: LD_INT 0
83301: PPUSH
83302: PPUSH
83303: PPUSH
83304: PPUSH
83305: PPUSH
83306: PPUSH
83307: PPUSH
// if not mc_bases or not skirmish then
83308: LD_EXP 69
83312: NOT
83313: PUSH
83314: LD_EXP 67
83318: NOT
83319: OR
83320: IFFALSE 83324
// exit ;
83322: GO 83589
// btype := GetBType ( building ) ;
83324: LD_ADDR_VAR 0 6
83328: PUSH
83329: LD_VAR 0 1
83333: PPUSH
83334: CALL_OW 266
83338: ST_TO_ADDR
// x := GetX ( building ) ;
83339: LD_ADDR_VAR 0 7
83343: PUSH
83344: LD_VAR 0 1
83348: PPUSH
83349: CALL_OW 250
83353: ST_TO_ADDR
// y := GetY ( building ) ;
83354: LD_ADDR_VAR 0 8
83358: PUSH
83359: LD_VAR 0 1
83363: PPUSH
83364: CALL_OW 251
83368: ST_TO_ADDR
// d := GetDir ( building ) ;
83369: LD_ADDR_VAR 0 9
83373: PUSH
83374: LD_VAR 0 1
83378: PPUSH
83379: CALL_OW 254
83383: ST_TO_ADDR
// for i = 1 to mc_bases do
83384: LD_ADDR_VAR 0 4
83388: PUSH
83389: DOUBLE
83390: LD_INT 1
83392: DEC
83393: ST_TO_ADDR
83394: LD_EXP 69
83398: PUSH
83399: FOR_TO
83400: IFFALSE 83587
// begin if not mc_build_list [ i ] then
83402: LD_EXP 74
83406: PUSH
83407: LD_VAR 0 4
83411: ARRAY
83412: NOT
83413: IFFALSE 83417
// continue ;
83415: GO 83399
// for j := 1 to mc_build_list [ i ] do
83417: LD_ADDR_VAR 0 5
83421: PUSH
83422: DOUBLE
83423: LD_INT 1
83425: DEC
83426: ST_TO_ADDR
83427: LD_EXP 74
83431: PUSH
83432: LD_VAR 0 4
83436: ARRAY
83437: PUSH
83438: FOR_TO
83439: IFFALSE 83583
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
83441: LD_VAR 0 6
83445: PUSH
83446: LD_VAR 0 7
83450: PUSH
83451: LD_VAR 0 8
83455: PUSH
83456: LD_VAR 0 9
83460: PUSH
83461: EMPTY
83462: LIST
83463: LIST
83464: LIST
83465: LIST
83466: PPUSH
83467: LD_EXP 74
83471: PUSH
83472: LD_VAR 0 4
83476: ARRAY
83477: PUSH
83478: LD_VAR 0 5
83482: ARRAY
83483: PPUSH
83484: CALL 24770 0 2
83488: IFFALSE 83581
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
83490: LD_ADDR_EXP 74
83494: PUSH
83495: LD_EXP 74
83499: PPUSH
83500: LD_VAR 0 4
83504: PPUSH
83505: LD_EXP 74
83509: PUSH
83510: LD_VAR 0 4
83514: ARRAY
83515: PPUSH
83516: LD_VAR 0 5
83520: PPUSH
83521: CALL_OW 3
83525: PPUSH
83526: CALL_OW 1
83530: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
83531: LD_ADDR_EXP 76
83535: PUSH
83536: LD_EXP 76
83540: PPUSH
83541: LD_VAR 0 4
83545: PUSH
83546: LD_EXP 76
83550: PUSH
83551: LD_VAR 0 4
83555: ARRAY
83556: PUSH
83557: LD_INT 1
83559: PLUS
83560: PUSH
83561: EMPTY
83562: LIST
83563: LIST
83564: PPUSH
83565: LD_VAR 0 1
83569: PPUSH
83570: CALL 18588 0 3
83574: ST_TO_ADDR
// exit ;
83575: POP
83576: POP
83577: POP
83578: POP
83579: GO 83589
// end ;
83581: GO 83438
83583: POP
83584: POP
// end ;
83585: GO 83399
83587: POP
83588: POP
// end ;
83589: LD_VAR 0 3
83593: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
83594: LD_INT 0
83596: PPUSH
83597: PPUSH
83598: PPUSH
// if not mc_bases or not skirmish then
83599: LD_EXP 69
83603: NOT
83604: PUSH
83605: LD_EXP 67
83609: NOT
83610: OR
83611: IFFALSE 83615
// exit ;
83613: GO 83805
// for i = 1 to mc_bases do
83615: LD_ADDR_VAR 0 4
83619: PUSH
83620: DOUBLE
83621: LD_INT 1
83623: DEC
83624: ST_TO_ADDR
83625: LD_EXP 69
83629: PUSH
83630: FOR_TO
83631: IFFALSE 83718
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
83633: LD_VAR 0 1
83637: PUSH
83638: LD_EXP 77
83642: PUSH
83643: LD_VAR 0 4
83647: ARRAY
83648: IN
83649: PUSH
83650: LD_VAR 0 1
83654: PUSH
83655: LD_EXP 78
83659: PUSH
83660: LD_VAR 0 4
83664: ARRAY
83665: IN
83666: NOT
83667: AND
83668: IFFALSE 83716
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83670: LD_ADDR_EXP 78
83674: PUSH
83675: LD_EXP 78
83679: PPUSH
83680: LD_VAR 0 4
83684: PUSH
83685: LD_EXP 78
83689: PUSH
83690: LD_VAR 0 4
83694: ARRAY
83695: PUSH
83696: LD_INT 1
83698: PLUS
83699: PUSH
83700: EMPTY
83701: LIST
83702: LIST
83703: PPUSH
83704: LD_VAR 0 1
83708: PPUSH
83709: CALL 18588 0 3
83713: ST_TO_ADDR
// break ;
83714: GO 83718
// end ; end ;
83716: GO 83630
83718: POP
83719: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
83720: LD_VAR 0 1
83724: PPUSH
83725: CALL_OW 257
83729: PUSH
83730: LD_EXP 95
83734: IN
83735: PUSH
83736: LD_VAR 0 1
83740: PPUSH
83741: CALL_OW 266
83745: PUSH
83746: LD_INT 5
83748: EQUAL
83749: AND
83750: PUSH
83751: LD_VAR 0 2
83755: PPUSH
83756: CALL_OW 110
83760: PUSH
83761: LD_INT 18
83763: NONEQUAL
83764: AND
83765: IFFALSE 83805
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
83767: LD_VAR 0 2
83771: PPUSH
83772: CALL_OW 257
83776: PUSH
83777: LD_INT 5
83779: PUSH
83780: LD_INT 8
83782: PUSH
83783: LD_INT 9
83785: PUSH
83786: EMPTY
83787: LIST
83788: LIST
83789: LIST
83790: IN
83791: IFFALSE 83805
// SetClass ( unit , 1 ) ;
83793: LD_VAR 0 2
83797: PPUSH
83798: LD_INT 1
83800: PPUSH
83801: CALL_OW 336
// end ;
83805: LD_VAR 0 3
83809: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
83810: LD_INT 0
83812: PPUSH
83813: PPUSH
// if not mc_bases or not skirmish then
83814: LD_EXP 69
83818: NOT
83819: PUSH
83820: LD_EXP 67
83824: NOT
83825: OR
83826: IFFALSE 83830
// exit ;
83828: GO 83946
// if GetLives ( abandoned_vehicle ) > 250 then
83830: LD_VAR 0 2
83834: PPUSH
83835: CALL_OW 256
83839: PUSH
83840: LD_INT 250
83842: GREATER
83843: IFFALSE 83847
// exit ;
83845: GO 83946
// for i = 1 to mc_bases do
83847: LD_ADDR_VAR 0 6
83851: PUSH
83852: DOUBLE
83853: LD_INT 1
83855: DEC
83856: ST_TO_ADDR
83857: LD_EXP 69
83861: PUSH
83862: FOR_TO
83863: IFFALSE 83944
// begin if driver in mc_bases [ i ] then
83865: LD_VAR 0 1
83869: PUSH
83870: LD_EXP 69
83874: PUSH
83875: LD_VAR 0 6
83879: ARRAY
83880: IN
83881: IFFALSE 83942
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
83883: LD_VAR 0 1
83887: PPUSH
83888: LD_EXP 69
83892: PUSH
83893: LD_VAR 0 6
83897: ARRAY
83898: PPUSH
83899: LD_INT 2
83901: PUSH
83902: LD_INT 30
83904: PUSH
83905: LD_INT 0
83907: PUSH
83908: EMPTY
83909: LIST
83910: LIST
83911: PUSH
83912: LD_INT 30
83914: PUSH
83915: LD_INT 1
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: PUSH
83922: EMPTY
83923: LIST
83924: LIST
83925: LIST
83926: PPUSH
83927: CALL_OW 72
83931: PUSH
83932: LD_INT 1
83934: ARRAY
83935: PPUSH
83936: CALL 51206 0 2
// break ;
83940: GO 83944
// end ; end ;
83942: GO 83862
83944: POP
83945: POP
// end ; end_of_file end_of_file
83946: LD_VAR 0 5
83950: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
83951: LD_INT 0
83953: PPUSH
// if p2 = 100 then
83954: LD_VAR 0 2
83958: PUSH
83959: LD_INT 100
83961: EQUAL
83962: IFFALSE 84965
// begin if not StreamModeActive then
83964: LD_EXP 113
83968: NOT
83969: IFFALSE 83979
// StreamModeActive := true ;
83971: LD_ADDR_EXP 113
83975: PUSH
83976: LD_INT 1
83978: ST_TO_ADDR
// if p3 = 0 then
83979: LD_VAR 0 3
83983: PUSH
83984: LD_INT 0
83986: EQUAL
83987: IFFALSE 83993
// InitStreamMode ;
83989: CALL 85125 0 0
// if p3 = 1 then
83993: LD_VAR 0 3
83997: PUSH
83998: LD_INT 1
84000: EQUAL
84001: IFFALSE 84011
// sRocket := true ;
84003: LD_ADDR_EXP 118
84007: PUSH
84008: LD_INT 1
84010: ST_TO_ADDR
// if p3 = 2 then
84011: LD_VAR 0 3
84015: PUSH
84016: LD_INT 2
84018: EQUAL
84019: IFFALSE 84029
// sSpeed := true ;
84021: LD_ADDR_EXP 117
84025: PUSH
84026: LD_INT 1
84028: ST_TO_ADDR
// if p3 = 3 then
84029: LD_VAR 0 3
84033: PUSH
84034: LD_INT 3
84036: EQUAL
84037: IFFALSE 84047
// sEngine := true ;
84039: LD_ADDR_EXP 119
84043: PUSH
84044: LD_INT 1
84046: ST_TO_ADDR
// if p3 = 4 then
84047: LD_VAR 0 3
84051: PUSH
84052: LD_INT 4
84054: EQUAL
84055: IFFALSE 84065
// sSpec := true ;
84057: LD_ADDR_EXP 116
84061: PUSH
84062: LD_INT 1
84064: ST_TO_ADDR
// if p3 = 5 then
84065: LD_VAR 0 3
84069: PUSH
84070: LD_INT 5
84072: EQUAL
84073: IFFALSE 84083
// sLevel := true ;
84075: LD_ADDR_EXP 120
84079: PUSH
84080: LD_INT 1
84082: ST_TO_ADDR
// if p3 = 6 then
84083: LD_VAR 0 3
84087: PUSH
84088: LD_INT 6
84090: EQUAL
84091: IFFALSE 84101
// sArmoury := true ;
84093: LD_ADDR_EXP 121
84097: PUSH
84098: LD_INT 1
84100: ST_TO_ADDR
// if p3 = 7 then
84101: LD_VAR 0 3
84105: PUSH
84106: LD_INT 7
84108: EQUAL
84109: IFFALSE 84119
// sRadar := true ;
84111: LD_ADDR_EXP 122
84115: PUSH
84116: LD_INT 1
84118: ST_TO_ADDR
// if p3 = 8 then
84119: LD_VAR 0 3
84123: PUSH
84124: LD_INT 8
84126: EQUAL
84127: IFFALSE 84137
// sBunker := true ;
84129: LD_ADDR_EXP 123
84133: PUSH
84134: LD_INT 1
84136: ST_TO_ADDR
// if p3 = 9 then
84137: LD_VAR 0 3
84141: PUSH
84142: LD_INT 9
84144: EQUAL
84145: IFFALSE 84155
// sHack := true ;
84147: LD_ADDR_EXP 124
84151: PUSH
84152: LD_INT 1
84154: ST_TO_ADDR
// if p3 = 10 then
84155: LD_VAR 0 3
84159: PUSH
84160: LD_INT 10
84162: EQUAL
84163: IFFALSE 84173
// sFire := true ;
84165: LD_ADDR_EXP 125
84169: PUSH
84170: LD_INT 1
84172: ST_TO_ADDR
// if p3 = 11 then
84173: LD_VAR 0 3
84177: PUSH
84178: LD_INT 11
84180: EQUAL
84181: IFFALSE 84191
// sRefresh := true ;
84183: LD_ADDR_EXP 126
84187: PUSH
84188: LD_INT 1
84190: ST_TO_ADDR
// if p3 = 12 then
84191: LD_VAR 0 3
84195: PUSH
84196: LD_INT 12
84198: EQUAL
84199: IFFALSE 84209
// sExp := true ;
84201: LD_ADDR_EXP 127
84205: PUSH
84206: LD_INT 1
84208: ST_TO_ADDR
// if p3 = 13 then
84209: LD_VAR 0 3
84213: PUSH
84214: LD_INT 13
84216: EQUAL
84217: IFFALSE 84227
// sDepot := true ;
84219: LD_ADDR_EXP 128
84223: PUSH
84224: LD_INT 1
84226: ST_TO_ADDR
// if p3 = 14 then
84227: LD_VAR 0 3
84231: PUSH
84232: LD_INT 14
84234: EQUAL
84235: IFFALSE 84245
// sFlag := true ;
84237: LD_ADDR_EXP 129
84241: PUSH
84242: LD_INT 1
84244: ST_TO_ADDR
// if p3 = 15 then
84245: LD_VAR 0 3
84249: PUSH
84250: LD_INT 15
84252: EQUAL
84253: IFFALSE 84263
// sKamikadze := true ;
84255: LD_ADDR_EXP 137
84259: PUSH
84260: LD_INT 1
84262: ST_TO_ADDR
// if p3 = 16 then
84263: LD_VAR 0 3
84267: PUSH
84268: LD_INT 16
84270: EQUAL
84271: IFFALSE 84281
// sTroll := true ;
84273: LD_ADDR_EXP 138
84277: PUSH
84278: LD_INT 1
84280: ST_TO_ADDR
// if p3 = 17 then
84281: LD_VAR 0 3
84285: PUSH
84286: LD_INT 17
84288: EQUAL
84289: IFFALSE 84299
// sSlow := true ;
84291: LD_ADDR_EXP 139
84295: PUSH
84296: LD_INT 1
84298: ST_TO_ADDR
// if p3 = 18 then
84299: LD_VAR 0 3
84303: PUSH
84304: LD_INT 18
84306: EQUAL
84307: IFFALSE 84317
// sLack := true ;
84309: LD_ADDR_EXP 140
84313: PUSH
84314: LD_INT 1
84316: ST_TO_ADDR
// if p3 = 19 then
84317: LD_VAR 0 3
84321: PUSH
84322: LD_INT 19
84324: EQUAL
84325: IFFALSE 84335
// sTank := true ;
84327: LD_ADDR_EXP 142
84331: PUSH
84332: LD_INT 1
84334: ST_TO_ADDR
// if p3 = 20 then
84335: LD_VAR 0 3
84339: PUSH
84340: LD_INT 20
84342: EQUAL
84343: IFFALSE 84353
// sRemote := true ;
84345: LD_ADDR_EXP 143
84349: PUSH
84350: LD_INT 1
84352: ST_TO_ADDR
// if p3 = 21 then
84353: LD_VAR 0 3
84357: PUSH
84358: LD_INT 21
84360: EQUAL
84361: IFFALSE 84371
// sPowell := true ;
84363: LD_ADDR_EXP 144
84367: PUSH
84368: LD_INT 1
84370: ST_TO_ADDR
// if p3 = 22 then
84371: LD_VAR 0 3
84375: PUSH
84376: LD_INT 22
84378: EQUAL
84379: IFFALSE 84389
// sTeleport := true ;
84381: LD_ADDR_EXP 147
84385: PUSH
84386: LD_INT 1
84388: ST_TO_ADDR
// if p3 = 23 then
84389: LD_VAR 0 3
84393: PUSH
84394: LD_INT 23
84396: EQUAL
84397: IFFALSE 84407
// sOilTower := true ;
84399: LD_ADDR_EXP 149
84403: PUSH
84404: LD_INT 1
84406: ST_TO_ADDR
// if p3 = 24 then
84407: LD_VAR 0 3
84411: PUSH
84412: LD_INT 24
84414: EQUAL
84415: IFFALSE 84425
// sShovel := true ;
84417: LD_ADDR_EXP 150
84421: PUSH
84422: LD_INT 1
84424: ST_TO_ADDR
// if p3 = 25 then
84425: LD_VAR 0 3
84429: PUSH
84430: LD_INT 25
84432: EQUAL
84433: IFFALSE 84443
// sSheik := true ;
84435: LD_ADDR_EXP 151
84439: PUSH
84440: LD_INT 1
84442: ST_TO_ADDR
// if p3 = 26 then
84443: LD_VAR 0 3
84447: PUSH
84448: LD_INT 26
84450: EQUAL
84451: IFFALSE 84461
// sEarthquake := true ;
84453: LD_ADDR_EXP 153
84457: PUSH
84458: LD_INT 1
84460: ST_TO_ADDR
// if p3 = 27 then
84461: LD_VAR 0 3
84465: PUSH
84466: LD_INT 27
84468: EQUAL
84469: IFFALSE 84479
// sAI := true ;
84471: LD_ADDR_EXP 154
84475: PUSH
84476: LD_INT 1
84478: ST_TO_ADDR
// if p3 = 28 then
84479: LD_VAR 0 3
84483: PUSH
84484: LD_INT 28
84486: EQUAL
84487: IFFALSE 84497
// sCargo := true ;
84489: LD_ADDR_EXP 157
84493: PUSH
84494: LD_INT 1
84496: ST_TO_ADDR
// if p3 = 29 then
84497: LD_VAR 0 3
84501: PUSH
84502: LD_INT 29
84504: EQUAL
84505: IFFALSE 84515
// sDLaser := true ;
84507: LD_ADDR_EXP 158
84511: PUSH
84512: LD_INT 1
84514: ST_TO_ADDR
// if p3 = 30 then
84515: LD_VAR 0 3
84519: PUSH
84520: LD_INT 30
84522: EQUAL
84523: IFFALSE 84533
// sExchange := true ;
84525: LD_ADDR_EXP 159
84529: PUSH
84530: LD_INT 1
84532: ST_TO_ADDR
// if p3 = 31 then
84533: LD_VAR 0 3
84537: PUSH
84538: LD_INT 31
84540: EQUAL
84541: IFFALSE 84551
// sFac := true ;
84543: LD_ADDR_EXP 160
84547: PUSH
84548: LD_INT 1
84550: ST_TO_ADDR
// if p3 = 32 then
84551: LD_VAR 0 3
84555: PUSH
84556: LD_INT 32
84558: EQUAL
84559: IFFALSE 84569
// sPower := true ;
84561: LD_ADDR_EXP 161
84565: PUSH
84566: LD_INT 1
84568: ST_TO_ADDR
// if p3 = 33 then
84569: LD_VAR 0 3
84573: PUSH
84574: LD_INT 33
84576: EQUAL
84577: IFFALSE 84587
// sRandom := true ;
84579: LD_ADDR_EXP 162
84583: PUSH
84584: LD_INT 1
84586: ST_TO_ADDR
// if p3 = 34 then
84587: LD_VAR 0 3
84591: PUSH
84592: LD_INT 34
84594: EQUAL
84595: IFFALSE 84605
// sShield := true ;
84597: LD_ADDR_EXP 163
84601: PUSH
84602: LD_INT 1
84604: ST_TO_ADDR
// if p3 = 35 then
84605: LD_VAR 0 3
84609: PUSH
84610: LD_INT 35
84612: EQUAL
84613: IFFALSE 84623
// sTime := true ;
84615: LD_ADDR_EXP 164
84619: PUSH
84620: LD_INT 1
84622: ST_TO_ADDR
// if p3 = 36 then
84623: LD_VAR 0 3
84627: PUSH
84628: LD_INT 36
84630: EQUAL
84631: IFFALSE 84641
// sTools := true ;
84633: LD_ADDR_EXP 165
84637: PUSH
84638: LD_INT 1
84640: ST_TO_ADDR
// if p3 = 101 then
84641: LD_VAR 0 3
84645: PUSH
84646: LD_INT 101
84648: EQUAL
84649: IFFALSE 84659
// sSold := true ;
84651: LD_ADDR_EXP 130
84655: PUSH
84656: LD_INT 1
84658: ST_TO_ADDR
// if p3 = 102 then
84659: LD_VAR 0 3
84663: PUSH
84664: LD_INT 102
84666: EQUAL
84667: IFFALSE 84677
// sDiff := true ;
84669: LD_ADDR_EXP 131
84673: PUSH
84674: LD_INT 1
84676: ST_TO_ADDR
// if p3 = 103 then
84677: LD_VAR 0 3
84681: PUSH
84682: LD_INT 103
84684: EQUAL
84685: IFFALSE 84695
// sFog := true ;
84687: LD_ADDR_EXP 134
84691: PUSH
84692: LD_INT 1
84694: ST_TO_ADDR
// if p3 = 104 then
84695: LD_VAR 0 3
84699: PUSH
84700: LD_INT 104
84702: EQUAL
84703: IFFALSE 84713
// sReset := true ;
84705: LD_ADDR_EXP 135
84709: PUSH
84710: LD_INT 1
84712: ST_TO_ADDR
// if p3 = 105 then
84713: LD_VAR 0 3
84717: PUSH
84718: LD_INT 105
84720: EQUAL
84721: IFFALSE 84731
// sSun := true ;
84723: LD_ADDR_EXP 136
84727: PUSH
84728: LD_INT 1
84730: ST_TO_ADDR
// if p3 = 106 then
84731: LD_VAR 0 3
84735: PUSH
84736: LD_INT 106
84738: EQUAL
84739: IFFALSE 84749
// sTiger := true ;
84741: LD_ADDR_EXP 132
84745: PUSH
84746: LD_INT 1
84748: ST_TO_ADDR
// if p3 = 107 then
84749: LD_VAR 0 3
84753: PUSH
84754: LD_INT 107
84756: EQUAL
84757: IFFALSE 84767
// sBomb := true ;
84759: LD_ADDR_EXP 133
84763: PUSH
84764: LD_INT 1
84766: ST_TO_ADDR
// if p3 = 108 then
84767: LD_VAR 0 3
84771: PUSH
84772: LD_INT 108
84774: EQUAL
84775: IFFALSE 84785
// sWound := true ;
84777: LD_ADDR_EXP 141
84781: PUSH
84782: LD_INT 1
84784: ST_TO_ADDR
// if p3 = 109 then
84785: LD_VAR 0 3
84789: PUSH
84790: LD_INT 109
84792: EQUAL
84793: IFFALSE 84803
// sBetray := true ;
84795: LD_ADDR_EXP 145
84799: PUSH
84800: LD_INT 1
84802: ST_TO_ADDR
// if p3 = 110 then
84803: LD_VAR 0 3
84807: PUSH
84808: LD_INT 110
84810: EQUAL
84811: IFFALSE 84821
// sContamin := true ;
84813: LD_ADDR_EXP 146
84817: PUSH
84818: LD_INT 1
84820: ST_TO_ADDR
// if p3 = 111 then
84821: LD_VAR 0 3
84825: PUSH
84826: LD_INT 111
84828: EQUAL
84829: IFFALSE 84839
// sOil := true ;
84831: LD_ADDR_EXP 148
84835: PUSH
84836: LD_INT 1
84838: ST_TO_ADDR
// if p3 = 112 then
84839: LD_VAR 0 3
84843: PUSH
84844: LD_INT 112
84846: EQUAL
84847: IFFALSE 84857
// sStu := true ;
84849: LD_ADDR_EXP 152
84853: PUSH
84854: LD_INT 1
84856: ST_TO_ADDR
// if p3 = 113 then
84857: LD_VAR 0 3
84861: PUSH
84862: LD_INT 113
84864: EQUAL
84865: IFFALSE 84875
// sBazooka := true ;
84867: LD_ADDR_EXP 155
84871: PUSH
84872: LD_INT 1
84874: ST_TO_ADDR
// if p3 = 114 then
84875: LD_VAR 0 3
84879: PUSH
84880: LD_INT 114
84882: EQUAL
84883: IFFALSE 84893
// sMortar := true ;
84885: LD_ADDR_EXP 156
84889: PUSH
84890: LD_INT 1
84892: ST_TO_ADDR
// if p3 = 115 then
84893: LD_VAR 0 3
84897: PUSH
84898: LD_INT 115
84900: EQUAL
84901: IFFALSE 84911
// sRanger := true ;
84903: LD_ADDR_EXP 166
84907: PUSH
84908: LD_INT 1
84910: ST_TO_ADDR
// if p3 = 116 then
84911: LD_VAR 0 3
84915: PUSH
84916: LD_INT 116
84918: EQUAL
84919: IFFALSE 84929
// sComputer := true ;
84921: LD_ADDR_EXP 167
84925: PUSH
84926: LD_INT 1
84928: ST_TO_ADDR
// if p3 = 117 then
84929: LD_VAR 0 3
84933: PUSH
84934: LD_INT 117
84936: EQUAL
84937: IFFALSE 84947
// s30 := true ;
84939: LD_ADDR_EXP 168
84943: PUSH
84944: LD_INT 1
84946: ST_TO_ADDR
// if p3 = 118 then
84947: LD_VAR 0 3
84951: PUSH
84952: LD_INT 118
84954: EQUAL
84955: IFFALSE 84965
// s60 := true ;
84957: LD_ADDR_EXP 169
84961: PUSH
84962: LD_INT 1
84964: ST_TO_ADDR
// end ; if p2 = 101 then
84965: LD_VAR 0 2
84969: PUSH
84970: LD_INT 101
84972: EQUAL
84973: IFFALSE 85101
// begin case p3 of 1 :
84975: LD_VAR 0 3
84979: PUSH
84980: LD_INT 1
84982: DOUBLE
84983: EQUAL
84984: IFTRUE 84988
84986: GO 84995
84988: POP
// hHackUnlimitedResources ; 2 :
84989: CALL 96697 0 0
84993: GO 85101
84995: LD_INT 2
84997: DOUBLE
84998: EQUAL
84999: IFTRUE 85003
85001: GO 85010
85003: POP
// hHackSetLevel10 ; 3 :
85004: CALL 96830 0 0
85008: GO 85101
85010: LD_INT 3
85012: DOUBLE
85013: EQUAL
85014: IFTRUE 85018
85016: GO 85025
85018: POP
// hHackSetLevel10YourUnits ; 4 :
85019: CALL 96915 0 0
85023: GO 85101
85025: LD_INT 4
85027: DOUBLE
85028: EQUAL
85029: IFTRUE 85033
85031: GO 85040
85033: POP
// hHackInvincible ; 5 :
85034: CALL 97363 0 0
85038: GO 85101
85040: LD_INT 5
85042: DOUBLE
85043: EQUAL
85044: IFTRUE 85048
85046: GO 85055
85048: POP
// hHackInvisible ; 6 :
85049: CALL 97474 0 0
85053: GO 85101
85055: LD_INT 6
85057: DOUBLE
85058: EQUAL
85059: IFTRUE 85063
85061: GO 85070
85063: POP
// hHackChangeYourSide ; 7 :
85064: CALL 97531 0 0
85068: GO 85101
85070: LD_INT 7
85072: DOUBLE
85073: EQUAL
85074: IFTRUE 85078
85076: GO 85085
85078: POP
// hHackChangeUnitSide ; 8 :
85079: CALL 97573 0 0
85083: GO 85101
85085: LD_INT 8
85087: DOUBLE
85088: EQUAL
85089: IFTRUE 85093
85091: GO 85100
85093: POP
// hHackFog ; end ;
85094: CALL 97674 0 0
85098: GO 85101
85100: POP
// end ; end ;
85101: LD_VAR 0 7
85105: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
85106: GO 85108
85108: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
85109: LD_STRING initStreamRollete();
85111: PPUSH
85112: CALL_OW 559
// InitStreamMode ;
85116: CALL 85125 0 0
// DefineStreamItems ( ) ;
85120: CALL 85589 0 0
// end ;
85124: END
// function InitStreamMode ; begin
85125: LD_INT 0
85127: PPUSH
// streamModeActive := false ;
85128: LD_ADDR_EXP 113
85132: PUSH
85133: LD_INT 0
85135: ST_TO_ADDR
// normalCounter := 36 ;
85136: LD_ADDR_EXP 114
85140: PUSH
85141: LD_INT 36
85143: ST_TO_ADDR
// hardcoreCounter := 16 ;
85144: LD_ADDR_EXP 115
85148: PUSH
85149: LD_INT 16
85151: ST_TO_ADDR
// sRocket := false ;
85152: LD_ADDR_EXP 118
85156: PUSH
85157: LD_INT 0
85159: ST_TO_ADDR
// sSpeed := false ;
85160: LD_ADDR_EXP 117
85164: PUSH
85165: LD_INT 0
85167: ST_TO_ADDR
// sEngine := false ;
85168: LD_ADDR_EXP 119
85172: PUSH
85173: LD_INT 0
85175: ST_TO_ADDR
// sSpec := false ;
85176: LD_ADDR_EXP 116
85180: PUSH
85181: LD_INT 0
85183: ST_TO_ADDR
// sLevel := false ;
85184: LD_ADDR_EXP 120
85188: PUSH
85189: LD_INT 0
85191: ST_TO_ADDR
// sArmoury := false ;
85192: LD_ADDR_EXP 121
85196: PUSH
85197: LD_INT 0
85199: ST_TO_ADDR
// sRadar := false ;
85200: LD_ADDR_EXP 122
85204: PUSH
85205: LD_INT 0
85207: ST_TO_ADDR
// sBunker := false ;
85208: LD_ADDR_EXP 123
85212: PUSH
85213: LD_INT 0
85215: ST_TO_ADDR
// sHack := false ;
85216: LD_ADDR_EXP 124
85220: PUSH
85221: LD_INT 0
85223: ST_TO_ADDR
// sFire := false ;
85224: LD_ADDR_EXP 125
85228: PUSH
85229: LD_INT 0
85231: ST_TO_ADDR
// sRefresh := false ;
85232: LD_ADDR_EXP 126
85236: PUSH
85237: LD_INT 0
85239: ST_TO_ADDR
// sExp := false ;
85240: LD_ADDR_EXP 127
85244: PUSH
85245: LD_INT 0
85247: ST_TO_ADDR
// sDepot := false ;
85248: LD_ADDR_EXP 128
85252: PUSH
85253: LD_INT 0
85255: ST_TO_ADDR
// sFlag := false ;
85256: LD_ADDR_EXP 129
85260: PUSH
85261: LD_INT 0
85263: ST_TO_ADDR
// sKamikadze := false ;
85264: LD_ADDR_EXP 137
85268: PUSH
85269: LD_INT 0
85271: ST_TO_ADDR
// sTroll := false ;
85272: LD_ADDR_EXP 138
85276: PUSH
85277: LD_INT 0
85279: ST_TO_ADDR
// sSlow := false ;
85280: LD_ADDR_EXP 139
85284: PUSH
85285: LD_INT 0
85287: ST_TO_ADDR
// sLack := false ;
85288: LD_ADDR_EXP 140
85292: PUSH
85293: LD_INT 0
85295: ST_TO_ADDR
// sTank := false ;
85296: LD_ADDR_EXP 142
85300: PUSH
85301: LD_INT 0
85303: ST_TO_ADDR
// sRemote := false ;
85304: LD_ADDR_EXP 143
85308: PUSH
85309: LD_INT 0
85311: ST_TO_ADDR
// sPowell := false ;
85312: LD_ADDR_EXP 144
85316: PUSH
85317: LD_INT 0
85319: ST_TO_ADDR
// sTeleport := false ;
85320: LD_ADDR_EXP 147
85324: PUSH
85325: LD_INT 0
85327: ST_TO_ADDR
// sOilTower := false ;
85328: LD_ADDR_EXP 149
85332: PUSH
85333: LD_INT 0
85335: ST_TO_ADDR
// sShovel := false ;
85336: LD_ADDR_EXP 150
85340: PUSH
85341: LD_INT 0
85343: ST_TO_ADDR
// sSheik := false ;
85344: LD_ADDR_EXP 151
85348: PUSH
85349: LD_INT 0
85351: ST_TO_ADDR
// sEarthquake := false ;
85352: LD_ADDR_EXP 153
85356: PUSH
85357: LD_INT 0
85359: ST_TO_ADDR
// sAI := false ;
85360: LD_ADDR_EXP 154
85364: PUSH
85365: LD_INT 0
85367: ST_TO_ADDR
// sCargo := false ;
85368: LD_ADDR_EXP 157
85372: PUSH
85373: LD_INT 0
85375: ST_TO_ADDR
// sDLaser := false ;
85376: LD_ADDR_EXP 158
85380: PUSH
85381: LD_INT 0
85383: ST_TO_ADDR
// sExchange := false ;
85384: LD_ADDR_EXP 159
85388: PUSH
85389: LD_INT 0
85391: ST_TO_ADDR
// sFac := false ;
85392: LD_ADDR_EXP 160
85396: PUSH
85397: LD_INT 0
85399: ST_TO_ADDR
// sPower := false ;
85400: LD_ADDR_EXP 161
85404: PUSH
85405: LD_INT 0
85407: ST_TO_ADDR
// sRandom := false ;
85408: LD_ADDR_EXP 162
85412: PUSH
85413: LD_INT 0
85415: ST_TO_ADDR
// sShield := false ;
85416: LD_ADDR_EXP 163
85420: PUSH
85421: LD_INT 0
85423: ST_TO_ADDR
// sTime := false ;
85424: LD_ADDR_EXP 164
85428: PUSH
85429: LD_INT 0
85431: ST_TO_ADDR
// sTools := false ;
85432: LD_ADDR_EXP 165
85436: PUSH
85437: LD_INT 0
85439: ST_TO_ADDR
// sSold := false ;
85440: LD_ADDR_EXP 130
85444: PUSH
85445: LD_INT 0
85447: ST_TO_ADDR
// sDiff := false ;
85448: LD_ADDR_EXP 131
85452: PUSH
85453: LD_INT 0
85455: ST_TO_ADDR
// sFog := false ;
85456: LD_ADDR_EXP 134
85460: PUSH
85461: LD_INT 0
85463: ST_TO_ADDR
// sReset := false ;
85464: LD_ADDR_EXP 135
85468: PUSH
85469: LD_INT 0
85471: ST_TO_ADDR
// sSun := false ;
85472: LD_ADDR_EXP 136
85476: PUSH
85477: LD_INT 0
85479: ST_TO_ADDR
// sTiger := false ;
85480: LD_ADDR_EXP 132
85484: PUSH
85485: LD_INT 0
85487: ST_TO_ADDR
// sBomb := false ;
85488: LD_ADDR_EXP 133
85492: PUSH
85493: LD_INT 0
85495: ST_TO_ADDR
// sWound := false ;
85496: LD_ADDR_EXP 141
85500: PUSH
85501: LD_INT 0
85503: ST_TO_ADDR
// sBetray := false ;
85504: LD_ADDR_EXP 145
85508: PUSH
85509: LD_INT 0
85511: ST_TO_ADDR
// sContamin := false ;
85512: LD_ADDR_EXP 146
85516: PUSH
85517: LD_INT 0
85519: ST_TO_ADDR
// sOil := false ;
85520: LD_ADDR_EXP 148
85524: PUSH
85525: LD_INT 0
85527: ST_TO_ADDR
// sStu := false ;
85528: LD_ADDR_EXP 152
85532: PUSH
85533: LD_INT 0
85535: ST_TO_ADDR
// sBazooka := false ;
85536: LD_ADDR_EXP 155
85540: PUSH
85541: LD_INT 0
85543: ST_TO_ADDR
// sMortar := false ;
85544: LD_ADDR_EXP 156
85548: PUSH
85549: LD_INT 0
85551: ST_TO_ADDR
// sRanger := false ;
85552: LD_ADDR_EXP 166
85556: PUSH
85557: LD_INT 0
85559: ST_TO_ADDR
// sComputer := false ;
85560: LD_ADDR_EXP 167
85564: PUSH
85565: LD_INT 0
85567: ST_TO_ADDR
// s30 := false ;
85568: LD_ADDR_EXP 168
85572: PUSH
85573: LD_INT 0
85575: ST_TO_ADDR
// s60 := false ;
85576: LD_ADDR_EXP 169
85580: PUSH
85581: LD_INT 0
85583: ST_TO_ADDR
// end ;
85584: LD_VAR 0 1
85588: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
85589: LD_INT 0
85591: PPUSH
85592: PPUSH
85593: PPUSH
85594: PPUSH
85595: PPUSH
// result := [ ] ;
85596: LD_ADDR_VAR 0 1
85600: PUSH
85601: EMPTY
85602: ST_TO_ADDR
// if campaign_id = 1 then
85603: LD_OWVAR 69
85607: PUSH
85608: LD_INT 1
85610: EQUAL
85611: IFFALSE 88777
// begin case mission_number of 1 :
85613: LD_OWVAR 70
85617: PUSH
85618: LD_INT 1
85620: DOUBLE
85621: EQUAL
85622: IFTRUE 85626
85624: GO 85702
85626: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
85627: LD_ADDR_VAR 0 1
85631: PUSH
85632: LD_INT 2
85634: PUSH
85635: LD_INT 4
85637: PUSH
85638: LD_INT 11
85640: PUSH
85641: LD_INT 12
85643: PUSH
85644: LD_INT 15
85646: PUSH
85647: LD_INT 16
85649: PUSH
85650: LD_INT 22
85652: PUSH
85653: LD_INT 23
85655: PUSH
85656: LD_INT 26
85658: PUSH
85659: EMPTY
85660: LIST
85661: LIST
85662: LIST
85663: LIST
85664: LIST
85665: LIST
85666: LIST
85667: LIST
85668: LIST
85669: PUSH
85670: LD_INT 101
85672: PUSH
85673: LD_INT 102
85675: PUSH
85676: LD_INT 106
85678: PUSH
85679: LD_INT 116
85681: PUSH
85682: LD_INT 117
85684: PUSH
85685: LD_INT 118
85687: PUSH
85688: EMPTY
85689: LIST
85690: LIST
85691: LIST
85692: LIST
85693: LIST
85694: LIST
85695: PUSH
85696: EMPTY
85697: LIST
85698: LIST
85699: ST_TO_ADDR
85700: GO 88775
85702: LD_INT 2
85704: DOUBLE
85705: EQUAL
85706: IFTRUE 85710
85708: GO 85794
85710: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
85711: LD_ADDR_VAR 0 1
85715: PUSH
85716: LD_INT 2
85718: PUSH
85719: LD_INT 4
85721: PUSH
85722: LD_INT 11
85724: PUSH
85725: LD_INT 12
85727: PUSH
85728: LD_INT 15
85730: PUSH
85731: LD_INT 16
85733: PUSH
85734: LD_INT 22
85736: PUSH
85737: LD_INT 23
85739: PUSH
85740: LD_INT 26
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: PUSH
85754: LD_INT 101
85756: PUSH
85757: LD_INT 102
85759: PUSH
85760: LD_INT 105
85762: PUSH
85763: LD_INT 106
85765: PUSH
85766: LD_INT 108
85768: PUSH
85769: LD_INT 116
85771: PUSH
85772: LD_INT 117
85774: PUSH
85775: LD_INT 118
85777: PUSH
85778: EMPTY
85779: LIST
85780: LIST
85781: LIST
85782: LIST
85783: LIST
85784: LIST
85785: LIST
85786: LIST
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: ST_TO_ADDR
85792: GO 88775
85794: LD_INT 3
85796: DOUBLE
85797: EQUAL
85798: IFTRUE 85802
85800: GO 85890
85802: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
85803: LD_ADDR_VAR 0 1
85807: PUSH
85808: LD_INT 2
85810: PUSH
85811: LD_INT 4
85813: PUSH
85814: LD_INT 5
85816: PUSH
85817: LD_INT 11
85819: PUSH
85820: LD_INT 12
85822: PUSH
85823: LD_INT 15
85825: PUSH
85826: LD_INT 16
85828: PUSH
85829: LD_INT 22
85831: PUSH
85832: LD_INT 26
85834: PUSH
85835: LD_INT 36
85837: PUSH
85838: EMPTY
85839: LIST
85840: LIST
85841: LIST
85842: LIST
85843: LIST
85844: LIST
85845: LIST
85846: LIST
85847: LIST
85848: LIST
85849: PUSH
85850: LD_INT 101
85852: PUSH
85853: LD_INT 102
85855: PUSH
85856: LD_INT 105
85858: PUSH
85859: LD_INT 106
85861: PUSH
85862: LD_INT 108
85864: PUSH
85865: LD_INT 116
85867: PUSH
85868: LD_INT 117
85870: PUSH
85871: LD_INT 118
85873: PUSH
85874: EMPTY
85875: LIST
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: PUSH
85884: EMPTY
85885: LIST
85886: LIST
85887: ST_TO_ADDR
85888: GO 88775
85890: LD_INT 4
85892: DOUBLE
85893: EQUAL
85894: IFTRUE 85898
85896: GO 85994
85898: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
85899: LD_ADDR_VAR 0 1
85903: PUSH
85904: LD_INT 2
85906: PUSH
85907: LD_INT 4
85909: PUSH
85910: LD_INT 5
85912: PUSH
85913: LD_INT 8
85915: PUSH
85916: LD_INT 11
85918: PUSH
85919: LD_INT 12
85921: PUSH
85922: LD_INT 15
85924: PUSH
85925: LD_INT 16
85927: PUSH
85928: LD_INT 22
85930: PUSH
85931: LD_INT 23
85933: PUSH
85934: LD_INT 26
85936: PUSH
85937: LD_INT 36
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: LIST
85944: LIST
85945: LIST
85946: LIST
85947: LIST
85948: LIST
85949: LIST
85950: LIST
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 101
85956: PUSH
85957: LD_INT 102
85959: PUSH
85960: LD_INT 105
85962: PUSH
85963: LD_INT 106
85965: PUSH
85966: LD_INT 108
85968: PUSH
85969: LD_INT 116
85971: PUSH
85972: LD_INT 117
85974: PUSH
85975: LD_INT 118
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: LIST
85982: LIST
85983: LIST
85984: LIST
85985: LIST
85986: LIST
85987: PUSH
85988: EMPTY
85989: LIST
85990: LIST
85991: ST_TO_ADDR
85992: GO 88775
85994: LD_INT 5
85996: DOUBLE
85997: EQUAL
85998: IFTRUE 86002
86000: GO 86114
86002: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
86003: LD_ADDR_VAR 0 1
86007: PUSH
86008: LD_INT 2
86010: PUSH
86011: LD_INT 4
86013: PUSH
86014: LD_INT 5
86016: PUSH
86017: LD_INT 6
86019: PUSH
86020: LD_INT 8
86022: PUSH
86023: LD_INT 11
86025: PUSH
86026: LD_INT 12
86028: PUSH
86029: LD_INT 15
86031: PUSH
86032: LD_INT 16
86034: PUSH
86035: LD_INT 22
86037: PUSH
86038: LD_INT 23
86040: PUSH
86041: LD_INT 25
86043: PUSH
86044: LD_INT 26
86046: PUSH
86047: LD_INT 36
86049: PUSH
86050: EMPTY
86051: LIST
86052: LIST
86053: LIST
86054: LIST
86055: LIST
86056: LIST
86057: LIST
86058: LIST
86059: LIST
86060: LIST
86061: LIST
86062: LIST
86063: LIST
86064: LIST
86065: PUSH
86066: LD_INT 101
86068: PUSH
86069: LD_INT 102
86071: PUSH
86072: LD_INT 105
86074: PUSH
86075: LD_INT 106
86077: PUSH
86078: LD_INT 108
86080: PUSH
86081: LD_INT 109
86083: PUSH
86084: LD_INT 112
86086: PUSH
86087: LD_INT 116
86089: PUSH
86090: LD_INT 117
86092: PUSH
86093: LD_INT 118
86095: PUSH
86096: EMPTY
86097: LIST
86098: LIST
86099: LIST
86100: LIST
86101: LIST
86102: LIST
86103: LIST
86104: LIST
86105: LIST
86106: LIST
86107: PUSH
86108: EMPTY
86109: LIST
86110: LIST
86111: ST_TO_ADDR
86112: GO 88775
86114: LD_INT 6
86116: DOUBLE
86117: EQUAL
86118: IFTRUE 86122
86120: GO 86254
86122: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
86123: LD_ADDR_VAR 0 1
86127: PUSH
86128: LD_INT 2
86130: PUSH
86131: LD_INT 4
86133: PUSH
86134: LD_INT 5
86136: PUSH
86137: LD_INT 6
86139: PUSH
86140: LD_INT 8
86142: PUSH
86143: LD_INT 11
86145: PUSH
86146: LD_INT 12
86148: PUSH
86149: LD_INT 15
86151: PUSH
86152: LD_INT 16
86154: PUSH
86155: LD_INT 20
86157: PUSH
86158: LD_INT 21
86160: PUSH
86161: LD_INT 22
86163: PUSH
86164: LD_INT 23
86166: PUSH
86167: LD_INT 25
86169: PUSH
86170: LD_INT 26
86172: PUSH
86173: LD_INT 30
86175: PUSH
86176: LD_INT 31
86178: PUSH
86179: LD_INT 32
86181: PUSH
86182: LD_INT 36
86184: PUSH
86185: EMPTY
86186: LIST
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: LIST
86195: LIST
86196: LIST
86197: LIST
86198: LIST
86199: LIST
86200: LIST
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: PUSH
86206: LD_INT 101
86208: PUSH
86209: LD_INT 102
86211: PUSH
86212: LD_INT 105
86214: PUSH
86215: LD_INT 106
86217: PUSH
86218: LD_INT 108
86220: PUSH
86221: LD_INT 109
86223: PUSH
86224: LD_INT 112
86226: PUSH
86227: LD_INT 116
86229: PUSH
86230: LD_INT 117
86232: PUSH
86233: LD_INT 118
86235: PUSH
86236: EMPTY
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: LIST
86242: LIST
86243: LIST
86244: LIST
86245: LIST
86246: LIST
86247: PUSH
86248: EMPTY
86249: LIST
86250: LIST
86251: ST_TO_ADDR
86252: GO 88775
86254: LD_INT 7
86256: DOUBLE
86257: EQUAL
86258: IFTRUE 86262
86260: GO 86374
86262: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
86263: LD_ADDR_VAR 0 1
86267: PUSH
86268: LD_INT 2
86270: PUSH
86271: LD_INT 4
86273: PUSH
86274: LD_INT 5
86276: PUSH
86277: LD_INT 7
86279: PUSH
86280: LD_INT 11
86282: PUSH
86283: LD_INT 12
86285: PUSH
86286: LD_INT 15
86288: PUSH
86289: LD_INT 16
86291: PUSH
86292: LD_INT 20
86294: PUSH
86295: LD_INT 21
86297: PUSH
86298: LD_INT 22
86300: PUSH
86301: LD_INT 23
86303: PUSH
86304: LD_INT 25
86306: PUSH
86307: LD_INT 26
86309: PUSH
86310: EMPTY
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: LIST
86323: LIST
86324: LIST
86325: PUSH
86326: LD_INT 101
86328: PUSH
86329: LD_INT 102
86331: PUSH
86332: LD_INT 103
86334: PUSH
86335: LD_INT 105
86337: PUSH
86338: LD_INT 106
86340: PUSH
86341: LD_INT 108
86343: PUSH
86344: LD_INT 112
86346: PUSH
86347: LD_INT 116
86349: PUSH
86350: LD_INT 117
86352: PUSH
86353: LD_INT 118
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: LIST
86360: LIST
86361: LIST
86362: LIST
86363: LIST
86364: LIST
86365: LIST
86366: LIST
86367: PUSH
86368: EMPTY
86369: LIST
86370: LIST
86371: ST_TO_ADDR
86372: GO 88775
86374: LD_INT 8
86376: DOUBLE
86377: EQUAL
86378: IFTRUE 86382
86380: GO 86522
86382: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
86383: LD_ADDR_VAR 0 1
86387: PUSH
86388: LD_INT 2
86390: PUSH
86391: LD_INT 4
86393: PUSH
86394: LD_INT 5
86396: PUSH
86397: LD_INT 6
86399: PUSH
86400: LD_INT 7
86402: PUSH
86403: LD_INT 8
86405: PUSH
86406: LD_INT 11
86408: PUSH
86409: LD_INT 12
86411: PUSH
86412: LD_INT 15
86414: PUSH
86415: LD_INT 16
86417: PUSH
86418: LD_INT 20
86420: PUSH
86421: LD_INT 21
86423: PUSH
86424: LD_INT 22
86426: PUSH
86427: LD_INT 23
86429: PUSH
86430: LD_INT 25
86432: PUSH
86433: LD_INT 26
86435: PUSH
86436: LD_INT 30
86438: PUSH
86439: LD_INT 31
86441: PUSH
86442: LD_INT 32
86444: PUSH
86445: LD_INT 36
86447: PUSH
86448: EMPTY
86449: LIST
86450: LIST
86451: LIST
86452: LIST
86453: LIST
86454: LIST
86455: LIST
86456: LIST
86457: LIST
86458: LIST
86459: LIST
86460: LIST
86461: LIST
86462: LIST
86463: LIST
86464: LIST
86465: LIST
86466: LIST
86467: LIST
86468: LIST
86469: PUSH
86470: LD_INT 101
86472: PUSH
86473: LD_INT 102
86475: PUSH
86476: LD_INT 103
86478: PUSH
86479: LD_INT 105
86481: PUSH
86482: LD_INT 106
86484: PUSH
86485: LD_INT 108
86487: PUSH
86488: LD_INT 109
86490: PUSH
86491: LD_INT 112
86493: PUSH
86494: LD_INT 116
86496: PUSH
86497: LD_INT 117
86499: PUSH
86500: LD_INT 118
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: LIST
86507: LIST
86508: LIST
86509: LIST
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: ST_TO_ADDR
86520: GO 88775
86522: LD_INT 9
86524: DOUBLE
86525: EQUAL
86526: IFTRUE 86530
86528: GO 86678
86530: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
86531: LD_ADDR_VAR 0 1
86535: PUSH
86536: LD_INT 2
86538: PUSH
86539: LD_INT 4
86541: PUSH
86542: LD_INT 5
86544: PUSH
86545: LD_INT 6
86547: PUSH
86548: LD_INT 7
86550: PUSH
86551: LD_INT 8
86553: PUSH
86554: LD_INT 11
86556: PUSH
86557: LD_INT 12
86559: PUSH
86560: LD_INT 15
86562: PUSH
86563: LD_INT 16
86565: PUSH
86566: LD_INT 20
86568: PUSH
86569: LD_INT 21
86571: PUSH
86572: LD_INT 22
86574: PUSH
86575: LD_INT 23
86577: PUSH
86578: LD_INT 25
86580: PUSH
86581: LD_INT 26
86583: PUSH
86584: LD_INT 28
86586: PUSH
86587: LD_INT 30
86589: PUSH
86590: LD_INT 31
86592: PUSH
86593: LD_INT 32
86595: PUSH
86596: LD_INT 36
86598: PUSH
86599: EMPTY
86600: LIST
86601: LIST
86602: LIST
86603: LIST
86604: LIST
86605: LIST
86606: LIST
86607: LIST
86608: LIST
86609: LIST
86610: LIST
86611: LIST
86612: LIST
86613: LIST
86614: LIST
86615: LIST
86616: LIST
86617: LIST
86618: LIST
86619: LIST
86620: LIST
86621: PUSH
86622: LD_INT 101
86624: PUSH
86625: LD_INT 102
86627: PUSH
86628: LD_INT 103
86630: PUSH
86631: LD_INT 105
86633: PUSH
86634: LD_INT 106
86636: PUSH
86637: LD_INT 108
86639: PUSH
86640: LD_INT 109
86642: PUSH
86643: LD_INT 112
86645: PUSH
86646: LD_INT 114
86648: PUSH
86649: LD_INT 116
86651: PUSH
86652: LD_INT 117
86654: PUSH
86655: LD_INT 118
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: LIST
86662: LIST
86663: LIST
86664: LIST
86665: LIST
86666: LIST
86667: LIST
86668: LIST
86669: LIST
86670: LIST
86671: PUSH
86672: EMPTY
86673: LIST
86674: LIST
86675: ST_TO_ADDR
86676: GO 88775
86678: LD_INT 10
86680: DOUBLE
86681: EQUAL
86682: IFTRUE 86686
86684: GO 86882
86686: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
86687: LD_ADDR_VAR 0 1
86691: PUSH
86692: LD_INT 2
86694: PUSH
86695: LD_INT 4
86697: PUSH
86698: LD_INT 5
86700: PUSH
86701: LD_INT 6
86703: PUSH
86704: LD_INT 7
86706: PUSH
86707: LD_INT 8
86709: PUSH
86710: LD_INT 9
86712: PUSH
86713: LD_INT 10
86715: PUSH
86716: LD_INT 11
86718: PUSH
86719: LD_INT 12
86721: PUSH
86722: LD_INT 13
86724: PUSH
86725: LD_INT 14
86727: PUSH
86728: LD_INT 15
86730: PUSH
86731: LD_INT 16
86733: PUSH
86734: LD_INT 17
86736: PUSH
86737: LD_INT 18
86739: PUSH
86740: LD_INT 19
86742: PUSH
86743: LD_INT 20
86745: PUSH
86746: LD_INT 21
86748: PUSH
86749: LD_INT 22
86751: PUSH
86752: LD_INT 23
86754: PUSH
86755: LD_INT 24
86757: PUSH
86758: LD_INT 25
86760: PUSH
86761: LD_INT 26
86763: PUSH
86764: LD_INT 28
86766: PUSH
86767: LD_INT 30
86769: PUSH
86770: LD_INT 31
86772: PUSH
86773: LD_INT 32
86775: PUSH
86776: LD_INT 36
86778: PUSH
86779: EMPTY
86780: LIST
86781: LIST
86782: LIST
86783: LIST
86784: LIST
86785: LIST
86786: LIST
86787: LIST
86788: LIST
86789: LIST
86790: LIST
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: LIST
86800: LIST
86801: LIST
86802: LIST
86803: LIST
86804: LIST
86805: LIST
86806: LIST
86807: LIST
86808: LIST
86809: PUSH
86810: LD_INT 101
86812: PUSH
86813: LD_INT 102
86815: PUSH
86816: LD_INT 103
86818: PUSH
86819: LD_INT 104
86821: PUSH
86822: LD_INT 105
86824: PUSH
86825: LD_INT 106
86827: PUSH
86828: LD_INT 107
86830: PUSH
86831: LD_INT 108
86833: PUSH
86834: LD_INT 109
86836: PUSH
86837: LD_INT 110
86839: PUSH
86840: LD_INT 111
86842: PUSH
86843: LD_INT 112
86845: PUSH
86846: LD_INT 114
86848: PUSH
86849: LD_INT 116
86851: PUSH
86852: LD_INT 117
86854: PUSH
86855: LD_INT 118
86857: PUSH
86858: EMPTY
86859: LIST
86860: LIST
86861: LIST
86862: LIST
86863: LIST
86864: LIST
86865: LIST
86866: LIST
86867: LIST
86868: LIST
86869: LIST
86870: LIST
86871: LIST
86872: LIST
86873: LIST
86874: LIST
86875: PUSH
86876: EMPTY
86877: LIST
86878: LIST
86879: ST_TO_ADDR
86880: GO 88775
86882: LD_INT 11
86884: DOUBLE
86885: EQUAL
86886: IFTRUE 86890
86888: GO 87094
86890: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
86891: LD_ADDR_VAR 0 1
86895: PUSH
86896: LD_INT 2
86898: PUSH
86899: LD_INT 3
86901: PUSH
86902: LD_INT 4
86904: PUSH
86905: LD_INT 5
86907: PUSH
86908: LD_INT 6
86910: PUSH
86911: LD_INT 7
86913: PUSH
86914: LD_INT 8
86916: PUSH
86917: LD_INT 9
86919: PUSH
86920: LD_INT 10
86922: PUSH
86923: LD_INT 11
86925: PUSH
86926: LD_INT 12
86928: PUSH
86929: LD_INT 13
86931: PUSH
86932: LD_INT 14
86934: PUSH
86935: LD_INT 15
86937: PUSH
86938: LD_INT 16
86940: PUSH
86941: LD_INT 17
86943: PUSH
86944: LD_INT 18
86946: PUSH
86947: LD_INT 19
86949: PUSH
86950: LD_INT 20
86952: PUSH
86953: LD_INT 21
86955: PUSH
86956: LD_INT 22
86958: PUSH
86959: LD_INT 23
86961: PUSH
86962: LD_INT 24
86964: PUSH
86965: LD_INT 25
86967: PUSH
86968: LD_INT 26
86970: PUSH
86971: LD_INT 28
86973: PUSH
86974: LD_INT 30
86976: PUSH
86977: LD_INT 31
86979: PUSH
86980: LD_INT 32
86982: PUSH
86983: LD_INT 34
86985: PUSH
86986: LD_INT 36
86988: PUSH
86989: EMPTY
86990: LIST
86991: LIST
86992: LIST
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: LIST
86998: LIST
86999: LIST
87000: LIST
87001: LIST
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: LIST
87020: LIST
87021: PUSH
87022: LD_INT 101
87024: PUSH
87025: LD_INT 102
87027: PUSH
87028: LD_INT 103
87030: PUSH
87031: LD_INT 104
87033: PUSH
87034: LD_INT 105
87036: PUSH
87037: LD_INT 106
87039: PUSH
87040: LD_INT 107
87042: PUSH
87043: LD_INT 108
87045: PUSH
87046: LD_INT 109
87048: PUSH
87049: LD_INT 110
87051: PUSH
87052: LD_INT 111
87054: PUSH
87055: LD_INT 112
87057: PUSH
87058: LD_INT 114
87060: PUSH
87061: LD_INT 116
87063: PUSH
87064: LD_INT 117
87066: PUSH
87067: LD_INT 118
87069: PUSH
87070: EMPTY
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: LIST
87076: LIST
87077: LIST
87078: LIST
87079: LIST
87080: LIST
87081: LIST
87082: LIST
87083: LIST
87084: LIST
87085: LIST
87086: LIST
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: ST_TO_ADDR
87092: GO 88775
87094: LD_INT 12
87096: DOUBLE
87097: EQUAL
87098: IFTRUE 87102
87100: GO 87322
87102: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
87103: LD_ADDR_VAR 0 1
87107: PUSH
87108: LD_INT 1
87110: PUSH
87111: LD_INT 2
87113: PUSH
87114: LD_INT 3
87116: PUSH
87117: LD_INT 4
87119: PUSH
87120: LD_INT 5
87122: PUSH
87123: LD_INT 6
87125: PUSH
87126: LD_INT 7
87128: PUSH
87129: LD_INT 8
87131: PUSH
87132: LD_INT 9
87134: PUSH
87135: LD_INT 10
87137: PUSH
87138: LD_INT 11
87140: PUSH
87141: LD_INT 12
87143: PUSH
87144: LD_INT 13
87146: PUSH
87147: LD_INT 14
87149: PUSH
87150: LD_INT 15
87152: PUSH
87153: LD_INT 16
87155: PUSH
87156: LD_INT 17
87158: PUSH
87159: LD_INT 18
87161: PUSH
87162: LD_INT 19
87164: PUSH
87165: LD_INT 20
87167: PUSH
87168: LD_INT 21
87170: PUSH
87171: LD_INT 22
87173: PUSH
87174: LD_INT 23
87176: PUSH
87177: LD_INT 24
87179: PUSH
87180: LD_INT 25
87182: PUSH
87183: LD_INT 26
87185: PUSH
87186: LD_INT 27
87188: PUSH
87189: LD_INT 28
87191: PUSH
87192: LD_INT 30
87194: PUSH
87195: LD_INT 31
87197: PUSH
87198: LD_INT 32
87200: PUSH
87201: LD_INT 33
87203: PUSH
87204: LD_INT 34
87206: PUSH
87207: LD_INT 36
87209: PUSH
87210: EMPTY
87211: LIST
87212: LIST
87213: LIST
87214: LIST
87215: LIST
87216: LIST
87217: LIST
87218: LIST
87219: LIST
87220: LIST
87221: LIST
87222: LIST
87223: LIST
87224: LIST
87225: LIST
87226: LIST
87227: LIST
87228: LIST
87229: LIST
87230: LIST
87231: LIST
87232: LIST
87233: LIST
87234: LIST
87235: LIST
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: PUSH
87246: LD_INT 101
87248: PUSH
87249: LD_INT 102
87251: PUSH
87252: LD_INT 103
87254: PUSH
87255: LD_INT 104
87257: PUSH
87258: LD_INT 105
87260: PUSH
87261: LD_INT 106
87263: PUSH
87264: LD_INT 107
87266: PUSH
87267: LD_INT 108
87269: PUSH
87270: LD_INT 109
87272: PUSH
87273: LD_INT 110
87275: PUSH
87276: LD_INT 111
87278: PUSH
87279: LD_INT 112
87281: PUSH
87282: LD_INT 113
87284: PUSH
87285: LD_INT 114
87287: PUSH
87288: LD_INT 116
87290: PUSH
87291: LD_INT 117
87293: PUSH
87294: LD_INT 118
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: LIST
87301: LIST
87302: LIST
87303: LIST
87304: LIST
87305: LIST
87306: LIST
87307: LIST
87308: LIST
87309: LIST
87310: LIST
87311: LIST
87312: LIST
87313: LIST
87314: LIST
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: ST_TO_ADDR
87320: GO 88775
87322: LD_INT 13
87324: DOUBLE
87325: EQUAL
87326: IFTRUE 87330
87328: GO 87538
87330: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
87331: LD_ADDR_VAR 0 1
87335: PUSH
87336: LD_INT 1
87338: PUSH
87339: LD_INT 2
87341: PUSH
87342: LD_INT 3
87344: PUSH
87345: LD_INT 4
87347: PUSH
87348: LD_INT 5
87350: PUSH
87351: LD_INT 8
87353: PUSH
87354: LD_INT 9
87356: PUSH
87357: LD_INT 10
87359: PUSH
87360: LD_INT 11
87362: PUSH
87363: LD_INT 12
87365: PUSH
87366: LD_INT 14
87368: PUSH
87369: LD_INT 15
87371: PUSH
87372: LD_INT 16
87374: PUSH
87375: LD_INT 17
87377: PUSH
87378: LD_INT 18
87380: PUSH
87381: LD_INT 19
87383: PUSH
87384: LD_INT 20
87386: PUSH
87387: LD_INT 21
87389: PUSH
87390: LD_INT 22
87392: PUSH
87393: LD_INT 23
87395: PUSH
87396: LD_INT 24
87398: PUSH
87399: LD_INT 25
87401: PUSH
87402: LD_INT 26
87404: PUSH
87405: LD_INT 27
87407: PUSH
87408: LD_INT 28
87410: PUSH
87411: LD_INT 30
87413: PUSH
87414: LD_INT 31
87416: PUSH
87417: LD_INT 32
87419: PUSH
87420: LD_INT 33
87422: PUSH
87423: LD_INT 34
87425: PUSH
87426: LD_INT 36
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: LIST
87433: LIST
87434: LIST
87435: LIST
87436: LIST
87437: LIST
87438: LIST
87439: LIST
87440: LIST
87441: LIST
87442: LIST
87443: LIST
87444: LIST
87445: LIST
87446: LIST
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: PUSH
87462: LD_INT 101
87464: PUSH
87465: LD_INT 102
87467: PUSH
87468: LD_INT 103
87470: PUSH
87471: LD_INT 104
87473: PUSH
87474: LD_INT 105
87476: PUSH
87477: LD_INT 106
87479: PUSH
87480: LD_INT 107
87482: PUSH
87483: LD_INT 108
87485: PUSH
87486: LD_INT 109
87488: PUSH
87489: LD_INT 110
87491: PUSH
87492: LD_INT 111
87494: PUSH
87495: LD_INT 112
87497: PUSH
87498: LD_INT 113
87500: PUSH
87501: LD_INT 114
87503: PUSH
87504: LD_INT 116
87506: PUSH
87507: LD_INT 117
87509: PUSH
87510: LD_INT 118
87512: PUSH
87513: EMPTY
87514: LIST
87515: LIST
87516: LIST
87517: LIST
87518: LIST
87519: LIST
87520: LIST
87521: LIST
87522: LIST
87523: LIST
87524: LIST
87525: LIST
87526: LIST
87527: LIST
87528: LIST
87529: LIST
87530: LIST
87531: PUSH
87532: EMPTY
87533: LIST
87534: LIST
87535: ST_TO_ADDR
87536: GO 88775
87538: LD_INT 14
87540: DOUBLE
87541: EQUAL
87542: IFTRUE 87546
87544: GO 87770
87546: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
87547: LD_ADDR_VAR 0 1
87551: PUSH
87552: LD_INT 1
87554: PUSH
87555: LD_INT 2
87557: PUSH
87558: LD_INT 3
87560: PUSH
87561: LD_INT 4
87563: PUSH
87564: LD_INT 5
87566: PUSH
87567: LD_INT 6
87569: PUSH
87570: LD_INT 7
87572: PUSH
87573: LD_INT 8
87575: PUSH
87576: LD_INT 9
87578: PUSH
87579: LD_INT 10
87581: PUSH
87582: LD_INT 11
87584: PUSH
87585: LD_INT 12
87587: PUSH
87588: LD_INT 13
87590: PUSH
87591: LD_INT 14
87593: PUSH
87594: LD_INT 15
87596: PUSH
87597: LD_INT 16
87599: PUSH
87600: LD_INT 17
87602: PUSH
87603: LD_INT 18
87605: PUSH
87606: LD_INT 19
87608: PUSH
87609: LD_INT 20
87611: PUSH
87612: LD_INT 21
87614: PUSH
87615: LD_INT 22
87617: PUSH
87618: LD_INT 23
87620: PUSH
87621: LD_INT 24
87623: PUSH
87624: LD_INT 25
87626: PUSH
87627: LD_INT 26
87629: PUSH
87630: LD_INT 27
87632: PUSH
87633: LD_INT 28
87635: PUSH
87636: LD_INT 29
87638: PUSH
87639: LD_INT 30
87641: PUSH
87642: LD_INT 31
87644: PUSH
87645: LD_INT 32
87647: PUSH
87648: LD_INT 33
87650: PUSH
87651: LD_INT 34
87653: PUSH
87654: LD_INT 36
87656: PUSH
87657: EMPTY
87658: LIST
87659: LIST
87660: LIST
87661: LIST
87662: LIST
87663: LIST
87664: LIST
87665: LIST
87666: LIST
87667: LIST
87668: LIST
87669: LIST
87670: LIST
87671: LIST
87672: LIST
87673: LIST
87674: LIST
87675: LIST
87676: LIST
87677: LIST
87678: LIST
87679: LIST
87680: LIST
87681: LIST
87682: LIST
87683: LIST
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: LIST
87691: LIST
87692: LIST
87693: PUSH
87694: LD_INT 101
87696: PUSH
87697: LD_INT 102
87699: PUSH
87700: LD_INT 103
87702: PUSH
87703: LD_INT 104
87705: PUSH
87706: LD_INT 105
87708: PUSH
87709: LD_INT 106
87711: PUSH
87712: LD_INT 107
87714: PUSH
87715: LD_INT 108
87717: PUSH
87718: LD_INT 109
87720: PUSH
87721: LD_INT 110
87723: PUSH
87724: LD_INT 111
87726: PUSH
87727: LD_INT 112
87729: PUSH
87730: LD_INT 113
87732: PUSH
87733: LD_INT 114
87735: PUSH
87736: LD_INT 116
87738: PUSH
87739: LD_INT 117
87741: PUSH
87742: LD_INT 118
87744: PUSH
87745: EMPTY
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: PUSH
87764: EMPTY
87765: LIST
87766: LIST
87767: ST_TO_ADDR
87768: GO 88775
87770: LD_INT 15
87772: DOUBLE
87773: EQUAL
87774: IFTRUE 87778
87776: GO 88002
87778: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
87779: LD_ADDR_VAR 0 1
87783: PUSH
87784: LD_INT 1
87786: PUSH
87787: LD_INT 2
87789: PUSH
87790: LD_INT 3
87792: PUSH
87793: LD_INT 4
87795: PUSH
87796: LD_INT 5
87798: PUSH
87799: LD_INT 6
87801: PUSH
87802: LD_INT 7
87804: PUSH
87805: LD_INT 8
87807: PUSH
87808: LD_INT 9
87810: PUSH
87811: LD_INT 10
87813: PUSH
87814: LD_INT 11
87816: PUSH
87817: LD_INT 12
87819: PUSH
87820: LD_INT 13
87822: PUSH
87823: LD_INT 14
87825: PUSH
87826: LD_INT 15
87828: PUSH
87829: LD_INT 16
87831: PUSH
87832: LD_INT 17
87834: PUSH
87835: LD_INT 18
87837: PUSH
87838: LD_INT 19
87840: PUSH
87841: LD_INT 20
87843: PUSH
87844: LD_INT 21
87846: PUSH
87847: LD_INT 22
87849: PUSH
87850: LD_INT 23
87852: PUSH
87853: LD_INT 24
87855: PUSH
87856: LD_INT 25
87858: PUSH
87859: LD_INT 26
87861: PUSH
87862: LD_INT 27
87864: PUSH
87865: LD_INT 28
87867: PUSH
87868: LD_INT 29
87870: PUSH
87871: LD_INT 30
87873: PUSH
87874: LD_INT 31
87876: PUSH
87877: LD_INT 32
87879: PUSH
87880: LD_INT 33
87882: PUSH
87883: LD_INT 34
87885: PUSH
87886: LD_INT 36
87888: PUSH
87889: EMPTY
87890: LIST
87891: LIST
87892: LIST
87893: LIST
87894: LIST
87895: LIST
87896: LIST
87897: LIST
87898: LIST
87899: LIST
87900: LIST
87901: LIST
87902: LIST
87903: LIST
87904: LIST
87905: LIST
87906: LIST
87907: LIST
87908: LIST
87909: LIST
87910: LIST
87911: LIST
87912: LIST
87913: LIST
87914: LIST
87915: LIST
87916: LIST
87917: LIST
87918: LIST
87919: LIST
87920: LIST
87921: LIST
87922: LIST
87923: LIST
87924: LIST
87925: PUSH
87926: LD_INT 101
87928: PUSH
87929: LD_INT 102
87931: PUSH
87932: LD_INT 103
87934: PUSH
87935: LD_INT 104
87937: PUSH
87938: LD_INT 105
87940: PUSH
87941: LD_INT 106
87943: PUSH
87944: LD_INT 107
87946: PUSH
87947: LD_INT 108
87949: PUSH
87950: LD_INT 109
87952: PUSH
87953: LD_INT 110
87955: PUSH
87956: LD_INT 111
87958: PUSH
87959: LD_INT 112
87961: PUSH
87962: LD_INT 113
87964: PUSH
87965: LD_INT 114
87967: PUSH
87968: LD_INT 116
87970: PUSH
87971: LD_INT 117
87973: PUSH
87974: LD_INT 118
87976: PUSH
87977: EMPTY
87978: LIST
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: LIST
87984: LIST
87985: LIST
87986: LIST
87987: LIST
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: PUSH
87996: EMPTY
87997: LIST
87998: LIST
87999: ST_TO_ADDR
88000: GO 88775
88002: LD_INT 16
88004: DOUBLE
88005: EQUAL
88006: IFTRUE 88010
88008: GO 88146
88010: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
88011: LD_ADDR_VAR 0 1
88015: PUSH
88016: LD_INT 2
88018: PUSH
88019: LD_INT 4
88021: PUSH
88022: LD_INT 5
88024: PUSH
88025: LD_INT 7
88027: PUSH
88028: LD_INT 11
88030: PUSH
88031: LD_INT 12
88033: PUSH
88034: LD_INT 15
88036: PUSH
88037: LD_INT 16
88039: PUSH
88040: LD_INT 20
88042: PUSH
88043: LD_INT 21
88045: PUSH
88046: LD_INT 22
88048: PUSH
88049: LD_INT 23
88051: PUSH
88052: LD_INT 25
88054: PUSH
88055: LD_INT 26
88057: PUSH
88058: LD_INT 30
88060: PUSH
88061: LD_INT 31
88063: PUSH
88064: LD_INT 32
88066: PUSH
88067: LD_INT 33
88069: PUSH
88070: LD_INT 34
88072: PUSH
88073: EMPTY
88074: LIST
88075: LIST
88076: LIST
88077: LIST
88078: LIST
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: PUSH
88094: LD_INT 101
88096: PUSH
88097: LD_INT 102
88099: PUSH
88100: LD_INT 103
88102: PUSH
88103: LD_INT 106
88105: PUSH
88106: LD_INT 108
88108: PUSH
88109: LD_INT 112
88111: PUSH
88112: LD_INT 113
88114: PUSH
88115: LD_INT 114
88117: PUSH
88118: LD_INT 116
88120: PUSH
88121: LD_INT 117
88123: PUSH
88124: LD_INT 118
88126: PUSH
88127: EMPTY
88128: LIST
88129: LIST
88130: LIST
88131: LIST
88132: LIST
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: LIST
88139: PUSH
88140: EMPTY
88141: LIST
88142: LIST
88143: ST_TO_ADDR
88144: GO 88775
88146: LD_INT 17
88148: DOUBLE
88149: EQUAL
88150: IFTRUE 88154
88152: GO 88378
88154: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
88155: LD_ADDR_VAR 0 1
88159: PUSH
88160: LD_INT 1
88162: PUSH
88163: LD_INT 2
88165: PUSH
88166: LD_INT 3
88168: PUSH
88169: LD_INT 4
88171: PUSH
88172: LD_INT 5
88174: PUSH
88175: LD_INT 6
88177: PUSH
88178: LD_INT 7
88180: PUSH
88181: LD_INT 8
88183: PUSH
88184: LD_INT 9
88186: PUSH
88187: LD_INT 10
88189: PUSH
88190: LD_INT 11
88192: PUSH
88193: LD_INT 12
88195: PUSH
88196: LD_INT 13
88198: PUSH
88199: LD_INT 14
88201: PUSH
88202: LD_INT 15
88204: PUSH
88205: LD_INT 16
88207: PUSH
88208: LD_INT 17
88210: PUSH
88211: LD_INT 18
88213: PUSH
88214: LD_INT 19
88216: PUSH
88217: LD_INT 20
88219: PUSH
88220: LD_INT 21
88222: PUSH
88223: LD_INT 22
88225: PUSH
88226: LD_INT 23
88228: PUSH
88229: LD_INT 24
88231: PUSH
88232: LD_INT 25
88234: PUSH
88235: LD_INT 26
88237: PUSH
88238: LD_INT 27
88240: PUSH
88241: LD_INT 28
88243: PUSH
88244: LD_INT 29
88246: PUSH
88247: LD_INT 30
88249: PUSH
88250: LD_INT 31
88252: PUSH
88253: LD_INT 32
88255: PUSH
88256: LD_INT 33
88258: PUSH
88259: LD_INT 34
88261: PUSH
88262: LD_INT 36
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: LIST
88269: LIST
88270: LIST
88271: LIST
88272: LIST
88273: LIST
88274: LIST
88275: LIST
88276: LIST
88277: LIST
88278: LIST
88279: LIST
88280: LIST
88281: LIST
88282: LIST
88283: LIST
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: LIST
88295: LIST
88296: LIST
88297: LIST
88298: LIST
88299: LIST
88300: LIST
88301: PUSH
88302: LD_INT 101
88304: PUSH
88305: LD_INT 102
88307: PUSH
88308: LD_INT 103
88310: PUSH
88311: LD_INT 104
88313: PUSH
88314: LD_INT 105
88316: PUSH
88317: LD_INT 106
88319: PUSH
88320: LD_INT 107
88322: PUSH
88323: LD_INT 108
88325: PUSH
88326: LD_INT 109
88328: PUSH
88329: LD_INT 110
88331: PUSH
88332: LD_INT 111
88334: PUSH
88335: LD_INT 112
88337: PUSH
88338: LD_INT 113
88340: PUSH
88341: LD_INT 114
88343: PUSH
88344: LD_INT 116
88346: PUSH
88347: LD_INT 117
88349: PUSH
88350: LD_INT 118
88352: PUSH
88353: EMPTY
88354: LIST
88355: LIST
88356: LIST
88357: LIST
88358: LIST
88359: LIST
88360: LIST
88361: LIST
88362: LIST
88363: LIST
88364: LIST
88365: LIST
88366: LIST
88367: LIST
88368: LIST
88369: LIST
88370: LIST
88371: PUSH
88372: EMPTY
88373: LIST
88374: LIST
88375: ST_TO_ADDR
88376: GO 88775
88378: LD_INT 18
88380: DOUBLE
88381: EQUAL
88382: IFTRUE 88386
88384: GO 88534
88386: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
88387: LD_ADDR_VAR 0 1
88391: PUSH
88392: LD_INT 2
88394: PUSH
88395: LD_INT 4
88397: PUSH
88398: LD_INT 5
88400: PUSH
88401: LD_INT 7
88403: PUSH
88404: LD_INT 11
88406: PUSH
88407: LD_INT 12
88409: PUSH
88410: LD_INT 15
88412: PUSH
88413: LD_INT 16
88415: PUSH
88416: LD_INT 20
88418: PUSH
88419: LD_INT 21
88421: PUSH
88422: LD_INT 22
88424: PUSH
88425: LD_INT 23
88427: PUSH
88428: LD_INT 25
88430: PUSH
88431: LD_INT 26
88433: PUSH
88434: LD_INT 30
88436: PUSH
88437: LD_INT 31
88439: PUSH
88440: LD_INT 32
88442: PUSH
88443: LD_INT 33
88445: PUSH
88446: LD_INT 34
88448: PUSH
88449: LD_INT 35
88451: PUSH
88452: LD_INT 36
88454: PUSH
88455: EMPTY
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: LIST
88466: LIST
88467: LIST
88468: LIST
88469: LIST
88470: LIST
88471: LIST
88472: LIST
88473: LIST
88474: LIST
88475: LIST
88476: LIST
88477: PUSH
88478: LD_INT 101
88480: PUSH
88481: LD_INT 102
88483: PUSH
88484: LD_INT 103
88486: PUSH
88487: LD_INT 106
88489: PUSH
88490: LD_INT 108
88492: PUSH
88493: LD_INT 112
88495: PUSH
88496: LD_INT 113
88498: PUSH
88499: LD_INT 114
88501: PUSH
88502: LD_INT 115
88504: PUSH
88505: LD_INT 116
88507: PUSH
88508: LD_INT 117
88510: PUSH
88511: LD_INT 118
88513: PUSH
88514: EMPTY
88515: LIST
88516: LIST
88517: LIST
88518: LIST
88519: LIST
88520: LIST
88521: LIST
88522: LIST
88523: LIST
88524: LIST
88525: LIST
88526: LIST
88527: PUSH
88528: EMPTY
88529: LIST
88530: LIST
88531: ST_TO_ADDR
88532: GO 88775
88534: LD_INT 19
88536: DOUBLE
88537: EQUAL
88538: IFTRUE 88542
88540: GO 88774
88542: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
88543: LD_ADDR_VAR 0 1
88547: PUSH
88548: LD_INT 1
88550: PUSH
88551: LD_INT 2
88553: PUSH
88554: LD_INT 3
88556: PUSH
88557: LD_INT 4
88559: PUSH
88560: LD_INT 5
88562: PUSH
88563: LD_INT 6
88565: PUSH
88566: LD_INT 7
88568: PUSH
88569: LD_INT 8
88571: PUSH
88572: LD_INT 9
88574: PUSH
88575: LD_INT 10
88577: PUSH
88578: LD_INT 11
88580: PUSH
88581: LD_INT 12
88583: PUSH
88584: LD_INT 13
88586: PUSH
88587: LD_INT 14
88589: PUSH
88590: LD_INT 15
88592: PUSH
88593: LD_INT 16
88595: PUSH
88596: LD_INT 17
88598: PUSH
88599: LD_INT 18
88601: PUSH
88602: LD_INT 19
88604: PUSH
88605: LD_INT 20
88607: PUSH
88608: LD_INT 21
88610: PUSH
88611: LD_INT 22
88613: PUSH
88614: LD_INT 23
88616: PUSH
88617: LD_INT 24
88619: PUSH
88620: LD_INT 25
88622: PUSH
88623: LD_INT 26
88625: PUSH
88626: LD_INT 27
88628: PUSH
88629: LD_INT 28
88631: PUSH
88632: LD_INT 29
88634: PUSH
88635: LD_INT 30
88637: PUSH
88638: LD_INT 31
88640: PUSH
88641: LD_INT 32
88643: PUSH
88644: LD_INT 33
88646: PUSH
88647: LD_INT 34
88649: PUSH
88650: LD_INT 35
88652: PUSH
88653: LD_INT 36
88655: PUSH
88656: EMPTY
88657: LIST
88658: LIST
88659: LIST
88660: LIST
88661: LIST
88662: LIST
88663: LIST
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: LIST
88672: LIST
88673: LIST
88674: LIST
88675: LIST
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: LIST
88681: LIST
88682: LIST
88683: LIST
88684: LIST
88685: LIST
88686: LIST
88687: LIST
88688: LIST
88689: LIST
88690: LIST
88691: LIST
88692: LIST
88693: PUSH
88694: LD_INT 101
88696: PUSH
88697: LD_INT 102
88699: PUSH
88700: LD_INT 103
88702: PUSH
88703: LD_INT 104
88705: PUSH
88706: LD_INT 105
88708: PUSH
88709: LD_INT 106
88711: PUSH
88712: LD_INT 107
88714: PUSH
88715: LD_INT 108
88717: PUSH
88718: LD_INT 109
88720: PUSH
88721: LD_INT 110
88723: PUSH
88724: LD_INT 111
88726: PUSH
88727: LD_INT 112
88729: PUSH
88730: LD_INT 113
88732: PUSH
88733: LD_INT 114
88735: PUSH
88736: LD_INT 115
88738: PUSH
88739: LD_INT 116
88741: PUSH
88742: LD_INT 117
88744: PUSH
88745: LD_INT 118
88747: PUSH
88748: EMPTY
88749: LIST
88750: LIST
88751: LIST
88752: LIST
88753: LIST
88754: LIST
88755: LIST
88756: LIST
88757: LIST
88758: LIST
88759: LIST
88760: LIST
88761: LIST
88762: LIST
88763: LIST
88764: LIST
88765: LIST
88766: LIST
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: ST_TO_ADDR
88772: GO 88775
88774: POP
// end else
88775: GO 89006
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
88777: LD_ADDR_VAR 0 1
88781: PUSH
88782: LD_INT 1
88784: PUSH
88785: LD_INT 2
88787: PUSH
88788: LD_INT 3
88790: PUSH
88791: LD_INT 4
88793: PUSH
88794: LD_INT 5
88796: PUSH
88797: LD_INT 6
88799: PUSH
88800: LD_INT 7
88802: PUSH
88803: LD_INT 8
88805: PUSH
88806: LD_INT 9
88808: PUSH
88809: LD_INT 10
88811: PUSH
88812: LD_INT 11
88814: PUSH
88815: LD_INT 12
88817: PUSH
88818: LD_INT 13
88820: PUSH
88821: LD_INT 14
88823: PUSH
88824: LD_INT 15
88826: PUSH
88827: LD_INT 16
88829: PUSH
88830: LD_INT 17
88832: PUSH
88833: LD_INT 18
88835: PUSH
88836: LD_INT 19
88838: PUSH
88839: LD_INT 20
88841: PUSH
88842: LD_INT 21
88844: PUSH
88845: LD_INT 22
88847: PUSH
88848: LD_INT 23
88850: PUSH
88851: LD_INT 24
88853: PUSH
88854: LD_INT 25
88856: PUSH
88857: LD_INT 26
88859: PUSH
88860: LD_INT 27
88862: PUSH
88863: LD_INT 28
88865: PUSH
88866: LD_INT 29
88868: PUSH
88869: LD_INT 30
88871: PUSH
88872: LD_INT 31
88874: PUSH
88875: LD_INT 32
88877: PUSH
88878: LD_INT 33
88880: PUSH
88881: LD_INT 34
88883: PUSH
88884: LD_INT 35
88886: PUSH
88887: LD_INT 36
88889: PUSH
88890: EMPTY
88891: LIST
88892: LIST
88893: LIST
88894: LIST
88895: LIST
88896: LIST
88897: LIST
88898: LIST
88899: LIST
88900: LIST
88901: LIST
88902: LIST
88903: LIST
88904: LIST
88905: LIST
88906: LIST
88907: LIST
88908: LIST
88909: LIST
88910: LIST
88911: LIST
88912: LIST
88913: LIST
88914: LIST
88915: LIST
88916: LIST
88917: LIST
88918: LIST
88919: LIST
88920: LIST
88921: LIST
88922: LIST
88923: LIST
88924: LIST
88925: LIST
88926: LIST
88927: PUSH
88928: LD_INT 101
88930: PUSH
88931: LD_INT 102
88933: PUSH
88934: LD_INT 103
88936: PUSH
88937: LD_INT 104
88939: PUSH
88940: LD_INT 105
88942: PUSH
88943: LD_INT 106
88945: PUSH
88946: LD_INT 107
88948: PUSH
88949: LD_INT 108
88951: PUSH
88952: LD_INT 109
88954: PUSH
88955: LD_INT 110
88957: PUSH
88958: LD_INT 111
88960: PUSH
88961: LD_INT 112
88963: PUSH
88964: LD_INT 113
88966: PUSH
88967: LD_INT 114
88969: PUSH
88970: LD_INT 115
88972: PUSH
88973: LD_INT 116
88975: PUSH
88976: LD_INT 117
88978: PUSH
88979: LD_INT 118
88981: PUSH
88982: EMPTY
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: PUSH
89002: EMPTY
89003: LIST
89004: LIST
89005: ST_TO_ADDR
// if result then
89006: LD_VAR 0 1
89010: IFFALSE 89299
// begin normal :=  ;
89012: LD_ADDR_VAR 0 3
89016: PUSH
89017: LD_STRING 
89019: ST_TO_ADDR
// hardcore :=  ;
89020: LD_ADDR_VAR 0 4
89024: PUSH
89025: LD_STRING 
89027: ST_TO_ADDR
// for i = 1 to normalCounter do
89028: LD_ADDR_VAR 0 5
89032: PUSH
89033: DOUBLE
89034: LD_INT 1
89036: DEC
89037: ST_TO_ADDR
89038: LD_EXP 114
89042: PUSH
89043: FOR_TO
89044: IFFALSE 89145
// begin tmp := 0 ;
89046: LD_ADDR_VAR 0 2
89050: PUSH
89051: LD_STRING 0
89053: ST_TO_ADDR
// if result [ 1 ] then
89054: LD_VAR 0 1
89058: PUSH
89059: LD_INT 1
89061: ARRAY
89062: IFFALSE 89127
// if result [ 1 ] [ 1 ] = i then
89064: LD_VAR 0 1
89068: PUSH
89069: LD_INT 1
89071: ARRAY
89072: PUSH
89073: LD_INT 1
89075: ARRAY
89076: PUSH
89077: LD_VAR 0 5
89081: EQUAL
89082: IFFALSE 89127
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
89084: LD_ADDR_VAR 0 1
89088: PUSH
89089: LD_VAR 0 1
89093: PPUSH
89094: LD_INT 1
89096: PPUSH
89097: LD_VAR 0 1
89101: PUSH
89102: LD_INT 1
89104: ARRAY
89105: PPUSH
89106: LD_INT 1
89108: PPUSH
89109: CALL_OW 3
89113: PPUSH
89114: CALL_OW 1
89118: ST_TO_ADDR
// tmp := 1 ;
89119: LD_ADDR_VAR 0 2
89123: PUSH
89124: LD_STRING 1
89126: ST_TO_ADDR
// end ; normal := normal & tmp ;
89127: LD_ADDR_VAR 0 3
89131: PUSH
89132: LD_VAR 0 3
89136: PUSH
89137: LD_VAR 0 2
89141: STR
89142: ST_TO_ADDR
// end ;
89143: GO 89043
89145: POP
89146: POP
// for i = 1 to hardcoreCounter do
89147: LD_ADDR_VAR 0 5
89151: PUSH
89152: DOUBLE
89153: LD_INT 1
89155: DEC
89156: ST_TO_ADDR
89157: LD_EXP 115
89161: PUSH
89162: FOR_TO
89163: IFFALSE 89268
// begin tmp := 0 ;
89165: LD_ADDR_VAR 0 2
89169: PUSH
89170: LD_STRING 0
89172: ST_TO_ADDR
// if result [ 2 ] then
89173: LD_VAR 0 1
89177: PUSH
89178: LD_INT 2
89180: ARRAY
89181: IFFALSE 89250
// if result [ 2 ] [ 1 ] = 100 + i then
89183: LD_VAR 0 1
89187: PUSH
89188: LD_INT 2
89190: ARRAY
89191: PUSH
89192: LD_INT 1
89194: ARRAY
89195: PUSH
89196: LD_INT 100
89198: PUSH
89199: LD_VAR 0 5
89203: PLUS
89204: EQUAL
89205: IFFALSE 89250
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
89207: LD_ADDR_VAR 0 1
89211: PUSH
89212: LD_VAR 0 1
89216: PPUSH
89217: LD_INT 2
89219: PPUSH
89220: LD_VAR 0 1
89224: PUSH
89225: LD_INT 2
89227: ARRAY
89228: PPUSH
89229: LD_INT 1
89231: PPUSH
89232: CALL_OW 3
89236: PPUSH
89237: CALL_OW 1
89241: ST_TO_ADDR
// tmp := 1 ;
89242: LD_ADDR_VAR 0 2
89246: PUSH
89247: LD_STRING 1
89249: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
89250: LD_ADDR_VAR 0 4
89254: PUSH
89255: LD_VAR 0 4
89259: PUSH
89260: LD_VAR 0 2
89264: STR
89265: ST_TO_ADDR
// end ;
89266: GO 89162
89268: POP
89269: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
89270: LD_STRING getStreamItemsFromMission("
89272: PUSH
89273: LD_VAR 0 3
89277: STR
89278: PUSH
89279: LD_STRING ","
89281: STR
89282: PUSH
89283: LD_VAR 0 4
89287: STR
89288: PUSH
89289: LD_STRING ")
89291: STR
89292: PPUSH
89293: CALL_OW 559
// end else
89297: GO 89306
// ToLua ( getStreamItemsFromMission("","") ) ;
89299: LD_STRING getStreamItemsFromMission("","")
89301: PPUSH
89302: CALL_OW 559
// end ;
89306: LD_VAR 0 1
89310: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
89311: LD_EXP 113
89315: PUSH
89316: LD_EXP 118
89320: AND
89321: IFFALSE 89445
89323: GO 89325
89325: DISABLE
89326: LD_INT 0
89328: PPUSH
89329: PPUSH
// begin enable ;
89330: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
89331: LD_ADDR_VAR 0 2
89335: PUSH
89336: LD_INT 22
89338: PUSH
89339: LD_OWVAR 2
89343: PUSH
89344: EMPTY
89345: LIST
89346: LIST
89347: PUSH
89348: LD_INT 2
89350: PUSH
89351: LD_INT 34
89353: PUSH
89354: LD_INT 7
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: PUSH
89361: LD_INT 34
89363: PUSH
89364: LD_INT 45
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: PUSH
89371: LD_INT 34
89373: PUSH
89374: LD_INT 28
89376: PUSH
89377: EMPTY
89378: LIST
89379: LIST
89380: PUSH
89381: LD_INT 34
89383: PUSH
89384: LD_INT 47
89386: PUSH
89387: EMPTY
89388: LIST
89389: LIST
89390: PUSH
89391: EMPTY
89392: LIST
89393: LIST
89394: LIST
89395: LIST
89396: LIST
89397: PUSH
89398: EMPTY
89399: LIST
89400: LIST
89401: PPUSH
89402: CALL_OW 69
89406: ST_TO_ADDR
// if not tmp then
89407: LD_VAR 0 2
89411: NOT
89412: IFFALSE 89416
// exit ;
89414: GO 89445
// for i in tmp do
89416: LD_ADDR_VAR 0 1
89420: PUSH
89421: LD_VAR 0 2
89425: PUSH
89426: FOR_IN
89427: IFFALSE 89443
// begin SetLives ( i , 0 ) ;
89429: LD_VAR 0 1
89433: PPUSH
89434: LD_INT 0
89436: PPUSH
89437: CALL_OW 234
// end ;
89441: GO 89426
89443: POP
89444: POP
// end ;
89445: PPOPN 2
89447: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
89448: LD_EXP 113
89452: PUSH
89453: LD_EXP 119
89457: AND
89458: IFFALSE 89542
89460: GO 89462
89462: DISABLE
89463: LD_INT 0
89465: PPUSH
89466: PPUSH
// begin enable ;
89467: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
89468: LD_ADDR_VAR 0 2
89472: PUSH
89473: LD_INT 22
89475: PUSH
89476: LD_OWVAR 2
89480: PUSH
89481: EMPTY
89482: LIST
89483: LIST
89484: PUSH
89485: LD_INT 32
89487: PUSH
89488: LD_INT 3
89490: PUSH
89491: EMPTY
89492: LIST
89493: LIST
89494: PUSH
89495: EMPTY
89496: LIST
89497: LIST
89498: PPUSH
89499: CALL_OW 69
89503: ST_TO_ADDR
// if not tmp then
89504: LD_VAR 0 2
89508: NOT
89509: IFFALSE 89513
// exit ;
89511: GO 89542
// for i in tmp do
89513: LD_ADDR_VAR 0 1
89517: PUSH
89518: LD_VAR 0 2
89522: PUSH
89523: FOR_IN
89524: IFFALSE 89540
// begin SetLives ( i , 0 ) ;
89526: LD_VAR 0 1
89530: PPUSH
89531: LD_INT 0
89533: PPUSH
89534: CALL_OW 234
// end ;
89538: GO 89523
89540: POP
89541: POP
// end ;
89542: PPOPN 2
89544: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
89545: LD_EXP 113
89549: PUSH
89550: LD_EXP 116
89554: AND
89555: IFFALSE 89648
89557: GO 89559
89559: DISABLE
89560: LD_INT 0
89562: PPUSH
// begin enable ;
89563: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
89564: LD_ADDR_VAR 0 1
89568: PUSH
89569: LD_INT 22
89571: PUSH
89572: LD_OWVAR 2
89576: PUSH
89577: EMPTY
89578: LIST
89579: LIST
89580: PUSH
89581: LD_INT 2
89583: PUSH
89584: LD_INT 25
89586: PUSH
89587: LD_INT 5
89589: PUSH
89590: EMPTY
89591: LIST
89592: LIST
89593: PUSH
89594: LD_INT 25
89596: PUSH
89597: LD_INT 9
89599: PUSH
89600: EMPTY
89601: LIST
89602: LIST
89603: PUSH
89604: LD_INT 25
89606: PUSH
89607: LD_INT 8
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: PUSH
89614: EMPTY
89615: LIST
89616: LIST
89617: LIST
89618: LIST
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: PPUSH
89624: CALL_OW 69
89628: PUSH
89629: FOR_IN
89630: IFFALSE 89646
// begin SetClass ( i , 1 ) ;
89632: LD_VAR 0 1
89636: PPUSH
89637: LD_INT 1
89639: PPUSH
89640: CALL_OW 336
// end ;
89644: GO 89629
89646: POP
89647: POP
// end ;
89648: PPOPN 1
89650: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
89651: LD_EXP 113
89655: PUSH
89656: LD_EXP 117
89660: AND
89661: PUSH
89662: LD_OWVAR 65
89666: PUSH
89667: LD_INT 7
89669: LESS
89670: AND
89671: IFFALSE 89685
89673: GO 89675
89675: DISABLE
// begin enable ;
89676: ENABLE
// game_speed := 7 ;
89677: LD_ADDR_OWVAR 65
89681: PUSH
89682: LD_INT 7
89684: ST_TO_ADDR
// end ;
89685: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
89686: LD_EXP 113
89690: PUSH
89691: LD_EXP 120
89695: AND
89696: IFFALSE 89898
89698: GO 89700
89700: DISABLE
89701: LD_INT 0
89703: PPUSH
89704: PPUSH
89705: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
89706: LD_ADDR_VAR 0 3
89710: PUSH
89711: LD_INT 81
89713: PUSH
89714: LD_OWVAR 2
89718: PUSH
89719: EMPTY
89720: LIST
89721: LIST
89722: PUSH
89723: LD_INT 21
89725: PUSH
89726: LD_INT 1
89728: PUSH
89729: EMPTY
89730: LIST
89731: LIST
89732: PUSH
89733: EMPTY
89734: LIST
89735: LIST
89736: PPUSH
89737: CALL_OW 69
89741: ST_TO_ADDR
// if not tmp then
89742: LD_VAR 0 3
89746: NOT
89747: IFFALSE 89751
// exit ;
89749: GO 89898
// if tmp > 5 then
89751: LD_VAR 0 3
89755: PUSH
89756: LD_INT 5
89758: GREATER
89759: IFFALSE 89771
// k := 5 else
89761: LD_ADDR_VAR 0 2
89765: PUSH
89766: LD_INT 5
89768: ST_TO_ADDR
89769: GO 89781
// k := tmp ;
89771: LD_ADDR_VAR 0 2
89775: PUSH
89776: LD_VAR 0 3
89780: ST_TO_ADDR
// for i := 1 to k do
89781: LD_ADDR_VAR 0 1
89785: PUSH
89786: DOUBLE
89787: LD_INT 1
89789: DEC
89790: ST_TO_ADDR
89791: LD_VAR 0 2
89795: PUSH
89796: FOR_TO
89797: IFFALSE 89896
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
89799: LD_VAR 0 3
89803: PUSH
89804: LD_VAR 0 1
89808: ARRAY
89809: PPUSH
89810: LD_VAR 0 1
89814: PUSH
89815: LD_INT 4
89817: MOD
89818: PUSH
89819: LD_INT 1
89821: PLUS
89822: PPUSH
89823: CALL_OW 259
89827: PUSH
89828: LD_INT 10
89830: LESS
89831: IFFALSE 89894
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
89833: LD_VAR 0 3
89837: PUSH
89838: LD_VAR 0 1
89842: ARRAY
89843: PPUSH
89844: LD_VAR 0 1
89848: PUSH
89849: LD_INT 4
89851: MOD
89852: PUSH
89853: LD_INT 1
89855: PLUS
89856: PPUSH
89857: LD_VAR 0 3
89861: PUSH
89862: LD_VAR 0 1
89866: ARRAY
89867: PPUSH
89868: LD_VAR 0 1
89872: PUSH
89873: LD_INT 4
89875: MOD
89876: PUSH
89877: LD_INT 1
89879: PLUS
89880: PPUSH
89881: CALL_OW 259
89885: PUSH
89886: LD_INT 1
89888: PLUS
89889: PPUSH
89890: CALL_OW 237
89894: GO 89796
89896: POP
89897: POP
// end ;
89898: PPOPN 3
89900: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
89901: LD_EXP 113
89905: PUSH
89906: LD_EXP 121
89910: AND
89911: IFFALSE 89931
89913: GO 89915
89915: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
89916: LD_INT 4
89918: PPUSH
89919: LD_OWVAR 2
89923: PPUSH
89924: LD_INT 0
89926: PPUSH
89927: CALL_OW 324
89931: END
// every 0 0$1 trigger StreamModeActive and sShovel do
89932: LD_EXP 113
89936: PUSH
89937: LD_EXP 150
89941: AND
89942: IFFALSE 89962
89944: GO 89946
89946: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
89947: LD_INT 19
89949: PPUSH
89950: LD_OWVAR 2
89954: PPUSH
89955: LD_INT 0
89957: PPUSH
89958: CALL_OW 324
89962: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
89963: LD_EXP 113
89967: PUSH
89968: LD_EXP 122
89972: AND
89973: IFFALSE 90075
89975: GO 89977
89977: DISABLE
89978: LD_INT 0
89980: PPUSH
89981: PPUSH
// begin enable ;
89982: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
89983: LD_ADDR_VAR 0 2
89987: PUSH
89988: LD_INT 22
89990: PUSH
89991: LD_OWVAR 2
89995: PUSH
89996: EMPTY
89997: LIST
89998: LIST
89999: PUSH
90000: LD_INT 2
90002: PUSH
90003: LD_INT 34
90005: PUSH
90006: LD_INT 11
90008: PUSH
90009: EMPTY
90010: LIST
90011: LIST
90012: PUSH
90013: LD_INT 34
90015: PUSH
90016: LD_INT 30
90018: PUSH
90019: EMPTY
90020: LIST
90021: LIST
90022: PUSH
90023: EMPTY
90024: LIST
90025: LIST
90026: LIST
90027: PUSH
90028: EMPTY
90029: LIST
90030: LIST
90031: PPUSH
90032: CALL_OW 69
90036: ST_TO_ADDR
// if not tmp then
90037: LD_VAR 0 2
90041: NOT
90042: IFFALSE 90046
// exit ;
90044: GO 90075
// for i in tmp do
90046: LD_ADDR_VAR 0 1
90050: PUSH
90051: LD_VAR 0 2
90055: PUSH
90056: FOR_IN
90057: IFFALSE 90073
// begin SetLives ( i , 0 ) ;
90059: LD_VAR 0 1
90063: PPUSH
90064: LD_INT 0
90066: PPUSH
90067: CALL_OW 234
// end ;
90071: GO 90056
90073: POP
90074: POP
// end ;
90075: PPOPN 2
90077: END
// every 0 0$1 trigger StreamModeActive and sBunker do
90078: LD_EXP 113
90082: PUSH
90083: LD_EXP 123
90087: AND
90088: IFFALSE 90108
90090: GO 90092
90092: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
90093: LD_INT 32
90095: PPUSH
90096: LD_OWVAR 2
90100: PPUSH
90101: LD_INT 0
90103: PPUSH
90104: CALL_OW 324
90108: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
90109: LD_EXP 113
90113: PUSH
90114: LD_EXP 124
90118: AND
90119: IFFALSE 90300
90121: GO 90123
90123: DISABLE
90124: LD_INT 0
90126: PPUSH
90127: PPUSH
90128: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
90129: LD_ADDR_VAR 0 2
90133: PUSH
90134: LD_INT 22
90136: PUSH
90137: LD_OWVAR 2
90141: PUSH
90142: EMPTY
90143: LIST
90144: LIST
90145: PUSH
90146: LD_INT 33
90148: PUSH
90149: LD_INT 3
90151: PUSH
90152: EMPTY
90153: LIST
90154: LIST
90155: PUSH
90156: EMPTY
90157: LIST
90158: LIST
90159: PPUSH
90160: CALL_OW 69
90164: ST_TO_ADDR
// if not tmp then
90165: LD_VAR 0 2
90169: NOT
90170: IFFALSE 90174
// exit ;
90172: GO 90300
// side := 0 ;
90174: LD_ADDR_VAR 0 3
90178: PUSH
90179: LD_INT 0
90181: ST_TO_ADDR
// for i := 1 to 8 do
90182: LD_ADDR_VAR 0 1
90186: PUSH
90187: DOUBLE
90188: LD_INT 1
90190: DEC
90191: ST_TO_ADDR
90192: LD_INT 8
90194: PUSH
90195: FOR_TO
90196: IFFALSE 90244
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
90198: LD_OWVAR 2
90202: PUSH
90203: LD_VAR 0 1
90207: NONEQUAL
90208: PUSH
90209: LD_OWVAR 2
90213: PPUSH
90214: LD_VAR 0 1
90218: PPUSH
90219: CALL_OW 81
90223: PUSH
90224: LD_INT 2
90226: EQUAL
90227: AND
90228: IFFALSE 90242
// begin side := i ;
90230: LD_ADDR_VAR 0 3
90234: PUSH
90235: LD_VAR 0 1
90239: ST_TO_ADDR
// break ;
90240: GO 90244
// end ;
90242: GO 90195
90244: POP
90245: POP
// if not side then
90246: LD_VAR 0 3
90250: NOT
90251: IFFALSE 90255
// exit ;
90253: GO 90300
// for i := 1 to tmp do
90255: LD_ADDR_VAR 0 1
90259: PUSH
90260: DOUBLE
90261: LD_INT 1
90263: DEC
90264: ST_TO_ADDR
90265: LD_VAR 0 2
90269: PUSH
90270: FOR_TO
90271: IFFALSE 90298
// if Prob ( 60 ) then
90273: LD_INT 60
90275: PPUSH
90276: CALL_OW 13
90280: IFFALSE 90296
// SetSide ( i , side ) ;
90282: LD_VAR 0 1
90286: PPUSH
90287: LD_VAR 0 3
90291: PPUSH
90292: CALL_OW 235
90296: GO 90270
90298: POP
90299: POP
// end ;
90300: PPOPN 3
90302: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
90303: LD_EXP 113
90307: PUSH
90308: LD_EXP 126
90312: AND
90313: IFFALSE 90432
90315: GO 90317
90317: DISABLE
90318: LD_INT 0
90320: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
90321: LD_ADDR_VAR 0 1
90325: PUSH
90326: LD_INT 22
90328: PUSH
90329: LD_OWVAR 2
90333: PUSH
90334: EMPTY
90335: LIST
90336: LIST
90337: PUSH
90338: LD_INT 21
90340: PUSH
90341: LD_INT 1
90343: PUSH
90344: EMPTY
90345: LIST
90346: LIST
90347: PUSH
90348: LD_INT 3
90350: PUSH
90351: LD_INT 23
90353: PUSH
90354: LD_INT 0
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: PUSH
90361: EMPTY
90362: LIST
90363: LIST
90364: PUSH
90365: EMPTY
90366: LIST
90367: LIST
90368: LIST
90369: PPUSH
90370: CALL_OW 69
90374: PUSH
90375: FOR_IN
90376: IFFALSE 90430
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
90378: LD_VAR 0 1
90382: PPUSH
90383: CALL_OW 257
90387: PUSH
90388: LD_INT 1
90390: PUSH
90391: LD_INT 2
90393: PUSH
90394: LD_INT 3
90396: PUSH
90397: LD_INT 4
90399: PUSH
90400: EMPTY
90401: LIST
90402: LIST
90403: LIST
90404: LIST
90405: IN
90406: IFFALSE 90428
// SetClass ( un , rand ( 1 , 4 ) ) ;
90408: LD_VAR 0 1
90412: PPUSH
90413: LD_INT 1
90415: PPUSH
90416: LD_INT 4
90418: PPUSH
90419: CALL_OW 12
90423: PPUSH
90424: CALL_OW 336
90428: GO 90375
90430: POP
90431: POP
// end ;
90432: PPOPN 1
90434: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
90435: LD_EXP 113
90439: PUSH
90440: LD_EXP 125
90444: AND
90445: IFFALSE 90524
90447: GO 90449
90449: DISABLE
90450: LD_INT 0
90452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
90453: LD_ADDR_VAR 0 1
90457: PUSH
90458: LD_INT 22
90460: PUSH
90461: LD_OWVAR 2
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: PUSH
90470: LD_INT 21
90472: PUSH
90473: LD_INT 3
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: EMPTY
90481: LIST
90482: LIST
90483: PPUSH
90484: CALL_OW 69
90488: ST_TO_ADDR
// if not tmp then
90489: LD_VAR 0 1
90493: NOT
90494: IFFALSE 90498
// exit ;
90496: GO 90524
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
90498: LD_VAR 0 1
90502: PUSH
90503: LD_INT 1
90505: PPUSH
90506: LD_VAR 0 1
90510: PPUSH
90511: CALL_OW 12
90515: ARRAY
90516: PPUSH
90517: LD_INT 100
90519: PPUSH
90520: CALL_OW 234
// end ;
90524: PPOPN 1
90526: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
90527: LD_EXP 113
90531: PUSH
90532: LD_EXP 127
90536: AND
90537: IFFALSE 90635
90539: GO 90541
90541: DISABLE
90542: LD_INT 0
90544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90545: LD_ADDR_VAR 0 1
90549: PUSH
90550: LD_INT 22
90552: PUSH
90553: LD_OWVAR 2
90557: PUSH
90558: EMPTY
90559: LIST
90560: LIST
90561: PUSH
90562: LD_INT 21
90564: PUSH
90565: LD_INT 1
90567: PUSH
90568: EMPTY
90569: LIST
90570: LIST
90571: PUSH
90572: EMPTY
90573: LIST
90574: LIST
90575: PPUSH
90576: CALL_OW 69
90580: ST_TO_ADDR
// if not tmp then
90581: LD_VAR 0 1
90585: NOT
90586: IFFALSE 90590
// exit ;
90588: GO 90635
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
90590: LD_VAR 0 1
90594: PUSH
90595: LD_INT 1
90597: PPUSH
90598: LD_VAR 0 1
90602: PPUSH
90603: CALL_OW 12
90607: ARRAY
90608: PPUSH
90609: LD_INT 1
90611: PPUSH
90612: LD_INT 4
90614: PPUSH
90615: CALL_OW 12
90619: PPUSH
90620: LD_INT 3000
90622: PPUSH
90623: LD_INT 9000
90625: PPUSH
90626: CALL_OW 12
90630: PPUSH
90631: CALL_OW 492
// end ;
90635: PPOPN 1
90637: END
// every 0 0$1 trigger StreamModeActive and sDepot do
90638: LD_EXP 113
90642: PUSH
90643: LD_EXP 128
90647: AND
90648: IFFALSE 90668
90650: GO 90652
90652: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
90653: LD_INT 1
90655: PPUSH
90656: LD_OWVAR 2
90660: PPUSH
90661: LD_INT 0
90663: PPUSH
90664: CALL_OW 324
90668: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
90669: LD_EXP 113
90673: PUSH
90674: LD_EXP 129
90678: AND
90679: IFFALSE 90762
90681: GO 90683
90683: DISABLE
90684: LD_INT 0
90686: PPUSH
90687: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
90688: LD_ADDR_VAR 0 2
90692: PUSH
90693: LD_INT 22
90695: PUSH
90696: LD_OWVAR 2
90700: PUSH
90701: EMPTY
90702: LIST
90703: LIST
90704: PUSH
90705: LD_INT 21
90707: PUSH
90708: LD_INT 3
90710: PUSH
90711: EMPTY
90712: LIST
90713: LIST
90714: PUSH
90715: EMPTY
90716: LIST
90717: LIST
90718: PPUSH
90719: CALL_OW 69
90723: ST_TO_ADDR
// if not tmp then
90724: LD_VAR 0 2
90728: NOT
90729: IFFALSE 90733
// exit ;
90731: GO 90762
// for i in tmp do
90733: LD_ADDR_VAR 0 1
90737: PUSH
90738: LD_VAR 0 2
90742: PUSH
90743: FOR_IN
90744: IFFALSE 90760
// SetBLevel ( i , 10 ) ;
90746: LD_VAR 0 1
90750: PPUSH
90751: LD_INT 10
90753: PPUSH
90754: CALL_OW 241
90758: GO 90743
90760: POP
90761: POP
// end ;
90762: PPOPN 2
90764: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
90765: LD_EXP 113
90769: PUSH
90770: LD_EXP 130
90774: AND
90775: IFFALSE 90886
90777: GO 90779
90779: DISABLE
90780: LD_INT 0
90782: PPUSH
90783: PPUSH
90784: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90785: LD_ADDR_VAR 0 3
90789: PUSH
90790: LD_INT 22
90792: PUSH
90793: LD_OWVAR 2
90797: PUSH
90798: EMPTY
90799: LIST
90800: LIST
90801: PUSH
90802: LD_INT 25
90804: PUSH
90805: LD_INT 1
90807: PUSH
90808: EMPTY
90809: LIST
90810: LIST
90811: PUSH
90812: EMPTY
90813: LIST
90814: LIST
90815: PPUSH
90816: CALL_OW 69
90820: ST_TO_ADDR
// if not tmp then
90821: LD_VAR 0 3
90825: NOT
90826: IFFALSE 90830
// exit ;
90828: GO 90886
// un := tmp [ rand ( 1 , tmp ) ] ;
90830: LD_ADDR_VAR 0 2
90834: PUSH
90835: LD_VAR 0 3
90839: PUSH
90840: LD_INT 1
90842: PPUSH
90843: LD_VAR 0 3
90847: PPUSH
90848: CALL_OW 12
90852: ARRAY
90853: ST_TO_ADDR
// if Crawls ( un ) then
90854: LD_VAR 0 2
90858: PPUSH
90859: CALL_OW 318
90863: IFFALSE 90874
// ComWalk ( un ) ;
90865: LD_VAR 0 2
90869: PPUSH
90870: CALL_OW 138
// SetClass ( un , class_sniper ) ;
90874: LD_VAR 0 2
90878: PPUSH
90879: LD_INT 5
90881: PPUSH
90882: CALL_OW 336
// end ;
90886: PPOPN 3
90888: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
90889: LD_EXP 113
90893: PUSH
90894: LD_EXP 131
90898: AND
90899: PUSH
90900: LD_OWVAR 67
90904: PUSH
90905: LD_INT 4
90907: LESS
90908: AND
90909: IFFALSE 90928
90911: GO 90913
90913: DISABLE
// begin Difficulty := Difficulty + 1 ;
90914: LD_ADDR_OWVAR 67
90918: PUSH
90919: LD_OWVAR 67
90923: PUSH
90924: LD_INT 1
90926: PLUS
90927: ST_TO_ADDR
// end ;
90928: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
90929: LD_EXP 113
90933: PUSH
90934: LD_EXP 132
90938: AND
90939: IFFALSE 91042
90941: GO 90943
90943: DISABLE
90944: LD_INT 0
90946: PPUSH
// begin for i := 1 to 5 do
90947: LD_ADDR_VAR 0 1
90951: PUSH
90952: DOUBLE
90953: LD_INT 1
90955: DEC
90956: ST_TO_ADDR
90957: LD_INT 5
90959: PUSH
90960: FOR_TO
90961: IFFALSE 91040
// begin uc_nation := nation_nature ;
90963: LD_ADDR_OWVAR 21
90967: PUSH
90968: LD_INT 0
90970: ST_TO_ADDR
// uc_side := 0 ;
90971: LD_ADDR_OWVAR 20
90975: PUSH
90976: LD_INT 0
90978: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
90979: LD_ADDR_OWVAR 29
90983: PUSH
90984: LD_INT 12
90986: PUSH
90987: LD_INT 12
90989: PUSH
90990: EMPTY
90991: LIST
90992: LIST
90993: ST_TO_ADDR
// hc_agressivity := 20 ;
90994: LD_ADDR_OWVAR 35
90998: PUSH
90999: LD_INT 20
91001: ST_TO_ADDR
// hc_class := class_tiger ;
91002: LD_ADDR_OWVAR 28
91006: PUSH
91007: LD_INT 14
91009: ST_TO_ADDR
// hc_gallery :=  ;
91010: LD_ADDR_OWVAR 33
91014: PUSH
91015: LD_STRING 
91017: ST_TO_ADDR
// hc_name :=  ;
91018: LD_ADDR_OWVAR 26
91022: PUSH
91023: LD_STRING 
91025: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
91026: CALL_OW 44
91030: PPUSH
91031: LD_INT 0
91033: PPUSH
91034: CALL_OW 51
// end ;
91038: GO 90960
91040: POP
91041: POP
// end ;
91042: PPOPN 1
91044: END
// every 0 0$1 trigger StreamModeActive and sBomb do
91045: LD_EXP 113
91049: PUSH
91050: LD_EXP 133
91054: AND
91055: IFFALSE 91064
91057: GO 91059
91059: DISABLE
// StreamSibBomb ;
91060: CALL 91065 0 0
91064: END
// export function StreamSibBomb ; var i , x , y ; begin
91065: LD_INT 0
91067: PPUSH
91068: PPUSH
91069: PPUSH
91070: PPUSH
// result := false ;
91071: LD_ADDR_VAR 0 1
91075: PUSH
91076: LD_INT 0
91078: ST_TO_ADDR
// for i := 1 to 16 do
91079: LD_ADDR_VAR 0 2
91083: PUSH
91084: DOUBLE
91085: LD_INT 1
91087: DEC
91088: ST_TO_ADDR
91089: LD_INT 16
91091: PUSH
91092: FOR_TO
91093: IFFALSE 91292
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91095: LD_ADDR_VAR 0 3
91099: PUSH
91100: LD_INT 10
91102: PUSH
91103: LD_INT 20
91105: PUSH
91106: LD_INT 30
91108: PUSH
91109: LD_INT 40
91111: PUSH
91112: LD_INT 50
91114: PUSH
91115: LD_INT 60
91117: PUSH
91118: LD_INT 70
91120: PUSH
91121: LD_INT 80
91123: PUSH
91124: LD_INT 90
91126: PUSH
91127: LD_INT 100
91129: PUSH
91130: LD_INT 110
91132: PUSH
91133: LD_INT 120
91135: PUSH
91136: LD_INT 130
91138: PUSH
91139: LD_INT 140
91141: PUSH
91142: LD_INT 150
91144: PUSH
91145: EMPTY
91146: LIST
91147: LIST
91148: LIST
91149: LIST
91150: LIST
91151: LIST
91152: LIST
91153: LIST
91154: LIST
91155: LIST
91156: LIST
91157: LIST
91158: LIST
91159: LIST
91160: LIST
91161: PUSH
91162: LD_INT 1
91164: PPUSH
91165: LD_INT 15
91167: PPUSH
91168: CALL_OW 12
91172: ARRAY
91173: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91174: LD_ADDR_VAR 0 4
91178: PUSH
91179: LD_INT 10
91181: PUSH
91182: LD_INT 20
91184: PUSH
91185: LD_INT 30
91187: PUSH
91188: LD_INT 40
91190: PUSH
91191: LD_INT 50
91193: PUSH
91194: LD_INT 60
91196: PUSH
91197: LD_INT 70
91199: PUSH
91200: LD_INT 80
91202: PUSH
91203: LD_INT 90
91205: PUSH
91206: LD_INT 100
91208: PUSH
91209: LD_INT 110
91211: PUSH
91212: LD_INT 120
91214: PUSH
91215: LD_INT 130
91217: PUSH
91218: LD_INT 140
91220: PUSH
91221: LD_INT 150
91223: PUSH
91224: EMPTY
91225: LIST
91226: LIST
91227: LIST
91228: LIST
91229: LIST
91230: LIST
91231: LIST
91232: LIST
91233: LIST
91234: LIST
91235: LIST
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: PUSH
91241: LD_INT 1
91243: PPUSH
91244: LD_INT 15
91246: PPUSH
91247: CALL_OW 12
91251: ARRAY
91252: ST_TO_ADDR
// if ValidHex ( x , y ) then
91253: LD_VAR 0 3
91257: PPUSH
91258: LD_VAR 0 4
91262: PPUSH
91263: CALL_OW 488
91267: IFFALSE 91290
// begin result := [ x , y ] ;
91269: LD_ADDR_VAR 0 1
91273: PUSH
91274: LD_VAR 0 3
91278: PUSH
91279: LD_VAR 0 4
91283: PUSH
91284: EMPTY
91285: LIST
91286: LIST
91287: ST_TO_ADDR
// break ;
91288: GO 91292
// end ; end ;
91290: GO 91092
91292: POP
91293: POP
// if result then
91294: LD_VAR 0 1
91298: IFFALSE 91358
// begin ToLua ( playSibBomb() ) ;
91300: LD_STRING playSibBomb()
91302: PPUSH
91303: CALL_OW 559
// wait ( 0 0$14 ) ;
91307: LD_INT 490
91309: PPUSH
91310: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
91314: LD_VAR 0 1
91318: PUSH
91319: LD_INT 1
91321: ARRAY
91322: PPUSH
91323: LD_VAR 0 1
91327: PUSH
91328: LD_INT 2
91330: ARRAY
91331: PPUSH
91332: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
91336: LD_VAR 0 1
91340: PUSH
91341: LD_INT 1
91343: ARRAY
91344: PPUSH
91345: LD_VAR 0 1
91349: PUSH
91350: LD_INT 2
91352: ARRAY
91353: PPUSH
91354: CALL_OW 429
// end ; end ;
91358: LD_VAR 0 1
91362: RET
// every 0 0$1 trigger StreamModeActive and sReset do
91363: LD_EXP 113
91367: PUSH
91368: LD_EXP 135
91372: AND
91373: IFFALSE 91385
91375: GO 91377
91377: DISABLE
// YouLost (  ) ;
91378: LD_STRING 
91380: PPUSH
91381: CALL_OW 104
91385: END
// every 0 0$1 trigger StreamModeActive and sFog do
91386: LD_EXP 113
91390: PUSH
91391: LD_EXP 134
91395: AND
91396: IFFALSE 91410
91398: GO 91400
91400: DISABLE
// FogOff ( your_side ) ;
91401: LD_OWVAR 2
91405: PPUSH
91406: CALL_OW 344
91410: END
// every 0 0$1 trigger StreamModeActive and sSun do
91411: LD_EXP 113
91415: PUSH
91416: LD_EXP 136
91420: AND
91421: IFFALSE 91449
91423: GO 91425
91425: DISABLE
// begin solar_recharge_percent := 0 ;
91426: LD_ADDR_OWVAR 79
91430: PUSH
91431: LD_INT 0
91433: ST_TO_ADDR
// wait ( 5 5$00 ) ;
91434: LD_INT 10500
91436: PPUSH
91437: CALL_OW 67
// solar_recharge_percent := 100 ;
91441: LD_ADDR_OWVAR 79
91445: PUSH
91446: LD_INT 100
91448: ST_TO_ADDR
// end ;
91449: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
91450: LD_EXP 113
91454: PUSH
91455: LD_EXP 137
91459: AND
91460: IFFALSE 91699
91462: GO 91464
91464: DISABLE
91465: LD_INT 0
91467: PPUSH
91468: PPUSH
91469: PPUSH
// begin tmp := [ ] ;
91470: LD_ADDR_VAR 0 3
91474: PUSH
91475: EMPTY
91476: ST_TO_ADDR
// for i := 1 to 6 do
91477: LD_ADDR_VAR 0 1
91481: PUSH
91482: DOUBLE
91483: LD_INT 1
91485: DEC
91486: ST_TO_ADDR
91487: LD_INT 6
91489: PUSH
91490: FOR_TO
91491: IFFALSE 91596
// begin uc_nation := nation_nature ;
91493: LD_ADDR_OWVAR 21
91497: PUSH
91498: LD_INT 0
91500: ST_TO_ADDR
// uc_side := 0 ;
91501: LD_ADDR_OWVAR 20
91505: PUSH
91506: LD_INT 0
91508: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
91509: LD_ADDR_OWVAR 29
91513: PUSH
91514: LD_INT 12
91516: PUSH
91517: LD_INT 12
91519: PUSH
91520: EMPTY
91521: LIST
91522: LIST
91523: ST_TO_ADDR
// hc_agressivity := 20 ;
91524: LD_ADDR_OWVAR 35
91528: PUSH
91529: LD_INT 20
91531: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
91532: LD_ADDR_OWVAR 28
91536: PUSH
91537: LD_INT 17
91539: ST_TO_ADDR
// hc_gallery :=  ;
91540: LD_ADDR_OWVAR 33
91544: PUSH
91545: LD_STRING 
91547: ST_TO_ADDR
// hc_name :=  ;
91548: LD_ADDR_OWVAR 26
91552: PUSH
91553: LD_STRING 
91555: ST_TO_ADDR
// un := CreateHuman ;
91556: LD_ADDR_VAR 0 2
91560: PUSH
91561: CALL_OW 44
91565: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
91566: LD_VAR 0 2
91570: PPUSH
91571: LD_INT 1
91573: PPUSH
91574: CALL_OW 51
// tmp := tmp ^ un ;
91578: LD_ADDR_VAR 0 3
91582: PUSH
91583: LD_VAR 0 3
91587: PUSH
91588: LD_VAR 0 2
91592: ADD
91593: ST_TO_ADDR
// end ;
91594: GO 91490
91596: POP
91597: POP
// repeat wait ( 0 0$1 ) ;
91598: LD_INT 35
91600: PPUSH
91601: CALL_OW 67
// for un in tmp do
91605: LD_ADDR_VAR 0 2
91609: PUSH
91610: LD_VAR 0 3
91614: PUSH
91615: FOR_IN
91616: IFFALSE 91690
// begin if IsDead ( un ) then
91618: LD_VAR 0 2
91622: PPUSH
91623: CALL_OW 301
91627: IFFALSE 91647
// begin tmp := tmp diff un ;
91629: LD_ADDR_VAR 0 3
91633: PUSH
91634: LD_VAR 0 3
91638: PUSH
91639: LD_VAR 0 2
91643: DIFF
91644: ST_TO_ADDR
// continue ;
91645: GO 91615
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
91647: LD_VAR 0 2
91651: PPUSH
91652: LD_INT 3
91654: PUSH
91655: LD_INT 22
91657: PUSH
91658: LD_INT 0
91660: PUSH
91661: EMPTY
91662: LIST
91663: LIST
91664: PUSH
91665: EMPTY
91666: LIST
91667: LIST
91668: PPUSH
91669: CALL_OW 69
91673: PPUSH
91674: LD_VAR 0 2
91678: PPUSH
91679: CALL_OW 74
91683: PPUSH
91684: CALL_OW 115
// end ;
91688: GO 91615
91690: POP
91691: POP
// until not tmp ;
91692: LD_VAR 0 3
91696: NOT
91697: IFFALSE 91598
// end ;
91699: PPOPN 3
91701: END
// every 0 0$1 trigger StreamModeActive and sTroll do
91702: LD_EXP 113
91706: PUSH
91707: LD_EXP 138
91711: AND
91712: IFFALSE 91766
91714: GO 91716
91716: DISABLE
// begin ToLua ( displayTroll(); ) ;
91717: LD_STRING displayTroll();
91719: PPUSH
91720: CALL_OW 559
// wait ( 3 3$00 ) ;
91724: LD_INT 6300
91726: PPUSH
91727: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91731: LD_STRING hideTroll();
91733: PPUSH
91734: CALL_OW 559
// wait ( 1 1$00 ) ;
91738: LD_INT 2100
91740: PPUSH
91741: CALL_OW 67
// ToLua ( displayTroll(); ) ;
91745: LD_STRING displayTroll();
91747: PPUSH
91748: CALL_OW 559
// wait ( 1 1$00 ) ;
91752: LD_INT 2100
91754: PPUSH
91755: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91759: LD_STRING hideTroll();
91761: PPUSH
91762: CALL_OW 559
// end ;
91766: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
91767: LD_EXP 113
91771: PUSH
91772: LD_EXP 139
91776: AND
91777: IFFALSE 91840
91779: GO 91781
91781: DISABLE
91782: LD_INT 0
91784: PPUSH
// begin p := 0 ;
91785: LD_ADDR_VAR 0 1
91789: PUSH
91790: LD_INT 0
91792: ST_TO_ADDR
// repeat game_speed := 1 ;
91793: LD_ADDR_OWVAR 65
91797: PUSH
91798: LD_INT 1
91800: ST_TO_ADDR
// wait ( 0 0$1 ) ;
91801: LD_INT 35
91803: PPUSH
91804: CALL_OW 67
// p := p + 1 ;
91808: LD_ADDR_VAR 0 1
91812: PUSH
91813: LD_VAR 0 1
91817: PUSH
91818: LD_INT 1
91820: PLUS
91821: ST_TO_ADDR
// until p >= 60 ;
91822: LD_VAR 0 1
91826: PUSH
91827: LD_INT 60
91829: GREATEREQUAL
91830: IFFALSE 91793
// game_speed := 4 ;
91832: LD_ADDR_OWVAR 65
91836: PUSH
91837: LD_INT 4
91839: ST_TO_ADDR
// end ;
91840: PPOPN 1
91842: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
91843: LD_EXP 113
91847: PUSH
91848: LD_EXP 140
91852: AND
91853: IFFALSE 91999
91855: GO 91857
91857: DISABLE
91858: LD_INT 0
91860: PPUSH
91861: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
91862: LD_ADDR_VAR 0 1
91866: PUSH
91867: LD_INT 22
91869: PUSH
91870: LD_OWVAR 2
91874: PUSH
91875: EMPTY
91876: LIST
91877: LIST
91878: PUSH
91879: LD_INT 2
91881: PUSH
91882: LD_INT 30
91884: PUSH
91885: LD_INT 0
91887: PUSH
91888: EMPTY
91889: LIST
91890: LIST
91891: PUSH
91892: LD_INT 30
91894: PUSH
91895: LD_INT 1
91897: PUSH
91898: EMPTY
91899: LIST
91900: LIST
91901: PUSH
91902: EMPTY
91903: LIST
91904: LIST
91905: LIST
91906: PUSH
91907: EMPTY
91908: LIST
91909: LIST
91910: PPUSH
91911: CALL_OW 69
91915: ST_TO_ADDR
// if not depot then
91916: LD_VAR 0 1
91920: NOT
91921: IFFALSE 91925
// exit ;
91923: GO 91999
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
91925: LD_ADDR_VAR 0 2
91929: PUSH
91930: LD_VAR 0 1
91934: PUSH
91935: LD_INT 1
91937: PPUSH
91938: LD_VAR 0 1
91942: PPUSH
91943: CALL_OW 12
91947: ARRAY
91948: PPUSH
91949: CALL_OW 274
91953: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
91954: LD_VAR 0 2
91958: PPUSH
91959: LD_INT 1
91961: PPUSH
91962: LD_INT 0
91964: PPUSH
91965: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
91969: LD_VAR 0 2
91973: PPUSH
91974: LD_INT 2
91976: PPUSH
91977: LD_INT 0
91979: PPUSH
91980: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
91984: LD_VAR 0 2
91988: PPUSH
91989: LD_INT 3
91991: PPUSH
91992: LD_INT 0
91994: PPUSH
91995: CALL_OW 277
// end ;
91999: PPOPN 2
92001: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
92002: LD_EXP 113
92006: PUSH
92007: LD_EXP 141
92011: AND
92012: IFFALSE 92109
92014: GO 92016
92016: DISABLE
92017: LD_INT 0
92019: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92020: LD_ADDR_VAR 0 1
92024: PUSH
92025: LD_INT 22
92027: PUSH
92028: LD_OWVAR 2
92032: PUSH
92033: EMPTY
92034: LIST
92035: LIST
92036: PUSH
92037: LD_INT 21
92039: PUSH
92040: LD_INT 1
92042: PUSH
92043: EMPTY
92044: LIST
92045: LIST
92046: PUSH
92047: LD_INT 3
92049: PUSH
92050: LD_INT 23
92052: PUSH
92053: LD_INT 0
92055: PUSH
92056: EMPTY
92057: LIST
92058: LIST
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: EMPTY
92065: LIST
92066: LIST
92067: LIST
92068: PPUSH
92069: CALL_OW 69
92073: ST_TO_ADDR
// if not tmp then
92074: LD_VAR 0 1
92078: NOT
92079: IFFALSE 92083
// exit ;
92081: GO 92109
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
92083: LD_VAR 0 1
92087: PUSH
92088: LD_INT 1
92090: PPUSH
92091: LD_VAR 0 1
92095: PPUSH
92096: CALL_OW 12
92100: ARRAY
92101: PPUSH
92102: LD_INT 200
92104: PPUSH
92105: CALL_OW 234
// end ;
92109: PPOPN 1
92111: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
92112: LD_EXP 113
92116: PUSH
92117: LD_EXP 142
92121: AND
92122: IFFALSE 92201
92124: GO 92126
92126: DISABLE
92127: LD_INT 0
92129: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
92130: LD_ADDR_VAR 0 1
92134: PUSH
92135: LD_INT 22
92137: PUSH
92138: LD_OWVAR 2
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: LD_INT 21
92149: PUSH
92150: LD_INT 2
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: PUSH
92157: EMPTY
92158: LIST
92159: LIST
92160: PPUSH
92161: CALL_OW 69
92165: ST_TO_ADDR
// if not tmp then
92166: LD_VAR 0 1
92170: NOT
92171: IFFALSE 92175
// exit ;
92173: GO 92201
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
92175: LD_VAR 0 1
92179: PUSH
92180: LD_INT 1
92182: PPUSH
92183: LD_VAR 0 1
92187: PPUSH
92188: CALL_OW 12
92192: ARRAY
92193: PPUSH
92194: LD_INT 60
92196: PPUSH
92197: CALL_OW 234
// end ;
92201: PPOPN 1
92203: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
92204: LD_EXP 113
92208: PUSH
92209: LD_EXP 143
92213: AND
92214: IFFALSE 92313
92216: GO 92218
92218: DISABLE
92219: LD_INT 0
92221: PPUSH
92222: PPUSH
// begin enable ;
92223: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
92224: LD_ADDR_VAR 0 1
92228: PUSH
92229: LD_INT 22
92231: PUSH
92232: LD_OWVAR 2
92236: PUSH
92237: EMPTY
92238: LIST
92239: LIST
92240: PUSH
92241: LD_INT 61
92243: PUSH
92244: EMPTY
92245: LIST
92246: PUSH
92247: LD_INT 33
92249: PUSH
92250: LD_INT 2
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: PUSH
92257: EMPTY
92258: LIST
92259: LIST
92260: LIST
92261: PPUSH
92262: CALL_OW 69
92266: ST_TO_ADDR
// if not tmp then
92267: LD_VAR 0 1
92271: NOT
92272: IFFALSE 92276
// exit ;
92274: GO 92313
// for i in tmp do
92276: LD_ADDR_VAR 0 2
92280: PUSH
92281: LD_VAR 0 1
92285: PUSH
92286: FOR_IN
92287: IFFALSE 92311
// if IsControledBy ( i ) then
92289: LD_VAR 0 2
92293: PPUSH
92294: CALL_OW 312
92298: IFFALSE 92309
// ComUnlink ( i ) ;
92300: LD_VAR 0 2
92304: PPUSH
92305: CALL_OW 136
92309: GO 92286
92311: POP
92312: POP
// end ;
92313: PPOPN 2
92315: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
92316: LD_EXP 113
92320: PUSH
92321: LD_EXP 144
92325: AND
92326: IFFALSE 92466
92328: GO 92330
92330: DISABLE
92331: LD_INT 0
92333: PPUSH
92334: PPUSH
// begin ToLua ( displayPowell(); ) ;
92335: LD_STRING displayPowell();
92337: PPUSH
92338: CALL_OW 559
// uc_side := 0 ;
92342: LD_ADDR_OWVAR 20
92346: PUSH
92347: LD_INT 0
92349: ST_TO_ADDR
// uc_nation := 2 ;
92350: LD_ADDR_OWVAR 21
92354: PUSH
92355: LD_INT 2
92357: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
92358: LD_ADDR_OWVAR 37
92362: PUSH
92363: LD_INT 14
92365: ST_TO_ADDR
// vc_engine := engine_siberite ;
92366: LD_ADDR_OWVAR 39
92370: PUSH
92371: LD_INT 3
92373: ST_TO_ADDR
// vc_control := control_apeman ;
92374: LD_ADDR_OWVAR 38
92378: PUSH
92379: LD_INT 5
92381: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
92382: LD_ADDR_OWVAR 40
92386: PUSH
92387: LD_INT 29
92389: ST_TO_ADDR
// un := CreateVehicle ;
92390: LD_ADDR_VAR 0 2
92394: PUSH
92395: CALL_OW 45
92399: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92400: LD_VAR 0 2
92404: PPUSH
92405: LD_INT 1
92407: PPUSH
92408: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
92412: LD_INT 35
92414: PPUSH
92415: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
92419: LD_VAR 0 2
92423: PPUSH
92424: LD_INT 22
92426: PUSH
92427: LD_OWVAR 2
92431: PUSH
92432: EMPTY
92433: LIST
92434: LIST
92435: PPUSH
92436: CALL_OW 69
92440: PPUSH
92441: LD_VAR 0 2
92445: PPUSH
92446: CALL_OW 74
92450: PPUSH
92451: CALL_OW 115
// until IsDead ( un ) ;
92455: LD_VAR 0 2
92459: PPUSH
92460: CALL_OW 301
92464: IFFALSE 92412
// end ;
92466: PPOPN 2
92468: END
// every 0 0$1 trigger StreamModeActive and sStu do
92469: LD_EXP 113
92473: PUSH
92474: LD_EXP 152
92478: AND
92479: IFFALSE 92495
92481: GO 92483
92483: DISABLE
// begin ToLua ( displayStucuk(); ) ;
92484: LD_STRING displayStucuk();
92486: PPUSH
92487: CALL_OW 559
// ResetFog ;
92491: CALL_OW 335
// end ;
92495: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
92496: LD_EXP 113
92500: PUSH
92501: LD_EXP 145
92505: AND
92506: IFFALSE 92647
92508: GO 92510
92510: DISABLE
92511: LD_INT 0
92513: PPUSH
92514: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92515: LD_ADDR_VAR 0 2
92519: PUSH
92520: LD_INT 22
92522: PUSH
92523: LD_OWVAR 2
92527: PUSH
92528: EMPTY
92529: LIST
92530: LIST
92531: PUSH
92532: LD_INT 21
92534: PUSH
92535: LD_INT 1
92537: PUSH
92538: EMPTY
92539: LIST
92540: LIST
92541: PUSH
92542: EMPTY
92543: LIST
92544: LIST
92545: PPUSH
92546: CALL_OW 69
92550: ST_TO_ADDR
// if not tmp then
92551: LD_VAR 0 2
92555: NOT
92556: IFFALSE 92560
// exit ;
92558: GO 92647
// un := tmp [ rand ( 1 , tmp ) ] ;
92560: LD_ADDR_VAR 0 1
92564: PUSH
92565: LD_VAR 0 2
92569: PUSH
92570: LD_INT 1
92572: PPUSH
92573: LD_VAR 0 2
92577: PPUSH
92578: CALL_OW 12
92582: ARRAY
92583: ST_TO_ADDR
// SetSide ( un , 0 ) ;
92584: LD_VAR 0 1
92588: PPUSH
92589: LD_INT 0
92591: PPUSH
92592: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
92596: LD_VAR 0 1
92600: PPUSH
92601: LD_OWVAR 3
92605: PUSH
92606: LD_VAR 0 1
92610: DIFF
92611: PPUSH
92612: LD_VAR 0 1
92616: PPUSH
92617: CALL_OW 74
92621: PPUSH
92622: CALL_OW 115
// wait ( 0 0$20 ) ;
92626: LD_INT 700
92628: PPUSH
92629: CALL_OW 67
// SetSide ( un , your_side ) ;
92633: LD_VAR 0 1
92637: PPUSH
92638: LD_OWVAR 2
92642: PPUSH
92643: CALL_OW 235
// end ;
92647: PPOPN 2
92649: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
92650: LD_EXP 113
92654: PUSH
92655: LD_EXP 146
92659: AND
92660: IFFALSE 92766
92662: GO 92664
92664: DISABLE
92665: LD_INT 0
92667: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92668: LD_ADDR_VAR 0 1
92672: PUSH
92673: LD_INT 22
92675: PUSH
92676: LD_OWVAR 2
92680: PUSH
92681: EMPTY
92682: LIST
92683: LIST
92684: PUSH
92685: LD_INT 2
92687: PUSH
92688: LD_INT 30
92690: PUSH
92691: LD_INT 0
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: LD_INT 30
92700: PUSH
92701: LD_INT 1
92703: PUSH
92704: EMPTY
92705: LIST
92706: LIST
92707: PUSH
92708: EMPTY
92709: LIST
92710: LIST
92711: LIST
92712: PUSH
92713: EMPTY
92714: LIST
92715: LIST
92716: PPUSH
92717: CALL_OW 69
92721: ST_TO_ADDR
// if not depot then
92722: LD_VAR 0 1
92726: NOT
92727: IFFALSE 92731
// exit ;
92729: GO 92766
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
92731: LD_VAR 0 1
92735: PUSH
92736: LD_INT 1
92738: ARRAY
92739: PPUSH
92740: CALL_OW 250
92744: PPUSH
92745: LD_VAR 0 1
92749: PUSH
92750: LD_INT 1
92752: ARRAY
92753: PPUSH
92754: CALL_OW 251
92758: PPUSH
92759: LD_INT 70
92761: PPUSH
92762: CALL_OW 495
// end ;
92766: PPOPN 1
92768: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
92769: LD_EXP 113
92773: PUSH
92774: LD_EXP 147
92778: AND
92779: IFFALSE 92990
92781: GO 92783
92783: DISABLE
92784: LD_INT 0
92786: PPUSH
92787: PPUSH
92788: PPUSH
92789: PPUSH
92790: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92791: LD_ADDR_VAR 0 5
92795: PUSH
92796: LD_INT 22
92798: PUSH
92799: LD_OWVAR 2
92803: PUSH
92804: EMPTY
92805: LIST
92806: LIST
92807: PUSH
92808: LD_INT 21
92810: PUSH
92811: LD_INT 1
92813: PUSH
92814: EMPTY
92815: LIST
92816: LIST
92817: PUSH
92818: EMPTY
92819: LIST
92820: LIST
92821: PPUSH
92822: CALL_OW 69
92826: ST_TO_ADDR
// if not tmp then
92827: LD_VAR 0 5
92831: NOT
92832: IFFALSE 92836
// exit ;
92834: GO 92990
// for i in tmp do
92836: LD_ADDR_VAR 0 1
92840: PUSH
92841: LD_VAR 0 5
92845: PUSH
92846: FOR_IN
92847: IFFALSE 92988
// begin d := rand ( 0 , 5 ) ;
92849: LD_ADDR_VAR 0 4
92853: PUSH
92854: LD_INT 0
92856: PPUSH
92857: LD_INT 5
92859: PPUSH
92860: CALL_OW 12
92864: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
92865: LD_ADDR_VAR 0 2
92869: PUSH
92870: LD_VAR 0 1
92874: PPUSH
92875: CALL_OW 250
92879: PPUSH
92880: LD_VAR 0 4
92884: PPUSH
92885: LD_INT 3
92887: PPUSH
92888: LD_INT 12
92890: PPUSH
92891: CALL_OW 12
92895: PPUSH
92896: CALL_OW 272
92900: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
92901: LD_ADDR_VAR 0 3
92905: PUSH
92906: LD_VAR 0 1
92910: PPUSH
92911: CALL_OW 251
92915: PPUSH
92916: LD_VAR 0 4
92920: PPUSH
92921: LD_INT 3
92923: PPUSH
92924: LD_INT 12
92926: PPUSH
92927: CALL_OW 12
92931: PPUSH
92932: CALL_OW 273
92936: ST_TO_ADDR
// if ValidHex ( x , y ) then
92937: LD_VAR 0 2
92941: PPUSH
92942: LD_VAR 0 3
92946: PPUSH
92947: CALL_OW 488
92951: IFFALSE 92986
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
92953: LD_VAR 0 1
92957: PPUSH
92958: LD_VAR 0 2
92962: PPUSH
92963: LD_VAR 0 3
92967: PPUSH
92968: LD_INT 3
92970: PPUSH
92971: LD_INT 6
92973: PPUSH
92974: CALL_OW 12
92978: PPUSH
92979: LD_INT 1
92981: PPUSH
92982: CALL_OW 483
// end ;
92986: GO 92846
92988: POP
92989: POP
// end ;
92990: PPOPN 5
92992: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
92993: LD_EXP 113
92997: PUSH
92998: LD_EXP 148
93002: AND
93003: IFFALSE 93097
93005: GO 93007
93007: DISABLE
93008: LD_INT 0
93010: PPUSH
93011: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
93012: LD_ADDR_VAR 0 2
93016: PUSH
93017: LD_INT 22
93019: PUSH
93020: LD_OWVAR 2
93024: PUSH
93025: EMPTY
93026: LIST
93027: LIST
93028: PUSH
93029: LD_INT 32
93031: PUSH
93032: LD_INT 1
93034: PUSH
93035: EMPTY
93036: LIST
93037: LIST
93038: PUSH
93039: LD_INT 21
93041: PUSH
93042: LD_INT 2
93044: PUSH
93045: EMPTY
93046: LIST
93047: LIST
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: LIST
93053: PPUSH
93054: CALL_OW 69
93058: ST_TO_ADDR
// if not tmp then
93059: LD_VAR 0 2
93063: NOT
93064: IFFALSE 93068
// exit ;
93066: GO 93097
// for i in tmp do
93068: LD_ADDR_VAR 0 1
93072: PUSH
93073: LD_VAR 0 2
93077: PUSH
93078: FOR_IN
93079: IFFALSE 93095
// SetFuel ( i , 0 ) ;
93081: LD_VAR 0 1
93085: PPUSH
93086: LD_INT 0
93088: PPUSH
93089: CALL_OW 240
93093: GO 93078
93095: POP
93096: POP
// end ;
93097: PPOPN 2
93099: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
93100: LD_EXP 113
93104: PUSH
93105: LD_EXP 149
93109: AND
93110: IFFALSE 93176
93112: GO 93114
93114: DISABLE
93115: LD_INT 0
93117: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
93118: LD_ADDR_VAR 0 1
93122: PUSH
93123: LD_INT 22
93125: PUSH
93126: LD_OWVAR 2
93130: PUSH
93131: EMPTY
93132: LIST
93133: LIST
93134: PUSH
93135: LD_INT 30
93137: PUSH
93138: LD_INT 29
93140: PUSH
93141: EMPTY
93142: LIST
93143: LIST
93144: PUSH
93145: EMPTY
93146: LIST
93147: LIST
93148: PPUSH
93149: CALL_OW 69
93153: ST_TO_ADDR
// if not tmp then
93154: LD_VAR 0 1
93158: NOT
93159: IFFALSE 93163
// exit ;
93161: GO 93176
// DestroyUnit ( tmp [ 1 ] ) ;
93163: LD_VAR 0 1
93167: PUSH
93168: LD_INT 1
93170: ARRAY
93171: PPUSH
93172: CALL_OW 65
// end ;
93176: PPOPN 1
93178: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
93179: LD_EXP 113
93183: PUSH
93184: LD_EXP 151
93188: AND
93189: IFFALSE 93318
93191: GO 93193
93193: DISABLE
93194: LD_INT 0
93196: PPUSH
// begin uc_side := 0 ;
93197: LD_ADDR_OWVAR 20
93201: PUSH
93202: LD_INT 0
93204: ST_TO_ADDR
// uc_nation := nation_arabian ;
93205: LD_ADDR_OWVAR 21
93209: PUSH
93210: LD_INT 2
93212: ST_TO_ADDR
// hc_gallery :=  ;
93213: LD_ADDR_OWVAR 33
93217: PUSH
93218: LD_STRING 
93220: ST_TO_ADDR
// hc_name :=  ;
93221: LD_ADDR_OWVAR 26
93225: PUSH
93226: LD_STRING 
93228: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
93229: LD_INT 1
93231: PPUSH
93232: LD_INT 11
93234: PPUSH
93235: LD_INT 10
93237: PPUSH
93238: CALL_OW 380
// un := CreateHuman ;
93242: LD_ADDR_VAR 0 1
93246: PUSH
93247: CALL_OW 44
93251: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93252: LD_VAR 0 1
93256: PPUSH
93257: LD_INT 1
93259: PPUSH
93260: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
93264: LD_INT 35
93266: PPUSH
93267: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
93271: LD_VAR 0 1
93275: PPUSH
93276: LD_INT 22
93278: PUSH
93279: LD_OWVAR 2
93283: PUSH
93284: EMPTY
93285: LIST
93286: LIST
93287: PPUSH
93288: CALL_OW 69
93292: PPUSH
93293: LD_VAR 0 1
93297: PPUSH
93298: CALL_OW 74
93302: PPUSH
93303: CALL_OW 115
// until IsDead ( un ) ;
93307: LD_VAR 0 1
93311: PPUSH
93312: CALL_OW 301
93316: IFFALSE 93264
// end ;
93318: PPOPN 1
93320: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
93321: LD_EXP 113
93325: PUSH
93326: LD_EXP 153
93330: AND
93331: IFFALSE 93343
93333: GO 93335
93335: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
93336: LD_STRING earthquake(getX(game), 0, 32)
93338: PPUSH
93339: CALL_OW 559
93343: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
93344: LD_EXP 113
93348: PUSH
93349: LD_EXP 154
93353: AND
93354: IFFALSE 93445
93356: GO 93358
93358: DISABLE
93359: LD_INT 0
93361: PPUSH
// begin enable ;
93362: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
93363: LD_ADDR_VAR 0 1
93367: PUSH
93368: LD_INT 22
93370: PUSH
93371: LD_OWVAR 2
93375: PUSH
93376: EMPTY
93377: LIST
93378: LIST
93379: PUSH
93380: LD_INT 21
93382: PUSH
93383: LD_INT 2
93385: PUSH
93386: EMPTY
93387: LIST
93388: LIST
93389: PUSH
93390: LD_INT 33
93392: PUSH
93393: LD_INT 3
93395: PUSH
93396: EMPTY
93397: LIST
93398: LIST
93399: PUSH
93400: EMPTY
93401: LIST
93402: LIST
93403: LIST
93404: PPUSH
93405: CALL_OW 69
93409: ST_TO_ADDR
// if not tmp then
93410: LD_VAR 0 1
93414: NOT
93415: IFFALSE 93419
// exit ;
93417: GO 93445
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
93419: LD_VAR 0 1
93423: PUSH
93424: LD_INT 1
93426: PPUSH
93427: LD_VAR 0 1
93431: PPUSH
93432: CALL_OW 12
93436: ARRAY
93437: PPUSH
93438: LD_INT 1
93440: PPUSH
93441: CALL_OW 234
// end ;
93445: PPOPN 1
93447: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
93448: LD_EXP 113
93452: PUSH
93453: LD_EXP 155
93457: AND
93458: IFFALSE 93599
93460: GO 93462
93462: DISABLE
93463: LD_INT 0
93465: PPUSH
93466: PPUSH
93467: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93468: LD_ADDR_VAR 0 3
93472: PUSH
93473: LD_INT 22
93475: PUSH
93476: LD_OWVAR 2
93480: PUSH
93481: EMPTY
93482: LIST
93483: LIST
93484: PUSH
93485: LD_INT 25
93487: PUSH
93488: LD_INT 1
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: PUSH
93495: EMPTY
93496: LIST
93497: LIST
93498: PPUSH
93499: CALL_OW 69
93503: ST_TO_ADDR
// if not tmp then
93504: LD_VAR 0 3
93508: NOT
93509: IFFALSE 93513
// exit ;
93511: GO 93599
// un := tmp [ rand ( 1 , tmp ) ] ;
93513: LD_ADDR_VAR 0 2
93517: PUSH
93518: LD_VAR 0 3
93522: PUSH
93523: LD_INT 1
93525: PPUSH
93526: LD_VAR 0 3
93530: PPUSH
93531: CALL_OW 12
93535: ARRAY
93536: ST_TO_ADDR
// if Crawls ( un ) then
93537: LD_VAR 0 2
93541: PPUSH
93542: CALL_OW 318
93546: IFFALSE 93557
// ComWalk ( un ) ;
93548: LD_VAR 0 2
93552: PPUSH
93553: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
93557: LD_VAR 0 2
93561: PPUSH
93562: LD_INT 9
93564: PPUSH
93565: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
93569: LD_INT 28
93571: PPUSH
93572: LD_OWVAR 2
93576: PPUSH
93577: LD_INT 2
93579: PPUSH
93580: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
93584: LD_INT 29
93586: PPUSH
93587: LD_OWVAR 2
93591: PPUSH
93592: LD_INT 2
93594: PPUSH
93595: CALL_OW 322
// end ;
93599: PPOPN 3
93601: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
93602: LD_EXP 113
93606: PUSH
93607: LD_EXP 156
93611: AND
93612: IFFALSE 93723
93614: GO 93616
93616: DISABLE
93617: LD_INT 0
93619: PPUSH
93620: PPUSH
93621: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93622: LD_ADDR_VAR 0 3
93626: PUSH
93627: LD_INT 22
93629: PUSH
93630: LD_OWVAR 2
93634: PUSH
93635: EMPTY
93636: LIST
93637: LIST
93638: PUSH
93639: LD_INT 25
93641: PUSH
93642: LD_INT 1
93644: PUSH
93645: EMPTY
93646: LIST
93647: LIST
93648: PUSH
93649: EMPTY
93650: LIST
93651: LIST
93652: PPUSH
93653: CALL_OW 69
93657: ST_TO_ADDR
// if not tmp then
93658: LD_VAR 0 3
93662: NOT
93663: IFFALSE 93667
// exit ;
93665: GO 93723
// un := tmp [ rand ( 1 , tmp ) ] ;
93667: LD_ADDR_VAR 0 2
93671: PUSH
93672: LD_VAR 0 3
93676: PUSH
93677: LD_INT 1
93679: PPUSH
93680: LD_VAR 0 3
93684: PPUSH
93685: CALL_OW 12
93689: ARRAY
93690: ST_TO_ADDR
// if Crawls ( un ) then
93691: LD_VAR 0 2
93695: PPUSH
93696: CALL_OW 318
93700: IFFALSE 93711
// ComWalk ( un ) ;
93702: LD_VAR 0 2
93706: PPUSH
93707: CALL_OW 138
// SetClass ( un , class_mortar ) ;
93711: LD_VAR 0 2
93715: PPUSH
93716: LD_INT 8
93718: PPUSH
93719: CALL_OW 336
// end ;
93723: PPOPN 3
93725: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
93726: LD_EXP 113
93730: PUSH
93731: LD_EXP 157
93735: AND
93736: IFFALSE 93880
93738: GO 93740
93740: DISABLE
93741: LD_INT 0
93743: PPUSH
93744: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
93745: LD_ADDR_VAR 0 2
93749: PUSH
93750: LD_INT 22
93752: PUSH
93753: LD_OWVAR 2
93757: PUSH
93758: EMPTY
93759: LIST
93760: LIST
93761: PUSH
93762: LD_INT 21
93764: PUSH
93765: LD_INT 2
93767: PUSH
93768: EMPTY
93769: LIST
93770: LIST
93771: PUSH
93772: LD_INT 2
93774: PUSH
93775: LD_INT 34
93777: PUSH
93778: LD_INT 12
93780: PUSH
93781: EMPTY
93782: LIST
93783: LIST
93784: PUSH
93785: LD_INT 34
93787: PUSH
93788: LD_INT 51
93790: PUSH
93791: EMPTY
93792: LIST
93793: LIST
93794: PUSH
93795: LD_INT 34
93797: PUSH
93798: LD_INT 32
93800: PUSH
93801: EMPTY
93802: LIST
93803: LIST
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: LIST
93809: LIST
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: LIST
93815: PPUSH
93816: CALL_OW 69
93820: ST_TO_ADDR
// if not tmp then
93821: LD_VAR 0 2
93825: NOT
93826: IFFALSE 93830
// exit ;
93828: GO 93880
// for i in tmp do
93830: LD_ADDR_VAR 0 1
93834: PUSH
93835: LD_VAR 0 2
93839: PUSH
93840: FOR_IN
93841: IFFALSE 93878
// if GetCargo ( i , mat_artifact ) = 0 then
93843: LD_VAR 0 1
93847: PPUSH
93848: LD_INT 4
93850: PPUSH
93851: CALL_OW 289
93855: PUSH
93856: LD_INT 0
93858: EQUAL
93859: IFFALSE 93876
// SetCargo ( i , mat_siberit , 100 ) ;
93861: LD_VAR 0 1
93865: PPUSH
93866: LD_INT 3
93868: PPUSH
93869: LD_INT 100
93871: PPUSH
93872: CALL_OW 290
93876: GO 93840
93878: POP
93879: POP
// end ;
93880: PPOPN 2
93882: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
93883: LD_EXP 113
93887: PUSH
93888: LD_EXP 158
93892: AND
93893: IFFALSE 94076
93895: GO 93897
93897: DISABLE
93898: LD_INT 0
93900: PPUSH
93901: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
93902: LD_ADDR_VAR 0 2
93906: PUSH
93907: LD_INT 22
93909: PUSH
93910: LD_OWVAR 2
93914: PUSH
93915: EMPTY
93916: LIST
93917: LIST
93918: PPUSH
93919: CALL_OW 69
93923: ST_TO_ADDR
// if not tmp then
93924: LD_VAR 0 2
93928: NOT
93929: IFFALSE 93933
// exit ;
93931: GO 94076
// for i := 1 to 2 do
93933: LD_ADDR_VAR 0 1
93937: PUSH
93938: DOUBLE
93939: LD_INT 1
93941: DEC
93942: ST_TO_ADDR
93943: LD_INT 2
93945: PUSH
93946: FOR_TO
93947: IFFALSE 94074
// begin uc_side := your_side ;
93949: LD_ADDR_OWVAR 20
93953: PUSH
93954: LD_OWVAR 2
93958: ST_TO_ADDR
// uc_nation := nation_american ;
93959: LD_ADDR_OWVAR 21
93963: PUSH
93964: LD_INT 1
93966: ST_TO_ADDR
// vc_chassis := us_morphling ;
93967: LD_ADDR_OWVAR 37
93971: PUSH
93972: LD_INT 5
93974: ST_TO_ADDR
// vc_engine := engine_siberite ;
93975: LD_ADDR_OWVAR 39
93979: PUSH
93980: LD_INT 3
93982: ST_TO_ADDR
// vc_control := control_computer ;
93983: LD_ADDR_OWVAR 38
93987: PUSH
93988: LD_INT 3
93990: ST_TO_ADDR
// vc_weapon := us_double_laser ;
93991: LD_ADDR_OWVAR 40
93995: PUSH
93996: LD_INT 10
93998: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
93999: LD_VAR 0 2
94003: PUSH
94004: LD_INT 1
94006: ARRAY
94007: PPUSH
94008: CALL_OW 310
94012: NOT
94013: IFFALSE 94060
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
94015: CALL_OW 45
94019: PPUSH
94020: LD_VAR 0 2
94024: PUSH
94025: LD_INT 1
94027: ARRAY
94028: PPUSH
94029: CALL_OW 250
94033: PPUSH
94034: LD_VAR 0 2
94038: PUSH
94039: LD_INT 1
94041: ARRAY
94042: PPUSH
94043: CALL_OW 251
94047: PPUSH
94048: LD_INT 12
94050: PPUSH
94051: LD_INT 1
94053: PPUSH
94054: CALL_OW 50
94058: GO 94072
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
94060: CALL_OW 45
94064: PPUSH
94065: LD_INT 1
94067: PPUSH
94068: CALL_OW 51
// end ;
94072: GO 93946
94074: POP
94075: POP
// end ;
94076: PPOPN 2
94078: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
94079: LD_EXP 113
94083: PUSH
94084: LD_EXP 159
94088: AND
94089: IFFALSE 94311
94091: GO 94093
94093: DISABLE
94094: LD_INT 0
94096: PPUSH
94097: PPUSH
94098: PPUSH
94099: PPUSH
94100: PPUSH
94101: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94102: LD_ADDR_VAR 0 6
94106: PUSH
94107: LD_INT 22
94109: PUSH
94110: LD_OWVAR 2
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: PUSH
94119: LD_INT 21
94121: PUSH
94122: LD_INT 1
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: PUSH
94129: LD_INT 3
94131: PUSH
94132: LD_INT 23
94134: PUSH
94135: LD_INT 0
94137: PUSH
94138: EMPTY
94139: LIST
94140: LIST
94141: PUSH
94142: EMPTY
94143: LIST
94144: LIST
94145: PUSH
94146: EMPTY
94147: LIST
94148: LIST
94149: LIST
94150: PPUSH
94151: CALL_OW 69
94155: ST_TO_ADDR
// if not tmp then
94156: LD_VAR 0 6
94160: NOT
94161: IFFALSE 94165
// exit ;
94163: GO 94311
// s1 := rand ( 1 , 4 ) ;
94165: LD_ADDR_VAR 0 2
94169: PUSH
94170: LD_INT 1
94172: PPUSH
94173: LD_INT 4
94175: PPUSH
94176: CALL_OW 12
94180: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
94181: LD_ADDR_VAR 0 4
94185: PUSH
94186: LD_VAR 0 6
94190: PUSH
94191: LD_INT 1
94193: ARRAY
94194: PPUSH
94195: LD_VAR 0 2
94199: PPUSH
94200: CALL_OW 259
94204: ST_TO_ADDR
// if s1 = 1 then
94205: LD_VAR 0 2
94209: PUSH
94210: LD_INT 1
94212: EQUAL
94213: IFFALSE 94233
// s2 := rand ( 2 , 4 ) else
94215: LD_ADDR_VAR 0 3
94219: PUSH
94220: LD_INT 2
94222: PPUSH
94223: LD_INT 4
94225: PPUSH
94226: CALL_OW 12
94230: ST_TO_ADDR
94231: GO 94241
// s2 := 1 ;
94233: LD_ADDR_VAR 0 3
94237: PUSH
94238: LD_INT 1
94240: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
94241: LD_ADDR_VAR 0 5
94245: PUSH
94246: LD_VAR 0 6
94250: PUSH
94251: LD_INT 1
94253: ARRAY
94254: PPUSH
94255: LD_VAR 0 3
94259: PPUSH
94260: CALL_OW 259
94264: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
94265: LD_VAR 0 6
94269: PUSH
94270: LD_INT 1
94272: ARRAY
94273: PPUSH
94274: LD_VAR 0 2
94278: PPUSH
94279: LD_VAR 0 5
94283: PPUSH
94284: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
94288: LD_VAR 0 6
94292: PUSH
94293: LD_INT 1
94295: ARRAY
94296: PPUSH
94297: LD_VAR 0 3
94301: PPUSH
94302: LD_VAR 0 4
94306: PPUSH
94307: CALL_OW 237
// end ;
94311: PPOPN 6
94313: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
94314: LD_EXP 113
94318: PUSH
94319: LD_EXP 160
94323: AND
94324: IFFALSE 94403
94326: GO 94328
94328: DISABLE
94329: LD_INT 0
94331: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
94332: LD_ADDR_VAR 0 1
94336: PUSH
94337: LD_INT 22
94339: PUSH
94340: LD_OWVAR 2
94344: PUSH
94345: EMPTY
94346: LIST
94347: LIST
94348: PUSH
94349: LD_INT 30
94351: PUSH
94352: LD_INT 3
94354: PUSH
94355: EMPTY
94356: LIST
94357: LIST
94358: PUSH
94359: EMPTY
94360: LIST
94361: LIST
94362: PPUSH
94363: CALL_OW 69
94367: ST_TO_ADDR
// if not tmp then
94368: LD_VAR 0 1
94372: NOT
94373: IFFALSE 94377
// exit ;
94375: GO 94403
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
94377: LD_VAR 0 1
94381: PUSH
94382: LD_INT 1
94384: PPUSH
94385: LD_VAR 0 1
94389: PPUSH
94390: CALL_OW 12
94394: ARRAY
94395: PPUSH
94396: LD_INT 1
94398: PPUSH
94399: CALL_OW 234
// end ;
94403: PPOPN 1
94405: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
94406: LD_EXP 113
94410: PUSH
94411: LD_EXP 161
94415: AND
94416: IFFALSE 94528
94418: GO 94420
94420: DISABLE
94421: LD_INT 0
94423: PPUSH
94424: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
94425: LD_ADDR_VAR 0 2
94429: PUSH
94430: LD_INT 22
94432: PUSH
94433: LD_OWVAR 2
94437: PUSH
94438: EMPTY
94439: LIST
94440: LIST
94441: PUSH
94442: LD_INT 2
94444: PUSH
94445: LD_INT 30
94447: PUSH
94448: LD_INT 27
94450: PUSH
94451: EMPTY
94452: LIST
94453: LIST
94454: PUSH
94455: LD_INT 30
94457: PUSH
94458: LD_INT 26
94460: PUSH
94461: EMPTY
94462: LIST
94463: LIST
94464: PUSH
94465: LD_INT 30
94467: PUSH
94468: LD_INT 28
94470: PUSH
94471: EMPTY
94472: LIST
94473: LIST
94474: PUSH
94475: EMPTY
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: PUSH
94481: EMPTY
94482: LIST
94483: LIST
94484: PPUSH
94485: CALL_OW 69
94489: ST_TO_ADDR
// if not tmp then
94490: LD_VAR 0 2
94494: NOT
94495: IFFALSE 94499
// exit ;
94497: GO 94528
// for i in tmp do
94499: LD_ADDR_VAR 0 1
94503: PUSH
94504: LD_VAR 0 2
94508: PUSH
94509: FOR_IN
94510: IFFALSE 94526
// SetLives ( i , 1 ) ;
94512: LD_VAR 0 1
94516: PPUSH
94517: LD_INT 1
94519: PPUSH
94520: CALL_OW 234
94524: GO 94509
94526: POP
94527: POP
// end ;
94528: PPOPN 2
94530: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
94531: LD_EXP 113
94535: PUSH
94536: LD_EXP 162
94540: AND
94541: IFFALSE 94828
94543: GO 94545
94545: DISABLE
94546: LD_INT 0
94548: PPUSH
94549: PPUSH
94550: PPUSH
// begin i := rand ( 1 , 7 ) ;
94551: LD_ADDR_VAR 0 1
94555: PUSH
94556: LD_INT 1
94558: PPUSH
94559: LD_INT 7
94561: PPUSH
94562: CALL_OW 12
94566: ST_TO_ADDR
// case i of 1 :
94567: LD_VAR 0 1
94571: PUSH
94572: LD_INT 1
94574: DOUBLE
94575: EQUAL
94576: IFTRUE 94580
94578: GO 94590
94580: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
94581: LD_STRING earthquake(getX(game), 0, 32)
94583: PPUSH
94584: CALL_OW 559
94588: GO 94828
94590: LD_INT 2
94592: DOUBLE
94593: EQUAL
94594: IFTRUE 94598
94596: GO 94612
94598: POP
// begin ToLua ( displayStucuk(); ) ;
94599: LD_STRING displayStucuk();
94601: PPUSH
94602: CALL_OW 559
// ResetFog ;
94606: CALL_OW 335
// end ; 3 :
94610: GO 94828
94612: LD_INT 3
94614: DOUBLE
94615: EQUAL
94616: IFTRUE 94620
94618: GO 94724
94620: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94621: LD_ADDR_VAR 0 2
94625: PUSH
94626: LD_INT 22
94628: PUSH
94629: LD_OWVAR 2
94633: PUSH
94634: EMPTY
94635: LIST
94636: LIST
94637: PUSH
94638: LD_INT 25
94640: PUSH
94641: LD_INT 1
94643: PUSH
94644: EMPTY
94645: LIST
94646: LIST
94647: PUSH
94648: EMPTY
94649: LIST
94650: LIST
94651: PPUSH
94652: CALL_OW 69
94656: ST_TO_ADDR
// if not tmp then
94657: LD_VAR 0 2
94661: NOT
94662: IFFALSE 94666
// exit ;
94664: GO 94828
// un := tmp [ rand ( 1 , tmp ) ] ;
94666: LD_ADDR_VAR 0 3
94670: PUSH
94671: LD_VAR 0 2
94675: PUSH
94676: LD_INT 1
94678: PPUSH
94679: LD_VAR 0 2
94683: PPUSH
94684: CALL_OW 12
94688: ARRAY
94689: ST_TO_ADDR
// if Crawls ( un ) then
94690: LD_VAR 0 3
94694: PPUSH
94695: CALL_OW 318
94699: IFFALSE 94710
// ComWalk ( un ) ;
94701: LD_VAR 0 3
94705: PPUSH
94706: CALL_OW 138
// SetClass ( un , class_mortar ) ;
94710: LD_VAR 0 3
94714: PPUSH
94715: LD_INT 8
94717: PPUSH
94718: CALL_OW 336
// end ; 4 :
94722: GO 94828
94724: LD_INT 4
94726: DOUBLE
94727: EQUAL
94728: IFTRUE 94732
94730: GO 94806
94732: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
94733: LD_ADDR_VAR 0 2
94737: PUSH
94738: LD_INT 22
94740: PUSH
94741: LD_OWVAR 2
94745: PUSH
94746: EMPTY
94747: LIST
94748: LIST
94749: PUSH
94750: LD_INT 30
94752: PUSH
94753: LD_INT 29
94755: PUSH
94756: EMPTY
94757: LIST
94758: LIST
94759: PUSH
94760: EMPTY
94761: LIST
94762: LIST
94763: PPUSH
94764: CALL_OW 69
94768: ST_TO_ADDR
// if not tmp then
94769: LD_VAR 0 2
94773: NOT
94774: IFFALSE 94778
// exit ;
94776: GO 94828
// CenterNowOnUnits ( tmp [ 1 ] ) ;
94778: LD_VAR 0 2
94782: PUSH
94783: LD_INT 1
94785: ARRAY
94786: PPUSH
94787: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
94791: LD_VAR 0 2
94795: PUSH
94796: LD_INT 1
94798: ARRAY
94799: PPUSH
94800: CALL_OW 65
// end ; 5 .. 7 :
94804: GO 94828
94806: LD_INT 5
94808: DOUBLE
94809: GREATEREQUAL
94810: IFFALSE 94818
94812: LD_INT 7
94814: DOUBLE
94815: LESSEQUAL
94816: IFTRUE 94820
94818: GO 94827
94820: POP
// StreamSibBomb ; end ;
94821: CALL 91065 0 0
94825: GO 94828
94827: POP
// end ;
94828: PPOPN 3
94830: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
94831: LD_EXP 113
94835: PUSH
94836: LD_EXP 163
94840: AND
94841: IFFALSE 94997
94843: GO 94845
94845: DISABLE
94846: LD_INT 0
94848: PPUSH
94849: PPUSH
94850: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
94851: LD_ADDR_VAR 0 2
94855: PUSH
94856: LD_INT 81
94858: PUSH
94859: LD_OWVAR 2
94863: PUSH
94864: EMPTY
94865: LIST
94866: LIST
94867: PUSH
94868: LD_INT 2
94870: PUSH
94871: LD_INT 21
94873: PUSH
94874: LD_INT 1
94876: PUSH
94877: EMPTY
94878: LIST
94879: LIST
94880: PUSH
94881: LD_INT 21
94883: PUSH
94884: LD_INT 2
94886: PUSH
94887: EMPTY
94888: LIST
94889: LIST
94890: PUSH
94891: EMPTY
94892: LIST
94893: LIST
94894: LIST
94895: PUSH
94896: EMPTY
94897: LIST
94898: LIST
94899: PPUSH
94900: CALL_OW 69
94904: ST_TO_ADDR
// if not tmp then
94905: LD_VAR 0 2
94909: NOT
94910: IFFALSE 94914
// exit ;
94912: GO 94997
// p := 0 ;
94914: LD_ADDR_VAR 0 3
94918: PUSH
94919: LD_INT 0
94921: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
94922: LD_INT 35
94924: PPUSH
94925: CALL_OW 67
// p := p + 1 ;
94929: LD_ADDR_VAR 0 3
94933: PUSH
94934: LD_VAR 0 3
94938: PUSH
94939: LD_INT 1
94941: PLUS
94942: ST_TO_ADDR
// for i in tmp do
94943: LD_ADDR_VAR 0 1
94947: PUSH
94948: LD_VAR 0 2
94952: PUSH
94953: FOR_IN
94954: IFFALSE 94985
// if GetLives ( i ) < 1000 then
94956: LD_VAR 0 1
94960: PPUSH
94961: CALL_OW 256
94965: PUSH
94966: LD_INT 1000
94968: LESS
94969: IFFALSE 94983
// SetLives ( i , 1000 ) ;
94971: LD_VAR 0 1
94975: PPUSH
94976: LD_INT 1000
94978: PPUSH
94979: CALL_OW 234
94983: GO 94953
94985: POP
94986: POP
// until p > 20 ;
94987: LD_VAR 0 3
94991: PUSH
94992: LD_INT 20
94994: GREATER
94995: IFFALSE 94922
// end ;
94997: PPOPN 3
94999: END
// every 0 0$1 trigger StreamModeActive and sTime do
95000: LD_EXP 113
95004: PUSH
95005: LD_EXP 164
95009: AND
95010: IFFALSE 95045
95012: GO 95014
95014: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
95015: LD_INT 28
95017: PPUSH
95018: LD_OWVAR 2
95022: PPUSH
95023: LD_INT 2
95025: PPUSH
95026: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
95030: LD_INT 30
95032: PPUSH
95033: LD_OWVAR 2
95037: PPUSH
95038: LD_INT 2
95040: PPUSH
95041: CALL_OW 322
// end ;
95045: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
95046: LD_EXP 113
95050: PUSH
95051: LD_EXP 165
95055: AND
95056: IFFALSE 95177
95058: GO 95060
95060: DISABLE
95061: LD_INT 0
95063: PPUSH
95064: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95065: LD_ADDR_VAR 0 2
95069: PUSH
95070: LD_INT 22
95072: PUSH
95073: LD_OWVAR 2
95077: PUSH
95078: EMPTY
95079: LIST
95080: LIST
95081: PUSH
95082: LD_INT 21
95084: PUSH
95085: LD_INT 1
95087: PUSH
95088: EMPTY
95089: LIST
95090: LIST
95091: PUSH
95092: LD_INT 3
95094: PUSH
95095: LD_INT 23
95097: PUSH
95098: LD_INT 0
95100: PUSH
95101: EMPTY
95102: LIST
95103: LIST
95104: PUSH
95105: EMPTY
95106: LIST
95107: LIST
95108: PUSH
95109: EMPTY
95110: LIST
95111: LIST
95112: LIST
95113: PPUSH
95114: CALL_OW 69
95118: ST_TO_ADDR
// if not tmp then
95119: LD_VAR 0 2
95123: NOT
95124: IFFALSE 95128
// exit ;
95126: GO 95177
// for i in tmp do
95128: LD_ADDR_VAR 0 1
95132: PUSH
95133: LD_VAR 0 2
95137: PUSH
95138: FOR_IN
95139: IFFALSE 95175
// begin if Crawls ( i ) then
95141: LD_VAR 0 1
95145: PPUSH
95146: CALL_OW 318
95150: IFFALSE 95161
// ComWalk ( i ) ;
95152: LD_VAR 0 1
95156: PPUSH
95157: CALL_OW 138
// SetClass ( i , 2 ) ;
95161: LD_VAR 0 1
95165: PPUSH
95166: LD_INT 2
95168: PPUSH
95169: CALL_OW 336
// end ;
95173: GO 95138
95175: POP
95176: POP
// end ;
95177: PPOPN 2
95179: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
95180: LD_EXP 113
95184: PUSH
95185: LD_EXP 166
95189: AND
95190: IFFALSE 95478
95192: GO 95194
95194: DISABLE
95195: LD_INT 0
95197: PPUSH
95198: PPUSH
95199: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
95200: LD_OWVAR 2
95204: PPUSH
95205: LD_INT 9
95207: PPUSH
95208: LD_INT 1
95210: PPUSH
95211: LD_INT 1
95213: PPUSH
95214: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
95218: LD_INT 9
95220: PPUSH
95221: LD_OWVAR 2
95225: PPUSH
95226: CALL_OW 343
// uc_side := 9 ;
95230: LD_ADDR_OWVAR 20
95234: PUSH
95235: LD_INT 9
95237: ST_TO_ADDR
// uc_nation := 2 ;
95238: LD_ADDR_OWVAR 21
95242: PUSH
95243: LD_INT 2
95245: ST_TO_ADDR
// hc_name := Dark Warrior ;
95246: LD_ADDR_OWVAR 26
95250: PUSH
95251: LD_STRING Dark Warrior
95253: ST_TO_ADDR
// hc_gallery :=  ;
95254: LD_ADDR_OWVAR 33
95258: PUSH
95259: LD_STRING 
95261: ST_TO_ADDR
// hc_noskilllimit := true ;
95262: LD_ADDR_OWVAR 76
95266: PUSH
95267: LD_INT 1
95269: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
95270: LD_ADDR_OWVAR 31
95274: PUSH
95275: LD_INT 30
95277: PUSH
95278: LD_INT 30
95280: PUSH
95281: LD_INT 30
95283: PUSH
95284: LD_INT 30
95286: PUSH
95287: EMPTY
95288: LIST
95289: LIST
95290: LIST
95291: LIST
95292: ST_TO_ADDR
// un := CreateHuman ;
95293: LD_ADDR_VAR 0 3
95297: PUSH
95298: CALL_OW 44
95302: ST_TO_ADDR
// hc_noskilllimit := false ;
95303: LD_ADDR_OWVAR 76
95307: PUSH
95308: LD_INT 0
95310: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95311: LD_VAR 0 3
95315: PPUSH
95316: LD_INT 1
95318: PPUSH
95319: CALL_OW 51
// ToLua ( playRanger() ) ;
95323: LD_STRING playRanger()
95325: PPUSH
95326: CALL_OW 559
// p := 0 ;
95330: LD_ADDR_VAR 0 2
95334: PUSH
95335: LD_INT 0
95337: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
95338: LD_INT 35
95340: PPUSH
95341: CALL_OW 67
// p := p + 1 ;
95345: LD_ADDR_VAR 0 2
95349: PUSH
95350: LD_VAR 0 2
95354: PUSH
95355: LD_INT 1
95357: PLUS
95358: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
95359: LD_VAR 0 3
95363: PPUSH
95364: CALL_OW 256
95368: PUSH
95369: LD_INT 1000
95371: LESS
95372: IFFALSE 95386
// SetLives ( un , 1000 ) ;
95374: LD_VAR 0 3
95378: PPUSH
95379: LD_INT 1000
95381: PPUSH
95382: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
95386: LD_VAR 0 3
95390: PPUSH
95391: LD_INT 81
95393: PUSH
95394: LD_OWVAR 2
95398: PUSH
95399: EMPTY
95400: LIST
95401: LIST
95402: PUSH
95403: LD_INT 91
95405: PUSH
95406: LD_VAR 0 3
95410: PUSH
95411: LD_INT 30
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: LIST
95418: PUSH
95419: EMPTY
95420: LIST
95421: LIST
95422: PPUSH
95423: CALL_OW 69
95427: PPUSH
95428: LD_VAR 0 3
95432: PPUSH
95433: CALL_OW 74
95437: PPUSH
95438: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
95442: LD_VAR 0 2
95446: PUSH
95447: LD_INT 80
95449: GREATER
95450: PUSH
95451: LD_VAR 0 3
95455: PPUSH
95456: CALL_OW 301
95460: OR
95461: IFFALSE 95338
// if un then
95463: LD_VAR 0 3
95467: IFFALSE 95478
// RemoveUnit ( un ) ;
95469: LD_VAR 0 3
95473: PPUSH
95474: CALL_OW 64
// end ;
95478: PPOPN 3
95480: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
95481: LD_EXP 167
95485: IFFALSE 95601
95487: GO 95489
95489: DISABLE
95490: LD_INT 0
95492: PPUSH
95493: PPUSH
95494: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
95495: LD_ADDR_VAR 0 2
95499: PUSH
95500: LD_INT 81
95502: PUSH
95503: LD_OWVAR 2
95507: PUSH
95508: EMPTY
95509: LIST
95510: LIST
95511: PUSH
95512: LD_INT 21
95514: PUSH
95515: LD_INT 1
95517: PUSH
95518: EMPTY
95519: LIST
95520: LIST
95521: PUSH
95522: EMPTY
95523: LIST
95524: LIST
95525: PPUSH
95526: CALL_OW 69
95530: ST_TO_ADDR
// ToLua ( playComputer() ) ;
95531: LD_STRING playComputer()
95533: PPUSH
95534: CALL_OW 559
// if not tmp then
95538: LD_VAR 0 2
95542: NOT
95543: IFFALSE 95547
// exit ;
95545: GO 95601
// for i in tmp do
95547: LD_ADDR_VAR 0 1
95551: PUSH
95552: LD_VAR 0 2
95556: PUSH
95557: FOR_IN
95558: IFFALSE 95599
// for j := 1 to 4 do
95560: LD_ADDR_VAR 0 3
95564: PUSH
95565: DOUBLE
95566: LD_INT 1
95568: DEC
95569: ST_TO_ADDR
95570: LD_INT 4
95572: PUSH
95573: FOR_TO
95574: IFFALSE 95595
// SetSkill ( i , j , 10 ) ;
95576: LD_VAR 0 1
95580: PPUSH
95581: LD_VAR 0 3
95585: PPUSH
95586: LD_INT 10
95588: PPUSH
95589: CALL_OW 237
95593: GO 95573
95595: POP
95596: POP
95597: GO 95557
95599: POP
95600: POP
// end ;
95601: PPOPN 3
95603: END
// every 0 0$1 trigger s30 do var i , tmp ;
95604: LD_EXP 168
95608: IFFALSE 95677
95610: GO 95612
95612: DISABLE
95613: LD_INT 0
95615: PPUSH
95616: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
95617: LD_ADDR_VAR 0 2
95621: PUSH
95622: LD_INT 22
95624: PUSH
95625: LD_OWVAR 2
95629: PUSH
95630: EMPTY
95631: LIST
95632: LIST
95633: PPUSH
95634: CALL_OW 69
95638: ST_TO_ADDR
// if not tmp then
95639: LD_VAR 0 2
95643: NOT
95644: IFFALSE 95648
// exit ;
95646: GO 95677
// for i in tmp do
95648: LD_ADDR_VAR 0 1
95652: PUSH
95653: LD_VAR 0 2
95657: PUSH
95658: FOR_IN
95659: IFFALSE 95675
// SetLives ( i , 300 ) ;
95661: LD_VAR 0 1
95665: PPUSH
95666: LD_INT 300
95668: PPUSH
95669: CALL_OW 234
95673: GO 95658
95675: POP
95676: POP
// end ;
95677: PPOPN 2
95679: END
// every 0 0$1 trigger s60 do var i , tmp ;
95680: LD_EXP 169
95684: IFFALSE 95753
95686: GO 95688
95688: DISABLE
95689: LD_INT 0
95691: PPUSH
95692: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
95693: LD_ADDR_VAR 0 2
95697: PUSH
95698: LD_INT 22
95700: PUSH
95701: LD_OWVAR 2
95705: PUSH
95706: EMPTY
95707: LIST
95708: LIST
95709: PPUSH
95710: CALL_OW 69
95714: ST_TO_ADDR
// if not tmp then
95715: LD_VAR 0 2
95719: NOT
95720: IFFALSE 95724
// exit ;
95722: GO 95753
// for i in tmp do
95724: LD_ADDR_VAR 0 1
95728: PUSH
95729: LD_VAR 0 2
95733: PUSH
95734: FOR_IN
95735: IFFALSE 95751
// SetLives ( i , 600 ) ;
95737: LD_VAR 0 1
95741: PPUSH
95742: LD_INT 600
95744: PPUSH
95745: CALL_OW 234
95749: GO 95734
95751: POP
95752: POP
// end ;
95753: PPOPN 2
95755: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
95756: LD_INT 0
95758: PPUSH
// case cmd of 301 :
95759: LD_VAR 0 1
95763: PUSH
95764: LD_INT 301
95766: DOUBLE
95767: EQUAL
95768: IFTRUE 95772
95770: GO 95804
95772: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
95773: LD_VAR 0 6
95777: PPUSH
95778: LD_VAR 0 7
95782: PPUSH
95783: LD_VAR 0 8
95787: PPUSH
95788: LD_VAR 0 4
95792: PPUSH
95793: LD_VAR 0 5
95797: PPUSH
95798: CALL 97005 0 5
95802: GO 95925
95804: LD_INT 302
95806: DOUBLE
95807: EQUAL
95808: IFTRUE 95812
95810: GO 95849
95812: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
95813: LD_VAR 0 6
95817: PPUSH
95818: LD_VAR 0 7
95822: PPUSH
95823: LD_VAR 0 8
95827: PPUSH
95828: LD_VAR 0 9
95832: PPUSH
95833: LD_VAR 0 4
95837: PPUSH
95838: LD_VAR 0 5
95842: PPUSH
95843: CALL 97096 0 6
95847: GO 95925
95849: LD_INT 303
95851: DOUBLE
95852: EQUAL
95853: IFTRUE 95857
95855: GO 95894
95857: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
95858: LD_VAR 0 6
95862: PPUSH
95863: LD_VAR 0 7
95867: PPUSH
95868: LD_VAR 0 8
95872: PPUSH
95873: LD_VAR 0 9
95877: PPUSH
95878: LD_VAR 0 4
95882: PPUSH
95883: LD_VAR 0 5
95887: PPUSH
95888: CALL 95930 0 6
95892: GO 95925
95894: LD_INT 304
95896: DOUBLE
95897: EQUAL
95898: IFTRUE 95902
95900: GO 95924
95902: POP
// hHackTeleport ( unit , x , y ) ; end ;
95903: LD_VAR 0 2
95907: PPUSH
95908: LD_VAR 0 4
95912: PPUSH
95913: LD_VAR 0 5
95917: PPUSH
95918: CALL 97689 0 3
95922: GO 95925
95924: POP
// end ;
95925: LD_VAR 0 12
95929: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
95930: LD_INT 0
95932: PPUSH
95933: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
95934: LD_VAR 0 1
95938: PUSH
95939: LD_INT 1
95941: LESS
95942: PUSH
95943: LD_VAR 0 1
95947: PUSH
95948: LD_INT 3
95950: GREATER
95951: OR
95952: PUSH
95953: LD_VAR 0 5
95957: PPUSH
95958: LD_VAR 0 6
95962: PPUSH
95963: CALL_OW 428
95967: OR
95968: IFFALSE 95972
// exit ;
95970: GO 96692
// uc_side := your_side ;
95972: LD_ADDR_OWVAR 20
95976: PUSH
95977: LD_OWVAR 2
95981: ST_TO_ADDR
// uc_nation := nation ;
95982: LD_ADDR_OWVAR 21
95986: PUSH
95987: LD_VAR 0 1
95991: ST_TO_ADDR
// bc_level = 1 ;
95992: LD_ADDR_OWVAR 43
95996: PUSH
95997: LD_INT 1
95999: ST_TO_ADDR
// case btype of 1 :
96000: LD_VAR 0 2
96004: PUSH
96005: LD_INT 1
96007: DOUBLE
96008: EQUAL
96009: IFTRUE 96013
96011: GO 96024
96013: POP
// bc_type := b_depot ; 2 :
96014: LD_ADDR_OWVAR 42
96018: PUSH
96019: LD_INT 0
96021: ST_TO_ADDR
96022: GO 96636
96024: LD_INT 2
96026: DOUBLE
96027: EQUAL
96028: IFTRUE 96032
96030: GO 96043
96032: POP
// bc_type := b_warehouse ; 3 :
96033: LD_ADDR_OWVAR 42
96037: PUSH
96038: LD_INT 1
96040: ST_TO_ADDR
96041: GO 96636
96043: LD_INT 3
96045: DOUBLE
96046: EQUAL
96047: IFTRUE 96051
96049: GO 96062
96051: POP
// bc_type := b_lab ; 4 .. 9 :
96052: LD_ADDR_OWVAR 42
96056: PUSH
96057: LD_INT 6
96059: ST_TO_ADDR
96060: GO 96636
96062: LD_INT 4
96064: DOUBLE
96065: GREATEREQUAL
96066: IFFALSE 96074
96068: LD_INT 9
96070: DOUBLE
96071: LESSEQUAL
96072: IFTRUE 96076
96074: GO 96128
96076: POP
// begin bc_type := b_lab_half ;
96077: LD_ADDR_OWVAR 42
96081: PUSH
96082: LD_INT 7
96084: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
96085: LD_ADDR_OWVAR 44
96089: PUSH
96090: LD_INT 10
96092: PUSH
96093: LD_INT 11
96095: PUSH
96096: LD_INT 12
96098: PUSH
96099: LD_INT 15
96101: PUSH
96102: LD_INT 14
96104: PUSH
96105: LD_INT 13
96107: PUSH
96108: EMPTY
96109: LIST
96110: LIST
96111: LIST
96112: LIST
96113: LIST
96114: LIST
96115: PUSH
96116: LD_VAR 0 2
96120: PUSH
96121: LD_INT 3
96123: MINUS
96124: ARRAY
96125: ST_TO_ADDR
// end ; 10 .. 13 :
96126: GO 96636
96128: LD_INT 10
96130: DOUBLE
96131: GREATEREQUAL
96132: IFFALSE 96140
96134: LD_INT 13
96136: DOUBLE
96137: LESSEQUAL
96138: IFTRUE 96142
96140: GO 96219
96142: POP
// begin bc_type := b_lab_full ;
96143: LD_ADDR_OWVAR 42
96147: PUSH
96148: LD_INT 8
96150: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
96151: LD_ADDR_OWVAR 44
96155: PUSH
96156: LD_INT 10
96158: PUSH
96159: LD_INT 12
96161: PUSH
96162: LD_INT 14
96164: PUSH
96165: LD_INT 13
96167: PUSH
96168: EMPTY
96169: LIST
96170: LIST
96171: LIST
96172: LIST
96173: PUSH
96174: LD_VAR 0 2
96178: PUSH
96179: LD_INT 9
96181: MINUS
96182: ARRAY
96183: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
96184: LD_ADDR_OWVAR 45
96188: PUSH
96189: LD_INT 11
96191: PUSH
96192: LD_INT 15
96194: PUSH
96195: LD_INT 12
96197: PUSH
96198: LD_INT 15
96200: PUSH
96201: EMPTY
96202: LIST
96203: LIST
96204: LIST
96205: LIST
96206: PUSH
96207: LD_VAR 0 2
96211: PUSH
96212: LD_INT 9
96214: MINUS
96215: ARRAY
96216: ST_TO_ADDR
// end ; 14 :
96217: GO 96636
96219: LD_INT 14
96221: DOUBLE
96222: EQUAL
96223: IFTRUE 96227
96225: GO 96238
96227: POP
// bc_type := b_workshop ; 15 :
96228: LD_ADDR_OWVAR 42
96232: PUSH
96233: LD_INT 2
96235: ST_TO_ADDR
96236: GO 96636
96238: LD_INT 15
96240: DOUBLE
96241: EQUAL
96242: IFTRUE 96246
96244: GO 96257
96246: POP
// bc_type := b_factory ; 16 :
96247: LD_ADDR_OWVAR 42
96251: PUSH
96252: LD_INT 3
96254: ST_TO_ADDR
96255: GO 96636
96257: LD_INT 16
96259: DOUBLE
96260: EQUAL
96261: IFTRUE 96265
96263: GO 96276
96265: POP
// bc_type := b_ext_gun ; 17 :
96266: LD_ADDR_OWVAR 42
96270: PUSH
96271: LD_INT 17
96273: ST_TO_ADDR
96274: GO 96636
96276: LD_INT 17
96278: DOUBLE
96279: EQUAL
96280: IFTRUE 96284
96282: GO 96312
96284: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
96285: LD_ADDR_OWVAR 42
96289: PUSH
96290: LD_INT 19
96292: PUSH
96293: LD_INT 23
96295: PUSH
96296: LD_INT 19
96298: PUSH
96299: EMPTY
96300: LIST
96301: LIST
96302: LIST
96303: PUSH
96304: LD_VAR 0 1
96308: ARRAY
96309: ST_TO_ADDR
96310: GO 96636
96312: LD_INT 18
96314: DOUBLE
96315: EQUAL
96316: IFTRUE 96320
96318: GO 96331
96320: POP
// bc_type := b_ext_radar ; 19 :
96321: LD_ADDR_OWVAR 42
96325: PUSH
96326: LD_INT 20
96328: ST_TO_ADDR
96329: GO 96636
96331: LD_INT 19
96333: DOUBLE
96334: EQUAL
96335: IFTRUE 96339
96337: GO 96350
96339: POP
// bc_type := b_ext_radio ; 20 :
96340: LD_ADDR_OWVAR 42
96344: PUSH
96345: LD_INT 22
96347: ST_TO_ADDR
96348: GO 96636
96350: LD_INT 20
96352: DOUBLE
96353: EQUAL
96354: IFTRUE 96358
96356: GO 96369
96358: POP
// bc_type := b_ext_siberium ; 21 :
96359: LD_ADDR_OWVAR 42
96363: PUSH
96364: LD_INT 21
96366: ST_TO_ADDR
96367: GO 96636
96369: LD_INT 21
96371: DOUBLE
96372: EQUAL
96373: IFTRUE 96377
96375: GO 96388
96377: POP
// bc_type := b_ext_computer ; 22 :
96378: LD_ADDR_OWVAR 42
96382: PUSH
96383: LD_INT 24
96385: ST_TO_ADDR
96386: GO 96636
96388: LD_INT 22
96390: DOUBLE
96391: EQUAL
96392: IFTRUE 96396
96394: GO 96407
96396: POP
// bc_type := b_ext_track ; 23 :
96397: LD_ADDR_OWVAR 42
96401: PUSH
96402: LD_INT 16
96404: ST_TO_ADDR
96405: GO 96636
96407: LD_INT 23
96409: DOUBLE
96410: EQUAL
96411: IFTRUE 96415
96413: GO 96426
96415: POP
// bc_type := b_ext_laser ; 24 :
96416: LD_ADDR_OWVAR 42
96420: PUSH
96421: LD_INT 25
96423: ST_TO_ADDR
96424: GO 96636
96426: LD_INT 24
96428: DOUBLE
96429: EQUAL
96430: IFTRUE 96434
96432: GO 96445
96434: POP
// bc_type := b_control_tower ; 25 :
96435: LD_ADDR_OWVAR 42
96439: PUSH
96440: LD_INT 36
96442: ST_TO_ADDR
96443: GO 96636
96445: LD_INT 25
96447: DOUBLE
96448: EQUAL
96449: IFTRUE 96453
96451: GO 96464
96453: POP
// bc_type := b_breastwork ; 26 :
96454: LD_ADDR_OWVAR 42
96458: PUSH
96459: LD_INT 31
96461: ST_TO_ADDR
96462: GO 96636
96464: LD_INT 26
96466: DOUBLE
96467: EQUAL
96468: IFTRUE 96472
96470: GO 96483
96472: POP
// bc_type := b_bunker ; 27 :
96473: LD_ADDR_OWVAR 42
96477: PUSH
96478: LD_INT 32
96480: ST_TO_ADDR
96481: GO 96636
96483: LD_INT 27
96485: DOUBLE
96486: EQUAL
96487: IFTRUE 96491
96489: GO 96502
96491: POP
// bc_type := b_turret ; 28 :
96492: LD_ADDR_OWVAR 42
96496: PUSH
96497: LD_INT 33
96499: ST_TO_ADDR
96500: GO 96636
96502: LD_INT 28
96504: DOUBLE
96505: EQUAL
96506: IFTRUE 96510
96508: GO 96521
96510: POP
// bc_type := b_armoury ; 29 :
96511: LD_ADDR_OWVAR 42
96515: PUSH
96516: LD_INT 4
96518: ST_TO_ADDR
96519: GO 96636
96521: LD_INT 29
96523: DOUBLE
96524: EQUAL
96525: IFTRUE 96529
96527: GO 96540
96529: POP
// bc_type := b_barracks ; 30 :
96530: LD_ADDR_OWVAR 42
96534: PUSH
96535: LD_INT 5
96537: ST_TO_ADDR
96538: GO 96636
96540: LD_INT 30
96542: DOUBLE
96543: EQUAL
96544: IFTRUE 96548
96546: GO 96559
96548: POP
// bc_type := b_solar_power ; 31 :
96549: LD_ADDR_OWVAR 42
96553: PUSH
96554: LD_INT 27
96556: ST_TO_ADDR
96557: GO 96636
96559: LD_INT 31
96561: DOUBLE
96562: EQUAL
96563: IFTRUE 96567
96565: GO 96578
96567: POP
// bc_type := b_oil_power ; 32 :
96568: LD_ADDR_OWVAR 42
96572: PUSH
96573: LD_INT 26
96575: ST_TO_ADDR
96576: GO 96636
96578: LD_INT 32
96580: DOUBLE
96581: EQUAL
96582: IFTRUE 96586
96584: GO 96597
96586: POP
// bc_type := b_siberite_power ; 33 :
96587: LD_ADDR_OWVAR 42
96591: PUSH
96592: LD_INT 28
96594: ST_TO_ADDR
96595: GO 96636
96597: LD_INT 33
96599: DOUBLE
96600: EQUAL
96601: IFTRUE 96605
96603: GO 96616
96605: POP
// bc_type := b_oil_mine ; 34 :
96606: LD_ADDR_OWVAR 42
96610: PUSH
96611: LD_INT 29
96613: ST_TO_ADDR
96614: GO 96636
96616: LD_INT 34
96618: DOUBLE
96619: EQUAL
96620: IFTRUE 96624
96622: GO 96635
96624: POP
// bc_type := b_siberite_mine ; end ;
96625: LD_ADDR_OWVAR 42
96629: PUSH
96630: LD_INT 30
96632: ST_TO_ADDR
96633: GO 96636
96635: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
96636: LD_ADDR_VAR 0 8
96640: PUSH
96641: LD_VAR 0 5
96645: PPUSH
96646: LD_VAR 0 6
96650: PPUSH
96651: LD_VAR 0 3
96655: PPUSH
96656: CALL_OW 47
96660: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
96661: LD_OWVAR 42
96665: PUSH
96666: LD_INT 32
96668: PUSH
96669: LD_INT 33
96671: PUSH
96672: EMPTY
96673: LIST
96674: LIST
96675: IN
96676: IFFALSE 96692
// PlaceWeaponTurret ( b , weapon ) ;
96678: LD_VAR 0 8
96682: PPUSH
96683: LD_VAR 0 4
96687: PPUSH
96688: CALL_OW 431
// end ;
96692: LD_VAR 0 7
96696: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
96697: LD_INT 0
96699: PPUSH
96700: PPUSH
96701: PPUSH
96702: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96703: LD_ADDR_VAR 0 4
96707: PUSH
96708: LD_INT 22
96710: PUSH
96711: LD_OWVAR 2
96715: PUSH
96716: EMPTY
96717: LIST
96718: LIST
96719: PUSH
96720: LD_INT 2
96722: PUSH
96723: LD_INT 30
96725: PUSH
96726: LD_INT 0
96728: PUSH
96729: EMPTY
96730: LIST
96731: LIST
96732: PUSH
96733: LD_INT 30
96735: PUSH
96736: LD_INT 1
96738: PUSH
96739: EMPTY
96740: LIST
96741: LIST
96742: PUSH
96743: EMPTY
96744: LIST
96745: LIST
96746: LIST
96747: PUSH
96748: EMPTY
96749: LIST
96750: LIST
96751: PPUSH
96752: CALL_OW 69
96756: ST_TO_ADDR
// if not tmp then
96757: LD_VAR 0 4
96761: NOT
96762: IFFALSE 96766
// exit ;
96764: GO 96825
// for i in tmp do
96766: LD_ADDR_VAR 0 2
96770: PUSH
96771: LD_VAR 0 4
96775: PUSH
96776: FOR_IN
96777: IFFALSE 96823
// for j = 1 to 3 do
96779: LD_ADDR_VAR 0 3
96783: PUSH
96784: DOUBLE
96785: LD_INT 1
96787: DEC
96788: ST_TO_ADDR
96789: LD_INT 3
96791: PUSH
96792: FOR_TO
96793: IFFALSE 96819
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
96795: LD_VAR 0 2
96799: PPUSH
96800: CALL_OW 274
96804: PPUSH
96805: LD_VAR 0 3
96809: PPUSH
96810: LD_INT 99999
96812: PPUSH
96813: CALL_OW 277
96817: GO 96792
96819: POP
96820: POP
96821: GO 96776
96823: POP
96824: POP
// end ;
96825: LD_VAR 0 1
96829: RET
// export function hHackSetLevel10 ; var i , j ; begin
96830: LD_INT 0
96832: PPUSH
96833: PPUSH
96834: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
96835: LD_ADDR_VAR 0 2
96839: PUSH
96840: LD_INT 21
96842: PUSH
96843: LD_INT 1
96845: PUSH
96846: EMPTY
96847: LIST
96848: LIST
96849: PPUSH
96850: CALL_OW 69
96854: PUSH
96855: FOR_IN
96856: IFFALSE 96908
// if IsSelected ( i ) then
96858: LD_VAR 0 2
96862: PPUSH
96863: CALL_OW 306
96867: IFFALSE 96906
// begin for j := 1 to 4 do
96869: LD_ADDR_VAR 0 3
96873: PUSH
96874: DOUBLE
96875: LD_INT 1
96877: DEC
96878: ST_TO_ADDR
96879: LD_INT 4
96881: PUSH
96882: FOR_TO
96883: IFFALSE 96904
// SetSkill ( i , j , 10 ) ;
96885: LD_VAR 0 2
96889: PPUSH
96890: LD_VAR 0 3
96894: PPUSH
96895: LD_INT 10
96897: PPUSH
96898: CALL_OW 237
96902: GO 96882
96904: POP
96905: POP
// end ;
96906: GO 96855
96908: POP
96909: POP
// end ;
96910: LD_VAR 0 1
96914: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
96915: LD_INT 0
96917: PPUSH
96918: PPUSH
96919: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
96920: LD_ADDR_VAR 0 2
96924: PUSH
96925: LD_INT 22
96927: PUSH
96928: LD_OWVAR 2
96932: PUSH
96933: EMPTY
96934: LIST
96935: LIST
96936: PUSH
96937: LD_INT 21
96939: PUSH
96940: LD_INT 1
96942: PUSH
96943: EMPTY
96944: LIST
96945: LIST
96946: PUSH
96947: EMPTY
96948: LIST
96949: LIST
96950: PPUSH
96951: CALL_OW 69
96955: PUSH
96956: FOR_IN
96957: IFFALSE 96998
// begin for j := 1 to 4 do
96959: LD_ADDR_VAR 0 3
96963: PUSH
96964: DOUBLE
96965: LD_INT 1
96967: DEC
96968: ST_TO_ADDR
96969: LD_INT 4
96971: PUSH
96972: FOR_TO
96973: IFFALSE 96994
// SetSkill ( i , j , 10 ) ;
96975: LD_VAR 0 2
96979: PPUSH
96980: LD_VAR 0 3
96984: PPUSH
96985: LD_INT 10
96987: PPUSH
96988: CALL_OW 237
96992: GO 96972
96994: POP
96995: POP
// end ;
96996: GO 96956
96998: POP
96999: POP
// end ;
97000: LD_VAR 0 1
97004: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
97005: LD_INT 0
97007: PPUSH
// uc_side := your_side ;
97008: LD_ADDR_OWVAR 20
97012: PUSH
97013: LD_OWVAR 2
97017: ST_TO_ADDR
// uc_nation := nation ;
97018: LD_ADDR_OWVAR 21
97022: PUSH
97023: LD_VAR 0 1
97027: ST_TO_ADDR
// InitHc ;
97028: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
97032: LD_INT 0
97034: PPUSH
97035: LD_VAR 0 2
97039: PPUSH
97040: LD_VAR 0 3
97044: PPUSH
97045: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
97049: LD_VAR 0 4
97053: PPUSH
97054: LD_VAR 0 5
97058: PPUSH
97059: CALL_OW 428
97063: PUSH
97064: LD_INT 0
97066: EQUAL
97067: IFFALSE 97091
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
97069: CALL_OW 44
97073: PPUSH
97074: LD_VAR 0 4
97078: PPUSH
97079: LD_VAR 0 5
97083: PPUSH
97084: LD_INT 1
97086: PPUSH
97087: CALL_OW 48
// end ;
97091: LD_VAR 0 6
97095: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
97096: LD_INT 0
97098: PPUSH
97099: PPUSH
// uc_side := your_side ;
97100: LD_ADDR_OWVAR 20
97104: PUSH
97105: LD_OWVAR 2
97109: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
97110: LD_VAR 0 1
97114: PUSH
97115: LD_INT 1
97117: PUSH
97118: LD_INT 2
97120: PUSH
97121: LD_INT 3
97123: PUSH
97124: LD_INT 4
97126: PUSH
97127: LD_INT 5
97129: PUSH
97130: EMPTY
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: IN
97137: IFFALSE 97149
// uc_nation := nation_american else
97139: LD_ADDR_OWVAR 21
97143: PUSH
97144: LD_INT 1
97146: ST_TO_ADDR
97147: GO 97192
// if chassis in [ 11 , 12 , 13 , 14 ] then
97149: LD_VAR 0 1
97153: PUSH
97154: LD_INT 11
97156: PUSH
97157: LD_INT 12
97159: PUSH
97160: LD_INT 13
97162: PUSH
97163: LD_INT 14
97165: PUSH
97166: EMPTY
97167: LIST
97168: LIST
97169: LIST
97170: LIST
97171: IN
97172: IFFALSE 97184
// uc_nation := nation_arabian else
97174: LD_ADDR_OWVAR 21
97178: PUSH
97179: LD_INT 2
97181: ST_TO_ADDR
97182: GO 97192
// uc_nation := nation_russian ;
97184: LD_ADDR_OWVAR 21
97188: PUSH
97189: LD_INT 3
97191: ST_TO_ADDR
// vc_chassis := chassis ;
97192: LD_ADDR_OWVAR 37
97196: PUSH
97197: LD_VAR 0 1
97201: ST_TO_ADDR
// vc_engine := engine ;
97202: LD_ADDR_OWVAR 39
97206: PUSH
97207: LD_VAR 0 2
97211: ST_TO_ADDR
// vc_control := control ;
97212: LD_ADDR_OWVAR 38
97216: PUSH
97217: LD_VAR 0 3
97221: ST_TO_ADDR
// vc_weapon := weapon ;
97222: LD_ADDR_OWVAR 40
97226: PUSH
97227: LD_VAR 0 4
97231: ST_TO_ADDR
// un := CreateVehicle ;
97232: LD_ADDR_VAR 0 8
97236: PUSH
97237: CALL_OW 45
97241: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
97242: LD_VAR 0 8
97246: PPUSH
97247: LD_INT 0
97249: PPUSH
97250: LD_INT 5
97252: PPUSH
97253: CALL_OW 12
97257: PPUSH
97258: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
97262: LD_VAR 0 8
97266: PPUSH
97267: LD_VAR 0 5
97271: PPUSH
97272: LD_VAR 0 6
97276: PPUSH
97277: LD_INT 1
97279: PPUSH
97280: CALL_OW 48
// end ;
97284: LD_VAR 0 7
97288: RET
// export hInvincible ; every 1 do
97289: GO 97291
97291: DISABLE
// hInvincible := [ ] ;
97292: LD_ADDR_EXP 170
97296: PUSH
97297: EMPTY
97298: ST_TO_ADDR
97299: END
// every 10 do var i ;
97300: GO 97302
97302: DISABLE
97303: LD_INT 0
97305: PPUSH
// begin enable ;
97306: ENABLE
// if not hInvincible then
97307: LD_EXP 170
97311: NOT
97312: IFFALSE 97316
// exit ;
97314: GO 97360
// for i in hInvincible do
97316: LD_ADDR_VAR 0 1
97320: PUSH
97321: LD_EXP 170
97325: PUSH
97326: FOR_IN
97327: IFFALSE 97358
// if GetLives ( i ) < 1000 then
97329: LD_VAR 0 1
97333: PPUSH
97334: CALL_OW 256
97338: PUSH
97339: LD_INT 1000
97341: LESS
97342: IFFALSE 97356
// SetLives ( i , 1000 ) ;
97344: LD_VAR 0 1
97348: PPUSH
97349: LD_INT 1000
97351: PPUSH
97352: CALL_OW 234
97356: GO 97326
97358: POP
97359: POP
// end ;
97360: PPOPN 1
97362: END
// export function hHackInvincible ; var i ; begin
97363: LD_INT 0
97365: PPUSH
97366: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
97367: LD_ADDR_VAR 0 2
97371: PUSH
97372: LD_INT 2
97374: PUSH
97375: LD_INT 21
97377: PUSH
97378: LD_INT 1
97380: PUSH
97381: EMPTY
97382: LIST
97383: LIST
97384: PUSH
97385: LD_INT 21
97387: PUSH
97388: LD_INT 2
97390: PUSH
97391: EMPTY
97392: LIST
97393: LIST
97394: PUSH
97395: EMPTY
97396: LIST
97397: LIST
97398: LIST
97399: PPUSH
97400: CALL_OW 69
97404: PUSH
97405: FOR_IN
97406: IFFALSE 97467
// if IsSelected ( i ) then
97408: LD_VAR 0 2
97412: PPUSH
97413: CALL_OW 306
97417: IFFALSE 97465
// begin if i in hInvincible then
97419: LD_VAR 0 2
97423: PUSH
97424: LD_EXP 170
97428: IN
97429: IFFALSE 97449
// hInvincible := hInvincible diff i else
97431: LD_ADDR_EXP 170
97435: PUSH
97436: LD_EXP 170
97440: PUSH
97441: LD_VAR 0 2
97445: DIFF
97446: ST_TO_ADDR
97447: GO 97465
// hInvincible := hInvincible union i ;
97449: LD_ADDR_EXP 170
97453: PUSH
97454: LD_EXP 170
97458: PUSH
97459: LD_VAR 0 2
97463: UNION
97464: ST_TO_ADDR
// end ;
97465: GO 97405
97467: POP
97468: POP
// end ;
97469: LD_VAR 0 1
97473: RET
// export function hHackInvisible ; var i , j ; begin
97474: LD_INT 0
97476: PPUSH
97477: PPUSH
97478: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
97479: LD_ADDR_VAR 0 2
97483: PUSH
97484: LD_INT 21
97486: PUSH
97487: LD_INT 1
97489: PUSH
97490: EMPTY
97491: LIST
97492: LIST
97493: PPUSH
97494: CALL_OW 69
97498: PUSH
97499: FOR_IN
97500: IFFALSE 97524
// if IsSelected ( i ) then
97502: LD_VAR 0 2
97506: PPUSH
97507: CALL_OW 306
97511: IFFALSE 97522
// ComForceInvisible ( i ) ;
97513: LD_VAR 0 2
97517: PPUSH
97518: CALL_OW 496
97522: GO 97499
97524: POP
97525: POP
// end ;
97526: LD_VAR 0 1
97530: RET
// export function hHackChangeYourSide ; begin
97531: LD_INT 0
97533: PPUSH
// if your_side = 8 then
97534: LD_OWVAR 2
97538: PUSH
97539: LD_INT 8
97541: EQUAL
97542: IFFALSE 97554
// your_side := 0 else
97544: LD_ADDR_OWVAR 2
97548: PUSH
97549: LD_INT 0
97551: ST_TO_ADDR
97552: GO 97568
// your_side := your_side + 1 ;
97554: LD_ADDR_OWVAR 2
97558: PUSH
97559: LD_OWVAR 2
97563: PUSH
97564: LD_INT 1
97566: PLUS
97567: ST_TO_ADDR
// end ;
97568: LD_VAR 0 1
97572: RET
// export function hHackChangeUnitSide ; var i , j ; begin
97573: LD_INT 0
97575: PPUSH
97576: PPUSH
97577: PPUSH
// for i in all_units do
97578: LD_ADDR_VAR 0 2
97582: PUSH
97583: LD_OWVAR 3
97587: PUSH
97588: FOR_IN
97589: IFFALSE 97667
// if IsSelected ( i ) then
97591: LD_VAR 0 2
97595: PPUSH
97596: CALL_OW 306
97600: IFFALSE 97665
// begin j := GetSide ( i ) ;
97602: LD_ADDR_VAR 0 3
97606: PUSH
97607: LD_VAR 0 2
97611: PPUSH
97612: CALL_OW 255
97616: ST_TO_ADDR
// if j = 8 then
97617: LD_VAR 0 3
97621: PUSH
97622: LD_INT 8
97624: EQUAL
97625: IFFALSE 97637
// j := 0 else
97627: LD_ADDR_VAR 0 3
97631: PUSH
97632: LD_INT 0
97634: ST_TO_ADDR
97635: GO 97651
// j := j + 1 ;
97637: LD_ADDR_VAR 0 3
97641: PUSH
97642: LD_VAR 0 3
97646: PUSH
97647: LD_INT 1
97649: PLUS
97650: ST_TO_ADDR
// SetSide ( i , j ) ;
97651: LD_VAR 0 2
97655: PPUSH
97656: LD_VAR 0 3
97660: PPUSH
97661: CALL_OW 235
// end ;
97665: GO 97588
97667: POP
97668: POP
// end ;
97669: LD_VAR 0 1
97673: RET
// export function hHackFog ; begin
97674: LD_INT 0
97676: PPUSH
// FogOff ( true ) ;
97677: LD_INT 1
97679: PPUSH
97680: CALL_OW 344
// end ;
97684: LD_VAR 0 1
97688: RET
// export function hHackTeleport ( unit , x , y ) ; begin
97689: LD_INT 0
97691: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
97692: LD_VAR 0 1
97696: PPUSH
97697: LD_VAR 0 2
97701: PPUSH
97702: LD_VAR 0 3
97706: PPUSH
97707: LD_INT 1
97709: PPUSH
97710: LD_INT 1
97712: PPUSH
97713: CALL_OW 483
// CenterOnXY ( x , y ) ;
97717: LD_VAR 0 2
97721: PPUSH
97722: LD_VAR 0 3
97726: PPUSH
97727: CALL_OW 84
// end ; end_of_file
97731: LD_VAR 0 4
97735: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
97736: LD_INT 0
97738: PPUSH
97739: PPUSH
97740: PPUSH
97741: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
97742: LD_VAR 0 1
97746: PPUSH
97747: CALL_OW 264
97751: PUSH
97752: LD_EXP 52
97756: EQUAL
97757: IFFALSE 97829
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
97759: LD_INT 68
97761: PPUSH
97762: LD_VAR 0 1
97766: PPUSH
97767: CALL_OW 255
97771: PPUSH
97772: CALL_OW 321
97776: PUSH
97777: LD_INT 2
97779: EQUAL
97780: IFFALSE 97792
// eff := 70 else
97782: LD_ADDR_VAR 0 4
97786: PUSH
97787: LD_INT 70
97789: ST_TO_ADDR
97790: GO 97800
// eff := 30 ;
97792: LD_ADDR_VAR 0 4
97796: PUSH
97797: LD_INT 30
97799: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
97800: LD_VAR 0 1
97804: PPUSH
97805: CALL_OW 250
97809: PPUSH
97810: LD_VAR 0 1
97814: PPUSH
97815: CALL_OW 251
97819: PPUSH
97820: LD_VAR 0 4
97824: PPUSH
97825: CALL_OW 495
// end ; end ;
97829: LD_VAR 0 2
97833: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
97834: LD_INT 0
97836: PPUSH
// end ;
97837: LD_VAR 0 4
97841: RET
// export function SOS_Command ( cmd ) ; begin
97842: LD_INT 0
97844: PPUSH
// end ;
97845: LD_VAR 0 2
97849: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
97850: LD_INT 0
97852: PPUSH
// end ;
97853: LD_VAR 0 6
97857: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
97858: LD_INT 0
97860: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
97861: LD_VAR 0 1
97865: PUSH
97866: LD_INT 250
97868: EQUAL
97869: PUSH
97870: LD_VAR 0 2
97874: PPUSH
97875: CALL_OW 264
97879: PUSH
97880: LD_EXP 55
97884: EQUAL
97885: AND
97886: IFFALSE 97907
// MinerPlaceMine ( unit , x , y ) ;
97888: LD_VAR 0 2
97892: PPUSH
97893: LD_VAR 0 4
97897: PPUSH
97898: LD_VAR 0 5
97902: PPUSH
97903: CALL 100256 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
97907: LD_VAR 0 1
97911: PUSH
97912: LD_INT 251
97914: EQUAL
97915: PUSH
97916: LD_VAR 0 2
97920: PPUSH
97921: CALL_OW 264
97925: PUSH
97926: LD_EXP 55
97930: EQUAL
97931: AND
97932: IFFALSE 97953
// MinerDetonateMine ( unit , x , y ) ;
97934: LD_VAR 0 2
97938: PPUSH
97939: LD_VAR 0 4
97943: PPUSH
97944: LD_VAR 0 5
97948: PPUSH
97949: CALL 100533 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
97953: LD_VAR 0 1
97957: PUSH
97958: LD_INT 252
97960: EQUAL
97961: PUSH
97962: LD_VAR 0 2
97966: PPUSH
97967: CALL_OW 264
97971: PUSH
97972: LD_EXP 55
97976: EQUAL
97977: AND
97978: IFFALSE 97999
// MinerCreateMinefield ( unit , x , y ) ;
97980: LD_VAR 0 2
97984: PPUSH
97985: LD_VAR 0 4
97989: PPUSH
97990: LD_VAR 0 5
97994: PPUSH
97995: CALL 100950 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
97999: LD_VAR 0 1
98003: PUSH
98004: LD_INT 253
98006: EQUAL
98007: PUSH
98008: LD_VAR 0 2
98012: PPUSH
98013: CALL_OW 257
98017: PUSH
98018: LD_INT 5
98020: EQUAL
98021: AND
98022: IFFALSE 98043
// ComBinocular ( unit , x , y ) ;
98024: LD_VAR 0 2
98028: PPUSH
98029: LD_VAR 0 4
98033: PPUSH
98034: LD_VAR 0 5
98038: PPUSH
98039: CALL 101321 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
98043: LD_VAR 0 1
98047: PUSH
98048: LD_INT 254
98050: EQUAL
98051: PUSH
98052: LD_VAR 0 2
98056: PPUSH
98057: CALL_OW 264
98061: PUSH
98062: LD_EXP 50
98066: EQUAL
98067: AND
98068: PUSH
98069: LD_VAR 0 3
98073: PPUSH
98074: CALL_OW 263
98078: PUSH
98079: LD_INT 3
98081: EQUAL
98082: AND
98083: IFFALSE 98099
// HackDestroyVehicle ( unit , selectedUnit ) ;
98085: LD_VAR 0 2
98089: PPUSH
98090: LD_VAR 0 3
98094: PPUSH
98095: CALL 99616 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
98099: LD_VAR 0 1
98103: PUSH
98104: LD_INT 255
98106: EQUAL
98107: PUSH
98108: LD_VAR 0 2
98112: PPUSH
98113: CALL_OW 264
98117: PUSH
98118: LD_INT 14
98120: PUSH
98121: LD_INT 53
98123: PUSH
98124: EMPTY
98125: LIST
98126: LIST
98127: IN
98128: AND
98129: PUSH
98130: LD_VAR 0 4
98134: PPUSH
98135: LD_VAR 0 5
98139: PPUSH
98140: CALL_OW 488
98144: AND
98145: IFFALSE 98169
// CutTreeXYR ( unit , x , y , 12 ) ;
98147: LD_VAR 0 2
98151: PPUSH
98152: LD_VAR 0 4
98156: PPUSH
98157: LD_VAR 0 5
98161: PPUSH
98162: LD_INT 12
98164: PPUSH
98165: CALL 98182 0 4
// end ;
98169: LD_VAR 0 6
98173: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
98174: LD_INT 0
98176: PPUSH
// end ;
98177: LD_VAR 0 4
98181: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
98182: LD_INT 0
98184: PPUSH
98185: PPUSH
98186: PPUSH
98187: PPUSH
98188: PPUSH
98189: PPUSH
98190: PPUSH
98191: PPUSH
98192: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
98193: LD_VAR 0 1
98197: NOT
98198: PUSH
98199: LD_VAR 0 2
98203: PPUSH
98204: LD_VAR 0 3
98208: PPUSH
98209: CALL_OW 488
98213: NOT
98214: OR
98215: PUSH
98216: LD_VAR 0 4
98220: NOT
98221: OR
98222: IFFALSE 98226
// exit ;
98224: GO 98566
// list := [ ] ;
98226: LD_ADDR_VAR 0 13
98230: PUSH
98231: EMPTY
98232: ST_TO_ADDR
// if x - r < 0 then
98233: LD_VAR 0 2
98237: PUSH
98238: LD_VAR 0 4
98242: MINUS
98243: PUSH
98244: LD_INT 0
98246: LESS
98247: IFFALSE 98259
// min_x := 0 else
98249: LD_ADDR_VAR 0 7
98253: PUSH
98254: LD_INT 0
98256: ST_TO_ADDR
98257: GO 98275
// min_x := x - r ;
98259: LD_ADDR_VAR 0 7
98263: PUSH
98264: LD_VAR 0 2
98268: PUSH
98269: LD_VAR 0 4
98273: MINUS
98274: ST_TO_ADDR
// if y - r < 0 then
98275: LD_VAR 0 3
98279: PUSH
98280: LD_VAR 0 4
98284: MINUS
98285: PUSH
98286: LD_INT 0
98288: LESS
98289: IFFALSE 98301
// min_y := 0 else
98291: LD_ADDR_VAR 0 8
98295: PUSH
98296: LD_INT 0
98298: ST_TO_ADDR
98299: GO 98317
// min_y := y - r ;
98301: LD_ADDR_VAR 0 8
98305: PUSH
98306: LD_VAR 0 3
98310: PUSH
98311: LD_VAR 0 4
98315: MINUS
98316: ST_TO_ADDR
// max_x := x + r ;
98317: LD_ADDR_VAR 0 9
98321: PUSH
98322: LD_VAR 0 2
98326: PUSH
98327: LD_VAR 0 4
98331: PLUS
98332: ST_TO_ADDR
// max_y := y + r ;
98333: LD_ADDR_VAR 0 10
98337: PUSH
98338: LD_VAR 0 3
98342: PUSH
98343: LD_VAR 0 4
98347: PLUS
98348: ST_TO_ADDR
// for _x = min_x to max_x do
98349: LD_ADDR_VAR 0 11
98353: PUSH
98354: DOUBLE
98355: LD_VAR 0 7
98359: DEC
98360: ST_TO_ADDR
98361: LD_VAR 0 9
98365: PUSH
98366: FOR_TO
98367: IFFALSE 98484
// for _y = min_y to max_y do
98369: LD_ADDR_VAR 0 12
98373: PUSH
98374: DOUBLE
98375: LD_VAR 0 8
98379: DEC
98380: ST_TO_ADDR
98381: LD_VAR 0 10
98385: PUSH
98386: FOR_TO
98387: IFFALSE 98480
// begin if not ValidHex ( _x , _y ) then
98389: LD_VAR 0 11
98393: PPUSH
98394: LD_VAR 0 12
98398: PPUSH
98399: CALL_OW 488
98403: NOT
98404: IFFALSE 98408
// continue ;
98406: GO 98386
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
98408: LD_VAR 0 11
98412: PPUSH
98413: LD_VAR 0 12
98417: PPUSH
98418: CALL_OW 351
98422: PUSH
98423: LD_VAR 0 11
98427: PPUSH
98428: LD_VAR 0 12
98432: PPUSH
98433: CALL_OW 554
98437: AND
98438: IFFALSE 98478
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
98440: LD_ADDR_VAR 0 13
98444: PUSH
98445: LD_VAR 0 13
98449: PPUSH
98450: LD_VAR 0 13
98454: PUSH
98455: LD_INT 1
98457: PLUS
98458: PPUSH
98459: LD_VAR 0 11
98463: PUSH
98464: LD_VAR 0 12
98468: PUSH
98469: EMPTY
98470: LIST
98471: LIST
98472: PPUSH
98473: CALL_OW 2
98477: ST_TO_ADDR
// end ;
98478: GO 98386
98480: POP
98481: POP
98482: GO 98366
98484: POP
98485: POP
// if not list then
98486: LD_VAR 0 13
98490: NOT
98491: IFFALSE 98495
// exit ;
98493: GO 98566
// for i in list do
98495: LD_ADDR_VAR 0 6
98499: PUSH
98500: LD_VAR 0 13
98504: PUSH
98505: FOR_IN
98506: IFFALSE 98564
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
98508: LD_VAR 0 1
98512: PPUSH
98513: LD_STRING M
98515: PUSH
98516: LD_VAR 0 6
98520: PUSH
98521: LD_INT 1
98523: ARRAY
98524: PUSH
98525: LD_VAR 0 6
98529: PUSH
98530: LD_INT 2
98532: ARRAY
98533: PUSH
98534: LD_INT 0
98536: PUSH
98537: LD_INT 0
98539: PUSH
98540: LD_INT 0
98542: PUSH
98543: LD_INT 0
98545: PUSH
98546: EMPTY
98547: LIST
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: LIST
98553: LIST
98554: PUSH
98555: EMPTY
98556: LIST
98557: PPUSH
98558: CALL_OW 447
98562: GO 98505
98564: POP
98565: POP
// end ;
98566: LD_VAR 0 5
98570: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
98571: LD_EXP 173
98575: NOT
98576: IFFALSE 98626
98578: GO 98580
98580: DISABLE
// begin initHack := true ;
98581: LD_ADDR_EXP 173
98585: PUSH
98586: LD_INT 1
98588: ST_TO_ADDR
// hackTanks := [ ] ;
98589: LD_ADDR_EXP 174
98593: PUSH
98594: EMPTY
98595: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
98596: LD_ADDR_EXP 175
98600: PUSH
98601: EMPTY
98602: ST_TO_ADDR
// hackLimit := 3 ;
98603: LD_ADDR_EXP 176
98607: PUSH
98608: LD_INT 3
98610: ST_TO_ADDR
// hackDist := 12 ;
98611: LD_ADDR_EXP 177
98615: PUSH
98616: LD_INT 12
98618: ST_TO_ADDR
// hackCounter := [ ] ;
98619: LD_ADDR_EXP 178
98623: PUSH
98624: EMPTY
98625: ST_TO_ADDR
// end ;
98626: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
98627: LD_EXP 173
98631: PUSH
98632: LD_INT 34
98634: PUSH
98635: LD_EXP 50
98639: PUSH
98640: EMPTY
98641: LIST
98642: LIST
98643: PPUSH
98644: CALL_OW 69
98648: AND
98649: IFFALSE 98904
98651: GO 98653
98653: DISABLE
98654: LD_INT 0
98656: PPUSH
98657: PPUSH
// begin enable ;
98658: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
98659: LD_ADDR_VAR 0 1
98663: PUSH
98664: LD_INT 34
98666: PUSH
98667: LD_EXP 50
98671: PUSH
98672: EMPTY
98673: LIST
98674: LIST
98675: PPUSH
98676: CALL_OW 69
98680: PUSH
98681: FOR_IN
98682: IFFALSE 98902
// begin if not i in hackTanks then
98684: LD_VAR 0 1
98688: PUSH
98689: LD_EXP 174
98693: IN
98694: NOT
98695: IFFALSE 98778
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
98697: LD_ADDR_EXP 174
98701: PUSH
98702: LD_EXP 174
98706: PPUSH
98707: LD_EXP 174
98711: PUSH
98712: LD_INT 1
98714: PLUS
98715: PPUSH
98716: LD_VAR 0 1
98720: PPUSH
98721: CALL_OW 1
98725: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
98726: LD_ADDR_EXP 175
98730: PUSH
98731: LD_EXP 175
98735: PPUSH
98736: LD_EXP 175
98740: PUSH
98741: LD_INT 1
98743: PLUS
98744: PPUSH
98745: EMPTY
98746: PPUSH
98747: CALL_OW 1
98751: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
98752: LD_ADDR_EXP 178
98756: PUSH
98757: LD_EXP 178
98761: PPUSH
98762: LD_EXP 178
98766: PUSH
98767: LD_INT 1
98769: PLUS
98770: PPUSH
98771: EMPTY
98772: PPUSH
98773: CALL_OW 1
98777: ST_TO_ADDR
// end ; if not IsOk ( i ) then
98778: LD_VAR 0 1
98782: PPUSH
98783: CALL_OW 302
98787: NOT
98788: IFFALSE 98801
// begin HackUnlinkAll ( i ) ;
98790: LD_VAR 0 1
98794: PPUSH
98795: CALL 98907 0 1
// continue ;
98799: GO 98681
// end ; HackCheckCapturedStatus ( i ) ;
98801: LD_VAR 0 1
98805: PPUSH
98806: CALL 99350 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
98810: LD_ADDR_VAR 0 2
98814: PUSH
98815: LD_INT 81
98817: PUSH
98818: LD_VAR 0 1
98822: PPUSH
98823: CALL_OW 255
98827: PUSH
98828: EMPTY
98829: LIST
98830: LIST
98831: PUSH
98832: LD_INT 33
98834: PUSH
98835: LD_INT 3
98837: PUSH
98838: EMPTY
98839: LIST
98840: LIST
98841: PUSH
98842: LD_INT 91
98844: PUSH
98845: LD_VAR 0 1
98849: PUSH
98850: LD_EXP 177
98854: PUSH
98855: EMPTY
98856: LIST
98857: LIST
98858: LIST
98859: PUSH
98860: LD_INT 50
98862: PUSH
98863: EMPTY
98864: LIST
98865: PUSH
98866: EMPTY
98867: LIST
98868: LIST
98869: LIST
98870: LIST
98871: PPUSH
98872: CALL_OW 69
98876: ST_TO_ADDR
// if not tmp then
98877: LD_VAR 0 2
98881: NOT
98882: IFFALSE 98886
// continue ;
98884: GO 98681
// HackLink ( i , tmp ) ;
98886: LD_VAR 0 1
98890: PPUSH
98891: LD_VAR 0 2
98895: PPUSH
98896: CALL 99043 0 2
// end ;
98900: GO 98681
98902: POP
98903: POP
// end ;
98904: PPOPN 2
98906: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
98907: LD_INT 0
98909: PPUSH
98910: PPUSH
98911: PPUSH
// if not hack in hackTanks then
98912: LD_VAR 0 1
98916: PUSH
98917: LD_EXP 174
98921: IN
98922: NOT
98923: IFFALSE 98927
// exit ;
98925: GO 99038
// index := GetElementIndex ( hackTanks , hack ) ;
98927: LD_ADDR_VAR 0 4
98931: PUSH
98932: LD_EXP 174
98936: PPUSH
98937: LD_VAR 0 1
98941: PPUSH
98942: CALL 18373 0 2
98946: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
98947: LD_EXP 175
98951: PUSH
98952: LD_VAR 0 4
98956: ARRAY
98957: IFFALSE 99038
// begin for i in hackTanksCaptured [ index ] do
98959: LD_ADDR_VAR 0 3
98963: PUSH
98964: LD_EXP 175
98968: PUSH
98969: LD_VAR 0 4
98973: ARRAY
98974: PUSH
98975: FOR_IN
98976: IFFALSE 99002
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
98978: LD_VAR 0 3
98982: PUSH
98983: LD_INT 1
98985: ARRAY
98986: PPUSH
98987: LD_VAR 0 3
98991: PUSH
98992: LD_INT 2
98994: ARRAY
98995: PPUSH
98996: CALL_OW 235
99000: GO 98975
99002: POP
99003: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
99004: LD_ADDR_EXP 175
99008: PUSH
99009: LD_EXP 175
99013: PPUSH
99014: LD_VAR 0 4
99018: PPUSH
99019: EMPTY
99020: PPUSH
99021: CALL_OW 1
99025: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
99026: LD_VAR 0 1
99030: PPUSH
99031: LD_INT 0
99033: PPUSH
99034: CALL_OW 505
// end ; end ;
99038: LD_VAR 0 2
99042: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
99043: LD_INT 0
99045: PPUSH
99046: PPUSH
99047: PPUSH
// if not hack in hackTanks or not vehicles then
99048: LD_VAR 0 1
99052: PUSH
99053: LD_EXP 174
99057: IN
99058: NOT
99059: PUSH
99060: LD_VAR 0 2
99064: NOT
99065: OR
99066: IFFALSE 99070
// exit ;
99068: GO 99345
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
99070: LD_ADDR_VAR 0 2
99074: PUSH
99075: LD_VAR 0 1
99079: PPUSH
99080: LD_VAR 0 2
99084: PPUSH
99085: LD_INT 1
99087: PPUSH
99088: LD_INT 1
99090: PPUSH
99091: CALL 19023 0 4
99095: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
99096: LD_ADDR_VAR 0 5
99100: PUSH
99101: LD_EXP 174
99105: PPUSH
99106: LD_VAR 0 1
99110: PPUSH
99111: CALL 18373 0 2
99115: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
99116: LD_EXP 175
99120: PUSH
99121: LD_VAR 0 5
99125: ARRAY
99126: PUSH
99127: LD_EXP 176
99131: LESS
99132: IFFALSE 99321
// begin for i := 1 to vehicles do
99134: LD_ADDR_VAR 0 4
99138: PUSH
99139: DOUBLE
99140: LD_INT 1
99142: DEC
99143: ST_TO_ADDR
99144: LD_VAR 0 2
99148: PUSH
99149: FOR_TO
99150: IFFALSE 99319
// begin if hackTanksCaptured [ index ] = hackLimit then
99152: LD_EXP 175
99156: PUSH
99157: LD_VAR 0 5
99161: ARRAY
99162: PUSH
99163: LD_EXP 176
99167: EQUAL
99168: IFFALSE 99172
// break ;
99170: GO 99319
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
99172: LD_ADDR_EXP 178
99176: PUSH
99177: LD_EXP 178
99181: PPUSH
99182: LD_VAR 0 5
99186: PPUSH
99187: LD_EXP 178
99191: PUSH
99192: LD_VAR 0 5
99196: ARRAY
99197: PUSH
99198: LD_INT 1
99200: PLUS
99201: PPUSH
99202: CALL_OW 1
99206: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
99207: LD_ADDR_EXP 175
99211: PUSH
99212: LD_EXP 175
99216: PPUSH
99217: LD_VAR 0 5
99221: PUSH
99222: LD_EXP 175
99226: PUSH
99227: LD_VAR 0 5
99231: ARRAY
99232: PUSH
99233: LD_INT 1
99235: PLUS
99236: PUSH
99237: EMPTY
99238: LIST
99239: LIST
99240: PPUSH
99241: LD_VAR 0 2
99245: PUSH
99246: LD_VAR 0 4
99250: ARRAY
99251: PUSH
99252: LD_VAR 0 2
99256: PUSH
99257: LD_VAR 0 4
99261: ARRAY
99262: PPUSH
99263: CALL_OW 255
99267: PUSH
99268: EMPTY
99269: LIST
99270: LIST
99271: PPUSH
99272: CALL 18588 0 3
99276: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
99277: LD_VAR 0 2
99281: PUSH
99282: LD_VAR 0 4
99286: ARRAY
99287: PPUSH
99288: LD_VAR 0 1
99292: PPUSH
99293: CALL_OW 255
99297: PPUSH
99298: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
99302: LD_VAR 0 2
99306: PUSH
99307: LD_VAR 0 4
99311: ARRAY
99312: PPUSH
99313: CALL_OW 141
// end ;
99317: GO 99149
99319: POP
99320: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
99321: LD_VAR 0 1
99325: PPUSH
99326: LD_EXP 175
99330: PUSH
99331: LD_VAR 0 5
99335: ARRAY
99336: PUSH
99337: LD_INT 0
99339: PLUS
99340: PPUSH
99341: CALL_OW 505
// end ;
99345: LD_VAR 0 3
99349: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
99350: LD_INT 0
99352: PPUSH
99353: PPUSH
99354: PPUSH
99355: PPUSH
// if not hack in hackTanks then
99356: LD_VAR 0 1
99360: PUSH
99361: LD_EXP 174
99365: IN
99366: NOT
99367: IFFALSE 99371
// exit ;
99369: GO 99611
// index := GetElementIndex ( hackTanks , hack ) ;
99371: LD_ADDR_VAR 0 4
99375: PUSH
99376: LD_EXP 174
99380: PPUSH
99381: LD_VAR 0 1
99385: PPUSH
99386: CALL 18373 0 2
99390: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
99391: LD_ADDR_VAR 0 3
99395: PUSH
99396: DOUBLE
99397: LD_EXP 175
99401: PUSH
99402: LD_VAR 0 4
99406: ARRAY
99407: INC
99408: ST_TO_ADDR
99409: LD_INT 1
99411: PUSH
99412: FOR_DOWNTO
99413: IFFALSE 99585
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
99415: LD_ADDR_VAR 0 5
99419: PUSH
99420: LD_EXP 175
99424: PUSH
99425: LD_VAR 0 4
99429: ARRAY
99430: PUSH
99431: LD_VAR 0 3
99435: ARRAY
99436: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
99437: LD_VAR 0 5
99441: PUSH
99442: LD_INT 1
99444: ARRAY
99445: PPUSH
99446: CALL_OW 302
99450: NOT
99451: PUSH
99452: LD_VAR 0 5
99456: PUSH
99457: LD_INT 1
99459: ARRAY
99460: PPUSH
99461: CALL_OW 255
99465: PUSH
99466: LD_VAR 0 1
99470: PPUSH
99471: CALL_OW 255
99475: NONEQUAL
99476: OR
99477: IFFALSE 99583
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
99479: LD_VAR 0 5
99483: PUSH
99484: LD_INT 1
99486: ARRAY
99487: PPUSH
99488: CALL_OW 305
99492: PUSH
99493: LD_VAR 0 5
99497: PUSH
99498: LD_INT 1
99500: ARRAY
99501: PPUSH
99502: CALL_OW 255
99506: PUSH
99507: LD_VAR 0 1
99511: PPUSH
99512: CALL_OW 255
99516: EQUAL
99517: AND
99518: IFFALSE 99542
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
99520: LD_VAR 0 5
99524: PUSH
99525: LD_INT 1
99527: ARRAY
99528: PPUSH
99529: LD_VAR 0 5
99533: PUSH
99534: LD_INT 2
99536: ARRAY
99537: PPUSH
99538: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
99542: LD_ADDR_EXP 175
99546: PUSH
99547: LD_EXP 175
99551: PPUSH
99552: LD_VAR 0 4
99556: PPUSH
99557: LD_EXP 175
99561: PUSH
99562: LD_VAR 0 4
99566: ARRAY
99567: PPUSH
99568: LD_VAR 0 3
99572: PPUSH
99573: CALL_OW 3
99577: PPUSH
99578: CALL_OW 1
99582: ST_TO_ADDR
// end ; end ;
99583: GO 99412
99585: POP
99586: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
99587: LD_VAR 0 1
99591: PPUSH
99592: LD_EXP 175
99596: PUSH
99597: LD_VAR 0 4
99601: ARRAY
99602: PUSH
99603: LD_INT 0
99605: PLUS
99606: PPUSH
99607: CALL_OW 505
// end ;
99611: LD_VAR 0 2
99615: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
99616: LD_INT 0
99618: PPUSH
99619: PPUSH
99620: PPUSH
99621: PPUSH
// if not hack in hackTanks then
99622: LD_VAR 0 1
99626: PUSH
99627: LD_EXP 174
99631: IN
99632: NOT
99633: IFFALSE 99637
// exit ;
99635: GO 99722
// index := GetElementIndex ( hackTanks , hack ) ;
99637: LD_ADDR_VAR 0 5
99641: PUSH
99642: LD_EXP 174
99646: PPUSH
99647: LD_VAR 0 1
99651: PPUSH
99652: CALL 18373 0 2
99656: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
99657: LD_ADDR_VAR 0 4
99661: PUSH
99662: DOUBLE
99663: LD_INT 1
99665: DEC
99666: ST_TO_ADDR
99667: LD_EXP 175
99671: PUSH
99672: LD_VAR 0 5
99676: ARRAY
99677: PUSH
99678: FOR_TO
99679: IFFALSE 99720
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
99681: LD_EXP 175
99685: PUSH
99686: LD_VAR 0 5
99690: ARRAY
99691: PUSH
99692: LD_VAR 0 4
99696: ARRAY
99697: PUSH
99698: LD_INT 1
99700: ARRAY
99701: PUSH
99702: LD_VAR 0 2
99706: EQUAL
99707: IFFALSE 99718
// KillUnit ( vehicle ) ;
99709: LD_VAR 0 2
99713: PPUSH
99714: CALL_OW 66
99718: GO 99678
99720: POP
99721: POP
// end ;
99722: LD_VAR 0 3
99726: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
99727: LD_EXP 179
99731: NOT
99732: IFFALSE 99767
99734: GO 99736
99736: DISABLE
// begin initMiner := true ;
99737: LD_ADDR_EXP 179
99741: PUSH
99742: LD_INT 1
99744: ST_TO_ADDR
// minersList := [ ] ;
99745: LD_ADDR_EXP 180
99749: PUSH
99750: EMPTY
99751: ST_TO_ADDR
// minerMinesList := [ ] ;
99752: LD_ADDR_EXP 181
99756: PUSH
99757: EMPTY
99758: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
99759: LD_ADDR_EXP 182
99763: PUSH
99764: LD_INT 5
99766: ST_TO_ADDR
// end ;
99767: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
99768: LD_EXP 179
99772: PUSH
99773: LD_INT 34
99775: PUSH
99776: LD_EXP 55
99780: PUSH
99781: EMPTY
99782: LIST
99783: LIST
99784: PPUSH
99785: CALL_OW 69
99789: AND
99790: IFFALSE 100253
99792: GO 99794
99794: DISABLE
99795: LD_INT 0
99797: PPUSH
99798: PPUSH
99799: PPUSH
99800: PPUSH
// begin enable ;
99801: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
99802: LD_ADDR_VAR 0 1
99806: PUSH
99807: LD_INT 34
99809: PUSH
99810: LD_EXP 55
99814: PUSH
99815: EMPTY
99816: LIST
99817: LIST
99818: PPUSH
99819: CALL_OW 69
99823: PUSH
99824: FOR_IN
99825: IFFALSE 99897
// begin if not i in minersList then
99827: LD_VAR 0 1
99831: PUSH
99832: LD_EXP 180
99836: IN
99837: NOT
99838: IFFALSE 99895
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
99840: LD_ADDR_EXP 180
99844: PUSH
99845: LD_EXP 180
99849: PPUSH
99850: LD_EXP 180
99854: PUSH
99855: LD_INT 1
99857: PLUS
99858: PPUSH
99859: LD_VAR 0 1
99863: PPUSH
99864: CALL_OW 1
99868: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
99869: LD_ADDR_EXP 181
99873: PUSH
99874: LD_EXP 181
99878: PPUSH
99879: LD_EXP 181
99883: PUSH
99884: LD_INT 1
99886: PLUS
99887: PPUSH
99888: EMPTY
99889: PPUSH
99890: CALL_OW 1
99894: ST_TO_ADDR
// end end ;
99895: GO 99824
99897: POP
99898: POP
// for i := minerMinesList downto 1 do
99899: LD_ADDR_VAR 0 1
99903: PUSH
99904: DOUBLE
99905: LD_EXP 181
99909: INC
99910: ST_TO_ADDR
99911: LD_INT 1
99913: PUSH
99914: FOR_DOWNTO
99915: IFFALSE 100251
// begin if IsLive ( minersList [ i ] ) then
99917: LD_EXP 180
99921: PUSH
99922: LD_VAR 0 1
99926: ARRAY
99927: PPUSH
99928: CALL_OW 300
99932: IFFALSE 99960
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
99934: LD_EXP 180
99938: PUSH
99939: LD_VAR 0 1
99943: ARRAY
99944: PPUSH
99945: LD_EXP 181
99949: PUSH
99950: LD_VAR 0 1
99954: ARRAY
99955: PPUSH
99956: CALL_OW 505
// if not minerMinesList [ i ] then
99960: LD_EXP 181
99964: PUSH
99965: LD_VAR 0 1
99969: ARRAY
99970: NOT
99971: IFFALSE 99975
// continue ;
99973: GO 99914
// for j := minerMinesList [ i ] downto 1 do
99975: LD_ADDR_VAR 0 2
99979: PUSH
99980: DOUBLE
99981: LD_EXP 181
99985: PUSH
99986: LD_VAR 0 1
99990: ARRAY
99991: INC
99992: ST_TO_ADDR
99993: LD_INT 1
99995: PUSH
99996: FOR_DOWNTO
99997: IFFALSE 100247
// begin side := GetSide ( minersList [ i ] ) ;
99999: LD_ADDR_VAR 0 3
100003: PUSH
100004: LD_EXP 180
100008: PUSH
100009: LD_VAR 0 1
100013: ARRAY
100014: PPUSH
100015: CALL_OW 255
100019: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
100020: LD_ADDR_VAR 0 4
100024: PUSH
100025: LD_EXP 181
100029: PUSH
100030: LD_VAR 0 1
100034: ARRAY
100035: PUSH
100036: LD_VAR 0 2
100040: ARRAY
100041: PUSH
100042: LD_INT 1
100044: ARRAY
100045: PPUSH
100046: LD_EXP 181
100050: PUSH
100051: LD_VAR 0 1
100055: ARRAY
100056: PUSH
100057: LD_VAR 0 2
100061: ARRAY
100062: PUSH
100063: LD_INT 2
100065: ARRAY
100066: PPUSH
100067: CALL_OW 428
100071: ST_TO_ADDR
// if not tmp then
100072: LD_VAR 0 4
100076: NOT
100077: IFFALSE 100081
// continue ;
100079: GO 99996
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
100081: LD_VAR 0 4
100085: PUSH
100086: LD_INT 81
100088: PUSH
100089: LD_VAR 0 3
100093: PUSH
100094: EMPTY
100095: LIST
100096: LIST
100097: PPUSH
100098: CALL_OW 69
100102: IN
100103: PUSH
100104: LD_EXP 181
100108: PUSH
100109: LD_VAR 0 1
100113: ARRAY
100114: PUSH
100115: LD_VAR 0 2
100119: ARRAY
100120: PUSH
100121: LD_INT 1
100123: ARRAY
100124: PPUSH
100125: LD_EXP 181
100129: PUSH
100130: LD_VAR 0 1
100134: ARRAY
100135: PUSH
100136: LD_VAR 0 2
100140: ARRAY
100141: PUSH
100142: LD_INT 2
100144: ARRAY
100145: PPUSH
100146: CALL_OW 458
100150: AND
100151: IFFALSE 100245
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
100153: LD_EXP 181
100157: PUSH
100158: LD_VAR 0 1
100162: ARRAY
100163: PUSH
100164: LD_VAR 0 2
100168: ARRAY
100169: PUSH
100170: LD_INT 1
100172: ARRAY
100173: PPUSH
100174: LD_EXP 181
100178: PUSH
100179: LD_VAR 0 1
100183: ARRAY
100184: PUSH
100185: LD_VAR 0 2
100189: ARRAY
100190: PUSH
100191: LD_INT 2
100193: ARRAY
100194: PPUSH
100195: LD_VAR 0 3
100199: PPUSH
100200: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
100204: LD_ADDR_EXP 181
100208: PUSH
100209: LD_EXP 181
100213: PPUSH
100214: LD_VAR 0 1
100218: PPUSH
100219: LD_EXP 181
100223: PUSH
100224: LD_VAR 0 1
100228: ARRAY
100229: PPUSH
100230: LD_VAR 0 2
100234: PPUSH
100235: CALL_OW 3
100239: PPUSH
100240: CALL_OW 1
100244: ST_TO_ADDR
// end ; end ;
100245: GO 99996
100247: POP
100248: POP
// end ;
100249: GO 99914
100251: POP
100252: POP
// end ;
100253: PPOPN 4
100255: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
100256: LD_INT 0
100258: PPUSH
100259: PPUSH
// result := false ;
100260: LD_ADDR_VAR 0 4
100264: PUSH
100265: LD_INT 0
100267: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
100268: LD_VAR 0 1
100272: PPUSH
100273: CALL_OW 264
100277: PUSH
100278: LD_EXP 55
100282: EQUAL
100283: NOT
100284: IFFALSE 100288
// exit ;
100286: GO 100528
// index := GetElementIndex ( minersList , unit ) ;
100288: LD_ADDR_VAR 0 5
100292: PUSH
100293: LD_EXP 180
100297: PPUSH
100298: LD_VAR 0 1
100302: PPUSH
100303: CALL 18373 0 2
100307: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
100308: LD_EXP 181
100312: PUSH
100313: LD_VAR 0 5
100317: ARRAY
100318: PUSH
100319: LD_EXP 182
100323: GREATEREQUAL
100324: IFFALSE 100328
// exit ;
100326: GO 100528
// ComMoveXY ( unit , x , y ) ;
100328: LD_VAR 0 1
100332: PPUSH
100333: LD_VAR 0 2
100337: PPUSH
100338: LD_VAR 0 3
100342: PPUSH
100343: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
100347: LD_INT 35
100349: PPUSH
100350: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
100354: LD_VAR 0 1
100358: PPUSH
100359: LD_VAR 0 2
100363: PPUSH
100364: LD_VAR 0 3
100368: PPUSH
100369: CALL 49145 0 3
100373: NOT
100374: PUSH
100375: LD_VAR 0 1
100379: PPUSH
100380: CALL_OW 314
100384: AND
100385: IFFALSE 100389
// exit ;
100387: GO 100528
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
100389: LD_VAR 0 2
100393: PPUSH
100394: LD_VAR 0 3
100398: PPUSH
100399: CALL_OW 428
100403: PUSH
100404: LD_VAR 0 1
100408: EQUAL
100409: PUSH
100410: LD_VAR 0 1
100414: PPUSH
100415: CALL_OW 314
100419: NOT
100420: AND
100421: IFFALSE 100347
// PlaySoundXY ( x , y , PlantMine ) ;
100423: LD_VAR 0 2
100427: PPUSH
100428: LD_VAR 0 3
100432: PPUSH
100433: LD_STRING PlantMine
100435: PPUSH
100436: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
100440: LD_VAR 0 2
100444: PPUSH
100445: LD_VAR 0 3
100449: PPUSH
100450: LD_VAR 0 1
100454: PPUSH
100455: CALL_OW 255
100459: PPUSH
100460: LD_INT 0
100462: PPUSH
100463: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
100467: LD_ADDR_EXP 181
100471: PUSH
100472: LD_EXP 181
100476: PPUSH
100477: LD_VAR 0 5
100481: PUSH
100482: LD_EXP 181
100486: PUSH
100487: LD_VAR 0 5
100491: ARRAY
100492: PUSH
100493: LD_INT 1
100495: PLUS
100496: PUSH
100497: EMPTY
100498: LIST
100499: LIST
100500: PPUSH
100501: LD_VAR 0 2
100505: PUSH
100506: LD_VAR 0 3
100510: PUSH
100511: EMPTY
100512: LIST
100513: LIST
100514: PPUSH
100515: CALL 18588 0 3
100519: ST_TO_ADDR
// result := true ;
100520: LD_ADDR_VAR 0 4
100524: PUSH
100525: LD_INT 1
100527: ST_TO_ADDR
// end ;
100528: LD_VAR 0 4
100532: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
100533: LD_INT 0
100535: PPUSH
100536: PPUSH
100537: PPUSH
// if not unit in minersList then
100538: LD_VAR 0 1
100542: PUSH
100543: LD_EXP 180
100547: IN
100548: NOT
100549: IFFALSE 100553
// exit ;
100551: GO 100945
// index := GetElementIndex ( minersList , unit ) ;
100553: LD_ADDR_VAR 0 6
100557: PUSH
100558: LD_EXP 180
100562: PPUSH
100563: LD_VAR 0 1
100567: PPUSH
100568: CALL 18373 0 2
100572: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
100573: LD_ADDR_VAR 0 5
100577: PUSH
100578: DOUBLE
100579: LD_EXP 181
100583: PUSH
100584: LD_VAR 0 6
100588: ARRAY
100589: INC
100590: ST_TO_ADDR
100591: LD_INT 1
100593: PUSH
100594: FOR_DOWNTO
100595: IFFALSE 100756
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
100597: LD_EXP 181
100601: PUSH
100602: LD_VAR 0 6
100606: ARRAY
100607: PUSH
100608: LD_VAR 0 5
100612: ARRAY
100613: PUSH
100614: LD_INT 1
100616: ARRAY
100617: PUSH
100618: LD_VAR 0 2
100622: EQUAL
100623: PUSH
100624: LD_EXP 181
100628: PUSH
100629: LD_VAR 0 6
100633: ARRAY
100634: PUSH
100635: LD_VAR 0 5
100639: ARRAY
100640: PUSH
100641: LD_INT 2
100643: ARRAY
100644: PUSH
100645: LD_VAR 0 3
100649: EQUAL
100650: AND
100651: IFFALSE 100754
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
100653: LD_EXP 181
100657: PUSH
100658: LD_VAR 0 6
100662: ARRAY
100663: PUSH
100664: LD_VAR 0 5
100668: ARRAY
100669: PUSH
100670: LD_INT 1
100672: ARRAY
100673: PPUSH
100674: LD_EXP 181
100678: PUSH
100679: LD_VAR 0 6
100683: ARRAY
100684: PUSH
100685: LD_VAR 0 5
100689: ARRAY
100690: PUSH
100691: LD_INT 2
100693: ARRAY
100694: PPUSH
100695: LD_VAR 0 1
100699: PPUSH
100700: CALL_OW 255
100704: PPUSH
100705: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
100709: LD_ADDR_EXP 181
100713: PUSH
100714: LD_EXP 181
100718: PPUSH
100719: LD_VAR 0 6
100723: PPUSH
100724: LD_EXP 181
100728: PUSH
100729: LD_VAR 0 6
100733: ARRAY
100734: PPUSH
100735: LD_VAR 0 5
100739: PPUSH
100740: CALL_OW 3
100744: PPUSH
100745: CALL_OW 1
100749: ST_TO_ADDR
// exit ;
100750: POP
100751: POP
100752: GO 100945
// end ; end ;
100754: GO 100594
100756: POP
100757: POP
// for i := minerMinesList [ index ] downto 1 do
100758: LD_ADDR_VAR 0 5
100762: PUSH
100763: DOUBLE
100764: LD_EXP 181
100768: PUSH
100769: LD_VAR 0 6
100773: ARRAY
100774: INC
100775: ST_TO_ADDR
100776: LD_INT 1
100778: PUSH
100779: FOR_DOWNTO
100780: IFFALSE 100943
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
100782: LD_EXP 181
100786: PUSH
100787: LD_VAR 0 6
100791: ARRAY
100792: PUSH
100793: LD_VAR 0 5
100797: ARRAY
100798: PUSH
100799: LD_INT 1
100801: ARRAY
100802: PPUSH
100803: LD_EXP 181
100807: PUSH
100808: LD_VAR 0 6
100812: ARRAY
100813: PUSH
100814: LD_VAR 0 5
100818: ARRAY
100819: PUSH
100820: LD_INT 2
100822: ARRAY
100823: PPUSH
100824: LD_VAR 0 2
100828: PPUSH
100829: LD_VAR 0 3
100833: PPUSH
100834: CALL_OW 298
100838: PUSH
100839: LD_INT 6
100841: LESS
100842: IFFALSE 100941
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
100844: LD_EXP 181
100848: PUSH
100849: LD_VAR 0 6
100853: ARRAY
100854: PUSH
100855: LD_VAR 0 5
100859: ARRAY
100860: PUSH
100861: LD_INT 1
100863: ARRAY
100864: PPUSH
100865: LD_EXP 181
100869: PUSH
100870: LD_VAR 0 6
100874: ARRAY
100875: PUSH
100876: LD_VAR 0 5
100880: ARRAY
100881: PUSH
100882: LD_INT 2
100884: ARRAY
100885: PPUSH
100886: LD_VAR 0 1
100890: PPUSH
100891: CALL_OW 255
100895: PPUSH
100896: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
100900: LD_ADDR_EXP 181
100904: PUSH
100905: LD_EXP 181
100909: PPUSH
100910: LD_VAR 0 6
100914: PPUSH
100915: LD_EXP 181
100919: PUSH
100920: LD_VAR 0 6
100924: ARRAY
100925: PPUSH
100926: LD_VAR 0 5
100930: PPUSH
100931: CALL_OW 3
100935: PPUSH
100936: CALL_OW 1
100940: ST_TO_ADDR
// end ; end ;
100941: GO 100779
100943: POP
100944: POP
// end ;
100945: LD_VAR 0 4
100949: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
100950: LD_INT 0
100952: PPUSH
100953: PPUSH
100954: PPUSH
100955: PPUSH
100956: PPUSH
100957: PPUSH
100958: PPUSH
100959: PPUSH
100960: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
100961: LD_VAR 0 1
100965: PPUSH
100966: CALL_OW 264
100970: PUSH
100971: LD_EXP 55
100975: EQUAL
100976: NOT
100977: PUSH
100978: LD_VAR 0 1
100982: PUSH
100983: LD_EXP 180
100987: IN
100988: NOT
100989: OR
100990: IFFALSE 100994
// exit ;
100992: GO 101316
// index := GetElementIndex ( minersList , unit ) ;
100994: LD_ADDR_VAR 0 6
100998: PUSH
100999: LD_EXP 180
101003: PPUSH
101004: LD_VAR 0 1
101008: PPUSH
101009: CALL 18373 0 2
101013: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
101014: LD_ADDR_VAR 0 8
101018: PUSH
101019: LD_EXP 182
101023: PUSH
101024: LD_EXP 181
101028: PUSH
101029: LD_VAR 0 6
101033: ARRAY
101034: MINUS
101035: ST_TO_ADDR
// if not minesFreeAmount then
101036: LD_VAR 0 8
101040: NOT
101041: IFFALSE 101045
// exit ;
101043: GO 101316
// tmp := [ ] ;
101045: LD_ADDR_VAR 0 7
101049: PUSH
101050: EMPTY
101051: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
101052: LD_ADDR_VAR 0 5
101056: PUSH
101057: DOUBLE
101058: LD_INT 1
101060: DEC
101061: ST_TO_ADDR
101062: LD_VAR 0 8
101066: PUSH
101067: FOR_TO
101068: IFFALSE 101263
// begin _d := rand ( 0 , 5 ) ;
101070: LD_ADDR_VAR 0 11
101074: PUSH
101075: LD_INT 0
101077: PPUSH
101078: LD_INT 5
101080: PPUSH
101081: CALL_OW 12
101085: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
101086: LD_ADDR_VAR 0 12
101090: PUSH
101091: LD_INT 2
101093: PPUSH
101094: LD_INT 6
101096: PPUSH
101097: CALL_OW 12
101101: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
101102: LD_ADDR_VAR 0 9
101106: PUSH
101107: LD_VAR 0 2
101111: PPUSH
101112: LD_VAR 0 11
101116: PPUSH
101117: LD_VAR 0 12
101121: PPUSH
101122: CALL_OW 272
101126: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
101127: LD_ADDR_VAR 0 10
101131: PUSH
101132: LD_VAR 0 3
101136: PPUSH
101137: LD_VAR 0 11
101141: PPUSH
101142: LD_VAR 0 12
101146: PPUSH
101147: CALL_OW 273
101151: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
101152: LD_VAR 0 9
101156: PPUSH
101157: LD_VAR 0 10
101161: PPUSH
101162: CALL_OW 488
101166: PUSH
101167: LD_VAR 0 9
101171: PUSH
101172: LD_VAR 0 10
101176: PUSH
101177: EMPTY
101178: LIST
101179: LIST
101180: PUSH
101181: LD_VAR 0 7
101185: IN
101186: NOT
101187: AND
101188: PUSH
101189: LD_VAR 0 9
101193: PPUSH
101194: LD_VAR 0 10
101198: PPUSH
101199: CALL_OW 458
101203: NOT
101204: AND
101205: IFFALSE 101247
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
101207: LD_ADDR_VAR 0 7
101211: PUSH
101212: LD_VAR 0 7
101216: PPUSH
101217: LD_VAR 0 7
101221: PUSH
101222: LD_INT 1
101224: PLUS
101225: PPUSH
101226: LD_VAR 0 9
101230: PUSH
101231: LD_VAR 0 10
101235: PUSH
101236: EMPTY
101237: LIST
101238: LIST
101239: PPUSH
101240: CALL_OW 1
101244: ST_TO_ADDR
101245: GO 101261
// i := i - 1 ;
101247: LD_ADDR_VAR 0 5
101251: PUSH
101252: LD_VAR 0 5
101256: PUSH
101257: LD_INT 1
101259: MINUS
101260: ST_TO_ADDR
// end ;
101261: GO 101067
101263: POP
101264: POP
// for i in tmp do
101265: LD_ADDR_VAR 0 5
101269: PUSH
101270: LD_VAR 0 7
101274: PUSH
101275: FOR_IN
101276: IFFALSE 101314
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
101278: LD_VAR 0 1
101282: PPUSH
101283: LD_VAR 0 5
101287: PUSH
101288: LD_INT 1
101290: ARRAY
101291: PPUSH
101292: LD_VAR 0 5
101296: PUSH
101297: LD_INT 2
101299: ARRAY
101300: PPUSH
101301: CALL 100256 0 3
101305: NOT
101306: IFFALSE 101312
// exit ;
101308: POP
101309: POP
101310: GO 101316
101312: GO 101275
101314: POP
101315: POP
// end ;
101316: LD_VAR 0 4
101320: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
101321: LD_INT 0
101323: PPUSH
101324: PPUSH
101325: PPUSH
101326: PPUSH
101327: PPUSH
101328: PPUSH
101329: PPUSH
// if not GetClass ( unit ) = class_sniper then
101330: LD_VAR 0 1
101334: PPUSH
101335: CALL_OW 257
101339: PUSH
101340: LD_INT 5
101342: EQUAL
101343: NOT
101344: IFFALSE 101348
// exit ;
101346: GO 101736
// dist := 8 ;
101348: LD_ADDR_VAR 0 5
101352: PUSH
101353: LD_INT 8
101355: ST_TO_ADDR
// viewRange := 12 ;
101356: LD_ADDR_VAR 0 7
101360: PUSH
101361: LD_INT 12
101363: ST_TO_ADDR
// side := GetSide ( unit ) ;
101364: LD_ADDR_VAR 0 6
101368: PUSH
101369: LD_VAR 0 1
101373: PPUSH
101374: CALL_OW 255
101378: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
101379: LD_INT 61
101381: PPUSH
101382: LD_VAR 0 6
101386: PPUSH
101387: CALL_OW 321
101391: PUSH
101392: LD_INT 2
101394: EQUAL
101395: IFFALSE 101405
// viewRange := 16 ;
101397: LD_ADDR_VAR 0 7
101401: PUSH
101402: LD_INT 16
101404: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
101405: LD_VAR 0 1
101409: PPUSH
101410: LD_VAR 0 2
101414: PPUSH
101415: LD_VAR 0 3
101419: PPUSH
101420: CALL_OW 297
101424: PUSH
101425: LD_VAR 0 5
101429: GREATER
101430: IFFALSE 101509
// begin ComMoveXY ( unit , x , y ) ;
101432: LD_VAR 0 1
101436: PPUSH
101437: LD_VAR 0 2
101441: PPUSH
101442: LD_VAR 0 3
101446: PPUSH
101447: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
101451: LD_INT 35
101453: PPUSH
101454: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
101458: LD_VAR 0 1
101462: PPUSH
101463: LD_VAR 0 2
101467: PPUSH
101468: LD_VAR 0 3
101472: PPUSH
101473: CALL 49145 0 3
101477: NOT
101478: IFFALSE 101482
// exit ;
101480: GO 101736
// until GetDistUnitXY ( unit , x , y ) < dist ;
101482: LD_VAR 0 1
101486: PPUSH
101487: LD_VAR 0 2
101491: PPUSH
101492: LD_VAR 0 3
101496: PPUSH
101497: CALL_OW 297
101501: PUSH
101502: LD_VAR 0 5
101506: LESS
101507: IFFALSE 101451
// end ; ComTurnXY ( unit , x , y ) ;
101509: LD_VAR 0 1
101513: PPUSH
101514: LD_VAR 0 2
101518: PPUSH
101519: LD_VAR 0 3
101523: PPUSH
101524: CALL_OW 118
// wait ( 5 ) ;
101528: LD_INT 5
101530: PPUSH
101531: CALL_OW 67
// _d := GetDir ( unit ) ;
101535: LD_ADDR_VAR 0 10
101539: PUSH
101540: LD_VAR 0 1
101544: PPUSH
101545: CALL_OW 254
101549: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
101550: LD_ADDR_VAR 0 8
101554: PUSH
101555: LD_VAR 0 1
101559: PPUSH
101560: CALL_OW 250
101564: PPUSH
101565: LD_VAR 0 10
101569: PPUSH
101570: LD_VAR 0 5
101574: PPUSH
101575: CALL_OW 272
101579: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
101580: LD_ADDR_VAR 0 9
101584: PUSH
101585: LD_VAR 0 1
101589: PPUSH
101590: CALL_OW 251
101594: PPUSH
101595: LD_VAR 0 10
101599: PPUSH
101600: LD_VAR 0 5
101604: PPUSH
101605: CALL_OW 273
101609: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
101610: LD_VAR 0 8
101614: PPUSH
101615: LD_VAR 0 9
101619: PPUSH
101620: CALL_OW 488
101624: NOT
101625: IFFALSE 101629
// exit ;
101627: GO 101736
// ComAnimCustom ( unit , 1 ) ;
101629: LD_VAR 0 1
101633: PPUSH
101634: LD_INT 1
101636: PPUSH
101637: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
101641: LD_VAR 0 8
101645: PPUSH
101646: LD_VAR 0 9
101650: PPUSH
101651: LD_VAR 0 6
101655: PPUSH
101656: LD_VAR 0 7
101660: PPUSH
101661: CALL_OW 330
// repeat wait ( 1 ) ;
101665: LD_INT 1
101667: PPUSH
101668: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
101672: LD_VAR 0 1
101676: PPUSH
101677: CALL_OW 316
101681: PUSH
101682: LD_VAR 0 1
101686: PPUSH
101687: CALL_OW 314
101691: OR
101692: PUSH
101693: LD_VAR 0 1
101697: PPUSH
101698: CALL_OW 302
101702: NOT
101703: OR
101704: PUSH
101705: LD_VAR 0 1
101709: PPUSH
101710: CALL_OW 301
101714: OR
101715: IFFALSE 101665
// RemoveSeeing ( _x , _y , side ) ;
101717: LD_VAR 0 8
101721: PPUSH
101722: LD_VAR 0 9
101726: PPUSH
101727: LD_VAR 0 6
101731: PPUSH
101732: CALL_OW 331
// end ; end_of_file
101736: LD_VAR 0 4
101740: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
101741: LD_INT 0
101743: PPUSH
101744: PPUSH
101745: PPUSH
101746: PPUSH
101747: PPUSH
101748: PPUSH
101749: PPUSH
101750: PPUSH
101751: PPUSH
101752: PPUSH
101753: PPUSH
101754: PPUSH
101755: PPUSH
101756: PPUSH
101757: PPUSH
101758: PPUSH
101759: PPUSH
101760: PPUSH
101761: PPUSH
101762: PPUSH
101763: PPUSH
101764: PPUSH
101765: PPUSH
101766: PPUSH
101767: PPUSH
101768: PPUSH
101769: PPUSH
101770: PPUSH
101771: PPUSH
101772: PPUSH
101773: PPUSH
101774: PPUSH
101775: PPUSH
101776: PPUSH
// if not list then
101777: LD_VAR 0 1
101781: NOT
101782: IFFALSE 101786
// exit ;
101784: GO 106445
// base := list [ 1 ] ;
101786: LD_ADDR_VAR 0 3
101790: PUSH
101791: LD_VAR 0 1
101795: PUSH
101796: LD_INT 1
101798: ARRAY
101799: ST_TO_ADDR
// group := list [ 2 ] ;
101800: LD_ADDR_VAR 0 4
101804: PUSH
101805: LD_VAR 0 1
101809: PUSH
101810: LD_INT 2
101812: ARRAY
101813: ST_TO_ADDR
// path := list [ 3 ] ;
101814: LD_ADDR_VAR 0 5
101818: PUSH
101819: LD_VAR 0 1
101823: PUSH
101824: LD_INT 3
101826: ARRAY
101827: ST_TO_ADDR
// flags := list [ 4 ] ;
101828: LD_ADDR_VAR 0 6
101832: PUSH
101833: LD_VAR 0 1
101837: PUSH
101838: LD_INT 4
101840: ARRAY
101841: ST_TO_ADDR
// mined := [ ] ;
101842: LD_ADDR_VAR 0 27
101846: PUSH
101847: EMPTY
101848: ST_TO_ADDR
// bombed := [ ] ;
101849: LD_ADDR_VAR 0 28
101853: PUSH
101854: EMPTY
101855: ST_TO_ADDR
// healers := [ ] ;
101856: LD_ADDR_VAR 0 31
101860: PUSH
101861: EMPTY
101862: ST_TO_ADDR
// to_heal := [ ] ;
101863: LD_ADDR_VAR 0 30
101867: PUSH
101868: EMPTY
101869: ST_TO_ADDR
// repairs := [ ] ;
101870: LD_ADDR_VAR 0 33
101874: PUSH
101875: EMPTY
101876: ST_TO_ADDR
// to_repair := [ ] ;
101877: LD_ADDR_VAR 0 32
101881: PUSH
101882: EMPTY
101883: ST_TO_ADDR
// if not group or not path then
101884: LD_VAR 0 4
101888: NOT
101889: PUSH
101890: LD_VAR 0 5
101894: NOT
101895: OR
101896: IFFALSE 101900
// exit ;
101898: GO 106445
// side := GetSide ( group [ 1 ] ) ;
101900: LD_ADDR_VAR 0 35
101904: PUSH
101905: LD_VAR 0 4
101909: PUSH
101910: LD_INT 1
101912: ARRAY
101913: PPUSH
101914: CALL_OW 255
101918: ST_TO_ADDR
// if flags then
101919: LD_VAR 0 6
101923: IFFALSE 102067
// begin f_ignore_area := flags [ 1 ] ;
101925: LD_ADDR_VAR 0 17
101929: PUSH
101930: LD_VAR 0 6
101934: PUSH
101935: LD_INT 1
101937: ARRAY
101938: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
101939: LD_ADDR_VAR 0 18
101943: PUSH
101944: LD_VAR 0 6
101948: PUSH
101949: LD_INT 2
101951: ARRAY
101952: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
101953: LD_ADDR_VAR 0 19
101957: PUSH
101958: LD_VAR 0 6
101962: PUSH
101963: LD_INT 3
101965: ARRAY
101966: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
101967: LD_ADDR_VAR 0 20
101971: PUSH
101972: LD_VAR 0 6
101976: PUSH
101977: LD_INT 4
101979: ARRAY
101980: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
101981: LD_ADDR_VAR 0 21
101985: PUSH
101986: LD_VAR 0 6
101990: PUSH
101991: LD_INT 5
101993: ARRAY
101994: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
101995: LD_ADDR_VAR 0 22
101999: PUSH
102000: LD_VAR 0 6
102004: PUSH
102005: LD_INT 6
102007: ARRAY
102008: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
102009: LD_ADDR_VAR 0 23
102013: PUSH
102014: LD_VAR 0 6
102018: PUSH
102019: LD_INT 7
102021: ARRAY
102022: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
102023: LD_ADDR_VAR 0 24
102027: PUSH
102028: LD_VAR 0 6
102032: PUSH
102033: LD_INT 8
102035: ARRAY
102036: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
102037: LD_ADDR_VAR 0 25
102041: PUSH
102042: LD_VAR 0 6
102046: PUSH
102047: LD_INT 9
102049: ARRAY
102050: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
102051: LD_ADDR_VAR 0 26
102055: PUSH
102056: LD_VAR 0 6
102060: PUSH
102061: LD_INT 10
102063: ARRAY
102064: ST_TO_ADDR
// end else
102065: GO 102147
// begin f_ignore_area := false ;
102067: LD_ADDR_VAR 0 17
102071: PUSH
102072: LD_INT 0
102074: ST_TO_ADDR
// f_capture := false ;
102075: LD_ADDR_VAR 0 18
102079: PUSH
102080: LD_INT 0
102082: ST_TO_ADDR
// f_ignore_civ := false ;
102083: LD_ADDR_VAR 0 19
102087: PUSH
102088: LD_INT 0
102090: ST_TO_ADDR
// f_murder := false ;
102091: LD_ADDR_VAR 0 20
102095: PUSH
102096: LD_INT 0
102098: ST_TO_ADDR
// f_mines := false ;
102099: LD_ADDR_VAR 0 21
102103: PUSH
102104: LD_INT 0
102106: ST_TO_ADDR
// f_repair := false ;
102107: LD_ADDR_VAR 0 22
102111: PUSH
102112: LD_INT 0
102114: ST_TO_ADDR
// f_heal := false ;
102115: LD_ADDR_VAR 0 23
102119: PUSH
102120: LD_INT 0
102122: ST_TO_ADDR
// f_spacetime := false ;
102123: LD_ADDR_VAR 0 24
102127: PUSH
102128: LD_INT 0
102130: ST_TO_ADDR
// f_attack_depot := false ;
102131: LD_ADDR_VAR 0 25
102135: PUSH
102136: LD_INT 0
102138: ST_TO_ADDR
// f_crawl := false ;
102139: LD_ADDR_VAR 0 26
102143: PUSH
102144: LD_INT 0
102146: ST_TO_ADDR
// end ; if f_heal then
102147: LD_VAR 0 23
102151: IFFALSE 102178
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
102153: LD_ADDR_VAR 0 31
102157: PUSH
102158: LD_VAR 0 4
102162: PPUSH
102163: LD_INT 25
102165: PUSH
102166: LD_INT 4
102168: PUSH
102169: EMPTY
102170: LIST
102171: LIST
102172: PPUSH
102173: CALL_OW 72
102177: ST_TO_ADDR
// if f_repair then
102178: LD_VAR 0 22
102182: IFFALSE 102209
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
102184: LD_ADDR_VAR 0 33
102188: PUSH
102189: LD_VAR 0 4
102193: PPUSH
102194: LD_INT 25
102196: PUSH
102197: LD_INT 3
102199: PUSH
102200: EMPTY
102201: LIST
102202: LIST
102203: PPUSH
102204: CALL_OW 72
102208: ST_TO_ADDR
// units_path := [ ] ;
102209: LD_ADDR_VAR 0 16
102213: PUSH
102214: EMPTY
102215: ST_TO_ADDR
// for i = 1 to group do
102216: LD_ADDR_VAR 0 7
102220: PUSH
102221: DOUBLE
102222: LD_INT 1
102224: DEC
102225: ST_TO_ADDR
102226: LD_VAR 0 4
102230: PUSH
102231: FOR_TO
102232: IFFALSE 102261
// units_path := Replace ( units_path , i , path ) ;
102234: LD_ADDR_VAR 0 16
102238: PUSH
102239: LD_VAR 0 16
102243: PPUSH
102244: LD_VAR 0 7
102248: PPUSH
102249: LD_VAR 0 5
102253: PPUSH
102254: CALL_OW 1
102258: ST_TO_ADDR
102259: GO 102231
102261: POP
102262: POP
// repeat for i = group downto 1 do
102263: LD_ADDR_VAR 0 7
102267: PUSH
102268: DOUBLE
102269: LD_VAR 0 4
102273: INC
102274: ST_TO_ADDR
102275: LD_INT 1
102277: PUSH
102278: FOR_DOWNTO
102279: IFFALSE 106401
// begin wait ( 5 ) ;
102281: LD_INT 5
102283: PPUSH
102284: CALL_OW 67
// tmp := [ ] ;
102288: LD_ADDR_VAR 0 14
102292: PUSH
102293: EMPTY
102294: ST_TO_ADDR
// attacking := false ;
102295: LD_ADDR_VAR 0 29
102299: PUSH
102300: LD_INT 0
102302: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
102303: LD_VAR 0 4
102307: PUSH
102308: LD_VAR 0 7
102312: ARRAY
102313: PPUSH
102314: CALL_OW 301
102318: PUSH
102319: LD_VAR 0 4
102323: PUSH
102324: LD_VAR 0 7
102328: ARRAY
102329: NOT
102330: OR
102331: IFFALSE 102440
// begin if GetType ( group [ i ] ) = unit_human then
102333: LD_VAR 0 4
102337: PUSH
102338: LD_VAR 0 7
102342: ARRAY
102343: PPUSH
102344: CALL_OW 247
102348: PUSH
102349: LD_INT 1
102351: EQUAL
102352: IFFALSE 102398
// begin to_heal := to_heal diff group [ i ] ;
102354: LD_ADDR_VAR 0 30
102358: PUSH
102359: LD_VAR 0 30
102363: PUSH
102364: LD_VAR 0 4
102368: PUSH
102369: LD_VAR 0 7
102373: ARRAY
102374: DIFF
102375: ST_TO_ADDR
// healers := healers diff group [ i ] ;
102376: LD_ADDR_VAR 0 31
102380: PUSH
102381: LD_VAR 0 31
102385: PUSH
102386: LD_VAR 0 4
102390: PUSH
102391: LD_VAR 0 7
102395: ARRAY
102396: DIFF
102397: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
102398: LD_ADDR_VAR 0 4
102402: PUSH
102403: LD_VAR 0 4
102407: PPUSH
102408: LD_VAR 0 7
102412: PPUSH
102413: CALL_OW 3
102417: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
102418: LD_ADDR_VAR 0 16
102422: PUSH
102423: LD_VAR 0 16
102427: PPUSH
102428: LD_VAR 0 7
102432: PPUSH
102433: CALL_OW 3
102437: ST_TO_ADDR
// continue ;
102438: GO 102278
// end ; if f_repair then
102440: LD_VAR 0 22
102444: IFFALSE 102933
// begin if GetType ( group [ i ] ) = unit_vehicle then
102446: LD_VAR 0 4
102450: PUSH
102451: LD_VAR 0 7
102455: ARRAY
102456: PPUSH
102457: CALL_OW 247
102461: PUSH
102462: LD_INT 2
102464: EQUAL
102465: IFFALSE 102655
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
102467: LD_VAR 0 4
102471: PUSH
102472: LD_VAR 0 7
102476: ARRAY
102477: PPUSH
102478: CALL_OW 256
102482: PUSH
102483: LD_INT 700
102485: LESS
102486: PUSH
102487: LD_VAR 0 4
102491: PUSH
102492: LD_VAR 0 7
102496: ARRAY
102497: PUSH
102498: LD_VAR 0 32
102502: IN
102503: NOT
102504: AND
102505: IFFALSE 102529
// to_repair := to_repair union group [ i ] ;
102507: LD_ADDR_VAR 0 32
102511: PUSH
102512: LD_VAR 0 32
102516: PUSH
102517: LD_VAR 0 4
102521: PUSH
102522: LD_VAR 0 7
102526: ARRAY
102527: UNION
102528: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
102529: LD_VAR 0 4
102533: PUSH
102534: LD_VAR 0 7
102538: ARRAY
102539: PPUSH
102540: CALL_OW 256
102544: PUSH
102545: LD_INT 1000
102547: EQUAL
102548: PUSH
102549: LD_VAR 0 4
102553: PUSH
102554: LD_VAR 0 7
102558: ARRAY
102559: PUSH
102560: LD_VAR 0 32
102564: IN
102565: AND
102566: IFFALSE 102590
// to_repair := to_repair diff group [ i ] ;
102568: LD_ADDR_VAR 0 32
102572: PUSH
102573: LD_VAR 0 32
102577: PUSH
102578: LD_VAR 0 4
102582: PUSH
102583: LD_VAR 0 7
102587: ARRAY
102588: DIFF
102589: ST_TO_ADDR
// if group [ i ] in to_repair then
102590: LD_VAR 0 4
102594: PUSH
102595: LD_VAR 0 7
102599: ARRAY
102600: PUSH
102601: LD_VAR 0 32
102605: IN
102606: IFFALSE 102653
// begin if not IsInArea ( group [ i ] , f_repair ) then
102608: LD_VAR 0 4
102612: PUSH
102613: LD_VAR 0 7
102617: ARRAY
102618: PPUSH
102619: LD_VAR 0 22
102623: PPUSH
102624: CALL_OW 308
102628: NOT
102629: IFFALSE 102651
// ComMoveToArea ( group [ i ] , f_repair ) ;
102631: LD_VAR 0 4
102635: PUSH
102636: LD_VAR 0 7
102640: ARRAY
102641: PPUSH
102642: LD_VAR 0 22
102646: PPUSH
102647: CALL_OW 113
// continue ;
102651: GO 102278
// end ; end else
102653: GO 102933
// if group [ i ] in repairs then
102655: LD_VAR 0 4
102659: PUSH
102660: LD_VAR 0 7
102664: ARRAY
102665: PUSH
102666: LD_VAR 0 33
102670: IN
102671: IFFALSE 102933
// begin if IsInUnit ( group [ i ] ) then
102673: LD_VAR 0 4
102677: PUSH
102678: LD_VAR 0 7
102682: ARRAY
102683: PPUSH
102684: CALL_OW 310
102688: IFFALSE 102756
// begin z := IsInUnit ( group [ i ] ) ;
102690: LD_ADDR_VAR 0 13
102694: PUSH
102695: LD_VAR 0 4
102699: PUSH
102700: LD_VAR 0 7
102704: ARRAY
102705: PPUSH
102706: CALL_OW 310
102710: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
102711: LD_VAR 0 13
102715: PUSH
102716: LD_VAR 0 32
102720: IN
102721: PUSH
102722: LD_VAR 0 13
102726: PPUSH
102727: LD_VAR 0 22
102731: PPUSH
102732: CALL_OW 308
102736: AND
102737: IFFALSE 102754
// ComExitVehicle ( group [ i ] ) ;
102739: LD_VAR 0 4
102743: PUSH
102744: LD_VAR 0 7
102748: ARRAY
102749: PPUSH
102750: CALL_OW 121
// end else
102754: GO 102933
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
102756: LD_ADDR_VAR 0 13
102760: PUSH
102761: LD_VAR 0 4
102765: PPUSH
102766: LD_INT 95
102768: PUSH
102769: LD_VAR 0 22
102773: PUSH
102774: EMPTY
102775: LIST
102776: LIST
102777: PUSH
102778: LD_INT 58
102780: PUSH
102781: EMPTY
102782: LIST
102783: PUSH
102784: EMPTY
102785: LIST
102786: LIST
102787: PPUSH
102788: CALL_OW 72
102792: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
102793: LD_VAR 0 4
102797: PUSH
102798: LD_VAR 0 7
102802: ARRAY
102803: PPUSH
102804: CALL_OW 314
102808: NOT
102809: IFFALSE 102931
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
102811: LD_ADDR_VAR 0 10
102815: PUSH
102816: LD_VAR 0 13
102820: PPUSH
102821: LD_VAR 0 4
102825: PUSH
102826: LD_VAR 0 7
102830: ARRAY
102831: PPUSH
102832: CALL_OW 74
102836: ST_TO_ADDR
// if not x then
102837: LD_VAR 0 10
102841: NOT
102842: IFFALSE 102846
// continue ;
102844: GO 102278
// if GetLives ( x ) < 1000 then
102846: LD_VAR 0 10
102850: PPUSH
102851: CALL_OW 256
102855: PUSH
102856: LD_INT 1000
102858: LESS
102859: IFFALSE 102883
// ComRepairVehicle ( group [ i ] , x ) else
102861: LD_VAR 0 4
102865: PUSH
102866: LD_VAR 0 7
102870: ARRAY
102871: PPUSH
102872: LD_VAR 0 10
102876: PPUSH
102877: CALL_OW 129
102881: GO 102931
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
102883: LD_VAR 0 23
102887: PUSH
102888: LD_VAR 0 4
102892: PUSH
102893: LD_VAR 0 7
102897: ARRAY
102898: PPUSH
102899: CALL_OW 256
102903: PUSH
102904: LD_INT 1000
102906: LESS
102907: AND
102908: NOT
102909: IFFALSE 102931
// ComEnterUnit ( group [ i ] , x ) ;
102911: LD_VAR 0 4
102915: PUSH
102916: LD_VAR 0 7
102920: ARRAY
102921: PPUSH
102922: LD_VAR 0 10
102926: PPUSH
102927: CALL_OW 120
// end ; continue ;
102931: GO 102278
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
102933: LD_VAR 0 23
102937: PUSH
102938: LD_VAR 0 4
102942: PUSH
102943: LD_VAR 0 7
102947: ARRAY
102948: PPUSH
102949: CALL_OW 247
102953: PUSH
102954: LD_INT 1
102956: EQUAL
102957: AND
102958: IFFALSE 103436
// begin if group [ i ] in healers then
102960: LD_VAR 0 4
102964: PUSH
102965: LD_VAR 0 7
102969: ARRAY
102970: PUSH
102971: LD_VAR 0 31
102975: IN
102976: IFFALSE 103249
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
102978: LD_VAR 0 4
102982: PUSH
102983: LD_VAR 0 7
102987: ARRAY
102988: PPUSH
102989: LD_VAR 0 23
102993: PPUSH
102994: CALL_OW 308
102998: NOT
102999: PUSH
103000: LD_VAR 0 4
103004: PUSH
103005: LD_VAR 0 7
103009: ARRAY
103010: PPUSH
103011: CALL_OW 314
103015: NOT
103016: AND
103017: IFFALSE 103041
// ComMoveToArea ( group [ i ] , f_heal ) else
103019: LD_VAR 0 4
103023: PUSH
103024: LD_VAR 0 7
103028: ARRAY
103029: PPUSH
103030: LD_VAR 0 23
103034: PPUSH
103035: CALL_OW 113
103039: GO 103247
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
103041: LD_VAR 0 4
103045: PUSH
103046: LD_VAR 0 7
103050: ARRAY
103051: PPUSH
103052: CALL 47668 0 1
103056: PPUSH
103057: CALL_OW 256
103061: PUSH
103062: LD_INT 1000
103064: EQUAL
103065: IFFALSE 103084
// ComStop ( group [ i ] ) else
103067: LD_VAR 0 4
103071: PUSH
103072: LD_VAR 0 7
103076: ARRAY
103077: PPUSH
103078: CALL_OW 141
103082: GO 103247
// if not HasTask ( group [ i ] ) and to_heal then
103084: LD_VAR 0 4
103088: PUSH
103089: LD_VAR 0 7
103093: ARRAY
103094: PPUSH
103095: CALL_OW 314
103099: NOT
103100: PUSH
103101: LD_VAR 0 30
103105: AND
103106: IFFALSE 103247
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
103108: LD_ADDR_VAR 0 13
103112: PUSH
103113: LD_VAR 0 30
103117: PPUSH
103118: LD_INT 3
103120: PUSH
103121: LD_INT 54
103123: PUSH
103124: EMPTY
103125: LIST
103126: PUSH
103127: EMPTY
103128: LIST
103129: LIST
103130: PPUSH
103131: CALL_OW 72
103135: PPUSH
103136: LD_VAR 0 4
103140: PUSH
103141: LD_VAR 0 7
103145: ARRAY
103146: PPUSH
103147: CALL_OW 74
103151: ST_TO_ADDR
// if z then
103152: LD_VAR 0 13
103156: IFFALSE 103247
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
103158: LD_INT 91
103160: PUSH
103161: LD_VAR 0 13
103165: PUSH
103166: LD_INT 10
103168: PUSH
103169: EMPTY
103170: LIST
103171: LIST
103172: LIST
103173: PUSH
103174: LD_INT 81
103176: PUSH
103177: LD_VAR 0 13
103181: PPUSH
103182: CALL_OW 255
103186: PUSH
103187: EMPTY
103188: LIST
103189: LIST
103190: PUSH
103191: EMPTY
103192: LIST
103193: LIST
103194: PPUSH
103195: CALL_OW 69
103199: PUSH
103200: LD_INT 0
103202: EQUAL
103203: IFFALSE 103227
// ComHeal ( group [ i ] , z ) else
103205: LD_VAR 0 4
103209: PUSH
103210: LD_VAR 0 7
103214: ARRAY
103215: PPUSH
103216: LD_VAR 0 13
103220: PPUSH
103221: CALL_OW 128
103225: GO 103247
// ComMoveToArea ( group [ i ] , f_heal ) ;
103227: LD_VAR 0 4
103231: PUSH
103232: LD_VAR 0 7
103236: ARRAY
103237: PPUSH
103238: LD_VAR 0 23
103242: PPUSH
103243: CALL_OW 113
// end ; continue ;
103247: GO 102278
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
103249: LD_VAR 0 4
103253: PUSH
103254: LD_VAR 0 7
103258: ARRAY
103259: PPUSH
103260: CALL_OW 256
103264: PUSH
103265: LD_INT 700
103267: LESS
103268: PUSH
103269: LD_VAR 0 4
103273: PUSH
103274: LD_VAR 0 7
103278: ARRAY
103279: PUSH
103280: LD_VAR 0 30
103284: IN
103285: NOT
103286: AND
103287: IFFALSE 103311
// to_heal := to_heal union group [ i ] ;
103289: LD_ADDR_VAR 0 30
103293: PUSH
103294: LD_VAR 0 30
103298: PUSH
103299: LD_VAR 0 4
103303: PUSH
103304: LD_VAR 0 7
103308: ARRAY
103309: UNION
103310: ST_TO_ADDR
// if group [ i ] in to_heal then
103311: LD_VAR 0 4
103315: PUSH
103316: LD_VAR 0 7
103320: ARRAY
103321: PUSH
103322: LD_VAR 0 30
103326: IN
103327: IFFALSE 103436
// begin if GetLives ( group [ i ] ) = 1000 then
103329: LD_VAR 0 4
103333: PUSH
103334: LD_VAR 0 7
103338: ARRAY
103339: PPUSH
103340: CALL_OW 256
103344: PUSH
103345: LD_INT 1000
103347: EQUAL
103348: IFFALSE 103374
// to_heal := to_heal diff group [ i ] else
103350: LD_ADDR_VAR 0 30
103354: PUSH
103355: LD_VAR 0 30
103359: PUSH
103360: LD_VAR 0 4
103364: PUSH
103365: LD_VAR 0 7
103369: ARRAY
103370: DIFF
103371: ST_TO_ADDR
103372: GO 103436
// begin if not IsInArea ( group [ i ] , to_heal ) then
103374: LD_VAR 0 4
103378: PUSH
103379: LD_VAR 0 7
103383: ARRAY
103384: PPUSH
103385: LD_VAR 0 30
103389: PPUSH
103390: CALL_OW 308
103394: NOT
103395: IFFALSE 103419
// ComMoveToArea ( group [ i ] , f_heal ) else
103397: LD_VAR 0 4
103401: PUSH
103402: LD_VAR 0 7
103406: ARRAY
103407: PPUSH
103408: LD_VAR 0 23
103412: PPUSH
103413: CALL_OW 113
103417: GO 103434
// ComHold ( group [ i ] ) ;
103419: LD_VAR 0 4
103423: PUSH
103424: LD_VAR 0 7
103428: ARRAY
103429: PPUSH
103430: CALL_OW 140
// continue ;
103434: GO 102278
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
103436: LD_VAR 0 4
103440: PUSH
103441: LD_VAR 0 7
103445: ARRAY
103446: PPUSH
103447: LD_INT 10
103449: PPUSH
103450: CALL 46088 0 2
103454: NOT
103455: PUSH
103456: LD_VAR 0 16
103460: PUSH
103461: LD_VAR 0 7
103465: ARRAY
103466: PUSH
103467: EMPTY
103468: EQUAL
103469: NOT
103470: AND
103471: IFFALSE 103737
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
103473: LD_VAR 0 4
103477: PUSH
103478: LD_VAR 0 7
103482: ARRAY
103483: PPUSH
103484: CALL_OW 262
103488: PUSH
103489: LD_INT 1
103491: PUSH
103492: LD_INT 2
103494: PUSH
103495: EMPTY
103496: LIST
103497: LIST
103498: IN
103499: IFFALSE 103540
// if GetFuel ( group [ i ] ) < 10 then
103501: LD_VAR 0 4
103505: PUSH
103506: LD_VAR 0 7
103510: ARRAY
103511: PPUSH
103512: CALL_OW 261
103516: PUSH
103517: LD_INT 10
103519: LESS
103520: IFFALSE 103540
// SetFuel ( group [ i ] , 12 ) ;
103522: LD_VAR 0 4
103526: PUSH
103527: LD_VAR 0 7
103531: ARRAY
103532: PPUSH
103533: LD_INT 12
103535: PPUSH
103536: CALL_OW 240
// if units_path [ i ] then
103540: LD_VAR 0 16
103544: PUSH
103545: LD_VAR 0 7
103549: ARRAY
103550: IFFALSE 103735
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
103552: LD_VAR 0 4
103556: PUSH
103557: LD_VAR 0 7
103561: ARRAY
103562: PPUSH
103563: LD_VAR 0 16
103567: PUSH
103568: LD_VAR 0 7
103572: ARRAY
103573: PUSH
103574: LD_INT 1
103576: ARRAY
103577: PUSH
103578: LD_INT 1
103580: ARRAY
103581: PPUSH
103582: LD_VAR 0 16
103586: PUSH
103587: LD_VAR 0 7
103591: ARRAY
103592: PUSH
103593: LD_INT 1
103595: ARRAY
103596: PUSH
103597: LD_INT 2
103599: ARRAY
103600: PPUSH
103601: CALL_OW 297
103605: PUSH
103606: LD_INT 6
103608: GREATER
103609: IFFALSE 103684
// begin if not HasTask ( group [ i ] ) then
103611: LD_VAR 0 4
103615: PUSH
103616: LD_VAR 0 7
103620: ARRAY
103621: PPUSH
103622: CALL_OW 314
103626: NOT
103627: IFFALSE 103682
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
103629: LD_VAR 0 4
103633: PUSH
103634: LD_VAR 0 7
103638: ARRAY
103639: PPUSH
103640: LD_VAR 0 16
103644: PUSH
103645: LD_VAR 0 7
103649: ARRAY
103650: PUSH
103651: LD_INT 1
103653: ARRAY
103654: PUSH
103655: LD_INT 1
103657: ARRAY
103658: PPUSH
103659: LD_VAR 0 16
103663: PUSH
103664: LD_VAR 0 7
103668: ARRAY
103669: PUSH
103670: LD_INT 1
103672: ARRAY
103673: PUSH
103674: LD_INT 2
103676: ARRAY
103677: PPUSH
103678: CALL_OW 114
// end else
103682: GO 103735
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
103684: LD_ADDR_VAR 0 15
103688: PUSH
103689: LD_VAR 0 16
103693: PUSH
103694: LD_VAR 0 7
103698: ARRAY
103699: PPUSH
103700: LD_INT 1
103702: PPUSH
103703: CALL_OW 3
103707: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
103708: LD_ADDR_VAR 0 16
103712: PUSH
103713: LD_VAR 0 16
103717: PPUSH
103718: LD_VAR 0 7
103722: PPUSH
103723: LD_VAR 0 15
103727: PPUSH
103728: CALL_OW 1
103732: ST_TO_ADDR
// continue ;
103733: GO 102278
// end ; end ; end else
103735: GO 106399
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
103737: LD_ADDR_VAR 0 14
103741: PUSH
103742: LD_INT 81
103744: PUSH
103745: LD_VAR 0 4
103749: PUSH
103750: LD_VAR 0 7
103754: ARRAY
103755: PPUSH
103756: CALL_OW 255
103760: PUSH
103761: EMPTY
103762: LIST
103763: LIST
103764: PPUSH
103765: CALL_OW 69
103769: ST_TO_ADDR
// if not tmp then
103770: LD_VAR 0 14
103774: NOT
103775: IFFALSE 103779
// continue ;
103777: GO 102278
// if f_ignore_area then
103779: LD_VAR 0 17
103783: IFFALSE 103871
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
103785: LD_ADDR_VAR 0 15
103789: PUSH
103790: LD_VAR 0 14
103794: PPUSH
103795: LD_INT 3
103797: PUSH
103798: LD_INT 92
103800: PUSH
103801: LD_VAR 0 17
103805: PUSH
103806: LD_INT 1
103808: ARRAY
103809: PUSH
103810: LD_VAR 0 17
103814: PUSH
103815: LD_INT 2
103817: ARRAY
103818: PUSH
103819: LD_VAR 0 17
103823: PUSH
103824: LD_INT 3
103826: ARRAY
103827: PUSH
103828: EMPTY
103829: LIST
103830: LIST
103831: LIST
103832: LIST
103833: PUSH
103834: EMPTY
103835: LIST
103836: LIST
103837: PPUSH
103838: CALL_OW 72
103842: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
103843: LD_VAR 0 14
103847: PUSH
103848: LD_VAR 0 15
103852: DIFF
103853: IFFALSE 103871
// tmp := tmp diff tmp2 ;
103855: LD_ADDR_VAR 0 14
103859: PUSH
103860: LD_VAR 0 14
103864: PUSH
103865: LD_VAR 0 15
103869: DIFF
103870: ST_TO_ADDR
// end ; if not f_murder then
103871: LD_VAR 0 20
103875: NOT
103876: IFFALSE 103934
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
103878: LD_ADDR_VAR 0 15
103882: PUSH
103883: LD_VAR 0 14
103887: PPUSH
103888: LD_INT 3
103890: PUSH
103891: LD_INT 50
103893: PUSH
103894: EMPTY
103895: LIST
103896: PUSH
103897: EMPTY
103898: LIST
103899: LIST
103900: PPUSH
103901: CALL_OW 72
103905: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
103906: LD_VAR 0 14
103910: PUSH
103911: LD_VAR 0 15
103915: DIFF
103916: IFFALSE 103934
// tmp := tmp diff tmp2 ;
103918: LD_ADDR_VAR 0 14
103922: PUSH
103923: LD_VAR 0 14
103927: PUSH
103928: LD_VAR 0 15
103932: DIFF
103933: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
103934: LD_ADDR_VAR 0 14
103938: PUSH
103939: LD_VAR 0 4
103943: PUSH
103944: LD_VAR 0 7
103948: ARRAY
103949: PPUSH
103950: LD_VAR 0 14
103954: PPUSH
103955: LD_INT 1
103957: PPUSH
103958: LD_INT 1
103960: PPUSH
103961: CALL 19023 0 4
103965: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
103966: LD_VAR 0 4
103970: PUSH
103971: LD_VAR 0 7
103975: ARRAY
103976: PPUSH
103977: CALL_OW 257
103981: PUSH
103982: LD_INT 1
103984: EQUAL
103985: IFFALSE 104433
// begin if WantPlant ( group [ i ] ) then
103987: LD_VAR 0 4
103991: PUSH
103992: LD_VAR 0 7
103996: ARRAY
103997: PPUSH
103998: CALL 18524 0 1
104002: IFFALSE 104006
// continue ;
104004: GO 102278
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
104006: LD_VAR 0 18
104010: PUSH
104011: LD_VAR 0 4
104015: PUSH
104016: LD_VAR 0 7
104020: ARRAY
104021: PPUSH
104022: CALL_OW 310
104026: NOT
104027: AND
104028: PUSH
104029: LD_VAR 0 14
104033: PUSH
104034: LD_INT 1
104036: ARRAY
104037: PUSH
104038: LD_VAR 0 14
104042: PPUSH
104043: LD_INT 21
104045: PUSH
104046: LD_INT 2
104048: PUSH
104049: EMPTY
104050: LIST
104051: LIST
104052: PUSH
104053: LD_INT 58
104055: PUSH
104056: EMPTY
104057: LIST
104058: PUSH
104059: EMPTY
104060: LIST
104061: LIST
104062: PPUSH
104063: CALL_OW 72
104067: IN
104068: AND
104069: IFFALSE 104105
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
104071: LD_VAR 0 4
104075: PUSH
104076: LD_VAR 0 7
104080: ARRAY
104081: PPUSH
104082: LD_VAR 0 14
104086: PUSH
104087: LD_INT 1
104089: ARRAY
104090: PPUSH
104091: CALL_OW 120
// attacking := true ;
104095: LD_ADDR_VAR 0 29
104099: PUSH
104100: LD_INT 1
104102: ST_TO_ADDR
// continue ;
104103: GO 102278
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
104105: LD_VAR 0 26
104109: PUSH
104110: LD_VAR 0 4
104114: PUSH
104115: LD_VAR 0 7
104119: ARRAY
104120: PPUSH
104121: CALL_OW 257
104125: PUSH
104126: LD_INT 1
104128: EQUAL
104129: AND
104130: PUSH
104131: LD_VAR 0 4
104135: PUSH
104136: LD_VAR 0 7
104140: ARRAY
104141: PPUSH
104142: CALL_OW 256
104146: PUSH
104147: LD_INT 800
104149: LESS
104150: AND
104151: PUSH
104152: LD_VAR 0 4
104156: PUSH
104157: LD_VAR 0 7
104161: ARRAY
104162: PPUSH
104163: CALL_OW 318
104167: NOT
104168: AND
104169: IFFALSE 104186
// ComCrawl ( group [ i ] ) ;
104171: LD_VAR 0 4
104175: PUSH
104176: LD_VAR 0 7
104180: ARRAY
104181: PPUSH
104182: CALL_OW 137
// if f_mines then
104186: LD_VAR 0 21
104190: IFFALSE 104433
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
104192: LD_VAR 0 14
104196: PUSH
104197: LD_INT 1
104199: ARRAY
104200: PPUSH
104201: CALL_OW 247
104205: PUSH
104206: LD_INT 3
104208: EQUAL
104209: PUSH
104210: LD_VAR 0 14
104214: PUSH
104215: LD_INT 1
104217: ARRAY
104218: PUSH
104219: LD_VAR 0 27
104223: IN
104224: NOT
104225: AND
104226: IFFALSE 104433
// begin x := GetX ( tmp [ 1 ] ) ;
104228: LD_ADDR_VAR 0 10
104232: PUSH
104233: LD_VAR 0 14
104237: PUSH
104238: LD_INT 1
104240: ARRAY
104241: PPUSH
104242: CALL_OW 250
104246: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
104247: LD_ADDR_VAR 0 11
104251: PUSH
104252: LD_VAR 0 14
104256: PUSH
104257: LD_INT 1
104259: ARRAY
104260: PPUSH
104261: CALL_OW 251
104265: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
104266: LD_ADDR_VAR 0 12
104270: PUSH
104271: LD_VAR 0 4
104275: PUSH
104276: LD_VAR 0 7
104280: ARRAY
104281: PPUSH
104282: CALL 46173 0 1
104286: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
104287: LD_VAR 0 4
104291: PUSH
104292: LD_VAR 0 7
104296: ARRAY
104297: PPUSH
104298: LD_VAR 0 10
104302: PPUSH
104303: LD_VAR 0 11
104307: PPUSH
104308: LD_VAR 0 14
104312: PUSH
104313: LD_INT 1
104315: ARRAY
104316: PPUSH
104317: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
104321: LD_VAR 0 4
104325: PUSH
104326: LD_VAR 0 7
104330: ARRAY
104331: PPUSH
104332: LD_VAR 0 10
104336: PPUSH
104337: LD_VAR 0 12
104341: PPUSH
104342: LD_INT 7
104344: PPUSH
104345: CALL_OW 272
104349: PPUSH
104350: LD_VAR 0 11
104354: PPUSH
104355: LD_VAR 0 12
104359: PPUSH
104360: LD_INT 7
104362: PPUSH
104363: CALL_OW 273
104367: PPUSH
104368: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
104372: LD_VAR 0 4
104376: PUSH
104377: LD_VAR 0 7
104381: ARRAY
104382: PPUSH
104383: LD_INT 71
104385: PPUSH
104386: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
104390: LD_ADDR_VAR 0 27
104394: PUSH
104395: LD_VAR 0 27
104399: PPUSH
104400: LD_VAR 0 27
104404: PUSH
104405: LD_INT 1
104407: PLUS
104408: PPUSH
104409: LD_VAR 0 14
104413: PUSH
104414: LD_INT 1
104416: ARRAY
104417: PPUSH
104418: CALL_OW 1
104422: ST_TO_ADDR
// attacking := true ;
104423: LD_ADDR_VAR 0 29
104427: PUSH
104428: LD_INT 1
104430: ST_TO_ADDR
// continue ;
104431: GO 102278
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
104433: LD_VAR 0 4
104437: PUSH
104438: LD_VAR 0 7
104442: ARRAY
104443: PPUSH
104444: CALL_OW 257
104448: PUSH
104449: LD_INT 17
104451: EQUAL
104452: PUSH
104453: LD_VAR 0 4
104457: PUSH
104458: LD_VAR 0 7
104462: ARRAY
104463: PPUSH
104464: CALL_OW 110
104468: PUSH
104469: LD_INT 71
104471: EQUAL
104472: NOT
104473: AND
104474: IFFALSE 104620
// begin attacking := false ;
104476: LD_ADDR_VAR 0 29
104480: PUSH
104481: LD_INT 0
104483: ST_TO_ADDR
// k := 5 ;
104484: LD_ADDR_VAR 0 9
104488: PUSH
104489: LD_INT 5
104491: ST_TO_ADDR
// if tmp < k then
104492: LD_VAR 0 14
104496: PUSH
104497: LD_VAR 0 9
104501: LESS
104502: IFFALSE 104514
// k := tmp ;
104504: LD_ADDR_VAR 0 9
104508: PUSH
104509: LD_VAR 0 14
104513: ST_TO_ADDR
// for j = 1 to k do
104514: LD_ADDR_VAR 0 8
104518: PUSH
104519: DOUBLE
104520: LD_INT 1
104522: DEC
104523: ST_TO_ADDR
104524: LD_VAR 0 9
104528: PUSH
104529: FOR_TO
104530: IFFALSE 104618
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
104532: LD_VAR 0 14
104536: PUSH
104537: LD_VAR 0 8
104541: ARRAY
104542: PUSH
104543: LD_VAR 0 14
104547: PPUSH
104548: LD_INT 58
104550: PUSH
104551: EMPTY
104552: LIST
104553: PPUSH
104554: CALL_OW 72
104558: IN
104559: NOT
104560: IFFALSE 104616
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104562: LD_VAR 0 4
104566: PUSH
104567: LD_VAR 0 7
104571: ARRAY
104572: PPUSH
104573: LD_VAR 0 14
104577: PUSH
104578: LD_VAR 0 8
104582: ARRAY
104583: PPUSH
104584: CALL_OW 115
// attacking := true ;
104588: LD_ADDR_VAR 0 29
104592: PUSH
104593: LD_INT 1
104595: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
104596: LD_VAR 0 4
104600: PUSH
104601: LD_VAR 0 7
104605: ARRAY
104606: PPUSH
104607: LD_INT 71
104609: PPUSH
104610: CALL_OW 109
// continue ;
104614: GO 104529
// end ; end ;
104616: GO 104529
104618: POP
104619: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
104620: LD_VAR 0 4
104624: PUSH
104625: LD_VAR 0 7
104629: ARRAY
104630: PPUSH
104631: CALL_OW 257
104635: PUSH
104636: LD_INT 8
104638: EQUAL
104639: PUSH
104640: LD_VAR 0 4
104644: PUSH
104645: LD_VAR 0 7
104649: ARRAY
104650: PPUSH
104651: CALL_OW 264
104655: PUSH
104656: LD_INT 28
104658: PUSH
104659: LD_INT 45
104661: PUSH
104662: LD_INT 7
104664: PUSH
104665: LD_INT 47
104667: PUSH
104668: EMPTY
104669: LIST
104670: LIST
104671: LIST
104672: LIST
104673: IN
104674: OR
104675: IFFALSE 104931
// begin attacking := false ;
104677: LD_ADDR_VAR 0 29
104681: PUSH
104682: LD_INT 0
104684: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
104685: LD_VAR 0 14
104689: PUSH
104690: LD_INT 1
104692: ARRAY
104693: PPUSH
104694: CALL_OW 266
104698: PUSH
104699: LD_INT 32
104701: PUSH
104702: LD_INT 31
104704: PUSH
104705: LD_INT 33
104707: PUSH
104708: LD_INT 4
104710: PUSH
104711: LD_INT 5
104713: PUSH
104714: EMPTY
104715: LIST
104716: LIST
104717: LIST
104718: LIST
104719: LIST
104720: IN
104721: IFFALSE 104907
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
104723: LD_ADDR_VAR 0 9
104727: PUSH
104728: LD_VAR 0 14
104732: PUSH
104733: LD_INT 1
104735: ARRAY
104736: PPUSH
104737: CALL_OW 266
104741: PPUSH
104742: LD_VAR 0 14
104746: PUSH
104747: LD_INT 1
104749: ARRAY
104750: PPUSH
104751: CALL_OW 250
104755: PPUSH
104756: LD_VAR 0 14
104760: PUSH
104761: LD_INT 1
104763: ARRAY
104764: PPUSH
104765: CALL_OW 251
104769: PPUSH
104770: LD_VAR 0 14
104774: PUSH
104775: LD_INT 1
104777: ARRAY
104778: PPUSH
104779: CALL_OW 254
104783: PPUSH
104784: LD_VAR 0 14
104788: PUSH
104789: LD_INT 1
104791: ARRAY
104792: PPUSH
104793: CALL_OW 248
104797: PPUSH
104798: LD_INT 0
104800: PPUSH
104801: CALL 27543 0 6
104805: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
104806: LD_ADDR_VAR 0 8
104810: PUSH
104811: LD_VAR 0 4
104815: PUSH
104816: LD_VAR 0 7
104820: ARRAY
104821: PPUSH
104822: LD_VAR 0 9
104826: PPUSH
104827: CALL 46213 0 2
104831: ST_TO_ADDR
// if j then
104832: LD_VAR 0 8
104836: IFFALSE 104905
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
104838: LD_VAR 0 8
104842: PUSH
104843: LD_INT 1
104845: ARRAY
104846: PPUSH
104847: LD_VAR 0 8
104851: PUSH
104852: LD_INT 2
104854: ARRAY
104855: PPUSH
104856: CALL_OW 488
104860: IFFALSE 104905
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
104862: LD_VAR 0 4
104866: PUSH
104867: LD_VAR 0 7
104871: ARRAY
104872: PPUSH
104873: LD_VAR 0 8
104877: PUSH
104878: LD_INT 1
104880: ARRAY
104881: PPUSH
104882: LD_VAR 0 8
104886: PUSH
104887: LD_INT 2
104889: ARRAY
104890: PPUSH
104891: CALL_OW 116
// attacking := true ;
104895: LD_ADDR_VAR 0 29
104899: PUSH
104900: LD_INT 1
104902: ST_TO_ADDR
// continue ;
104903: GO 102278
// end ; end else
104905: GO 104931
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104907: LD_VAR 0 4
104911: PUSH
104912: LD_VAR 0 7
104916: ARRAY
104917: PPUSH
104918: LD_VAR 0 14
104922: PUSH
104923: LD_INT 1
104925: ARRAY
104926: PPUSH
104927: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
104931: LD_VAR 0 4
104935: PUSH
104936: LD_VAR 0 7
104940: ARRAY
104941: PPUSH
104942: CALL_OW 265
104946: PUSH
104947: LD_INT 11
104949: EQUAL
104950: IFFALSE 105228
// begin k := 10 ;
104952: LD_ADDR_VAR 0 9
104956: PUSH
104957: LD_INT 10
104959: ST_TO_ADDR
// x := 0 ;
104960: LD_ADDR_VAR 0 10
104964: PUSH
104965: LD_INT 0
104967: ST_TO_ADDR
// if tmp < k then
104968: LD_VAR 0 14
104972: PUSH
104973: LD_VAR 0 9
104977: LESS
104978: IFFALSE 104990
// k := tmp ;
104980: LD_ADDR_VAR 0 9
104984: PUSH
104985: LD_VAR 0 14
104989: ST_TO_ADDR
// for j = k downto 1 do
104990: LD_ADDR_VAR 0 8
104994: PUSH
104995: DOUBLE
104996: LD_VAR 0 9
105000: INC
105001: ST_TO_ADDR
105002: LD_INT 1
105004: PUSH
105005: FOR_DOWNTO
105006: IFFALSE 105081
// begin if GetType ( tmp [ j ] ) = unit_human then
105008: LD_VAR 0 14
105012: PUSH
105013: LD_VAR 0 8
105017: ARRAY
105018: PPUSH
105019: CALL_OW 247
105023: PUSH
105024: LD_INT 1
105026: EQUAL
105027: IFFALSE 105079
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
105029: LD_VAR 0 4
105033: PUSH
105034: LD_VAR 0 7
105038: ARRAY
105039: PPUSH
105040: LD_VAR 0 14
105044: PUSH
105045: LD_VAR 0 8
105049: ARRAY
105050: PPUSH
105051: CALL 46484 0 2
// x := tmp [ j ] ;
105055: LD_ADDR_VAR 0 10
105059: PUSH
105060: LD_VAR 0 14
105064: PUSH
105065: LD_VAR 0 8
105069: ARRAY
105070: ST_TO_ADDR
// attacking := true ;
105071: LD_ADDR_VAR 0 29
105075: PUSH
105076: LD_INT 1
105078: ST_TO_ADDR
// end ; end ;
105079: GO 105005
105081: POP
105082: POP
// if not x then
105083: LD_VAR 0 10
105087: NOT
105088: IFFALSE 105228
// begin attacking := true ;
105090: LD_ADDR_VAR 0 29
105094: PUSH
105095: LD_INT 1
105097: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
105098: LD_VAR 0 4
105102: PUSH
105103: LD_VAR 0 7
105107: ARRAY
105108: PPUSH
105109: CALL_OW 250
105113: PPUSH
105114: LD_VAR 0 4
105118: PUSH
105119: LD_VAR 0 7
105123: ARRAY
105124: PPUSH
105125: CALL_OW 251
105129: PPUSH
105130: CALL_OW 546
105134: PUSH
105135: LD_INT 2
105137: ARRAY
105138: PUSH
105139: LD_VAR 0 14
105143: PUSH
105144: LD_INT 1
105146: ARRAY
105147: PPUSH
105148: CALL_OW 250
105152: PPUSH
105153: LD_VAR 0 14
105157: PUSH
105158: LD_INT 1
105160: ARRAY
105161: PPUSH
105162: CALL_OW 251
105166: PPUSH
105167: CALL_OW 546
105171: PUSH
105172: LD_INT 2
105174: ARRAY
105175: EQUAL
105176: IFFALSE 105204
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
105178: LD_VAR 0 4
105182: PUSH
105183: LD_VAR 0 7
105187: ARRAY
105188: PPUSH
105189: LD_VAR 0 14
105193: PUSH
105194: LD_INT 1
105196: ARRAY
105197: PPUSH
105198: CALL 46484 0 2
105202: GO 105228
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105204: LD_VAR 0 4
105208: PUSH
105209: LD_VAR 0 7
105213: ARRAY
105214: PPUSH
105215: LD_VAR 0 14
105219: PUSH
105220: LD_INT 1
105222: ARRAY
105223: PPUSH
105224: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
105228: LD_VAR 0 4
105232: PUSH
105233: LD_VAR 0 7
105237: ARRAY
105238: PPUSH
105239: CALL_OW 264
105243: PUSH
105244: LD_INT 29
105246: EQUAL
105247: IFFALSE 105613
// begin if WantsToAttack ( group [ i ] ) in bombed then
105249: LD_VAR 0 4
105253: PUSH
105254: LD_VAR 0 7
105258: ARRAY
105259: PPUSH
105260: CALL_OW 319
105264: PUSH
105265: LD_VAR 0 28
105269: IN
105270: IFFALSE 105274
// continue ;
105272: GO 102278
// k := 8 ;
105274: LD_ADDR_VAR 0 9
105278: PUSH
105279: LD_INT 8
105281: ST_TO_ADDR
// x := 0 ;
105282: LD_ADDR_VAR 0 10
105286: PUSH
105287: LD_INT 0
105289: ST_TO_ADDR
// if tmp < k then
105290: LD_VAR 0 14
105294: PUSH
105295: LD_VAR 0 9
105299: LESS
105300: IFFALSE 105312
// k := tmp ;
105302: LD_ADDR_VAR 0 9
105306: PUSH
105307: LD_VAR 0 14
105311: ST_TO_ADDR
// for j = 1 to k do
105312: LD_ADDR_VAR 0 8
105316: PUSH
105317: DOUBLE
105318: LD_INT 1
105320: DEC
105321: ST_TO_ADDR
105322: LD_VAR 0 9
105326: PUSH
105327: FOR_TO
105328: IFFALSE 105460
// begin if GetType ( tmp [ j ] ) = unit_building then
105330: LD_VAR 0 14
105334: PUSH
105335: LD_VAR 0 8
105339: ARRAY
105340: PPUSH
105341: CALL_OW 247
105345: PUSH
105346: LD_INT 3
105348: EQUAL
105349: IFFALSE 105458
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
105351: LD_VAR 0 14
105355: PUSH
105356: LD_VAR 0 8
105360: ARRAY
105361: PUSH
105362: LD_VAR 0 28
105366: IN
105367: NOT
105368: PUSH
105369: LD_VAR 0 14
105373: PUSH
105374: LD_VAR 0 8
105378: ARRAY
105379: PPUSH
105380: CALL_OW 313
105384: AND
105385: IFFALSE 105458
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105387: LD_VAR 0 4
105391: PUSH
105392: LD_VAR 0 7
105396: ARRAY
105397: PPUSH
105398: LD_VAR 0 14
105402: PUSH
105403: LD_VAR 0 8
105407: ARRAY
105408: PPUSH
105409: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
105413: LD_ADDR_VAR 0 28
105417: PUSH
105418: LD_VAR 0 28
105422: PPUSH
105423: LD_VAR 0 28
105427: PUSH
105428: LD_INT 1
105430: PLUS
105431: PPUSH
105432: LD_VAR 0 14
105436: PUSH
105437: LD_VAR 0 8
105441: ARRAY
105442: PPUSH
105443: CALL_OW 1
105447: ST_TO_ADDR
// attacking := true ;
105448: LD_ADDR_VAR 0 29
105452: PUSH
105453: LD_INT 1
105455: ST_TO_ADDR
// break ;
105456: GO 105460
// end ; end ;
105458: GO 105327
105460: POP
105461: POP
// if not attacking and f_attack_depot then
105462: LD_VAR 0 29
105466: NOT
105467: PUSH
105468: LD_VAR 0 25
105472: AND
105473: IFFALSE 105568
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
105475: LD_ADDR_VAR 0 13
105479: PUSH
105480: LD_VAR 0 14
105484: PPUSH
105485: LD_INT 2
105487: PUSH
105488: LD_INT 30
105490: PUSH
105491: LD_INT 0
105493: PUSH
105494: EMPTY
105495: LIST
105496: LIST
105497: PUSH
105498: LD_INT 30
105500: PUSH
105501: LD_INT 1
105503: PUSH
105504: EMPTY
105505: LIST
105506: LIST
105507: PUSH
105508: EMPTY
105509: LIST
105510: LIST
105511: LIST
105512: PPUSH
105513: CALL_OW 72
105517: ST_TO_ADDR
// if z then
105518: LD_VAR 0 13
105522: IFFALSE 105568
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
105524: LD_VAR 0 4
105528: PUSH
105529: LD_VAR 0 7
105533: ARRAY
105534: PPUSH
105535: LD_VAR 0 13
105539: PPUSH
105540: LD_VAR 0 4
105544: PUSH
105545: LD_VAR 0 7
105549: ARRAY
105550: PPUSH
105551: CALL_OW 74
105555: PPUSH
105556: CALL_OW 115
// attacking := true ;
105560: LD_ADDR_VAR 0 29
105564: PUSH
105565: LD_INT 1
105567: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
105568: LD_VAR 0 4
105572: PUSH
105573: LD_VAR 0 7
105577: ARRAY
105578: PPUSH
105579: CALL_OW 256
105583: PUSH
105584: LD_INT 500
105586: LESS
105587: IFFALSE 105613
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105589: LD_VAR 0 4
105593: PUSH
105594: LD_VAR 0 7
105598: ARRAY
105599: PPUSH
105600: LD_VAR 0 14
105604: PUSH
105605: LD_INT 1
105607: ARRAY
105608: PPUSH
105609: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
105613: LD_VAR 0 4
105617: PUSH
105618: LD_VAR 0 7
105622: ARRAY
105623: PPUSH
105624: CALL_OW 264
105628: PUSH
105629: LD_INT 49
105631: EQUAL
105632: IFFALSE 105753
// begin if not HasTask ( group [ i ] ) then
105634: LD_VAR 0 4
105638: PUSH
105639: LD_VAR 0 7
105643: ARRAY
105644: PPUSH
105645: CALL_OW 314
105649: NOT
105650: IFFALSE 105753
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
105652: LD_ADDR_VAR 0 9
105656: PUSH
105657: LD_INT 81
105659: PUSH
105660: LD_VAR 0 4
105664: PUSH
105665: LD_VAR 0 7
105669: ARRAY
105670: PPUSH
105671: CALL_OW 255
105675: PUSH
105676: EMPTY
105677: LIST
105678: LIST
105679: PPUSH
105680: CALL_OW 69
105684: PPUSH
105685: LD_VAR 0 4
105689: PUSH
105690: LD_VAR 0 7
105694: ARRAY
105695: PPUSH
105696: CALL_OW 74
105700: ST_TO_ADDR
// if k then
105701: LD_VAR 0 9
105705: IFFALSE 105753
// if GetDistUnits ( group [ i ] , k ) > 10 then
105707: LD_VAR 0 4
105711: PUSH
105712: LD_VAR 0 7
105716: ARRAY
105717: PPUSH
105718: LD_VAR 0 9
105722: PPUSH
105723: CALL_OW 296
105727: PUSH
105728: LD_INT 10
105730: GREATER
105731: IFFALSE 105753
// ComMoveUnit ( group [ i ] , k ) ;
105733: LD_VAR 0 4
105737: PUSH
105738: LD_VAR 0 7
105742: ARRAY
105743: PPUSH
105744: LD_VAR 0 9
105748: PPUSH
105749: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
105753: LD_VAR 0 4
105757: PUSH
105758: LD_VAR 0 7
105762: ARRAY
105763: PPUSH
105764: CALL_OW 256
105768: PUSH
105769: LD_INT 250
105771: LESS
105772: PUSH
105773: LD_VAR 0 4
105777: PUSH
105778: LD_VAR 0 7
105782: ARRAY
105783: PUSH
105784: LD_INT 21
105786: PUSH
105787: LD_INT 2
105789: PUSH
105790: EMPTY
105791: LIST
105792: LIST
105793: PUSH
105794: LD_INT 23
105796: PUSH
105797: LD_INT 2
105799: PUSH
105800: EMPTY
105801: LIST
105802: LIST
105803: PUSH
105804: EMPTY
105805: LIST
105806: LIST
105807: PPUSH
105808: CALL_OW 69
105812: IN
105813: AND
105814: IFFALSE 105939
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
105816: LD_ADDR_VAR 0 9
105820: PUSH
105821: LD_OWVAR 3
105825: PUSH
105826: LD_VAR 0 4
105830: PUSH
105831: LD_VAR 0 7
105835: ARRAY
105836: DIFF
105837: PPUSH
105838: LD_VAR 0 4
105842: PUSH
105843: LD_VAR 0 7
105847: ARRAY
105848: PPUSH
105849: CALL_OW 74
105853: ST_TO_ADDR
// if not k then
105854: LD_VAR 0 9
105858: NOT
105859: IFFALSE 105863
// continue ;
105861: GO 102278
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
105863: LD_VAR 0 9
105867: PUSH
105868: LD_INT 81
105870: PUSH
105871: LD_VAR 0 4
105875: PUSH
105876: LD_VAR 0 7
105880: ARRAY
105881: PPUSH
105882: CALL_OW 255
105886: PUSH
105887: EMPTY
105888: LIST
105889: LIST
105890: PPUSH
105891: CALL_OW 69
105895: IN
105896: PUSH
105897: LD_VAR 0 9
105901: PPUSH
105902: LD_VAR 0 4
105906: PUSH
105907: LD_VAR 0 7
105911: ARRAY
105912: PPUSH
105913: CALL_OW 296
105917: PUSH
105918: LD_INT 5
105920: LESS
105921: AND
105922: IFFALSE 105939
// ComAutodestruct ( group [ i ] ) ;
105924: LD_VAR 0 4
105928: PUSH
105929: LD_VAR 0 7
105933: ARRAY
105934: PPUSH
105935: CALL 46382 0 1
// end ; if f_attack_depot then
105939: LD_VAR 0 25
105943: IFFALSE 106055
// begin k := 6 ;
105945: LD_ADDR_VAR 0 9
105949: PUSH
105950: LD_INT 6
105952: ST_TO_ADDR
// if tmp < k then
105953: LD_VAR 0 14
105957: PUSH
105958: LD_VAR 0 9
105962: LESS
105963: IFFALSE 105975
// k := tmp ;
105965: LD_ADDR_VAR 0 9
105969: PUSH
105970: LD_VAR 0 14
105974: ST_TO_ADDR
// for j = 1 to k do
105975: LD_ADDR_VAR 0 8
105979: PUSH
105980: DOUBLE
105981: LD_INT 1
105983: DEC
105984: ST_TO_ADDR
105985: LD_VAR 0 9
105989: PUSH
105990: FOR_TO
105991: IFFALSE 106053
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
105993: LD_VAR 0 8
105997: PPUSH
105998: CALL_OW 266
106002: PUSH
106003: LD_INT 0
106005: PUSH
106006: LD_INT 1
106008: PUSH
106009: EMPTY
106010: LIST
106011: LIST
106012: IN
106013: IFFALSE 106051
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
106015: LD_VAR 0 4
106019: PUSH
106020: LD_VAR 0 7
106024: ARRAY
106025: PPUSH
106026: LD_VAR 0 14
106030: PUSH
106031: LD_VAR 0 8
106035: ARRAY
106036: PPUSH
106037: CALL_OW 115
// attacking := true ;
106041: LD_ADDR_VAR 0 29
106045: PUSH
106046: LD_INT 1
106048: ST_TO_ADDR
// break ;
106049: GO 106053
// end ;
106051: GO 105990
106053: POP
106054: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
106055: LD_VAR 0 4
106059: PUSH
106060: LD_VAR 0 7
106064: ARRAY
106065: PPUSH
106066: CALL_OW 302
106070: PUSH
106071: LD_VAR 0 29
106075: NOT
106076: AND
106077: IFFALSE 106399
// begin if GetTag ( group [ i ] ) = 71 then
106079: LD_VAR 0 4
106083: PUSH
106084: LD_VAR 0 7
106088: ARRAY
106089: PPUSH
106090: CALL_OW 110
106094: PUSH
106095: LD_INT 71
106097: EQUAL
106098: IFFALSE 106139
// begin if HasTask ( group [ i ] ) then
106100: LD_VAR 0 4
106104: PUSH
106105: LD_VAR 0 7
106109: ARRAY
106110: PPUSH
106111: CALL_OW 314
106115: IFFALSE 106121
// continue else
106117: GO 102278
106119: GO 106139
// SetTag ( group [ i ] , 0 ) ;
106121: LD_VAR 0 4
106125: PUSH
106126: LD_VAR 0 7
106130: ARRAY
106131: PPUSH
106132: LD_INT 0
106134: PPUSH
106135: CALL_OW 109
// end ; k := 8 ;
106139: LD_ADDR_VAR 0 9
106143: PUSH
106144: LD_INT 8
106146: ST_TO_ADDR
// x := 0 ;
106147: LD_ADDR_VAR 0 10
106151: PUSH
106152: LD_INT 0
106154: ST_TO_ADDR
// if tmp < k then
106155: LD_VAR 0 14
106159: PUSH
106160: LD_VAR 0 9
106164: LESS
106165: IFFALSE 106177
// k := tmp ;
106167: LD_ADDR_VAR 0 9
106171: PUSH
106172: LD_VAR 0 14
106176: ST_TO_ADDR
// for j = 1 to k do
106177: LD_ADDR_VAR 0 8
106181: PUSH
106182: DOUBLE
106183: LD_INT 1
106185: DEC
106186: ST_TO_ADDR
106187: LD_VAR 0 9
106191: PUSH
106192: FOR_TO
106193: IFFALSE 106291
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
106195: LD_VAR 0 14
106199: PUSH
106200: LD_VAR 0 8
106204: ARRAY
106205: PPUSH
106206: CALL_OW 247
106210: PUSH
106211: LD_INT 1
106213: EQUAL
106214: PUSH
106215: LD_VAR 0 14
106219: PUSH
106220: LD_VAR 0 8
106224: ARRAY
106225: PPUSH
106226: CALL_OW 256
106230: PUSH
106231: LD_INT 250
106233: LESS
106234: PUSH
106235: LD_VAR 0 20
106239: AND
106240: PUSH
106241: LD_VAR 0 20
106245: NOT
106246: PUSH
106247: LD_VAR 0 14
106251: PUSH
106252: LD_VAR 0 8
106256: ARRAY
106257: PPUSH
106258: CALL_OW 256
106262: PUSH
106263: LD_INT 250
106265: GREATEREQUAL
106266: AND
106267: OR
106268: AND
106269: IFFALSE 106289
// begin x := tmp [ j ] ;
106271: LD_ADDR_VAR 0 10
106275: PUSH
106276: LD_VAR 0 14
106280: PUSH
106281: LD_VAR 0 8
106285: ARRAY
106286: ST_TO_ADDR
// break ;
106287: GO 106291
// end ;
106289: GO 106192
106291: POP
106292: POP
// if x then
106293: LD_VAR 0 10
106297: IFFALSE 106321
// ComAttackUnit ( group [ i ] , x ) else
106299: LD_VAR 0 4
106303: PUSH
106304: LD_VAR 0 7
106308: ARRAY
106309: PPUSH
106310: LD_VAR 0 10
106314: PPUSH
106315: CALL_OW 115
106319: GO 106345
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106321: LD_VAR 0 4
106325: PUSH
106326: LD_VAR 0 7
106330: ARRAY
106331: PPUSH
106332: LD_VAR 0 14
106336: PUSH
106337: LD_INT 1
106339: ARRAY
106340: PPUSH
106341: CALL_OW 115
// if not HasTask ( group [ i ] ) then
106345: LD_VAR 0 4
106349: PUSH
106350: LD_VAR 0 7
106354: ARRAY
106355: PPUSH
106356: CALL_OW 314
106360: NOT
106361: IFFALSE 106399
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
106363: LD_VAR 0 4
106367: PUSH
106368: LD_VAR 0 7
106372: ARRAY
106373: PPUSH
106374: LD_VAR 0 14
106378: PPUSH
106379: LD_VAR 0 4
106383: PUSH
106384: LD_VAR 0 7
106388: ARRAY
106389: PPUSH
106390: CALL_OW 74
106394: PPUSH
106395: CALL_OW 115
// end ; end ; end ;
106399: GO 102278
106401: POP
106402: POP
// wait ( 0 0$2 ) ;
106403: LD_INT 70
106405: PPUSH
106406: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
106410: LD_VAR 0 4
106414: NOT
106415: PUSH
106416: LD_VAR 0 4
106420: PUSH
106421: EMPTY
106422: EQUAL
106423: OR
106424: PUSH
106425: LD_INT 81
106427: PUSH
106428: LD_VAR 0 35
106432: PUSH
106433: EMPTY
106434: LIST
106435: LIST
106436: PPUSH
106437: CALL_OW 69
106441: NOT
106442: OR
106443: IFFALSE 102263
// end ;
106445: LD_VAR 0 2
106449: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
106450: LD_INT 0
106452: PPUSH
106453: PPUSH
106454: PPUSH
106455: PPUSH
106456: PPUSH
106457: PPUSH
// if not base or not mc_bases [ base ] or not solds then
106458: LD_VAR 0 1
106462: NOT
106463: PUSH
106464: LD_EXP 69
106468: PUSH
106469: LD_VAR 0 1
106473: ARRAY
106474: NOT
106475: OR
106476: PUSH
106477: LD_VAR 0 2
106481: NOT
106482: OR
106483: IFFALSE 106487
// exit ;
106485: GO 107041
// side := mc_sides [ base ] ;
106487: LD_ADDR_VAR 0 6
106491: PUSH
106492: LD_EXP 95
106496: PUSH
106497: LD_VAR 0 1
106501: ARRAY
106502: ST_TO_ADDR
// if not side then
106503: LD_VAR 0 6
106507: NOT
106508: IFFALSE 106512
// exit ;
106510: GO 107041
// for i in solds do
106512: LD_ADDR_VAR 0 7
106516: PUSH
106517: LD_VAR 0 2
106521: PUSH
106522: FOR_IN
106523: IFFALSE 106584
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
106525: LD_VAR 0 7
106529: PPUSH
106530: CALL_OW 310
106534: PPUSH
106535: CALL_OW 266
106539: PUSH
106540: LD_INT 32
106542: PUSH
106543: LD_INT 31
106545: PUSH
106546: EMPTY
106547: LIST
106548: LIST
106549: IN
106550: IFFALSE 106570
// solds := solds diff i else
106552: LD_ADDR_VAR 0 2
106556: PUSH
106557: LD_VAR 0 2
106561: PUSH
106562: LD_VAR 0 7
106566: DIFF
106567: ST_TO_ADDR
106568: GO 106582
// SetTag ( i , 18 ) ;
106570: LD_VAR 0 7
106574: PPUSH
106575: LD_INT 18
106577: PPUSH
106578: CALL_OW 109
106582: GO 106522
106584: POP
106585: POP
// if not solds then
106586: LD_VAR 0 2
106590: NOT
106591: IFFALSE 106595
// exit ;
106593: GO 107041
// repeat wait ( 0 0$2 ) ;
106595: LD_INT 70
106597: PPUSH
106598: CALL_OW 67
// enemy := mc_scan [ base ] ;
106602: LD_ADDR_VAR 0 4
106606: PUSH
106607: LD_EXP 92
106611: PUSH
106612: LD_VAR 0 1
106616: ARRAY
106617: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
106618: LD_EXP 69
106622: PUSH
106623: LD_VAR 0 1
106627: ARRAY
106628: NOT
106629: PUSH
106630: LD_EXP 69
106634: PUSH
106635: LD_VAR 0 1
106639: ARRAY
106640: PUSH
106641: EMPTY
106642: EQUAL
106643: OR
106644: IFFALSE 106681
// begin for i in solds do
106646: LD_ADDR_VAR 0 7
106650: PUSH
106651: LD_VAR 0 2
106655: PUSH
106656: FOR_IN
106657: IFFALSE 106670
// ComStop ( i ) ;
106659: LD_VAR 0 7
106663: PPUSH
106664: CALL_OW 141
106668: GO 106656
106670: POP
106671: POP
// solds := [ ] ;
106672: LD_ADDR_VAR 0 2
106676: PUSH
106677: EMPTY
106678: ST_TO_ADDR
// exit ;
106679: GO 107041
// end ; for i in solds do
106681: LD_ADDR_VAR 0 7
106685: PUSH
106686: LD_VAR 0 2
106690: PUSH
106691: FOR_IN
106692: IFFALSE 107013
// begin if IsInUnit ( i ) then
106694: LD_VAR 0 7
106698: PPUSH
106699: CALL_OW 310
106703: IFFALSE 106714
// ComExitBuilding ( i ) ;
106705: LD_VAR 0 7
106709: PPUSH
106710: CALL_OW 122
// if GetLives ( i ) > 500 then
106714: LD_VAR 0 7
106718: PPUSH
106719: CALL_OW 256
106723: PUSH
106724: LD_INT 500
106726: GREATER
106727: IFFALSE 106780
// begin e := NearestUnitToUnit ( enemy , i ) ;
106729: LD_ADDR_VAR 0 5
106733: PUSH
106734: LD_VAR 0 4
106738: PPUSH
106739: LD_VAR 0 7
106743: PPUSH
106744: CALL_OW 74
106748: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
106749: LD_VAR 0 7
106753: PPUSH
106754: LD_VAR 0 5
106758: PPUSH
106759: CALL_OW 250
106763: PPUSH
106764: LD_VAR 0 5
106768: PPUSH
106769: CALL_OW 251
106773: PPUSH
106774: CALL_OW 114
// end else
106778: GO 107011
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
106780: LD_VAR 0 7
106784: PPUSH
106785: LD_EXP 69
106789: PUSH
106790: LD_VAR 0 1
106794: ARRAY
106795: PPUSH
106796: LD_INT 2
106798: PUSH
106799: LD_INT 30
106801: PUSH
106802: LD_INT 0
106804: PUSH
106805: EMPTY
106806: LIST
106807: LIST
106808: PUSH
106809: LD_INT 30
106811: PUSH
106812: LD_INT 1
106814: PUSH
106815: EMPTY
106816: LIST
106817: LIST
106818: PUSH
106819: LD_INT 30
106821: PUSH
106822: LD_INT 6
106824: PUSH
106825: EMPTY
106826: LIST
106827: LIST
106828: PUSH
106829: EMPTY
106830: LIST
106831: LIST
106832: LIST
106833: LIST
106834: PPUSH
106835: CALL_OW 72
106839: PPUSH
106840: LD_VAR 0 7
106844: PPUSH
106845: CALL_OW 74
106849: PPUSH
106850: CALL_OW 296
106854: PUSH
106855: LD_INT 10
106857: GREATER
106858: IFFALSE 107011
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
106860: LD_ADDR_VAR 0 8
106864: PUSH
106865: LD_EXP 69
106869: PUSH
106870: LD_VAR 0 1
106874: ARRAY
106875: PPUSH
106876: LD_INT 2
106878: PUSH
106879: LD_INT 30
106881: PUSH
106882: LD_INT 0
106884: PUSH
106885: EMPTY
106886: LIST
106887: LIST
106888: PUSH
106889: LD_INT 30
106891: PUSH
106892: LD_INT 1
106894: PUSH
106895: EMPTY
106896: LIST
106897: LIST
106898: PUSH
106899: LD_INT 30
106901: PUSH
106902: LD_INT 6
106904: PUSH
106905: EMPTY
106906: LIST
106907: LIST
106908: PUSH
106909: EMPTY
106910: LIST
106911: LIST
106912: LIST
106913: LIST
106914: PPUSH
106915: CALL_OW 72
106919: PPUSH
106920: LD_VAR 0 7
106924: PPUSH
106925: CALL_OW 74
106929: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
106930: LD_VAR 0 7
106934: PPUSH
106935: LD_VAR 0 8
106939: PPUSH
106940: CALL_OW 250
106944: PPUSH
106945: LD_INT 3
106947: PPUSH
106948: LD_INT 5
106950: PPUSH
106951: CALL_OW 272
106955: PPUSH
106956: LD_VAR 0 8
106960: PPUSH
106961: CALL_OW 251
106965: PPUSH
106966: LD_INT 3
106968: PPUSH
106969: LD_INT 5
106971: PPUSH
106972: CALL_OW 273
106976: PPUSH
106977: CALL_OW 111
// SetTag ( i , 0 ) ;
106981: LD_VAR 0 7
106985: PPUSH
106986: LD_INT 0
106988: PPUSH
106989: CALL_OW 109
// solds := solds diff i ;
106993: LD_ADDR_VAR 0 2
106997: PUSH
106998: LD_VAR 0 2
107002: PUSH
107003: LD_VAR 0 7
107007: DIFF
107008: ST_TO_ADDR
// continue ;
107009: GO 106691
// end ; end ;
107011: GO 106691
107013: POP
107014: POP
// until not solds or not enemy ;
107015: LD_VAR 0 2
107019: NOT
107020: PUSH
107021: LD_VAR 0 4
107025: NOT
107026: OR
107027: IFFALSE 106595
// MC_Reset ( base , 18 ) ;
107029: LD_VAR 0 1
107033: PPUSH
107034: LD_INT 18
107036: PPUSH
107037: CALL 57479 0 2
// end ;
107041: LD_VAR 0 3
107045: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
107046: LD_INT 0
107048: PPUSH
107049: PPUSH
107050: PPUSH
107051: PPUSH
107052: PPUSH
107053: PPUSH
107054: PPUSH
107055: PPUSH
107056: PPUSH
107057: PPUSH
107058: PPUSH
107059: PPUSH
107060: PPUSH
107061: PPUSH
107062: PPUSH
107063: PPUSH
107064: PPUSH
107065: PPUSH
107066: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
107067: LD_ADDR_VAR 0 12
107071: PUSH
107072: LD_EXP 69
107076: PUSH
107077: LD_VAR 0 1
107081: ARRAY
107082: PPUSH
107083: LD_INT 25
107085: PUSH
107086: LD_INT 3
107088: PUSH
107089: EMPTY
107090: LIST
107091: LIST
107092: PPUSH
107093: CALL_OW 72
107097: ST_TO_ADDR
// if mc_remote_driver [ base ] then
107098: LD_EXP 109
107102: PUSH
107103: LD_VAR 0 1
107107: ARRAY
107108: IFFALSE 107132
// mechs := mechs diff mc_remote_driver [ base ] ;
107110: LD_ADDR_VAR 0 12
107114: PUSH
107115: LD_VAR 0 12
107119: PUSH
107120: LD_EXP 109
107124: PUSH
107125: LD_VAR 0 1
107129: ARRAY
107130: DIFF
107131: ST_TO_ADDR
// for i in mechs do
107132: LD_ADDR_VAR 0 4
107136: PUSH
107137: LD_VAR 0 12
107141: PUSH
107142: FOR_IN
107143: IFFALSE 107178
// if GetTag ( i ) > 0 then
107145: LD_VAR 0 4
107149: PPUSH
107150: CALL_OW 110
107154: PUSH
107155: LD_INT 0
107157: GREATER
107158: IFFALSE 107176
// mechs := mechs diff i ;
107160: LD_ADDR_VAR 0 12
107164: PUSH
107165: LD_VAR 0 12
107169: PUSH
107170: LD_VAR 0 4
107174: DIFF
107175: ST_TO_ADDR
107176: GO 107142
107178: POP
107179: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
107180: LD_ADDR_VAR 0 8
107184: PUSH
107185: LD_EXP 69
107189: PUSH
107190: LD_VAR 0 1
107194: ARRAY
107195: PPUSH
107196: LD_INT 2
107198: PUSH
107199: LD_INT 25
107201: PUSH
107202: LD_INT 1
107204: PUSH
107205: EMPTY
107206: LIST
107207: LIST
107208: PUSH
107209: LD_INT 25
107211: PUSH
107212: LD_INT 5
107214: PUSH
107215: EMPTY
107216: LIST
107217: LIST
107218: PUSH
107219: LD_INT 25
107221: PUSH
107222: LD_INT 8
107224: PUSH
107225: EMPTY
107226: LIST
107227: LIST
107228: PUSH
107229: LD_INT 25
107231: PUSH
107232: LD_INT 9
107234: PUSH
107235: EMPTY
107236: LIST
107237: LIST
107238: PUSH
107239: EMPTY
107240: LIST
107241: LIST
107242: LIST
107243: LIST
107244: LIST
107245: PPUSH
107246: CALL_OW 72
107250: ST_TO_ADDR
// if not defenders and not solds then
107251: LD_VAR 0 2
107255: NOT
107256: PUSH
107257: LD_VAR 0 8
107261: NOT
107262: AND
107263: IFFALSE 107267
// exit ;
107265: GO 109037
// depot_under_attack := false ;
107267: LD_ADDR_VAR 0 16
107271: PUSH
107272: LD_INT 0
107274: ST_TO_ADDR
// sold_defenders := [ ] ;
107275: LD_ADDR_VAR 0 17
107279: PUSH
107280: EMPTY
107281: ST_TO_ADDR
// if mechs then
107282: LD_VAR 0 12
107286: IFFALSE 107439
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
107288: LD_ADDR_VAR 0 4
107292: PUSH
107293: LD_VAR 0 2
107297: PPUSH
107298: LD_INT 21
107300: PUSH
107301: LD_INT 2
107303: PUSH
107304: EMPTY
107305: LIST
107306: LIST
107307: PPUSH
107308: CALL_OW 72
107312: PUSH
107313: FOR_IN
107314: IFFALSE 107437
// begin if GetTag ( i ) <> 20 then
107316: LD_VAR 0 4
107320: PPUSH
107321: CALL_OW 110
107325: PUSH
107326: LD_INT 20
107328: NONEQUAL
107329: IFFALSE 107343
// SetTag ( i , 20 ) ;
107331: LD_VAR 0 4
107335: PPUSH
107336: LD_INT 20
107338: PPUSH
107339: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
107343: LD_VAR 0 4
107347: PPUSH
107348: CALL_OW 263
107352: PUSH
107353: LD_INT 1
107355: EQUAL
107356: PUSH
107357: LD_VAR 0 4
107361: PPUSH
107362: CALL_OW 311
107366: NOT
107367: AND
107368: IFFALSE 107435
// begin un := mechs [ 1 ] ;
107370: LD_ADDR_VAR 0 10
107374: PUSH
107375: LD_VAR 0 12
107379: PUSH
107380: LD_INT 1
107382: ARRAY
107383: ST_TO_ADDR
// ComExit ( un ) ;
107384: LD_VAR 0 10
107388: PPUSH
107389: CALL 50727 0 1
// AddComEnterUnit ( un , i ) ;
107393: LD_VAR 0 10
107397: PPUSH
107398: LD_VAR 0 4
107402: PPUSH
107403: CALL_OW 180
// SetTag ( un , 19 ) ;
107407: LD_VAR 0 10
107411: PPUSH
107412: LD_INT 19
107414: PPUSH
107415: CALL_OW 109
// mechs := mechs diff un ;
107419: LD_ADDR_VAR 0 12
107423: PUSH
107424: LD_VAR 0 12
107428: PUSH
107429: LD_VAR 0 10
107433: DIFF
107434: ST_TO_ADDR
// end ; end ;
107435: GO 107313
107437: POP
107438: POP
// if solds then
107439: LD_VAR 0 8
107443: IFFALSE 107502
// for i in solds do
107445: LD_ADDR_VAR 0 4
107449: PUSH
107450: LD_VAR 0 8
107454: PUSH
107455: FOR_IN
107456: IFFALSE 107500
// if not GetTag ( i ) then
107458: LD_VAR 0 4
107462: PPUSH
107463: CALL_OW 110
107467: NOT
107468: IFFALSE 107498
// begin defenders := defenders union i ;
107470: LD_ADDR_VAR 0 2
107474: PUSH
107475: LD_VAR 0 2
107479: PUSH
107480: LD_VAR 0 4
107484: UNION
107485: ST_TO_ADDR
// SetTag ( i , 18 ) ;
107486: LD_VAR 0 4
107490: PPUSH
107491: LD_INT 18
107493: PPUSH
107494: CALL_OW 109
// end ;
107498: GO 107455
107500: POP
107501: POP
// repeat wait ( 0 0$2 ) ;
107502: LD_INT 70
107504: PPUSH
107505: CALL_OW 67
// enemy := mc_scan [ base ] ;
107509: LD_ADDR_VAR 0 21
107513: PUSH
107514: LD_EXP 92
107518: PUSH
107519: LD_VAR 0 1
107523: ARRAY
107524: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107525: LD_EXP 69
107529: PUSH
107530: LD_VAR 0 1
107534: ARRAY
107535: NOT
107536: PUSH
107537: LD_EXP 69
107541: PUSH
107542: LD_VAR 0 1
107546: ARRAY
107547: PUSH
107548: EMPTY
107549: EQUAL
107550: OR
107551: IFFALSE 107588
// begin for i in defenders do
107553: LD_ADDR_VAR 0 4
107557: PUSH
107558: LD_VAR 0 2
107562: PUSH
107563: FOR_IN
107564: IFFALSE 107577
// ComStop ( i ) ;
107566: LD_VAR 0 4
107570: PPUSH
107571: CALL_OW 141
107575: GO 107563
107577: POP
107578: POP
// defenders := [ ] ;
107579: LD_ADDR_VAR 0 2
107583: PUSH
107584: EMPTY
107585: ST_TO_ADDR
// exit ;
107586: GO 109037
// end ; for i in defenders do
107588: LD_ADDR_VAR 0 4
107592: PUSH
107593: LD_VAR 0 2
107597: PUSH
107598: FOR_IN
107599: IFFALSE 108497
// begin e := NearestUnitToUnit ( enemy , i ) ;
107601: LD_ADDR_VAR 0 13
107605: PUSH
107606: LD_VAR 0 21
107610: PPUSH
107611: LD_VAR 0 4
107615: PPUSH
107616: CALL_OW 74
107620: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107621: LD_ADDR_VAR 0 7
107625: PUSH
107626: LD_EXP 69
107630: PUSH
107631: LD_VAR 0 1
107635: ARRAY
107636: PPUSH
107637: LD_INT 2
107639: PUSH
107640: LD_INT 30
107642: PUSH
107643: LD_INT 0
107645: PUSH
107646: EMPTY
107647: LIST
107648: LIST
107649: PUSH
107650: LD_INT 30
107652: PUSH
107653: LD_INT 1
107655: PUSH
107656: EMPTY
107657: LIST
107658: LIST
107659: PUSH
107660: EMPTY
107661: LIST
107662: LIST
107663: LIST
107664: PPUSH
107665: CALL_OW 72
107669: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
107670: LD_ADDR_VAR 0 16
107674: PUSH
107675: LD_VAR 0 7
107679: NOT
107680: PUSH
107681: LD_VAR 0 7
107685: PPUSH
107686: LD_INT 3
107688: PUSH
107689: LD_INT 24
107691: PUSH
107692: LD_INT 600
107694: PUSH
107695: EMPTY
107696: LIST
107697: LIST
107698: PUSH
107699: EMPTY
107700: LIST
107701: LIST
107702: PPUSH
107703: CALL_OW 72
107707: OR
107708: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
107709: LD_VAR 0 4
107713: PPUSH
107714: CALL_OW 247
107718: PUSH
107719: LD_INT 2
107721: DOUBLE
107722: EQUAL
107723: IFTRUE 107727
107725: GO 108123
107727: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
107728: LD_VAR 0 4
107732: PPUSH
107733: CALL_OW 256
107737: PUSH
107738: LD_INT 1000
107740: EQUAL
107741: PUSH
107742: LD_VAR 0 4
107746: PPUSH
107747: LD_VAR 0 13
107751: PPUSH
107752: CALL_OW 296
107756: PUSH
107757: LD_INT 40
107759: LESS
107760: PUSH
107761: LD_VAR 0 13
107765: PPUSH
107766: LD_EXP 94
107770: PUSH
107771: LD_VAR 0 1
107775: ARRAY
107776: PPUSH
107777: CALL_OW 308
107781: OR
107782: AND
107783: IFFALSE 107905
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
107785: LD_VAR 0 4
107789: PPUSH
107790: CALL_OW 262
107794: PUSH
107795: LD_INT 1
107797: EQUAL
107798: PUSH
107799: LD_VAR 0 4
107803: PPUSH
107804: CALL_OW 261
107808: PUSH
107809: LD_INT 30
107811: LESS
107812: AND
107813: PUSH
107814: LD_VAR 0 7
107818: AND
107819: IFFALSE 107889
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
107821: LD_VAR 0 4
107825: PPUSH
107826: LD_VAR 0 7
107830: PPUSH
107831: LD_VAR 0 4
107835: PPUSH
107836: CALL_OW 74
107840: PPUSH
107841: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
107845: LD_VAR 0 4
107849: PPUSH
107850: LD_VAR 0 7
107854: PPUSH
107855: LD_VAR 0 4
107859: PPUSH
107860: CALL_OW 74
107864: PPUSH
107865: CALL_OW 296
107869: PUSH
107870: LD_INT 6
107872: LESS
107873: IFFALSE 107887
// SetFuel ( i , 100 ) ;
107875: LD_VAR 0 4
107879: PPUSH
107880: LD_INT 100
107882: PPUSH
107883: CALL_OW 240
// end else
107887: GO 107903
// ComAttackUnit ( i , e ) ;
107889: LD_VAR 0 4
107893: PPUSH
107894: LD_VAR 0 13
107898: PPUSH
107899: CALL_OW 115
// end else
107903: GO 108006
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
107905: LD_VAR 0 13
107909: PPUSH
107910: LD_EXP 94
107914: PUSH
107915: LD_VAR 0 1
107919: ARRAY
107920: PPUSH
107921: CALL_OW 308
107925: NOT
107926: PUSH
107927: LD_VAR 0 4
107931: PPUSH
107932: LD_VAR 0 13
107936: PPUSH
107937: CALL_OW 296
107941: PUSH
107942: LD_INT 40
107944: GREATEREQUAL
107945: AND
107946: PUSH
107947: LD_VAR 0 4
107951: PPUSH
107952: CALL_OW 256
107956: PUSH
107957: LD_INT 650
107959: LESSEQUAL
107960: OR
107961: PUSH
107962: LD_VAR 0 4
107966: PPUSH
107967: LD_EXP 93
107971: PUSH
107972: LD_VAR 0 1
107976: ARRAY
107977: PPUSH
107978: CALL_OW 308
107982: NOT
107983: AND
107984: IFFALSE 108006
// ComMoveToArea ( i , mc_parking [ base ] ) ;
107986: LD_VAR 0 4
107990: PPUSH
107991: LD_EXP 93
107995: PUSH
107996: LD_VAR 0 1
108000: ARRAY
108001: PPUSH
108002: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
108006: LD_VAR 0 4
108010: PPUSH
108011: CALL_OW 256
108015: PUSH
108016: LD_INT 1000
108018: LESS
108019: PUSH
108020: LD_VAR 0 4
108024: PPUSH
108025: CALL_OW 263
108029: PUSH
108030: LD_INT 1
108032: EQUAL
108033: AND
108034: PUSH
108035: LD_VAR 0 4
108039: PPUSH
108040: CALL_OW 311
108044: AND
108045: PUSH
108046: LD_VAR 0 4
108050: PPUSH
108051: LD_EXP 93
108055: PUSH
108056: LD_VAR 0 1
108060: ARRAY
108061: PPUSH
108062: CALL_OW 308
108066: AND
108067: IFFALSE 108121
// begin mech := IsDrivenBy ( i ) ;
108069: LD_ADDR_VAR 0 9
108073: PUSH
108074: LD_VAR 0 4
108078: PPUSH
108079: CALL_OW 311
108083: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
108084: LD_VAR 0 9
108088: PPUSH
108089: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
108093: LD_VAR 0 9
108097: PPUSH
108098: LD_VAR 0 4
108102: PPUSH
108103: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
108107: LD_VAR 0 9
108111: PPUSH
108112: LD_VAR 0 4
108116: PPUSH
108117: CALL_OW 180
// end ; end ; unit_human :
108121: GO 108468
108123: LD_INT 1
108125: DOUBLE
108126: EQUAL
108127: IFTRUE 108131
108129: GO 108467
108131: POP
// begin b := IsInUnit ( i ) ;
108132: LD_ADDR_VAR 0 18
108136: PUSH
108137: LD_VAR 0 4
108141: PPUSH
108142: CALL_OW 310
108146: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
108147: LD_ADDR_VAR 0 19
108151: PUSH
108152: LD_VAR 0 18
108156: NOT
108157: PUSH
108158: LD_VAR 0 18
108162: PPUSH
108163: CALL_OW 266
108167: PUSH
108168: LD_INT 32
108170: PUSH
108171: LD_INT 31
108173: PUSH
108174: EMPTY
108175: LIST
108176: LIST
108177: IN
108178: OR
108179: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
108180: LD_VAR 0 18
108184: PPUSH
108185: CALL_OW 266
108189: PUSH
108190: LD_INT 5
108192: EQUAL
108193: PUSH
108194: LD_VAR 0 4
108198: PPUSH
108199: CALL_OW 257
108203: PUSH
108204: LD_INT 1
108206: PUSH
108207: LD_INT 2
108209: PUSH
108210: LD_INT 3
108212: PUSH
108213: LD_INT 4
108215: PUSH
108216: EMPTY
108217: LIST
108218: LIST
108219: LIST
108220: LIST
108221: IN
108222: AND
108223: IFFALSE 108260
// begin class := AllowSpecClass ( i ) ;
108225: LD_ADDR_VAR 0 20
108229: PUSH
108230: LD_VAR 0 4
108234: PPUSH
108235: CALL 15388 0 1
108239: ST_TO_ADDR
// if class then
108240: LD_VAR 0 20
108244: IFFALSE 108260
// ComChangeProfession ( i , class ) ;
108246: LD_VAR 0 4
108250: PPUSH
108251: LD_VAR 0 20
108255: PPUSH
108256: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
108260: LD_VAR 0 16
108264: PUSH
108265: LD_VAR 0 2
108269: PPUSH
108270: LD_INT 21
108272: PUSH
108273: LD_INT 2
108275: PUSH
108276: EMPTY
108277: LIST
108278: LIST
108279: PPUSH
108280: CALL_OW 72
108284: PUSH
108285: LD_INT 1
108287: LESSEQUAL
108288: OR
108289: PUSH
108290: LD_VAR 0 19
108294: AND
108295: PUSH
108296: LD_VAR 0 4
108300: PUSH
108301: LD_VAR 0 17
108305: IN
108306: NOT
108307: AND
108308: IFFALSE 108401
// begin if b then
108310: LD_VAR 0 18
108314: IFFALSE 108363
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
108316: LD_VAR 0 18
108320: PPUSH
108321: LD_VAR 0 21
108325: PPUSH
108326: LD_VAR 0 18
108330: PPUSH
108331: CALL_OW 74
108335: PPUSH
108336: CALL_OW 296
108340: PUSH
108341: LD_INT 10
108343: LESS
108344: PUSH
108345: LD_VAR 0 18
108349: PPUSH
108350: CALL_OW 461
108354: PUSH
108355: LD_INT 7
108357: NONEQUAL
108358: AND
108359: IFFALSE 108363
// continue ;
108361: GO 107598
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
108363: LD_ADDR_VAR 0 17
108367: PUSH
108368: LD_VAR 0 17
108372: PPUSH
108373: LD_VAR 0 17
108377: PUSH
108378: LD_INT 1
108380: PLUS
108381: PPUSH
108382: LD_VAR 0 4
108386: PPUSH
108387: CALL_OW 1
108391: ST_TO_ADDR
// ComExitBuilding ( i ) ;
108392: LD_VAR 0 4
108396: PPUSH
108397: CALL_OW 122
// end ; if sold_defenders then
108401: LD_VAR 0 17
108405: IFFALSE 108465
// if i in sold_defenders then
108407: LD_VAR 0 4
108411: PUSH
108412: LD_VAR 0 17
108416: IN
108417: IFFALSE 108465
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
108419: LD_VAR 0 4
108423: PPUSH
108424: CALL_OW 314
108428: NOT
108429: PUSH
108430: LD_VAR 0 4
108434: PPUSH
108435: LD_VAR 0 13
108439: PPUSH
108440: CALL_OW 296
108444: PUSH
108445: LD_INT 30
108447: LESS
108448: AND
108449: IFFALSE 108465
// ComAttackUnit ( i , e ) ;
108451: LD_VAR 0 4
108455: PPUSH
108456: LD_VAR 0 13
108460: PPUSH
108461: CALL_OW 115
// end ; end ; end ;
108465: GO 108468
108467: POP
// if IsDead ( i ) then
108468: LD_VAR 0 4
108472: PPUSH
108473: CALL_OW 301
108477: IFFALSE 108495
// defenders := defenders diff i ;
108479: LD_ADDR_VAR 0 2
108483: PUSH
108484: LD_VAR 0 2
108488: PUSH
108489: LD_VAR 0 4
108493: DIFF
108494: ST_TO_ADDR
// end ;
108495: GO 107598
108497: POP
108498: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
108499: LD_VAR 0 21
108503: NOT
108504: PUSH
108505: LD_VAR 0 2
108509: NOT
108510: OR
108511: PUSH
108512: LD_EXP 69
108516: PUSH
108517: LD_VAR 0 1
108521: ARRAY
108522: NOT
108523: OR
108524: IFFALSE 107502
// MC_Reset ( base , 18 ) ;
108526: LD_VAR 0 1
108530: PPUSH
108531: LD_INT 18
108533: PPUSH
108534: CALL 57479 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
108538: LD_ADDR_VAR 0 2
108542: PUSH
108543: LD_VAR 0 2
108547: PUSH
108548: LD_VAR 0 2
108552: PPUSH
108553: LD_INT 2
108555: PUSH
108556: LD_INT 25
108558: PUSH
108559: LD_INT 1
108561: PUSH
108562: EMPTY
108563: LIST
108564: LIST
108565: PUSH
108566: LD_INT 25
108568: PUSH
108569: LD_INT 5
108571: PUSH
108572: EMPTY
108573: LIST
108574: LIST
108575: PUSH
108576: LD_INT 25
108578: PUSH
108579: LD_INT 8
108581: PUSH
108582: EMPTY
108583: LIST
108584: LIST
108585: PUSH
108586: LD_INT 25
108588: PUSH
108589: LD_INT 9
108591: PUSH
108592: EMPTY
108593: LIST
108594: LIST
108595: PUSH
108596: EMPTY
108597: LIST
108598: LIST
108599: LIST
108600: LIST
108601: LIST
108602: PPUSH
108603: CALL_OW 72
108607: DIFF
108608: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
108609: LD_VAR 0 21
108613: NOT
108614: PUSH
108615: LD_VAR 0 2
108619: PPUSH
108620: LD_INT 21
108622: PUSH
108623: LD_INT 2
108625: PUSH
108626: EMPTY
108627: LIST
108628: LIST
108629: PPUSH
108630: CALL_OW 72
108634: AND
108635: IFFALSE 108973
// begin tmp := FilterByTag ( defenders , 19 ) ;
108637: LD_ADDR_VAR 0 11
108641: PUSH
108642: LD_VAR 0 2
108646: PPUSH
108647: LD_INT 19
108649: PPUSH
108650: CALL 47857 0 2
108654: ST_TO_ADDR
// if tmp then
108655: LD_VAR 0 11
108659: IFFALSE 108729
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
108661: LD_ADDR_VAR 0 11
108665: PUSH
108666: LD_VAR 0 11
108670: PPUSH
108671: LD_INT 25
108673: PUSH
108674: LD_INT 3
108676: PUSH
108677: EMPTY
108678: LIST
108679: LIST
108680: PPUSH
108681: CALL_OW 72
108685: ST_TO_ADDR
// if tmp then
108686: LD_VAR 0 11
108690: IFFALSE 108729
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
108692: LD_ADDR_EXP 81
108696: PUSH
108697: LD_EXP 81
108701: PPUSH
108702: LD_VAR 0 1
108706: PPUSH
108707: LD_EXP 81
108711: PUSH
108712: LD_VAR 0 1
108716: ARRAY
108717: PUSH
108718: LD_VAR 0 11
108722: UNION
108723: PPUSH
108724: CALL_OW 1
108728: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
108729: LD_VAR 0 1
108733: PPUSH
108734: LD_INT 19
108736: PPUSH
108737: CALL 57479 0 2
// repeat wait ( 0 0$1 ) ;
108741: LD_INT 35
108743: PPUSH
108744: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
108748: LD_EXP 69
108752: PUSH
108753: LD_VAR 0 1
108757: ARRAY
108758: NOT
108759: PUSH
108760: LD_EXP 69
108764: PUSH
108765: LD_VAR 0 1
108769: ARRAY
108770: PUSH
108771: EMPTY
108772: EQUAL
108773: OR
108774: IFFALSE 108811
// begin for i in defenders do
108776: LD_ADDR_VAR 0 4
108780: PUSH
108781: LD_VAR 0 2
108785: PUSH
108786: FOR_IN
108787: IFFALSE 108800
// ComStop ( i ) ;
108789: LD_VAR 0 4
108793: PPUSH
108794: CALL_OW 141
108798: GO 108786
108800: POP
108801: POP
// defenders := [ ] ;
108802: LD_ADDR_VAR 0 2
108806: PUSH
108807: EMPTY
108808: ST_TO_ADDR
// exit ;
108809: GO 109037
// end ; for i in defenders do
108811: LD_ADDR_VAR 0 4
108815: PUSH
108816: LD_VAR 0 2
108820: PUSH
108821: FOR_IN
108822: IFFALSE 108911
// begin if not IsInArea ( i , mc_parking [ base ] ) then
108824: LD_VAR 0 4
108828: PPUSH
108829: LD_EXP 93
108833: PUSH
108834: LD_VAR 0 1
108838: ARRAY
108839: PPUSH
108840: CALL_OW 308
108844: NOT
108845: IFFALSE 108869
// ComMoveToArea ( i , mc_parking [ base ] ) else
108847: LD_VAR 0 4
108851: PPUSH
108852: LD_EXP 93
108856: PUSH
108857: LD_VAR 0 1
108861: ARRAY
108862: PPUSH
108863: CALL_OW 113
108867: GO 108909
// if GetControl ( i ) = control_manual then
108869: LD_VAR 0 4
108873: PPUSH
108874: CALL_OW 263
108878: PUSH
108879: LD_INT 1
108881: EQUAL
108882: IFFALSE 108909
// if IsDrivenBy ( i ) then
108884: LD_VAR 0 4
108888: PPUSH
108889: CALL_OW 311
108893: IFFALSE 108909
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
108895: LD_VAR 0 4
108899: PPUSH
108900: CALL_OW 311
108904: PPUSH
108905: CALL_OW 121
// end ;
108909: GO 108821
108911: POP
108912: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
108913: LD_VAR 0 2
108917: PPUSH
108918: LD_INT 95
108920: PUSH
108921: LD_EXP 93
108925: PUSH
108926: LD_VAR 0 1
108930: ARRAY
108931: PUSH
108932: EMPTY
108933: LIST
108934: LIST
108935: PPUSH
108936: CALL_OW 72
108940: PUSH
108941: LD_VAR 0 2
108945: EQUAL
108946: PUSH
108947: LD_EXP 92
108951: PUSH
108952: LD_VAR 0 1
108956: ARRAY
108957: OR
108958: PUSH
108959: LD_EXP 69
108963: PUSH
108964: LD_VAR 0 1
108968: ARRAY
108969: NOT
108970: OR
108971: IFFALSE 108741
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
108973: LD_ADDR_EXP 91
108977: PUSH
108978: LD_EXP 91
108982: PPUSH
108983: LD_VAR 0 1
108987: PPUSH
108988: LD_VAR 0 2
108992: PPUSH
108993: LD_INT 21
108995: PUSH
108996: LD_INT 2
108998: PUSH
108999: EMPTY
109000: LIST
109001: LIST
109002: PPUSH
109003: CALL_OW 72
109007: PPUSH
109008: CALL_OW 1
109012: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
109013: LD_VAR 0 1
109017: PPUSH
109018: LD_INT 19
109020: PPUSH
109021: CALL 57479 0 2
// MC_Reset ( base , 20 ) ;
109025: LD_VAR 0 1
109029: PPUSH
109030: LD_INT 20
109032: PPUSH
109033: CALL 57479 0 2
// end ; end_of_file
109037: LD_VAR 0 3
109041: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
109042: LD_VAR 0 1
109046: PUSH
109047: LD_INT 200
109049: DOUBLE
109050: GREATEREQUAL
109051: IFFALSE 109059
109053: LD_INT 299
109055: DOUBLE
109056: LESSEQUAL
109057: IFTRUE 109061
109059: GO 109093
109061: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
109062: LD_VAR 0 1
109066: PPUSH
109067: LD_VAR 0 2
109071: PPUSH
109072: LD_VAR 0 3
109076: PPUSH
109077: LD_VAR 0 4
109081: PPUSH
109082: LD_VAR 0 5
109086: PPUSH
109087: CALL 97858 0 5
109091: GO 109170
109093: LD_INT 300
109095: DOUBLE
109096: GREATEREQUAL
109097: IFFALSE 109105
109099: LD_INT 399
109101: DOUBLE
109102: LESSEQUAL
109103: IFTRUE 109107
109105: GO 109169
109107: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
109108: LD_VAR 0 1
109112: PPUSH
109113: LD_VAR 0 2
109117: PPUSH
109118: LD_VAR 0 3
109122: PPUSH
109123: LD_VAR 0 4
109127: PPUSH
109128: LD_VAR 0 5
109132: PPUSH
109133: LD_VAR 0 6
109137: PPUSH
109138: LD_VAR 0 7
109142: PPUSH
109143: LD_VAR 0 8
109147: PPUSH
109148: LD_VAR 0 9
109152: PPUSH
109153: LD_VAR 0 10
109157: PPUSH
109158: LD_VAR 0 11
109162: PPUSH
109163: CALL 95756 0 11
109167: GO 109170
109169: POP
// end ;
109170: PPOPN 11
109172: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
109173: LD_VAR 0 1
109177: PPUSH
109178: LD_VAR 0 2
109182: PPUSH
109183: LD_VAR 0 3
109187: PPUSH
109188: LD_VAR 0 4
109192: PPUSH
109193: LD_VAR 0 5
109197: PPUSH
109198: CALL 97850 0 5
// end ; end_of_file
109202: PPOPN 5
109204: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
109205: LD_VAR 0 1
109209: PPUSH
109210: LD_VAR 0 2
109214: PPUSH
109215: LD_VAR 0 3
109219: PPUSH
109220: LD_VAR 0 4
109224: PPUSH
109225: LD_VAR 0 5
109229: PPUSH
109230: LD_VAR 0 6
109234: PPUSH
109235: CALL 83951 0 6
// end ;
109239: PPOPN 6
109241: END
