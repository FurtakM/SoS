// export MissionStart ; export southAreaBlocker ; starting begin southAreaBlocker = true ;
   0: LD_ADDR_EXP 2
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// ResetFog ;
   8: CALL_OW 335
// AnimateTrees ( true ) ;
  12: LD_INT 1
  14: PPUSH
  15: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  19: LD_INT 1
  21: PPUSH
  22: LD_INT 8
  24: PPUSH
  25: CALL_OW 332
// GameType ;
  29: CALL 5444 0 0
// SetBName ( BetaA , beta ) ;
  33: LD_INT 1
  35: PPUSH
  36: LD_STRING beta
  38: PPUSH
  39: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  43: LD_INT 3
  45: PPUSH
  46: LD_STRING beta
  48: PPUSH
  49: CALL_OW 500
// SetResourceType ( GetBase ( BetaA ) , mat_cans , startCrates [ 1 ] ) ;
  53: LD_INT 1
  55: PPUSH
  56: CALL_OW 274
  60: PPUSH
  61: LD_INT 1
  63: PPUSH
  64: LD_EXP 43
  68: PUSH
  69: LD_INT 1
  71: ARRAY
  72: PPUSH
  73: CALL_OW 277
// SetResourceType ( GetBase ( BetaB ) , mat_cans , startCrates [ 2 ] ) ;
  77: LD_INT 3
  79: PPUSH
  80: CALL_OW 274
  84: PPUSH
  85: LD_INT 1
  87: PPUSH
  88: LD_EXP 43
  92: PUSH
  93: LD_INT 2
  95: ARRAY
  96: PPUSH
  97: CALL_OW 277
// PrepareHeroes ;
 101: CALL 2607 0 0
// PrepareBeta ;
 105: CALL 2996 0 0
// HideArea ( 1 , SouthArea ) ;
 109: LD_INT 1
 111: PPUSH
 112: LD_INT 16
 114: PPUSH
 115: CALL_OW 333
// InGameOn ;
 119: CALL_OW 8
// ComHold ( Brighton ) ;
 123: LD_EXP 9
 127: PPUSH
 128: CALL_OW 140
// CenterNowOnUnits ( Brighton ) ;
 132: LD_EXP 9
 136: PPUSH
 137: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
 141: LD_EXP 11
 145: PPUSH
 146: LD_INT 50
 148: PPUSH
 149: LD_INT 42
 151: PPUSH
 152: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
 156: LD_INT 35
 158: PPUSH
 159: CALL_OW 67
 163: LD_EXP 11
 167: PPUSH
 168: LD_EXP 9
 172: PPUSH
 173: CALL_OW 296
 177: PUSH
 178: LD_INT 3
 180: LESS
 181: IFFALSE 156
// ComTurnUnit ( Megan , Brighton ) ;
 183: LD_EXP 11
 187: PPUSH
 188: LD_EXP 9
 192: PPUSH
 193: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 197: LD_EXP 11
 201: PPUSH
 202: LD_STRING DMegan-1a
 204: PPUSH
 205: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 209: LD_INT 10
 211: PPUSH
 212: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 216: LD_EXP 9
 220: PPUSH
 221: LD_EXP 11
 225: PPUSH
 226: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 230: LD_EXP 9
 234: PPUSH
 235: LD_STRING DBrighton-1a
 237: PPUSH
 238: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 242: LD_EXP 11
 246: PPUSH
 247: LD_STRING DMegan-2a
 249: PPUSH
 250: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 254: LD_EXP 9
 258: PPUSH
 259: LD_STRING DBrighton-2a
 261: PPUSH
 262: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 266: LD_EXP 11
 270: PPUSH
 271: LD_INT 40
 273: PPUSH
 274: LD_INT 37
 276: PPUSH
 277: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 281: LD_EXP 11
 285: PPUSH
 286: LD_EXP 9
 290: PPUSH
 291: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 295: LD_EXP 10
 299: PPUSH
 300: LD_INT 50
 302: PPUSH
 303: LD_INT 42
 305: PPUSH
 306: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 310: LD_INT 35
 312: PPUSH
 313: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 317: LD_EXP 9
 321: PPUSH
 322: LD_EXP 10
 326: PPUSH
 327: CALL_OW 296
 331: PUSH
 332: LD_INT 6
 334: LESS
 335: IFFALSE 310
// ComTurnUnit ( Brighton , Palmer ) ;
 337: LD_EXP 9
 341: PPUSH
 342: LD_EXP 10
 346: PPUSH
 347: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 351: LD_EXP 10
 355: PPUSH
 356: LD_EXP 9
 360: PPUSH
 361: CALL_OW 119
// Say ( Palmer , DPalmer-1 ) ;
 365: LD_EXP 10
 369: PPUSH
 370: LD_STRING DPalmer-1
 372: PPUSH
 373: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 377: LD_EXP 9
 381: PPUSH
 382: LD_STRING DBrighton-1
 384: PPUSH
 385: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 389: LD_EXP 10
 393: PPUSH
 394: LD_STRING DPalmer-2
 396: PPUSH
 397: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 401: LD_EXP 9
 405: PPUSH
 406: LD_STRING DBrighton-2
 408: PPUSH
 409: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 413: LD_EXP 10
 417: PPUSH
 418: LD_STRING DPalmer-3
 420: PPUSH
 421: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 425: LD_EXP 9
 429: PPUSH
 430: LD_STRING DBrighton-3
 432: PPUSH
 433: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 437: LD_EXP 10
 441: PPUSH
 442: LD_STRING DPalmer-4
 444: PPUSH
 445: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 449: LD_EXP 10
 453: PPUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 461: LD_INT 35
 463: PPUSH
 464: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 468: LD_EXP 10
 472: PPUSH
 473: CALL_OW 310
 477: PUSH
 478: LD_INT 6
 480: EQUAL
 481: IFFALSE 461
// SayRadio ( Palmer , DPalmer-5 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_STRING DPalmer-5
 490: PPUSH
 491: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 495: LD_EXP 9
 499: PPUSH
 500: LD_INT 59
 502: PPUSH
 503: LD_INT 36
 505: PPUSH
 506: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 510: LD_EXP 11
 514: PPUSH
 515: LD_INT 60
 517: PPUSH
 518: LD_INT 35
 520: PPUSH
 521: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 525: LD_EXP 10
 529: PPUSH
 530: LD_INT 60
 532: PPUSH
 533: LD_INT 34
 535: PPUSH
 536: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 540: LD_EXP 9
 544: PPUSH
 545: LD_INT 99
 547: PPUSH
 548: LD_INT 37
 550: PPUSH
 551: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 555: LD_EXP 11
 559: PPUSH
 560: LD_EXP 9
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 569: LD_EXP 10
 573: PPUSH
 574: LD_EXP 9
 578: PPUSH
 579: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 583: LD_INT 64
 585: PPUSH
 586: LD_INT 40
 588: PPUSH
 589: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 593: LD_EXP 12
 597: PPUSH
 598: LD_INT 13
 600: PPUSH
 601: CALL 12715 0 2
// wait ( 0 0$30 ) ;
 605: LD_INT 1050
 607: PPUSH
 608: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 612: LD_EXP 9
 616: PPUSH
 617: LD_STRING DBrighton-4
 619: PPUSH
 620: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 624: LD_EXP 9
 628: PPUSH
 629: LD_STRING DBrighton-5
 631: PPUSH
 632: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 636: LD_EXP 9
 640: PPUSH
 641: LD_EXP 11
 645: PPUSH
 646: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 650: LD_EXP 9
 654: PPUSH
 655: LD_STRING DBrighton-6
 657: PPUSH
 658: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 662: LD_EXP 11
 666: PPUSH
 667: LD_STRING DMegan-1
 669: PPUSH
 670: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 674: LD_EXP 9
 678: PPUSH
 679: LD_STRING DBrighton-7
 681: PPUSH
 682: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 686: LD_EXP 9
 690: PPUSH
 691: LD_INT 99
 693: PPUSH
 694: LD_INT 37
 696: PPUSH
 697: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 701: LD_EXP 9
 705: PPUSH
 706: LD_STRING DBrighton-8
 708: PPUSH
 709: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 713: LD_STRING C1
 715: PPUSH
 716: CALL_OW 337
// InGameOff ;
 720: CALL_OW 9
// SaveForQuickRestart ;
 724: CALL_OW 22
// MissionStart := true ;
 728: LD_ADDR_EXP 1
 732: PUSH
 733: LD_INT 1
 735: ST_TO_ADDR
// PrepareRUBase_v2 ;
 736: CALL 4719 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 740: LD_ADDR_EXP 66
 744: PUSH
 745: LD_EXP 66
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: PPUSH
 763: CALL_OW 69
 767: PPUSH
 768: CALL_OW 1
 772: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 773: LD_ADDR_EXP 66
 777: PUSH
 778: LD_EXP 66
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: LD_EXP 36
 790: PPUSH
 791: CALL_OW 1
 795: ST_TO_ADDR
// MC_Start ( ) ;
 796: CALL 52670 0 0
// music_nat := 1 ;
 800: LD_ADDR_OWVAR 71
 804: PUSH
 805: LD_INT 1
 807: ST_TO_ADDR
// end ;
 808: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var i , tmp ;
 809: LD_EXP 1
 813: IFFALSE 1237
 815: GO 817
 817: DISABLE
 818: LD_INT 0
 820: PPUSH
 821: PPUSH
// begin wait ( ruArrival ) ;
 822: LD_EXP 42
 826: PPUSH
 827: CALL_OW 67
// PrepareRUArmada ;
 831: CALL 3578 0 0
// wait ( 0 0$3 ) ;
 835: LD_INT 105
 837: PPUSH
 838: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 842: LD_ADDR_VAR 0 2
 846: PUSH
 847: LD_INT 15
 849: PPUSH
 850: LD_INT 0
 852: PPUSH
 853: CALL_OW 517
 857: ST_TO_ADDR
// for i = 1 to RUArmada do
 858: LD_ADDR_VAR 0 1
 862: PUSH
 863: DOUBLE
 864: LD_INT 1
 866: DEC
 867: ST_TO_ADDR
 868: LD_EXP 17
 872: PUSH
 873: FOR_TO
 874: IFFALSE 923
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 876: LD_EXP 17
 880: PUSH
 881: LD_VAR 0 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 1
 894: ARRAY
 895: PUSH
 896: LD_VAR 0 1
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 2
 909: ARRAY
 910: PUSH
 911: LD_VAR 0 1
 915: ARRAY
 916: PPUSH
 917: CALL_OW 111
 921: GO 873
 923: POP
 924: POP
// ArmadaArrived := true ;
 925: LD_ADDR_EXP 3
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 933: LD_EXP 10
 937: PPUSH
 938: LD_STRING DPalmer-A1
 940: PPUSH
 941: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 945: LD_EXP 9
 949: PPUSH
 950: LD_STRING DBrighton-A1
 952: PPUSH
 953: CALL_OW 88
// wait ( 0 0$20 ) ;
 957: LD_INT 700
 959: PPUSH
 960: CALL_OW 67
// PrepareRUBase ;
 964: CALL 4303 0 0
// wait ( 1 1$20 ) ;
 968: LD_INT 2800
 970: PPUSH
 971: CALL_OW 67
// PrepareRUBulldozers ;
 975: CALL 4190 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 979: LD_EXP 18
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: LD_INT 9
 990: PPUSH
 991: CALL 12572 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 995: LD_EXP 18
 999: PUSH
1000: LD_INT 2
1002: ARRAY
1003: PPUSH
1004: LD_INT 11
1006: PPUSH
1007: CALL 12572 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
1011: LD_INT 1
1013: PPUSH
1014: LD_EXP 18
1018: PUSH
1019: LD_INT 1
1021: ARRAY
1022: PPUSH
1023: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1027: LD_INT 1
1029: PPUSH
1030: LD_EXP 18
1034: PUSH
1035: LD_INT 2
1037: ARRAY
1038: PPUSH
1039: CALL_OW 471
// wait ( 1 1$20 ) ;
1043: LD_INT 2800
1045: PPUSH
1046: CALL_OW 67
// ComMoveXY ( Bulldozers , 64 , 114 ) ;
1050: LD_EXP 18
1054: PPUSH
1055: LD_INT 64
1057: PPUSH
1058: LD_INT 114
1060: PPUSH
1061: CALL_OW 111
// wait ( 0 0$10 ) ;
1065: LD_INT 350
1067: PPUSH
1068: CALL_OW 67
// for i := 1 to 2 do
1072: LD_ADDR_VAR 0 1
1076: PUSH
1077: DOUBLE
1078: LD_INT 1
1080: DEC
1081: ST_TO_ADDR
1082: LD_INT 2
1084: PUSH
1085: FOR_TO
1086: IFFALSE 1105
// RemoveUnit ( Bulldozers [ i ] ) ;
1088: LD_EXP 18
1092: PUSH
1093: LD_VAR 0 1
1097: ARRAY
1098: PPUSH
1099: CALL_OW 64
1103: GO 1085
1105: POP
1106: POP
// RemoveEnvironmentArea ( BulldozerArea ) ;
1107: LD_INT 9
1109: PPUSH
1110: CALL_OW 355
// RemoveEnvironmentArea ( BulldozerArea2 ) ;
1114: LD_INT 11
1116: PPUSH
1117: CALL_OW 355
// SayEffect ( DRuSol-A1 ) ;
1121: LD_STRING DRuSol-A1
1123: PPUSH
1124: CALL_OW 96
// AssaultStarted := true ;
1128: LD_ADDR_EXP 8
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// wait ( 0 0$2 ) ;
1136: LD_INT 70
1138: PPUSH
1139: CALL_OW 67
// Say ( Yashin , DDeath-Yas-1 ) ;
1143: LD_EXP 13
1147: PPUSH
1148: LD_STRING DDeath-Yas-1
1150: PPUSH
1151: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-2 ) ;
1155: LD_EXP 15
1159: PPUSH
1160: LD_STRING DDeath-Gay-2
1162: PPUSH
1163: CALL_OW 88
// wait ( 0 0$2 ) ;
1167: LD_INT 70
1169: PPUSH
1170: CALL_OW 67
// Say ( Popov , DDeath-Pop-1 ) ;
1174: LD_EXP 14
1178: PPUSH
1179: LD_STRING DDeath-Pop-1
1181: PPUSH
1182: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1186: LD_EXP 15
1190: PPUSH
1191: LD_STRING DDeath-Gay-1
1193: PPUSH
1194: CALL_OW 88
// wait ( 0 0$5 ) ;
1198: LD_INT 175
1200: PPUSH
1201: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1205: LD_EXP 16
1209: PPUSH
1210: LD_STRING DDeath-Vse-1
1212: PPUSH
1213: CALL_OW 88
// Say ( Popov , DDeath-Pop-2 ) ;
1217: LD_EXP 14
1221: PPUSH
1222: LD_STRING DDeath-Pop-2
1224: PPUSH
1225: CALL_OW 88
// southAreaBlocker = false ;
1229: LD_ADDR_EXP 2
1233: PUSH
1234: LD_INT 0
1236: ST_TO_ADDR
// end ;
1237: PPOPN 2
1239: END
// every 0 0$1 trigger AssaultStarted do var i , tmp ;
1240: LD_EXP 8
1244: IFFALSE 1835
1246: GO 1248
1248: DISABLE
1249: LD_INT 0
1251: PPUSH
1252: PPUSH
// begin PriorityAttack ( 6 , BetaA ) ;
1253: LD_INT 6
1255: PPUSH
1256: LD_INT 1
1258: PPUSH
1259: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1263: LD_INT 6
1265: PPUSH
1266: LD_INT 3
1268: PPUSH
1269: CALL_OW 470
// repeat for i in RuArmada do
1273: LD_ADDR_VAR 0 1
1277: PUSH
1278: LD_EXP 17
1282: PUSH
1283: FOR_IN
1284: IFFALSE 1487
// begin if GetDistUnitXY ( i , 87 , 77 ) < 10 and not GetTag ( i ) then
1286: LD_VAR 0 1
1290: PPUSH
1291: LD_INT 87
1293: PPUSH
1294: LD_INT 77
1296: PPUSH
1297: CALL_OW 297
1301: PUSH
1302: LD_INT 10
1304: LESS
1305: PUSH
1306: LD_VAR 0 1
1310: PPUSH
1311: CALL_OW 110
1315: NOT
1316: AND
1317: IFFALSE 1331
// SetTag ( i , 1 ) ;
1319: LD_VAR 0 1
1323: PPUSH
1324: LD_INT 1
1326: PPUSH
1327: CALL_OW 109
// if GetDistUnitXY ( i , 62 , 48 ) < 10 and GetTag ( i ) < 2 then
1331: LD_VAR 0 1
1335: PPUSH
1336: LD_INT 62
1338: PPUSH
1339: LD_INT 48
1341: PPUSH
1342: CALL_OW 297
1346: PUSH
1347: LD_INT 10
1349: LESS
1350: PUSH
1351: LD_VAR 0 1
1355: PPUSH
1356: CALL_OW 110
1360: PUSH
1361: LD_INT 2
1363: LESS
1364: AND
1365: IFFALSE 1379
// SetTag ( i , 2 ) ;
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_INT 2
1374: PPUSH
1375: CALL_OW 109
// if not GetTag ( i ) then
1379: LD_VAR 0 1
1383: PPUSH
1384: CALL_OW 110
1388: NOT
1389: IFFALSE 1406
// ComAgressiveMove ( i , 87 , 77 ) ;
1391: LD_VAR 0 1
1395: PPUSH
1396: LD_INT 87
1398: PPUSH
1399: LD_INT 77
1401: PPUSH
1402: CALL_OW 114
// if GetTag ( i ) = 1 then
1406: LD_VAR 0 1
1410: PPUSH
1411: CALL_OW 110
1415: PUSH
1416: LD_INT 1
1418: EQUAL
1419: IFFALSE 1436
// ComAgressiveMove ( i , 62 , 48 ) ;
1421: LD_VAR 0 1
1425: PPUSH
1426: LD_INT 62
1428: PPUSH
1429: LD_INT 48
1431: PPUSH
1432: CALL_OW 114
// if GetTag ( i ) = 2 then
1436: LD_VAR 0 1
1440: PPUSH
1441: CALL_OW 110
1445: PUSH
1446: LD_INT 2
1448: EQUAL
1449: IFFALSE 1485
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1451: LD_VAR 0 1
1455: PPUSH
1456: LD_INT 22
1458: PUSH
1459: LD_INT 1
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PPUSH
1466: CALL_OW 69
1470: PPUSH
1471: LD_VAR 0 1
1475: PPUSH
1476: CALL_OW 74
1480: PPUSH
1481: CALL_OW 115
// end ;
1485: GO 1283
1487: POP
1488: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1489: LD_INT 35
1491: PPUSH
1492: CALL_OW 67
1496: LD_INT 1
1498: PUSH
1499: LD_INT 22
1501: PUSH
1502: LD_INT 6
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: PUSH
1509: LD_INT 21
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: EMPTY
1516: LIST
1517: LIST
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PPUSH
1524: CALL_OW 69
1528: PUSH
1529: LD_INT 10
1531: LESS
1532: PUSH
1533: LD_EXP 13
1537: PPUSH
1538: CALL_OW 301
1542: AND
1543: PUSH
1544: LD_EXP 14
1548: PPUSH
1549: CALL_OW 301
1553: AND
1554: PUSH
1555: LD_EXP 15
1559: PPUSH
1560: CALL_OW 301
1564: AND
1565: PUSH
1566: LD_EXP 16
1570: PPUSH
1571: CALL_OW 301
1575: AND
1576: IFFALSE 1273
// AssaultStarted := false ;
1578: LD_ADDR_EXP 8
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 6 ] ) , RUArrivalArea ) ;
1586: LD_INT 22
1588: PUSH
1589: LD_INT 6
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PPUSH
1596: CALL_OW 69
1600: PPUSH
1601: LD_INT 5
1603: PPUSH
1604: CALL_OW 113
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1608: LD_ADDR_EXP 5
1612: PUSH
1613: LD_INT 1
1615: PUSH
1616: LD_INT 22
1618: PUSH
1619: LD_INT 6
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: LD_INT 26
1628: PUSH
1629: LD_INT 1
1631: PUSH
1632: EMPTY
1633: LIST
1634: LIST
1635: PUSH
1636: LD_INT 21
1638: PUSH
1639: LD_INT 1
1641: PUSH
1642: EMPTY
1643: LIST
1644: LIST
1645: PUSH
1646: LD_INT 24
1648: PUSH
1649: LD_INT 500
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: PPUSH
1663: CALL_OW 69
1667: ST_TO_ADDR
// if RuSpeaker then
1668: LD_EXP 5
1672: IFFALSE 1690
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1674: LD_EXP 5
1678: PUSH
1679: LD_INT 1
1681: ARRAY
1682: PPUSH
1683: LD_STRING DRuSol-A2
1685: PPUSH
1686: CALL_OW 88
// wait ( 0 0$30 ) ;
1690: LD_INT 1050
1692: PPUSH
1693: CALL_OW 67
// DialogueOn ;
1697: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1701: LD_EXP 9
1705: PPUSH
1706: LD_STRING DBrighton-B1
1708: PPUSH
1709: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1713: LD_EXP 10
1717: PPUSH
1718: LD_STRING DPalmer-B1
1720: PPUSH
1721: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1725: LD_EXP 9
1729: PPUSH
1730: LD_STRING DBrighton-B2
1732: PPUSH
1733: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1737: LD_EXP 19
1741: PPUSH
1742: LD_STRING DBurlak-B1
1744: PPUSH
1745: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1749: LD_EXP 9
1753: PPUSH
1754: LD_STRING DBrighton-B3
1756: PPUSH
1757: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1761: LD_EXP 10
1765: PPUSH
1766: LD_STRING DPalmer-B2
1768: PPUSH
1769: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1773: LD_EXP 9
1777: PPUSH
1778: LD_STRING DBrighton-B4
1780: PPUSH
1781: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1785: LD_EXP 9
1789: PPUSH
1790: LD_STRING DBrighton-B5
1792: PPUSH
1793: CALL_OW 88
// DialogueOff ;
1797: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1801: LD_STRING C2
1803: PPUSH
1804: CALL_OW 337
// FirstAssaultRepelled := true ;
1808: LD_ADDR_EXP 4
1812: PUSH
1813: LD_INT 1
1815: ST_TO_ADDR
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1816: LD_INT 22
1818: PUSH
1819: LD_INT 6
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 69
1830: PPUSH
1831: CALL_OW 181
// end ;
1835: PPOPN 2
1837: END
// every 0 0$1 trigger FirstAssaultRepelled do var unit , insideUnit ;
1838: LD_EXP 4
1842: IFFALSE 2007
1844: GO 1846
1846: DISABLE
1847: LD_INT 0
1849: PPUSH
1850: PPUSH
// begin enable ;
1851: ENABLE
// if FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) = 0 then
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 22
1857: PUSH
1858: LD_INT 6
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: PPUSH
1868: CALL_OW 70
1872: PUSH
1873: LD_INT 0
1875: EQUAL
1876: IFFALSE 1880
// exit ;
1878: GO 2007
// for unit in FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) do
1880: LD_ADDR_VAR 0 1
1884: PUSH
1885: LD_INT 5
1887: PPUSH
1888: LD_INT 22
1890: PUSH
1891: LD_INT 6
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: PUSH
1898: EMPTY
1899: LIST
1900: PPUSH
1901: CALL_OW 70
1905: PUSH
1906: FOR_IN
1907: IFFALSE 2005
// begin SetSide ( unit , 3 ) ;
1909: LD_VAR 0 1
1913: PPUSH
1914: LD_INT 3
1916: PPUSH
1917: CALL_OW 235
// if ( GetType ( unit ) = unit_vehicle ) then
1921: LD_VAR 0 1
1925: PPUSH
1926: CALL_OW 247
1930: PUSH
1931: LD_INT 2
1933: EQUAL
1934: IFFALSE 1970
// for insideUnit in UnitsInside ( unit ) do
1936: LD_ADDR_VAR 0 2
1940: PUSH
1941: LD_VAR 0 1
1945: PPUSH
1946: CALL_OW 313
1950: PUSH
1951: FOR_IN
1952: IFFALSE 1968
// SetSide ( insideUnit , 3 ) ;
1954: LD_VAR 0 2
1958: PPUSH
1959: LD_INT 3
1961: PPUSH
1962: CALL_OW 235
1966: GO 1951
1968: POP
1969: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
1970: LD_ADDR_EXP 66
1974: PUSH
1975: LD_EXP 66
1979: PPUSH
1980: LD_INT 1
1982: PPUSH
1983: LD_INT 22
1985: PUSH
1986: LD_INT 3
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: PPUSH
1993: CALL_OW 69
1997: PPUSH
1998: CALL_OW 1
2002: ST_TO_ADDR
// end ;
2003: GO 1906
2005: POP
2006: POP
// end ;
2007: PPOPN 2
2009: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
2010: LD_EXP 4
2014: PUSH
2015: LD_EXP 41
2019: PUSH
2020: LD_INT 0
2022: GREATER
2023: AND
2024: IFFALSE 2044
2026: GO 2028
2028: DISABLE
// begin enable ;
2029: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
2030: LD_ADDR_EXP 41
2034: PUSH
2035: LD_EXP 41
2039: PUSH
2040: LD_INT 35
2042: MINUS
2043: ST_TO_ADDR
// end ;
2044: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
2045: LD_EXP 41
2049: PUSH
2050: LD_INT 0
2052: EQUAL
2053: IFFALSE 2159
2055: GO 2057
2057: DISABLE
// begin JMMReinforcement ;
2058: CALL 5047 0 0
// DialogueOn ;
2062: CALL_OW 6
// CenterOnUnits ( JMM ) ;
2066: LD_EXP 37
2070: PPUSH
2071: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
2075: LD_EXP 37
2079: PPUSH
2080: LD_STRING DJMM-F1
2082: PPUSH
2083: CALL_OW 88
// if RussiansDefeated then
2087: LD_EXP 44
2091: IFFALSE 2117
// begin AddMedal ( Russians , 1 ) ;
2093: LD_STRING Russians
2095: PPUSH
2096: LD_INT 1
2098: PPUSH
2099: CALL_OW 101
// Say ( Brighton , DBrighton-F1a ) ;
2103: LD_EXP 9
2107: PPUSH
2108: LD_STRING DBrighton-F1a
2110: PPUSH
2111: CALL_OW 88
// end else
2115: GO 2147
// begin AddMedal ( Russians , - 1 ) ;
2117: LD_STRING Russians
2119: PPUSH
2120: LD_INT 1
2122: NEG
2123: PPUSH
2124: CALL_OW 101
// Say ( Brighton , DBrighton-F1 ) ;
2128: LD_EXP 9
2132: PPUSH
2133: LD_STRING DBrighton-F1
2135: PPUSH
2136: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2140: LD_STRING C3
2142: PPUSH
2143: CALL_OW 337
// end ; DialogueOff ;
2147: CALL_OW 7
// JMM_Arrived := true ;
2151: LD_ADDR_EXP 6
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// end ;
2159: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2160: LD_EXP 6
2164: PUSH
2165: LD_INT 1
2167: PPUSH
2168: LD_EXP 19
2172: PPUSH
2173: CALL_OW 292
2177: AND
2178: IFFALSE 2207
2180: GO 2182
2182: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2183: LD_EXP 19
2187: PPUSH
2188: LD_STRING DBurlak
2190: PPUSH
2191: CALL_OW 88
// Say ( JMM , DJMM ) ;
2195: LD_EXP 37
2199: PPUSH
2200: LD_STRING DJMM
2202: PPUSH
2203: CALL_OW 88
// end ;
2207: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2208: LD_INT 1
2210: PUSH
2211: LD_INT 22
2213: PUSH
2214: LD_INT 1
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PUSH
2221: LD_INT 2
2223: PUSH
2224: LD_INT 34
2226: PUSH
2227: LD_INT 9
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: PUSH
2234: LD_INT 35
2236: PUSH
2237: LD_INT 9
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: PUSH
2259: LD_INT 1
2261: GREATER
2262: IFFALSE 2275
2264: GO 2266
2266: DISABLE
// LaserBuilt := true ;
2267: LD_ADDR_EXP 7
2271: PUSH
2272: LD_INT 1
2274: ST_TO_ADDR
2275: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2276: LD_EXP 8
2280: PUSH
2281: LD_INT 6
2283: PPUSH
2284: LD_INT 1
2286: PUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: LD_INT 35
2299: PUSH
2300: LD_INT 9
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PUSH
2307: EMPTY
2308: LIST
2309: LIST
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PPUSH
2320: LD_EXP 16
2324: PPUSH
2325: CALL_OW 310
2329: PPUSH
2330: CALL_OW 74
2334: PPUSH
2335: CALL_OW 292
2339: AND
2340: IFFALSE 2369
2342: GO 2344
2344: DISABLE
// begin Say ( Sevi , DDeath-Vse-2 ) ;
2345: LD_EXP 16
2349: PPUSH
2350: LD_STRING DDeath-Vse-2
2352: PPUSH
2353: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2357: LD_EXP 13
2361: PPUSH
2362: LD_STRING DDeath-Yas-2
2364: PPUSH
2365: CALL_OW 88
// end ;
2369: END
// every 0 0$1 trigger MissionStart and GetResourceArea ( CratesArea , mat_cans ) < 20 do
2370: LD_EXP 1
2374: PUSH
2375: LD_INT 12
2377: PPUSH
2378: LD_INT 1
2380: PPUSH
2381: CALL_OW 287
2385: PUSH
2386: LD_INT 20
2388: LESS
2389: AND
2390: IFFALSE 2432
2392: GO 2394
2394: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2395: LD_INT 1750
2397: PPUSH
2398: LD_INT 4900
2400: PPUSH
2401: CALL_OW 12
2405: PPUSH
2406: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2410: LD_INT 2
2412: PPUSH
2413: LD_INT 5
2415: PPUSH
2416: CALL_OW 12
2420: PPUSH
2421: LD_INT 12
2423: PPUSH
2424: LD_INT 1
2426: PPUSH
2427: CALL_OW 55
// enable ;
2431: ENABLE
// end ;
2432: END
// every 0 0$1 trigger FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) do var un , x , y ;
2433: LD_INT 17
2435: PPUSH
2436: LD_INT 81
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PPUSH
2446: CALL_OW 70
2450: IFFALSE 2576
2452: GO 2454
2454: DISABLE
2455: LD_INT 0
2457: PPUSH
2458: PPUSH
2459: PPUSH
// begin un := FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) [ 1 ] ;
2460: LD_ADDR_VAR 0 1
2464: PUSH
2465: LD_INT 17
2467: PPUSH
2468: LD_INT 81
2470: PUSH
2471: LD_INT 1
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: PPUSH
2478: CALL_OW 70
2482: PUSH
2483: LD_INT 1
2485: ARRAY
2486: ST_TO_ADDR
// x := GetX ( un ) ;
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: LD_VAR 0 1
2496: PPUSH
2497: CALL_OW 250
2501: ST_TO_ADDR
// y := GetY ( un ) ;
2502: LD_ADDR_VAR 0 3
2506: PUSH
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 251
2516: ST_TO_ADDR
// PlaceSeeing ( x , y , 1 , - 12 ) ;
2517: LD_VAR 0 2
2521: PPUSH
2522: LD_VAR 0 3
2526: PPUSH
2527: LD_INT 1
2529: PPUSH
2530: LD_INT 12
2532: NEG
2533: PPUSH
2534: CALL_OW 330
// CenterNowOnUnits ( un ) ;
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 87
// Say ( Brighton , DBrighton-E1 ) ;
2547: LD_EXP 9
2551: PPUSH
2552: LD_STRING DBrighton-E1
2554: PPUSH
2555: CALL_OW 88
// RemoveSeeing ( x , y , 1 ) ;
2559: LD_VAR 0 2
2563: PPUSH
2564: LD_VAR 0 3
2568: PPUSH
2569: LD_INT 1
2571: PPUSH
2572: CALL_OW 331
// end ;
2576: PPOPN 3
2578: END
// every 0 0$1 trigger MissionStart do
2579: LD_EXP 1
2583: IFFALSE 2606
2585: GO 2587
2587: DISABLE
// begin enable ;
2588: ENABLE
// display_Strings := [ #tick , tick ] ;
2589: LD_ADDR_OWVAR 47
2593: PUSH
2594: LD_STRING #tick
2596: PUSH
2597: LD_OWVAR 1
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: ST_TO_ADDR
// end ; end_of_file
2606: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2607: LD_INT 0
2609: PPUSH
// uc_side := 1 ;
2610: LD_ADDR_OWVAR 20
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// hc_class = class_soldier ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 1
2625: ST_TO_ADDR
// uc_nation := nation_american ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_sex = sex_male ;
2634: LD_ADDR_OWVAR 27
2638: PUSH
2639: LD_INT 1
2641: ST_TO_ADDR
// hc_importance = 110 ;
2642: LD_ADDR_OWVAR 32
2646: PUSH
2647: LD_INT 110
2649: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2650: LD_ADDR_OWVAR 30
2654: PUSH
2655: LD_INT 5
2657: PUSH
2658: LD_INT 4
2660: PUSH
2661: LD_INT 5
2663: PUSH
2664: LD_INT 3
2666: PUSH
2667: EMPTY
2668: LIST
2669: LIST
2670: LIST
2671: LIST
2672: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2673: LD_ADDR_OWVAR 31
2677: PUSH
2678: LD_INT 9
2680: PUSH
2681: LD_INT 6
2683: PUSH
2684: LD_INT 7
2686: PUSH
2687: LD_INT 6
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: LIST
2695: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2696: LD_ADDR_OWVAR 29
2700: PUSH
2701: LD_INT 12
2703: PUSH
2704: LD_INT 10
2706: PUSH
2707: EMPTY
2708: LIST
2709: LIST
2710: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING Gerard Brighton
2718: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2719: LD_ADDR_OWVAR 33
2723: PUSH
2724: LD_STRING Beta_Skirmish
2726: ST_TO_ADDR
// hc_face_number := 1 ;
2727: LD_ADDR_OWVAR 34
2731: PUSH
2732: LD_INT 1
2734: ST_TO_ADDR
// Brighton := CreateHuman ;
2735: LD_ADDR_EXP 9
2739: PUSH
2740: CALL_OW 44
2744: ST_TO_ADDR
// uc_nation := nation_american ;
2745: LD_ADDR_OWVAR 21
2749: PUSH
2750: LD_INT 1
2752: ST_TO_ADDR
// hc_importance = 80 ;
2753: LD_ADDR_OWVAR 32
2757: PUSH
2758: LD_INT 80
2760: ST_TO_ADDR
// hc_sex = sex_male ;
2761: LD_ADDR_OWVAR 27
2765: PUSH
2766: LD_INT 1
2768: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2769: LD_ADDR_OWVAR 30
2773: PUSH
2774: LD_INT 5
2776: PUSH
2777: LD_INT 5
2779: PUSH
2780: LD_INT 3
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: LIST
2790: LIST
2791: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2792: LD_ADDR_OWVAR 31
2796: PUSH
2797: LD_INT 7
2799: PUSH
2800: LD_INT 6
2802: PUSH
2803: LD_INT 5
2805: PUSH
2806: LD_INT 3
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2815: LD_ADDR_OWVAR 29
2819: PUSH
2820: LD_INT 10
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: ST_TO_ADDR
// hc_name := Brian Palmer ;
2830: LD_ADDR_OWVAR 26
2834: PUSH
2835: LD_STRING Brian Palmer
2837: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2838: LD_ADDR_OWVAR 33
2842: PUSH
2843: LD_STRING Beta_Skirmish
2845: ST_TO_ADDR
// hc_face_number := 3 ;
2846: LD_ADDR_OWVAR 34
2850: PUSH
2851: LD_INT 3
2853: ST_TO_ADDR
// Palmer := CreateHuman ;
2854: LD_ADDR_EXP 10
2858: PUSH
2859: CALL_OW 44
2863: ST_TO_ADDR
// hc_class = class_scientistic ;
2864: LD_ADDR_OWVAR 28
2868: PUSH
2869: LD_INT 4
2871: ST_TO_ADDR
// uc_nation := nation_american ;
2872: LD_ADDR_OWVAR 21
2876: PUSH
2877: LD_INT 1
2879: ST_TO_ADDR
// hc_importance = 70 ;
2880: LD_ADDR_OWVAR 32
2884: PUSH
2885: LD_INT 70
2887: ST_TO_ADDR
// hc_sex = sex_female ;
2888: LD_ADDR_OWVAR 27
2892: PUSH
2893: LD_INT 2
2895: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2896: LD_ADDR_OWVAR 30
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 2
2906: PUSH
2907: LD_INT 4
2909: PUSH
2910: LD_INT 6
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: LIST
2917: LIST
2918: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2919: LD_ADDR_OWVAR 31
2923: PUSH
2924: LD_INT 4
2926: PUSH
2927: LD_INT 2
2929: PUSH
2930: LD_INT 5
2932: PUSH
2933: LD_INT 8
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2942: LD_ADDR_OWVAR 29
2946: PUSH
2947: LD_INT 10
2949: PUSH
2950: LD_INT 10
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: ST_TO_ADDR
// hc_name := Megan Armitage ;
2957: LD_ADDR_OWVAR 26
2961: PUSH
2962: LD_STRING Megan Armitage
2964: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2965: LD_ADDR_OWVAR 33
2969: PUSH
2970: LD_STRING Beta_Skirmish
2972: ST_TO_ADDR
// hc_face_number := 4 ;
2973: LD_ADDR_OWVAR 34
2977: PUSH
2978: LD_INT 4
2980: ST_TO_ADDR
// Megan := CreateHuman ;
2981: LD_ADDR_EXP 11
2985: PUSH
2986: CALL_OW 44
2990: ST_TO_ADDR
// end ;
2991: LD_VAR 0 1
2995: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
2996: LD_INT 0
2998: PPUSH
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
// uc_side := 1 ;
3003: LD_ADDR_OWVAR 20
3007: PUSH
3008: LD_INT 1
3010: ST_TO_ADDR
// uc_nation := nation_american ;
3011: LD_ADDR_OWVAR 21
3015: PUSH
3016: LD_INT 1
3018: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
3019: LD_ADDR_VAR 0 2
3023: PUSH
3024: LD_INT 22
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 30
3036: PUSH
3037: LD_INT 32
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PPUSH
3048: CALL_OW 69
3052: PUSH
3053: FOR_IN
3054: IFFALSE 3109
// PlaceWeaponTurret ( i , [ us_light_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
3056: LD_VAR 0 2
3060: PPUSH
3061: LD_INT 3
3063: PUSH
3064: LD_INT 3
3066: PUSH
3067: LD_INT 4
3069: PUSH
3070: LD_INT 5
3072: PUSH
3073: LD_INT 11
3075: PUSH
3076: LD_INT 3
3078: PUSH
3079: LD_INT 4
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 1
3093: PPUSH
3094: LD_INT 7
3096: PPUSH
3097: CALL_OW 12
3101: ARRAY
3102: PPUSH
3103: CALL_OW 431
3107: GO 3053
3109: POP
3110: POP
// hc_name :=  ;
3111: LD_ADDR_OWVAR 26
3115: PUSH
3116: LD_STRING 
3118: ST_TO_ADDR
// hc_gallery :=  ;
3119: LD_ADDR_OWVAR 33
3123: PUSH
3124: LD_STRING 
3126: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
3127: LD_ADDR_VAR 0 2
3131: PUSH
3132: DOUBLE
3133: LD_INT 1
3135: DEC
3136: ST_TO_ADDR
3137: LD_INT 6
3139: PUSH
3140: LD_INT 5
3142: PUSH
3143: LD_INT 5
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_OWVAR 67
3155: ARRAY
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3216
// begin PrepareSoldier ( 1 , game_skill ) ;
3160: LD_INT 1
3162: PPUSH
3163: LD_EXP 39
3167: PPUSH
3168: CALL_OW 381
// un := CreateHuman ;
3172: LD_ADDR_VAR 0 4
3176: PUSH
3177: CALL_OW 44
3181: ST_TO_ADDR
// filter := filter ^ un ;
3182: LD_ADDR_VAR 0 3
3186: PUSH
3187: LD_VAR 0 3
3191: PUSH
3192: LD_VAR 0 4
3196: ADD
3197: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3198: LD_ADDR_VAR 0 5
3202: PUSH
3203: LD_VAR 0 5
3207: PUSH
3208: LD_VAR 0 4
3212: ADD
3213: ST_TO_ADDR
// end ;
3214: GO 3157
3216: POP
3217: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
3218: LD_ADDR_VAR 0 2
3222: PUSH
3223: DOUBLE
3224: LD_INT 1
3226: DEC
3227: ST_TO_ADDR
3228: LD_INT 3
3230: PUSH
3231: LD_INT 2
3233: PUSH
3234: LD_INT 2
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PUSH
3242: LD_OWVAR 67
3246: ARRAY
3247: PUSH
3248: FOR_TO
3249: IFFALSE 3303
// begin PrepareEngineer ( 0 , game_skill ) ;
3251: LD_INT 0
3253: PPUSH
3254: LD_EXP 39
3258: PPUSH
3259: CALL_OW 382
// un := CreateHuman ;
3263: LD_ADDR_VAR 0 4
3267: PUSH
3268: CALL_OW 44
3272: ST_TO_ADDR
// filter := filter ^ un ;
3273: LD_ADDR_VAR 0 3
3277: PUSH
3278: LD_VAR 0 3
3282: PUSH
3283: LD_VAR 0 4
3287: ADD
3288: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3289: LD_VAR 0 4
3293: PPUSH
3294: LD_INT 3
3296: PPUSH
3297: CALL_OW 52
// end ;
3301: GO 3248
3303: POP
3304: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3305: LD_ADDR_VAR 0 2
3309: PUSH
3310: DOUBLE
3311: LD_INT 1
3313: DEC
3314: ST_TO_ADDR
3315: LD_INT 4
3317: PUSH
3318: LD_INT 3
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: PUSH
3335: FOR_TO
3336: IFFALSE 3390
// begin PrepareMechanic ( 0 , game_skill ) ;
3338: LD_INT 0
3340: PPUSH
3341: LD_EXP 39
3345: PPUSH
3346: CALL_OW 383
// un := CreateHuman ;
3350: LD_ADDR_VAR 0 4
3354: PUSH
3355: CALL_OW 44
3359: ST_TO_ADDR
// filter := filter ^ un ;
3360: LD_ADDR_VAR 0 3
3364: PUSH
3365: LD_VAR 0 3
3369: PUSH
3370: LD_VAR 0 4
3374: ADD
3375: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3376: LD_VAR 0 4
3380: PPUSH
3381: LD_INT 8
3383: PPUSH
3384: CALL_OW 52
// end ;
3388: GO 3335
3390: POP
3391: POP
// for i = 1 to 2 do
3392: LD_ADDR_VAR 0 2
3396: PUSH
3397: DOUBLE
3398: LD_INT 1
3400: DEC
3401: ST_TO_ADDR
3402: LD_INT 2
3404: PUSH
3405: FOR_TO
3406: IFFALSE 3460
// begin PrepareScientist ( 0 , game_skill ) ;
3408: LD_INT 0
3410: PPUSH
3411: LD_EXP 39
3415: PPUSH
3416: CALL_OW 384
// un := CreateHuman ;
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: CALL_OW 44
3429: ST_TO_ADDR
// filter := filter ^ un ;
3430: LD_ADDR_VAR 0 3
3434: PUSH
3435: LD_VAR 0 3
3439: PUSH
3440: LD_VAR 0 4
3444: ADD
3445: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_INT 14
3453: PPUSH
3454: CALL_OW 52
// end ;
3458: GO 3405
3460: POP
3461: POP
// for i = 1 to soldiers do
3462: LD_ADDR_VAR 0 2
3466: PUSH
3467: DOUBLE
3468: LD_INT 1
3470: DEC
3471: ST_TO_ADDR
3472: LD_VAR 0 5
3476: PUSH
3477: FOR_TO
3478: IFFALSE 3503
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3480: LD_VAR 0 5
3484: PUSH
3485: LD_VAR 0 2
3489: ARRAY
3490: PPUSH
3491: LD_INT 1
3493: PPUSH
3494: LD_INT 0
3496: PPUSH
3497: CALL_OW 49
3501: GO 3477
3503: POP
3504: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3505: LD_EXP 9
3509: PPUSH
3510: LD_INT 51
3512: PPUSH
3513: LD_INT 43
3515: PPUSH
3516: LD_INT 0
3518: PPUSH
3519: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3523: LD_EXP 10
3527: PPUSH
3528: LD_INT 55
3530: PPUSH
3531: LD_INT 58
3533: PPUSH
3534: LD_INT 0
3536: PPUSH
3537: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3541: LD_EXP 11
3545: PPUSH
3546: LD_INT 39
3548: PPUSH
3549: LD_INT 36
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// BetaSquad := filter diff 0 ;
3559: LD_ADDR_EXP 12
3563: PUSH
3564: LD_VAR 0 3
3568: PUSH
3569: LD_INT 0
3571: DIFF
3572: ST_TO_ADDR
// end ;
3573: LD_VAR 0 1
3577: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3578: LD_INT 0
3580: PPUSH
3581: PPUSH
3582: PPUSH
3583: PPUSH
3584: PPUSH
3585: PPUSH
// uc_side := 6 ;
3586: LD_ADDR_OWVAR 20
3590: PUSH
3591: LD_INT 6
3593: ST_TO_ADDR
// uc_nation := nation_russian ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// soldiers := [ ] ;
3602: LD_ADDR_VAR 0 4
3606: PUSH
3607: EMPTY
3608: ST_TO_ADDR
// vehs := [ ] ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: EMPTY
3615: ST_TO_ADDR
// RUArmada := [ ] ;
3616: LD_ADDR_EXP 17
3620: PUSH
3621: EMPTY
3622: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3623: LD_ADDR_EXP 13
3627: PUSH
3628: LD_STRING Yashin
3630: PPUSH
3631: CALL_OW 25
3635: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3636: LD_ADDR_EXP 14
3640: PUSH
3641: LD_STRING Popov
3643: PPUSH
3644: CALL_OW 25
3648: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3649: LD_ADDR_EXP 15
3653: PUSH
3654: LD_STRING Gaydar
3656: PPUSH
3657: CALL_OW 25
3661: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3662: LD_ADDR_EXP 16
3666: PUSH
3667: LD_STRING Vsevolod
3669: PPUSH
3670: CALL_OW 25
3674: ST_TO_ADDR
// for i = 1 to 16 do
3675: LD_ADDR_VAR 0 2
3679: PUSH
3680: DOUBLE
3681: LD_INT 1
3683: DEC
3684: ST_TO_ADDR
3685: LD_INT 16
3687: PUSH
3688: FOR_TO
3689: IFFALSE 3731
// begin PrepareSoldier ( 0 , game_eskill ) ;
3691: LD_INT 0
3693: PPUSH
3694: LD_EXP 40
3698: PPUSH
3699: CALL_OW 381
// un := CreateHuman ;
3703: LD_ADDR_VAR 0 5
3707: PUSH
3708: CALL_OW 44
3712: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3713: LD_ADDR_VAR 0 4
3717: PUSH
3718: LD_VAR 0 4
3722: PUSH
3723: LD_VAR 0 5
3727: ADD
3728: ST_TO_ADDR
// end ;
3729: GO 3688
3731: POP
3732: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: LD_EXP 13
3742: PUSH
3743: LD_EXP 14
3747: ADD
3748: PUSH
3749: LD_EXP 15
3753: ADD
3754: PUSH
3755: LD_EXP 16
3759: ADD
3760: PUSH
3761: LD_VAR 0 4
3765: ADD
3766: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3767: LD_INT 24
3769: PPUSH
3770: LD_INT 3
3772: PPUSH
3773: LD_INT 1
3775: PPUSH
3776: LD_INT 46
3778: PPUSH
3779: LD_INT 100
3781: PPUSH
3782: CALL 18426 0 5
// for i = 1 to 8 do
3786: LD_ADDR_VAR 0 2
3790: PUSH
3791: DOUBLE
3792: LD_INT 1
3794: DEC
3795: ST_TO_ADDR
3796: LD_INT 8
3798: PUSH
3799: FOR_TO
3800: IFFALSE 3883
// begin vehicle := CreateVehicle ;
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: CALL_OW 45
3811: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3812: LD_VAR 0 4
3816: PUSH
3817: LD_INT 1
3819: ARRAY
3820: PPUSH
3821: LD_VAR 0 3
3825: PPUSH
3826: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3830: LD_ADDR_VAR 0 4
3834: PUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_VAR 0 4
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: DIFF
3849: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3850: LD_VAR 0 3
3854: PPUSH
3855: LD_INT 5
3857: PPUSH
3858: LD_INT 0
3860: PPUSH
3861: CALL_OW 49
// vehs := vehs ^ vehicle ;
3865: LD_ADDR_VAR 0 6
3869: PUSH
3870: LD_VAR 0 6
3874: PUSH
3875: LD_VAR 0 3
3879: ADD
3880: ST_TO_ADDR
// end ;
3881: GO 3799
3883: POP
3884: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3885: LD_INT 24
3887: PPUSH
3888: LD_INT 3
3890: PPUSH
3891: LD_INT 1
3893: PPUSH
3894: LD_INT 43
3896: PPUSH
3897: LD_INT 100
3899: PPUSH
3900: CALL 18426 0 5
// for i = 1 to 8 do
3904: LD_ADDR_VAR 0 2
3908: PUSH
3909: DOUBLE
3910: LD_INT 1
3912: DEC
3913: ST_TO_ADDR
3914: LD_INT 8
3916: PUSH
3917: FOR_TO
3918: IFFALSE 4001
// begin vehicle := CreateVehicle ;
3920: LD_ADDR_VAR 0 3
3924: PUSH
3925: CALL_OW 45
3929: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3930: LD_VAR 0 4
3934: PUSH
3935: LD_INT 1
3937: ARRAY
3938: PPUSH
3939: LD_VAR 0 3
3943: PPUSH
3944: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3948: LD_ADDR_VAR 0 4
3952: PUSH
3953: LD_VAR 0 4
3957: PUSH
3958: LD_VAR 0 4
3962: PUSH
3963: LD_INT 1
3965: ARRAY
3966: DIFF
3967: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3968: LD_VAR 0 3
3972: PPUSH
3973: LD_INT 5
3975: PPUSH
3976: LD_INT 0
3978: PPUSH
3979: CALL_OW 49
// vehs := vehs ^ vehicle ;
3983: LD_ADDR_VAR 0 6
3987: PUSH
3988: LD_VAR 0 6
3992: PUSH
3993: LD_VAR 0 3
3997: ADD
3998: ST_TO_ADDR
// end ;
3999: GO 3917
4001: POP
4002: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
4003: LD_INT 22
4005: PPUSH
4006: LD_INT 3
4008: PPUSH
4009: LD_INT 1
4011: PPUSH
4012: LD_INT 44
4014: PPUSH
4015: LD_INT 100
4017: PPUSH
4018: CALL 18426 0 5
// for i = 1 to 4 do
4022: LD_ADDR_VAR 0 2
4026: PUSH
4027: DOUBLE
4028: LD_INT 1
4030: DEC
4031: ST_TO_ADDR
4032: LD_INT 4
4034: PUSH
4035: FOR_TO
4036: IFFALSE 4119
// begin vehicle := CreateVehicle ;
4038: LD_ADDR_VAR 0 3
4042: PUSH
4043: CALL_OW 45
4047: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4048: LD_VAR 0 4
4052: PUSH
4053: LD_INT 1
4055: ARRAY
4056: PPUSH
4057: LD_VAR 0 3
4061: PPUSH
4062: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4066: LD_ADDR_VAR 0 4
4070: PUSH
4071: LD_VAR 0 4
4075: PUSH
4076: LD_VAR 0 4
4080: PUSH
4081: LD_INT 1
4083: ARRAY
4084: DIFF
4085: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_INT 5
4093: PPUSH
4094: LD_INT 0
4096: PPUSH
4097: CALL_OW 49
// vehs := vehs ^ vehicle ;
4101: LD_ADDR_VAR 0 6
4105: PUSH
4106: LD_VAR 0 6
4110: PUSH
4111: LD_VAR 0 3
4115: ADD
4116: ST_TO_ADDR
// end ;
4117: GO 4035
4119: POP
4120: POP
// RUArmada := vehs ;
4121: LD_ADDR_EXP 17
4125: PUSH
4126: LD_VAR 0 6
4130: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
4131: LD_EXP 13
4135: PPUSH
4136: CALL_OW 310
4140: PUSH
4141: LD_EXP 14
4145: PPUSH
4146: CALL_OW 310
4150: PUSH
4151: LD_EXP 15
4155: PPUSH
4156: CALL_OW 310
4160: PUSH
4161: LD_EXP 16
4165: PPUSH
4166: CALL_OW 310
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: LIST
4176: PPUSH
4177: LD_INT 6
4179: NEG
4180: PPUSH
4181: CALL_OW 242
// end ;
4185: LD_VAR 0 1
4189: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
4190: LD_INT 0
4192: PPUSH
4193: PPUSH
4194: PPUSH
// uc_side := 6 ;
4195: LD_ADDR_OWVAR 20
4199: PUSH
4200: LD_INT 6
4202: ST_TO_ADDR
// uc_nation := nation_russian ;
4203: LD_ADDR_OWVAR 21
4207: PUSH
4208: LD_INT 3
4210: ST_TO_ADDR
// Bulldozers := [ ] ;
4211: LD_ADDR_EXP 18
4215: PUSH
4216: EMPTY
4217: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
4218: LD_INT 24
4220: PPUSH
4221: LD_INT 3
4223: PPUSH
4224: LD_INT 3
4226: PPUSH
4227: LD_INT 53
4229: PPUSH
4230: LD_INT 100
4232: PPUSH
4233: CALL 18426 0 5
// for i = 1 to 2 do
4237: LD_ADDR_VAR 0 2
4241: PUSH
4242: DOUBLE
4243: LD_INT 1
4245: DEC
4246: ST_TO_ADDR
4247: LD_INT 2
4249: PUSH
4250: FOR_TO
4251: IFFALSE 4296
// begin vehicle := CreateVehicle ;
4253: LD_ADDR_VAR 0 3
4257: PUSH
4258: CALL_OW 45
4262: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4263: LD_VAR 0 3
4267: PPUSH
4268: LD_INT 5
4270: PPUSH
4271: LD_INT 0
4273: PPUSH
4274: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4278: LD_ADDR_EXP 18
4282: PUSH
4283: LD_EXP 18
4287: PUSH
4288: LD_VAR 0 3
4292: ADD
4293: ST_TO_ADDR
// end ;
4294: GO 4250
4296: POP
4297: POP
// end ;
4298: LD_VAR 0 1
4302: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4303: LD_INT 0
4305: PPUSH
4306: PPUSH
4307: PPUSH
4308: PPUSH
// uc_side := 3 ;
4309: LD_ADDR_OWVAR 20
4313: PUSH
4314: LD_INT 3
4316: ST_TO_ADDR
// uc_nation := nation_russian ;
4317: LD_ADDR_OWVAR 21
4321: PUSH
4322: LD_INT 3
4324: ST_TO_ADDR
// hc_name :=  ;
4325: LD_ADDR_OWVAR 26
4329: PUSH
4330: LD_STRING 
4332: ST_TO_ADDR
// hc_gallery :=  ;
4333: LD_ADDR_OWVAR 33
4337: PUSH
4338: LD_STRING 
4340: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4341: LD_ADDR_EXP 19
4345: PUSH
4346: LD_STRING Burlak
4348: PPUSH
4349: CALL_OW 25
4353: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4354: LD_ADDR_EXP 20
4358: PUSH
4359: LD_STRING Gleb
4361: PPUSH
4362: CALL_OW 25
4366: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4367: LD_ADDR_EXP 21
4371: PUSH
4372: LD_STRING Furmanov
4374: PPUSH
4375: CALL_OW 25
4379: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4380: LD_ADDR_EXP 22
4384: PUSH
4385: LD_STRING Titov
4387: PPUSH
4388: CALL_OW 25
4392: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4393: LD_ADDR_EXP 23
4397: PUSH
4398: LD_STRING Scholtze
4400: PPUSH
4401: CALL_OW 25
4405: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4406: LD_ADDR_EXP 24
4410: PUSH
4411: LD_STRING Dolgov
4413: PPUSH
4414: CALL_OW 25
4418: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4419: LD_ADDR_EXP 25
4423: PUSH
4424: LD_STRING Kapitsova
4426: PPUSH
4427: CALL_OW 25
4431: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4432: LD_ADDR_EXP 26
4436: PUSH
4437: LD_STRING Karamazov
4439: PPUSH
4440: CALL_OW 25
4444: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4445: LD_ADDR_EXP 27
4449: PUSH
4450: LD_STRING Kirlenkova
4452: PPUSH
4453: CALL_OW 25
4457: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4458: LD_ADDR_EXP 28
4462: PUSH
4463: LD_STRING Kovalyuk
4465: PPUSH
4466: CALL_OW 25
4470: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4471: LD_ADDR_EXP 29
4475: PUSH
4476: LD_STRING Kozlov
4478: PPUSH
4479: CALL_OW 25
4483: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4484: LD_ADDR_EXP 30
4488: PUSH
4489: LD_STRING Kuzmov
4491: PPUSH
4492: CALL_OW 25
4496: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4497: LD_ADDR_EXP 31
4501: PUSH
4502: LD_STRING Lipshchin
4504: PPUSH
4505: CALL_OW 25
4509: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4510: LD_ADDR_EXP 32
4514: PUSH
4515: LD_STRING Oblukov
4517: PPUSH
4518: CALL_OW 25
4522: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4523: LD_ADDR_EXP 33
4527: PUSH
4528: LD_STRING Xavier2
4530: PPUSH
4531: CALL_OW 25
4535: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4536: LD_ADDR_EXP 34
4540: PUSH
4541: LD_STRING Gnyevko
4543: PPUSH
4544: CALL_OW 25
4548: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4549: LD_ADDR_EXP 35
4553: PUSH
4554: LD_STRING Belkov
4556: PPUSH
4557: CALL_OW 25
4561: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4562: LD_ADDR_VAR 0 3
4566: PUSH
4567: LD_EXP 19
4571: PUSH
4572: LD_EXP 20
4576: PUSH
4577: LD_EXP 21
4581: PUSH
4582: LD_EXP 22
4586: PUSH
4587: LD_EXP 23
4591: PUSH
4592: LD_EXP 24
4596: PUSH
4597: LD_EXP 25
4601: PUSH
4602: LD_EXP 26
4606: PUSH
4607: LD_EXP 27
4611: PUSH
4612: LD_EXP 28
4616: PUSH
4617: LD_EXP 29
4621: PUSH
4622: LD_EXP 30
4626: PUSH
4627: LD_EXP 31
4631: PUSH
4632: LD_EXP 32
4636: PUSH
4637: LD_EXP 33
4641: PUSH
4642: LD_EXP 34
4646: PUSH
4647: LD_EXP 35
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ST_TO_ADDR
// for i = 1 to filter do
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: DOUBLE
4677: LD_INT 1
4679: DEC
4680: ST_TO_ADDR
4681: LD_VAR 0 3
4685: PUSH
4686: FOR_TO
4687: IFFALSE 4712
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4689: LD_VAR 0 3
4693: PUSH
4694: LD_VAR 0 2
4698: ARRAY
4699: PPUSH
4700: LD_INT 6
4702: PPUSH
4703: LD_INT 0
4705: PPUSH
4706: CALL_OW 49
4710: GO 4686
4712: POP
4713: POP
// end ;
4714: LD_VAR 0 1
4718: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4719: LD_INT 0
4721: PPUSH
4722: PPUSH
4723: PPUSH
4724: PPUSH
// uc_side := 3 ;
4725: LD_ADDR_OWVAR 20
4729: PUSH
4730: LD_INT 3
4732: ST_TO_ADDR
// uc_nation := nation_russian ;
4733: LD_ADDR_OWVAR 21
4737: PUSH
4738: LD_INT 3
4740: ST_TO_ADDR
// hc_name :=  ;
4741: LD_ADDR_OWVAR 26
4745: PUSH
4746: LD_STRING 
4748: ST_TO_ADDR
// hc_gallery :=  ;
4749: LD_ADDR_OWVAR 33
4753: PUSH
4754: LD_STRING 
4756: ST_TO_ADDR
// for i = 1 to 8 do
4757: LD_ADDR_VAR 0 2
4761: PUSH
4762: DOUBLE
4763: LD_INT 1
4765: DEC
4766: ST_TO_ADDR
4767: LD_INT 8
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4813
// begin PrepareSoldier ( 0 , game_eskill ) ;
4773: LD_INT 0
4775: PPUSH
4776: LD_EXP 40
4780: PPUSH
4781: CALL_OW 381
// un := CreateHuman ;
4785: LD_ADDR_VAR 0 4
4789: PUSH
4790: CALL_OW 44
4794: ST_TO_ADDR
// filter := filter ^ un ;
4795: LD_ADDR_VAR 0 3
4799: PUSH
4800: LD_VAR 0 3
4804: PUSH
4805: LD_VAR 0 4
4809: ADD
4810: ST_TO_ADDR
// end ;
4811: GO 4770
4813: POP
4814: POP
// for i = 1 to 4 do
4815: LD_ADDR_VAR 0 2
4819: PUSH
4820: DOUBLE
4821: LD_INT 1
4823: DEC
4824: ST_TO_ADDR
4825: LD_INT 4
4827: PUSH
4828: FOR_TO
4829: IFFALSE 4871
// begin PrepareEngineer ( 0 , game_eskill ) ;
4831: LD_INT 0
4833: PPUSH
4834: LD_EXP 40
4838: PPUSH
4839: CALL_OW 382
// un := CreateHuman ;
4843: LD_ADDR_VAR 0 4
4847: PUSH
4848: CALL_OW 44
4852: ST_TO_ADDR
// filter := filter ^ un ;
4853: LD_ADDR_VAR 0 3
4857: PUSH
4858: LD_VAR 0 3
4862: PUSH
4863: LD_VAR 0 4
4867: ADD
4868: ST_TO_ADDR
// end ;
4869: GO 4828
4871: POP
4872: POP
// for i = 1 to 6 do
4873: LD_ADDR_VAR 0 2
4877: PUSH
4878: DOUBLE
4879: LD_INT 1
4881: DEC
4882: ST_TO_ADDR
4883: LD_INT 6
4885: PUSH
4886: FOR_TO
4887: IFFALSE 4929
// begin PrepareMechanic ( 0 , game_eskill ) ;
4889: LD_INT 0
4891: PPUSH
4892: LD_EXP 40
4896: PPUSH
4897: CALL_OW 383
// un := CreateHuman ;
4901: LD_ADDR_VAR 0 4
4905: PUSH
4906: CALL_OW 44
4910: ST_TO_ADDR
// filter := filter ^ un ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_VAR 0 3
4920: PUSH
4921: LD_VAR 0 4
4925: ADD
4926: ST_TO_ADDR
// end ;
4927: GO 4886
4929: POP
4930: POP
// for i = 1 to 4 do
4931: LD_ADDR_VAR 0 2
4935: PUSH
4936: DOUBLE
4937: LD_INT 1
4939: DEC
4940: ST_TO_ADDR
4941: LD_INT 4
4943: PUSH
4944: FOR_TO
4945: IFFALSE 4987
// begin PrepareScientist ( 0 , game_eskill ) ;
4947: LD_INT 0
4949: PPUSH
4950: LD_EXP 40
4954: PPUSH
4955: CALL_OW 384
// un := CreateHuman ;
4959: LD_ADDR_VAR 0 4
4963: PUSH
4964: CALL_OW 44
4968: ST_TO_ADDR
// filter := filter ^ un ;
4969: LD_ADDR_VAR 0 3
4973: PUSH
4974: LD_VAR 0 3
4978: PUSH
4979: LD_VAR 0 4
4983: ADD
4984: ST_TO_ADDR
// end ;
4985: GO 4944
4987: POP
4988: POP
// for i = 1 to filter do
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: DOUBLE
4995: LD_INT 1
4997: DEC
4998: ST_TO_ADDR
4999: LD_VAR 0 3
5003: PUSH
5004: FOR_TO
5005: IFFALSE 5030
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
5007: LD_VAR 0 3
5011: PUSH
5012: LD_VAR 0 2
5016: ARRAY
5017: PPUSH
5018: LD_INT 6
5020: PPUSH
5021: LD_INT 0
5023: PPUSH
5024: CALL_OW 49
5028: GO 5004
5030: POP
5031: POP
// RU_SecondPersonnel := filter ;
5032: LD_ADDR_EXP 36
5036: PUSH
5037: LD_VAR 0 3
5041: ST_TO_ADDR
// end ;
5042: LD_VAR 0 1
5046: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
5047: LD_INT 0
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
5055: PPUSH
// uc_side := 1 ;
5056: LD_ADDR_OWVAR 20
5060: PUSH
5061: LD_INT 1
5063: ST_TO_ADDR
// uc_nation := nation_american ;
5064: LD_ADDR_OWVAR 21
5068: PUSH
5069: LD_INT 1
5071: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
5072: LD_ADDR_EXP 37
5076: PUSH
5077: LD_STRING JMM
5079: PPUSH
5080: CALL_OW 25
5084: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
5085: LD_EXP 37
5089: PPUSH
5090: LD_INT 1
5092: PPUSH
5093: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
5097: LD_EXP 37
5101: PPUSH
5102: LD_INT 7
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 49
// mechs := [ ] ;
5112: LD_ADDR_VAR 0 7
5116: PUSH
5117: EMPTY
5118: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
5119: LD_ADDR_VAR 0 2
5123: PUSH
5124: DOUBLE
5125: LD_INT 1
5127: DEC
5128: ST_TO_ADDR
5129: LD_INT 4
5131: PUSH
5132: LD_INT 3
5134: PUSH
5135: LD_INT 3
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: LIST
5142: PUSH
5143: LD_OWVAR 67
5147: ARRAY
5148: PUSH
5149: FOR_TO
5150: IFFALSE 5211
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_EXP 39
5159: PUSH
5160: LD_INT 1
5162: PLUS
5163: PPUSH
5164: CALL_OW 381
// un := CreateHuman ;
5168: LD_ADDR_VAR 0 4
5172: PUSH
5173: CALL_OW 44
5177: ST_TO_ADDR
// soldiers := soldiers ^ un ;
5178: LD_ADDR_VAR 0 3
5182: PUSH
5183: LD_VAR 0 3
5187: PUSH
5188: LD_VAR 0 4
5192: ADD
5193: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
5194: LD_VAR 0 4
5198: PPUSH
5199: LD_INT 7
5201: PPUSH
5202: LD_INT 0
5204: PPUSH
5205: CALL_OW 49
// end ;
5209: GO 5149
5211: POP
5212: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5213: LD_ADDR_VAR 0 2
5217: PUSH
5218: DOUBLE
5219: LD_INT 1
5221: DEC
5222: ST_TO_ADDR
5223: LD_INT 7
5225: PUSH
5226: LD_INT 6
5228: PUSH
5229: LD_INT 4
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: LIST
5236: PUSH
5237: LD_OWVAR 67
5241: ARRAY
5242: PUSH
5243: FOR_TO
5244: IFFALSE 5290
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5246: LD_INT 0
5248: PPUSH
5249: LD_EXP 39
5253: PUSH
5254: LD_INT 1
5256: PLUS
5257: PPUSH
5258: CALL_OW 383
// un := CreateHuman ;
5262: LD_ADDR_VAR 0 4
5266: PUSH
5267: CALL_OW 44
5271: ST_TO_ADDR
// mechs := mechs ^ un ;
5272: LD_ADDR_VAR 0 7
5276: PUSH
5277: LD_VAR 0 7
5281: PUSH
5282: LD_VAR 0 4
5286: ADD
5287: ST_TO_ADDR
// end ;
5288: GO 5243
5290: POP
5291: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5292: LD_INT 3
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 1
5300: PPUSH
5301: LD_INT 5
5303: PPUSH
5304: LD_INT 100
5306: PPUSH
5307: CALL 18426 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5311: LD_ADDR_VAR 0 2
5315: PUSH
5316: DOUBLE
5317: LD_INT 1
5319: DEC
5320: ST_TO_ADDR
5321: LD_INT 7
5323: PUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 4
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: LIST
5334: PUSH
5335: LD_OWVAR 67
5339: ARRAY
5340: PUSH
5341: FOR_TO
5342: IFFALSE 5437
// begin vehicle := CreateVehicle ;
5344: LD_ADDR_VAR 0 6
5348: PUSH
5349: CALL_OW 45
5353: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5354: LD_VAR 0 7
5358: PUSH
5359: LD_INT 1
5361: ARRAY
5362: PPUSH
5363: LD_VAR 0 6
5367: PPUSH
5368: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5372: LD_ADDR_VAR 0 7
5376: PUSH
5377: LD_VAR 0 7
5381: PUSH
5382: LD_VAR 0 7
5386: PUSH
5387: LD_INT 1
5389: ARRAY
5390: DIFF
5391: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5392: LD_VAR 0 6
5396: PPUSH
5397: LD_INT 1
5399: PPUSH
5400: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5404: LD_VAR 0 6
5408: PPUSH
5409: LD_INT 7
5411: PPUSH
5412: LD_INT 0
5414: PPUSH
5415: CALL_OW 49
// vehs := vehs ^ vehicle ;
5419: LD_ADDR_VAR 0 5
5423: PUSH
5424: LD_VAR 0 5
5428: PUSH
5429: LD_VAR 0 6
5433: ADD
5434: ST_TO_ADDR
// end ;
5435: GO 5341
5437: POP
5438: POP
// end ; end_of_file
5439: LD_VAR 0 1
5443: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export startCrates ; export function GameType ; var i , ruStartTechs ; begin
5444: LD_INT 0
5446: PPUSH
5447: PPUSH
5448: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5449: LD_ADDR_OWVAR 67
5453: PUSH
5454: LD_INT 0
5456: PPUSH
5457: CALL_OW 426
5461: ST_TO_ADDR
// game_diff := Difficulty ;
5462: LD_ADDR_EXP 38
5466: PUSH
5467: LD_OWVAR 67
5471: ST_TO_ADDR
// game_skill := [ 7 , 6 , 5 ] [ game_diff ] ;
5472: LD_ADDR_EXP 39
5476: PUSH
5477: LD_INT 7
5479: PUSH
5480: LD_INT 6
5482: PUSH
5483: LD_INT 5
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: LD_EXP 38
5495: ARRAY
5496: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5497: LD_ADDR_EXP 40
5501: PUSH
5502: LD_INT 6
5504: PUSH
5505: LD_INT 7
5507: PUSH
5508: LD_INT 8
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_EXP 38
5520: ARRAY
5521: ST_TO_ADDR
// ruArrival := [ 3 3$00 , 2 2$00 , 1 1$00 ] [ game_diff ] ;
5522: LD_ADDR_EXP 42
5526: PUSH
5527: LD_INT 6300
5529: PUSH
5530: LD_INT 4200
5532: PUSH
5533: LD_INT 2100
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: LIST
5540: PUSH
5541: LD_EXP 38
5545: ARRAY
5546: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5547: LD_ADDR_EXP 41
5551: PUSH
5552: LD_INT 73500
5554: PUSH
5555: LD_INT 94500
5557: PUSH
5558: LD_INT 115500
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: PUSH
5566: LD_EXP 38
5570: ARRAY
5571: ST_TO_ADDR
// ruStartTechs = [ [ tech_Weap1 ] , [ tech_Weap1 , tech_Comp1 ] , [ tech_Weap1 , tech_Weap2 , tech_Comp1 ] ] ;
5572: LD_ADDR_VAR 0 3
5576: PUSH
5577: LD_INT 51
5579: PUSH
5580: EMPTY
5581: LIST
5582: PUSH
5583: LD_INT 51
5585: PUSH
5586: LD_INT 57
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 51
5595: PUSH
5596: LD_INT 52
5598: PUSH
5599: LD_INT 57
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: ST_TO_ADDR
// startCrates = [ [ 300 , 350 ] , [ 230 , 200 ] , [ 150 , 100 ] ] [ game_diff ] ;
5612: LD_ADDR_EXP 43
5616: PUSH
5617: LD_INT 300
5619: PUSH
5620: LD_INT 350
5622: PUSH
5623: EMPTY
5624: LIST
5625: LIST
5626: PUSH
5627: LD_INT 230
5629: PUSH
5630: LD_INT 200
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 150
5639: PUSH
5640: LD_INT 100
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_EXP 38
5656: ARRAY
5657: ST_TO_ADDR
// for i := 1 to ruStartTechs [ game_diff ] do
5658: LD_ADDR_VAR 0 2
5662: PUSH
5663: DOUBLE
5664: LD_INT 1
5666: DEC
5667: ST_TO_ADDR
5668: LD_VAR 0 3
5672: PUSH
5673: LD_EXP 38
5677: ARRAY
5678: PUSH
5679: FOR_TO
5680: IFFALSE 5738
// begin SetTech ( ruStartTechs [ game_diff ] [ i ] , 3 , state_researched ) ;
5682: LD_VAR 0 3
5686: PUSH
5687: LD_EXP 38
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: LD_INT 3
5701: PPUSH
5702: LD_INT 2
5704: PPUSH
5705: CALL_OW 322
// SetTech ( ruStartTechs [ game_diff ] [ i ] , 6 , state_researched ) ;
5709: LD_VAR 0 3
5713: PUSH
5714: LD_EXP 38
5718: ARRAY
5719: PUSH
5720: LD_VAR 0 2
5724: ARRAY
5725: PPUSH
5726: LD_INT 6
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 322
// end ;
5736: GO 5679
5738: POP
5739: POP
// end ; end_of_file
5740: LD_VAR 0 1
5744: RET
// export function CustomEvent ( event ) ; begin
5745: LD_INT 0
5747: PPUSH
// end ;
5748: LD_VAR 0 2
5752: RET
// export function CustomInitMacro ( ) ; begin
5753: LD_INT 0
5755: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5756: LD_INT 1
5758: PPUSH
5759: LD_INT 3
5761: PPUSH
5762: CALL 75510 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5766: LD_INT 1
5768: PPUSH
5769: LD_INT 4
5771: PPUSH
5772: CALL 75454 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5776: LD_INT 1
5778: PPUSH
5779: LD_INT 136
5781: PUSH
5782: LD_INT 130
5784: PUSH
5785: LD_INT 0
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 145
5795: PUSH
5796: LD_INT 123
5798: PUSH
5799: LD_INT 0
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: CALL 74513 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5815: LD_INT 1
5817: PPUSH
5818: LD_INT 43
5820: PUSH
5821: LD_INT 46
5823: PUSH
5824: LD_INT 45
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PPUSH
5832: CALL 75342 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5836: LD_INT 1
5838: PPUSH
5839: LD_INT 3
5841: PPUSH
5842: CALL 75024 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5846: LD_INT 1
5848: PPUSH
5849: LD_INT 3
5851: PPUSH
5852: CALL 74755 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5856: LD_INT 1
5858: PPUSH
5859: LD_INT 8
5861: PPUSH
5862: CALL 74374 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5866: LD_INT 1
5868: PPUSH
5869: LD_INT 22
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: LD_INT 3
5877: PUSH
5878: LD_INT 43
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: PUSH
5887: LD_INT 22
5889: PUSH
5890: LD_INT 1
5892: PUSH
5893: LD_INT 3
5895: PUSH
5896: LD_INT 44
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 22
5907: PUSH
5908: LD_INT 1
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: LD_INT 45
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: PUSH
5923: LD_INT 24
5925: PUSH
5926: LD_INT 1
5928: PUSH
5929: LD_INT 3
5931: PUSH
5932: LD_INT 43
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_INT 24
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 3
5949: PUSH
5950: LD_INT 43
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 24
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: LD_INT 3
5967: PUSH
5968: LD_INT 46
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: PUSH
5977: LD_INT 22
5979: PUSH
5980: LD_INT 1
5982: PUSH
5983: LD_INT 3
5985: PUSH
5986: LD_INT 43
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 22
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: LD_INT 3
6003: PUSH
6004: LD_INT 44
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: LIST
6011: LIST
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PPUSH
6023: CALL 74189 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
6027: LD_INT 1
6029: PPUSH
6030: LD_INT 0
6032: PUSH
6033: LD_INT 127
6035: PUSH
6036: LD_INT 125
6038: PUSH
6039: LD_INT 5
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 6
6050: PUSH
6051: LD_INT 124
6053: PUSH
6054: LD_INT 132
6056: PUSH
6057: LD_INT 0
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 29
6068: PUSH
6069: LD_INT 136
6071: PUSH
6072: LD_INT 130
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 4
6086: PUSH
6087: LD_INT 118
6089: PUSH
6090: LD_INT 114
6092: PUSH
6093: LD_INT 2
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 29
6104: PUSH
6105: LD_INT 145
6107: PUSH
6108: LD_INT 123
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 26
6122: PUSH
6123: LD_INT 150
6125: PUSH
6126: LD_INT 135
6128: PUSH
6129: LD_INT 1
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 26
6140: PUSH
6141: LD_INT 140
6143: PUSH
6144: LD_INT 134
6146: PUSH
6147: LD_INT 2
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_INT 26
6158: PUSH
6159: LD_INT 137
6161: PUSH
6162: LD_INT 121
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 2
6176: PUSH
6177: LD_INT 155
6179: PUSH
6180: LD_INT 130
6182: PUSH
6183: LD_INT 0
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 32
6194: PUSH
6195: LD_INT 155
6197: PUSH
6198: LD_INT 130
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 32
6212: PUSH
6213: LD_INT 130
6215: PUSH
6216: LD_INT 114
6218: PUSH
6219: LD_INT 3
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 32
6230: PUSH
6231: LD_INT 142
6233: PUSH
6234: LD_INT 115
6236: PUSH
6237: LD_INT 3
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 32
6248: PUSH
6249: LD_INT 153
6251: PUSH
6252: LD_INT 120
6254: PUSH
6255: LD_INT 3
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: PPUSH
6279: CALL 74081 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
6283: LD_INT 1
6285: PPUSH
6286: LD_INT 10
6288: PUSH
6289: LD_INT 12
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: PPUSH
6296: CALL 74931 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6300: LD_INT 1
6302: PPUSH
6303: LD_INT 155
6305: PPUSH
6306: LD_INT 130
6308: PPUSH
6309: LD_INT 0
6311: PPUSH
6312: LD_INT 24
6314: PUSH
6315: LD_INT 16
6317: PUSH
6318: LD_INT 17
6320: PUSH
6321: LD_INT 18
6323: PUSH
6324: LD_INT 21
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL 75136 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
6338: LD_INT 2
6340: PPUSH
6341: LD_INT 3
6343: PPUSH
6344: CALL 75510 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 4
6353: PPUSH
6354: CALL 75454 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
6358: LD_INT 2
6360: PPUSH
6361: LD_INT 84
6363: PUSH
6364: LD_INT 125
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: EMPTY
6376: LIST
6377: PPUSH
6378: CALL 74513 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
6382: LD_INT 2
6384: PPUSH
6385: LD_INT 43
6387: PUSH
6388: LD_INT 46
6390: PUSH
6391: LD_INT 45
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: LIST
6398: PPUSH
6399: CALL 75342 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
6403: LD_INT 2
6405: PPUSH
6406: LD_INT 3
6408: PPUSH
6409: CALL 75024 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6413: LD_INT 2
6415: PPUSH
6416: LD_INT 3
6418: PPUSH
6419: CALL 74755 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6423: LD_INT 2
6425: PPUSH
6426: LD_INT 8
6428: PPUSH
6429: CALL 74374 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6433: LD_INT 2
6435: PPUSH
6436: LD_INT 22
6438: PUSH
6439: LD_INT 3
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: LD_INT 43
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 22
6456: PUSH
6457: LD_INT 3
6459: PUSH
6460: LD_INT 3
6462: PUSH
6463: LD_INT 44
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 22
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: LD_INT 3
6480: PUSH
6481: LD_INT 45
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 24
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 43
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 24
6510: PUSH
6511: LD_INT 3
6513: PUSH
6514: LD_INT 3
6516: PUSH
6517: LD_INT 43
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 24
6528: PUSH
6529: LD_INT 3
6531: PUSH
6532: LD_INT 3
6534: PUSH
6535: LD_INT 46
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 22
6546: PUSH
6547: LD_INT 3
6549: PUSH
6550: LD_INT 3
6552: PUSH
6553: LD_INT 43
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 22
6564: PUSH
6565: LD_INT 3
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 44
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: LIST
6588: LIST
6589: PPUSH
6590: CALL 74189 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6594: LD_INT 2
6596: PPUSH
6597: LD_INT 0
6599: PUSH
6600: LD_INT 96
6602: PUSH
6603: LD_INT 125
6605: PUSH
6606: LD_INT 0
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 6
6617: PUSH
6618: LD_INT 74
6620: PUSH
6621: LD_INT 122
6623: PUSH
6624: LD_INT 1
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 30
6635: PUSH
6636: LD_INT 84
6638: PUSH
6639: LD_INT 125
6641: PUSH
6642: LD_INT 1
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 28
6653: PUSH
6654: LD_INT 86
6656: PUSH
6657: LD_INT 128
6659: PUSH
6660: LD_INT 1
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 28
6671: PUSH
6672: LD_INT 85
6674: PUSH
6675: LD_INT 130
6677: PUSH
6678: LD_INT 2
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 28
6689: PUSH
6690: LD_INT 88
6692: PUSH
6693: LD_INT 132
6695: PUSH
6696: LD_INT 5
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: LD_INT 2
6707: PUSH
6708: LD_INT 106
6710: PUSH
6711: LD_INT 130
6713: PUSH
6714: LD_INT 0
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 4
6725: PUSH
6726: LD_INT 99
6728: PUSH
6729: LD_INT 114
6731: PUSH
6732: LD_INT 3
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: PUSH
6741: LD_INT 32
6743: PUSH
6744: LD_INT 72
6746: PUSH
6747: LD_INT 112
6749: PUSH
6750: LD_INT 2
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 32
6761: PUSH
6762: LD_INT 78
6764: PUSH
6765: LD_INT 110
6767: PUSH
6768: LD_INT 3
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: PUSH
6777: LD_INT 32
6779: PUSH
6780: LD_INT 84
6782: PUSH
6783: LD_INT 110
6785: PUSH
6786: LD_INT 2
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: PUSH
6795: LD_INT 32
6797: PUSH
6798: LD_INT 105
6800: PUSH
6801: LD_INT 117
6803: PUSH
6804: LD_INT 3
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: LIST
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL 74081 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6831: LD_INT 2
6833: PPUSH
6834: LD_INT 14
6836: PUSH
6837: LD_INT 11
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PPUSH
6844: CALL 74931 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6848: LD_INT 2
6850: PPUSH
6851: LD_INT 106
6853: PPUSH
6854: LD_INT 130
6856: PPUSH
6857: LD_INT 0
6859: PPUSH
6860: LD_INT 24
6862: PUSH
6863: LD_INT 16
6865: PUSH
6866: LD_INT 17
6868: PUSH
6869: LD_INT 18
6871: PUSH
6872: LD_INT 21
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: LIST
6879: LIST
6880: LIST
6881: PPUSH
6882: CALL 75136 0 5
// end ;
6886: LD_VAR 0 1
6890: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6891: LD_INT 22
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 30
6903: PUSH
6904: LD_INT 3
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PPUSH
6915: CALL_OW 69
6919: IFFALSE 8062
6921: GO 6923
6923: DISABLE
6924: LD_INT 0
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
6931: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
6932: LD_INT 6300
6934: PUSH
6935: LD_INT 4200
6937: PUSH
6938: LD_INT 2100
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: LIST
6945: PUSH
6946: LD_OWVAR 67
6950: ARRAY
6951: PPUSH
6952: CALL_OW 67
// base := 2 ;
6956: LD_ADDR_VAR 0 2
6960: PUSH
6961: LD_INT 2
6963: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
6964: LD_INT 22
6966: PUSH
6967: LD_INT 3
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 30
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PPUSH
6988: CALL_OW 69
6992: NOT
6993: IFFALSE 6997
// continue ;
6995: GO 6932
// case Rand ( 1 , 3 ) of 1 :
6997: LD_INT 1
6999: PPUSH
7000: LD_INT 3
7002: PPUSH
7003: CALL_OW 12
7007: PUSH
7008: LD_INT 1
7010: DOUBLE
7011: EQUAL
7012: IFTRUE 7016
7014: GO 7192
7016: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7017: LD_ADDR_VAR 0 3
7021: PUSH
7022: LD_INT 22
7024: PUSH
7025: LD_INT 3
7027: PUSH
7028: LD_INT 3
7030: PUSH
7031: LD_INT 43
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 24
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 3
7048: PUSH
7049: LD_INT 46
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 24
7060: PUSH
7061: LD_INT 3
7063: PUSH
7064: LD_INT 3
7066: PUSH
7067: LD_INT 43
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 24
7078: PUSH
7079: LD_INT 3
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: LD_INT 46
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PUSH
7094: LD_INT 22
7096: PUSH
7097: LD_INT 3
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 45
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: LD_INT 3
7120: PUSH
7121: LD_INT 43
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: PUSH
7130: LD_INT 24
7132: PUSH
7133: LD_INT 3
7135: PUSH
7136: LD_INT 3
7138: PUSH
7139: LD_INT 46
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: PUSH
7148: LD_INT 22
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 3
7156: PUSH
7157: LD_INT 45
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7176: LD_VAR 0 2
7180: PPUSH
7181: LD_VAR 0 3
7185: PPUSH
7186: CALL 74237 0 2
// end ; 2 :
7190: GO 7523
7192: LD_INT 2
7194: DOUBLE
7195: EQUAL
7196: IFTRUE 7200
7198: GO 7338
7200: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7201: LD_ADDR_VAR 0 3
7205: PUSH
7206: LD_INT 24
7208: PUSH
7209: LD_INT 3
7211: PUSH
7212: LD_INT 3
7214: PUSH
7215: LD_INT 43
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: PUSH
7224: LD_INT 24
7226: PUSH
7227: LD_INT 3
7229: PUSH
7230: LD_INT 3
7232: PUSH
7233: LD_INT 46
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: PUSH
7242: LD_INT 24
7244: PUSH
7245: LD_INT 3
7247: PUSH
7248: LD_INT 3
7250: PUSH
7251: LD_INT 43
7253: PUSH
7254: EMPTY
7255: LIST
7256: LIST
7257: LIST
7258: LIST
7259: PUSH
7260: LD_INT 24
7262: PUSH
7263: LD_INT 3
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: LD_INT 46
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: PUSH
7278: LD_INT 22
7280: PUSH
7281: LD_INT 3
7283: PUSH
7284: LD_INT 3
7286: PUSH
7287: LD_INT 45
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 22
7298: PUSH
7299: LD_INT 3
7301: PUSH
7302: LD_INT 3
7304: PUSH
7305: LD_INT 45
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: LIST
7318: LIST
7319: LIST
7320: LIST
7321: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7322: LD_VAR 0 2
7326: PPUSH
7327: LD_VAR 0 3
7331: PPUSH
7332: CALL 74237 0 2
// end ; 3 :
7336: GO 7523
7338: LD_INT 3
7340: DOUBLE
7341: EQUAL
7342: IFTRUE 7346
7344: GO 7522
7346: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7347: LD_ADDR_VAR 0 3
7351: PUSH
7352: LD_INT 22
7354: PUSH
7355: LD_INT 3
7357: PUSH
7358: LD_INT 3
7360: PUSH
7361: LD_INT 43
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 24
7372: PUSH
7373: LD_INT 3
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: LD_INT 46
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: LD_INT 3
7396: PUSH
7397: LD_INT 43
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: LD_INT 24
7408: PUSH
7409: LD_INT 3
7411: PUSH
7412: LD_INT 3
7414: PUSH
7415: LD_INT 46
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_INT 3
7429: PUSH
7430: LD_INT 3
7432: PUSH
7433: LD_INT 45
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: LD_INT 22
7444: PUSH
7445: LD_INT 3
7447: PUSH
7448: LD_INT 3
7450: PUSH
7451: LD_INT 43
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 24
7462: PUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: LD_INT 46
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: LIST
7476: LIST
7477: PUSH
7478: LD_INT 22
7480: PUSH
7481: LD_INT 3
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 45
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7506: LD_VAR 0 2
7510: PPUSH
7511: LD_VAR 0 3
7515: PPUSH
7516: CALL 74237 0 2
// end ; end ;
7520: GO 7523
7522: POP
// repeat wait ( 0 0$1 ) ;
7523: LD_INT 35
7525: PPUSH
7526: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7530: LD_VAR 0 2
7534: PPUSH
7535: CALL 74585 0 1
7539: PUSH
7540: LD_INT 0
7542: EQUAL
7543: IFFALSE 7523
// wait ( 0 0$30 ) ;
7545: LD_INT 1050
7547: PPUSH
7548: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7552: LD_ADDR_VAR 0 5
7556: PUSH
7557: LD_INT 86
7559: PUSH
7560: LD_INT 77
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 63
7569: PUSH
7570: LD_INT 38
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7581: LD_ADDR_VAR 0 4
7585: PUSH
7586: LD_INT 0
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: LD_INT 0
7594: PUSH
7595: LD_INT 1
7597: PUSH
7598: LD_INT 0
7600: PUSH
7601: LD_INT 0
7603: PUSH
7604: LD_INT 0
7606: PUSH
7607: LD_INT 0
7609: PUSH
7610: LD_INT 1
7612: PUSH
7613: LD_INT 0
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7628: LD_ADDR_VAR 0 6
7632: PUSH
7633: LD_EXP 85
7637: PUSH
7638: LD_VAR 0 2
7642: ARRAY
7643: PUSH
7644: LD_EXP 88
7648: PUSH
7649: LD_VAR 0 2
7653: ARRAY
7654: DIFF
7655: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7656: LD_ADDR_EXP 85
7660: PUSH
7661: LD_EXP 85
7665: PPUSH
7666: LD_VAR 0 2
7670: PPUSH
7671: LD_EXP 85
7675: PUSH
7676: LD_VAR 0 2
7680: ARRAY
7681: PUSH
7682: LD_VAR 0 6
7686: DIFF
7687: PPUSH
7688: CALL_OW 1
7692: ST_TO_ADDR
// if not attackers then
7693: LD_VAR 0 6
7697: NOT
7698: IFFALSE 7702
// continue ;
7700: GO 6932
// repeat wait ( 0 0$1 ) ;
7702: LD_INT 35
7704: PPUSH
7705: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7709: LD_VAR 0 6
7713: PPUSH
7714: LD_INT 60
7716: PUSH
7717: EMPTY
7718: LIST
7719: PPUSH
7720: CALL_OW 72
7724: NOT
7725: IFFALSE 7702
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// for i in attackers do
7734: LD_ADDR_VAR 0 1
7738: PUSH
7739: LD_VAR 0 6
7743: PUSH
7744: FOR_IN
7745: IFFALSE 8029
// begin if IsDead ( i ) then
7747: LD_VAR 0 1
7751: PPUSH
7752: CALL_OW 301
7756: IFFALSE 7774
// attackers := attackers diff i ;
7758: LD_ADDR_VAR 0 6
7762: PUSH
7763: LD_VAR 0 6
7767: PUSH
7768: LD_VAR 0 1
7772: DIFF
7773: ST_TO_ADDR
// if not HasTask ( i ) then
7774: LD_VAR 0 1
7778: PPUSH
7779: CALL_OW 314
7783: NOT
7784: IFFALSE 8027
// begin if not GetTag ( i ) then
7786: LD_VAR 0 1
7790: PPUSH
7791: CALL_OW 110
7795: NOT
7796: IFFALSE 7888
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
7798: LD_VAR 0 1
7802: PPUSH
7803: LD_VAR 0 5
7807: PUSH
7808: LD_INT 1
7810: ARRAY
7811: PUSH
7812: LD_INT 1
7814: ARRAY
7815: PPUSH
7816: LD_VAR 0 5
7820: PUSH
7821: LD_INT 1
7823: ARRAY
7824: PUSH
7825: LD_INT 2
7827: ARRAY
7828: PPUSH
7829: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
7833: LD_VAR 0 1
7837: PPUSH
7838: LD_VAR 0 5
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PUSH
7847: LD_INT 1
7849: ARRAY
7850: PPUSH
7851: LD_VAR 0 5
7855: PUSH
7856: LD_INT 1
7858: ARRAY
7859: PUSH
7860: LD_INT 2
7862: ARRAY
7863: PPUSH
7864: CALL_OW 297
7868: PUSH
7869: LD_INT 8
7871: LESS
7872: IFFALSE 7886
// SetTag ( i , 1 ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_INT 1
7881: PPUSH
7882: CALL_OW 109
// end else
7886: GO 8027
// if GetTag ( i ) = 1 then
7888: LD_VAR 0 1
7892: PPUSH
7893: CALL_OW 110
7897: PUSH
7898: LD_INT 1
7900: EQUAL
7901: IFFALSE 7993
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
7903: LD_VAR 0 1
7907: PPUSH
7908: LD_VAR 0 5
7912: PUSH
7913: LD_INT 2
7915: ARRAY
7916: PUSH
7917: LD_INT 1
7919: ARRAY
7920: PPUSH
7921: LD_VAR 0 5
7925: PUSH
7926: LD_INT 2
7928: ARRAY
7929: PUSH
7930: LD_INT 2
7932: ARRAY
7933: PPUSH
7934: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
7938: LD_VAR 0 1
7942: PPUSH
7943: LD_VAR 0 5
7947: PUSH
7948: LD_INT 2
7950: ARRAY
7951: PUSH
7952: LD_INT 1
7954: ARRAY
7955: PPUSH
7956: LD_VAR 0 5
7960: PUSH
7961: LD_INT 2
7963: ARRAY
7964: PUSH
7965: LD_INT 2
7967: ARRAY
7968: PPUSH
7969: CALL_OW 297
7973: PUSH
7974: LD_INT 8
7976: LESS
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// end else
7991: GO 8027
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_INT 81
8000: PUSH
8001: LD_INT 3
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PPUSH
8008: CALL_OW 69
8012: PPUSH
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL_OW 74
8022: PPUSH
8023: CALL_OW 115
// end ; end ;
8027: GO 7744
8029: POP
8030: POP
// until not attackers ;
8031: LD_VAR 0 6
8035: NOT
8036: IFFALSE 7727
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8038: LD_EXP 66
8042: PUSH
8043: LD_VAR 0 2
8047: ARRAY
8048: PPUSH
8049: LD_INT 50
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 72
8059: NOT
8060: IFFALSE 6932
// end ;
8062: PPOPN 6
8064: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
8065: LD_INT 22
8067: PUSH
8068: LD_INT 3
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: LD_INT 30
8077: PUSH
8078: LD_INT 3
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PPUSH
8089: CALL_OW 69
8093: IFFALSE 9277
8095: GO 8097
8097: DISABLE
8098: LD_INT 0
8100: PPUSH
8101: PPUSH
8102: PPUSH
8103: PPUSH
8104: PPUSH
8105: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
8106: LD_INT 6300
8108: PUSH
8109: LD_INT 4200
8111: PUSH
8112: LD_INT 2100
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PPUSH
8126: CALL_OW 67
// base := 1 ;
8130: LD_ADDR_VAR 0 2
8134: PUSH
8135: LD_INT 1
8137: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8138: LD_INT 22
8140: PUSH
8141: LD_INT 3
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 30
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PPUSH
8162: CALL_OW 69
8166: NOT
8167: IFFALSE 8171
// continue ;
8169: GO 8106
// case Rand ( 1 , 3 ) of 1 :
8171: LD_INT 1
8173: PPUSH
8174: LD_INT 3
8176: PPUSH
8177: CALL_OW 12
8181: PUSH
8182: LD_INT 1
8184: DOUBLE
8185: EQUAL
8186: IFTRUE 8190
8188: GO 8366
8190: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8191: LD_ADDR_VAR 0 3
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 1
8201: PUSH
8202: LD_INT 3
8204: PUSH
8205: LD_INT 43
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 24
8216: PUSH
8217: LD_INT 1
8219: PUSH
8220: LD_INT 3
8222: PUSH
8223: LD_INT 46
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 24
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: LD_INT 3
8240: PUSH
8241: LD_INT 43
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: PUSH
8250: LD_INT 24
8252: PUSH
8253: LD_INT 1
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: LD_INT 46
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: PUSH
8268: LD_INT 22
8270: PUSH
8271: LD_INT 1
8273: PUSH
8274: LD_INT 3
8276: PUSH
8277: LD_INT 45
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: LIST
8284: LIST
8285: PUSH
8286: LD_INT 22
8288: PUSH
8289: LD_INT 1
8291: PUSH
8292: LD_INT 3
8294: PUSH
8295: LD_INT 43
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: LIST
8302: LIST
8303: PUSH
8304: LD_INT 24
8306: PUSH
8307: LD_INT 1
8309: PUSH
8310: LD_INT 3
8312: PUSH
8313: LD_INT 46
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_INT 22
8324: PUSH
8325: LD_INT 1
8327: PUSH
8328: LD_INT 3
8330: PUSH
8331: LD_INT 45
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: LIST
8349: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_VAR 0 3
8359: PPUSH
8360: CALL 74237 0 2
// end ; 2 :
8364: GO 8735
8366: LD_INT 2
8368: DOUBLE
8369: EQUAL
8370: IFTRUE 8374
8372: GO 8550
8374: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8375: LD_ADDR_VAR 0 3
8379: PUSH
8380: LD_INT 24
8382: PUSH
8383: LD_INT 1
8385: PUSH
8386: LD_INT 3
8388: PUSH
8389: LD_INT 43
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 24
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: LD_INT 3
8406: PUSH
8407: LD_INT 46
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 24
8418: PUSH
8419: LD_INT 1
8421: PUSH
8422: LD_INT 3
8424: PUSH
8425: LD_INT 43
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 24
8436: PUSH
8437: LD_INT 1
8439: PUSH
8440: LD_INT 3
8442: PUSH
8443: LD_INT 46
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: LIST
8451: PUSH
8452: LD_INT 22
8454: PUSH
8455: LD_INT 1
8457: PUSH
8458: LD_INT 3
8460: PUSH
8461: LD_INT 45
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 22
8472: PUSH
8473: LD_INT 1
8475: PUSH
8476: LD_INT 3
8478: PUSH
8479: LD_INT 45
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 22
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 3
8496: PUSH
8497: LD_INT 45
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 1
8511: PUSH
8512: LD_INT 3
8514: PUSH
8515: LD_INT 45
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: LIST
8533: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8534: LD_VAR 0 2
8538: PPUSH
8539: LD_VAR 0 3
8543: PPUSH
8544: CALL 74237 0 2
// end ; 3 :
8548: GO 8735
8550: LD_INT 3
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8734
8558: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: LD_INT 22
8566: PUSH
8567: LD_INT 1
8569: PUSH
8570: LD_INT 3
8572: PUSH
8573: LD_INT 43
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_INT 24
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: LD_INT 3
8590: PUSH
8591: LD_INT 46
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 22
8602: PUSH
8603: LD_INT 1
8605: PUSH
8606: LD_INT 3
8608: PUSH
8609: LD_INT 43
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: LIST
8616: LIST
8617: PUSH
8618: LD_INT 24
8620: PUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: LD_INT 46
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: LIST
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: LD_INT 45
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: PUSH
8654: LD_INT 22
8656: PUSH
8657: LD_INT 1
8659: PUSH
8660: LD_INT 3
8662: PUSH
8663: LD_INT 43
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: LIST
8670: LIST
8671: PUSH
8672: LD_INT 24
8674: PUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: LD_INT 46
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 22
8692: PUSH
8693: LD_INT 1
8695: PUSH
8696: LD_INT 3
8698: PUSH
8699: LD_INT 45
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: LIST
8706: LIST
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8718: LD_VAR 0 2
8722: PPUSH
8723: LD_VAR 0 3
8727: PPUSH
8728: CALL 74237 0 2
// end ; end ;
8732: GO 8735
8734: POP
// repeat wait ( 0 0$1 ) ;
8735: LD_INT 35
8737: PPUSH
8738: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8742: LD_VAR 0 2
8746: PPUSH
8747: LD_INT 1
8749: PPUSH
8750: CALL 75655 0 2
8754: PUSH
8755: LD_INT 8
8757: GREATEREQUAL
8758: IFFALSE 8735
// wait ( 0 0$30 ) ;
8760: LD_INT 1050
8762: PPUSH
8763: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8767: LD_ADDR_VAR 0 5
8771: PUSH
8772: LD_INT 144
8774: PUSH
8775: LD_INT 65
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 63
8784: PUSH
8785: LD_INT 38
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: PUSH
8792: EMPTY
8793: LIST
8794: LIST
8795: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8796: LD_ADDR_VAR 0 4
8800: PUSH
8801: LD_INT 0
8803: PUSH
8804: LD_INT 0
8806: PUSH
8807: LD_INT 0
8809: PUSH
8810: LD_INT 1
8812: PUSH
8813: LD_INT 0
8815: PUSH
8816: LD_INT 0
8818: PUSH
8819: LD_INT 0
8821: PUSH
8822: LD_INT 0
8824: PUSH
8825: LD_INT 1
8827: PUSH
8828: LD_INT 0
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_EXP 85
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PUSH
8859: LD_EXP 88
8863: PUSH
8864: LD_VAR 0 2
8868: ARRAY
8869: DIFF
8870: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8871: LD_ADDR_EXP 85
8875: PUSH
8876: LD_EXP 85
8880: PPUSH
8881: LD_VAR 0 2
8885: PPUSH
8886: LD_EXP 85
8890: PUSH
8891: LD_VAR 0 2
8895: ARRAY
8896: PUSH
8897: LD_VAR 0 6
8901: DIFF
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// if not attackers then
8908: LD_VAR 0 6
8912: NOT
8913: IFFALSE 8917
// continue ;
8915: GO 8106
// repeat wait ( 0 0$1 ) ;
8917: LD_INT 35
8919: PPUSH
8920: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8924: LD_VAR 0 6
8928: PPUSH
8929: LD_INT 60
8931: PUSH
8932: EMPTY
8933: LIST
8934: PPUSH
8935: CALL_OW 72
8939: NOT
8940: IFFALSE 8917
// repeat wait ( 0 0$1 ) ;
8942: LD_INT 35
8944: PPUSH
8945: CALL_OW 67
// for i in attackers do
8949: LD_ADDR_VAR 0 1
8953: PUSH
8954: LD_VAR 0 6
8958: PUSH
8959: FOR_IN
8960: IFFALSE 9244
// begin if IsDead ( i ) then
8962: LD_VAR 0 1
8966: PPUSH
8967: CALL_OW 301
8971: IFFALSE 8989
// attackers := attackers diff i ;
8973: LD_ADDR_VAR 0 6
8977: PUSH
8978: LD_VAR 0 6
8982: PUSH
8983: LD_VAR 0 1
8987: DIFF
8988: ST_TO_ADDR
// if not HasTask ( i ) then
8989: LD_VAR 0 1
8993: PPUSH
8994: CALL_OW 314
8998: NOT
8999: IFFALSE 9242
// begin if not GetTag ( i ) then
9001: LD_VAR 0 1
9005: PPUSH
9006: CALL_OW 110
9010: NOT
9011: IFFALSE 9103
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
9013: LD_VAR 0 1
9017: PPUSH
9018: LD_VAR 0 5
9022: PUSH
9023: LD_INT 1
9025: ARRAY
9026: PUSH
9027: LD_INT 1
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 5
9035: PUSH
9036: LD_INT 1
9038: ARRAY
9039: PUSH
9040: LD_INT 2
9042: ARRAY
9043: PPUSH
9044: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
9048: LD_VAR 0 1
9052: PPUSH
9053: LD_VAR 0 5
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PUSH
9062: LD_INT 1
9064: ARRAY
9065: PPUSH
9066: LD_VAR 0 5
9070: PUSH
9071: LD_INT 1
9073: ARRAY
9074: PUSH
9075: LD_INT 2
9077: ARRAY
9078: PPUSH
9079: CALL_OW 297
9083: PUSH
9084: LD_INT 8
9086: LESS
9087: IFFALSE 9101
// SetTag ( i , 1 ) ;
9089: LD_VAR 0 1
9093: PPUSH
9094: LD_INT 1
9096: PPUSH
9097: CALL_OW 109
// end else
9101: GO 9242
// if GetTag ( i ) = 1 then
9103: LD_VAR 0 1
9107: PPUSH
9108: CALL_OW 110
9112: PUSH
9113: LD_INT 1
9115: EQUAL
9116: IFFALSE 9208
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
9118: LD_VAR 0 1
9122: PPUSH
9123: LD_VAR 0 5
9127: PUSH
9128: LD_INT 2
9130: ARRAY
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_VAR 0 5
9140: PUSH
9141: LD_INT 2
9143: ARRAY
9144: PUSH
9145: LD_INT 2
9147: ARRAY
9148: PPUSH
9149: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
9153: LD_VAR 0 1
9157: PPUSH
9158: LD_VAR 0 5
9162: PUSH
9163: LD_INT 2
9165: ARRAY
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 5
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PUSH
9180: LD_INT 2
9182: ARRAY
9183: PPUSH
9184: CALL_OW 297
9188: PUSH
9189: LD_INT 8
9191: LESS
9192: IFFALSE 9206
// SetTag ( i , 2 ) ;
9194: LD_VAR 0 1
9198: PPUSH
9199: LD_INT 2
9201: PPUSH
9202: CALL_OW 109
// end else
9206: GO 9242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9208: LD_VAR 0 1
9212: PPUSH
9213: LD_INT 81
9215: PUSH
9216: LD_INT 3
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: PPUSH
9223: CALL_OW 69
9227: PPUSH
9228: LD_VAR 0 1
9232: PPUSH
9233: CALL_OW 74
9237: PPUSH
9238: CALL_OW 115
// end ; end ;
9242: GO 8959
9244: POP
9245: POP
// until not attackers ;
9246: LD_VAR 0 6
9250: NOT
9251: IFFALSE 8942
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
9253: LD_EXP 66
9257: PUSH
9258: LD_VAR 0 2
9262: ARRAY
9263: PPUSH
9264: LD_INT 50
9266: PUSH
9267: EMPTY
9268: LIST
9269: PPUSH
9270: CALL_OW 72
9274: NOT
9275: IFFALSE 8106
// end ;
9277: PPOPN 6
9279: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9280: LD_EXP 4
9284: PUSH
9285: LD_INT 22
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 21
9297: PUSH
9298: LD_INT 1
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 69
9313: PUSH
9314: LD_INT 0
9316: EQUAL
9317: AND
9318: IFFALSE 9331
9320: GO 9322
9322: DISABLE
// RussiansDefeated := true ;
9323: LD_ADDR_EXP 44
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
9331: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
9332: LD_EXP 4
9336: PUSH
9337: LD_EXP 6
9341: NOT
9342: AND
9343: IFFALSE 10767
9345: GO 9347
9347: DISABLE
9348: LD_INT 0
9350: PPUSH
9351: PPUSH
9352: PPUSH
9353: PPUSH
9354: PPUSH
9355: PPUSH
9356: PPUSH
9357: PPUSH
9358: PPUSH
9359: PPUSH
9360: PPUSH
9361: PPUSH
// begin wait ( [ Rand ( 4 4$00 , 4 4$30 ) , Rand ( 4 4$30 , 3 3$30 ) , Rand ( 3 3$00 , 2 2$00 ) ] [ Difficulty ] ) ;
9362: LD_INT 8400
9364: PPUSH
9365: LD_INT 9450
9367: PPUSH
9368: CALL_OW 12
9372: PUSH
9373: LD_INT 9450
9375: PPUSH
9376: LD_INT 7350
9378: PPUSH
9379: CALL_OW 12
9383: PUSH
9384: LD_INT 6300
9386: PPUSH
9387: LD_INT 4200
9389: PPUSH
9390: CALL_OW 12
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: LD_OWVAR 67
9404: ARRAY
9405: PPUSH
9406: CALL_OW 67
// filter := [ ] ;
9410: LD_ADDR_VAR 0 3
9414: PUSH
9415: EMPTY
9416: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9417: LD_ADDR_VAR 0 4
9421: PUSH
9422: LD_INT 2
9424: PPUSH
9425: LD_INT 3
9427: PPUSH
9428: CALL_OW 12
9432: PUSH
9433: LD_INT 3
9435: PPUSH
9436: LD_INT 4
9438: PPUSH
9439: CALL_OW 12
9443: PUSH
9444: LD_INT 3
9446: PPUSH
9447: LD_INT 5
9449: PPUSH
9450: CALL_OW 12
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: LIST
9459: PUSH
9460: LD_OWVAR 67
9464: ARRAY
9465: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 1
9473: PUSH
9474: LD_INT 1
9476: PPUSH
9477: LD_INT 2
9479: PPUSH
9480: CALL_OW 12
9484: PUSH
9485: LD_INT 2
9487: PPUSH
9488: LD_INT 3
9490: PPUSH
9491: CALL_OW 12
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: LIST
9500: PUSH
9501: LD_OWVAR 67
9505: ARRAY
9506: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9507: LD_ADDR_VAR 0 6
9511: PUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: PUSH
9523: LD_INT 2
9525: PPUSH
9526: LD_INT 4
9528: PPUSH
9529: CALL_OW 12
9533: PUSH
9534: LD_INT 3
9536: PPUSH
9537: LD_INT 5
9539: PPUSH
9540: CALL_OW 12
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_OWVAR 67
9554: ARRAY
9555: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
9556: LD_ADDR_VAR 0 8
9560: PUSH
9561: LD_INT 1
9563: PUSH
9564: LD_INT 2
9566: PUSH
9567: LD_INT 2
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: LD_OWVAR 67
9579: ARRAY
9580: ST_TO_ADDR
// uc_side := 3 ;
9581: LD_ADDR_OWVAR 20
9585: PUSH
9586: LD_INT 3
9588: ST_TO_ADDR
// uc_nation := nation_russian ;
9589: LD_ADDR_OWVAR 21
9593: PUSH
9594: LD_INT 3
9596: ST_TO_ADDR
// for i = 1 to soldiers do
9597: LD_ADDR_VAR 0 1
9601: PUSH
9602: DOUBLE
9603: LD_INT 1
9605: DEC
9606: ST_TO_ADDR
9607: LD_VAR 0 4
9611: PUSH
9612: FOR_TO
9613: IFFALSE 9655
// begin PrepareSoldier ( 0 , game_eskill ) ;
9615: LD_INT 0
9617: PPUSH
9618: LD_EXP 40
9622: PPUSH
9623: CALL_OW 381
// un := CreateHuman ;
9627: LD_ADDR_VAR 0 2
9631: PUSH
9632: CALL_OW 44
9636: ST_TO_ADDR
// filter := filter ^ un ;
9637: LD_ADDR_VAR 0 3
9641: PUSH
9642: LD_VAR 0 3
9646: PUSH
9647: LD_VAR 0 2
9651: ADD
9652: ST_TO_ADDR
// end ;
9653: GO 9612
9655: POP
9656: POP
// for i = 1 to bazookas do
9657: LD_ADDR_VAR 0 1
9661: PUSH
9662: DOUBLE
9663: LD_INT 1
9665: DEC
9666: ST_TO_ADDR
9667: LD_VAR 0 5
9671: PUSH
9672: FOR_TO
9673: IFFALSE 9723
// begin PrepareSoldier ( 0 , game_eskill ) ;
9675: LD_INT 0
9677: PPUSH
9678: LD_EXP 40
9682: PPUSH
9683: CALL_OW 381
// hc_class := class_bazooker ;
9687: LD_ADDR_OWVAR 28
9691: PUSH
9692: LD_INT 9
9694: ST_TO_ADDR
// un := CreateHuman ;
9695: LD_ADDR_VAR 0 2
9699: PUSH
9700: CALL_OW 44
9704: ST_TO_ADDR
// filter := filter ^ un ;
9705: LD_ADDR_VAR 0 3
9709: PUSH
9710: LD_VAR 0 3
9714: PUSH
9715: LD_VAR 0 2
9719: ADD
9720: ST_TO_ADDR
// end ;
9721: GO 9672
9723: POP
9724: POP
// for i = 1 to medics do
9725: LD_ADDR_VAR 0 1
9729: PUSH
9730: DOUBLE
9731: LD_INT 1
9733: DEC
9734: ST_TO_ADDR
9735: LD_VAR 0 8
9739: PUSH
9740: FOR_TO
9741: IFFALSE 9783
// begin PrepareScientist ( 0 , game_eskill ) ;
9743: LD_INT 0
9745: PPUSH
9746: LD_EXP 40
9750: PPUSH
9751: CALL_OW 384
// un := CreateHuman ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: CALL_OW 44
9764: ST_TO_ADDR
// filter := filter ^ un ;
9765: LD_ADDR_VAR 0 3
9769: PUSH
9770: LD_VAR 0 3
9774: PUSH
9775: LD_VAR 0 2
9779: ADD
9780: ST_TO_ADDR
// end ;
9781: GO 9740
9783: POP
9784: POP
// for i = 1 to vehs do
9785: LD_ADDR_VAR 0 1
9789: PUSH
9790: DOUBLE
9791: LD_INT 1
9793: DEC
9794: ST_TO_ADDR
9795: LD_VAR 0 6
9799: PUSH
9800: FOR_TO
9801: IFFALSE 9993
// begin case Rand ( 1 , 5 ) of 1 :
9803: LD_INT 1
9805: PPUSH
9806: LD_INT 5
9808: PPUSH
9809: CALL_OW 12
9813: PUSH
9814: LD_INT 1
9816: DOUBLE
9817: EQUAL
9818: IFTRUE 9822
9820: GO 9844
9822: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
9823: LD_INT 22
9825: PPUSH
9826: LD_INT 3
9828: PPUSH
9829: LD_INT 3
9831: PPUSH
9832: LD_INT 43
9834: PPUSH
9835: LD_INT 100
9837: PPUSH
9838: CALL 18426 0 5
9842: GO 9965
9844: LD_INT 2
9846: DOUBLE
9847: EQUAL
9848: IFTRUE 9852
9850: GO 9874
9852: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
9853: LD_INT 22
9855: PPUSH
9856: LD_INT 3
9858: PPUSH
9859: LD_INT 3
9861: PPUSH
9862: LD_INT 44
9864: PPUSH
9865: LD_INT 100
9867: PPUSH
9868: CALL 18426 0 5
9872: GO 9965
9874: LD_INT 3
9876: DOUBLE
9877: EQUAL
9878: IFTRUE 9882
9880: GO 9904
9882: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
9883: LD_INT 22
9885: PPUSH
9886: LD_INT 3
9888: PPUSH
9889: LD_INT 3
9891: PPUSH
9892: LD_INT 45
9894: PPUSH
9895: LD_INT 100
9897: PPUSH
9898: CALL 18426 0 5
9902: GO 9965
9904: LD_INT 4
9906: DOUBLE
9907: EQUAL
9908: IFTRUE 9912
9910: GO 9934
9912: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
9913: LD_INT 24
9915: PPUSH
9916: LD_INT 3
9918: PPUSH
9919: LD_INT 3
9921: PPUSH
9922: LD_INT 43
9924: PPUSH
9925: LD_INT 100
9927: PPUSH
9928: CALL 18426 0 5
9932: GO 9965
9934: LD_INT 5
9936: DOUBLE
9937: EQUAL
9938: IFTRUE 9942
9940: GO 9964
9942: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
9943: LD_INT 24
9945: PPUSH
9946: LD_INT 3
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 46
9954: PPUSH
9955: LD_INT 100
9957: PPUSH
9958: CALL 18426 0 5
9962: GO 9965
9964: POP
// vehicle := CreateVehicle ;
9965: LD_ADDR_VAR 0 7
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// filter := filter ^ vehicle ;
9975: LD_ADDR_VAR 0 3
9979: PUSH
9980: LD_VAR 0 3
9984: PUSH
9985: LD_VAR 0 7
9989: ADD
9990: ST_TO_ADDR
// end ;
9991: GO 9800
9993: POP
9994: POP
// for i = 1 to filter do
9995: LD_ADDR_VAR 0 1
9999: PUSH
10000: DOUBLE
10001: LD_INT 1
10003: DEC
10004: ST_TO_ADDR
10005: LD_VAR 0 3
10009: PUSH
10010: FOR_TO
10011: IFFALSE 10036
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
10013: LD_VAR 0 3
10017: PUSH
10018: LD_VAR 0 1
10022: ARRAY
10023: PPUSH
10024: LD_INT 14
10026: PPUSH
10027: LD_INT 0
10029: PPUSH
10030: CALL_OW 49
10034: GO 10010
10036: POP
10037: POP
// case Rand ( 1 , 3 ) of 1 :
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 3
10043: PPUSH
10044: CALL_OW 12
10048: PUSH
10049: LD_INT 1
10051: DOUBLE
10052: EQUAL
10053: IFTRUE 10057
10055: GO 10111
10057: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
10058: LD_ADDR_VAR 0 11
10062: PUSH
10063: LD_INT 165
10065: PUSH
10066: LD_INT 114
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PUSH
10073: LD_INT 104
10075: PUSH
10076: LD_INT 108
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PUSH
10083: LD_INT 86
10085: PUSH
10086: LD_INT 77
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PUSH
10093: LD_INT 63
10095: PUSH
10096: LD_INT 38
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: ST_TO_ADDR
10109: GO 10236
10111: LD_INT 2
10113: DOUBLE
10114: EQUAL
10115: IFTRUE 10119
10117: GO 10173
10119: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
10120: LD_ADDR_VAR 0 11
10124: PUSH
10125: LD_INT 165
10127: PUSH
10128: LD_INT 114
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 146
10137: PUSH
10138: LD_INT 71
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: LD_INT 112
10147: PUSH
10148: LD_INT 41
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PUSH
10155: LD_INT 63
10157: PUSH
10158: LD_INT 38
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: ST_TO_ADDR
10171: GO 10236
10173: LD_INT 3
10175: DOUBLE
10176: EQUAL
10177: IFTRUE 10181
10179: GO 10235
10181: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
10182: LD_ADDR_VAR 0 11
10186: PUSH
10187: LD_INT 165
10189: PUSH
10190: LD_INT 114
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 63
10199: PUSH
10200: LD_INT 99
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 55
10209: PUSH
10210: LD_INT 77
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PUSH
10217: LD_INT 63
10219: PUSH
10220: LD_INT 38
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: ST_TO_ADDR
10233: GO 10236
10235: POP
// attackers := filter ;
10236: LD_ADDR_VAR 0 10
10240: PUSH
10241: LD_VAR 0 3
10245: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// for i in attackers do
10253: LD_ADDR_VAR 0 1
10257: PUSH
10258: LD_VAR 0 10
10262: PUSH
10263: FOR_IN
10264: IFFALSE 10758
// begin if IsDead ( i ) then
10266: LD_VAR 0 1
10270: PPUSH
10271: CALL_OW 301
10275: IFFALSE 10293
// attackers := attackers diff i ;
10277: LD_ADDR_VAR 0 10
10281: PUSH
10282: LD_VAR 0 10
10286: PUSH
10287: LD_VAR 0 1
10291: DIFF
10292: ST_TO_ADDR
// if not HasTask ( i ) then
10293: LD_VAR 0 1
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10756
// begin if not GetTag ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 110
10314: NOT
10315: IFFALSE 10407
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
10317: LD_VAR 0 1
10321: PPUSH
10322: LD_VAR 0 11
10326: PUSH
10327: LD_INT 1
10329: ARRAY
10330: PUSH
10331: LD_INT 1
10333: ARRAY
10334: PPUSH
10335: LD_VAR 0 11
10339: PUSH
10340: LD_INT 1
10342: ARRAY
10343: PUSH
10344: LD_INT 2
10346: ARRAY
10347: PPUSH
10348: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
10352: LD_VAR 0 1
10356: PPUSH
10357: LD_VAR 0 11
10361: PUSH
10362: LD_INT 1
10364: ARRAY
10365: PUSH
10366: LD_INT 1
10368: ARRAY
10369: PPUSH
10370: LD_VAR 0 11
10374: PUSH
10375: LD_INT 1
10377: ARRAY
10378: PUSH
10379: LD_INT 2
10381: ARRAY
10382: PPUSH
10383: CALL_OW 297
10387: PUSH
10388: LD_INT 8
10390: LESS
10391: IFFALSE 10405
// SetTag ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 109
// end else
10405: GO 10756
// if GetTag ( i ) = 1 then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 110
10416: PUSH
10417: LD_INT 1
10419: EQUAL
10420: IFFALSE 10512
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
10422: LD_VAR 0 1
10426: PPUSH
10427: LD_VAR 0 11
10431: PUSH
10432: LD_INT 2
10434: ARRAY
10435: PUSH
10436: LD_INT 1
10438: ARRAY
10439: PPUSH
10440: LD_VAR 0 11
10444: PUSH
10445: LD_INT 2
10447: ARRAY
10448: PUSH
10449: LD_INT 2
10451: ARRAY
10452: PPUSH
10453: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
10457: LD_VAR 0 1
10461: PPUSH
10462: LD_VAR 0 11
10466: PUSH
10467: LD_INT 2
10469: ARRAY
10470: PUSH
10471: LD_INT 1
10473: ARRAY
10474: PPUSH
10475: LD_VAR 0 11
10479: PUSH
10480: LD_INT 2
10482: ARRAY
10483: PUSH
10484: LD_INT 2
10486: ARRAY
10487: PPUSH
10488: CALL_OW 297
10492: PUSH
10493: LD_INT 8
10495: LESS
10496: IFFALSE 10510
// SetTag ( i , 2 ) ;
10498: LD_VAR 0 1
10502: PPUSH
10503: LD_INT 2
10505: PPUSH
10506: CALL_OW 109
// end else
10510: GO 10756
// if GetTag ( i ) = 2 then
10512: LD_VAR 0 1
10516: PPUSH
10517: CALL_OW 110
10521: PUSH
10522: LD_INT 2
10524: EQUAL
10525: IFFALSE 10617
// begin ComAgressiveMove ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) ;
10527: LD_VAR 0 1
10531: PPUSH
10532: LD_VAR 0 11
10536: PUSH
10537: LD_INT 3
10539: ARRAY
10540: PUSH
10541: LD_INT 1
10543: ARRAY
10544: PPUSH
10545: LD_VAR 0 11
10549: PUSH
10550: LD_INT 3
10552: ARRAY
10553: PUSH
10554: LD_INT 2
10556: ARRAY
10557: PPUSH
10558: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) < 8 then
10562: LD_VAR 0 1
10566: PPUSH
10567: LD_VAR 0 11
10571: PUSH
10572: LD_INT 3
10574: ARRAY
10575: PUSH
10576: LD_INT 1
10578: ARRAY
10579: PPUSH
10580: LD_VAR 0 11
10584: PUSH
10585: LD_INT 3
10587: ARRAY
10588: PUSH
10589: LD_INT 2
10591: ARRAY
10592: PPUSH
10593: CALL_OW 297
10597: PUSH
10598: LD_INT 8
10600: LESS
10601: IFFALSE 10615
// SetTag ( i , 3 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_INT 3
10610: PPUSH
10611: CALL_OW 109
// end else
10615: GO 10756
// if GetTag ( i ) = 3 then
10617: LD_VAR 0 1
10621: PPUSH
10622: CALL_OW 110
10626: PUSH
10627: LD_INT 3
10629: EQUAL
10630: IFFALSE 10722
// begin ComAgressiveMove ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) ;
10632: LD_VAR 0 1
10636: PPUSH
10637: LD_VAR 0 11
10641: PUSH
10642: LD_INT 4
10644: ARRAY
10645: PUSH
10646: LD_INT 1
10648: ARRAY
10649: PPUSH
10650: LD_VAR 0 11
10654: PUSH
10655: LD_INT 4
10657: ARRAY
10658: PUSH
10659: LD_INT 2
10661: ARRAY
10662: PPUSH
10663: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) < 8 then
10667: LD_VAR 0 1
10671: PPUSH
10672: LD_VAR 0 11
10676: PUSH
10677: LD_INT 4
10679: ARRAY
10680: PUSH
10681: LD_INT 1
10683: ARRAY
10684: PPUSH
10685: LD_VAR 0 11
10689: PUSH
10690: LD_INT 4
10692: ARRAY
10693: PUSH
10694: LD_INT 2
10696: ARRAY
10697: PPUSH
10698: CALL_OW 297
10702: PUSH
10703: LD_INT 8
10705: LESS
10706: IFFALSE 10720
// SetTag ( i , 4 ) ;
10708: LD_VAR 0 1
10712: PPUSH
10713: LD_INT 4
10715: PPUSH
10716: CALL_OW 109
// end else
10720: GO 10756
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10722: LD_VAR 0 1
10726: PPUSH
10727: LD_INT 81
10729: PUSH
10730: LD_INT 3
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PPUSH
10737: CALL_OW 69
10741: PPUSH
10742: LD_VAR 0 1
10746: PPUSH
10747: CALL_OW 74
10751: PPUSH
10752: CALL_OW 115
// end ; end ;
10756: GO 10263
10758: POP
10759: POP
// until not attackers ;
10760: LD_VAR 0 10
10764: NOT
10765: IFFALSE 10246
// end ;
10767: PPOPN 12
10769: END
// every 0 0$1 do var i , tmp ;
10770: GO 10772
10772: DISABLE
10773: LD_INT 0
10775: PPUSH
10776: PPUSH
// begin enable ;
10777: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
10778: LD_ADDR_VAR 0 2
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: LD_INT 22
10788: PUSH
10789: LD_INT 1
10791: PUSH
10792: EMPTY
10793: LIST
10794: LIST
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 32
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 69
10818: ST_TO_ADDR
// if tmp then
10819: LD_VAR 0 2
10823: IFFALSE 10869
// for i in tmp do
10825: LD_ADDR_VAR 0 1
10829: PUSH
10830: LD_VAR 0 2
10834: PUSH
10835: FOR_IN
10836: IFFALSE 10867
// if GetFuel ( i ) < 3 then
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 261
10847: PUSH
10848: LD_INT 3
10850: LESS
10851: IFFALSE 10865
// SetFuel ( i , 3 ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: LD_INT 3
10860: PPUSH
10861: CALL_OW 240
10865: GO 10835
10867: POP
10868: POP
// end ;
10869: PPOPN 2
10871: END
// every 0 0$1 trigger ( FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) and not JMMArrival ) or ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) and not FirstAssaultRepelled ) do
10872: LD_INT 3
10874: PPUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 1
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PPUSH
10885: CALL_OW 70
10889: PUSH
10890: LD_EXP 41
10894: NOT
10895: AND
10896: PUSH
10897: LD_INT 10
10899: PPUSH
10900: LD_INT 22
10902: PUSH
10903: LD_INT 1
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PPUSH
10910: CALL_OW 70
10914: PUSH
10915: LD_EXP 4
10919: NOT
10920: AND
10921: OR
10922: IFFALSE 10931
10924: GO 10926
10926: DISABLE
// Antirush ;
10927: CALL 10932 0 0
10931: END
// export function Antirush ; var i , veh , tmp , num ; begin
10932: LD_INT 0
10934: PPUSH
10935: PPUSH
10936: PPUSH
10937: PPUSH
10938: PPUSH
// tmp := [ ] ;
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: EMPTY
10945: ST_TO_ADDR
// if not FirstAssaultRepelled then
10946: LD_EXP 4
10950: NOT
10951: IFFALSE 10963
// num := 12 else
10953: LD_ADDR_VAR 0 5
10957: PUSH
10958: LD_INT 12
10960: ST_TO_ADDR
10961: GO 10971
// num := 10 ;
10963: LD_ADDR_VAR 0 5
10967: PUSH
10968: LD_INT 10
10970: ST_TO_ADDR
// num := num - [ 4 , 2 , 0 ] [ Difficulty ] ;
10971: LD_ADDR_VAR 0 5
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: LD_INT 4
10983: PUSH
10984: LD_INT 2
10986: PUSH
10987: LD_INT 0
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_OWVAR 67
10999: ARRAY
11000: MINUS
11001: ST_TO_ADDR
// for i := 1 to num do
11002: LD_ADDR_VAR 0 2
11006: PUSH
11007: DOUBLE
11008: LD_INT 1
11010: DEC
11011: ST_TO_ADDR
11012: LD_VAR 0 5
11016: PUSH
11017: FOR_TO
11018: IFFALSE 11157
// begin uc_side := 3 ;
11020: LD_ADDR_OWVAR 20
11024: PUSH
11025: LD_INT 3
11027: ST_TO_ADDR
// uc_nation := 3 ;
11028: LD_ADDR_OWVAR 21
11032: PUSH
11033: LD_INT 3
11035: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
11036: LD_INT 23
11038: PPUSH
11039: LD_INT 3
11041: PPUSH
11042: LD_INT 3
11044: PPUSH
11045: LD_INT 46
11047: PUSH
11048: LD_INT 43
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: PUSH
11055: LD_INT 1
11057: PPUSH
11058: LD_INT 2
11060: PPUSH
11061: CALL_OW 12
11065: ARRAY
11066: PPUSH
11067: LD_INT 100
11069: PPUSH
11070: CALL 18426 0 5
// veh := CreateVehicle ;
11074: LD_ADDR_VAR 0 3
11078: PUSH
11079: CALL_OW 45
11083: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
11084: LD_VAR 0 3
11088: PPUSH
11089: LD_INT 5
11091: PPUSH
11092: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
11096: LD_VAR 0 3
11100: PPUSH
11101: LD_INT 199
11103: PPUSH
11104: LD_INT 135
11106: PPUSH
11107: LD_INT 3
11109: PPUSH
11110: LD_INT 0
11112: PPUSH
11113: CALL_OW 50
// tmp := tmp ^ veh ;
11117: LD_ADDR_VAR 0 4
11121: PUSH
11122: LD_VAR 0 4
11126: PUSH
11127: LD_VAR 0 3
11131: ADD
11132: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
11133: LD_VAR 0 3
11137: PPUSH
11138: LD_INT 173
11140: PPUSH
11141: LD_INT 118
11143: PPUSH
11144: CALL_OW 111
// wait ( 0 0$2 ) ;
11148: LD_INT 70
11150: PPUSH
11151: CALL_OW 67
// end ;
11155: GO 11017
11157: POP
11158: POP
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// for i in tmp do
11166: LD_ADDR_VAR 0 2
11170: PUSH
11171: LD_VAR 0 4
11175: PUSH
11176: FOR_IN
11177: IFFALSE 11244
// if IsDead ( i ) then
11179: LD_VAR 0 2
11183: PPUSH
11184: CALL_OW 301
11188: IFFALSE 11208
// tmp := tmp diff i else
11190: LD_ADDR_VAR 0 4
11194: PUSH
11195: LD_VAR 0 4
11199: PUSH
11200: LD_VAR 0 2
11204: DIFF
11205: ST_TO_ADDR
11206: GO 11242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 22
11215: PUSH
11216: LD_INT 1
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PPUSH
11223: CALL_OW 69
11227: PPUSH
11228: LD_VAR 0 2
11232: PPUSH
11233: CALL_OW 74
11237: PPUSH
11238: CALL_OW 115
11242: GO 11176
11244: POP
11245: POP
// until not tmp ;
11246: LD_VAR 0 4
11250: NOT
11251: IFFALSE 11159
// end ; end_of_file
11253: LD_VAR 0 1
11257: RET
// export Losses ; on UnitDestroyed ( un ) do begin if un = Brighton then
11258: LD_VAR 0 1
11262: PUSH
11263: LD_EXP 9
11267: EQUAL
11268: IFFALSE 11284
// begin wait ( 0 0$1 ) ;
11270: LD_INT 35
11272: PPUSH
11273: CALL_OW 67
// YouLost ( Brighton ) ;
11277: LD_STRING Brighton
11279: PPUSH
11280: CALL_OW 104
// end ; if un = JMM then
11284: LD_VAR 0 1
11288: PUSH
11289: LD_EXP 37
11293: EQUAL
11294: IFFALSE 11310
// begin wait ( 0 0$1 ) ;
11296: LD_INT 35
11298: PPUSH
11299: CALL_OW 67
// YouLost ( JMM ) ;
11303: LD_STRING JMM
11305: PPUSH
11306: CALL_OW 104
// end ; if un = Megan then
11310: LD_VAR 0 1
11314: PUSH
11315: LD_EXP 11
11319: EQUAL
11320: IFFALSE 11334
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
11322: LD_EXP 9
11326: PPUSH
11327: LD_STRING DBrighton-MeganDeath
11329: PPUSH
11330: CALL_OW 88
// end ; if un = Palmer then
11334: LD_VAR 0 1
11338: PUSH
11339: LD_EXP 10
11343: EQUAL
11344: IFFALSE 11358
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
11346: LD_EXP 9
11350: PPUSH
11351: LD_STRING DBrighton-PalmerDeath
11353: PPUSH
11354: CALL_OW 88
// end ; if un = Burlak then
11358: LD_VAR 0 1
11362: PUSH
11363: LD_EXP 19
11367: EQUAL
11368: IFFALSE 11400
// begin if JMM_Arrived then
11370: LD_EXP 6
11374: IFFALSE 11388
// Say ( JMM , DJMM-BurlakDead ) ;
11376: LD_EXP 37
11380: PPUSH
11381: LD_STRING DJMM-BurlakDead
11383: PPUSH
11384: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
11388: LD_EXP 10
11392: PPUSH
11393: LD_STRING DSol-BurlakDead
11395: PPUSH
11396: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
11400: LD_VAR 0 1
11404: PUSH
11405: LD_INT 1
11407: EQUAL
11408: PUSH
11409: LD_VAR 0 1
11413: PUSH
11414: LD_INT 3
11416: EQUAL
11417: OR
11418: IFFALSE 11434
// begin wait ( 0 0$1 ) ;
11420: LD_INT 35
11422: PPUSH
11423: CALL_OW 67
// YouLost ( Depot ) ;
11427: LD_STRING Depot
11429: PPUSH
11430: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
11434: LD_VAR 0 1
11438: PPUSH
11439: CALL_OW 255
11443: PUSH
11444: LD_INT 1
11446: EQUAL
11447: PUSH
11448: LD_VAR 0 1
11452: PPUSH
11453: CALL_OW 247
11457: PUSH
11458: LD_INT 1
11460: EQUAL
11461: AND
11462: IFFALSE 11478
// Losses := Losses + 1 ;
11464: LD_ADDR_EXP 45
11468: PUSH
11469: LD_EXP 45
11473: PUSH
11474: LD_INT 1
11476: PLUS
11477: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11478: LD_VAR 0 1
11482: PPUSH
11483: CALL 77629 0 1
// end ;
11487: PPOPN 1
11489: END
// on UnitGoesToRed ( un ) do begin if GetType ( un ) = unit_vehicle and un in RUArmada then
11490: LD_VAR 0 1
11494: PPUSH
11495: CALL_OW 247
11499: PUSH
11500: LD_INT 2
11502: EQUAL
11503: PUSH
11504: LD_VAR 0 1
11508: PUSH
11509: LD_EXP 17
11513: IN
11514: AND
11515: IFFALSE 11529
// SetLives ( un , 0 ) ;
11517: LD_VAR 0 1
11521: PPUSH
11522: LD_INT 0
11524: PPUSH
11525: CALL_OW 234
// if un = Yashin then
11529: LD_VAR 0 1
11533: PUSH
11534: LD_EXP 13
11538: EQUAL
11539: IFFALSE 11553
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
11541: LD_EXP 13
11545: PPUSH
11546: LD_STRING DDeath-Yas-3
11548: PPUSH
11549: CALL_OW 91
// if un = Popov then
11553: LD_VAR 0 1
11557: PUSH
11558: LD_EXP 14
11562: EQUAL
11563: IFFALSE 11577
// ForceSay ( Popov , DDeath-Pop-3 ) ;
11565: LD_EXP 14
11569: PPUSH
11570: LD_STRING DDeath-Pop-3
11572: PPUSH
11573: CALL_OW 91
// if un = Gaydar then
11577: LD_VAR 0 1
11581: PUSH
11582: LD_EXP 15
11586: EQUAL
11587: IFFALSE 11601
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
11589: LD_EXP 15
11593: PPUSH
11594: LD_STRING DDeath-Gay-3
11596: PPUSH
11597: CALL_OW 91
// if un = Sevi then
11601: LD_VAR 0 1
11605: PUSH
11606: LD_EXP 16
11610: EQUAL
11611: IFFALSE 11625
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
11613: LD_EXP 16
11617: PPUSH
11618: LD_STRING DDeath-Vse-3
11620: PPUSH
11621: CALL_OW 91
// end ;
11625: PPOPN 1
11627: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
11628: LD_VAR 0 1
11632: PUSH
11633: LD_INT 10
11635: EQUAL
11636: IFFALSE 11674
// begin Say ( Brighton , DBrighton-C1 ) ;
11638: LD_EXP 9
11642: PPUSH
11643: LD_STRING DBrighton-C1
11645: PPUSH
11646: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
11650: LD_EXP 11
11654: PPUSH
11655: LD_STRING DMegan-C1
11657: PPUSH
11658: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
11662: LD_EXP 9
11666: PPUSH
11667: LD_STRING DBrighton-C2
11669: PPUSH
11670: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
11674: LD_VAR 0 1
11678: PPUSH
11679: LD_VAR 0 2
11683: PPUSH
11684: CALL 77325 0 2
// end ;
11688: PPOPN 2
11690: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11691: LD_VAR 0 1
11695: PPUSH
11696: LD_VAR 0 2
11700: PPUSH
11701: CALL 79963 0 2
// end ;
11705: PPOPN 2
11707: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11708: LD_VAR 0 1
11712: PPUSH
11713: CALL 79031 0 1
// end ;
11717: PPOPN 1
11719: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
11720: LD_VAR 0 1
11724: PPUSH
11725: CALL_OW 266
11729: PUSH
11730: LD_INT 0
11732: EQUAL
11733: PUSH
11734: LD_VAR 0 1
11738: PPUSH
11739: CALL_OW 255
11743: PUSH
11744: LD_INT 3
11746: EQUAL
11747: AND
11748: IFFALSE 11810
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
11750: LD_VAR 0 1
11754: PPUSH
11755: CALL_OW 274
11759: PPUSH
11760: LD_INT 1
11762: PPUSH
11763: LD_INT 10000
11765: PPUSH
11766: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
11770: LD_VAR 0 1
11774: PPUSH
11775: CALL_OW 274
11779: PPUSH
11780: LD_INT 2
11782: PPUSH
11783: LD_INT 250
11785: PPUSH
11786: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
11790: LD_VAR 0 1
11794: PPUSH
11795: CALL_OW 274
11799: PPUSH
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 100
11805: PPUSH
11806: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
11810: LD_VAR 0 1
11814: PPUSH
11815: CALL 79272 0 1
// end ;
11819: PPOPN 1
11821: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11822: LD_VAR 0 1
11826: PPUSH
11827: LD_VAR 0 2
11831: PPUSH
11832: LD_VAR 0 3
11836: PPUSH
11837: LD_VAR 0 4
11841: PPUSH
11842: LD_VAR 0 5
11846: PPUSH
11847: CALL 76945 0 5
// end ;
11851: PPOPN 5
11853: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11854: LD_VAR 0 1
11858: PPUSH
11859: LD_VAR 0 2
11863: PPUSH
11864: CALL 76541 0 2
// end ;
11868: PPOPN 2
11870: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11871: LD_VAR 0 1
11875: PPUSH
11876: LD_VAR 0 2
11880: PPUSH
11881: LD_VAR 0 3
11885: PPUSH
11886: LD_VAR 0 4
11890: PPUSH
11891: CALL 76379 0 4
// end ;
11895: PPOPN 4
11897: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11898: LD_VAR 0 1
11902: PPUSH
11903: LD_VAR 0 2
11907: PPUSH
11908: LD_VAR 0 3
11912: PPUSH
11913: CALL 76154 0 3
// end ;
11917: PPOPN 3
11919: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11920: LD_VAR 0 1
11924: PPUSH
11925: LD_VAR 0 2
11929: PPUSH
11930: CALL 76039 0 2
// end ;
11934: PPOPN 2
11936: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11937: LD_VAR 0 1
11941: PPUSH
11942: LD_VAR 0 2
11946: PPUSH
11947: CALL 80224 0 2
// end ;
11951: PPOPN 2
11953: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
11954: LD_VAR 0 1
11958: PPUSH
11959: CALL_OW 255
11963: PUSH
11964: LD_INT 6
11966: EQUAL
11967: IFFALSE 12097
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
11969: LD_VAR 0 1
11973: PUSH
11974: LD_EXP 13
11978: PUSH
11979: LD_EXP 16
11983: PUSH
11984: LD_EXP 15
11988: PUSH
11989: LD_EXP 14
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: IN
12000: IFFALSE 12004
// exit ;
12002: GO 12121
// if AssaultStarted then
12004: LD_EXP 8
12008: IFFALSE 12082
// case Rand ( 1 , 4 ) of 1 .. 3 :
12010: LD_INT 1
12012: PPUSH
12013: LD_INT 4
12015: PPUSH
12016: CALL_OW 12
12020: PUSH
12021: LD_INT 1
12023: DOUBLE
12024: GREATEREQUAL
12025: IFFALSE 12033
12027: LD_INT 3
12029: DOUBLE
12030: LESSEQUAL
12031: IFTRUE 12035
12033: GO 12053
12035: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
12036: LD_VAR 0 1
12040: PPUSH
12041: LD_INT 67
12043: PPUSH
12044: LD_INT 37
12046: PPUSH
12047: CALL_OW 114
12051: GO 12080
12053: LD_INT 4
12055: DOUBLE
12056: EQUAL
12057: IFTRUE 12061
12059: GO 12079
12061: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
12062: LD_VAR 0 1
12066: PPUSH
12067: LD_INT 120
12069: PPUSH
12070: LD_INT 131
12072: PPUSH
12073: CALL_OW 111
12077: GO 12080
12079: POP
12080: GO 12097
// ComMoveXY ( driver , 120 , 131 ) ;
12082: LD_VAR 0 1
12086: PPUSH
12087: LD_INT 120
12089: PPUSH
12090: LD_INT 131
12092: PPUSH
12093: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12097: LD_VAR 0 1
12101: PPUSH
12102: LD_VAR 0 2
12106: PPUSH
12107: LD_VAR 0 3
12111: PPUSH
12112: LD_VAR 0 4
12116: PPUSH
12117: CALL 80440 0 4
// end ;
12121: PPOPN 4
12123: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12124: LD_VAR 0 1
12128: PPUSH
12129: LD_VAR 0 2
12133: PPUSH
12134: CALL 75848 0 2
// end ;
12138: PPOPN 2
12140: END
// on Command ( cmd ) do var i ;
12141: LD_INT 0
12143: PPUSH
// begin if cmd = 77 and southAreaBlocker then
12144: LD_VAR 0 1
12148: PUSH
12149: LD_INT 77
12151: EQUAL
12152: PUSH
12153: LD_EXP 2
12157: AND
12158: IFFALSE 12234
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12160: LD_ADDR_VAR 0 2
12164: PUSH
12165: LD_INT 22
12167: PUSH
12168: LD_INT 1
12170: PUSH
12171: EMPTY
12172: LIST
12173: LIST
12174: PUSH
12175: LD_INT 2
12177: PUSH
12178: LD_INT 21
12180: PUSH
12181: LD_INT 1
12183: PUSH
12184: EMPTY
12185: LIST
12186: LIST
12187: PUSH
12188: LD_INT 21
12190: PUSH
12191: LD_INT 2
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: LIST
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PPUSH
12207: CALL_OW 69
12211: PUSH
12212: FOR_IN
12213: IFFALSE 12232
// NotGoToAreaUnit ( i , SouthAreaBlock , SouthAreaGoAway ) ;
12215: LD_VAR 0 2
12219: PPUSH
12220: LD_INT 20
12222: PPUSH
12223: LD_INT 19
12225: PPUSH
12226: CALL 50201 0 3
12230: GO 12212
12232: POP
12233: POP
// end ; SOS_Command ( cmd ) ;
12234: LD_VAR 0 1
12238: PPUSH
12239: CALL 93854 0 1
// end ;
12243: PPOPN 2
12245: END
// every 0 0$1 trigger southAreaBlocker and FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do var i ;
12246: LD_EXP 2
12250: PUSH
12251: LD_INT 16
12253: PPUSH
12254: LD_INT 22
12256: PUSH
12257: LD_INT 1
12259: PUSH
12260: EMPTY
12261: LIST
12262: LIST
12263: PUSH
12264: LD_INT 2
12266: PUSH
12267: LD_INT 21
12269: PUSH
12270: LD_INT 1
12272: PUSH
12273: EMPTY
12274: LIST
12275: LIST
12276: PUSH
12277: LD_INT 21
12279: PUSH
12280: LD_INT 2
12282: PUSH
12283: EMPTY
12284: LIST
12285: LIST
12286: PUSH
12287: EMPTY
12288: LIST
12289: LIST
12290: LIST
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PPUSH
12296: CALL_OW 70
12300: AND
12301: IFFALSE 12387
12303: GO 12305
12305: DISABLE
12306: LD_INT 0
12308: PPUSH
// begin enable ;
12309: ENABLE
// for i in FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12310: LD_ADDR_VAR 0 1
12314: PUSH
12315: LD_INT 16
12317: PPUSH
12318: LD_INT 22
12320: PUSH
12321: LD_INT 1
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PUSH
12328: LD_INT 2
12330: PUSH
12331: LD_INT 21
12333: PUSH
12334: LD_INT 1
12336: PUSH
12337: EMPTY
12338: LIST
12339: LIST
12340: PUSH
12341: LD_INT 21
12343: PUSH
12344: LD_INT 2
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: PUSH
12351: EMPTY
12352: LIST
12353: LIST
12354: LIST
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PPUSH
12360: CALL_OW 70
12364: PUSH
12365: FOR_IN
12366: IFFALSE 12385
// NotGoToAreaUnit ( i , SouthAreaOutside , SouthAreaGoAway ) ;
12368: LD_VAR 0 1
12372: PPUSH
12373: LD_INT 18
12375: PPUSH
12376: LD_INT 19
12378: PPUSH
12379: CALL 50201 0 3
12383: GO 12365
12385: POP
12386: POP
// end ; end_of_file
12387: PPOPN 1
12389: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
12390: LD_EXP 6
12394: PUSH
12395: LD_EXP 44
12399: AND
12400: IFFALSE 12571
12402: GO 12404
12404: DISABLE
// begin wait ( 0 0$2 ) ;
12405: LD_INT 70
12407: PPUSH
12408: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
12412: LD_EXP 9
12416: PPUSH
12417: LD_STRING DBrighton-G1
12419: PPUSH
12420: CALL_OW 88
// if Losses < 1 then
12424: LD_EXP 45
12428: PUSH
12429: LD_INT 1
12431: LESS
12432: IFFALSE 12446
// AddMedal ( Losses , 1 ) else
12434: LD_STRING Losses
12436: PPUSH
12437: LD_INT 1
12439: PPUSH
12440: CALL_OW 101
12444: GO 12479
// if Losses < 5 then
12446: LD_EXP 45
12450: PUSH
12451: LD_INT 5
12453: LESS
12454: IFFALSE 12468
// AddMedal ( Losses , 2 ) else
12456: LD_STRING Losses
12458: PPUSH
12459: LD_INT 2
12461: PPUSH
12462: CALL_OW 101
12466: GO 12479
// AddMedal ( Losses , - 1 ) ;
12468: LD_STRING Losses
12470: PPUSH
12471: LD_INT 1
12473: NEG
12474: PPUSH
12475: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12479: LD_EXP 7
12483: PUSH
12484: LD_INT 10
12486: PPUSH
12487: LD_INT 1
12489: PPUSH
12490: CALL_OW 321
12494: PUSH
12495: LD_INT 2
12497: EQUAL
12498: AND
12499: IFFALSE 12513
// AddMedal ( Laser , 1 ) else
12501: LD_STRING Laser
12503: PPUSH
12504: LD_INT 1
12506: PPUSH
12507: CALL_OW 101
12511: GO 12560
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12513: LD_EXP 7
12517: NOT
12518: PUSH
12519: LD_INT 10
12521: PPUSH
12522: LD_INT 1
12524: PPUSH
12525: CALL_OW 321
12529: PUSH
12530: LD_INT 2
12532: EQUAL
12533: AND
12534: IFFALSE 12549
// AddMedal ( Laser , - 1 ) else
12536: LD_STRING Laser
12538: PPUSH
12539: LD_INT 1
12541: NEG
12542: PPUSH
12543: CALL_OW 101
12547: GO 12560
// AddMedal ( Laser , - 2 ) ;
12549: LD_STRING Laser
12551: PPUSH
12552: LD_INT 2
12554: NEG
12555: PPUSH
12556: CALL_OW 101
// GiveMedals ( BaseMain ) ;
12560: LD_STRING BaseMain
12562: PPUSH
12563: CALL_OW 102
// YouWin ;
12567: CALL_OW 103
// end ; end_of_file
12571: END
// export rows ; export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
12572: LD_INT 0
12574: PPUSH
12575: PPUSH
// area = ListEnvironmentArea ( area ) ;
12576: LD_ADDR_VAR 0 2
12580: PUSH
12581: LD_VAR 0 2
12585: PPUSH
12586: CALL_OW 353
12590: ST_TO_ADDR
// if bulldozer > 0 then
12591: LD_VAR 0 1
12595: PUSH
12596: LD_INT 0
12598: GREATER
12599: IFFALSE 12710
// for i = area downto 1 do
12601: LD_ADDR_VAR 0 4
12605: PUSH
12606: DOUBLE
12607: LD_VAR 0 2
12611: INC
12612: ST_TO_ADDR
12613: LD_INT 1
12615: PUSH
12616: FOR_DOWNTO
12617: IFFALSE 12708
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
12619: LD_VAR 0 2
12623: PUSH
12624: LD_VAR 0 4
12628: ARRAY
12629: PUSH
12630: LD_INT 1
12632: ARRAY
12633: PPUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_VAR 0 4
12643: ARRAY
12644: PUSH
12645: LD_INT 2
12647: ARRAY
12648: PPUSH
12649: CALL_OW 351
12653: IFFALSE 12706
// if not HasTask ( bulldozer ) then
12655: LD_VAR 0 1
12659: PPUSH
12660: CALL_OW 314
12664: NOT
12665: IFFALSE 12706
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
12667: LD_VAR 0 1
12671: PPUSH
12672: LD_VAR 0 2
12676: PUSH
12677: LD_VAR 0 4
12681: ARRAY
12682: PUSH
12683: LD_INT 1
12685: ARRAY
12686: PPUSH
12687: LD_VAR 0 2
12691: PUSH
12692: LD_VAR 0 4
12696: ARRAY
12697: PUSH
12698: LD_INT 2
12700: ARRAY
12701: PPUSH
12702: CALL_OW 171
12706: GO 12616
12708: POP
12709: POP
// end ;
12710: LD_VAR 0 3
12714: RET
// export function ComMeeting ( team , area ) ; var i , x , tmp , offset , sold_team , civil_team ; begin
12715: LD_INT 0
12717: PPUSH
12718: PPUSH
12719: PPUSH
12720: PPUSH
12721: PPUSH
12722: PPUSH
12723: PPUSH
// sold_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , class_soldier ] ] ) ;
12724: LD_ADDR_VAR 0 8
12728: PUSH
12729: LD_VAR 0 1
12733: PPUSH
12734: LD_INT 22
12736: PUSH
12737: LD_INT 1
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: PUSH
12744: LD_INT 21
12746: PUSH
12747: LD_INT 1
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 25
12756: PUSH
12757: LD_INT 1
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: LIST
12768: PPUSH
12769: CALL_OW 72
12773: ST_TO_ADDR
// civil_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , class_soldier ] ] ] ) ;
12774: LD_ADDR_VAR 0 9
12778: PUSH
12779: LD_VAR 0 1
12783: PPUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 1
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 21
12796: PUSH
12797: LD_INT 1
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 3
12806: PUSH
12807: LD_INT 25
12809: PUSH
12810: LD_INT 1
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: LIST
12825: PPUSH
12826: CALL_OW 72
12830: ST_TO_ADDR
// rows = MakeRows ( sold_team , civil_team ) ;
12831: LD_ADDR_EXP 47
12835: PUSH
12836: LD_VAR 0 8
12840: PPUSH
12841: LD_VAR 0 9
12845: PPUSH
12846: CALL 13239 0 2
12850: ST_TO_ADDR
// offset = 0 ;
12851: LD_ADDR_VAR 0 7
12855: PUSH
12856: LD_INT 0
12858: ST_TO_ADDR
// for i := 1 to sold_team do
12859: LD_ADDR_VAR 0 4
12863: PUSH
12864: DOUBLE
12865: LD_INT 1
12867: DEC
12868: ST_TO_ADDR
12869: LD_VAR 0 8
12873: PUSH
12874: FOR_TO
12875: IFFALSE 13006
// begin if IsInUnit ( sold_team [ i ] ) then
12877: LD_VAR 0 8
12881: PUSH
12882: LD_VAR 0 4
12886: ARRAY
12887: PPUSH
12888: CALL_OW 310
12892: IFFALSE 12909
// ComExitBuilding ( sold_team [ i ] ) ;
12894: LD_VAR 0 8
12898: PUSH
12899: LD_VAR 0 4
12903: ARRAY
12904: PPUSH
12905: CALL_OW 122
// AddComMoveXY ( sold_team [ i ] , rows [ 1 ] [ i + offset ] , rows [ 1 ] [ i + 1 + offset ] ) ;
12909: LD_VAR 0 8
12913: PUSH
12914: LD_VAR 0 4
12918: ARRAY
12919: PPUSH
12920: LD_EXP 47
12924: PUSH
12925: LD_INT 1
12927: ARRAY
12928: PUSH
12929: LD_VAR 0 4
12933: PUSH
12934: LD_VAR 0 7
12938: PLUS
12939: ARRAY
12940: PPUSH
12941: LD_EXP 47
12945: PUSH
12946: LD_INT 1
12948: ARRAY
12949: PUSH
12950: LD_VAR 0 4
12954: PUSH
12955: LD_INT 1
12957: PLUS
12958: PUSH
12959: LD_VAR 0 7
12963: PLUS
12964: ARRAY
12965: PPUSH
12966: CALL_OW 171
// AddComTurnUnit ( sold_team [ i ] , Brighton ) ;
12970: LD_VAR 0 8
12974: PUSH
12975: LD_VAR 0 4
12979: ARRAY
12980: PPUSH
12981: LD_EXP 9
12985: PPUSH
12986: CALL_OW 179
// offset = offset + 1 ;
12990: LD_ADDR_VAR 0 7
12994: PUSH
12995: LD_VAR 0 7
12999: PUSH
13000: LD_INT 1
13002: PLUS
13003: ST_TO_ADDR
// end ;
13004: GO 12874
13006: POP
13007: POP
// offset = 0 ;
13008: LD_ADDR_VAR 0 7
13012: PUSH
13013: LD_INT 0
13015: ST_TO_ADDR
// tmp = 1 ;
13016: LD_ADDR_VAR 0 6
13020: PUSH
13021: LD_INT 1
13023: ST_TO_ADDR
// for i := 2 to rows do
13024: LD_ADDR_VAR 0 4
13028: PUSH
13029: DOUBLE
13030: LD_INT 2
13032: DEC
13033: ST_TO_ADDR
13034: LD_EXP 47
13038: PUSH
13039: FOR_TO
13040: IFFALSE 13232
// begin for x := 1 to sold_team do
13042: LD_ADDR_VAR 0 5
13046: PUSH
13047: DOUBLE
13048: LD_INT 1
13050: DEC
13051: ST_TO_ADDR
13052: LD_VAR 0 8
13056: PUSH
13057: FOR_TO
13058: IFFALSE 13220
// begin if IsInUnit ( civil_team [ tmp ] ) then
13060: LD_VAR 0 9
13064: PUSH
13065: LD_VAR 0 6
13069: ARRAY
13070: PPUSH
13071: CALL_OW 310
13075: IFFALSE 13092
// ComExitBuilding ( civil_team [ tmp ] ) ;
13077: LD_VAR 0 9
13081: PUSH
13082: LD_VAR 0 6
13086: ARRAY
13087: PPUSH
13088: CALL_OW 122
// AddComMoveXY ( civil_team [ tmp ] , rows [ i ] [ x + offset ] , rows [ i ] [ x + 1 + offset ] ) ;
13092: LD_VAR 0 9
13096: PUSH
13097: LD_VAR 0 6
13101: ARRAY
13102: PPUSH
13103: LD_EXP 47
13107: PUSH
13108: LD_VAR 0 4
13112: ARRAY
13113: PUSH
13114: LD_VAR 0 5
13118: PUSH
13119: LD_VAR 0 7
13123: PLUS
13124: ARRAY
13125: PPUSH
13126: LD_EXP 47
13130: PUSH
13131: LD_VAR 0 4
13135: ARRAY
13136: PUSH
13137: LD_VAR 0 5
13141: PUSH
13142: LD_INT 1
13144: PLUS
13145: PUSH
13146: LD_VAR 0 7
13150: PLUS
13151: ARRAY
13152: PPUSH
13153: CALL_OW 171
// AddComTurnUnit ( civil_team [ tmp ] , Brighton ) ;
13157: LD_VAR 0 9
13161: PUSH
13162: LD_VAR 0 6
13166: ARRAY
13167: PPUSH
13168: LD_EXP 9
13172: PPUSH
13173: CALL_OW 179
// offset = offset + 1 ;
13177: LD_ADDR_VAR 0 7
13181: PUSH
13182: LD_VAR 0 7
13186: PUSH
13187: LD_INT 1
13189: PLUS
13190: ST_TO_ADDR
// if not ( tmp = civil_team ) then
13191: LD_VAR 0 6
13195: PUSH
13196: LD_VAR 0 9
13200: EQUAL
13201: NOT
13202: IFFALSE 13218
// tmp = tmp + 1 ;
13204: LD_ADDR_VAR 0 6
13208: PUSH
13209: LD_VAR 0 6
13213: PUSH
13214: LD_INT 1
13216: PLUS
13217: ST_TO_ADDR
// end ;
13218: GO 13057
13220: POP
13221: POP
// offset = 0 ;
13222: LD_ADDR_VAR 0 7
13226: PUSH
13227: LD_INT 0
13229: ST_TO_ADDR
// end ;
13230: GO 13039
13232: POP
13233: POP
// end ;
13234: LD_VAR 0 3
13238: RET
// export function MakeRows ( sold_team , civil_team ) ; var i , x , start_pos , row_size , new_row , result_rows , civil_rows , offsetX , offsetY ; begin
13239: LD_INT 0
13241: PPUSH
13242: PPUSH
13243: PPUSH
13244: PPUSH
13245: PPUSH
13246: PPUSH
13247: PPUSH
13248: PPUSH
13249: PPUSH
13250: PPUSH
// start_pos = [ 65 , 34 ] ;
13251: LD_ADDR_VAR 0 6
13255: PUSH
13256: LD_INT 65
13258: PUSH
13259: LD_INT 34
13261: PUSH
13262: EMPTY
13263: LIST
13264: LIST
13265: ST_TO_ADDR
// row_size = 0 ;
13266: LD_ADDR_VAR 0 7
13270: PUSH
13271: LD_INT 0
13273: ST_TO_ADDR
// result_rows = [ ] ;
13274: LD_ADDR_VAR 0 9
13278: PUSH
13279: EMPTY
13280: ST_TO_ADDR
// new_row = [ ] ;
13281: LD_ADDR_VAR 0 8
13285: PUSH
13286: EMPTY
13287: ST_TO_ADDR
// for i := 1 to sold_team do
13288: LD_ADDR_VAR 0 4
13292: PUSH
13293: DOUBLE
13294: LD_INT 1
13296: DEC
13297: ST_TO_ADDR
13298: LD_VAR 0 1
13302: PUSH
13303: FOR_TO
13304: IFFALSE 13358
// begin new_row = new_row ^ start_pos [ 1 ] ^ start_pos [ 2 ] + i ;
13306: LD_ADDR_VAR 0 8
13310: PUSH
13311: LD_VAR 0 8
13315: PUSH
13316: LD_VAR 0 6
13320: PUSH
13321: LD_INT 1
13323: ARRAY
13324: ADD
13325: PUSH
13326: LD_VAR 0 6
13330: PUSH
13331: LD_INT 2
13333: ARRAY
13334: PUSH
13335: LD_VAR 0 4
13339: PLUS
13340: ADD
13341: ST_TO_ADDR
// row_size = row_size + 1 ;
13342: LD_ADDR_VAR 0 7
13346: PUSH
13347: LD_VAR 0 7
13351: PUSH
13352: LD_INT 1
13354: PLUS
13355: ST_TO_ADDR
// end ;
13356: GO 13303
13358: POP
13359: POP
// result_rows = result_rows ^ [ new_row ] ;
13360: LD_ADDR_VAR 0 9
13364: PUSH
13365: LD_VAR 0 9
13369: PUSH
13370: LD_VAR 0 8
13374: PUSH
13375: EMPTY
13376: LIST
13377: ADD
13378: ST_TO_ADDR
// civil_rows = civil_team div sold_team ;
13379: LD_ADDR_VAR 0 10
13383: PUSH
13384: LD_VAR 0 2
13388: PUSH
13389: LD_VAR 0 1
13393: DIV
13394: ST_TO_ADDR
// if ( civil_rows mod sold_team > 0 ) then
13395: LD_VAR 0 10
13399: PUSH
13400: LD_VAR 0 1
13404: MOD
13405: PUSH
13406: LD_INT 0
13408: GREATER
13409: IFFALSE 13425
// civil_rows = civil_rows + 1 ;
13411: LD_ADDR_VAR 0 10
13415: PUSH
13416: LD_VAR 0 10
13420: PUSH
13421: LD_INT 1
13423: PLUS
13424: ST_TO_ADDR
// offsetX = 2 ;
13425: LD_ADDR_VAR 0 11
13429: PUSH
13430: LD_INT 2
13432: ST_TO_ADDR
// offsetY = 1 ;
13433: LD_ADDR_VAR 0 12
13437: PUSH
13438: LD_INT 1
13440: ST_TO_ADDR
// for i := 1 to civil_rows do
13441: LD_ADDR_VAR 0 4
13445: PUSH
13446: DOUBLE
13447: LD_INT 1
13449: DEC
13450: ST_TO_ADDR
13451: LD_VAR 0 10
13455: PUSH
13456: FOR_TO
13457: IFFALSE 13585
// begin new_row = [ ] ;
13459: LD_ADDR_VAR 0 8
13463: PUSH
13464: EMPTY
13465: ST_TO_ADDR
// for x := 1 to row_size do
13466: LD_ADDR_VAR 0 5
13470: PUSH
13471: DOUBLE
13472: LD_INT 1
13474: DEC
13475: ST_TO_ADDR
13476: LD_VAR 0 7
13480: PUSH
13481: FOR_TO
13482: IFFALSE 13534
// begin new_row = new_row ^ start_pos [ 1 ] + offsetX ^ start_pos [ 2 ] + offsetY + x ;
13484: LD_ADDR_VAR 0 8
13488: PUSH
13489: LD_VAR 0 8
13493: PUSH
13494: LD_VAR 0 6
13498: PUSH
13499: LD_INT 1
13501: ARRAY
13502: PUSH
13503: LD_VAR 0 11
13507: PLUS
13508: ADD
13509: PUSH
13510: LD_VAR 0 6
13514: PUSH
13515: LD_INT 2
13517: ARRAY
13518: PUSH
13519: LD_VAR 0 12
13523: PLUS
13524: PUSH
13525: LD_VAR 0 5
13529: PLUS
13530: ADD
13531: ST_TO_ADDR
// end ;
13532: GO 13481
13534: POP
13535: POP
// result_rows = result_rows ^ [ new_row ] ;
13536: LD_ADDR_VAR 0 9
13540: PUSH
13541: LD_VAR 0 9
13545: PUSH
13546: LD_VAR 0 8
13550: PUSH
13551: EMPTY
13552: LIST
13553: ADD
13554: ST_TO_ADDR
// offsetX = offsetX + 2 ;
13555: LD_ADDR_VAR 0 11
13559: PUSH
13560: LD_VAR 0 11
13564: PUSH
13565: LD_INT 2
13567: PLUS
13568: ST_TO_ADDR
// offsetY = offsetY + 1 ;
13569: LD_ADDR_VAR 0 12
13573: PUSH
13574: LD_VAR 0 12
13578: PUSH
13579: LD_INT 1
13581: PLUS
13582: ST_TO_ADDR
// end ;
13583: GO 13456
13585: POP
13586: POP
// result = result_rows ;
13587: LD_ADDR_VAR 0 3
13591: PUSH
13592: LD_VAR 0 9
13596: ST_TO_ADDR
// end ; end_of_file
13597: LD_VAR 0 3
13601: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13602: LD_INT 0
13604: PPUSH
13605: PPUSH
// if exist_mode then
13606: LD_VAR 0 2
13610: IFFALSE 13635
// unit := CreateCharacter ( prefix & ident ) else
13612: LD_ADDR_VAR 0 5
13616: PUSH
13617: LD_VAR 0 3
13621: PUSH
13622: LD_VAR 0 1
13626: STR
13627: PPUSH
13628: CALL_OW 34
13632: ST_TO_ADDR
13633: GO 13650
// unit := NewCharacter ( ident ) ;
13635: LD_ADDR_VAR 0 5
13639: PUSH
13640: LD_VAR 0 1
13644: PPUSH
13645: CALL_OW 25
13649: ST_TO_ADDR
// result := unit ;
13650: LD_ADDR_VAR 0 4
13654: PUSH
13655: LD_VAR 0 5
13659: ST_TO_ADDR
// end ;
13660: LD_VAR 0 4
13664: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13665: LD_INT 0
13667: PPUSH
13668: PPUSH
// if not side or not nation then
13669: LD_VAR 0 1
13673: NOT
13674: PUSH
13675: LD_VAR 0 2
13679: NOT
13680: OR
13681: IFFALSE 13685
// exit ;
13683: GO 14449
// case nation of nation_american :
13685: LD_VAR 0 2
13689: PUSH
13690: LD_INT 1
13692: DOUBLE
13693: EQUAL
13694: IFTRUE 13698
13696: GO 13912
13698: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
13699: LD_ADDR_VAR 0 4
13703: PUSH
13704: LD_INT 35
13706: PUSH
13707: LD_INT 45
13709: PUSH
13710: LD_INT 46
13712: PUSH
13713: LD_INT 47
13715: PUSH
13716: LD_INT 82
13718: PUSH
13719: LD_INT 83
13721: PUSH
13722: LD_INT 84
13724: PUSH
13725: LD_INT 85
13727: PUSH
13728: LD_INT 86
13730: PUSH
13731: LD_INT 1
13733: PUSH
13734: LD_INT 2
13736: PUSH
13737: LD_INT 6
13739: PUSH
13740: LD_INT 15
13742: PUSH
13743: LD_INT 16
13745: PUSH
13746: LD_INT 7
13748: PUSH
13749: LD_INT 12
13751: PUSH
13752: LD_INT 13
13754: PUSH
13755: LD_INT 10
13757: PUSH
13758: LD_INT 14
13760: PUSH
13761: LD_INT 20
13763: PUSH
13764: LD_INT 21
13766: PUSH
13767: LD_INT 22
13769: PUSH
13770: LD_INT 25
13772: PUSH
13773: LD_INT 32
13775: PUSH
13776: LD_INT 27
13778: PUSH
13779: LD_INT 36
13781: PUSH
13782: LD_INT 69
13784: PUSH
13785: LD_INT 39
13787: PUSH
13788: LD_INT 34
13790: PUSH
13791: LD_INT 40
13793: PUSH
13794: LD_INT 48
13796: PUSH
13797: LD_INT 49
13799: PUSH
13800: LD_INT 50
13802: PUSH
13803: LD_INT 51
13805: PUSH
13806: LD_INT 52
13808: PUSH
13809: LD_INT 53
13811: PUSH
13812: LD_INT 54
13814: PUSH
13815: LD_INT 55
13817: PUSH
13818: LD_INT 56
13820: PUSH
13821: LD_INT 57
13823: PUSH
13824: LD_INT 58
13826: PUSH
13827: LD_INT 59
13829: PUSH
13830: LD_INT 60
13832: PUSH
13833: LD_INT 61
13835: PUSH
13836: LD_INT 62
13838: PUSH
13839: LD_INT 80
13841: PUSH
13842: LD_INT 82
13844: PUSH
13845: LD_INT 83
13847: PUSH
13848: LD_INT 84
13850: PUSH
13851: LD_INT 85
13853: PUSH
13854: LD_INT 86
13856: PUSH
13857: EMPTY
13858: LIST
13859: LIST
13860: LIST
13861: LIST
13862: LIST
13863: LIST
13864: LIST
13865: LIST
13866: LIST
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: ST_TO_ADDR
13910: GO 14373
13912: LD_INT 2
13914: DOUBLE
13915: EQUAL
13916: IFTRUE 13920
13918: GO 14142
13920: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
13921: LD_ADDR_VAR 0 4
13925: PUSH
13926: LD_INT 35
13928: PUSH
13929: LD_INT 45
13931: PUSH
13932: LD_INT 46
13934: PUSH
13935: LD_INT 47
13937: PUSH
13938: LD_INT 82
13940: PUSH
13941: LD_INT 83
13943: PUSH
13944: LD_INT 84
13946: PUSH
13947: LD_INT 85
13949: PUSH
13950: LD_INT 87
13952: PUSH
13953: LD_INT 70
13955: PUSH
13956: LD_INT 1
13958: PUSH
13959: LD_INT 11
13961: PUSH
13962: LD_INT 3
13964: PUSH
13965: LD_INT 4
13967: PUSH
13968: LD_INT 5
13970: PUSH
13971: LD_INT 6
13973: PUSH
13974: LD_INT 15
13976: PUSH
13977: LD_INT 18
13979: PUSH
13980: LD_INT 7
13982: PUSH
13983: LD_INT 17
13985: PUSH
13986: LD_INT 8
13988: PUSH
13989: LD_INT 20
13991: PUSH
13992: LD_INT 21
13994: PUSH
13995: LD_INT 22
13997: PUSH
13998: LD_INT 72
14000: PUSH
14001: LD_INT 26
14003: PUSH
14004: LD_INT 69
14006: PUSH
14007: LD_INT 39
14009: PUSH
14010: LD_INT 40
14012: PUSH
14013: LD_INT 41
14015: PUSH
14016: LD_INT 42
14018: PUSH
14019: LD_INT 43
14021: PUSH
14022: LD_INT 48
14024: PUSH
14025: LD_INT 49
14027: PUSH
14028: LD_INT 50
14030: PUSH
14031: LD_INT 51
14033: PUSH
14034: LD_INT 52
14036: PUSH
14037: LD_INT 53
14039: PUSH
14040: LD_INT 54
14042: PUSH
14043: LD_INT 55
14045: PUSH
14046: LD_INT 56
14048: PUSH
14049: LD_INT 60
14051: PUSH
14052: LD_INT 61
14054: PUSH
14055: LD_INT 62
14057: PUSH
14058: LD_INT 66
14060: PUSH
14061: LD_INT 67
14063: PUSH
14064: LD_INT 68
14066: PUSH
14067: LD_INT 81
14069: PUSH
14070: LD_INT 82
14072: PUSH
14073: LD_INT 83
14075: PUSH
14076: LD_INT 84
14078: PUSH
14079: LD_INT 85
14081: PUSH
14082: LD_INT 87
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: LIST
14089: LIST
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: ST_TO_ADDR
14140: GO 14373
14142: LD_INT 3
14144: DOUBLE
14145: EQUAL
14146: IFTRUE 14150
14148: GO 14372
14150: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14151: LD_ADDR_VAR 0 4
14155: PUSH
14156: LD_INT 46
14158: PUSH
14159: LD_INT 47
14161: PUSH
14162: LD_INT 1
14164: PUSH
14165: LD_INT 2
14167: PUSH
14168: LD_INT 82
14170: PUSH
14171: LD_INT 83
14173: PUSH
14174: LD_INT 84
14176: PUSH
14177: LD_INT 85
14179: PUSH
14180: LD_INT 86
14182: PUSH
14183: LD_INT 11
14185: PUSH
14186: LD_INT 9
14188: PUSH
14189: LD_INT 20
14191: PUSH
14192: LD_INT 19
14194: PUSH
14195: LD_INT 21
14197: PUSH
14198: LD_INT 24
14200: PUSH
14201: LD_INT 22
14203: PUSH
14204: LD_INT 25
14206: PUSH
14207: LD_INT 28
14209: PUSH
14210: LD_INT 29
14212: PUSH
14213: LD_INT 30
14215: PUSH
14216: LD_INT 31
14218: PUSH
14219: LD_INT 37
14221: PUSH
14222: LD_INT 38
14224: PUSH
14225: LD_INT 32
14227: PUSH
14228: LD_INT 27
14230: PUSH
14231: LD_INT 33
14233: PUSH
14234: LD_INT 69
14236: PUSH
14237: LD_INT 39
14239: PUSH
14240: LD_INT 34
14242: PUSH
14243: LD_INT 40
14245: PUSH
14246: LD_INT 71
14248: PUSH
14249: LD_INT 23
14251: PUSH
14252: LD_INT 44
14254: PUSH
14255: LD_INT 48
14257: PUSH
14258: LD_INT 49
14260: PUSH
14261: LD_INT 50
14263: PUSH
14264: LD_INT 51
14266: PUSH
14267: LD_INT 52
14269: PUSH
14270: LD_INT 53
14272: PUSH
14273: LD_INT 54
14275: PUSH
14276: LD_INT 55
14278: PUSH
14279: LD_INT 56
14281: PUSH
14282: LD_INT 57
14284: PUSH
14285: LD_INT 58
14287: PUSH
14288: LD_INT 59
14290: PUSH
14291: LD_INT 63
14293: PUSH
14294: LD_INT 64
14296: PUSH
14297: LD_INT 65
14299: PUSH
14300: LD_INT 82
14302: PUSH
14303: LD_INT 83
14305: PUSH
14306: LD_INT 84
14308: PUSH
14309: LD_INT 85
14311: PUSH
14312: LD_INT 86
14314: PUSH
14315: EMPTY
14316: LIST
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: ST_TO_ADDR
14370: GO 14373
14372: POP
// if state > - 1 and state < 3 then
14373: LD_VAR 0 3
14377: PUSH
14378: LD_INT 1
14380: NEG
14381: GREATER
14382: PUSH
14383: LD_VAR 0 3
14387: PUSH
14388: LD_INT 3
14390: LESS
14391: AND
14392: IFFALSE 14449
// for i in result do
14394: LD_ADDR_VAR 0 5
14398: PUSH
14399: LD_VAR 0 4
14403: PUSH
14404: FOR_IN
14405: IFFALSE 14447
// if GetTech ( i , side ) <> state then
14407: LD_VAR 0 5
14411: PPUSH
14412: LD_VAR 0 1
14416: PPUSH
14417: CALL_OW 321
14421: PUSH
14422: LD_VAR 0 3
14426: NONEQUAL
14427: IFFALSE 14445
// result := result diff i ;
14429: LD_ADDR_VAR 0 4
14433: PUSH
14434: LD_VAR 0 4
14438: PUSH
14439: LD_VAR 0 5
14443: DIFF
14444: ST_TO_ADDR
14445: GO 14404
14447: POP
14448: POP
// end ;
14449: LD_VAR 0 4
14453: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14454: LD_INT 0
14456: PPUSH
14457: PPUSH
14458: PPUSH
// result := true ;
14459: LD_ADDR_VAR 0 3
14463: PUSH
14464: LD_INT 1
14466: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14467: LD_ADDR_VAR 0 5
14471: PUSH
14472: LD_VAR 0 2
14476: PPUSH
14477: CALL_OW 480
14481: ST_TO_ADDR
// if not tmp then
14482: LD_VAR 0 5
14486: NOT
14487: IFFALSE 14491
// exit ;
14489: GO 14540
// for i in tmp do
14491: LD_ADDR_VAR 0 4
14495: PUSH
14496: LD_VAR 0 5
14500: PUSH
14501: FOR_IN
14502: IFFALSE 14538
// if GetTech ( i , side ) <> state_researched then
14504: LD_VAR 0 4
14508: PPUSH
14509: LD_VAR 0 1
14513: PPUSH
14514: CALL_OW 321
14518: PUSH
14519: LD_INT 2
14521: NONEQUAL
14522: IFFALSE 14536
// begin result := false ;
14524: LD_ADDR_VAR 0 3
14528: PUSH
14529: LD_INT 0
14531: ST_TO_ADDR
// exit ;
14532: POP
14533: POP
14534: GO 14540
// end ;
14536: GO 14501
14538: POP
14539: POP
// end ;
14540: LD_VAR 0 3
14544: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14545: LD_INT 0
14547: PPUSH
14548: PPUSH
14549: PPUSH
14550: PPUSH
14551: PPUSH
14552: PPUSH
14553: PPUSH
14554: PPUSH
14555: PPUSH
14556: PPUSH
14557: PPUSH
14558: PPUSH
14559: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14560: LD_VAR 0 1
14564: NOT
14565: PUSH
14566: LD_VAR 0 1
14570: PPUSH
14571: CALL_OW 257
14575: PUSH
14576: LD_INT 9
14578: NONEQUAL
14579: OR
14580: IFFALSE 14584
// exit ;
14582: GO 15157
// side := GetSide ( unit ) ;
14584: LD_ADDR_VAR 0 9
14588: PUSH
14589: LD_VAR 0 1
14593: PPUSH
14594: CALL_OW 255
14598: ST_TO_ADDR
// tech_space := tech_spacanom ;
14599: LD_ADDR_VAR 0 12
14603: PUSH
14604: LD_INT 29
14606: ST_TO_ADDR
// tech_time := tech_taurad ;
14607: LD_ADDR_VAR 0 13
14611: PUSH
14612: LD_INT 28
14614: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14615: LD_ADDR_VAR 0 11
14619: PUSH
14620: LD_VAR 0 1
14624: PPUSH
14625: CALL_OW 310
14629: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14630: LD_VAR 0 11
14634: PPUSH
14635: CALL_OW 247
14639: PUSH
14640: LD_INT 2
14642: EQUAL
14643: IFFALSE 14647
// exit ;
14645: GO 15157
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14647: LD_ADDR_VAR 0 8
14651: PUSH
14652: LD_INT 81
14654: PUSH
14655: LD_VAR 0 9
14659: PUSH
14660: EMPTY
14661: LIST
14662: LIST
14663: PUSH
14664: LD_INT 3
14666: PUSH
14667: LD_INT 21
14669: PUSH
14670: LD_INT 3
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PPUSH
14685: CALL_OW 69
14689: ST_TO_ADDR
// if not tmp then
14690: LD_VAR 0 8
14694: NOT
14695: IFFALSE 14699
// exit ;
14697: GO 15157
// if in_unit then
14699: LD_VAR 0 11
14703: IFFALSE 14727
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14705: LD_ADDR_VAR 0 10
14709: PUSH
14710: LD_VAR 0 8
14714: PPUSH
14715: LD_VAR 0 11
14719: PPUSH
14720: CALL_OW 74
14724: ST_TO_ADDR
14725: GO 14747
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14727: LD_ADDR_VAR 0 10
14731: PUSH
14732: LD_VAR 0 8
14736: PPUSH
14737: LD_VAR 0 1
14741: PPUSH
14742: CALL_OW 74
14746: ST_TO_ADDR
// if not enemy then
14747: LD_VAR 0 10
14751: NOT
14752: IFFALSE 14756
// exit ;
14754: GO 15157
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14756: LD_VAR 0 11
14760: PUSH
14761: LD_VAR 0 11
14765: PPUSH
14766: LD_VAR 0 10
14770: PPUSH
14771: CALL_OW 296
14775: PUSH
14776: LD_INT 13
14778: GREATER
14779: AND
14780: PUSH
14781: LD_VAR 0 1
14785: PPUSH
14786: LD_VAR 0 10
14790: PPUSH
14791: CALL_OW 296
14795: PUSH
14796: LD_INT 12
14798: GREATER
14799: OR
14800: IFFALSE 14804
// exit ;
14802: GO 15157
// missile := [ 1 ] ;
14804: LD_ADDR_VAR 0 14
14808: PUSH
14809: LD_INT 1
14811: PUSH
14812: EMPTY
14813: LIST
14814: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14815: LD_VAR 0 9
14819: PPUSH
14820: LD_VAR 0 12
14824: PPUSH
14825: CALL_OW 325
14829: IFFALSE 14858
// missile := Insert ( missile , missile + 1 , 2 ) ;
14831: LD_ADDR_VAR 0 14
14835: PUSH
14836: LD_VAR 0 14
14840: PPUSH
14841: LD_VAR 0 14
14845: PUSH
14846: LD_INT 1
14848: PLUS
14849: PPUSH
14850: LD_INT 2
14852: PPUSH
14853: CALL_OW 2
14857: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14858: LD_VAR 0 9
14862: PPUSH
14863: LD_VAR 0 13
14867: PPUSH
14868: CALL_OW 325
14872: PUSH
14873: LD_VAR 0 10
14877: PPUSH
14878: CALL_OW 255
14882: PPUSH
14883: LD_VAR 0 13
14887: PPUSH
14888: CALL_OW 325
14892: NOT
14893: AND
14894: IFFALSE 14923
// missile := Insert ( missile , missile + 1 , 3 ) ;
14896: LD_ADDR_VAR 0 14
14900: PUSH
14901: LD_VAR 0 14
14905: PPUSH
14906: LD_VAR 0 14
14910: PUSH
14911: LD_INT 1
14913: PLUS
14914: PPUSH
14915: LD_INT 3
14917: PPUSH
14918: CALL_OW 2
14922: ST_TO_ADDR
// if missile < 2 then
14923: LD_VAR 0 14
14927: PUSH
14928: LD_INT 2
14930: LESS
14931: IFFALSE 14935
// exit ;
14933: GO 15157
// x := GetX ( enemy ) ;
14935: LD_ADDR_VAR 0 4
14939: PUSH
14940: LD_VAR 0 10
14944: PPUSH
14945: CALL_OW 250
14949: ST_TO_ADDR
// y := GetY ( enemy ) ;
14950: LD_ADDR_VAR 0 5
14954: PUSH
14955: LD_VAR 0 10
14959: PPUSH
14960: CALL_OW 251
14964: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14965: LD_ADDR_VAR 0 6
14969: PUSH
14970: LD_VAR 0 4
14974: PUSH
14975: LD_INT 1
14977: NEG
14978: PPUSH
14979: LD_INT 1
14981: PPUSH
14982: CALL_OW 12
14986: PLUS
14987: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
14988: LD_ADDR_VAR 0 7
14992: PUSH
14993: LD_VAR 0 5
14997: PUSH
14998: LD_INT 1
15000: NEG
15001: PPUSH
15002: LD_INT 1
15004: PPUSH
15005: CALL_OW 12
15009: PLUS
15010: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15011: LD_VAR 0 6
15015: PPUSH
15016: LD_VAR 0 7
15020: PPUSH
15021: CALL_OW 488
15025: NOT
15026: IFFALSE 15048
// begin _x := x ;
15028: LD_ADDR_VAR 0 6
15032: PUSH
15033: LD_VAR 0 4
15037: ST_TO_ADDR
// _y := y ;
15038: LD_ADDR_VAR 0 7
15042: PUSH
15043: LD_VAR 0 5
15047: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15048: LD_ADDR_VAR 0 3
15052: PUSH
15053: LD_INT 1
15055: PPUSH
15056: LD_VAR 0 14
15060: PPUSH
15061: CALL_OW 12
15065: ST_TO_ADDR
// case i of 1 :
15066: LD_VAR 0 3
15070: PUSH
15071: LD_INT 1
15073: DOUBLE
15074: EQUAL
15075: IFTRUE 15079
15077: GO 15096
15079: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15080: LD_VAR 0 1
15084: PPUSH
15085: LD_VAR 0 10
15089: PPUSH
15090: CALL_OW 115
15094: GO 15157
15096: LD_INT 2
15098: DOUBLE
15099: EQUAL
15100: IFTRUE 15104
15102: GO 15126
15104: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15105: LD_VAR 0 1
15109: PPUSH
15110: LD_VAR 0 6
15114: PPUSH
15115: LD_VAR 0 7
15119: PPUSH
15120: CALL_OW 153
15124: GO 15157
15126: LD_INT 3
15128: DOUBLE
15129: EQUAL
15130: IFTRUE 15134
15132: GO 15156
15134: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15135: LD_VAR 0 1
15139: PPUSH
15140: LD_VAR 0 6
15144: PPUSH
15145: LD_VAR 0 7
15149: PPUSH
15150: CALL_OW 154
15154: GO 15157
15156: POP
// end ;
15157: LD_VAR 0 2
15161: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15162: LD_INT 0
15164: PPUSH
15165: PPUSH
15166: PPUSH
15167: PPUSH
15168: PPUSH
15169: PPUSH
// if not unit or not building then
15170: LD_VAR 0 1
15174: NOT
15175: PUSH
15176: LD_VAR 0 2
15180: NOT
15181: OR
15182: IFFALSE 15186
// exit ;
15184: GO 15344
// x := GetX ( building ) ;
15186: LD_ADDR_VAR 0 5
15190: PUSH
15191: LD_VAR 0 2
15195: PPUSH
15196: CALL_OW 250
15200: ST_TO_ADDR
// y := GetY ( building ) ;
15201: LD_ADDR_VAR 0 6
15205: PUSH
15206: LD_VAR 0 2
15210: PPUSH
15211: CALL_OW 251
15215: ST_TO_ADDR
// for i = 0 to 5 do
15216: LD_ADDR_VAR 0 4
15220: PUSH
15221: DOUBLE
15222: LD_INT 0
15224: DEC
15225: ST_TO_ADDR
15226: LD_INT 5
15228: PUSH
15229: FOR_TO
15230: IFFALSE 15342
// begin _x := ShiftX ( x , i , 3 ) ;
15232: LD_ADDR_VAR 0 7
15236: PUSH
15237: LD_VAR 0 5
15241: PPUSH
15242: LD_VAR 0 4
15246: PPUSH
15247: LD_INT 3
15249: PPUSH
15250: CALL_OW 272
15254: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15255: LD_ADDR_VAR 0 8
15259: PUSH
15260: LD_VAR 0 6
15264: PPUSH
15265: LD_VAR 0 4
15269: PPUSH
15270: LD_INT 3
15272: PPUSH
15273: CALL_OW 273
15277: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15278: LD_VAR 0 7
15282: PPUSH
15283: LD_VAR 0 8
15287: PPUSH
15288: CALL_OW 488
15292: NOT
15293: IFFALSE 15297
// continue ;
15295: GO 15229
// if HexInfo ( _x , _y ) = 0 then
15297: LD_VAR 0 7
15301: PPUSH
15302: LD_VAR 0 8
15306: PPUSH
15307: CALL_OW 428
15311: PUSH
15312: LD_INT 0
15314: EQUAL
15315: IFFALSE 15340
// begin ComMoveXY ( unit , _x , _y ) ;
15317: LD_VAR 0 1
15321: PPUSH
15322: LD_VAR 0 7
15326: PPUSH
15327: LD_VAR 0 8
15331: PPUSH
15332: CALL_OW 111
// exit ;
15336: POP
15337: POP
15338: GO 15344
// end ; end ;
15340: GO 15229
15342: POP
15343: POP
// end ;
15344: LD_VAR 0 3
15348: RET
// export function ScanBase ( side , base_area ) ; begin
15349: LD_INT 0
15351: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15352: LD_ADDR_VAR 0 3
15356: PUSH
15357: LD_VAR 0 2
15361: PPUSH
15362: LD_INT 81
15364: PUSH
15365: LD_VAR 0 1
15369: PUSH
15370: EMPTY
15371: LIST
15372: LIST
15373: PPUSH
15374: CALL_OW 70
15378: ST_TO_ADDR
// end ;
15379: LD_VAR 0 3
15383: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15384: LD_INT 0
15386: PPUSH
15387: PPUSH
15388: PPUSH
15389: PPUSH
// result := false ;
15390: LD_ADDR_VAR 0 2
15394: PUSH
15395: LD_INT 0
15397: ST_TO_ADDR
// side := GetSide ( unit ) ;
15398: LD_ADDR_VAR 0 3
15402: PUSH
15403: LD_VAR 0 1
15407: PPUSH
15408: CALL_OW 255
15412: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15413: LD_ADDR_VAR 0 4
15417: PUSH
15418: LD_VAR 0 1
15422: PPUSH
15423: CALL_OW 248
15427: ST_TO_ADDR
// case nat of 1 :
15428: LD_VAR 0 4
15432: PUSH
15433: LD_INT 1
15435: DOUBLE
15436: EQUAL
15437: IFTRUE 15441
15439: GO 15452
15441: POP
// tech := tech_lassight ; 2 :
15442: LD_ADDR_VAR 0 5
15446: PUSH
15447: LD_INT 12
15449: ST_TO_ADDR
15450: GO 15491
15452: LD_INT 2
15454: DOUBLE
15455: EQUAL
15456: IFTRUE 15460
15458: GO 15471
15460: POP
// tech := tech_mortar ; 3 :
15461: LD_ADDR_VAR 0 5
15465: PUSH
15466: LD_INT 41
15468: ST_TO_ADDR
15469: GO 15491
15471: LD_INT 3
15473: DOUBLE
15474: EQUAL
15475: IFTRUE 15479
15477: GO 15490
15479: POP
// tech := tech_bazooka ; end ;
15480: LD_ADDR_VAR 0 5
15484: PUSH
15485: LD_INT 44
15487: ST_TO_ADDR
15488: GO 15491
15490: POP
// if Researched ( side , tech ) then
15491: LD_VAR 0 3
15495: PPUSH
15496: LD_VAR 0 5
15500: PPUSH
15501: CALL_OW 325
15505: IFFALSE 15532
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15507: LD_ADDR_VAR 0 2
15511: PUSH
15512: LD_INT 5
15514: PUSH
15515: LD_INT 8
15517: PUSH
15518: LD_INT 9
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: LIST
15525: PUSH
15526: LD_VAR 0 4
15530: ARRAY
15531: ST_TO_ADDR
// end ;
15532: LD_VAR 0 2
15536: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15537: LD_INT 0
15539: PPUSH
15540: PPUSH
15541: PPUSH
// if not mines then
15542: LD_VAR 0 2
15546: NOT
15547: IFFALSE 15551
// exit ;
15549: GO 15695
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15551: LD_ADDR_VAR 0 5
15555: PUSH
15556: LD_INT 81
15558: PUSH
15559: LD_VAR 0 1
15563: PUSH
15564: EMPTY
15565: LIST
15566: LIST
15567: PUSH
15568: LD_INT 3
15570: PUSH
15571: LD_INT 21
15573: PUSH
15574: LD_INT 3
15576: PUSH
15577: EMPTY
15578: LIST
15579: LIST
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PPUSH
15589: CALL_OW 69
15593: ST_TO_ADDR
// for i in mines do
15594: LD_ADDR_VAR 0 4
15598: PUSH
15599: LD_VAR 0 2
15603: PUSH
15604: FOR_IN
15605: IFFALSE 15693
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15607: LD_VAR 0 4
15611: PUSH
15612: LD_INT 1
15614: ARRAY
15615: PPUSH
15616: LD_VAR 0 4
15620: PUSH
15621: LD_INT 2
15623: ARRAY
15624: PPUSH
15625: CALL_OW 458
15629: NOT
15630: IFFALSE 15634
// continue ;
15632: GO 15604
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15634: LD_VAR 0 4
15638: PUSH
15639: LD_INT 1
15641: ARRAY
15642: PPUSH
15643: LD_VAR 0 4
15647: PUSH
15648: LD_INT 2
15650: ARRAY
15651: PPUSH
15652: CALL_OW 428
15656: PUSH
15657: LD_VAR 0 5
15661: IN
15662: IFFALSE 15691
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15664: LD_VAR 0 4
15668: PUSH
15669: LD_INT 1
15671: ARRAY
15672: PPUSH
15673: LD_VAR 0 4
15677: PUSH
15678: LD_INT 2
15680: ARRAY
15681: PPUSH
15682: LD_VAR 0 1
15686: PPUSH
15687: CALL_OW 456
// end ;
15691: GO 15604
15693: POP
15694: POP
// end ;
15695: LD_VAR 0 3
15699: RET
// export function Count ( array ) ; var i ; begin
15700: LD_INT 0
15702: PPUSH
15703: PPUSH
// result := 0 ;
15704: LD_ADDR_VAR 0 2
15708: PUSH
15709: LD_INT 0
15711: ST_TO_ADDR
// for i in array do
15712: LD_ADDR_VAR 0 3
15716: PUSH
15717: LD_VAR 0 1
15721: PUSH
15722: FOR_IN
15723: IFFALSE 15747
// if i then
15725: LD_VAR 0 3
15729: IFFALSE 15745
// result := result + 1 ;
15731: LD_ADDR_VAR 0 2
15735: PUSH
15736: LD_VAR 0 2
15740: PUSH
15741: LD_INT 1
15743: PLUS
15744: ST_TO_ADDR
15745: GO 15722
15747: POP
15748: POP
// end ;
15749: LD_VAR 0 2
15753: RET
// export function IsEmpty ( building ) ; begin
15754: LD_INT 0
15756: PPUSH
// if not building then
15757: LD_VAR 0 1
15761: NOT
15762: IFFALSE 15766
// exit ;
15764: GO 15809
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15766: LD_ADDR_VAR 0 2
15770: PUSH
15771: LD_VAR 0 1
15775: PUSH
15776: LD_INT 22
15778: PUSH
15779: LD_VAR 0 1
15783: PPUSH
15784: CALL_OW 255
15788: PUSH
15789: EMPTY
15790: LIST
15791: LIST
15792: PUSH
15793: LD_INT 58
15795: PUSH
15796: EMPTY
15797: LIST
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: PPUSH
15803: CALL_OW 69
15807: IN
15808: ST_TO_ADDR
// end ;
15809: LD_VAR 0 2
15813: RET
// export function IsNotFull ( building ) ; begin
15814: LD_INT 0
15816: PPUSH
// if not building then
15817: LD_VAR 0 1
15821: NOT
15822: IFFALSE 15826
// exit ;
15824: GO 15845
// result := UnitsInside ( building ) < 6 ;
15826: LD_ADDR_VAR 0 2
15830: PUSH
15831: LD_VAR 0 1
15835: PPUSH
15836: CALL_OW 313
15840: PUSH
15841: LD_INT 6
15843: LESS
15844: ST_TO_ADDR
// end ;
15845: LD_VAR 0 2
15849: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
15850: LD_INT 0
15852: PPUSH
15853: PPUSH
15854: PPUSH
15855: PPUSH
// tmp := [ ] ;
15856: LD_ADDR_VAR 0 3
15860: PUSH
15861: EMPTY
15862: ST_TO_ADDR
// list := [ ] ;
15863: LD_ADDR_VAR 0 5
15867: PUSH
15868: EMPTY
15869: ST_TO_ADDR
// for i = 16 to 25 do
15870: LD_ADDR_VAR 0 4
15874: PUSH
15875: DOUBLE
15876: LD_INT 16
15878: DEC
15879: ST_TO_ADDR
15880: LD_INT 25
15882: PUSH
15883: FOR_TO
15884: IFFALSE 15957
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
15886: LD_ADDR_VAR 0 3
15890: PUSH
15891: LD_VAR 0 3
15895: PUSH
15896: LD_INT 22
15898: PUSH
15899: LD_VAR 0 1
15903: PPUSH
15904: CALL_OW 255
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: PUSH
15913: LD_INT 91
15915: PUSH
15916: LD_VAR 0 1
15920: PUSH
15921: LD_INT 6
15923: PUSH
15924: EMPTY
15925: LIST
15926: LIST
15927: LIST
15928: PUSH
15929: LD_INT 30
15931: PUSH
15932: LD_VAR 0 4
15936: PUSH
15937: EMPTY
15938: LIST
15939: LIST
15940: PUSH
15941: EMPTY
15942: LIST
15943: LIST
15944: LIST
15945: PUSH
15946: EMPTY
15947: LIST
15948: PPUSH
15949: CALL_OW 69
15953: ADD
15954: ST_TO_ADDR
15955: GO 15883
15957: POP
15958: POP
// for i = 1 to tmp do
15959: LD_ADDR_VAR 0 4
15963: PUSH
15964: DOUBLE
15965: LD_INT 1
15967: DEC
15968: ST_TO_ADDR
15969: LD_VAR 0 3
15973: PUSH
15974: FOR_TO
15975: IFFALSE 16063
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
15977: LD_ADDR_VAR 0 5
15981: PUSH
15982: LD_VAR 0 5
15986: PUSH
15987: LD_VAR 0 3
15991: PUSH
15992: LD_VAR 0 4
15996: ARRAY
15997: PPUSH
15998: CALL_OW 266
16002: PUSH
16003: LD_VAR 0 3
16007: PUSH
16008: LD_VAR 0 4
16012: ARRAY
16013: PPUSH
16014: CALL_OW 250
16018: PUSH
16019: LD_VAR 0 3
16023: PUSH
16024: LD_VAR 0 4
16028: ARRAY
16029: PPUSH
16030: CALL_OW 251
16034: PUSH
16035: LD_VAR 0 3
16039: PUSH
16040: LD_VAR 0 4
16044: ARRAY
16045: PPUSH
16046: CALL_OW 254
16050: PUSH
16051: EMPTY
16052: LIST
16053: LIST
16054: LIST
16055: LIST
16056: PUSH
16057: EMPTY
16058: LIST
16059: ADD
16060: ST_TO_ADDR
16061: GO 15974
16063: POP
16064: POP
// result := list ;
16065: LD_ADDR_VAR 0 2
16069: PUSH
16070: LD_VAR 0 5
16074: ST_TO_ADDR
// end ;
16075: LD_VAR 0 2
16079: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16080: LD_INT 0
16082: PPUSH
16083: PPUSH
16084: PPUSH
16085: PPUSH
16086: PPUSH
16087: PPUSH
16088: PPUSH
// if not factory then
16089: LD_VAR 0 1
16093: NOT
16094: IFFALSE 16098
// exit ;
16096: GO 16691
// if control = control_apeman then
16098: LD_VAR 0 4
16102: PUSH
16103: LD_INT 5
16105: EQUAL
16106: IFFALSE 16215
// begin tmp := UnitsInside ( factory ) ;
16108: LD_ADDR_VAR 0 8
16112: PUSH
16113: LD_VAR 0 1
16117: PPUSH
16118: CALL_OW 313
16122: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16123: LD_VAR 0 8
16127: PPUSH
16128: LD_INT 25
16130: PUSH
16131: LD_INT 12
16133: PUSH
16134: EMPTY
16135: LIST
16136: LIST
16137: PPUSH
16138: CALL_OW 72
16142: NOT
16143: IFFALSE 16153
// control := control_manual ;
16145: LD_ADDR_VAR 0 4
16149: PUSH
16150: LD_INT 1
16152: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16153: LD_ADDR_VAR 0 8
16157: PUSH
16158: LD_VAR 0 1
16162: PPUSH
16163: CALL 15850 0 1
16167: ST_TO_ADDR
// if tmp then
16168: LD_VAR 0 8
16172: IFFALSE 16215
// begin for i in tmp do
16174: LD_ADDR_VAR 0 7
16178: PUSH
16179: LD_VAR 0 8
16183: PUSH
16184: FOR_IN
16185: IFFALSE 16213
// if i [ 1 ] = b_ext_radio then
16187: LD_VAR 0 7
16191: PUSH
16192: LD_INT 1
16194: ARRAY
16195: PUSH
16196: LD_INT 22
16198: EQUAL
16199: IFFALSE 16211
// begin control := control_remote ;
16201: LD_ADDR_VAR 0 4
16205: PUSH
16206: LD_INT 2
16208: ST_TO_ADDR
// break ;
16209: GO 16213
// end ;
16211: GO 16184
16213: POP
16214: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16215: LD_VAR 0 1
16219: PPUSH
16220: LD_VAR 0 2
16224: PPUSH
16225: LD_VAR 0 3
16229: PPUSH
16230: LD_VAR 0 4
16234: PPUSH
16235: LD_VAR 0 5
16239: PPUSH
16240: CALL_OW 448
16244: IFFALSE 16279
// begin result := [ chassis , engine , control , weapon ] ;
16246: LD_ADDR_VAR 0 6
16250: PUSH
16251: LD_VAR 0 2
16255: PUSH
16256: LD_VAR 0 3
16260: PUSH
16261: LD_VAR 0 4
16265: PUSH
16266: LD_VAR 0 5
16270: PUSH
16271: EMPTY
16272: LIST
16273: LIST
16274: LIST
16275: LIST
16276: ST_TO_ADDR
// exit ;
16277: GO 16691
// end ; _chassis := AvailableChassisList ( factory ) ;
16279: LD_ADDR_VAR 0 9
16283: PUSH
16284: LD_VAR 0 1
16288: PPUSH
16289: CALL_OW 475
16293: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16294: LD_ADDR_VAR 0 11
16298: PUSH
16299: LD_VAR 0 1
16303: PPUSH
16304: CALL_OW 476
16308: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16309: LD_ADDR_VAR 0 12
16313: PUSH
16314: LD_VAR 0 1
16318: PPUSH
16319: CALL_OW 477
16323: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
16324: LD_ADDR_VAR 0 10
16328: PUSH
16329: LD_VAR 0 1
16333: PPUSH
16334: CALL_OW 478
16338: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
16339: LD_VAR 0 9
16343: NOT
16344: PUSH
16345: LD_VAR 0 11
16349: NOT
16350: OR
16351: PUSH
16352: LD_VAR 0 12
16356: NOT
16357: OR
16358: PUSH
16359: LD_VAR 0 10
16363: NOT
16364: OR
16365: IFFALSE 16400
// begin result := [ chassis , engine , control , weapon ] ;
16367: LD_ADDR_VAR 0 6
16371: PUSH
16372: LD_VAR 0 2
16376: PUSH
16377: LD_VAR 0 3
16381: PUSH
16382: LD_VAR 0 4
16386: PUSH
16387: LD_VAR 0 5
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: LIST
16396: LIST
16397: ST_TO_ADDR
// exit ;
16398: GO 16691
// end ; if not chassis in _chassis then
16400: LD_VAR 0 2
16404: PUSH
16405: LD_VAR 0 9
16409: IN
16410: NOT
16411: IFFALSE 16437
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16413: LD_ADDR_VAR 0 2
16417: PUSH
16418: LD_VAR 0 9
16422: PUSH
16423: LD_INT 1
16425: PPUSH
16426: LD_VAR 0 9
16430: PPUSH
16431: CALL_OW 12
16435: ARRAY
16436: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16437: LD_VAR 0 2
16441: PPUSH
16442: LD_VAR 0 3
16446: PPUSH
16447: CALL 16696 0 2
16451: NOT
16452: IFFALSE 16511
// repeat engine := _engine [ 1 ] ;
16454: LD_ADDR_VAR 0 3
16458: PUSH
16459: LD_VAR 0 11
16463: PUSH
16464: LD_INT 1
16466: ARRAY
16467: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16468: LD_ADDR_VAR 0 11
16472: PUSH
16473: LD_VAR 0 11
16477: PPUSH
16478: LD_INT 1
16480: PPUSH
16481: CALL_OW 3
16485: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16486: LD_VAR 0 2
16490: PPUSH
16491: LD_VAR 0 3
16495: PPUSH
16496: CALL 16696 0 2
16500: PUSH
16501: LD_VAR 0 11
16505: PUSH
16506: EMPTY
16507: EQUAL
16508: OR
16509: IFFALSE 16454
// if not control in _control then
16511: LD_VAR 0 4
16515: PUSH
16516: LD_VAR 0 12
16520: IN
16521: NOT
16522: IFFALSE 16548
// control := _control [ rand ( 1 , _control ) ] ;
16524: LD_ADDR_VAR 0 4
16528: PUSH
16529: LD_VAR 0 12
16533: PUSH
16534: LD_INT 1
16536: PPUSH
16537: LD_VAR 0 12
16541: PPUSH
16542: CALL_OW 12
16546: ARRAY
16547: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16548: LD_VAR 0 2
16552: PPUSH
16553: LD_VAR 0 5
16557: PPUSH
16558: CALL 16916 0 2
16562: NOT
16563: IFFALSE 16622
// repeat weapon := _weapon [ 1 ] ;
16565: LD_ADDR_VAR 0 5
16569: PUSH
16570: LD_VAR 0 10
16574: PUSH
16575: LD_INT 1
16577: ARRAY
16578: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16579: LD_ADDR_VAR 0 10
16583: PUSH
16584: LD_VAR 0 10
16588: PPUSH
16589: LD_INT 1
16591: PPUSH
16592: CALL_OW 3
16596: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16597: LD_VAR 0 2
16601: PPUSH
16602: LD_VAR 0 5
16606: PPUSH
16607: CALL 16916 0 2
16611: PUSH
16612: LD_VAR 0 10
16616: PUSH
16617: EMPTY
16618: EQUAL
16619: OR
16620: IFFALSE 16565
// result := [ ] ;
16622: LD_ADDR_VAR 0 6
16626: PUSH
16627: EMPTY
16628: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16629: LD_VAR 0 1
16633: PPUSH
16634: LD_VAR 0 2
16638: PPUSH
16639: LD_VAR 0 3
16643: PPUSH
16644: LD_VAR 0 4
16648: PPUSH
16649: LD_VAR 0 5
16653: PPUSH
16654: CALL_OW 448
16658: IFFALSE 16691
// result := [ chassis , engine , control , weapon ] ;
16660: LD_ADDR_VAR 0 6
16664: PUSH
16665: LD_VAR 0 2
16669: PUSH
16670: LD_VAR 0 3
16674: PUSH
16675: LD_VAR 0 4
16679: PUSH
16680: LD_VAR 0 5
16684: PUSH
16685: EMPTY
16686: LIST
16687: LIST
16688: LIST
16689: LIST
16690: ST_TO_ADDR
// end ;
16691: LD_VAR 0 6
16695: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16696: LD_INT 0
16698: PPUSH
// if not chassis or not engine then
16699: LD_VAR 0 1
16703: NOT
16704: PUSH
16705: LD_VAR 0 2
16709: NOT
16710: OR
16711: IFFALSE 16715
// exit ;
16713: GO 16911
// case engine of engine_solar :
16715: LD_VAR 0 2
16719: PUSH
16720: LD_INT 2
16722: DOUBLE
16723: EQUAL
16724: IFTRUE 16728
16726: GO 16766
16728: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16729: LD_ADDR_VAR 0 3
16733: PUSH
16734: LD_INT 11
16736: PUSH
16737: LD_INT 12
16739: PUSH
16740: LD_INT 13
16742: PUSH
16743: LD_INT 14
16745: PUSH
16746: LD_INT 1
16748: PUSH
16749: LD_INT 2
16751: PUSH
16752: LD_INT 3
16754: PUSH
16755: EMPTY
16756: LIST
16757: LIST
16758: LIST
16759: LIST
16760: LIST
16761: LIST
16762: LIST
16763: ST_TO_ADDR
16764: GO 16895
16766: LD_INT 1
16768: DOUBLE
16769: EQUAL
16770: IFTRUE 16774
16772: GO 16836
16774: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16775: LD_ADDR_VAR 0 3
16779: PUSH
16780: LD_INT 11
16782: PUSH
16783: LD_INT 12
16785: PUSH
16786: LD_INT 13
16788: PUSH
16789: LD_INT 14
16791: PUSH
16792: LD_INT 1
16794: PUSH
16795: LD_INT 2
16797: PUSH
16798: LD_INT 3
16800: PUSH
16801: LD_INT 4
16803: PUSH
16804: LD_INT 5
16806: PUSH
16807: LD_INT 21
16809: PUSH
16810: LD_INT 23
16812: PUSH
16813: LD_INT 22
16815: PUSH
16816: LD_INT 24
16818: PUSH
16819: EMPTY
16820: LIST
16821: LIST
16822: LIST
16823: LIST
16824: LIST
16825: LIST
16826: LIST
16827: LIST
16828: LIST
16829: LIST
16830: LIST
16831: LIST
16832: LIST
16833: ST_TO_ADDR
16834: GO 16895
16836: LD_INT 3
16838: DOUBLE
16839: EQUAL
16840: IFTRUE 16844
16842: GO 16894
16844: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
16845: LD_ADDR_VAR 0 3
16849: PUSH
16850: LD_INT 13
16852: PUSH
16853: LD_INT 14
16855: PUSH
16856: LD_INT 2
16858: PUSH
16859: LD_INT 3
16861: PUSH
16862: LD_INT 4
16864: PUSH
16865: LD_INT 5
16867: PUSH
16868: LD_INT 21
16870: PUSH
16871: LD_INT 22
16873: PUSH
16874: LD_INT 23
16876: PUSH
16877: LD_INT 24
16879: PUSH
16880: EMPTY
16881: LIST
16882: LIST
16883: LIST
16884: LIST
16885: LIST
16886: LIST
16887: LIST
16888: LIST
16889: LIST
16890: LIST
16891: ST_TO_ADDR
16892: GO 16895
16894: POP
// result := ( chassis in result ) ;
16895: LD_ADDR_VAR 0 3
16899: PUSH
16900: LD_VAR 0 1
16904: PUSH
16905: LD_VAR 0 3
16909: IN
16910: ST_TO_ADDR
// end ;
16911: LD_VAR 0 3
16915: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
16916: LD_INT 0
16918: PPUSH
// if not chassis or not weapon then
16919: LD_VAR 0 1
16923: NOT
16924: PUSH
16925: LD_VAR 0 2
16929: NOT
16930: OR
16931: IFFALSE 16935
// exit ;
16933: GO 17961
// case weapon of us_machine_gun :
16935: LD_VAR 0 2
16939: PUSH
16940: LD_INT 2
16942: DOUBLE
16943: EQUAL
16944: IFTRUE 16948
16946: GO 16978
16948: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
16949: LD_ADDR_VAR 0 3
16953: PUSH
16954: LD_INT 1
16956: PUSH
16957: LD_INT 2
16959: PUSH
16960: LD_INT 3
16962: PUSH
16963: LD_INT 4
16965: PUSH
16966: LD_INT 5
16968: PUSH
16969: EMPTY
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: LIST
16975: ST_TO_ADDR
16976: GO 17945
16978: LD_INT 3
16980: DOUBLE
16981: EQUAL
16982: IFTRUE 16986
16984: GO 17016
16986: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
16987: LD_ADDR_VAR 0 3
16991: PUSH
16992: LD_INT 1
16994: PUSH
16995: LD_INT 2
16997: PUSH
16998: LD_INT 3
17000: PUSH
17001: LD_INT 4
17003: PUSH
17004: LD_INT 5
17006: PUSH
17007: EMPTY
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: LIST
17013: ST_TO_ADDR
17014: GO 17945
17016: LD_INT 11
17018: DOUBLE
17019: EQUAL
17020: IFTRUE 17024
17022: GO 17054
17024: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17025: LD_ADDR_VAR 0 3
17029: PUSH
17030: LD_INT 1
17032: PUSH
17033: LD_INT 2
17035: PUSH
17036: LD_INT 3
17038: PUSH
17039: LD_INT 4
17041: PUSH
17042: LD_INT 5
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: LIST
17049: LIST
17050: LIST
17051: ST_TO_ADDR
17052: GO 17945
17054: LD_INT 4
17056: DOUBLE
17057: EQUAL
17058: IFTRUE 17062
17060: GO 17088
17062: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17063: LD_ADDR_VAR 0 3
17067: PUSH
17068: LD_INT 2
17070: PUSH
17071: LD_INT 3
17073: PUSH
17074: LD_INT 4
17076: PUSH
17077: LD_INT 5
17079: PUSH
17080: EMPTY
17081: LIST
17082: LIST
17083: LIST
17084: LIST
17085: ST_TO_ADDR
17086: GO 17945
17088: LD_INT 5
17090: DOUBLE
17091: EQUAL
17092: IFTRUE 17096
17094: GO 17122
17096: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17097: LD_ADDR_VAR 0 3
17101: PUSH
17102: LD_INT 2
17104: PUSH
17105: LD_INT 3
17107: PUSH
17108: LD_INT 4
17110: PUSH
17111: LD_INT 5
17113: PUSH
17114: EMPTY
17115: LIST
17116: LIST
17117: LIST
17118: LIST
17119: ST_TO_ADDR
17120: GO 17945
17122: LD_INT 9
17124: DOUBLE
17125: EQUAL
17126: IFTRUE 17130
17128: GO 17156
17130: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17131: LD_ADDR_VAR 0 3
17135: PUSH
17136: LD_INT 2
17138: PUSH
17139: LD_INT 3
17141: PUSH
17142: LD_INT 4
17144: PUSH
17145: LD_INT 5
17147: PUSH
17148: EMPTY
17149: LIST
17150: LIST
17151: LIST
17152: LIST
17153: ST_TO_ADDR
17154: GO 17945
17156: LD_INT 7
17158: DOUBLE
17159: EQUAL
17160: IFTRUE 17164
17162: GO 17190
17164: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17165: LD_ADDR_VAR 0 3
17169: PUSH
17170: LD_INT 2
17172: PUSH
17173: LD_INT 3
17175: PUSH
17176: LD_INT 4
17178: PUSH
17179: LD_INT 5
17181: PUSH
17182: EMPTY
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: ST_TO_ADDR
17188: GO 17945
17190: LD_INT 12
17192: DOUBLE
17193: EQUAL
17194: IFTRUE 17198
17196: GO 17224
17198: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17199: LD_ADDR_VAR 0 3
17203: PUSH
17204: LD_INT 2
17206: PUSH
17207: LD_INT 3
17209: PUSH
17210: LD_INT 4
17212: PUSH
17213: LD_INT 5
17215: PUSH
17216: EMPTY
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: ST_TO_ADDR
17222: GO 17945
17224: LD_INT 13
17226: DOUBLE
17227: EQUAL
17228: IFTRUE 17232
17230: GO 17258
17232: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17233: LD_ADDR_VAR 0 3
17237: PUSH
17238: LD_INT 2
17240: PUSH
17241: LD_INT 3
17243: PUSH
17244: LD_INT 4
17246: PUSH
17247: LD_INT 5
17249: PUSH
17250: EMPTY
17251: LIST
17252: LIST
17253: LIST
17254: LIST
17255: ST_TO_ADDR
17256: GO 17945
17258: LD_INT 14
17260: DOUBLE
17261: EQUAL
17262: IFTRUE 17266
17264: GO 17284
17266: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17267: LD_ADDR_VAR 0 3
17271: PUSH
17272: LD_INT 4
17274: PUSH
17275: LD_INT 5
17277: PUSH
17278: EMPTY
17279: LIST
17280: LIST
17281: ST_TO_ADDR
17282: GO 17945
17284: LD_INT 6
17286: DOUBLE
17287: EQUAL
17288: IFTRUE 17292
17290: GO 17310
17292: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17293: LD_ADDR_VAR 0 3
17297: PUSH
17298: LD_INT 4
17300: PUSH
17301: LD_INT 5
17303: PUSH
17304: EMPTY
17305: LIST
17306: LIST
17307: ST_TO_ADDR
17308: GO 17945
17310: LD_INT 10
17312: DOUBLE
17313: EQUAL
17314: IFTRUE 17318
17316: GO 17336
17318: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
17319: LD_ADDR_VAR 0 3
17323: PUSH
17324: LD_INT 4
17326: PUSH
17327: LD_INT 5
17329: PUSH
17330: EMPTY
17331: LIST
17332: LIST
17333: ST_TO_ADDR
17334: GO 17945
17336: LD_INT 22
17338: DOUBLE
17339: EQUAL
17340: IFTRUE 17344
17342: GO 17370
17344: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
17345: LD_ADDR_VAR 0 3
17349: PUSH
17350: LD_INT 11
17352: PUSH
17353: LD_INT 12
17355: PUSH
17356: LD_INT 13
17358: PUSH
17359: LD_INT 14
17361: PUSH
17362: EMPTY
17363: LIST
17364: LIST
17365: LIST
17366: LIST
17367: ST_TO_ADDR
17368: GO 17945
17370: LD_INT 23
17372: DOUBLE
17373: EQUAL
17374: IFTRUE 17378
17376: GO 17404
17378: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
17379: LD_ADDR_VAR 0 3
17383: PUSH
17384: LD_INT 11
17386: PUSH
17387: LD_INT 12
17389: PUSH
17390: LD_INT 13
17392: PUSH
17393: LD_INT 14
17395: PUSH
17396: EMPTY
17397: LIST
17398: LIST
17399: LIST
17400: LIST
17401: ST_TO_ADDR
17402: GO 17945
17404: LD_INT 24
17406: DOUBLE
17407: EQUAL
17408: IFTRUE 17412
17410: GO 17438
17412: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17413: LD_ADDR_VAR 0 3
17417: PUSH
17418: LD_INT 11
17420: PUSH
17421: LD_INT 12
17423: PUSH
17424: LD_INT 13
17426: PUSH
17427: LD_INT 14
17429: PUSH
17430: EMPTY
17431: LIST
17432: LIST
17433: LIST
17434: LIST
17435: ST_TO_ADDR
17436: GO 17945
17438: LD_INT 30
17440: DOUBLE
17441: EQUAL
17442: IFTRUE 17446
17444: GO 17472
17446: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17447: LD_ADDR_VAR 0 3
17451: PUSH
17452: LD_INT 11
17454: PUSH
17455: LD_INT 12
17457: PUSH
17458: LD_INT 13
17460: PUSH
17461: LD_INT 14
17463: PUSH
17464: EMPTY
17465: LIST
17466: LIST
17467: LIST
17468: LIST
17469: ST_TO_ADDR
17470: GO 17945
17472: LD_INT 25
17474: DOUBLE
17475: EQUAL
17476: IFTRUE 17480
17478: GO 17498
17480: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17481: LD_ADDR_VAR 0 3
17485: PUSH
17486: LD_INT 13
17488: PUSH
17489: LD_INT 14
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: ST_TO_ADDR
17496: GO 17945
17498: LD_INT 27
17500: DOUBLE
17501: EQUAL
17502: IFTRUE 17506
17504: GO 17524
17506: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17507: LD_ADDR_VAR 0 3
17511: PUSH
17512: LD_INT 13
17514: PUSH
17515: LD_INT 14
17517: PUSH
17518: EMPTY
17519: LIST
17520: LIST
17521: ST_TO_ADDR
17522: GO 17945
17524: LD_INT 28
17526: DOUBLE
17527: EQUAL
17528: IFTRUE 17532
17530: GO 17550
17532: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17533: LD_ADDR_VAR 0 3
17537: PUSH
17538: LD_INT 13
17540: PUSH
17541: LD_INT 14
17543: PUSH
17544: EMPTY
17545: LIST
17546: LIST
17547: ST_TO_ADDR
17548: GO 17945
17550: LD_INT 29
17552: DOUBLE
17553: EQUAL
17554: IFTRUE 17558
17556: GO 17576
17558: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17559: LD_ADDR_VAR 0 3
17563: PUSH
17564: LD_INT 13
17566: PUSH
17567: LD_INT 14
17569: PUSH
17570: EMPTY
17571: LIST
17572: LIST
17573: ST_TO_ADDR
17574: GO 17945
17576: LD_INT 31
17578: DOUBLE
17579: EQUAL
17580: IFTRUE 17584
17582: GO 17602
17584: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17585: LD_ADDR_VAR 0 3
17589: PUSH
17590: LD_INT 13
17592: PUSH
17593: LD_INT 14
17595: PUSH
17596: EMPTY
17597: LIST
17598: LIST
17599: ST_TO_ADDR
17600: GO 17945
17602: LD_INT 26
17604: DOUBLE
17605: EQUAL
17606: IFTRUE 17610
17608: GO 17628
17610: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17611: LD_ADDR_VAR 0 3
17615: PUSH
17616: LD_INT 13
17618: PUSH
17619: LD_INT 14
17621: PUSH
17622: EMPTY
17623: LIST
17624: LIST
17625: ST_TO_ADDR
17626: GO 17945
17628: LD_INT 42
17630: DOUBLE
17631: EQUAL
17632: IFTRUE 17636
17634: GO 17662
17636: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17637: LD_ADDR_VAR 0 3
17641: PUSH
17642: LD_INT 21
17644: PUSH
17645: LD_INT 22
17647: PUSH
17648: LD_INT 23
17650: PUSH
17651: LD_INT 24
17653: PUSH
17654: EMPTY
17655: LIST
17656: LIST
17657: LIST
17658: LIST
17659: ST_TO_ADDR
17660: GO 17945
17662: LD_INT 43
17664: DOUBLE
17665: EQUAL
17666: IFTRUE 17670
17668: GO 17696
17670: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17671: LD_ADDR_VAR 0 3
17675: PUSH
17676: LD_INT 21
17678: PUSH
17679: LD_INT 22
17681: PUSH
17682: LD_INT 23
17684: PUSH
17685: LD_INT 24
17687: PUSH
17688: EMPTY
17689: LIST
17690: LIST
17691: LIST
17692: LIST
17693: ST_TO_ADDR
17694: GO 17945
17696: LD_INT 44
17698: DOUBLE
17699: EQUAL
17700: IFTRUE 17704
17702: GO 17730
17704: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17705: LD_ADDR_VAR 0 3
17709: PUSH
17710: LD_INT 21
17712: PUSH
17713: LD_INT 22
17715: PUSH
17716: LD_INT 23
17718: PUSH
17719: LD_INT 24
17721: PUSH
17722: EMPTY
17723: LIST
17724: LIST
17725: LIST
17726: LIST
17727: ST_TO_ADDR
17728: GO 17945
17730: LD_INT 45
17732: DOUBLE
17733: EQUAL
17734: IFTRUE 17738
17736: GO 17764
17738: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17739: LD_ADDR_VAR 0 3
17743: PUSH
17744: LD_INT 21
17746: PUSH
17747: LD_INT 22
17749: PUSH
17750: LD_INT 23
17752: PUSH
17753: LD_INT 24
17755: PUSH
17756: EMPTY
17757: LIST
17758: LIST
17759: LIST
17760: LIST
17761: ST_TO_ADDR
17762: GO 17945
17764: LD_INT 49
17766: DOUBLE
17767: EQUAL
17768: IFTRUE 17772
17770: GO 17798
17772: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17773: LD_ADDR_VAR 0 3
17777: PUSH
17778: LD_INT 21
17780: PUSH
17781: LD_INT 22
17783: PUSH
17784: LD_INT 23
17786: PUSH
17787: LD_INT 24
17789: PUSH
17790: EMPTY
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: ST_TO_ADDR
17796: GO 17945
17798: LD_INT 51
17800: DOUBLE
17801: EQUAL
17802: IFTRUE 17806
17804: GO 17832
17806: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
17807: LD_ADDR_VAR 0 3
17811: PUSH
17812: LD_INT 21
17814: PUSH
17815: LD_INT 22
17817: PUSH
17818: LD_INT 23
17820: PUSH
17821: LD_INT 24
17823: PUSH
17824: EMPTY
17825: LIST
17826: LIST
17827: LIST
17828: LIST
17829: ST_TO_ADDR
17830: GO 17945
17832: LD_INT 52
17834: DOUBLE
17835: EQUAL
17836: IFTRUE 17840
17838: GO 17866
17840: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
17841: LD_ADDR_VAR 0 3
17845: PUSH
17846: LD_INT 21
17848: PUSH
17849: LD_INT 22
17851: PUSH
17852: LD_INT 23
17854: PUSH
17855: LD_INT 24
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: LIST
17862: LIST
17863: ST_TO_ADDR
17864: GO 17945
17866: LD_INT 53
17868: DOUBLE
17869: EQUAL
17870: IFTRUE 17874
17872: GO 17892
17874: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
17875: LD_ADDR_VAR 0 3
17879: PUSH
17880: LD_INT 23
17882: PUSH
17883: LD_INT 24
17885: PUSH
17886: EMPTY
17887: LIST
17888: LIST
17889: ST_TO_ADDR
17890: GO 17945
17892: LD_INT 46
17894: DOUBLE
17895: EQUAL
17896: IFTRUE 17900
17898: GO 17918
17900: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
17901: LD_ADDR_VAR 0 3
17905: PUSH
17906: LD_INT 23
17908: PUSH
17909: LD_INT 24
17911: PUSH
17912: EMPTY
17913: LIST
17914: LIST
17915: ST_TO_ADDR
17916: GO 17945
17918: LD_INT 47
17920: DOUBLE
17921: EQUAL
17922: IFTRUE 17926
17924: GO 17944
17926: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17927: LD_ADDR_VAR 0 3
17931: PUSH
17932: LD_INT 23
17934: PUSH
17935: LD_INT 24
17937: PUSH
17938: EMPTY
17939: LIST
17940: LIST
17941: ST_TO_ADDR
17942: GO 17945
17944: POP
// result := ( chassis in result ) ;
17945: LD_ADDR_VAR 0 3
17949: PUSH
17950: LD_VAR 0 1
17954: PUSH
17955: LD_VAR 0 3
17959: IN
17960: ST_TO_ADDR
// end ;
17961: LD_VAR 0 3
17965: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
17966: LD_INT 0
17968: PPUSH
17969: PPUSH
17970: PPUSH
17971: PPUSH
17972: PPUSH
17973: PPUSH
17974: PPUSH
// result := array ;
17975: LD_ADDR_VAR 0 5
17979: PUSH
17980: LD_VAR 0 1
17984: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
17985: LD_VAR 0 1
17989: NOT
17990: PUSH
17991: LD_VAR 0 2
17995: NOT
17996: OR
17997: PUSH
17998: LD_VAR 0 3
18002: NOT
18003: OR
18004: PUSH
18005: LD_VAR 0 2
18009: PUSH
18010: LD_VAR 0 1
18014: GREATER
18015: OR
18016: PUSH
18017: LD_VAR 0 3
18021: PUSH
18022: LD_VAR 0 1
18026: GREATER
18027: OR
18028: IFFALSE 18032
// exit ;
18030: GO 18328
// if direction then
18032: LD_VAR 0 4
18036: IFFALSE 18100
// begin d := 1 ;
18038: LD_ADDR_VAR 0 9
18042: PUSH
18043: LD_INT 1
18045: ST_TO_ADDR
// if i_from > i_to then
18046: LD_VAR 0 2
18050: PUSH
18051: LD_VAR 0 3
18055: GREATER
18056: IFFALSE 18082
// length := ( array - i_from ) + i_to else
18058: LD_ADDR_VAR 0 11
18062: PUSH
18063: LD_VAR 0 1
18067: PUSH
18068: LD_VAR 0 2
18072: MINUS
18073: PUSH
18074: LD_VAR 0 3
18078: PLUS
18079: ST_TO_ADDR
18080: GO 18098
// length := i_to - i_from ;
18082: LD_ADDR_VAR 0 11
18086: PUSH
18087: LD_VAR 0 3
18091: PUSH
18092: LD_VAR 0 2
18096: MINUS
18097: ST_TO_ADDR
// end else
18098: GO 18161
// begin d := - 1 ;
18100: LD_ADDR_VAR 0 9
18104: PUSH
18105: LD_INT 1
18107: NEG
18108: ST_TO_ADDR
// if i_from > i_to then
18109: LD_VAR 0 2
18113: PUSH
18114: LD_VAR 0 3
18118: GREATER
18119: IFFALSE 18139
// length := i_from - i_to else
18121: LD_ADDR_VAR 0 11
18125: PUSH
18126: LD_VAR 0 2
18130: PUSH
18131: LD_VAR 0 3
18135: MINUS
18136: ST_TO_ADDR
18137: GO 18161
// length := ( array - i_to ) + i_from ;
18139: LD_ADDR_VAR 0 11
18143: PUSH
18144: LD_VAR 0 1
18148: PUSH
18149: LD_VAR 0 3
18153: MINUS
18154: PUSH
18155: LD_VAR 0 2
18159: PLUS
18160: ST_TO_ADDR
// end ; if not length then
18161: LD_VAR 0 11
18165: NOT
18166: IFFALSE 18170
// exit ;
18168: GO 18328
// tmp := array ;
18170: LD_ADDR_VAR 0 10
18174: PUSH
18175: LD_VAR 0 1
18179: ST_TO_ADDR
// for i = 1 to length do
18180: LD_ADDR_VAR 0 6
18184: PUSH
18185: DOUBLE
18186: LD_INT 1
18188: DEC
18189: ST_TO_ADDR
18190: LD_VAR 0 11
18194: PUSH
18195: FOR_TO
18196: IFFALSE 18316
// begin for j = 1 to array do
18198: LD_ADDR_VAR 0 7
18202: PUSH
18203: DOUBLE
18204: LD_INT 1
18206: DEC
18207: ST_TO_ADDR
18208: LD_VAR 0 1
18212: PUSH
18213: FOR_TO
18214: IFFALSE 18302
// begin k := j + d ;
18216: LD_ADDR_VAR 0 8
18220: PUSH
18221: LD_VAR 0 7
18225: PUSH
18226: LD_VAR 0 9
18230: PLUS
18231: ST_TO_ADDR
// if k > array then
18232: LD_VAR 0 8
18236: PUSH
18237: LD_VAR 0 1
18241: GREATER
18242: IFFALSE 18252
// k := 1 ;
18244: LD_ADDR_VAR 0 8
18248: PUSH
18249: LD_INT 1
18251: ST_TO_ADDR
// if not k then
18252: LD_VAR 0 8
18256: NOT
18257: IFFALSE 18269
// k := array ;
18259: LD_ADDR_VAR 0 8
18263: PUSH
18264: LD_VAR 0 1
18268: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18269: LD_ADDR_VAR 0 10
18273: PUSH
18274: LD_VAR 0 10
18278: PPUSH
18279: LD_VAR 0 8
18283: PPUSH
18284: LD_VAR 0 1
18288: PUSH
18289: LD_VAR 0 7
18293: ARRAY
18294: PPUSH
18295: CALL_OW 1
18299: ST_TO_ADDR
// end ;
18300: GO 18213
18302: POP
18303: POP
// array := tmp ;
18304: LD_ADDR_VAR 0 1
18308: PUSH
18309: LD_VAR 0 10
18313: ST_TO_ADDR
// end ;
18314: GO 18195
18316: POP
18317: POP
// result := array ;
18318: LD_ADDR_VAR 0 5
18322: PUSH
18323: LD_VAR 0 1
18327: ST_TO_ADDR
// end ;
18328: LD_VAR 0 5
18332: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
18333: LD_INT 0
18335: PPUSH
18336: PPUSH
// result := 0 ;
18337: LD_ADDR_VAR 0 3
18341: PUSH
18342: LD_INT 0
18344: ST_TO_ADDR
// if not array or not value in array then
18345: LD_VAR 0 1
18349: NOT
18350: PUSH
18351: LD_VAR 0 2
18355: PUSH
18356: LD_VAR 0 1
18360: IN
18361: NOT
18362: OR
18363: IFFALSE 18367
// exit ;
18365: GO 18421
// for i = 1 to array do
18367: LD_ADDR_VAR 0 4
18371: PUSH
18372: DOUBLE
18373: LD_INT 1
18375: DEC
18376: ST_TO_ADDR
18377: LD_VAR 0 1
18381: PUSH
18382: FOR_TO
18383: IFFALSE 18419
// if value = array [ i ] then
18385: LD_VAR 0 2
18389: PUSH
18390: LD_VAR 0 1
18394: PUSH
18395: LD_VAR 0 4
18399: ARRAY
18400: EQUAL
18401: IFFALSE 18417
// begin result := i ;
18403: LD_ADDR_VAR 0 3
18407: PUSH
18408: LD_VAR 0 4
18412: ST_TO_ADDR
// exit ;
18413: POP
18414: POP
18415: GO 18421
// end ;
18417: GO 18382
18419: POP
18420: POP
// end ;
18421: LD_VAR 0 3
18425: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18426: LD_INT 0
18428: PPUSH
// vc_chassis := chassis ;
18429: LD_ADDR_OWVAR 37
18433: PUSH
18434: LD_VAR 0 1
18438: ST_TO_ADDR
// vc_engine := engine ;
18439: LD_ADDR_OWVAR 39
18443: PUSH
18444: LD_VAR 0 2
18448: ST_TO_ADDR
// vc_control := control ;
18449: LD_ADDR_OWVAR 38
18453: PUSH
18454: LD_VAR 0 3
18458: ST_TO_ADDR
// vc_weapon := weapon ;
18459: LD_ADDR_OWVAR 40
18463: PUSH
18464: LD_VAR 0 4
18468: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18469: LD_ADDR_OWVAR 41
18473: PUSH
18474: LD_VAR 0 5
18478: ST_TO_ADDR
// end ;
18479: LD_VAR 0 6
18483: RET
// export function WantPlant ( unit ) ; var task ; begin
18484: LD_INT 0
18486: PPUSH
18487: PPUSH
// result := false ;
18488: LD_ADDR_VAR 0 2
18492: PUSH
18493: LD_INT 0
18495: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18496: LD_ADDR_VAR 0 3
18500: PUSH
18501: LD_VAR 0 1
18505: PPUSH
18506: CALL_OW 437
18510: ST_TO_ADDR
// if task then
18511: LD_VAR 0 3
18515: IFFALSE 18543
// if task [ 1 ] [ 1 ] = p then
18517: LD_VAR 0 3
18521: PUSH
18522: LD_INT 1
18524: ARRAY
18525: PUSH
18526: LD_INT 1
18528: ARRAY
18529: PUSH
18530: LD_STRING p
18532: EQUAL
18533: IFFALSE 18543
// result := true ;
18535: LD_ADDR_VAR 0 2
18539: PUSH
18540: LD_INT 1
18542: ST_TO_ADDR
// end ;
18543: LD_VAR 0 2
18547: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18548: LD_INT 0
18550: PPUSH
18551: PPUSH
18552: PPUSH
18553: PPUSH
// if pos < 1 then
18554: LD_VAR 0 2
18558: PUSH
18559: LD_INT 1
18561: LESS
18562: IFFALSE 18566
// exit ;
18564: GO 18869
// if pos = 1 then
18566: LD_VAR 0 2
18570: PUSH
18571: LD_INT 1
18573: EQUAL
18574: IFFALSE 18607
// result := Replace ( arr , pos [ 1 ] , value ) else
18576: LD_ADDR_VAR 0 4
18580: PUSH
18581: LD_VAR 0 1
18585: PPUSH
18586: LD_VAR 0 2
18590: PUSH
18591: LD_INT 1
18593: ARRAY
18594: PPUSH
18595: LD_VAR 0 3
18599: PPUSH
18600: CALL_OW 1
18604: ST_TO_ADDR
18605: GO 18869
// begin tmp := arr ;
18607: LD_ADDR_VAR 0 6
18611: PUSH
18612: LD_VAR 0 1
18616: ST_TO_ADDR
// s_arr := [ tmp ] ;
18617: LD_ADDR_VAR 0 7
18621: PUSH
18622: LD_VAR 0 6
18626: PUSH
18627: EMPTY
18628: LIST
18629: ST_TO_ADDR
// for i = 1 to pos - 1 do
18630: LD_ADDR_VAR 0 5
18634: PUSH
18635: DOUBLE
18636: LD_INT 1
18638: DEC
18639: ST_TO_ADDR
18640: LD_VAR 0 2
18644: PUSH
18645: LD_INT 1
18647: MINUS
18648: PUSH
18649: FOR_TO
18650: IFFALSE 18695
// begin tmp := tmp [ pos [ i ] ] ;
18652: LD_ADDR_VAR 0 6
18656: PUSH
18657: LD_VAR 0 6
18661: PUSH
18662: LD_VAR 0 2
18666: PUSH
18667: LD_VAR 0 5
18671: ARRAY
18672: ARRAY
18673: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18674: LD_ADDR_VAR 0 7
18678: PUSH
18679: LD_VAR 0 7
18683: PUSH
18684: LD_VAR 0 6
18688: PUSH
18689: EMPTY
18690: LIST
18691: ADD
18692: ST_TO_ADDR
// end ;
18693: GO 18649
18695: POP
18696: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18697: LD_ADDR_VAR 0 6
18701: PUSH
18702: LD_VAR 0 6
18706: PPUSH
18707: LD_VAR 0 2
18711: PUSH
18712: LD_VAR 0 2
18716: ARRAY
18717: PPUSH
18718: LD_VAR 0 3
18722: PPUSH
18723: CALL_OW 1
18727: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18728: LD_ADDR_VAR 0 7
18732: PUSH
18733: LD_VAR 0 7
18737: PPUSH
18738: LD_VAR 0 7
18742: PPUSH
18743: LD_VAR 0 6
18747: PPUSH
18748: CALL_OW 1
18752: ST_TO_ADDR
// for i = s_arr downto 2 do
18753: LD_ADDR_VAR 0 5
18757: PUSH
18758: DOUBLE
18759: LD_VAR 0 7
18763: INC
18764: ST_TO_ADDR
18765: LD_INT 2
18767: PUSH
18768: FOR_DOWNTO
18769: IFFALSE 18853
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18771: LD_ADDR_VAR 0 6
18775: PUSH
18776: LD_VAR 0 7
18780: PUSH
18781: LD_VAR 0 5
18785: PUSH
18786: LD_INT 1
18788: MINUS
18789: ARRAY
18790: PPUSH
18791: LD_VAR 0 2
18795: PUSH
18796: LD_VAR 0 5
18800: PUSH
18801: LD_INT 1
18803: MINUS
18804: ARRAY
18805: PPUSH
18806: LD_VAR 0 7
18810: PUSH
18811: LD_VAR 0 5
18815: ARRAY
18816: PPUSH
18817: CALL_OW 1
18821: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
18822: LD_ADDR_VAR 0 7
18826: PUSH
18827: LD_VAR 0 7
18831: PPUSH
18832: LD_VAR 0 5
18836: PUSH
18837: LD_INT 1
18839: MINUS
18840: PPUSH
18841: LD_VAR 0 6
18845: PPUSH
18846: CALL_OW 1
18850: ST_TO_ADDR
// end ;
18851: GO 18768
18853: POP
18854: POP
// result := s_arr [ 1 ] ;
18855: LD_ADDR_VAR 0 4
18859: PUSH
18860: LD_VAR 0 7
18864: PUSH
18865: LD_INT 1
18867: ARRAY
18868: ST_TO_ADDR
// end ; end ;
18869: LD_VAR 0 4
18873: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
18874: LD_INT 0
18876: PPUSH
18877: PPUSH
// if not list then
18878: LD_VAR 0 1
18882: NOT
18883: IFFALSE 18887
// exit ;
18885: GO 18978
// i := list [ pos1 ] ;
18887: LD_ADDR_VAR 0 5
18891: PUSH
18892: LD_VAR 0 1
18896: PUSH
18897: LD_VAR 0 2
18901: ARRAY
18902: ST_TO_ADDR
// if not i then
18903: LD_VAR 0 5
18907: NOT
18908: IFFALSE 18912
// exit ;
18910: GO 18978
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
18912: LD_ADDR_VAR 0 1
18916: PUSH
18917: LD_VAR 0 1
18921: PPUSH
18922: LD_VAR 0 2
18926: PPUSH
18927: LD_VAR 0 1
18931: PUSH
18932: LD_VAR 0 3
18936: ARRAY
18937: PPUSH
18938: CALL_OW 1
18942: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
18943: LD_ADDR_VAR 0 1
18947: PUSH
18948: LD_VAR 0 1
18952: PPUSH
18953: LD_VAR 0 3
18957: PPUSH
18958: LD_VAR 0 5
18962: PPUSH
18963: CALL_OW 1
18967: ST_TO_ADDR
// result := list ;
18968: LD_ADDR_VAR 0 4
18972: PUSH
18973: LD_VAR 0 1
18977: ST_TO_ADDR
// end ;
18978: LD_VAR 0 4
18982: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
18983: LD_INT 0
18985: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
18986: LD_ADDR_VAR 0 5
18990: PUSH
18991: LD_VAR 0 1
18995: PPUSH
18996: CALL_OW 250
19000: PPUSH
19001: LD_VAR 0 1
19005: PPUSH
19006: CALL_OW 251
19010: PPUSH
19011: LD_VAR 0 2
19015: PPUSH
19016: LD_VAR 0 3
19020: PPUSH
19021: LD_VAR 0 4
19025: PPUSH
19026: CALL 19036 0 5
19030: ST_TO_ADDR
// end ;
19031: LD_VAR 0 5
19035: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19036: LD_INT 0
19038: PPUSH
19039: PPUSH
19040: PPUSH
19041: PPUSH
// if not list then
19042: LD_VAR 0 3
19046: NOT
19047: IFFALSE 19051
// exit ;
19049: GO 19439
// result := [ ] ;
19051: LD_ADDR_VAR 0 6
19055: PUSH
19056: EMPTY
19057: ST_TO_ADDR
// for i in list do
19058: LD_ADDR_VAR 0 7
19062: PUSH
19063: LD_VAR 0 3
19067: PUSH
19068: FOR_IN
19069: IFFALSE 19271
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19071: LD_ADDR_VAR 0 9
19075: PUSH
19076: LD_VAR 0 7
19080: PPUSH
19081: LD_VAR 0 1
19085: PPUSH
19086: LD_VAR 0 2
19090: PPUSH
19091: CALL_OW 297
19095: ST_TO_ADDR
// if not result then
19096: LD_VAR 0 6
19100: NOT
19101: IFFALSE 19127
// result := [ [ i , tmp ] ] else
19103: LD_ADDR_VAR 0 6
19107: PUSH
19108: LD_VAR 0 7
19112: PUSH
19113: LD_VAR 0 9
19117: PUSH
19118: EMPTY
19119: LIST
19120: LIST
19121: PUSH
19122: EMPTY
19123: LIST
19124: ST_TO_ADDR
19125: GO 19269
// begin if result [ result ] [ 2 ] < tmp then
19127: LD_VAR 0 6
19131: PUSH
19132: LD_VAR 0 6
19136: ARRAY
19137: PUSH
19138: LD_INT 2
19140: ARRAY
19141: PUSH
19142: LD_VAR 0 9
19146: LESS
19147: IFFALSE 19189
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19149: LD_ADDR_VAR 0 6
19153: PUSH
19154: LD_VAR 0 6
19158: PPUSH
19159: LD_VAR 0 6
19163: PUSH
19164: LD_INT 1
19166: PLUS
19167: PPUSH
19168: LD_VAR 0 7
19172: PUSH
19173: LD_VAR 0 9
19177: PUSH
19178: EMPTY
19179: LIST
19180: LIST
19181: PPUSH
19182: CALL_OW 2
19186: ST_TO_ADDR
19187: GO 19269
// for j = 1 to result do
19189: LD_ADDR_VAR 0 8
19193: PUSH
19194: DOUBLE
19195: LD_INT 1
19197: DEC
19198: ST_TO_ADDR
19199: LD_VAR 0 6
19203: PUSH
19204: FOR_TO
19205: IFFALSE 19267
// begin if tmp < result [ j ] [ 2 ] then
19207: LD_VAR 0 9
19211: PUSH
19212: LD_VAR 0 6
19216: PUSH
19217: LD_VAR 0 8
19221: ARRAY
19222: PUSH
19223: LD_INT 2
19225: ARRAY
19226: LESS
19227: IFFALSE 19265
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19229: LD_ADDR_VAR 0 6
19233: PUSH
19234: LD_VAR 0 6
19238: PPUSH
19239: LD_VAR 0 8
19243: PPUSH
19244: LD_VAR 0 7
19248: PUSH
19249: LD_VAR 0 9
19253: PUSH
19254: EMPTY
19255: LIST
19256: LIST
19257: PPUSH
19258: CALL_OW 2
19262: ST_TO_ADDR
// break ;
19263: GO 19267
// end ; end ;
19265: GO 19204
19267: POP
19268: POP
// end ; end ;
19269: GO 19068
19271: POP
19272: POP
// if result and not asc then
19273: LD_VAR 0 6
19277: PUSH
19278: LD_VAR 0 4
19282: NOT
19283: AND
19284: IFFALSE 19359
// begin tmp := result ;
19286: LD_ADDR_VAR 0 9
19290: PUSH
19291: LD_VAR 0 6
19295: ST_TO_ADDR
// for i = tmp downto 1 do
19296: LD_ADDR_VAR 0 7
19300: PUSH
19301: DOUBLE
19302: LD_VAR 0 9
19306: INC
19307: ST_TO_ADDR
19308: LD_INT 1
19310: PUSH
19311: FOR_DOWNTO
19312: IFFALSE 19357
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
19314: LD_ADDR_VAR 0 6
19318: PUSH
19319: LD_VAR 0 6
19323: PPUSH
19324: LD_VAR 0 9
19328: PUSH
19329: LD_VAR 0 7
19333: MINUS
19334: PUSH
19335: LD_INT 1
19337: PLUS
19338: PPUSH
19339: LD_VAR 0 9
19343: PUSH
19344: LD_VAR 0 7
19348: ARRAY
19349: PPUSH
19350: CALL_OW 1
19354: ST_TO_ADDR
19355: GO 19311
19357: POP
19358: POP
// end ; tmp := [ ] ;
19359: LD_ADDR_VAR 0 9
19363: PUSH
19364: EMPTY
19365: ST_TO_ADDR
// if mode then
19366: LD_VAR 0 5
19370: IFFALSE 19439
// begin for i = 1 to result do
19372: LD_ADDR_VAR 0 7
19376: PUSH
19377: DOUBLE
19378: LD_INT 1
19380: DEC
19381: ST_TO_ADDR
19382: LD_VAR 0 6
19386: PUSH
19387: FOR_TO
19388: IFFALSE 19427
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19390: LD_ADDR_VAR 0 9
19394: PUSH
19395: LD_VAR 0 9
19399: PPUSH
19400: LD_VAR 0 7
19404: PPUSH
19405: LD_VAR 0 6
19409: PUSH
19410: LD_VAR 0 7
19414: ARRAY
19415: PUSH
19416: LD_INT 1
19418: ARRAY
19419: PPUSH
19420: CALL_OW 1
19424: ST_TO_ADDR
19425: GO 19387
19427: POP
19428: POP
// result := tmp ;
19429: LD_ADDR_VAR 0 6
19433: PUSH
19434: LD_VAR 0 9
19438: ST_TO_ADDR
// end ; end ;
19439: LD_VAR 0 6
19443: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19444: LD_INT 0
19446: PPUSH
19447: PPUSH
19448: PPUSH
19449: PPUSH
19450: PPUSH
19451: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19452: LD_ADDR_VAR 0 5
19456: PUSH
19457: LD_INT 0
19459: PUSH
19460: LD_INT 0
19462: PUSH
19463: LD_INT 0
19465: PUSH
19466: EMPTY
19467: PUSH
19468: EMPTY
19469: LIST
19470: LIST
19471: LIST
19472: LIST
19473: ST_TO_ADDR
// if not x or not y then
19474: LD_VAR 0 2
19478: NOT
19479: PUSH
19480: LD_VAR 0 3
19484: NOT
19485: OR
19486: IFFALSE 19490
// exit ;
19488: GO 21136
// if not range then
19490: LD_VAR 0 4
19494: NOT
19495: IFFALSE 19505
// range := 10 ;
19497: LD_ADDR_VAR 0 4
19501: PUSH
19502: LD_INT 10
19504: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19505: LD_ADDR_VAR 0 8
19509: PUSH
19510: LD_INT 81
19512: PUSH
19513: LD_VAR 0 1
19517: PUSH
19518: EMPTY
19519: LIST
19520: LIST
19521: PUSH
19522: LD_INT 92
19524: PUSH
19525: LD_VAR 0 2
19529: PUSH
19530: LD_VAR 0 3
19534: PUSH
19535: LD_VAR 0 4
19539: PUSH
19540: EMPTY
19541: LIST
19542: LIST
19543: LIST
19544: LIST
19545: PUSH
19546: LD_INT 3
19548: PUSH
19549: LD_INT 21
19551: PUSH
19552: LD_INT 3
19554: PUSH
19555: EMPTY
19556: LIST
19557: LIST
19558: PUSH
19559: EMPTY
19560: LIST
19561: LIST
19562: PUSH
19563: EMPTY
19564: LIST
19565: LIST
19566: LIST
19567: PPUSH
19568: CALL_OW 69
19572: ST_TO_ADDR
// if not tmp then
19573: LD_VAR 0 8
19577: NOT
19578: IFFALSE 19582
// exit ;
19580: GO 21136
// for i in tmp do
19582: LD_ADDR_VAR 0 6
19586: PUSH
19587: LD_VAR 0 8
19591: PUSH
19592: FOR_IN
19593: IFFALSE 21111
// begin points := [ 0 , 0 , 0 ] ;
19595: LD_ADDR_VAR 0 9
19599: PUSH
19600: LD_INT 0
19602: PUSH
19603: LD_INT 0
19605: PUSH
19606: LD_INT 0
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: LIST
19613: ST_TO_ADDR
// bpoints := 1 ;
19614: LD_ADDR_VAR 0 10
19618: PUSH
19619: LD_INT 1
19621: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19622: LD_VAR 0 6
19626: PPUSH
19627: CALL_OW 247
19631: PUSH
19632: LD_INT 1
19634: DOUBLE
19635: EQUAL
19636: IFTRUE 19640
19638: GO 20218
19640: POP
// begin if GetClass ( i ) = 1 then
19641: LD_VAR 0 6
19645: PPUSH
19646: CALL_OW 257
19650: PUSH
19651: LD_INT 1
19653: EQUAL
19654: IFFALSE 19675
// points := [ 10 , 5 , 3 ] ;
19656: LD_ADDR_VAR 0 9
19660: PUSH
19661: LD_INT 10
19663: PUSH
19664: LD_INT 5
19666: PUSH
19667: LD_INT 3
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: LIST
19674: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19675: LD_VAR 0 6
19679: PPUSH
19680: CALL_OW 257
19684: PUSH
19685: LD_INT 2
19687: PUSH
19688: LD_INT 3
19690: PUSH
19691: LD_INT 4
19693: PUSH
19694: EMPTY
19695: LIST
19696: LIST
19697: LIST
19698: IN
19699: IFFALSE 19720
// points := [ 3 , 2 , 1 ] ;
19701: LD_ADDR_VAR 0 9
19705: PUSH
19706: LD_INT 3
19708: PUSH
19709: LD_INT 2
19711: PUSH
19712: LD_INT 1
19714: PUSH
19715: EMPTY
19716: LIST
19717: LIST
19718: LIST
19719: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19720: LD_VAR 0 6
19724: PPUSH
19725: CALL_OW 257
19729: PUSH
19730: LD_INT 5
19732: EQUAL
19733: IFFALSE 19754
// points := [ 130 , 5 , 2 ] ;
19735: LD_ADDR_VAR 0 9
19739: PUSH
19740: LD_INT 130
19742: PUSH
19743: LD_INT 5
19745: PUSH
19746: LD_INT 2
19748: PUSH
19749: EMPTY
19750: LIST
19751: LIST
19752: LIST
19753: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19754: LD_VAR 0 6
19758: PPUSH
19759: CALL_OW 257
19763: PUSH
19764: LD_INT 8
19766: EQUAL
19767: IFFALSE 19788
// points := [ 35 , 35 , 30 ] ;
19769: LD_ADDR_VAR 0 9
19773: PUSH
19774: LD_INT 35
19776: PUSH
19777: LD_INT 35
19779: PUSH
19780: LD_INT 30
19782: PUSH
19783: EMPTY
19784: LIST
19785: LIST
19786: LIST
19787: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19788: LD_VAR 0 6
19792: PPUSH
19793: CALL_OW 257
19797: PUSH
19798: LD_INT 9
19800: EQUAL
19801: IFFALSE 19822
// points := [ 20 , 55 , 40 ] ;
19803: LD_ADDR_VAR 0 9
19807: PUSH
19808: LD_INT 20
19810: PUSH
19811: LD_INT 55
19813: PUSH
19814: LD_INT 40
19816: PUSH
19817: EMPTY
19818: LIST
19819: LIST
19820: LIST
19821: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
19822: LD_VAR 0 6
19826: PPUSH
19827: CALL_OW 257
19831: PUSH
19832: LD_INT 12
19834: PUSH
19835: LD_INT 16
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: IN
19842: IFFALSE 19863
// points := [ 5 , 3 , 2 ] ;
19844: LD_ADDR_VAR 0 9
19848: PUSH
19849: LD_INT 5
19851: PUSH
19852: LD_INT 3
19854: PUSH
19855: LD_INT 2
19857: PUSH
19858: EMPTY
19859: LIST
19860: LIST
19861: LIST
19862: ST_TO_ADDR
// if GetClass ( i ) = 17 then
19863: LD_VAR 0 6
19867: PPUSH
19868: CALL_OW 257
19872: PUSH
19873: LD_INT 17
19875: EQUAL
19876: IFFALSE 19897
// points := [ 100 , 50 , 75 ] ;
19878: LD_ADDR_VAR 0 9
19882: PUSH
19883: LD_INT 100
19885: PUSH
19886: LD_INT 50
19888: PUSH
19889: LD_INT 75
19891: PUSH
19892: EMPTY
19893: LIST
19894: LIST
19895: LIST
19896: ST_TO_ADDR
// if GetClass ( i ) = 15 then
19897: LD_VAR 0 6
19901: PPUSH
19902: CALL_OW 257
19906: PUSH
19907: LD_INT 15
19909: EQUAL
19910: IFFALSE 19931
// points := [ 10 , 5 , 3 ] ;
19912: LD_ADDR_VAR 0 9
19916: PUSH
19917: LD_INT 10
19919: PUSH
19920: LD_INT 5
19922: PUSH
19923: LD_INT 3
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: LIST
19930: ST_TO_ADDR
// if GetClass ( i ) = 14 then
19931: LD_VAR 0 6
19935: PPUSH
19936: CALL_OW 257
19940: PUSH
19941: LD_INT 14
19943: EQUAL
19944: IFFALSE 19965
// points := [ 10 , 0 , 0 ] ;
19946: LD_ADDR_VAR 0 9
19950: PUSH
19951: LD_INT 10
19953: PUSH
19954: LD_INT 0
19956: PUSH
19957: LD_INT 0
19959: PUSH
19960: EMPTY
19961: LIST
19962: LIST
19963: LIST
19964: ST_TO_ADDR
// if GetClass ( i ) = 11 then
19965: LD_VAR 0 6
19969: PPUSH
19970: CALL_OW 257
19974: PUSH
19975: LD_INT 11
19977: EQUAL
19978: IFFALSE 19999
// points := [ 30 , 10 , 5 ] ;
19980: LD_ADDR_VAR 0 9
19984: PUSH
19985: LD_INT 30
19987: PUSH
19988: LD_INT 10
19990: PUSH
19991: LD_INT 5
19993: PUSH
19994: EMPTY
19995: LIST
19996: LIST
19997: LIST
19998: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
19999: LD_VAR 0 1
20003: PPUSH
20004: LD_INT 5
20006: PPUSH
20007: CALL_OW 321
20011: PUSH
20012: LD_INT 2
20014: EQUAL
20015: IFFALSE 20032
// bpoints := bpoints * 1.8 ;
20017: LD_ADDR_VAR 0 10
20021: PUSH
20022: LD_VAR 0 10
20026: PUSH
20027: LD_REAL  1.80000000000000E+0000
20030: MUL
20031: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20032: LD_VAR 0 6
20036: PPUSH
20037: CALL_OW 257
20041: PUSH
20042: LD_INT 1
20044: PUSH
20045: LD_INT 2
20047: PUSH
20048: LD_INT 3
20050: PUSH
20051: LD_INT 4
20053: PUSH
20054: EMPTY
20055: LIST
20056: LIST
20057: LIST
20058: LIST
20059: IN
20060: PUSH
20061: LD_VAR 0 1
20065: PPUSH
20066: LD_INT 51
20068: PPUSH
20069: CALL_OW 321
20073: PUSH
20074: LD_INT 2
20076: EQUAL
20077: AND
20078: IFFALSE 20095
// bpoints := bpoints * 1.2 ;
20080: LD_ADDR_VAR 0 10
20084: PUSH
20085: LD_VAR 0 10
20089: PUSH
20090: LD_REAL  1.20000000000000E+0000
20093: MUL
20094: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20095: LD_VAR 0 6
20099: PPUSH
20100: CALL_OW 257
20104: PUSH
20105: LD_INT 5
20107: PUSH
20108: LD_INT 7
20110: PUSH
20111: LD_INT 9
20113: PUSH
20114: EMPTY
20115: LIST
20116: LIST
20117: LIST
20118: IN
20119: PUSH
20120: LD_VAR 0 1
20124: PPUSH
20125: LD_INT 52
20127: PPUSH
20128: CALL_OW 321
20132: PUSH
20133: LD_INT 2
20135: EQUAL
20136: AND
20137: IFFALSE 20154
// bpoints := bpoints * 1.5 ;
20139: LD_ADDR_VAR 0 10
20143: PUSH
20144: LD_VAR 0 10
20148: PUSH
20149: LD_REAL  1.50000000000000E+0000
20152: MUL
20153: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20154: LD_VAR 0 1
20158: PPUSH
20159: LD_INT 66
20161: PPUSH
20162: CALL_OW 321
20166: PUSH
20167: LD_INT 2
20169: EQUAL
20170: IFFALSE 20187
// bpoints := bpoints * 1.1 ;
20172: LD_ADDR_VAR 0 10
20176: PUSH
20177: LD_VAR 0 10
20181: PUSH
20182: LD_REAL  1.10000000000000E+0000
20185: MUL
20186: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20187: LD_ADDR_VAR 0 10
20191: PUSH
20192: LD_VAR 0 10
20196: PUSH
20197: LD_VAR 0 6
20201: PPUSH
20202: LD_INT 1
20204: PPUSH
20205: CALL_OW 259
20209: PUSH
20210: LD_REAL  1.15000000000000E+0000
20213: MUL
20214: MUL
20215: ST_TO_ADDR
// end ; unit_vehicle :
20216: GO 21040
20218: LD_INT 2
20220: DOUBLE
20221: EQUAL
20222: IFTRUE 20226
20224: GO 21028
20226: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20227: LD_VAR 0 6
20231: PPUSH
20232: CALL_OW 264
20236: PUSH
20237: LD_INT 2
20239: PUSH
20240: LD_INT 42
20242: PUSH
20243: LD_INT 24
20245: PUSH
20246: EMPTY
20247: LIST
20248: LIST
20249: LIST
20250: IN
20251: IFFALSE 20272
// points := [ 25 , 5 , 3 ] ;
20253: LD_ADDR_VAR 0 9
20257: PUSH
20258: LD_INT 25
20260: PUSH
20261: LD_INT 5
20263: PUSH
20264: LD_INT 3
20266: PUSH
20267: EMPTY
20268: LIST
20269: LIST
20270: LIST
20271: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20272: LD_VAR 0 6
20276: PPUSH
20277: CALL_OW 264
20281: PUSH
20282: LD_INT 4
20284: PUSH
20285: LD_INT 43
20287: PUSH
20288: LD_INT 25
20290: PUSH
20291: EMPTY
20292: LIST
20293: LIST
20294: LIST
20295: IN
20296: IFFALSE 20317
// points := [ 40 , 15 , 5 ] ;
20298: LD_ADDR_VAR 0 9
20302: PUSH
20303: LD_INT 40
20305: PUSH
20306: LD_INT 15
20308: PUSH
20309: LD_INT 5
20311: PUSH
20312: EMPTY
20313: LIST
20314: LIST
20315: LIST
20316: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
20317: LD_VAR 0 6
20321: PPUSH
20322: CALL_OW 264
20326: PUSH
20327: LD_INT 3
20329: PUSH
20330: LD_INT 23
20332: PUSH
20333: EMPTY
20334: LIST
20335: LIST
20336: IN
20337: IFFALSE 20358
// points := [ 7 , 25 , 8 ] ;
20339: LD_ADDR_VAR 0 9
20343: PUSH
20344: LD_INT 7
20346: PUSH
20347: LD_INT 25
20349: PUSH
20350: LD_INT 8
20352: PUSH
20353: EMPTY
20354: LIST
20355: LIST
20356: LIST
20357: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
20358: LD_VAR 0 6
20362: PPUSH
20363: CALL_OW 264
20367: PUSH
20368: LD_INT 5
20370: PUSH
20371: LD_INT 27
20373: PUSH
20374: LD_INT 44
20376: PUSH
20377: EMPTY
20378: LIST
20379: LIST
20380: LIST
20381: IN
20382: IFFALSE 20403
// points := [ 14 , 50 , 16 ] ;
20384: LD_ADDR_VAR 0 9
20388: PUSH
20389: LD_INT 14
20391: PUSH
20392: LD_INT 50
20394: PUSH
20395: LD_INT 16
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: LIST
20402: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20403: LD_VAR 0 6
20407: PPUSH
20408: CALL_OW 264
20412: PUSH
20413: LD_INT 6
20415: PUSH
20416: LD_INT 46
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: IN
20423: IFFALSE 20444
// points := [ 32 , 120 , 70 ] ;
20425: LD_ADDR_VAR 0 9
20429: PUSH
20430: LD_INT 32
20432: PUSH
20433: LD_INT 120
20435: PUSH
20436: LD_INT 70
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: LIST
20443: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
20444: LD_VAR 0 6
20448: PPUSH
20449: CALL_OW 264
20453: PUSH
20454: LD_INT 7
20456: PUSH
20457: LD_INT 28
20459: PUSH
20460: LD_INT 45
20462: PUSH
20463: EMPTY
20464: LIST
20465: LIST
20466: LIST
20467: IN
20468: IFFALSE 20489
// points := [ 35 , 20 , 45 ] ;
20470: LD_ADDR_VAR 0 9
20474: PUSH
20475: LD_INT 35
20477: PUSH
20478: LD_INT 20
20480: PUSH
20481: LD_INT 45
20483: PUSH
20484: EMPTY
20485: LIST
20486: LIST
20487: LIST
20488: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20489: LD_VAR 0 6
20493: PPUSH
20494: CALL_OW 264
20498: PUSH
20499: LD_INT 47
20501: PUSH
20502: EMPTY
20503: LIST
20504: IN
20505: IFFALSE 20526
// points := [ 67 , 45 , 75 ] ;
20507: LD_ADDR_VAR 0 9
20511: PUSH
20512: LD_INT 67
20514: PUSH
20515: LD_INT 45
20517: PUSH
20518: LD_INT 75
20520: PUSH
20521: EMPTY
20522: LIST
20523: LIST
20524: LIST
20525: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20526: LD_VAR 0 6
20530: PPUSH
20531: CALL_OW 264
20535: PUSH
20536: LD_INT 26
20538: PUSH
20539: EMPTY
20540: LIST
20541: IN
20542: IFFALSE 20563
// points := [ 120 , 30 , 80 ] ;
20544: LD_ADDR_VAR 0 9
20548: PUSH
20549: LD_INT 120
20551: PUSH
20552: LD_INT 30
20554: PUSH
20555: LD_INT 80
20557: PUSH
20558: EMPTY
20559: LIST
20560: LIST
20561: LIST
20562: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20563: LD_VAR 0 6
20567: PPUSH
20568: CALL_OW 264
20572: PUSH
20573: LD_INT 22
20575: PUSH
20576: EMPTY
20577: LIST
20578: IN
20579: IFFALSE 20600
// points := [ 40 , 1 , 1 ] ;
20581: LD_ADDR_VAR 0 9
20585: PUSH
20586: LD_INT 40
20588: PUSH
20589: LD_INT 1
20591: PUSH
20592: LD_INT 1
20594: PUSH
20595: EMPTY
20596: LIST
20597: LIST
20598: LIST
20599: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20600: LD_VAR 0 6
20604: PPUSH
20605: CALL_OW 264
20609: PUSH
20610: LD_INT 29
20612: PUSH
20613: EMPTY
20614: LIST
20615: IN
20616: IFFALSE 20637
// points := [ 70 , 200 , 400 ] ;
20618: LD_ADDR_VAR 0 9
20622: PUSH
20623: LD_INT 70
20625: PUSH
20626: LD_INT 200
20628: PUSH
20629: LD_INT 400
20631: PUSH
20632: EMPTY
20633: LIST
20634: LIST
20635: LIST
20636: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20637: LD_VAR 0 6
20641: PPUSH
20642: CALL_OW 264
20646: PUSH
20647: LD_INT 14
20649: PUSH
20650: LD_INT 53
20652: PUSH
20653: EMPTY
20654: LIST
20655: LIST
20656: IN
20657: IFFALSE 20678
// points := [ 40 , 10 , 20 ] ;
20659: LD_ADDR_VAR 0 9
20663: PUSH
20664: LD_INT 40
20666: PUSH
20667: LD_INT 10
20669: PUSH
20670: LD_INT 20
20672: PUSH
20673: EMPTY
20674: LIST
20675: LIST
20676: LIST
20677: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20678: LD_VAR 0 6
20682: PPUSH
20683: CALL_OW 264
20687: PUSH
20688: LD_INT 9
20690: PUSH
20691: EMPTY
20692: LIST
20693: IN
20694: IFFALSE 20715
// points := [ 5 , 70 , 20 ] ;
20696: LD_ADDR_VAR 0 9
20700: PUSH
20701: LD_INT 5
20703: PUSH
20704: LD_INT 70
20706: PUSH
20707: LD_INT 20
20709: PUSH
20710: EMPTY
20711: LIST
20712: LIST
20713: LIST
20714: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20715: LD_VAR 0 6
20719: PPUSH
20720: CALL_OW 264
20724: PUSH
20725: LD_INT 10
20727: PUSH
20728: EMPTY
20729: LIST
20730: IN
20731: IFFALSE 20752
// points := [ 35 , 110 , 70 ] ;
20733: LD_ADDR_VAR 0 9
20737: PUSH
20738: LD_INT 35
20740: PUSH
20741: LD_INT 110
20743: PUSH
20744: LD_INT 70
20746: PUSH
20747: EMPTY
20748: LIST
20749: LIST
20750: LIST
20751: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20752: LD_VAR 0 6
20756: PPUSH
20757: CALL_OW 265
20761: PUSH
20762: LD_INT 25
20764: EQUAL
20765: IFFALSE 20786
// points := [ 80 , 65 , 100 ] ;
20767: LD_ADDR_VAR 0 9
20771: PUSH
20772: LD_INT 80
20774: PUSH
20775: LD_INT 65
20777: PUSH
20778: LD_INT 100
20780: PUSH
20781: EMPTY
20782: LIST
20783: LIST
20784: LIST
20785: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20786: LD_VAR 0 6
20790: PPUSH
20791: CALL_OW 263
20795: PUSH
20796: LD_INT 1
20798: EQUAL
20799: IFFALSE 20834
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
20801: LD_ADDR_VAR 0 10
20805: PUSH
20806: LD_VAR 0 10
20810: PUSH
20811: LD_VAR 0 6
20815: PPUSH
20816: CALL_OW 311
20820: PPUSH
20821: LD_INT 3
20823: PPUSH
20824: CALL_OW 259
20828: PUSH
20829: LD_INT 4
20831: MUL
20832: MUL
20833: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
20834: LD_VAR 0 6
20838: PPUSH
20839: CALL_OW 263
20843: PUSH
20844: LD_INT 2
20846: EQUAL
20847: IFFALSE 20898
// begin j := IsControledBy ( i ) ;
20849: LD_ADDR_VAR 0 7
20853: PUSH
20854: LD_VAR 0 6
20858: PPUSH
20859: CALL_OW 312
20863: ST_TO_ADDR
// if j then
20864: LD_VAR 0 7
20868: IFFALSE 20898
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
20870: LD_ADDR_VAR 0 10
20874: PUSH
20875: LD_VAR 0 10
20879: PUSH
20880: LD_VAR 0 7
20884: PPUSH
20885: LD_INT 3
20887: PPUSH
20888: CALL_OW 259
20892: PUSH
20893: LD_INT 3
20895: MUL
20896: MUL
20897: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
20898: LD_VAR 0 6
20902: PPUSH
20903: CALL_OW 264
20907: PUSH
20908: LD_INT 5
20910: PUSH
20911: LD_INT 6
20913: PUSH
20914: LD_INT 46
20916: PUSH
20917: LD_INT 44
20919: PUSH
20920: LD_INT 47
20922: PUSH
20923: LD_INT 45
20925: PUSH
20926: LD_INT 28
20928: PUSH
20929: LD_INT 7
20931: PUSH
20932: LD_INT 27
20934: PUSH
20935: LD_INT 29
20937: PUSH
20938: EMPTY
20939: LIST
20940: LIST
20941: LIST
20942: LIST
20943: LIST
20944: LIST
20945: LIST
20946: LIST
20947: LIST
20948: LIST
20949: IN
20950: PUSH
20951: LD_VAR 0 1
20955: PPUSH
20956: LD_INT 52
20958: PPUSH
20959: CALL_OW 321
20963: PUSH
20964: LD_INT 2
20966: EQUAL
20967: AND
20968: IFFALSE 20985
// bpoints := bpoints * 1.2 ;
20970: LD_ADDR_VAR 0 10
20974: PUSH
20975: LD_VAR 0 10
20979: PUSH
20980: LD_REAL  1.20000000000000E+0000
20983: MUL
20984: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
20985: LD_VAR 0 6
20989: PPUSH
20990: CALL_OW 264
20994: PUSH
20995: LD_INT 6
20997: PUSH
20998: LD_INT 46
21000: PUSH
21001: LD_INT 47
21003: PUSH
21004: EMPTY
21005: LIST
21006: LIST
21007: LIST
21008: IN
21009: IFFALSE 21026
// bpoints := bpoints * 1.2 ;
21011: LD_ADDR_VAR 0 10
21015: PUSH
21016: LD_VAR 0 10
21020: PUSH
21021: LD_REAL  1.20000000000000E+0000
21024: MUL
21025: ST_TO_ADDR
// end ; unit_building :
21026: GO 21040
21028: LD_INT 3
21030: DOUBLE
21031: EQUAL
21032: IFTRUE 21036
21034: GO 21039
21036: POP
// ; end ;
21037: GO 21040
21039: POP
// for j = 1 to 3 do
21040: LD_ADDR_VAR 0 7
21044: PUSH
21045: DOUBLE
21046: LD_INT 1
21048: DEC
21049: ST_TO_ADDR
21050: LD_INT 3
21052: PUSH
21053: FOR_TO
21054: IFFALSE 21107
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21056: LD_ADDR_VAR 0 5
21060: PUSH
21061: LD_VAR 0 5
21065: PPUSH
21066: LD_VAR 0 7
21070: PPUSH
21071: LD_VAR 0 5
21075: PUSH
21076: LD_VAR 0 7
21080: ARRAY
21081: PUSH
21082: LD_VAR 0 9
21086: PUSH
21087: LD_VAR 0 7
21091: ARRAY
21092: PUSH
21093: LD_VAR 0 10
21097: MUL
21098: PLUS
21099: PPUSH
21100: CALL_OW 1
21104: ST_TO_ADDR
21105: GO 21053
21107: POP
21108: POP
// end ;
21109: GO 19592
21111: POP
21112: POP
// result := Replace ( result , 4 , tmp ) ;
21113: LD_ADDR_VAR 0 5
21117: PUSH
21118: LD_VAR 0 5
21122: PPUSH
21123: LD_INT 4
21125: PPUSH
21126: LD_VAR 0 8
21130: PPUSH
21131: CALL_OW 1
21135: ST_TO_ADDR
// end ;
21136: LD_VAR 0 5
21140: RET
// export function DangerAtRange ( unit , range ) ; begin
21141: LD_INT 0
21143: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21144: LD_ADDR_VAR 0 3
21148: PUSH
21149: LD_VAR 0 1
21153: PPUSH
21154: CALL_OW 255
21158: PPUSH
21159: LD_VAR 0 1
21163: PPUSH
21164: CALL_OW 250
21168: PPUSH
21169: LD_VAR 0 1
21173: PPUSH
21174: CALL_OW 251
21178: PPUSH
21179: LD_VAR 0 2
21183: PPUSH
21184: CALL 19444 0 4
21188: ST_TO_ADDR
// end ;
21189: LD_VAR 0 3
21193: RET
// export function DangerInArea ( side , area ) ; begin
21194: LD_INT 0
21196: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21197: LD_ADDR_VAR 0 3
21201: PUSH
21202: LD_VAR 0 2
21206: PPUSH
21207: LD_INT 81
21209: PUSH
21210: LD_VAR 0 1
21214: PUSH
21215: EMPTY
21216: LIST
21217: LIST
21218: PPUSH
21219: CALL_OW 70
21223: ST_TO_ADDR
// end ;
21224: LD_VAR 0 3
21228: RET
// export function IsExtension ( b ) ; begin
21229: LD_INT 0
21231: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21232: LD_ADDR_VAR 0 2
21236: PUSH
21237: LD_VAR 0 1
21241: PUSH
21242: LD_INT 23
21244: PUSH
21245: LD_INT 20
21247: PUSH
21248: LD_INT 22
21250: PUSH
21251: LD_INT 17
21253: PUSH
21254: LD_INT 24
21256: PUSH
21257: LD_INT 21
21259: PUSH
21260: LD_INT 19
21262: PUSH
21263: LD_INT 16
21265: PUSH
21266: LD_INT 25
21268: PUSH
21269: LD_INT 18
21271: PUSH
21272: EMPTY
21273: LIST
21274: LIST
21275: LIST
21276: LIST
21277: LIST
21278: LIST
21279: LIST
21280: LIST
21281: LIST
21282: LIST
21283: IN
21284: ST_TO_ADDR
// end ;
21285: LD_VAR 0 2
21289: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
21290: LD_INT 0
21292: PPUSH
21293: PPUSH
21294: PPUSH
// result := [ ] ;
21295: LD_ADDR_VAR 0 3
21299: PUSH
21300: EMPTY
21301: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21302: LD_ADDR_VAR 0 4
21306: PUSH
21307: LD_VAR 0 2
21311: PPUSH
21312: LD_INT 21
21314: PUSH
21315: LD_INT 3
21317: PUSH
21318: EMPTY
21319: LIST
21320: LIST
21321: PPUSH
21322: CALL_OW 70
21326: ST_TO_ADDR
// if not tmp then
21327: LD_VAR 0 4
21331: NOT
21332: IFFALSE 21336
// exit ;
21334: GO 21394
// for i in tmp do
21336: LD_ADDR_VAR 0 5
21340: PUSH
21341: LD_VAR 0 4
21345: PUSH
21346: FOR_IN
21347: IFFALSE 21382
// if GetBase ( i ) <> base then
21349: LD_VAR 0 5
21353: PPUSH
21354: CALL_OW 274
21358: PUSH
21359: LD_VAR 0 1
21363: NONEQUAL
21364: IFFALSE 21380
// ComLinkToBase ( base , i ) ;
21366: LD_VAR 0 1
21370: PPUSH
21371: LD_VAR 0 5
21375: PPUSH
21376: CALL_OW 169
21380: GO 21346
21382: POP
21383: POP
// result := tmp ;
21384: LD_ADDR_VAR 0 3
21388: PUSH
21389: LD_VAR 0 4
21393: ST_TO_ADDR
// end ;
21394: LD_VAR 0 3
21398: RET
// export function ComComplete ( unit , b ) ; var i ; begin
21399: LD_INT 0
21401: PPUSH
21402: PPUSH
// if BuildingStatus ( b ) = bs_build then
21403: LD_VAR 0 2
21407: PPUSH
21408: CALL_OW 461
21412: PUSH
21413: LD_INT 1
21415: EQUAL
21416: IFFALSE 21476
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21418: LD_VAR 0 1
21422: PPUSH
21423: LD_STRING h
21425: PUSH
21426: LD_VAR 0 2
21430: PPUSH
21431: CALL_OW 250
21435: PUSH
21436: LD_VAR 0 2
21440: PPUSH
21441: CALL_OW 251
21445: PUSH
21446: LD_VAR 0 2
21450: PUSH
21451: LD_INT 0
21453: PUSH
21454: LD_INT 0
21456: PUSH
21457: LD_INT 0
21459: PUSH
21460: EMPTY
21461: LIST
21462: LIST
21463: LIST
21464: LIST
21465: LIST
21466: LIST
21467: LIST
21468: PUSH
21469: EMPTY
21470: LIST
21471: PPUSH
21472: CALL_OW 446
// end ;
21476: LD_VAR 0 3
21480: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21481: LD_INT 0
21483: PPUSH
21484: PPUSH
21485: PPUSH
21486: PPUSH
21487: PPUSH
21488: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
21489: LD_VAR 0 1
21493: NOT
21494: PUSH
21495: LD_VAR 0 1
21499: PPUSH
21500: CALL_OW 263
21504: PUSH
21505: LD_INT 2
21507: EQUAL
21508: NOT
21509: OR
21510: IFFALSE 21514
// exit ;
21512: GO 21830
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21514: LD_ADDR_VAR 0 6
21518: PUSH
21519: LD_INT 22
21521: PUSH
21522: LD_VAR 0 1
21526: PPUSH
21527: CALL_OW 255
21531: PUSH
21532: EMPTY
21533: LIST
21534: LIST
21535: PUSH
21536: LD_INT 2
21538: PUSH
21539: LD_INT 30
21541: PUSH
21542: LD_INT 36
21544: PUSH
21545: EMPTY
21546: LIST
21547: LIST
21548: PUSH
21549: LD_INT 34
21551: PUSH
21552: LD_INT 31
21554: PUSH
21555: EMPTY
21556: LIST
21557: LIST
21558: PUSH
21559: EMPTY
21560: LIST
21561: LIST
21562: LIST
21563: PUSH
21564: EMPTY
21565: LIST
21566: LIST
21567: PPUSH
21568: CALL_OW 69
21572: ST_TO_ADDR
// if not tmp then
21573: LD_VAR 0 6
21577: NOT
21578: IFFALSE 21582
// exit ;
21580: GO 21830
// result := [ ] ;
21582: LD_ADDR_VAR 0 2
21586: PUSH
21587: EMPTY
21588: ST_TO_ADDR
// for i in tmp do
21589: LD_ADDR_VAR 0 3
21593: PUSH
21594: LD_VAR 0 6
21598: PUSH
21599: FOR_IN
21600: IFFALSE 21671
// begin t := UnitsInside ( i ) ;
21602: LD_ADDR_VAR 0 4
21606: PUSH
21607: LD_VAR 0 3
21611: PPUSH
21612: CALL_OW 313
21616: ST_TO_ADDR
// if t then
21617: LD_VAR 0 4
21621: IFFALSE 21669
// for j in t do
21623: LD_ADDR_VAR 0 7
21627: PUSH
21628: LD_VAR 0 4
21632: PUSH
21633: FOR_IN
21634: IFFALSE 21667
// result := Insert ( result , result + 1 , j ) ;
21636: LD_ADDR_VAR 0 2
21640: PUSH
21641: LD_VAR 0 2
21645: PPUSH
21646: LD_VAR 0 2
21650: PUSH
21651: LD_INT 1
21653: PLUS
21654: PPUSH
21655: LD_VAR 0 7
21659: PPUSH
21660: CALL_OW 2
21664: ST_TO_ADDR
21665: GO 21633
21667: POP
21668: POP
// end ;
21669: GO 21599
21671: POP
21672: POP
// if not result then
21673: LD_VAR 0 2
21677: NOT
21678: IFFALSE 21682
// exit ;
21680: GO 21830
// mech := result [ 1 ] ;
21682: LD_ADDR_VAR 0 5
21686: PUSH
21687: LD_VAR 0 2
21691: PUSH
21692: LD_INT 1
21694: ARRAY
21695: ST_TO_ADDR
// if result > 1 then
21696: LD_VAR 0 2
21700: PUSH
21701: LD_INT 1
21703: GREATER
21704: IFFALSE 21816
// for i = 2 to result do
21706: LD_ADDR_VAR 0 3
21710: PUSH
21711: DOUBLE
21712: LD_INT 2
21714: DEC
21715: ST_TO_ADDR
21716: LD_VAR 0 2
21720: PUSH
21721: FOR_TO
21722: IFFALSE 21814
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21724: LD_ADDR_VAR 0 4
21728: PUSH
21729: LD_VAR 0 2
21733: PUSH
21734: LD_VAR 0 3
21738: ARRAY
21739: PPUSH
21740: LD_INT 3
21742: PPUSH
21743: CALL_OW 259
21747: PUSH
21748: LD_VAR 0 2
21752: PUSH
21753: LD_VAR 0 3
21757: ARRAY
21758: PPUSH
21759: CALL_OW 432
21763: MINUS
21764: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
21765: LD_VAR 0 4
21769: PUSH
21770: LD_VAR 0 5
21774: PPUSH
21775: LD_INT 3
21777: PPUSH
21778: CALL_OW 259
21782: PUSH
21783: LD_VAR 0 5
21787: PPUSH
21788: CALL_OW 432
21792: MINUS
21793: GREATEREQUAL
21794: IFFALSE 21812
// mech := result [ i ] ;
21796: LD_ADDR_VAR 0 5
21800: PUSH
21801: LD_VAR 0 2
21805: PUSH
21806: LD_VAR 0 3
21810: ARRAY
21811: ST_TO_ADDR
// end ;
21812: GO 21721
21814: POP
21815: POP
// ComLinkTo ( vehicle , mech ) ;
21816: LD_VAR 0 1
21820: PPUSH
21821: LD_VAR 0 5
21825: PPUSH
21826: CALL_OW 135
// end ;
21830: LD_VAR 0 2
21834: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
21835: LD_INT 0
21837: PPUSH
21838: PPUSH
21839: PPUSH
21840: PPUSH
21841: PPUSH
21842: PPUSH
21843: PPUSH
21844: PPUSH
21845: PPUSH
21846: PPUSH
21847: PPUSH
21848: PPUSH
21849: PPUSH
// result := [ ] ;
21850: LD_ADDR_VAR 0 7
21854: PUSH
21855: EMPTY
21856: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
21857: LD_VAR 0 1
21861: PPUSH
21862: CALL_OW 266
21866: PUSH
21867: LD_INT 0
21869: PUSH
21870: LD_INT 1
21872: PUSH
21873: EMPTY
21874: LIST
21875: LIST
21876: IN
21877: NOT
21878: IFFALSE 21882
// exit ;
21880: GO 23513
// if name then
21882: LD_VAR 0 3
21886: IFFALSE 21902
// SetBName ( base_dep , name ) ;
21888: LD_VAR 0 1
21892: PPUSH
21893: LD_VAR 0 3
21897: PPUSH
21898: CALL_OW 500
// base := GetBase ( base_dep ) ;
21902: LD_ADDR_VAR 0 15
21906: PUSH
21907: LD_VAR 0 1
21911: PPUSH
21912: CALL_OW 274
21916: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
21917: LD_ADDR_VAR 0 16
21921: PUSH
21922: LD_VAR 0 1
21926: PPUSH
21927: CALL_OW 255
21931: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
21932: LD_ADDR_VAR 0 17
21936: PUSH
21937: LD_VAR 0 1
21941: PPUSH
21942: CALL_OW 248
21946: ST_TO_ADDR
// if sources then
21947: LD_VAR 0 5
21951: IFFALSE 21998
// for i = 1 to 3 do
21953: LD_ADDR_VAR 0 8
21957: PUSH
21958: DOUBLE
21959: LD_INT 1
21961: DEC
21962: ST_TO_ADDR
21963: LD_INT 3
21965: PUSH
21966: FOR_TO
21967: IFFALSE 21996
// AddResourceType ( base , i , sources [ i ] ) ;
21969: LD_VAR 0 15
21973: PPUSH
21974: LD_VAR 0 8
21978: PPUSH
21979: LD_VAR 0 5
21983: PUSH
21984: LD_VAR 0 8
21988: ARRAY
21989: PPUSH
21990: CALL_OW 276
21994: GO 21966
21996: POP
21997: POP
// buildings := GetBaseBuildings ( base , area ) ;
21998: LD_ADDR_VAR 0 18
22002: PUSH
22003: LD_VAR 0 15
22007: PPUSH
22008: LD_VAR 0 2
22012: PPUSH
22013: CALL 21290 0 2
22017: ST_TO_ADDR
// InitHc ;
22018: CALL_OW 19
// InitUc ;
22022: CALL_OW 18
// uc_side := side ;
22026: LD_ADDR_OWVAR 20
22030: PUSH
22031: LD_VAR 0 16
22035: ST_TO_ADDR
// uc_nation := nation ;
22036: LD_ADDR_OWVAR 21
22040: PUSH
22041: LD_VAR 0 17
22045: ST_TO_ADDR
// if buildings then
22046: LD_VAR 0 18
22050: IFFALSE 23372
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22052: LD_ADDR_VAR 0 19
22056: PUSH
22057: LD_VAR 0 18
22061: PPUSH
22062: LD_INT 2
22064: PUSH
22065: LD_INT 30
22067: PUSH
22068: LD_INT 29
22070: PUSH
22071: EMPTY
22072: LIST
22073: LIST
22074: PUSH
22075: LD_INT 30
22077: PUSH
22078: LD_INT 30
22080: PUSH
22081: EMPTY
22082: LIST
22083: LIST
22084: PUSH
22085: EMPTY
22086: LIST
22087: LIST
22088: LIST
22089: PPUSH
22090: CALL_OW 72
22094: ST_TO_ADDR
// if tmp then
22095: LD_VAR 0 19
22099: IFFALSE 22147
// for i in tmp do
22101: LD_ADDR_VAR 0 8
22105: PUSH
22106: LD_VAR 0 19
22110: PUSH
22111: FOR_IN
22112: IFFALSE 22145
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22114: LD_VAR 0 8
22118: PPUSH
22119: CALL_OW 250
22123: PPUSH
22124: LD_VAR 0 8
22128: PPUSH
22129: CALL_OW 251
22133: PPUSH
22134: LD_VAR 0 16
22138: PPUSH
22139: CALL_OW 441
22143: GO 22111
22145: POP
22146: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22147: LD_VAR 0 18
22151: PPUSH
22152: LD_INT 2
22154: PUSH
22155: LD_INT 30
22157: PUSH
22158: LD_INT 32
22160: PUSH
22161: EMPTY
22162: LIST
22163: LIST
22164: PUSH
22165: LD_INT 30
22167: PUSH
22168: LD_INT 33
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: PUSH
22175: EMPTY
22176: LIST
22177: LIST
22178: LIST
22179: PPUSH
22180: CALL_OW 72
22184: IFFALSE 22272
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22186: LD_ADDR_VAR 0 8
22190: PUSH
22191: LD_VAR 0 18
22195: PPUSH
22196: LD_INT 2
22198: PUSH
22199: LD_INT 30
22201: PUSH
22202: LD_INT 32
22204: PUSH
22205: EMPTY
22206: LIST
22207: LIST
22208: PUSH
22209: LD_INT 30
22211: PUSH
22212: LD_INT 33
22214: PUSH
22215: EMPTY
22216: LIST
22217: LIST
22218: PUSH
22219: EMPTY
22220: LIST
22221: LIST
22222: LIST
22223: PPUSH
22224: CALL_OW 72
22228: PUSH
22229: FOR_IN
22230: IFFALSE 22270
// begin if not GetBWeapon ( i ) then
22232: LD_VAR 0 8
22236: PPUSH
22237: CALL_OW 269
22241: NOT
22242: IFFALSE 22268
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22244: LD_VAR 0 8
22248: PPUSH
22249: LD_VAR 0 8
22253: PPUSH
22254: LD_VAR 0 2
22258: PPUSH
22259: CALL 23518 0 2
22263: PPUSH
22264: CALL_OW 431
// end ;
22268: GO 22229
22270: POP
22271: POP
// end ; for i = 1 to personel do
22272: LD_ADDR_VAR 0 8
22276: PUSH
22277: DOUBLE
22278: LD_INT 1
22280: DEC
22281: ST_TO_ADDR
22282: LD_VAR 0 6
22286: PUSH
22287: FOR_TO
22288: IFFALSE 23352
// begin if i > 4 then
22290: LD_VAR 0 8
22294: PUSH
22295: LD_INT 4
22297: GREATER
22298: IFFALSE 22302
// break ;
22300: GO 23352
// case i of 1 :
22302: LD_VAR 0 8
22306: PUSH
22307: LD_INT 1
22309: DOUBLE
22310: EQUAL
22311: IFTRUE 22315
22313: GO 22395
22315: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
22316: LD_ADDR_VAR 0 12
22320: PUSH
22321: LD_VAR 0 18
22325: PPUSH
22326: LD_INT 22
22328: PUSH
22329: LD_VAR 0 16
22333: PUSH
22334: EMPTY
22335: LIST
22336: LIST
22337: PUSH
22338: LD_INT 58
22340: PUSH
22341: EMPTY
22342: LIST
22343: PUSH
22344: LD_INT 2
22346: PUSH
22347: LD_INT 30
22349: PUSH
22350: LD_INT 32
22352: PUSH
22353: EMPTY
22354: LIST
22355: LIST
22356: PUSH
22357: LD_INT 30
22359: PUSH
22360: LD_INT 4
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: PUSH
22367: LD_INT 30
22369: PUSH
22370: LD_INT 5
22372: PUSH
22373: EMPTY
22374: LIST
22375: LIST
22376: PUSH
22377: EMPTY
22378: LIST
22379: LIST
22380: LIST
22381: LIST
22382: PUSH
22383: EMPTY
22384: LIST
22385: LIST
22386: LIST
22387: PPUSH
22388: CALL_OW 72
22392: ST_TO_ADDR
22393: GO 22617
22395: LD_INT 2
22397: DOUBLE
22398: EQUAL
22399: IFTRUE 22403
22401: GO 22465
22403: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22404: LD_ADDR_VAR 0 12
22408: PUSH
22409: LD_VAR 0 18
22413: PPUSH
22414: LD_INT 22
22416: PUSH
22417: LD_VAR 0 16
22421: PUSH
22422: EMPTY
22423: LIST
22424: LIST
22425: PUSH
22426: LD_INT 2
22428: PUSH
22429: LD_INT 30
22431: PUSH
22432: LD_INT 0
22434: PUSH
22435: EMPTY
22436: LIST
22437: LIST
22438: PUSH
22439: LD_INT 30
22441: PUSH
22442: LD_INT 1
22444: PUSH
22445: EMPTY
22446: LIST
22447: LIST
22448: PUSH
22449: EMPTY
22450: LIST
22451: LIST
22452: LIST
22453: PUSH
22454: EMPTY
22455: LIST
22456: LIST
22457: PPUSH
22458: CALL_OW 72
22462: ST_TO_ADDR
22463: GO 22617
22465: LD_INT 3
22467: DOUBLE
22468: EQUAL
22469: IFTRUE 22473
22471: GO 22535
22473: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22474: LD_ADDR_VAR 0 12
22478: PUSH
22479: LD_VAR 0 18
22483: PPUSH
22484: LD_INT 22
22486: PUSH
22487: LD_VAR 0 16
22491: PUSH
22492: EMPTY
22493: LIST
22494: LIST
22495: PUSH
22496: LD_INT 2
22498: PUSH
22499: LD_INT 30
22501: PUSH
22502: LD_INT 2
22504: PUSH
22505: EMPTY
22506: LIST
22507: LIST
22508: PUSH
22509: LD_INT 30
22511: PUSH
22512: LD_INT 3
22514: PUSH
22515: EMPTY
22516: LIST
22517: LIST
22518: PUSH
22519: EMPTY
22520: LIST
22521: LIST
22522: LIST
22523: PUSH
22524: EMPTY
22525: LIST
22526: LIST
22527: PPUSH
22528: CALL_OW 72
22532: ST_TO_ADDR
22533: GO 22617
22535: LD_INT 4
22537: DOUBLE
22538: EQUAL
22539: IFTRUE 22543
22541: GO 22616
22543: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22544: LD_ADDR_VAR 0 12
22548: PUSH
22549: LD_VAR 0 18
22553: PPUSH
22554: LD_INT 22
22556: PUSH
22557: LD_VAR 0 16
22561: PUSH
22562: EMPTY
22563: LIST
22564: LIST
22565: PUSH
22566: LD_INT 2
22568: PUSH
22569: LD_INT 30
22571: PUSH
22572: LD_INT 6
22574: PUSH
22575: EMPTY
22576: LIST
22577: LIST
22578: PUSH
22579: LD_INT 30
22581: PUSH
22582: LD_INT 7
22584: PUSH
22585: EMPTY
22586: LIST
22587: LIST
22588: PUSH
22589: LD_INT 30
22591: PUSH
22592: LD_INT 8
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: PUSH
22599: EMPTY
22600: LIST
22601: LIST
22602: LIST
22603: LIST
22604: PUSH
22605: EMPTY
22606: LIST
22607: LIST
22608: PPUSH
22609: CALL_OW 72
22613: ST_TO_ADDR
22614: GO 22617
22616: POP
// if i = 1 then
22617: LD_VAR 0 8
22621: PUSH
22622: LD_INT 1
22624: EQUAL
22625: IFFALSE 22736
// begin tmp := [ ] ;
22627: LD_ADDR_VAR 0 19
22631: PUSH
22632: EMPTY
22633: ST_TO_ADDR
// for j in f do
22634: LD_ADDR_VAR 0 9
22638: PUSH
22639: LD_VAR 0 12
22643: PUSH
22644: FOR_IN
22645: IFFALSE 22718
// if GetBType ( j ) = b_bunker then
22647: LD_VAR 0 9
22651: PPUSH
22652: CALL_OW 266
22656: PUSH
22657: LD_INT 32
22659: EQUAL
22660: IFFALSE 22687
// tmp := Insert ( tmp , 1 , j ) else
22662: LD_ADDR_VAR 0 19
22666: PUSH
22667: LD_VAR 0 19
22671: PPUSH
22672: LD_INT 1
22674: PPUSH
22675: LD_VAR 0 9
22679: PPUSH
22680: CALL_OW 2
22684: ST_TO_ADDR
22685: GO 22716
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22687: LD_ADDR_VAR 0 19
22691: PUSH
22692: LD_VAR 0 19
22696: PPUSH
22697: LD_VAR 0 19
22701: PUSH
22702: LD_INT 1
22704: PLUS
22705: PPUSH
22706: LD_VAR 0 9
22710: PPUSH
22711: CALL_OW 2
22715: ST_TO_ADDR
22716: GO 22644
22718: POP
22719: POP
// if tmp then
22720: LD_VAR 0 19
22724: IFFALSE 22736
// f := tmp ;
22726: LD_ADDR_VAR 0 12
22730: PUSH
22731: LD_VAR 0 19
22735: ST_TO_ADDR
// end ; x := personel [ i ] ;
22736: LD_ADDR_VAR 0 13
22740: PUSH
22741: LD_VAR 0 6
22745: PUSH
22746: LD_VAR 0 8
22750: ARRAY
22751: ST_TO_ADDR
// if x = - 1 then
22752: LD_VAR 0 13
22756: PUSH
22757: LD_INT 1
22759: NEG
22760: EQUAL
22761: IFFALSE 22970
// begin for j in f do
22763: LD_ADDR_VAR 0 9
22767: PUSH
22768: LD_VAR 0 12
22772: PUSH
22773: FOR_IN
22774: IFFALSE 22966
// repeat InitHc ;
22776: CALL_OW 19
// if GetBType ( j ) = b_barracks then
22780: LD_VAR 0 9
22784: PPUSH
22785: CALL_OW 266
22789: PUSH
22790: LD_INT 5
22792: EQUAL
22793: IFFALSE 22863
// begin if UnitsInside ( j ) < 3 then
22795: LD_VAR 0 9
22799: PPUSH
22800: CALL_OW 313
22804: PUSH
22805: LD_INT 3
22807: LESS
22808: IFFALSE 22844
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22810: LD_INT 0
22812: PPUSH
22813: LD_INT 5
22815: PUSH
22816: LD_INT 8
22818: PUSH
22819: LD_INT 9
22821: PUSH
22822: EMPTY
22823: LIST
22824: LIST
22825: LIST
22826: PUSH
22827: LD_VAR 0 17
22831: ARRAY
22832: PPUSH
22833: LD_VAR 0 4
22837: PPUSH
22838: CALL_OW 380
22842: GO 22861
// PrepareHuman ( false , i , skill ) ;
22844: LD_INT 0
22846: PPUSH
22847: LD_VAR 0 8
22851: PPUSH
22852: LD_VAR 0 4
22856: PPUSH
22857: CALL_OW 380
// end else
22861: GO 22880
// PrepareHuman ( false , i , skill ) ;
22863: LD_INT 0
22865: PPUSH
22866: LD_VAR 0 8
22870: PPUSH
22871: LD_VAR 0 4
22875: PPUSH
22876: CALL_OW 380
// un := CreateHuman ;
22880: LD_ADDR_VAR 0 14
22884: PUSH
22885: CALL_OW 44
22889: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22890: LD_ADDR_VAR 0 7
22894: PUSH
22895: LD_VAR 0 7
22899: PPUSH
22900: LD_INT 1
22902: PPUSH
22903: LD_VAR 0 14
22907: PPUSH
22908: CALL_OW 2
22912: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
22913: LD_VAR 0 14
22917: PPUSH
22918: LD_VAR 0 9
22922: PPUSH
22923: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
22927: LD_VAR 0 9
22931: PPUSH
22932: CALL_OW 313
22936: PUSH
22937: LD_INT 6
22939: EQUAL
22940: PUSH
22941: LD_VAR 0 9
22945: PPUSH
22946: CALL_OW 266
22950: PUSH
22951: LD_INT 32
22953: PUSH
22954: LD_INT 31
22956: PUSH
22957: EMPTY
22958: LIST
22959: LIST
22960: IN
22961: OR
22962: IFFALSE 22776
22964: GO 22773
22966: POP
22967: POP
// end else
22968: GO 23350
// for j = 1 to x do
22970: LD_ADDR_VAR 0 9
22974: PUSH
22975: DOUBLE
22976: LD_INT 1
22978: DEC
22979: ST_TO_ADDR
22980: LD_VAR 0 13
22984: PUSH
22985: FOR_TO
22986: IFFALSE 23348
// begin InitHc ;
22988: CALL_OW 19
// if not f then
22992: LD_VAR 0 12
22996: NOT
22997: IFFALSE 23086
// begin PrepareHuman ( false , i , skill ) ;
22999: LD_INT 0
23001: PPUSH
23002: LD_VAR 0 8
23006: PPUSH
23007: LD_VAR 0 4
23011: PPUSH
23012: CALL_OW 380
// un := CreateHuman ;
23016: LD_ADDR_VAR 0 14
23020: PUSH
23021: CALL_OW 44
23025: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23026: LD_ADDR_VAR 0 7
23030: PUSH
23031: LD_VAR 0 7
23035: PPUSH
23036: LD_INT 1
23038: PPUSH
23039: LD_VAR 0 14
23043: PPUSH
23044: CALL_OW 2
23048: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23049: LD_VAR 0 14
23053: PPUSH
23054: LD_VAR 0 1
23058: PPUSH
23059: CALL_OW 250
23063: PPUSH
23064: LD_VAR 0 1
23068: PPUSH
23069: CALL_OW 251
23073: PPUSH
23074: LD_INT 10
23076: PPUSH
23077: LD_INT 0
23079: PPUSH
23080: CALL_OW 50
// continue ;
23084: GO 22985
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23086: LD_VAR 0 12
23090: PUSH
23091: LD_INT 1
23093: ARRAY
23094: PPUSH
23095: CALL_OW 313
23099: PUSH
23100: LD_VAR 0 12
23104: PUSH
23105: LD_INT 1
23107: ARRAY
23108: PPUSH
23109: CALL_OW 266
23113: PUSH
23114: LD_INT 32
23116: PUSH
23117: LD_INT 31
23119: PUSH
23120: EMPTY
23121: LIST
23122: LIST
23123: IN
23124: AND
23125: PUSH
23126: LD_VAR 0 12
23130: PUSH
23131: LD_INT 1
23133: ARRAY
23134: PPUSH
23135: CALL_OW 313
23139: PUSH
23140: LD_INT 6
23142: EQUAL
23143: OR
23144: IFFALSE 23164
// f := Delete ( f , 1 ) ;
23146: LD_ADDR_VAR 0 12
23150: PUSH
23151: LD_VAR 0 12
23155: PPUSH
23156: LD_INT 1
23158: PPUSH
23159: CALL_OW 3
23163: ST_TO_ADDR
// if not f then
23164: LD_VAR 0 12
23168: NOT
23169: IFFALSE 23187
// begin x := x + 2 ;
23171: LD_ADDR_VAR 0 13
23175: PUSH
23176: LD_VAR 0 13
23180: PUSH
23181: LD_INT 2
23183: PLUS
23184: ST_TO_ADDR
// continue ;
23185: GO 22985
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23187: LD_VAR 0 12
23191: PUSH
23192: LD_INT 1
23194: ARRAY
23195: PPUSH
23196: CALL_OW 266
23200: PUSH
23201: LD_INT 5
23203: EQUAL
23204: IFFALSE 23278
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23206: LD_VAR 0 12
23210: PUSH
23211: LD_INT 1
23213: ARRAY
23214: PPUSH
23215: CALL_OW 313
23219: PUSH
23220: LD_INT 3
23222: LESS
23223: IFFALSE 23259
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23225: LD_INT 0
23227: PPUSH
23228: LD_INT 5
23230: PUSH
23231: LD_INT 8
23233: PUSH
23234: LD_INT 9
23236: PUSH
23237: EMPTY
23238: LIST
23239: LIST
23240: LIST
23241: PUSH
23242: LD_VAR 0 17
23246: ARRAY
23247: PPUSH
23248: LD_VAR 0 4
23252: PPUSH
23253: CALL_OW 380
23257: GO 23276
// PrepareHuman ( false , i , skill ) ;
23259: LD_INT 0
23261: PPUSH
23262: LD_VAR 0 8
23266: PPUSH
23267: LD_VAR 0 4
23271: PPUSH
23272: CALL_OW 380
// end else
23276: GO 23295
// PrepareHuman ( false , i , skill ) ;
23278: LD_INT 0
23280: PPUSH
23281: LD_VAR 0 8
23285: PPUSH
23286: LD_VAR 0 4
23290: PPUSH
23291: CALL_OW 380
// un := CreateHuman ;
23295: LD_ADDR_VAR 0 14
23299: PUSH
23300: CALL_OW 44
23304: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23305: LD_ADDR_VAR 0 7
23309: PUSH
23310: LD_VAR 0 7
23314: PPUSH
23315: LD_INT 1
23317: PPUSH
23318: LD_VAR 0 14
23322: PPUSH
23323: CALL_OW 2
23327: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
23328: LD_VAR 0 14
23332: PPUSH
23333: LD_VAR 0 12
23337: PUSH
23338: LD_INT 1
23340: ARRAY
23341: PPUSH
23342: CALL_OW 52
// end ;
23346: GO 22985
23348: POP
23349: POP
// end ;
23350: GO 22287
23352: POP
23353: POP
// result := result ^ buildings ;
23354: LD_ADDR_VAR 0 7
23358: PUSH
23359: LD_VAR 0 7
23363: PUSH
23364: LD_VAR 0 18
23368: ADD
23369: ST_TO_ADDR
// end else
23370: GO 23513
// begin for i = 1 to personel do
23372: LD_ADDR_VAR 0 8
23376: PUSH
23377: DOUBLE
23378: LD_INT 1
23380: DEC
23381: ST_TO_ADDR
23382: LD_VAR 0 6
23386: PUSH
23387: FOR_TO
23388: IFFALSE 23511
// begin if i > 4 then
23390: LD_VAR 0 8
23394: PUSH
23395: LD_INT 4
23397: GREATER
23398: IFFALSE 23402
// break ;
23400: GO 23511
// x := personel [ i ] ;
23402: LD_ADDR_VAR 0 13
23406: PUSH
23407: LD_VAR 0 6
23411: PUSH
23412: LD_VAR 0 8
23416: ARRAY
23417: ST_TO_ADDR
// if x = - 1 then
23418: LD_VAR 0 13
23422: PUSH
23423: LD_INT 1
23425: NEG
23426: EQUAL
23427: IFFALSE 23431
// continue ;
23429: GO 23387
// PrepareHuman ( false , i , skill ) ;
23431: LD_INT 0
23433: PPUSH
23434: LD_VAR 0 8
23438: PPUSH
23439: LD_VAR 0 4
23443: PPUSH
23444: CALL_OW 380
// un := CreateHuman ;
23448: LD_ADDR_VAR 0 14
23452: PUSH
23453: CALL_OW 44
23457: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23458: LD_VAR 0 14
23462: PPUSH
23463: LD_VAR 0 1
23467: PPUSH
23468: CALL_OW 250
23472: PPUSH
23473: LD_VAR 0 1
23477: PPUSH
23478: CALL_OW 251
23482: PPUSH
23483: LD_INT 10
23485: PPUSH
23486: LD_INT 0
23488: PPUSH
23489: CALL_OW 50
// result := result ^ un ;
23493: LD_ADDR_VAR 0 7
23497: PUSH
23498: LD_VAR 0 7
23502: PUSH
23503: LD_VAR 0 14
23507: ADD
23508: ST_TO_ADDR
// end ;
23509: GO 23387
23511: POP
23512: POP
// end ; end ;
23513: LD_VAR 0 7
23517: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23518: LD_INT 0
23520: PPUSH
23521: PPUSH
23522: PPUSH
23523: PPUSH
23524: PPUSH
23525: PPUSH
23526: PPUSH
23527: PPUSH
23528: PPUSH
23529: PPUSH
23530: PPUSH
23531: PPUSH
23532: PPUSH
23533: PPUSH
23534: PPUSH
23535: PPUSH
// result := false ;
23536: LD_ADDR_VAR 0 3
23540: PUSH
23541: LD_INT 0
23543: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23544: LD_VAR 0 1
23548: NOT
23549: PUSH
23550: LD_VAR 0 1
23554: PPUSH
23555: CALL_OW 266
23559: PUSH
23560: LD_INT 32
23562: PUSH
23563: LD_INT 33
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: IN
23570: NOT
23571: OR
23572: IFFALSE 23576
// exit ;
23574: GO 24712
// nat := GetNation ( tower ) ;
23576: LD_ADDR_VAR 0 12
23580: PUSH
23581: LD_VAR 0 1
23585: PPUSH
23586: CALL_OW 248
23590: ST_TO_ADDR
// side := GetSide ( tower ) ;
23591: LD_ADDR_VAR 0 16
23595: PUSH
23596: LD_VAR 0 1
23600: PPUSH
23601: CALL_OW 255
23605: ST_TO_ADDR
// x := GetX ( tower ) ;
23606: LD_ADDR_VAR 0 10
23610: PUSH
23611: LD_VAR 0 1
23615: PPUSH
23616: CALL_OW 250
23620: ST_TO_ADDR
// y := GetY ( tower ) ;
23621: LD_ADDR_VAR 0 11
23625: PUSH
23626: LD_VAR 0 1
23630: PPUSH
23631: CALL_OW 251
23635: ST_TO_ADDR
// if not x or not y then
23636: LD_VAR 0 10
23640: NOT
23641: PUSH
23642: LD_VAR 0 11
23646: NOT
23647: OR
23648: IFFALSE 23652
// exit ;
23650: GO 24712
// weapon := 0 ;
23652: LD_ADDR_VAR 0 18
23656: PUSH
23657: LD_INT 0
23659: ST_TO_ADDR
// fac_list := [ ] ;
23660: LD_ADDR_VAR 0 17
23664: PUSH
23665: EMPTY
23666: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
23667: LD_ADDR_VAR 0 6
23671: PUSH
23672: LD_VAR 0 1
23676: PPUSH
23677: CALL_OW 274
23681: PPUSH
23682: LD_VAR 0 2
23686: PPUSH
23687: CALL 21290 0 2
23691: PPUSH
23692: LD_INT 30
23694: PUSH
23695: LD_INT 3
23697: PUSH
23698: EMPTY
23699: LIST
23700: LIST
23701: PPUSH
23702: CALL_OW 72
23706: ST_TO_ADDR
// if not factories then
23707: LD_VAR 0 6
23711: NOT
23712: IFFALSE 23716
// exit ;
23714: GO 24712
// for i in factories do
23716: LD_ADDR_VAR 0 8
23720: PUSH
23721: LD_VAR 0 6
23725: PUSH
23726: FOR_IN
23727: IFFALSE 23752
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23729: LD_ADDR_VAR 0 17
23733: PUSH
23734: LD_VAR 0 17
23738: PUSH
23739: LD_VAR 0 8
23743: PPUSH
23744: CALL_OW 478
23748: UNION
23749: ST_TO_ADDR
23750: GO 23726
23752: POP
23753: POP
// if not fac_list then
23754: LD_VAR 0 17
23758: NOT
23759: IFFALSE 23763
// exit ;
23761: GO 24712
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
23763: LD_ADDR_VAR 0 5
23767: PUSH
23768: LD_INT 4
23770: PUSH
23771: LD_INT 5
23773: PUSH
23774: LD_INT 9
23776: PUSH
23777: LD_INT 10
23779: PUSH
23780: LD_INT 6
23782: PUSH
23783: LD_INT 7
23785: PUSH
23786: LD_INT 11
23788: PUSH
23789: EMPTY
23790: LIST
23791: LIST
23792: LIST
23793: LIST
23794: LIST
23795: LIST
23796: LIST
23797: PUSH
23798: LD_INT 27
23800: PUSH
23801: LD_INT 28
23803: PUSH
23804: LD_INT 26
23806: PUSH
23807: LD_INT 30
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: LIST
23814: LIST
23815: PUSH
23816: LD_INT 43
23818: PUSH
23819: LD_INT 44
23821: PUSH
23822: LD_INT 46
23824: PUSH
23825: LD_INT 45
23827: PUSH
23828: LD_INT 47
23830: PUSH
23831: LD_INT 49
23833: PUSH
23834: EMPTY
23835: LIST
23836: LIST
23837: LIST
23838: LIST
23839: LIST
23840: LIST
23841: PUSH
23842: EMPTY
23843: LIST
23844: LIST
23845: LIST
23846: PUSH
23847: LD_VAR 0 12
23851: ARRAY
23852: ST_TO_ADDR
// for i in list do
23853: LD_ADDR_VAR 0 8
23857: PUSH
23858: LD_VAR 0 5
23862: PUSH
23863: FOR_IN
23864: IFFALSE 23897
// if not i in fac_list then
23866: LD_VAR 0 8
23870: PUSH
23871: LD_VAR 0 17
23875: IN
23876: NOT
23877: IFFALSE 23895
// list := list diff i ;
23879: LD_ADDR_VAR 0 5
23883: PUSH
23884: LD_VAR 0 5
23888: PUSH
23889: LD_VAR 0 8
23893: DIFF
23894: ST_TO_ADDR
23895: GO 23863
23897: POP
23898: POP
// if not list then
23899: LD_VAR 0 5
23903: NOT
23904: IFFALSE 23908
// exit ;
23906: GO 24712
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
23908: LD_VAR 0 12
23912: PUSH
23913: LD_INT 3
23915: EQUAL
23916: PUSH
23917: LD_INT 49
23919: PUSH
23920: LD_VAR 0 5
23924: IN
23925: AND
23926: PUSH
23927: LD_INT 31
23929: PPUSH
23930: LD_VAR 0 16
23934: PPUSH
23935: CALL_OW 321
23939: PUSH
23940: LD_INT 2
23942: EQUAL
23943: AND
23944: IFFALSE 24004
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
23946: LD_INT 22
23948: PUSH
23949: LD_VAR 0 16
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: PUSH
23958: LD_INT 35
23960: PUSH
23961: LD_INT 49
23963: PUSH
23964: EMPTY
23965: LIST
23966: LIST
23967: PUSH
23968: LD_INT 91
23970: PUSH
23971: LD_VAR 0 1
23975: PUSH
23976: LD_INT 10
23978: PUSH
23979: EMPTY
23980: LIST
23981: LIST
23982: LIST
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: LIST
23988: PPUSH
23989: CALL_OW 69
23993: NOT
23994: IFFALSE 24004
// weapon := ru_time_lapser ;
23996: LD_ADDR_VAR 0 18
24000: PUSH
24001: LD_INT 49
24003: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24004: LD_VAR 0 12
24008: PUSH
24009: LD_INT 1
24011: PUSH
24012: LD_INT 2
24014: PUSH
24015: EMPTY
24016: LIST
24017: LIST
24018: IN
24019: PUSH
24020: LD_INT 11
24022: PUSH
24023: LD_VAR 0 5
24027: IN
24028: PUSH
24029: LD_INT 30
24031: PUSH
24032: LD_VAR 0 5
24036: IN
24037: OR
24038: AND
24039: PUSH
24040: LD_INT 6
24042: PPUSH
24043: LD_VAR 0 16
24047: PPUSH
24048: CALL_OW 321
24052: PUSH
24053: LD_INT 2
24055: EQUAL
24056: AND
24057: IFFALSE 24222
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24059: LD_INT 22
24061: PUSH
24062: LD_VAR 0 16
24066: PUSH
24067: EMPTY
24068: LIST
24069: LIST
24070: PUSH
24071: LD_INT 2
24073: PUSH
24074: LD_INT 35
24076: PUSH
24077: LD_INT 11
24079: PUSH
24080: EMPTY
24081: LIST
24082: LIST
24083: PUSH
24084: LD_INT 35
24086: PUSH
24087: LD_INT 30
24089: PUSH
24090: EMPTY
24091: LIST
24092: LIST
24093: PUSH
24094: EMPTY
24095: LIST
24096: LIST
24097: LIST
24098: PUSH
24099: LD_INT 91
24101: PUSH
24102: LD_VAR 0 1
24106: PUSH
24107: LD_INT 18
24109: PUSH
24110: EMPTY
24111: LIST
24112: LIST
24113: LIST
24114: PUSH
24115: EMPTY
24116: LIST
24117: LIST
24118: LIST
24119: PPUSH
24120: CALL_OW 69
24124: NOT
24125: PUSH
24126: LD_INT 22
24128: PUSH
24129: LD_VAR 0 16
24133: PUSH
24134: EMPTY
24135: LIST
24136: LIST
24137: PUSH
24138: LD_INT 2
24140: PUSH
24141: LD_INT 30
24143: PUSH
24144: LD_INT 32
24146: PUSH
24147: EMPTY
24148: LIST
24149: LIST
24150: PUSH
24151: LD_INT 30
24153: PUSH
24154: LD_INT 33
24156: PUSH
24157: EMPTY
24158: LIST
24159: LIST
24160: PUSH
24161: EMPTY
24162: LIST
24163: LIST
24164: LIST
24165: PUSH
24166: LD_INT 91
24168: PUSH
24169: LD_VAR 0 1
24173: PUSH
24174: LD_INT 12
24176: PUSH
24177: EMPTY
24178: LIST
24179: LIST
24180: LIST
24181: PUSH
24182: EMPTY
24183: LIST
24184: LIST
24185: LIST
24186: PUSH
24187: EMPTY
24188: LIST
24189: PPUSH
24190: CALL_OW 69
24194: PUSH
24195: LD_INT 2
24197: GREATER
24198: AND
24199: IFFALSE 24222
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24201: LD_ADDR_VAR 0 18
24205: PUSH
24206: LD_INT 11
24208: PUSH
24209: LD_INT 30
24211: PUSH
24212: EMPTY
24213: LIST
24214: LIST
24215: PUSH
24216: LD_VAR 0 12
24220: ARRAY
24221: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24222: LD_VAR 0 18
24226: NOT
24227: PUSH
24228: LD_INT 40
24230: PPUSH
24231: LD_VAR 0 16
24235: PPUSH
24236: CALL_OW 321
24240: PUSH
24241: LD_INT 2
24243: EQUAL
24244: AND
24245: PUSH
24246: LD_INT 7
24248: PUSH
24249: LD_VAR 0 5
24253: IN
24254: PUSH
24255: LD_INT 28
24257: PUSH
24258: LD_VAR 0 5
24262: IN
24263: OR
24264: PUSH
24265: LD_INT 45
24267: PUSH
24268: LD_VAR 0 5
24272: IN
24273: OR
24274: AND
24275: IFFALSE 24529
// begin hex := GetHexInfo ( x , y ) ;
24277: LD_ADDR_VAR 0 4
24281: PUSH
24282: LD_VAR 0 10
24286: PPUSH
24287: LD_VAR 0 11
24291: PPUSH
24292: CALL_OW 546
24296: ST_TO_ADDR
// if hex [ 1 ] then
24297: LD_VAR 0 4
24301: PUSH
24302: LD_INT 1
24304: ARRAY
24305: IFFALSE 24309
// exit ;
24307: GO 24712
// height := hex [ 2 ] ;
24309: LD_ADDR_VAR 0 15
24313: PUSH
24314: LD_VAR 0 4
24318: PUSH
24319: LD_INT 2
24321: ARRAY
24322: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
24323: LD_ADDR_VAR 0 14
24327: PUSH
24328: LD_INT 0
24330: PUSH
24331: LD_INT 2
24333: PUSH
24334: LD_INT 3
24336: PUSH
24337: LD_INT 5
24339: PUSH
24340: EMPTY
24341: LIST
24342: LIST
24343: LIST
24344: LIST
24345: ST_TO_ADDR
// for i in tmp do
24346: LD_ADDR_VAR 0 8
24350: PUSH
24351: LD_VAR 0 14
24355: PUSH
24356: FOR_IN
24357: IFFALSE 24527
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
24359: LD_ADDR_VAR 0 9
24363: PUSH
24364: LD_VAR 0 10
24368: PPUSH
24369: LD_VAR 0 8
24373: PPUSH
24374: LD_INT 5
24376: PPUSH
24377: CALL_OW 272
24381: PUSH
24382: LD_VAR 0 11
24386: PPUSH
24387: LD_VAR 0 8
24391: PPUSH
24392: LD_INT 5
24394: PPUSH
24395: CALL_OW 273
24399: PUSH
24400: EMPTY
24401: LIST
24402: LIST
24403: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24404: LD_VAR 0 9
24408: PUSH
24409: LD_INT 1
24411: ARRAY
24412: PPUSH
24413: LD_VAR 0 9
24417: PUSH
24418: LD_INT 2
24420: ARRAY
24421: PPUSH
24422: CALL_OW 488
24426: IFFALSE 24525
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24428: LD_ADDR_VAR 0 4
24432: PUSH
24433: LD_VAR 0 9
24437: PUSH
24438: LD_INT 1
24440: ARRAY
24441: PPUSH
24442: LD_VAR 0 9
24446: PUSH
24447: LD_INT 2
24449: ARRAY
24450: PPUSH
24451: CALL_OW 546
24455: ST_TO_ADDR
// if hex [ 1 ] then
24456: LD_VAR 0 4
24460: PUSH
24461: LD_INT 1
24463: ARRAY
24464: IFFALSE 24468
// continue ;
24466: GO 24356
// h := hex [ 2 ] ;
24468: LD_ADDR_VAR 0 13
24472: PUSH
24473: LD_VAR 0 4
24477: PUSH
24478: LD_INT 2
24480: ARRAY
24481: ST_TO_ADDR
// if h + 7 < height then
24482: LD_VAR 0 13
24486: PUSH
24487: LD_INT 7
24489: PLUS
24490: PUSH
24491: LD_VAR 0 15
24495: LESS
24496: IFFALSE 24525
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24498: LD_ADDR_VAR 0 18
24502: PUSH
24503: LD_INT 7
24505: PUSH
24506: LD_INT 28
24508: PUSH
24509: LD_INT 45
24511: PUSH
24512: EMPTY
24513: LIST
24514: LIST
24515: LIST
24516: PUSH
24517: LD_VAR 0 12
24521: ARRAY
24522: ST_TO_ADDR
// break ;
24523: GO 24527
// end ; end ; end ;
24525: GO 24356
24527: POP
24528: POP
// end ; if not weapon then
24529: LD_VAR 0 18
24533: NOT
24534: IFFALSE 24594
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24536: LD_ADDR_VAR 0 5
24540: PUSH
24541: LD_VAR 0 5
24545: PUSH
24546: LD_INT 11
24548: PUSH
24549: LD_INT 30
24551: PUSH
24552: LD_INT 49
24554: PUSH
24555: EMPTY
24556: LIST
24557: LIST
24558: LIST
24559: DIFF
24560: ST_TO_ADDR
// if not list then
24561: LD_VAR 0 5
24565: NOT
24566: IFFALSE 24570
// exit ;
24568: GO 24712
// weapon := list [ rand ( 1 , list ) ] ;
24570: LD_ADDR_VAR 0 18
24574: PUSH
24575: LD_VAR 0 5
24579: PUSH
24580: LD_INT 1
24582: PPUSH
24583: LD_VAR 0 5
24587: PPUSH
24588: CALL_OW 12
24592: ARRAY
24593: ST_TO_ADDR
// end ; if weapon then
24594: LD_VAR 0 18
24598: IFFALSE 24712
// begin tmp := CostOfWeapon ( weapon ) ;
24600: LD_ADDR_VAR 0 14
24604: PUSH
24605: LD_VAR 0 18
24609: PPUSH
24610: CALL_OW 451
24614: ST_TO_ADDR
// j := GetBase ( tower ) ;
24615: LD_ADDR_VAR 0 9
24619: PUSH
24620: LD_VAR 0 1
24624: PPUSH
24625: CALL_OW 274
24629: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24630: LD_VAR 0 9
24634: PPUSH
24635: LD_INT 1
24637: PPUSH
24638: CALL_OW 275
24642: PUSH
24643: LD_VAR 0 14
24647: PUSH
24648: LD_INT 1
24650: ARRAY
24651: GREATEREQUAL
24652: PUSH
24653: LD_VAR 0 9
24657: PPUSH
24658: LD_INT 2
24660: PPUSH
24661: CALL_OW 275
24665: PUSH
24666: LD_VAR 0 14
24670: PUSH
24671: LD_INT 2
24673: ARRAY
24674: GREATEREQUAL
24675: AND
24676: PUSH
24677: LD_VAR 0 9
24681: PPUSH
24682: LD_INT 3
24684: PPUSH
24685: CALL_OW 275
24689: PUSH
24690: LD_VAR 0 14
24694: PUSH
24695: LD_INT 3
24697: ARRAY
24698: GREATEREQUAL
24699: AND
24700: IFFALSE 24712
// result := weapon ;
24702: LD_ADDR_VAR 0 3
24706: PUSH
24707: LD_VAR 0 18
24711: ST_TO_ADDR
// end ; end ;
24712: LD_VAR 0 3
24716: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24717: LD_INT 0
24719: PPUSH
24720: PPUSH
// result := true ;
24721: LD_ADDR_VAR 0 3
24725: PUSH
24726: LD_INT 1
24728: ST_TO_ADDR
// if array1 = array2 then
24729: LD_VAR 0 1
24733: PUSH
24734: LD_VAR 0 2
24738: EQUAL
24739: IFFALSE 24799
// begin for i = 1 to array1 do
24741: LD_ADDR_VAR 0 4
24745: PUSH
24746: DOUBLE
24747: LD_INT 1
24749: DEC
24750: ST_TO_ADDR
24751: LD_VAR 0 1
24755: PUSH
24756: FOR_TO
24757: IFFALSE 24795
// if array1 [ i ] <> array2 [ i ] then
24759: LD_VAR 0 1
24763: PUSH
24764: LD_VAR 0 4
24768: ARRAY
24769: PUSH
24770: LD_VAR 0 2
24774: PUSH
24775: LD_VAR 0 4
24779: ARRAY
24780: NONEQUAL
24781: IFFALSE 24793
// begin result := false ;
24783: LD_ADDR_VAR 0 3
24787: PUSH
24788: LD_INT 0
24790: ST_TO_ADDR
// break ;
24791: GO 24795
// end ;
24793: GO 24756
24795: POP
24796: POP
// end else
24797: GO 24807
// result := false ;
24799: LD_ADDR_VAR 0 3
24803: PUSH
24804: LD_INT 0
24806: ST_TO_ADDR
// end ;
24807: LD_VAR 0 3
24811: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
24812: LD_INT 0
24814: PPUSH
24815: PPUSH
24816: PPUSH
// pom := GetBase ( fac ) ;
24817: LD_ADDR_VAR 0 5
24821: PUSH
24822: LD_VAR 0 1
24826: PPUSH
24827: CALL_OW 274
24831: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24832: LD_ADDR_VAR 0 4
24836: PUSH
24837: LD_VAR 0 2
24841: PUSH
24842: LD_INT 1
24844: ARRAY
24845: PPUSH
24846: LD_VAR 0 2
24850: PUSH
24851: LD_INT 2
24853: ARRAY
24854: PPUSH
24855: LD_VAR 0 2
24859: PUSH
24860: LD_INT 3
24862: ARRAY
24863: PPUSH
24864: LD_VAR 0 2
24868: PUSH
24869: LD_INT 4
24871: ARRAY
24872: PPUSH
24873: CALL_OW 449
24877: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
24878: LD_ADDR_VAR 0 3
24882: PUSH
24883: LD_VAR 0 5
24887: PPUSH
24888: LD_INT 1
24890: PPUSH
24891: CALL_OW 275
24895: PUSH
24896: LD_VAR 0 4
24900: PUSH
24901: LD_INT 1
24903: ARRAY
24904: GREATEREQUAL
24905: PUSH
24906: LD_VAR 0 5
24910: PPUSH
24911: LD_INT 2
24913: PPUSH
24914: CALL_OW 275
24918: PUSH
24919: LD_VAR 0 4
24923: PUSH
24924: LD_INT 2
24926: ARRAY
24927: GREATEREQUAL
24928: AND
24929: PUSH
24930: LD_VAR 0 5
24934: PPUSH
24935: LD_INT 3
24937: PPUSH
24938: CALL_OW 275
24942: PUSH
24943: LD_VAR 0 4
24947: PUSH
24948: LD_INT 3
24950: ARRAY
24951: GREATEREQUAL
24952: AND
24953: ST_TO_ADDR
// end ;
24954: LD_VAR 0 3
24958: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
24959: LD_INT 0
24961: PPUSH
24962: PPUSH
24963: PPUSH
24964: PPUSH
// pom := GetBase ( building ) ;
24965: LD_ADDR_VAR 0 3
24969: PUSH
24970: LD_VAR 0 1
24974: PPUSH
24975: CALL_OW 274
24979: ST_TO_ADDR
// if not pom then
24980: LD_VAR 0 3
24984: NOT
24985: IFFALSE 24989
// exit ;
24987: GO 25159
// btype := GetBType ( building ) ;
24989: LD_ADDR_VAR 0 5
24993: PUSH
24994: LD_VAR 0 1
24998: PPUSH
24999: CALL_OW 266
25003: ST_TO_ADDR
// if btype = b_armoury then
25004: LD_VAR 0 5
25008: PUSH
25009: LD_INT 4
25011: EQUAL
25012: IFFALSE 25022
// btype := b_barracks ;
25014: LD_ADDR_VAR 0 5
25018: PUSH
25019: LD_INT 5
25021: ST_TO_ADDR
// if btype = b_depot then
25022: LD_VAR 0 5
25026: PUSH
25027: LD_INT 0
25029: EQUAL
25030: IFFALSE 25040
// btype := b_warehouse ;
25032: LD_ADDR_VAR 0 5
25036: PUSH
25037: LD_INT 1
25039: ST_TO_ADDR
// if btype = b_workshop then
25040: LD_VAR 0 5
25044: PUSH
25045: LD_INT 2
25047: EQUAL
25048: IFFALSE 25058
// btype := b_factory ;
25050: LD_ADDR_VAR 0 5
25054: PUSH
25055: LD_INT 3
25057: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25058: LD_ADDR_VAR 0 4
25062: PUSH
25063: LD_VAR 0 5
25067: PPUSH
25068: LD_VAR 0 1
25072: PPUSH
25073: CALL_OW 248
25077: PPUSH
25078: CALL_OW 450
25082: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25083: LD_ADDR_VAR 0 2
25087: PUSH
25088: LD_VAR 0 3
25092: PPUSH
25093: LD_INT 1
25095: PPUSH
25096: CALL_OW 275
25100: PUSH
25101: LD_VAR 0 4
25105: PUSH
25106: LD_INT 1
25108: ARRAY
25109: GREATEREQUAL
25110: PUSH
25111: LD_VAR 0 3
25115: PPUSH
25116: LD_INT 2
25118: PPUSH
25119: CALL_OW 275
25123: PUSH
25124: LD_VAR 0 4
25128: PUSH
25129: LD_INT 2
25131: ARRAY
25132: GREATEREQUAL
25133: AND
25134: PUSH
25135: LD_VAR 0 3
25139: PPUSH
25140: LD_INT 3
25142: PPUSH
25143: CALL_OW 275
25147: PUSH
25148: LD_VAR 0 4
25152: PUSH
25153: LD_INT 3
25155: ARRAY
25156: GREATEREQUAL
25157: AND
25158: ST_TO_ADDR
// end ;
25159: LD_VAR 0 2
25163: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25164: LD_INT 0
25166: PPUSH
25167: PPUSH
25168: PPUSH
// pom := GetBase ( building ) ;
25169: LD_ADDR_VAR 0 4
25173: PUSH
25174: LD_VAR 0 1
25178: PPUSH
25179: CALL_OW 274
25183: ST_TO_ADDR
// if not pom then
25184: LD_VAR 0 4
25188: NOT
25189: IFFALSE 25193
// exit ;
25191: GO 25294
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25193: LD_ADDR_VAR 0 5
25197: PUSH
25198: LD_VAR 0 2
25202: PPUSH
25203: LD_VAR 0 1
25207: PPUSH
25208: CALL_OW 248
25212: PPUSH
25213: CALL_OW 450
25217: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25218: LD_ADDR_VAR 0 3
25222: PUSH
25223: LD_VAR 0 4
25227: PPUSH
25228: LD_INT 1
25230: PPUSH
25231: CALL_OW 275
25235: PUSH
25236: LD_VAR 0 5
25240: PUSH
25241: LD_INT 1
25243: ARRAY
25244: GREATEREQUAL
25245: PUSH
25246: LD_VAR 0 4
25250: PPUSH
25251: LD_INT 2
25253: PPUSH
25254: CALL_OW 275
25258: PUSH
25259: LD_VAR 0 5
25263: PUSH
25264: LD_INT 2
25266: ARRAY
25267: GREATEREQUAL
25268: AND
25269: PUSH
25270: LD_VAR 0 4
25274: PPUSH
25275: LD_INT 3
25277: PPUSH
25278: CALL_OW 275
25282: PUSH
25283: LD_VAR 0 5
25287: PUSH
25288: LD_INT 3
25290: ARRAY
25291: GREATEREQUAL
25292: AND
25293: ST_TO_ADDR
// end ;
25294: LD_VAR 0 3
25298: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
25299: LD_INT 0
25301: PPUSH
25302: PPUSH
25303: PPUSH
25304: PPUSH
25305: PPUSH
25306: PPUSH
25307: PPUSH
25308: PPUSH
25309: PPUSH
25310: PPUSH
// result := false ;
25311: LD_ADDR_VAR 0 6
25315: PUSH
25316: LD_INT 0
25318: ST_TO_ADDR
// if not base or not btype or not x or not y then
25319: LD_VAR 0 1
25323: NOT
25324: PUSH
25325: LD_VAR 0 2
25329: NOT
25330: OR
25331: PUSH
25332: LD_VAR 0 3
25336: NOT
25337: OR
25338: PUSH
25339: LD_VAR 0 4
25343: NOT
25344: OR
25345: IFFALSE 25349
// exit ;
25347: GO 25958
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
25349: LD_ADDR_VAR 0 12
25353: PUSH
25354: LD_VAR 0 2
25358: PPUSH
25359: LD_VAR 0 3
25363: PPUSH
25364: LD_VAR 0 4
25368: PPUSH
25369: LD_VAR 0 5
25373: PPUSH
25374: LD_VAR 0 1
25378: PUSH
25379: LD_INT 1
25381: ARRAY
25382: PPUSH
25383: CALL_OW 248
25387: PPUSH
25388: LD_INT 0
25390: PPUSH
25391: CALL 26795 0 6
25395: ST_TO_ADDR
// if not hexes then
25396: LD_VAR 0 12
25400: NOT
25401: IFFALSE 25405
// exit ;
25403: GO 25958
// for i = 1 to hexes do
25405: LD_ADDR_VAR 0 7
25409: PUSH
25410: DOUBLE
25411: LD_INT 1
25413: DEC
25414: ST_TO_ADDR
25415: LD_VAR 0 12
25419: PUSH
25420: FOR_TO
25421: IFFALSE 25956
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25423: LD_ADDR_VAR 0 11
25427: PUSH
25428: LD_VAR 0 12
25432: PUSH
25433: LD_VAR 0 7
25437: ARRAY
25438: PUSH
25439: LD_INT 1
25441: ARRAY
25442: PPUSH
25443: LD_VAR 0 12
25447: PUSH
25448: LD_VAR 0 7
25452: ARRAY
25453: PUSH
25454: LD_INT 2
25456: ARRAY
25457: PPUSH
25458: CALL_OW 428
25462: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25463: LD_VAR 0 12
25467: PUSH
25468: LD_VAR 0 7
25472: ARRAY
25473: PUSH
25474: LD_INT 1
25476: ARRAY
25477: PPUSH
25478: LD_VAR 0 12
25482: PUSH
25483: LD_VAR 0 7
25487: ARRAY
25488: PUSH
25489: LD_INT 2
25491: ARRAY
25492: PPUSH
25493: CALL_OW 351
25497: PUSH
25498: LD_VAR 0 12
25502: PUSH
25503: LD_VAR 0 7
25507: ARRAY
25508: PUSH
25509: LD_INT 1
25511: ARRAY
25512: PPUSH
25513: LD_VAR 0 12
25517: PUSH
25518: LD_VAR 0 7
25522: ARRAY
25523: PUSH
25524: LD_INT 2
25526: ARRAY
25527: PPUSH
25528: CALL_OW 488
25532: NOT
25533: OR
25534: PUSH
25535: LD_VAR 0 11
25539: PPUSH
25540: CALL_OW 247
25544: PUSH
25545: LD_INT 3
25547: EQUAL
25548: OR
25549: IFFALSE 25555
// exit ;
25551: POP
25552: POP
25553: GO 25958
// if not tmp or not tmp in base then
25555: LD_VAR 0 11
25559: NOT
25560: PUSH
25561: LD_VAR 0 11
25565: PUSH
25566: LD_VAR 0 1
25570: IN
25571: NOT
25572: OR
25573: IFFALSE 25577
// continue ;
25575: GO 25420
// result := true ;
25577: LD_ADDR_VAR 0 6
25581: PUSH
25582: LD_INT 1
25584: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25585: LD_ADDR_VAR 0 15
25589: PUSH
25590: LD_VAR 0 1
25594: PPUSH
25595: LD_INT 22
25597: PUSH
25598: LD_VAR 0 11
25602: PPUSH
25603: CALL_OW 255
25607: PUSH
25608: EMPTY
25609: LIST
25610: LIST
25611: PUSH
25612: LD_INT 2
25614: PUSH
25615: LD_INT 30
25617: PUSH
25618: LD_INT 0
25620: PUSH
25621: EMPTY
25622: LIST
25623: LIST
25624: PUSH
25625: LD_INT 30
25627: PUSH
25628: LD_INT 1
25630: PUSH
25631: EMPTY
25632: LIST
25633: LIST
25634: PUSH
25635: EMPTY
25636: LIST
25637: LIST
25638: LIST
25639: PUSH
25640: EMPTY
25641: LIST
25642: LIST
25643: PPUSH
25644: CALL_OW 72
25648: ST_TO_ADDR
// if dep then
25649: LD_VAR 0 15
25653: IFFALSE 25789
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
25655: LD_ADDR_VAR 0 14
25659: PUSH
25660: LD_VAR 0 15
25664: PUSH
25665: LD_INT 1
25667: ARRAY
25668: PPUSH
25669: CALL_OW 250
25673: PPUSH
25674: LD_VAR 0 15
25678: PUSH
25679: LD_INT 1
25681: ARRAY
25682: PPUSH
25683: CALL_OW 254
25687: PPUSH
25688: LD_INT 5
25690: PPUSH
25691: CALL_OW 272
25695: PUSH
25696: LD_VAR 0 15
25700: PUSH
25701: LD_INT 1
25703: ARRAY
25704: PPUSH
25705: CALL_OW 251
25709: PPUSH
25710: LD_VAR 0 15
25714: PUSH
25715: LD_INT 1
25717: ARRAY
25718: PPUSH
25719: CALL_OW 254
25723: PPUSH
25724: LD_INT 5
25726: PPUSH
25727: CALL_OW 273
25731: PUSH
25732: EMPTY
25733: LIST
25734: LIST
25735: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
25736: LD_VAR 0 14
25740: PUSH
25741: LD_INT 1
25743: ARRAY
25744: PPUSH
25745: LD_VAR 0 14
25749: PUSH
25750: LD_INT 2
25752: ARRAY
25753: PPUSH
25754: CALL_OW 488
25758: IFFALSE 25789
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
25760: LD_VAR 0 11
25764: PPUSH
25765: LD_VAR 0 14
25769: PUSH
25770: LD_INT 1
25772: ARRAY
25773: PPUSH
25774: LD_VAR 0 14
25778: PUSH
25779: LD_INT 2
25781: ARRAY
25782: PPUSH
25783: CALL_OW 111
// continue ;
25787: GO 25420
// end ; end ; r := GetDir ( tmp ) ;
25789: LD_ADDR_VAR 0 13
25793: PUSH
25794: LD_VAR 0 11
25798: PPUSH
25799: CALL_OW 254
25803: ST_TO_ADDR
// if r = 5 then
25804: LD_VAR 0 13
25808: PUSH
25809: LD_INT 5
25811: EQUAL
25812: IFFALSE 25822
// r := 0 ;
25814: LD_ADDR_VAR 0 13
25818: PUSH
25819: LD_INT 0
25821: ST_TO_ADDR
// for j = r to 5 do
25822: LD_ADDR_VAR 0 8
25826: PUSH
25827: DOUBLE
25828: LD_VAR 0 13
25832: DEC
25833: ST_TO_ADDR
25834: LD_INT 5
25836: PUSH
25837: FOR_TO
25838: IFFALSE 25952
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
25840: LD_ADDR_VAR 0 9
25844: PUSH
25845: LD_VAR 0 11
25849: PPUSH
25850: CALL_OW 250
25854: PPUSH
25855: LD_VAR 0 8
25859: PPUSH
25860: LD_INT 2
25862: PPUSH
25863: CALL_OW 272
25867: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
25868: LD_ADDR_VAR 0 10
25872: PUSH
25873: LD_VAR 0 11
25877: PPUSH
25878: CALL_OW 251
25882: PPUSH
25883: LD_VAR 0 8
25887: PPUSH
25888: LD_INT 2
25890: PPUSH
25891: CALL_OW 273
25895: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
25896: LD_VAR 0 9
25900: PPUSH
25901: LD_VAR 0 10
25905: PPUSH
25906: CALL_OW 488
25910: PUSH
25911: LD_VAR 0 9
25915: PPUSH
25916: LD_VAR 0 10
25920: PPUSH
25921: CALL_OW 428
25925: NOT
25926: AND
25927: IFFALSE 25950
// begin ComMoveXY ( tmp , _x , _y ) ;
25929: LD_VAR 0 11
25933: PPUSH
25934: LD_VAR 0 9
25938: PPUSH
25939: LD_VAR 0 10
25943: PPUSH
25944: CALL_OW 111
// break ;
25948: GO 25952
// end ; end ;
25950: GO 25837
25952: POP
25953: POP
// end ;
25954: GO 25420
25956: POP
25957: POP
// end ;
25958: LD_VAR 0 6
25962: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
25963: LD_INT 0
25965: PPUSH
25966: PPUSH
25967: PPUSH
25968: PPUSH
25969: PPUSH
25970: PPUSH
25971: PPUSH
25972: PPUSH
25973: PPUSH
25974: PPUSH
// result := false ;
25975: LD_ADDR_VAR 0 6
25979: PUSH
25980: LD_INT 0
25982: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
25983: LD_VAR 0 1
25987: NOT
25988: PUSH
25989: LD_VAR 0 1
25993: PPUSH
25994: CALL_OW 266
25998: PUSH
25999: LD_INT 0
26001: PUSH
26002: LD_INT 1
26004: PUSH
26005: EMPTY
26006: LIST
26007: LIST
26008: IN
26009: NOT
26010: OR
26011: PUSH
26012: LD_VAR 0 2
26016: NOT
26017: OR
26018: PUSH
26019: LD_VAR 0 5
26023: PUSH
26024: LD_INT 0
26026: PUSH
26027: LD_INT 1
26029: PUSH
26030: LD_INT 2
26032: PUSH
26033: LD_INT 3
26035: PUSH
26036: LD_INT 4
26038: PUSH
26039: LD_INT 5
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: LIST
26046: LIST
26047: LIST
26048: LIST
26049: IN
26050: NOT
26051: OR
26052: PUSH
26053: LD_VAR 0 3
26057: PPUSH
26058: LD_VAR 0 4
26062: PPUSH
26063: CALL_OW 488
26067: NOT
26068: OR
26069: IFFALSE 26073
// exit ;
26071: GO 26790
// pom := GetBase ( depot ) ;
26073: LD_ADDR_VAR 0 10
26077: PUSH
26078: LD_VAR 0 1
26082: PPUSH
26083: CALL_OW 274
26087: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26088: LD_ADDR_VAR 0 11
26092: PUSH
26093: LD_VAR 0 2
26097: PPUSH
26098: LD_VAR 0 1
26102: PPUSH
26103: CALL_OW 248
26107: PPUSH
26108: CALL_OW 450
26112: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26113: LD_VAR 0 10
26117: PPUSH
26118: LD_INT 1
26120: PPUSH
26121: CALL_OW 275
26125: PUSH
26126: LD_VAR 0 11
26130: PUSH
26131: LD_INT 1
26133: ARRAY
26134: GREATEREQUAL
26135: PUSH
26136: LD_VAR 0 10
26140: PPUSH
26141: LD_INT 2
26143: PPUSH
26144: CALL_OW 275
26148: PUSH
26149: LD_VAR 0 11
26153: PUSH
26154: LD_INT 2
26156: ARRAY
26157: GREATEREQUAL
26158: AND
26159: PUSH
26160: LD_VAR 0 10
26164: PPUSH
26165: LD_INT 3
26167: PPUSH
26168: CALL_OW 275
26172: PUSH
26173: LD_VAR 0 11
26177: PUSH
26178: LD_INT 3
26180: ARRAY
26181: GREATEREQUAL
26182: AND
26183: NOT
26184: IFFALSE 26188
// exit ;
26186: GO 26790
// if GetBType ( depot ) = b_depot then
26188: LD_VAR 0 1
26192: PPUSH
26193: CALL_OW 266
26197: PUSH
26198: LD_INT 0
26200: EQUAL
26201: IFFALSE 26213
// dist := 28 else
26203: LD_ADDR_VAR 0 14
26207: PUSH
26208: LD_INT 28
26210: ST_TO_ADDR
26211: GO 26221
// dist := 36 ;
26213: LD_ADDR_VAR 0 14
26217: PUSH
26218: LD_INT 36
26220: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26221: LD_VAR 0 1
26225: PPUSH
26226: LD_VAR 0 3
26230: PPUSH
26231: LD_VAR 0 4
26235: PPUSH
26236: CALL_OW 297
26240: PUSH
26241: LD_VAR 0 14
26245: GREATER
26246: IFFALSE 26250
// exit ;
26248: GO 26790
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
26250: LD_ADDR_VAR 0 12
26254: PUSH
26255: LD_VAR 0 2
26259: PPUSH
26260: LD_VAR 0 3
26264: PPUSH
26265: LD_VAR 0 4
26269: PPUSH
26270: LD_VAR 0 5
26274: PPUSH
26275: LD_VAR 0 1
26279: PPUSH
26280: CALL_OW 248
26284: PPUSH
26285: LD_INT 0
26287: PPUSH
26288: CALL 26795 0 6
26292: ST_TO_ADDR
// if not hexes then
26293: LD_VAR 0 12
26297: NOT
26298: IFFALSE 26302
// exit ;
26300: GO 26790
// hex := GetHexInfo ( x , y ) ;
26302: LD_ADDR_VAR 0 15
26306: PUSH
26307: LD_VAR 0 3
26311: PPUSH
26312: LD_VAR 0 4
26316: PPUSH
26317: CALL_OW 546
26321: ST_TO_ADDR
// if hex [ 1 ] then
26322: LD_VAR 0 15
26326: PUSH
26327: LD_INT 1
26329: ARRAY
26330: IFFALSE 26334
// exit ;
26332: GO 26790
// height := hex [ 2 ] ;
26334: LD_ADDR_VAR 0 13
26338: PUSH
26339: LD_VAR 0 15
26343: PUSH
26344: LD_INT 2
26346: ARRAY
26347: ST_TO_ADDR
// for i = 1 to hexes do
26348: LD_ADDR_VAR 0 7
26352: PUSH
26353: DOUBLE
26354: LD_INT 1
26356: DEC
26357: ST_TO_ADDR
26358: LD_VAR 0 12
26362: PUSH
26363: FOR_TO
26364: IFFALSE 26694
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
26366: LD_VAR 0 12
26370: PUSH
26371: LD_VAR 0 7
26375: ARRAY
26376: PUSH
26377: LD_INT 1
26379: ARRAY
26380: PPUSH
26381: LD_VAR 0 12
26385: PUSH
26386: LD_VAR 0 7
26390: ARRAY
26391: PUSH
26392: LD_INT 2
26394: ARRAY
26395: PPUSH
26396: CALL_OW 488
26400: NOT
26401: PUSH
26402: LD_VAR 0 12
26406: PUSH
26407: LD_VAR 0 7
26411: ARRAY
26412: PUSH
26413: LD_INT 1
26415: ARRAY
26416: PPUSH
26417: LD_VAR 0 12
26421: PUSH
26422: LD_VAR 0 7
26426: ARRAY
26427: PUSH
26428: LD_INT 2
26430: ARRAY
26431: PPUSH
26432: CALL_OW 428
26436: PUSH
26437: LD_INT 0
26439: GREATER
26440: OR
26441: PUSH
26442: LD_VAR 0 12
26446: PUSH
26447: LD_VAR 0 7
26451: ARRAY
26452: PUSH
26453: LD_INT 1
26455: ARRAY
26456: PPUSH
26457: LD_VAR 0 12
26461: PUSH
26462: LD_VAR 0 7
26466: ARRAY
26467: PUSH
26468: LD_INT 2
26470: ARRAY
26471: PPUSH
26472: CALL_OW 351
26476: OR
26477: IFFALSE 26483
// exit ;
26479: POP
26480: POP
26481: GO 26790
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26483: LD_ADDR_VAR 0 8
26487: PUSH
26488: LD_VAR 0 12
26492: PUSH
26493: LD_VAR 0 7
26497: ARRAY
26498: PUSH
26499: LD_INT 1
26501: ARRAY
26502: PPUSH
26503: LD_VAR 0 12
26507: PUSH
26508: LD_VAR 0 7
26512: ARRAY
26513: PUSH
26514: LD_INT 2
26516: ARRAY
26517: PPUSH
26518: CALL_OW 546
26522: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
26523: LD_VAR 0 8
26527: PUSH
26528: LD_INT 1
26530: ARRAY
26531: PUSH
26532: LD_VAR 0 8
26536: PUSH
26537: LD_INT 2
26539: ARRAY
26540: PUSH
26541: LD_VAR 0 13
26545: PUSH
26546: LD_INT 2
26548: PLUS
26549: GREATER
26550: OR
26551: PUSH
26552: LD_VAR 0 8
26556: PUSH
26557: LD_INT 2
26559: ARRAY
26560: PUSH
26561: LD_VAR 0 13
26565: PUSH
26566: LD_INT 2
26568: MINUS
26569: LESS
26570: OR
26571: PUSH
26572: LD_VAR 0 8
26576: PUSH
26577: LD_INT 3
26579: ARRAY
26580: PUSH
26581: LD_INT 0
26583: PUSH
26584: LD_INT 8
26586: PUSH
26587: LD_INT 9
26589: PUSH
26590: LD_INT 10
26592: PUSH
26593: LD_INT 11
26595: PUSH
26596: LD_INT 12
26598: PUSH
26599: LD_INT 13
26601: PUSH
26602: LD_INT 16
26604: PUSH
26605: LD_INT 17
26607: PUSH
26608: LD_INT 18
26610: PUSH
26611: LD_INT 19
26613: PUSH
26614: LD_INT 20
26616: PUSH
26617: LD_INT 21
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: LIST
26624: LIST
26625: LIST
26626: LIST
26627: LIST
26628: LIST
26629: LIST
26630: LIST
26631: LIST
26632: LIST
26633: LIST
26634: IN
26635: NOT
26636: OR
26637: PUSH
26638: LD_VAR 0 8
26642: PUSH
26643: LD_INT 5
26645: ARRAY
26646: NOT
26647: OR
26648: PUSH
26649: LD_VAR 0 8
26653: PUSH
26654: LD_INT 6
26656: ARRAY
26657: PUSH
26658: LD_INT 1
26660: PUSH
26661: LD_INT 2
26663: PUSH
26664: LD_INT 7
26666: PUSH
26667: LD_INT 9
26669: PUSH
26670: LD_INT 10
26672: PUSH
26673: LD_INT 11
26675: PUSH
26676: EMPTY
26677: LIST
26678: LIST
26679: LIST
26680: LIST
26681: LIST
26682: LIST
26683: IN
26684: NOT
26685: OR
26686: IFFALSE 26692
// exit ;
26688: POP
26689: POP
26690: GO 26790
// end ;
26692: GO 26363
26694: POP
26695: POP
// side := GetSide ( depot ) ;
26696: LD_ADDR_VAR 0 9
26700: PUSH
26701: LD_VAR 0 1
26705: PPUSH
26706: CALL_OW 255
26710: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
26711: LD_VAR 0 9
26715: PPUSH
26716: LD_VAR 0 3
26720: PPUSH
26721: LD_VAR 0 4
26725: PPUSH
26726: LD_INT 20
26728: PPUSH
26729: CALL 19444 0 4
26733: PUSH
26734: LD_INT 4
26736: ARRAY
26737: IFFALSE 26741
// exit ;
26739: GO 26790
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
26741: LD_VAR 0 2
26745: PUSH
26746: LD_INT 29
26748: PUSH
26749: LD_INT 30
26751: PUSH
26752: EMPTY
26753: LIST
26754: LIST
26755: IN
26756: PUSH
26757: LD_VAR 0 3
26761: PPUSH
26762: LD_VAR 0 4
26766: PPUSH
26767: LD_VAR 0 9
26771: PPUSH
26772: CALL_OW 440
26776: NOT
26777: AND
26778: IFFALSE 26782
// exit ;
26780: GO 26790
// result := true ;
26782: LD_ADDR_VAR 0 6
26786: PUSH
26787: LD_INT 1
26789: ST_TO_ADDR
// end ;
26790: LD_VAR 0 6
26794: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
26795: LD_INT 0
26797: PPUSH
26798: PPUSH
26799: PPUSH
26800: PPUSH
26801: PPUSH
26802: PPUSH
26803: PPUSH
26804: PPUSH
26805: PPUSH
26806: PPUSH
26807: PPUSH
26808: PPUSH
26809: PPUSH
26810: PPUSH
26811: PPUSH
26812: PPUSH
26813: PPUSH
26814: PPUSH
26815: PPUSH
26816: PPUSH
26817: PPUSH
26818: PPUSH
26819: PPUSH
26820: PPUSH
26821: PPUSH
26822: PPUSH
26823: PPUSH
26824: PPUSH
26825: PPUSH
26826: PPUSH
26827: PPUSH
26828: PPUSH
26829: PPUSH
26830: PPUSH
26831: PPUSH
26832: PPUSH
26833: PPUSH
26834: PPUSH
26835: PPUSH
26836: PPUSH
26837: PPUSH
26838: PPUSH
26839: PPUSH
26840: PPUSH
26841: PPUSH
26842: PPUSH
26843: PPUSH
26844: PPUSH
26845: PPUSH
26846: PPUSH
26847: PPUSH
26848: PPUSH
26849: PPUSH
26850: PPUSH
26851: PPUSH
26852: PPUSH
26853: PPUSH
26854: PPUSH
// result = [ ] ;
26855: LD_ADDR_VAR 0 7
26859: PUSH
26860: EMPTY
26861: ST_TO_ADDR
// temp_list = [ ] ;
26862: LD_ADDR_VAR 0 9
26866: PUSH
26867: EMPTY
26868: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
26869: LD_VAR 0 4
26873: PUSH
26874: LD_INT 0
26876: PUSH
26877: LD_INT 1
26879: PUSH
26880: LD_INT 2
26882: PUSH
26883: LD_INT 3
26885: PUSH
26886: LD_INT 4
26888: PUSH
26889: LD_INT 5
26891: PUSH
26892: EMPTY
26893: LIST
26894: LIST
26895: LIST
26896: LIST
26897: LIST
26898: LIST
26899: IN
26900: NOT
26901: PUSH
26902: LD_VAR 0 1
26906: PUSH
26907: LD_INT 0
26909: PUSH
26910: LD_INT 1
26912: PUSH
26913: EMPTY
26914: LIST
26915: LIST
26916: IN
26917: PUSH
26918: LD_VAR 0 5
26922: PUSH
26923: LD_INT 1
26925: PUSH
26926: LD_INT 2
26928: PUSH
26929: LD_INT 3
26931: PUSH
26932: EMPTY
26933: LIST
26934: LIST
26935: LIST
26936: IN
26937: NOT
26938: AND
26939: OR
26940: IFFALSE 26944
// exit ;
26942: GO 45335
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
26944: LD_VAR 0 1
26948: PUSH
26949: LD_INT 6
26951: PUSH
26952: LD_INT 7
26954: PUSH
26955: LD_INT 8
26957: PUSH
26958: LD_INT 13
26960: PUSH
26961: LD_INT 12
26963: PUSH
26964: LD_INT 15
26966: PUSH
26967: LD_INT 11
26969: PUSH
26970: LD_INT 14
26972: PUSH
26973: LD_INT 10
26975: PUSH
26976: EMPTY
26977: LIST
26978: LIST
26979: LIST
26980: LIST
26981: LIST
26982: LIST
26983: LIST
26984: LIST
26985: LIST
26986: IN
26987: IFFALSE 26997
// btype = b_lab ;
26989: LD_ADDR_VAR 0 1
26993: PUSH
26994: LD_INT 6
26996: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
26997: LD_VAR 0 6
27001: PUSH
27002: LD_INT 0
27004: PUSH
27005: LD_INT 1
27007: PUSH
27008: LD_INT 2
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: LIST
27015: IN
27016: NOT
27017: PUSH
27018: LD_VAR 0 1
27022: PUSH
27023: LD_INT 0
27025: PUSH
27026: LD_INT 1
27028: PUSH
27029: LD_INT 2
27031: PUSH
27032: LD_INT 3
27034: PUSH
27035: LD_INT 6
27037: PUSH
27038: LD_INT 36
27040: PUSH
27041: LD_INT 4
27043: PUSH
27044: LD_INT 5
27046: PUSH
27047: LD_INT 31
27049: PUSH
27050: LD_INT 32
27052: PUSH
27053: LD_INT 33
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: LIST
27060: LIST
27061: LIST
27062: LIST
27063: LIST
27064: LIST
27065: LIST
27066: LIST
27067: LIST
27068: IN
27069: NOT
27070: PUSH
27071: LD_VAR 0 6
27075: PUSH
27076: LD_INT 1
27078: EQUAL
27079: AND
27080: OR
27081: PUSH
27082: LD_VAR 0 1
27086: PUSH
27087: LD_INT 2
27089: PUSH
27090: LD_INT 3
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: IN
27097: NOT
27098: PUSH
27099: LD_VAR 0 6
27103: PUSH
27104: LD_INT 2
27106: EQUAL
27107: AND
27108: OR
27109: IFFALSE 27119
// mode = 0 ;
27111: LD_ADDR_VAR 0 6
27115: PUSH
27116: LD_INT 0
27118: ST_TO_ADDR
// case mode of 0 :
27119: LD_VAR 0 6
27123: PUSH
27124: LD_INT 0
27126: DOUBLE
27127: EQUAL
27128: IFTRUE 27132
27130: GO 38585
27132: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27133: LD_ADDR_VAR 0 11
27137: PUSH
27138: LD_INT 0
27140: PUSH
27141: LD_INT 0
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PUSH
27148: LD_INT 0
27150: PUSH
27151: LD_INT 1
27153: NEG
27154: PUSH
27155: EMPTY
27156: LIST
27157: LIST
27158: PUSH
27159: LD_INT 1
27161: PUSH
27162: LD_INT 0
27164: PUSH
27165: EMPTY
27166: LIST
27167: LIST
27168: PUSH
27169: LD_INT 1
27171: PUSH
27172: LD_INT 1
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: PUSH
27179: LD_INT 0
27181: PUSH
27182: LD_INT 1
27184: PUSH
27185: EMPTY
27186: LIST
27187: LIST
27188: PUSH
27189: LD_INT 1
27191: NEG
27192: PUSH
27193: LD_INT 0
27195: PUSH
27196: EMPTY
27197: LIST
27198: LIST
27199: PUSH
27200: LD_INT 1
27202: NEG
27203: PUSH
27204: LD_INT 1
27206: NEG
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: PUSH
27212: LD_INT 1
27214: NEG
27215: PUSH
27216: LD_INT 2
27218: NEG
27219: PUSH
27220: EMPTY
27221: LIST
27222: LIST
27223: PUSH
27224: LD_INT 0
27226: PUSH
27227: LD_INT 2
27229: NEG
27230: PUSH
27231: EMPTY
27232: LIST
27233: LIST
27234: PUSH
27235: LD_INT 1
27237: PUSH
27238: LD_INT 1
27240: NEG
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: PUSH
27246: LD_INT 1
27248: PUSH
27249: LD_INT 2
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: PUSH
27256: LD_INT 0
27258: PUSH
27259: LD_INT 2
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: PUSH
27266: LD_INT 1
27268: NEG
27269: PUSH
27270: LD_INT 1
27272: PUSH
27273: EMPTY
27274: LIST
27275: LIST
27276: PUSH
27277: LD_INT 1
27279: PUSH
27280: LD_INT 3
27282: PUSH
27283: EMPTY
27284: LIST
27285: LIST
27286: PUSH
27287: LD_INT 0
27289: PUSH
27290: LD_INT 3
27292: PUSH
27293: EMPTY
27294: LIST
27295: LIST
27296: PUSH
27297: LD_INT 1
27299: NEG
27300: PUSH
27301: LD_INT 2
27303: PUSH
27304: EMPTY
27305: LIST
27306: LIST
27307: PUSH
27308: EMPTY
27309: LIST
27310: LIST
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: LIST
27317: LIST
27318: LIST
27319: LIST
27320: LIST
27321: LIST
27322: LIST
27323: LIST
27324: LIST
27325: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
27326: LD_ADDR_VAR 0 12
27330: PUSH
27331: LD_INT 0
27333: PUSH
27334: LD_INT 0
27336: PUSH
27337: EMPTY
27338: LIST
27339: LIST
27340: PUSH
27341: LD_INT 0
27343: PUSH
27344: LD_INT 1
27346: NEG
27347: PUSH
27348: EMPTY
27349: LIST
27350: LIST
27351: PUSH
27352: LD_INT 1
27354: PUSH
27355: LD_INT 0
27357: PUSH
27358: EMPTY
27359: LIST
27360: LIST
27361: PUSH
27362: LD_INT 1
27364: PUSH
27365: LD_INT 1
27367: PUSH
27368: EMPTY
27369: LIST
27370: LIST
27371: PUSH
27372: LD_INT 0
27374: PUSH
27375: LD_INT 1
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: PUSH
27382: LD_INT 1
27384: NEG
27385: PUSH
27386: LD_INT 0
27388: PUSH
27389: EMPTY
27390: LIST
27391: LIST
27392: PUSH
27393: LD_INT 1
27395: NEG
27396: PUSH
27397: LD_INT 1
27399: NEG
27400: PUSH
27401: EMPTY
27402: LIST
27403: LIST
27404: PUSH
27405: LD_INT 1
27407: PUSH
27408: LD_INT 1
27410: NEG
27411: PUSH
27412: EMPTY
27413: LIST
27414: LIST
27415: PUSH
27416: LD_INT 2
27418: PUSH
27419: LD_INT 0
27421: PUSH
27422: EMPTY
27423: LIST
27424: LIST
27425: PUSH
27426: LD_INT 2
27428: PUSH
27429: LD_INT 1
27431: PUSH
27432: EMPTY
27433: LIST
27434: LIST
27435: PUSH
27436: LD_INT 1
27438: NEG
27439: PUSH
27440: LD_INT 1
27442: PUSH
27443: EMPTY
27444: LIST
27445: LIST
27446: PUSH
27447: LD_INT 2
27449: NEG
27450: PUSH
27451: LD_INT 0
27453: PUSH
27454: EMPTY
27455: LIST
27456: LIST
27457: PUSH
27458: LD_INT 2
27460: NEG
27461: PUSH
27462: LD_INT 1
27464: NEG
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: LD_INT 2
27472: NEG
27473: PUSH
27474: LD_INT 1
27476: PUSH
27477: EMPTY
27478: LIST
27479: LIST
27480: PUSH
27481: LD_INT 3
27483: NEG
27484: PUSH
27485: LD_INT 0
27487: PUSH
27488: EMPTY
27489: LIST
27490: LIST
27491: PUSH
27492: LD_INT 3
27494: NEG
27495: PUSH
27496: LD_INT 1
27498: NEG
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: EMPTY
27505: LIST
27506: LIST
27507: LIST
27508: LIST
27509: LIST
27510: LIST
27511: LIST
27512: LIST
27513: LIST
27514: LIST
27515: LIST
27516: LIST
27517: LIST
27518: LIST
27519: LIST
27520: LIST
27521: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
27522: LD_ADDR_VAR 0 13
27526: PUSH
27527: LD_INT 0
27529: PUSH
27530: LD_INT 0
27532: PUSH
27533: EMPTY
27534: LIST
27535: LIST
27536: PUSH
27537: LD_INT 0
27539: PUSH
27540: LD_INT 1
27542: NEG
27543: PUSH
27544: EMPTY
27545: LIST
27546: LIST
27547: PUSH
27548: LD_INT 1
27550: PUSH
27551: LD_INT 0
27553: PUSH
27554: EMPTY
27555: LIST
27556: LIST
27557: PUSH
27558: LD_INT 1
27560: PUSH
27561: LD_INT 1
27563: PUSH
27564: EMPTY
27565: LIST
27566: LIST
27567: PUSH
27568: LD_INT 0
27570: PUSH
27571: LD_INT 1
27573: PUSH
27574: EMPTY
27575: LIST
27576: LIST
27577: PUSH
27578: LD_INT 1
27580: NEG
27581: PUSH
27582: LD_INT 0
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 1
27591: NEG
27592: PUSH
27593: LD_INT 1
27595: NEG
27596: PUSH
27597: EMPTY
27598: LIST
27599: LIST
27600: PUSH
27601: LD_INT 1
27603: NEG
27604: PUSH
27605: LD_INT 2
27607: NEG
27608: PUSH
27609: EMPTY
27610: LIST
27611: LIST
27612: PUSH
27613: LD_INT 2
27615: PUSH
27616: LD_INT 1
27618: PUSH
27619: EMPTY
27620: LIST
27621: LIST
27622: PUSH
27623: LD_INT 2
27625: PUSH
27626: LD_INT 2
27628: PUSH
27629: EMPTY
27630: LIST
27631: LIST
27632: PUSH
27633: LD_INT 1
27635: PUSH
27636: LD_INT 2
27638: PUSH
27639: EMPTY
27640: LIST
27641: LIST
27642: PUSH
27643: LD_INT 2
27645: NEG
27646: PUSH
27647: LD_INT 1
27649: NEG
27650: PUSH
27651: EMPTY
27652: LIST
27653: LIST
27654: PUSH
27655: LD_INT 2
27657: NEG
27658: PUSH
27659: LD_INT 2
27661: NEG
27662: PUSH
27663: EMPTY
27664: LIST
27665: LIST
27666: PUSH
27667: LD_INT 2
27669: NEG
27670: PUSH
27671: LD_INT 3
27673: NEG
27674: PUSH
27675: EMPTY
27676: LIST
27677: LIST
27678: PUSH
27679: LD_INT 3
27681: NEG
27682: PUSH
27683: LD_INT 2
27685: NEG
27686: PUSH
27687: EMPTY
27688: LIST
27689: LIST
27690: PUSH
27691: LD_INT 3
27693: NEG
27694: PUSH
27695: LD_INT 3
27697: NEG
27698: PUSH
27699: EMPTY
27700: LIST
27701: LIST
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: LIST
27707: LIST
27708: LIST
27709: LIST
27710: LIST
27711: LIST
27712: LIST
27713: LIST
27714: LIST
27715: LIST
27716: LIST
27717: LIST
27718: LIST
27719: LIST
27720: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
27721: LD_ADDR_VAR 0 14
27725: PUSH
27726: LD_INT 0
27728: PUSH
27729: LD_INT 0
27731: PUSH
27732: EMPTY
27733: LIST
27734: LIST
27735: PUSH
27736: LD_INT 0
27738: PUSH
27739: LD_INT 1
27741: NEG
27742: PUSH
27743: EMPTY
27744: LIST
27745: LIST
27746: PUSH
27747: LD_INT 1
27749: PUSH
27750: LD_INT 0
27752: PUSH
27753: EMPTY
27754: LIST
27755: LIST
27756: PUSH
27757: LD_INT 1
27759: PUSH
27760: LD_INT 1
27762: PUSH
27763: EMPTY
27764: LIST
27765: LIST
27766: PUSH
27767: LD_INT 0
27769: PUSH
27770: LD_INT 1
27772: PUSH
27773: EMPTY
27774: LIST
27775: LIST
27776: PUSH
27777: LD_INT 1
27779: NEG
27780: PUSH
27781: LD_INT 0
27783: PUSH
27784: EMPTY
27785: LIST
27786: LIST
27787: PUSH
27788: LD_INT 1
27790: NEG
27791: PUSH
27792: LD_INT 1
27794: NEG
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: LD_INT 1
27802: NEG
27803: PUSH
27804: LD_INT 2
27806: NEG
27807: PUSH
27808: EMPTY
27809: LIST
27810: LIST
27811: PUSH
27812: LD_INT 0
27814: PUSH
27815: LD_INT 2
27817: NEG
27818: PUSH
27819: EMPTY
27820: LIST
27821: LIST
27822: PUSH
27823: LD_INT 1
27825: PUSH
27826: LD_INT 1
27828: NEG
27829: PUSH
27830: EMPTY
27831: LIST
27832: LIST
27833: PUSH
27834: LD_INT 1
27836: PUSH
27837: LD_INT 2
27839: PUSH
27840: EMPTY
27841: LIST
27842: LIST
27843: PUSH
27844: LD_INT 0
27846: PUSH
27847: LD_INT 2
27849: PUSH
27850: EMPTY
27851: LIST
27852: LIST
27853: PUSH
27854: LD_INT 1
27856: NEG
27857: PUSH
27858: LD_INT 1
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: PUSH
27865: LD_INT 1
27867: NEG
27868: PUSH
27869: LD_INT 3
27871: NEG
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PUSH
27877: LD_INT 0
27879: PUSH
27880: LD_INT 3
27882: NEG
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: LD_INT 1
27890: PUSH
27891: LD_INT 2
27893: NEG
27894: PUSH
27895: EMPTY
27896: LIST
27897: LIST
27898: PUSH
27899: EMPTY
27900: LIST
27901: LIST
27902: LIST
27903: LIST
27904: LIST
27905: LIST
27906: LIST
27907: LIST
27908: LIST
27909: LIST
27910: LIST
27911: LIST
27912: LIST
27913: LIST
27914: LIST
27915: LIST
27916: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
27917: LD_ADDR_VAR 0 15
27921: PUSH
27922: LD_INT 0
27924: PUSH
27925: LD_INT 0
27927: PUSH
27928: EMPTY
27929: LIST
27930: LIST
27931: PUSH
27932: LD_INT 0
27934: PUSH
27935: LD_INT 1
27937: NEG
27938: PUSH
27939: EMPTY
27940: LIST
27941: LIST
27942: PUSH
27943: LD_INT 1
27945: PUSH
27946: LD_INT 0
27948: PUSH
27949: EMPTY
27950: LIST
27951: LIST
27952: PUSH
27953: LD_INT 1
27955: PUSH
27956: LD_INT 1
27958: PUSH
27959: EMPTY
27960: LIST
27961: LIST
27962: PUSH
27963: LD_INT 0
27965: PUSH
27966: LD_INT 1
27968: PUSH
27969: EMPTY
27970: LIST
27971: LIST
27972: PUSH
27973: LD_INT 1
27975: NEG
27976: PUSH
27977: LD_INT 0
27979: PUSH
27980: EMPTY
27981: LIST
27982: LIST
27983: PUSH
27984: LD_INT 1
27986: NEG
27987: PUSH
27988: LD_INT 1
27990: NEG
27991: PUSH
27992: EMPTY
27993: LIST
27994: LIST
27995: PUSH
27996: LD_INT 1
27998: PUSH
27999: LD_INT 1
28001: NEG
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: PUSH
28007: LD_INT 2
28009: PUSH
28010: LD_INT 0
28012: PUSH
28013: EMPTY
28014: LIST
28015: LIST
28016: PUSH
28017: LD_INT 2
28019: PUSH
28020: LD_INT 1
28022: PUSH
28023: EMPTY
28024: LIST
28025: LIST
28026: PUSH
28027: LD_INT 1
28029: NEG
28030: PUSH
28031: LD_INT 1
28033: PUSH
28034: EMPTY
28035: LIST
28036: LIST
28037: PUSH
28038: LD_INT 2
28040: NEG
28041: PUSH
28042: LD_INT 0
28044: PUSH
28045: EMPTY
28046: LIST
28047: LIST
28048: PUSH
28049: LD_INT 2
28051: NEG
28052: PUSH
28053: LD_INT 1
28055: NEG
28056: PUSH
28057: EMPTY
28058: LIST
28059: LIST
28060: PUSH
28061: LD_INT 2
28063: PUSH
28064: LD_INT 1
28066: NEG
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: PUSH
28072: LD_INT 3
28074: PUSH
28075: LD_INT 0
28077: PUSH
28078: EMPTY
28079: LIST
28080: LIST
28081: PUSH
28082: LD_INT 3
28084: PUSH
28085: LD_INT 1
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: PUSH
28092: EMPTY
28093: LIST
28094: LIST
28095: LIST
28096: LIST
28097: LIST
28098: LIST
28099: LIST
28100: LIST
28101: LIST
28102: LIST
28103: LIST
28104: LIST
28105: LIST
28106: LIST
28107: LIST
28108: LIST
28109: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28110: LD_ADDR_VAR 0 16
28114: PUSH
28115: LD_INT 0
28117: PUSH
28118: LD_INT 0
28120: PUSH
28121: EMPTY
28122: LIST
28123: LIST
28124: PUSH
28125: LD_INT 0
28127: PUSH
28128: LD_INT 1
28130: NEG
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: LD_INT 1
28138: PUSH
28139: LD_INT 0
28141: PUSH
28142: EMPTY
28143: LIST
28144: LIST
28145: PUSH
28146: LD_INT 1
28148: PUSH
28149: LD_INT 1
28151: PUSH
28152: EMPTY
28153: LIST
28154: LIST
28155: PUSH
28156: LD_INT 0
28158: PUSH
28159: LD_INT 1
28161: PUSH
28162: EMPTY
28163: LIST
28164: LIST
28165: PUSH
28166: LD_INT 1
28168: NEG
28169: PUSH
28170: LD_INT 0
28172: PUSH
28173: EMPTY
28174: LIST
28175: LIST
28176: PUSH
28177: LD_INT 1
28179: NEG
28180: PUSH
28181: LD_INT 1
28183: NEG
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PUSH
28189: LD_INT 1
28191: NEG
28192: PUSH
28193: LD_INT 2
28195: NEG
28196: PUSH
28197: EMPTY
28198: LIST
28199: LIST
28200: PUSH
28201: LD_INT 2
28203: PUSH
28204: LD_INT 1
28206: PUSH
28207: EMPTY
28208: LIST
28209: LIST
28210: PUSH
28211: LD_INT 2
28213: PUSH
28214: LD_INT 2
28216: PUSH
28217: EMPTY
28218: LIST
28219: LIST
28220: PUSH
28221: LD_INT 1
28223: PUSH
28224: LD_INT 2
28226: PUSH
28227: EMPTY
28228: LIST
28229: LIST
28230: PUSH
28231: LD_INT 2
28233: NEG
28234: PUSH
28235: LD_INT 1
28237: NEG
28238: PUSH
28239: EMPTY
28240: LIST
28241: LIST
28242: PUSH
28243: LD_INT 2
28245: NEG
28246: PUSH
28247: LD_INT 2
28249: NEG
28250: PUSH
28251: EMPTY
28252: LIST
28253: LIST
28254: PUSH
28255: LD_INT 3
28257: PUSH
28258: LD_INT 2
28260: PUSH
28261: EMPTY
28262: LIST
28263: LIST
28264: PUSH
28265: LD_INT 3
28267: PUSH
28268: LD_INT 3
28270: PUSH
28271: EMPTY
28272: LIST
28273: LIST
28274: PUSH
28275: LD_INT 2
28277: PUSH
28278: LD_INT 3
28280: PUSH
28281: EMPTY
28282: LIST
28283: LIST
28284: PUSH
28285: EMPTY
28286: LIST
28287: LIST
28288: LIST
28289: LIST
28290: LIST
28291: LIST
28292: LIST
28293: LIST
28294: LIST
28295: LIST
28296: LIST
28297: LIST
28298: LIST
28299: LIST
28300: LIST
28301: LIST
28302: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28303: LD_ADDR_VAR 0 17
28307: PUSH
28308: LD_INT 0
28310: PUSH
28311: LD_INT 0
28313: PUSH
28314: EMPTY
28315: LIST
28316: LIST
28317: PUSH
28318: LD_INT 0
28320: PUSH
28321: LD_INT 1
28323: NEG
28324: PUSH
28325: EMPTY
28326: LIST
28327: LIST
28328: PUSH
28329: LD_INT 1
28331: PUSH
28332: LD_INT 0
28334: PUSH
28335: EMPTY
28336: LIST
28337: LIST
28338: PUSH
28339: LD_INT 1
28341: PUSH
28342: LD_INT 1
28344: PUSH
28345: EMPTY
28346: LIST
28347: LIST
28348: PUSH
28349: LD_INT 0
28351: PUSH
28352: LD_INT 1
28354: PUSH
28355: EMPTY
28356: LIST
28357: LIST
28358: PUSH
28359: LD_INT 1
28361: NEG
28362: PUSH
28363: LD_INT 0
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: PUSH
28370: LD_INT 1
28372: NEG
28373: PUSH
28374: LD_INT 1
28376: NEG
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: LD_INT 1
28384: NEG
28385: PUSH
28386: LD_INT 2
28388: NEG
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PUSH
28394: LD_INT 0
28396: PUSH
28397: LD_INT 2
28399: NEG
28400: PUSH
28401: EMPTY
28402: LIST
28403: LIST
28404: PUSH
28405: LD_INT 1
28407: PUSH
28408: LD_INT 1
28410: NEG
28411: PUSH
28412: EMPTY
28413: LIST
28414: LIST
28415: PUSH
28416: LD_INT 2
28418: PUSH
28419: LD_INT 0
28421: PUSH
28422: EMPTY
28423: LIST
28424: LIST
28425: PUSH
28426: LD_INT 2
28428: PUSH
28429: LD_INT 1
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PUSH
28436: LD_INT 2
28438: PUSH
28439: LD_INT 2
28441: PUSH
28442: EMPTY
28443: LIST
28444: LIST
28445: PUSH
28446: LD_INT 1
28448: PUSH
28449: LD_INT 2
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: PUSH
28456: LD_INT 0
28458: PUSH
28459: LD_INT 2
28461: PUSH
28462: EMPTY
28463: LIST
28464: LIST
28465: PUSH
28466: LD_INT 1
28468: NEG
28469: PUSH
28470: LD_INT 1
28472: PUSH
28473: EMPTY
28474: LIST
28475: LIST
28476: PUSH
28477: LD_INT 2
28479: NEG
28480: PUSH
28481: LD_INT 0
28483: PUSH
28484: EMPTY
28485: LIST
28486: LIST
28487: PUSH
28488: LD_INT 2
28490: NEG
28491: PUSH
28492: LD_INT 1
28494: NEG
28495: PUSH
28496: EMPTY
28497: LIST
28498: LIST
28499: PUSH
28500: LD_INT 2
28502: NEG
28503: PUSH
28504: LD_INT 2
28506: NEG
28507: PUSH
28508: EMPTY
28509: LIST
28510: LIST
28511: PUSH
28512: EMPTY
28513: LIST
28514: LIST
28515: LIST
28516: LIST
28517: LIST
28518: LIST
28519: LIST
28520: LIST
28521: LIST
28522: LIST
28523: LIST
28524: LIST
28525: LIST
28526: LIST
28527: LIST
28528: LIST
28529: LIST
28530: LIST
28531: LIST
28532: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28533: LD_ADDR_VAR 0 18
28537: PUSH
28538: LD_INT 0
28540: PUSH
28541: LD_INT 0
28543: PUSH
28544: EMPTY
28545: LIST
28546: LIST
28547: PUSH
28548: LD_INT 0
28550: PUSH
28551: LD_INT 1
28553: NEG
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: PUSH
28559: LD_INT 1
28561: PUSH
28562: LD_INT 0
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: LD_INT 1
28571: PUSH
28572: LD_INT 1
28574: PUSH
28575: EMPTY
28576: LIST
28577: LIST
28578: PUSH
28579: LD_INT 0
28581: PUSH
28582: LD_INT 1
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: LD_INT 1
28591: NEG
28592: PUSH
28593: LD_INT 0
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: PUSH
28600: LD_INT 1
28602: NEG
28603: PUSH
28604: LD_INT 1
28606: NEG
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: PUSH
28612: LD_INT 1
28614: NEG
28615: PUSH
28616: LD_INT 2
28618: NEG
28619: PUSH
28620: EMPTY
28621: LIST
28622: LIST
28623: PUSH
28624: LD_INT 0
28626: PUSH
28627: LD_INT 2
28629: NEG
28630: PUSH
28631: EMPTY
28632: LIST
28633: LIST
28634: PUSH
28635: LD_INT 1
28637: PUSH
28638: LD_INT 1
28640: NEG
28641: PUSH
28642: EMPTY
28643: LIST
28644: LIST
28645: PUSH
28646: LD_INT 2
28648: PUSH
28649: LD_INT 0
28651: PUSH
28652: EMPTY
28653: LIST
28654: LIST
28655: PUSH
28656: LD_INT 2
28658: PUSH
28659: LD_INT 1
28661: PUSH
28662: EMPTY
28663: LIST
28664: LIST
28665: PUSH
28666: LD_INT 2
28668: PUSH
28669: LD_INT 2
28671: PUSH
28672: EMPTY
28673: LIST
28674: LIST
28675: PUSH
28676: LD_INT 1
28678: PUSH
28679: LD_INT 2
28681: PUSH
28682: EMPTY
28683: LIST
28684: LIST
28685: PUSH
28686: LD_INT 0
28688: PUSH
28689: LD_INT 2
28691: PUSH
28692: EMPTY
28693: LIST
28694: LIST
28695: PUSH
28696: LD_INT 1
28698: NEG
28699: PUSH
28700: LD_INT 1
28702: PUSH
28703: EMPTY
28704: LIST
28705: LIST
28706: PUSH
28707: LD_INT 2
28709: NEG
28710: PUSH
28711: LD_INT 0
28713: PUSH
28714: EMPTY
28715: LIST
28716: LIST
28717: PUSH
28718: LD_INT 2
28720: NEG
28721: PUSH
28722: LD_INT 1
28724: NEG
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: LD_INT 2
28732: NEG
28733: PUSH
28734: LD_INT 2
28736: NEG
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: EMPTY
28743: LIST
28744: LIST
28745: LIST
28746: LIST
28747: LIST
28748: LIST
28749: LIST
28750: LIST
28751: LIST
28752: LIST
28753: LIST
28754: LIST
28755: LIST
28756: LIST
28757: LIST
28758: LIST
28759: LIST
28760: LIST
28761: LIST
28762: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28763: LD_ADDR_VAR 0 19
28767: PUSH
28768: LD_INT 0
28770: PUSH
28771: LD_INT 0
28773: PUSH
28774: EMPTY
28775: LIST
28776: LIST
28777: PUSH
28778: LD_INT 0
28780: PUSH
28781: LD_INT 1
28783: NEG
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: PUSH
28789: LD_INT 1
28791: PUSH
28792: LD_INT 0
28794: PUSH
28795: EMPTY
28796: LIST
28797: LIST
28798: PUSH
28799: LD_INT 1
28801: PUSH
28802: LD_INT 1
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 0
28811: PUSH
28812: LD_INT 1
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: LD_INT 1
28821: NEG
28822: PUSH
28823: LD_INT 0
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: PUSH
28830: LD_INT 1
28832: NEG
28833: PUSH
28834: LD_INT 1
28836: NEG
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: PUSH
28842: LD_INT 1
28844: NEG
28845: PUSH
28846: LD_INT 2
28848: NEG
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: PUSH
28854: LD_INT 0
28856: PUSH
28857: LD_INT 2
28859: NEG
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PUSH
28865: LD_INT 1
28867: PUSH
28868: LD_INT 1
28870: NEG
28871: PUSH
28872: EMPTY
28873: LIST
28874: LIST
28875: PUSH
28876: LD_INT 2
28878: PUSH
28879: LD_INT 0
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: PUSH
28886: LD_INT 2
28888: PUSH
28889: LD_INT 1
28891: PUSH
28892: EMPTY
28893: LIST
28894: LIST
28895: PUSH
28896: LD_INT 2
28898: PUSH
28899: LD_INT 2
28901: PUSH
28902: EMPTY
28903: LIST
28904: LIST
28905: PUSH
28906: LD_INT 1
28908: PUSH
28909: LD_INT 2
28911: PUSH
28912: EMPTY
28913: LIST
28914: LIST
28915: PUSH
28916: LD_INT 0
28918: PUSH
28919: LD_INT 2
28921: PUSH
28922: EMPTY
28923: LIST
28924: LIST
28925: PUSH
28926: LD_INT 1
28928: NEG
28929: PUSH
28930: LD_INT 1
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: LD_INT 2
28939: NEG
28940: PUSH
28941: LD_INT 0
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: PUSH
28948: LD_INT 2
28950: NEG
28951: PUSH
28952: LD_INT 1
28954: NEG
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: LD_INT 2
28962: NEG
28963: PUSH
28964: LD_INT 2
28966: NEG
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: EMPTY
28973: LIST
28974: LIST
28975: LIST
28976: LIST
28977: LIST
28978: LIST
28979: LIST
28980: LIST
28981: LIST
28982: LIST
28983: LIST
28984: LIST
28985: LIST
28986: LIST
28987: LIST
28988: LIST
28989: LIST
28990: LIST
28991: LIST
28992: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28993: LD_ADDR_VAR 0 20
28997: PUSH
28998: LD_INT 0
29000: PUSH
29001: LD_INT 0
29003: PUSH
29004: EMPTY
29005: LIST
29006: LIST
29007: PUSH
29008: LD_INT 0
29010: PUSH
29011: LD_INT 1
29013: NEG
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: PUSH
29019: LD_INT 1
29021: PUSH
29022: LD_INT 0
29024: PUSH
29025: EMPTY
29026: LIST
29027: LIST
29028: PUSH
29029: LD_INT 1
29031: PUSH
29032: LD_INT 1
29034: PUSH
29035: EMPTY
29036: LIST
29037: LIST
29038: PUSH
29039: LD_INT 0
29041: PUSH
29042: LD_INT 1
29044: PUSH
29045: EMPTY
29046: LIST
29047: LIST
29048: PUSH
29049: LD_INT 1
29051: NEG
29052: PUSH
29053: LD_INT 0
29055: PUSH
29056: EMPTY
29057: LIST
29058: LIST
29059: PUSH
29060: LD_INT 1
29062: NEG
29063: PUSH
29064: LD_INT 1
29066: NEG
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 1
29074: NEG
29075: PUSH
29076: LD_INT 2
29078: NEG
29079: PUSH
29080: EMPTY
29081: LIST
29082: LIST
29083: PUSH
29084: LD_INT 0
29086: PUSH
29087: LD_INT 2
29089: NEG
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: LD_INT 1
29097: PUSH
29098: LD_INT 1
29100: NEG
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 2
29108: PUSH
29109: LD_INT 0
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: LD_INT 2
29118: PUSH
29119: LD_INT 1
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: PUSH
29126: LD_INT 2
29128: PUSH
29129: LD_INT 2
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: PUSH
29136: LD_INT 1
29138: PUSH
29139: LD_INT 2
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PUSH
29146: LD_INT 0
29148: PUSH
29149: LD_INT 2
29151: PUSH
29152: EMPTY
29153: LIST
29154: LIST
29155: PUSH
29156: LD_INT 1
29158: NEG
29159: PUSH
29160: LD_INT 1
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: LD_INT 2
29169: NEG
29170: PUSH
29171: LD_INT 0
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: PUSH
29178: LD_INT 2
29180: NEG
29181: PUSH
29182: LD_INT 1
29184: NEG
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 2
29192: NEG
29193: PUSH
29194: LD_INT 2
29196: NEG
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: LIST
29220: LIST
29221: LIST
29222: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29223: LD_ADDR_VAR 0 21
29227: PUSH
29228: LD_INT 0
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 0
29240: PUSH
29241: LD_INT 1
29243: NEG
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PUSH
29249: LD_INT 1
29251: PUSH
29252: LD_INT 0
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PUSH
29259: LD_INT 1
29261: PUSH
29262: LD_INT 1
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 0
29271: PUSH
29272: LD_INT 1
29274: PUSH
29275: EMPTY
29276: LIST
29277: LIST
29278: PUSH
29279: LD_INT 1
29281: NEG
29282: PUSH
29283: LD_INT 0
29285: PUSH
29286: EMPTY
29287: LIST
29288: LIST
29289: PUSH
29290: LD_INT 1
29292: NEG
29293: PUSH
29294: LD_INT 1
29296: NEG
29297: PUSH
29298: EMPTY
29299: LIST
29300: LIST
29301: PUSH
29302: LD_INT 1
29304: NEG
29305: PUSH
29306: LD_INT 2
29308: NEG
29309: PUSH
29310: EMPTY
29311: LIST
29312: LIST
29313: PUSH
29314: LD_INT 0
29316: PUSH
29317: LD_INT 2
29319: NEG
29320: PUSH
29321: EMPTY
29322: LIST
29323: LIST
29324: PUSH
29325: LD_INT 1
29327: PUSH
29328: LD_INT 1
29330: NEG
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 2
29338: PUSH
29339: LD_INT 0
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 2
29348: PUSH
29349: LD_INT 1
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 2
29358: PUSH
29359: LD_INT 2
29361: PUSH
29362: EMPTY
29363: LIST
29364: LIST
29365: PUSH
29366: LD_INT 1
29368: PUSH
29369: LD_INT 2
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 0
29378: PUSH
29379: LD_INT 2
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: PUSH
29386: LD_INT 1
29388: NEG
29389: PUSH
29390: LD_INT 1
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: LD_INT 2
29399: NEG
29400: PUSH
29401: LD_INT 0
29403: PUSH
29404: EMPTY
29405: LIST
29406: LIST
29407: PUSH
29408: LD_INT 2
29410: NEG
29411: PUSH
29412: LD_INT 1
29414: NEG
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 2
29422: NEG
29423: PUSH
29424: LD_INT 2
29426: NEG
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: LIST
29436: LIST
29437: LIST
29438: LIST
29439: LIST
29440: LIST
29441: LIST
29442: LIST
29443: LIST
29444: LIST
29445: LIST
29446: LIST
29447: LIST
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29453: LD_ADDR_VAR 0 22
29457: PUSH
29458: LD_INT 0
29460: PUSH
29461: LD_INT 0
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PUSH
29468: LD_INT 0
29470: PUSH
29471: LD_INT 1
29473: NEG
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 1
29481: PUSH
29482: LD_INT 0
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 1
29491: PUSH
29492: LD_INT 1
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 0
29501: PUSH
29502: LD_INT 1
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PUSH
29509: LD_INT 1
29511: NEG
29512: PUSH
29513: LD_INT 0
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: LD_INT 1
29522: NEG
29523: PUSH
29524: LD_INT 1
29526: NEG
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: LD_INT 1
29534: NEG
29535: PUSH
29536: LD_INT 2
29538: NEG
29539: PUSH
29540: EMPTY
29541: LIST
29542: LIST
29543: PUSH
29544: LD_INT 0
29546: PUSH
29547: LD_INT 2
29549: NEG
29550: PUSH
29551: EMPTY
29552: LIST
29553: LIST
29554: PUSH
29555: LD_INT 1
29557: PUSH
29558: LD_INT 1
29560: NEG
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 2
29568: PUSH
29569: LD_INT 0
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 2
29578: PUSH
29579: LD_INT 1
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 2
29588: PUSH
29589: LD_INT 2
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 1
29598: PUSH
29599: LD_INT 2
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: PUSH
29606: LD_INT 0
29608: PUSH
29609: LD_INT 2
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: LD_INT 1
29618: NEG
29619: PUSH
29620: LD_INT 1
29622: PUSH
29623: EMPTY
29624: LIST
29625: LIST
29626: PUSH
29627: LD_INT 2
29629: NEG
29630: PUSH
29631: LD_INT 0
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PUSH
29638: LD_INT 2
29640: NEG
29641: PUSH
29642: LD_INT 1
29644: NEG
29645: PUSH
29646: EMPTY
29647: LIST
29648: LIST
29649: PUSH
29650: LD_INT 2
29652: NEG
29653: PUSH
29654: LD_INT 2
29656: NEG
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: EMPTY
29663: LIST
29664: LIST
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: LIST
29670: LIST
29671: LIST
29672: LIST
29673: LIST
29674: LIST
29675: LIST
29676: LIST
29677: LIST
29678: LIST
29679: LIST
29680: LIST
29681: LIST
29682: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
29683: LD_ADDR_VAR 0 23
29687: PUSH
29688: LD_INT 0
29690: PUSH
29691: LD_INT 0
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: PUSH
29698: LD_INT 0
29700: PUSH
29701: LD_INT 1
29703: NEG
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 1
29711: PUSH
29712: LD_INT 0
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 1
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: LD_INT 0
29731: PUSH
29732: LD_INT 1
29734: PUSH
29735: EMPTY
29736: LIST
29737: LIST
29738: PUSH
29739: LD_INT 1
29741: NEG
29742: PUSH
29743: LD_INT 0
29745: PUSH
29746: EMPTY
29747: LIST
29748: LIST
29749: PUSH
29750: LD_INT 1
29752: NEG
29753: PUSH
29754: LD_INT 1
29756: NEG
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 1
29764: NEG
29765: PUSH
29766: LD_INT 2
29768: NEG
29769: PUSH
29770: EMPTY
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 0
29776: PUSH
29777: LD_INT 2
29779: NEG
29780: PUSH
29781: EMPTY
29782: LIST
29783: LIST
29784: PUSH
29785: LD_INT 1
29787: PUSH
29788: LD_INT 1
29790: NEG
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 2
29798: PUSH
29799: LD_INT 0
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 2
29808: PUSH
29809: LD_INT 1
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 2
29818: PUSH
29819: LD_INT 2
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 1
29828: PUSH
29829: LD_INT 2
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 0
29838: PUSH
29839: LD_INT 2
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PUSH
29846: LD_INT 1
29848: NEG
29849: PUSH
29850: LD_INT 1
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 2
29859: NEG
29860: PUSH
29861: LD_INT 0
29863: PUSH
29864: EMPTY
29865: LIST
29866: LIST
29867: PUSH
29868: LD_INT 2
29870: NEG
29871: PUSH
29872: LD_INT 1
29874: NEG
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: PUSH
29880: LD_INT 2
29882: NEG
29883: PUSH
29884: LD_INT 2
29886: NEG
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: LD_INT 2
29894: NEG
29895: PUSH
29896: LD_INT 3
29898: NEG
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 1
29906: NEG
29907: PUSH
29908: LD_INT 3
29910: NEG
29911: PUSH
29912: EMPTY
29913: LIST
29914: LIST
29915: PUSH
29916: LD_INT 1
29918: PUSH
29919: LD_INT 2
29921: NEG
29922: PUSH
29923: EMPTY
29924: LIST
29925: LIST
29926: PUSH
29927: LD_INT 2
29929: PUSH
29930: LD_INT 1
29932: NEG
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: PUSH
29938: EMPTY
29939: LIST
29940: LIST
29941: LIST
29942: LIST
29943: LIST
29944: LIST
29945: LIST
29946: LIST
29947: LIST
29948: LIST
29949: LIST
29950: LIST
29951: LIST
29952: LIST
29953: LIST
29954: LIST
29955: LIST
29956: LIST
29957: LIST
29958: LIST
29959: LIST
29960: LIST
29961: LIST
29962: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
29963: LD_ADDR_VAR 0 24
29967: PUSH
29968: LD_INT 0
29970: PUSH
29971: LD_INT 0
29973: PUSH
29974: EMPTY
29975: LIST
29976: LIST
29977: PUSH
29978: LD_INT 0
29980: PUSH
29981: LD_INT 1
29983: NEG
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: LD_INT 1
29991: PUSH
29992: LD_INT 0
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: PUSH
29999: LD_INT 1
30001: PUSH
30002: LD_INT 1
30004: PUSH
30005: EMPTY
30006: LIST
30007: LIST
30008: PUSH
30009: LD_INT 0
30011: PUSH
30012: LD_INT 1
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: PUSH
30019: LD_INT 1
30021: NEG
30022: PUSH
30023: LD_INT 0
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PUSH
30030: LD_INT 1
30032: NEG
30033: PUSH
30034: LD_INT 1
30036: NEG
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 1
30044: NEG
30045: PUSH
30046: LD_INT 2
30048: NEG
30049: PUSH
30050: EMPTY
30051: LIST
30052: LIST
30053: PUSH
30054: LD_INT 0
30056: PUSH
30057: LD_INT 2
30059: NEG
30060: PUSH
30061: EMPTY
30062: LIST
30063: LIST
30064: PUSH
30065: LD_INT 1
30067: PUSH
30068: LD_INT 1
30070: NEG
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 2
30078: PUSH
30079: LD_INT 0
30081: PUSH
30082: EMPTY
30083: LIST
30084: LIST
30085: PUSH
30086: LD_INT 2
30088: PUSH
30089: LD_INT 1
30091: PUSH
30092: EMPTY
30093: LIST
30094: LIST
30095: PUSH
30096: LD_INT 2
30098: PUSH
30099: LD_INT 2
30101: PUSH
30102: EMPTY
30103: LIST
30104: LIST
30105: PUSH
30106: LD_INT 1
30108: PUSH
30109: LD_INT 2
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: PUSH
30116: LD_INT 0
30118: PUSH
30119: LD_INT 2
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: PUSH
30126: LD_INT 1
30128: NEG
30129: PUSH
30130: LD_INT 1
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 2
30139: NEG
30140: PUSH
30141: LD_INT 0
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: LD_INT 2
30150: NEG
30151: PUSH
30152: LD_INT 1
30154: NEG
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 2
30162: NEG
30163: PUSH
30164: LD_INT 2
30166: NEG
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 1
30174: PUSH
30175: LD_INT 2
30177: NEG
30178: PUSH
30179: EMPTY
30180: LIST
30181: LIST
30182: PUSH
30183: LD_INT 2
30185: PUSH
30186: LD_INT 1
30188: NEG
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: LD_INT 3
30196: PUSH
30197: LD_INT 1
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 3
30206: PUSH
30207: LD_INT 2
30209: PUSH
30210: EMPTY
30211: LIST
30212: LIST
30213: PUSH
30214: EMPTY
30215: LIST
30216: LIST
30217: LIST
30218: LIST
30219: LIST
30220: LIST
30221: LIST
30222: LIST
30223: LIST
30224: LIST
30225: LIST
30226: LIST
30227: LIST
30228: LIST
30229: LIST
30230: LIST
30231: LIST
30232: LIST
30233: LIST
30234: LIST
30235: LIST
30236: LIST
30237: LIST
30238: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30239: LD_ADDR_VAR 0 25
30243: PUSH
30244: LD_INT 0
30246: PUSH
30247: LD_INT 0
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: LD_INT 0
30256: PUSH
30257: LD_INT 1
30259: NEG
30260: PUSH
30261: EMPTY
30262: LIST
30263: LIST
30264: PUSH
30265: LD_INT 1
30267: PUSH
30268: LD_INT 0
30270: PUSH
30271: EMPTY
30272: LIST
30273: LIST
30274: PUSH
30275: LD_INT 1
30277: PUSH
30278: LD_INT 1
30280: PUSH
30281: EMPTY
30282: LIST
30283: LIST
30284: PUSH
30285: LD_INT 0
30287: PUSH
30288: LD_INT 1
30290: PUSH
30291: EMPTY
30292: LIST
30293: LIST
30294: PUSH
30295: LD_INT 1
30297: NEG
30298: PUSH
30299: LD_INT 0
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PUSH
30306: LD_INT 1
30308: NEG
30309: PUSH
30310: LD_INT 1
30312: NEG
30313: PUSH
30314: EMPTY
30315: LIST
30316: LIST
30317: PUSH
30318: LD_INT 1
30320: NEG
30321: PUSH
30322: LD_INT 2
30324: NEG
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 0
30332: PUSH
30333: LD_INT 2
30335: NEG
30336: PUSH
30337: EMPTY
30338: LIST
30339: LIST
30340: PUSH
30341: LD_INT 1
30343: PUSH
30344: LD_INT 1
30346: NEG
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 2
30354: PUSH
30355: LD_INT 0
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: PUSH
30362: LD_INT 2
30364: PUSH
30365: LD_INT 1
30367: PUSH
30368: EMPTY
30369: LIST
30370: LIST
30371: PUSH
30372: LD_INT 2
30374: PUSH
30375: LD_INT 2
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 1
30384: PUSH
30385: LD_INT 2
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 0
30394: PUSH
30395: LD_INT 2
30397: PUSH
30398: EMPTY
30399: LIST
30400: LIST
30401: PUSH
30402: LD_INT 1
30404: NEG
30405: PUSH
30406: LD_INT 1
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 2
30415: NEG
30416: PUSH
30417: LD_INT 0
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 2
30426: NEG
30427: PUSH
30428: LD_INT 1
30430: NEG
30431: PUSH
30432: EMPTY
30433: LIST
30434: LIST
30435: PUSH
30436: LD_INT 2
30438: NEG
30439: PUSH
30440: LD_INT 2
30442: NEG
30443: PUSH
30444: EMPTY
30445: LIST
30446: LIST
30447: PUSH
30448: LD_INT 3
30450: PUSH
30451: LD_INT 1
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: LD_INT 3
30460: PUSH
30461: LD_INT 2
30463: PUSH
30464: EMPTY
30465: LIST
30466: LIST
30467: PUSH
30468: LD_INT 2
30470: PUSH
30471: LD_INT 3
30473: PUSH
30474: EMPTY
30475: LIST
30476: LIST
30477: PUSH
30478: LD_INT 1
30480: PUSH
30481: LD_INT 3
30483: PUSH
30484: EMPTY
30485: LIST
30486: LIST
30487: PUSH
30488: EMPTY
30489: LIST
30490: LIST
30491: LIST
30492: LIST
30493: LIST
30494: LIST
30495: LIST
30496: LIST
30497: LIST
30498: LIST
30499: LIST
30500: LIST
30501: LIST
30502: LIST
30503: LIST
30504: LIST
30505: LIST
30506: LIST
30507: LIST
30508: LIST
30509: LIST
30510: LIST
30511: LIST
30512: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
30513: LD_ADDR_VAR 0 26
30517: PUSH
30518: LD_INT 0
30520: PUSH
30521: LD_INT 0
30523: PUSH
30524: EMPTY
30525: LIST
30526: LIST
30527: PUSH
30528: LD_INT 0
30530: PUSH
30531: LD_INT 1
30533: NEG
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: LD_INT 1
30541: PUSH
30542: LD_INT 0
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: PUSH
30549: LD_INT 1
30551: PUSH
30552: LD_INT 1
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 0
30561: PUSH
30562: LD_INT 1
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: LD_INT 1
30571: NEG
30572: PUSH
30573: LD_INT 0
30575: PUSH
30576: EMPTY
30577: LIST
30578: LIST
30579: PUSH
30580: LD_INT 1
30582: NEG
30583: PUSH
30584: LD_INT 1
30586: NEG
30587: PUSH
30588: EMPTY
30589: LIST
30590: LIST
30591: PUSH
30592: LD_INT 1
30594: NEG
30595: PUSH
30596: LD_INT 2
30598: NEG
30599: PUSH
30600: EMPTY
30601: LIST
30602: LIST
30603: PUSH
30604: LD_INT 0
30606: PUSH
30607: LD_INT 2
30609: NEG
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: PUSH
30615: LD_INT 1
30617: PUSH
30618: LD_INT 1
30620: NEG
30621: PUSH
30622: EMPTY
30623: LIST
30624: LIST
30625: PUSH
30626: LD_INT 2
30628: PUSH
30629: LD_INT 0
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: LD_INT 2
30638: PUSH
30639: LD_INT 1
30641: PUSH
30642: EMPTY
30643: LIST
30644: LIST
30645: PUSH
30646: LD_INT 2
30648: PUSH
30649: LD_INT 2
30651: PUSH
30652: EMPTY
30653: LIST
30654: LIST
30655: PUSH
30656: LD_INT 1
30658: PUSH
30659: LD_INT 2
30661: PUSH
30662: EMPTY
30663: LIST
30664: LIST
30665: PUSH
30666: LD_INT 0
30668: PUSH
30669: LD_INT 2
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: PUSH
30676: LD_INT 1
30678: NEG
30679: PUSH
30680: LD_INT 1
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PUSH
30687: LD_INT 2
30689: NEG
30690: PUSH
30691: LD_INT 0
30693: PUSH
30694: EMPTY
30695: LIST
30696: LIST
30697: PUSH
30698: LD_INT 2
30700: NEG
30701: PUSH
30702: LD_INT 1
30704: NEG
30705: PUSH
30706: EMPTY
30707: LIST
30708: LIST
30709: PUSH
30710: LD_INT 2
30712: NEG
30713: PUSH
30714: LD_INT 2
30716: NEG
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: PUSH
30722: LD_INT 2
30724: PUSH
30725: LD_INT 3
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 1
30734: PUSH
30735: LD_INT 3
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 1
30744: NEG
30745: PUSH
30746: LD_INT 2
30748: PUSH
30749: EMPTY
30750: LIST
30751: LIST
30752: PUSH
30753: LD_INT 2
30755: NEG
30756: PUSH
30757: LD_INT 1
30759: PUSH
30760: EMPTY
30761: LIST
30762: LIST
30763: PUSH
30764: EMPTY
30765: LIST
30766: LIST
30767: LIST
30768: LIST
30769: LIST
30770: LIST
30771: LIST
30772: LIST
30773: LIST
30774: LIST
30775: LIST
30776: LIST
30777: LIST
30778: LIST
30779: LIST
30780: LIST
30781: LIST
30782: LIST
30783: LIST
30784: LIST
30785: LIST
30786: LIST
30787: LIST
30788: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
30789: LD_ADDR_VAR 0 27
30793: PUSH
30794: LD_INT 0
30796: PUSH
30797: LD_INT 0
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PUSH
30804: LD_INT 0
30806: PUSH
30807: LD_INT 1
30809: NEG
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 1
30817: PUSH
30818: LD_INT 0
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: PUSH
30825: LD_INT 1
30827: PUSH
30828: LD_INT 1
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: PUSH
30835: LD_INT 0
30837: PUSH
30838: LD_INT 1
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: LD_INT 1
30847: NEG
30848: PUSH
30849: LD_INT 0
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: LD_INT 1
30858: NEG
30859: PUSH
30860: LD_INT 1
30862: NEG
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 1
30870: NEG
30871: PUSH
30872: LD_INT 2
30874: NEG
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: LD_INT 0
30882: PUSH
30883: LD_INT 2
30885: NEG
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: PUSH
30891: LD_INT 1
30893: PUSH
30894: LD_INT 1
30896: NEG
30897: PUSH
30898: EMPTY
30899: LIST
30900: LIST
30901: PUSH
30902: LD_INT 2
30904: PUSH
30905: LD_INT 0
30907: PUSH
30908: EMPTY
30909: LIST
30910: LIST
30911: PUSH
30912: LD_INT 2
30914: PUSH
30915: LD_INT 1
30917: PUSH
30918: EMPTY
30919: LIST
30920: LIST
30921: PUSH
30922: LD_INT 2
30924: PUSH
30925: LD_INT 2
30927: PUSH
30928: EMPTY
30929: LIST
30930: LIST
30931: PUSH
30932: LD_INT 1
30934: PUSH
30935: LD_INT 2
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 0
30944: PUSH
30945: LD_INT 2
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: PUSH
30952: LD_INT 1
30954: NEG
30955: PUSH
30956: LD_INT 1
30958: PUSH
30959: EMPTY
30960: LIST
30961: LIST
30962: PUSH
30963: LD_INT 2
30965: NEG
30966: PUSH
30967: LD_INT 0
30969: PUSH
30970: EMPTY
30971: LIST
30972: LIST
30973: PUSH
30974: LD_INT 2
30976: NEG
30977: PUSH
30978: LD_INT 1
30980: NEG
30981: PUSH
30982: EMPTY
30983: LIST
30984: LIST
30985: PUSH
30986: LD_INT 2
30988: NEG
30989: PUSH
30990: LD_INT 2
30992: NEG
30993: PUSH
30994: EMPTY
30995: LIST
30996: LIST
30997: PUSH
30998: LD_INT 1
31000: NEG
31001: PUSH
31002: LD_INT 2
31004: PUSH
31005: EMPTY
31006: LIST
31007: LIST
31008: PUSH
31009: LD_INT 2
31011: NEG
31012: PUSH
31013: LD_INT 1
31015: PUSH
31016: EMPTY
31017: LIST
31018: LIST
31019: PUSH
31020: LD_INT 3
31022: NEG
31023: PUSH
31024: LD_INT 1
31026: NEG
31027: PUSH
31028: EMPTY
31029: LIST
31030: LIST
31031: PUSH
31032: LD_INT 3
31034: NEG
31035: PUSH
31036: LD_INT 2
31038: NEG
31039: PUSH
31040: EMPTY
31041: LIST
31042: LIST
31043: PUSH
31044: EMPTY
31045: LIST
31046: LIST
31047: LIST
31048: LIST
31049: LIST
31050: LIST
31051: LIST
31052: LIST
31053: LIST
31054: LIST
31055: LIST
31056: LIST
31057: LIST
31058: LIST
31059: LIST
31060: LIST
31061: LIST
31062: LIST
31063: LIST
31064: LIST
31065: LIST
31066: LIST
31067: LIST
31068: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31069: LD_ADDR_VAR 0 28
31073: PUSH
31074: LD_INT 0
31076: PUSH
31077: LD_INT 0
31079: PUSH
31080: EMPTY
31081: LIST
31082: LIST
31083: PUSH
31084: LD_INT 0
31086: PUSH
31087: LD_INT 1
31089: NEG
31090: PUSH
31091: EMPTY
31092: LIST
31093: LIST
31094: PUSH
31095: LD_INT 1
31097: PUSH
31098: LD_INT 0
31100: PUSH
31101: EMPTY
31102: LIST
31103: LIST
31104: PUSH
31105: LD_INT 1
31107: PUSH
31108: LD_INT 1
31110: PUSH
31111: EMPTY
31112: LIST
31113: LIST
31114: PUSH
31115: LD_INT 0
31117: PUSH
31118: LD_INT 1
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: PUSH
31125: LD_INT 1
31127: NEG
31128: PUSH
31129: LD_INT 0
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: LD_INT 1
31138: NEG
31139: PUSH
31140: LD_INT 1
31142: NEG
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 1
31150: NEG
31151: PUSH
31152: LD_INT 2
31154: NEG
31155: PUSH
31156: EMPTY
31157: LIST
31158: LIST
31159: PUSH
31160: LD_INT 0
31162: PUSH
31163: LD_INT 2
31165: NEG
31166: PUSH
31167: EMPTY
31168: LIST
31169: LIST
31170: PUSH
31171: LD_INT 1
31173: PUSH
31174: LD_INT 1
31176: NEG
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PUSH
31182: LD_INT 2
31184: PUSH
31185: LD_INT 0
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 2
31194: PUSH
31195: LD_INT 1
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 2
31204: PUSH
31205: LD_INT 2
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: LD_INT 1
31214: PUSH
31215: LD_INT 2
31217: PUSH
31218: EMPTY
31219: LIST
31220: LIST
31221: PUSH
31222: LD_INT 0
31224: PUSH
31225: LD_INT 2
31227: PUSH
31228: EMPTY
31229: LIST
31230: LIST
31231: PUSH
31232: LD_INT 1
31234: NEG
31235: PUSH
31236: LD_INT 1
31238: PUSH
31239: EMPTY
31240: LIST
31241: LIST
31242: PUSH
31243: LD_INT 2
31245: NEG
31246: PUSH
31247: LD_INT 0
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 2
31256: NEG
31257: PUSH
31258: LD_INT 1
31260: NEG
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: PUSH
31266: LD_INT 2
31268: NEG
31269: PUSH
31270: LD_INT 2
31272: NEG
31273: PUSH
31274: EMPTY
31275: LIST
31276: LIST
31277: PUSH
31278: LD_INT 2
31280: NEG
31281: PUSH
31282: LD_INT 3
31284: NEG
31285: PUSH
31286: EMPTY
31287: LIST
31288: LIST
31289: PUSH
31290: LD_INT 1
31292: NEG
31293: PUSH
31294: LD_INT 3
31296: NEG
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 3
31304: NEG
31305: PUSH
31306: LD_INT 1
31308: NEG
31309: PUSH
31310: EMPTY
31311: LIST
31312: LIST
31313: PUSH
31314: LD_INT 3
31316: NEG
31317: PUSH
31318: LD_INT 2
31320: NEG
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: LIST
31330: LIST
31331: LIST
31332: LIST
31333: LIST
31334: LIST
31335: LIST
31336: LIST
31337: LIST
31338: LIST
31339: LIST
31340: LIST
31341: LIST
31342: LIST
31343: LIST
31344: LIST
31345: LIST
31346: LIST
31347: LIST
31348: LIST
31349: LIST
31350: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31351: LD_ADDR_VAR 0 29
31355: PUSH
31356: LD_INT 0
31358: PUSH
31359: LD_INT 0
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 0
31368: PUSH
31369: LD_INT 1
31371: NEG
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: LD_INT 1
31379: PUSH
31380: LD_INT 0
31382: PUSH
31383: EMPTY
31384: LIST
31385: LIST
31386: PUSH
31387: LD_INT 1
31389: PUSH
31390: LD_INT 1
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 0
31399: PUSH
31400: LD_INT 1
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 1
31409: NEG
31410: PUSH
31411: LD_INT 0
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 1
31420: NEG
31421: PUSH
31422: LD_INT 1
31424: NEG
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: LD_INT 1
31432: NEG
31433: PUSH
31434: LD_INT 2
31436: NEG
31437: PUSH
31438: EMPTY
31439: LIST
31440: LIST
31441: PUSH
31442: LD_INT 0
31444: PUSH
31445: LD_INT 2
31447: NEG
31448: PUSH
31449: EMPTY
31450: LIST
31451: LIST
31452: PUSH
31453: LD_INT 1
31455: PUSH
31456: LD_INT 1
31458: NEG
31459: PUSH
31460: EMPTY
31461: LIST
31462: LIST
31463: PUSH
31464: LD_INT 2
31466: PUSH
31467: LD_INT 0
31469: PUSH
31470: EMPTY
31471: LIST
31472: LIST
31473: PUSH
31474: LD_INT 2
31476: PUSH
31477: LD_INT 1
31479: PUSH
31480: EMPTY
31481: LIST
31482: LIST
31483: PUSH
31484: LD_INT 1
31486: PUSH
31487: LD_INT 2
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 0
31496: PUSH
31497: LD_INT 2
31499: PUSH
31500: EMPTY
31501: LIST
31502: LIST
31503: PUSH
31504: LD_INT 1
31506: NEG
31507: PUSH
31508: LD_INT 1
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: PUSH
31515: LD_INT 2
31517: NEG
31518: PUSH
31519: LD_INT 1
31521: NEG
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: LD_INT 2
31529: NEG
31530: PUSH
31531: LD_INT 2
31533: NEG
31534: PUSH
31535: EMPTY
31536: LIST
31537: LIST
31538: PUSH
31539: LD_INT 2
31541: NEG
31542: PUSH
31543: LD_INT 3
31545: NEG
31546: PUSH
31547: EMPTY
31548: LIST
31549: LIST
31550: PUSH
31551: LD_INT 2
31553: PUSH
31554: LD_INT 1
31556: NEG
31557: PUSH
31558: EMPTY
31559: LIST
31560: LIST
31561: PUSH
31562: LD_INT 3
31564: PUSH
31565: LD_INT 1
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 1
31574: PUSH
31575: LD_INT 3
31577: PUSH
31578: EMPTY
31579: LIST
31580: LIST
31581: PUSH
31582: LD_INT 1
31584: NEG
31585: PUSH
31586: LD_INT 2
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 3
31595: NEG
31596: PUSH
31597: LD_INT 2
31599: NEG
31600: PUSH
31601: EMPTY
31602: LIST
31603: LIST
31604: PUSH
31605: EMPTY
31606: LIST
31607: LIST
31608: LIST
31609: LIST
31610: LIST
31611: LIST
31612: LIST
31613: LIST
31614: LIST
31615: LIST
31616: LIST
31617: LIST
31618: LIST
31619: LIST
31620: LIST
31621: LIST
31622: LIST
31623: LIST
31624: LIST
31625: LIST
31626: LIST
31627: LIST
31628: LIST
31629: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31630: LD_ADDR_VAR 0 30
31634: PUSH
31635: LD_INT 0
31637: PUSH
31638: LD_INT 0
31640: PUSH
31641: EMPTY
31642: LIST
31643: LIST
31644: PUSH
31645: LD_INT 0
31647: PUSH
31648: LD_INT 1
31650: NEG
31651: PUSH
31652: EMPTY
31653: LIST
31654: LIST
31655: PUSH
31656: LD_INT 1
31658: PUSH
31659: LD_INT 0
31661: PUSH
31662: EMPTY
31663: LIST
31664: LIST
31665: PUSH
31666: LD_INT 1
31668: PUSH
31669: LD_INT 1
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PUSH
31676: LD_INT 0
31678: PUSH
31679: LD_INT 1
31681: PUSH
31682: EMPTY
31683: LIST
31684: LIST
31685: PUSH
31686: LD_INT 1
31688: NEG
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PUSH
31697: LD_INT 1
31699: NEG
31700: PUSH
31701: LD_INT 1
31703: NEG
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: LD_INT 1
31711: NEG
31712: PUSH
31713: LD_INT 2
31715: NEG
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 0
31723: PUSH
31724: LD_INT 2
31726: NEG
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: LD_INT 1
31734: PUSH
31735: LD_INT 1
31737: NEG
31738: PUSH
31739: EMPTY
31740: LIST
31741: LIST
31742: PUSH
31743: LD_INT 2
31745: PUSH
31746: LD_INT 0
31748: PUSH
31749: EMPTY
31750: LIST
31751: LIST
31752: PUSH
31753: LD_INT 2
31755: PUSH
31756: LD_INT 1
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: PUSH
31763: LD_INT 2
31765: PUSH
31766: LD_INT 2
31768: PUSH
31769: EMPTY
31770: LIST
31771: LIST
31772: PUSH
31773: LD_INT 1
31775: PUSH
31776: LD_INT 2
31778: PUSH
31779: EMPTY
31780: LIST
31781: LIST
31782: PUSH
31783: LD_INT 1
31785: NEG
31786: PUSH
31787: LD_INT 1
31789: PUSH
31790: EMPTY
31791: LIST
31792: LIST
31793: PUSH
31794: LD_INT 2
31796: NEG
31797: PUSH
31798: LD_INT 0
31800: PUSH
31801: EMPTY
31802: LIST
31803: LIST
31804: PUSH
31805: LD_INT 2
31807: NEG
31808: PUSH
31809: LD_INT 1
31811: NEG
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: LD_INT 1
31819: NEG
31820: PUSH
31821: LD_INT 3
31823: NEG
31824: PUSH
31825: EMPTY
31826: LIST
31827: LIST
31828: PUSH
31829: LD_INT 1
31831: PUSH
31832: LD_INT 2
31834: NEG
31835: PUSH
31836: EMPTY
31837: LIST
31838: LIST
31839: PUSH
31840: LD_INT 3
31842: PUSH
31843: LD_INT 2
31845: PUSH
31846: EMPTY
31847: LIST
31848: LIST
31849: PUSH
31850: LD_INT 2
31852: PUSH
31853: LD_INT 3
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: PUSH
31860: LD_INT 2
31862: NEG
31863: PUSH
31864: LD_INT 1
31866: PUSH
31867: EMPTY
31868: LIST
31869: LIST
31870: PUSH
31871: LD_INT 3
31873: NEG
31874: PUSH
31875: LD_INT 1
31877: NEG
31878: PUSH
31879: EMPTY
31880: LIST
31881: LIST
31882: PUSH
31883: EMPTY
31884: LIST
31885: LIST
31886: LIST
31887: LIST
31888: LIST
31889: LIST
31890: LIST
31891: LIST
31892: LIST
31893: LIST
31894: LIST
31895: LIST
31896: LIST
31897: LIST
31898: LIST
31899: LIST
31900: LIST
31901: LIST
31902: LIST
31903: LIST
31904: LIST
31905: LIST
31906: LIST
31907: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31908: LD_ADDR_VAR 0 31
31912: PUSH
31913: LD_INT 0
31915: PUSH
31916: LD_INT 0
31918: PUSH
31919: EMPTY
31920: LIST
31921: LIST
31922: PUSH
31923: LD_INT 0
31925: PUSH
31926: LD_INT 1
31928: NEG
31929: PUSH
31930: EMPTY
31931: LIST
31932: LIST
31933: PUSH
31934: LD_INT 1
31936: PUSH
31937: LD_INT 0
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: PUSH
31944: LD_INT 1
31946: PUSH
31947: LD_INT 1
31949: PUSH
31950: EMPTY
31951: LIST
31952: LIST
31953: PUSH
31954: LD_INT 0
31956: PUSH
31957: LD_INT 1
31959: PUSH
31960: EMPTY
31961: LIST
31962: LIST
31963: PUSH
31964: LD_INT 1
31966: NEG
31967: PUSH
31968: LD_INT 0
31970: PUSH
31971: EMPTY
31972: LIST
31973: LIST
31974: PUSH
31975: LD_INT 1
31977: NEG
31978: PUSH
31979: LD_INT 1
31981: NEG
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 1
31989: NEG
31990: PUSH
31991: LD_INT 2
31993: NEG
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 1
32001: PUSH
32002: LD_INT 1
32004: NEG
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 2
32012: PUSH
32013: LD_INT 0
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 2
32022: PUSH
32023: LD_INT 1
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 2
32032: PUSH
32033: LD_INT 2
32035: PUSH
32036: EMPTY
32037: LIST
32038: LIST
32039: PUSH
32040: LD_INT 1
32042: PUSH
32043: LD_INT 2
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PUSH
32050: LD_INT 0
32052: PUSH
32053: LD_INT 2
32055: PUSH
32056: EMPTY
32057: LIST
32058: LIST
32059: PUSH
32060: LD_INT 1
32062: NEG
32063: PUSH
32064: LD_INT 1
32066: PUSH
32067: EMPTY
32068: LIST
32069: LIST
32070: PUSH
32071: LD_INT 2
32073: NEG
32074: PUSH
32075: LD_INT 1
32077: NEG
32078: PUSH
32079: EMPTY
32080: LIST
32081: LIST
32082: PUSH
32083: LD_INT 2
32085: NEG
32086: PUSH
32087: LD_INT 2
32089: NEG
32090: PUSH
32091: EMPTY
32092: LIST
32093: LIST
32094: PUSH
32095: LD_INT 2
32097: NEG
32098: PUSH
32099: LD_INT 3
32101: NEG
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: PUSH
32107: LD_INT 2
32109: PUSH
32110: LD_INT 1
32112: NEG
32113: PUSH
32114: EMPTY
32115: LIST
32116: LIST
32117: PUSH
32118: LD_INT 3
32120: PUSH
32121: LD_INT 1
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 1
32130: PUSH
32131: LD_INT 3
32133: PUSH
32134: EMPTY
32135: LIST
32136: LIST
32137: PUSH
32138: LD_INT 1
32140: NEG
32141: PUSH
32142: LD_INT 2
32144: PUSH
32145: EMPTY
32146: LIST
32147: LIST
32148: PUSH
32149: LD_INT 3
32151: NEG
32152: PUSH
32153: LD_INT 2
32155: NEG
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: LIST
32165: LIST
32166: LIST
32167: LIST
32168: LIST
32169: LIST
32170: LIST
32171: LIST
32172: LIST
32173: LIST
32174: LIST
32175: LIST
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32186: LD_ADDR_VAR 0 32
32190: PUSH
32191: LD_INT 0
32193: PUSH
32194: LD_INT 0
32196: PUSH
32197: EMPTY
32198: LIST
32199: LIST
32200: PUSH
32201: LD_INT 0
32203: PUSH
32204: LD_INT 1
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 1
32214: PUSH
32215: LD_INT 0
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 1
32224: PUSH
32225: LD_INT 1
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 0
32234: PUSH
32235: LD_INT 1
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 1
32244: NEG
32245: PUSH
32246: LD_INT 0
32248: PUSH
32249: EMPTY
32250: LIST
32251: LIST
32252: PUSH
32253: LD_INT 1
32255: NEG
32256: PUSH
32257: LD_INT 1
32259: NEG
32260: PUSH
32261: EMPTY
32262: LIST
32263: LIST
32264: PUSH
32265: LD_INT 1
32267: NEG
32268: PUSH
32269: LD_INT 2
32271: NEG
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 0
32279: PUSH
32280: LD_INT 2
32282: NEG
32283: PUSH
32284: EMPTY
32285: LIST
32286: LIST
32287: PUSH
32288: LD_INT 1
32290: PUSH
32291: LD_INT 1
32293: NEG
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: LD_INT 2
32301: PUSH
32302: LD_INT 1
32304: PUSH
32305: EMPTY
32306: LIST
32307: LIST
32308: PUSH
32309: LD_INT 2
32311: PUSH
32312: LD_INT 2
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PUSH
32319: LD_INT 1
32321: PUSH
32322: LD_INT 2
32324: PUSH
32325: EMPTY
32326: LIST
32327: LIST
32328: PUSH
32329: LD_INT 0
32331: PUSH
32332: LD_INT 2
32334: PUSH
32335: EMPTY
32336: LIST
32337: LIST
32338: PUSH
32339: LD_INT 1
32341: NEG
32342: PUSH
32343: LD_INT 1
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 2
32352: NEG
32353: PUSH
32354: LD_INT 0
32356: PUSH
32357: EMPTY
32358: LIST
32359: LIST
32360: PUSH
32361: LD_INT 2
32363: NEG
32364: PUSH
32365: LD_INT 1
32367: NEG
32368: PUSH
32369: EMPTY
32370: LIST
32371: LIST
32372: PUSH
32373: LD_INT 1
32375: NEG
32376: PUSH
32377: LD_INT 3
32379: NEG
32380: PUSH
32381: EMPTY
32382: LIST
32383: LIST
32384: PUSH
32385: LD_INT 1
32387: PUSH
32388: LD_INT 2
32390: NEG
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 3
32398: PUSH
32399: LD_INT 2
32401: PUSH
32402: EMPTY
32403: LIST
32404: LIST
32405: PUSH
32406: LD_INT 2
32408: PUSH
32409: LD_INT 3
32411: PUSH
32412: EMPTY
32413: LIST
32414: LIST
32415: PUSH
32416: LD_INT 2
32418: NEG
32419: PUSH
32420: LD_INT 1
32422: PUSH
32423: EMPTY
32424: LIST
32425: LIST
32426: PUSH
32427: LD_INT 3
32429: NEG
32430: PUSH
32431: LD_INT 1
32433: NEG
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: EMPTY
32440: LIST
32441: LIST
32442: LIST
32443: LIST
32444: LIST
32445: LIST
32446: LIST
32447: LIST
32448: LIST
32449: LIST
32450: LIST
32451: LIST
32452: LIST
32453: LIST
32454: LIST
32455: LIST
32456: LIST
32457: LIST
32458: LIST
32459: LIST
32460: LIST
32461: LIST
32462: LIST
32463: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32464: LD_ADDR_VAR 0 33
32468: PUSH
32469: LD_INT 0
32471: PUSH
32472: LD_INT 0
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 0
32481: PUSH
32482: LD_INT 1
32484: NEG
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 1
32492: PUSH
32493: LD_INT 0
32495: PUSH
32496: EMPTY
32497: LIST
32498: LIST
32499: PUSH
32500: LD_INT 1
32502: PUSH
32503: LD_INT 1
32505: PUSH
32506: EMPTY
32507: LIST
32508: LIST
32509: PUSH
32510: LD_INT 0
32512: PUSH
32513: LD_INT 1
32515: PUSH
32516: EMPTY
32517: LIST
32518: LIST
32519: PUSH
32520: LD_INT 1
32522: NEG
32523: PUSH
32524: LD_INT 0
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 1
32533: NEG
32534: PUSH
32535: LD_INT 1
32537: NEG
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PUSH
32543: LD_INT 1
32545: NEG
32546: PUSH
32547: LD_INT 2
32549: NEG
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 1
32557: PUSH
32558: LD_INT 1
32560: NEG
32561: PUSH
32562: EMPTY
32563: LIST
32564: LIST
32565: PUSH
32566: LD_INT 2
32568: PUSH
32569: LD_INT 0
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 2
32578: PUSH
32579: LD_INT 1
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 1
32588: PUSH
32589: LD_INT 2
32591: PUSH
32592: EMPTY
32593: LIST
32594: LIST
32595: PUSH
32596: LD_INT 0
32598: PUSH
32599: LD_INT 2
32601: PUSH
32602: EMPTY
32603: LIST
32604: LIST
32605: PUSH
32606: LD_INT 1
32608: NEG
32609: PUSH
32610: LD_INT 1
32612: PUSH
32613: EMPTY
32614: LIST
32615: LIST
32616: PUSH
32617: LD_INT 2
32619: NEG
32620: PUSH
32621: LD_INT 0
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: PUSH
32628: LD_INT 2
32630: NEG
32631: PUSH
32632: LD_INT 1
32634: NEG
32635: PUSH
32636: EMPTY
32637: LIST
32638: LIST
32639: PUSH
32640: LD_INT 2
32642: NEG
32643: PUSH
32644: LD_INT 2
32646: NEG
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: PUSH
32652: LD_INT 2
32654: NEG
32655: PUSH
32656: LD_INT 3
32658: NEG
32659: PUSH
32660: EMPTY
32661: LIST
32662: LIST
32663: PUSH
32664: LD_INT 2
32666: PUSH
32667: LD_INT 1
32669: NEG
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: LD_INT 3
32677: PUSH
32678: LD_INT 1
32680: PUSH
32681: EMPTY
32682: LIST
32683: LIST
32684: PUSH
32685: LD_INT 1
32687: PUSH
32688: LD_INT 3
32690: PUSH
32691: EMPTY
32692: LIST
32693: LIST
32694: PUSH
32695: LD_INT 1
32697: NEG
32698: PUSH
32699: LD_INT 2
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PUSH
32706: LD_INT 3
32708: NEG
32709: PUSH
32710: LD_INT 2
32712: NEG
32713: PUSH
32714: EMPTY
32715: LIST
32716: LIST
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: LIST
32722: LIST
32723: LIST
32724: LIST
32725: LIST
32726: LIST
32727: LIST
32728: LIST
32729: LIST
32730: LIST
32731: LIST
32732: LIST
32733: LIST
32734: LIST
32735: LIST
32736: LIST
32737: LIST
32738: LIST
32739: LIST
32740: LIST
32741: LIST
32742: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32743: LD_ADDR_VAR 0 34
32747: PUSH
32748: LD_INT 0
32750: PUSH
32751: LD_INT 0
32753: PUSH
32754: EMPTY
32755: LIST
32756: LIST
32757: PUSH
32758: LD_INT 0
32760: PUSH
32761: LD_INT 1
32763: NEG
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: PUSH
32769: LD_INT 1
32771: PUSH
32772: LD_INT 0
32774: PUSH
32775: EMPTY
32776: LIST
32777: LIST
32778: PUSH
32779: LD_INT 1
32781: PUSH
32782: LD_INT 1
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: LD_INT 0
32791: PUSH
32792: LD_INT 1
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 1
32801: NEG
32802: PUSH
32803: LD_INT 0
32805: PUSH
32806: EMPTY
32807: LIST
32808: LIST
32809: PUSH
32810: LD_INT 1
32812: NEG
32813: PUSH
32814: LD_INT 1
32816: NEG
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PUSH
32822: LD_INT 1
32824: NEG
32825: PUSH
32826: LD_INT 2
32828: NEG
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 0
32836: PUSH
32837: LD_INT 2
32839: NEG
32840: PUSH
32841: EMPTY
32842: LIST
32843: LIST
32844: PUSH
32845: LD_INT 1
32847: PUSH
32848: LD_INT 1
32850: NEG
32851: PUSH
32852: EMPTY
32853: LIST
32854: LIST
32855: PUSH
32856: LD_INT 2
32858: PUSH
32859: LD_INT 1
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: PUSH
32866: LD_INT 2
32868: PUSH
32869: LD_INT 2
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 1
32878: PUSH
32879: LD_INT 2
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: PUSH
32886: LD_INT 1
32888: NEG
32889: PUSH
32890: LD_INT 1
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 2
32899: NEG
32900: PUSH
32901: LD_INT 0
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 2
32910: NEG
32911: PUSH
32912: LD_INT 1
32914: NEG
32915: PUSH
32916: EMPTY
32917: LIST
32918: LIST
32919: PUSH
32920: LD_INT 2
32922: NEG
32923: PUSH
32924: LD_INT 2
32926: NEG
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 1
32934: NEG
32935: PUSH
32936: LD_INT 3
32938: NEG
32939: PUSH
32940: EMPTY
32941: LIST
32942: LIST
32943: PUSH
32944: LD_INT 1
32946: PUSH
32947: LD_INT 2
32949: NEG
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 3
32957: PUSH
32958: LD_INT 2
32960: PUSH
32961: EMPTY
32962: LIST
32963: LIST
32964: PUSH
32965: LD_INT 2
32967: PUSH
32968: LD_INT 3
32970: PUSH
32971: EMPTY
32972: LIST
32973: LIST
32974: PUSH
32975: LD_INT 2
32977: NEG
32978: PUSH
32979: LD_INT 1
32981: PUSH
32982: EMPTY
32983: LIST
32984: LIST
32985: PUSH
32986: LD_INT 3
32988: NEG
32989: PUSH
32990: LD_INT 1
32992: NEG
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: EMPTY
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: LIST
33004: LIST
33005: LIST
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: LIST
33013: LIST
33014: LIST
33015: LIST
33016: LIST
33017: LIST
33018: LIST
33019: LIST
33020: LIST
33021: LIST
33022: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33023: LD_ADDR_VAR 0 35
33027: PUSH
33028: LD_INT 0
33030: PUSH
33031: LD_INT 0
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 0
33040: PUSH
33041: LD_INT 1
33043: NEG
33044: PUSH
33045: EMPTY
33046: LIST
33047: LIST
33048: PUSH
33049: LD_INT 1
33051: PUSH
33052: LD_INT 0
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 1
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 0
33071: PUSH
33072: LD_INT 1
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 1
33081: NEG
33082: PUSH
33083: LD_INT 0
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: LD_INT 1
33092: NEG
33093: PUSH
33094: LD_INT 1
33096: NEG
33097: PUSH
33098: EMPTY
33099: LIST
33100: LIST
33101: PUSH
33102: LD_INT 2
33104: PUSH
33105: LD_INT 1
33107: PUSH
33108: EMPTY
33109: LIST
33110: LIST
33111: PUSH
33112: LD_INT 2
33114: NEG
33115: PUSH
33116: LD_INT 1
33118: NEG
33119: PUSH
33120: EMPTY
33121: LIST
33122: LIST
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: LIST
33128: LIST
33129: LIST
33130: LIST
33131: LIST
33132: LIST
33133: LIST
33134: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33135: LD_ADDR_VAR 0 36
33139: PUSH
33140: LD_INT 0
33142: PUSH
33143: LD_INT 0
33145: PUSH
33146: EMPTY
33147: LIST
33148: LIST
33149: PUSH
33150: LD_INT 0
33152: PUSH
33153: LD_INT 1
33155: NEG
33156: PUSH
33157: EMPTY
33158: LIST
33159: LIST
33160: PUSH
33161: LD_INT 1
33163: PUSH
33164: LD_INT 0
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 1
33173: PUSH
33174: LD_INT 1
33176: PUSH
33177: EMPTY
33178: LIST
33179: LIST
33180: PUSH
33181: LD_INT 0
33183: PUSH
33184: LD_INT 1
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PUSH
33191: LD_INT 1
33193: NEG
33194: PUSH
33195: LD_INT 0
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: PUSH
33202: LD_INT 1
33204: NEG
33205: PUSH
33206: LD_INT 1
33208: NEG
33209: PUSH
33210: EMPTY
33211: LIST
33212: LIST
33213: PUSH
33214: LD_INT 1
33216: NEG
33217: PUSH
33218: LD_INT 2
33220: NEG
33221: PUSH
33222: EMPTY
33223: LIST
33224: LIST
33225: PUSH
33226: LD_INT 1
33228: PUSH
33229: LD_INT 2
33231: PUSH
33232: EMPTY
33233: LIST
33234: LIST
33235: PUSH
33236: EMPTY
33237: LIST
33238: LIST
33239: LIST
33240: LIST
33241: LIST
33242: LIST
33243: LIST
33244: LIST
33245: LIST
33246: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33247: LD_ADDR_VAR 0 37
33251: PUSH
33252: LD_INT 0
33254: PUSH
33255: LD_INT 0
33257: PUSH
33258: EMPTY
33259: LIST
33260: LIST
33261: PUSH
33262: LD_INT 0
33264: PUSH
33265: LD_INT 1
33267: NEG
33268: PUSH
33269: EMPTY
33270: LIST
33271: LIST
33272: PUSH
33273: LD_INT 1
33275: PUSH
33276: LD_INT 0
33278: PUSH
33279: EMPTY
33280: LIST
33281: LIST
33282: PUSH
33283: LD_INT 1
33285: PUSH
33286: LD_INT 1
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PUSH
33293: LD_INT 0
33295: PUSH
33296: LD_INT 1
33298: PUSH
33299: EMPTY
33300: LIST
33301: LIST
33302: PUSH
33303: LD_INT 1
33305: NEG
33306: PUSH
33307: LD_INT 0
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 1
33316: NEG
33317: PUSH
33318: LD_INT 1
33320: NEG
33321: PUSH
33322: EMPTY
33323: LIST
33324: LIST
33325: PUSH
33326: LD_INT 1
33328: PUSH
33329: LD_INT 1
33331: NEG
33332: PUSH
33333: EMPTY
33334: LIST
33335: LIST
33336: PUSH
33337: LD_INT 1
33339: NEG
33340: PUSH
33341: LD_INT 1
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PUSH
33348: EMPTY
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: LIST
33357: LIST
33358: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33359: LD_ADDR_VAR 0 38
33363: PUSH
33364: LD_INT 0
33366: PUSH
33367: LD_INT 0
33369: PUSH
33370: EMPTY
33371: LIST
33372: LIST
33373: PUSH
33374: LD_INT 0
33376: PUSH
33377: LD_INT 1
33379: NEG
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: LD_INT 1
33387: PUSH
33388: LD_INT 0
33390: PUSH
33391: EMPTY
33392: LIST
33393: LIST
33394: PUSH
33395: LD_INT 1
33397: PUSH
33398: LD_INT 1
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: PUSH
33405: LD_INT 0
33407: PUSH
33408: LD_INT 1
33410: PUSH
33411: EMPTY
33412: LIST
33413: LIST
33414: PUSH
33415: LD_INT 1
33417: NEG
33418: PUSH
33419: LD_INT 0
33421: PUSH
33422: EMPTY
33423: LIST
33424: LIST
33425: PUSH
33426: LD_INT 1
33428: NEG
33429: PUSH
33430: LD_INT 1
33432: NEG
33433: PUSH
33434: EMPTY
33435: LIST
33436: LIST
33437: PUSH
33438: LD_INT 2
33440: PUSH
33441: LD_INT 1
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 2
33450: NEG
33451: PUSH
33452: LD_INT 1
33454: NEG
33455: PUSH
33456: EMPTY
33457: LIST
33458: LIST
33459: PUSH
33460: EMPTY
33461: LIST
33462: LIST
33463: LIST
33464: LIST
33465: LIST
33466: LIST
33467: LIST
33468: LIST
33469: LIST
33470: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33471: LD_ADDR_VAR 0 39
33475: PUSH
33476: LD_INT 0
33478: PUSH
33479: LD_INT 0
33481: PUSH
33482: EMPTY
33483: LIST
33484: LIST
33485: PUSH
33486: LD_INT 0
33488: PUSH
33489: LD_INT 1
33491: NEG
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PUSH
33497: LD_INT 1
33499: PUSH
33500: LD_INT 0
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: LD_INT 1
33509: PUSH
33510: LD_INT 1
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 0
33519: PUSH
33520: LD_INT 1
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 1
33529: NEG
33530: PUSH
33531: LD_INT 0
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 1
33540: NEG
33541: PUSH
33542: LD_INT 1
33544: NEG
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 1
33552: NEG
33553: PUSH
33554: LD_INT 2
33556: NEG
33557: PUSH
33558: EMPTY
33559: LIST
33560: LIST
33561: PUSH
33562: LD_INT 1
33564: PUSH
33565: LD_INT 2
33567: PUSH
33568: EMPTY
33569: LIST
33570: LIST
33571: PUSH
33572: EMPTY
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: LIST
33580: LIST
33581: LIST
33582: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33583: LD_ADDR_VAR 0 40
33587: PUSH
33588: LD_INT 0
33590: PUSH
33591: LD_INT 0
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 0
33600: PUSH
33601: LD_INT 1
33603: NEG
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 1
33611: PUSH
33612: LD_INT 0
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 1
33621: PUSH
33622: LD_INT 1
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 0
33631: PUSH
33632: LD_INT 1
33634: PUSH
33635: EMPTY
33636: LIST
33637: LIST
33638: PUSH
33639: LD_INT 1
33641: NEG
33642: PUSH
33643: LD_INT 0
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 1
33652: NEG
33653: PUSH
33654: LD_INT 1
33656: NEG
33657: PUSH
33658: EMPTY
33659: LIST
33660: LIST
33661: PUSH
33662: LD_INT 1
33664: PUSH
33665: LD_INT 1
33667: NEG
33668: PUSH
33669: EMPTY
33670: LIST
33671: LIST
33672: PUSH
33673: LD_INT 1
33675: NEG
33676: PUSH
33677: LD_INT 1
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33695: LD_ADDR_VAR 0 41
33699: PUSH
33700: LD_INT 0
33702: PUSH
33703: LD_INT 0
33705: PUSH
33706: EMPTY
33707: LIST
33708: LIST
33709: PUSH
33710: LD_INT 0
33712: PUSH
33713: LD_INT 1
33715: NEG
33716: PUSH
33717: EMPTY
33718: LIST
33719: LIST
33720: PUSH
33721: LD_INT 1
33723: PUSH
33724: LD_INT 0
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: PUSH
33731: LD_INT 1
33733: PUSH
33734: LD_INT 1
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: PUSH
33741: LD_INT 0
33743: PUSH
33744: LD_INT 1
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: LD_INT 1
33753: NEG
33754: PUSH
33755: LD_INT 0
33757: PUSH
33758: EMPTY
33759: LIST
33760: LIST
33761: PUSH
33762: LD_INT 1
33764: NEG
33765: PUSH
33766: LD_INT 1
33768: NEG
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 1
33776: NEG
33777: PUSH
33778: LD_INT 2
33780: NEG
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 1
33788: PUSH
33789: LD_INT 1
33791: NEG
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 2
33799: PUSH
33800: LD_INT 0
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: LD_INT 2
33809: PUSH
33810: LD_INT 1
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 2
33819: PUSH
33820: LD_INT 2
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 1
33829: PUSH
33830: LD_INT 2
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: PUSH
33837: LD_INT 1
33839: NEG
33840: PUSH
33841: LD_INT 1
33843: PUSH
33844: EMPTY
33845: LIST
33846: LIST
33847: PUSH
33848: LD_INT 2
33850: NEG
33851: PUSH
33852: LD_INT 0
33854: PUSH
33855: EMPTY
33856: LIST
33857: LIST
33858: PUSH
33859: LD_INT 2
33861: NEG
33862: PUSH
33863: LD_INT 1
33865: NEG
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 2
33873: NEG
33874: PUSH
33875: LD_INT 2
33877: NEG
33878: PUSH
33879: EMPTY
33880: LIST
33881: LIST
33882: PUSH
33883: LD_INT 2
33885: NEG
33886: PUSH
33887: LD_INT 3
33889: NEG
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 2
33897: PUSH
33898: LD_INT 1
33900: NEG
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 3
33908: PUSH
33909: LD_INT 0
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 3
33918: PUSH
33919: LD_INT 1
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 3
33928: PUSH
33929: LD_INT 2
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 3
33938: PUSH
33939: LD_INT 3
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 2
33948: PUSH
33949: LD_INT 3
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 2
33958: NEG
33959: PUSH
33960: LD_INT 1
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 3
33969: NEG
33970: PUSH
33971: LD_INT 0
33973: PUSH
33974: EMPTY
33975: LIST
33976: LIST
33977: PUSH
33978: LD_INT 3
33980: NEG
33981: PUSH
33982: LD_INT 1
33984: NEG
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 3
33992: NEG
33993: PUSH
33994: LD_INT 2
33996: NEG
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 3
34004: NEG
34005: PUSH
34006: LD_INT 3
34008: NEG
34009: PUSH
34010: EMPTY
34011: LIST
34012: LIST
34013: PUSH
34014: EMPTY
34015: LIST
34016: LIST
34017: LIST
34018: LIST
34019: LIST
34020: LIST
34021: LIST
34022: LIST
34023: LIST
34024: LIST
34025: LIST
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34045: LD_ADDR_VAR 0 42
34049: PUSH
34050: LD_INT 0
34052: PUSH
34053: LD_INT 0
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: LD_INT 1
34065: NEG
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: LD_INT 1
34073: PUSH
34074: LD_INT 0
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: LD_INT 1
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 0
34093: PUSH
34094: LD_INT 1
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 1
34103: NEG
34104: PUSH
34105: LD_INT 0
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 1
34114: NEG
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PUSH
34124: LD_INT 1
34126: NEG
34127: PUSH
34128: LD_INT 2
34130: NEG
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 0
34138: PUSH
34139: LD_INT 2
34141: NEG
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 1
34149: PUSH
34150: LD_INT 1
34152: NEG
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PUSH
34158: LD_INT 2
34160: PUSH
34161: LD_INT 1
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 2
34170: PUSH
34171: LD_INT 2
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 1
34180: PUSH
34181: LD_INT 2
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 0
34190: PUSH
34191: LD_INT 2
34193: PUSH
34194: EMPTY
34195: LIST
34196: LIST
34197: PUSH
34198: LD_INT 1
34200: NEG
34201: PUSH
34202: LD_INT 1
34204: PUSH
34205: EMPTY
34206: LIST
34207: LIST
34208: PUSH
34209: LD_INT 2
34211: NEG
34212: PUSH
34213: LD_INT 1
34215: NEG
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: PUSH
34221: LD_INT 2
34223: NEG
34224: PUSH
34225: LD_INT 2
34227: NEG
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: LD_INT 2
34235: NEG
34236: PUSH
34237: LD_INT 3
34239: NEG
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PUSH
34245: LD_INT 1
34247: NEG
34248: PUSH
34249: LD_INT 3
34251: NEG
34252: PUSH
34253: EMPTY
34254: LIST
34255: LIST
34256: PUSH
34257: LD_INT 0
34259: PUSH
34260: LD_INT 3
34262: NEG
34263: PUSH
34264: EMPTY
34265: LIST
34266: LIST
34267: PUSH
34268: LD_INT 1
34270: PUSH
34271: LD_INT 2
34273: NEG
34274: PUSH
34275: EMPTY
34276: LIST
34277: LIST
34278: PUSH
34279: LD_INT 3
34281: PUSH
34282: LD_INT 2
34284: PUSH
34285: EMPTY
34286: LIST
34287: LIST
34288: PUSH
34289: LD_INT 3
34291: PUSH
34292: LD_INT 3
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: PUSH
34299: LD_INT 2
34301: PUSH
34302: LD_INT 3
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: LD_INT 1
34311: PUSH
34312: LD_INT 3
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 0
34321: PUSH
34322: LD_INT 3
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 1
34331: NEG
34332: PUSH
34333: LD_INT 2
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 3
34342: NEG
34343: PUSH
34344: LD_INT 2
34346: NEG
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 3
34354: NEG
34355: PUSH
34356: LD_INT 3
34358: NEG
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: LIST
34368: LIST
34369: LIST
34370: LIST
34371: LIST
34372: LIST
34373: LIST
34374: LIST
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: LIST
34381: LIST
34382: LIST
34383: LIST
34384: LIST
34385: LIST
34386: LIST
34387: LIST
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34395: LD_ADDR_VAR 0 43
34399: PUSH
34400: LD_INT 0
34402: PUSH
34403: LD_INT 0
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 0
34412: PUSH
34413: LD_INT 1
34415: NEG
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: PUSH
34424: LD_INT 0
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 1
34433: PUSH
34434: LD_INT 1
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 0
34443: PUSH
34444: LD_INT 1
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 1
34453: NEG
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 1
34464: NEG
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 1
34476: NEG
34477: PUSH
34478: LD_INT 2
34480: NEG
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 0
34488: PUSH
34489: LD_INT 2
34491: NEG
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 1
34499: PUSH
34500: LD_INT 1
34502: NEG
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 2
34510: PUSH
34511: LD_INT 0
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: LD_INT 2
34520: PUSH
34521: LD_INT 1
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: LD_INT 1
34530: PUSH
34531: LD_INT 2
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 0
34540: PUSH
34541: LD_INT 2
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: PUSH
34548: LD_INT 1
34550: NEG
34551: PUSH
34552: LD_INT 1
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 2
34561: NEG
34562: PUSH
34563: LD_INT 0
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 2
34572: NEG
34573: PUSH
34574: LD_INT 1
34576: NEG
34577: PUSH
34578: EMPTY
34579: LIST
34580: LIST
34581: PUSH
34582: LD_INT 1
34584: NEG
34585: PUSH
34586: LD_INT 3
34588: NEG
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 0
34596: PUSH
34597: LD_INT 3
34599: NEG
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: LD_INT 1
34607: PUSH
34608: LD_INT 2
34610: NEG
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 2
34618: PUSH
34619: LD_INT 1
34621: NEG
34622: PUSH
34623: EMPTY
34624: LIST
34625: LIST
34626: PUSH
34627: LD_INT 3
34629: PUSH
34630: LD_INT 0
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 3
34639: PUSH
34640: LD_INT 1
34642: PUSH
34643: EMPTY
34644: LIST
34645: LIST
34646: PUSH
34647: LD_INT 1
34649: PUSH
34650: LD_INT 3
34652: PUSH
34653: EMPTY
34654: LIST
34655: LIST
34656: PUSH
34657: LD_INT 0
34659: PUSH
34660: LD_INT 3
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 1
34669: NEG
34670: PUSH
34671: LD_INT 2
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: PUSH
34678: LD_INT 2
34680: NEG
34681: PUSH
34682: LD_INT 1
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 3
34691: NEG
34692: PUSH
34693: LD_INT 0
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 3
34702: NEG
34703: PUSH
34704: LD_INT 1
34706: NEG
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: LIST
34742: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34743: LD_ADDR_VAR 0 44
34747: PUSH
34748: LD_INT 0
34750: PUSH
34751: LD_INT 0
34753: PUSH
34754: EMPTY
34755: LIST
34756: LIST
34757: PUSH
34758: LD_INT 0
34760: PUSH
34761: LD_INT 1
34763: NEG
34764: PUSH
34765: EMPTY
34766: LIST
34767: LIST
34768: PUSH
34769: LD_INT 1
34771: PUSH
34772: LD_INT 0
34774: PUSH
34775: EMPTY
34776: LIST
34777: LIST
34778: PUSH
34779: LD_INT 1
34781: PUSH
34782: LD_INT 1
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: LD_INT 1
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: PUSH
34799: LD_INT 1
34801: NEG
34802: PUSH
34803: LD_INT 0
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: PUSH
34810: LD_INT 1
34812: NEG
34813: PUSH
34814: LD_INT 1
34816: NEG
34817: PUSH
34818: EMPTY
34819: LIST
34820: LIST
34821: PUSH
34822: LD_INT 1
34824: NEG
34825: PUSH
34826: LD_INT 2
34828: NEG
34829: PUSH
34830: EMPTY
34831: LIST
34832: LIST
34833: PUSH
34834: LD_INT 1
34836: PUSH
34837: LD_INT 1
34839: NEG
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: PUSH
34845: LD_INT 2
34847: PUSH
34848: LD_INT 0
34850: PUSH
34851: EMPTY
34852: LIST
34853: LIST
34854: PUSH
34855: LD_INT 2
34857: PUSH
34858: LD_INT 1
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: PUSH
34865: LD_INT 2
34867: PUSH
34868: LD_INT 2
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 1
34877: PUSH
34878: LD_INT 2
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 1
34887: NEG
34888: PUSH
34889: LD_INT 1
34891: PUSH
34892: EMPTY
34893: LIST
34894: LIST
34895: PUSH
34896: LD_INT 2
34898: NEG
34899: PUSH
34900: LD_INT 0
34902: PUSH
34903: EMPTY
34904: LIST
34905: LIST
34906: PUSH
34907: LD_INT 2
34909: NEG
34910: PUSH
34911: LD_INT 1
34913: NEG
34914: PUSH
34915: EMPTY
34916: LIST
34917: LIST
34918: PUSH
34919: LD_INT 2
34921: NEG
34922: PUSH
34923: LD_INT 2
34925: NEG
34926: PUSH
34927: EMPTY
34928: LIST
34929: LIST
34930: PUSH
34931: LD_INT 2
34933: NEG
34934: PUSH
34935: LD_INT 3
34937: NEG
34938: PUSH
34939: EMPTY
34940: LIST
34941: LIST
34942: PUSH
34943: LD_INT 2
34945: PUSH
34946: LD_INT 1
34948: NEG
34949: PUSH
34950: EMPTY
34951: LIST
34952: LIST
34953: PUSH
34954: LD_INT 3
34956: PUSH
34957: LD_INT 0
34959: PUSH
34960: EMPTY
34961: LIST
34962: LIST
34963: PUSH
34964: LD_INT 3
34966: PUSH
34967: LD_INT 1
34969: PUSH
34970: EMPTY
34971: LIST
34972: LIST
34973: PUSH
34974: LD_INT 3
34976: PUSH
34977: LD_INT 2
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: PUSH
34984: LD_INT 3
34986: PUSH
34987: LD_INT 3
34989: PUSH
34990: EMPTY
34991: LIST
34992: LIST
34993: PUSH
34994: LD_INT 2
34996: PUSH
34997: LD_INT 3
34999: PUSH
35000: EMPTY
35001: LIST
35002: LIST
35003: PUSH
35004: LD_INT 2
35006: NEG
35007: PUSH
35008: LD_INT 1
35010: PUSH
35011: EMPTY
35012: LIST
35013: LIST
35014: PUSH
35015: LD_INT 3
35017: NEG
35018: PUSH
35019: LD_INT 0
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: LD_INT 3
35028: NEG
35029: PUSH
35030: LD_INT 1
35032: NEG
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: PUSH
35038: LD_INT 3
35040: NEG
35041: PUSH
35042: LD_INT 2
35044: NEG
35045: PUSH
35046: EMPTY
35047: LIST
35048: LIST
35049: PUSH
35050: LD_INT 3
35052: NEG
35053: PUSH
35054: LD_INT 3
35056: NEG
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: LIST
35066: LIST
35067: LIST
35068: LIST
35069: LIST
35070: LIST
35071: LIST
35072: LIST
35073: LIST
35074: LIST
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: LIST
35085: LIST
35086: LIST
35087: LIST
35088: LIST
35089: LIST
35090: LIST
35091: LIST
35092: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35093: LD_ADDR_VAR 0 45
35097: PUSH
35098: LD_INT 0
35100: PUSH
35101: LD_INT 0
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 0
35110: PUSH
35111: LD_INT 1
35113: NEG
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 1
35121: PUSH
35122: LD_INT 0
35124: PUSH
35125: EMPTY
35126: LIST
35127: LIST
35128: PUSH
35129: LD_INT 1
35131: PUSH
35132: LD_INT 1
35134: PUSH
35135: EMPTY
35136: LIST
35137: LIST
35138: PUSH
35139: LD_INT 0
35141: PUSH
35142: LD_INT 1
35144: PUSH
35145: EMPTY
35146: LIST
35147: LIST
35148: PUSH
35149: LD_INT 1
35151: NEG
35152: PUSH
35153: LD_INT 0
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PUSH
35160: LD_INT 1
35162: NEG
35163: PUSH
35164: LD_INT 1
35166: NEG
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: PUSH
35172: LD_INT 1
35174: NEG
35175: PUSH
35176: LD_INT 2
35178: NEG
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: LD_INT 0
35186: PUSH
35187: LD_INT 2
35189: NEG
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: PUSH
35195: LD_INT 1
35197: PUSH
35198: LD_INT 1
35200: NEG
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: LD_INT 2
35208: PUSH
35209: LD_INT 1
35211: PUSH
35212: EMPTY
35213: LIST
35214: LIST
35215: PUSH
35216: LD_INT 2
35218: PUSH
35219: LD_INT 2
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: LD_INT 1
35228: PUSH
35229: LD_INT 2
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 0
35238: PUSH
35239: LD_INT 2
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 1
35248: NEG
35249: PUSH
35250: LD_INT 1
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 2
35259: NEG
35260: PUSH
35261: LD_INT 1
35263: NEG
35264: PUSH
35265: EMPTY
35266: LIST
35267: LIST
35268: PUSH
35269: LD_INT 2
35271: NEG
35272: PUSH
35273: LD_INT 2
35275: NEG
35276: PUSH
35277: EMPTY
35278: LIST
35279: LIST
35280: PUSH
35281: LD_INT 2
35283: NEG
35284: PUSH
35285: LD_INT 3
35287: NEG
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: PUSH
35293: LD_INT 1
35295: NEG
35296: PUSH
35297: LD_INT 3
35299: NEG
35300: PUSH
35301: EMPTY
35302: LIST
35303: LIST
35304: PUSH
35305: LD_INT 0
35307: PUSH
35308: LD_INT 3
35310: NEG
35311: PUSH
35312: EMPTY
35313: LIST
35314: LIST
35315: PUSH
35316: LD_INT 1
35318: PUSH
35319: LD_INT 2
35321: NEG
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 3
35329: PUSH
35330: LD_INT 2
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 3
35339: PUSH
35340: LD_INT 3
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 2
35349: PUSH
35350: LD_INT 3
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 1
35359: PUSH
35360: LD_INT 3
35362: PUSH
35363: EMPTY
35364: LIST
35365: LIST
35366: PUSH
35367: LD_INT 0
35369: PUSH
35370: LD_INT 3
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 1
35379: NEG
35380: PUSH
35381: LD_INT 2
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: LD_INT 3
35390: NEG
35391: PUSH
35392: LD_INT 2
35394: NEG
35395: PUSH
35396: EMPTY
35397: LIST
35398: LIST
35399: PUSH
35400: LD_INT 3
35402: NEG
35403: PUSH
35404: LD_INT 3
35406: NEG
35407: PUSH
35408: EMPTY
35409: LIST
35410: LIST
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: LIST
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: LIST
35436: LIST
35437: LIST
35438: LIST
35439: LIST
35440: LIST
35441: LIST
35442: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35443: LD_ADDR_VAR 0 46
35447: PUSH
35448: LD_INT 0
35450: PUSH
35451: LD_INT 0
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: LD_INT 0
35460: PUSH
35461: LD_INT 1
35463: NEG
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: LD_INT 1
35471: PUSH
35472: LD_INT 0
35474: PUSH
35475: EMPTY
35476: LIST
35477: LIST
35478: PUSH
35479: LD_INT 1
35481: PUSH
35482: LD_INT 1
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 0
35491: PUSH
35492: LD_INT 1
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: LD_INT 1
35501: NEG
35502: PUSH
35503: LD_INT 0
35505: PUSH
35506: EMPTY
35507: LIST
35508: LIST
35509: PUSH
35510: LD_INT 1
35512: NEG
35513: PUSH
35514: LD_INT 1
35516: NEG
35517: PUSH
35518: EMPTY
35519: LIST
35520: LIST
35521: PUSH
35522: LD_INT 1
35524: NEG
35525: PUSH
35526: LD_INT 2
35528: NEG
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 0
35536: PUSH
35537: LD_INT 2
35539: NEG
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 1
35547: PUSH
35548: LD_INT 1
35550: NEG
35551: PUSH
35552: EMPTY
35553: LIST
35554: LIST
35555: PUSH
35556: LD_INT 2
35558: PUSH
35559: LD_INT 0
35561: PUSH
35562: EMPTY
35563: LIST
35564: LIST
35565: PUSH
35566: LD_INT 2
35568: PUSH
35569: LD_INT 1
35571: PUSH
35572: EMPTY
35573: LIST
35574: LIST
35575: PUSH
35576: LD_INT 1
35578: PUSH
35579: LD_INT 2
35581: PUSH
35582: EMPTY
35583: LIST
35584: LIST
35585: PUSH
35586: LD_INT 0
35588: PUSH
35589: LD_INT 2
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: PUSH
35596: LD_INT 1
35598: NEG
35599: PUSH
35600: LD_INT 1
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 2
35609: NEG
35610: PUSH
35611: LD_INT 0
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: LD_INT 2
35620: NEG
35621: PUSH
35622: LD_INT 1
35624: NEG
35625: PUSH
35626: EMPTY
35627: LIST
35628: LIST
35629: PUSH
35630: LD_INT 1
35632: NEG
35633: PUSH
35634: LD_INT 3
35636: NEG
35637: PUSH
35638: EMPTY
35639: LIST
35640: LIST
35641: PUSH
35642: LD_INT 0
35644: PUSH
35645: LD_INT 3
35647: NEG
35648: PUSH
35649: EMPTY
35650: LIST
35651: LIST
35652: PUSH
35653: LD_INT 1
35655: PUSH
35656: LD_INT 2
35658: NEG
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PUSH
35664: LD_INT 2
35666: PUSH
35667: LD_INT 1
35669: NEG
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: LD_INT 3
35677: PUSH
35678: LD_INT 0
35680: PUSH
35681: EMPTY
35682: LIST
35683: LIST
35684: PUSH
35685: LD_INT 3
35687: PUSH
35688: LD_INT 1
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: LD_INT 1
35697: PUSH
35698: LD_INT 3
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 0
35707: PUSH
35708: LD_INT 3
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: LD_INT 1
35717: NEG
35718: PUSH
35719: LD_INT 2
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: PUSH
35726: LD_INT 2
35728: NEG
35729: PUSH
35730: LD_INT 1
35732: PUSH
35733: EMPTY
35734: LIST
35735: LIST
35736: PUSH
35737: LD_INT 3
35739: NEG
35740: PUSH
35741: LD_INT 0
35743: PUSH
35744: EMPTY
35745: LIST
35746: LIST
35747: PUSH
35748: LD_INT 3
35750: NEG
35751: PUSH
35752: LD_INT 1
35754: NEG
35755: PUSH
35756: EMPTY
35757: LIST
35758: LIST
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: LIST
35768: LIST
35769: LIST
35770: LIST
35771: LIST
35772: LIST
35773: LIST
35774: LIST
35775: LIST
35776: LIST
35777: LIST
35778: LIST
35779: LIST
35780: LIST
35781: LIST
35782: LIST
35783: LIST
35784: LIST
35785: LIST
35786: LIST
35787: LIST
35788: LIST
35789: LIST
35790: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35791: LD_ADDR_VAR 0 47
35795: PUSH
35796: LD_INT 0
35798: PUSH
35799: LD_INT 0
35801: PUSH
35802: EMPTY
35803: LIST
35804: LIST
35805: PUSH
35806: LD_INT 0
35808: PUSH
35809: LD_INT 1
35811: NEG
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: LD_INT 1
35819: PUSH
35820: LD_INT 0
35822: PUSH
35823: EMPTY
35824: LIST
35825: LIST
35826: PUSH
35827: LD_INT 1
35829: PUSH
35830: LD_INT 1
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: PUSH
35837: LD_INT 0
35839: PUSH
35840: LD_INT 1
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 1
35849: NEG
35850: PUSH
35851: LD_INT 0
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: PUSH
35858: LD_INT 1
35860: NEG
35861: PUSH
35862: LD_INT 1
35864: NEG
35865: PUSH
35866: EMPTY
35867: LIST
35868: LIST
35869: PUSH
35870: LD_INT 1
35872: NEG
35873: PUSH
35874: LD_INT 2
35876: NEG
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 0
35884: PUSH
35885: LD_INT 2
35887: NEG
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 1
35895: PUSH
35896: LD_INT 1
35898: NEG
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: PUSH
35904: LD_INT 2
35906: NEG
35907: PUSH
35908: LD_INT 1
35910: NEG
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 2
35918: NEG
35919: PUSH
35920: LD_INT 2
35922: NEG
35923: PUSH
35924: EMPTY
35925: LIST
35926: LIST
35927: PUSH
35928: EMPTY
35929: LIST
35930: LIST
35931: LIST
35932: LIST
35933: LIST
35934: LIST
35935: LIST
35936: LIST
35937: LIST
35938: LIST
35939: LIST
35940: LIST
35941: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
35942: LD_ADDR_VAR 0 48
35946: PUSH
35947: LD_INT 0
35949: PUSH
35950: LD_INT 0
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 0
35959: PUSH
35960: LD_INT 1
35962: NEG
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: LD_INT 1
35970: PUSH
35971: LD_INT 0
35973: PUSH
35974: EMPTY
35975: LIST
35976: LIST
35977: PUSH
35978: LD_INT 1
35980: PUSH
35981: LD_INT 1
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 0
35990: PUSH
35991: LD_INT 1
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: LD_INT 1
36000: NEG
36001: PUSH
36002: LD_INT 0
36004: PUSH
36005: EMPTY
36006: LIST
36007: LIST
36008: PUSH
36009: LD_INT 1
36011: NEG
36012: PUSH
36013: LD_INT 1
36015: NEG
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 1
36023: NEG
36024: PUSH
36025: LD_INT 2
36027: NEG
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: LD_INT 0
36035: PUSH
36036: LD_INT 2
36038: NEG
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 1
36046: PUSH
36047: LD_INT 1
36049: NEG
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 2
36057: PUSH
36058: LD_INT 0
36060: PUSH
36061: EMPTY
36062: LIST
36063: LIST
36064: PUSH
36065: LD_INT 2
36067: PUSH
36068: LD_INT 1
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: LIST
36079: LIST
36080: LIST
36081: LIST
36082: LIST
36083: LIST
36084: LIST
36085: LIST
36086: LIST
36087: LIST
36088: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36089: LD_ADDR_VAR 0 49
36093: PUSH
36094: LD_INT 0
36096: PUSH
36097: LD_INT 0
36099: PUSH
36100: EMPTY
36101: LIST
36102: LIST
36103: PUSH
36104: LD_INT 0
36106: PUSH
36107: LD_INT 1
36109: NEG
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: LD_INT 1
36117: PUSH
36118: LD_INT 0
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: PUSH
36125: LD_INT 1
36127: PUSH
36128: LD_INT 1
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 0
36137: PUSH
36138: LD_INT 1
36140: PUSH
36141: EMPTY
36142: LIST
36143: LIST
36144: PUSH
36145: LD_INT 1
36147: NEG
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 1
36158: NEG
36159: PUSH
36160: LD_INT 1
36162: NEG
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: PUSH
36168: LD_INT 1
36170: PUSH
36171: LD_INT 1
36173: NEG
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: PUSH
36179: LD_INT 2
36181: PUSH
36182: LD_INT 0
36184: PUSH
36185: EMPTY
36186: LIST
36187: LIST
36188: PUSH
36189: LD_INT 2
36191: PUSH
36192: LD_INT 1
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 2
36201: PUSH
36202: LD_INT 2
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: PUSH
36209: LD_INT 1
36211: PUSH
36212: LD_INT 2
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: LIST
36223: LIST
36224: LIST
36225: LIST
36226: LIST
36227: LIST
36228: LIST
36229: LIST
36230: LIST
36231: LIST
36232: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36233: LD_ADDR_VAR 0 50
36237: PUSH
36238: LD_INT 0
36240: PUSH
36241: LD_INT 0
36243: PUSH
36244: EMPTY
36245: LIST
36246: LIST
36247: PUSH
36248: LD_INT 0
36250: PUSH
36251: LD_INT 1
36253: NEG
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: LD_INT 0
36264: PUSH
36265: EMPTY
36266: LIST
36267: LIST
36268: PUSH
36269: LD_INT 1
36271: PUSH
36272: LD_INT 1
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 0
36281: PUSH
36282: LD_INT 1
36284: PUSH
36285: EMPTY
36286: LIST
36287: LIST
36288: PUSH
36289: LD_INT 1
36291: NEG
36292: PUSH
36293: LD_INT 0
36295: PUSH
36296: EMPTY
36297: LIST
36298: LIST
36299: PUSH
36300: LD_INT 1
36302: NEG
36303: PUSH
36304: LD_INT 1
36306: NEG
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: PUSH
36312: LD_INT 2
36314: PUSH
36315: LD_INT 1
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: PUSH
36322: LD_INT 2
36324: PUSH
36325: LD_INT 2
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 1
36334: PUSH
36335: LD_INT 2
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 0
36344: PUSH
36345: LD_INT 2
36347: PUSH
36348: EMPTY
36349: LIST
36350: LIST
36351: PUSH
36352: LD_INT 1
36354: NEG
36355: PUSH
36356: LD_INT 1
36358: PUSH
36359: EMPTY
36360: LIST
36361: LIST
36362: PUSH
36363: EMPTY
36364: LIST
36365: LIST
36366: LIST
36367: LIST
36368: LIST
36369: LIST
36370: LIST
36371: LIST
36372: LIST
36373: LIST
36374: LIST
36375: LIST
36376: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
36377: LD_ADDR_VAR 0 51
36381: PUSH
36382: LD_INT 0
36384: PUSH
36385: LD_INT 0
36387: PUSH
36388: EMPTY
36389: LIST
36390: LIST
36391: PUSH
36392: LD_INT 0
36394: PUSH
36395: LD_INT 1
36397: NEG
36398: PUSH
36399: EMPTY
36400: LIST
36401: LIST
36402: PUSH
36403: LD_INT 1
36405: PUSH
36406: LD_INT 0
36408: PUSH
36409: EMPTY
36410: LIST
36411: LIST
36412: PUSH
36413: LD_INT 1
36415: PUSH
36416: LD_INT 1
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: LD_INT 0
36425: PUSH
36426: LD_INT 1
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: LD_INT 1
36435: NEG
36436: PUSH
36437: LD_INT 0
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: LD_INT 1
36446: NEG
36447: PUSH
36448: LD_INT 1
36450: NEG
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: PUSH
36456: LD_INT 1
36458: PUSH
36459: LD_INT 2
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 0
36468: PUSH
36469: LD_INT 2
36471: PUSH
36472: EMPTY
36473: LIST
36474: LIST
36475: PUSH
36476: LD_INT 1
36478: NEG
36479: PUSH
36480: LD_INT 1
36482: PUSH
36483: EMPTY
36484: LIST
36485: LIST
36486: PUSH
36487: LD_INT 2
36489: NEG
36490: PUSH
36491: LD_INT 0
36493: PUSH
36494: EMPTY
36495: LIST
36496: LIST
36497: PUSH
36498: LD_INT 2
36500: NEG
36501: PUSH
36502: LD_INT 1
36504: NEG
36505: PUSH
36506: EMPTY
36507: LIST
36508: LIST
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: LIST
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: LIST
36522: LIST
36523: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36524: LD_ADDR_VAR 0 52
36528: PUSH
36529: LD_INT 0
36531: PUSH
36532: LD_INT 0
36534: PUSH
36535: EMPTY
36536: LIST
36537: LIST
36538: PUSH
36539: LD_INT 0
36541: PUSH
36542: LD_INT 1
36544: NEG
36545: PUSH
36546: EMPTY
36547: LIST
36548: LIST
36549: PUSH
36550: LD_INT 1
36552: PUSH
36553: LD_INT 0
36555: PUSH
36556: EMPTY
36557: LIST
36558: LIST
36559: PUSH
36560: LD_INT 1
36562: PUSH
36563: LD_INT 1
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: PUSH
36570: LD_INT 0
36572: PUSH
36573: LD_INT 1
36575: PUSH
36576: EMPTY
36577: LIST
36578: LIST
36579: PUSH
36580: LD_INT 1
36582: NEG
36583: PUSH
36584: LD_INT 0
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: PUSH
36591: LD_INT 1
36593: NEG
36594: PUSH
36595: LD_INT 1
36597: NEG
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 1
36605: NEG
36606: PUSH
36607: LD_INT 2
36609: NEG
36610: PUSH
36611: EMPTY
36612: LIST
36613: LIST
36614: PUSH
36615: LD_INT 1
36617: NEG
36618: PUSH
36619: LD_INT 1
36621: PUSH
36622: EMPTY
36623: LIST
36624: LIST
36625: PUSH
36626: LD_INT 2
36628: NEG
36629: PUSH
36630: LD_INT 0
36632: PUSH
36633: EMPTY
36634: LIST
36635: LIST
36636: PUSH
36637: LD_INT 2
36639: NEG
36640: PUSH
36641: LD_INT 1
36643: NEG
36644: PUSH
36645: EMPTY
36646: LIST
36647: LIST
36648: PUSH
36649: LD_INT 2
36651: NEG
36652: PUSH
36653: LD_INT 2
36655: NEG
36656: PUSH
36657: EMPTY
36658: LIST
36659: LIST
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36675: LD_ADDR_VAR 0 53
36679: PUSH
36680: LD_INT 0
36682: PUSH
36683: LD_INT 0
36685: PUSH
36686: EMPTY
36687: LIST
36688: LIST
36689: PUSH
36690: LD_INT 0
36692: PUSH
36693: LD_INT 1
36695: NEG
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PUSH
36701: LD_INT 1
36703: PUSH
36704: LD_INT 0
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 1
36713: PUSH
36714: LD_INT 1
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: PUSH
36721: LD_INT 0
36723: PUSH
36724: LD_INT 1
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: PUSH
36731: LD_INT 1
36733: NEG
36734: PUSH
36735: LD_INT 0
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 1
36744: NEG
36745: PUSH
36746: LD_INT 1
36748: NEG
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: PUSH
36754: LD_INT 1
36756: NEG
36757: PUSH
36758: LD_INT 2
36760: NEG
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: LD_INT 0
36768: PUSH
36769: LD_INT 2
36771: NEG
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: PUSH
36777: LD_INT 1
36779: PUSH
36780: LD_INT 1
36782: NEG
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 2
36790: PUSH
36791: LD_INT 0
36793: PUSH
36794: EMPTY
36795: LIST
36796: LIST
36797: PUSH
36798: LD_INT 2
36800: PUSH
36801: LD_INT 1
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: PUSH
36808: LD_INT 2
36810: PUSH
36811: LD_INT 2
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 1
36820: PUSH
36821: LD_INT 2
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: PUSH
36828: LD_INT 0
36830: PUSH
36831: LD_INT 2
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: LD_INT 1
36840: NEG
36841: PUSH
36842: LD_INT 1
36844: PUSH
36845: EMPTY
36846: LIST
36847: LIST
36848: PUSH
36849: LD_INT 2
36851: NEG
36852: PUSH
36853: LD_INT 0
36855: PUSH
36856: EMPTY
36857: LIST
36858: LIST
36859: PUSH
36860: LD_INT 2
36862: NEG
36863: PUSH
36864: LD_INT 1
36866: NEG
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 2
36874: NEG
36875: PUSH
36876: LD_INT 2
36878: NEG
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: LIST
36888: LIST
36889: LIST
36890: LIST
36891: LIST
36892: LIST
36893: LIST
36894: LIST
36895: LIST
36896: LIST
36897: LIST
36898: LIST
36899: LIST
36900: LIST
36901: LIST
36902: LIST
36903: LIST
36904: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36905: LD_ADDR_VAR 0 54
36909: PUSH
36910: LD_INT 0
36912: PUSH
36913: LD_INT 0
36915: PUSH
36916: EMPTY
36917: LIST
36918: LIST
36919: PUSH
36920: LD_INT 0
36922: PUSH
36923: LD_INT 1
36925: NEG
36926: PUSH
36927: EMPTY
36928: LIST
36929: LIST
36930: PUSH
36931: LD_INT 1
36933: PUSH
36934: LD_INT 0
36936: PUSH
36937: EMPTY
36938: LIST
36939: LIST
36940: PUSH
36941: LD_INT 1
36943: PUSH
36944: LD_INT 1
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: LD_INT 0
36953: PUSH
36954: LD_INT 1
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 1
36963: NEG
36964: PUSH
36965: LD_INT 0
36967: PUSH
36968: EMPTY
36969: LIST
36970: LIST
36971: PUSH
36972: LD_INT 1
36974: NEG
36975: PUSH
36976: LD_INT 1
36978: NEG
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 1
36986: NEG
36987: PUSH
36988: LD_INT 2
36990: NEG
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 0
36998: PUSH
36999: LD_INT 2
37001: NEG
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: PUSH
37007: LD_INT 1
37009: PUSH
37010: LD_INT 1
37012: NEG
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: PUSH
37018: LD_INT 2
37020: PUSH
37021: LD_INT 0
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 2
37030: PUSH
37031: LD_INT 1
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: PUSH
37038: LD_INT 2
37040: PUSH
37041: LD_INT 2
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 1
37050: PUSH
37051: LD_INT 2
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: LD_INT 0
37060: PUSH
37061: LD_INT 2
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 1
37070: NEG
37071: PUSH
37072: LD_INT 1
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 2
37081: NEG
37082: PUSH
37083: LD_INT 0
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 2
37092: NEG
37093: PUSH
37094: LD_INT 1
37096: NEG
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 2
37104: NEG
37105: PUSH
37106: LD_INT 2
37108: NEG
37109: PUSH
37110: EMPTY
37111: LIST
37112: LIST
37113: PUSH
37114: EMPTY
37115: LIST
37116: LIST
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: LIST
37124: LIST
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: LIST
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37135: LD_ADDR_VAR 0 55
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: LD_INT 0
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 0
37152: PUSH
37153: LD_INT 1
37155: NEG
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 1
37163: PUSH
37164: LD_INT 0
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 1
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: LD_INT 1
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 1
37193: NEG
37194: PUSH
37195: LD_INT 0
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 1
37204: NEG
37205: PUSH
37206: LD_INT 1
37208: NEG
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 1
37216: NEG
37217: PUSH
37218: LD_INT 2
37220: NEG
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 0
37228: PUSH
37229: LD_INT 2
37231: NEG
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: PUSH
37237: LD_INT 1
37239: PUSH
37240: LD_INT 1
37242: NEG
37243: PUSH
37244: EMPTY
37245: LIST
37246: LIST
37247: PUSH
37248: LD_INT 2
37250: PUSH
37251: LD_INT 0
37253: PUSH
37254: EMPTY
37255: LIST
37256: LIST
37257: PUSH
37258: LD_INT 2
37260: PUSH
37261: LD_INT 1
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 2
37270: PUSH
37271: LD_INT 2
37273: PUSH
37274: EMPTY
37275: LIST
37276: LIST
37277: PUSH
37278: LD_INT 1
37280: PUSH
37281: LD_INT 2
37283: PUSH
37284: EMPTY
37285: LIST
37286: LIST
37287: PUSH
37288: LD_INT 0
37290: PUSH
37291: LD_INT 2
37293: PUSH
37294: EMPTY
37295: LIST
37296: LIST
37297: PUSH
37298: LD_INT 1
37300: NEG
37301: PUSH
37302: LD_INT 1
37304: PUSH
37305: EMPTY
37306: LIST
37307: LIST
37308: PUSH
37309: LD_INT 2
37311: NEG
37312: PUSH
37313: LD_INT 0
37315: PUSH
37316: EMPTY
37317: LIST
37318: LIST
37319: PUSH
37320: LD_INT 2
37322: NEG
37323: PUSH
37324: LD_INT 1
37326: NEG
37327: PUSH
37328: EMPTY
37329: LIST
37330: LIST
37331: PUSH
37332: LD_INT 2
37334: NEG
37335: PUSH
37336: LD_INT 2
37338: NEG
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: EMPTY
37345: LIST
37346: LIST
37347: LIST
37348: LIST
37349: LIST
37350: LIST
37351: LIST
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37365: LD_ADDR_VAR 0 56
37369: PUSH
37370: LD_INT 0
37372: PUSH
37373: LD_INT 0
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: LD_INT 0
37382: PUSH
37383: LD_INT 1
37385: NEG
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 1
37393: PUSH
37394: LD_INT 0
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: LD_INT 1
37403: PUSH
37404: LD_INT 1
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: LD_INT 0
37413: PUSH
37414: LD_INT 1
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: PUSH
37421: LD_INT 1
37423: NEG
37424: PUSH
37425: LD_INT 0
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: LD_INT 1
37438: NEG
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: PUSH
37444: LD_INT 1
37446: NEG
37447: PUSH
37448: LD_INT 2
37450: NEG
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 0
37458: PUSH
37459: LD_INT 2
37461: NEG
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 1
37469: PUSH
37470: LD_INT 1
37472: NEG
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 2
37480: PUSH
37481: LD_INT 0
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: LD_INT 2
37490: PUSH
37491: LD_INT 1
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 2
37500: PUSH
37501: LD_INT 2
37503: PUSH
37504: EMPTY
37505: LIST
37506: LIST
37507: PUSH
37508: LD_INT 1
37510: PUSH
37511: LD_INT 2
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 0
37520: PUSH
37521: LD_INT 2
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: LD_INT 1
37530: NEG
37531: PUSH
37532: LD_INT 1
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: LD_INT 2
37541: NEG
37542: PUSH
37543: LD_INT 0
37545: PUSH
37546: EMPTY
37547: LIST
37548: LIST
37549: PUSH
37550: LD_INT 2
37552: NEG
37553: PUSH
37554: LD_INT 1
37556: NEG
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 2
37564: NEG
37565: PUSH
37566: LD_INT 2
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: LIST
37591: LIST
37592: LIST
37593: LIST
37594: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37595: LD_ADDR_VAR 0 57
37599: PUSH
37600: LD_INT 0
37602: PUSH
37603: LD_INT 0
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 0
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: PUSH
37624: LD_INT 0
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 1
37633: PUSH
37634: LD_INT 1
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 0
37643: PUSH
37644: LD_INT 1
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 1
37653: NEG
37654: PUSH
37655: LD_INT 0
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 1
37664: NEG
37665: PUSH
37666: LD_INT 1
37668: NEG
37669: PUSH
37670: EMPTY
37671: LIST
37672: LIST
37673: PUSH
37674: LD_INT 1
37676: NEG
37677: PUSH
37678: LD_INT 2
37680: NEG
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: LD_INT 0
37688: PUSH
37689: LD_INT 2
37691: NEG
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 1
37699: PUSH
37700: LD_INT 1
37702: NEG
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: LD_INT 2
37710: PUSH
37711: LD_INT 0
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: LD_INT 2
37720: PUSH
37721: LD_INT 1
37723: PUSH
37724: EMPTY
37725: LIST
37726: LIST
37727: PUSH
37728: LD_INT 2
37730: PUSH
37731: LD_INT 2
37733: PUSH
37734: EMPTY
37735: LIST
37736: LIST
37737: PUSH
37738: LD_INT 1
37740: PUSH
37741: LD_INT 2
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: LD_INT 2
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 1
37760: NEG
37761: PUSH
37762: LD_INT 1
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 2
37771: NEG
37772: PUSH
37773: LD_INT 0
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: LD_INT 2
37782: NEG
37783: PUSH
37784: LD_INT 1
37786: NEG
37787: PUSH
37788: EMPTY
37789: LIST
37790: LIST
37791: PUSH
37792: LD_INT 2
37794: NEG
37795: PUSH
37796: LD_INT 2
37798: NEG
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: LIST
37810: LIST
37811: LIST
37812: LIST
37813: LIST
37814: LIST
37815: LIST
37816: LIST
37817: LIST
37818: LIST
37819: LIST
37820: LIST
37821: LIST
37822: LIST
37823: LIST
37824: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37825: LD_ADDR_VAR 0 58
37829: PUSH
37830: LD_INT 0
37832: PUSH
37833: LD_INT 0
37835: PUSH
37836: EMPTY
37837: LIST
37838: LIST
37839: PUSH
37840: LD_INT 0
37842: PUSH
37843: LD_INT 1
37845: NEG
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 1
37853: PUSH
37854: LD_INT 0
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 1
37863: PUSH
37864: LD_INT 1
37866: PUSH
37867: EMPTY
37868: LIST
37869: LIST
37870: PUSH
37871: LD_INT 0
37873: PUSH
37874: LD_INT 1
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 1
37883: NEG
37884: PUSH
37885: LD_INT 0
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: LD_INT 1
37894: NEG
37895: PUSH
37896: LD_INT 1
37898: NEG
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 1
37906: NEG
37907: PUSH
37908: LD_INT 2
37910: NEG
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 0
37918: PUSH
37919: LD_INT 2
37921: NEG
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: LD_INT 1
37929: PUSH
37930: LD_INT 1
37932: NEG
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 2
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 2
37950: PUSH
37951: LD_INT 1
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: LD_INT 2
37960: PUSH
37961: LD_INT 2
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 1
37970: PUSH
37971: LD_INT 2
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 0
37980: PUSH
37981: LD_INT 2
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: PUSH
37988: LD_INT 1
37990: NEG
37991: PUSH
37992: LD_INT 1
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 2
38001: NEG
38002: PUSH
38003: LD_INT 0
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 2
38012: NEG
38013: PUSH
38014: LD_INT 1
38016: NEG
38017: PUSH
38018: EMPTY
38019: LIST
38020: LIST
38021: PUSH
38022: LD_INT 2
38024: NEG
38025: PUSH
38026: LD_INT 2
38028: NEG
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38055: LD_ADDR_VAR 0 59
38059: PUSH
38060: LD_INT 0
38062: PUSH
38063: LD_INT 0
38065: PUSH
38066: EMPTY
38067: LIST
38068: LIST
38069: PUSH
38070: LD_INT 0
38072: PUSH
38073: LD_INT 1
38075: NEG
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 1
38083: PUSH
38084: LD_INT 0
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 1
38093: PUSH
38094: LD_INT 1
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: LD_INT 0
38103: PUSH
38104: LD_INT 1
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: LD_INT 1
38113: NEG
38114: PUSH
38115: LD_INT 0
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 1
38124: NEG
38125: PUSH
38126: LD_INT 1
38128: NEG
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: EMPTY
38135: LIST
38136: LIST
38137: LIST
38138: LIST
38139: LIST
38140: LIST
38141: LIST
38142: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38143: LD_ADDR_VAR 0 60
38147: PUSH
38148: LD_INT 0
38150: PUSH
38151: LD_INT 0
38153: PUSH
38154: EMPTY
38155: LIST
38156: LIST
38157: PUSH
38158: LD_INT 0
38160: PUSH
38161: LD_INT 1
38163: NEG
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: LD_INT 1
38171: PUSH
38172: LD_INT 0
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 1
38181: PUSH
38182: LD_INT 1
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 0
38191: PUSH
38192: LD_INT 1
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 1
38201: NEG
38202: PUSH
38203: LD_INT 0
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 1
38212: NEG
38213: PUSH
38214: LD_INT 1
38216: NEG
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: LIST
38226: LIST
38227: LIST
38228: LIST
38229: LIST
38230: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38231: LD_ADDR_VAR 0 61
38235: PUSH
38236: LD_INT 0
38238: PUSH
38239: LD_INT 0
38241: PUSH
38242: EMPTY
38243: LIST
38244: LIST
38245: PUSH
38246: LD_INT 0
38248: PUSH
38249: LD_INT 1
38251: NEG
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PUSH
38257: LD_INT 1
38259: PUSH
38260: LD_INT 0
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 1
38269: PUSH
38270: LD_INT 1
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: LD_INT 0
38279: PUSH
38280: LD_INT 1
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: LD_INT 1
38289: NEG
38290: PUSH
38291: LD_INT 0
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 1
38300: NEG
38301: PUSH
38302: LD_INT 1
38304: NEG
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: LIST
38314: LIST
38315: LIST
38316: LIST
38317: LIST
38318: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38319: LD_ADDR_VAR 0 62
38323: PUSH
38324: LD_INT 0
38326: PUSH
38327: LD_INT 0
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: PUSH
38334: LD_INT 0
38336: PUSH
38337: LD_INT 1
38339: NEG
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: PUSH
38345: LD_INT 1
38347: PUSH
38348: LD_INT 0
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: PUSH
38355: LD_INT 1
38357: PUSH
38358: LD_INT 1
38360: PUSH
38361: EMPTY
38362: LIST
38363: LIST
38364: PUSH
38365: LD_INT 0
38367: PUSH
38368: LD_INT 1
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 1
38377: NEG
38378: PUSH
38379: LD_INT 0
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: PUSH
38386: LD_INT 1
38388: NEG
38389: PUSH
38390: LD_INT 1
38392: NEG
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38407: LD_ADDR_VAR 0 63
38411: PUSH
38412: LD_INT 0
38414: PUSH
38415: LD_INT 0
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 0
38424: PUSH
38425: LD_INT 1
38427: NEG
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: PUSH
38433: LD_INT 1
38435: PUSH
38436: LD_INT 0
38438: PUSH
38439: EMPTY
38440: LIST
38441: LIST
38442: PUSH
38443: LD_INT 1
38445: PUSH
38446: LD_INT 1
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 0
38455: PUSH
38456: LD_INT 1
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 1
38465: NEG
38466: PUSH
38467: LD_INT 0
38469: PUSH
38470: EMPTY
38471: LIST
38472: LIST
38473: PUSH
38474: LD_INT 1
38476: NEG
38477: PUSH
38478: LD_INT 1
38480: NEG
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: LIST
38490: LIST
38491: LIST
38492: LIST
38493: LIST
38494: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38495: LD_ADDR_VAR 0 64
38499: PUSH
38500: LD_INT 0
38502: PUSH
38503: LD_INT 0
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 0
38512: PUSH
38513: LD_INT 1
38515: NEG
38516: PUSH
38517: EMPTY
38518: LIST
38519: LIST
38520: PUSH
38521: LD_INT 1
38523: PUSH
38524: LD_INT 0
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: LD_INT 1
38533: PUSH
38534: LD_INT 1
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 0
38543: PUSH
38544: LD_INT 1
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 1
38553: NEG
38554: PUSH
38555: LD_INT 0
38557: PUSH
38558: EMPTY
38559: LIST
38560: LIST
38561: PUSH
38562: LD_INT 1
38564: NEG
38565: PUSH
38566: LD_INT 1
38568: NEG
38569: PUSH
38570: EMPTY
38571: LIST
38572: LIST
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: LIST
38578: LIST
38579: LIST
38580: LIST
38581: LIST
38582: ST_TO_ADDR
// end ; 1 :
38583: GO 44480
38585: LD_INT 1
38587: DOUBLE
38588: EQUAL
38589: IFTRUE 38593
38591: GO 41216
38593: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38594: LD_ADDR_VAR 0 11
38598: PUSH
38599: LD_INT 1
38601: NEG
38602: PUSH
38603: LD_INT 3
38605: NEG
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: PUSH
38611: LD_INT 0
38613: PUSH
38614: LD_INT 3
38616: NEG
38617: PUSH
38618: EMPTY
38619: LIST
38620: LIST
38621: PUSH
38622: LD_INT 1
38624: PUSH
38625: LD_INT 2
38627: NEG
38628: PUSH
38629: EMPTY
38630: LIST
38631: LIST
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: LIST
38637: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38638: LD_ADDR_VAR 0 12
38642: PUSH
38643: LD_INT 2
38645: PUSH
38646: LD_INT 1
38648: NEG
38649: PUSH
38650: EMPTY
38651: LIST
38652: LIST
38653: PUSH
38654: LD_INT 3
38656: PUSH
38657: LD_INT 0
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: PUSH
38664: LD_INT 3
38666: PUSH
38667: LD_INT 1
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: LIST
38678: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38679: LD_ADDR_VAR 0 13
38683: PUSH
38684: LD_INT 3
38686: PUSH
38687: LD_INT 2
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 3
38696: PUSH
38697: LD_INT 3
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: LD_INT 2
38706: PUSH
38707: LD_INT 3
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: LIST
38718: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38719: LD_ADDR_VAR 0 14
38723: PUSH
38724: LD_INT 1
38726: PUSH
38727: LD_INT 3
38729: PUSH
38730: EMPTY
38731: LIST
38732: LIST
38733: PUSH
38734: LD_INT 0
38736: PUSH
38737: LD_INT 3
38739: PUSH
38740: EMPTY
38741: LIST
38742: LIST
38743: PUSH
38744: LD_INT 1
38746: NEG
38747: PUSH
38748: LD_INT 2
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: LIST
38759: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38760: LD_ADDR_VAR 0 15
38764: PUSH
38765: LD_INT 2
38767: NEG
38768: PUSH
38769: LD_INT 1
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 3
38778: NEG
38779: PUSH
38780: LD_INT 0
38782: PUSH
38783: EMPTY
38784: LIST
38785: LIST
38786: PUSH
38787: LD_INT 3
38789: NEG
38790: PUSH
38791: LD_INT 1
38793: NEG
38794: PUSH
38795: EMPTY
38796: LIST
38797: LIST
38798: PUSH
38799: EMPTY
38800: LIST
38801: LIST
38802: LIST
38803: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38804: LD_ADDR_VAR 0 16
38808: PUSH
38809: LD_INT 2
38811: NEG
38812: PUSH
38813: LD_INT 3
38815: NEG
38816: PUSH
38817: EMPTY
38818: LIST
38819: LIST
38820: PUSH
38821: LD_INT 3
38823: NEG
38824: PUSH
38825: LD_INT 2
38827: NEG
38828: PUSH
38829: EMPTY
38830: LIST
38831: LIST
38832: PUSH
38833: LD_INT 3
38835: NEG
38836: PUSH
38837: LD_INT 3
38839: NEG
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: LIST
38849: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38850: LD_ADDR_VAR 0 17
38854: PUSH
38855: LD_INT 1
38857: NEG
38858: PUSH
38859: LD_INT 3
38861: NEG
38862: PUSH
38863: EMPTY
38864: LIST
38865: LIST
38866: PUSH
38867: LD_INT 0
38869: PUSH
38870: LD_INT 3
38872: NEG
38873: PUSH
38874: EMPTY
38875: LIST
38876: LIST
38877: PUSH
38878: LD_INT 1
38880: PUSH
38881: LD_INT 2
38883: NEG
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: EMPTY
38890: LIST
38891: LIST
38892: LIST
38893: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38894: LD_ADDR_VAR 0 18
38898: PUSH
38899: LD_INT 2
38901: PUSH
38902: LD_INT 1
38904: NEG
38905: PUSH
38906: EMPTY
38907: LIST
38908: LIST
38909: PUSH
38910: LD_INT 3
38912: PUSH
38913: LD_INT 0
38915: PUSH
38916: EMPTY
38917: LIST
38918: LIST
38919: PUSH
38920: LD_INT 3
38922: PUSH
38923: LD_INT 1
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: LIST
38934: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38935: LD_ADDR_VAR 0 19
38939: PUSH
38940: LD_INT 3
38942: PUSH
38943: LD_INT 2
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: LD_INT 3
38952: PUSH
38953: LD_INT 3
38955: PUSH
38956: EMPTY
38957: LIST
38958: LIST
38959: PUSH
38960: LD_INT 2
38962: PUSH
38963: LD_INT 3
38965: PUSH
38966: EMPTY
38967: LIST
38968: LIST
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: LIST
38974: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38975: LD_ADDR_VAR 0 20
38979: PUSH
38980: LD_INT 1
38982: PUSH
38983: LD_INT 3
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 0
38992: PUSH
38993: LD_INT 3
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: LD_INT 1
39002: NEG
39003: PUSH
39004: LD_INT 2
39006: PUSH
39007: EMPTY
39008: LIST
39009: LIST
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: LIST
39015: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39016: LD_ADDR_VAR 0 21
39020: PUSH
39021: LD_INT 2
39023: NEG
39024: PUSH
39025: LD_INT 1
39027: PUSH
39028: EMPTY
39029: LIST
39030: LIST
39031: PUSH
39032: LD_INT 3
39034: NEG
39035: PUSH
39036: LD_INT 0
39038: PUSH
39039: EMPTY
39040: LIST
39041: LIST
39042: PUSH
39043: LD_INT 3
39045: NEG
39046: PUSH
39047: LD_INT 1
39049: NEG
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: EMPTY
39056: LIST
39057: LIST
39058: LIST
39059: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39060: LD_ADDR_VAR 0 22
39064: PUSH
39065: LD_INT 2
39067: NEG
39068: PUSH
39069: LD_INT 3
39071: NEG
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 3
39079: NEG
39080: PUSH
39081: LD_INT 2
39083: NEG
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: LD_INT 3
39091: NEG
39092: PUSH
39093: LD_INT 3
39095: NEG
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: EMPTY
39102: LIST
39103: LIST
39104: LIST
39105: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39106: LD_ADDR_VAR 0 23
39110: PUSH
39111: LD_INT 0
39113: PUSH
39114: LD_INT 3
39116: NEG
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 1
39124: NEG
39125: PUSH
39126: LD_INT 4
39128: NEG
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 1
39136: PUSH
39137: LD_INT 3
39139: NEG
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: LIST
39149: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39150: LD_ADDR_VAR 0 24
39154: PUSH
39155: LD_INT 3
39157: PUSH
39158: LD_INT 0
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: PUSH
39165: LD_INT 3
39167: PUSH
39168: LD_INT 1
39170: NEG
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: LD_INT 4
39178: PUSH
39179: LD_INT 1
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: LIST
39190: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39191: LD_ADDR_VAR 0 25
39195: PUSH
39196: LD_INT 3
39198: PUSH
39199: LD_INT 3
39201: PUSH
39202: EMPTY
39203: LIST
39204: LIST
39205: PUSH
39206: LD_INT 4
39208: PUSH
39209: LD_INT 3
39211: PUSH
39212: EMPTY
39213: LIST
39214: LIST
39215: PUSH
39216: LD_INT 3
39218: PUSH
39219: LD_INT 4
39221: PUSH
39222: EMPTY
39223: LIST
39224: LIST
39225: PUSH
39226: EMPTY
39227: LIST
39228: LIST
39229: LIST
39230: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39231: LD_ADDR_VAR 0 26
39235: PUSH
39236: LD_INT 0
39238: PUSH
39239: LD_INT 3
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 1
39248: PUSH
39249: LD_INT 4
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 1
39258: NEG
39259: PUSH
39260: LD_INT 3
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: EMPTY
39268: LIST
39269: LIST
39270: LIST
39271: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
39272: LD_ADDR_VAR 0 27
39276: PUSH
39277: LD_INT 3
39279: NEG
39280: PUSH
39281: LD_INT 0
39283: PUSH
39284: EMPTY
39285: LIST
39286: LIST
39287: PUSH
39288: LD_INT 3
39290: NEG
39291: PUSH
39292: LD_INT 1
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: LD_INT 4
39301: NEG
39302: PUSH
39303: LD_INT 1
39305: NEG
39306: PUSH
39307: EMPTY
39308: LIST
39309: LIST
39310: PUSH
39311: EMPTY
39312: LIST
39313: LIST
39314: LIST
39315: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
39316: LD_ADDR_VAR 0 28
39320: PUSH
39321: LD_INT 3
39323: NEG
39324: PUSH
39325: LD_INT 3
39327: NEG
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 3
39335: NEG
39336: PUSH
39337: LD_INT 4
39339: NEG
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 4
39347: NEG
39348: PUSH
39349: LD_INT 3
39351: NEG
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: EMPTY
39358: LIST
39359: LIST
39360: LIST
39361: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
39362: LD_ADDR_VAR 0 29
39366: PUSH
39367: LD_INT 1
39369: NEG
39370: PUSH
39371: LD_INT 3
39373: NEG
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 0
39381: PUSH
39382: LD_INT 3
39384: NEG
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 1
39392: PUSH
39393: LD_INT 2
39395: NEG
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 1
39403: NEG
39404: PUSH
39405: LD_INT 4
39407: NEG
39408: PUSH
39409: EMPTY
39410: LIST
39411: LIST
39412: PUSH
39413: LD_INT 0
39415: PUSH
39416: LD_INT 4
39418: NEG
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: PUSH
39424: LD_INT 1
39426: PUSH
39427: LD_INT 3
39429: NEG
39430: PUSH
39431: EMPTY
39432: LIST
39433: LIST
39434: PUSH
39435: LD_INT 1
39437: NEG
39438: PUSH
39439: LD_INT 5
39441: NEG
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 0
39449: PUSH
39450: LD_INT 5
39452: NEG
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: LD_INT 1
39460: PUSH
39461: LD_INT 4
39463: NEG
39464: PUSH
39465: EMPTY
39466: LIST
39467: LIST
39468: PUSH
39469: LD_INT 1
39471: NEG
39472: PUSH
39473: LD_INT 6
39475: NEG
39476: PUSH
39477: EMPTY
39478: LIST
39479: LIST
39480: PUSH
39481: LD_INT 0
39483: PUSH
39484: LD_INT 6
39486: NEG
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 1
39494: PUSH
39495: LD_INT 5
39497: NEG
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: LIST
39507: LIST
39508: LIST
39509: LIST
39510: LIST
39511: LIST
39512: LIST
39513: LIST
39514: LIST
39515: LIST
39516: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
39517: LD_ADDR_VAR 0 30
39521: PUSH
39522: LD_INT 2
39524: PUSH
39525: LD_INT 1
39527: NEG
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 3
39535: PUSH
39536: LD_INT 0
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 3
39545: PUSH
39546: LD_INT 1
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 3
39555: PUSH
39556: LD_INT 1
39558: NEG
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 4
39566: PUSH
39567: LD_INT 0
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: LD_INT 4
39576: PUSH
39577: LD_INT 1
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 4
39586: PUSH
39587: LD_INT 1
39589: NEG
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: PUSH
39595: LD_INT 5
39597: PUSH
39598: LD_INT 0
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 5
39607: PUSH
39608: LD_INT 1
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 5
39617: PUSH
39618: LD_INT 1
39620: NEG
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: LD_INT 6
39628: PUSH
39629: LD_INT 0
39631: PUSH
39632: EMPTY
39633: LIST
39634: LIST
39635: PUSH
39636: LD_INT 6
39638: PUSH
39639: LD_INT 1
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: EMPTY
39647: LIST
39648: LIST
39649: LIST
39650: LIST
39651: LIST
39652: LIST
39653: LIST
39654: LIST
39655: LIST
39656: LIST
39657: LIST
39658: LIST
39659: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
39660: LD_ADDR_VAR 0 31
39664: PUSH
39665: LD_INT 3
39667: PUSH
39668: LD_INT 2
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PUSH
39675: LD_INT 3
39677: PUSH
39678: LD_INT 3
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 2
39687: PUSH
39688: LD_INT 3
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 4
39697: PUSH
39698: LD_INT 3
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 4
39707: PUSH
39708: LD_INT 4
39710: PUSH
39711: EMPTY
39712: LIST
39713: LIST
39714: PUSH
39715: LD_INT 3
39717: PUSH
39718: LD_INT 4
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PUSH
39725: LD_INT 5
39727: PUSH
39728: LD_INT 4
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 5
39737: PUSH
39738: LD_INT 5
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: LD_INT 4
39747: PUSH
39748: LD_INT 5
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: PUSH
39755: LD_INT 6
39757: PUSH
39758: LD_INT 5
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: LD_INT 6
39767: PUSH
39768: LD_INT 6
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: LD_INT 5
39777: PUSH
39778: LD_INT 6
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: LIST
39789: LIST
39790: LIST
39791: LIST
39792: LIST
39793: LIST
39794: LIST
39795: LIST
39796: LIST
39797: LIST
39798: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
39799: LD_ADDR_VAR 0 32
39803: PUSH
39804: LD_INT 1
39806: PUSH
39807: LD_INT 3
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 0
39816: PUSH
39817: LD_INT 3
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 1
39826: NEG
39827: PUSH
39828: LD_INT 2
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: LD_INT 1
39837: PUSH
39838: LD_INT 4
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 0
39847: PUSH
39848: LD_INT 4
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 1
39857: NEG
39858: PUSH
39859: LD_INT 3
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 1
39868: PUSH
39869: LD_INT 5
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: LD_INT 0
39878: PUSH
39879: LD_INT 5
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 1
39888: NEG
39889: PUSH
39890: LD_INT 4
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 1
39899: PUSH
39900: LD_INT 6
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 0
39909: PUSH
39910: LD_INT 6
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 1
39919: NEG
39920: PUSH
39921: LD_INT 5
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: LIST
39932: LIST
39933: LIST
39934: LIST
39935: LIST
39936: LIST
39937: LIST
39938: LIST
39939: LIST
39940: LIST
39941: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
39942: LD_ADDR_VAR 0 33
39946: PUSH
39947: LD_INT 2
39949: NEG
39950: PUSH
39951: LD_INT 1
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: PUSH
39958: LD_INT 3
39960: NEG
39961: PUSH
39962: LD_INT 0
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: PUSH
39969: LD_INT 3
39971: NEG
39972: PUSH
39973: LD_INT 1
39975: NEG
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 3
39983: NEG
39984: PUSH
39985: LD_INT 1
39987: PUSH
39988: EMPTY
39989: LIST
39990: LIST
39991: PUSH
39992: LD_INT 4
39994: NEG
39995: PUSH
39996: LD_INT 0
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 4
40005: NEG
40006: PUSH
40007: LD_INT 1
40009: NEG
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: LD_INT 4
40017: NEG
40018: PUSH
40019: LD_INT 1
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 5
40028: NEG
40029: PUSH
40030: LD_INT 0
40032: PUSH
40033: EMPTY
40034: LIST
40035: LIST
40036: PUSH
40037: LD_INT 5
40039: NEG
40040: PUSH
40041: LD_INT 1
40043: NEG
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 5
40051: NEG
40052: PUSH
40053: LD_INT 1
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: PUSH
40060: LD_INT 6
40062: NEG
40063: PUSH
40064: LD_INT 0
40066: PUSH
40067: EMPTY
40068: LIST
40069: LIST
40070: PUSH
40071: LD_INT 6
40073: NEG
40074: PUSH
40075: LD_INT 1
40077: NEG
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: LIST
40087: LIST
40088: LIST
40089: LIST
40090: LIST
40091: LIST
40092: LIST
40093: LIST
40094: LIST
40095: LIST
40096: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40097: LD_ADDR_VAR 0 34
40101: PUSH
40102: LD_INT 2
40104: NEG
40105: PUSH
40106: LD_INT 3
40108: NEG
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: LD_INT 3
40116: NEG
40117: PUSH
40118: LD_INT 2
40120: NEG
40121: PUSH
40122: EMPTY
40123: LIST
40124: LIST
40125: PUSH
40126: LD_INT 3
40128: NEG
40129: PUSH
40130: LD_INT 3
40132: NEG
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: LD_INT 3
40140: NEG
40141: PUSH
40142: LD_INT 4
40144: NEG
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PUSH
40150: LD_INT 4
40152: NEG
40153: PUSH
40154: LD_INT 3
40156: NEG
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 4
40164: NEG
40165: PUSH
40166: LD_INT 4
40168: NEG
40169: PUSH
40170: EMPTY
40171: LIST
40172: LIST
40173: PUSH
40174: LD_INT 4
40176: NEG
40177: PUSH
40178: LD_INT 5
40180: NEG
40181: PUSH
40182: EMPTY
40183: LIST
40184: LIST
40185: PUSH
40186: LD_INT 5
40188: NEG
40189: PUSH
40190: LD_INT 4
40192: NEG
40193: PUSH
40194: EMPTY
40195: LIST
40196: LIST
40197: PUSH
40198: LD_INT 5
40200: NEG
40201: PUSH
40202: LD_INT 5
40204: NEG
40205: PUSH
40206: EMPTY
40207: LIST
40208: LIST
40209: PUSH
40210: LD_INT 5
40212: NEG
40213: PUSH
40214: LD_INT 6
40216: NEG
40217: PUSH
40218: EMPTY
40219: LIST
40220: LIST
40221: PUSH
40222: LD_INT 6
40224: NEG
40225: PUSH
40226: LD_INT 5
40228: NEG
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 6
40236: NEG
40237: PUSH
40238: LD_INT 6
40240: NEG
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: LIST
40250: LIST
40251: LIST
40252: LIST
40253: LIST
40254: LIST
40255: LIST
40256: LIST
40257: LIST
40258: LIST
40259: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
40260: LD_ADDR_VAR 0 41
40264: PUSH
40265: LD_INT 0
40267: PUSH
40268: LD_INT 2
40270: NEG
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PUSH
40276: LD_INT 1
40278: NEG
40279: PUSH
40280: LD_INT 3
40282: NEG
40283: PUSH
40284: EMPTY
40285: LIST
40286: LIST
40287: PUSH
40288: LD_INT 1
40290: PUSH
40291: LD_INT 2
40293: NEG
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: EMPTY
40300: LIST
40301: LIST
40302: LIST
40303: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
40304: LD_ADDR_VAR 0 42
40308: PUSH
40309: LD_INT 2
40311: PUSH
40312: LD_INT 0
40314: PUSH
40315: EMPTY
40316: LIST
40317: LIST
40318: PUSH
40319: LD_INT 2
40321: PUSH
40322: LD_INT 1
40324: NEG
40325: PUSH
40326: EMPTY
40327: LIST
40328: LIST
40329: PUSH
40330: LD_INT 3
40332: PUSH
40333: LD_INT 1
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: LIST
40344: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
40345: LD_ADDR_VAR 0 43
40349: PUSH
40350: LD_INT 2
40352: PUSH
40353: LD_INT 2
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: PUSH
40360: LD_INT 3
40362: PUSH
40363: LD_INT 2
40365: PUSH
40366: EMPTY
40367: LIST
40368: LIST
40369: PUSH
40370: LD_INT 2
40372: PUSH
40373: LD_INT 3
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: LIST
40384: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
40385: LD_ADDR_VAR 0 44
40389: PUSH
40390: LD_INT 0
40392: PUSH
40393: LD_INT 2
40395: PUSH
40396: EMPTY
40397: LIST
40398: LIST
40399: PUSH
40400: LD_INT 1
40402: PUSH
40403: LD_INT 3
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: PUSH
40410: LD_INT 1
40412: NEG
40413: PUSH
40414: LD_INT 2
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: LIST
40425: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
40426: LD_ADDR_VAR 0 45
40430: PUSH
40431: LD_INT 2
40433: NEG
40434: PUSH
40435: LD_INT 0
40437: PUSH
40438: EMPTY
40439: LIST
40440: LIST
40441: PUSH
40442: LD_INT 2
40444: NEG
40445: PUSH
40446: LD_INT 1
40448: PUSH
40449: EMPTY
40450: LIST
40451: LIST
40452: PUSH
40453: LD_INT 3
40455: NEG
40456: PUSH
40457: LD_INT 1
40459: NEG
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: LIST
40469: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
40470: LD_ADDR_VAR 0 46
40474: PUSH
40475: LD_INT 2
40477: NEG
40478: PUSH
40479: LD_INT 2
40481: NEG
40482: PUSH
40483: EMPTY
40484: LIST
40485: LIST
40486: PUSH
40487: LD_INT 2
40489: NEG
40490: PUSH
40491: LD_INT 3
40493: NEG
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: LD_INT 3
40501: NEG
40502: PUSH
40503: LD_INT 2
40505: NEG
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: LIST
40515: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
40516: LD_ADDR_VAR 0 47
40520: PUSH
40521: LD_INT 2
40523: NEG
40524: PUSH
40525: LD_INT 3
40527: NEG
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: PUSH
40533: LD_INT 1
40535: NEG
40536: PUSH
40537: LD_INT 3
40539: NEG
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
40549: LD_ADDR_VAR 0 48
40553: PUSH
40554: LD_INT 1
40556: PUSH
40557: LD_INT 2
40559: NEG
40560: PUSH
40561: EMPTY
40562: LIST
40563: LIST
40564: PUSH
40565: LD_INT 2
40567: PUSH
40568: LD_INT 1
40570: NEG
40571: PUSH
40572: EMPTY
40573: LIST
40574: LIST
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
40580: LD_ADDR_VAR 0 49
40584: PUSH
40585: LD_INT 3
40587: PUSH
40588: LD_INT 1
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: PUSH
40595: LD_INT 3
40597: PUSH
40598: LD_INT 2
40600: PUSH
40601: EMPTY
40602: LIST
40603: LIST
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
40609: LD_ADDR_VAR 0 50
40613: PUSH
40614: LD_INT 2
40616: PUSH
40617: LD_INT 3
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 1
40626: PUSH
40627: LD_INT 3
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
40638: LD_ADDR_VAR 0 51
40642: PUSH
40643: LD_INT 1
40645: NEG
40646: PUSH
40647: LD_INT 2
40649: PUSH
40650: EMPTY
40651: LIST
40652: LIST
40653: PUSH
40654: LD_INT 2
40656: NEG
40657: PUSH
40658: LD_INT 1
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
40669: LD_ADDR_VAR 0 52
40673: PUSH
40674: LD_INT 3
40676: NEG
40677: PUSH
40678: LD_INT 1
40680: NEG
40681: PUSH
40682: EMPTY
40683: LIST
40684: LIST
40685: PUSH
40686: LD_INT 3
40688: NEG
40689: PUSH
40690: LD_INT 2
40692: NEG
40693: PUSH
40694: EMPTY
40695: LIST
40696: LIST
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40702: LD_ADDR_VAR 0 53
40706: PUSH
40707: LD_INT 1
40709: NEG
40710: PUSH
40711: LD_INT 3
40713: NEG
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: PUSH
40719: LD_INT 0
40721: PUSH
40722: LD_INT 3
40724: NEG
40725: PUSH
40726: EMPTY
40727: LIST
40728: LIST
40729: PUSH
40730: LD_INT 1
40732: PUSH
40733: LD_INT 2
40735: NEG
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: PUSH
40741: EMPTY
40742: LIST
40743: LIST
40744: LIST
40745: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40746: LD_ADDR_VAR 0 54
40750: PUSH
40751: LD_INT 2
40753: PUSH
40754: LD_INT 1
40756: NEG
40757: PUSH
40758: EMPTY
40759: LIST
40760: LIST
40761: PUSH
40762: LD_INT 3
40764: PUSH
40765: LD_INT 0
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: LD_INT 3
40774: PUSH
40775: LD_INT 1
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: LIST
40786: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40787: LD_ADDR_VAR 0 55
40791: PUSH
40792: LD_INT 3
40794: PUSH
40795: LD_INT 2
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: PUSH
40802: LD_INT 3
40804: PUSH
40805: LD_INT 3
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 2
40814: PUSH
40815: LD_INT 3
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PUSH
40822: EMPTY
40823: LIST
40824: LIST
40825: LIST
40826: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40827: LD_ADDR_VAR 0 56
40831: PUSH
40832: LD_INT 1
40834: PUSH
40835: LD_INT 3
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: PUSH
40842: LD_INT 0
40844: PUSH
40845: LD_INT 3
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 1
40854: NEG
40855: PUSH
40856: LD_INT 2
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: LIST
40867: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40868: LD_ADDR_VAR 0 57
40872: PUSH
40873: LD_INT 2
40875: NEG
40876: PUSH
40877: LD_INT 1
40879: PUSH
40880: EMPTY
40881: LIST
40882: LIST
40883: PUSH
40884: LD_INT 3
40886: NEG
40887: PUSH
40888: LD_INT 0
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: PUSH
40895: LD_INT 3
40897: NEG
40898: PUSH
40899: LD_INT 1
40901: NEG
40902: PUSH
40903: EMPTY
40904: LIST
40905: LIST
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: LIST
40911: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40912: LD_ADDR_VAR 0 58
40916: PUSH
40917: LD_INT 2
40919: NEG
40920: PUSH
40921: LD_INT 3
40923: NEG
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: PUSH
40929: LD_INT 3
40931: NEG
40932: PUSH
40933: LD_INT 2
40935: NEG
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: PUSH
40941: LD_INT 3
40943: NEG
40944: PUSH
40945: LD_INT 3
40947: NEG
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: LIST
40957: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
40958: LD_ADDR_VAR 0 59
40962: PUSH
40963: LD_INT 1
40965: NEG
40966: PUSH
40967: LD_INT 2
40969: NEG
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: LD_INT 0
40977: PUSH
40978: LD_INT 2
40980: NEG
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PUSH
40986: LD_INT 1
40988: PUSH
40989: LD_INT 1
40991: NEG
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PUSH
40997: EMPTY
40998: LIST
40999: LIST
41000: LIST
41001: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41002: LD_ADDR_VAR 0 60
41006: PUSH
41007: LD_INT 1
41009: PUSH
41010: LD_INT 1
41012: NEG
41013: PUSH
41014: EMPTY
41015: LIST
41016: LIST
41017: PUSH
41018: LD_INT 2
41020: PUSH
41021: LD_INT 0
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: PUSH
41028: LD_INT 2
41030: PUSH
41031: LD_INT 1
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: PUSH
41038: EMPTY
41039: LIST
41040: LIST
41041: LIST
41042: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41043: LD_ADDR_VAR 0 61
41047: PUSH
41048: LD_INT 2
41050: PUSH
41051: LD_INT 1
41053: PUSH
41054: EMPTY
41055: LIST
41056: LIST
41057: PUSH
41058: LD_INT 2
41060: PUSH
41061: LD_INT 2
41063: PUSH
41064: EMPTY
41065: LIST
41066: LIST
41067: PUSH
41068: LD_INT 1
41070: PUSH
41071: LD_INT 2
41073: PUSH
41074: EMPTY
41075: LIST
41076: LIST
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: LIST
41082: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41083: LD_ADDR_VAR 0 62
41087: PUSH
41088: LD_INT 1
41090: PUSH
41091: LD_INT 2
41093: PUSH
41094: EMPTY
41095: LIST
41096: LIST
41097: PUSH
41098: LD_INT 0
41100: PUSH
41101: LD_INT 2
41103: PUSH
41104: EMPTY
41105: LIST
41106: LIST
41107: PUSH
41108: LD_INT 1
41110: NEG
41111: PUSH
41112: LD_INT 1
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: LIST
41123: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41124: LD_ADDR_VAR 0 63
41128: PUSH
41129: LD_INT 1
41131: NEG
41132: PUSH
41133: LD_INT 1
41135: PUSH
41136: EMPTY
41137: LIST
41138: LIST
41139: PUSH
41140: LD_INT 2
41142: NEG
41143: PUSH
41144: LD_INT 0
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: PUSH
41151: LD_INT 2
41153: NEG
41154: PUSH
41155: LD_INT 1
41157: NEG
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: LIST
41167: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41168: LD_ADDR_VAR 0 64
41172: PUSH
41173: LD_INT 1
41175: NEG
41176: PUSH
41177: LD_INT 2
41179: NEG
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 2
41187: NEG
41188: PUSH
41189: LD_INT 1
41191: NEG
41192: PUSH
41193: EMPTY
41194: LIST
41195: LIST
41196: PUSH
41197: LD_INT 2
41199: NEG
41200: PUSH
41201: LD_INT 2
41203: NEG
41204: PUSH
41205: EMPTY
41206: LIST
41207: LIST
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: LIST
41213: ST_TO_ADDR
// end ; 2 :
41214: GO 44480
41216: LD_INT 2
41218: DOUBLE
41219: EQUAL
41220: IFTRUE 41224
41222: GO 44479
41224: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41225: LD_ADDR_VAR 0 29
41229: PUSH
41230: LD_INT 4
41232: PUSH
41233: LD_INT 0
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: LD_INT 4
41242: PUSH
41243: LD_INT 1
41245: NEG
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: PUSH
41251: LD_INT 5
41253: PUSH
41254: LD_INT 0
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PUSH
41261: LD_INT 5
41263: PUSH
41264: LD_INT 1
41266: PUSH
41267: EMPTY
41268: LIST
41269: LIST
41270: PUSH
41271: LD_INT 4
41273: PUSH
41274: LD_INT 1
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 3
41283: PUSH
41284: LD_INT 0
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: LD_INT 3
41293: PUSH
41294: LD_INT 1
41296: NEG
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: LD_INT 3
41304: PUSH
41305: LD_INT 2
41307: NEG
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: PUSH
41313: LD_INT 5
41315: PUSH
41316: LD_INT 2
41318: PUSH
41319: EMPTY
41320: LIST
41321: LIST
41322: PUSH
41323: LD_INT 3
41325: PUSH
41326: LD_INT 3
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 3
41335: PUSH
41336: LD_INT 2
41338: PUSH
41339: EMPTY
41340: LIST
41341: LIST
41342: PUSH
41343: LD_INT 4
41345: PUSH
41346: LD_INT 3
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: LD_INT 4
41355: PUSH
41356: LD_INT 4
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: LD_INT 3
41365: PUSH
41366: LD_INT 4
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: LD_INT 2
41375: PUSH
41376: LD_INT 3
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: PUSH
41383: LD_INT 2
41385: PUSH
41386: LD_INT 2
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: PUSH
41393: LD_INT 4
41395: PUSH
41396: LD_INT 2
41398: PUSH
41399: EMPTY
41400: LIST
41401: LIST
41402: PUSH
41403: LD_INT 2
41405: PUSH
41406: LD_INT 4
41408: PUSH
41409: EMPTY
41410: LIST
41411: LIST
41412: PUSH
41413: LD_INT 0
41415: PUSH
41416: LD_INT 4
41418: PUSH
41419: EMPTY
41420: LIST
41421: LIST
41422: PUSH
41423: LD_INT 0
41425: PUSH
41426: LD_INT 3
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: LD_INT 1
41435: PUSH
41436: LD_INT 4
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 1
41445: PUSH
41446: LD_INT 5
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: PUSH
41453: LD_INT 0
41455: PUSH
41456: LD_INT 5
41458: PUSH
41459: EMPTY
41460: LIST
41461: LIST
41462: PUSH
41463: LD_INT 1
41465: NEG
41466: PUSH
41467: LD_INT 4
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: PUSH
41474: LD_INT 1
41476: NEG
41477: PUSH
41478: LD_INT 3
41480: PUSH
41481: EMPTY
41482: LIST
41483: LIST
41484: PUSH
41485: LD_INT 2
41487: PUSH
41488: LD_INT 5
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: PUSH
41495: LD_INT 2
41497: NEG
41498: PUSH
41499: LD_INT 3
41501: PUSH
41502: EMPTY
41503: LIST
41504: LIST
41505: PUSH
41506: LD_INT 3
41508: NEG
41509: PUSH
41510: LD_INT 0
41512: PUSH
41513: EMPTY
41514: LIST
41515: LIST
41516: PUSH
41517: LD_INT 3
41519: NEG
41520: PUSH
41521: LD_INT 1
41523: NEG
41524: PUSH
41525: EMPTY
41526: LIST
41527: LIST
41528: PUSH
41529: LD_INT 2
41531: NEG
41532: PUSH
41533: LD_INT 0
41535: PUSH
41536: EMPTY
41537: LIST
41538: LIST
41539: PUSH
41540: LD_INT 2
41542: NEG
41543: PUSH
41544: LD_INT 1
41546: PUSH
41547: EMPTY
41548: LIST
41549: LIST
41550: PUSH
41551: LD_INT 3
41553: NEG
41554: PUSH
41555: LD_INT 1
41557: PUSH
41558: EMPTY
41559: LIST
41560: LIST
41561: PUSH
41562: LD_INT 4
41564: NEG
41565: PUSH
41566: LD_INT 0
41568: PUSH
41569: EMPTY
41570: LIST
41571: LIST
41572: PUSH
41573: LD_INT 4
41575: NEG
41576: PUSH
41577: LD_INT 1
41579: NEG
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: LD_INT 4
41587: NEG
41588: PUSH
41589: LD_INT 2
41591: NEG
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: PUSH
41597: LD_INT 2
41599: NEG
41600: PUSH
41601: LD_INT 2
41603: PUSH
41604: EMPTY
41605: LIST
41606: LIST
41607: PUSH
41608: LD_INT 4
41610: NEG
41611: PUSH
41612: LD_INT 4
41614: NEG
41615: PUSH
41616: EMPTY
41617: LIST
41618: LIST
41619: PUSH
41620: LD_INT 4
41622: NEG
41623: PUSH
41624: LD_INT 5
41626: NEG
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: LD_INT 3
41634: NEG
41635: PUSH
41636: LD_INT 4
41638: NEG
41639: PUSH
41640: EMPTY
41641: LIST
41642: LIST
41643: PUSH
41644: LD_INT 3
41646: NEG
41647: PUSH
41648: LD_INT 3
41650: NEG
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 4
41658: NEG
41659: PUSH
41660: LD_INT 3
41662: NEG
41663: PUSH
41664: EMPTY
41665: LIST
41666: LIST
41667: PUSH
41668: LD_INT 5
41670: NEG
41671: PUSH
41672: LD_INT 4
41674: NEG
41675: PUSH
41676: EMPTY
41677: LIST
41678: LIST
41679: PUSH
41680: LD_INT 5
41682: NEG
41683: PUSH
41684: LD_INT 5
41686: NEG
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 3
41694: NEG
41695: PUSH
41696: LD_INT 5
41698: NEG
41699: PUSH
41700: EMPTY
41701: LIST
41702: LIST
41703: PUSH
41704: LD_INT 5
41706: NEG
41707: PUSH
41708: LD_INT 3
41710: NEG
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: EMPTY
41717: LIST
41718: LIST
41719: LIST
41720: LIST
41721: LIST
41722: LIST
41723: LIST
41724: LIST
41725: LIST
41726: LIST
41727: LIST
41728: LIST
41729: LIST
41730: LIST
41731: LIST
41732: LIST
41733: LIST
41734: LIST
41735: LIST
41736: LIST
41737: LIST
41738: LIST
41739: LIST
41740: LIST
41741: LIST
41742: LIST
41743: LIST
41744: LIST
41745: LIST
41746: LIST
41747: LIST
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
41763: LD_ADDR_VAR 0 30
41767: PUSH
41768: LD_INT 4
41770: PUSH
41771: LD_INT 4
41773: PUSH
41774: EMPTY
41775: LIST
41776: LIST
41777: PUSH
41778: LD_INT 4
41780: PUSH
41781: LD_INT 3
41783: PUSH
41784: EMPTY
41785: LIST
41786: LIST
41787: PUSH
41788: LD_INT 5
41790: PUSH
41791: LD_INT 4
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 5
41800: PUSH
41801: LD_INT 5
41803: PUSH
41804: EMPTY
41805: LIST
41806: LIST
41807: PUSH
41808: LD_INT 4
41810: PUSH
41811: LD_INT 5
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: LD_INT 3
41820: PUSH
41821: LD_INT 4
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 3
41830: PUSH
41831: LD_INT 3
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: PUSH
41838: LD_INT 5
41840: PUSH
41841: LD_INT 3
41843: PUSH
41844: EMPTY
41845: LIST
41846: LIST
41847: PUSH
41848: LD_INT 3
41850: PUSH
41851: LD_INT 5
41853: PUSH
41854: EMPTY
41855: LIST
41856: LIST
41857: PUSH
41858: LD_INT 0
41860: PUSH
41861: LD_INT 3
41863: PUSH
41864: EMPTY
41865: LIST
41866: LIST
41867: PUSH
41868: LD_INT 0
41870: PUSH
41871: LD_INT 2
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: LD_INT 1
41880: PUSH
41881: LD_INT 3
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: PUSH
41888: LD_INT 1
41890: PUSH
41891: LD_INT 4
41893: PUSH
41894: EMPTY
41895: LIST
41896: LIST
41897: PUSH
41898: LD_INT 0
41900: PUSH
41901: LD_INT 4
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PUSH
41908: LD_INT 1
41910: NEG
41911: PUSH
41912: LD_INT 3
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: LD_INT 1
41921: NEG
41922: PUSH
41923: LD_INT 2
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 2
41932: PUSH
41933: LD_INT 4
41935: PUSH
41936: EMPTY
41937: LIST
41938: LIST
41939: PUSH
41940: LD_INT 2
41942: NEG
41943: PUSH
41944: LD_INT 2
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: LD_INT 4
41953: NEG
41954: PUSH
41955: LD_INT 0
41957: PUSH
41958: EMPTY
41959: LIST
41960: LIST
41961: PUSH
41962: LD_INT 4
41964: NEG
41965: PUSH
41966: LD_INT 1
41968: NEG
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PUSH
41974: LD_INT 3
41976: NEG
41977: PUSH
41978: LD_INT 0
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 3
41987: NEG
41988: PUSH
41989: LD_INT 1
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: LD_INT 4
41998: NEG
41999: PUSH
42000: LD_INT 1
42002: PUSH
42003: EMPTY
42004: LIST
42005: LIST
42006: PUSH
42007: LD_INT 5
42009: NEG
42010: PUSH
42011: LD_INT 0
42013: PUSH
42014: EMPTY
42015: LIST
42016: LIST
42017: PUSH
42018: LD_INT 5
42020: NEG
42021: PUSH
42022: LD_INT 1
42024: NEG
42025: PUSH
42026: EMPTY
42027: LIST
42028: LIST
42029: PUSH
42030: LD_INT 5
42032: NEG
42033: PUSH
42034: LD_INT 2
42036: NEG
42037: PUSH
42038: EMPTY
42039: LIST
42040: LIST
42041: PUSH
42042: LD_INT 3
42044: NEG
42045: PUSH
42046: LD_INT 2
42048: PUSH
42049: EMPTY
42050: LIST
42051: LIST
42052: PUSH
42053: LD_INT 3
42055: NEG
42056: PUSH
42057: LD_INT 3
42059: NEG
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PUSH
42065: LD_INT 3
42067: NEG
42068: PUSH
42069: LD_INT 4
42071: NEG
42072: PUSH
42073: EMPTY
42074: LIST
42075: LIST
42076: PUSH
42077: LD_INT 2
42079: NEG
42080: PUSH
42081: LD_INT 3
42083: NEG
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: PUSH
42089: LD_INT 2
42091: NEG
42092: PUSH
42093: LD_INT 2
42095: NEG
42096: PUSH
42097: EMPTY
42098: LIST
42099: LIST
42100: PUSH
42101: LD_INT 3
42103: NEG
42104: PUSH
42105: LD_INT 2
42107: NEG
42108: PUSH
42109: EMPTY
42110: LIST
42111: LIST
42112: PUSH
42113: LD_INT 4
42115: NEG
42116: PUSH
42117: LD_INT 3
42119: NEG
42120: PUSH
42121: EMPTY
42122: LIST
42123: LIST
42124: PUSH
42125: LD_INT 4
42127: NEG
42128: PUSH
42129: LD_INT 4
42131: NEG
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: PUSH
42137: LD_INT 2
42139: NEG
42140: PUSH
42141: LD_INT 4
42143: NEG
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 4
42151: NEG
42152: PUSH
42153: LD_INT 2
42155: NEG
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 0
42163: PUSH
42164: LD_INT 4
42166: NEG
42167: PUSH
42168: EMPTY
42169: LIST
42170: LIST
42171: PUSH
42172: LD_INT 0
42174: PUSH
42175: LD_INT 5
42177: NEG
42178: PUSH
42179: EMPTY
42180: LIST
42181: LIST
42182: PUSH
42183: LD_INT 1
42185: PUSH
42186: LD_INT 4
42188: NEG
42189: PUSH
42190: EMPTY
42191: LIST
42192: LIST
42193: PUSH
42194: LD_INT 1
42196: PUSH
42197: LD_INT 3
42199: NEG
42200: PUSH
42201: EMPTY
42202: LIST
42203: LIST
42204: PUSH
42205: LD_INT 0
42207: PUSH
42208: LD_INT 3
42210: NEG
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PUSH
42216: LD_INT 1
42218: NEG
42219: PUSH
42220: LD_INT 4
42222: NEG
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PUSH
42228: LD_INT 1
42230: NEG
42231: PUSH
42232: LD_INT 5
42234: NEG
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PUSH
42240: LD_INT 2
42242: PUSH
42243: LD_INT 3
42245: NEG
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: LD_INT 2
42253: NEG
42254: PUSH
42255: LD_INT 5
42257: NEG
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: EMPTY
42264: LIST
42265: LIST
42266: LIST
42267: LIST
42268: LIST
42269: LIST
42270: LIST
42271: LIST
42272: LIST
42273: LIST
42274: LIST
42275: LIST
42276: LIST
42277: LIST
42278: LIST
42279: LIST
42280: LIST
42281: LIST
42282: LIST
42283: LIST
42284: LIST
42285: LIST
42286: LIST
42287: LIST
42288: LIST
42289: LIST
42290: LIST
42291: LIST
42292: LIST
42293: LIST
42294: LIST
42295: LIST
42296: LIST
42297: LIST
42298: LIST
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: LIST
42306: LIST
42307: LIST
42308: LIST
42309: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
42310: LD_ADDR_VAR 0 31
42314: PUSH
42315: LD_INT 0
42317: PUSH
42318: LD_INT 4
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: LD_INT 0
42327: PUSH
42328: LD_INT 3
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 1
42337: PUSH
42338: LD_INT 4
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: LD_INT 1
42347: PUSH
42348: LD_INT 5
42350: PUSH
42351: EMPTY
42352: LIST
42353: LIST
42354: PUSH
42355: LD_INT 0
42357: PUSH
42358: LD_INT 5
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: LD_INT 1
42367: NEG
42368: PUSH
42369: LD_INT 4
42371: PUSH
42372: EMPTY
42373: LIST
42374: LIST
42375: PUSH
42376: LD_INT 1
42378: NEG
42379: PUSH
42380: LD_INT 3
42382: PUSH
42383: EMPTY
42384: LIST
42385: LIST
42386: PUSH
42387: LD_INT 2
42389: PUSH
42390: LD_INT 5
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: LD_INT 2
42399: NEG
42400: PUSH
42401: LD_INT 3
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: PUSH
42408: LD_INT 3
42410: NEG
42411: PUSH
42412: LD_INT 0
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: PUSH
42419: LD_INT 3
42421: NEG
42422: PUSH
42423: LD_INT 1
42425: NEG
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: LD_INT 2
42433: NEG
42434: PUSH
42435: LD_INT 0
42437: PUSH
42438: EMPTY
42439: LIST
42440: LIST
42441: PUSH
42442: LD_INT 2
42444: NEG
42445: PUSH
42446: LD_INT 1
42448: PUSH
42449: EMPTY
42450: LIST
42451: LIST
42452: PUSH
42453: LD_INT 3
42455: NEG
42456: PUSH
42457: LD_INT 1
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: LD_INT 4
42466: NEG
42467: PUSH
42468: LD_INT 0
42470: PUSH
42471: EMPTY
42472: LIST
42473: LIST
42474: PUSH
42475: LD_INT 4
42477: NEG
42478: PUSH
42479: LD_INT 1
42481: NEG
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: PUSH
42487: LD_INT 4
42489: NEG
42490: PUSH
42491: LD_INT 2
42493: NEG
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 2
42501: NEG
42502: PUSH
42503: LD_INT 2
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: PUSH
42510: LD_INT 4
42512: NEG
42513: PUSH
42514: LD_INT 4
42516: NEG
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 4
42524: NEG
42525: PUSH
42526: LD_INT 5
42528: NEG
42529: PUSH
42530: EMPTY
42531: LIST
42532: LIST
42533: PUSH
42534: LD_INT 3
42536: NEG
42537: PUSH
42538: LD_INT 4
42540: NEG
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PUSH
42546: LD_INT 3
42548: NEG
42549: PUSH
42550: LD_INT 3
42552: NEG
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PUSH
42558: LD_INT 4
42560: NEG
42561: PUSH
42562: LD_INT 3
42564: NEG
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 5
42572: NEG
42573: PUSH
42574: LD_INT 4
42576: NEG
42577: PUSH
42578: EMPTY
42579: LIST
42580: LIST
42581: PUSH
42582: LD_INT 5
42584: NEG
42585: PUSH
42586: LD_INT 5
42588: NEG
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: PUSH
42594: LD_INT 3
42596: NEG
42597: PUSH
42598: LD_INT 5
42600: NEG
42601: PUSH
42602: EMPTY
42603: LIST
42604: LIST
42605: PUSH
42606: LD_INT 5
42608: NEG
42609: PUSH
42610: LD_INT 3
42612: NEG
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PUSH
42618: LD_INT 0
42620: PUSH
42621: LD_INT 3
42623: NEG
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: PUSH
42629: LD_INT 0
42631: PUSH
42632: LD_INT 4
42634: NEG
42635: PUSH
42636: EMPTY
42637: LIST
42638: LIST
42639: PUSH
42640: LD_INT 1
42642: PUSH
42643: LD_INT 3
42645: NEG
42646: PUSH
42647: EMPTY
42648: LIST
42649: LIST
42650: PUSH
42651: LD_INT 1
42653: PUSH
42654: LD_INT 2
42656: NEG
42657: PUSH
42658: EMPTY
42659: LIST
42660: LIST
42661: PUSH
42662: LD_INT 0
42664: PUSH
42665: LD_INT 2
42667: NEG
42668: PUSH
42669: EMPTY
42670: LIST
42671: LIST
42672: PUSH
42673: LD_INT 1
42675: NEG
42676: PUSH
42677: LD_INT 3
42679: NEG
42680: PUSH
42681: EMPTY
42682: LIST
42683: LIST
42684: PUSH
42685: LD_INT 1
42687: NEG
42688: PUSH
42689: LD_INT 4
42691: NEG
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 2
42699: PUSH
42700: LD_INT 2
42702: NEG
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: LD_INT 2
42710: NEG
42711: PUSH
42712: LD_INT 4
42714: NEG
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 4
42722: PUSH
42723: LD_INT 0
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 4
42732: PUSH
42733: LD_INT 1
42735: NEG
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 5
42743: PUSH
42744: LD_INT 0
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: PUSH
42751: LD_INT 5
42753: PUSH
42754: LD_INT 1
42756: PUSH
42757: EMPTY
42758: LIST
42759: LIST
42760: PUSH
42761: LD_INT 4
42763: PUSH
42764: LD_INT 1
42766: PUSH
42767: EMPTY
42768: LIST
42769: LIST
42770: PUSH
42771: LD_INT 3
42773: PUSH
42774: LD_INT 0
42776: PUSH
42777: EMPTY
42778: LIST
42779: LIST
42780: PUSH
42781: LD_INT 3
42783: PUSH
42784: LD_INT 1
42786: NEG
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: LD_INT 3
42794: PUSH
42795: LD_INT 2
42797: NEG
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 5
42805: PUSH
42806: LD_INT 2
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: LIST
42817: LIST
42818: LIST
42819: LIST
42820: LIST
42821: LIST
42822: LIST
42823: LIST
42824: LIST
42825: LIST
42826: LIST
42827: LIST
42828: LIST
42829: LIST
42830: LIST
42831: LIST
42832: LIST
42833: LIST
42834: LIST
42835: LIST
42836: LIST
42837: LIST
42838: LIST
42839: LIST
42840: LIST
42841: LIST
42842: LIST
42843: LIST
42844: LIST
42845: LIST
42846: LIST
42847: LIST
42848: LIST
42849: LIST
42850: LIST
42851: LIST
42852: LIST
42853: LIST
42854: LIST
42855: LIST
42856: LIST
42857: LIST
42858: LIST
42859: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
42860: LD_ADDR_VAR 0 32
42864: PUSH
42865: LD_INT 4
42867: NEG
42868: PUSH
42869: LD_INT 0
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PUSH
42876: LD_INT 4
42878: NEG
42879: PUSH
42880: LD_INT 1
42882: NEG
42883: PUSH
42884: EMPTY
42885: LIST
42886: LIST
42887: PUSH
42888: LD_INT 3
42890: NEG
42891: PUSH
42892: LD_INT 0
42894: PUSH
42895: EMPTY
42896: LIST
42897: LIST
42898: PUSH
42899: LD_INT 3
42901: NEG
42902: PUSH
42903: LD_INT 1
42905: PUSH
42906: EMPTY
42907: LIST
42908: LIST
42909: PUSH
42910: LD_INT 4
42912: NEG
42913: PUSH
42914: LD_INT 1
42916: PUSH
42917: EMPTY
42918: LIST
42919: LIST
42920: PUSH
42921: LD_INT 5
42923: NEG
42924: PUSH
42925: LD_INT 0
42927: PUSH
42928: EMPTY
42929: LIST
42930: LIST
42931: PUSH
42932: LD_INT 5
42934: NEG
42935: PUSH
42936: LD_INT 1
42938: NEG
42939: PUSH
42940: EMPTY
42941: LIST
42942: LIST
42943: PUSH
42944: LD_INT 5
42946: NEG
42947: PUSH
42948: LD_INT 2
42950: NEG
42951: PUSH
42952: EMPTY
42953: LIST
42954: LIST
42955: PUSH
42956: LD_INT 3
42958: NEG
42959: PUSH
42960: LD_INT 2
42962: PUSH
42963: EMPTY
42964: LIST
42965: LIST
42966: PUSH
42967: LD_INT 3
42969: NEG
42970: PUSH
42971: LD_INT 3
42973: NEG
42974: PUSH
42975: EMPTY
42976: LIST
42977: LIST
42978: PUSH
42979: LD_INT 3
42981: NEG
42982: PUSH
42983: LD_INT 4
42985: NEG
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: PUSH
42991: LD_INT 2
42993: NEG
42994: PUSH
42995: LD_INT 3
42997: NEG
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: LD_INT 2
43005: NEG
43006: PUSH
43007: LD_INT 2
43009: NEG
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: PUSH
43015: LD_INT 3
43017: NEG
43018: PUSH
43019: LD_INT 2
43021: NEG
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: LD_INT 4
43029: NEG
43030: PUSH
43031: LD_INT 3
43033: NEG
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: PUSH
43039: LD_INT 4
43041: NEG
43042: PUSH
43043: LD_INT 4
43045: NEG
43046: PUSH
43047: EMPTY
43048: LIST
43049: LIST
43050: PUSH
43051: LD_INT 2
43053: NEG
43054: PUSH
43055: LD_INT 4
43057: NEG
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: LD_INT 4
43065: NEG
43066: PUSH
43067: LD_INT 2
43069: NEG
43070: PUSH
43071: EMPTY
43072: LIST
43073: LIST
43074: PUSH
43075: LD_INT 0
43077: PUSH
43078: LD_INT 4
43080: NEG
43081: PUSH
43082: EMPTY
43083: LIST
43084: LIST
43085: PUSH
43086: LD_INT 0
43088: PUSH
43089: LD_INT 5
43091: NEG
43092: PUSH
43093: EMPTY
43094: LIST
43095: LIST
43096: PUSH
43097: LD_INT 1
43099: PUSH
43100: LD_INT 4
43102: NEG
43103: PUSH
43104: EMPTY
43105: LIST
43106: LIST
43107: PUSH
43108: LD_INT 1
43110: PUSH
43111: LD_INT 3
43113: NEG
43114: PUSH
43115: EMPTY
43116: LIST
43117: LIST
43118: PUSH
43119: LD_INT 0
43121: PUSH
43122: LD_INT 3
43124: NEG
43125: PUSH
43126: EMPTY
43127: LIST
43128: LIST
43129: PUSH
43130: LD_INT 1
43132: NEG
43133: PUSH
43134: LD_INT 4
43136: NEG
43137: PUSH
43138: EMPTY
43139: LIST
43140: LIST
43141: PUSH
43142: LD_INT 1
43144: NEG
43145: PUSH
43146: LD_INT 5
43148: NEG
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_INT 2
43156: PUSH
43157: LD_INT 3
43159: NEG
43160: PUSH
43161: EMPTY
43162: LIST
43163: LIST
43164: PUSH
43165: LD_INT 2
43167: NEG
43168: PUSH
43169: LD_INT 5
43171: NEG
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: LD_INT 3
43179: PUSH
43180: LD_INT 0
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: PUSH
43187: LD_INT 3
43189: PUSH
43190: LD_INT 1
43192: NEG
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: PUSH
43198: LD_INT 4
43200: PUSH
43201: LD_INT 0
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: LD_INT 4
43210: PUSH
43211: LD_INT 1
43213: PUSH
43214: EMPTY
43215: LIST
43216: LIST
43217: PUSH
43218: LD_INT 3
43220: PUSH
43221: LD_INT 1
43223: PUSH
43224: EMPTY
43225: LIST
43226: LIST
43227: PUSH
43228: LD_INT 2
43230: PUSH
43231: LD_INT 0
43233: PUSH
43234: EMPTY
43235: LIST
43236: LIST
43237: PUSH
43238: LD_INT 2
43240: PUSH
43241: LD_INT 1
43243: NEG
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: LD_INT 2
43251: PUSH
43252: LD_INT 2
43254: NEG
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PUSH
43260: LD_INT 4
43262: PUSH
43263: LD_INT 2
43265: PUSH
43266: EMPTY
43267: LIST
43268: LIST
43269: PUSH
43270: LD_INT 4
43272: PUSH
43273: LD_INT 4
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: LD_INT 4
43282: PUSH
43283: LD_INT 3
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 5
43292: PUSH
43293: LD_INT 4
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 5
43302: PUSH
43303: LD_INT 5
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PUSH
43310: LD_INT 4
43312: PUSH
43313: LD_INT 5
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 3
43322: PUSH
43323: LD_INT 4
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 3
43332: PUSH
43333: LD_INT 3
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: PUSH
43340: LD_INT 5
43342: PUSH
43343: LD_INT 3
43345: PUSH
43346: EMPTY
43347: LIST
43348: LIST
43349: PUSH
43350: LD_INT 3
43352: PUSH
43353: LD_INT 5
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: LIST
43364: LIST
43365: LIST
43366: LIST
43367: LIST
43368: LIST
43369: LIST
43370: LIST
43371: LIST
43372: LIST
43373: LIST
43374: LIST
43375: LIST
43376: LIST
43377: LIST
43378: LIST
43379: LIST
43380: LIST
43381: LIST
43382: LIST
43383: LIST
43384: LIST
43385: LIST
43386: LIST
43387: LIST
43388: LIST
43389: LIST
43390: LIST
43391: LIST
43392: LIST
43393: LIST
43394: LIST
43395: LIST
43396: LIST
43397: LIST
43398: LIST
43399: LIST
43400: LIST
43401: LIST
43402: LIST
43403: LIST
43404: LIST
43405: LIST
43406: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
43407: LD_ADDR_VAR 0 33
43411: PUSH
43412: LD_INT 4
43414: NEG
43415: PUSH
43416: LD_INT 4
43418: NEG
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PUSH
43424: LD_INT 4
43426: NEG
43427: PUSH
43428: LD_INT 5
43430: NEG
43431: PUSH
43432: EMPTY
43433: LIST
43434: LIST
43435: PUSH
43436: LD_INT 3
43438: NEG
43439: PUSH
43440: LD_INT 4
43442: NEG
43443: PUSH
43444: EMPTY
43445: LIST
43446: LIST
43447: PUSH
43448: LD_INT 3
43450: NEG
43451: PUSH
43452: LD_INT 3
43454: NEG
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PUSH
43460: LD_INT 4
43462: NEG
43463: PUSH
43464: LD_INT 3
43466: NEG
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 5
43474: NEG
43475: PUSH
43476: LD_INT 4
43478: NEG
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: LD_INT 5
43486: NEG
43487: PUSH
43488: LD_INT 5
43490: NEG
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: PUSH
43496: LD_INT 3
43498: NEG
43499: PUSH
43500: LD_INT 5
43502: NEG
43503: PUSH
43504: EMPTY
43505: LIST
43506: LIST
43507: PUSH
43508: LD_INT 5
43510: NEG
43511: PUSH
43512: LD_INT 3
43514: NEG
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: PUSH
43520: LD_INT 0
43522: PUSH
43523: LD_INT 3
43525: NEG
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: PUSH
43531: LD_INT 0
43533: PUSH
43534: LD_INT 4
43536: NEG
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 1
43544: PUSH
43545: LD_INT 3
43547: NEG
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: LD_INT 1
43555: PUSH
43556: LD_INT 2
43558: NEG
43559: PUSH
43560: EMPTY
43561: LIST
43562: LIST
43563: PUSH
43564: LD_INT 0
43566: PUSH
43567: LD_INT 2
43569: NEG
43570: PUSH
43571: EMPTY
43572: LIST
43573: LIST
43574: PUSH
43575: LD_INT 1
43577: NEG
43578: PUSH
43579: LD_INT 3
43581: NEG
43582: PUSH
43583: EMPTY
43584: LIST
43585: LIST
43586: PUSH
43587: LD_INT 1
43589: NEG
43590: PUSH
43591: LD_INT 4
43593: NEG
43594: PUSH
43595: EMPTY
43596: LIST
43597: LIST
43598: PUSH
43599: LD_INT 2
43601: PUSH
43602: LD_INT 2
43604: NEG
43605: PUSH
43606: EMPTY
43607: LIST
43608: LIST
43609: PUSH
43610: LD_INT 2
43612: NEG
43613: PUSH
43614: LD_INT 4
43616: NEG
43617: PUSH
43618: EMPTY
43619: LIST
43620: LIST
43621: PUSH
43622: LD_INT 4
43624: PUSH
43625: LD_INT 0
43627: PUSH
43628: EMPTY
43629: LIST
43630: LIST
43631: PUSH
43632: LD_INT 4
43634: PUSH
43635: LD_INT 1
43637: NEG
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: PUSH
43643: LD_INT 5
43645: PUSH
43646: LD_INT 0
43648: PUSH
43649: EMPTY
43650: LIST
43651: LIST
43652: PUSH
43653: LD_INT 5
43655: PUSH
43656: LD_INT 1
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 4
43665: PUSH
43666: LD_INT 1
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 3
43675: PUSH
43676: LD_INT 0
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: PUSH
43683: LD_INT 3
43685: PUSH
43686: LD_INT 1
43688: NEG
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 3
43696: PUSH
43697: LD_INT 2
43699: NEG
43700: PUSH
43701: EMPTY
43702: LIST
43703: LIST
43704: PUSH
43705: LD_INT 5
43707: PUSH
43708: LD_INT 2
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: PUSH
43715: LD_INT 3
43717: PUSH
43718: LD_INT 3
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: LD_INT 3
43727: PUSH
43728: LD_INT 2
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PUSH
43735: LD_INT 4
43737: PUSH
43738: LD_INT 3
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: PUSH
43745: LD_INT 4
43747: PUSH
43748: LD_INT 4
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: LD_INT 3
43757: PUSH
43758: LD_INT 4
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 2
43767: PUSH
43768: LD_INT 3
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: LD_INT 2
43777: PUSH
43778: LD_INT 2
43780: PUSH
43781: EMPTY
43782: LIST
43783: LIST
43784: PUSH
43785: LD_INT 4
43787: PUSH
43788: LD_INT 2
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: LD_INT 2
43797: PUSH
43798: LD_INT 4
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: LD_INT 0
43807: PUSH
43808: LD_INT 4
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: LD_INT 0
43817: PUSH
43818: LD_INT 3
43820: PUSH
43821: EMPTY
43822: LIST
43823: LIST
43824: PUSH
43825: LD_INT 1
43827: PUSH
43828: LD_INT 4
43830: PUSH
43831: EMPTY
43832: LIST
43833: LIST
43834: PUSH
43835: LD_INT 1
43837: PUSH
43838: LD_INT 5
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PUSH
43845: LD_INT 0
43847: PUSH
43848: LD_INT 5
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 1
43857: NEG
43858: PUSH
43859: LD_INT 4
43861: PUSH
43862: EMPTY
43863: LIST
43864: LIST
43865: PUSH
43866: LD_INT 1
43868: NEG
43869: PUSH
43870: LD_INT 3
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 2
43879: PUSH
43880: LD_INT 5
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 2
43889: NEG
43890: PUSH
43891: LD_INT 3
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: EMPTY
43899: LIST
43900: LIST
43901: LIST
43902: LIST
43903: LIST
43904: LIST
43905: LIST
43906: LIST
43907: LIST
43908: LIST
43909: LIST
43910: LIST
43911: LIST
43912: LIST
43913: LIST
43914: LIST
43915: LIST
43916: LIST
43917: LIST
43918: LIST
43919: LIST
43920: LIST
43921: LIST
43922: LIST
43923: LIST
43924: LIST
43925: LIST
43926: LIST
43927: LIST
43928: LIST
43929: LIST
43930: LIST
43931: LIST
43932: LIST
43933: LIST
43934: LIST
43935: LIST
43936: LIST
43937: LIST
43938: LIST
43939: LIST
43940: LIST
43941: LIST
43942: LIST
43943: LIST
43944: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
43945: LD_ADDR_VAR 0 34
43949: PUSH
43950: LD_INT 0
43952: PUSH
43953: LD_INT 4
43955: NEG
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PUSH
43961: LD_INT 0
43963: PUSH
43964: LD_INT 5
43966: NEG
43967: PUSH
43968: EMPTY
43969: LIST
43970: LIST
43971: PUSH
43972: LD_INT 1
43974: PUSH
43975: LD_INT 4
43977: NEG
43978: PUSH
43979: EMPTY
43980: LIST
43981: LIST
43982: PUSH
43983: LD_INT 1
43985: PUSH
43986: LD_INT 3
43988: NEG
43989: PUSH
43990: EMPTY
43991: LIST
43992: LIST
43993: PUSH
43994: LD_INT 0
43996: PUSH
43997: LD_INT 3
43999: NEG
44000: PUSH
44001: EMPTY
44002: LIST
44003: LIST
44004: PUSH
44005: LD_INT 1
44007: NEG
44008: PUSH
44009: LD_INT 4
44011: NEG
44012: PUSH
44013: EMPTY
44014: LIST
44015: LIST
44016: PUSH
44017: LD_INT 1
44019: NEG
44020: PUSH
44021: LD_INT 5
44023: NEG
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 2
44031: PUSH
44032: LD_INT 3
44034: NEG
44035: PUSH
44036: EMPTY
44037: LIST
44038: LIST
44039: PUSH
44040: LD_INT 2
44042: NEG
44043: PUSH
44044: LD_INT 5
44046: NEG
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: PUSH
44052: LD_INT 3
44054: PUSH
44055: LD_INT 0
44057: PUSH
44058: EMPTY
44059: LIST
44060: LIST
44061: PUSH
44062: LD_INT 3
44064: PUSH
44065: LD_INT 1
44067: NEG
44068: PUSH
44069: EMPTY
44070: LIST
44071: LIST
44072: PUSH
44073: LD_INT 4
44075: PUSH
44076: LD_INT 0
44078: PUSH
44079: EMPTY
44080: LIST
44081: LIST
44082: PUSH
44083: LD_INT 4
44085: PUSH
44086: LD_INT 1
44088: PUSH
44089: EMPTY
44090: LIST
44091: LIST
44092: PUSH
44093: LD_INT 3
44095: PUSH
44096: LD_INT 1
44098: PUSH
44099: EMPTY
44100: LIST
44101: LIST
44102: PUSH
44103: LD_INT 2
44105: PUSH
44106: LD_INT 0
44108: PUSH
44109: EMPTY
44110: LIST
44111: LIST
44112: PUSH
44113: LD_INT 2
44115: PUSH
44116: LD_INT 1
44118: NEG
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: PUSH
44124: LD_INT 2
44126: PUSH
44127: LD_INT 2
44129: NEG
44130: PUSH
44131: EMPTY
44132: LIST
44133: LIST
44134: PUSH
44135: LD_INT 4
44137: PUSH
44138: LD_INT 2
44140: PUSH
44141: EMPTY
44142: LIST
44143: LIST
44144: PUSH
44145: LD_INT 4
44147: PUSH
44148: LD_INT 4
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: PUSH
44155: LD_INT 4
44157: PUSH
44158: LD_INT 3
44160: PUSH
44161: EMPTY
44162: LIST
44163: LIST
44164: PUSH
44165: LD_INT 5
44167: PUSH
44168: LD_INT 4
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: LD_INT 5
44177: PUSH
44178: LD_INT 5
44180: PUSH
44181: EMPTY
44182: LIST
44183: LIST
44184: PUSH
44185: LD_INT 4
44187: PUSH
44188: LD_INT 5
44190: PUSH
44191: EMPTY
44192: LIST
44193: LIST
44194: PUSH
44195: LD_INT 3
44197: PUSH
44198: LD_INT 4
44200: PUSH
44201: EMPTY
44202: LIST
44203: LIST
44204: PUSH
44205: LD_INT 3
44207: PUSH
44208: LD_INT 3
44210: PUSH
44211: EMPTY
44212: LIST
44213: LIST
44214: PUSH
44215: LD_INT 5
44217: PUSH
44218: LD_INT 3
44220: PUSH
44221: EMPTY
44222: LIST
44223: LIST
44224: PUSH
44225: LD_INT 3
44227: PUSH
44228: LD_INT 5
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: PUSH
44235: LD_INT 0
44237: PUSH
44238: LD_INT 3
44240: PUSH
44241: EMPTY
44242: LIST
44243: LIST
44244: PUSH
44245: LD_INT 0
44247: PUSH
44248: LD_INT 2
44250: PUSH
44251: EMPTY
44252: LIST
44253: LIST
44254: PUSH
44255: LD_INT 1
44257: PUSH
44258: LD_INT 3
44260: PUSH
44261: EMPTY
44262: LIST
44263: LIST
44264: PUSH
44265: LD_INT 1
44267: PUSH
44268: LD_INT 4
44270: PUSH
44271: EMPTY
44272: LIST
44273: LIST
44274: PUSH
44275: LD_INT 0
44277: PUSH
44278: LD_INT 4
44280: PUSH
44281: EMPTY
44282: LIST
44283: LIST
44284: PUSH
44285: LD_INT 1
44287: NEG
44288: PUSH
44289: LD_INT 3
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 1
44298: NEG
44299: PUSH
44300: LD_INT 2
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: PUSH
44307: LD_INT 2
44309: PUSH
44310: LD_INT 4
44312: PUSH
44313: EMPTY
44314: LIST
44315: LIST
44316: PUSH
44317: LD_INT 2
44319: NEG
44320: PUSH
44321: LD_INT 2
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_INT 4
44330: NEG
44331: PUSH
44332: LD_INT 0
44334: PUSH
44335: EMPTY
44336: LIST
44337: LIST
44338: PUSH
44339: LD_INT 4
44341: NEG
44342: PUSH
44343: LD_INT 1
44345: NEG
44346: PUSH
44347: EMPTY
44348: LIST
44349: LIST
44350: PUSH
44351: LD_INT 3
44353: NEG
44354: PUSH
44355: LD_INT 0
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: LD_INT 3
44364: NEG
44365: PUSH
44366: LD_INT 1
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 4
44375: NEG
44376: PUSH
44377: LD_INT 1
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 5
44386: NEG
44387: PUSH
44388: LD_INT 0
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: PUSH
44395: LD_INT 5
44397: NEG
44398: PUSH
44399: LD_INT 1
44401: NEG
44402: PUSH
44403: EMPTY
44404: LIST
44405: LIST
44406: PUSH
44407: LD_INT 5
44409: NEG
44410: PUSH
44411: LD_INT 2
44413: NEG
44414: PUSH
44415: EMPTY
44416: LIST
44417: LIST
44418: PUSH
44419: LD_INT 3
44421: NEG
44422: PUSH
44423: LD_INT 2
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: LIST
44434: LIST
44435: LIST
44436: LIST
44437: LIST
44438: LIST
44439: LIST
44440: LIST
44441: LIST
44442: LIST
44443: LIST
44444: LIST
44445: LIST
44446: LIST
44447: LIST
44448: LIST
44449: LIST
44450: LIST
44451: LIST
44452: LIST
44453: LIST
44454: LIST
44455: LIST
44456: LIST
44457: LIST
44458: LIST
44459: LIST
44460: LIST
44461: LIST
44462: LIST
44463: LIST
44464: LIST
44465: LIST
44466: LIST
44467: LIST
44468: LIST
44469: LIST
44470: LIST
44471: LIST
44472: LIST
44473: LIST
44474: LIST
44475: LIST
44476: ST_TO_ADDR
// end ; end ;
44477: GO 44480
44479: POP
// case btype of b_depot , b_warehouse :
44480: LD_VAR 0 1
44484: PUSH
44485: LD_INT 0
44487: DOUBLE
44488: EQUAL
44489: IFTRUE 44499
44491: LD_INT 1
44493: DOUBLE
44494: EQUAL
44495: IFTRUE 44499
44497: GO 44700
44499: POP
// case nation of nation_american :
44500: LD_VAR 0 5
44504: PUSH
44505: LD_INT 1
44507: DOUBLE
44508: EQUAL
44509: IFTRUE 44513
44511: GO 44569
44513: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
44514: LD_ADDR_VAR 0 9
44518: PUSH
44519: LD_VAR 0 11
44523: PUSH
44524: LD_VAR 0 12
44528: PUSH
44529: LD_VAR 0 13
44533: PUSH
44534: LD_VAR 0 14
44538: PUSH
44539: LD_VAR 0 15
44543: PUSH
44544: LD_VAR 0 16
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: LIST
44553: LIST
44554: LIST
44555: LIST
44556: PUSH
44557: LD_VAR 0 4
44561: PUSH
44562: LD_INT 1
44564: PLUS
44565: ARRAY
44566: ST_TO_ADDR
44567: GO 44698
44569: LD_INT 2
44571: DOUBLE
44572: EQUAL
44573: IFTRUE 44577
44575: GO 44633
44577: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
44578: LD_ADDR_VAR 0 9
44582: PUSH
44583: LD_VAR 0 17
44587: PUSH
44588: LD_VAR 0 18
44592: PUSH
44593: LD_VAR 0 19
44597: PUSH
44598: LD_VAR 0 20
44602: PUSH
44603: LD_VAR 0 21
44607: PUSH
44608: LD_VAR 0 22
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: LIST
44617: LIST
44618: LIST
44619: LIST
44620: PUSH
44621: LD_VAR 0 4
44625: PUSH
44626: LD_INT 1
44628: PLUS
44629: ARRAY
44630: ST_TO_ADDR
44631: GO 44698
44633: LD_INT 3
44635: DOUBLE
44636: EQUAL
44637: IFTRUE 44641
44639: GO 44697
44641: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
44642: LD_ADDR_VAR 0 9
44646: PUSH
44647: LD_VAR 0 23
44651: PUSH
44652: LD_VAR 0 24
44656: PUSH
44657: LD_VAR 0 25
44661: PUSH
44662: LD_VAR 0 26
44666: PUSH
44667: LD_VAR 0 27
44671: PUSH
44672: LD_VAR 0 28
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: LIST
44681: LIST
44682: LIST
44683: LIST
44684: PUSH
44685: LD_VAR 0 4
44689: PUSH
44690: LD_INT 1
44692: PLUS
44693: ARRAY
44694: ST_TO_ADDR
44695: GO 44698
44697: POP
44698: GO 45253
44700: LD_INT 2
44702: DOUBLE
44703: EQUAL
44704: IFTRUE 44714
44706: LD_INT 3
44708: DOUBLE
44709: EQUAL
44710: IFTRUE 44714
44712: GO 44770
44714: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
44715: LD_ADDR_VAR 0 9
44719: PUSH
44720: LD_VAR 0 29
44724: PUSH
44725: LD_VAR 0 30
44729: PUSH
44730: LD_VAR 0 31
44734: PUSH
44735: LD_VAR 0 32
44739: PUSH
44740: LD_VAR 0 33
44744: PUSH
44745: LD_VAR 0 34
44749: PUSH
44750: EMPTY
44751: LIST
44752: LIST
44753: LIST
44754: LIST
44755: LIST
44756: LIST
44757: PUSH
44758: LD_VAR 0 4
44762: PUSH
44763: LD_INT 1
44765: PLUS
44766: ARRAY
44767: ST_TO_ADDR
44768: GO 45253
44770: LD_INT 16
44772: DOUBLE
44773: EQUAL
44774: IFTRUE 44832
44776: LD_INT 17
44778: DOUBLE
44779: EQUAL
44780: IFTRUE 44832
44782: LD_INT 18
44784: DOUBLE
44785: EQUAL
44786: IFTRUE 44832
44788: LD_INT 19
44790: DOUBLE
44791: EQUAL
44792: IFTRUE 44832
44794: LD_INT 22
44796: DOUBLE
44797: EQUAL
44798: IFTRUE 44832
44800: LD_INT 20
44802: DOUBLE
44803: EQUAL
44804: IFTRUE 44832
44806: LD_INT 21
44808: DOUBLE
44809: EQUAL
44810: IFTRUE 44832
44812: LD_INT 23
44814: DOUBLE
44815: EQUAL
44816: IFTRUE 44832
44818: LD_INT 24
44820: DOUBLE
44821: EQUAL
44822: IFTRUE 44832
44824: LD_INT 25
44826: DOUBLE
44827: EQUAL
44828: IFTRUE 44832
44830: GO 44888
44832: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
44833: LD_ADDR_VAR 0 9
44837: PUSH
44838: LD_VAR 0 35
44842: PUSH
44843: LD_VAR 0 36
44847: PUSH
44848: LD_VAR 0 37
44852: PUSH
44853: LD_VAR 0 38
44857: PUSH
44858: LD_VAR 0 39
44862: PUSH
44863: LD_VAR 0 40
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: LIST
44872: LIST
44873: LIST
44874: LIST
44875: PUSH
44876: LD_VAR 0 4
44880: PUSH
44881: LD_INT 1
44883: PLUS
44884: ARRAY
44885: ST_TO_ADDR
44886: GO 45253
44888: LD_INT 6
44890: DOUBLE
44891: EQUAL
44892: IFTRUE 44944
44894: LD_INT 7
44896: DOUBLE
44897: EQUAL
44898: IFTRUE 44944
44900: LD_INT 8
44902: DOUBLE
44903: EQUAL
44904: IFTRUE 44944
44906: LD_INT 13
44908: DOUBLE
44909: EQUAL
44910: IFTRUE 44944
44912: LD_INT 12
44914: DOUBLE
44915: EQUAL
44916: IFTRUE 44944
44918: LD_INT 15
44920: DOUBLE
44921: EQUAL
44922: IFTRUE 44944
44924: LD_INT 11
44926: DOUBLE
44927: EQUAL
44928: IFTRUE 44944
44930: LD_INT 14
44932: DOUBLE
44933: EQUAL
44934: IFTRUE 44944
44936: LD_INT 10
44938: DOUBLE
44939: EQUAL
44940: IFTRUE 44944
44942: GO 45000
44944: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
44945: LD_ADDR_VAR 0 9
44949: PUSH
44950: LD_VAR 0 41
44954: PUSH
44955: LD_VAR 0 42
44959: PUSH
44960: LD_VAR 0 43
44964: PUSH
44965: LD_VAR 0 44
44969: PUSH
44970: LD_VAR 0 45
44974: PUSH
44975: LD_VAR 0 46
44979: PUSH
44980: EMPTY
44981: LIST
44982: LIST
44983: LIST
44984: LIST
44985: LIST
44986: LIST
44987: PUSH
44988: LD_VAR 0 4
44992: PUSH
44993: LD_INT 1
44995: PLUS
44996: ARRAY
44997: ST_TO_ADDR
44998: GO 45253
45000: LD_INT 36
45002: DOUBLE
45003: EQUAL
45004: IFTRUE 45008
45006: GO 45064
45008: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45009: LD_ADDR_VAR 0 9
45013: PUSH
45014: LD_VAR 0 47
45018: PUSH
45019: LD_VAR 0 48
45023: PUSH
45024: LD_VAR 0 49
45028: PUSH
45029: LD_VAR 0 50
45033: PUSH
45034: LD_VAR 0 51
45038: PUSH
45039: LD_VAR 0 52
45043: PUSH
45044: EMPTY
45045: LIST
45046: LIST
45047: LIST
45048: LIST
45049: LIST
45050: LIST
45051: PUSH
45052: LD_VAR 0 4
45056: PUSH
45057: LD_INT 1
45059: PLUS
45060: ARRAY
45061: ST_TO_ADDR
45062: GO 45253
45064: LD_INT 4
45066: DOUBLE
45067: EQUAL
45068: IFTRUE 45090
45070: LD_INT 5
45072: DOUBLE
45073: EQUAL
45074: IFTRUE 45090
45076: LD_INT 34
45078: DOUBLE
45079: EQUAL
45080: IFTRUE 45090
45082: LD_INT 37
45084: DOUBLE
45085: EQUAL
45086: IFTRUE 45090
45088: GO 45146
45090: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45091: LD_ADDR_VAR 0 9
45095: PUSH
45096: LD_VAR 0 53
45100: PUSH
45101: LD_VAR 0 54
45105: PUSH
45106: LD_VAR 0 55
45110: PUSH
45111: LD_VAR 0 56
45115: PUSH
45116: LD_VAR 0 57
45120: PUSH
45121: LD_VAR 0 58
45125: PUSH
45126: EMPTY
45127: LIST
45128: LIST
45129: LIST
45130: LIST
45131: LIST
45132: LIST
45133: PUSH
45134: LD_VAR 0 4
45138: PUSH
45139: LD_INT 1
45141: PLUS
45142: ARRAY
45143: ST_TO_ADDR
45144: GO 45253
45146: LD_INT 31
45148: DOUBLE
45149: EQUAL
45150: IFTRUE 45196
45152: LD_INT 32
45154: DOUBLE
45155: EQUAL
45156: IFTRUE 45196
45158: LD_INT 33
45160: DOUBLE
45161: EQUAL
45162: IFTRUE 45196
45164: LD_INT 27
45166: DOUBLE
45167: EQUAL
45168: IFTRUE 45196
45170: LD_INT 26
45172: DOUBLE
45173: EQUAL
45174: IFTRUE 45196
45176: LD_INT 28
45178: DOUBLE
45179: EQUAL
45180: IFTRUE 45196
45182: LD_INT 29
45184: DOUBLE
45185: EQUAL
45186: IFTRUE 45196
45188: LD_INT 30
45190: DOUBLE
45191: EQUAL
45192: IFTRUE 45196
45194: GO 45252
45196: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
45197: LD_ADDR_VAR 0 9
45201: PUSH
45202: LD_VAR 0 59
45206: PUSH
45207: LD_VAR 0 60
45211: PUSH
45212: LD_VAR 0 61
45216: PUSH
45217: LD_VAR 0 62
45221: PUSH
45222: LD_VAR 0 63
45226: PUSH
45227: LD_VAR 0 64
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: LIST
45236: LIST
45237: LIST
45238: LIST
45239: PUSH
45240: LD_VAR 0 4
45244: PUSH
45245: LD_INT 1
45247: PLUS
45248: ARRAY
45249: ST_TO_ADDR
45250: GO 45253
45252: POP
// temp_list2 = [ ] ;
45253: LD_ADDR_VAR 0 10
45257: PUSH
45258: EMPTY
45259: ST_TO_ADDR
// for i in temp_list do
45260: LD_ADDR_VAR 0 8
45264: PUSH
45265: LD_VAR 0 9
45269: PUSH
45270: FOR_IN
45271: IFFALSE 45323
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
45273: LD_ADDR_VAR 0 10
45277: PUSH
45278: LD_VAR 0 10
45282: PUSH
45283: LD_VAR 0 8
45287: PUSH
45288: LD_INT 1
45290: ARRAY
45291: PUSH
45292: LD_VAR 0 2
45296: PLUS
45297: PUSH
45298: LD_VAR 0 8
45302: PUSH
45303: LD_INT 2
45305: ARRAY
45306: PUSH
45307: LD_VAR 0 3
45311: PLUS
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: EMPTY
45318: LIST
45319: ADD
45320: ST_TO_ADDR
45321: GO 45270
45323: POP
45324: POP
// result = temp_list2 ;
45325: LD_ADDR_VAR 0 7
45329: PUSH
45330: LD_VAR 0 10
45334: ST_TO_ADDR
// end ;
45335: LD_VAR 0 7
45339: RET
// export function EnemyInRange ( unit , dist ) ; begin
45340: LD_INT 0
45342: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
45343: LD_ADDR_VAR 0 3
45347: PUSH
45348: LD_VAR 0 1
45352: PPUSH
45353: CALL_OW 255
45357: PPUSH
45358: LD_VAR 0 1
45362: PPUSH
45363: CALL_OW 250
45367: PPUSH
45368: LD_VAR 0 1
45372: PPUSH
45373: CALL_OW 251
45377: PPUSH
45378: LD_VAR 0 2
45382: PPUSH
45383: CALL 19444 0 4
45387: PUSH
45388: LD_INT 4
45390: ARRAY
45391: ST_TO_ADDR
// end ;
45392: LD_VAR 0 3
45396: RET
// export function PlayerSeeMe ( unit ) ; begin
45397: LD_INT 0
45399: PPUSH
// result := See ( your_side , unit ) ;
45400: LD_ADDR_VAR 0 2
45404: PUSH
45405: LD_OWVAR 2
45409: PPUSH
45410: LD_VAR 0 1
45414: PPUSH
45415: CALL_OW 292
45419: ST_TO_ADDR
// end ;
45420: LD_VAR 0 2
45424: RET
// export function ReverseDir ( unit ) ; begin
45425: LD_INT 0
45427: PPUSH
// if not unit then
45428: LD_VAR 0 1
45432: NOT
45433: IFFALSE 45437
// exit ;
45435: GO 45460
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
45437: LD_ADDR_VAR 0 2
45441: PUSH
45442: LD_VAR 0 1
45446: PPUSH
45447: CALL_OW 254
45451: PUSH
45452: LD_INT 3
45454: PLUS
45455: PUSH
45456: LD_INT 6
45458: MOD
45459: ST_TO_ADDR
// end ;
45460: LD_VAR 0 2
45464: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
45465: LD_INT 0
45467: PPUSH
45468: PPUSH
45469: PPUSH
45470: PPUSH
45471: PPUSH
// if not hexes then
45472: LD_VAR 0 2
45476: NOT
45477: IFFALSE 45481
// exit ;
45479: GO 45629
// dist := 9999 ;
45481: LD_ADDR_VAR 0 5
45485: PUSH
45486: LD_INT 9999
45488: ST_TO_ADDR
// for i = 1 to hexes do
45489: LD_ADDR_VAR 0 4
45493: PUSH
45494: DOUBLE
45495: LD_INT 1
45497: DEC
45498: ST_TO_ADDR
45499: LD_VAR 0 2
45503: PUSH
45504: FOR_TO
45505: IFFALSE 45617
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
45507: LD_VAR 0 1
45511: PPUSH
45512: LD_VAR 0 2
45516: PUSH
45517: LD_VAR 0 4
45521: ARRAY
45522: PUSH
45523: LD_INT 1
45525: ARRAY
45526: PPUSH
45527: LD_VAR 0 2
45531: PUSH
45532: LD_VAR 0 4
45536: ARRAY
45537: PUSH
45538: LD_INT 2
45540: ARRAY
45541: PPUSH
45542: CALL_OW 297
45546: PUSH
45547: LD_VAR 0 5
45551: LESS
45552: IFFALSE 45615
// begin hex := hexes [ i ] ;
45554: LD_ADDR_VAR 0 7
45558: PUSH
45559: LD_VAR 0 2
45563: PUSH
45564: LD_VAR 0 4
45568: ARRAY
45569: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
45570: LD_ADDR_VAR 0 5
45574: PUSH
45575: LD_VAR 0 1
45579: PPUSH
45580: LD_VAR 0 2
45584: PUSH
45585: LD_VAR 0 4
45589: ARRAY
45590: PUSH
45591: LD_INT 1
45593: ARRAY
45594: PPUSH
45595: LD_VAR 0 2
45599: PUSH
45600: LD_VAR 0 4
45604: ARRAY
45605: PUSH
45606: LD_INT 2
45608: ARRAY
45609: PPUSH
45610: CALL_OW 297
45614: ST_TO_ADDR
// end ; end ;
45615: GO 45504
45617: POP
45618: POP
// result := hex ;
45619: LD_ADDR_VAR 0 3
45623: PUSH
45624: LD_VAR 0 7
45628: ST_TO_ADDR
// end ;
45629: LD_VAR 0 3
45633: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
45634: LD_INT 0
45636: PPUSH
45637: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
45638: LD_VAR 0 1
45642: NOT
45643: PUSH
45644: LD_VAR 0 1
45648: PUSH
45649: LD_INT 21
45651: PUSH
45652: LD_INT 2
45654: PUSH
45655: EMPTY
45656: LIST
45657: LIST
45658: PUSH
45659: LD_INT 23
45661: PUSH
45662: LD_INT 2
45664: PUSH
45665: EMPTY
45666: LIST
45667: LIST
45668: PUSH
45669: EMPTY
45670: LIST
45671: LIST
45672: PPUSH
45673: CALL_OW 69
45677: IN
45678: NOT
45679: OR
45680: IFFALSE 45684
// exit ;
45682: GO 45731
// for i = 1 to 3 do
45684: LD_ADDR_VAR 0 3
45688: PUSH
45689: DOUBLE
45690: LD_INT 1
45692: DEC
45693: ST_TO_ADDR
45694: LD_INT 3
45696: PUSH
45697: FOR_TO
45698: IFFALSE 45729
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
45700: LD_VAR 0 1
45704: PPUSH
45705: CALL_OW 250
45709: PPUSH
45710: LD_VAR 0 1
45714: PPUSH
45715: CALL_OW 251
45719: PPUSH
45720: LD_INT 1
45722: PPUSH
45723: CALL_OW 453
45727: GO 45697
45729: POP
45730: POP
// end ;
45731: LD_VAR 0 2
45735: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
45736: LD_INT 0
45738: PPUSH
45739: PPUSH
45740: PPUSH
45741: PPUSH
45742: PPUSH
45743: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
45744: LD_VAR 0 1
45748: NOT
45749: PUSH
45750: LD_VAR 0 2
45754: NOT
45755: OR
45756: PUSH
45757: LD_VAR 0 1
45761: PPUSH
45762: CALL_OW 314
45766: OR
45767: IFFALSE 45771
// exit ;
45769: GO 46212
// x := GetX ( enemy_unit ) ;
45771: LD_ADDR_VAR 0 7
45775: PUSH
45776: LD_VAR 0 2
45780: PPUSH
45781: CALL_OW 250
45785: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
45786: LD_ADDR_VAR 0 8
45790: PUSH
45791: LD_VAR 0 2
45795: PPUSH
45796: CALL_OW 251
45800: ST_TO_ADDR
// if not x or not y then
45801: LD_VAR 0 7
45805: NOT
45806: PUSH
45807: LD_VAR 0 8
45811: NOT
45812: OR
45813: IFFALSE 45817
// exit ;
45815: GO 46212
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
45817: LD_ADDR_VAR 0 6
45821: PUSH
45822: LD_VAR 0 7
45826: PPUSH
45827: LD_INT 0
45829: PPUSH
45830: LD_INT 4
45832: PPUSH
45833: CALL_OW 272
45837: PUSH
45838: LD_VAR 0 8
45842: PPUSH
45843: LD_INT 0
45845: PPUSH
45846: LD_INT 4
45848: PPUSH
45849: CALL_OW 273
45853: PUSH
45854: EMPTY
45855: LIST
45856: LIST
45857: PUSH
45858: LD_VAR 0 7
45862: PPUSH
45863: LD_INT 1
45865: PPUSH
45866: LD_INT 4
45868: PPUSH
45869: CALL_OW 272
45873: PUSH
45874: LD_VAR 0 8
45878: PPUSH
45879: LD_INT 1
45881: PPUSH
45882: LD_INT 4
45884: PPUSH
45885: CALL_OW 273
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: PUSH
45894: LD_VAR 0 7
45898: PPUSH
45899: LD_INT 2
45901: PPUSH
45902: LD_INT 4
45904: PPUSH
45905: CALL_OW 272
45909: PUSH
45910: LD_VAR 0 8
45914: PPUSH
45915: LD_INT 2
45917: PPUSH
45918: LD_INT 4
45920: PPUSH
45921: CALL_OW 273
45925: PUSH
45926: EMPTY
45927: LIST
45928: LIST
45929: PUSH
45930: LD_VAR 0 7
45934: PPUSH
45935: LD_INT 3
45937: PPUSH
45938: LD_INT 4
45940: PPUSH
45941: CALL_OW 272
45945: PUSH
45946: LD_VAR 0 8
45950: PPUSH
45951: LD_INT 3
45953: PPUSH
45954: LD_INT 4
45956: PPUSH
45957: CALL_OW 273
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: PUSH
45966: LD_VAR 0 7
45970: PPUSH
45971: LD_INT 4
45973: PPUSH
45974: LD_INT 4
45976: PPUSH
45977: CALL_OW 272
45981: PUSH
45982: LD_VAR 0 8
45986: PPUSH
45987: LD_INT 4
45989: PPUSH
45990: LD_INT 4
45992: PPUSH
45993: CALL_OW 273
45997: PUSH
45998: EMPTY
45999: LIST
46000: LIST
46001: PUSH
46002: LD_VAR 0 7
46006: PPUSH
46007: LD_INT 5
46009: PPUSH
46010: LD_INT 4
46012: PPUSH
46013: CALL_OW 272
46017: PUSH
46018: LD_VAR 0 8
46022: PPUSH
46023: LD_INT 5
46025: PPUSH
46026: LD_INT 4
46028: PPUSH
46029: CALL_OW 273
46033: PUSH
46034: EMPTY
46035: LIST
46036: LIST
46037: PUSH
46038: EMPTY
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: LIST
46044: LIST
46045: ST_TO_ADDR
// for i = tmp downto 1 do
46046: LD_ADDR_VAR 0 4
46050: PUSH
46051: DOUBLE
46052: LD_VAR 0 6
46056: INC
46057: ST_TO_ADDR
46058: LD_INT 1
46060: PUSH
46061: FOR_DOWNTO
46062: IFFALSE 46163
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46064: LD_VAR 0 6
46068: PUSH
46069: LD_VAR 0 4
46073: ARRAY
46074: PUSH
46075: LD_INT 1
46077: ARRAY
46078: PPUSH
46079: LD_VAR 0 6
46083: PUSH
46084: LD_VAR 0 4
46088: ARRAY
46089: PUSH
46090: LD_INT 2
46092: ARRAY
46093: PPUSH
46094: CALL_OW 488
46098: NOT
46099: PUSH
46100: LD_VAR 0 6
46104: PUSH
46105: LD_VAR 0 4
46109: ARRAY
46110: PUSH
46111: LD_INT 1
46113: ARRAY
46114: PPUSH
46115: LD_VAR 0 6
46119: PUSH
46120: LD_VAR 0 4
46124: ARRAY
46125: PUSH
46126: LD_INT 2
46128: ARRAY
46129: PPUSH
46130: CALL_OW 428
46134: PUSH
46135: LD_INT 0
46137: NONEQUAL
46138: OR
46139: IFFALSE 46161
// tmp := Delete ( tmp , i ) ;
46141: LD_ADDR_VAR 0 6
46145: PUSH
46146: LD_VAR 0 6
46150: PPUSH
46151: LD_VAR 0 4
46155: PPUSH
46156: CALL_OW 3
46160: ST_TO_ADDR
46161: GO 46061
46163: POP
46164: POP
// j := GetClosestHex ( unit , tmp ) ;
46165: LD_ADDR_VAR 0 5
46169: PUSH
46170: LD_VAR 0 1
46174: PPUSH
46175: LD_VAR 0 6
46179: PPUSH
46180: CALL 45465 0 2
46184: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46185: LD_VAR 0 1
46189: PPUSH
46190: LD_VAR 0 5
46194: PUSH
46195: LD_INT 1
46197: ARRAY
46198: PPUSH
46199: LD_VAR 0 5
46203: PUSH
46204: LD_INT 2
46206: ARRAY
46207: PPUSH
46208: CALL_OW 111
// end ;
46212: LD_VAR 0 3
46216: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46217: LD_INT 0
46219: PPUSH
46220: PPUSH
46221: PPUSH
// uc_side = 0 ;
46222: LD_ADDR_OWVAR 20
46226: PUSH
46227: LD_INT 0
46229: ST_TO_ADDR
// uc_nation = 0 ;
46230: LD_ADDR_OWVAR 21
46234: PUSH
46235: LD_INT 0
46237: ST_TO_ADDR
// InitHc_All ( ) ;
46238: CALL_OW 584
// InitVc ;
46242: CALL_OW 20
// if mastodonts then
46246: LD_VAR 0 6
46250: IFFALSE 46317
// for i = 1 to mastodonts do
46252: LD_ADDR_VAR 0 11
46256: PUSH
46257: DOUBLE
46258: LD_INT 1
46260: DEC
46261: ST_TO_ADDR
46262: LD_VAR 0 6
46266: PUSH
46267: FOR_TO
46268: IFFALSE 46315
// begin vc_chassis := 31 ;
46270: LD_ADDR_OWVAR 37
46274: PUSH
46275: LD_INT 31
46277: ST_TO_ADDR
// vc_control := control_rider ;
46278: LD_ADDR_OWVAR 38
46282: PUSH
46283: LD_INT 4
46285: ST_TO_ADDR
// animal := CreateVehicle ;
46286: LD_ADDR_VAR 0 12
46290: PUSH
46291: CALL_OW 45
46295: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46296: LD_VAR 0 12
46300: PPUSH
46301: LD_VAR 0 8
46305: PPUSH
46306: LD_INT 0
46308: PPUSH
46309: CALL 48505 0 3
// end ;
46313: GO 46267
46315: POP
46316: POP
// if horses then
46317: LD_VAR 0 5
46321: IFFALSE 46388
// for i = 1 to horses do
46323: LD_ADDR_VAR 0 11
46327: PUSH
46328: DOUBLE
46329: LD_INT 1
46331: DEC
46332: ST_TO_ADDR
46333: LD_VAR 0 5
46337: PUSH
46338: FOR_TO
46339: IFFALSE 46386
// begin hc_class := 21 ;
46341: LD_ADDR_OWVAR 28
46345: PUSH
46346: LD_INT 21
46348: ST_TO_ADDR
// hc_gallery :=  ;
46349: LD_ADDR_OWVAR 33
46353: PUSH
46354: LD_STRING 
46356: ST_TO_ADDR
// animal := CreateHuman ;
46357: LD_ADDR_VAR 0 12
46361: PUSH
46362: CALL_OW 44
46366: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46367: LD_VAR 0 12
46371: PPUSH
46372: LD_VAR 0 8
46376: PPUSH
46377: LD_INT 0
46379: PPUSH
46380: CALL 48505 0 3
// end ;
46384: GO 46338
46386: POP
46387: POP
// if birds then
46388: LD_VAR 0 1
46392: IFFALSE 46459
// for i = 1 to birds do
46394: LD_ADDR_VAR 0 11
46398: PUSH
46399: DOUBLE
46400: LD_INT 1
46402: DEC
46403: ST_TO_ADDR
46404: LD_VAR 0 1
46408: PUSH
46409: FOR_TO
46410: IFFALSE 46457
// begin hc_class = 18 ;
46412: LD_ADDR_OWVAR 28
46416: PUSH
46417: LD_INT 18
46419: ST_TO_ADDR
// hc_gallery =  ;
46420: LD_ADDR_OWVAR 33
46424: PUSH
46425: LD_STRING 
46427: ST_TO_ADDR
// animal := CreateHuman ;
46428: LD_ADDR_VAR 0 12
46432: PUSH
46433: CALL_OW 44
46437: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46438: LD_VAR 0 12
46442: PPUSH
46443: LD_VAR 0 8
46447: PPUSH
46448: LD_INT 0
46450: PPUSH
46451: CALL 48505 0 3
// end ;
46455: GO 46409
46457: POP
46458: POP
// if tigers then
46459: LD_VAR 0 2
46463: IFFALSE 46547
// for i = 1 to tigers do
46465: LD_ADDR_VAR 0 11
46469: PUSH
46470: DOUBLE
46471: LD_INT 1
46473: DEC
46474: ST_TO_ADDR
46475: LD_VAR 0 2
46479: PUSH
46480: FOR_TO
46481: IFFALSE 46545
// begin hc_class = class_tiger ;
46483: LD_ADDR_OWVAR 28
46487: PUSH
46488: LD_INT 14
46490: ST_TO_ADDR
// hc_gallery =  ;
46491: LD_ADDR_OWVAR 33
46495: PUSH
46496: LD_STRING 
46498: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
46499: LD_ADDR_OWVAR 35
46503: PUSH
46504: LD_INT 7
46506: NEG
46507: PPUSH
46508: LD_INT 7
46510: PPUSH
46511: CALL_OW 12
46515: ST_TO_ADDR
// animal := CreateHuman ;
46516: LD_ADDR_VAR 0 12
46520: PUSH
46521: CALL_OW 44
46525: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46526: LD_VAR 0 12
46530: PPUSH
46531: LD_VAR 0 8
46535: PPUSH
46536: LD_INT 0
46538: PPUSH
46539: CALL 48505 0 3
// end ;
46543: GO 46480
46545: POP
46546: POP
// if apemans then
46547: LD_VAR 0 3
46551: IFFALSE 46674
// for i = 1 to apemans do
46553: LD_ADDR_VAR 0 11
46557: PUSH
46558: DOUBLE
46559: LD_INT 1
46561: DEC
46562: ST_TO_ADDR
46563: LD_VAR 0 3
46567: PUSH
46568: FOR_TO
46569: IFFALSE 46672
// begin hc_class = class_apeman ;
46571: LD_ADDR_OWVAR 28
46575: PUSH
46576: LD_INT 12
46578: ST_TO_ADDR
// hc_gallery =  ;
46579: LD_ADDR_OWVAR 33
46583: PUSH
46584: LD_STRING 
46586: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
46587: LD_ADDR_OWVAR 35
46591: PUSH
46592: LD_INT 5
46594: NEG
46595: PPUSH
46596: LD_INT 5
46598: PPUSH
46599: CALL_OW 12
46603: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
46604: LD_ADDR_OWVAR 31
46608: PUSH
46609: LD_INT 1
46611: PPUSH
46612: LD_INT 3
46614: PPUSH
46615: CALL_OW 12
46619: PUSH
46620: LD_INT 1
46622: PPUSH
46623: LD_INT 3
46625: PPUSH
46626: CALL_OW 12
46630: PUSH
46631: LD_INT 0
46633: PUSH
46634: LD_INT 0
46636: PUSH
46637: EMPTY
46638: LIST
46639: LIST
46640: LIST
46641: LIST
46642: ST_TO_ADDR
// animal := CreateHuman ;
46643: LD_ADDR_VAR 0 12
46647: PUSH
46648: CALL_OW 44
46652: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46653: LD_VAR 0 12
46657: PPUSH
46658: LD_VAR 0 8
46662: PPUSH
46663: LD_INT 0
46665: PPUSH
46666: CALL 48505 0 3
// end ;
46670: GO 46568
46672: POP
46673: POP
// if enchidnas then
46674: LD_VAR 0 4
46678: IFFALSE 46745
// for i = 1 to enchidnas do
46680: LD_ADDR_VAR 0 11
46684: PUSH
46685: DOUBLE
46686: LD_INT 1
46688: DEC
46689: ST_TO_ADDR
46690: LD_VAR 0 4
46694: PUSH
46695: FOR_TO
46696: IFFALSE 46743
// begin hc_class = 13 ;
46698: LD_ADDR_OWVAR 28
46702: PUSH
46703: LD_INT 13
46705: ST_TO_ADDR
// hc_gallery =  ;
46706: LD_ADDR_OWVAR 33
46710: PUSH
46711: LD_STRING 
46713: ST_TO_ADDR
// animal := CreateHuman ;
46714: LD_ADDR_VAR 0 12
46718: PUSH
46719: CALL_OW 44
46723: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46724: LD_VAR 0 12
46728: PPUSH
46729: LD_VAR 0 8
46733: PPUSH
46734: LD_INT 0
46736: PPUSH
46737: CALL 48505 0 3
// end ;
46741: GO 46695
46743: POP
46744: POP
// if fishes then
46745: LD_VAR 0 7
46749: IFFALSE 46816
// for i = 1 to fishes do
46751: LD_ADDR_VAR 0 11
46755: PUSH
46756: DOUBLE
46757: LD_INT 1
46759: DEC
46760: ST_TO_ADDR
46761: LD_VAR 0 7
46765: PUSH
46766: FOR_TO
46767: IFFALSE 46814
// begin hc_class = 20 ;
46769: LD_ADDR_OWVAR 28
46773: PUSH
46774: LD_INT 20
46776: ST_TO_ADDR
// hc_gallery =  ;
46777: LD_ADDR_OWVAR 33
46781: PUSH
46782: LD_STRING 
46784: ST_TO_ADDR
// animal := CreateHuman ;
46785: LD_ADDR_VAR 0 12
46789: PUSH
46790: CALL_OW 44
46794: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
46795: LD_VAR 0 12
46799: PPUSH
46800: LD_VAR 0 9
46804: PPUSH
46805: LD_INT 0
46807: PPUSH
46808: CALL 48505 0 3
// end ;
46812: GO 46766
46814: POP
46815: POP
// end ;
46816: LD_VAR 0 10
46820: RET
// export function WantHeal ( sci , unit ) ; begin
46821: LD_INT 0
46823: PPUSH
// if GetTaskList ( sci ) > 0 then
46824: LD_VAR 0 1
46828: PPUSH
46829: CALL_OW 437
46833: PUSH
46834: LD_INT 0
46836: GREATER
46837: IFFALSE 46907
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
46839: LD_VAR 0 1
46843: PPUSH
46844: CALL_OW 437
46848: PUSH
46849: LD_INT 1
46851: ARRAY
46852: PUSH
46853: LD_INT 1
46855: ARRAY
46856: PUSH
46857: LD_STRING l
46859: EQUAL
46860: PUSH
46861: LD_VAR 0 1
46865: PPUSH
46866: CALL_OW 437
46870: PUSH
46871: LD_INT 1
46873: ARRAY
46874: PUSH
46875: LD_INT 4
46877: ARRAY
46878: PUSH
46879: LD_VAR 0 2
46883: EQUAL
46884: AND
46885: IFFALSE 46897
// result := true else
46887: LD_ADDR_VAR 0 3
46891: PUSH
46892: LD_INT 1
46894: ST_TO_ADDR
46895: GO 46905
// result := false ;
46897: LD_ADDR_VAR 0 3
46901: PUSH
46902: LD_INT 0
46904: ST_TO_ADDR
// end else
46905: GO 46915
// result := false ;
46907: LD_ADDR_VAR 0 3
46911: PUSH
46912: LD_INT 0
46914: ST_TO_ADDR
// end ;
46915: LD_VAR 0 3
46919: RET
// export function HealTarget ( sci ) ; begin
46920: LD_INT 0
46922: PPUSH
// if not sci then
46923: LD_VAR 0 1
46927: NOT
46928: IFFALSE 46932
// exit ;
46930: GO 46997
// result := 0 ;
46932: LD_ADDR_VAR 0 2
46936: PUSH
46937: LD_INT 0
46939: ST_TO_ADDR
// if GetTaskList ( sci ) then
46940: LD_VAR 0 1
46944: PPUSH
46945: CALL_OW 437
46949: IFFALSE 46997
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
46951: LD_VAR 0 1
46955: PPUSH
46956: CALL_OW 437
46960: PUSH
46961: LD_INT 1
46963: ARRAY
46964: PUSH
46965: LD_INT 1
46967: ARRAY
46968: PUSH
46969: LD_STRING l
46971: EQUAL
46972: IFFALSE 46997
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
46974: LD_ADDR_VAR 0 2
46978: PUSH
46979: LD_VAR 0 1
46983: PPUSH
46984: CALL_OW 437
46988: PUSH
46989: LD_INT 1
46991: ARRAY
46992: PUSH
46993: LD_INT 4
46995: ARRAY
46996: ST_TO_ADDR
// end ;
46997: LD_VAR 0 2
47001: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
47002: LD_INT 0
47004: PPUSH
47005: PPUSH
47006: PPUSH
47007: PPUSH
// if not base_units then
47008: LD_VAR 0 1
47012: NOT
47013: IFFALSE 47017
// exit ;
47015: GO 47104
// result := false ;
47017: LD_ADDR_VAR 0 2
47021: PUSH
47022: LD_INT 0
47024: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
47025: LD_ADDR_VAR 0 5
47029: PUSH
47030: LD_VAR 0 1
47034: PPUSH
47035: LD_INT 21
47037: PUSH
47038: LD_INT 3
47040: PUSH
47041: EMPTY
47042: LIST
47043: LIST
47044: PPUSH
47045: CALL_OW 72
47049: ST_TO_ADDR
// if not tmp then
47050: LD_VAR 0 5
47054: NOT
47055: IFFALSE 47059
// exit ;
47057: GO 47104
// for i in tmp do
47059: LD_ADDR_VAR 0 3
47063: PUSH
47064: LD_VAR 0 5
47068: PUSH
47069: FOR_IN
47070: IFFALSE 47102
// begin result := EnemyInRange ( i , 22 ) ;
47072: LD_ADDR_VAR 0 2
47076: PUSH
47077: LD_VAR 0 3
47081: PPUSH
47082: LD_INT 22
47084: PPUSH
47085: CALL 45340 0 2
47089: ST_TO_ADDR
// if result then
47090: LD_VAR 0 2
47094: IFFALSE 47100
// exit ;
47096: POP
47097: POP
47098: GO 47104
// end ;
47100: GO 47069
47102: POP
47103: POP
// end ;
47104: LD_VAR 0 2
47108: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
47109: LD_INT 0
47111: PPUSH
47112: PPUSH
// if not units then
47113: LD_VAR 0 1
47117: NOT
47118: IFFALSE 47122
// exit ;
47120: GO 47192
// result := [ ] ;
47122: LD_ADDR_VAR 0 3
47126: PUSH
47127: EMPTY
47128: ST_TO_ADDR
// for i in units do
47129: LD_ADDR_VAR 0 4
47133: PUSH
47134: LD_VAR 0 1
47138: PUSH
47139: FOR_IN
47140: IFFALSE 47190
// if GetTag ( i ) = tag then
47142: LD_VAR 0 4
47146: PPUSH
47147: CALL_OW 110
47151: PUSH
47152: LD_VAR 0 2
47156: EQUAL
47157: IFFALSE 47188
// result := Insert ( result , result + 1 , i ) ;
47159: LD_ADDR_VAR 0 3
47163: PUSH
47164: LD_VAR 0 3
47168: PPUSH
47169: LD_VAR 0 3
47173: PUSH
47174: LD_INT 1
47176: PLUS
47177: PPUSH
47178: LD_VAR 0 4
47182: PPUSH
47183: CALL_OW 2
47187: ST_TO_ADDR
47188: GO 47139
47190: POP
47191: POP
// end ;
47192: LD_VAR 0 3
47196: RET
// export function IsDriver ( un ) ; begin
47197: LD_INT 0
47199: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47200: LD_ADDR_VAR 0 2
47204: PUSH
47205: LD_VAR 0 1
47209: PUSH
47210: LD_INT 55
47212: PUSH
47213: EMPTY
47214: LIST
47215: PPUSH
47216: CALL_OW 69
47220: IN
47221: ST_TO_ADDR
// end ;
47222: LD_VAR 0 2
47226: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47227: LD_INT 0
47229: PPUSH
47230: PPUSH
// list := [ ] ;
47231: LD_ADDR_VAR 0 5
47235: PUSH
47236: EMPTY
47237: ST_TO_ADDR
// case d of 0 :
47238: LD_VAR 0 3
47242: PUSH
47243: LD_INT 0
47245: DOUBLE
47246: EQUAL
47247: IFTRUE 47251
47249: GO 47384
47251: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
47252: LD_ADDR_VAR 0 5
47256: PUSH
47257: LD_VAR 0 1
47261: PUSH
47262: LD_INT 4
47264: MINUS
47265: PUSH
47266: LD_VAR 0 2
47270: PUSH
47271: LD_INT 4
47273: MINUS
47274: PUSH
47275: LD_INT 2
47277: PUSH
47278: EMPTY
47279: LIST
47280: LIST
47281: LIST
47282: PUSH
47283: LD_VAR 0 1
47287: PUSH
47288: LD_INT 3
47290: MINUS
47291: PUSH
47292: LD_VAR 0 2
47296: PUSH
47297: LD_INT 1
47299: PUSH
47300: EMPTY
47301: LIST
47302: LIST
47303: LIST
47304: PUSH
47305: LD_VAR 0 1
47309: PUSH
47310: LD_INT 4
47312: PLUS
47313: PUSH
47314: LD_VAR 0 2
47318: PUSH
47319: LD_INT 4
47321: PUSH
47322: EMPTY
47323: LIST
47324: LIST
47325: LIST
47326: PUSH
47327: LD_VAR 0 1
47331: PUSH
47332: LD_INT 3
47334: PLUS
47335: PUSH
47336: LD_VAR 0 2
47340: PUSH
47341: LD_INT 3
47343: PLUS
47344: PUSH
47345: LD_INT 5
47347: PUSH
47348: EMPTY
47349: LIST
47350: LIST
47351: LIST
47352: PUSH
47353: LD_VAR 0 1
47357: PUSH
47358: LD_VAR 0 2
47362: PUSH
47363: LD_INT 4
47365: PLUS
47366: PUSH
47367: LD_INT 0
47369: PUSH
47370: EMPTY
47371: LIST
47372: LIST
47373: LIST
47374: PUSH
47375: EMPTY
47376: LIST
47377: LIST
47378: LIST
47379: LIST
47380: LIST
47381: ST_TO_ADDR
// end ; 1 :
47382: GO 48082
47384: LD_INT 1
47386: DOUBLE
47387: EQUAL
47388: IFTRUE 47392
47390: GO 47525
47392: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
47393: LD_ADDR_VAR 0 5
47397: PUSH
47398: LD_VAR 0 1
47402: PUSH
47403: LD_VAR 0 2
47407: PUSH
47408: LD_INT 4
47410: MINUS
47411: PUSH
47412: LD_INT 3
47414: PUSH
47415: EMPTY
47416: LIST
47417: LIST
47418: LIST
47419: PUSH
47420: LD_VAR 0 1
47424: PUSH
47425: LD_INT 3
47427: MINUS
47428: PUSH
47429: LD_VAR 0 2
47433: PUSH
47434: LD_INT 3
47436: MINUS
47437: PUSH
47438: LD_INT 2
47440: PUSH
47441: EMPTY
47442: LIST
47443: LIST
47444: LIST
47445: PUSH
47446: LD_VAR 0 1
47450: PUSH
47451: LD_INT 4
47453: MINUS
47454: PUSH
47455: LD_VAR 0 2
47459: PUSH
47460: LD_INT 1
47462: PUSH
47463: EMPTY
47464: LIST
47465: LIST
47466: LIST
47467: PUSH
47468: LD_VAR 0 1
47472: PUSH
47473: LD_VAR 0 2
47477: PUSH
47478: LD_INT 3
47480: PLUS
47481: PUSH
47482: LD_INT 0
47484: PUSH
47485: EMPTY
47486: LIST
47487: LIST
47488: LIST
47489: PUSH
47490: LD_VAR 0 1
47494: PUSH
47495: LD_INT 4
47497: PLUS
47498: PUSH
47499: LD_VAR 0 2
47503: PUSH
47504: LD_INT 4
47506: PLUS
47507: PUSH
47508: LD_INT 5
47510: PUSH
47511: EMPTY
47512: LIST
47513: LIST
47514: LIST
47515: PUSH
47516: EMPTY
47517: LIST
47518: LIST
47519: LIST
47520: LIST
47521: LIST
47522: ST_TO_ADDR
// end ; 2 :
47523: GO 48082
47525: LD_INT 2
47527: DOUBLE
47528: EQUAL
47529: IFTRUE 47533
47531: GO 47662
47533: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
47534: LD_ADDR_VAR 0 5
47538: PUSH
47539: LD_VAR 0 1
47543: PUSH
47544: LD_VAR 0 2
47548: PUSH
47549: LD_INT 3
47551: MINUS
47552: PUSH
47553: LD_INT 3
47555: PUSH
47556: EMPTY
47557: LIST
47558: LIST
47559: LIST
47560: PUSH
47561: LD_VAR 0 1
47565: PUSH
47566: LD_INT 4
47568: PLUS
47569: PUSH
47570: LD_VAR 0 2
47574: PUSH
47575: LD_INT 4
47577: PUSH
47578: EMPTY
47579: LIST
47580: LIST
47581: LIST
47582: PUSH
47583: LD_VAR 0 1
47587: PUSH
47588: LD_VAR 0 2
47592: PUSH
47593: LD_INT 4
47595: PLUS
47596: PUSH
47597: LD_INT 0
47599: PUSH
47600: EMPTY
47601: LIST
47602: LIST
47603: LIST
47604: PUSH
47605: LD_VAR 0 1
47609: PUSH
47610: LD_INT 3
47612: MINUS
47613: PUSH
47614: LD_VAR 0 2
47618: PUSH
47619: LD_INT 1
47621: PUSH
47622: EMPTY
47623: LIST
47624: LIST
47625: LIST
47626: PUSH
47627: LD_VAR 0 1
47631: PUSH
47632: LD_INT 4
47634: MINUS
47635: PUSH
47636: LD_VAR 0 2
47640: PUSH
47641: LD_INT 4
47643: MINUS
47644: PUSH
47645: LD_INT 2
47647: PUSH
47648: EMPTY
47649: LIST
47650: LIST
47651: LIST
47652: PUSH
47653: EMPTY
47654: LIST
47655: LIST
47656: LIST
47657: LIST
47658: LIST
47659: ST_TO_ADDR
// end ; 3 :
47660: GO 48082
47662: LD_INT 3
47664: DOUBLE
47665: EQUAL
47666: IFTRUE 47670
47668: GO 47803
47670: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
47671: LD_ADDR_VAR 0 5
47675: PUSH
47676: LD_VAR 0 1
47680: PUSH
47681: LD_INT 3
47683: PLUS
47684: PUSH
47685: LD_VAR 0 2
47689: PUSH
47690: LD_INT 4
47692: PUSH
47693: EMPTY
47694: LIST
47695: LIST
47696: LIST
47697: PUSH
47698: LD_VAR 0 1
47702: PUSH
47703: LD_INT 4
47705: PLUS
47706: PUSH
47707: LD_VAR 0 2
47711: PUSH
47712: LD_INT 4
47714: PLUS
47715: PUSH
47716: LD_INT 5
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: LIST
47723: PUSH
47724: LD_VAR 0 1
47728: PUSH
47729: LD_INT 4
47731: MINUS
47732: PUSH
47733: LD_VAR 0 2
47737: PUSH
47738: LD_INT 1
47740: PUSH
47741: EMPTY
47742: LIST
47743: LIST
47744: LIST
47745: PUSH
47746: LD_VAR 0 1
47750: PUSH
47751: LD_VAR 0 2
47755: PUSH
47756: LD_INT 4
47758: MINUS
47759: PUSH
47760: LD_INT 3
47762: PUSH
47763: EMPTY
47764: LIST
47765: LIST
47766: LIST
47767: PUSH
47768: LD_VAR 0 1
47772: PUSH
47773: LD_INT 3
47775: MINUS
47776: PUSH
47777: LD_VAR 0 2
47781: PUSH
47782: LD_INT 3
47784: MINUS
47785: PUSH
47786: LD_INT 2
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: LIST
47793: PUSH
47794: EMPTY
47795: LIST
47796: LIST
47797: LIST
47798: LIST
47799: LIST
47800: ST_TO_ADDR
// end ; 4 :
47801: GO 48082
47803: LD_INT 4
47805: DOUBLE
47806: EQUAL
47807: IFTRUE 47811
47809: GO 47944
47811: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
47812: LD_ADDR_VAR 0 5
47816: PUSH
47817: LD_VAR 0 1
47821: PUSH
47822: LD_VAR 0 2
47826: PUSH
47827: LD_INT 4
47829: PLUS
47830: PUSH
47831: LD_INT 0
47833: PUSH
47834: EMPTY
47835: LIST
47836: LIST
47837: LIST
47838: PUSH
47839: LD_VAR 0 1
47843: PUSH
47844: LD_INT 3
47846: PLUS
47847: PUSH
47848: LD_VAR 0 2
47852: PUSH
47853: LD_INT 3
47855: PLUS
47856: PUSH
47857: LD_INT 5
47859: PUSH
47860: EMPTY
47861: LIST
47862: LIST
47863: LIST
47864: PUSH
47865: LD_VAR 0 1
47869: PUSH
47870: LD_INT 4
47872: PLUS
47873: PUSH
47874: LD_VAR 0 2
47878: PUSH
47879: LD_INT 4
47881: PUSH
47882: EMPTY
47883: LIST
47884: LIST
47885: LIST
47886: PUSH
47887: LD_VAR 0 1
47891: PUSH
47892: LD_VAR 0 2
47896: PUSH
47897: LD_INT 3
47899: MINUS
47900: PUSH
47901: LD_INT 3
47903: PUSH
47904: EMPTY
47905: LIST
47906: LIST
47907: LIST
47908: PUSH
47909: LD_VAR 0 1
47913: PUSH
47914: LD_INT 4
47916: MINUS
47917: PUSH
47918: LD_VAR 0 2
47922: PUSH
47923: LD_INT 4
47925: MINUS
47926: PUSH
47927: LD_INT 2
47929: PUSH
47930: EMPTY
47931: LIST
47932: LIST
47933: LIST
47934: PUSH
47935: EMPTY
47936: LIST
47937: LIST
47938: LIST
47939: LIST
47940: LIST
47941: ST_TO_ADDR
// end ; 5 :
47942: GO 48082
47944: LD_INT 5
47946: DOUBLE
47947: EQUAL
47948: IFTRUE 47952
47950: GO 48081
47952: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
47953: LD_ADDR_VAR 0 5
47957: PUSH
47958: LD_VAR 0 1
47962: PUSH
47963: LD_INT 4
47965: MINUS
47966: PUSH
47967: LD_VAR 0 2
47971: PUSH
47972: LD_INT 1
47974: PUSH
47975: EMPTY
47976: LIST
47977: LIST
47978: LIST
47979: PUSH
47980: LD_VAR 0 1
47984: PUSH
47985: LD_VAR 0 2
47989: PUSH
47990: LD_INT 4
47992: MINUS
47993: PUSH
47994: LD_INT 3
47996: PUSH
47997: EMPTY
47998: LIST
47999: LIST
48000: LIST
48001: PUSH
48002: LD_VAR 0 1
48006: PUSH
48007: LD_INT 4
48009: PLUS
48010: PUSH
48011: LD_VAR 0 2
48015: PUSH
48016: LD_INT 4
48018: PLUS
48019: PUSH
48020: LD_INT 5
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: LIST
48027: PUSH
48028: LD_VAR 0 1
48032: PUSH
48033: LD_INT 3
48035: PLUS
48036: PUSH
48037: LD_VAR 0 2
48041: PUSH
48042: LD_INT 4
48044: PUSH
48045: EMPTY
48046: LIST
48047: LIST
48048: LIST
48049: PUSH
48050: LD_VAR 0 1
48054: PUSH
48055: LD_VAR 0 2
48059: PUSH
48060: LD_INT 3
48062: PLUS
48063: PUSH
48064: LD_INT 0
48066: PUSH
48067: EMPTY
48068: LIST
48069: LIST
48070: LIST
48071: PUSH
48072: EMPTY
48073: LIST
48074: LIST
48075: LIST
48076: LIST
48077: LIST
48078: ST_TO_ADDR
// end ; end ;
48079: GO 48082
48081: POP
// result := list ;
48082: LD_ADDR_VAR 0 4
48086: PUSH
48087: LD_VAR 0 5
48091: ST_TO_ADDR
// end ;
48092: LD_VAR 0 4
48096: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48097: LD_INT 0
48099: PPUSH
48100: PPUSH
48101: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48102: LD_VAR 0 1
48106: NOT
48107: PUSH
48108: LD_VAR 0 2
48112: PUSH
48113: LD_INT 1
48115: PUSH
48116: LD_INT 2
48118: PUSH
48119: LD_INT 3
48121: PUSH
48122: LD_INT 4
48124: PUSH
48125: EMPTY
48126: LIST
48127: LIST
48128: LIST
48129: LIST
48130: IN
48131: NOT
48132: OR
48133: IFFALSE 48137
// exit ;
48135: GO 48229
// tmp := [ ] ;
48137: LD_ADDR_VAR 0 5
48141: PUSH
48142: EMPTY
48143: ST_TO_ADDR
// for i in units do
48144: LD_ADDR_VAR 0 4
48148: PUSH
48149: LD_VAR 0 1
48153: PUSH
48154: FOR_IN
48155: IFFALSE 48198
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48157: LD_ADDR_VAR 0 5
48161: PUSH
48162: LD_VAR 0 5
48166: PPUSH
48167: LD_VAR 0 5
48171: PUSH
48172: LD_INT 1
48174: PLUS
48175: PPUSH
48176: LD_VAR 0 4
48180: PPUSH
48181: LD_VAR 0 2
48185: PPUSH
48186: CALL_OW 259
48190: PPUSH
48191: CALL_OW 2
48195: ST_TO_ADDR
48196: GO 48154
48198: POP
48199: POP
// if not tmp then
48200: LD_VAR 0 5
48204: NOT
48205: IFFALSE 48209
// exit ;
48207: GO 48229
// result := SortListByListDesc ( units , tmp ) ;
48209: LD_ADDR_VAR 0 3
48213: PUSH
48214: LD_VAR 0 1
48218: PPUSH
48219: LD_VAR 0 5
48223: PPUSH
48224: CALL_OW 77
48228: ST_TO_ADDR
// end ;
48229: LD_VAR 0 3
48233: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48234: LD_INT 0
48236: PPUSH
48237: PPUSH
48238: PPUSH
// result := false ;
48239: LD_ADDR_VAR 0 3
48243: PUSH
48244: LD_INT 0
48246: ST_TO_ADDR
// x := GetX ( building ) ;
48247: LD_ADDR_VAR 0 4
48251: PUSH
48252: LD_VAR 0 2
48256: PPUSH
48257: CALL_OW 250
48261: ST_TO_ADDR
// y := GetY ( building ) ;
48262: LD_ADDR_VAR 0 5
48266: PUSH
48267: LD_VAR 0 2
48271: PPUSH
48272: CALL_OW 251
48276: ST_TO_ADDR
// if not building or not x or not y then
48277: LD_VAR 0 2
48281: NOT
48282: PUSH
48283: LD_VAR 0 4
48287: NOT
48288: OR
48289: PUSH
48290: LD_VAR 0 5
48294: NOT
48295: OR
48296: IFFALSE 48300
// exit ;
48298: GO 48392
// if GetTaskList ( unit ) then
48300: LD_VAR 0 1
48304: PPUSH
48305: CALL_OW 437
48309: IFFALSE 48392
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48311: LD_STRING e
48313: PUSH
48314: LD_VAR 0 1
48318: PPUSH
48319: CALL_OW 437
48323: PUSH
48324: LD_INT 1
48326: ARRAY
48327: PUSH
48328: LD_INT 1
48330: ARRAY
48331: EQUAL
48332: PUSH
48333: LD_VAR 0 4
48337: PUSH
48338: LD_VAR 0 1
48342: PPUSH
48343: CALL_OW 437
48347: PUSH
48348: LD_INT 1
48350: ARRAY
48351: PUSH
48352: LD_INT 2
48354: ARRAY
48355: EQUAL
48356: AND
48357: PUSH
48358: LD_VAR 0 5
48362: PUSH
48363: LD_VAR 0 1
48367: PPUSH
48368: CALL_OW 437
48372: PUSH
48373: LD_INT 1
48375: ARRAY
48376: PUSH
48377: LD_INT 3
48379: ARRAY
48380: EQUAL
48381: AND
48382: IFFALSE 48392
// result := true end ;
48384: LD_ADDR_VAR 0 3
48388: PUSH
48389: LD_INT 1
48391: ST_TO_ADDR
// end ;
48392: LD_VAR 0 3
48396: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
48397: LD_INT 0
48399: PPUSH
// result := false ;
48400: LD_ADDR_VAR 0 4
48404: PUSH
48405: LD_INT 0
48407: ST_TO_ADDR
// if GetTaskList ( unit ) then
48408: LD_VAR 0 1
48412: PPUSH
48413: CALL_OW 437
48417: IFFALSE 48500
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48419: LD_STRING M
48421: PUSH
48422: LD_VAR 0 1
48426: PPUSH
48427: CALL_OW 437
48431: PUSH
48432: LD_INT 1
48434: ARRAY
48435: PUSH
48436: LD_INT 1
48438: ARRAY
48439: EQUAL
48440: PUSH
48441: LD_VAR 0 2
48445: PUSH
48446: LD_VAR 0 1
48450: PPUSH
48451: CALL_OW 437
48455: PUSH
48456: LD_INT 1
48458: ARRAY
48459: PUSH
48460: LD_INT 2
48462: ARRAY
48463: EQUAL
48464: AND
48465: PUSH
48466: LD_VAR 0 3
48470: PUSH
48471: LD_VAR 0 1
48475: PPUSH
48476: CALL_OW 437
48480: PUSH
48481: LD_INT 1
48483: ARRAY
48484: PUSH
48485: LD_INT 3
48487: ARRAY
48488: EQUAL
48489: AND
48490: IFFALSE 48500
// result := true ;
48492: LD_ADDR_VAR 0 4
48496: PUSH
48497: LD_INT 1
48499: ST_TO_ADDR
// end ; end ;
48500: LD_VAR 0 4
48504: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
48505: LD_INT 0
48507: PPUSH
48508: PPUSH
48509: PPUSH
48510: PPUSH
// if not unit or not area then
48511: LD_VAR 0 1
48515: NOT
48516: PUSH
48517: LD_VAR 0 2
48521: NOT
48522: OR
48523: IFFALSE 48527
// exit ;
48525: GO 48691
// tmp := AreaToList ( area , i ) ;
48527: LD_ADDR_VAR 0 6
48531: PUSH
48532: LD_VAR 0 2
48536: PPUSH
48537: LD_VAR 0 5
48541: PPUSH
48542: CALL_OW 517
48546: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
48547: LD_ADDR_VAR 0 5
48551: PUSH
48552: DOUBLE
48553: LD_INT 1
48555: DEC
48556: ST_TO_ADDR
48557: LD_VAR 0 6
48561: PUSH
48562: LD_INT 1
48564: ARRAY
48565: PUSH
48566: FOR_TO
48567: IFFALSE 48689
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
48569: LD_ADDR_VAR 0 7
48573: PUSH
48574: LD_VAR 0 6
48578: PUSH
48579: LD_INT 1
48581: ARRAY
48582: PUSH
48583: LD_VAR 0 5
48587: ARRAY
48588: PUSH
48589: LD_VAR 0 6
48593: PUSH
48594: LD_INT 2
48596: ARRAY
48597: PUSH
48598: LD_VAR 0 5
48602: ARRAY
48603: PUSH
48604: EMPTY
48605: LIST
48606: LIST
48607: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
48608: LD_VAR 0 7
48612: PUSH
48613: LD_INT 1
48615: ARRAY
48616: PPUSH
48617: LD_VAR 0 7
48621: PUSH
48622: LD_INT 2
48624: ARRAY
48625: PPUSH
48626: CALL_OW 428
48630: PUSH
48631: LD_INT 0
48633: EQUAL
48634: IFFALSE 48687
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
48636: LD_VAR 0 1
48640: PPUSH
48641: LD_VAR 0 7
48645: PUSH
48646: LD_INT 1
48648: ARRAY
48649: PPUSH
48650: LD_VAR 0 7
48654: PUSH
48655: LD_INT 2
48657: ARRAY
48658: PPUSH
48659: LD_VAR 0 3
48663: PPUSH
48664: CALL_OW 48
// result := IsPlaced ( unit ) ;
48668: LD_ADDR_VAR 0 4
48672: PUSH
48673: LD_VAR 0 1
48677: PPUSH
48678: CALL_OW 305
48682: ST_TO_ADDR
// exit ;
48683: POP
48684: POP
48685: GO 48691
// end ; end ;
48687: GO 48566
48689: POP
48690: POP
// end ;
48691: LD_VAR 0 4
48695: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
48696: LD_INT 0
48698: PPUSH
48699: PPUSH
48700: PPUSH
// if not side or side > 8 then
48701: LD_VAR 0 1
48705: NOT
48706: PUSH
48707: LD_VAR 0 1
48711: PUSH
48712: LD_INT 8
48714: GREATER
48715: OR
48716: IFFALSE 48720
// exit ;
48718: GO 48907
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
48720: LD_ADDR_VAR 0 4
48724: PUSH
48725: LD_INT 22
48727: PUSH
48728: LD_VAR 0 1
48732: PUSH
48733: EMPTY
48734: LIST
48735: LIST
48736: PUSH
48737: LD_INT 21
48739: PUSH
48740: LD_INT 3
48742: PUSH
48743: EMPTY
48744: LIST
48745: LIST
48746: PUSH
48747: EMPTY
48748: LIST
48749: LIST
48750: PPUSH
48751: CALL_OW 69
48755: ST_TO_ADDR
// if not tmp then
48756: LD_VAR 0 4
48760: NOT
48761: IFFALSE 48765
// exit ;
48763: GO 48907
// enable_addtolog := true ;
48765: LD_ADDR_OWVAR 81
48769: PUSH
48770: LD_INT 1
48772: ST_TO_ADDR
// AddToLog ( [ ) ;
48773: LD_STRING [
48775: PPUSH
48776: CALL_OW 561
// for i in tmp do
48780: LD_ADDR_VAR 0 3
48784: PUSH
48785: LD_VAR 0 4
48789: PUSH
48790: FOR_IN
48791: IFFALSE 48898
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
48793: LD_STRING [
48795: PUSH
48796: LD_VAR 0 3
48800: PPUSH
48801: CALL_OW 266
48805: STR
48806: PUSH
48807: LD_STRING , 
48809: STR
48810: PUSH
48811: LD_VAR 0 3
48815: PPUSH
48816: CALL_OW 250
48820: STR
48821: PUSH
48822: LD_STRING , 
48824: STR
48825: PUSH
48826: LD_VAR 0 3
48830: PPUSH
48831: CALL_OW 251
48835: STR
48836: PUSH
48837: LD_STRING , 
48839: STR
48840: PUSH
48841: LD_VAR 0 3
48845: PPUSH
48846: CALL_OW 254
48850: STR
48851: PUSH
48852: LD_STRING , 
48854: STR
48855: PUSH
48856: LD_VAR 0 3
48860: PPUSH
48861: LD_INT 1
48863: PPUSH
48864: CALL_OW 268
48868: STR
48869: PUSH
48870: LD_STRING , 
48872: STR
48873: PUSH
48874: LD_VAR 0 3
48878: PPUSH
48879: LD_INT 2
48881: PPUSH
48882: CALL_OW 268
48886: STR
48887: PUSH
48888: LD_STRING ],
48890: STR
48891: PPUSH
48892: CALL_OW 561
// end ;
48896: GO 48790
48898: POP
48899: POP
// AddToLog ( ]; ) ;
48900: LD_STRING ];
48902: PPUSH
48903: CALL_OW 561
// end ;
48907: LD_VAR 0 2
48911: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
48912: LD_INT 0
48914: PPUSH
48915: PPUSH
48916: PPUSH
48917: PPUSH
48918: PPUSH
// if not area or not rate or not max then
48919: LD_VAR 0 1
48923: NOT
48924: PUSH
48925: LD_VAR 0 2
48929: NOT
48930: OR
48931: PUSH
48932: LD_VAR 0 4
48936: NOT
48937: OR
48938: IFFALSE 48942
// exit ;
48940: GO 49134
// while 1 do
48942: LD_INT 1
48944: IFFALSE 49134
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
48946: LD_ADDR_VAR 0 9
48950: PUSH
48951: LD_VAR 0 1
48955: PPUSH
48956: LD_INT 1
48958: PPUSH
48959: CALL_OW 287
48963: PUSH
48964: LD_INT 10
48966: MUL
48967: ST_TO_ADDR
// r := rate / 10 ;
48968: LD_ADDR_VAR 0 7
48972: PUSH
48973: LD_VAR 0 2
48977: PUSH
48978: LD_INT 10
48980: DIVREAL
48981: ST_TO_ADDR
// time := 1 1$00 ;
48982: LD_ADDR_VAR 0 8
48986: PUSH
48987: LD_INT 2100
48989: ST_TO_ADDR
// if amount < min then
48990: LD_VAR 0 9
48994: PUSH
48995: LD_VAR 0 3
48999: LESS
49000: IFFALSE 49018
// r := r * 2 else
49002: LD_ADDR_VAR 0 7
49006: PUSH
49007: LD_VAR 0 7
49011: PUSH
49012: LD_INT 2
49014: MUL
49015: ST_TO_ADDR
49016: GO 49044
// if amount > max then
49018: LD_VAR 0 9
49022: PUSH
49023: LD_VAR 0 4
49027: GREATER
49028: IFFALSE 49044
// r := r / 2 ;
49030: LD_ADDR_VAR 0 7
49034: PUSH
49035: LD_VAR 0 7
49039: PUSH
49040: LD_INT 2
49042: DIVREAL
49043: ST_TO_ADDR
// time := time / r ;
49044: LD_ADDR_VAR 0 8
49048: PUSH
49049: LD_VAR 0 8
49053: PUSH
49054: LD_VAR 0 7
49058: DIVREAL
49059: ST_TO_ADDR
// if time < 0 then
49060: LD_VAR 0 8
49064: PUSH
49065: LD_INT 0
49067: LESS
49068: IFFALSE 49085
// time := time * - 1 ;
49070: LD_ADDR_VAR 0 8
49074: PUSH
49075: LD_VAR 0 8
49079: PUSH
49080: LD_INT 1
49082: NEG
49083: MUL
49084: ST_TO_ADDR
// wait ( time ) ;
49085: LD_VAR 0 8
49089: PPUSH
49090: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
49094: LD_INT 35
49096: PPUSH
49097: LD_INT 875
49099: PPUSH
49100: CALL_OW 12
49104: PPUSH
49105: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
49109: LD_INT 1
49111: PPUSH
49112: LD_INT 5
49114: PPUSH
49115: CALL_OW 12
49119: PPUSH
49120: LD_VAR 0 1
49124: PPUSH
49125: LD_INT 1
49127: PPUSH
49128: CALL_OW 55
// end ;
49132: GO 48942
// end ;
49134: LD_VAR 0 5
49138: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
49139: LD_INT 0
49141: PPUSH
49142: PPUSH
49143: PPUSH
49144: PPUSH
49145: PPUSH
49146: PPUSH
49147: PPUSH
49148: PPUSH
// if not turrets or not factories then
49149: LD_VAR 0 1
49153: NOT
49154: PUSH
49155: LD_VAR 0 2
49159: NOT
49160: OR
49161: IFFALSE 49165
// exit ;
49163: GO 49472
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49165: LD_ADDR_VAR 0 10
49169: PUSH
49170: LD_INT 5
49172: PUSH
49173: LD_INT 6
49175: PUSH
49176: EMPTY
49177: LIST
49178: LIST
49179: PUSH
49180: LD_INT 2
49182: PUSH
49183: LD_INT 4
49185: PUSH
49186: EMPTY
49187: LIST
49188: LIST
49189: PUSH
49190: LD_INT 3
49192: PUSH
49193: LD_INT 5
49195: PUSH
49196: EMPTY
49197: LIST
49198: LIST
49199: PUSH
49200: EMPTY
49201: LIST
49202: LIST
49203: LIST
49204: PUSH
49205: LD_INT 24
49207: PUSH
49208: LD_INT 25
49210: PUSH
49211: EMPTY
49212: LIST
49213: LIST
49214: PUSH
49215: LD_INT 23
49217: PUSH
49218: LD_INT 27
49220: PUSH
49221: EMPTY
49222: LIST
49223: LIST
49224: PUSH
49225: EMPTY
49226: LIST
49227: LIST
49228: PUSH
49229: LD_INT 42
49231: PUSH
49232: LD_INT 43
49234: PUSH
49235: EMPTY
49236: LIST
49237: LIST
49238: PUSH
49239: LD_INT 44
49241: PUSH
49242: LD_INT 46
49244: PUSH
49245: EMPTY
49246: LIST
49247: LIST
49248: PUSH
49249: LD_INT 45
49251: PUSH
49252: LD_INT 47
49254: PUSH
49255: EMPTY
49256: LIST
49257: LIST
49258: PUSH
49259: EMPTY
49260: LIST
49261: LIST
49262: LIST
49263: PUSH
49264: EMPTY
49265: LIST
49266: LIST
49267: LIST
49268: ST_TO_ADDR
// result := [ ] ;
49269: LD_ADDR_VAR 0 3
49273: PUSH
49274: EMPTY
49275: ST_TO_ADDR
// for i in turrets do
49276: LD_ADDR_VAR 0 4
49280: PUSH
49281: LD_VAR 0 1
49285: PUSH
49286: FOR_IN
49287: IFFALSE 49470
// begin nat := GetNation ( i ) ;
49289: LD_ADDR_VAR 0 7
49293: PUSH
49294: LD_VAR 0 4
49298: PPUSH
49299: CALL_OW 248
49303: ST_TO_ADDR
// weapon := 0 ;
49304: LD_ADDR_VAR 0 8
49308: PUSH
49309: LD_INT 0
49311: ST_TO_ADDR
// if not nat then
49312: LD_VAR 0 7
49316: NOT
49317: IFFALSE 49321
// continue ;
49319: GO 49286
// for j in list [ nat ] do
49321: LD_ADDR_VAR 0 5
49325: PUSH
49326: LD_VAR 0 10
49330: PUSH
49331: LD_VAR 0 7
49335: ARRAY
49336: PUSH
49337: FOR_IN
49338: IFFALSE 49379
// if GetBWeapon ( i ) = j [ 1 ] then
49340: LD_VAR 0 4
49344: PPUSH
49345: CALL_OW 269
49349: PUSH
49350: LD_VAR 0 5
49354: PUSH
49355: LD_INT 1
49357: ARRAY
49358: EQUAL
49359: IFFALSE 49377
// begin weapon := j [ 2 ] ;
49361: LD_ADDR_VAR 0 8
49365: PUSH
49366: LD_VAR 0 5
49370: PUSH
49371: LD_INT 2
49373: ARRAY
49374: ST_TO_ADDR
// break ;
49375: GO 49379
// end ;
49377: GO 49337
49379: POP
49380: POP
// if not weapon then
49381: LD_VAR 0 8
49385: NOT
49386: IFFALSE 49390
// continue ;
49388: GO 49286
// for k in factories do
49390: LD_ADDR_VAR 0 6
49394: PUSH
49395: LD_VAR 0 2
49399: PUSH
49400: FOR_IN
49401: IFFALSE 49466
// begin weapons := AvailableWeaponList ( k ) ;
49403: LD_ADDR_VAR 0 9
49407: PUSH
49408: LD_VAR 0 6
49412: PPUSH
49413: CALL_OW 478
49417: ST_TO_ADDR
// if not weapons then
49418: LD_VAR 0 9
49422: NOT
49423: IFFALSE 49427
// continue ;
49425: GO 49400
// if weapon in weapons then
49427: LD_VAR 0 8
49431: PUSH
49432: LD_VAR 0 9
49436: IN
49437: IFFALSE 49464
// begin result := [ i , weapon ] ;
49439: LD_ADDR_VAR 0 3
49443: PUSH
49444: LD_VAR 0 4
49448: PUSH
49449: LD_VAR 0 8
49453: PUSH
49454: EMPTY
49455: LIST
49456: LIST
49457: ST_TO_ADDR
// exit ;
49458: POP
49459: POP
49460: POP
49461: POP
49462: GO 49472
// end ; end ;
49464: GO 49400
49466: POP
49467: POP
// end ;
49468: GO 49286
49470: POP
49471: POP
// end ;
49472: LD_VAR 0 3
49476: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
49477: LD_INT 0
49479: PPUSH
// if not side or side > 8 then
49480: LD_VAR 0 3
49484: NOT
49485: PUSH
49486: LD_VAR 0 3
49490: PUSH
49491: LD_INT 8
49493: GREATER
49494: OR
49495: IFFALSE 49499
// exit ;
49497: GO 49558
// if not range then
49499: LD_VAR 0 4
49503: NOT
49504: IFFALSE 49515
// range := - 12 ;
49506: LD_ADDR_VAR 0 4
49510: PUSH
49511: LD_INT 12
49513: NEG
49514: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
49515: LD_VAR 0 1
49519: PPUSH
49520: LD_VAR 0 2
49524: PPUSH
49525: LD_VAR 0 3
49529: PPUSH
49530: LD_VAR 0 4
49534: PPUSH
49535: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
49539: LD_VAR 0 1
49543: PPUSH
49544: LD_VAR 0 2
49548: PPUSH
49549: LD_VAR 0 3
49553: PPUSH
49554: CALL_OW 331
// end ;
49558: LD_VAR 0 5
49562: RET
// export function Video ( mode ) ; begin
49563: LD_INT 0
49565: PPUSH
// ingame_video = mode ;
49566: LD_ADDR_OWVAR 52
49570: PUSH
49571: LD_VAR 0 1
49575: ST_TO_ADDR
// interface_hidden = mode ;
49576: LD_ADDR_OWVAR 54
49580: PUSH
49581: LD_VAR 0 1
49585: ST_TO_ADDR
// end ;
49586: LD_VAR 0 2
49590: RET
// export function Join ( array , element ) ; begin
49591: LD_INT 0
49593: PPUSH
// result := Replace ( array , array + 1 , element ) ;
49594: LD_ADDR_VAR 0 3
49598: PUSH
49599: LD_VAR 0 1
49603: PPUSH
49604: LD_VAR 0 1
49608: PUSH
49609: LD_INT 1
49611: PLUS
49612: PPUSH
49613: LD_VAR 0 2
49617: PPUSH
49618: CALL_OW 1
49622: ST_TO_ADDR
// end ;
49623: LD_VAR 0 3
49627: RET
// export function JoinUnion ( array , element ) ; begin
49628: LD_INT 0
49630: PPUSH
// result := array union element ;
49631: LD_ADDR_VAR 0 3
49635: PUSH
49636: LD_VAR 0 1
49640: PUSH
49641: LD_VAR 0 2
49645: UNION
49646: ST_TO_ADDR
// end ;
49647: LD_VAR 0 3
49651: RET
// export function GetBehemoths ( side ) ; begin
49652: LD_INT 0
49654: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
49655: LD_ADDR_VAR 0 2
49659: PUSH
49660: LD_INT 22
49662: PUSH
49663: LD_VAR 0 1
49667: PUSH
49668: EMPTY
49669: LIST
49670: LIST
49671: PUSH
49672: LD_INT 31
49674: PUSH
49675: LD_INT 25
49677: PUSH
49678: EMPTY
49679: LIST
49680: LIST
49681: PUSH
49682: EMPTY
49683: LIST
49684: LIST
49685: PPUSH
49686: CALL_OW 69
49690: ST_TO_ADDR
// end ;
49691: LD_VAR 0 2
49695: RET
// export function Shuffle ( array ) ; var i , index ; begin
49696: LD_INT 0
49698: PPUSH
49699: PPUSH
49700: PPUSH
// result := [ ] ;
49701: LD_ADDR_VAR 0 2
49705: PUSH
49706: EMPTY
49707: ST_TO_ADDR
// if not array then
49708: LD_VAR 0 1
49712: NOT
49713: IFFALSE 49717
// exit ;
49715: GO 49816
// Randomize ;
49717: CALL_OW 10
// for i = array downto 1 do
49721: LD_ADDR_VAR 0 3
49725: PUSH
49726: DOUBLE
49727: LD_VAR 0 1
49731: INC
49732: ST_TO_ADDR
49733: LD_INT 1
49735: PUSH
49736: FOR_DOWNTO
49737: IFFALSE 49814
// begin index := rand ( 1 , array ) ;
49739: LD_ADDR_VAR 0 4
49743: PUSH
49744: LD_INT 1
49746: PPUSH
49747: LD_VAR 0 1
49751: PPUSH
49752: CALL_OW 12
49756: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
49757: LD_ADDR_VAR 0 2
49761: PUSH
49762: LD_VAR 0 2
49766: PPUSH
49767: LD_VAR 0 2
49771: PUSH
49772: LD_INT 1
49774: PLUS
49775: PPUSH
49776: LD_VAR 0 1
49780: PUSH
49781: LD_VAR 0 4
49785: ARRAY
49786: PPUSH
49787: CALL_OW 2
49791: ST_TO_ADDR
// array := Delete ( array , index ) ;
49792: LD_ADDR_VAR 0 1
49796: PUSH
49797: LD_VAR 0 1
49801: PPUSH
49802: LD_VAR 0 4
49806: PPUSH
49807: CALL_OW 3
49811: ST_TO_ADDR
// end ;
49812: GO 49736
49814: POP
49815: POP
// end ;
49816: LD_VAR 0 2
49820: RET
// export function GetBaseMaterials ( base ) ; begin
49821: LD_INT 0
49823: PPUSH
// result := [ 0 , 0 , 0 ] ;
49824: LD_ADDR_VAR 0 2
49828: PUSH
49829: LD_INT 0
49831: PUSH
49832: LD_INT 0
49834: PUSH
49835: LD_INT 0
49837: PUSH
49838: EMPTY
49839: LIST
49840: LIST
49841: LIST
49842: ST_TO_ADDR
// if not base then
49843: LD_VAR 0 1
49847: NOT
49848: IFFALSE 49852
// exit ;
49850: GO 49901
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
49852: LD_ADDR_VAR 0 2
49856: PUSH
49857: LD_VAR 0 1
49861: PPUSH
49862: LD_INT 1
49864: PPUSH
49865: CALL_OW 275
49869: PUSH
49870: LD_VAR 0 1
49874: PPUSH
49875: LD_INT 2
49877: PPUSH
49878: CALL_OW 275
49882: PUSH
49883: LD_VAR 0 1
49887: PPUSH
49888: LD_INT 3
49890: PPUSH
49891: CALL_OW 275
49895: PUSH
49896: EMPTY
49897: LIST
49898: LIST
49899: LIST
49900: ST_TO_ADDR
// end ;
49901: LD_VAR 0 2
49905: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
49906: LD_INT 0
49908: PPUSH
49909: PPUSH
// result := array ;
49910: LD_ADDR_VAR 0 3
49914: PUSH
49915: LD_VAR 0 1
49919: ST_TO_ADDR
// if size > 0 then
49920: LD_VAR 0 2
49924: PUSH
49925: LD_INT 0
49927: GREATER
49928: IFFALSE 49974
// for i := array downto size do
49930: LD_ADDR_VAR 0 4
49934: PUSH
49935: DOUBLE
49936: LD_VAR 0 1
49940: INC
49941: ST_TO_ADDR
49942: LD_VAR 0 2
49946: PUSH
49947: FOR_DOWNTO
49948: IFFALSE 49972
// result := Delete ( result , result ) ;
49950: LD_ADDR_VAR 0 3
49954: PUSH
49955: LD_VAR 0 3
49959: PPUSH
49960: LD_VAR 0 3
49964: PPUSH
49965: CALL_OW 3
49969: ST_TO_ADDR
49970: GO 49947
49972: POP
49973: POP
// end ;
49974: LD_VAR 0 3
49978: RET
// export function ComExit ( unit ) ; var tmp ; begin
49979: LD_INT 0
49981: PPUSH
49982: PPUSH
// if not IsInUnit ( unit ) then
49983: LD_VAR 0 1
49987: PPUSH
49988: CALL_OW 310
49992: NOT
49993: IFFALSE 49997
// exit ;
49995: GO 50057
// tmp := IsInUnit ( unit ) ;
49997: LD_ADDR_VAR 0 3
50001: PUSH
50002: LD_VAR 0 1
50006: PPUSH
50007: CALL_OW 310
50011: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
50012: LD_VAR 0 3
50016: PPUSH
50017: CALL_OW 247
50021: PUSH
50022: LD_INT 2
50024: EQUAL
50025: IFFALSE 50038
// ComExitVehicle ( unit ) else
50027: LD_VAR 0 1
50031: PPUSH
50032: CALL_OW 121
50036: GO 50047
// ComExitBuilding ( unit ) ;
50038: LD_VAR 0 1
50042: PPUSH
50043: CALL_OW 122
// result := tmp ;
50047: LD_ADDR_VAR 0 2
50051: PUSH
50052: LD_VAR 0 3
50056: ST_TO_ADDR
// end ;
50057: LD_VAR 0 2
50061: RET
// export function ResetHc ; begin
50062: LD_INT 0
50064: PPUSH
// InitHc ;
50065: CALL_OW 19
// hc_importance := 0 ;
50069: LD_ADDR_OWVAR 32
50073: PUSH
50074: LD_INT 0
50076: ST_TO_ADDR
// end ;
50077: LD_VAR 0 1
50081: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
50082: LD_INT 0
50084: PPUSH
50085: PPUSH
50086: PPUSH
// _x := ( x1 + x2 ) div 2 ;
50087: LD_ADDR_VAR 0 6
50091: PUSH
50092: LD_VAR 0 1
50096: PUSH
50097: LD_VAR 0 3
50101: PLUS
50102: PUSH
50103: LD_INT 2
50105: DIV
50106: ST_TO_ADDR
// if _x < 0 then
50107: LD_VAR 0 6
50111: PUSH
50112: LD_INT 0
50114: LESS
50115: IFFALSE 50132
// _x := _x * - 1 ;
50117: LD_ADDR_VAR 0 6
50121: PUSH
50122: LD_VAR 0 6
50126: PUSH
50127: LD_INT 1
50129: NEG
50130: MUL
50131: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
50132: LD_ADDR_VAR 0 7
50136: PUSH
50137: LD_VAR 0 2
50141: PUSH
50142: LD_VAR 0 4
50146: PLUS
50147: PUSH
50148: LD_INT 2
50150: DIV
50151: ST_TO_ADDR
// if _y < 0 then
50152: LD_VAR 0 7
50156: PUSH
50157: LD_INT 0
50159: LESS
50160: IFFALSE 50177
// _y := _y * - 1 ;
50162: LD_ADDR_VAR 0 7
50166: PUSH
50167: LD_VAR 0 7
50171: PUSH
50172: LD_INT 1
50174: NEG
50175: MUL
50176: ST_TO_ADDR
// result := [ _x , _y ] ;
50177: LD_ADDR_VAR 0 5
50181: PUSH
50182: LD_VAR 0 6
50186: PUSH
50187: LD_VAR 0 7
50191: PUSH
50192: EMPTY
50193: LIST
50194: LIST
50195: ST_TO_ADDR
// end ;
50196: LD_VAR 0 5
50200: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
50201: LD_INT 0
50203: PPUSH
50204: PPUSH
50205: PPUSH
50206: PPUSH
// task := GetTaskList ( unit ) ;
50207: LD_ADDR_VAR 0 7
50211: PUSH
50212: LD_VAR 0 1
50216: PPUSH
50217: CALL_OW 437
50221: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
50222: LD_VAR 0 7
50226: NOT
50227: PUSH
50228: LD_VAR 0 1
50232: PPUSH
50233: LD_VAR 0 2
50237: PPUSH
50238: CALL_OW 308
50242: NOT
50243: AND
50244: IFFALSE 50248
// exit ;
50246: GO 50366
// if IsInArea ( unit , area ) then
50248: LD_VAR 0 1
50252: PPUSH
50253: LD_VAR 0 2
50257: PPUSH
50258: CALL_OW 308
50262: IFFALSE 50280
// begin ComMoveToArea ( unit , goAway ) ;
50264: LD_VAR 0 1
50268: PPUSH
50269: LD_VAR 0 3
50273: PPUSH
50274: CALL_OW 113
// exit ;
50278: GO 50366
// end ; if task [ 1 ] [ 1 ] <> M then
50280: LD_VAR 0 7
50284: PUSH
50285: LD_INT 1
50287: ARRAY
50288: PUSH
50289: LD_INT 1
50291: ARRAY
50292: PUSH
50293: LD_STRING M
50295: NONEQUAL
50296: IFFALSE 50300
// exit ;
50298: GO 50366
// x := task [ 1 ] [ 2 ] ;
50300: LD_ADDR_VAR 0 5
50304: PUSH
50305: LD_VAR 0 7
50309: PUSH
50310: LD_INT 1
50312: ARRAY
50313: PUSH
50314: LD_INT 2
50316: ARRAY
50317: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
50318: LD_ADDR_VAR 0 6
50322: PUSH
50323: LD_VAR 0 7
50327: PUSH
50328: LD_INT 1
50330: ARRAY
50331: PUSH
50332: LD_INT 3
50334: ARRAY
50335: ST_TO_ADDR
// if InArea ( x , y , area ) then
50336: LD_VAR 0 5
50340: PPUSH
50341: LD_VAR 0 6
50345: PPUSH
50346: LD_VAR 0 2
50350: PPUSH
50351: CALL_OW 309
50355: IFFALSE 50366
// ComStop ( unit ) ;
50357: LD_VAR 0 1
50361: PPUSH
50362: CALL_OW 141
// end ;
50366: LD_VAR 0 4
50370: RET
// export function Abs ( value ) ; begin
50371: LD_INT 0
50373: PPUSH
// result := value ;
50374: LD_ADDR_VAR 0 2
50378: PUSH
50379: LD_VAR 0 1
50383: ST_TO_ADDR
// if value < 0 then
50384: LD_VAR 0 1
50388: PUSH
50389: LD_INT 0
50391: LESS
50392: IFFALSE 50409
// result := value * - 1 ;
50394: LD_ADDR_VAR 0 2
50398: PUSH
50399: LD_VAR 0 1
50403: PUSH
50404: LD_INT 1
50406: NEG
50407: MUL
50408: ST_TO_ADDR
// end ; end_of_file
50409: LD_VAR 0 2
50413: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
50414: LD_INT 0
50416: PPUSH
// ar_miner := 81 ;
50417: LD_ADDR_EXP 55
50421: PUSH
50422: LD_INT 81
50424: ST_TO_ADDR
// ar_crane := 88 ;
50425: LD_ADDR_EXP 54
50429: PUSH
50430: LD_INT 88
50432: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
50433: LD_ADDR_EXP 49
50437: PUSH
50438: LD_INT 89
50440: ST_TO_ADDR
// us_hack := 99 ;
50441: LD_ADDR_EXP 50
50445: PUSH
50446: LD_INT 99
50448: ST_TO_ADDR
// us_artillery := 97 ;
50449: LD_ADDR_EXP 51
50453: PUSH
50454: LD_INT 97
50456: ST_TO_ADDR
// ar_bio_bomb := 91 ;
50457: LD_ADDR_EXP 52
50461: PUSH
50462: LD_INT 91
50464: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
50465: LD_ADDR_EXP 53
50469: PUSH
50470: LD_INT 92
50472: ST_TO_ADDR
// ru_radar := 98 ;
50473: LD_ADDR_EXP 48
50477: PUSH
50478: LD_INT 98
50480: ST_TO_ADDR
// tech_Artillery := 80 ;
50481: LD_ADDR_EXP 56
50485: PUSH
50486: LD_INT 80
50488: ST_TO_ADDR
// tech_RadMat := 81 ;
50489: LD_ADDR_EXP 57
50493: PUSH
50494: LD_INT 81
50496: ST_TO_ADDR
// tech_BasicTools := 82 ;
50497: LD_ADDR_EXP 58
50501: PUSH
50502: LD_INT 82
50504: ST_TO_ADDR
// tech_Cargo := 83 ;
50505: LD_ADDR_EXP 59
50509: PUSH
50510: LD_INT 83
50512: ST_TO_ADDR
// tech_Track := 84 ;
50513: LD_ADDR_EXP 60
50517: PUSH
50518: LD_INT 84
50520: ST_TO_ADDR
// tech_Crane := 85 ;
50521: LD_ADDR_EXP 61
50525: PUSH
50526: LD_INT 85
50528: ST_TO_ADDR
// tech_Bulldozer := 86 ;
50529: LD_ADDR_EXP 62
50533: PUSH
50534: LD_INT 86
50536: ST_TO_ADDR
// tech_Hovercraft := 87 ;
50537: LD_ADDR_EXP 63
50541: PUSH
50542: LD_INT 87
50544: ST_TO_ADDR
// end ;
50545: LD_VAR 0 1
50549: RET
// every 1 do
50550: GO 50552
50552: DISABLE
// InitGlobalVariables ; end_of_file
50553: CALL 50414 0 0
50557: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
50558: LD_INT 0
50560: PPUSH
50561: PPUSH
// skirmish := false ;
50562: LD_ADDR_EXP 64
50566: PUSH
50567: LD_INT 0
50569: ST_TO_ADDR
// debug_mc := false ;
50570: LD_ADDR_EXP 65
50574: PUSH
50575: LD_INT 0
50577: ST_TO_ADDR
// mc_bases := [ ] ;
50578: LD_ADDR_EXP 66
50582: PUSH
50583: EMPTY
50584: ST_TO_ADDR
// mc_sides := [ ] ;
50585: LD_ADDR_EXP 92
50589: PUSH
50590: EMPTY
50591: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
50592: LD_ADDR_EXP 67
50596: PUSH
50597: EMPTY
50598: ST_TO_ADDR
// mc_building_repairs := [ ] ;
50599: LD_ADDR_EXP 68
50603: PUSH
50604: EMPTY
50605: ST_TO_ADDR
// mc_need_heal := [ ] ;
50606: LD_ADDR_EXP 69
50610: PUSH
50611: EMPTY
50612: ST_TO_ADDR
// mc_healers := [ ] ;
50613: LD_ADDR_EXP 70
50617: PUSH
50618: EMPTY
50619: ST_TO_ADDR
// mc_build_list := [ ] ;
50620: LD_ADDR_EXP 71
50624: PUSH
50625: EMPTY
50626: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
50627: LD_ADDR_EXP 98
50631: PUSH
50632: EMPTY
50633: ST_TO_ADDR
// mc_builders := [ ] ;
50634: LD_ADDR_EXP 72
50638: PUSH
50639: EMPTY
50640: ST_TO_ADDR
// mc_construct_list := [ ] ;
50641: LD_ADDR_EXP 73
50645: PUSH
50646: EMPTY
50647: ST_TO_ADDR
// mc_turret_list := [ ] ;
50648: LD_ADDR_EXP 74
50652: PUSH
50653: EMPTY
50654: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
50655: LD_ADDR_EXP 75
50659: PUSH
50660: EMPTY
50661: ST_TO_ADDR
// mc_miners := [ ] ;
50662: LD_ADDR_EXP 80
50666: PUSH
50667: EMPTY
50668: ST_TO_ADDR
// mc_mines := [ ] ;
50669: LD_ADDR_EXP 79
50673: PUSH
50674: EMPTY
50675: ST_TO_ADDR
// mc_minefields := [ ] ;
50676: LD_ADDR_EXP 81
50680: PUSH
50681: EMPTY
50682: ST_TO_ADDR
// mc_crates := [ ] ;
50683: LD_ADDR_EXP 82
50687: PUSH
50688: EMPTY
50689: ST_TO_ADDR
// mc_crates_collector := [ ] ;
50690: LD_ADDR_EXP 83
50694: PUSH
50695: EMPTY
50696: ST_TO_ADDR
// mc_crates_area := [ ] ;
50697: LD_ADDR_EXP 84
50701: PUSH
50702: EMPTY
50703: ST_TO_ADDR
// mc_vehicles := [ ] ;
50704: LD_ADDR_EXP 85
50708: PUSH
50709: EMPTY
50710: ST_TO_ADDR
// mc_attack := [ ] ;
50711: LD_ADDR_EXP 86
50715: PUSH
50716: EMPTY
50717: ST_TO_ADDR
// mc_produce := [ ] ;
50718: LD_ADDR_EXP 87
50722: PUSH
50723: EMPTY
50724: ST_TO_ADDR
// mc_defender := [ ] ;
50725: LD_ADDR_EXP 88
50729: PUSH
50730: EMPTY
50731: ST_TO_ADDR
// mc_parking := [ ] ;
50732: LD_ADDR_EXP 90
50736: PUSH
50737: EMPTY
50738: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
50739: LD_ADDR_EXP 76
50743: PUSH
50744: EMPTY
50745: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
50746: LD_ADDR_EXP 78
50750: PUSH
50751: EMPTY
50752: ST_TO_ADDR
// mc_scan := [ ] ;
50753: LD_ADDR_EXP 89
50757: PUSH
50758: EMPTY
50759: ST_TO_ADDR
// mc_scan_area := [ ] ;
50760: LD_ADDR_EXP 91
50764: PUSH
50765: EMPTY
50766: ST_TO_ADDR
// mc_tech := [ ] ;
50767: LD_ADDR_EXP 93
50771: PUSH
50772: EMPTY
50773: ST_TO_ADDR
// mc_class := [ ] ;
50774: LD_ADDR_EXP 107
50778: PUSH
50779: EMPTY
50780: ST_TO_ADDR
// mc_class_case_use := [ ] ;
50781: LD_ADDR_EXP 108
50785: PUSH
50786: EMPTY
50787: ST_TO_ADDR
// end ;
50788: LD_VAR 0 1
50792: RET
// export function MC_Kill ( base ) ; begin
50793: LD_INT 0
50795: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
50796: LD_ADDR_EXP 66
50800: PUSH
50801: LD_EXP 66
50805: PPUSH
50806: LD_VAR 0 1
50810: PPUSH
50811: EMPTY
50812: PPUSH
50813: CALL_OW 1
50817: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
50818: LD_ADDR_EXP 67
50822: PUSH
50823: LD_EXP 67
50827: PPUSH
50828: LD_VAR 0 1
50832: PPUSH
50833: EMPTY
50834: PPUSH
50835: CALL_OW 1
50839: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
50840: LD_ADDR_EXP 68
50844: PUSH
50845: LD_EXP 68
50849: PPUSH
50850: LD_VAR 0 1
50854: PPUSH
50855: EMPTY
50856: PPUSH
50857: CALL_OW 1
50861: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
50862: LD_ADDR_EXP 69
50866: PUSH
50867: LD_EXP 69
50871: PPUSH
50872: LD_VAR 0 1
50876: PPUSH
50877: EMPTY
50878: PPUSH
50879: CALL_OW 1
50883: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
50884: LD_ADDR_EXP 70
50888: PUSH
50889: LD_EXP 70
50893: PPUSH
50894: LD_VAR 0 1
50898: PPUSH
50899: EMPTY
50900: PPUSH
50901: CALL_OW 1
50905: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
50906: LD_ADDR_EXP 71
50910: PUSH
50911: LD_EXP 71
50915: PPUSH
50916: LD_VAR 0 1
50920: PPUSH
50921: EMPTY
50922: PPUSH
50923: CALL_OW 1
50927: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
50928: LD_ADDR_EXP 72
50932: PUSH
50933: LD_EXP 72
50937: PPUSH
50938: LD_VAR 0 1
50942: PPUSH
50943: EMPTY
50944: PPUSH
50945: CALL_OW 1
50949: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
50950: LD_ADDR_EXP 73
50954: PUSH
50955: LD_EXP 73
50959: PPUSH
50960: LD_VAR 0 1
50964: PPUSH
50965: EMPTY
50966: PPUSH
50967: CALL_OW 1
50971: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
50972: LD_ADDR_EXP 74
50976: PUSH
50977: LD_EXP 74
50981: PPUSH
50982: LD_VAR 0 1
50986: PPUSH
50987: EMPTY
50988: PPUSH
50989: CALL_OW 1
50993: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
50994: LD_ADDR_EXP 75
50998: PUSH
50999: LD_EXP 75
51003: PPUSH
51004: LD_VAR 0 1
51008: PPUSH
51009: EMPTY
51010: PPUSH
51011: CALL_OW 1
51015: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51016: LD_ADDR_EXP 76
51020: PUSH
51021: LD_EXP 76
51025: PPUSH
51026: LD_VAR 0 1
51030: PPUSH
51031: EMPTY
51032: PPUSH
51033: CALL_OW 1
51037: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51038: LD_ADDR_EXP 77
51042: PUSH
51043: LD_EXP 77
51047: PPUSH
51048: LD_VAR 0 1
51052: PPUSH
51053: LD_INT 0
51055: PPUSH
51056: CALL_OW 1
51060: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51061: LD_ADDR_EXP 78
51065: PUSH
51066: LD_EXP 78
51070: PPUSH
51071: LD_VAR 0 1
51075: PPUSH
51076: EMPTY
51077: PPUSH
51078: CALL_OW 1
51082: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51083: LD_ADDR_EXP 79
51087: PUSH
51088: LD_EXP 79
51092: PPUSH
51093: LD_VAR 0 1
51097: PPUSH
51098: EMPTY
51099: PPUSH
51100: CALL_OW 1
51104: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51105: LD_ADDR_EXP 80
51109: PUSH
51110: LD_EXP 80
51114: PPUSH
51115: LD_VAR 0 1
51119: PPUSH
51120: EMPTY
51121: PPUSH
51122: CALL_OW 1
51126: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51127: LD_ADDR_EXP 81
51131: PUSH
51132: LD_EXP 81
51136: PPUSH
51137: LD_VAR 0 1
51141: PPUSH
51142: EMPTY
51143: PPUSH
51144: CALL_OW 1
51148: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51149: LD_ADDR_EXP 82
51153: PUSH
51154: LD_EXP 82
51158: PPUSH
51159: LD_VAR 0 1
51163: PPUSH
51164: EMPTY
51165: PPUSH
51166: CALL_OW 1
51170: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51171: LD_ADDR_EXP 83
51175: PUSH
51176: LD_EXP 83
51180: PPUSH
51181: LD_VAR 0 1
51185: PPUSH
51186: EMPTY
51187: PPUSH
51188: CALL_OW 1
51192: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51193: LD_ADDR_EXP 84
51197: PUSH
51198: LD_EXP 84
51202: PPUSH
51203: LD_VAR 0 1
51207: PPUSH
51208: EMPTY
51209: PPUSH
51210: CALL_OW 1
51214: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51215: LD_ADDR_EXP 85
51219: PUSH
51220: LD_EXP 85
51224: PPUSH
51225: LD_VAR 0 1
51229: PPUSH
51230: EMPTY
51231: PPUSH
51232: CALL_OW 1
51236: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51237: LD_ADDR_EXP 86
51241: PUSH
51242: LD_EXP 86
51246: PPUSH
51247: LD_VAR 0 1
51251: PPUSH
51252: EMPTY
51253: PPUSH
51254: CALL_OW 1
51258: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51259: LD_ADDR_EXP 87
51263: PUSH
51264: LD_EXP 87
51268: PPUSH
51269: LD_VAR 0 1
51273: PPUSH
51274: EMPTY
51275: PPUSH
51276: CALL_OW 1
51280: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51281: LD_ADDR_EXP 88
51285: PUSH
51286: LD_EXP 88
51290: PPUSH
51291: LD_VAR 0 1
51295: PPUSH
51296: EMPTY
51297: PPUSH
51298: CALL_OW 1
51302: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51303: LD_ADDR_EXP 89
51307: PUSH
51308: LD_EXP 89
51312: PPUSH
51313: LD_VAR 0 1
51317: PPUSH
51318: EMPTY
51319: PPUSH
51320: CALL_OW 1
51324: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51325: LD_ADDR_EXP 90
51329: PUSH
51330: LD_EXP 90
51334: PPUSH
51335: LD_VAR 0 1
51339: PPUSH
51340: EMPTY
51341: PPUSH
51342: CALL_OW 1
51346: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51347: LD_ADDR_EXP 91
51351: PUSH
51352: LD_EXP 91
51356: PPUSH
51357: LD_VAR 0 1
51361: PPUSH
51362: EMPTY
51363: PPUSH
51364: CALL_OW 1
51368: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51369: LD_ADDR_EXP 93
51373: PUSH
51374: LD_EXP 93
51378: PPUSH
51379: LD_VAR 0 1
51383: PPUSH
51384: EMPTY
51385: PPUSH
51386: CALL_OW 1
51390: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51391: LD_ADDR_EXP 95
51395: PUSH
51396: LD_EXP 95
51400: PPUSH
51401: LD_VAR 0 1
51405: PPUSH
51406: EMPTY
51407: PPUSH
51408: CALL_OW 1
51412: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51413: LD_ADDR_EXP 96
51417: PUSH
51418: LD_EXP 96
51422: PPUSH
51423: LD_VAR 0 1
51427: PPUSH
51428: EMPTY
51429: PPUSH
51430: CALL_OW 1
51434: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51435: LD_ADDR_EXP 97
51439: PUSH
51440: LD_EXP 97
51444: PPUSH
51445: LD_VAR 0 1
51449: PPUSH
51450: EMPTY
51451: PPUSH
51452: CALL_OW 1
51456: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51457: LD_ADDR_EXP 98
51461: PUSH
51462: LD_EXP 98
51466: PPUSH
51467: LD_VAR 0 1
51471: PPUSH
51472: EMPTY
51473: PPUSH
51474: CALL_OW 1
51478: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51479: LD_ADDR_EXP 99
51483: PUSH
51484: LD_EXP 99
51488: PPUSH
51489: LD_VAR 0 1
51493: PPUSH
51494: EMPTY
51495: PPUSH
51496: CALL_OW 1
51500: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
51501: LD_ADDR_EXP 100
51505: PUSH
51506: LD_EXP 100
51510: PPUSH
51511: LD_VAR 0 1
51515: PPUSH
51516: EMPTY
51517: PPUSH
51518: CALL_OW 1
51522: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
51523: LD_ADDR_EXP 101
51527: PUSH
51528: LD_EXP 101
51532: PPUSH
51533: LD_VAR 0 1
51537: PPUSH
51538: EMPTY
51539: PPUSH
51540: CALL_OW 1
51544: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
51545: LD_ADDR_EXP 102
51549: PUSH
51550: LD_EXP 102
51554: PPUSH
51555: LD_VAR 0 1
51559: PPUSH
51560: EMPTY
51561: PPUSH
51562: CALL_OW 1
51566: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
51567: LD_ADDR_EXP 103
51571: PUSH
51572: LD_EXP 103
51576: PPUSH
51577: LD_VAR 0 1
51581: PPUSH
51582: EMPTY
51583: PPUSH
51584: CALL_OW 1
51588: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
51589: LD_ADDR_EXP 104
51593: PUSH
51594: LD_EXP 104
51598: PPUSH
51599: LD_VAR 0 1
51603: PPUSH
51604: EMPTY
51605: PPUSH
51606: CALL_OW 1
51610: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
51611: LD_ADDR_EXP 105
51615: PUSH
51616: LD_EXP 105
51620: PPUSH
51621: LD_VAR 0 1
51625: PPUSH
51626: EMPTY
51627: PPUSH
51628: CALL_OW 1
51632: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
51633: LD_ADDR_EXP 106
51637: PUSH
51638: LD_EXP 106
51642: PPUSH
51643: LD_VAR 0 1
51647: PPUSH
51648: EMPTY
51649: PPUSH
51650: CALL_OW 1
51654: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
51655: LD_ADDR_EXP 107
51659: PUSH
51660: LD_EXP 107
51664: PPUSH
51665: LD_VAR 0 1
51669: PPUSH
51670: EMPTY
51671: PPUSH
51672: CALL_OW 1
51676: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
51677: LD_ADDR_EXP 108
51681: PUSH
51682: LD_EXP 108
51686: PPUSH
51687: LD_VAR 0 1
51691: PPUSH
51692: LD_INT 0
51694: PPUSH
51695: CALL_OW 1
51699: ST_TO_ADDR
// end ;
51700: LD_VAR 0 2
51704: RET
// export function MC_Add ( side , units ) ; var base ; begin
51705: LD_INT 0
51707: PPUSH
51708: PPUSH
// base := mc_bases + 1 ;
51709: LD_ADDR_VAR 0 4
51713: PUSH
51714: LD_EXP 66
51718: PUSH
51719: LD_INT 1
51721: PLUS
51722: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
51723: LD_ADDR_EXP 92
51727: PUSH
51728: LD_EXP 92
51732: PPUSH
51733: LD_VAR 0 4
51737: PPUSH
51738: LD_VAR 0 1
51742: PPUSH
51743: CALL_OW 1
51747: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
51748: LD_ADDR_EXP 66
51752: PUSH
51753: LD_EXP 66
51757: PPUSH
51758: LD_VAR 0 4
51762: PPUSH
51763: LD_VAR 0 2
51767: PPUSH
51768: CALL_OW 1
51772: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51773: LD_ADDR_EXP 67
51777: PUSH
51778: LD_EXP 67
51782: PPUSH
51783: LD_VAR 0 4
51787: PPUSH
51788: EMPTY
51789: PPUSH
51790: CALL_OW 1
51794: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51795: LD_ADDR_EXP 68
51799: PUSH
51800: LD_EXP 68
51804: PPUSH
51805: LD_VAR 0 4
51809: PPUSH
51810: EMPTY
51811: PPUSH
51812: CALL_OW 1
51816: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51817: LD_ADDR_EXP 69
51821: PUSH
51822: LD_EXP 69
51826: PPUSH
51827: LD_VAR 0 4
51831: PPUSH
51832: EMPTY
51833: PPUSH
51834: CALL_OW 1
51838: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51839: LD_ADDR_EXP 70
51843: PUSH
51844: LD_EXP 70
51848: PPUSH
51849: LD_VAR 0 4
51853: PPUSH
51854: EMPTY
51855: PPUSH
51856: CALL_OW 1
51860: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51861: LD_ADDR_EXP 71
51865: PUSH
51866: LD_EXP 71
51870: PPUSH
51871: LD_VAR 0 4
51875: PPUSH
51876: EMPTY
51877: PPUSH
51878: CALL_OW 1
51882: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51883: LD_ADDR_EXP 72
51887: PUSH
51888: LD_EXP 72
51892: PPUSH
51893: LD_VAR 0 4
51897: PPUSH
51898: EMPTY
51899: PPUSH
51900: CALL_OW 1
51904: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51905: LD_ADDR_EXP 73
51909: PUSH
51910: LD_EXP 73
51914: PPUSH
51915: LD_VAR 0 4
51919: PPUSH
51920: EMPTY
51921: PPUSH
51922: CALL_OW 1
51926: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51927: LD_ADDR_EXP 74
51931: PUSH
51932: LD_EXP 74
51936: PPUSH
51937: LD_VAR 0 4
51941: PPUSH
51942: EMPTY
51943: PPUSH
51944: CALL_OW 1
51948: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51949: LD_ADDR_EXP 75
51953: PUSH
51954: LD_EXP 75
51958: PPUSH
51959: LD_VAR 0 4
51963: PPUSH
51964: EMPTY
51965: PPUSH
51966: CALL_OW 1
51970: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51971: LD_ADDR_EXP 76
51975: PUSH
51976: LD_EXP 76
51980: PPUSH
51981: LD_VAR 0 4
51985: PPUSH
51986: EMPTY
51987: PPUSH
51988: CALL_OW 1
51992: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51993: LD_ADDR_EXP 77
51997: PUSH
51998: LD_EXP 77
52002: PPUSH
52003: LD_VAR 0 4
52007: PPUSH
52008: LD_INT 0
52010: PPUSH
52011: CALL_OW 1
52015: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52016: LD_ADDR_EXP 78
52020: PUSH
52021: LD_EXP 78
52025: PPUSH
52026: LD_VAR 0 4
52030: PPUSH
52031: EMPTY
52032: PPUSH
52033: CALL_OW 1
52037: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52038: LD_ADDR_EXP 79
52042: PUSH
52043: LD_EXP 79
52047: PPUSH
52048: LD_VAR 0 4
52052: PPUSH
52053: EMPTY
52054: PPUSH
52055: CALL_OW 1
52059: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52060: LD_ADDR_EXP 80
52064: PUSH
52065: LD_EXP 80
52069: PPUSH
52070: LD_VAR 0 4
52074: PPUSH
52075: EMPTY
52076: PPUSH
52077: CALL_OW 1
52081: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52082: LD_ADDR_EXP 81
52086: PUSH
52087: LD_EXP 81
52091: PPUSH
52092: LD_VAR 0 4
52096: PPUSH
52097: EMPTY
52098: PPUSH
52099: CALL_OW 1
52103: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52104: LD_ADDR_EXP 82
52108: PUSH
52109: LD_EXP 82
52113: PPUSH
52114: LD_VAR 0 4
52118: PPUSH
52119: EMPTY
52120: PPUSH
52121: CALL_OW 1
52125: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52126: LD_ADDR_EXP 83
52130: PUSH
52131: LD_EXP 83
52135: PPUSH
52136: LD_VAR 0 4
52140: PPUSH
52141: EMPTY
52142: PPUSH
52143: CALL_OW 1
52147: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52148: LD_ADDR_EXP 84
52152: PUSH
52153: LD_EXP 84
52157: PPUSH
52158: LD_VAR 0 4
52162: PPUSH
52163: EMPTY
52164: PPUSH
52165: CALL_OW 1
52169: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52170: LD_ADDR_EXP 85
52174: PUSH
52175: LD_EXP 85
52179: PPUSH
52180: LD_VAR 0 4
52184: PPUSH
52185: EMPTY
52186: PPUSH
52187: CALL_OW 1
52191: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52192: LD_ADDR_EXP 86
52196: PUSH
52197: LD_EXP 86
52201: PPUSH
52202: LD_VAR 0 4
52206: PPUSH
52207: EMPTY
52208: PPUSH
52209: CALL_OW 1
52213: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52214: LD_ADDR_EXP 87
52218: PUSH
52219: LD_EXP 87
52223: PPUSH
52224: LD_VAR 0 4
52228: PPUSH
52229: EMPTY
52230: PPUSH
52231: CALL_OW 1
52235: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52236: LD_ADDR_EXP 88
52240: PUSH
52241: LD_EXP 88
52245: PPUSH
52246: LD_VAR 0 4
52250: PPUSH
52251: EMPTY
52252: PPUSH
52253: CALL_OW 1
52257: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52258: LD_ADDR_EXP 89
52262: PUSH
52263: LD_EXP 89
52267: PPUSH
52268: LD_VAR 0 4
52272: PPUSH
52273: EMPTY
52274: PPUSH
52275: CALL_OW 1
52279: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52280: LD_ADDR_EXP 90
52284: PUSH
52285: LD_EXP 90
52289: PPUSH
52290: LD_VAR 0 4
52294: PPUSH
52295: EMPTY
52296: PPUSH
52297: CALL_OW 1
52301: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52302: LD_ADDR_EXP 91
52306: PUSH
52307: LD_EXP 91
52311: PPUSH
52312: LD_VAR 0 4
52316: PPUSH
52317: EMPTY
52318: PPUSH
52319: CALL_OW 1
52323: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52324: LD_ADDR_EXP 93
52328: PUSH
52329: LD_EXP 93
52333: PPUSH
52334: LD_VAR 0 4
52338: PPUSH
52339: EMPTY
52340: PPUSH
52341: CALL_OW 1
52345: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52346: LD_ADDR_EXP 95
52350: PUSH
52351: LD_EXP 95
52355: PPUSH
52356: LD_VAR 0 4
52360: PPUSH
52361: EMPTY
52362: PPUSH
52363: CALL_OW 1
52367: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52368: LD_ADDR_EXP 96
52372: PUSH
52373: LD_EXP 96
52377: PPUSH
52378: LD_VAR 0 4
52382: PPUSH
52383: EMPTY
52384: PPUSH
52385: CALL_OW 1
52389: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52390: LD_ADDR_EXP 97
52394: PUSH
52395: LD_EXP 97
52399: PPUSH
52400: LD_VAR 0 4
52404: PPUSH
52405: EMPTY
52406: PPUSH
52407: CALL_OW 1
52411: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52412: LD_ADDR_EXP 98
52416: PUSH
52417: LD_EXP 98
52421: PPUSH
52422: LD_VAR 0 4
52426: PPUSH
52427: EMPTY
52428: PPUSH
52429: CALL_OW 1
52433: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52434: LD_ADDR_EXP 99
52438: PUSH
52439: LD_EXP 99
52443: PPUSH
52444: LD_VAR 0 4
52448: PPUSH
52449: EMPTY
52450: PPUSH
52451: CALL_OW 1
52455: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52456: LD_ADDR_EXP 100
52460: PUSH
52461: LD_EXP 100
52465: PPUSH
52466: LD_VAR 0 4
52470: PPUSH
52471: EMPTY
52472: PPUSH
52473: CALL_OW 1
52477: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52478: LD_ADDR_EXP 101
52482: PUSH
52483: LD_EXP 101
52487: PPUSH
52488: LD_VAR 0 4
52492: PPUSH
52493: EMPTY
52494: PPUSH
52495: CALL_OW 1
52499: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52500: LD_ADDR_EXP 102
52504: PUSH
52505: LD_EXP 102
52509: PPUSH
52510: LD_VAR 0 4
52514: PPUSH
52515: EMPTY
52516: PPUSH
52517: CALL_OW 1
52521: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52522: LD_ADDR_EXP 103
52526: PUSH
52527: LD_EXP 103
52531: PPUSH
52532: LD_VAR 0 4
52536: PPUSH
52537: EMPTY
52538: PPUSH
52539: CALL_OW 1
52543: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52544: LD_ADDR_EXP 104
52548: PUSH
52549: LD_EXP 104
52553: PPUSH
52554: LD_VAR 0 4
52558: PPUSH
52559: EMPTY
52560: PPUSH
52561: CALL_OW 1
52565: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52566: LD_ADDR_EXP 105
52570: PUSH
52571: LD_EXP 105
52575: PPUSH
52576: LD_VAR 0 4
52580: PPUSH
52581: EMPTY
52582: PPUSH
52583: CALL_OW 1
52587: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52588: LD_ADDR_EXP 106
52592: PUSH
52593: LD_EXP 106
52597: PPUSH
52598: LD_VAR 0 4
52602: PPUSH
52603: EMPTY
52604: PPUSH
52605: CALL_OW 1
52609: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52610: LD_ADDR_EXP 107
52614: PUSH
52615: LD_EXP 107
52619: PPUSH
52620: LD_VAR 0 4
52624: PPUSH
52625: EMPTY
52626: PPUSH
52627: CALL_OW 1
52631: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52632: LD_ADDR_EXP 108
52636: PUSH
52637: LD_EXP 108
52641: PPUSH
52642: LD_VAR 0 4
52646: PPUSH
52647: LD_INT 0
52649: PPUSH
52650: CALL_OW 1
52654: ST_TO_ADDR
// result := base ;
52655: LD_ADDR_VAR 0 3
52659: PUSH
52660: LD_VAR 0 4
52664: ST_TO_ADDR
// end ;
52665: LD_VAR 0 3
52669: RET
// export function MC_Start ( ) ; var i ; begin
52670: LD_INT 0
52672: PPUSH
52673: PPUSH
// for i = 1 to mc_bases do
52674: LD_ADDR_VAR 0 2
52678: PUSH
52679: DOUBLE
52680: LD_INT 1
52682: DEC
52683: ST_TO_ADDR
52684: LD_EXP 66
52688: PUSH
52689: FOR_TO
52690: IFFALSE 53767
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
52692: LD_ADDR_EXP 66
52696: PUSH
52697: LD_EXP 66
52701: PPUSH
52702: LD_VAR 0 2
52706: PPUSH
52707: LD_EXP 66
52711: PUSH
52712: LD_VAR 0 2
52716: ARRAY
52717: PUSH
52718: LD_INT 0
52720: DIFF
52721: PPUSH
52722: CALL_OW 1
52726: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
52727: LD_ADDR_EXP 67
52731: PUSH
52732: LD_EXP 67
52736: PPUSH
52737: LD_VAR 0 2
52741: PPUSH
52742: EMPTY
52743: PPUSH
52744: CALL_OW 1
52748: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
52749: LD_ADDR_EXP 68
52753: PUSH
52754: LD_EXP 68
52758: PPUSH
52759: LD_VAR 0 2
52763: PPUSH
52764: EMPTY
52765: PPUSH
52766: CALL_OW 1
52770: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
52771: LD_ADDR_EXP 69
52775: PUSH
52776: LD_EXP 69
52780: PPUSH
52781: LD_VAR 0 2
52785: PPUSH
52786: EMPTY
52787: PPUSH
52788: CALL_OW 1
52792: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
52793: LD_ADDR_EXP 70
52797: PUSH
52798: LD_EXP 70
52802: PPUSH
52803: LD_VAR 0 2
52807: PPUSH
52808: EMPTY
52809: PUSH
52810: EMPTY
52811: PUSH
52812: EMPTY
52813: LIST
52814: LIST
52815: PPUSH
52816: CALL_OW 1
52820: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
52821: LD_ADDR_EXP 71
52825: PUSH
52826: LD_EXP 71
52830: PPUSH
52831: LD_VAR 0 2
52835: PPUSH
52836: EMPTY
52837: PPUSH
52838: CALL_OW 1
52842: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
52843: LD_ADDR_EXP 98
52847: PUSH
52848: LD_EXP 98
52852: PPUSH
52853: LD_VAR 0 2
52857: PPUSH
52858: EMPTY
52859: PPUSH
52860: CALL_OW 1
52864: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
52865: LD_ADDR_EXP 72
52869: PUSH
52870: LD_EXP 72
52874: PPUSH
52875: LD_VAR 0 2
52879: PPUSH
52880: EMPTY
52881: PPUSH
52882: CALL_OW 1
52886: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
52887: LD_ADDR_EXP 73
52891: PUSH
52892: LD_EXP 73
52896: PPUSH
52897: LD_VAR 0 2
52901: PPUSH
52902: EMPTY
52903: PPUSH
52904: CALL_OW 1
52908: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
52909: LD_ADDR_EXP 74
52913: PUSH
52914: LD_EXP 74
52918: PPUSH
52919: LD_VAR 0 2
52923: PPUSH
52924: LD_EXP 66
52928: PUSH
52929: LD_VAR 0 2
52933: ARRAY
52934: PPUSH
52935: LD_INT 2
52937: PUSH
52938: LD_INT 30
52940: PUSH
52941: LD_INT 32
52943: PUSH
52944: EMPTY
52945: LIST
52946: LIST
52947: PUSH
52948: LD_INT 30
52950: PUSH
52951: LD_INT 33
52953: PUSH
52954: EMPTY
52955: LIST
52956: LIST
52957: PUSH
52958: EMPTY
52959: LIST
52960: LIST
52961: LIST
52962: PPUSH
52963: CALL_OW 72
52967: PPUSH
52968: CALL_OW 1
52972: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
52973: LD_ADDR_EXP 75
52977: PUSH
52978: LD_EXP 75
52982: PPUSH
52983: LD_VAR 0 2
52987: PPUSH
52988: LD_EXP 66
52992: PUSH
52993: LD_VAR 0 2
52997: ARRAY
52998: PPUSH
52999: LD_INT 2
53001: PUSH
53002: LD_INT 30
53004: PUSH
53005: LD_INT 32
53007: PUSH
53008: EMPTY
53009: LIST
53010: LIST
53011: PUSH
53012: LD_INT 30
53014: PUSH
53015: LD_INT 31
53017: PUSH
53018: EMPTY
53019: LIST
53020: LIST
53021: PUSH
53022: EMPTY
53023: LIST
53024: LIST
53025: LIST
53026: PUSH
53027: LD_INT 58
53029: PUSH
53030: EMPTY
53031: LIST
53032: PUSH
53033: EMPTY
53034: LIST
53035: LIST
53036: PPUSH
53037: CALL_OW 72
53041: PPUSH
53042: CALL_OW 1
53046: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53047: LD_ADDR_EXP 76
53051: PUSH
53052: LD_EXP 76
53056: PPUSH
53057: LD_VAR 0 2
53061: PPUSH
53062: EMPTY
53063: PPUSH
53064: CALL_OW 1
53068: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53069: LD_ADDR_EXP 80
53073: PUSH
53074: LD_EXP 80
53078: PPUSH
53079: LD_VAR 0 2
53083: PPUSH
53084: EMPTY
53085: PPUSH
53086: CALL_OW 1
53090: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53091: LD_ADDR_EXP 79
53095: PUSH
53096: LD_EXP 79
53100: PPUSH
53101: LD_VAR 0 2
53105: PPUSH
53106: EMPTY
53107: PPUSH
53108: CALL_OW 1
53112: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53113: LD_ADDR_EXP 81
53117: PUSH
53118: LD_EXP 81
53122: PPUSH
53123: LD_VAR 0 2
53127: PPUSH
53128: EMPTY
53129: PPUSH
53130: CALL_OW 1
53134: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53135: LD_ADDR_EXP 82
53139: PUSH
53140: LD_EXP 82
53144: PPUSH
53145: LD_VAR 0 2
53149: PPUSH
53150: EMPTY
53151: PPUSH
53152: CALL_OW 1
53156: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53157: LD_ADDR_EXP 83
53161: PUSH
53162: LD_EXP 83
53166: PPUSH
53167: LD_VAR 0 2
53171: PPUSH
53172: EMPTY
53173: PPUSH
53174: CALL_OW 1
53178: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53179: LD_ADDR_EXP 84
53183: PUSH
53184: LD_EXP 84
53188: PPUSH
53189: LD_VAR 0 2
53193: PPUSH
53194: EMPTY
53195: PPUSH
53196: CALL_OW 1
53200: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53201: LD_ADDR_EXP 85
53205: PUSH
53206: LD_EXP 85
53210: PPUSH
53211: LD_VAR 0 2
53215: PPUSH
53216: EMPTY
53217: PPUSH
53218: CALL_OW 1
53222: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53223: LD_ADDR_EXP 86
53227: PUSH
53228: LD_EXP 86
53232: PPUSH
53233: LD_VAR 0 2
53237: PPUSH
53238: EMPTY
53239: PPUSH
53240: CALL_OW 1
53244: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
53245: LD_ADDR_EXP 87
53249: PUSH
53250: LD_EXP 87
53254: PPUSH
53255: LD_VAR 0 2
53259: PPUSH
53260: EMPTY
53261: PPUSH
53262: CALL_OW 1
53266: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53267: LD_ADDR_EXP 88
53271: PUSH
53272: LD_EXP 88
53276: PPUSH
53277: LD_VAR 0 2
53281: PPUSH
53282: EMPTY
53283: PPUSH
53284: CALL_OW 1
53288: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
53289: LD_ADDR_EXP 77
53293: PUSH
53294: LD_EXP 77
53298: PPUSH
53299: LD_VAR 0 2
53303: PPUSH
53304: LD_INT 0
53306: PPUSH
53307: CALL_OW 1
53311: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
53312: LD_ADDR_EXP 90
53316: PUSH
53317: LD_EXP 90
53321: PPUSH
53322: LD_VAR 0 2
53326: PPUSH
53327: LD_INT 0
53329: PPUSH
53330: CALL_OW 1
53334: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53335: LD_ADDR_EXP 78
53339: PUSH
53340: LD_EXP 78
53344: PPUSH
53345: LD_VAR 0 2
53349: PPUSH
53350: EMPTY
53351: PPUSH
53352: CALL_OW 1
53356: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
53357: LD_ADDR_EXP 89
53361: PUSH
53362: LD_EXP 89
53366: PPUSH
53367: LD_VAR 0 2
53371: PPUSH
53372: LD_INT 0
53374: PPUSH
53375: CALL_OW 1
53379: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
53380: LD_ADDR_EXP 91
53384: PUSH
53385: LD_EXP 91
53389: PPUSH
53390: LD_VAR 0 2
53394: PPUSH
53395: EMPTY
53396: PPUSH
53397: CALL_OW 1
53401: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
53402: LD_ADDR_EXP 94
53406: PUSH
53407: LD_EXP 94
53411: PPUSH
53412: LD_VAR 0 2
53416: PPUSH
53417: LD_INT 0
53419: PPUSH
53420: CALL_OW 1
53424: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
53425: LD_ADDR_EXP 95
53429: PUSH
53430: LD_EXP 95
53434: PPUSH
53435: LD_VAR 0 2
53439: PPUSH
53440: EMPTY
53441: PPUSH
53442: CALL_OW 1
53446: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
53447: LD_ADDR_EXP 96
53451: PUSH
53452: LD_EXP 96
53456: PPUSH
53457: LD_VAR 0 2
53461: PPUSH
53462: EMPTY
53463: PPUSH
53464: CALL_OW 1
53468: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53469: LD_ADDR_EXP 97
53473: PUSH
53474: LD_EXP 97
53478: PPUSH
53479: LD_VAR 0 2
53483: PPUSH
53484: EMPTY
53485: PPUSH
53486: CALL_OW 1
53490: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
53491: LD_ADDR_EXP 99
53495: PUSH
53496: LD_EXP 99
53500: PPUSH
53501: LD_VAR 0 2
53505: PPUSH
53506: LD_EXP 66
53510: PUSH
53511: LD_VAR 0 2
53515: ARRAY
53516: PPUSH
53517: LD_INT 2
53519: PUSH
53520: LD_INT 30
53522: PUSH
53523: LD_INT 6
53525: PUSH
53526: EMPTY
53527: LIST
53528: LIST
53529: PUSH
53530: LD_INT 30
53532: PUSH
53533: LD_INT 7
53535: PUSH
53536: EMPTY
53537: LIST
53538: LIST
53539: PUSH
53540: LD_INT 30
53542: PUSH
53543: LD_INT 8
53545: PUSH
53546: EMPTY
53547: LIST
53548: LIST
53549: PUSH
53550: EMPTY
53551: LIST
53552: LIST
53553: LIST
53554: LIST
53555: PPUSH
53556: CALL_OW 72
53560: PPUSH
53561: CALL_OW 1
53565: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
53566: LD_ADDR_EXP 100
53570: PUSH
53571: LD_EXP 100
53575: PPUSH
53576: LD_VAR 0 2
53580: PPUSH
53581: EMPTY
53582: PPUSH
53583: CALL_OW 1
53587: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
53588: LD_ADDR_EXP 101
53592: PUSH
53593: LD_EXP 101
53597: PPUSH
53598: LD_VAR 0 2
53602: PPUSH
53603: EMPTY
53604: PPUSH
53605: CALL_OW 1
53609: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
53610: LD_ADDR_EXP 102
53614: PUSH
53615: LD_EXP 102
53619: PPUSH
53620: LD_VAR 0 2
53624: PPUSH
53625: EMPTY
53626: PPUSH
53627: CALL_OW 1
53631: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
53632: LD_ADDR_EXP 103
53636: PUSH
53637: LD_EXP 103
53641: PPUSH
53642: LD_VAR 0 2
53646: PPUSH
53647: EMPTY
53648: PPUSH
53649: CALL_OW 1
53653: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
53654: LD_ADDR_EXP 104
53658: PUSH
53659: LD_EXP 104
53663: PPUSH
53664: LD_VAR 0 2
53668: PPUSH
53669: EMPTY
53670: PPUSH
53671: CALL_OW 1
53675: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
53676: LD_ADDR_EXP 105
53680: PUSH
53681: LD_EXP 105
53685: PPUSH
53686: LD_VAR 0 2
53690: PPUSH
53691: EMPTY
53692: PPUSH
53693: CALL_OW 1
53697: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
53698: LD_ADDR_EXP 106
53702: PUSH
53703: LD_EXP 106
53707: PPUSH
53708: LD_VAR 0 2
53712: PPUSH
53713: EMPTY
53714: PPUSH
53715: CALL_OW 1
53719: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
53720: LD_ADDR_EXP 107
53724: PUSH
53725: LD_EXP 107
53729: PPUSH
53730: LD_VAR 0 2
53734: PPUSH
53735: EMPTY
53736: PPUSH
53737: CALL_OW 1
53741: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
53742: LD_ADDR_EXP 108
53746: PUSH
53747: LD_EXP 108
53751: PPUSH
53752: LD_VAR 0 2
53756: PPUSH
53757: LD_INT 0
53759: PPUSH
53760: CALL_OW 1
53764: ST_TO_ADDR
// end ;
53765: GO 52689
53767: POP
53768: POP
// MC_InitSides ( ) ;
53769: CALL 54055 0 0
// MC_InitResearch ( ) ;
53773: CALL 53794 0 0
// CustomInitMacro ( ) ;
53777: CALL 5753 0 0
// skirmish := true ;
53781: LD_ADDR_EXP 64
53785: PUSH
53786: LD_INT 1
53788: ST_TO_ADDR
// end ;
53789: LD_VAR 0 1
53793: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
53794: LD_INT 0
53796: PPUSH
53797: PPUSH
53798: PPUSH
53799: PPUSH
53800: PPUSH
53801: PPUSH
// if not mc_bases then
53802: LD_EXP 66
53806: NOT
53807: IFFALSE 53811
// exit ;
53809: GO 54050
// for i = 1 to 8 do
53811: LD_ADDR_VAR 0 2
53815: PUSH
53816: DOUBLE
53817: LD_INT 1
53819: DEC
53820: ST_TO_ADDR
53821: LD_INT 8
53823: PUSH
53824: FOR_TO
53825: IFFALSE 53851
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
53827: LD_ADDR_EXP 93
53831: PUSH
53832: LD_EXP 93
53836: PPUSH
53837: LD_VAR 0 2
53841: PPUSH
53842: EMPTY
53843: PPUSH
53844: CALL_OW 1
53848: ST_TO_ADDR
53849: GO 53824
53851: POP
53852: POP
// tmp := [ ] ;
53853: LD_ADDR_VAR 0 5
53857: PUSH
53858: EMPTY
53859: ST_TO_ADDR
// for i = 1 to mc_sides do
53860: LD_ADDR_VAR 0 2
53864: PUSH
53865: DOUBLE
53866: LD_INT 1
53868: DEC
53869: ST_TO_ADDR
53870: LD_EXP 92
53874: PUSH
53875: FOR_TO
53876: IFFALSE 53934
// if not mc_sides [ i ] in tmp then
53878: LD_EXP 92
53882: PUSH
53883: LD_VAR 0 2
53887: ARRAY
53888: PUSH
53889: LD_VAR 0 5
53893: IN
53894: NOT
53895: IFFALSE 53932
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
53897: LD_ADDR_VAR 0 5
53901: PUSH
53902: LD_VAR 0 5
53906: PPUSH
53907: LD_VAR 0 5
53911: PUSH
53912: LD_INT 1
53914: PLUS
53915: PPUSH
53916: LD_EXP 92
53920: PUSH
53921: LD_VAR 0 2
53925: ARRAY
53926: PPUSH
53927: CALL_OW 2
53931: ST_TO_ADDR
53932: GO 53875
53934: POP
53935: POP
// if not tmp then
53936: LD_VAR 0 5
53940: NOT
53941: IFFALSE 53945
// exit ;
53943: GO 54050
// for j in tmp do
53945: LD_ADDR_VAR 0 3
53949: PUSH
53950: LD_VAR 0 5
53954: PUSH
53955: FOR_IN
53956: IFFALSE 54048
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
53958: LD_ADDR_VAR 0 6
53962: PUSH
53963: LD_INT 22
53965: PUSH
53966: LD_VAR 0 3
53970: PUSH
53971: EMPTY
53972: LIST
53973: LIST
53974: PPUSH
53975: CALL_OW 69
53979: ST_TO_ADDR
// if not un then
53980: LD_VAR 0 6
53984: NOT
53985: IFFALSE 53989
// continue ;
53987: GO 53955
// nation := GetNation ( un [ 1 ] ) ;
53989: LD_ADDR_VAR 0 4
53993: PUSH
53994: LD_VAR 0 6
53998: PUSH
53999: LD_INT 1
54001: ARRAY
54002: PPUSH
54003: CALL_OW 248
54007: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54008: LD_ADDR_EXP 93
54012: PUSH
54013: LD_EXP 93
54017: PPUSH
54018: LD_VAR 0 3
54022: PPUSH
54023: LD_VAR 0 3
54027: PPUSH
54028: LD_VAR 0 4
54032: PPUSH
54033: LD_INT 1
54035: PPUSH
54036: CALL 13665 0 3
54040: PPUSH
54041: CALL_OW 1
54045: ST_TO_ADDR
// end ;
54046: GO 53955
54048: POP
54049: POP
// end ;
54050: LD_VAR 0 1
54054: RET
// export function MC_InitSides ( ) ; var i ; begin
54055: LD_INT 0
54057: PPUSH
54058: PPUSH
// if not mc_bases then
54059: LD_EXP 66
54063: NOT
54064: IFFALSE 54068
// exit ;
54066: GO 54142
// for i = 1 to mc_bases do
54068: LD_ADDR_VAR 0 2
54072: PUSH
54073: DOUBLE
54074: LD_INT 1
54076: DEC
54077: ST_TO_ADDR
54078: LD_EXP 66
54082: PUSH
54083: FOR_TO
54084: IFFALSE 54140
// if mc_bases [ i ] then
54086: LD_EXP 66
54090: PUSH
54091: LD_VAR 0 2
54095: ARRAY
54096: IFFALSE 54138
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54098: LD_ADDR_EXP 92
54102: PUSH
54103: LD_EXP 92
54107: PPUSH
54108: LD_VAR 0 2
54112: PPUSH
54113: LD_EXP 66
54117: PUSH
54118: LD_VAR 0 2
54122: ARRAY
54123: PUSH
54124: LD_INT 1
54126: ARRAY
54127: PPUSH
54128: CALL_OW 255
54132: PPUSH
54133: CALL_OW 1
54137: ST_TO_ADDR
54138: GO 54083
54140: POP
54141: POP
// end ;
54142: LD_VAR 0 1
54146: RET
// every 0 0$01 trigger skirmish do
54147: LD_EXP 64
54151: IFFALSE 54305
54153: GO 54155
54155: DISABLE
// begin enable ;
54156: ENABLE
// MC_CheckBuildings ( ) ;
54157: CALL 58803 0 0
// MC_CheckPeopleLife ( ) ;
54161: CALL 58928 0 0
// RaiseSailEvent ( 100 ) ;
54165: LD_INT 100
54167: PPUSH
54168: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
54172: LD_INT 103
54174: PPUSH
54175: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
54179: LD_INT 104
54181: PPUSH
54182: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
54186: LD_INT 105
54188: PPUSH
54189: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
54193: LD_INT 106
54195: PPUSH
54196: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
54200: LD_INT 107
54202: PPUSH
54203: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
54207: LD_INT 108
54209: PPUSH
54210: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
54214: LD_INT 109
54216: PPUSH
54217: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
54221: LD_INT 110
54223: PPUSH
54224: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
54228: LD_INT 111
54230: PPUSH
54231: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
54235: LD_INT 112
54237: PPUSH
54238: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
54242: LD_INT 113
54244: PPUSH
54245: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
54249: LD_INT 120
54251: PPUSH
54252: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
54256: LD_INT 121
54258: PPUSH
54259: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
54263: LD_INT 122
54265: PPUSH
54266: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
54270: LD_INT 123
54272: PPUSH
54273: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
54277: LD_INT 124
54279: PPUSH
54280: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
54284: LD_INT 125
54286: PPUSH
54287: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
54291: LD_INT 126
54293: PPUSH
54294: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
54298: LD_INT 200
54300: PPUSH
54301: CALL_OW 427
// end ;
54305: END
// on SailEvent ( event ) do begin if event < 100 then
54306: LD_VAR 0 1
54310: PUSH
54311: LD_INT 100
54313: LESS
54314: IFFALSE 54325
// CustomEvent ( event ) ;
54316: LD_VAR 0 1
54320: PPUSH
54321: CALL 5745 0 1
// if event = 100 then
54325: LD_VAR 0 1
54329: PUSH
54330: LD_INT 100
54332: EQUAL
54333: IFFALSE 54339
// MC_ClassManager ( ) ;
54335: CALL 54731 0 0
// if event = 101 then
54339: LD_VAR 0 1
54343: PUSH
54344: LD_INT 101
54346: EQUAL
54347: IFFALSE 54353
// MC_RepairBuildings ( ) ;
54349: CALL 59513 0 0
// if event = 102 then
54353: LD_VAR 0 1
54357: PUSH
54358: LD_INT 102
54360: EQUAL
54361: IFFALSE 54367
// MC_Heal ( ) ;
54363: CALL 60372 0 0
// if event = 103 then
54367: LD_VAR 0 1
54371: PUSH
54372: LD_INT 103
54374: EQUAL
54375: IFFALSE 54381
// MC_Build ( ) ;
54377: CALL 60794 0 0
// if event = 104 then
54381: LD_VAR 0 1
54385: PUSH
54386: LD_INT 104
54388: EQUAL
54389: IFFALSE 54395
// MC_TurretWeapon ( ) ;
54391: CALL 62407 0 0
// if event = 105 then
54395: LD_VAR 0 1
54399: PUSH
54400: LD_INT 105
54402: EQUAL
54403: IFFALSE 54409
// MC_BuildUpgrade ( ) ;
54405: CALL 61958 0 0
// if event = 106 then
54409: LD_VAR 0 1
54413: PUSH
54414: LD_INT 106
54416: EQUAL
54417: IFFALSE 54423
// MC_PlantMines ( ) ;
54419: CALL 62837 0 0
// if event = 107 then
54423: LD_VAR 0 1
54427: PUSH
54428: LD_INT 107
54430: EQUAL
54431: IFFALSE 54437
// MC_CollectCrates ( ) ;
54433: CALL 63635 0 0
// if event = 108 then
54437: LD_VAR 0 1
54441: PUSH
54442: LD_INT 108
54444: EQUAL
54445: IFFALSE 54451
// MC_LinkRemoteControl ( ) ;
54447: CALL 65411 0 0
// if event = 109 then
54451: LD_VAR 0 1
54455: PUSH
54456: LD_INT 109
54458: EQUAL
54459: IFFALSE 54465
// MC_ProduceVehicle ( ) ;
54461: CALL 65592 0 0
// if event = 110 then
54465: LD_VAR 0 1
54469: PUSH
54470: LD_INT 110
54472: EQUAL
54473: IFFALSE 54479
// MC_SendAttack ( ) ;
54475: CALL 66058 0 0
// if event = 111 then
54479: LD_VAR 0 1
54483: PUSH
54484: LD_INT 111
54486: EQUAL
54487: IFFALSE 54493
// MC_Defend ( ) ;
54489: CALL 66166 0 0
// if event = 112 then
54493: LD_VAR 0 1
54497: PUSH
54498: LD_INT 112
54500: EQUAL
54501: IFFALSE 54507
// MC_Research ( ) ;
54503: CALL 66771 0 0
// if event = 113 then
54507: LD_VAR 0 1
54511: PUSH
54512: LD_INT 113
54514: EQUAL
54515: IFFALSE 54521
// MC_MinesTrigger ( ) ;
54517: CALL 67885 0 0
// if event = 120 then
54521: LD_VAR 0 1
54525: PUSH
54526: LD_INT 120
54528: EQUAL
54529: IFFALSE 54535
// MC_RepairVehicle ( ) ;
54531: CALL 67984 0 0
// if event = 121 then
54535: LD_VAR 0 1
54539: PUSH
54540: LD_INT 121
54542: EQUAL
54543: IFFALSE 54549
// MC_TameApe ( ) ;
54545: CALL 68714 0 0
// if event = 122 then
54549: LD_VAR 0 1
54553: PUSH
54554: LD_INT 122
54556: EQUAL
54557: IFFALSE 54563
// MC_ChangeApeClass ( ) ;
54559: CALL 69543 0 0
// if event = 123 then
54563: LD_VAR 0 1
54567: PUSH
54568: LD_INT 123
54570: EQUAL
54571: IFFALSE 54577
// MC_Bazooka ( ) ;
54573: CALL 70193 0 0
// if event = 124 then
54577: LD_VAR 0 1
54581: PUSH
54582: LD_INT 124
54584: EQUAL
54585: IFFALSE 54591
// MC_TeleportExit ( ) ;
54587: CALL 70391 0 0
// if event = 125 then
54591: LD_VAR 0 1
54595: PUSH
54596: LD_INT 125
54598: EQUAL
54599: IFFALSE 54605
// MC_Deposits ( ) ;
54601: CALL 71038 0 0
// if event = 126 then
54605: LD_VAR 0 1
54609: PUSH
54610: LD_INT 126
54612: EQUAL
54613: IFFALSE 54619
// MC_RemoteDriver ( ) ;
54615: CALL 71663 0 0
// if event = 200 then
54619: LD_VAR 0 1
54623: PUSH
54624: LD_INT 200
54626: EQUAL
54627: IFFALSE 54633
// MC_Idle ( ) ;
54629: CALL 73612 0 0
// end ;
54633: PPOPN 1
54635: END
// export function MC_Reset ( base , tag ) ; var i ; begin
54636: LD_INT 0
54638: PPUSH
54639: PPUSH
// if not mc_bases [ base ] or not tag then
54640: LD_EXP 66
54644: PUSH
54645: LD_VAR 0 1
54649: ARRAY
54650: NOT
54651: PUSH
54652: LD_VAR 0 2
54656: NOT
54657: OR
54658: IFFALSE 54662
// exit ;
54660: GO 54726
// for i in mc_bases [ base ] union mc_ape [ base ] do
54662: LD_ADDR_VAR 0 4
54666: PUSH
54667: LD_EXP 66
54671: PUSH
54672: LD_VAR 0 1
54676: ARRAY
54677: PUSH
54678: LD_EXP 95
54682: PUSH
54683: LD_VAR 0 1
54687: ARRAY
54688: UNION
54689: PUSH
54690: FOR_IN
54691: IFFALSE 54724
// if GetTag ( i ) = tag then
54693: LD_VAR 0 4
54697: PPUSH
54698: CALL_OW 110
54702: PUSH
54703: LD_VAR 0 2
54707: EQUAL
54708: IFFALSE 54722
// SetTag ( i , 0 ) ;
54710: LD_VAR 0 4
54714: PPUSH
54715: LD_INT 0
54717: PPUSH
54718: CALL_OW 109
54722: GO 54690
54724: POP
54725: POP
// end ;
54726: LD_VAR 0 3
54730: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
54731: LD_INT 0
54733: PPUSH
54734: PPUSH
54735: PPUSH
54736: PPUSH
54737: PPUSH
54738: PPUSH
54739: PPUSH
54740: PPUSH
// if not mc_bases then
54741: LD_EXP 66
54745: NOT
54746: IFFALSE 54750
// exit ;
54748: GO 55208
// for i = 1 to mc_bases do
54750: LD_ADDR_VAR 0 2
54754: PUSH
54755: DOUBLE
54756: LD_INT 1
54758: DEC
54759: ST_TO_ADDR
54760: LD_EXP 66
54764: PUSH
54765: FOR_TO
54766: IFFALSE 55206
// begin tmp := MC_ClassCheckReq ( i ) ;
54768: LD_ADDR_VAR 0 4
54772: PUSH
54773: LD_VAR 0 2
54777: PPUSH
54778: CALL 55213 0 1
54782: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
54783: LD_ADDR_EXP 107
54787: PUSH
54788: LD_EXP 107
54792: PPUSH
54793: LD_VAR 0 2
54797: PPUSH
54798: LD_VAR 0 4
54802: PPUSH
54803: CALL_OW 1
54807: ST_TO_ADDR
// if not tmp then
54808: LD_VAR 0 4
54812: NOT
54813: IFFALSE 54817
// continue ;
54815: GO 54765
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
54817: LD_ADDR_VAR 0 6
54821: PUSH
54822: LD_EXP 66
54826: PUSH
54827: LD_VAR 0 2
54831: ARRAY
54832: PPUSH
54833: LD_INT 2
54835: PUSH
54836: LD_INT 30
54838: PUSH
54839: LD_INT 4
54841: PUSH
54842: EMPTY
54843: LIST
54844: LIST
54845: PUSH
54846: LD_INT 30
54848: PUSH
54849: LD_INT 5
54851: PUSH
54852: EMPTY
54853: LIST
54854: LIST
54855: PUSH
54856: EMPTY
54857: LIST
54858: LIST
54859: LIST
54860: PPUSH
54861: CALL_OW 72
54865: PUSH
54866: LD_EXP 66
54870: PUSH
54871: LD_VAR 0 2
54875: ARRAY
54876: PPUSH
54877: LD_INT 2
54879: PUSH
54880: LD_INT 30
54882: PUSH
54883: LD_INT 0
54885: PUSH
54886: EMPTY
54887: LIST
54888: LIST
54889: PUSH
54890: LD_INT 30
54892: PUSH
54893: LD_INT 1
54895: PUSH
54896: EMPTY
54897: LIST
54898: LIST
54899: PUSH
54900: EMPTY
54901: LIST
54902: LIST
54903: LIST
54904: PPUSH
54905: CALL_OW 72
54909: PUSH
54910: LD_EXP 66
54914: PUSH
54915: LD_VAR 0 2
54919: ARRAY
54920: PPUSH
54921: LD_INT 30
54923: PUSH
54924: LD_INT 3
54926: PUSH
54927: EMPTY
54928: LIST
54929: LIST
54930: PPUSH
54931: CALL_OW 72
54935: PUSH
54936: LD_EXP 66
54940: PUSH
54941: LD_VAR 0 2
54945: ARRAY
54946: PPUSH
54947: LD_INT 2
54949: PUSH
54950: LD_INT 30
54952: PUSH
54953: LD_INT 6
54955: PUSH
54956: EMPTY
54957: LIST
54958: LIST
54959: PUSH
54960: LD_INT 30
54962: PUSH
54963: LD_INT 7
54965: PUSH
54966: EMPTY
54967: LIST
54968: LIST
54969: PUSH
54970: LD_INT 30
54972: PUSH
54973: LD_INT 8
54975: PUSH
54976: EMPTY
54977: LIST
54978: LIST
54979: PUSH
54980: EMPTY
54981: LIST
54982: LIST
54983: LIST
54984: LIST
54985: PPUSH
54986: CALL_OW 72
54990: PUSH
54991: EMPTY
54992: LIST
54993: LIST
54994: LIST
54995: LIST
54996: ST_TO_ADDR
// for j = 1 to 4 do
54997: LD_ADDR_VAR 0 3
55001: PUSH
55002: DOUBLE
55003: LD_INT 1
55005: DEC
55006: ST_TO_ADDR
55007: LD_INT 4
55009: PUSH
55010: FOR_TO
55011: IFFALSE 55202
// begin if not tmp [ j ] then
55013: LD_VAR 0 4
55017: PUSH
55018: LD_VAR 0 3
55022: ARRAY
55023: NOT
55024: IFFALSE 55028
// continue ;
55026: GO 55010
// for p in tmp [ j ] do
55028: LD_ADDR_VAR 0 5
55032: PUSH
55033: LD_VAR 0 4
55037: PUSH
55038: LD_VAR 0 3
55042: ARRAY
55043: PUSH
55044: FOR_IN
55045: IFFALSE 55198
// begin if not b [ j ] then
55047: LD_VAR 0 6
55051: PUSH
55052: LD_VAR 0 3
55056: ARRAY
55057: NOT
55058: IFFALSE 55062
// break ;
55060: GO 55198
// e := 0 ;
55062: LD_ADDR_VAR 0 7
55066: PUSH
55067: LD_INT 0
55069: ST_TO_ADDR
// for k in b [ j ] do
55070: LD_ADDR_VAR 0 8
55074: PUSH
55075: LD_VAR 0 6
55079: PUSH
55080: LD_VAR 0 3
55084: ARRAY
55085: PUSH
55086: FOR_IN
55087: IFFALSE 55114
// if IsNotFull ( k ) then
55089: LD_VAR 0 8
55093: PPUSH
55094: CALL 15814 0 1
55098: IFFALSE 55112
// begin e := k ;
55100: LD_ADDR_VAR 0 7
55104: PUSH
55105: LD_VAR 0 8
55109: ST_TO_ADDR
// break ;
55110: GO 55114
// end ;
55112: GO 55086
55114: POP
55115: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55116: LD_VAR 0 7
55120: PUSH
55121: LD_VAR 0 5
55125: PPUSH
55126: LD_VAR 0 7
55130: PPUSH
55131: CALL 48234 0 2
55135: NOT
55136: AND
55137: IFFALSE 55196
// begin if IsInUnit ( p ) then
55139: LD_VAR 0 5
55143: PPUSH
55144: CALL_OW 310
55148: IFFALSE 55159
// ComExitBuilding ( p ) ;
55150: LD_VAR 0 5
55154: PPUSH
55155: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55159: LD_VAR 0 5
55163: PPUSH
55164: LD_VAR 0 7
55168: PPUSH
55169: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
55173: LD_VAR 0 5
55177: PPUSH
55178: LD_VAR 0 3
55182: PPUSH
55183: CALL_OW 183
// AddComExitBuilding ( p ) ;
55187: LD_VAR 0 5
55191: PPUSH
55192: CALL_OW 182
// end ; end ;
55196: GO 55044
55198: POP
55199: POP
// end ;
55200: GO 55010
55202: POP
55203: POP
// end ;
55204: GO 54765
55206: POP
55207: POP
// end ;
55208: LD_VAR 0 1
55212: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
55213: LD_INT 0
55215: PPUSH
55216: PPUSH
55217: PPUSH
55218: PPUSH
55219: PPUSH
55220: PPUSH
55221: PPUSH
55222: PPUSH
55223: PPUSH
55224: PPUSH
55225: PPUSH
55226: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55227: LD_VAR 0 1
55231: NOT
55232: PUSH
55233: LD_EXP 66
55237: PUSH
55238: LD_VAR 0 1
55242: ARRAY
55243: NOT
55244: OR
55245: PUSH
55246: LD_EXP 66
55250: PUSH
55251: LD_VAR 0 1
55255: ARRAY
55256: PPUSH
55257: LD_INT 2
55259: PUSH
55260: LD_INT 30
55262: PUSH
55263: LD_INT 0
55265: PUSH
55266: EMPTY
55267: LIST
55268: LIST
55269: PUSH
55270: LD_INT 30
55272: PUSH
55273: LD_INT 1
55275: PUSH
55276: EMPTY
55277: LIST
55278: LIST
55279: PUSH
55280: EMPTY
55281: LIST
55282: LIST
55283: LIST
55284: PPUSH
55285: CALL_OW 72
55289: NOT
55290: OR
55291: IFFALSE 55295
// exit ;
55293: GO 58798
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55295: LD_ADDR_VAR 0 4
55299: PUSH
55300: LD_EXP 66
55304: PUSH
55305: LD_VAR 0 1
55309: ARRAY
55310: PPUSH
55311: LD_INT 2
55313: PUSH
55314: LD_INT 25
55316: PUSH
55317: LD_INT 1
55319: PUSH
55320: EMPTY
55321: LIST
55322: LIST
55323: PUSH
55324: LD_INT 25
55326: PUSH
55327: LD_INT 2
55329: PUSH
55330: EMPTY
55331: LIST
55332: LIST
55333: PUSH
55334: LD_INT 25
55336: PUSH
55337: LD_INT 3
55339: PUSH
55340: EMPTY
55341: LIST
55342: LIST
55343: PUSH
55344: LD_INT 25
55346: PUSH
55347: LD_INT 4
55349: PUSH
55350: EMPTY
55351: LIST
55352: LIST
55353: PUSH
55354: LD_INT 25
55356: PUSH
55357: LD_INT 5
55359: PUSH
55360: EMPTY
55361: LIST
55362: LIST
55363: PUSH
55364: LD_INT 25
55366: PUSH
55367: LD_INT 8
55369: PUSH
55370: EMPTY
55371: LIST
55372: LIST
55373: PUSH
55374: LD_INT 25
55376: PUSH
55377: LD_INT 9
55379: PUSH
55380: EMPTY
55381: LIST
55382: LIST
55383: PUSH
55384: EMPTY
55385: LIST
55386: LIST
55387: LIST
55388: LIST
55389: LIST
55390: LIST
55391: LIST
55392: LIST
55393: PPUSH
55394: CALL_OW 72
55398: ST_TO_ADDR
// if not tmp then
55399: LD_VAR 0 4
55403: NOT
55404: IFFALSE 55408
// exit ;
55406: GO 58798
// for i in tmp do
55408: LD_ADDR_VAR 0 3
55412: PUSH
55413: LD_VAR 0 4
55417: PUSH
55418: FOR_IN
55419: IFFALSE 55450
// if GetTag ( i ) then
55421: LD_VAR 0 3
55425: PPUSH
55426: CALL_OW 110
55430: IFFALSE 55448
// tmp := tmp diff i ;
55432: LD_ADDR_VAR 0 4
55436: PUSH
55437: LD_VAR 0 4
55441: PUSH
55442: LD_VAR 0 3
55446: DIFF
55447: ST_TO_ADDR
55448: GO 55418
55450: POP
55451: POP
// if not tmp then
55452: LD_VAR 0 4
55456: NOT
55457: IFFALSE 55461
// exit ;
55459: GO 58798
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55461: LD_ADDR_VAR 0 5
55465: PUSH
55466: LD_EXP 66
55470: PUSH
55471: LD_VAR 0 1
55475: ARRAY
55476: PPUSH
55477: LD_INT 2
55479: PUSH
55480: LD_INT 25
55482: PUSH
55483: LD_INT 1
55485: PUSH
55486: EMPTY
55487: LIST
55488: LIST
55489: PUSH
55490: LD_INT 25
55492: PUSH
55493: LD_INT 5
55495: PUSH
55496: EMPTY
55497: LIST
55498: LIST
55499: PUSH
55500: LD_INT 25
55502: PUSH
55503: LD_INT 8
55505: PUSH
55506: EMPTY
55507: LIST
55508: LIST
55509: PUSH
55510: LD_INT 25
55512: PUSH
55513: LD_INT 9
55515: PUSH
55516: EMPTY
55517: LIST
55518: LIST
55519: PUSH
55520: EMPTY
55521: LIST
55522: LIST
55523: LIST
55524: LIST
55525: LIST
55526: PPUSH
55527: CALL_OW 72
55531: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
55532: LD_ADDR_VAR 0 6
55536: PUSH
55537: LD_EXP 66
55541: PUSH
55542: LD_VAR 0 1
55546: ARRAY
55547: PPUSH
55548: LD_INT 25
55550: PUSH
55551: LD_INT 2
55553: PUSH
55554: EMPTY
55555: LIST
55556: LIST
55557: PPUSH
55558: CALL_OW 72
55562: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
55563: LD_ADDR_VAR 0 7
55567: PUSH
55568: LD_EXP 66
55572: PUSH
55573: LD_VAR 0 1
55577: ARRAY
55578: PPUSH
55579: LD_INT 25
55581: PUSH
55582: LD_INT 3
55584: PUSH
55585: EMPTY
55586: LIST
55587: LIST
55588: PPUSH
55589: CALL_OW 72
55593: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
55594: LD_ADDR_VAR 0 8
55598: PUSH
55599: LD_EXP 66
55603: PUSH
55604: LD_VAR 0 1
55608: ARRAY
55609: PPUSH
55610: LD_INT 25
55612: PUSH
55613: LD_INT 4
55615: PUSH
55616: EMPTY
55617: LIST
55618: LIST
55619: PUSH
55620: LD_INT 24
55622: PUSH
55623: LD_INT 251
55625: PUSH
55626: EMPTY
55627: LIST
55628: LIST
55629: PUSH
55630: EMPTY
55631: LIST
55632: LIST
55633: PPUSH
55634: CALL_OW 72
55638: ST_TO_ADDR
// if mc_scan [ base ] then
55639: LD_EXP 89
55643: PUSH
55644: LD_VAR 0 1
55648: ARRAY
55649: IFFALSE 56110
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
55651: LD_ADDR_EXP 108
55655: PUSH
55656: LD_EXP 108
55660: PPUSH
55661: LD_VAR 0 1
55665: PPUSH
55666: LD_INT 4
55668: PPUSH
55669: CALL_OW 1
55673: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55674: LD_ADDR_VAR 0 12
55678: PUSH
55679: LD_EXP 66
55683: PUSH
55684: LD_VAR 0 1
55688: ARRAY
55689: PPUSH
55690: LD_INT 2
55692: PUSH
55693: LD_INT 30
55695: PUSH
55696: LD_INT 4
55698: PUSH
55699: EMPTY
55700: LIST
55701: LIST
55702: PUSH
55703: LD_INT 30
55705: PUSH
55706: LD_INT 5
55708: PUSH
55709: EMPTY
55710: LIST
55711: LIST
55712: PUSH
55713: EMPTY
55714: LIST
55715: LIST
55716: LIST
55717: PPUSH
55718: CALL_OW 72
55722: ST_TO_ADDR
// if not b then
55723: LD_VAR 0 12
55727: NOT
55728: IFFALSE 55732
// exit ;
55730: GO 58798
// p := [ ] ;
55732: LD_ADDR_VAR 0 11
55736: PUSH
55737: EMPTY
55738: ST_TO_ADDR
// if sci >= 2 then
55739: LD_VAR 0 8
55743: PUSH
55744: LD_INT 2
55746: GREATEREQUAL
55747: IFFALSE 55778
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
55749: LD_ADDR_VAR 0 8
55753: PUSH
55754: LD_VAR 0 8
55758: PUSH
55759: LD_INT 1
55761: ARRAY
55762: PUSH
55763: LD_VAR 0 8
55767: PUSH
55768: LD_INT 2
55770: ARRAY
55771: PUSH
55772: EMPTY
55773: LIST
55774: LIST
55775: ST_TO_ADDR
55776: GO 55839
// if sci = 1 then
55778: LD_VAR 0 8
55782: PUSH
55783: LD_INT 1
55785: EQUAL
55786: IFFALSE 55807
// sci := [ sci [ 1 ] ] else
55788: LD_ADDR_VAR 0 8
55792: PUSH
55793: LD_VAR 0 8
55797: PUSH
55798: LD_INT 1
55800: ARRAY
55801: PUSH
55802: EMPTY
55803: LIST
55804: ST_TO_ADDR
55805: GO 55839
// if sci = 0 then
55807: LD_VAR 0 8
55811: PUSH
55812: LD_INT 0
55814: EQUAL
55815: IFFALSE 55839
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
55817: LD_ADDR_VAR 0 11
55821: PUSH
55822: LD_VAR 0 4
55826: PPUSH
55827: LD_INT 4
55829: PPUSH
55830: CALL 48097 0 2
55834: PUSH
55835: LD_INT 1
55837: ARRAY
55838: ST_TO_ADDR
// if eng > 4 then
55839: LD_VAR 0 6
55843: PUSH
55844: LD_INT 4
55846: GREATER
55847: IFFALSE 55893
// for i = eng downto 4 do
55849: LD_ADDR_VAR 0 3
55853: PUSH
55854: DOUBLE
55855: LD_VAR 0 6
55859: INC
55860: ST_TO_ADDR
55861: LD_INT 4
55863: PUSH
55864: FOR_DOWNTO
55865: IFFALSE 55891
// eng := eng diff eng [ i ] ;
55867: LD_ADDR_VAR 0 6
55871: PUSH
55872: LD_VAR 0 6
55876: PUSH
55877: LD_VAR 0 6
55881: PUSH
55882: LD_VAR 0 3
55886: ARRAY
55887: DIFF
55888: ST_TO_ADDR
55889: GO 55864
55891: POP
55892: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
55893: LD_ADDR_VAR 0 4
55897: PUSH
55898: LD_VAR 0 4
55902: PUSH
55903: LD_VAR 0 5
55907: PUSH
55908: LD_VAR 0 6
55912: UNION
55913: PUSH
55914: LD_VAR 0 7
55918: UNION
55919: PUSH
55920: LD_VAR 0 8
55924: UNION
55925: DIFF
55926: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
55927: LD_ADDR_VAR 0 13
55931: PUSH
55932: LD_EXP 66
55936: PUSH
55937: LD_VAR 0 1
55941: ARRAY
55942: PPUSH
55943: LD_INT 2
55945: PUSH
55946: LD_INT 30
55948: PUSH
55949: LD_INT 32
55951: PUSH
55952: EMPTY
55953: LIST
55954: LIST
55955: PUSH
55956: LD_INT 30
55958: PUSH
55959: LD_INT 31
55961: PUSH
55962: EMPTY
55963: LIST
55964: LIST
55965: PUSH
55966: EMPTY
55967: LIST
55968: LIST
55969: LIST
55970: PPUSH
55971: CALL_OW 72
55975: PUSH
55976: LD_EXP 66
55980: PUSH
55981: LD_VAR 0 1
55985: ARRAY
55986: PPUSH
55987: LD_INT 2
55989: PUSH
55990: LD_INT 30
55992: PUSH
55993: LD_INT 4
55995: PUSH
55996: EMPTY
55997: LIST
55998: LIST
55999: PUSH
56000: LD_INT 30
56002: PUSH
56003: LD_INT 5
56005: PUSH
56006: EMPTY
56007: LIST
56008: LIST
56009: PUSH
56010: EMPTY
56011: LIST
56012: LIST
56013: LIST
56014: PPUSH
56015: CALL_OW 72
56019: PUSH
56020: LD_INT 6
56022: MUL
56023: PLUS
56024: ST_TO_ADDR
// if bcount < tmp then
56025: LD_VAR 0 13
56029: PUSH
56030: LD_VAR 0 4
56034: LESS
56035: IFFALSE 56081
// for i = tmp downto bcount do
56037: LD_ADDR_VAR 0 3
56041: PUSH
56042: DOUBLE
56043: LD_VAR 0 4
56047: INC
56048: ST_TO_ADDR
56049: LD_VAR 0 13
56053: PUSH
56054: FOR_DOWNTO
56055: IFFALSE 56079
// tmp := Delete ( tmp , tmp ) ;
56057: LD_ADDR_VAR 0 4
56061: PUSH
56062: LD_VAR 0 4
56066: PPUSH
56067: LD_VAR 0 4
56071: PPUSH
56072: CALL_OW 3
56076: ST_TO_ADDR
56077: GO 56054
56079: POP
56080: POP
// result := [ tmp , 0 , 0 , p ] ;
56081: LD_ADDR_VAR 0 2
56085: PUSH
56086: LD_VAR 0 4
56090: PUSH
56091: LD_INT 0
56093: PUSH
56094: LD_INT 0
56096: PUSH
56097: LD_VAR 0 11
56101: PUSH
56102: EMPTY
56103: LIST
56104: LIST
56105: LIST
56106: LIST
56107: ST_TO_ADDR
// exit ;
56108: GO 58798
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56110: LD_EXP 66
56114: PUSH
56115: LD_VAR 0 1
56119: ARRAY
56120: PPUSH
56121: LD_INT 2
56123: PUSH
56124: LD_INT 30
56126: PUSH
56127: LD_INT 6
56129: PUSH
56130: EMPTY
56131: LIST
56132: LIST
56133: PUSH
56134: LD_INT 30
56136: PUSH
56137: LD_INT 7
56139: PUSH
56140: EMPTY
56141: LIST
56142: LIST
56143: PUSH
56144: LD_INT 30
56146: PUSH
56147: LD_INT 8
56149: PUSH
56150: EMPTY
56151: LIST
56152: LIST
56153: PUSH
56154: EMPTY
56155: LIST
56156: LIST
56157: LIST
56158: LIST
56159: PPUSH
56160: CALL_OW 72
56164: NOT
56165: PUSH
56166: LD_EXP 66
56170: PUSH
56171: LD_VAR 0 1
56175: ARRAY
56176: PPUSH
56177: LD_INT 30
56179: PUSH
56180: LD_INT 3
56182: PUSH
56183: EMPTY
56184: LIST
56185: LIST
56186: PPUSH
56187: CALL_OW 72
56191: NOT
56192: AND
56193: IFFALSE 56265
// begin if eng = tmp then
56195: LD_VAR 0 6
56199: PUSH
56200: LD_VAR 0 4
56204: EQUAL
56205: IFFALSE 56209
// exit ;
56207: GO 58798
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
56209: LD_ADDR_EXP 108
56213: PUSH
56214: LD_EXP 108
56218: PPUSH
56219: LD_VAR 0 1
56223: PPUSH
56224: LD_INT 1
56226: PPUSH
56227: CALL_OW 1
56231: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
56232: LD_ADDR_VAR 0 2
56236: PUSH
56237: LD_INT 0
56239: PUSH
56240: LD_VAR 0 4
56244: PUSH
56245: LD_VAR 0 6
56249: DIFF
56250: PUSH
56251: LD_INT 0
56253: PUSH
56254: LD_INT 0
56256: PUSH
56257: EMPTY
56258: LIST
56259: LIST
56260: LIST
56261: LIST
56262: ST_TO_ADDR
// exit ;
56263: GO 58798
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56265: LD_EXP 93
56269: PUSH
56270: LD_EXP 92
56274: PUSH
56275: LD_VAR 0 1
56279: ARRAY
56280: ARRAY
56281: PUSH
56282: LD_EXP 66
56286: PUSH
56287: LD_VAR 0 1
56291: ARRAY
56292: PPUSH
56293: LD_INT 2
56295: PUSH
56296: LD_INT 30
56298: PUSH
56299: LD_INT 6
56301: PUSH
56302: EMPTY
56303: LIST
56304: LIST
56305: PUSH
56306: LD_INT 30
56308: PUSH
56309: LD_INT 7
56311: PUSH
56312: EMPTY
56313: LIST
56314: LIST
56315: PUSH
56316: LD_INT 30
56318: PUSH
56319: LD_INT 8
56321: PUSH
56322: EMPTY
56323: LIST
56324: LIST
56325: PUSH
56326: EMPTY
56327: LIST
56328: LIST
56329: LIST
56330: LIST
56331: PPUSH
56332: CALL_OW 72
56336: AND
56337: PUSH
56338: LD_EXP 66
56342: PUSH
56343: LD_VAR 0 1
56347: ARRAY
56348: PPUSH
56349: LD_INT 30
56351: PUSH
56352: LD_INT 3
56354: PUSH
56355: EMPTY
56356: LIST
56357: LIST
56358: PPUSH
56359: CALL_OW 72
56363: NOT
56364: AND
56365: IFFALSE 56579
// begin if sci >= 6 then
56367: LD_VAR 0 8
56371: PUSH
56372: LD_INT 6
56374: GREATEREQUAL
56375: IFFALSE 56379
// exit ;
56377: GO 58798
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
56379: LD_ADDR_EXP 108
56383: PUSH
56384: LD_EXP 108
56388: PPUSH
56389: LD_VAR 0 1
56393: PPUSH
56394: LD_INT 2
56396: PPUSH
56397: CALL_OW 1
56401: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
56402: LD_ADDR_VAR 0 9
56406: PUSH
56407: LD_VAR 0 4
56411: PUSH
56412: LD_VAR 0 8
56416: DIFF
56417: PPUSH
56418: LD_INT 4
56420: PPUSH
56421: CALL 48097 0 2
56425: ST_TO_ADDR
// p := [ ] ;
56426: LD_ADDR_VAR 0 11
56430: PUSH
56431: EMPTY
56432: ST_TO_ADDR
// if sci < 6 and sort > 6 then
56433: LD_VAR 0 8
56437: PUSH
56438: LD_INT 6
56440: LESS
56441: PUSH
56442: LD_VAR 0 9
56446: PUSH
56447: LD_INT 6
56449: GREATER
56450: AND
56451: IFFALSE 56532
// begin for i = 1 to 6 - sci do
56453: LD_ADDR_VAR 0 3
56457: PUSH
56458: DOUBLE
56459: LD_INT 1
56461: DEC
56462: ST_TO_ADDR
56463: LD_INT 6
56465: PUSH
56466: LD_VAR 0 8
56470: MINUS
56471: PUSH
56472: FOR_TO
56473: IFFALSE 56528
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
56475: LD_ADDR_VAR 0 11
56479: PUSH
56480: LD_VAR 0 11
56484: PPUSH
56485: LD_VAR 0 11
56489: PUSH
56490: LD_INT 1
56492: PLUS
56493: PPUSH
56494: LD_VAR 0 9
56498: PUSH
56499: LD_INT 1
56501: ARRAY
56502: PPUSH
56503: CALL_OW 2
56507: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
56508: LD_ADDR_VAR 0 9
56512: PUSH
56513: LD_VAR 0 9
56517: PPUSH
56518: LD_INT 1
56520: PPUSH
56521: CALL_OW 3
56525: ST_TO_ADDR
// end ;
56526: GO 56472
56528: POP
56529: POP
// end else
56530: GO 56552
// if sort then
56532: LD_VAR 0 9
56536: IFFALSE 56552
// p := sort [ 1 ] ;
56538: LD_ADDR_VAR 0 11
56542: PUSH
56543: LD_VAR 0 9
56547: PUSH
56548: LD_INT 1
56550: ARRAY
56551: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
56552: LD_ADDR_VAR 0 2
56556: PUSH
56557: LD_INT 0
56559: PUSH
56560: LD_INT 0
56562: PUSH
56563: LD_INT 0
56565: PUSH
56566: LD_VAR 0 11
56570: PUSH
56571: EMPTY
56572: LIST
56573: LIST
56574: LIST
56575: LIST
56576: ST_TO_ADDR
// exit ;
56577: GO 58798
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56579: LD_EXP 93
56583: PUSH
56584: LD_EXP 92
56588: PUSH
56589: LD_VAR 0 1
56593: ARRAY
56594: ARRAY
56595: PUSH
56596: LD_EXP 66
56600: PUSH
56601: LD_VAR 0 1
56605: ARRAY
56606: PPUSH
56607: LD_INT 2
56609: PUSH
56610: LD_INT 30
56612: PUSH
56613: LD_INT 6
56615: PUSH
56616: EMPTY
56617: LIST
56618: LIST
56619: PUSH
56620: LD_INT 30
56622: PUSH
56623: LD_INT 7
56625: PUSH
56626: EMPTY
56627: LIST
56628: LIST
56629: PUSH
56630: LD_INT 30
56632: PUSH
56633: LD_INT 8
56635: PUSH
56636: EMPTY
56637: LIST
56638: LIST
56639: PUSH
56640: EMPTY
56641: LIST
56642: LIST
56643: LIST
56644: LIST
56645: PPUSH
56646: CALL_OW 72
56650: AND
56651: PUSH
56652: LD_EXP 66
56656: PUSH
56657: LD_VAR 0 1
56661: ARRAY
56662: PPUSH
56663: LD_INT 30
56665: PUSH
56666: LD_INT 3
56668: PUSH
56669: EMPTY
56670: LIST
56671: LIST
56672: PPUSH
56673: CALL_OW 72
56677: AND
56678: IFFALSE 57412
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
56680: LD_ADDR_EXP 108
56684: PUSH
56685: LD_EXP 108
56689: PPUSH
56690: LD_VAR 0 1
56694: PPUSH
56695: LD_INT 3
56697: PPUSH
56698: CALL_OW 1
56702: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56703: LD_ADDR_VAR 0 2
56707: PUSH
56708: LD_INT 0
56710: PUSH
56711: LD_INT 0
56713: PUSH
56714: LD_INT 0
56716: PUSH
56717: LD_INT 0
56719: PUSH
56720: EMPTY
56721: LIST
56722: LIST
56723: LIST
56724: LIST
56725: ST_TO_ADDR
// if not eng then
56726: LD_VAR 0 6
56730: NOT
56731: IFFALSE 56794
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
56733: LD_ADDR_VAR 0 11
56737: PUSH
56738: LD_VAR 0 4
56742: PPUSH
56743: LD_INT 2
56745: PPUSH
56746: CALL 48097 0 2
56750: PUSH
56751: LD_INT 1
56753: ARRAY
56754: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
56755: LD_ADDR_VAR 0 2
56759: PUSH
56760: LD_VAR 0 2
56764: PPUSH
56765: LD_INT 2
56767: PPUSH
56768: LD_VAR 0 11
56772: PPUSH
56773: CALL_OW 1
56777: ST_TO_ADDR
// tmp := tmp diff p ;
56778: LD_ADDR_VAR 0 4
56782: PUSH
56783: LD_VAR 0 4
56787: PUSH
56788: LD_VAR 0 11
56792: DIFF
56793: ST_TO_ADDR
// end ; if tmp and sci < 6 then
56794: LD_VAR 0 4
56798: PUSH
56799: LD_VAR 0 8
56803: PUSH
56804: LD_INT 6
56806: LESS
56807: AND
56808: IFFALSE 56996
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
56810: LD_ADDR_VAR 0 9
56814: PUSH
56815: LD_VAR 0 4
56819: PUSH
56820: LD_VAR 0 8
56824: PUSH
56825: LD_VAR 0 7
56829: UNION
56830: DIFF
56831: PPUSH
56832: LD_INT 4
56834: PPUSH
56835: CALL 48097 0 2
56839: ST_TO_ADDR
// p := [ ] ;
56840: LD_ADDR_VAR 0 11
56844: PUSH
56845: EMPTY
56846: ST_TO_ADDR
// if sort then
56847: LD_VAR 0 9
56851: IFFALSE 56967
// for i = 1 to 6 - sci do
56853: LD_ADDR_VAR 0 3
56857: PUSH
56858: DOUBLE
56859: LD_INT 1
56861: DEC
56862: ST_TO_ADDR
56863: LD_INT 6
56865: PUSH
56866: LD_VAR 0 8
56870: MINUS
56871: PUSH
56872: FOR_TO
56873: IFFALSE 56965
// begin if i = sort then
56875: LD_VAR 0 3
56879: PUSH
56880: LD_VAR 0 9
56884: EQUAL
56885: IFFALSE 56889
// break ;
56887: GO 56965
// if GetClass ( i ) = 4 then
56889: LD_VAR 0 3
56893: PPUSH
56894: CALL_OW 257
56898: PUSH
56899: LD_INT 4
56901: EQUAL
56902: IFFALSE 56906
// continue ;
56904: GO 56872
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56906: LD_ADDR_VAR 0 11
56910: PUSH
56911: LD_VAR 0 11
56915: PPUSH
56916: LD_VAR 0 11
56920: PUSH
56921: LD_INT 1
56923: PLUS
56924: PPUSH
56925: LD_VAR 0 9
56929: PUSH
56930: LD_VAR 0 3
56934: ARRAY
56935: PPUSH
56936: CALL_OW 2
56940: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56941: LD_ADDR_VAR 0 4
56945: PUSH
56946: LD_VAR 0 4
56950: PUSH
56951: LD_VAR 0 9
56955: PUSH
56956: LD_VAR 0 3
56960: ARRAY
56961: DIFF
56962: ST_TO_ADDR
// end ;
56963: GO 56872
56965: POP
56966: POP
// if p then
56967: LD_VAR 0 11
56971: IFFALSE 56996
// result := Replace ( result , 4 , p ) ;
56973: LD_ADDR_VAR 0 2
56977: PUSH
56978: LD_VAR 0 2
56982: PPUSH
56983: LD_INT 4
56985: PPUSH
56986: LD_VAR 0 11
56990: PPUSH
56991: CALL_OW 1
56995: ST_TO_ADDR
// end ; if tmp and mech < 6 then
56996: LD_VAR 0 4
57000: PUSH
57001: LD_VAR 0 7
57005: PUSH
57006: LD_INT 6
57008: LESS
57009: AND
57010: IFFALSE 57198
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57012: LD_ADDR_VAR 0 9
57016: PUSH
57017: LD_VAR 0 4
57021: PUSH
57022: LD_VAR 0 8
57026: PUSH
57027: LD_VAR 0 7
57031: UNION
57032: DIFF
57033: PPUSH
57034: LD_INT 3
57036: PPUSH
57037: CALL 48097 0 2
57041: ST_TO_ADDR
// p := [ ] ;
57042: LD_ADDR_VAR 0 11
57046: PUSH
57047: EMPTY
57048: ST_TO_ADDR
// if sort then
57049: LD_VAR 0 9
57053: IFFALSE 57169
// for i = 1 to 6 - mech do
57055: LD_ADDR_VAR 0 3
57059: PUSH
57060: DOUBLE
57061: LD_INT 1
57063: DEC
57064: ST_TO_ADDR
57065: LD_INT 6
57067: PUSH
57068: LD_VAR 0 7
57072: MINUS
57073: PUSH
57074: FOR_TO
57075: IFFALSE 57167
// begin if i = sort then
57077: LD_VAR 0 3
57081: PUSH
57082: LD_VAR 0 9
57086: EQUAL
57087: IFFALSE 57091
// break ;
57089: GO 57167
// if GetClass ( i ) = 3 then
57091: LD_VAR 0 3
57095: PPUSH
57096: CALL_OW 257
57100: PUSH
57101: LD_INT 3
57103: EQUAL
57104: IFFALSE 57108
// continue ;
57106: GO 57074
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57108: LD_ADDR_VAR 0 11
57112: PUSH
57113: LD_VAR 0 11
57117: PPUSH
57118: LD_VAR 0 11
57122: PUSH
57123: LD_INT 1
57125: PLUS
57126: PPUSH
57127: LD_VAR 0 9
57131: PUSH
57132: LD_VAR 0 3
57136: ARRAY
57137: PPUSH
57138: CALL_OW 2
57142: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57143: LD_ADDR_VAR 0 4
57147: PUSH
57148: LD_VAR 0 4
57152: PUSH
57153: LD_VAR 0 9
57157: PUSH
57158: LD_VAR 0 3
57162: ARRAY
57163: DIFF
57164: ST_TO_ADDR
// end ;
57165: GO 57074
57167: POP
57168: POP
// if p then
57169: LD_VAR 0 11
57173: IFFALSE 57198
// result := Replace ( result , 3 , p ) ;
57175: LD_ADDR_VAR 0 2
57179: PUSH
57180: LD_VAR 0 2
57184: PPUSH
57185: LD_INT 3
57187: PPUSH
57188: LD_VAR 0 11
57192: PPUSH
57193: CALL_OW 1
57197: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57198: LD_VAR 0 4
57202: PUSH
57203: LD_INT 6
57205: GREATER
57206: PUSH
57207: LD_VAR 0 6
57211: PUSH
57212: LD_INT 6
57214: LESS
57215: AND
57216: IFFALSE 57410
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57218: LD_ADDR_VAR 0 9
57222: PUSH
57223: LD_VAR 0 4
57227: PUSH
57228: LD_VAR 0 8
57232: PUSH
57233: LD_VAR 0 7
57237: UNION
57238: PUSH
57239: LD_VAR 0 6
57243: UNION
57244: DIFF
57245: PPUSH
57246: LD_INT 2
57248: PPUSH
57249: CALL 48097 0 2
57253: ST_TO_ADDR
// p := [ ] ;
57254: LD_ADDR_VAR 0 11
57258: PUSH
57259: EMPTY
57260: ST_TO_ADDR
// if sort then
57261: LD_VAR 0 9
57265: IFFALSE 57381
// for i = 1 to 6 - eng do
57267: LD_ADDR_VAR 0 3
57271: PUSH
57272: DOUBLE
57273: LD_INT 1
57275: DEC
57276: ST_TO_ADDR
57277: LD_INT 6
57279: PUSH
57280: LD_VAR 0 6
57284: MINUS
57285: PUSH
57286: FOR_TO
57287: IFFALSE 57379
// begin if i = sort then
57289: LD_VAR 0 3
57293: PUSH
57294: LD_VAR 0 9
57298: EQUAL
57299: IFFALSE 57303
// break ;
57301: GO 57379
// if GetClass ( i ) = 2 then
57303: LD_VAR 0 3
57307: PPUSH
57308: CALL_OW 257
57312: PUSH
57313: LD_INT 2
57315: EQUAL
57316: IFFALSE 57320
// continue ;
57318: GO 57286
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57320: LD_ADDR_VAR 0 11
57324: PUSH
57325: LD_VAR 0 11
57329: PPUSH
57330: LD_VAR 0 11
57334: PUSH
57335: LD_INT 1
57337: PLUS
57338: PPUSH
57339: LD_VAR 0 9
57343: PUSH
57344: LD_VAR 0 3
57348: ARRAY
57349: PPUSH
57350: CALL_OW 2
57354: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57355: LD_ADDR_VAR 0 4
57359: PUSH
57360: LD_VAR 0 4
57364: PUSH
57365: LD_VAR 0 9
57369: PUSH
57370: LD_VAR 0 3
57374: ARRAY
57375: DIFF
57376: ST_TO_ADDR
// end ;
57377: GO 57286
57379: POP
57380: POP
// if p then
57381: LD_VAR 0 11
57385: IFFALSE 57410
// result := Replace ( result , 2 , p ) ;
57387: LD_ADDR_VAR 0 2
57391: PUSH
57392: LD_VAR 0 2
57396: PPUSH
57397: LD_INT 2
57399: PPUSH
57400: LD_VAR 0 11
57404: PPUSH
57405: CALL_OW 1
57409: ST_TO_ADDR
// end ; exit ;
57410: GO 58798
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
57412: LD_EXP 93
57416: PUSH
57417: LD_EXP 92
57421: PUSH
57422: LD_VAR 0 1
57426: ARRAY
57427: ARRAY
57428: NOT
57429: PUSH
57430: LD_EXP 66
57434: PUSH
57435: LD_VAR 0 1
57439: ARRAY
57440: PPUSH
57441: LD_INT 30
57443: PUSH
57444: LD_INT 3
57446: PUSH
57447: EMPTY
57448: LIST
57449: LIST
57450: PPUSH
57451: CALL_OW 72
57455: AND
57456: PUSH
57457: LD_EXP 71
57461: PUSH
57462: LD_VAR 0 1
57466: ARRAY
57467: AND
57468: IFFALSE 58076
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
57470: LD_ADDR_EXP 108
57474: PUSH
57475: LD_EXP 108
57479: PPUSH
57480: LD_VAR 0 1
57484: PPUSH
57485: LD_INT 5
57487: PPUSH
57488: CALL_OW 1
57492: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57493: LD_ADDR_VAR 0 2
57497: PUSH
57498: LD_INT 0
57500: PUSH
57501: LD_INT 0
57503: PUSH
57504: LD_INT 0
57506: PUSH
57507: LD_INT 0
57509: PUSH
57510: EMPTY
57511: LIST
57512: LIST
57513: LIST
57514: LIST
57515: ST_TO_ADDR
// if sci > 1 then
57516: LD_VAR 0 8
57520: PUSH
57521: LD_INT 1
57523: GREATER
57524: IFFALSE 57552
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
57526: LD_ADDR_VAR 0 4
57530: PUSH
57531: LD_VAR 0 4
57535: PUSH
57536: LD_VAR 0 8
57540: PUSH
57541: LD_VAR 0 8
57545: PUSH
57546: LD_INT 1
57548: ARRAY
57549: DIFF
57550: DIFF
57551: ST_TO_ADDR
// if tmp and not sci then
57552: LD_VAR 0 4
57556: PUSH
57557: LD_VAR 0 8
57561: NOT
57562: AND
57563: IFFALSE 57632
// begin sort := SortBySkill ( tmp , 4 ) ;
57565: LD_ADDR_VAR 0 9
57569: PUSH
57570: LD_VAR 0 4
57574: PPUSH
57575: LD_INT 4
57577: PPUSH
57578: CALL 48097 0 2
57582: ST_TO_ADDR
// if sort then
57583: LD_VAR 0 9
57587: IFFALSE 57603
// p := sort [ 1 ] ;
57589: LD_ADDR_VAR 0 11
57593: PUSH
57594: LD_VAR 0 9
57598: PUSH
57599: LD_INT 1
57601: ARRAY
57602: ST_TO_ADDR
// if p then
57603: LD_VAR 0 11
57607: IFFALSE 57632
// result := Replace ( result , 4 , p ) ;
57609: LD_ADDR_VAR 0 2
57613: PUSH
57614: LD_VAR 0 2
57618: PPUSH
57619: LD_INT 4
57621: PPUSH
57622: LD_VAR 0 11
57626: PPUSH
57627: CALL_OW 1
57631: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57632: LD_ADDR_VAR 0 4
57636: PUSH
57637: LD_VAR 0 4
57641: PUSH
57642: LD_VAR 0 7
57646: DIFF
57647: ST_TO_ADDR
// if tmp and mech < 6 then
57648: LD_VAR 0 4
57652: PUSH
57653: LD_VAR 0 7
57657: PUSH
57658: LD_INT 6
57660: LESS
57661: AND
57662: IFFALSE 57850
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57664: LD_ADDR_VAR 0 9
57668: PUSH
57669: LD_VAR 0 4
57673: PUSH
57674: LD_VAR 0 8
57678: PUSH
57679: LD_VAR 0 7
57683: UNION
57684: DIFF
57685: PPUSH
57686: LD_INT 3
57688: PPUSH
57689: CALL 48097 0 2
57693: ST_TO_ADDR
// p := [ ] ;
57694: LD_ADDR_VAR 0 11
57698: PUSH
57699: EMPTY
57700: ST_TO_ADDR
// if sort then
57701: LD_VAR 0 9
57705: IFFALSE 57821
// for i = 1 to 6 - mech do
57707: LD_ADDR_VAR 0 3
57711: PUSH
57712: DOUBLE
57713: LD_INT 1
57715: DEC
57716: ST_TO_ADDR
57717: LD_INT 6
57719: PUSH
57720: LD_VAR 0 7
57724: MINUS
57725: PUSH
57726: FOR_TO
57727: IFFALSE 57819
// begin if i = sort then
57729: LD_VAR 0 3
57733: PUSH
57734: LD_VAR 0 9
57738: EQUAL
57739: IFFALSE 57743
// break ;
57741: GO 57819
// if GetClass ( i ) = 3 then
57743: LD_VAR 0 3
57747: PPUSH
57748: CALL_OW 257
57752: PUSH
57753: LD_INT 3
57755: EQUAL
57756: IFFALSE 57760
// continue ;
57758: GO 57726
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57760: LD_ADDR_VAR 0 11
57764: PUSH
57765: LD_VAR 0 11
57769: PPUSH
57770: LD_VAR 0 11
57774: PUSH
57775: LD_INT 1
57777: PLUS
57778: PPUSH
57779: LD_VAR 0 9
57783: PUSH
57784: LD_VAR 0 3
57788: ARRAY
57789: PPUSH
57790: CALL_OW 2
57794: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57795: LD_ADDR_VAR 0 4
57799: PUSH
57800: LD_VAR 0 4
57804: PUSH
57805: LD_VAR 0 9
57809: PUSH
57810: LD_VAR 0 3
57814: ARRAY
57815: DIFF
57816: ST_TO_ADDR
// end ;
57817: GO 57726
57819: POP
57820: POP
// if p then
57821: LD_VAR 0 11
57825: IFFALSE 57850
// result := Replace ( result , 3 , p ) ;
57827: LD_ADDR_VAR 0 2
57831: PUSH
57832: LD_VAR 0 2
57836: PPUSH
57837: LD_INT 3
57839: PPUSH
57840: LD_VAR 0 11
57844: PPUSH
57845: CALL_OW 1
57849: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
57850: LD_ADDR_VAR 0 4
57854: PUSH
57855: LD_VAR 0 4
57859: PUSH
57860: LD_VAR 0 6
57864: DIFF
57865: ST_TO_ADDR
// if tmp and eng < 6 then
57866: LD_VAR 0 4
57870: PUSH
57871: LD_VAR 0 6
57875: PUSH
57876: LD_INT 6
57878: LESS
57879: AND
57880: IFFALSE 58074
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57882: LD_ADDR_VAR 0 9
57886: PUSH
57887: LD_VAR 0 4
57891: PUSH
57892: LD_VAR 0 8
57896: PUSH
57897: LD_VAR 0 7
57901: UNION
57902: PUSH
57903: LD_VAR 0 6
57907: UNION
57908: DIFF
57909: PPUSH
57910: LD_INT 2
57912: PPUSH
57913: CALL 48097 0 2
57917: ST_TO_ADDR
// p := [ ] ;
57918: LD_ADDR_VAR 0 11
57922: PUSH
57923: EMPTY
57924: ST_TO_ADDR
// if sort then
57925: LD_VAR 0 9
57929: IFFALSE 58045
// for i = 1 to 6 - eng do
57931: LD_ADDR_VAR 0 3
57935: PUSH
57936: DOUBLE
57937: LD_INT 1
57939: DEC
57940: ST_TO_ADDR
57941: LD_INT 6
57943: PUSH
57944: LD_VAR 0 6
57948: MINUS
57949: PUSH
57950: FOR_TO
57951: IFFALSE 58043
// begin if i = sort then
57953: LD_VAR 0 3
57957: PUSH
57958: LD_VAR 0 9
57962: EQUAL
57963: IFFALSE 57967
// break ;
57965: GO 58043
// if GetClass ( i ) = 2 then
57967: LD_VAR 0 3
57971: PPUSH
57972: CALL_OW 257
57976: PUSH
57977: LD_INT 2
57979: EQUAL
57980: IFFALSE 57984
// continue ;
57982: GO 57950
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57984: LD_ADDR_VAR 0 11
57988: PUSH
57989: LD_VAR 0 11
57993: PPUSH
57994: LD_VAR 0 11
57998: PUSH
57999: LD_INT 1
58001: PLUS
58002: PPUSH
58003: LD_VAR 0 9
58007: PUSH
58008: LD_VAR 0 3
58012: ARRAY
58013: PPUSH
58014: CALL_OW 2
58018: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58019: LD_ADDR_VAR 0 4
58023: PUSH
58024: LD_VAR 0 4
58028: PUSH
58029: LD_VAR 0 9
58033: PUSH
58034: LD_VAR 0 3
58038: ARRAY
58039: DIFF
58040: ST_TO_ADDR
// end ;
58041: GO 57950
58043: POP
58044: POP
// if p then
58045: LD_VAR 0 11
58049: IFFALSE 58074
// result := Replace ( result , 2 , p ) ;
58051: LD_ADDR_VAR 0 2
58055: PUSH
58056: LD_VAR 0 2
58060: PPUSH
58061: LD_INT 2
58063: PPUSH
58064: LD_VAR 0 11
58068: PPUSH
58069: CALL_OW 1
58073: ST_TO_ADDR
// end ; exit ;
58074: GO 58798
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58076: LD_EXP 93
58080: PUSH
58081: LD_EXP 92
58085: PUSH
58086: LD_VAR 0 1
58090: ARRAY
58091: ARRAY
58092: NOT
58093: PUSH
58094: LD_EXP 66
58098: PUSH
58099: LD_VAR 0 1
58103: ARRAY
58104: PPUSH
58105: LD_INT 30
58107: PUSH
58108: LD_INT 3
58110: PUSH
58111: EMPTY
58112: LIST
58113: LIST
58114: PPUSH
58115: CALL_OW 72
58119: AND
58120: PUSH
58121: LD_EXP 71
58125: PUSH
58126: LD_VAR 0 1
58130: ARRAY
58131: NOT
58132: AND
58133: IFFALSE 58798
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58135: LD_ADDR_EXP 108
58139: PUSH
58140: LD_EXP 108
58144: PPUSH
58145: LD_VAR 0 1
58149: PPUSH
58150: LD_INT 6
58152: PPUSH
58153: CALL_OW 1
58157: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58158: LD_ADDR_VAR 0 2
58162: PUSH
58163: LD_INT 0
58165: PUSH
58166: LD_INT 0
58168: PUSH
58169: LD_INT 0
58171: PUSH
58172: LD_INT 0
58174: PUSH
58175: EMPTY
58176: LIST
58177: LIST
58178: LIST
58179: LIST
58180: ST_TO_ADDR
// if sci >= 1 then
58181: LD_VAR 0 8
58185: PUSH
58186: LD_INT 1
58188: GREATEREQUAL
58189: IFFALSE 58211
// tmp := tmp diff sci [ 1 ] ;
58191: LD_ADDR_VAR 0 4
58195: PUSH
58196: LD_VAR 0 4
58200: PUSH
58201: LD_VAR 0 8
58205: PUSH
58206: LD_INT 1
58208: ARRAY
58209: DIFF
58210: ST_TO_ADDR
// if tmp and not sci then
58211: LD_VAR 0 4
58215: PUSH
58216: LD_VAR 0 8
58220: NOT
58221: AND
58222: IFFALSE 58291
// begin sort := SortBySkill ( tmp , 4 ) ;
58224: LD_ADDR_VAR 0 9
58228: PUSH
58229: LD_VAR 0 4
58233: PPUSH
58234: LD_INT 4
58236: PPUSH
58237: CALL 48097 0 2
58241: ST_TO_ADDR
// if sort then
58242: LD_VAR 0 9
58246: IFFALSE 58262
// p := sort [ 1 ] ;
58248: LD_ADDR_VAR 0 11
58252: PUSH
58253: LD_VAR 0 9
58257: PUSH
58258: LD_INT 1
58260: ARRAY
58261: ST_TO_ADDR
// if p then
58262: LD_VAR 0 11
58266: IFFALSE 58291
// result := Replace ( result , 4 , p ) ;
58268: LD_ADDR_VAR 0 2
58272: PUSH
58273: LD_VAR 0 2
58277: PPUSH
58278: LD_INT 4
58280: PPUSH
58281: LD_VAR 0 11
58285: PPUSH
58286: CALL_OW 1
58290: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58291: LD_ADDR_VAR 0 4
58295: PUSH
58296: LD_VAR 0 4
58300: PUSH
58301: LD_VAR 0 7
58305: DIFF
58306: ST_TO_ADDR
// if tmp and mech < 6 then
58307: LD_VAR 0 4
58311: PUSH
58312: LD_VAR 0 7
58316: PUSH
58317: LD_INT 6
58319: LESS
58320: AND
58321: IFFALSE 58503
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
58323: LD_ADDR_VAR 0 9
58327: PUSH
58328: LD_VAR 0 4
58332: PUSH
58333: LD_VAR 0 7
58337: DIFF
58338: PPUSH
58339: LD_INT 3
58341: PPUSH
58342: CALL 48097 0 2
58346: ST_TO_ADDR
// p := [ ] ;
58347: LD_ADDR_VAR 0 11
58351: PUSH
58352: EMPTY
58353: ST_TO_ADDR
// if sort then
58354: LD_VAR 0 9
58358: IFFALSE 58474
// for i = 1 to 6 - mech do
58360: LD_ADDR_VAR 0 3
58364: PUSH
58365: DOUBLE
58366: LD_INT 1
58368: DEC
58369: ST_TO_ADDR
58370: LD_INT 6
58372: PUSH
58373: LD_VAR 0 7
58377: MINUS
58378: PUSH
58379: FOR_TO
58380: IFFALSE 58472
// begin if i = sort then
58382: LD_VAR 0 3
58386: PUSH
58387: LD_VAR 0 9
58391: EQUAL
58392: IFFALSE 58396
// break ;
58394: GO 58472
// if GetClass ( i ) = 3 then
58396: LD_VAR 0 3
58400: PPUSH
58401: CALL_OW 257
58405: PUSH
58406: LD_INT 3
58408: EQUAL
58409: IFFALSE 58413
// continue ;
58411: GO 58379
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58413: LD_ADDR_VAR 0 11
58417: PUSH
58418: LD_VAR 0 11
58422: PPUSH
58423: LD_VAR 0 11
58427: PUSH
58428: LD_INT 1
58430: PLUS
58431: PPUSH
58432: LD_VAR 0 9
58436: PUSH
58437: LD_VAR 0 3
58441: ARRAY
58442: PPUSH
58443: CALL_OW 2
58447: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58448: LD_ADDR_VAR 0 4
58452: PUSH
58453: LD_VAR 0 4
58457: PUSH
58458: LD_VAR 0 9
58462: PUSH
58463: LD_VAR 0 3
58467: ARRAY
58468: DIFF
58469: ST_TO_ADDR
// end ;
58470: GO 58379
58472: POP
58473: POP
// if p then
58474: LD_VAR 0 11
58478: IFFALSE 58503
// result := Replace ( result , 3 , p ) ;
58480: LD_ADDR_VAR 0 2
58484: PUSH
58485: LD_VAR 0 2
58489: PPUSH
58490: LD_INT 3
58492: PPUSH
58493: LD_VAR 0 11
58497: PPUSH
58498: CALL_OW 1
58502: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58503: LD_ADDR_VAR 0 4
58507: PUSH
58508: LD_VAR 0 4
58512: PUSH
58513: LD_VAR 0 6
58517: DIFF
58518: ST_TO_ADDR
// if tmp and eng < 4 then
58519: LD_VAR 0 4
58523: PUSH
58524: LD_VAR 0 6
58528: PUSH
58529: LD_INT 4
58531: LESS
58532: AND
58533: IFFALSE 58723
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
58535: LD_ADDR_VAR 0 9
58539: PUSH
58540: LD_VAR 0 4
58544: PUSH
58545: LD_VAR 0 7
58549: PUSH
58550: LD_VAR 0 6
58554: UNION
58555: DIFF
58556: PPUSH
58557: LD_INT 2
58559: PPUSH
58560: CALL 48097 0 2
58564: ST_TO_ADDR
// p := [ ] ;
58565: LD_ADDR_VAR 0 11
58569: PUSH
58570: EMPTY
58571: ST_TO_ADDR
// if sort then
58572: LD_VAR 0 9
58576: IFFALSE 58692
// for i = 1 to 4 - eng do
58578: LD_ADDR_VAR 0 3
58582: PUSH
58583: DOUBLE
58584: LD_INT 1
58586: DEC
58587: ST_TO_ADDR
58588: LD_INT 4
58590: PUSH
58591: LD_VAR 0 6
58595: MINUS
58596: PUSH
58597: FOR_TO
58598: IFFALSE 58690
// begin if i = sort then
58600: LD_VAR 0 3
58604: PUSH
58605: LD_VAR 0 9
58609: EQUAL
58610: IFFALSE 58614
// break ;
58612: GO 58690
// if GetClass ( i ) = 2 then
58614: LD_VAR 0 3
58618: PPUSH
58619: CALL_OW 257
58623: PUSH
58624: LD_INT 2
58626: EQUAL
58627: IFFALSE 58631
// continue ;
58629: GO 58597
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58631: LD_ADDR_VAR 0 11
58635: PUSH
58636: LD_VAR 0 11
58640: PPUSH
58641: LD_VAR 0 11
58645: PUSH
58646: LD_INT 1
58648: PLUS
58649: PPUSH
58650: LD_VAR 0 9
58654: PUSH
58655: LD_VAR 0 3
58659: ARRAY
58660: PPUSH
58661: CALL_OW 2
58665: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58666: LD_ADDR_VAR 0 4
58670: PUSH
58671: LD_VAR 0 4
58675: PUSH
58676: LD_VAR 0 9
58680: PUSH
58681: LD_VAR 0 3
58685: ARRAY
58686: DIFF
58687: ST_TO_ADDR
// end ;
58688: GO 58597
58690: POP
58691: POP
// if p then
58692: LD_VAR 0 11
58696: IFFALSE 58721
// result := Replace ( result , 2 , p ) ;
58698: LD_ADDR_VAR 0 2
58702: PUSH
58703: LD_VAR 0 2
58707: PPUSH
58708: LD_INT 2
58710: PPUSH
58711: LD_VAR 0 11
58715: PPUSH
58716: CALL_OW 1
58720: ST_TO_ADDR
// end else
58721: GO 58767
// for i = eng downto 5 do
58723: LD_ADDR_VAR 0 3
58727: PUSH
58728: DOUBLE
58729: LD_VAR 0 6
58733: INC
58734: ST_TO_ADDR
58735: LD_INT 5
58737: PUSH
58738: FOR_DOWNTO
58739: IFFALSE 58765
// tmp := tmp union eng [ i ] ;
58741: LD_ADDR_VAR 0 4
58745: PUSH
58746: LD_VAR 0 4
58750: PUSH
58751: LD_VAR 0 6
58755: PUSH
58756: LD_VAR 0 3
58760: ARRAY
58761: UNION
58762: ST_TO_ADDR
58763: GO 58738
58765: POP
58766: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
58767: LD_ADDR_VAR 0 2
58771: PUSH
58772: LD_VAR 0 2
58776: PPUSH
58777: LD_INT 1
58779: PPUSH
58780: LD_VAR 0 4
58784: PUSH
58785: LD_VAR 0 5
58789: DIFF
58790: PPUSH
58791: CALL_OW 1
58795: ST_TO_ADDR
// exit ;
58796: GO 58798
// end ; end ;
58798: LD_VAR 0 2
58802: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
58803: LD_INT 0
58805: PPUSH
58806: PPUSH
58807: PPUSH
// if not mc_bases then
58808: LD_EXP 66
58812: NOT
58813: IFFALSE 58817
// exit ;
58815: GO 58923
// for i = 1 to mc_bases do
58817: LD_ADDR_VAR 0 2
58821: PUSH
58822: DOUBLE
58823: LD_INT 1
58825: DEC
58826: ST_TO_ADDR
58827: LD_EXP 66
58831: PUSH
58832: FOR_TO
58833: IFFALSE 58914
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58835: LD_ADDR_VAR 0 3
58839: PUSH
58840: LD_EXP 66
58844: PUSH
58845: LD_VAR 0 2
58849: ARRAY
58850: PPUSH
58851: LD_INT 21
58853: PUSH
58854: LD_INT 3
58856: PUSH
58857: EMPTY
58858: LIST
58859: LIST
58860: PUSH
58861: LD_INT 3
58863: PUSH
58864: LD_INT 24
58866: PUSH
58867: LD_INT 1000
58869: PUSH
58870: EMPTY
58871: LIST
58872: LIST
58873: PUSH
58874: EMPTY
58875: LIST
58876: LIST
58877: PUSH
58878: EMPTY
58879: LIST
58880: LIST
58881: PPUSH
58882: CALL_OW 72
58886: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
58887: LD_ADDR_EXP 67
58891: PUSH
58892: LD_EXP 67
58896: PPUSH
58897: LD_VAR 0 2
58901: PPUSH
58902: LD_VAR 0 3
58906: PPUSH
58907: CALL_OW 1
58911: ST_TO_ADDR
// end ;
58912: GO 58832
58914: POP
58915: POP
// RaiseSailEvent ( 101 ) ;
58916: LD_INT 101
58918: PPUSH
58919: CALL_OW 427
// end ;
58923: LD_VAR 0 1
58927: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
58928: LD_INT 0
58930: PPUSH
58931: PPUSH
58932: PPUSH
58933: PPUSH
58934: PPUSH
58935: PPUSH
58936: PPUSH
// if not mc_bases then
58937: LD_EXP 66
58941: NOT
58942: IFFALSE 58946
// exit ;
58944: GO 59508
// for i = 1 to mc_bases do
58946: LD_ADDR_VAR 0 2
58950: PUSH
58951: DOUBLE
58952: LD_INT 1
58954: DEC
58955: ST_TO_ADDR
58956: LD_EXP 66
58960: PUSH
58961: FOR_TO
58962: IFFALSE 59499
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
58964: LD_ADDR_VAR 0 5
58968: PUSH
58969: LD_EXP 66
58973: PUSH
58974: LD_VAR 0 2
58978: ARRAY
58979: PUSH
58980: LD_EXP 95
58984: PUSH
58985: LD_VAR 0 2
58989: ARRAY
58990: UNION
58991: PPUSH
58992: LD_INT 21
58994: PUSH
58995: LD_INT 1
58997: PUSH
58998: EMPTY
58999: LIST
59000: LIST
59001: PUSH
59002: LD_INT 1
59004: PUSH
59005: LD_INT 3
59007: PUSH
59008: LD_INT 54
59010: PUSH
59011: EMPTY
59012: LIST
59013: PUSH
59014: EMPTY
59015: LIST
59016: LIST
59017: PUSH
59018: LD_INT 3
59020: PUSH
59021: LD_INT 24
59023: PUSH
59024: LD_INT 800
59026: PUSH
59027: EMPTY
59028: LIST
59029: LIST
59030: PUSH
59031: EMPTY
59032: LIST
59033: LIST
59034: PUSH
59035: EMPTY
59036: LIST
59037: LIST
59038: LIST
59039: PUSH
59040: EMPTY
59041: LIST
59042: LIST
59043: PPUSH
59044: CALL_OW 72
59048: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59049: LD_ADDR_VAR 0 6
59053: PUSH
59054: LD_EXP 66
59058: PUSH
59059: LD_VAR 0 2
59063: ARRAY
59064: PPUSH
59065: LD_INT 21
59067: PUSH
59068: LD_INT 1
59070: PUSH
59071: EMPTY
59072: LIST
59073: LIST
59074: PUSH
59075: LD_INT 1
59077: PUSH
59078: LD_INT 3
59080: PUSH
59081: LD_INT 54
59083: PUSH
59084: EMPTY
59085: LIST
59086: PUSH
59087: EMPTY
59088: LIST
59089: LIST
59090: PUSH
59091: LD_INT 3
59093: PUSH
59094: LD_INT 24
59096: PUSH
59097: LD_INT 250
59099: PUSH
59100: EMPTY
59101: LIST
59102: LIST
59103: PUSH
59104: EMPTY
59105: LIST
59106: LIST
59107: PUSH
59108: EMPTY
59109: LIST
59110: LIST
59111: LIST
59112: PUSH
59113: EMPTY
59114: LIST
59115: LIST
59116: PPUSH
59117: CALL_OW 72
59121: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59122: LD_ADDR_VAR 0 7
59126: PUSH
59127: LD_VAR 0 5
59131: PUSH
59132: LD_VAR 0 6
59136: DIFF
59137: ST_TO_ADDR
// if not need_heal_1 then
59138: LD_VAR 0 6
59142: NOT
59143: IFFALSE 59176
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59145: LD_ADDR_EXP 69
59149: PUSH
59150: LD_EXP 69
59154: PPUSH
59155: LD_VAR 0 2
59159: PUSH
59160: LD_INT 1
59162: PUSH
59163: EMPTY
59164: LIST
59165: LIST
59166: PPUSH
59167: EMPTY
59168: PPUSH
59169: CALL 18548 0 3
59173: ST_TO_ADDR
59174: GO 59246
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
59176: LD_ADDR_EXP 69
59180: PUSH
59181: LD_EXP 69
59185: PPUSH
59186: LD_VAR 0 2
59190: PUSH
59191: LD_INT 1
59193: PUSH
59194: EMPTY
59195: LIST
59196: LIST
59197: PPUSH
59198: LD_EXP 69
59202: PUSH
59203: LD_VAR 0 2
59207: ARRAY
59208: PUSH
59209: LD_INT 1
59211: ARRAY
59212: PPUSH
59213: LD_INT 3
59215: PUSH
59216: LD_INT 24
59218: PUSH
59219: LD_INT 1000
59221: PUSH
59222: EMPTY
59223: LIST
59224: LIST
59225: PUSH
59226: EMPTY
59227: LIST
59228: LIST
59229: PPUSH
59230: CALL_OW 72
59234: PUSH
59235: LD_VAR 0 6
59239: UNION
59240: PPUSH
59241: CALL 18548 0 3
59245: ST_TO_ADDR
// if not need_heal_2 then
59246: LD_VAR 0 7
59250: NOT
59251: IFFALSE 59284
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
59253: LD_ADDR_EXP 69
59257: PUSH
59258: LD_EXP 69
59262: PPUSH
59263: LD_VAR 0 2
59267: PUSH
59268: LD_INT 2
59270: PUSH
59271: EMPTY
59272: LIST
59273: LIST
59274: PPUSH
59275: EMPTY
59276: PPUSH
59277: CALL 18548 0 3
59281: ST_TO_ADDR
59282: GO 59316
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
59284: LD_ADDR_EXP 69
59288: PUSH
59289: LD_EXP 69
59293: PPUSH
59294: LD_VAR 0 2
59298: PUSH
59299: LD_INT 2
59301: PUSH
59302: EMPTY
59303: LIST
59304: LIST
59305: PPUSH
59306: LD_VAR 0 7
59310: PPUSH
59311: CALL 18548 0 3
59315: ST_TO_ADDR
// if need_heal_2 then
59316: LD_VAR 0 7
59320: IFFALSE 59481
// for j in need_heal_2 do
59322: LD_ADDR_VAR 0 3
59326: PUSH
59327: LD_VAR 0 7
59331: PUSH
59332: FOR_IN
59333: IFFALSE 59479
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59335: LD_ADDR_VAR 0 5
59339: PUSH
59340: LD_EXP 66
59344: PUSH
59345: LD_VAR 0 2
59349: ARRAY
59350: PPUSH
59351: LD_INT 2
59353: PUSH
59354: LD_INT 30
59356: PUSH
59357: LD_INT 6
59359: PUSH
59360: EMPTY
59361: LIST
59362: LIST
59363: PUSH
59364: LD_INT 30
59366: PUSH
59367: LD_INT 7
59369: PUSH
59370: EMPTY
59371: LIST
59372: LIST
59373: PUSH
59374: LD_INT 30
59376: PUSH
59377: LD_INT 8
59379: PUSH
59380: EMPTY
59381: LIST
59382: LIST
59383: PUSH
59384: LD_INT 30
59386: PUSH
59387: LD_INT 0
59389: PUSH
59390: EMPTY
59391: LIST
59392: LIST
59393: PUSH
59394: LD_INT 30
59396: PUSH
59397: LD_INT 1
59399: PUSH
59400: EMPTY
59401: LIST
59402: LIST
59403: PUSH
59404: EMPTY
59405: LIST
59406: LIST
59407: LIST
59408: LIST
59409: LIST
59410: LIST
59411: PPUSH
59412: CALL_OW 72
59416: ST_TO_ADDR
// if tmp then
59417: LD_VAR 0 5
59421: IFFALSE 59477
// begin k := NearestUnitToUnit ( tmp , j ) ;
59423: LD_ADDR_VAR 0 4
59427: PUSH
59428: LD_VAR 0 5
59432: PPUSH
59433: LD_VAR 0 3
59437: PPUSH
59438: CALL_OW 74
59442: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
59443: LD_VAR 0 3
59447: PPUSH
59448: LD_VAR 0 4
59452: PPUSH
59453: CALL_OW 296
59457: PUSH
59458: LD_INT 5
59460: GREATER
59461: IFFALSE 59477
// ComMoveUnit ( j , k ) ;
59463: LD_VAR 0 3
59467: PPUSH
59468: LD_VAR 0 4
59472: PPUSH
59473: CALL_OW 112
// end ; end ;
59477: GO 59332
59479: POP
59480: POP
// if not need_heal_1 and not need_heal_2 then
59481: LD_VAR 0 6
59485: NOT
59486: PUSH
59487: LD_VAR 0 7
59491: NOT
59492: AND
59493: IFFALSE 59497
// continue ;
59495: GO 58961
// end ;
59497: GO 58961
59499: POP
59500: POP
// RaiseSailEvent ( 102 ) ;
59501: LD_INT 102
59503: PPUSH
59504: CALL_OW 427
// end ;
59508: LD_VAR 0 1
59512: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
59513: LD_INT 0
59515: PPUSH
59516: PPUSH
59517: PPUSH
59518: PPUSH
59519: PPUSH
59520: PPUSH
59521: PPUSH
59522: PPUSH
// if not mc_bases then
59523: LD_EXP 66
59527: NOT
59528: IFFALSE 59532
// exit ;
59530: GO 60367
// for i = 1 to mc_bases do
59532: LD_ADDR_VAR 0 2
59536: PUSH
59537: DOUBLE
59538: LD_INT 1
59540: DEC
59541: ST_TO_ADDR
59542: LD_EXP 66
59546: PUSH
59547: FOR_TO
59548: IFFALSE 60365
// begin if not mc_building_need_repair [ i ] then
59550: LD_EXP 67
59554: PUSH
59555: LD_VAR 0 2
59559: ARRAY
59560: NOT
59561: IFFALSE 59735
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
59563: LD_ADDR_VAR 0 6
59567: PUSH
59568: LD_EXP 85
59572: PUSH
59573: LD_VAR 0 2
59577: ARRAY
59578: PPUSH
59579: LD_INT 3
59581: PUSH
59582: LD_INT 24
59584: PUSH
59585: LD_INT 1000
59587: PUSH
59588: EMPTY
59589: LIST
59590: LIST
59591: PUSH
59592: EMPTY
59593: LIST
59594: LIST
59595: PUSH
59596: LD_INT 2
59598: PUSH
59599: LD_INT 34
59601: PUSH
59602: LD_INT 13
59604: PUSH
59605: EMPTY
59606: LIST
59607: LIST
59608: PUSH
59609: LD_INT 34
59611: PUSH
59612: LD_INT 52
59614: PUSH
59615: EMPTY
59616: LIST
59617: LIST
59618: PUSH
59619: EMPTY
59620: LIST
59621: LIST
59622: LIST
59623: PUSH
59624: EMPTY
59625: LIST
59626: LIST
59627: PPUSH
59628: CALL_OW 72
59632: ST_TO_ADDR
// if cranes then
59633: LD_VAR 0 6
59637: IFFALSE 59699
// for j in cranes do
59639: LD_ADDR_VAR 0 3
59643: PUSH
59644: LD_VAR 0 6
59648: PUSH
59649: FOR_IN
59650: IFFALSE 59697
// if not IsInArea ( j , mc_parking [ i ] ) then
59652: LD_VAR 0 3
59656: PPUSH
59657: LD_EXP 90
59661: PUSH
59662: LD_VAR 0 2
59666: ARRAY
59667: PPUSH
59668: CALL_OW 308
59672: NOT
59673: IFFALSE 59695
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59675: LD_VAR 0 3
59679: PPUSH
59680: LD_EXP 90
59684: PUSH
59685: LD_VAR 0 2
59689: ARRAY
59690: PPUSH
59691: CALL_OW 113
59695: GO 59649
59697: POP
59698: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59699: LD_ADDR_EXP 68
59703: PUSH
59704: LD_EXP 68
59708: PPUSH
59709: LD_VAR 0 2
59713: PPUSH
59714: EMPTY
59715: PPUSH
59716: CALL_OW 1
59720: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
59721: LD_VAR 0 2
59725: PPUSH
59726: LD_INT 101
59728: PPUSH
59729: CALL 54636 0 2
// continue ;
59733: GO 59547
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
59735: LD_ADDR_EXP 72
59739: PUSH
59740: LD_EXP 72
59744: PPUSH
59745: LD_VAR 0 2
59749: PPUSH
59750: EMPTY
59751: PPUSH
59752: CALL_OW 1
59756: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
59757: LD_VAR 0 2
59761: PPUSH
59762: LD_INT 103
59764: PPUSH
59765: CALL 54636 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
59769: LD_ADDR_VAR 0 5
59773: PUSH
59774: LD_EXP 66
59778: PUSH
59779: LD_VAR 0 2
59783: ARRAY
59784: PUSH
59785: LD_EXP 95
59789: PUSH
59790: LD_VAR 0 2
59794: ARRAY
59795: UNION
59796: PPUSH
59797: LD_INT 2
59799: PUSH
59800: LD_INT 25
59802: PUSH
59803: LD_INT 2
59805: PUSH
59806: EMPTY
59807: LIST
59808: LIST
59809: PUSH
59810: LD_INT 25
59812: PUSH
59813: LD_INT 16
59815: PUSH
59816: EMPTY
59817: LIST
59818: LIST
59819: PUSH
59820: EMPTY
59821: LIST
59822: LIST
59823: LIST
59824: PUSH
59825: EMPTY
59826: LIST
59827: PPUSH
59828: CALL_OW 72
59832: PUSH
59833: LD_EXP 69
59837: PUSH
59838: LD_VAR 0 2
59842: ARRAY
59843: PUSH
59844: LD_INT 1
59846: ARRAY
59847: PUSH
59848: LD_EXP 69
59852: PUSH
59853: LD_VAR 0 2
59857: ARRAY
59858: PUSH
59859: LD_INT 2
59861: ARRAY
59862: UNION
59863: DIFF
59864: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
59865: LD_ADDR_VAR 0 6
59869: PUSH
59870: LD_EXP 85
59874: PUSH
59875: LD_VAR 0 2
59879: ARRAY
59880: PPUSH
59881: LD_INT 2
59883: PUSH
59884: LD_INT 34
59886: PUSH
59887: LD_INT 13
59889: PUSH
59890: EMPTY
59891: LIST
59892: LIST
59893: PUSH
59894: LD_INT 34
59896: PUSH
59897: LD_INT 52
59899: PUSH
59900: EMPTY
59901: LIST
59902: LIST
59903: PUSH
59904: EMPTY
59905: LIST
59906: LIST
59907: LIST
59908: PPUSH
59909: CALL_OW 72
59913: ST_TO_ADDR
// if cranes then
59914: LD_VAR 0 6
59918: IFFALSE 60054
// begin for j in cranes do
59920: LD_ADDR_VAR 0 3
59924: PUSH
59925: LD_VAR 0 6
59929: PUSH
59930: FOR_IN
59931: IFFALSE 60052
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
59933: LD_VAR 0 3
59937: PPUSH
59938: CALL_OW 256
59942: PUSH
59943: LD_INT 500
59945: GREATEREQUAL
59946: PUSH
59947: LD_VAR 0 3
59951: PPUSH
59952: CALL_OW 314
59956: NOT
59957: AND
59958: IFFALSE 59992
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
59960: LD_VAR 0 3
59964: PPUSH
59965: LD_EXP 67
59969: PUSH
59970: LD_VAR 0 2
59974: ARRAY
59975: PPUSH
59976: LD_VAR 0 3
59980: PPUSH
59981: CALL_OW 74
59985: PPUSH
59986: CALL_OW 130
59990: GO 60050
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
59992: LD_VAR 0 3
59996: PPUSH
59997: CALL_OW 256
60001: PUSH
60002: LD_INT 500
60004: LESS
60005: PUSH
60006: LD_VAR 0 3
60010: PPUSH
60011: LD_EXP 90
60015: PUSH
60016: LD_VAR 0 2
60020: ARRAY
60021: PPUSH
60022: CALL_OW 308
60026: NOT
60027: AND
60028: IFFALSE 60050
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60030: LD_VAR 0 3
60034: PPUSH
60035: LD_EXP 90
60039: PUSH
60040: LD_VAR 0 2
60044: ARRAY
60045: PPUSH
60046: CALL_OW 113
60050: GO 59930
60052: POP
60053: POP
// end ; if tmp > 3 then
60054: LD_VAR 0 5
60058: PUSH
60059: LD_INT 3
60061: GREATER
60062: IFFALSE 60082
// tmp := ShrinkArray ( tmp , 4 ) ;
60064: LD_ADDR_VAR 0 5
60068: PUSH
60069: LD_VAR 0 5
60073: PPUSH
60074: LD_INT 4
60076: PPUSH
60077: CALL 49906 0 2
60081: ST_TO_ADDR
// if not tmp then
60082: LD_VAR 0 5
60086: NOT
60087: IFFALSE 60091
// continue ;
60089: GO 59547
// for j in tmp do
60091: LD_ADDR_VAR 0 3
60095: PUSH
60096: LD_VAR 0 5
60100: PUSH
60101: FOR_IN
60102: IFFALSE 60361
// begin if IsInUnit ( j ) then
60104: LD_VAR 0 3
60108: PPUSH
60109: CALL_OW 310
60113: IFFALSE 60124
// ComExitBuilding ( j ) ;
60115: LD_VAR 0 3
60119: PPUSH
60120: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
60124: LD_VAR 0 3
60128: PUSH
60129: LD_EXP 68
60133: PUSH
60134: LD_VAR 0 2
60138: ARRAY
60139: IN
60140: NOT
60141: IFFALSE 60199
// begin SetTag ( j , 101 ) ;
60143: LD_VAR 0 3
60147: PPUSH
60148: LD_INT 101
60150: PPUSH
60151: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
60155: LD_ADDR_EXP 68
60159: PUSH
60160: LD_EXP 68
60164: PPUSH
60165: LD_VAR 0 2
60169: PUSH
60170: LD_EXP 68
60174: PUSH
60175: LD_VAR 0 2
60179: ARRAY
60180: PUSH
60181: LD_INT 1
60183: PLUS
60184: PUSH
60185: EMPTY
60186: LIST
60187: LIST
60188: PPUSH
60189: LD_VAR 0 3
60193: PPUSH
60194: CALL 18548 0 3
60198: ST_TO_ADDR
// end ; wait ( 1 ) ;
60199: LD_INT 1
60201: PPUSH
60202: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
60206: LD_ADDR_VAR 0 7
60210: PUSH
60211: LD_EXP 67
60215: PUSH
60216: LD_VAR 0 2
60220: ARRAY
60221: ST_TO_ADDR
// if mc_scan [ i ] then
60222: LD_EXP 89
60226: PUSH
60227: LD_VAR 0 2
60231: ARRAY
60232: IFFALSE 60294
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
60234: LD_ADDR_VAR 0 7
60238: PUSH
60239: LD_EXP 67
60243: PUSH
60244: LD_VAR 0 2
60248: ARRAY
60249: PPUSH
60250: LD_INT 3
60252: PUSH
60253: LD_INT 30
60255: PUSH
60256: LD_INT 32
60258: PUSH
60259: EMPTY
60260: LIST
60261: LIST
60262: PUSH
60263: LD_INT 30
60265: PUSH
60266: LD_INT 33
60268: PUSH
60269: EMPTY
60270: LIST
60271: LIST
60272: PUSH
60273: LD_INT 30
60275: PUSH
60276: LD_INT 31
60278: PUSH
60279: EMPTY
60280: LIST
60281: LIST
60282: PUSH
60283: EMPTY
60284: LIST
60285: LIST
60286: LIST
60287: LIST
60288: PPUSH
60289: CALL_OW 72
60293: ST_TO_ADDR
// if not to_repair_tmp then
60294: LD_VAR 0 7
60298: NOT
60299: IFFALSE 60303
// continue ;
60301: GO 60101
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
60303: LD_ADDR_VAR 0 8
60307: PUSH
60308: LD_VAR 0 7
60312: PPUSH
60313: LD_VAR 0 3
60317: PPUSH
60318: CALL_OW 74
60322: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
60323: LD_VAR 0 8
60327: PPUSH
60328: LD_INT 16
60330: PPUSH
60331: CALL 21141 0 2
60335: PUSH
60336: LD_INT 4
60338: ARRAY
60339: PUSH
60340: LD_INT 5
60342: LESS
60343: IFFALSE 60359
// ComRepairBuilding ( j , to_repair ) ;
60345: LD_VAR 0 3
60349: PPUSH
60350: LD_VAR 0 8
60354: PPUSH
60355: CALL_OW 130
// end ;
60359: GO 60101
60361: POP
60362: POP
// end ;
60363: GO 59547
60365: POP
60366: POP
// end ;
60367: LD_VAR 0 1
60371: RET
// export function MC_Heal ; var i , j , tmp ; begin
60372: LD_INT 0
60374: PPUSH
60375: PPUSH
60376: PPUSH
60377: PPUSH
// if not mc_bases then
60378: LD_EXP 66
60382: NOT
60383: IFFALSE 60387
// exit ;
60385: GO 60789
// for i = 1 to mc_bases do
60387: LD_ADDR_VAR 0 2
60391: PUSH
60392: DOUBLE
60393: LD_INT 1
60395: DEC
60396: ST_TO_ADDR
60397: LD_EXP 66
60401: PUSH
60402: FOR_TO
60403: IFFALSE 60787
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
60405: LD_EXP 69
60409: PUSH
60410: LD_VAR 0 2
60414: ARRAY
60415: PUSH
60416: LD_INT 1
60418: ARRAY
60419: NOT
60420: PUSH
60421: LD_EXP 69
60425: PUSH
60426: LD_VAR 0 2
60430: ARRAY
60431: PUSH
60432: LD_INT 2
60434: ARRAY
60435: NOT
60436: AND
60437: IFFALSE 60475
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
60439: LD_ADDR_EXP 70
60443: PUSH
60444: LD_EXP 70
60448: PPUSH
60449: LD_VAR 0 2
60453: PPUSH
60454: EMPTY
60455: PPUSH
60456: CALL_OW 1
60460: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
60461: LD_VAR 0 2
60465: PPUSH
60466: LD_INT 102
60468: PPUSH
60469: CALL 54636 0 2
// continue ;
60473: GO 60402
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60475: LD_ADDR_VAR 0 4
60479: PUSH
60480: LD_EXP 66
60484: PUSH
60485: LD_VAR 0 2
60489: ARRAY
60490: PPUSH
60491: LD_INT 25
60493: PUSH
60494: LD_INT 4
60496: PUSH
60497: EMPTY
60498: LIST
60499: LIST
60500: PPUSH
60501: CALL_OW 72
60505: ST_TO_ADDR
// if not tmp then
60506: LD_VAR 0 4
60510: NOT
60511: IFFALSE 60515
// continue ;
60513: GO 60402
// if mc_taming [ i ] then
60515: LD_EXP 97
60519: PUSH
60520: LD_VAR 0 2
60524: ARRAY
60525: IFFALSE 60549
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60527: LD_ADDR_EXP 97
60531: PUSH
60532: LD_EXP 97
60536: PPUSH
60537: LD_VAR 0 2
60541: PPUSH
60542: EMPTY
60543: PPUSH
60544: CALL_OW 1
60548: ST_TO_ADDR
// for j in tmp do
60549: LD_ADDR_VAR 0 3
60553: PUSH
60554: LD_VAR 0 4
60558: PUSH
60559: FOR_IN
60560: IFFALSE 60783
// begin if IsInUnit ( j ) then
60562: LD_VAR 0 3
60566: PPUSH
60567: CALL_OW 310
60571: IFFALSE 60582
// ComExitBuilding ( j ) ;
60573: LD_VAR 0 3
60577: PPUSH
60578: CALL_OW 122
// if not j in mc_healers [ i ] then
60582: LD_VAR 0 3
60586: PUSH
60587: LD_EXP 70
60591: PUSH
60592: LD_VAR 0 2
60596: ARRAY
60597: IN
60598: NOT
60599: IFFALSE 60645
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
60601: LD_ADDR_EXP 70
60605: PUSH
60606: LD_EXP 70
60610: PPUSH
60611: LD_VAR 0 2
60615: PUSH
60616: LD_EXP 70
60620: PUSH
60621: LD_VAR 0 2
60625: ARRAY
60626: PUSH
60627: LD_INT 1
60629: PLUS
60630: PUSH
60631: EMPTY
60632: LIST
60633: LIST
60634: PPUSH
60635: LD_VAR 0 3
60639: PPUSH
60640: CALL 18548 0 3
60644: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
60645: LD_VAR 0 3
60649: PPUSH
60650: CALL_OW 110
60654: PUSH
60655: LD_INT 102
60657: NONEQUAL
60658: IFFALSE 60672
// SetTag ( j , 102 ) ;
60660: LD_VAR 0 3
60664: PPUSH
60665: LD_INT 102
60667: PPUSH
60668: CALL_OW 109
// Wait ( 3 ) ;
60672: LD_INT 3
60674: PPUSH
60675: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
60679: LD_EXP 69
60683: PUSH
60684: LD_VAR 0 2
60688: ARRAY
60689: PUSH
60690: LD_INT 1
60692: ARRAY
60693: IFFALSE 60725
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
60695: LD_VAR 0 3
60699: PPUSH
60700: LD_EXP 69
60704: PUSH
60705: LD_VAR 0 2
60709: ARRAY
60710: PUSH
60711: LD_INT 1
60713: ARRAY
60714: PUSH
60715: LD_INT 1
60717: ARRAY
60718: PPUSH
60719: CALL_OW 128
60723: GO 60781
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
60725: LD_VAR 0 3
60729: PPUSH
60730: CALL_OW 314
60734: NOT
60735: PUSH
60736: LD_EXP 69
60740: PUSH
60741: LD_VAR 0 2
60745: ARRAY
60746: PUSH
60747: LD_INT 2
60749: ARRAY
60750: AND
60751: IFFALSE 60781
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
60753: LD_VAR 0 3
60757: PPUSH
60758: LD_EXP 69
60762: PUSH
60763: LD_VAR 0 2
60767: ARRAY
60768: PUSH
60769: LD_INT 2
60771: ARRAY
60772: PUSH
60773: LD_INT 1
60775: ARRAY
60776: PPUSH
60777: CALL_OW 128
// end ;
60781: GO 60559
60783: POP
60784: POP
// end ;
60785: GO 60402
60787: POP
60788: POP
// end ;
60789: LD_VAR 0 1
60793: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
60794: LD_INT 0
60796: PPUSH
60797: PPUSH
60798: PPUSH
60799: PPUSH
60800: PPUSH
// if not mc_bases then
60801: LD_EXP 66
60805: NOT
60806: IFFALSE 60810
// exit ;
60808: GO 61953
// for i = 1 to mc_bases do
60810: LD_ADDR_VAR 0 2
60814: PUSH
60815: DOUBLE
60816: LD_INT 1
60818: DEC
60819: ST_TO_ADDR
60820: LD_EXP 66
60824: PUSH
60825: FOR_TO
60826: IFFALSE 61951
// begin if mc_scan [ i ] then
60828: LD_EXP 89
60832: PUSH
60833: LD_VAR 0 2
60837: ARRAY
60838: IFFALSE 60842
// continue ;
60840: GO 60825
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
60842: LD_EXP 71
60846: PUSH
60847: LD_VAR 0 2
60851: ARRAY
60852: NOT
60853: PUSH
60854: LD_EXP 73
60858: PUSH
60859: LD_VAR 0 2
60863: ARRAY
60864: NOT
60865: AND
60866: PUSH
60867: LD_EXP 72
60871: PUSH
60872: LD_VAR 0 2
60876: ARRAY
60877: AND
60878: IFFALSE 60916
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
60880: LD_ADDR_EXP 72
60884: PUSH
60885: LD_EXP 72
60889: PPUSH
60890: LD_VAR 0 2
60894: PPUSH
60895: EMPTY
60896: PPUSH
60897: CALL_OW 1
60901: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60902: LD_VAR 0 2
60906: PPUSH
60907: LD_INT 103
60909: PPUSH
60910: CALL 54636 0 2
// continue ;
60914: GO 60825
// end ; if mc_construct_list [ i ] then
60916: LD_EXP 73
60920: PUSH
60921: LD_VAR 0 2
60925: ARRAY
60926: IFFALSE 61146
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
60928: LD_ADDR_VAR 0 4
60932: PUSH
60933: LD_EXP 66
60937: PUSH
60938: LD_VAR 0 2
60942: ARRAY
60943: PPUSH
60944: LD_INT 25
60946: PUSH
60947: LD_INT 2
60949: PUSH
60950: EMPTY
60951: LIST
60952: LIST
60953: PPUSH
60954: CALL_OW 72
60958: PUSH
60959: LD_EXP 68
60963: PUSH
60964: LD_VAR 0 2
60968: ARRAY
60969: DIFF
60970: ST_TO_ADDR
// if not tmp then
60971: LD_VAR 0 4
60975: NOT
60976: IFFALSE 60980
// continue ;
60978: GO 60825
// for j in tmp do
60980: LD_ADDR_VAR 0 3
60984: PUSH
60985: LD_VAR 0 4
60989: PUSH
60990: FOR_IN
60991: IFFALSE 61142
// begin if not mc_builders [ i ] then
60993: LD_EXP 72
60997: PUSH
60998: LD_VAR 0 2
61002: ARRAY
61003: NOT
61004: IFFALSE 61062
// begin SetTag ( j , 103 ) ;
61006: LD_VAR 0 3
61010: PPUSH
61011: LD_INT 103
61013: PPUSH
61014: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61018: LD_ADDR_EXP 72
61022: PUSH
61023: LD_EXP 72
61027: PPUSH
61028: LD_VAR 0 2
61032: PUSH
61033: LD_EXP 72
61037: PUSH
61038: LD_VAR 0 2
61042: ARRAY
61043: PUSH
61044: LD_INT 1
61046: PLUS
61047: PUSH
61048: EMPTY
61049: LIST
61050: LIST
61051: PPUSH
61052: LD_VAR 0 3
61056: PPUSH
61057: CALL 18548 0 3
61061: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61062: LD_VAR 0 3
61066: PPUSH
61067: CALL_OW 310
61071: IFFALSE 61082
// ComExitBuilding ( j ) ;
61073: LD_VAR 0 3
61077: PPUSH
61078: CALL_OW 122
// wait ( 3 ) ;
61082: LD_INT 3
61084: PPUSH
61085: CALL_OW 67
// if not mc_construct_list [ i ] then
61089: LD_EXP 73
61093: PUSH
61094: LD_VAR 0 2
61098: ARRAY
61099: NOT
61100: IFFALSE 61104
// break ;
61102: GO 61142
// if not HasTask ( j ) then
61104: LD_VAR 0 3
61108: PPUSH
61109: CALL_OW 314
61113: NOT
61114: IFFALSE 61140
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61116: LD_VAR 0 3
61120: PPUSH
61121: LD_EXP 73
61125: PUSH
61126: LD_VAR 0 2
61130: ARRAY
61131: PUSH
61132: LD_INT 1
61134: ARRAY
61135: PPUSH
61136: CALL 21399 0 2
// end ;
61140: GO 60990
61142: POP
61143: POP
// end else
61144: GO 61949
// if mc_build_list [ i ] then
61146: LD_EXP 71
61150: PUSH
61151: LD_VAR 0 2
61155: ARRAY
61156: IFFALSE 61949
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61158: LD_ADDR_VAR 0 5
61162: PUSH
61163: LD_EXP 66
61167: PUSH
61168: LD_VAR 0 2
61172: ARRAY
61173: PPUSH
61174: LD_INT 2
61176: PUSH
61177: LD_INT 30
61179: PUSH
61180: LD_INT 0
61182: PUSH
61183: EMPTY
61184: LIST
61185: LIST
61186: PUSH
61187: LD_INT 30
61189: PUSH
61190: LD_INT 1
61192: PUSH
61193: EMPTY
61194: LIST
61195: LIST
61196: PUSH
61197: EMPTY
61198: LIST
61199: LIST
61200: LIST
61201: PPUSH
61202: CALL_OW 72
61206: ST_TO_ADDR
// if depot then
61207: LD_VAR 0 5
61211: IFFALSE 61229
// depot := depot [ 1 ] else
61213: LD_ADDR_VAR 0 5
61217: PUSH
61218: LD_VAR 0 5
61222: PUSH
61223: LD_INT 1
61225: ARRAY
61226: ST_TO_ADDR
61227: GO 61237
// depot := 0 ;
61229: LD_ADDR_VAR 0 5
61233: PUSH
61234: LD_INT 0
61236: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
61237: LD_EXP 71
61241: PUSH
61242: LD_VAR 0 2
61246: ARRAY
61247: PUSH
61248: LD_INT 1
61250: ARRAY
61251: PUSH
61252: LD_INT 1
61254: ARRAY
61255: PPUSH
61256: CALL 21229 0 1
61260: PUSH
61261: LD_EXP 66
61265: PUSH
61266: LD_VAR 0 2
61270: ARRAY
61271: PPUSH
61272: LD_INT 2
61274: PUSH
61275: LD_INT 30
61277: PUSH
61278: LD_INT 2
61280: PUSH
61281: EMPTY
61282: LIST
61283: LIST
61284: PUSH
61285: LD_INT 30
61287: PUSH
61288: LD_INT 3
61290: PUSH
61291: EMPTY
61292: LIST
61293: LIST
61294: PUSH
61295: EMPTY
61296: LIST
61297: LIST
61298: LIST
61299: PPUSH
61300: CALL_OW 72
61304: NOT
61305: AND
61306: IFFALSE 61411
// begin for j = 1 to mc_build_list [ i ] do
61308: LD_ADDR_VAR 0 3
61312: PUSH
61313: DOUBLE
61314: LD_INT 1
61316: DEC
61317: ST_TO_ADDR
61318: LD_EXP 71
61322: PUSH
61323: LD_VAR 0 2
61327: ARRAY
61328: PUSH
61329: FOR_TO
61330: IFFALSE 61409
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
61332: LD_EXP 71
61336: PUSH
61337: LD_VAR 0 2
61341: ARRAY
61342: PUSH
61343: LD_VAR 0 3
61347: ARRAY
61348: PUSH
61349: LD_INT 1
61351: ARRAY
61352: PUSH
61353: LD_INT 2
61355: EQUAL
61356: IFFALSE 61407
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
61358: LD_ADDR_EXP 71
61362: PUSH
61363: LD_EXP 71
61367: PPUSH
61368: LD_VAR 0 2
61372: PPUSH
61373: LD_EXP 71
61377: PUSH
61378: LD_VAR 0 2
61382: ARRAY
61383: PPUSH
61384: LD_VAR 0 3
61388: PPUSH
61389: LD_INT 1
61391: PPUSH
61392: LD_INT 0
61394: PPUSH
61395: CALL 17966 0 4
61399: PPUSH
61400: CALL_OW 1
61404: ST_TO_ADDR
// break ;
61405: GO 61409
// end ;
61407: GO 61329
61409: POP
61410: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
61411: LD_EXP 71
61415: PUSH
61416: LD_VAR 0 2
61420: ARRAY
61421: PUSH
61422: LD_INT 1
61424: ARRAY
61425: PUSH
61426: LD_INT 1
61428: ARRAY
61429: PUSH
61430: LD_INT 0
61432: EQUAL
61433: PUSH
61434: LD_VAR 0 5
61438: PUSH
61439: LD_VAR 0 5
61443: PPUSH
61444: LD_EXP 71
61448: PUSH
61449: LD_VAR 0 2
61453: ARRAY
61454: PUSH
61455: LD_INT 1
61457: ARRAY
61458: PUSH
61459: LD_INT 1
61461: ARRAY
61462: PPUSH
61463: LD_EXP 71
61467: PUSH
61468: LD_VAR 0 2
61472: ARRAY
61473: PUSH
61474: LD_INT 1
61476: ARRAY
61477: PUSH
61478: LD_INT 2
61480: ARRAY
61481: PPUSH
61482: LD_EXP 71
61486: PUSH
61487: LD_VAR 0 2
61491: ARRAY
61492: PUSH
61493: LD_INT 1
61495: ARRAY
61496: PUSH
61497: LD_INT 3
61499: ARRAY
61500: PPUSH
61501: LD_EXP 71
61505: PUSH
61506: LD_VAR 0 2
61510: ARRAY
61511: PUSH
61512: LD_INT 1
61514: ARRAY
61515: PUSH
61516: LD_INT 4
61518: ARRAY
61519: PPUSH
61520: CALL 25963 0 5
61524: AND
61525: OR
61526: IFFALSE 61807
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61528: LD_ADDR_VAR 0 4
61532: PUSH
61533: LD_EXP 66
61537: PUSH
61538: LD_VAR 0 2
61542: ARRAY
61543: PPUSH
61544: LD_INT 25
61546: PUSH
61547: LD_INT 2
61549: PUSH
61550: EMPTY
61551: LIST
61552: LIST
61553: PPUSH
61554: CALL_OW 72
61558: PUSH
61559: LD_EXP 68
61563: PUSH
61564: LD_VAR 0 2
61568: ARRAY
61569: DIFF
61570: ST_TO_ADDR
// if not tmp then
61571: LD_VAR 0 4
61575: NOT
61576: IFFALSE 61580
// continue ;
61578: GO 60825
// for j in tmp do
61580: LD_ADDR_VAR 0 3
61584: PUSH
61585: LD_VAR 0 4
61589: PUSH
61590: FOR_IN
61591: IFFALSE 61803
// begin if not mc_builders [ i ] then
61593: LD_EXP 72
61597: PUSH
61598: LD_VAR 0 2
61602: ARRAY
61603: NOT
61604: IFFALSE 61662
// begin SetTag ( j , 103 ) ;
61606: LD_VAR 0 3
61610: PPUSH
61611: LD_INT 103
61613: PPUSH
61614: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61618: LD_ADDR_EXP 72
61622: PUSH
61623: LD_EXP 72
61627: PPUSH
61628: LD_VAR 0 2
61632: PUSH
61633: LD_EXP 72
61637: PUSH
61638: LD_VAR 0 2
61642: ARRAY
61643: PUSH
61644: LD_INT 1
61646: PLUS
61647: PUSH
61648: EMPTY
61649: LIST
61650: LIST
61651: PPUSH
61652: LD_VAR 0 3
61656: PPUSH
61657: CALL 18548 0 3
61661: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61662: LD_VAR 0 3
61666: PPUSH
61667: CALL_OW 310
61671: IFFALSE 61682
// ComExitBuilding ( j ) ;
61673: LD_VAR 0 3
61677: PPUSH
61678: CALL_OW 122
// wait ( 3 ) ;
61682: LD_INT 3
61684: PPUSH
61685: CALL_OW 67
// if not mc_build_list [ i ] then
61689: LD_EXP 71
61693: PUSH
61694: LD_VAR 0 2
61698: ARRAY
61699: NOT
61700: IFFALSE 61704
// break ;
61702: GO 61803
// if not HasTask ( j ) then
61704: LD_VAR 0 3
61708: PPUSH
61709: CALL_OW 314
61713: NOT
61714: IFFALSE 61801
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
61716: LD_VAR 0 3
61720: PPUSH
61721: LD_EXP 71
61725: PUSH
61726: LD_VAR 0 2
61730: ARRAY
61731: PUSH
61732: LD_INT 1
61734: ARRAY
61735: PUSH
61736: LD_INT 1
61738: ARRAY
61739: PPUSH
61740: LD_EXP 71
61744: PUSH
61745: LD_VAR 0 2
61749: ARRAY
61750: PUSH
61751: LD_INT 1
61753: ARRAY
61754: PUSH
61755: LD_INT 2
61757: ARRAY
61758: PPUSH
61759: LD_EXP 71
61763: PUSH
61764: LD_VAR 0 2
61768: ARRAY
61769: PUSH
61770: LD_INT 1
61772: ARRAY
61773: PUSH
61774: LD_INT 3
61776: ARRAY
61777: PPUSH
61778: LD_EXP 71
61782: PUSH
61783: LD_VAR 0 2
61787: ARRAY
61788: PUSH
61789: LD_INT 1
61791: ARRAY
61792: PUSH
61793: LD_INT 4
61795: ARRAY
61796: PPUSH
61797: CALL_OW 145
// end ;
61801: GO 61590
61803: POP
61804: POP
// end else
61805: GO 61949
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
61807: LD_EXP 66
61811: PUSH
61812: LD_VAR 0 2
61816: ARRAY
61817: PPUSH
61818: LD_EXP 71
61822: PUSH
61823: LD_VAR 0 2
61827: ARRAY
61828: PUSH
61829: LD_INT 1
61831: ARRAY
61832: PUSH
61833: LD_INT 1
61835: ARRAY
61836: PPUSH
61837: LD_EXP 71
61841: PUSH
61842: LD_VAR 0 2
61846: ARRAY
61847: PUSH
61848: LD_INT 1
61850: ARRAY
61851: PUSH
61852: LD_INT 2
61854: ARRAY
61855: PPUSH
61856: LD_EXP 71
61860: PUSH
61861: LD_VAR 0 2
61865: ARRAY
61866: PUSH
61867: LD_INT 1
61869: ARRAY
61870: PUSH
61871: LD_INT 3
61873: ARRAY
61874: PPUSH
61875: LD_EXP 71
61879: PUSH
61880: LD_VAR 0 2
61884: ARRAY
61885: PUSH
61886: LD_INT 1
61888: ARRAY
61889: PUSH
61890: LD_INT 4
61892: ARRAY
61893: PPUSH
61894: CALL 25299 0 5
61898: NOT
61899: IFFALSE 61949
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
61901: LD_ADDR_EXP 71
61905: PUSH
61906: LD_EXP 71
61910: PPUSH
61911: LD_VAR 0 2
61915: PPUSH
61916: LD_EXP 71
61920: PUSH
61921: LD_VAR 0 2
61925: ARRAY
61926: PPUSH
61927: LD_INT 1
61929: PPUSH
61930: LD_INT 1
61932: NEG
61933: PPUSH
61934: LD_INT 0
61936: PPUSH
61937: CALL 17966 0 4
61941: PPUSH
61942: CALL_OW 1
61946: ST_TO_ADDR
// continue ;
61947: GO 60825
// end ; end ; end ;
61949: GO 60825
61951: POP
61952: POP
// end ;
61953: LD_VAR 0 1
61957: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
61958: LD_INT 0
61960: PPUSH
61961: PPUSH
61962: PPUSH
61963: PPUSH
61964: PPUSH
61965: PPUSH
// if not mc_bases then
61966: LD_EXP 66
61970: NOT
61971: IFFALSE 61975
// exit ;
61973: GO 62402
// for i = 1 to mc_bases do
61975: LD_ADDR_VAR 0 2
61979: PUSH
61980: DOUBLE
61981: LD_INT 1
61983: DEC
61984: ST_TO_ADDR
61985: LD_EXP 66
61989: PUSH
61990: FOR_TO
61991: IFFALSE 62400
// begin tmp := mc_build_upgrade [ i ] ;
61993: LD_ADDR_VAR 0 4
61997: PUSH
61998: LD_EXP 98
62002: PUSH
62003: LD_VAR 0 2
62007: ARRAY
62008: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62009: LD_ADDR_VAR 0 6
62013: PUSH
62014: LD_EXP 99
62018: PUSH
62019: LD_VAR 0 2
62023: ARRAY
62024: PPUSH
62025: LD_INT 2
62027: PUSH
62028: LD_INT 30
62030: PUSH
62031: LD_INT 6
62033: PUSH
62034: EMPTY
62035: LIST
62036: LIST
62037: PUSH
62038: LD_INT 30
62040: PUSH
62041: LD_INT 7
62043: PUSH
62044: EMPTY
62045: LIST
62046: LIST
62047: PUSH
62048: EMPTY
62049: LIST
62050: LIST
62051: LIST
62052: PPUSH
62053: CALL_OW 72
62057: ST_TO_ADDR
// if not tmp and not lab then
62058: LD_VAR 0 4
62062: NOT
62063: PUSH
62064: LD_VAR 0 6
62068: NOT
62069: AND
62070: IFFALSE 62074
// continue ;
62072: GO 61990
// if tmp then
62074: LD_VAR 0 4
62078: IFFALSE 62198
// for j in tmp do
62080: LD_ADDR_VAR 0 3
62084: PUSH
62085: LD_VAR 0 4
62089: PUSH
62090: FOR_IN
62091: IFFALSE 62196
// begin if UpgradeCost ( j ) then
62093: LD_VAR 0 3
62097: PPUSH
62098: CALL 24959 0 1
62102: IFFALSE 62194
// begin ComUpgrade ( j ) ;
62104: LD_VAR 0 3
62108: PPUSH
62109: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
62113: LD_ADDR_EXP 98
62117: PUSH
62118: LD_EXP 98
62122: PPUSH
62123: LD_VAR 0 2
62127: PPUSH
62128: LD_EXP 98
62132: PUSH
62133: LD_VAR 0 2
62137: ARRAY
62138: PUSH
62139: LD_VAR 0 3
62143: DIFF
62144: PPUSH
62145: CALL_OW 1
62149: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62150: LD_ADDR_EXP 73
62154: PUSH
62155: LD_EXP 73
62159: PPUSH
62160: LD_VAR 0 2
62164: PUSH
62165: LD_EXP 73
62169: PUSH
62170: LD_VAR 0 2
62174: ARRAY
62175: PUSH
62176: LD_INT 1
62178: PLUS
62179: PUSH
62180: EMPTY
62181: LIST
62182: LIST
62183: PPUSH
62184: LD_VAR 0 3
62188: PPUSH
62189: CALL 18548 0 3
62193: ST_TO_ADDR
// end ; end ;
62194: GO 62090
62196: POP
62197: POP
// if not lab or not mc_lab_upgrade [ i ] then
62198: LD_VAR 0 6
62202: NOT
62203: PUSH
62204: LD_EXP 100
62208: PUSH
62209: LD_VAR 0 2
62213: ARRAY
62214: NOT
62215: OR
62216: IFFALSE 62220
// continue ;
62218: GO 61990
// for j in lab do
62220: LD_ADDR_VAR 0 3
62224: PUSH
62225: LD_VAR 0 6
62229: PUSH
62230: FOR_IN
62231: IFFALSE 62396
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
62233: LD_VAR 0 3
62237: PPUSH
62238: CALL_OW 266
62242: PUSH
62243: LD_INT 6
62245: PUSH
62246: LD_INT 7
62248: PUSH
62249: EMPTY
62250: LIST
62251: LIST
62252: IN
62253: PUSH
62254: LD_VAR 0 3
62258: PPUSH
62259: CALL_OW 461
62263: PUSH
62264: LD_INT 1
62266: NONEQUAL
62267: AND
62268: IFFALSE 62394
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
62270: LD_VAR 0 3
62274: PPUSH
62275: LD_EXP 100
62279: PUSH
62280: LD_VAR 0 2
62284: ARRAY
62285: PUSH
62286: LD_INT 1
62288: ARRAY
62289: PPUSH
62290: CALL 25164 0 2
62294: IFFALSE 62394
// begin ComCancel ( j ) ;
62296: LD_VAR 0 3
62300: PPUSH
62301: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
62305: LD_VAR 0 3
62309: PPUSH
62310: LD_EXP 100
62314: PUSH
62315: LD_VAR 0 2
62319: ARRAY
62320: PUSH
62321: LD_INT 1
62323: ARRAY
62324: PPUSH
62325: CALL_OW 207
// if not j in mc_construct_list [ i ] then
62329: LD_VAR 0 3
62333: PUSH
62334: LD_EXP 73
62338: PUSH
62339: LD_VAR 0 2
62343: ARRAY
62344: IN
62345: NOT
62346: IFFALSE 62392
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62348: LD_ADDR_EXP 73
62352: PUSH
62353: LD_EXP 73
62357: PPUSH
62358: LD_VAR 0 2
62362: PUSH
62363: LD_EXP 73
62367: PUSH
62368: LD_VAR 0 2
62372: ARRAY
62373: PUSH
62374: LD_INT 1
62376: PLUS
62377: PUSH
62378: EMPTY
62379: LIST
62380: LIST
62381: PPUSH
62382: LD_VAR 0 3
62386: PPUSH
62387: CALL 18548 0 3
62391: ST_TO_ADDR
// break ;
62392: GO 62396
// end ; end ; end ;
62394: GO 62230
62396: POP
62397: POP
// end ;
62398: GO 61990
62400: POP
62401: POP
// end ;
62402: LD_VAR 0 1
62406: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
62407: LD_INT 0
62409: PPUSH
62410: PPUSH
62411: PPUSH
62412: PPUSH
62413: PPUSH
62414: PPUSH
62415: PPUSH
62416: PPUSH
62417: PPUSH
// if not mc_bases then
62418: LD_EXP 66
62422: NOT
62423: IFFALSE 62427
// exit ;
62425: GO 62832
// for i = 1 to mc_bases do
62427: LD_ADDR_VAR 0 2
62431: PUSH
62432: DOUBLE
62433: LD_INT 1
62435: DEC
62436: ST_TO_ADDR
62437: LD_EXP 66
62441: PUSH
62442: FOR_TO
62443: IFFALSE 62830
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
62445: LD_EXP 74
62449: PUSH
62450: LD_VAR 0 2
62454: ARRAY
62455: NOT
62456: PUSH
62457: LD_EXP 66
62461: PUSH
62462: LD_VAR 0 2
62466: ARRAY
62467: PPUSH
62468: LD_INT 30
62470: PUSH
62471: LD_INT 3
62473: PUSH
62474: EMPTY
62475: LIST
62476: LIST
62477: PPUSH
62478: CALL_OW 72
62482: NOT
62483: OR
62484: IFFALSE 62488
// continue ;
62486: GO 62442
// busy := false ;
62488: LD_ADDR_VAR 0 8
62492: PUSH
62493: LD_INT 0
62495: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62496: LD_ADDR_VAR 0 4
62500: PUSH
62501: LD_EXP 66
62505: PUSH
62506: LD_VAR 0 2
62510: ARRAY
62511: PPUSH
62512: LD_INT 30
62514: PUSH
62515: LD_INT 3
62517: PUSH
62518: EMPTY
62519: LIST
62520: LIST
62521: PPUSH
62522: CALL_OW 72
62526: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
62527: LD_ADDR_VAR 0 6
62531: PUSH
62532: LD_EXP 74
62536: PUSH
62537: LD_VAR 0 2
62541: ARRAY
62542: PPUSH
62543: LD_INT 2
62545: PUSH
62546: LD_INT 30
62548: PUSH
62549: LD_INT 32
62551: PUSH
62552: EMPTY
62553: LIST
62554: LIST
62555: PUSH
62556: LD_INT 30
62558: PUSH
62559: LD_INT 33
62561: PUSH
62562: EMPTY
62563: LIST
62564: LIST
62565: PUSH
62566: EMPTY
62567: LIST
62568: LIST
62569: LIST
62570: PPUSH
62571: CALL_OW 72
62575: ST_TO_ADDR
// if not t then
62576: LD_VAR 0 6
62580: NOT
62581: IFFALSE 62585
// continue ;
62583: GO 62442
// for j in tmp do
62585: LD_ADDR_VAR 0 3
62589: PUSH
62590: LD_VAR 0 4
62594: PUSH
62595: FOR_IN
62596: IFFALSE 62626
// if not BuildingStatus ( j ) = bs_idle then
62598: LD_VAR 0 3
62602: PPUSH
62603: CALL_OW 461
62607: PUSH
62608: LD_INT 2
62610: EQUAL
62611: NOT
62612: IFFALSE 62624
// begin busy := true ;
62614: LD_ADDR_VAR 0 8
62618: PUSH
62619: LD_INT 1
62621: ST_TO_ADDR
// break ;
62622: GO 62626
// end ;
62624: GO 62595
62626: POP
62627: POP
// if busy then
62628: LD_VAR 0 8
62632: IFFALSE 62636
// continue ;
62634: GO 62442
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
62636: LD_ADDR_VAR 0 7
62640: PUSH
62641: LD_VAR 0 6
62645: PPUSH
62646: LD_INT 35
62648: PUSH
62649: LD_INT 0
62651: PUSH
62652: EMPTY
62653: LIST
62654: LIST
62655: PPUSH
62656: CALL_OW 72
62660: ST_TO_ADDR
// if tw then
62661: LD_VAR 0 7
62665: IFFALSE 62742
// begin tw := tw [ 1 ] ;
62667: LD_ADDR_VAR 0 7
62671: PUSH
62672: LD_VAR 0 7
62676: PUSH
62677: LD_INT 1
62679: ARRAY
62680: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
62681: LD_ADDR_VAR 0 9
62685: PUSH
62686: LD_VAR 0 7
62690: PPUSH
62691: LD_EXP 91
62695: PUSH
62696: LD_VAR 0 2
62700: ARRAY
62701: PPUSH
62702: CALL 23518 0 2
62706: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
62707: LD_EXP 105
62711: PUSH
62712: LD_VAR 0 2
62716: ARRAY
62717: IFFALSE 62740
// if not weapon in mc_allowed_tower_weapons [ i ] then
62719: LD_VAR 0 9
62723: PUSH
62724: LD_EXP 105
62728: PUSH
62729: LD_VAR 0 2
62733: ARRAY
62734: IN
62735: NOT
62736: IFFALSE 62740
// continue ;
62738: GO 62442
// end else
62740: GO 62805
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
62742: LD_ADDR_VAR 0 5
62746: PUSH
62747: LD_EXP 74
62751: PUSH
62752: LD_VAR 0 2
62756: ARRAY
62757: PPUSH
62758: LD_VAR 0 4
62762: PPUSH
62763: CALL 49139 0 2
62767: ST_TO_ADDR
// if not tmp2 then
62768: LD_VAR 0 5
62772: NOT
62773: IFFALSE 62777
// continue ;
62775: GO 62442
// tw := tmp2 [ 1 ] ;
62777: LD_ADDR_VAR 0 7
62781: PUSH
62782: LD_VAR 0 5
62786: PUSH
62787: LD_INT 1
62789: ARRAY
62790: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
62791: LD_ADDR_VAR 0 9
62795: PUSH
62796: LD_VAR 0 5
62800: PUSH
62801: LD_INT 2
62803: ARRAY
62804: ST_TO_ADDR
// end ; if not weapon then
62805: LD_VAR 0 9
62809: NOT
62810: IFFALSE 62814
// continue ;
62812: GO 62442
// ComPlaceWeapon ( tw , weapon ) ;
62814: LD_VAR 0 7
62818: PPUSH
62819: LD_VAR 0 9
62823: PPUSH
62824: CALL_OW 148
// end ;
62828: GO 62442
62830: POP
62831: POP
// end ;
62832: LD_VAR 0 1
62836: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
62837: LD_INT 0
62839: PPUSH
62840: PPUSH
62841: PPUSH
62842: PPUSH
62843: PPUSH
62844: PPUSH
// if not mc_bases then
62845: LD_EXP 66
62849: NOT
62850: IFFALSE 62854
// exit ;
62852: GO 63630
// for i = 1 to mc_bases do
62854: LD_ADDR_VAR 0 2
62858: PUSH
62859: DOUBLE
62860: LD_INT 1
62862: DEC
62863: ST_TO_ADDR
62864: LD_EXP 66
62868: PUSH
62869: FOR_TO
62870: IFFALSE 63628
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
62872: LD_EXP 79
62876: PUSH
62877: LD_VAR 0 2
62881: ARRAY
62882: NOT
62883: PUSH
62884: LD_EXP 79
62888: PUSH
62889: LD_VAR 0 2
62893: ARRAY
62894: PUSH
62895: LD_EXP 80
62899: PUSH
62900: LD_VAR 0 2
62904: ARRAY
62905: EQUAL
62906: OR
62907: PUSH
62908: LD_EXP 89
62912: PUSH
62913: LD_VAR 0 2
62917: ARRAY
62918: OR
62919: IFFALSE 62923
// continue ;
62921: GO 62869
// if mc_miners [ i ] then
62923: LD_EXP 80
62927: PUSH
62928: LD_VAR 0 2
62932: ARRAY
62933: IFFALSE 63315
// begin for j = mc_miners [ i ] downto 1 do
62935: LD_ADDR_VAR 0 3
62939: PUSH
62940: DOUBLE
62941: LD_EXP 80
62945: PUSH
62946: LD_VAR 0 2
62950: ARRAY
62951: INC
62952: ST_TO_ADDR
62953: LD_INT 1
62955: PUSH
62956: FOR_DOWNTO
62957: IFFALSE 63313
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
62959: LD_EXP 80
62963: PUSH
62964: LD_VAR 0 2
62968: ARRAY
62969: PUSH
62970: LD_VAR 0 3
62974: ARRAY
62975: PPUSH
62976: CALL_OW 301
62980: PUSH
62981: LD_EXP 80
62985: PUSH
62986: LD_VAR 0 2
62990: ARRAY
62991: PUSH
62992: LD_VAR 0 3
62996: ARRAY
62997: PPUSH
62998: CALL_OW 257
63002: PUSH
63003: LD_INT 1
63005: NONEQUAL
63006: OR
63007: IFFALSE 63070
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63009: LD_ADDR_VAR 0 5
63013: PUSH
63014: LD_EXP 80
63018: PUSH
63019: LD_VAR 0 2
63023: ARRAY
63024: PUSH
63025: LD_EXP 80
63029: PUSH
63030: LD_VAR 0 2
63034: ARRAY
63035: PUSH
63036: LD_VAR 0 3
63040: ARRAY
63041: DIFF
63042: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63043: LD_ADDR_EXP 80
63047: PUSH
63048: LD_EXP 80
63052: PPUSH
63053: LD_VAR 0 2
63057: PPUSH
63058: LD_VAR 0 5
63062: PPUSH
63063: CALL_OW 1
63067: ST_TO_ADDR
// continue ;
63068: GO 62956
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63070: LD_EXP 80
63074: PUSH
63075: LD_VAR 0 2
63079: ARRAY
63080: PUSH
63081: LD_VAR 0 3
63085: ARRAY
63086: PPUSH
63087: CALL_OW 257
63091: PUSH
63092: LD_INT 1
63094: EQUAL
63095: PUSH
63096: LD_EXP 80
63100: PUSH
63101: LD_VAR 0 2
63105: ARRAY
63106: PUSH
63107: LD_VAR 0 3
63111: ARRAY
63112: PPUSH
63113: CALL_OW 459
63117: NOT
63118: AND
63119: PUSH
63120: LD_EXP 80
63124: PUSH
63125: LD_VAR 0 2
63129: ARRAY
63130: PUSH
63131: LD_VAR 0 3
63135: ARRAY
63136: PPUSH
63137: CALL_OW 314
63141: NOT
63142: AND
63143: IFFALSE 63311
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
63145: LD_EXP 80
63149: PUSH
63150: LD_VAR 0 2
63154: ARRAY
63155: PUSH
63156: LD_VAR 0 3
63160: ARRAY
63161: PPUSH
63162: CALL_OW 310
63166: IFFALSE 63189
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
63168: LD_EXP 80
63172: PUSH
63173: LD_VAR 0 2
63177: ARRAY
63178: PUSH
63179: LD_VAR 0 3
63183: ARRAY
63184: PPUSH
63185: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
63189: LD_EXP 80
63193: PUSH
63194: LD_VAR 0 2
63198: ARRAY
63199: PUSH
63200: LD_VAR 0 3
63204: ARRAY
63205: PPUSH
63206: CALL_OW 314
63210: NOT
63211: IFFALSE 63311
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
63213: LD_EXP 80
63217: PUSH
63218: LD_VAR 0 2
63222: ARRAY
63223: PUSH
63224: LD_VAR 0 3
63228: ARRAY
63229: PPUSH
63230: LD_EXP 79
63234: PUSH
63235: LD_VAR 0 2
63239: ARRAY
63240: PUSH
63241: LD_VAR 0 3
63245: PUSH
63246: LD_EXP 79
63250: PUSH
63251: LD_VAR 0 2
63255: ARRAY
63256: MOD
63257: PUSH
63258: LD_INT 1
63260: PLUS
63261: ARRAY
63262: PUSH
63263: LD_INT 1
63265: ARRAY
63266: PPUSH
63267: LD_EXP 79
63271: PUSH
63272: LD_VAR 0 2
63276: ARRAY
63277: PUSH
63278: LD_VAR 0 3
63282: PUSH
63283: LD_EXP 79
63287: PUSH
63288: LD_VAR 0 2
63292: ARRAY
63293: MOD
63294: PUSH
63295: LD_INT 1
63297: PLUS
63298: ARRAY
63299: PUSH
63300: LD_INT 2
63302: ARRAY
63303: PPUSH
63304: LD_INT 0
63306: PPUSH
63307: CALL_OW 193
// end ; end ;
63311: GO 62956
63313: POP
63314: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
63315: LD_ADDR_VAR 0 5
63319: PUSH
63320: LD_EXP 66
63324: PUSH
63325: LD_VAR 0 2
63329: ARRAY
63330: PPUSH
63331: LD_INT 2
63333: PUSH
63334: LD_INT 30
63336: PUSH
63337: LD_INT 4
63339: PUSH
63340: EMPTY
63341: LIST
63342: LIST
63343: PUSH
63344: LD_INT 30
63346: PUSH
63347: LD_INT 5
63349: PUSH
63350: EMPTY
63351: LIST
63352: LIST
63353: PUSH
63354: LD_INT 30
63356: PUSH
63357: LD_INT 32
63359: PUSH
63360: EMPTY
63361: LIST
63362: LIST
63363: PUSH
63364: EMPTY
63365: LIST
63366: LIST
63367: LIST
63368: LIST
63369: PPUSH
63370: CALL_OW 72
63374: ST_TO_ADDR
// if not tmp then
63375: LD_VAR 0 5
63379: NOT
63380: IFFALSE 63384
// continue ;
63382: GO 62869
// list := [ ] ;
63384: LD_ADDR_VAR 0 6
63388: PUSH
63389: EMPTY
63390: ST_TO_ADDR
// for j in tmp do
63391: LD_ADDR_VAR 0 3
63395: PUSH
63396: LD_VAR 0 5
63400: PUSH
63401: FOR_IN
63402: IFFALSE 63471
// begin for k in UnitsInside ( j ) do
63404: LD_ADDR_VAR 0 4
63408: PUSH
63409: LD_VAR 0 3
63413: PPUSH
63414: CALL_OW 313
63418: PUSH
63419: FOR_IN
63420: IFFALSE 63467
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
63422: LD_VAR 0 4
63426: PPUSH
63427: CALL_OW 257
63431: PUSH
63432: LD_INT 1
63434: EQUAL
63435: PUSH
63436: LD_VAR 0 4
63440: PPUSH
63441: CALL_OW 459
63445: NOT
63446: AND
63447: IFFALSE 63465
// list := list ^ k ;
63449: LD_ADDR_VAR 0 6
63453: PUSH
63454: LD_VAR 0 6
63458: PUSH
63459: LD_VAR 0 4
63463: ADD
63464: ST_TO_ADDR
63465: GO 63419
63467: POP
63468: POP
// end ;
63469: GO 63401
63471: POP
63472: POP
// list := list diff mc_miners [ i ] ;
63473: LD_ADDR_VAR 0 6
63477: PUSH
63478: LD_VAR 0 6
63482: PUSH
63483: LD_EXP 80
63487: PUSH
63488: LD_VAR 0 2
63492: ARRAY
63493: DIFF
63494: ST_TO_ADDR
// if not list then
63495: LD_VAR 0 6
63499: NOT
63500: IFFALSE 63504
// continue ;
63502: GO 62869
// k := mc_mines [ i ] - mc_miners [ i ] ;
63504: LD_ADDR_VAR 0 4
63508: PUSH
63509: LD_EXP 79
63513: PUSH
63514: LD_VAR 0 2
63518: ARRAY
63519: PUSH
63520: LD_EXP 80
63524: PUSH
63525: LD_VAR 0 2
63529: ARRAY
63530: MINUS
63531: ST_TO_ADDR
// if k > list then
63532: LD_VAR 0 4
63536: PUSH
63537: LD_VAR 0 6
63541: GREATER
63542: IFFALSE 63554
// k := list ;
63544: LD_ADDR_VAR 0 4
63548: PUSH
63549: LD_VAR 0 6
63553: ST_TO_ADDR
// for j = 1 to k do
63554: LD_ADDR_VAR 0 3
63558: PUSH
63559: DOUBLE
63560: LD_INT 1
63562: DEC
63563: ST_TO_ADDR
63564: LD_VAR 0 4
63568: PUSH
63569: FOR_TO
63570: IFFALSE 63624
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
63572: LD_ADDR_EXP 80
63576: PUSH
63577: LD_EXP 80
63581: PPUSH
63582: LD_VAR 0 2
63586: PUSH
63587: LD_EXP 80
63591: PUSH
63592: LD_VAR 0 2
63596: ARRAY
63597: PUSH
63598: LD_INT 1
63600: PLUS
63601: PUSH
63602: EMPTY
63603: LIST
63604: LIST
63605: PPUSH
63606: LD_VAR 0 6
63610: PUSH
63611: LD_VAR 0 3
63615: ARRAY
63616: PPUSH
63617: CALL 18548 0 3
63621: ST_TO_ADDR
63622: GO 63569
63624: POP
63625: POP
// end ;
63626: GO 62869
63628: POP
63629: POP
// end ;
63630: LD_VAR 0 1
63634: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
63635: LD_INT 0
63637: PPUSH
63638: PPUSH
63639: PPUSH
63640: PPUSH
63641: PPUSH
63642: PPUSH
63643: PPUSH
63644: PPUSH
63645: PPUSH
63646: PPUSH
// if not mc_bases then
63647: LD_EXP 66
63651: NOT
63652: IFFALSE 63656
// exit ;
63654: GO 65406
// for i = 1 to mc_bases do
63656: LD_ADDR_VAR 0 2
63660: PUSH
63661: DOUBLE
63662: LD_INT 1
63664: DEC
63665: ST_TO_ADDR
63666: LD_EXP 66
63670: PUSH
63671: FOR_TO
63672: IFFALSE 65404
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
63674: LD_EXP 66
63678: PUSH
63679: LD_VAR 0 2
63683: ARRAY
63684: NOT
63685: PUSH
63686: LD_EXP 73
63690: PUSH
63691: LD_VAR 0 2
63695: ARRAY
63696: OR
63697: IFFALSE 63701
// continue ;
63699: GO 63671
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
63701: LD_EXP 82
63705: PUSH
63706: LD_VAR 0 2
63710: ARRAY
63711: NOT
63712: PUSH
63713: LD_EXP 83
63717: PUSH
63718: LD_VAR 0 2
63722: ARRAY
63723: AND
63724: IFFALSE 63762
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63726: LD_ADDR_EXP 83
63730: PUSH
63731: LD_EXP 83
63735: PPUSH
63736: LD_VAR 0 2
63740: PPUSH
63741: EMPTY
63742: PPUSH
63743: CALL_OW 1
63747: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
63748: LD_VAR 0 2
63752: PPUSH
63753: LD_INT 107
63755: PPUSH
63756: CALL 54636 0 2
// continue ;
63760: GO 63671
// end ; target := [ ] ;
63762: LD_ADDR_VAR 0 6
63766: PUSH
63767: EMPTY
63768: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
63769: LD_ADDR_VAR 0 3
63773: PUSH
63774: DOUBLE
63775: LD_EXP 82
63779: PUSH
63780: LD_VAR 0 2
63784: ARRAY
63785: INC
63786: ST_TO_ADDR
63787: LD_INT 1
63789: PUSH
63790: FOR_DOWNTO
63791: IFFALSE 64051
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
63793: LD_EXP 82
63797: PUSH
63798: LD_VAR 0 2
63802: ARRAY
63803: PUSH
63804: LD_VAR 0 3
63808: ARRAY
63809: PUSH
63810: LD_INT 2
63812: ARRAY
63813: PPUSH
63814: LD_EXP 82
63818: PUSH
63819: LD_VAR 0 2
63823: ARRAY
63824: PUSH
63825: LD_VAR 0 3
63829: ARRAY
63830: PUSH
63831: LD_INT 3
63833: ARRAY
63834: PPUSH
63835: CALL_OW 488
63839: PUSH
63840: LD_EXP 82
63844: PUSH
63845: LD_VAR 0 2
63849: ARRAY
63850: PUSH
63851: LD_VAR 0 3
63855: ARRAY
63856: PUSH
63857: LD_INT 2
63859: ARRAY
63860: PPUSH
63861: LD_EXP 82
63865: PUSH
63866: LD_VAR 0 2
63870: ARRAY
63871: PUSH
63872: LD_VAR 0 3
63876: ARRAY
63877: PUSH
63878: LD_INT 3
63880: ARRAY
63881: PPUSH
63882: CALL_OW 284
63886: PUSH
63887: LD_INT 0
63889: EQUAL
63890: AND
63891: IFFALSE 63946
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
63893: LD_ADDR_VAR 0 5
63897: PUSH
63898: LD_EXP 82
63902: PUSH
63903: LD_VAR 0 2
63907: ARRAY
63908: PPUSH
63909: LD_VAR 0 3
63913: PPUSH
63914: CALL_OW 3
63918: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
63919: LD_ADDR_EXP 82
63923: PUSH
63924: LD_EXP 82
63928: PPUSH
63929: LD_VAR 0 2
63933: PPUSH
63934: LD_VAR 0 5
63938: PPUSH
63939: CALL_OW 1
63943: ST_TO_ADDR
// continue ;
63944: GO 63790
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
63946: LD_EXP 66
63950: PUSH
63951: LD_VAR 0 2
63955: ARRAY
63956: PUSH
63957: LD_INT 1
63959: ARRAY
63960: PPUSH
63961: CALL_OW 255
63965: PPUSH
63966: LD_EXP 82
63970: PUSH
63971: LD_VAR 0 2
63975: ARRAY
63976: PUSH
63977: LD_VAR 0 3
63981: ARRAY
63982: PUSH
63983: LD_INT 2
63985: ARRAY
63986: PPUSH
63987: LD_EXP 82
63991: PUSH
63992: LD_VAR 0 2
63996: ARRAY
63997: PUSH
63998: LD_VAR 0 3
64002: ARRAY
64003: PUSH
64004: LD_INT 3
64006: ARRAY
64007: PPUSH
64008: LD_INT 30
64010: PPUSH
64011: CALL 19444 0 4
64015: PUSH
64016: LD_INT 4
64018: ARRAY
64019: PUSH
64020: LD_INT 0
64022: EQUAL
64023: IFFALSE 64049
// begin target := mc_crates [ i ] [ j ] ;
64025: LD_ADDR_VAR 0 6
64029: PUSH
64030: LD_EXP 82
64034: PUSH
64035: LD_VAR 0 2
64039: ARRAY
64040: PUSH
64041: LD_VAR 0 3
64045: ARRAY
64046: ST_TO_ADDR
// break ;
64047: GO 64051
// end ; end ;
64049: GO 63790
64051: POP
64052: POP
// if not target then
64053: LD_VAR 0 6
64057: NOT
64058: IFFALSE 64062
// continue ;
64060: GO 63671
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
64062: LD_ADDR_VAR 0 7
64066: PUSH
64067: LD_EXP 85
64071: PUSH
64072: LD_VAR 0 2
64076: ARRAY
64077: PPUSH
64078: LD_INT 2
64080: PUSH
64081: LD_INT 3
64083: PUSH
64084: LD_INT 58
64086: PUSH
64087: EMPTY
64088: LIST
64089: PUSH
64090: EMPTY
64091: LIST
64092: LIST
64093: PUSH
64094: LD_INT 61
64096: PUSH
64097: EMPTY
64098: LIST
64099: PUSH
64100: LD_INT 33
64102: PUSH
64103: LD_INT 5
64105: PUSH
64106: EMPTY
64107: LIST
64108: LIST
64109: PUSH
64110: LD_INT 33
64112: PUSH
64113: LD_INT 3
64115: PUSH
64116: EMPTY
64117: LIST
64118: LIST
64119: PUSH
64120: EMPTY
64121: LIST
64122: LIST
64123: LIST
64124: LIST
64125: LIST
64126: PUSH
64127: LD_INT 2
64129: PUSH
64130: LD_INT 34
64132: PUSH
64133: LD_INT 32
64135: PUSH
64136: EMPTY
64137: LIST
64138: LIST
64139: PUSH
64140: LD_INT 34
64142: PUSH
64143: LD_INT 51
64145: PUSH
64146: EMPTY
64147: LIST
64148: LIST
64149: PUSH
64150: LD_INT 34
64152: PUSH
64153: LD_INT 12
64155: PUSH
64156: EMPTY
64157: LIST
64158: LIST
64159: PUSH
64160: EMPTY
64161: LIST
64162: LIST
64163: LIST
64164: LIST
64165: PUSH
64166: EMPTY
64167: LIST
64168: LIST
64169: PPUSH
64170: CALL_OW 72
64174: ST_TO_ADDR
// if not cargo then
64175: LD_VAR 0 7
64179: NOT
64180: IFFALSE 64823
// begin if mc_crates_collector [ i ] < 5 then
64182: LD_EXP 83
64186: PUSH
64187: LD_VAR 0 2
64191: ARRAY
64192: PUSH
64193: LD_INT 5
64195: LESS
64196: IFFALSE 64562
// begin if mc_ape [ i ] then
64198: LD_EXP 95
64202: PUSH
64203: LD_VAR 0 2
64207: ARRAY
64208: IFFALSE 64255
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
64210: LD_ADDR_VAR 0 5
64214: PUSH
64215: LD_EXP 95
64219: PUSH
64220: LD_VAR 0 2
64224: ARRAY
64225: PPUSH
64226: LD_INT 25
64228: PUSH
64229: LD_INT 16
64231: PUSH
64232: EMPTY
64233: LIST
64234: LIST
64235: PUSH
64236: LD_INT 24
64238: PUSH
64239: LD_INT 750
64241: PUSH
64242: EMPTY
64243: LIST
64244: LIST
64245: PUSH
64246: EMPTY
64247: LIST
64248: LIST
64249: PPUSH
64250: CALL_OW 72
64254: ST_TO_ADDR
// if not tmp then
64255: LD_VAR 0 5
64259: NOT
64260: IFFALSE 64307
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
64262: LD_ADDR_VAR 0 5
64266: PUSH
64267: LD_EXP 66
64271: PUSH
64272: LD_VAR 0 2
64276: ARRAY
64277: PPUSH
64278: LD_INT 25
64280: PUSH
64281: LD_INT 2
64283: PUSH
64284: EMPTY
64285: LIST
64286: LIST
64287: PUSH
64288: LD_INT 24
64290: PUSH
64291: LD_INT 750
64293: PUSH
64294: EMPTY
64295: LIST
64296: LIST
64297: PUSH
64298: EMPTY
64299: LIST
64300: LIST
64301: PPUSH
64302: CALL_OW 72
64306: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
64307: LD_EXP 95
64311: PUSH
64312: LD_VAR 0 2
64316: ARRAY
64317: PUSH
64318: LD_EXP 66
64322: PUSH
64323: LD_VAR 0 2
64327: ARRAY
64328: PPUSH
64329: LD_INT 25
64331: PUSH
64332: LD_INT 2
64334: PUSH
64335: EMPTY
64336: LIST
64337: LIST
64338: PUSH
64339: LD_INT 24
64341: PUSH
64342: LD_INT 750
64344: PUSH
64345: EMPTY
64346: LIST
64347: LIST
64348: PUSH
64349: EMPTY
64350: LIST
64351: LIST
64352: PPUSH
64353: CALL_OW 72
64357: AND
64358: PUSH
64359: LD_VAR 0 5
64363: PUSH
64364: LD_INT 5
64366: LESS
64367: AND
64368: IFFALSE 64450
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
64370: LD_ADDR_VAR 0 3
64374: PUSH
64375: LD_EXP 66
64379: PUSH
64380: LD_VAR 0 2
64384: ARRAY
64385: PPUSH
64386: LD_INT 25
64388: PUSH
64389: LD_INT 2
64391: PUSH
64392: EMPTY
64393: LIST
64394: LIST
64395: PUSH
64396: LD_INT 24
64398: PUSH
64399: LD_INT 750
64401: PUSH
64402: EMPTY
64403: LIST
64404: LIST
64405: PUSH
64406: EMPTY
64407: LIST
64408: LIST
64409: PPUSH
64410: CALL_OW 72
64414: PUSH
64415: FOR_IN
64416: IFFALSE 64448
// begin tmp := tmp union j ;
64418: LD_ADDR_VAR 0 5
64422: PUSH
64423: LD_VAR 0 5
64427: PUSH
64428: LD_VAR 0 3
64432: UNION
64433: ST_TO_ADDR
// if tmp >= 5 then
64434: LD_VAR 0 5
64438: PUSH
64439: LD_INT 5
64441: GREATEREQUAL
64442: IFFALSE 64446
// break ;
64444: GO 64448
// end ;
64446: GO 64415
64448: POP
64449: POP
// end ; if not tmp then
64450: LD_VAR 0 5
64454: NOT
64455: IFFALSE 64459
// continue ;
64457: GO 63671
// for j in tmp do
64459: LD_ADDR_VAR 0 3
64463: PUSH
64464: LD_VAR 0 5
64468: PUSH
64469: FOR_IN
64470: IFFALSE 64560
// if not GetTag ( j ) then
64472: LD_VAR 0 3
64476: PPUSH
64477: CALL_OW 110
64481: NOT
64482: IFFALSE 64558
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
64484: LD_ADDR_EXP 83
64488: PUSH
64489: LD_EXP 83
64493: PPUSH
64494: LD_VAR 0 2
64498: PUSH
64499: LD_EXP 83
64503: PUSH
64504: LD_VAR 0 2
64508: ARRAY
64509: PUSH
64510: LD_INT 1
64512: PLUS
64513: PUSH
64514: EMPTY
64515: LIST
64516: LIST
64517: PPUSH
64518: LD_VAR 0 3
64522: PPUSH
64523: CALL 18548 0 3
64527: ST_TO_ADDR
// SetTag ( j , 107 ) ;
64528: LD_VAR 0 3
64532: PPUSH
64533: LD_INT 107
64535: PPUSH
64536: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
64540: LD_EXP 83
64544: PUSH
64545: LD_VAR 0 2
64549: ARRAY
64550: PUSH
64551: LD_INT 5
64553: GREATEREQUAL
64554: IFFALSE 64558
// break ;
64556: GO 64560
// end ;
64558: GO 64469
64560: POP
64561: POP
// end ; if mc_crates_collector [ i ] and target then
64562: LD_EXP 83
64566: PUSH
64567: LD_VAR 0 2
64571: ARRAY
64572: PUSH
64573: LD_VAR 0 6
64577: AND
64578: IFFALSE 64821
// begin if mc_crates_collector [ i ] < target [ 1 ] then
64580: LD_EXP 83
64584: PUSH
64585: LD_VAR 0 2
64589: ARRAY
64590: PUSH
64591: LD_VAR 0 6
64595: PUSH
64596: LD_INT 1
64598: ARRAY
64599: LESS
64600: IFFALSE 64620
// tmp := mc_crates_collector [ i ] else
64602: LD_ADDR_VAR 0 5
64606: PUSH
64607: LD_EXP 83
64611: PUSH
64612: LD_VAR 0 2
64616: ARRAY
64617: ST_TO_ADDR
64618: GO 64634
// tmp := target [ 1 ] ;
64620: LD_ADDR_VAR 0 5
64624: PUSH
64625: LD_VAR 0 6
64629: PUSH
64630: LD_INT 1
64632: ARRAY
64633: ST_TO_ADDR
// k := 0 ;
64634: LD_ADDR_VAR 0 4
64638: PUSH
64639: LD_INT 0
64641: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
64642: LD_ADDR_VAR 0 3
64646: PUSH
64647: LD_EXP 83
64651: PUSH
64652: LD_VAR 0 2
64656: ARRAY
64657: PUSH
64658: FOR_IN
64659: IFFALSE 64819
// begin k := k + 1 ;
64661: LD_ADDR_VAR 0 4
64665: PUSH
64666: LD_VAR 0 4
64670: PUSH
64671: LD_INT 1
64673: PLUS
64674: ST_TO_ADDR
// if k > tmp then
64675: LD_VAR 0 4
64679: PUSH
64680: LD_VAR 0 5
64684: GREATER
64685: IFFALSE 64689
// break ;
64687: GO 64819
// if not GetClass ( j ) in [ 2 , 16 ] then
64689: LD_VAR 0 3
64693: PPUSH
64694: CALL_OW 257
64698: PUSH
64699: LD_INT 2
64701: PUSH
64702: LD_INT 16
64704: PUSH
64705: EMPTY
64706: LIST
64707: LIST
64708: IN
64709: NOT
64710: IFFALSE 64763
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
64712: LD_ADDR_EXP 83
64716: PUSH
64717: LD_EXP 83
64721: PPUSH
64722: LD_VAR 0 2
64726: PPUSH
64727: LD_EXP 83
64731: PUSH
64732: LD_VAR 0 2
64736: ARRAY
64737: PUSH
64738: LD_VAR 0 3
64742: DIFF
64743: PPUSH
64744: CALL_OW 1
64748: ST_TO_ADDR
// SetTag ( j , 0 ) ;
64749: LD_VAR 0 3
64753: PPUSH
64754: LD_INT 0
64756: PPUSH
64757: CALL_OW 109
// continue ;
64761: GO 64658
// end ; if IsInUnit ( j ) then
64763: LD_VAR 0 3
64767: PPUSH
64768: CALL_OW 310
64772: IFFALSE 64783
// ComExitBuilding ( j ) ;
64774: LD_VAR 0 3
64778: PPUSH
64779: CALL_OW 122
// wait ( 3 ) ;
64783: LD_INT 3
64785: PPUSH
64786: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
64790: LD_VAR 0 3
64794: PPUSH
64795: LD_VAR 0 6
64799: PUSH
64800: LD_INT 2
64802: ARRAY
64803: PPUSH
64804: LD_VAR 0 6
64808: PUSH
64809: LD_INT 3
64811: ARRAY
64812: PPUSH
64813: CALL_OW 117
// end ;
64817: GO 64658
64819: POP
64820: POP
// end ; end else
64821: GO 65402
// begin for j in cargo do
64823: LD_ADDR_VAR 0 3
64827: PUSH
64828: LD_VAR 0 7
64832: PUSH
64833: FOR_IN
64834: IFFALSE 65400
// begin if GetTag ( j ) <> 0 then
64836: LD_VAR 0 3
64840: PPUSH
64841: CALL_OW 110
64845: PUSH
64846: LD_INT 0
64848: NONEQUAL
64849: IFFALSE 64853
// continue ;
64851: GO 64833
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
64853: LD_VAR 0 3
64857: PPUSH
64858: CALL_OW 256
64862: PUSH
64863: LD_INT 1000
64865: LESS
64866: PUSH
64867: LD_VAR 0 3
64871: PPUSH
64872: LD_EXP 90
64876: PUSH
64877: LD_VAR 0 2
64881: ARRAY
64882: PPUSH
64883: CALL_OW 308
64887: NOT
64888: AND
64889: IFFALSE 64911
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64891: LD_VAR 0 3
64895: PPUSH
64896: LD_EXP 90
64900: PUSH
64901: LD_VAR 0 2
64905: ARRAY
64906: PPUSH
64907: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
64911: LD_VAR 0 3
64915: PPUSH
64916: CALL_OW 256
64920: PUSH
64921: LD_INT 1000
64923: LESS
64924: PUSH
64925: LD_VAR 0 3
64929: PPUSH
64930: LD_EXP 90
64934: PUSH
64935: LD_VAR 0 2
64939: ARRAY
64940: PPUSH
64941: CALL_OW 308
64945: AND
64946: IFFALSE 64950
// continue ;
64948: GO 64833
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
64950: LD_VAR 0 3
64954: PPUSH
64955: CALL_OW 262
64959: PUSH
64960: LD_INT 2
64962: EQUAL
64963: PUSH
64964: LD_VAR 0 3
64968: PPUSH
64969: CALL_OW 261
64973: PUSH
64974: LD_INT 15
64976: LESS
64977: AND
64978: IFFALSE 64982
// continue ;
64980: GO 64833
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
64982: LD_VAR 0 3
64986: PPUSH
64987: CALL_OW 262
64991: PUSH
64992: LD_INT 1
64994: EQUAL
64995: PUSH
64996: LD_VAR 0 3
65000: PPUSH
65001: CALL_OW 261
65005: PUSH
65006: LD_INT 10
65008: LESS
65009: AND
65010: IFFALSE 65339
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65012: LD_ADDR_VAR 0 8
65016: PUSH
65017: LD_EXP 66
65021: PUSH
65022: LD_VAR 0 2
65026: ARRAY
65027: PPUSH
65028: LD_INT 2
65030: PUSH
65031: LD_INT 30
65033: PUSH
65034: LD_INT 0
65036: PUSH
65037: EMPTY
65038: LIST
65039: LIST
65040: PUSH
65041: LD_INT 30
65043: PUSH
65044: LD_INT 1
65046: PUSH
65047: EMPTY
65048: LIST
65049: LIST
65050: PUSH
65051: EMPTY
65052: LIST
65053: LIST
65054: LIST
65055: PPUSH
65056: CALL_OW 72
65060: ST_TO_ADDR
// if not depot then
65061: LD_VAR 0 8
65065: NOT
65066: IFFALSE 65070
// continue ;
65068: GO 64833
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
65070: LD_VAR 0 3
65074: PPUSH
65075: LD_VAR 0 8
65079: PPUSH
65080: LD_VAR 0 3
65084: PPUSH
65085: CALL_OW 74
65089: PPUSH
65090: CALL_OW 296
65094: PUSH
65095: LD_INT 6
65097: LESS
65098: IFFALSE 65114
// SetFuel ( j , 100 ) else
65100: LD_VAR 0 3
65104: PPUSH
65105: LD_INT 100
65107: PPUSH
65108: CALL_OW 240
65112: GO 65339
// if GetFuel ( j ) = 0 then
65114: LD_VAR 0 3
65118: PPUSH
65119: CALL_OW 261
65123: PUSH
65124: LD_INT 0
65126: EQUAL
65127: IFFALSE 65339
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
65129: LD_ADDR_EXP 85
65133: PUSH
65134: LD_EXP 85
65138: PPUSH
65139: LD_VAR 0 2
65143: PPUSH
65144: LD_EXP 85
65148: PUSH
65149: LD_VAR 0 2
65153: ARRAY
65154: PUSH
65155: LD_VAR 0 3
65159: DIFF
65160: PPUSH
65161: CALL_OW 1
65165: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
65166: LD_VAR 0 3
65170: PPUSH
65171: CALL_OW 263
65175: PUSH
65176: LD_INT 1
65178: EQUAL
65179: IFFALSE 65195
// ComExitVehicle ( IsInUnit ( j ) ) ;
65181: LD_VAR 0 3
65185: PPUSH
65186: CALL_OW 310
65190: PPUSH
65191: CALL_OW 121
// if GetControl ( j ) = control_remote then
65195: LD_VAR 0 3
65199: PPUSH
65200: CALL_OW 263
65204: PUSH
65205: LD_INT 2
65207: EQUAL
65208: IFFALSE 65219
// ComUnlink ( j ) ;
65210: LD_VAR 0 3
65214: PPUSH
65215: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
65219: LD_ADDR_VAR 0 9
65223: PUSH
65224: LD_VAR 0 2
65228: PPUSH
65229: LD_INT 3
65231: PPUSH
65232: CALL 74692 0 2
65236: ST_TO_ADDR
// if fac then
65237: LD_VAR 0 9
65241: IFFALSE 65337
// begin for k in fac do
65243: LD_ADDR_VAR 0 4
65247: PUSH
65248: LD_VAR 0 9
65252: PUSH
65253: FOR_IN
65254: IFFALSE 65335
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
65256: LD_ADDR_VAR 0 10
65260: PUSH
65261: LD_VAR 0 9
65265: PPUSH
65266: LD_VAR 0 3
65270: PPUSH
65271: CALL_OW 265
65275: PPUSH
65276: LD_VAR 0 3
65280: PPUSH
65281: CALL_OW 262
65285: PPUSH
65286: LD_VAR 0 3
65290: PPUSH
65291: CALL_OW 263
65295: PPUSH
65296: LD_VAR 0 3
65300: PPUSH
65301: CALL_OW 264
65305: PPUSH
65306: CALL 16080 0 5
65310: ST_TO_ADDR
// if components then
65311: LD_VAR 0 10
65315: IFFALSE 65333
// begin MC_InsertProduceList ( i , components ) ;
65317: LD_VAR 0 2
65321: PPUSH
65322: LD_VAR 0 10
65326: PPUSH
65327: CALL 74237 0 2
// break ;
65331: GO 65335
// end ; end ;
65333: GO 65253
65335: POP
65336: POP
// end ; continue ;
65337: GO 64833
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
65339: LD_VAR 0 3
65343: PPUSH
65344: LD_INT 1
65346: PPUSH
65347: CALL_OW 289
65351: PUSH
65352: LD_INT 100
65354: LESS
65355: PUSH
65356: LD_VAR 0 3
65360: PPUSH
65361: CALL_OW 314
65365: NOT
65366: AND
65367: IFFALSE 65396
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65369: LD_VAR 0 3
65373: PPUSH
65374: LD_VAR 0 6
65378: PUSH
65379: LD_INT 2
65381: ARRAY
65382: PPUSH
65383: LD_VAR 0 6
65387: PUSH
65388: LD_INT 3
65390: ARRAY
65391: PPUSH
65392: CALL_OW 117
// break ;
65396: GO 65400
// end ;
65398: GO 64833
65400: POP
65401: POP
// end ; end ;
65402: GO 63671
65404: POP
65405: POP
// end ;
65406: LD_VAR 0 1
65410: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
65411: LD_INT 0
65413: PPUSH
65414: PPUSH
65415: PPUSH
65416: PPUSH
// if not mc_bases then
65417: LD_EXP 66
65421: NOT
65422: IFFALSE 65426
// exit ;
65424: GO 65587
// for i = 1 to mc_bases do
65426: LD_ADDR_VAR 0 2
65430: PUSH
65431: DOUBLE
65432: LD_INT 1
65434: DEC
65435: ST_TO_ADDR
65436: LD_EXP 66
65440: PUSH
65441: FOR_TO
65442: IFFALSE 65585
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
65444: LD_ADDR_VAR 0 4
65448: PUSH
65449: LD_EXP 85
65453: PUSH
65454: LD_VAR 0 2
65458: ARRAY
65459: PUSH
65460: LD_EXP 88
65464: PUSH
65465: LD_VAR 0 2
65469: ARRAY
65470: UNION
65471: PPUSH
65472: LD_INT 33
65474: PUSH
65475: LD_INT 2
65477: PUSH
65478: EMPTY
65479: LIST
65480: LIST
65481: PPUSH
65482: CALL_OW 72
65486: ST_TO_ADDR
// if tmp then
65487: LD_VAR 0 4
65491: IFFALSE 65583
// for j in tmp do
65493: LD_ADDR_VAR 0 3
65497: PUSH
65498: LD_VAR 0 4
65502: PUSH
65503: FOR_IN
65504: IFFALSE 65581
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
65506: LD_VAR 0 3
65510: PPUSH
65511: CALL_OW 312
65515: NOT
65516: PUSH
65517: LD_VAR 0 3
65521: PPUSH
65522: CALL_OW 256
65526: PUSH
65527: LD_INT 250
65529: GREATEREQUAL
65530: AND
65531: IFFALSE 65544
// Connect ( j ) else
65533: LD_VAR 0 3
65537: PPUSH
65538: CALL 21481 0 1
65542: GO 65579
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
65544: LD_VAR 0 3
65548: PPUSH
65549: CALL_OW 256
65553: PUSH
65554: LD_INT 250
65556: LESS
65557: PUSH
65558: LD_VAR 0 3
65562: PPUSH
65563: CALL_OW 312
65567: AND
65568: IFFALSE 65579
// ComUnlink ( j ) ;
65570: LD_VAR 0 3
65574: PPUSH
65575: CALL_OW 136
65579: GO 65503
65581: POP
65582: POP
// end ;
65583: GO 65441
65585: POP
65586: POP
// end ;
65587: LD_VAR 0 1
65591: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
65592: LD_INT 0
65594: PPUSH
65595: PPUSH
65596: PPUSH
65597: PPUSH
65598: PPUSH
// if not mc_bases then
65599: LD_EXP 66
65603: NOT
65604: IFFALSE 65608
// exit ;
65606: GO 66053
// for i = 1 to mc_bases do
65608: LD_ADDR_VAR 0 2
65612: PUSH
65613: DOUBLE
65614: LD_INT 1
65616: DEC
65617: ST_TO_ADDR
65618: LD_EXP 66
65622: PUSH
65623: FOR_TO
65624: IFFALSE 66051
// begin if not mc_produce [ i ] then
65626: LD_EXP 87
65630: PUSH
65631: LD_VAR 0 2
65635: ARRAY
65636: NOT
65637: IFFALSE 65641
// continue ;
65639: GO 65623
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65641: LD_ADDR_VAR 0 5
65645: PUSH
65646: LD_EXP 66
65650: PUSH
65651: LD_VAR 0 2
65655: ARRAY
65656: PPUSH
65657: LD_INT 30
65659: PUSH
65660: LD_INT 3
65662: PUSH
65663: EMPTY
65664: LIST
65665: LIST
65666: PPUSH
65667: CALL_OW 72
65671: ST_TO_ADDR
// if not fac then
65672: LD_VAR 0 5
65676: NOT
65677: IFFALSE 65681
// continue ;
65679: GO 65623
// for j in fac do
65681: LD_ADDR_VAR 0 3
65685: PUSH
65686: LD_VAR 0 5
65690: PUSH
65691: FOR_IN
65692: IFFALSE 66047
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
65694: LD_VAR 0 3
65698: PPUSH
65699: CALL_OW 461
65703: PUSH
65704: LD_INT 2
65706: NONEQUAL
65707: PUSH
65708: LD_VAR 0 3
65712: PPUSH
65713: LD_INT 15
65715: PPUSH
65716: CALL 21141 0 2
65720: PUSH
65721: LD_INT 4
65723: ARRAY
65724: OR
65725: IFFALSE 65729
// continue ;
65727: GO 65691
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
65729: LD_VAR 0 3
65733: PPUSH
65734: LD_EXP 87
65738: PUSH
65739: LD_VAR 0 2
65743: ARRAY
65744: PUSH
65745: LD_INT 1
65747: ARRAY
65748: PUSH
65749: LD_INT 1
65751: ARRAY
65752: PPUSH
65753: LD_EXP 87
65757: PUSH
65758: LD_VAR 0 2
65762: ARRAY
65763: PUSH
65764: LD_INT 1
65766: ARRAY
65767: PUSH
65768: LD_INT 2
65770: ARRAY
65771: PPUSH
65772: LD_EXP 87
65776: PUSH
65777: LD_VAR 0 2
65781: ARRAY
65782: PUSH
65783: LD_INT 1
65785: ARRAY
65786: PUSH
65787: LD_INT 3
65789: ARRAY
65790: PPUSH
65791: LD_EXP 87
65795: PUSH
65796: LD_VAR 0 2
65800: ARRAY
65801: PUSH
65802: LD_INT 1
65804: ARRAY
65805: PUSH
65806: LD_INT 4
65808: ARRAY
65809: PPUSH
65810: CALL_OW 448
65814: PUSH
65815: LD_VAR 0 3
65819: PPUSH
65820: LD_EXP 87
65824: PUSH
65825: LD_VAR 0 2
65829: ARRAY
65830: PUSH
65831: LD_INT 1
65833: ARRAY
65834: PUSH
65835: LD_INT 1
65837: ARRAY
65838: PUSH
65839: LD_EXP 87
65843: PUSH
65844: LD_VAR 0 2
65848: ARRAY
65849: PUSH
65850: LD_INT 1
65852: ARRAY
65853: PUSH
65854: LD_INT 2
65856: ARRAY
65857: PUSH
65858: LD_EXP 87
65862: PUSH
65863: LD_VAR 0 2
65867: ARRAY
65868: PUSH
65869: LD_INT 1
65871: ARRAY
65872: PUSH
65873: LD_INT 3
65875: ARRAY
65876: PUSH
65877: LD_EXP 87
65881: PUSH
65882: LD_VAR 0 2
65886: ARRAY
65887: PUSH
65888: LD_INT 1
65890: ARRAY
65891: PUSH
65892: LD_INT 4
65894: ARRAY
65895: PUSH
65896: EMPTY
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: PPUSH
65902: CALL 24812 0 2
65906: AND
65907: IFFALSE 66045
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
65909: LD_VAR 0 3
65913: PPUSH
65914: LD_EXP 87
65918: PUSH
65919: LD_VAR 0 2
65923: ARRAY
65924: PUSH
65925: LD_INT 1
65927: ARRAY
65928: PUSH
65929: LD_INT 1
65931: ARRAY
65932: PPUSH
65933: LD_EXP 87
65937: PUSH
65938: LD_VAR 0 2
65942: ARRAY
65943: PUSH
65944: LD_INT 1
65946: ARRAY
65947: PUSH
65948: LD_INT 2
65950: ARRAY
65951: PPUSH
65952: LD_EXP 87
65956: PUSH
65957: LD_VAR 0 2
65961: ARRAY
65962: PUSH
65963: LD_INT 1
65965: ARRAY
65966: PUSH
65967: LD_INT 3
65969: ARRAY
65970: PPUSH
65971: LD_EXP 87
65975: PUSH
65976: LD_VAR 0 2
65980: ARRAY
65981: PUSH
65982: LD_INT 1
65984: ARRAY
65985: PUSH
65986: LD_INT 4
65988: ARRAY
65989: PPUSH
65990: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
65994: LD_ADDR_VAR 0 4
65998: PUSH
65999: LD_EXP 87
66003: PUSH
66004: LD_VAR 0 2
66008: ARRAY
66009: PPUSH
66010: LD_INT 1
66012: PPUSH
66013: CALL_OW 3
66017: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66018: LD_ADDR_EXP 87
66022: PUSH
66023: LD_EXP 87
66027: PPUSH
66028: LD_VAR 0 2
66032: PPUSH
66033: LD_VAR 0 4
66037: PPUSH
66038: CALL_OW 1
66042: ST_TO_ADDR
// break ;
66043: GO 66047
// end ; end ;
66045: GO 65691
66047: POP
66048: POP
// end ;
66049: GO 65623
66051: POP
66052: POP
// end ;
66053: LD_VAR 0 1
66057: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
66058: LD_INT 0
66060: PPUSH
66061: PPUSH
66062: PPUSH
// if not mc_bases then
66063: LD_EXP 66
66067: NOT
66068: IFFALSE 66072
// exit ;
66070: GO 66161
// for i = 1 to mc_bases do
66072: LD_ADDR_VAR 0 2
66076: PUSH
66077: DOUBLE
66078: LD_INT 1
66080: DEC
66081: ST_TO_ADDR
66082: LD_EXP 66
66086: PUSH
66087: FOR_TO
66088: IFFALSE 66159
// begin if mc_attack [ i ] then
66090: LD_EXP 86
66094: PUSH
66095: LD_VAR 0 2
66099: ARRAY
66100: IFFALSE 66157
// begin tmp := mc_attack [ i ] [ 1 ] ;
66102: LD_ADDR_VAR 0 3
66106: PUSH
66107: LD_EXP 86
66111: PUSH
66112: LD_VAR 0 2
66116: ARRAY
66117: PUSH
66118: LD_INT 1
66120: ARRAY
66121: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66122: LD_ADDR_EXP 86
66126: PUSH
66127: LD_EXP 86
66131: PPUSH
66132: LD_VAR 0 2
66136: PPUSH
66137: EMPTY
66138: PPUSH
66139: CALL_OW 1
66143: ST_TO_ADDR
// Attack ( tmp ) ;
66144: LD_VAR 0 3
66148: PPUSH
66149: CALL 97737 0 1
// exit ;
66153: POP
66154: POP
66155: GO 66161
// end ; end ;
66157: GO 66087
66159: POP
66160: POP
// end ;
66161: LD_VAR 0 1
66165: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
66166: LD_INT 0
66168: PPUSH
66169: PPUSH
66170: PPUSH
66171: PPUSH
66172: PPUSH
66173: PPUSH
66174: PPUSH
// if not mc_bases then
66175: LD_EXP 66
66179: NOT
66180: IFFALSE 66184
// exit ;
66182: GO 66766
// for i = 1 to mc_bases do
66184: LD_ADDR_VAR 0 2
66188: PUSH
66189: DOUBLE
66190: LD_INT 1
66192: DEC
66193: ST_TO_ADDR
66194: LD_EXP 66
66198: PUSH
66199: FOR_TO
66200: IFFALSE 66764
// begin if not mc_bases [ i ] then
66202: LD_EXP 66
66206: PUSH
66207: LD_VAR 0 2
66211: ARRAY
66212: NOT
66213: IFFALSE 66217
// continue ;
66215: GO 66199
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
66217: LD_ADDR_VAR 0 7
66221: PUSH
66222: LD_EXP 66
66226: PUSH
66227: LD_VAR 0 2
66231: ARRAY
66232: PUSH
66233: LD_INT 1
66235: ARRAY
66236: PPUSH
66237: CALL 15384 0 1
66241: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
66242: LD_ADDR_EXP 89
66246: PUSH
66247: LD_EXP 89
66251: PPUSH
66252: LD_VAR 0 2
66256: PPUSH
66257: LD_EXP 66
66261: PUSH
66262: LD_VAR 0 2
66266: ARRAY
66267: PUSH
66268: LD_INT 1
66270: ARRAY
66271: PPUSH
66272: CALL_OW 255
66276: PPUSH
66277: LD_EXP 91
66281: PUSH
66282: LD_VAR 0 2
66286: ARRAY
66287: PPUSH
66288: CALL 15349 0 2
66292: PPUSH
66293: CALL_OW 1
66297: ST_TO_ADDR
// if not mc_scan [ i ] then
66298: LD_EXP 89
66302: PUSH
66303: LD_VAR 0 2
66307: ARRAY
66308: NOT
66309: IFFALSE 66464
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66311: LD_ADDR_VAR 0 4
66315: PUSH
66316: LD_EXP 66
66320: PUSH
66321: LD_VAR 0 2
66325: ARRAY
66326: PPUSH
66327: LD_INT 2
66329: PUSH
66330: LD_INT 25
66332: PUSH
66333: LD_INT 5
66335: PUSH
66336: EMPTY
66337: LIST
66338: LIST
66339: PUSH
66340: LD_INT 25
66342: PUSH
66343: LD_INT 8
66345: PUSH
66346: EMPTY
66347: LIST
66348: LIST
66349: PUSH
66350: LD_INT 25
66352: PUSH
66353: LD_INT 9
66355: PUSH
66356: EMPTY
66357: LIST
66358: LIST
66359: PUSH
66360: EMPTY
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: PPUSH
66366: CALL_OW 72
66370: ST_TO_ADDR
// if not tmp then
66371: LD_VAR 0 4
66375: NOT
66376: IFFALSE 66380
// continue ;
66378: GO 66199
// for j in tmp do
66380: LD_ADDR_VAR 0 3
66384: PUSH
66385: LD_VAR 0 4
66389: PUSH
66390: FOR_IN
66391: IFFALSE 66462
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
66393: LD_VAR 0 3
66397: PPUSH
66398: CALL_OW 310
66402: PPUSH
66403: CALL_OW 266
66407: PUSH
66408: LD_INT 5
66410: EQUAL
66411: PUSH
66412: LD_VAR 0 3
66416: PPUSH
66417: CALL_OW 257
66421: PUSH
66422: LD_INT 1
66424: EQUAL
66425: AND
66426: PUSH
66427: LD_VAR 0 3
66431: PPUSH
66432: CALL_OW 459
66436: NOT
66437: AND
66438: PUSH
66439: LD_VAR 0 7
66443: AND
66444: IFFALSE 66460
// ComChangeProfession ( j , class ) ;
66446: LD_VAR 0 3
66450: PPUSH
66451: LD_VAR 0 7
66455: PPUSH
66456: CALL_OW 123
66460: GO 66390
66462: POP
66463: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
66464: LD_EXP 89
66468: PUSH
66469: LD_VAR 0 2
66473: ARRAY
66474: PUSH
66475: LD_EXP 88
66479: PUSH
66480: LD_VAR 0 2
66484: ARRAY
66485: NOT
66486: AND
66487: PUSH
66488: LD_EXP 66
66492: PUSH
66493: LD_VAR 0 2
66497: ARRAY
66498: PPUSH
66499: LD_INT 30
66501: PUSH
66502: LD_INT 32
66504: PUSH
66505: EMPTY
66506: LIST
66507: LIST
66508: PPUSH
66509: CALL_OW 72
66513: NOT
66514: AND
66515: PUSH
66516: LD_EXP 66
66520: PUSH
66521: LD_VAR 0 2
66525: ARRAY
66526: PPUSH
66527: LD_INT 2
66529: PUSH
66530: LD_INT 30
66532: PUSH
66533: LD_INT 4
66535: PUSH
66536: EMPTY
66537: LIST
66538: LIST
66539: PUSH
66540: LD_INT 30
66542: PUSH
66543: LD_INT 5
66545: PUSH
66546: EMPTY
66547: LIST
66548: LIST
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: LIST
66554: PPUSH
66555: CALL_OW 72
66559: NOT
66560: AND
66561: IFFALSE 66693
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66563: LD_ADDR_VAR 0 4
66567: PUSH
66568: LD_EXP 66
66572: PUSH
66573: LD_VAR 0 2
66577: ARRAY
66578: PPUSH
66579: LD_INT 2
66581: PUSH
66582: LD_INT 25
66584: PUSH
66585: LD_INT 1
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: LD_INT 25
66594: PUSH
66595: LD_INT 5
66597: PUSH
66598: EMPTY
66599: LIST
66600: LIST
66601: PUSH
66602: LD_INT 25
66604: PUSH
66605: LD_INT 8
66607: PUSH
66608: EMPTY
66609: LIST
66610: LIST
66611: PUSH
66612: LD_INT 25
66614: PUSH
66615: LD_INT 9
66617: PUSH
66618: EMPTY
66619: LIST
66620: LIST
66621: PUSH
66622: EMPTY
66623: LIST
66624: LIST
66625: LIST
66626: LIST
66627: LIST
66628: PPUSH
66629: CALL_OW 72
66633: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
66634: LD_ADDR_VAR 0 4
66638: PUSH
66639: LD_VAR 0 4
66643: PUSH
66644: LD_VAR 0 4
66648: PPUSH
66649: LD_INT 18
66651: PPUSH
66652: CALL 47109 0 2
66656: DIFF
66657: ST_TO_ADDR
// if tmp then
66658: LD_VAR 0 4
66662: IFFALSE 66693
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
66664: LD_VAR 0 2
66668: PPUSH
66669: LD_VAR 0 4
66673: PPUSH
66674: LD_EXP 91
66678: PUSH
66679: LD_VAR 0 2
66683: ARRAY
66684: PPUSH
66685: CALL 102446 0 3
// exit ;
66689: POP
66690: POP
66691: GO 66766
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
66693: LD_EXP 89
66697: PUSH
66698: LD_VAR 0 2
66702: ARRAY
66703: PUSH
66704: LD_EXP 88
66708: PUSH
66709: LD_VAR 0 2
66713: ARRAY
66714: AND
66715: IFFALSE 66762
// begin tmp := mc_defender [ i ] ;
66717: LD_ADDR_VAR 0 4
66721: PUSH
66722: LD_EXP 88
66726: PUSH
66727: LD_VAR 0 2
66731: ARRAY
66732: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
66733: LD_VAR 0 2
66737: PPUSH
66738: LD_VAR 0 4
66742: PPUSH
66743: LD_EXP 89
66747: PUSH
66748: LD_VAR 0 2
66752: ARRAY
66753: PPUSH
66754: CALL 103007 0 3
// exit ;
66758: POP
66759: POP
66760: GO 66766
// end ; end ;
66762: GO 66199
66764: POP
66765: POP
// end ;
66766: LD_VAR 0 1
66770: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
66771: LD_INT 0
66773: PPUSH
66774: PPUSH
66775: PPUSH
66776: PPUSH
66777: PPUSH
66778: PPUSH
66779: PPUSH
66780: PPUSH
66781: PPUSH
66782: PPUSH
66783: PPUSH
// if not mc_bases then
66784: LD_EXP 66
66788: NOT
66789: IFFALSE 66793
// exit ;
66791: GO 67880
// for i = 1 to mc_bases do
66793: LD_ADDR_VAR 0 2
66797: PUSH
66798: DOUBLE
66799: LD_INT 1
66801: DEC
66802: ST_TO_ADDR
66803: LD_EXP 66
66807: PUSH
66808: FOR_TO
66809: IFFALSE 67878
// begin tmp := mc_lab [ i ] ;
66811: LD_ADDR_VAR 0 6
66815: PUSH
66816: LD_EXP 99
66820: PUSH
66821: LD_VAR 0 2
66825: ARRAY
66826: ST_TO_ADDR
// if not tmp then
66827: LD_VAR 0 6
66831: NOT
66832: IFFALSE 66836
// continue ;
66834: GO 66808
// idle_lab := 0 ;
66836: LD_ADDR_VAR 0 11
66840: PUSH
66841: LD_INT 0
66843: ST_TO_ADDR
// for j in tmp do
66844: LD_ADDR_VAR 0 3
66848: PUSH
66849: LD_VAR 0 6
66853: PUSH
66854: FOR_IN
66855: IFFALSE 67874
// begin researching := false ;
66857: LD_ADDR_VAR 0 10
66861: PUSH
66862: LD_INT 0
66864: ST_TO_ADDR
// side := GetSide ( j ) ;
66865: LD_ADDR_VAR 0 4
66869: PUSH
66870: LD_VAR 0 3
66874: PPUSH
66875: CALL_OW 255
66879: ST_TO_ADDR
// if not mc_tech [ side ] then
66880: LD_EXP 93
66884: PUSH
66885: LD_VAR 0 4
66889: ARRAY
66890: NOT
66891: IFFALSE 66895
// continue ;
66893: GO 66854
// if BuildingStatus ( j ) = bs_idle then
66895: LD_VAR 0 3
66899: PPUSH
66900: CALL_OW 461
66904: PUSH
66905: LD_INT 2
66907: EQUAL
66908: IFFALSE 67096
// begin if idle_lab and UnitsInside ( j ) < 6 then
66910: LD_VAR 0 11
66914: PUSH
66915: LD_VAR 0 3
66919: PPUSH
66920: CALL_OW 313
66924: PUSH
66925: LD_INT 6
66927: LESS
66928: AND
66929: IFFALSE 67000
// begin tmp2 := UnitsInside ( idle_lab ) ;
66931: LD_ADDR_VAR 0 9
66935: PUSH
66936: LD_VAR 0 11
66940: PPUSH
66941: CALL_OW 313
66945: ST_TO_ADDR
// if tmp2 then
66946: LD_VAR 0 9
66950: IFFALSE 66992
// for x in tmp2 do
66952: LD_ADDR_VAR 0 7
66956: PUSH
66957: LD_VAR 0 9
66961: PUSH
66962: FOR_IN
66963: IFFALSE 66990
// begin ComExitBuilding ( x ) ;
66965: LD_VAR 0 7
66969: PPUSH
66970: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
66974: LD_VAR 0 7
66978: PPUSH
66979: LD_VAR 0 3
66983: PPUSH
66984: CALL_OW 180
// end ;
66988: GO 66962
66990: POP
66991: POP
// idle_lab := 0 ;
66992: LD_ADDR_VAR 0 11
66996: PUSH
66997: LD_INT 0
66999: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
67000: LD_ADDR_VAR 0 5
67004: PUSH
67005: LD_EXP 93
67009: PUSH
67010: LD_VAR 0 4
67014: ARRAY
67015: PUSH
67016: FOR_IN
67017: IFFALSE 67077
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
67019: LD_VAR 0 3
67023: PPUSH
67024: LD_VAR 0 5
67028: PPUSH
67029: CALL_OW 430
67033: PUSH
67034: LD_VAR 0 4
67038: PPUSH
67039: LD_VAR 0 5
67043: PPUSH
67044: CALL 14454 0 2
67048: AND
67049: IFFALSE 67075
// begin researching := true ;
67051: LD_ADDR_VAR 0 10
67055: PUSH
67056: LD_INT 1
67058: ST_TO_ADDR
// ComResearch ( j , t ) ;
67059: LD_VAR 0 3
67063: PPUSH
67064: LD_VAR 0 5
67068: PPUSH
67069: CALL_OW 124
// break ;
67073: GO 67077
// end ;
67075: GO 67016
67077: POP
67078: POP
// if not researching then
67079: LD_VAR 0 10
67083: NOT
67084: IFFALSE 67096
// idle_lab := j ;
67086: LD_ADDR_VAR 0 11
67090: PUSH
67091: LD_VAR 0 3
67095: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
67096: LD_VAR 0 3
67100: PPUSH
67101: CALL_OW 461
67105: PUSH
67106: LD_INT 10
67108: EQUAL
67109: IFFALSE 67697
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
67111: LD_EXP 95
67115: PUSH
67116: LD_VAR 0 2
67120: ARRAY
67121: NOT
67122: PUSH
67123: LD_EXP 96
67127: PUSH
67128: LD_VAR 0 2
67132: ARRAY
67133: NOT
67134: AND
67135: PUSH
67136: LD_EXP 93
67140: PUSH
67141: LD_VAR 0 4
67145: ARRAY
67146: PUSH
67147: LD_INT 1
67149: GREATER
67150: AND
67151: IFFALSE 67282
// begin ComCancel ( j ) ;
67153: LD_VAR 0 3
67157: PPUSH
67158: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
67162: LD_ADDR_EXP 93
67166: PUSH
67167: LD_EXP 93
67171: PPUSH
67172: LD_VAR 0 4
67176: PPUSH
67177: LD_EXP 93
67181: PUSH
67182: LD_VAR 0 4
67186: ARRAY
67187: PPUSH
67188: LD_EXP 93
67192: PUSH
67193: LD_VAR 0 4
67197: ARRAY
67198: PUSH
67199: LD_INT 1
67201: MINUS
67202: PPUSH
67203: LD_EXP 93
67207: PUSH
67208: LD_VAR 0 4
67212: ARRAY
67213: PPUSH
67214: LD_INT 0
67216: PPUSH
67217: CALL 17966 0 4
67221: PPUSH
67222: CALL_OW 1
67226: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
67227: LD_ADDR_EXP 93
67231: PUSH
67232: LD_EXP 93
67236: PPUSH
67237: LD_VAR 0 4
67241: PPUSH
67242: LD_EXP 93
67246: PUSH
67247: LD_VAR 0 4
67251: ARRAY
67252: PPUSH
67253: LD_EXP 93
67257: PUSH
67258: LD_VAR 0 4
67262: ARRAY
67263: PPUSH
67264: LD_INT 1
67266: PPUSH
67267: LD_INT 0
67269: PPUSH
67270: CALL 17966 0 4
67274: PPUSH
67275: CALL_OW 1
67279: ST_TO_ADDR
// continue ;
67280: GO 66854
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
67282: LD_EXP 95
67286: PUSH
67287: LD_VAR 0 2
67291: ARRAY
67292: PUSH
67293: LD_EXP 96
67297: PUSH
67298: LD_VAR 0 2
67302: ARRAY
67303: NOT
67304: AND
67305: IFFALSE 67432
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
67307: LD_ADDR_EXP 96
67311: PUSH
67312: LD_EXP 96
67316: PPUSH
67317: LD_VAR 0 2
67321: PUSH
67322: LD_EXP 96
67326: PUSH
67327: LD_VAR 0 2
67331: ARRAY
67332: PUSH
67333: LD_INT 1
67335: PLUS
67336: PUSH
67337: EMPTY
67338: LIST
67339: LIST
67340: PPUSH
67341: LD_EXP 95
67345: PUSH
67346: LD_VAR 0 2
67350: ARRAY
67351: PUSH
67352: LD_INT 1
67354: ARRAY
67355: PPUSH
67356: CALL 18548 0 3
67360: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
67361: LD_EXP 95
67365: PUSH
67366: LD_VAR 0 2
67370: ARRAY
67371: PUSH
67372: LD_INT 1
67374: ARRAY
67375: PPUSH
67376: LD_INT 112
67378: PPUSH
67379: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
67383: LD_ADDR_VAR 0 9
67387: PUSH
67388: LD_EXP 95
67392: PUSH
67393: LD_VAR 0 2
67397: ARRAY
67398: PPUSH
67399: LD_INT 1
67401: PPUSH
67402: CALL_OW 3
67406: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
67407: LD_ADDR_EXP 95
67411: PUSH
67412: LD_EXP 95
67416: PPUSH
67417: LD_VAR 0 2
67421: PPUSH
67422: LD_VAR 0 9
67426: PPUSH
67427: CALL_OW 1
67431: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
67432: LD_EXP 95
67436: PUSH
67437: LD_VAR 0 2
67441: ARRAY
67442: PUSH
67443: LD_EXP 96
67447: PUSH
67448: LD_VAR 0 2
67452: ARRAY
67453: AND
67454: PUSH
67455: LD_EXP 96
67459: PUSH
67460: LD_VAR 0 2
67464: ARRAY
67465: PUSH
67466: LD_INT 1
67468: ARRAY
67469: PPUSH
67470: CALL_OW 310
67474: NOT
67475: AND
67476: PUSH
67477: LD_VAR 0 3
67481: PPUSH
67482: CALL_OW 313
67486: PUSH
67487: LD_INT 6
67489: EQUAL
67490: AND
67491: IFFALSE 67547
// begin tmp2 := UnitsInside ( j ) ;
67493: LD_ADDR_VAR 0 9
67497: PUSH
67498: LD_VAR 0 3
67502: PPUSH
67503: CALL_OW 313
67507: ST_TO_ADDR
// if tmp2 = 6 then
67508: LD_VAR 0 9
67512: PUSH
67513: LD_INT 6
67515: EQUAL
67516: IFFALSE 67547
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
67518: LD_VAR 0 9
67522: PUSH
67523: LD_INT 1
67525: ARRAY
67526: PPUSH
67527: LD_INT 112
67529: PPUSH
67530: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
67534: LD_VAR 0 9
67538: PUSH
67539: LD_INT 1
67541: ARRAY
67542: PPUSH
67543: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
67547: LD_EXP 96
67551: PUSH
67552: LD_VAR 0 2
67556: ARRAY
67557: PUSH
67558: LD_EXP 96
67562: PUSH
67563: LD_VAR 0 2
67567: ARRAY
67568: PUSH
67569: LD_INT 1
67571: ARRAY
67572: PPUSH
67573: CALL_OW 314
67577: NOT
67578: AND
67579: PUSH
67580: LD_EXP 96
67584: PUSH
67585: LD_VAR 0 2
67589: ARRAY
67590: PUSH
67591: LD_INT 1
67593: ARRAY
67594: PPUSH
67595: CALL_OW 310
67599: NOT
67600: AND
67601: IFFALSE 67627
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
67603: LD_EXP 96
67607: PUSH
67608: LD_VAR 0 2
67612: ARRAY
67613: PUSH
67614: LD_INT 1
67616: ARRAY
67617: PPUSH
67618: LD_VAR 0 3
67622: PPUSH
67623: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
67627: LD_EXP 96
67631: PUSH
67632: LD_VAR 0 2
67636: ARRAY
67637: PUSH
67638: LD_INT 1
67640: ARRAY
67641: PPUSH
67642: CALL_OW 310
67646: PUSH
67647: LD_EXP 96
67651: PUSH
67652: LD_VAR 0 2
67656: ARRAY
67657: PUSH
67658: LD_INT 1
67660: ARRAY
67661: PPUSH
67662: CALL_OW 310
67666: PPUSH
67667: CALL_OW 461
67671: PUSH
67672: LD_INT 3
67674: NONEQUAL
67675: AND
67676: IFFALSE 67697
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
67678: LD_EXP 96
67682: PUSH
67683: LD_VAR 0 2
67687: ARRAY
67688: PUSH
67689: LD_INT 1
67691: ARRAY
67692: PPUSH
67693: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
67697: LD_VAR 0 3
67701: PPUSH
67702: CALL_OW 461
67706: PUSH
67707: LD_INT 6
67709: EQUAL
67710: PUSH
67711: LD_VAR 0 6
67715: PUSH
67716: LD_INT 1
67718: GREATER
67719: AND
67720: IFFALSE 67872
// begin sci := [ ] ;
67722: LD_ADDR_VAR 0 8
67726: PUSH
67727: EMPTY
67728: ST_TO_ADDR
// for x in ( tmp diff j ) do
67729: LD_ADDR_VAR 0 7
67733: PUSH
67734: LD_VAR 0 6
67738: PUSH
67739: LD_VAR 0 3
67743: DIFF
67744: PUSH
67745: FOR_IN
67746: IFFALSE 67798
// begin if sci = 6 then
67748: LD_VAR 0 8
67752: PUSH
67753: LD_INT 6
67755: EQUAL
67756: IFFALSE 67760
// break ;
67758: GO 67798
// if BuildingStatus ( x ) = bs_idle then
67760: LD_VAR 0 7
67764: PPUSH
67765: CALL_OW 461
67769: PUSH
67770: LD_INT 2
67772: EQUAL
67773: IFFALSE 67796
// sci := sci ^ UnitsInside ( x ) ;
67775: LD_ADDR_VAR 0 8
67779: PUSH
67780: LD_VAR 0 8
67784: PUSH
67785: LD_VAR 0 7
67789: PPUSH
67790: CALL_OW 313
67794: ADD
67795: ST_TO_ADDR
// end ;
67796: GO 67745
67798: POP
67799: POP
// if not sci then
67800: LD_VAR 0 8
67804: NOT
67805: IFFALSE 67809
// continue ;
67807: GO 66854
// for x in sci do
67809: LD_ADDR_VAR 0 7
67813: PUSH
67814: LD_VAR 0 8
67818: PUSH
67819: FOR_IN
67820: IFFALSE 67870
// if IsInUnit ( x ) and not HasTask ( x ) then
67822: LD_VAR 0 7
67826: PPUSH
67827: CALL_OW 310
67831: PUSH
67832: LD_VAR 0 7
67836: PPUSH
67837: CALL_OW 314
67841: NOT
67842: AND
67843: IFFALSE 67868
// begin ComExitBuilding ( x ) ;
67845: LD_VAR 0 7
67849: PPUSH
67850: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67854: LD_VAR 0 7
67858: PPUSH
67859: LD_VAR 0 3
67863: PPUSH
67864: CALL_OW 180
// end ;
67868: GO 67819
67870: POP
67871: POP
// end ; end ;
67872: GO 66854
67874: POP
67875: POP
// end ;
67876: GO 66808
67878: POP
67879: POP
// end ;
67880: LD_VAR 0 1
67884: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
67885: LD_INT 0
67887: PPUSH
67888: PPUSH
// if not mc_bases then
67889: LD_EXP 66
67893: NOT
67894: IFFALSE 67898
// exit ;
67896: GO 67979
// for i = 1 to mc_bases do
67898: LD_ADDR_VAR 0 2
67902: PUSH
67903: DOUBLE
67904: LD_INT 1
67906: DEC
67907: ST_TO_ADDR
67908: LD_EXP 66
67912: PUSH
67913: FOR_TO
67914: IFFALSE 67977
// if mc_mines [ i ] and mc_miners [ i ] then
67916: LD_EXP 79
67920: PUSH
67921: LD_VAR 0 2
67925: ARRAY
67926: PUSH
67927: LD_EXP 80
67931: PUSH
67932: LD_VAR 0 2
67936: ARRAY
67937: AND
67938: IFFALSE 67975
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
67940: LD_EXP 80
67944: PUSH
67945: LD_VAR 0 2
67949: ARRAY
67950: PUSH
67951: LD_INT 1
67953: ARRAY
67954: PPUSH
67955: CALL_OW 255
67959: PPUSH
67960: LD_EXP 79
67964: PUSH
67965: LD_VAR 0 2
67969: ARRAY
67970: PPUSH
67971: CALL 15537 0 2
67975: GO 67913
67977: POP
67978: POP
// end ;
67979: LD_VAR 0 1
67983: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
67984: LD_INT 0
67986: PPUSH
67987: PPUSH
67988: PPUSH
67989: PPUSH
67990: PPUSH
67991: PPUSH
67992: PPUSH
67993: PPUSH
// if not mc_bases or not mc_parking then
67994: LD_EXP 66
67998: NOT
67999: PUSH
68000: LD_EXP 90
68004: NOT
68005: OR
68006: IFFALSE 68010
// exit ;
68008: GO 68709
// for i = 1 to mc_bases do
68010: LD_ADDR_VAR 0 2
68014: PUSH
68015: DOUBLE
68016: LD_INT 1
68018: DEC
68019: ST_TO_ADDR
68020: LD_EXP 66
68024: PUSH
68025: FOR_TO
68026: IFFALSE 68707
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
68028: LD_EXP 66
68032: PUSH
68033: LD_VAR 0 2
68037: ARRAY
68038: NOT
68039: PUSH
68040: LD_EXP 90
68044: PUSH
68045: LD_VAR 0 2
68049: ARRAY
68050: NOT
68051: OR
68052: IFFALSE 68056
// continue ;
68054: GO 68025
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68056: LD_ADDR_VAR 0 5
68060: PUSH
68061: LD_EXP 66
68065: PUSH
68066: LD_VAR 0 2
68070: ARRAY
68071: PUSH
68072: LD_INT 1
68074: ARRAY
68075: PPUSH
68076: CALL_OW 255
68080: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68081: LD_ADDR_VAR 0 6
68085: PUSH
68086: LD_EXP 66
68090: PUSH
68091: LD_VAR 0 2
68095: ARRAY
68096: PPUSH
68097: LD_INT 30
68099: PUSH
68100: LD_INT 3
68102: PUSH
68103: EMPTY
68104: LIST
68105: LIST
68106: PPUSH
68107: CALL_OW 72
68111: ST_TO_ADDR
// if not fac then
68112: LD_VAR 0 6
68116: NOT
68117: IFFALSE 68168
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68119: LD_ADDR_VAR 0 6
68123: PUSH
68124: LD_EXP 66
68128: PUSH
68129: LD_VAR 0 2
68133: ARRAY
68134: PPUSH
68135: LD_INT 2
68137: PUSH
68138: LD_INT 30
68140: PUSH
68141: LD_INT 0
68143: PUSH
68144: EMPTY
68145: LIST
68146: LIST
68147: PUSH
68148: LD_INT 30
68150: PUSH
68151: LD_INT 1
68153: PUSH
68154: EMPTY
68155: LIST
68156: LIST
68157: PUSH
68158: EMPTY
68159: LIST
68160: LIST
68161: LIST
68162: PPUSH
68163: CALL_OW 72
68167: ST_TO_ADDR
// if not fac then
68168: LD_VAR 0 6
68172: NOT
68173: IFFALSE 68177
// continue ;
68175: GO 68025
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68177: LD_ADDR_VAR 0 7
68181: PUSH
68182: LD_EXP 90
68186: PUSH
68187: LD_VAR 0 2
68191: ARRAY
68192: PPUSH
68193: LD_INT 22
68195: PUSH
68196: LD_VAR 0 5
68200: PUSH
68201: EMPTY
68202: LIST
68203: LIST
68204: PUSH
68205: LD_INT 21
68207: PUSH
68208: LD_INT 2
68210: PUSH
68211: EMPTY
68212: LIST
68213: LIST
68214: PUSH
68215: LD_INT 3
68217: PUSH
68218: LD_INT 24
68220: PUSH
68221: LD_INT 1000
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PUSH
68232: EMPTY
68233: LIST
68234: LIST
68235: LIST
68236: PPUSH
68237: CALL_OW 70
68241: ST_TO_ADDR
// for j in fac do
68242: LD_ADDR_VAR 0 3
68246: PUSH
68247: LD_VAR 0 6
68251: PUSH
68252: FOR_IN
68253: IFFALSE 68334
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68255: LD_ADDR_VAR 0 7
68259: PUSH
68260: LD_VAR 0 7
68264: PUSH
68265: LD_INT 22
68267: PUSH
68268: LD_VAR 0 5
68272: PUSH
68273: EMPTY
68274: LIST
68275: LIST
68276: PUSH
68277: LD_INT 91
68279: PUSH
68280: LD_VAR 0 3
68284: PUSH
68285: LD_INT 15
68287: PUSH
68288: EMPTY
68289: LIST
68290: LIST
68291: LIST
68292: PUSH
68293: LD_INT 21
68295: PUSH
68296: LD_INT 2
68298: PUSH
68299: EMPTY
68300: LIST
68301: LIST
68302: PUSH
68303: LD_INT 3
68305: PUSH
68306: LD_INT 24
68308: PUSH
68309: LD_INT 1000
68311: PUSH
68312: EMPTY
68313: LIST
68314: LIST
68315: PUSH
68316: EMPTY
68317: LIST
68318: LIST
68319: PUSH
68320: EMPTY
68321: LIST
68322: LIST
68323: LIST
68324: LIST
68325: PPUSH
68326: CALL_OW 69
68330: UNION
68331: ST_TO_ADDR
68332: GO 68252
68334: POP
68335: POP
// if not vehs then
68336: LD_VAR 0 7
68340: NOT
68341: IFFALSE 68367
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
68343: LD_ADDR_EXP 78
68347: PUSH
68348: LD_EXP 78
68352: PPUSH
68353: LD_VAR 0 2
68357: PPUSH
68358: EMPTY
68359: PPUSH
68360: CALL_OW 1
68364: ST_TO_ADDR
// continue ;
68365: GO 68025
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68367: LD_ADDR_VAR 0 8
68371: PUSH
68372: LD_EXP 66
68376: PUSH
68377: LD_VAR 0 2
68381: ARRAY
68382: PPUSH
68383: LD_INT 30
68385: PUSH
68386: LD_INT 3
68388: PUSH
68389: EMPTY
68390: LIST
68391: LIST
68392: PPUSH
68393: CALL_OW 72
68397: ST_TO_ADDR
// if tmp then
68398: LD_VAR 0 8
68402: IFFALSE 68505
// begin for j in tmp do
68404: LD_ADDR_VAR 0 3
68408: PUSH
68409: LD_VAR 0 8
68413: PUSH
68414: FOR_IN
68415: IFFALSE 68503
// for k in UnitsInside ( j ) do
68417: LD_ADDR_VAR 0 4
68421: PUSH
68422: LD_VAR 0 3
68426: PPUSH
68427: CALL_OW 313
68431: PUSH
68432: FOR_IN
68433: IFFALSE 68499
// if k then
68435: LD_VAR 0 4
68439: IFFALSE 68497
// if not k in mc_repair_vehicle [ i ] then
68441: LD_VAR 0 4
68445: PUSH
68446: LD_EXP 78
68450: PUSH
68451: LD_VAR 0 2
68455: ARRAY
68456: IN
68457: NOT
68458: IFFALSE 68497
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
68460: LD_ADDR_EXP 78
68464: PUSH
68465: LD_EXP 78
68469: PPUSH
68470: LD_VAR 0 2
68474: PPUSH
68475: LD_EXP 78
68479: PUSH
68480: LD_VAR 0 2
68484: ARRAY
68485: PUSH
68486: LD_VAR 0 4
68490: UNION
68491: PPUSH
68492: CALL_OW 1
68496: ST_TO_ADDR
68497: GO 68432
68499: POP
68500: POP
68501: GO 68414
68503: POP
68504: POP
// end ; if not mc_repair_vehicle [ i ] then
68505: LD_EXP 78
68509: PUSH
68510: LD_VAR 0 2
68514: ARRAY
68515: NOT
68516: IFFALSE 68520
// continue ;
68518: GO 68025
// for j in mc_repair_vehicle [ i ] do
68520: LD_ADDR_VAR 0 3
68524: PUSH
68525: LD_EXP 78
68529: PUSH
68530: LD_VAR 0 2
68534: ARRAY
68535: PUSH
68536: FOR_IN
68537: IFFALSE 68703
// begin if GetClass ( j ) <> 3 then
68539: LD_VAR 0 3
68543: PPUSH
68544: CALL_OW 257
68548: PUSH
68549: LD_INT 3
68551: NONEQUAL
68552: IFFALSE 68593
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
68554: LD_ADDR_EXP 78
68558: PUSH
68559: LD_EXP 78
68563: PPUSH
68564: LD_VAR 0 2
68568: PPUSH
68569: LD_EXP 78
68573: PUSH
68574: LD_VAR 0 2
68578: ARRAY
68579: PUSH
68580: LD_VAR 0 3
68584: DIFF
68585: PPUSH
68586: CALL_OW 1
68590: ST_TO_ADDR
// continue ;
68591: GO 68536
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
68593: LD_VAR 0 3
68597: PPUSH
68598: CALL_OW 311
68602: NOT
68603: PUSH
68604: LD_VAR 0 3
68608: PUSH
68609: LD_EXP 69
68613: PUSH
68614: LD_VAR 0 2
68618: ARRAY
68619: PUSH
68620: LD_INT 1
68622: ARRAY
68623: IN
68624: NOT
68625: AND
68626: PUSH
68627: LD_VAR 0 3
68631: PUSH
68632: LD_EXP 69
68636: PUSH
68637: LD_VAR 0 2
68641: ARRAY
68642: PUSH
68643: LD_INT 2
68645: ARRAY
68646: IN
68647: NOT
68648: AND
68649: IFFALSE 68701
// begin if IsInUnit ( j ) then
68651: LD_VAR 0 3
68655: PPUSH
68656: CALL_OW 310
68660: IFFALSE 68671
// ComExitBuilding ( j ) ;
68662: LD_VAR 0 3
68666: PPUSH
68667: CALL_OW 122
// if not HasTask ( j ) then
68671: LD_VAR 0 3
68675: PPUSH
68676: CALL_OW 314
68680: NOT
68681: IFFALSE 68701
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
68683: LD_VAR 0 3
68687: PPUSH
68688: LD_VAR 0 7
68692: PUSH
68693: LD_INT 1
68695: ARRAY
68696: PPUSH
68697: CALL_OW 189
// end ; end ;
68701: GO 68536
68703: POP
68704: POP
// end ;
68705: GO 68025
68707: POP
68708: POP
// end ;
68709: LD_VAR 0 1
68713: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
68714: LD_INT 0
68716: PPUSH
68717: PPUSH
68718: PPUSH
68719: PPUSH
68720: PPUSH
68721: PPUSH
68722: PPUSH
68723: PPUSH
68724: PPUSH
68725: PPUSH
68726: PPUSH
// if not mc_bases then
68727: LD_EXP 66
68731: NOT
68732: IFFALSE 68736
// exit ;
68734: GO 69538
// for i = 1 to mc_bases do
68736: LD_ADDR_VAR 0 2
68740: PUSH
68741: DOUBLE
68742: LD_INT 1
68744: DEC
68745: ST_TO_ADDR
68746: LD_EXP 66
68750: PUSH
68751: FOR_TO
68752: IFFALSE 69536
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
68754: LD_EXP 94
68758: PUSH
68759: LD_VAR 0 2
68763: ARRAY
68764: NOT
68765: PUSH
68766: LD_EXP 69
68770: PUSH
68771: LD_VAR 0 2
68775: ARRAY
68776: PUSH
68777: LD_INT 1
68779: ARRAY
68780: OR
68781: PUSH
68782: LD_EXP 69
68786: PUSH
68787: LD_VAR 0 2
68791: ARRAY
68792: PUSH
68793: LD_INT 2
68795: ARRAY
68796: OR
68797: PUSH
68798: LD_EXP 92
68802: PUSH
68803: LD_VAR 0 2
68807: ARRAY
68808: PPUSH
68809: LD_INT 1
68811: PPUSH
68812: CALL_OW 325
68816: NOT
68817: OR
68818: PUSH
68819: LD_EXP 89
68823: PUSH
68824: LD_VAR 0 2
68828: ARRAY
68829: OR
68830: IFFALSE 68834
// continue ;
68832: GO 68751
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
68834: LD_ADDR_VAR 0 8
68838: PUSH
68839: LD_EXP 66
68843: PUSH
68844: LD_VAR 0 2
68848: ARRAY
68849: PPUSH
68850: LD_INT 25
68852: PUSH
68853: LD_INT 4
68855: PUSH
68856: EMPTY
68857: LIST
68858: LIST
68859: PUSH
68860: LD_INT 50
68862: PUSH
68863: EMPTY
68864: LIST
68865: PUSH
68866: LD_INT 3
68868: PUSH
68869: LD_INT 60
68871: PUSH
68872: EMPTY
68873: LIST
68874: PUSH
68875: EMPTY
68876: LIST
68877: LIST
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: LIST
68883: PPUSH
68884: CALL_OW 72
68888: PUSH
68889: LD_EXP 70
68893: PUSH
68894: LD_VAR 0 2
68898: ARRAY
68899: DIFF
68900: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68901: LD_ADDR_VAR 0 9
68905: PUSH
68906: LD_EXP 66
68910: PUSH
68911: LD_VAR 0 2
68915: ARRAY
68916: PPUSH
68917: LD_INT 2
68919: PUSH
68920: LD_INT 30
68922: PUSH
68923: LD_INT 0
68925: PUSH
68926: EMPTY
68927: LIST
68928: LIST
68929: PUSH
68930: LD_INT 30
68932: PUSH
68933: LD_INT 1
68935: PUSH
68936: EMPTY
68937: LIST
68938: LIST
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: LIST
68944: PPUSH
68945: CALL_OW 72
68949: ST_TO_ADDR
// if not tmp or not dep then
68950: LD_VAR 0 8
68954: NOT
68955: PUSH
68956: LD_VAR 0 9
68960: NOT
68961: OR
68962: IFFALSE 68966
// continue ;
68964: GO 68751
// side := GetSide ( tmp [ 1 ] ) ;
68966: LD_ADDR_VAR 0 11
68970: PUSH
68971: LD_VAR 0 8
68975: PUSH
68976: LD_INT 1
68978: ARRAY
68979: PPUSH
68980: CALL_OW 255
68984: ST_TO_ADDR
// dep := dep [ 1 ] ;
68985: LD_ADDR_VAR 0 9
68989: PUSH
68990: LD_VAR 0 9
68994: PUSH
68995: LD_INT 1
68997: ARRAY
68998: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
68999: LD_ADDR_VAR 0 7
69003: PUSH
69004: LD_EXP 94
69008: PUSH
69009: LD_VAR 0 2
69013: ARRAY
69014: PPUSH
69015: LD_INT 22
69017: PUSH
69018: LD_INT 0
69020: PUSH
69021: EMPTY
69022: LIST
69023: LIST
69024: PUSH
69025: LD_INT 25
69027: PUSH
69028: LD_INT 12
69030: PUSH
69031: EMPTY
69032: LIST
69033: LIST
69034: PUSH
69035: EMPTY
69036: LIST
69037: LIST
69038: PPUSH
69039: CALL_OW 70
69043: PUSH
69044: LD_INT 22
69046: PUSH
69047: LD_INT 0
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: PUSH
69054: LD_INT 25
69056: PUSH
69057: LD_INT 12
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: PUSH
69064: LD_INT 91
69066: PUSH
69067: LD_VAR 0 9
69071: PUSH
69072: LD_INT 20
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: LIST
69079: PUSH
69080: EMPTY
69081: LIST
69082: LIST
69083: LIST
69084: PPUSH
69085: CALL_OW 69
69089: UNION
69090: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
69091: LD_ADDR_VAR 0 10
69095: PUSH
69096: LD_EXP 94
69100: PUSH
69101: LD_VAR 0 2
69105: ARRAY
69106: PPUSH
69107: LD_INT 81
69109: PUSH
69110: LD_VAR 0 11
69114: PUSH
69115: EMPTY
69116: LIST
69117: LIST
69118: PPUSH
69119: CALL_OW 70
69123: ST_TO_ADDR
// if not apes or danger_at_area then
69124: LD_VAR 0 7
69128: NOT
69129: PUSH
69130: LD_VAR 0 10
69134: OR
69135: IFFALSE 69185
// begin if mc_taming [ i ] then
69137: LD_EXP 97
69141: PUSH
69142: LD_VAR 0 2
69146: ARRAY
69147: IFFALSE 69183
// begin MC_Reset ( i , 121 ) ;
69149: LD_VAR 0 2
69153: PPUSH
69154: LD_INT 121
69156: PPUSH
69157: CALL 54636 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
69161: LD_ADDR_EXP 97
69165: PUSH
69166: LD_EXP 97
69170: PPUSH
69171: LD_VAR 0 2
69175: PPUSH
69176: EMPTY
69177: PPUSH
69178: CALL_OW 1
69182: ST_TO_ADDR
// end ; continue ;
69183: GO 68751
// end ; for j in tmp do
69185: LD_ADDR_VAR 0 3
69189: PUSH
69190: LD_VAR 0 8
69194: PUSH
69195: FOR_IN
69196: IFFALSE 69532
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
69198: LD_VAR 0 3
69202: PUSH
69203: LD_EXP 97
69207: PUSH
69208: LD_VAR 0 2
69212: ARRAY
69213: IN
69214: NOT
69215: PUSH
69216: LD_EXP 97
69220: PUSH
69221: LD_VAR 0 2
69225: ARRAY
69226: PUSH
69227: LD_INT 3
69229: LESS
69230: AND
69231: IFFALSE 69289
// begin SetTag ( j , 121 ) ;
69233: LD_VAR 0 3
69237: PPUSH
69238: LD_INT 121
69240: PPUSH
69241: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
69245: LD_ADDR_EXP 97
69249: PUSH
69250: LD_EXP 97
69254: PPUSH
69255: LD_VAR 0 2
69259: PUSH
69260: LD_EXP 97
69264: PUSH
69265: LD_VAR 0 2
69269: ARRAY
69270: PUSH
69271: LD_INT 1
69273: PLUS
69274: PUSH
69275: EMPTY
69276: LIST
69277: LIST
69278: PPUSH
69279: LD_VAR 0 3
69283: PPUSH
69284: CALL 18548 0 3
69288: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
69289: LD_VAR 0 3
69293: PUSH
69294: LD_EXP 97
69298: PUSH
69299: LD_VAR 0 2
69303: ARRAY
69304: IN
69305: IFFALSE 69530
// begin if GetClass ( j ) <> 4 then
69307: LD_VAR 0 3
69311: PPUSH
69312: CALL_OW 257
69316: PUSH
69317: LD_INT 4
69319: NONEQUAL
69320: IFFALSE 69373
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
69322: LD_ADDR_EXP 97
69326: PUSH
69327: LD_EXP 97
69331: PPUSH
69332: LD_VAR 0 2
69336: PPUSH
69337: LD_EXP 97
69341: PUSH
69342: LD_VAR 0 2
69346: ARRAY
69347: PUSH
69348: LD_VAR 0 3
69352: DIFF
69353: PPUSH
69354: CALL_OW 1
69358: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69359: LD_VAR 0 3
69363: PPUSH
69364: LD_INT 0
69366: PPUSH
69367: CALL_OW 109
// continue ;
69371: GO 69195
// end ; if IsInUnit ( j ) then
69373: LD_VAR 0 3
69377: PPUSH
69378: CALL_OW 310
69382: IFFALSE 69393
// ComExitBuilding ( j ) ;
69384: LD_VAR 0 3
69388: PPUSH
69389: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
69393: LD_ADDR_VAR 0 6
69397: PUSH
69398: LD_VAR 0 7
69402: PPUSH
69403: LD_VAR 0 3
69407: PPUSH
69408: CALL_OW 74
69412: ST_TO_ADDR
// if not ape then
69413: LD_VAR 0 6
69417: NOT
69418: IFFALSE 69422
// break ;
69420: GO 69532
// x := GetX ( ape ) ;
69422: LD_ADDR_VAR 0 4
69426: PUSH
69427: LD_VAR 0 6
69431: PPUSH
69432: CALL_OW 250
69436: ST_TO_ADDR
// y := GetY ( ape ) ;
69437: LD_ADDR_VAR 0 5
69441: PUSH
69442: LD_VAR 0 6
69446: PPUSH
69447: CALL_OW 251
69451: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
69452: LD_VAR 0 4
69456: PPUSH
69457: LD_VAR 0 5
69461: PPUSH
69462: CALL_OW 488
69466: NOT
69467: PUSH
69468: LD_VAR 0 11
69472: PPUSH
69473: LD_VAR 0 4
69477: PPUSH
69478: LD_VAR 0 5
69482: PPUSH
69483: LD_INT 20
69485: PPUSH
69486: CALL 19444 0 4
69490: PUSH
69491: LD_INT 4
69493: ARRAY
69494: OR
69495: IFFALSE 69499
// break ;
69497: GO 69532
// if not HasTask ( j ) then
69499: LD_VAR 0 3
69503: PPUSH
69504: CALL_OW 314
69508: NOT
69509: IFFALSE 69530
// ComTameXY ( j , x , y ) ;
69511: LD_VAR 0 3
69515: PPUSH
69516: LD_VAR 0 4
69520: PPUSH
69521: LD_VAR 0 5
69525: PPUSH
69526: CALL_OW 131
// end ; end ;
69530: GO 69195
69532: POP
69533: POP
// end ;
69534: GO 68751
69536: POP
69537: POP
// end ;
69538: LD_VAR 0 1
69542: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
69543: LD_INT 0
69545: PPUSH
69546: PPUSH
69547: PPUSH
69548: PPUSH
69549: PPUSH
69550: PPUSH
69551: PPUSH
69552: PPUSH
// if not mc_bases then
69553: LD_EXP 66
69557: NOT
69558: IFFALSE 69562
// exit ;
69560: GO 70188
// for i = 1 to mc_bases do
69562: LD_ADDR_VAR 0 2
69566: PUSH
69567: DOUBLE
69568: LD_INT 1
69570: DEC
69571: ST_TO_ADDR
69572: LD_EXP 66
69576: PUSH
69577: FOR_TO
69578: IFFALSE 70186
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
69580: LD_EXP 95
69584: PUSH
69585: LD_VAR 0 2
69589: ARRAY
69590: NOT
69591: PUSH
69592: LD_EXP 95
69596: PUSH
69597: LD_VAR 0 2
69601: ARRAY
69602: PPUSH
69603: LD_INT 25
69605: PUSH
69606: LD_INT 12
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PPUSH
69613: CALL_OW 72
69617: NOT
69618: OR
69619: IFFALSE 69623
// continue ;
69621: GO 69577
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
69623: LD_ADDR_VAR 0 5
69627: PUSH
69628: LD_EXP 95
69632: PUSH
69633: LD_VAR 0 2
69637: ARRAY
69638: PUSH
69639: LD_INT 1
69641: ARRAY
69642: PPUSH
69643: CALL_OW 255
69647: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
69648: LD_VAR 0 5
69652: PPUSH
69653: LD_INT 2
69655: PPUSH
69656: CALL_OW 325
69660: IFFALSE 69913
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69662: LD_ADDR_VAR 0 4
69666: PUSH
69667: LD_EXP 95
69671: PUSH
69672: LD_VAR 0 2
69676: ARRAY
69677: PPUSH
69678: LD_INT 25
69680: PUSH
69681: LD_INT 16
69683: PUSH
69684: EMPTY
69685: LIST
69686: LIST
69687: PPUSH
69688: CALL_OW 72
69692: ST_TO_ADDR
// if tmp < 6 then
69693: LD_VAR 0 4
69697: PUSH
69698: LD_INT 6
69700: LESS
69701: IFFALSE 69913
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69703: LD_ADDR_VAR 0 6
69707: PUSH
69708: LD_EXP 66
69712: PUSH
69713: LD_VAR 0 2
69717: ARRAY
69718: PPUSH
69719: LD_INT 2
69721: PUSH
69722: LD_INT 30
69724: PUSH
69725: LD_INT 0
69727: PUSH
69728: EMPTY
69729: LIST
69730: LIST
69731: PUSH
69732: LD_INT 30
69734: PUSH
69735: LD_INT 1
69737: PUSH
69738: EMPTY
69739: LIST
69740: LIST
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: LIST
69746: PPUSH
69747: CALL_OW 72
69751: ST_TO_ADDR
// if depot then
69752: LD_VAR 0 6
69756: IFFALSE 69913
// begin selected := 0 ;
69758: LD_ADDR_VAR 0 7
69762: PUSH
69763: LD_INT 0
69765: ST_TO_ADDR
// for j in depot do
69766: LD_ADDR_VAR 0 3
69770: PUSH
69771: LD_VAR 0 6
69775: PUSH
69776: FOR_IN
69777: IFFALSE 69808
// begin if UnitsInside ( j ) < 6 then
69779: LD_VAR 0 3
69783: PPUSH
69784: CALL_OW 313
69788: PUSH
69789: LD_INT 6
69791: LESS
69792: IFFALSE 69806
// begin selected := j ;
69794: LD_ADDR_VAR 0 7
69798: PUSH
69799: LD_VAR 0 3
69803: ST_TO_ADDR
// break ;
69804: GO 69808
// end ; end ;
69806: GO 69776
69808: POP
69809: POP
// if selected then
69810: LD_VAR 0 7
69814: IFFALSE 69913
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69816: LD_ADDR_VAR 0 3
69820: PUSH
69821: LD_EXP 95
69825: PUSH
69826: LD_VAR 0 2
69830: ARRAY
69831: PPUSH
69832: LD_INT 25
69834: PUSH
69835: LD_INT 12
69837: PUSH
69838: EMPTY
69839: LIST
69840: LIST
69841: PPUSH
69842: CALL_OW 72
69846: PUSH
69847: FOR_IN
69848: IFFALSE 69911
// if not HasTask ( j ) then
69850: LD_VAR 0 3
69854: PPUSH
69855: CALL_OW 314
69859: NOT
69860: IFFALSE 69909
// begin if not IsInUnit ( j ) then
69862: LD_VAR 0 3
69866: PPUSH
69867: CALL_OW 310
69871: NOT
69872: IFFALSE 69888
// ComEnterUnit ( j , selected ) ;
69874: LD_VAR 0 3
69878: PPUSH
69879: LD_VAR 0 7
69883: PPUSH
69884: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
69888: LD_VAR 0 3
69892: PPUSH
69893: LD_INT 16
69895: PPUSH
69896: CALL_OW 183
// AddComExitBuilding ( j ) ;
69900: LD_VAR 0 3
69904: PPUSH
69905: CALL_OW 182
// end ;
69909: GO 69847
69911: POP
69912: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
69913: LD_VAR 0 5
69917: PPUSH
69918: LD_INT 11
69920: PPUSH
69921: CALL_OW 325
69925: IFFALSE 70184
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69927: LD_ADDR_VAR 0 4
69931: PUSH
69932: LD_EXP 95
69936: PUSH
69937: LD_VAR 0 2
69941: ARRAY
69942: PPUSH
69943: LD_INT 25
69945: PUSH
69946: LD_INT 16
69948: PUSH
69949: EMPTY
69950: LIST
69951: LIST
69952: PPUSH
69953: CALL_OW 72
69957: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
69958: LD_VAR 0 4
69962: PUSH
69963: LD_INT 6
69965: GREATEREQUAL
69966: PUSH
69967: LD_VAR 0 5
69971: PPUSH
69972: LD_INT 2
69974: PPUSH
69975: CALL_OW 325
69979: NOT
69980: OR
69981: IFFALSE 70184
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
69983: LD_ADDR_VAR 0 8
69987: PUSH
69988: LD_EXP 66
69992: PUSH
69993: LD_VAR 0 2
69997: ARRAY
69998: PPUSH
69999: LD_INT 2
70001: PUSH
70002: LD_INT 30
70004: PUSH
70005: LD_INT 4
70007: PUSH
70008: EMPTY
70009: LIST
70010: LIST
70011: PUSH
70012: LD_INT 30
70014: PUSH
70015: LD_INT 5
70017: PUSH
70018: EMPTY
70019: LIST
70020: LIST
70021: PUSH
70022: EMPTY
70023: LIST
70024: LIST
70025: LIST
70026: PPUSH
70027: CALL_OW 72
70031: ST_TO_ADDR
// if barracks then
70032: LD_VAR 0 8
70036: IFFALSE 70184
// begin selected := 0 ;
70038: LD_ADDR_VAR 0 7
70042: PUSH
70043: LD_INT 0
70045: ST_TO_ADDR
// for j in barracks do
70046: LD_ADDR_VAR 0 3
70050: PUSH
70051: LD_VAR 0 8
70055: PUSH
70056: FOR_IN
70057: IFFALSE 70088
// begin if UnitsInside ( j ) < 6 then
70059: LD_VAR 0 3
70063: PPUSH
70064: CALL_OW 313
70068: PUSH
70069: LD_INT 6
70071: LESS
70072: IFFALSE 70086
// begin selected := j ;
70074: LD_ADDR_VAR 0 7
70078: PUSH
70079: LD_VAR 0 3
70083: ST_TO_ADDR
// break ;
70084: GO 70088
// end ; end ;
70086: GO 70056
70088: POP
70089: POP
// if selected then
70090: LD_VAR 0 7
70094: IFFALSE 70184
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70096: LD_ADDR_VAR 0 3
70100: PUSH
70101: LD_EXP 95
70105: PUSH
70106: LD_VAR 0 2
70110: ARRAY
70111: PPUSH
70112: LD_INT 25
70114: PUSH
70115: LD_INT 12
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: PPUSH
70122: CALL_OW 72
70126: PUSH
70127: FOR_IN
70128: IFFALSE 70182
// if not IsInUnit ( j ) and not HasTask ( j ) then
70130: LD_VAR 0 3
70134: PPUSH
70135: CALL_OW 310
70139: NOT
70140: PUSH
70141: LD_VAR 0 3
70145: PPUSH
70146: CALL_OW 314
70150: NOT
70151: AND
70152: IFFALSE 70180
// begin ComEnterUnit ( j , selected ) ;
70154: LD_VAR 0 3
70158: PPUSH
70159: LD_VAR 0 7
70163: PPUSH
70164: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
70168: LD_VAR 0 3
70172: PPUSH
70173: LD_INT 15
70175: PPUSH
70176: CALL_OW 183
// end ;
70180: GO 70127
70182: POP
70183: POP
// end ; end ; end ; end ; end ;
70184: GO 69577
70186: POP
70187: POP
// end ;
70188: LD_VAR 0 1
70192: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
70193: LD_INT 0
70195: PPUSH
70196: PPUSH
70197: PPUSH
70198: PPUSH
// if not mc_bases then
70199: LD_EXP 66
70203: NOT
70204: IFFALSE 70208
// exit ;
70206: GO 70386
// for i = 1 to mc_bases do
70208: LD_ADDR_VAR 0 2
70212: PUSH
70213: DOUBLE
70214: LD_INT 1
70216: DEC
70217: ST_TO_ADDR
70218: LD_EXP 66
70222: PUSH
70223: FOR_TO
70224: IFFALSE 70384
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
70226: LD_ADDR_VAR 0 4
70230: PUSH
70231: LD_EXP 66
70235: PUSH
70236: LD_VAR 0 2
70240: ARRAY
70241: PPUSH
70242: LD_INT 25
70244: PUSH
70245: LD_INT 9
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PPUSH
70252: CALL_OW 72
70256: ST_TO_ADDR
// if not tmp then
70257: LD_VAR 0 4
70261: NOT
70262: IFFALSE 70266
// continue ;
70264: GO 70223
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
70266: LD_EXP 92
70270: PUSH
70271: LD_VAR 0 2
70275: ARRAY
70276: PPUSH
70277: LD_INT 29
70279: PPUSH
70280: CALL_OW 325
70284: NOT
70285: PUSH
70286: LD_EXP 92
70290: PUSH
70291: LD_VAR 0 2
70295: ARRAY
70296: PPUSH
70297: LD_INT 28
70299: PPUSH
70300: CALL_OW 325
70304: NOT
70305: AND
70306: IFFALSE 70310
// continue ;
70308: GO 70223
// for j in tmp do
70310: LD_ADDR_VAR 0 3
70314: PUSH
70315: LD_VAR 0 4
70319: PUSH
70320: FOR_IN
70321: IFFALSE 70380
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70323: LD_VAR 0 3
70327: PUSH
70328: LD_EXP 69
70332: PUSH
70333: LD_VAR 0 2
70337: ARRAY
70338: PUSH
70339: LD_INT 1
70341: ARRAY
70342: IN
70343: NOT
70344: PUSH
70345: LD_VAR 0 3
70349: PUSH
70350: LD_EXP 69
70354: PUSH
70355: LD_VAR 0 2
70359: ARRAY
70360: PUSH
70361: LD_INT 2
70363: ARRAY
70364: IN
70365: NOT
70366: AND
70367: IFFALSE 70378
// ComSpaceTimeShoot ( j ) ;
70369: LD_VAR 0 3
70373: PPUSH
70374: CALL 14545 0 1
70378: GO 70320
70380: POP
70381: POP
// end ;
70382: GO 70223
70384: POP
70385: POP
// end ;
70386: LD_VAR 0 1
70390: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
70391: LD_INT 0
70393: PPUSH
70394: PPUSH
70395: PPUSH
70396: PPUSH
70397: PPUSH
70398: PPUSH
70399: PPUSH
70400: PPUSH
70401: PPUSH
// if not mc_bases then
70402: LD_EXP 66
70406: NOT
70407: IFFALSE 70411
// exit ;
70409: GO 71033
// for i = 1 to mc_bases do
70411: LD_ADDR_VAR 0 2
70415: PUSH
70416: DOUBLE
70417: LD_INT 1
70419: DEC
70420: ST_TO_ADDR
70421: LD_EXP 66
70425: PUSH
70426: FOR_TO
70427: IFFALSE 71031
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
70429: LD_EXP 101
70433: PUSH
70434: LD_VAR 0 2
70438: ARRAY
70439: NOT
70440: PUSH
70441: LD_INT 38
70443: PPUSH
70444: LD_EXP 92
70448: PUSH
70449: LD_VAR 0 2
70453: ARRAY
70454: PPUSH
70455: CALL_OW 321
70459: PUSH
70460: LD_INT 2
70462: NONEQUAL
70463: OR
70464: IFFALSE 70468
// continue ;
70466: GO 70426
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
70468: LD_ADDR_VAR 0 8
70472: PUSH
70473: LD_EXP 66
70477: PUSH
70478: LD_VAR 0 2
70482: ARRAY
70483: PPUSH
70484: LD_INT 30
70486: PUSH
70487: LD_INT 34
70489: PUSH
70490: EMPTY
70491: LIST
70492: LIST
70493: PPUSH
70494: CALL_OW 72
70498: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
70499: LD_ADDR_VAR 0 9
70503: PUSH
70504: LD_EXP 66
70508: PUSH
70509: LD_VAR 0 2
70513: ARRAY
70514: PPUSH
70515: LD_INT 25
70517: PUSH
70518: LD_INT 4
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PPUSH
70525: CALL_OW 72
70529: PPUSH
70530: LD_INT 0
70532: PPUSH
70533: CALL 47109 0 2
70537: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
70538: LD_VAR 0 9
70542: NOT
70543: PUSH
70544: LD_VAR 0 8
70548: NOT
70549: OR
70550: PUSH
70551: LD_EXP 66
70555: PUSH
70556: LD_VAR 0 2
70560: ARRAY
70561: PPUSH
70562: LD_INT 124
70564: PPUSH
70565: CALL 47109 0 2
70569: OR
70570: IFFALSE 70574
// continue ;
70572: GO 70426
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
70574: LD_EXP 102
70578: PUSH
70579: LD_VAR 0 2
70583: ARRAY
70584: PUSH
70585: LD_EXP 101
70589: PUSH
70590: LD_VAR 0 2
70594: ARRAY
70595: LESS
70596: PUSH
70597: LD_EXP 102
70601: PUSH
70602: LD_VAR 0 2
70606: ARRAY
70607: PUSH
70608: LD_VAR 0 8
70612: LESS
70613: AND
70614: IFFALSE 71029
// begin tmp := sci [ 1 ] ;
70616: LD_ADDR_VAR 0 7
70620: PUSH
70621: LD_VAR 0 9
70625: PUSH
70626: LD_INT 1
70628: ARRAY
70629: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
70630: LD_VAR 0 7
70634: PPUSH
70635: LD_INT 124
70637: PPUSH
70638: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
70642: LD_ADDR_VAR 0 3
70646: PUSH
70647: DOUBLE
70648: LD_EXP 101
70652: PUSH
70653: LD_VAR 0 2
70657: ARRAY
70658: INC
70659: ST_TO_ADDR
70660: LD_EXP 101
70664: PUSH
70665: LD_VAR 0 2
70669: ARRAY
70670: PUSH
70671: FOR_DOWNTO
70672: IFFALSE 71015
// begin if IsInUnit ( tmp ) then
70674: LD_VAR 0 7
70678: PPUSH
70679: CALL_OW 310
70683: IFFALSE 70694
// ComExitBuilding ( tmp ) ;
70685: LD_VAR 0 7
70689: PPUSH
70690: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
70694: LD_INT 35
70696: PPUSH
70697: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
70701: LD_VAR 0 7
70705: PPUSH
70706: CALL_OW 310
70710: NOT
70711: PUSH
70712: LD_VAR 0 7
70716: PPUSH
70717: CALL_OW 314
70721: NOT
70722: AND
70723: IFFALSE 70694
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
70725: LD_ADDR_VAR 0 6
70729: PUSH
70730: LD_VAR 0 7
70734: PPUSH
70735: CALL_OW 250
70739: PUSH
70740: LD_VAR 0 7
70744: PPUSH
70745: CALL_OW 251
70749: PUSH
70750: EMPTY
70751: LIST
70752: LIST
70753: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
70754: LD_INT 35
70756: PPUSH
70757: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
70761: LD_ADDR_VAR 0 4
70765: PUSH
70766: LD_EXP 101
70770: PUSH
70771: LD_VAR 0 2
70775: ARRAY
70776: PUSH
70777: LD_VAR 0 3
70781: ARRAY
70782: PUSH
70783: LD_INT 1
70785: ARRAY
70786: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
70787: LD_ADDR_VAR 0 5
70791: PUSH
70792: LD_EXP 101
70796: PUSH
70797: LD_VAR 0 2
70801: ARRAY
70802: PUSH
70803: LD_VAR 0 3
70807: ARRAY
70808: PUSH
70809: LD_INT 2
70811: ARRAY
70812: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
70813: LD_VAR 0 7
70817: PPUSH
70818: LD_INT 10
70820: PPUSH
70821: CALL 21141 0 2
70825: PUSH
70826: LD_INT 4
70828: ARRAY
70829: IFFALSE 70867
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
70831: LD_VAR 0 7
70835: PPUSH
70836: LD_VAR 0 6
70840: PUSH
70841: LD_INT 1
70843: ARRAY
70844: PPUSH
70845: LD_VAR 0 6
70849: PUSH
70850: LD_INT 2
70852: ARRAY
70853: PPUSH
70854: CALL_OW 111
// wait ( 0 0$10 ) ;
70858: LD_INT 350
70860: PPUSH
70861: CALL_OW 67
// end else
70865: GO 70893
// begin ComMoveXY ( tmp , x , y ) ;
70867: LD_VAR 0 7
70871: PPUSH
70872: LD_VAR 0 4
70876: PPUSH
70877: LD_VAR 0 5
70881: PPUSH
70882: CALL_OW 111
// wait ( 0 0$3 ) ;
70886: LD_INT 105
70888: PPUSH
70889: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
70893: LD_VAR 0 7
70897: PPUSH
70898: LD_VAR 0 4
70902: PPUSH
70903: LD_VAR 0 5
70907: PPUSH
70908: CALL_OW 307
70912: IFFALSE 70754
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
70914: LD_VAR 0 7
70918: PPUSH
70919: LD_VAR 0 4
70923: PPUSH
70924: LD_VAR 0 5
70928: PPUSH
70929: LD_VAR 0 8
70933: PUSH
70934: LD_VAR 0 3
70938: ARRAY
70939: PPUSH
70940: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
70944: LD_INT 35
70946: PPUSH
70947: CALL_OW 67
// until not HasTask ( tmp ) ;
70951: LD_VAR 0 7
70955: PPUSH
70956: CALL_OW 314
70960: NOT
70961: IFFALSE 70944
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
70963: LD_ADDR_EXP 102
70967: PUSH
70968: LD_EXP 102
70972: PPUSH
70973: LD_VAR 0 2
70977: PUSH
70978: LD_EXP 102
70982: PUSH
70983: LD_VAR 0 2
70987: ARRAY
70988: PUSH
70989: LD_INT 1
70991: PLUS
70992: PUSH
70993: EMPTY
70994: LIST
70995: LIST
70996: PPUSH
70997: LD_VAR 0 8
71001: PUSH
71002: LD_VAR 0 3
71006: ARRAY
71007: PPUSH
71008: CALL 18548 0 3
71012: ST_TO_ADDR
// end ;
71013: GO 70671
71015: POP
71016: POP
// MC_Reset ( i , 124 ) ;
71017: LD_VAR 0 2
71021: PPUSH
71022: LD_INT 124
71024: PPUSH
71025: CALL 54636 0 2
// end ; end ;
71029: GO 70426
71031: POP
71032: POP
// end ;
71033: LD_VAR 0 1
71037: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
71038: LD_INT 0
71040: PPUSH
71041: PPUSH
71042: PPUSH
// if not mc_bases then
71043: LD_EXP 66
71047: NOT
71048: IFFALSE 71052
// exit ;
71050: GO 71658
// for i = 1 to mc_bases do
71052: LD_ADDR_VAR 0 2
71056: PUSH
71057: DOUBLE
71058: LD_INT 1
71060: DEC
71061: ST_TO_ADDR
71062: LD_EXP 66
71066: PUSH
71067: FOR_TO
71068: IFFALSE 71656
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71070: LD_ADDR_VAR 0 3
71074: PUSH
71075: LD_EXP 66
71079: PUSH
71080: LD_VAR 0 2
71084: ARRAY
71085: PPUSH
71086: LD_INT 25
71088: PUSH
71089: LD_INT 4
71091: PUSH
71092: EMPTY
71093: LIST
71094: LIST
71095: PPUSH
71096: CALL_OW 72
71100: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
71101: LD_VAR 0 3
71105: NOT
71106: PUSH
71107: LD_EXP 103
71111: PUSH
71112: LD_VAR 0 2
71116: ARRAY
71117: NOT
71118: OR
71119: PUSH
71120: LD_EXP 66
71124: PUSH
71125: LD_VAR 0 2
71129: ARRAY
71130: PPUSH
71131: LD_INT 2
71133: PUSH
71134: LD_INT 30
71136: PUSH
71137: LD_INT 0
71139: PUSH
71140: EMPTY
71141: LIST
71142: LIST
71143: PUSH
71144: LD_INT 30
71146: PUSH
71147: LD_INT 1
71149: PUSH
71150: EMPTY
71151: LIST
71152: LIST
71153: PUSH
71154: EMPTY
71155: LIST
71156: LIST
71157: LIST
71158: PPUSH
71159: CALL_OW 72
71163: NOT
71164: OR
71165: IFFALSE 71215
// begin if mc_deposits_finder [ i ] then
71167: LD_EXP 104
71171: PUSH
71172: LD_VAR 0 2
71176: ARRAY
71177: IFFALSE 71213
// begin MC_Reset ( i , 125 ) ;
71179: LD_VAR 0 2
71183: PPUSH
71184: LD_INT 125
71186: PPUSH
71187: CALL 54636 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71191: LD_ADDR_EXP 104
71195: PUSH
71196: LD_EXP 104
71200: PPUSH
71201: LD_VAR 0 2
71205: PPUSH
71206: EMPTY
71207: PPUSH
71208: CALL_OW 1
71212: ST_TO_ADDR
// end ; continue ;
71213: GO 71067
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
71215: LD_EXP 103
71219: PUSH
71220: LD_VAR 0 2
71224: ARRAY
71225: PUSH
71226: LD_INT 1
71228: ARRAY
71229: PUSH
71230: LD_INT 3
71232: ARRAY
71233: PUSH
71234: LD_INT 1
71236: EQUAL
71237: PUSH
71238: LD_INT 20
71240: PPUSH
71241: LD_EXP 92
71245: PUSH
71246: LD_VAR 0 2
71250: ARRAY
71251: PPUSH
71252: CALL_OW 321
71256: PUSH
71257: LD_INT 2
71259: NONEQUAL
71260: AND
71261: IFFALSE 71311
// begin if mc_deposits_finder [ i ] then
71263: LD_EXP 104
71267: PUSH
71268: LD_VAR 0 2
71272: ARRAY
71273: IFFALSE 71309
// begin MC_Reset ( i , 125 ) ;
71275: LD_VAR 0 2
71279: PPUSH
71280: LD_INT 125
71282: PPUSH
71283: CALL 54636 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71287: LD_ADDR_EXP 104
71291: PUSH
71292: LD_EXP 104
71296: PPUSH
71297: LD_VAR 0 2
71301: PPUSH
71302: EMPTY
71303: PPUSH
71304: CALL_OW 1
71308: ST_TO_ADDR
// end ; continue ;
71309: GO 71067
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
71311: LD_EXP 103
71315: PUSH
71316: LD_VAR 0 2
71320: ARRAY
71321: PUSH
71322: LD_INT 1
71324: ARRAY
71325: PUSH
71326: LD_INT 1
71328: ARRAY
71329: PPUSH
71330: LD_EXP 103
71334: PUSH
71335: LD_VAR 0 2
71339: ARRAY
71340: PUSH
71341: LD_INT 1
71343: ARRAY
71344: PUSH
71345: LD_INT 2
71347: ARRAY
71348: PPUSH
71349: LD_EXP 92
71353: PUSH
71354: LD_VAR 0 2
71358: ARRAY
71359: PPUSH
71360: CALL_OW 440
71364: IFFALSE 71407
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
71366: LD_ADDR_EXP 103
71370: PUSH
71371: LD_EXP 103
71375: PPUSH
71376: LD_VAR 0 2
71380: PPUSH
71381: LD_EXP 103
71385: PUSH
71386: LD_VAR 0 2
71390: ARRAY
71391: PPUSH
71392: LD_INT 1
71394: PPUSH
71395: CALL_OW 3
71399: PPUSH
71400: CALL_OW 1
71404: ST_TO_ADDR
71405: GO 71654
// begin if not mc_deposits_finder [ i ] then
71407: LD_EXP 104
71411: PUSH
71412: LD_VAR 0 2
71416: ARRAY
71417: NOT
71418: IFFALSE 71470
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
71420: LD_ADDR_EXP 104
71424: PUSH
71425: LD_EXP 104
71429: PPUSH
71430: LD_VAR 0 2
71434: PPUSH
71435: LD_VAR 0 3
71439: PUSH
71440: LD_INT 1
71442: ARRAY
71443: PUSH
71444: EMPTY
71445: LIST
71446: PPUSH
71447: CALL_OW 1
71451: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
71452: LD_VAR 0 3
71456: PUSH
71457: LD_INT 1
71459: ARRAY
71460: PPUSH
71461: LD_INT 125
71463: PPUSH
71464: CALL_OW 109
// end else
71468: GO 71654
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
71470: LD_EXP 104
71474: PUSH
71475: LD_VAR 0 2
71479: ARRAY
71480: PUSH
71481: LD_INT 1
71483: ARRAY
71484: PPUSH
71485: CALL_OW 310
71489: IFFALSE 71512
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
71491: LD_EXP 104
71495: PUSH
71496: LD_VAR 0 2
71500: ARRAY
71501: PUSH
71502: LD_INT 1
71504: ARRAY
71505: PPUSH
71506: CALL_OW 122
71510: GO 71654
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
71512: LD_EXP 104
71516: PUSH
71517: LD_VAR 0 2
71521: ARRAY
71522: PUSH
71523: LD_INT 1
71525: ARRAY
71526: PPUSH
71527: CALL_OW 314
71531: NOT
71532: PUSH
71533: LD_EXP 104
71537: PUSH
71538: LD_VAR 0 2
71542: ARRAY
71543: PUSH
71544: LD_INT 1
71546: ARRAY
71547: PPUSH
71548: LD_EXP 103
71552: PUSH
71553: LD_VAR 0 2
71557: ARRAY
71558: PUSH
71559: LD_INT 1
71561: ARRAY
71562: PUSH
71563: LD_INT 1
71565: ARRAY
71566: PPUSH
71567: LD_EXP 103
71571: PUSH
71572: LD_VAR 0 2
71576: ARRAY
71577: PUSH
71578: LD_INT 1
71580: ARRAY
71581: PUSH
71582: LD_INT 2
71584: ARRAY
71585: PPUSH
71586: CALL_OW 297
71590: PUSH
71591: LD_INT 6
71593: GREATER
71594: AND
71595: IFFALSE 71654
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
71597: LD_EXP 104
71601: PUSH
71602: LD_VAR 0 2
71606: ARRAY
71607: PUSH
71608: LD_INT 1
71610: ARRAY
71611: PPUSH
71612: LD_EXP 103
71616: PUSH
71617: LD_VAR 0 2
71621: ARRAY
71622: PUSH
71623: LD_INT 1
71625: ARRAY
71626: PUSH
71627: LD_INT 1
71629: ARRAY
71630: PPUSH
71631: LD_EXP 103
71635: PUSH
71636: LD_VAR 0 2
71640: ARRAY
71641: PUSH
71642: LD_INT 1
71644: ARRAY
71645: PUSH
71646: LD_INT 2
71648: ARRAY
71649: PPUSH
71650: CALL_OW 111
// end ; end ; end ;
71654: GO 71067
71656: POP
71657: POP
// end ;
71658: LD_VAR 0 1
71662: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
71663: LD_INT 0
71665: PPUSH
71666: PPUSH
71667: PPUSH
71668: PPUSH
71669: PPUSH
71670: PPUSH
71671: PPUSH
71672: PPUSH
71673: PPUSH
71674: PPUSH
71675: PPUSH
// if not mc_bases then
71676: LD_EXP 66
71680: NOT
71681: IFFALSE 71685
// exit ;
71683: GO 72625
// for i = 1 to mc_bases do
71685: LD_ADDR_VAR 0 2
71689: PUSH
71690: DOUBLE
71691: LD_INT 1
71693: DEC
71694: ST_TO_ADDR
71695: LD_EXP 66
71699: PUSH
71700: FOR_TO
71701: IFFALSE 72623
// begin if not mc_bases [ i ] or mc_scan [ i ] then
71703: LD_EXP 66
71707: PUSH
71708: LD_VAR 0 2
71712: ARRAY
71713: NOT
71714: PUSH
71715: LD_EXP 89
71719: PUSH
71720: LD_VAR 0 2
71724: ARRAY
71725: OR
71726: IFFALSE 71730
// continue ;
71728: GO 71700
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
71730: LD_ADDR_VAR 0 7
71734: PUSH
71735: LD_EXP 66
71739: PUSH
71740: LD_VAR 0 2
71744: ARRAY
71745: PUSH
71746: LD_INT 1
71748: ARRAY
71749: PPUSH
71750: CALL_OW 248
71754: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
71755: LD_VAR 0 7
71759: PUSH
71760: LD_INT 3
71762: EQUAL
71763: PUSH
71764: LD_EXP 85
71768: PUSH
71769: LD_VAR 0 2
71773: ARRAY
71774: PUSH
71775: LD_EXP 88
71779: PUSH
71780: LD_VAR 0 2
71784: ARRAY
71785: UNION
71786: PPUSH
71787: LD_INT 33
71789: PUSH
71790: LD_INT 2
71792: PUSH
71793: EMPTY
71794: LIST
71795: LIST
71796: PPUSH
71797: CALL_OW 72
71801: NOT
71802: OR
71803: IFFALSE 71807
// continue ;
71805: GO 71700
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
71807: LD_ADDR_VAR 0 9
71811: PUSH
71812: LD_EXP 66
71816: PUSH
71817: LD_VAR 0 2
71821: ARRAY
71822: PPUSH
71823: LD_INT 30
71825: PUSH
71826: LD_INT 36
71828: PUSH
71829: EMPTY
71830: LIST
71831: LIST
71832: PPUSH
71833: CALL_OW 72
71837: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
71838: LD_ADDR_VAR 0 10
71842: PUSH
71843: LD_EXP 85
71847: PUSH
71848: LD_VAR 0 2
71852: ARRAY
71853: PPUSH
71854: LD_INT 34
71856: PUSH
71857: LD_INT 31
71859: PUSH
71860: EMPTY
71861: LIST
71862: LIST
71863: PPUSH
71864: CALL_OW 72
71868: ST_TO_ADDR
// if not cts and not mcts then
71869: LD_VAR 0 9
71873: NOT
71874: PUSH
71875: LD_VAR 0 10
71879: NOT
71880: AND
71881: IFFALSE 71885
// continue ;
71883: GO 71700
// x := cts ;
71885: LD_ADDR_VAR 0 11
71889: PUSH
71890: LD_VAR 0 9
71894: ST_TO_ADDR
// if not x then
71895: LD_VAR 0 11
71899: NOT
71900: IFFALSE 71912
// x := mcts ;
71902: LD_ADDR_VAR 0 11
71906: PUSH
71907: LD_VAR 0 10
71911: ST_TO_ADDR
// if not x then
71912: LD_VAR 0 11
71916: NOT
71917: IFFALSE 71921
// continue ;
71919: GO 71700
// if mc_remote_driver [ i ] then
71921: LD_EXP 106
71925: PUSH
71926: LD_VAR 0 2
71930: ARRAY
71931: IFFALSE 72318
// for j in mc_remote_driver [ i ] do
71933: LD_ADDR_VAR 0 3
71937: PUSH
71938: LD_EXP 106
71942: PUSH
71943: LD_VAR 0 2
71947: ARRAY
71948: PUSH
71949: FOR_IN
71950: IFFALSE 72316
// begin if GetClass ( j ) <> 3 then
71952: LD_VAR 0 3
71956: PPUSH
71957: CALL_OW 257
71961: PUSH
71962: LD_INT 3
71964: NONEQUAL
71965: IFFALSE 72018
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
71967: LD_ADDR_EXP 106
71971: PUSH
71972: LD_EXP 106
71976: PPUSH
71977: LD_VAR 0 2
71981: PPUSH
71982: LD_EXP 106
71986: PUSH
71987: LD_VAR 0 2
71991: ARRAY
71992: PUSH
71993: LD_VAR 0 3
71997: DIFF
71998: PPUSH
71999: CALL_OW 1
72003: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72004: LD_VAR 0 3
72008: PPUSH
72009: LD_INT 0
72011: PPUSH
72012: CALL_OW 109
// continue ;
72016: GO 71949
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
72018: LD_EXP 85
72022: PUSH
72023: LD_VAR 0 2
72027: ARRAY
72028: PPUSH
72029: LD_INT 34
72031: PUSH
72032: LD_INT 31
72034: PUSH
72035: EMPTY
72036: LIST
72037: LIST
72038: PUSH
72039: LD_INT 58
72041: PUSH
72042: EMPTY
72043: LIST
72044: PUSH
72045: EMPTY
72046: LIST
72047: LIST
72048: PPUSH
72049: CALL_OW 72
72053: PUSH
72054: LD_VAR 0 3
72058: PPUSH
72059: CALL 47197 0 1
72063: NOT
72064: AND
72065: IFFALSE 72136
// begin if IsInUnit ( j ) then
72067: LD_VAR 0 3
72071: PPUSH
72072: CALL_OW 310
72076: IFFALSE 72087
// ComExitBuilding ( j ) ;
72078: LD_VAR 0 3
72082: PPUSH
72083: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
72087: LD_VAR 0 3
72091: PPUSH
72092: LD_EXP 85
72096: PUSH
72097: LD_VAR 0 2
72101: ARRAY
72102: PPUSH
72103: LD_INT 34
72105: PUSH
72106: LD_INT 31
72108: PUSH
72109: EMPTY
72110: LIST
72111: LIST
72112: PUSH
72113: LD_INT 58
72115: PUSH
72116: EMPTY
72117: LIST
72118: PUSH
72119: EMPTY
72120: LIST
72121: LIST
72122: PPUSH
72123: CALL_OW 72
72127: PUSH
72128: LD_INT 1
72130: ARRAY
72131: PPUSH
72132: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
72136: LD_VAR 0 3
72140: PPUSH
72141: CALL_OW 310
72145: NOT
72146: PUSH
72147: LD_VAR 0 3
72151: PPUSH
72152: CALL_OW 310
72156: PPUSH
72157: CALL_OW 266
72161: PUSH
72162: LD_INT 36
72164: NONEQUAL
72165: PUSH
72166: LD_VAR 0 3
72170: PPUSH
72171: CALL 47197 0 1
72175: NOT
72176: AND
72177: OR
72178: IFFALSE 72314
// begin if IsInUnit ( j ) then
72180: LD_VAR 0 3
72184: PPUSH
72185: CALL_OW 310
72189: IFFALSE 72200
// ComExitBuilding ( j ) ;
72191: LD_VAR 0 3
72195: PPUSH
72196: CALL_OW 122
// ct := 0 ;
72200: LD_ADDR_VAR 0 8
72204: PUSH
72205: LD_INT 0
72207: ST_TO_ADDR
// for k in x do
72208: LD_ADDR_VAR 0 4
72212: PUSH
72213: LD_VAR 0 11
72217: PUSH
72218: FOR_IN
72219: IFFALSE 72292
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
72221: LD_VAR 0 4
72225: PPUSH
72226: CALL_OW 264
72230: PUSH
72231: LD_INT 31
72233: EQUAL
72234: PUSH
72235: LD_VAR 0 4
72239: PPUSH
72240: CALL_OW 311
72244: NOT
72245: AND
72246: PUSH
72247: LD_VAR 0 4
72251: PPUSH
72252: CALL_OW 266
72256: PUSH
72257: LD_INT 36
72259: EQUAL
72260: PUSH
72261: LD_VAR 0 4
72265: PPUSH
72266: CALL_OW 313
72270: PUSH
72271: LD_INT 3
72273: LESS
72274: AND
72275: OR
72276: IFFALSE 72290
// begin ct := k ;
72278: LD_ADDR_VAR 0 8
72282: PUSH
72283: LD_VAR 0 4
72287: ST_TO_ADDR
// break ;
72288: GO 72292
// end ;
72290: GO 72218
72292: POP
72293: POP
// if ct then
72294: LD_VAR 0 8
72298: IFFALSE 72314
// ComEnterUnit ( j , ct ) ;
72300: LD_VAR 0 3
72304: PPUSH
72305: LD_VAR 0 8
72309: PPUSH
72310: CALL_OW 120
// end ; end ;
72314: GO 71949
72316: POP
72317: POP
// places := 0 ;
72318: LD_ADDR_VAR 0 5
72322: PUSH
72323: LD_INT 0
72325: ST_TO_ADDR
// for j = 1 to x do
72326: LD_ADDR_VAR 0 3
72330: PUSH
72331: DOUBLE
72332: LD_INT 1
72334: DEC
72335: ST_TO_ADDR
72336: LD_VAR 0 11
72340: PUSH
72341: FOR_TO
72342: IFFALSE 72418
// if GetWeapon ( x [ j ] ) = ar_control_tower then
72344: LD_VAR 0 11
72348: PUSH
72349: LD_VAR 0 3
72353: ARRAY
72354: PPUSH
72355: CALL_OW 264
72359: PUSH
72360: LD_INT 31
72362: EQUAL
72363: IFFALSE 72381
// places := places + 1 else
72365: LD_ADDR_VAR 0 5
72369: PUSH
72370: LD_VAR 0 5
72374: PUSH
72375: LD_INT 1
72377: PLUS
72378: ST_TO_ADDR
72379: GO 72416
// if GetBType ( x [ j ] ) = b_control_tower then
72381: LD_VAR 0 11
72385: PUSH
72386: LD_VAR 0 3
72390: ARRAY
72391: PPUSH
72392: CALL_OW 266
72396: PUSH
72397: LD_INT 36
72399: EQUAL
72400: IFFALSE 72416
// places := places + 3 ;
72402: LD_ADDR_VAR 0 5
72406: PUSH
72407: LD_VAR 0 5
72411: PUSH
72412: LD_INT 3
72414: PLUS
72415: ST_TO_ADDR
72416: GO 72341
72418: POP
72419: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
72420: LD_VAR 0 5
72424: PUSH
72425: LD_INT 0
72427: EQUAL
72428: PUSH
72429: LD_VAR 0 5
72433: PUSH
72434: LD_EXP 106
72438: PUSH
72439: LD_VAR 0 2
72443: ARRAY
72444: LESSEQUAL
72445: OR
72446: IFFALSE 72450
// continue ;
72448: GO 71700
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
72450: LD_ADDR_VAR 0 6
72454: PUSH
72455: LD_EXP 66
72459: PUSH
72460: LD_VAR 0 2
72464: ARRAY
72465: PPUSH
72466: LD_INT 25
72468: PUSH
72469: LD_INT 3
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: PPUSH
72476: CALL_OW 72
72480: PUSH
72481: LD_EXP 106
72485: PUSH
72486: LD_VAR 0 2
72490: ARRAY
72491: DIFF
72492: PPUSH
72493: LD_INT 3
72495: PPUSH
72496: CALL 48097 0 2
72500: ST_TO_ADDR
// for j in tmp do
72501: LD_ADDR_VAR 0 3
72505: PUSH
72506: LD_VAR 0 6
72510: PUSH
72511: FOR_IN
72512: IFFALSE 72547
// if GetTag ( j ) > 0 then
72514: LD_VAR 0 3
72518: PPUSH
72519: CALL_OW 110
72523: PUSH
72524: LD_INT 0
72526: GREATER
72527: IFFALSE 72545
// tmp := tmp diff j ;
72529: LD_ADDR_VAR 0 6
72533: PUSH
72534: LD_VAR 0 6
72538: PUSH
72539: LD_VAR 0 3
72543: DIFF
72544: ST_TO_ADDR
72545: GO 72511
72547: POP
72548: POP
// if not tmp then
72549: LD_VAR 0 6
72553: NOT
72554: IFFALSE 72558
// continue ;
72556: GO 71700
// if places then
72558: LD_VAR 0 5
72562: IFFALSE 72621
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
72564: LD_ADDR_EXP 106
72568: PUSH
72569: LD_EXP 106
72573: PPUSH
72574: LD_VAR 0 2
72578: PPUSH
72579: LD_EXP 106
72583: PUSH
72584: LD_VAR 0 2
72588: ARRAY
72589: PUSH
72590: LD_VAR 0 6
72594: PUSH
72595: LD_INT 1
72597: ARRAY
72598: UNION
72599: PPUSH
72600: CALL_OW 1
72604: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
72605: LD_VAR 0 6
72609: PUSH
72610: LD_INT 1
72612: ARRAY
72613: PPUSH
72614: LD_INT 126
72616: PPUSH
72617: CALL_OW 109
// end ; end ;
72621: GO 71700
72623: POP
72624: POP
// end ;
72625: LD_VAR 0 1
72629: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
72630: LD_INT 0
72632: PPUSH
72633: PPUSH
72634: PPUSH
72635: PPUSH
72636: PPUSH
72637: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
72638: LD_VAR 0 1
72642: NOT
72643: PUSH
72644: LD_VAR 0 2
72648: NOT
72649: OR
72650: PUSH
72651: LD_VAR 0 3
72655: NOT
72656: OR
72657: PUSH
72658: LD_VAR 0 4
72662: PUSH
72663: LD_INT 1
72665: PUSH
72666: LD_INT 2
72668: PUSH
72669: LD_INT 3
72671: PUSH
72672: LD_INT 4
72674: PUSH
72675: LD_INT 5
72677: PUSH
72678: LD_INT 8
72680: PUSH
72681: LD_INT 9
72683: PUSH
72684: LD_INT 15
72686: PUSH
72687: LD_INT 16
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: LIST
72694: LIST
72695: LIST
72696: LIST
72697: LIST
72698: LIST
72699: LIST
72700: IN
72701: NOT
72702: OR
72703: IFFALSE 72707
// exit ;
72705: GO 73607
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
72707: LD_ADDR_VAR 0 2
72711: PUSH
72712: LD_VAR 0 2
72716: PPUSH
72717: LD_INT 21
72719: PUSH
72720: LD_INT 3
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: PUSH
72727: LD_INT 24
72729: PUSH
72730: LD_INT 250
72732: PUSH
72733: EMPTY
72734: LIST
72735: LIST
72736: PUSH
72737: EMPTY
72738: LIST
72739: LIST
72740: PPUSH
72741: CALL_OW 72
72745: ST_TO_ADDR
// case class of 1 , 15 :
72746: LD_VAR 0 4
72750: PUSH
72751: LD_INT 1
72753: DOUBLE
72754: EQUAL
72755: IFTRUE 72765
72757: LD_INT 15
72759: DOUBLE
72760: EQUAL
72761: IFTRUE 72765
72763: GO 72850
72765: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
72766: LD_ADDR_VAR 0 8
72770: PUSH
72771: LD_VAR 0 2
72775: PPUSH
72776: LD_INT 2
72778: PUSH
72779: LD_INT 30
72781: PUSH
72782: LD_INT 32
72784: PUSH
72785: EMPTY
72786: LIST
72787: LIST
72788: PUSH
72789: LD_INT 30
72791: PUSH
72792: LD_INT 31
72794: PUSH
72795: EMPTY
72796: LIST
72797: LIST
72798: PUSH
72799: EMPTY
72800: LIST
72801: LIST
72802: LIST
72803: PPUSH
72804: CALL_OW 72
72808: PUSH
72809: LD_VAR 0 2
72813: PPUSH
72814: LD_INT 2
72816: PUSH
72817: LD_INT 30
72819: PUSH
72820: LD_INT 4
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: PUSH
72827: LD_INT 30
72829: PUSH
72830: LD_INT 5
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: LIST
72841: PPUSH
72842: CALL_OW 72
72846: ADD
72847: ST_TO_ADDR
72848: GO 73096
72850: LD_INT 2
72852: DOUBLE
72853: EQUAL
72854: IFTRUE 72864
72856: LD_INT 16
72858: DOUBLE
72859: EQUAL
72860: IFTRUE 72864
72862: GO 72910
72864: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
72865: LD_ADDR_VAR 0 8
72869: PUSH
72870: LD_VAR 0 2
72874: PPUSH
72875: LD_INT 2
72877: PUSH
72878: LD_INT 30
72880: PUSH
72881: LD_INT 0
72883: PUSH
72884: EMPTY
72885: LIST
72886: LIST
72887: PUSH
72888: LD_INT 30
72890: PUSH
72891: LD_INT 1
72893: PUSH
72894: EMPTY
72895: LIST
72896: LIST
72897: PUSH
72898: EMPTY
72899: LIST
72900: LIST
72901: LIST
72902: PPUSH
72903: CALL_OW 72
72907: ST_TO_ADDR
72908: GO 73096
72910: LD_INT 3
72912: DOUBLE
72913: EQUAL
72914: IFTRUE 72918
72916: GO 72964
72918: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
72919: LD_ADDR_VAR 0 8
72923: PUSH
72924: LD_VAR 0 2
72928: PPUSH
72929: LD_INT 2
72931: PUSH
72932: LD_INT 30
72934: PUSH
72935: LD_INT 2
72937: PUSH
72938: EMPTY
72939: LIST
72940: LIST
72941: PUSH
72942: LD_INT 30
72944: PUSH
72945: LD_INT 3
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: PUSH
72952: EMPTY
72953: LIST
72954: LIST
72955: LIST
72956: PPUSH
72957: CALL_OW 72
72961: ST_TO_ADDR
72962: GO 73096
72964: LD_INT 4
72966: DOUBLE
72967: EQUAL
72968: IFTRUE 72972
72970: GO 73029
72972: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
72973: LD_ADDR_VAR 0 8
72977: PUSH
72978: LD_VAR 0 2
72982: PPUSH
72983: LD_INT 2
72985: PUSH
72986: LD_INT 30
72988: PUSH
72989: LD_INT 6
72991: PUSH
72992: EMPTY
72993: LIST
72994: LIST
72995: PUSH
72996: LD_INT 30
72998: PUSH
72999: LD_INT 7
73001: PUSH
73002: EMPTY
73003: LIST
73004: LIST
73005: PUSH
73006: LD_INT 30
73008: PUSH
73009: LD_INT 8
73011: PUSH
73012: EMPTY
73013: LIST
73014: LIST
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: LIST
73020: LIST
73021: PPUSH
73022: CALL_OW 72
73026: ST_TO_ADDR
73027: GO 73096
73029: LD_INT 5
73031: DOUBLE
73032: EQUAL
73033: IFTRUE 73049
73035: LD_INT 8
73037: DOUBLE
73038: EQUAL
73039: IFTRUE 73049
73041: LD_INT 9
73043: DOUBLE
73044: EQUAL
73045: IFTRUE 73049
73047: GO 73095
73049: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
73050: LD_ADDR_VAR 0 8
73054: PUSH
73055: LD_VAR 0 2
73059: PPUSH
73060: LD_INT 2
73062: PUSH
73063: LD_INT 30
73065: PUSH
73066: LD_INT 4
73068: PUSH
73069: EMPTY
73070: LIST
73071: LIST
73072: PUSH
73073: LD_INT 30
73075: PUSH
73076: LD_INT 5
73078: PUSH
73079: EMPTY
73080: LIST
73081: LIST
73082: PUSH
73083: EMPTY
73084: LIST
73085: LIST
73086: LIST
73087: PPUSH
73088: CALL_OW 72
73092: ST_TO_ADDR
73093: GO 73096
73095: POP
// if not tmp then
73096: LD_VAR 0 8
73100: NOT
73101: IFFALSE 73105
// exit ;
73103: GO 73607
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
73105: LD_VAR 0 4
73109: PUSH
73110: LD_INT 1
73112: PUSH
73113: LD_INT 15
73115: PUSH
73116: EMPTY
73117: LIST
73118: LIST
73119: IN
73120: PUSH
73121: LD_EXP 75
73125: PUSH
73126: LD_VAR 0 1
73130: ARRAY
73131: AND
73132: IFFALSE 73288
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
73134: LD_ADDR_VAR 0 9
73138: PUSH
73139: LD_EXP 75
73143: PUSH
73144: LD_VAR 0 1
73148: ARRAY
73149: PUSH
73150: LD_INT 1
73152: ARRAY
73153: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
73154: LD_VAR 0 9
73158: PUSH
73159: LD_EXP 76
73163: PUSH
73164: LD_VAR 0 1
73168: ARRAY
73169: IN
73170: NOT
73171: IFFALSE 73286
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
73173: LD_ADDR_EXP 76
73177: PUSH
73178: LD_EXP 76
73182: PPUSH
73183: LD_VAR 0 1
73187: PUSH
73188: LD_EXP 76
73192: PUSH
73193: LD_VAR 0 1
73197: ARRAY
73198: PUSH
73199: LD_INT 1
73201: PLUS
73202: PUSH
73203: EMPTY
73204: LIST
73205: LIST
73206: PPUSH
73207: LD_VAR 0 9
73211: PPUSH
73212: CALL 18548 0 3
73216: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
73217: LD_ADDR_EXP 75
73221: PUSH
73222: LD_EXP 75
73226: PPUSH
73227: LD_VAR 0 1
73231: PPUSH
73232: LD_EXP 75
73236: PUSH
73237: LD_VAR 0 1
73241: ARRAY
73242: PUSH
73243: LD_VAR 0 9
73247: DIFF
73248: PPUSH
73249: CALL_OW 1
73253: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
73254: LD_VAR 0 3
73258: PPUSH
73259: LD_EXP 76
73263: PUSH
73264: LD_VAR 0 1
73268: ARRAY
73269: PUSH
73270: LD_EXP 76
73274: PUSH
73275: LD_VAR 0 1
73279: ARRAY
73280: ARRAY
73281: PPUSH
73282: CALL_OW 120
// end ; exit ;
73286: GO 73607
// end ; if tmp > 1 then
73288: LD_VAR 0 8
73292: PUSH
73293: LD_INT 1
73295: GREATER
73296: IFFALSE 73400
// for i = 2 to tmp do
73298: LD_ADDR_VAR 0 6
73302: PUSH
73303: DOUBLE
73304: LD_INT 2
73306: DEC
73307: ST_TO_ADDR
73308: LD_VAR 0 8
73312: PUSH
73313: FOR_TO
73314: IFFALSE 73398
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
73316: LD_VAR 0 8
73320: PUSH
73321: LD_VAR 0 6
73325: ARRAY
73326: PPUSH
73327: CALL_OW 461
73331: PUSH
73332: LD_INT 6
73334: EQUAL
73335: IFFALSE 73396
// begin x := tmp [ i ] ;
73337: LD_ADDR_VAR 0 9
73341: PUSH
73342: LD_VAR 0 8
73346: PUSH
73347: LD_VAR 0 6
73351: ARRAY
73352: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
73353: LD_ADDR_VAR 0 8
73357: PUSH
73358: LD_VAR 0 8
73362: PPUSH
73363: LD_VAR 0 6
73367: PPUSH
73368: CALL_OW 3
73372: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
73373: LD_ADDR_VAR 0 8
73377: PUSH
73378: LD_VAR 0 8
73382: PPUSH
73383: LD_INT 1
73385: PPUSH
73386: LD_VAR 0 9
73390: PPUSH
73391: CALL_OW 2
73395: ST_TO_ADDR
// end ;
73396: GO 73313
73398: POP
73399: POP
// for i in tmp do
73400: LD_ADDR_VAR 0 6
73404: PUSH
73405: LD_VAR 0 8
73409: PUSH
73410: FOR_IN
73411: IFFALSE 73480
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
73413: LD_VAR 0 6
73417: PPUSH
73418: CALL_OW 313
73422: PUSH
73423: LD_INT 6
73425: LESS
73426: PUSH
73427: LD_VAR 0 6
73431: PPUSH
73432: CALL_OW 266
73436: PUSH
73437: LD_INT 31
73439: PUSH
73440: LD_INT 32
73442: PUSH
73443: EMPTY
73444: LIST
73445: LIST
73446: IN
73447: NOT
73448: AND
73449: PUSH
73450: LD_VAR 0 6
73454: PPUSH
73455: CALL_OW 313
73459: PUSH
73460: LD_INT 0
73462: EQUAL
73463: OR
73464: IFFALSE 73478
// begin j := i ;
73466: LD_ADDR_VAR 0 7
73470: PUSH
73471: LD_VAR 0 6
73475: ST_TO_ADDR
// break ;
73476: GO 73480
// end ; end ;
73478: GO 73410
73480: POP
73481: POP
// if j then
73482: LD_VAR 0 7
73486: IFFALSE 73504
// ComEnterUnit ( unit , j ) else
73488: LD_VAR 0 3
73492: PPUSH
73493: LD_VAR 0 7
73497: PPUSH
73498: CALL_OW 120
73502: GO 73607
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73504: LD_ADDR_VAR 0 10
73508: PUSH
73509: LD_VAR 0 2
73513: PPUSH
73514: LD_INT 2
73516: PUSH
73517: LD_INT 30
73519: PUSH
73520: LD_INT 0
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: PUSH
73527: LD_INT 30
73529: PUSH
73530: LD_INT 1
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: EMPTY
73538: LIST
73539: LIST
73540: LIST
73541: PPUSH
73542: CALL_OW 72
73546: ST_TO_ADDR
// if depot then
73547: LD_VAR 0 10
73551: IFFALSE 73607
// begin depot := NearestUnitToUnit ( depot , unit ) ;
73553: LD_ADDR_VAR 0 10
73557: PUSH
73558: LD_VAR 0 10
73562: PPUSH
73563: LD_VAR 0 3
73567: PPUSH
73568: CALL_OW 74
73572: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
73573: LD_VAR 0 3
73577: PPUSH
73578: LD_VAR 0 10
73582: PPUSH
73583: CALL_OW 296
73587: PUSH
73588: LD_INT 10
73590: GREATER
73591: IFFALSE 73607
// ComStandNearbyBuilding ( unit , depot ) ;
73593: LD_VAR 0 3
73597: PPUSH
73598: LD_VAR 0 10
73602: PPUSH
73603: CALL 15162 0 2
// end ; end ; end ;
73607: LD_VAR 0 5
73611: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
73612: LD_INT 0
73614: PPUSH
73615: PPUSH
73616: PPUSH
73617: PPUSH
// if not mc_bases then
73618: LD_EXP 66
73622: NOT
73623: IFFALSE 73627
// exit ;
73625: GO 73866
// for i = 1 to mc_bases do
73627: LD_ADDR_VAR 0 2
73631: PUSH
73632: DOUBLE
73633: LD_INT 1
73635: DEC
73636: ST_TO_ADDR
73637: LD_EXP 66
73641: PUSH
73642: FOR_TO
73643: IFFALSE 73864
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
73645: LD_ADDR_VAR 0 4
73649: PUSH
73650: LD_EXP 66
73654: PUSH
73655: LD_VAR 0 2
73659: ARRAY
73660: PPUSH
73661: LD_INT 21
73663: PUSH
73664: LD_INT 1
73666: PUSH
73667: EMPTY
73668: LIST
73669: LIST
73670: PPUSH
73671: CALL_OW 72
73675: PUSH
73676: LD_EXP 95
73680: PUSH
73681: LD_VAR 0 2
73685: ARRAY
73686: UNION
73687: ST_TO_ADDR
// if not tmp then
73688: LD_VAR 0 4
73692: NOT
73693: IFFALSE 73697
// continue ;
73695: GO 73642
// for j in tmp do
73697: LD_ADDR_VAR 0 3
73701: PUSH
73702: LD_VAR 0 4
73706: PUSH
73707: FOR_IN
73708: IFFALSE 73860
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
73710: LD_VAR 0 3
73714: PPUSH
73715: CALL_OW 110
73719: NOT
73720: PUSH
73721: LD_VAR 0 3
73725: PPUSH
73726: CALL_OW 314
73730: NOT
73731: AND
73732: PUSH
73733: LD_VAR 0 3
73737: PPUSH
73738: CALL_OW 311
73742: NOT
73743: AND
73744: PUSH
73745: LD_VAR 0 3
73749: PPUSH
73750: CALL_OW 310
73754: NOT
73755: AND
73756: PUSH
73757: LD_VAR 0 3
73761: PUSH
73762: LD_EXP 69
73766: PUSH
73767: LD_VAR 0 2
73771: ARRAY
73772: PUSH
73773: LD_INT 1
73775: ARRAY
73776: IN
73777: NOT
73778: AND
73779: PUSH
73780: LD_VAR 0 3
73784: PUSH
73785: LD_EXP 69
73789: PUSH
73790: LD_VAR 0 2
73794: ARRAY
73795: PUSH
73796: LD_INT 2
73798: ARRAY
73799: IN
73800: NOT
73801: AND
73802: PUSH
73803: LD_VAR 0 3
73807: PUSH
73808: LD_EXP 78
73812: PUSH
73813: LD_VAR 0 2
73817: ARRAY
73818: IN
73819: NOT
73820: AND
73821: IFFALSE 73858
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
73823: LD_VAR 0 2
73827: PPUSH
73828: LD_EXP 66
73832: PUSH
73833: LD_VAR 0 2
73837: ARRAY
73838: PPUSH
73839: LD_VAR 0 3
73843: PPUSH
73844: LD_VAR 0 3
73848: PPUSH
73849: CALL_OW 257
73853: PPUSH
73854: CALL 72630 0 4
// end ;
73858: GO 73707
73860: POP
73861: POP
// end ;
73862: GO 73642
73864: POP
73865: POP
// end ;
73866: LD_VAR 0 1
73870: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
73871: LD_INT 0
73873: PPUSH
73874: PPUSH
73875: PPUSH
73876: PPUSH
73877: PPUSH
73878: PPUSH
// if not mc_bases [ base ] then
73879: LD_EXP 66
73883: PUSH
73884: LD_VAR 0 1
73888: ARRAY
73889: NOT
73890: IFFALSE 73894
// exit ;
73892: GO 74076
// tmp := [ ] ;
73894: LD_ADDR_VAR 0 6
73898: PUSH
73899: EMPTY
73900: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
73901: LD_ADDR_VAR 0 7
73905: PUSH
73906: LD_VAR 0 3
73910: PPUSH
73911: LD_INT 0
73913: PPUSH
73914: CALL_OW 517
73918: ST_TO_ADDR
// if not list then
73919: LD_VAR 0 7
73923: NOT
73924: IFFALSE 73928
// exit ;
73926: GO 74076
// for i = 1 to amount do
73928: LD_ADDR_VAR 0 5
73932: PUSH
73933: DOUBLE
73934: LD_INT 1
73936: DEC
73937: ST_TO_ADDR
73938: LD_VAR 0 2
73942: PUSH
73943: FOR_TO
73944: IFFALSE 74024
// begin x := rand ( 1 , list [ 1 ] ) ;
73946: LD_ADDR_VAR 0 8
73950: PUSH
73951: LD_INT 1
73953: PPUSH
73954: LD_VAR 0 7
73958: PUSH
73959: LD_INT 1
73961: ARRAY
73962: PPUSH
73963: CALL_OW 12
73967: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
73968: LD_ADDR_VAR 0 6
73972: PUSH
73973: LD_VAR 0 6
73977: PPUSH
73978: LD_VAR 0 5
73982: PPUSH
73983: LD_VAR 0 7
73987: PUSH
73988: LD_INT 1
73990: ARRAY
73991: PUSH
73992: LD_VAR 0 8
73996: ARRAY
73997: PUSH
73998: LD_VAR 0 7
74002: PUSH
74003: LD_INT 2
74005: ARRAY
74006: PUSH
74007: LD_VAR 0 8
74011: ARRAY
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PPUSH
74017: CALL_OW 1
74021: ST_TO_ADDR
// end ;
74022: GO 73943
74024: POP
74025: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
74026: LD_ADDR_EXP 79
74030: PUSH
74031: LD_EXP 79
74035: PPUSH
74036: LD_VAR 0 1
74040: PPUSH
74041: LD_VAR 0 6
74045: PPUSH
74046: CALL_OW 1
74050: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
74051: LD_ADDR_EXP 81
74055: PUSH
74056: LD_EXP 81
74060: PPUSH
74061: LD_VAR 0 1
74065: PPUSH
74066: LD_VAR 0 3
74070: PPUSH
74071: CALL_OW 1
74075: ST_TO_ADDR
// end ;
74076: LD_VAR 0 4
74080: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
74081: LD_INT 0
74083: PPUSH
// if not mc_bases [ base ] then
74084: LD_EXP 66
74088: PUSH
74089: LD_VAR 0 1
74093: ARRAY
74094: NOT
74095: IFFALSE 74099
// exit ;
74097: GO 74124
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
74099: LD_ADDR_EXP 71
74103: PUSH
74104: LD_EXP 71
74108: PPUSH
74109: LD_VAR 0 1
74113: PPUSH
74114: LD_VAR 0 2
74118: PPUSH
74119: CALL_OW 1
74123: ST_TO_ADDR
// end ;
74124: LD_VAR 0 3
74128: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
74129: LD_INT 0
74131: PPUSH
// if not mc_bases [ base ] then
74132: LD_EXP 66
74136: PUSH
74137: LD_VAR 0 1
74141: ARRAY
74142: NOT
74143: IFFALSE 74147
// exit ;
74145: GO 74184
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
74147: LD_ADDR_EXP 71
74151: PUSH
74152: LD_EXP 71
74156: PPUSH
74157: LD_VAR 0 1
74161: PPUSH
74162: LD_EXP 71
74166: PUSH
74167: LD_VAR 0 1
74171: ARRAY
74172: PUSH
74173: LD_VAR 0 2
74177: UNION
74178: PPUSH
74179: CALL_OW 1
74183: ST_TO_ADDR
// end ;
74184: LD_VAR 0 3
74188: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
74189: LD_INT 0
74191: PPUSH
// if not mc_bases [ base ] then
74192: LD_EXP 66
74196: PUSH
74197: LD_VAR 0 1
74201: ARRAY
74202: NOT
74203: IFFALSE 74207
// exit ;
74205: GO 74232
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
74207: LD_ADDR_EXP 87
74211: PUSH
74212: LD_EXP 87
74216: PPUSH
74217: LD_VAR 0 1
74221: PPUSH
74222: LD_VAR 0 2
74226: PPUSH
74227: CALL_OW 1
74231: ST_TO_ADDR
// end ;
74232: LD_VAR 0 3
74236: RET
// export function MC_InsertProduceList ( base , components ) ; begin
74237: LD_INT 0
74239: PPUSH
// if not mc_bases [ base ] then
74240: LD_EXP 66
74244: PUSH
74245: LD_VAR 0 1
74249: ARRAY
74250: NOT
74251: IFFALSE 74255
// exit ;
74253: GO 74292
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
74255: LD_ADDR_EXP 87
74259: PUSH
74260: LD_EXP 87
74264: PPUSH
74265: LD_VAR 0 1
74269: PPUSH
74270: LD_EXP 87
74274: PUSH
74275: LD_VAR 0 1
74279: ARRAY
74280: PUSH
74281: LD_VAR 0 2
74285: ADD
74286: PPUSH
74287: CALL_OW 1
74291: ST_TO_ADDR
// end ;
74292: LD_VAR 0 3
74296: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
74297: LD_INT 0
74299: PPUSH
// if not mc_bases [ base ] then
74300: LD_EXP 66
74304: PUSH
74305: LD_VAR 0 1
74309: ARRAY
74310: NOT
74311: IFFALSE 74315
// exit ;
74313: GO 74369
// mc_defender := Replace ( mc_defender , base , deflist ) ;
74315: LD_ADDR_EXP 88
74319: PUSH
74320: LD_EXP 88
74324: PPUSH
74325: LD_VAR 0 1
74329: PPUSH
74330: LD_VAR 0 2
74334: PPUSH
74335: CALL_OW 1
74339: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
74340: LD_ADDR_EXP 77
74344: PUSH
74345: LD_EXP 77
74349: PPUSH
74350: LD_VAR 0 1
74354: PPUSH
74355: LD_VAR 0 2
74359: PUSH
74360: LD_INT 0
74362: PLUS
74363: PPUSH
74364: CALL_OW 1
74368: ST_TO_ADDR
// end ;
74369: LD_VAR 0 3
74373: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
74374: LD_INT 0
74376: PPUSH
// if not mc_bases [ base ] then
74377: LD_EXP 66
74381: PUSH
74382: LD_VAR 0 1
74386: ARRAY
74387: NOT
74388: IFFALSE 74392
// exit ;
74390: GO 74417
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
74392: LD_ADDR_EXP 77
74396: PUSH
74397: LD_EXP 77
74401: PPUSH
74402: LD_VAR 0 1
74406: PPUSH
74407: LD_VAR 0 2
74411: PPUSH
74412: CALL_OW 1
74416: ST_TO_ADDR
// end ;
74417: LD_VAR 0 3
74421: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
74422: LD_INT 0
74424: PPUSH
74425: PPUSH
74426: PPUSH
74427: PPUSH
// if not mc_bases [ base ] then
74428: LD_EXP 66
74432: PUSH
74433: LD_VAR 0 1
74437: ARRAY
74438: NOT
74439: IFFALSE 74443
// exit ;
74441: GO 74508
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
74443: LD_ADDR_EXP 86
74447: PUSH
74448: LD_EXP 86
74452: PPUSH
74453: LD_VAR 0 1
74457: PUSH
74458: LD_EXP 86
74462: PUSH
74463: LD_VAR 0 1
74467: ARRAY
74468: PUSH
74469: LD_INT 1
74471: PLUS
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PPUSH
74477: LD_VAR 0 1
74481: PUSH
74482: LD_VAR 0 2
74486: PUSH
74487: LD_VAR 0 3
74491: PUSH
74492: LD_VAR 0 4
74496: PUSH
74497: EMPTY
74498: LIST
74499: LIST
74500: LIST
74501: LIST
74502: PPUSH
74503: CALL 18548 0 3
74507: ST_TO_ADDR
// end ;
74508: LD_VAR 0 5
74512: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
74513: LD_INT 0
74515: PPUSH
// if not mc_bases [ base ] then
74516: LD_EXP 66
74520: PUSH
74521: LD_VAR 0 1
74525: ARRAY
74526: NOT
74527: IFFALSE 74531
// exit ;
74529: GO 74556
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
74531: LD_ADDR_EXP 103
74535: PUSH
74536: LD_EXP 103
74540: PPUSH
74541: LD_VAR 0 1
74545: PPUSH
74546: LD_VAR 0 2
74550: PPUSH
74551: CALL_OW 1
74555: ST_TO_ADDR
// end ;
74556: LD_VAR 0 3
74560: RET
// export function MC_GetMinesField ( base ) ; begin
74561: LD_INT 0
74563: PPUSH
// result := mc_mines [ base ] ;
74564: LD_ADDR_VAR 0 2
74568: PUSH
74569: LD_EXP 79
74573: PUSH
74574: LD_VAR 0 1
74578: ARRAY
74579: ST_TO_ADDR
// end ;
74580: LD_VAR 0 2
74584: RET
// export function MC_GetProduceList ( base ) ; begin
74585: LD_INT 0
74587: PPUSH
// result := mc_produce [ base ] ;
74588: LD_ADDR_VAR 0 2
74592: PUSH
74593: LD_EXP 87
74597: PUSH
74598: LD_VAR 0 1
74602: ARRAY
74603: ST_TO_ADDR
// end ;
74604: LD_VAR 0 2
74608: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
74609: LD_INT 0
74611: PPUSH
74612: PPUSH
// if not mc_bases then
74613: LD_EXP 66
74617: NOT
74618: IFFALSE 74622
// exit ;
74620: GO 74687
// if mc_bases [ base ] then
74622: LD_EXP 66
74626: PUSH
74627: LD_VAR 0 1
74631: ARRAY
74632: IFFALSE 74687
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74634: LD_ADDR_VAR 0 3
74638: PUSH
74639: LD_EXP 66
74643: PUSH
74644: LD_VAR 0 1
74648: ARRAY
74649: PPUSH
74650: LD_INT 30
74652: PUSH
74653: LD_VAR 0 2
74657: PUSH
74658: EMPTY
74659: LIST
74660: LIST
74661: PPUSH
74662: CALL_OW 72
74666: ST_TO_ADDR
// if result then
74667: LD_VAR 0 3
74671: IFFALSE 74687
// result := result [ 1 ] ;
74673: LD_ADDR_VAR 0 3
74677: PUSH
74678: LD_VAR 0 3
74682: PUSH
74683: LD_INT 1
74685: ARRAY
74686: ST_TO_ADDR
// end ; end ;
74687: LD_VAR 0 3
74691: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
74692: LD_INT 0
74694: PPUSH
74695: PPUSH
// if not mc_bases then
74696: LD_EXP 66
74700: NOT
74701: IFFALSE 74705
// exit ;
74703: GO 74750
// if mc_bases [ base ] then
74705: LD_EXP 66
74709: PUSH
74710: LD_VAR 0 1
74714: ARRAY
74715: IFFALSE 74750
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74717: LD_ADDR_VAR 0 3
74721: PUSH
74722: LD_EXP 66
74726: PUSH
74727: LD_VAR 0 1
74731: ARRAY
74732: PPUSH
74733: LD_INT 30
74735: PUSH
74736: LD_VAR 0 2
74740: PUSH
74741: EMPTY
74742: LIST
74743: LIST
74744: PPUSH
74745: CALL_OW 72
74749: ST_TO_ADDR
// end ;
74750: LD_VAR 0 3
74754: RET
// export function MC_SetTame ( base , area ) ; begin
74755: LD_INT 0
74757: PPUSH
// if not mc_bases or not base then
74758: LD_EXP 66
74762: NOT
74763: PUSH
74764: LD_VAR 0 1
74768: NOT
74769: OR
74770: IFFALSE 74774
// exit ;
74772: GO 74799
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
74774: LD_ADDR_EXP 94
74778: PUSH
74779: LD_EXP 94
74783: PPUSH
74784: LD_VAR 0 1
74788: PPUSH
74789: LD_VAR 0 2
74793: PPUSH
74794: CALL_OW 1
74798: ST_TO_ADDR
// end ;
74799: LD_VAR 0 3
74803: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
74804: LD_INT 0
74806: PPUSH
74807: PPUSH
// if not mc_bases or not base then
74808: LD_EXP 66
74812: NOT
74813: PUSH
74814: LD_VAR 0 1
74818: NOT
74819: OR
74820: IFFALSE 74824
// exit ;
74822: GO 74926
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74824: LD_ADDR_VAR 0 4
74828: PUSH
74829: LD_EXP 66
74833: PUSH
74834: LD_VAR 0 1
74838: ARRAY
74839: PPUSH
74840: LD_INT 30
74842: PUSH
74843: LD_VAR 0 2
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PPUSH
74852: CALL_OW 72
74856: ST_TO_ADDR
// if not tmp then
74857: LD_VAR 0 4
74861: NOT
74862: IFFALSE 74866
// exit ;
74864: GO 74926
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
74866: LD_ADDR_EXP 98
74870: PUSH
74871: LD_EXP 98
74875: PPUSH
74876: LD_VAR 0 1
74880: PPUSH
74881: LD_EXP 98
74885: PUSH
74886: LD_VAR 0 1
74890: ARRAY
74891: PPUSH
74892: LD_EXP 98
74896: PUSH
74897: LD_VAR 0 1
74901: ARRAY
74902: PUSH
74903: LD_INT 1
74905: PLUS
74906: PPUSH
74907: LD_VAR 0 4
74911: PUSH
74912: LD_INT 1
74914: ARRAY
74915: PPUSH
74916: CALL_OW 2
74920: PPUSH
74921: CALL_OW 1
74925: ST_TO_ADDR
// end ;
74926: LD_VAR 0 3
74930: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
74931: LD_INT 0
74933: PPUSH
74934: PPUSH
// if not mc_bases or not base or not kinds then
74935: LD_EXP 66
74939: NOT
74940: PUSH
74941: LD_VAR 0 1
74945: NOT
74946: OR
74947: PUSH
74948: LD_VAR 0 2
74952: NOT
74953: OR
74954: IFFALSE 74958
// exit ;
74956: GO 75019
// for i in kinds do
74958: LD_ADDR_VAR 0 4
74962: PUSH
74963: LD_VAR 0 2
74967: PUSH
74968: FOR_IN
74969: IFFALSE 75017
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
74971: LD_ADDR_EXP 100
74975: PUSH
74976: LD_EXP 100
74980: PPUSH
74981: LD_VAR 0 1
74985: PUSH
74986: LD_EXP 100
74990: PUSH
74991: LD_VAR 0 1
74995: ARRAY
74996: PUSH
74997: LD_INT 1
74999: PLUS
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PPUSH
75005: LD_VAR 0 4
75009: PPUSH
75010: CALL 18548 0 3
75014: ST_TO_ADDR
75015: GO 74968
75017: POP
75018: POP
// end ;
75019: LD_VAR 0 3
75023: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
75024: LD_INT 0
75026: PPUSH
// if not mc_bases or not base or not areas then
75027: LD_EXP 66
75031: NOT
75032: PUSH
75033: LD_VAR 0 1
75037: NOT
75038: OR
75039: PUSH
75040: LD_VAR 0 2
75044: NOT
75045: OR
75046: IFFALSE 75050
// exit ;
75048: GO 75075
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
75050: LD_ADDR_EXP 84
75054: PUSH
75055: LD_EXP 84
75059: PPUSH
75060: LD_VAR 0 1
75064: PPUSH
75065: LD_VAR 0 2
75069: PPUSH
75070: CALL_OW 1
75074: ST_TO_ADDR
// end ;
75075: LD_VAR 0 3
75079: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
75080: LD_INT 0
75082: PPUSH
// if not mc_bases or not base or not teleports_exit then
75083: LD_EXP 66
75087: NOT
75088: PUSH
75089: LD_VAR 0 1
75093: NOT
75094: OR
75095: PUSH
75096: LD_VAR 0 2
75100: NOT
75101: OR
75102: IFFALSE 75106
// exit ;
75104: GO 75131
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
75106: LD_ADDR_EXP 101
75110: PUSH
75111: LD_EXP 101
75115: PPUSH
75116: LD_VAR 0 1
75120: PPUSH
75121: LD_VAR 0 2
75125: PPUSH
75126: CALL_OW 1
75130: ST_TO_ADDR
// end ;
75131: LD_VAR 0 3
75135: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
75136: LD_INT 0
75138: PPUSH
75139: PPUSH
75140: PPUSH
// if not mc_bases or not base or not ext_list then
75141: LD_EXP 66
75145: NOT
75146: PUSH
75147: LD_VAR 0 1
75151: NOT
75152: OR
75153: PUSH
75154: LD_VAR 0 5
75158: NOT
75159: OR
75160: IFFALSE 75164
// exit ;
75162: GO 75337
// tmp := GetFacExtXYD ( x , y , d ) ;
75164: LD_ADDR_VAR 0 8
75168: PUSH
75169: LD_VAR 0 2
75173: PPUSH
75174: LD_VAR 0 3
75178: PPUSH
75179: LD_VAR 0 4
75183: PPUSH
75184: CALL 47227 0 3
75188: ST_TO_ADDR
// if not tmp then
75189: LD_VAR 0 8
75193: NOT
75194: IFFALSE 75198
// exit ;
75196: GO 75337
// for i in tmp do
75198: LD_ADDR_VAR 0 7
75202: PUSH
75203: LD_VAR 0 8
75207: PUSH
75208: FOR_IN
75209: IFFALSE 75335
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
75211: LD_ADDR_EXP 71
75215: PUSH
75216: LD_EXP 71
75220: PPUSH
75221: LD_VAR 0 1
75225: PPUSH
75226: LD_EXP 71
75230: PUSH
75231: LD_VAR 0 1
75235: ARRAY
75236: PPUSH
75237: LD_EXP 71
75241: PUSH
75242: LD_VAR 0 1
75246: ARRAY
75247: PUSH
75248: LD_INT 1
75250: PLUS
75251: PPUSH
75252: LD_VAR 0 5
75256: PUSH
75257: LD_INT 1
75259: ARRAY
75260: PUSH
75261: LD_VAR 0 7
75265: PUSH
75266: LD_INT 1
75268: ARRAY
75269: PUSH
75270: LD_VAR 0 7
75274: PUSH
75275: LD_INT 2
75277: ARRAY
75278: PUSH
75279: LD_VAR 0 7
75283: PUSH
75284: LD_INT 3
75286: ARRAY
75287: PUSH
75288: EMPTY
75289: LIST
75290: LIST
75291: LIST
75292: LIST
75293: PPUSH
75294: CALL_OW 2
75298: PPUSH
75299: CALL_OW 1
75303: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
75304: LD_ADDR_VAR 0 5
75308: PUSH
75309: LD_VAR 0 5
75313: PPUSH
75314: LD_INT 1
75316: PPUSH
75317: CALL_OW 3
75321: ST_TO_ADDR
// if not ext_list then
75322: LD_VAR 0 5
75326: NOT
75327: IFFALSE 75333
// exit ;
75329: POP
75330: POP
75331: GO 75337
// end ;
75333: GO 75208
75335: POP
75336: POP
// end ;
75337: LD_VAR 0 6
75341: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
75342: LD_INT 0
75344: PPUSH
// if not mc_bases or not base or not weapon_list then
75345: LD_EXP 66
75349: NOT
75350: PUSH
75351: LD_VAR 0 1
75355: NOT
75356: OR
75357: PUSH
75358: LD_VAR 0 2
75362: NOT
75363: OR
75364: IFFALSE 75368
// exit ;
75366: GO 75393
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
75368: LD_ADDR_EXP 105
75372: PUSH
75373: LD_EXP 105
75377: PPUSH
75378: LD_VAR 0 1
75382: PPUSH
75383: LD_VAR 0 2
75387: PPUSH
75388: CALL_OW 1
75392: ST_TO_ADDR
// end ;
75393: LD_VAR 0 3
75397: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
75398: LD_INT 0
75400: PPUSH
// if not mc_bases or not base or not tech_list then
75401: LD_EXP 66
75405: NOT
75406: PUSH
75407: LD_VAR 0 1
75411: NOT
75412: OR
75413: PUSH
75414: LD_VAR 0 2
75418: NOT
75419: OR
75420: IFFALSE 75424
// exit ;
75422: GO 75449
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
75424: LD_ADDR_EXP 93
75428: PUSH
75429: LD_EXP 93
75433: PPUSH
75434: LD_VAR 0 1
75438: PPUSH
75439: LD_VAR 0 2
75443: PPUSH
75444: CALL_OW 1
75448: ST_TO_ADDR
// end ;
75449: LD_VAR 0 3
75453: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
75454: LD_INT 0
75456: PPUSH
// if not mc_bases or not parking_area or not base then
75457: LD_EXP 66
75461: NOT
75462: PUSH
75463: LD_VAR 0 2
75467: NOT
75468: OR
75469: PUSH
75470: LD_VAR 0 1
75474: NOT
75475: OR
75476: IFFALSE 75480
// exit ;
75478: GO 75505
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
75480: LD_ADDR_EXP 90
75484: PUSH
75485: LD_EXP 90
75489: PPUSH
75490: LD_VAR 0 1
75494: PPUSH
75495: LD_VAR 0 2
75499: PPUSH
75500: CALL_OW 1
75504: ST_TO_ADDR
// end ;
75505: LD_VAR 0 3
75509: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
75510: LD_INT 0
75512: PPUSH
// if not mc_bases or not base or not scan_area then
75513: LD_EXP 66
75517: NOT
75518: PUSH
75519: LD_VAR 0 1
75523: NOT
75524: OR
75525: PUSH
75526: LD_VAR 0 2
75530: NOT
75531: OR
75532: IFFALSE 75536
// exit ;
75534: GO 75561
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
75536: LD_ADDR_EXP 91
75540: PUSH
75541: LD_EXP 91
75545: PPUSH
75546: LD_VAR 0 1
75550: PPUSH
75551: LD_VAR 0 2
75555: PPUSH
75556: CALL_OW 1
75560: ST_TO_ADDR
// end ;
75561: LD_VAR 0 3
75565: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
75566: LD_INT 0
75568: PPUSH
75569: PPUSH
// if not mc_bases or not base then
75570: LD_EXP 66
75574: NOT
75575: PUSH
75576: LD_VAR 0 1
75580: NOT
75581: OR
75582: IFFALSE 75586
// exit ;
75584: GO 75650
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
75586: LD_ADDR_VAR 0 3
75590: PUSH
75591: LD_INT 1
75593: PUSH
75594: LD_INT 2
75596: PUSH
75597: LD_INT 3
75599: PUSH
75600: LD_INT 4
75602: PUSH
75603: LD_INT 11
75605: PUSH
75606: EMPTY
75607: LIST
75608: LIST
75609: LIST
75610: LIST
75611: LIST
75612: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
75613: LD_ADDR_EXP 93
75617: PUSH
75618: LD_EXP 93
75622: PPUSH
75623: LD_VAR 0 1
75627: PPUSH
75628: LD_EXP 93
75632: PUSH
75633: LD_VAR 0 1
75637: ARRAY
75638: PUSH
75639: LD_VAR 0 3
75643: DIFF
75644: PPUSH
75645: CALL_OW 1
75649: ST_TO_ADDR
// end ;
75650: LD_VAR 0 2
75654: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
75655: LD_INT 0
75657: PPUSH
// result := mc_vehicles [ base ] ;
75658: LD_ADDR_VAR 0 3
75662: PUSH
75663: LD_EXP 85
75667: PUSH
75668: LD_VAR 0 1
75672: ARRAY
75673: ST_TO_ADDR
// if onlyCombat then
75674: LD_VAR 0 2
75678: IFFALSE 75843
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
75680: LD_ADDR_VAR 0 3
75684: PUSH
75685: LD_VAR 0 3
75689: PUSH
75690: LD_VAR 0 3
75694: PPUSH
75695: LD_INT 2
75697: PUSH
75698: LD_INT 34
75700: PUSH
75701: LD_INT 12
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: PUSH
75708: LD_INT 34
75710: PUSH
75711: LD_INT 51
75713: PUSH
75714: EMPTY
75715: LIST
75716: LIST
75717: PUSH
75718: LD_INT 34
75720: PUSH
75721: LD_EXP 49
75725: PUSH
75726: EMPTY
75727: LIST
75728: LIST
75729: PUSH
75730: LD_INT 34
75732: PUSH
75733: LD_INT 32
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 34
75742: PUSH
75743: LD_INT 13
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: PUSH
75750: LD_INT 34
75752: PUSH
75753: LD_INT 52
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: PUSH
75760: LD_INT 34
75762: PUSH
75763: LD_INT 14
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PUSH
75770: LD_INT 34
75772: PUSH
75773: LD_INT 53
75775: PUSH
75776: EMPTY
75777: LIST
75778: LIST
75779: PUSH
75780: LD_INT 34
75782: PUSH
75783: LD_EXP 48
75787: PUSH
75788: EMPTY
75789: LIST
75790: LIST
75791: PUSH
75792: LD_INT 34
75794: PUSH
75795: LD_INT 31
75797: PUSH
75798: EMPTY
75799: LIST
75800: LIST
75801: PUSH
75802: LD_INT 34
75804: PUSH
75805: LD_INT 48
75807: PUSH
75808: EMPTY
75809: LIST
75810: LIST
75811: PUSH
75812: LD_INT 34
75814: PUSH
75815: LD_INT 8
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: PUSH
75822: EMPTY
75823: LIST
75824: LIST
75825: LIST
75826: LIST
75827: LIST
75828: LIST
75829: LIST
75830: LIST
75831: LIST
75832: LIST
75833: LIST
75834: LIST
75835: LIST
75836: PPUSH
75837: CALL_OW 72
75841: DIFF
75842: ST_TO_ADDR
// end ; end_of_file
75843: LD_VAR 0 3
75847: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
75848: LD_INT 0
75850: PPUSH
75851: PPUSH
75852: PPUSH
// if not mc_bases or not skirmish then
75853: LD_EXP 66
75857: NOT
75858: PUSH
75859: LD_EXP 64
75863: NOT
75864: OR
75865: IFFALSE 75869
// exit ;
75867: GO 76034
// for i = 1 to mc_bases do
75869: LD_ADDR_VAR 0 4
75873: PUSH
75874: DOUBLE
75875: LD_INT 1
75877: DEC
75878: ST_TO_ADDR
75879: LD_EXP 66
75883: PUSH
75884: FOR_TO
75885: IFFALSE 76032
// begin if sci in mc_bases [ i ] then
75887: LD_VAR 0 2
75891: PUSH
75892: LD_EXP 66
75896: PUSH
75897: LD_VAR 0 4
75901: ARRAY
75902: IN
75903: IFFALSE 76030
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
75905: LD_ADDR_EXP 95
75909: PUSH
75910: LD_EXP 95
75914: PPUSH
75915: LD_VAR 0 4
75919: PUSH
75920: LD_EXP 95
75924: PUSH
75925: LD_VAR 0 4
75929: ARRAY
75930: PUSH
75931: LD_INT 1
75933: PLUS
75934: PUSH
75935: EMPTY
75936: LIST
75937: LIST
75938: PPUSH
75939: LD_VAR 0 1
75943: PPUSH
75944: CALL 18548 0 3
75948: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
75949: LD_ADDR_VAR 0 5
75953: PUSH
75954: LD_EXP 66
75958: PUSH
75959: LD_VAR 0 4
75963: ARRAY
75964: PPUSH
75965: LD_INT 2
75967: PUSH
75968: LD_INT 30
75970: PUSH
75971: LD_INT 0
75973: PUSH
75974: EMPTY
75975: LIST
75976: LIST
75977: PUSH
75978: LD_INT 30
75980: PUSH
75981: LD_INT 1
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: PUSH
75988: EMPTY
75989: LIST
75990: LIST
75991: LIST
75992: PPUSH
75993: CALL_OW 72
75997: PPUSH
75998: LD_VAR 0 1
76002: PPUSH
76003: CALL_OW 74
76007: ST_TO_ADDR
// if tmp then
76008: LD_VAR 0 5
76012: IFFALSE 76028
// ComStandNearbyBuilding ( ape , tmp ) ;
76014: LD_VAR 0 1
76018: PPUSH
76019: LD_VAR 0 5
76023: PPUSH
76024: CALL 15162 0 2
// break ;
76028: GO 76032
// end ; end ;
76030: GO 75884
76032: POP
76033: POP
// end ;
76034: LD_VAR 0 3
76038: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
76039: LD_INT 0
76041: PPUSH
76042: PPUSH
76043: PPUSH
// if not mc_bases or not skirmish then
76044: LD_EXP 66
76048: NOT
76049: PUSH
76050: LD_EXP 64
76054: NOT
76055: OR
76056: IFFALSE 76060
// exit ;
76058: GO 76149
// for i = 1 to mc_bases do
76060: LD_ADDR_VAR 0 4
76064: PUSH
76065: DOUBLE
76066: LD_INT 1
76068: DEC
76069: ST_TO_ADDR
76070: LD_EXP 66
76074: PUSH
76075: FOR_TO
76076: IFFALSE 76147
// begin if building in mc_busy_turret_list [ i ] then
76078: LD_VAR 0 1
76082: PUSH
76083: LD_EXP 76
76087: PUSH
76088: LD_VAR 0 4
76092: ARRAY
76093: IN
76094: IFFALSE 76145
// begin tmp := mc_busy_turret_list [ i ] diff building ;
76096: LD_ADDR_VAR 0 5
76100: PUSH
76101: LD_EXP 76
76105: PUSH
76106: LD_VAR 0 4
76110: ARRAY
76111: PUSH
76112: LD_VAR 0 1
76116: DIFF
76117: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
76118: LD_ADDR_EXP 76
76122: PUSH
76123: LD_EXP 76
76127: PPUSH
76128: LD_VAR 0 4
76132: PPUSH
76133: LD_VAR 0 5
76137: PPUSH
76138: CALL_OW 1
76142: ST_TO_ADDR
// break ;
76143: GO 76147
// end ; end ;
76145: GO 76075
76147: POP
76148: POP
// end ;
76149: LD_VAR 0 3
76153: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
76154: LD_INT 0
76156: PPUSH
76157: PPUSH
76158: PPUSH
// if not mc_bases or not skirmish then
76159: LD_EXP 66
76163: NOT
76164: PUSH
76165: LD_EXP 64
76169: NOT
76170: OR
76171: IFFALSE 76175
// exit ;
76173: GO 76374
// for i = 1 to mc_bases do
76175: LD_ADDR_VAR 0 5
76179: PUSH
76180: DOUBLE
76181: LD_INT 1
76183: DEC
76184: ST_TO_ADDR
76185: LD_EXP 66
76189: PUSH
76190: FOR_TO
76191: IFFALSE 76372
// if building in mc_bases [ i ] then
76193: LD_VAR 0 1
76197: PUSH
76198: LD_EXP 66
76202: PUSH
76203: LD_VAR 0 5
76207: ARRAY
76208: IN
76209: IFFALSE 76370
// begin tmp := mc_bases [ i ] diff building ;
76211: LD_ADDR_VAR 0 6
76215: PUSH
76216: LD_EXP 66
76220: PUSH
76221: LD_VAR 0 5
76225: ARRAY
76226: PUSH
76227: LD_VAR 0 1
76231: DIFF
76232: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
76233: LD_ADDR_EXP 66
76237: PUSH
76238: LD_EXP 66
76242: PPUSH
76243: LD_VAR 0 5
76247: PPUSH
76248: LD_VAR 0 6
76252: PPUSH
76253: CALL_OW 1
76257: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
76258: LD_VAR 0 1
76262: PUSH
76263: LD_EXP 74
76267: PUSH
76268: LD_VAR 0 5
76272: ARRAY
76273: IN
76274: IFFALSE 76313
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
76276: LD_ADDR_EXP 74
76280: PUSH
76281: LD_EXP 74
76285: PPUSH
76286: LD_VAR 0 5
76290: PPUSH
76291: LD_EXP 74
76295: PUSH
76296: LD_VAR 0 5
76300: ARRAY
76301: PUSH
76302: LD_VAR 0 1
76306: DIFF
76307: PPUSH
76308: CALL_OW 1
76312: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
76313: LD_VAR 0 1
76317: PUSH
76318: LD_EXP 75
76322: PUSH
76323: LD_VAR 0 5
76327: ARRAY
76328: IN
76329: IFFALSE 76368
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
76331: LD_ADDR_EXP 75
76335: PUSH
76336: LD_EXP 75
76340: PPUSH
76341: LD_VAR 0 5
76345: PPUSH
76346: LD_EXP 75
76350: PUSH
76351: LD_VAR 0 5
76355: ARRAY
76356: PUSH
76357: LD_VAR 0 1
76361: DIFF
76362: PPUSH
76363: CALL_OW 1
76367: ST_TO_ADDR
// break ;
76368: GO 76372
// end ;
76370: GO 76190
76372: POP
76373: POP
// end ;
76374: LD_VAR 0 4
76378: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
76379: LD_INT 0
76381: PPUSH
76382: PPUSH
76383: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
76384: LD_EXP 66
76388: NOT
76389: PUSH
76390: LD_EXP 64
76394: NOT
76395: OR
76396: PUSH
76397: LD_VAR 0 3
76401: PUSH
76402: LD_EXP 92
76406: IN
76407: NOT
76408: OR
76409: IFFALSE 76413
// exit ;
76411: GO 76536
// for i = 1 to mc_vehicles do
76413: LD_ADDR_VAR 0 6
76417: PUSH
76418: DOUBLE
76419: LD_INT 1
76421: DEC
76422: ST_TO_ADDR
76423: LD_EXP 85
76427: PUSH
76428: FOR_TO
76429: IFFALSE 76534
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
76431: LD_VAR 0 2
76435: PUSH
76436: LD_EXP 85
76440: PUSH
76441: LD_VAR 0 6
76445: ARRAY
76446: IN
76447: PUSH
76448: LD_VAR 0 1
76452: PUSH
76453: LD_EXP 85
76457: PUSH
76458: LD_VAR 0 6
76462: ARRAY
76463: IN
76464: OR
76465: IFFALSE 76532
// begin tmp := mc_vehicles [ i ] diff old ;
76467: LD_ADDR_VAR 0 7
76471: PUSH
76472: LD_EXP 85
76476: PUSH
76477: LD_VAR 0 6
76481: ARRAY
76482: PUSH
76483: LD_VAR 0 2
76487: DIFF
76488: ST_TO_ADDR
// tmp := tmp diff new ;
76489: LD_ADDR_VAR 0 7
76493: PUSH
76494: LD_VAR 0 7
76498: PUSH
76499: LD_VAR 0 1
76503: DIFF
76504: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
76505: LD_ADDR_EXP 85
76509: PUSH
76510: LD_EXP 85
76514: PPUSH
76515: LD_VAR 0 6
76519: PPUSH
76520: LD_VAR 0 7
76524: PPUSH
76525: CALL_OW 1
76529: ST_TO_ADDR
// break ;
76530: GO 76534
// end ;
76532: GO 76428
76534: POP
76535: POP
// end ;
76536: LD_VAR 0 5
76540: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
76541: LD_INT 0
76543: PPUSH
76544: PPUSH
76545: PPUSH
76546: PPUSH
// if not mc_bases or not skirmish then
76547: LD_EXP 66
76551: NOT
76552: PUSH
76553: LD_EXP 64
76557: NOT
76558: OR
76559: IFFALSE 76563
// exit ;
76561: GO 76940
// side := GetSide ( vehicle ) ;
76563: LD_ADDR_VAR 0 5
76567: PUSH
76568: LD_VAR 0 1
76572: PPUSH
76573: CALL_OW 255
76577: ST_TO_ADDR
// for i = 1 to mc_bases do
76578: LD_ADDR_VAR 0 4
76582: PUSH
76583: DOUBLE
76584: LD_INT 1
76586: DEC
76587: ST_TO_ADDR
76588: LD_EXP 66
76592: PUSH
76593: FOR_TO
76594: IFFALSE 76938
// begin if factory in mc_bases [ i ] then
76596: LD_VAR 0 2
76600: PUSH
76601: LD_EXP 66
76605: PUSH
76606: LD_VAR 0 4
76610: ARRAY
76611: IN
76612: IFFALSE 76936
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
76614: LD_EXP 88
76618: PUSH
76619: LD_VAR 0 4
76623: ARRAY
76624: PUSH
76625: LD_EXP 77
76629: PUSH
76630: LD_VAR 0 4
76634: ARRAY
76635: LESS
76636: PUSH
76637: LD_VAR 0 1
76641: PPUSH
76642: CALL_OW 264
76646: PUSH
76647: LD_INT 31
76649: PUSH
76650: LD_INT 32
76652: PUSH
76653: LD_INT 51
76655: PUSH
76656: LD_EXP 49
76660: PUSH
76661: LD_INT 12
76663: PUSH
76664: LD_INT 30
76666: PUSH
76667: LD_EXP 48
76671: PUSH
76672: LD_INT 11
76674: PUSH
76675: LD_INT 53
76677: PUSH
76678: LD_INT 14
76680: PUSH
76681: LD_EXP 52
76685: PUSH
76686: LD_INT 29
76688: PUSH
76689: LD_EXP 50
76693: PUSH
76694: LD_INT 13
76696: PUSH
76697: LD_INT 52
76699: PUSH
76700: LD_INT 48
76702: PUSH
76703: LD_INT 8
76705: PUSH
76706: EMPTY
76707: LIST
76708: LIST
76709: LIST
76710: LIST
76711: LIST
76712: LIST
76713: LIST
76714: LIST
76715: LIST
76716: LIST
76717: LIST
76718: LIST
76719: LIST
76720: LIST
76721: LIST
76722: LIST
76723: LIST
76724: IN
76725: NOT
76726: AND
76727: IFFALSE 76775
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
76729: LD_ADDR_EXP 88
76733: PUSH
76734: LD_EXP 88
76738: PPUSH
76739: LD_VAR 0 4
76743: PUSH
76744: LD_EXP 88
76748: PUSH
76749: LD_VAR 0 4
76753: ARRAY
76754: PUSH
76755: LD_INT 1
76757: PLUS
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PPUSH
76763: LD_VAR 0 1
76767: PPUSH
76768: CALL 18548 0 3
76772: ST_TO_ADDR
76773: GO 76819
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
76775: LD_ADDR_EXP 85
76779: PUSH
76780: LD_EXP 85
76784: PPUSH
76785: LD_VAR 0 4
76789: PUSH
76790: LD_EXP 85
76794: PUSH
76795: LD_VAR 0 4
76799: ARRAY
76800: PUSH
76801: LD_INT 1
76803: PLUS
76804: PUSH
76805: EMPTY
76806: LIST
76807: LIST
76808: PPUSH
76809: LD_VAR 0 1
76813: PPUSH
76814: CALL 18548 0 3
76818: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
76819: LD_VAR 0 1
76823: PPUSH
76824: CALL_OW 263
76828: PUSH
76829: LD_INT 2
76831: EQUAL
76832: IFFALSE 76852
// begin repeat wait ( 0 0$1 ) ;
76834: LD_INT 35
76836: PPUSH
76837: CALL_OW 67
// until IsControledBy ( vehicle ) ;
76841: LD_VAR 0 1
76845: PPUSH
76846: CALL_OW 312
76850: IFFALSE 76834
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
76852: LD_VAR 0 1
76856: PPUSH
76857: LD_EXP 90
76861: PUSH
76862: LD_VAR 0 4
76866: ARRAY
76867: PPUSH
76868: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
76872: LD_VAR 0 1
76876: PPUSH
76877: CALL_OW 263
76881: PUSH
76882: LD_INT 1
76884: NONEQUAL
76885: IFFALSE 76889
// break ;
76887: GO 76938
// repeat wait ( 0 0$1 ) ;
76889: LD_INT 35
76891: PPUSH
76892: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
76896: LD_VAR 0 1
76900: PPUSH
76901: LD_EXP 90
76905: PUSH
76906: LD_VAR 0 4
76910: ARRAY
76911: PPUSH
76912: CALL_OW 308
76916: IFFALSE 76889
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
76918: LD_VAR 0 1
76922: PPUSH
76923: CALL_OW 311
76927: PPUSH
76928: CALL_OW 121
// exit ;
76932: POP
76933: POP
76934: GO 76940
// end ; end ;
76936: GO 76593
76938: POP
76939: POP
// end ;
76940: LD_VAR 0 3
76944: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
76945: LD_INT 0
76947: PPUSH
76948: PPUSH
76949: PPUSH
76950: PPUSH
// if not mc_bases or not skirmish then
76951: LD_EXP 66
76955: NOT
76956: PUSH
76957: LD_EXP 64
76961: NOT
76962: OR
76963: IFFALSE 76967
// exit ;
76965: GO 77320
// repeat wait ( 0 0$1 ) ;
76967: LD_INT 35
76969: PPUSH
76970: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
76974: LD_VAR 0 2
76978: PPUSH
76979: LD_VAR 0 3
76983: PPUSH
76984: CALL_OW 284
76988: IFFALSE 76967
// if GetResourceTypeXY ( x , y ) = mat_artefact then
76990: LD_VAR 0 2
76994: PPUSH
76995: LD_VAR 0 3
76999: PPUSH
77000: CALL_OW 283
77004: PUSH
77005: LD_INT 4
77007: EQUAL
77008: IFFALSE 77012
// exit ;
77010: GO 77320
// for i = 1 to mc_bases do
77012: LD_ADDR_VAR 0 7
77016: PUSH
77017: DOUBLE
77018: LD_INT 1
77020: DEC
77021: ST_TO_ADDR
77022: LD_EXP 66
77026: PUSH
77027: FOR_TO
77028: IFFALSE 77318
// begin if mc_crates_area [ i ] then
77030: LD_EXP 84
77034: PUSH
77035: LD_VAR 0 7
77039: ARRAY
77040: IFFALSE 77151
// for j in mc_crates_area [ i ] do
77042: LD_ADDR_VAR 0 8
77046: PUSH
77047: LD_EXP 84
77051: PUSH
77052: LD_VAR 0 7
77056: ARRAY
77057: PUSH
77058: FOR_IN
77059: IFFALSE 77149
// if InArea ( x , y , j ) then
77061: LD_VAR 0 2
77065: PPUSH
77066: LD_VAR 0 3
77070: PPUSH
77071: LD_VAR 0 8
77075: PPUSH
77076: CALL_OW 309
77080: IFFALSE 77147
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77082: LD_ADDR_EXP 82
77086: PUSH
77087: LD_EXP 82
77091: PPUSH
77092: LD_VAR 0 7
77096: PUSH
77097: LD_EXP 82
77101: PUSH
77102: LD_VAR 0 7
77106: ARRAY
77107: PUSH
77108: LD_INT 1
77110: PLUS
77111: PUSH
77112: EMPTY
77113: LIST
77114: LIST
77115: PPUSH
77116: LD_VAR 0 4
77120: PUSH
77121: LD_VAR 0 2
77125: PUSH
77126: LD_VAR 0 3
77130: PUSH
77131: EMPTY
77132: LIST
77133: LIST
77134: LIST
77135: PPUSH
77136: CALL 18548 0 3
77140: ST_TO_ADDR
// exit ;
77141: POP
77142: POP
77143: POP
77144: POP
77145: GO 77320
// end ;
77147: GO 77058
77149: POP
77150: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77151: LD_ADDR_VAR 0 9
77155: PUSH
77156: LD_EXP 66
77160: PUSH
77161: LD_VAR 0 7
77165: ARRAY
77166: PPUSH
77167: LD_INT 2
77169: PUSH
77170: LD_INT 30
77172: PUSH
77173: LD_INT 0
77175: PUSH
77176: EMPTY
77177: LIST
77178: LIST
77179: PUSH
77180: LD_INT 30
77182: PUSH
77183: LD_INT 1
77185: PUSH
77186: EMPTY
77187: LIST
77188: LIST
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: LIST
77194: PPUSH
77195: CALL_OW 72
77199: ST_TO_ADDR
// if not depot then
77200: LD_VAR 0 9
77204: NOT
77205: IFFALSE 77209
// continue ;
77207: GO 77027
// for j in depot do
77209: LD_ADDR_VAR 0 8
77213: PUSH
77214: LD_VAR 0 9
77218: PUSH
77219: FOR_IN
77220: IFFALSE 77314
// if GetDistUnitXY ( j , x , y ) < 30 then
77222: LD_VAR 0 8
77226: PPUSH
77227: LD_VAR 0 2
77231: PPUSH
77232: LD_VAR 0 3
77236: PPUSH
77237: CALL_OW 297
77241: PUSH
77242: LD_INT 30
77244: LESS
77245: IFFALSE 77312
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77247: LD_ADDR_EXP 82
77251: PUSH
77252: LD_EXP 82
77256: PPUSH
77257: LD_VAR 0 7
77261: PUSH
77262: LD_EXP 82
77266: PUSH
77267: LD_VAR 0 7
77271: ARRAY
77272: PUSH
77273: LD_INT 1
77275: PLUS
77276: PUSH
77277: EMPTY
77278: LIST
77279: LIST
77280: PPUSH
77281: LD_VAR 0 4
77285: PUSH
77286: LD_VAR 0 2
77290: PUSH
77291: LD_VAR 0 3
77295: PUSH
77296: EMPTY
77297: LIST
77298: LIST
77299: LIST
77300: PPUSH
77301: CALL 18548 0 3
77305: ST_TO_ADDR
// exit ;
77306: POP
77307: POP
77308: POP
77309: POP
77310: GO 77320
// end ;
77312: GO 77219
77314: POP
77315: POP
// end ;
77316: GO 77027
77318: POP
77319: POP
// end ;
77320: LD_VAR 0 6
77324: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
77325: LD_INT 0
77327: PPUSH
77328: PPUSH
77329: PPUSH
77330: PPUSH
// if not mc_bases or not skirmish then
77331: LD_EXP 66
77335: NOT
77336: PUSH
77337: LD_EXP 64
77341: NOT
77342: OR
77343: IFFALSE 77347
// exit ;
77345: GO 77624
// side := GetSide ( lab ) ;
77347: LD_ADDR_VAR 0 4
77351: PUSH
77352: LD_VAR 0 2
77356: PPUSH
77357: CALL_OW 255
77361: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
77362: LD_VAR 0 4
77366: PUSH
77367: LD_EXP 92
77371: IN
77372: NOT
77373: PUSH
77374: LD_EXP 93
77378: NOT
77379: OR
77380: PUSH
77381: LD_EXP 66
77385: NOT
77386: OR
77387: IFFALSE 77391
// exit ;
77389: GO 77624
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
77391: LD_ADDR_EXP 93
77395: PUSH
77396: LD_EXP 93
77400: PPUSH
77401: LD_VAR 0 4
77405: PPUSH
77406: LD_EXP 93
77410: PUSH
77411: LD_VAR 0 4
77415: ARRAY
77416: PUSH
77417: LD_VAR 0 1
77421: DIFF
77422: PPUSH
77423: CALL_OW 1
77427: ST_TO_ADDR
// for i = 1 to mc_bases do
77428: LD_ADDR_VAR 0 5
77432: PUSH
77433: DOUBLE
77434: LD_INT 1
77436: DEC
77437: ST_TO_ADDR
77438: LD_EXP 66
77442: PUSH
77443: FOR_TO
77444: IFFALSE 77622
// begin if lab in mc_bases [ i ] then
77446: LD_VAR 0 2
77450: PUSH
77451: LD_EXP 66
77455: PUSH
77456: LD_VAR 0 5
77460: ARRAY
77461: IN
77462: IFFALSE 77620
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
77464: LD_VAR 0 1
77468: PUSH
77469: LD_INT 11
77471: PUSH
77472: LD_INT 4
77474: PUSH
77475: LD_INT 3
77477: PUSH
77478: LD_INT 2
77480: PUSH
77481: EMPTY
77482: LIST
77483: LIST
77484: LIST
77485: LIST
77486: IN
77487: PUSH
77488: LD_EXP 96
77492: PUSH
77493: LD_VAR 0 5
77497: ARRAY
77498: AND
77499: IFFALSE 77620
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
77501: LD_ADDR_VAR 0 6
77505: PUSH
77506: LD_EXP 96
77510: PUSH
77511: LD_VAR 0 5
77515: ARRAY
77516: PUSH
77517: LD_INT 1
77519: ARRAY
77520: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77521: LD_ADDR_EXP 96
77525: PUSH
77526: LD_EXP 96
77530: PPUSH
77531: LD_VAR 0 5
77535: PPUSH
77536: EMPTY
77537: PPUSH
77538: CALL_OW 1
77542: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
77543: LD_VAR 0 6
77547: PPUSH
77548: LD_INT 0
77550: PPUSH
77551: CALL_OW 109
// ComExitBuilding ( tmp ) ;
77555: LD_VAR 0 6
77559: PPUSH
77560: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
77564: LD_ADDR_EXP 95
77568: PUSH
77569: LD_EXP 95
77573: PPUSH
77574: LD_VAR 0 5
77578: PPUSH
77579: LD_EXP 95
77583: PUSH
77584: LD_VAR 0 5
77588: ARRAY
77589: PPUSH
77590: LD_INT 1
77592: PPUSH
77593: LD_VAR 0 6
77597: PPUSH
77598: CALL_OW 2
77602: PPUSH
77603: CALL_OW 1
77607: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
77608: LD_VAR 0 5
77612: PPUSH
77613: LD_INT 112
77615: PPUSH
77616: CALL 54636 0 2
// end ; end ; end ;
77620: GO 77443
77622: POP
77623: POP
// end ;
77624: LD_VAR 0 3
77628: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
77629: LD_INT 0
77631: PPUSH
77632: PPUSH
77633: PPUSH
77634: PPUSH
77635: PPUSH
77636: PPUSH
77637: PPUSH
77638: PPUSH
// if not mc_bases or not skirmish then
77639: LD_EXP 66
77643: NOT
77644: PUSH
77645: LD_EXP 64
77649: NOT
77650: OR
77651: IFFALSE 77655
// exit ;
77653: GO 79026
// for i = 1 to mc_bases do
77655: LD_ADDR_VAR 0 3
77659: PUSH
77660: DOUBLE
77661: LD_INT 1
77663: DEC
77664: ST_TO_ADDR
77665: LD_EXP 66
77669: PUSH
77670: FOR_TO
77671: IFFALSE 79024
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
77673: LD_VAR 0 1
77677: PUSH
77678: LD_EXP 66
77682: PUSH
77683: LD_VAR 0 3
77687: ARRAY
77688: IN
77689: PUSH
77690: LD_VAR 0 1
77694: PUSH
77695: LD_EXP 73
77699: PUSH
77700: LD_VAR 0 3
77704: ARRAY
77705: IN
77706: OR
77707: PUSH
77708: LD_VAR 0 1
77712: PUSH
77713: LD_EXP 88
77717: PUSH
77718: LD_VAR 0 3
77722: ARRAY
77723: IN
77724: OR
77725: PUSH
77726: LD_VAR 0 1
77730: PUSH
77731: LD_EXP 85
77735: PUSH
77736: LD_VAR 0 3
77740: ARRAY
77741: IN
77742: OR
77743: PUSH
77744: LD_VAR 0 1
77748: PUSH
77749: LD_EXP 95
77753: PUSH
77754: LD_VAR 0 3
77758: ARRAY
77759: IN
77760: OR
77761: PUSH
77762: LD_VAR 0 1
77766: PUSH
77767: LD_EXP 96
77771: PUSH
77772: LD_VAR 0 3
77776: ARRAY
77777: IN
77778: OR
77779: IFFALSE 79022
// begin if un in mc_ape [ i ] then
77781: LD_VAR 0 1
77785: PUSH
77786: LD_EXP 95
77790: PUSH
77791: LD_VAR 0 3
77795: ARRAY
77796: IN
77797: IFFALSE 77836
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
77799: LD_ADDR_EXP 95
77803: PUSH
77804: LD_EXP 95
77808: PPUSH
77809: LD_VAR 0 3
77813: PPUSH
77814: LD_EXP 95
77818: PUSH
77819: LD_VAR 0 3
77823: ARRAY
77824: PUSH
77825: LD_VAR 0 1
77829: DIFF
77830: PPUSH
77831: CALL_OW 1
77835: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
77836: LD_VAR 0 1
77840: PUSH
77841: LD_EXP 96
77845: PUSH
77846: LD_VAR 0 3
77850: ARRAY
77851: IN
77852: IFFALSE 77876
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77854: LD_ADDR_EXP 96
77858: PUSH
77859: LD_EXP 96
77863: PPUSH
77864: LD_VAR 0 3
77868: PPUSH
77869: EMPTY
77870: PPUSH
77871: CALL_OW 1
77875: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
77876: LD_VAR 0 1
77880: PPUSH
77881: CALL_OW 247
77885: PUSH
77886: LD_INT 2
77888: EQUAL
77889: PUSH
77890: LD_VAR 0 1
77894: PPUSH
77895: CALL_OW 110
77899: PUSH
77900: LD_INT 20
77902: EQUAL
77903: PUSH
77904: LD_VAR 0 1
77908: PUSH
77909: LD_EXP 88
77913: PUSH
77914: LD_VAR 0 3
77918: ARRAY
77919: IN
77920: OR
77921: PUSH
77922: LD_VAR 0 1
77926: PPUSH
77927: CALL_OW 264
77931: PUSH
77932: LD_INT 12
77934: PUSH
77935: LD_INT 51
77937: PUSH
77938: LD_EXP 49
77942: PUSH
77943: LD_INT 32
77945: PUSH
77946: LD_INT 13
77948: PUSH
77949: LD_INT 52
77951: PUSH
77952: LD_INT 31
77954: PUSH
77955: EMPTY
77956: LIST
77957: LIST
77958: LIST
77959: LIST
77960: LIST
77961: LIST
77962: LIST
77963: IN
77964: OR
77965: AND
77966: IFFALSE 78274
// begin if un in mc_defender [ i ] then
77968: LD_VAR 0 1
77972: PUSH
77973: LD_EXP 88
77977: PUSH
77978: LD_VAR 0 3
77982: ARRAY
77983: IN
77984: IFFALSE 78023
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
77986: LD_ADDR_EXP 88
77990: PUSH
77991: LD_EXP 88
77995: PPUSH
77996: LD_VAR 0 3
78000: PPUSH
78001: LD_EXP 88
78005: PUSH
78006: LD_VAR 0 3
78010: ARRAY
78011: PUSH
78012: LD_VAR 0 1
78016: DIFF
78017: PPUSH
78018: CALL_OW 1
78022: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
78023: LD_ADDR_VAR 0 8
78027: PUSH
78028: LD_VAR 0 3
78032: PPUSH
78033: LD_INT 3
78035: PPUSH
78036: CALL 74692 0 2
78040: ST_TO_ADDR
// if fac then
78041: LD_VAR 0 8
78045: IFFALSE 78274
// begin for j in fac do
78047: LD_ADDR_VAR 0 4
78051: PUSH
78052: LD_VAR 0 8
78056: PUSH
78057: FOR_IN
78058: IFFALSE 78272
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
78060: LD_ADDR_VAR 0 9
78064: PUSH
78065: LD_VAR 0 8
78069: PPUSH
78070: LD_VAR 0 1
78074: PPUSH
78075: CALL_OW 265
78079: PPUSH
78080: LD_VAR 0 1
78084: PPUSH
78085: CALL_OW 262
78089: PPUSH
78090: LD_VAR 0 1
78094: PPUSH
78095: CALL_OW 263
78099: PPUSH
78100: LD_VAR 0 1
78104: PPUSH
78105: CALL_OW 264
78109: PPUSH
78110: CALL 16080 0 5
78114: ST_TO_ADDR
// if components then
78115: LD_VAR 0 9
78119: IFFALSE 78270
// begin if GetWeapon ( un ) = ar_control_tower then
78121: LD_VAR 0 1
78125: PPUSH
78126: CALL_OW 264
78130: PUSH
78131: LD_INT 31
78133: EQUAL
78134: IFFALSE 78251
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
78136: LD_VAR 0 1
78140: PPUSH
78141: CALL_OW 311
78145: PPUSH
78146: LD_INT 0
78148: PPUSH
78149: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
78153: LD_ADDR_EXP 106
78157: PUSH
78158: LD_EXP 106
78162: PPUSH
78163: LD_VAR 0 3
78167: PPUSH
78168: LD_EXP 106
78172: PUSH
78173: LD_VAR 0 3
78177: ARRAY
78178: PUSH
78179: LD_VAR 0 1
78183: PPUSH
78184: CALL_OW 311
78188: DIFF
78189: PPUSH
78190: CALL_OW 1
78194: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
78195: LD_ADDR_VAR 0 7
78199: PUSH
78200: LD_EXP 87
78204: PUSH
78205: LD_VAR 0 3
78209: ARRAY
78210: PPUSH
78211: LD_INT 1
78213: PPUSH
78214: LD_VAR 0 9
78218: PPUSH
78219: CALL_OW 2
78223: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
78224: LD_ADDR_EXP 87
78228: PUSH
78229: LD_EXP 87
78233: PPUSH
78234: LD_VAR 0 3
78238: PPUSH
78239: LD_VAR 0 7
78243: PPUSH
78244: CALL_OW 1
78248: ST_TO_ADDR
// end else
78249: GO 78268
// MC_InsertProduceList ( i , [ components ] ) ;
78251: LD_VAR 0 3
78255: PPUSH
78256: LD_VAR 0 9
78260: PUSH
78261: EMPTY
78262: LIST
78263: PPUSH
78264: CALL 74237 0 2
// break ;
78268: GO 78272
// end ; end ;
78270: GO 78057
78272: POP
78273: POP
// end ; end ; if GetType ( un ) = unit_building then
78274: LD_VAR 0 1
78278: PPUSH
78279: CALL_OW 247
78283: PUSH
78284: LD_INT 3
78286: EQUAL
78287: IFFALSE 78690
// begin btype := GetBType ( un ) ;
78289: LD_ADDR_VAR 0 5
78293: PUSH
78294: LD_VAR 0 1
78298: PPUSH
78299: CALL_OW 266
78303: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
78304: LD_VAR 0 5
78308: PUSH
78309: LD_INT 29
78311: PUSH
78312: LD_INT 30
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: IN
78319: IFFALSE 78392
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
78321: LD_VAR 0 1
78325: PPUSH
78326: CALL_OW 250
78330: PPUSH
78331: LD_VAR 0 1
78335: PPUSH
78336: CALL_OW 251
78340: PPUSH
78341: LD_VAR 0 1
78345: PPUSH
78346: CALL_OW 255
78350: PPUSH
78351: CALL_OW 440
78355: NOT
78356: IFFALSE 78392
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
78358: LD_VAR 0 1
78362: PPUSH
78363: CALL_OW 250
78367: PPUSH
78368: LD_VAR 0 1
78372: PPUSH
78373: CALL_OW 251
78377: PPUSH
78378: LD_VAR 0 1
78382: PPUSH
78383: CALL_OW 255
78387: PPUSH
78388: CALL_OW 441
// end ; if btype = b_warehouse then
78392: LD_VAR 0 5
78396: PUSH
78397: LD_INT 1
78399: EQUAL
78400: IFFALSE 78418
// begin btype := b_depot ;
78402: LD_ADDR_VAR 0 5
78406: PUSH
78407: LD_INT 0
78409: ST_TO_ADDR
// pos := 1 ;
78410: LD_ADDR_VAR 0 6
78414: PUSH
78415: LD_INT 1
78417: ST_TO_ADDR
// end ; if btype = b_factory then
78418: LD_VAR 0 5
78422: PUSH
78423: LD_INT 3
78425: EQUAL
78426: IFFALSE 78444
// begin btype := b_workshop ;
78428: LD_ADDR_VAR 0 5
78432: PUSH
78433: LD_INT 2
78435: ST_TO_ADDR
// pos := 1 ;
78436: LD_ADDR_VAR 0 6
78440: PUSH
78441: LD_INT 1
78443: ST_TO_ADDR
// end ; if btype = b_barracks then
78444: LD_VAR 0 5
78448: PUSH
78449: LD_INT 5
78451: EQUAL
78452: IFFALSE 78462
// btype := b_armoury ;
78454: LD_ADDR_VAR 0 5
78458: PUSH
78459: LD_INT 4
78461: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
78462: LD_VAR 0 5
78466: PUSH
78467: LD_INT 7
78469: PUSH
78470: LD_INT 8
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: IN
78477: IFFALSE 78487
// btype := b_lab ;
78479: LD_ADDR_VAR 0 5
78483: PUSH
78484: LD_INT 6
78486: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
78487: LD_ADDR_EXP 71
78491: PUSH
78492: LD_EXP 71
78496: PPUSH
78497: LD_VAR 0 3
78501: PUSH
78502: LD_EXP 71
78506: PUSH
78507: LD_VAR 0 3
78511: ARRAY
78512: PUSH
78513: LD_INT 1
78515: PLUS
78516: PUSH
78517: EMPTY
78518: LIST
78519: LIST
78520: PPUSH
78521: LD_VAR 0 5
78525: PUSH
78526: LD_VAR 0 1
78530: PPUSH
78531: CALL_OW 250
78535: PUSH
78536: LD_VAR 0 1
78540: PPUSH
78541: CALL_OW 251
78545: PUSH
78546: LD_VAR 0 1
78550: PPUSH
78551: CALL_OW 254
78555: PUSH
78556: EMPTY
78557: LIST
78558: LIST
78559: LIST
78560: LIST
78561: PPUSH
78562: CALL 18548 0 3
78566: ST_TO_ADDR
// if pos = 1 then
78567: LD_VAR 0 6
78571: PUSH
78572: LD_INT 1
78574: EQUAL
78575: IFFALSE 78690
// begin tmp := mc_build_list [ i ] ;
78577: LD_ADDR_VAR 0 7
78581: PUSH
78582: LD_EXP 71
78586: PUSH
78587: LD_VAR 0 3
78591: ARRAY
78592: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78593: LD_VAR 0 7
78597: PPUSH
78598: LD_INT 2
78600: PUSH
78601: LD_INT 30
78603: PUSH
78604: LD_INT 0
78606: PUSH
78607: EMPTY
78608: LIST
78609: LIST
78610: PUSH
78611: LD_INT 30
78613: PUSH
78614: LD_INT 1
78616: PUSH
78617: EMPTY
78618: LIST
78619: LIST
78620: PUSH
78621: EMPTY
78622: LIST
78623: LIST
78624: LIST
78625: PPUSH
78626: CALL_OW 72
78630: IFFALSE 78640
// pos := 2 ;
78632: LD_ADDR_VAR 0 6
78636: PUSH
78637: LD_INT 2
78639: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
78640: LD_ADDR_VAR 0 7
78644: PUSH
78645: LD_VAR 0 7
78649: PPUSH
78650: LD_VAR 0 6
78654: PPUSH
78655: LD_VAR 0 7
78659: PPUSH
78660: CALL 18874 0 3
78664: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
78665: LD_ADDR_EXP 71
78669: PUSH
78670: LD_EXP 71
78674: PPUSH
78675: LD_VAR 0 3
78679: PPUSH
78680: LD_VAR 0 7
78684: PPUSH
78685: CALL_OW 1
78689: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
78690: LD_VAR 0 1
78694: PUSH
78695: LD_EXP 66
78699: PUSH
78700: LD_VAR 0 3
78704: ARRAY
78705: IN
78706: IFFALSE 78745
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
78708: LD_ADDR_EXP 66
78712: PUSH
78713: LD_EXP 66
78717: PPUSH
78718: LD_VAR 0 3
78722: PPUSH
78723: LD_EXP 66
78727: PUSH
78728: LD_VAR 0 3
78732: ARRAY
78733: PUSH
78734: LD_VAR 0 1
78738: DIFF
78739: PPUSH
78740: CALL_OW 1
78744: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
78745: LD_VAR 0 1
78749: PUSH
78750: LD_EXP 73
78754: PUSH
78755: LD_VAR 0 3
78759: ARRAY
78760: IN
78761: IFFALSE 78800
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
78763: LD_ADDR_EXP 73
78767: PUSH
78768: LD_EXP 73
78772: PPUSH
78773: LD_VAR 0 3
78777: PPUSH
78778: LD_EXP 73
78782: PUSH
78783: LD_VAR 0 3
78787: ARRAY
78788: PUSH
78789: LD_VAR 0 1
78793: DIFF
78794: PPUSH
78795: CALL_OW 1
78799: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
78800: LD_VAR 0 1
78804: PUSH
78805: LD_EXP 85
78809: PUSH
78810: LD_VAR 0 3
78814: ARRAY
78815: IN
78816: IFFALSE 78855
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
78818: LD_ADDR_EXP 85
78822: PUSH
78823: LD_EXP 85
78827: PPUSH
78828: LD_VAR 0 3
78832: PPUSH
78833: LD_EXP 85
78837: PUSH
78838: LD_VAR 0 3
78842: ARRAY
78843: PUSH
78844: LD_VAR 0 1
78848: DIFF
78849: PPUSH
78850: CALL_OW 1
78854: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
78855: LD_VAR 0 1
78859: PUSH
78860: LD_EXP 88
78864: PUSH
78865: LD_VAR 0 3
78869: ARRAY
78870: IN
78871: IFFALSE 78910
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78873: LD_ADDR_EXP 88
78877: PUSH
78878: LD_EXP 88
78882: PPUSH
78883: LD_VAR 0 3
78887: PPUSH
78888: LD_EXP 88
78892: PUSH
78893: LD_VAR 0 3
78897: ARRAY
78898: PUSH
78899: LD_VAR 0 1
78903: DIFF
78904: PPUSH
78905: CALL_OW 1
78909: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
78910: LD_VAR 0 1
78914: PUSH
78915: LD_EXP 75
78919: PUSH
78920: LD_VAR 0 3
78924: ARRAY
78925: IN
78926: IFFALSE 78965
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
78928: LD_ADDR_EXP 75
78932: PUSH
78933: LD_EXP 75
78937: PPUSH
78938: LD_VAR 0 3
78942: PPUSH
78943: LD_EXP 75
78947: PUSH
78948: LD_VAR 0 3
78952: ARRAY
78953: PUSH
78954: LD_VAR 0 1
78958: DIFF
78959: PPUSH
78960: CALL_OW 1
78964: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
78965: LD_VAR 0 1
78969: PUSH
78970: LD_EXP 74
78974: PUSH
78975: LD_VAR 0 3
78979: ARRAY
78980: IN
78981: IFFALSE 79020
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
78983: LD_ADDR_EXP 74
78987: PUSH
78988: LD_EXP 74
78992: PPUSH
78993: LD_VAR 0 3
78997: PPUSH
78998: LD_EXP 74
79002: PUSH
79003: LD_VAR 0 3
79007: ARRAY
79008: PUSH
79009: LD_VAR 0 1
79013: DIFF
79014: PPUSH
79015: CALL_OW 1
79019: ST_TO_ADDR
// end ; break ;
79020: GO 79024
// end ;
79022: GO 77670
79024: POP
79025: POP
// end ;
79026: LD_VAR 0 2
79030: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
79031: LD_INT 0
79033: PPUSH
79034: PPUSH
79035: PPUSH
// if not mc_bases or not skirmish then
79036: LD_EXP 66
79040: NOT
79041: PUSH
79042: LD_EXP 64
79046: NOT
79047: OR
79048: IFFALSE 79052
// exit ;
79050: GO 79267
// for i = 1 to mc_bases do
79052: LD_ADDR_VAR 0 3
79056: PUSH
79057: DOUBLE
79058: LD_INT 1
79060: DEC
79061: ST_TO_ADDR
79062: LD_EXP 66
79066: PUSH
79067: FOR_TO
79068: IFFALSE 79265
// begin if building in mc_construct_list [ i ] then
79070: LD_VAR 0 1
79074: PUSH
79075: LD_EXP 73
79079: PUSH
79080: LD_VAR 0 3
79084: ARRAY
79085: IN
79086: IFFALSE 79263
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79088: LD_ADDR_EXP 73
79092: PUSH
79093: LD_EXP 73
79097: PPUSH
79098: LD_VAR 0 3
79102: PPUSH
79103: LD_EXP 73
79107: PUSH
79108: LD_VAR 0 3
79112: ARRAY
79113: PUSH
79114: LD_VAR 0 1
79118: DIFF
79119: PPUSH
79120: CALL_OW 1
79124: ST_TO_ADDR
// if building in mc_lab [ i ] then
79125: LD_VAR 0 1
79129: PUSH
79130: LD_EXP 99
79134: PUSH
79135: LD_VAR 0 3
79139: ARRAY
79140: IN
79141: IFFALSE 79196
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
79143: LD_ADDR_EXP 100
79147: PUSH
79148: LD_EXP 100
79152: PPUSH
79153: LD_VAR 0 3
79157: PPUSH
79158: LD_EXP 100
79162: PUSH
79163: LD_VAR 0 3
79167: ARRAY
79168: PPUSH
79169: LD_INT 1
79171: PPUSH
79172: LD_EXP 100
79176: PUSH
79177: LD_VAR 0 3
79181: ARRAY
79182: PPUSH
79183: LD_INT 0
79185: PPUSH
79186: CALL 17966 0 4
79190: PPUSH
79191: CALL_OW 1
79195: ST_TO_ADDR
// if not building in mc_bases [ i ] then
79196: LD_VAR 0 1
79200: PUSH
79201: LD_EXP 66
79205: PUSH
79206: LD_VAR 0 3
79210: ARRAY
79211: IN
79212: NOT
79213: IFFALSE 79259
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79215: LD_ADDR_EXP 66
79219: PUSH
79220: LD_EXP 66
79224: PPUSH
79225: LD_VAR 0 3
79229: PUSH
79230: LD_EXP 66
79234: PUSH
79235: LD_VAR 0 3
79239: ARRAY
79240: PUSH
79241: LD_INT 1
79243: PLUS
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: PPUSH
79249: LD_VAR 0 1
79253: PPUSH
79254: CALL 18548 0 3
79258: ST_TO_ADDR
// exit ;
79259: POP
79260: POP
79261: GO 79267
// end ; end ;
79263: GO 79067
79265: POP
79266: POP
// end ;
79267: LD_VAR 0 2
79271: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
79272: LD_INT 0
79274: PPUSH
79275: PPUSH
79276: PPUSH
79277: PPUSH
79278: PPUSH
79279: PPUSH
79280: PPUSH
// if not mc_bases or not skirmish then
79281: LD_EXP 66
79285: NOT
79286: PUSH
79287: LD_EXP 64
79291: NOT
79292: OR
79293: IFFALSE 79297
// exit ;
79295: GO 79958
// for i = 1 to mc_bases do
79297: LD_ADDR_VAR 0 3
79301: PUSH
79302: DOUBLE
79303: LD_INT 1
79305: DEC
79306: ST_TO_ADDR
79307: LD_EXP 66
79311: PUSH
79312: FOR_TO
79313: IFFALSE 79956
// begin if building in mc_construct_list [ i ] then
79315: LD_VAR 0 1
79319: PUSH
79320: LD_EXP 73
79324: PUSH
79325: LD_VAR 0 3
79329: ARRAY
79330: IN
79331: IFFALSE 79954
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79333: LD_ADDR_EXP 73
79337: PUSH
79338: LD_EXP 73
79342: PPUSH
79343: LD_VAR 0 3
79347: PPUSH
79348: LD_EXP 73
79352: PUSH
79353: LD_VAR 0 3
79357: ARRAY
79358: PUSH
79359: LD_VAR 0 1
79363: DIFF
79364: PPUSH
79365: CALL_OW 1
79369: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79370: LD_ADDR_EXP 66
79374: PUSH
79375: LD_EXP 66
79379: PPUSH
79380: LD_VAR 0 3
79384: PUSH
79385: LD_EXP 66
79389: PUSH
79390: LD_VAR 0 3
79394: ARRAY
79395: PUSH
79396: LD_INT 1
79398: PLUS
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PPUSH
79404: LD_VAR 0 1
79408: PPUSH
79409: CALL 18548 0 3
79413: ST_TO_ADDR
// btype := GetBType ( building ) ;
79414: LD_ADDR_VAR 0 5
79418: PUSH
79419: LD_VAR 0 1
79423: PPUSH
79424: CALL_OW 266
79428: ST_TO_ADDR
// side := GetSide ( building ) ;
79429: LD_ADDR_VAR 0 8
79433: PUSH
79434: LD_VAR 0 1
79438: PPUSH
79439: CALL_OW 255
79443: ST_TO_ADDR
// if btype = b_lab then
79444: LD_VAR 0 5
79448: PUSH
79449: LD_INT 6
79451: EQUAL
79452: IFFALSE 79502
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
79454: LD_ADDR_EXP 99
79458: PUSH
79459: LD_EXP 99
79463: PPUSH
79464: LD_VAR 0 3
79468: PUSH
79469: LD_EXP 99
79473: PUSH
79474: LD_VAR 0 3
79478: ARRAY
79479: PUSH
79480: LD_INT 1
79482: PLUS
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PPUSH
79488: LD_VAR 0 1
79492: PPUSH
79493: CALL 18548 0 3
79497: ST_TO_ADDR
// exit ;
79498: POP
79499: POP
79500: GO 79958
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
79502: LD_VAR 0 5
79506: PUSH
79507: LD_INT 0
79509: PUSH
79510: LD_INT 2
79512: PUSH
79513: LD_INT 4
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: LIST
79520: IN
79521: IFFALSE 79645
// begin if btype = b_armoury then
79523: LD_VAR 0 5
79527: PUSH
79528: LD_INT 4
79530: EQUAL
79531: IFFALSE 79541
// btype := b_barracks ;
79533: LD_ADDR_VAR 0 5
79537: PUSH
79538: LD_INT 5
79540: ST_TO_ADDR
// if btype = b_depot then
79541: LD_VAR 0 5
79545: PUSH
79546: LD_INT 0
79548: EQUAL
79549: IFFALSE 79559
// btype := b_warehouse ;
79551: LD_ADDR_VAR 0 5
79555: PUSH
79556: LD_INT 1
79558: ST_TO_ADDR
// if btype = b_workshop then
79559: LD_VAR 0 5
79563: PUSH
79564: LD_INT 2
79566: EQUAL
79567: IFFALSE 79577
// btype := b_factory ;
79569: LD_ADDR_VAR 0 5
79573: PUSH
79574: LD_INT 3
79576: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
79577: LD_VAR 0 5
79581: PPUSH
79582: LD_VAR 0 8
79586: PPUSH
79587: CALL_OW 323
79591: PUSH
79592: LD_INT 1
79594: EQUAL
79595: IFFALSE 79641
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
79597: LD_ADDR_EXP 98
79601: PUSH
79602: LD_EXP 98
79606: PPUSH
79607: LD_VAR 0 3
79611: PUSH
79612: LD_EXP 98
79616: PUSH
79617: LD_VAR 0 3
79621: ARRAY
79622: PUSH
79623: LD_INT 1
79625: PLUS
79626: PUSH
79627: EMPTY
79628: LIST
79629: LIST
79630: PPUSH
79631: LD_VAR 0 1
79635: PPUSH
79636: CALL 18548 0 3
79640: ST_TO_ADDR
// exit ;
79641: POP
79642: POP
79643: GO 79958
// end ; if btype in [ b_bunker , b_turret ] then
79645: LD_VAR 0 5
79649: PUSH
79650: LD_INT 32
79652: PUSH
79653: LD_INT 33
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: IN
79660: IFFALSE 79950
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
79662: LD_ADDR_EXP 74
79666: PUSH
79667: LD_EXP 74
79671: PPUSH
79672: LD_VAR 0 3
79676: PUSH
79677: LD_EXP 74
79681: PUSH
79682: LD_VAR 0 3
79686: ARRAY
79687: PUSH
79688: LD_INT 1
79690: PLUS
79691: PUSH
79692: EMPTY
79693: LIST
79694: LIST
79695: PPUSH
79696: LD_VAR 0 1
79700: PPUSH
79701: CALL 18548 0 3
79705: ST_TO_ADDR
// if btype = b_bunker then
79706: LD_VAR 0 5
79710: PUSH
79711: LD_INT 32
79713: EQUAL
79714: IFFALSE 79950
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
79716: LD_ADDR_EXP 75
79720: PUSH
79721: LD_EXP 75
79725: PPUSH
79726: LD_VAR 0 3
79730: PUSH
79731: LD_EXP 75
79735: PUSH
79736: LD_VAR 0 3
79740: ARRAY
79741: PUSH
79742: LD_INT 1
79744: PLUS
79745: PUSH
79746: EMPTY
79747: LIST
79748: LIST
79749: PPUSH
79750: LD_VAR 0 1
79754: PPUSH
79755: CALL 18548 0 3
79759: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
79760: LD_ADDR_VAR 0 6
79764: PUSH
79765: LD_EXP 66
79769: PUSH
79770: LD_VAR 0 3
79774: ARRAY
79775: PPUSH
79776: LD_INT 25
79778: PUSH
79779: LD_INT 1
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: PUSH
79786: LD_INT 3
79788: PUSH
79789: LD_INT 54
79791: PUSH
79792: EMPTY
79793: LIST
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: PPUSH
79803: CALL_OW 72
79807: ST_TO_ADDR
// if tmp then
79808: LD_VAR 0 6
79812: IFFALSE 79818
// exit ;
79814: POP
79815: POP
79816: GO 79958
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
79818: LD_ADDR_VAR 0 6
79822: PUSH
79823: LD_EXP 66
79827: PUSH
79828: LD_VAR 0 3
79832: ARRAY
79833: PPUSH
79834: LD_INT 2
79836: PUSH
79837: LD_INT 30
79839: PUSH
79840: LD_INT 4
79842: PUSH
79843: EMPTY
79844: LIST
79845: LIST
79846: PUSH
79847: LD_INT 30
79849: PUSH
79850: LD_INT 5
79852: PUSH
79853: EMPTY
79854: LIST
79855: LIST
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: LIST
79861: PPUSH
79862: CALL_OW 72
79866: ST_TO_ADDR
// if not tmp then
79867: LD_VAR 0 6
79871: NOT
79872: IFFALSE 79878
// exit ;
79874: POP
79875: POP
79876: GO 79958
// for j in tmp do
79878: LD_ADDR_VAR 0 4
79882: PUSH
79883: LD_VAR 0 6
79887: PUSH
79888: FOR_IN
79889: IFFALSE 79948
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
79891: LD_ADDR_VAR 0 7
79895: PUSH
79896: LD_VAR 0 4
79900: PPUSH
79901: CALL_OW 313
79905: PPUSH
79906: LD_INT 25
79908: PUSH
79909: LD_INT 1
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PPUSH
79916: CALL_OW 72
79920: ST_TO_ADDR
// if units then
79921: LD_VAR 0 7
79925: IFFALSE 79946
// begin ComExitBuilding ( units [ 1 ] ) ;
79927: LD_VAR 0 7
79931: PUSH
79932: LD_INT 1
79934: ARRAY
79935: PPUSH
79936: CALL_OW 122
// exit ;
79940: POP
79941: POP
79942: POP
79943: POP
79944: GO 79958
// end ; end ;
79946: GO 79888
79948: POP
79949: POP
// end ; end ; exit ;
79950: POP
79951: POP
79952: GO 79958
// end ; end ;
79954: GO 79312
79956: POP
79957: POP
// end ;
79958: LD_VAR 0 2
79962: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
79963: LD_INT 0
79965: PPUSH
79966: PPUSH
79967: PPUSH
79968: PPUSH
79969: PPUSH
79970: PPUSH
79971: PPUSH
// if not mc_bases or not skirmish then
79972: LD_EXP 66
79976: NOT
79977: PUSH
79978: LD_EXP 64
79982: NOT
79983: OR
79984: IFFALSE 79988
// exit ;
79986: GO 80219
// btype := GetBType ( building ) ;
79988: LD_ADDR_VAR 0 6
79992: PUSH
79993: LD_VAR 0 1
79997: PPUSH
79998: CALL_OW 266
80002: ST_TO_ADDR
// x := GetX ( building ) ;
80003: LD_ADDR_VAR 0 7
80007: PUSH
80008: LD_VAR 0 1
80012: PPUSH
80013: CALL_OW 250
80017: ST_TO_ADDR
// y := GetY ( building ) ;
80018: LD_ADDR_VAR 0 8
80022: PUSH
80023: LD_VAR 0 1
80027: PPUSH
80028: CALL_OW 251
80032: ST_TO_ADDR
// d := GetDir ( building ) ;
80033: LD_ADDR_VAR 0 9
80037: PUSH
80038: LD_VAR 0 1
80042: PPUSH
80043: CALL_OW 254
80047: ST_TO_ADDR
// for i = 1 to mc_bases do
80048: LD_ADDR_VAR 0 4
80052: PUSH
80053: DOUBLE
80054: LD_INT 1
80056: DEC
80057: ST_TO_ADDR
80058: LD_EXP 66
80062: PUSH
80063: FOR_TO
80064: IFFALSE 80217
// begin if not mc_build_list [ i ] then
80066: LD_EXP 71
80070: PUSH
80071: LD_VAR 0 4
80075: ARRAY
80076: NOT
80077: IFFALSE 80081
// continue ;
80079: GO 80063
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
80081: LD_VAR 0 6
80085: PUSH
80086: LD_VAR 0 7
80090: PUSH
80091: LD_VAR 0 8
80095: PUSH
80096: LD_VAR 0 9
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: LIST
80105: LIST
80106: PPUSH
80107: LD_EXP 71
80111: PUSH
80112: LD_VAR 0 4
80116: ARRAY
80117: PUSH
80118: LD_INT 1
80120: ARRAY
80121: PPUSH
80122: CALL 24717 0 2
80126: IFFALSE 80215
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
80128: LD_ADDR_EXP 71
80132: PUSH
80133: LD_EXP 71
80137: PPUSH
80138: LD_VAR 0 4
80142: PPUSH
80143: LD_EXP 71
80147: PUSH
80148: LD_VAR 0 4
80152: ARRAY
80153: PPUSH
80154: LD_INT 1
80156: PPUSH
80157: CALL_OW 3
80161: PPUSH
80162: CALL_OW 1
80166: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
80167: LD_ADDR_EXP 73
80171: PUSH
80172: LD_EXP 73
80176: PPUSH
80177: LD_VAR 0 4
80181: PUSH
80182: LD_EXP 73
80186: PUSH
80187: LD_VAR 0 4
80191: ARRAY
80192: PUSH
80193: LD_INT 1
80195: PLUS
80196: PUSH
80197: EMPTY
80198: LIST
80199: LIST
80200: PPUSH
80201: LD_VAR 0 1
80205: PPUSH
80206: CALL 18548 0 3
80210: ST_TO_ADDR
// exit ;
80211: POP
80212: POP
80213: GO 80219
// end ; end ;
80215: GO 80063
80217: POP
80218: POP
// end ;
80219: LD_VAR 0 3
80223: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
80224: LD_INT 0
80226: PPUSH
80227: PPUSH
80228: PPUSH
// if not mc_bases or not skirmish then
80229: LD_EXP 66
80233: NOT
80234: PUSH
80235: LD_EXP 64
80239: NOT
80240: OR
80241: IFFALSE 80245
// exit ;
80243: GO 80435
// for i = 1 to mc_bases do
80245: LD_ADDR_VAR 0 4
80249: PUSH
80250: DOUBLE
80251: LD_INT 1
80253: DEC
80254: ST_TO_ADDR
80255: LD_EXP 66
80259: PUSH
80260: FOR_TO
80261: IFFALSE 80348
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
80263: LD_VAR 0 1
80267: PUSH
80268: LD_EXP 74
80272: PUSH
80273: LD_VAR 0 4
80277: ARRAY
80278: IN
80279: PUSH
80280: LD_VAR 0 1
80284: PUSH
80285: LD_EXP 75
80289: PUSH
80290: LD_VAR 0 4
80294: ARRAY
80295: IN
80296: NOT
80297: AND
80298: IFFALSE 80346
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80300: LD_ADDR_EXP 75
80304: PUSH
80305: LD_EXP 75
80309: PPUSH
80310: LD_VAR 0 4
80314: PUSH
80315: LD_EXP 75
80319: PUSH
80320: LD_VAR 0 4
80324: ARRAY
80325: PUSH
80326: LD_INT 1
80328: PLUS
80329: PUSH
80330: EMPTY
80331: LIST
80332: LIST
80333: PPUSH
80334: LD_VAR 0 1
80338: PPUSH
80339: CALL 18548 0 3
80343: ST_TO_ADDR
// break ;
80344: GO 80348
// end ; end ;
80346: GO 80260
80348: POP
80349: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
80350: LD_VAR 0 1
80354: PPUSH
80355: CALL_OW 257
80359: PUSH
80360: LD_EXP 92
80364: IN
80365: PUSH
80366: LD_VAR 0 1
80370: PPUSH
80371: CALL_OW 266
80375: PUSH
80376: LD_INT 5
80378: EQUAL
80379: AND
80380: PUSH
80381: LD_VAR 0 2
80385: PPUSH
80386: CALL_OW 110
80390: PUSH
80391: LD_INT 18
80393: NONEQUAL
80394: AND
80395: IFFALSE 80435
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
80397: LD_VAR 0 2
80401: PPUSH
80402: CALL_OW 257
80406: PUSH
80407: LD_INT 5
80409: PUSH
80410: LD_INT 8
80412: PUSH
80413: LD_INT 9
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: LIST
80420: IN
80421: IFFALSE 80435
// SetClass ( unit , 1 ) ;
80423: LD_VAR 0 2
80427: PPUSH
80428: LD_INT 1
80430: PPUSH
80431: CALL_OW 336
// end ;
80435: LD_VAR 0 3
80439: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
80440: LD_INT 0
80442: PPUSH
80443: PPUSH
// if not mc_bases or not skirmish then
80444: LD_EXP 66
80448: NOT
80449: PUSH
80450: LD_EXP 64
80454: NOT
80455: OR
80456: IFFALSE 80460
// exit ;
80458: GO 80576
// if GetLives ( abandoned_vehicle ) > 250 then
80460: LD_VAR 0 2
80464: PPUSH
80465: CALL_OW 256
80469: PUSH
80470: LD_INT 250
80472: GREATER
80473: IFFALSE 80477
// exit ;
80475: GO 80576
// for i = 1 to mc_bases do
80477: LD_ADDR_VAR 0 6
80481: PUSH
80482: DOUBLE
80483: LD_INT 1
80485: DEC
80486: ST_TO_ADDR
80487: LD_EXP 66
80491: PUSH
80492: FOR_TO
80493: IFFALSE 80574
// begin if driver in mc_bases [ i ] then
80495: LD_VAR 0 1
80499: PUSH
80500: LD_EXP 66
80504: PUSH
80505: LD_VAR 0 6
80509: ARRAY
80510: IN
80511: IFFALSE 80572
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
80513: LD_VAR 0 1
80517: PPUSH
80518: LD_EXP 66
80522: PUSH
80523: LD_VAR 0 6
80527: ARRAY
80528: PPUSH
80529: LD_INT 2
80531: PUSH
80532: LD_INT 30
80534: PUSH
80535: LD_INT 0
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 30
80544: PUSH
80545: LD_INT 1
80547: PUSH
80548: EMPTY
80549: LIST
80550: LIST
80551: PUSH
80552: EMPTY
80553: LIST
80554: LIST
80555: LIST
80556: PPUSH
80557: CALL_OW 72
80561: PUSH
80562: LD_INT 1
80564: ARRAY
80565: PPUSH
80566: CALL_OW 112
// break ;
80570: GO 80574
// end ; end ;
80572: GO 80492
80574: POP
80575: POP
// end ; end_of_file end_of_file
80576: LD_VAR 0 5
80580: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
80581: LD_VAR 0 2
80585: PUSH
80586: LD_INT 100
80588: EQUAL
80589: IFFALSE 81538
// begin if not StreamModeActive then
80591: LD_EXP 109
80595: NOT
80596: IFFALSE 80606
// StreamModeActive := true ;
80598: LD_ADDR_EXP 109
80602: PUSH
80603: LD_INT 1
80605: ST_TO_ADDR
// if p3 = 0 then
80606: LD_VAR 0 3
80610: PUSH
80611: LD_INT 0
80613: EQUAL
80614: IFFALSE 80620
// InitStreamMode ;
80616: CALL 81696 0 0
// if p3 = 1 then
80620: LD_VAR 0 3
80624: PUSH
80625: LD_INT 1
80627: EQUAL
80628: IFFALSE 80638
// sRocket := true ;
80630: LD_ADDR_EXP 114
80634: PUSH
80635: LD_INT 1
80637: ST_TO_ADDR
// if p3 = 2 then
80638: LD_VAR 0 3
80642: PUSH
80643: LD_INT 2
80645: EQUAL
80646: IFFALSE 80656
// sSpeed := true ;
80648: LD_ADDR_EXP 113
80652: PUSH
80653: LD_INT 1
80655: ST_TO_ADDR
// if p3 = 3 then
80656: LD_VAR 0 3
80660: PUSH
80661: LD_INT 3
80663: EQUAL
80664: IFFALSE 80674
// sEngine := true ;
80666: LD_ADDR_EXP 115
80670: PUSH
80671: LD_INT 1
80673: ST_TO_ADDR
// if p3 = 4 then
80674: LD_VAR 0 3
80678: PUSH
80679: LD_INT 4
80681: EQUAL
80682: IFFALSE 80692
// sSpec := true ;
80684: LD_ADDR_EXP 112
80688: PUSH
80689: LD_INT 1
80691: ST_TO_ADDR
// if p3 = 5 then
80692: LD_VAR 0 3
80696: PUSH
80697: LD_INT 5
80699: EQUAL
80700: IFFALSE 80710
// sLevel := true ;
80702: LD_ADDR_EXP 116
80706: PUSH
80707: LD_INT 1
80709: ST_TO_ADDR
// if p3 = 6 then
80710: LD_VAR 0 3
80714: PUSH
80715: LD_INT 6
80717: EQUAL
80718: IFFALSE 80728
// sArmoury := true ;
80720: LD_ADDR_EXP 117
80724: PUSH
80725: LD_INT 1
80727: ST_TO_ADDR
// if p3 = 7 then
80728: LD_VAR 0 3
80732: PUSH
80733: LD_INT 7
80735: EQUAL
80736: IFFALSE 80746
// sRadar := true ;
80738: LD_ADDR_EXP 118
80742: PUSH
80743: LD_INT 1
80745: ST_TO_ADDR
// if p3 = 8 then
80746: LD_VAR 0 3
80750: PUSH
80751: LD_INT 8
80753: EQUAL
80754: IFFALSE 80764
// sBunker := true ;
80756: LD_ADDR_EXP 119
80760: PUSH
80761: LD_INT 1
80763: ST_TO_ADDR
// if p3 = 9 then
80764: LD_VAR 0 3
80768: PUSH
80769: LD_INT 9
80771: EQUAL
80772: IFFALSE 80782
// sHack := true ;
80774: LD_ADDR_EXP 120
80778: PUSH
80779: LD_INT 1
80781: ST_TO_ADDR
// if p3 = 10 then
80782: LD_VAR 0 3
80786: PUSH
80787: LD_INT 10
80789: EQUAL
80790: IFFALSE 80800
// sFire := true ;
80792: LD_ADDR_EXP 121
80796: PUSH
80797: LD_INT 1
80799: ST_TO_ADDR
// if p3 = 11 then
80800: LD_VAR 0 3
80804: PUSH
80805: LD_INT 11
80807: EQUAL
80808: IFFALSE 80818
// sRefresh := true ;
80810: LD_ADDR_EXP 122
80814: PUSH
80815: LD_INT 1
80817: ST_TO_ADDR
// if p3 = 12 then
80818: LD_VAR 0 3
80822: PUSH
80823: LD_INT 12
80825: EQUAL
80826: IFFALSE 80836
// sExp := true ;
80828: LD_ADDR_EXP 123
80832: PUSH
80833: LD_INT 1
80835: ST_TO_ADDR
// if p3 = 13 then
80836: LD_VAR 0 3
80840: PUSH
80841: LD_INT 13
80843: EQUAL
80844: IFFALSE 80854
// sDepot := true ;
80846: LD_ADDR_EXP 124
80850: PUSH
80851: LD_INT 1
80853: ST_TO_ADDR
// if p3 = 14 then
80854: LD_VAR 0 3
80858: PUSH
80859: LD_INT 14
80861: EQUAL
80862: IFFALSE 80872
// sFlag := true ;
80864: LD_ADDR_EXP 125
80868: PUSH
80869: LD_INT 1
80871: ST_TO_ADDR
// if p3 = 15 then
80872: LD_VAR 0 3
80876: PUSH
80877: LD_INT 15
80879: EQUAL
80880: IFFALSE 80890
// sKamikadze := true ;
80882: LD_ADDR_EXP 133
80886: PUSH
80887: LD_INT 1
80889: ST_TO_ADDR
// if p3 = 16 then
80890: LD_VAR 0 3
80894: PUSH
80895: LD_INT 16
80897: EQUAL
80898: IFFALSE 80908
// sTroll := true ;
80900: LD_ADDR_EXP 134
80904: PUSH
80905: LD_INT 1
80907: ST_TO_ADDR
// if p3 = 17 then
80908: LD_VAR 0 3
80912: PUSH
80913: LD_INT 17
80915: EQUAL
80916: IFFALSE 80926
// sSlow := true ;
80918: LD_ADDR_EXP 135
80922: PUSH
80923: LD_INT 1
80925: ST_TO_ADDR
// if p3 = 18 then
80926: LD_VAR 0 3
80930: PUSH
80931: LD_INT 18
80933: EQUAL
80934: IFFALSE 80944
// sLack := true ;
80936: LD_ADDR_EXP 136
80940: PUSH
80941: LD_INT 1
80943: ST_TO_ADDR
// if p3 = 19 then
80944: LD_VAR 0 3
80948: PUSH
80949: LD_INT 19
80951: EQUAL
80952: IFFALSE 80962
// sTank := true ;
80954: LD_ADDR_EXP 138
80958: PUSH
80959: LD_INT 1
80961: ST_TO_ADDR
// if p3 = 20 then
80962: LD_VAR 0 3
80966: PUSH
80967: LD_INT 20
80969: EQUAL
80970: IFFALSE 80980
// sRemote := true ;
80972: LD_ADDR_EXP 139
80976: PUSH
80977: LD_INT 1
80979: ST_TO_ADDR
// if p3 = 21 then
80980: LD_VAR 0 3
80984: PUSH
80985: LD_INT 21
80987: EQUAL
80988: IFFALSE 80998
// sPowell := true ;
80990: LD_ADDR_EXP 140
80994: PUSH
80995: LD_INT 1
80997: ST_TO_ADDR
// if p3 = 22 then
80998: LD_VAR 0 3
81002: PUSH
81003: LD_INT 22
81005: EQUAL
81006: IFFALSE 81016
// sTeleport := true ;
81008: LD_ADDR_EXP 143
81012: PUSH
81013: LD_INT 1
81015: ST_TO_ADDR
// if p3 = 23 then
81016: LD_VAR 0 3
81020: PUSH
81021: LD_INT 23
81023: EQUAL
81024: IFFALSE 81034
// sOilTower := true ;
81026: LD_ADDR_EXP 145
81030: PUSH
81031: LD_INT 1
81033: ST_TO_ADDR
// if p3 = 24 then
81034: LD_VAR 0 3
81038: PUSH
81039: LD_INT 24
81041: EQUAL
81042: IFFALSE 81052
// sShovel := true ;
81044: LD_ADDR_EXP 146
81048: PUSH
81049: LD_INT 1
81051: ST_TO_ADDR
// if p3 = 25 then
81052: LD_VAR 0 3
81056: PUSH
81057: LD_INT 25
81059: EQUAL
81060: IFFALSE 81070
// sSheik := true ;
81062: LD_ADDR_EXP 147
81066: PUSH
81067: LD_INT 1
81069: ST_TO_ADDR
// if p3 = 26 then
81070: LD_VAR 0 3
81074: PUSH
81075: LD_INT 26
81077: EQUAL
81078: IFFALSE 81088
// sEarthquake := true ;
81080: LD_ADDR_EXP 149
81084: PUSH
81085: LD_INT 1
81087: ST_TO_ADDR
// if p3 = 27 then
81088: LD_VAR 0 3
81092: PUSH
81093: LD_INT 27
81095: EQUAL
81096: IFFALSE 81106
// sAI := true ;
81098: LD_ADDR_EXP 150
81102: PUSH
81103: LD_INT 1
81105: ST_TO_ADDR
// if p3 = 28 then
81106: LD_VAR 0 3
81110: PUSH
81111: LD_INT 28
81113: EQUAL
81114: IFFALSE 81124
// sCargo := true ;
81116: LD_ADDR_EXP 153
81120: PUSH
81121: LD_INT 1
81123: ST_TO_ADDR
// if p3 = 29 then
81124: LD_VAR 0 3
81128: PUSH
81129: LD_INT 29
81131: EQUAL
81132: IFFALSE 81142
// sDLaser := true ;
81134: LD_ADDR_EXP 154
81138: PUSH
81139: LD_INT 1
81141: ST_TO_ADDR
// if p3 = 30 then
81142: LD_VAR 0 3
81146: PUSH
81147: LD_INT 30
81149: EQUAL
81150: IFFALSE 81160
// sExchange := true ;
81152: LD_ADDR_EXP 155
81156: PUSH
81157: LD_INT 1
81159: ST_TO_ADDR
// if p3 = 31 then
81160: LD_VAR 0 3
81164: PUSH
81165: LD_INT 31
81167: EQUAL
81168: IFFALSE 81178
// sFac := true ;
81170: LD_ADDR_EXP 156
81174: PUSH
81175: LD_INT 1
81177: ST_TO_ADDR
// if p3 = 32 then
81178: LD_VAR 0 3
81182: PUSH
81183: LD_INT 32
81185: EQUAL
81186: IFFALSE 81196
// sPower := true ;
81188: LD_ADDR_EXP 157
81192: PUSH
81193: LD_INT 1
81195: ST_TO_ADDR
// if p3 = 33 then
81196: LD_VAR 0 3
81200: PUSH
81201: LD_INT 33
81203: EQUAL
81204: IFFALSE 81214
// sRandom := true ;
81206: LD_ADDR_EXP 158
81210: PUSH
81211: LD_INT 1
81213: ST_TO_ADDR
// if p3 = 34 then
81214: LD_VAR 0 3
81218: PUSH
81219: LD_INT 34
81221: EQUAL
81222: IFFALSE 81232
// sShield := true ;
81224: LD_ADDR_EXP 159
81228: PUSH
81229: LD_INT 1
81231: ST_TO_ADDR
// if p3 = 35 then
81232: LD_VAR 0 3
81236: PUSH
81237: LD_INT 35
81239: EQUAL
81240: IFFALSE 81250
// sTime := true ;
81242: LD_ADDR_EXP 160
81246: PUSH
81247: LD_INT 1
81249: ST_TO_ADDR
// if p3 = 36 then
81250: LD_VAR 0 3
81254: PUSH
81255: LD_INT 36
81257: EQUAL
81258: IFFALSE 81268
// sTools := true ;
81260: LD_ADDR_EXP 161
81264: PUSH
81265: LD_INT 1
81267: ST_TO_ADDR
// if p3 = 101 then
81268: LD_VAR 0 3
81272: PUSH
81273: LD_INT 101
81275: EQUAL
81276: IFFALSE 81286
// sSold := true ;
81278: LD_ADDR_EXP 126
81282: PUSH
81283: LD_INT 1
81285: ST_TO_ADDR
// if p3 = 102 then
81286: LD_VAR 0 3
81290: PUSH
81291: LD_INT 102
81293: EQUAL
81294: IFFALSE 81304
// sDiff := true ;
81296: LD_ADDR_EXP 127
81300: PUSH
81301: LD_INT 1
81303: ST_TO_ADDR
// if p3 = 103 then
81304: LD_VAR 0 3
81308: PUSH
81309: LD_INT 103
81311: EQUAL
81312: IFFALSE 81322
// sFog := true ;
81314: LD_ADDR_EXP 130
81318: PUSH
81319: LD_INT 1
81321: ST_TO_ADDR
// if p3 = 104 then
81322: LD_VAR 0 3
81326: PUSH
81327: LD_INT 104
81329: EQUAL
81330: IFFALSE 81340
// sReset := true ;
81332: LD_ADDR_EXP 131
81336: PUSH
81337: LD_INT 1
81339: ST_TO_ADDR
// if p3 = 105 then
81340: LD_VAR 0 3
81344: PUSH
81345: LD_INT 105
81347: EQUAL
81348: IFFALSE 81358
// sSun := true ;
81350: LD_ADDR_EXP 132
81354: PUSH
81355: LD_INT 1
81357: ST_TO_ADDR
// if p3 = 106 then
81358: LD_VAR 0 3
81362: PUSH
81363: LD_INT 106
81365: EQUAL
81366: IFFALSE 81376
// sTiger := true ;
81368: LD_ADDR_EXP 128
81372: PUSH
81373: LD_INT 1
81375: ST_TO_ADDR
// if p3 = 107 then
81376: LD_VAR 0 3
81380: PUSH
81381: LD_INT 107
81383: EQUAL
81384: IFFALSE 81394
// sBomb := true ;
81386: LD_ADDR_EXP 129
81390: PUSH
81391: LD_INT 1
81393: ST_TO_ADDR
// if p3 = 108 then
81394: LD_VAR 0 3
81398: PUSH
81399: LD_INT 108
81401: EQUAL
81402: IFFALSE 81412
// sWound := true ;
81404: LD_ADDR_EXP 137
81408: PUSH
81409: LD_INT 1
81411: ST_TO_ADDR
// if p3 = 109 then
81412: LD_VAR 0 3
81416: PUSH
81417: LD_INT 109
81419: EQUAL
81420: IFFALSE 81430
// sBetray := true ;
81422: LD_ADDR_EXP 141
81426: PUSH
81427: LD_INT 1
81429: ST_TO_ADDR
// if p3 = 110 then
81430: LD_VAR 0 3
81434: PUSH
81435: LD_INT 110
81437: EQUAL
81438: IFFALSE 81448
// sContamin := true ;
81440: LD_ADDR_EXP 142
81444: PUSH
81445: LD_INT 1
81447: ST_TO_ADDR
// if p3 = 111 then
81448: LD_VAR 0 3
81452: PUSH
81453: LD_INT 111
81455: EQUAL
81456: IFFALSE 81466
// sOil := true ;
81458: LD_ADDR_EXP 144
81462: PUSH
81463: LD_INT 1
81465: ST_TO_ADDR
// if p3 = 112 then
81466: LD_VAR 0 3
81470: PUSH
81471: LD_INT 112
81473: EQUAL
81474: IFFALSE 81484
// sStu := true ;
81476: LD_ADDR_EXP 148
81480: PUSH
81481: LD_INT 1
81483: ST_TO_ADDR
// if p3 = 113 then
81484: LD_VAR 0 3
81488: PUSH
81489: LD_INT 113
81491: EQUAL
81492: IFFALSE 81502
// sBazooka := true ;
81494: LD_ADDR_EXP 151
81498: PUSH
81499: LD_INT 1
81501: ST_TO_ADDR
// if p3 = 114 then
81502: LD_VAR 0 3
81506: PUSH
81507: LD_INT 114
81509: EQUAL
81510: IFFALSE 81520
// sMortar := true ;
81512: LD_ADDR_EXP 152
81516: PUSH
81517: LD_INT 1
81519: ST_TO_ADDR
// if p3 = 115 then
81520: LD_VAR 0 3
81524: PUSH
81525: LD_INT 115
81527: EQUAL
81528: IFFALSE 81538
// sRanger := true ;
81530: LD_ADDR_EXP 162
81534: PUSH
81535: LD_INT 1
81537: ST_TO_ADDR
// end ; if p2 = 101 then
81538: LD_VAR 0 2
81542: PUSH
81543: LD_INT 101
81545: EQUAL
81546: IFFALSE 81674
// begin case p3 of 1 :
81548: LD_VAR 0 3
81552: PUSH
81553: LD_INT 1
81555: DOUBLE
81556: EQUAL
81557: IFTRUE 81561
81559: GO 81568
81561: POP
// hHackUnlimitedResources ; 2 :
81562: CALL 92709 0 0
81566: GO 81674
81568: LD_INT 2
81570: DOUBLE
81571: EQUAL
81572: IFTRUE 81576
81574: GO 81583
81576: POP
// hHackSetLevel10 ; 3 :
81577: CALL 92842 0 0
81581: GO 81674
81583: LD_INT 3
81585: DOUBLE
81586: EQUAL
81587: IFTRUE 81591
81589: GO 81598
81591: POP
// hHackSetLevel10YourUnits ; 4 :
81592: CALL 92927 0 0
81596: GO 81674
81598: LD_INT 4
81600: DOUBLE
81601: EQUAL
81602: IFTRUE 81606
81604: GO 81613
81606: POP
// hHackInvincible ; 5 :
81607: CALL 93375 0 0
81611: GO 81674
81613: LD_INT 5
81615: DOUBLE
81616: EQUAL
81617: IFTRUE 81621
81619: GO 81628
81621: POP
// hHackInvisible ; 6 :
81622: CALL 93486 0 0
81626: GO 81674
81628: LD_INT 6
81630: DOUBLE
81631: EQUAL
81632: IFTRUE 81636
81634: GO 81643
81636: POP
// hHackChangeYourSide ; 7 :
81637: CALL 93543 0 0
81641: GO 81674
81643: LD_INT 7
81645: DOUBLE
81646: EQUAL
81647: IFTRUE 81651
81649: GO 81658
81651: POP
// hHackChangeUnitSide ; 8 :
81652: CALL 93585 0 0
81656: GO 81674
81658: LD_INT 8
81660: DOUBLE
81661: EQUAL
81662: IFTRUE 81666
81664: GO 81673
81666: POP
// hHackFog ; end ;
81667: CALL 93686 0 0
81671: GO 81674
81673: POP
// end ; end ;
81674: PPOPN 6
81676: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
81677: GO 81679
81679: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
81680: LD_STRING initStreamRollete();
81682: PPUSH
81683: CALL_OW 559
// InitStreamMode ;
81687: CALL 81696 0 0
// DefineStreamItems ( ) ;
81691: CALL 82136 0 0
// end ;
81695: END
// function InitStreamMode ; begin
81696: LD_INT 0
81698: PPUSH
// streamModeActive := false ;
81699: LD_ADDR_EXP 109
81703: PUSH
81704: LD_INT 0
81706: ST_TO_ADDR
// normalCounter := 36 ;
81707: LD_ADDR_EXP 110
81711: PUSH
81712: LD_INT 36
81714: ST_TO_ADDR
// hardcoreCounter := 16 ;
81715: LD_ADDR_EXP 111
81719: PUSH
81720: LD_INT 16
81722: ST_TO_ADDR
// sRocket := false ;
81723: LD_ADDR_EXP 114
81727: PUSH
81728: LD_INT 0
81730: ST_TO_ADDR
// sSpeed := false ;
81731: LD_ADDR_EXP 113
81735: PUSH
81736: LD_INT 0
81738: ST_TO_ADDR
// sEngine := false ;
81739: LD_ADDR_EXP 115
81743: PUSH
81744: LD_INT 0
81746: ST_TO_ADDR
// sSpec := false ;
81747: LD_ADDR_EXP 112
81751: PUSH
81752: LD_INT 0
81754: ST_TO_ADDR
// sLevel := false ;
81755: LD_ADDR_EXP 116
81759: PUSH
81760: LD_INT 0
81762: ST_TO_ADDR
// sArmoury := false ;
81763: LD_ADDR_EXP 117
81767: PUSH
81768: LD_INT 0
81770: ST_TO_ADDR
// sRadar := false ;
81771: LD_ADDR_EXP 118
81775: PUSH
81776: LD_INT 0
81778: ST_TO_ADDR
// sBunker := false ;
81779: LD_ADDR_EXP 119
81783: PUSH
81784: LD_INT 0
81786: ST_TO_ADDR
// sHack := false ;
81787: LD_ADDR_EXP 120
81791: PUSH
81792: LD_INT 0
81794: ST_TO_ADDR
// sFire := false ;
81795: LD_ADDR_EXP 121
81799: PUSH
81800: LD_INT 0
81802: ST_TO_ADDR
// sRefresh := false ;
81803: LD_ADDR_EXP 122
81807: PUSH
81808: LD_INT 0
81810: ST_TO_ADDR
// sExp := false ;
81811: LD_ADDR_EXP 123
81815: PUSH
81816: LD_INT 0
81818: ST_TO_ADDR
// sDepot := false ;
81819: LD_ADDR_EXP 124
81823: PUSH
81824: LD_INT 0
81826: ST_TO_ADDR
// sFlag := false ;
81827: LD_ADDR_EXP 125
81831: PUSH
81832: LD_INT 0
81834: ST_TO_ADDR
// sKamikadze := false ;
81835: LD_ADDR_EXP 133
81839: PUSH
81840: LD_INT 0
81842: ST_TO_ADDR
// sTroll := false ;
81843: LD_ADDR_EXP 134
81847: PUSH
81848: LD_INT 0
81850: ST_TO_ADDR
// sSlow := false ;
81851: LD_ADDR_EXP 135
81855: PUSH
81856: LD_INT 0
81858: ST_TO_ADDR
// sLack := false ;
81859: LD_ADDR_EXP 136
81863: PUSH
81864: LD_INT 0
81866: ST_TO_ADDR
// sTank := false ;
81867: LD_ADDR_EXP 138
81871: PUSH
81872: LD_INT 0
81874: ST_TO_ADDR
// sRemote := false ;
81875: LD_ADDR_EXP 139
81879: PUSH
81880: LD_INT 0
81882: ST_TO_ADDR
// sPowell := false ;
81883: LD_ADDR_EXP 140
81887: PUSH
81888: LD_INT 0
81890: ST_TO_ADDR
// sTeleport := false ;
81891: LD_ADDR_EXP 143
81895: PUSH
81896: LD_INT 0
81898: ST_TO_ADDR
// sOilTower := false ;
81899: LD_ADDR_EXP 145
81903: PUSH
81904: LD_INT 0
81906: ST_TO_ADDR
// sShovel := false ;
81907: LD_ADDR_EXP 146
81911: PUSH
81912: LD_INT 0
81914: ST_TO_ADDR
// sSheik := false ;
81915: LD_ADDR_EXP 147
81919: PUSH
81920: LD_INT 0
81922: ST_TO_ADDR
// sEarthquake := false ;
81923: LD_ADDR_EXP 149
81927: PUSH
81928: LD_INT 0
81930: ST_TO_ADDR
// sAI := false ;
81931: LD_ADDR_EXP 150
81935: PUSH
81936: LD_INT 0
81938: ST_TO_ADDR
// sCargo := false ;
81939: LD_ADDR_EXP 153
81943: PUSH
81944: LD_INT 0
81946: ST_TO_ADDR
// sDLaser := false ;
81947: LD_ADDR_EXP 154
81951: PUSH
81952: LD_INT 0
81954: ST_TO_ADDR
// sExchange := false ;
81955: LD_ADDR_EXP 155
81959: PUSH
81960: LD_INT 0
81962: ST_TO_ADDR
// sFac := false ;
81963: LD_ADDR_EXP 156
81967: PUSH
81968: LD_INT 0
81970: ST_TO_ADDR
// sPower := false ;
81971: LD_ADDR_EXP 157
81975: PUSH
81976: LD_INT 0
81978: ST_TO_ADDR
// sRandom := false ;
81979: LD_ADDR_EXP 158
81983: PUSH
81984: LD_INT 0
81986: ST_TO_ADDR
// sShield := false ;
81987: LD_ADDR_EXP 159
81991: PUSH
81992: LD_INT 0
81994: ST_TO_ADDR
// sTime := false ;
81995: LD_ADDR_EXP 160
81999: PUSH
82000: LD_INT 0
82002: ST_TO_ADDR
// sTools := false ;
82003: LD_ADDR_EXP 161
82007: PUSH
82008: LD_INT 0
82010: ST_TO_ADDR
// sSold := false ;
82011: LD_ADDR_EXP 126
82015: PUSH
82016: LD_INT 0
82018: ST_TO_ADDR
// sDiff := false ;
82019: LD_ADDR_EXP 127
82023: PUSH
82024: LD_INT 0
82026: ST_TO_ADDR
// sFog := false ;
82027: LD_ADDR_EXP 130
82031: PUSH
82032: LD_INT 0
82034: ST_TO_ADDR
// sReset := false ;
82035: LD_ADDR_EXP 131
82039: PUSH
82040: LD_INT 0
82042: ST_TO_ADDR
// sSun := false ;
82043: LD_ADDR_EXP 132
82047: PUSH
82048: LD_INT 0
82050: ST_TO_ADDR
// sTiger := false ;
82051: LD_ADDR_EXP 128
82055: PUSH
82056: LD_INT 0
82058: ST_TO_ADDR
// sBomb := false ;
82059: LD_ADDR_EXP 129
82063: PUSH
82064: LD_INT 0
82066: ST_TO_ADDR
// sWound := false ;
82067: LD_ADDR_EXP 137
82071: PUSH
82072: LD_INT 0
82074: ST_TO_ADDR
// sBetray := false ;
82075: LD_ADDR_EXP 141
82079: PUSH
82080: LD_INT 0
82082: ST_TO_ADDR
// sContamin := false ;
82083: LD_ADDR_EXP 142
82087: PUSH
82088: LD_INT 0
82090: ST_TO_ADDR
// sOil := false ;
82091: LD_ADDR_EXP 144
82095: PUSH
82096: LD_INT 0
82098: ST_TO_ADDR
// sStu := false ;
82099: LD_ADDR_EXP 148
82103: PUSH
82104: LD_INT 0
82106: ST_TO_ADDR
// sBazooka := false ;
82107: LD_ADDR_EXP 151
82111: PUSH
82112: LD_INT 0
82114: ST_TO_ADDR
// sMortar := false ;
82115: LD_ADDR_EXP 152
82119: PUSH
82120: LD_INT 0
82122: ST_TO_ADDR
// sRanger := false ;
82123: LD_ADDR_EXP 162
82127: PUSH
82128: LD_INT 0
82130: ST_TO_ADDR
// end ;
82131: LD_VAR 0 1
82135: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
82136: LD_INT 0
82138: PPUSH
82139: PPUSH
82140: PPUSH
82141: PPUSH
82142: PPUSH
// result := [ ] ;
82143: LD_ADDR_VAR 0 1
82147: PUSH
82148: EMPTY
82149: ST_TO_ADDR
// if campaign_id = 1 then
82150: LD_OWVAR 69
82154: PUSH
82155: LD_INT 1
82157: EQUAL
82158: IFFALSE 85096
// begin case mission_number of 1 :
82160: LD_OWVAR 70
82164: PUSH
82165: LD_INT 1
82167: DOUBLE
82168: EQUAL
82169: IFTRUE 82173
82171: GO 82237
82173: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
82174: LD_ADDR_VAR 0 1
82178: PUSH
82179: LD_INT 2
82181: PUSH
82182: LD_INT 4
82184: PUSH
82185: LD_INT 11
82187: PUSH
82188: LD_INT 12
82190: PUSH
82191: LD_INT 15
82193: PUSH
82194: LD_INT 16
82196: PUSH
82197: LD_INT 22
82199: PUSH
82200: LD_INT 23
82202: PUSH
82203: LD_INT 26
82205: PUSH
82206: EMPTY
82207: LIST
82208: LIST
82209: LIST
82210: LIST
82211: LIST
82212: LIST
82213: LIST
82214: LIST
82215: LIST
82216: PUSH
82217: LD_INT 101
82219: PUSH
82220: LD_INT 102
82222: PUSH
82223: LD_INT 106
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: LIST
82230: PUSH
82231: EMPTY
82232: LIST
82233: LIST
82234: ST_TO_ADDR
82235: GO 85094
82237: LD_INT 2
82239: DOUBLE
82240: EQUAL
82241: IFTRUE 82245
82243: GO 82317
82245: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
82246: LD_ADDR_VAR 0 1
82250: PUSH
82251: LD_INT 2
82253: PUSH
82254: LD_INT 4
82256: PUSH
82257: LD_INT 11
82259: PUSH
82260: LD_INT 12
82262: PUSH
82263: LD_INT 15
82265: PUSH
82266: LD_INT 16
82268: PUSH
82269: LD_INT 22
82271: PUSH
82272: LD_INT 23
82274: PUSH
82275: LD_INT 26
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: LIST
82282: LIST
82283: LIST
82284: LIST
82285: LIST
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 101
82291: PUSH
82292: LD_INT 102
82294: PUSH
82295: LD_INT 105
82297: PUSH
82298: LD_INT 106
82300: PUSH
82301: LD_INT 108
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: LIST
82308: LIST
82309: LIST
82310: PUSH
82311: EMPTY
82312: LIST
82313: LIST
82314: ST_TO_ADDR
82315: GO 85094
82317: LD_INT 3
82319: DOUBLE
82320: EQUAL
82321: IFTRUE 82325
82323: GO 82401
82325: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
82326: LD_ADDR_VAR 0 1
82330: PUSH
82331: LD_INT 2
82333: PUSH
82334: LD_INT 4
82336: PUSH
82337: LD_INT 5
82339: PUSH
82340: LD_INT 11
82342: PUSH
82343: LD_INT 12
82345: PUSH
82346: LD_INT 15
82348: PUSH
82349: LD_INT 16
82351: PUSH
82352: LD_INT 22
82354: PUSH
82355: LD_INT 26
82357: PUSH
82358: LD_INT 36
82360: PUSH
82361: EMPTY
82362: LIST
82363: LIST
82364: LIST
82365: LIST
82366: LIST
82367: LIST
82368: LIST
82369: LIST
82370: LIST
82371: LIST
82372: PUSH
82373: LD_INT 101
82375: PUSH
82376: LD_INT 102
82378: PUSH
82379: LD_INT 105
82381: PUSH
82382: LD_INT 106
82384: PUSH
82385: LD_INT 108
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: LIST
82392: LIST
82393: LIST
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: ST_TO_ADDR
82399: GO 85094
82401: LD_INT 4
82403: DOUBLE
82404: EQUAL
82405: IFTRUE 82409
82407: GO 82493
82409: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
82410: LD_ADDR_VAR 0 1
82414: PUSH
82415: LD_INT 2
82417: PUSH
82418: LD_INT 4
82420: PUSH
82421: LD_INT 5
82423: PUSH
82424: LD_INT 8
82426: PUSH
82427: LD_INT 11
82429: PUSH
82430: LD_INT 12
82432: PUSH
82433: LD_INT 15
82435: PUSH
82436: LD_INT 16
82438: PUSH
82439: LD_INT 22
82441: PUSH
82442: LD_INT 23
82444: PUSH
82445: LD_INT 26
82447: PUSH
82448: LD_INT 36
82450: PUSH
82451: EMPTY
82452: LIST
82453: LIST
82454: LIST
82455: LIST
82456: LIST
82457: LIST
82458: LIST
82459: LIST
82460: LIST
82461: LIST
82462: LIST
82463: LIST
82464: PUSH
82465: LD_INT 101
82467: PUSH
82468: LD_INT 102
82470: PUSH
82471: LD_INT 105
82473: PUSH
82474: LD_INT 106
82476: PUSH
82477: LD_INT 108
82479: PUSH
82480: EMPTY
82481: LIST
82482: LIST
82483: LIST
82484: LIST
82485: LIST
82486: PUSH
82487: EMPTY
82488: LIST
82489: LIST
82490: ST_TO_ADDR
82491: GO 85094
82493: LD_INT 5
82495: DOUBLE
82496: EQUAL
82497: IFTRUE 82501
82499: GO 82601
82501: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
82502: LD_ADDR_VAR 0 1
82506: PUSH
82507: LD_INT 2
82509: PUSH
82510: LD_INT 4
82512: PUSH
82513: LD_INT 5
82515: PUSH
82516: LD_INT 6
82518: PUSH
82519: LD_INT 8
82521: PUSH
82522: LD_INT 11
82524: PUSH
82525: LD_INT 12
82527: PUSH
82528: LD_INT 15
82530: PUSH
82531: LD_INT 16
82533: PUSH
82534: LD_INT 22
82536: PUSH
82537: LD_INT 23
82539: PUSH
82540: LD_INT 25
82542: PUSH
82543: LD_INT 26
82545: PUSH
82546: LD_INT 36
82548: PUSH
82549: EMPTY
82550: LIST
82551: LIST
82552: LIST
82553: LIST
82554: LIST
82555: LIST
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 101
82567: PUSH
82568: LD_INT 102
82570: PUSH
82571: LD_INT 105
82573: PUSH
82574: LD_INT 106
82576: PUSH
82577: LD_INT 108
82579: PUSH
82580: LD_INT 109
82582: PUSH
82583: LD_INT 112
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: LIST
82590: LIST
82591: LIST
82592: LIST
82593: LIST
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: ST_TO_ADDR
82599: GO 85094
82601: LD_INT 6
82603: DOUBLE
82604: EQUAL
82605: IFTRUE 82609
82607: GO 82729
82609: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
82610: LD_ADDR_VAR 0 1
82614: PUSH
82615: LD_INT 2
82617: PUSH
82618: LD_INT 4
82620: PUSH
82621: LD_INT 5
82623: PUSH
82624: LD_INT 6
82626: PUSH
82627: LD_INT 8
82629: PUSH
82630: LD_INT 11
82632: PUSH
82633: LD_INT 12
82635: PUSH
82636: LD_INT 15
82638: PUSH
82639: LD_INT 16
82641: PUSH
82642: LD_INT 20
82644: PUSH
82645: LD_INT 21
82647: PUSH
82648: LD_INT 22
82650: PUSH
82651: LD_INT 23
82653: PUSH
82654: LD_INT 25
82656: PUSH
82657: LD_INT 26
82659: PUSH
82660: LD_INT 30
82662: PUSH
82663: LD_INT 31
82665: PUSH
82666: LD_INT 32
82668: PUSH
82669: LD_INT 36
82671: PUSH
82672: EMPTY
82673: LIST
82674: LIST
82675: LIST
82676: LIST
82677: LIST
82678: LIST
82679: LIST
82680: LIST
82681: LIST
82682: LIST
82683: LIST
82684: LIST
82685: LIST
82686: LIST
82687: LIST
82688: LIST
82689: LIST
82690: LIST
82691: LIST
82692: PUSH
82693: LD_INT 101
82695: PUSH
82696: LD_INT 102
82698: PUSH
82699: LD_INT 105
82701: PUSH
82702: LD_INT 106
82704: PUSH
82705: LD_INT 108
82707: PUSH
82708: LD_INT 109
82710: PUSH
82711: LD_INT 112
82713: PUSH
82714: EMPTY
82715: LIST
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: ST_TO_ADDR
82727: GO 85094
82729: LD_INT 7
82731: DOUBLE
82732: EQUAL
82733: IFTRUE 82737
82735: GO 82837
82737: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
82738: LD_ADDR_VAR 0 1
82742: PUSH
82743: LD_INT 2
82745: PUSH
82746: LD_INT 4
82748: PUSH
82749: LD_INT 5
82751: PUSH
82752: LD_INT 7
82754: PUSH
82755: LD_INT 11
82757: PUSH
82758: LD_INT 12
82760: PUSH
82761: LD_INT 15
82763: PUSH
82764: LD_INT 16
82766: PUSH
82767: LD_INT 20
82769: PUSH
82770: LD_INT 21
82772: PUSH
82773: LD_INT 22
82775: PUSH
82776: LD_INT 23
82778: PUSH
82779: LD_INT 25
82781: PUSH
82782: LD_INT 26
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: LIST
82789: LIST
82790: LIST
82791: LIST
82792: LIST
82793: LIST
82794: LIST
82795: LIST
82796: LIST
82797: LIST
82798: LIST
82799: LIST
82800: PUSH
82801: LD_INT 101
82803: PUSH
82804: LD_INT 102
82806: PUSH
82807: LD_INT 103
82809: PUSH
82810: LD_INT 105
82812: PUSH
82813: LD_INT 106
82815: PUSH
82816: LD_INT 108
82818: PUSH
82819: LD_INT 112
82821: PUSH
82822: EMPTY
82823: LIST
82824: LIST
82825: LIST
82826: LIST
82827: LIST
82828: LIST
82829: LIST
82830: PUSH
82831: EMPTY
82832: LIST
82833: LIST
82834: ST_TO_ADDR
82835: GO 85094
82837: LD_INT 8
82839: DOUBLE
82840: EQUAL
82841: IFTRUE 82845
82843: GO 82973
82845: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
82846: LD_ADDR_VAR 0 1
82850: PUSH
82851: LD_INT 2
82853: PUSH
82854: LD_INT 4
82856: PUSH
82857: LD_INT 5
82859: PUSH
82860: LD_INT 6
82862: PUSH
82863: LD_INT 7
82865: PUSH
82866: LD_INT 8
82868: PUSH
82869: LD_INT 11
82871: PUSH
82872: LD_INT 12
82874: PUSH
82875: LD_INT 15
82877: PUSH
82878: LD_INT 16
82880: PUSH
82881: LD_INT 20
82883: PUSH
82884: LD_INT 21
82886: PUSH
82887: LD_INT 22
82889: PUSH
82890: LD_INT 23
82892: PUSH
82893: LD_INT 25
82895: PUSH
82896: LD_INT 26
82898: PUSH
82899: LD_INT 30
82901: PUSH
82902: LD_INT 31
82904: PUSH
82905: LD_INT 32
82907: PUSH
82908: LD_INT 36
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: LIST
82927: LIST
82928: LIST
82929: LIST
82930: LIST
82931: LIST
82932: PUSH
82933: LD_INT 101
82935: PUSH
82936: LD_INT 102
82938: PUSH
82939: LD_INT 103
82941: PUSH
82942: LD_INT 105
82944: PUSH
82945: LD_INT 106
82947: PUSH
82948: LD_INT 108
82950: PUSH
82951: LD_INT 109
82953: PUSH
82954: LD_INT 112
82956: PUSH
82957: EMPTY
82958: LIST
82959: LIST
82960: LIST
82961: LIST
82962: LIST
82963: LIST
82964: LIST
82965: LIST
82966: PUSH
82967: EMPTY
82968: LIST
82969: LIST
82970: ST_TO_ADDR
82971: GO 85094
82973: LD_INT 9
82975: DOUBLE
82976: EQUAL
82977: IFTRUE 82981
82979: GO 83117
82981: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
82982: LD_ADDR_VAR 0 1
82986: PUSH
82987: LD_INT 2
82989: PUSH
82990: LD_INT 4
82992: PUSH
82993: LD_INT 5
82995: PUSH
82996: LD_INT 6
82998: PUSH
82999: LD_INT 7
83001: PUSH
83002: LD_INT 8
83004: PUSH
83005: LD_INT 11
83007: PUSH
83008: LD_INT 12
83010: PUSH
83011: LD_INT 15
83013: PUSH
83014: LD_INT 16
83016: PUSH
83017: LD_INT 20
83019: PUSH
83020: LD_INT 21
83022: PUSH
83023: LD_INT 22
83025: PUSH
83026: LD_INT 23
83028: PUSH
83029: LD_INT 25
83031: PUSH
83032: LD_INT 26
83034: PUSH
83035: LD_INT 28
83037: PUSH
83038: LD_INT 30
83040: PUSH
83041: LD_INT 31
83043: PUSH
83044: LD_INT 32
83046: PUSH
83047: LD_INT 36
83049: PUSH
83050: EMPTY
83051: LIST
83052: LIST
83053: LIST
83054: LIST
83055: LIST
83056: LIST
83057: LIST
83058: LIST
83059: LIST
83060: LIST
83061: LIST
83062: LIST
83063: LIST
83064: LIST
83065: LIST
83066: LIST
83067: LIST
83068: LIST
83069: LIST
83070: LIST
83071: LIST
83072: PUSH
83073: LD_INT 101
83075: PUSH
83076: LD_INT 102
83078: PUSH
83079: LD_INT 103
83081: PUSH
83082: LD_INT 105
83084: PUSH
83085: LD_INT 106
83087: PUSH
83088: LD_INT 108
83090: PUSH
83091: LD_INT 109
83093: PUSH
83094: LD_INT 112
83096: PUSH
83097: LD_INT 114
83099: PUSH
83100: EMPTY
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: PUSH
83111: EMPTY
83112: LIST
83113: LIST
83114: ST_TO_ADDR
83115: GO 85094
83117: LD_INT 10
83119: DOUBLE
83120: EQUAL
83121: IFTRUE 83125
83123: GO 83309
83125: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
83126: LD_ADDR_VAR 0 1
83130: PUSH
83131: LD_INT 2
83133: PUSH
83134: LD_INT 4
83136: PUSH
83137: LD_INT 5
83139: PUSH
83140: LD_INT 6
83142: PUSH
83143: LD_INT 7
83145: PUSH
83146: LD_INT 8
83148: PUSH
83149: LD_INT 9
83151: PUSH
83152: LD_INT 10
83154: PUSH
83155: LD_INT 11
83157: PUSH
83158: LD_INT 12
83160: PUSH
83161: LD_INT 13
83163: PUSH
83164: LD_INT 14
83166: PUSH
83167: LD_INT 15
83169: PUSH
83170: LD_INT 16
83172: PUSH
83173: LD_INT 17
83175: PUSH
83176: LD_INT 18
83178: PUSH
83179: LD_INT 19
83181: PUSH
83182: LD_INT 20
83184: PUSH
83185: LD_INT 21
83187: PUSH
83188: LD_INT 22
83190: PUSH
83191: LD_INT 23
83193: PUSH
83194: LD_INT 24
83196: PUSH
83197: LD_INT 25
83199: PUSH
83200: LD_INT 26
83202: PUSH
83203: LD_INT 28
83205: PUSH
83206: LD_INT 30
83208: PUSH
83209: LD_INT 31
83211: PUSH
83212: LD_INT 32
83214: PUSH
83215: LD_INT 36
83217: PUSH
83218: EMPTY
83219: LIST
83220: LIST
83221: LIST
83222: LIST
83223: LIST
83224: LIST
83225: LIST
83226: LIST
83227: LIST
83228: LIST
83229: LIST
83230: LIST
83231: LIST
83232: LIST
83233: LIST
83234: LIST
83235: LIST
83236: LIST
83237: LIST
83238: LIST
83239: LIST
83240: LIST
83241: LIST
83242: LIST
83243: LIST
83244: LIST
83245: LIST
83246: LIST
83247: LIST
83248: PUSH
83249: LD_INT 101
83251: PUSH
83252: LD_INT 102
83254: PUSH
83255: LD_INT 103
83257: PUSH
83258: LD_INT 104
83260: PUSH
83261: LD_INT 105
83263: PUSH
83264: LD_INT 106
83266: PUSH
83267: LD_INT 107
83269: PUSH
83270: LD_INT 108
83272: PUSH
83273: LD_INT 109
83275: PUSH
83276: LD_INT 110
83278: PUSH
83279: LD_INT 111
83281: PUSH
83282: LD_INT 112
83284: PUSH
83285: LD_INT 114
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: LIST
83292: LIST
83293: LIST
83294: LIST
83295: LIST
83296: LIST
83297: LIST
83298: LIST
83299: LIST
83300: LIST
83301: LIST
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: ST_TO_ADDR
83307: GO 85094
83309: LD_INT 11
83311: DOUBLE
83312: EQUAL
83313: IFTRUE 83317
83315: GO 83509
83317: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
83318: LD_ADDR_VAR 0 1
83322: PUSH
83323: LD_INT 2
83325: PUSH
83326: LD_INT 3
83328: PUSH
83329: LD_INT 4
83331: PUSH
83332: LD_INT 5
83334: PUSH
83335: LD_INT 6
83337: PUSH
83338: LD_INT 7
83340: PUSH
83341: LD_INT 8
83343: PUSH
83344: LD_INT 9
83346: PUSH
83347: LD_INT 10
83349: PUSH
83350: LD_INT 11
83352: PUSH
83353: LD_INT 12
83355: PUSH
83356: LD_INT 13
83358: PUSH
83359: LD_INT 14
83361: PUSH
83362: LD_INT 15
83364: PUSH
83365: LD_INT 16
83367: PUSH
83368: LD_INT 17
83370: PUSH
83371: LD_INT 18
83373: PUSH
83374: LD_INT 19
83376: PUSH
83377: LD_INT 20
83379: PUSH
83380: LD_INT 21
83382: PUSH
83383: LD_INT 22
83385: PUSH
83386: LD_INT 23
83388: PUSH
83389: LD_INT 24
83391: PUSH
83392: LD_INT 25
83394: PUSH
83395: LD_INT 26
83397: PUSH
83398: LD_INT 28
83400: PUSH
83401: LD_INT 30
83403: PUSH
83404: LD_INT 31
83406: PUSH
83407: LD_INT 32
83409: PUSH
83410: LD_INT 34
83412: PUSH
83413: LD_INT 36
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: LIST
83420: LIST
83421: LIST
83422: LIST
83423: LIST
83424: LIST
83425: LIST
83426: LIST
83427: LIST
83428: LIST
83429: LIST
83430: LIST
83431: LIST
83432: LIST
83433: LIST
83434: LIST
83435: LIST
83436: LIST
83437: LIST
83438: LIST
83439: LIST
83440: LIST
83441: LIST
83442: LIST
83443: LIST
83444: LIST
83445: LIST
83446: LIST
83447: LIST
83448: PUSH
83449: LD_INT 101
83451: PUSH
83452: LD_INT 102
83454: PUSH
83455: LD_INT 103
83457: PUSH
83458: LD_INT 104
83460: PUSH
83461: LD_INT 105
83463: PUSH
83464: LD_INT 106
83466: PUSH
83467: LD_INT 107
83469: PUSH
83470: LD_INT 108
83472: PUSH
83473: LD_INT 109
83475: PUSH
83476: LD_INT 110
83478: PUSH
83479: LD_INT 111
83481: PUSH
83482: LD_INT 112
83484: PUSH
83485: LD_INT 114
83487: PUSH
83488: EMPTY
83489: LIST
83490: LIST
83491: LIST
83492: LIST
83493: LIST
83494: LIST
83495: LIST
83496: LIST
83497: LIST
83498: LIST
83499: LIST
83500: LIST
83501: LIST
83502: PUSH
83503: EMPTY
83504: LIST
83505: LIST
83506: ST_TO_ADDR
83507: GO 85094
83509: LD_INT 12
83511: DOUBLE
83512: EQUAL
83513: IFTRUE 83517
83515: GO 83725
83517: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
83518: LD_ADDR_VAR 0 1
83522: PUSH
83523: LD_INT 1
83525: PUSH
83526: LD_INT 2
83528: PUSH
83529: LD_INT 3
83531: PUSH
83532: LD_INT 4
83534: PUSH
83535: LD_INT 5
83537: PUSH
83538: LD_INT 6
83540: PUSH
83541: LD_INT 7
83543: PUSH
83544: LD_INT 8
83546: PUSH
83547: LD_INT 9
83549: PUSH
83550: LD_INT 10
83552: PUSH
83553: LD_INT 11
83555: PUSH
83556: LD_INT 12
83558: PUSH
83559: LD_INT 13
83561: PUSH
83562: LD_INT 14
83564: PUSH
83565: LD_INT 15
83567: PUSH
83568: LD_INT 16
83570: PUSH
83571: LD_INT 17
83573: PUSH
83574: LD_INT 18
83576: PUSH
83577: LD_INT 19
83579: PUSH
83580: LD_INT 20
83582: PUSH
83583: LD_INT 21
83585: PUSH
83586: LD_INT 22
83588: PUSH
83589: LD_INT 23
83591: PUSH
83592: LD_INT 24
83594: PUSH
83595: LD_INT 25
83597: PUSH
83598: LD_INT 26
83600: PUSH
83601: LD_INT 27
83603: PUSH
83604: LD_INT 28
83606: PUSH
83607: LD_INT 30
83609: PUSH
83610: LD_INT 31
83612: PUSH
83613: LD_INT 32
83615: PUSH
83616: LD_INT 33
83618: PUSH
83619: LD_INT 34
83621: PUSH
83622: LD_INT 36
83624: PUSH
83625: EMPTY
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: LIST
83645: LIST
83646: LIST
83647: LIST
83648: LIST
83649: LIST
83650: LIST
83651: LIST
83652: LIST
83653: LIST
83654: LIST
83655: LIST
83656: LIST
83657: LIST
83658: LIST
83659: LIST
83660: PUSH
83661: LD_INT 101
83663: PUSH
83664: LD_INT 102
83666: PUSH
83667: LD_INT 103
83669: PUSH
83670: LD_INT 104
83672: PUSH
83673: LD_INT 105
83675: PUSH
83676: LD_INT 106
83678: PUSH
83679: LD_INT 107
83681: PUSH
83682: LD_INT 108
83684: PUSH
83685: LD_INT 109
83687: PUSH
83688: LD_INT 110
83690: PUSH
83691: LD_INT 111
83693: PUSH
83694: LD_INT 112
83696: PUSH
83697: LD_INT 113
83699: PUSH
83700: LD_INT 114
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: LIST
83709: LIST
83710: LIST
83711: LIST
83712: LIST
83713: LIST
83714: LIST
83715: LIST
83716: LIST
83717: LIST
83718: PUSH
83719: EMPTY
83720: LIST
83721: LIST
83722: ST_TO_ADDR
83723: GO 85094
83725: LD_INT 13
83727: DOUBLE
83728: EQUAL
83729: IFTRUE 83733
83731: GO 83929
83733: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
83734: LD_ADDR_VAR 0 1
83738: PUSH
83739: LD_INT 1
83741: PUSH
83742: LD_INT 2
83744: PUSH
83745: LD_INT 3
83747: PUSH
83748: LD_INT 4
83750: PUSH
83751: LD_INT 5
83753: PUSH
83754: LD_INT 8
83756: PUSH
83757: LD_INT 9
83759: PUSH
83760: LD_INT 10
83762: PUSH
83763: LD_INT 11
83765: PUSH
83766: LD_INT 12
83768: PUSH
83769: LD_INT 14
83771: PUSH
83772: LD_INT 15
83774: PUSH
83775: LD_INT 16
83777: PUSH
83778: LD_INT 17
83780: PUSH
83781: LD_INT 18
83783: PUSH
83784: LD_INT 19
83786: PUSH
83787: LD_INT 20
83789: PUSH
83790: LD_INT 21
83792: PUSH
83793: LD_INT 22
83795: PUSH
83796: LD_INT 23
83798: PUSH
83799: LD_INT 24
83801: PUSH
83802: LD_INT 25
83804: PUSH
83805: LD_INT 26
83807: PUSH
83808: LD_INT 27
83810: PUSH
83811: LD_INT 28
83813: PUSH
83814: LD_INT 30
83816: PUSH
83817: LD_INT 31
83819: PUSH
83820: LD_INT 32
83822: PUSH
83823: LD_INT 33
83825: PUSH
83826: LD_INT 34
83828: PUSH
83829: LD_INT 36
83831: PUSH
83832: EMPTY
83833: LIST
83834: LIST
83835: LIST
83836: LIST
83837: LIST
83838: LIST
83839: LIST
83840: LIST
83841: LIST
83842: LIST
83843: LIST
83844: LIST
83845: LIST
83846: LIST
83847: LIST
83848: LIST
83849: LIST
83850: LIST
83851: LIST
83852: LIST
83853: LIST
83854: LIST
83855: LIST
83856: LIST
83857: LIST
83858: LIST
83859: LIST
83860: LIST
83861: LIST
83862: LIST
83863: LIST
83864: PUSH
83865: LD_INT 101
83867: PUSH
83868: LD_INT 102
83870: PUSH
83871: LD_INT 103
83873: PUSH
83874: LD_INT 104
83876: PUSH
83877: LD_INT 105
83879: PUSH
83880: LD_INT 106
83882: PUSH
83883: LD_INT 107
83885: PUSH
83886: LD_INT 108
83888: PUSH
83889: LD_INT 109
83891: PUSH
83892: LD_INT 110
83894: PUSH
83895: LD_INT 111
83897: PUSH
83898: LD_INT 112
83900: PUSH
83901: LD_INT 113
83903: PUSH
83904: LD_INT 114
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: LIST
83911: LIST
83912: LIST
83913: LIST
83914: LIST
83915: LIST
83916: LIST
83917: LIST
83918: LIST
83919: LIST
83920: LIST
83921: LIST
83922: PUSH
83923: EMPTY
83924: LIST
83925: LIST
83926: ST_TO_ADDR
83927: GO 85094
83929: LD_INT 14
83931: DOUBLE
83932: EQUAL
83933: IFTRUE 83937
83935: GO 84149
83937: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
83938: LD_ADDR_VAR 0 1
83942: PUSH
83943: LD_INT 1
83945: PUSH
83946: LD_INT 2
83948: PUSH
83949: LD_INT 3
83951: PUSH
83952: LD_INT 4
83954: PUSH
83955: LD_INT 5
83957: PUSH
83958: LD_INT 6
83960: PUSH
83961: LD_INT 7
83963: PUSH
83964: LD_INT 8
83966: PUSH
83967: LD_INT 9
83969: PUSH
83970: LD_INT 10
83972: PUSH
83973: LD_INT 11
83975: PUSH
83976: LD_INT 12
83978: PUSH
83979: LD_INT 13
83981: PUSH
83982: LD_INT 14
83984: PUSH
83985: LD_INT 15
83987: PUSH
83988: LD_INT 16
83990: PUSH
83991: LD_INT 17
83993: PUSH
83994: LD_INT 18
83996: PUSH
83997: LD_INT 19
83999: PUSH
84000: LD_INT 20
84002: PUSH
84003: LD_INT 21
84005: PUSH
84006: LD_INT 22
84008: PUSH
84009: LD_INT 23
84011: PUSH
84012: LD_INT 24
84014: PUSH
84015: LD_INT 25
84017: PUSH
84018: LD_INT 26
84020: PUSH
84021: LD_INT 27
84023: PUSH
84024: LD_INT 28
84026: PUSH
84027: LD_INT 29
84029: PUSH
84030: LD_INT 30
84032: PUSH
84033: LD_INT 31
84035: PUSH
84036: LD_INT 32
84038: PUSH
84039: LD_INT 33
84041: PUSH
84042: LD_INT 34
84044: PUSH
84045: LD_INT 36
84047: PUSH
84048: EMPTY
84049: LIST
84050: LIST
84051: LIST
84052: LIST
84053: LIST
84054: LIST
84055: LIST
84056: LIST
84057: LIST
84058: LIST
84059: LIST
84060: LIST
84061: LIST
84062: LIST
84063: LIST
84064: LIST
84065: LIST
84066: LIST
84067: LIST
84068: LIST
84069: LIST
84070: LIST
84071: LIST
84072: LIST
84073: LIST
84074: LIST
84075: LIST
84076: LIST
84077: LIST
84078: LIST
84079: LIST
84080: LIST
84081: LIST
84082: LIST
84083: LIST
84084: PUSH
84085: LD_INT 101
84087: PUSH
84088: LD_INT 102
84090: PUSH
84091: LD_INT 103
84093: PUSH
84094: LD_INT 104
84096: PUSH
84097: LD_INT 105
84099: PUSH
84100: LD_INT 106
84102: PUSH
84103: LD_INT 107
84105: PUSH
84106: LD_INT 108
84108: PUSH
84109: LD_INT 109
84111: PUSH
84112: LD_INT 110
84114: PUSH
84115: LD_INT 111
84117: PUSH
84118: LD_INT 112
84120: PUSH
84121: LD_INT 113
84123: PUSH
84124: LD_INT 114
84126: PUSH
84127: EMPTY
84128: LIST
84129: LIST
84130: LIST
84131: LIST
84132: LIST
84133: LIST
84134: LIST
84135: LIST
84136: LIST
84137: LIST
84138: LIST
84139: LIST
84140: LIST
84141: LIST
84142: PUSH
84143: EMPTY
84144: LIST
84145: LIST
84146: ST_TO_ADDR
84147: GO 85094
84149: LD_INT 15
84151: DOUBLE
84152: EQUAL
84153: IFTRUE 84157
84155: GO 84369
84157: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
84158: LD_ADDR_VAR 0 1
84162: PUSH
84163: LD_INT 1
84165: PUSH
84166: LD_INT 2
84168: PUSH
84169: LD_INT 3
84171: PUSH
84172: LD_INT 4
84174: PUSH
84175: LD_INT 5
84177: PUSH
84178: LD_INT 6
84180: PUSH
84181: LD_INT 7
84183: PUSH
84184: LD_INT 8
84186: PUSH
84187: LD_INT 9
84189: PUSH
84190: LD_INT 10
84192: PUSH
84193: LD_INT 11
84195: PUSH
84196: LD_INT 12
84198: PUSH
84199: LD_INT 13
84201: PUSH
84202: LD_INT 14
84204: PUSH
84205: LD_INT 15
84207: PUSH
84208: LD_INT 16
84210: PUSH
84211: LD_INT 17
84213: PUSH
84214: LD_INT 18
84216: PUSH
84217: LD_INT 19
84219: PUSH
84220: LD_INT 20
84222: PUSH
84223: LD_INT 21
84225: PUSH
84226: LD_INT 22
84228: PUSH
84229: LD_INT 23
84231: PUSH
84232: LD_INT 24
84234: PUSH
84235: LD_INT 25
84237: PUSH
84238: LD_INT 26
84240: PUSH
84241: LD_INT 27
84243: PUSH
84244: LD_INT 28
84246: PUSH
84247: LD_INT 29
84249: PUSH
84250: LD_INT 30
84252: PUSH
84253: LD_INT 31
84255: PUSH
84256: LD_INT 32
84258: PUSH
84259: LD_INT 33
84261: PUSH
84262: LD_INT 34
84264: PUSH
84265: LD_INT 36
84267: PUSH
84268: EMPTY
84269: LIST
84270: LIST
84271: LIST
84272: LIST
84273: LIST
84274: LIST
84275: LIST
84276: LIST
84277: LIST
84278: LIST
84279: LIST
84280: LIST
84281: LIST
84282: LIST
84283: LIST
84284: LIST
84285: LIST
84286: LIST
84287: LIST
84288: LIST
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: LIST
84295: LIST
84296: LIST
84297: LIST
84298: LIST
84299: LIST
84300: LIST
84301: LIST
84302: LIST
84303: LIST
84304: PUSH
84305: LD_INT 101
84307: PUSH
84308: LD_INT 102
84310: PUSH
84311: LD_INT 103
84313: PUSH
84314: LD_INT 104
84316: PUSH
84317: LD_INT 105
84319: PUSH
84320: LD_INT 106
84322: PUSH
84323: LD_INT 107
84325: PUSH
84326: LD_INT 108
84328: PUSH
84329: LD_INT 109
84331: PUSH
84332: LD_INT 110
84334: PUSH
84335: LD_INT 111
84337: PUSH
84338: LD_INT 112
84340: PUSH
84341: LD_INT 113
84343: PUSH
84344: LD_INT 114
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: LIST
84351: LIST
84352: LIST
84353: LIST
84354: LIST
84355: LIST
84356: LIST
84357: LIST
84358: LIST
84359: LIST
84360: LIST
84361: LIST
84362: PUSH
84363: EMPTY
84364: LIST
84365: LIST
84366: ST_TO_ADDR
84367: GO 85094
84369: LD_INT 16
84371: DOUBLE
84372: EQUAL
84373: IFTRUE 84377
84375: GO 84501
84377: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
84378: LD_ADDR_VAR 0 1
84382: PUSH
84383: LD_INT 2
84385: PUSH
84386: LD_INT 4
84388: PUSH
84389: LD_INT 5
84391: PUSH
84392: LD_INT 7
84394: PUSH
84395: LD_INT 11
84397: PUSH
84398: LD_INT 12
84400: PUSH
84401: LD_INT 15
84403: PUSH
84404: LD_INT 16
84406: PUSH
84407: LD_INT 20
84409: PUSH
84410: LD_INT 21
84412: PUSH
84413: LD_INT 22
84415: PUSH
84416: LD_INT 23
84418: PUSH
84419: LD_INT 25
84421: PUSH
84422: LD_INT 26
84424: PUSH
84425: LD_INT 30
84427: PUSH
84428: LD_INT 31
84430: PUSH
84431: LD_INT 32
84433: PUSH
84434: LD_INT 33
84436: PUSH
84437: LD_INT 34
84439: PUSH
84440: EMPTY
84441: LIST
84442: LIST
84443: LIST
84444: LIST
84445: LIST
84446: LIST
84447: LIST
84448: LIST
84449: LIST
84450: LIST
84451: LIST
84452: LIST
84453: LIST
84454: LIST
84455: LIST
84456: LIST
84457: LIST
84458: LIST
84459: LIST
84460: PUSH
84461: LD_INT 101
84463: PUSH
84464: LD_INT 102
84466: PUSH
84467: LD_INT 103
84469: PUSH
84470: LD_INT 106
84472: PUSH
84473: LD_INT 108
84475: PUSH
84476: LD_INT 112
84478: PUSH
84479: LD_INT 113
84481: PUSH
84482: LD_INT 114
84484: PUSH
84485: EMPTY
84486: LIST
84487: LIST
84488: LIST
84489: LIST
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: PUSH
84495: EMPTY
84496: LIST
84497: LIST
84498: ST_TO_ADDR
84499: GO 85094
84501: LD_INT 17
84503: DOUBLE
84504: EQUAL
84505: IFTRUE 84509
84507: GO 84721
84509: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
84510: LD_ADDR_VAR 0 1
84514: PUSH
84515: LD_INT 1
84517: PUSH
84518: LD_INT 2
84520: PUSH
84521: LD_INT 3
84523: PUSH
84524: LD_INT 4
84526: PUSH
84527: LD_INT 5
84529: PUSH
84530: LD_INT 6
84532: PUSH
84533: LD_INT 7
84535: PUSH
84536: LD_INT 8
84538: PUSH
84539: LD_INT 9
84541: PUSH
84542: LD_INT 10
84544: PUSH
84545: LD_INT 11
84547: PUSH
84548: LD_INT 12
84550: PUSH
84551: LD_INT 13
84553: PUSH
84554: LD_INT 14
84556: PUSH
84557: LD_INT 15
84559: PUSH
84560: LD_INT 16
84562: PUSH
84563: LD_INT 17
84565: PUSH
84566: LD_INT 18
84568: PUSH
84569: LD_INT 19
84571: PUSH
84572: LD_INT 20
84574: PUSH
84575: LD_INT 21
84577: PUSH
84578: LD_INT 22
84580: PUSH
84581: LD_INT 23
84583: PUSH
84584: LD_INT 24
84586: PUSH
84587: LD_INT 25
84589: PUSH
84590: LD_INT 26
84592: PUSH
84593: LD_INT 27
84595: PUSH
84596: LD_INT 28
84598: PUSH
84599: LD_INT 29
84601: PUSH
84602: LD_INT 30
84604: PUSH
84605: LD_INT 31
84607: PUSH
84608: LD_INT 32
84610: PUSH
84611: LD_INT 33
84613: PUSH
84614: LD_INT 34
84616: PUSH
84617: LD_INT 36
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: LIST
84624: LIST
84625: LIST
84626: LIST
84627: LIST
84628: LIST
84629: LIST
84630: LIST
84631: LIST
84632: LIST
84633: LIST
84634: LIST
84635: LIST
84636: LIST
84637: LIST
84638: LIST
84639: LIST
84640: LIST
84641: LIST
84642: LIST
84643: LIST
84644: LIST
84645: LIST
84646: LIST
84647: LIST
84648: LIST
84649: LIST
84650: LIST
84651: LIST
84652: LIST
84653: LIST
84654: LIST
84655: LIST
84656: PUSH
84657: LD_INT 101
84659: PUSH
84660: LD_INT 102
84662: PUSH
84663: LD_INT 103
84665: PUSH
84666: LD_INT 104
84668: PUSH
84669: LD_INT 105
84671: PUSH
84672: LD_INT 106
84674: PUSH
84675: LD_INT 107
84677: PUSH
84678: LD_INT 108
84680: PUSH
84681: LD_INT 109
84683: PUSH
84684: LD_INT 110
84686: PUSH
84687: LD_INT 111
84689: PUSH
84690: LD_INT 112
84692: PUSH
84693: LD_INT 113
84695: PUSH
84696: LD_INT 114
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: LIST
84703: LIST
84704: LIST
84705: LIST
84706: LIST
84707: LIST
84708: LIST
84709: LIST
84710: LIST
84711: LIST
84712: LIST
84713: LIST
84714: PUSH
84715: EMPTY
84716: LIST
84717: LIST
84718: ST_TO_ADDR
84719: GO 85094
84721: LD_INT 18
84723: DOUBLE
84724: EQUAL
84725: IFTRUE 84729
84727: GO 84865
84729: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
84730: LD_ADDR_VAR 0 1
84734: PUSH
84735: LD_INT 2
84737: PUSH
84738: LD_INT 4
84740: PUSH
84741: LD_INT 5
84743: PUSH
84744: LD_INT 7
84746: PUSH
84747: LD_INT 11
84749: PUSH
84750: LD_INT 12
84752: PUSH
84753: LD_INT 15
84755: PUSH
84756: LD_INT 16
84758: PUSH
84759: LD_INT 20
84761: PUSH
84762: LD_INT 21
84764: PUSH
84765: LD_INT 22
84767: PUSH
84768: LD_INT 23
84770: PUSH
84771: LD_INT 25
84773: PUSH
84774: LD_INT 26
84776: PUSH
84777: LD_INT 30
84779: PUSH
84780: LD_INT 31
84782: PUSH
84783: LD_INT 32
84785: PUSH
84786: LD_INT 33
84788: PUSH
84789: LD_INT 34
84791: PUSH
84792: LD_INT 35
84794: PUSH
84795: LD_INT 36
84797: PUSH
84798: EMPTY
84799: LIST
84800: LIST
84801: LIST
84802: LIST
84803: LIST
84804: LIST
84805: LIST
84806: LIST
84807: LIST
84808: LIST
84809: LIST
84810: LIST
84811: LIST
84812: LIST
84813: LIST
84814: LIST
84815: LIST
84816: LIST
84817: LIST
84818: LIST
84819: LIST
84820: PUSH
84821: LD_INT 101
84823: PUSH
84824: LD_INT 102
84826: PUSH
84827: LD_INT 103
84829: PUSH
84830: LD_INT 106
84832: PUSH
84833: LD_INT 108
84835: PUSH
84836: LD_INT 112
84838: PUSH
84839: LD_INT 113
84841: PUSH
84842: LD_INT 114
84844: PUSH
84845: LD_INT 115
84847: PUSH
84848: EMPTY
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: LIST
84855: LIST
84856: LIST
84857: LIST
84858: PUSH
84859: EMPTY
84860: LIST
84861: LIST
84862: ST_TO_ADDR
84863: GO 85094
84865: LD_INT 19
84867: DOUBLE
84868: EQUAL
84869: IFTRUE 84873
84871: GO 85093
84873: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
84874: LD_ADDR_VAR 0 1
84878: PUSH
84879: LD_INT 1
84881: PUSH
84882: LD_INT 2
84884: PUSH
84885: LD_INT 3
84887: PUSH
84888: LD_INT 4
84890: PUSH
84891: LD_INT 5
84893: PUSH
84894: LD_INT 6
84896: PUSH
84897: LD_INT 7
84899: PUSH
84900: LD_INT 8
84902: PUSH
84903: LD_INT 9
84905: PUSH
84906: LD_INT 10
84908: PUSH
84909: LD_INT 11
84911: PUSH
84912: LD_INT 12
84914: PUSH
84915: LD_INT 13
84917: PUSH
84918: LD_INT 14
84920: PUSH
84921: LD_INT 15
84923: PUSH
84924: LD_INT 16
84926: PUSH
84927: LD_INT 17
84929: PUSH
84930: LD_INT 18
84932: PUSH
84933: LD_INT 19
84935: PUSH
84936: LD_INT 20
84938: PUSH
84939: LD_INT 21
84941: PUSH
84942: LD_INT 22
84944: PUSH
84945: LD_INT 23
84947: PUSH
84948: LD_INT 24
84950: PUSH
84951: LD_INT 25
84953: PUSH
84954: LD_INT 26
84956: PUSH
84957: LD_INT 27
84959: PUSH
84960: LD_INT 28
84962: PUSH
84963: LD_INT 29
84965: PUSH
84966: LD_INT 30
84968: PUSH
84969: LD_INT 31
84971: PUSH
84972: LD_INT 32
84974: PUSH
84975: LD_INT 33
84977: PUSH
84978: LD_INT 34
84980: PUSH
84981: LD_INT 35
84983: PUSH
84984: LD_INT 36
84986: PUSH
84987: EMPTY
84988: LIST
84989: LIST
84990: LIST
84991: LIST
84992: LIST
84993: LIST
84994: LIST
84995: LIST
84996: LIST
84997: LIST
84998: LIST
84999: LIST
85000: LIST
85001: LIST
85002: LIST
85003: LIST
85004: LIST
85005: LIST
85006: LIST
85007: LIST
85008: LIST
85009: LIST
85010: LIST
85011: LIST
85012: LIST
85013: LIST
85014: LIST
85015: LIST
85016: LIST
85017: LIST
85018: LIST
85019: LIST
85020: LIST
85021: LIST
85022: LIST
85023: LIST
85024: PUSH
85025: LD_INT 101
85027: PUSH
85028: LD_INT 102
85030: PUSH
85031: LD_INT 103
85033: PUSH
85034: LD_INT 104
85036: PUSH
85037: LD_INT 105
85039: PUSH
85040: LD_INT 106
85042: PUSH
85043: LD_INT 107
85045: PUSH
85046: LD_INT 108
85048: PUSH
85049: LD_INT 109
85051: PUSH
85052: LD_INT 110
85054: PUSH
85055: LD_INT 111
85057: PUSH
85058: LD_INT 112
85060: PUSH
85061: LD_INT 113
85063: PUSH
85064: LD_INT 114
85066: PUSH
85067: LD_INT 115
85069: PUSH
85070: EMPTY
85071: LIST
85072: LIST
85073: LIST
85074: LIST
85075: LIST
85076: LIST
85077: LIST
85078: LIST
85079: LIST
85080: LIST
85081: LIST
85082: LIST
85083: LIST
85084: LIST
85085: LIST
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: ST_TO_ADDR
85091: GO 85094
85093: POP
// end else
85094: GO 85313
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
85096: LD_ADDR_VAR 0 1
85100: PUSH
85101: LD_INT 1
85103: PUSH
85104: LD_INT 2
85106: PUSH
85107: LD_INT 3
85109: PUSH
85110: LD_INT 4
85112: PUSH
85113: LD_INT 5
85115: PUSH
85116: LD_INT 6
85118: PUSH
85119: LD_INT 7
85121: PUSH
85122: LD_INT 8
85124: PUSH
85125: LD_INT 9
85127: PUSH
85128: LD_INT 10
85130: PUSH
85131: LD_INT 11
85133: PUSH
85134: LD_INT 12
85136: PUSH
85137: LD_INT 13
85139: PUSH
85140: LD_INT 14
85142: PUSH
85143: LD_INT 15
85145: PUSH
85146: LD_INT 16
85148: PUSH
85149: LD_INT 17
85151: PUSH
85152: LD_INT 18
85154: PUSH
85155: LD_INT 19
85157: PUSH
85158: LD_INT 20
85160: PUSH
85161: LD_INT 21
85163: PUSH
85164: LD_INT 22
85166: PUSH
85167: LD_INT 23
85169: PUSH
85170: LD_INT 24
85172: PUSH
85173: LD_INT 25
85175: PUSH
85176: LD_INT 26
85178: PUSH
85179: LD_INT 27
85181: PUSH
85182: LD_INT 28
85184: PUSH
85185: LD_INT 29
85187: PUSH
85188: LD_INT 30
85190: PUSH
85191: LD_INT 31
85193: PUSH
85194: LD_INT 32
85196: PUSH
85197: LD_INT 33
85199: PUSH
85200: LD_INT 34
85202: PUSH
85203: LD_INT 35
85205: PUSH
85206: LD_INT 36
85208: PUSH
85209: EMPTY
85210: LIST
85211: LIST
85212: LIST
85213: LIST
85214: LIST
85215: LIST
85216: LIST
85217: LIST
85218: LIST
85219: LIST
85220: LIST
85221: LIST
85222: LIST
85223: LIST
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: LIST
85232: LIST
85233: LIST
85234: LIST
85235: LIST
85236: LIST
85237: LIST
85238: LIST
85239: LIST
85240: LIST
85241: LIST
85242: LIST
85243: LIST
85244: LIST
85245: LIST
85246: PUSH
85247: LD_INT 101
85249: PUSH
85250: LD_INT 102
85252: PUSH
85253: LD_INT 103
85255: PUSH
85256: LD_INT 104
85258: PUSH
85259: LD_INT 105
85261: PUSH
85262: LD_INT 106
85264: PUSH
85265: LD_INT 107
85267: PUSH
85268: LD_INT 108
85270: PUSH
85271: LD_INT 109
85273: PUSH
85274: LD_INT 110
85276: PUSH
85277: LD_INT 111
85279: PUSH
85280: LD_INT 112
85282: PUSH
85283: LD_INT 113
85285: PUSH
85286: LD_INT 114
85288: PUSH
85289: LD_INT 115
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: LIST
85296: LIST
85297: LIST
85298: LIST
85299: LIST
85300: LIST
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: LIST
85307: LIST
85308: PUSH
85309: EMPTY
85310: LIST
85311: LIST
85312: ST_TO_ADDR
// if result then
85313: LD_VAR 0 1
85317: IFFALSE 85606
// begin normal :=  ;
85319: LD_ADDR_VAR 0 3
85323: PUSH
85324: LD_STRING 
85326: ST_TO_ADDR
// hardcore :=  ;
85327: LD_ADDR_VAR 0 4
85331: PUSH
85332: LD_STRING 
85334: ST_TO_ADDR
// for i = 1 to normalCounter do
85335: LD_ADDR_VAR 0 5
85339: PUSH
85340: DOUBLE
85341: LD_INT 1
85343: DEC
85344: ST_TO_ADDR
85345: LD_EXP 110
85349: PUSH
85350: FOR_TO
85351: IFFALSE 85452
// begin tmp := 0 ;
85353: LD_ADDR_VAR 0 2
85357: PUSH
85358: LD_STRING 0
85360: ST_TO_ADDR
// if result [ 1 ] then
85361: LD_VAR 0 1
85365: PUSH
85366: LD_INT 1
85368: ARRAY
85369: IFFALSE 85434
// if result [ 1 ] [ 1 ] = i then
85371: LD_VAR 0 1
85375: PUSH
85376: LD_INT 1
85378: ARRAY
85379: PUSH
85380: LD_INT 1
85382: ARRAY
85383: PUSH
85384: LD_VAR 0 5
85388: EQUAL
85389: IFFALSE 85434
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
85391: LD_ADDR_VAR 0 1
85395: PUSH
85396: LD_VAR 0 1
85400: PPUSH
85401: LD_INT 1
85403: PPUSH
85404: LD_VAR 0 1
85408: PUSH
85409: LD_INT 1
85411: ARRAY
85412: PPUSH
85413: LD_INT 1
85415: PPUSH
85416: CALL_OW 3
85420: PPUSH
85421: CALL_OW 1
85425: ST_TO_ADDR
// tmp := 1 ;
85426: LD_ADDR_VAR 0 2
85430: PUSH
85431: LD_STRING 1
85433: ST_TO_ADDR
// end ; normal := normal & tmp ;
85434: LD_ADDR_VAR 0 3
85438: PUSH
85439: LD_VAR 0 3
85443: PUSH
85444: LD_VAR 0 2
85448: STR
85449: ST_TO_ADDR
// end ;
85450: GO 85350
85452: POP
85453: POP
// for i = 1 to hardcoreCounter do
85454: LD_ADDR_VAR 0 5
85458: PUSH
85459: DOUBLE
85460: LD_INT 1
85462: DEC
85463: ST_TO_ADDR
85464: LD_EXP 111
85468: PUSH
85469: FOR_TO
85470: IFFALSE 85575
// begin tmp := 0 ;
85472: LD_ADDR_VAR 0 2
85476: PUSH
85477: LD_STRING 0
85479: ST_TO_ADDR
// if result [ 2 ] then
85480: LD_VAR 0 1
85484: PUSH
85485: LD_INT 2
85487: ARRAY
85488: IFFALSE 85557
// if result [ 2 ] [ 1 ] = 100 + i then
85490: LD_VAR 0 1
85494: PUSH
85495: LD_INT 2
85497: ARRAY
85498: PUSH
85499: LD_INT 1
85501: ARRAY
85502: PUSH
85503: LD_INT 100
85505: PUSH
85506: LD_VAR 0 5
85510: PLUS
85511: EQUAL
85512: IFFALSE 85557
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
85514: LD_ADDR_VAR 0 1
85518: PUSH
85519: LD_VAR 0 1
85523: PPUSH
85524: LD_INT 2
85526: PPUSH
85527: LD_VAR 0 1
85531: PUSH
85532: LD_INT 2
85534: ARRAY
85535: PPUSH
85536: LD_INT 1
85538: PPUSH
85539: CALL_OW 3
85543: PPUSH
85544: CALL_OW 1
85548: ST_TO_ADDR
// tmp := 1 ;
85549: LD_ADDR_VAR 0 2
85553: PUSH
85554: LD_STRING 1
85556: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
85557: LD_ADDR_VAR 0 4
85561: PUSH
85562: LD_VAR 0 4
85566: PUSH
85567: LD_VAR 0 2
85571: STR
85572: ST_TO_ADDR
// end ;
85573: GO 85469
85575: POP
85576: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
85577: LD_STRING getStreamItemsFromMission("
85579: PUSH
85580: LD_VAR 0 3
85584: STR
85585: PUSH
85586: LD_STRING ","
85588: STR
85589: PUSH
85590: LD_VAR 0 4
85594: STR
85595: PUSH
85596: LD_STRING ")
85598: STR
85599: PPUSH
85600: CALL_OW 559
// end else
85604: GO 85613
// ToLua ( getStreamItemsFromMission("","") ) ;
85606: LD_STRING getStreamItemsFromMission("","")
85608: PPUSH
85609: CALL_OW 559
// end ;
85613: LD_VAR 0 1
85617: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
85618: LD_EXP 109
85622: PUSH
85623: LD_EXP 114
85627: AND
85628: IFFALSE 85752
85630: GO 85632
85632: DISABLE
85633: LD_INT 0
85635: PPUSH
85636: PPUSH
// begin enable ;
85637: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
85638: LD_ADDR_VAR 0 2
85642: PUSH
85643: LD_INT 22
85645: PUSH
85646: LD_OWVAR 2
85650: PUSH
85651: EMPTY
85652: LIST
85653: LIST
85654: PUSH
85655: LD_INT 2
85657: PUSH
85658: LD_INT 34
85660: PUSH
85661: LD_INT 7
85663: PUSH
85664: EMPTY
85665: LIST
85666: LIST
85667: PUSH
85668: LD_INT 34
85670: PUSH
85671: LD_INT 45
85673: PUSH
85674: EMPTY
85675: LIST
85676: LIST
85677: PUSH
85678: LD_INT 34
85680: PUSH
85681: LD_INT 28
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PUSH
85688: LD_INT 34
85690: PUSH
85691: LD_INT 47
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: PUSH
85698: EMPTY
85699: LIST
85700: LIST
85701: LIST
85702: LIST
85703: LIST
85704: PUSH
85705: EMPTY
85706: LIST
85707: LIST
85708: PPUSH
85709: CALL_OW 69
85713: ST_TO_ADDR
// if not tmp then
85714: LD_VAR 0 2
85718: NOT
85719: IFFALSE 85723
// exit ;
85721: GO 85752
// for i in tmp do
85723: LD_ADDR_VAR 0 1
85727: PUSH
85728: LD_VAR 0 2
85732: PUSH
85733: FOR_IN
85734: IFFALSE 85750
// begin SetLives ( i , 0 ) ;
85736: LD_VAR 0 1
85740: PPUSH
85741: LD_INT 0
85743: PPUSH
85744: CALL_OW 234
// end ;
85748: GO 85733
85750: POP
85751: POP
// end ;
85752: PPOPN 2
85754: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
85755: LD_EXP 109
85759: PUSH
85760: LD_EXP 115
85764: AND
85765: IFFALSE 85849
85767: GO 85769
85769: DISABLE
85770: LD_INT 0
85772: PPUSH
85773: PPUSH
// begin enable ;
85774: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
85775: LD_ADDR_VAR 0 2
85779: PUSH
85780: LD_INT 22
85782: PUSH
85783: LD_OWVAR 2
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: PUSH
85792: LD_INT 32
85794: PUSH
85795: LD_INT 3
85797: PUSH
85798: EMPTY
85799: LIST
85800: LIST
85801: PUSH
85802: EMPTY
85803: LIST
85804: LIST
85805: PPUSH
85806: CALL_OW 69
85810: ST_TO_ADDR
// if not tmp then
85811: LD_VAR 0 2
85815: NOT
85816: IFFALSE 85820
// exit ;
85818: GO 85849
// for i in tmp do
85820: LD_ADDR_VAR 0 1
85824: PUSH
85825: LD_VAR 0 2
85829: PUSH
85830: FOR_IN
85831: IFFALSE 85847
// begin SetLives ( i , 0 ) ;
85833: LD_VAR 0 1
85837: PPUSH
85838: LD_INT 0
85840: PPUSH
85841: CALL_OW 234
// end ;
85845: GO 85830
85847: POP
85848: POP
// end ;
85849: PPOPN 2
85851: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
85852: LD_EXP 109
85856: PUSH
85857: LD_EXP 112
85861: AND
85862: IFFALSE 85955
85864: GO 85866
85866: DISABLE
85867: LD_INT 0
85869: PPUSH
// begin enable ;
85870: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
85871: LD_ADDR_VAR 0 1
85875: PUSH
85876: LD_INT 22
85878: PUSH
85879: LD_OWVAR 2
85883: PUSH
85884: EMPTY
85885: LIST
85886: LIST
85887: PUSH
85888: LD_INT 2
85890: PUSH
85891: LD_INT 25
85893: PUSH
85894: LD_INT 5
85896: PUSH
85897: EMPTY
85898: LIST
85899: LIST
85900: PUSH
85901: LD_INT 25
85903: PUSH
85904: LD_INT 9
85906: PUSH
85907: EMPTY
85908: LIST
85909: LIST
85910: PUSH
85911: LD_INT 25
85913: PUSH
85914: LD_INT 8
85916: PUSH
85917: EMPTY
85918: LIST
85919: LIST
85920: PUSH
85921: EMPTY
85922: LIST
85923: LIST
85924: LIST
85925: LIST
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PPUSH
85931: CALL_OW 69
85935: PUSH
85936: FOR_IN
85937: IFFALSE 85953
// begin SetClass ( i , 1 ) ;
85939: LD_VAR 0 1
85943: PPUSH
85944: LD_INT 1
85946: PPUSH
85947: CALL_OW 336
// end ;
85951: GO 85936
85953: POP
85954: POP
// end ;
85955: PPOPN 1
85957: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
85958: LD_EXP 109
85962: PUSH
85963: LD_EXP 113
85967: AND
85968: PUSH
85969: LD_OWVAR 65
85973: PUSH
85974: LD_INT 7
85976: LESS
85977: AND
85978: IFFALSE 85992
85980: GO 85982
85982: DISABLE
// begin enable ;
85983: ENABLE
// game_speed := 7 ;
85984: LD_ADDR_OWVAR 65
85988: PUSH
85989: LD_INT 7
85991: ST_TO_ADDR
// end ;
85992: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
85993: LD_EXP 109
85997: PUSH
85998: LD_EXP 116
86002: AND
86003: IFFALSE 86205
86005: GO 86007
86007: DISABLE
86008: LD_INT 0
86010: PPUSH
86011: PPUSH
86012: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
86013: LD_ADDR_VAR 0 3
86017: PUSH
86018: LD_INT 81
86020: PUSH
86021: LD_OWVAR 2
86025: PUSH
86026: EMPTY
86027: LIST
86028: LIST
86029: PUSH
86030: LD_INT 21
86032: PUSH
86033: LD_INT 1
86035: PUSH
86036: EMPTY
86037: LIST
86038: LIST
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: PPUSH
86044: CALL_OW 69
86048: ST_TO_ADDR
// if not tmp then
86049: LD_VAR 0 3
86053: NOT
86054: IFFALSE 86058
// exit ;
86056: GO 86205
// if tmp > 5 then
86058: LD_VAR 0 3
86062: PUSH
86063: LD_INT 5
86065: GREATER
86066: IFFALSE 86078
// k := 5 else
86068: LD_ADDR_VAR 0 2
86072: PUSH
86073: LD_INT 5
86075: ST_TO_ADDR
86076: GO 86088
// k := tmp ;
86078: LD_ADDR_VAR 0 2
86082: PUSH
86083: LD_VAR 0 3
86087: ST_TO_ADDR
// for i := 1 to k do
86088: LD_ADDR_VAR 0 1
86092: PUSH
86093: DOUBLE
86094: LD_INT 1
86096: DEC
86097: ST_TO_ADDR
86098: LD_VAR 0 2
86102: PUSH
86103: FOR_TO
86104: IFFALSE 86203
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
86106: LD_VAR 0 3
86110: PUSH
86111: LD_VAR 0 1
86115: ARRAY
86116: PPUSH
86117: LD_VAR 0 1
86121: PUSH
86122: LD_INT 4
86124: MOD
86125: PUSH
86126: LD_INT 1
86128: PLUS
86129: PPUSH
86130: CALL_OW 259
86134: PUSH
86135: LD_INT 10
86137: LESS
86138: IFFALSE 86201
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
86140: LD_VAR 0 3
86144: PUSH
86145: LD_VAR 0 1
86149: ARRAY
86150: PPUSH
86151: LD_VAR 0 1
86155: PUSH
86156: LD_INT 4
86158: MOD
86159: PUSH
86160: LD_INT 1
86162: PLUS
86163: PPUSH
86164: LD_VAR 0 3
86168: PUSH
86169: LD_VAR 0 1
86173: ARRAY
86174: PPUSH
86175: LD_VAR 0 1
86179: PUSH
86180: LD_INT 4
86182: MOD
86183: PUSH
86184: LD_INT 1
86186: PLUS
86187: PPUSH
86188: CALL_OW 259
86192: PUSH
86193: LD_INT 1
86195: PLUS
86196: PPUSH
86197: CALL_OW 237
86201: GO 86103
86203: POP
86204: POP
// end ;
86205: PPOPN 3
86207: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
86208: LD_EXP 109
86212: PUSH
86213: LD_EXP 117
86217: AND
86218: IFFALSE 86238
86220: GO 86222
86222: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
86223: LD_INT 4
86225: PPUSH
86226: LD_OWVAR 2
86230: PPUSH
86231: LD_INT 0
86233: PPUSH
86234: CALL_OW 324
86238: END
// every 0 0$1 trigger StreamModeActive and sShovel do
86239: LD_EXP 109
86243: PUSH
86244: LD_EXP 146
86248: AND
86249: IFFALSE 86269
86251: GO 86253
86253: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
86254: LD_INT 19
86256: PPUSH
86257: LD_OWVAR 2
86261: PPUSH
86262: LD_INT 0
86264: PPUSH
86265: CALL_OW 324
86269: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
86270: LD_EXP 109
86274: PUSH
86275: LD_EXP 118
86279: AND
86280: IFFALSE 86382
86282: GO 86284
86284: DISABLE
86285: LD_INT 0
86287: PPUSH
86288: PPUSH
// begin enable ;
86289: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
86290: LD_ADDR_VAR 0 2
86294: PUSH
86295: LD_INT 22
86297: PUSH
86298: LD_OWVAR 2
86302: PUSH
86303: EMPTY
86304: LIST
86305: LIST
86306: PUSH
86307: LD_INT 2
86309: PUSH
86310: LD_INT 34
86312: PUSH
86313: LD_INT 11
86315: PUSH
86316: EMPTY
86317: LIST
86318: LIST
86319: PUSH
86320: LD_INT 34
86322: PUSH
86323: LD_INT 30
86325: PUSH
86326: EMPTY
86327: LIST
86328: LIST
86329: PUSH
86330: EMPTY
86331: LIST
86332: LIST
86333: LIST
86334: PUSH
86335: EMPTY
86336: LIST
86337: LIST
86338: PPUSH
86339: CALL_OW 69
86343: ST_TO_ADDR
// if not tmp then
86344: LD_VAR 0 2
86348: NOT
86349: IFFALSE 86353
// exit ;
86351: GO 86382
// for i in tmp do
86353: LD_ADDR_VAR 0 1
86357: PUSH
86358: LD_VAR 0 2
86362: PUSH
86363: FOR_IN
86364: IFFALSE 86380
// begin SetLives ( i , 0 ) ;
86366: LD_VAR 0 1
86370: PPUSH
86371: LD_INT 0
86373: PPUSH
86374: CALL_OW 234
// end ;
86378: GO 86363
86380: POP
86381: POP
// end ;
86382: PPOPN 2
86384: END
// every 0 0$1 trigger StreamModeActive and sBunker do
86385: LD_EXP 109
86389: PUSH
86390: LD_EXP 119
86394: AND
86395: IFFALSE 86415
86397: GO 86399
86399: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
86400: LD_INT 32
86402: PPUSH
86403: LD_OWVAR 2
86407: PPUSH
86408: LD_INT 0
86410: PPUSH
86411: CALL_OW 324
86415: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
86416: LD_EXP 109
86420: PUSH
86421: LD_EXP 120
86425: AND
86426: IFFALSE 86607
86428: GO 86430
86430: DISABLE
86431: LD_INT 0
86433: PPUSH
86434: PPUSH
86435: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
86436: LD_ADDR_VAR 0 2
86440: PUSH
86441: LD_INT 22
86443: PUSH
86444: LD_OWVAR 2
86448: PUSH
86449: EMPTY
86450: LIST
86451: LIST
86452: PUSH
86453: LD_INT 33
86455: PUSH
86456: LD_INT 3
86458: PUSH
86459: EMPTY
86460: LIST
86461: LIST
86462: PUSH
86463: EMPTY
86464: LIST
86465: LIST
86466: PPUSH
86467: CALL_OW 69
86471: ST_TO_ADDR
// if not tmp then
86472: LD_VAR 0 2
86476: NOT
86477: IFFALSE 86481
// exit ;
86479: GO 86607
// side := 0 ;
86481: LD_ADDR_VAR 0 3
86485: PUSH
86486: LD_INT 0
86488: ST_TO_ADDR
// for i := 1 to 8 do
86489: LD_ADDR_VAR 0 1
86493: PUSH
86494: DOUBLE
86495: LD_INT 1
86497: DEC
86498: ST_TO_ADDR
86499: LD_INT 8
86501: PUSH
86502: FOR_TO
86503: IFFALSE 86551
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
86505: LD_OWVAR 2
86509: PUSH
86510: LD_VAR 0 1
86514: NONEQUAL
86515: PUSH
86516: LD_OWVAR 2
86520: PPUSH
86521: LD_VAR 0 1
86525: PPUSH
86526: CALL_OW 81
86530: PUSH
86531: LD_INT 2
86533: EQUAL
86534: AND
86535: IFFALSE 86549
// begin side := i ;
86537: LD_ADDR_VAR 0 3
86541: PUSH
86542: LD_VAR 0 1
86546: ST_TO_ADDR
// break ;
86547: GO 86551
// end ;
86549: GO 86502
86551: POP
86552: POP
// if not side then
86553: LD_VAR 0 3
86557: NOT
86558: IFFALSE 86562
// exit ;
86560: GO 86607
// for i := 1 to tmp do
86562: LD_ADDR_VAR 0 1
86566: PUSH
86567: DOUBLE
86568: LD_INT 1
86570: DEC
86571: ST_TO_ADDR
86572: LD_VAR 0 2
86576: PUSH
86577: FOR_TO
86578: IFFALSE 86605
// if Prob ( 60 ) then
86580: LD_INT 60
86582: PPUSH
86583: CALL_OW 13
86587: IFFALSE 86603
// SetSide ( i , side ) ;
86589: LD_VAR 0 1
86593: PPUSH
86594: LD_VAR 0 3
86598: PPUSH
86599: CALL_OW 235
86603: GO 86577
86605: POP
86606: POP
// end ;
86607: PPOPN 3
86609: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
86610: LD_EXP 109
86614: PUSH
86615: LD_EXP 122
86619: AND
86620: IFFALSE 86739
86622: GO 86624
86624: DISABLE
86625: LD_INT 0
86627: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
86628: LD_ADDR_VAR 0 1
86632: PUSH
86633: LD_INT 22
86635: PUSH
86636: LD_OWVAR 2
86640: PUSH
86641: EMPTY
86642: LIST
86643: LIST
86644: PUSH
86645: LD_INT 21
86647: PUSH
86648: LD_INT 1
86650: PUSH
86651: EMPTY
86652: LIST
86653: LIST
86654: PUSH
86655: LD_INT 3
86657: PUSH
86658: LD_INT 23
86660: PUSH
86661: LD_INT 0
86663: PUSH
86664: EMPTY
86665: LIST
86666: LIST
86667: PUSH
86668: EMPTY
86669: LIST
86670: LIST
86671: PUSH
86672: EMPTY
86673: LIST
86674: LIST
86675: LIST
86676: PPUSH
86677: CALL_OW 69
86681: PUSH
86682: FOR_IN
86683: IFFALSE 86737
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
86685: LD_VAR 0 1
86689: PPUSH
86690: CALL_OW 257
86694: PUSH
86695: LD_INT 1
86697: PUSH
86698: LD_INT 2
86700: PUSH
86701: LD_INT 3
86703: PUSH
86704: LD_INT 4
86706: PUSH
86707: EMPTY
86708: LIST
86709: LIST
86710: LIST
86711: LIST
86712: IN
86713: IFFALSE 86735
// SetClass ( un , rand ( 1 , 4 ) ) ;
86715: LD_VAR 0 1
86719: PPUSH
86720: LD_INT 1
86722: PPUSH
86723: LD_INT 4
86725: PPUSH
86726: CALL_OW 12
86730: PPUSH
86731: CALL_OW 336
86735: GO 86682
86737: POP
86738: POP
// end ;
86739: PPOPN 1
86741: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
86742: LD_EXP 109
86746: PUSH
86747: LD_EXP 121
86751: AND
86752: IFFALSE 86831
86754: GO 86756
86756: DISABLE
86757: LD_INT 0
86759: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
86760: LD_ADDR_VAR 0 1
86764: PUSH
86765: LD_INT 22
86767: PUSH
86768: LD_OWVAR 2
86772: PUSH
86773: EMPTY
86774: LIST
86775: LIST
86776: PUSH
86777: LD_INT 21
86779: PUSH
86780: LD_INT 3
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: PPUSH
86791: CALL_OW 69
86795: ST_TO_ADDR
// if not tmp then
86796: LD_VAR 0 1
86800: NOT
86801: IFFALSE 86805
// exit ;
86803: GO 86831
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
86805: LD_VAR 0 1
86809: PUSH
86810: LD_INT 1
86812: PPUSH
86813: LD_VAR 0 1
86817: PPUSH
86818: CALL_OW 12
86822: ARRAY
86823: PPUSH
86824: LD_INT 100
86826: PPUSH
86827: CALL_OW 234
// end ;
86831: PPOPN 1
86833: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
86834: LD_EXP 109
86838: PUSH
86839: LD_EXP 123
86843: AND
86844: IFFALSE 86942
86846: GO 86848
86848: DISABLE
86849: LD_INT 0
86851: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
86852: LD_ADDR_VAR 0 1
86856: PUSH
86857: LD_INT 22
86859: PUSH
86860: LD_OWVAR 2
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: LD_INT 21
86871: PUSH
86872: LD_INT 1
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: PUSH
86879: EMPTY
86880: LIST
86881: LIST
86882: PPUSH
86883: CALL_OW 69
86887: ST_TO_ADDR
// if not tmp then
86888: LD_VAR 0 1
86892: NOT
86893: IFFALSE 86897
// exit ;
86895: GO 86942
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
86897: LD_VAR 0 1
86901: PUSH
86902: LD_INT 1
86904: PPUSH
86905: LD_VAR 0 1
86909: PPUSH
86910: CALL_OW 12
86914: ARRAY
86915: PPUSH
86916: LD_INT 1
86918: PPUSH
86919: LD_INT 4
86921: PPUSH
86922: CALL_OW 12
86926: PPUSH
86927: LD_INT 3000
86929: PPUSH
86930: LD_INT 9000
86932: PPUSH
86933: CALL_OW 12
86937: PPUSH
86938: CALL_OW 492
// end ;
86942: PPOPN 1
86944: END
// every 0 0$1 trigger StreamModeActive and sDepot do
86945: LD_EXP 109
86949: PUSH
86950: LD_EXP 124
86954: AND
86955: IFFALSE 86975
86957: GO 86959
86959: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
86960: LD_INT 1
86962: PPUSH
86963: LD_OWVAR 2
86967: PPUSH
86968: LD_INT 0
86970: PPUSH
86971: CALL_OW 324
86975: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
86976: LD_EXP 109
86980: PUSH
86981: LD_EXP 125
86985: AND
86986: IFFALSE 87069
86988: GO 86990
86990: DISABLE
86991: LD_INT 0
86993: PPUSH
86994: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
86995: LD_ADDR_VAR 0 2
86999: PUSH
87000: LD_INT 22
87002: PUSH
87003: LD_OWVAR 2
87007: PUSH
87008: EMPTY
87009: LIST
87010: LIST
87011: PUSH
87012: LD_INT 21
87014: PUSH
87015: LD_INT 3
87017: PUSH
87018: EMPTY
87019: LIST
87020: LIST
87021: PUSH
87022: EMPTY
87023: LIST
87024: LIST
87025: PPUSH
87026: CALL_OW 69
87030: ST_TO_ADDR
// if not tmp then
87031: LD_VAR 0 2
87035: NOT
87036: IFFALSE 87040
// exit ;
87038: GO 87069
// for i in tmp do
87040: LD_ADDR_VAR 0 1
87044: PUSH
87045: LD_VAR 0 2
87049: PUSH
87050: FOR_IN
87051: IFFALSE 87067
// SetBLevel ( i , 10 ) ;
87053: LD_VAR 0 1
87057: PPUSH
87058: LD_INT 10
87060: PPUSH
87061: CALL_OW 241
87065: GO 87050
87067: POP
87068: POP
// end ;
87069: PPOPN 2
87071: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
87072: LD_EXP 109
87076: PUSH
87077: LD_EXP 126
87081: AND
87082: IFFALSE 87193
87084: GO 87086
87086: DISABLE
87087: LD_INT 0
87089: PPUSH
87090: PPUSH
87091: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
87092: LD_ADDR_VAR 0 3
87096: PUSH
87097: LD_INT 22
87099: PUSH
87100: LD_OWVAR 2
87104: PUSH
87105: EMPTY
87106: LIST
87107: LIST
87108: PUSH
87109: LD_INT 25
87111: PUSH
87112: LD_INT 1
87114: PUSH
87115: EMPTY
87116: LIST
87117: LIST
87118: PUSH
87119: EMPTY
87120: LIST
87121: LIST
87122: PPUSH
87123: CALL_OW 69
87127: ST_TO_ADDR
// if not tmp then
87128: LD_VAR 0 3
87132: NOT
87133: IFFALSE 87137
// exit ;
87135: GO 87193
// un := tmp [ rand ( 1 , tmp ) ] ;
87137: LD_ADDR_VAR 0 2
87141: PUSH
87142: LD_VAR 0 3
87146: PUSH
87147: LD_INT 1
87149: PPUSH
87150: LD_VAR 0 3
87154: PPUSH
87155: CALL_OW 12
87159: ARRAY
87160: ST_TO_ADDR
// if Crawls ( un ) then
87161: LD_VAR 0 2
87165: PPUSH
87166: CALL_OW 318
87170: IFFALSE 87181
// ComWalk ( un ) ;
87172: LD_VAR 0 2
87176: PPUSH
87177: CALL_OW 138
// SetClass ( un , class_sniper ) ;
87181: LD_VAR 0 2
87185: PPUSH
87186: LD_INT 5
87188: PPUSH
87189: CALL_OW 336
// end ;
87193: PPOPN 3
87195: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
87196: LD_EXP 109
87200: PUSH
87201: LD_EXP 127
87205: AND
87206: PUSH
87207: LD_OWVAR 67
87211: PUSH
87212: LD_INT 3
87214: LESS
87215: AND
87216: IFFALSE 87235
87218: GO 87220
87220: DISABLE
// Difficulty := Difficulty + 1 ;
87221: LD_ADDR_OWVAR 67
87225: PUSH
87226: LD_OWVAR 67
87230: PUSH
87231: LD_INT 1
87233: PLUS
87234: ST_TO_ADDR
87235: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
87236: LD_EXP 109
87240: PUSH
87241: LD_EXP 128
87245: AND
87246: IFFALSE 87349
87248: GO 87250
87250: DISABLE
87251: LD_INT 0
87253: PPUSH
// begin for i := 1 to 5 do
87254: LD_ADDR_VAR 0 1
87258: PUSH
87259: DOUBLE
87260: LD_INT 1
87262: DEC
87263: ST_TO_ADDR
87264: LD_INT 5
87266: PUSH
87267: FOR_TO
87268: IFFALSE 87347
// begin uc_nation := nation_nature ;
87270: LD_ADDR_OWVAR 21
87274: PUSH
87275: LD_INT 0
87277: ST_TO_ADDR
// uc_side := 0 ;
87278: LD_ADDR_OWVAR 20
87282: PUSH
87283: LD_INT 0
87285: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
87286: LD_ADDR_OWVAR 29
87290: PUSH
87291: LD_INT 12
87293: PUSH
87294: LD_INT 12
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: ST_TO_ADDR
// hc_agressivity := 20 ;
87301: LD_ADDR_OWVAR 35
87305: PUSH
87306: LD_INT 20
87308: ST_TO_ADDR
// hc_class := class_tiger ;
87309: LD_ADDR_OWVAR 28
87313: PUSH
87314: LD_INT 14
87316: ST_TO_ADDR
// hc_gallery :=  ;
87317: LD_ADDR_OWVAR 33
87321: PUSH
87322: LD_STRING 
87324: ST_TO_ADDR
// hc_name :=  ;
87325: LD_ADDR_OWVAR 26
87329: PUSH
87330: LD_STRING 
87332: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
87333: CALL_OW 44
87337: PPUSH
87338: LD_INT 0
87340: PPUSH
87341: CALL_OW 51
// end ;
87345: GO 87267
87347: POP
87348: POP
// end ;
87349: PPOPN 1
87351: END
// every 0 0$1 trigger StreamModeActive and sBomb do
87352: LD_EXP 109
87356: PUSH
87357: LD_EXP 129
87361: AND
87362: IFFALSE 87371
87364: GO 87366
87366: DISABLE
// StreamSibBomb ;
87367: CALL 87372 0 0
87371: END
// export function StreamSibBomb ; var i , x , y ; begin
87372: LD_INT 0
87374: PPUSH
87375: PPUSH
87376: PPUSH
87377: PPUSH
// result := false ;
87378: LD_ADDR_VAR 0 1
87382: PUSH
87383: LD_INT 0
87385: ST_TO_ADDR
// for i := 1 to 16 do
87386: LD_ADDR_VAR 0 2
87390: PUSH
87391: DOUBLE
87392: LD_INT 1
87394: DEC
87395: ST_TO_ADDR
87396: LD_INT 16
87398: PUSH
87399: FOR_TO
87400: IFFALSE 87599
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
87402: LD_ADDR_VAR 0 3
87406: PUSH
87407: LD_INT 10
87409: PUSH
87410: LD_INT 20
87412: PUSH
87413: LD_INT 30
87415: PUSH
87416: LD_INT 40
87418: PUSH
87419: LD_INT 50
87421: PUSH
87422: LD_INT 60
87424: PUSH
87425: LD_INT 70
87427: PUSH
87428: LD_INT 80
87430: PUSH
87431: LD_INT 90
87433: PUSH
87434: LD_INT 100
87436: PUSH
87437: LD_INT 110
87439: PUSH
87440: LD_INT 120
87442: PUSH
87443: LD_INT 130
87445: PUSH
87446: LD_INT 140
87448: PUSH
87449: LD_INT 150
87451: PUSH
87452: EMPTY
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: LIST
87466: LIST
87467: LIST
87468: PUSH
87469: LD_INT 1
87471: PPUSH
87472: LD_INT 15
87474: PPUSH
87475: CALL_OW 12
87479: ARRAY
87480: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
87481: LD_ADDR_VAR 0 4
87485: PUSH
87486: LD_INT 10
87488: PUSH
87489: LD_INT 20
87491: PUSH
87492: LD_INT 30
87494: PUSH
87495: LD_INT 40
87497: PUSH
87498: LD_INT 50
87500: PUSH
87501: LD_INT 60
87503: PUSH
87504: LD_INT 70
87506: PUSH
87507: LD_INT 80
87509: PUSH
87510: LD_INT 90
87512: PUSH
87513: LD_INT 100
87515: PUSH
87516: LD_INT 110
87518: PUSH
87519: LD_INT 120
87521: PUSH
87522: LD_INT 130
87524: PUSH
87525: LD_INT 140
87527: PUSH
87528: LD_INT 150
87530: PUSH
87531: EMPTY
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: LIST
87540: LIST
87541: LIST
87542: LIST
87543: LIST
87544: LIST
87545: LIST
87546: LIST
87547: PUSH
87548: LD_INT 1
87550: PPUSH
87551: LD_INT 15
87553: PPUSH
87554: CALL_OW 12
87558: ARRAY
87559: ST_TO_ADDR
// if ValidHex ( x , y ) then
87560: LD_VAR 0 3
87564: PPUSH
87565: LD_VAR 0 4
87569: PPUSH
87570: CALL_OW 488
87574: IFFALSE 87597
// begin result := [ x , y ] ;
87576: LD_ADDR_VAR 0 1
87580: PUSH
87581: LD_VAR 0 3
87585: PUSH
87586: LD_VAR 0 4
87590: PUSH
87591: EMPTY
87592: LIST
87593: LIST
87594: ST_TO_ADDR
// break ;
87595: GO 87599
// end ; end ;
87597: GO 87399
87599: POP
87600: POP
// if result then
87601: LD_VAR 0 1
87605: IFFALSE 87665
// begin ToLua ( playSibBomb() ) ;
87607: LD_STRING playSibBomb()
87609: PPUSH
87610: CALL_OW 559
// wait ( 0 0$14 ) ;
87614: LD_INT 490
87616: PPUSH
87617: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
87621: LD_VAR 0 1
87625: PUSH
87626: LD_INT 1
87628: ARRAY
87629: PPUSH
87630: LD_VAR 0 1
87634: PUSH
87635: LD_INT 2
87637: ARRAY
87638: PPUSH
87639: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
87643: LD_VAR 0 1
87647: PUSH
87648: LD_INT 1
87650: ARRAY
87651: PPUSH
87652: LD_VAR 0 1
87656: PUSH
87657: LD_INT 2
87659: ARRAY
87660: PPUSH
87661: CALL_OW 429
// end ; end ;
87665: LD_VAR 0 1
87669: RET
// every 0 0$1 trigger StreamModeActive and sReset do
87670: LD_EXP 109
87674: PUSH
87675: LD_EXP 131
87679: AND
87680: IFFALSE 87692
87682: GO 87684
87684: DISABLE
// YouLost (  ) ;
87685: LD_STRING 
87687: PPUSH
87688: CALL_OW 104
87692: END
// every 0 0$1 trigger StreamModeActive and sFog do
87693: LD_EXP 109
87697: PUSH
87698: LD_EXP 130
87702: AND
87703: IFFALSE 87717
87705: GO 87707
87707: DISABLE
// FogOff ( your_side ) ;
87708: LD_OWVAR 2
87712: PPUSH
87713: CALL_OW 344
87717: END
// every 0 0$1 trigger StreamModeActive and sSun do
87718: LD_EXP 109
87722: PUSH
87723: LD_EXP 132
87727: AND
87728: IFFALSE 87756
87730: GO 87732
87732: DISABLE
// begin solar_recharge_percent := 0 ;
87733: LD_ADDR_OWVAR 79
87737: PUSH
87738: LD_INT 0
87740: ST_TO_ADDR
// wait ( 5 5$00 ) ;
87741: LD_INT 10500
87743: PPUSH
87744: CALL_OW 67
// solar_recharge_percent := 100 ;
87748: LD_ADDR_OWVAR 79
87752: PUSH
87753: LD_INT 100
87755: ST_TO_ADDR
// end ;
87756: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
87757: LD_EXP 109
87761: PUSH
87762: LD_EXP 133
87766: AND
87767: IFFALSE 88006
87769: GO 87771
87771: DISABLE
87772: LD_INT 0
87774: PPUSH
87775: PPUSH
87776: PPUSH
// begin tmp := [ ] ;
87777: LD_ADDR_VAR 0 3
87781: PUSH
87782: EMPTY
87783: ST_TO_ADDR
// for i := 1 to 6 do
87784: LD_ADDR_VAR 0 1
87788: PUSH
87789: DOUBLE
87790: LD_INT 1
87792: DEC
87793: ST_TO_ADDR
87794: LD_INT 6
87796: PUSH
87797: FOR_TO
87798: IFFALSE 87903
// begin uc_nation := nation_nature ;
87800: LD_ADDR_OWVAR 21
87804: PUSH
87805: LD_INT 0
87807: ST_TO_ADDR
// uc_side := 0 ;
87808: LD_ADDR_OWVAR 20
87812: PUSH
87813: LD_INT 0
87815: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
87816: LD_ADDR_OWVAR 29
87820: PUSH
87821: LD_INT 12
87823: PUSH
87824: LD_INT 12
87826: PUSH
87827: EMPTY
87828: LIST
87829: LIST
87830: ST_TO_ADDR
// hc_agressivity := 20 ;
87831: LD_ADDR_OWVAR 35
87835: PUSH
87836: LD_INT 20
87838: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
87839: LD_ADDR_OWVAR 28
87843: PUSH
87844: LD_INT 17
87846: ST_TO_ADDR
// hc_gallery :=  ;
87847: LD_ADDR_OWVAR 33
87851: PUSH
87852: LD_STRING 
87854: ST_TO_ADDR
// hc_name :=  ;
87855: LD_ADDR_OWVAR 26
87859: PUSH
87860: LD_STRING 
87862: ST_TO_ADDR
// un := CreateHuman ;
87863: LD_ADDR_VAR 0 2
87867: PUSH
87868: CALL_OW 44
87872: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
87873: LD_VAR 0 2
87877: PPUSH
87878: LD_INT 1
87880: PPUSH
87881: CALL_OW 51
// tmp := tmp ^ un ;
87885: LD_ADDR_VAR 0 3
87889: PUSH
87890: LD_VAR 0 3
87894: PUSH
87895: LD_VAR 0 2
87899: ADD
87900: ST_TO_ADDR
// end ;
87901: GO 87797
87903: POP
87904: POP
// repeat wait ( 0 0$1 ) ;
87905: LD_INT 35
87907: PPUSH
87908: CALL_OW 67
// for un in tmp do
87912: LD_ADDR_VAR 0 2
87916: PUSH
87917: LD_VAR 0 3
87921: PUSH
87922: FOR_IN
87923: IFFALSE 87997
// begin if IsDead ( un ) then
87925: LD_VAR 0 2
87929: PPUSH
87930: CALL_OW 301
87934: IFFALSE 87954
// begin tmp := tmp diff un ;
87936: LD_ADDR_VAR 0 3
87940: PUSH
87941: LD_VAR 0 3
87945: PUSH
87946: LD_VAR 0 2
87950: DIFF
87951: ST_TO_ADDR
// continue ;
87952: GO 87922
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
87954: LD_VAR 0 2
87958: PPUSH
87959: LD_INT 3
87961: PUSH
87962: LD_INT 22
87964: PUSH
87965: LD_INT 0
87967: PUSH
87968: EMPTY
87969: LIST
87970: LIST
87971: PUSH
87972: EMPTY
87973: LIST
87974: LIST
87975: PPUSH
87976: CALL_OW 69
87980: PPUSH
87981: LD_VAR 0 2
87985: PPUSH
87986: CALL_OW 74
87990: PPUSH
87991: CALL_OW 115
// end ;
87995: GO 87922
87997: POP
87998: POP
// until not tmp ;
87999: LD_VAR 0 3
88003: NOT
88004: IFFALSE 87905
// end ;
88006: PPOPN 3
88008: END
// every 0 0$1 trigger StreamModeActive and sTroll do
88009: LD_EXP 109
88013: PUSH
88014: LD_EXP 134
88018: AND
88019: IFFALSE 88073
88021: GO 88023
88023: DISABLE
// begin ToLua ( displayTroll(); ) ;
88024: LD_STRING displayTroll();
88026: PPUSH
88027: CALL_OW 559
// wait ( 3 3$00 ) ;
88031: LD_INT 6300
88033: PPUSH
88034: CALL_OW 67
// ToLua ( hideTroll(); ) ;
88038: LD_STRING hideTroll();
88040: PPUSH
88041: CALL_OW 559
// wait ( 1 1$00 ) ;
88045: LD_INT 2100
88047: PPUSH
88048: CALL_OW 67
// ToLua ( displayTroll(); ) ;
88052: LD_STRING displayTroll();
88054: PPUSH
88055: CALL_OW 559
// wait ( 1 1$00 ) ;
88059: LD_INT 2100
88061: PPUSH
88062: CALL_OW 67
// ToLua ( hideTroll(); ) ;
88066: LD_STRING hideTroll();
88068: PPUSH
88069: CALL_OW 559
// end ;
88073: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
88074: LD_EXP 109
88078: PUSH
88079: LD_EXP 135
88083: AND
88084: IFFALSE 88147
88086: GO 88088
88088: DISABLE
88089: LD_INT 0
88091: PPUSH
// begin p := 0 ;
88092: LD_ADDR_VAR 0 1
88096: PUSH
88097: LD_INT 0
88099: ST_TO_ADDR
// repeat game_speed := 1 ;
88100: LD_ADDR_OWVAR 65
88104: PUSH
88105: LD_INT 1
88107: ST_TO_ADDR
// wait ( 0 0$1 ) ;
88108: LD_INT 35
88110: PPUSH
88111: CALL_OW 67
// p := p + 1 ;
88115: LD_ADDR_VAR 0 1
88119: PUSH
88120: LD_VAR 0 1
88124: PUSH
88125: LD_INT 1
88127: PLUS
88128: ST_TO_ADDR
// until p >= 60 ;
88129: LD_VAR 0 1
88133: PUSH
88134: LD_INT 60
88136: GREATEREQUAL
88137: IFFALSE 88100
// game_speed := 4 ;
88139: LD_ADDR_OWVAR 65
88143: PUSH
88144: LD_INT 4
88146: ST_TO_ADDR
// end ;
88147: PPOPN 1
88149: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
88150: LD_EXP 109
88154: PUSH
88155: LD_EXP 136
88159: AND
88160: IFFALSE 88306
88162: GO 88164
88164: DISABLE
88165: LD_INT 0
88167: PPUSH
88168: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
88169: LD_ADDR_VAR 0 1
88173: PUSH
88174: LD_INT 22
88176: PUSH
88177: LD_OWVAR 2
88181: PUSH
88182: EMPTY
88183: LIST
88184: LIST
88185: PUSH
88186: LD_INT 2
88188: PUSH
88189: LD_INT 30
88191: PUSH
88192: LD_INT 0
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PUSH
88199: LD_INT 30
88201: PUSH
88202: LD_INT 1
88204: PUSH
88205: EMPTY
88206: LIST
88207: LIST
88208: PUSH
88209: EMPTY
88210: LIST
88211: LIST
88212: LIST
88213: PUSH
88214: EMPTY
88215: LIST
88216: LIST
88217: PPUSH
88218: CALL_OW 69
88222: ST_TO_ADDR
// if not depot then
88223: LD_VAR 0 1
88227: NOT
88228: IFFALSE 88232
// exit ;
88230: GO 88306
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
88232: LD_ADDR_VAR 0 2
88236: PUSH
88237: LD_VAR 0 1
88241: PUSH
88242: LD_INT 1
88244: PPUSH
88245: LD_VAR 0 1
88249: PPUSH
88250: CALL_OW 12
88254: ARRAY
88255: PPUSH
88256: CALL_OW 274
88260: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
88261: LD_VAR 0 2
88265: PPUSH
88266: LD_INT 1
88268: PPUSH
88269: LD_INT 0
88271: PPUSH
88272: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
88276: LD_VAR 0 2
88280: PPUSH
88281: LD_INT 2
88283: PPUSH
88284: LD_INT 0
88286: PPUSH
88287: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
88291: LD_VAR 0 2
88295: PPUSH
88296: LD_INT 3
88298: PPUSH
88299: LD_INT 0
88301: PPUSH
88302: CALL_OW 277
// end ;
88306: PPOPN 2
88308: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
88309: LD_EXP 109
88313: PUSH
88314: LD_EXP 137
88318: AND
88319: IFFALSE 88416
88321: GO 88323
88323: DISABLE
88324: LD_INT 0
88326: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
88327: LD_ADDR_VAR 0 1
88331: PUSH
88332: LD_INT 22
88334: PUSH
88335: LD_OWVAR 2
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: PUSH
88344: LD_INT 21
88346: PUSH
88347: LD_INT 1
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 3
88356: PUSH
88357: LD_INT 23
88359: PUSH
88360: LD_INT 0
88362: PUSH
88363: EMPTY
88364: LIST
88365: LIST
88366: PUSH
88367: EMPTY
88368: LIST
88369: LIST
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: LIST
88375: PPUSH
88376: CALL_OW 69
88380: ST_TO_ADDR
// if not tmp then
88381: LD_VAR 0 1
88385: NOT
88386: IFFALSE 88390
// exit ;
88388: GO 88416
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
88390: LD_VAR 0 1
88394: PUSH
88395: LD_INT 1
88397: PPUSH
88398: LD_VAR 0 1
88402: PPUSH
88403: CALL_OW 12
88407: ARRAY
88408: PPUSH
88409: LD_INT 200
88411: PPUSH
88412: CALL_OW 234
// end ;
88416: PPOPN 1
88418: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
88419: LD_EXP 109
88423: PUSH
88424: LD_EXP 138
88428: AND
88429: IFFALSE 88508
88431: GO 88433
88433: DISABLE
88434: LD_INT 0
88436: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
88437: LD_ADDR_VAR 0 1
88441: PUSH
88442: LD_INT 22
88444: PUSH
88445: LD_OWVAR 2
88449: PUSH
88450: EMPTY
88451: LIST
88452: LIST
88453: PUSH
88454: LD_INT 21
88456: PUSH
88457: LD_INT 2
88459: PUSH
88460: EMPTY
88461: LIST
88462: LIST
88463: PUSH
88464: EMPTY
88465: LIST
88466: LIST
88467: PPUSH
88468: CALL_OW 69
88472: ST_TO_ADDR
// if not tmp then
88473: LD_VAR 0 1
88477: NOT
88478: IFFALSE 88482
// exit ;
88480: GO 88508
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
88482: LD_VAR 0 1
88486: PUSH
88487: LD_INT 1
88489: PPUSH
88490: LD_VAR 0 1
88494: PPUSH
88495: CALL_OW 12
88499: ARRAY
88500: PPUSH
88501: LD_INT 60
88503: PPUSH
88504: CALL_OW 234
// end ;
88508: PPOPN 1
88510: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
88511: LD_EXP 109
88515: PUSH
88516: LD_EXP 139
88520: AND
88521: IFFALSE 88620
88523: GO 88525
88525: DISABLE
88526: LD_INT 0
88528: PPUSH
88529: PPUSH
// begin enable ;
88530: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
88531: LD_ADDR_VAR 0 1
88535: PUSH
88536: LD_INT 22
88538: PUSH
88539: LD_OWVAR 2
88543: PUSH
88544: EMPTY
88545: LIST
88546: LIST
88547: PUSH
88548: LD_INT 61
88550: PUSH
88551: EMPTY
88552: LIST
88553: PUSH
88554: LD_INT 33
88556: PUSH
88557: LD_INT 2
88559: PUSH
88560: EMPTY
88561: LIST
88562: LIST
88563: PUSH
88564: EMPTY
88565: LIST
88566: LIST
88567: LIST
88568: PPUSH
88569: CALL_OW 69
88573: ST_TO_ADDR
// if not tmp then
88574: LD_VAR 0 1
88578: NOT
88579: IFFALSE 88583
// exit ;
88581: GO 88620
// for i in tmp do
88583: LD_ADDR_VAR 0 2
88587: PUSH
88588: LD_VAR 0 1
88592: PUSH
88593: FOR_IN
88594: IFFALSE 88618
// if IsControledBy ( i ) then
88596: LD_VAR 0 2
88600: PPUSH
88601: CALL_OW 312
88605: IFFALSE 88616
// ComUnlink ( i ) ;
88607: LD_VAR 0 2
88611: PPUSH
88612: CALL_OW 136
88616: GO 88593
88618: POP
88619: POP
// end ;
88620: PPOPN 2
88622: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
88623: LD_EXP 109
88627: PUSH
88628: LD_EXP 140
88632: AND
88633: IFFALSE 88773
88635: GO 88637
88637: DISABLE
88638: LD_INT 0
88640: PPUSH
88641: PPUSH
// begin ToLua ( displayPowell(); ) ;
88642: LD_STRING displayPowell();
88644: PPUSH
88645: CALL_OW 559
// uc_side := 0 ;
88649: LD_ADDR_OWVAR 20
88653: PUSH
88654: LD_INT 0
88656: ST_TO_ADDR
// uc_nation := 2 ;
88657: LD_ADDR_OWVAR 21
88661: PUSH
88662: LD_INT 2
88664: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
88665: LD_ADDR_OWVAR 37
88669: PUSH
88670: LD_INT 14
88672: ST_TO_ADDR
// vc_engine := engine_siberite ;
88673: LD_ADDR_OWVAR 39
88677: PUSH
88678: LD_INT 3
88680: ST_TO_ADDR
// vc_control := control_apeman ;
88681: LD_ADDR_OWVAR 38
88685: PUSH
88686: LD_INT 5
88688: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
88689: LD_ADDR_OWVAR 40
88693: PUSH
88694: LD_INT 29
88696: ST_TO_ADDR
// un := CreateVehicle ;
88697: LD_ADDR_VAR 0 2
88701: PUSH
88702: CALL_OW 45
88706: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
88707: LD_VAR 0 2
88711: PPUSH
88712: LD_INT 1
88714: PPUSH
88715: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
88719: LD_INT 35
88721: PPUSH
88722: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
88726: LD_VAR 0 2
88730: PPUSH
88731: LD_INT 22
88733: PUSH
88734: LD_OWVAR 2
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PPUSH
88743: CALL_OW 69
88747: PPUSH
88748: LD_VAR 0 2
88752: PPUSH
88753: CALL_OW 74
88757: PPUSH
88758: CALL_OW 115
// until IsDead ( un ) ;
88762: LD_VAR 0 2
88766: PPUSH
88767: CALL_OW 301
88771: IFFALSE 88719
// end ;
88773: PPOPN 2
88775: END
// every 0 0$1 trigger StreamModeActive and sStu do
88776: LD_EXP 109
88780: PUSH
88781: LD_EXP 148
88785: AND
88786: IFFALSE 88802
88788: GO 88790
88790: DISABLE
// begin ToLua ( displayStucuk(); ) ;
88791: LD_STRING displayStucuk();
88793: PPUSH
88794: CALL_OW 559
// ResetFog ;
88798: CALL_OW 335
// end ;
88802: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
88803: LD_EXP 109
88807: PUSH
88808: LD_EXP 141
88812: AND
88813: IFFALSE 88954
88815: GO 88817
88817: DISABLE
88818: LD_INT 0
88820: PPUSH
88821: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
88822: LD_ADDR_VAR 0 2
88826: PUSH
88827: LD_INT 22
88829: PUSH
88830: LD_OWVAR 2
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: PUSH
88839: LD_INT 21
88841: PUSH
88842: LD_INT 1
88844: PUSH
88845: EMPTY
88846: LIST
88847: LIST
88848: PUSH
88849: EMPTY
88850: LIST
88851: LIST
88852: PPUSH
88853: CALL_OW 69
88857: ST_TO_ADDR
// if not tmp then
88858: LD_VAR 0 2
88862: NOT
88863: IFFALSE 88867
// exit ;
88865: GO 88954
// un := tmp [ rand ( 1 , tmp ) ] ;
88867: LD_ADDR_VAR 0 1
88871: PUSH
88872: LD_VAR 0 2
88876: PUSH
88877: LD_INT 1
88879: PPUSH
88880: LD_VAR 0 2
88884: PPUSH
88885: CALL_OW 12
88889: ARRAY
88890: ST_TO_ADDR
// SetSide ( un , 0 ) ;
88891: LD_VAR 0 1
88895: PPUSH
88896: LD_INT 0
88898: PPUSH
88899: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
88903: LD_VAR 0 1
88907: PPUSH
88908: LD_OWVAR 3
88912: PUSH
88913: LD_VAR 0 1
88917: DIFF
88918: PPUSH
88919: LD_VAR 0 1
88923: PPUSH
88924: CALL_OW 74
88928: PPUSH
88929: CALL_OW 115
// wait ( 0 0$20 ) ;
88933: LD_INT 700
88935: PPUSH
88936: CALL_OW 67
// SetSide ( un , your_side ) ;
88940: LD_VAR 0 1
88944: PPUSH
88945: LD_OWVAR 2
88949: PPUSH
88950: CALL_OW 235
// end ;
88954: PPOPN 2
88956: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
88957: LD_EXP 109
88961: PUSH
88962: LD_EXP 142
88966: AND
88967: IFFALSE 89073
88969: GO 88971
88971: DISABLE
88972: LD_INT 0
88974: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
88975: LD_ADDR_VAR 0 1
88979: PUSH
88980: LD_INT 22
88982: PUSH
88983: LD_OWVAR 2
88987: PUSH
88988: EMPTY
88989: LIST
88990: LIST
88991: PUSH
88992: LD_INT 2
88994: PUSH
88995: LD_INT 30
88997: PUSH
88998: LD_INT 0
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: LD_INT 30
89007: PUSH
89008: LD_INT 1
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: LIST
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: PPUSH
89024: CALL_OW 69
89028: ST_TO_ADDR
// if not depot then
89029: LD_VAR 0 1
89033: NOT
89034: IFFALSE 89038
// exit ;
89036: GO 89073
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
89038: LD_VAR 0 1
89042: PUSH
89043: LD_INT 1
89045: ARRAY
89046: PPUSH
89047: CALL_OW 250
89051: PPUSH
89052: LD_VAR 0 1
89056: PUSH
89057: LD_INT 1
89059: ARRAY
89060: PPUSH
89061: CALL_OW 251
89065: PPUSH
89066: LD_INT 70
89068: PPUSH
89069: CALL_OW 495
// end ;
89073: PPOPN 1
89075: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
89076: LD_EXP 109
89080: PUSH
89081: LD_EXP 143
89085: AND
89086: IFFALSE 89297
89088: GO 89090
89090: DISABLE
89091: LD_INT 0
89093: PPUSH
89094: PPUSH
89095: PPUSH
89096: PPUSH
89097: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89098: LD_ADDR_VAR 0 5
89102: PUSH
89103: LD_INT 22
89105: PUSH
89106: LD_OWVAR 2
89110: PUSH
89111: EMPTY
89112: LIST
89113: LIST
89114: PUSH
89115: LD_INT 21
89117: PUSH
89118: LD_INT 1
89120: PUSH
89121: EMPTY
89122: LIST
89123: LIST
89124: PUSH
89125: EMPTY
89126: LIST
89127: LIST
89128: PPUSH
89129: CALL_OW 69
89133: ST_TO_ADDR
// if not tmp then
89134: LD_VAR 0 5
89138: NOT
89139: IFFALSE 89143
// exit ;
89141: GO 89297
// for i in tmp do
89143: LD_ADDR_VAR 0 1
89147: PUSH
89148: LD_VAR 0 5
89152: PUSH
89153: FOR_IN
89154: IFFALSE 89295
// begin d := rand ( 0 , 5 ) ;
89156: LD_ADDR_VAR 0 4
89160: PUSH
89161: LD_INT 0
89163: PPUSH
89164: LD_INT 5
89166: PPUSH
89167: CALL_OW 12
89171: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
89172: LD_ADDR_VAR 0 2
89176: PUSH
89177: LD_VAR 0 1
89181: PPUSH
89182: CALL_OW 250
89186: PPUSH
89187: LD_VAR 0 4
89191: PPUSH
89192: LD_INT 3
89194: PPUSH
89195: LD_INT 12
89197: PPUSH
89198: CALL_OW 12
89202: PPUSH
89203: CALL_OW 272
89207: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
89208: LD_ADDR_VAR 0 3
89212: PUSH
89213: LD_VAR 0 1
89217: PPUSH
89218: CALL_OW 251
89222: PPUSH
89223: LD_VAR 0 4
89227: PPUSH
89228: LD_INT 3
89230: PPUSH
89231: LD_INT 12
89233: PPUSH
89234: CALL_OW 12
89238: PPUSH
89239: CALL_OW 273
89243: ST_TO_ADDR
// if ValidHex ( x , y ) then
89244: LD_VAR 0 2
89248: PPUSH
89249: LD_VAR 0 3
89253: PPUSH
89254: CALL_OW 488
89258: IFFALSE 89293
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
89260: LD_VAR 0 1
89264: PPUSH
89265: LD_VAR 0 2
89269: PPUSH
89270: LD_VAR 0 3
89274: PPUSH
89275: LD_INT 3
89277: PPUSH
89278: LD_INT 6
89280: PPUSH
89281: CALL_OW 12
89285: PPUSH
89286: LD_INT 1
89288: PPUSH
89289: CALL_OW 483
// end ;
89293: GO 89153
89295: POP
89296: POP
// end ;
89297: PPOPN 5
89299: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
89300: LD_EXP 109
89304: PUSH
89305: LD_EXP 144
89309: AND
89310: IFFALSE 89404
89312: GO 89314
89314: DISABLE
89315: LD_INT 0
89317: PPUSH
89318: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
89319: LD_ADDR_VAR 0 2
89323: PUSH
89324: LD_INT 22
89326: PUSH
89327: LD_OWVAR 2
89331: PUSH
89332: EMPTY
89333: LIST
89334: LIST
89335: PUSH
89336: LD_INT 32
89338: PUSH
89339: LD_INT 1
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: LD_INT 21
89348: PUSH
89349: LD_INT 2
89351: PUSH
89352: EMPTY
89353: LIST
89354: LIST
89355: PUSH
89356: EMPTY
89357: LIST
89358: LIST
89359: LIST
89360: PPUSH
89361: CALL_OW 69
89365: ST_TO_ADDR
// if not tmp then
89366: LD_VAR 0 2
89370: NOT
89371: IFFALSE 89375
// exit ;
89373: GO 89404
// for i in tmp do
89375: LD_ADDR_VAR 0 1
89379: PUSH
89380: LD_VAR 0 2
89384: PUSH
89385: FOR_IN
89386: IFFALSE 89402
// SetFuel ( i , 0 ) ;
89388: LD_VAR 0 1
89392: PPUSH
89393: LD_INT 0
89395: PPUSH
89396: CALL_OW 240
89400: GO 89385
89402: POP
89403: POP
// end ;
89404: PPOPN 2
89406: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
89407: LD_EXP 109
89411: PUSH
89412: LD_EXP 145
89416: AND
89417: IFFALSE 89483
89419: GO 89421
89421: DISABLE
89422: LD_INT 0
89424: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
89425: LD_ADDR_VAR 0 1
89429: PUSH
89430: LD_INT 22
89432: PUSH
89433: LD_OWVAR 2
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: PUSH
89442: LD_INT 30
89444: PUSH
89445: LD_INT 29
89447: PUSH
89448: EMPTY
89449: LIST
89450: LIST
89451: PUSH
89452: EMPTY
89453: LIST
89454: LIST
89455: PPUSH
89456: CALL_OW 69
89460: ST_TO_ADDR
// if not tmp then
89461: LD_VAR 0 1
89465: NOT
89466: IFFALSE 89470
// exit ;
89468: GO 89483
// DestroyUnit ( tmp [ 1 ] ) ;
89470: LD_VAR 0 1
89474: PUSH
89475: LD_INT 1
89477: ARRAY
89478: PPUSH
89479: CALL_OW 65
// end ;
89483: PPOPN 1
89485: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
89486: LD_EXP 109
89490: PUSH
89491: LD_EXP 147
89495: AND
89496: IFFALSE 89625
89498: GO 89500
89500: DISABLE
89501: LD_INT 0
89503: PPUSH
// begin uc_side := 0 ;
89504: LD_ADDR_OWVAR 20
89508: PUSH
89509: LD_INT 0
89511: ST_TO_ADDR
// uc_nation := nation_arabian ;
89512: LD_ADDR_OWVAR 21
89516: PUSH
89517: LD_INT 2
89519: ST_TO_ADDR
// hc_gallery :=  ;
89520: LD_ADDR_OWVAR 33
89524: PUSH
89525: LD_STRING 
89527: ST_TO_ADDR
// hc_name :=  ;
89528: LD_ADDR_OWVAR 26
89532: PUSH
89533: LD_STRING 
89535: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
89536: LD_INT 1
89538: PPUSH
89539: LD_INT 11
89541: PPUSH
89542: LD_INT 10
89544: PPUSH
89545: CALL_OW 380
// un := CreateHuman ;
89549: LD_ADDR_VAR 0 1
89553: PUSH
89554: CALL_OW 44
89558: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
89559: LD_VAR 0 1
89563: PPUSH
89564: LD_INT 1
89566: PPUSH
89567: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
89571: LD_INT 35
89573: PPUSH
89574: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
89578: LD_VAR 0 1
89582: PPUSH
89583: LD_INT 22
89585: PUSH
89586: LD_OWVAR 2
89590: PUSH
89591: EMPTY
89592: LIST
89593: LIST
89594: PPUSH
89595: CALL_OW 69
89599: PPUSH
89600: LD_VAR 0 1
89604: PPUSH
89605: CALL_OW 74
89609: PPUSH
89610: CALL_OW 115
// until IsDead ( un ) ;
89614: LD_VAR 0 1
89618: PPUSH
89619: CALL_OW 301
89623: IFFALSE 89571
// end ;
89625: PPOPN 1
89627: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
89628: LD_EXP 109
89632: PUSH
89633: LD_EXP 149
89637: AND
89638: IFFALSE 89650
89640: GO 89642
89642: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
89643: LD_STRING earthquake(getX(game), 0, 32)
89645: PPUSH
89646: CALL_OW 559
89650: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
89651: LD_EXP 109
89655: PUSH
89656: LD_EXP 150
89660: AND
89661: IFFALSE 89752
89663: GO 89665
89665: DISABLE
89666: LD_INT 0
89668: PPUSH
// begin enable ;
89669: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
89670: LD_ADDR_VAR 0 1
89674: PUSH
89675: LD_INT 22
89677: PUSH
89678: LD_OWVAR 2
89682: PUSH
89683: EMPTY
89684: LIST
89685: LIST
89686: PUSH
89687: LD_INT 21
89689: PUSH
89690: LD_INT 2
89692: PUSH
89693: EMPTY
89694: LIST
89695: LIST
89696: PUSH
89697: LD_INT 33
89699: PUSH
89700: LD_INT 3
89702: PUSH
89703: EMPTY
89704: LIST
89705: LIST
89706: PUSH
89707: EMPTY
89708: LIST
89709: LIST
89710: LIST
89711: PPUSH
89712: CALL_OW 69
89716: ST_TO_ADDR
// if not tmp then
89717: LD_VAR 0 1
89721: NOT
89722: IFFALSE 89726
// exit ;
89724: GO 89752
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
89726: LD_VAR 0 1
89730: PUSH
89731: LD_INT 1
89733: PPUSH
89734: LD_VAR 0 1
89738: PPUSH
89739: CALL_OW 12
89743: ARRAY
89744: PPUSH
89745: LD_INT 1
89747: PPUSH
89748: CALL_OW 234
// end ;
89752: PPOPN 1
89754: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
89755: LD_EXP 109
89759: PUSH
89760: LD_EXP 151
89764: AND
89765: IFFALSE 89906
89767: GO 89769
89769: DISABLE
89770: LD_INT 0
89772: PPUSH
89773: PPUSH
89774: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
89775: LD_ADDR_VAR 0 3
89779: PUSH
89780: LD_INT 22
89782: PUSH
89783: LD_OWVAR 2
89787: PUSH
89788: EMPTY
89789: LIST
89790: LIST
89791: PUSH
89792: LD_INT 25
89794: PUSH
89795: LD_INT 1
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: PUSH
89802: EMPTY
89803: LIST
89804: LIST
89805: PPUSH
89806: CALL_OW 69
89810: ST_TO_ADDR
// if not tmp then
89811: LD_VAR 0 3
89815: NOT
89816: IFFALSE 89820
// exit ;
89818: GO 89906
// un := tmp [ rand ( 1 , tmp ) ] ;
89820: LD_ADDR_VAR 0 2
89824: PUSH
89825: LD_VAR 0 3
89829: PUSH
89830: LD_INT 1
89832: PPUSH
89833: LD_VAR 0 3
89837: PPUSH
89838: CALL_OW 12
89842: ARRAY
89843: ST_TO_ADDR
// if Crawls ( un ) then
89844: LD_VAR 0 2
89848: PPUSH
89849: CALL_OW 318
89853: IFFALSE 89864
// ComWalk ( un ) ;
89855: LD_VAR 0 2
89859: PPUSH
89860: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
89864: LD_VAR 0 2
89868: PPUSH
89869: LD_INT 9
89871: PPUSH
89872: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
89876: LD_INT 28
89878: PPUSH
89879: LD_OWVAR 2
89883: PPUSH
89884: LD_INT 2
89886: PPUSH
89887: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
89891: LD_INT 29
89893: PPUSH
89894: LD_OWVAR 2
89898: PPUSH
89899: LD_INT 2
89901: PPUSH
89902: CALL_OW 322
// end ;
89906: PPOPN 3
89908: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
89909: LD_EXP 109
89913: PUSH
89914: LD_EXP 152
89918: AND
89919: IFFALSE 90030
89921: GO 89923
89923: DISABLE
89924: LD_INT 0
89926: PPUSH
89927: PPUSH
89928: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
89929: LD_ADDR_VAR 0 3
89933: PUSH
89934: LD_INT 22
89936: PUSH
89937: LD_OWVAR 2
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: PUSH
89946: LD_INT 25
89948: PUSH
89949: LD_INT 1
89951: PUSH
89952: EMPTY
89953: LIST
89954: LIST
89955: PUSH
89956: EMPTY
89957: LIST
89958: LIST
89959: PPUSH
89960: CALL_OW 69
89964: ST_TO_ADDR
// if not tmp then
89965: LD_VAR 0 3
89969: NOT
89970: IFFALSE 89974
// exit ;
89972: GO 90030
// un := tmp [ rand ( 1 , tmp ) ] ;
89974: LD_ADDR_VAR 0 2
89978: PUSH
89979: LD_VAR 0 3
89983: PUSH
89984: LD_INT 1
89986: PPUSH
89987: LD_VAR 0 3
89991: PPUSH
89992: CALL_OW 12
89996: ARRAY
89997: ST_TO_ADDR
// if Crawls ( un ) then
89998: LD_VAR 0 2
90002: PPUSH
90003: CALL_OW 318
90007: IFFALSE 90018
// ComWalk ( un ) ;
90009: LD_VAR 0 2
90013: PPUSH
90014: CALL_OW 138
// SetClass ( un , class_mortar ) ;
90018: LD_VAR 0 2
90022: PPUSH
90023: LD_INT 8
90025: PPUSH
90026: CALL_OW 336
// end ;
90030: PPOPN 3
90032: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
90033: LD_EXP 109
90037: PUSH
90038: LD_EXP 153
90042: AND
90043: IFFALSE 90187
90045: GO 90047
90047: DISABLE
90048: LD_INT 0
90050: PPUSH
90051: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
90052: LD_ADDR_VAR 0 2
90056: PUSH
90057: LD_INT 22
90059: PUSH
90060: LD_OWVAR 2
90064: PUSH
90065: EMPTY
90066: LIST
90067: LIST
90068: PUSH
90069: LD_INT 21
90071: PUSH
90072: LD_INT 2
90074: PUSH
90075: EMPTY
90076: LIST
90077: LIST
90078: PUSH
90079: LD_INT 2
90081: PUSH
90082: LD_INT 34
90084: PUSH
90085: LD_INT 12
90087: PUSH
90088: EMPTY
90089: LIST
90090: LIST
90091: PUSH
90092: LD_INT 34
90094: PUSH
90095: LD_INT 51
90097: PUSH
90098: EMPTY
90099: LIST
90100: LIST
90101: PUSH
90102: LD_INT 34
90104: PUSH
90105: LD_INT 32
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: PUSH
90112: EMPTY
90113: LIST
90114: LIST
90115: LIST
90116: LIST
90117: PUSH
90118: EMPTY
90119: LIST
90120: LIST
90121: LIST
90122: PPUSH
90123: CALL_OW 69
90127: ST_TO_ADDR
// if not tmp then
90128: LD_VAR 0 2
90132: NOT
90133: IFFALSE 90137
// exit ;
90135: GO 90187
// for i in tmp do
90137: LD_ADDR_VAR 0 1
90141: PUSH
90142: LD_VAR 0 2
90146: PUSH
90147: FOR_IN
90148: IFFALSE 90185
// if GetCargo ( i , mat_artifact ) = 0 then
90150: LD_VAR 0 1
90154: PPUSH
90155: LD_INT 4
90157: PPUSH
90158: CALL_OW 289
90162: PUSH
90163: LD_INT 0
90165: EQUAL
90166: IFFALSE 90183
// SetCargo ( i , mat_siberit , 100 ) ;
90168: LD_VAR 0 1
90172: PPUSH
90173: LD_INT 3
90175: PPUSH
90176: LD_INT 100
90178: PPUSH
90179: CALL_OW 290
90183: GO 90147
90185: POP
90186: POP
// end ;
90187: PPOPN 2
90189: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
90190: LD_EXP 109
90194: PUSH
90195: LD_EXP 154
90199: AND
90200: IFFALSE 90383
90202: GO 90204
90204: DISABLE
90205: LD_INT 0
90207: PPUSH
90208: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
90209: LD_ADDR_VAR 0 2
90213: PUSH
90214: LD_INT 22
90216: PUSH
90217: LD_OWVAR 2
90221: PUSH
90222: EMPTY
90223: LIST
90224: LIST
90225: PPUSH
90226: CALL_OW 69
90230: ST_TO_ADDR
// if not tmp then
90231: LD_VAR 0 2
90235: NOT
90236: IFFALSE 90240
// exit ;
90238: GO 90383
// for i := 1 to 2 do
90240: LD_ADDR_VAR 0 1
90244: PUSH
90245: DOUBLE
90246: LD_INT 1
90248: DEC
90249: ST_TO_ADDR
90250: LD_INT 2
90252: PUSH
90253: FOR_TO
90254: IFFALSE 90381
// begin uc_side := your_side ;
90256: LD_ADDR_OWVAR 20
90260: PUSH
90261: LD_OWVAR 2
90265: ST_TO_ADDR
// uc_nation := nation_american ;
90266: LD_ADDR_OWVAR 21
90270: PUSH
90271: LD_INT 1
90273: ST_TO_ADDR
// vc_chassis := us_morphling ;
90274: LD_ADDR_OWVAR 37
90278: PUSH
90279: LD_INT 5
90281: ST_TO_ADDR
// vc_engine := engine_siberite ;
90282: LD_ADDR_OWVAR 39
90286: PUSH
90287: LD_INT 3
90289: ST_TO_ADDR
// vc_control := control_computer ;
90290: LD_ADDR_OWVAR 38
90294: PUSH
90295: LD_INT 3
90297: ST_TO_ADDR
// vc_weapon := us_double_laser ;
90298: LD_ADDR_OWVAR 40
90302: PUSH
90303: LD_INT 10
90305: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
90306: LD_VAR 0 2
90310: PUSH
90311: LD_INT 1
90313: ARRAY
90314: PPUSH
90315: CALL_OW 310
90319: NOT
90320: IFFALSE 90367
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
90322: CALL_OW 45
90326: PPUSH
90327: LD_VAR 0 2
90331: PUSH
90332: LD_INT 1
90334: ARRAY
90335: PPUSH
90336: CALL_OW 250
90340: PPUSH
90341: LD_VAR 0 2
90345: PUSH
90346: LD_INT 1
90348: ARRAY
90349: PPUSH
90350: CALL_OW 251
90354: PPUSH
90355: LD_INT 12
90357: PPUSH
90358: LD_INT 1
90360: PPUSH
90361: CALL_OW 50
90365: GO 90379
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
90367: CALL_OW 45
90371: PPUSH
90372: LD_INT 1
90374: PPUSH
90375: CALL_OW 51
// end ;
90379: GO 90253
90381: POP
90382: POP
// end ;
90383: PPOPN 2
90385: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
90386: LD_EXP 109
90390: PUSH
90391: LD_EXP 155
90395: AND
90396: IFFALSE 90618
90398: GO 90400
90400: DISABLE
90401: LD_INT 0
90403: PPUSH
90404: PPUSH
90405: PPUSH
90406: PPUSH
90407: PPUSH
90408: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
90409: LD_ADDR_VAR 0 6
90413: PUSH
90414: LD_INT 22
90416: PUSH
90417: LD_OWVAR 2
90421: PUSH
90422: EMPTY
90423: LIST
90424: LIST
90425: PUSH
90426: LD_INT 21
90428: PUSH
90429: LD_INT 1
90431: PUSH
90432: EMPTY
90433: LIST
90434: LIST
90435: PUSH
90436: LD_INT 3
90438: PUSH
90439: LD_INT 23
90441: PUSH
90442: LD_INT 0
90444: PUSH
90445: EMPTY
90446: LIST
90447: LIST
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: PUSH
90453: EMPTY
90454: LIST
90455: LIST
90456: LIST
90457: PPUSH
90458: CALL_OW 69
90462: ST_TO_ADDR
// if not tmp then
90463: LD_VAR 0 6
90467: NOT
90468: IFFALSE 90472
// exit ;
90470: GO 90618
// s1 := rand ( 1 , 4 ) ;
90472: LD_ADDR_VAR 0 2
90476: PUSH
90477: LD_INT 1
90479: PPUSH
90480: LD_INT 4
90482: PPUSH
90483: CALL_OW 12
90487: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
90488: LD_ADDR_VAR 0 4
90492: PUSH
90493: LD_VAR 0 6
90497: PUSH
90498: LD_INT 1
90500: ARRAY
90501: PPUSH
90502: LD_VAR 0 2
90506: PPUSH
90507: CALL_OW 259
90511: ST_TO_ADDR
// if s1 = 1 then
90512: LD_VAR 0 2
90516: PUSH
90517: LD_INT 1
90519: EQUAL
90520: IFFALSE 90540
// s2 := rand ( 2 , 4 ) else
90522: LD_ADDR_VAR 0 3
90526: PUSH
90527: LD_INT 2
90529: PPUSH
90530: LD_INT 4
90532: PPUSH
90533: CALL_OW 12
90537: ST_TO_ADDR
90538: GO 90548
// s2 := 1 ;
90540: LD_ADDR_VAR 0 3
90544: PUSH
90545: LD_INT 1
90547: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
90548: LD_ADDR_VAR 0 5
90552: PUSH
90553: LD_VAR 0 6
90557: PUSH
90558: LD_INT 1
90560: ARRAY
90561: PPUSH
90562: LD_VAR 0 3
90566: PPUSH
90567: CALL_OW 259
90571: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
90572: LD_VAR 0 6
90576: PUSH
90577: LD_INT 1
90579: ARRAY
90580: PPUSH
90581: LD_VAR 0 2
90585: PPUSH
90586: LD_VAR 0 5
90590: PPUSH
90591: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
90595: LD_VAR 0 6
90599: PUSH
90600: LD_INT 1
90602: ARRAY
90603: PPUSH
90604: LD_VAR 0 3
90608: PPUSH
90609: LD_VAR 0 4
90613: PPUSH
90614: CALL_OW 237
// end ;
90618: PPOPN 6
90620: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
90621: LD_EXP 109
90625: PUSH
90626: LD_EXP 156
90630: AND
90631: IFFALSE 90710
90633: GO 90635
90635: DISABLE
90636: LD_INT 0
90638: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
90639: LD_ADDR_VAR 0 1
90643: PUSH
90644: LD_INT 22
90646: PUSH
90647: LD_OWVAR 2
90651: PUSH
90652: EMPTY
90653: LIST
90654: LIST
90655: PUSH
90656: LD_INT 30
90658: PUSH
90659: LD_INT 3
90661: PUSH
90662: EMPTY
90663: LIST
90664: LIST
90665: PUSH
90666: EMPTY
90667: LIST
90668: LIST
90669: PPUSH
90670: CALL_OW 69
90674: ST_TO_ADDR
// if not tmp then
90675: LD_VAR 0 1
90679: NOT
90680: IFFALSE 90684
// exit ;
90682: GO 90710
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
90684: LD_VAR 0 1
90688: PUSH
90689: LD_INT 1
90691: PPUSH
90692: LD_VAR 0 1
90696: PPUSH
90697: CALL_OW 12
90701: ARRAY
90702: PPUSH
90703: LD_INT 1
90705: PPUSH
90706: CALL_OW 234
// end ;
90710: PPOPN 1
90712: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
90713: LD_EXP 109
90717: PUSH
90718: LD_EXP 157
90722: AND
90723: IFFALSE 90835
90725: GO 90727
90727: DISABLE
90728: LD_INT 0
90730: PPUSH
90731: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
90732: LD_ADDR_VAR 0 2
90736: PUSH
90737: LD_INT 22
90739: PUSH
90740: LD_OWVAR 2
90744: PUSH
90745: EMPTY
90746: LIST
90747: LIST
90748: PUSH
90749: LD_INT 2
90751: PUSH
90752: LD_INT 30
90754: PUSH
90755: LD_INT 27
90757: PUSH
90758: EMPTY
90759: LIST
90760: LIST
90761: PUSH
90762: LD_INT 30
90764: PUSH
90765: LD_INT 26
90767: PUSH
90768: EMPTY
90769: LIST
90770: LIST
90771: PUSH
90772: LD_INT 30
90774: PUSH
90775: LD_INT 28
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: PUSH
90782: EMPTY
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PPUSH
90792: CALL_OW 69
90796: ST_TO_ADDR
// if not tmp then
90797: LD_VAR 0 2
90801: NOT
90802: IFFALSE 90806
// exit ;
90804: GO 90835
// for i in tmp do
90806: LD_ADDR_VAR 0 1
90810: PUSH
90811: LD_VAR 0 2
90815: PUSH
90816: FOR_IN
90817: IFFALSE 90833
// SetLives ( i , 1 ) ;
90819: LD_VAR 0 1
90823: PPUSH
90824: LD_INT 1
90826: PPUSH
90827: CALL_OW 234
90831: GO 90816
90833: POP
90834: POP
// end ;
90835: PPOPN 2
90837: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
90838: LD_EXP 109
90842: PUSH
90843: LD_EXP 158
90847: AND
90848: IFFALSE 91122
90850: GO 90852
90852: DISABLE
90853: LD_INT 0
90855: PPUSH
90856: PPUSH
90857: PPUSH
// begin i := rand ( 1 , 7 ) ;
90858: LD_ADDR_VAR 0 1
90862: PUSH
90863: LD_INT 1
90865: PPUSH
90866: LD_INT 7
90868: PPUSH
90869: CALL_OW 12
90873: ST_TO_ADDR
// case i of 1 :
90874: LD_VAR 0 1
90878: PUSH
90879: LD_INT 1
90881: DOUBLE
90882: EQUAL
90883: IFTRUE 90887
90885: GO 90897
90887: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
90888: LD_STRING earthquake(getX(game), 0, 32)
90890: PPUSH
90891: CALL_OW 559
90895: GO 91122
90897: LD_INT 2
90899: DOUBLE
90900: EQUAL
90901: IFTRUE 90905
90903: GO 90919
90905: POP
// begin ToLua ( displayStucuk(); ) ;
90906: LD_STRING displayStucuk();
90908: PPUSH
90909: CALL_OW 559
// ResetFog ;
90913: CALL_OW 335
// end ; 3 :
90917: GO 91122
90919: LD_INT 3
90921: DOUBLE
90922: EQUAL
90923: IFTRUE 90927
90925: GO 91031
90927: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90928: LD_ADDR_VAR 0 2
90932: PUSH
90933: LD_INT 22
90935: PUSH
90936: LD_OWVAR 2
90940: PUSH
90941: EMPTY
90942: LIST
90943: LIST
90944: PUSH
90945: LD_INT 25
90947: PUSH
90948: LD_INT 1
90950: PUSH
90951: EMPTY
90952: LIST
90953: LIST
90954: PUSH
90955: EMPTY
90956: LIST
90957: LIST
90958: PPUSH
90959: CALL_OW 69
90963: ST_TO_ADDR
// if not tmp then
90964: LD_VAR 0 2
90968: NOT
90969: IFFALSE 90973
// exit ;
90971: GO 91122
// un := tmp [ rand ( 1 , tmp ) ] ;
90973: LD_ADDR_VAR 0 3
90977: PUSH
90978: LD_VAR 0 2
90982: PUSH
90983: LD_INT 1
90985: PPUSH
90986: LD_VAR 0 2
90990: PPUSH
90991: CALL_OW 12
90995: ARRAY
90996: ST_TO_ADDR
// if Crawls ( un ) then
90997: LD_VAR 0 3
91001: PPUSH
91002: CALL_OW 318
91006: IFFALSE 91017
// ComWalk ( un ) ;
91008: LD_VAR 0 3
91012: PPUSH
91013: CALL_OW 138
// SetClass ( un , class_mortar ) ;
91017: LD_VAR 0 3
91021: PPUSH
91022: LD_INT 8
91024: PPUSH
91025: CALL_OW 336
// end ; 4 :
91029: GO 91122
91031: LD_INT 4
91033: DOUBLE
91034: EQUAL
91035: IFTRUE 91039
91037: GO 91100
91039: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
91040: LD_ADDR_VAR 0 2
91044: PUSH
91045: LD_INT 22
91047: PUSH
91048: LD_OWVAR 2
91052: PUSH
91053: EMPTY
91054: LIST
91055: LIST
91056: PUSH
91057: LD_INT 30
91059: PUSH
91060: LD_INT 29
91062: PUSH
91063: EMPTY
91064: LIST
91065: LIST
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: PPUSH
91071: CALL_OW 69
91075: ST_TO_ADDR
// if not tmp then
91076: LD_VAR 0 2
91080: NOT
91081: IFFALSE 91085
// exit ;
91083: GO 91122
// DestroyUnit ( tmp [ 1 ] ) ;
91085: LD_VAR 0 2
91089: PUSH
91090: LD_INT 1
91092: ARRAY
91093: PPUSH
91094: CALL_OW 65
// end ; 5 .. 7 :
91098: GO 91122
91100: LD_INT 5
91102: DOUBLE
91103: GREATEREQUAL
91104: IFFALSE 91112
91106: LD_INT 7
91108: DOUBLE
91109: LESSEQUAL
91110: IFTRUE 91114
91112: GO 91121
91114: POP
// StreamSibBomb ; end ;
91115: CALL 87372 0 0
91119: GO 91122
91121: POP
// end ;
91122: PPOPN 3
91124: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
91125: LD_EXP 109
91129: PUSH
91130: LD_EXP 159
91134: AND
91135: IFFALSE 91291
91137: GO 91139
91139: DISABLE
91140: LD_INT 0
91142: PPUSH
91143: PPUSH
91144: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
91145: LD_ADDR_VAR 0 2
91149: PUSH
91150: LD_INT 81
91152: PUSH
91153: LD_OWVAR 2
91157: PUSH
91158: EMPTY
91159: LIST
91160: LIST
91161: PUSH
91162: LD_INT 2
91164: PUSH
91165: LD_INT 21
91167: PUSH
91168: LD_INT 1
91170: PUSH
91171: EMPTY
91172: LIST
91173: LIST
91174: PUSH
91175: LD_INT 21
91177: PUSH
91178: LD_INT 2
91180: PUSH
91181: EMPTY
91182: LIST
91183: LIST
91184: PUSH
91185: EMPTY
91186: LIST
91187: LIST
91188: LIST
91189: PUSH
91190: EMPTY
91191: LIST
91192: LIST
91193: PPUSH
91194: CALL_OW 69
91198: ST_TO_ADDR
// if not tmp then
91199: LD_VAR 0 2
91203: NOT
91204: IFFALSE 91208
// exit ;
91206: GO 91291
// p := 0 ;
91208: LD_ADDR_VAR 0 3
91212: PUSH
91213: LD_INT 0
91215: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
91216: LD_INT 35
91218: PPUSH
91219: CALL_OW 67
// p := p + 1 ;
91223: LD_ADDR_VAR 0 3
91227: PUSH
91228: LD_VAR 0 3
91232: PUSH
91233: LD_INT 1
91235: PLUS
91236: ST_TO_ADDR
// for i in tmp do
91237: LD_ADDR_VAR 0 1
91241: PUSH
91242: LD_VAR 0 2
91246: PUSH
91247: FOR_IN
91248: IFFALSE 91279
// if GetLives ( i ) < 1000 then
91250: LD_VAR 0 1
91254: PPUSH
91255: CALL_OW 256
91259: PUSH
91260: LD_INT 1000
91262: LESS
91263: IFFALSE 91277
// SetLives ( i , 1000 ) ;
91265: LD_VAR 0 1
91269: PPUSH
91270: LD_INT 1000
91272: PPUSH
91273: CALL_OW 234
91277: GO 91247
91279: POP
91280: POP
// until p > 20 ;
91281: LD_VAR 0 3
91285: PUSH
91286: LD_INT 20
91288: GREATER
91289: IFFALSE 91216
// end ;
91291: PPOPN 3
91293: END
// every 0 0$1 trigger StreamModeActive and sTime do
91294: LD_EXP 109
91298: PUSH
91299: LD_EXP 160
91303: AND
91304: IFFALSE 91339
91306: GO 91308
91308: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
91309: LD_INT 28
91311: PPUSH
91312: LD_OWVAR 2
91316: PPUSH
91317: LD_INT 2
91319: PPUSH
91320: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
91324: LD_INT 30
91326: PPUSH
91327: LD_OWVAR 2
91331: PPUSH
91332: LD_INT 2
91334: PPUSH
91335: CALL_OW 322
// end ;
91339: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
91340: LD_EXP 109
91344: PUSH
91345: LD_EXP 161
91349: AND
91350: IFFALSE 91471
91352: GO 91354
91354: DISABLE
91355: LD_INT 0
91357: PPUSH
91358: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91359: LD_ADDR_VAR 0 2
91363: PUSH
91364: LD_INT 22
91366: PUSH
91367: LD_OWVAR 2
91371: PUSH
91372: EMPTY
91373: LIST
91374: LIST
91375: PUSH
91376: LD_INT 21
91378: PUSH
91379: LD_INT 1
91381: PUSH
91382: EMPTY
91383: LIST
91384: LIST
91385: PUSH
91386: LD_INT 3
91388: PUSH
91389: LD_INT 23
91391: PUSH
91392: LD_INT 0
91394: PUSH
91395: EMPTY
91396: LIST
91397: LIST
91398: PUSH
91399: EMPTY
91400: LIST
91401: LIST
91402: PUSH
91403: EMPTY
91404: LIST
91405: LIST
91406: LIST
91407: PPUSH
91408: CALL_OW 69
91412: ST_TO_ADDR
// if not tmp then
91413: LD_VAR 0 2
91417: NOT
91418: IFFALSE 91422
// exit ;
91420: GO 91471
// for i in tmp do
91422: LD_ADDR_VAR 0 1
91426: PUSH
91427: LD_VAR 0 2
91431: PUSH
91432: FOR_IN
91433: IFFALSE 91469
// begin if Crawls ( i ) then
91435: LD_VAR 0 1
91439: PPUSH
91440: CALL_OW 318
91444: IFFALSE 91455
// ComWalk ( i ) ;
91446: LD_VAR 0 1
91450: PPUSH
91451: CALL_OW 138
// SetClass ( i , 2 ) ;
91455: LD_VAR 0 1
91459: PPUSH
91460: LD_INT 2
91462: PPUSH
91463: CALL_OW 336
// end ;
91467: GO 91432
91469: POP
91470: POP
// end ;
91471: PPOPN 2
91473: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
91474: LD_EXP 109
91478: PUSH
91479: LD_EXP 162
91483: AND
91484: IFFALSE 91765
91486: GO 91488
91488: DISABLE
91489: LD_INT 0
91491: PPUSH
91492: PPUSH
91493: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
91494: LD_OWVAR 2
91498: PPUSH
91499: LD_INT 9
91501: PPUSH
91502: LD_INT 1
91504: PPUSH
91505: LD_INT 1
91507: PPUSH
91508: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
91512: LD_INT 9
91514: PPUSH
91515: LD_OWVAR 2
91519: PPUSH
91520: CALL_OW 343
// uc_side := 9 ;
91524: LD_ADDR_OWVAR 20
91528: PUSH
91529: LD_INT 9
91531: ST_TO_ADDR
// uc_nation := 2 ;
91532: LD_ADDR_OWVAR 21
91536: PUSH
91537: LD_INT 2
91539: ST_TO_ADDR
// hc_name := Dark Warrior ;
91540: LD_ADDR_OWVAR 26
91544: PUSH
91545: LD_STRING Dark Warrior
91547: ST_TO_ADDR
// hc_gallery :=  ;
91548: LD_ADDR_OWVAR 33
91552: PUSH
91553: LD_STRING 
91555: ST_TO_ADDR
// hc_noskilllimit := true ;
91556: LD_ADDR_OWVAR 76
91560: PUSH
91561: LD_INT 1
91563: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
91564: LD_ADDR_OWVAR 31
91568: PUSH
91569: LD_INT 30
91571: PUSH
91572: LD_INT 30
91574: PUSH
91575: LD_INT 30
91577: PUSH
91578: LD_INT 30
91580: PUSH
91581: EMPTY
91582: LIST
91583: LIST
91584: LIST
91585: LIST
91586: ST_TO_ADDR
// un := CreateHuman ;
91587: LD_ADDR_VAR 0 3
91591: PUSH
91592: CALL_OW 44
91596: ST_TO_ADDR
// hc_noskilllimit := false ;
91597: LD_ADDR_OWVAR 76
91601: PUSH
91602: LD_INT 0
91604: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91605: LD_VAR 0 3
91609: PPUSH
91610: LD_INT 1
91612: PPUSH
91613: CALL_OW 51
// p := 0 ;
91617: LD_ADDR_VAR 0 2
91621: PUSH
91622: LD_INT 0
91624: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
91625: LD_INT 35
91627: PPUSH
91628: CALL_OW 67
// p := p + 1 ;
91632: LD_ADDR_VAR 0 2
91636: PUSH
91637: LD_VAR 0 2
91641: PUSH
91642: LD_INT 1
91644: PLUS
91645: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
91646: LD_VAR 0 3
91650: PPUSH
91651: CALL_OW 256
91655: PUSH
91656: LD_INT 1000
91658: LESS
91659: IFFALSE 91673
// SetLives ( un , 1000 ) ;
91661: LD_VAR 0 3
91665: PPUSH
91666: LD_INT 1000
91668: PPUSH
91669: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
91673: LD_VAR 0 3
91677: PPUSH
91678: LD_INT 81
91680: PUSH
91681: LD_OWVAR 2
91685: PUSH
91686: EMPTY
91687: LIST
91688: LIST
91689: PUSH
91690: LD_INT 91
91692: PUSH
91693: LD_VAR 0 3
91697: PUSH
91698: LD_INT 30
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: LIST
91705: PUSH
91706: EMPTY
91707: LIST
91708: LIST
91709: PPUSH
91710: CALL_OW 69
91714: PPUSH
91715: LD_VAR 0 3
91719: PPUSH
91720: CALL_OW 74
91724: PPUSH
91725: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
91729: LD_VAR 0 2
91733: PUSH
91734: LD_INT 60
91736: GREATER
91737: PUSH
91738: LD_VAR 0 3
91742: PPUSH
91743: CALL_OW 301
91747: OR
91748: IFFALSE 91625
// if un then
91750: LD_VAR 0 3
91754: IFFALSE 91765
// RemoveUnit ( un ) ;
91756: LD_VAR 0 3
91760: PPUSH
91761: CALL_OW 64
// end ;
91765: PPOPN 3
91767: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91768: LD_INT 0
91770: PPUSH
// case cmd of 301 :
91771: LD_VAR 0 1
91775: PUSH
91776: LD_INT 301
91778: DOUBLE
91779: EQUAL
91780: IFTRUE 91784
91782: GO 91816
91784: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
91785: LD_VAR 0 6
91789: PPUSH
91790: LD_VAR 0 7
91794: PPUSH
91795: LD_VAR 0 8
91799: PPUSH
91800: LD_VAR 0 4
91804: PPUSH
91805: LD_VAR 0 5
91809: PPUSH
91810: CALL 93017 0 5
91814: GO 91937
91816: LD_INT 302
91818: DOUBLE
91819: EQUAL
91820: IFTRUE 91824
91822: GO 91861
91824: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
91825: LD_VAR 0 6
91829: PPUSH
91830: LD_VAR 0 7
91834: PPUSH
91835: LD_VAR 0 8
91839: PPUSH
91840: LD_VAR 0 9
91844: PPUSH
91845: LD_VAR 0 4
91849: PPUSH
91850: LD_VAR 0 5
91854: PPUSH
91855: CALL 93108 0 6
91859: GO 91937
91861: LD_INT 303
91863: DOUBLE
91864: EQUAL
91865: IFTRUE 91869
91867: GO 91906
91869: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
91870: LD_VAR 0 6
91874: PPUSH
91875: LD_VAR 0 7
91879: PPUSH
91880: LD_VAR 0 8
91884: PPUSH
91885: LD_VAR 0 9
91889: PPUSH
91890: LD_VAR 0 4
91894: PPUSH
91895: LD_VAR 0 5
91899: PPUSH
91900: CALL 91942 0 6
91904: GO 91937
91906: LD_INT 304
91908: DOUBLE
91909: EQUAL
91910: IFTRUE 91914
91912: GO 91936
91914: POP
// hHackTeleport ( unit , x , y ) ; end ;
91915: LD_VAR 0 2
91919: PPUSH
91920: LD_VAR 0 4
91924: PPUSH
91925: LD_VAR 0 5
91929: PPUSH
91930: CALL 93701 0 3
91934: GO 91937
91936: POP
// end ;
91937: LD_VAR 0 12
91941: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
91942: LD_INT 0
91944: PPUSH
91945: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
91946: LD_VAR 0 1
91950: PUSH
91951: LD_INT 1
91953: LESS
91954: PUSH
91955: LD_VAR 0 1
91959: PUSH
91960: LD_INT 3
91962: GREATER
91963: OR
91964: PUSH
91965: LD_VAR 0 5
91969: PPUSH
91970: LD_VAR 0 6
91974: PPUSH
91975: CALL_OW 428
91979: OR
91980: IFFALSE 91984
// exit ;
91982: GO 92704
// uc_side := your_side ;
91984: LD_ADDR_OWVAR 20
91988: PUSH
91989: LD_OWVAR 2
91993: ST_TO_ADDR
// uc_nation := nation ;
91994: LD_ADDR_OWVAR 21
91998: PUSH
91999: LD_VAR 0 1
92003: ST_TO_ADDR
// bc_level = 1 ;
92004: LD_ADDR_OWVAR 43
92008: PUSH
92009: LD_INT 1
92011: ST_TO_ADDR
// case btype of 1 :
92012: LD_VAR 0 2
92016: PUSH
92017: LD_INT 1
92019: DOUBLE
92020: EQUAL
92021: IFTRUE 92025
92023: GO 92036
92025: POP
// bc_type := b_depot ; 2 :
92026: LD_ADDR_OWVAR 42
92030: PUSH
92031: LD_INT 0
92033: ST_TO_ADDR
92034: GO 92648
92036: LD_INT 2
92038: DOUBLE
92039: EQUAL
92040: IFTRUE 92044
92042: GO 92055
92044: POP
// bc_type := b_warehouse ; 3 :
92045: LD_ADDR_OWVAR 42
92049: PUSH
92050: LD_INT 1
92052: ST_TO_ADDR
92053: GO 92648
92055: LD_INT 3
92057: DOUBLE
92058: EQUAL
92059: IFTRUE 92063
92061: GO 92074
92063: POP
// bc_type := b_lab ; 4 .. 9 :
92064: LD_ADDR_OWVAR 42
92068: PUSH
92069: LD_INT 6
92071: ST_TO_ADDR
92072: GO 92648
92074: LD_INT 4
92076: DOUBLE
92077: GREATEREQUAL
92078: IFFALSE 92086
92080: LD_INT 9
92082: DOUBLE
92083: LESSEQUAL
92084: IFTRUE 92088
92086: GO 92140
92088: POP
// begin bc_type := b_lab_half ;
92089: LD_ADDR_OWVAR 42
92093: PUSH
92094: LD_INT 7
92096: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
92097: LD_ADDR_OWVAR 44
92101: PUSH
92102: LD_INT 10
92104: PUSH
92105: LD_INT 11
92107: PUSH
92108: LD_INT 12
92110: PUSH
92111: LD_INT 15
92113: PUSH
92114: LD_INT 14
92116: PUSH
92117: LD_INT 13
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: LIST
92124: LIST
92125: LIST
92126: LIST
92127: PUSH
92128: LD_VAR 0 2
92132: PUSH
92133: LD_INT 3
92135: MINUS
92136: ARRAY
92137: ST_TO_ADDR
// end ; 10 .. 13 :
92138: GO 92648
92140: LD_INT 10
92142: DOUBLE
92143: GREATEREQUAL
92144: IFFALSE 92152
92146: LD_INT 13
92148: DOUBLE
92149: LESSEQUAL
92150: IFTRUE 92154
92152: GO 92231
92154: POP
// begin bc_type := b_lab_full ;
92155: LD_ADDR_OWVAR 42
92159: PUSH
92160: LD_INT 8
92162: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
92163: LD_ADDR_OWVAR 44
92167: PUSH
92168: LD_INT 10
92170: PUSH
92171: LD_INT 12
92173: PUSH
92174: LD_INT 14
92176: PUSH
92177: LD_INT 13
92179: PUSH
92180: EMPTY
92181: LIST
92182: LIST
92183: LIST
92184: LIST
92185: PUSH
92186: LD_VAR 0 2
92190: PUSH
92191: LD_INT 9
92193: MINUS
92194: ARRAY
92195: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
92196: LD_ADDR_OWVAR 45
92200: PUSH
92201: LD_INT 11
92203: PUSH
92204: LD_INT 15
92206: PUSH
92207: LD_INT 12
92209: PUSH
92210: LD_INT 15
92212: PUSH
92213: EMPTY
92214: LIST
92215: LIST
92216: LIST
92217: LIST
92218: PUSH
92219: LD_VAR 0 2
92223: PUSH
92224: LD_INT 9
92226: MINUS
92227: ARRAY
92228: ST_TO_ADDR
// end ; 14 :
92229: GO 92648
92231: LD_INT 14
92233: DOUBLE
92234: EQUAL
92235: IFTRUE 92239
92237: GO 92250
92239: POP
// bc_type := b_workshop ; 15 :
92240: LD_ADDR_OWVAR 42
92244: PUSH
92245: LD_INT 2
92247: ST_TO_ADDR
92248: GO 92648
92250: LD_INT 15
92252: DOUBLE
92253: EQUAL
92254: IFTRUE 92258
92256: GO 92269
92258: POP
// bc_type := b_factory ; 16 :
92259: LD_ADDR_OWVAR 42
92263: PUSH
92264: LD_INT 3
92266: ST_TO_ADDR
92267: GO 92648
92269: LD_INT 16
92271: DOUBLE
92272: EQUAL
92273: IFTRUE 92277
92275: GO 92288
92277: POP
// bc_type := b_ext_gun ; 17 :
92278: LD_ADDR_OWVAR 42
92282: PUSH
92283: LD_INT 17
92285: ST_TO_ADDR
92286: GO 92648
92288: LD_INT 17
92290: DOUBLE
92291: EQUAL
92292: IFTRUE 92296
92294: GO 92324
92296: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
92297: LD_ADDR_OWVAR 42
92301: PUSH
92302: LD_INT 19
92304: PUSH
92305: LD_INT 23
92307: PUSH
92308: LD_INT 19
92310: PUSH
92311: EMPTY
92312: LIST
92313: LIST
92314: LIST
92315: PUSH
92316: LD_VAR 0 1
92320: ARRAY
92321: ST_TO_ADDR
92322: GO 92648
92324: LD_INT 18
92326: DOUBLE
92327: EQUAL
92328: IFTRUE 92332
92330: GO 92343
92332: POP
// bc_type := b_ext_radar ; 19 :
92333: LD_ADDR_OWVAR 42
92337: PUSH
92338: LD_INT 20
92340: ST_TO_ADDR
92341: GO 92648
92343: LD_INT 19
92345: DOUBLE
92346: EQUAL
92347: IFTRUE 92351
92349: GO 92362
92351: POP
// bc_type := b_ext_radio ; 20 :
92352: LD_ADDR_OWVAR 42
92356: PUSH
92357: LD_INT 22
92359: ST_TO_ADDR
92360: GO 92648
92362: LD_INT 20
92364: DOUBLE
92365: EQUAL
92366: IFTRUE 92370
92368: GO 92381
92370: POP
// bc_type := b_ext_siberium ; 21 :
92371: LD_ADDR_OWVAR 42
92375: PUSH
92376: LD_INT 21
92378: ST_TO_ADDR
92379: GO 92648
92381: LD_INT 21
92383: DOUBLE
92384: EQUAL
92385: IFTRUE 92389
92387: GO 92400
92389: POP
// bc_type := b_ext_computer ; 22 :
92390: LD_ADDR_OWVAR 42
92394: PUSH
92395: LD_INT 24
92397: ST_TO_ADDR
92398: GO 92648
92400: LD_INT 22
92402: DOUBLE
92403: EQUAL
92404: IFTRUE 92408
92406: GO 92419
92408: POP
// bc_type := b_ext_track ; 23 :
92409: LD_ADDR_OWVAR 42
92413: PUSH
92414: LD_INT 16
92416: ST_TO_ADDR
92417: GO 92648
92419: LD_INT 23
92421: DOUBLE
92422: EQUAL
92423: IFTRUE 92427
92425: GO 92438
92427: POP
// bc_type := b_ext_laser ; 24 :
92428: LD_ADDR_OWVAR 42
92432: PUSH
92433: LD_INT 25
92435: ST_TO_ADDR
92436: GO 92648
92438: LD_INT 24
92440: DOUBLE
92441: EQUAL
92442: IFTRUE 92446
92444: GO 92457
92446: POP
// bc_type := b_control_tower ; 25 :
92447: LD_ADDR_OWVAR 42
92451: PUSH
92452: LD_INT 36
92454: ST_TO_ADDR
92455: GO 92648
92457: LD_INT 25
92459: DOUBLE
92460: EQUAL
92461: IFTRUE 92465
92463: GO 92476
92465: POP
// bc_type := b_breastwork ; 26 :
92466: LD_ADDR_OWVAR 42
92470: PUSH
92471: LD_INT 31
92473: ST_TO_ADDR
92474: GO 92648
92476: LD_INT 26
92478: DOUBLE
92479: EQUAL
92480: IFTRUE 92484
92482: GO 92495
92484: POP
// bc_type := b_bunker ; 27 :
92485: LD_ADDR_OWVAR 42
92489: PUSH
92490: LD_INT 32
92492: ST_TO_ADDR
92493: GO 92648
92495: LD_INT 27
92497: DOUBLE
92498: EQUAL
92499: IFTRUE 92503
92501: GO 92514
92503: POP
// bc_type := b_turret ; 28 :
92504: LD_ADDR_OWVAR 42
92508: PUSH
92509: LD_INT 33
92511: ST_TO_ADDR
92512: GO 92648
92514: LD_INT 28
92516: DOUBLE
92517: EQUAL
92518: IFTRUE 92522
92520: GO 92533
92522: POP
// bc_type := b_armoury ; 29 :
92523: LD_ADDR_OWVAR 42
92527: PUSH
92528: LD_INT 4
92530: ST_TO_ADDR
92531: GO 92648
92533: LD_INT 29
92535: DOUBLE
92536: EQUAL
92537: IFTRUE 92541
92539: GO 92552
92541: POP
// bc_type := b_barracks ; 30 :
92542: LD_ADDR_OWVAR 42
92546: PUSH
92547: LD_INT 5
92549: ST_TO_ADDR
92550: GO 92648
92552: LD_INT 30
92554: DOUBLE
92555: EQUAL
92556: IFTRUE 92560
92558: GO 92571
92560: POP
// bc_type := b_solar_power ; 31 :
92561: LD_ADDR_OWVAR 42
92565: PUSH
92566: LD_INT 27
92568: ST_TO_ADDR
92569: GO 92648
92571: LD_INT 31
92573: DOUBLE
92574: EQUAL
92575: IFTRUE 92579
92577: GO 92590
92579: POP
// bc_type := b_oil_power ; 32 :
92580: LD_ADDR_OWVAR 42
92584: PUSH
92585: LD_INT 26
92587: ST_TO_ADDR
92588: GO 92648
92590: LD_INT 32
92592: DOUBLE
92593: EQUAL
92594: IFTRUE 92598
92596: GO 92609
92598: POP
// bc_type := b_siberite_power ; 33 :
92599: LD_ADDR_OWVAR 42
92603: PUSH
92604: LD_INT 28
92606: ST_TO_ADDR
92607: GO 92648
92609: LD_INT 33
92611: DOUBLE
92612: EQUAL
92613: IFTRUE 92617
92615: GO 92628
92617: POP
// bc_type := b_oil_mine ; 34 :
92618: LD_ADDR_OWVAR 42
92622: PUSH
92623: LD_INT 29
92625: ST_TO_ADDR
92626: GO 92648
92628: LD_INT 34
92630: DOUBLE
92631: EQUAL
92632: IFTRUE 92636
92634: GO 92647
92636: POP
// bc_type := b_siberite_mine ; end ;
92637: LD_ADDR_OWVAR 42
92641: PUSH
92642: LD_INT 30
92644: ST_TO_ADDR
92645: GO 92648
92647: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
92648: LD_ADDR_VAR 0 8
92652: PUSH
92653: LD_VAR 0 5
92657: PPUSH
92658: LD_VAR 0 6
92662: PPUSH
92663: LD_VAR 0 3
92667: PPUSH
92668: CALL_OW 47
92672: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
92673: LD_OWVAR 42
92677: PUSH
92678: LD_INT 32
92680: PUSH
92681: LD_INT 33
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: IN
92688: IFFALSE 92704
// PlaceWeaponTurret ( b , weapon ) ;
92690: LD_VAR 0 8
92694: PPUSH
92695: LD_VAR 0 4
92699: PPUSH
92700: CALL_OW 431
// end ;
92704: LD_VAR 0 7
92708: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
92709: LD_INT 0
92711: PPUSH
92712: PPUSH
92713: PPUSH
92714: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92715: LD_ADDR_VAR 0 4
92719: PUSH
92720: LD_INT 22
92722: PUSH
92723: LD_OWVAR 2
92727: PUSH
92728: EMPTY
92729: LIST
92730: LIST
92731: PUSH
92732: LD_INT 2
92734: PUSH
92735: LD_INT 30
92737: PUSH
92738: LD_INT 0
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: PUSH
92745: LD_INT 30
92747: PUSH
92748: LD_INT 1
92750: PUSH
92751: EMPTY
92752: LIST
92753: LIST
92754: PUSH
92755: EMPTY
92756: LIST
92757: LIST
92758: LIST
92759: PUSH
92760: EMPTY
92761: LIST
92762: LIST
92763: PPUSH
92764: CALL_OW 69
92768: ST_TO_ADDR
// if not tmp then
92769: LD_VAR 0 4
92773: NOT
92774: IFFALSE 92778
// exit ;
92776: GO 92837
// for i in tmp do
92778: LD_ADDR_VAR 0 2
92782: PUSH
92783: LD_VAR 0 4
92787: PUSH
92788: FOR_IN
92789: IFFALSE 92835
// for j = 1 to 3 do
92791: LD_ADDR_VAR 0 3
92795: PUSH
92796: DOUBLE
92797: LD_INT 1
92799: DEC
92800: ST_TO_ADDR
92801: LD_INT 3
92803: PUSH
92804: FOR_TO
92805: IFFALSE 92831
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
92807: LD_VAR 0 2
92811: PPUSH
92812: CALL_OW 274
92816: PPUSH
92817: LD_VAR 0 3
92821: PPUSH
92822: LD_INT 99999
92824: PPUSH
92825: CALL_OW 277
92829: GO 92804
92831: POP
92832: POP
92833: GO 92788
92835: POP
92836: POP
// end ;
92837: LD_VAR 0 1
92841: RET
// export function hHackSetLevel10 ; var i , j ; begin
92842: LD_INT 0
92844: PPUSH
92845: PPUSH
92846: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
92847: LD_ADDR_VAR 0 2
92851: PUSH
92852: LD_INT 21
92854: PUSH
92855: LD_INT 1
92857: PUSH
92858: EMPTY
92859: LIST
92860: LIST
92861: PPUSH
92862: CALL_OW 69
92866: PUSH
92867: FOR_IN
92868: IFFALSE 92920
// if IsSelected ( i ) then
92870: LD_VAR 0 2
92874: PPUSH
92875: CALL_OW 306
92879: IFFALSE 92918
// begin for j := 1 to 4 do
92881: LD_ADDR_VAR 0 3
92885: PUSH
92886: DOUBLE
92887: LD_INT 1
92889: DEC
92890: ST_TO_ADDR
92891: LD_INT 4
92893: PUSH
92894: FOR_TO
92895: IFFALSE 92916
// SetSkill ( i , j , 10 ) ;
92897: LD_VAR 0 2
92901: PPUSH
92902: LD_VAR 0 3
92906: PPUSH
92907: LD_INT 10
92909: PPUSH
92910: CALL_OW 237
92914: GO 92894
92916: POP
92917: POP
// end ;
92918: GO 92867
92920: POP
92921: POP
// end ;
92922: LD_VAR 0 1
92926: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
92927: LD_INT 0
92929: PPUSH
92930: PPUSH
92931: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
92932: LD_ADDR_VAR 0 2
92936: PUSH
92937: LD_INT 22
92939: PUSH
92940: LD_OWVAR 2
92944: PUSH
92945: EMPTY
92946: LIST
92947: LIST
92948: PUSH
92949: LD_INT 21
92951: PUSH
92952: LD_INT 1
92954: PUSH
92955: EMPTY
92956: LIST
92957: LIST
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: PPUSH
92963: CALL_OW 69
92967: PUSH
92968: FOR_IN
92969: IFFALSE 93010
// begin for j := 1 to 4 do
92971: LD_ADDR_VAR 0 3
92975: PUSH
92976: DOUBLE
92977: LD_INT 1
92979: DEC
92980: ST_TO_ADDR
92981: LD_INT 4
92983: PUSH
92984: FOR_TO
92985: IFFALSE 93006
// SetSkill ( i , j , 10 ) ;
92987: LD_VAR 0 2
92991: PPUSH
92992: LD_VAR 0 3
92996: PPUSH
92997: LD_INT 10
92999: PPUSH
93000: CALL_OW 237
93004: GO 92984
93006: POP
93007: POP
// end ;
93008: GO 92968
93010: POP
93011: POP
// end ;
93012: LD_VAR 0 1
93016: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
93017: LD_INT 0
93019: PPUSH
// uc_side := your_side ;
93020: LD_ADDR_OWVAR 20
93024: PUSH
93025: LD_OWVAR 2
93029: ST_TO_ADDR
// uc_nation := nation ;
93030: LD_ADDR_OWVAR 21
93034: PUSH
93035: LD_VAR 0 1
93039: ST_TO_ADDR
// InitHc ;
93040: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
93044: LD_INT 0
93046: PPUSH
93047: LD_VAR 0 2
93051: PPUSH
93052: LD_VAR 0 3
93056: PPUSH
93057: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
93061: LD_VAR 0 4
93065: PPUSH
93066: LD_VAR 0 5
93070: PPUSH
93071: CALL_OW 428
93075: PUSH
93076: LD_INT 0
93078: EQUAL
93079: IFFALSE 93103
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
93081: CALL_OW 44
93085: PPUSH
93086: LD_VAR 0 4
93090: PPUSH
93091: LD_VAR 0 5
93095: PPUSH
93096: LD_INT 1
93098: PPUSH
93099: CALL_OW 48
// end ;
93103: LD_VAR 0 6
93107: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
93108: LD_INT 0
93110: PPUSH
93111: PPUSH
// uc_side := your_side ;
93112: LD_ADDR_OWVAR 20
93116: PUSH
93117: LD_OWVAR 2
93121: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
93122: LD_VAR 0 1
93126: PUSH
93127: LD_INT 1
93129: PUSH
93130: LD_INT 2
93132: PUSH
93133: LD_INT 3
93135: PUSH
93136: LD_INT 4
93138: PUSH
93139: LD_INT 5
93141: PUSH
93142: EMPTY
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: IN
93149: IFFALSE 93161
// uc_nation := nation_american else
93151: LD_ADDR_OWVAR 21
93155: PUSH
93156: LD_INT 1
93158: ST_TO_ADDR
93159: GO 93204
// if chassis in [ 11 , 12 , 13 , 14 ] then
93161: LD_VAR 0 1
93165: PUSH
93166: LD_INT 11
93168: PUSH
93169: LD_INT 12
93171: PUSH
93172: LD_INT 13
93174: PUSH
93175: LD_INT 14
93177: PUSH
93178: EMPTY
93179: LIST
93180: LIST
93181: LIST
93182: LIST
93183: IN
93184: IFFALSE 93196
// uc_nation := nation_arabian else
93186: LD_ADDR_OWVAR 21
93190: PUSH
93191: LD_INT 2
93193: ST_TO_ADDR
93194: GO 93204
// uc_nation := nation_russian ;
93196: LD_ADDR_OWVAR 21
93200: PUSH
93201: LD_INT 3
93203: ST_TO_ADDR
// vc_chassis := chassis ;
93204: LD_ADDR_OWVAR 37
93208: PUSH
93209: LD_VAR 0 1
93213: ST_TO_ADDR
// vc_engine := engine ;
93214: LD_ADDR_OWVAR 39
93218: PUSH
93219: LD_VAR 0 2
93223: ST_TO_ADDR
// vc_control := control ;
93224: LD_ADDR_OWVAR 38
93228: PUSH
93229: LD_VAR 0 3
93233: ST_TO_ADDR
// vc_weapon := weapon ;
93234: LD_ADDR_OWVAR 40
93238: PUSH
93239: LD_VAR 0 4
93243: ST_TO_ADDR
// un := CreateVehicle ;
93244: LD_ADDR_VAR 0 8
93248: PUSH
93249: CALL_OW 45
93253: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
93254: LD_VAR 0 8
93258: PPUSH
93259: LD_INT 0
93261: PPUSH
93262: LD_INT 5
93264: PPUSH
93265: CALL_OW 12
93269: PPUSH
93270: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
93274: LD_VAR 0 8
93278: PPUSH
93279: LD_VAR 0 5
93283: PPUSH
93284: LD_VAR 0 6
93288: PPUSH
93289: LD_INT 1
93291: PPUSH
93292: CALL_OW 48
// end ;
93296: LD_VAR 0 7
93300: RET
// export hInvincible ; every 1 do
93301: GO 93303
93303: DISABLE
// hInvincible := [ ] ;
93304: LD_ADDR_EXP 163
93308: PUSH
93309: EMPTY
93310: ST_TO_ADDR
93311: END
// every 10 do var i ;
93312: GO 93314
93314: DISABLE
93315: LD_INT 0
93317: PPUSH
// begin enable ;
93318: ENABLE
// if not hInvincible then
93319: LD_EXP 163
93323: NOT
93324: IFFALSE 93328
// exit ;
93326: GO 93372
// for i in hInvincible do
93328: LD_ADDR_VAR 0 1
93332: PUSH
93333: LD_EXP 163
93337: PUSH
93338: FOR_IN
93339: IFFALSE 93370
// if GetLives ( i ) < 1000 then
93341: LD_VAR 0 1
93345: PPUSH
93346: CALL_OW 256
93350: PUSH
93351: LD_INT 1000
93353: LESS
93354: IFFALSE 93368
// SetLives ( i , 1000 ) ;
93356: LD_VAR 0 1
93360: PPUSH
93361: LD_INT 1000
93363: PPUSH
93364: CALL_OW 234
93368: GO 93338
93370: POP
93371: POP
// end ;
93372: PPOPN 1
93374: END
// export function hHackInvincible ; var i ; begin
93375: LD_INT 0
93377: PPUSH
93378: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
93379: LD_ADDR_VAR 0 2
93383: PUSH
93384: LD_INT 2
93386: PUSH
93387: LD_INT 21
93389: PUSH
93390: LD_INT 1
93392: PUSH
93393: EMPTY
93394: LIST
93395: LIST
93396: PUSH
93397: LD_INT 21
93399: PUSH
93400: LD_INT 2
93402: PUSH
93403: EMPTY
93404: LIST
93405: LIST
93406: PUSH
93407: EMPTY
93408: LIST
93409: LIST
93410: LIST
93411: PPUSH
93412: CALL_OW 69
93416: PUSH
93417: FOR_IN
93418: IFFALSE 93479
// if IsSelected ( i ) then
93420: LD_VAR 0 2
93424: PPUSH
93425: CALL_OW 306
93429: IFFALSE 93477
// begin if i in hInvincible then
93431: LD_VAR 0 2
93435: PUSH
93436: LD_EXP 163
93440: IN
93441: IFFALSE 93461
// hInvincible := hInvincible diff i else
93443: LD_ADDR_EXP 163
93447: PUSH
93448: LD_EXP 163
93452: PUSH
93453: LD_VAR 0 2
93457: DIFF
93458: ST_TO_ADDR
93459: GO 93477
// hInvincible := hInvincible union i ;
93461: LD_ADDR_EXP 163
93465: PUSH
93466: LD_EXP 163
93470: PUSH
93471: LD_VAR 0 2
93475: UNION
93476: ST_TO_ADDR
// end ;
93477: GO 93417
93479: POP
93480: POP
// end ;
93481: LD_VAR 0 1
93485: RET
// export function hHackInvisible ; var i , j ; begin
93486: LD_INT 0
93488: PPUSH
93489: PPUSH
93490: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
93491: LD_ADDR_VAR 0 2
93495: PUSH
93496: LD_INT 21
93498: PUSH
93499: LD_INT 1
93501: PUSH
93502: EMPTY
93503: LIST
93504: LIST
93505: PPUSH
93506: CALL_OW 69
93510: PUSH
93511: FOR_IN
93512: IFFALSE 93536
// if IsSelected ( i ) then
93514: LD_VAR 0 2
93518: PPUSH
93519: CALL_OW 306
93523: IFFALSE 93534
// ComForceInvisible ( i ) ;
93525: LD_VAR 0 2
93529: PPUSH
93530: CALL_OW 496
93534: GO 93511
93536: POP
93537: POP
// end ;
93538: LD_VAR 0 1
93542: RET
// export function hHackChangeYourSide ; begin
93543: LD_INT 0
93545: PPUSH
// if your_side = 8 then
93546: LD_OWVAR 2
93550: PUSH
93551: LD_INT 8
93553: EQUAL
93554: IFFALSE 93566
// your_side := 0 else
93556: LD_ADDR_OWVAR 2
93560: PUSH
93561: LD_INT 0
93563: ST_TO_ADDR
93564: GO 93580
// your_side := your_side + 1 ;
93566: LD_ADDR_OWVAR 2
93570: PUSH
93571: LD_OWVAR 2
93575: PUSH
93576: LD_INT 1
93578: PLUS
93579: ST_TO_ADDR
// end ;
93580: LD_VAR 0 1
93584: RET
// export function hHackChangeUnitSide ; var i , j ; begin
93585: LD_INT 0
93587: PPUSH
93588: PPUSH
93589: PPUSH
// for i in all_units do
93590: LD_ADDR_VAR 0 2
93594: PUSH
93595: LD_OWVAR 3
93599: PUSH
93600: FOR_IN
93601: IFFALSE 93679
// if IsSelected ( i ) then
93603: LD_VAR 0 2
93607: PPUSH
93608: CALL_OW 306
93612: IFFALSE 93677
// begin j := GetSide ( i ) ;
93614: LD_ADDR_VAR 0 3
93618: PUSH
93619: LD_VAR 0 2
93623: PPUSH
93624: CALL_OW 255
93628: ST_TO_ADDR
// if j = 8 then
93629: LD_VAR 0 3
93633: PUSH
93634: LD_INT 8
93636: EQUAL
93637: IFFALSE 93649
// j := 0 else
93639: LD_ADDR_VAR 0 3
93643: PUSH
93644: LD_INT 0
93646: ST_TO_ADDR
93647: GO 93663
// j := j + 1 ;
93649: LD_ADDR_VAR 0 3
93653: PUSH
93654: LD_VAR 0 3
93658: PUSH
93659: LD_INT 1
93661: PLUS
93662: ST_TO_ADDR
// SetSide ( i , j ) ;
93663: LD_VAR 0 2
93667: PPUSH
93668: LD_VAR 0 3
93672: PPUSH
93673: CALL_OW 235
// end ;
93677: GO 93600
93679: POP
93680: POP
// end ;
93681: LD_VAR 0 1
93685: RET
// export function hHackFog ; begin
93686: LD_INT 0
93688: PPUSH
// FogOff ( true ) ;
93689: LD_INT 1
93691: PPUSH
93692: CALL_OW 344
// end ;
93696: LD_VAR 0 1
93700: RET
// export function hHackTeleport ( unit , x , y ) ; begin
93701: LD_INT 0
93703: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
93704: LD_VAR 0 1
93708: PPUSH
93709: LD_VAR 0 2
93713: PPUSH
93714: LD_VAR 0 3
93718: PPUSH
93719: LD_INT 1
93721: PPUSH
93722: LD_INT 1
93724: PPUSH
93725: CALL_OW 483
// CenterOnXY ( x , y ) ;
93729: LD_VAR 0 2
93733: PPUSH
93734: LD_VAR 0 3
93738: PPUSH
93739: CALL_OW 84
// end ; end_of_file
93743: LD_VAR 0 4
93747: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
93748: LD_INT 0
93750: PPUSH
93751: PPUSH
93752: PPUSH
93753: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
93754: LD_VAR 0 1
93758: PPUSH
93759: CALL_OW 264
93763: PUSH
93764: LD_EXP 52
93768: EQUAL
93769: IFFALSE 93841
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
93771: LD_INT 68
93773: PPUSH
93774: LD_VAR 0 1
93778: PPUSH
93779: CALL_OW 255
93783: PPUSH
93784: CALL_OW 321
93788: PUSH
93789: LD_INT 2
93791: EQUAL
93792: IFFALSE 93804
// eff := 70 else
93794: LD_ADDR_VAR 0 4
93798: PUSH
93799: LD_INT 70
93801: ST_TO_ADDR
93802: GO 93812
// eff := 30 ;
93804: LD_ADDR_VAR 0 4
93808: PUSH
93809: LD_INT 30
93811: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
93812: LD_VAR 0 1
93816: PPUSH
93817: CALL_OW 250
93821: PPUSH
93822: LD_VAR 0 1
93826: PPUSH
93827: CALL_OW 251
93831: PPUSH
93832: LD_VAR 0 4
93836: PPUSH
93837: CALL_OW 495
// end ; end ;
93841: LD_VAR 0 2
93845: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
93846: LD_INT 0
93848: PPUSH
// end ;
93849: LD_VAR 0 4
93853: RET
// export function SOS_Command ( cmd ) ; begin
93854: LD_INT 0
93856: PPUSH
// end ;
93857: LD_VAR 0 2
93861: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
93862: LD_INT 0
93864: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
93865: LD_VAR 0 1
93869: PUSH
93870: LD_INT 250
93872: EQUAL
93873: PUSH
93874: LD_VAR 0 2
93878: PPUSH
93879: CALL_OW 264
93883: PUSH
93884: LD_EXP 55
93888: EQUAL
93889: AND
93890: IFFALSE 93911
// MinerPlaceMine ( unit , x , y ) ;
93892: LD_VAR 0 2
93896: PPUSH
93897: LD_VAR 0 4
93901: PPUSH
93902: LD_VAR 0 5
93906: PPUSH
93907: CALL 96252 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
93911: LD_VAR 0 1
93915: PUSH
93916: LD_INT 251
93918: EQUAL
93919: PUSH
93920: LD_VAR 0 2
93924: PPUSH
93925: CALL_OW 264
93929: PUSH
93930: LD_EXP 55
93934: EQUAL
93935: AND
93936: IFFALSE 93957
// MinerDetonateMine ( unit , x , y ) ;
93938: LD_VAR 0 2
93942: PPUSH
93943: LD_VAR 0 4
93947: PPUSH
93948: LD_VAR 0 5
93952: PPUSH
93953: CALL 96529 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
93957: LD_VAR 0 1
93961: PUSH
93962: LD_INT 252
93964: EQUAL
93965: PUSH
93966: LD_VAR 0 2
93970: PPUSH
93971: CALL_OW 264
93975: PUSH
93976: LD_EXP 55
93980: EQUAL
93981: AND
93982: IFFALSE 94003
// MinerCreateMinefield ( unit , x , y ) ;
93984: LD_VAR 0 2
93988: PPUSH
93989: LD_VAR 0 4
93993: PPUSH
93994: LD_VAR 0 5
93998: PPUSH
93999: CALL 96946 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
94003: LD_VAR 0 1
94007: PUSH
94008: LD_INT 253
94010: EQUAL
94011: PUSH
94012: LD_VAR 0 2
94016: PPUSH
94017: CALL_OW 257
94021: PUSH
94022: LD_INT 5
94024: EQUAL
94025: AND
94026: IFFALSE 94047
// ComBinocular ( unit , x , y ) ;
94028: LD_VAR 0 2
94032: PPUSH
94033: LD_VAR 0 4
94037: PPUSH
94038: LD_VAR 0 5
94042: PPUSH
94043: CALL 97317 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
94047: LD_VAR 0 1
94051: PUSH
94052: LD_INT 254
94054: EQUAL
94055: PUSH
94056: LD_VAR 0 2
94060: PPUSH
94061: CALL_OW 264
94065: PUSH
94066: LD_EXP 50
94070: EQUAL
94071: AND
94072: PUSH
94073: LD_VAR 0 3
94077: PPUSH
94078: CALL_OW 263
94082: PUSH
94083: LD_INT 3
94085: EQUAL
94086: AND
94087: IFFALSE 94103
// HackDestroyVehicle ( unit , selectedUnit ) ;
94089: LD_VAR 0 2
94093: PPUSH
94094: LD_VAR 0 3
94098: PPUSH
94099: CALL 95612 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
94103: LD_VAR 0 1
94107: PUSH
94108: LD_INT 255
94110: EQUAL
94111: PUSH
94112: LD_VAR 0 2
94116: PPUSH
94117: CALL_OW 264
94121: PUSH
94122: LD_INT 14
94124: PUSH
94125: LD_INT 53
94127: PUSH
94128: EMPTY
94129: LIST
94130: LIST
94131: IN
94132: AND
94133: PUSH
94134: LD_VAR 0 4
94138: PPUSH
94139: LD_VAR 0 5
94143: PPUSH
94144: CALL_OW 488
94148: AND
94149: IFFALSE 94173
// CutTreeXYR ( unit , x , y , 12 ) ;
94151: LD_VAR 0 2
94155: PPUSH
94156: LD_VAR 0 4
94160: PPUSH
94161: LD_VAR 0 5
94165: PPUSH
94166: LD_INT 12
94168: PPUSH
94169: CALL 94178 0 4
// end ;
94173: LD_VAR 0 6
94177: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
94178: LD_INT 0
94180: PPUSH
94181: PPUSH
94182: PPUSH
94183: PPUSH
94184: PPUSH
94185: PPUSH
94186: PPUSH
94187: PPUSH
94188: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
94189: LD_VAR 0 1
94193: NOT
94194: PUSH
94195: LD_VAR 0 2
94199: PPUSH
94200: LD_VAR 0 3
94204: PPUSH
94205: CALL_OW 488
94209: NOT
94210: OR
94211: PUSH
94212: LD_VAR 0 4
94216: NOT
94217: OR
94218: IFFALSE 94222
// exit ;
94220: GO 94562
// list := [ ] ;
94222: LD_ADDR_VAR 0 13
94226: PUSH
94227: EMPTY
94228: ST_TO_ADDR
// if x - r < 0 then
94229: LD_VAR 0 2
94233: PUSH
94234: LD_VAR 0 4
94238: MINUS
94239: PUSH
94240: LD_INT 0
94242: LESS
94243: IFFALSE 94255
// min_x := 0 else
94245: LD_ADDR_VAR 0 7
94249: PUSH
94250: LD_INT 0
94252: ST_TO_ADDR
94253: GO 94271
// min_x := x - r ;
94255: LD_ADDR_VAR 0 7
94259: PUSH
94260: LD_VAR 0 2
94264: PUSH
94265: LD_VAR 0 4
94269: MINUS
94270: ST_TO_ADDR
// if y - r < 0 then
94271: LD_VAR 0 3
94275: PUSH
94276: LD_VAR 0 4
94280: MINUS
94281: PUSH
94282: LD_INT 0
94284: LESS
94285: IFFALSE 94297
// min_y := 0 else
94287: LD_ADDR_VAR 0 8
94291: PUSH
94292: LD_INT 0
94294: ST_TO_ADDR
94295: GO 94313
// min_y := y - r ;
94297: LD_ADDR_VAR 0 8
94301: PUSH
94302: LD_VAR 0 3
94306: PUSH
94307: LD_VAR 0 4
94311: MINUS
94312: ST_TO_ADDR
// max_x := x + r ;
94313: LD_ADDR_VAR 0 9
94317: PUSH
94318: LD_VAR 0 2
94322: PUSH
94323: LD_VAR 0 4
94327: PLUS
94328: ST_TO_ADDR
// max_y := y + r ;
94329: LD_ADDR_VAR 0 10
94333: PUSH
94334: LD_VAR 0 3
94338: PUSH
94339: LD_VAR 0 4
94343: PLUS
94344: ST_TO_ADDR
// for _x = min_x to max_x do
94345: LD_ADDR_VAR 0 11
94349: PUSH
94350: DOUBLE
94351: LD_VAR 0 7
94355: DEC
94356: ST_TO_ADDR
94357: LD_VAR 0 9
94361: PUSH
94362: FOR_TO
94363: IFFALSE 94480
// for _y = min_y to max_y do
94365: LD_ADDR_VAR 0 12
94369: PUSH
94370: DOUBLE
94371: LD_VAR 0 8
94375: DEC
94376: ST_TO_ADDR
94377: LD_VAR 0 10
94381: PUSH
94382: FOR_TO
94383: IFFALSE 94476
// begin if not ValidHex ( _x , _y ) then
94385: LD_VAR 0 11
94389: PPUSH
94390: LD_VAR 0 12
94394: PPUSH
94395: CALL_OW 488
94399: NOT
94400: IFFALSE 94404
// continue ;
94402: GO 94382
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
94404: LD_VAR 0 11
94408: PPUSH
94409: LD_VAR 0 12
94413: PPUSH
94414: CALL_OW 351
94418: PUSH
94419: LD_VAR 0 11
94423: PPUSH
94424: LD_VAR 0 12
94428: PPUSH
94429: CALL_OW 554
94433: AND
94434: IFFALSE 94474
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
94436: LD_ADDR_VAR 0 13
94440: PUSH
94441: LD_VAR 0 13
94445: PPUSH
94446: LD_VAR 0 13
94450: PUSH
94451: LD_INT 1
94453: PLUS
94454: PPUSH
94455: LD_VAR 0 11
94459: PUSH
94460: LD_VAR 0 12
94464: PUSH
94465: EMPTY
94466: LIST
94467: LIST
94468: PPUSH
94469: CALL_OW 2
94473: ST_TO_ADDR
// end ;
94474: GO 94382
94476: POP
94477: POP
94478: GO 94362
94480: POP
94481: POP
// if not list then
94482: LD_VAR 0 13
94486: NOT
94487: IFFALSE 94491
// exit ;
94489: GO 94562
// for i in list do
94491: LD_ADDR_VAR 0 6
94495: PUSH
94496: LD_VAR 0 13
94500: PUSH
94501: FOR_IN
94502: IFFALSE 94560
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
94504: LD_VAR 0 1
94508: PPUSH
94509: LD_STRING M
94511: PUSH
94512: LD_VAR 0 6
94516: PUSH
94517: LD_INT 1
94519: ARRAY
94520: PUSH
94521: LD_VAR 0 6
94525: PUSH
94526: LD_INT 2
94528: ARRAY
94529: PUSH
94530: LD_INT 0
94532: PUSH
94533: LD_INT 0
94535: PUSH
94536: LD_INT 0
94538: PUSH
94539: LD_INT 0
94541: PUSH
94542: EMPTY
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: PUSH
94551: EMPTY
94552: LIST
94553: PPUSH
94554: CALL_OW 447
94558: GO 94501
94560: POP
94561: POP
// end ;
94562: LD_VAR 0 5
94566: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
94567: LD_EXP 164
94571: NOT
94572: IFFALSE 94622
94574: GO 94576
94576: DISABLE
// begin initHack := true ;
94577: LD_ADDR_EXP 164
94581: PUSH
94582: LD_INT 1
94584: ST_TO_ADDR
// hackTanks := [ ] ;
94585: LD_ADDR_EXP 165
94589: PUSH
94590: EMPTY
94591: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
94592: LD_ADDR_EXP 166
94596: PUSH
94597: EMPTY
94598: ST_TO_ADDR
// hackLimit := 3 ;
94599: LD_ADDR_EXP 167
94603: PUSH
94604: LD_INT 3
94606: ST_TO_ADDR
// hackDist := 12 ;
94607: LD_ADDR_EXP 168
94611: PUSH
94612: LD_INT 12
94614: ST_TO_ADDR
// hackCounter := [ ] ;
94615: LD_ADDR_EXP 169
94619: PUSH
94620: EMPTY
94621: ST_TO_ADDR
// end ;
94622: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
94623: LD_EXP 164
94627: PUSH
94628: LD_INT 34
94630: PUSH
94631: LD_EXP 50
94635: PUSH
94636: EMPTY
94637: LIST
94638: LIST
94639: PPUSH
94640: CALL_OW 69
94644: AND
94645: IFFALSE 94900
94647: GO 94649
94649: DISABLE
94650: LD_INT 0
94652: PPUSH
94653: PPUSH
// begin enable ;
94654: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
94655: LD_ADDR_VAR 0 1
94659: PUSH
94660: LD_INT 34
94662: PUSH
94663: LD_EXP 50
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: PPUSH
94672: CALL_OW 69
94676: PUSH
94677: FOR_IN
94678: IFFALSE 94898
// begin if not i in hackTanks then
94680: LD_VAR 0 1
94684: PUSH
94685: LD_EXP 165
94689: IN
94690: NOT
94691: IFFALSE 94774
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
94693: LD_ADDR_EXP 165
94697: PUSH
94698: LD_EXP 165
94702: PPUSH
94703: LD_EXP 165
94707: PUSH
94708: LD_INT 1
94710: PLUS
94711: PPUSH
94712: LD_VAR 0 1
94716: PPUSH
94717: CALL_OW 1
94721: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
94722: LD_ADDR_EXP 166
94726: PUSH
94727: LD_EXP 166
94731: PPUSH
94732: LD_EXP 166
94736: PUSH
94737: LD_INT 1
94739: PLUS
94740: PPUSH
94741: EMPTY
94742: PPUSH
94743: CALL_OW 1
94747: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
94748: LD_ADDR_EXP 169
94752: PUSH
94753: LD_EXP 169
94757: PPUSH
94758: LD_EXP 169
94762: PUSH
94763: LD_INT 1
94765: PLUS
94766: PPUSH
94767: EMPTY
94768: PPUSH
94769: CALL_OW 1
94773: ST_TO_ADDR
// end ; if not IsOk ( i ) then
94774: LD_VAR 0 1
94778: PPUSH
94779: CALL_OW 302
94783: NOT
94784: IFFALSE 94797
// begin HackUnlinkAll ( i ) ;
94786: LD_VAR 0 1
94790: PPUSH
94791: CALL 94903 0 1
// continue ;
94795: GO 94677
// end ; HackCheckCapturedStatus ( i ) ;
94797: LD_VAR 0 1
94801: PPUSH
94802: CALL 95346 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
94806: LD_ADDR_VAR 0 2
94810: PUSH
94811: LD_INT 81
94813: PUSH
94814: LD_VAR 0 1
94818: PPUSH
94819: CALL_OW 255
94823: PUSH
94824: EMPTY
94825: LIST
94826: LIST
94827: PUSH
94828: LD_INT 33
94830: PUSH
94831: LD_INT 3
94833: PUSH
94834: EMPTY
94835: LIST
94836: LIST
94837: PUSH
94838: LD_INT 91
94840: PUSH
94841: LD_VAR 0 1
94845: PUSH
94846: LD_EXP 168
94850: PUSH
94851: EMPTY
94852: LIST
94853: LIST
94854: LIST
94855: PUSH
94856: LD_INT 50
94858: PUSH
94859: EMPTY
94860: LIST
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: LIST
94866: LIST
94867: PPUSH
94868: CALL_OW 69
94872: ST_TO_ADDR
// if not tmp then
94873: LD_VAR 0 2
94877: NOT
94878: IFFALSE 94882
// continue ;
94880: GO 94677
// HackLink ( i , tmp ) ;
94882: LD_VAR 0 1
94886: PPUSH
94887: LD_VAR 0 2
94891: PPUSH
94892: CALL 95039 0 2
// end ;
94896: GO 94677
94898: POP
94899: POP
// end ;
94900: PPOPN 2
94902: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
94903: LD_INT 0
94905: PPUSH
94906: PPUSH
94907: PPUSH
// if not hack in hackTanks then
94908: LD_VAR 0 1
94912: PUSH
94913: LD_EXP 165
94917: IN
94918: NOT
94919: IFFALSE 94923
// exit ;
94921: GO 95034
// index := GetElementIndex ( hackTanks , hack ) ;
94923: LD_ADDR_VAR 0 4
94927: PUSH
94928: LD_EXP 165
94932: PPUSH
94933: LD_VAR 0 1
94937: PPUSH
94938: CALL 18333 0 2
94942: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
94943: LD_EXP 166
94947: PUSH
94948: LD_VAR 0 4
94952: ARRAY
94953: IFFALSE 95034
// begin for i in hackTanksCaptured [ index ] do
94955: LD_ADDR_VAR 0 3
94959: PUSH
94960: LD_EXP 166
94964: PUSH
94965: LD_VAR 0 4
94969: ARRAY
94970: PUSH
94971: FOR_IN
94972: IFFALSE 94998
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
94974: LD_VAR 0 3
94978: PUSH
94979: LD_INT 1
94981: ARRAY
94982: PPUSH
94983: LD_VAR 0 3
94987: PUSH
94988: LD_INT 2
94990: ARRAY
94991: PPUSH
94992: CALL_OW 235
94996: GO 94971
94998: POP
94999: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
95000: LD_ADDR_EXP 166
95004: PUSH
95005: LD_EXP 166
95009: PPUSH
95010: LD_VAR 0 4
95014: PPUSH
95015: EMPTY
95016: PPUSH
95017: CALL_OW 1
95021: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
95022: LD_VAR 0 1
95026: PPUSH
95027: LD_INT 0
95029: PPUSH
95030: CALL_OW 505
// end ; end ;
95034: LD_VAR 0 2
95038: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
95039: LD_INT 0
95041: PPUSH
95042: PPUSH
95043: PPUSH
// if not hack in hackTanks or not vehicles then
95044: LD_VAR 0 1
95048: PUSH
95049: LD_EXP 165
95053: IN
95054: NOT
95055: PUSH
95056: LD_VAR 0 2
95060: NOT
95061: OR
95062: IFFALSE 95066
// exit ;
95064: GO 95341
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
95066: LD_ADDR_VAR 0 2
95070: PUSH
95071: LD_VAR 0 1
95075: PPUSH
95076: LD_VAR 0 2
95080: PPUSH
95081: LD_INT 1
95083: PPUSH
95084: LD_INT 1
95086: PPUSH
95087: CALL 18983 0 4
95091: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
95092: LD_ADDR_VAR 0 5
95096: PUSH
95097: LD_EXP 165
95101: PPUSH
95102: LD_VAR 0 1
95106: PPUSH
95107: CALL 18333 0 2
95111: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
95112: LD_EXP 166
95116: PUSH
95117: LD_VAR 0 5
95121: ARRAY
95122: PUSH
95123: LD_EXP 167
95127: LESS
95128: IFFALSE 95317
// begin for i := 1 to vehicles do
95130: LD_ADDR_VAR 0 4
95134: PUSH
95135: DOUBLE
95136: LD_INT 1
95138: DEC
95139: ST_TO_ADDR
95140: LD_VAR 0 2
95144: PUSH
95145: FOR_TO
95146: IFFALSE 95315
// begin if hackTanksCaptured [ index ] = hackLimit then
95148: LD_EXP 166
95152: PUSH
95153: LD_VAR 0 5
95157: ARRAY
95158: PUSH
95159: LD_EXP 167
95163: EQUAL
95164: IFFALSE 95168
// break ;
95166: GO 95315
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
95168: LD_ADDR_EXP 169
95172: PUSH
95173: LD_EXP 169
95177: PPUSH
95178: LD_VAR 0 5
95182: PPUSH
95183: LD_EXP 169
95187: PUSH
95188: LD_VAR 0 5
95192: ARRAY
95193: PUSH
95194: LD_INT 1
95196: PLUS
95197: PPUSH
95198: CALL_OW 1
95202: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
95203: LD_ADDR_EXP 166
95207: PUSH
95208: LD_EXP 166
95212: PPUSH
95213: LD_VAR 0 5
95217: PUSH
95218: LD_EXP 166
95222: PUSH
95223: LD_VAR 0 5
95227: ARRAY
95228: PUSH
95229: LD_INT 1
95231: PLUS
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: PPUSH
95237: LD_VAR 0 2
95241: PUSH
95242: LD_VAR 0 4
95246: ARRAY
95247: PUSH
95248: LD_VAR 0 2
95252: PUSH
95253: LD_VAR 0 4
95257: ARRAY
95258: PPUSH
95259: CALL_OW 255
95263: PUSH
95264: EMPTY
95265: LIST
95266: LIST
95267: PPUSH
95268: CALL 18548 0 3
95272: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
95273: LD_VAR 0 2
95277: PUSH
95278: LD_VAR 0 4
95282: ARRAY
95283: PPUSH
95284: LD_VAR 0 1
95288: PPUSH
95289: CALL_OW 255
95293: PPUSH
95294: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
95298: LD_VAR 0 2
95302: PUSH
95303: LD_VAR 0 4
95307: ARRAY
95308: PPUSH
95309: CALL_OW 141
// end ;
95313: GO 95145
95315: POP
95316: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
95317: LD_VAR 0 1
95321: PPUSH
95322: LD_EXP 166
95326: PUSH
95327: LD_VAR 0 5
95331: ARRAY
95332: PUSH
95333: LD_INT 0
95335: PLUS
95336: PPUSH
95337: CALL_OW 505
// end ;
95341: LD_VAR 0 3
95345: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
95346: LD_INT 0
95348: PPUSH
95349: PPUSH
95350: PPUSH
95351: PPUSH
// if not hack in hackTanks then
95352: LD_VAR 0 1
95356: PUSH
95357: LD_EXP 165
95361: IN
95362: NOT
95363: IFFALSE 95367
// exit ;
95365: GO 95607
// index := GetElementIndex ( hackTanks , hack ) ;
95367: LD_ADDR_VAR 0 4
95371: PUSH
95372: LD_EXP 165
95376: PPUSH
95377: LD_VAR 0 1
95381: PPUSH
95382: CALL 18333 0 2
95386: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
95387: LD_ADDR_VAR 0 3
95391: PUSH
95392: DOUBLE
95393: LD_EXP 166
95397: PUSH
95398: LD_VAR 0 4
95402: ARRAY
95403: INC
95404: ST_TO_ADDR
95405: LD_INT 1
95407: PUSH
95408: FOR_DOWNTO
95409: IFFALSE 95581
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
95411: LD_ADDR_VAR 0 5
95415: PUSH
95416: LD_EXP 166
95420: PUSH
95421: LD_VAR 0 4
95425: ARRAY
95426: PUSH
95427: LD_VAR 0 3
95431: ARRAY
95432: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
95433: LD_VAR 0 5
95437: PUSH
95438: LD_INT 1
95440: ARRAY
95441: PPUSH
95442: CALL_OW 302
95446: NOT
95447: PUSH
95448: LD_VAR 0 5
95452: PUSH
95453: LD_INT 1
95455: ARRAY
95456: PPUSH
95457: CALL_OW 255
95461: PUSH
95462: LD_VAR 0 1
95466: PPUSH
95467: CALL_OW 255
95471: NONEQUAL
95472: OR
95473: IFFALSE 95579
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
95475: LD_VAR 0 5
95479: PUSH
95480: LD_INT 1
95482: ARRAY
95483: PPUSH
95484: CALL_OW 305
95488: PUSH
95489: LD_VAR 0 5
95493: PUSH
95494: LD_INT 1
95496: ARRAY
95497: PPUSH
95498: CALL_OW 255
95502: PUSH
95503: LD_VAR 0 1
95507: PPUSH
95508: CALL_OW 255
95512: EQUAL
95513: AND
95514: IFFALSE 95538
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
95516: LD_VAR 0 5
95520: PUSH
95521: LD_INT 1
95523: ARRAY
95524: PPUSH
95525: LD_VAR 0 5
95529: PUSH
95530: LD_INT 2
95532: ARRAY
95533: PPUSH
95534: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
95538: LD_ADDR_EXP 166
95542: PUSH
95543: LD_EXP 166
95547: PPUSH
95548: LD_VAR 0 4
95552: PPUSH
95553: LD_EXP 166
95557: PUSH
95558: LD_VAR 0 4
95562: ARRAY
95563: PPUSH
95564: LD_VAR 0 3
95568: PPUSH
95569: CALL_OW 3
95573: PPUSH
95574: CALL_OW 1
95578: ST_TO_ADDR
// end ; end ;
95579: GO 95408
95581: POP
95582: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
95583: LD_VAR 0 1
95587: PPUSH
95588: LD_EXP 166
95592: PUSH
95593: LD_VAR 0 4
95597: ARRAY
95598: PUSH
95599: LD_INT 0
95601: PLUS
95602: PPUSH
95603: CALL_OW 505
// end ;
95607: LD_VAR 0 2
95611: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
95612: LD_INT 0
95614: PPUSH
95615: PPUSH
95616: PPUSH
95617: PPUSH
// if not hack in hackTanks then
95618: LD_VAR 0 1
95622: PUSH
95623: LD_EXP 165
95627: IN
95628: NOT
95629: IFFALSE 95633
// exit ;
95631: GO 95718
// index := GetElementIndex ( hackTanks , hack ) ;
95633: LD_ADDR_VAR 0 5
95637: PUSH
95638: LD_EXP 165
95642: PPUSH
95643: LD_VAR 0 1
95647: PPUSH
95648: CALL 18333 0 2
95652: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
95653: LD_ADDR_VAR 0 4
95657: PUSH
95658: DOUBLE
95659: LD_INT 1
95661: DEC
95662: ST_TO_ADDR
95663: LD_EXP 166
95667: PUSH
95668: LD_VAR 0 5
95672: ARRAY
95673: PUSH
95674: FOR_TO
95675: IFFALSE 95716
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
95677: LD_EXP 166
95681: PUSH
95682: LD_VAR 0 5
95686: ARRAY
95687: PUSH
95688: LD_VAR 0 4
95692: ARRAY
95693: PUSH
95694: LD_INT 1
95696: ARRAY
95697: PUSH
95698: LD_VAR 0 2
95702: EQUAL
95703: IFFALSE 95714
// KillUnit ( vehicle ) ;
95705: LD_VAR 0 2
95709: PPUSH
95710: CALL_OW 66
95714: GO 95674
95716: POP
95717: POP
// end ;
95718: LD_VAR 0 3
95722: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
95723: LD_EXP 170
95727: NOT
95728: IFFALSE 95763
95730: GO 95732
95732: DISABLE
// begin initMiner := true ;
95733: LD_ADDR_EXP 170
95737: PUSH
95738: LD_INT 1
95740: ST_TO_ADDR
// minersList := [ ] ;
95741: LD_ADDR_EXP 171
95745: PUSH
95746: EMPTY
95747: ST_TO_ADDR
// minerMinesList := [ ] ;
95748: LD_ADDR_EXP 172
95752: PUSH
95753: EMPTY
95754: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
95755: LD_ADDR_EXP 173
95759: PUSH
95760: LD_INT 5
95762: ST_TO_ADDR
// end ;
95763: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
95764: LD_EXP 170
95768: PUSH
95769: LD_INT 34
95771: PUSH
95772: LD_EXP 55
95776: PUSH
95777: EMPTY
95778: LIST
95779: LIST
95780: PPUSH
95781: CALL_OW 69
95785: AND
95786: IFFALSE 96249
95788: GO 95790
95790: DISABLE
95791: LD_INT 0
95793: PPUSH
95794: PPUSH
95795: PPUSH
95796: PPUSH
// begin enable ;
95797: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
95798: LD_ADDR_VAR 0 1
95802: PUSH
95803: LD_INT 34
95805: PUSH
95806: LD_EXP 55
95810: PUSH
95811: EMPTY
95812: LIST
95813: LIST
95814: PPUSH
95815: CALL_OW 69
95819: PUSH
95820: FOR_IN
95821: IFFALSE 95893
// begin if not i in minersList then
95823: LD_VAR 0 1
95827: PUSH
95828: LD_EXP 171
95832: IN
95833: NOT
95834: IFFALSE 95891
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
95836: LD_ADDR_EXP 171
95840: PUSH
95841: LD_EXP 171
95845: PPUSH
95846: LD_EXP 171
95850: PUSH
95851: LD_INT 1
95853: PLUS
95854: PPUSH
95855: LD_VAR 0 1
95859: PPUSH
95860: CALL_OW 1
95864: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
95865: LD_ADDR_EXP 172
95869: PUSH
95870: LD_EXP 172
95874: PPUSH
95875: LD_EXP 172
95879: PUSH
95880: LD_INT 1
95882: PLUS
95883: PPUSH
95884: EMPTY
95885: PPUSH
95886: CALL_OW 1
95890: ST_TO_ADDR
// end end ;
95891: GO 95820
95893: POP
95894: POP
// for i := minerMinesList downto 1 do
95895: LD_ADDR_VAR 0 1
95899: PUSH
95900: DOUBLE
95901: LD_EXP 172
95905: INC
95906: ST_TO_ADDR
95907: LD_INT 1
95909: PUSH
95910: FOR_DOWNTO
95911: IFFALSE 96247
// begin if IsLive ( minersList [ i ] ) then
95913: LD_EXP 171
95917: PUSH
95918: LD_VAR 0 1
95922: ARRAY
95923: PPUSH
95924: CALL_OW 300
95928: IFFALSE 95956
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
95930: LD_EXP 171
95934: PUSH
95935: LD_VAR 0 1
95939: ARRAY
95940: PPUSH
95941: LD_EXP 172
95945: PUSH
95946: LD_VAR 0 1
95950: ARRAY
95951: PPUSH
95952: CALL_OW 505
// if not minerMinesList [ i ] then
95956: LD_EXP 172
95960: PUSH
95961: LD_VAR 0 1
95965: ARRAY
95966: NOT
95967: IFFALSE 95971
// continue ;
95969: GO 95910
// for j := minerMinesList [ i ] downto 1 do
95971: LD_ADDR_VAR 0 2
95975: PUSH
95976: DOUBLE
95977: LD_EXP 172
95981: PUSH
95982: LD_VAR 0 1
95986: ARRAY
95987: INC
95988: ST_TO_ADDR
95989: LD_INT 1
95991: PUSH
95992: FOR_DOWNTO
95993: IFFALSE 96243
// begin side := GetSide ( minersList [ i ] ) ;
95995: LD_ADDR_VAR 0 3
95999: PUSH
96000: LD_EXP 171
96004: PUSH
96005: LD_VAR 0 1
96009: ARRAY
96010: PPUSH
96011: CALL_OW 255
96015: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
96016: LD_ADDR_VAR 0 4
96020: PUSH
96021: LD_EXP 172
96025: PUSH
96026: LD_VAR 0 1
96030: ARRAY
96031: PUSH
96032: LD_VAR 0 2
96036: ARRAY
96037: PUSH
96038: LD_INT 1
96040: ARRAY
96041: PPUSH
96042: LD_EXP 172
96046: PUSH
96047: LD_VAR 0 1
96051: ARRAY
96052: PUSH
96053: LD_VAR 0 2
96057: ARRAY
96058: PUSH
96059: LD_INT 2
96061: ARRAY
96062: PPUSH
96063: CALL_OW 428
96067: ST_TO_ADDR
// if not tmp then
96068: LD_VAR 0 4
96072: NOT
96073: IFFALSE 96077
// continue ;
96075: GO 95992
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
96077: LD_VAR 0 4
96081: PUSH
96082: LD_INT 81
96084: PUSH
96085: LD_VAR 0 3
96089: PUSH
96090: EMPTY
96091: LIST
96092: LIST
96093: PPUSH
96094: CALL_OW 69
96098: IN
96099: PUSH
96100: LD_EXP 172
96104: PUSH
96105: LD_VAR 0 1
96109: ARRAY
96110: PUSH
96111: LD_VAR 0 2
96115: ARRAY
96116: PUSH
96117: LD_INT 1
96119: ARRAY
96120: PPUSH
96121: LD_EXP 172
96125: PUSH
96126: LD_VAR 0 1
96130: ARRAY
96131: PUSH
96132: LD_VAR 0 2
96136: ARRAY
96137: PUSH
96138: LD_INT 2
96140: ARRAY
96141: PPUSH
96142: CALL_OW 458
96146: AND
96147: IFFALSE 96241
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
96149: LD_EXP 172
96153: PUSH
96154: LD_VAR 0 1
96158: ARRAY
96159: PUSH
96160: LD_VAR 0 2
96164: ARRAY
96165: PUSH
96166: LD_INT 1
96168: ARRAY
96169: PPUSH
96170: LD_EXP 172
96174: PUSH
96175: LD_VAR 0 1
96179: ARRAY
96180: PUSH
96181: LD_VAR 0 2
96185: ARRAY
96186: PUSH
96187: LD_INT 2
96189: ARRAY
96190: PPUSH
96191: LD_VAR 0 3
96195: PPUSH
96196: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
96200: LD_ADDR_EXP 172
96204: PUSH
96205: LD_EXP 172
96209: PPUSH
96210: LD_VAR 0 1
96214: PPUSH
96215: LD_EXP 172
96219: PUSH
96220: LD_VAR 0 1
96224: ARRAY
96225: PPUSH
96226: LD_VAR 0 2
96230: PPUSH
96231: CALL_OW 3
96235: PPUSH
96236: CALL_OW 1
96240: ST_TO_ADDR
// end ; end ;
96241: GO 95992
96243: POP
96244: POP
// end ;
96245: GO 95910
96247: POP
96248: POP
// end ;
96249: PPOPN 4
96251: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
96252: LD_INT 0
96254: PPUSH
96255: PPUSH
// result := false ;
96256: LD_ADDR_VAR 0 4
96260: PUSH
96261: LD_INT 0
96263: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
96264: LD_VAR 0 1
96268: PPUSH
96269: CALL_OW 264
96273: PUSH
96274: LD_EXP 55
96278: EQUAL
96279: NOT
96280: IFFALSE 96284
// exit ;
96282: GO 96524
// index := GetElementIndex ( minersList , unit ) ;
96284: LD_ADDR_VAR 0 5
96288: PUSH
96289: LD_EXP 171
96293: PPUSH
96294: LD_VAR 0 1
96298: PPUSH
96299: CALL 18333 0 2
96303: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
96304: LD_EXP 172
96308: PUSH
96309: LD_VAR 0 5
96313: ARRAY
96314: PUSH
96315: LD_EXP 173
96319: GREATEREQUAL
96320: IFFALSE 96324
// exit ;
96322: GO 96524
// ComMoveXY ( unit , x , y ) ;
96324: LD_VAR 0 1
96328: PPUSH
96329: LD_VAR 0 2
96333: PPUSH
96334: LD_VAR 0 3
96338: PPUSH
96339: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
96343: LD_INT 35
96345: PPUSH
96346: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
96350: LD_VAR 0 1
96354: PPUSH
96355: LD_VAR 0 2
96359: PPUSH
96360: LD_VAR 0 3
96364: PPUSH
96365: CALL 48397 0 3
96369: NOT
96370: PUSH
96371: LD_VAR 0 1
96375: PPUSH
96376: CALL_OW 314
96380: AND
96381: IFFALSE 96385
// exit ;
96383: GO 96524
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
96385: LD_VAR 0 2
96389: PPUSH
96390: LD_VAR 0 3
96394: PPUSH
96395: CALL_OW 428
96399: PUSH
96400: LD_VAR 0 1
96404: EQUAL
96405: PUSH
96406: LD_VAR 0 1
96410: PPUSH
96411: CALL_OW 314
96415: NOT
96416: AND
96417: IFFALSE 96343
// PlaySoundXY ( x , y , PlantMine ) ;
96419: LD_VAR 0 2
96423: PPUSH
96424: LD_VAR 0 3
96428: PPUSH
96429: LD_STRING PlantMine
96431: PPUSH
96432: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
96436: LD_VAR 0 2
96440: PPUSH
96441: LD_VAR 0 3
96445: PPUSH
96446: LD_VAR 0 1
96450: PPUSH
96451: CALL_OW 255
96455: PPUSH
96456: LD_INT 0
96458: PPUSH
96459: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
96463: LD_ADDR_EXP 172
96467: PUSH
96468: LD_EXP 172
96472: PPUSH
96473: LD_VAR 0 5
96477: PUSH
96478: LD_EXP 172
96482: PUSH
96483: LD_VAR 0 5
96487: ARRAY
96488: PUSH
96489: LD_INT 1
96491: PLUS
96492: PUSH
96493: EMPTY
96494: LIST
96495: LIST
96496: PPUSH
96497: LD_VAR 0 2
96501: PUSH
96502: LD_VAR 0 3
96506: PUSH
96507: EMPTY
96508: LIST
96509: LIST
96510: PPUSH
96511: CALL 18548 0 3
96515: ST_TO_ADDR
// result := true ;
96516: LD_ADDR_VAR 0 4
96520: PUSH
96521: LD_INT 1
96523: ST_TO_ADDR
// end ;
96524: LD_VAR 0 4
96528: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
96529: LD_INT 0
96531: PPUSH
96532: PPUSH
96533: PPUSH
// if not unit in minersList then
96534: LD_VAR 0 1
96538: PUSH
96539: LD_EXP 171
96543: IN
96544: NOT
96545: IFFALSE 96549
// exit ;
96547: GO 96941
// index := GetElementIndex ( minersList , unit ) ;
96549: LD_ADDR_VAR 0 6
96553: PUSH
96554: LD_EXP 171
96558: PPUSH
96559: LD_VAR 0 1
96563: PPUSH
96564: CALL 18333 0 2
96568: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
96569: LD_ADDR_VAR 0 5
96573: PUSH
96574: DOUBLE
96575: LD_EXP 172
96579: PUSH
96580: LD_VAR 0 6
96584: ARRAY
96585: INC
96586: ST_TO_ADDR
96587: LD_INT 1
96589: PUSH
96590: FOR_DOWNTO
96591: IFFALSE 96752
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
96593: LD_EXP 172
96597: PUSH
96598: LD_VAR 0 6
96602: ARRAY
96603: PUSH
96604: LD_VAR 0 5
96608: ARRAY
96609: PUSH
96610: LD_INT 1
96612: ARRAY
96613: PUSH
96614: LD_VAR 0 2
96618: EQUAL
96619: PUSH
96620: LD_EXP 172
96624: PUSH
96625: LD_VAR 0 6
96629: ARRAY
96630: PUSH
96631: LD_VAR 0 5
96635: ARRAY
96636: PUSH
96637: LD_INT 2
96639: ARRAY
96640: PUSH
96641: LD_VAR 0 3
96645: EQUAL
96646: AND
96647: IFFALSE 96750
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
96649: LD_EXP 172
96653: PUSH
96654: LD_VAR 0 6
96658: ARRAY
96659: PUSH
96660: LD_VAR 0 5
96664: ARRAY
96665: PUSH
96666: LD_INT 1
96668: ARRAY
96669: PPUSH
96670: LD_EXP 172
96674: PUSH
96675: LD_VAR 0 6
96679: ARRAY
96680: PUSH
96681: LD_VAR 0 5
96685: ARRAY
96686: PUSH
96687: LD_INT 2
96689: ARRAY
96690: PPUSH
96691: LD_VAR 0 1
96695: PPUSH
96696: CALL_OW 255
96700: PPUSH
96701: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
96705: LD_ADDR_EXP 172
96709: PUSH
96710: LD_EXP 172
96714: PPUSH
96715: LD_VAR 0 6
96719: PPUSH
96720: LD_EXP 172
96724: PUSH
96725: LD_VAR 0 6
96729: ARRAY
96730: PPUSH
96731: LD_VAR 0 5
96735: PPUSH
96736: CALL_OW 3
96740: PPUSH
96741: CALL_OW 1
96745: ST_TO_ADDR
// exit ;
96746: POP
96747: POP
96748: GO 96941
// end ; end ;
96750: GO 96590
96752: POP
96753: POP
// for i := minerMinesList [ index ] downto 1 do
96754: LD_ADDR_VAR 0 5
96758: PUSH
96759: DOUBLE
96760: LD_EXP 172
96764: PUSH
96765: LD_VAR 0 6
96769: ARRAY
96770: INC
96771: ST_TO_ADDR
96772: LD_INT 1
96774: PUSH
96775: FOR_DOWNTO
96776: IFFALSE 96939
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
96778: LD_EXP 172
96782: PUSH
96783: LD_VAR 0 6
96787: ARRAY
96788: PUSH
96789: LD_VAR 0 5
96793: ARRAY
96794: PUSH
96795: LD_INT 1
96797: ARRAY
96798: PPUSH
96799: LD_EXP 172
96803: PUSH
96804: LD_VAR 0 6
96808: ARRAY
96809: PUSH
96810: LD_VAR 0 5
96814: ARRAY
96815: PUSH
96816: LD_INT 2
96818: ARRAY
96819: PPUSH
96820: LD_VAR 0 2
96824: PPUSH
96825: LD_VAR 0 3
96829: PPUSH
96830: CALL_OW 298
96834: PUSH
96835: LD_INT 6
96837: LESS
96838: IFFALSE 96937
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
96840: LD_EXP 172
96844: PUSH
96845: LD_VAR 0 6
96849: ARRAY
96850: PUSH
96851: LD_VAR 0 5
96855: ARRAY
96856: PUSH
96857: LD_INT 1
96859: ARRAY
96860: PPUSH
96861: LD_EXP 172
96865: PUSH
96866: LD_VAR 0 6
96870: ARRAY
96871: PUSH
96872: LD_VAR 0 5
96876: ARRAY
96877: PUSH
96878: LD_INT 2
96880: ARRAY
96881: PPUSH
96882: LD_VAR 0 1
96886: PPUSH
96887: CALL_OW 255
96891: PPUSH
96892: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
96896: LD_ADDR_EXP 172
96900: PUSH
96901: LD_EXP 172
96905: PPUSH
96906: LD_VAR 0 6
96910: PPUSH
96911: LD_EXP 172
96915: PUSH
96916: LD_VAR 0 6
96920: ARRAY
96921: PPUSH
96922: LD_VAR 0 5
96926: PPUSH
96927: CALL_OW 3
96931: PPUSH
96932: CALL_OW 1
96936: ST_TO_ADDR
// end ; end ;
96937: GO 96775
96939: POP
96940: POP
// end ;
96941: LD_VAR 0 4
96945: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
96946: LD_INT 0
96948: PPUSH
96949: PPUSH
96950: PPUSH
96951: PPUSH
96952: PPUSH
96953: PPUSH
96954: PPUSH
96955: PPUSH
96956: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
96957: LD_VAR 0 1
96961: PPUSH
96962: CALL_OW 264
96966: PUSH
96967: LD_EXP 55
96971: EQUAL
96972: NOT
96973: PUSH
96974: LD_VAR 0 1
96978: PUSH
96979: LD_EXP 171
96983: IN
96984: NOT
96985: OR
96986: IFFALSE 96990
// exit ;
96988: GO 97312
// index := GetElementIndex ( minersList , unit ) ;
96990: LD_ADDR_VAR 0 6
96994: PUSH
96995: LD_EXP 171
96999: PPUSH
97000: LD_VAR 0 1
97004: PPUSH
97005: CALL 18333 0 2
97009: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
97010: LD_ADDR_VAR 0 8
97014: PUSH
97015: LD_EXP 173
97019: PUSH
97020: LD_EXP 172
97024: PUSH
97025: LD_VAR 0 6
97029: ARRAY
97030: MINUS
97031: ST_TO_ADDR
// if not minesFreeAmount then
97032: LD_VAR 0 8
97036: NOT
97037: IFFALSE 97041
// exit ;
97039: GO 97312
// tmp := [ ] ;
97041: LD_ADDR_VAR 0 7
97045: PUSH
97046: EMPTY
97047: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
97048: LD_ADDR_VAR 0 5
97052: PUSH
97053: DOUBLE
97054: LD_INT 1
97056: DEC
97057: ST_TO_ADDR
97058: LD_VAR 0 8
97062: PUSH
97063: FOR_TO
97064: IFFALSE 97259
// begin _d := rand ( 0 , 5 ) ;
97066: LD_ADDR_VAR 0 11
97070: PUSH
97071: LD_INT 0
97073: PPUSH
97074: LD_INT 5
97076: PPUSH
97077: CALL_OW 12
97081: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
97082: LD_ADDR_VAR 0 12
97086: PUSH
97087: LD_INT 2
97089: PPUSH
97090: LD_INT 6
97092: PPUSH
97093: CALL_OW 12
97097: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
97098: LD_ADDR_VAR 0 9
97102: PUSH
97103: LD_VAR 0 2
97107: PPUSH
97108: LD_VAR 0 11
97112: PPUSH
97113: LD_VAR 0 12
97117: PPUSH
97118: CALL_OW 272
97122: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
97123: LD_ADDR_VAR 0 10
97127: PUSH
97128: LD_VAR 0 3
97132: PPUSH
97133: LD_VAR 0 11
97137: PPUSH
97138: LD_VAR 0 12
97142: PPUSH
97143: CALL_OW 273
97147: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
97148: LD_VAR 0 9
97152: PPUSH
97153: LD_VAR 0 10
97157: PPUSH
97158: CALL_OW 488
97162: PUSH
97163: LD_VAR 0 9
97167: PUSH
97168: LD_VAR 0 10
97172: PUSH
97173: EMPTY
97174: LIST
97175: LIST
97176: PUSH
97177: LD_VAR 0 7
97181: IN
97182: NOT
97183: AND
97184: PUSH
97185: LD_VAR 0 9
97189: PPUSH
97190: LD_VAR 0 10
97194: PPUSH
97195: CALL_OW 458
97199: NOT
97200: AND
97201: IFFALSE 97243
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
97203: LD_ADDR_VAR 0 7
97207: PUSH
97208: LD_VAR 0 7
97212: PPUSH
97213: LD_VAR 0 7
97217: PUSH
97218: LD_INT 1
97220: PLUS
97221: PPUSH
97222: LD_VAR 0 9
97226: PUSH
97227: LD_VAR 0 10
97231: PUSH
97232: EMPTY
97233: LIST
97234: LIST
97235: PPUSH
97236: CALL_OW 1
97240: ST_TO_ADDR
97241: GO 97257
// i := i - 1 ;
97243: LD_ADDR_VAR 0 5
97247: PUSH
97248: LD_VAR 0 5
97252: PUSH
97253: LD_INT 1
97255: MINUS
97256: ST_TO_ADDR
// end ;
97257: GO 97063
97259: POP
97260: POP
// for i in tmp do
97261: LD_ADDR_VAR 0 5
97265: PUSH
97266: LD_VAR 0 7
97270: PUSH
97271: FOR_IN
97272: IFFALSE 97310
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
97274: LD_VAR 0 1
97278: PPUSH
97279: LD_VAR 0 5
97283: PUSH
97284: LD_INT 1
97286: ARRAY
97287: PPUSH
97288: LD_VAR 0 5
97292: PUSH
97293: LD_INT 2
97295: ARRAY
97296: PPUSH
97297: CALL 96252 0 3
97301: NOT
97302: IFFALSE 97308
// exit ;
97304: POP
97305: POP
97306: GO 97312
97308: GO 97271
97310: POP
97311: POP
// end ;
97312: LD_VAR 0 4
97316: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
97317: LD_INT 0
97319: PPUSH
97320: PPUSH
97321: PPUSH
97322: PPUSH
97323: PPUSH
97324: PPUSH
97325: PPUSH
// if not GetClass ( unit ) = class_sniper then
97326: LD_VAR 0 1
97330: PPUSH
97331: CALL_OW 257
97335: PUSH
97336: LD_INT 5
97338: EQUAL
97339: NOT
97340: IFFALSE 97344
// exit ;
97342: GO 97732
// dist := 8 ;
97344: LD_ADDR_VAR 0 5
97348: PUSH
97349: LD_INT 8
97351: ST_TO_ADDR
// viewRange := 12 ;
97352: LD_ADDR_VAR 0 7
97356: PUSH
97357: LD_INT 12
97359: ST_TO_ADDR
// side := GetSide ( unit ) ;
97360: LD_ADDR_VAR 0 6
97364: PUSH
97365: LD_VAR 0 1
97369: PPUSH
97370: CALL_OW 255
97374: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
97375: LD_INT 61
97377: PPUSH
97378: LD_VAR 0 6
97382: PPUSH
97383: CALL_OW 321
97387: PUSH
97388: LD_INT 2
97390: EQUAL
97391: IFFALSE 97401
// viewRange := 16 ;
97393: LD_ADDR_VAR 0 7
97397: PUSH
97398: LD_INT 16
97400: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
97401: LD_VAR 0 1
97405: PPUSH
97406: LD_VAR 0 2
97410: PPUSH
97411: LD_VAR 0 3
97415: PPUSH
97416: CALL_OW 297
97420: PUSH
97421: LD_VAR 0 5
97425: GREATER
97426: IFFALSE 97505
// begin ComMoveXY ( unit , x , y ) ;
97428: LD_VAR 0 1
97432: PPUSH
97433: LD_VAR 0 2
97437: PPUSH
97438: LD_VAR 0 3
97442: PPUSH
97443: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
97447: LD_INT 35
97449: PPUSH
97450: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
97454: LD_VAR 0 1
97458: PPUSH
97459: LD_VAR 0 2
97463: PPUSH
97464: LD_VAR 0 3
97468: PPUSH
97469: CALL 48397 0 3
97473: NOT
97474: IFFALSE 97478
// exit ;
97476: GO 97732
// until GetDistUnitXY ( unit , x , y ) < dist ;
97478: LD_VAR 0 1
97482: PPUSH
97483: LD_VAR 0 2
97487: PPUSH
97488: LD_VAR 0 3
97492: PPUSH
97493: CALL_OW 297
97497: PUSH
97498: LD_VAR 0 5
97502: LESS
97503: IFFALSE 97447
// end ; ComTurnXY ( unit , x , y ) ;
97505: LD_VAR 0 1
97509: PPUSH
97510: LD_VAR 0 2
97514: PPUSH
97515: LD_VAR 0 3
97519: PPUSH
97520: CALL_OW 118
// wait ( 5 ) ;
97524: LD_INT 5
97526: PPUSH
97527: CALL_OW 67
// _d := GetDir ( unit ) ;
97531: LD_ADDR_VAR 0 10
97535: PUSH
97536: LD_VAR 0 1
97540: PPUSH
97541: CALL_OW 254
97545: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
97546: LD_ADDR_VAR 0 8
97550: PUSH
97551: LD_VAR 0 1
97555: PPUSH
97556: CALL_OW 250
97560: PPUSH
97561: LD_VAR 0 10
97565: PPUSH
97566: LD_VAR 0 5
97570: PPUSH
97571: CALL_OW 272
97575: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
97576: LD_ADDR_VAR 0 9
97580: PUSH
97581: LD_VAR 0 1
97585: PPUSH
97586: CALL_OW 251
97590: PPUSH
97591: LD_VAR 0 10
97595: PPUSH
97596: LD_VAR 0 5
97600: PPUSH
97601: CALL_OW 273
97605: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
97606: LD_VAR 0 8
97610: PPUSH
97611: LD_VAR 0 9
97615: PPUSH
97616: CALL_OW 488
97620: NOT
97621: IFFALSE 97625
// exit ;
97623: GO 97732
// ComAnimCustom ( unit , 1 ) ;
97625: LD_VAR 0 1
97629: PPUSH
97630: LD_INT 1
97632: PPUSH
97633: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
97637: LD_VAR 0 8
97641: PPUSH
97642: LD_VAR 0 9
97646: PPUSH
97647: LD_VAR 0 6
97651: PPUSH
97652: LD_VAR 0 7
97656: PPUSH
97657: CALL_OW 330
// repeat wait ( 1 ) ;
97661: LD_INT 1
97663: PPUSH
97664: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
97668: LD_VAR 0 1
97672: PPUSH
97673: CALL_OW 316
97677: PUSH
97678: LD_VAR 0 1
97682: PPUSH
97683: CALL_OW 314
97687: OR
97688: PUSH
97689: LD_VAR 0 1
97693: PPUSH
97694: CALL_OW 302
97698: NOT
97699: OR
97700: PUSH
97701: LD_VAR 0 1
97705: PPUSH
97706: CALL_OW 301
97710: OR
97711: IFFALSE 97661
// RemoveSeeing ( _x , _y , side ) ;
97713: LD_VAR 0 8
97717: PPUSH
97718: LD_VAR 0 9
97722: PPUSH
97723: LD_VAR 0 6
97727: PPUSH
97728: CALL_OW 331
// end ; end_of_file
97732: LD_VAR 0 4
97736: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
97737: LD_INT 0
97739: PPUSH
97740: PPUSH
97741: PPUSH
97742: PPUSH
97743: PPUSH
97744: PPUSH
97745: PPUSH
97746: PPUSH
97747: PPUSH
97748: PPUSH
97749: PPUSH
97750: PPUSH
97751: PPUSH
97752: PPUSH
97753: PPUSH
97754: PPUSH
97755: PPUSH
97756: PPUSH
97757: PPUSH
97758: PPUSH
97759: PPUSH
97760: PPUSH
97761: PPUSH
97762: PPUSH
97763: PPUSH
97764: PPUSH
97765: PPUSH
97766: PPUSH
97767: PPUSH
97768: PPUSH
97769: PPUSH
97770: PPUSH
97771: PPUSH
97772: PPUSH
// if not list then
97773: LD_VAR 0 1
97777: NOT
97778: IFFALSE 97782
// exit ;
97780: GO 102441
// base := list [ 1 ] ;
97782: LD_ADDR_VAR 0 3
97786: PUSH
97787: LD_VAR 0 1
97791: PUSH
97792: LD_INT 1
97794: ARRAY
97795: ST_TO_ADDR
// group := list [ 2 ] ;
97796: LD_ADDR_VAR 0 4
97800: PUSH
97801: LD_VAR 0 1
97805: PUSH
97806: LD_INT 2
97808: ARRAY
97809: ST_TO_ADDR
// path := list [ 3 ] ;
97810: LD_ADDR_VAR 0 5
97814: PUSH
97815: LD_VAR 0 1
97819: PUSH
97820: LD_INT 3
97822: ARRAY
97823: ST_TO_ADDR
// flags := list [ 4 ] ;
97824: LD_ADDR_VAR 0 6
97828: PUSH
97829: LD_VAR 0 1
97833: PUSH
97834: LD_INT 4
97836: ARRAY
97837: ST_TO_ADDR
// mined := [ ] ;
97838: LD_ADDR_VAR 0 27
97842: PUSH
97843: EMPTY
97844: ST_TO_ADDR
// bombed := [ ] ;
97845: LD_ADDR_VAR 0 28
97849: PUSH
97850: EMPTY
97851: ST_TO_ADDR
// healers := [ ] ;
97852: LD_ADDR_VAR 0 31
97856: PUSH
97857: EMPTY
97858: ST_TO_ADDR
// to_heal := [ ] ;
97859: LD_ADDR_VAR 0 30
97863: PUSH
97864: EMPTY
97865: ST_TO_ADDR
// repairs := [ ] ;
97866: LD_ADDR_VAR 0 33
97870: PUSH
97871: EMPTY
97872: ST_TO_ADDR
// to_repair := [ ] ;
97873: LD_ADDR_VAR 0 32
97877: PUSH
97878: EMPTY
97879: ST_TO_ADDR
// if not group or not path then
97880: LD_VAR 0 4
97884: NOT
97885: PUSH
97886: LD_VAR 0 5
97890: NOT
97891: OR
97892: IFFALSE 97896
// exit ;
97894: GO 102441
// side := GetSide ( group [ 1 ] ) ;
97896: LD_ADDR_VAR 0 35
97900: PUSH
97901: LD_VAR 0 4
97905: PUSH
97906: LD_INT 1
97908: ARRAY
97909: PPUSH
97910: CALL_OW 255
97914: ST_TO_ADDR
// if flags then
97915: LD_VAR 0 6
97919: IFFALSE 98063
// begin f_ignore_area := flags [ 1 ] ;
97921: LD_ADDR_VAR 0 17
97925: PUSH
97926: LD_VAR 0 6
97930: PUSH
97931: LD_INT 1
97933: ARRAY
97934: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
97935: LD_ADDR_VAR 0 18
97939: PUSH
97940: LD_VAR 0 6
97944: PUSH
97945: LD_INT 2
97947: ARRAY
97948: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
97949: LD_ADDR_VAR 0 19
97953: PUSH
97954: LD_VAR 0 6
97958: PUSH
97959: LD_INT 3
97961: ARRAY
97962: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
97963: LD_ADDR_VAR 0 20
97967: PUSH
97968: LD_VAR 0 6
97972: PUSH
97973: LD_INT 4
97975: ARRAY
97976: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
97977: LD_ADDR_VAR 0 21
97981: PUSH
97982: LD_VAR 0 6
97986: PUSH
97987: LD_INT 5
97989: ARRAY
97990: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
97991: LD_ADDR_VAR 0 22
97995: PUSH
97996: LD_VAR 0 6
98000: PUSH
98001: LD_INT 6
98003: ARRAY
98004: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
98005: LD_ADDR_VAR 0 23
98009: PUSH
98010: LD_VAR 0 6
98014: PUSH
98015: LD_INT 7
98017: ARRAY
98018: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
98019: LD_ADDR_VAR 0 24
98023: PUSH
98024: LD_VAR 0 6
98028: PUSH
98029: LD_INT 8
98031: ARRAY
98032: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
98033: LD_ADDR_VAR 0 25
98037: PUSH
98038: LD_VAR 0 6
98042: PUSH
98043: LD_INT 9
98045: ARRAY
98046: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
98047: LD_ADDR_VAR 0 26
98051: PUSH
98052: LD_VAR 0 6
98056: PUSH
98057: LD_INT 10
98059: ARRAY
98060: ST_TO_ADDR
// end else
98061: GO 98143
// begin f_ignore_area := false ;
98063: LD_ADDR_VAR 0 17
98067: PUSH
98068: LD_INT 0
98070: ST_TO_ADDR
// f_capture := false ;
98071: LD_ADDR_VAR 0 18
98075: PUSH
98076: LD_INT 0
98078: ST_TO_ADDR
// f_ignore_civ := false ;
98079: LD_ADDR_VAR 0 19
98083: PUSH
98084: LD_INT 0
98086: ST_TO_ADDR
// f_murder := false ;
98087: LD_ADDR_VAR 0 20
98091: PUSH
98092: LD_INT 0
98094: ST_TO_ADDR
// f_mines := false ;
98095: LD_ADDR_VAR 0 21
98099: PUSH
98100: LD_INT 0
98102: ST_TO_ADDR
// f_repair := false ;
98103: LD_ADDR_VAR 0 22
98107: PUSH
98108: LD_INT 0
98110: ST_TO_ADDR
// f_heal := false ;
98111: LD_ADDR_VAR 0 23
98115: PUSH
98116: LD_INT 0
98118: ST_TO_ADDR
// f_spacetime := false ;
98119: LD_ADDR_VAR 0 24
98123: PUSH
98124: LD_INT 0
98126: ST_TO_ADDR
// f_attack_depot := false ;
98127: LD_ADDR_VAR 0 25
98131: PUSH
98132: LD_INT 0
98134: ST_TO_ADDR
// f_crawl := false ;
98135: LD_ADDR_VAR 0 26
98139: PUSH
98140: LD_INT 0
98142: ST_TO_ADDR
// end ; if f_heal then
98143: LD_VAR 0 23
98147: IFFALSE 98174
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
98149: LD_ADDR_VAR 0 31
98153: PUSH
98154: LD_VAR 0 4
98158: PPUSH
98159: LD_INT 25
98161: PUSH
98162: LD_INT 4
98164: PUSH
98165: EMPTY
98166: LIST
98167: LIST
98168: PPUSH
98169: CALL_OW 72
98173: ST_TO_ADDR
// if f_repair then
98174: LD_VAR 0 22
98178: IFFALSE 98205
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
98180: LD_ADDR_VAR 0 33
98184: PUSH
98185: LD_VAR 0 4
98189: PPUSH
98190: LD_INT 25
98192: PUSH
98193: LD_INT 3
98195: PUSH
98196: EMPTY
98197: LIST
98198: LIST
98199: PPUSH
98200: CALL_OW 72
98204: ST_TO_ADDR
// units_path := [ ] ;
98205: LD_ADDR_VAR 0 16
98209: PUSH
98210: EMPTY
98211: ST_TO_ADDR
// for i = 1 to group do
98212: LD_ADDR_VAR 0 7
98216: PUSH
98217: DOUBLE
98218: LD_INT 1
98220: DEC
98221: ST_TO_ADDR
98222: LD_VAR 0 4
98226: PUSH
98227: FOR_TO
98228: IFFALSE 98257
// units_path := Replace ( units_path , i , path ) ;
98230: LD_ADDR_VAR 0 16
98234: PUSH
98235: LD_VAR 0 16
98239: PPUSH
98240: LD_VAR 0 7
98244: PPUSH
98245: LD_VAR 0 5
98249: PPUSH
98250: CALL_OW 1
98254: ST_TO_ADDR
98255: GO 98227
98257: POP
98258: POP
// repeat for i = group downto 1 do
98259: LD_ADDR_VAR 0 7
98263: PUSH
98264: DOUBLE
98265: LD_VAR 0 4
98269: INC
98270: ST_TO_ADDR
98271: LD_INT 1
98273: PUSH
98274: FOR_DOWNTO
98275: IFFALSE 102397
// begin wait ( 5 ) ;
98277: LD_INT 5
98279: PPUSH
98280: CALL_OW 67
// tmp := [ ] ;
98284: LD_ADDR_VAR 0 14
98288: PUSH
98289: EMPTY
98290: ST_TO_ADDR
// attacking := false ;
98291: LD_ADDR_VAR 0 29
98295: PUSH
98296: LD_INT 0
98298: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
98299: LD_VAR 0 4
98303: PUSH
98304: LD_VAR 0 7
98308: ARRAY
98309: PPUSH
98310: CALL_OW 301
98314: PUSH
98315: LD_VAR 0 4
98319: PUSH
98320: LD_VAR 0 7
98324: ARRAY
98325: NOT
98326: OR
98327: IFFALSE 98436
// begin if GetType ( group [ i ] ) = unit_human then
98329: LD_VAR 0 4
98333: PUSH
98334: LD_VAR 0 7
98338: ARRAY
98339: PPUSH
98340: CALL_OW 247
98344: PUSH
98345: LD_INT 1
98347: EQUAL
98348: IFFALSE 98394
// begin to_heal := to_heal diff group [ i ] ;
98350: LD_ADDR_VAR 0 30
98354: PUSH
98355: LD_VAR 0 30
98359: PUSH
98360: LD_VAR 0 4
98364: PUSH
98365: LD_VAR 0 7
98369: ARRAY
98370: DIFF
98371: ST_TO_ADDR
// healers := healers diff group [ i ] ;
98372: LD_ADDR_VAR 0 31
98376: PUSH
98377: LD_VAR 0 31
98381: PUSH
98382: LD_VAR 0 4
98386: PUSH
98387: LD_VAR 0 7
98391: ARRAY
98392: DIFF
98393: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
98394: LD_ADDR_VAR 0 4
98398: PUSH
98399: LD_VAR 0 4
98403: PPUSH
98404: LD_VAR 0 7
98408: PPUSH
98409: CALL_OW 3
98413: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
98414: LD_ADDR_VAR 0 16
98418: PUSH
98419: LD_VAR 0 16
98423: PPUSH
98424: LD_VAR 0 7
98428: PPUSH
98429: CALL_OW 3
98433: ST_TO_ADDR
// continue ;
98434: GO 98274
// end ; if f_repair then
98436: LD_VAR 0 22
98440: IFFALSE 98929
// begin if GetType ( group [ i ] ) = unit_vehicle then
98442: LD_VAR 0 4
98446: PUSH
98447: LD_VAR 0 7
98451: ARRAY
98452: PPUSH
98453: CALL_OW 247
98457: PUSH
98458: LD_INT 2
98460: EQUAL
98461: IFFALSE 98651
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
98463: LD_VAR 0 4
98467: PUSH
98468: LD_VAR 0 7
98472: ARRAY
98473: PPUSH
98474: CALL_OW 256
98478: PUSH
98479: LD_INT 700
98481: LESS
98482: PUSH
98483: LD_VAR 0 4
98487: PUSH
98488: LD_VAR 0 7
98492: ARRAY
98493: PUSH
98494: LD_VAR 0 32
98498: IN
98499: NOT
98500: AND
98501: IFFALSE 98525
// to_repair := to_repair union group [ i ] ;
98503: LD_ADDR_VAR 0 32
98507: PUSH
98508: LD_VAR 0 32
98512: PUSH
98513: LD_VAR 0 4
98517: PUSH
98518: LD_VAR 0 7
98522: ARRAY
98523: UNION
98524: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
98525: LD_VAR 0 4
98529: PUSH
98530: LD_VAR 0 7
98534: ARRAY
98535: PPUSH
98536: CALL_OW 256
98540: PUSH
98541: LD_INT 1000
98543: EQUAL
98544: PUSH
98545: LD_VAR 0 4
98549: PUSH
98550: LD_VAR 0 7
98554: ARRAY
98555: PUSH
98556: LD_VAR 0 32
98560: IN
98561: AND
98562: IFFALSE 98586
// to_repair := to_repair diff group [ i ] ;
98564: LD_ADDR_VAR 0 32
98568: PUSH
98569: LD_VAR 0 32
98573: PUSH
98574: LD_VAR 0 4
98578: PUSH
98579: LD_VAR 0 7
98583: ARRAY
98584: DIFF
98585: ST_TO_ADDR
// if group [ i ] in to_repair then
98586: LD_VAR 0 4
98590: PUSH
98591: LD_VAR 0 7
98595: ARRAY
98596: PUSH
98597: LD_VAR 0 32
98601: IN
98602: IFFALSE 98649
// begin if not IsInArea ( group [ i ] , f_repair ) then
98604: LD_VAR 0 4
98608: PUSH
98609: LD_VAR 0 7
98613: ARRAY
98614: PPUSH
98615: LD_VAR 0 22
98619: PPUSH
98620: CALL_OW 308
98624: NOT
98625: IFFALSE 98647
// ComMoveToArea ( group [ i ] , f_repair ) ;
98627: LD_VAR 0 4
98631: PUSH
98632: LD_VAR 0 7
98636: ARRAY
98637: PPUSH
98638: LD_VAR 0 22
98642: PPUSH
98643: CALL_OW 113
// continue ;
98647: GO 98274
// end ; end else
98649: GO 98929
// if group [ i ] in repairs then
98651: LD_VAR 0 4
98655: PUSH
98656: LD_VAR 0 7
98660: ARRAY
98661: PUSH
98662: LD_VAR 0 33
98666: IN
98667: IFFALSE 98929
// begin if IsInUnit ( group [ i ] ) then
98669: LD_VAR 0 4
98673: PUSH
98674: LD_VAR 0 7
98678: ARRAY
98679: PPUSH
98680: CALL_OW 310
98684: IFFALSE 98752
// begin z := IsInUnit ( group [ i ] ) ;
98686: LD_ADDR_VAR 0 13
98690: PUSH
98691: LD_VAR 0 4
98695: PUSH
98696: LD_VAR 0 7
98700: ARRAY
98701: PPUSH
98702: CALL_OW 310
98706: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
98707: LD_VAR 0 13
98711: PUSH
98712: LD_VAR 0 32
98716: IN
98717: PUSH
98718: LD_VAR 0 13
98722: PPUSH
98723: LD_VAR 0 22
98727: PPUSH
98728: CALL_OW 308
98732: AND
98733: IFFALSE 98750
// ComExitVehicle ( group [ i ] ) ;
98735: LD_VAR 0 4
98739: PUSH
98740: LD_VAR 0 7
98744: ARRAY
98745: PPUSH
98746: CALL_OW 121
// end else
98750: GO 98929
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
98752: LD_ADDR_VAR 0 13
98756: PUSH
98757: LD_VAR 0 4
98761: PPUSH
98762: LD_INT 95
98764: PUSH
98765: LD_VAR 0 22
98769: PUSH
98770: EMPTY
98771: LIST
98772: LIST
98773: PUSH
98774: LD_INT 58
98776: PUSH
98777: EMPTY
98778: LIST
98779: PUSH
98780: EMPTY
98781: LIST
98782: LIST
98783: PPUSH
98784: CALL_OW 72
98788: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
98789: LD_VAR 0 4
98793: PUSH
98794: LD_VAR 0 7
98798: ARRAY
98799: PPUSH
98800: CALL_OW 314
98804: NOT
98805: IFFALSE 98927
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
98807: LD_ADDR_VAR 0 10
98811: PUSH
98812: LD_VAR 0 13
98816: PPUSH
98817: LD_VAR 0 4
98821: PUSH
98822: LD_VAR 0 7
98826: ARRAY
98827: PPUSH
98828: CALL_OW 74
98832: ST_TO_ADDR
// if not x then
98833: LD_VAR 0 10
98837: NOT
98838: IFFALSE 98842
// continue ;
98840: GO 98274
// if GetLives ( x ) < 1000 then
98842: LD_VAR 0 10
98846: PPUSH
98847: CALL_OW 256
98851: PUSH
98852: LD_INT 1000
98854: LESS
98855: IFFALSE 98879
// ComRepairVehicle ( group [ i ] , x ) else
98857: LD_VAR 0 4
98861: PUSH
98862: LD_VAR 0 7
98866: ARRAY
98867: PPUSH
98868: LD_VAR 0 10
98872: PPUSH
98873: CALL_OW 129
98877: GO 98927
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
98879: LD_VAR 0 23
98883: PUSH
98884: LD_VAR 0 4
98888: PUSH
98889: LD_VAR 0 7
98893: ARRAY
98894: PPUSH
98895: CALL_OW 256
98899: PUSH
98900: LD_INT 1000
98902: LESS
98903: AND
98904: NOT
98905: IFFALSE 98927
// ComEnterUnit ( group [ i ] , x ) ;
98907: LD_VAR 0 4
98911: PUSH
98912: LD_VAR 0 7
98916: ARRAY
98917: PPUSH
98918: LD_VAR 0 10
98922: PPUSH
98923: CALL_OW 120
// end ; continue ;
98927: GO 98274
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
98929: LD_VAR 0 23
98933: PUSH
98934: LD_VAR 0 4
98938: PUSH
98939: LD_VAR 0 7
98943: ARRAY
98944: PPUSH
98945: CALL_OW 247
98949: PUSH
98950: LD_INT 1
98952: EQUAL
98953: AND
98954: IFFALSE 99432
// begin if group [ i ] in healers then
98956: LD_VAR 0 4
98960: PUSH
98961: LD_VAR 0 7
98965: ARRAY
98966: PUSH
98967: LD_VAR 0 31
98971: IN
98972: IFFALSE 99245
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
98974: LD_VAR 0 4
98978: PUSH
98979: LD_VAR 0 7
98983: ARRAY
98984: PPUSH
98985: LD_VAR 0 23
98989: PPUSH
98990: CALL_OW 308
98994: NOT
98995: PUSH
98996: LD_VAR 0 4
99000: PUSH
99001: LD_VAR 0 7
99005: ARRAY
99006: PPUSH
99007: CALL_OW 314
99011: NOT
99012: AND
99013: IFFALSE 99037
// ComMoveToArea ( group [ i ] , f_heal ) else
99015: LD_VAR 0 4
99019: PUSH
99020: LD_VAR 0 7
99024: ARRAY
99025: PPUSH
99026: LD_VAR 0 23
99030: PPUSH
99031: CALL_OW 113
99035: GO 99243
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
99037: LD_VAR 0 4
99041: PUSH
99042: LD_VAR 0 7
99046: ARRAY
99047: PPUSH
99048: CALL 46920 0 1
99052: PPUSH
99053: CALL_OW 256
99057: PUSH
99058: LD_INT 1000
99060: EQUAL
99061: IFFALSE 99080
// ComStop ( group [ i ] ) else
99063: LD_VAR 0 4
99067: PUSH
99068: LD_VAR 0 7
99072: ARRAY
99073: PPUSH
99074: CALL_OW 141
99078: GO 99243
// if not HasTask ( group [ i ] ) and to_heal then
99080: LD_VAR 0 4
99084: PUSH
99085: LD_VAR 0 7
99089: ARRAY
99090: PPUSH
99091: CALL_OW 314
99095: NOT
99096: PUSH
99097: LD_VAR 0 30
99101: AND
99102: IFFALSE 99243
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
99104: LD_ADDR_VAR 0 13
99108: PUSH
99109: LD_VAR 0 30
99113: PPUSH
99114: LD_INT 3
99116: PUSH
99117: LD_INT 54
99119: PUSH
99120: EMPTY
99121: LIST
99122: PUSH
99123: EMPTY
99124: LIST
99125: LIST
99126: PPUSH
99127: CALL_OW 72
99131: PPUSH
99132: LD_VAR 0 4
99136: PUSH
99137: LD_VAR 0 7
99141: ARRAY
99142: PPUSH
99143: CALL_OW 74
99147: ST_TO_ADDR
// if z then
99148: LD_VAR 0 13
99152: IFFALSE 99243
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
99154: LD_INT 91
99156: PUSH
99157: LD_VAR 0 13
99161: PUSH
99162: LD_INT 10
99164: PUSH
99165: EMPTY
99166: LIST
99167: LIST
99168: LIST
99169: PUSH
99170: LD_INT 81
99172: PUSH
99173: LD_VAR 0 13
99177: PPUSH
99178: CALL_OW 255
99182: PUSH
99183: EMPTY
99184: LIST
99185: LIST
99186: PUSH
99187: EMPTY
99188: LIST
99189: LIST
99190: PPUSH
99191: CALL_OW 69
99195: PUSH
99196: LD_INT 0
99198: EQUAL
99199: IFFALSE 99223
// ComHeal ( group [ i ] , z ) else
99201: LD_VAR 0 4
99205: PUSH
99206: LD_VAR 0 7
99210: ARRAY
99211: PPUSH
99212: LD_VAR 0 13
99216: PPUSH
99217: CALL_OW 128
99221: GO 99243
// ComMoveToArea ( group [ i ] , f_heal ) ;
99223: LD_VAR 0 4
99227: PUSH
99228: LD_VAR 0 7
99232: ARRAY
99233: PPUSH
99234: LD_VAR 0 23
99238: PPUSH
99239: CALL_OW 113
// end ; continue ;
99243: GO 98274
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
99245: LD_VAR 0 4
99249: PUSH
99250: LD_VAR 0 7
99254: ARRAY
99255: PPUSH
99256: CALL_OW 256
99260: PUSH
99261: LD_INT 700
99263: LESS
99264: PUSH
99265: LD_VAR 0 4
99269: PUSH
99270: LD_VAR 0 7
99274: ARRAY
99275: PUSH
99276: LD_VAR 0 30
99280: IN
99281: NOT
99282: AND
99283: IFFALSE 99307
// to_heal := to_heal union group [ i ] ;
99285: LD_ADDR_VAR 0 30
99289: PUSH
99290: LD_VAR 0 30
99294: PUSH
99295: LD_VAR 0 4
99299: PUSH
99300: LD_VAR 0 7
99304: ARRAY
99305: UNION
99306: ST_TO_ADDR
// if group [ i ] in to_heal then
99307: LD_VAR 0 4
99311: PUSH
99312: LD_VAR 0 7
99316: ARRAY
99317: PUSH
99318: LD_VAR 0 30
99322: IN
99323: IFFALSE 99432
// begin if GetLives ( group [ i ] ) = 1000 then
99325: LD_VAR 0 4
99329: PUSH
99330: LD_VAR 0 7
99334: ARRAY
99335: PPUSH
99336: CALL_OW 256
99340: PUSH
99341: LD_INT 1000
99343: EQUAL
99344: IFFALSE 99370
// to_heal := to_heal diff group [ i ] else
99346: LD_ADDR_VAR 0 30
99350: PUSH
99351: LD_VAR 0 30
99355: PUSH
99356: LD_VAR 0 4
99360: PUSH
99361: LD_VAR 0 7
99365: ARRAY
99366: DIFF
99367: ST_TO_ADDR
99368: GO 99432
// begin if not IsInArea ( group [ i ] , to_heal ) then
99370: LD_VAR 0 4
99374: PUSH
99375: LD_VAR 0 7
99379: ARRAY
99380: PPUSH
99381: LD_VAR 0 30
99385: PPUSH
99386: CALL_OW 308
99390: NOT
99391: IFFALSE 99415
// ComMoveToArea ( group [ i ] , f_heal ) else
99393: LD_VAR 0 4
99397: PUSH
99398: LD_VAR 0 7
99402: ARRAY
99403: PPUSH
99404: LD_VAR 0 23
99408: PPUSH
99409: CALL_OW 113
99413: GO 99430
// ComHold ( group [ i ] ) ;
99415: LD_VAR 0 4
99419: PUSH
99420: LD_VAR 0 7
99424: ARRAY
99425: PPUSH
99426: CALL_OW 140
// continue ;
99430: GO 98274
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
99432: LD_VAR 0 4
99436: PUSH
99437: LD_VAR 0 7
99441: ARRAY
99442: PPUSH
99443: LD_INT 10
99445: PPUSH
99446: CALL 45340 0 2
99450: NOT
99451: PUSH
99452: LD_VAR 0 16
99456: PUSH
99457: LD_VAR 0 7
99461: ARRAY
99462: PUSH
99463: EMPTY
99464: EQUAL
99465: NOT
99466: AND
99467: IFFALSE 99733
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
99469: LD_VAR 0 4
99473: PUSH
99474: LD_VAR 0 7
99478: ARRAY
99479: PPUSH
99480: CALL_OW 262
99484: PUSH
99485: LD_INT 1
99487: PUSH
99488: LD_INT 2
99490: PUSH
99491: EMPTY
99492: LIST
99493: LIST
99494: IN
99495: IFFALSE 99536
// if GetFuel ( group [ i ] ) < 10 then
99497: LD_VAR 0 4
99501: PUSH
99502: LD_VAR 0 7
99506: ARRAY
99507: PPUSH
99508: CALL_OW 261
99512: PUSH
99513: LD_INT 10
99515: LESS
99516: IFFALSE 99536
// SetFuel ( group [ i ] , 12 ) ;
99518: LD_VAR 0 4
99522: PUSH
99523: LD_VAR 0 7
99527: ARRAY
99528: PPUSH
99529: LD_INT 12
99531: PPUSH
99532: CALL_OW 240
// if units_path [ i ] then
99536: LD_VAR 0 16
99540: PUSH
99541: LD_VAR 0 7
99545: ARRAY
99546: IFFALSE 99731
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
99548: LD_VAR 0 4
99552: PUSH
99553: LD_VAR 0 7
99557: ARRAY
99558: PPUSH
99559: LD_VAR 0 16
99563: PUSH
99564: LD_VAR 0 7
99568: ARRAY
99569: PUSH
99570: LD_INT 1
99572: ARRAY
99573: PUSH
99574: LD_INT 1
99576: ARRAY
99577: PPUSH
99578: LD_VAR 0 16
99582: PUSH
99583: LD_VAR 0 7
99587: ARRAY
99588: PUSH
99589: LD_INT 1
99591: ARRAY
99592: PUSH
99593: LD_INT 2
99595: ARRAY
99596: PPUSH
99597: CALL_OW 297
99601: PUSH
99602: LD_INT 6
99604: GREATER
99605: IFFALSE 99680
// begin if not HasTask ( group [ i ] ) then
99607: LD_VAR 0 4
99611: PUSH
99612: LD_VAR 0 7
99616: ARRAY
99617: PPUSH
99618: CALL_OW 314
99622: NOT
99623: IFFALSE 99678
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
99625: LD_VAR 0 4
99629: PUSH
99630: LD_VAR 0 7
99634: ARRAY
99635: PPUSH
99636: LD_VAR 0 16
99640: PUSH
99641: LD_VAR 0 7
99645: ARRAY
99646: PUSH
99647: LD_INT 1
99649: ARRAY
99650: PUSH
99651: LD_INT 1
99653: ARRAY
99654: PPUSH
99655: LD_VAR 0 16
99659: PUSH
99660: LD_VAR 0 7
99664: ARRAY
99665: PUSH
99666: LD_INT 1
99668: ARRAY
99669: PUSH
99670: LD_INT 2
99672: ARRAY
99673: PPUSH
99674: CALL_OW 114
// end else
99678: GO 99731
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
99680: LD_ADDR_VAR 0 15
99684: PUSH
99685: LD_VAR 0 16
99689: PUSH
99690: LD_VAR 0 7
99694: ARRAY
99695: PPUSH
99696: LD_INT 1
99698: PPUSH
99699: CALL_OW 3
99703: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
99704: LD_ADDR_VAR 0 16
99708: PUSH
99709: LD_VAR 0 16
99713: PPUSH
99714: LD_VAR 0 7
99718: PPUSH
99719: LD_VAR 0 15
99723: PPUSH
99724: CALL_OW 1
99728: ST_TO_ADDR
// continue ;
99729: GO 98274
// end ; end ; end else
99731: GO 102395
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
99733: LD_ADDR_VAR 0 14
99737: PUSH
99738: LD_INT 81
99740: PUSH
99741: LD_VAR 0 4
99745: PUSH
99746: LD_VAR 0 7
99750: ARRAY
99751: PPUSH
99752: CALL_OW 255
99756: PUSH
99757: EMPTY
99758: LIST
99759: LIST
99760: PPUSH
99761: CALL_OW 69
99765: ST_TO_ADDR
// if not tmp then
99766: LD_VAR 0 14
99770: NOT
99771: IFFALSE 99775
// continue ;
99773: GO 98274
// if f_ignore_area then
99775: LD_VAR 0 17
99779: IFFALSE 99867
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
99781: LD_ADDR_VAR 0 15
99785: PUSH
99786: LD_VAR 0 14
99790: PPUSH
99791: LD_INT 3
99793: PUSH
99794: LD_INT 92
99796: PUSH
99797: LD_VAR 0 17
99801: PUSH
99802: LD_INT 1
99804: ARRAY
99805: PUSH
99806: LD_VAR 0 17
99810: PUSH
99811: LD_INT 2
99813: ARRAY
99814: PUSH
99815: LD_VAR 0 17
99819: PUSH
99820: LD_INT 3
99822: ARRAY
99823: PUSH
99824: EMPTY
99825: LIST
99826: LIST
99827: LIST
99828: LIST
99829: PUSH
99830: EMPTY
99831: LIST
99832: LIST
99833: PPUSH
99834: CALL_OW 72
99838: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
99839: LD_VAR 0 14
99843: PUSH
99844: LD_VAR 0 15
99848: DIFF
99849: IFFALSE 99867
// tmp := tmp diff tmp2 ;
99851: LD_ADDR_VAR 0 14
99855: PUSH
99856: LD_VAR 0 14
99860: PUSH
99861: LD_VAR 0 15
99865: DIFF
99866: ST_TO_ADDR
// end ; if not f_murder then
99867: LD_VAR 0 20
99871: NOT
99872: IFFALSE 99930
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
99874: LD_ADDR_VAR 0 15
99878: PUSH
99879: LD_VAR 0 14
99883: PPUSH
99884: LD_INT 3
99886: PUSH
99887: LD_INT 50
99889: PUSH
99890: EMPTY
99891: LIST
99892: PUSH
99893: EMPTY
99894: LIST
99895: LIST
99896: PPUSH
99897: CALL_OW 72
99901: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
99902: LD_VAR 0 14
99906: PUSH
99907: LD_VAR 0 15
99911: DIFF
99912: IFFALSE 99930
// tmp := tmp diff tmp2 ;
99914: LD_ADDR_VAR 0 14
99918: PUSH
99919: LD_VAR 0 14
99923: PUSH
99924: LD_VAR 0 15
99928: DIFF
99929: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
99930: LD_ADDR_VAR 0 14
99934: PUSH
99935: LD_VAR 0 4
99939: PUSH
99940: LD_VAR 0 7
99944: ARRAY
99945: PPUSH
99946: LD_VAR 0 14
99950: PPUSH
99951: LD_INT 1
99953: PPUSH
99954: LD_INT 1
99956: PPUSH
99957: CALL 18983 0 4
99961: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
99962: LD_VAR 0 4
99966: PUSH
99967: LD_VAR 0 7
99971: ARRAY
99972: PPUSH
99973: CALL_OW 257
99977: PUSH
99978: LD_INT 1
99980: EQUAL
99981: IFFALSE 100429
// begin if WantPlant ( group [ i ] ) then
99983: LD_VAR 0 4
99987: PUSH
99988: LD_VAR 0 7
99992: ARRAY
99993: PPUSH
99994: CALL 18484 0 1
99998: IFFALSE 100002
// continue ;
100000: GO 98274
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
100002: LD_VAR 0 18
100006: PUSH
100007: LD_VAR 0 4
100011: PUSH
100012: LD_VAR 0 7
100016: ARRAY
100017: PPUSH
100018: CALL_OW 310
100022: NOT
100023: AND
100024: PUSH
100025: LD_VAR 0 14
100029: PUSH
100030: LD_INT 1
100032: ARRAY
100033: PUSH
100034: LD_VAR 0 14
100038: PPUSH
100039: LD_INT 21
100041: PUSH
100042: LD_INT 2
100044: PUSH
100045: EMPTY
100046: LIST
100047: LIST
100048: PUSH
100049: LD_INT 58
100051: PUSH
100052: EMPTY
100053: LIST
100054: PUSH
100055: EMPTY
100056: LIST
100057: LIST
100058: PPUSH
100059: CALL_OW 72
100063: IN
100064: AND
100065: IFFALSE 100101
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
100067: LD_VAR 0 4
100071: PUSH
100072: LD_VAR 0 7
100076: ARRAY
100077: PPUSH
100078: LD_VAR 0 14
100082: PUSH
100083: LD_INT 1
100085: ARRAY
100086: PPUSH
100087: CALL_OW 120
// attacking := true ;
100091: LD_ADDR_VAR 0 29
100095: PUSH
100096: LD_INT 1
100098: ST_TO_ADDR
// continue ;
100099: GO 98274
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
100101: LD_VAR 0 26
100105: PUSH
100106: LD_VAR 0 4
100110: PUSH
100111: LD_VAR 0 7
100115: ARRAY
100116: PPUSH
100117: CALL_OW 257
100121: PUSH
100122: LD_INT 1
100124: EQUAL
100125: AND
100126: PUSH
100127: LD_VAR 0 4
100131: PUSH
100132: LD_VAR 0 7
100136: ARRAY
100137: PPUSH
100138: CALL_OW 256
100142: PUSH
100143: LD_INT 800
100145: LESS
100146: AND
100147: PUSH
100148: LD_VAR 0 4
100152: PUSH
100153: LD_VAR 0 7
100157: ARRAY
100158: PPUSH
100159: CALL_OW 318
100163: NOT
100164: AND
100165: IFFALSE 100182
// ComCrawl ( group [ i ] ) ;
100167: LD_VAR 0 4
100171: PUSH
100172: LD_VAR 0 7
100176: ARRAY
100177: PPUSH
100178: CALL_OW 137
// if f_mines then
100182: LD_VAR 0 21
100186: IFFALSE 100429
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
100188: LD_VAR 0 14
100192: PUSH
100193: LD_INT 1
100195: ARRAY
100196: PPUSH
100197: CALL_OW 247
100201: PUSH
100202: LD_INT 3
100204: EQUAL
100205: PUSH
100206: LD_VAR 0 14
100210: PUSH
100211: LD_INT 1
100213: ARRAY
100214: PUSH
100215: LD_VAR 0 27
100219: IN
100220: NOT
100221: AND
100222: IFFALSE 100429
// begin x := GetX ( tmp [ 1 ] ) ;
100224: LD_ADDR_VAR 0 10
100228: PUSH
100229: LD_VAR 0 14
100233: PUSH
100234: LD_INT 1
100236: ARRAY
100237: PPUSH
100238: CALL_OW 250
100242: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
100243: LD_ADDR_VAR 0 11
100247: PUSH
100248: LD_VAR 0 14
100252: PUSH
100253: LD_INT 1
100255: ARRAY
100256: PPUSH
100257: CALL_OW 251
100261: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
100262: LD_ADDR_VAR 0 12
100266: PUSH
100267: LD_VAR 0 4
100271: PUSH
100272: LD_VAR 0 7
100276: ARRAY
100277: PPUSH
100278: CALL 45425 0 1
100282: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
100283: LD_VAR 0 4
100287: PUSH
100288: LD_VAR 0 7
100292: ARRAY
100293: PPUSH
100294: LD_VAR 0 10
100298: PPUSH
100299: LD_VAR 0 11
100303: PPUSH
100304: LD_VAR 0 14
100308: PUSH
100309: LD_INT 1
100311: ARRAY
100312: PPUSH
100313: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
100317: LD_VAR 0 4
100321: PUSH
100322: LD_VAR 0 7
100326: ARRAY
100327: PPUSH
100328: LD_VAR 0 10
100332: PPUSH
100333: LD_VAR 0 12
100337: PPUSH
100338: LD_INT 7
100340: PPUSH
100341: CALL_OW 272
100345: PPUSH
100346: LD_VAR 0 11
100350: PPUSH
100351: LD_VAR 0 12
100355: PPUSH
100356: LD_INT 7
100358: PPUSH
100359: CALL_OW 273
100363: PPUSH
100364: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
100368: LD_VAR 0 4
100372: PUSH
100373: LD_VAR 0 7
100377: ARRAY
100378: PPUSH
100379: LD_INT 71
100381: PPUSH
100382: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
100386: LD_ADDR_VAR 0 27
100390: PUSH
100391: LD_VAR 0 27
100395: PPUSH
100396: LD_VAR 0 27
100400: PUSH
100401: LD_INT 1
100403: PLUS
100404: PPUSH
100405: LD_VAR 0 14
100409: PUSH
100410: LD_INT 1
100412: ARRAY
100413: PPUSH
100414: CALL_OW 1
100418: ST_TO_ADDR
// attacking := true ;
100419: LD_ADDR_VAR 0 29
100423: PUSH
100424: LD_INT 1
100426: ST_TO_ADDR
// continue ;
100427: GO 98274
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
100429: LD_VAR 0 4
100433: PUSH
100434: LD_VAR 0 7
100438: ARRAY
100439: PPUSH
100440: CALL_OW 257
100444: PUSH
100445: LD_INT 17
100447: EQUAL
100448: PUSH
100449: LD_VAR 0 4
100453: PUSH
100454: LD_VAR 0 7
100458: ARRAY
100459: PPUSH
100460: CALL_OW 110
100464: PUSH
100465: LD_INT 71
100467: EQUAL
100468: NOT
100469: AND
100470: IFFALSE 100616
// begin attacking := false ;
100472: LD_ADDR_VAR 0 29
100476: PUSH
100477: LD_INT 0
100479: ST_TO_ADDR
// k := 5 ;
100480: LD_ADDR_VAR 0 9
100484: PUSH
100485: LD_INT 5
100487: ST_TO_ADDR
// if tmp < k then
100488: LD_VAR 0 14
100492: PUSH
100493: LD_VAR 0 9
100497: LESS
100498: IFFALSE 100510
// k := tmp ;
100500: LD_ADDR_VAR 0 9
100504: PUSH
100505: LD_VAR 0 14
100509: ST_TO_ADDR
// for j = 1 to k do
100510: LD_ADDR_VAR 0 8
100514: PUSH
100515: DOUBLE
100516: LD_INT 1
100518: DEC
100519: ST_TO_ADDR
100520: LD_VAR 0 9
100524: PUSH
100525: FOR_TO
100526: IFFALSE 100614
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
100528: LD_VAR 0 14
100532: PUSH
100533: LD_VAR 0 8
100537: ARRAY
100538: PUSH
100539: LD_VAR 0 14
100543: PPUSH
100544: LD_INT 58
100546: PUSH
100547: EMPTY
100548: LIST
100549: PPUSH
100550: CALL_OW 72
100554: IN
100555: NOT
100556: IFFALSE 100612
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
100558: LD_VAR 0 4
100562: PUSH
100563: LD_VAR 0 7
100567: ARRAY
100568: PPUSH
100569: LD_VAR 0 14
100573: PUSH
100574: LD_VAR 0 8
100578: ARRAY
100579: PPUSH
100580: CALL_OW 115
// attacking := true ;
100584: LD_ADDR_VAR 0 29
100588: PUSH
100589: LD_INT 1
100591: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
100592: LD_VAR 0 4
100596: PUSH
100597: LD_VAR 0 7
100601: ARRAY
100602: PPUSH
100603: LD_INT 71
100605: PPUSH
100606: CALL_OW 109
// continue ;
100610: GO 100525
// end ; end ;
100612: GO 100525
100614: POP
100615: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
100616: LD_VAR 0 4
100620: PUSH
100621: LD_VAR 0 7
100625: ARRAY
100626: PPUSH
100627: CALL_OW 257
100631: PUSH
100632: LD_INT 8
100634: EQUAL
100635: PUSH
100636: LD_VAR 0 4
100640: PUSH
100641: LD_VAR 0 7
100645: ARRAY
100646: PPUSH
100647: CALL_OW 264
100651: PUSH
100652: LD_INT 28
100654: PUSH
100655: LD_INT 45
100657: PUSH
100658: LD_INT 7
100660: PUSH
100661: LD_INT 47
100663: PUSH
100664: EMPTY
100665: LIST
100666: LIST
100667: LIST
100668: LIST
100669: IN
100670: OR
100671: IFFALSE 100927
// begin attacking := false ;
100673: LD_ADDR_VAR 0 29
100677: PUSH
100678: LD_INT 0
100680: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
100681: LD_VAR 0 14
100685: PUSH
100686: LD_INT 1
100688: ARRAY
100689: PPUSH
100690: CALL_OW 266
100694: PUSH
100695: LD_INT 32
100697: PUSH
100698: LD_INT 31
100700: PUSH
100701: LD_INT 33
100703: PUSH
100704: LD_INT 4
100706: PUSH
100707: LD_INT 5
100709: PUSH
100710: EMPTY
100711: LIST
100712: LIST
100713: LIST
100714: LIST
100715: LIST
100716: IN
100717: IFFALSE 100903
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
100719: LD_ADDR_VAR 0 9
100723: PUSH
100724: LD_VAR 0 14
100728: PUSH
100729: LD_INT 1
100731: ARRAY
100732: PPUSH
100733: CALL_OW 266
100737: PPUSH
100738: LD_VAR 0 14
100742: PUSH
100743: LD_INT 1
100745: ARRAY
100746: PPUSH
100747: CALL_OW 250
100751: PPUSH
100752: LD_VAR 0 14
100756: PUSH
100757: LD_INT 1
100759: ARRAY
100760: PPUSH
100761: CALL_OW 251
100765: PPUSH
100766: LD_VAR 0 14
100770: PUSH
100771: LD_INT 1
100773: ARRAY
100774: PPUSH
100775: CALL_OW 254
100779: PPUSH
100780: LD_VAR 0 14
100784: PUSH
100785: LD_INT 1
100787: ARRAY
100788: PPUSH
100789: CALL_OW 248
100793: PPUSH
100794: LD_INT 0
100796: PPUSH
100797: CALL 26795 0 6
100801: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
100802: LD_ADDR_VAR 0 8
100806: PUSH
100807: LD_VAR 0 4
100811: PUSH
100812: LD_VAR 0 7
100816: ARRAY
100817: PPUSH
100818: LD_VAR 0 9
100822: PPUSH
100823: CALL 45465 0 2
100827: ST_TO_ADDR
// if j then
100828: LD_VAR 0 8
100832: IFFALSE 100901
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
100834: LD_VAR 0 8
100838: PUSH
100839: LD_INT 1
100841: ARRAY
100842: PPUSH
100843: LD_VAR 0 8
100847: PUSH
100848: LD_INT 2
100850: ARRAY
100851: PPUSH
100852: CALL_OW 488
100856: IFFALSE 100901
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
100858: LD_VAR 0 4
100862: PUSH
100863: LD_VAR 0 7
100867: ARRAY
100868: PPUSH
100869: LD_VAR 0 8
100873: PUSH
100874: LD_INT 1
100876: ARRAY
100877: PPUSH
100878: LD_VAR 0 8
100882: PUSH
100883: LD_INT 2
100885: ARRAY
100886: PPUSH
100887: CALL_OW 116
// attacking := true ;
100891: LD_ADDR_VAR 0 29
100895: PUSH
100896: LD_INT 1
100898: ST_TO_ADDR
// continue ;
100899: GO 98274
// end ; end else
100901: GO 100927
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
100903: LD_VAR 0 4
100907: PUSH
100908: LD_VAR 0 7
100912: ARRAY
100913: PPUSH
100914: LD_VAR 0 14
100918: PUSH
100919: LD_INT 1
100921: ARRAY
100922: PPUSH
100923: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
100927: LD_VAR 0 4
100931: PUSH
100932: LD_VAR 0 7
100936: ARRAY
100937: PPUSH
100938: CALL_OW 265
100942: PUSH
100943: LD_INT 11
100945: EQUAL
100946: IFFALSE 101224
// begin k := 10 ;
100948: LD_ADDR_VAR 0 9
100952: PUSH
100953: LD_INT 10
100955: ST_TO_ADDR
// x := 0 ;
100956: LD_ADDR_VAR 0 10
100960: PUSH
100961: LD_INT 0
100963: ST_TO_ADDR
// if tmp < k then
100964: LD_VAR 0 14
100968: PUSH
100969: LD_VAR 0 9
100973: LESS
100974: IFFALSE 100986
// k := tmp ;
100976: LD_ADDR_VAR 0 9
100980: PUSH
100981: LD_VAR 0 14
100985: ST_TO_ADDR
// for j = k downto 1 do
100986: LD_ADDR_VAR 0 8
100990: PUSH
100991: DOUBLE
100992: LD_VAR 0 9
100996: INC
100997: ST_TO_ADDR
100998: LD_INT 1
101000: PUSH
101001: FOR_DOWNTO
101002: IFFALSE 101077
// begin if GetType ( tmp [ j ] ) = unit_human then
101004: LD_VAR 0 14
101008: PUSH
101009: LD_VAR 0 8
101013: ARRAY
101014: PPUSH
101015: CALL_OW 247
101019: PUSH
101020: LD_INT 1
101022: EQUAL
101023: IFFALSE 101075
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
101025: LD_VAR 0 4
101029: PUSH
101030: LD_VAR 0 7
101034: ARRAY
101035: PPUSH
101036: LD_VAR 0 14
101040: PUSH
101041: LD_VAR 0 8
101045: ARRAY
101046: PPUSH
101047: CALL 45736 0 2
// x := tmp [ j ] ;
101051: LD_ADDR_VAR 0 10
101055: PUSH
101056: LD_VAR 0 14
101060: PUSH
101061: LD_VAR 0 8
101065: ARRAY
101066: ST_TO_ADDR
// attacking := true ;
101067: LD_ADDR_VAR 0 29
101071: PUSH
101072: LD_INT 1
101074: ST_TO_ADDR
// end ; end ;
101075: GO 101001
101077: POP
101078: POP
// if not x then
101079: LD_VAR 0 10
101083: NOT
101084: IFFALSE 101224
// begin attacking := true ;
101086: LD_ADDR_VAR 0 29
101090: PUSH
101091: LD_INT 1
101093: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
101094: LD_VAR 0 4
101098: PUSH
101099: LD_VAR 0 7
101103: ARRAY
101104: PPUSH
101105: CALL_OW 250
101109: PPUSH
101110: LD_VAR 0 4
101114: PUSH
101115: LD_VAR 0 7
101119: ARRAY
101120: PPUSH
101121: CALL_OW 251
101125: PPUSH
101126: CALL_OW 546
101130: PUSH
101131: LD_INT 2
101133: ARRAY
101134: PUSH
101135: LD_VAR 0 14
101139: PUSH
101140: LD_INT 1
101142: ARRAY
101143: PPUSH
101144: CALL_OW 250
101148: PPUSH
101149: LD_VAR 0 14
101153: PUSH
101154: LD_INT 1
101156: ARRAY
101157: PPUSH
101158: CALL_OW 251
101162: PPUSH
101163: CALL_OW 546
101167: PUSH
101168: LD_INT 2
101170: ARRAY
101171: EQUAL
101172: IFFALSE 101200
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
101174: LD_VAR 0 4
101178: PUSH
101179: LD_VAR 0 7
101183: ARRAY
101184: PPUSH
101185: LD_VAR 0 14
101189: PUSH
101190: LD_INT 1
101192: ARRAY
101193: PPUSH
101194: CALL 45736 0 2
101198: GO 101224
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101200: LD_VAR 0 4
101204: PUSH
101205: LD_VAR 0 7
101209: ARRAY
101210: PPUSH
101211: LD_VAR 0 14
101215: PUSH
101216: LD_INT 1
101218: ARRAY
101219: PPUSH
101220: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
101224: LD_VAR 0 4
101228: PUSH
101229: LD_VAR 0 7
101233: ARRAY
101234: PPUSH
101235: CALL_OW 264
101239: PUSH
101240: LD_INT 29
101242: EQUAL
101243: IFFALSE 101609
// begin if WantsToAttack ( group [ i ] ) in bombed then
101245: LD_VAR 0 4
101249: PUSH
101250: LD_VAR 0 7
101254: ARRAY
101255: PPUSH
101256: CALL_OW 319
101260: PUSH
101261: LD_VAR 0 28
101265: IN
101266: IFFALSE 101270
// continue ;
101268: GO 98274
// k := 8 ;
101270: LD_ADDR_VAR 0 9
101274: PUSH
101275: LD_INT 8
101277: ST_TO_ADDR
// x := 0 ;
101278: LD_ADDR_VAR 0 10
101282: PUSH
101283: LD_INT 0
101285: ST_TO_ADDR
// if tmp < k then
101286: LD_VAR 0 14
101290: PUSH
101291: LD_VAR 0 9
101295: LESS
101296: IFFALSE 101308
// k := tmp ;
101298: LD_ADDR_VAR 0 9
101302: PUSH
101303: LD_VAR 0 14
101307: ST_TO_ADDR
// for j = 1 to k do
101308: LD_ADDR_VAR 0 8
101312: PUSH
101313: DOUBLE
101314: LD_INT 1
101316: DEC
101317: ST_TO_ADDR
101318: LD_VAR 0 9
101322: PUSH
101323: FOR_TO
101324: IFFALSE 101456
// begin if GetType ( tmp [ j ] ) = unit_building then
101326: LD_VAR 0 14
101330: PUSH
101331: LD_VAR 0 8
101335: ARRAY
101336: PPUSH
101337: CALL_OW 247
101341: PUSH
101342: LD_INT 3
101344: EQUAL
101345: IFFALSE 101454
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
101347: LD_VAR 0 14
101351: PUSH
101352: LD_VAR 0 8
101356: ARRAY
101357: PUSH
101358: LD_VAR 0 28
101362: IN
101363: NOT
101364: PUSH
101365: LD_VAR 0 14
101369: PUSH
101370: LD_VAR 0 8
101374: ARRAY
101375: PPUSH
101376: CALL_OW 313
101380: AND
101381: IFFALSE 101454
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101383: LD_VAR 0 4
101387: PUSH
101388: LD_VAR 0 7
101392: ARRAY
101393: PPUSH
101394: LD_VAR 0 14
101398: PUSH
101399: LD_VAR 0 8
101403: ARRAY
101404: PPUSH
101405: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
101409: LD_ADDR_VAR 0 28
101413: PUSH
101414: LD_VAR 0 28
101418: PPUSH
101419: LD_VAR 0 28
101423: PUSH
101424: LD_INT 1
101426: PLUS
101427: PPUSH
101428: LD_VAR 0 14
101432: PUSH
101433: LD_VAR 0 8
101437: ARRAY
101438: PPUSH
101439: CALL_OW 1
101443: ST_TO_ADDR
// attacking := true ;
101444: LD_ADDR_VAR 0 29
101448: PUSH
101449: LD_INT 1
101451: ST_TO_ADDR
// break ;
101452: GO 101456
// end ; end ;
101454: GO 101323
101456: POP
101457: POP
// if not attacking and f_attack_depot then
101458: LD_VAR 0 29
101462: NOT
101463: PUSH
101464: LD_VAR 0 25
101468: AND
101469: IFFALSE 101564
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101471: LD_ADDR_VAR 0 13
101475: PUSH
101476: LD_VAR 0 14
101480: PPUSH
101481: LD_INT 2
101483: PUSH
101484: LD_INT 30
101486: PUSH
101487: LD_INT 0
101489: PUSH
101490: EMPTY
101491: LIST
101492: LIST
101493: PUSH
101494: LD_INT 30
101496: PUSH
101497: LD_INT 1
101499: PUSH
101500: EMPTY
101501: LIST
101502: LIST
101503: PUSH
101504: EMPTY
101505: LIST
101506: LIST
101507: LIST
101508: PPUSH
101509: CALL_OW 72
101513: ST_TO_ADDR
// if z then
101514: LD_VAR 0 13
101518: IFFALSE 101564
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
101520: LD_VAR 0 4
101524: PUSH
101525: LD_VAR 0 7
101529: ARRAY
101530: PPUSH
101531: LD_VAR 0 13
101535: PPUSH
101536: LD_VAR 0 4
101540: PUSH
101541: LD_VAR 0 7
101545: ARRAY
101546: PPUSH
101547: CALL_OW 74
101551: PPUSH
101552: CALL_OW 115
// attacking := true ;
101556: LD_ADDR_VAR 0 29
101560: PUSH
101561: LD_INT 1
101563: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
101564: LD_VAR 0 4
101568: PUSH
101569: LD_VAR 0 7
101573: ARRAY
101574: PPUSH
101575: CALL_OW 256
101579: PUSH
101580: LD_INT 500
101582: LESS
101583: IFFALSE 101609
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101585: LD_VAR 0 4
101589: PUSH
101590: LD_VAR 0 7
101594: ARRAY
101595: PPUSH
101596: LD_VAR 0 14
101600: PUSH
101601: LD_INT 1
101603: ARRAY
101604: PPUSH
101605: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
101609: LD_VAR 0 4
101613: PUSH
101614: LD_VAR 0 7
101618: ARRAY
101619: PPUSH
101620: CALL_OW 264
101624: PUSH
101625: LD_INT 49
101627: EQUAL
101628: IFFALSE 101749
// begin if not HasTask ( group [ i ] ) then
101630: LD_VAR 0 4
101634: PUSH
101635: LD_VAR 0 7
101639: ARRAY
101640: PPUSH
101641: CALL_OW 314
101645: NOT
101646: IFFALSE 101749
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
101648: LD_ADDR_VAR 0 9
101652: PUSH
101653: LD_INT 81
101655: PUSH
101656: LD_VAR 0 4
101660: PUSH
101661: LD_VAR 0 7
101665: ARRAY
101666: PPUSH
101667: CALL_OW 255
101671: PUSH
101672: EMPTY
101673: LIST
101674: LIST
101675: PPUSH
101676: CALL_OW 69
101680: PPUSH
101681: LD_VAR 0 4
101685: PUSH
101686: LD_VAR 0 7
101690: ARRAY
101691: PPUSH
101692: CALL_OW 74
101696: ST_TO_ADDR
// if k then
101697: LD_VAR 0 9
101701: IFFALSE 101749
// if GetDistUnits ( group [ i ] , k ) > 10 then
101703: LD_VAR 0 4
101707: PUSH
101708: LD_VAR 0 7
101712: ARRAY
101713: PPUSH
101714: LD_VAR 0 9
101718: PPUSH
101719: CALL_OW 296
101723: PUSH
101724: LD_INT 10
101726: GREATER
101727: IFFALSE 101749
// ComMoveUnit ( group [ i ] , k ) ;
101729: LD_VAR 0 4
101733: PUSH
101734: LD_VAR 0 7
101738: ARRAY
101739: PPUSH
101740: LD_VAR 0 9
101744: PPUSH
101745: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
101749: LD_VAR 0 4
101753: PUSH
101754: LD_VAR 0 7
101758: ARRAY
101759: PPUSH
101760: CALL_OW 256
101764: PUSH
101765: LD_INT 250
101767: LESS
101768: PUSH
101769: LD_VAR 0 4
101773: PUSH
101774: LD_VAR 0 7
101778: ARRAY
101779: PUSH
101780: LD_INT 21
101782: PUSH
101783: LD_INT 2
101785: PUSH
101786: EMPTY
101787: LIST
101788: LIST
101789: PUSH
101790: LD_INT 23
101792: PUSH
101793: LD_INT 2
101795: PUSH
101796: EMPTY
101797: LIST
101798: LIST
101799: PUSH
101800: EMPTY
101801: LIST
101802: LIST
101803: PPUSH
101804: CALL_OW 69
101808: IN
101809: AND
101810: IFFALSE 101935
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
101812: LD_ADDR_VAR 0 9
101816: PUSH
101817: LD_OWVAR 3
101821: PUSH
101822: LD_VAR 0 4
101826: PUSH
101827: LD_VAR 0 7
101831: ARRAY
101832: DIFF
101833: PPUSH
101834: LD_VAR 0 4
101838: PUSH
101839: LD_VAR 0 7
101843: ARRAY
101844: PPUSH
101845: CALL_OW 74
101849: ST_TO_ADDR
// if not k then
101850: LD_VAR 0 9
101854: NOT
101855: IFFALSE 101859
// continue ;
101857: GO 98274
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
101859: LD_VAR 0 9
101863: PUSH
101864: LD_INT 81
101866: PUSH
101867: LD_VAR 0 4
101871: PUSH
101872: LD_VAR 0 7
101876: ARRAY
101877: PPUSH
101878: CALL_OW 255
101882: PUSH
101883: EMPTY
101884: LIST
101885: LIST
101886: PPUSH
101887: CALL_OW 69
101891: IN
101892: PUSH
101893: LD_VAR 0 9
101897: PPUSH
101898: LD_VAR 0 4
101902: PUSH
101903: LD_VAR 0 7
101907: ARRAY
101908: PPUSH
101909: CALL_OW 296
101913: PUSH
101914: LD_INT 5
101916: LESS
101917: AND
101918: IFFALSE 101935
// ComAutodestruct ( group [ i ] ) ;
101920: LD_VAR 0 4
101924: PUSH
101925: LD_VAR 0 7
101929: ARRAY
101930: PPUSH
101931: CALL 45634 0 1
// end ; if f_attack_depot then
101935: LD_VAR 0 25
101939: IFFALSE 102051
// begin k := 6 ;
101941: LD_ADDR_VAR 0 9
101945: PUSH
101946: LD_INT 6
101948: ST_TO_ADDR
// if tmp < k then
101949: LD_VAR 0 14
101953: PUSH
101954: LD_VAR 0 9
101958: LESS
101959: IFFALSE 101971
// k := tmp ;
101961: LD_ADDR_VAR 0 9
101965: PUSH
101966: LD_VAR 0 14
101970: ST_TO_ADDR
// for j = 1 to k do
101971: LD_ADDR_VAR 0 8
101975: PUSH
101976: DOUBLE
101977: LD_INT 1
101979: DEC
101980: ST_TO_ADDR
101981: LD_VAR 0 9
101985: PUSH
101986: FOR_TO
101987: IFFALSE 102049
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
101989: LD_VAR 0 8
101993: PPUSH
101994: CALL_OW 266
101998: PUSH
101999: LD_INT 0
102001: PUSH
102002: LD_INT 1
102004: PUSH
102005: EMPTY
102006: LIST
102007: LIST
102008: IN
102009: IFFALSE 102047
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102011: LD_VAR 0 4
102015: PUSH
102016: LD_VAR 0 7
102020: ARRAY
102021: PPUSH
102022: LD_VAR 0 14
102026: PUSH
102027: LD_VAR 0 8
102031: ARRAY
102032: PPUSH
102033: CALL_OW 115
// attacking := true ;
102037: LD_ADDR_VAR 0 29
102041: PUSH
102042: LD_INT 1
102044: ST_TO_ADDR
// break ;
102045: GO 102049
// end ;
102047: GO 101986
102049: POP
102050: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
102051: LD_VAR 0 4
102055: PUSH
102056: LD_VAR 0 7
102060: ARRAY
102061: PPUSH
102062: CALL_OW 302
102066: PUSH
102067: LD_VAR 0 29
102071: NOT
102072: AND
102073: IFFALSE 102395
// begin if GetTag ( group [ i ] ) = 71 then
102075: LD_VAR 0 4
102079: PUSH
102080: LD_VAR 0 7
102084: ARRAY
102085: PPUSH
102086: CALL_OW 110
102090: PUSH
102091: LD_INT 71
102093: EQUAL
102094: IFFALSE 102135
// begin if HasTask ( group [ i ] ) then
102096: LD_VAR 0 4
102100: PUSH
102101: LD_VAR 0 7
102105: ARRAY
102106: PPUSH
102107: CALL_OW 314
102111: IFFALSE 102117
// continue else
102113: GO 98274
102115: GO 102135
// SetTag ( group [ i ] , 0 ) ;
102117: LD_VAR 0 4
102121: PUSH
102122: LD_VAR 0 7
102126: ARRAY
102127: PPUSH
102128: LD_INT 0
102130: PPUSH
102131: CALL_OW 109
// end ; k := 8 ;
102135: LD_ADDR_VAR 0 9
102139: PUSH
102140: LD_INT 8
102142: ST_TO_ADDR
// x := 0 ;
102143: LD_ADDR_VAR 0 10
102147: PUSH
102148: LD_INT 0
102150: ST_TO_ADDR
// if tmp < k then
102151: LD_VAR 0 14
102155: PUSH
102156: LD_VAR 0 9
102160: LESS
102161: IFFALSE 102173
// k := tmp ;
102163: LD_ADDR_VAR 0 9
102167: PUSH
102168: LD_VAR 0 14
102172: ST_TO_ADDR
// for j = 1 to k do
102173: LD_ADDR_VAR 0 8
102177: PUSH
102178: DOUBLE
102179: LD_INT 1
102181: DEC
102182: ST_TO_ADDR
102183: LD_VAR 0 9
102187: PUSH
102188: FOR_TO
102189: IFFALSE 102287
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
102191: LD_VAR 0 14
102195: PUSH
102196: LD_VAR 0 8
102200: ARRAY
102201: PPUSH
102202: CALL_OW 247
102206: PUSH
102207: LD_INT 1
102209: EQUAL
102210: PUSH
102211: LD_VAR 0 14
102215: PUSH
102216: LD_VAR 0 8
102220: ARRAY
102221: PPUSH
102222: CALL_OW 256
102226: PUSH
102227: LD_INT 250
102229: LESS
102230: PUSH
102231: LD_VAR 0 20
102235: AND
102236: PUSH
102237: LD_VAR 0 20
102241: NOT
102242: PUSH
102243: LD_VAR 0 14
102247: PUSH
102248: LD_VAR 0 8
102252: ARRAY
102253: PPUSH
102254: CALL_OW 256
102258: PUSH
102259: LD_INT 250
102261: GREATEREQUAL
102262: AND
102263: OR
102264: AND
102265: IFFALSE 102285
// begin x := tmp [ j ] ;
102267: LD_ADDR_VAR 0 10
102271: PUSH
102272: LD_VAR 0 14
102276: PUSH
102277: LD_VAR 0 8
102281: ARRAY
102282: ST_TO_ADDR
// break ;
102283: GO 102287
// end ;
102285: GO 102188
102287: POP
102288: POP
// if x then
102289: LD_VAR 0 10
102293: IFFALSE 102317
// ComAttackUnit ( group [ i ] , x ) else
102295: LD_VAR 0 4
102299: PUSH
102300: LD_VAR 0 7
102304: ARRAY
102305: PPUSH
102306: LD_VAR 0 10
102310: PPUSH
102311: CALL_OW 115
102315: GO 102341
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102317: LD_VAR 0 4
102321: PUSH
102322: LD_VAR 0 7
102326: ARRAY
102327: PPUSH
102328: LD_VAR 0 14
102332: PUSH
102333: LD_INT 1
102335: ARRAY
102336: PPUSH
102337: CALL_OW 115
// if not HasTask ( group [ i ] ) then
102341: LD_VAR 0 4
102345: PUSH
102346: LD_VAR 0 7
102350: ARRAY
102351: PPUSH
102352: CALL_OW 314
102356: NOT
102357: IFFALSE 102395
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
102359: LD_VAR 0 4
102363: PUSH
102364: LD_VAR 0 7
102368: ARRAY
102369: PPUSH
102370: LD_VAR 0 14
102374: PPUSH
102375: LD_VAR 0 4
102379: PUSH
102380: LD_VAR 0 7
102384: ARRAY
102385: PPUSH
102386: CALL_OW 74
102390: PPUSH
102391: CALL_OW 115
// end ; end ; end ;
102395: GO 98274
102397: POP
102398: POP
// wait ( 0 0$2 ) ;
102399: LD_INT 70
102401: PPUSH
102402: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
102406: LD_VAR 0 4
102410: NOT
102411: PUSH
102412: LD_VAR 0 4
102416: PUSH
102417: EMPTY
102418: EQUAL
102419: OR
102420: PUSH
102421: LD_INT 81
102423: PUSH
102424: LD_VAR 0 35
102428: PUSH
102429: EMPTY
102430: LIST
102431: LIST
102432: PPUSH
102433: CALL_OW 69
102437: NOT
102438: OR
102439: IFFALSE 98259
// end ;
102441: LD_VAR 0 2
102445: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
102446: LD_INT 0
102448: PPUSH
102449: PPUSH
102450: PPUSH
102451: PPUSH
102452: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
102453: LD_VAR 0 1
102457: NOT
102458: PUSH
102459: LD_EXP 66
102463: PUSH
102464: LD_VAR 0 1
102468: ARRAY
102469: NOT
102470: OR
102471: PUSH
102472: LD_VAR 0 2
102476: NOT
102477: OR
102478: PUSH
102479: LD_VAR 0 3
102483: NOT
102484: OR
102485: IFFALSE 102489
// exit ;
102487: GO 103002
// side := mc_sides [ base ] ;
102489: LD_ADDR_VAR 0 6
102493: PUSH
102494: LD_EXP 92
102498: PUSH
102499: LD_VAR 0 1
102503: ARRAY
102504: ST_TO_ADDR
// if not side then
102505: LD_VAR 0 6
102509: NOT
102510: IFFALSE 102514
// exit ;
102512: GO 103002
// for i in solds do
102514: LD_ADDR_VAR 0 7
102518: PUSH
102519: LD_VAR 0 2
102523: PUSH
102524: FOR_IN
102525: IFFALSE 102586
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
102527: LD_VAR 0 7
102531: PPUSH
102532: CALL_OW 310
102536: PPUSH
102537: CALL_OW 266
102541: PUSH
102542: LD_INT 32
102544: PUSH
102545: LD_INT 31
102547: PUSH
102548: EMPTY
102549: LIST
102550: LIST
102551: IN
102552: IFFALSE 102572
// solds := solds diff i else
102554: LD_ADDR_VAR 0 2
102558: PUSH
102559: LD_VAR 0 2
102563: PUSH
102564: LD_VAR 0 7
102568: DIFF
102569: ST_TO_ADDR
102570: GO 102584
// SetTag ( i , 18 ) ;
102572: LD_VAR 0 7
102576: PPUSH
102577: LD_INT 18
102579: PPUSH
102580: CALL_OW 109
102584: GO 102524
102586: POP
102587: POP
// if not solds then
102588: LD_VAR 0 2
102592: NOT
102593: IFFALSE 102597
// exit ;
102595: GO 103002
// repeat wait ( 0 0$1 ) ;
102597: LD_INT 35
102599: PPUSH
102600: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
102604: LD_ADDR_VAR 0 5
102608: PUSH
102609: LD_VAR 0 6
102613: PPUSH
102614: LD_VAR 0 3
102618: PPUSH
102619: CALL 15349 0 2
102623: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
102624: LD_EXP 66
102628: PUSH
102629: LD_VAR 0 1
102633: ARRAY
102634: NOT
102635: PUSH
102636: LD_EXP 66
102640: PUSH
102641: LD_VAR 0 1
102645: ARRAY
102646: PUSH
102647: EMPTY
102648: EQUAL
102649: OR
102650: IFFALSE 102687
// begin for i in solds do
102652: LD_ADDR_VAR 0 7
102656: PUSH
102657: LD_VAR 0 2
102661: PUSH
102662: FOR_IN
102663: IFFALSE 102676
// ComStop ( i ) ;
102665: LD_VAR 0 7
102669: PPUSH
102670: CALL_OW 141
102674: GO 102662
102676: POP
102677: POP
// solds := [ ] ;
102678: LD_ADDR_VAR 0 2
102682: PUSH
102683: EMPTY
102684: ST_TO_ADDR
// exit ;
102685: GO 103002
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
102687: LD_VAR 0 5
102691: NOT
102692: PUSH
102693: LD_VAR 0 5
102697: PUSH
102698: LD_INT 3
102700: GREATER
102701: OR
102702: PUSH
102703: LD_EXP 88
102707: PUSH
102708: LD_VAR 0 1
102712: ARRAY
102713: OR
102714: IFFALSE 102755
// begin for i in solds do
102716: LD_ADDR_VAR 0 7
102720: PUSH
102721: LD_VAR 0 2
102725: PUSH
102726: FOR_IN
102727: IFFALSE 102751
// if HasTask ( i ) then
102729: LD_VAR 0 7
102733: PPUSH
102734: CALL_OW 314
102738: IFFALSE 102749
// ComStop ( i ) ;
102740: LD_VAR 0 7
102744: PPUSH
102745: CALL_OW 141
102749: GO 102726
102751: POP
102752: POP
// break ;
102753: GO 102990
// end ; for i in solds do
102755: LD_ADDR_VAR 0 7
102759: PUSH
102760: LD_VAR 0 2
102764: PUSH
102765: FOR_IN
102766: IFFALSE 102982
// begin if IsInUnit ( i ) then
102768: LD_VAR 0 7
102772: PPUSH
102773: CALL_OW 310
102777: IFFALSE 102788
// ComExitBuilding ( i ) ;
102779: LD_VAR 0 7
102783: PPUSH
102784: CALL_OW 122
// if GetLives ( i ) > 333 then
102788: LD_VAR 0 7
102792: PPUSH
102793: CALL_OW 256
102797: PUSH
102798: LD_INT 333
102800: GREATER
102801: IFFALSE 102829
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
102803: LD_VAR 0 7
102807: PPUSH
102808: LD_VAR 0 5
102812: PPUSH
102813: LD_VAR 0 7
102817: PPUSH
102818: CALL_OW 74
102822: PPUSH
102823: CALL_OW 115
102827: GO 102980
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
102829: LD_ADDR_VAR 0 8
102833: PUSH
102834: LD_EXP 66
102838: PUSH
102839: LD_VAR 0 1
102843: ARRAY
102844: PPUSH
102845: LD_INT 2
102847: PUSH
102848: LD_INT 30
102850: PUSH
102851: LD_INT 0
102853: PUSH
102854: EMPTY
102855: LIST
102856: LIST
102857: PUSH
102858: LD_INT 30
102860: PUSH
102861: LD_INT 1
102863: PUSH
102864: EMPTY
102865: LIST
102866: LIST
102867: PUSH
102868: LD_INT 30
102870: PUSH
102871: LD_INT 6
102873: PUSH
102874: EMPTY
102875: LIST
102876: LIST
102877: PUSH
102878: EMPTY
102879: LIST
102880: LIST
102881: LIST
102882: LIST
102883: PPUSH
102884: CALL_OW 72
102888: PPUSH
102889: LD_VAR 0 7
102893: PPUSH
102894: CALL_OW 74
102898: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
102899: LD_VAR 0 7
102903: PPUSH
102904: LD_VAR 0 8
102908: PPUSH
102909: CALL_OW 250
102913: PPUSH
102914: LD_INT 3
102916: PPUSH
102917: LD_INT 5
102919: PPUSH
102920: CALL_OW 272
102924: PPUSH
102925: LD_VAR 0 8
102929: PPUSH
102930: CALL_OW 251
102934: PPUSH
102935: LD_INT 3
102937: PPUSH
102938: LD_INT 5
102940: PPUSH
102941: CALL_OW 273
102945: PPUSH
102946: CALL_OW 111
// SetTag ( i , 0 ) ;
102950: LD_VAR 0 7
102954: PPUSH
102955: LD_INT 0
102957: PPUSH
102958: CALL_OW 109
// solds := solds diff i ;
102962: LD_ADDR_VAR 0 2
102966: PUSH
102967: LD_VAR 0 2
102971: PUSH
102972: LD_VAR 0 7
102976: DIFF
102977: ST_TO_ADDR
// continue ;
102978: GO 102765
// end ; end ;
102980: GO 102765
102982: POP
102983: POP
// until solds ;
102984: LD_VAR 0 2
102988: IFFALSE 102597
// MC_Reset ( base , 18 ) ;
102990: LD_VAR 0 1
102994: PPUSH
102995: LD_INT 18
102997: PPUSH
102998: CALL 54636 0 2
// end ;
103002: LD_VAR 0 4
103006: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
103007: LD_INT 0
103009: PPUSH
103010: PPUSH
103011: PPUSH
103012: PPUSH
103013: PPUSH
103014: PPUSH
103015: PPUSH
103016: PPUSH
103017: PPUSH
103018: PPUSH
103019: PPUSH
103020: PPUSH
103021: PPUSH
103022: PPUSH
103023: PPUSH
103024: PPUSH
103025: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
103026: LD_ADDR_VAR 0 13
103030: PUSH
103031: LD_EXP 66
103035: PUSH
103036: LD_VAR 0 1
103040: ARRAY
103041: PPUSH
103042: LD_INT 25
103044: PUSH
103045: LD_INT 3
103047: PUSH
103048: EMPTY
103049: LIST
103050: LIST
103051: PPUSH
103052: CALL_OW 72
103056: ST_TO_ADDR
// if mc_remote_driver [ base ] then
103057: LD_EXP 106
103061: PUSH
103062: LD_VAR 0 1
103066: ARRAY
103067: IFFALSE 103091
// mechs := mechs diff mc_remote_driver [ base ] ;
103069: LD_ADDR_VAR 0 13
103073: PUSH
103074: LD_VAR 0 13
103078: PUSH
103079: LD_EXP 106
103083: PUSH
103084: LD_VAR 0 1
103088: ARRAY
103089: DIFF
103090: ST_TO_ADDR
// for i in mechs do
103091: LD_ADDR_VAR 0 5
103095: PUSH
103096: LD_VAR 0 13
103100: PUSH
103101: FOR_IN
103102: IFFALSE 103137
// if GetTag ( i ) > 0 then
103104: LD_VAR 0 5
103108: PPUSH
103109: CALL_OW 110
103113: PUSH
103114: LD_INT 0
103116: GREATER
103117: IFFALSE 103135
// mechs := mechs diff i ;
103119: LD_ADDR_VAR 0 13
103123: PUSH
103124: LD_VAR 0 13
103128: PUSH
103129: LD_VAR 0 5
103133: DIFF
103134: ST_TO_ADDR
103135: GO 103101
103137: POP
103138: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
103139: LD_ADDR_VAR 0 9
103143: PUSH
103144: LD_EXP 66
103148: PUSH
103149: LD_VAR 0 1
103153: ARRAY
103154: PPUSH
103155: LD_INT 2
103157: PUSH
103158: LD_INT 25
103160: PUSH
103161: LD_INT 1
103163: PUSH
103164: EMPTY
103165: LIST
103166: LIST
103167: PUSH
103168: LD_INT 25
103170: PUSH
103171: LD_INT 5
103173: PUSH
103174: EMPTY
103175: LIST
103176: LIST
103177: PUSH
103178: LD_INT 25
103180: PUSH
103181: LD_INT 8
103183: PUSH
103184: EMPTY
103185: LIST
103186: LIST
103187: PUSH
103188: LD_INT 25
103190: PUSH
103191: LD_INT 9
103193: PUSH
103194: EMPTY
103195: LIST
103196: LIST
103197: PUSH
103198: EMPTY
103199: LIST
103200: LIST
103201: LIST
103202: LIST
103203: LIST
103204: PPUSH
103205: CALL_OW 72
103209: ST_TO_ADDR
// if not defenders and not solds then
103210: LD_VAR 0 2
103214: NOT
103215: PUSH
103216: LD_VAR 0 9
103220: NOT
103221: AND
103222: IFFALSE 103226
// exit ;
103224: GO 104852
// depot_under_attack := false ;
103226: LD_ADDR_VAR 0 17
103230: PUSH
103231: LD_INT 0
103233: ST_TO_ADDR
// sold_defenders := [ ] ;
103234: LD_ADDR_VAR 0 18
103238: PUSH
103239: EMPTY
103240: ST_TO_ADDR
// if mechs then
103241: LD_VAR 0 13
103245: IFFALSE 103374
// for i in defenders do
103247: LD_ADDR_VAR 0 5
103251: PUSH
103252: LD_VAR 0 2
103256: PUSH
103257: FOR_IN
103258: IFFALSE 103372
// begin SetTag ( i , 20 ) ;
103260: LD_VAR 0 5
103264: PPUSH
103265: LD_INT 20
103267: PPUSH
103268: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
103272: LD_VAR 0 5
103276: PPUSH
103277: CALL_OW 263
103281: PUSH
103282: LD_INT 1
103284: EQUAL
103285: PUSH
103286: LD_VAR 0 5
103290: PPUSH
103291: CALL_OW 311
103295: NOT
103296: AND
103297: PUSH
103298: LD_VAR 0 13
103302: AND
103303: IFFALSE 103370
// begin un := mechs [ 1 ] ;
103305: LD_ADDR_VAR 0 11
103309: PUSH
103310: LD_VAR 0 13
103314: PUSH
103315: LD_INT 1
103317: ARRAY
103318: ST_TO_ADDR
// ComExitBuilding ( un ) ;
103319: LD_VAR 0 11
103323: PPUSH
103324: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
103328: LD_VAR 0 11
103332: PPUSH
103333: LD_VAR 0 5
103337: PPUSH
103338: CALL_OW 180
// SetTag ( un , 19 ) ;
103342: LD_VAR 0 11
103346: PPUSH
103347: LD_INT 19
103349: PPUSH
103350: CALL_OW 109
// mechs := mechs diff un ;
103354: LD_ADDR_VAR 0 13
103358: PUSH
103359: LD_VAR 0 13
103363: PUSH
103364: LD_VAR 0 11
103368: DIFF
103369: ST_TO_ADDR
// end ; end ;
103370: GO 103257
103372: POP
103373: POP
// if solds then
103374: LD_VAR 0 9
103378: IFFALSE 103437
// for i in solds do
103380: LD_ADDR_VAR 0 5
103384: PUSH
103385: LD_VAR 0 9
103389: PUSH
103390: FOR_IN
103391: IFFALSE 103435
// if not GetTag ( i ) then
103393: LD_VAR 0 5
103397: PPUSH
103398: CALL_OW 110
103402: NOT
103403: IFFALSE 103433
// begin defenders := defenders union i ;
103405: LD_ADDR_VAR 0 2
103409: PUSH
103410: LD_VAR 0 2
103414: PUSH
103415: LD_VAR 0 5
103419: UNION
103420: ST_TO_ADDR
// SetTag ( i , 18 ) ;
103421: LD_VAR 0 5
103425: PPUSH
103426: LD_INT 18
103428: PPUSH
103429: CALL_OW 109
// end ;
103433: GO 103390
103435: POP
103436: POP
// repeat wait ( 0 0$1 ) ;
103437: LD_INT 35
103439: PPUSH
103440: CALL_OW 67
// enemy := mc_scan [ base ] ;
103444: LD_ADDR_VAR 0 3
103448: PUSH
103449: LD_EXP 89
103453: PUSH
103454: LD_VAR 0 1
103458: ARRAY
103459: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
103460: LD_EXP 66
103464: PUSH
103465: LD_VAR 0 1
103469: ARRAY
103470: NOT
103471: PUSH
103472: LD_EXP 66
103476: PUSH
103477: LD_VAR 0 1
103481: ARRAY
103482: PUSH
103483: EMPTY
103484: EQUAL
103485: OR
103486: IFFALSE 103523
// begin for i in defenders do
103488: LD_ADDR_VAR 0 5
103492: PUSH
103493: LD_VAR 0 2
103497: PUSH
103498: FOR_IN
103499: IFFALSE 103512
// ComStop ( i ) ;
103501: LD_VAR 0 5
103505: PPUSH
103506: CALL_OW 141
103510: GO 103498
103512: POP
103513: POP
// defenders := [ ] ;
103514: LD_ADDR_VAR 0 2
103518: PUSH
103519: EMPTY
103520: ST_TO_ADDR
// exit ;
103521: GO 104852
// end ; for i in defenders do
103523: LD_ADDR_VAR 0 5
103527: PUSH
103528: LD_VAR 0 2
103532: PUSH
103533: FOR_IN
103534: IFFALSE 104352
// begin e := NearestUnitToUnit ( enemy , i ) ;
103536: LD_ADDR_VAR 0 14
103540: PUSH
103541: LD_VAR 0 3
103545: PPUSH
103546: LD_VAR 0 5
103550: PPUSH
103551: CALL_OW 74
103555: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103556: LD_ADDR_VAR 0 8
103560: PUSH
103561: LD_EXP 66
103565: PUSH
103566: LD_VAR 0 1
103570: ARRAY
103571: PPUSH
103572: LD_INT 2
103574: PUSH
103575: LD_INT 30
103577: PUSH
103578: LD_INT 0
103580: PUSH
103581: EMPTY
103582: LIST
103583: LIST
103584: PUSH
103585: LD_INT 30
103587: PUSH
103588: LD_INT 1
103590: PUSH
103591: EMPTY
103592: LIST
103593: LIST
103594: PUSH
103595: EMPTY
103596: LIST
103597: LIST
103598: LIST
103599: PPUSH
103600: CALL_OW 72
103604: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
103605: LD_ADDR_VAR 0 17
103609: PUSH
103610: LD_VAR 0 8
103614: NOT
103615: PUSH
103616: LD_VAR 0 8
103620: PPUSH
103621: LD_INT 3
103623: PUSH
103624: LD_INT 24
103626: PUSH
103627: LD_INT 600
103629: PUSH
103630: EMPTY
103631: LIST
103632: LIST
103633: PUSH
103634: EMPTY
103635: LIST
103636: LIST
103637: PPUSH
103638: CALL_OW 72
103642: OR
103643: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
103644: LD_VAR 0 5
103648: PPUSH
103649: CALL_OW 247
103653: PUSH
103654: LD_INT 2
103656: DOUBLE
103657: EQUAL
103658: IFTRUE 103662
103660: GO 104058
103662: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
103663: LD_VAR 0 5
103667: PPUSH
103668: CALL_OW 256
103672: PUSH
103673: LD_INT 650
103675: GREATER
103676: PUSH
103677: LD_VAR 0 5
103681: PPUSH
103682: LD_VAR 0 14
103686: PPUSH
103687: CALL_OW 296
103691: PUSH
103692: LD_INT 40
103694: LESS
103695: PUSH
103696: LD_VAR 0 14
103700: PPUSH
103701: LD_EXP 91
103705: PUSH
103706: LD_VAR 0 1
103710: ARRAY
103711: PPUSH
103712: CALL_OW 308
103716: OR
103717: AND
103718: IFFALSE 103840
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
103720: LD_VAR 0 5
103724: PPUSH
103725: CALL_OW 262
103729: PUSH
103730: LD_INT 1
103732: EQUAL
103733: PUSH
103734: LD_VAR 0 5
103738: PPUSH
103739: CALL_OW 261
103743: PUSH
103744: LD_INT 30
103746: LESS
103747: AND
103748: PUSH
103749: LD_VAR 0 8
103753: AND
103754: IFFALSE 103824
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
103756: LD_VAR 0 5
103760: PPUSH
103761: LD_VAR 0 8
103765: PPUSH
103766: LD_VAR 0 5
103770: PPUSH
103771: CALL_OW 74
103775: PPUSH
103776: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
103780: LD_VAR 0 5
103784: PPUSH
103785: LD_VAR 0 8
103789: PPUSH
103790: LD_VAR 0 5
103794: PPUSH
103795: CALL_OW 74
103799: PPUSH
103800: CALL_OW 296
103804: PUSH
103805: LD_INT 6
103807: LESS
103808: IFFALSE 103822
// SetFuel ( i , 100 ) ;
103810: LD_VAR 0 5
103814: PPUSH
103815: LD_INT 100
103817: PPUSH
103818: CALL_OW 240
// end else
103822: GO 103838
// ComAttackUnit ( i , e ) ;
103824: LD_VAR 0 5
103828: PPUSH
103829: LD_VAR 0 14
103833: PPUSH
103834: CALL_OW 115
// end else
103838: GO 103941
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
103840: LD_VAR 0 14
103844: PPUSH
103845: LD_EXP 91
103849: PUSH
103850: LD_VAR 0 1
103854: ARRAY
103855: PPUSH
103856: CALL_OW 308
103860: NOT
103861: PUSH
103862: LD_VAR 0 5
103866: PPUSH
103867: LD_VAR 0 14
103871: PPUSH
103872: CALL_OW 296
103876: PUSH
103877: LD_INT 40
103879: GREATEREQUAL
103880: AND
103881: PUSH
103882: LD_VAR 0 5
103886: PPUSH
103887: CALL_OW 256
103891: PUSH
103892: LD_INT 650
103894: LESSEQUAL
103895: OR
103896: PUSH
103897: LD_VAR 0 5
103901: PPUSH
103902: LD_EXP 90
103906: PUSH
103907: LD_VAR 0 1
103911: ARRAY
103912: PPUSH
103913: CALL_OW 308
103917: NOT
103918: AND
103919: IFFALSE 103941
// ComMoveToArea ( i , mc_parking [ base ] ) ;
103921: LD_VAR 0 5
103925: PPUSH
103926: LD_EXP 90
103930: PUSH
103931: LD_VAR 0 1
103935: ARRAY
103936: PPUSH
103937: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
103941: LD_VAR 0 5
103945: PPUSH
103946: CALL_OW 256
103950: PUSH
103951: LD_INT 998
103953: LESS
103954: PUSH
103955: LD_VAR 0 5
103959: PPUSH
103960: CALL_OW 263
103964: PUSH
103965: LD_INT 1
103967: EQUAL
103968: AND
103969: PUSH
103970: LD_VAR 0 5
103974: PPUSH
103975: CALL_OW 311
103979: AND
103980: PUSH
103981: LD_VAR 0 5
103985: PPUSH
103986: LD_EXP 90
103990: PUSH
103991: LD_VAR 0 1
103995: ARRAY
103996: PPUSH
103997: CALL_OW 308
104001: AND
104002: IFFALSE 104056
// begin mech := IsDrivenBy ( i ) ;
104004: LD_ADDR_VAR 0 10
104008: PUSH
104009: LD_VAR 0 5
104013: PPUSH
104014: CALL_OW 311
104018: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
104019: LD_VAR 0 10
104023: PPUSH
104024: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
104028: LD_VAR 0 10
104032: PPUSH
104033: LD_VAR 0 5
104037: PPUSH
104038: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
104042: LD_VAR 0 10
104046: PPUSH
104047: LD_VAR 0 5
104051: PPUSH
104052: CALL_OW 180
// end ; end ; unit_human :
104056: GO 104323
104058: LD_INT 1
104060: DOUBLE
104061: EQUAL
104062: IFTRUE 104066
104064: GO 104322
104066: POP
// begin b := IsInUnit ( i ) ;
104067: LD_ADDR_VAR 0 19
104071: PUSH
104072: LD_VAR 0 5
104076: PPUSH
104077: CALL_OW 310
104081: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
104082: LD_ADDR_VAR 0 20
104086: PUSH
104087: LD_VAR 0 19
104091: NOT
104092: PUSH
104093: LD_VAR 0 19
104097: PPUSH
104098: CALL_OW 266
104102: PUSH
104103: LD_INT 32
104105: PUSH
104106: LD_INT 31
104108: PUSH
104109: EMPTY
104110: LIST
104111: LIST
104112: IN
104113: OR
104114: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
104115: LD_VAR 0 17
104119: PUSH
104120: LD_VAR 0 2
104124: PPUSH
104125: LD_INT 21
104127: PUSH
104128: LD_INT 2
104130: PUSH
104131: EMPTY
104132: LIST
104133: LIST
104134: PPUSH
104135: CALL_OW 72
104139: PUSH
104140: LD_INT 1
104142: LESSEQUAL
104143: OR
104144: PUSH
104145: LD_VAR 0 20
104149: AND
104150: PUSH
104151: LD_VAR 0 5
104155: PUSH
104156: LD_VAR 0 18
104160: IN
104161: NOT
104162: AND
104163: IFFALSE 104256
// begin if b then
104165: LD_VAR 0 19
104169: IFFALSE 104218
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
104171: LD_VAR 0 19
104175: PPUSH
104176: LD_VAR 0 3
104180: PPUSH
104181: LD_VAR 0 19
104185: PPUSH
104186: CALL_OW 74
104190: PPUSH
104191: CALL_OW 296
104195: PUSH
104196: LD_INT 10
104198: LESS
104199: PUSH
104200: LD_VAR 0 19
104204: PPUSH
104205: CALL_OW 461
104209: PUSH
104210: LD_INT 7
104212: NONEQUAL
104213: AND
104214: IFFALSE 104218
// continue ;
104216: GO 103533
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
104218: LD_ADDR_VAR 0 18
104222: PUSH
104223: LD_VAR 0 18
104227: PPUSH
104228: LD_VAR 0 18
104232: PUSH
104233: LD_INT 1
104235: PLUS
104236: PPUSH
104237: LD_VAR 0 5
104241: PPUSH
104242: CALL_OW 1
104246: ST_TO_ADDR
// ComExitBuilding ( i ) ;
104247: LD_VAR 0 5
104251: PPUSH
104252: CALL_OW 122
// end ; if sold_defenders then
104256: LD_VAR 0 18
104260: IFFALSE 104320
// if i in sold_defenders then
104262: LD_VAR 0 5
104266: PUSH
104267: LD_VAR 0 18
104271: IN
104272: IFFALSE 104320
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
104274: LD_VAR 0 5
104278: PPUSH
104279: CALL_OW 314
104283: NOT
104284: PUSH
104285: LD_VAR 0 5
104289: PPUSH
104290: LD_VAR 0 14
104294: PPUSH
104295: CALL_OW 296
104299: PUSH
104300: LD_INT 30
104302: LESS
104303: AND
104304: IFFALSE 104320
// ComAttackUnit ( i , e ) ;
104306: LD_VAR 0 5
104310: PPUSH
104311: LD_VAR 0 14
104315: PPUSH
104316: CALL_OW 115
// end ; end ; end ;
104320: GO 104323
104322: POP
// if IsDead ( i ) then
104323: LD_VAR 0 5
104327: PPUSH
104328: CALL_OW 301
104332: IFFALSE 104350
// defenders := defenders diff i ;
104334: LD_ADDR_VAR 0 2
104338: PUSH
104339: LD_VAR 0 2
104343: PUSH
104344: LD_VAR 0 5
104348: DIFF
104349: ST_TO_ADDR
// end ;
104350: GO 103533
104352: POP
104353: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
104354: LD_VAR 0 3
104358: NOT
104359: PUSH
104360: LD_VAR 0 2
104364: NOT
104365: OR
104366: PUSH
104367: LD_EXP 66
104371: PUSH
104372: LD_VAR 0 1
104376: ARRAY
104377: NOT
104378: OR
104379: IFFALSE 103437
// MC_Reset ( base , 18 ) ;
104381: LD_VAR 0 1
104385: PPUSH
104386: LD_INT 18
104388: PPUSH
104389: CALL 54636 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104393: LD_ADDR_VAR 0 2
104397: PUSH
104398: LD_VAR 0 2
104402: PUSH
104403: LD_VAR 0 2
104407: PPUSH
104408: LD_INT 2
104410: PUSH
104411: LD_INT 25
104413: PUSH
104414: LD_INT 1
104416: PUSH
104417: EMPTY
104418: LIST
104419: LIST
104420: PUSH
104421: LD_INT 25
104423: PUSH
104424: LD_INT 5
104426: PUSH
104427: EMPTY
104428: LIST
104429: LIST
104430: PUSH
104431: LD_INT 25
104433: PUSH
104434: LD_INT 8
104436: PUSH
104437: EMPTY
104438: LIST
104439: LIST
104440: PUSH
104441: LD_INT 25
104443: PUSH
104444: LD_INT 9
104446: PUSH
104447: EMPTY
104448: LIST
104449: LIST
104450: PUSH
104451: EMPTY
104452: LIST
104453: LIST
104454: LIST
104455: LIST
104456: LIST
104457: PPUSH
104458: CALL_OW 72
104462: DIFF
104463: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
104464: LD_VAR 0 3
104468: NOT
104469: PUSH
104470: LD_VAR 0 2
104474: PPUSH
104475: LD_INT 21
104477: PUSH
104478: LD_INT 2
104480: PUSH
104481: EMPTY
104482: LIST
104483: LIST
104484: PPUSH
104485: CALL_OW 72
104489: AND
104490: IFFALSE 104828
// begin tmp := FilterByTag ( defenders , 19 ) ;
104492: LD_ADDR_VAR 0 12
104496: PUSH
104497: LD_VAR 0 2
104501: PPUSH
104502: LD_INT 19
104504: PPUSH
104505: CALL 47109 0 2
104509: ST_TO_ADDR
// if tmp then
104510: LD_VAR 0 12
104514: IFFALSE 104584
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
104516: LD_ADDR_VAR 0 12
104520: PUSH
104521: LD_VAR 0 12
104525: PPUSH
104526: LD_INT 25
104528: PUSH
104529: LD_INT 3
104531: PUSH
104532: EMPTY
104533: LIST
104534: LIST
104535: PPUSH
104536: CALL_OW 72
104540: ST_TO_ADDR
// if tmp then
104541: LD_VAR 0 12
104545: IFFALSE 104584
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
104547: LD_ADDR_EXP 78
104551: PUSH
104552: LD_EXP 78
104556: PPUSH
104557: LD_VAR 0 1
104561: PPUSH
104562: LD_EXP 78
104566: PUSH
104567: LD_VAR 0 1
104571: ARRAY
104572: PUSH
104573: LD_VAR 0 12
104577: UNION
104578: PPUSH
104579: CALL_OW 1
104583: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
104584: LD_VAR 0 1
104588: PPUSH
104589: LD_INT 19
104591: PPUSH
104592: CALL 54636 0 2
// repeat wait ( 0 0$1 ) ;
104596: LD_INT 35
104598: PPUSH
104599: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
104603: LD_EXP 66
104607: PUSH
104608: LD_VAR 0 1
104612: ARRAY
104613: NOT
104614: PUSH
104615: LD_EXP 66
104619: PUSH
104620: LD_VAR 0 1
104624: ARRAY
104625: PUSH
104626: EMPTY
104627: EQUAL
104628: OR
104629: IFFALSE 104666
// begin for i in defenders do
104631: LD_ADDR_VAR 0 5
104635: PUSH
104636: LD_VAR 0 2
104640: PUSH
104641: FOR_IN
104642: IFFALSE 104655
// ComStop ( i ) ;
104644: LD_VAR 0 5
104648: PPUSH
104649: CALL_OW 141
104653: GO 104641
104655: POP
104656: POP
// defenders := [ ] ;
104657: LD_ADDR_VAR 0 2
104661: PUSH
104662: EMPTY
104663: ST_TO_ADDR
// exit ;
104664: GO 104852
// end ; for i in defenders do
104666: LD_ADDR_VAR 0 5
104670: PUSH
104671: LD_VAR 0 2
104675: PUSH
104676: FOR_IN
104677: IFFALSE 104766
// begin if not IsInArea ( i , mc_parking [ base ] ) then
104679: LD_VAR 0 5
104683: PPUSH
104684: LD_EXP 90
104688: PUSH
104689: LD_VAR 0 1
104693: ARRAY
104694: PPUSH
104695: CALL_OW 308
104699: NOT
104700: IFFALSE 104724
// ComMoveToArea ( i , mc_parking [ base ] ) else
104702: LD_VAR 0 5
104706: PPUSH
104707: LD_EXP 90
104711: PUSH
104712: LD_VAR 0 1
104716: ARRAY
104717: PPUSH
104718: CALL_OW 113
104722: GO 104764
// if GetControl ( i ) = control_manual then
104724: LD_VAR 0 5
104728: PPUSH
104729: CALL_OW 263
104733: PUSH
104734: LD_INT 1
104736: EQUAL
104737: IFFALSE 104764
// if IsDrivenBy ( i ) then
104739: LD_VAR 0 5
104743: PPUSH
104744: CALL_OW 311
104748: IFFALSE 104764
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
104750: LD_VAR 0 5
104754: PPUSH
104755: CALL_OW 311
104759: PPUSH
104760: CALL_OW 121
// end ;
104764: GO 104676
104766: POP
104767: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
104768: LD_VAR 0 2
104772: PPUSH
104773: LD_INT 95
104775: PUSH
104776: LD_EXP 90
104780: PUSH
104781: LD_VAR 0 1
104785: ARRAY
104786: PUSH
104787: EMPTY
104788: LIST
104789: LIST
104790: PPUSH
104791: CALL_OW 72
104795: PUSH
104796: LD_VAR 0 2
104800: EQUAL
104801: PUSH
104802: LD_EXP 89
104806: PUSH
104807: LD_VAR 0 1
104811: ARRAY
104812: OR
104813: PUSH
104814: LD_EXP 66
104818: PUSH
104819: LD_VAR 0 1
104823: ARRAY
104824: NOT
104825: OR
104826: IFFALSE 104596
// end ; MC_Reset ( base , 19 ) ;
104828: LD_VAR 0 1
104832: PPUSH
104833: LD_INT 19
104835: PPUSH
104836: CALL 54636 0 2
// MC_Reset ( base , 20 ) ;
104840: LD_VAR 0 1
104844: PPUSH
104845: LD_INT 20
104847: PPUSH
104848: CALL 54636 0 2
// end ;
104852: LD_VAR 0 4
104856: RET
