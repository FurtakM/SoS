// export MissionStart ; export southAreaBlocker ; starting begin southAreaBlocker = true ;
   0: LD_ADDR_EXP 2
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// ResetFog ;
   8: CALL_OW 335
// AnimateTrees ( true ) ;
  12: LD_INT 1
  14: PPUSH
  15: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  19: LD_INT 1
  21: PPUSH
  22: LD_INT 8
  24: PPUSH
  25: CALL_OW 332
// GameType ;
  29: CALL 5444 0 0
// SetBName ( BetaA , beta ) ;
  33: LD_INT 1
  35: PPUSH
  36: LD_STRING beta
  38: PPUSH
  39: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  43: LD_INT 3
  45: PPUSH
  46: LD_STRING beta
  48: PPUSH
  49: CALL_OW 500
// SetResourceType ( GetBase ( BetaA ) , mat_cans , startCrates [ 1 ] ) ;
  53: LD_INT 1
  55: PPUSH
  56: CALL_OW 274
  60: PPUSH
  61: LD_INT 1
  63: PPUSH
  64: LD_EXP 43
  68: PUSH
  69: LD_INT 1
  71: ARRAY
  72: PPUSH
  73: CALL_OW 277
// SetResourceType ( GetBase ( BetaB ) , mat_cans , startCrates [ 2 ] ) ;
  77: LD_INT 3
  79: PPUSH
  80: CALL_OW 274
  84: PPUSH
  85: LD_INT 1
  87: PPUSH
  88: LD_EXP 43
  92: PUSH
  93: LD_INT 2
  95: ARRAY
  96: PPUSH
  97: CALL_OW 277
// PrepareHeroes ;
 101: CALL 2607 0 0
// PrepareBeta ;
 105: CALL 2996 0 0
// HideArea ( 1 , SouthArea ) ;
 109: LD_INT 1
 111: PPUSH
 112: LD_INT 16
 114: PPUSH
 115: CALL_OW 333
// InGameOn ;
 119: CALL_OW 8
// ComHold ( Brighton ) ;
 123: LD_EXP 9
 127: PPUSH
 128: CALL_OW 140
// CenterNowOnUnits ( Brighton ) ;
 132: LD_EXP 9
 136: PPUSH
 137: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
 141: LD_EXP 11
 145: PPUSH
 146: LD_INT 50
 148: PPUSH
 149: LD_INT 42
 151: PPUSH
 152: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
 156: LD_INT 35
 158: PPUSH
 159: CALL_OW 67
 163: LD_EXP 11
 167: PPUSH
 168: LD_EXP 9
 172: PPUSH
 173: CALL_OW 296
 177: PUSH
 178: LD_INT 3
 180: LESS
 181: IFFALSE 156
// ComTurnUnit ( Megan , Brighton ) ;
 183: LD_EXP 11
 187: PPUSH
 188: LD_EXP 9
 192: PPUSH
 193: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 197: LD_EXP 11
 201: PPUSH
 202: LD_STRING DMegan-1a
 204: PPUSH
 205: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 209: LD_INT 10
 211: PPUSH
 212: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 216: LD_EXP 9
 220: PPUSH
 221: LD_EXP 11
 225: PPUSH
 226: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 230: LD_EXP 9
 234: PPUSH
 235: LD_STRING DBrighton-1a
 237: PPUSH
 238: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 242: LD_EXP 11
 246: PPUSH
 247: LD_STRING DMegan-2a
 249: PPUSH
 250: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 254: LD_EXP 9
 258: PPUSH
 259: LD_STRING DBrighton-2a
 261: PPUSH
 262: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 266: LD_EXP 11
 270: PPUSH
 271: LD_INT 40
 273: PPUSH
 274: LD_INT 37
 276: PPUSH
 277: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 281: LD_EXP 11
 285: PPUSH
 286: LD_EXP 9
 290: PPUSH
 291: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 295: LD_EXP 10
 299: PPUSH
 300: LD_INT 50
 302: PPUSH
 303: LD_INT 42
 305: PPUSH
 306: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 310: LD_INT 35
 312: PPUSH
 313: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 317: LD_EXP 9
 321: PPUSH
 322: LD_EXP 10
 326: PPUSH
 327: CALL_OW 296
 331: PUSH
 332: LD_INT 6
 334: LESS
 335: IFFALSE 310
// ComTurnUnit ( Brighton , Palmer ) ;
 337: LD_EXP 9
 341: PPUSH
 342: LD_EXP 10
 346: PPUSH
 347: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 351: LD_EXP 10
 355: PPUSH
 356: LD_EXP 9
 360: PPUSH
 361: CALL_OW 119
// Say ( Palmer , DPalmer-1 ) ;
 365: LD_EXP 10
 369: PPUSH
 370: LD_STRING DPalmer-1
 372: PPUSH
 373: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 377: LD_EXP 9
 381: PPUSH
 382: LD_STRING DBrighton-1
 384: PPUSH
 385: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 389: LD_EXP 10
 393: PPUSH
 394: LD_STRING DPalmer-2
 396: PPUSH
 397: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 401: LD_EXP 9
 405: PPUSH
 406: LD_STRING DBrighton-2
 408: PPUSH
 409: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 413: LD_EXP 10
 417: PPUSH
 418: LD_STRING DPalmer-3
 420: PPUSH
 421: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 425: LD_EXP 9
 429: PPUSH
 430: LD_STRING DBrighton-3
 432: PPUSH
 433: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 437: LD_EXP 10
 441: PPUSH
 442: LD_STRING DPalmer-4
 444: PPUSH
 445: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 449: LD_EXP 10
 453: PPUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 461: LD_INT 35
 463: PPUSH
 464: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 468: LD_EXP 10
 472: PPUSH
 473: CALL_OW 310
 477: PUSH
 478: LD_INT 6
 480: EQUAL
 481: IFFALSE 461
// SayRadio ( Palmer , DPalmer-5 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_STRING DPalmer-5
 490: PPUSH
 491: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 495: LD_EXP 9
 499: PPUSH
 500: LD_INT 59
 502: PPUSH
 503: LD_INT 36
 505: PPUSH
 506: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 510: LD_EXP 11
 514: PPUSH
 515: LD_INT 60
 517: PPUSH
 518: LD_INT 35
 520: PPUSH
 521: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 525: LD_EXP 10
 529: PPUSH
 530: LD_INT 60
 532: PPUSH
 533: LD_INT 34
 535: PPUSH
 536: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 540: LD_EXP 9
 544: PPUSH
 545: LD_INT 99
 547: PPUSH
 548: LD_INT 37
 550: PPUSH
 551: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 555: LD_EXP 11
 559: PPUSH
 560: LD_EXP 9
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 569: LD_EXP 10
 573: PPUSH
 574: LD_EXP 9
 578: PPUSH
 579: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 583: LD_INT 64
 585: PPUSH
 586: LD_INT 40
 588: PPUSH
 589: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 593: LD_EXP 12
 597: PPUSH
 598: LD_INT 13
 600: PPUSH
 601: CALL 12715 0 2
// wait ( 0 0$30 ) ;
 605: LD_INT 1050
 607: PPUSH
 608: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 612: LD_EXP 9
 616: PPUSH
 617: LD_STRING DBrighton-4
 619: PPUSH
 620: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 624: LD_EXP 9
 628: PPUSH
 629: LD_STRING DBrighton-5
 631: PPUSH
 632: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 636: LD_EXP 9
 640: PPUSH
 641: LD_EXP 11
 645: PPUSH
 646: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 650: LD_EXP 9
 654: PPUSH
 655: LD_STRING DBrighton-6
 657: PPUSH
 658: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 662: LD_EXP 11
 666: PPUSH
 667: LD_STRING DMegan-1
 669: PPUSH
 670: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 674: LD_EXP 9
 678: PPUSH
 679: LD_STRING DBrighton-7
 681: PPUSH
 682: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 686: LD_EXP 9
 690: PPUSH
 691: LD_INT 99
 693: PPUSH
 694: LD_INT 37
 696: PPUSH
 697: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 701: LD_EXP 9
 705: PPUSH
 706: LD_STRING DBrighton-8
 708: PPUSH
 709: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 713: LD_STRING C1
 715: PPUSH
 716: CALL_OW 337
// InGameOff ;
 720: CALL_OW 9
// SaveForQuickRestart ;
 724: CALL_OW 22
// MissionStart := true ;
 728: LD_ADDR_EXP 1
 732: PUSH
 733: LD_INT 1
 735: ST_TO_ADDR
// PrepareRUBase_v2 ;
 736: CALL 4719 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 740: LD_ADDR_EXP 69
 744: PUSH
 745: LD_EXP 69
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: PPUSH
 763: CALL_OW 69
 767: PPUSH
 768: CALL_OW 1
 772: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 773: LD_ADDR_EXP 69
 777: PUSH
 778: LD_EXP 69
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: LD_EXP 36
 790: PPUSH
 791: CALL_OW 1
 795: ST_TO_ADDR
// MC_Start ( ) ;
 796: CALL 56026 0 0
// music_nat := 1 ;
 800: LD_ADDR_OWVAR 71
 804: PUSH
 805: LD_INT 1
 807: ST_TO_ADDR
// end ;
 808: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var i , tmp ;
 809: LD_EXP 1
 813: IFFALSE 1237
 815: GO 817
 817: DISABLE
 818: LD_INT 0
 820: PPUSH
 821: PPUSH
// begin wait ( ruArrival ) ;
 822: LD_EXP 42
 826: PPUSH
 827: CALL_OW 67
// PrepareRUArmada ;
 831: CALL 3578 0 0
// wait ( 0 0$3 ) ;
 835: LD_INT 105
 837: PPUSH
 838: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 842: LD_ADDR_VAR 0 2
 846: PUSH
 847: LD_INT 15
 849: PPUSH
 850: LD_INT 0
 852: PPUSH
 853: CALL_OW 517
 857: ST_TO_ADDR
// for i = 1 to RUArmada do
 858: LD_ADDR_VAR 0 1
 862: PUSH
 863: DOUBLE
 864: LD_INT 1
 866: DEC
 867: ST_TO_ADDR
 868: LD_EXP 17
 872: PUSH
 873: FOR_TO
 874: IFFALSE 923
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 876: LD_EXP 17
 880: PUSH
 881: LD_VAR 0 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 1
 894: ARRAY
 895: PUSH
 896: LD_VAR 0 1
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 2
 909: ARRAY
 910: PUSH
 911: LD_VAR 0 1
 915: ARRAY
 916: PPUSH
 917: CALL_OW 111
 921: GO 873
 923: POP
 924: POP
// ArmadaArrived := true ;
 925: LD_ADDR_EXP 3
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 933: LD_EXP 10
 937: PPUSH
 938: LD_STRING DPalmer-A1
 940: PPUSH
 941: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 945: LD_EXP 9
 949: PPUSH
 950: LD_STRING DBrighton-A1
 952: PPUSH
 953: CALL_OW 88
// wait ( 0 0$20 ) ;
 957: LD_INT 700
 959: PPUSH
 960: CALL_OW 67
// PrepareRUBase ;
 964: CALL 4303 0 0
// wait ( 1 1$20 ) ;
 968: LD_INT 2800
 970: PPUSH
 971: CALL_OW 67
// PrepareRUBulldozers ;
 975: CALL 4190 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 979: LD_EXP 18
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: LD_INT 9
 990: PPUSH
 991: CALL 12572 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 995: LD_EXP 18
 999: PUSH
1000: LD_INT 2
1002: ARRAY
1003: PPUSH
1004: LD_INT 11
1006: PPUSH
1007: CALL 12572 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
1011: LD_INT 1
1013: PPUSH
1014: LD_EXP 18
1018: PUSH
1019: LD_INT 1
1021: ARRAY
1022: PPUSH
1023: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1027: LD_INT 1
1029: PPUSH
1030: LD_EXP 18
1034: PUSH
1035: LD_INT 2
1037: ARRAY
1038: PPUSH
1039: CALL_OW 471
// wait ( 1 1$20 ) ;
1043: LD_INT 2800
1045: PPUSH
1046: CALL_OW 67
// ComMoveXY ( Bulldozers , 64 , 114 ) ;
1050: LD_EXP 18
1054: PPUSH
1055: LD_INT 64
1057: PPUSH
1058: LD_INT 114
1060: PPUSH
1061: CALL_OW 111
// wait ( 0 0$10 ) ;
1065: LD_INT 350
1067: PPUSH
1068: CALL_OW 67
// for i := 1 to 2 do
1072: LD_ADDR_VAR 0 1
1076: PUSH
1077: DOUBLE
1078: LD_INT 1
1080: DEC
1081: ST_TO_ADDR
1082: LD_INT 2
1084: PUSH
1085: FOR_TO
1086: IFFALSE 1105
// RemoveUnit ( Bulldozers [ i ] ) ;
1088: LD_EXP 18
1092: PUSH
1093: LD_VAR 0 1
1097: ARRAY
1098: PPUSH
1099: CALL_OW 64
1103: GO 1085
1105: POP
1106: POP
// RemoveEnvironmentArea ( BulldozerArea ) ;
1107: LD_INT 9
1109: PPUSH
1110: CALL_OW 355
// RemoveEnvironmentArea ( BulldozerArea2 ) ;
1114: LD_INT 11
1116: PPUSH
1117: CALL_OW 355
// SayEffect ( DRuSol-A1 ) ;
1121: LD_STRING DRuSol-A1
1123: PPUSH
1124: CALL_OW 96
// AssaultStarted := true ;
1128: LD_ADDR_EXP 8
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// wait ( 0 0$2 ) ;
1136: LD_INT 70
1138: PPUSH
1139: CALL_OW 67
// Say ( Yashin , DDeath-Yas-1 ) ;
1143: LD_EXP 13
1147: PPUSH
1148: LD_STRING DDeath-Yas-1
1150: PPUSH
1151: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-2 ) ;
1155: LD_EXP 15
1159: PPUSH
1160: LD_STRING DDeath-Gay-2
1162: PPUSH
1163: CALL_OW 88
// wait ( 0 0$2 ) ;
1167: LD_INT 70
1169: PPUSH
1170: CALL_OW 67
// Say ( Popov , DDeath-Pop-1 ) ;
1174: LD_EXP 14
1178: PPUSH
1179: LD_STRING DDeath-Pop-1
1181: PPUSH
1182: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1186: LD_EXP 15
1190: PPUSH
1191: LD_STRING DDeath-Gay-1
1193: PPUSH
1194: CALL_OW 88
// wait ( 0 0$5 ) ;
1198: LD_INT 175
1200: PPUSH
1201: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1205: LD_EXP 16
1209: PPUSH
1210: LD_STRING DDeath-Vse-1
1212: PPUSH
1213: CALL_OW 88
// Say ( Popov , DDeath-Pop-2 ) ;
1217: LD_EXP 14
1221: PPUSH
1222: LD_STRING DDeath-Pop-2
1224: PPUSH
1225: CALL_OW 88
// southAreaBlocker = false ;
1229: LD_ADDR_EXP 2
1233: PUSH
1234: LD_INT 0
1236: ST_TO_ADDR
// end ;
1237: PPOPN 2
1239: END
// every 0 0$1 trigger AssaultStarted do var i , tmp ;
1240: LD_EXP 8
1244: IFFALSE 1835
1246: GO 1248
1248: DISABLE
1249: LD_INT 0
1251: PPUSH
1252: PPUSH
// begin PriorityAttack ( 6 , BetaA ) ;
1253: LD_INT 6
1255: PPUSH
1256: LD_INT 1
1258: PPUSH
1259: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1263: LD_INT 6
1265: PPUSH
1266: LD_INT 3
1268: PPUSH
1269: CALL_OW 470
// repeat for i in RuArmada do
1273: LD_ADDR_VAR 0 1
1277: PUSH
1278: LD_EXP 17
1282: PUSH
1283: FOR_IN
1284: IFFALSE 1487
// begin if GetDistUnitXY ( i , 87 , 77 ) < 10 and not GetTag ( i ) then
1286: LD_VAR 0 1
1290: PPUSH
1291: LD_INT 87
1293: PPUSH
1294: LD_INT 77
1296: PPUSH
1297: CALL_OW 297
1301: PUSH
1302: LD_INT 10
1304: LESS
1305: PUSH
1306: LD_VAR 0 1
1310: PPUSH
1311: CALL_OW 110
1315: NOT
1316: AND
1317: IFFALSE 1331
// SetTag ( i , 1 ) ;
1319: LD_VAR 0 1
1323: PPUSH
1324: LD_INT 1
1326: PPUSH
1327: CALL_OW 109
// if GetDistUnitXY ( i , 62 , 48 ) < 10 and GetTag ( i ) < 2 then
1331: LD_VAR 0 1
1335: PPUSH
1336: LD_INT 62
1338: PPUSH
1339: LD_INT 48
1341: PPUSH
1342: CALL_OW 297
1346: PUSH
1347: LD_INT 10
1349: LESS
1350: PUSH
1351: LD_VAR 0 1
1355: PPUSH
1356: CALL_OW 110
1360: PUSH
1361: LD_INT 2
1363: LESS
1364: AND
1365: IFFALSE 1379
// SetTag ( i , 2 ) ;
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_INT 2
1374: PPUSH
1375: CALL_OW 109
// if not GetTag ( i ) then
1379: LD_VAR 0 1
1383: PPUSH
1384: CALL_OW 110
1388: NOT
1389: IFFALSE 1406
// ComAgressiveMove ( i , 87 , 77 ) ;
1391: LD_VAR 0 1
1395: PPUSH
1396: LD_INT 87
1398: PPUSH
1399: LD_INT 77
1401: PPUSH
1402: CALL_OW 114
// if GetTag ( i ) = 1 then
1406: LD_VAR 0 1
1410: PPUSH
1411: CALL_OW 110
1415: PUSH
1416: LD_INT 1
1418: EQUAL
1419: IFFALSE 1436
// ComAgressiveMove ( i , 62 , 48 ) ;
1421: LD_VAR 0 1
1425: PPUSH
1426: LD_INT 62
1428: PPUSH
1429: LD_INT 48
1431: PPUSH
1432: CALL_OW 114
// if GetTag ( i ) = 2 then
1436: LD_VAR 0 1
1440: PPUSH
1441: CALL_OW 110
1445: PUSH
1446: LD_INT 2
1448: EQUAL
1449: IFFALSE 1485
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1451: LD_VAR 0 1
1455: PPUSH
1456: LD_INT 22
1458: PUSH
1459: LD_INT 1
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PPUSH
1466: CALL_OW 69
1470: PPUSH
1471: LD_VAR 0 1
1475: PPUSH
1476: CALL_OW 74
1480: PPUSH
1481: CALL_OW 115
// end ;
1485: GO 1283
1487: POP
1488: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1489: LD_INT 35
1491: PPUSH
1492: CALL_OW 67
1496: LD_INT 1
1498: PUSH
1499: LD_INT 22
1501: PUSH
1502: LD_INT 6
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: PUSH
1509: LD_INT 21
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: EMPTY
1516: LIST
1517: LIST
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PPUSH
1524: CALL_OW 69
1528: PUSH
1529: LD_INT 10
1531: LESS
1532: PUSH
1533: LD_EXP 13
1537: PPUSH
1538: CALL_OW 301
1542: AND
1543: PUSH
1544: LD_EXP 14
1548: PPUSH
1549: CALL_OW 301
1553: AND
1554: PUSH
1555: LD_EXP 15
1559: PPUSH
1560: CALL_OW 301
1564: AND
1565: PUSH
1566: LD_EXP 16
1570: PPUSH
1571: CALL_OW 301
1575: AND
1576: IFFALSE 1273
// AssaultStarted := false ;
1578: LD_ADDR_EXP 8
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 6 ] ) , RUArrivalArea ) ;
1586: LD_INT 22
1588: PUSH
1589: LD_INT 6
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PPUSH
1596: CALL_OW 69
1600: PPUSH
1601: LD_INT 5
1603: PPUSH
1604: CALL_OW 113
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1608: LD_ADDR_EXP 5
1612: PUSH
1613: LD_INT 1
1615: PUSH
1616: LD_INT 22
1618: PUSH
1619: LD_INT 6
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: LD_INT 26
1628: PUSH
1629: LD_INT 1
1631: PUSH
1632: EMPTY
1633: LIST
1634: LIST
1635: PUSH
1636: LD_INT 21
1638: PUSH
1639: LD_INT 1
1641: PUSH
1642: EMPTY
1643: LIST
1644: LIST
1645: PUSH
1646: LD_INT 24
1648: PUSH
1649: LD_INT 500
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: PPUSH
1663: CALL_OW 69
1667: ST_TO_ADDR
// if RuSpeaker then
1668: LD_EXP 5
1672: IFFALSE 1690
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1674: LD_EXP 5
1678: PUSH
1679: LD_INT 1
1681: ARRAY
1682: PPUSH
1683: LD_STRING DRuSol-A2
1685: PPUSH
1686: CALL_OW 88
// wait ( 0 0$30 ) ;
1690: LD_INT 1050
1692: PPUSH
1693: CALL_OW 67
// DialogueOn ;
1697: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1701: LD_EXP 9
1705: PPUSH
1706: LD_STRING DBrighton-B1
1708: PPUSH
1709: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1713: LD_EXP 10
1717: PPUSH
1718: LD_STRING DPalmer-B1
1720: PPUSH
1721: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1725: LD_EXP 9
1729: PPUSH
1730: LD_STRING DBrighton-B2
1732: PPUSH
1733: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1737: LD_EXP 19
1741: PPUSH
1742: LD_STRING DBurlak-B1
1744: PPUSH
1745: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1749: LD_EXP 9
1753: PPUSH
1754: LD_STRING DBrighton-B3
1756: PPUSH
1757: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1761: LD_EXP 10
1765: PPUSH
1766: LD_STRING DPalmer-B2
1768: PPUSH
1769: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1773: LD_EXP 9
1777: PPUSH
1778: LD_STRING DBrighton-B4
1780: PPUSH
1781: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1785: LD_EXP 9
1789: PPUSH
1790: LD_STRING DBrighton-B5
1792: PPUSH
1793: CALL_OW 88
// DialogueOff ;
1797: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1801: LD_STRING C2
1803: PPUSH
1804: CALL_OW 337
// FirstAssaultRepelled := true ;
1808: LD_ADDR_EXP 4
1812: PUSH
1813: LD_INT 1
1815: ST_TO_ADDR
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1816: LD_INT 22
1818: PUSH
1819: LD_INT 6
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 69
1830: PPUSH
1831: CALL_OW 181
// end ;
1835: PPOPN 2
1837: END
// every 0 0$1 trigger FirstAssaultRepelled do var unit , insideUnit ;
1838: LD_EXP 4
1842: IFFALSE 2007
1844: GO 1846
1846: DISABLE
1847: LD_INT 0
1849: PPUSH
1850: PPUSH
// begin enable ;
1851: ENABLE
// if FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) = 0 then
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 22
1857: PUSH
1858: LD_INT 6
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: PPUSH
1868: CALL_OW 70
1872: PUSH
1873: LD_INT 0
1875: EQUAL
1876: IFFALSE 1880
// exit ;
1878: GO 2007
// for unit in FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) do
1880: LD_ADDR_VAR 0 1
1884: PUSH
1885: LD_INT 5
1887: PPUSH
1888: LD_INT 22
1890: PUSH
1891: LD_INT 6
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: PUSH
1898: EMPTY
1899: LIST
1900: PPUSH
1901: CALL_OW 70
1905: PUSH
1906: FOR_IN
1907: IFFALSE 2005
// begin SetSide ( unit , 3 ) ;
1909: LD_VAR 0 1
1913: PPUSH
1914: LD_INT 3
1916: PPUSH
1917: CALL_OW 235
// if ( GetType ( unit ) = unit_vehicle ) then
1921: LD_VAR 0 1
1925: PPUSH
1926: CALL_OW 247
1930: PUSH
1931: LD_INT 2
1933: EQUAL
1934: IFFALSE 1970
// for insideUnit in UnitsInside ( unit ) do
1936: LD_ADDR_VAR 0 2
1940: PUSH
1941: LD_VAR 0 1
1945: PPUSH
1946: CALL_OW 313
1950: PUSH
1951: FOR_IN
1952: IFFALSE 1968
// SetSide ( insideUnit , 3 ) ;
1954: LD_VAR 0 2
1958: PPUSH
1959: LD_INT 3
1961: PPUSH
1962: CALL_OW 235
1966: GO 1951
1968: POP
1969: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
1970: LD_ADDR_EXP 69
1974: PUSH
1975: LD_EXP 69
1979: PPUSH
1980: LD_INT 1
1982: PPUSH
1983: LD_INT 22
1985: PUSH
1986: LD_INT 3
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: PPUSH
1993: CALL_OW 69
1997: PPUSH
1998: CALL_OW 1
2002: ST_TO_ADDR
// end ;
2003: GO 1906
2005: POP
2006: POP
// end ;
2007: PPOPN 2
2009: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
2010: LD_EXP 4
2014: PUSH
2015: LD_EXP 41
2019: PUSH
2020: LD_INT 0
2022: GREATER
2023: AND
2024: IFFALSE 2044
2026: GO 2028
2028: DISABLE
// begin enable ;
2029: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
2030: LD_ADDR_EXP 41
2034: PUSH
2035: LD_EXP 41
2039: PUSH
2040: LD_INT 35
2042: MINUS
2043: ST_TO_ADDR
// end ;
2044: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
2045: LD_EXP 41
2049: PUSH
2050: LD_INT 0
2052: EQUAL
2053: IFFALSE 2159
2055: GO 2057
2057: DISABLE
// begin JMMReinforcement ;
2058: CALL 5047 0 0
// DialogueOn ;
2062: CALL_OW 6
// CenterOnUnits ( JMM ) ;
2066: LD_EXP 37
2070: PPUSH
2071: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
2075: LD_EXP 37
2079: PPUSH
2080: LD_STRING DJMM-F1
2082: PPUSH
2083: CALL_OW 88
// if RussiansDefeated then
2087: LD_EXP 44
2091: IFFALSE 2117
// begin AddMedal ( Russians , 1 ) ;
2093: LD_STRING Russians
2095: PPUSH
2096: LD_INT 1
2098: PPUSH
2099: CALL_OW 101
// Say ( Brighton , DBrighton-F1a ) ;
2103: LD_EXP 9
2107: PPUSH
2108: LD_STRING DBrighton-F1a
2110: PPUSH
2111: CALL_OW 88
// end else
2115: GO 2147
// begin AddMedal ( Russians , - 1 ) ;
2117: LD_STRING Russians
2119: PPUSH
2120: LD_INT 1
2122: NEG
2123: PPUSH
2124: CALL_OW 101
// Say ( Brighton , DBrighton-F1 ) ;
2128: LD_EXP 9
2132: PPUSH
2133: LD_STRING DBrighton-F1
2135: PPUSH
2136: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2140: LD_STRING C3
2142: PPUSH
2143: CALL_OW 337
// end ; DialogueOff ;
2147: CALL_OW 7
// JMM_Arrived := true ;
2151: LD_ADDR_EXP 6
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// end ;
2159: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2160: LD_EXP 6
2164: PUSH
2165: LD_INT 1
2167: PPUSH
2168: LD_EXP 19
2172: PPUSH
2173: CALL_OW 292
2177: AND
2178: IFFALSE 2207
2180: GO 2182
2182: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2183: LD_EXP 19
2187: PPUSH
2188: LD_STRING DBurlak
2190: PPUSH
2191: CALL_OW 88
// Say ( JMM , DJMM ) ;
2195: LD_EXP 37
2199: PPUSH
2200: LD_STRING DJMM
2202: PPUSH
2203: CALL_OW 88
// end ;
2207: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2208: LD_INT 1
2210: PUSH
2211: LD_INT 22
2213: PUSH
2214: LD_INT 1
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PUSH
2221: LD_INT 2
2223: PUSH
2224: LD_INT 34
2226: PUSH
2227: LD_INT 9
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: PUSH
2234: LD_INT 35
2236: PUSH
2237: LD_INT 9
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: PUSH
2259: LD_INT 1
2261: GREATER
2262: IFFALSE 2275
2264: GO 2266
2266: DISABLE
// LaserBuilt := true ;
2267: LD_ADDR_EXP 7
2271: PUSH
2272: LD_INT 1
2274: ST_TO_ADDR
2275: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2276: LD_EXP 8
2280: PUSH
2281: LD_INT 6
2283: PPUSH
2284: LD_INT 1
2286: PUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: LD_INT 35
2299: PUSH
2300: LD_INT 9
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PUSH
2307: EMPTY
2308: LIST
2309: LIST
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PPUSH
2320: LD_EXP 16
2324: PPUSH
2325: CALL_OW 310
2329: PPUSH
2330: CALL_OW 74
2334: PPUSH
2335: CALL_OW 292
2339: AND
2340: IFFALSE 2369
2342: GO 2344
2344: DISABLE
// begin Say ( Sevi , DDeath-Vse-2 ) ;
2345: LD_EXP 16
2349: PPUSH
2350: LD_STRING DDeath-Vse-2
2352: PPUSH
2353: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2357: LD_EXP 13
2361: PPUSH
2362: LD_STRING DDeath-Yas-2
2364: PPUSH
2365: CALL_OW 88
// end ;
2369: END
// every 0 0$1 trigger MissionStart and GetResourceArea ( CratesArea , mat_cans ) < 20 do
2370: LD_EXP 1
2374: PUSH
2375: LD_INT 12
2377: PPUSH
2378: LD_INT 1
2380: PPUSH
2381: CALL_OW 287
2385: PUSH
2386: LD_INT 20
2388: LESS
2389: AND
2390: IFFALSE 2432
2392: GO 2394
2394: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2395: LD_INT 1750
2397: PPUSH
2398: LD_INT 4900
2400: PPUSH
2401: CALL_OW 12
2405: PPUSH
2406: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2410: LD_INT 2
2412: PPUSH
2413: LD_INT 5
2415: PPUSH
2416: CALL_OW 12
2420: PPUSH
2421: LD_INT 12
2423: PPUSH
2424: LD_INT 1
2426: PPUSH
2427: CALL_OW 55
// enable ;
2431: ENABLE
// end ;
2432: END
// every 0 0$1 trigger FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) do var un , x , y ;
2433: LD_INT 17
2435: PPUSH
2436: LD_INT 81
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PPUSH
2446: CALL_OW 70
2450: IFFALSE 2576
2452: GO 2454
2454: DISABLE
2455: LD_INT 0
2457: PPUSH
2458: PPUSH
2459: PPUSH
// begin un := FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) [ 1 ] ;
2460: LD_ADDR_VAR 0 1
2464: PUSH
2465: LD_INT 17
2467: PPUSH
2468: LD_INT 81
2470: PUSH
2471: LD_INT 1
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: PPUSH
2478: CALL_OW 70
2482: PUSH
2483: LD_INT 1
2485: ARRAY
2486: ST_TO_ADDR
// x := GetX ( un ) ;
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: LD_VAR 0 1
2496: PPUSH
2497: CALL_OW 250
2501: ST_TO_ADDR
// y := GetY ( un ) ;
2502: LD_ADDR_VAR 0 3
2506: PUSH
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 251
2516: ST_TO_ADDR
// PlaceSeeing ( x , y , 1 , - 12 ) ;
2517: LD_VAR 0 2
2521: PPUSH
2522: LD_VAR 0 3
2526: PPUSH
2527: LD_INT 1
2529: PPUSH
2530: LD_INT 12
2532: NEG
2533: PPUSH
2534: CALL_OW 330
// CenterNowOnUnits ( un ) ;
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 87
// Say ( Brighton , DBrighton-E1 ) ;
2547: LD_EXP 9
2551: PPUSH
2552: LD_STRING DBrighton-E1
2554: PPUSH
2555: CALL_OW 88
// RemoveSeeing ( x , y , 1 ) ;
2559: LD_VAR 0 2
2563: PPUSH
2564: LD_VAR 0 3
2568: PPUSH
2569: LD_INT 1
2571: PPUSH
2572: CALL_OW 331
// end ;
2576: PPOPN 3
2578: END
// every 0 0$1 trigger MissionStart do
2579: LD_EXP 1
2583: IFFALSE 2606
2585: GO 2587
2587: DISABLE
// begin enable ;
2588: ENABLE
// display_Strings := [ #tick , tick ] ;
2589: LD_ADDR_OWVAR 47
2593: PUSH
2594: LD_STRING #tick
2596: PUSH
2597: LD_OWVAR 1
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: ST_TO_ADDR
// end ; end_of_file
2606: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2607: LD_INT 0
2609: PPUSH
// uc_side := 1 ;
2610: LD_ADDR_OWVAR 20
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// hc_class = class_soldier ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 1
2625: ST_TO_ADDR
// uc_nation := nation_american ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_sex = sex_male ;
2634: LD_ADDR_OWVAR 27
2638: PUSH
2639: LD_INT 1
2641: ST_TO_ADDR
// hc_importance = 110 ;
2642: LD_ADDR_OWVAR 32
2646: PUSH
2647: LD_INT 110
2649: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2650: LD_ADDR_OWVAR 30
2654: PUSH
2655: LD_INT 5
2657: PUSH
2658: LD_INT 4
2660: PUSH
2661: LD_INT 5
2663: PUSH
2664: LD_INT 3
2666: PUSH
2667: EMPTY
2668: LIST
2669: LIST
2670: LIST
2671: LIST
2672: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2673: LD_ADDR_OWVAR 31
2677: PUSH
2678: LD_INT 9
2680: PUSH
2681: LD_INT 6
2683: PUSH
2684: LD_INT 7
2686: PUSH
2687: LD_INT 6
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: LIST
2695: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2696: LD_ADDR_OWVAR 29
2700: PUSH
2701: LD_INT 12
2703: PUSH
2704: LD_INT 10
2706: PUSH
2707: EMPTY
2708: LIST
2709: LIST
2710: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING Gerard Brighton
2718: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2719: LD_ADDR_OWVAR 33
2723: PUSH
2724: LD_STRING Beta_Skirmish
2726: ST_TO_ADDR
// hc_face_number := 1 ;
2727: LD_ADDR_OWVAR 34
2731: PUSH
2732: LD_INT 1
2734: ST_TO_ADDR
// Brighton := CreateHuman ;
2735: LD_ADDR_EXP 9
2739: PUSH
2740: CALL_OW 44
2744: ST_TO_ADDR
// uc_nation := nation_american ;
2745: LD_ADDR_OWVAR 21
2749: PUSH
2750: LD_INT 1
2752: ST_TO_ADDR
// hc_importance = 80 ;
2753: LD_ADDR_OWVAR 32
2757: PUSH
2758: LD_INT 80
2760: ST_TO_ADDR
// hc_sex = sex_male ;
2761: LD_ADDR_OWVAR 27
2765: PUSH
2766: LD_INT 1
2768: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2769: LD_ADDR_OWVAR 30
2773: PUSH
2774: LD_INT 5
2776: PUSH
2777: LD_INT 5
2779: PUSH
2780: LD_INT 3
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: LIST
2790: LIST
2791: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2792: LD_ADDR_OWVAR 31
2796: PUSH
2797: LD_INT 7
2799: PUSH
2800: LD_INT 6
2802: PUSH
2803: LD_INT 5
2805: PUSH
2806: LD_INT 3
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2815: LD_ADDR_OWVAR 29
2819: PUSH
2820: LD_INT 10
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: ST_TO_ADDR
// hc_name := Brian Palmer ;
2830: LD_ADDR_OWVAR 26
2834: PUSH
2835: LD_STRING Brian Palmer
2837: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2838: LD_ADDR_OWVAR 33
2842: PUSH
2843: LD_STRING Beta_Skirmish
2845: ST_TO_ADDR
// hc_face_number := 3 ;
2846: LD_ADDR_OWVAR 34
2850: PUSH
2851: LD_INT 3
2853: ST_TO_ADDR
// Palmer := CreateHuman ;
2854: LD_ADDR_EXP 10
2858: PUSH
2859: CALL_OW 44
2863: ST_TO_ADDR
// hc_class = class_scientistic ;
2864: LD_ADDR_OWVAR 28
2868: PUSH
2869: LD_INT 4
2871: ST_TO_ADDR
// uc_nation := nation_american ;
2872: LD_ADDR_OWVAR 21
2876: PUSH
2877: LD_INT 1
2879: ST_TO_ADDR
// hc_importance = 70 ;
2880: LD_ADDR_OWVAR 32
2884: PUSH
2885: LD_INT 70
2887: ST_TO_ADDR
// hc_sex = sex_female ;
2888: LD_ADDR_OWVAR 27
2892: PUSH
2893: LD_INT 2
2895: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2896: LD_ADDR_OWVAR 30
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 2
2906: PUSH
2907: LD_INT 4
2909: PUSH
2910: LD_INT 6
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: LIST
2917: LIST
2918: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2919: LD_ADDR_OWVAR 31
2923: PUSH
2924: LD_INT 4
2926: PUSH
2927: LD_INT 2
2929: PUSH
2930: LD_INT 5
2932: PUSH
2933: LD_INT 8
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2942: LD_ADDR_OWVAR 29
2946: PUSH
2947: LD_INT 10
2949: PUSH
2950: LD_INT 10
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: ST_TO_ADDR
// hc_name := Megan Armitage ;
2957: LD_ADDR_OWVAR 26
2961: PUSH
2962: LD_STRING Megan Armitage
2964: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2965: LD_ADDR_OWVAR 33
2969: PUSH
2970: LD_STRING Beta_Skirmish
2972: ST_TO_ADDR
// hc_face_number := 4 ;
2973: LD_ADDR_OWVAR 34
2977: PUSH
2978: LD_INT 4
2980: ST_TO_ADDR
// Megan := CreateHuman ;
2981: LD_ADDR_EXP 11
2985: PUSH
2986: CALL_OW 44
2990: ST_TO_ADDR
// end ;
2991: LD_VAR 0 1
2995: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
2996: LD_INT 0
2998: PPUSH
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
// uc_side := 1 ;
3003: LD_ADDR_OWVAR 20
3007: PUSH
3008: LD_INT 1
3010: ST_TO_ADDR
// uc_nation := nation_american ;
3011: LD_ADDR_OWVAR 21
3015: PUSH
3016: LD_INT 1
3018: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
3019: LD_ADDR_VAR 0 2
3023: PUSH
3024: LD_INT 22
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 30
3036: PUSH
3037: LD_INT 32
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PPUSH
3048: CALL_OW 69
3052: PUSH
3053: FOR_IN
3054: IFFALSE 3109
// PlaceWeaponTurret ( i , [ us_light_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
3056: LD_VAR 0 2
3060: PPUSH
3061: LD_INT 3
3063: PUSH
3064: LD_INT 3
3066: PUSH
3067: LD_INT 4
3069: PUSH
3070: LD_INT 5
3072: PUSH
3073: LD_INT 11
3075: PUSH
3076: LD_INT 3
3078: PUSH
3079: LD_INT 4
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 1
3093: PPUSH
3094: LD_INT 7
3096: PPUSH
3097: CALL_OW 12
3101: ARRAY
3102: PPUSH
3103: CALL_OW 431
3107: GO 3053
3109: POP
3110: POP
// hc_name :=  ;
3111: LD_ADDR_OWVAR 26
3115: PUSH
3116: LD_STRING 
3118: ST_TO_ADDR
// hc_gallery :=  ;
3119: LD_ADDR_OWVAR 33
3123: PUSH
3124: LD_STRING 
3126: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
3127: LD_ADDR_VAR 0 2
3131: PUSH
3132: DOUBLE
3133: LD_INT 1
3135: DEC
3136: ST_TO_ADDR
3137: LD_INT 6
3139: PUSH
3140: LD_INT 5
3142: PUSH
3143: LD_INT 5
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_OWVAR 67
3155: ARRAY
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3216
// begin PrepareSoldier ( 1 , game_skill ) ;
3160: LD_INT 1
3162: PPUSH
3163: LD_EXP 39
3167: PPUSH
3168: CALL_OW 381
// un := CreateHuman ;
3172: LD_ADDR_VAR 0 4
3176: PUSH
3177: CALL_OW 44
3181: ST_TO_ADDR
// filter := filter ^ un ;
3182: LD_ADDR_VAR 0 3
3186: PUSH
3187: LD_VAR 0 3
3191: PUSH
3192: LD_VAR 0 4
3196: ADD
3197: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3198: LD_ADDR_VAR 0 5
3202: PUSH
3203: LD_VAR 0 5
3207: PUSH
3208: LD_VAR 0 4
3212: ADD
3213: ST_TO_ADDR
// end ;
3214: GO 3157
3216: POP
3217: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
3218: LD_ADDR_VAR 0 2
3222: PUSH
3223: DOUBLE
3224: LD_INT 1
3226: DEC
3227: ST_TO_ADDR
3228: LD_INT 3
3230: PUSH
3231: LD_INT 2
3233: PUSH
3234: LD_INT 2
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PUSH
3242: LD_OWVAR 67
3246: ARRAY
3247: PUSH
3248: FOR_TO
3249: IFFALSE 3303
// begin PrepareEngineer ( 0 , game_skill ) ;
3251: LD_INT 0
3253: PPUSH
3254: LD_EXP 39
3258: PPUSH
3259: CALL_OW 382
// un := CreateHuman ;
3263: LD_ADDR_VAR 0 4
3267: PUSH
3268: CALL_OW 44
3272: ST_TO_ADDR
// filter := filter ^ un ;
3273: LD_ADDR_VAR 0 3
3277: PUSH
3278: LD_VAR 0 3
3282: PUSH
3283: LD_VAR 0 4
3287: ADD
3288: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3289: LD_VAR 0 4
3293: PPUSH
3294: LD_INT 3
3296: PPUSH
3297: CALL_OW 52
// end ;
3301: GO 3248
3303: POP
3304: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3305: LD_ADDR_VAR 0 2
3309: PUSH
3310: DOUBLE
3311: LD_INT 1
3313: DEC
3314: ST_TO_ADDR
3315: LD_INT 4
3317: PUSH
3318: LD_INT 3
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: PUSH
3335: FOR_TO
3336: IFFALSE 3390
// begin PrepareMechanic ( 0 , game_skill ) ;
3338: LD_INT 0
3340: PPUSH
3341: LD_EXP 39
3345: PPUSH
3346: CALL_OW 383
// un := CreateHuman ;
3350: LD_ADDR_VAR 0 4
3354: PUSH
3355: CALL_OW 44
3359: ST_TO_ADDR
// filter := filter ^ un ;
3360: LD_ADDR_VAR 0 3
3364: PUSH
3365: LD_VAR 0 3
3369: PUSH
3370: LD_VAR 0 4
3374: ADD
3375: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3376: LD_VAR 0 4
3380: PPUSH
3381: LD_INT 8
3383: PPUSH
3384: CALL_OW 52
// end ;
3388: GO 3335
3390: POP
3391: POP
// for i = 1 to 2 do
3392: LD_ADDR_VAR 0 2
3396: PUSH
3397: DOUBLE
3398: LD_INT 1
3400: DEC
3401: ST_TO_ADDR
3402: LD_INT 2
3404: PUSH
3405: FOR_TO
3406: IFFALSE 3460
// begin PrepareScientist ( 0 , game_skill ) ;
3408: LD_INT 0
3410: PPUSH
3411: LD_EXP 39
3415: PPUSH
3416: CALL_OW 384
// un := CreateHuman ;
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: CALL_OW 44
3429: ST_TO_ADDR
// filter := filter ^ un ;
3430: LD_ADDR_VAR 0 3
3434: PUSH
3435: LD_VAR 0 3
3439: PUSH
3440: LD_VAR 0 4
3444: ADD
3445: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_INT 14
3453: PPUSH
3454: CALL_OW 52
// end ;
3458: GO 3405
3460: POP
3461: POP
// for i = 1 to soldiers do
3462: LD_ADDR_VAR 0 2
3466: PUSH
3467: DOUBLE
3468: LD_INT 1
3470: DEC
3471: ST_TO_ADDR
3472: LD_VAR 0 5
3476: PUSH
3477: FOR_TO
3478: IFFALSE 3503
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3480: LD_VAR 0 5
3484: PUSH
3485: LD_VAR 0 2
3489: ARRAY
3490: PPUSH
3491: LD_INT 1
3493: PPUSH
3494: LD_INT 0
3496: PPUSH
3497: CALL_OW 49
3501: GO 3477
3503: POP
3504: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3505: LD_EXP 9
3509: PPUSH
3510: LD_INT 51
3512: PPUSH
3513: LD_INT 43
3515: PPUSH
3516: LD_INT 0
3518: PPUSH
3519: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3523: LD_EXP 10
3527: PPUSH
3528: LD_INT 55
3530: PPUSH
3531: LD_INT 58
3533: PPUSH
3534: LD_INT 0
3536: PPUSH
3537: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3541: LD_EXP 11
3545: PPUSH
3546: LD_INT 39
3548: PPUSH
3549: LD_INT 36
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// BetaSquad := filter diff 0 ;
3559: LD_ADDR_EXP 12
3563: PUSH
3564: LD_VAR 0 3
3568: PUSH
3569: LD_INT 0
3571: DIFF
3572: ST_TO_ADDR
// end ;
3573: LD_VAR 0 1
3577: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3578: LD_INT 0
3580: PPUSH
3581: PPUSH
3582: PPUSH
3583: PPUSH
3584: PPUSH
3585: PPUSH
// uc_side := 6 ;
3586: LD_ADDR_OWVAR 20
3590: PUSH
3591: LD_INT 6
3593: ST_TO_ADDR
// uc_nation := nation_russian ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// soldiers := [ ] ;
3602: LD_ADDR_VAR 0 4
3606: PUSH
3607: EMPTY
3608: ST_TO_ADDR
// vehs := [ ] ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: EMPTY
3615: ST_TO_ADDR
// RUArmada := [ ] ;
3616: LD_ADDR_EXP 17
3620: PUSH
3621: EMPTY
3622: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3623: LD_ADDR_EXP 13
3627: PUSH
3628: LD_STRING Yashin
3630: PPUSH
3631: CALL_OW 25
3635: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3636: LD_ADDR_EXP 14
3640: PUSH
3641: LD_STRING Popov
3643: PPUSH
3644: CALL_OW 25
3648: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3649: LD_ADDR_EXP 15
3653: PUSH
3654: LD_STRING Gaydar
3656: PPUSH
3657: CALL_OW 25
3661: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3662: LD_ADDR_EXP 16
3666: PUSH
3667: LD_STRING Vsevolod
3669: PPUSH
3670: CALL_OW 25
3674: ST_TO_ADDR
// for i = 1 to 16 do
3675: LD_ADDR_VAR 0 2
3679: PUSH
3680: DOUBLE
3681: LD_INT 1
3683: DEC
3684: ST_TO_ADDR
3685: LD_INT 16
3687: PUSH
3688: FOR_TO
3689: IFFALSE 3731
// begin PrepareSoldier ( 0 , game_eskill ) ;
3691: LD_INT 0
3693: PPUSH
3694: LD_EXP 40
3698: PPUSH
3699: CALL_OW 381
// un := CreateHuman ;
3703: LD_ADDR_VAR 0 5
3707: PUSH
3708: CALL_OW 44
3712: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3713: LD_ADDR_VAR 0 4
3717: PUSH
3718: LD_VAR 0 4
3722: PUSH
3723: LD_VAR 0 5
3727: ADD
3728: ST_TO_ADDR
// end ;
3729: GO 3688
3731: POP
3732: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: LD_EXP 13
3742: PUSH
3743: LD_EXP 14
3747: ADD
3748: PUSH
3749: LD_EXP 15
3753: ADD
3754: PUSH
3755: LD_EXP 16
3759: ADD
3760: PUSH
3761: LD_VAR 0 4
3765: ADD
3766: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3767: LD_INT 24
3769: PPUSH
3770: LD_INT 3
3772: PPUSH
3773: LD_INT 1
3775: PPUSH
3776: LD_INT 46
3778: PPUSH
3779: LD_INT 100
3781: PPUSH
3782: CALL 18466 0 5
// for i = 1 to 8 do
3786: LD_ADDR_VAR 0 2
3790: PUSH
3791: DOUBLE
3792: LD_INT 1
3794: DEC
3795: ST_TO_ADDR
3796: LD_INT 8
3798: PUSH
3799: FOR_TO
3800: IFFALSE 3883
// begin vehicle := CreateVehicle ;
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: CALL_OW 45
3811: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3812: LD_VAR 0 4
3816: PUSH
3817: LD_INT 1
3819: ARRAY
3820: PPUSH
3821: LD_VAR 0 3
3825: PPUSH
3826: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3830: LD_ADDR_VAR 0 4
3834: PUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_VAR 0 4
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: DIFF
3849: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3850: LD_VAR 0 3
3854: PPUSH
3855: LD_INT 5
3857: PPUSH
3858: LD_INT 0
3860: PPUSH
3861: CALL_OW 49
// vehs := vehs ^ vehicle ;
3865: LD_ADDR_VAR 0 6
3869: PUSH
3870: LD_VAR 0 6
3874: PUSH
3875: LD_VAR 0 3
3879: ADD
3880: ST_TO_ADDR
// end ;
3881: GO 3799
3883: POP
3884: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3885: LD_INT 24
3887: PPUSH
3888: LD_INT 3
3890: PPUSH
3891: LD_INT 1
3893: PPUSH
3894: LD_INT 43
3896: PPUSH
3897: LD_INT 100
3899: PPUSH
3900: CALL 18466 0 5
// for i = 1 to 8 do
3904: LD_ADDR_VAR 0 2
3908: PUSH
3909: DOUBLE
3910: LD_INT 1
3912: DEC
3913: ST_TO_ADDR
3914: LD_INT 8
3916: PUSH
3917: FOR_TO
3918: IFFALSE 4001
// begin vehicle := CreateVehicle ;
3920: LD_ADDR_VAR 0 3
3924: PUSH
3925: CALL_OW 45
3929: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3930: LD_VAR 0 4
3934: PUSH
3935: LD_INT 1
3937: ARRAY
3938: PPUSH
3939: LD_VAR 0 3
3943: PPUSH
3944: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3948: LD_ADDR_VAR 0 4
3952: PUSH
3953: LD_VAR 0 4
3957: PUSH
3958: LD_VAR 0 4
3962: PUSH
3963: LD_INT 1
3965: ARRAY
3966: DIFF
3967: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3968: LD_VAR 0 3
3972: PPUSH
3973: LD_INT 5
3975: PPUSH
3976: LD_INT 0
3978: PPUSH
3979: CALL_OW 49
// vehs := vehs ^ vehicle ;
3983: LD_ADDR_VAR 0 6
3987: PUSH
3988: LD_VAR 0 6
3992: PUSH
3993: LD_VAR 0 3
3997: ADD
3998: ST_TO_ADDR
// end ;
3999: GO 3917
4001: POP
4002: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
4003: LD_INT 22
4005: PPUSH
4006: LD_INT 3
4008: PPUSH
4009: LD_INT 1
4011: PPUSH
4012: LD_INT 44
4014: PPUSH
4015: LD_INT 100
4017: PPUSH
4018: CALL 18466 0 5
// for i = 1 to 4 do
4022: LD_ADDR_VAR 0 2
4026: PUSH
4027: DOUBLE
4028: LD_INT 1
4030: DEC
4031: ST_TO_ADDR
4032: LD_INT 4
4034: PUSH
4035: FOR_TO
4036: IFFALSE 4119
// begin vehicle := CreateVehicle ;
4038: LD_ADDR_VAR 0 3
4042: PUSH
4043: CALL_OW 45
4047: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4048: LD_VAR 0 4
4052: PUSH
4053: LD_INT 1
4055: ARRAY
4056: PPUSH
4057: LD_VAR 0 3
4061: PPUSH
4062: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4066: LD_ADDR_VAR 0 4
4070: PUSH
4071: LD_VAR 0 4
4075: PUSH
4076: LD_VAR 0 4
4080: PUSH
4081: LD_INT 1
4083: ARRAY
4084: DIFF
4085: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_INT 5
4093: PPUSH
4094: LD_INT 0
4096: PPUSH
4097: CALL_OW 49
// vehs := vehs ^ vehicle ;
4101: LD_ADDR_VAR 0 6
4105: PUSH
4106: LD_VAR 0 6
4110: PUSH
4111: LD_VAR 0 3
4115: ADD
4116: ST_TO_ADDR
// end ;
4117: GO 4035
4119: POP
4120: POP
// RUArmada := vehs ;
4121: LD_ADDR_EXP 17
4125: PUSH
4126: LD_VAR 0 6
4130: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
4131: LD_EXP 13
4135: PPUSH
4136: CALL_OW 310
4140: PUSH
4141: LD_EXP 14
4145: PPUSH
4146: CALL_OW 310
4150: PUSH
4151: LD_EXP 15
4155: PPUSH
4156: CALL_OW 310
4160: PUSH
4161: LD_EXP 16
4165: PPUSH
4166: CALL_OW 310
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: LIST
4176: PPUSH
4177: LD_INT 6
4179: NEG
4180: PPUSH
4181: CALL_OW 242
// end ;
4185: LD_VAR 0 1
4189: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
4190: LD_INT 0
4192: PPUSH
4193: PPUSH
4194: PPUSH
// uc_side := 6 ;
4195: LD_ADDR_OWVAR 20
4199: PUSH
4200: LD_INT 6
4202: ST_TO_ADDR
// uc_nation := nation_russian ;
4203: LD_ADDR_OWVAR 21
4207: PUSH
4208: LD_INT 3
4210: ST_TO_ADDR
// Bulldozers := [ ] ;
4211: LD_ADDR_EXP 18
4215: PUSH
4216: EMPTY
4217: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
4218: LD_INT 24
4220: PPUSH
4221: LD_INT 3
4223: PPUSH
4224: LD_INT 3
4226: PPUSH
4227: LD_INT 53
4229: PPUSH
4230: LD_INT 100
4232: PPUSH
4233: CALL 18466 0 5
// for i = 1 to 2 do
4237: LD_ADDR_VAR 0 2
4241: PUSH
4242: DOUBLE
4243: LD_INT 1
4245: DEC
4246: ST_TO_ADDR
4247: LD_INT 2
4249: PUSH
4250: FOR_TO
4251: IFFALSE 4296
// begin vehicle := CreateVehicle ;
4253: LD_ADDR_VAR 0 3
4257: PUSH
4258: CALL_OW 45
4262: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4263: LD_VAR 0 3
4267: PPUSH
4268: LD_INT 5
4270: PPUSH
4271: LD_INT 0
4273: PPUSH
4274: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4278: LD_ADDR_EXP 18
4282: PUSH
4283: LD_EXP 18
4287: PUSH
4288: LD_VAR 0 3
4292: ADD
4293: ST_TO_ADDR
// end ;
4294: GO 4250
4296: POP
4297: POP
// end ;
4298: LD_VAR 0 1
4302: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4303: LD_INT 0
4305: PPUSH
4306: PPUSH
4307: PPUSH
4308: PPUSH
// uc_side := 3 ;
4309: LD_ADDR_OWVAR 20
4313: PUSH
4314: LD_INT 3
4316: ST_TO_ADDR
// uc_nation := nation_russian ;
4317: LD_ADDR_OWVAR 21
4321: PUSH
4322: LD_INT 3
4324: ST_TO_ADDR
// hc_name :=  ;
4325: LD_ADDR_OWVAR 26
4329: PUSH
4330: LD_STRING 
4332: ST_TO_ADDR
// hc_gallery :=  ;
4333: LD_ADDR_OWVAR 33
4337: PUSH
4338: LD_STRING 
4340: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4341: LD_ADDR_EXP 19
4345: PUSH
4346: LD_STRING Burlak
4348: PPUSH
4349: CALL_OW 25
4353: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4354: LD_ADDR_EXP 20
4358: PUSH
4359: LD_STRING Gleb
4361: PPUSH
4362: CALL_OW 25
4366: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4367: LD_ADDR_EXP 21
4371: PUSH
4372: LD_STRING Furmanov
4374: PPUSH
4375: CALL_OW 25
4379: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4380: LD_ADDR_EXP 22
4384: PUSH
4385: LD_STRING Titov
4387: PPUSH
4388: CALL_OW 25
4392: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4393: LD_ADDR_EXP 23
4397: PUSH
4398: LD_STRING Scholtze
4400: PPUSH
4401: CALL_OW 25
4405: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4406: LD_ADDR_EXP 24
4410: PUSH
4411: LD_STRING Dolgov
4413: PPUSH
4414: CALL_OW 25
4418: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4419: LD_ADDR_EXP 25
4423: PUSH
4424: LD_STRING Kapitsova
4426: PPUSH
4427: CALL_OW 25
4431: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4432: LD_ADDR_EXP 26
4436: PUSH
4437: LD_STRING Karamazov
4439: PPUSH
4440: CALL_OW 25
4444: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4445: LD_ADDR_EXP 27
4449: PUSH
4450: LD_STRING Kirlenkova
4452: PPUSH
4453: CALL_OW 25
4457: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4458: LD_ADDR_EXP 28
4462: PUSH
4463: LD_STRING Kovalyuk
4465: PPUSH
4466: CALL_OW 25
4470: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4471: LD_ADDR_EXP 29
4475: PUSH
4476: LD_STRING Kozlov
4478: PPUSH
4479: CALL_OW 25
4483: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4484: LD_ADDR_EXP 30
4488: PUSH
4489: LD_STRING Kuzmov
4491: PPUSH
4492: CALL_OW 25
4496: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4497: LD_ADDR_EXP 31
4501: PUSH
4502: LD_STRING Lipshchin
4504: PPUSH
4505: CALL_OW 25
4509: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4510: LD_ADDR_EXP 32
4514: PUSH
4515: LD_STRING Oblukov
4517: PPUSH
4518: CALL_OW 25
4522: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4523: LD_ADDR_EXP 33
4527: PUSH
4528: LD_STRING Xavier2
4530: PPUSH
4531: CALL_OW 25
4535: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4536: LD_ADDR_EXP 34
4540: PUSH
4541: LD_STRING Gnyevko
4543: PPUSH
4544: CALL_OW 25
4548: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4549: LD_ADDR_EXP 35
4553: PUSH
4554: LD_STRING Belkov
4556: PPUSH
4557: CALL_OW 25
4561: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4562: LD_ADDR_VAR 0 3
4566: PUSH
4567: LD_EXP 19
4571: PUSH
4572: LD_EXP 20
4576: PUSH
4577: LD_EXP 21
4581: PUSH
4582: LD_EXP 22
4586: PUSH
4587: LD_EXP 23
4591: PUSH
4592: LD_EXP 24
4596: PUSH
4597: LD_EXP 25
4601: PUSH
4602: LD_EXP 26
4606: PUSH
4607: LD_EXP 27
4611: PUSH
4612: LD_EXP 28
4616: PUSH
4617: LD_EXP 29
4621: PUSH
4622: LD_EXP 30
4626: PUSH
4627: LD_EXP 31
4631: PUSH
4632: LD_EXP 32
4636: PUSH
4637: LD_EXP 33
4641: PUSH
4642: LD_EXP 34
4646: PUSH
4647: LD_EXP 35
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ST_TO_ADDR
// for i = 1 to filter do
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: DOUBLE
4677: LD_INT 1
4679: DEC
4680: ST_TO_ADDR
4681: LD_VAR 0 3
4685: PUSH
4686: FOR_TO
4687: IFFALSE 4712
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4689: LD_VAR 0 3
4693: PUSH
4694: LD_VAR 0 2
4698: ARRAY
4699: PPUSH
4700: LD_INT 6
4702: PPUSH
4703: LD_INT 0
4705: PPUSH
4706: CALL_OW 49
4710: GO 4686
4712: POP
4713: POP
// end ;
4714: LD_VAR 0 1
4718: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4719: LD_INT 0
4721: PPUSH
4722: PPUSH
4723: PPUSH
4724: PPUSH
// uc_side := 3 ;
4725: LD_ADDR_OWVAR 20
4729: PUSH
4730: LD_INT 3
4732: ST_TO_ADDR
// uc_nation := nation_russian ;
4733: LD_ADDR_OWVAR 21
4737: PUSH
4738: LD_INT 3
4740: ST_TO_ADDR
// hc_name :=  ;
4741: LD_ADDR_OWVAR 26
4745: PUSH
4746: LD_STRING 
4748: ST_TO_ADDR
// hc_gallery :=  ;
4749: LD_ADDR_OWVAR 33
4753: PUSH
4754: LD_STRING 
4756: ST_TO_ADDR
// for i = 1 to 8 do
4757: LD_ADDR_VAR 0 2
4761: PUSH
4762: DOUBLE
4763: LD_INT 1
4765: DEC
4766: ST_TO_ADDR
4767: LD_INT 8
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4813
// begin PrepareSoldier ( 0 , game_eskill ) ;
4773: LD_INT 0
4775: PPUSH
4776: LD_EXP 40
4780: PPUSH
4781: CALL_OW 381
// un := CreateHuman ;
4785: LD_ADDR_VAR 0 4
4789: PUSH
4790: CALL_OW 44
4794: ST_TO_ADDR
// filter := filter ^ un ;
4795: LD_ADDR_VAR 0 3
4799: PUSH
4800: LD_VAR 0 3
4804: PUSH
4805: LD_VAR 0 4
4809: ADD
4810: ST_TO_ADDR
// end ;
4811: GO 4770
4813: POP
4814: POP
// for i = 1 to 4 do
4815: LD_ADDR_VAR 0 2
4819: PUSH
4820: DOUBLE
4821: LD_INT 1
4823: DEC
4824: ST_TO_ADDR
4825: LD_INT 4
4827: PUSH
4828: FOR_TO
4829: IFFALSE 4871
// begin PrepareEngineer ( 0 , game_eskill ) ;
4831: LD_INT 0
4833: PPUSH
4834: LD_EXP 40
4838: PPUSH
4839: CALL_OW 382
// un := CreateHuman ;
4843: LD_ADDR_VAR 0 4
4847: PUSH
4848: CALL_OW 44
4852: ST_TO_ADDR
// filter := filter ^ un ;
4853: LD_ADDR_VAR 0 3
4857: PUSH
4858: LD_VAR 0 3
4862: PUSH
4863: LD_VAR 0 4
4867: ADD
4868: ST_TO_ADDR
// end ;
4869: GO 4828
4871: POP
4872: POP
// for i = 1 to 6 do
4873: LD_ADDR_VAR 0 2
4877: PUSH
4878: DOUBLE
4879: LD_INT 1
4881: DEC
4882: ST_TO_ADDR
4883: LD_INT 6
4885: PUSH
4886: FOR_TO
4887: IFFALSE 4929
// begin PrepareMechanic ( 0 , game_eskill ) ;
4889: LD_INT 0
4891: PPUSH
4892: LD_EXP 40
4896: PPUSH
4897: CALL_OW 383
// un := CreateHuman ;
4901: LD_ADDR_VAR 0 4
4905: PUSH
4906: CALL_OW 44
4910: ST_TO_ADDR
// filter := filter ^ un ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_VAR 0 3
4920: PUSH
4921: LD_VAR 0 4
4925: ADD
4926: ST_TO_ADDR
// end ;
4927: GO 4886
4929: POP
4930: POP
// for i = 1 to 4 do
4931: LD_ADDR_VAR 0 2
4935: PUSH
4936: DOUBLE
4937: LD_INT 1
4939: DEC
4940: ST_TO_ADDR
4941: LD_INT 4
4943: PUSH
4944: FOR_TO
4945: IFFALSE 4987
// begin PrepareScientist ( 0 , game_eskill ) ;
4947: LD_INT 0
4949: PPUSH
4950: LD_EXP 40
4954: PPUSH
4955: CALL_OW 384
// un := CreateHuman ;
4959: LD_ADDR_VAR 0 4
4963: PUSH
4964: CALL_OW 44
4968: ST_TO_ADDR
// filter := filter ^ un ;
4969: LD_ADDR_VAR 0 3
4973: PUSH
4974: LD_VAR 0 3
4978: PUSH
4979: LD_VAR 0 4
4983: ADD
4984: ST_TO_ADDR
// end ;
4985: GO 4944
4987: POP
4988: POP
// for i = 1 to filter do
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: DOUBLE
4995: LD_INT 1
4997: DEC
4998: ST_TO_ADDR
4999: LD_VAR 0 3
5003: PUSH
5004: FOR_TO
5005: IFFALSE 5030
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
5007: LD_VAR 0 3
5011: PUSH
5012: LD_VAR 0 2
5016: ARRAY
5017: PPUSH
5018: LD_INT 6
5020: PPUSH
5021: LD_INT 0
5023: PPUSH
5024: CALL_OW 49
5028: GO 5004
5030: POP
5031: POP
// RU_SecondPersonnel := filter ;
5032: LD_ADDR_EXP 36
5036: PUSH
5037: LD_VAR 0 3
5041: ST_TO_ADDR
// end ;
5042: LD_VAR 0 1
5046: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
5047: LD_INT 0
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
5055: PPUSH
// uc_side := 1 ;
5056: LD_ADDR_OWVAR 20
5060: PUSH
5061: LD_INT 1
5063: ST_TO_ADDR
// uc_nation := nation_american ;
5064: LD_ADDR_OWVAR 21
5068: PUSH
5069: LD_INT 1
5071: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
5072: LD_ADDR_EXP 37
5076: PUSH
5077: LD_STRING JMM
5079: PPUSH
5080: CALL_OW 25
5084: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
5085: LD_EXP 37
5089: PPUSH
5090: LD_INT 1
5092: PPUSH
5093: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
5097: LD_EXP 37
5101: PPUSH
5102: LD_INT 7
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 49
// mechs := [ ] ;
5112: LD_ADDR_VAR 0 7
5116: PUSH
5117: EMPTY
5118: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
5119: LD_ADDR_VAR 0 2
5123: PUSH
5124: DOUBLE
5125: LD_INT 1
5127: DEC
5128: ST_TO_ADDR
5129: LD_INT 4
5131: PUSH
5132: LD_INT 3
5134: PUSH
5135: LD_INT 3
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: LIST
5142: PUSH
5143: LD_OWVAR 67
5147: ARRAY
5148: PUSH
5149: FOR_TO
5150: IFFALSE 5211
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_EXP 39
5159: PUSH
5160: LD_INT 1
5162: PLUS
5163: PPUSH
5164: CALL_OW 381
// un := CreateHuman ;
5168: LD_ADDR_VAR 0 4
5172: PUSH
5173: CALL_OW 44
5177: ST_TO_ADDR
// soldiers := soldiers ^ un ;
5178: LD_ADDR_VAR 0 3
5182: PUSH
5183: LD_VAR 0 3
5187: PUSH
5188: LD_VAR 0 4
5192: ADD
5193: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
5194: LD_VAR 0 4
5198: PPUSH
5199: LD_INT 7
5201: PPUSH
5202: LD_INT 0
5204: PPUSH
5205: CALL_OW 49
// end ;
5209: GO 5149
5211: POP
5212: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5213: LD_ADDR_VAR 0 2
5217: PUSH
5218: DOUBLE
5219: LD_INT 1
5221: DEC
5222: ST_TO_ADDR
5223: LD_INT 7
5225: PUSH
5226: LD_INT 6
5228: PUSH
5229: LD_INT 4
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: LIST
5236: PUSH
5237: LD_OWVAR 67
5241: ARRAY
5242: PUSH
5243: FOR_TO
5244: IFFALSE 5290
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5246: LD_INT 0
5248: PPUSH
5249: LD_EXP 39
5253: PUSH
5254: LD_INT 1
5256: PLUS
5257: PPUSH
5258: CALL_OW 383
// un := CreateHuman ;
5262: LD_ADDR_VAR 0 4
5266: PUSH
5267: CALL_OW 44
5271: ST_TO_ADDR
// mechs := mechs ^ un ;
5272: LD_ADDR_VAR 0 7
5276: PUSH
5277: LD_VAR 0 7
5281: PUSH
5282: LD_VAR 0 4
5286: ADD
5287: ST_TO_ADDR
// end ;
5288: GO 5243
5290: POP
5291: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5292: LD_INT 3
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 1
5300: PPUSH
5301: LD_INT 5
5303: PPUSH
5304: LD_INT 100
5306: PPUSH
5307: CALL 18466 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5311: LD_ADDR_VAR 0 2
5315: PUSH
5316: DOUBLE
5317: LD_INT 1
5319: DEC
5320: ST_TO_ADDR
5321: LD_INT 7
5323: PUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 4
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: LIST
5334: PUSH
5335: LD_OWVAR 67
5339: ARRAY
5340: PUSH
5341: FOR_TO
5342: IFFALSE 5437
// begin vehicle := CreateVehicle ;
5344: LD_ADDR_VAR 0 6
5348: PUSH
5349: CALL_OW 45
5353: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5354: LD_VAR 0 7
5358: PUSH
5359: LD_INT 1
5361: ARRAY
5362: PPUSH
5363: LD_VAR 0 6
5367: PPUSH
5368: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5372: LD_ADDR_VAR 0 7
5376: PUSH
5377: LD_VAR 0 7
5381: PUSH
5382: LD_VAR 0 7
5386: PUSH
5387: LD_INT 1
5389: ARRAY
5390: DIFF
5391: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5392: LD_VAR 0 6
5396: PPUSH
5397: LD_INT 1
5399: PPUSH
5400: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5404: LD_VAR 0 6
5408: PPUSH
5409: LD_INT 7
5411: PPUSH
5412: LD_INT 0
5414: PPUSH
5415: CALL_OW 49
// vehs := vehs ^ vehicle ;
5419: LD_ADDR_VAR 0 5
5423: PUSH
5424: LD_VAR 0 5
5428: PUSH
5429: LD_VAR 0 6
5433: ADD
5434: ST_TO_ADDR
// end ;
5435: GO 5341
5437: POP
5438: POP
// end ; end_of_file
5439: LD_VAR 0 1
5443: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export startCrates ; export function GameType ; var i , ruStartTechs ; begin
5444: LD_INT 0
5446: PPUSH
5447: PPUSH
5448: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5449: LD_ADDR_OWVAR 67
5453: PUSH
5454: LD_INT 0
5456: PPUSH
5457: CALL_OW 426
5461: ST_TO_ADDR
// game_diff := Difficulty ;
5462: LD_ADDR_EXP 38
5466: PUSH
5467: LD_OWVAR 67
5471: ST_TO_ADDR
// game_skill := [ 7 , 6 , 5 ] [ game_diff ] ;
5472: LD_ADDR_EXP 39
5476: PUSH
5477: LD_INT 7
5479: PUSH
5480: LD_INT 6
5482: PUSH
5483: LD_INT 5
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: LD_EXP 38
5495: ARRAY
5496: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5497: LD_ADDR_EXP 40
5501: PUSH
5502: LD_INT 6
5504: PUSH
5505: LD_INT 7
5507: PUSH
5508: LD_INT 8
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_EXP 38
5520: ARRAY
5521: ST_TO_ADDR
// ruArrival := [ 3 3$00 , 2 2$00 , 1 1$00 ] [ game_diff ] ;
5522: LD_ADDR_EXP 42
5526: PUSH
5527: LD_INT 6300
5529: PUSH
5530: LD_INT 4200
5532: PUSH
5533: LD_INT 2100
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: LIST
5540: PUSH
5541: LD_EXP 38
5545: ARRAY
5546: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5547: LD_ADDR_EXP 41
5551: PUSH
5552: LD_INT 73500
5554: PUSH
5555: LD_INT 94500
5557: PUSH
5558: LD_INT 115500
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: PUSH
5566: LD_EXP 38
5570: ARRAY
5571: ST_TO_ADDR
// ruStartTechs = [ [ tech_Weap1 ] , [ tech_Weap1 , tech_Comp1 ] , [ tech_Weap1 , tech_Weap2 , tech_Comp1 ] ] ;
5572: LD_ADDR_VAR 0 3
5576: PUSH
5577: LD_INT 51
5579: PUSH
5580: EMPTY
5581: LIST
5582: PUSH
5583: LD_INT 51
5585: PUSH
5586: LD_INT 57
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 51
5595: PUSH
5596: LD_INT 52
5598: PUSH
5599: LD_INT 57
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: ST_TO_ADDR
// startCrates = [ [ 300 , 350 ] , [ 230 , 200 ] , [ 150 , 100 ] ] [ game_diff ] ;
5612: LD_ADDR_EXP 43
5616: PUSH
5617: LD_INT 300
5619: PUSH
5620: LD_INT 350
5622: PUSH
5623: EMPTY
5624: LIST
5625: LIST
5626: PUSH
5627: LD_INT 230
5629: PUSH
5630: LD_INT 200
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 150
5639: PUSH
5640: LD_INT 100
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_EXP 38
5656: ARRAY
5657: ST_TO_ADDR
// for i := 1 to ruStartTechs [ game_diff ] do
5658: LD_ADDR_VAR 0 2
5662: PUSH
5663: DOUBLE
5664: LD_INT 1
5666: DEC
5667: ST_TO_ADDR
5668: LD_VAR 0 3
5672: PUSH
5673: LD_EXP 38
5677: ARRAY
5678: PUSH
5679: FOR_TO
5680: IFFALSE 5738
// begin SetTech ( ruStartTechs [ game_diff ] [ i ] , 3 , state_researched ) ;
5682: LD_VAR 0 3
5686: PUSH
5687: LD_EXP 38
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: LD_INT 3
5701: PPUSH
5702: LD_INT 2
5704: PPUSH
5705: CALL_OW 322
// SetTech ( ruStartTechs [ game_diff ] [ i ] , 6 , state_researched ) ;
5709: LD_VAR 0 3
5713: PUSH
5714: LD_EXP 38
5718: ARRAY
5719: PUSH
5720: LD_VAR 0 2
5724: ARRAY
5725: PPUSH
5726: LD_INT 6
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 322
// end ;
5736: GO 5679
5738: POP
5739: POP
// end ; end_of_file
5740: LD_VAR 0 1
5744: RET
// export function CustomEvent ( event ) ; begin
5745: LD_INT 0
5747: PPUSH
// end ;
5748: LD_VAR 0 2
5752: RET
// export function CustomInitMacro ( ) ; begin
5753: LD_INT 0
5755: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5756: LD_INT 1
5758: PPUSH
5759: LD_INT 3
5761: PPUSH
5762: CALL 79354 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5766: LD_INT 1
5768: PPUSH
5769: LD_INT 4
5771: PPUSH
5772: CALL 79298 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5776: LD_INT 1
5778: PPUSH
5779: LD_INT 136
5781: PUSH
5782: LD_INT 130
5784: PUSH
5785: LD_INT 0
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 145
5795: PUSH
5796: LD_INT 123
5798: PUSH
5799: LD_INT 0
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: CALL 78357 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5815: LD_INT 1
5817: PPUSH
5818: LD_INT 43
5820: PUSH
5821: LD_INT 46
5823: PUSH
5824: LD_INT 45
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PPUSH
5832: CALL 79186 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5836: LD_INT 1
5838: PPUSH
5839: LD_INT 3
5841: PPUSH
5842: CALL 78868 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5846: LD_INT 1
5848: PPUSH
5849: LD_INT 3
5851: PPUSH
5852: CALL 78599 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5856: LD_INT 1
5858: PPUSH
5859: LD_INT 8
5861: PPUSH
5862: CALL 78218 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5866: LD_INT 1
5868: PPUSH
5869: LD_INT 22
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: LD_INT 3
5877: PUSH
5878: LD_INT 43
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: PUSH
5887: LD_INT 22
5889: PUSH
5890: LD_INT 1
5892: PUSH
5893: LD_INT 3
5895: PUSH
5896: LD_INT 44
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 22
5907: PUSH
5908: LD_INT 1
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: LD_INT 45
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: PUSH
5923: LD_INT 24
5925: PUSH
5926: LD_INT 1
5928: PUSH
5929: LD_INT 3
5931: PUSH
5932: LD_INT 43
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_INT 24
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 3
5949: PUSH
5950: LD_INT 43
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 24
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: LD_INT 3
5967: PUSH
5968: LD_INT 46
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: PUSH
5977: LD_INT 22
5979: PUSH
5980: LD_INT 1
5982: PUSH
5983: LD_INT 3
5985: PUSH
5986: LD_INT 43
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 22
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: LD_INT 3
6003: PUSH
6004: LD_INT 44
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: LIST
6011: LIST
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PPUSH
6023: CALL 78033 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
6027: LD_INT 1
6029: PPUSH
6030: LD_INT 0
6032: PUSH
6033: LD_INT 127
6035: PUSH
6036: LD_INT 125
6038: PUSH
6039: LD_INT 5
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 6
6050: PUSH
6051: LD_INT 124
6053: PUSH
6054: LD_INT 132
6056: PUSH
6057: LD_INT 0
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 29
6068: PUSH
6069: LD_INT 136
6071: PUSH
6072: LD_INT 130
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 4
6086: PUSH
6087: LD_INT 118
6089: PUSH
6090: LD_INT 114
6092: PUSH
6093: LD_INT 2
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 29
6104: PUSH
6105: LD_INT 145
6107: PUSH
6108: LD_INT 123
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 26
6122: PUSH
6123: LD_INT 150
6125: PUSH
6126: LD_INT 135
6128: PUSH
6129: LD_INT 1
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 26
6140: PUSH
6141: LD_INT 140
6143: PUSH
6144: LD_INT 134
6146: PUSH
6147: LD_INT 2
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_INT 26
6158: PUSH
6159: LD_INT 137
6161: PUSH
6162: LD_INT 121
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 2
6176: PUSH
6177: LD_INT 155
6179: PUSH
6180: LD_INT 130
6182: PUSH
6183: LD_INT 0
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 32
6194: PUSH
6195: LD_INT 155
6197: PUSH
6198: LD_INT 130
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 32
6212: PUSH
6213: LD_INT 130
6215: PUSH
6216: LD_INT 114
6218: PUSH
6219: LD_INT 3
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 32
6230: PUSH
6231: LD_INT 142
6233: PUSH
6234: LD_INT 115
6236: PUSH
6237: LD_INT 3
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 32
6248: PUSH
6249: LD_INT 153
6251: PUSH
6252: LD_INT 120
6254: PUSH
6255: LD_INT 3
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: PPUSH
6279: CALL 77925 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
6283: LD_INT 1
6285: PPUSH
6286: LD_INT 10
6288: PUSH
6289: LD_INT 12
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: PPUSH
6296: CALL 78775 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6300: LD_INT 1
6302: PPUSH
6303: LD_INT 155
6305: PPUSH
6306: LD_INT 130
6308: PPUSH
6309: LD_INT 0
6311: PPUSH
6312: LD_INT 24
6314: PUSH
6315: LD_INT 16
6317: PUSH
6318: LD_INT 17
6320: PUSH
6321: LD_INT 18
6323: PUSH
6324: LD_INT 21
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL 78980 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
6338: LD_INT 2
6340: PPUSH
6341: LD_INT 3
6343: PPUSH
6344: CALL 79354 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 4
6353: PPUSH
6354: CALL 79298 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
6358: LD_INT 2
6360: PPUSH
6361: LD_INT 84
6363: PUSH
6364: LD_INT 125
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: EMPTY
6376: LIST
6377: PPUSH
6378: CALL 78357 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
6382: LD_INT 2
6384: PPUSH
6385: LD_INT 43
6387: PUSH
6388: LD_INT 46
6390: PUSH
6391: LD_INT 45
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: LIST
6398: PPUSH
6399: CALL 79186 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
6403: LD_INT 2
6405: PPUSH
6406: LD_INT 3
6408: PPUSH
6409: CALL 78868 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6413: LD_INT 2
6415: PPUSH
6416: LD_INT 3
6418: PPUSH
6419: CALL 78599 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6423: LD_INT 2
6425: PPUSH
6426: LD_INT 8
6428: PPUSH
6429: CALL 78218 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6433: LD_INT 2
6435: PPUSH
6436: LD_INT 22
6438: PUSH
6439: LD_INT 3
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: LD_INT 43
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 22
6456: PUSH
6457: LD_INT 3
6459: PUSH
6460: LD_INT 3
6462: PUSH
6463: LD_INT 44
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 22
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: LD_INT 3
6480: PUSH
6481: LD_INT 45
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 24
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 43
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 24
6510: PUSH
6511: LD_INT 3
6513: PUSH
6514: LD_INT 3
6516: PUSH
6517: LD_INT 43
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 24
6528: PUSH
6529: LD_INT 3
6531: PUSH
6532: LD_INT 3
6534: PUSH
6535: LD_INT 46
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 22
6546: PUSH
6547: LD_INT 3
6549: PUSH
6550: LD_INT 3
6552: PUSH
6553: LD_INT 43
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 22
6564: PUSH
6565: LD_INT 3
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 44
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: LIST
6588: LIST
6589: PPUSH
6590: CALL 78033 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6594: LD_INT 2
6596: PPUSH
6597: LD_INT 0
6599: PUSH
6600: LD_INT 96
6602: PUSH
6603: LD_INT 125
6605: PUSH
6606: LD_INT 0
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 6
6617: PUSH
6618: LD_INT 74
6620: PUSH
6621: LD_INT 122
6623: PUSH
6624: LD_INT 1
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 30
6635: PUSH
6636: LD_INT 84
6638: PUSH
6639: LD_INT 125
6641: PUSH
6642: LD_INT 1
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 28
6653: PUSH
6654: LD_INT 86
6656: PUSH
6657: LD_INT 128
6659: PUSH
6660: LD_INT 1
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 28
6671: PUSH
6672: LD_INT 85
6674: PUSH
6675: LD_INT 130
6677: PUSH
6678: LD_INT 2
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 28
6689: PUSH
6690: LD_INT 88
6692: PUSH
6693: LD_INT 132
6695: PUSH
6696: LD_INT 5
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: LD_INT 2
6707: PUSH
6708: LD_INT 106
6710: PUSH
6711: LD_INT 130
6713: PUSH
6714: LD_INT 0
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 4
6725: PUSH
6726: LD_INT 99
6728: PUSH
6729: LD_INT 114
6731: PUSH
6732: LD_INT 3
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: PUSH
6741: LD_INT 32
6743: PUSH
6744: LD_INT 72
6746: PUSH
6747: LD_INT 112
6749: PUSH
6750: LD_INT 2
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 32
6761: PUSH
6762: LD_INT 78
6764: PUSH
6765: LD_INT 110
6767: PUSH
6768: LD_INT 3
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: PUSH
6777: LD_INT 32
6779: PUSH
6780: LD_INT 84
6782: PUSH
6783: LD_INT 110
6785: PUSH
6786: LD_INT 2
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: PUSH
6795: LD_INT 32
6797: PUSH
6798: LD_INT 105
6800: PUSH
6801: LD_INT 117
6803: PUSH
6804: LD_INT 3
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: LIST
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL 77925 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6831: LD_INT 2
6833: PPUSH
6834: LD_INT 14
6836: PUSH
6837: LD_INT 11
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PPUSH
6844: CALL 78775 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6848: LD_INT 2
6850: PPUSH
6851: LD_INT 106
6853: PPUSH
6854: LD_INT 130
6856: PPUSH
6857: LD_INT 0
6859: PPUSH
6860: LD_INT 24
6862: PUSH
6863: LD_INT 16
6865: PUSH
6866: LD_INT 17
6868: PUSH
6869: LD_INT 18
6871: PUSH
6872: LD_INT 21
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: LIST
6879: LIST
6880: LIST
6881: PPUSH
6882: CALL 78980 0 5
// end ;
6886: LD_VAR 0 1
6890: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6891: LD_INT 22
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 30
6903: PUSH
6904: LD_INT 3
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PPUSH
6915: CALL_OW 69
6919: IFFALSE 8062
6921: GO 6923
6923: DISABLE
6924: LD_INT 0
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
6931: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
6932: LD_INT 6300
6934: PUSH
6935: LD_INT 4200
6937: PUSH
6938: LD_INT 2100
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: LIST
6945: PUSH
6946: LD_OWVAR 67
6950: ARRAY
6951: PPUSH
6952: CALL_OW 67
// base := 2 ;
6956: LD_ADDR_VAR 0 2
6960: PUSH
6961: LD_INT 2
6963: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
6964: LD_INT 22
6966: PUSH
6967: LD_INT 3
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 30
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PPUSH
6988: CALL_OW 69
6992: NOT
6993: IFFALSE 6997
// continue ;
6995: GO 6932
// case Rand ( 1 , 3 ) of 1 :
6997: LD_INT 1
6999: PPUSH
7000: LD_INT 3
7002: PPUSH
7003: CALL_OW 12
7007: PUSH
7008: LD_INT 1
7010: DOUBLE
7011: EQUAL
7012: IFTRUE 7016
7014: GO 7192
7016: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7017: LD_ADDR_VAR 0 3
7021: PUSH
7022: LD_INT 22
7024: PUSH
7025: LD_INT 3
7027: PUSH
7028: LD_INT 3
7030: PUSH
7031: LD_INT 43
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 24
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 3
7048: PUSH
7049: LD_INT 46
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 24
7060: PUSH
7061: LD_INT 3
7063: PUSH
7064: LD_INT 3
7066: PUSH
7067: LD_INT 43
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 24
7078: PUSH
7079: LD_INT 3
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: LD_INT 46
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PUSH
7094: LD_INT 22
7096: PUSH
7097: LD_INT 3
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 45
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: LD_INT 3
7120: PUSH
7121: LD_INT 43
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: PUSH
7130: LD_INT 24
7132: PUSH
7133: LD_INT 3
7135: PUSH
7136: LD_INT 3
7138: PUSH
7139: LD_INT 46
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: PUSH
7148: LD_INT 22
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 3
7156: PUSH
7157: LD_INT 45
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7176: LD_VAR 0 2
7180: PPUSH
7181: LD_VAR 0 3
7185: PPUSH
7186: CALL 78081 0 2
// end ; 2 :
7190: GO 7523
7192: LD_INT 2
7194: DOUBLE
7195: EQUAL
7196: IFTRUE 7200
7198: GO 7338
7200: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7201: LD_ADDR_VAR 0 3
7205: PUSH
7206: LD_INT 24
7208: PUSH
7209: LD_INT 3
7211: PUSH
7212: LD_INT 3
7214: PUSH
7215: LD_INT 43
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: PUSH
7224: LD_INT 24
7226: PUSH
7227: LD_INT 3
7229: PUSH
7230: LD_INT 3
7232: PUSH
7233: LD_INT 46
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: PUSH
7242: LD_INT 24
7244: PUSH
7245: LD_INT 3
7247: PUSH
7248: LD_INT 3
7250: PUSH
7251: LD_INT 43
7253: PUSH
7254: EMPTY
7255: LIST
7256: LIST
7257: LIST
7258: LIST
7259: PUSH
7260: LD_INT 24
7262: PUSH
7263: LD_INT 3
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: LD_INT 46
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: PUSH
7278: LD_INT 22
7280: PUSH
7281: LD_INT 3
7283: PUSH
7284: LD_INT 3
7286: PUSH
7287: LD_INT 45
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 22
7298: PUSH
7299: LD_INT 3
7301: PUSH
7302: LD_INT 3
7304: PUSH
7305: LD_INT 45
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: LIST
7318: LIST
7319: LIST
7320: LIST
7321: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7322: LD_VAR 0 2
7326: PPUSH
7327: LD_VAR 0 3
7331: PPUSH
7332: CALL 78081 0 2
// end ; 3 :
7336: GO 7523
7338: LD_INT 3
7340: DOUBLE
7341: EQUAL
7342: IFTRUE 7346
7344: GO 7522
7346: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7347: LD_ADDR_VAR 0 3
7351: PUSH
7352: LD_INT 22
7354: PUSH
7355: LD_INT 3
7357: PUSH
7358: LD_INT 3
7360: PUSH
7361: LD_INT 43
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 24
7372: PUSH
7373: LD_INT 3
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: LD_INT 46
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: LD_INT 3
7396: PUSH
7397: LD_INT 43
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: LD_INT 24
7408: PUSH
7409: LD_INT 3
7411: PUSH
7412: LD_INT 3
7414: PUSH
7415: LD_INT 46
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_INT 3
7429: PUSH
7430: LD_INT 3
7432: PUSH
7433: LD_INT 45
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: LD_INT 22
7444: PUSH
7445: LD_INT 3
7447: PUSH
7448: LD_INT 3
7450: PUSH
7451: LD_INT 43
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 24
7462: PUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: LD_INT 46
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: LIST
7476: LIST
7477: PUSH
7478: LD_INT 22
7480: PUSH
7481: LD_INT 3
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 45
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7506: LD_VAR 0 2
7510: PPUSH
7511: LD_VAR 0 3
7515: PPUSH
7516: CALL 78081 0 2
// end ; end ;
7520: GO 7523
7522: POP
// repeat wait ( 0 0$1 ) ;
7523: LD_INT 35
7525: PPUSH
7526: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7530: LD_VAR 0 2
7534: PPUSH
7535: CALL 78429 0 1
7539: PUSH
7540: LD_INT 0
7542: EQUAL
7543: IFFALSE 7523
// wait ( 0 0$30 ) ;
7545: LD_INT 1050
7547: PPUSH
7548: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7552: LD_ADDR_VAR 0 5
7556: PUSH
7557: LD_INT 86
7559: PUSH
7560: LD_INT 77
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 63
7569: PUSH
7570: LD_INT 38
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7581: LD_ADDR_VAR 0 4
7585: PUSH
7586: LD_INT 0
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: LD_INT 0
7594: PUSH
7595: LD_INT 1
7597: PUSH
7598: LD_INT 0
7600: PUSH
7601: LD_INT 0
7603: PUSH
7604: LD_INT 0
7606: PUSH
7607: LD_INT 0
7609: PUSH
7610: LD_INT 1
7612: PUSH
7613: LD_INT 0
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7628: LD_ADDR_VAR 0 6
7632: PUSH
7633: LD_EXP 88
7637: PUSH
7638: LD_VAR 0 2
7642: ARRAY
7643: PUSH
7644: LD_EXP 91
7648: PUSH
7649: LD_VAR 0 2
7653: ARRAY
7654: DIFF
7655: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7656: LD_ADDR_EXP 88
7660: PUSH
7661: LD_EXP 88
7665: PPUSH
7666: LD_VAR 0 2
7670: PPUSH
7671: LD_EXP 88
7675: PUSH
7676: LD_VAR 0 2
7680: ARRAY
7681: PUSH
7682: LD_VAR 0 6
7686: DIFF
7687: PPUSH
7688: CALL_OW 1
7692: ST_TO_ADDR
// if not attackers then
7693: LD_VAR 0 6
7697: NOT
7698: IFFALSE 7702
// continue ;
7700: GO 6932
// repeat wait ( 0 0$1 ) ;
7702: LD_INT 35
7704: PPUSH
7705: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7709: LD_VAR 0 6
7713: PPUSH
7714: LD_INT 60
7716: PUSH
7717: EMPTY
7718: LIST
7719: PPUSH
7720: CALL_OW 72
7724: NOT
7725: IFFALSE 7702
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// for i in attackers do
7734: LD_ADDR_VAR 0 1
7738: PUSH
7739: LD_VAR 0 6
7743: PUSH
7744: FOR_IN
7745: IFFALSE 8029
// begin if IsDead ( i ) then
7747: LD_VAR 0 1
7751: PPUSH
7752: CALL_OW 301
7756: IFFALSE 7774
// attackers := attackers diff i ;
7758: LD_ADDR_VAR 0 6
7762: PUSH
7763: LD_VAR 0 6
7767: PUSH
7768: LD_VAR 0 1
7772: DIFF
7773: ST_TO_ADDR
// if not HasTask ( i ) then
7774: LD_VAR 0 1
7778: PPUSH
7779: CALL_OW 314
7783: NOT
7784: IFFALSE 8027
// begin if not GetTag ( i ) then
7786: LD_VAR 0 1
7790: PPUSH
7791: CALL_OW 110
7795: NOT
7796: IFFALSE 7888
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
7798: LD_VAR 0 1
7802: PPUSH
7803: LD_VAR 0 5
7807: PUSH
7808: LD_INT 1
7810: ARRAY
7811: PUSH
7812: LD_INT 1
7814: ARRAY
7815: PPUSH
7816: LD_VAR 0 5
7820: PUSH
7821: LD_INT 1
7823: ARRAY
7824: PUSH
7825: LD_INT 2
7827: ARRAY
7828: PPUSH
7829: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
7833: LD_VAR 0 1
7837: PPUSH
7838: LD_VAR 0 5
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PUSH
7847: LD_INT 1
7849: ARRAY
7850: PPUSH
7851: LD_VAR 0 5
7855: PUSH
7856: LD_INT 1
7858: ARRAY
7859: PUSH
7860: LD_INT 2
7862: ARRAY
7863: PPUSH
7864: CALL_OW 297
7868: PUSH
7869: LD_INT 8
7871: LESS
7872: IFFALSE 7886
// SetTag ( i , 1 ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_INT 1
7881: PPUSH
7882: CALL_OW 109
// end else
7886: GO 8027
// if GetTag ( i ) = 1 then
7888: LD_VAR 0 1
7892: PPUSH
7893: CALL_OW 110
7897: PUSH
7898: LD_INT 1
7900: EQUAL
7901: IFFALSE 7993
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
7903: LD_VAR 0 1
7907: PPUSH
7908: LD_VAR 0 5
7912: PUSH
7913: LD_INT 2
7915: ARRAY
7916: PUSH
7917: LD_INT 1
7919: ARRAY
7920: PPUSH
7921: LD_VAR 0 5
7925: PUSH
7926: LD_INT 2
7928: ARRAY
7929: PUSH
7930: LD_INT 2
7932: ARRAY
7933: PPUSH
7934: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
7938: LD_VAR 0 1
7942: PPUSH
7943: LD_VAR 0 5
7947: PUSH
7948: LD_INT 2
7950: ARRAY
7951: PUSH
7952: LD_INT 1
7954: ARRAY
7955: PPUSH
7956: LD_VAR 0 5
7960: PUSH
7961: LD_INT 2
7963: ARRAY
7964: PUSH
7965: LD_INT 2
7967: ARRAY
7968: PPUSH
7969: CALL_OW 297
7973: PUSH
7974: LD_INT 8
7976: LESS
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// end else
7991: GO 8027
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_INT 81
8000: PUSH
8001: LD_INT 3
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PPUSH
8008: CALL_OW 69
8012: PPUSH
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL_OW 74
8022: PPUSH
8023: CALL_OW 115
// end ; end ;
8027: GO 7744
8029: POP
8030: POP
// until not attackers ;
8031: LD_VAR 0 6
8035: NOT
8036: IFFALSE 7727
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8038: LD_EXP 69
8042: PUSH
8043: LD_VAR 0 2
8047: ARRAY
8048: PPUSH
8049: LD_INT 50
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 72
8059: NOT
8060: IFFALSE 6932
// end ;
8062: PPOPN 6
8064: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
8065: LD_INT 22
8067: PUSH
8068: LD_INT 3
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: LD_INT 30
8077: PUSH
8078: LD_INT 3
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PPUSH
8089: CALL_OW 69
8093: IFFALSE 9277
8095: GO 8097
8097: DISABLE
8098: LD_INT 0
8100: PPUSH
8101: PPUSH
8102: PPUSH
8103: PPUSH
8104: PPUSH
8105: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
8106: LD_INT 6300
8108: PUSH
8109: LD_INT 4200
8111: PUSH
8112: LD_INT 2100
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PPUSH
8126: CALL_OW 67
// base := 1 ;
8130: LD_ADDR_VAR 0 2
8134: PUSH
8135: LD_INT 1
8137: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8138: LD_INT 22
8140: PUSH
8141: LD_INT 3
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 30
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PPUSH
8162: CALL_OW 69
8166: NOT
8167: IFFALSE 8171
// continue ;
8169: GO 8106
// case Rand ( 1 , 3 ) of 1 :
8171: LD_INT 1
8173: PPUSH
8174: LD_INT 3
8176: PPUSH
8177: CALL_OW 12
8181: PUSH
8182: LD_INT 1
8184: DOUBLE
8185: EQUAL
8186: IFTRUE 8190
8188: GO 8366
8190: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8191: LD_ADDR_VAR 0 3
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 1
8201: PUSH
8202: LD_INT 3
8204: PUSH
8205: LD_INT 43
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 24
8216: PUSH
8217: LD_INT 1
8219: PUSH
8220: LD_INT 3
8222: PUSH
8223: LD_INT 46
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 24
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: LD_INT 3
8240: PUSH
8241: LD_INT 43
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: PUSH
8250: LD_INT 24
8252: PUSH
8253: LD_INT 1
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: LD_INT 46
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: PUSH
8268: LD_INT 22
8270: PUSH
8271: LD_INT 1
8273: PUSH
8274: LD_INT 3
8276: PUSH
8277: LD_INT 45
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: LIST
8284: LIST
8285: PUSH
8286: LD_INT 22
8288: PUSH
8289: LD_INT 1
8291: PUSH
8292: LD_INT 3
8294: PUSH
8295: LD_INT 43
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: LIST
8302: LIST
8303: PUSH
8304: LD_INT 24
8306: PUSH
8307: LD_INT 1
8309: PUSH
8310: LD_INT 3
8312: PUSH
8313: LD_INT 46
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_INT 22
8324: PUSH
8325: LD_INT 1
8327: PUSH
8328: LD_INT 3
8330: PUSH
8331: LD_INT 45
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: LIST
8349: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_VAR 0 3
8359: PPUSH
8360: CALL 78081 0 2
// end ; 2 :
8364: GO 8735
8366: LD_INT 2
8368: DOUBLE
8369: EQUAL
8370: IFTRUE 8374
8372: GO 8550
8374: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8375: LD_ADDR_VAR 0 3
8379: PUSH
8380: LD_INT 24
8382: PUSH
8383: LD_INT 1
8385: PUSH
8386: LD_INT 3
8388: PUSH
8389: LD_INT 43
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 24
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: LD_INT 3
8406: PUSH
8407: LD_INT 46
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 24
8418: PUSH
8419: LD_INT 1
8421: PUSH
8422: LD_INT 3
8424: PUSH
8425: LD_INT 43
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 24
8436: PUSH
8437: LD_INT 1
8439: PUSH
8440: LD_INT 3
8442: PUSH
8443: LD_INT 46
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: LIST
8451: PUSH
8452: LD_INT 22
8454: PUSH
8455: LD_INT 1
8457: PUSH
8458: LD_INT 3
8460: PUSH
8461: LD_INT 45
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 22
8472: PUSH
8473: LD_INT 1
8475: PUSH
8476: LD_INT 3
8478: PUSH
8479: LD_INT 45
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 22
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 3
8496: PUSH
8497: LD_INT 45
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 1
8511: PUSH
8512: LD_INT 3
8514: PUSH
8515: LD_INT 45
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: LIST
8533: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8534: LD_VAR 0 2
8538: PPUSH
8539: LD_VAR 0 3
8543: PPUSH
8544: CALL 78081 0 2
// end ; 3 :
8548: GO 8735
8550: LD_INT 3
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8734
8558: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: LD_INT 22
8566: PUSH
8567: LD_INT 1
8569: PUSH
8570: LD_INT 3
8572: PUSH
8573: LD_INT 43
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_INT 24
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: LD_INT 3
8590: PUSH
8591: LD_INT 46
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 22
8602: PUSH
8603: LD_INT 1
8605: PUSH
8606: LD_INT 3
8608: PUSH
8609: LD_INT 43
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: LIST
8616: LIST
8617: PUSH
8618: LD_INT 24
8620: PUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: LD_INT 46
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: LIST
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: LD_INT 45
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: PUSH
8654: LD_INT 22
8656: PUSH
8657: LD_INT 1
8659: PUSH
8660: LD_INT 3
8662: PUSH
8663: LD_INT 43
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: LIST
8670: LIST
8671: PUSH
8672: LD_INT 24
8674: PUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: LD_INT 46
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 22
8692: PUSH
8693: LD_INT 1
8695: PUSH
8696: LD_INT 3
8698: PUSH
8699: LD_INT 45
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: LIST
8706: LIST
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8718: LD_VAR 0 2
8722: PPUSH
8723: LD_VAR 0 3
8727: PPUSH
8728: CALL 78081 0 2
// end ; end ;
8732: GO 8735
8734: POP
// repeat wait ( 0 0$1 ) ;
8735: LD_INT 35
8737: PPUSH
8738: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8742: LD_VAR 0 2
8746: PPUSH
8747: LD_INT 1
8749: PPUSH
8750: CALL 79499 0 2
8754: PUSH
8755: LD_INT 8
8757: GREATEREQUAL
8758: IFFALSE 8735
// wait ( 0 0$30 ) ;
8760: LD_INT 1050
8762: PPUSH
8763: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8767: LD_ADDR_VAR 0 5
8771: PUSH
8772: LD_INT 144
8774: PUSH
8775: LD_INT 65
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 63
8784: PUSH
8785: LD_INT 38
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: PUSH
8792: EMPTY
8793: LIST
8794: LIST
8795: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8796: LD_ADDR_VAR 0 4
8800: PUSH
8801: LD_INT 0
8803: PUSH
8804: LD_INT 0
8806: PUSH
8807: LD_INT 0
8809: PUSH
8810: LD_INT 1
8812: PUSH
8813: LD_INT 0
8815: PUSH
8816: LD_INT 0
8818: PUSH
8819: LD_INT 0
8821: PUSH
8822: LD_INT 0
8824: PUSH
8825: LD_INT 1
8827: PUSH
8828: LD_INT 0
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_EXP 88
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PUSH
8859: LD_EXP 91
8863: PUSH
8864: LD_VAR 0 2
8868: ARRAY
8869: DIFF
8870: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8871: LD_ADDR_EXP 88
8875: PUSH
8876: LD_EXP 88
8880: PPUSH
8881: LD_VAR 0 2
8885: PPUSH
8886: LD_EXP 88
8890: PUSH
8891: LD_VAR 0 2
8895: ARRAY
8896: PUSH
8897: LD_VAR 0 6
8901: DIFF
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// if not attackers then
8908: LD_VAR 0 6
8912: NOT
8913: IFFALSE 8917
// continue ;
8915: GO 8106
// repeat wait ( 0 0$1 ) ;
8917: LD_INT 35
8919: PPUSH
8920: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8924: LD_VAR 0 6
8928: PPUSH
8929: LD_INT 60
8931: PUSH
8932: EMPTY
8933: LIST
8934: PPUSH
8935: CALL_OW 72
8939: NOT
8940: IFFALSE 8917
// repeat wait ( 0 0$1 ) ;
8942: LD_INT 35
8944: PPUSH
8945: CALL_OW 67
// for i in attackers do
8949: LD_ADDR_VAR 0 1
8953: PUSH
8954: LD_VAR 0 6
8958: PUSH
8959: FOR_IN
8960: IFFALSE 9244
// begin if IsDead ( i ) then
8962: LD_VAR 0 1
8966: PPUSH
8967: CALL_OW 301
8971: IFFALSE 8989
// attackers := attackers diff i ;
8973: LD_ADDR_VAR 0 6
8977: PUSH
8978: LD_VAR 0 6
8982: PUSH
8983: LD_VAR 0 1
8987: DIFF
8988: ST_TO_ADDR
// if not HasTask ( i ) then
8989: LD_VAR 0 1
8993: PPUSH
8994: CALL_OW 314
8998: NOT
8999: IFFALSE 9242
// begin if not GetTag ( i ) then
9001: LD_VAR 0 1
9005: PPUSH
9006: CALL_OW 110
9010: NOT
9011: IFFALSE 9103
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
9013: LD_VAR 0 1
9017: PPUSH
9018: LD_VAR 0 5
9022: PUSH
9023: LD_INT 1
9025: ARRAY
9026: PUSH
9027: LD_INT 1
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 5
9035: PUSH
9036: LD_INT 1
9038: ARRAY
9039: PUSH
9040: LD_INT 2
9042: ARRAY
9043: PPUSH
9044: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
9048: LD_VAR 0 1
9052: PPUSH
9053: LD_VAR 0 5
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PUSH
9062: LD_INT 1
9064: ARRAY
9065: PPUSH
9066: LD_VAR 0 5
9070: PUSH
9071: LD_INT 1
9073: ARRAY
9074: PUSH
9075: LD_INT 2
9077: ARRAY
9078: PPUSH
9079: CALL_OW 297
9083: PUSH
9084: LD_INT 8
9086: LESS
9087: IFFALSE 9101
// SetTag ( i , 1 ) ;
9089: LD_VAR 0 1
9093: PPUSH
9094: LD_INT 1
9096: PPUSH
9097: CALL_OW 109
// end else
9101: GO 9242
// if GetTag ( i ) = 1 then
9103: LD_VAR 0 1
9107: PPUSH
9108: CALL_OW 110
9112: PUSH
9113: LD_INT 1
9115: EQUAL
9116: IFFALSE 9208
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
9118: LD_VAR 0 1
9122: PPUSH
9123: LD_VAR 0 5
9127: PUSH
9128: LD_INT 2
9130: ARRAY
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_VAR 0 5
9140: PUSH
9141: LD_INT 2
9143: ARRAY
9144: PUSH
9145: LD_INT 2
9147: ARRAY
9148: PPUSH
9149: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
9153: LD_VAR 0 1
9157: PPUSH
9158: LD_VAR 0 5
9162: PUSH
9163: LD_INT 2
9165: ARRAY
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 5
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PUSH
9180: LD_INT 2
9182: ARRAY
9183: PPUSH
9184: CALL_OW 297
9188: PUSH
9189: LD_INT 8
9191: LESS
9192: IFFALSE 9206
// SetTag ( i , 2 ) ;
9194: LD_VAR 0 1
9198: PPUSH
9199: LD_INT 2
9201: PPUSH
9202: CALL_OW 109
// end else
9206: GO 9242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9208: LD_VAR 0 1
9212: PPUSH
9213: LD_INT 81
9215: PUSH
9216: LD_INT 3
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: PPUSH
9223: CALL_OW 69
9227: PPUSH
9228: LD_VAR 0 1
9232: PPUSH
9233: CALL_OW 74
9237: PPUSH
9238: CALL_OW 115
// end ; end ;
9242: GO 8959
9244: POP
9245: POP
// until not attackers ;
9246: LD_VAR 0 6
9250: NOT
9251: IFFALSE 8942
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
9253: LD_EXP 69
9257: PUSH
9258: LD_VAR 0 2
9262: ARRAY
9263: PPUSH
9264: LD_INT 50
9266: PUSH
9267: EMPTY
9268: LIST
9269: PPUSH
9270: CALL_OW 72
9274: NOT
9275: IFFALSE 8106
// end ;
9277: PPOPN 6
9279: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9280: LD_EXP 4
9284: PUSH
9285: LD_INT 22
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 21
9297: PUSH
9298: LD_INT 1
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 69
9313: PUSH
9314: LD_INT 0
9316: EQUAL
9317: AND
9318: IFFALSE 9331
9320: GO 9322
9322: DISABLE
// RussiansDefeated := true ;
9323: LD_ADDR_EXP 44
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
9331: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
9332: LD_EXP 4
9336: PUSH
9337: LD_EXP 6
9341: NOT
9342: AND
9343: IFFALSE 10767
9345: GO 9347
9347: DISABLE
9348: LD_INT 0
9350: PPUSH
9351: PPUSH
9352: PPUSH
9353: PPUSH
9354: PPUSH
9355: PPUSH
9356: PPUSH
9357: PPUSH
9358: PPUSH
9359: PPUSH
9360: PPUSH
9361: PPUSH
// begin wait ( [ Rand ( 4 4$00 , 4 4$30 ) , Rand ( 4 4$30 , 3 3$30 ) , Rand ( 3 3$00 , 2 2$00 ) ] [ Difficulty ] ) ;
9362: LD_INT 8400
9364: PPUSH
9365: LD_INT 9450
9367: PPUSH
9368: CALL_OW 12
9372: PUSH
9373: LD_INT 9450
9375: PPUSH
9376: LD_INT 7350
9378: PPUSH
9379: CALL_OW 12
9383: PUSH
9384: LD_INT 6300
9386: PPUSH
9387: LD_INT 4200
9389: PPUSH
9390: CALL_OW 12
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: LD_OWVAR 67
9404: ARRAY
9405: PPUSH
9406: CALL_OW 67
// filter := [ ] ;
9410: LD_ADDR_VAR 0 3
9414: PUSH
9415: EMPTY
9416: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9417: LD_ADDR_VAR 0 4
9421: PUSH
9422: LD_INT 2
9424: PPUSH
9425: LD_INT 3
9427: PPUSH
9428: CALL_OW 12
9432: PUSH
9433: LD_INT 3
9435: PPUSH
9436: LD_INT 4
9438: PPUSH
9439: CALL_OW 12
9443: PUSH
9444: LD_INT 3
9446: PPUSH
9447: LD_INT 5
9449: PPUSH
9450: CALL_OW 12
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: LIST
9459: PUSH
9460: LD_OWVAR 67
9464: ARRAY
9465: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 1
9473: PUSH
9474: LD_INT 1
9476: PPUSH
9477: LD_INT 2
9479: PPUSH
9480: CALL_OW 12
9484: PUSH
9485: LD_INT 2
9487: PPUSH
9488: LD_INT 3
9490: PPUSH
9491: CALL_OW 12
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: LIST
9500: PUSH
9501: LD_OWVAR 67
9505: ARRAY
9506: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9507: LD_ADDR_VAR 0 6
9511: PUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: PUSH
9523: LD_INT 2
9525: PPUSH
9526: LD_INT 4
9528: PPUSH
9529: CALL_OW 12
9533: PUSH
9534: LD_INT 3
9536: PPUSH
9537: LD_INT 5
9539: PPUSH
9540: CALL_OW 12
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_OWVAR 67
9554: ARRAY
9555: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
9556: LD_ADDR_VAR 0 8
9560: PUSH
9561: LD_INT 1
9563: PUSH
9564: LD_INT 2
9566: PUSH
9567: LD_INT 2
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: LD_OWVAR 67
9579: ARRAY
9580: ST_TO_ADDR
// uc_side := 3 ;
9581: LD_ADDR_OWVAR 20
9585: PUSH
9586: LD_INT 3
9588: ST_TO_ADDR
// uc_nation := nation_russian ;
9589: LD_ADDR_OWVAR 21
9593: PUSH
9594: LD_INT 3
9596: ST_TO_ADDR
// for i = 1 to soldiers do
9597: LD_ADDR_VAR 0 1
9601: PUSH
9602: DOUBLE
9603: LD_INT 1
9605: DEC
9606: ST_TO_ADDR
9607: LD_VAR 0 4
9611: PUSH
9612: FOR_TO
9613: IFFALSE 9655
// begin PrepareSoldier ( 0 , game_eskill ) ;
9615: LD_INT 0
9617: PPUSH
9618: LD_EXP 40
9622: PPUSH
9623: CALL_OW 381
// un := CreateHuman ;
9627: LD_ADDR_VAR 0 2
9631: PUSH
9632: CALL_OW 44
9636: ST_TO_ADDR
// filter := filter ^ un ;
9637: LD_ADDR_VAR 0 3
9641: PUSH
9642: LD_VAR 0 3
9646: PUSH
9647: LD_VAR 0 2
9651: ADD
9652: ST_TO_ADDR
// end ;
9653: GO 9612
9655: POP
9656: POP
// for i = 1 to bazookas do
9657: LD_ADDR_VAR 0 1
9661: PUSH
9662: DOUBLE
9663: LD_INT 1
9665: DEC
9666: ST_TO_ADDR
9667: LD_VAR 0 5
9671: PUSH
9672: FOR_TO
9673: IFFALSE 9723
// begin PrepareSoldier ( 0 , game_eskill ) ;
9675: LD_INT 0
9677: PPUSH
9678: LD_EXP 40
9682: PPUSH
9683: CALL_OW 381
// hc_class := class_bazooker ;
9687: LD_ADDR_OWVAR 28
9691: PUSH
9692: LD_INT 9
9694: ST_TO_ADDR
// un := CreateHuman ;
9695: LD_ADDR_VAR 0 2
9699: PUSH
9700: CALL_OW 44
9704: ST_TO_ADDR
// filter := filter ^ un ;
9705: LD_ADDR_VAR 0 3
9709: PUSH
9710: LD_VAR 0 3
9714: PUSH
9715: LD_VAR 0 2
9719: ADD
9720: ST_TO_ADDR
// end ;
9721: GO 9672
9723: POP
9724: POP
// for i = 1 to medics do
9725: LD_ADDR_VAR 0 1
9729: PUSH
9730: DOUBLE
9731: LD_INT 1
9733: DEC
9734: ST_TO_ADDR
9735: LD_VAR 0 8
9739: PUSH
9740: FOR_TO
9741: IFFALSE 9783
// begin PrepareScientist ( 0 , game_eskill ) ;
9743: LD_INT 0
9745: PPUSH
9746: LD_EXP 40
9750: PPUSH
9751: CALL_OW 384
// un := CreateHuman ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: CALL_OW 44
9764: ST_TO_ADDR
// filter := filter ^ un ;
9765: LD_ADDR_VAR 0 3
9769: PUSH
9770: LD_VAR 0 3
9774: PUSH
9775: LD_VAR 0 2
9779: ADD
9780: ST_TO_ADDR
// end ;
9781: GO 9740
9783: POP
9784: POP
// for i = 1 to vehs do
9785: LD_ADDR_VAR 0 1
9789: PUSH
9790: DOUBLE
9791: LD_INT 1
9793: DEC
9794: ST_TO_ADDR
9795: LD_VAR 0 6
9799: PUSH
9800: FOR_TO
9801: IFFALSE 9993
// begin case Rand ( 1 , 5 ) of 1 :
9803: LD_INT 1
9805: PPUSH
9806: LD_INT 5
9808: PPUSH
9809: CALL_OW 12
9813: PUSH
9814: LD_INT 1
9816: DOUBLE
9817: EQUAL
9818: IFTRUE 9822
9820: GO 9844
9822: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
9823: LD_INT 22
9825: PPUSH
9826: LD_INT 3
9828: PPUSH
9829: LD_INT 3
9831: PPUSH
9832: LD_INT 43
9834: PPUSH
9835: LD_INT 100
9837: PPUSH
9838: CALL 18466 0 5
9842: GO 9965
9844: LD_INT 2
9846: DOUBLE
9847: EQUAL
9848: IFTRUE 9852
9850: GO 9874
9852: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
9853: LD_INT 22
9855: PPUSH
9856: LD_INT 3
9858: PPUSH
9859: LD_INT 3
9861: PPUSH
9862: LD_INT 44
9864: PPUSH
9865: LD_INT 100
9867: PPUSH
9868: CALL 18466 0 5
9872: GO 9965
9874: LD_INT 3
9876: DOUBLE
9877: EQUAL
9878: IFTRUE 9882
9880: GO 9904
9882: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
9883: LD_INT 22
9885: PPUSH
9886: LD_INT 3
9888: PPUSH
9889: LD_INT 3
9891: PPUSH
9892: LD_INT 45
9894: PPUSH
9895: LD_INT 100
9897: PPUSH
9898: CALL 18466 0 5
9902: GO 9965
9904: LD_INT 4
9906: DOUBLE
9907: EQUAL
9908: IFTRUE 9912
9910: GO 9934
9912: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
9913: LD_INT 24
9915: PPUSH
9916: LD_INT 3
9918: PPUSH
9919: LD_INT 3
9921: PPUSH
9922: LD_INT 43
9924: PPUSH
9925: LD_INT 100
9927: PPUSH
9928: CALL 18466 0 5
9932: GO 9965
9934: LD_INT 5
9936: DOUBLE
9937: EQUAL
9938: IFTRUE 9942
9940: GO 9964
9942: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
9943: LD_INT 24
9945: PPUSH
9946: LD_INT 3
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 46
9954: PPUSH
9955: LD_INT 100
9957: PPUSH
9958: CALL 18466 0 5
9962: GO 9965
9964: POP
// vehicle := CreateVehicle ;
9965: LD_ADDR_VAR 0 7
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// filter := filter ^ vehicle ;
9975: LD_ADDR_VAR 0 3
9979: PUSH
9980: LD_VAR 0 3
9984: PUSH
9985: LD_VAR 0 7
9989: ADD
9990: ST_TO_ADDR
// end ;
9991: GO 9800
9993: POP
9994: POP
// for i = 1 to filter do
9995: LD_ADDR_VAR 0 1
9999: PUSH
10000: DOUBLE
10001: LD_INT 1
10003: DEC
10004: ST_TO_ADDR
10005: LD_VAR 0 3
10009: PUSH
10010: FOR_TO
10011: IFFALSE 10036
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
10013: LD_VAR 0 3
10017: PUSH
10018: LD_VAR 0 1
10022: ARRAY
10023: PPUSH
10024: LD_INT 14
10026: PPUSH
10027: LD_INT 0
10029: PPUSH
10030: CALL_OW 49
10034: GO 10010
10036: POP
10037: POP
// case Rand ( 1 , 3 ) of 1 :
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 3
10043: PPUSH
10044: CALL_OW 12
10048: PUSH
10049: LD_INT 1
10051: DOUBLE
10052: EQUAL
10053: IFTRUE 10057
10055: GO 10111
10057: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
10058: LD_ADDR_VAR 0 11
10062: PUSH
10063: LD_INT 165
10065: PUSH
10066: LD_INT 114
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PUSH
10073: LD_INT 104
10075: PUSH
10076: LD_INT 108
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PUSH
10083: LD_INT 86
10085: PUSH
10086: LD_INT 77
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PUSH
10093: LD_INT 63
10095: PUSH
10096: LD_INT 38
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: ST_TO_ADDR
10109: GO 10236
10111: LD_INT 2
10113: DOUBLE
10114: EQUAL
10115: IFTRUE 10119
10117: GO 10173
10119: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
10120: LD_ADDR_VAR 0 11
10124: PUSH
10125: LD_INT 165
10127: PUSH
10128: LD_INT 114
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 146
10137: PUSH
10138: LD_INT 71
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: LD_INT 112
10147: PUSH
10148: LD_INT 41
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PUSH
10155: LD_INT 63
10157: PUSH
10158: LD_INT 38
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: ST_TO_ADDR
10171: GO 10236
10173: LD_INT 3
10175: DOUBLE
10176: EQUAL
10177: IFTRUE 10181
10179: GO 10235
10181: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
10182: LD_ADDR_VAR 0 11
10186: PUSH
10187: LD_INT 165
10189: PUSH
10190: LD_INT 114
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 63
10199: PUSH
10200: LD_INT 99
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 55
10209: PUSH
10210: LD_INT 77
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PUSH
10217: LD_INT 63
10219: PUSH
10220: LD_INT 38
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: ST_TO_ADDR
10233: GO 10236
10235: POP
// attackers := filter ;
10236: LD_ADDR_VAR 0 10
10240: PUSH
10241: LD_VAR 0 3
10245: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// for i in attackers do
10253: LD_ADDR_VAR 0 1
10257: PUSH
10258: LD_VAR 0 10
10262: PUSH
10263: FOR_IN
10264: IFFALSE 10758
// begin if IsDead ( i ) then
10266: LD_VAR 0 1
10270: PPUSH
10271: CALL_OW 301
10275: IFFALSE 10293
// attackers := attackers diff i ;
10277: LD_ADDR_VAR 0 10
10281: PUSH
10282: LD_VAR 0 10
10286: PUSH
10287: LD_VAR 0 1
10291: DIFF
10292: ST_TO_ADDR
// if not HasTask ( i ) then
10293: LD_VAR 0 1
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10756
// begin if not GetTag ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 110
10314: NOT
10315: IFFALSE 10407
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
10317: LD_VAR 0 1
10321: PPUSH
10322: LD_VAR 0 11
10326: PUSH
10327: LD_INT 1
10329: ARRAY
10330: PUSH
10331: LD_INT 1
10333: ARRAY
10334: PPUSH
10335: LD_VAR 0 11
10339: PUSH
10340: LD_INT 1
10342: ARRAY
10343: PUSH
10344: LD_INT 2
10346: ARRAY
10347: PPUSH
10348: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
10352: LD_VAR 0 1
10356: PPUSH
10357: LD_VAR 0 11
10361: PUSH
10362: LD_INT 1
10364: ARRAY
10365: PUSH
10366: LD_INT 1
10368: ARRAY
10369: PPUSH
10370: LD_VAR 0 11
10374: PUSH
10375: LD_INT 1
10377: ARRAY
10378: PUSH
10379: LD_INT 2
10381: ARRAY
10382: PPUSH
10383: CALL_OW 297
10387: PUSH
10388: LD_INT 8
10390: LESS
10391: IFFALSE 10405
// SetTag ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 109
// end else
10405: GO 10756
// if GetTag ( i ) = 1 then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 110
10416: PUSH
10417: LD_INT 1
10419: EQUAL
10420: IFFALSE 10512
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
10422: LD_VAR 0 1
10426: PPUSH
10427: LD_VAR 0 11
10431: PUSH
10432: LD_INT 2
10434: ARRAY
10435: PUSH
10436: LD_INT 1
10438: ARRAY
10439: PPUSH
10440: LD_VAR 0 11
10444: PUSH
10445: LD_INT 2
10447: ARRAY
10448: PUSH
10449: LD_INT 2
10451: ARRAY
10452: PPUSH
10453: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
10457: LD_VAR 0 1
10461: PPUSH
10462: LD_VAR 0 11
10466: PUSH
10467: LD_INT 2
10469: ARRAY
10470: PUSH
10471: LD_INT 1
10473: ARRAY
10474: PPUSH
10475: LD_VAR 0 11
10479: PUSH
10480: LD_INT 2
10482: ARRAY
10483: PUSH
10484: LD_INT 2
10486: ARRAY
10487: PPUSH
10488: CALL_OW 297
10492: PUSH
10493: LD_INT 8
10495: LESS
10496: IFFALSE 10510
// SetTag ( i , 2 ) ;
10498: LD_VAR 0 1
10502: PPUSH
10503: LD_INT 2
10505: PPUSH
10506: CALL_OW 109
// end else
10510: GO 10756
// if GetTag ( i ) = 2 then
10512: LD_VAR 0 1
10516: PPUSH
10517: CALL_OW 110
10521: PUSH
10522: LD_INT 2
10524: EQUAL
10525: IFFALSE 10617
// begin ComAgressiveMove ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) ;
10527: LD_VAR 0 1
10531: PPUSH
10532: LD_VAR 0 11
10536: PUSH
10537: LD_INT 3
10539: ARRAY
10540: PUSH
10541: LD_INT 1
10543: ARRAY
10544: PPUSH
10545: LD_VAR 0 11
10549: PUSH
10550: LD_INT 3
10552: ARRAY
10553: PUSH
10554: LD_INT 2
10556: ARRAY
10557: PPUSH
10558: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) < 8 then
10562: LD_VAR 0 1
10566: PPUSH
10567: LD_VAR 0 11
10571: PUSH
10572: LD_INT 3
10574: ARRAY
10575: PUSH
10576: LD_INT 1
10578: ARRAY
10579: PPUSH
10580: LD_VAR 0 11
10584: PUSH
10585: LD_INT 3
10587: ARRAY
10588: PUSH
10589: LD_INT 2
10591: ARRAY
10592: PPUSH
10593: CALL_OW 297
10597: PUSH
10598: LD_INT 8
10600: LESS
10601: IFFALSE 10615
// SetTag ( i , 3 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_INT 3
10610: PPUSH
10611: CALL_OW 109
// end else
10615: GO 10756
// if GetTag ( i ) = 3 then
10617: LD_VAR 0 1
10621: PPUSH
10622: CALL_OW 110
10626: PUSH
10627: LD_INT 3
10629: EQUAL
10630: IFFALSE 10722
// begin ComAgressiveMove ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) ;
10632: LD_VAR 0 1
10636: PPUSH
10637: LD_VAR 0 11
10641: PUSH
10642: LD_INT 4
10644: ARRAY
10645: PUSH
10646: LD_INT 1
10648: ARRAY
10649: PPUSH
10650: LD_VAR 0 11
10654: PUSH
10655: LD_INT 4
10657: ARRAY
10658: PUSH
10659: LD_INT 2
10661: ARRAY
10662: PPUSH
10663: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) < 8 then
10667: LD_VAR 0 1
10671: PPUSH
10672: LD_VAR 0 11
10676: PUSH
10677: LD_INT 4
10679: ARRAY
10680: PUSH
10681: LD_INT 1
10683: ARRAY
10684: PPUSH
10685: LD_VAR 0 11
10689: PUSH
10690: LD_INT 4
10692: ARRAY
10693: PUSH
10694: LD_INT 2
10696: ARRAY
10697: PPUSH
10698: CALL_OW 297
10702: PUSH
10703: LD_INT 8
10705: LESS
10706: IFFALSE 10720
// SetTag ( i , 4 ) ;
10708: LD_VAR 0 1
10712: PPUSH
10713: LD_INT 4
10715: PPUSH
10716: CALL_OW 109
// end else
10720: GO 10756
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10722: LD_VAR 0 1
10726: PPUSH
10727: LD_INT 81
10729: PUSH
10730: LD_INT 3
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PPUSH
10737: CALL_OW 69
10741: PPUSH
10742: LD_VAR 0 1
10746: PPUSH
10747: CALL_OW 74
10751: PPUSH
10752: CALL_OW 115
// end ; end ;
10756: GO 10263
10758: POP
10759: POP
// until not attackers ;
10760: LD_VAR 0 10
10764: NOT
10765: IFFALSE 10246
// end ;
10767: PPOPN 12
10769: END
// every 0 0$1 do var i , tmp ;
10770: GO 10772
10772: DISABLE
10773: LD_INT 0
10775: PPUSH
10776: PPUSH
// begin enable ;
10777: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
10778: LD_ADDR_VAR 0 2
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: LD_INT 22
10788: PUSH
10789: LD_INT 1
10791: PUSH
10792: EMPTY
10793: LIST
10794: LIST
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 32
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 69
10818: ST_TO_ADDR
// if tmp then
10819: LD_VAR 0 2
10823: IFFALSE 10869
// for i in tmp do
10825: LD_ADDR_VAR 0 1
10829: PUSH
10830: LD_VAR 0 2
10834: PUSH
10835: FOR_IN
10836: IFFALSE 10867
// if GetFuel ( i ) < 3 then
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 261
10847: PUSH
10848: LD_INT 3
10850: LESS
10851: IFFALSE 10865
// SetFuel ( i , 3 ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: LD_INT 3
10860: PPUSH
10861: CALL_OW 240
10865: GO 10835
10867: POP
10868: POP
// end ;
10869: PPOPN 2
10871: END
// every 0 0$1 trigger ( FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) and not JMMArrival ) or ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) and not FirstAssaultRepelled ) do
10872: LD_INT 3
10874: PPUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 1
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PPUSH
10885: CALL_OW 70
10889: PUSH
10890: LD_EXP 41
10894: NOT
10895: AND
10896: PUSH
10897: LD_INT 10
10899: PPUSH
10900: LD_INT 22
10902: PUSH
10903: LD_INT 1
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PPUSH
10910: CALL_OW 70
10914: PUSH
10915: LD_EXP 4
10919: NOT
10920: AND
10921: OR
10922: IFFALSE 10931
10924: GO 10926
10926: DISABLE
// Antirush ;
10927: CALL 10932 0 0
10931: END
// export function Antirush ; var i , veh , tmp , num ; begin
10932: LD_INT 0
10934: PPUSH
10935: PPUSH
10936: PPUSH
10937: PPUSH
10938: PPUSH
// tmp := [ ] ;
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: EMPTY
10945: ST_TO_ADDR
// if not FirstAssaultRepelled then
10946: LD_EXP 4
10950: NOT
10951: IFFALSE 10963
// num := 12 else
10953: LD_ADDR_VAR 0 5
10957: PUSH
10958: LD_INT 12
10960: ST_TO_ADDR
10961: GO 10971
// num := 10 ;
10963: LD_ADDR_VAR 0 5
10967: PUSH
10968: LD_INT 10
10970: ST_TO_ADDR
// num := num - [ 4 , 2 , 0 ] [ Difficulty ] ;
10971: LD_ADDR_VAR 0 5
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: LD_INT 4
10983: PUSH
10984: LD_INT 2
10986: PUSH
10987: LD_INT 0
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_OWVAR 67
10999: ARRAY
11000: MINUS
11001: ST_TO_ADDR
// for i := 1 to num do
11002: LD_ADDR_VAR 0 2
11006: PUSH
11007: DOUBLE
11008: LD_INT 1
11010: DEC
11011: ST_TO_ADDR
11012: LD_VAR 0 5
11016: PUSH
11017: FOR_TO
11018: IFFALSE 11157
// begin uc_side := 3 ;
11020: LD_ADDR_OWVAR 20
11024: PUSH
11025: LD_INT 3
11027: ST_TO_ADDR
// uc_nation := 3 ;
11028: LD_ADDR_OWVAR 21
11032: PUSH
11033: LD_INT 3
11035: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
11036: LD_INT 23
11038: PPUSH
11039: LD_INT 3
11041: PPUSH
11042: LD_INT 3
11044: PPUSH
11045: LD_INT 46
11047: PUSH
11048: LD_INT 43
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: PUSH
11055: LD_INT 1
11057: PPUSH
11058: LD_INT 2
11060: PPUSH
11061: CALL_OW 12
11065: ARRAY
11066: PPUSH
11067: LD_INT 100
11069: PPUSH
11070: CALL 18466 0 5
// veh := CreateVehicle ;
11074: LD_ADDR_VAR 0 3
11078: PUSH
11079: CALL_OW 45
11083: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
11084: LD_VAR 0 3
11088: PPUSH
11089: LD_INT 5
11091: PPUSH
11092: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
11096: LD_VAR 0 3
11100: PPUSH
11101: LD_INT 199
11103: PPUSH
11104: LD_INT 135
11106: PPUSH
11107: LD_INT 3
11109: PPUSH
11110: LD_INT 0
11112: PPUSH
11113: CALL_OW 50
// tmp := tmp ^ veh ;
11117: LD_ADDR_VAR 0 4
11121: PUSH
11122: LD_VAR 0 4
11126: PUSH
11127: LD_VAR 0 3
11131: ADD
11132: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
11133: LD_VAR 0 3
11137: PPUSH
11138: LD_INT 173
11140: PPUSH
11141: LD_INT 118
11143: PPUSH
11144: CALL_OW 111
// wait ( 0 0$2 ) ;
11148: LD_INT 70
11150: PPUSH
11151: CALL_OW 67
// end ;
11155: GO 11017
11157: POP
11158: POP
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// for i in tmp do
11166: LD_ADDR_VAR 0 2
11170: PUSH
11171: LD_VAR 0 4
11175: PUSH
11176: FOR_IN
11177: IFFALSE 11244
// if IsDead ( i ) then
11179: LD_VAR 0 2
11183: PPUSH
11184: CALL_OW 301
11188: IFFALSE 11208
// tmp := tmp diff i else
11190: LD_ADDR_VAR 0 4
11194: PUSH
11195: LD_VAR 0 4
11199: PUSH
11200: LD_VAR 0 2
11204: DIFF
11205: ST_TO_ADDR
11206: GO 11242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 22
11215: PUSH
11216: LD_INT 1
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PPUSH
11223: CALL_OW 69
11227: PPUSH
11228: LD_VAR 0 2
11232: PPUSH
11233: CALL_OW 74
11237: PPUSH
11238: CALL_OW 115
11242: GO 11176
11244: POP
11245: POP
// until not tmp ;
11246: LD_VAR 0 4
11250: NOT
11251: IFFALSE 11159
// end ; end_of_file
11253: LD_VAR 0 1
11257: RET
// export Losses ; on UnitDestroyed ( un ) do begin if un = Brighton then
11258: LD_VAR 0 1
11262: PUSH
11263: LD_EXP 9
11267: EQUAL
11268: IFFALSE 11284
// begin wait ( 0 0$1 ) ;
11270: LD_INT 35
11272: PPUSH
11273: CALL_OW 67
// YouLost ( Brighton ) ;
11277: LD_STRING Brighton
11279: PPUSH
11280: CALL_OW 104
// end ; if un = JMM then
11284: LD_VAR 0 1
11288: PUSH
11289: LD_EXP 37
11293: EQUAL
11294: IFFALSE 11310
// begin wait ( 0 0$1 ) ;
11296: LD_INT 35
11298: PPUSH
11299: CALL_OW 67
// YouLost ( JMM ) ;
11303: LD_STRING JMM
11305: PPUSH
11306: CALL_OW 104
// end ; if un = Megan then
11310: LD_VAR 0 1
11314: PUSH
11315: LD_EXP 11
11319: EQUAL
11320: IFFALSE 11334
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
11322: LD_EXP 9
11326: PPUSH
11327: LD_STRING DBrighton-MeganDeath
11329: PPUSH
11330: CALL_OW 88
// end ; if un = Palmer then
11334: LD_VAR 0 1
11338: PUSH
11339: LD_EXP 10
11343: EQUAL
11344: IFFALSE 11358
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
11346: LD_EXP 9
11350: PPUSH
11351: LD_STRING DBrighton-PalmerDeath
11353: PPUSH
11354: CALL_OW 88
// end ; if un = Burlak then
11358: LD_VAR 0 1
11362: PUSH
11363: LD_EXP 19
11367: EQUAL
11368: IFFALSE 11400
// begin if JMM_Arrived then
11370: LD_EXP 6
11374: IFFALSE 11388
// Say ( JMM , DJMM-BurlakDead ) ;
11376: LD_EXP 37
11380: PPUSH
11381: LD_STRING DJMM-BurlakDead
11383: PPUSH
11384: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
11388: LD_EXP 10
11392: PPUSH
11393: LD_STRING DSol-BurlakDead
11395: PPUSH
11396: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
11400: LD_VAR 0 1
11404: PUSH
11405: LD_INT 1
11407: EQUAL
11408: PUSH
11409: LD_VAR 0 1
11413: PUSH
11414: LD_INT 3
11416: EQUAL
11417: OR
11418: IFFALSE 11434
// begin wait ( 0 0$1 ) ;
11420: LD_INT 35
11422: PPUSH
11423: CALL_OW 67
// YouLost ( Depot ) ;
11427: LD_STRING Depot
11429: PPUSH
11430: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
11434: LD_VAR 0 1
11438: PPUSH
11439: CALL_OW 255
11443: PUSH
11444: LD_INT 1
11446: EQUAL
11447: PUSH
11448: LD_VAR 0 1
11452: PPUSH
11453: CALL_OW 247
11457: PUSH
11458: LD_INT 1
11460: EQUAL
11461: AND
11462: IFFALSE 11478
// Losses := Losses + 1 ;
11464: LD_ADDR_EXP 45
11468: PUSH
11469: LD_EXP 45
11473: PUSH
11474: LD_INT 1
11476: PLUS
11477: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11478: LD_VAR 0 1
11482: PPUSH
11483: CALL 81501 0 1
// end ;
11487: PPOPN 1
11489: END
// on UnitGoesToRed ( un ) do begin if GetType ( un ) = unit_vehicle and un in RUArmada then
11490: LD_VAR 0 1
11494: PPUSH
11495: CALL_OW 247
11499: PUSH
11500: LD_INT 2
11502: EQUAL
11503: PUSH
11504: LD_VAR 0 1
11508: PUSH
11509: LD_EXP 17
11513: IN
11514: AND
11515: IFFALSE 11529
// SetLives ( un , 0 ) ;
11517: LD_VAR 0 1
11521: PPUSH
11522: LD_INT 0
11524: PPUSH
11525: CALL_OW 234
// if un = Yashin then
11529: LD_VAR 0 1
11533: PUSH
11534: LD_EXP 13
11538: EQUAL
11539: IFFALSE 11553
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
11541: LD_EXP 13
11545: PPUSH
11546: LD_STRING DDeath-Yas-3
11548: PPUSH
11549: CALL_OW 91
// if un = Popov then
11553: LD_VAR 0 1
11557: PUSH
11558: LD_EXP 14
11562: EQUAL
11563: IFFALSE 11577
// ForceSay ( Popov , DDeath-Pop-3 ) ;
11565: LD_EXP 14
11569: PPUSH
11570: LD_STRING DDeath-Pop-3
11572: PPUSH
11573: CALL_OW 91
// if un = Gaydar then
11577: LD_VAR 0 1
11581: PUSH
11582: LD_EXP 15
11586: EQUAL
11587: IFFALSE 11601
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
11589: LD_EXP 15
11593: PPUSH
11594: LD_STRING DDeath-Gay-3
11596: PPUSH
11597: CALL_OW 91
// if un = Sevi then
11601: LD_VAR 0 1
11605: PUSH
11606: LD_EXP 16
11610: EQUAL
11611: IFFALSE 11625
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
11613: LD_EXP 16
11617: PPUSH
11618: LD_STRING DDeath-Vse-3
11620: PPUSH
11621: CALL_OW 91
// end ;
11625: PPOPN 1
11627: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
11628: LD_VAR 0 1
11632: PUSH
11633: LD_INT 10
11635: EQUAL
11636: IFFALSE 11674
// begin Say ( Brighton , DBrighton-C1 ) ;
11638: LD_EXP 9
11642: PPUSH
11643: LD_STRING DBrighton-C1
11645: PPUSH
11646: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
11650: LD_EXP 11
11654: PPUSH
11655: LD_STRING DMegan-C1
11657: PPUSH
11658: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
11662: LD_EXP 9
11666: PPUSH
11667: LD_STRING DBrighton-C2
11669: PPUSH
11670: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
11674: LD_VAR 0 1
11678: PPUSH
11679: LD_VAR 0 2
11683: PPUSH
11684: CALL 81197 0 2
// end ;
11688: PPOPN 2
11690: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11691: LD_VAR 0 1
11695: PPUSH
11696: LD_VAR 0 2
11700: PPUSH
11701: CALL 83835 0 2
// end ;
11705: PPOPN 2
11707: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11708: LD_VAR 0 1
11712: PPUSH
11713: CALL 82903 0 1
// end ;
11717: PPOPN 1
11719: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
11720: LD_VAR 0 1
11724: PPUSH
11725: CALL_OW 266
11729: PUSH
11730: LD_INT 0
11732: EQUAL
11733: PUSH
11734: LD_VAR 0 1
11738: PPUSH
11739: CALL_OW 255
11743: PUSH
11744: LD_INT 3
11746: EQUAL
11747: AND
11748: IFFALSE 11810
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
11750: LD_VAR 0 1
11754: PPUSH
11755: CALL_OW 274
11759: PPUSH
11760: LD_INT 1
11762: PPUSH
11763: LD_INT 10000
11765: PPUSH
11766: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
11770: LD_VAR 0 1
11774: PPUSH
11775: CALL_OW 274
11779: PPUSH
11780: LD_INT 2
11782: PPUSH
11783: LD_INT 250
11785: PPUSH
11786: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
11790: LD_VAR 0 1
11794: PPUSH
11795: CALL_OW 274
11799: PPUSH
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 100
11805: PPUSH
11806: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
11810: LD_VAR 0 1
11814: PPUSH
11815: CALL 83144 0 1
// end ;
11819: PPOPN 1
11821: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11822: LD_VAR 0 1
11826: PPUSH
11827: LD_VAR 0 2
11831: PPUSH
11832: LD_VAR 0 3
11836: PPUSH
11837: LD_VAR 0 4
11841: PPUSH
11842: LD_VAR 0 5
11846: PPUSH
11847: CALL 80817 0 5
// end ;
11851: PPOPN 5
11853: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11854: LD_VAR 0 1
11858: PPUSH
11859: LD_VAR 0 2
11863: PPUSH
11864: CALL 80398 0 2
// end ;
11868: PPOPN 2
11870: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11871: LD_VAR 0 1
11875: PPUSH
11876: LD_VAR 0 2
11880: PPUSH
11881: LD_VAR 0 3
11885: PPUSH
11886: LD_VAR 0 4
11890: PPUSH
11891: CALL 80236 0 4
// end ;
11895: PPOPN 4
11897: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11898: LD_VAR 0 1
11902: PPUSH
11903: LD_VAR 0 2
11907: PPUSH
11908: LD_VAR 0 3
11912: PPUSH
11913: CALL 80011 0 3
// end ;
11917: PPOPN 3
11919: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11920: LD_VAR 0 1
11924: PPUSH
11925: LD_VAR 0 2
11929: PPUSH
11930: CALL 79896 0 2
// end ;
11934: PPOPN 2
11936: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11937: LD_VAR 0 1
11941: PPUSH
11942: LD_VAR 0 2
11946: PPUSH
11947: CALL 84130 0 2
// end ;
11951: PPOPN 2
11953: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
11954: LD_VAR 0 1
11958: PPUSH
11959: CALL_OW 255
11963: PUSH
11964: LD_INT 6
11966: EQUAL
11967: IFFALSE 12097
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
11969: LD_VAR 0 1
11973: PUSH
11974: LD_EXP 13
11978: PUSH
11979: LD_EXP 16
11983: PUSH
11984: LD_EXP 15
11988: PUSH
11989: LD_EXP 14
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: IN
12000: IFFALSE 12004
// exit ;
12002: GO 12121
// if AssaultStarted then
12004: LD_EXP 8
12008: IFFALSE 12082
// case Rand ( 1 , 4 ) of 1 .. 3 :
12010: LD_INT 1
12012: PPUSH
12013: LD_INT 4
12015: PPUSH
12016: CALL_OW 12
12020: PUSH
12021: LD_INT 1
12023: DOUBLE
12024: GREATEREQUAL
12025: IFFALSE 12033
12027: LD_INT 3
12029: DOUBLE
12030: LESSEQUAL
12031: IFTRUE 12035
12033: GO 12053
12035: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
12036: LD_VAR 0 1
12040: PPUSH
12041: LD_INT 67
12043: PPUSH
12044: LD_INT 37
12046: PPUSH
12047: CALL_OW 114
12051: GO 12080
12053: LD_INT 4
12055: DOUBLE
12056: EQUAL
12057: IFTRUE 12061
12059: GO 12079
12061: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
12062: LD_VAR 0 1
12066: PPUSH
12067: LD_INT 120
12069: PPUSH
12070: LD_INT 131
12072: PPUSH
12073: CALL_OW 111
12077: GO 12080
12079: POP
12080: GO 12097
// ComMoveXY ( driver , 120 , 131 ) ;
12082: LD_VAR 0 1
12086: PPUSH
12087: LD_INT 120
12089: PPUSH
12090: LD_INT 131
12092: PPUSH
12093: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12097: LD_VAR 0 1
12101: PPUSH
12102: LD_VAR 0 2
12106: PPUSH
12107: LD_VAR 0 3
12111: PPUSH
12112: LD_VAR 0 4
12116: PPUSH
12117: CALL 84346 0 4
// end ;
12121: PPOPN 4
12123: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12124: LD_VAR 0 1
12128: PPUSH
12129: LD_VAR 0 2
12133: PPUSH
12134: CALL 79705 0 2
// end ;
12138: PPOPN 2
12140: END
// on Command ( cmd ) do var i ;
12141: LD_INT 0
12143: PPUSH
// begin if cmd = 77 and southAreaBlocker then
12144: LD_VAR 0 1
12148: PUSH
12149: LD_INT 77
12151: EQUAL
12152: PUSH
12153: LD_EXP 2
12157: AND
12158: IFFALSE 12234
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12160: LD_ADDR_VAR 0 2
12164: PUSH
12165: LD_INT 22
12167: PUSH
12168: LD_INT 1
12170: PUSH
12171: EMPTY
12172: LIST
12173: LIST
12174: PUSH
12175: LD_INT 2
12177: PUSH
12178: LD_INT 21
12180: PUSH
12181: LD_INT 1
12183: PUSH
12184: EMPTY
12185: LIST
12186: LIST
12187: PUSH
12188: LD_INT 21
12190: PUSH
12191: LD_INT 2
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: LIST
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PPUSH
12207: CALL_OW 69
12211: PUSH
12212: FOR_IN
12213: IFFALSE 12232
// NotGoToAreaUnit ( i , SouthAreaBlock , SouthAreaGoAway ) ;
12215: LD_VAR 0 2
12219: PPUSH
12220: LD_INT 20
12222: PPUSH
12223: LD_INT 19
12225: PPUSH
12226: CALL 50993 0 3
12230: GO 12212
12232: POP
12233: POP
// end ; SOS_Command ( cmd ) ;
12234: LD_VAR 0 1
12238: PPUSH
12239: CALL 98400 0 1
// end ;
12243: PPOPN 2
12245: END
// every 0 0$1 trigger southAreaBlocker and FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do var i ;
12246: LD_EXP 2
12250: PUSH
12251: LD_INT 16
12253: PPUSH
12254: LD_INT 22
12256: PUSH
12257: LD_INT 1
12259: PUSH
12260: EMPTY
12261: LIST
12262: LIST
12263: PUSH
12264: LD_INT 2
12266: PUSH
12267: LD_INT 21
12269: PUSH
12270: LD_INT 1
12272: PUSH
12273: EMPTY
12274: LIST
12275: LIST
12276: PUSH
12277: LD_INT 21
12279: PUSH
12280: LD_INT 2
12282: PUSH
12283: EMPTY
12284: LIST
12285: LIST
12286: PUSH
12287: EMPTY
12288: LIST
12289: LIST
12290: LIST
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PPUSH
12296: CALL_OW 70
12300: AND
12301: IFFALSE 12387
12303: GO 12305
12305: DISABLE
12306: LD_INT 0
12308: PPUSH
// begin enable ;
12309: ENABLE
// for i in FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12310: LD_ADDR_VAR 0 1
12314: PUSH
12315: LD_INT 16
12317: PPUSH
12318: LD_INT 22
12320: PUSH
12321: LD_INT 1
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PUSH
12328: LD_INT 2
12330: PUSH
12331: LD_INT 21
12333: PUSH
12334: LD_INT 1
12336: PUSH
12337: EMPTY
12338: LIST
12339: LIST
12340: PUSH
12341: LD_INT 21
12343: PUSH
12344: LD_INT 2
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: PUSH
12351: EMPTY
12352: LIST
12353: LIST
12354: LIST
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PPUSH
12360: CALL_OW 70
12364: PUSH
12365: FOR_IN
12366: IFFALSE 12385
// NotGoToAreaUnit ( i , SouthAreaOutside , SouthAreaGoAway ) ;
12368: LD_VAR 0 1
12372: PPUSH
12373: LD_INT 18
12375: PPUSH
12376: LD_INT 19
12378: PPUSH
12379: CALL 50993 0 3
12383: GO 12365
12385: POP
12386: POP
// end ; end_of_file
12387: PPOPN 1
12389: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
12390: LD_EXP 6
12394: PUSH
12395: LD_EXP 44
12399: AND
12400: IFFALSE 12571
12402: GO 12404
12404: DISABLE
// begin wait ( 0 0$2 ) ;
12405: LD_INT 70
12407: PPUSH
12408: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
12412: LD_EXP 9
12416: PPUSH
12417: LD_STRING DBrighton-G1
12419: PPUSH
12420: CALL_OW 88
// if Losses < 1 then
12424: LD_EXP 45
12428: PUSH
12429: LD_INT 1
12431: LESS
12432: IFFALSE 12446
// AddMedal ( Losses , 1 ) else
12434: LD_STRING Losses
12436: PPUSH
12437: LD_INT 1
12439: PPUSH
12440: CALL_OW 101
12444: GO 12479
// if Losses < 5 then
12446: LD_EXP 45
12450: PUSH
12451: LD_INT 5
12453: LESS
12454: IFFALSE 12468
// AddMedal ( Losses , 2 ) else
12456: LD_STRING Losses
12458: PPUSH
12459: LD_INT 2
12461: PPUSH
12462: CALL_OW 101
12466: GO 12479
// AddMedal ( Losses , - 1 ) ;
12468: LD_STRING Losses
12470: PPUSH
12471: LD_INT 1
12473: NEG
12474: PPUSH
12475: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12479: LD_EXP 7
12483: PUSH
12484: LD_INT 10
12486: PPUSH
12487: LD_INT 1
12489: PPUSH
12490: CALL_OW 321
12494: PUSH
12495: LD_INT 2
12497: EQUAL
12498: AND
12499: IFFALSE 12513
// AddMedal ( Laser , 1 ) else
12501: LD_STRING Laser
12503: PPUSH
12504: LD_INT 1
12506: PPUSH
12507: CALL_OW 101
12511: GO 12560
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12513: LD_EXP 7
12517: NOT
12518: PUSH
12519: LD_INT 10
12521: PPUSH
12522: LD_INT 1
12524: PPUSH
12525: CALL_OW 321
12529: PUSH
12530: LD_INT 2
12532: EQUAL
12533: AND
12534: IFFALSE 12549
// AddMedal ( Laser , - 1 ) else
12536: LD_STRING Laser
12538: PPUSH
12539: LD_INT 1
12541: NEG
12542: PPUSH
12543: CALL_OW 101
12547: GO 12560
// AddMedal ( Laser , - 2 ) ;
12549: LD_STRING Laser
12551: PPUSH
12552: LD_INT 2
12554: NEG
12555: PPUSH
12556: CALL_OW 101
// GiveMedals ( BaseMain ) ;
12560: LD_STRING BaseMain
12562: PPUSH
12563: CALL_OW 102
// YouWin ;
12567: CALL_OW 103
// end ; end_of_file
12571: END
// export rows ; export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
12572: LD_INT 0
12574: PPUSH
12575: PPUSH
// area = ListEnvironmentArea ( area ) ;
12576: LD_ADDR_VAR 0 2
12580: PUSH
12581: LD_VAR 0 2
12585: PPUSH
12586: CALL_OW 353
12590: ST_TO_ADDR
// if bulldozer > 0 then
12591: LD_VAR 0 1
12595: PUSH
12596: LD_INT 0
12598: GREATER
12599: IFFALSE 12710
// for i = area downto 1 do
12601: LD_ADDR_VAR 0 4
12605: PUSH
12606: DOUBLE
12607: LD_VAR 0 2
12611: INC
12612: ST_TO_ADDR
12613: LD_INT 1
12615: PUSH
12616: FOR_DOWNTO
12617: IFFALSE 12708
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
12619: LD_VAR 0 2
12623: PUSH
12624: LD_VAR 0 4
12628: ARRAY
12629: PUSH
12630: LD_INT 1
12632: ARRAY
12633: PPUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_VAR 0 4
12643: ARRAY
12644: PUSH
12645: LD_INT 2
12647: ARRAY
12648: PPUSH
12649: CALL_OW 351
12653: IFFALSE 12706
// if not HasTask ( bulldozer ) then
12655: LD_VAR 0 1
12659: PPUSH
12660: CALL_OW 314
12664: NOT
12665: IFFALSE 12706
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
12667: LD_VAR 0 1
12671: PPUSH
12672: LD_VAR 0 2
12676: PUSH
12677: LD_VAR 0 4
12681: ARRAY
12682: PUSH
12683: LD_INT 1
12685: ARRAY
12686: PPUSH
12687: LD_VAR 0 2
12691: PUSH
12692: LD_VAR 0 4
12696: ARRAY
12697: PUSH
12698: LD_INT 2
12700: ARRAY
12701: PPUSH
12702: CALL_OW 171
12706: GO 12616
12708: POP
12709: POP
// end ;
12710: LD_VAR 0 3
12714: RET
// export function ComMeeting ( team , area ) ; var i , x , tmp , offset , sold_team , civil_team ; begin
12715: LD_INT 0
12717: PPUSH
12718: PPUSH
12719: PPUSH
12720: PPUSH
12721: PPUSH
12722: PPUSH
12723: PPUSH
// sold_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , class_soldier ] ] ) ;
12724: LD_ADDR_VAR 0 8
12728: PUSH
12729: LD_VAR 0 1
12733: PPUSH
12734: LD_INT 22
12736: PUSH
12737: LD_INT 1
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: PUSH
12744: LD_INT 21
12746: PUSH
12747: LD_INT 1
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 25
12756: PUSH
12757: LD_INT 1
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: LIST
12768: PPUSH
12769: CALL_OW 72
12773: ST_TO_ADDR
// civil_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , class_soldier ] ] ] ) ;
12774: LD_ADDR_VAR 0 9
12778: PUSH
12779: LD_VAR 0 1
12783: PPUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 1
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 21
12796: PUSH
12797: LD_INT 1
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 3
12806: PUSH
12807: LD_INT 25
12809: PUSH
12810: LD_INT 1
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: LIST
12825: PPUSH
12826: CALL_OW 72
12830: ST_TO_ADDR
// rows = MakeRows ( sold_team , civil_team ) ;
12831: LD_ADDR_EXP 47
12835: PUSH
12836: LD_VAR 0 8
12840: PPUSH
12841: LD_VAR 0 9
12845: PPUSH
12846: CALL 13239 0 2
12850: ST_TO_ADDR
// offset = 0 ;
12851: LD_ADDR_VAR 0 7
12855: PUSH
12856: LD_INT 0
12858: ST_TO_ADDR
// for i := 1 to sold_team do
12859: LD_ADDR_VAR 0 4
12863: PUSH
12864: DOUBLE
12865: LD_INT 1
12867: DEC
12868: ST_TO_ADDR
12869: LD_VAR 0 8
12873: PUSH
12874: FOR_TO
12875: IFFALSE 13006
// begin if IsInUnit ( sold_team [ i ] ) then
12877: LD_VAR 0 8
12881: PUSH
12882: LD_VAR 0 4
12886: ARRAY
12887: PPUSH
12888: CALL_OW 310
12892: IFFALSE 12909
// ComExitBuilding ( sold_team [ i ] ) ;
12894: LD_VAR 0 8
12898: PUSH
12899: LD_VAR 0 4
12903: ARRAY
12904: PPUSH
12905: CALL_OW 122
// AddComMoveXY ( sold_team [ i ] , rows [ 1 ] [ i + offset ] , rows [ 1 ] [ i + 1 + offset ] ) ;
12909: LD_VAR 0 8
12913: PUSH
12914: LD_VAR 0 4
12918: ARRAY
12919: PPUSH
12920: LD_EXP 47
12924: PUSH
12925: LD_INT 1
12927: ARRAY
12928: PUSH
12929: LD_VAR 0 4
12933: PUSH
12934: LD_VAR 0 7
12938: PLUS
12939: ARRAY
12940: PPUSH
12941: LD_EXP 47
12945: PUSH
12946: LD_INT 1
12948: ARRAY
12949: PUSH
12950: LD_VAR 0 4
12954: PUSH
12955: LD_INT 1
12957: PLUS
12958: PUSH
12959: LD_VAR 0 7
12963: PLUS
12964: ARRAY
12965: PPUSH
12966: CALL_OW 171
// AddComTurnUnit ( sold_team [ i ] , Brighton ) ;
12970: LD_VAR 0 8
12974: PUSH
12975: LD_VAR 0 4
12979: ARRAY
12980: PPUSH
12981: LD_EXP 9
12985: PPUSH
12986: CALL_OW 179
// offset = offset + 1 ;
12990: LD_ADDR_VAR 0 7
12994: PUSH
12995: LD_VAR 0 7
12999: PUSH
13000: LD_INT 1
13002: PLUS
13003: ST_TO_ADDR
// end ;
13004: GO 12874
13006: POP
13007: POP
// offset = 0 ;
13008: LD_ADDR_VAR 0 7
13012: PUSH
13013: LD_INT 0
13015: ST_TO_ADDR
// tmp = 1 ;
13016: LD_ADDR_VAR 0 6
13020: PUSH
13021: LD_INT 1
13023: ST_TO_ADDR
// for i := 2 to rows do
13024: LD_ADDR_VAR 0 4
13028: PUSH
13029: DOUBLE
13030: LD_INT 2
13032: DEC
13033: ST_TO_ADDR
13034: LD_EXP 47
13038: PUSH
13039: FOR_TO
13040: IFFALSE 13232
// begin for x := 1 to sold_team do
13042: LD_ADDR_VAR 0 5
13046: PUSH
13047: DOUBLE
13048: LD_INT 1
13050: DEC
13051: ST_TO_ADDR
13052: LD_VAR 0 8
13056: PUSH
13057: FOR_TO
13058: IFFALSE 13220
// begin if IsInUnit ( civil_team [ tmp ] ) then
13060: LD_VAR 0 9
13064: PUSH
13065: LD_VAR 0 6
13069: ARRAY
13070: PPUSH
13071: CALL_OW 310
13075: IFFALSE 13092
// ComExitBuilding ( civil_team [ tmp ] ) ;
13077: LD_VAR 0 9
13081: PUSH
13082: LD_VAR 0 6
13086: ARRAY
13087: PPUSH
13088: CALL_OW 122
// AddComMoveXY ( civil_team [ tmp ] , rows [ i ] [ x + offset ] , rows [ i ] [ x + 1 + offset ] ) ;
13092: LD_VAR 0 9
13096: PUSH
13097: LD_VAR 0 6
13101: ARRAY
13102: PPUSH
13103: LD_EXP 47
13107: PUSH
13108: LD_VAR 0 4
13112: ARRAY
13113: PUSH
13114: LD_VAR 0 5
13118: PUSH
13119: LD_VAR 0 7
13123: PLUS
13124: ARRAY
13125: PPUSH
13126: LD_EXP 47
13130: PUSH
13131: LD_VAR 0 4
13135: ARRAY
13136: PUSH
13137: LD_VAR 0 5
13141: PUSH
13142: LD_INT 1
13144: PLUS
13145: PUSH
13146: LD_VAR 0 7
13150: PLUS
13151: ARRAY
13152: PPUSH
13153: CALL_OW 171
// AddComTurnUnit ( civil_team [ tmp ] , Brighton ) ;
13157: LD_VAR 0 9
13161: PUSH
13162: LD_VAR 0 6
13166: ARRAY
13167: PPUSH
13168: LD_EXP 9
13172: PPUSH
13173: CALL_OW 179
// offset = offset + 1 ;
13177: LD_ADDR_VAR 0 7
13181: PUSH
13182: LD_VAR 0 7
13186: PUSH
13187: LD_INT 1
13189: PLUS
13190: ST_TO_ADDR
// if not ( tmp = civil_team ) then
13191: LD_VAR 0 6
13195: PUSH
13196: LD_VAR 0 9
13200: EQUAL
13201: NOT
13202: IFFALSE 13218
// tmp = tmp + 1 ;
13204: LD_ADDR_VAR 0 6
13208: PUSH
13209: LD_VAR 0 6
13213: PUSH
13214: LD_INT 1
13216: PLUS
13217: ST_TO_ADDR
// end ;
13218: GO 13057
13220: POP
13221: POP
// offset = 0 ;
13222: LD_ADDR_VAR 0 7
13226: PUSH
13227: LD_INT 0
13229: ST_TO_ADDR
// end ;
13230: GO 13039
13232: POP
13233: POP
// end ;
13234: LD_VAR 0 3
13238: RET
// export function MakeRows ( sold_team , civil_team ) ; var i , x , start_pos , row_size , new_row , result_rows , civil_rows , offsetX , offsetY ; begin
13239: LD_INT 0
13241: PPUSH
13242: PPUSH
13243: PPUSH
13244: PPUSH
13245: PPUSH
13246: PPUSH
13247: PPUSH
13248: PPUSH
13249: PPUSH
13250: PPUSH
// start_pos = [ 65 , 34 ] ;
13251: LD_ADDR_VAR 0 6
13255: PUSH
13256: LD_INT 65
13258: PUSH
13259: LD_INT 34
13261: PUSH
13262: EMPTY
13263: LIST
13264: LIST
13265: ST_TO_ADDR
// row_size = 0 ;
13266: LD_ADDR_VAR 0 7
13270: PUSH
13271: LD_INT 0
13273: ST_TO_ADDR
// result_rows = [ ] ;
13274: LD_ADDR_VAR 0 9
13278: PUSH
13279: EMPTY
13280: ST_TO_ADDR
// new_row = [ ] ;
13281: LD_ADDR_VAR 0 8
13285: PUSH
13286: EMPTY
13287: ST_TO_ADDR
// for i := 1 to sold_team do
13288: LD_ADDR_VAR 0 4
13292: PUSH
13293: DOUBLE
13294: LD_INT 1
13296: DEC
13297: ST_TO_ADDR
13298: LD_VAR 0 1
13302: PUSH
13303: FOR_TO
13304: IFFALSE 13358
// begin new_row = new_row ^ start_pos [ 1 ] ^ start_pos [ 2 ] + i ;
13306: LD_ADDR_VAR 0 8
13310: PUSH
13311: LD_VAR 0 8
13315: PUSH
13316: LD_VAR 0 6
13320: PUSH
13321: LD_INT 1
13323: ARRAY
13324: ADD
13325: PUSH
13326: LD_VAR 0 6
13330: PUSH
13331: LD_INT 2
13333: ARRAY
13334: PUSH
13335: LD_VAR 0 4
13339: PLUS
13340: ADD
13341: ST_TO_ADDR
// row_size = row_size + 1 ;
13342: LD_ADDR_VAR 0 7
13346: PUSH
13347: LD_VAR 0 7
13351: PUSH
13352: LD_INT 1
13354: PLUS
13355: ST_TO_ADDR
// end ;
13356: GO 13303
13358: POP
13359: POP
// result_rows = result_rows ^ [ new_row ] ;
13360: LD_ADDR_VAR 0 9
13364: PUSH
13365: LD_VAR 0 9
13369: PUSH
13370: LD_VAR 0 8
13374: PUSH
13375: EMPTY
13376: LIST
13377: ADD
13378: ST_TO_ADDR
// civil_rows = civil_team div sold_team ;
13379: LD_ADDR_VAR 0 10
13383: PUSH
13384: LD_VAR 0 2
13388: PUSH
13389: LD_VAR 0 1
13393: DIV
13394: ST_TO_ADDR
// if ( civil_rows mod sold_team > 0 ) then
13395: LD_VAR 0 10
13399: PUSH
13400: LD_VAR 0 1
13404: MOD
13405: PUSH
13406: LD_INT 0
13408: GREATER
13409: IFFALSE 13425
// civil_rows = civil_rows + 1 ;
13411: LD_ADDR_VAR 0 10
13415: PUSH
13416: LD_VAR 0 10
13420: PUSH
13421: LD_INT 1
13423: PLUS
13424: ST_TO_ADDR
// offsetX = 2 ;
13425: LD_ADDR_VAR 0 11
13429: PUSH
13430: LD_INT 2
13432: ST_TO_ADDR
// offsetY = 1 ;
13433: LD_ADDR_VAR 0 12
13437: PUSH
13438: LD_INT 1
13440: ST_TO_ADDR
// for i := 1 to civil_rows do
13441: LD_ADDR_VAR 0 4
13445: PUSH
13446: DOUBLE
13447: LD_INT 1
13449: DEC
13450: ST_TO_ADDR
13451: LD_VAR 0 10
13455: PUSH
13456: FOR_TO
13457: IFFALSE 13585
// begin new_row = [ ] ;
13459: LD_ADDR_VAR 0 8
13463: PUSH
13464: EMPTY
13465: ST_TO_ADDR
// for x := 1 to row_size do
13466: LD_ADDR_VAR 0 5
13470: PUSH
13471: DOUBLE
13472: LD_INT 1
13474: DEC
13475: ST_TO_ADDR
13476: LD_VAR 0 7
13480: PUSH
13481: FOR_TO
13482: IFFALSE 13534
// begin new_row = new_row ^ start_pos [ 1 ] + offsetX ^ start_pos [ 2 ] + offsetY + x ;
13484: LD_ADDR_VAR 0 8
13488: PUSH
13489: LD_VAR 0 8
13493: PUSH
13494: LD_VAR 0 6
13498: PUSH
13499: LD_INT 1
13501: ARRAY
13502: PUSH
13503: LD_VAR 0 11
13507: PLUS
13508: ADD
13509: PUSH
13510: LD_VAR 0 6
13514: PUSH
13515: LD_INT 2
13517: ARRAY
13518: PUSH
13519: LD_VAR 0 12
13523: PLUS
13524: PUSH
13525: LD_VAR 0 5
13529: PLUS
13530: ADD
13531: ST_TO_ADDR
// end ;
13532: GO 13481
13534: POP
13535: POP
// result_rows = result_rows ^ [ new_row ] ;
13536: LD_ADDR_VAR 0 9
13540: PUSH
13541: LD_VAR 0 9
13545: PUSH
13546: LD_VAR 0 8
13550: PUSH
13551: EMPTY
13552: LIST
13553: ADD
13554: ST_TO_ADDR
// offsetX = offsetX + 2 ;
13555: LD_ADDR_VAR 0 11
13559: PUSH
13560: LD_VAR 0 11
13564: PUSH
13565: LD_INT 2
13567: PLUS
13568: ST_TO_ADDR
// offsetY = offsetY + 1 ;
13569: LD_ADDR_VAR 0 12
13573: PUSH
13574: LD_VAR 0 12
13578: PUSH
13579: LD_INT 1
13581: PLUS
13582: ST_TO_ADDR
// end ;
13583: GO 13456
13585: POP
13586: POP
// result = result_rows ;
13587: LD_ADDR_VAR 0 3
13591: PUSH
13592: LD_VAR 0 9
13596: ST_TO_ADDR
// end ; end_of_file
13597: LD_VAR 0 3
13601: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13602: LD_INT 0
13604: PPUSH
13605: PPUSH
// if exist_mode then
13606: LD_VAR 0 2
13610: IFFALSE 13635
// unit := CreateCharacter ( prefix & ident ) else
13612: LD_ADDR_VAR 0 5
13616: PUSH
13617: LD_VAR 0 3
13621: PUSH
13622: LD_VAR 0 1
13626: STR
13627: PPUSH
13628: CALL_OW 34
13632: ST_TO_ADDR
13633: GO 13650
// unit := NewCharacter ( ident ) ;
13635: LD_ADDR_VAR 0 5
13639: PUSH
13640: LD_VAR 0 1
13644: PPUSH
13645: CALL_OW 25
13649: ST_TO_ADDR
// result := unit ;
13650: LD_ADDR_VAR 0 4
13654: PUSH
13655: LD_VAR 0 5
13659: ST_TO_ADDR
// end ;
13660: LD_VAR 0 4
13664: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13665: LD_INT 0
13667: PPUSH
13668: PPUSH
// if not side or not nation then
13669: LD_VAR 0 1
13673: NOT
13674: PUSH
13675: LD_VAR 0 2
13679: NOT
13680: OR
13681: IFFALSE 13685
// exit ;
13683: GO 14453
// case nation of nation_american :
13685: LD_VAR 0 2
13689: PUSH
13690: LD_INT 1
13692: DOUBLE
13693: EQUAL
13694: IFTRUE 13698
13696: GO 13912
13698: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
13699: LD_ADDR_VAR 0 4
13703: PUSH
13704: LD_INT 35
13706: PUSH
13707: LD_INT 45
13709: PUSH
13710: LD_INT 46
13712: PUSH
13713: LD_INT 47
13715: PUSH
13716: LD_INT 82
13718: PUSH
13719: LD_INT 83
13721: PUSH
13722: LD_INT 84
13724: PUSH
13725: LD_INT 85
13727: PUSH
13728: LD_INT 86
13730: PUSH
13731: LD_INT 1
13733: PUSH
13734: LD_INT 2
13736: PUSH
13737: LD_INT 6
13739: PUSH
13740: LD_INT 15
13742: PUSH
13743: LD_INT 16
13745: PUSH
13746: LD_INT 7
13748: PUSH
13749: LD_INT 12
13751: PUSH
13752: LD_INT 13
13754: PUSH
13755: LD_INT 10
13757: PUSH
13758: LD_INT 14
13760: PUSH
13761: LD_INT 20
13763: PUSH
13764: LD_INT 21
13766: PUSH
13767: LD_INT 22
13769: PUSH
13770: LD_INT 25
13772: PUSH
13773: LD_INT 32
13775: PUSH
13776: LD_INT 27
13778: PUSH
13779: LD_INT 36
13781: PUSH
13782: LD_INT 69
13784: PUSH
13785: LD_INT 39
13787: PUSH
13788: LD_INT 34
13790: PUSH
13791: LD_INT 40
13793: PUSH
13794: LD_INT 48
13796: PUSH
13797: LD_INT 49
13799: PUSH
13800: LD_INT 50
13802: PUSH
13803: LD_INT 51
13805: PUSH
13806: LD_INT 52
13808: PUSH
13809: LD_INT 53
13811: PUSH
13812: LD_INT 54
13814: PUSH
13815: LD_INT 55
13817: PUSH
13818: LD_INT 56
13820: PUSH
13821: LD_INT 57
13823: PUSH
13824: LD_INT 58
13826: PUSH
13827: LD_INT 59
13829: PUSH
13830: LD_INT 60
13832: PUSH
13833: LD_INT 61
13835: PUSH
13836: LD_INT 62
13838: PUSH
13839: LD_INT 80
13841: PUSH
13842: LD_INT 82
13844: PUSH
13845: LD_INT 83
13847: PUSH
13848: LD_INT 84
13850: PUSH
13851: LD_INT 85
13853: PUSH
13854: LD_INT 86
13856: PUSH
13857: EMPTY
13858: LIST
13859: LIST
13860: LIST
13861: LIST
13862: LIST
13863: LIST
13864: LIST
13865: LIST
13866: LIST
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: ST_TO_ADDR
13910: GO 14377
13912: LD_INT 2
13914: DOUBLE
13915: EQUAL
13916: IFTRUE 13920
13918: GO 14146
13920: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
13921: LD_ADDR_VAR 0 4
13925: PUSH
13926: LD_INT 35
13928: PUSH
13929: LD_INT 45
13931: PUSH
13932: LD_INT 46
13934: PUSH
13935: LD_INT 47
13937: PUSH
13938: LD_INT 82
13940: PUSH
13941: LD_INT 83
13943: PUSH
13944: LD_INT 84
13946: PUSH
13947: LD_INT 85
13949: PUSH
13950: LD_INT 87
13952: PUSH
13953: LD_INT 70
13955: PUSH
13956: LD_INT 1
13958: PUSH
13959: LD_INT 11
13961: PUSH
13962: LD_INT 3
13964: PUSH
13965: LD_INT 4
13967: PUSH
13968: LD_INT 5
13970: PUSH
13971: LD_INT 6
13973: PUSH
13974: LD_INT 15
13976: PUSH
13977: LD_INT 18
13979: PUSH
13980: LD_INT 7
13982: PUSH
13983: LD_INT 17
13985: PUSH
13986: LD_INT 8
13988: PUSH
13989: LD_INT 20
13991: PUSH
13992: LD_INT 21
13994: PUSH
13995: LD_INT 22
13997: PUSH
13998: LD_INT 72
14000: PUSH
14001: LD_INT 26
14003: PUSH
14004: LD_INT 69
14006: PUSH
14007: LD_INT 39
14009: PUSH
14010: LD_INT 40
14012: PUSH
14013: LD_INT 41
14015: PUSH
14016: LD_INT 42
14018: PUSH
14019: LD_INT 43
14021: PUSH
14022: LD_INT 48
14024: PUSH
14025: LD_INT 49
14027: PUSH
14028: LD_INT 50
14030: PUSH
14031: LD_INT 51
14033: PUSH
14034: LD_INT 52
14036: PUSH
14037: LD_INT 53
14039: PUSH
14040: LD_INT 54
14042: PUSH
14043: LD_INT 55
14045: PUSH
14046: LD_INT 56
14048: PUSH
14049: LD_INT 60
14051: PUSH
14052: LD_INT 61
14054: PUSH
14055: LD_INT 62
14057: PUSH
14058: LD_INT 66
14060: PUSH
14061: LD_INT 67
14063: PUSH
14064: LD_INT 68
14066: PUSH
14067: LD_INT 81
14069: PUSH
14070: LD_INT 82
14072: PUSH
14073: LD_INT 83
14075: PUSH
14076: LD_INT 84
14078: PUSH
14079: LD_INT 85
14081: PUSH
14082: LD_INT 87
14084: PUSH
14085: LD_INT 88
14087: PUSH
14088: EMPTY
14089: LIST
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: ST_TO_ADDR
14144: GO 14377
14146: LD_INT 3
14148: DOUBLE
14149: EQUAL
14150: IFTRUE 14154
14152: GO 14376
14154: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14155: LD_ADDR_VAR 0 4
14159: PUSH
14160: LD_INT 46
14162: PUSH
14163: LD_INT 47
14165: PUSH
14166: LD_INT 1
14168: PUSH
14169: LD_INT 2
14171: PUSH
14172: LD_INT 82
14174: PUSH
14175: LD_INT 83
14177: PUSH
14178: LD_INT 84
14180: PUSH
14181: LD_INT 85
14183: PUSH
14184: LD_INT 86
14186: PUSH
14187: LD_INT 11
14189: PUSH
14190: LD_INT 9
14192: PUSH
14193: LD_INT 20
14195: PUSH
14196: LD_INT 19
14198: PUSH
14199: LD_INT 21
14201: PUSH
14202: LD_INT 24
14204: PUSH
14205: LD_INT 22
14207: PUSH
14208: LD_INT 25
14210: PUSH
14211: LD_INT 28
14213: PUSH
14214: LD_INT 29
14216: PUSH
14217: LD_INT 30
14219: PUSH
14220: LD_INT 31
14222: PUSH
14223: LD_INT 37
14225: PUSH
14226: LD_INT 38
14228: PUSH
14229: LD_INT 32
14231: PUSH
14232: LD_INT 27
14234: PUSH
14235: LD_INT 33
14237: PUSH
14238: LD_INT 69
14240: PUSH
14241: LD_INT 39
14243: PUSH
14244: LD_INT 34
14246: PUSH
14247: LD_INT 40
14249: PUSH
14250: LD_INT 71
14252: PUSH
14253: LD_INT 23
14255: PUSH
14256: LD_INT 44
14258: PUSH
14259: LD_INT 48
14261: PUSH
14262: LD_INT 49
14264: PUSH
14265: LD_INT 50
14267: PUSH
14268: LD_INT 51
14270: PUSH
14271: LD_INT 52
14273: PUSH
14274: LD_INT 53
14276: PUSH
14277: LD_INT 54
14279: PUSH
14280: LD_INT 55
14282: PUSH
14283: LD_INT 56
14285: PUSH
14286: LD_INT 57
14288: PUSH
14289: LD_INT 58
14291: PUSH
14292: LD_INT 59
14294: PUSH
14295: LD_INT 63
14297: PUSH
14298: LD_INT 64
14300: PUSH
14301: LD_INT 65
14303: PUSH
14304: LD_INT 82
14306: PUSH
14307: LD_INT 83
14309: PUSH
14310: LD_INT 84
14312: PUSH
14313: LD_INT 85
14315: PUSH
14316: LD_INT 86
14318: PUSH
14319: EMPTY
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: ST_TO_ADDR
14374: GO 14377
14376: POP
// if state > - 1 and state < 3 then
14377: LD_VAR 0 3
14381: PUSH
14382: LD_INT 1
14384: NEG
14385: GREATER
14386: PUSH
14387: LD_VAR 0 3
14391: PUSH
14392: LD_INT 3
14394: LESS
14395: AND
14396: IFFALSE 14453
// for i in result do
14398: LD_ADDR_VAR 0 5
14402: PUSH
14403: LD_VAR 0 4
14407: PUSH
14408: FOR_IN
14409: IFFALSE 14451
// if GetTech ( i , side ) <> state then
14411: LD_VAR 0 5
14415: PPUSH
14416: LD_VAR 0 1
14420: PPUSH
14421: CALL_OW 321
14425: PUSH
14426: LD_VAR 0 3
14430: NONEQUAL
14431: IFFALSE 14449
// result := result diff i ;
14433: LD_ADDR_VAR 0 4
14437: PUSH
14438: LD_VAR 0 4
14442: PUSH
14443: LD_VAR 0 5
14447: DIFF
14448: ST_TO_ADDR
14449: GO 14408
14451: POP
14452: POP
// end ;
14453: LD_VAR 0 4
14457: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14458: LD_INT 0
14460: PPUSH
14461: PPUSH
14462: PPUSH
// result := true ;
14463: LD_ADDR_VAR 0 3
14467: PUSH
14468: LD_INT 1
14470: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14471: LD_ADDR_VAR 0 5
14475: PUSH
14476: LD_VAR 0 2
14480: PPUSH
14481: CALL_OW 480
14485: ST_TO_ADDR
// if not tmp then
14486: LD_VAR 0 5
14490: NOT
14491: IFFALSE 14495
// exit ;
14493: GO 14544
// for i in tmp do
14495: LD_ADDR_VAR 0 4
14499: PUSH
14500: LD_VAR 0 5
14504: PUSH
14505: FOR_IN
14506: IFFALSE 14542
// if GetTech ( i , side ) <> state_researched then
14508: LD_VAR 0 4
14512: PPUSH
14513: LD_VAR 0 1
14517: PPUSH
14518: CALL_OW 321
14522: PUSH
14523: LD_INT 2
14525: NONEQUAL
14526: IFFALSE 14540
// begin result := false ;
14528: LD_ADDR_VAR 0 3
14532: PUSH
14533: LD_INT 0
14535: ST_TO_ADDR
// exit ;
14536: POP
14537: POP
14538: GO 14544
// end ;
14540: GO 14505
14542: POP
14543: POP
// end ;
14544: LD_VAR 0 3
14548: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14549: LD_INT 0
14551: PPUSH
14552: PPUSH
14553: PPUSH
14554: PPUSH
14555: PPUSH
14556: PPUSH
14557: PPUSH
14558: PPUSH
14559: PPUSH
14560: PPUSH
14561: PPUSH
14562: PPUSH
14563: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14564: LD_VAR 0 1
14568: NOT
14569: PUSH
14570: LD_VAR 0 1
14574: PPUSH
14575: CALL_OW 257
14579: PUSH
14580: LD_INT 9
14582: NONEQUAL
14583: OR
14584: IFFALSE 14588
// exit ;
14586: GO 15161
// side := GetSide ( unit ) ;
14588: LD_ADDR_VAR 0 9
14592: PUSH
14593: LD_VAR 0 1
14597: PPUSH
14598: CALL_OW 255
14602: ST_TO_ADDR
// tech_space := tech_spacanom ;
14603: LD_ADDR_VAR 0 12
14607: PUSH
14608: LD_INT 29
14610: ST_TO_ADDR
// tech_time := tech_taurad ;
14611: LD_ADDR_VAR 0 13
14615: PUSH
14616: LD_INT 28
14618: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14619: LD_ADDR_VAR 0 11
14623: PUSH
14624: LD_VAR 0 1
14628: PPUSH
14629: CALL_OW 310
14633: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14634: LD_VAR 0 11
14638: PPUSH
14639: CALL_OW 247
14643: PUSH
14644: LD_INT 2
14646: EQUAL
14647: IFFALSE 14651
// exit ;
14649: GO 15161
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14651: LD_ADDR_VAR 0 8
14655: PUSH
14656: LD_INT 81
14658: PUSH
14659: LD_VAR 0 9
14663: PUSH
14664: EMPTY
14665: LIST
14666: LIST
14667: PUSH
14668: LD_INT 3
14670: PUSH
14671: LD_INT 21
14673: PUSH
14674: LD_INT 3
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: PPUSH
14689: CALL_OW 69
14693: ST_TO_ADDR
// if not tmp then
14694: LD_VAR 0 8
14698: NOT
14699: IFFALSE 14703
// exit ;
14701: GO 15161
// if in_unit then
14703: LD_VAR 0 11
14707: IFFALSE 14731
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14709: LD_ADDR_VAR 0 10
14713: PUSH
14714: LD_VAR 0 8
14718: PPUSH
14719: LD_VAR 0 11
14723: PPUSH
14724: CALL_OW 74
14728: ST_TO_ADDR
14729: GO 14751
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14731: LD_ADDR_VAR 0 10
14735: PUSH
14736: LD_VAR 0 8
14740: PPUSH
14741: LD_VAR 0 1
14745: PPUSH
14746: CALL_OW 74
14750: ST_TO_ADDR
// if not enemy then
14751: LD_VAR 0 10
14755: NOT
14756: IFFALSE 14760
// exit ;
14758: GO 15161
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14760: LD_VAR 0 11
14764: PUSH
14765: LD_VAR 0 11
14769: PPUSH
14770: LD_VAR 0 10
14774: PPUSH
14775: CALL_OW 296
14779: PUSH
14780: LD_INT 13
14782: GREATER
14783: AND
14784: PUSH
14785: LD_VAR 0 1
14789: PPUSH
14790: LD_VAR 0 10
14794: PPUSH
14795: CALL_OW 296
14799: PUSH
14800: LD_INT 12
14802: GREATER
14803: OR
14804: IFFALSE 14808
// exit ;
14806: GO 15161
// missile := [ 1 ] ;
14808: LD_ADDR_VAR 0 14
14812: PUSH
14813: LD_INT 1
14815: PUSH
14816: EMPTY
14817: LIST
14818: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14819: LD_VAR 0 9
14823: PPUSH
14824: LD_VAR 0 12
14828: PPUSH
14829: CALL_OW 325
14833: IFFALSE 14862
// missile := Insert ( missile , missile + 1 , 2 ) ;
14835: LD_ADDR_VAR 0 14
14839: PUSH
14840: LD_VAR 0 14
14844: PPUSH
14845: LD_VAR 0 14
14849: PUSH
14850: LD_INT 1
14852: PLUS
14853: PPUSH
14854: LD_INT 2
14856: PPUSH
14857: CALL_OW 2
14861: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14862: LD_VAR 0 9
14866: PPUSH
14867: LD_VAR 0 13
14871: PPUSH
14872: CALL_OW 325
14876: PUSH
14877: LD_VAR 0 10
14881: PPUSH
14882: CALL_OW 255
14886: PPUSH
14887: LD_VAR 0 13
14891: PPUSH
14892: CALL_OW 325
14896: NOT
14897: AND
14898: IFFALSE 14927
// missile := Insert ( missile , missile + 1 , 3 ) ;
14900: LD_ADDR_VAR 0 14
14904: PUSH
14905: LD_VAR 0 14
14909: PPUSH
14910: LD_VAR 0 14
14914: PUSH
14915: LD_INT 1
14917: PLUS
14918: PPUSH
14919: LD_INT 3
14921: PPUSH
14922: CALL_OW 2
14926: ST_TO_ADDR
// if missile < 2 then
14927: LD_VAR 0 14
14931: PUSH
14932: LD_INT 2
14934: LESS
14935: IFFALSE 14939
// exit ;
14937: GO 15161
// x := GetX ( enemy ) ;
14939: LD_ADDR_VAR 0 4
14943: PUSH
14944: LD_VAR 0 10
14948: PPUSH
14949: CALL_OW 250
14953: ST_TO_ADDR
// y := GetY ( enemy ) ;
14954: LD_ADDR_VAR 0 5
14958: PUSH
14959: LD_VAR 0 10
14963: PPUSH
14964: CALL_OW 251
14968: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14969: LD_ADDR_VAR 0 6
14973: PUSH
14974: LD_VAR 0 4
14978: PUSH
14979: LD_INT 1
14981: NEG
14982: PPUSH
14983: LD_INT 1
14985: PPUSH
14986: CALL_OW 12
14990: PLUS
14991: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
14992: LD_ADDR_VAR 0 7
14996: PUSH
14997: LD_VAR 0 5
15001: PUSH
15002: LD_INT 1
15004: NEG
15005: PPUSH
15006: LD_INT 1
15008: PPUSH
15009: CALL_OW 12
15013: PLUS
15014: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15015: LD_VAR 0 6
15019: PPUSH
15020: LD_VAR 0 7
15024: PPUSH
15025: CALL_OW 488
15029: NOT
15030: IFFALSE 15052
// begin _x := x ;
15032: LD_ADDR_VAR 0 6
15036: PUSH
15037: LD_VAR 0 4
15041: ST_TO_ADDR
// _y := y ;
15042: LD_ADDR_VAR 0 7
15046: PUSH
15047: LD_VAR 0 5
15051: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15052: LD_ADDR_VAR 0 3
15056: PUSH
15057: LD_INT 1
15059: PPUSH
15060: LD_VAR 0 14
15064: PPUSH
15065: CALL_OW 12
15069: ST_TO_ADDR
// case i of 1 :
15070: LD_VAR 0 3
15074: PUSH
15075: LD_INT 1
15077: DOUBLE
15078: EQUAL
15079: IFTRUE 15083
15081: GO 15100
15083: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15084: LD_VAR 0 1
15088: PPUSH
15089: LD_VAR 0 10
15093: PPUSH
15094: CALL_OW 115
15098: GO 15161
15100: LD_INT 2
15102: DOUBLE
15103: EQUAL
15104: IFTRUE 15108
15106: GO 15130
15108: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15109: LD_VAR 0 1
15113: PPUSH
15114: LD_VAR 0 6
15118: PPUSH
15119: LD_VAR 0 7
15123: PPUSH
15124: CALL_OW 153
15128: GO 15161
15130: LD_INT 3
15132: DOUBLE
15133: EQUAL
15134: IFTRUE 15138
15136: GO 15160
15138: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15139: LD_VAR 0 1
15143: PPUSH
15144: LD_VAR 0 6
15148: PPUSH
15149: LD_VAR 0 7
15153: PPUSH
15154: CALL_OW 154
15158: GO 15161
15160: POP
// end ;
15161: LD_VAR 0 2
15165: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15166: LD_INT 0
15168: PPUSH
15169: PPUSH
15170: PPUSH
15171: PPUSH
15172: PPUSH
15173: PPUSH
// if not unit or not building then
15174: LD_VAR 0 1
15178: NOT
15179: PUSH
15180: LD_VAR 0 2
15184: NOT
15185: OR
15186: IFFALSE 15190
// exit ;
15188: GO 15348
// x := GetX ( building ) ;
15190: LD_ADDR_VAR 0 5
15194: PUSH
15195: LD_VAR 0 2
15199: PPUSH
15200: CALL_OW 250
15204: ST_TO_ADDR
// y := GetY ( building ) ;
15205: LD_ADDR_VAR 0 6
15209: PUSH
15210: LD_VAR 0 2
15214: PPUSH
15215: CALL_OW 251
15219: ST_TO_ADDR
// for i = 0 to 5 do
15220: LD_ADDR_VAR 0 4
15224: PUSH
15225: DOUBLE
15226: LD_INT 0
15228: DEC
15229: ST_TO_ADDR
15230: LD_INT 5
15232: PUSH
15233: FOR_TO
15234: IFFALSE 15346
// begin _x := ShiftX ( x , i , 3 ) ;
15236: LD_ADDR_VAR 0 7
15240: PUSH
15241: LD_VAR 0 5
15245: PPUSH
15246: LD_VAR 0 4
15250: PPUSH
15251: LD_INT 3
15253: PPUSH
15254: CALL_OW 272
15258: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15259: LD_ADDR_VAR 0 8
15263: PUSH
15264: LD_VAR 0 6
15268: PPUSH
15269: LD_VAR 0 4
15273: PPUSH
15274: LD_INT 3
15276: PPUSH
15277: CALL_OW 273
15281: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15282: LD_VAR 0 7
15286: PPUSH
15287: LD_VAR 0 8
15291: PPUSH
15292: CALL_OW 488
15296: NOT
15297: IFFALSE 15301
// continue ;
15299: GO 15233
// if HexInfo ( _x , _y ) = 0 then
15301: LD_VAR 0 7
15305: PPUSH
15306: LD_VAR 0 8
15310: PPUSH
15311: CALL_OW 428
15315: PUSH
15316: LD_INT 0
15318: EQUAL
15319: IFFALSE 15344
// begin ComMoveXY ( unit , _x , _y ) ;
15321: LD_VAR 0 1
15325: PPUSH
15326: LD_VAR 0 7
15330: PPUSH
15331: LD_VAR 0 8
15335: PPUSH
15336: CALL_OW 111
// exit ;
15340: POP
15341: POP
15342: GO 15348
// end ; end ;
15344: GO 15233
15346: POP
15347: POP
// end ;
15348: LD_VAR 0 3
15352: RET
// export function ScanBase ( side , base_area ) ; begin
15353: LD_INT 0
15355: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15356: LD_ADDR_VAR 0 3
15360: PUSH
15361: LD_VAR 0 2
15365: PPUSH
15366: LD_INT 81
15368: PUSH
15369: LD_VAR 0 1
15373: PUSH
15374: EMPTY
15375: LIST
15376: LIST
15377: PPUSH
15378: CALL_OW 70
15382: ST_TO_ADDR
// end ;
15383: LD_VAR 0 3
15387: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15388: LD_INT 0
15390: PPUSH
15391: PPUSH
15392: PPUSH
15393: PPUSH
// result := false ;
15394: LD_ADDR_VAR 0 2
15398: PUSH
15399: LD_INT 0
15401: ST_TO_ADDR
// side := GetSide ( unit ) ;
15402: LD_ADDR_VAR 0 3
15406: PUSH
15407: LD_VAR 0 1
15411: PPUSH
15412: CALL_OW 255
15416: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15417: LD_ADDR_VAR 0 4
15421: PUSH
15422: LD_VAR 0 1
15426: PPUSH
15427: CALL_OW 248
15431: ST_TO_ADDR
// case nat of 1 :
15432: LD_VAR 0 4
15436: PUSH
15437: LD_INT 1
15439: DOUBLE
15440: EQUAL
15441: IFTRUE 15445
15443: GO 15456
15445: POP
// tech := tech_lassight ; 2 :
15446: LD_ADDR_VAR 0 5
15450: PUSH
15451: LD_INT 12
15453: ST_TO_ADDR
15454: GO 15495
15456: LD_INT 2
15458: DOUBLE
15459: EQUAL
15460: IFTRUE 15464
15462: GO 15475
15464: POP
// tech := tech_mortar ; 3 :
15465: LD_ADDR_VAR 0 5
15469: PUSH
15470: LD_INT 41
15472: ST_TO_ADDR
15473: GO 15495
15475: LD_INT 3
15477: DOUBLE
15478: EQUAL
15479: IFTRUE 15483
15481: GO 15494
15483: POP
// tech := tech_bazooka ; end ;
15484: LD_ADDR_VAR 0 5
15488: PUSH
15489: LD_INT 44
15491: ST_TO_ADDR
15492: GO 15495
15494: POP
// if Researched ( side , tech ) then
15495: LD_VAR 0 3
15499: PPUSH
15500: LD_VAR 0 5
15504: PPUSH
15505: CALL_OW 325
15509: IFFALSE 15536
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15511: LD_ADDR_VAR 0 2
15515: PUSH
15516: LD_INT 5
15518: PUSH
15519: LD_INT 8
15521: PUSH
15522: LD_INT 9
15524: PUSH
15525: EMPTY
15526: LIST
15527: LIST
15528: LIST
15529: PUSH
15530: LD_VAR 0 4
15534: ARRAY
15535: ST_TO_ADDR
// end ;
15536: LD_VAR 0 2
15540: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15541: LD_INT 0
15543: PPUSH
15544: PPUSH
15545: PPUSH
// if not mines then
15546: LD_VAR 0 2
15550: NOT
15551: IFFALSE 15555
// exit ;
15553: GO 15699
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15555: LD_ADDR_VAR 0 5
15559: PUSH
15560: LD_INT 81
15562: PUSH
15563: LD_VAR 0 1
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: LD_INT 3
15574: PUSH
15575: LD_INT 21
15577: PUSH
15578: LD_INT 3
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PUSH
15589: EMPTY
15590: LIST
15591: LIST
15592: PPUSH
15593: CALL_OW 69
15597: ST_TO_ADDR
// for i in mines do
15598: LD_ADDR_VAR 0 4
15602: PUSH
15603: LD_VAR 0 2
15607: PUSH
15608: FOR_IN
15609: IFFALSE 15697
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15611: LD_VAR 0 4
15615: PUSH
15616: LD_INT 1
15618: ARRAY
15619: PPUSH
15620: LD_VAR 0 4
15624: PUSH
15625: LD_INT 2
15627: ARRAY
15628: PPUSH
15629: CALL_OW 458
15633: NOT
15634: IFFALSE 15638
// continue ;
15636: GO 15608
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15638: LD_VAR 0 4
15642: PUSH
15643: LD_INT 1
15645: ARRAY
15646: PPUSH
15647: LD_VAR 0 4
15651: PUSH
15652: LD_INT 2
15654: ARRAY
15655: PPUSH
15656: CALL_OW 428
15660: PUSH
15661: LD_VAR 0 5
15665: IN
15666: IFFALSE 15695
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15668: LD_VAR 0 4
15672: PUSH
15673: LD_INT 1
15675: ARRAY
15676: PPUSH
15677: LD_VAR 0 4
15681: PUSH
15682: LD_INT 2
15684: ARRAY
15685: PPUSH
15686: LD_VAR 0 1
15690: PPUSH
15691: CALL_OW 456
// end ;
15695: GO 15608
15697: POP
15698: POP
// end ;
15699: LD_VAR 0 3
15703: RET
// export function Count ( array ) ; var i ; begin
15704: LD_INT 0
15706: PPUSH
15707: PPUSH
// result := 0 ;
15708: LD_ADDR_VAR 0 2
15712: PUSH
15713: LD_INT 0
15715: ST_TO_ADDR
// for i in array do
15716: LD_ADDR_VAR 0 3
15720: PUSH
15721: LD_VAR 0 1
15725: PUSH
15726: FOR_IN
15727: IFFALSE 15751
// if i then
15729: LD_VAR 0 3
15733: IFFALSE 15749
// result := result + 1 ;
15735: LD_ADDR_VAR 0 2
15739: PUSH
15740: LD_VAR 0 2
15744: PUSH
15745: LD_INT 1
15747: PLUS
15748: ST_TO_ADDR
15749: GO 15726
15751: POP
15752: POP
// end ;
15753: LD_VAR 0 2
15757: RET
// export function IsEmpty ( building ) ; begin
15758: LD_INT 0
15760: PPUSH
// if not building then
15761: LD_VAR 0 1
15765: NOT
15766: IFFALSE 15770
// exit ;
15768: GO 15813
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15770: LD_ADDR_VAR 0 2
15774: PUSH
15775: LD_VAR 0 1
15779: PUSH
15780: LD_INT 22
15782: PUSH
15783: LD_VAR 0 1
15787: PPUSH
15788: CALL_OW 255
15792: PUSH
15793: EMPTY
15794: LIST
15795: LIST
15796: PUSH
15797: LD_INT 58
15799: PUSH
15800: EMPTY
15801: LIST
15802: PUSH
15803: EMPTY
15804: LIST
15805: LIST
15806: PPUSH
15807: CALL_OW 69
15811: IN
15812: ST_TO_ADDR
// end ;
15813: LD_VAR 0 2
15817: RET
// export function IsNotFull ( building ) ; begin
15818: LD_INT 0
15820: PPUSH
// if not building then
15821: LD_VAR 0 1
15825: NOT
15826: IFFALSE 15830
// exit ;
15828: GO 15849
// result := UnitsInside ( building ) < 6 ;
15830: LD_ADDR_VAR 0 2
15834: PUSH
15835: LD_VAR 0 1
15839: PPUSH
15840: CALL_OW 313
15844: PUSH
15845: LD_INT 6
15847: LESS
15848: ST_TO_ADDR
// end ;
15849: LD_VAR 0 2
15853: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
15854: LD_INT 0
15856: PPUSH
15857: PPUSH
15858: PPUSH
15859: PPUSH
// tmp := [ ] ;
15860: LD_ADDR_VAR 0 3
15864: PUSH
15865: EMPTY
15866: ST_TO_ADDR
// list := [ ] ;
15867: LD_ADDR_VAR 0 5
15871: PUSH
15872: EMPTY
15873: ST_TO_ADDR
// for i = 16 to 25 do
15874: LD_ADDR_VAR 0 4
15878: PUSH
15879: DOUBLE
15880: LD_INT 16
15882: DEC
15883: ST_TO_ADDR
15884: LD_INT 25
15886: PUSH
15887: FOR_TO
15888: IFFALSE 15961
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
15890: LD_ADDR_VAR 0 3
15894: PUSH
15895: LD_VAR 0 3
15899: PUSH
15900: LD_INT 22
15902: PUSH
15903: LD_VAR 0 1
15907: PPUSH
15908: CALL_OW 255
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: PUSH
15917: LD_INT 91
15919: PUSH
15920: LD_VAR 0 1
15924: PUSH
15925: LD_INT 6
15927: PUSH
15928: EMPTY
15929: LIST
15930: LIST
15931: LIST
15932: PUSH
15933: LD_INT 30
15935: PUSH
15936: LD_VAR 0 4
15940: PUSH
15941: EMPTY
15942: LIST
15943: LIST
15944: PUSH
15945: EMPTY
15946: LIST
15947: LIST
15948: LIST
15949: PUSH
15950: EMPTY
15951: LIST
15952: PPUSH
15953: CALL_OW 69
15957: ADD
15958: ST_TO_ADDR
15959: GO 15887
15961: POP
15962: POP
// for i = 1 to tmp do
15963: LD_ADDR_VAR 0 4
15967: PUSH
15968: DOUBLE
15969: LD_INT 1
15971: DEC
15972: ST_TO_ADDR
15973: LD_VAR 0 3
15977: PUSH
15978: FOR_TO
15979: IFFALSE 16067
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
15981: LD_ADDR_VAR 0 5
15985: PUSH
15986: LD_VAR 0 5
15990: PUSH
15991: LD_VAR 0 3
15995: PUSH
15996: LD_VAR 0 4
16000: ARRAY
16001: PPUSH
16002: CALL_OW 266
16006: PUSH
16007: LD_VAR 0 3
16011: PUSH
16012: LD_VAR 0 4
16016: ARRAY
16017: PPUSH
16018: CALL_OW 250
16022: PUSH
16023: LD_VAR 0 3
16027: PUSH
16028: LD_VAR 0 4
16032: ARRAY
16033: PPUSH
16034: CALL_OW 251
16038: PUSH
16039: LD_VAR 0 3
16043: PUSH
16044: LD_VAR 0 4
16048: ARRAY
16049: PPUSH
16050: CALL_OW 254
16054: PUSH
16055: EMPTY
16056: LIST
16057: LIST
16058: LIST
16059: LIST
16060: PUSH
16061: EMPTY
16062: LIST
16063: ADD
16064: ST_TO_ADDR
16065: GO 15978
16067: POP
16068: POP
// result := list ;
16069: LD_ADDR_VAR 0 2
16073: PUSH
16074: LD_VAR 0 5
16078: ST_TO_ADDR
// end ;
16079: LD_VAR 0 2
16083: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16084: LD_INT 0
16086: PPUSH
16087: PPUSH
16088: PPUSH
16089: PPUSH
16090: PPUSH
16091: PPUSH
16092: PPUSH
// if not factory then
16093: LD_VAR 0 1
16097: NOT
16098: IFFALSE 16102
// exit ;
16100: GO 16695
// if control = control_apeman then
16102: LD_VAR 0 4
16106: PUSH
16107: LD_INT 5
16109: EQUAL
16110: IFFALSE 16219
// begin tmp := UnitsInside ( factory ) ;
16112: LD_ADDR_VAR 0 8
16116: PUSH
16117: LD_VAR 0 1
16121: PPUSH
16122: CALL_OW 313
16126: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16127: LD_VAR 0 8
16131: PPUSH
16132: LD_INT 25
16134: PUSH
16135: LD_INT 12
16137: PUSH
16138: EMPTY
16139: LIST
16140: LIST
16141: PPUSH
16142: CALL_OW 72
16146: NOT
16147: IFFALSE 16157
// control := control_manual ;
16149: LD_ADDR_VAR 0 4
16153: PUSH
16154: LD_INT 1
16156: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16157: LD_ADDR_VAR 0 8
16161: PUSH
16162: LD_VAR 0 1
16166: PPUSH
16167: CALL 15854 0 1
16171: ST_TO_ADDR
// if tmp then
16172: LD_VAR 0 8
16176: IFFALSE 16219
// begin for i in tmp do
16178: LD_ADDR_VAR 0 7
16182: PUSH
16183: LD_VAR 0 8
16187: PUSH
16188: FOR_IN
16189: IFFALSE 16217
// if i [ 1 ] = b_ext_radio then
16191: LD_VAR 0 7
16195: PUSH
16196: LD_INT 1
16198: ARRAY
16199: PUSH
16200: LD_INT 22
16202: EQUAL
16203: IFFALSE 16215
// begin control := control_remote ;
16205: LD_ADDR_VAR 0 4
16209: PUSH
16210: LD_INT 2
16212: ST_TO_ADDR
// break ;
16213: GO 16217
// end ;
16215: GO 16188
16217: POP
16218: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16219: LD_VAR 0 1
16223: PPUSH
16224: LD_VAR 0 2
16228: PPUSH
16229: LD_VAR 0 3
16233: PPUSH
16234: LD_VAR 0 4
16238: PPUSH
16239: LD_VAR 0 5
16243: PPUSH
16244: CALL_OW 448
16248: IFFALSE 16283
// begin result := [ chassis , engine , control , weapon ] ;
16250: LD_ADDR_VAR 0 6
16254: PUSH
16255: LD_VAR 0 2
16259: PUSH
16260: LD_VAR 0 3
16264: PUSH
16265: LD_VAR 0 4
16269: PUSH
16270: LD_VAR 0 5
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: LIST
16279: LIST
16280: ST_TO_ADDR
// exit ;
16281: GO 16695
// end ; _chassis := AvailableChassisList ( factory ) ;
16283: LD_ADDR_VAR 0 9
16287: PUSH
16288: LD_VAR 0 1
16292: PPUSH
16293: CALL_OW 475
16297: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16298: LD_ADDR_VAR 0 11
16302: PUSH
16303: LD_VAR 0 1
16307: PPUSH
16308: CALL_OW 476
16312: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16313: LD_ADDR_VAR 0 12
16317: PUSH
16318: LD_VAR 0 1
16322: PPUSH
16323: CALL_OW 477
16327: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
16328: LD_ADDR_VAR 0 10
16332: PUSH
16333: LD_VAR 0 1
16337: PPUSH
16338: CALL_OW 478
16342: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
16343: LD_VAR 0 9
16347: NOT
16348: PUSH
16349: LD_VAR 0 11
16353: NOT
16354: OR
16355: PUSH
16356: LD_VAR 0 12
16360: NOT
16361: OR
16362: PUSH
16363: LD_VAR 0 10
16367: NOT
16368: OR
16369: IFFALSE 16404
// begin result := [ chassis , engine , control , weapon ] ;
16371: LD_ADDR_VAR 0 6
16375: PUSH
16376: LD_VAR 0 2
16380: PUSH
16381: LD_VAR 0 3
16385: PUSH
16386: LD_VAR 0 4
16390: PUSH
16391: LD_VAR 0 5
16395: PUSH
16396: EMPTY
16397: LIST
16398: LIST
16399: LIST
16400: LIST
16401: ST_TO_ADDR
// exit ;
16402: GO 16695
// end ; if not chassis in _chassis then
16404: LD_VAR 0 2
16408: PUSH
16409: LD_VAR 0 9
16413: IN
16414: NOT
16415: IFFALSE 16441
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: LD_VAR 0 9
16426: PUSH
16427: LD_INT 1
16429: PPUSH
16430: LD_VAR 0 9
16434: PPUSH
16435: CALL_OW 12
16439: ARRAY
16440: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16441: LD_VAR 0 2
16445: PPUSH
16446: LD_VAR 0 3
16450: PPUSH
16451: CALL 16700 0 2
16455: NOT
16456: IFFALSE 16515
// repeat engine := _engine [ 1 ] ;
16458: LD_ADDR_VAR 0 3
16462: PUSH
16463: LD_VAR 0 11
16467: PUSH
16468: LD_INT 1
16470: ARRAY
16471: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16472: LD_ADDR_VAR 0 11
16476: PUSH
16477: LD_VAR 0 11
16481: PPUSH
16482: LD_INT 1
16484: PPUSH
16485: CALL_OW 3
16489: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16490: LD_VAR 0 2
16494: PPUSH
16495: LD_VAR 0 3
16499: PPUSH
16500: CALL 16700 0 2
16504: PUSH
16505: LD_VAR 0 11
16509: PUSH
16510: EMPTY
16511: EQUAL
16512: OR
16513: IFFALSE 16458
// if not control in _control then
16515: LD_VAR 0 4
16519: PUSH
16520: LD_VAR 0 12
16524: IN
16525: NOT
16526: IFFALSE 16552
// control := _control [ rand ( 1 , _control ) ] ;
16528: LD_ADDR_VAR 0 4
16532: PUSH
16533: LD_VAR 0 12
16537: PUSH
16538: LD_INT 1
16540: PPUSH
16541: LD_VAR 0 12
16545: PPUSH
16546: CALL_OW 12
16550: ARRAY
16551: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16552: LD_VAR 0 2
16556: PPUSH
16557: LD_VAR 0 5
16561: PPUSH
16562: CALL 16920 0 2
16566: NOT
16567: IFFALSE 16626
// repeat weapon := _weapon [ 1 ] ;
16569: LD_ADDR_VAR 0 5
16573: PUSH
16574: LD_VAR 0 10
16578: PUSH
16579: LD_INT 1
16581: ARRAY
16582: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16583: LD_ADDR_VAR 0 10
16587: PUSH
16588: LD_VAR 0 10
16592: PPUSH
16593: LD_INT 1
16595: PPUSH
16596: CALL_OW 3
16600: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16601: LD_VAR 0 2
16605: PPUSH
16606: LD_VAR 0 5
16610: PPUSH
16611: CALL 16920 0 2
16615: PUSH
16616: LD_VAR 0 10
16620: PUSH
16621: EMPTY
16622: EQUAL
16623: OR
16624: IFFALSE 16569
// result := [ ] ;
16626: LD_ADDR_VAR 0 6
16630: PUSH
16631: EMPTY
16632: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16633: LD_VAR 0 1
16637: PPUSH
16638: LD_VAR 0 2
16642: PPUSH
16643: LD_VAR 0 3
16647: PPUSH
16648: LD_VAR 0 4
16652: PPUSH
16653: LD_VAR 0 5
16657: PPUSH
16658: CALL_OW 448
16662: IFFALSE 16695
// result := [ chassis , engine , control , weapon ] ;
16664: LD_ADDR_VAR 0 6
16668: PUSH
16669: LD_VAR 0 2
16673: PUSH
16674: LD_VAR 0 3
16678: PUSH
16679: LD_VAR 0 4
16683: PUSH
16684: LD_VAR 0 5
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: LIST
16693: LIST
16694: ST_TO_ADDR
// end ;
16695: LD_VAR 0 6
16699: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16700: LD_INT 0
16702: PPUSH
// if not chassis or not engine then
16703: LD_VAR 0 1
16707: NOT
16708: PUSH
16709: LD_VAR 0 2
16713: NOT
16714: OR
16715: IFFALSE 16719
// exit ;
16717: GO 16915
// case engine of engine_solar :
16719: LD_VAR 0 2
16723: PUSH
16724: LD_INT 2
16726: DOUBLE
16727: EQUAL
16728: IFTRUE 16732
16730: GO 16770
16732: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16733: LD_ADDR_VAR 0 3
16737: PUSH
16738: LD_INT 11
16740: PUSH
16741: LD_INT 12
16743: PUSH
16744: LD_INT 13
16746: PUSH
16747: LD_INT 14
16749: PUSH
16750: LD_INT 1
16752: PUSH
16753: LD_INT 2
16755: PUSH
16756: LD_INT 3
16758: PUSH
16759: EMPTY
16760: LIST
16761: LIST
16762: LIST
16763: LIST
16764: LIST
16765: LIST
16766: LIST
16767: ST_TO_ADDR
16768: GO 16899
16770: LD_INT 1
16772: DOUBLE
16773: EQUAL
16774: IFTRUE 16778
16776: GO 16840
16778: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16779: LD_ADDR_VAR 0 3
16783: PUSH
16784: LD_INT 11
16786: PUSH
16787: LD_INT 12
16789: PUSH
16790: LD_INT 13
16792: PUSH
16793: LD_INT 14
16795: PUSH
16796: LD_INT 1
16798: PUSH
16799: LD_INT 2
16801: PUSH
16802: LD_INT 3
16804: PUSH
16805: LD_INT 4
16807: PUSH
16808: LD_INT 5
16810: PUSH
16811: LD_INT 21
16813: PUSH
16814: LD_INT 23
16816: PUSH
16817: LD_INT 22
16819: PUSH
16820: LD_INT 24
16822: PUSH
16823: EMPTY
16824: LIST
16825: LIST
16826: LIST
16827: LIST
16828: LIST
16829: LIST
16830: LIST
16831: LIST
16832: LIST
16833: LIST
16834: LIST
16835: LIST
16836: LIST
16837: ST_TO_ADDR
16838: GO 16899
16840: LD_INT 3
16842: DOUBLE
16843: EQUAL
16844: IFTRUE 16848
16846: GO 16898
16848: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
16849: LD_ADDR_VAR 0 3
16853: PUSH
16854: LD_INT 13
16856: PUSH
16857: LD_INT 14
16859: PUSH
16860: LD_INT 2
16862: PUSH
16863: LD_INT 3
16865: PUSH
16866: LD_INT 4
16868: PUSH
16869: LD_INT 5
16871: PUSH
16872: LD_INT 21
16874: PUSH
16875: LD_INT 22
16877: PUSH
16878: LD_INT 23
16880: PUSH
16881: LD_INT 24
16883: PUSH
16884: EMPTY
16885: LIST
16886: LIST
16887: LIST
16888: LIST
16889: LIST
16890: LIST
16891: LIST
16892: LIST
16893: LIST
16894: LIST
16895: ST_TO_ADDR
16896: GO 16899
16898: POP
// result := ( chassis in result ) ;
16899: LD_ADDR_VAR 0 3
16903: PUSH
16904: LD_VAR 0 1
16908: PUSH
16909: LD_VAR 0 3
16913: IN
16914: ST_TO_ADDR
// end ;
16915: LD_VAR 0 3
16919: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
16920: LD_INT 0
16922: PPUSH
// if not chassis or not weapon then
16923: LD_VAR 0 1
16927: NOT
16928: PUSH
16929: LD_VAR 0 2
16933: NOT
16934: OR
16935: IFFALSE 16939
// exit ;
16937: GO 18001
// case weapon of us_machine_gun :
16939: LD_VAR 0 2
16943: PUSH
16944: LD_INT 2
16946: DOUBLE
16947: EQUAL
16948: IFTRUE 16952
16950: GO 16982
16952: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
16953: LD_ADDR_VAR 0 3
16957: PUSH
16958: LD_INT 1
16960: PUSH
16961: LD_INT 2
16963: PUSH
16964: LD_INT 3
16966: PUSH
16967: LD_INT 4
16969: PUSH
16970: LD_INT 5
16972: PUSH
16973: EMPTY
16974: LIST
16975: LIST
16976: LIST
16977: LIST
16978: LIST
16979: ST_TO_ADDR
16980: GO 17985
16982: LD_INT 3
16984: DOUBLE
16985: EQUAL
16986: IFTRUE 16990
16988: GO 17020
16990: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
16991: LD_ADDR_VAR 0 3
16995: PUSH
16996: LD_INT 1
16998: PUSH
16999: LD_INT 2
17001: PUSH
17002: LD_INT 3
17004: PUSH
17005: LD_INT 4
17007: PUSH
17008: LD_INT 5
17010: PUSH
17011: EMPTY
17012: LIST
17013: LIST
17014: LIST
17015: LIST
17016: LIST
17017: ST_TO_ADDR
17018: GO 17985
17020: LD_INT 11
17022: DOUBLE
17023: EQUAL
17024: IFTRUE 17028
17026: GO 17058
17028: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17029: LD_ADDR_VAR 0 3
17033: PUSH
17034: LD_INT 1
17036: PUSH
17037: LD_INT 2
17039: PUSH
17040: LD_INT 3
17042: PUSH
17043: LD_INT 4
17045: PUSH
17046: LD_INT 5
17048: PUSH
17049: EMPTY
17050: LIST
17051: LIST
17052: LIST
17053: LIST
17054: LIST
17055: ST_TO_ADDR
17056: GO 17985
17058: LD_INT 4
17060: DOUBLE
17061: EQUAL
17062: IFTRUE 17066
17064: GO 17092
17066: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17067: LD_ADDR_VAR 0 3
17071: PUSH
17072: LD_INT 2
17074: PUSH
17075: LD_INT 3
17077: PUSH
17078: LD_INT 4
17080: PUSH
17081: LD_INT 5
17083: PUSH
17084: EMPTY
17085: LIST
17086: LIST
17087: LIST
17088: LIST
17089: ST_TO_ADDR
17090: GO 17985
17092: LD_INT 5
17094: DOUBLE
17095: EQUAL
17096: IFTRUE 17100
17098: GO 17126
17100: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17101: LD_ADDR_VAR 0 3
17105: PUSH
17106: LD_INT 2
17108: PUSH
17109: LD_INT 3
17111: PUSH
17112: LD_INT 4
17114: PUSH
17115: LD_INT 5
17117: PUSH
17118: EMPTY
17119: LIST
17120: LIST
17121: LIST
17122: LIST
17123: ST_TO_ADDR
17124: GO 17985
17126: LD_INT 9
17128: DOUBLE
17129: EQUAL
17130: IFTRUE 17134
17132: GO 17160
17134: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17135: LD_ADDR_VAR 0 3
17139: PUSH
17140: LD_INT 2
17142: PUSH
17143: LD_INT 3
17145: PUSH
17146: LD_INT 4
17148: PUSH
17149: LD_INT 5
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: LIST
17156: LIST
17157: ST_TO_ADDR
17158: GO 17985
17160: LD_INT 7
17162: DOUBLE
17163: EQUAL
17164: IFTRUE 17168
17166: GO 17194
17168: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17169: LD_ADDR_VAR 0 3
17173: PUSH
17174: LD_INT 2
17176: PUSH
17177: LD_INT 3
17179: PUSH
17180: LD_INT 4
17182: PUSH
17183: LD_INT 5
17185: PUSH
17186: EMPTY
17187: LIST
17188: LIST
17189: LIST
17190: LIST
17191: ST_TO_ADDR
17192: GO 17985
17194: LD_INT 12
17196: DOUBLE
17197: EQUAL
17198: IFTRUE 17202
17200: GO 17228
17202: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17203: LD_ADDR_VAR 0 3
17207: PUSH
17208: LD_INT 2
17210: PUSH
17211: LD_INT 3
17213: PUSH
17214: LD_INT 4
17216: PUSH
17217: LD_INT 5
17219: PUSH
17220: EMPTY
17221: LIST
17222: LIST
17223: LIST
17224: LIST
17225: ST_TO_ADDR
17226: GO 17985
17228: LD_INT 13
17230: DOUBLE
17231: EQUAL
17232: IFTRUE 17236
17234: GO 17262
17236: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17237: LD_ADDR_VAR 0 3
17241: PUSH
17242: LD_INT 2
17244: PUSH
17245: LD_INT 3
17247: PUSH
17248: LD_INT 4
17250: PUSH
17251: LD_INT 5
17253: PUSH
17254: EMPTY
17255: LIST
17256: LIST
17257: LIST
17258: LIST
17259: ST_TO_ADDR
17260: GO 17985
17262: LD_INT 14
17264: DOUBLE
17265: EQUAL
17266: IFTRUE 17270
17268: GO 17288
17270: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17271: LD_ADDR_VAR 0 3
17275: PUSH
17276: LD_INT 4
17278: PUSH
17279: LD_INT 5
17281: PUSH
17282: EMPTY
17283: LIST
17284: LIST
17285: ST_TO_ADDR
17286: GO 17985
17288: LD_INT 6
17290: DOUBLE
17291: EQUAL
17292: IFTRUE 17296
17294: GO 17314
17296: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17297: LD_ADDR_VAR 0 3
17301: PUSH
17302: LD_INT 4
17304: PUSH
17305: LD_INT 5
17307: PUSH
17308: EMPTY
17309: LIST
17310: LIST
17311: ST_TO_ADDR
17312: GO 17985
17314: LD_INT 10
17316: DOUBLE
17317: EQUAL
17318: IFTRUE 17322
17320: GO 17340
17322: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
17323: LD_ADDR_VAR 0 3
17327: PUSH
17328: LD_INT 4
17330: PUSH
17331: LD_INT 5
17333: PUSH
17334: EMPTY
17335: LIST
17336: LIST
17337: ST_TO_ADDR
17338: GO 17985
17340: LD_INT 22
17342: DOUBLE
17343: EQUAL
17344: IFTRUE 17348
17346: GO 17374
17348: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
17349: LD_ADDR_VAR 0 3
17353: PUSH
17354: LD_INT 11
17356: PUSH
17357: LD_INT 12
17359: PUSH
17360: LD_INT 13
17362: PUSH
17363: LD_INT 14
17365: PUSH
17366: EMPTY
17367: LIST
17368: LIST
17369: LIST
17370: LIST
17371: ST_TO_ADDR
17372: GO 17985
17374: LD_INT 23
17376: DOUBLE
17377: EQUAL
17378: IFTRUE 17382
17380: GO 17408
17382: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
17383: LD_ADDR_VAR 0 3
17387: PUSH
17388: LD_INT 11
17390: PUSH
17391: LD_INT 12
17393: PUSH
17394: LD_INT 13
17396: PUSH
17397: LD_INT 14
17399: PUSH
17400: EMPTY
17401: LIST
17402: LIST
17403: LIST
17404: LIST
17405: ST_TO_ADDR
17406: GO 17985
17408: LD_INT 24
17410: DOUBLE
17411: EQUAL
17412: IFTRUE 17416
17414: GO 17442
17416: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17417: LD_ADDR_VAR 0 3
17421: PUSH
17422: LD_INT 11
17424: PUSH
17425: LD_INT 12
17427: PUSH
17428: LD_INT 13
17430: PUSH
17431: LD_INT 14
17433: PUSH
17434: EMPTY
17435: LIST
17436: LIST
17437: LIST
17438: LIST
17439: ST_TO_ADDR
17440: GO 17985
17442: LD_INT 30
17444: DOUBLE
17445: EQUAL
17446: IFTRUE 17450
17448: GO 17476
17450: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17451: LD_ADDR_VAR 0 3
17455: PUSH
17456: LD_INT 11
17458: PUSH
17459: LD_INT 12
17461: PUSH
17462: LD_INT 13
17464: PUSH
17465: LD_INT 14
17467: PUSH
17468: EMPTY
17469: LIST
17470: LIST
17471: LIST
17472: LIST
17473: ST_TO_ADDR
17474: GO 17985
17476: LD_INT 25
17478: DOUBLE
17479: EQUAL
17480: IFTRUE 17484
17482: GO 17502
17484: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17485: LD_ADDR_VAR 0 3
17489: PUSH
17490: LD_INT 13
17492: PUSH
17493: LD_INT 14
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: ST_TO_ADDR
17500: GO 17985
17502: LD_INT 27
17504: DOUBLE
17505: EQUAL
17506: IFTRUE 17510
17508: GO 17528
17510: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
17511: LD_ADDR_VAR 0 3
17515: PUSH
17516: LD_INT 13
17518: PUSH
17519: LD_INT 14
17521: PUSH
17522: EMPTY
17523: LIST
17524: LIST
17525: ST_TO_ADDR
17526: GO 17985
17528: LD_EXP 53
17532: DOUBLE
17533: EQUAL
17534: IFTRUE 17538
17536: GO 17564
17538: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17539: LD_ADDR_VAR 0 3
17543: PUSH
17544: LD_INT 11
17546: PUSH
17547: LD_INT 12
17549: PUSH
17550: LD_INT 13
17552: PUSH
17553: LD_INT 14
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: LIST
17560: LIST
17561: ST_TO_ADDR
17562: GO 17985
17564: LD_INT 28
17566: DOUBLE
17567: EQUAL
17568: IFTRUE 17572
17570: GO 17590
17572: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17573: LD_ADDR_VAR 0 3
17577: PUSH
17578: LD_INT 13
17580: PUSH
17581: LD_INT 14
17583: PUSH
17584: EMPTY
17585: LIST
17586: LIST
17587: ST_TO_ADDR
17588: GO 17985
17590: LD_INT 29
17592: DOUBLE
17593: EQUAL
17594: IFTRUE 17598
17596: GO 17616
17598: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17599: LD_ADDR_VAR 0 3
17603: PUSH
17604: LD_INT 13
17606: PUSH
17607: LD_INT 14
17609: PUSH
17610: EMPTY
17611: LIST
17612: LIST
17613: ST_TO_ADDR
17614: GO 17985
17616: LD_INT 31
17618: DOUBLE
17619: EQUAL
17620: IFTRUE 17624
17622: GO 17642
17624: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17625: LD_ADDR_VAR 0 3
17629: PUSH
17630: LD_INT 13
17632: PUSH
17633: LD_INT 14
17635: PUSH
17636: EMPTY
17637: LIST
17638: LIST
17639: ST_TO_ADDR
17640: GO 17985
17642: LD_INT 26
17644: DOUBLE
17645: EQUAL
17646: IFTRUE 17650
17648: GO 17668
17650: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17651: LD_ADDR_VAR 0 3
17655: PUSH
17656: LD_INT 13
17658: PUSH
17659: LD_INT 14
17661: PUSH
17662: EMPTY
17663: LIST
17664: LIST
17665: ST_TO_ADDR
17666: GO 17985
17668: LD_INT 42
17670: DOUBLE
17671: EQUAL
17672: IFTRUE 17676
17674: GO 17702
17676: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17677: LD_ADDR_VAR 0 3
17681: PUSH
17682: LD_INT 21
17684: PUSH
17685: LD_INT 22
17687: PUSH
17688: LD_INT 23
17690: PUSH
17691: LD_INT 24
17693: PUSH
17694: EMPTY
17695: LIST
17696: LIST
17697: LIST
17698: LIST
17699: ST_TO_ADDR
17700: GO 17985
17702: LD_INT 43
17704: DOUBLE
17705: EQUAL
17706: IFTRUE 17710
17708: GO 17736
17710: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17711: LD_ADDR_VAR 0 3
17715: PUSH
17716: LD_INT 21
17718: PUSH
17719: LD_INT 22
17721: PUSH
17722: LD_INT 23
17724: PUSH
17725: LD_INT 24
17727: PUSH
17728: EMPTY
17729: LIST
17730: LIST
17731: LIST
17732: LIST
17733: ST_TO_ADDR
17734: GO 17985
17736: LD_INT 44
17738: DOUBLE
17739: EQUAL
17740: IFTRUE 17744
17742: GO 17770
17744: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17745: LD_ADDR_VAR 0 3
17749: PUSH
17750: LD_INT 21
17752: PUSH
17753: LD_INT 22
17755: PUSH
17756: LD_INT 23
17758: PUSH
17759: LD_INT 24
17761: PUSH
17762: EMPTY
17763: LIST
17764: LIST
17765: LIST
17766: LIST
17767: ST_TO_ADDR
17768: GO 17985
17770: LD_INT 45
17772: DOUBLE
17773: EQUAL
17774: IFTRUE 17778
17776: GO 17804
17778: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17779: LD_ADDR_VAR 0 3
17783: PUSH
17784: LD_INT 21
17786: PUSH
17787: LD_INT 22
17789: PUSH
17790: LD_INT 23
17792: PUSH
17793: LD_INT 24
17795: PUSH
17796: EMPTY
17797: LIST
17798: LIST
17799: LIST
17800: LIST
17801: ST_TO_ADDR
17802: GO 17985
17804: LD_INT 49
17806: DOUBLE
17807: EQUAL
17808: IFTRUE 17812
17810: GO 17838
17812: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17813: LD_ADDR_VAR 0 3
17817: PUSH
17818: LD_INT 21
17820: PUSH
17821: LD_INT 22
17823: PUSH
17824: LD_INT 23
17826: PUSH
17827: LD_INT 24
17829: PUSH
17830: EMPTY
17831: LIST
17832: LIST
17833: LIST
17834: LIST
17835: ST_TO_ADDR
17836: GO 17985
17838: LD_INT 51
17840: DOUBLE
17841: EQUAL
17842: IFTRUE 17846
17844: GO 17872
17846: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
17847: LD_ADDR_VAR 0 3
17851: PUSH
17852: LD_INT 21
17854: PUSH
17855: LD_INT 22
17857: PUSH
17858: LD_INT 23
17860: PUSH
17861: LD_INT 24
17863: PUSH
17864: EMPTY
17865: LIST
17866: LIST
17867: LIST
17868: LIST
17869: ST_TO_ADDR
17870: GO 17985
17872: LD_INT 52
17874: DOUBLE
17875: EQUAL
17876: IFTRUE 17880
17878: GO 17906
17880: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
17881: LD_ADDR_VAR 0 3
17885: PUSH
17886: LD_INT 21
17888: PUSH
17889: LD_INT 22
17891: PUSH
17892: LD_INT 23
17894: PUSH
17895: LD_INT 24
17897: PUSH
17898: EMPTY
17899: LIST
17900: LIST
17901: LIST
17902: LIST
17903: ST_TO_ADDR
17904: GO 17985
17906: LD_INT 53
17908: DOUBLE
17909: EQUAL
17910: IFTRUE 17914
17912: GO 17932
17914: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
17915: LD_ADDR_VAR 0 3
17919: PUSH
17920: LD_INT 23
17922: PUSH
17923: LD_INT 24
17925: PUSH
17926: EMPTY
17927: LIST
17928: LIST
17929: ST_TO_ADDR
17930: GO 17985
17932: LD_INT 46
17934: DOUBLE
17935: EQUAL
17936: IFTRUE 17940
17938: GO 17958
17940: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
17941: LD_ADDR_VAR 0 3
17945: PUSH
17946: LD_INT 23
17948: PUSH
17949: LD_INT 24
17951: PUSH
17952: EMPTY
17953: LIST
17954: LIST
17955: ST_TO_ADDR
17956: GO 17985
17958: LD_INT 47
17960: DOUBLE
17961: EQUAL
17962: IFTRUE 17966
17964: GO 17984
17966: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17967: LD_ADDR_VAR 0 3
17971: PUSH
17972: LD_INT 23
17974: PUSH
17975: LD_INT 24
17977: PUSH
17978: EMPTY
17979: LIST
17980: LIST
17981: ST_TO_ADDR
17982: GO 17985
17984: POP
// result := ( chassis in result ) ;
17985: LD_ADDR_VAR 0 3
17989: PUSH
17990: LD_VAR 0 1
17994: PUSH
17995: LD_VAR 0 3
17999: IN
18000: ST_TO_ADDR
// end ;
18001: LD_VAR 0 3
18005: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
18006: LD_INT 0
18008: PPUSH
18009: PPUSH
18010: PPUSH
18011: PPUSH
18012: PPUSH
18013: PPUSH
18014: PPUSH
// result := array ;
18015: LD_ADDR_VAR 0 5
18019: PUSH
18020: LD_VAR 0 1
18024: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18025: LD_VAR 0 1
18029: NOT
18030: PUSH
18031: LD_VAR 0 2
18035: NOT
18036: OR
18037: PUSH
18038: LD_VAR 0 3
18042: NOT
18043: OR
18044: PUSH
18045: LD_VAR 0 2
18049: PUSH
18050: LD_VAR 0 1
18054: GREATER
18055: OR
18056: PUSH
18057: LD_VAR 0 3
18061: PUSH
18062: LD_VAR 0 1
18066: GREATER
18067: OR
18068: IFFALSE 18072
// exit ;
18070: GO 18368
// if direction then
18072: LD_VAR 0 4
18076: IFFALSE 18140
// begin d := 1 ;
18078: LD_ADDR_VAR 0 9
18082: PUSH
18083: LD_INT 1
18085: ST_TO_ADDR
// if i_from > i_to then
18086: LD_VAR 0 2
18090: PUSH
18091: LD_VAR 0 3
18095: GREATER
18096: IFFALSE 18122
// length := ( array - i_from ) + i_to else
18098: LD_ADDR_VAR 0 11
18102: PUSH
18103: LD_VAR 0 1
18107: PUSH
18108: LD_VAR 0 2
18112: MINUS
18113: PUSH
18114: LD_VAR 0 3
18118: PLUS
18119: ST_TO_ADDR
18120: GO 18138
// length := i_to - i_from ;
18122: LD_ADDR_VAR 0 11
18126: PUSH
18127: LD_VAR 0 3
18131: PUSH
18132: LD_VAR 0 2
18136: MINUS
18137: ST_TO_ADDR
// end else
18138: GO 18201
// begin d := - 1 ;
18140: LD_ADDR_VAR 0 9
18144: PUSH
18145: LD_INT 1
18147: NEG
18148: ST_TO_ADDR
// if i_from > i_to then
18149: LD_VAR 0 2
18153: PUSH
18154: LD_VAR 0 3
18158: GREATER
18159: IFFALSE 18179
// length := i_from - i_to else
18161: LD_ADDR_VAR 0 11
18165: PUSH
18166: LD_VAR 0 2
18170: PUSH
18171: LD_VAR 0 3
18175: MINUS
18176: ST_TO_ADDR
18177: GO 18201
// length := ( array - i_to ) + i_from ;
18179: LD_ADDR_VAR 0 11
18183: PUSH
18184: LD_VAR 0 1
18188: PUSH
18189: LD_VAR 0 3
18193: MINUS
18194: PUSH
18195: LD_VAR 0 2
18199: PLUS
18200: ST_TO_ADDR
// end ; if not length then
18201: LD_VAR 0 11
18205: NOT
18206: IFFALSE 18210
// exit ;
18208: GO 18368
// tmp := array ;
18210: LD_ADDR_VAR 0 10
18214: PUSH
18215: LD_VAR 0 1
18219: ST_TO_ADDR
// for i = 1 to length do
18220: LD_ADDR_VAR 0 6
18224: PUSH
18225: DOUBLE
18226: LD_INT 1
18228: DEC
18229: ST_TO_ADDR
18230: LD_VAR 0 11
18234: PUSH
18235: FOR_TO
18236: IFFALSE 18356
// begin for j = 1 to array do
18238: LD_ADDR_VAR 0 7
18242: PUSH
18243: DOUBLE
18244: LD_INT 1
18246: DEC
18247: ST_TO_ADDR
18248: LD_VAR 0 1
18252: PUSH
18253: FOR_TO
18254: IFFALSE 18342
// begin k := j + d ;
18256: LD_ADDR_VAR 0 8
18260: PUSH
18261: LD_VAR 0 7
18265: PUSH
18266: LD_VAR 0 9
18270: PLUS
18271: ST_TO_ADDR
// if k > array then
18272: LD_VAR 0 8
18276: PUSH
18277: LD_VAR 0 1
18281: GREATER
18282: IFFALSE 18292
// k := 1 ;
18284: LD_ADDR_VAR 0 8
18288: PUSH
18289: LD_INT 1
18291: ST_TO_ADDR
// if not k then
18292: LD_VAR 0 8
18296: NOT
18297: IFFALSE 18309
// k := array ;
18299: LD_ADDR_VAR 0 8
18303: PUSH
18304: LD_VAR 0 1
18308: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18309: LD_ADDR_VAR 0 10
18313: PUSH
18314: LD_VAR 0 10
18318: PPUSH
18319: LD_VAR 0 8
18323: PPUSH
18324: LD_VAR 0 1
18328: PUSH
18329: LD_VAR 0 7
18333: ARRAY
18334: PPUSH
18335: CALL_OW 1
18339: ST_TO_ADDR
// end ;
18340: GO 18253
18342: POP
18343: POP
// array := tmp ;
18344: LD_ADDR_VAR 0 1
18348: PUSH
18349: LD_VAR 0 10
18353: ST_TO_ADDR
// end ;
18354: GO 18235
18356: POP
18357: POP
// result := array ;
18358: LD_ADDR_VAR 0 5
18362: PUSH
18363: LD_VAR 0 1
18367: ST_TO_ADDR
// end ;
18368: LD_VAR 0 5
18372: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
18373: LD_INT 0
18375: PPUSH
18376: PPUSH
// result := 0 ;
18377: LD_ADDR_VAR 0 3
18381: PUSH
18382: LD_INT 0
18384: ST_TO_ADDR
// if not array or not value in array then
18385: LD_VAR 0 1
18389: NOT
18390: PUSH
18391: LD_VAR 0 2
18395: PUSH
18396: LD_VAR 0 1
18400: IN
18401: NOT
18402: OR
18403: IFFALSE 18407
// exit ;
18405: GO 18461
// for i = 1 to array do
18407: LD_ADDR_VAR 0 4
18411: PUSH
18412: DOUBLE
18413: LD_INT 1
18415: DEC
18416: ST_TO_ADDR
18417: LD_VAR 0 1
18421: PUSH
18422: FOR_TO
18423: IFFALSE 18459
// if value = array [ i ] then
18425: LD_VAR 0 2
18429: PUSH
18430: LD_VAR 0 1
18434: PUSH
18435: LD_VAR 0 4
18439: ARRAY
18440: EQUAL
18441: IFFALSE 18457
// begin result := i ;
18443: LD_ADDR_VAR 0 3
18447: PUSH
18448: LD_VAR 0 4
18452: ST_TO_ADDR
// exit ;
18453: POP
18454: POP
18455: GO 18461
// end ;
18457: GO 18422
18459: POP
18460: POP
// end ;
18461: LD_VAR 0 3
18465: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18466: LD_INT 0
18468: PPUSH
// vc_chassis := chassis ;
18469: LD_ADDR_OWVAR 37
18473: PUSH
18474: LD_VAR 0 1
18478: ST_TO_ADDR
// vc_engine := engine ;
18479: LD_ADDR_OWVAR 39
18483: PUSH
18484: LD_VAR 0 2
18488: ST_TO_ADDR
// vc_control := control ;
18489: LD_ADDR_OWVAR 38
18493: PUSH
18494: LD_VAR 0 3
18498: ST_TO_ADDR
// vc_weapon := weapon ;
18499: LD_ADDR_OWVAR 40
18503: PUSH
18504: LD_VAR 0 4
18508: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18509: LD_ADDR_OWVAR 41
18513: PUSH
18514: LD_VAR 0 5
18518: ST_TO_ADDR
// end ;
18519: LD_VAR 0 6
18523: RET
// export function WantPlant ( unit ) ; var task ; begin
18524: LD_INT 0
18526: PPUSH
18527: PPUSH
// result := false ;
18528: LD_ADDR_VAR 0 2
18532: PUSH
18533: LD_INT 0
18535: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18536: LD_ADDR_VAR 0 3
18540: PUSH
18541: LD_VAR 0 1
18545: PPUSH
18546: CALL_OW 437
18550: ST_TO_ADDR
// if task then
18551: LD_VAR 0 3
18555: IFFALSE 18583
// if task [ 1 ] [ 1 ] = p then
18557: LD_VAR 0 3
18561: PUSH
18562: LD_INT 1
18564: ARRAY
18565: PUSH
18566: LD_INT 1
18568: ARRAY
18569: PUSH
18570: LD_STRING p
18572: EQUAL
18573: IFFALSE 18583
// result := true ;
18575: LD_ADDR_VAR 0 2
18579: PUSH
18580: LD_INT 1
18582: ST_TO_ADDR
// end ;
18583: LD_VAR 0 2
18587: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18588: LD_INT 0
18590: PPUSH
18591: PPUSH
18592: PPUSH
18593: PPUSH
// if pos < 1 then
18594: LD_VAR 0 2
18598: PUSH
18599: LD_INT 1
18601: LESS
18602: IFFALSE 18606
// exit ;
18604: GO 18909
// if pos = 1 then
18606: LD_VAR 0 2
18610: PUSH
18611: LD_INT 1
18613: EQUAL
18614: IFFALSE 18647
// result := Replace ( arr , pos [ 1 ] , value ) else
18616: LD_ADDR_VAR 0 4
18620: PUSH
18621: LD_VAR 0 1
18625: PPUSH
18626: LD_VAR 0 2
18630: PUSH
18631: LD_INT 1
18633: ARRAY
18634: PPUSH
18635: LD_VAR 0 3
18639: PPUSH
18640: CALL_OW 1
18644: ST_TO_ADDR
18645: GO 18909
// begin tmp := arr ;
18647: LD_ADDR_VAR 0 6
18651: PUSH
18652: LD_VAR 0 1
18656: ST_TO_ADDR
// s_arr := [ tmp ] ;
18657: LD_ADDR_VAR 0 7
18661: PUSH
18662: LD_VAR 0 6
18666: PUSH
18667: EMPTY
18668: LIST
18669: ST_TO_ADDR
// for i = 1 to pos - 1 do
18670: LD_ADDR_VAR 0 5
18674: PUSH
18675: DOUBLE
18676: LD_INT 1
18678: DEC
18679: ST_TO_ADDR
18680: LD_VAR 0 2
18684: PUSH
18685: LD_INT 1
18687: MINUS
18688: PUSH
18689: FOR_TO
18690: IFFALSE 18735
// begin tmp := tmp [ pos [ i ] ] ;
18692: LD_ADDR_VAR 0 6
18696: PUSH
18697: LD_VAR 0 6
18701: PUSH
18702: LD_VAR 0 2
18706: PUSH
18707: LD_VAR 0 5
18711: ARRAY
18712: ARRAY
18713: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18714: LD_ADDR_VAR 0 7
18718: PUSH
18719: LD_VAR 0 7
18723: PUSH
18724: LD_VAR 0 6
18728: PUSH
18729: EMPTY
18730: LIST
18731: ADD
18732: ST_TO_ADDR
// end ;
18733: GO 18689
18735: POP
18736: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18737: LD_ADDR_VAR 0 6
18741: PUSH
18742: LD_VAR 0 6
18746: PPUSH
18747: LD_VAR 0 2
18751: PUSH
18752: LD_VAR 0 2
18756: ARRAY
18757: PPUSH
18758: LD_VAR 0 3
18762: PPUSH
18763: CALL_OW 1
18767: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18768: LD_ADDR_VAR 0 7
18772: PUSH
18773: LD_VAR 0 7
18777: PPUSH
18778: LD_VAR 0 7
18782: PPUSH
18783: LD_VAR 0 6
18787: PPUSH
18788: CALL_OW 1
18792: ST_TO_ADDR
// for i = s_arr downto 2 do
18793: LD_ADDR_VAR 0 5
18797: PUSH
18798: DOUBLE
18799: LD_VAR 0 7
18803: INC
18804: ST_TO_ADDR
18805: LD_INT 2
18807: PUSH
18808: FOR_DOWNTO
18809: IFFALSE 18893
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18811: LD_ADDR_VAR 0 6
18815: PUSH
18816: LD_VAR 0 7
18820: PUSH
18821: LD_VAR 0 5
18825: PUSH
18826: LD_INT 1
18828: MINUS
18829: ARRAY
18830: PPUSH
18831: LD_VAR 0 2
18835: PUSH
18836: LD_VAR 0 5
18840: PUSH
18841: LD_INT 1
18843: MINUS
18844: ARRAY
18845: PPUSH
18846: LD_VAR 0 7
18850: PUSH
18851: LD_VAR 0 5
18855: ARRAY
18856: PPUSH
18857: CALL_OW 1
18861: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
18862: LD_ADDR_VAR 0 7
18866: PUSH
18867: LD_VAR 0 7
18871: PPUSH
18872: LD_VAR 0 5
18876: PUSH
18877: LD_INT 1
18879: MINUS
18880: PPUSH
18881: LD_VAR 0 6
18885: PPUSH
18886: CALL_OW 1
18890: ST_TO_ADDR
// end ;
18891: GO 18808
18893: POP
18894: POP
// result := s_arr [ 1 ] ;
18895: LD_ADDR_VAR 0 4
18899: PUSH
18900: LD_VAR 0 7
18904: PUSH
18905: LD_INT 1
18907: ARRAY
18908: ST_TO_ADDR
// end ; end ;
18909: LD_VAR 0 4
18913: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
18914: LD_INT 0
18916: PPUSH
18917: PPUSH
// if not list then
18918: LD_VAR 0 1
18922: NOT
18923: IFFALSE 18927
// exit ;
18925: GO 19018
// i := list [ pos1 ] ;
18927: LD_ADDR_VAR 0 5
18931: PUSH
18932: LD_VAR 0 1
18936: PUSH
18937: LD_VAR 0 2
18941: ARRAY
18942: ST_TO_ADDR
// if not i then
18943: LD_VAR 0 5
18947: NOT
18948: IFFALSE 18952
// exit ;
18950: GO 19018
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
18952: LD_ADDR_VAR 0 1
18956: PUSH
18957: LD_VAR 0 1
18961: PPUSH
18962: LD_VAR 0 2
18966: PPUSH
18967: LD_VAR 0 1
18971: PUSH
18972: LD_VAR 0 3
18976: ARRAY
18977: PPUSH
18978: CALL_OW 1
18982: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
18983: LD_ADDR_VAR 0 1
18987: PUSH
18988: LD_VAR 0 1
18992: PPUSH
18993: LD_VAR 0 3
18997: PPUSH
18998: LD_VAR 0 5
19002: PPUSH
19003: CALL_OW 1
19007: ST_TO_ADDR
// result := list ;
19008: LD_ADDR_VAR 0 4
19012: PUSH
19013: LD_VAR 0 1
19017: ST_TO_ADDR
// end ;
19018: LD_VAR 0 4
19022: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19023: LD_INT 0
19025: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19026: LD_ADDR_VAR 0 5
19030: PUSH
19031: LD_VAR 0 1
19035: PPUSH
19036: CALL_OW 250
19040: PPUSH
19041: LD_VAR 0 1
19045: PPUSH
19046: CALL_OW 251
19050: PPUSH
19051: LD_VAR 0 2
19055: PPUSH
19056: LD_VAR 0 3
19060: PPUSH
19061: LD_VAR 0 4
19065: PPUSH
19066: CALL 19076 0 5
19070: ST_TO_ADDR
// end ;
19071: LD_VAR 0 5
19075: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19076: LD_INT 0
19078: PPUSH
19079: PPUSH
19080: PPUSH
19081: PPUSH
// if not list then
19082: LD_VAR 0 3
19086: NOT
19087: IFFALSE 19091
// exit ;
19089: GO 19479
// result := [ ] ;
19091: LD_ADDR_VAR 0 6
19095: PUSH
19096: EMPTY
19097: ST_TO_ADDR
// for i in list do
19098: LD_ADDR_VAR 0 7
19102: PUSH
19103: LD_VAR 0 3
19107: PUSH
19108: FOR_IN
19109: IFFALSE 19311
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19111: LD_ADDR_VAR 0 9
19115: PUSH
19116: LD_VAR 0 7
19120: PPUSH
19121: LD_VAR 0 1
19125: PPUSH
19126: LD_VAR 0 2
19130: PPUSH
19131: CALL_OW 297
19135: ST_TO_ADDR
// if not result then
19136: LD_VAR 0 6
19140: NOT
19141: IFFALSE 19167
// result := [ [ i , tmp ] ] else
19143: LD_ADDR_VAR 0 6
19147: PUSH
19148: LD_VAR 0 7
19152: PUSH
19153: LD_VAR 0 9
19157: PUSH
19158: EMPTY
19159: LIST
19160: LIST
19161: PUSH
19162: EMPTY
19163: LIST
19164: ST_TO_ADDR
19165: GO 19309
// begin if result [ result ] [ 2 ] < tmp then
19167: LD_VAR 0 6
19171: PUSH
19172: LD_VAR 0 6
19176: ARRAY
19177: PUSH
19178: LD_INT 2
19180: ARRAY
19181: PUSH
19182: LD_VAR 0 9
19186: LESS
19187: IFFALSE 19229
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19189: LD_ADDR_VAR 0 6
19193: PUSH
19194: LD_VAR 0 6
19198: PPUSH
19199: LD_VAR 0 6
19203: PUSH
19204: LD_INT 1
19206: PLUS
19207: PPUSH
19208: LD_VAR 0 7
19212: PUSH
19213: LD_VAR 0 9
19217: PUSH
19218: EMPTY
19219: LIST
19220: LIST
19221: PPUSH
19222: CALL_OW 2
19226: ST_TO_ADDR
19227: GO 19309
// for j = 1 to result do
19229: LD_ADDR_VAR 0 8
19233: PUSH
19234: DOUBLE
19235: LD_INT 1
19237: DEC
19238: ST_TO_ADDR
19239: LD_VAR 0 6
19243: PUSH
19244: FOR_TO
19245: IFFALSE 19307
// begin if tmp < result [ j ] [ 2 ] then
19247: LD_VAR 0 9
19251: PUSH
19252: LD_VAR 0 6
19256: PUSH
19257: LD_VAR 0 8
19261: ARRAY
19262: PUSH
19263: LD_INT 2
19265: ARRAY
19266: LESS
19267: IFFALSE 19305
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19269: LD_ADDR_VAR 0 6
19273: PUSH
19274: LD_VAR 0 6
19278: PPUSH
19279: LD_VAR 0 8
19283: PPUSH
19284: LD_VAR 0 7
19288: PUSH
19289: LD_VAR 0 9
19293: PUSH
19294: EMPTY
19295: LIST
19296: LIST
19297: PPUSH
19298: CALL_OW 2
19302: ST_TO_ADDR
// break ;
19303: GO 19307
// end ; end ;
19305: GO 19244
19307: POP
19308: POP
// end ; end ;
19309: GO 19108
19311: POP
19312: POP
// if result and not asc then
19313: LD_VAR 0 6
19317: PUSH
19318: LD_VAR 0 4
19322: NOT
19323: AND
19324: IFFALSE 19399
// begin tmp := result ;
19326: LD_ADDR_VAR 0 9
19330: PUSH
19331: LD_VAR 0 6
19335: ST_TO_ADDR
// for i = tmp downto 1 do
19336: LD_ADDR_VAR 0 7
19340: PUSH
19341: DOUBLE
19342: LD_VAR 0 9
19346: INC
19347: ST_TO_ADDR
19348: LD_INT 1
19350: PUSH
19351: FOR_DOWNTO
19352: IFFALSE 19397
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
19354: LD_ADDR_VAR 0 6
19358: PUSH
19359: LD_VAR 0 6
19363: PPUSH
19364: LD_VAR 0 9
19368: PUSH
19369: LD_VAR 0 7
19373: MINUS
19374: PUSH
19375: LD_INT 1
19377: PLUS
19378: PPUSH
19379: LD_VAR 0 9
19383: PUSH
19384: LD_VAR 0 7
19388: ARRAY
19389: PPUSH
19390: CALL_OW 1
19394: ST_TO_ADDR
19395: GO 19351
19397: POP
19398: POP
// end ; tmp := [ ] ;
19399: LD_ADDR_VAR 0 9
19403: PUSH
19404: EMPTY
19405: ST_TO_ADDR
// if mode then
19406: LD_VAR 0 5
19410: IFFALSE 19479
// begin for i = 1 to result do
19412: LD_ADDR_VAR 0 7
19416: PUSH
19417: DOUBLE
19418: LD_INT 1
19420: DEC
19421: ST_TO_ADDR
19422: LD_VAR 0 6
19426: PUSH
19427: FOR_TO
19428: IFFALSE 19467
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19430: LD_ADDR_VAR 0 9
19434: PUSH
19435: LD_VAR 0 9
19439: PPUSH
19440: LD_VAR 0 7
19444: PPUSH
19445: LD_VAR 0 6
19449: PUSH
19450: LD_VAR 0 7
19454: ARRAY
19455: PUSH
19456: LD_INT 1
19458: ARRAY
19459: PPUSH
19460: CALL_OW 1
19464: ST_TO_ADDR
19465: GO 19427
19467: POP
19468: POP
// result := tmp ;
19469: LD_ADDR_VAR 0 6
19473: PUSH
19474: LD_VAR 0 9
19478: ST_TO_ADDR
// end ; end ;
19479: LD_VAR 0 6
19483: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19484: LD_INT 0
19486: PPUSH
19487: PPUSH
19488: PPUSH
19489: PPUSH
19490: PPUSH
19491: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19492: LD_ADDR_VAR 0 5
19496: PUSH
19497: LD_INT 0
19499: PUSH
19500: LD_INT 0
19502: PUSH
19503: LD_INT 0
19505: PUSH
19506: EMPTY
19507: PUSH
19508: EMPTY
19509: LIST
19510: LIST
19511: LIST
19512: LIST
19513: ST_TO_ADDR
// if not x or not y then
19514: LD_VAR 0 2
19518: NOT
19519: PUSH
19520: LD_VAR 0 3
19524: NOT
19525: OR
19526: IFFALSE 19530
// exit ;
19528: GO 21182
// if not range then
19530: LD_VAR 0 4
19534: NOT
19535: IFFALSE 19545
// range := 10 ;
19537: LD_ADDR_VAR 0 4
19541: PUSH
19542: LD_INT 10
19544: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19545: LD_ADDR_VAR 0 8
19549: PUSH
19550: LD_INT 81
19552: PUSH
19553: LD_VAR 0 1
19557: PUSH
19558: EMPTY
19559: LIST
19560: LIST
19561: PUSH
19562: LD_INT 92
19564: PUSH
19565: LD_VAR 0 2
19569: PUSH
19570: LD_VAR 0 3
19574: PUSH
19575: LD_VAR 0 4
19579: PUSH
19580: EMPTY
19581: LIST
19582: LIST
19583: LIST
19584: LIST
19585: PUSH
19586: LD_INT 3
19588: PUSH
19589: LD_INT 21
19591: PUSH
19592: LD_INT 3
19594: PUSH
19595: EMPTY
19596: LIST
19597: LIST
19598: PUSH
19599: EMPTY
19600: LIST
19601: LIST
19602: PUSH
19603: EMPTY
19604: LIST
19605: LIST
19606: LIST
19607: PPUSH
19608: CALL_OW 69
19612: ST_TO_ADDR
// if not tmp then
19613: LD_VAR 0 8
19617: NOT
19618: IFFALSE 19622
// exit ;
19620: GO 21182
// for i in tmp do
19622: LD_ADDR_VAR 0 6
19626: PUSH
19627: LD_VAR 0 8
19631: PUSH
19632: FOR_IN
19633: IFFALSE 21157
// begin points := [ 0 , 0 , 0 ] ;
19635: LD_ADDR_VAR 0 9
19639: PUSH
19640: LD_INT 0
19642: PUSH
19643: LD_INT 0
19645: PUSH
19646: LD_INT 0
19648: PUSH
19649: EMPTY
19650: LIST
19651: LIST
19652: LIST
19653: ST_TO_ADDR
// bpoints := 1 ;
19654: LD_ADDR_VAR 0 10
19658: PUSH
19659: LD_INT 1
19661: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19662: LD_VAR 0 6
19666: PPUSH
19667: CALL_OW 247
19671: PUSH
19672: LD_INT 1
19674: DOUBLE
19675: EQUAL
19676: IFTRUE 19680
19678: GO 20258
19680: POP
// begin if GetClass ( i ) = 1 then
19681: LD_VAR 0 6
19685: PPUSH
19686: CALL_OW 257
19690: PUSH
19691: LD_INT 1
19693: EQUAL
19694: IFFALSE 19715
// points := [ 10 , 5 , 3 ] ;
19696: LD_ADDR_VAR 0 9
19700: PUSH
19701: LD_INT 10
19703: PUSH
19704: LD_INT 5
19706: PUSH
19707: LD_INT 3
19709: PUSH
19710: EMPTY
19711: LIST
19712: LIST
19713: LIST
19714: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19715: LD_VAR 0 6
19719: PPUSH
19720: CALL_OW 257
19724: PUSH
19725: LD_INT 2
19727: PUSH
19728: LD_INT 3
19730: PUSH
19731: LD_INT 4
19733: PUSH
19734: EMPTY
19735: LIST
19736: LIST
19737: LIST
19738: IN
19739: IFFALSE 19760
// points := [ 3 , 2 , 1 ] ;
19741: LD_ADDR_VAR 0 9
19745: PUSH
19746: LD_INT 3
19748: PUSH
19749: LD_INT 2
19751: PUSH
19752: LD_INT 1
19754: PUSH
19755: EMPTY
19756: LIST
19757: LIST
19758: LIST
19759: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19760: LD_VAR 0 6
19764: PPUSH
19765: CALL_OW 257
19769: PUSH
19770: LD_INT 5
19772: EQUAL
19773: IFFALSE 19794
// points := [ 130 , 5 , 2 ] ;
19775: LD_ADDR_VAR 0 9
19779: PUSH
19780: LD_INT 130
19782: PUSH
19783: LD_INT 5
19785: PUSH
19786: LD_INT 2
19788: PUSH
19789: EMPTY
19790: LIST
19791: LIST
19792: LIST
19793: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19794: LD_VAR 0 6
19798: PPUSH
19799: CALL_OW 257
19803: PUSH
19804: LD_INT 8
19806: EQUAL
19807: IFFALSE 19828
// points := [ 35 , 35 , 30 ] ;
19809: LD_ADDR_VAR 0 9
19813: PUSH
19814: LD_INT 35
19816: PUSH
19817: LD_INT 35
19819: PUSH
19820: LD_INT 30
19822: PUSH
19823: EMPTY
19824: LIST
19825: LIST
19826: LIST
19827: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19828: LD_VAR 0 6
19832: PPUSH
19833: CALL_OW 257
19837: PUSH
19838: LD_INT 9
19840: EQUAL
19841: IFFALSE 19862
// points := [ 20 , 55 , 40 ] ;
19843: LD_ADDR_VAR 0 9
19847: PUSH
19848: LD_INT 20
19850: PUSH
19851: LD_INT 55
19853: PUSH
19854: LD_INT 40
19856: PUSH
19857: EMPTY
19858: LIST
19859: LIST
19860: LIST
19861: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
19862: LD_VAR 0 6
19866: PPUSH
19867: CALL_OW 257
19871: PUSH
19872: LD_INT 12
19874: PUSH
19875: LD_INT 16
19877: PUSH
19878: EMPTY
19879: LIST
19880: LIST
19881: IN
19882: IFFALSE 19903
// points := [ 5 , 3 , 2 ] ;
19884: LD_ADDR_VAR 0 9
19888: PUSH
19889: LD_INT 5
19891: PUSH
19892: LD_INT 3
19894: PUSH
19895: LD_INT 2
19897: PUSH
19898: EMPTY
19899: LIST
19900: LIST
19901: LIST
19902: ST_TO_ADDR
// if GetClass ( i ) = 17 then
19903: LD_VAR 0 6
19907: PPUSH
19908: CALL_OW 257
19912: PUSH
19913: LD_INT 17
19915: EQUAL
19916: IFFALSE 19937
// points := [ 100 , 50 , 75 ] ;
19918: LD_ADDR_VAR 0 9
19922: PUSH
19923: LD_INT 100
19925: PUSH
19926: LD_INT 50
19928: PUSH
19929: LD_INT 75
19931: PUSH
19932: EMPTY
19933: LIST
19934: LIST
19935: LIST
19936: ST_TO_ADDR
// if GetClass ( i ) = 15 then
19937: LD_VAR 0 6
19941: PPUSH
19942: CALL_OW 257
19946: PUSH
19947: LD_INT 15
19949: EQUAL
19950: IFFALSE 19971
// points := [ 10 , 5 , 3 ] ;
19952: LD_ADDR_VAR 0 9
19956: PUSH
19957: LD_INT 10
19959: PUSH
19960: LD_INT 5
19962: PUSH
19963: LD_INT 3
19965: PUSH
19966: EMPTY
19967: LIST
19968: LIST
19969: LIST
19970: ST_TO_ADDR
// if GetClass ( i ) = 14 then
19971: LD_VAR 0 6
19975: PPUSH
19976: CALL_OW 257
19980: PUSH
19981: LD_INT 14
19983: EQUAL
19984: IFFALSE 20005
// points := [ 10 , 0 , 0 ] ;
19986: LD_ADDR_VAR 0 9
19990: PUSH
19991: LD_INT 10
19993: PUSH
19994: LD_INT 0
19996: PUSH
19997: LD_INT 0
19999: PUSH
20000: EMPTY
20001: LIST
20002: LIST
20003: LIST
20004: ST_TO_ADDR
// if GetClass ( i ) = 11 then
20005: LD_VAR 0 6
20009: PPUSH
20010: CALL_OW 257
20014: PUSH
20015: LD_INT 11
20017: EQUAL
20018: IFFALSE 20039
// points := [ 30 , 10 , 5 ] ;
20020: LD_ADDR_VAR 0 9
20024: PUSH
20025: LD_INT 30
20027: PUSH
20028: LD_INT 10
20030: PUSH
20031: LD_INT 5
20033: PUSH
20034: EMPTY
20035: LIST
20036: LIST
20037: LIST
20038: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20039: LD_VAR 0 1
20043: PPUSH
20044: LD_INT 5
20046: PPUSH
20047: CALL_OW 321
20051: PUSH
20052: LD_INT 2
20054: EQUAL
20055: IFFALSE 20072
// bpoints := bpoints * 1.8 ;
20057: LD_ADDR_VAR 0 10
20061: PUSH
20062: LD_VAR 0 10
20066: PUSH
20067: LD_REAL  1.80000000000000E+0000
20070: MUL
20071: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20072: LD_VAR 0 6
20076: PPUSH
20077: CALL_OW 257
20081: PUSH
20082: LD_INT 1
20084: PUSH
20085: LD_INT 2
20087: PUSH
20088: LD_INT 3
20090: PUSH
20091: LD_INT 4
20093: PUSH
20094: EMPTY
20095: LIST
20096: LIST
20097: LIST
20098: LIST
20099: IN
20100: PUSH
20101: LD_VAR 0 1
20105: PPUSH
20106: LD_INT 51
20108: PPUSH
20109: CALL_OW 321
20113: PUSH
20114: LD_INT 2
20116: EQUAL
20117: AND
20118: IFFALSE 20135
// bpoints := bpoints * 1.2 ;
20120: LD_ADDR_VAR 0 10
20124: PUSH
20125: LD_VAR 0 10
20129: PUSH
20130: LD_REAL  1.20000000000000E+0000
20133: MUL
20134: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20135: LD_VAR 0 6
20139: PPUSH
20140: CALL_OW 257
20144: PUSH
20145: LD_INT 5
20147: PUSH
20148: LD_INT 7
20150: PUSH
20151: LD_INT 9
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: LIST
20158: IN
20159: PUSH
20160: LD_VAR 0 1
20164: PPUSH
20165: LD_INT 52
20167: PPUSH
20168: CALL_OW 321
20172: PUSH
20173: LD_INT 2
20175: EQUAL
20176: AND
20177: IFFALSE 20194
// bpoints := bpoints * 1.5 ;
20179: LD_ADDR_VAR 0 10
20183: PUSH
20184: LD_VAR 0 10
20188: PUSH
20189: LD_REAL  1.50000000000000E+0000
20192: MUL
20193: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20194: LD_VAR 0 1
20198: PPUSH
20199: LD_INT 66
20201: PPUSH
20202: CALL_OW 321
20206: PUSH
20207: LD_INT 2
20209: EQUAL
20210: IFFALSE 20227
// bpoints := bpoints * 1.1 ;
20212: LD_ADDR_VAR 0 10
20216: PUSH
20217: LD_VAR 0 10
20221: PUSH
20222: LD_REAL  1.10000000000000E+0000
20225: MUL
20226: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20227: LD_ADDR_VAR 0 10
20231: PUSH
20232: LD_VAR 0 10
20236: PUSH
20237: LD_VAR 0 6
20241: PPUSH
20242: LD_INT 1
20244: PPUSH
20245: CALL_OW 259
20249: PUSH
20250: LD_REAL  1.15000000000000E+0000
20253: MUL
20254: MUL
20255: ST_TO_ADDR
// end ; unit_vehicle :
20256: GO 21086
20258: LD_INT 2
20260: DOUBLE
20261: EQUAL
20262: IFTRUE 20266
20264: GO 21074
20266: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20267: LD_VAR 0 6
20271: PPUSH
20272: CALL_OW 264
20276: PUSH
20277: LD_INT 2
20279: PUSH
20280: LD_INT 42
20282: PUSH
20283: LD_INT 24
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: LIST
20290: IN
20291: IFFALSE 20312
// points := [ 25 , 5 , 3 ] ;
20293: LD_ADDR_VAR 0 9
20297: PUSH
20298: LD_INT 25
20300: PUSH
20301: LD_INT 5
20303: PUSH
20304: LD_INT 3
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: LIST
20311: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20312: LD_VAR 0 6
20316: PPUSH
20317: CALL_OW 264
20321: PUSH
20322: LD_INT 4
20324: PUSH
20325: LD_INT 43
20327: PUSH
20328: LD_INT 25
20330: PUSH
20331: EMPTY
20332: LIST
20333: LIST
20334: LIST
20335: IN
20336: IFFALSE 20357
// points := [ 40 , 15 , 5 ] ;
20338: LD_ADDR_VAR 0 9
20342: PUSH
20343: LD_INT 40
20345: PUSH
20346: LD_INT 15
20348: PUSH
20349: LD_INT 5
20351: PUSH
20352: EMPTY
20353: LIST
20354: LIST
20355: LIST
20356: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
20357: LD_VAR 0 6
20361: PPUSH
20362: CALL_OW 264
20366: PUSH
20367: LD_INT 3
20369: PUSH
20370: LD_INT 23
20372: PUSH
20373: EMPTY
20374: LIST
20375: LIST
20376: IN
20377: IFFALSE 20398
// points := [ 7 , 25 , 8 ] ;
20379: LD_ADDR_VAR 0 9
20383: PUSH
20384: LD_INT 7
20386: PUSH
20387: LD_INT 25
20389: PUSH
20390: LD_INT 8
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: LIST
20397: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
20398: LD_VAR 0 6
20402: PPUSH
20403: CALL_OW 264
20407: PUSH
20408: LD_INT 5
20410: PUSH
20411: LD_INT 27
20413: PUSH
20414: LD_INT 44
20416: PUSH
20417: EMPTY
20418: LIST
20419: LIST
20420: LIST
20421: IN
20422: IFFALSE 20443
// points := [ 14 , 50 , 16 ] ;
20424: LD_ADDR_VAR 0 9
20428: PUSH
20429: LD_INT 14
20431: PUSH
20432: LD_INT 50
20434: PUSH
20435: LD_INT 16
20437: PUSH
20438: EMPTY
20439: LIST
20440: LIST
20441: LIST
20442: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20443: LD_VAR 0 6
20447: PPUSH
20448: CALL_OW 264
20452: PUSH
20453: LD_INT 6
20455: PUSH
20456: LD_INT 46
20458: PUSH
20459: EMPTY
20460: LIST
20461: LIST
20462: IN
20463: IFFALSE 20484
// points := [ 32 , 120 , 70 ] ;
20465: LD_ADDR_VAR 0 9
20469: PUSH
20470: LD_INT 32
20472: PUSH
20473: LD_INT 120
20475: PUSH
20476: LD_INT 70
20478: PUSH
20479: EMPTY
20480: LIST
20481: LIST
20482: LIST
20483: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
20484: LD_VAR 0 6
20488: PPUSH
20489: CALL_OW 264
20493: PUSH
20494: LD_INT 7
20496: PUSH
20497: LD_INT 28
20499: PUSH
20500: LD_INT 45
20502: PUSH
20503: LD_EXP 53
20507: PUSH
20508: EMPTY
20509: LIST
20510: LIST
20511: LIST
20512: LIST
20513: IN
20514: IFFALSE 20535
// points := [ 35 , 20 , 45 ] ;
20516: LD_ADDR_VAR 0 9
20520: PUSH
20521: LD_INT 35
20523: PUSH
20524: LD_INT 20
20526: PUSH
20527: LD_INT 45
20529: PUSH
20530: EMPTY
20531: LIST
20532: LIST
20533: LIST
20534: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20535: LD_VAR 0 6
20539: PPUSH
20540: CALL_OW 264
20544: PUSH
20545: LD_INT 47
20547: PUSH
20548: EMPTY
20549: LIST
20550: IN
20551: IFFALSE 20572
// points := [ 67 , 45 , 75 ] ;
20553: LD_ADDR_VAR 0 9
20557: PUSH
20558: LD_INT 67
20560: PUSH
20561: LD_INT 45
20563: PUSH
20564: LD_INT 75
20566: PUSH
20567: EMPTY
20568: LIST
20569: LIST
20570: LIST
20571: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20572: LD_VAR 0 6
20576: PPUSH
20577: CALL_OW 264
20581: PUSH
20582: LD_INT 26
20584: PUSH
20585: EMPTY
20586: LIST
20587: IN
20588: IFFALSE 20609
// points := [ 120 , 30 , 80 ] ;
20590: LD_ADDR_VAR 0 9
20594: PUSH
20595: LD_INT 120
20597: PUSH
20598: LD_INT 30
20600: PUSH
20601: LD_INT 80
20603: PUSH
20604: EMPTY
20605: LIST
20606: LIST
20607: LIST
20608: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20609: LD_VAR 0 6
20613: PPUSH
20614: CALL_OW 264
20618: PUSH
20619: LD_INT 22
20621: PUSH
20622: EMPTY
20623: LIST
20624: IN
20625: IFFALSE 20646
// points := [ 40 , 1 , 1 ] ;
20627: LD_ADDR_VAR 0 9
20631: PUSH
20632: LD_INT 40
20634: PUSH
20635: LD_INT 1
20637: PUSH
20638: LD_INT 1
20640: PUSH
20641: EMPTY
20642: LIST
20643: LIST
20644: LIST
20645: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20646: LD_VAR 0 6
20650: PPUSH
20651: CALL_OW 264
20655: PUSH
20656: LD_INT 29
20658: PUSH
20659: EMPTY
20660: LIST
20661: IN
20662: IFFALSE 20683
// points := [ 70 , 200 , 400 ] ;
20664: LD_ADDR_VAR 0 9
20668: PUSH
20669: LD_INT 70
20671: PUSH
20672: LD_INT 200
20674: PUSH
20675: LD_INT 400
20677: PUSH
20678: EMPTY
20679: LIST
20680: LIST
20681: LIST
20682: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20683: LD_VAR 0 6
20687: PPUSH
20688: CALL_OW 264
20692: PUSH
20693: LD_INT 14
20695: PUSH
20696: LD_INT 53
20698: PUSH
20699: EMPTY
20700: LIST
20701: LIST
20702: IN
20703: IFFALSE 20724
// points := [ 40 , 10 , 20 ] ;
20705: LD_ADDR_VAR 0 9
20709: PUSH
20710: LD_INT 40
20712: PUSH
20713: LD_INT 10
20715: PUSH
20716: LD_INT 20
20718: PUSH
20719: EMPTY
20720: LIST
20721: LIST
20722: LIST
20723: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20724: LD_VAR 0 6
20728: PPUSH
20729: CALL_OW 264
20733: PUSH
20734: LD_INT 9
20736: PUSH
20737: EMPTY
20738: LIST
20739: IN
20740: IFFALSE 20761
// points := [ 5 , 70 , 20 ] ;
20742: LD_ADDR_VAR 0 9
20746: PUSH
20747: LD_INT 5
20749: PUSH
20750: LD_INT 70
20752: PUSH
20753: LD_INT 20
20755: PUSH
20756: EMPTY
20757: LIST
20758: LIST
20759: LIST
20760: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20761: LD_VAR 0 6
20765: PPUSH
20766: CALL_OW 264
20770: PUSH
20771: LD_INT 10
20773: PUSH
20774: EMPTY
20775: LIST
20776: IN
20777: IFFALSE 20798
// points := [ 35 , 110 , 70 ] ;
20779: LD_ADDR_VAR 0 9
20783: PUSH
20784: LD_INT 35
20786: PUSH
20787: LD_INT 110
20789: PUSH
20790: LD_INT 70
20792: PUSH
20793: EMPTY
20794: LIST
20795: LIST
20796: LIST
20797: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20798: LD_VAR 0 6
20802: PPUSH
20803: CALL_OW 265
20807: PUSH
20808: LD_INT 25
20810: EQUAL
20811: IFFALSE 20832
// points := [ 80 , 65 , 100 ] ;
20813: LD_ADDR_VAR 0 9
20817: PUSH
20818: LD_INT 80
20820: PUSH
20821: LD_INT 65
20823: PUSH
20824: LD_INT 100
20826: PUSH
20827: EMPTY
20828: LIST
20829: LIST
20830: LIST
20831: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20832: LD_VAR 0 6
20836: PPUSH
20837: CALL_OW 263
20841: PUSH
20842: LD_INT 1
20844: EQUAL
20845: IFFALSE 20880
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
20847: LD_ADDR_VAR 0 10
20851: PUSH
20852: LD_VAR 0 10
20856: PUSH
20857: LD_VAR 0 6
20861: PPUSH
20862: CALL_OW 311
20866: PPUSH
20867: LD_INT 3
20869: PPUSH
20870: CALL_OW 259
20874: PUSH
20875: LD_INT 4
20877: MUL
20878: MUL
20879: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
20880: LD_VAR 0 6
20884: PPUSH
20885: CALL_OW 263
20889: PUSH
20890: LD_INT 2
20892: EQUAL
20893: IFFALSE 20944
// begin j := IsControledBy ( i ) ;
20895: LD_ADDR_VAR 0 7
20899: PUSH
20900: LD_VAR 0 6
20904: PPUSH
20905: CALL_OW 312
20909: ST_TO_ADDR
// if j then
20910: LD_VAR 0 7
20914: IFFALSE 20944
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
20916: LD_ADDR_VAR 0 10
20920: PUSH
20921: LD_VAR 0 10
20925: PUSH
20926: LD_VAR 0 7
20930: PPUSH
20931: LD_INT 3
20933: PPUSH
20934: CALL_OW 259
20938: PUSH
20939: LD_INT 3
20941: MUL
20942: MUL
20943: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
20944: LD_VAR 0 6
20948: PPUSH
20949: CALL_OW 264
20953: PUSH
20954: LD_INT 5
20956: PUSH
20957: LD_INT 6
20959: PUSH
20960: LD_INT 46
20962: PUSH
20963: LD_INT 44
20965: PUSH
20966: LD_INT 47
20968: PUSH
20969: LD_INT 45
20971: PUSH
20972: LD_INT 28
20974: PUSH
20975: LD_INT 7
20977: PUSH
20978: LD_INT 27
20980: PUSH
20981: LD_INT 29
20983: PUSH
20984: EMPTY
20985: LIST
20986: LIST
20987: LIST
20988: LIST
20989: LIST
20990: LIST
20991: LIST
20992: LIST
20993: LIST
20994: LIST
20995: IN
20996: PUSH
20997: LD_VAR 0 1
21001: PPUSH
21002: LD_INT 52
21004: PPUSH
21005: CALL_OW 321
21009: PUSH
21010: LD_INT 2
21012: EQUAL
21013: AND
21014: IFFALSE 21031
// bpoints := bpoints * 1.2 ;
21016: LD_ADDR_VAR 0 10
21020: PUSH
21021: LD_VAR 0 10
21025: PUSH
21026: LD_REAL  1.20000000000000E+0000
21029: MUL
21030: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21031: LD_VAR 0 6
21035: PPUSH
21036: CALL_OW 264
21040: PUSH
21041: LD_INT 6
21043: PUSH
21044: LD_INT 46
21046: PUSH
21047: LD_INT 47
21049: PUSH
21050: EMPTY
21051: LIST
21052: LIST
21053: LIST
21054: IN
21055: IFFALSE 21072
// bpoints := bpoints * 1.2 ;
21057: LD_ADDR_VAR 0 10
21061: PUSH
21062: LD_VAR 0 10
21066: PUSH
21067: LD_REAL  1.20000000000000E+0000
21070: MUL
21071: ST_TO_ADDR
// end ; unit_building :
21072: GO 21086
21074: LD_INT 3
21076: DOUBLE
21077: EQUAL
21078: IFTRUE 21082
21080: GO 21085
21082: POP
// ; end ;
21083: GO 21086
21085: POP
// for j = 1 to 3 do
21086: LD_ADDR_VAR 0 7
21090: PUSH
21091: DOUBLE
21092: LD_INT 1
21094: DEC
21095: ST_TO_ADDR
21096: LD_INT 3
21098: PUSH
21099: FOR_TO
21100: IFFALSE 21153
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21102: LD_ADDR_VAR 0 5
21106: PUSH
21107: LD_VAR 0 5
21111: PPUSH
21112: LD_VAR 0 7
21116: PPUSH
21117: LD_VAR 0 5
21121: PUSH
21122: LD_VAR 0 7
21126: ARRAY
21127: PUSH
21128: LD_VAR 0 9
21132: PUSH
21133: LD_VAR 0 7
21137: ARRAY
21138: PUSH
21139: LD_VAR 0 10
21143: MUL
21144: PLUS
21145: PPUSH
21146: CALL_OW 1
21150: ST_TO_ADDR
21151: GO 21099
21153: POP
21154: POP
// end ;
21155: GO 19632
21157: POP
21158: POP
// result := Replace ( result , 4 , tmp ) ;
21159: LD_ADDR_VAR 0 5
21163: PUSH
21164: LD_VAR 0 5
21168: PPUSH
21169: LD_INT 4
21171: PPUSH
21172: LD_VAR 0 8
21176: PPUSH
21177: CALL_OW 1
21181: ST_TO_ADDR
// end ;
21182: LD_VAR 0 5
21186: RET
// export function DangerAtRange ( unit , range ) ; begin
21187: LD_INT 0
21189: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21190: LD_ADDR_VAR 0 3
21194: PUSH
21195: LD_VAR 0 1
21199: PPUSH
21200: CALL_OW 255
21204: PPUSH
21205: LD_VAR 0 1
21209: PPUSH
21210: CALL_OW 250
21214: PPUSH
21215: LD_VAR 0 1
21219: PPUSH
21220: CALL_OW 251
21224: PPUSH
21225: LD_VAR 0 2
21229: PPUSH
21230: CALL 19484 0 4
21234: ST_TO_ADDR
// end ;
21235: LD_VAR 0 3
21239: RET
// export function DangerInArea ( side , area ) ; begin
21240: LD_INT 0
21242: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21243: LD_ADDR_VAR 0 3
21247: PUSH
21248: LD_VAR 0 2
21252: PPUSH
21253: LD_INT 81
21255: PUSH
21256: LD_VAR 0 1
21260: PUSH
21261: EMPTY
21262: LIST
21263: LIST
21264: PPUSH
21265: CALL_OW 70
21269: ST_TO_ADDR
// end ;
21270: LD_VAR 0 3
21274: RET
// export function IsExtension ( b ) ; begin
21275: LD_INT 0
21277: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21278: LD_ADDR_VAR 0 2
21282: PUSH
21283: LD_VAR 0 1
21287: PUSH
21288: LD_INT 23
21290: PUSH
21291: LD_INT 20
21293: PUSH
21294: LD_INT 22
21296: PUSH
21297: LD_INT 17
21299: PUSH
21300: LD_INT 24
21302: PUSH
21303: LD_INT 21
21305: PUSH
21306: LD_INT 19
21308: PUSH
21309: LD_INT 16
21311: PUSH
21312: LD_INT 25
21314: PUSH
21315: LD_INT 18
21317: PUSH
21318: EMPTY
21319: LIST
21320: LIST
21321: LIST
21322: LIST
21323: LIST
21324: LIST
21325: LIST
21326: LIST
21327: LIST
21328: LIST
21329: IN
21330: ST_TO_ADDR
// end ;
21331: LD_VAR 0 2
21335: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
21336: LD_INT 0
21338: PPUSH
21339: PPUSH
21340: PPUSH
// result := [ ] ;
21341: LD_ADDR_VAR 0 4
21345: PUSH
21346: EMPTY
21347: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21348: LD_ADDR_VAR 0 5
21352: PUSH
21353: LD_VAR 0 2
21357: PPUSH
21358: LD_INT 21
21360: PUSH
21361: LD_INT 3
21363: PUSH
21364: EMPTY
21365: LIST
21366: LIST
21367: PPUSH
21368: CALL_OW 70
21372: ST_TO_ADDR
// if not tmp then
21373: LD_VAR 0 5
21377: NOT
21378: IFFALSE 21382
// exit ;
21380: GO 21446
// if checkLink then
21382: LD_VAR 0 3
21386: IFFALSE 21436
// begin for i in tmp do
21388: LD_ADDR_VAR 0 6
21392: PUSH
21393: LD_VAR 0 5
21397: PUSH
21398: FOR_IN
21399: IFFALSE 21434
// if GetBase ( i ) <> base then
21401: LD_VAR 0 6
21405: PPUSH
21406: CALL_OW 274
21410: PUSH
21411: LD_VAR 0 1
21415: NONEQUAL
21416: IFFALSE 21432
// ComLinkToBase ( base , i ) ;
21418: LD_VAR 0 1
21422: PPUSH
21423: LD_VAR 0 6
21427: PPUSH
21428: CALL_OW 169
21432: GO 21398
21434: POP
21435: POP
// end ; result := tmp ;
21436: LD_ADDR_VAR 0 4
21440: PUSH
21441: LD_VAR 0 5
21445: ST_TO_ADDR
// end ;
21446: LD_VAR 0 4
21450: RET
// export function ComComplete ( units , b ) ; var i ; begin
21451: LD_INT 0
21453: PPUSH
21454: PPUSH
// if not units then
21455: LD_VAR 0 1
21459: NOT
21460: IFFALSE 21464
// exit ;
21462: GO 21554
// for i in units do
21464: LD_ADDR_VAR 0 4
21468: PUSH
21469: LD_VAR 0 1
21473: PUSH
21474: FOR_IN
21475: IFFALSE 21552
// if BuildingStatus ( b ) = bs_build then
21477: LD_VAR 0 2
21481: PPUSH
21482: CALL_OW 461
21486: PUSH
21487: LD_INT 1
21489: EQUAL
21490: IFFALSE 21550
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21492: LD_VAR 0 4
21496: PPUSH
21497: LD_STRING h
21499: PUSH
21500: LD_VAR 0 2
21504: PPUSH
21505: CALL_OW 250
21509: PUSH
21510: LD_VAR 0 2
21514: PPUSH
21515: CALL_OW 251
21519: PUSH
21520: LD_VAR 0 2
21524: PUSH
21525: LD_INT 0
21527: PUSH
21528: LD_INT 0
21530: PUSH
21531: LD_INT 0
21533: PUSH
21534: EMPTY
21535: LIST
21536: LIST
21537: LIST
21538: LIST
21539: LIST
21540: LIST
21541: LIST
21542: PUSH
21543: EMPTY
21544: LIST
21545: PPUSH
21546: CALL_OW 446
21550: GO 21474
21552: POP
21553: POP
// end ;
21554: LD_VAR 0 3
21558: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21559: LD_INT 0
21561: PPUSH
21562: PPUSH
21563: PPUSH
21564: PPUSH
21565: PPUSH
21566: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
21567: LD_VAR 0 1
21571: NOT
21572: PUSH
21573: LD_VAR 0 1
21577: PPUSH
21578: CALL_OW 263
21582: PUSH
21583: LD_INT 2
21585: NONEQUAL
21586: OR
21587: IFFALSE 21591
// exit ;
21589: GO 21907
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21591: LD_ADDR_VAR 0 6
21595: PUSH
21596: LD_INT 22
21598: PUSH
21599: LD_VAR 0 1
21603: PPUSH
21604: CALL_OW 255
21608: PUSH
21609: EMPTY
21610: LIST
21611: LIST
21612: PUSH
21613: LD_INT 2
21615: PUSH
21616: LD_INT 30
21618: PUSH
21619: LD_INT 36
21621: PUSH
21622: EMPTY
21623: LIST
21624: LIST
21625: PUSH
21626: LD_INT 34
21628: PUSH
21629: LD_INT 31
21631: PUSH
21632: EMPTY
21633: LIST
21634: LIST
21635: PUSH
21636: EMPTY
21637: LIST
21638: LIST
21639: LIST
21640: PUSH
21641: EMPTY
21642: LIST
21643: LIST
21644: PPUSH
21645: CALL_OW 69
21649: ST_TO_ADDR
// if not tmp then
21650: LD_VAR 0 6
21654: NOT
21655: IFFALSE 21659
// exit ;
21657: GO 21907
// result := [ ] ;
21659: LD_ADDR_VAR 0 2
21663: PUSH
21664: EMPTY
21665: ST_TO_ADDR
// for i in tmp do
21666: LD_ADDR_VAR 0 3
21670: PUSH
21671: LD_VAR 0 6
21675: PUSH
21676: FOR_IN
21677: IFFALSE 21748
// begin t := UnitsInside ( i ) ;
21679: LD_ADDR_VAR 0 4
21683: PUSH
21684: LD_VAR 0 3
21688: PPUSH
21689: CALL_OW 313
21693: ST_TO_ADDR
// if t then
21694: LD_VAR 0 4
21698: IFFALSE 21746
// for j in t do
21700: LD_ADDR_VAR 0 7
21704: PUSH
21705: LD_VAR 0 4
21709: PUSH
21710: FOR_IN
21711: IFFALSE 21744
// result := Replace ( result , result + 1 , j ) ;
21713: LD_ADDR_VAR 0 2
21717: PUSH
21718: LD_VAR 0 2
21722: PPUSH
21723: LD_VAR 0 2
21727: PUSH
21728: LD_INT 1
21730: PLUS
21731: PPUSH
21732: LD_VAR 0 7
21736: PPUSH
21737: CALL_OW 1
21741: ST_TO_ADDR
21742: GO 21710
21744: POP
21745: POP
// end ;
21746: GO 21676
21748: POP
21749: POP
// if not result then
21750: LD_VAR 0 2
21754: NOT
21755: IFFALSE 21759
// exit ;
21757: GO 21907
// mech := result [ 1 ] ;
21759: LD_ADDR_VAR 0 5
21763: PUSH
21764: LD_VAR 0 2
21768: PUSH
21769: LD_INT 1
21771: ARRAY
21772: ST_TO_ADDR
// if result > 1 then
21773: LD_VAR 0 2
21777: PUSH
21778: LD_INT 1
21780: GREATER
21781: IFFALSE 21893
// begin for i = 2 to result do
21783: LD_ADDR_VAR 0 3
21787: PUSH
21788: DOUBLE
21789: LD_INT 2
21791: DEC
21792: ST_TO_ADDR
21793: LD_VAR 0 2
21797: PUSH
21798: FOR_TO
21799: IFFALSE 21891
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21801: LD_ADDR_VAR 0 4
21805: PUSH
21806: LD_VAR 0 2
21810: PUSH
21811: LD_VAR 0 3
21815: ARRAY
21816: PPUSH
21817: LD_INT 3
21819: PPUSH
21820: CALL_OW 259
21824: PUSH
21825: LD_VAR 0 2
21829: PUSH
21830: LD_VAR 0 3
21834: ARRAY
21835: PPUSH
21836: CALL_OW 432
21840: MINUS
21841: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
21842: LD_VAR 0 4
21846: PUSH
21847: LD_VAR 0 5
21851: PPUSH
21852: LD_INT 3
21854: PPUSH
21855: CALL_OW 259
21859: PUSH
21860: LD_VAR 0 5
21864: PPUSH
21865: CALL_OW 432
21869: MINUS
21870: GREATEREQUAL
21871: IFFALSE 21889
// mech := result [ i ] ;
21873: LD_ADDR_VAR 0 5
21877: PUSH
21878: LD_VAR 0 2
21882: PUSH
21883: LD_VAR 0 3
21887: ARRAY
21888: ST_TO_ADDR
// end ;
21889: GO 21798
21891: POP
21892: POP
// end ; ComLinkTo ( vehicle , mech ) ;
21893: LD_VAR 0 1
21897: PPUSH
21898: LD_VAR 0 5
21902: PPUSH
21903: CALL_OW 135
// end ;
21907: LD_VAR 0 2
21911: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
21912: LD_INT 0
21914: PPUSH
21915: PPUSH
21916: PPUSH
21917: PPUSH
21918: PPUSH
21919: PPUSH
21920: PPUSH
21921: PPUSH
21922: PPUSH
21923: PPUSH
21924: PPUSH
21925: PPUSH
21926: PPUSH
// result := [ ] ;
21927: LD_ADDR_VAR 0 7
21931: PUSH
21932: EMPTY
21933: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
21934: LD_VAR 0 1
21938: PPUSH
21939: CALL_OW 266
21943: PUSH
21944: LD_INT 0
21946: PUSH
21947: LD_INT 1
21949: PUSH
21950: EMPTY
21951: LIST
21952: LIST
21953: IN
21954: NOT
21955: IFFALSE 21959
// exit ;
21957: GO 23593
// if name then
21959: LD_VAR 0 3
21963: IFFALSE 21979
// SetBName ( base_dep , name ) ;
21965: LD_VAR 0 1
21969: PPUSH
21970: LD_VAR 0 3
21974: PPUSH
21975: CALL_OW 500
// base := GetBase ( base_dep ) ;
21979: LD_ADDR_VAR 0 15
21983: PUSH
21984: LD_VAR 0 1
21988: PPUSH
21989: CALL_OW 274
21993: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
21994: LD_ADDR_VAR 0 16
21998: PUSH
21999: LD_VAR 0 1
22003: PPUSH
22004: CALL_OW 255
22008: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22009: LD_ADDR_VAR 0 17
22013: PUSH
22014: LD_VAR 0 1
22018: PPUSH
22019: CALL_OW 248
22023: ST_TO_ADDR
// if sources then
22024: LD_VAR 0 5
22028: IFFALSE 22075
// for i = 1 to 3 do
22030: LD_ADDR_VAR 0 8
22034: PUSH
22035: DOUBLE
22036: LD_INT 1
22038: DEC
22039: ST_TO_ADDR
22040: LD_INT 3
22042: PUSH
22043: FOR_TO
22044: IFFALSE 22073
// AddResourceType ( base , i , sources [ i ] ) ;
22046: LD_VAR 0 15
22050: PPUSH
22051: LD_VAR 0 8
22055: PPUSH
22056: LD_VAR 0 5
22060: PUSH
22061: LD_VAR 0 8
22065: ARRAY
22066: PPUSH
22067: CALL_OW 276
22071: GO 22043
22073: POP
22074: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
22075: LD_ADDR_VAR 0 18
22079: PUSH
22080: LD_VAR 0 15
22084: PPUSH
22085: LD_VAR 0 2
22089: PPUSH
22090: LD_INT 1
22092: PPUSH
22093: CALL 21336 0 3
22097: ST_TO_ADDR
// InitHc ;
22098: CALL_OW 19
// InitUc ;
22102: CALL_OW 18
// uc_side := side ;
22106: LD_ADDR_OWVAR 20
22110: PUSH
22111: LD_VAR 0 16
22115: ST_TO_ADDR
// uc_nation := nation ;
22116: LD_ADDR_OWVAR 21
22120: PUSH
22121: LD_VAR 0 17
22125: ST_TO_ADDR
// if buildings then
22126: LD_VAR 0 18
22130: IFFALSE 23452
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22132: LD_ADDR_VAR 0 19
22136: PUSH
22137: LD_VAR 0 18
22141: PPUSH
22142: LD_INT 2
22144: PUSH
22145: LD_INT 30
22147: PUSH
22148: LD_INT 29
22150: PUSH
22151: EMPTY
22152: LIST
22153: LIST
22154: PUSH
22155: LD_INT 30
22157: PUSH
22158: LD_INT 30
22160: PUSH
22161: EMPTY
22162: LIST
22163: LIST
22164: PUSH
22165: EMPTY
22166: LIST
22167: LIST
22168: LIST
22169: PPUSH
22170: CALL_OW 72
22174: ST_TO_ADDR
// if tmp then
22175: LD_VAR 0 19
22179: IFFALSE 22227
// for i in tmp do
22181: LD_ADDR_VAR 0 8
22185: PUSH
22186: LD_VAR 0 19
22190: PUSH
22191: FOR_IN
22192: IFFALSE 22225
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22194: LD_VAR 0 8
22198: PPUSH
22199: CALL_OW 250
22203: PPUSH
22204: LD_VAR 0 8
22208: PPUSH
22209: CALL_OW 251
22213: PPUSH
22214: LD_VAR 0 16
22218: PPUSH
22219: CALL_OW 441
22223: GO 22191
22225: POP
22226: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22227: LD_VAR 0 18
22231: PPUSH
22232: LD_INT 2
22234: PUSH
22235: LD_INT 30
22237: PUSH
22238: LD_INT 32
22240: PUSH
22241: EMPTY
22242: LIST
22243: LIST
22244: PUSH
22245: LD_INT 30
22247: PUSH
22248: LD_INT 33
22250: PUSH
22251: EMPTY
22252: LIST
22253: LIST
22254: PUSH
22255: EMPTY
22256: LIST
22257: LIST
22258: LIST
22259: PPUSH
22260: CALL_OW 72
22264: IFFALSE 22352
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22266: LD_ADDR_VAR 0 8
22270: PUSH
22271: LD_VAR 0 18
22275: PPUSH
22276: LD_INT 2
22278: PUSH
22279: LD_INT 30
22281: PUSH
22282: LD_INT 32
22284: PUSH
22285: EMPTY
22286: LIST
22287: LIST
22288: PUSH
22289: LD_INT 30
22291: PUSH
22292: LD_INT 33
22294: PUSH
22295: EMPTY
22296: LIST
22297: LIST
22298: PUSH
22299: EMPTY
22300: LIST
22301: LIST
22302: LIST
22303: PPUSH
22304: CALL_OW 72
22308: PUSH
22309: FOR_IN
22310: IFFALSE 22350
// begin if not GetBWeapon ( i ) then
22312: LD_VAR 0 8
22316: PPUSH
22317: CALL_OW 269
22321: NOT
22322: IFFALSE 22348
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22324: LD_VAR 0 8
22328: PPUSH
22329: LD_VAR 0 8
22333: PPUSH
22334: LD_VAR 0 2
22338: PPUSH
22339: CALL 23598 0 2
22343: PPUSH
22344: CALL_OW 431
// end ;
22348: GO 22309
22350: POP
22351: POP
// end ; for i = 1 to personel do
22352: LD_ADDR_VAR 0 8
22356: PUSH
22357: DOUBLE
22358: LD_INT 1
22360: DEC
22361: ST_TO_ADDR
22362: LD_VAR 0 6
22366: PUSH
22367: FOR_TO
22368: IFFALSE 23432
// begin if i > 4 then
22370: LD_VAR 0 8
22374: PUSH
22375: LD_INT 4
22377: GREATER
22378: IFFALSE 22382
// break ;
22380: GO 23432
// case i of 1 :
22382: LD_VAR 0 8
22386: PUSH
22387: LD_INT 1
22389: DOUBLE
22390: EQUAL
22391: IFTRUE 22395
22393: GO 22475
22395: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
22396: LD_ADDR_VAR 0 12
22400: PUSH
22401: LD_VAR 0 18
22405: PPUSH
22406: LD_INT 22
22408: PUSH
22409: LD_VAR 0 16
22413: PUSH
22414: EMPTY
22415: LIST
22416: LIST
22417: PUSH
22418: LD_INT 58
22420: PUSH
22421: EMPTY
22422: LIST
22423: PUSH
22424: LD_INT 2
22426: PUSH
22427: LD_INT 30
22429: PUSH
22430: LD_INT 32
22432: PUSH
22433: EMPTY
22434: LIST
22435: LIST
22436: PUSH
22437: LD_INT 30
22439: PUSH
22440: LD_INT 4
22442: PUSH
22443: EMPTY
22444: LIST
22445: LIST
22446: PUSH
22447: LD_INT 30
22449: PUSH
22450: LD_INT 5
22452: PUSH
22453: EMPTY
22454: LIST
22455: LIST
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: LIST
22461: LIST
22462: PUSH
22463: EMPTY
22464: LIST
22465: LIST
22466: LIST
22467: PPUSH
22468: CALL_OW 72
22472: ST_TO_ADDR
22473: GO 22697
22475: LD_INT 2
22477: DOUBLE
22478: EQUAL
22479: IFTRUE 22483
22481: GO 22545
22483: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22484: LD_ADDR_VAR 0 12
22488: PUSH
22489: LD_VAR 0 18
22493: PPUSH
22494: LD_INT 22
22496: PUSH
22497: LD_VAR 0 16
22501: PUSH
22502: EMPTY
22503: LIST
22504: LIST
22505: PUSH
22506: LD_INT 2
22508: PUSH
22509: LD_INT 30
22511: PUSH
22512: LD_INT 0
22514: PUSH
22515: EMPTY
22516: LIST
22517: LIST
22518: PUSH
22519: LD_INT 30
22521: PUSH
22522: LD_INT 1
22524: PUSH
22525: EMPTY
22526: LIST
22527: LIST
22528: PUSH
22529: EMPTY
22530: LIST
22531: LIST
22532: LIST
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PPUSH
22538: CALL_OW 72
22542: ST_TO_ADDR
22543: GO 22697
22545: LD_INT 3
22547: DOUBLE
22548: EQUAL
22549: IFTRUE 22553
22551: GO 22615
22553: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22554: LD_ADDR_VAR 0 12
22558: PUSH
22559: LD_VAR 0 18
22563: PPUSH
22564: LD_INT 22
22566: PUSH
22567: LD_VAR 0 16
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: LD_INT 2
22578: PUSH
22579: LD_INT 30
22581: PUSH
22582: LD_INT 2
22584: PUSH
22585: EMPTY
22586: LIST
22587: LIST
22588: PUSH
22589: LD_INT 30
22591: PUSH
22592: LD_INT 3
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: PUSH
22599: EMPTY
22600: LIST
22601: LIST
22602: LIST
22603: PUSH
22604: EMPTY
22605: LIST
22606: LIST
22607: PPUSH
22608: CALL_OW 72
22612: ST_TO_ADDR
22613: GO 22697
22615: LD_INT 4
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22696
22623: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22624: LD_ADDR_VAR 0 12
22628: PUSH
22629: LD_VAR 0 18
22633: PPUSH
22634: LD_INT 22
22636: PUSH
22637: LD_VAR 0 16
22641: PUSH
22642: EMPTY
22643: LIST
22644: LIST
22645: PUSH
22646: LD_INT 2
22648: PUSH
22649: LD_INT 30
22651: PUSH
22652: LD_INT 6
22654: PUSH
22655: EMPTY
22656: LIST
22657: LIST
22658: PUSH
22659: LD_INT 30
22661: PUSH
22662: LD_INT 7
22664: PUSH
22665: EMPTY
22666: LIST
22667: LIST
22668: PUSH
22669: LD_INT 30
22671: PUSH
22672: LD_INT 8
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: PUSH
22679: EMPTY
22680: LIST
22681: LIST
22682: LIST
22683: LIST
22684: PUSH
22685: EMPTY
22686: LIST
22687: LIST
22688: PPUSH
22689: CALL_OW 72
22693: ST_TO_ADDR
22694: GO 22697
22696: POP
// if i = 1 then
22697: LD_VAR 0 8
22701: PUSH
22702: LD_INT 1
22704: EQUAL
22705: IFFALSE 22816
// begin tmp := [ ] ;
22707: LD_ADDR_VAR 0 19
22711: PUSH
22712: EMPTY
22713: ST_TO_ADDR
// for j in f do
22714: LD_ADDR_VAR 0 9
22718: PUSH
22719: LD_VAR 0 12
22723: PUSH
22724: FOR_IN
22725: IFFALSE 22798
// if GetBType ( j ) = b_bunker then
22727: LD_VAR 0 9
22731: PPUSH
22732: CALL_OW 266
22736: PUSH
22737: LD_INT 32
22739: EQUAL
22740: IFFALSE 22767
// tmp := Insert ( tmp , 1 , j ) else
22742: LD_ADDR_VAR 0 19
22746: PUSH
22747: LD_VAR 0 19
22751: PPUSH
22752: LD_INT 1
22754: PPUSH
22755: LD_VAR 0 9
22759: PPUSH
22760: CALL_OW 2
22764: ST_TO_ADDR
22765: GO 22796
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22767: LD_ADDR_VAR 0 19
22771: PUSH
22772: LD_VAR 0 19
22776: PPUSH
22777: LD_VAR 0 19
22781: PUSH
22782: LD_INT 1
22784: PLUS
22785: PPUSH
22786: LD_VAR 0 9
22790: PPUSH
22791: CALL_OW 2
22795: ST_TO_ADDR
22796: GO 22724
22798: POP
22799: POP
// if tmp then
22800: LD_VAR 0 19
22804: IFFALSE 22816
// f := tmp ;
22806: LD_ADDR_VAR 0 12
22810: PUSH
22811: LD_VAR 0 19
22815: ST_TO_ADDR
// end ; x := personel [ i ] ;
22816: LD_ADDR_VAR 0 13
22820: PUSH
22821: LD_VAR 0 6
22825: PUSH
22826: LD_VAR 0 8
22830: ARRAY
22831: ST_TO_ADDR
// if x = - 1 then
22832: LD_VAR 0 13
22836: PUSH
22837: LD_INT 1
22839: NEG
22840: EQUAL
22841: IFFALSE 23050
// begin for j in f do
22843: LD_ADDR_VAR 0 9
22847: PUSH
22848: LD_VAR 0 12
22852: PUSH
22853: FOR_IN
22854: IFFALSE 23046
// repeat InitHc ;
22856: CALL_OW 19
// if GetBType ( j ) = b_barracks then
22860: LD_VAR 0 9
22864: PPUSH
22865: CALL_OW 266
22869: PUSH
22870: LD_INT 5
22872: EQUAL
22873: IFFALSE 22943
// begin if UnitsInside ( j ) < 3 then
22875: LD_VAR 0 9
22879: PPUSH
22880: CALL_OW 313
22884: PUSH
22885: LD_INT 3
22887: LESS
22888: IFFALSE 22924
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22890: LD_INT 0
22892: PPUSH
22893: LD_INT 5
22895: PUSH
22896: LD_INT 8
22898: PUSH
22899: LD_INT 9
22901: PUSH
22902: EMPTY
22903: LIST
22904: LIST
22905: LIST
22906: PUSH
22907: LD_VAR 0 17
22911: ARRAY
22912: PPUSH
22913: LD_VAR 0 4
22917: PPUSH
22918: CALL_OW 380
22922: GO 22941
// PrepareHuman ( false , i , skill ) ;
22924: LD_INT 0
22926: PPUSH
22927: LD_VAR 0 8
22931: PPUSH
22932: LD_VAR 0 4
22936: PPUSH
22937: CALL_OW 380
// end else
22941: GO 22960
// PrepareHuman ( false , i , skill ) ;
22943: LD_INT 0
22945: PPUSH
22946: LD_VAR 0 8
22950: PPUSH
22951: LD_VAR 0 4
22955: PPUSH
22956: CALL_OW 380
// un := CreateHuman ;
22960: LD_ADDR_VAR 0 14
22964: PUSH
22965: CALL_OW 44
22969: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22970: LD_ADDR_VAR 0 7
22974: PUSH
22975: LD_VAR 0 7
22979: PPUSH
22980: LD_INT 1
22982: PPUSH
22983: LD_VAR 0 14
22987: PPUSH
22988: CALL_OW 2
22992: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
22993: LD_VAR 0 14
22997: PPUSH
22998: LD_VAR 0 9
23002: PPUSH
23003: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
23007: LD_VAR 0 9
23011: PPUSH
23012: CALL_OW 313
23016: PUSH
23017: LD_INT 6
23019: EQUAL
23020: PUSH
23021: LD_VAR 0 9
23025: PPUSH
23026: CALL_OW 266
23030: PUSH
23031: LD_INT 32
23033: PUSH
23034: LD_INT 31
23036: PUSH
23037: EMPTY
23038: LIST
23039: LIST
23040: IN
23041: OR
23042: IFFALSE 22856
23044: GO 22853
23046: POP
23047: POP
// end else
23048: GO 23430
// for j = 1 to x do
23050: LD_ADDR_VAR 0 9
23054: PUSH
23055: DOUBLE
23056: LD_INT 1
23058: DEC
23059: ST_TO_ADDR
23060: LD_VAR 0 13
23064: PUSH
23065: FOR_TO
23066: IFFALSE 23428
// begin InitHc ;
23068: CALL_OW 19
// if not f then
23072: LD_VAR 0 12
23076: NOT
23077: IFFALSE 23166
// begin PrepareHuman ( false , i , skill ) ;
23079: LD_INT 0
23081: PPUSH
23082: LD_VAR 0 8
23086: PPUSH
23087: LD_VAR 0 4
23091: PPUSH
23092: CALL_OW 380
// un := CreateHuman ;
23096: LD_ADDR_VAR 0 14
23100: PUSH
23101: CALL_OW 44
23105: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23106: LD_ADDR_VAR 0 7
23110: PUSH
23111: LD_VAR 0 7
23115: PPUSH
23116: LD_INT 1
23118: PPUSH
23119: LD_VAR 0 14
23123: PPUSH
23124: CALL_OW 2
23128: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23129: LD_VAR 0 14
23133: PPUSH
23134: LD_VAR 0 1
23138: PPUSH
23139: CALL_OW 250
23143: PPUSH
23144: LD_VAR 0 1
23148: PPUSH
23149: CALL_OW 251
23153: PPUSH
23154: LD_INT 10
23156: PPUSH
23157: LD_INT 0
23159: PPUSH
23160: CALL_OW 50
// continue ;
23164: GO 23065
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23166: LD_VAR 0 12
23170: PUSH
23171: LD_INT 1
23173: ARRAY
23174: PPUSH
23175: CALL_OW 313
23179: PUSH
23180: LD_VAR 0 12
23184: PUSH
23185: LD_INT 1
23187: ARRAY
23188: PPUSH
23189: CALL_OW 266
23193: PUSH
23194: LD_INT 32
23196: PUSH
23197: LD_INT 31
23199: PUSH
23200: EMPTY
23201: LIST
23202: LIST
23203: IN
23204: AND
23205: PUSH
23206: LD_VAR 0 12
23210: PUSH
23211: LD_INT 1
23213: ARRAY
23214: PPUSH
23215: CALL_OW 313
23219: PUSH
23220: LD_INT 6
23222: EQUAL
23223: OR
23224: IFFALSE 23244
// f := Delete ( f , 1 ) ;
23226: LD_ADDR_VAR 0 12
23230: PUSH
23231: LD_VAR 0 12
23235: PPUSH
23236: LD_INT 1
23238: PPUSH
23239: CALL_OW 3
23243: ST_TO_ADDR
// if not f then
23244: LD_VAR 0 12
23248: NOT
23249: IFFALSE 23267
// begin x := x + 2 ;
23251: LD_ADDR_VAR 0 13
23255: PUSH
23256: LD_VAR 0 13
23260: PUSH
23261: LD_INT 2
23263: PLUS
23264: ST_TO_ADDR
// continue ;
23265: GO 23065
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23267: LD_VAR 0 12
23271: PUSH
23272: LD_INT 1
23274: ARRAY
23275: PPUSH
23276: CALL_OW 266
23280: PUSH
23281: LD_INT 5
23283: EQUAL
23284: IFFALSE 23358
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23286: LD_VAR 0 12
23290: PUSH
23291: LD_INT 1
23293: ARRAY
23294: PPUSH
23295: CALL_OW 313
23299: PUSH
23300: LD_INT 3
23302: LESS
23303: IFFALSE 23339
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23305: LD_INT 0
23307: PPUSH
23308: LD_INT 5
23310: PUSH
23311: LD_INT 8
23313: PUSH
23314: LD_INT 9
23316: PUSH
23317: EMPTY
23318: LIST
23319: LIST
23320: LIST
23321: PUSH
23322: LD_VAR 0 17
23326: ARRAY
23327: PPUSH
23328: LD_VAR 0 4
23332: PPUSH
23333: CALL_OW 380
23337: GO 23356
// PrepareHuman ( false , i , skill ) ;
23339: LD_INT 0
23341: PPUSH
23342: LD_VAR 0 8
23346: PPUSH
23347: LD_VAR 0 4
23351: PPUSH
23352: CALL_OW 380
// end else
23356: GO 23375
// PrepareHuman ( false , i , skill ) ;
23358: LD_INT 0
23360: PPUSH
23361: LD_VAR 0 8
23365: PPUSH
23366: LD_VAR 0 4
23370: PPUSH
23371: CALL_OW 380
// un := CreateHuman ;
23375: LD_ADDR_VAR 0 14
23379: PUSH
23380: CALL_OW 44
23384: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23385: LD_ADDR_VAR 0 7
23389: PUSH
23390: LD_VAR 0 7
23394: PPUSH
23395: LD_INT 1
23397: PPUSH
23398: LD_VAR 0 14
23402: PPUSH
23403: CALL_OW 2
23407: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
23408: LD_VAR 0 14
23412: PPUSH
23413: LD_VAR 0 12
23417: PUSH
23418: LD_INT 1
23420: ARRAY
23421: PPUSH
23422: CALL_OW 52
// end ;
23426: GO 23065
23428: POP
23429: POP
// end ;
23430: GO 22367
23432: POP
23433: POP
// result := result ^ buildings ;
23434: LD_ADDR_VAR 0 7
23438: PUSH
23439: LD_VAR 0 7
23443: PUSH
23444: LD_VAR 0 18
23448: ADD
23449: ST_TO_ADDR
// end else
23450: GO 23593
// begin for i = 1 to personel do
23452: LD_ADDR_VAR 0 8
23456: PUSH
23457: DOUBLE
23458: LD_INT 1
23460: DEC
23461: ST_TO_ADDR
23462: LD_VAR 0 6
23466: PUSH
23467: FOR_TO
23468: IFFALSE 23591
// begin if i > 4 then
23470: LD_VAR 0 8
23474: PUSH
23475: LD_INT 4
23477: GREATER
23478: IFFALSE 23482
// break ;
23480: GO 23591
// x := personel [ i ] ;
23482: LD_ADDR_VAR 0 13
23486: PUSH
23487: LD_VAR 0 6
23491: PUSH
23492: LD_VAR 0 8
23496: ARRAY
23497: ST_TO_ADDR
// if x = - 1 then
23498: LD_VAR 0 13
23502: PUSH
23503: LD_INT 1
23505: NEG
23506: EQUAL
23507: IFFALSE 23511
// continue ;
23509: GO 23467
// PrepareHuman ( false , i , skill ) ;
23511: LD_INT 0
23513: PPUSH
23514: LD_VAR 0 8
23518: PPUSH
23519: LD_VAR 0 4
23523: PPUSH
23524: CALL_OW 380
// un := CreateHuman ;
23528: LD_ADDR_VAR 0 14
23532: PUSH
23533: CALL_OW 44
23537: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23538: LD_VAR 0 14
23542: PPUSH
23543: LD_VAR 0 1
23547: PPUSH
23548: CALL_OW 250
23552: PPUSH
23553: LD_VAR 0 1
23557: PPUSH
23558: CALL_OW 251
23562: PPUSH
23563: LD_INT 10
23565: PPUSH
23566: LD_INT 0
23568: PPUSH
23569: CALL_OW 50
// result := result ^ un ;
23573: LD_ADDR_VAR 0 7
23577: PUSH
23578: LD_VAR 0 7
23582: PUSH
23583: LD_VAR 0 14
23587: ADD
23588: ST_TO_ADDR
// end ;
23589: GO 23467
23591: POP
23592: POP
// end ; end ;
23593: LD_VAR 0 7
23597: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23598: LD_INT 0
23600: PPUSH
23601: PPUSH
23602: PPUSH
23603: PPUSH
23604: PPUSH
23605: PPUSH
23606: PPUSH
23607: PPUSH
23608: PPUSH
23609: PPUSH
23610: PPUSH
23611: PPUSH
23612: PPUSH
23613: PPUSH
23614: PPUSH
23615: PPUSH
// result := false ;
23616: LD_ADDR_VAR 0 3
23620: PUSH
23621: LD_INT 0
23623: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23624: LD_VAR 0 1
23628: NOT
23629: PUSH
23630: LD_VAR 0 1
23634: PPUSH
23635: CALL_OW 266
23639: PUSH
23640: LD_INT 32
23642: PUSH
23643: LD_INT 33
23645: PUSH
23646: EMPTY
23647: LIST
23648: LIST
23649: IN
23650: NOT
23651: OR
23652: IFFALSE 23656
// exit ;
23654: GO 24765
// nat := GetNation ( tower ) ;
23656: LD_ADDR_VAR 0 12
23660: PUSH
23661: LD_VAR 0 1
23665: PPUSH
23666: CALL_OW 248
23670: ST_TO_ADDR
// side := GetSide ( tower ) ;
23671: LD_ADDR_VAR 0 16
23675: PUSH
23676: LD_VAR 0 1
23680: PPUSH
23681: CALL_OW 255
23685: ST_TO_ADDR
// x := GetX ( tower ) ;
23686: LD_ADDR_VAR 0 10
23690: PUSH
23691: LD_VAR 0 1
23695: PPUSH
23696: CALL_OW 250
23700: ST_TO_ADDR
// y := GetY ( tower ) ;
23701: LD_ADDR_VAR 0 11
23705: PUSH
23706: LD_VAR 0 1
23710: PPUSH
23711: CALL_OW 251
23715: ST_TO_ADDR
// if not x or not y then
23716: LD_VAR 0 10
23720: NOT
23721: PUSH
23722: LD_VAR 0 11
23726: NOT
23727: OR
23728: IFFALSE 23732
// exit ;
23730: GO 24765
// weapon := 0 ;
23732: LD_ADDR_VAR 0 18
23736: PUSH
23737: LD_INT 0
23739: ST_TO_ADDR
// fac_list := [ ] ;
23740: LD_ADDR_VAR 0 17
23744: PUSH
23745: EMPTY
23746: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
23747: LD_ADDR_VAR 0 6
23751: PUSH
23752: LD_VAR 0 1
23756: PPUSH
23757: CALL_OW 274
23761: PPUSH
23762: LD_VAR 0 2
23766: PPUSH
23767: LD_INT 0
23769: PPUSH
23770: CALL 21336 0 3
23774: PPUSH
23775: LD_INT 30
23777: PUSH
23778: LD_INT 3
23780: PUSH
23781: EMPTY
23782: LIST
23783: LIST
23784: PPUSH
23785: CALL_OW 72
23789: ST_TO_ADDR
// if not factories then
23790: LD_VAR 0 6
23794: NOT
23795: IFFALSE 23799
// exit ;
23797: GO 24765
// for i in factories do
23799: LD_ADDR_VAR 0 8
23803: PUSH
23804: LD_VAR 0 6
23808: PUSH
23809: FOR_IN
23810: IFFALSE 23835
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23812: LD_ADDR_VAR 0 17
23816: PUSH
23817: LD_VAR 0 17
23821: PUSH
23822: LD_VAR 0 8
23826: PPUSH
23827: CALL_OW 478
23831: UNION
23832: ST_TO_ADDR
23833: GO 23809
23835: POP
23836: POP
// if not fac_list then
23837: LD_VAR 0 17
23841: NOT
23842: IFFALSE 23846
// exit ;
23844: GO 24765
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
23846: LD_ADDR_VAR 0 5
23850: PUSH
23851: LD_INT 4
23853: PUSH
23854: LD_INT 5
23856: PUSH
23857: LD_INT 9
23859: PUSH
23860: LD_INT 10
23862: PUSH
23863: LD_INT 6
23865: PUSH
23866: LD_INT 7
23868: PUSH
23869: LD_INT 11
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: LIST
23876: LIST
23877: LIST
23878: LIST
23879: LIST
23880: PUSH
23881: LD_INT 27
23883: PUSH
23884: LD_INT 28
23886: PUSH
23887: LD_INT 26
23889: PUSH
23890: LD_INT 30
23892: PUSH
23893: EMPTY
23894: LIST
23895: LIST
23896: LIST
23897: LIST
23898: PUSH
23899: LD_INT 43
23901: PUSH
23902: LD_INT 44
23904: PUSH
23905: LD_INT 46
23907: PUSH
23908: LD_INT 45
23910: PUSH
23911: LD_INT 47
23913: PUSH
23914: LD_INT 49
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: LIST
23921: LIST
23922: LIST
23923: LIST
23924: PUSH
23925: EMPTY
23926: LIST
23927: LIST
23928: LIST
23929: PUSH
23930: LD_VAR 0 12
23934: ARRAY
23935: ST_TO_ADDR
// list := list isect fac_list ;
23936: LD_ADDR_VAR 0 5
23940: PUSH
23941: LD_VAR 0 5
23945: PUSH
23946: LD_VAR 0 17
23950: ISECT
23951: ST_TO_ADDR
// if not list then
23952: LD_VAR 0 5
23956: NOT
23957: IFFALSE 23961
// exit ;
23959: GO 24765
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
23961: LD_VAR 0 12
23965: PUSH
23966: LD_INT 3
23968: EQUAL
23969: PUSH
23970: LD_INT 49
23972: PUSH
23973: LD_VAR 0 5
23977: IN
23978: AND
23979: PUSH
23980: LD_INT 31
23982: PPUSH
23983: LD_VAR 0 16
23987: PPUSH
23988: CALL_OW 321
23992: PUSH
23993: LD_INT 2
23995: EQUAL
23996: AND
23997: IFFALSE 24057
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
23999: LD_INT 22
24001: PUSH
24002: LD_VAR 0 16
24006: PUSH
24007: EMPTY
24008: LIST
24009: LIST
24010: PUSH
24011: LD_INT 35
24013: PUSH
24014: LD_INT 49
24016: PUSH
24017: EMPTY
24018: LIST
24019: LIST
24020: PUSH
24021: LD_INT 91
24023: PUSH
24024: LD_VAR 0 1
24028: PUSH
24029: LD_INT 10
24031: PUSH
24032: EMPTY
24033: LIST
24034: LIST
24035: LIST
24036: PUSH
24037: EMPTY
24038: LIST
24039: LIST
24040: LIST
24041: PPUSH
24042: CALL_OW 69
24046: NOT
24047: IFFALSE 24057
// weapon := ru_time_lapser ;
24049: LD_ADDR_VAR 0 18
24053: PUSH
24054: LD_INT 49
24056: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24057: LD_VAR 0 12
24061: PUSH
24062: LD_INT 1
24064: PUSH
24065: LD_INT 2
24067: PUSH
24068: EMPTY
24069: LIST
24070: LIST
24071: IN
24072: PUSH
24073: LD_INT 11
24075: PUSH
24076: LD_VAR 0 5
24080: IN
24081: PUSH
24082: LD_INT 30
24084: PUSH
24085: LD_VAR 0 5
24089: IN
24090: OR
24091: AND
24092: PUSH
24093: LD_INT 6
24095: PPUSH
24096: LD_VAR 0 16
24100: PPUSH
24101: CALL_OW 321
24105: PUSH
24106: LD_INT 2
24108: EQUAL
24109: AND
24110: IFFALSE 24275
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24112: LD_INT 22
24114: PUSH
24115: LD_VAR 0 16
24119: PUSH
24120: EMPTY
24121: LIST
24122: LIST
24123: PUSH
24124: LD_INT 2
24126: PUSH
24127: LD_INT 35
24129: PUSH
24130: LD_INT 11
24132: PUSH
24133: EMPTY
24134: LIST
24135: LIST
24136: PUSH
24137: LD_INT 35
24139: PUSH
24140: LD_INT 30
24142: PUSH
24143: EMPTY
24144: LIST
24145: LIST
24146: PUSH
24147: EMPTY
24148: LIST
24149: LIST
24150: LIST
24151: PUSH
24152: LD_INT 91
24154: PUSH
24155: LD_VAR 0 1
24159: PUSH
24160: LD_INT 18
24162: PUSH
24163: EMPTY
24164: LIST
24165: LIST
24166: LIST
24167: PUSH
24168: EMPTY
24169: LIST
24170: LIST
24171: LIST
24172: PPUSH
24173: CALL_OW 69
24177: NOT
24178: PUSH
24179: LD_INT 22
24181: PUSH
24182: LD_VAR 0 16
24186: PUSH
24187: EMPTY
24188: LIST
24189: LIST
24190: PUSH
24191: LD_INT 2
24193: PUSH
24194: LD_INT 30
24196: PUSH
24197: LD_INT 32
24199: PUSH
24200: EMPTY
24201: LIST
24202: LIST
24203: PUSH
24204: LD_INT 30
24206: PUSH
24207: LD_INT 33
24209: PUSH
24210: EMPTY
24211: LIST
24212: LIST
24213: PUSH
24214: EMPTY
24215: LIST
24216: LIST
24217: LIST
24218: PUSH
24219: LD_INT 91
24221: PUSH
24222: LD_VAR 0 1
24226: PUSH
24227: LD_INT 12
24229: PUSH
24230: EMPTY
24231: LIST
24232: LIST
24233: LIST
24234: PUSH
24235: EMPTY
24236: LIST
24237: LIST
24238: LIST
24239: PUSH
24240: EMPTY
24241: LIST
24242: PPUSH
24243: CALL_OW 69
24247: PUSH
24248: LD_INT 2
24250: GREATER
24251: AND
24252: IFFALSE 24275
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24254: LD_ADDR_VAR 0 18
24258: PUSH
24259: LD_INT 11
24261: PUSH
24262: LD_INT 30
24264: PUSH
24265: EMPTY
24266: LIST
24267: LIST
24268: PUSH
24269: LD_VAR 0 12
24273: ARRAY
24274: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24275: LD_VAR 0 18
24279: NOT
24280: PUSH
24281: LD_INT 40
24283: PPUSH
24284: LD_VAR 0 16
24288: PPUSH
24289: CALL_OW 321
24293: PUSH
24294: LD_INT 2
24296: EQUAL
24297: AND
24298: PUSH
24299: LD_INT 7
24301: PUSH
24302: LD_VAR 0 5
24306: IN
24307: PUSH
24308: LD_INT 28
24310: PUSH
24311: LD_VAR 0 5
24315: IN
24316: OR
24317: PUSH
24318: LD_INT 45
24320: PUSH
24321: LD_VAR 0 5
24325: IN
24326: OR
24327: AND
24328: IFFALSE 24582
// begin hex := GetHexInfo ( x , y ) ;
24330: LD_ADDR_VAR 0 4
24334: PUSH
24335: LD_VAR 0 10
24339: PPUSH
24340: LD_VAR 0 11
24344: PPUSH
24345: CALL_OW 546
24349: ST_TO_ADDR
// if hex [ 1 ] then
24350: LD_VAR 0 4
24354: PUSH
24355: LD_INT 1
24357: ARRAY
24358: IFFALSE 24362
// exit ;
24360: GO 24765
// height := hex [ 2 ] ;
24362: LD_ADDR_VAR 0 15
24366: PUSH
24367: LD_VAR 0 4
24371: PUSH
24372: LD_INT 2
24374: ARRAY
24375: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
24376: LD_ADDR_VAR 0 14
24380: PUSH
24381: LD_INT 0
24383: PUSH
24384: LD_INT 2
24386: PUSH
24387: LD_INT 3
24389: PUSH
24390: LD_INT 5
24392: PUSH
24393: EMPTY
24394: LIST
24395: LIST
24396: LIST
24397: LIST
24398: ST_TO_ADDR
// for i in tmp do
24399: LD_ADDR_VAR 0 8
24403: PUSH
24404: LD_VAR 0 14
24408: PUSH
24409: FOR_IN
24410: IFFALSE 24580
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
24412: LD_ADDR_VAR 0 9
24416: PUSH
24417: LD_VAR 0 10
24421: PPUSH
24422: LD_VAR 0 8
24426: PPUSH
24427: LD_INT 5
24429: PPUSH
24430: CALL_OW 272
24434: PUSH
24435: LD_VAR 0 11
24439: PPUSH
24440: LD_VAR 0 8
24444: PPUSH
24445: LD_INT 5
24447: PPUSH
24448: CALL_OW 273
24452: PUSH
24453: EMPTY
24454: LIST
24455: LIST
24456: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24457: LD_VAR 0 9
24461: PUSH
24462: LD_INT 1
24464: ARRAY
24465: PPUSH
24466: LD_VAR 0 9
24470: PUSH
24471: LD_INT 2
24473: ARRAY
24474: PPUSH
24475: CALL_OW 488
24479: IFFALSE 24578
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24481: LD_ADDR_VAR 0 4
24485: PUSH
24486: LD_VAR 0 9
24490: PUSH
24491: LD_INT 1
24493: ARRAY
24494: PPUSH
24495: LD_VAR 0 9
24499: PUSH
24500: LD_INT 2
24502: ARRAY
24503: PPUSH
24504: CALL_OW 546
24508: ST_TO_ADDR
// if hex [ 1 ] then
24509: LD_VAR 0 4
24513: PUSH
24514: LD_INT 1
24516: ARRAY
24517: IFFALSE 24521
// continue ;
24519: GO 24409
// h := hex [ 2 ] ;
24521: LD_ADDR_VAR 0 13
24525: PUSH
24526: LD_VAR 0 4
24530: PUSH
24531: LD_INT 2
24533: ARRAY
24534: ST_TO_ADDR
// if h + 7 < height then
24535: LD_VAR 0 13
24539: PUSH
24540: LD_INT 7
24542: PLUS
24543: PUSH
24544: LD_VAR 0 15
24548: LESS
24549: IFFALSE 24578
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24551: LD_ADDR_VAR 0 18
24555: PUSH
24556: LD_INT 7
24558: PUSH
24559: LD_INT 28
24561: PUSH
24562: LD_INT 45
24564: PUSH
24565: EMPTY
24566: LIST
24567: LIST
24568: LIST
24569: PUSH
24570: LD_VAR 0 12
24574: ARRAY
24575: ST_TO_ADDR
// break ;
24576: GO 24580
// end ; end ; end ;
24578: GO 24409
24580: POP
24581: POP
// end ; if not weapon then
24582: LD_VAR 0 18
24586: NOT
24587: IFFALSE 24647
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24589: LD_ADDR_VAR 0 5
24593: PUSH
24594: LD_VAR 0 5
24598: PUSH
24599: LD_INT 11
24601: PUSH
24602: LD_INT 30
24604: PUSH
24605: LD_INT 49
24607: PUSH
24608: EMPTY
24609: LIST
24610: LIST
24611: LIST
24612: DIFF
24613: ST_TO_ADDR
// if not list then
24614: LD_VAR 0 5
24618: NOT
24619: IFFALSE 24623
// exit ;
24621: GO 24765
// weapon := list [ rand ( 1 , list ) ] ;
24623: LD_ADDR_VAR 0 18
24627: PUSH
24628: LD_VAR 0 5
24632: PUSH
24633: LD_INT 1
24635: PPUSH
24636: LD_VAR 0 5
24640: PPUSH
24641: CALL_OW 12
24645: ARRAY
24646: ST_TO_ADDR
// end ; if weapon then
24647: LD_VAR 0 18
24651: IFFALSE 24765
// begin tmp := CostOfWeapon ( weapon ) ;
24653: LD_ADDR_VAR 0 14
24657: PUSH
24658: LD_VAR 0 18
24662: PPUSH
24663: CALL_OW 451
24667: ST_TO_ADDR
// j := GetBase ( tower ) ;
24668: LD_ADDR_VAR 0 9
24672: PUSH
24673: LD_VAR 0 1
24677: PPUSH
24678: CALL_OW 274
24682: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24683: LD_VAR 0 9
24687: PPUSH
24688: LD_INT 1
24690: PPUSH
24691: CALL_OW 275
24695: PUSH
24696: LD_VAR 0 14
24700: PUSH
24701: LD_INT 1
24703: ARRAY
24704: GREATEREQUAL
24705: PUSH
24706: LD_VAR 0 9
24710: PPUSH
24711: LD_INT 2
24713: PPUSH
24714: CALL_OW 275
24718: PUSH
24719: LD_VAR 0 14
24723: PUSH
24724: LD_INT 2
24726: ARRAY
24727: GREATEREQUAL
24728: AND
24729: PUSH
24730: LD_VAR 0 9
24734: PPUSH
24735: LD_INT 3
24737: PPUSH
24738: CALL_OW 275
24742: PUSH
24743: LD_VAR 0 14
24747: PUSH
24748: LD_INT 3
24750: ARRAY
24751: GREATEREQUAL
24752: AND
24753: IFFALSE 24765
// result := weapon ;
24755: LD_ADDR_VAR 0 3
24759: PUSH
24760: LD_VAR 0 18
24764: ST_TO_ADDR
// end ; end ;
24765: LD_VAR 0 3
24769: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24770: LD_INT 0
24772: PPUSH
24773: PPUSH
// result := true ;
24774: LD_ADDR_VAR 0 3
24778: PUSH
24779: LD_INT 1
24781: ST_TO_ADDR
// if array1 = array2 then
24782: LD_VAR 0 1
24786: PUSH
24787: LD_VAR 0 2
24791: EQUAL
24792: IFFALSE 24852
// begin for i = 1 to array1 do
24794: LD_ADDR_VAR 0 4
24798: PUSH
24799: DOUBLE
24800: LD_INT 1
24802: DEC
24803: ST_TO_ADDR
24804: LD_VAR 0 1
24808: PUSH
24809: FOR_TO
24810: IFFALSE 24848
// if array1 [ i ] <> array2 [ i ] then
24812: LD_VAR 0 1
24816: PUSH
24817: LD_VAR 0 4
24821: ARRAY
24822: PUSH
24823: LD_VAR 0 2
24827: PUSH
24828: LD_VAR 0 4
24832: ARRAY
24833: NONEQUAL
24834: IFFALSE 24846
// begin result := false ;
24836: LD_ADDR_VAR 0 3
24840: PUSH
24841: LD_INT 0
24843: ST_TO_ADDR
// break ;
24844: GO 24848
// end ;
24846: GO 24809
24848: POP
24849: POP
// end else
24850: GO 24860
// result := false ;
24852: LD_ADDR_VAR 0 3
24856: PUSH
24857: LD_INT 0
24859: ST_TO_ADDR
// end ;
24860: LD_VAR 0 3
24864: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
24865: LD_INT 0
24867: PPUSH
24868: PPUSH
// if not array1 or not array2 then
24869: LD_VAR 0 1
24873: NOT
24874: PUSH
24875: LD_VAR 0 2
24879: NOT
24880: OR
24881: IFFALSE 24885
// exit ;
24883: GO 24949
// result := true ;
24885: LD_ADDR_VAR 0 3
24889: PUSH
24890: LD_INT 1
24892: ST_TO_ADDR
// for i = 1 to array1 do
24893: LD_ADDR_VAR 0 4
24897: PUSH
24898: DOUBLE
24899: LD_INT 1
24901: DEC
24902: ST_TO_ADDR
24903: LD_VAR 0 1
24907: PUSH
24908: FOR_TO
24909: IFFALSE 24947
// if array1 [ i ] <> array2 [ i ] then
24911: LD_VAR 0 1
24915: PUSH
24916: LD_VAR 0 4
24920: ARRAY
24921: PUSH
24922: LD_VAR 0 2
24926: PUSH
24927: LD_VAR 0 4
24931: ARRAY
24932: NONEQUAL
24933: IFFALSE 24945
// begin result := false ;
24935: LD_ADDR_VAR 0 3
24939: PUSH
24940: LD_INT 0
24942: ST_TO_ADDR
// break ;
24943: GO 24947
// end ;
24945: GO 24908
24947: POP
24948: POP
// end ;
24949: LD_VAR 0 3
24953: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
24954: LD_INT 0
24956: PPUSH
24957: PPUSH
24958: PPUSH
// pom := GetBase ( fac ) ;
24959: LD_ADDR_VAR 0 5
24963: PUSH
24964: LD_VAR 0 1
24968: PPUSH
24969: CALL_OW 274
24973: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24974: LD_ADDR_VAR 0 4
24978: PUSH
24979: LD_VAR 0 2
24983: PUSH
24984: LD_INT 1
24986: ARRAY
24987: PPUSH
24988: LD_VAR 0 2
24992: PUSH
24993: LD_INT 2
24995: ARRAY
24996: PPUSH
24997: LD_VAR 0 2
25001: PUSH
25002: LD_INT 3
25004: ARRAY
25005: PPUSH
25006: LD_VAR 0 2
25010: PUSH
25011: LD_INT 4
25013: ARRAY
25014: PPUSH
25015: CALL_OW 449
25019: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25020: LD_ADDR_VAR 0 3
25024: PUSH
25025: LD_VAR 0 5
25029: PPUSH
25030: LD_INT 1
25032: PPUSH
25033: CALL_OW 275
25037: PUSH
25038: LD_VAR 0 4
25042: PUSH
25043: LD_INT 1
25045: ARRAY
25046: GREATEREQUAL
25047: PUSH
25048: LD_VAR 0 5
25052: PPUSH
25053: LD_INT 2
25055: PPUSH
25056: CALL_OW 275
25060: PUSH
25061: LD_VAR 0 4
25065: PUSH
25066: LD_INT 2
25068: ARRAY
25069: GREATEREQUAL
25070: AND
25071: PUSH
25072: LD_VAR 0 5
25076: PPUSH
25077: LD_INT 3
25079: PPUSH
25080: CALL_OW 275
25084: PUSH
25085: LD_VAR 0 4
25089: PUSH
25090: LD_INT 3
25092: ARRAY
25093: GREATEREQUAL
25094: AND
25095: ST_TO_ADDR
// end ;
25096: LD_VAR 0 3
25100: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25101: LD_INT 0
25103: PPUSH
25104: PPUSH
25105: PPUSH
25106: PPUSH
// pom := GetBase ( building ) ;
25107: LD_ADDR_VAR 0 3
25111: PUSH
25112: LD_VAR 0 1
25116: PPUSH
25117: CALL_OW 274
25121: ST_TO_ADDR
// if not pom then
25122: LD_VAR 0 3
25126: NOT
25127: IFFALSE 25131
// exit ;
25129: GO 25301
// btype := GetBType ( building ) ;
25131: LD_ADDR_VAR 0 5
25135: PUSH
25136: LD_VAR 0 1
25140: PPUSH
25141: CALL_OW 266
25145: ST_TO_ADDR
// if btype = b_armoury then
25146: LD_VAR 0 5
25150: PUSH
25151: LD_INT 4
25153: EQUAL
25154: IFFALSE 25164
// btype := b_barracks ;
25156: LD_ADDR_VAR 0 5
25160: PUSH
25161: LD_INT 5
25163: ST_TO_ADDR
// if btype = b_depot then
25164: LD_VAR 0 5
25168: PUSH
25169: LD_INT 0
25171: EQUAL
25172: IFFALSE 25182
// btype := b_warehouse ;
25174: LD_ADDR_VAR 0 5
25178: PUSH
25179: LD_INT 1
25181: ST_TO_ADDR
// if btype = b_workshop then
25182: LD_VAR 0 5
25186: PUSH
25187: LD_INT 2
25189: EQUAL
25190: IFFALSE 25200
// btype := b_factory ;
25192: LD_ADDR_VAR 0 5
25196: PUSH
25197: LD_INT 3
25199: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25200: LD_ADDR_VAR 0 4
25204: PUSH
25205: LD_VAR 0 5
25209: PPUSH
25210: LD_VAR 0 1
25214: PPUSH
25215: CALL_OW 248
25219: PPUSH
25220: CALL_OW 450
25224: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25225: LD_ADDR_VAR 0 2
25229: PUSH
25230: LD_VAR 0 3
25234: PPUSH
25235: LD_INT 1
25237: PPUSH
25238: CALL_OW 275
25242: PUSH
25243: LD_VAR 0 4
25247: PUSH
25248: LD_INT 1
25250: ARRAY
25251: GREATEREQUAL
25252: PUSH
25253: LD_VAR 0 3
25257: PPUSH
25258: LD_INT 2
25260: PPUSH
25261: CALL_OW 275
25265: PUSH
25266: LD_VAR 0 4
25270: PUSH
25271: LD_INT 2
25273: ARRAY
25274: GREATEREQUAL
25275: AND
25276: PUSH
25277: LD_VAR 0 3
25281: PPUSH
25282: LD_INT 3
25284: PPUSH
25285: CALL_OW 275
25289: PUSH
25290: LD_VAR 0 4
25294: PUSH
25295: LD_INT 3
25297: ARRAY
25298: GREATEREQUAL
25299: AND
25300: ST_TO_ADDR
// end ;
25301: LD_VAR 0 2
25305: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25306: LD_INT 0
25308: PPUSH
25309: PPUSH
25310: PPUSH
// pom := GetBase ( building ) ;
25311: LD_ADDR_VAR 0 4
25315: PUSH
25316: LD_VAR 0 1
25320: PPUSH
25321: CALL_OW 274
25325: ST_TO_ADDR
// if not pom then
25326: LD_VAR 0 4
25330: NOT
25331: IFFALSE 25335
// exit ;
25333: GO 25436
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25335: LD_ADDR_VAR 0 5
25339: PUSH
25340: LD_VAR 0 2
25344: PPUSH
25345: LD_VAR 0 1
25349: PPUSH
25350: CALL_OW 248
25354: PPUSH
25355: CALL_OW 450
25359: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25360: LD_ADDR_VAR 0 3
25364: PUSH
25365: LD_VAR 0 4
25369: PPUSH
25370: LD_INT 1
25372: PPUSH
25373: CALL_OW 275
25377: PUSH
25378: LD_VAR 0 5
25382: PUSH
25383: LD_INT 1
25385: ARRAY
25386: GREATEREQUAL
25387: PUSH
25388: LD_VAR 0 4
25392: PPUSH
25393: LD_INT 2
25395: PPUSH
25396: CALL_OW 275
25400: PUSH
25401: LD_VAR 0 5
25405: PUSH
25406: LD_INT 2
25408: ARRAY
25409: GREATEREQUAL
25410: AND
25411: PUSH
25412: LD_VAR 0 4
25416: PPUSH
25417: LD_INT 3
25419: PPUSH
25420: CALL_OW 275
25424: PUSH
25425: LD_VAR 0 5
25429: PUSH
25430: LD_INT 3
25432: ARRAY
25433: GREATEREQUAL
25434: AND
25435: ST_TO_ADDR
// end ;
25436: LD_VAR 0 3
25440: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
25441: LD_INT 0
25443: PPUSH
25444: PPUSH
25445: PPUSH
25446: PPUSH
25447: PPUSH
25448: PPUSH
25449: PPUSH
25450: PPUSH
25451: PPUSH
25452: PPUSH
25453: PPUSH
// result := false ;
25454: LD_ADDR_VAR 0 8
25458: PUSH
25459: LD_INT 0
25461: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
25462: LD_VAR 0 5
25466: NOT
25467: PUSH
25468: LD_VAR 0 1
25472: NOT
25473: OR
25474: PUSH
25475: LD_VAR 0 2
25479: NOT
25480: OR
25481: PUSH
25482: LD_VAR 0 3
25486: NOT
25487: OR
25488: IFFALSE 25492
// exit ;
25490: GO 26306
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
25492: LD_ADDR_VAR 0 14
25496: PUSH
25497: LD_VAR 0 1
25501: PPUSH
25502: LD_VAR 0 2
25506: PPUSH
25507: LD_VAR 0 3
25511: PPUSH
25512: LD_VAR 0 4
25516: PPUSH
25517: LD_VAR 0 5
25521: PUSH
25522: LD_INT 1
25524: ARRAY
25525: PPUSH
25526: CALL_OW 248
25530: PPUSH
25531: LD_INT 0
25533: PPUSH
25534: CALL 27543 0 6
25538: ST_TO_ADDR
// if not hexes then
25539: LD_VAR 0 14
25543: NOT
25544: IFFALSE 25548
// exit ;
25546: GO 26306
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25548: LD_ADDR_VAR 0 17
25552: PUSH
25553: LD_VAR 0 5
25557: PPUSH
25558: LD_INT 22
25560: PUSH
25561: LD_VAR 0 13
25565: PPUSH
25566: CALL_OW 255
25570: PUSH
25571: EMPTY
25572: LIST
25573: LIST
25574: PUSH
25575: LD_INT 2
25577: PUSH
25578: LD_INT 30
25580: PUSH
25581: LD_INT 0
25583: PUSH
25584: EMPTY
25585: LIST
25586: LIST
25587: PUSH
25588: LD_INT 30
25590: PUSH
25591: LD_INT 1
25593: PUSH
25594: EMPTY
25595: LIST
25596: LIST
25597: PUSH
25598: EMPTY
25599: LIST
25600: LIST
25601: LIST
25602: PUSH
25603: EMPTY
25604: LIST
25605: LIST
25606: PPUSH
25607: CALL_OW 72
25611: ST_TO_ADDR
// for i = 1 to hexes do
25612: LD_ADDR_VAR 0 9
25616: PUSH
25617: DOUBLE
25618: LD_INT 1
25620: DEC
25621: ST_TO_ADDR
25622: LD_VAR 0 14
25626: PUSH
25627: FOR_TO
25628: IFFALSE 26304
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25630: LD_ADDR_VAR 0 13
25634: PUSH
25635: LD_VAR 0 14
25639: PUSH
25640: LD_VAR 0 9
25644: ARRAY
25645: PUSH
25646: LD_INT 1
25648: ARRAY
25649: PPUSH
25650: LD_VAR 0 14
25654: PUSH
25655: LD_VAR 0 9
25659: ARRAY
25660: PUSH
25661: LD_INT 2
25663: ARRAY
25664: PPUSH
25665: CALL_OW 428
25669: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25670: LD_VAR 0 14
25674: PUSH
25675: LD_VAR 0 9
25679: ARRAY
25680: PUSH
25681: LD_INT 1
25683: ARRAY
25684: PPUSH
25685: LD_VAR 0 14
25689: PUSH
25690: LD_VAR 0 9
25694: ARRAY
25695: PUSH
25696: LD_INT 2
25698: ARRAY
25699: PPUSH
25700: CALL_OW 351
25704: PUSH
25705: LD_VAR 0 14
25709: PUSH
25710: LD_VAR 0 9
25714: ARRAY
25715: PUSH
25716: LD_INT 1
25718: ARRAY
25719: PPUSH
25720: LD_VAR 0 14
25724: PUSH
25725: LD_VAR 0 9
25729: ARRAY
25730: PUSH
25731: LD_INT 2
25733: ARRAY
25734: PPUSH
25735: CALL_OW 488
25739: NOT
25740: OR
25741: PUSH
25742: LD_VAR 0 13
25746: PPUSH
25747: CALL_OW 247
25751: PUSH
25752: LD_INT 3
25754: EQUAL
25755: OR
25756: IFFALSE 25762
// exit ;
25758: POP
25759: POP
25760: GO 26306
// if not tmp then
25762: LD_VAR 0 13
25766: NOT
25767: IFFALSE 25771
// continue ;
25769: GO 25627
// result := true ;
25771: LD_ADDR_VAR 0 8
25775: PUSH
25776: LD_INT 1
25778: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
25779: LD_VAR 0 6
25783: PUSH
25784: LD_VAR 0 13
25788: PPUSH
25789: CALL_OW 247
25793: PUSH
25794: LD_INT 2
25796: EQUAL
25797: AND
25798: PUSH
25799: LD_VAR 0 13
25803: PPUSH
25804: CALL_OW 263
25808: PUSH
25809: LD_INT 1
25811: EQUAL
25812: AND
25813: IFFALSE 25977
// begin if IsDrivenBy ( tmp ) then
25815: LD_VAR 0 13
25819: PPUSH
25820: CALL_OW 311
25824: IFFALSE 25828
// continue ;
25826: GO 25627
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
25828: LD_VAR 0 6
25832: PPUSH
25833: LD_INT 3
25835: PUSH
25836: LD_INT 60
25838: PUSH
25839: EMPTY
25840: LIST
25841: PUSH
25842: EMPTY
25843: LIST
25844: LIST
25845: PUSH
25846: LD_INT 3
25848: PUSH
25849: LD_INT 55
25851: PUSH
25852: EMPTY
25853: LIST
25854: PUSH
25855: EMPTY
25856: LIST
25857: LIST
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: PPUSH
25863: CALL_OW 72
25867: IFFALSE 25975
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
25869: LD_ADDR_VAR 0 18
25873: PUSH
25874: LD_VAR 0 6
25878: PPUSH
25879: LD_INT 3
25881: PUSH
25882: LD_INT 60
25884: PUSH
25885: EMPTY
25886: LIST
25887: PUSH
25888: EMPTY
25889: LIST
25890: LIST
25891: PUSH
25892: LD_INT 3
25894: PUSH
25895: LD_INT 55
25897: PUSH
25898: EMPTY
25899: LIST
25900: PUSH
25901: EMPTY
25902: LIST
25903: LIST
25904: PUSH
25905: EMPTY
25906: LIST
25907: LIST
25908: PPUSH
25909: CALL_OW 72
25913: PUSH
25914: LD_INT 1
25916: ARRAY
25917: ST_TO_ADDR
// if IsInUnit ( driver ) then
25918: LD_VAR 0 18
25922: PPUSH
25923: CALL_OW 310
25927: IFFALSE 25938
// ComExit ( driver ) ;
25929: LD_VAR 0 18
25933: PPUSH
25934: CALL 50727 0 1
// AddComEnterUnit ( driver , tmp ) ;
25938: LD_VAR 0 18
25942: PPUSH
25943: LD_VAR 0 13
25947: PPUSH
25948: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
25952: LD_VAR 0 18
25956: PPUSH
25957: LD_VAR 0 7
25961: PPUSH
25962: CALL_OW 173
// AddComExitVehicle ( driver ) ;
25966: LD_VAR 0 18
25970: PPUSH
25971: CALL_OW 181
// end ; continue ;
25975: GO 25627
// end ; if not cleaners or not tmp in cleaners then
25977: LD_VAR 0 6
25981: NOT
25982: PUSH
25983: LD_VAR 0 13
25987: PUSH
25988: LD_VAR 0 6
25992: IN
25993: NOT
25994: OR
25995: IFFALSE 26302
// begin if dep then
25997: LD_VAR 0 17
26001: IFFALSE 26137
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
26003: LD_ADDR_VAR 0 16
26007: PUSH
26008: LD_VAR 0 17
26012: PUSH
26013: LD_INT 1
26015: ARRAY
26016: PPUSH
26017: CALL_OW 250
26021: PPUSH
26022: LD_VAR 0 17
26026: PUSH
26027: LD_INT 1
26029: ARRAY
26030: PPUSH
26031: CALL_OW 254
26035: PPUSH
26036: LD_INT 5
26038: PPUSH
26039: CALL_OW 272
26043: PUSH
26044: LD_VAR 0 17
26048: PUSH
26049: LD_INT 1
26051: ARRAY
26052: PPUSH
26053: CALL_OW 251
26057: PPUSH
26058: LD_VAR 0 17
26062: PUSH
26063: LD_INT 1
26065: ARRAY
26066: PPUSH
26067: CALL_OW 254
26071: PPUSH
26072: LD_INT 5
26074: PPUSH
26075: CALL_OW 273
26079: PUSH
26080: EMPTY
26081: LIST
26082: LIST
26083: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26084: LD_VAR 0 16
26088: PUSH
26089: LD_INT 1
26091: ARRAY
26092: PPUSH
26093: LD_VAR 0 16
26097: PUSH
26098: LD_INT 2
26100: ARRAY
26101: PPUSH
26102: CALL_OW 488
26106: IFFALSE 26137
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26108: LD_VAR 0 13
26112: PPUSH
26113: LD_VAR 0 16
26117: PUSH
26118: LD_INT 1
26120: ARRAY
26121: PPUSH
26122: LD_VAR 0 16
26126: PUSH
26127: LD_INT 2
26129: ARRAY
26130: PPUSH
26131: CALL_OW 111
// continue ;
26135: GO 25627
// end ; end ; r := GetDir ( tmp ) ;
26137: LD_ADDR_VAR 0 15
26141: PUSH
26142: LD_VAR 0 13
26146: PPUSH
26147: CALL_OW 254
26151: ST_TO_ADDR
// if r = 5 then
26152: LD_VAR 0 15
26156: PUSH
26157: LD_INT 5
26159: EQUAL
26160: IFFALSE 26170
// r := 0 ;
26162: LD_ADDR_VAR 0 15
26166: PUSH
26167: LD_INT 0
26169: ST_TO_ADDR
// for j = r to 5 do
26170: LD_ADDR_VAR 0 10
26174: PUSH
26175: DOUBLE
26176: LD_VAR 0 15
26180: DEC
26181: ST_TO_ADDR
26182: LD_INT 5
26184: PUSH
26185: FOR_TO
26186: IFFALSE 26300
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26188: LD_ADDR_VAR 0 11
26192: PUSH
26193: LD_VAR 0 13
26197: PPUSH
26198: CALL_OW 250
26202: PPUSH
26203: LD_VAR 0 10
26207: PPUSH
26208: LD_INT 2
26210: PPUSH
26211: CALL_OW 272
26215: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26216: LD_ADDR_VAR 0 12
26220: PUSH
26221: LD_VAR 0 13
26225: PPUSH
26226: CALL_OW 251
26230: PPUSH
26231: LD_VAR 0 10
26235: PPUSH
26236: LD_INT 2
26238: PPUSH
26239: CALL_OW 273
26243: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26244: LD_VAR 0 11
26248: PPUSH
26249: LD_VAR 0 12
26253: PPUSH
26254: CALL_OW 488
26258: PUSH
26259: LD_VAR 0 11
26263: PPUSH
26264: LD_VAR 0 12
26268: PPUSH
26269: CALL_OW 428
26273: NOT
26274: AND
26275: IFFALSE 26298
// begin ComMoveXY ( tmp , _x , _y ) ;
26277: LD_VAR 0 13
26281: PPUSH
26282: LD_VAR 0 11
26286: PPUSH
26287: LD_VAR 0 12
26291: PPUSH
26292: CALL_OW 111
// break ;
26296: GO 26300
// end ; end ;
26298: GO 26185
26300: POP
26301: POP
// end ; end ;
26302: GO 25627
26304: POP
26305: POP
// end ;
26306: LD_VAR 0 8
26310: RET
// export function BuildingTechInvented ( side , btype ) ; begin
26311: LD_INT 0
26313: PPUSH
// result := true ;
26314: LD_ADDR_VAR 0 3
26318: PUSH
26319: LD_INT 1
26321: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
26322: LD_VAR 0 2
26326: PUSH
26327: LD_INT 24
26329: DOUBLE
26330: EQUAL
26331: IFTRUE 26341
26333: LD_INT 33
26335: DOUBLE
26336: EQUAL
26337: IFTRUE 26341
26339: GO 26366
26341: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
26342: LD_ADDR_VAR 0 3
26346: PUSH
26347: LD_INT 32
26349: PPUSH
26350: LD_VAR 0 1
26354: PPUSH
26355: CALL_OW 321
26359: PUSH
26360: LD_INT 2
26362: EQUAL
26363: ST_TO_ADDR
26364: GO 26686
26366: LD_INT 20
26368: DOUBLE
26369: EQUAL
26370: IFTRUE 26374
26372: GO 26399
26374: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
26375: LD_ADDR_VAR 0 3
26379: PUSH
26380: LD_INT 6
26382: PPUSH
26383: LD_VAR 0 1
26387: PPUSH
26388: CALL_OW 321
26392: PUSH
26393: LD_INT 2
26395: EQUAL
26396: ST_TO_ADDR
26397: GO 26686
26399: LD_INT 22
26401: DOUBLE
26402: EQUAL
26403: IFTRUE 26413
26405: LD_INT 36
26407: DOUBLE
26408: EQUAL
26409: IFTRUE 26413
26411: GO 26438
26413: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
26414: LD_ADDR_VAR 0 3
26418: PUSH
26419: LD_INT 15
26421: PPUSH
26422: LD_VAR 0 1
26426: PPUSH
26427: CALL_OW 321
26431: PUSH
26432: LD_INT 2
26434: EQUAL
26435: ST_TO_ADDR
26436: GO 26686
26438: LD_INT 30
26440: DOUBLE
26441: EQUAL
26442: IFTRUE 26446
26444: GO 26471
26446: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
26447: LD_ADDR_VAR 0 3
26451: PUSH
26452: LD_INT 20
26454: PPUSH
26455: LD_VAR 0 1
26459: PPUSH
26460: CALL_OW 321
26464: PUSH
26465: LD_INT 2
26467: EQUAL
26468: ST_TO_ADDR
26469: GO 26686
26471: LD_INT 28
26473: DOUBLE
26474: EQUAL
26475: IFTRUE 26485
26477: LD_INT 21
26479: DOUBLE
26480: EQUAL
26481: IFTRUE 26485
26483: GO 26510
26485: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
26486: LD_ADDR_VAR 0 3
26490: PUSH
26491: LD_INT 21
26493: PPUSH
26494: LD_VAR 0 1
26498: PPUSH
26499: CALL_OW 321
26503: PUSH
26504: LD_INT 2
26506: EQUAL
26507: ST_TO_ADDR
26508: GO 26686
26510: LD_INT 16
26512: DOUBLE
26513: EQUAL
26514: IFTRUE 26518
26516: GO 26545
26518: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
26519: LD_ADDR_VAR 0 3
26523: PUSH
26524: LD_EXP 60
26528: PPUSH
26529: LD_VAR 0 1
26533: PPUSH
26534: CALL_OW 321
26538: PUSH
26539: LD_INT 2
26541: EQUAL
26542: ST_TO_ADDR
26543: GO 26686
26545: LD_INT 19
26547: DOUBLE
26548: EQUAL
26549: IFTRUE 26559
26551: LD_INT 23
26553: DOUBLE
26554: EQUAL
26555: IFTRUE 26559
26557: GO 26586
26559: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
26560: LD_ADDR_VAR 0 3
26564: PUSH
26565: LD_EXP 59
26569: PPUSH
26570: LD_VAR 0 1
26574: PPUSH
26575: CALL_OW 321
26579: PUSH
26580: LD_INT 2
26582: EQUAL
26583: ST_TO_ADDR
26584: GO 26686
26586: LD_INT 17
26588: DOUBLE
26589: EQUAL
26590: IFTRUE 26594
26592: GO 26619
26594: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
26595: LD_ADDR_VAR 0 3
26599: PUSH
26600: LD_INT 39
26602: PPUSH
26603: LD_VAR 0 1
26607: PPUSH
26608: CALL_OW 321
26612: PUSH
26613: LD_INT 2
26615: EQUAL
26616: ST_TO_ADDR
26617: GO 26686
26619: LD_INT 18
26621: DOUBLE
26622: EQUAL
26623: IFTRUE 26627
26625: GO 26652
26627: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
26628: LD_ADDR_VAR 0 3
26632: PUSH
26633: LD_INT 40
26635: PPUSH
26636: LD_VAR 0 1
26640: PPUSH
26641: CALL_OW 321
26645: PUSH
26646: LD_INT 2
26648: EQUAL
26649: ST_TO_ADDR
26650: GO 26686
26652: LD_INT 27
26654: DOUBLE
26655: EQUAL
26656: IFTRUE 26660
26658: GO 26685
26660: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
26661: LD_ADDR_VAR 0 3
26665: PUSH
26666: LD_INT 35
26668: PPUSH
26669: LD_VAR 0 1
26673: PPUSH
26674: CALL_OW 321
26678: PUSH
26679: LD_INT 2
26681: EQUAL
26682: ST_TO_ADDR
26683: GO 26686
26685: POP
// end ;
26686: LD_VAR 0 3
26690: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
26691: LD_INT 0
26693: PPUSH
26694: PPUSH
26695: PPUSH
26696: PPUSH
26697: PPUSH
26698: PPUSH
26699: PPUSH
26700: PPUSH
26701: PPUSH
26702: PPUSH
26703: PPUSH
// result := false ;
26704: LD_ADDR_VAR 0 6
26708: PUSH
26709: LD_INT 0
26711: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26712: LD_VAR 0 1
26716: NOT
26717: PUSH
26718: LD_VAR 0 1
26722: PPUSH
26723: CALL_OW 266
26727: PUSH
26728: LD_INT 0
26730: PUSH
26731: LD_INT 1
26733: PUSH
26734: EMPTY
26735: LIST
26736: LIST
26737: IN
26738: NOT
26739: OR
26740: PUSH
26741: LD_VAR 0 2
26745: NOT
26746: OR
26747: PUSH
26748: LD_VAR 0 5
26752: PUSH
26753: LD_INT 0
26755: PUSH
26756: LD_INT 1
26758: PUSH
26759: LD_INT 2
26761: PUSH
26762: LD_INT 3
26764: PUSH
26765: LD_INT 4
26767: PUSH
26768: LD_INT 5
26770: PUSH
26771: EMPTY
26772: LIST
26773: LIST
26774: LIST
26775: LIST
26776: LIST
26777: LIST
26778: IN
26779: NOT
26780: OR
26781: PUSH
26782: LD_VAR 0 3
26786: PPUSH
26787: LD_VAR 0 4
26791: PPUSH
26792: CALL_OW 488
26796: NOT
26797: OR
26798: IFFALSE 26802
// exit ;
26800: GO 27538
// side := GetSide ( depot ) ;
26802: LD_ADDR_VAR 0 9
26806: PUSH
26807: LD_VAR 0 1
26811: PPUSH
26812: CALL_OW 255
26816: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
26817: LD_VAR 0 9
26821: PPUSH
26822: LD_VAR 0 2
26826: PPUSH
26827: CALL 26311 0 2
26831: NOT
26832: IFFALSE 26836
// exit ;
26834: GO 27538
// pom := GetBase ( depot ) ;
26836: LD_ADDR_VAR 0 10
26840: PUSH
26841: LD_VAR 0 1
26845: PPUSH
26846: CALL_OW 274
26850: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26851: LD_ADDR_VAR 0 11
26855: PUSH
26856: LD_VAR 0 2
26860: PPUSH
26861: LD_VAR 0 1
26865: PPUSH
26866: CALL_OW 248
26870: PPUSH
26871: CALL_OW 450
26875: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26876: LD_VAR 0 10
26880: PPUSH
26881: LD_INT 1
26883: PPUSH
26884: CALL_OW 275
26888: PUSH
26889: LD_VAR 0 11
26893: PUSH
26894: LD_INT 1
26896: ARRAY
26897: GREATEREQUAL
26898: PUSH
26899: LD_VAR 0 10
26903: PPUSH
26904: LD_INT 2
26906: PPUSH
26907: CALL_OW 275
26911: PUSH
26912: LD_VAR 0 11
26916: PUSH
26917: LD_INT 2
26919: ARRAY
26920: GREATEREQUAL
26921: AND
26922: PUSH
26923: LD_VAR 0 10
26927: PPUSH
26928: LD_INT 3
26930: PPUSH
26931: CALL_OW 275
26935: PUSH
26936: LD_VAR 0 11
26940: PUSH
26941: LD_INT 3
26943: ARRAY
26944: GREATEREQUAL
26945: AND
26946: NOT
26947: IFFALSE 26951
// exit ;
26949: GO 27538
// if GetBType ( depot ) = b_depot then
26951: LD_VAR 0 1
26955: PPUSH
26956: CALL_OW 266
26960: PUSH
26961: LD_INT 0
26963: EQUAL
26964: IFFALSE 26976
// dist := 28 else
26966: LD_ADDR_VAR 0 14
26970: PUSH
26971: LD_INT 28
26973: ST_TO_ADDR
26974: GO 26984
// dist := 36 ;
26976: LD_ADDR_VAR 0 14
26980: PUSH
26981: LD_INT 36
26983: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26984: LD_VAR 0 1
26988: PPUSH
26989: LD_VAR 0 3
26993: PPUSH
26994: LD_VAR 0 4
26998: PPUSH
26999: CALL_OW 297
27003: PUSH
27004: LD_VAR 0 14
27008: GREATER
27009: IFFALSE 27013
// exit ;
27011: GO 27538
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
27013: LD_ADDR_VAR 0 12
27017: PUSH
27018: LD_VAR 0 2
27022: PPUSH
27023: LD_VAR 0 3
27027: PPUSH
27028: LD_VAR 0 4
27032: PPUSH
27033: LD_VAR 0 5
27037: PPUSH
27038: LD_VAR 0 1
27042: PPUSH
27043: CALL_OW 248
27047: PPUSH
27048: LD_INT 0
27050: PPUSH
27051: CALL 27543 0 6
27055: ST_TO_ADDR
// if not hexes then
27056: LD_VAR 0 12
27060: NOT
27061: IFFALSE 27065
// exit ;
27063: GO 27538
// hex := GetHexInfo ( x , y ) ;
27065: LD_ADDR_VAR 0 15
27069: PUSH
27070: LD_VAR 0 3
27074: PPUSH
27075: LD_VAR 0 4
27079: PPUSH
27080: CALL_OW 546
27084: ST_TO_ADDR
// if hex [ 1 ] then
27085: LD_VAR 0 15
27089: PUSH
27090: LD_INT 1
27092: ARRAY
27093: IFFALSE 27097
// exit ;
27095: GO 27538
// height := hex [ 2 ] ;
27097: LD_ADDR_VAR 0 13
27101: PUSH
27102: LD_VAR 0 15
27106: PUSH
27107: LD_INT 2
27109: ARRAY
27110: ST_TO_ADDR
// for i = 1 to hexes do
27111: LD_ADDR_VAR 0 7
27115: PUSH
27116: DOUBLE
27117: LD_INT 1
27119: DEC
27120: ST_TO_ADDR
27121: LD_VAR 0 12
27125: PUSH
27126: FOR_TO
27127: IFFALSE 27457
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27129: LD_VAR 0 12
27133: PUSH
27134: LD_VAR 0 7
27138: ARRAY
27139: PUSH
27140: LD_INT 1
27142: ARRAY
27143: PPUSH
27144: LD_VAR 0 12
27148: PUSH
27149: LD_VAR 0 7
27153: ARRAY
27154: PUSH
27155: LD_INT 2
27157: ARRAY
27158: PPUSH
27159: CALL_OW 488
27163: NOT
27164: PUSH
27165: LD_VAR 0 12
27169: PUSH
27170: LD_VAR 0 7
27174: ARRAY
27175: PUSH
27176: LD_INT 1
27178: ARRAY
27179: PPUSH
27180: LD_VAR 0 12
27184: PUSH
27185: LD_VAR 0 7
27189: ARRAY
27190: PUSH
27191: LD_INT 2
27193: ARRAY
27194: PPUSH
27195: CALL_OW 428
27199: PUSH
27200: LD_INT 0
27202: GREATER
27203: OR
27204: PUSH
27205: LD_VAR 0 12
27209: PUSH
27210: LD_VAR 0 7
27214: ARRAY
27215: PUSH
27216: LD_INT 1
27218: ARRAY
27219: PPUSH
27220: LD_VAR 0 12
27224: PUSH
27225: LD_VAR 0 7
27229: ARRAY
27230: PUSH
27231: LD_INT 2
27233: ARRAY
27234: PPUSH
27235: CALL_OW 351
27239: OR
27240: IFFALSE 27246
// exit ;
27242: POP
27243: POP
27244: GO 27538
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27246: LD_ADDR_VAR 0 8
27250: PUSH
27251: LD_VAR 0 12
27255: PUSH
27256: LD_VAR 0 7
27260: ARRAY
27261: PUSH
27262: LD_INT 1
27264: ARRAY
27265: PPUSH
27266: LD_VAR 0 12
27270: PUSH
27271: LD_VAR 0 7
27275: ARRAY
27276: PUSH
27277: LD_INT 2
27279: ARRAY
27280: PPUSH
27281: CALL_OW 546
27285: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27286: LD_VAR 0 8
27290: PUSH
27291: LD_INT 1
27293: ARRAY
27294: PUSH
27295: LD_VAR 0 8
27299: PUSH
27300: LD_INT 2
27302: ARRAY
27303: PUSH
27304: LD_VAR 0 13
27308: PUSH
27309: LD_INT 2
27311: PLUS
27312: GREATER
27313: OR
27314: PUSH
27315: LD_VAR 0 8
27319: PUSH
27320: LD_INT 2
27322: ARRAY
27323: PUSH
27324: LD_VAR 0 13
27328: PUSH
27329: LD_INT 2
27331: MINUS
27332: LESS
27333: OR
27334: PUSH
27335: LD_VAR 0 8
27339: PUSH
27340: LD_INT 3
27342: ARRAY
27343: PUSH
27344: LD_INT 0
27346: PUSH
27347: LD_INT 8
27349: PUSH
27350: LD_INT 9
27352: PUSH
27353: LD_INT 10
27355: PUSH
27356: LD_INT 11
27358: PUSH
27359: LD_INT 12
27361: PUSH
27362: LD_INT 13
27364: PUSH
27365: LD_INT 16
27367: PUSH
27368: LD_INT 17
27370: PUSH
27371: LD_INT 18
27373: PUSH
27374: LD_INT 19
27376: PUSH
27377: LD_INT 20
27379: PUSH
27380: LD_INT 21
27382: PUSH
27383: EMPTY
27384: LIST
27385: LIST
27386: LIST
27387: LIST
27388: LIST
27389: LIST
27390: LIST
27391: LIST
27392: LIST
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: IN
27398: NOT
27399: OR
27400: PUSH
27401: LD_VAR 0 8
27405: PUSH
27406: LD_INT 5
27408: ARRAY
27409: NOT
27410: OR
27411: PUSH
27412: LD_VAR 0 8
27416: PUSH
27417: LD_INT 6
27419: ARRAY
27420: PUSH
27421: LD_INT 1
27423: PUSH
27424: LD_INT 2
27426: PUSH
27427: LD_INT 7
27429: PUSH
27430: LD_INT 9
27432: PUSH
27433: LD_INT 10
27435: PUSH
27436: LD_INT 11
27438: PUSH
27439: EMPTY
27440: LIST
27441: LIST
27442: LIST
27443: LIST
27444: LIST
27445: LIST
27446: IN
27447: NOT
27448: OR
27449: IFFALSE 27455
// exit ;
27451: POP
27452: POP
27453: GO 27538
// end ;
27455: GO 27126
27457: POP
27458: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27459: LD_VAR 0 9
27463: PPUSH
27464: LD_VAR 0 3
27468: PPUSH
27469: LD_VAR 0 4
27473: PPUSH
27474: LD_INT 20
27476: PPUSH
27477: CALL 19484 0 4
27481: PUSH
27482: LD_INT 4
27484: ARRAY
27485: IFFALSE 27489
// exit ;
27487: GO 27538
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27489: LD_VAR 0 2
27493: PUSH
27494: LD_INT 29
27496: PUSH
27497: LD_INT 30
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: IN
27504: PUSH
27505: LD_VAR 0 3
27509: PPUSH
27510: LD_VAR 0 4
27514: PPUSH
27515: LD_VAR 0 9
27519: PPUSH
27520: CALL_OW 440
27524: NOT
27525: AND
27526: IFFALSE 27530
// exit ;
27528: GO 27538
// result := true ;
27530: LD_ADDR_VAR 0 6
27534: PUSH
27535: LD_INT 1
27537: ST_TO_ADDR
// end ;
27538: LD_VAR 0 6
27542: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
27543: LD_INT 0
27545: PPUSH
27546: PPUSH
27547: PPUSH
27548: PPUSH
27549: PPUSH
27550: PPUSH
27551: PPUSH
27552: PPUSH
27553: PPUSH
27554: PPUSH
27555: PPUSH
27556: PPUSH
27557: PPUSH
27558: PPUSH
27559: PPUSH
27560: PPUSH
27561: PPUSH
27562: PPUSH
27563: PPUSH
27564: PPUSH
27565: PPUSH
27566: PPUSH
27567: PPUSH
27568: PPUSH
27569: PPUSH
27570: PPUSH
27571: PPUSH
27572: PPUSH
27573: PPUSH
27574: PPUSH
27575: PPUSH
27576: PPUSH
27577: PPUSH
27578: PPUSH
27579: PPUSH
27580: PPUSH
27581: PPUSH
27582: PPUSH
27583: PPUSH
27584: PPUSH
27585: PPUSH
27586: PPUSH
27587: PPUSH
27588: PPUSH
27589: PPUSH
27590: PPUSH
27591: PPUSH
27592: PPUSH
27593: PPUSH
27594: PPUSH
27595: PPUSH
27596: PPUSH
27597: PPUSH
27598: PPUSH
27599: PPUSH
27600: PPUSH
27601: PPUSH
27602: PPUSH
// result = [ ] ;
27603: LD_ADDR_VAR 0 7
27607: PUSH
27608: EMPTY
27609: ST_TO_ADDR
// temp_list = [ ] ;
27610: LD_ADDR_VAR 0 9
27614: PUSH
27615: EMPTY
27616: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27617: LD_VAR 0 4
27621: PUSH
27622: LD_INT 0
27624: PUSH
27625: LD_INT 1
27627: PUSH
27628: LD_INT 2
27630: PUSH
27631: LD_INT 3
27633: PUSH
27634: LD_INT 4
27636: PUSH
27637: LD_INT 5
27639: PUSH
27640: EMPTY
27641: LIST
27642: LIST
27643: LIST
27644: LIST
27645: LIST
27646: LIST
27647: IN
27648: NOT
27649: PUSH
27650: LD_VAR 0 1
27654: PUSH
27655: LD_INT 0
27657: PUSH
27658: LD_INT 1
27660: PUSH
27661: EMPTY
27662: LIST
27663: LIST
27664: IN
27665: PUSH
27666: LD_VAR 0 5
27670: PUSH
27671: LD_INT 1
27673: PUSH
27674: LD_INT 2
27676: PUSH
27677: LD_INT 3
27679: PUSH
27680: EMPTY
27681: LIST
27682: LIST
27683: LIST
27684: IN
27685: NOT
27686: AND
27687: OR
27688: IFFALSE 27692
// exit ;
27690: GO 46083
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27692: LD_VAR 0 1
27696: PUSH
27697: LD_INT 6
27699: PUSH
27700: LD_INT 7
27702: PUSH
27703: LD_INT 8
27705: PUSH
27706: LD_INT 13
27708: PUSH
27709: LD_INT 12
27711: PUSH
27712: LD_INT 15
27714: PUSH
27715: LD_INT 11
27717: PUSH
27718: LD_INT 14
27720: PUSH
27721: LD_INT 10
27723: PUSH
27724: EMPTY
27725: LIST
27726: LIST
27727: LIST
27728: LIST
27729: LIST
27730: LIST
27731: LIST
27732: LIST
27733: LIST
27734: IN
27735: IFFALSE 27745
// btype = b_lab ;
27737: LD_ADDR_VAR 0 1
27741: PUSH
27742: LD_INT 6
27744: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27745: LD_VAR 0 6
27749: PUSH
27750: LD_INT 0
27752: PUSH
27753: LD_INT 1
27755: PUSH
27756: LD_INT 2
27758: PUSH
27759: EMPTY
27760: LIST
27761: LIST
27762: LIST
27763: IN
27764: NOT
27765: PUSH
27766: LD_VAR 0 1
27770: PUSH
27771: LD_INT 0
27773: PUSH
27774: LD_INT 1
27776: PUSH
27777: LD_INT 2
27779: PUSH
27780: LD_INT 3
27782: PUSH
27783: LD_INT 6
27785: PUSH
27786: LD_INT 36
27788: PUSH
27789: LD_INT 4
27791: PUSH
27792: LD_INT 5
27794: PUSH
27795: LD_INT 31
27797: PUSH
27798: LD_INT 32
27800: PUSH
27801: LD_INT 33
27803: PUSH
27804: EMPTY
27805: LIST
27806: LIST
27807: LIST
27808: LIST
27809: LIST
27810: LIST
27811: LIST
27812: LIST
27813: LIST
27814: LIST
27815: LIST
27816: IN
27817: NOT
27818: PUSH
27819: LD_VAR 0 6
27823: PUSH
27824: LD_INT 1
27826: EQUAL
27827: AND
27828: OR
27829: PUSH
27830: LD_VAR 0 1
27834: PUSH
27835: LD_INT 2
27837: PUSH
27838: LD_INT 3
27840: PUSH
27841: EMPTY
27842: LIST
27843: LIST
27844: IN
27845: NOT
27846: PUSH
27847: LD_VAR 0 6
27851: PUSH
27852: LD_INT 2
27854: EQUAL
27855: AND
27856: OR
27857: IFFALSE 27867
// mode = 0 ;
27859: LD_ADDR_VAR 0 6
27863: PUSH
27864: LD_INT 0
27866: ST_TO_ADDR
// case mode of 0 :
27867: LD_VAR 0 6
27871: PUSH
27872: LD_INT 0
27874: DOUBLE
27875: EQUAL
27876: IFTRUE 27880
27878: GO 39333
27880: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27881: LD_ADDR_VAR 0 11
27885: PUSH
27886: LD_INT 0
27888: PUSH
27889: LD_INT 0
27891: PUSH
27892: EMPTY
27893: LIST
27894: LIST
27895: PUSH
27896: LD_INT 0
27898: PUSH
27899: LD_INT 1
27901: NEG
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: PUSH
27907: LD_INT 1
27909: PUSH
27910: LD_INT 0
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PUSH
27917: LD_INT 1
27919: PUSH
27920: LD_INT 1
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PUSH
27927: LD_INT 0
27929: PUSH
27930: LD_INT 1
27932: PUSH
27933: EMPTY
27934: LIST
27935: LIST
27936: PUSH
27937: LD_INT 1
27939: NEG
27940: PUSH
27941: LD_INT 0
27943: PUSH
27944: EMPTY
27945: LIST
27946: LIST
27947: PUSH
27948: LD_INT 1
27950: NEG
27951: PUSH
27952: LD_INT 1
27954: NEG
27955: PUSH
27956: EMPTY
27957: LIST
27958: LIST
27959: PUSH
27960: LD_INT 1
27962: NEG
27963: PUSH
27964: LD_INT 2
27966: NEG
27967: PUSH
27968: EMPTY
27969: LIST
27970: LIST
27971: PUSH
27972: LD_INT 0
27974: PUSH
27975: LD_INT 2
27977: NEG
27978: PUSH
27979: EMPTY
27980: LIST
27981: LIST
27982: PUSH
27983: LD_INT 1
27985: PUSH
27986: LD_INT 1
27988: NEG
27989: PUSH
27990: EMPTY
27991: LIST
27992: LIST
27993: PUSH
27994: LD_INT 1
27996: PUSH
27997: LD_INT 2
27999: PUSH
28000: EMPTY
28001: LIST
28002: LIST
28003: PUSH
28004: LD_INT 0
28006: PUSH
28007: LD_INT 2
28009: PUSH
28010: EMPTY
28011: LIST
28012: LIST
28013: PUSH
28014: LD_INT 1
28016: NEG
28017: PUSH
28018: LD_INT 1
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: PUSH
28025: LD_INT 1
28027: PUSH
28028: LD_INT 3
28030: PUSH
28031: EMPTY
28032: LIST
28033: LIST
28034: PUSH
28035: LD_INT 0
28037: PUSH
28038: LD_INT 3
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: PUSH
28045: LD_INT 1
28047: NEG
28048: PUSH
28049: LD_INT 2
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: LIST
28060: LIST
28061: LIST
28062: LIST
28063: LIST
28064: LIST
28065: LIST
28066: LIST
28067: LIST
28068: LIST
28069: LIST
28070: LIST
28071: LIST
28072: LIST
28073: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28074: LD_ADDR_VAR 0 12
28078: PUSH
28079: LD_INT 0
28081: PUSH
28082: LD_INT 0
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: PUSH
28089: LD_INT 0
28091: PUSH
28092: LD_INT 1
28094: NEG
28095: PUSH
28096: EMPTY
28097: LIST
28098: LIST
28099: PUSH
28100: LD_INT 1
28102: PUSH
28103: LD_INT 0
28105: PUSH
28106: EMPTY
28107: LIST
28108: LIST
28109: PUSH
28110: LD_INT 1
28112: PUSH
28113: LD_INT 1
28115: PUSH
28116: EMPTY
28117: LIST
28118: LIST
28119: PUSH
28120: LD_INT 0
28122: PUSH
28123: LD_INT 1
28125: PUSH
28126: EMPTY
28127: LIST
28128: LIST
28129: PUSH
28130: LD_INT 1
28132: NEG
28133: PUSH
28134: LD_INT 0
28136: PUSH
28137: EMPTY
28138: LIST
28139: LIST
28140: PUSH
28141: LD_INT 1
28143: NEG
28144: PUSH
28145: LD_INT 1
28147: NEG
28148: PUSH
28149: EMPTY
28150: LIST
28151: LIST
28152: PUSH
28153: LD_INT 1
28155: PUSH
28156: LD_INT 1
28158: NEG
28159: PUSH
28160: EMPTY
28161: LIST
28162: LIST
28163: PUSH
28164: LD_INT 2
28166: PUSH
28167: LD_INT 0
28169: PUSH
28170: EMPTY
28171: LIST
28172: LIST
28173: PUSH
28174: LD_INT 2
28176: PUSH
28177: LD_INT 1
28179: PUSH
28180: EMPTY
28181: LIST
28182: LIST
28183: PUSH
28184: LD_INT 1
28186: NEG
28187: PUSH
28188: LD_INT 1
28190: PUSH
28191: EMPTY
28192: LIST
28193: LIST
28194: PUSH
28195: LD_INT 2
28197: NEG
28198: PUSH
28199: LD_INT 0
28201: PUSH
28202: EMPTY
28203: LIST
28204: LIST
28205: PUSH
28206: LD_INT 2
28208: NEG
28209: PUSH
28210: LD_INT 1
28212: NEG
28213: PUSH
28214: EMPTY
28215: LIST
28216: LIST
28217: PUSH
28218: LD_INT 2
28220: NEG
28221: PUSH
28222: LD_INT 1
28224: PUSH
28225: EMPTY
28226: LIST
28227: LIST
28228: PUSH
28229: LD_INT 3
28231: NEG
28232: PUSH
28233: LD_INT 0
28235: PUSH
28236: EMPTY
28237: LIST
28238: LIST
28239: PUSH
28240: LD_INT 3
28242: NEG
28243: PUSH
28244: LD_INT 1
28246: NEG
28247: PUSH
28248: EMPTY
28249: LIST
28250: LIST
28251: PUSH
28252: EMPTY
28253: LIST
28254: LIST
28255: LIST
28256: LIST
28257: LIST
28258: LIST
28259: LIST
28260: LIST
28261: LIST
28262: LIST
28263: LIST
28264: LIST
28265: LIST
28266: LIST
28267: LIST
28268: LIST
28269: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28270: LD_ADDR_VAR 0 13
28274: PUSH
28275: LD_INT 0
28277: PUSH
28278: LD_INT 0
28280: PUSH
28281: EMPTY
28282: LIST
28283: LIST
28284: PUSH
28285: LD_INT 0
28287: PUSH
28288: LD_INT 1
28290: NEG
28291: PUSH
28292: EMPTY
28293: LIST
28294: LIST
28295: PUSH
28296: LD_INT 1
28298: PUSH
28299: LD_INT 0
28301: PUSH
28302: EMPTY
28303: LIST
28304: LIST
28305: PUSH
28306: LD_INT 1
28308: PUSH
28309: LD_INT 1
28311: PUSH
28312: EMPTY
28313: LIST
28314: LIST
28315: PUSH
28316: LD_INT 0
28318: PUSH
28319: LD_INT 1
28321: PUSH
28322: EMPTY
28323: LIST
28324: LIST
28325: PUSH
28326: LD_INT 1
28328: NEG
28329: PUSH
28330: LD_INT 0
28332: PUSH
28333: EMPTY
28334: LIST
28335: LIST
28336: PUSH
28337: LD_INT 1
28339: NEG
28340: PUSH
28341: LD_INT 1
28343: NEG
28344: PUSH
28345: EMPTY
28346: LIST
28347: LIST
28348: PUSH
28349: LD_INT 1
28351: NEG
28352: PUSH
28353: LD_INT 2
28355: NEG
28356: PUSH
28357: EMPTY
28358: LIST
28359: LIST
28360: PUSH
28361: LD_INT 2
28363: PUSH
28364: LD_INT 1
28366: PUSH
28367: EMPTY
28368: LIST
28369: LIST
28370: PUSH
28371: LD_INT 2
28373: PUSH
28374: LD_INT 2
28376: PUSH
28377: EMPTY
28378: LIST
28379: LIST
28380: PUSH
28381: LD_INT 1
28383: PUSH
28384: LD_INT 2
28386: PUSH
28387: EMPTY
28388: LIST
28389: LIST
28390: PUSH
28391: LD_INT 2
28393: NEG
28394: PUSH
28395: LD_INT 1
28397: NEG
28398: PUSH
28399: EMPTY
28400: LIST
28401: LIST
28402: PUSH
28403: LD_INT 2
28405: NEG
28406: PUSH
28407: LD_INT 2
28409: NEG
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 2
28417: NEG
28418: PUSH
28419: LD_INT 3
28421: NEG
28422: PUSH
28423: EMPTY
28424: LIST
28425: LIST
28426: PUSH
28427: LD_INT 3
28429: NEG
28430: PUSH
28431: LD_INT 2
28433: NEG
28434: PUSH
28435: EMPTY
28436: LIST
28437: LIST
28438: PUSH
28439: LD_INT 3
28441: NEG
28442: PUSH
28443: LD_INT 3
28445: NEG
28446: PUSH
28447: EMPTY
28448: LIST
28449: LIST
28450: PUSH
28451: EMPTY
28452: LIST
28453: LIST
28454: LIST
28455: LIST
28456: LIST
28457: LIST
28458: LIST
28459: LIST
28460: LIST
28461: LIST
28462: LIST
28463: LIST
28464: LIST
28465: LIST
28466: LIST
28467: LIST
28468: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28469: LD_ADDR_VAR 0 14
28473: PUSH
28474: LD_INT 0
28476: PUSH
28477: LD_INT 0
28479: PUSH
28480: EMPTY
28481: LIST
28482: LIST
28483: PUSH
28484: LD_INT 0
28486: PUSH
28487: LD_INT 1
28489: NEG
28490: PUSH
28491: EMPTY
28492: LIST
28493: LIST
28494: PUSH
28495: LD_INT 1
28497: PUSH
28498: LD_INT 0
28500: PUSH
28501: EMPTY
28502: LIST
28503: LIST
28504: PUSH
28505: LD_INT 1
28507: PUSH
28508: LD_INT 1
28510: PUSH
28511: EMPTY
28512: LIST
28513: LIST
28514: PUSH
28515: LD_INT 0
28517: PUSH
28518: LD_INT 1
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PUSH
28525: LD_INT 1
28527: NEG
28528: PUSH
28529: LD_INT 0
28531: PUSH
28532: EMPTY
28533: LIST
28534: LIST
28535: PUSH
28536: LD_INT 1
28538: NEG
28539: PUSH
28540: LD_INT 1
28542: NEG
28543: PUSH
28544: EMPTY
28545: LIST
28546: LIST
28547: PUSH
28548: LD_INT 1
28550: NEG
28551: PUSH
28552: LD_INT 2
28554: NEG
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: PUSH
28560: LD_INT 0
28562: PUSH
28563: LD_INT 2
28565: NEG
28566: PUSH
28567: EMPTY
28568: LIST
28569: LIST
28570: PUSH
28571: LD_INT 1
28573: PUSH
28574: LD_INT 1
28576: NEG
28577: PUSH
28578: EMPTY
28579: LIST
28580: LIST
28581: PUSH
28582: LD_INT 1
28584: PUSH
28585: LD_INT 2
28587: PUSH
28588: EMPTY
28589: LIST
28590: LIST
28591: PUSH
28592: LD_INT 0
28594: PUSH
28595: LD_INT 2
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: PUSH
28602: LD_INT 1
28604: NEG
28605: PUSH
28606: LD_INT 1
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: PUSH
28613: LD_INT 1
28615: NEG
28616: PUSH
28617: LD_INT 3
28619: NEG
28620: PUSH
28621: EMPTY
28622: LIST
28623: LIST
28624: PUSH
28625: LD_INT 0
28627: PUSH
28628: LD_INT 3
28630: NEG
28631: PUSH
28632: EMPTY
28633: LIST
28634: LIST
28635: PUSH
28636: LD_INT 1
28638: PUSH
28639: LD_INT 2
28641: NEG
28642: PUSH
28643: EMPTY
28644: LIST
28645: LIST
28646: PUSH
28647: EMPTY
28648: LIST
28649: LIST
28650: LIST
28651: LIST
28652: LIST
28653: LIST
28654: LIST
28655: LIST
28656: LIST
28657: LIST
28658: LIST
28659: LIST
28660: LIST
28661: LIST
28662: LIST
28663: LIST
28664: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28665: LD_ADDR_VAR 0 15
28669: PUSH
28670: LD_INT 0
28672: PUSH
28673: LD_INT 0
28675: PUSH
28676: EMPTY
28677: LIST
28678: LIST
28679: PUSH
28680: LD_INT 0
28682: PUSH
28683: LD_INT 1
28685: NEG
28686: PUSH
28687: EMPTY
28688: LIST
28689: LIST
28690: PUSH
28691: LD_INT 1
28693: PUSH
28694: LD_INT 0
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: LD_INT 1
28703: PUSH
28704: LD_INT 1
28706: PUSH
28707: EMPTY
28708: LIST
28709: LIST
28710: PUSH
28711: LD_INT 0
28713: PUSH
28714: LD_INT 1
28716: PUSH
28717: EMPTY
28718: LIST
28719: LIST
28720: PUSH
28721: LD_INT 1
28723: NEG
28724: PUSH
28725: LD_INT 0
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: LD_INT 1
28734: NEG
28735: PUSH
28736: LD_INT 1
28738: NEG
28739: PUSH
28740: EMPTY
28741: LIST
28742: LIST
28743: PUSH
28744: LD_INT 1
28746: PUSH
28747: LD_INT 1
28749: NEG
28750: PUSH
28751: EMPTY
28752: LIST
28753: LIST
28754: PUSH
28755: LD_INT 2
28757: PUSH
28758: LD_INT 0
28760: PUSH
28761: EMPTY
28762: LIST
28763: LIST
28764: PUSH
28765: LD_INT 2
28767: PUSH
28768: LD_INT 1
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: PUSH
28775: LD_INT 1
28777: NEG
28778: PUSH
28779: LD_INT 1
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 2
28788: NEG
28789: PUSH
28790: LD_INT 0
28792: PUSH
28793: EMPTY
28794: LIST
28795: LIST
28796: PUSH
28797: LD_INT 2
28799: NEG
28800: PUSH
28801: LD_INT 1
28803: NEG
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 2
28811: PUSH
28812: LD_INT 1
28814: NEG
28815: PUSH
28816: EMPTY
28817: LIST
28818: LIST
28819: PUSH
28820: LD_INT 3
28822: PUSH
28823: LD_INT 0
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: PUSH
28830: LD_INT 3
28832: PUSH
28833: LD_INT 1
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: EMPTY
28841: LIST
28842: LIST
28843: LIST
28844: LIST
28845: LIST
28846: LIST
28847: LIST
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28858: LD_ADDR_VAR 0 16
28862: PUSH
28863: LD_INT 0
28865: PUSH
28866: LD_INT 0
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PUSH
28873: LD_INT 0
28875: PUSH
28876: LD_INT 1
28878: NEG
28879: PUSH
28880: EMPTY
28881: LIST
28882: LIST
28883: PUSH
28884: LD_INT 1
28886: PUSH
28887: LD_INT 0
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PUSH
28894: LD_INT 1
28896: PUSH
28897: LD_INT 1
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: LD_INT 0
28906: PUSH
28907: LD_INT 1
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: LD_INT 1
28916: NEG
28917: PUSH
28918: LD_INT 0
28920: PUSH
28921: EMPTY
28922: LIST
28923: LIST
28924: PUSH
28925: LD_INT 1
28927: NEG
28928: PUSH
28929: LD_INT 1
28931: NEG
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: LD_INT 1
28939: NEG
28940: PUSH
28941: LD_INT 2
28943: NEG
28944: PUSH
28945: EMPTY
28946: LIST
28947: LIST
28948: PUSH
28949: LD_INT 2
28951: PUSH
28952: LD_INT 1
28954: PUSH
28955: EMPTY
28956: LIST
28957: LIST
28958: PUSH
28959: LD_INT 2
28961: PUSH
28962: LD_INT 2
28964: PUSH
28965: EMPTY
28966: LIST
28967: LIST
28968: PUSH
28969: LD_INT 1
28971: PUSH
28972: LD_INT 2
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: PUSH
28979: LD_INT 2
28981: NEG
28982: PUSH
28983: LD_INT 1
28985: NEG
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: PUSH
28991: LD_INT 2
28993: NEG
28994: PUSH
28995: LD_INT 2
28997: NEG
28998: PUSH
28999: EMPTY
29000: LIST
29001: LIST
29002: PUSH
29003: LD_INT 3
29005: PUSH
29006: LD_INT 2
29008: PUSH
29009: EMPTY
29010: LIST
29011: LIST
29012: PUSH
29013: LD_INT 3
29015: PUSH
29016: LD_INT 3
29018: PUSH
29019: EMPTY
29020: LIST
29021: LIST
29022: PUSH
29023: LD_INT 2
29025: PUSH
29026: LD_INT 3
29028: PUSH
29029: EMPTY
29030: LIST
29031: LIST
29032: PUSH
29033: EMPTY
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: LIST
29050: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29051: LD_ADDR_VAR 0 17
29055: PUSH
29056: LD_INT 0
29058: PUSH
29059: LD_INT 0
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 0
29068: PUSH
29069: LD_INT 1
29071: NEG
29072: PUSH
29073: EMPTY
29074: LIST
29075: LIST
29076: PUSH
29077: LD_INT 1
29079: PUSH
29080: LD_INT 0
29082: PUSH
29083: EMPTY
29084: LIST
29085: LIST
29086: PUSH
29087: LD_INT 1
29089: PUSH
29090: LD_INT 1
29092: PUSH
29093: EMPTY
29094: LIST
29095: LIST
29096: PUSH
29097: LD_INT 0
29099: PUSH
29100: LD_INT 1
29102: PUSH
29103: EMPTY
29104: LIST
29105: LIST
29106: PUSH
29107: LD_INT 1
29109: NEG
29110: PUSH
29111: LD_INT 0
29113: PUSH
29114: EMPTY
29115: LIST
29116: LIST
29117: PUSH
29118: LD_INT 1
29120: NEG
29121: PUSH
29122: LD_INT 1
29124: NEG
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 1
29132: NEG
29133: PUSH
29134: LD_INT 2
29136: NEG
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: PUSH
29142: LD_INT 0
29144: PUSH
29145: LD_INT 2
29147: NEG
29148: PUSH
29149: EMPTY
29150: LIST
29151: LIST
29152: PUSH
29153: LD_INT 1
29155: PUSH
29156: LD_INT 1
29158: NEG
29159: PUSH
29160: EMPTY
29161: LIST
29162: LIST
29163: PUSH
29164: LD_INT 2
29166: PUSH
29167: LD_INT 0
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: LD_INT 2
29176: PUSH
29177: LD_INT 1
29179: PUSH
29180: EMPTY
29181: LIST
29182: LIST
29183: PUSH
29184: LD_INT 2
29186: PUSH
29187: LD_INT 2
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: LD_INT 1
29196: PUSH
29197: LD_INT 2
29199: PUSH
29200: EMPTY
29201: LIST
29202: LIST
29203: PUSH
29204: LD_INT 0
29206: PUSH
29207: LD_INT 2
29209: PUSH
29210: EMPTY
29211: LIST
29212: LIST
29213: PUSH
29214: LD_INT 1
29216: NEG
29217: PUSH
29218: LD_INT 1
29220: PUSH
29221: EMPTY
29222: LIST
29223: LIST
29224: PUSH
29225: LD_INT 2
29227: NEG
29228: PUSH
29229: LD_INT 0
29231: PUSH
29232: EMPTY
29233: LIST
29234: LIST
29235: PUSH
29236: LD_INT 2
29238: NEG
29239: PUSH
29240: LD_INT 1
29242: NEG
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: LD_INT 2
29250: NEG
29251: PUSH
29252: LD_INT 2
29254: NEG
29255: PUSH
29256: EMPTY
29257: LIST
29258: LIST
29259: PUSH
29260: EMPTY
29261: LIST
29262: LIST
29263: LIST
29264: LIST
29265: LIST
29266: LIST
29267: LIST
29268: LIST
29269: LIST
29270: LIST
29271: LIST
29272: LIST
29273: LIST
29274: LIST
29275: LIST
29276: LIST
29277: LIST
29278: LIST
29279: LIST
29280: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29281: LD_ADDR_VAR 0 18
29285: PUSH
29286: LD_INT 0
29288: PUSH
29289: LD_INT 0
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PUSH
29296: LD_INT 0
29298: PUSH
29299: LD_INT 1
29301: NEG
29302: PUSH
29303: EMPTY
29304: LIST
29305: LIST
29306: PUSH
29307: LD_INT 1
29309: PUSH
29310: LD_INT 0
29312: PUSH
29313: EMPTY
29314: LIST
29315: LIST
29316: PUSH
29317: LD_INT 1
29319: PUSH
29320: LD_INT 1
29322: PUSH
29323: EMPTY
29324: LIST
29325: LIST
29326: PUSH
29327: LD_INT 0
29329: PUSH
29330: LD_INT 1
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: PUSH
29337: LD_INT 1
29339: NEG
29340: PUSH
29341: LD_INT 0
29343: PUSH
29344: EMPTY
29345: LIST
29346: LIST
29347: PUSH
29348: LD_INT 1
29350: NEG
29351: PUSH
29352: LD_INT 1
29354: NEG
29355: PUSH
29356: EMPTY
29357: LIST
29358: LIST
29359: PUSH
29360: LD_INT 1
29362: NEG
29363: PUSH
29364: LD_INT 2
29366: NEG
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 0
29374: PUSH
29375: LD_INT 2
29377: NEG
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: LD_INT 1
29385: PUSH
29386: LD_INT 1
29388: NEG
29389: PUSH
29390: EMPTY
29391: LIST
29392: LIST
29393: PUSH
29394: LD_INT 2
29396: PUSH
29397: LD_INT 0
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PUSH
29404: LD_INT 2
29406: PUSH
29407: LD_INT 1
29409: PUSH
29410: EMPTY
29411: LIST
29412: LIST
29413: PUSH
29414: LD_INT 2
29416: PUSH
29417: LD_INT 2
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: PUSH
29424: LD_INT 1
29426: PUSH
29427: LD_INT 2
29429: PUSH
29430: EMPTY
29431: LIST
29432: LIST
29433: PUSH
29434: LD_INT 0
29436: PUSH
29437: LD_INT 2
29439: PUSH
29440: EMPTY
29441: LIST
29442: LIST
29443: PUSH
29444: LD_INT 1
29446: NEG
29447: PUSH
29448: LD_INT 1
29450: PUSH
29451: EMPTY
29452: LIST
29453: LIST
29454: PUSH
29455: LD_INT 2
29457: NEG
29458: PUSH
29459: LD_INT 0
29461: PUSH
29462: EMPTY
29463: LIST
29464: LIST
29465: PUSH
29466: LD_INT 2
29468: NEG
29469: PUSH
29470: LD_INT 1
29472: NEG
29473: PUSH
29474: EMPTY
29475: LIST
29476: LIST
29477: PUSH
29478: LD_INT 2
29480: NEG
29481: PUSH
29482: LD_INT 2
29484: NEG
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: PUSH
29490: EMPTY
29491: LIST
29492: LIST
29493: LIST
29494: LIST
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: LIST
29501: LIST
29502: LIST
29503: LIST
29504: LIST
29505: LIST
29506: LIST
29507: LIST
29508: LIST
29509: LIST
29510: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29511: LD_ADDR_VAR 0 19
29515: PUSH
29516: LD_INT 0
29518: PUSH
29519: LD_INT 0
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: PUSH
29526: LD_INT 0
29528: PUSH
29529: LD_INT 1
29531: NEG
29532: PUSH
29533: EMPTY
29534: LIST
29535: LIST
29536: PUSH
29537: LD_INT 1
29539: PUSH
29540: LD_INT 0
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PUSH
29547: LD_INT 1
29549: PUSH
29550: LD_INT 1
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 0
29559: PUSH
29560: LD_INT 1
29562: PUSH
29563: EMPTY
29564: LIST
29565: LIST
29566: PUSH
29567: LD_INT 1
29569: NEG
29570: PUSH
29571: LD_INT 0
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PUSH
29578: LD_INT 1
29580: NEG
29581: PUSH
29582: LD_INT 1
29584: NEG
29585: PUSH
29586: EMPTY
29587: LIST
29588: LIST
29589: PUSH
29590: LD_INT 1
29592: NEG
29593: PUSH
29594: LD_INT 2
29596: NEG
29597: PUSH
29598: EMPTY
29599: LIST
29600: LIST
29601: PUSH
29602: LD_INT 0
29604: PUSH
29605: LD_INT 2
29607: NEG
29608: PUSH
29609: EMPTY
29610: LIST
29611: LIST
29612: PUSH
29613: LD_INT 1
29615: PUSH
29616: LD_INT 1
29618: NEG
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: LD_INT 2
29626: PUSH
29627: LD_INT 0
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 2
29636: PUSH
29637: LD_INT 1
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: LD_INT 2
29646: PUSH
29647: LD_INT 2
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 1
29656: PUSH
29657: LD_INT 2
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: PUSH
29664: LD_INT 0
29666: PUSH
29667: LD_INT 2
29669: PUSH
29670: EMPTY
29671: LIST
29672: LIST
29673: PUSH
29674: LD_INT 1
29676: NEG
29677: PUSH
29678: LD_INT 1
29680: PUSH
29681: EMPTY
29682: LIST
29683: LIST
29684: PUSH
29685: LD_INT 2
29687: NEG
29688: PUSH
29689: LD_INT 0
29691: PUSH
29692: EMPTY
29693: LIST
29694: LIST
29695: PUSH
29696: LD_INT 2
29698: NEG
29699: PUSH
29700: LD_INT 1
29702: NEG
29703: PUSH
29704: EMPTY
29705: LIST
29706: LIST
29707: PUSH
29708: LD_INT 2
29710: NEG
29711: PUSH
29712: LD_INT 2
29714: NEG
29715: PUSH
29716: EMPTY
29717: LIST
29718: LIST
29719: PUSH
29720: EMPTY
29721: LIST
29722: LIST
29723: LIST
29724: LIST
29725: LIST
29726: LIST
29727: LIST
29728: LIST
29729: LIST
29730: LIST
29731: LIST
29732: LIST
29733: LIST
29734: LIST
29735: LIST
29736: LIST
29737: LIST
29738: LIST
29739: LIST
29740: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29741: LD_ADDR_VAR 0 20
29745: PUSH
29746: LD_INT 0
29748: PUSH
29749: LD_INT 0
29751: PUSH
29752: EMPTY
29753: LIST
29754: LIST
29755: PUSH
29756: LD_INT 0
29758: PUSH
29759: LD_INT 1
29761: NEG
29762: PUSH
29763: EMPTY
29764: LIST
29765: LIST
29766: PUSH
29767: LD_INT 1
29769: PUSH
29770: LD_INT 0
29772: PUSH
29773: EMPTY
29774: LIST
29775: LIST
29776: PUSH
29777: LD_INT 1
29779: PUSH
29780: LD_INT 1
29782: PUSH
29783: EMPTY
29784: LIST
29785: LIST
29786: PUSH
29787: LD_INT 0
29789: PUSH
29790: LD_INT 1
29792: PUSH
29793: EMPTY
29794: LIST
29795: LIST
29796: PUSH
29797: LD_INT 1
29799: NEG
29800: PUSH
29801: LD_INT 0
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 1
29810: NEG
29811: PUSH
29812: LD_INT 1
29814: NEG
29815: PUSH
29816: EMPTY
29817: LIST
29818: LIST
29819: PUSH
29820: LD_INT 1
29822: NEG
29823: PUSH
29824: LD_INT 2
29826: NEG
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: PUSH
29832: LD_INT 0
29834: PUSH
29835: LD_INT 2
29837: NEG
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: LD_INT 1
29845: PUSH
29846: LD_INT 1
29848: NEG
29849: PUSH
29850: EMPTY
29851: LIST
29852: LIST
29853: PUSH
29854: LD_INT 2
29856: PUSH
29857: LD_INT 0
29859: PUSH
29860: EMPTY
29861: LIST
29862: LIST
29863: PUSH
29864: LD_INT 2
29866: PUSH
29867: LD_INT 1
29869: PUSH
29870: EMPTY
29871: LIST
29872: LIST
29873: PUSH
29874: LD_INT 2
29876: PUSH
29877: LD_INT 2
29879: PUSH
29880: EMPTY
29881: LIST
29882: LIST
29883: PUSH
29884: LD_INT 1
29886: PUSH
29887: LD_INT 2
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 0
29896: PUSH
29897: LD_INT 2
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 1
29906: NEG
29907: PUSH
29908: LD_INT 1
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: PUSH
29915: LD_INT 2
29917: NEG
29918: PUSH
29919: LD_INT 0
29921: PUSH
29922: EMPTY
29923: LIST
29924: LIST
29925: PUSH
29926: LD_INT 2
29928: NEG
29929: PUSH
29930: LD_INT 1
29932: NEG
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: PUSH
29938: LD_INT 2
29940: NEG
29941: PUSH
29942: LD_INT 2
29944: NEG
29945: PUSH
29946: EMPTY
29947: LIST
29948: LIST
29949: PUSH
29950: EMPTY
29951: LIST
29952: LIST
29953: LIST
29954: LIST
29955: LIST
29956: LIST
29957: LIST
29958: LIST
29959: LIST
29960: LIST
29961: LIST
29962: LIST
29963: LIST
29964: LIST
29965: LIST
29966: LIST
29967: LIST
29968: LIST
29969: LIST
29970: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29971: LD_ADDR_VAR 0 21
29975: PUSH
29976: LD_INT 0
29978: PUSH
29979: LD_INT 0
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: LD_INT 0
29988: PUSH
29989: LD_INT 1
29991: NEG
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 1
29999: PUSH
30000: LD_INT 0
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: LD_INT 1
30009: PUSH
30010: LD_INT 1
30012: PUSH
30013: EMPTY
30014: LIST
30015: LIST
30016: PUSH
30017: LD_INT 0
30019: PUSH
30020: LD_INT 1
30022: PUSH
30023: EMPTY
30024: LIST
30025: LIST
30026: PUSH
30027: LD_INT 1
30029: NEG
30030: PUSH
30031: LD_INT 0
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: PUSH
30038: LD_INT 1
30040: NEG
30041: PUSH
30042: LD_INT 1
30044: NEG
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: LD_INT 1
30052: NEG
30053: PUSH
30054: LD_INT 2
30056: NEG
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 0
30064: PUSH
30065: LD_INT 2
30067: NEG
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 1
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: EMPTY
30081: LIST
30082: LIST
30083: PUSH
30084: LD_INT 2
30086: PUSH
30087: LD_INT 0
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: PUSH
30094: LD_INT 2
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 2
30106: PUSH
30107: LD_INT 2
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: LD_INT 1
30116: PUSH
30117: LD_INT 2
30119: PUSH
30120: EMPTY
30121: LIST
30122: LIST
30123: PUSH
30124: LD_INT 0
30126: PUSH
30127: LD_INT 2
30129: PUSH
30130: EMPTY
30131: LIST
30132: LIST
30133: PUSH
30134: LD_INT 1
30136: NEG
30137: PUSH
30138: LD_INT 1
30140: PUSH
30141: EMPTY
30142: LIST
30143: LIST
30144: PUSH
30145: LD_INT 2
30147: NEG
30148: PUSH
30149: LD_INT 0
30151: PUSH
30152: EMPTY
30153: LIST
30154: LIST
30155: PUSH
30156: LD_INT 2
30158: NEG
30159: PUSH
30160: LD_INT 1
30162: NEG
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: PUSH
30168: LD_INT 2
30170: NEG
30171: PUSH
30172: LD_INT 2
30174: NEG
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: EMPTY
30181: LIST
30182: LIST
30183: LIST
30184: LIST
30185: LIST
30186: LIST
30187: LIST
30188: LIST
30189: LIST
30190: LIST
30191: LIST
30192: LIST
30193: LIST
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30201: LD_ADDR_VAR 0 22
30205: PUSH
30206: LD_INT 0
30208: PUSH
30209: LD_INT 0
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: LD_INT 0
30218: PUSH
30219: LD_INT 1
30221: NEG
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: PUSH
30227: LD_INT 1
30229: PUSH
30230: LD_INT 0
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: PUSH
30237: LD_INT 1
30239: PUSH
30240: LD_INT 1
30242: PUSH
30243: EMPTY
30244: LIST
30245: LIST
30246: PUSH
30247: LD_INT 0
30249: PUSH
30250: LD_INT 1
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: PUSH
30257: LD_INT 1
30259: NEG
30260: PUSH
30261: LD_INT 0
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 1
30270: NEG
30271: PUSH
30272: LD_INT 1
30274: NEG
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 1
30282: NEG
30283: PUSH
30284: LD_INT 2
30286: NEG
30287: PUSH
30288: EMPTY
30289: LIST
30290: LIST
30291: PUSH
30292: LD_INT 0
30294: PUSH
30295: LD_INT 2
30297: NEG
30298: PUSH
30299: EMPTY
30300: LIST
30301: LIST
30302: PUSH
30303: LD_INT 1
30305: PUSH
30306: LD_INT 1
30308: NEG
30309: PUSH
30310: EMPTY
30311: LIST
30312: LIST
30313: PUSH
30314: LD_INT 2
30316: PUSH
30317: LD_INT 0
30319: PUSH
30320: EMPTY
30321: LIST
30322: LIST
30323: PUSH
30324: LD_INT 2
30326: PUSH
30327: LD_INT 1
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: PUSH
30334: LD_INT 2
30336: PUSH
30337: LD_INT 2
30339: PUSH
30340: EMPTY
30341: LIST
30342: LIST
30343: PUSH
30344: LD_INT 1
30346: PUSH
30347: LD_INT 2
30349: PUSH
30350: EMPTY
30351: LIST
30352: LIST
30353: PUSH
30354: LD_INT 0
30356: PUSH
30357: LD_INT 2
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: LD_INT 1
30366: NEG
30367: PUSH
30368: LD_INT 1
30370: PUSH
30371: EMPTY
30372: LIST
30373: LIST
30374: PUSH
30375: LD_INT 2
30377: NEG
30378: PUSH
30379: LD_INT 0
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: LD_INT 2
30388: NEG
30389: PUSH
30390: LD_INT 1
30392: NEG
30393: PUSH
30394: EMPTY
30395: LIST
30396: LIST
30397: PUSH
30398: LD_INT 2
30400: NEG
30401: PUSH
30402: LD_INT 2
30404: NEG
30405: PUSH
30406: EMPTY
30407: LIST
30408: LIST
30409: PUSH
30410: EMPTY
30411: LIST
30412: LIST
30413: LIST
30414: LIST
30415: LIST
30416: LIST
30417: LIST
30418: LIST
30419: LIST
30420: LIST
30421: LIST
30422: LIST
30423: LIST
30424: LIST
30425: LIST
30426: LIST
30427: LIST
30428: LIST
30429: LIST
30430: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30431: LD_ADDR_VAR 0 23
30435: PUSH
30436: LD_INT 0
30438: PUSH
30439: LD_INT 0
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: PUSH
30446: LD_INT 0
30448: PUSH
30449: LD_INT 1
30451: NEG
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: PUSH
30457: LD_INT 1
30459: PUSH
30460: LD_INT 0
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: PUSH
30467: LD_INT 1
30469: PUSH
30470: LD_INT 1
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: LD_INT 0
30479: PUSH
30480: LD_INT 1
30482: PUSH
30483: EMPTY
30484: LIST
30485: LIST
30486: PUSH
30487: LD_INT 1
30489: NEG
30490: PUSH
30491: LD_INT 0
30493: PUSH
30494: EMPTY
30495: LIST
30496: LIST
30497: PUSH
30498: LD_INT 1
30500: NEG
30501: PUSH
30502: LD_INT 1
30504: NEG
30505: PUSH
30506: EMPTY
30507: LIST
30508: LIST
30509: PUSH
30510: LD_INT 1
30512: NEG
30513: PUSH
30514: LD_INT 2
30516: NEG
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: PUSH
30522: LD_INT 0
30524: PUSH
30525: LD_INT 2
30527: NEG
30528: PUSH
30529: EMPTY
30530: LIST
30531: LIST
30532: PUSH
30533: LD_INT 1
30535: PUSH
30536: LD_INT 1
30538: NEG
30539: PUSH
30540: EMPTY
30541: LIST
30542: LIST
30543: PUSH
30544: LD_INT 2
30546: PUSH
30547: LD_INT 0
30549: PUSH
30550: EMPTY
30551: LIST
30552: LIST
30553: PUSH
30554: LD_INT 2
30556: PUSH
30557: LD_INT 1
30559: PUSH
30560: EMPTY
30561: LIST
30562: LIST
30563: PUSH
30564: LD_INT 2
30566: PUSH
30567: LD_INT 2
30569: PUSH
30570: EMPTY
30571: LIST
30572: LIST
30573: PUSH
30574: LD_INT 1
30576: PUSH
30577: LD_INT 2
30579: PUSH
30580: EMPTY
30581: LIST
30582: LIST
30583: PUSH
30584: LD_INT 0
30586: PUSH
30587: LD_INT 2
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: LD_INT 1
30600: PUSH
30601: EMPTY
30602: LIST
30603: LIST
30604: PUSH
30605: LD_INT 2
30607: NEG
30608: PUSH
30609: LD_INT 0
30611: PUSH
30612: EMPTY
30613: LIST
30614: LIST
30615: PUSH
30616: LD_INT 2
30618: NEG
30619: PUSH
30620: LD_INT 1
30622: NEG
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: LD_INT 2
30630: NEG
30631: PUSH
30632: LD_INT 2
30634: NEG
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: PUSH
30640: LD_INT 2
30642: NEG
30643: PUSH
30644: LD_INT 3
30646: NEG
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 1
30654: NEG
30655: PUSH
30656: LD_INT 3
30658: NEG
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: LD_INT 1
30666: PUSH
30667: LD_INT 2
30669: NEG
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: PUSH
30675: LD_INT 2
30677: PUSH
30678: LD_INT 1
30680: NEG
30681: PUSH
30682: EMPTY
30683: LIST
30684: LIST
30685: PUSH
30686: EMPTY
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: LIST
30694: LIST
30695: LIST
30696: LIST
30697: LIST
30698: LIST
30699: LIST
30700: LIST
30701: LIST
30702: LIST
30703: LIST
30704: LIST
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: LIST
30710: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30711: LD_ADDR_VAR 0 24
30715: PUSH
30716: LD_INT 0
30718: PUSH
30719: LD_INT 0
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: PUSH
30726: LD_INT 0
30728: PUSH
30729: LD_INT 1
30731: NEG
30732: PUSH
30733: EMPTY
30734: LIST
30735: LIST
30736: PUSH
30737: LD_INT 1
30739: PUSH
30740: LD_INT 0
30742: PUSH
30743: EMPTY
30744: LIST
30745: LIST
30746: PUSH
30747: LD_INT 1
30749: PUSH
30750: LD_INT 1
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: PUSH
30757: LD_INT 0
30759: PUSH
30760: LD_INT 1
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: LD_INT 1
30769: NEG
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: LD_INT 1
30780: NEG
30781: PUSH
30782: LD_INT 1
30784: NEG
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 1
30792: NEG
30793: PUSH
30794: LD_INT 2
30796: NEG
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 0
30804: PUSH
30805: LD_INT 2
30807: NEG
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PUSH
30813: LD_INT 1
30815: PUSH
30816: LD_INT 1
30818: NEG
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 2
30826: PUSH
30827: LD_INT 0
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: PUSH
30834: LD_INT 2
30836: PUSH
30837: LD_INT 1
30839: PUSH
30840: EMPTY
30841: LIST
30842: LIST
30843: PUSH
30844: LD_INT 2
30846: PUSH
30847: LD_INT 2
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: PUSH
30854: LD_INT 1
30856: PUSH
30857: LD_INT 2
30859: PUSH
30860: EMPTY
30861: LIST
30862: LIST
30863: PUSH
30864: LD_INT 0
30866: PUSH
30867: LD_INT 2
30869: PUSH
30870: EMPTY
30871: LIST
30872: LIST
30873: PUSH
30874: LD_INT 1
30876: NEG
30877: PUSH
30878: LD_INT 1
30880: PUSH
30881: EMPTY
30882: LIST
30883: LIST
30884: PUSH
30885: LD_INT 2
30887: NEG
30888: PUSH
30889: LD_INT 0
30891: PUSH
30892: EMPTY
30893: LIST
30894: LIST
30895: PUSH
30896: LD_INT 2
30898: NEG
30899: PUSH
30900: LD_INT 1
30902: NEG
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 2
30910: NEG
30911: PUSH
30912: LD_INT 2
30914: NEG
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: PUSH
30920: LD_INT 1
30922: PUSH
30923: LD_INT 2
30925: NEG
30926: PUSH
30927: EMPTY
30928: LIST
30929: LIST
30930: PUSH
30931: LD_INT 2
30933: PUSH
30934: LD_INT 1
30936: NEG
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 3
30944: PUSH
30945: LD_INT 1
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: PUSH
30952: LD_INT 3
30954: PUSH
30955: LD_INT 2
30957: PUSH
30958: EMPTY
30959: LIST
30960: LIST
30961: PUSH
30962: EMPTY
30963: LIST
30964: LIST
30965: LIST
30966: LIST
30967: LIST
30968: LIST
30969: LIST
30970: LIST
30971: LIST
30972: LIST
30973: LIST
30974: LIST
30975: LIST
30976: LIST
30977: LIST
30978: LIST
30979: LIST
30980: LIST
30981: LIST
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30987: LD_ADDR_VAR 0 25
30991: PUSH
30992: LD_INT 0
30994: PUSH
30995: LD_INT 0
30997: PUSH
30998: EMPTY
30999: LIST
31000: LIST
31001: PUSH
31002: LD_INT 0
31004: PUSH
31005: LD_INT 1
31007: NEG
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: LD_INT 1
31015: PUSH
31016: LD_INT 0
31018: PUSH
31019: EMPTY
31020: LIST
31021: LIST
31022: PUSH
31023: LD_INT 1
31025: PUSH
31026: LD_INT 1
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 0
31035: PUSH
31036: LD_INT 1
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PUSH
31043: LD_INT 1
31045: NEG
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: PUSH
31054: LD_INT 1
31056: NEG
31057: PUSH
31058: LD_INT 1
31060: NEG
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 1
31068: NEG
31069: PUSH
31070: LD_INT 2
31072: NEG
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 0
31080: PUSH
31081: LD_INT 2
31083: NEG
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: PUSH
31089: LD_INT 1
31091: PUSH
31092: LD_INT 1
31094: NEG
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: LD_INT 2
31102: PUSH
31103: LD_INT 0
31105: PUSH
31106: EMPTY
31107: LIST
31108: LIST
31109: PUSH
31110: LD_INT 2
31112: PUSH
31113: LD_INT 1
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PUSH
31120: LD_INT 2
31122: PUSH
31123: LD_INT 2
31125: PUSH
31126: EMPTY
31127: LIST
31128: LIST
31129: PUSH
31130: LD_INT 1
31132: PUSH
31133: LD_INT 2
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 0
31142: PUSH
31143: LD_INT 2
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: LD_INT 1
31152: NEG
31153: PUSH
31154: LD_INT 1
31156: PUSH
31157: EMPTY
31158: LIST
31159: LIST
31160: PUSH
31161: LD_INT 2
31163: NEG
31164: PUSH
31165: LD_INT 0
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 2
31174: NEG
31175: PUSH
31176: LD_INT 1
31178: NEG
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 2
31186: NEG
31187: PUSH
31188: LD_INT 2
31190: NEG
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PUSH
31196: LD_INT 3
31198: PUSH
31199: LD_INT 1
31201: PUSH
31202: EMPTY
31203: LIST
31204: LIST
31205: PUSH
31206: LD_INT 3
31208: PUSH
31209: LD_INT 2
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: PUSH
31216: LD_INT 2
31218: PUSH
31219: LD_INT 3
31221: PUSH
31222: EMPTY
31223: LIST
31224: LIST
31225: PUSH
31226: LD_INT 1
31228: PUSH
31229: LD_INT 3
31231: PUSH
31232: EMPTY
31233: LIST
31234: LIST
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: LIST
31240: LIST
31241: LIST
31242: LIST
31243: LIST
31244: LIST
31245: LIST
31246: LIST
31247: LIST
31248: LIST
31249: LIST
31250: LIST
31251: LIST
31252: LIST
31253: LIST
31254: LIST
31255: LIST
31256: LIST
31257: LIST
31258: LIST
31259: LIST
31260: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31261: LD_ADDR_VAR 0 26
31265: PUSH
31266: LD_INT 0
31268: PUSH
31269: LD_INT 0
31271: PUSH
31272: EMPTY
31273: LIST
31274: LIST
31275: PUSH
31276: LD_INT 0
31278: PUSH
31279: LD_INT 1
31281: NEG
31282: PUSH
31283: EMPTY
31284: LIST
31285: LIST
31286: PUSH
31287: LD_INT 1
31289: PUSH
31290: LD_INT 0
31292: PUSH
31293: EMPTY
31294: LIST
31295: LIST
31296: PUSH
31297: LD_INT 1
31299: PUSH
31300: LD_INT 1
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: PUSH
31307: LD_INT 0
31309: PUSH
31310: LD_INT 1
31312: PUSH
31313: EMPTY
31314: LIST
31315: LIST
31316: PUSH
31317: LD_INT 1
31319: NEG
31320: PUSH
31321: LD_INT 0
31323: PUSH
31324: EMPTY
31325: LIST
31326: LIST
31327: PUSH
31328: LD_INT 1
31330: NEG
31331: PUSH
31332: LD_INT 1
31334: NEG
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 1
31342: NEG
31343: PUSH
31344: LD_INT 2
31346: NEG
31347: PUSH
31348: EMPTY
31349: LIST
31350: LIST
31351: PUSH
31352: LD_INT 0
31354: PUSH
31355: LD_INT 2
31357: NEG
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 1
31365: PUSH
31366: LD_INT 1
31368: NEG
31369: PUSH
31370: EMPTY
31371: LIST
31372: LIST
31373: PUSH
31374: LD_INT 2
31376: PUSH
31377: LD_INT 0
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 2
31386: PUSH
31387: LD_INT 1
31389: PUSH
31390: EMPTY
31391: LIST
31392: LIST
31393: PUSH
31394: LD_INT 2
31396: PUSH
31397: LD_INT 2
31399: PUSH
31400: EMPTY
31401: LIST
31402: LIST
31403: PUSH
31404: LD_INT 1
31406: PUSH
31407: LD_INT 2
31409: PUSH
31410: EMPTY
31411: LIST
31412: LIST
31413: PUSH
31414: LD_INT 0
31416: PUSH
31417: LD_INT 2
31419: PUSH
31420: EMPTY
31421: LIST
31422: LIST
31423: PUSH
31424: LD_INT 1
31426: NEG
31427: PUSH
31428: LD_INT 1
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: LD_INT 2
31437: NEG
31438: PUSH
31439: LD_INT 0
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: PUSH
31446: LD_INT 2
31448: NEG
31449: PUSH
31450: LD_INT 1
31452: NEG
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: PUSH
31458: LD_INT 2
31460: NEG
31461: PUSH
31462: LD_INT 2
31464: NEG
31465: PUSH
31466: EMPTY
31467: LIST
31468: LIST
31469: PUSH
31470: LD_INT 2
31472: PUSH
31473: LD_INT 3
31475: PUSH
31476: EMPTY
31477: LIST
31478: LIST
31479: PUSH
31480: LD_INT 1
31482: PUSH
31483: LD_INT 3
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: PUSH
31490: LD_INT 1
31492: NEG
31493: PUSH
31494: LD_INT 2
31496: PUSH
31497: EMPTY
31498: LIST
31499: LIST
31500: PUSH
31501: LD_INT 2
31503: NEG
31504: PUSH
31505: LD_INT 1
31507: PUSH
31508: EMPTY
31509: LIST
31510: LIST
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: LIST
31516: LIST
31517: LIST
31518: LIST
31519: LIST
31520: LIST
31521: LIST
31522: LIST
31523: LIST
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: LIST
31529: LIST
31530: LIST
31531: LIST
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31537: LD_ADDR_VAR 0 27
31541: PUSH
31542: LD_INT 0
31544: PUSH
31545: LD_INT 0
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: LD_INT 0
31554: PUSH
31555: LD_INT 1
31557: NEG
31558: PUSH
31559: EMPTY
31560: LIST
31561: LIST
31562: PUSH
31563: LD_INT 1
31565: PUSH
31566: LD_INT 0
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 1
31575: PUSH
31576: LD_INT 1
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 0
31585: PUSH
31586: LD_INT 1
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 1
31595: NEG
31596: PUSH
31597: LD_INT 0
31599: PUSH
31600: EMPTY
31601: LIST
31602: LIST
31603: PUSH
31604: LD_INT 1
31606: NEG
31607: PUSH
31608: LD_INT 1
31610: NEG
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: PUSH
31616: LD_INT 1
31618: NEG
31619: PUSH
31620: LD_INT 2
31622: NEG
31623: PUSH
31624: EMPTY
31625: LIST
31626: LIST
31627: PUSH
31628: LD_INT 0
31630: PUSH
31631: LD_INT 2
31633: NEG
31634: PUSH
31635: EMPTY
31636: LIST
31637: LIST
31638: PUSH
31639: LD_INT 1
31641: PUSH
31642: LD_INT 1
31644: NEG
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PUSH
31650: LD_INT 2
31652: PUSH
31653: LD_INT 0
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: LD_INT 2
31662: PUSH
31663: LD_INT 1
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: LD_INT 2
31672: PUSH
31673: LD_INT 2
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 1
31682: PUSH
31683: LD_INT 2
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: LD_INT 2
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 1
31702: NEG
31703: PUSH
31704: LD_INT 1
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 2
31713: NEG
31714: PUSH
31715: LD_INT 0
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: LD_INT 2
31724: NEG
31725: PUSH
31726: LD_INT 1
31728: NEG
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: LD_INT 2
31736: NEG
31737: PUSH
31738: LD_INT 2
31740: NEG
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 1
31748: NEG
31749: PUSH
31750: LD_INT 2
31752: PUSH
31753: EMPTY
31754: LIST
31755: LIST
31756: PUSH
31757: LD_INT 2
31759: NEG
31760: PUSH
31761: LD_INT 1
31763: PUSH
31764: EMPTY
31765: LIST
31766: LIST
31767: PUSH
31768: LD_INT 3
31770: NEG
31771: PUSH
31772: LD_INT 1
31774: NEG
31775: PUSH
31776: EMPTY
31777: LIST
31778: LIST
31779: PUSH
31780: LD_INT 3
31782: NEG
31783: PUSH
31784: LD_INT 2
31786: NEG
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: LIST
31796: LIST
31797: LIST
31798: LIST
31799: LIST
31800: LIST
31801: LIST
31802: LIST
31803: LIST
31804: LIST
31805: LIST
31806: LIST
31807: LIST
31808: LIST
31809: LIST
31810: LIST
31811: LIST
31812: LIST
31813: LIST
31814: LIST
31815: LIST
31816: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31817: LD_ADDR_VAR 0 28
31821: PUSH
31822: LD_INT 0
31824: PUSH
31825: LD_INT 0
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PUSH
31832: LD_INT 0
31834: PUSH
31835: LD_INT 1
31837: NEG
31838: PUSH
31839: EMPTY
31840: LIST
31841: LIST
31842: PUSH
31843: LD_INT 1
31845: PUSH
31846: LD_INT 0
31848: PUSH
31849: EMPTY
31850: LIST
31851: LIST
31852: PUSH
31853: LD_INT 1
31855: PUSH
31856: LD_INT 1
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: PUSH
31863: LD_INT 0
31865: PUSH
31866: LD_INT 1
31868: PUSH
31869: EMPTY
31870: LIST
31871: LIST
31872: PUSH
31873: LD_INT 1
31875: NEG
31876: PUSH
31877: LD_INT 0
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PUSH
31884: LD_INT 1
31886: NEG
31887: PUSH
31888: LD_INT 1
31890: NEG
31891: PUSH
31892: EMPTY
31893: LIST
31894: LIST
31895: PUSH
31896: LD_INT 1
31898: NEG
31899: PUSH
31900: LD_INT 2
31902: NEG
31903: PUSH
31904: EMPTY
31905: LIST
31906: LIST
31907: PUSH
31908: LD_INT 0
31910: PUSH
31911: LD_INT 2
31913: NEG
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: LD_INT 1
31921: PUSH
31922: LD_INT 1
31924: NEG
31925: PUSH
31926: EMPTY
31927: LIST
31928: LIST
31929: PUSH
31930: LD_INT 2
31932: PUSH
31933: LD_INT 0
31935: PUSH
31936: EMPTY
31937: LIST
31938: LIST
31939: PUSH
31940: LD_INT 2
31942: PUSH
31943: LD_INT 1
31945: PUSH
31946: EMPTY
31947: LIST
31948: LIST
31949: PUSH
31950: LD_INT 2
31952: PUSH
31953: LD_INT 2
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PUSH
31960: LD_INT 1
31962: PUSH
31963: LD_INT 2
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: PUSH
31970: LD_INT 0
31972: PUSH
31973: LD_INT 2
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 1
31982: NEG
31983: PUSH
31984: LD_INT 1
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 2
31993: NEG
31994: PUSH
31995: LD_INT 0
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PUSH
32002: LD_INT 2
32004: NEG
32005: PUSH
32006: LD_INT 1
32008: NEG
32009: PUSH
32010: EMPTY
32011: LIST
32012: LIST
32013: PUSH
32014: LD_INT 2
32016: NEG
32017: PUSH
32018: LD_INT 2
32020: NEG
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 2
32028: NEG
32029: PUSH
32030: LD_INT 3
32032: NEG
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 1
32040: NEG
32041: PUSH
32042: LD_INT 3
32044: NEG
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PUSH
32050: LD_INT 3
32052: NEG
32053: PUSH
32054: LD_INT 1
32056: NEG
32057: PUSH
32058: EMPTY
32059: LIST
32060: LIST
32061: PUSH
32062: LD_INT 3
32064: NEG
32065: PUSH
32066: LD_INT 2
32068: NEG
32069: PUSH
32070: EMPTY
32071: LIST
32072: LIST
32073: PUSH
32074: EMPTY
32075: LIST
32076: LIST
32077: LIST
32078: LIST
32079: LIST
32080: LIST
32081: LIST
32082: LIST
32083: LIST
32084: LIST
32085: LIST
32086: LIST
32087: LIST
32088: LIST
32089: LIST
32090: LIST
32091: LIST
32092: LIST
32093: LIST
32094: LIST
32095: LIST
32096: LIST
32097: LIST
32098: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32099: LD_ADDR_VAR 0 29
32103: PUSH
32104: LD_INT 0
32106: PUSH
32107: LD_INT 0
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 0
32116: PUSH
32117: LD_INT 1
32119: NEG
32120: PUSH
32121: EMPTY
32122: LIST
32123: LIST
32124: PUSH
32125: LD_INT 1
32127: PUSH
32128: LD_INT 0
32130: PUSH
32131: EMPTY
32132: LIST
32133: LIST
32134: PUSH
32135: LD_INT 1
32137: PUSH
32138: LD_INT 1
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: PUSH
32145: LD_INT 0
32147: PUSH
32148: LD_INT 1
32150: PUSH
32151: EMPTY
32152: LIST
32153: LIST
32154: PUSH
32155: LD_INT 1
32157: NEG
32158: PUSH
32159: LD_INT 0
32161: PUSH
32162: EMPTY
32163: LIST
32164: LIST
32165: PUSH
32166: LD_INT 1
32168: NEG
32169: PUSH
32170: LD_INT 1
32172: NEG
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: LD_INT 1
32180: NEG
32181: PUSH
32182: LD_INT 2
32184: NEG
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 0
32192: PUSH
32193: LD_INT 2
32195: NEG
32196: PUSH
32197: EMPTY
32198: LIST
32199: LIST
32200: PUSH
32201: LD_INT 1
32203: PUSH
32204: LD_INT 1
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 2
32214: PUSH
32215: LD_INT 0
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 2
32224: PUSH
32225: LD_INT 1
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 1
32234: PUSH
32235: LD_INT 2
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 0
32244: PUSH
32245: LD_INT 2
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 1
32254: NEG
32255: PUSH
32256: LD_INT 1
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: PUSH
32263: LD_INT 2
32265: NEG
32266: PUSH
32267: LD_INT 1
32269: NEG
32270: PUSH
32271: EMPTY
32272: LIST
32273: LIST
32274: PUSH
32275: LD_INT 2
32277: NEG
32278: PUSH
32279: LD_INT 2
32281: NEG
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 2
32289: NEG
32290: PUSH
32291: LD_INT 3
32293: NEG
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: LD_INT 2
32301: PUSH
32302: LD_INT 1
32304: NEG
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 3
32312: PUSH
32313: LD_INT 1
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 1
32322: PUSH
32323: LD_INT 3
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 1
32332: NEG
32333: PUSH
32334: LD_INT 2
32336: PUSH
32337: EMPTY
32338: LIST
32339: LIST
32340: PUSH
32341: LD_INT 3
32343: NEG
32344: PUSH
32345: LD_INT 2
32347: NEG
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: LIST
32357: LIST
32358: LIST
32359: LIST
32360: LIST
32361: LIST
32362: LIST
32363: LIST
32364: LIST
32365: LIST
32366: LIST
32367: LIST
32368: LIST
32369: LIST
32370: LIST
32371: LIST
32372: LIST
32373: LIST
32374: LIST
32375: LIST
32376: LIST
32377: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32378: LD_ADDR_VAR 0 30
32382: PUSH
32383: LD_INT 0
32385: PUSH
32386: LD_INT 0
32388: PUSH
32389: EMPTY
32390: LIST
32391: LIST
32392: PUSH
32393: LD_INT 0
32395: PUSH
32396: LD_INT 1
32398: NEG
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 1
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 1
32416: PUSH
32417: LD_INT 1
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PUSH
32424: LD_INT 0
32426: PUSH
32427: LD_INT 1
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: LD_INT 1
32436: NEG
32437: PUSH
32438: LD_INT 0
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: LD_INT 1
32447: NEG
32448: PUSH
32449: LD_INT 1
32451: NEG
32452: PUSH
32453: EMPTY
32454: LIST
32455: LIST
32456: PUSH
32457: LD_INT 1
32459: NEG
32460: PUSH
32461: LD_INT 2
32463: NEG
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 0
32471: PUSH
32472: LD_INT 2
32474: NEG
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: LD_INT 1
32482: PUSH
32483: LD_INT 1
32485: NEG
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: LD_INT 2
32493: PUSH
32494: LD_INT 0
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 2
32503: PUSH
32504: LD_INT 1
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 2
32513: PUSH
32514: LD_INT 2
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: LD_INT 1
32523: PUSH
32524: LD_INT 2
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 1
32533: NEG
32534: PUSH
32535: LD_INT 1
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 2
32544: NEG
32545: PUSH
32546: LD_INT 0
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 2
32555: NEG
32556: PUSH
32557: LD_INT 1
32559: NEG
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 1
32567: NEG
32568: PUSH
32569: LD_INT 3
32571: NEG
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: PUSH
32577: LD_INT 1
32579: PUSH
32580: LD_INT 2
32582: NEG
32583: PUSH
32584: EMPTY
32585: LIST
32586: LIST
32587: PUSH
32588: LD_INT 3
32590: PUSH
32591: LD_INT 2
32593: PUSH
32594: EMPTY
32595: LIST
32596: LIST
32597: PUSH
32598: LD_INT 2
32600: PUSH
32601: LD_INT 3
32603: PUSH
32604: EMPTY
32605: LIST
32606: LIST
32607: PUSH
32608: LD_INT 2
32610: NEG
32611: PUSH
32612: LD_INT 1
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PUSH
32619: LD_INT 3
32621: NEG
32622: PUSH
32623: LD_INT 1
32625: NEG
32626: PUSH
32627: EMPTY
32628: LIST
32629: LIST
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: LIST
32635: LIST
32636: LIST
32637: LIST
32638: LIST
32639: LIST
32640: LIST
32641: LIST
32642: LIST
32643: LIST
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32656: LD_ADDR_VAR 0 31
32660: PUSH
32661: LD_INT 0
32663: PUSH
32664: LD_INT 0
32666: PUSH
32667: EMPTY
32668: LIST
32669: LIST
32670: PUSH
32671: LD_INT 0
32673: PUSH
32674: LD_INT 1
32676: NEG
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 1
32684: PUSH
32685: LD_INT 0
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 1
32694: PUSH
32695: LD_INT 1
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 0
32704: PUSH
32705: LD_INT 1
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: LD_INT 1
32714: NEG
32715: PUSH
32716: LD_INT 0
32718: PUSH
32719: EMPTY
32720: LIST
32721: LIST
32722: PUSH
32723: LD_INT 1
32725: NEG
32726: PUSH
32727: LD_INT 1
32729: NEG
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 1
32737: NEG
32738: PUSH
32739: LD_INT 2
32741: NEG
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 1
32749: PUSH
32750: LD_INT 1
32752: NEG
32753: PUSH
32754: EMPTY
32755: LIST
32756: LIST
32757: PUSH
32758: LD_INT 2
32760: PUSH
32761: LD_INT 0
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PUSH
32768: LD_INT 2
32770: PUSH
32771: LD_INT 1
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 2
32780: PUSH
32781: LD_INT 2
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 1
32790: PUSH
32791: LD_INT 2
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: LD_INT 0
32800: PUSH
32801: LD_INT 2
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 1
32810: NEG
32811: PUSH
32812: LD_INT 1
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 2
32821: NEG
32822: PUSH
32823: LD_INT 1
32825: NEG
32826: PUSH
32827: EMPTY
32828: LIST
32829: LIST
32830: PUSH
32831: LD_INT 2
32833: NEG
32834: PUSH
32835: LD_INT 2
32837: NEG
32838: PUSH
32839: EMPTY
32840: LIST
32841: LIST
32842: PUSH
32843: LD_INT 2
32845: NEG
32846: PUSH
32847: LD_INT 3
32849: NEG
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: PUSH
32855: LD_INT 2
32857: PUSH
32858: LD_INT 1
32860: NEG
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: PUSH
32866: LD_INT 3
32868: PUSH
32869: LD_INT 1
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 1
32878: PUSH
32879: LD_INT 3
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: PUSH
32886: LD_INT 1
32888: NEG
32889: PUSH
32890: LD_INT 2
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 3
32899: NEG
32900: PUSH
32901: LD_INT 2
32903: NEG
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: EMPTY
32910: LIST
32911: LIST
32912: LIST
32913: LIST
32914: LIST
32915: LIST
32916: LIST
32917: LIST
32918: LIST
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32934: LD_ADDR_VAR 0 32
32938: PUSH
32939: LD_INT 0
32941: PUSH
32942: LD_INT 0
32944: PUSH
32945: EMPTY
32946: LIST
32947: LIST
32948: PUSH
32949: LD_INT 0
32951: PUSH
32952: LD_INT 1
32954: NEG
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PUSH
32960: LD_INT 1
32962: PUSH
32963: LD_INT 0
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 1
32972: PUSH
32973: LD_INT 1
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: LD_INT 0
32982: PUSH
32983: LD_INT 1
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: PUSH
32990: LD_INT 1
32992: NEG
32993: PUSH
32994: LD_INT 0
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: LD_INT 1
33003: NEG
33004: PUSH
33005: LD_INT 1
33007: NEG
33008: PUSH
33009: EMPTY
33010: LIST
33011: LIST
33012: PUSH
33013: LD_INT 1
33015: NEG
33016: PUSH
33017: LD_INT 2
33019: NEG
33020: PUSH
33021: EMPTY
33022: LIST
33023: LIST
33024: PUSH
33025: LD_INT 0
33027: PUSH
33028: LD_INT 2
33030: NEG
33031: PUSH
33032: EMPTY
33033: LIST
33034: LIST
33035: PUSH
33036: LD_INT 1
33038: PUSH
33039: LD_INT 1
33041: NEG
33042: PUSH
33043: EMPTY
33044: LIST
33045: LIST
33046: PUSH
33047: LD_INT 2
33049: PUSH
33050: LD_INT 1
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: LD_INT 2
33059: PUSH
33060: LD_INT 2
33062: PUSH
33063: EMPTY
33064: LIST
33065: LIST
33066: PUSH
33067: LD_INT 1
33069: PUSH
33070: LD_INT 2
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: PUSH
33077: LD_INT 0
33079: PUSH
33080: LD_INT 2
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 1
33089: NEG
33090: PUSH
33091: LD_INT 1
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 2
33100: NEG
33101: PUSH
33102: LD_INT 0
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: PUSH
33109: LD_INT 2
33111: NEG
33112: PUSH
33113: LD_INT 1
33115: NEG
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 1
33123: NEG
33124: PUSH
33125: LD_INT 3
33127: NEG
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: PUSH
33133: LD_INT 1
33135: PUSH
33136: LD_INT 2
33138: NEG
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: LD_INT 3
33146: PUSH
33147: LD_INT 2
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: PUSH
33154: LD_INT 2
33156: PUSH
33157: LD_INT 3
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: PUSH
33164: LD_INT 2
33166: NEG
33167: PUSH
33168: LD_INT 1
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 3
33177: NEG
33178: PUSH
33179: LD_INT 1
33181: NEG
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: LIST
33191: LIST
33192: LIST
33193: LIST
33194: LIST
33195: LIST
33196: LIST
33197: LIST
33198: LIST
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33212: LD_ADDR_VAR 0 33
33216: PUSH
33217: LD_INT 0
33219: PUSH
33220: LD_INT 0
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 0
33229: PUSH
33230: LD_INT 1
33232: NEG
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: LD_INT 1
33240: PUSH
33241: LD_INT 0
33243: PUSH
33244: EMPTY
33245: LIST
33246: LIST
33247: PUSH
33248: LD_INT 1
33250: PUSH
33251: LD_INT 1
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 0
33260: PUSH
33261: LD_INT 1
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: LD_INT 1
33270: NEG
33271: PUSH
33272: LD_INT 0
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 1
33281: NEG
33282: PUSH
33283: LD_INT 1
33285: NEG
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: PUSH
33291: LD_INT 1
33293: NEG
33294: PUSH
33295: LD_INT 2
33297: NEG
33298: PUSH
33299: EMPTY
33300: LIST
33301: LIST
33302: PUSH
33303: LD_INT 1
33305: PUSH
33306: LD_INT 1
33308: NEG
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 2
33316: PUSH
33317: LD_INT 0
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: LD_INT 2
33326: PUSH
33327: LD_INT 1
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 1
33336: PUSH
33337: LD_INT 2
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: PUSH
33344: LD_INT 0
33346: PUSH
33347: LD_INT 2
33349: PUSH
33350: EMPTY
33351: LIST
33352: LIST
33353: PUSH
33354: LD_INT 1
33356: NEG
33357: PUSH
33358: LD_INT 1
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 2
33367: NEG
33368: PUSH
33369: LD_INT 0
33371: PUSH
33372: EMPTY
33373: LIST
33374: LIST
33375: PUSH
33376: LD_INT 2
33378: NEG
33379: PUSH
33380: LD_INT 1
33382: NEG
33383: PUSH
33384: EMPTY
33385: LIST
33386: LIST
33387: PUSH
33388: LD_INT 2
33390: NEG
33391: PUSH
33392: LD_INT 2
33394: NEG
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: LD_INT 2
33402: NEG
33403: PUSH
33404: LD_INT 3
33406: NEG
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: PUSH
33412: LD_INT 2
33414: PUSH
33415: LD_INT 1
33417: NEG
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PUSH
33423: LD_INT 3
33425: PUSH
33426: LD_INT 1
33428: PUSH
33429: EMPTY
33430: LIST
33431: LIST
33432: PUSH
33433: LD_INT 1
33435: PUSH
33436: LD_INT 3
33438: PUSH
33439: EMPTY
33440: LIST
33441: LIST
33442: PUSH
33443: LD_INT 1
33445: NEG
33446: PUSH
33447: LD_INT 2
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 3
33456: NEG
33457: PUSH
33458: LD_INT 2
33460: NEG
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: LIST
33470: LIST
33471: LIST
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: LIST
33486: LIST
33487: LIST
33488: LIST
33489: LIST
33490: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33491: LD_ADDR_VAR 0 34
33495: PUSH
33496: LD_INT 0
33498: PUSH
33499: LD_INT 0
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 0
33508: PUSH
33509: LD_INT 1
33511: NEG
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 1
33519: PUSH
33520: LD_INT 0
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 1
33529: PUSH
33530: LD_INT 1
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 0
33539: PUSH
33540: LD_INT 1
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: NEG
33550: PUSH
33551: LD_INT 0
33553: PUSH
33554: EMPTY
33555: LIST
33556: LIST
33557: PUSH
33558: LD_INT 1
33560: NEG
33561: PUSH
33562: LD_INT 1
33564: NEG
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: PUSH
33570: LD_INT 1
33572: NEG
33573: PUSH
33574: LD_INT 2
33576: NEG
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: LD_INT 0
33584: PUSH
33585: LD_INT 2
33587: NEG
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 1
33595: PUSH
33596: LD_INT 1
33598: NEG
33599: PUSH
33600: EMPTY
33601: LIST
33602: LIST
33603: PUSH
33604: LD_INT 2
33606: PUSH
33607: LD_INT 1
33609: PUSH
33610: EMPTY
33611: LIST
33612: LIST
33613: PUSH
33614: LD_INT 2
33616: PUSH
33617: LD_INT 2
33619: PUSH
33620: EMPTY
33621: LIST
33622: LIST
33623: PUSH
33624: LD_INT 1
33626: PUSH
33627: LD_INT 2
33629: PUSH
33630: EMPTY
33631: LIST
33632: LIST
33633: PUSH
33634: LD_INT 1
33636: NEG
33637: PUSH
33638: LD_INT 1
33640: PUSH
33641: EMPTY
33642: LIST
33643: LIST
33644: PUSH
33645: LD_INT 2
33647: NEG
33648: PUSH
33649: LD_INT 0
33651: PUSH
33652: EMPTY
33653: LIST
33654: LIST
33655: PUSH
33656: LD_INT 2
33658: NEG
33659: PUSH
33660: LD_INT 1
33662: NEG
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 2
33670: NEG
33671: PUSH
33672: LD_INT 2
33674: NEG
33675: PUSH
33676: EMPTY
33677: LIST
33678: LIST
33679: PUSH
33680: LD_INT 1
33682: NEG
33683: PUSH
33684: LD_INT 3
33686: NEG
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: LD_INT 1
33694: PUSH
33695: LD_INT 2
33697: NEG
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 3
33705: PUSH
33706: LD_INT 2
33708: PUSH
33709: EMPTY
33710: LIST
33711: LIST
33712: PUSH
33713: LD_INT 2
33715: PUSH
33716: LD_INT 3
33718: PUSH
33719: EMPTY
33720: LIST
33721: LIST
33722: PUSH
33723: LD_INT 2
33725: NEG
33726: PUSH
33727: LD_INT 1
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 3
33736: NEG
33737: PUSH
33738: LD_INT 1
33740: NEG
33741: PUSH
33742: EMPTY
33743: LIST
33744: LIST
33745: PUSH
33746: EMPTY
33747: LIST
33748: LIST
33749: LIST
33750: LIST
33751: LIST
33752: LIST
33753: LIST
33754: LIST
33755: LIST
33756: LIST
33757: LIST
33758: LIST
33759: LIST
33760: LIST
33761: LIST
33762: LIST
33763: LIST
33764: LIST
33765: LIST
33766: LIST
33767: LIST
33768: LIST
33769: LIST
33770: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33771: LD_ADDR_VAR 0 35
33775: PUSH
33776: LD_INT 0
33778: PUSH
33779: LD_INT 0
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 0
33788: PUSH
33789: LD_INT 1
33791: NEG
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 1
33799: PUSH
33800: LD_INT 0
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: LD_INT 1
33809: PUSH
33810: LD_INT 1
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 0
33819: PUSH
33820: LD_INT 1
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 1
33829: NEG
33830: PUSH
33831: LD_INT 0
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 1
33840: NEG
33841: PUSH
33842: LD_INT 1
33844: NEG
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 2
33852: PUSH
33853: LD_INT 1
33855: PUSH
33856: EMPTY
33857: LIST
33858: LIST
33859: PUSH
33860: LD_INT 2
33862: NEG
33863: PUSH
33864: LD_INT 1
33866: NEG
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: EMPTY
33873: LIST
33874: LIST
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33883: LD_ADDR_VAR 0 36
33887: PUSH
33888: LD_INT 0
33890: PUSH
33891: LD_INT 0
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PUSH
33898: LD_INT 0
33900: PUSH
33901: LD_INT 1
33903: NEG
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: PUSH
33909: LD_INT 1
33911: PUSH
33912: LD_INT 0
33914: PUSH
33915: EMPTY
33916: LIST
33917: LIST
33918: PUSH
33919: LD_INT 1
33921: PUSH
33922: LD_INT 1
33924: PUSH
33925: EMPTY
33926: LIST
33927: LIST
33928: PUSH
33929: LD_INT 0
33931: PUSH
33932: LD_INT 1
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: LD_INT 1
33941: NEG
33942: PUSH
33943: LD_INT 0
33945: PUSH
33946: EMPTY
33947: LIST
33948: LIST
33949: PUSH
33950: LD_INT 1
33952: NEG
33953: PUSH
33954: LD_INT 1
33956: NEG
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 1
33964: NEG
33965: PUSH
33966: LD_INT 2
33968: NEG
33969: PUSH
33970: EMPTY
33971: LIST
33972: LIST
33973: PUSH
33974: LD_INT 1
33976: PUSH
33977: LD_INT 2
33979: PUSH
33980: EMPTY
33981: LIST
33982: LIST
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: LIST
33988: LIST
33989: LIST
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33995: LD_ADDR_VAR 0 37
33999: PUSH
34000: LD_INT 0
34002: PUSH
34003: LD_INT 0
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: PUSH
34010: LD_INT 0
34012: PUSH
34013: LD_INT 1
34015: NEG
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 1
34023: PUSH
34024: LD_INT 0
34026: PUSH
34027: EMPTY
34028: LIST
34029: LIST
34030: PUSH
34031: LD_INT 1
34033: PUSH
34034: LD_INT 1
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 0
34043: PUSH
34044: LD_INT 1
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: PUSH
34051: LD_INT 1
34053: NEG
34054: PUSH
34055: LD_INT 0
34057: PUSH
34058: EMPTY
34059: LIST
34060: LIST
34061: PUSH
34062: LD_INT 1
34064: NEG
34065: PUSH
34066: LD_INT 1
34068: NEG
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 1
34076: PUSH
34077: LD_INT 1
34079: NEG
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 1
34087: NEG
34088: PUSH
34089: LD_INT 1
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: LIST
34100: LIST
34101: LIST
34102: LIST
34103: LIST
34104: LIST
34105: LIST
34106: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34107: LD_ADDR_VAR 0 38
34111: PUSH
34112: LD_INT 0
34114: PUSH
34115: LD_INT 0
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: LD_INT 0
34124: PUSH
34125: LD_INT 1
34127: NEG
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 1
34135: PUSH
34136: LD_INT 0
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: LD_INT 1
34145: PUSH
34146: LD_INT 1
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 0
34155: PUSH
34156: LD_INT 1
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PUSH
34163: LD_INT 1
34165: NEG
34166: PUSH
34167: LD_INT 0
34169: PUSH
34170: EMPTY
34171: LIST
34172: LIST
34173: PUSH
34174: LD_INT 1
34176: NEG
34177: PUSH
34178: LD_INT 1
34180: NEG
34181: PUSH
34182: EMPTY
34183: LIST
34184: LIST
34185: PUSH
34186: LD_INT 2
34188: PUSH
34189: LD_INT 1
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: PUSH
34196: LD_INT 2
34198: NEG
34199: PUSH
34200: LD_INT 1
34202: NEG
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PUSH
34208: EMPTY
34209: LIST
34210: LIST
34211: LIST
34212: LIST
34213: LIST
34214: LIST
34215: LIST
34216: LIST
34217: LIST
34218: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34219: LD_ADDR_VAR 0 39
34223: PUSH
34224: LD_INT 0
34226: PUSH
34227: LD_INT 0
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 0
34236: PUSH
34237: LD_INT 1
34239: NEG
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PUSH
34245: LD_INT 1
34247: PUSH
34248: LD_INT 0
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 1
34257: PUSH
34258: LD_INT 1
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PUSH
34265: LD_INT 0
34267: PUSH
34268: LD_INT 1
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 1
34277: NEG
34278: PUSH
34279: LD_INT 0
34281: PUSH
34282: EMPTY
34283: LIST
34284: LIST
34285: PUSH
34286: LD_INT 1
34288: NEG
34289: PUSH
34290: LD_INT 1
34292: NEG
34293: PUSH
34294: EMPTY
34295: LIST
34296: LIST
34297: PUSH
34298: LD_INT 1
34300: NEG
34301: PUSH
34302: LD_INT 2
34304: NEG
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: PUSH
34310: LD_INT 1
34312: PUSH
34313: LD_INT 2
34315: PUSH
34316: EMPTY
34317: LIST
34318: LIST
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: LIST
34324: LIST
34325: LIST
34326: LIST
34327: LIST
34328: LIST
34329: LIST
34330: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34331: LD_ADDR_VAR 0 40
34335: PUSH
34336: LD_INT 0
34338: PUSH
34339: LD_INT 0
34341: PUSH
34342: EMPTY
34343: LIST
34344: LIST
34345: PUSH
34346: LD_INT 0
34348: PUSH
34349: LD_INT 1
34351: NEG
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 1
34359: PUSH
34360: LD_INT 0
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 1
34369: PUSH
34370: LD_INT 1
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 0
34379: PUSH
34380: LD_INT 1
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: NEG
34390: PUSH
34391: LD_INT 0
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 1
34400: NEG
34401: PUSH
34402: LD_INT 1
34404: NEG
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 1
34412: PUSH
34413: LD_INT 1
34415: NEG
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: NEG
34424: PUSH
34425: LD_INT 1
34427: PUSH
34428: EMPTY
34429: LIST
34430: LIST
34431: PUSH
34432: EMPTY
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34443: LD_ADDR_VAR 0 41
34447: PUSH
34448: LD_INT 0
34450: PUSH
34451: LD_INT 0
34453: PUSH
34454: EMPTY
34455: LIST
34456: LIST
34457: PUSH
34458: LD_INT 0
34460: PUSH
34461: LD_INT 1
34463: NEG
34464: PUSH
34465: EMPTY
34466: LIST
34467: LIST
34468: PUSH
34469: LD_INT 1
34471: PUSH
34472: LD_INT 0
34474: PUSH
34475: EMPTY
34476: LIST
34477: LIST
34478: PUSH
34479: LD_INT 1
34481: PUSH
34482: LD_INT 1
34484: PUSH
34485: EMPTY
34486: LIST
34487: LIST
34488: PUSH
34489: LD_INT 0
34491: PUSH
34492: LD_INT 1
34494: PUSH
34495: EMPTY
34496: LIST
34497: LIST
34498: PUSH
34499: LD_INT 1
34501: NEG
34502: PUSH
34503: LD_INT 0
34505: PUSH
34506: EMPTY
34507: LIST
34508: LIST
34509: PUSH
34510: LD_INT 1
34512: NEG
34513: PUSH
34514: LD_INT 1
34516: NEG
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 1
34524: NEG
34525: PUSH
34526: LD_INT 2
34528: NEG
34529: PUSH
34530: EMPTY
34531: LIST
34532: LIST
34533: PUSH
34534: LD_INT 1
34536: PUSH
34537: LD_INT 1
34539: NEG
34540: PUSH
34541: EMPTY
34542: LIST
34543: LIST
34544: PUSH
34545: LD_INT 2
34547: PUSH
34548: LD_INT 0
34550: PUSH
34551: EMPTY
34552: LIST
34553: LIST
34554: PUSH
34555: LD_INT 2
34557: PUSH
34558: LD_INT 1
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: LD_INT 2
34567: PUSH
34568: LD_INT 2
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: PUSH
34575: LD_INT 1
34577: PUSH
34578: LD_INT 2
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 1
34587: NEG
34588: PUSH
34589: LD_INT 1
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 2
34598: NEG
34599: PUSH
34600: LD_INT 0
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: LD_INT 2
34609: NEG
34610: PUSH
34611: LD_INT 1
34613: NEG
34614: PUSH
34615: EMPTY
34616: LIST
34617: LIST
34618: PUSH
34619: LD_INT 2
34621: NEG
34622: PUSH
34623: LD_INT 2
34625: NEG
34626: PUSH
34627: EMPTY
34628: LIST
34629: LIST
34630: PUSH
34631: LD_INT 2
34633: NEG
34634: PUSH
34635: LD_INT 3
34637: NEG
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 2
34645: PUSH
34646: LD_INT 1
34648: NEG
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 3
34656: PUSH
34657: LD_INT 0
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: PUSH
34664: LD_INT 3
34666: PUSH
34667: LD_INT 1
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PUSH
34674: LD_INT 3
34676: PUSH
34677: LD_INT 2
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PUSH
34684: LD_INT 3
34686: PUSH
34687: LD_INT 3
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 2
34696: PUSH
34697: LD_INT 3
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 2
34706: NEG
34707: PUSH
34708: LD_INT 1
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PUSH
34715: LD_INT 3
34717: NEG
34718: PUSH
34719: LD_INT 0
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PUSH
34726: LD_INT 3
34728: NEG
34729: PUSH
34730: LD_INT 1
34732: NEG
34733: PUSH
34734: EMPTY
34735: LIST
34736: LIST
34737: PUSH
34738: LD_INT 3
34740: NEG
34741: PUSH
34742: LD_INT 2
34744: NEG
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 3
34752: NEG
34753: PUSH
34754: LD_INT 3
34756: NEG
34757: PUSH
34758: EMPTY
34759: LIST
34760: LIST
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: LIST
34766: LIST
34767: LIST
34768: LIST
34769: LIST
34770: LIST
34771: LIST
34772: LIST
34773: LIST
34774: LIST
34775: LIST
34776: LIST
34777: LIST
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: LIST
34783: LIST
34784: LIST
34785: LIST
34786: LIST
34787: LIST
34788: LIST
34789: LIST
34790: LIST
34791: LIST
34792: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34793: LD_ADDR_VAR 0 42
34797: PUSH
34798: LD_INT 0
34800: PUSH
34801: LD_INT 0
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: PUSH
34808: LD_INT 0
34810: PUSH
34811: LD_INT 1
34813: NEG
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PUSH
34819: LD_INT 1
34821: PUSH
34822: LD_INT 0
34824: PUSH
34825: EMPTY
34826: LIST
34827: LIST
34828: PUSH
34829: LD_INT 1
34831: PUSH
34832: LD_INT 1
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 0
34841: PUSH
34842: LD_INT 1
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: PUSH
34849: LD_INT 1
34851: NEG
34852: PUSH
34853: LD_INT 0
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: LD_INT 1
34862: NEG
34863: PUSH
34864: LD_INT 1
34866: NEG
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 1
34874: NEG
34875: PUSH
34876: LD_INT 2
34878: NEG
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: LD_INT 0
34886: PUSH
34887: LD_INT 2
34889: NEG
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 1
34897: PUSH
34898: LD_INT 1
34900: NEG
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 2
34908: PUSH
34909: LD_INT 1
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 2
34918: PUSH
34919: LD_INT 2
34921: PUSH
34922: EMPTY
34923: LIST
34924: LIST
34925: PUSH
34926: LD_INT 1
34928: PUSH
34929: LD_INT 2
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 0
34938: PUSH
34939: LD_INT 2
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: PUSH
34946: LD_INT 1
34948: NEG
34949: PUSH
34950: LD_INT 1
34952: PUSH
34953: EMPTY
34954: LIST
34955: LIST
34956: PUSH
34957: LD_INT 2
34959: NEG
34960: PUSH
34961: LD_INT 1
34963: NEG
34964: PUSH
34965: EMPTY
34966: LIST
34967: LIST
34968: PUSH
34969: LD_INT 2
34971: NEG
34972: PUSH
34973: LD_INT 2
34975: NEG
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: LD_INT 2
34983: NEG
34984: PUSH
34985: LD_INT 3
34987: NEG
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 1
34995: NEG
34996: PUSH
34997: LD_INT 3
34999: NEG
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: LD_INT 0
35007: PUSH
35008: LD_INT 3
35010: NEG
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: LD_INT 1
35018: PUSH
35019: LD_INT 2
35021: NEG
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 3
35029: PUSH
35030: LD_INT 2
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 3
35039: PUSH
35040: LD_INT 3
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: PUSH
35047: LD_INT 2
35049: PUSH
35050: LD_INT 3
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: LD_INT 1
35059: PUSH
35060: LD_INT 3
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: LD_INT 0
35069: PUSH
35070: LD_INT 3
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 1
35079: NEG
35080: PUSH
35081: LD_INT 2
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 3
35090: NEG
35091: PUSH
35092: LD_INT 2
35094: NEG
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 3
35102: NEG
35103: PUSH
35104: LD_INT 3
35106: NEG
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: LIST
35133: LIST
35134: LIST
35135: LIST
35136: LIST
35137: LIST
35138: LIST
35139: LIST
35140: LIST
35141: LIST
35142: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35143: LD_ADDR_VAR 0 43
35147: PUSH
35148: LD_INT 0
35150: PUSH
35151: LD_INT 0
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: LD_INT 0
35160: PUSH
35161: LD_INT 1
35163: NEG
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 1
35171: PUSH
35172: LD_INT 0
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 1
35181: PUSH
35182: LD_INT 1
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 0
35191: PUSH
35192: LD_INT 1
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 1
35201: NEG
35202: PUSH
35203: LD_INT 0
35205: PUSH
35206: EMPTY
35207: LIST
35208: LIST
35209: PUSH
35210: LD_INT 1
35212: NEG
35213: PUSH
35214: LD_INT 1
35216: NEG
35217: PUSH
35218: EMPTY
35219: LIST
35220: LIST
35221: PUSH
35222: LD_INT 1
35224: NEG
35225: PUSH
35226: LD_INT 2
35228: NEG
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 0
35236: PUSH
35237: LD_INT 2
35239: NEG
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: PUSH
35245: LD_INT 1
35247: PUSH
35248: LD_INT 1
35250: NEG
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 2
35258: PUSH
35259: LD_INT 0
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 2
35268: PUSH
35269: LD_INT 1
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: LD_INT 1
35278: PUSH
35279: LD_INT 2
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 0
35288: PUSH
35289: LD_INT 2
35291: PUSH
35292: EMPTY
35293: LIST
35294: LIST
35295: PUSH
35296: LD_INT 1
35298: NEG
35299: PUSH
35300: LD_INT 1
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PUSH
35307: LD_INT 2
35309: NEG
35310: PUSH
35311: LD_INT 0
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: LD_INT 2
35320: NEG
35321: PUSH
35322: LD_INT 1
35324: NEG
35325: PUSH
35326: EMPTY
35327: LIST
35328: LIST
35329: PUSH
35330: LD_INT 1
35332: NEG
35333: PUSH
35334: LD_INT 3
35336: NEG
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: LD_INT 0
35344: PUSH
35345: LD_INT 3
35347: NEG
35348: PUSH
35349: EMPTY
35350: LIST
35351: LIST
35352: PUSH
35353: LD_INT 1
35355: PUSH
35356: LD_INT 2
35358: NEG
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 2
35366: PUSH
35367: LD_INT 1
35369: NEG
35370: PUSH
35371: EMPTY
35372: LIST
35373: LIST
35374: PUSH
35375: LD_INT 3
35377: PUSH
35378: LD_INT 0
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: PUSH
35385: LD_INT 3
35387: PUSH
35388: LD_INT 1
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: PUSH
35395: LD_INT 1
35397: PUSH
35398: LD_INT 3
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: PUSH
35405: LD_INT 0
35407: PUSH
35408: LD_INT 3
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: LD_INT 1
35417: NEG
35418: PUSH
35419: LD_INT 2
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 2
35428: NEG
35429: PUSH
35430: LD_INT 1
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 3
35439: NEG
35440: PUSH
35441: LD_INT 0
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 3
35450: NEG
35451: PUSH
35452: LD_INT 1
35454: NEG
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: LIST
35469: LIST
35470: LIST
35471: LIST
35472: LIST
35473: LIST
35474: LIST
35475: LIST
35476: LIST
35477: LIST
35478: LIST
35479: LIST
35480: LIST
35481: LIST
35482: LIST
35483: LIST
35484: LIST
35485: LIST
35486: LIST
35487: LIST
35488: LIST
35489: LIST
35490: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35491: LD_ADDR_VAR 0 44
35495: PUSH
35496: LD_INT 0
35498: PUSH
35499: LD_INT 0
35501: PUSH
35502: EMPTY
35503: LIST
35504: LIST
35505: PUSH
35506: LD_INT 0
35508: PUSH
35509: LD_INT 1
35511: NEG
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 1
35519: PUSH
35520: LD_INT 0
35522: PUSH
35523: EMPTY
35524: LIST
35525: LIST
35526: PUSH
35527: LD_INT 1
35529: PUSH
35530: LD_INT 1
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 0
35539: PUSH
35540: LD_INT 1
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 1
35549: NEG
35550: PUSH
35551: LD_INT 0
35553: PUSH
35554: EMPTY
35555: LIST
35556: LIST
35557: PUSH
35558: LD_INT 1
35560: NEG
35561: PUSH
35562: LD_INT 1
35564: NEG
35565: PUSH
35566: EMPTY
35567: LIST
35568: LIST
35569: PUSH
35570: LD_INT 1
35572: NEG
35573: PUSH
35574: LD_INT 2
35576: NEG
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 1
35584: PUSH
35585: LD_INT 1
35587: NEG
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: LD_INT 2
35595: PUSH
35596: LD_INT 0
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 2
35605: PUSH
35606: LD_INT 1
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 2
35615: PUSH
35616: LD_INT 2
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: LD_INT 1
35625: PUSH
35626: LD_INT 2
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 1
35635: NEG
35636: PUSH
35637: LD_INT 1
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 2
35646: NEG
35647: PUSH
35648: LD_INT 0
35650: PUSH
35651: EMPTY
35652: LIST
35653: LIST
35654: PUSH
35655: LD_INT 2
35657: NEG
35658: PUSH
35659: LD_INT 1
35661: NEG
35662: PUSH
35663: EMPTY
35664: LIST
35665: LIST
35666: PUSH
35667: LD_INT 2
35669: NEG
35670: PUSH
35671: LD_INT 2
35673: NEG
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 2
35681: NEG
35682: PUSH
35683: LD_INT 3
35685: NEG
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 2
35693: PUSH
35694: LD_INT 1
35696: NEG
35697: PUSH
35698: EMPTY
35699: LIST
35700: LIST
35701: PUSH
35702: LD_INT 3
35704: PUSH
35705: LD_INT 0
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 3
35714: PUSH
35715: LD_INT 1
35717: PUSH
35718: EMPTY
35719: LIST
35720: LIST
35721: PUSH
35722: LD_INT 3
35724: PUSH
35725: LD_INT 2
35727: PUSH
35728: EMPTY
35729: LIST
35730: LIST
35731: PUSH
35732: LD_INT 3
35734: PUSH
35735: LD_INT 3
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 2
35744: PUSH
35745: LD_INT 3
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: LD_INT 2
35754: NEG
35755: PUSH
35756: LD_INT 1
35758: PUSH
35759: EMPTY
35760: LIST
35761: LIST
35762: PUSH
35763: LD_INT 3
35765: NEG
35766: PUSH
35767: LD_INT 0
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: PUSH
35774: LD_INT 3
35776: NEG
35777: PUSH
35778: LD_INT 1
35780: NEG
35781: PUSH
35782: EMPTY
35783: LIST
35784: LIST
35785: PUSH
35786: LD_INT 3
35788: NEG
35789: PUSH
35790: LD_INT 2
35792: NEG
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 3
35800: NEG
35801: PUSH
35802: LD_INT 3
35804: NEG
35805: PUSH
35806: EMPTY
35807: LIST
35808: LIST
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: LIST
35822: LIST
35823: LIST
35824: LIST
35825: LIST
35826: LIST
35827: LIST
35828: LIST
35829: LIST
35830: LIST
35831: LIST
35832: LIST
35833: LIST
35834: LIST
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: LIST
35840: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35841: LD_ADDR_VAR 0 45
35845: PUSH
35846: LD_INT 0
35848: PUSH
35849: LD_INT 0
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PUSH
35856: LD_INT 0
35858: PUSH
35859: LD_INT 1
35861: NEG
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: LD_INT 1
35869: PUSH
35870: LD_INT 0
35872: PUSH
35873: EMPTY
35874: LIST
35875: LIST
35876: PUSH
35877: LD_INT 1
35879: PUSH
35880: LD_INT 1
35882: PUSH
35883: EMPTY
35884: LIST
35885: LIST
35886: PUSH
35887: LD_INT 0
35889: PUSH
35890: LD_INT 1
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: LD_INT 1
35899: NEG
35900: PUSH
35901: LD_INT 0
35903: PUSH
35904: EMPTY
35905: LIST
35906: LIST
35907: PUSH
35908: LD_INT 1
35910: NEG
35911: PUSH
35912: LD_INT 1
35914: NEG
35915: PUSH
35916: EMPTY
35917: LIST
35918: LIST
35919: PUSH
35920: LD_INT 1
35922: NEG
35923: PUSH
35924: LD_INT 2
35926: NEG
35927: PUSH
35928: EMPTY
35929: LIST
35930: LIST
35931: PUSH
35932: LD_INT 0
35934: PUSH
35935: LD_INT 2
35937: NEG
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PUSH
35943: LD_INT 1
35945: PUSH
35946: LD_INT 1
35948: NEG
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: LD_INT 2
35956: PUSH
35957: LD_INT 1
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PUSH
35964: LD_INT 2
35966: PUSH
35967: LD_INT 2
35969: PUSH
35970: EMPTY
35971: LIST
35972: LIST
35973: PUSH
35974: LD_INT 1
35976: PUSH
35977: LD_INT 2
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: PUSH
35984: LD_INT 0
35986: PUSH
35987: LD_INT 2
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 1
35996: NEG
35997: PUSH
35998: LD_INT 1
36000: PUSH
36001: EMPTY
36002: LIST
36003: LIST
36004: PUSH
36005: LD_INT 2
36007: NEG
36008: PUSH
36009: LD_INT 1
36011: NEG
36012: PUSH
36013: EMPTY
36014: LIST
36015: LIST
36016: PUSH
36017: LD_INT 2
36019: NEG
36020: PUSH
36021: LD_INT 2
36023: NEG
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 2
36031: NEG
36032: PUSH
36033: LD_INT 3
36035: NEG
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: LD_INT 1
36043: NEG
36044: PUSH
36045: LD_INT 3
36047: NEG
36048: PUSH
36049: EMPTY
36050: LIST
36051: LIST
36052: PUSH
36053: LD_INT 0
36055: PUSH
36056: LD_INT 3
36058: NEG
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: LD_INT 1
36066: PUSH
36067: LD_INT 2
36069: NEG
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 3
36077: PUSH
36078: LD_INT 2
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 3
36087: PUSH
36088: LD_INT 3
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: LD_INT 2
36097: PUSH
36098: LD_INT 3
36100: PUSH
36101: EMPTY
36102: LIST
36103: LIST
36104: PUSH
36105: LD_INT 1
36107: PUSH
36108: LD_INT 3
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: LD_INT 0
36117: PUSH
36118: LD_INT 3
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: PUSH
36125: LD_INT 1
36127: NEG
36128: PUSH
36129: LD_INT 2
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PUSH
36136: LD_INT 3
36138: NEG
36139: PUSH
36140: LD_INT 2
36142: NEG
36143: PUSH
36144: EMPTY
36145: LIST
36146: LIST
36147: PUSH
36148: LD_INT 3
36150: NEG
36151: PUSH
36152: LD_INT 3
36154: NEG
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: LIST
36164: LIST
36165: LIST
36166: LIST
36167: LIST
36168: LIST
36169: LIST
36170: LIST
36171: LIST
36172: LIST
36173: LIST
36174: LIST
36175: LIST
36176: LIST
36177: LIST
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: LIST
36184: LIST
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36191: LD_ADDR_VAR 0 46
36195: PUSH
36196: LD_INT 0
36198: PUSH
36199: LD_INT 0
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 0
36208: PUSH
36209: LD_INT 1
36211: NEG
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: PUSH
36217: LD_INT 1
36219: PUSH
36220: LD_INT 0
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: PUSH
36227: LD_INT 1
36229: PUSH
36230: LD_INT 1
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 0
36239: PUSH
36240: LD_INT 1
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 1
36249: NEG
36250: PUSH
36251: LD_INT 0
36253: PUSH
36254: EMPTY
36255: LIST
36256: LIST
36257: PUSH
36258: LD_INT 1
36260: NEG
36261: PUSH
36262: LD_INT 1
36264: NEG
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 1
36272: NEG
36273: PUSH
36274: LD_INT 2
36276: NEG
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: PUSH
36282: LD_INT 0
36284: PUSH
36285: LD_INT 2
36287: NEG
36288: PUSH
36289: EMPTY
36290: LIST
36291: LIST
36292: PUSH
36293: LD_INT 1
36295: PUSH
36296: LD_INT 1
36298: NEG
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PUSH
36304: LD_INT 2
36306: PUSH
36307: LD_INT 0
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: LD_INT 2
36316: PUSH
36317: LD_INT 1
36319: PUSH
36320: EMPTY
36321: LIST
36322: LIST
36323: PUSH
36324: LD_INT 1
36326: PUSH
36327: LD_INT 2
36329: PUSH
36330: EMPTY
36331: LIST
36332: LIST
36333: PUSH
36334: LD_INT 0
36336: PUSH
36337: LD_INT 2
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: PUSH
36344: LD_INT 1
36346: NEG
36347: PUSH
36348: LD_INT 1
36350: PUSH
36351: EMPTY
36352: LIST
36353: LIST
36354: PUSH
36355: LD_INT 2
36357: NEG
36358: PUSH
36359: LD_INT 0
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: PUSH
36366: LD_INT 2
36368: NEG
36369: PUSH
36370: LD_INT 1
36372: NEG
36373: PUSH
36374: EMPTY
36375: LIST
36376: LIST
36377: PUSH
36378: LD_INT 1
36380: NEG
36381: PUSH
36382: LD_INT 3
36384: NEG
36385: PUSH
36386: EMPTY
36387: LIST
36388: LIST
36389: PUSH
36390: LD_INT 0
36392: PUSH
36393: LD_INT 3
36395: NEG
36396: PUSH
36397: EMPTY
36398: LIST
36399: LIST
36400: PUSH
36401: LD_INT 1
36403: PUSH
36404: LD_INT 2
36406: NEG
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 2
36414: PUSH
36415: LD_INT 1
36417: NEG
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: LD_INT 3
36425: PUSH
36426: LD_INT 0
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: LD_INT 3
36435: PUSH
36436: LD_INT 1
36438: PUSH
36439: EMPTY
36440: LIST
36441: LIST
36442: PUSH
36443: LD_INT 1
36445: PUSH
36446: LD_INT 3
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: PUSH
36453: LD_INT 0
36455: PUSH
36456: LD_INT 3
36458: PUSH
36459: EMPTY
36460: LIST
36461: LIST
36462: PUSH
36463: LD_INT 1
36465: NEG
36466: PUSH
36467: LD_INT 2
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: PUSH
36474: LD_INT 2
36476: NEG
36477: PUSH
36478: LD_INT 1
36480: PUSH
36481: EMPTY
36482: LIST
36483: LIST
36484: PUSH
36485: LD_INT 3
36487: NEG
36488: PUSH
36489: LD_INT 0
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 3
36498: NEG
36499: PUSH
36500: LD_INT 1
36502: NEG
36503: PUSH
36504: EMPTY
36505: LIST
36506: LIST
36507: PUSH
36508: EMPTY
36509: LIST
36510: LIST
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: LIST
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: LIST
36522: LIST
36523: LIST
36524: LIST
36525: LIST
36526: LIST
36527: LIST
36528: LIST
36529: LIST
36530: LIST
36531: LIST
36532: LIST
36533: LIST
36534: LIST
36535: LIST
36536: LIST
36537: LIST
36538: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36539: LD_ADDR_VAR 0 47
36543: PUSH
36544: LD_INT 0
36546: PUSH
36547: LD_INT 0
36549: PUSH
36550: EMPTY
36551: LIST
36552: LIST
36553: PUSH
36554: LD_INT 0
36556: PUSH
36557: LD_INT 1
36559: NEG
36560: PUSH
36561: EMPTY
36562: LIST
36563: LIST
36564: PUSH
36565: LD_INT 1
36567: PUSH
36568: LD_INT 0
36570: PUSH
36571: EMPTY
36572: LIST
36573: LIST
36574: PUSH
36575: LD_INT 1
36577: PUSH
36578: LD_INT 1
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 0
36587: PUSH
36588: LD_INT 1
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: PUSH
36595: LD_INT 1
36597: NEG
36598: PUSH
36599: LD_INT 0
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: LD_INT 1
36608: NEG
36609: PUSH
36610: LD_INT 1
36612: NEG
36613: PUSH
36614: EMPTY
36615: LIST
36616: LIST
36617: PUSH
36618: LD_INT 1
36620: NEG
36621: PUSH
36622: LD_INT 2
36624: NEG
36625: PUSH
36626: EMPTY
36627: LIST
36628: LIST
36629: PUSH
36630: LD_INT 0
36632: PUSH
36633: LD_INT 2
36635: NEG
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: LD_INT 1
36643: PUSH
36644: LD_INT 1
36646: NEG
36647: PUSH
36648: EMPTY
36649: LIST
36650: LIST
36651: PUSH
36652: LD_INT 2
36654: NEG
36655: PUSH
36656: LD_INT 1
36658: NEG
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: LD_INT 2
36666: NEG
36667: PUSH
36668: LD_INT 2
36670: NEG
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: EMPTY
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36690: LD_ADDR_VAR 0 48
36694: PUSH
36695: LD_INT 0
36697: PUSH
36698: LD_INT 0
36700: PUSH
36701: EMPTY
36702: LIST
36703: LIST
36704: PUSH
36705: LD_INT 0
36707: PUSH
36708: LD_INT 1
36710: NEG
36711: PUSH
36712: EMPTY
36713: LIST
36714: LIST
36715: PUSH
36716: LD_INT 1
36718: PUSH
36719: LD_INT 0
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PUSH
36726: LD_INT 1
36728: PUSH
36729: LD_INT 1
36731: PUSH
36732: EMPTY
36733: LIST
36734: LIST
36735: PUSH
36736: LD_INT 0
36738: PUSH
36739: LD_INT 1
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: PUSH
36746: LD_INT 1
36748: NEG
36749: PUSH
36750: LD_INT 0
36752: PUSH
36753: EMPTY
36754: LIST
36755: LIST
36756: PUSH
36757: LD_INT 1
36759: NEG
36760: PUSH
36761: LD_INT 1
36763: NEG
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PUSH
36769: LD_INT 1
36771: NEG
36772: PUSH
36773: LD_INT 2
36775: NEG
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 0
36783: PUSH
36784: LD_INT 2
36786: NEG
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 1
36794: PUSH
36795: LD_INT 1
36797: NEG
36798: PUSH
36799: EMPTY
36800: LIST
36801: LIST
36802: PUSH
36803: LD_INT 2
36805: PUSH
36806: LD_INT 0
36808: PUSH
36809: EMPTY
36810: LIST
36811: LIST
36812: PUSH
36813: LD_INT 2
36815: PUSH
36816: LD_INT 1
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: LIST
36827: LIST
36828: LIST
36829: LIST
36830: LIST
36831: LIST
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36837: LD_ADDR_VAR 0 49
36841: PUSH
36842: LD_INT 0
36844: PUSH
36845: LD_INT 0
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 0
36854: PUSH
36855: LD_INT 1
36857: NEG
36858: PUSH
36859: EMPTY
36860: LIST
36861: LIST
36862: PUSH
36863: LD_INT 1
36865: PUSH
36866: LD_INT 0
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PUSH
36873: LD_INT 1
36875: PUSH
36876: LD_INT 1
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 0
36885: PUSH
36886: LD_INT 1
36888: PUSH
36889: EMPTY
36890: LIST
36891: LIST
36892: PUSH
36893: LD_INT 1
36895: NEG
36896: PUSH
36897: LD_INT 0
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 1
36906: NEG
36907: PUSH
36908: LD_INT 1
36910: NEG
36911: PUSH
36912: EMPTY
36913: LIST
36914: LIST
36915: PUSH
36916: LD_INT 1
36918: PUSH
36919: LD_INT 1
36921: NEG
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: LD_INT 2
36929: PUSH
36930: LD_INT 0
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 2
36939: PUSH
36940: LD_INT 1
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 2
36949: PUSH
36950: LD_INT 2
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 1
36959: PUSH
36960: LD_INT 2
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36981: LD_ADDR_VAR 0 50
36985: PUSH
36986: LD_INT 0
36988: PUSH
36989: LD_INT 0
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 0
36998: PUSH
36999: LD_INT 1
37001: NEG
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: PUSH
37007: LD_INT 1
37009: PUSH
37010: LD_INT 0
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 1
37019: PUSH
37020: LD_INT 1
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: LD_INT 0
37029: PUSH
37030: LD_INT 1
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 1
37039: NEG
37040: PUSH
37041: LD_INT 0
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 1
37050: NEG
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 2
37062: PUSH
37063: LD_INT 1
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 2
37072: PUSH
37073: LD_INT 2
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 1
37082: PUSH
37083: LD_INT 2
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 0
37092: PUSH
37093: LD_INT 2
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 1
37102: NEG
37103: PUSH
37104: LD_INT 1
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: PUSH
37111: EMPTY
37112: LIST
37113: LIST
37114: LIST
37115: LIST
37116: LIST
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: LIST
37124: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37125: LD_ADDR_VAR 0 51
37129: PUSH
37130: LD_INT 0
37132: PUSH
37133: LD_INT 0
37135: PUSH
37136: EMPTY
37137: LIST
37138: LIST
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: LD_INT 1
37145: NEG
37146: PUSH
37147: EMPTY
37148: LIST
37149: LIST
37150: PUSH
37151: LD_INT 1
37153: PUSH
37154: LD_INT 0
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 1
37163: PUSH
37164: LD_INT 1
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 0
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PUSH
37181: LD_INT 1
37183: NEG
37184: PUSH
37185: LD_INT 0
37187: PUSH
37188: EMPTY
37189: LIST
37190: LIST
37191: PUSH
37192: LD_INT 1
37194: NEG
37195: PUSH
37196: LD_INT 1
37198: NEG
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 1
37206: PUSH
37207: LD_INT 2
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 0
37216: PUSH
37217: LD_INT 2
37219: PUSH
37220: EMPTY
37221: LIST
37222: LIST
37223: PUSH
37224: LD_INT 1
37226: NEG
37227: PUSH
37228: LD_INT 1
37230: PUSH
37231: EMPTY
37232: LIST
37233: LIST
37234: PUSH
37235: LD_INT 2
37237: NEG
37238: PUSH
37239: LD_INT 0
37241: PUSH
37242: EMPTY
37243: LIST
37244: LIST
37245: PUSH
37246: LD_INT 2
37248: NEG
37249: PUSH
37250: LD_INT 1
37252: NEG
37253: PUSH
37254: EMPTY
37255: LIST
37256: LIST
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: LIST
37262: LIST
37263: LIST
37264: LIST
37265: LIST
37266: LIST
37267: LIST
37268: LIST
37269: LIST
37270: LIST
37271: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37272: LD_ADDR_VAR 0 52
37276: PUSH
37277: LD_INT 0
37279: PUSH
37280: LD_INT 0
37282: PUSH
37283: EMPTY
37284: LIST
37285: LIST
37286: PUSH
37287: LD_INT 0
37289: PUSH
37290: LD_INT 1
37292: NEG
37293: PUSH
37294: EMPTY
37295: LIST
37296: LIST
37297: PUSH
37298: LD_INT 1
37300: PUSH
37301: LD_INT 0
37303: PUSH
37304: EMPTY
37305: LIST
37306: LIST
37307: PUSH
37308: LD_INT 1
37310: PUSH
37311: LD_INT 1
37313: PUSH
37314: EMPTY
37315: LIST
37316: LIST
37317: PUSH
37318: LD_INT 0
37320: PUSH
37321: LD_INT 1
37323: PUSH
37324: EMPTY
37325: LIST
37326: LIST
37327: PUSH
37328: LD_INT 1
37330: NEG
37331: PUSH
37332: LD_INT 0
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: PUSH
37339: LD_INT 1
37341: NEG
37342: PUSH
37343: LD_INT 1
37345: NEG
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: LD_INT 1
37353: NEG
37354: PUSH
37355: LD_INT 2
37357: NEG
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 1
37365: NEG
37366: PUSH
37367: LD_INT 1
37369: PUSH
37370: EMPTY
37371: LIST
37372: LIST
37373: PUSH
37374: LD_INT 2
37376: NEG
37377: PUSH
37378: LD_INT 0
37380: PUSH
37381: EMPTY
37382: LIST
37383: LIST
37384: PUSH
37385: LD_INT 2
37387: NEG
37388: PUSH
37389: LD_INT 1
37391: NEG
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: LD_INT 2
37399: NEG
37400: PUSH
37401: LD_INT 2
37403: NEG
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: PUSH
37409: EMPTY
37410: LIST
37411: LIST
37412: LIST
37413: LIST
37414: LIST
37415: LIST
37416: LIST
37417: LIST
37418: LIST
37419: LIST
37420: LIST
37421: LIST
37422: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37423: LD_ADDR_VAR 0 53
37427: PUSH
37428: LD_INT 0
37430: PUSH
37431: LD_INT 0
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 0
37440: PUSH
37441: LD_INT 1
37443: NEG
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 1
37451: PUSH
37452: LD_INT 0
37454: PUSH
37455: EMPTY
37456: LIST
37457: LIST
37458: PUSH
37459: LD_INT 1
37461: PUSH
37462: LD_INT 1
37464: PUSH
37465: EMPTY
37466: LIST
37467: LIST
37468: PUSH
37469: LD_INT 0
37471: PUSH
37472: LD_INT 1
37474: PUSH
37475: EMPTY
37476: LIST
37477: LIST
37478: PUSH
37479: LD_INT 1
37481: NEG
37482: PUSH
37483: LD_INT 0
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 1
37492: NEG
37493: PUSH
37494: LD_INT 1
37496: NEG
37497: PUSH
37498: EMPTY
37499: LIST
37500: LIST
37501: PUSH
37502: LD_INT 1
37504: NEG
37505: PUSH
37506: LD_INT 2
37508: NEG
37509: PUSH
37510: EMPTY
37511: LIST
37512: LIST
37513: PUSH
37514: LD_INT 0
37516: PUSH
37517: LD_INT 2
37519: NEG
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: PUSH
37525: LD_INT 1
37527: PUSH
37528: LD_INT 1
37530: NEG
37531: PUSH
37532: EMPTY
37533: LIST
37534: LIST
37535: PUSH
37536: LD_INT 2
37538: PUSH
37539: LD_INT 0
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PUSH
37546: LD_INT 2
37548: PUSH
37549: LD_INT 1
37551: PUSH
37552: EMPTY
37553: LIST
37554: LIST
37555: PUSH
37556: LD_INT 2
37558: PUSH
37559: LD_INT 2
37561: PUSH
37562: EMPTY
37563: LIST
37564: LIST
37565: PUSH
37566: LD_INT 1
37568: PUSH
37569: LD_INT 2
37571: PUSH
37572: EMPTY
37573: LIST
37574: LIST
37575: PUSH
37576: LD_INT 0
37578: PUSH
37579: LD_INT 2
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 1
37588: NEG
37589: PUSH
37590: LD_INT 1
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 2
37599: NEG
37600: PUSH
37601: LD_INT 0
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 2
37610: NEG
37611: PUSH
37612: LD_INT 1
37614: NEG
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 2
37622: NEG
37623: PUSH
37624: LD_INT 2
37626: NEG
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: LIST
37636: LIST
37637: LIST
37638: LIST
37639: LIST
37640: LIST
37641: LIST
37642: LIST
37643: LIST
37644: LIST
37645: LIST
37646: LIST
37647: LIST
37648: LIST
37649: LIST
37650: LIST
37651: LIST
37652: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37653: LD_ADDR_VAR 0 54
37657: PUSH
37658: LD_INT 0
37660: PUSH
37661: LD_INT 0
37663: PUSH
37664: EMPTY
37665: LIST
37666: LIST
37667: PUSH
37668: LD_INT 0
37670: PUSH
37671: LD_INT 1
37673: NEG
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 1
37681: PUSH
37682: LD_INT 0
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: LD_INT 1
37691: PUSH
37692: LD_INT 1
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 0
37701: PUSH
37702: LD_INT 1
37704: PUSH
37705: EMPTY
37706: LIST
37707: LIST
37708: PUSH
37709: LD_INT 1
37711: NEG
37712: PUSH
37713: LD_INT 0
37715: PUSH
37716: EMPTY
37717: LIST
37718: LIST
37719: PUSH
37720: LD_INT 1
37722: NEG
37723: PUSH
37724: LD_INT 1
37726: NEG
37727: PUSH
37728: EMPTY
37729: LIST
37730: LIST
37731: PUSH
37732: LD_INT 1
37734: NEG
37735: PUSH
37736: LD_INT 2
37738: NEG
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 0
37746: PUSH
37747: LD_INT 2
37749: NEG
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 1
37757: PUSH
37758: LD_INT 1
37760: NEG
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: LD_INT 2
37768: PUSH
37769: LD_INT 0
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: LD_INT 2
37778: PUSH
37779: LD_INT 1
37781: PUSH
37782: EMPTY
37783: LIST
37784: LIST
37785: PUSH
37786: LD_INT 2
37788: PUSH
37789: LD_INT 2
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: LD_INT 1
37798: PUSH
37799: LD_INT 2
37801: PUSH
37802: EMPTY
37803: LIST
37804: LIST
37805: PUSH
37806: LD_INT 0
37808: PUSH
37809: LD_INT 2
37811: PUSH
37812: EMPTY
37813: LIST
37814: LIST
37815: PUSH
37816: LD_INT 1
37818: NEG
37819: PUSH
37820: LD_INT 1
37822: PUSH
37823: EMPTY
37824: LIST
37825: LIST
37826: PUSH
37827: LD_INT 2
37829: NEG
37830: PUSH
37831: LD_INT 0
37833: PUSH
37834: EMPTY
37835: LIST
37836: LIST
37837: PUSH
37838: LD_INT 2
37840: NEG
37841: PUSH
37842: LD_INT 1
37844: NEG
37845: PUSH
37846: EMPTY
37847: LIST
37848: LIST
37849: PUSH
37850: LD_INT 2
37852: NEG
37853: PUSH
37854: LD_INT 2
37856: NEG
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: PUSH
37862: EMPTY
37863: LIST
37864: LIST
37865: LIST
37866: LIST
37867: LIST
37868: LIST
37869: LIST
37870: LIST
37871: LIST
37872: LIST
37873: LIST
37874: LIST
37875: LIST
37876: LIST
37877: LIST
37878: LIST
37879: LIST
37880: LIST
37881: LIST
37882: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37883: LD_ADDR_VAR 0 55
37887: PUSH
37888: LD_INT 0
37890: PUSH
37891: LD_INT 0
37893: PUSH
37894: EMPTY
37895: LIST
37896: LIST
37897: PUSH
37898: LD_INT 0
37900: PUSH
37901: LD_INT 1
37903: NEG
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 1
37911: PUSH
37912: LD_INT 0
37914: PUSH
37915: EMPTY
37916: LIST
37917: LIST
37918: PUSH
37919: LD_INT 1
37921: PUSH
37922: LD_INT 1
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 0
37931: PUSH
37932: LD_INT 1
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: LD_INT 1
37941: NEG
37942: PUSH
37943: LD_INT 0
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: LD_INT 1
37952: NEG
37953: PUSH
37954: LD_INT 1
37956: NEG
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 1
37964: NEG
37965: PUSH
37966: LD_INT 2
37968: NEG
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: LD_INT 0
37976: PUSH
37977: LD_INT 2
37979: NEG
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 1
37987: PUSH
37988: LD_INT 1
37990: NEG
37991: PUSH
37992: EMPTY
37993: LIST
37994: LIST
37995: PUSH
37996: LD_INT 2
37998: PUSH
37999: LD_INT 0
38001: PUSH
38002: EMPTY
38003: LIST
38004: LIST
38005: PUSH
38006: LD_INT 2
38008: PUSH
38009: LD_INT 1
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: LD_INT 2
38018: PUSH
38019: LD_INT 2
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 1
38028: PUSH
38029: LD_INT 2
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 0
38038: PUSH
38039: LD_INT 2
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: LD_INT 1
38048: NEG
38049: PUSH
38050: LD_INT 1
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PUSH
38057: LD_INT 2
38059: NEG
38060: PUSH
38061: LD_INT 0
38063: PUSH
38064: EMPTY
38065: LIST
38066: LIST
38067: PUSH
38068: LD_INT 2
38070: NEG
38071: PUSH
38072: LD_INT 1
38074: NEG
38075: PUSH
38076: EMPTY
38077: LIST
38078: LIST
38079: PUSH
38080: LD_INT 2
38082: NEG
38083: PUSH
38084: LD_INT 2
38086: NEG
38087: PUSH
38088: EMPTY
38089: LIST
38090: LIST
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: LIST
38096: LIST
38097: LIST
38098: LIST
38099: LIST
38100: LIST
38101: LIST
38102: LIST
38103: LIST
38104: LIST
38105: LIST
38106: LIST
38107: LIST
38108: LIST
38109: LIST
38110: LIST
38111: LIST
38112: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38113: LD_ADDR_VAR 0 56
38117: PUSH
38118: LD_INT 0
38120: PUSH
38121: LD_INT 0
38123: PUSH
38124: EMPTY
38125: LIST
38126: LIST
38127: PUSH
38128: LD_INT 0
38130: PUSH
38131: LD_INT 1
38133: NEG
38134: PUSH
38135: EMPTY
38136: LIST
38137: LIST
38138: PUSH
38139: LD_INT 1
38141: PUSH
38142: LD_INT 0
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 1
38151: PUSH
38152: LD_INT 1
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PUSH
38159: LD_INT 0
38161: PUSH
38162: LD_INT 1
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: LD_INT 1
38171: NEG
38172: PUSH
38173: LD_INT 0
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: LD_INT 1
38182: NEG
38183: PUSH
38184: LD_INT 1
38186: NEG
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 1
38194: NEG
38195: PUSH
38196: LD_INT 2
38198: NEG
38199: PUSH
38200: EMPTY
38201: LIST
38202: LIST
38203: PUSH
38204: LD_INT 0
38206: PUSH
38207: LD_INT 2
38209: NEG
38210: PUSH
38211: EMPTY
38212: LIST
38213: LIST
38214: PUSH
38215: LD_INT 1
38217: PUSH
38218: LD_INT 1
38220: NEG
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: PUSH
38226: LD_INT 2
38228: PUSH
38229: LD_INT 0
38231: PUSH
38232: EMPTY
38233: LIST
38234: LIST
38235: PUSH
38236: LD_INT 2
38238: PUSH
38239: LD_INT 1
38241: PUSH
38242: EMPTY
38243: LIST
38244: LIST
38245: PUSH
38246: LD_INT 2
38248: PUSH
38249: LD_INT 2
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: PUSH
38256: LD_INT 1
38258: PUSH
38259: LD_INT 2
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: LD_INT 0
38268: PUSH
38269: LD_INT 2
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: PUSH
38276: LD_INT 1
38278: NEG
38279: PUSH
38280: LD_INT 1
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: LD_INT 2
38289: NEG
38290: PUSH
38291: LD_INT 0
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 2
38300: NEG
38301: PUSH
38302: LD_INT 1
38304: NEG
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 2
38312: NEG
38313: PUSH
38314: LD_INT 2
38316: NEG
38317: PUSH
38318: EMPTY
38319: LIST
38320: LIST
38321: PUSH
38322: EMPTY
38323: LIST
38324: LIST
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38343: LD_ADDR_VAR 0 57
38347: PUSH
38348: LD_INT 0
38350: PUSH
38351: LD_INT 0
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 0
38360: PUSH
38361: LD_INT 1
38363: NEG
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 1
38371: PUSH
38372: LD_INT 0
38374: PUSH
38375: EMPTY
38376: LIST
38377: LIST
38378: PUSH
38379: LD_INT 1
38381: PUSH
38382: LD_INT 1
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: LD_INT 0
38391: PUSH
38392: LD_INT 1
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: PUSH
38399: LD_INT 1
38401: NEG
38402: PUSH
38403: LD_INT 0
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 1
38412: NEG
38413: PUSH
38414: LD_INT 1
38416: NEG
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 1
38424: NEG
38425: PUSH
38426: LD_INT 2
38428: NEG
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 0
38436: PUSH
38437: LD_INT 2
38439: NEG
38440: PUSH
38441: EMPTY
38442: LIST
38443: LIST
38444: PUSH
38445: LD_INT 1
38447: PUSH
38448: LD_INT 1
38450: NEG
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PUSH
38456: LD_INT 2
38458: PUSH
38459: LD_INT 0
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PUSH
38466: LD_INT 2
38468: PUSH
38469: LD_INT 1
38471: PUSH
38472: EMPTY
38473: LIST
38474: LIST
38475: PUSH
38476: LD_INT 2
38478: PUSH
38479: LD_INT 2
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: LD_INT 1
38488: PUSH
38489: LD_INT 2
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: PUSH
38496: LD_INT 0
38498: PUSH
38499: LD_INT 2
38501: PUSH
38502: EMPTY
38503: LIST
38504: LIST
38505: PUSH
38506: LD_INT 1
38508: NEG
38509: PUSH
38510: LD_INT 1
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: PUSH
38517: LD_INT 2
38519: NEG
38520: PUSH
38521: LD_INT 0
38523: PUSH
38524: EMPTY
38525: LIST
38526: LIST
38527: PUSH
38528: LD_INT 2
38530: NEG
38531: PUSH
38532: LD_INT 1
38534: NEG
38535: PUSH
38536: EMPTY
38537: LIST
38538: LIST
38539: PUSH
38540: LD_INT 2
38542: NEG
38543: PUSH
38544: LD_INT 2
38546: NEG
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: LIST
38556: LIST
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: LIST
38564: LIST
38565: LIST
38566: LIST
38567: LIST
38568: LIST
38569: LIST
38570: LIST
38571: LIST
38572: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38573: LD_ADDR_VAR 0 58
38577: PUSH
38578: LD_INT 0
38580: PUSH
38581: LD_INT 0
38583: PUSH
38584: EMPTY
38585: LIST
38586: LIST
38587: PUSH
38588: LD_INT 0
38590: PUSH
38591: LD_INT 1
38593: NEG
38594: PUSH
38595: EMPTY
38596: LIST
38597: LIST
38598: PUSH
38599: LD_INT 1
38601: PUSH
38602: LD_INT 0
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: LD_INT 1
38611: PUSH
38612: LD_INT 1
38614: PUSH
38615: EMPTY
38616: LIST
38617: LIST
38618: PUSH
38619: LD_INT 0
38621: PUSH
38622: LD_INT 1
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: PUSH
38629: LD_INT 1
38631: NEG
38632: PUSH
38633: LD_INT 0
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: PUSH
38640: LD_INT 1
38642: NEG
38643: PUSH
38644: LD_INT 1
38646: NEG
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: PUSH
38652: LD_INT 1
38654: NEG
38655: PUSH
38656: LD_INT 2
38658: NEG
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: PUSH
38664: LD_INT 0
38666: PUSH
38667: LD_INT 2
38669: NEG
38670: PUSH
38671: EMPTY
38672: LIST
38673: LIST
38674: PUSH
38675: LD_INT 1
38677: PUSH
38678: LD_INT 1
38680: NEG
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: LD_INT 2
38688: PUSH
38689: LD_INT 0
38691: PUSH
38692: EMPTY
38693: LIST
38694: LIST
38695: PUSH
38696: LD_INT 2
38698: PUSH
38699: LD_INT 1
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 2
38708: PUSH
38709: LD_INT 2
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 1
38718: PUSH
38719: LD_INT 2
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: LD_INT 0
38728: PUSH
38729: LD_INT 2
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 1
38738: NEG
38739: PUSH
38740: LD_INT 1
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 2
38749: NEG
38750: PUSH
38751: LD_INT 0
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: PUSH
38758: LD_INT 2
38760: NEG
38761: PUSH
38762: LD_INT 1
38764: NEG
38765: PUSH
38766: EMPTY
38767: LIST
38768: LIST
38769: PUSH
38770: LD_INT 2
38772: NEG
38773: PUSH
38774: LD_INT 2
38776: NEG
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: LIST
38786: LIST
38787: LIST
38788: LIST
38789: LIST
38790: LIST
38791: LIST
38792: LIST
38793: LIST
38794: LIST
38795: LIST
38796: LIST
38797: LIST
38798: LIST
38799: LIST
38800: LIST
38801: LIST
38802: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38803: LD_ADDR_VAR 0 59
38807: PUSH
38808: LD_INT 0
38810: PUSH
38811: LD_INT 0
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: LD_INT 0
38820: PUSH
38821: LD_INT 1
38823: NEG
38824: PUSH
38825: EMPTY
38826: LIST
38827: LIST
38828: PUSH
38829: LD_INT 1
38831: PUSH
38832: LD_INT 0
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: PUSH
38839: LD_INT 1
38841: PUSH
38842: LD_INT 1
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: PUSH
38849: LD_INT 0
38851: PUSH
38852: LD_INT 1
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 1
38861: NEG
38862: PUSH
38863: LD_INT 0
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: LD_INT 1
38872: NEG
38873: PUSH
38874: LD_INT 1
38876: NEG
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38891: LD_ADDR_VAR 0 60
38895: PUSH
38896: LD_INT 0
38898: PUSH
38899: LD_INT 0
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: PUSH
38906: LD_INT 0
38908: PUSH
38909: LD_INT 1
38911: NEG
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: LD_INT 1
38919: PUSH
38920: LD_INT 0
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PUSH
38927: LD_INT 1
38929: PUSH
38930: LD_INT 1
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: LD_INT 0
38939: PUSH
38940: LD_INT 1
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: LD_INT 1
38949: NEG
38950: PUSH
38951: LD_INT 0
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 1
38960: NEG
38961: PUSH
38962: LD_INT 1
38964: NEG
38965: PUSH
38966: EMPTY
38967: LIST
38968: LIST
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: LIST
38974: LIST
38975: LIST
38976: LIST
38977: LIST
38978: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38979: LD_ADDR_VAR 0 61
38983: PUSH
38984: LD_INT 0
38986: PUSH
38987: LD_INT 0
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PUSH
38994: LD_INT 0
38996: PUSH
38997: LD_INT 1
38999: NEG
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: LD_INT 1
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 1
39017: PUSH
39018: LD_INT 1
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 0
39027: PUSH
39028: LD_INT 1
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 1
39037: NEG
39038: PUSH
39039: LD_INT 0
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 1
39048: NEG
39049: PUSH
39050: LD_INT 1
39052: NEG
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39067: LD_ADDR_VAR 0 62
39071: PUSH
39072: LD_INT 0
39074: PUSH
39075: LD_INT 0
39077: PUSH
39078: EMPTY
39079: LIST
39080: LIST
39081: PUSH
39082: LD_INT 0
39084: PUSH
39085: LD_INT 1
39087: NEG
39088: PUSH
39089: EMPTY
39090: LIST
39091: LIST
39092: PUSH
39093: LD_INT 1
39095: PUSH
39096: LD_INT 0
39098: PUSH
39099: EMPTY
39100: LIST
39101: LIST
39102: PUSH
39103: LD_INT 1
39105: PUSH
39106: LD_INT 1
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: LD_INT 0
39115: PUSH
39116: LD_INT 1
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PUSH
39123: LD_INT 1
39125: NEG
39126: PUSH
39127: LD_INT 0
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 1
39136: NEG
39137: PUSH
39138: LD_INT 1
39140: NEG
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: LIST
39150: LIST
39151: LIST
39152: LIST
39153: LIST
39154: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39155: LD_ADDR_VAR 0 63
39159: PUSH
39160: LD_INT 0
39162: PUSH
39163: LD_INT 0
39165: PUSH
39166: EMPTY
39167: LIST
39168: LIST
39169: PUSH
39170: LD_INT 0
39172: PUSH
39173: LD_INT 1
39175: NEG
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: PUSH
39181: LD_INT 1
39183: PUSH
39184: LD_INT 0
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: PUSH
39191: LD_INT 1
39193: PUSH
39194: LD_INT 1
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 0
39203: PUSH
39204: LD_INT 1
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PUSH
39211: LD_INT 1
39213: NEG
39214: PUSH
39215: LD_INT 0
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PUSH
39222: LD_INT 1
39224: NEG
39225: PUSH
39226: LD_INT 1
39228: NEG
39229: PUSH
39230: EMPTY
39231: LIST
39232: LIST
39233: PUSH
39234: EMPTY
39235: LIST
39236: LIST
39237: LIST
39238: LIST
39239: LIST
39240: LIST
39241: LIST
39242: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39243: LD_ADDR_VAR 0 64
39247: PUSH
39248: LD_INT 0
39250: PUSH
39251: LD_INT 0
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 0
39260: PUSH
39261: LD_INT 1
39263: NEG
39264: PUSH
39265: EMPTY
39266: LIST
39267: LIST
39268: PUSH
39269: LD_INT 1
39271: PUSH
39272: LD_INT 0
39274: PUSH
39275: EMPTY
39276: LIST
39277: LIST
39278: PUSH
39279: LD_INT 1
39281: PUSH
39282: LD_INT 1
39284: PUSH
39285: EMPTY
39286: LIST
39287: LIST
39288: PUSH
39289: LD_INT 0
39291: PUSH
39292: LD_INT 1
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: LD_INT 1
39301: NEG
39302: PUSH
39303: LD_INT 0
39305: PUSH
39306: EMPTY
39307: LIST
39308: LIST
39309: PUSH
39310: LD_INT 1
39312: NEG
39313: PUSH
39314: LD_INT 1
39316: NEG
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: LIST
39326: LIST
39327: LIST
39328: LIST
39329: LIST
39330: ST_TO_ADDR
// end ; 1 :
39331: GO 45228
39333: LD_INT 1
39335: DOUBLE
39336: EQUAL
39337: IFTRUE 39341
39339: GO 41964
39341: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39342: LD_ADDR_VAR 0 11
39346: PUSH
39347: LD_INT 1
39349: NEG
39350: PUSH
39351: LD_INT 3
39353: NEG
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: LD_INT 0
39361: PUSH
39362: LD_INT 3
39364: NEG
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: LD_INT 1
39372: PUSH
39373: LD_INT 2
39375: NEG
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: LIST
39385: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39386: LD_ADDR_VAR 0 12
39390: PUSH
39391: LD_INT 2
39393: PUSH
39394: LD_INT 1
39396: NEG
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: LD_INT 3
39404: PUSH
39405: LD_INT 0
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 3
39414: PUSH
39415: LD_INT 1
39417: PUSH
39418: EMPTY
39419: LIST
39420: LIST
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: LIST
39426: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39427: LD_ADDR_VAR 0 13
39431: PUSH
39432: LD_INT 3
39434: PUSH
39435: LD_INT 2
39437: PUSH
39438: EMPTY
39439: LIST
39440: LIST
39441: PUSH
39442: LD_INT 3
39444: PUSH
39445: LD_INT 3
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 2
39454: PUSH
39455: LD_INT 3
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PUSH
39462: EMPTY
39463: LIST
39464: LIST
39465: LIST
39466: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39467: LD_ADDR_VAR 0 14
39471: PUSH
39472: LD_INT 1
39474: PUSH
39475: LD_INT 3
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 0
39484: PUSH
39485: LD_INT 3
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 1
39494: NEG
39495: PUSH
39496: LD_INT 2
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: LIST
39507: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39508: LD_ADDR_VAR 0 15
39512: PUSH
39513: LD_INT 2
39515: NEG
39516: PUSH
39517: LD_INT 1
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: LD_INT 3
39526: NEG
39527: PUSH
39528: LD_INT 0
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: LD_INT 3
39537: NEG
39538: PUSH
39539: LD_INT 1
39541: NEG
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: LIST
39551: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39552: LD_ADDR_VAR 0 16
39556: PUSH
39557: LD_INT 2
39559: NEG
39560: PUSH
39561: LD_INT 3
39563: NEG
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: PUSH
39569: LD_INT 3
39571: NEG
39572: PUSH
39573: LD_INT 2
39575: NEG
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: LD_INT 3
39583: NEG
39584: PUSH
39585: LD_INT 3
39587: NEG
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: LIST
39597: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39598: LD_ADDR_VAR 0 17
39602: PUSH
39603: LD_INT 1
39605: NEG
39606: PUSH
39607: LD_INT 3
39609: NEG
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 0
39617: PUSH
39618: LD_INT 3
39620: NEG
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: LD_INT 1
39628: PUSH
39629: LD_INT 2
39631: NEG
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: LIST
39641: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39642: LD_ADDR_VAR 0 18
39646: PUSH
39647: LD_INT 2
39649: PUSH
39650: LD_INT 1
39652: NEG
39653: PUSH
39654: EMPTY
39655: LIST
39656: LIST
39657: PUSH
39658: LD_INT 3
39660: PUSH
39661: LD_INT 0
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PUSH
39668: LD_INT 3
39670: PUSH
39671: LD_INT 1
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: LIST
39682: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39683: LD_ADDR_VAR 0 19
39687: PUSH
39688: LD_INT 3
39690: PUSH
39691: LD_INT 2
39693: PUSH
39694: EMPTY
39695: LIST
39696: LIST
39697: PUSH
39698: LD_INT 3
39700: PUSH
39701: LD_INT 3
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: LD_INT 2
39710: PUSH
39711: LD_INT 3
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: LIST
39722: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39723: LD_ADDR_VAR 0 20
39727: PUSH
39728: LD_INT 1
39730: PUSH
39731: LD_INT 3
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 0
39740: PUSH
39741: LD_INT 3
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: PUSH
39748: LD_INT 1
39750: NEG
39751: PUSH
39752: LD_INT 2
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: EMPTY
39760: LIST
39761: LIST
39762: LIST
39763: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39764: LD_ADDR_VAR 0 21
39768: PUSH
39769: LD_INT 2
39771: NEG
39772: PUSH
39773: LD_INT 1
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 3
39782: NEG
39783: PUSH
39784: LD_INT 0
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 3
39793: NEG
39794: PUSH
39795: LD_INT 1
39797: NEG
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: LIST
39807: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39808: LD_ADDR_VAR 0 22
39812: PUSH
39813: LD_INT 2
39815: NEG
39816: PUSH
39817: LD_INT 3
39819: NEG
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: LD_INT 3
39827: NEG
39828: PUSH
39829: LD_INT 2
39831: NEG
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 3
39839: NEG
39840: PUSH
39841: LD_INT 3
39843: NEG
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: EMPTY
39850: LIST
39851: LIST
39852: LIST
39853: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39854: LD_ADDR_VAR 0 23
39858: PUSH
39859: LD_INT 0
39861: PUSH
39862: LD_INT 3
39864: NEG
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: PUSH
39870: LD_INT 1
39872: NEG
39873: PUSH
39874: LD_INT 4
39876: NEG
39877: PUSH
39878: EMPTY
39879: LIST
39880: LIST
39881: PUSH
39882: LD_INT 1
39884: PUSH
39885: LD_INT 3
39887: NEG
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: LIST
39897: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39898: LD_ADDR_VAR 0 24
39902: PUSH
39903: LD_INT 3
39905: PUSH
39906: LD_INT 0
39908: PUSH
39909: EMPTY
39910: LIST
39911: LIST
39912: PUSH
39913: LD_INT 3
39915: PUSH
39916: LD_INT 1
39918: NEG
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PUSH
39924: LD_INT 4
39926: PUSH
39927: LD_INT 1
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: LIST
39938: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39939: LD_ADDR_VAR 0 25
39943: PUSH
39944: LD_INT 3
39946: PUSH
39947: LD_INT 3
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: LD_INT 4
39956: PUSH
39957: LD_INT 3
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 3
39966: PUSH
39967: LD_INT 4
39969: PUSH
39970: EMPTY
39971: LIST
39972: LIST
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: LIST
39978: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39979: LD_ADDR_VAR 0 26
39983: PUSH
39984: LD_INT 0
39986: PUSH
39987: LD_INT 3
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: PUSH
39994: LD_INT 1
39996: PUSH
39997: LD_INT 4
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: PUSH
40004: LD_INT 1
40006: NEG
40007: PUSH
40008: LD_INT 3
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: EMPTY
40016: LIST
40017: LIST
40018: LIST
40019: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40020: LD_ADDR_VAR 0 27
40024: PUSH
40025: LD_INT 3
40027: NEG
40028: PUSH
40029: LD_INT 0
40031: PUSH
40032: EMPTY
40033: LIST
40034: LIST
40035: PUSH
40036: LD_INT 3
40038: NEG
40039: PUSH
40040: LD_INT 1
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 4
40049: NEG
40050: PUSH
40051: LD_INT 1
40053: NEG
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PUSH
40059: EMPTY
40060: LIST
40061: LIST
40062: LIST
40063: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40064: LD_ADDR_VAR 0 28
40068: PUSH
40069: LD_INT 3
40071: NEG
40072: PUSH
40073: LD_INT 3
40075: NEG
40076: PUSH
40077: EMPTY
40078: LIST
40079: LIST
40080: PUSH
40081: LD_INT 3
40083: NEG
40084: PUSH
40085: LD_INT 4
40087: NEG
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 4
40095: NEG
40096: PUSH
40097: LD_INT 3
40099: NEG
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: LIST
40109: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40110: LD_ADDR_VAR 0 29
40114: PUSH
40115: LD_INT 1
40117: NEG
40118: PUSH
40119: LD_INT 3
40121: NEG
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: LD_INT 0
40129: PUSH
40130: LD_INT 3
40132: NEG
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: LD_INT 1
40140: PUSH
40141: LD_INT 2
40143: NEG
40144: PUSH
40145: EMPTY
40146: LIST
40147: LIST
40148: PUSH
40149: LD_INT 1
40151: NEG
40152: PUSH
40153: LD_INT 4
40155: NEG
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PUSH
40161: LD_INT 0
40163: PUSH
40164: LD_INT 4
40166: NEG
40167: PUSH
40168: EMPTY
40169: LIST
40170: LIST
40171: PUSH
40172: LD_INT 1
40174: PUSH
40175: LD_INT 3
40177: NEG
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: LD_INT 1
40185: NEG
40186: PUSH
40187: LD_INT 5
40189: NEG
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: LD_INT 0
40197: PUSH
40198: LD_INT 5
40200: NEG
40201: PUSH
40202: EMPTY
40203: LIST
40204: LIST
40205: PUSH
40206: LD_INT 1
40208: PUSH
40209: LD_INT 4
40211: NEG
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 1
40219: NEG
40220: PUSH
40221: LD_INT 6
40223: NEG
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 0
40231: PUSH
40232: LD_INT 6
40234: NEG
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PUSH
40240: LD_INT 1
40242: PUSH
40243: LD_INT 5
40245: NEG
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: LIST
40255: LIST
40256: LIST
40257: LIST
40258: LIST
40259: LIST
40260: LIST
40261: LIST
40262: LIST
40263: LIST
40264: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40265: LD_ADDR_VAR 0 30
40269: PUSH
40270: LD_INT 2
40272: PUSH
40273: LD_INT 1
40275: NEG
40276: PUSH
40277: EMPTY
40278: LIST
40279: LIST
40280: PUSH
40281: LD_INT 3
40283: PUSH
40284: LD_INT 0
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 3
40293: PUSH
40294: LD_INT 1
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 3
40303: PUSH
40304: LD_INT 1
40306: NEG
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PUSH
40312: LD_INT 4
40314: PUSH
40315: LD_INT 0
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 4
40324: PUSH
40325: LD_INT 1
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 4
40334: PUSH
40335: LD_INT 1
40337: NEG
40338: PUSH
40339: EMPTY
40340: LIST
40341: LIST
40342: PUSH
40343: LD_INT 5
40345: PUSH
40346: LD_INT 0
40348: PUSH
40349: EMPTY
40350: LIST
40351: LIST
40352: PUSH
40353: LD_INT 5
40355: PUSH
40356: LD_INT 1
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: PUSH
40363: LD_INT 5
40365: PUSH
40366: LD_INT 1
40368: NEG
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 6
40376: PUSH
40377: LD_INT 0
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: LD_INT 6
40386: PUSH
40387: LD_INT 1
40389: PUSH
40390: EMPTY
40391: LIST
40392: LIST
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: LIST
40405: LIST
40406: LIST
40407: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40408: LD_ADDR_VAR 0 31
40412: PUSH
40413: LD_INT 3
40415: PUSH
40416: LD_INT 2
40418: PUSH
40419: EMPTY
40420: LIST
40421: LIST
40422: PUSH
40423: LD_INT 3
40425: PUSH
40426: LD_INT 3
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 2
40435: PUSH
40436: LD_INT 3
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: PUSH
40443: LD_INT 4
40445: PUSH
40446: LD_INT 3
40448: PUSH
40449: EMPTY
40450: LIST
40451: LIST
40452: PUSH
40453: LD_INT 4
40455: PUSH
40456: LD_INT 4
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: PUSH
40463: LD_INT 3
40465: PUSH
40466: LD_INT 4
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: PUSH
40473: LD_INT 5
40475: PUSH
40476: LD_INT 4
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: LD_INT 5
40485: PUSH
40486: LD_INT 5
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: PUSH
40493: LD_INT 4
40495: PUSH
40496: LD_INT 5
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: PUSH
40503: LD_INT 6
40505: PUSH
40506: LD_INT 5
40508: PUSH
40509: EMPTY
40510: LIST
40511: LIST
40512: PUSH
40513: LD_INT 6
40515: PUSH
40516: LD_INT 6
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: LD_INT 5
40525: PUSH
40526: LD_INT 6
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40547: LD_ADDR_VAR 0 32
40551: PUSH
40552: LD_INT 1
40554: PUSH
40555: LD_INT 3
40557: PUSH
40558: EMPTY
40559: LIST
40560: LIST
40561: PUSH
40562: LD_INT 0
40564: PUSH
40565: LD_INT 3
40567: PUSH
40568: EMPTY
40569: LIST
40570: LIST
40571: PUSH
40572: LD_INT 1
40574: NEG
40575: PUSH
40576: LD_INT 2
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PUSH
40583: LD_INT 1
40585: PUSH
40586: LD_INT 4
40588: PUSH
40589: EMPTY
40590: LIST
40591: LIST
40592: PUSH
40593: LD_INT 0
40595: PUSH
40596: LD_INT 4
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: LD_INT 1
40605: NEG
40606: PUSH
40607: LD_INT 3
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 1
40616: PUSH
40617: LD_INT 5
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 0
40626: PUSH
40627: LD_INT 5
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: LD_INT 1
40636: NEG
40637: PUSH
40638: LD_INT 4
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 1
40647: PUSH
40648: LD_INT 6
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 0
40657: PUSH
40658: LD_INT 6
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 1
40667: NEG
40668: PUSH
40669: LD_INT 5
40671: PUSH
40672: EMPTY
40673: LIST
40674: LIST
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: LIST
40680: LIST
40681: LIST
40682: LIST
40683: LIST
40684: LIST
40685: LIST
40686: LIST
40687: LIST
40688: LIST
40689: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40690: LD_ADDR_VAR 0 33
40694: PUSH
40695: LD_INT 2
40697: NEG
40698: PUSH
40699: LD_INT 1
40701: PUSH
40702: EMPTY
40703: LIST
40704: LIST
40705: PUSH
40706: LD_INT 3
40708: NEG
40709: PUSH
40710: LD_INT 0
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 3
40719: NEG
40720: PUSH
40721: LD_INT 1
40723: NEG
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: PUSH
40729: LD_INT 3
40731: NEG
40732: PUSH
40733: LD_INT 1
40735: PUSH
40736: EMPTY
40737: LIST
40738: LIST
40739: PUSH
40740: LD_INT 4
40742: NEG
40743: PUSH
40744: LD_INT 0
40746: PUSH
40747: EMPTY
40748: LIST
40749: LIST
40750: PUSH
40751: LD_INT 4
40753: NEG
40754: PUSH
40755: LD_INT 1
40757: NEG
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 4
40765: NEG
40766: PUSH
40767: LD_INT 1
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 5
40776: NEG
40777: PUSH
40778: LD_INT 0
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: LD_INT 5
40787: NEG
40788: PUSH
40789: LD_INT 1
40791: NEG
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 5
40799: NEG
40800: PUSH
40801: LD_INT 1
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 6
40810: NEG
40811: PUSH
40812: LD_INT 0
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: PUSH
40819: LD_INT 6
40821: NEG
40822: PUSH
40823: LD_INT 1
40825: NEG
40826: PUSH
40827: EMPTY
40828: LIST
40829: LIST
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: LIST
40835: LIST
40836: LIST
40837: LIST
40838: LIST
40839: LIST
40840: LIST
40841: LIST
40842: LIST
40843: LIST
40844: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40845: LD_ADDR_VAR 0 34
40849: PUSH
40850: LD_INT 2
40852: NEG
40853: PUSH
40854: LD_INT 3
40856: NEG
40857: PUSH
40858: EMPTY
40859: LIST
40860: LIST
40861: PUSH
40862: LD_INT 3
40864: NEG
40865: PUSH
40866: LD_INT 2
40868: NEG
40869: PUSH
40870: EMPTY
40871: LIST
40872: LIST
40873: PUSH
40874: LD_INT 3
40876: NEG
40877: PUSH
40878: LD_INT 3
40880: NEG
40881: PUSH
40882: EMPTY
40883: LIST
40884: LIST
40885: PUSH
40886: LD_INT 3
40888: NEG
40889: PUSH
40890: LD_INT 4
40892: NEG
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: LD_INT 4
40900: NEG
40901: PUSH
40902: LD_INT 3
40904: NEG
40905: PUSH
40906: EMPTY
40907: LIST
40908: LIST
40909: PUSH
40910: LD_INT 4
40912: NEG
40913: PUSH
40914: LD_INT 4
40916: NEG
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: PUSH
40922: LD_INT 4
40924: NEG
40925: PUSH
40926: LD_INT 5
40928: NEG
40929: PUSH
40930: EMPTY
40931: LIST
40932: LIST
40933: PUSH
40934: LD_INT 5
40936: NEG
40937: PUSH
40938: LD_INT 4
40940: NEG
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: PUSH
40946: LD_INT 5
40948: NEG
40949: PUSH
40950: LD_INT 5
40952: NEG
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: PUSH
40958: LD_INT 5
40960: NEG
40961: PUSH
40962: LD_INT 6
40964: NEG
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PUSH
40970: LD_INT 6
40972: NEG
40973: PUSH
40974: LD_INT 5
40976: NEG
40977: PUSH
40978: EMPTY
40979: LIST
40980: LIST
40981: PUSH
40982: LD_INT 6
40984: NEG
40985: PUSH
40986: LD_INT 6
40988: NEG
40989: PUSH
40990: EMPTY
40991: LIST
40992: LIST
40993: PUSH
40994: EMPTY
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41008: LD_ADDR_VAR 0 41
41012: PUSH
41013: LD_INT 0
41015: PUSH
41016: LD_INT 2
41018: NEG
41019: PUSH
41020: EMPTY
41021: LIST
41022: LIST
41023: PUSH
41024: LD_INT 1
41026: NEG
41027: PUSH
41028: LD_INT 3
41030: NEG
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 1
41038: PUSH
41039: LD_INT 2
41041: NEG
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: LIST
41051: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41052: LD_ADDR_VAR 0 42
41056: PUSH
41057: LD_INT 2
41059: PUSH
41060: LD_INT 0
41062: PUSH
41063: EMPTY
41064: LIST
41065: LIST
41066: PUSH
41067: LD_INT 2
41069: PUSH
41070: LD_INT 1
41072: NEG
41073: PUSH
41074: EMPTY
41075: LIST
41076: LIST
41077: PUSH
41078: LD_INT 3
41080: PUSH
41081: LD_INT 1
41083: PUSH
41084: EMPTY
41085: LIST
41086: LIST
41087: PUSH
41088: EMPTY
41089: LIST
41090: LIST
41091: LIST
41092: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41093: LD_ADDR_VAR 0 43
41097: PUSH
41098: LD_INT 2
41100: PUSH
41101: LD_INT 2
41103: PUSH
41104: EMPTY
41105: LIST
41106: LIST
41107: PUSH
41108: LD_INT 3
41110: PUSH
41111: LD_INT 2
41113: PUSH
41114: EMPTY
41115: LIST
41116: LIST
41117: PUSH
41118: LD_INT 2
41120: PUSH
41121: LD_INT 3
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: LIST
41132: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41133: LD_ADDR_VAR 0 44
41137: PUSH
41138: LD_INT 0
41140: PUSH
41141: LD_INT 2
41143: PUSH
41144: EMPTY
41145: LIST
41146: LIST
41147: PUSH
41148: LD_INT 1
41150: PUSH
41151: LD_INT 3
41153: PUSH
41154: EMPTY
41155: LIST
41156: LIST
41157: PUSH
41158: LD_INT 1
41160: NEG
41161: PUSH
41162: LD_INT 2
41164: PUSH
41165: EMPTY
41166: LIST
41167: LIST
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: LIST
41173: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41174: LD_ADDR_VAR 0 45
41178: PUSH
41179: LD_INT 2
41181: NEG
41182: PUSH
41183: LD_INT 0
41185: PUSH
41186: EMPTY
41187: LIST
41188: LIST
41189: PUSH
41190: LD_INT 2
41192: NEG
41193: PUSH
41194: LD_INT 1
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: LD_INT 3
41203: NEG
41204: PUSH
41205: LD_INT 1
41207: NEG
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: LIST
41217: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41218: LD_ADDR_VAR 0 46
41222: PUSH
41223: LD_INT 2
41225: NEG
41226: PUSH
41227: LD_INT 2
41229: NEG
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: LD_INT 2
41237: NEG
41238: PUSH
41239: LD_INT 3
41241: NEG
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 3
41249: NEG
41250: PUSH
41251: LD_INT 2
41253: NEG
41254: PUSH
41255: EMPTY
41256: LIST
41257: LIST
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: LIST
41263: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41264: LD_ADDR_VAR 0 47
41268: PUSH
41269: LD_INT 2
41271: NEG
41272: PUSH
41273: LD_INT 3
41275: NEG
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 1
41283: NEG
41284: PUSH
41285: LD_INT 3
41287: NEG
41288: PUSH
41289: EMPTY
41290: LIST
41291: LIST
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41297: LD_ADDR_VAR 0 48
41301: PUSH
41302: LD_INT 1
41304: PUSH
41305: LD_INT 2
41307: NEG
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: PUSH
41313: LD_INT 2
41315: PUSH
41316: LD_INT 1
41318: NEG
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41328: LD_ADDR_VAR 0 49
41332: PUSH
41333: LD_INT 3
41335: PUSH
41336: LD_INT 1
41338: PUSH
41339: EMPTY
41340: LIST
41341: LIST
41342: PUSH
41343: LD_INT 3
41345: PUSH
41346: LD_INT 2
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41357: LD_ADDR_VAR 0 50
41361: PUSH
41362: LD_INT 2
41364: PUSH
41365: LD_INT 3
41367: PUSH
41368: EMPTY
41369: LIST
41370: LIST
41371: PUSH
41372: LD_INT 1
41374: PUSH
41375: LD_INT 3
41377: PUSH
41378: EMPTY
41379: LIST
41380: LIST
41381: PUSH
41382: EMPTY
41383: LIST
41384: LIST
41385: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41386: LD_ADDR_VAR 0 51
41390: PUSH
41391: LD_INT 1
41393: NEG
41394: PUSH
41395: LD_INT 2
41397: PUSH
41398: EMPTY
41399: LIST
41400: LIST
41401: PUSH
41402: LD_INT 2
41404: NEG
41405: PUSH
41406: LD_INT 1
41408: PUSH
41409: EMPTY
41410: LIST
41411: LIST
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41417: LD_ADDR_VAR 0 52
41421: PUSH
41422: LD_INT 3
41424: NEG
41425: PUSH
41426: LD_INT 1
41428: NEG
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: PUSH
41434: LD_INT 3
41436: NEG
41437: PUSH
41438: LD_INT 2
41440: NEG
41441: PUSH
41442: EMPTY
41443: LIST
41444: LIST
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41450: LD_ADDR_VAR 0 53
41454: PUSH
41455: LD_INT 1
41457: NEG
41458: PUSH
41459: LD_INT 3
41461: NEG
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: LD_INT 0
41469: PUSH
41470: LD_INT 3
41472: NEG
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 1
41480: PUSH
41481: LD_INT 2
41483: NEG
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: EMPTY
41490: LIST
41491: LIST
41492: LIST
41493: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41494: LD_ADDR_VAR 0 54
41498: PUSH
41499: LD_INT 2
41501: PUSH
41502: LD_INT 1
41504: NEG
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: LD_INT 3
41512: PUSH
41513: LD_INT 0
41515: PUSH
41516: EMPTY
41517: LIST
41518: LIST
41519: PUSH
41520: LD_INT 3
41522: PUSH
41523: LD_INT 1
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: LIST
41534: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41535: LD_ADDR_VAR 0 55
41539: PUSH
41540: LD_INT 3
41542: PUSH
41543: LD_INT 2
41545: PUSH
41546: EMPTY
41547: LIST
41548: LIST
41549: PUSH
41550: LD_INT 3
41552: PUSH
41553: LD_INT 3
41555: PUSH
41556: EMPTY
41557: LIST
41558: LIST
41559: PUSH
41560: LD_INT 2
41562: PUSH
41563: LD_INT 3
41565: PUSH
41566: EMPTY
41567: LIST
41568: LIST
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: LIST
41574: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41575: LD_ADDR_VAR 0 56
41579: PUSH
41580: LD_INT 1
41582: PUSH
41583: LD_INT 3
41585: PUSH
41586: EMPTY
41587: LIST
41588: LIST
41589: PUSH
41590: LD_INT 0
41592: PUSH
41593: LD_INT 3
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: PUSH
41600: LD_INT 1
41602: NEG
41603: PUSH
41604: LD_INT 2
41606: PUSH
41607: EMPTY
41608: LIST
41609: LIST
41610: PUSH
41611: EMPTY
41612: LIST
41613: LIST
41614: LIST
41615: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41616: LD_ADDR_VAR 0 57
41620: PUSH
41621: LD_INT 2
41623: NEG
41624: PUSH
41625: LD_INT 1
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: LD_INT 3
41634: NEG
41635: PUSH
41636: LD_INT 0
41638: PUSH
41639: EMPTY
41640: LIST
41641: LIST
41642: PUSH
41643: LD_INT 3
41645: NEG
41646: PUSH
41647: LD_INT 1
41649: NEG
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: LIST
41659: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41660: LD_ADDR_VAR 0 58
41664: PUSH
41665: LD_INT 2
41667: NEG
41668: PUSH
41669: LD_INT 3
41671: NEG
41672: PUSH
41673: EMPTY
41674: LIST
41675: LIST
41676: PUSH
41677: LD_INT 3
41679: NEG
41680: PUSH
41681: LD_INT 2
41683: NEG
41684: PUSH
41685: EMPTY
41686: LIST
41687: LIST
41688: PUSH
41689: LD_INT 3
41691: NEG
41692: PUSH
41693: LD_INT 3
41695: NEG
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: PUSH
41701: EMPTY
41702: LIST
41703: LIST
41704: LIST
41705: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41706: LD_ADDR_VAR 0 59
41710: PUSH
41711: LD_INT 1
41713: NEG
41714: PUSH
41715: LD_INT 2
41717: NEG
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PUSH
41723: LD_INT 0
41725: PUSH
41726: LD_INT 2
41728: NEG
41729: PUSH
41730: EMPTY
41731: LIST
41732: LIST
41733: PUSH
41734: LD_INT 1
41736: PUSH
41737: LD_INT 1
41739: NEG
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: LIST
41749: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41750: LD_ADDR_VAR 0 60
41754: PUSH
41755: LD_INT 1
41757: PUSH
41758: LD_INT 1
41760: NEG
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: PUSH
41766: LD_INT 2
41768: PUSH
41769: LD_INT 0
41771: PUSH
41772: EMPTY
41773: LIST
41774: LIST
41775: PUSH
41776: LD_INT 2
41778: PUSH
41779: LD_INT 1
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: PUSH
41786: EMPTY
41787: LIST
41788: LIST
41789: LIST
41790: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41791: LD_ADDR_VAR 0 61
41795: PUSH
41796: LD_INT 2
41798: PUSH
41799: LD_INT 1
41801: PUSH
41802: EMPTY
41803: LIST
41804: LIST
41805: PUSH
41806: LD_INT 2
41808: PUSH
41809: LD_INT 2
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: LD_INT 1
41818: PUSH
41819: LD_INT 2
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: LIST
41830: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41831: LD_ADDR_VAR 0 62
41835: PUSH
41836: LD_INT 1
41838: PUSH
41839: LD_INT 2
41841: PUSH
41842: EMPTY
41843: LIST
41844: LIST
41845: PUSH
41846: LD_INT 0
41848: PUSH
41849: LD_INT 2
41851: PUSH
41852: EMPTY
41853: LIST
41854: LIST
41855: PUSH
41856: LD_INT 1
41858: NEG
41859: PUSH
41860: LD_INT 1
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PUSH
41867: EMPTY
41868: LIST
41869: LIST
41870: LIST
41871: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41872: LD_ADDR_VAR 0 63
41876: PUSH
41877: LD_INT 1
41879: NEG
41880: PUSH
41881: LD_INT 1
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: PUSH
41888: LD_INT 2
41890: NEG
41891: PUSH
41892: LD_INT 0
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: LD_INT 2
41901: NEG
41902: PUSH
41903: LD_INT 1
41905: NEG
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: LIST
41915: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41916: LD_ADDR_VAR 0 64
41920: PUSH
41921: LD_INT 1
41923: NEG
41924: PUSH
41925: LD_INT 2
41927: NEG
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: LD_INT 2
41935: NEG
41936: PUSH
41937: LD_INT 1
41939: NEG
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: PUSH
41945: LD_INT 2
41947: NEG
41948: PUSH
41949: LD_INT 2
41951: NEG
41952: PUSH
41953: EMPTY
41954: LIST
41955: LIST
41956: PUSH
41957: EMPTY
41958: LIST
41959: LIST
41960: LIST
41961: ST_TO_ADDR
// end ; 2 :
41962: GO 45228
41964: LD_INT 2
41966: DOUBLE
41967: EQUAL
41968: IFTRUE 41972
41970: GO 45227
41972: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41973: LD_ADDR_VAR 0 29
41977: PUSH
41978: LD_INT 4
41980: PUSH
41981: LD_INT 0
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: LD_INT 4
41990: PUSH
41991: LD_INT 1
41993: NEG
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: LD_INT 5
42001: PUSH
42002: LD_INT 0
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 5
42011: PUSH
42012: LD_INT 1
42014: PUSH
42015: EMPTY
42016: LIST
42017: LIST
42018: PUSH
42019: LD_INT 4
42021: PUSH
42022: LD_INT 1
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: LD_INT 3
42031: PUSH
42032: LD_INT 0
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 3
42041: PUSH
42042: LD_INT 1
42044: NEG
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 3
42052: PUSH
42053: LD_INT 2
42055: NEG
42056: PUSH
42057: EMPTY
42058: LIST
42059: LIST
42060: PUSH
42061: LD_INT 5
42063: PUSH
42064: LD_INT 2
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: PUSH
42071: LD_INT 3
42073: PUSH
42074: LD_INT 3
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 3
42083: PUSH
42084: LD_INT 2
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: LD_INT 4
42093: PUSH
42094: LD_INT 3
42096: PUSH
42097: EMPTY
42098: LIST
42099: LIST
42100: PUSH
42101: LD_INT 4
42103: PUSH
42104: LD_INT 4
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 3
42113: PUSH
42114: LD_INT 4
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 2
42123: PUSH
42124: LD_INT 3
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: LD_INT 2
42133: PUSH
42134: LD_INT 2
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 4
42143: PUSH
42144: LD_INT 2
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 2
42153: PUSH
42154: LD_INT 4
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 0
42163: PUSH
42164: LD_INT 4
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 0
42173: PUSH
42174: LD_INT 3
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 1
42183: PUSH
42184: LD_INT 4
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_INT 1
42193: PUSH
42194: LD_INT 5
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 0
42203: PUSH
42204: LD_INT 5
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 1
42213: NEG
42214: PUSH
42215: LD_INT 4
42217: PUSH
42218: EMPTY
42219: LIST
42220: LIST
42221: PUSH
42222: LD_INT 1
42224: NEG
42225: PUSH
42226: LD_INT 3
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 2
42235: PUSH
42236: LD_INT 5
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 2
42245: NEG
42246: PUSH
42247: LD_INT 3
42249: PUSH
42250: EMPTY
42251: LIST
42252: LIST
42253: PUSH
42254: LD_INT 3
42256: NEG
42257: PUSH
42258: LD_INT 0
42260: PUSH
42261: EMPTY
42262: LIST
42263: LIST
42264: PUSH
42265: LD_INT 3
42267: NEG
42268: PUSH
42269: LD_INT 1
42271: NEG
42272: PUSH
42273: EMPTY
42274: LIST
42275: LIST
42276: PUSH
42277: LD_INT 2
42279: NEG
42280: PUSH
42281: LD_INT 0
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: PUSH
42288: LD_INT 2
42290: NEG
42291: PUSH
42292: LD_INT 1
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 3
42301: NEG
42302: PUSH
42303: LD_INT 1
42305: PUSH
42306: EMPTY
42307: LIST
42308: LIST
42309: PUSH
42310: LD_INT 4
42312: NEG
42313: PUSH
42314: LD_INT 0
42316: PUSH
42317: EMPTY
42318: LIST
42319: LIST
42320: PUSH
42321: LD_INT 4
42323: NEG
42324: PUSH
42325: LD_INT 1
42327: NEG
42328: PUSH
42329: EMPTY
42330: LIST
42331: LIST
42332: PUSH
42333: LD_INT 4
42335: NEG
42336: PUSH
42337: LD_INT 2
42339: NEG
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: LD_INT 2
42347: NEG
42348: PUSH
42349: LD_INT 2
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: PUSH
42356: LD_INT 4
42358: NEG
42359: PUSH
42360: LD_INT 4
42362: NEG
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 4
42370: NEG
42371: PUSH
42372: LD_INT 5
42374: NEG
42375: PUSH
42376: EMPTY
42377: LIST
42378: LIST
42379: PUSH
42380: LD_INT 3
42382: NEG
42383: PUSH
42384: LD_INT 4
42386: NEG
42387: PUSH
42388: EMPTY
42389: LIST
42390: LIST
42391: PUSH
42392: LD_INT 3
42394: NEG
42395: PUSH
42396: LD_INT 3
42398: NEG
42399: PUSH
42400: EMPTY
42401: LIST
42402: LIST
42403: PUSH
42404: LD_INT 4
42406: NEG
42407: PUSH
42408: LD_INT 3
42410: NEG
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: PUSH
42416: LD_INT 5
42418: NEG
42419: PUSH
42420: LD_INT 4
42422: NEG
42423: PUSH
42424: EMPTY
42425: LIST
42426: LIST
42427: PUSH
42428: LD_INT 5
42430: NEG
42431: PUSH
42432: LD_INT 5
42434: NEG
42435: PUSH
42436: EMPTY
42437: LIST
42438: LIST
42439: PUSH
42440: LD_INT 3
42442: NEG
42443: PUSH
42444: LD_INT 5
42446: NEG
42447: PUSH
42448: EMPTY
42449: LIST
42450: LIST
42451: PUSH
42452: LD_INT 5
42454: NEG
42455: PUSH
42456: LD_INT 3
42458: NEG
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: LIST
42468: LIST
42469: LIST
42470: LIST
42471: LIST
42472: LIST
42473: LIST
42474: LIST
42475: LIST
42476: LIST
42477: LIST
42478: LIST
42479: LIST
42480: LIST
42481: LIST
42482: LIST
42483: LIST
42484: LIST
42485: LIST
42486: LIST
42487: LIST
42488: LIST
42489: LIST
42490: LIST
42491: LIST
42492: LIST
42493: LIST
42494: LIST
42495: LIST
42496: LIST
42497: LIST
42498: LIST
42499: LIST
42500: LIST
42501: LIST
42502: LIST
42503: LIST
42504: LIST
42505: LIST
42506: LIST
42507: LIST
42508: LIST
42509: LIST
42510: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42511: LD_ADDR_VAR 0 30
42515: PUSH
42516: LD_INT 4
42518: PUSH
42519: LD_INT 4
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 4
42528: PUSH
42529: LD_INT 3
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: PUSH
42536: LD_INT 5
42538: PUSH
42539: LD_INT 4
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PUSH
42546: LD_INT 5
42548: PUSH
42549: LD_INT 5
42551: PUSH
42552: EMPTY
42553: LIST
42554: LIST
42555: PUSH
42556: LD_INT 4
42558: PUSH
42559: LD_INT 5
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: PUSH
42566: LD_INT 3
42568: PUSH
42569: LD_INT 4
42571: PUSH
42572: EMPTY
42573: LIST
42574: LIST
42575: PUSH
42576: LD_INT 3
42578: PUSH
42579: LD_INT 3
42581: PUSH
42582: EMPTY
42583: LIST
42584: LIST
42585: PUSH
42586: LD_INT 5
42588: PUSH
42589: LD_INT 3
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: PUSH
42596: LD_INT 3
42598: PUSH
42599: LD_INT 5
42601: PUSH
42602: EMPTY
42603: LIST
42604: LIST
42605: PUSH
42606: LD_INT 0
42608: PUSH
42609: LD_INT 3
42611: PUSH
42612: EMPTY
42613: LIST
42614: LIST
42615: PUSH
42616: LD_INT 0
42618: PUSH
42619: LD_INT 2
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: PUSH
42626: LD_INT 1
42628: PUSH
42629: LD_INT 3
42631: PUSH
42632: EMPTY
42633: LIST
42634: LIST
42635: PUSH
42636: LD_INT 1
42638: PUSH
42639: LD_INT 4
42641: PUSH
42642: EMPTY
42643: LIST
42644: LIST
42645: PUSH
42646: LD_INT 0
42648: PUSH
42649: LD_INT 4
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PUSH
42656: LD_INT 1
42658: NEG
42659: PUSH
42660: LD_INT 3
42662: PUSH
42663: EMPTY
42664: LIST
42665: LIST
42666: PUSH
42667: LD_INT 1
42669: NEG
42670: PUSH
42671: LD_INT 2
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PUSH
42678: LD_INT 2
42680: PUSH
42681: LD_INT 4
42683: PUSH
42684: EMPTY
42685: LIST
42686: LIST
42687: PUSH
42688: LD_INT 2
42690: NEG
42691: PUSH
42692: LD_INT 2
42694: PUSH
42695: EMPTY
42696: LIST
42697: LIST
42698: PUSH
42699: LD_INT 4
42701: NEG
42702: PUSH
42703: LD_INT 0
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: PUSH
42710: LD_INT 4
42712: NEG
42713: PUSH
42714: LD_INT 1
42716: NEG
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 3
42724: NEG
42725: PUSH
42726: LD_INT 0
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: LD_INT 3
42735: NEG
42736: PUSH
42737: LD_INT 1
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: PUSH
42744: LD_INT 4
42746: NEG
42747: PUSH
42748: LD_INT 1
42750: PUSH
42751: EMPTY
42752: LIST
42753: LIST
42754: PUSH
42755: LD_INT 5
42757: NEG
42758: PUSH
42759: LD_INT 0
42761: PUSH
42762: EMPTY
42763: LIST
42764: LIST
42765: PUSH
42766: LD_INT 5
42768: NEG
42769: PUSH
42770: LD_INT 1
42772: NEG
42773: PUSH
42774: EMPTY
42775: LIST
42776: LIST
42777: PUSH
42778: LD_INT 5
42780: NEG
42781: PUSH
42782: LD_INT 2
42784: NEG
42785: PUSH
42786: EMPTY
42787: LIST
42788: LIST
42789: PUSH
42790: LD_INT 3
42792: NEG
42793: PUSH
42794: LD_INT 2
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: PUSH
42801: LD_INT 3
42803: NEG
42804: PUSH
42805: LD_INT 3
42807: NEG
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: LD_INT 3
42815: NEG
42816: PUSH
42817: LD_INT 4
42819: NEG
42820: PUSH
42821: EMPTY
42822: LIST
42823: LIST
42824: PUSH
42825: LD_INT 2
42827: NEG
42828: PUSH
42829: LD_INT 3
42831: NEG
42832: PUSH
42833: EMPTY
42834: LIST
42835: LIST
42836: PUSH
42837: LD_INT 2
42839: NEG
42840: PUSH
42841: LD_INT 2
42843: NEG
42844: PUSH
42845: EMPTY
42846: LIST
42847: LIST
42848: PUSH
42849: LD_INT 3
42851: NEG
42852: PUSH
42853: LD_INT 2
42855: NEG
42856: PUSH
42857: EMPTY
42858: LIST
42859: LIST
42860: PUSH
42861: LD_INT 4
42863: NEG
42864: PUSH
42865: LD_INT 3
42867: NEG
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: PUSH
42873: LD_INT 4
42875: NEG
42876: PUSH
42877: LD_INT 4
42879: NEG
42880: PUSH
42881: EMPTY
42882: LIST
42883: LIST
42884: PUSH
42885: LD_INT 2
42887: NEG
42888: PUSH
42889: LD_INT 4
42891: NEG
42892: PUSH
42893: EMPTY
42894: LIST
42895: LIST
42896: PUSH
42897: LD_INT 4
42899: NEG
42900: PUSH
42901: LD_INT 2
42903: NEG
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: LD_INT 0
42911: PUSH
42912: LD_INT 4
42914: NEG
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: PUSH
42920: LD_INT 0
42922: PUSH
42923: LD_INT 5
42925: NEG
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: PUSH
42931: LD_INT 1
42933: PUSH
42934: LD_INT 4
42936: NEG
42937: PUSH
42938: EMPTY
42939: LIST
42940: LIST
42941: PUSH
42942: LD_INT 1
42944: PUSH
42945: LD_INT 3
42947: NEG
42948: PUSH
42949: EMPTY
42950: LIST
42951: LIST
42952: PUSH
42953: LD_INT 0
42955: PUSH
42956: LD_INT 3
42958: NEG
42959: PUSH
42960: EMPTY
42961: LIST
42962: LIST
42963: PUSH
42964: LD_INT 1
42966: NEG
42967: PUSH
42968: LD_INT 4
42970: NEG
42971: PUSH
42972: EMPTY
42973: LIST
42974: LIST
42975: PUSH
42976: LD_INT 1
42978: NEG
42979: PUSH
42980: LD_INT 5
42982: NEG
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: PUSH
42988: LD_INT 2
42990: PUSH
42991: LD_INT 3
42993: NEG
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: LD_INT 2
43001: NEG
43002: PUSH
43003: LD_INT 5
43005: NEG
43006: PUSH
43007: EMPTY
43008: LIST
43009: LIST
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: LIST
43015: LIST
43016: LIST
43017: LIST
43018: LIST
43019: LIST
43020: LIST
43021: LIST
43022: LIST
43023: LIST
43024: LIST
43025: LIST
43026: LIST
43027: LIST
43028: LIST
43029: LIST
43030: LIST
43031: LIST
43032: LIST
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: LIST
43043: LIST
43044: LIST
43045: LIST
43046: LIST
43047: LIST
43048: LIST
43049: LIST
43050: LIST
43051: LIST
43052: LIST
43053: LIST
43054: LIST
43055: LIST
43056: LIST
43057: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43058: LD_ADDR_VAR 0 31
43062: PUSH
43063: LD_INT 0
43065: PUSH
43066: LD_INT 4
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: PUSH
43073: LD_INT 0
43075: PUSH
43076: LD_INT 3
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 1
43085: PUSH
43086: LD_INT 4
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 1
43095: PUSH
43096: LD_INT 5
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: LD_INT 0
43105: PUSH
43106: LD_INT 5
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: LD_INT 1
43115: NEG
43116: PUSH
43117: LD_INT 4
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 1
43126: NEG
43127: PUSH
43128: LD_INT 3
43130: PUSH
43131: EMPTY
43132: LIST
43133: LIST
43134: PUSH
43135: LD_INT 2
43137: PUSH
43138: LD_INT 5
43140: PUSH
43141: EMPTY
43142: LIST
43143: LIST
43144: PUSH
43145: LD_INT 2
43147: NEG
43148: PUSH
43149: LD_INT 3
43151: PUSH
43152: EMPTY
43153: LIST
43154: LIST
43155: PUSH
43156: LD_INT 3
43158: NEG
43159: PUSH
43160: LD_INT 0
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 3
43169: NEG
43170: PUSH
43171: LD_INT 1
43173: NEG
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: LD_INT 2
43181: NEG
43182: PUSH
43183: LD_INT 0
43185: PUSH
43186: EMPTY
43187: LIST
43188: LIST
43189: PUSH
43190: LD_INT 2
43192: NEG
43193: PUSH
43194: LD_INT 1
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PUSH
43201: LD_INT 3
43203: NEG
43204: PUSH
43205: LD_INT 1
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: PUSH
43212: LD_INT 4
43214: NEG
43215: PUSH
43216: LD_INT 0
43218: PUSH
43219: EMPTY
43220: LIST
43221: LIST
43222: PUSH
43223: LD_INT 4
43225: NEG
43226: PUSH
43227: LD_INT 1
43229: NEG
43230: PUSH
43231: EMPTY
43232: LIST
43233: LIST
43234: PUSH
43235: LD_INT 4
43237: NEG
43238: PUSH
43239: LD_INT 2
43241: NEG
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PUSH
43247: LD_INT 2
43249: NEG
43250: PUSH
43251: LD_INT 2
43253: PUSH
43254: EMPTY
43255: LIST
43256: LIST
43257: PUSH
43258: LD_INT 4
43260: NEG
43261: PUSH
43262: LD_INT 4
43264: NEG
43265: PUSH
43266: EMPTY
43267: LIST
43268: LIST
43269: PUSH
43270: LD_INT 4
43272: NEG
43273: PUSH
43274: LD_INT 5
43276: NEG
43277: PUSH
43278: EMPTY
43279: LIST
43280: LIST
43281: PUSH
43282: LD_INT 3
43284: NEG
43285: PUSH
43286: LD_INT 4
43288: NEG
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: PUSH
43294: LD_INT 3
43296: NEG
43297: PUSH
43298: LD_INT 3
43300: NEG
43301: PUSH
43302: EMPTY
43303: LIST
43304: LIST
43305: PUSH
43306: LD_INT 4
43308: NEG
43309: PUSH
43310: LD_INT 3
43312: NEG
43313: PUSH
43314: EMPTY
43315: LIST
43316: LIST
43317: PUSH
43318: LD_INT 5
43320: NEG
43321: PUSH
43322: LD_INT 4
43324: NEG
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 5
43332: NEG
43333: PUSH
43334: LD_INT 5
43336: NEG
43337: PUSH
43338: EMPTY
43339: LIST
43340: LIST
43341: PUSH
43342: LD_INT 3
43344: NEG
43345: PUSH
43346: LD_INT 5
43348: NEG
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 5
43356: NEG
43357: PUSH
43358: LD_INT 3
43360: NEG
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: PUSH
43366: LD_INT 0
43368: PUSH
43369: LD_INT 3
43371: NEG
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 0
43379: PUSH
43380: LD_INT 4
43382: NEG
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: PUSH
43388: LD_INT 1
43390: PUSH
43391: LD_INT 3
43393: NEG
43394: PUSH
43395: EMPTY
43396: LIST
43397: LIST
43398: PUSH
43399: LD_INT 1
43401: PUSH
43402: LD_INT 2
43404: NEG
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: PUSH
43410: LD_INT 0
43412: PUSH
43413: LD_INT 2
43415: NEG
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: PUSH
43421: LD_INT 1
43423: NEG
43424: PUSH
43425: LD_INT 3
43427: NEG
43428: PUSH
43429: EMPTY
43430: LIST
43431: LIST
43432: PUSH
43433: LD_INT 1
43435: NEG
43436: PUSH
43437: LD_INT 4
43439: NEG
43440: PUSH
43441: EMPTY
43442: LIST
43443: LIST
43444: PUSH
43445: LD_INT 2
43447: PUSH
43448: LD_INT 2
43450: NEG
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 2
43458: NEG
43459: PUSH
43460: LD_INT 4
43462: NEG
43463: PUSH
43464: EMPTY
43465: LIST
43466: LIST
43467: PUSH
43468: LD_INT 4
43470: PUSH
43471: LD_INT 0
43473: PUSH
43474: EMPTY
43475: LIST
43476: LIST
43477: PUSH
43478: LD_INT 4
43480: PUSH
43481: LD_INT 1
43483: NEG
43484: PUSH
43485: EMPTY
43486: LIST
43487: LIST
43488: PUSH
43489: LD_INT 5
43491: PUSH
43492: LD_INT 0
43494: PUSH
43495: EMPTY
43496: LIST
43497: LIST
43498: PUSH
43499: LD_INT 5
43501: PUSH
43502: LD_INT 1
43504: PUSH
43505: EMPTY
43506: LIST
43507: LIST
43508: PUSH
43509: LD_INT 4
43511: PUSH
43512: LD_INT 1
43514: PUSH
43515: EMPTY
43516: LIST
43517: LIST
43518: PUSH
43519: LD_INT 3
43521: PUSH
43522: LD_INT 0
43524: PUSH
43525: EMPTY
43526: LIST
43527: LIST
43528: PUSH
43529: LD_INT 3
43531: PUSH
43532: LD_INT 1
43534: NEG
43535: PUSH
43536: EMPTY
43537: LIST
43538: LIST
43539: PUSH
43540: LD_INT 3
43542: PUSH
43543: LD_INT 2
43545: NEG
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 5
43553: PUSH
43554: LD_INT 2
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: EMPTY
43562: LIST
43563: LIST
43564: LIST
43565: LIST
43566: LIST
43567: LIST
43568: LIST
43569: LIST
43570: LIST
43571: LIST
43572: LIST
43573: LIST
43574: LIST
43575: LIST
43576: LIST
43577: LIST
43578: LIST
43579: LIST
43580: LIST
43581: LIST
43582: LIST
43583: LIST
43584: LIST
43585: LIST
43586: LIST
43587: LIST
43588: LIST
43589: LIST
43590: LIST
43591: LIST
43592: LIST
43593: LIST
43594: LIST
43595: LIST
43596: LIST
43597: LIST
43598: LIST
43599: LIST
43600: LIST
43601: LIST
43602: LIST
43603: LIST
43604: LIST
43605: LIST
43606: LIST
43607: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43608: LD_ADDR_VAR 0 32
43612: PUSH
43613: LD_INT 4
43615: NEG
43616: PUSH
43617: LD_INT 0
43619: PUSH
43620: EMPTY
43621: LIST
43622: LIST
43623: PUSH
43624: LD_INT 4
43626: NEG
43627: PUSH
43628: LD_INT 1
43630: NEG
43631: PUSH
43632: EMPTY
43633: LIST
43634: LIST
43635: PUSH
43636: LD_INT 3
43638: NEG
43639: PUSH
43640: LD_INT 0
43642: PUSH
43643: EMPTY
43644: LIST
43645: LIST
43646: PUSH
43647: LD_INT 3
43649: NEG
43650: PUSH
43651: LD_INT 1
43653: PUSH
43654: EMPTY
43655: LIST
43656: LIST
43657: PUSH
43658: LD_INT 4
43660: NEG
43661: PUSH
43662: LD_INT 1
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: PUSH
43669: LD_INT 5
43671: NEG
43672: PUSH
43673: LD_INT 0
43675: PUSH
43676: EMPTY
43677: LIST
43678: LIST
43679: PUSH
43680: LD_INT 5
43682: NEG
43683: PUSH
43684: LD_INT 1
43686: NEG
43687: PUSH
43688: EMPTY
43689: LIST
43690: LIST
43691: PUSH
43692: LD_INT 5
43694: NEG
43695: PUSH
43696: LD_INT 2
43698: NEG
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 3
43706: NEG
43707: PUSH
43708: LD_INT 2
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: PUSH
43715: LD_INT 3
43717: NEG
43718: PUSH
43719: LD_INT 3
43721: NEG
43722: PUSH
43723: EMPTY
43724: LIST
43725: LIST
43726: PUSH
43727: LD_INT 3
43729: NEG
43730: PUSH
43731: LD_INT 4
43733: NEG
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: PUSH
43739: LD_INT 2
43741: NEG
43742: PUSH
43743: LD_INT 3
43745: NEG
43746: PUSH
43747: EMPTY
43748: LIST
43749: LIST
43750: PUSH
43751: LD_INT 2
43753: NEG
43754: PUSH
43755: LD_INT 2
43757: NEG
43758: PUSH
43759: EMPTY
43760: LIST
43761: LIST
43762: PUSH
43763: LD_INT 3
43765: NEG
43766: PUSH
43767: LD_INT 2
43769: NEG
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: LD_INT 4
43777: NEG
43778: PUSH
43779: LD_INT 3
43781: NEG
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: PUSH
43787: LD_INT 4
43789: NEG
43790: PUSH
43791: LD_INT 4
43793: NEG
43794: PUSH
43795: EMPTY
43796: LIST
43797: LIST
43798: PUSH
43799: LD_INT 2
43801: NEG
43802: PUSH
43803: LD_INT 4
43805: NEG
43806: PUSH
43807: EMPTY
43808: LIST
43809: LIST
43810: PUSH
43811: LD_INT 4
43813: NEG
43814: PUSH
43815: LD_INT 2
43817: NEG
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PUSH
43823: LD_INT 0
43825: PUSH
43826: LD_INT 4
43828: NEG
43829: PUSH
43830: EMPTY
43831: LIST
43832: LIST
43833: PUSH
43834: LD_INT 0
43836: PUSH
43837: LD_INT 5
43839: NEG
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PUSH
43845: LD_INT 1
43847: PUSH
43848: LD_INT 4
43850: NEG
43851: PUSH
43852: EMPTY
43853: LIST
43854: LIST
43855: PUSH
43856: LD_INT 1
43858: PUSH
43859: LD_INT 3
43861: NEG
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 0
43869: PUSH
43870: LD_INT 3
43872: NEG
43873: PUSH
43874: EMPTY
43875: LIST
43876: LIST
43877: PUSH
43878: LD_INT 1
43880: NEG
43881: PUSH
43882: LD_INT 4
43884: NEG
43885: PUSH
43886: EMPTY
43887: LIST
43888: LIST
43889: PUSH
43890: LD_INT 1
43892: NEG
43893: PUSH
43894: LD_INT 5
43896: NEG
43897: PUSH
43898: EMPTY
43899: LIST
43900: LIST
43901: PUSH
43902: LD_INT 2
43904: PUSH
43905: LD_INT 3
43907: NEG
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: LD_INT 2
43915: NEG
43916: PUSH
43917: LD_INT 5
43919: NEG
43920: PUSH
43921: EMPTY
43922: LIST
43923: LIST
43924: PUSH
43925: LD_INT 3
43927: PUSH
43928: LD_INT 0
43930: PUSH
43931: EMPTY
43932: LIST
43933: LIST
43934: PUSH
43935: LD_INT 3
43937: PUSH
43938: LD_INT 1
43940: NEG
43941: PUSH
43942: EMPTY
43943: LIST
43944: LIST
43945: PUSH
43946: LD_INT 4
43948: PUSH
43949: LD_INT 0
43951: PUSH
43952: EMPTY
43953: LIST
43954: LIST
43955: PUSH
43956: LD_INT 4
43958: PUSH
43959: LD_INT 1
43961: PUSH
43962: EMPTY
43963: LIST
43964: LIST
43965: PUSH
43966: LD_INT 3
43968: PUSH
43969: LD_INT 1
43971: PUSH
43972: EMPTY
43973: LIST
43974: LIST
43975: PUSH
43976: LD_INT 2
43978: PUSH
43979: LD_INT 0
43981: PUSH
43982: EMPTY
43983: LIST
43984: LIST
43985: PUSH
43986: LD_INT 2
43988: PUSH
43989: LD_INT 1
43991: NEG
43992: PUSH
43993: EMPTY
43994: LIST
43995: LIST
43996: PUSH
43997: LD_INT 2
43999: PUSH
44000: LD_INT 2
44002: NEG
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: LD_INT 4
44010: PUSH
44011: LD_INT 2
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: LD_INT 4
44020: PUSH
44021: LD_INT 4
44023: PUSH
44024: EMPTY
44025: LIST
44026: LIST
44027: PUSH
44028: LD_INT 4
44030: PUSH
44031: LD_INT 3
44033: PUSH
44034: EMPTY
44035: LIST
44036: LIST
44037: PUSH
44038: LD_INT 5
44040: PUSH
44041: LD_INT 4
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 5
44050: PUSH
44051: LD_INT 5
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 4
44060: PUSH
44061: LD_INT 5
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: LD_INT 3
44070: PUSH
44071: LD_INT 4
44073: PUSH
44074: EMPTY
44075: LIST
44076: LIST
44077: PUSH
44078: LD_INT 3
44080: PUSH
44081: LD_INT 3
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PUSH
44088: LD_INT 5
44090: PUSH
44091: LD_INT 3
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 3
44100: PUSH
44101: LD_INT 5
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: LIST
44112: LIST
44113: LIST
44114: LIST
44115: LIST
44116: LIST
44117: LIST
44118: LIST
44119: LIST
44120: LIST
44121: LIST
44122: LIST
44123: LIST
44124: LIST
44125: LIST
44126: LIST
44127: LIST
44128: LIST
44129: LIST
44130: LIST
44131: LIST
44132: LIST
44133: LIST
44134: LIST
44135: LIST
44136: LIST
44137: LIST
44138: LIST
44139: LIST
44140: LIST
44141: LIST
44142: LIST
44143: LIST
44144: LIST
44145: LIST
44146: LIST
44147: LIST
44148: LIST
44149: LIST
44150: LIST
44151: LIST
44152: LIST
44153: LIST
44154: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44155: LD_ADDR_VAR 0 33
44159: PUSH
44160: LD_INT 4
44162: NEG
44163: PUSH
44164: LD_INT 4
44166: NEG
44167: PUSH
44168: EMPTY
44169: LIST
44170: LIST
44171: PUSH
44172: LD_INT 4
44174: NEG
44175: PUSH
44176: LD_INT 5
44178: NEG
44179: PUSH
44180: EMPTY
44181: LIST
44182: LIST
44183: PUSH
44184: LD_INT 3
44186: NEG
44187: PUSH
44188: LD_INT 4
44190: NEG
44191: PUSH
44192: EMPTY
44193: LIST
44194: LIST
44195: PUSH
44196: LD_INT 3
44198: NEG
44199: PUSH
44200: LD_INT 3
44202: NEG
44203: PUSH
44204: EMPTY
44205: LIST
44206: LIST
44207: PUSH
44208: LD_INT 4
44210: NEG
44211: PUSH
44212: LD_INT 3
44214: NEG
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 5
44222: NEG
44223: PUSH
44224: LD_INT 4
44226: NEG
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 5
44234: NEG
44235: PUSH
44236: LD_INT 5
44238: NEG
44239: PUSH
44240: EMPTY
44241: LIST
44242: LIST
44243: PUSH
44244: LD_INT 3
44246: NEG
44247: PUSH
44248: LD_INT 5
44250: NEG
44251: PUSH
44252: EMPTY
44253: LIST
44254: LIST
44255: PUSH
44256: LD_INT 5
44258: NEG
44259: PUSH
44260: LD_INT 3
44262: NEG
44263: PUSH
44264: EMPTY
44265: LIST
44266: LIST
44267: PUSH
44268: LD_INT 0
44270: PUSH
44271: LD_INT 3
44273: NEG
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: PUSH
44279: LD_INT 0
44281: PUSH
44282: LD_INT 4
44284: NEG
44285: PUSH
44286: EMPTY
44287: LIST
44288: LIST
44289: PUSH
44290: LD_INT 1
44292: PUSH
44293: LD_INT 3
44295: NEG
44296: PUSH
44297: EMPTY
44298: LIST
44299: LIST
44300: PUSH
44301: LD_INT 1
44303: PUSH
44304: LD_INT 2
44306: NEG
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: PUSH
44312: LD_INT 0
44314: PUSH
44315: LD_INT 2
44317: NEG
44318: PUSH
44319: EMPTY
44320: LIST
44321: LIST
44322: PUSH
44323: LD_INT 1
44325: NEG
44326: PUSH
44327: LD_INT 3
44329: NEG
44330: PUSH
44331: EMPTY
44332: LIST
44333: LIST
44334: PUSH
44335: LD_INT 1
44337: NEG
44338: PUSH
44339: LD_INT 4
44341: NEG
44342: PUSH
44343: EMPTY
44344: LIST
44345: LIST
44346: PUSH
44347: LD_INT 2
44349: PUSH
44350: LD_INT 2
44352: NEG
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 2
44360: NEG
44361: PUSH
44362: LD_INT 4
44364: NEG
44365: PUSH
44366: EMPTY
44367: LIST
44368: LIST
44369: PUSH
44370: LD_INT 4
44372: PUSH
44373: LD_INT 0
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: LD_INT 4
44382: PUSH
44383: LD_INT 1
44385: NEG
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: LD_INT 5
44393: PUSH
44394: LD_INT 0
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 5
44403: PUSH
44404: LD_INT 1
44406: PUSH
44407: EMPTY
44408: LIST
44409: LIST
44410: PUSH
44411: LD_INT 4
44413: PUSH
44414: LD_INT 1
44416: PUSH
44417: EMPTY
44418: LIST
44419: LIST
44420: PUSH
44421: LD_INT 3
44423: PUSH
44424: LD_INT 0
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: PUSH
44431: LD_INT 3
44433: PUSH
44434: LD_INT 1
44436: NEG
44437: PUSH
44438: EMPTY
44439: LIST
44440: LIST
44441: PUSH
44442: LD_INT 3
44444: PUSH
44445: LD_INT 2
44447: NEG
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: LD_INT 5
44455: PUSH
44456: LD_INT 2
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 3
44465: PUSH
44466: LD_INT 3
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 3
44475: PUSH
44476: LD_INT 2
44478: PUSH
44479: EMPTY
44480: LIST
44481: LIST
44482: PUSH
44483: LD_INT 4
44485: PUSH
44486: LD_INT 3
44488: PUSH
44489: EMPTY
44490: LIST
44491: LIST
44492: PUSH
44493: LD_INT 4
44495: PUSH
44496: LD_INT 4
44498: PUSH
44499: EMPTY
44500: LIST
44501: LIST
44502: PUSH
44503: LD_INT 3
44505: PUSH
44506: LD_INT 4
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: LD_INT 2
44515: PUSH
44516: LD_INT 3
44518: PUSH
44519: EMPTY
44520: LIST
44521: LIST
44522: PUSH
44523: LD_INT 2
44525: PUSH
44526: LD_INT 2
44528: PUSH
44529: EMPTY
44530: LIST
44531: LIST
44532: PUSH
44533: LD_INT 4
44535: PUSH
44536: LD_INT 2
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: PUSH
44543: LD_INT 2
44545: PUSH
44546: LD_INT 4
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: PUSH
44553: LD_INT 0
44555: PUSH
44556: LD_INT 4
44558: PUSH
44559: EMPTY
44560: LIST
44561: LIST
44562: PUSH
44563: LD_INT 0
44565: PUSH
44566: LD_INT 3
44568: PUSH
44569: EMPTY
44570: LIST
44571: LIST
44572: PUSH
44573: LD_INT 1
44575: PUSH
44576: LD_INT 4
44578: PUSH
44579: EMPTY
44580: LIST
44581: LIST
44582: PUSH
44583: LD_INT 1
44585: PUSH
44586: LD_INT 5
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 0
44595: PUSH
44596: LD_INT 5
44598: PUSH
44599: EMPTY
44600: LIST
44601: LIST
44602: PUSH
44603: LD_INT 1
44605: NEG
44606: PUSH
44607: LD_INT 4
44609: PUSH
44610: EMPTY
44611: LIST
44612: LIST
44613: PUSH
44614: LD_INT 1
44616: NEG
44617: PUSH
44618: LD_INT 3
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: PUSH
44625: LD_INT 2
44627: PUSH
44628: LD_INT 5
44630: PUSH
44631: EMPTY
44632: LIST
44633: LIST
44634: PUSH
44635: LD_INT 2
44637: NEG
44638: PUSH
44639: LD_INT 3
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: LIST
44650: LIST
44651: LIST
44652: LIST
44653: LIST
44654: LIST
44655: LIST
44656: LIST
44657: LIST
44658: LIST
44659: LIST
44660: LIST
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: LIST
44669: LIST
44670: LIST
44671: LIST
44672: LIST
44673: LIST
44674: LIST
44675: LIST
44676: LIST
44677: LIST
44678: LIST
44679: LIST
44680: LIST
44681: LIST
44682: LIST
44683: LIST
44684: LIST
44685: LIST
44686: LIST
44687: LIST
44688: LIST
44689: LIST
44690: LIST
44691: LIST
44692: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44693: LD_ADDR_VAR 0 34
44697: PUSH
44698: LD_INT 0
44700: PUSH
44701: LD_INT 4
44703: NEG
44704: PUSH
44705: EMPTY
44706: LIST
44707: LIST
44708: PUSH
44709: LD_INT 0
44711: PUSH
44712: LD_INT 5
44714: NEG
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: PUSH
44720: LD_INT 1
44722: PUSH
44723: LD_INT 4
44725: NEG
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: LD_INT 1
44733: PUSH
44734: LD_INT 3
44736: NEG
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: PUSH
44742: LD_INT 0
44744: PUSH
44745: LD_INT 3
44747: NEG
44748: PUSH
44749: EMPTY
44750: LIST
44751: LIST
44752: PUSH
44753: LD_INT 1
44755: NEG
44756: PUSH
44757: LD_INT 4
44759: NEG
44760: PUSH
44761: EMPTY
44762: LIST
44763: LIST
44764: PUSH
44765: LD_INT 1
44767: NEG
44768: PUSH
44769: LD_INT 5
44771: NEG
44772: PUSH
44773: EMPTY
44774: LIST
44775: LIST
44776: PUSH
44777: LD_INT 2
44779: PUSH
44780: LD_INT 3
44782: NEG
44783: PUSH
44784: EMPTY
44785: LIST
44786: LIST
44787: PUSH
44788: LD_INT 2
44790: NEG
44791: PUSH
44792: LD_INT 5
44794: NEG
44795: PUSH
44796: EMPTY
44797: LIST
44798: LIST
44799: PUSH
44800: LD_INT 3
44802: PUSH
44803: LD_INT 0
44805: PUSH
44806: EMPTY
44807: LIST
44808: LIST
44809: PUSH
44810: LD_INT 3
44812: PUSH
44813: LD_INT 1
44815: NEG
44816: PUSH
44817: EMPTY
44818: LIST
44819: LIST
44820: PUSH
44821: LD_INT 4
44823: PUSH
44824: LD_INT 0
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PUSH
44831: LD_INT 4
44833: PUSH
44834: LD_INT 1
44836: PUSH
44837: EMPTY
44838: LIST
44839: LIST
44840: PUSH
44841: LD_INT 3
44843: PUSH
44844: LD_INT 1
44846: PUSH
44847: EMPTY
44848: LIST
44849: LIST
44850: PUSH
44851: LD_INT 2
44853: PUSH
44854: LD_INT 0
44856: PUSH
44857: EMPTY
44858: LIST
44859: LIST
44860: PUSH
44861: LD_INT 2
44863: PUSH
44864: LD_INT 1
44866: NEG
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: LD_INT 2
44874: PUSH
44875: LD_INT 2
44877: NEG
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: PUSH
44883: LD_INT 4
44885: PUSH
44886: LD_INT 2
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 4
44895: PUSH
44896: LD_INT 4
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 4
44905: PUSH
44906: LD_INT 3
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 5
44915: PUSH
44916: LD_INT 4
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: PUSH
44923: LD_INT 5
44925: PUSH
44926: LD_INT 5
44928: PUSH
44929: EMPTY
44930: LIST
44931: LIST
44932: PUSH
44933: LD_INT 4
44935: PUSH
44936: LD_INT 5
44938: PUSH
44939: EMPTY
44940: LIST
44941: LIST
44942: PUSH
44943: LD_INT 3
44945: PUSH
44946: LD_INT 4
44948: PUSH
44949: EMPTY
44950: LIST
44951: LIST
44952: PUSH
44953: LD_INT 3
44955: PUSH
44956: LD_INT 3
44958: PUSH
44959: EMPTY
44960: LIST
44961: LIST
44962: PUSH
44963: LD_INT 5
44965: PUSH
44966: LD_INT 3
44968: PUSH
44969: EMPTY
44970: LIST
44971: LIST
44972: PUSH
44973: LD_INT 3
44975: PUSH
44976: LD_INT 5
44978: PUSH
44979: EMPTY
44980: LIST
44981: LIST
44982: PUSH
44983: LD_INT 0
44985: PUSH
44986: LD_INT 3
44988: PUSH
44989: EMPTY
44990: LIST
44991: LIST
44992: PUSH
44993: LD_INT 0
44995: PUSH
44996: LD_INT 2
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: LD_INT 1
45005: PUSH
45006: LD_INT 3
45008: PUSH
45009: EMPTY
45010: LIST
45011: LIST
45012: PUSH
45013: LD_INT 1
45015: PUSH
45016: LD_INT 4
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PUSH
45023: LD_INT 0
45025: PUSH
45026: LD_INT 4
45028: PUSH
45029: EMPTY
45030: LIST
45031: LIST
45032: PUSH
45033: LD_INT 1
45035: NEG
45036: PUSH
45037: LD_INT 3
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: LD_INT 1
45046: NEG
45047: PUSH
45048: LD_INT 2
45050: PUSH
45051: EMPTY
45052: LIST
45053: LIST
45054: PUSH
45055: LD_INT 2
45057: PUSH
45058: LD_INT 4
45060: PUSH
45061: EMPTY
45062: LIST
45063: LIST
45064: PUSH
45065: LD_INT 2
45067: NEG
45068: PUSH
45069: LD_INT 2
45071: PUSH
45072: EMPTY
45073: LIST
45074: LIST
45075: PUSH
45076: LD_INT 4
45078: NEG
45079: PUSH
45080: LD_INT 0
45082: PUSH
45083: EMPTY
45084: LIST
45085: LIST
45086: PUSH
45087: LD_INT 4
45089: NEG
45090: PUSH
45091: LD_INT 1
45093: NEG
45094: PUSH
45095: EMPTY
45096: LIST
45097: LIST
45098: PUSH
45099: LD_INT 3
45101: NEG
45102: PUSH
45103: LD_INT 0
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: PUSH
45110: LD_INT 3
45112: NEG
45113: PUSH
45114: LD_INT 1
45116: PUSH
45117: EMPTY
45118: LIST
45119: LIST
45120: PUSH
45121: LD_INT 4
45123: NEG
45124: PUSH
45125: LD_INT 1
45127: PUSH
45128: EMPTY
45129: LIST
45130: LIST
45131: PUSH
45132: LD_INT 5
45134: NEG
45135: PUSH
45136: LD_INT 0
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: PUSH
45143: LD_INT 5
45145: NEG
45146: PUSH
45147: LD_INT 1
45149: NEG
45150: PUSH
45151: EMPTY
45152: LIST
45153: LIST
45154: PUSH
45155: LD_INT 5
45157: NEG
45158: PUSH
45159: LD_INT 2
45161: NEG
45162: PUSH
45163: EMPTY
45164: LIST
45165: LIST
45166: PUSH
45167: LD_INT 3
45169: NEG
45170: PUSH
45171: LD_INT 2
45173: PUSH
45174: EMPTY
45175: LIST
45176: LIST
45177: PUSH
45178: EMPTY
45179: LIST
45180: LIST
45181: LIST
45182: LIST
45183: LIST
45184: LIST
45185: LIST
45186: LIST
45187: LIST
45188: LIST
45189: LIST
45190: LIST
45191: LIST
45192: LIST
45193: LIST
45194: LIST
45195: LIST
45196: LIST
45197: LIST
45198: LIST
45199: LIST
45200: LIST
45201: LIST
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: LIST
45219: LIST
45220: LIST
45221: LIST
45222: LIST
45223: LIST
45224: ST_TO_ADDR
// end ; end ;
45225: GO 45228
45227: POP
// case btype of b_depot , b_warehouse :
45228: LD_VAR 0 1
45232: PUSH
45233: LD_INT 0
45235: DOUBLE
45236: EQUAL
45237: IFTRUE 45247
45239: LD_INT 1
45241: DOUBLE
45242: EQUAL
45243: IFTRUE 45247
45245: GO 45448
45247: POP
// case nation of nation_american :
45248: LD_VAR 0 5
45252: PUSH
45253: LD_INT 1
45255: DOUBLE
45256: EQUAL
45257: IFTRUE 45261
45259: GO 45317
45261: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
45262: LD_ADDR_VAR 0 9
45266: PUSH
45267: LD_VAR 0 11
45271: PUSH
45272: LD_VAR 0 12
45276: PUSH
45277: LD_VAR 0 13
45281: PUSH
45282: LD_VAR 0 14
45286: PUSH
45287: LD_VAR 0 15
45291: PUSH
45292: LD_VAR 0 16
45296: PUSH
45297: EMPTY
45298: LIST
45299: LIST
45300: LIST
45301: LIST
45302: LIST
45303: LIST
45304: PUSH
45305: LD_VAR 0 4
45309: PUSH
45310: LD_INT 1
45312: PLUS
45313: ARRAY
45314: ST_TO_ADDR
45315: GO 45446
45317: LD_INT 2
45319: DOUBLE
45320: EQUAL
45321: IFTRUE 45325
45323: GO 45381
45325: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
45326: LD_ADDR_VAR 0 9
45330: PUSH
45331: LD_VAR 0 17
45335: PUSH
45336: LD_VAR 0 18
45340: PUSH
45341: LD_VAR 0 19
45345: PUSH
45346: LD_VAR 0 20
45350: PUSH
45351: LD_VAR 0 21
45355: PUSH
45356: LD_VAR 0 22
45360: PUSH
45361: EMPTY
45362: LIST
45363: LIST
45364: LIST
45365: LIST
45366: LIST
45367: LIST
45368: PUSH
45369: LD_VAR 0 4
45373: PUSH
45374: LD_INT 1
45376: PLUS
45377: ARRAY
45378: ST_TO_ADDR
45379: GO 45446
45381: LD_INT 3
45383: DOUBLE
45384: EQUAL
45385: IFTRUE 45389
45387: GO 45445
45389: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45390: LD_ADDR_VAR 0 9
45394: PUSH
45395: LD_VAR 0 23
45399: PUSH
45400: LD_VAR 0 24
45404: PUSH
45405: LD_VAR 0 25
45409: PUSH
45410: LD_VAR 0 26
45414: PUSH
45415: LD_VAR 0 27
45419: PUSH
45420: LD_VAR 0 28
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: LIST
45429: LIST
45430: LIST
45431: LIST
45432: PUSH
45433: LD_VAR 0 4
45437: PUSH
45438: LD_INT 1
45440: PLUS
45441: ARRAY
45442: ST_TO_ADDR
45443: GO 45446
45445: POP
45446: GO 46001
45448: LD_INT 2
45450: DOUBLE
45451: EQUAL
45452: IFTRUE 45462
45454: LD_INT 3
45456: DOUBLE
45457: EQUAL
45458: IFTRUE 45462
45460: GO 45518
45462: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45463: LD_ADDR_VAR 0 9
45467: PUSH
45468: LD_VAR 0 29
45472: PUSH
45473: LD_VAR 0 30
45477: PUSH
45478: LD_VAR 0 31
45482: PUSH
45483: LD_VAR 0 32
45487: PUSH
45488: LD_VAR 0 33
45492: PUSH
45493: LD_VAR 0 34
45497: PUSH
45498: EMPTY
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: PUSH
45506: LD_VAR 0 4
45510: PUSH
45511: LD_INT 1
45513: PLUS
45514: ARRAY
45515: ST_TO_ADDR
45516: GO 46001
45518: LD_INT 16
45520: DOUBLE
45521: EQUAL
45522: IFTRUE 45580
45524: LD_INT 17
45526: DOUBLE
45527: EQUAL
45528: IFTRUE 45580
45530: LD_INT 18
45532: DOUBLE
45533: EQUAL
45534: IFTRUE 45580
45536: LD_INT 19
45538: DOUBLE
45539: EQUAL
45540: IFTRUE 45580
45542: LD_INT 22
45544: DOUBLE
45545: EQUAL
45546: IFTRUE 45580
45548: LD_INT 20
45550: DOUBLE
45551: EQUAL
45552: IFTRUE 45580
45554: LD_INT 21
45556: DOUBLE
45557: EQUAL
45558: IFTRUE 45580
45560: LD_INT 23
45562: DOUBLE
45563: EQUAL
45564: IFTRUE 45580
45566: LD_INT 24
45568: DOUBLE
45569: EQUAL
45570: IFTRUE 45580
45572: LD_INT 25
45574: DOUBLE
45575: EQUAL
45576: IFTRUE 45580
45578: GO 45636
45580: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45581: LD_ADDR_VAR 0 9
45585: PUSH
45586: LD_VAR 0 35
45590: PUSH
45591: LD_VAR 0 36
45595: PUSH
45596: LD_VAR 0 37
45600: PUSH
45601: LD_VAR 0 38
45605: PUSH
45606: LD_VAR 0 39
45610: PUSH
45611: LD_VAR 0 40
45615: PUSH
45616: EMPTY
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: LIST
45622: LIST
45623: PUSH
45624: LD_VAR 0 4
45628: PUSH
45629: LD_INT 1
45631: PLUS
45632: ARRAY
45633: ST_TO_ADDR
45634: GO 46001
45636: LD_INT 6
45638: DOUBLE
45639: EQUAL
45640: IFTRUE 45692
45642: LD_INT 7
45644: DOUBLE
45645: EQUAL
45646: IFTRUE 45692
45648: LD_INT 8
45650: DOUBLE
45651: EQUAL
45652: IFTRUE 45692
45654: LD_INT 13
45656: DOUBLE
45657: EQUAL
45658: IFTRUE 45692
45660: LD_INT 12
45662: DOUBLE
45663: EQUAL
45664: IFTRUE 45692
45666: LD_INT 15
45668: DOUBLE
45669: EQUAL
45670: IFTRUE 45692
45672: LD_INT 11
45674: DOUBLE
45675: EQUAL
45676: IFTRUE 45692
45678: LD_INT 14
45680: DOUBLE
45681: EQUAL
45682: IFTRUE 45692
45684: LD_INT 10
45686: DOUBLE
45687: EQUAL
45688: IFTRUE 45692
45690: GO 45748
45692: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
45693: LD_ADDR_VAR 0 9
45697: PUSH
45698: LD_VAR 0 41
45702: PUSH
45703: LD_VAR 0 42
45707: PUSH
45708: LD_VAR 0 43
45712: PUSH
45713: LD_VAR 0 44
45717: PUSH
45718: LD_VAR 0 45
45722: PUSH
45723: LD_VAR 0 46
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: LIST
45732: LIST
45733: LIST
45734: LIST
45735: PUSH
45736: LD_VAR 0 4
45740: PUSH
45741: LD_INT 1
45743: PLUS
45744: ARRAY
45745: ST_TO_ADDR
45746: GO 46001
45748: LD_INT 36
45750: DOUBLE
45751: EQUAL
45752: IFTRUE 45756
45754: GO 45812
45756: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45757: LD_ADDR_VAR 0 9
45761: PUSH
45762: LD_VAR 0 47
45766: PUSH
45767: LD_VAR 0 48
45771: PUSH
45772: LD_VAR 0 49
45776: PUSH
45777: LD_VAR 0 50
45781: PUSH
45782: LD_VAR 0 51
45786: PUSH
45787: LD_VAR 0 52
45791: PUSH
45792: EMPTY
45793: LIST
45794: LIST
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: PUSH
45800: LD_VAR 0 4
45804: PUSH
45805: LD_INT 1
45807: PLUS
45808: ARRAY
45809: ST_TO_ADDR
45810: GO 46001
45812: LD_INT 4
45814: DOUBLE
45815: EQUAL
45816: IFTRUE 45838
45818: LD_INT 5
45820: DOUBLE
45821: EQUAL
45822: IFTRUE 45838
45824: LD_INT 34
45826: DOUBLE
45827: EQUAL
45828: IFTRUE 45838
45830: LD_INT 37
45832: DOUBLE
45833: EQUAL
45834: IFTRUE 45838
45836: GO 45894
45838: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45839: LD_ADDR_VAR 0 9
45843: PUSH
45844: LD_VAR 0 53
45848: PUSH
45849: LD_VAR 0 54
45853: PUSH
45854: LD_VAR 0 55
45858: PUSH
45859: LD_VAR 0 56
45863: PUSH
45864: LD_VAR 0 57
45868: PUSH
45869: LD_VAR 0 58
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: PUSH
45882: LD_VAR 0 4
45886: PUSH
45887: LD_INT 1
45889: PLUS
45890: ARRAY
45891: ST_TO_ADDR
45892: GO 46001
45894: LD_INT 31
45896: DOUBLE
45897: EQUAL
45898: IFTRUE 45944
45900: LD_INT 32
45902: DOUBLE
45903: EQUAL
45904: IFTRUE 45944
45906: LD_INT 33
45908: DOUBLE
45909: EQUAL
45910: IFTRUE 45944
45912: LD_INT 27
45914: DOUBLE
45915: EQUAL
45916: IFTRUE 45944
45918: LD_INT 26
45920: DOUBLE
45921: EQUAL
45922: IFTRUE 45944
45924: LD_INT 28
45926: DOUBLE
45927: EQUAL
45928: IFTRUE 45944
45930: LD_INT 29
45932: DOUBLE
45933: EQUAL
45934: IFTRUE 45944
45936: LD_INT 30
45938: DOUBLE
45939: EQUAL
45940: IFTRUE 45944
45942: GO 46000
45944: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
45945: LD_ADDR_VAR 0 9
45949: PUSH
45950: LD_VAR 0 59
45954: PUSH
45955: LD_VAR 0 60
45959: PUSH
45960: LD_VAR 0 61
45964: PUSH
45965: LD_VAR 0 62
45969: PUSH
45970: LD_VAR 0 63
45974: PUSH
45975: LD_VAR 0 64
45979: PUSH
45980: EMPTY
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: PUSH
45988: LD_VAR 0 4
45992: PUSH
45993: LD_INT 1
45995: PLUS
45996: ARRAY
45997: ST_TO_ADDR
45998: GO 46001
46000: POP
// temp_list2 = [ ] ;
46001: LD_ADDR_VAR 0 10
46005: PUSH
46006: EMPTY
46007: ST_TO_ADDR
// for i in temp_list do
46008: LD_ADDR_VAR 0 8
46012: PUSH
46013: LD_VAR 0 9
46017: PUSH
46018: FOR_IN
46019: IFFALSE 46071
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46021: LD_ADDR_VAR 0 10
46025: PUSH
46026: LD_VAR 0 10
46030: PUSH
46031: LD_VAR 0 8
46035: PUSH
46036: LD_INT 1
46038: ARRAY
46039: PUSH
46040: LD_VAR 0 2
46044: PLUS
46045: PUSH
46046: LD_VAR 0 8
46050: PUSH
46051: LD_INT 2
46053: ARRAY
46054: PUSH
46055: LD_VAR 0 3
46059: PLUS
46060: PUSH
46061: EMPTY
46062: LIST
46063: LIST
46064: PUSH
46065: EMPTY
46066: LIST
46067: ADD
46068: ST_TO_ADDR
46069: GO 46018
46071: POP
46072: POP
// result = temp_list2 ;
46073: LD_ADDR_VAR 0 7
46077: PUSH
46078: LD_VAR 0 10
46082: ST_TO_ADDR
// end ;
46083: LD_VAR 0 7
46087: RET
// export function EnemyInRange ( unit , dist ) ; begin
46088: LD_INT 0
46090: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46091: LD_ADDR_VAR 0 3
46095: PUSH
46096: LD_VAR 0 1
46100: PPUSH
46101: CALL_OW 255
46105: PPUSH
46106: LD_VAR 0 1
46110: PPUSH
46111: CALL_OW 250
46115: PPUSH
46116: LD_VAR 0 1
46120: PPUSH
46121: CALL_OW 251
46125: PPUSH
46126: LD_VAR 0 2
46130: PPUSH
46131: CALL 19484 0 4
46135: PUSH
46136: LD_INT 4
46138: ARRAY
46139: ST_TO_ADDR
// end ;
46140: LD_VAR 0 3
46144: RET
// export function PlayerSeeMe ( unit ) ; begin
46145: LD_INT 0
46147: PPUSH
// result := See ( your_side , unit ) ;
46148: LD_ADDR_VAR 0 2
46152: PUSH
46153: LD_OWVAR 2
46157: PPUSH
46158: LD_VAR 0 1
46162: PPUSH
46163: CALL_OW 292
46167: ST_TO_ADDR
// end ;
46168: LD_VAR 0 2
46172: RET
// export function ReverseDir ( unit ) ; begin
46173: LD_INT 0
46175: PPUSH
// if not unit then
46176: LD_VAR 0 1
46180: NOT
46181: IFFALSE 46185
// exit ;
46183: GO 46208
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46185: LD_ADDR_VAR 0 2
46189: PUSH
46190: LD_VAR 0 1
46194: PPUSH
46195: CALL_OW 254
46199: PUSH
46200: LD_INT 3
46202: PLUS
46203: PUSH
46204: LD_INT 6
46206: MOD
46207: ST_TO_ADDR
// end ;
46208: LD_VAR 0 2
46212: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46213: LD_INT 0
46215: PPUSH
46216: PPUSH
46217: PPUSH
46218: PPUSH
46219: PPUSH
// if not hexes then
46220: LD_VAR 0 2
46224: NOT
46225: IFFALSE 46229
// exit ;
46227: GO 46377
// dist := 9999 ;
46229: LD_ADDR_VAR 0 5
46233: PUSH
46234: LD_INT 9999
46236: ST_TO_ADDR
// for i = 1 to hexes do
46237: LD_ADDR_VAR 0 4
46241: PUSH
46242: DOUBLE
46243: LD_INT 1
46245: DEC
46246: ST_TO_ADDR
46247: LD_VAR 0 2
46251: PUSH
46252: FOR_TO
46253: IFFALSE 46365
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
46255: LD_VAR 0 1
46259: PPUSH
46260: LD_VAR 0 2
46264: PUSH
46265: LD_VAR 0 4
46269: ARRAY
46270: PUSH
46271: LD_INT 1
46273: ARRAY
46274: PPUSH
46275: LD_VAR 0 2
46279: PUSH
46280: LD_VAR 0 4
46284: ARRAY
46285: PUSH
46286: LD_INT 2
46288: ARRAY
46289: PPUSH
46290: CALL_OW 297
46294: PUSH
46295: LD_VAR 0 5
46299: LESS
46300: IFFALSE 46363
// begin hex := hexes [ i ] ;
46302: LD_ADDR_VAR 0 7
46306: PUSH
46307: LD_VAR 0 2
46311: PUSH
46312: LD_VAR 0 4
46316: ARRAY
46317: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46318: LD_ADDR_VAR 0 5
46322: PUSH
46323: LD_VAR 0 1
46327: PPUSH
46328: LD_VAR 0 2
46332: PUSH
46333: LD_VAR 0 4
46337: ARRAY
46338: PUSH
46339: LD_INT 1
46341: ARRAY
46342: PPUSH
46343: LD_VAR 0 2
46347: PUSH
46348: LD_VAR 0 4
46352: ARRAY
46353: PUSH
46354: LD_INT 2
46356: ARRAY
46357: PPUSH
46358: CALL_OW 297
46362: ST_TO_ADDR
// end ; end ;
46363: GO 46252
46365: POP
46366: POP
// result := hex ;
46367: LD_ADDR_VAR 0 3
46371: PUSH
46372: LD_VAR 0 7
46376: ST_TO_ADDR
// end ;
46377: LD_VAR 0 3
46381: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46382: LD_INT 0
46384: PPUSH
46385: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46386: LD_VAR 0 1
46390: NOT
46391: PUSH
46392: LD_VAR 0 1
46396: PUSH
46397: LD_INT 21
46399: PUSH
46400: LD_INT 2
46402: PUSH
46403: EMPTY
46404: LIST
46405: LIST
46406: PUSH
46407: LD_INT 23
46409: PUSH
46410: LD_INT 2
46412: PUSH
46413: EMPTY
46414: LIST
46415: LIST
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: PPUSH
46421: CALL_OW 69
46425: IN
46426: NOT
46427: OR
46428: IFFALSE 46432
// exit ;
46430: GO 46479
// for i = 1 to 3 do
46432: LD_ADDR_VAR 0 3
46436: PUSH
46437: DOUBLE
46438: LD_INT 1
46440: DEC
46441: ST_TO_ADDR
46442: LD_INT 3
46444: PUSH
46445: FOR_TO
46446: IFFALSE 46477
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46448: LD_VAR 0 1
46452: PPUSH
46453: CALL_OW 250
46457: PPUSH
46458: LD_VAR 0 1
46462: PPUSH
46463: CALL_OW 251
46467: PPUSH
46468: LD_INT 1
46470: PPUSH
46471: CALL_OW 453
46475: GO 46445
46477: POP
46478: POP
// end ;
46479: LD_VAR 0 2
46483: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46484: LD_INT 0
46486: PPUSH
46487: PPUSH
46488: PPUSH
46489: PPUSH
46490: PPUSH
46491: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46492: LD_VAR 0 1
46496: NOT
46497: PUSH
46498: LD_VAR 0 2
46502: NOT
46503: OR
46504: PUSH
46505: LD_VAR 0 1
46509: PPUSH
46510: CALL_OW 314
46514: OR
46515: IFFALSE 46519
// exit ;
46517: GO 46960
// x := GetX ( enemy_unit ) ;
46519: LD_ADDR_VAR 0 7
46523: PUSH
46524: LD_VAR 0 2
46528: PPUSH
46529: CALL_OW 250
46533: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46534: LD_ADDR_VAR 0 8
46538: PUSH
46539: LD_VAR 0 2
46543: PPUSH
46544: CALL_OW 251
46548: ST_TO_ADDR
// if not x or not y then
46549: LD_VAR 0 7
46553: NOT
46554: PUSH
46555: LD_VAR 0 8
46559: NOT
46560: OR
46561: IFFALSE 46565
// exit ;
46563: GO 46960
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46565: LD_ADDR_VAR 0 6
46569: PUSH
46570: LD_VAR 0 7
46574: PPUSH
46575: LD_INT 0
46577: PPUSH
46578: LD_INT 4
46580: PPUSH
46581: CALL_OW 272
46585: PUSH
46586: LD_VAR 0 8
46590: PPUSH
46591: LD_INT 0
46593: PPUSH
46594: LD_INT 4
46596: PPUSH
46597: CALL_OW 273
46601: PUSH
46602: EMPTY
46603: LIST
46604: LIST
46605: PUSH
46606: LD_VAR 0 7
46610: PPUSH
46611: LD_INT 1
46613: PPUSH
46614: LD_INT 4
46616: PPUSH
46617: CALL_OW 272
46621: PUSH
46622: LD_VAR 0 8
46626: PPUSH
46627: LD_INT 1
46629: PPUSH
46630: LD_INT 4
46632: PPUSH
46633: CALL_OW 273
46637: PUSH
46638: EMPTY
46639: LIST
46640: LIST
46641: PUSH
46642: LD_VAR 0 7
46646: PPUSH
46647: LD_INT 2
46649: PPUSH
46650: LD_INT 4
46652: PPUSH
46653: CALL_OW 272
46657: PUSH
46658: LD_VAR 0 8
46662: PPUSH
46663: LD_INT 2
46665: PPUSH
46666: LD_INT 4
46668: PPUSH
46669: CALL_OW 273
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: LD_VAR 0 7
46682: PPUSH
46683: LD_INT 3
46685: PPUSH
46686: LD_INT 4
46688: PPUSH
46689: CALL_OW 272
46693: PUSH
46694: LD_VAR 0 8
46698: PPUSH
46699: LD_INT 3
46701: PPUSH
46702: LD_INT 4
46704: PPUSH
46705: CALL_OW 273
46709: PUSH
46710: EMPTY
46711: LIST
46712: LIST
46713: PUSH
46714: LD_VAR 0 7
46718: PPUSH
46719: LD_INT 4
46721: PPUSH
46722: LD_INT 4
46724: PPUSH
46725: CALL_OW 272
46729: PUSH
46730: LD_VAR 0 8
46734: PPUSH
46735: LD_INT 4
46737: PPUSH
46738: LD_INT 4
46740: PPUSH
46741: CALL_OW 273
46745: PUSH
46746: EMPTY
46747: LIST
46748: LIST
46749: PUSH
46750: LD_VAR 0 7
46754: PPUSH
46755: LD_INT 5
46757: PPUSH
46758: LD_INT 4
46760: PPUSH
46761: CALL_OW 272
46765: PUSH
46766: LD_VAR 0 8
46770: PPUSH
46771: LD_INT 5
46773: PPUSH
46774: LD_INT 4
46776: PPUSH
46777: CALL_OW 273
46781: PUSH
46782: EMPTY
46783: LIST
46784: LIST
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: LIST
46790: LIST
46791: LIST
46792: LIST
46793: ST_TO_ADDR
// for i = tmp downto 1 do
46794: LD_ADDR_VAR 0 4
46798: PUSH
46799: DOUBLE
46800: LD_VAR 0 6
46804: INC
46805: ST_TO_ADDR
46806: LD_INT 1
46808: PUSH
46809: FOR_DOWNTO
46810: IFFALSE 46911
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46812: LD_VAR 0 6
46816: PUSH
46817: LD_VAR 0 4
46821: ARRAY
46822: PUSH
46823: LD_INT 1
46825: ARRAY
46826: PPUSH
46827: LD_VAR 0 6
46831: PUSH
46832: LD_VAR 0 4
46836: ARRAY
46837: PUSH
46838: LD_INT 2
46840: ARRAY
46841: PPUSH
46842: CALL_OW 488
46846: NOT
46847: PUSH
46848: LD_VAR 0 6
46852: PUSH
46853: LD_VAR 0 4
46857: ARRAY
46858: PUSH
46859: LD_INT 1
46861: ARRAY
46862: PPUSH
46863: LD_VAR 0 6
46867: PUSH
46868: LD_VAR 0 4
46872: ARRAY
46873: PUSH
46874: LD_INT 2
46876: ARRAY
46877: PPUSH
46878: CALL_OW 428
46882: PUSH
46883: LD_INT 0
46885: NONEQUAL
46886: OR
46887: IFFALSE 46909
// tmp := Delete ( tmp , i ) ;
46889: LD_ADDR_VAR 0 6
46893: PUSH
46894: LD_VAR 0 6
46898: PPUSH
46899: LD_VAR 0 4
46903: PPUSH
46904: CALL_OW 3
46908: ST_TO_ADDR
46909: GO 46809
46911: POP
46912: POP
// j := GetClosestHex ( unit , tmp ) ;
46913: LD_ADDR_VAR 0 5
46917: PUSH
46918: LD_VAR 0 1
46922: PPUSH
46923: LD_VAR 0 6
46927: PPUSH
46928: CALL 46213 0 2
46932: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46933: LD_VAR 0 1
46937: PPUSH
46938: LD_VAR 0 5
46942: PUSH
46943: LD_INT 1
46945: ARRAY
46946: PPUSH
46947: LD_VAR 0 5
46951: PUSH
46952: LD_INT 2
46954: ARRAY
46955: PPUSH
46956: CALL_OW 111
// end ;
46960: LD_VAR 0 3
46964: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46965: LD_INT 0
46967: PPUSH
46968: PPUSH
46969: PPUSH
// uc_side = 0 ;
46970: LD_ADDR_OWVAR 20
46974: PUSH
46975: LD_INT 0
46977: ST_TO_ADDR
// uc_nation = 0 ;
46978: LD_ADDR_OWVAR 21
46982: PUSH
46983: LD_INT 0
46985: ST_TO_ADDR
// InitHc_All ( ) ;
46986: CALL_OW 584
// InitVc ;
46990: CALL_OW 20
// if mastodonts then
46994: LD_VAR 0 6
46998: IFFALSE 47065
// for i = 1 to mastodonts do
47000: LD_ADDR_VAR 0 11
47004: PUSH
47005: DOUBLE
47006: LD_INT 1
47008: DEC
47009: ST_TO_ADDR
47010: LD_VAR 0 6
47014: PUSH
47015: FOR_TO
47016: IFFALSE 47063
// begin vc_chassis := 31 ;
47018: LD_ADDR_OWVAR 37
47022: PUSH
47023: LD_INT 31
47025: ST_TO_ADDR
// vc_control := control_rider ;
47026: LD_ADDR_OWVAR 38
47030: PUSH
47031: LD_INT 4
47033: ST_TO_ADDR
// animal := CreateVehicle ;
47034: LD_ADDR_VAR 0 12
47038: PUSH
47039: CALL_OW 45
47043: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47044: LD_VAR 0 12
47048: PPUSH
47049: LD_VAR 0 8
47053: PPUSH
47054: LD_INT 0
47056: PPUSH
47057: CALL 49253 0 3
// end ;
47061: GO 47015
47063: POP
47064: POP
// if horses then
47065: LD_VAR 0 5
47069: IFFALSE 47136
// for i = 1 to horses do
47071: LD_ADDR_VAR 0 11
47075: PUSH
47076: DOUBLE
47077: LD_INT 1
47079: DEC
47080: ST_TO_ADDR
47081: LD_VAR 0 5
47085: PUSH
47086: FOR_TO
47087: IFFALSE 47134
// begin hc_class := 21 ;
47089: LD_ADDR_OWVAR 28
47093: PUSH
47094: LD_INT 21
47096: ST_TO_ADDR
// hc_gallery :=  ;
47097: LD_ADDR_OWVAR 33
47101: PUSH
47102: LD_STRING 
47104: ST_TO_ADDR
// animal := CreateHuman ;
47105: LD_ADDR_VAR 0 12
47109: PUSH
47110: CALL_OW 44
47114: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47115: LD_VAR 0 12
47119: PPUSH
47120: LD_VAR 0 8
47124: PPUSH
47125: LD_INT 0
47127: PPUSH
47128: CALL 49253 0 3
// end ;
47132: GO 47086
47134: POP
47135: POP
// if birds then
47136: LD_VAR 0 1
47140: IFFALSE 47207
// for i = 1 to birds do
47142: LD_ADDR_VAR 0 11
47146: PUSH
47147: DOUBLE
47148: LD_INT 1
47150: DEC
47151: ST_TO_ADDR
47152: LD_VAR 0 1
47156: PUSH
47157: FOR_TO
47158: IFFALSE 47205
// begin hc_class = 18 ;
47160: LD_ADDR_OWVAR 28
47164: PUSH
47165: LD_INT 18
47167: ST_TO_ADDR
// hc_gallery =  ;
47168: LD_ADDR_OWVAR 33
47172: PUSH
47173: LD_STRING 
47175: ST_TO_ADDR
// animal := CreateHuman ;
47176: LD_ADDR_VAR 0 12
47180: PUSH
47181: CALL_OW 44
47185: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47186: LD_VAR 0 12
47190: PPUSH
47191: LD_VAR 0 8
47195: PPUSH
47196: LD_INT 0
47198: PPUSH
47199: CALL 49253 0 3
// end ;
47203: GO 47157
47205: POP
47206: POP
// if tigers then
47207: LD_VAR 0 2
47211: IFFALSE 47295
// for i = 1 to tigers do
47213: LD_ADDR_VAR 0 11
47217: PUSH
47218: DOUBLE
47219: LD_INT 1
47221: DEC
47222: ST_TO_ADDR
47223: LD_VAR 0 2
47227: PUSH
47228: FOR_TO
47229: IFFALSE 47293
// begin hc_class = class_tiger ;
47231: LD_ADDR_OWVAR 28
47235: PUSH
47236: LD_INT 14
47238: ST_TO_ADDR
// hc_gallery =  ;
47239: LD_ADDR_OWVAR 33
47243: PUSH
47244: LD_STRING 
47246: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47247: LD_ADDR_OWVAR 35
47251: PUSH
47252: LD_INT 7
47254: NEG
47255: PPUSH
47256: LD_INT 7
47258: PPUSH
47259: CALL_OW 12
47263: ST_TO_ADDR
// animal := CreateHuman ;
47264: LD_ADDR_VAR 0 12
47268: PUSH
47269: CALL_OW 44
47273: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47274: LD_VAR 0 12
47278: PPUSH
47279: LD_VAR 0 8
47283: PPUSH
47284: LD_INT 0
47286: PPUSH
47287: CALL 49253 0 3
// end ;
47291: GO 47228
47293: POP
47294: POP
// if apemans then
47295: LD_VAR 0 3
47299: IFFALSE 47422
// for i = 1 to apemans do
47301: LD_ADDR_VAR 0 11
47305: PUSH
47306: DOUBLE
47307: LD_INT 1
47309: DEC
47310: ST_TO_ADDR
47311: LD_VAR 0 3
47315: PUSH
47316: FOR_TO
47317: IFFALSE 47420
// begin hc_class = class_apeman ;
47319: LD_ADDR_OWVAR 28
47323: PUSH
47324: LD_INT 12
47326: ST_TO_ADDR
// hc_gallery =  ;
47327: LD_ADDR_OWVAR 33
47331: PUSH
47332: LD_STRING 
47334: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
47335: LD_ADDR_OWVAR 35
47339: PUSH
47340: LD_INT 2
47342: NEG
47343: PPUSH
47344: LD_INT 2
47346: PPUSH
47347: CALL_OW 12
47351: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
47352: LD_ADDR_OWVAR 31
47356: PUSH
47357: LD_INT 1
47359: PPUSH
47360: LD_INT 3
47362: PPUSH
47363: CALL_OW 12
47367: PUSH
47368: LD_INT 1
47370: PPUSH
47371: LD_INT 3
47373: PPUSH
47374: CALL_OW 12
47378: PUSH
47379: LD_INT 0
47381: PUSH
47382: LD_INT 0
47384: PUSH
47385: EMPTY
47386: LIST
47387: LIST
47388: LIST
47389: LIST
47390: ST_TO_ADDR
// animal := CreateHuman ;
47391: LD_ADDR_VAR 0 12
47395: PUSH
47396: CALL_OW 44
47400: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47401: LD_VAR 0 12
47405: PPUSH
47406: LD_VAR 0 8
47410: PPUSH
47411: LD_INT 0
47413: PPUSH
47414: CALL 49253 0 3
// end ;
47418: GO 47316
47420: POP
47421: POP
// if enchidnas then
47422: LD_VAR 0 4
47426: IFFALSE 47493
// for i = 1 to enchidnas do
47428: LD_ADDR_VAR 0 11
47432: PUSH
47433: DOUBLE
47434: LD_INT 1
47436: DEC
47437: ST_TO_ADDR
47438: LD_VAR 0 4
47442: PUSH
47443: FOR_TO
47444: IFFALSE 47491
// begin hc_class = 13 ;
47446: LD_ADDR_OWVAR 28
47450: PUSH
47451: LD_INT 13
47453: ST_TO_ADDR
// hc_gallery =  ;
47454: LD_ADDR_OWVAR 33
47458: PUSH
47459: LD_STRING 
47461: ST_TO_ADDR
// animal := CreateHuman ;
47462: LD_ADDR_VAR 0 12
47466: PUSH
47467: CALL_OW 44
47471: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47472: LD_VAR 0 12
47476: PPUSH
47477: LD_VAR 0 8
47481: PPUSH
47482: LD_INT 0
47484: PPUSH
47485: CALL 49253 0 3
// end ;
47489: GO 47443
47491: POP
47492: POP
// if fishes then
47493: LD_VAR 0 7
47497: IFFALSE 47564
// for i = 1 to fishes do
47499: LD_ADDR_VAR 0 11
47503: PUSH
47504: DOUBLE
47505: LD_INT 1
47507: DEC
47508: ST_TO_ADDR
47509: LD_VAR 0 7
47513: PUSH
47514: FOR_TO
47515: IFFALSE 47562
// begin hc_class = 20 ;
47517: LD_ADDR_OWVAR 28
47521: PUSH
47522: LD_INT 20
47524: ST_TO_ADDR
// hc_gallery =  ;
47525: LD_ADDR_OWVAR 33
47529: PUSH
47530: LD_STRING 
47532: ST_TO_ADDR
// animal := CreateHuman ;
47533: LD_ADDR_VAR 0 12
47537: PUSH
47538: CALL_OW 44
47542: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
47543: LD_VAR 0 12
47547: PPUSH
47548: LD_VAR 0 9
47552: PPUSH
47553: LD_INT 0
47555: PPUSH
47556: CALL 49253 0 3
// end ;
47560: GO 47514
47562: POP
47563: POP
// end ;
47564: LD_VAR 0 10
47568: RET
// export function WantHeal ( sci , unit ) ; begin
47569: LD_INT 0
47571: PPUSH
// if GetTaskList ( sci ) > 0 then
47572: LD_VAR 0 1
47576: PPUSH
47577: CALL_OW 437
47581: PUSH
47582: LD_INT 0
47584: GREATER
47585: IFFALSE 47655
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
47587: LD_VAR 0 1
47591: PPUSH
47592: CALL_OW 437
47596: PUSH
47597: LD_INT 1
47599: ARRAY
47600: PUSH
47601: LD_INT 1
47603: ARRAY
47604: PUSH
47605: LD_STRING l
47607: EQUAL
47608: PUSH
47609: LD_VAR 0 1
47613: PPUSH
47614: CALL_OW 437
47618: PUSH
47619: LD_INT 1
47621: ARRAY
47622: PUSH
47623: LD_INT 4
47625: ARRAY
47626: PUSH
47627: LD_VAR 0 2
47631: EQUAL
47632: AND
47633: IFFALSE 47645
// result := true else
47635: LD_ADDR_VAR 0 3
47639: PUSH
47640: LD_INT 1
47642: ST_TO_ADDR
47643: GO 47653
// result := false ;
47645: LD_ADDR_VAR 0 3
47649: PUSH
47650: LD_INT 0
47652: ST_TO_ADDR
// end else
47653: GO 47663
// result := false ;
47655: LD_ADDR_VAR 0 3
47659: PUSH
47660: LD_INT 0
47662: ST_TO_ADDR
// end ;
47663: LD_VAR 0 3
47667: RET
// export function HealTarget ( sci ) ; begin
47668: LD_INT 0
47670: PPUSH
// if not sci then
47671: LD_VAR 0 1
47675: NOT
47676: IFFALSE 47680
// exit ;
47678: GO 47745
// result := 0 ;
47680: LD_ADDR_VAR 0 2
47684: PUSH
47685: LD_INT 0
47687: ST_TO_ADDR
// if GetTaskList ( sci ) then
47688: LD_VAR 0 1
47692: PPUSH
47693: CALL_OW 437
47697: IFFALSE 47745
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
47699: LD_VAR 0 1
47703: PPUSH
47704: CALL_OW 437
47708: PUSH
47709: LD_INT 1
47711: ARRAY
47712: PUSH
47713: LD_INT 1
47715: ARRAY
47716: PUSH
47717: LD_STRING l
47719: EQUAL
47720: IFFALSE 47745
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
47722: LD_ADDR_VAR 0 2
47726: PUSH
47727: LD_VAR 0 1
47731: PPUSH
47732: CALL_OW 437
47736: PUSH
47737: LD_INT 1
47739: ARRAY
47740: PUSH
47741: LD_INT 4
47743: ARRAY
47744: ST_TO_ADDR
// end ;
47745: LD_VAR 0 2
47749: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
47750: LD_INT 0
47752: PPUSH
47753: PPUSH
47754: PPUSH
47755: PPUSH
// if not base_units then
47756: LD_VAR 0 1
47760: NOT
47761: IFFALSE 47765
// exit ;
47763: GO 47852
// result := false ;
47765: LD_ADDR_VAR 0 2
47769: PUSH
47770: LD_INT 0
47772: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
47773: LD_ADDR_VAR 0 5
47777: PUSH
47778: LD_VAR 0 1
47782: PPUSH
47783: LD_INT 21
47785: PUSH
47786: LD_INT 3
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: PPUSH
47793: CALL_OW 72
47797: ST_TO_ADDR
// if not tmp then
47798: LD_VAR 0 5
47802: NOT
47803: IFFALSE 47807
// exit ;
47805: GO 47852
// for i in tmp do
47807: LD_ADDR_VAR 0 3
47811: PUSH
47812: LD_VAR 0 5
47816: PUSH
47817: FOR_IN
47818: IFFALSE 47850
// begin result := EnemyInRange ( i , 22 ) ;
47820: LD_ADDR_VAR 0 2
47824: PUSH
47825: LD_VAR 0 3
47829: PPUSH
47830: LD_INT 22
47832: PPUSH
47833: CALL 46088 0 2
47837: ST_TO_ADDR
// if result then
47838: LD_VAR 0 2
47842: IFFALSE 47848
// exit ;
47844: POP
47845: POP
47846: GO 47852
// end ;
47848: GO 47817
47850: POP
47851: POP
// end ;
47852: LD_VAR 0 2
47856: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
47857: LD_INT 0
47859: PPUSH
47860: PPUSH
// if not units then
47861: LD_VAR 0 1
47865: NOT
47866: IFFALSE 47870
// exit ;
47868: GO 47940
// result := [ ] ;
47870: LD_ADDR_VAR 0 3
47874: PUSH
47875: EMPTY
47876: ST_TO_ADDR
// for i in units do
47877: LD_ADDR_VAR 0 4
47881: PUSH
47882: LD_VAR 0 1
47886: PUSH
47887: FOR_IN
47888: IFFALSE 47938
// if GetTag ( i ) = tag then
47890: LD_VAR 0 4
47894: PPUSH
47895: CALL_OW 110
47899: PUSH
47900: LD_VAR 0 2
47904: EQUAL
47905: IFFALSE 47936
// result := Replace ( result , result + 1 , i ) ;
47907: LD_ADDR_VAR 0 3
47911: PUSH
47912: LD_VAR 0 3
47916: PPUSH
47917: LD_VAR 0 3
47921: PUSH
47922: LD_INT 1
47924: PLUS
47925: PPUSH
47926: LD_VAR 0 4
47930: PPUSH
47931: CALL_OW 1
47935: ST_TO_ADDR
47936: GO 47887
47938: POP
47939: POP
// end ;
47940: LD_VAR 0 3
47944: RET
// export function IsDriver ( un ) ; begin
47945: LD_INT 0
47947: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47948: LD_ADDR_VAR 0 2
47952: PUSH
47953: LD_VAR 0 1
47957: PUSH
47958: LD_INT 55
47960: PUSH
47961: EMPTY
47962: LIST
47963: PPUSH
47964: CALL_OW 69
47968: IN
47969: ST_TO_ADDR
// end ;
47970: LD_VAR 0 2
47974: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47975: LD_INT 0
47977: PPUSH
47978: PPUSH
// list := [ ] ;
47979: LD_ADDR_VAR 0 5
47983: PUSH
47984: EMPTY
47985: ST_TO_ADDR
// case d of 0 :
47986: LD_VAR 0 3
47990: PUSH
47991: LD_INT 0
47993: DOUBLE
47994: EQUAL
47995: IFTRUE 47999
47997: GO 48132
47999: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
48000: LD_ADDR_VAR 0 5
48004: PUSH
48005: LD_VAR 0 1
48009: PUSH
48010: LD_INT 4
48012: MINUS
48013: PUSH
48014: LD_VAR 0 2
48018: PUSH
48019: LD_INT 4
48021: MINUS
48022: PUSH
48023: LD_INT 2
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: LIST
48030: PUSH
48031: LD_VAR 0 1
48035: PUSH
48036: LD_INT 3
48038: MINUS
48039: PUSH
48040: LD_VAR 0 2
48044: PUSH
48045: LD_INT 1
48047: PUSH
48048: EMPTY
48049: LIST
48050: LIST
48051: LIST
48052: PUSH
48053: LD_VAR 0 1
48057: PUSH
48058: LD_INT 4
48060: PLUS
48061: PUSH
48062: LD_VAR 0 2
48066: PUSH
48067: LD_INT 4
48069: PUSH
48070: EMPTY
48071: LIST
48072: LIST
48073: LIST
48074: PUSH
48075: LD_VAR 0 1
48079: PUSH
48080: LD_INT 3
48082: PLUS
48083: PUSH
48084: LD_VAR 0 2
48088: PUSH
48089: LD_INT 3
48091: PLUS
48092: PUSH
48093: LD_INT 5
48095: PUSH
48096: EMPTY
48097: LIST
48098: LIST
48099: LIST
48100: PUSH
48101: LD_VAR 0 1
48105: PUSH
48106: LD_VAR 0 2
48110: PUSH
48111: LD_INT 4
48113: PLUS
48114: PUSH
48115: LD_INT 0
48117: PUSH
48118: EMPTY
48119: LIST
48120: LIST
48121: LIST
48122: PUSH
48123: EMPTY
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: ST_TO_ADDR
// end ; 1 :
48130: GO 48830
48132: LD_INT 1
48134: DOUBLE
48135: EQUAL
48136: IFTRUE 48140
48138: GO 48273
48140: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48141: LD_ADDR_VAR 0 5
48145: PUSH
48146: LD_VAR 0 1
48150: PUSH
48151: LD_VAR 0 2
48155: PUSH
48156: LD_INT 4
48158: MINUS
48159: PUSH
48160: LD_INT 3
48162: PUSH
48163: EMPTY
48164: LIST
48165: LIST
48166: LIST
48167: PUSH
48168: LD_VAR 0 1
48172: PUSH
48173: LD_INT 3
48175: MINUS
48176: PUSH
48177: LD_VAR 0 2
48181: PUSH
48182: LD_INT 3
48184: MINUS
48185: PUSH
48186: LD_INT 2
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: LIST
48193: PUSH
48194: LD_VAR 0 1
48198: PUSH
48199: LD_INT 4
48201: MINUS
48202: PUSH
48203: LD_VAR 0 2
48207: PUSH
48208: LD_INT 1
48210: PUSH
48211: EMPTY
48212: LIST
48213: LIST
48214: LIST
48215: PUSH
48216: LD_VAR 0 1
48220: PUSH
48221: LD_VAR 0 2
48225: PUSH
48226: LD_INT 3
48228: PLUS
48229: PUSH
48230: LD_INT 0
48232: PUSH
48233: EMPTY
48234: LIST
48235: LIST
48236: LIST
48237: PUSH
48238: LD_VAR 0 1
48242: PUSH
48243: LD_INT 4
48245: PLUS
48246: PUSH
48247: LD_VAR 0 2
48251: PUSH
48252: LD_INT 4
48254: PLUS
48255: PUSH
48256: LD_INT 5
48258: PUSH
48259: EMPTY
48260: LIST
48261: LIST
48262: LIST
48263: PUSH
48264: EMPTY
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: ST_TO_ADDR
// end ; 2 :
48271: GO 48830
48273: LD_INT 2
48275: DOUBLE
48276: EQUAL
48277: IFTRUE 48281
48279: GO 48410
48281: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48282: LD_ADDR_VAR 0 5
48286: PUSH
48287: LD_VAR 0 1
48291: PUSH
48292: LD_VAR 0 2
48296: PUSH
48297: LD_INT 3
48299: MINUS
48300: PUSH
48301: LD_INT 3
48303: PUSH
48304: EMPTY
48305: LIST
48306: LIST
48307: LIST
48308: PUSH
48309: LD_VAR 0 1
48313: PUSH
48314: LD_INT 4
48316: PLUS
48317: PUSH
48318: LD_VAR 0 2
48322: PUSH
48323: LD_INT 4
48325: PUSH
48326: EMPTY
48327: LIST
48328: LIST
48329: LIST
48330: PUSH
48331: LD_VAR 0 1
48335: PUSH
48336: LD_VAR 0 2
48340: PUSH
48341: LD_INT 4
48343: PLUS
48344: PUSH
48345: LD_INT 0
48347: PUSH
48348: EMPTY
48349: LIST
48350: LIST
48351: LIST
48352: PUSH
48353: LD_VAR 0 1
48357: PUSH
48358: LD_INT 3
48360: MINUS
48361: PUSH
48362: LD_VAR 0 2
48366: PUSH
48367: LD_INT 1
48369: PUSH
48370: EMPTY
48371: LIST
48372: LIST
48373: LIST
48374: PUSH
48375: LD_VAR 0 1
48379: PUSH
48380: LD_INT 4
48382: MINUS
48383: PUSH
48384: LD_VAR 0 2
48388: PUSH
48389: LD_INT 4
48391: MINUS
48392: PUSH
48393: LD_INT 2
48395: PUSH
48396: EMPTY
48397: LIST
48398: LIST
48399: LIST
48400: PUSH
48401: EMPTY
48402: LIST
48403: LIST
48404: LIST
48405: LIST
48406: LIST
48407: ST_TO_ADDR
// end ; 3 :
48408: GO 48830
48410: LD_INT 3
48412: DOUBLE
48413: EQUAL
48414: IFTRUE 48418
48416: GO 48551
48418: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
48419: LD_ADDR_VAR 0 5
48423: PUSH
48424: LD_VAR 0 1
48428: PUSH
48429: LD_INT 3
48431: PLUS
48432: PUSH
48433: LD_VAR 0 2
48437: PUSH
48438: LD_INT 4
48440: PUSH
48441: EMPTY
48442: LIST
48443: LIST
48444: LIST
48445: PUSH
48446: LD_VAR 0 1
48450: PUSH
48451: LD_INT 4
48453: PLUS
48454: PUSH
48455: LD_VAR 0 2
48459: PUSH
48460: LD_INT 4
48462: PLUS
48463: PUSH
48464: LD_INT 5
48466: PUSH
48467: EMPTY
48468: LIST
48469: LIST
48470: LIST
48471: PUSH
48472: LD_VAR 0 1
48476: PUSH
48477: LD_INT 4
48479: MINUS
48480: PUSH
48481: LD_VAR 0 2
48485: PUSH
48486: LD_INT 1
48488: PUSH
48489: EMPTY
48490: LIST
48491: LIST
48492: LIST
48493: PUSH
48494: LD_VAR 0 1
48498: PUSH
48499: LD_VAR 0 2
48503: PUSH
48504: LD_INT 4
48506: MINUS
48507: PUSH
48508: LD_INT 3
48510: PUSH
48511: EMPTY
48512: LIST
48513: LIST
48514: LIST
48515: PUSH
48516: LD_VAR 0 1
48520: PUSH
48521: LD_INT 3
48523: MINUS
48524: PUSH
48525: LD_VAR 0 2
48529: PUSH
48530: LD_INT 3
48532: MINUS
48533: PUSH
48534: LD_INT 2
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: LIST
48541: PUSH
48542: EMPTY
48543: LIST
48544: LIST
48545: LIST
48546: LIST
48547: LIST
48548: ST_TO_ADDR
// end ; 4 :
48549: GO 48830
48551: LD_INT 4
48553: DOUBLE
48554: EQUAL
48555: IFTRUE 48559
48557: GO 48692
48559: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
48560: LD_ADDR_VAR 0 5
48564: PUSH
48565: LD_VAR 0 1
48569: PUSH
48570: LD_VAR 0 2
48574: PUSH
48575: LD_INT 4
48577: PLUS
48578: PUSH
48579: LD_INT 0
48581: PUSH
48582: EMPTY
48583: LIST
48584: LIST
48585: LIST
48586: PUSH
48587: LD_VAR 0 1
48591: PUSH
48592: LD_INT 3
48594: PLUS
48595: PUSH
48596: LD_VAR 0 2
48600: PUSH
48601: LD_INT 3
48603: PLUS
48604: PUSH
48605: LD_INT 5
48607: PUSH
48608: EMPTY
48609: LIST
48610: LIST
48611: LIST
48612: PUSH
48613: LD_VAR 0 1
48617: PUSH
48618: LD_INT 4
48620: PLUS
48621: PUSH
48622: LD_VAR 0 2
48626: PUSH
48627: LD_INT 4
48629: PUSH
48630: EMPTY
48631: LIST
48632: LIST
48633: LIST
48634: PUSH
48635: LD_VAR 0 1
48639: PUSH
48640: LD_VAR 0 2
48644: PUSH
48645: LD_INT 3
48647: MINUS
48648: PUSH
48649: LD_INT 3
48651: PUSH
48652: EMPTY
48653: LIST
48654: LIST
48655: LIST
48656: PUSH
48657: LD_VAR 0 1
48661: PUSH
48662: LD_INT 4
48664: MINUS
48665: PUSH
48666: LD_VAR 0 2
48670: PUSH
48671: LD_INT 4
48673: MINUS
48674: PUSH
48675: LD_INT 2
48677: PUSH
48678: EMPTY
48679: LIST
48680: LIST
48681: LIST
48682: PUSH
48683: EMPTY
48684: LIST
48685: LIST
48686: LIST
48687: LIST
48688: LIST
48689: ST_TO_ADDR
// end ; 5 :
48690: GO 48830
48692: LD_INT 5
48694: DOUBLE
48695: EQUAL
48696: IFTRUE 48700
48698: GO 48829
48700: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
48701: LD_ADDR_VAR 0 5
48705: PUSH
48706: LD_VAR 0 1
48710: PUSH
48711: LD_INT 4
48713: MINUS
48714: PUSH
48715: LD_VAR 0 2
48719: PUSH
48720: LD_INT 1
48722: PUSH
48723: EMPTY
48724: LIST
48725: LIST
48726: LIST
48727: PUSH
48728: LD_VAR 0 1
48732: PUSH
48733: LD_VAR 0 2
48737: PUSH
48738: LD_INT 4
48740: MINUS
48741: PUSH
48742: LD_INT 3
48744: PUSH
48745: EMPTY
48746: LIST
48747: LIST
48748: LIST
48749: PUSH
48750: LD_VAR 0 1
48754: PUSH
48755: LD_INT 4
48757: PLUS
48758: PUSH
48759: LD_VAR 0 2
48763: PUSH
48764: LD_INT 4
48766: PLUS
48767: PUSH
48768: LD_INT 5
48770: PUSH
48771: EMPTY
48772: LIST
48773: LIST
48774: LIST
48775: PUSH
48776: LD_VAR 0 1
48780: PUSH
48781: LD_INT 3
48783: PLUS
48784: PUSH
48785: LD_VAR 0 2
48789: PUSH
48790: LD_INT 4
48792: PUSH
48793: EMPTY
48794: LIST
48795: LIST
48796: LIST
48797: PUSH
48798: LD_VAR 0 1
48802: PUSH
48803: LD_VAR 0 2
48807: PUSH
48808: LD_INT 3
48810: PLUS
48811: PUSH
48812: LD_INT 0
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: LIST
48819: PUSH
48820: EMPTY
48821: LIST
48822: LIST
48823: LIST
48824: LIST
48825: LIST
48826: ST_TO_ADDR
// end ; end ;
48827: GO 48830
48829: POP
// result := list ;
48830: LD_ADDR_VAR 0 4
48834: PUSH
48835: LD_VAR 0 5
48839: ST_TO_ADDR
// end ;
48840: LD_VAR 0 4
48844: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48845: LD_INT 0
48847: PPUSH
48848: PPUSH
48849: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48850: LD_VAR 0 1
48854: NOT
48855: PUSH
48856: LD_VAR 0 2
48860: PUSH
48861: LD_INT 1
48863: PUSH
48864: LD_INT 2
48866: PUSH
48867: LD_INT 3
48869: PUSH
48870: LD_INT 4
48872: PUSH
48873: EMPTY
48874: LIST
48875: LIST
48876: LIST
48877: LIST
48878: IN
48879: NOT
48880: OR
48881: IFFALSE 48885
// exit ;
48883: GO 48977
// tmp := [ ] ;
48885: LD_ADDR_VAR 0 5
48889: PUSH
48890: EMPTY
48891: ST_TO_ADDR
// for i in units do
48892: LD_ADDR_VAR 0 4
48896: PUSH
48897: LD_VAR 0 1
48901: PUSH
48902: FOR_IN
48903: IFFALSE 48946
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48905: LD_ADDR_VAR 0 5
48909: PUSH
48910: LD_VAR 0 5
48914: PPUSH
48915: LD_VAR 0 5
48919: PUSH
48920: LD_INT 1
48922: PLUS
48923: PPUSH
48924: LD_VAR 0 4
48928: PPUSH
48929: LD_VAR 0 2
48933: PPUSH
48934: CALL_OW 259
48938: PPUSH
48939: CALL_OW 2
48943: ST_TO_ADDR
48944: GO 48902
48946: POP
48947: POP
// if not tmp then
48948: LD_VAR 0 5
48952: NOT
48953: IFFALSE 48957
// exit ;
48955: GO 48977
// result := SortListByListDesc ( units , tmp ) ;
48957: LD_ADDR_VAR 0 3
48961: PUSH
48962: LD_VAR 0 1
48966: PPUSH
48967: LD_VAR 0 5
48971: PPUSH
48972: CALL_OW 77
48976: ST_TO_ADDR
// end ;
48977: LD_VAR 0 3
48981: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48982: LD_INT 0
48984: PPUSH
48985: PPUSH
48986: PPUSH
// result := false ;
48987: LD_ADDR_VAR 0 3
48991: PUSH
48992: LD_INT 0
48994: ST_TO_ADDR
// x := GetX ( building ) ;
48995: LD_ADDR_VAR 0 4
48999: PUSH
49000: LD_VAR 0 2
49004: PPUSH
49005: CALL_OW 250
49009: ST_TO_ADDR
// y := GetY ( building ) ;
49010: LD_ADDR_VAR 0 5
49014: PUSH
49015: LD_VAR 0 2
49019: PPUSH
49020: CALL_OW 251
49024: ST_TO_ADDR
// if not building or not x or not y then
49025: LD_VAR 0 2
49029: NOT
49030: PUSH
49031: LD_VAR 0 4
49035: NOT
49036: OR
49037: PUSH
49038: LD_VAR 0 5
49042: NOT
49043: OR
49044: IFFALSE 49048
// exit ;
49046: GO 49140
// if GetTaskList ( unit ) then
49048: LD_VAR 0 1
49052: PPUSH
49053: CALL_OW 437
49057: IFFALSE 49140
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49059: LD_STRING e
49061: PUSH
49062: LD_VAR 0 1
49066: PPUSH
49067: CALL_OW 437
49071: PUSH
49072: LD_INT 1
49074: ARRAY
49075: PUSH
49076: LD_INT 1
49078: ARRAY
49079: EQUAL
49080: PUSH
49081: LD_VAR 0 4
49085: PUSH
49086: LD_VAR 0 1
49090: PPUSH
49091: CALL_OW 437
49095: PUSH
49096: LD_INT 1
49098: ARRAY
49099: PUSH
49100: LD_INT 2
49102: ARRAY
49103: EQUAL
49104: AND
49105: PUSH
49106: LD_VAR 0 5
49110: PUSH
49111: LD_VAR 0 1
49115: PPUSH
49116: CALL_OW 437
49120: PUSH
49121: LD_INT 1
49123: ARRAY
49124: PUSH
49125: LD_INT 3
49127: ARRAY
49128: EQUAL
49129: AND
49130: IFFALSE 49140
// result := true end ;
49132: LD_ADDR_VAR 0 3
49136: PUSH
49137: LD_INT 1
49139: ST_TO_ADDR
// end ;
49140: LD_VAR 0 3
49144: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
49145: LD_INT 0
49147: PPUSH
// result := false ;
49148: LD_ADDR_VAR 0 4
49152: PUSH
49153: LD_INT 0
49155: ST_TO_ADDR
// if GetTaskList ( unit ) then
49156: LD_VAR 0 1
49160: PPUSH
49161: CALL_OW 437
49165: IFFALSE 49248
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49167: LD_STRING M
49169: PUSH
49170: LD_VAR 0 1
49174: PPUSH
49175: CALL_OW 437
49179: PUSH
49180: LD_INT 1
49182: ARRAY
49183: PUSH
49184: LD_INT 1
49186: ARRAY
49187: EQUAL
49188: PUSH
49189: LD_VAR 0 2
49193: PUSH
49194: LD_VAR 0 1
49198: PPUSH
49199: CALL_OW 437
49203: PUSH
49204: LD_INT 1
49206: ARRAY
49207: PUSH
49208: LD_INT 2
49210: ARRAY
49211: EQUAL
49212: AND
49213: PUSH
49214: LD_VAR 0 3
49218: PUSH
49219: LD_VAR 0 1
49223: PPUSH
49224: CALL_OW 437
49228: PUSH
49229: LD_INT 1
49231: ARRAY
49232: PUSH
49233: LD_INT 3
49235: ARRAY
49236: EQUAL
49237: AND
49238: IFFALSE 49248
// result := true ;
49240: LD_ADDR_VAR 0 4
49244: PUSH
49245: LD_INT 1
49247: ST_TO_ADDR
// end ; end ;
49248: LD_VAR 0 4
49252: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49253: LD_INT 0
49255: PPUSH
49256: PPUSH
49257: PPUSH
49258: PPUSH
// if not unit or not area then
49259: LD_VAR 0 1
49263: NOT
49264: PUSH
49265: LD_VAR 0 2
49269: NOT
49270: OR
49271: IFFALSE 49275
// exit ;
49273: GO 49439
// tmp := AreaToList ( area , i ) ;
49275: LD_ADDR_VAR 0 6
49279: PUSH
49280: LD_VAR 0 2
49284: PPUSH
49285: LD_VAR 0 5
49289: PPUSH
49290: CALL_OW 517
49294: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49295: LD_ADDR_VAR 0 5
49299: PUSH
49300: DOUBLE
49301: LD_INT 1
49303: DEC
49304: ST_TO_ADDR
49305: LD_VAR 0 6
49309: PUSH
49310: LD_INT 1
49312: ARRAY
49313: PUSH
49314: FOR_TO
49315: IFFALSE 49437
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49317: LD_ADDR_VAR 0 7
49321: PUSH
49322: LD_VAR 0 6
49326: PUSH
49327: LD_INT 1
49329: ARRAY
49330: PUSH
49331: LD_VAR 0 5
49335: ARRAY
49336: PUSH
49337: LD_VAR 0 6
49341: PUSH
49342: LD_INT 2
49344: ARRAY
49345: PUSH
49346: LD_VAR 0 5
49350: ARRAY
49351: PUSH
49352: EMPTY
49353: LIST
49354: LIST
49355: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
49356: LD_VAR 0 7
49360: PUSH
49361: LD_INT 1
49363: ARRAY
49364: PPUSH
49365: LD_VAR 0 7
49369: PUSH
49370: LD_INT 2
49372: ARRAY
49373: PPUSH
49374: CALL_OW 428
49378: PUSH
49379: LD_INT 0
49381: EQUAL
49382: IFFALSE 49435
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
49384: LD_VAR 0 1
49388: PPUSH
49389: LD_VAR 0 7
49393: PUSH
49394: LD_INT 1
49396: ARRAY
49397: PPUSH
49398: LD_VAR 0 7
49402: PUSH
49403: LD_INT 2
49405: ARRAY
49406: PPUSH
49407: LD_VAR 0 3
49411: PPUSH
49412: CALL_OW 48
// result := IsPlaced ( unit ) ;
49416: LD_ADDR_VAR 0 4
49420: PUSH
49421: LD_VAR 0 1
49425: PPUSH
49426: CALL_OW 305
49430: ST_TO_ADDR
// exit ;
49431: POP
49432: POP
49433: GO 49439
// end ; end ;
49435: GO 49314
49437: POP
49438: POP
// end ;
49439: LD_VAR 0 4
49443: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
49444: LD_INT 0
49446: PPUSH
49447: PPUSH
49448: PPUSH
// if not side or side > 8 then
49449: LD_VAR 0 1
49453: NOT
49454: PUSH
49455: LD_VAR 0 1
49459: PUSH
49460: LD_INT 8
49462: GREATER
49463: OR
49464: IFFALSE 49468
// exit ;
49466: GO 49655
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
49468: LD_ADDR_VAR 0 4
49472: PUSH
49473: LD_INT 22
49475: PUSH
49476: LD_VAR 0 1
49480: PUSH
49481: EMPTY
49482: LIST
49483: LIST
49484: PUSH
49485: LD_INT 21
49487: PUSH
49488: LD_INT 3
49490: PUSH
49491: EMPTY
49492: LIST
49493: LIST
49494: PUSH
49495: EMPTY
49496: LIST
49497: LIST
49498: PPUSH
49499: CALL_OW 69
49503: ST_TO_ADDR
// if not tmp then
49504: LD_VAR 0 4
49508: NOT
49509: IFFALSE 49513
// exit ;
49511: GO 49655
// enable_addtolog := true ;
49513: LD_ADDR_OWVAR 81
49517: PUSH
49518: LD_INT 1
49520: ST_TO_ADDR
// AddToLog ( [ ) ;
49521: LD_STRING [
49523: PPUSH
49524: CALL_OW 561
// for i in tmp do
49528: LD_ADDR_VAR 0 3
49532: PUSH
49533: LD_VAR 0 4
49537: PUSH
49538: FOR_IN
49539: IFFALSE 49646
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
49541: LD_STRING [
49543: PUSH
49544: LD_VAR 0 3
49548: PPUSH
49549: CALL_OW 266
49553: STR
49554: PUSH
49555: LD_STRING , 
49557: STR
49558: PUSH
49559: LD_VAR 0 3
49563: PPUSH
49564: CALL_OW 250
49568: STR
49569: PUSH
49570: LD_STRING , 
49572: STR
49573: PUSH
49574: LD_VAR 0 3
49578: PPUSH
49579: CALL_OW 251
49583: STR
49584: PUSH
49585: LD_STRING , 
49587: STR
49588: PUSH
49589: LD_VAR 0 3
49593: PPUSH
49594: CALL_OW 254
49598: STR
49599: PUSH
49600: LD_STRING , 
49602: STR
49603: PUSH
49604: LD_VAR 0 3
49608: PPUSH
49609: LD_INT 1
49611: PPUSH
49612: CALL_OW 268
49616: STR
49617: PUSH
49618: LD_STRING , 
49620: STR
49621: PUSH
49622: LD_VAR 0 3
49626: PPUSH
49627: LD_INT 2
49629: PPUSH
49630: CALL_OW 268
49634: STR
49635: PUSH
49636: LD_STRING ],
49638: STR
49639: PPUSH
49640: CALL_OW 561
// end ;
49644: GO 49538
49646: POP
49647: POP
// AddToLog ( ]; ) ;
49648: LD_STRING ];
49650: PPUSH
49651: CALL_OW 561
// end ;
49655: LD_VAR 0 2
49659: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
49660: LD_INT 0
49662: PPUSH
49663: PPUSH
49664: PPUSH
49665: PPUSH
49666: PPUSH
// if not area or not rate or not max then
49667: LD_VAR 0 1
49671: NOT
49672: PUSH
49673: LD_VAR 0 2
49677: NOT
49678: OR
49679: PUSH
49680: LD_VAR 0 4
49684: NOT
49685: OR
49686: IFFALSE 49690
// exit ;
49688: GO 49882
// while 1 do
49690: LD_INT 1
49692: IFFALSE 49882
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
49694: LD_ADDR_VAR 0 9
49698: PUSH
49699: LD_VAR 0 1
49703: PPUSH
49704: LD_INT 1
49706: PPUSH
49707: CALL_OW 287
49711: PUSH
49712: LD_INT 10
49714: MUL
49715: ST_TO_ADDR
// r := rate / 10 ;
49716: LD_ADDR_VAR 0 7
49720: PUSH
49721: LD_VAR 0 2
49725: PUSH
49726: LD_INT 10
49728: DIVREAL
49729: ST_TO_ADDR
// time := 1 1$00 ;
49730: LD_ADDR_VAR 0 8
49734: PUSH
49735: LD_INT 2100
49737: ST_TO_ADDR
// if amount < min then
49738: LD_VAR 0 9
49742: PUSH
49743: LD_VAR 0 3
49747: LESS
49748: IFFALSE 49766
// r := r * 2 else
49750: LD_ADDR_VAR 0 7
49754: PUSH
49755: LD_VAR 0 7
49759: PUSH
49760: LD_INT 2
49762: MUL
49763: ST_TO_ADDR
49764: GO 49792
// if amount > max then
49766: LD_VAR 0 9
49770: PUSH
49771: LD_VAR 0 4
49775: GREATER
49776: IFFALSE 49792
// r := r / 2 ;
49778: LD_ADDR_VAR 0 7
49782: PUSH
49783: LD_VAR 0 7
49787: PUSH
49788: LD_INT 2
49790: DIVREAL
49791: ST_TO_ADDR
// time := time / r ;
49792: LD_ADDR_VAR 0 8
49796: PUSH
49797: LD_VAR 0 8
49801: PUSH
49802: LD_VAR 0 7
49806: DIVREAL
49807: ST_TO_ADDR
// if time < 0 then
49808: LD_VAR 0 8
49812: PUSH
49813: LD_INT 0
49815: LESS
49816: IFFALSE 49833
// time := time * - 1 ;
49818: LD_ADDR_VAR 0 8
49822: PUSH
49823: LD_VAR 0 8
49827: PUSH
49828: LD_INT 1
49830: NEG
49831: MUL
49832: ST_TO_ADDR
// wait ( time ) ;
49833: LD_VAR 0 8
49837: PPUSH
49838: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
49842: LD_INT 35
49844: PPUSH
49845: LD_INT 875
49847: PPUSH
49848: CALL_OW 12
49852: PPUSH
49853: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
49857: LD_INT 1
49859: PPUSH
49860: LD_INT 5
49862: PPUSH
49863: CALL_OW 12
49867: PPUSH
49868: LD_VAR 0 1
49872: PPUSH
49873: LD_INT 1
49875: PPUSH
49876: CALL_OW 55
// end ;
49880: GO 49690
// end ;
49882: LD_VAR 0 5
49886: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
49887: LD_INT 0
49889: PPUSH
49890: PPUSH
49891: PPUSH
49892: PPUSH
49893: PPUSH
49894: PPUSH
49895: PPUSH
49896: PPUSH
// if not turrets or not factories then
49897: LD_VAR 0 1
49901: NOT
49902: PUSH
49903: LD_VAR 0 2
49907: NOT
49908: OR
49909: IFFALSE 49913
// exit ;
49911: GO 50220
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49913: LD_ADDR_VAR 0 10
49917: PUSH
49918: LD_INT 5
49920: PUSH
49921: LD_INT 6
49923: PUSH
49924: EMPTY
49925: LIST
49926: LIST
49927: PUSH
49928: LD_INT 2
49930: PUSH
49931: LD_INT 4
49933: PUSH
49934: EMPTY
49935: LIST
49936: LIST
49937: PUSH
49938: LD_INT 3
49940: PUSH
49941: LD_INT 5
49943: PUSH
49944: EMPTY
49945: LIST
49946: LIST
49947: PUSH
49948: EMPTY
49949: LIST
49950: LIST
49951: LIST
49952: PUSH
49953: LD_INT 24
49955: PUSH
49956: LD_INT 25
49958: PUSH
49959: EMPTY
49960: LIST
49961: LIST
49962: PUSH
49963: LD_INT 23
49965: PUSH
49966: LD_INT 27
49968: PUSH
49969: EMPTY
49970: LIST
49971: LIST
49972: PUSH
49973: EMPTY
49974: LIST
49975: LIST
49976: PUSH
49977: LD_INT 42
49979: PUSH
49980: LD_INT 43
49982: PUSH
49983: EMPTY
49984: LIST
49985: LIST
49986: PUSH
49987: LD_INT 44
49989: PUSH
49990: LD_INT 46
49992: PUSH
49993: EMPTY
49994: LIST
49995: LIST
49996: PUSH
49997: LD_INT 45
49999: PUSH
50000: LD_INT 47
50002: PUSH
50003: EMPTY
50004: LIST
50005: LIST
50006: PUSH
50007: EMPTY
50008: LIST
50009: LIST
50010: LIST
50011: PUSH
50012: EMPTY
50013: LIST
50014: LIST
50015: LIST
50016: ST_TO_ADDR
// result := [ ] ;
50017: LD_ADDR_VAR 0 3
50021: PUSH
50022: EMPTY
50023: ST_TO_ADDR
// for i in turrets do
50024: LD_ADDR_VAR 0 4
50028: PUSH
50029: LD_VAR 0 1
50033: PUSH
50034: FOR_IN
50035: IFFALSE 50218
// begin nat := GetNation ( i ) ;
50037: LD_ADDR_VAR 0 7
50041: PUSH
50042: LD_VAR 0 4
50046: PPUSH
50047: CALL_OW 248
50051: ST_TO_ADDR
// weapon := 0 ;
50052: LD_ADDR_VAR 0 8
50056: PUSH
50057: LD_INT 0
50059: ST_TO_ADDR
// if not nat then
50060: LD_VAR 0 7
50064: NOT
50065: IFFALSE 50069
// continue ;
50067: GO 50034
// for j in list [ nat ] do
50069: LD_ADDR_VAR 0 5
50073: PUSH
50074: LD_VAR 0 10
50078: PUSH
50079: LD_VAR 0 7
50083: ARRAY
50084: PUSH
50085: FOR_IN
50086: IFFALSE 50127
// if GetBWeapon ( i ) = j [ 1 ] then
50088: LD_VAR 0 4
50092: PPUSH
50093: CALL_OW 269
50097: PUSH
50098: LD_VAR 0 5
50102: PUSH
50103: LD_INT 1
50105: ARRAY
50106: EQUAL
50107: IFFALSE 50125
// begin weapon := j [ 2 ] ;
50109: LD_ADDR_VAR 0 8
50113: PUSH
50114: LD_VAR 0 5
50118: PUSH
50119: LD_INT 2
50121: ARRAY
50122: ST_TO_ADDR
// break ;
50123: GO 50127
// end ;
50125: GO 50085
50127: POP
50128: POP
// if not weapon then
50129: LD_VAR 0 8
50133: NOT
50134: IFFALSE 50138
// continue ;
50136: GO 50034
// for k in factories do
50138: LD_ADDR_VAR 0 6
50142: PUSH
50143: LD_VAR 0 2
50147: PUSH
50148: FOR_IN
50149: IFFALSE 50214
// begin weapons := AvailableWeaponList ( k ) ;
50151: LD_ADDR_VAR 0 9
50155: PUSH
50156: LD_VAR 0 6
50160: PPUSH
50161: CALL_OW 478
50165: ST_TO_ADDR
// if not weapons then
50166: LD_VAR 0 9
50170: NOT
50171: IFFALSE 50175
// continue ;
50173: GO 50148
// if weapon in weapons then
50175: LD_VAR 0 8
50179: PUSH
50180: LD_VAR 0 9
50184: IN
50185: IFFALSE 50212
// begin result := [ i , weapon ] ;
50187: LD_ADDR_VAR 0 3
50191: PUSH
50192: LD_VAR 0 4
50196: PUSH
50197: LD_VAR 0 8
50201: PUSH
50202: EMPTY
50203: LIST
50204: LIST
50205: ST_TO_ADDR
// exit ;
50206: POP
50207: POP
50208: POP
50209: POP
50210: GO 50220
// end ; end ;
50212: GO 50148
50214: POP
50215: POP
// end ;
50216: GO 50034
50218: POP
50219: POP
// end ;
50220: LD_VAR 0 3
50224: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50225: LD_INT 0
50227: PPUSH
// if not side or side > 8 then
50228: LD_VAR 0 3
50232: NOT
50233: PUSH
50234: LD_VAR 0 3
50238: PUSH
50239: LD_INT 8
50241: GREATER
50242: OR
50243: IFFALSE 50247
// exit ;
50245: GO 50306
// if not range then
50247: LD_VAR 0 4
50251: NOT
50252: IFFALSE 50263
// range := - 12 ;
50254: LD_ADDR_VAR 0 4
50258: PUSH
50259: LD_INT 12
50261: NEG
50262: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50263: LD_VAR 0 1
50267: PPUSH
50268: LD_VAR 0 2
50272: PPUSH
50273: LD_VAR 0 3
50277: PPUSH
50278: LD_VAR 0 4
50282: PPUSH
50283: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50287: LD_VAR 0 1
50291: PPUSH
50292: LD_VAR 0 2
50296: PPUSH
50297: LD_VAR 0 3
50301: PPUSH
50302: CALL_OW 331
// end ;
50306: LD_VAR 0 5
50310: RET
// export function Video ( mode ) ; begin
50311: LD_INT 0
50313: PPUSH
// ingame_video = mode ;
50314: LD_ADDR_OWVAR 52
50318: PUSH
50319: LD_VAR 0 1
50323: ST_TO_ADDR
// interface_hidden = mode ;
50324: LD_ADDR_OWVAR 54
50328: PUSH
50329: LD_VAR 0 1
50333: ST_TO_ADDR
// end ;
50334: LD_VAR 0 2
50338: RET
// export function Join ( array , element ) ; begin
50339: LD_INT 0
50341: PPUSH
// result := Replace ( array , array + 1 , element ) ;
50342: LD_ADDR_VAR 0 3
50346: PUSH
50347: LD_VAR 0 1
50351: PPUSH
50352: LD_VAR 0 1
50356: PUSH
50357: LD_INT 1
50359: PLUS
50360: PPUSH
50361: LD_VAR 0 2
50365: PPUSH
50366: CALL_OW 1
50370: ST_TO_ADDR
// end ;
50371: LD_VAR 0 3
50375: RET
// export function JoinUnion ( array , element ) ; begin
50376: LD_INT 0
50378: PPUSH
// result := array union element ;
50379: LD_ADDR_VAR 0 3
50383: PUSH
50384: LD_VAR 0 1
50388: PUSH
50389: LD_VAR 0 2
50393: UNION
50394: ST_TO_ADDR
// end ;
50395: LD_VAR 0 3
50399: RET
// export function GetBehemoths ( side ) ; begin
50400: LD_INT 0
50402: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
50403: LD_ADDR_VAR 0 2
50407: PUSH
50408: LD_INT 22
50410: PUSH
50411: LD_VAR 0 1
50415: PUSH
50416: EMPTY
50417: LIST
50418: LIST
50419: PUSH
50420: LD_INT 31
50422: PUSH
50423: LD_INT 25
50425: PUSH
50426: EMPTY
50427: LIST
50428: LIST
50429: PUSH
50430: EMPTY
50431: LIST
50432: LIST
50433: PPUSH
50434: CALL_OW 69
50438: ST_TO_ADDR
// end ;
50439: LD_VAR 0 2
50443: RET
// export function Shuffle ( array ) ; var i , index ; begin
50444: LD_INT 0
50446: PPUSH
50447: PPUSH
50448: PPUSH
// result := [ ] ;
50449: LD_ADDR_VAR 0 2
50453: PUSH
50454: EMPTY
50455: ST_TO_ADDR
// if not array then
50456: LD_VAR 0 1
50460: NOT
50461: IFFALSE 50465
// exit ;
50463: GO 50564
// Randomize ;
50465: CALL_OW 10
// for i = array downto 1 do
50469: LD_ADDR_VAR 0 3
50473: PUSH
50474: DOUBLE
50475: LD_VAR 0 1
50479: INC
50480: ST_TO_ADDR
50481: LD_INT 1
50483: PUSH
50484: FOR_DOWNTO
50485: IFFALSE 50562
// begin index := rand ( 1 , array ) ;
50487: LD_ADDR_VAR 0 4
50491: PUSH
50492: LD_INT 1
50494: PPUSH
50495: LD_VAR 0 1
50499: PPUSH
50500: CALL_OW 12
50504: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
50505: LD_ADDR_VAR 0 2
50509: PUSH
50510: LD_VAR 0 2
50514: PPUSH
50515: LD_VAR 0 2
50519: PUSH
50520: LD_INT 1
50522: PLUS
50523: PPUSH
50524: LD_VAR 0 1
50528: PUSH
50529: LD_VAR 0 4
50533: ARRAY
50534: PPUSH
50535: CALL_OW 2
50539: ST_TO_ADDR
// array := Delete ( array , index ) ;
50540: LD_ADDR_VAR 0 1
50544: PUSH
50545: LD_VAR 0 1
50549: PPUSH
50550: LD_VAR 0 4
50554: PPUSH
50555: CALL_OW 3
50559: ST_TO_ADDR
// end ;
50560: GO 50484
50562: POP
50563: POP
// end ;
50564: LD_VAR 0 2
50568: RET
// export function GetBaseMaterials ( base ) ; begin
50569: LD_INT 0
50571: PPUSH
// result := [ 0 , 0 , 0 ] ;
50572: LD_ADDR_VAR 0 2
50576: PUSH
50577: LD_INT 0
50579: PUSH
50580: LD_INT 0
50582: PUSH
50583: LD_INT 0
50585: PUSH
50586: EMPTY
50587: LIST
50588: LIST
50589: LIST
50590: ST_TO_ADDR
// if not base then
50591: LD_VAR 0 1
50595: NOT
50596: IFFALSE 50600
// exit ;
50598: GO 50649
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
50600: LD_ADDR_VAR 0 2
50604: PUSH
50605: LD_VAR 0 1
50609: PPUSH
50610: LD_INT 1
50612: PPUSH
50613: CALL_OW 275
50617: PUSH
50618: LD_VAR 0 1
50622: PPUSH
50623: LD_INT 2
50625: PPUSH
50626: CALL_OW 275
50630: PUSH
50631: LD_VAR 0 1
50635: PPUSH
50636: LD_INT 3
50638: PPUSH
50639: CALL_OW 275
50643: PUSH
50644: EMPTY
50645: LIST
50646: LIST
50647: LIST
50648: ST_TO_ADDR
// end ;
50649: LD_VAR 0 2
50653: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
50654: LD_INT 0
50656: PPUSH
50657: PPUSH
// result := array ;
50658: LD_ADDR_VAR 0 3
50662: PUSH
50663: LD_VAR 0 1
50667: ST_TO_ADDR
// if size > 0 then
50668: LD_VAR 0 2
50672: PUSH
50673: LD_INT 0
50675: GREATER
50676: IFFALSE 50722
// for i := array downto size do
50678: LD_ADDR_VAR 0 4
50682: PUSH
50683: DOUBLE
50684: LD_VAR 0 1
50688: INC
50689: ST_TO_ADDR
50690: LD_VAR 0 2
50694: PUSH
50695: FOR_DOWNTO
50696: IFFALSE 50720
// result := Delete ( result , result ) ;
50698: LD_ADDR_VAR 0 3
50702: PUSH
50703: LD_VAR 0 3
50707: PPUSH
50708: LD_VAR 0 3
50712: PPUSH
50713: CALL_OW 3
50717: ST_TO_ADDR
50718: GO 50695
50720: POP
50721: POP
// end ;
50722: LD_VAR 0 3
50726: RET
// export function ComExit ( unit ) ; var tmp ; begin
50727: LD_INT 0
50729: PPUSH
50730: PPUSH
// if not IsInUnit ( unit ) then
50731: LD_VAR 0 1
50735: PPUSH
50736: CALL_OW 310
50740: NOT
50741: IFFALSE 50745
// exit ;
50743: GO 50805
// tmp := IsInUnit ( unit ) ;
50745: LD_ADDR_VAR 0 3
50749: PUSH
50750: LD_VAR 0 1
50754: PPUSH
50755: CALL_OW 310
50759: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
50760: LD_VAR 0 3
50764: PPUSH
50765: CALL_OW 247
50769: PUSH
50770: LD_INT 2
50772: EQUAL
50773: IFFALSE 50786
// ComExitVehicle ( unit ) else
50775: LD_VAR 0 1
50779: PPUSH
50780: CALL_OW 121
50784: GO 50795
// ComExitBuilding ( unit ) ;
50786: LD_VAR 0 1
50790: PPUSH
50791: CALL_OW 122
// result := tmp ;
50795: LD_ADDR_VAR 0 2
50799: PUSH
50800: LD_VAR 0 3
50804: ST_TO_ADDR
// end ;
50805: LD_VAR 0 2
50809: RET
// export function ComExitAll ( units ) ; var i ; begin
50810: LD_INT 0
50812: PPUSH
50813: PPUSH
// if not units then
50814: LD_VAR 0 1
50818: NOT
50819: IFFALSE 50823
// exit ;
50821: GO 50849
// for i in units do
50823: LD_ADDR_VAR 0 3
50827: PUSH
50828: LD_VAR 0 1
50832: PUSH
50833: FOR_IN
50834: IFFALSE 50847
// ComExit ( i ) ;
50836: LD_VAR 0 3
50840: PPUSH
50841: CALL 50727 0 1
50845: GO 50833
50847: POP
50848: POP
// end ;
50849: LD_VAR 0 2
50853: RET
// export function ResetHc ; begin
50854: LD_INT 0
50856: PPUSH
// InitHc ;
50857: CALL_OW 19
// hc_importance := 0 ;
50861: LD_ADDR_OWVAR 32
50865: PUSH
50866: LD_INT 0
50868: ST_TO_ADDR
// end ;
50869: LD_VAR 0 1
50873: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
50874: LD_INT 0
50876: PPUSH
50877: PPUSH
50878: PPUSH
// _x := ( x1 + x2 ) div 2 ;
50879: LD_ADDR_VAR 0 6
50883: PUSH
50884: LD_VAR 0 1
50888: PUSH
50889: LD_VAR 0 3
50893: PLUS
50894: PUSH
50895: LD_INT 2
50897: DIV
50898: ST_TO_ADDR
// if _x < 0 then
50899: LD_VAR 0 6
50903: PUSH
50904: LD_INT 0
50906: LESS
50907: IFFALSE 50924
// _x := _x * - 1 ;
50909: LD_ADDR_VAR 0 6
50913: PUSH
50914: LD_VAR 0 6
50918: PUSH
50919: LD_INT 1
50921: NEG
50922: MUL
50923: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
50924: LD_ADDR_VAR 0 7
50928: PUSH
50929: LD_VAR 0 2
50933: PUSH
50934: LD_VAR 0 4
50938: PLUS
50939: PUSH
50940: LD_INT 2
50942: DIV
50943: ST_TO_ADDR
// if _y < 0 then
50944: LD_VAR 0 7
50948: PUSH
50949: LD_INT 0
50951: LESS
50952: IFFALSE 50969
// _y := _y * - 1 ;
50954: LD_ADDR_VAR 0 7
50958: PUSH
50959: LD_VAR 0 7
50963: PUSH
50964: LD_INT 1
50966: NEG
50967: MUL
50968: ST_TO_ADDR
// result := [ _x , _y ] ;
50969: LD_ADDR_VAR 0 5
50973: PUSH
50974: LD_VAR 0 6
50978: PUSH
50979: LD_VAR 0 7
50983: PUSH
50984: EMPTY
50985: LIST
50986: LIST
50987: ST_TO_ADDR
// end ;
50988: LD_VAR 0 5
50992: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
50993: LD_INT 0
50995: PPUSH
50996: PPUSH
50997: PPUSH
50998: PPUSH
// task := GetTaskList ( unit ) ;
50999: LD_ADDR_VAR 0 7
51003: PUSH
51004: LD_VAR 0 1
51008: PPUSH
51009: CALL_OW 437
51013: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
51014: LD_VAR 0 7
51018: NOT
51019: PUSH
51020: LD_VAR 0 1
51024: PPUSH
51025: LD_VAR 0 2
51029: PPUSH
51030: CALL_OW 308
51034: NOT
51035: AND
51036: IFFALSE 51040
// exit ;
51038: GO 51158
// if IsInArea ( unit , area ) then
51040: LD_VAR 0 1
51044: PPUSH
51045: LD_VAR 0 2
51049: PPUSH
51050: CALL_OW 308
51054: IFFALSE 51072
// begin ComMoveToArea ( unit , goAway ) ;
51056: LD_VAR 0 1
51060: PPUSH
51061: LD_VAR 0 3
51065: PPUSH
51066: CALL_OW 113
// exit ;
51070: GO 51158
// end ; if task [ 1 ] [ 1 ] <> M then
51072: LD_VAR 0 7
51076: PUSH
51077: LD_INT 1
51079: ARRAY
51080: PUSH
51081: LD_INT 1
51083: ARRAY
51084: PUSH
51085: LD_STRING M
51087: NONEQUAL
51088: IFFALSE 51092
// exit ;
51090: GO 51158
// x := task [ 1 ] [ 2 ] ;
51092: LD_ADDR_VAR 0 5
51096: PUSH
51097: LD_VAR 0 7
51101: PUSH
51102: LD_INT 1
51104: ARRAY
51105: PUSH
51106: LD_INT 2
51108: ARRAY
51109: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
51110: LD_ADDR_VAR 0 6
51114: PUSH
51115: LD_VAR 0 7
51119: PUSH
51120: LD_INT 1
51122: ARRAY
51123: PUSH
51124: LD_INT 3
51126: ARRAY
51127: ST_TO_ADDR
// if InArea ( x , y , area ) then
51128: LD_VAR 0 5
51132: PPUSH
51133: LD_VAR 0 6
51137: PPUSH
51138: LD_VAR 0 2
51142: PPUSH
51143: CALL_OW 309
51147: IFFALSE 51158
// ComStop ( unit ) ;
51149: LD_VAR 0 1
51153: PPUSH
51154: CALL_OW 141
// end ;
51158: LD_VAR 0 4
51162: RET
// export function Abs ( value ) ; begin
51163: LD_INT 0
51165: PPUSH
// result := value ;
51166: LD_ADDR_VAR 0 2
51170: PUSH
51171: LD_VAR 0 1
51175: ST_TO_ADDR
// if value < 0 then
51176: LD_VAR 0 1
51180: PUSH
51181: LD_INT 0
51183: LESS
51184: IFFALSE 51201
// result := value * - 1 ;
51186: LD_ADDR_VAR 0 2
51190: PUSH
51191: LD_VAR 0 1
51195: PUSH
51196: LD_INT 1
51198: NEG
51199: MUL
51200: ST_TO_ADDR
// end ;
51201: LD_VAR 0 2
51205: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
51206: LD_INT 0
51208: PPUSH
51209: PPUSH
51210: PPUSH
51211: PPUSH
51212: PPUSH
51213: PPUSH
51214: PPUSH
51215: PPUSH
// if not unit or not building then
51216: LD_VAR 0 1
51220: NOT
51221: PUSH
51222: LD_VAR 0 2
51226: NOT
51227: OR
51228: IFFALSE 51232
// exit ;
51230: GO 51458
// x := GetX ( building ) ;
51232: LD_ADDR_VAR 0 4
51236: PUSH
51237: LD_VAR 0 2
51241: PPUSH
51242: CALL_OW 250
51246: ST_TO_ADDR
// y := GetY ( building ) ;
51247: LD_ADDR_VAR 0 6
51251: PUSH
51252: LD_VAR 0 2
51256: PPUSH
51257: CALL_OW 251
51261: ST_TO_ADDR
// d := GetDir ( building ) ;
51262: LD_ADDR_VAR 0 8
51266: PUSH
51267: LD_VAR 0 2
51271: PPUSH
51272: CALL_OW 254
51276: ST_TO_ADDR
// r := 4 ;
51277: LD_ADDR_VAR 0 9
51281: PUSH
51282: LD_INT 4
51284: ST_TO_ADDR
// for i := 1 to 5 do
51285: LD_ADDR_VAR 0 10
51289: PUSH
51290: DOUBLE
51291: LD_INT 1
51293: DEC
51294: ST_TO_ADDR
51295: LD_INT 5
51297: PUSH
51298: FOR_TO
51299: IFFALSE 51456
// begin _x := ShiftX ( x , d , r + i ) ;
51301: LD_ADDR_VAR 0 5
51305: PUSH
51306: LD_VAR 0 4
51310: PPUSH
51311: LD_VAR 0 8
51315: PPUSH
51316: LD_VAR 0 9
51320: PUSH
51321: LD_VAR 0 10
51325: PLUS
51326: PPUSH
51327: CALL_OW 272
51331: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
51332: LD_ADDR_VAR 0 7
51336: PUSH
51337: LD_VAR 0 6
51341: PPUSH
51342: LD_VAR 0 8
51346: PPUSH
51347: LD_VAR 0 9
51351: PUSH
51352: LD_VAR 0 10
51356: PLUS
51357: PPUSH
51358: CALL_OW 273
51362: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
51363: LD_VAR 0 5
51367: PPUSH
51368: LD_VAR 0 7
51372: PPUSH
51373: CALL_OW 488
51377: PUSH
51378: LD_VAR 0 5
51382: PPUSH
51383: LD_VAR 0 7
51387: PPUSH
51388: CALL_OW 428
51392: PPUSH
51393: CALL_OW 247
51397: PUSH
51398: LD_INT 3
51400: PUSH
51401: LD_INT 2
51403: PUSH
51404: EMPTY
51405: LIST
51406: LIST
51407: IN
51408: NOT
51409: AND
51410: IFFALSE 51454
// begin ComMoveXY ( unit , _x , _y ) ;
51412: LD_VAR 0 1
51416: PPUSH
51417: LD_VAR 0 5
51421: PPUSH
51422: LD_VAR 0 7
51426: PPUSH
51427: CALL_OW 111
// result := [ _x , _y ] ;
51431: LD_ADDR_VAR 0 3
51435: PUSH
51436: LD_VAR 0 5
51440: PUSH
51441: LD_VAR 0 7
51445: PUSH
51446: EMPTY
51447: LIST
51448: LIST
51449: ST_TO_ADDR
// exit ;
51450: POP
51451: POP
51452: GO 51458
// end ; end ;
51454: GO 51298
51456: POP
51457: POP
// end ;
51458: LD_VAR 0 3
51462: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
51463: LD_INT 0
51465: PPUSH
51466: PPUSH
51467: PPUSH
// result := 0 ;
51468: LD_ADDR_VAR 0 3
51472: PUSH
51473: LD_INT 0
51475: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
51476: LD_VAR 0 1
51480: PUSH
51481: LD_INT 0
51483: LESS
51484: PUSH
51485: LD_VAR 0 1
51489: PUSH
51490: LD_INT 8
51492: GREATER
51493: OR
51494: PUSH
51495: LD_VAR 0 2
51499: PUSH
51500: LD_INT 0
51502: LESS
51503: OR
51504: PUSH
51505: LD_VAR 0 2
51509: PUSH
51510: LD_INT 8
51512: GREATER
51513: OR
51514: IFFALSE 51518
// exit ;
51516: GO 51593
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
51518: LD_ADDR_VAR 0 4
51522: PUSH
51523: LD_INT 22
51525: PUSH
51526: LD_VAR 0 2
51530: PUSH
51531: EMPTY
51532: LIST
51533: LIST
51534: PPUSH
51535: CALL_OW 69
51539: PUSH
51540: FOR_IN
51541: IFFALSE 51591
// begin un := UnitShoot ( i ) ;
51543: LD_ADDR_VAR 0 5
51547: PUSH
51548: LD_VAR 0 4
51552: PPUSH
51553: CALL_OW 504
51557: ST_TO_ADDR
// if GetSide ( un ) = side1 then
51558: LD_VAR 0 5
51562: PPUSH
51563: CALL_OW 255
51567: PUSH
51568: LD_VAR 0 1
51572: EQUAL
51573: IFFALSE 51589
// begin result := un ;
51575: LD_ADDR_VAR 0 3
51579: PUSH
51580: LD_VAR 0 5
51584: ST_TO_ADDR
// exit ;
51585: POP
51586: POP
51587: GO 51593
// end ; end ;
51589: GO 51540
51591: POP
51592: POP
// end ;
51593: LD_VAR 0 3
51597: RET
// export function GetCargoBay ( units ) ; begin
51598: LD_INT 0
51600: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
51601: LD_ADDR_VAR 0 2
51605: PUSH
51606: LD_VAR 0 1
51610: PPUSH
51611: LD_INT 2
51613: PUSH
51614: LD_INT 34
51616: PUSH
51617: LD_INT 12
51619: PUSH
51620: EMPTY
51621: LIST
51622: LIST
51623: PUSH
51624: LD_INT 34
51626: PUSH
51627: LD_INT 51
51629: PUSH
51630: EMPTY
51631: LIST
51632: LIST
51633: PUSH
51634: LD_INT 34
51636: PUSH
51637: LD_INT 32
51639: PUSH
51640: EMPTY
51641: LIST
51642: LIST
51643: PUSH
51644: LD_INT 34
51646: PUSH
51647: LD_EXP 49
51651: PUSH
51652: EMPTY
51653: LIST
51654: LIST
51655: PUSH
51656: EMPTY
51657: LIST
51658: LIST
51659: LIST
51660: LIST
51661: LIST
51662: PPUSH
51663: CALL_OW 72
51667: ST_TO_ADDR
// end ;
51668: LD_VAR 0 2
51672: RET
// export function Negate ( value ) ; begin
51673: LD_INT 0
51675: PPUSH
// result := not value ;
51676: LD_ADDR_VAR 0 2
51680: PUSH
51681: LD_VAR 0 1
51685: NOT
51686: ST_TO_ADDR
// end ;
51687: LD_VAR 0 2
51691: RET
// export function Inc ( value ) ; begin
51692: LD_INT 0
51694: PPUSH
// result := value + 1 ;
51695: LD_ADDR_VAR 0 2
51699: PUSH
51700: LD_VAR 0 1
51704: PUSH
51705: LD_INT 1
51707: PLUS
51708: ST_TO_ADDR
// end ;
51709: LD_VAR 0 2
51713: RET
// export function Dec ( value ) ; begin
51714: LD_INT 0
51716: PPUSH
// result := value - 1 ;
51717: LD_ADDR_VAR 0 2
51721: PUSH
51722: LD_VAR 0 1
51726: PUSH
51727: LD_INT 1
51729: MINUS
51730: ST_TO_ADDR
// end ;
51731: LD_VAR 0 2
51735: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
51736: LD_INT 0
51738: PPUSH
51739: PPUSH
51740: PPUSH
51741: PPUSH
51742: PPUSH
51743: PPUSH
51744: PPUSH
51745: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
51746: LD_VAR 0 1
51750: PPUSH
51751: LD_VAR 0 2
51755: PPUSH
51756: CALL_OW 488
51760: NOT
51761: PUSH
51762: LD_VAR 0 3
51766: PPUSH
51767: LD_VAR 0 4
51771: PPUSH
51772: CALL_OW 488
51776: NOT
51777: OR
51778: IFFALSE 51791
// begin result := - 1 ;
51780: LD_ADDR_VAR 0 5
51784: PUSH
51785: LD_INT 1
51787: NEG
51788: ST_TO_ADDR
// exit ;
51789: GO 52026
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
51791: LD_ADDR_VAR 0 12
51795: PUSH
51796: LD_VAR 0 1
51800: PPUSH
51801: LD_VAR 0 2
51805: PPUSH
51806: LD_VAR 0 3
51810: PPUSH
51811: LD_VAR 0 4
51815: PPUSH
51816: CALL 50874 0 4
51820: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
51821: LD_ADDR_VAR 0 11
51825: PUSH
51826: LD_VAR 0 1
51830: PPUSH
51831: LD_VAR 0 2
51835: PPUSH
51836: LD_VAR 0 12
51840: PUSH
51841: LD_INT 1
51843: ARRAY
51844: PPUSH
51845: LD_VAR 0 12
51849: PUSH
51850: LD_INT 2
51852: ARRAY
51853: PPUSH
51854: CALL_OW 298
51858: ST_TO_ADDR
// distance := 9999 ;
51859: LD_ADDR_VAR 0 10
51863: PUSH
51864: LD_INT 9999
51866: ST_TO_ADDR
// for i := 0 to 5 do
51867: LD_ADDR_VAR 0 6
51871: PUSH
51872: DOUBLE
51873: LD_INT 0
51875: DEC
51876: ST_TO_ADDR
51877: LD_INT 5
51879: PUSH
51880: FOR_TO
51881: IFFALSE 52024
// begin _x := ShiftX ( x1 , i , centerDist ) ;
51883: LD_ADDR_VAR 0 7
51887: PUSH
51888: LD_VAR 0 1
51892: PPUSH
51893: LD_VAR 0 6
51897: PPUSH
51898: LD_VAR 0 11
51902: PPUSH
51903: CALL_OW 272
51907: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
51908: LD_ADDR_VAR 0 8
51912: PUSH
51913: LD_VAR 0 2
51917: PPUSH
51918: LD_VAR 0 6
51922: PPUSH
51923: LD_VAR 0 11
51927: PPUSH
51928: CALL_OW 273
51932: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51933: LD_VAR 0 7
51937: PPUSH
51938: LD_VAR 0 8
51942: PPUSH
51943: CALL_OW 488
51947: NOT
51948: IFFALSE 51952
// continue ;
51950: GO 51880
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
51952: LD_ADDR_VAR 0 9
51956: PUSH
51957: LD_VAR 0 12
51961: PUSH
51962: LD_INT 1
51964: ARRAY
51965: PPUSH
51966: LD_VAR 0 12
51970: PUSH
51971: LD_INT 2
51973: ARRAY
51974: PPUSH
51975: LD_VAR 0 7
51979: PPUSH
51980: LD_VAR 0 8
51984: PPUSH
51985: CALL_OW 298
51989: ST_TO_ADDR
// if tmp < distance then
51990: LD_VAR 0 9
51994: PUSH
51995: LD_VAR 0 10
51999: LESS
52000: IFFALSE 52022
// begin result := i ;
52002: LD_ADDR_VAR 0 5
52006: PUSH
52007: LD_VAR 0 6
52011: ST_TO_ADDR
// distance := tmp ;
52012: LD_ADDR_VAR 0 10
52016: PUSH
52017: LD_VAR 0 9
52021: ST_TO_ADDR
// end ; end ;
52022: GO 51880
52024: POP
52025: POP
// end ;
52026: LD_VAR 0 5
52030: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
52031: LD_INT 0
52033: PPUSH
52034: PPUSH
// if not driver or not IsInUnit ( driver ) then
52035: LD_VAR 0 1
52039: NOT
52040: PUSH
52041: LD_VAR 0 1
52045: PPUSH
52046: CALL_OW 310
52050: NOT
52051: OR
52052: IFFALSE 52056
// exit ;
52054: GO 52146
// vehicle := IsInUnit ( driver ) ;
52056: LD_ADDR_VAR 0 3
52060: PUSH
52061: LD_VAR 0 1
52065: PPUSH
52066: CALL_OW 310
52070: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
52071: LD_VAR 0 1
52075: PPUSH
52076: LD_STRING \
52078: PUSH
52079: LD_INT 0
52081: PUSH
52082: LD_INT 0
52084: PUSH
52085: LD_INT 0
52087: PUSH
52088: LD_INT 0
52090: PUSH
52091: LD_INT 0
52093: PUSH
52094: LD_INT 0
52096: PUSH
52097: EMPTY
52098: LIST
52099: LIST
52100: LIST
52101: LIST
52102: LIST
52103: LIST
52104: LIST
52105: PUSH
52106: LD_STRING E
52108: PUSH
52109: LD_INT 0
52111: PUSH
52112: LD_INT 0
52114: PUSH
52115: LD_VAR 0 3
52119: PUSH
52120: LD_INT 0
52122: PUSH
52123: LD_INT 0
52125: PUSH
52126: LD_INT 0
52128: PUSH
52129: EMPTY
52130: LIST
52131: LIST
52132: LIST
52133: LIST
52134: LIST
52135: LIST
52136: LIST
52137: PUSH
52138: EMPTY
52139: LIST
52140: LIST
52141: PPUSH
52142: CALL_OW 446
// end ;
52146: LD_VAR 0 2
52150: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
52151: LD_INT 0
52153: PPUSH
52154: PPUSH
// if not driver or not IsInUnit ( driver ) then
52155: LD_VAR 0 1
52159: NOT
52160: PUSH
52161: LD_VAR 0 1
52165: PPUSH
52166: CALL_OW 310
52170: NOT
52171: OR
52172: IFFALSE 52176
// exit ;
52174: GO 52266
// vehicle := IsInUnit ( driver ) ;
52176: LD_ADDR_VAR 0 3
52180: PUSH
52181: LD_VAR 0 1
52185: PPUSH
52186: CALL_OW 310
52190: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
52191: LD_VAR 0 1
52195: PPUSH
52196: LD_STRING \
52198: PUSH
52199: LD_INT 0
52201: PUSH
52202: LD_INT 0
52204: PUSH
52205: LD_INT 0
52207: PUSH
52208: LD_INT 0
52210: PUSH
52211: LD_INT 0
52213: PUSH
52214: LD_INT 0
52216: PUSH
52217: EMPTY
52218: LIST
52219: LIST
52220: LIST
52221: LIST
52222: LIST
52223: LIST
52224: LIST
52225: PUSH
52226: LD_STRING E
52228: PUSH
52229: LD_INT 0
52231: PUSH
52232: LD_INT 0
52234: PUSH
52235: LD_VAR 0 3
52239: PUSH
52240: LD_INT 0
52242: PUSH
52243: LD_INT 0
52245: PUSH
52246: LD_INT 0
52248: PUSH
52249: EMPTY
52250: LIST
52251: LIST
52252: LIST
52253: LIST
52254: LIST
52255: LIST
52256: LIST
52257: PUSH
52258: EMPTY
52259: LIST
52260: LIST
52261: PPUSH
52262: CALL_OW 447
// end ;
52266: LD_VAR 0 2
52270: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
52271: LD_INT 0
52273: PPUSH
52274: PPUSH
52275: PPUSH
// tmp := [ ] ;
52276: LD_ADDR_VAR 0 5
52280: PUSH
52281: EMPTY
52282: ST_TO_ADDR
// for i in units do
52283: LD_ADDR_VAR 0 4
52287: PUSH
52288: LD_VAR 0 1
52292: PUSH
52293: FOR_IN
52294: IFFALSE 52332
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
52296: LD_ADDR_VAR 0 5
52300: PUSH
52301: LD_VAR 0 5
52305: PPUSH
52306: LD_VAR 0 5
52310: PUSH
52311: LD_INT 1
52313: PLUS
52314: PPUSH
52315: LD_VAR 0 4
52319: PPUSH
52320: CALL_OW 256
52324: PPUSH
52325: CALL_OW 2
52329: ST_TO_ADDR
52330: GO 52293
52332: POP
52333: POP
// if not tmp then
52334: LD_VAR 0 5
52338: NOT
52339: IFFALSE 52343
// exit ;
52341: GO 52391
// if asc then
52343: LD_VAR 0 2
52347: IFFALSE 52371
// result := SortListByListAsc ( units , tmp ) else
52349: LD_ADDR_VAR 0 3
52353: PUSH
52354: LD_VAR 0 1
52358: PPUSH
52359: LD_VAR 0 5
52363: PPUSH
52364: CALL_OW 76
52368: ST_TO_ADDR
52369: GO 52391
// result := SortListByListDesc ( units , tmp ) ;
52371: LD_ADDR_VAR 0 3
52375: PUSH
52376: LD_VAR 0 1
52380: PPUSH
52381: LD_VAR 0 5
52385: PPUSH
52386: CALL_OW 77
52390: ST_TO_ADDR
// end ;
52391: LD_VAR 0 3
52395: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
52396: LD_INT 0
52398: PPUSH
52399: PPUSH
// task := GetTaskList ( mech ) ;
52400: LD_ADDR_VAR 0 4
52404: PUSH
52405: LD_VAR 0 1
52409: PPUSH
52410: CALL_OW 437
52414: ST_TO_ADDR
// if not task then
52415: LD_VAR 0 4
52419: NOT
52420: IFFALSE 52424
// exit ;
52422: GO 52466
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
52424: LD_ADDR_VAR 0 3
52428: PUSH
52429: LD_VAR 0 4
52433: PUSH
52434: LD_INT 1
52436: ARRAY
52437: PUSH
52438: LD_INT 1
52440: ARRAY
52441: PUSH
52442: LD_STRING r
52444: EQUAL
52445: PUSH
52446: LD_VAR 0 4
52450: PUSH
52451: LD_INT 1
52453: ARRAY
52454: PUSH
52455: LD_INT 4
52457: ARRAY
52458: PUSH
52459: LD_VAR 0 2
52463: EQUAL
52464: AND
52465: ST_TO_ADDR
// end ;
52466: LD_VAR 0 3
52470: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
52471: LD_INT 0
52473: PPUSH
// SetDir ( unit , d ) ;
52474: LD_VAR 0 1
52478: PPUSH
52479: LD_VAR 0 4
52483: PPUSH
52484: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
52488: LD_VAR 0 1
52492: PPUSH
52493: LD_VAR 0 2
52497: PPUSH
52498: LD_VAR 0 3
52502: PPUSH
52503: LD_VAR 0 5
52507: PPUSH
52508: CALL_OW 48
// end ;
52512: LD_VAR 0 6
52516: RET
// export function ToNaturalNumber ( number ) ; begin
52517: LD_INT 0
52519: PPUSH
// result := number div 1 ;
52520: LD_ADDR_VAR 0 2
52524: PUSH
52525: LD_VAR 0 1
52529: PUSH
52530: LD_INT 1
52532: DIV
52533: ST_TO_ADDR
// if number < 0 then
52534: LD_VAR 0 1
52538: PUSH
52539: LD_INT 0
52541: LESS
52542: IFFALSE 52552
// result := 0 ;
52544: LD_ADDR_VAR 0 2
52548: PUSH
52549: LD_INT 0
52551: ST_TO_ADDR
// end ;
52552: LD_VAR 0 2
52556: RET
// export function SortByClass ( units , class ) ; var un ; begin
52557: LD_INT 0
52559: PPUSH
52560: PPUSH
// if not units or not class then
52561: LD_VAR 0 1
52565: NOT
52566: PUSH
52567: LD_VAR 0 2
52571: NOT
52572: OR
52573: IFFALSE 52577
// exit ;
52575: GO 52672
// result := [ ] ;
52577: LD_ADDR_VAR 0 3
52581: PUSH
52582: EMPTY
52583: ST_TO_ADDR
// for un in units do
52584: LD_ADDR_VAR 0 4
52588: PUSH
52589: LD_VAR 0 1
52593: PUSH
52594: FOR_IN
52595: IFFALSE 52670
// if GetClass ( un ) = class then
52597: LD_VAR 0 4
52601: PPUSH
52602: CALL_OW 257
52606: PUSH
52607: LD_VAR 0 2
52611: EQUAL
52612: IFFALSE 52639
// result := Insert ( result , 1 , un ) else
52614: LD_ADDR_VAR 0 3
52618: PUSH
52619: LD_VAR 0 3
52623: PPUSH
52624: LD_INT 1
52626: PPUSH
52627: LD_VAR 0 4
52631: PPUSH
52632: CALL_OW 2
52636: ST_TO_ADDR
52637: GO 52668
// result := Replace ( result , result + 1 , un ) ;
52639: LD_ADDR_VAR 0 3
52643: PUSH
52644: LD_VAR 0 3
52648: PPUSH
52649: LD_VAR 0 3
52653: PUSH
52654: LD_INT 1
52656: PLUS
52657: PPUSH
52658: LD_VAR 0 4
52662: PPUSH
52663: CALL_OW 1
52667: ST_TO_ADDR
52668: GO 52594
52670: POP
52671: POP
// end ;
52672: LD_VAR 0 3
52676: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
52677: LD_INT 0
52679: PPUSH
52680: PPUSH
52681: PPUSH
52682: PPUSH
52683: PPUSH
52684: PPUSH
52685: PPUSH
// result := [ ] ;
52686: LD_ADDR_VAR 0 4
52690: PUSH
52691: EMPTY
52692: ST_TO_ADDR
// if x - r < 0 then
52693: LD_VAR 0 1
52697: PUSH
52698: LD_VAR 0 3
52702: MINUS
52703: PUSH
52704: LD_INT 0
52706: LESS
52707: IFFALSE 52719
// min_x := 0 else
52709: LD_ADDR_VAR 0 8
52713: PUSH
52714: LD_INT 0
52716: ST_TO_ADDR
52717: GO 52735
// min_x := x - r ;
52719: LD_ADDR_VAR 0 8
52723: PUSH
52724: LD_VAR 0 1
52728: PUSH
52729: LD_VAR 0 3
52733: MINUS
52734: ST_TO_ADDR
// if y - r < 0 then
52735: LD_VAR 0 2
52739: PUSH
52740: LD_VAR 0 3
52744: MINUS
52745: PUSH
52746: LD_INT 0
52748: LESS
52749: IFFALSE 52761
// min_y := 0 else
52751: LD_ADDR_VAR 0 7
52755: PUSH
52756: LD_INT 0
52758: ST_TO_ADDR
52759: GO 52777
// min_y := y - r ;
52761: LD_ADDR_VAR 0 7
52765: PUSH
52766: LD_VAR 0 2
52770: PUSH
52771: LD_VAR 0 3
52775: MINUS
52776: ST_TO_ADDR
// max_x := x + r ;
52777: LD_ADDR_VAR 0 9
52781: PUSH
52782: LD_VAR 0 1
52786: PUSH
52787: LD_VAR 0 3
52791: PLUS
52792: ST_TO_ADDR
// max_y := y + r ;
52793: LD_ADDR_VAR 0 10
52797: PUSH
52798: LD_VAR 0 2
52802: PUSH
52803: LD_VAR 0 3
52807: PLUS
52808: ST_TO_ADDR
// for _x = min_x to max_x do
52809: LD_ADDR_VAR 0 5
52813: PUSH
52814: DOUBLE
52815: LD_VAR 0 8
52819: DEC
52820: ST_TO_ADDR
52821: LD_VAR 0 9
52825: PUSH
52826: FOR_TO
52827: IFFALSE 52928
// for _y = min_y to max_y do
52829: LD_ADDR_VAR 0 6
52833: PUSH
52834: DOUBLE
52835: LD_VAR 0 7
52839: DEC
52840: ST_TO_ADDR
52841: LD_VAR 0 10
52845: PUSH
52846: FOR_TO
52847: IFFALSE 52924
// begin if not ValidHex ( _x , _y ) then
52849: LD_VAR 0 5
52853: PPUSH
52854: LD_VAR 0 6
52858: PPUSH
52859: CALL_OW 488
52863: NOT
52864: IFFALSE 52868
// continue ;
52866: GO 52846
// if GetResourceTypeXY ( _x , _y ) then
52868: LD_VAR 0 5
52872: PPUSH
52873: LD_VAR 0 6
52877: PPUSH
52878: CALL_OW 283
52882: IFFALSE 52922
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
52884: LD_ADDR_VAR 0 4
52888: PUSH
52889: LD_VAR 0 4
52893: PPUSH
52894: LD_VAR 0 4
52898: PUSH
52899: LD_INT 1
52901: PLUS
52902: PPUSH
52903: LD_VAR 0 5
52907: PUSH
52908: LD_VAR 0 6
52912: PUSH
52913: EMPTY
52914: LIST
52915: LIST
52916: PPUSH
52917: CALL_OW 1
52921: ST_TO_ADDR
// end ;
52922: GO 52846
52924: POP
52925: POP
52926: GO 52826
52928: POP
52929: POP
// end ;
52930: LD_VAR 0 4
52934: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
52935: LD_INT 0
52937: PPUSH
52938: PPUSH
52939: PPUSH
52940: PPUSH
52941: PPUSH
52942: PPUSH
52943: PPUSH
52944: PPUSH
// if not units then
52945: LD_VAR 0 1
52949: NOT
52950: IFFALSE 52954
// exit ;
52952: GO 53379
// result := UnitFilter ( units , [ f_ok ] ) ;
52954: LD_ADDR_VAR 0 3
52958: PUSH
52959: LD_VAR 0 1
52963: PPUSH
52964: LD_INT 50
52966: PUSH
52967: EMPTY
52968: LIST
52969: PPUSH
52970: CALL_OW 72
52974: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
52975: LD_ADDR_VAR 0 8
52979: PUSH
52980: LD_VAR 0 1
52984: PUSH
52985: LD_INT 1
52987: ARRAY
52988: PPUSH
52989: CALL_OW 255
52993: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
52994: LD_ADDR_VAR 0 10
52998: PUSH
52999: LD_INT 29
53001: PUSH
53002: LD_EXP 52
53006: PUSH
53007: EMPTY
53008: LIST
53009: LIST
53010: ST_TO_ADDR
// if not result then
53011: LD_VAR 0 3
53015: NOT
53016: IFFALSE 53020
// exit ;
53018: GO 53379
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
53020: LD_ADDR_VAR 0 5
53024: PUSH
53025: LD_INT 81
53027: PUSH
53028: LD_VAR 0 8
53032: PUSH
53033: EMPTY
53034: LIST
53035: LIST
53036: PPUSH
53037: CALL_OW 69
53041: ST_TO_ADDR
// for i in result do
53042: LD_ADDR_VAR 0 4
53046: PUSH
53047: LD_VAR 0 3
53051: PUSH
53052: FOR_IN
53053: IFFALSE 53377
// begin tag := GetTag ( i ) + 1 ;
53055: LD_ADDR_VAR 0 9
53059: PUSH
53060: LD_VAR 0 4
53064: PPUSH
53065: CALL_OW 110
53069: PUSH
53070: LD_INT 1
53072: PLUS
53073: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
53074: LD_ADDR_VAR 0 7
53078: PUSH
53079: LD_VAR 0 4
53083: PPUSH
53084: CALL_OW 250
53088: PPUSH
53089: LD_VAR 0 4
53093: PPUSH
53094: CALL_OW 251
53098: PPUSH
53099: LD_INT 6
53101: PPUSH
53102: CALL 52677 0 3
53106: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
53107: LD_VAR 0 7
53111: PUSH
53112: LD_VAR 0 4
53116: PPUSH
53117: CALL_OW 264
53121: PUSH
53122: LD_VAR 0 10
53126: IN
53127: NOT
53128: AND
53129: IFFALSE 53168
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
53131: LD_VAR 0 4
53135: PPUSH
53136: LD_VAR 0 7
53140: PUSH
53141: LD_INT 1
53143: ARRAY
53144: PUSH
53145: LD_INT 1
53147: ARRAY
53148: PPUSH
53149: LD_VAR 0 7
53153: PUSH
53154: LD_INT 1
53156: ARRAY
53157: PUSH
53158: LD_INT 2
53160: ARRAY
53161: PPUSH
53162: CALL_OW 116
53166: GO 53375
// if path > tag then
53168: LD_VAR 0 2
53172: PUSH
53173: LD_VAR 0 9
53177: GREATER
53178: IFFALSE 53345
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
53180: LD_ADDR_VAR 0 6
53184: PUSH
53185: LD_VAR 0 5
53189: PPUSH
53190: LD_INT 91
53192: PUSH
53193: LD_VAR 0 4
53197: PUSH
53198: LD_INT 12
53200: PUSH
53201: EMPTY
53202: LIST
53203: LIST
53204: LIST
53205: PPUSH
53206: CALL_OW 72
53210: ST_TO_ADDR
// if nearEnemy then
53211: LD_VAR 0 6
53215: IFFALSE 53243
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
53217: LD_VAR 0 4
53221: PPUSH
53222: LD_VAR 0 6
53226: PPUSH
53227: LD_VAR 0 4
53231: PPUSH
53232: CALL_OW 74
53236: PPUSH
53237: CALL_OW 115
53241: GO 53343
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
53243: LD_VAR 0 4
53247: PPUSH
53248: LD_VAR 0 2
53252: PUSH
53253: LD_VAR 0 9
53257: ARRAY
53258: PUSH
53259: LD_INT 1
53261: ARRAY
53262: PPUSH
53263: LD_VAR 0 2
53267: PUSH
53268: LD_VAR 0 9
53272: ARRAY
53273: PUSH
53274: LD_INT 2
53276: ARRAY
53277: PPUSH
53278: CALL_OW 297
53282: PUSH
53283: LD_INT 6
53285: GREATER
53286: IFFALSE 53329
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
53288: LD_VAR 0 4
53292: PPUSH
53293: LD_VAR 0 2
53297: PUSH
53298: LD_VAR 0 9
53302: ARRAY
53303: PUSH
53304: LD_INT 1
53306: ARRAY
53307: PPUSH
53308: LD_VAR 0 2
53312: PUSH
53313: LD_VAR 0 9
53317: ARRAY
53318: PUSH
53319: LD_INT 2
53321: ARRAY
53322: PPUSH
53323: CALL_OW 114
53327: GO 53343
// SetTag ( i , tag ) ;
53329: LD_VAR 0 4
53333: PPUSH
53334: LD_VAR 0 9
53338: PPUSH
53339: CALL_OW 109
// end else
53343: GO 53375
// if enemy then
53345: LD_VAR 0 5
53349: IFFALSE 53375
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
53351: LD_VAR 0 4
53355: PPUSH
53356: LD_VAR 0 5
53360: PPUSH
53361: LD_VAR 0 4
53365: PPUSH
53366: CALL_OW 74
53370: PPUSH
53371: CALL_OW 115
// end ;
53375: GO 53052
53377: POP
53378: POP
// end ;
53379: LD_VAR 0 3
53383: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
53384: LD_INT 0
53386: PPUSH
53387: PPUSH
53388: PPUSH
// if not unit or IsInUnit ( unit ) then
53389: LD_VAR 0 1
53393: NOT
53394: PUSH
53395: LD_VAR 0 1
53399: PPUSH
53400: CALL_OW 310
53404: OR
53405: IFFALSE 53409
// exit ;
53407: GO 53500
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
53409: LD_ADDR_VAR 0 4
53413: PUSH
53414: LD_VAR 0 1
53418: PPUSH
53419: CALL_OW 250
53423: PPUSH
53424: LD_VAR 0 2
53428: PPUSH
53429: LD_INT 1
53431: PPUSH
53432: CALL_OW 272
53436: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
53437: LD_ADDR_VAR 0 5
53441: PUSH
53442: LD_VAR 0 1
53446: PPUSH
53447: CALL_OW 251
53451: PPUSH
53452: LD_VAR 0 2
53456: PPUSH
53457: LD_INT 1
53459: PPUSH
53460: CALL_OW 273
53464: ST_TO_ADDR
// if ValidHex ( x , y ) then
53465: LD_VAR 0 4
53469: PPUSH
53470: LD_VAR 0 5
53474: PPUSH
53475: CALL_OW 488
53479: IFFALSE 53500
// ComTurnXY ( unit , x , y ) ;
53481: LD_VAR 0 1
53485: PPUSH
53486: LD_VAR 0 4
53490: PPUSH
53491: LD_VAR 0 5
53495: PPUSH
53496: CALL_OW 118
// end ;
53500: LD_VAR 0 3
53504: RET
// export function SeeUnits ( side , units ) ; var i ; begin
53505: LD_INT 0
53507: PPUSH
53508: PPUSH
// result := false ;
53509: LD_ADDR_VAR 0 3
53513: PUSH
53514: LD_INT 0
53516: ST_TO_ADDR
// if not units then
53517: LD_VAR 0 2
53521: NOT
53522: IFFALSE 53526
// exit ;
53524: GO 53571
// for i in units do
53526: LD_ADDR_VAR 0 4
53530: PUSH
53531: LD_VAR 0 2
53535: PUSH
53536: FOR_IN
53537: IFFALSE 53569
// if See ( side , i ) then
53539: LD_VAR 0 1
53543: PPUSH
53544: LD_VAR 0 4
53548: PPUSH
53549: CALL_OW 292
53553: IFFALSE 53567
// begin result := true ;
53555: LD_ADDR_VAR 0 3
53559: PUSH
53560: LD_INT 1
53562: ST_TO_ADDR
// exit ;
53563: POP
53564: POP
53565: GO 53571
// end ;
53567: GO 53536
53569: POP
53570: POP
// end ;
53571: LD_VAR 0 3
53575: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
53576: LD_INT 0
53578: PPUSH
53579: PPUSH
53580: PPUSH
53581: PPUSH
// if not unit or not points then
53582: LD_VAR 0 1
53586: NOT
53587: PUSH
53588: LD_VAR 0 2
53592: NOT
53593: OR
53594: IFFALSE 53598
// exit ;
53596: GO 53688
// dist := 99999 ;
53598: LD_ADDR_VAR 0 5
53602: PUSH
53603: LD_INT 99999
53605: ST_TO_ADDR
// for i in points do
53606: LD_ADDR_VAR 0 4
53610: PUSH
53611: LD_VAR 0 2
53615: PUSH
53616: FOR_IN
53617: IFFALSE 53686
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
53619: LD_ADDR_VAR 0 6
53623: PUSH
53624: LD_VAR 0 1
53628: PPUSH
53629: LD_VAR 0 4
53633: PUSH
53634: LD_INT 1
53636: ARRAY
53637: PPUSH
53638: LD_VAR 0 4
53642: PUSH
53643: LD_INT 2
53645: ARRAY
53646: PPUSH
53647: CALL_OW 297
53651: ST_TO_ADDR
// if tmpDist < dist then
53652: LD_VAR 0 6
53656: PUSH
53657: LD_VAR 0 5
53661: LESS
53662: IFFALSE 53684
// begin result := i ;
53664: LD_ADDR_VAR 0 3
53668: PUSH
53669: LD_VAR 0 4
53673: ST_TO_ADDR
// dist := tmpDist ;
53674: LD_ADDR_VAR 0 5
53678: PUSH
53679: LD_VAR 0 6
53683: ST_TO_ADDR
// end ; end ;
53684: GO 53616
53686: POP
53687: POP
// end ; end_of_file
53688: LD_VAR 0 3
53692: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
53693: LD_INT 0
53695: PPUSH
// ar_miner := 81 ;
53696: LD_ADDR_EXP 55
53700: PUSH
53701: LD_INT 81
53703: ST_TO_ADDR
// ar_crane := 88 ;
53704: LD_ADDR_EXP 54
53708: PUSH
53709: LD_INT 88
53711: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
53712: LD_ADDR_EXP 49
53716: PUSH
53717: LD_INT 89
53719: ST_TO_ADDR
// us_hack := 99 ;
53720: LD_ADDR_EXP 50
53724: PUSH
53725: LD_INT 99
53727: ST_TO_ADDR
// us_artillery := 97 ;
53728: LD_ADDR_EXP 51
53732: PUSH
53733: LD_INT 97
53735: ST_TO_ADDR
// ar_bio_bomb := 91 ;
53736: LD_ADDR_EXP 52
53740: PUSH
53741: LD_INT 91
53743: ST_TO_ADDR
// ar_mortar := 92 ;
53744: LD_ADDR_EXP 53
53748: PUSH
53749: LD_INT 92
53751: ST_TO_ADDR
// ru_radar := 98 ;
53752: LD_ADDR_EXP 48
53756: PUSH
53757: LD_INT 98
53759: ST_TO_ADDR
// tech_Artillery := 80 ;
53760: LD_ADDR_EXP 56
53764: PUSH
53765: LD_INT 80
53767: ST_TO_ADDR
// tech_RadMat := 81 ;
53768: LD_ADDR_EXP 57
53772: PUSH
53773: LD_INT 81
53775: ST_TO_ADDR
// tech_BasicTools := 82 ;
53776: LD_ADDR_EXP 58
53780: PUSH
53781: LD_INT 82
53783: ST_TO_ADDR
// tech_Cargo := 83 ;
53784: LD_ADDR_EXP 59
53788: PUSH
53789: LD_INT 83
53791: ST_TO_ADDR
// tech_Track := 84 ;
53792: LD_ADDR_EXP 60
53796: PUSH
53797: LD_INT 84
53799: ST_TO_ADDR
// tech_Crane := 85 ;
53800: LD_ADDR_EXP 61
53804: PUSH
53805: LD_INT 85
53807: ST_TO_ADDR
// tech_Bulldozer := 86 ;
53808: LD_ADDR_EXP 62
53812: PUSH
53813: LD_INT 86
53815: ST_TO_ADDR
// tech_Hovercraft := 87 ;
53816: LD_ADDR_EXP 63
53820: PUSH
53821: LD_INT 87
53823: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
53824: LD_ADDR_EXP 64
53828: PUSH
53829: LD_INT 88
53831: ST_TO_ADDR
// class_mastodont := 31 ;
53832: LD_ADDR_EXP 65
53836: PUSH
53837: LD_INT 31
53839: ST_TO_ADDR
// class_horse := 21 ;
53840: LD_ADDR_EXP 66
53844: PUSH
53845: LD_INT 21
53847: ST_TO_ADDR
// end ;
53848: LD_VAR 0 1
53852: RET
// every 1 do
53853: GO 53855
53855: DISABLE
// InitGlobalVariables ; end_of_file
53856: CALL 53693 0 0
53860: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
53861: LD_INT 0
53863: PPUSH
53864: PPUSH
// skirmish := false ;
53865: LD_ADDR_EXP 67
53869: PUSH
53870: LD_INT 0
53872: ST_TO_ADDR
// debug_mc := false ;
53873: LD_ADDR_EXP 68
53877: PUSH
53878: LD_INT 0
53880: ST_TO_ADDR
// mc_bases := [ ] ;
53881: LD_ADDR_EXP 69
53885: PUSH
53886: EMPTY
53887: ST_TO_ADDR
// mc_sides := [ ] ;
53888: LD_ADDR_EXP 95
53892: PUSH
53893: EMPTY
53894: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
53895: LD_ADDR_EXP 70
53899: PUSH
53900: EMPTY
53901: ST_TO_ADDR
// mc_building_repairs := [ ] ;
53902: LD_ADDR_EXP 71
53906: PUSH
53907: EMPTY
53908: ST_TO_ADDR
// mc_need_heal := [ ] ;
53909: LD_ADDR_EXP 72
53913: PUSH
53914: EMPTY
53915: ST_TO_ADDR
// mc_healers := [ ] ;
53916: LD_ADDR_EXP 73
53920: PUSH
53921: EMPTY
53922: ST_TO_ADDR
// mc_build_list := [ ] ;
53923: LD_ADDR_EXP 74
53927: PUSH
53928: EMPTY
53929: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
53930: LD_ADDR_EXP 101
53934: PUSH
53935: EMPTY
53936: ST_TO_ADDR
// mc_builders := [ ] ;
53937: LD_ADDR_EXP 75
53941: PUSH
53942: EMPTY
53943: ST_TO_ADDR
// mc_construct_list := [ ] ;
53944: LD_ADDR_EXP 76
53948: PUSH
53949: EMPTY
53950: ST_TO_ADDR
// mc_turret_list := [ ] ;
53951: LD_ADDR_EXP 77
53955: PUSH
53956: EMPTY
53957: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
53958: LD_ADDR_EXP 78
53962: PUSH
53963: EMPTY
53964: ST_TO_ADDR
// mc_miners := [ ] ;
53965: LD_ADDR_EXP 83
53969: PUSH
53970: EMPTY
53971: ST_TO_ADDR
// mc_mines := [ ] ;
53972: LD_ADDR_EXP 82
53976: PUSH
53977: EMPTY
53978: ST_TO_ADDR
// mc_minefields := [ ] ;
53979: LD_ADDR_EXP 84
53983: PUSH
53984: EMPTY
53985: ST_TO_ADDR
// mc_crates := [ ] ;
53986: LD_ADDR_EXP 85
53990: PUSH
53991: EMPTY
53992: ST_TO_ADDR
// mc_crates_collector := [ ] ;
53993: LD_ADDR_EXP 86
53997: PUSH
53998: EMPTY
53999: ST_TO_ADDR
// mc_crates_area := [ ] ;
54000: LD_ADDR_EXP 87
54004: PUSH
54005: EMPTY
54006: ST_TO_ADDR
// mc_vehicles := [ ] ;
54007: LD_ADDR_EXP 88
54011: PUSH
54012: EMPTY
54013: ST_TO_ADDR
// mc_attack := [ ] ;
54014: LD_ADDR_EXP 89
54018: PUSH
54019: EMPTY
54020: ST_TO_ADDR
// mc_produce := [ ] ;
54021: LD_ADDR_EXP 90
54025: PUSH
54026: EMPTY
54027: ST_TO_ADDR
// mc_defender := [ ] ;
54028: LD_ADDR_EXP 91
54032: PUSH
54033: EMPTY
54034: ST_TO_ADDR
// mc_parking := [ ] ;
54035: LD_ADDR_EXP 93
54039: PUSH
54040: EMPTY
54041: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
54042: LD_ADDR_EXP 79
54046: PUSH
54047: EMPTY
54048: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
54049: LD_ADDR_EXP 81
54053: PUSH
54054: EMPTY
54055: ST_TO_ADDR
// mc_scan := [ ] ;
54056: LD_ADDR_EXP 92
54060: PUSH
54061: EMPTY
54062: ST_TO_ADDR
// mc_scan_area := [ ] ;
54063: LD_ADDR_EXP 94
54067: PUSH
54068: EMPTY
54069: ST_TO_ADDR
// mc_tech := [ ] ;
54070: LD_ADDR_EXP 96
54074: PUSH
54075: EMPTY
54076: ST_TO_ADDR
// mc_class := [ ] ;
54077: LD_ADDR_EXP 110
54081: PUSH
54082: EMPTY
54083: ST_TO_ADDR
// mc_class_case_use := [ ] ;
54084: LD_ADDR_EXP 111
54088: PUSH
54089: EMPTY
54090: ST_TO_ADDR
// mc_is_defending := [ ] ;
54091: LD_ADDR_EXP 112
54095: PUSH
54096: EMPTY
54097: ST_TO_ADDR
// end ;
54098: LD_VAR 0 1
54102: RET
// export function MC_Kill ( base ) ; begin
54103: LD_INT 0
54105: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
54106: LD_ADDR_EXP 69
54110: PUSH
54111: LD_EXP 69
54115: PPUSH
54116: LD_VAR 0 1
54120: PPUSH
54121: EMPTY
54122: PPUSH
54123: CALL_OW 1
54127: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
54128: LD_ADDR_EXP 70
54132: PUSH
54133: LD_EXP 70
54137: PPUSH
54138: LD_VAR 0 1
54142: PPUSH
54143: EMPTY
54144: PPUSH
54145: CALL_OW 1
54149: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
54150: LD_ADDR_EXP 71
54154: PUSH
54155: LD_EXP 71
54159: PPUSH
54160: LD_VAR 0 1
54164: PPUSH
54165: EMPTY
54166: PPUSH
54167: CALL_OW 1
54171: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
54172: LD_ADDR_EXP 72
54176: PUSH
54177: LD_EXP 72
54181: PPUSH
54182: LD_VAR 0 1
54186: PPUSH
54187: EMPTY
54188: PPUSH
54189: CALL_OW 1
54193: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
54194: LD_ADDR_EXP 73
54198: PUSH
54199: LD_EXP 73
54203: PPUSH
54204: LD_VAR 0 1
54208: PPUSH
54209: EMPTY
54210: PPUSH
54211: CALL_OW 1
54215: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
54216: LD_ADDR_EXP 74
54220: PUSH
54221: LD_EXP 74
54225: PPUSH
54226: LD_VAR 0 1
54230: PPUSH
54231: EMPTY
54232: PPUSH
54233: CALL_OW 1
54237: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
54238: LD_ADDR_EXP 75
54242: PUSH
54243: LD_EXP 75
54247: PPUSH
54248: LD_VAR 0 1
54252: PPUSH
54253: EMPTY
54254: PPUSH
54255: CALL_OW 1
54259: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
54260: LD_ADDR_EXP 76
54264: PUSH
54265: LD_EXP 76
54269: PPUSH
54270: LD_VAR 0 1
54274: PPUSH
54275: EMPTY
54276: PPUSH
54277: CALL_OW 1
54281: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
54282: LD_ADDR_EXP 77
54286: PUSH
54287: LD_EXP 77
54291: PPUSH
54292: LD_VAR 0 1
54296: PPUSH
54297: EMPTY
54298: PPUSH
54299: CALL_OW 1
54303: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
54304: LD_ADDR_EXP 78
54308: PUSH
54309: LD_EXP 78
54313: PPUSH
54314: LD_VAR 0 1
54318: PPUSH
54319: EMPTY
54320: PPUSH
54321: CALL_OW 1
54325: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
54326: LD_ADDR_EXP 79
54330: PUSH
54331: LD_EXP 79
54335: PPUSH
54336: LD_VAR 0 1
54340: PPUSH
54341: EMPTY
54342: PPUSH
54343: CALL_OW 1
54347: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
54348: LD_ADDR_EXP 80
54352: PUSH
54353: LD_EXP 80
54357: PPUSH
54358: LD_VAR 0 1
54362: PPUSH
54363: LD_INT 0
54365: PPUSH
54366: CALL_OW 1
54370: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
54371: LD_ADDR_EXP 81
54375: PUSH
54376: LD_EXP 81
54380: PPUSH
54381: LD_VAR 0 1
54385: PPUSH
54386: EMPTY
54387: PPUSH
54388: CALL_OW 1
54392: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
54393: LD_ADDR_EXP 82
54397: PUSH
54398: LD_EXP 82
54402: PPUSH
54403: LD_VAR 0 1
54407: PPUSH
54408: EMPTY
54409: PPUSH
54410: CALL_OW 1
54414: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
54415: LD_ADDR_EXP 83
54419: PUSH
54420: LD_EXP 83
54424: PPUSH
54425: LD_VAR 0 1
54429: PPUSH
54430: EMPTY
54431: PPUSH
54432: CALL_OW 1
54436: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
54437: LD_ADDR_EXP 84
54441: PUSH
54442: LD_EXP 84
54446: PPUSH
54447: LD_VAR 0 1
54451: PPUSH
54452: EMPTY
54453: PPUSH
54454: CALL_OW 1
54458: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
54459: LD_ADDR_EXP 85
54463: PUSH
54464: LD_EXP 85
54468: PPUSH
54469: LD_VAR 0 1
54473: PPUSH
54474: EMPTY
54475: PPUSH
54476: CALL_OW 1
54480: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
54481: LD_ADDR_EXP 86
54485: PUSH
54486: LD_EXP 86
54490: PPUSH
54491: LD_VAR 0 1
54495: PPUSH
54496: EMPTY
54497: PPUSH
54498: CALL_OW 1
54502: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
54503: LD_ADDR_EXP 87
54507: PUSH
54508: LD_EXP 87
54512: PPUSH
54513: LD_VAR 0 1
54517: PPUSH
54518: EMPTY
54519: PPUSH
54520: CALL_OW 1
54524: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54525: LD_ADDR_EXP 88
54529: PUSH
54530: LD_EXP 88
54534: PPUSH
54535: LD_VAR 0 1
54539: PPUSH
54540: EMPTY
54541: PPUSH
54542: CALL_OW 1
54546: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54547: LD_ADDR_EXP 89
54551: PUSH
54552: LD_EXP 89
54556: PPUSH
54557: LD_VAR 0 1
54561: PPUSH
54562: EMPTY
54563: PPUSH
54564: CALL_OW 1
54568: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54569: LD_ADDR_EXP 90
54573: PUSH
54574: LD_EXP 90
54578: PPUSH
54579: LD_VAR 0 1
54583: PPUSH
54584: EMPTY
54585: PPUSH
54586: CALL_OW 1
54590: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54591: LD_ADDR_EXP 91
54595: PUSH
54596: LD_EXP 91
54600: PPUSH
54601: LD_VAR 0 1
54605: PPUSH
54606: EMPTY
54607: PPUSH
54608: CALL_OW 1
54612: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54613: LD_ADDR_EXP 92
54617: PUSH
54618: LD_EXP 92
54622: PPUSH
54623: LD_VAR 0 1
54627: PPUSH
54628: EMPTY
54629: PPUSH
54630: CALL_OW 1
54634: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54635: LD_ADDR_EXP 93
54639: PUSH
54640: LD_EXP 93
54644: PPUSH
54645: LD_VAR 0 1
54649: PPUSH
54650: EMPTY
54651: PPUSH
54652: CALL_OW 1
54656: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54657: LD_ADDR_EXP 94
54661: PUSH
54662: LD_EXP 94
54666: PPUSH
54667: LD_VAR 0 1
54671: PPUSH
54672: EMPTY
54673: PPUSH
54674: CALL_OW 1
54678: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54679: LD_ADDR_EXP 96
54683: PUSH
54684: LD_EXP 96
54688: PPUSH
54689: LD_VAR 0 1
54693: PPUSH
54694: EMPTY
54695: PPUSH
54696: CALL_OW 1
54700: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54701: LD_ADDR_EXP 98
54705: PUSH
54706: LD_EXP 98
54710: PPUSH
54711: LD_VAR 0 1
54715: PPUSH
54716: EMPTY
54717: PPUSH
54718: CALL_OW 1
54722: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54723: LD_ADDR_EXP 99
54727: PUSH
54728: LD_EXP 99
54732: PPUSH
54733: LD_VAR 0 1
54737: PPUSH
54738: EMPTY
54739: PPUSH
54740: CALL_OW 1
54744: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54745: LD_ADDR_EXP 100
54749: PUSH
54750: LD_EXP 100
54754: PPUSH
54755: LD_VAR 0 1
54759: PPUSH
54760: EMPTY
54761: PPUSH
54762: CALL_OW 1
54766: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54767: LD_ADDR_EXP 101
54771: PUSH
54772: LD_EXP 101
54776: PPUSH
54777: LD_VAR 0 1
54781: PPUSH
54782: EMPTY
54783: PPUSH
54784: CALL_OW 1
54788: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54789: LD_ADDR_EXP 102
54793: PUSH
54794: LD_EXP 102
54798: PPUSH
54799: LD_VAR 0 1
54803: PPUSH
54804: EMPTY
54805: PPUSH
54806: CALL_OW 1
54810: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54811: LD_ADDR_EXP 103
54815: PUSH
54816: LD_EXP 103
54820: PPUSH
54821: LD_VAR 0 1
54825: PPUSH
54826: EMPTY
54827: PPUSH
54828: CALL_OW 1
54832: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54833: LD_ADDR_EXP 104
54837: PUSH
54838: LD_EXP 104
54842: PPUSH
54843: LD_VAR 0 1
54847: PPUSH
54848: EMPTY
54849: PPUSH
54850: CALL_OW 1
54854: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54855: LD_ADDR_EXP 105
54859: PUSH
54860: LD_EXP 105
54864: PPUSH
54865: LD_VAR 0 1
54869: PPUSH
54870: EMPTY
54871: PPUSH
54872: CALL_OW 1
54876: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54877: LD_ADDR_EXP 106
54881: PUSH
54882: LD_EXP 106
54886: PPUSH
54887: LD_VAR 0 1
54891: PPUSH
54892: EMPTY
54893: PPUSH
54894: CALL_OW 1
54898: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54899: LD_ADDR_EXP 107
54903: PUSH
54904: LD_EXP 107
54908: PPUSH
54909: LD_VAR 0 1
54913: PPUSH
54914: EMPTY
54915: PPUSH
54916: CALL_OW 1
54920: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54921: LD_ADDR_EXP 108
54925: PUSH
54926: LD_EXP 108
54930: PPUSH
54931: LD_VAR 0 1
54935: PPUSH
54936: EMPTY
54937: PPUSH
54938: CALL_OW 1
54942: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54943: LD_ADDR_EXP 109
54947: PUSH
54948: LD_EXP 109
54952: PPUSH
54953: LD_VAR 0 1
54957: PPUSH
54958: EMPTY
54959: PPUSH
54960: CALL_OW 1
54964: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54965: LD_ADDR_EXP 110
54969: PUSH
54970: LD_EXP 110
54974: PPUSH
54975: LD_VAR 0 1
54979: PPUSH
54980: EMPTY
54981: PPUSH
54982: CALL_OW 1
54986: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54987: LD_ADDR_EXP 111
54991: PUSH
54992: LD_EXP 111
54996: PPUSH
54997: LD_VAR 0 1
55001: PPUSH
55002: LD_INT 0
55004: PPUSH
55005: CALL_OW 1
55009: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
55010: LD_ADDR_EXP 112
55014: PUSH
55015: LD_EXP 112
55019: PPUSH
55020: LD_VAR 0 1
55024: PPUSH
55025: LD_INT 0
55027: PPUSH
55028: CALL_OW 1
55032: ST_TO_ADDR
// end ;
55033: LD_VAR 0 2
55037: RET
// export function MC_Add ( side , units ) ; var base ; begin
55038: LD_INT 0
55040: PPUSH
55041: PPUSH
// base := mc_bases + 1 ;
55042: LD_ADDR_VAR 0 4
55046: PUSH
55047: LD_EXP 69
55051: PUSH
55052: LD_INT 1
55054: PLUS
55055: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
55056: LD_ADDR_EXP 95
55060: PUSH
55061: LD_EXP 95
55065: PPUSH
55066: LD_VAR 0 4
55070: PPUSH
55071: LD_VAR 0 1
55075: PPUSH
55076: CALL_OW 1
55080: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
55081: LD_ADDR_EXP 69
55085: PUSH
55086: LD_EXP 69
55090: PPUSH
55091: LD_VAR 0 4
55095: PPUSH
55096: LD_VAR 0 2
55100: PPUSH
55101: CALL_OW 1
55105: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55106: LD_ADDR_EXP 70
55110: PUSH
55111: LD_EXP 70
55115: PPUSH
55116: LD_VAR 0 4
55120: PPUSH
55121: EMPTY
55122: PPUSH
55123: CALL_OW 1
55127: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55128: LD_ADDR_EXP 71
55132: PUSH
55133: LD_EXP 71
55137: PPUSH
55138: LD_VAR 0 4
55142: PPUSH
55143: EMPTY
55144: PPUSH
55145: CALL_OW 1
55149: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55150: LD_ADDR_EXP 72
55154: PUSH
55155: LD_EXP 72
55159: PPUSH
55160: LD_VAR 0 4
55164: PPUSH
55165: EMPTY
55166: PPUSH
55167: CALL_OW 1
55171: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55172: LD_ADDR_EXP 73
55176: PUSH
55177: LD_EXP 73
55181: PPUSH
55182: LD_VAR 0 4
55186: PPUSH
55187: EMPTY
55188: PPUSH
55189: CALL_OW 1
55193: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55194: LD_ADDR_EXP 74
55198: PUSH
55199: LD_EXP 74
55203: PPUSH
55204: LD_VAR 0 4
55208: PPUSH
55209: EMPTY
55210: PPUSH
55211: CALL_OW 1
55215: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55216: LD_ADDR_EXP 75
55220: PUSH
55221: LD_EXP 75
55225: PPUSH
55226: LD_VAR 0 4
55230: PPUSH
55231: EMPTY
55232: PPUSH
55233: CALL_OW 1
55237: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55238: LD_ADDR_EXP 76
55242: PUSH
55243: LD_EXP 76
55247: PPUSH
55248: LD_VAR 0 4
55252: PPUSH
55253: EMPTY
55254: PPUSH
55255: CALL_OW 1
55259: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55260: LD_ADDR_EXP 77
55264: PUSH
55265: LD_EXP 77
55269: PPUSH
55270: LD_VAR 0 4
55274: PPUSH
55275: EMPTY
55276: PPUSH
55277: CALL_OW 1
55281: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55282: LD_ADDR_EXP 78
55286: PUSH
55287: LD_EXP 78
55291: PPUSH
55292: LD_VAR 0 4
55296: PPUSH
55297: EMPTY
55298: PPUSH
55299: CALL_OW 1
55303: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55304: LD_ADDR_EXP 79
55308: PUSH
55309: LD_EXP 79
55313: PPUSH
55314: LD_VAR 0 4
55318: PPUSH
55319: EMPTY
55320: PPUSH
55321: CALL_OW 1
55325: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55326: LD_ADDR_EXP 80
55330: PUSH
55331: LD_EXP 80
55335: PPUSH
55336: LD_VAR 0 4
55340: PPUSH
55341: LD_INT 0
55343: PPUSH
55344: CALL_OW 1
55348: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55349: LD_ADDR_EXP 81
55353: PUSH
55354: LD_EXP 81
55358: PPUSH
55359: LD_VAR 0 4
55363: PPUSH
55364: EMPTY
55365: PPUSH
55366: CALL_OW 1
55370: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55371: LD_ADDR_EXP 82
55375: PUSH
55376: LD_EXP 82
55380: PPUSH
55381: LD_VAR 0 4
55385: PPUSH
55386: EMPTY
55387: PPUSH
55388: CALL_OW 1
55392: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55393: LD_ADDR_EXP 83
55397: PUSH
55398: LD_EXP 83
55402: PPUSH
55403: LD_VAR 0 4
55407: PPUSH
55408: EMPTY
55409: PPUSH
55410: CALL_OW 1
55414: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55415: LD_ADDR_EXP 84
55419: PUSH
55420: LD_EXP 84
55424: PPUSH
55425: LD_VAR 0 4
55429: PPUSH
55430: EMPTY
55431: PPUSH
55432: CALL_OW 1
55436: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55437: LD_ADDR_EXP 85
55441: PUSH
55442: LD_EXP 85
55446: PPUSH
55447: LD_VAR 0 4
55451: PPUSH
55452: EMPTY
55453: PPUSH
55454: CALL_OW 1
55458: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55459: LD_ADDR_EXP 86
55463: PUSH
55464: LD_EXP 86
55468: PPUSH
55469: LD_VAR 0 4
55473: PPUSH
55474: EMPTY
55475: PPUSH
55476: CALL_OW 1
55480: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55481: LD_ADDR_EXP 87
55485: PUSH
55486: LD_EXP 87
55490: PPUSH
55491: LD_VAR 0 4
55495: PPUSH
55496: EMPTY
55497: PPUSH
55498: CALL_OW 1
55502: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55503: LD_ADDR_EXP 88
55507: PUSH
55508: LD_EXP 88
55512: PPUSH
55513: LD_VAR 0 4
55517: PPUSH
55518: EMPTY
55519: PPUSH
55520: CALL_OW 1
55524: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55525: LD_ADDR_EXP 89
55529: PUSH
55530: LD_EXP 89
55534: PPUSH
55535: LD_VAR 0 4
55539: PPUSH
55540: EMPTY
55541: PPUSH
55542: CALL_OW 1
55546: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55547: LD_ADDR_EXP 90
55551: PUSH
55552: LD_EXP 90
55556: PPUSH
55557: LD_VAR 0 4
55561: PPUSH
55562: EMPTY
55563: PPUSH
55564: CALL_OW 1
55568: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55569: LD_ADDR_EXP 91
55573: PUSH
55574: LD_EXP 91
55578: PPUSH
55579: LD_VAR 0 4
55583: PPUSH
55584: EMPTY
55585: PPUSH
55586: CALL_OW 1
55590: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55591: LD_ADDR_EXP 92
55595: PUSH
55596: LD_EXP 92
55600: PPUSH
55601: LD_VAR 0 4
55605: PPUSH
55606: EMPTY
55607: PPUSH
55608: CALL_OW 1
55612: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55613: LD_ADDR_EXP 93
55617: PUSH
55618: LD_EXP 93
55622: PPUSH
55623: LD_VAR 0 4
55627: PPUSH
55628: EMPTY
55629: PPUSH
55630: CALL_OW 1
55634: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55635: LD_ADDR_EXP 94
55639: PUSH
55640: LD_EXP 94
55644: PPUSH
55645: LD_VAR 0 4
55649: PPUSH
55650: EMPTY
55651: PPUSH
55652: CALL_OW 1
55656: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55657: LD_ADDR_EXP 96
55661: PUSH
55662: LD_EXP 96
55666: PPUSH
55667: LD_VAR 0 4
55671: PPUSH
55672: EMPTY
55673: PPUSH
55674: CALL_OW 1
55678: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55679: LD_ADDR_EXP 98
55683: PUSH
55684: LD_EXP 98
55688: PPUSH
55689: LD_VAR 0 4
55693: PPUSH
55694: EMPTY
55695: PPUSH
55696: CALL_OW 1
55700: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55701: LD_ADDR_EXP 99
55705: PUSH
55706: LD_EXP 99
55710: PPUSH
55711: LD_VAR 0 4
55715: PPUSH
55716: EMPTY
55717: PPUSH
55718: CALL_OW 1
55722: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55723: LD_ADDR_EXP 100
55727: PUSH
55728: LD_EXP 100
55732: PPUSH
55733: LD_VAR 0 4
55737: PPUSH
55738: EMPTY
55739: PPUSH
55740: CALL_OW 1
55744: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55745: LD_ADDR_EXP 101
55749: PUSH
55750: LD_EXP 101
55754: PPUSH
55755: LD_VAR 0 4
55759: PPUSH
55760: EMPTY
55761: PPUSH
55762: CALL_OW 1
55766: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55767: LD_ADDR_EXP 102
55771: PUSH
55772: LD_EXP 102
55776: PPUSH
55777: LD_VAR 0 4
55781: PPUSH
55782: EMPTY
55783: PPUSH
55784: CALL_OW 1
55788: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55789: LD_ADDR_EXP 103
55793: PUSH
55794: LD_EXP 103
55798: PPUSH
55799: LD_VAR 0 4
55803: PPUSH
55804: EMPTY
55805: PPUSH
55806: CALL_OW 1
55810: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55811: LD_ADDR_EXP 104
55815: PUSH
55816: LD_EXP 104
55820: PPUSH
55821: LD_VAR 0 4
55825: PPUSH
55826: EMPTY
55827: PPUSH
55828: CALL_OW 1
55832: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55833: LD_ADDR_EXP 105
55837: PUSH
55838: LD_EXP 105
55842: PPUSH
55843: LD_VAR 0 4
55847: PPUSH
55848: EMPTY
55849: PPUSH
55850: CALL_OW 1
55854: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55855: LD_ADDR_EXP 106
55859: PUSH
55860: LD_EXP 106
55864: PPUSH
55865: LD_VAR 0 4
55869: PPUSH
55870: EMPTY
55871: PPUSH
55872: CALL_OW 1
55876: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55877: LD_ADDR_EXP 107
55881: PUSH
55882: LD_EXP 107
55886: PPUSH
55887: LD_VAR 0 4
55891: PPUSH
55892: EMPTY
55893: PPUSH
55894: CALL_OW 1
55898: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55899: LD_ADDR_EXP 108
55903: PUSH
55904: LD_EXP 108
55908: PPUSH
55909: LD_VAR 0 4
55913: PPUSH
55914: EMPTY
55915: PPUSH
55916: CALL_OW 1
55920: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55921: LD_ADDR_EXP 109
55925: PUSH
55926: LD_EXP 109
55930: PPUSH
55931: LD_VAR 0 4
55935: PPUSH
55936: EMPTY
55937: PPUSH
55938: CALL_OW 1
55942: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55943: LD_ADDR_EXP 110
55947: PUSH
55948: LD_EXP 110
55952: PPUSH
55953: LD_VAR 0 4
55957: PPUSH
55958: EMPTY
55959: PPUSH
55960: CALL_OW 1
55964: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55965: LD_ADDR_EXP 111
55969: PUSH
55970: LD_EXP 111
55974: PPUSH
55975: LD_VAR 0 4
55979: PPUSH
55980: LD_INT 0
55982: PPUSH
55983: CALL_OW 1
55987: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
55988: LD_ADDR_EXP 112
55992: PUSH
55993: LD_EXP 112
55997: PPUSH
55998: LD_VAR 0 4
56002: PPUSH
56003: LD_INT 0
56005: PPUSH
56006: CALL_OW 1
56010: ST_TO_ADDR
// result := base ;
56011: LD_ADDR_VAR 0 3
56015: PUSH
56016: LD_VAR 0 4
56020: ST_TO_ADDR
// end ;
56021: LD_VAR 0 3
56025: RET
// export function MC_Start ( ) ; var i ; begin
56026: LD_INT 0
56028: PPUSH
56029: PPUSH
// for i = 1 to mc_bases do
56030: LD_ADDR_VAR 0 2
56034: PUSH
56035: DOUBLE
56036: LD_INT 1
56038: DEC
56039: ST_TO_ADDR
56040: LD_EXP 69
56044: PUSH
56045: FOR_TO
56046: IFFALSE 57146
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
56048: LD_ADDR_EXP 69
56052: PUSH
56053: LD_EXP 69
56057: PPUSH
56058: LD_VAR 0 2
56062: PPUSH
56063: LD_EXP 69
56067: PUSH
56068: LD_VAR 0 2
56072: ARRAY
56073: PUSH
56074: LD_INT 0
56076: DIFF
56077: PPUSH
56078: CALL_OW 1
56082: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
56083: LD_ADDR_EXP 70
56087: PUSH
56088: LD_EXP 70
56092: PPUSH
56093: LD_VAR 0 2
56097: PPUSH
56098: EMPTY
56099: PPUSH
56100: CALL_OW 1
56104: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56105: LD_ADDR_EXP 71
56109: PUSH
56110: LD_EXP 71
56114: PPUSH
56115: LD_VAR 0 2
56119: PPUSH
56120: EMPTY
56121: PPUSH
56122: CALL_OW 1
56126: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
56127: LD_ADDR_EXP 72
56131: PUSH
56132: LD_EXP 72
56136: PPUSH
56137: LD_VAR 0 2
56141: PPUSH
56142: EMPTY
56143: PPUSH
56144: CALL_OW 1
56148: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
56149: LD_ADDR_EXP 73
56153: PUSH
56154: LD_EXP 73
56158: PPUSH
56159: LD_VAR 0 2
56163: PPUSH
56164: EMPTY
56165: PUSH
56166: EMPTY
56167: PUSH
56168: EMPTY
56169: LIST
56170: LIST
56171: PPUSH
56172: CALL_OW 1
56176: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
56177: LD_ADDR_EXP 74
56181: PUSH
56182: LD_EXP 74
56186: PPUSH
56187: LD_VAR 0 2
56191: PPUSH
56192: EMPTY
56193: PPUSH
56194: CALL_OW 1
56198: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
56199: LD_ADDR_EXP 101
56203: PUSH
56204: LD_EXP 101
56208: PPUSH
56209: LD_VAR 0 2
56213: PPUSH
56214: EMPTY
56215: PPUSH
56216: CALL_OW 1
56220: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
56221: LD_ADDR_EXP 75
56225: PUSH
56226: LD_EXP 75
56230: PPUSH
56231: LD_VAR 0 2
56235: PPUSH
56236: EMPTY
56237: PPUSH
56238: CALL_OW 1
56242: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
56243: LD_ADDR_EXP 76
56247: PUSH
56248: LD_EXP 76
56252: PPUSH
56253: LD_VAR 0 2
56257: PPUSH
56258: EMPTY
56259: PPUSH
56260: CALL_OW 1
56264: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
56265: LD_ADDR_EXP 77
56269: PUSH
56270: LD_EXP 77
56274: PPUSH
56275: LD_VAR 0 2
56279: PPUSH
56280: LD_EXP 69
56284: PUSH
56285: LD_VAR 0 2
56289: ARRAY
56290: PPUSH
56291: LD_INT 2
56293: PUSH
56294: LD_INT 30
56296: PUSH
56297: LD_INT 32
56299: PUSH
56300: EMPTY
56301: LIST
56302: LIST
56303: PUSH
56304: LD_INT 30
56306: PUSH
56307: LD_INT 33
56309: PUSH
56310: EMPTY
56311: LIST
56312: LIST
56313: PUSH
56314: EMPTY
56315: LIST
56316: LIST
56317: LIST
56318: PPUSH
56319: CALL_OW 72
56323: PPUSH
56324: CALL_OW 1
56328: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
56329: LD_ADDR_EXP 78
56333: PUSH
56334: LD_EXP 78
56338: PPUSH
56339: LD_VAR 0 2
56343: PPUSH
56344: LD_EXP 69
56348: PUSH
56349: LD_VAR 0 2
56353: ARRAY
56354: PPUSH
56355: LD_INT 2
56357: PUSH
56358: LD_INT 30
56360: PUSH
56361: LD_INT 32
56363: PUSH
56364: EMPTY
56365: LIST
56366: LIST
56367: PUSH
56368: LD_INT 30
56370: PUSH
56371: LD_INT 31
56373: PUSH
56374: EMPTY
56375: LIST
56376: LIST
56377: PUSH
56378: EMPTY
56379: LIST
56380: LIST
56381: LIST
56382: PUSH
56383: LD_INT 58
56385: PUSH
56386: EMPTY
56387: LIST
56388: PUSH
56389: EMPTY
56390: LIST
56391: LIST
56392: PPUSH
56393: CALL_OW 72
56397: PPUSH
56398: CALL_OW 1
56402: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
56403: LD_ADDR_EXP 79
56407: PUSH
56408: LD_EXP 79
56412: PPUSH
56413: LD_VAR 0 2
56417: PPUSH
56418: EMPTY
56419: PPUSH
56420: CALL_OW 1
56424: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
56425: LD_ADDR_EXP 83
56429: PUSH
56430: LD_EXP 83
56434: PPUSH
56435: LD_VAR 0 2
56439: PPUSH
56440: EMPTY
56441: PPUSH
56442: CALL_OW 1
56446: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
56447: LD_ADDR_EXP 82
56451: PUSH
56452: LD_EXP 82
56456: PPUSH
56457: LD_VAR 0 2
56461: PPUSH
56462: EMPTY
56463: PPUSH
56464: CALL_OW 1
56468: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
56469: LD_ADDR_EXP 84
56473: PUSH
56474: LD_EXP 84
56478: PPUSH
56479: LD_VAR 0 2
56483: PPUSH
56484: EMPTY
56485: PPUSH
56486: CALL_OW 1
56490: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
56491: LD_ADDR_EXP 85
56495: PUSH
56496: LD_EXP 85
56500: PPUSH
56501: LD_VAR 0 2
56505: PPUSH
56506: EMPTY
56507: PPUSH
56508: CALL_OW 1
56512: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
56513: LD_ADDR_EXP 86
56517: PUSH
56518: LD_EXP 86
56522: PPUSH
56523: LD_VAR 0 2
56527: PPUSH
56528: EMPTY
56529: PPUSH
56530: CALL_OW 1
56534: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
56535: LD_ADDR_EXP 87
56539: PUSH
56540: LD_EXP 87
56544: PPUSH
56545: LD_VAR 0 2
56549: PPUSH
56550: EMPTY
56551: PPUSH
56552: CALL_OW 1
56556: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
56557: LD_ADDR_EXP 88
56561: PUSH
56562: LD_EXP 88
56566: PPUSH
56567: LD_VAR 0 2
56571: PPUSH
56572: EMPTY
56573: PPUSH
56574: CALL_OW 1
56578: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
56579: LD_ADDR_EXP 89
56583: PUSH
56584: LD_EXP 89
56588: PPUSH
56589: LD_VAR 0 2
56593: PPUSH
56594: EMPTY
56595: PPUSH
56596: CALL_OW 1
56600: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
56601: LD_ADDR_EXP 90
56605: PUSH
56606: LD_EXP 90
56610: PPUSH
56611: LD_VAR 0 2
56615: PPUSH
56616: EMPTY
56617: PPUSH
56618: CALL_OW 1
56622: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56623: LD_ADDR_EXP 91
56627: PUSH
56628: LD_EXP 91
56632: PPUSH
56633: LD_VAR 0 2
56637: PPUSH
56638: EMPTY
56639: PPUSH
56640: CALL_OW 1
56644: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
56645: LD_ADDR_EXP 80
56649: PUSH
56650: LD_EXP 80
56654: PPUSH
56655: LD_VAR 0 2
56659: PPUSH
56660: LD_INT 0
56662: PPUSH
56663: CALL_OW 1
56667: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
56668: LD_ADDR_EXP 93
56672: PUSH
56673: LD_EXP 93
56677: PPUSH
56678: LD_VAR 0 2
56682: PPUSH
56683: LD_INT 0
56685: PPUSH
56686: CALL_OW 1
56690: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
56691: LD_ADDR_EXP 81
56695: PUSH
56696: LD_EXP 81
56700: PPUSH
56701: LD_VAR 0 2
56705: PPUSH
56706: EMPTY
56707: PPUSH
56708: CALL_OW 1
56712: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
56713: LD_ADDR_EXP 92
56717: PUSH
56718: LD_EXP 92
56722: PPUSH
56723: LD_VAR 0 2
56727: PPUSH
56728: LD_INT 0
56730: PPUSH
56731: CALL_OW 1
56735: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
56736: LD_ADDR_EXP 94
56740: PUSH
56741: LD_EXP 94
56745: PPUSH
56746: LD_VAR 0 2
56750: PPUSH
56751: EMPTY
56752: PPUSH
56753: CALL_OW 1
56757: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
56758: LD_ADDR_EXP 97
56762: PUSH
56763: LD_EXP 97
56767: PPUSH
56768: LD_VAR 0 2
56772: PPUSH
56773: LD_INT 0
56775: PPUSH
56776: CALL_OW 1
56780: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
56781: LD_ADDR_EXP 98
56785: PUSH
56786: LD_EXP 98
56790: PPUSH
56791: LD_VAR 0 2
56795: PPUSH
56796: EMPTY
56797: PPUSH
56798: CALL_OW 1
56802: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
56803: LD_ADDR_EXP 99
56807: PUSH
56808: LD_EXP 99
56812: PPUSH
56813: LD_VAR 0 2
56817: PPUSH
56818: EMPTY
56819: PPUSH
56820: CALL_OW 1
56824: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
56825: LD_ADDR_EXP 100
56829: PUSH
56830: LD_EXP 100
56834: PPUSH
56835: LD_VAR 0 2
56839: PPUSH
56840: EMPTY
56841: PPUSH
56842: CALL_OW 1
56846: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
56847: LD_ADDR_EXP 102
56851: PUSH
56852: LD_EXP 102
56856: PPUSH
56857: LD_VAR 0 2
56861: PPUSH
56862: LD_EXP 69
56866: PUSH
56867: LD_VAR 0 2
56871: ARRAY
56872: PPUSH
56873: LD_INT 2
56875: PUSH
56876: LD_INT 30
56878: PUSH
56879: LD_INT 6
56881: PUSH
56882: EMPTY
56883: LIST
56884: LIST
56885: PUSH
56886: LD_INT 30
56888: PUSH
56889: LD_INT 7
56891: PUSH
56892: EMPTY
56893: LIST
56894: LIST
56895: PUSH
56896: LD_INT 30
56898: PUSH
56899: LD_INT 8
56901: PUSH
56902: EMPTY
56903: LIST
56904: LIST
56905: PUSH
56906: EMPTY
56907: LIST
56908: LIST
56909: LIST
56910: LIST
56911: PPUSH
56912: CALL_OW 72
56916: PPUSH
56917: CALL_OW 1
56921: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
56922: LD_ADDR_EXP 103
56926: PUSH
56927: LD_EXP 103
56931: PPUSH
56932: LD_VAR 0 2
56936: PPUSH
56937: EMPTY
56938: PPUSH
56939: CALL_OW 1
56943: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
56944: LD_ADDR_EXP 104
56948: PUSH
56949: LD_EXP 104
56953: PPUSH
56954: LD_VAR 0 2
56958: PPUSH
56959: EMPTY
56960: PPUSH
56961: CALL_OW 1
56965: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
56966: LD_ADDR_EXP 105
56970: PUSH
56971: LD_EXP 105
56975: PPUSH
56976: LD_VAR 0 2
56980: PPUSH
56981: EMPTY
56982: PPUSH
56983: CALL_OW 1
56987: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
56988: LD_ADDR_EXP 106
56992: PUSH
56993: LD_EXP 106
56997: PPUSH
56998: LD_VAR 0 2
57002: PPUSH
57003: EMPTY
57004: PPUSH
57005: CALL_OW 1
57009: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57010: LD_ADDR_EXP 107
57014: PUSH
57015: LD_EXP 107
57019: PPUSH
57020: LD_VAR 0 2
57024: PPUSH
57025: EMPTY
57026: PPUSH
57027: CALL_OW 1
57031: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
57032: LD_ADDR_EXP 108
57036: PUSH
57037: LD_EXP 108
57041: PPUSH
57042: LD_VAR 0 2
57046: PPUSH
57047: EMPTY
57048: PPUSH
57049: CALL_OW 1
57053: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
57054: LD_ADDR_EXP 109
57058: PUSH
57059: LD_EXP 109
57063: PPUSH
57064: LD_VAR 0 2
57068: PPUSH
57069: EMPTY
57070: PPUSH
57071: CALL_OW 1
57075: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
57076: LD_ADDR_EXP 110
57080: PUSH
57081: LD_EXP 110
57085: PPUSH
57086: LD_VAR 0 2
57090: PPUSH
57091: EMPTY
57092: PPUSH
57093: CALL_OW 1
57097: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
57098: LD_ADDR_EXP 111
57102: PUSH
57103: LD_EXP 111
57107: PPUSH
57108: LD_VAR 0 2
57112: PPUSH
57113: LD_INT 0
57115: PPUSH
57116: CALL_OW 1
57120: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
57121: LD_ADDR_EXP 112
57125: PUSH
57126: LD_EXP 112
57130: PPUSH
57131: LD_VAR 0 2
57135: PPUSH
57136: LD_INT 0
57138: PPUSH
57139: CALL_OW 1
57143: ST_TO_ADDR
// end ;
57144: GO 56045
57146: POP
57147: POP
// MC_InitSides ( ) ;
57148: CALL 57434 0 0
// MC_InitResearch ( ) ;
57152: CALL 57173 0 0
// CustomInitMacro ( ) ;
57156: CALL 5753 0 0
// skirmish := true ;
57160: LD_ADDR_EXP 67
57164: PUSH
57165: LD_INT 1
57167: ST_TO_ADDR
// end ;
57168: LD_VAR 0 1
57172: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
57173: LD_INT 0
57175: PPUSH
57176: PPUSH
57177: PPUSH
57178: PPUSH
57179: PPUSH
57180: PPUSH
// if not mc_bases then
57181: LD_EXP 69
57185: NOT
57186: IFFALSE 57190
// exit ;
57188: GO 57429
// for i = 1 to 8 do
57190: LD_ADDR_VAR 0 2
57194: PUSH
57195: DOUBLE
57196: LD_INT 1
57198: DEC
57199: ST_TO_ADDR
57200: LD_INT 8
57202: PUSH
57203: FOR_TO
57204: IFFALSE 57230
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
57206: LD_ADDR_EXP 96
57210: PUSH
57211: LD_EXP 96
57215: PPUSH
57216: LD_VAR 0 2
57220: PPUSH
57221: EMPTY
57222: PPUSH
57223: CALL_OW 1
57227: ST_TO_ADDR
57228: GO 57203
57230: POP
57231: POP
// tmp := [ ] ;
57232: LD_ADDR_VAR 0 5
57236: PUSH
57237: EMPTY
57238: ST_TO_ADDR
// for i = 1 to mc_sides do
57239: LD_ADDR_VAR 0 2
57243: PUSH
57244: DOUBLE
57245: LD_INT 1
57247: DEC
57248: ST_TO_ADDR
57249: LD_EXP 95
57253: PUSH
57254: FOR_TO
57255: IFFALSE 57313
// if not mc_sides [ i ] in tmp then
57257: LD_EXP 95
57261: PUSH
57262: LD_VAR 0 2
57266: ARRAY
57267: PUSH
57268: LD_VAR 0 5
57272: IN
57273: NOT
57274: IFFALSE 57311
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
57276: LD_ADDR_VAR 0 5
57280: PUSH
57281: LD_VAR 0 5
57285: PPUSH
57286: LD_VAR 0 5
57290: PUSH
57291: LD_INT 1
57293: PLUS
57294: PPUSH
57295: LD_EXP 95
57299: PUSH
57300: LD_VAR 0 2
57304: ARRAY
57305: PPUSH
57306: CALL_OW 2
57310: ST_TO_ADDR
57311: GO 57254
57313: POP
57314: POP
// if not tmp then
57315: LD_VAR 0 5
57319: NOT
57320: IFFALSE 57324
// exit ;
57322: GO 57429
// for j in tmp do
57324: LD_ADDR_VAR 0 3
57328: PUSH
57329: LD_VAR 0 5
57333: PUSH
57334: FOR_IN
57335: IFFALSE 57427
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
57337: LD_ADDR_VAR 0 6
57341: PUSH
57342: LD_INT 22
57344: PUSH
57345: LD_VAR 0 3
57349: PUSH
57350: EMPTY
57351: LIST
57352: LIST
57353: PPUSH
57354: CALL_OW 69
57358: ST_TO_ADDR
// if not un then
57359: LD_VAR 0 6
57363: NOT
57364: IFFALSE 57368
// continue ;
57366: GO 57334
// nation := GetNation ( un [ 1 ] ) ;
57368: LD_ADDR_VAR 0 4
57372: PUSH
57373: LD_VAR 0 6
57377: PUSH
57378: LD_INT 1
57380: ARRAY
57381: PPUSH
57382: CALL_OW 248
57386: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
57387: LD_ADDR_EXP 96
57391: PUSH
57392: LD_EXP 96
57396: PPUSH
57397: LD_VAR 0 3
57401: PPUSH
57402: LD_VAR 0 3
57406: PPUSH
57407: LD_VAR 0 4
57411: PPUSH
57412: LD_INT 1
57414: PPUSH
57415: CALL 13665 0 3
57419: PPUSH
57420: CALL_OW 1
57424: ST_TO_ADDR
// end ;
57425: GO 57334
57427: POP
57428: POP
// end ;
57429: LD_VAR 0 1
57433: RET
// export function MC_InitSides ( ) ; var i ; begin
57434: LD_INT 0
57436: PPUSH
57437: PPUSH
// if not mc_bases then
57438: LD_EXP 69
57442: NOT
57443: IFFALSE 57447
// exit ;
57445: GO 57521
// for i = 1 to mc_bases do
57447: LD_ADDR_VAR 0 2
57451: PUSH
57452: DOUBLE
57453: LD_INT 1
57455: DEC
57456: ST_TO_ADDR
57457: LD_EXP 69
57461: PUSH
57462: FOR_TO
57463: IFFALSE 57519
// if mc_bases [ i ] then
57465: LD_EXP 69
57469: PUSH
57470: LD_VAR 0 2
57474: ARRAY
57475: IFFALSE 57517
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
57477: LD_ADDR_EXP 95
57481: PUSH
57482: LD_EXP 95
57486: PPUSH
57487: LD_VAR 0 2
57491: PPUSH
57492: LD_EXP 69
57496: PUSH
57497: LD_VAR 0 2
57501: ARRAY
57502: PUSH
57503: LD_INT 1
57505: ARRAY
57506: PPUSH
57507: CALL_OW 255
57511: PPUSH
57512: CALL_OW 1
57516: ST_TO_ADDR
57517: GO 57462
57519: POP
57520: POP
// end ;
57521: LD_VAR 0 1
57525: RET
// every 0 0$03 trigger skirmish do
57526: LD_EXP 67
57530: IFFALSE 57684
57532: GO 57534
57534: DISABLE
// begin enable ;
57535: ENABLE
// MC_CheckBuildings ( ) ;
57536: CALL 62182 0 0
// MC_CheckPeopleLife ( ) ;
57540: CALL 62343 0 0
// RaiseSailEvent ( 100 ) ;
57544: LD_INT 100
57546: PPUSH
57547: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
57551: LD_INT 103
57553: PPUSH
57554: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
57558: LD_INT 104
57560: PPUSH
57561: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
57565: LD_INT 105
57567: PPUSH
57568: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
57572: LD_INT 106
57574: PPUSH
57575: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
57579: LD_INT 107
57581: PPUSH
57582: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
57586: LD_INT 108
57588: PPUSH
57589: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
57593: LD_INT 109
57595: PPUSH
57596: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
57600: LD_INT 110
57602: PPUSH
57603: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
57607: LD_INT 111
57609: PPUSH
57610: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
57614: LD_INT 112
57616: PPUSH
57617: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
57621: LD_INT 113
57623: PPUSH
57624: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
57628: LD_INT 120
57630: PPUSH
57631: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
57635: LD_INT 121
57637: PPUSH
57638: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
57642: LD_INT 122
57644: PPUSH
57645: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
57649: LD_INT 123
57651: PPUSH
57652: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
57656: LD_INT 124
57658: PPUSH
57659: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
57663: LD_INT 125
57665: PPUSH
57666: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
57670: LD_INT 126
57672: PPUSH
57673: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
57677: LD_INT 200
57679: PPUSH
57680: CALL_OW 427
// end ;
57684: END
// on SailEvent ( event ) do begin if event < 100 then
57685: LD_VAR 0 1
57689: PUSH
57690: LD_INT 100
57692: LESS
57693: IFFALSE 57704
// CustomEvent ( event ) ;
57695: LD_VAR 0 1
57699: PPUSH
57700: CALL 5745 0 1
// if event = 100 then
57704: LD_VAR 0 1
57708: PUSH
57709: LD_INT 100
57711: EQUAL
57712: IFFALSE 57718
// MC_ClassManager ( ) ;
57714: CALL 58110 0 0
// if event = 101 then
57718: LD_VAR 0 1
57722: PUSH
57723: LD_INT 101
57725: EQUAL
57726: IFFALSE 57732
// MC_RepairBuildings ( ) ;
57728: CALL 62928 0 0
// if event = 102 then
57732: LD_VAR 0 1
57736: PUSH
57737: LD_INT 102
57739: EQUAL
57740: IFFALSE 57746
// MC_Heal ( ) ;
57742: CALL 63835 0 0
// if event = 103 then
57746: LD_VAR 0 1
57750: PUSH
57751: LD_INT 103
57753: EQUAL
57754: IFFALSE 57760
// MC_Build ( ) ;
57756: CALL 64257 0 0
// if event = 104 then
57760: LD_VAR 0 1
57764: PUSH
57765: LD_INT 104
57767: EQUAL
57768: IFFALSE 57774
// MC_TurretWeapon ( ) ;
57770: CALL 65898 0 0
// if event = 105 then
57774: LD_VAR 0 1
57778: PUSH
57779: LD_INT 105
57781: EQUAL
57782: IFFALSE 57788
// MC_BuildUpgrade ( ) ;
57784: CALL 65449 0 0
// if event = 106 then
57788: LD_VAR 0 1
57792: PUSH
57793: LD_INT 106
57795: EQUAL
57796: IFFALSE 57802
// MC_PlantMines ( ) ;
57798: CALL 66328 0 0
// if event = 107 then
57802: LD_VAR 0 1
57806: PUSH
57807: LD_INT 107
57809: EQUAL
57810: IFFALSE 57816
// MC_CollectCrates ( ) ;
57812: CALL 67119 0 0
// if event = 108 then
57816: LD_VAR 0 1
57820: PUSH
57821: LD_INT 108
57823: EQUAL
57824: IFFALSE 57830
// MC_LinkRemoteControl ( ) ;
57826: CALL 68969 0 0
// if event = 109 then
57830: LD_VAR 0 1
57834: PUSH
57835: LD_INT 109
57837: EQUAL
57838: IFFALSE 57844
// MC_ProduceVehicle ( ) ;
57840: CALL 69150 0 0
// if event = 110 then
57844: LD_VAR 0 1
57848: PUSH
57849: LD_INT 110
57851: EQUAL
57852: IFFALSE 57858
// MC_SendAttack ( ) ;
57854: CALL 69616 0 0
// if event = 111 then
57858: LD_VAR 0 1
57862: PUSH
57863: LD_INT 111
57865: EQUAL
57866: IFFALSE 57872
// MC_Defend ( ) ;
57868: CALL 69724 0 0
// if event = 112 then
57872: LD_VAR 0 1
57876: PUSH
57877: LD_INT 112
57879: EQUAL
57880: IFFALSE 57886
// MC_Research ( ) ;
57882: CALL 70604 0 0
// if event = 113 then
57886: LD_VAR 0 1
57890: PUSH
57891: LD_INT 113
57893: EQUAL
57894: IFFALSE 57900
// MC_MinesTrigger ( ) ;
57896: CALL 71718 0 0
// if event = 120 then
57900: LD_VAR 0 1
57904: PUSH
57905: LD_INT 120
57907: EQUAL
57908: IFFALSE 57914
// MC_RepairVehicle ( ) ;
57910: CALL 71817 0 0
// if event = 121 then
57914: LD_VAR 0 1
57918: PUSH
57919: LD_INT 121
57921: EQUAL
57922: IFFALSE 57928
// MC_TameApe ( ) ;
57924: CALL 72558 0 0
// if event = 122 then
57928: LD_VAR 0 1
57932: PUSH
57933: LD_INT 122
57935: EQUAL
57936: IFFALSE 57942
// MC_ChangeApeClass ( ) ;
57938: CALL 73387 0 0
// if event = 123 then
57942: LD_VAR 0 1
57946: PUSH
57947: LD_INT 123
57949: EQUAL
57950: IFFALSE 57956
// MC_Bazooka ( ) ;
57952: CALL 74037 0 0
// if event = 124 then
57956: LD_VAR 0 1
57960: PUSH
57961: LD_INT 124
57963: EQUAL
57964: IFFALSE 57970
// MC_TeleportExit ( ) ;
57966: CALL 74235 0 0
// if event = 125 then
57970: LD_VAR 0 1
57974: PUSH
57975: LD_INT 125
57977: EQUAL
57978: IFFALSE 57984
// MC_Deposits ( ) ;
57980: CALL 74882 0 0
// if event = 126 then
57984: LD_VAR 0 1
57988: PUSH
57989: LD_INT 126
57991: EQUAL
57992: IFFALSE 57998
// MC_RemoteDriver ( ) ;
57994: CALL 75507 0 0
// if event = 200 then
57998: LD_VAR 0 1
58002: PUSH
58003: LD_INT 200
58005: EQUAL
58006: IFFALSE 58012
// MC_Idle ( ) ;
58008: CALL 77456 0 0
// end ;
58012: PPOPN 1
58014: END
// export function MC_Reset ( base , tag ) ; var i ; begin
58015: LD_INT 0
58017: PPUSH
58018: PPUSH
// if not mc_bases [ base ] or not tag then
58019: LD_EXP 69
58023: PUSH
58024: LD_VAR 0 1
58028: ARRAY
58029: NOT
58030: PUSH
58031: LD_VAR 0 2
58035: NOT
58036: OR
58037: IFFALSE 58041
// exit ;
58039: GO 58105
// for i in mc_bases [ base ] union mc_ape [ base ] do
58041: LD_ADDR_VAR 0 4
58045: PUSH
58046: LD_EXP 69
58050: PUSH
58051: LD_VAR 0 1
58055: ARRAY
58056: PUSH
58057: LD_EXP 98
58061: PUSH
58062: LD_VAR 0 1
58066: ARRAY
58067: UNION
58068: PUSH
58069: FOR_IN
58070: IFFALSE 58103
// if GetTag ( i ) = tag then
58072: LD_VAR 0 4
58076: PPUSH
58077: CALL_OW 110
58081: PUSH
58082: LD_VAR 0 2
58086: EQUAL
58087: IFFALSE 58101
// SetTag ( i , 0 ) ;
58089: LD_VAR 0 4
58093: PPUSH
58094: LD_INT 0
58096: PPUSH
58097: CALL_OW 109
58101: GO 58069
58103: POP
58104: POP
// end ;
58105: LD_VAR 0 3
58109: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
58110: LD_INT 0
58112: PPUSH
58113: PPUSH
58114: PPUSH
58115: PPUSH
58116: PPUSH
58117: PPUSH
58118: PPUSH
58119: PPUSH
// if not mc_bases then
58120: LD_EXP 69
58124: NOT
58125: IFFALSE 58129
// exit ;
58127: GO 58587
// for i = 1 to mc_bases do
58129: LD_ADDR_VAR 0 2
58133: PUSH
58134: DOUBLE
58135: LD_INT 1
58137: DEC
58138: ST_TO_ADDR
58139: LD_EXP 69
58143: PUSH
58144: FOR_TO
58145: IFFALSE 58585
// begin tmp := MC_ClassCheckReq ( i ) ;
58147: LD_ADDR_VAR 0 4
58151: PUSH
58152: LD_VAR 0 2
58156: PPUSH
58157: CALL 58592 0 1
58161: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
58162: LD_ADDR_EXP 110
58166: PUSH
58167: LD_EXP 110
58171: PPUSH
58172: LD_VAR 0 2
58176: PPUSH
58177: LD_VAR 0 4
58181: PPUSH
58182: CALL_OW 1
58186: ST_TO_ADDR
// if not tmp then
58187: LD_VAR 0 4
58191: NOT
58192: IFFALSE 58196
// continue ;
58194: GO 58144
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
58196: LD_ADDR_VAR 0 6
58200: PUSH
58201: LD_EXP 69
58205: PUSH
58206: LD_VAR 0 2
58210: ARRAY
58211: PPUSH
58212: LD_INT 2
58214: PUSH
58215: LD_INT 30
58217: PUSH
58218: LD_INT 4
58220: PUSH
58221: EMPTY
58222: LIST
58223: LIST
58224: PUSH
58225: LD_INT 30
58227: PUSH
58228: LD_INT 5
58230: PUSH
58231: EMPTY
58232: LIST
58233: LIST
58234: PUSH
58235: EMPTY
58236: LIST
58237: LIST
58238: LIST
58239: PPUSH
58240: CALL_OW 72
58244: PUSH
58245: LD_EXP 69
58249: PUSH
58250: LD_VAR 0 2
58254: ARRAY
58255: PPUSH
58256: LD_INT 2
58258: PUSH
58259: LD_INT 30
58261: PUSH
58262: LD_INT 0
58264: PUSH
58265: EMPTY
58266: LIST
58267: LIST
58268: PUSH
58269: LD_INT 30
58271: PUSH
58272: LD_INT 1
58274: PUSH
58275: EMPTY
58276: LIST
58277: LIST
58278: PUSH
58279: EMPTY
58280: LIST
58281: LIST
58282: LIST
58283: PPUSH
58284: CALL_OW 72
58288: PUSH
58289: LD_EXP 69
58293: PUSH
58294: LD_VAR 0 2
58298: ARRAY
58299: PPUSH
58300: LD_INT 30
58302: PUSH
58303: LD_INT 3
58305: PUSH
58306: EMPTY
58307: LIST
58308: LIST
58309: PPUSH
58310: CALL_OW 72
58314: PUSH
58315: LD_EXP 69
58319: PUSH
58320: LD_VAR 0 2
58324: ARRAY
58325: PPUSH
58326: LD_INT 2
58328: PUSH
58329: LD_INT 30
58331: PUSH
58332: LD_INT 6
58334: PUSH
58335: EMPTY
58336: LIST
58337: LIST
58338: PUSH
58339: LD_INT 30
58341: PUSH
58342: LD_INT 7
58344: PUSH
58345: EMPTY
58346: LIST
58347: LIST
58348: PUSH
58349: LD_INT 30
58351: PUSH
58352: LD_INT 8
58354: PUSH
58355: EMPTY
58356: LIST
58357: LIST
58358: PUSH
58359: EMPTY
58360: LIST
58361: LIST
58362: LIST
58363: LIST
58364: PPUSH
58365: CALL_OW 72
58369: PUSH
58370: EMPTY
58371: LIST
58372: LIST
58373: LIST
58374: LIST
58375: ST_TO_ADDR
// for j = 1 to 4 do
58376: LD_ADDR_VAR 0 3
58380: PUSH
58381: DOUBLE
58382: LD_INT 1
58384: DEC
58385: ST_TO_ADDR
58386: LD_INT 4
58388: PUSH
58389: FOR_TO
58390: IFFALSE 58581
// begin if not tmp [ j ] then
58392: LD_VAR 0 4
58396: PUSH
58397: LD_VAR 0 3
58401: ARRAY
58402: NOT
58403: IFFALSE 58407
// continue ;
58405: GO 58389
// for p in tmp [ j ] do
58407: LD_ADDR_VAR 0 5
58411: PUSH
58412: LD_VAR 0 4
58416: PUSH
58417: LD_VAR 0 3
58421: ARRAY
58422: PUSH
58423: FOR_IN
58424: IFFALSE 58577
// begin if not b [ j ] then
58426: LD_VAR 0 6
58430: PUSH
58431: LD_VAR 0 3
58435: ARRAY
58436: NOT
58437: IFFALSE 58441
// break ;
58439: GO 58577
// e := 0 ;
58441: LD_ADDR_VAR 0 7
58445: PUSH
58446: LD_INT 0
58448: ST_TO_ADDR
// for k in b [ j ] do
58449: LD_ADDR_VAR 0 8
58453: PUSH
58454: LD_VAR 0 6
58458: PUSH
58459: LD_VAR 0 3
58463: ARRAY
58464: PUSH
58465: FOR_IN
58466: IFFALSE 58493
// if IsNotFull ( k ) then
58468: LD_VAR 0 8
58472: PPUSH
58473: CALL 15818 0 1
58477: IFFALSE 58491
// begin e := k ;
58479: LD_ADDR_VAR 0 7
58483: PUSH
58484: LD_VAR 0 8
58488: ST_TO_ADDR
// break ;
58489: GO 58493
// end ;
58491: GO 58465
58493: POP
58494: POP
// if e and not UnitGoingToBuilding ( p , e ) then
58495: LD_VAR 0 7
58499: PUSH
58500: LD_VAR 0 5
58504: PPUSH
58505: LD_VAR 0 7
58509: PPUSH
58510: CALL 48982 0 2
58514: NOT
58515: AND
58516: IFFALSE 58575
// begin if IsInUnit ( p ) then
58518: LD_VAR 0 5
58522: PPUSH
58523: CALL_OW 310
58527: IFFALSE 58538
// ComExitBuilding ( p ) ;
58529: LD_VAR 0 5
58533: PPUSH
58534: CALL_OW 122
// ComEnterUnit ( p , e ) ;
58538: LD_VAR 0 5
58542: PPUSH
58543: LD_VAR 0 7
58547: PPUSH
58548: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
58552: LD_VAR 0 5
58556: PPUSH
58557: LD_VAR 0 3
58561: PPUSH
58562: CALL_OW 183
// AddComExitBuilding ( p ) ;
58566: LD_VAR 0 5
58570: PPUSH
58571: CALL_OW 182
// end ; end ;
58575: GO 58423
58577: POP
58578: POP
// end ;
58579: GO 58389
58581: POP
58582: POP
// end ;
58583: GO 58144
58585: POP
58586: POP
// end ;
58587: LD_VAR 0 1
58591: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
58592: LD_INT 0
58594: PPUSH
58595: PPUSH
58596: PPUSH
58597: PPUSH
58598: PPUSH
58599: PPUSH
58600: PPUSH
58601: PPUSH
58602: PPUSH
58603: PPUSH
58604: PPUSH
58605: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
58606: LD_VAR 0 1
58610: NOT
58611: PUSH
58612: LD_EXP 69
58616: PUSH
58617: LD_VAR 0 1
58621: ARRAY
58622: NOT
58623: OR
58624: PUSH
58625: LD_EXP 69
58629: PUSH
58630: LD_VAR 0 1
58634: ARRAY
58635: PPUSH
58636: LD_INT 2
58638: PUSH
58639: LD_INT 30
58641: PUSH
58642: LD_INT 0
58644: PUSH
58645: EMPTY
58646: LIST
58647: LIST
58648: PUSH
58649: LD_INT 30
58651: PUSH
58652: LD_INT 1
58654: PUSH
58655: EMPTY
58656: LIST
58657: LIST
58658: PUSH
58659: EMPTY
58660: LIST
58661: LIST
58662: LIST
58663: PPUSH
58664: CALL_OW 72
58668: NOT
58669: OR
58670: IFFALSE 58674
// exit ;
58672: GO 62177
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58674: LD_ADDR_VAR 0 4
58678: PUSH
58679: LD_EXP 69
58683: PUSH
58684: LD_VAR 0 1
58688: ARRAY
58689: PPUSH
58690: LD_INT 2
58692: PUSH
58693: LD_INT 25
58695: PUSH
58696: LD_INT 1
58698: PUSH
58699: EMPTY
58700: LIST
58701: LIST
58702: PUSH
58703: LD_INT 25
58705: PUSH
58706: LD_INT 2
58708: PUSH
58709: EMPTY
58710: LIST
58711: LIST
58712: PUSH
58713: LD_INT 25
58715: PUSH
58716: LD_INT 3
58718: PUSH
58719: EMPTY
58720: LIST
58721: LIST
58722: PUSH
58723: LD_INT 25
58725: PUSH
58726: LD_INT 4
58728: PUSH
58729: EMPTY
58730: LIST
58731: LIST
58732: PUSH
58733: LD_INT 25
58735: PUSH
58736: LD_INT 5
58738: PUSH
58739: EMPTY
58740: LIST
58741: LIST
58742: PUSH
58743: LD_INT 25
58745: PUSH
58746: LD_INT 8
58748: PUSH
58749: EMPTY
58750: LIST
58751: LIST
58752: PUSH
58753: LD_INT 25
58755: PUSH
58756: LD_INT 9
58758: PUSH
58759: EMPTY
58760: LIST
58761: LIST
58762: PUSH
58763: EMPTY
58764: LIST
58765: LIST
58766: LIST
58767: LIST
58768: LIST
58769: LIST
58770: LIST
58771: LIST
58772: PPUSH
58773: CALL_OW 72
58777: ST_TO_ADDR
// if not tmp then
58778: LD_VAR 0 4
58782: NOT
58783: IFFALSE 58787
// exit ;
58785: GO 62177
// for i in tmp do
58787: LD_ADDR_VAR 0 3
58791: PUSH
58792: LD_VAR 0 4
58796: PUSH
58797: FOR_IN
58798: IFFALSE 58829
// if GetTag ( i ) then
58800: LD_VAR 0 3
58804: PPUSH
58805: CALL_OW 110
58809: IFFALSE 58827
// tmp := tmp diff i ;
58811: LD_ADDR_VAR 0 4
58815: PUSH
58816: LD_VAR 0 4
58820: PUSH
58821: LD_VAR 0 3
58825: DIFF
58826: ST_TO_ADDR
58827: GO 58797
58829: POP
58830: POP
// if not tmp then
58831: LD_VAR 0 4
58835: NOT
58836: IFFALSE 58840
// exit ;
58838: GO 62177
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58840: LD_ADDR_VAR 0 5
58844: PUSH
58845: LD_EXP 69
58849: PUSH
58850: LD_VAR 0 1
58854: ARRAY
58855: PPUSH
58856: LD_INT 2
58858: PUSH
58859: LD_INT 25
58861: PUSH
58862: LD_INT 1
58864: PUSH
58865: EMPTY
58866: LIST
58867: LIST
58868: PUSH
58869: LD_INT 25
58871: PUSH
58872: LD_INT 5
58874: PUSH
58875: EMPTY
58876: LIST
58877: LIST
58878: PUSH
58879: LD_INT 25
58881: PUSH
58882: LD_INT 8
58884: PUSH
58885: EMPTY
58886: LIST
58887: LIST
58888: PUSH
58889: LD_INT 25
58891: PUSH
58892: LD_INT 9
58894: PUSH
58895: EMPTY
58896: LIST
58897: LIST
58898: PUSH
58899: EMPTY
58900: LIST
58901: LIST
58902: LIST
58903: LIST
58904: LIST
58905: PPUSH
58906: CALL_OW 72
58910: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
58911: LD_ADDR_VAR 0 6
58915: PUSH
58916: LD_EXP 69
58920: PUSH
58921: LD_VAR 0 1
58925: ARRAY
58926: PPUSH
58927: LD_INT 25
58929: PUSH
58930: LD_INT 2
58932: PUSH
58933: EMPTY
58934: LIST
58935: LIST
58936: PPUSH
58937: CALL_OW 72
58941: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
58942: LD_ADDR_VAR 0 7
58946: PUSH
58947: LD_EXP 69
58951: PUSH
58952: LD_VAR 0 1
58956: ARRAY
58957: PPUSH
58958: LD_INT 25
58960: PUSH
58961: LD_INT 3
58963: PUSH
58964: EMPTY
58965: LIST
58966: LIST
58967: PPUSH
58968: CALL_OW 72
58972: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
58973: LD_ADDR_VAR 0 8
58977: PUSH
58978: LD_EXP 69
58982: PUSH
58983: LD_VAR 0 1
58987: ARRAY
58988: PPUSH
58989: LD_INT 25
58991: PUSH
58992: LD_INT 4
58994: PUSH
58995: EMPTY
58996: LIST
58997: LIST
58998: PUSH
58999: LD_INT 24
59001: PUSH
59002: LD_INT 251
59004: PUSH
59005: EMPTY
59006: LIST
59007: LIST
59008: PUSH
59009: EMPTY
59010: LIST
59011: LIST
59012: PPUSH
59013: CALL_OW 72
59017: ST_TO_ADDR
// if mc_is_defending [ base ] then
59018: LD_EXP 112
59022: PUSH
59023: LD_VAR 0 1
59027: ARRAY
59028: IFFALSE 59489
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
59030: LD_ADDR_EXP 111
59034: PUSH
59035: LD_EXP 111
59039: PPUSH
59040: LD_VAR 0 1
59044: PPUSH
59045: LD_INT 4
59047: PPUSH
59048: CALL_OW 1
59052: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59053: LD_ADDR_VAR 0 12
59057: PUSH
59058: LD_EXP 69
59062: PUSH
59063: LD_VAR 0 1
59067: ARRAY
59068: PPUSH
59069: LD_INT 2
59071: PUSH
59072: LD_INT 30
59074: PUSH
59075: LD_INT 4
59077: PUSH
59078: EMPTY
59079: LIST
59080: LIST
59081: PUSH
59082: LD_INT 30
59084: PUSH
59085: LD_INT 5
59087: PUSH
59088: EMPTY
59089: LIST
59090: LIST
59091: PUSH
59092: EMPTY
59093: LIST
59094: LIST
59095: LIST
59096: PPUSH
59097: CALL_OW 72
59101: ST_TO_ADDR
// if not b then
59102: LD_VAR 0 12
59106: NOT
59107: IFFALSE 59111
// exit ;
59109: GO 62177
// p := [ ] ;
59111: LD_ADDR_VAR 0 11
59115: PUSH
59116: EMPTY
59117: ST_TO_ADDR
// if sci >= 2 then
59118: LD_VAR 0 8
59122: PUSH
59123: LD_INT 2
59125: GREATEREQUAL
59126: IFFALSE 59157
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
59128: LD_ADDR_VAR 0 8
59132: PUSH
59133: LD_VAR 0 8
59137: PUSH
59138: LD_INT 1
59140: ARRAY
59141: PUSH
59142: LD_VAR 0 8
59146: PUSH
59147: LD_INT 2
59149: ARRAY
59150: PUSH
59151: EMPTY
59152: LIST
59153: LIST
59154: ST_TO_ADDR
59155: GO 59218
// if sci = 1 then
59157: LD_VAR 0 8
59161: PUSH
59162: LD_INT 1
59164: EQUAL
59165: IFFALSE 59186
// sci := [ sci [ 1 ] ] else
59167: LD_ADDR_VAR 0 8
59171: PUSH
59172: LD_VAR 0 8
59176: PUSH
59177: LD_INT 1
59179: ARRAY
59180: PUSH
59181: EMPTY
59182: LIST
59183: ST_TO_ADDR
59184: GO 59218
// if sci = 0 then
59186: LD_VAR 0 8
59190: PUSH
59191: LD_INT 0
59193: EQUAL
59194: IFFALSE 59218
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
59196: LD_ADDR_VAR 0 11
59200: PUSH
59201: LD_VAR 0 4
59205: PPUSH
59206: LD_INT 4
59208: PPUSH
59209: CALL 48845 0 2
59213: PUSH
59214: LD_INT 1
59216: ARRAY
59217: ST_TO_ADDR
// if eng > 4 then
59218: LD_VAR 0 6
59222: PUSH
59223: LD_INT 4
59225: GREATER
59226: IFFALSE 59272
// for i = eng downto 4 do
59228: LD_ADDR_VAR 0 3
59232: PUSH
59233: DOUBLE
59234: LD_VAR 0 6
59238: INC
59239: ST_TO_ADDR
59240: LD_INT 4
59242: PUSH
59243: FOR_DOWNTO
59244: IFFALSE 59270
// eng := eng diff eng [ i ] ;
59246: LD_ADDR_VAR 0 6
59250: PUSH
59251: LD_VAR 0 6
59255: PUSH
59256: LD_VAR 0 6
59260: PUSH
59261: LD_VAR 0 3
59265: ARRAY
59266: DIFF
59267: ST_TO_ADDR
59268: GO 59243
59270: POP
59271: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
59272: LD_ADDR_VAR 0 4
59276: PUSH
59277: LD_VAR 0 4
59281: PUSH
59282: LD_VAR 0 5
59286: PUSH
59287: LD_VAR 0 6
59291: UNION
59292: PUSH
59293: LD_VAR 0 7
59297: UNION
59298: PUSH
59299: LD_VAR 0 8
59303: UNION
59304: DIFF
59305: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
59306: LD_ADDR_VAR 0 13
59310: PUSH
59311: LD_EXP 69
59315: PUSH
59316: LD_VAR 0 1
59320: ARRAY
59321: PPUSH
59322: LD_INT 2
59324: PUSH
59325: LD_INT 30
59327: PUSH
59328: LD_INT 32
59330: PUSH
59331: EMPTY
59332: LIST
59333: LIST
59334: PUSH
59335: LD_INT 30
59337: PUSH
59338: LD_INT 31
59340: PUSH
59341: EMPTY
59342: LIST
59343: LIST
59344: PUSH
59345: EMPTY
59346: LIST
59347: LIST
59348: LIST
59349: PPUSH
59350: CALL_OW 72
59354: PUSH
59355: LD_EXP 69
59359: PUSH
59360: LD_VAR 0 1
59364: ARRAY
59365: PPUSH
59366: LD_INT 2
59368: PUSH
59369: LD_INT 30
59371: PUSH
59372: LD_INT 4
59374: PUSH
59375: EMPTY
59376: LIST
59377: LIST
59378: PUSH
59379: LD_INT 30
59381: PUSH
59382: LD_INT 5
59384: PUSH
59385: EMPTY
59386: LIST
59387: LIST
59388: PUSH
59389: EMPTY
59390: LIST
59391: LIST
59392: LIST
59393: PPUSH
59394: CALL_OW 72
59398: PUSH
59399: LD_INT 6
59401: MUL
59402: PLUS
59403: ST_TO_ADDR
// if bcount < tmp then
59404: LD_VAR 0 13
59408: PUSH
59409: LD_VAR 0 4
59413: LESS
59414: IFFALSE 59460
// for i = tmp downto bcount do
59416: LD_ADDR_VAR 0 3
59420: PUSH
59421: DOUBLE
59422: LD_VAR 0 4
59426: INC
59427: ST_TO_ADDR
59428: LD_VAR 0 13
59432: PUSH
59433: FOR_DOWNTO
59434: IFFALSE 59458
// tmp := Delete ( tmp , tmp ) ;
59436: LD_ADDR_VAR 0 4
59440: PUSH
59441: LD_VAR 0 4
59445: PPUSH
59446: LD_VAR 0 4
59450: PPUSH
59451: CALL_OW 3
59455: ST_TO_ADDR
59456: GO 59433
59458: POP
59459: POP
// result := [ tmp , 0 , 0 , p ] ;
59460: LD_ADDR_VAR 0 2
59464: PUSH
59465: LD_VAR 0 4
59469: PUSH
59470: LD_INT 0
59472: PUSH
59473: LD_INT 0
59475: PUSH
59476: LD_VAR 0 11
59480: PUSH
59481: EMPTY
59482: LIST
59483: LIST
59484: LIST
59485: LIST
59486: ST_TO_ADDR
// exit ;
59487: GO 62177
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59489: LD_EXP 69
59493: PUSH
59494: LD_VAR 0 1
59498: ARRAY
59499: PPUSH
59500: LD_INT 2
59502: PUSH
59503: LD_INT 30
59505: PUSH
59506: LD_INT 6
59508: PUSH
59509: EMPTY
59510: LIST
59511: LIST
59512: PUSH
59513: LD_INT 30
59515: PUSH
59516: LD_INT 7
59518: PUSH
59519: EMPTY
59520: LIST
59521: LIST
59522: PUSH
59523: LD_INT 30
59525: PUSH
59526: LD_INT 8
59528: PUSH
59529: EMPTY
59530: LIST
59531: LIST
59532: PUSH
59533: EMPTY
59534: LIST
59535: LIST
59536: LIST
59537: LIST
59538: PPUSH
59539: CALL_OW 72
59543: NOT
59544: PUSH
59545: LD_EXP 69
59549: PUSH
59550: LD_VAR 0 1
59554: ARRAY
59555: PPUSH
59556: LD_INT 30
59558: PUSH
59559: LD_INT 3
59561: PUSH
59562: EMPTY
59563: LIST
59564: LIST
59565: PPUSH
59566: CALL_OW 72
59570: NOT
59571: AND
59572: IFFALSE 59644
// begin if eng = tmp then
59574: LD_VAR 0 6
59578: PUSH
59579: LD_VAR 0 4
59583: EQUAL
59584: IFFALSE 59588
// exit ;
59586: GO 62177
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
59588: LD_ADDR_EXP 111
59592: PUSH
59593: LD_EXP 111
59597: PPUSH
59598: LD_VAR 0 1
59602: PPUSH
59603: LD_INT 1
59605: PPUSH
59606: CALL_OW 1
59610: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
59611: LD_ADDR_VAR 0 2
59615: PUSH
59616: LD_INT 0
59618: PUSH
59619: LD_VAR 0 4
59623: PUSH
59624: LD_VAR 0 6
59628: DIFF
59629: PUSH
59630: LD_INT 0
59632: PUSH
59633: LD_INT 0
59635: PUSH
59636: EMPTY
59637: LIST
59638: LIST
59639: LIST
59640: LIST
59641: ST_TO_ADDR
// exit ;
59642: GO 62177
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59644: LD_EXP 96
59648: PUSH
59649: LD_EXP 95
59653: PUSH
59654: LD_VAR 0 1
59658: ARRAY
59659: ARRAY
59660: PUSH
59661: LD_EXP 69
59665: PUSH
59666: LD_VAR 0 1
59670: ARRAY
59671: PPUSH
59672: LD_INT 2
59674: PUSH
59675: LD_INT 30
59677: PUSH
59678: LD_INT 6
59680: PUSH
59681: EMPTY
59682: LIST
59683: LIST
59684: PUSH
59685: LD_INT 30
59687: PUSH
59688: LD_INT 7
59690: PUSH
59691: EMPTY
59692: LIST
59693: LIST
59694: PUSH
59695: LD_INT 30
59697: PUSH
59698: LD_INT 8
59700: PUSH
59701: EMPTY
59702: LIST
59703: LIST
59704: PUSH
59705: EMPTY
59706: LIST
59707: LIST
59708: LIST
59709: LIST
59710: PPUSH
59711: CALL_OW 72
59715: AND
59716: PUSH
59717: LD_EXP 69
59721: PUSH
59722: LD_VAR 0 1
59726: ARRAY
59727: PPUSH
59728: LD_INT 30
59730: PUSH
59731: LD_INT 3
59733: PUSH
59734: EMPTY
59735: LIST
59736: LIST
59737: PPUSH
59738: CALL_OW 72
59742: NOT
59743: AND
59744: IFFALSE 59958
// begin if sci >= 6 then
59746: LD_VAR 0 8
59750: PUSH
59751: LD_INT 6
59753: GREATEREQUAL
59754: IFFALSE 59758
// exit ;
59756: GO 62177
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
59758: LD_ADDR_EXP 111
59762: PUSH
59763: LD_EXP 111
59767: PPUSH
59768: LD_VAR 0 1
59772: PPUSH
59773: LD_INT 2
59775: PPUSH
59776: CALL_OW 1
59780: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
59781: LD_ADDR_VAR 0 9
59785: PUSH
59786: LD_VAR 0 4
59790: PUSH
59791: LD_VAR 0 8
59795: DIFF
59796: PPUSH
59797: LD_INT 4
59799: PPUSH
59800: CALL 48845 0 2
59804: ST_TO_ADDR
// p := [ ] ;
59805: LD_ADDR_VAR 0 11
59809: PUSH
59810: EMPTY
59811: ST_TO_ADDR
// if sci < 6 and sort > 6 then
59812: LD_VAR 0 8
59816: PUSH
59817: LD_INT 6
59819: LESS
59820: PUSH
59821: LD_VAR 0 9
59825: PUSH
59826: LD_INT 6
59828: GREATER
59829: AND
59830: IFFALSE 59911
// begin for i = 1 to 6 - sci do
59832: LD_ADDR_VAR 0 3
59836: PUSH
59837: DOUBLE
59838: LD_INT 1
59840: DEC
59841: ST_TO_ADDR
59842: LD_INT 6
59844: PUSH
59845: LD_VAR 0 8
59849: MINUS
59850: PUSH
59851: FOR_TO
59852: IFFALSE 59907
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
59854: LD_ADDR_VAR 0 11
59858: PUSH
59859: LD_VAR 0 11
59863: PPUSH
59864: LD_VAR 0 11
59868: PUSH
59869: LD_INT 1
59871: PLUS
59872: PPUSH
59873: LD_VAR 0 9
59877: PUSH
59878: LD_INT 1
59880: ARRAY
59881: PPUSH
59882: CALL_OW 2
59886: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
59887: LD_ADDR_VAR 0 9
59891: PUSH
59892: LD_VAR 0 9
59896: PPUSH
59897: LD_INT 1
59899: PPUSH
59900: CALL_OW 3
59904: ST_TO_ADDR
// end ;
59905: GO 59851
59907: POP
59908: POP
// end else
59909: GO 59931
// if sort then
59911: LD_VAR 0 9
59915: IFFALSE 59931
// p := sort [ 1 ] ;
59917: LD_ADDR_VAR 0 11
59921: PUSH
59922: LD_VAR 0 9
59926: PUSH
59927: LD_INT 1
59929: ARRAY
59930: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
59931: LD_ADDR_VAR 0 2
59935: PUSH
59936: LD_INT 0
59938: PUSH
59939: LD_INT 0
59941: PUSH
59942: LD_INT 0
59944: PUSH
59945: LD_VAR 0 11
59949: PUSH
59950: EMPTY
59951: LIST
59952: LIST
59953: LIST
59954: LIST
59955: ST_TO_ADDR
// exit ;
59956: GO 62177
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59958: LD_EXP 96
59962: PUSH
59963: LD_EXP 95
59967: PUSH
59968: LD_VAR 0 1
59972: ARRAY
59973: ARRAY
59974: PUSH
59975: LD_EXP 69
59979: PUSH
59980: LD_VAR 0 1
59984: ARRAY
59985: PPUSH
59986: LD_INT 2
59988: PUSH
59989: LD_INT 30
59991: PUSH
59992: LD_INT 6
59994: PUSH
59995: EMPTY
59996: LIST
59997: LIST
59998: PUSH
59999: LD_INT 30
60001: PUSH
60002: LD_INT 7
60004: PUSH
60005: EMPTY
60006: LIST
60007: LIST
60008: PUSH
60009: LD_INT 30
60011: PUSH
60012: LD_INT 8
60014: PUSH
60015: EMPTY
60016: LIST
60017: LIST
60018: PUSH
60019: EMPTY
60020: LIST
60021: LIST
60022: LIST
60023: LIST
60024: PPUSH
60025: CALL_OW 72
60029: AND
60030: PUSH
60031: LD_EXP 69
60035: PUSH
60036: LD_VAR 0 1
60040: ARRAY
60041: PPUSH
60042: LD_INT 30
60044: PUSH
60045: LD_INT 3
60047: PUSH
60048: EMPTY
60049: LIST
60050: LIST
60051: PPUSH
60052: CALL_OW 72
60056: AND
60057: IFFALSE 60791
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
60059: LD_ADDR_EXP 111
60063: PUSH
60064: LD_EXP 111
60068: PPUSH
60069: LD_VAR 0 1
60073: PPUSH
60074: LD_INT 3
60076: PPUSH
60077: CALL_OW 1
60081: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60082: LD_ADDR_VAR 0 2
60086: PUSH
60087: LD_INT 0
60089: PUSH
60090: LD_INT 0
60092: PUSH
60093: LD_INT 0
60095: PUSH
60096: LD_INT 0
60098: PUSH
60099: EMPTY
60100: LIST
60101: LIST
60102: LIST
60103: LIST
60104: ST_TO_ADDR
// if not eng then
60105: LD_VAR 0 6
60109: NOT
60110: IFFALSE 60173
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
60112: LD_ADDR_VAR 0 11
60116: PUSH
60117: LD_VAR 0 4
60121: PPUSH
60122: LD_INT 2
60124: PPUSH
60125: CALL 48845 0 2
60129: PUSH
60130: LD_INT 1
60132: ARRAY
60133: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
60134: LD_ADDR_VAR 0 2
60138: PUSH
60139: LD_VAR 0 2
60143: PPUSH
60144: LD_INT 2
60146: PPUSH
60147: LD_VAR 0 11
60151: PPUSH
60152: CALL_OW 1
60156: ST_TO_ADDR
// tmp := tmp diff p ;
60157: LD_ADDR_VAR 0 4
60161: PUSH
60162: LD_VAR 0 4
60166: PUSH
60167: LD_VAR 0 11
60171: DIFF
60172: ST_TO_ADDR
// end ; if tmp and sci < 6 then
60173: LD_VAR 0 4
60177: PUSH
60178: LD_VAR 0 8
60182: PUSH
60183: LD_INT 6
60185: LESS
60186: AND
60187: IFFALSE 60375
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
60189: LD_ADDR_VAR 0 9
60193: PUSH
60194: LD_VAR 0 4
60198: PUSH
60199: LD_VAR 0 8
60203: PUSH
60204: LD_VAR 0 7
60208: UNION
60209: DIFF
60210: PPUSH
60211: LD_INT 4
60213: PPUSH
60214: CALL 48845 0 2
60218: ST_TO_ADDR
// p := [ ] ;
60219: LD_ADDR_VAR 0 11
60223: PUSH
60224: EMPTY
60225: ST_TO_ADDR
// if sort then
60226: LD_VAR 0 9
60230: IFFALSE 60346
// for i = 1 to 6 - sci do
60232: LD_ADDR_VAR 0 3
60236: PUSH
60237: DOUBLE
60238: LD_INT 1
60240: DEC
60241: ST_TO_ADDR
60242: LD_INT 6
60244: PUSH
60245: LD_VAR 0 8
60249: MINUS
60250: PUSH
60251: FOR_TO
60252: IFFALSE 60344
// begin if i = sort then
60254: LD_VAR 0 3
60258: PUSH
60259: LD_VAR 0 9
60263: EQUAL
60264: IFFALSE 60268
// break ;
60266: GO 60344
// if GetClass ( i ) = 4 then
60268: LD_VAR 0 3
60272: PPUSH
60273: CALL_OW 257
60277: PUSH
60278: LD_INT 4
60280: EQUAL
60281: IFFALSE 60285
// continue ;
60283: GO 60251
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60285: LD_ADDR_VAR 0 11
60289: PUSH
60290: LD_VAR 0 11
60294: PPUSH
60295: LD_VAR 0 11
60299: PUSH
60300: LD_INT 1
60302: PLUS
60303: PPUSH
60304: LD_VAR 0 9
60308: PUSH
60309: LD_VAR 0 3
60313: ARRAY
60314: PPUSH
60315: CALL_OW 2
60319: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60320: LD_ADDR_VAR 0 4
60324: PUSH
60325: LD_VAR 0 4
60329: PUSH
60330: LD_VAR 0 9
60334: PUSH
60335: LD_VAR 0 3
60339: ARRAY
60340: DIFF
60341: ST_TO_ADDR
// end ;
60342: GO 60251
60344: POP
60345: POP
// if p then
60346: LD_VAR 0 11
60350: IFFALSE 60375
// result := Replace ( result , 4 , p ) ;
60352: LD_ADDR_VAR 0 2
60356: PUSH
60357: LD_VAR 0 2
60361: PPUSH
60362: LD_INT 4
60364: PPUSH
60365: LD_VAR 0 11
60369: PPUSH
60370: CALL_OW 1
60374: ST_TO_ADDR
// end ; if tmp and mech < 6 then
60375: LD_VAR 0 4
60379: PUSH
60380: LD_VAR 0 7
60384: PUSH
60385: LD_INT 6
60387: LESS
60388: AND
60389: IFFALSE 60577
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
60391: LD_ADDR_VAR 0 9
60395: PUSH
60396: LD_VAR 0 4
60400: PUSH
60401: LD_VAR 0 8
60405: PUSH
60406: LD_VAR 0 7
60410: UNION
60411: DIFF
60412: PPUSH
60413: LD_INT 3
60415: PPUSH
60416: CALL 48845 0 2
60420: ST_TO_ADDR
// p := [ ] ;
60421: LD_ADDR_VAR 0 11
60425: PUSH
60426: EMPTY
60427: ST_TO_ADDR
// if sort then
60428: LD_VAR 0 9
60432: IFFALSE 60548
// for i = 1 to 6 - mech do
60434: LD_ADDR_VAR 0 3
60438: PUSH
60439: DOUBLE
60440: LD_INT 1
60442: DEC
60443: ST_TO_ADDR
60444: LD_INT 6
60446: PUSH
60447: LD_VAR 0 7
60451: MINUS
60452: PUSH
60453: FOR_TO
60454: IFFALSE 60546
// begin if i = sort then
60456: LD_VAR 0 3
60460: PUSH
60461: LD_VAR 0 9
60465: EQUAL
60466: IFFALSE 60470
// break ;
60468: GO 60546
// if GetClass ( i ) = 3 then
60470: LD_VAR 0 3
60474: PPUSH
60475: CALL_OW 257
60479: PUSH
60480: LD_INT 3
60482: EQUAL
60483: IFFALSE 60487
// continue ;
60485: GO 60453
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60487: LD_ADDR_VAR 0 11
60491: PUSH
60492: LD_VAR 0 11
60496: PPUSH
60497: LD_VAR 0 11
60501: PUSH
60502: LD_INT 1
60504: PLUS
60505: PPUSH
60506: LD_VAR 0 9
60510: PUSH
60511: LD_VAR 0 3
60515: ARRAY
60516: PPUSH
60517: CALL_OW 2
60521: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60522: LD_ADDR_VAR 0 4
60526: PUSH
60527: LD_VAR 0 4
60531: PUSH
60532: LD_VAR 0 9
60536: PUSH
60537: LD_VAR 0 3
60541: ARRAY
60542: DIFF
60543: ST_TO_ADDR
// end ;
60544: GO 60453
60546: POP
60547: POP
// if p then
60548: LD_VAR 0 11
60552: IFFALSE 60577
// result := Replace ( result , 3 , p ) ;
60554: LD_ADDR_VAR 0 2
60558: PUSH
60559: LD_VAR 0 2
60563: PPUSH
60564: LD_INT 3
60566: PPUSH
60567: LD_VAR 0 11
60571: PPUSH
60572: CALL_OW 1
60576: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
60577: LD_VAR 0 4
60581: PUSH
60582: LD_INT 6
60584: GREATER
60585: PUSH
60586: LD_VAR 0 6
60590: PUSH
60591: LD_INT 6
60593: LESS
60594: AND
60595: IFFALSE 60789
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
60597: LD_ADDR_VAR 0 9
60601: PUSH
60602: LD_VAR 0 4
60606: PUSH
60607: LD_VAR 0 8
60611: PUSH
60612: LD_VAR 0 7
60616: UNION
60617: PUSH
60618: LD_VAR 0 6
60622: UNION
60623: DIFF
60624: PPUSH
60625: LD_INT 2
60627: PPUSH
60628: CALL 48845 0 2
60632: ST_TO_ADDR
// p := [ ] ;
60633: LD_ADDR_VAR 0 11
60637: PUSH
60638: EMPTY
60639: ST_TO_ADDR
// if sort then
60640: LD_VAR 0 9
60644: IFFALSE 60760
// for i = 1 to 6 - eng do
60646: LD_ADDR_VAR 0 3
60650: PUSH
60651: DOUBLE
60652: LD_INT 1
60654: DEC
60655: ST_TO_ADDR
60656: LD_INT 6
60658: PUSH
60659: LD_VAR 0 6
60663: MINUS
60664: PUSH
60665: FOR_TO
60666: IFFALSE 60758
// begin if i = sort then
60668: LD_VAR 0 3
60672: PUSH
60673: LD_VAR 0 9
60677: EQUAL
60678: IFFALSE 60682
// break ;
60680: GO 60758
// if GetClass ( i ) = 2 then
60682: LD_VAR 0 3
60686: PPUSH
60687: CALL_OW 257
60691: PUSH
60692: LD_INT 2
60694: EQUAL
60695: IFFALSE 60699
// continue ;
60697: GO 60665
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60699: LD_ADDR_VAR 0 11
60703: PUSH
60704: LD_VAR 0 11
60708: PPUSH
60709: LD_VAR 0 11
60713: PUSH
60714: LD_INT 1
60716: PLUS
60717: PPUSH
60718: LD_VAR 0 9
60722: PUSH
60723: LD_VAR 0 3
60727: ARRAY
60728: PPUSH
60729: CALL_OW 2
60733: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60734: LD_ADDR_VAR 0 4
60738: PUSH
60739: LD_VAR 0 4
60743: PUSH
60744: LD_VAR 0 9
60748: PUSH
60749: LD_VAR 0 3
60753: ARRAY
60754: DIFF
60755: ST_TO_ADDR
// end ;
60756: GO 60665
60758: POP
60759: POP
// if p then
60760: LD_VAR 0 11
60764: IFFALSE 60789
// result := Replace ( result , 2 , p ) ;
60766: LD_ADDR_VAR 0 2
60770: PUSH
60771: LD_VAR 0 2
60775: PPUSH
60776: LD_INT 2
60778: PPUSH
60779: LD_VAR 0 11
60783: PPUSH
60784: CALL_OW 1
60788: ST_TO_ADDR
// end ; exit ;
60789: GO 62177
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
60791: LD_EXP 96
60795: PUSH
60796: LD_EXP 95
60800: PUSH
60801: LD_VAR 0 1
60805: ARRAY
60806: ARRAY
60807: NOT
60808: PUSH
60809: LD_EXP 69
60813: PUSH
60814: LD_VAR 0 1
60818: ARRAY
60819: PPUSH
60820: LD_INT 30
60822: PUSH
60823: LD_INT 3
60825: PUSH
60826: EMPTY
60827: LIST
60828: LIST
60829: PPUSH
60830: CALL_OW 72
60834: AND
60835: PUSH
60836: LD_EXP 74
60840: PUSH
60841: LD_VAR 0 1
60845: ARRAY
60846: AND
60847: IFFALSE 61455
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
60849: LD_ADDR_EXP 111
60853: PUSH
60854: LD_EXP 111
60858: PPUSH
60859: LD_VAR 0 1
60863: PPUSH
60864: LD_INT 5
60866: PPUSH
60867: CALL_OW 1
60871: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60872: LD_ADDR_VAR 0 2
60876: PUSH
60877: LD_INT 0
60879: PUSH
60880: LD_INT 0
60882: PUSH
60883: LD_INT 0
60885: PUSH
60886: LD_INT 0
60888: PUSH
60889: EMPTY
60890: LIST
60891: LIST
60892: LIST
60893: LIST
60894: ST_TO_ADDR
// if sci > 1 then
60895: LD_VAR 0 8
60899: PUSH
60900: LD_INT 1
60902: GREATER
60903: IFFALSE 60931
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
60905: LD_ADDR_VAR 0 4
60909: PUSH
60910: LD_VAR 0 4
60914: PUSH
60915: LD_VAR 0 8
60919: PUSH
60920: LD_VAR 0 8
60924: PUSH
60925: LD_INT 1
60927: ARRAY
60928: DIFF
60929: DIFF
60930: ST_TO_ADDR
// if tmp and not sci then
60931: LD_VAR 0 4
60935: PUSH
60936: LD_VAR 0 8
60940: NOT
60941: AND
60942: IFFALSE 61011
// begin sort := SortBySkill ( tmp , 4 ) ;
60944: LD_ADDR_VAR 0 9
60948: PUSH
60949: LD_VAR 0 4
60953: PPUSH
60954: LD_INT 4
60956: PPUSH
60957: CALL 48845 0 2
60961: ST_TO_ADDR
// if sort then
60962: LD_VAR 0 9
60966: IFFALSE 60982
// p := sort [ 1 ] ;
60968: LD_ADDR_VAR 0 11
60972: PUSH
60973: LD_VAR 0 9
60977: PUSH
60978: LD_INT 1
60980: ARRAY
60981: ST_TO_ADDR
// if p then
60982: LD_VAR 0 11
60986: IFFALSE 61011
// result := Replace ( result , 4 , p ) ;
60988: LD_ADDR_VAR 0 2
60992: PUSH
60993: LD_VAR 0 2
60997: PPUSH
60998: LD_INT 4
61000: PPUSH
61001: LD_VAR 0 11
61005: PPUSH
61006: CALL_OW 1
61010: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61011: LD_ADDR_VAR 0 4
61015: PUSH
61016: LD_VAR 0 4
61020: PUSH
61021: LD_VAR 0 7
61025: DIFF
61026: ST_TO_ADDR
// if tmp and mech < 6 then
61027: LD_VAR 0 4
61031: PUSH
61032: LD_VAR 0 7
61036: PUSH
61037: LD_INT 6
61039: LESS
61040: AND
61041: IFFALSE 61229
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61043: LD_ADDR_VAR 0 9
61047: PUSH
61048: LD_VAR 0 4
61052: PUSH
61053: LD_VAR 0 8
61057: PUSH
61058: LD_VAR 0 7
61062: UNION
61063: DIFF
61064: PPUSH
61065: LD_INT 3
61067: PPUSH
61068: CALL 48845 0 2
61072: ST_TO_ADDR
// p := [ ] ;
61073: LD_ADDR_VAR 0 11
61077: PUSH
61078: EMPTY
61079: ST_TO_ADDR
// if sort then
61080: LD_VAR 0 9
61084: IFFALSE 61200
// for i = 1 to 6 - mech do
61086: LD_ADDR_VAR 0 3
61090: PUSH
61091: DOUBLE
61092: LD_INT 1
61094: DEC
61095: ST_TO_ADDR
61096: LD_INT 6
61098: PUSH
61099: LD_VAR 0 7
61103: MINUS
61104: PUSH
61105: FOR_TO
61106: IFFALSE 61198
// begin if i = sort then
61108: LD_VAR 0 3
61112: PUSH
61113: LD_VAR 0 9
61117: EQUAL
61118: IFFALSE 61122
// break ;
61120: GO 61198
// if GetClass ( i ) = 3 then
61122: LD_VAR 0 3
61126: PPUSH
61127: CALL_OW 257
61131: PUSH
61132: LD_INT 3
61134: EQUAL
61135: IFFALSE 61139
// continue ;
61137: GO 61105
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61139: LD_ADDR_VAR 0 11
61143: PUSH
61144: LD_VAR 0 11
61148: PPUSH
61149: LD_VAR 0 11
61153: PUSH
61154: LD_INT 1
61156: PLUS
61157: PPUSH
61158: LD_VAR 0 9
61162: PUSH
61163: LD_VAR 0 3
61167: ARRAY
61168: PPUSH
61169: CALL_OW 2
61173: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61174: LD_ADDR_VAR 0 4
61178: PUSH
61179: LD_VAR 0 4
61183: PUSH
61184: LD_VAR 0 9
61188: PUSH
61189: LD_VAR 0 3
61193: ARRAY
61194: DIFF
61195: ST_TO_ADDR
// end ;
61196: GO 61105
61198: POP
61199: POP
// if p then
61200: LD_VAR 0 11
61204: IFFALSE 61229
// result := Replace ( result , 3 , p ) ;
61206: LD_ADDR_VAR 0 2
61210: PUSH
61211: LD_VAR 0 2
61215: PPUSH
61216: LD_INT 3
61218: PPUSH
61219: LD_VAR 0 11
61223: PPUSH
61224: CALL_OW 1
61228: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61229: LD_ADDR_VAR 0 4
61233: PUSH
61234: LD_VAR 0 4
61238: PUSH
61239: LD_VAR 0 6
61243: DIFF
61244: ST_TO_ADDR
// if tmp and eng < 6 then
61245: LD_VAR 0 4
61249: PUSH
61250: LD_VAR 0 6
61254: PUSH
61255: LD_INT 6
61257: LESS
61258: AND
61259: IFFALSE 61453
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61261: LD_ADDR_VAR 0 9
61265: PUSH
61266: LD_VAR 0 4
61270: PUSH
61271: LD_VAR 0 8
61275: PUSH
61276: LD_VAR 0 7
61280: UNION
61281: PUSH
61282: LD_VAR 0 6
61286: UNION
61287: DIFF
61288: PPUSH
61289: LD_INT 2
61291: PPUSH
61292: CALL 48845 0 2
61296: ST_TO_ADDR
// p := [ ] ;
61297: LD_ADDR_VAR 0 11
61301: PUSH
61302: EMPTY
61303: ST_TO_ADDR
// if sort then
61304: LD_VAR 0 9
61308: IFFALSE 61424
// for i = 1 to 6 - eng do
61310: LD_ADDR_VAR 0 3
61314: PUSH
61315: DOUBLE
61316: LD_INT 1
61318: DEC
61319: ST_TO_ADDR
61320: LD_INT 6
61322: PUSH
61323: LD_VAR 0 6
61327: MINUS
61328: PUSH
61329: FOR_TO
61330: IFFALSE 61422
// begin if i = sort then
61332: LD_VAR 0 3
61336: PUSH
61337: LD_VAR 0 9
61341: EQUAL
61342: IFFALSE 61346
// break ;
61344: GO 61422
// if GetClass ( i ) = 2 then
61346: LD_VAR 0 3
61350: PPUSH
61351: CALL_OW 257
61355: PUSH
61356: LD_INT 2
61358: EQUAL
61359: IFFALSE 61363
// continue ;
61361: GO 61329
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61363: LD_ADDR_VAR 0 11
61367: PUSH
61368: LD_VAR 0 11
61372: PPUSH
61373: LD_VAR 0 11
61377: PUSH
61378: LD_INT 1
61380: PLUS
61381: PPUSH
61382: LD_VAR 0 9
61386: PUSH
61387: LD_VAR 0 3
61391: ARRAY
61392: PPUSH
61393: CALL_OW 2
61397: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61398: LD_ADDR_VAR 0 4
61402: PUSH
61403: LD_VAR 0 4
61407: PUSH
61408: LD_VAR 0 9
61412: PUSH
61413: LD_VAR 0 3
61417: ARRAY
61418: DIFF
61419: ST_TO_ADDR
// end ;
61420: GO 61329
61422: POP
61423: POP
// if p then
61424: LD_VAR 0 11
61428: IFFALSE 61453
// result := Replace ( result , 2 , p ) ;
61430: LD_ADDR_VAR 0 2
61434: PUSH
61435: LD_VAR 0 2
61439: PPUSH
61440: LD_INT 2
61442: PPUSH
61443: LD_VAR 0 11
61447: PPUSH
61448: CALL_OW 1
61452: ST_TO_ADDR
// end ; exit ;
61453: GO 62177
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
61455: LD_EXP 96
61459: PUSH
61460: LD_EXP 95
61464: PUSH
61465: LD_VAR 0 1
61469: ARRAY
61470: ARRAY
61471: NOT
61472: PUSH
61473: LD_EXP 69
61477: PUSH
61478: LD_VAR 0 1
61482: ARRAY
61483: PPUSH
61484: LD_INT 30
61486: PUSH
61487: LD_INT 3
61489: PUSH
61490: EMPTY
61491: LIST
61492: LIST
61493: PPUSH
61494: CALL_OW 72
61498: AND
61499: PUSH
61500: LD_EXP 74
61504: PUSH
61505: LD_VAR 0 1
61509: ARRAY
61510: NOT
61511: AND
61512: IFFALSE 62177
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
61514: LD_ADDR_EXP 111
61518: PUSH
61519: LD_EXP 111
61523: PPUSH
61524: LD_VAR 0 1
61528: PPUSH
61529: LD_INT 6
61531: PPUSH
61532: CALL_OW 1
61536: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61537: LD_ADDR_VAR 0 2
61541: PUSH
61542: LD_INT 0
61544: PUSH
61545: LD_INT 0
61547: PUSH
61548: LD_INT 0
61550: PUSH
61551: LD_INT 0
61553: PUSH
61554: EMPTY
61555: LIST
61556: LIST
61557: LIST
61558: LIST
61559: ST_TO_ADDR
// if sci >= 1 then
61560: LD_VAR 0 8
61564: PUSH
61565: LD_INT 1
61567: GREATEREQUAL
61568: IFFALSE 61590
// tmp := tmp diff sci [ 1 ] ;
61570: LD_ADDR_VAR 0 4
61574: PUSH
61575: LD_VAR 0 4
61579: PUSH
61580: LD_VAR 0 8
61584: PUSH
61585: LD_INT 1
61587: ARRAY
61588: DIFF
61589: ST_TO_ADDR
// if tmp and not sci then
61590: LD_VAR 0 4
61594: PUSH
61595: LD_VAR 0 8
61599: NOT
61600: AND
61601: IFFALSE 61670
// begin sort := SortBySkill ( tmp , 4 ) ;
61603: LD_ADDR_VAR 0 9
61607: PUSH
61608: LD_VAR 0 4
61612: PPUSH
61613: LD_INT 4
61615: PPUSH
61616: CALL 48845 0 2
61620: ST_TO_ADDR
// if sort then
61621: LD_VAR 0 9
61625: IFFALSE 61641
// p := sort [ 1 ] ;
61627: LD_ADDR_VAR 0 11
61631: PUSH
61632: LD_VAR 0 9
61636: PUSH
61637: LD_INT 1
61639: ARRAY
61640: ST_TO_ADDR
// if p then
61641: LD_VAR 0 11
61645: IFFALSE 61670
// result := Replace ( result , 4 , p ) ;
61647: LD_ADDR_VAR 0 2
61651: PUSH
61652: LD_VAR 0 2
61656: PPUSH
61657: LD_INT 4
61659: PPUSH
61660: LD_VAR 0 11
61664: PPUSH
61665: CALL_OW 1
61669: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61670: LD_ADDR_VAR 0 4
61674: PUSH
61675: LD_VAR 0 4
61679: PUSH
61680: LD_VAR 0 7
61684: DIFF
61685: ST_TO_ADDR
// if tmp and mech < 6 then
61686: LD_VAR 0 4
61690: PUSH
61691: LD_VAR 0 7
61695: PUSH
61696: LD_INT 6
61698: LESS
61699: AND
61700: IFFALSE 61882
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
61702: LD_ADDR_VAR 0 9
61706: PUSH
61707: LD_VAR 0 4
61711: PUSH
61712: LD_VAR 0 7
61716: DIFF
61717: PPUSH
61718: LD_INT 3
61720: PPUSH
61721: CALL 48845 0 2
61725: ST_TO_ADDR
// p := [ ] ;
61726: LD_ADDR_VAR 0 11
61730: PUSH
61731: EMPTY
61732: ST_TO_ADDR
// if sort then
61733: LD_VAR 0 9
61737: IFFALSE 61853
// for i = 1 to 6 - mech do
61739: LD_ADDR_VAR 0 3
61743: PUSH
61744: DOUBLE
61745: LD_INT 1
61747: DEC
61748: ST_TO_ADDR
61749: LD_INT 6
61751: PUSH
61752: LD_VAR 0 7
61756: MINUS
61757: PUSH
61758: FOR_TO
61759: IFFALSE 61851
// begin if i = sort then
61761: LD_VAR 0 3
61765: PUSH
61766: LD_VAR 0 9
61770: EQUAL
61771: IFFALSE 61775
// break ;
61773: GO 61851
// if GetClass ( i ) = 3 then
61775: LD_VAR 0 3
61779: PPUSH
61780: CALL_OW 257
61784: PUSH
61785: LD_INT 3
61787: EQUAL
61788: IFFALSE 61792
// continue ;
61790: GO 61758
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61792: LD_ADDR_VAR 0 11
61796: PUSH
61797: LD_VAR 0 11
61801: PPUSH
61802: LD_VAR 0 11
61806: PUSH
61807: LD_INT 1
61809: PLUS
61810: PPUSH
61811: LD_VAR 0 9
61815: PUSH
61816: LD_VAR 0 3
61820: ARRAY
61821: PPUSH
61822: CALL_OW 2
61826: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61827: LD_ADDR_VAR 0 4
61831: PUSH
61832: LD_VAR 0 4
61836: PUSH
61837: LD_VAR 0 9
61841: PUSH
61842: LD_VAR 0 3
61846: ARRAY
61847: DIFF
61848: ST_TO_ADDR
// end ;
61849: GO 61758
61851: POP
61852: POP
// if p then
61853: LD_VAR 0 11
61857: IFFALSE 61882
// result := Replace ( result , 3 , p ) ;
61859: LD_ADDR_VAR 0 2
61863: PUSH
61864: LD_VAR 0 2
61868: PPUSH
61869: LD_INT 3
61871: PPUSH
61872: LD_VAR 0 11
61876: PPUSH
61877: CALL_OW 1
61881: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61882: LD_ADDR_VAR 0 4
61886: PUSH
61887: LD_VAR 0 4
61891: PUSH
61892: LD_VAR 0 6
61896: DIFF
61897: ST_TO_ADDR
// if tmp and eng < 4 then
61898: LD_VAR 0 4
61902: PUSH
61903: LD_VAR 0 6
61907: PUSH
61908: LD_INT 4
61910: LESS
61911: AND
61912: IFFALSE 62102
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
61914: LD_ADDR_VAR 0 9
61918: PUSH
61919: LD_VAR 0 4
61923: PUSH
61924: LD_VAR 0 7
61928: PUSH
61929: LD_VAR 0 6
61933: UNION
61934: DIFF
61935: PPUSH
61936: LD_INT 2
61938: PPUSH
61939: CALL 48845 0 2
61943: ST_TO_ADDR
// p := [ ] ;
61944: LD_ADDR_VAR 0 11
61948: PUSH
61949: EMPTY
61950: ST_TO_ADDR
// if sort then
61951: LD_VAR 0 9
61955: IFFALSE 62071
// for i = 1 to 4 - eng do
61957: LD_ADDR_VAR 0 3
61961: PUSH
61962: DOUBLE
61963: LD_INT 1
61965: DEC
61966: ST_TO_ADDR
61967: LD_INT 4
61969: PUSH
61970: LD_VAR 0 6
61974: MINUS
61975: PUSH
61976: FOR_TO
61977: IFFALSE 62069
// begin if i = sort then
61979: LD_VAR 0 3
61983: PUSH
61984: LD_VAR 0 9
61988: EQUAL
61989: IFFALSE 61993
// break ;
61991: GO 62069
// if GetClass ( i ) = 2 then
61993: LD_VAR 0 3
61997: PPUSH
61998: CALL_OW 257
62002: PUSH
62003: LD_INT 2
62005: EQUAL
62006: IFFALSE 62010
// continue ;
62008: GO 61976
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62010: LD_ADDR_VAR 0 11
62014: PUSH
62015: LD_VAR 0 11
62019: PPUSH
62020: LD_VAR 0 11
62024: PUSH
62025: LD_INT 1
62027: PLUS
62028: PPUSH
62029: LD_VAR 0 9
62033: PUSH
62034: LD_VAR 0 3
62038: ARRAY
62039: PPUSH
62040: CALL_OW 2
62044: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62045: LD_ADDR_VAR 0 4
62049: PUSH
62050: LD_VAR 0 4
62054: PUSH
62055: LD_VAR 0 9
62059: PUSH
62060: LD_VAR 0 3
62064: ARRAY
62065: DIFF
62066: ST_TO_ADDR
// end ;
62067: GO 61976
62069: POP
62070: POP
// if p then
62071: LD_VAR 0 11
62075: IFFALSE 62100
// result := Replace ( result , 2 , p ) ;
62077: LD_ADDR_VAR 0 2
62081: PUSH
62082: LD_VAR 0 2
62086: PPUSH
62087: LD_INT 2
62089: PPUSH
62090: LD_VAR 0 11
62094: PPUSH
62095: CALL_OW 1
62099: ST_TO_ADDR
// end else
62100: GO 62146
// for i = eng downto 5 do
62102: LD_ADDR_VAR 0 3
62106: PUSH
62107: DOUBLE
62108: LD_VAR 0 6
62112: INC
62113: ST_TO_ADDR
62114: LD_INT 5
62116: PUSH
62117: FOR_DOWNTO
62118: IFFALSE 62144
// tmp := tmp union eng [ i ] ;
62120: LD_ADDR_VAR 0 4
62124: PUSH
62125: LD_VAR 0 4
62129: PUSH
62130: LD_VAR 0 6
62134: PUSH
62135: LD_VAR 0 3
62139: ARRAY
62140: UNION
62141: ST_TO_ADDR
62142: GO 62117
62144: POP
62145: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
62146: LD_ADDR_VAR 0 2
62150: PUSH
62151: LD_VAR 0 2
62155: PPUSH
62156: LD_INT 1
62158: PPUSH
62159: LD_VAR 0 4
62163: PUSH
62164: LD_VAR 0 5
62168: DIFF
62169: PPUSH
62170: CALL_OW 1
62174: ST_TO_ADDR
// exit ;
62175: GO 62177
// end ; end ;
62177: LD_VAR 0 2
62181: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
62182: LD_INT 0
62184: PPUSH
62185: PPUSH
62186: PPUSH
// if not mc_bases then
62187: LD_EXP 69
62191: NOT
62192: IFFALSE 62196
// exit ;
62194: GO 62338
// for i = 1 to mc_bases do
62196: LD_ADDR_VAR 0 2
62200: PUSH
62201: DOUBLE
62202: LD_INT 1
62204: DEC
62205: ST_TO_ADDR
62206: LD_EXP 69
62210: PUSH
62211: FOR_TO
62212: IFFALSE 62329
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
62214: LD_ADDR_VAR 0 3
62218: PUSH
62219: LD_EXP 69
62223: PUSH
62224: LD_VAR 0 2
62228: ARRAY
62229: PPUSH
62230: LD_INT 21
62232: PUSH
62233: LD_INT 3
62235: PUSH
62236: EMPTY
62237: LIST
62238: LIST
62239: PUSH
62240: LD_INT 3
62242: PUSH
62243: LD_INT 2
62245: PUSH
62246: LD_INT 30
62248: PUSH
62249: LD_INT 29
62251: PUSH
62252: EMPTY
62253: LIST
62254: LIST
62255: PUSH
62256: LD_INT 30
62258: PUSH
62259: LD_INT 30
62261: PUSH
62262: EMPTY
62263: LIST
62264: LIST
62265: PUSH
62266: EMPTY
62267: LIST
62268: LIST
62269: LIST
62270: PUSH
62271: EMPTY
62272: LIST
62273: LIST
62274: PUSH
62275: LD_INT 3
62277: PUSH
62278: LD_INT 24
62280: PUSH
62281: LD_INT 1000
62283: PUSH
62284: EMPTY
62285: LIST
62286: LIST
62287: PUSH
62288: EMPTY
62289: LIST
62290: LIST
62291: PUSH
62292: EMPTY
62293: LIST
62294: LIST
62295: LIST
62296: PPUSH
62297: CALL_OW 72
62301: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
62302: LD_ADDR_EXP 70
62306: PUSH
62307: LD_EXP 70
62311: PPUSH
62312: LD_VAR 0 2
62316: PPUSH
62317: LD_VAR 0 3
62321: PPUSH
62322: CALL_OW 1
62326: ST_TO_ADDR
// end ;
62327: GO 62211
62329: POP
62330: POP
// RaiseSailEvent ( 101 ) ;
62331: LD_INT 101
62333: PPUSH
62334: CALL_OW 427
// end ;
62338: LD_VAR 0 1
62342: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
62343: LD_INT 0
62345: PPUSH
62346: PPUSH
62347: PPUSH
62348: PPUSH
62349: PPUSH
62350: PPUSH
62351: PPUSH
// if not mc_bases then
62352: LD_EXP 69
62356: NOT
62357: IFFALSE 62361
// exit ;
62359: GO 62923
// for i = 1 to mc_bases do
62361: LD_ADDR_VAR 0 2
62365: PUSH
62366: DOUBLE
62367: LD_INT 1
62369: DEC
62370: ST_TO_ADDR
62371: LD_EXP 69
62375: PUSH
62376: FOR_TO
62377: IFFALSE 62914
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
62379: LD_ADDR_VAR 0 5
62383: PUSH
62384: LD_EXP 69
62388: PUSH
62389: LD_VAR 0 2
62393: ARRAY
62394: PUSH
62395: LD_EXP 98
62399: PUSH
62400: LD_VAR 0 2
62404: ARRAY
62405: UNION
62406: PPUSH
62407: LD_INT 21
62409: PUSH
62410: LD_INT 1
62412: PUSH
62413: EMPTY
62414: LIST
62415: LIST
62416: PUSH
62417: LD_INT 1
62419: PUSH
62420: LD_INT 3
62422: PUSH
62423: LD_INT 54
62425: PUSH
62426: EMPTY
62427: LIST
62428: PUSH
62429: EMPTY
62430: LIST
62431: LIST
62432: PUSH
62433: LD_INT 3
62435: PUSH
62436: LD_INT 24
62438: PUSH
62439: LD_INT 1000
62441: PUSH
62442: EMPTY
62443: LIST
62444: LIST
62445: PUSH
62446: EMPTY
62447: LIST
62448: LIST
62449: PUSH
62450: EMPTY
62451: LIST
62452: LIST
62453: LIST
62454: PUSH
62455: EMPTY
62456: LIST
62457: LIST
62458: PPUSH
62459: CALL_OW 72
62463: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
62464: LD_ADDR_VAR 0 6
62468: PUSH
62469: LD_EXP 69
62473: PUSH
62474: LD_VAR 0 2
62478: ARRAY
62479: PPUSH
62480: LD_INT 21
62482: PUSH
62483: LD_INT 1
62485: PUSH
62486: EMPTY
62487: LIST
62488: LIST
62489: PUSH
62490: LD_INT 1
62492: PUSH
62493: LD_INT 3
62495: PUSH
62496: LD_INT 54
62498: PUSH
62499: EMPTY
62500: LIST
62501: PUSH
62502: EMPTY
62503: LIST
62504: LIST
62505: PUSH
62506: LD_INT 3
62508: PUSH
62509: LD_INT 24
62511: PUSH
62512: LD_INT 250
62514: PUSH
62515: EMPTY
62516: LIST
62517: LIST
62518: PUSH
62519: EMPTY
62520: LIST
62521: LIST
62522: PUSH
62523: EMPTY
62524: LIST
62525: LIST
62526: LIST
62527: PUSH
62528: EMPTY
62529: LIST
62530: LIST
62531: PPUSH
62532: CALL_OW 72
62536: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
62537: LD_ADDR_VAR 0 7
62541: PUSH
62542: LD_VAR 0 5
62546: PUSH
62547: LD_VAR 0 6
62551: DIFF
62552: ST_TO_ADDR
// if not need_heal_1 then
62553: LD_VAR 0 6
62557: NOT
62558: IFFALSE 62591
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
62560: LD_ADDR_EXP 72
62564: PUSH
62565: LD_EXP 72
62569: PPUSH
62570: LD_VAR 0 2
62574: PUSH
62575: LD_INT 1
62577: PUSH
62578: EMPTY
62579: LIST
62580: LIST
62581: PPUSH
62582: EMPTY
62583: PPUSH
62584: CALL 18588 0 3
62588: ST_TO_ADDR
62589: GO 62661
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
62591: LD_ADDR_EXP 72
62595: PUSH
62596: LD_EXP 72
62600: PPUSH
62601: LD_VAR 0 2
62605: PUSH
62606: LD_INT 1
62608: PUSH
62609: EMPTY
62610: LIST
62611: LIST
62612: PPUSH
62613: LD_EXP 72
62617: PUSH
62618: LD_VAR 0 2
62622: ARRAY
62623: PUSH
62624: LD_INT 1
62626: ARRAY
62627: PPUSH
62628: LD_INT 3
62630: PUSH
62631: LD_INT 24
62633: PUSH
62634: LD_INT 1000
62636: PUSH
62637: EMPTY
62638: LIST
62639: LIST
62640: PUSH
62641: EMPTY
62642: LIST
62643: LIST
62644: PPUSH
62645: CALL_OW 72
62649: PUSH
62650: LD_VAR 0 6
62654: UNION
62655: PPUSH
62656: CALL 18588 0 3
62660: ST_TO_ADDR
// if not need_heal_2 then
62661: LD_VAR 0 7
62665: NOT
62666: IFFALSE 62699
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
62668: LD_ADDR_EXP 72
62672: PUSH
62673: LD_EXP 72
62677: PPUSH
62678: LD_VAR 0 2
62682: PUSH
62683: LD_INT 2
62685: PUSH
62686: EMPTY
62687: LIST
62688: LIST
62689: PPUSH
62690: EMPTY
62691: PPUSH
62692: CALL 18588 0 3
62696: ST_TO_ADDR
62697: GO 62731
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
62699: LD_ADDR_EXP 72
62703: PUSH
62704: LD_EXP 72
62708: PPUSH
62709: LD_VAR 0 2
62713: PUSH
62714: LD_INT 2
62716: PUSH
62717: EMPTY
62718: LIST
62719: LIST
62720: PPUSH
62721: LD_VAR 0 7
62725: PPUSH
62726: CALL 18588 0 3
62730: ST_TO_ADDR
// if need_heal_2 then
62731: LD_VAR 0 7
62735: IFFALSE 62896
// for j in need_heal_2 do
62737: LD_ADDR_VAR 0 3
62741: PUSH
62742: LD_VAR 0 7
62746: PUSH
62747: FOR_IN
62748: IFFALSE 62894
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62750: LD_ADDR_VAR 0 5
62754: PUSH
62755: LD_EXP 69
62759: PUSH
62760: LD_VAR 0 2
62764: ARRAY
62765: PPUSH
62766: LD_INT 2
62768: PUSH
62769: LD_INT 30
62771: PUSH
62772: LD_INT 6
62774: PUSH
62775: EMPTY
62776: LIST
62777: LIST
62778: PUSH
62779: LD_INT 30
62781: PUSH
62782: LD_INT 7
62784: PUSH
62785: EMPTY
62786: LIST
62787: LIST
62788: PUSH
62789: LD_INT 30
62791: PUSH
62792: LD_INT 8
62794: PUSH
62795: EMPTY
62796: LIST
62797: LIST
62798: PUSH
62799: LD_INT 30
62801: PUSH
62802: LD_INT 0
62804: PUSH
62805: EMPTY
62806: LIST
62807: LIST
62808: PUSH
62809: LD_INT 30
62811: PUSH
62812: LD_INT 1
62814: PUSH
62815: EMPTY
62816: LIST
62817: LIST
62818: PUSH
62819: EMPTY
62820: LIST
62821: LIST
62822: LIST
62823: LIST
62824: LIST
62825: LIST
62826: PPUSH
62827: CALL_OW 72
62831: ST_TO_ADDR
// if tmp then
62832: LD_VAR 0 5
62836: IFFALSE 62892
// begin k := NearestUnitToUnit ( tmp , j ) ;
62838: LD_ADDR_VAR 0 4
62842: PUSH
62843: LD_VAR 0 5
62847: PPUSH
62848: LD_VAR 0 3
62852: PPUSH
62853: CALL_OW 74
62857: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
62858: LD_VAR 0 3
62862: PPUSH
62863: LD_VAR 0 4
62867: PPUSH
62868: CALL_OW 296
62872: PUSH
62873: LD_INT 5
62875: GREATER
62876: IFFALSE 62892
// ComMoveToNearbyEntrance ( j , k ) ;
62878: LD_VAR 0 3
62882: PPUSH
62883: LD_VAR 0 4
62887: PPUSH
62888: CALL 51206 0 2
// end ; end ;
62892: GO 62747
62894: POP
62895: POP
// if not need_heal_1 and not need_heal_2 then
62896: LD_VAR 0 6
62900: NOT
62901: PUSH
62902: LD_VAR 0 7
62906: NOT
62907: AND
62908: IFFALSE 62912
// continue ;
62910: GO 62376
// end ;
62912: GO 62376
62914: POP
62915: POP
// RaiseSailEvent ( 102 ) ;
62916: LD_INT 102
62918: PPUSH
62919: CALL_OW 427
// end ;
62923: LD_VAR 0 1
62927: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
62928: LD_INT 0
62930: PPUSH
62931: PPUSH
62932: PPUSH
62933: PPUSH
62934: PPUSH
62935: PPUSH
62936: PPUSH
62937: PPUSH
// if not mc_bases then
62938: LD_EXP 69
62942: NOT
62943: IFFALSE 62947
// exit ;
62945: GO 63830
// for i = 1 to mc_bases do
62947: LD_ADDR_VAR 0 2
62951: PUSH
62952: DOUBLE
62953: LD_INT 1
62955: DEC
62956: ST_TO_ADDR
62957: LD_EXP 69
62961: PUSH
62962: FOR_TO
62963: IFFALSE 63828
// begin if not mc_building_need_repair [ i ] then
62965: LD_EXP 70
62969: PUSH
62970: LD_VAR 0 2
62974: ARRAY
62975: NOT
62976: IFFALSE 63163
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
62978: LD_ADDR_VAR 0 6
62982: PUSH
62983: LD_EXP 88
62987: PUSH
62988: LD_VAR 0 2
62992: ARRAY
62993: PPUSH
62994: LD_INT 3
62996: PUSH
62997: LD_INT 24
62999: PUSH
63000: LD_INT 1000
63002: PUSH
63003: EMPTY
63004: LIST
63005: LIST
63006: PUSH
63007: EMPTY
63008: LIST
63009: LIST
63010: PUSH
63011: LD_INT 2
63013: PUSH
63014: LD_INT 34
63016: PUSH
63017: LD_INT 13
63019: PUSH
63020: EMPTY
63021: LIST
63022: LIST
63023: PUSH
63024: LD_INT 34
63026: PUSH
63027: LD_INT 52
63029: PUSH
63030: EMPTY
63031: LIST
63032: LIST
63033: PUSH
63034: LD_INT 34
63036: PUSH
63037: LD_EXP 54
63041: PUSH
63042: EMPTY
63043: LIST
63044: LIST
63045: PUSH
63046: EMPTY
63047: LIST
63048: LIST
63049: LIST
63050: LIST
63051: PUSH
63052: EMPTY
63053: LIST
63054: LIST
63055: PPUSH
63056: CALL_OW 72
63060: ST_TO_ADDR
// if cranes then
63061: LD_VAR 0 6
63065: IFFALSE 63127
// for j in cranes do
63067: LD_ADDR_VAR 0 3
63071: PUSH
63072: LD_VAR 0 6
63076: PUSH
63077: FOR_IN
63078: IFFALSE 63125
// if not IsInArea ( j , mc_parking [ i ] ) then
63080: LD_VAR 0 3
63084: PPUSH
63085: LD_EXP 93
63089: PUSH
63090: LD_VAR 0 2
63094: ARRAY
63095: PPUSH
63096: CALL_OW 308
63100: NOT
63101: IFFALSE 63123
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63103: LD_VAR 0 3
63107: PPUSH
63108: LD_EXP 93
63112: PUSH
63113: LD_VAR 0 2
63117: ARRAY
63118: PPUSH
63119: CALL_OW 113
63123: GO 63077
63125: POP
63126: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63127: LD_ADDR_EXP 71
63131: PUSH
63132: LD_EXP 71
63136: PPUSH
63137: LD_VAR 0 2
63141: PPUSH
63142: EMPTY
63143: PPUSH
63144: CALL_OW 1
63148: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
63149: LD_VAR 0 2
63153: PPUSH
63154: LD_INT 101
63156: PPUSH
63157: CALL 58015 0 2
// continue ;
63161: GO 62962
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
63163: LD_ADDR_EXP 75
63167: PUSH
63168: LD_EXP 75
63172: PPUSH
63173: LD_VAR 0 2
63177: PPUSH
63178: EMPTY
63179: PPUSH
63180: CALL_OW 1
63184: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63185: LD_VAR 0 2
63189: PPUSH
63190: LD_INT 103
63192: PPUSH
63193: CALL 58015 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
63197: LD_ADDR_VAR 0 5
63201: PUSH
63202: LD_EXP 69
63206: PUSH
63207: LD_VAR 0 2
63211: ARRAY
63212: PUSH
63213: LD_EXP 98
63217: PUSH
63218: LD_VAR 0 2
63222: ARRAY
63223: UNION
63224: PPUSH
63225: LD_INT 2
63227: PUSH
63228: LD_INT 25
63230: PUSH
63231: LD_INT 2
63233: PUSH
63234: EMPTY
63235: LIST
63236: LIST
63237: PUSH
63238: LD_INT 25
63240: PUSH
63241: LD_INT 16
63243: PUSH
63244: EMPTY
63245: LIST
63246: LIST
63247: PUSH
63248: EMPTY
63249: LIST
63250: LIST
63251: LIST
63252: PUSH
63253: EMPTY
63254: LIST
63255: PPUSH
63256: CALL_OW 72
63260: ST_TO_ADDR
// if mc_need_heal [ i ] then
63261: LD_EXP 72
63265: PUSH
63266: LD_VAR 0 2
63270: ARRAY
63271: IFFALSE 63315
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
63273: LD_ADDR_VAR 0 5
63277: PUSH
63278: LD_VAR 0 5
63282: PUSH
63283: LD_EXP 72
63287: PUSH
63288: LD_VAR 0 2
63292: ARRAY
63293: PUSH
63294: LD_INT 1
63296: ARRAY
63297: PUSH
63298: LD_EXP 72
63302: PUSH
63303: LD_VAR 0 2
63307: ARRAY
63308: PUSH
63309: LD_INT 2
63311: ARRAY
63312: UNION
63313: DIFF
63314: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
63315: LD_ADDR_VAR 0 6
63319: PUSH
63320: LD_EXP 88
63324: PUSH
63325: LD_VAR 0 2
63329: ARRAY
63330: PPUSH
63331: LD_INT 2
63333: PUSH
63334: LD_INT 34
63336: PUSH
63337: LD_INT 13
63339: PUSH
63340: EMPTY
63341: LIST
63342: LIST
63343: PUSH
63344: LD_INT 34
63346: PUSH
63347: LD_INT 52
63349: PUSH
63350: EMPTY
63351: LIST
63352: LIST
63353: PUSH
63354: LD_INT 34
63356: PUSH
63357: LD_EXP 54
63361: PUSH
63362: EMPTY
63363: LIST
63364: LIST
63365: PUSH
63366: EMPTY
63367: LIST
63368: LIST
63369: LIST
63370: LIST
63371: PPUSH
63372: CALL_OW 72
63376: ST_TO_ADDR
// if cranes then
63377: LD_VAR 0 6
63381: IFFALSE 63517
// begin for j in cranes do
63383: LD_ADDR_VAR 0 3
63387: PUSH
63388: LD_VAR 0 6
63392: PUSH
63393: FOR_IN
63394: IFFALSE 63515
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
63396: LD_VAR 0 3
63400: PPUSH
63401: CALL_OW 256
63405: PUSH
63406: LD_INT 1000
63408: EQUAL
63409: PUSH
63410: LD_VAR 0 3
63414: PPUSH
63415: CALL_OW 314
63419: NOT
63420: AND
63421: IFFALSE 63455
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
63423: LD_VAR 0 3
63427: PPUSH
63428: LD_EXP 70
63432: PUSH
63433: LD_VAR 0 2
63437: ARRAY
63438: PPUSH
63439: LD_VAR 0 3
63443: PPUSH
63444: CALL_OW 74
63448: PPUSH
63449: CALL_OW 130
63453: GO 63513
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
63455: LD_VAR 0 3
63459: PPUSH
63460: CALL_OW 256
63464: PUSH
63465: LD_INT 500
63467: LESS
63468: PUSH
63469: LD_VAR 0 3
63473: PPUSH
63474: LD_EXP 93
63478: PUSH
63479: LD_VAR 0 2
63483: ARRAY
63484: PPUSH
63485: CALL_OW 308
63489: NOT
63490: AND
63491: IFFALSE 63513
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63493: LD_VAR 0 3
63497: PPUSH
63498: LD_EXP 93
63502: PUSH
63503: LD_VAR 0 2
63507: ARRAY
63508: PPUSH
63509: CALL_OW 113
// end ;
63513: GO 63393
63515: POP
63516: POP
// end ; if tmp > 3 then
63517: LD_VAR 0 5
63521: PUSH
63522: LD_INT 3
63524: GREATER
63525: IFFALSE 63545
// tmp := ShrinkArray ( tmp , 4 ) ;
63527: LD_ADDR_VAR 0 5
63531: PUSH
63532: LD_VAR 0 5
63536: PPUSH
63537: LD_INT 4
63539: PPUSH
63540: CALL 50654 0 2
63544: ST_TO_ADDR
// if not tmp then
63545: LD_VAR 0 5
63549: NOT
63550: IFFALSE 63554
// continue ;
63552: GO 62962
// for j in tmp do
63554: LD_ADDR_VAR 0 3
63558: PUSH
63559: LD_VAR 0 5
63563: PUSH
63564: FOR_IN
63565: IFFALSE 63824
// begin if IsInUnit ( j ) then
63567: LD_VAR 0 3
63571: PPUSH
63572: CALL_OW 310
63576: IFFALSE 63587
// ComExitBuilding ( j ) ;
63578: LD_VAR 0 3
63582: PPUSH
63583: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
63587: LD_VAR 0 3
63591: PUSH
63592: LD_EXP 71
63596: PUSH
63597: LD_VAR 0 2
63601: ARRAY
63602: IN
63603: NOT
63604: IFFALSE 63662
// begin SetTag ( j , 101 ) ;
63606: LD_VAR 0 3
63610: PPUSH
63611: LD_INT 101
63613: PPUSH
63614: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
63618: LD_ADDR_EXP 71
63622: PUSH
63623: LD_EXP 71
63627: PPUSH
63628: LD_VAR 0 2
63632: PUSH
63633: LD_EXP 71
63637: PUSH
63638: LD_VAR 0 2
63642: ARRAY
63643: PUSH
63644: LD_INT 1
63646: PLUS
63647: PUSH
63648: EMPTY
63649: LIST
63650: LIST
63651: PPUSH
63652: LD_VAR 0 3
63656: PPUSH
63657: CALL 18588 0 3
63661: ST_TO_ADDR
// end ; wait ( 1 ) ;
63662: LD_INT 1
63664: PPUSH
63665: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
63669: LD_ADDR_VAR 0 7
63673: PUSH
63674: LD_EXP 70
63678: PUSH
63679: LD_VAR 0 2
63683: ARRAY
63684: ST_TO_ADDR
// if mc_scan [ i ] then
63685: LD_EXP 92
63689: PUSH
63690: LD_VAR 0 2
63694: ARRAY
63695: IFFALSE 63757
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
63697: LD_ADDR_VAR 0 7
63701: PUSH
63702: LD_EXP 70
63706: PUSH
63707: LD_VAR 0 2
63711: ARRAY
63712: PPUSH
63713: LD_INT 3
63715: PUSH
63716: LD_INT 30
63718: PUSH
63719: LD_INT 32
63721: PUSH
63722: EMPTY
63723: LIST
63724: LIST
63725: PUSH
63726: LD_INT 30
63728: PUSH
63729: LD_INT 33
63731: PUSH
63732: EMPTY
63733: LIST
63734: LIST
63735: PUSH
63736: LD_INT 30
63738: PUSH
63739: LD_INT 31
63741: PUSH
63742: EMPTY
63743: LIST
63744: LIST
63745: PUSH
63746: EMPTY
63747: LIST
63748: LIST
63749: LIST
63750: LIST
63751: PPUSH
63752: CALL_OW 72
63756: ST_TO_ADDR
// if not to_repair_tmp then
63757: LD_VAR 0 7
63761: NOT
63762: IFFALSE 63766
// continue ;
63764: GO 63564
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
63766: LD_ADDR_VAR 0 8
63770: PUSH
63771: LD_VAR 0 7
63775: PPUSH
63776: LD_VAR 0 3
63780: PPUSH
63781: CALL_OW 74
63785: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
63786: LD_VAR 0 8
63790: PPUSH
63791: LD_INT 16
63793: PPUSH
63794: CALL 21187 0 2
63798: PUSH
63799: LD_INT 4
63801: ARRAY
63802: PUSH
63803: LD_INT 10
63805: LESS
63806: IFFALSE 63822
// ComRepairBuilding ( j , to_repair ) ;
63808: LD_VAR 0 3
63812: PPUSH
63813: LD_VAR 0 8
63817: PPUSH
63818: CALL_OW 130
// end ;
63822: GO 63564
63824: POP
63825: POP
// end ;
63826: GO 62962
63828: POP
63829: POP
// end ;
63830: LD_VAR 0 1
63834: RET
// export function MC_Heal ; var i , j , tmp ; begin
63835: LD_INT 0
63837: PPUSH
63838: PPUSH
63839: PPUSH
63840: PPUSH
// if not mc_bases then
63841: LD_EXP 69
63845: NOT
63846: IFFALSE 63850
// exit ;
63848: GO 64252
// for i = 1 to mc_bases do
63850: LD_ADDR_VAR 0 2
63854: PUSH
63855: DOUBLE
63856: LD_INT 1
63858: DEC
63859: ST_TO_ADDR
63860: LD_EXP 69
63864: PUSH
63865: FOR_TO
63866: IFFALSE 64250
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
63868: LD_EXP 72
63872: PUSH
63873: LD_VAR 0 2
63877: ARRAY
63878: PUSH
63879: LD_INT 1
63881: ARRAY
63882: NOT
63883: PUSH
63884: LD_EXP 72
63888: PUSH
63889: LD_VAR 0 2
63893: ARRAY
63894: PUSH
63895: LD_INT 2
63897: ARRAY
63898: NOT
63899: AND
63900: IFFALSE 63938
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
63902: LD_ADDR_EXP 73
63906: PUSH
63907: LD_EXP 73
63911: PPUSH
63912: LD_VAR 0 2
63916: PPUSH
63917: EMPTY
63918: PPUSH
63919: CALL_OW 1
63923: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
63924: LD_VAR 0 2
63928: PPUSH
63929: LD_INT 102
63931: PPUSH
63932: CALL 58015 0 2
// continue ;
63936: GO 63865
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
63938: LD_ADDR_VAR 0 4
63942: PUSH
63943: LD_EXP 69
63947: PUSH
63948: LD_VAR 0 2
63952: ARRAY
63953: PPUSH
63954: LD_INT 25
63956: PUSH
63957: LD_INT 4
63959: PUSH
63960: EMPTY
63961: LIST
63962: LIST
63963: PPUSH
63964: CALL_OW 72
63968: ST_TO_ADDR
// if not tmp then
63969: LD_VAR 0 4
63973: NOT
63974: IFFALSE 63978
// continue ;
63976: GO 63865
// if mc_taming [ i ] then
63978: LD_EXP 100
63982: PUSH
63983: LD_VAR 0 2
63987: ARRAY
63988: IFFALSE 64012
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63990: LD_ADDR_EXP 100
63994: PUSH
63995: LD_EXP 100
63999: PPUSH
64000: LD_VAR 0 2
64004: PPUSH
64005: EMPTY
64006: PPUSH
64007: CALL_OW 1
64011: ST_TO_ADDR
// for j in tmp do
64012: LD_ADDR_VAR 0 3
64016: PUSH
64017: LD_VAR 0 4
64021: PUSH
64022: FOR_IN
64023: IFFALSE 64246
// begin if IsInUnit ( j ) then
64025: LD_VAR 0 3
64029: PPUSH
64030: CALL_OW 310
64034: IFFALSE 64045
// ComExitBuilding ( j ) ;
64036: LD_VAR 0 3
64040: PPUSH
64041: CALL_OW 122
// if not j in mc_healers [ i ] then
64045: LD_VAR 0 3
64049: PUSH
64050: LD_EXP 73
64054: PUSH
64055: LD_VAR 0 2
64059: ARRAY
64060: IN
64061: NOT
64062: IFFALSE 64108
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
64064: LD_ADDR_EXP 73
64068: PUSH
64069: LD_EXP 73
64073: PPUSH
64074: LD_VAR 0 2
64078: PUSH
64079: LD_EXP 73
64083: PUSH
64084: LD_VAR 0 2
64088: ARRAY
64089: PUSH
64090: LD_INT 1
64092: PLUS
64093: PUSH
64094: EMPTY
64095: LIST
64096: LIST
64097: PPUSH
64098: LD_VAR 0 3
64102: PPUSH
64103: CALL 18588 0 3
64107: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
64108: LD_VAR 0 3
64112: PPUSH
64113: CALL_OW 110
64117: PUSH
64118: LD_INT 102
64120: NONEQUAL
64121: IFFALSE 64135
// SetTag ( j , 102 ) ;
64123: LD_VAR 0 3
64127: PPUSH
64128: LD_INT 102
64130: PPUSH
64131: CALL_OW 109
// Wait ( 3 ) ;
64135: LD_INT 3
64137: PPUSH
64138: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
64142: LD_EXP 72
64146: PUSH
64147: LD_VAR 0 2
64151: ARRAY
64152: PUSH
64153: LD_INT 1
64155: ARRAY
64156: IFFALSE 64188
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
64158: LD_VAR 0 3
64162: PPUSH
64163: LD_EXP 72
64167: PUSH
64168: LD_VAR 0 2
64172: ARRAY
64173: PUSH
64174: LD_INT 1
64176: ARRAY
64177: PUSH
64178: LD_INT 1
64180: ARRAY
64181: PPUSH
64182: CALL_OW 128
64186: GO 64244
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
64188: LD_VAR 0 3
64192: PPUSH
64193: CALL_OW 314
64197: NOT
64198: PUSH
64199: LD_EXP 72
64203: PUSH
64204: LD_VAR 0 2
64208: ARRAY
64209: PUSH
64210: LD_INT 2
64212: ARRAY
64213: AND
64214: IFFALSE 64244
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
64216: LD_VAR 0 3
64220: PPUSH
64221: LD_EXP 72
64225: PUSH
64226: LD_VAR 0 2
64230: ARRAY
64231: PUSH
64232: LD_INT 2
64234: ARRAY
64235: PUSH
64236: LD_INT 1
64238: ARRAY
64239: PPUSH
64240: CALL_OW 128
// end ;
64244: GO 64022
64246: POP
64247: POP
// end ;
64248: GO 63865
64250: POP
64251: POP
// end ;
64252: LD_VAR 0 1
64256: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
64257: LD_INT 0
64259: PPUSH
64260: PPUSH
64261: PPUSH
64262: PPUSH
64263: PPUSH
// if not mc_bases then
64264: LD_EXP 69
64268: NOT
64269: IFFALSE 64273
// exit ;
64271: GO 65444
// for i = 1 to mc_bases do
64273: LD_ADDR_VAR 0 2
64277: PUSH
64278: DOUBLE
64279: LD_INT 1
64281: DEC
64282: ST_TO_ADDR
64283: LD_EXP 69
64287: PUSH
64288: FOR_TO
64289: IFFALSE 65442
// begin if mc_scan [ i ] then
64291: LD_EXP 92
64295: PUSH
64296: LD_VAR 0 2
64300: ARRAY
64301: IFFALSE 64305
// continue ;
64303: GO 64288
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
64305: LD_EXP 74
64309: PUSH
64310: LD_VAR 0 2
64314: ARRAY
64315: NOT
64316: PUSH
64317: LD_EXP 76
64321: PUSH
64322: LD_VAR 0 2
64326: ARRAY
64327: NOT
64328: AND
64329: PUSH
64330: LD_EXP 75
64334: PUSH
64335: LD_VAR 0 2
64339: ARRAY
64340: AND
64341: IFFALSE 64379
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
64343: LD_ADDR_EXP 75
64347: PUSH
64348: LD_EXP 75
64352: PPUSH
64353: LD_VAR 0 2
64357: PPUSH
64358: EMPTY
64359: PPUSH
64360: CALL_OW 1
64364: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64365: LD_VAR 0 2
64369: PPUSH
64370: LD_INT 103
64372: PPUSH
64373: CALL 58015 0 2
// continue ;
64377: GO 64288
// end ; if mc_construct_list [ i ] then
64379: LD_EXP 76
64383: PUSH
64384: LD_VAR 0 2
64388: ARRAY
64389: IFFALSE 64609
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64391: LD_ADDR_VAR 0 4
64395: PUSH
64396: LD_EXP 69
64400: PUSH
64401: LD_VAR 0 2
64405: ARRAY
64406: PPUSH
64407: LD_INT 25
64409: PUSH
64410: LD_INT 2
64412: PUSH
64413: EMPTY
64414: LIST
64415: LIST
64416: PPUSH
64417: CALL_OW 72
64421: PUSH
64422: LD_EXP 71
64426: PUSH
64427: LD_VAR 0 2
64431: ARRAY
64432: DIFF
64433: ST_TO_ADDR
// if not tmp then
64434: LD_VAR 0 4
64438: NOT
64439: IFFALSE 64443
// continue ;
64441: GO 64288
// for j in tmp do
64443: LD_ADDR_VAR 0 3
64447: PUSH
64448: LD_VAR 0 4
64452: PUSH
64453: FOR_IN
64454: IFFALSE 64605
// begin if not mc_builders [ i ] then
64456: LD_EXP 75
64460: PUSH
64461: LD_VAR 0 2
64465: ARRAY
64466: NOT
64467: IFFALSE 64525
// begin SetTag ( j , 103 ) ;
64469: LD_VAR 0 3
64473: PPUSH
64474: LD_INT 103
64476: PPUSH
64477: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64481: LD_ADDR_EXP 75
64485: PUSH
64486: LD_EXP 75
64490: PPUSH
64491: LD_VAR 0 2
64495: PUSH
64496: LD_EXP 75
64500: PUSH
64501: LD_VAR 0 2
64505: ARRAY
64506: PUSH
64507: LD_INT 1
64509: PLUS
64510: PUSH
64511: EMPTY
64512: LIST
64513: LIST
64514: PPUSH
64515: LD_VAR 0 3
64519: PPUSH
64520: CALL 18588 0 3
64524: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64525: LD_VAR 0 3
64529: PPUSH
64530: CALL_OW 310
64534: IFFALSE 64545
// ComExitBuilding ( j ) ;
64536: LD_VAR 0 3
64540: PPUSH
64541: CALL_OW 122
// wait ( 3 ) ;
64545: LD_INT 3
64547: PPUSH
64548: CALL_OW 67
// if not mc_construct_list [ i ] then
64552: LD_EXP 76
64556: PUSH
64557: LD_VAR 0 2
64561: ARRAY
64562: NOT
64563: IFFALSE 64567
// break ;
64565: GO 64605
// if not HasTask ( j ) then
64567: LD_VAR 0 3
64571: PPUSH
64572: CALL_OW 314
64576: NOT
64577: IFFALSE 64603
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
64579: LD_VAR 0 3
64583: PPUSH
64584: LD_EXP 76
64588: PUSH
64589: LD_VAR 0 2
64593: ARRAY
64594: PUSH
64595: LD_INT 1
64597: ARRAY
64598: PPUSH
64599: CALL 21451 0 2
// end ;
64603: GO 64453
64605: POP
64606: POP
// end else
64607: GO 65440
// if mc_build_list [ i ] then
64609: LD_EXP 74
64613: PUSH
64614: LD_VAR 0 2
64618: ARRAY
64619: IFFALSE 65440
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64621: LD_ADDR_VAR 0 5
64625: PUSH
64626: LD_EXP 69
64630: PUSH
64631: LD_VAR 0 2
64635: ARRAY
64636: PPUSH
64637: LD_INT 2
64639: PUSH
64640: LD_INT 30
64642: PUSH
64643: LD_INT 0
64645: PUSH
64646: EMPTY
64647: LIST
64648: LIST
64649: PUSH
64650: LD_INT 30
64652: PUSH
64653: LD_INT 1
64655: PUSH
64656: EMPTY
64657: LIST
64658: LIST
64659: PUSH
64660: EMPTY
64661: LIST
64662: LIST
64663: LIST
64664: PPUSH
64665: CALL_OW 72
64669: ST_TO_ADDR
// if depot then
64670: LD_VAR 0 5
64674: IFFALSE 64692
// depot := depot [ 1 ] else
64676: LD_ADDR_VAR 0 5
64680: PUSH
64681: LD_VAR 0 5
64685: PUSH
64686: LD_INT 1
64688: ARRAY
64689: ST_TO_ADDR
64690: GO 64700
// depot := 0 ;
64692: LD_ADDR_VAR 0 5
64696: PUSH
64697: LD_INT 0
64699: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
64700: LD_EXP 74
64704: PUSH
64705: LD_VAR 0 2
64709: ARRAY
64710: PUSH
64711: LD_INT 1
64713: ARRAY
64714: PUSH
64715: LD_INT 1
64717: ARRAY
64718: PPUSH
64719: CALL 21275 0 1
64723: PUSH
64724: LD_EXP 69
64728: PUSH
64729: LD_VAR 0 2
64733: ARRAY
64734: PPUSH
64735: LD_INT 2
64737: PUSH
64738: LD_INT 30
64740: PUSH
64741: LD_INT 2
64743: PUSH
64744: EMPTY
64745: LIST
64746: LIST
64747: PUSH
64748: LD_INT 30
64750: PUSH
64751: LD_INT 3
64753: PUSH
64754: EMPTY
64755: LIST
64756: LIST
64757: PUSH
64758: EMPTY
64759: LIST
64760: LIST
64761: LIST
64762: PPUSH
64763: CALL_OW 72
64767: NOT
64768: AND
64769: IFFALSE 64874
// begin for j = 1 to mc_build_list [ i ] do
64771: LD_ADDR_VAR 0 3
64775: PUSH
64776: DOUBLE
64777: LD_INT 1
64779: DEC
64780: ST_TO_ADDR
64781: LD_EXP 74
64785: PUSH
64786: LD_VAR 0 2
64790: ARRAY
64791: PUSH
64792: FOR_TO
64793: IFFALSE 64872
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
64795: LD_EXP 74
64799: PUSH
64800: LD_VAR 0 2
64804: ARRAY
64805: PUSH
64806: LD_VAR 0 3
64810: ARRAY
64811: PUSH
64812: LD_INT 1
64814: ARRAY
64815: PUSH
64816: LD_INT 2
64818: EQUAL
64819: IFFALSE 64870
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
64821: LD_ADDR_EXP 74
64825: PUSH
64826: LD_EXP 74
64830: PPUSH
64831: LD_VAR 0 2
64835: PPUSH
64836: LD_EXP 74
64840: PUSH
64841: LD_VAR 0 2
64845: ARRAY
64846: PPUSH
64847: LD_VAR 0 3
64851: PPUSH
64852: LD_INT 1
64854: PPUSH
64855: LD_INT 0
64857: PPUSH
64858: CALL 18006 0 4
64862: PPUSH
64863: CALL_OW 1
64867: ST_TO_ADDR
// break ;
64868: GO 64872
// end ;
64870: GO 64792
64872: POP
64873: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
64874: LD_EXP 74
64878: PUSH
64879: LD_VAR 0 2
64883: ARRAY
64884: PUSH
64885: LD_INT 1
64887: ARRAY
64888: PUSH
64889: LD_INT 1
64891: ARRAY
64892: PUSH
64893: LD_INT 0
64895: EQUAL
64896: PUSH
64897: LD_VAR 0 5
64901: PUSH
64902: LD_VAR 0 5
64906: PPUSH
64907: LD_EXP 74
64911: PUSH
64912: LD_VAR 0 2
64916: ARRAY
64917: PUSH
64918: LD_INT 1
64920: ARRAY
64921: PUSH
64922: LD_INT 1
64924: ARRAY
64925: PPUSH
64926: LD_EXP 74
64930: PUSH
64931: LD_VAR 0 2
64935: ARRAY
64936: PUSH
64937: LD_INT 1
64939: ARRAY
64940: PUSH
64941: LD_INT 2
64943: ARRAY
64944: PPUSH
64945: LD_EXP 74
64949: PUSH
64950: LD_VAR 0 2
64954: ARRAY
64955: PUSH
64956: LD_INT 1
64958: ARRAY
64959: PUSH
64960: LD_INT 3
64962: ARRAY
64963: PPUSH
64964: LD_EXP 74
64968: PUSH
64969: LD_VAR 0 2
64973: ARRAY
64974: PUSH
64975: LD_INT 1
64977: ARRAY
64978: PUSH
64979: LD_INT 4
64981: ARRAY
64982: PPUSH
64983: CALL 26691 0 5
64987: AND
64988: OR
64989: IFFALSE 65270
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64991: LD_ADDR_VAR 0 4
64995: PUSH
64996: LD_EXP 69
65000: PUSH
65001: LD_VAR 0 2
65005: ARRAY
65006: PPUSH
65007: LD_INT 25
65009: PUSH
65010: LD_INT 2
65012: PUSH
65013: EMPTY
65014: LIST
65015: LIST
65016: PPUSH
65017: CALL_OW 72
65021: PUSH
65022: LD_EXP 71
65026: PUSH
65027: LD_VAR 0 2
65031: ARRAY
65032: DIFF
65033: ST_TO_ADDR
// if not tmp then
65034: LD_VAR 0 4
65038: NOT
65039: IFFALSE 65043
// continue ;
65041: GO 64288
// for j in tmp do
65043: LD_ADDR_VAR 0 3
65047: PUSH
65048: LD_VAR 0 4
65052: PUSH
65053: FOR_IN
65054: IFFALSE 65266
// begin if not mc_builders [ i ] then
65056: LD_EXP 75
65060: PUSH
65061: LD_VAR 0 2
65065: ARRAY
65066: NOT
65067: IFFALSE 65125
// begin SetTag ( j , 103 ) ;
65069: LD_VAR 0 3
65073: PPUSH
65074: LD_INT 103
65076: PPUSH
65077: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65081: LD_ADDR_EXP 75
65085: PUSH
65086: LD_EXP 75
65090: PPUSH
65091: LD_VAR 0 2
65095: PUSH
65096: LD_EXP 75
65100: PUSH
65101: LD_VAR 0 2
65105: ARRAY
65106: PUSH
65107: LD_INT 1
65109: PLUS
65110: PUSH
65111: EMPTY
65112: LIST
65113: LIST
65114: PPUSH
65115: LD_VAR 0 3
65119: PPUSH
65120: CALL 18588 0 3
65124: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65125: LD_VAR 0 3
65129: PPUSH
65130: CALL_OW 310
65134: IFFALSE 65145
// ComExitBuilding ( j ) ;
65136: LD_VAR 0 3
65140: PPUSH
65141: CALL_OW 122
// wait ( 3 ) ;
65145: LD_INT 3
65147: PPUSH
65148: CALL_OW 67
// if not mc_build_list [ i ] then
65152: LD_EXP 74
65156: PUSH
65157: LD_VAR 0 2
65161: ARRAY
65162: NOT
65163: IFFALSE 65167
// break ;
65165: GO 65266
// if not HasTask ( j ) then
65167: LD_VAR 0 3
65171: PPUSH
65172: CALL_OW 314
65176: NOT
65177: IFFALSE 65264
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
65179: LD_VAR 0 3
65183: PPUSH
65184: LD_EXP 74
65188: PUSH
65189: LD_VAR 0 2
65193: ARRAY
65194: PUSH
65195: LD_INT 1
65197: ARRAY
65198: PUSH
65199: LD_INT 1
65201: ARRAY
65202: PPUSH
65203: LD_EXP 74
65207: PUSH
65208: LD_VAR 0 2
65212: ARRAY
65213: PUSH
65214: LD_INT 1
65216: ARRAY
65217: PUSH
65218: LD_INT 2
65220: ARRAY
65221: PPUSH
65222: LD_EXP 74
65226: PUSH
65227: LD_VAR 0 2
65231: ARRAY
65232: PUSH
65233: LD_INT 1
65235: ARRAY
65236: PUSH
65237: LD_INT 3
65239: ARRAY
65240: PPUSH
65241: LD_EXP 74
65245: PUSH
65246: LD_VAR 0 2
65250: ARRAY
65251: PUSH
65252: LD_INT 1
65254: ARRAY
65255: PUSH
65256: LD_INT 4
65258: ARRAY
65259: PPUSH
65260: CALL_OW 145
// end ;
65264: GO 65053
65266: POP
65267: POP
// end else
65268: GO 65440
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
65270: LD_EXP 69
65274: PUSH
65275: LD_VAR 0 2
65279: ARRAY
65280: PPUSH
65281: LD_EXP 74
65285: PUSH
65286: LD_VAR 0 2
65290: ARRAY
65291: PUSH
65292: LD_INT 1
65294: ARRAY
65295: PUSH
65296: LD_INT 1
65298: ARRAY
65299: PPUSH
65300: LD_EXP 74
65304: PUSH
65305: LD_VAR 0 2
65309: ARRAY
65310: PUSH
65311: LD_INT 1
65313: ARRAY
65314: PUSH
65315: LD_INT 2
65317: ARRAY
65318: PPUSH
65319: LD_EXP 74
65323: PUSH
65324: LD_VAR 0 2
65328: ARRAY
65329: PUSH
65330: LD_INT 1
65332: ARRAY
65333: PUSH
65334: LD_INT 3
65336: ARRAY
65337: PPUSH
65338: LD_EXP 74
65342: PUSH
65343: LD_VAR 0 2
65347: ARRAY
65348: PUSH
65349: LD_INT 1
65351: ARRAY
65352: PUSH
65353: LD_INT 4
65355: ARRAY
65356: PPUSH
65357: LD_EXP 69
65361: PUSH
65362: LD_VAR 0 2
65366: ARRAY
65367: PPUSH
65368: LD_INT 21
65370: PUSH
65371: LD_INT 3
65373: PUSH
65374: EMPTY
65375: LIST
65376: LIST
65377: PPUSH
65378: CALL_OW 72
65382: PPUSH
65383: EMPTY
65384: PPUSH
65385: CALL 25441 0 7
65389: NOT
65390: IFFALSE 65440
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
65392: LD_ADDR_EXP 74
65396: PUSH
65397: LD_EXP 74
65401: PPUSH
65402: LD_VAR 0 2
65406: PPUSH
65407: LD_EXP 74
65411: PUSH
65412: LD_VAR 0 2
65416: ARRAY
65417: PPUSH
65418: LD_INT 1
65420: PPUSH
65421: LD_INT 1
65423: NEG
65424: PPUSH
65425: LD_INT 0
65427: PPUSH
65428: CALL 18006 0 4
65432: PPUSH
65433: CALL_OW 1
65437: ST_TO_ADDR
// continue ;
65438: GO 64288
// end ; end ; end ;
65440: GO 64288
65442: POP
65443: POP
// end ;
65444: LD_VAR 0 1
65448: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
65449: LD_INT 0
65451: PPUSH
65452: PPUSH
65453: PPUSH
65454: PPUSH
65455: PPUSH
65456: PPUSH
// if not mc_bases then
65457: LD_EXP 69
65461: NOT
65462: IFFALSE 65466
// exit ;
65464: GO 65893
// for i = 1 to mc_bases do
65466: LD_ADDR_VAR 0 2
65470: PUSH
65471: DOUBLE
65472: LD_INT 1
65474: DEC
65475: ST_TO_ADDR
65476: LD_EXP 69
65480: PUSH
65481: FOR_TO
65482: IFFALSE 65891
// begin tmp := mc_build_upgrade [ i ] ;
65484: LD_ADDR_VAR 0 4
65488: PUSH
65489: LD_EXP 101
65493: PUSH
65494: LD_VAR 0 2
65498: ARRAY
65499: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
65500: LD_ADDR_VAR 0 6
65504: PUSH
65505: LD_EXP 102
65509: PUSH
65510: LD_VAR 0 2
65514: ARRAY
65515: PPUSH
65516: LD_INT 2
65518: PUSH
65519: LD_INT 30
65521: PUSH
65522: LD_INT 6
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: PUSH
65529: LD_INT 30
65531: PUSH
65532: LD_INT 7
65534: PUSH
65535: EMPTY
65536: LIST
65537: LIST
65538: PUSH
65539: EMPTY
65540: LIST
65541: LIST
65542: LIST
65543: PPUSH
65544: CALL_OW 72
65548: ST_TO_ADDR
// if not tmp and not lab then
65549: LD_VAR 0 4
65553: NOT
65554: PUSH
65555: LD_VAR 0 6
65559: NOT
65560: AND
65561: IFFALSE 65565
// continue ;
65563: GO 65481
// if tmp then
65565: LD_VAR 0 4
65569: IFFALSE 65689
// for j in tmp do
65571: LD_ADDR_VAR 0 3
65575: PUSH
65576: LD_VAR 0 4
65580: PUSH
65581: FOR_IN
65582: IFFALSE 65687
// begin if UpgradeCost ( j ) then
65584: LD_VAR 0 3
65588: PPUSH
65589: CALL 25101 0 1
65593: IFFALSE 65685
// begin ComUpgrade ( j ) ;
65595: LD_VAR 0 3
65599: PPUSH
65600: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
65604: LD_ADDR_EXP 101
65608: PUSH
65609: LD_EXP 101
65613: PPUSH
65614: LD_VAR 0 2
65618: PPUSH
65619: LD_EXP 101
65623: PUSH
65624: LD_VAR 0 2
65628: ARRAY
65629: PUSH
65630: LD_VAR 0 3
65634: DIFF
65635: PPUSH
65636: CALL_OW 1
65640: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65641: LD_ADDR_EXP 76
65645: PUSH
65646: LD_EXP 76
65650: PPUSH
65651: LD_VAR 0 2
65655: PUSH
65656: LD_EXP 76
65660: PUSH
65661: LD_VAR 0 2
65665: ARRAY
65666: PUSH
65667: LD_INT 1
65669: PLUS
65670: PUSH
65671: EMPTY
65672: LIST
65673: LIST
65674: PPUSH
65675: LD_VAR 0 3
65679: PPUSH
65680: CALL 18588 0 3
65684: ST_TO_ADDR
// end ; end ;
65685: GO 65581
65687: POP
65688: POP
// if not lab or not mc_lab_upgrade [ i ] then
65689: LD_VAR 0 6
65693: NOT
65694: PUSH
65695: LD_EXP 103
65699: PUSH
65700: LD_VAR 0 2
65704: ARRAY
65705: NOT
65706: OR
65707: IFFALSE 65711
// continue ;
65709: GO 65481
// for j in lab do
65711: LD_ADDR_VAR 0 3
65715: PUSH
65716: LD_VAR 0 6
65720: PUSH
65721: FOR_IN
65722: IFFALSE 65887
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
65724: LD_VAR 0 3
65728: PPUSH
65729: CALL_OW 266
65733: PUSH
65734: LD_INT 6
65736: PUSH
65737: LD_INT 7
65739: PUSH
65740: EMPTY
65741: LIST
65742: LIST
65743: IN
65744: PUSH
65745: LD_VAR 0 3
65749: PPUSH
65750: CALL_OW 461
65754: PUSH
65755: LD_INT 1
65757: NONEQUAL
65758: AND
65759: IFFALSE 65885
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
65761: LD_VAR 0 3
65765: PPUSH
65766: LD_EXP 103
65770: PUSH
65771: LD_VAR 0 2
65775: ARRAY
65776: PUSH
65777: LD_INT 1
65779: ARRAY
65780: PPUSH
65781: CALL 25306 0 2
65785: IFFALSE 65885
// begin ComCancel ( j ) ;
65787: LD_VAR 0 3
65791: PPUSH
65792: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
65796: LD_VAR 0 3
65800: PPUSH
65801: LD_EXP 103
65805: PUSH
65806: LD_VAR 0 2
65810: ARRAY
65811: PUSH
65812: LD_INT 1
65814: ARRAY
65815: PPUSH
65816: CALL_OW 207
// if not j in mc_construct_list [ i ] then
65820: LD_VAR 0 3
65824: PUSH
65825: LD_EXP 76
65829: PUSH
65830: LD_VAR 0 2
65834: ARRAY
65835: IN
65836: NOT
65837: IFFALSE 65883
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65839: LD_ADDR_EXP 76
65843: PUSH
65844: LD_EXP 76
65848: PPUSH
65849: LD_VAR 0 2
65853: PUSH
65854: LD_EXP 76
65858: PUSH
65859: LD_VAR 0 2
65863: ARRAY
65864: PUSH
65865: LD_INT 1
65867: PLUS
65868: PUSH
65869: EMPTY
65870: LIST
65871: LIST
65872: PPUSH
65873: LD_VAR 0 3
65877: PPUSH
65878: CALL 18588 0 3
65882: ST_TO_ADDR
// break ;
65883: GO 65887
// end ; end ; end ;
65885: GO 65721
65887: POP
65888: POP
// end ;
65889: GO 65481
65891: POP
65892: POP
// end ;
65893: LD_VAR 0 1
65897: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
65898: LD_INT 0
65900: PPUSH
65901: PPUSH
65902: PPUSH
65903: PPUSH
65904: PPUSH
65905: PPUSH
65906: PPUSH
65907: PPUSH
65908: PPUSH
// if not mc_bases then
65909: LD_EXP 69
65913: NOT
65914: IFFALSE 65918
// exit ;
65916: GO 66323
// for i = 1 to mc_bases do
65918: LD_ADDR_VAR 0 2
65922: PUSH
65923: DOUBLE
65924: LD_INT 1
65926: DEC
65927: ST_TO_ADDR
65928: LD_EXP 69
65932: PUSH
65933: FOR_TO
65934: IFFALSE 66321
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
65936: LD_EXP 77
65940: PUSH
65941: LD_VAR 0 2
65945: ARRAY
65946: NOT
65947: PUSH
65948: LD_EXP 69
65952: PUSH
65953: LD_VAR 0 2
65957: ARRAY
65958: PPUSH
65959: LD_INT 30
65961: PUSH
65962: LD_INT 3
65964: PUSH
65965: EMPTY
65966: LIST
65967: LIST
65968: PPUSH
65969: CALL_OW 72
65973: NOT
65974: OR
65975: IFFALSE 65979
// continue ;
65977: GO 65933
// busy := false ;
65979: LD_ADDR_VAR 0 8
65983: PUSH
65984: LD_INT 0
65986: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65987: LD_ADDR_VAR 0 4
65991: PUSH
65992: LD_EXP 69
65996: PUSH
65997: LD_VAR 0 2
66001: ARRAY
66002: PPUSH
66003: LD_INT 30
66005: PUSH
66006: LD_INT 3
66008: PUSH
66009: EMPTY
66010: LIST
66011: LIST
66012: PPUSH
66013: CALL_OW 72
66017: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66018: LD_ADDR_VAR 0 6
66022: PUSH
66023: LD_EXP 77
66027: PUSH
66028: LD_VAR 0 2
66032: ARRAY
66033: PPUSH
66034: LD_INT 2
66036: PUSH
66037: LD_INT 30
66039: PUSH
66040: LD_INT 32
66042: PUSH
66043: EMPTY
66044: LIST
66045: LIST
66046: PUSH
66047: LD_INT 30
66049: PUSH
66050: LD_INT 33
66052: PUSH
66053: EMPTY
66054: LIST
66055: LIST
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: LIST
66061: PPUSH
66062: CALL_OW 72
66066: ST_TO_ADDR
// if not t then
66067: LD_VAR 0 6
66071: NOT
66072: IFFALSE 66076
// continue ;
66074: GO 65933
// for j in tmp do
66076: LD_ADDR_VAR 0 3
66080: PUSH
66081: LD_VAR 0 4
66085: PUSH
66086: FOR_IN
66087: IFFALSE 66117
// if not BuildingStatus ( j ) = bs_idle then
66089: LD_VAR 0 3
66093: PPUSH
66094: CALL_OW 461
66098: PUSH
66099: LD_INT 2
66101: EQUAL
66102: NOT
66103: IFFALSE 66115
// begin busy := true ;
66105: LD_ADDR_VAR 0 8
66109: PUSH
66110: LD_INT 1
66112: ST_TO_ADDR
// break ;
66113: GO 66117
// end ;
66115: GO 66086
66117: POP
66118: POP
// if busy then
66119: LD_VAR 0 8
66123: IFFALSE 66127
// continue ;
66125: GO 65933
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
66127: LD_ADDR_VAR 0 7
66131: PUSH
66132: LD_VAR 0 6
66136: PPUSH
66137: LD_INT 35
66139: PUSH
66140: LD_INT 0
66142: PUSH
66143: EMPTY
66144: LIST
66145: LIST
66146: PPUSH
66147: CALL_OW 72
66151: ST_TO_ADDR
// if tw then
66152: LD_VAR 0 7
66156: IFFALSE 66233
// begin tw := tw [ 1 ] ;
66158: LD_ADDR_VAR 0 7
66162: PUSH
66163: LD_VAR 0 7
66167: PUSH
66168: LD_INT 1
66170: ARRAY
66171: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
66172: LD_ADDR_VAR 0 9
66176: PUSH
66177: LD_VAR 0 7
66181: PPUSH
66182: LD_EXP 94
66186: PUSH
66187: LD_VAR 0 2
66191: ARRAY
66192: PPUSH
66193: CALL 23598 0 2
66197: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
66198: LD_EXP 108
66202: PUSH
66203: LD_VAR 0 2
66207: ARRAY
66208: IFFALSE 66231
// if not weapon in mc_allowed_tower_weapons [ i ] then
66210: LD_VAR 0 9
66214: PUSH
66215: LD_EXP 108
66219: PUSH
66220: LD_VAR 0 2
66224: ARRAY
66225: IN
66226: NOT
66227: IFFALSE 66231
// continue ;
66229: GO 65933
// end else
66231: GO 66296
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
66233: LD_ADDR_VAR 0 5
66237: PUSH
66238: LD_EXP 77
66242: PUSH
66243: LD_VAR 0 2
66247: ARRAY
66248: PPUSH
66249: LD_VAR 0 4
66253: PPUSH
66254: CALL 49887 0 2
66258: ST_TO_ADDR
// if not tmp2 then
66259: LD_VAR 0 5
66263: NOT
66264: IFFALSE 66268
// continue ;
66266: GO 65933
// tw := tmp2 [ 1 ] ;
66268: LD_ADDR_VAR 0 7
66272: PUSH
66273: LD_VAR 0 5
66277: PUSH
66278: LD_INT 1
66280: ARRAY
66281: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
66282: LD_ADDR_VAR 0 9
66286: PUSH
66287: LD_VAR 0 5
66291: PUSH
66292: LD_INT 2
66294: ARRAY
66295: ST_TO_ADDR
// end ; if not weapon then
66296: LD_VAR 0 9
66300: NOT
66301: IFFALSE 66305
// continue ;
66303: GO 65933
// ComPlaceWeapon ( tw , weapon ) ;
66305: LD_VAR 0 7
66309: PPUSH
66310: LD_VAR 0 9
66314: PPUSH
66315: CALL_OW 148
// end ;
66319: GO 65933
66321: POP
66322: POP
// end ;
66323: LD_VAR 0 1
66327: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
66328: LD_INT 0
66330: PPUSH
66331: PPUSH
66332: PPUSH
66333: PPUSH
66334: PPUSH
66335: PPUSH
66336: PPUSH
// if not mc_bases then
66337: LD_EXP 69
66341: NOT
66342: IFFALSE 66346
// exit ;
66344: GO 67114
// for i = 1 to mc_bases do
66346: LD_ADDR_VAR 0 2
66350: PUSH
66351: DOUBLE
66352: LD_INT 1
66354: DEC
66355: ST_TO_ADDR
66356: LD_EXP 69
66360: PUSH
66361: FOR_TO
66362: IFFALSE 67112
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
66364: LD_EXP 82
66368: PUSH
66369: LD_VAR 0 2
66373: ARRAY
66374: NOT
66375: PUSH
66376: LD_EXP 82
66380: PUSH
66381: LD_VAR 0 2
66385: ARRAY
66386: PUSH
66387: LD_EXP 83
66391: PUSH
66392: LD_VAR 0 2
66396: ARRAY
66397: EQUAL
66398: OR
66399: PUSH
66400: LD_EXP 92
66404: PUSH
66405: LD_VAR 0 2
66409: ARRAY
66410: OR
66411: IFFALSE 66415
// continue ;
66413: GO 66361
// if mc_miners [ i ] then
66415: LD_EXP 83
66419: PUSH
66420: LD_VAR 0 2
66424: ARRAY
66425: IFFALSE 66799
// begin for j = mc_miners [ i ] downto 1 do
66427: LD_ADDR_VAR 0 3
66431: PUSH
66432: DOUBLE
66433: LD_EXP 83
66437: PUSH
66438: LD_VAR 0 2
66442: ARRAY
66443: INC
66444: ST_TO_ADDR
66445: LD_INT 1
66447: PUSH
66448: FOR_DOWNTO
66449: IFFALSE 66797
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
66451: LD_EXP 83
66455: PUSH
66456: LD_VAR 0 2
66460: ARRAY
66461: PUSH
66462: LD_VAR 0 3
66466: ARRAY
66467: PPUSH
66468: CALL_OW 301
66472: PUSH
66473: LD_EXP 83
66477: PUSH
66478: LD_VAR 0 2
66482: ARRAY
66483: PUSH
66484: LD_VAR 0 3
66488: ARRAY
66489: PPUSH
66490: CALL_OW 257
66494: PUSH
66495: LD_INT 1
66497: NONEQUAL
66498: OR
66499: IFFALSE 66562
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
66501: LD_ADDR_VAR 0 5
66505: PUSH
66506: LD_EXP 83
66510: PUSH
66511: LD_VAR 0 2
66515: ARRAY
66516: PUSH
66517: LD_EXP 83
66521: PUSH
66522: LD_VAR 0 2
66526: ARRAY
66527: PUSH
66528: LD_VAR 0 3
66532: ARRAY
66533: DIFF
66534: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
66535: LD_ADDR_EXP 83
66539: PUSH
66540: LD_EXP 83
66544: PPUSH
66545: LD_VAR 0 2
66549: PPUSH
66550: LD_VAR 0 5
66554: PPUSH
66555: CALL_OW 1
66559: ST_TO_ADDR
// continue ;
66560: GO 66448
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
66562: LD_EXP 83
66566: PUSH
66567: LD_VAR 0 2
66571: ARRAY
66572: PUSH
66573: LD_VAR 0 3
66577: ARRAY
66578: PPUSH
66579: CALL_OW 257
66583: PUSH
66584: LD_INT 1
66586: EQUAL
66587: PUSH
66588: LD_EXP 83
66592: PUSH
66593: LD_VAR 0 2
66597: ARRAY
66598: PUSH
66599: LD_VAR 0 3
66603: ARRAY
66604: PPUSH
66605: CALL_OW 459
66609: NOT
66610: AND
66611: PUSH
66612: LD_EXP 83
66616: PUSH
66617: LD_VAR 0 2
66621: ARRAY
66622: PUSH
66623: LD_VAR 0 3
66627: ARRAY
66628: PPUSH
66629: CALL_OW 314
66633: NOT
66634: AND
66635: IFFALSE 66795
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
66637: LD_EXP 83
66641: PUSH
66642: LD_VAR 0 2
66646: ARRAY
66647: PUSH
66648: LD_VAR 0 3
66652: ARRAY
66653: PPUSH
66654: CALL_OW 310
66658: IFFALSE 66681
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
66660: LD_EXP 83
66664: PUSH
66665: LD_VAR 0 2
66669: ARRAY
66670: PUSH
66671: LD_VAR 0 3
66675: ARRAY
66676: PPUSH
66677: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
66681: LD_EXP 83
66685: PUSH
66686: LD_VAR 0 2
66690: ARRAY
66691: PUSH
66692: LD_VAR 0 3
66696: ARRAY
66697: PPUSH
66698: CALL_OW 314
66702: NOT
66703: IFFALSE 66795
// begin r := rand ( 1 , mc_mines [ i ] ) ;
66705: LD_ADDR_VAR 0 7
66709: PUSH
66710: LD_INT 1
66712: PPUSH
66713: LD_EXP 82
66717: PUSH
66718: LD_VAR 0 2
66722: ARRAY
66723: PPUSH
66724: CALL_OW 12
66728: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
66729: LD_EXP 83
66733: PUSH
66734: LD_VAR 0 2
66738: ARRAY
66739: PUSH
66740: LD_VAR 0 3
66744: ARRAY
66745: PPUSH
66746: LD_EXP 82
66750: PUSH
66751: LD_VAR 0 2
66755: ARRAY
66756: PUSH
66757: LD_VAR 0 7
66761: ARRAY
66762: PUSH
66763: LD_INT 1
66765: ARRAY
66766: PPUSH
66767: LD_EXP 82
66771: PUSH
66772: LD_VAR 0 2
66776: ARRAY
66777: PUSH
66778: LD_VAR 0 7
66782: ARRAY
66783: PUSH
66784: LD_INT 2
66786: ARRAY
66787: PPUSH
66788: LD_INT 0
66790: PPUSH
66791: CALL_OW 193
// end ; end ; end ;
66795: GO 66448
66797: POP
66798: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
66799: LD_ADDR_VAR 0 5
66803: PUSH
66804: LD_EXP 69
66808: PUSH
66809: LD_VAR 0 2
66813: ARRAY
66814: PPUSH
66815: LD_INT 2
66817: PUSH
66818: LD_INT 30
66820: PUSH
66821: LD_INT 4
66823: PUSH
66824: EMPTY
66825: LIST
66826: LIST
66827: PUSH
66828: LD_INT 30
66830: PUSH
66831: LD_INT 5
66833: PUSH
66834: EMPTY
66835: LIST
66836: LIST
66837: PUSH
66838: LD_INT 30
66840: PUSH
66841: LD_INT 32
66843: PUSH
66844: EMPTY
66845: LIST
66846: LIST
66847: PUSH
66848: EMPTY
66849: LIST
66850: LIST
66851: LIST
66852: LIST
66853: PPUSH
66854: CALL_OW 72
66858: ST_TO_ADDR
// if not tmp then
66859: LD_VAR 0 5
66863: NOT
66864: IFFALSE 66868
// continue ;
66866: GO 66361
// list := [ ] ;
66868: LD_ADDR_VAR 0 6
66872: PUSH
66873: EMPTY
66874: ST_TO_ADDR
// for j in tmp do
66875: LD_ADDR_VAR 0 3
66879: PUSH
66880: LD_VAR 0 5
66884: PUSH
66885: FOR_IN
66886: IFFALSE 66955
// begin for k in UnitsInside ( j ) do
66888: LD_ADDR_VAR 0 4
66892: PUSH
66893: LD_VAR 0 3
66897: PPUSH
66898: CALL_OW 313
66902: PUSH
66903: FOR_IN
66904: IFFALSE 66951
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
66906: LD_VAR 0 4
66910: PPUSH
66911: CALL_OW 257
66915: PUSH
66916: LD_INT 1
66918: EQUAL
66919: PUSH
66920: LD_VAR 0 4
66924: PPUSH
66925: CALL_OW 459
66929: NOT
66930: AND
66931: IFFALSE 66949
// list := list ^ k ;
66933: LD_ADDR_VAR 0 6
66937: PUSH
66938: LD_VAR 0 6
66942: PUSH
66943: LD_VAR 0 4
66947: ADD
66948: ST_TO_ADDR
66949: GO 66903
66951: POP
66952: POP
// end ;
66953: GO 66885
66955: POP
66956: POP
// list := list diff mc_miners [ i ] ;
66957: LD_ADDR_VAR 0 6
66961: PUSH
66962: LD_VAR 0 6
66966: PUSH
66967: LD_EXP 83
66971: PUSH
66972: LD_VAR 0 2
66976: ARRAY
66977: DIFF
66978: ST_TO_ADDR
// if not list then
66979: LD_VAR 0 6
66983: NOT
66984: IFFALSE 66988
// continue ;
66986: GO 66361
// k := mc_mines [ i ] - mc_miners [ i ] ;
66988: LD_ADDR_VAR 0 4
66992: PUSH
66993: LD_EXP 82
66997: PUSH
66998: LD_VAR 0 2
67002: ARRAY
67003: PUSH
67004: LD_EXP 83
67008: PUSH
67009: LD_VAR 0 2
67013: ARRAY
67014: MINUS
67015: ST_TO_ADDR
// if k > list then
67016: LD_VAR 0 4
67020: PUSH
67021: LD_VAR 0 6
67025: GREATER
67026: IFFALSE 67038
// k := list ;
67028: LD_ADDR_VAR 0 4
67032: PUSH
67033: LD_VAR 0 6
67037: ST_TO_ADDR
// for j = 1 to k do
67038: LD_ADDR_VAR 0 3
67042: PUSH
67043: DOUBLE
67044: LD_INT 1
67046: DEC
67047: ST_TO_ADDR
67048: LD_VAR 0 4
67052: PUSH
67053: FOR_TO
67054: IFFALSE 67108
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
67056: LD_ADDR_EXP 83
67060: PUSH
67061: LD_EXP 83
67065: PPUSH
67066: LD_VAR 0 2
67070: PUSH
67071: LD_EXP 83
67075: PUSH
67076: LD_VAR 0 2
67080: ARRAY
67081: PUSH
67082: LD_INT 1
67084: PLUS
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: PPUSH
67090: LD_VAR 0 6
67094: PUSH
67095: LD_VAR 0 3
67099: ARRAY
67100: PPUSH
67101: CALL 18588 0 3
67105: ST_TO_ADDR
67106: GO 67053
67108: POP
67109: POP
// end ;
67110: GO 66361
67112: POP
67113: POP
// end ;
67114: LD_VAR 0 1
67118: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
67119: LD_INT 0
67121: PPUSH
67122: PPUSH
67123: PPUSH
67124: PPUSH
67125: PPUSH
67126: PPUSH
67127: PPUSH
67128: PPUSH
67129: PPUSH
67130: PPUSH
67131: PPUSH
// if not mc_bases then
67132: LD_EXP 69
67136: NOT
67137: IFFALSE 67141
// exit ;
67139: GO 68964
// for i = 1 to mc_bases do
67141: LD_ADDR_VAR 0 2
67145: PUSH
67146: DOUBLE
67147: LD_INT 1
67149: DEC
67150: ST_TO_ADDR
67151: LD_EXP 69
67155: PUSH
67156: FOR_TO
67157: IFFALSE 68962
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
67159: LD_EXP 69
67163: PUSH
67164: LD_VAR 0 2
67168: ARRAY
67169: NOT
67170: PUSH
67171: LD_EXP 76
67175: PUSH
67176: LD_VAR 0 2
67180: ARRAY
67181: OR
67182: IFFALSE 67186
// continue ;
67184: GO 67156
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
67186: LD_EXP 85
67190: PUSH
67191: LD_VAR 0 2
67195: ARRAY
67196: NOT
67197: PUSH
67198: LD_EXP 86
67202: PUSH
67203: LD_VAR 0 2
67207: ARRAY
67208: AND
67209: IFFALSE 67247
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
67211: LD_ADDR_EXP 86
67215: PUSH
67216: LD_EXP 86
67220: PPUSH
67221: LD_VAR 0 2
67225: PPUSH
67226: EMPTY
67227: PPUSH
67228: CALL_OW 1
67232: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
67233: LD_VAR 0 2
67237: PPUSH
67238: LD_INT 107
67240: PPUSH
67241: CALL 58015 0 2
// continue ;
67245: GO 67156
// end ; target := [ ] ;
67247: LD_ADDR_VAR 0 7
67251: PUSH
67252: EMPTY
67253: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
67254: LD_ADDR_VAR 0 6
67258: PUSH
67259: LD_EXP 69
67263: PUSH
67264: LD_VAR 0 2
67268: ARRAY
67269: PUSH
67270: LD_INT 1
67272: ARRAY
67273: PPUSH
67274: CALL_OW 255
67278: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67279: LD_ADDR_VAR 0 9
67283: PUSH
67284: LD_EXP 69
67288: PUSH
67289: LD_VAR 0 2
67293: ARRAY
67294: PPUSH
67295: LD_INT 2
67297: PUSH
67298: LD_INT 30
67300: PUSH
67301: LD_INT 0
67303: PUSH
67304: EMPTY
67305: LIST
67306: LIST
67307: PUSH
67308: LD_INT 30
67310: PUSH
67311: LD_INT 1
67313: PUSH
67314: EMPTY
67315: LIST
67316: LIST
67317: PUSH
67318: EMPTY
67319: LIST
67320: LIST
67321: LIST
67322: PPUSH
67323: CALL_OW 72
67327: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
67328: LD_ADDR_VAR 0 3
67332: PUSH
67333: DOUBLE
67334: LD_EXP 85
67338: PUSH
67339: LD_VAR 0 2
67343: ARRAY
67344: INC
67345: ST_TO_ADDR
67346: LD_INT 1
67348: PUSH
67349: FOR_DOWNTO
67350: IFFALSE 67595
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
67352: LD_EXP 85
67356: PUSH
67357: LD_VAR 0 2
67361: ARRAY
67362: PUSH
67363: LD_VAR 0 3
67367: ARRAY
67368: PUSH
67369: LD_INT 2
67371: ARRAY
67372: PPUSH
67373: LD_EXP 85
67377: PUSH
67378: LD_VAR 0 2
67382: ARRAY
67383: PUSH
67384: LD_VAR 0 3
67388: ARRAY
67389: PUSH
67390: LD_INT 3
67392: ARRAY
67393: PPUSH
67394: CALL_OW 488
67398: PUSH
67399: LD_EXP 85
67403: PUSH
67404: LD_VAR 0 2
67408: ARRAY
67409: PUSH
67410: LD_VAR 0 3
67414: ARRAY
67415: PUSH
67416: LD_INT 2
67418: ARRAY
67419: PPUSH
67420: LD_EXP 85
67424: PUSH
67425: LD_VAR 0 2
67429: ARRAY
67430: PUSH
67431: LD_VAR 0 3
67435: ARRAY
67436: PUSH
67437: LD_INT 3
67439: ARRAY
67440: PPUSH
67441: CALL_OW 284
67445: PUSH
67446: LD_INT 0
67448: EQUAL
67449: AND
67450: IFFALSE 67505
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
67452: LD_ADDR_VAR 0 5
67456: PUSH
67457: LD_EXP 85
67461: PUSH
67462: LD_VAR 0 2
67466: ARRAY
67467: PPUSH
67468: LD_VAR 0 3
67472: PPUSH
67473: CALL_OW 3
67477: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
67478: LD_ADDR_EXP 85
67482: PUSH
67483: LD_EXP 85
67487: PPUSH
67488: LD_VAR 0 2
67492: PPUSH
67493: LD_VAR 0 5
67497: PPUSH
67498: CALL_OW 1
67502: ST_TO_ADDR
// continue ;
67503: GO 67349
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
67505: LD_VAR 0 6
67509: PPUSH
67510: LD_EXP 85
67514: PUSH
67515: LD_VAR 0 2
67519: ARRAY
67520: PUSH
67521: LD_VAR 0 3
67525: ARRAY
67526: PUSH
67527: LD_INT 2
67529: ARRAY
67530: PPUSH
67531: LD_EXP 85
67535: PUSH
67536: LD_VAR 0 2
67540: ARRAY
67541: PUSH
67542: LD_VAR 0 3
67546: ARRAY
67547: PUSH
67548: LD_INT 3
67550: ARRAY
67551: PPUSH
67552: LD_INT 30
67554: PPUSH
67555: CALL 19484 0 4
67559: PUSH
67560: LD_INT 4
67562: ARRAY
67563: PUSH
67564: LD_INT 0
67566: EQUAL
67567: IFFALSE 67593
// begin target := mc_crates [ i ] [ j ] ;
67569: LD_ADDR_VAR 0 7
67573: PUSH
67574: LD_EXP 85
67578: PUSH
67579: LD_VAR 0 2
67583: ARRAY
67584: PUSH
67585: LD_VAR 0 3
67589: ARRAY
67590: ST_TO_ADDR
// break ;
67591: GO 67595
// end ; end ;
67593: GO 67349
67595: POP
67596: POP
// if not target then
67597: LD_VAR 0 7
67601: NOT
67602: IFFALSE 67606
// continue ;
67604: GO 67156
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
67606: LD_ADDR_VAR 0 8
67610: PUSH
67611: LD_EXP 88
67615: PUSH
67616: LD_VAR 0 2
67620: ARRAY
67621: PPUSH
67622: LD_INT 2
67624: PUSH
67625: LD_INT 3
67627: PUSH
67628: LD_INT 58
67630: PUSH
67631: EMPTY
67632: LIST
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PUSH
67638: LD_INT 61
67640: PUSH
67641: EMPTY
67642: LIST
67643: PUSH
67644: LD_INT 33
67646: PUSH
67647: LD_INT 5
67649: PUSH
67650: EMPTY
67651: LIST
67652: LIST
67653: PUSH
67654: LD_INT 33
67656: PUSH
67657: LD_INT 3
67659: PUSH
67660: EMPTY
67661: LIST
67662: LIST
67663: PUSH
67664: EMPTY
67665: LIST
67666: LIST
67667: LIST
67668: LIST
67669: LIST
67670: PUSH
67671: LD_INT 2
67673: PUSH
67674: LD_INT 34
67676: PUSH
67677: LD_INT 32
67679: PUSH
67680: EMPTY
67681: LIST
67682: LIST
67683: PUSH
67684: LD_INT 34
67686: PUSH
67687: LD_INT 51
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: PUSH
67694: LD_INT 34
67696: PUSH
67697: LD_INT 12
67699: PUSH
67700: EMPTY
67701: LIST
67702: LIST
67703: PUSH
67704: EMPTY
67705: LIST
67706: LIST
67707: LIST
67708: LIST
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: PPUSH
67714: CALL_OW 72
67718: ST_TO_ADDR
// if not cargo then
67719: LD_VAR 0 8
67723: NOT
67724: IFFALSE 68430
// begin if mc_crates_collector [ i ] < 5 then
67726: LD_EXP 86
67730: PUSH
67731: LD_VAR 0 2
67735: ARRAY
67736: PUSH
67737: LD_INT 5
67739: LESS
67740: IFFALSE 68106
// begin if mc_ape [ i ] then
67742: LD_EXP 98
67746: PUSH
67747: LD_VAR 0 2
67751: ARRAY
67752: IFFALSE 67799
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
67754: LD_ADDR_VAR 0 5
67758: PUSH
67759: LD_EXP 98
67763: PUSH
67764: LD_VAR 0 2
67768: ARRAY
67769: PPUSH
67770: LD_INT 25
67772: PUSH
67773: LD_INT 16
67775: PUSH
67776: EMPTY
67777: LIST
67778: LIST
67779: PUSH
67780: LD_INT 24
67782: PUSH
67783: LD_INT 750
67785: PUSH
67786: EMPTY
67787: LIST
67788: LIST
67789: PUSH
67790: EMPTY
67791: LIST
67792: LIST
67793: PPUSH
67794: CALL_OW 72
67798: ST_TO_ADDR
// if not tmp then
67799: LD_VAR 0 5
67803: NOT
67804: IFFALSE 67851
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
67806: LD_ADDR_VAR 0 5
67810: PUSH
67811: LD_EXP 69
67815: PUSH
67816: LD_VAR 0 2
67820: ARRAY
67821: PPUSH
67822: LD_INT 25
67824: PUSH
67825: LD_INT 2
67827: PUSH
67828: EMPTY
67829: LIST
67830: LIST
67831: PUSH
67832: LD_INT 24
67834: PUSH
67835: LD_INT 750
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: PUSH
67842: EMPTY
67843: LIST
67844: LIST
67845: PPUSH
67846: CALL_OW 72
67850: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
67851: LD_EXP 98
67855: PUSH
67856: LD_VAR 0 2
67860: ARRAY
67861: PUSH
67862: LD_EXP 69
67866: PUSH
67867: LD_VAR 0 2
67871: ARRAY
67872: PPUSH
67873: LD_INT 25
67875: PUSH
67876: LD_INT 2
67878: PUSH
67879: EMPTY
67880: LIST
67881: LIST
67882: PUSH
67883: LD_INT 24
67885: PUSH
67886: LD_INT 750
67888: PUSH
67889: EMPTY
67890: LIST
67891: LIST
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: PPUSH
67897: CALL_OW 72
67901: AND
67902: PUSH
67903: LD_VAR 0 5
67907: PUSH
67908: LD_INT 5
67910: LESS
67911: AND
67912: IFFALSE 67994
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
67914: LD_ADDR_VAR 0 3
67918: PUSH
67919: LD_EXP 69
67923: PUSH
67924: LD_VAR 0 2
67928: ARRAY
67929: PPUSH
67930: LD_INT 25
67932: PUSH
67933: LD_INT 2
67935: PUSH
67936: EMPTY
67937: LIST
67938: LIST
67939: PUSH
67940: LD_INT 24
67942: PUSH
67943: LD_INT 750
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: EMPTY
67951: LIST
67952: LIST
67953: PPUSH
67954: CALL_OW 72
67958: PUSH
67959: FOR_IN
67960: IFFALSE 67992
// begin tmp := tmp union j ;
67962: LD_ADDR_VAR 0 5
67966: PUSH
67967: LD_VAR 0 5
67971: PUSH
67972: LD_VAR 0 3
67976: UNION
67977: ST_TO_ADDR
// if tmp >= 5 then
67978: LD_VAR 0 5
67982: PUSH
67983: LD_INT 5
67985: GREATEREQUAL
67986: IFFALSE 67990
// break ;
67988: GO 67992
// end ;
67990: GO 67959
67992: POP
67993: POP
// end ; if not tmp then
67994: LD_VAR 0 5
67998: NOT
67999: IFFALSE 68003
// continue ;
68001: GO 67156
// for j in tmp do
68003: LD_ADDR_VAR 0 3
68007: PUSH
68008: LD_VAR 0 5
68012: PUSH
68013: FOR_IN
68014: IFFALSE 68104
// if not GetTag ( j ) then
68016: LD_VAR 0 3
68020: PPUSH
68021: CALL_OW 110
68025: NOT
68026: IFFALSE 68102
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
68028: LD_ADDR_EXP 86
68032: PUSH
68033: LD_EXP 86
68037: PPUSH
68038: LD_VAR 0 2
68042: PUSH
68043: LD_EXP 86
68047: PUSH
68048: LD_VAR 0 2
68052: ARRAY
68053: PUSH
68054: LD_INT 1
68056: PLUS
68057: PUSH
68058: EMPTY
68059: LIST
68060: LIST
68061: PPUSH
68062: LD_VAR 0 3
68066: PPUSH
68067: CALL 18588 0 3
68071: ST_TO_ADDR
// SetTag ( j , 107 ) ;
68072: LD_VAR 0 3
68076: PPUSH
68077: LD_INT 107
68079: PPUSH
68080: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
68084: LD_EXP 86
68088: PUSH
68089: LD_VAR 0 2
68093: ARRAY
68094: PUSH
68095: LD_INT 5
68097: GREATEREQUAL
68098: IFFALSE 68102
// break ;
68100: GO 68104
// end ;
68102: GO 68013
68104: POP
68105: POP
// end ; if mc_crates_collector [ i ] and target then
68106: LD_EXP 86
68110: PUSH
68111: LD_VAR 0 2
68115: ARRAY
68116: PUSH
68117: LD_VAR 0 7
68121: AND
68122: IFFALSE 68428
// begin if mc_crates_collector [ i ] < target [ 1 ] then
68124: LD_EXP 86
68128: PUSH
68129: LD_VAR 0 2
68133: ARRAY
68134: PUSH
68135: LD_VAR 0 7
68139: PUSH
68140: LD_INT 1
68142: ARRAY
68143: LESS
68144: IFFALSE 68164
// tmp := mc_crates_collector [ i ] else
68146: LD_ADDR_VAR 0 5
68150: PUSH
68151: LD_EXP 86
68155: PUSH
68156: LD_VAR 0 2
68160: ARRAY
68161: ST_TO_ADDR
68162: GO 68178
// tmp := target [ 1 ] ;
68164: LD_ADDR_VAR 0 5
68168: PUSH
68169: LD_VAR 0 7
68173: PUSH
68174: LD_INT 1
68176: ARRAY
68177: ST_TO_ADDR
// k := 0 ;
68178: LD_ADDR_VAR 0 4
68182: PUSH
68183: LD_INT 0
68185: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
68186: LD_ADDR_VAR 0 3
68190: PUSH
68191: LD_EXP 86
68195: PUSH
68196: LD_VAR 0 2
68200: ARRAY
68201: PUSH
68202: FOR_IN
68203: IFFALSE 68426
// begin k := k + 1 ;
68205: LD_ADDR_VAR 0 4
68209: PUSH
68210: LD_VAR 0 4
68214: PUSH
68215: LD_INT 1
68217: PLUS
68218: ST_TO_ADDR
// if k > tmp then
68219: LD_VAR 0 4
68223: PUSH
68224: LD_VAR 0 5
68228: GREATER
68229: IFFALSE 68233
// break ;
68231: GO 68426
// if not GetClass ( j ) in [ 2 , 16 ] then
68233: LD_VAR 0 3
68237: PPUSH
68238: CALL_OW 257
68242: PUSH
68243: LD_INT 2
68245: PUSH
68246: LD_INT 16
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: IN
68253: NOT
68254: IFFALSE 68307
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
68256: LD_ADDR_EXP 86
68260: PUSH
68261: LD_EXP 86
68265: PPUSH
68266: LD_VAR 0 2
68270: PPUSH
68271: LD_EXP 86
68275: PUSH
68276: LD_VAR 0 2
68280: ARRAY
68281: PUSH
68282: LD_VAR 0 3
68286: DIFF
68287: PPUSH
68288: CALL_OW 1
68292: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68293: LD_VAR 0 3
68297: PPUSH
68298: LD_INT 0
68300: PPUSH
68301: CALL_OW 109
// continue ;
68305: GO 68202
// end ; if IsInUnit ( j ) then
68307: LD_VAR 0 3
68311: PPUSH
68312: CALL_OW 310
68316: IFFALSE 68327
// ComExitBuilding ( j ) ;
68318: LD_VAR 0 3
68322: PPUSH
68323: CALL_OW 122
// wait ( 3 ) ;
68327: LD_INT 3
68329: PPUSH
68330: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
68334: LD_VAR 0 3
68338: PPUSH
68339: CALL_OW 314
68343: PUSH
68344: LD_VAR 0 6
68348: PPUSH
68349: LD_VAR 0 7
68353: PUSH
68354: LD_INT 2
68356: ARRAY
68357: PPUSH
68358: LD_VAR 0 7
68362: PUSH
68363: LD_INT 3
68365: ARRAY
68366: PPUSH
68367: LD_INT 30
68369: PPUSH
68370: CALL 19484 0 4
68374: PUSH
68375: LD_INT 4
68377: ARRAY
68378: AND
68379: IFFALSE 68397
// ComStandNearbyBuilding ( j , depot ) else
68381: LD_VAR 0 3
68385: PPUSH
68386: LD_VAR 0 9
68390: PPUSH
68391: CALL 15166 0 2
68395: GO 68424
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68397: LD_VAR 0 3
68401: PPUSH
68402: LD_VAR 0 7
68406: PUSH
68407: LD_INT 2
68409: ARRAY
68410: PPUSH
68411: LD_VAR 0 7
68415: PUSH
68416: LD_INT 3
68418: ARRAY
68419: PPUSH
68420: CALL_OW 117
// end ;
68424: GO 68202
68426: POP
68427: POP
// end ; end else
68428: GO 68960
// begin for j in cargo do
68430: LD_ADDR_VAR 0 3
68434: PUSH
68435: LD_VAR 0 8
68439: PUSH
68440: FOR_IN
68441: IFFALSE 68958
// begin if GetTag ( j ) <> 0 then
68443: LD_VAR 0 3
68447: PPUSH
68448: CALL_OW 110
68452: PUSH
68453: LD_INT 0
68455: NONEQUAL
68456: IFFALSE 68460
// continue ;
68458: GO 68440
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
68460: LD_VAR 0 3
68464: PPUSH
68465: CALL_OW 256
68469: PUSH
68470: LD_INT 1000
68472: LESS
68473: PUSH
68474: LD_VAR 0 3
68478: PPUSH
68479: LD_EXP 93
68483: PUSH
68484: LD_VAR 0 2
68488: ARRAY
68489: PPUSH
68490: CALL_OW 308
68494: NOT
68495: AND
68496: IFFALSE 68518
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68498: LD_VAR 0 3
68502: PPUSH
68503: LD_EXP 93
68507: PUSH
68508: LD_VAR 0 2
68512: ARRAY
68513: PPUSH
68514: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
68518: LD_VAR 0 3
68522: PPUSH
68523: CALL_OW 256
68527: PUSH
68528: LD_INT 1000
68530: LESS
68531: PUSH
68532: LD_VAR 0 3
68536: PPUSH
68537: LD_EXP 93
68541: PUSH
68542: LD_VAR 0 2
68546: ARRAY
68547: PPUSH
68548: CALL_OW 308
68552: AND
68553: IFFALSE 68557
// continue ;
68555: GO 68440
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
68557: LD_VAR 0 3
68561: PPUSH
68562: CALL_OW 262
68566: PUSH
68567: LD_INT 2
68569: EQUAL
68570: PUSH
68571: LD_VAR 0 3
68575: PPUSH
68576: CALL_OW 261
68580: PUSH
68581: LD_INT 15
68583: LESS
68584: AND
68585: IFFALSE 68589
// continue ;
68587: GO 68440
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
68589: LD_VAR 0 3
68593: PPUSH
68594: CALL_OW 262
68598: PUSH
68599: LD_INT 1
68601: EQUAL
68602: PUSH
68603: LD_VAR 0 3
68607: PPUSH
68608: CALL_OW 261
68612: PUSH
68613: LD_INT 10
68615: LESS
68616: AND
68617: IFFALSE 68897
// begin if not depot then
68619: LD_VAR 0 9
68623: NOT
68624: IFFALSE 68628
// continue ;
68626: GO 68440
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
68628: LD_VAR 0 3
68632: PPUSH
68633: LD_VAR 0 9
68637: PPUSH
68638: LD_VAR 0 3
68642: PPUSH
68643: CALL_OW 74
68647: PPUSH
68648: CALL_OW 296
68652: PUSH
68653: LD_INT 6
68655: LESS
68656: IFFALSE 68672
// SetFuel ( j , 100 ) else
68658: LD_VAR 0 3
68662: PPUSH
68663: LD_INT 100
68665: PPUSH
68666: CALL_OW 240
68670: GO 68897
// if GetFuel ( j ) = 0 then
68672: LD_VAR 0 3
68676: PPUSH
68677: CALL_OW 261
68681: PUSH
68682: LD_INT 0
68684: EQUAL
68685: IFFALSE 68897
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
68687: LD_ADDR_EXP 88
68691: PUSH
68692: LD_EXP 88
68696: PPUSH
68697: LD_VAR 0 2
68701: PPUSH
68702: LD_EXP 88
68706: PUSH
68707: LD_VAR 0 2
68711: ARRAY
68712: PUSH
68713: LD_VAR 0 3
68717: DIFF
68718: PPUSH
68719: CALL_OW 1
68723: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
68724: LD_VAR 0 3
68728: PPUSH
68729: CALL_OW 263
68733: PUSH
68734: LD_INT 1
68736: EQUAL
68737: IFFALSE 68753
// ComExitVehicle ( IsInUnit ( j ) ) ;
68739: LD_VAR 0 3
68743: PPUSH
68744: CALL_OW 310
68748: PPUSH
68749: CALL_OW 121
// if GetControl ( j ) = control_remote then
68753: LD_VAR 0 3
68757: PPUSH
68758: CALL_OW 263
68762: PUSH
68763: LD_INT 2
68765: EQUAL
68766: IFFALSE 68777
// ComUnlink ( j ) ;
68768: LD_VAR 0 3
68772: PPUSH
68773: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
68777: LD_ADDR_VAR 0 10
68781: PUSH
68782: LD_VAR 0 2
68786: PPUSH
68787: LD_INT 3
68789: PPUSH
68790: CALL 78536 0 2
68794: ST_TO_ADDR
// if fac then
68795: LD_VAR 0 10
68799: IFFALSE 68895
// begin for k in fac do
68801: LD_ADDR_VAR 0 4
68805: PUSH
68806: LD_VAR 0 10
68810: PUSH
68811: FOR_IN
68812: IFFALSE 68893
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
68814: LD_ADDR_VAR 0 11
68818: PUSH
68819: LD_VAR 0 10
68823: PPUSH
68824: LD_VAR 0 3
68828: PPUSH
68829: CALL_OW 265
68833: PPUSH
68834: LD_VAR 0 3
68838: PPUSH
68839: CALL_OW 262
68843: PPUSH
68844: LD_VAR 0 3
68848: PPUSH
68849: CALL_OW 263
68853: PPUSH
68854: LD_VAR 0 3
68858: PPUSH
68859: CALL_OW 264
68863: PPUSH
68864: CALL 16084 0 5
68868: ST_TO_ADDR
// if components then
68869: LD_VAR 0 11
68873: IFFALSE 68891
// begin MC_InsertProduceList ( i , components ) ;
68875: LD_VAR 0 2
68879: PPUSH
68880: LD_VAR 0 11
68884: PPUSH
68885: CALL 78081 0 2
// break ;
68889: GO 68893
// end ; end ;
68891: GO 68811
68893: POP
68894: POP
// end ; continue ;
68895: GO 68440
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
68897: LD_VAR 0 3
68901: PPUSH
68902: LD_INT 1
68904: PPUSH
68905: CALL_OW 289
68909: PUSH
68910: LD_INT 100
68912: LESS
68913: PUSH
68914: LD_VAR 0 3
68918: PPUSH
68919: CALL_OW 314
68923: NOT
68924: AND
68925: IFFALSE 68954
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68927: LD_VAR 0 3
68931: PPUSH
68932: LD_VAR 0 7
68936: PUSH
68937: LD_INT 2
68939: ARRAY
68940: PPUSH
68941: LD_VAR 0 7
68945: PUSH
68946: LD_INT 3
68948: ARRAY
68949: PPUSH
68950: CALL_OW 117
// break ;
68954: GO 68958
// end ;
68956: GO 68440
68958: POP
68959: POP
// end ; end ;
68960: GO 67156
68962: POP
68963: POP
// end ;
68964: LD_VAR 0 1
68968: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
68969: LD_INT 0
68971: PPUSH
68972: PPUSH
68973: PPUSH
68974: PPUSH
// if not mc_bases then
68975: LD_EXP 69
68979: NOT
68980: IFFALSE 68984
// exit ;
68982: GO 69145
// for i = 1 to mc_bases do
68984: LD_ADDR_VAR 0 2
68988: PUSH
68989: DOUBLE
68990: LD_INT 1
68992: DEC
68993: ST_TO_ADDR
68994: LD_EXP 69
68998: PUSH
68999: FOR_TO
69000: IFFALSE 69143
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
69002: LD_ADDR_VAR 0 4
69006: PUSH
69007: LD_EXP 88
69011: PUSH
69012: LD_VAR 0 2
69016: ARRAY
69017: PUSH
69018: LD_EXP 91
69022: PUSH
69023: LD_VAR 0 2
69027: ARRAY
69028: UNION
69029: PPUSH
69030: LD_INT 33
69032: PUSH
69033: LD_INT 2
69035: PUSH
69036: EMPTY
69037: LIST
69038: LIST
69039: PPUSH
69040: CALL_OW 72
69044: ST_TO_ADDR
// if tmp then
69045: LD_VAR 0 4
69049: IFFALSE 69141
// for j in tmp do
69051: LD_ADDR_VAR 0 3
69055: PUSH
69056: LD_VAR 0 4
69060: PUSH
69061: FOR_IN
69062: IFFALSE 69139
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
69064: LD_VAR 0 3
69068: PPUSH
69069: CALL_OW 312
69073: NOT
69074: PUSH
69075: LD_VAR 0 3
69079: PPUSH
69080: CALL_OW 256
69084: PUSH
69085: LD_INT 250
69087: GREATEREQUAL
69088: AND
69089: IFFALSE 69102
// Connect ( j ) else
69091: LD_VAR 0 3
69095: PPUSH
69096: CALL 21559 0 1
69100: GO 69137
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
69102: LD_VAR 0 3
69106: PPUSH
69107: CALL_OW 256
69111: PUSH
69112: LD_INT 250
69114: LESS
69115: PUSH
69116: LD_VAR 0 3
69120: PPUSH
69121: CALL_OW 312
69125: AND
69126: IFFALSE 69137
// ComUnlink ( j ) ;
69128: LD_VAR 0 3
69132: PPUSH
69133: CALL_OW 136
69137: GO 69061
69139: POP
69140: POP
// end ;
69141: GO 68999
69143: POP
69144: POP
// end ;
69145: LD_VAR 0 1
69149: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
69150: LD_INT 0
69152: PPUSH
69153: PPUSH
69154: PPUSH
69155: PPUSH
69156: PPUSH
// if not mc_bases then
69157: LD_EXP 69
69161: NOT
69162: IFFALSE 69166
// exit ;
69164: GO 69611
// for i = 1 to mc_bases do
69166: LD_ADDR_VAR 0 2
69170: PUSH
69171: DOUBLE
69172: LD_INT 1
69174: DEC
69175: ST_TO_ADDR
69176: LD_EXP 69
69180: PUSH
69181: FOR_TO
69182: IFFALSE 69609
// begin if not mc_produce [ i ] then
69184: LD_EXP 90
69188: PUSH
69189: LD_VAR 0 2
69193: ARRAY
69194: NOT
69195: IFFALSE 69199
// continue ;
69197: GO 69181
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69199: LD_ADDR_VAR 0 5
69203: PUSH
69204: LD_EXP 69
69208: PUSH
69209: LD_VAR 0 2
69213: ARRAY
69214: PPUSH
69215: LD_INT 30
69217: PUSH
69218: LD_INT 3
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: PPUSH
69225: CALL_OW 72
69229: ST_TO_ADDR
// if not fac then
69230: LD_VAR 0 5
69234: NOT
69235: IFFALSE 69239
// continue ;
69237: GO 69181
// for j in fac do
69239: LD_ADDR_VAR 0 3
69243: PUSH
69244: LD_VAR 0 5
69248: PUSH
69249: FOR_IN
69250: IFFALSE 69605
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
69252: LD_VAR 0 3
69256: PPUSH
69257: CALL_OW 461
69261: PUSH
69262: LD_INT 2
69264: NONEQUAL
69265: PUSH
69266: LD_VAR 0 3
69270: PPUSH
69271: LD_INT 15
69273: PPUSH
69274: CALL 21187 0 2
69278: PUSH
69279: LD_INT 4
69281: ARRAY
69282: OR
69283: IFFALSE 69287
// continue ;
69285: GO 69249
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
69287: LD_VAR 0 3
69291: PPUSH
69292: LD_EXP 90
69296: PUSH
69297: LD_VAR 0 2
69301: ARRAY
69302: PUSH
69303: LD_INT 1
69305: ARRAY
69306: PUSH
69307: LD_INT 1
69309: ARRAY
69310: PPUSH
69311: LD_EXP 90
69315: PUSH
69316: LD_VAR 0 2
69320: ARRAY
69321: PUSH
69322: LD_INT 1
69324: ARRAY
69325: PUSH
69326: LD_INT 2
69328: ARRAY
69329: PPUSH
69330: LD_EXP 90
69334: PUSH
69335: LD_VAR 0 2
69339: ARRAY
69340: PUSH
69341: LD_INT 1
69343: ARRAY
69344: PUSH
69345: LD_INT 3
69347: ARRAY
69348: PPUSH
69349: LD_EXP 90
69353: PUSH
69354: LD_VAR 0 2
69358: ARRAY
69359: PUSH
69360: LD_INT 1
69362: ARRAY
69363: PUSH
69364: LD_INT 4
69366: ARRAY
69367: PPUSH
69368: CALL_OW 448
69372: PUSH
69373: LD_VAR 0 3
69377: PPUSH
69378: LD_EXP 90
69382: PUSH
69383: LD_VAR 0 2
69387: ARRAY
69388: PUSH
69389: LD_INT 1
69391: ARRAY
69392: PUSH
69393: LD_INT 1
69395: ARRAY
69396: PUSH
69397: LD_EXP 90
69401: PUSH
69402: LD_VAR 0 2
69406: ARRAY
69407: PUSH
69408: LD_INT 1
69410: ARRAY
69411: PUSH
69412: LD_INT 2
69414: ARRAY
69415: PUSH
69416: LD_EXP 90
69420: PUSH
69421: LD_VAR 0 2
69425: ARRAY
69426: PUSH
69427: LD_INT 1
69429: ARRAY
69430: PUSH
69431: LD_INT 3
69433: ARRAY
69434: PUSH
69435: LD_EXP 90
69439: PUSH
69440: LD_VAR 0 2
69444: ARRAY
69445: PUSH
69446: LD_INT 1
69448: ARRAY
69449: PUSH
69450: LD_INT 4
69452: ARRAY
69453: PUSH
69454: EMPTY
69455: LIST
69456: LIST
69457: LIST
69458: LIST
69459: PPUSH
69460: CALL 24954 0 2
69464: AND
69465: IFFALSE 69603
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
69467: LD_VAR 0 3
69471: PPUSH
69472: LD_EXP 90
69476: PUSH
69477: LD_VAR 0 2
69481: ARRAY
69482: PUSH
69483: LD_INT 1
69485: ARRAY
69486: PUSH
69487: LD_INT 1
69489: ARRAY
69490: PPUSH
69491: LD_EXP 90
69495: PUSH
69496: LD_VAR 0 2
69500: ARRAY
69501: PUSH
69502: LD_INT 1
69504: ARRAY
69505: PUSH
69506: LD_INT 2
69508: ARRAY
69509: PPUSH
69510: LD_EXP 90
69514: PUSH
69515: LD_VAR 0 2
69519: ARRAY
69520: PUSH
69521: LD_INT 1
69523: ARRAY
69524: PUSH
69525: LD_INT 3
69527: ARRAY
69528: PPUSH
69529: LD_EXP 90
69533: PUSH
69534: LD_VAR 0 2
69538: ARRAY
69539: PUSH
69540: LD_INT 1
69542: ARRAY
69543: PUSH
69544: LD_INT 4
69546: ARRAY
69547: PPUSH
69548: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
69552: LD_ADDR_VAR 0 4
69556: PUSH
69557: LD_EXP 90
69561: PUSH
69562: LD_VAR 0 2
69566: ARRAY
69567: PPUSH
69568: LD_INT 1
69570: PPUSH
69571: CALL_OW 3
69575: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
69576: LD_ADDR_EXP 90
69580: PUSH
69581: LD_EXP 90
69585: PPUSH
69586: LD_VAR 0 2
69590: PPUSH
69591: LD_VAR 0 4
69595: PPUSH
69596: CALL_OW 1
69600: ST_TO_ADDR
// break ;
69601: GO 69605
// end ; end ;
69603: GO 69249
69605: POP
69606: POP
// end ;
69607: GO 69181
69609: POP
69610: POP
// end ;
69611: LD_VAR 0 1
69615: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
69616: LD_INT 0
69618: PPUSH
69619: PPUSH
69620: PPUSH
// if not mc_bases then
69621: LD_EXP 69
69625: NOT
69626: IFFALSE 69630
// exit ;
69628: GO 69719
// for i = 1 to mc_bases do
69630: LD_ADDR_VAR 0 2
69634: PUSH
69635: DOUBLE
69636: LD_INT 1
69638: DEC
69639: ST_TO_ADDR
69640: LD_EXP 69
69644: PUSH
69645: FOR_TO
69646: IFFALSE 69717
// begin if mc_attack [ i ] then
69648: LD_EXP 89
69652: PUSH
69653: LD_VAR 0 2
69657: ARRAY
69658: IFFALSE 69715
// begin tmp := mc_attack [ i ] [ 1 ] ;
69660: LD_ADDR_VAR 0 3
69664: PUSH
69665: LD_EXP 89
69669: PUSH
69670: LD_VAR 0 2
69674: ARRAY
69675: PUSH
69676: LD_INT 1
69678: ARRAY
69679: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
69680: LD_ADDR_EXP 89
69684: PUSH
69685: LD_EXP 89
69689: PPUSH
69690: LD_VAR 0 2
69694: PPUSH
69695: EMPTY
69696: PPUSH
69697: CALL_OW 1
69701: ST_TO_ADDR
// Attack ( tmp ) ;
69702: LD_VAR 0 3
69706: PPUSH
69707: CALL 102299 0 1
// exit ;
69711: POP
69712: POP
69713: GO 69719
// end ; end ;
69715: GO 69645
69717: POP
69718: POP
// end ;
69719: LD_VAR 0 1
69723: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
69724: LD_INT 0
69726: PPUSH
69727: PPUSH
69728: PPUSH
69729: PPUSH
69730: PPUSH
69731: PPUSH
69732: PPUSH
// if not mc_bases then
69733: LD_EXP 69
69737: NOT
69738: IFFALSE 69742
// exit ;
69740: GO 70599
// for i = 1 to mc_bases do
69742: LD_ADDR_VAR 0 2
69746: PUSH
69747: DOUBLE
69748: LD_INT 1
69750: DEC
69751: ST_TO_ADDR
69752: LD_EXP 69
69756: PUSH
69757: FOR_TO
69758: IFFALSE 70597
// begin if not mc_bases [ i ] then
69760: LD_EXP 69
69764: PUSH
69765: LD_VAR 0 2
69769: ARRAY
69770: NOT
69771: IFFALSE 69775
// continue ;
69773: GO 69757
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
69775: LD_ADDR_VAR 0 7
69779: PUSH
69780: LD_EXP 69
69784: PUSH
69785: LD_VAR 0 2
69789: ARRAY
69790: PUSH
69791: LD_INT 1
69793: ARRAY
69794: PPUSH
69795: CALL 15388 0 1
69799: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
69800: LD_ADDR_EXP 92
69804: PUSH
69805: LD_EXP 92
69809: PPUSH
69810: LD_VAR 0 2
69814: PPUSH
69815: LD_EXP 69
69819: PUSH
69820: LD_VAR 0 2
69824: ARRAY
69825: PUSH
69826: LD_INT 1
69828: ARRAY
69829: PPUSH
69830: CALL_OW 255
69834: PPUSH
69835: LD_EXP 94
69839: PUSH
69840: LD_VAR 0 2
69844: ARRAY
69845: PPUSH
69846: CALL 15353 0 2
69850: PPUSH
69851: CALL_OW 1
69855: ST_TO_ADDR
// if not mc_scan [ i ] then
69856: LD_EXP 92
69860: PUSH
69861: LD_VAR 0 2
69865: ARRAY
69866: NOT
69867: IFFALSE 70045
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
69869: LD_ADDR_EXP 112
69873: PUSH
69874: LD_EXP 112
69878: PPUSH
69879: LD_VAR 0 2
69883: PPUSH
69884: LD_INT 0
69886: PPUSH
69887: CALL_OW 1
69891: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69892: LD_ADDR_VAR 0 4
69896: PUSH
69897: LD_EXP 69
69901: PUSH
69902: LD_VAR 0 2
69906: ARRAY
69907: PPUSH
69908: LD_INT 2
69910: PUSH
69911: LD_INT 25
69913: PUSH
69914: LD_INT 5
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 25
69923: PUSH
69924: LD_INT 8
69926: PUSH
69927: EMPTY
69928: LIST
69929: LIST
69930: PUSH
69931: LD_INT 25
69933: PUSH
69934: LD_INT 9
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: PPUSH
69947: CALL_OW 72
69951: ST_TO_ADDR
// if not tmp then
69952: LD_VAR 0 4
69956: NOT
69957: IFFALSE 69961
// continue ;
69959: GO 69757
// for j in tmp do
69961: LD_ADDR_VAR 0 3
69965: PUSH
69966: LD_VAR 0 4
69970: PUSH
69971: FOR_IN
69972: IFFALSE 70043
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
69974: LD_VAR 0 3
69978: PPUSH
69979: CALL_OW 310
69983: PPUSH
69984: CALL_OW 266
69988: PUSH
69989: LD_INT 5
69991: EQUAL
69992: PUSH
69993: LD_VAR 0 3
69997: PPUSH
69998: CALL_OW 257
70002: PUSH
70003: LD_INT 1
70005: EQUAL
70006: AND
70007: PUSH
70008: LD_VAR 0 3
70012: PPUSH
70013: CALL_OW 459
70017: NOT
70018: AND
70019: PUSH
70020: LD_VAR 0 7
70024: AND
70025: IFFALSE 70041
// ComChangeProfession ( j , class ) ;
70027: LD_VAR 0 3
70031: PPUSH
70032: LD_VAR 0 7
70036: PPUSH
70037: CALL_OW 123
70041: GO 69971
70043: POP
70044: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
70045: LD_EXP 92
70049: PUSH
70050: LD_VAR 0 2
70054: ARRAY
70055: PUSH
70056: LD_EXP 112
70060: PUSH
70061: LD_VAR 0 2
70065: ARRAY
70066: NOT
70067: AND
70068: PUSH
70069: LD_EXP 91
70073: PUSH
70074: LD_VAR 0 2
70078: ARRAY
70079: NOT
70080: AND
70081: PUSH
70082: LD_EXP 69
70086: PUSH
70087: LD_VAR 0 2
70091: ARRAY
70092: PPUSH
70093: LD_INT 50
70095: PUSH
70096: EMPTY
70097: LIST
70098: PUSH
70099: LD_INT 2
70101: PUSH
70102: LD_INT 30
70104: PUSH
70105: LD_INT 32
70107: PUSH
70108: EMPTY
70109: LIST
70110: LIST
70111: PUSH
70112: LD_INT 30
70114: PUSH
70115: LD_INT 33
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: PUSH
70122: LD_INT 30
70124: PUSH
70125: LD_INT 4
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: LD_INT 30
70134: PUSH
70135: LD_INT 5
70137: PUSH
70138: EMPTY
70139: LIST
70140: LIST
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: LIST
70146: LIST
70147: LIST
70148: PUSH
70149: EMPTY
70150: LIST
70151: LIST
70152: PPUSH
70153: CALL_OW 72
70157: PUSH
70158: LD_INT 4
70160: LESS
70161: PUSH
70162: LD_EXP 69
70166: PUSH
70167: LD_VAR 0 2
70171: ARRAY
70172: PPUSH
70173: LD_INT 3
70175: PUSH
70176: LD_INT 24
70178: PUSH
70179: LD_INT 1000
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: LD_INT 2
70192: PUSH
70193: LD_INT 30
70195: PUSH
70196: LD_INT 0
70198: PUSH
70199: EMPTY
70200: LIST
70201: LIST
70202: PUSH
70203: LD_INT 30
70205: PUSH
70206: LD_INT 1
70208: PUSH
70209: EMPTY
70210: LIST
70211: LIST
70212: PUSH
70213: EMPTY
70214: LIST
70215: LIST
70216: LIST
70217: PUSH
70218: EMPTY
70219: LIST
70220: LIST
70221: PPUSH
70222: CALL_OW 72
70226: OR
70227: AND
70228: IFFALSE 70479
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
70230: LD_ADDR_EXP 112
70234: PUSH
70235: LD_EXP 112
70239: PPUSH
70240: LD_VAR 0 2
70244: PPUSH
70245: LD_INT 1
70247: PPUSH
70248: CALL_OW 1
70252: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70253: LD_ADDR_VAR 0 4
70257: PUSH
70258: LD_EXP 69
70262: PUSH
70263: LD_VAR 0 2
70267: ARRAY
70268: PPUSH
70269: LD_INT 2
70271: PUSH
70272: LD_INT 25
70274: PUSH
70275: LD_INT 1
70277: PUSH
70278: EMPTY
70279: LIST
70280: LIST
70281: PUSH
70282: LD_INT 25
70284: PUSH
70285: LD_INT 5
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: PUSH
70292: LD_INT 25
70294: PUSH
70295: LD_INT 8
70297: PUSH
70298: EMPTY
70299: LIST
70300: LIST
70301: PUSH
70302: LD_INT 25
70304: PUSH
70305: LD_INT 9
70307: PUSH
70308: EMPTY
70309: LIST
70310: LIST
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: LIST
70316: LIST
70317: LIST
70318: PPUSH
70319: CALL_OW 72
70323: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
70324: LD_ADDR_VAR 0 4
70328: PUSH
70329: LD_VAR 0 4
70333: PUSH
70334: LD_VAR 0 4
70338: PPUSH
70339: LD_INT 18
70341: PPUSH
70342: CALL 47857 0 2
70346: DIFF
70347: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
70348: LD_VAR 0 4
70352: NOT
70353: PUSH
70354: LD_EXP 69
70358: PUSH
70359: LD_VAR 0 2
70363: ARRAY
70364: PPUSH
70365: LD_INT 2
70367: PUSH
70368: LD_INT 30
70370: PUSH
70371: LD_INT 4
70373: PUSH
70374: EMPTY
70375: LIST
70376: LIST
70377: PUSH
70378: LD_INT 30
70380: PUSH
70381: LD_INT 5
70383: PUSH
70384: EMPTY
70385: LIST
70386: LIST
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: LIST
70392: PPUSH
70393: CALL_OW 72
70397: NOT
70398: AND
70399: IFFALSE 70461
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
70401: LD_ADDR_VAR 0 4
70405: PUSH
70406: LD_EXP 69
70410: PUSH
70411: LD_VAR 0 2
70415: ARRAY
70416: PPUSH
70417: LD_INT 2
70419: PUSH
70420: LD_INT 25
70422: PUSH
70423: LD_INT 2
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: PUSH
70430: LD_INT 25
70432: PUSH
70433: LD_INT 3
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: PUSH
70440: LD_INT 25
70442: PUSH
70443: LD_INT 4
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: LIST
70454: LIST
70455: PPUSH
70456: CALL_OW 72
70460: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
70461: LD_VAR 0 2
70465: PPUSH
70466: LD_VAR 0 4
70470: PPUSH
70471: CALL 107008 0 2
// exit ;
70475: POP
70476: POP
70477: GO 70599
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
70479: LD_EXP 92
70483: PUSH
70484: LD_VAR 0 2
70488: ARRAY
70489: PUSH
70490: LD_EXP 112
70494: PUSH
70495: LD_VAR 0 2
70499: ARRAY
70500: NOT
70501: AND
70502: PUSH
70503: LD_EXP 91
70507: PUSH
70508: LD_VAR 0 2
70512: ARRAY
70513: AND
70514: IFFALSE 70595
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
70516: LD_ADDR_EXP 112
70520: PUSH
70521: LD_EXP 112
70525: PPUSH
70526: LD_VAR 0 2
70530: PPUSH
70531: LD_INT 1
70533: PPUSH
70534: CALL_OW 1
70538: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
70539: LD_ADDR_VAR 0 4
70543: PUSH
70544: LD_EXP 91
70548: PUSH
70549: LD_VAR 0 2
70553: ARRAY
70554: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
70555: LD_ADDR_EXP 91
70559: PUSH
70560: LD_EXP 91
70564: PPUSH
70565: LD_VAR 0 2
70569: PPUSH
70570: EMPTY
70571: PPUSH
70572: CALL_OW 1
70576: ST_TO_ADDR
// Defend ( i , tmp ) ;
70577: LD_VAR 0 2
70581: PPUSH
70582: LD_VAR 0 4
70586: PPUSH
70587: CALL 107604 0 2
// exit ;
70591: POP
70592: POP
70593: GO 70599
// end ; end ;
70595: GO 69757
70597: POP
70598: POP
// end ;
70599: LD_VAR 0 1
70603: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
70604: LD_INT 0
70606: PPUSH
70607: PPUSH
70608: PPUSH
70609: PPUSH
70610: PPUSH
70611: PPUSH
70612: PPUSH
70613: PPUSH
70614: PPUSH
70615: PPUSH
70616: PPUSH
// if not mc_bases then
70617: LD_EXP 69
70621: NOT
70622: IFFALSE 70626
// exit ;
70624: GO 71713
// for i = 1 to mc_bases do
70626: LD_ADDR_VAR 0 2
70630: PUSH
70631: DOUBLE
70632: LD_INT 1
70634: DEC
70635: ST_TO_ADDR
70636: LD_EXP 69
70640: PUSH
70641: FOR_TO
70642: IFFALSE 71711
// begin tmp := mc_lab [ i ] ;
70644: LD_ADDR_VAR 0 6
70648: PUSH
70649: LD_EXP 102
70653: PUSH
70654: LD_VAR 0 2
70658: ARRAY
70659: ST_TO_ADDR
// if not tmp then
70660: LD_VAR 0 6
70664: NOT
70665: IFFALSE 70669
// continue ;
70667: GO 70641
// idle_lab := 0 ;
70669: LD_ADDR_VAR 0 11
70673: PUSH
70674: LD_INT 0
70676: ST_TO_ADDR
// for j in tmp do
70677: LD_ADDR_VAR 0 3
70681: PUSH
70682: LD_VAR 0 6
70686: PUSH
70687: FOR_IN
70688: IFFALSE 71707
// begin researching := false ;
70690: LD_ADDR_VAR 0 10
70694: PUSH
70695: LD_INT 0
70697: ST_TO_ADDR
// side := GetSide ( j ) ;
70698: LD_ADDR_VAR 0 4
70702: PUSH
70703: LD_VAR 0 3
70707: PPUSH
70708: CALL_OW 255
70712: ST_TO_ADDR
// if not mc_tech [ side ] then
70713: LD_EXP 96
70717: PUSH
70718: LD_VAR 0 4
70722: ARRAY
70723: NOT
70724: IFFALSE 70728
// continue ;
70726: GO 70687
// if BuildingStatus ( j ) = bs_idle then
70728: LD_VAR 0 3
70732: PPUSH
70733: CALL_OW 461
70737: PUSH
70738: LD_INT 2
70740: EQUAL
70741: IFFALSE 70929
// begin if idle_lab and UnitsInside ( j ) < 6 then
70743: LD_VAR 0 11
70747: PUSH
70748: LD_VAR 0 3
70752: PPUSH
70753: CALL_OW 313
70757: PUSH
70758: LD_INT 6
70760: LESS
70761: AND
70762: IFFALSE 70833
// begin tmp2 := UnitsInside ( idle_lab ) ;
70764: LD_ADDR_VAR 0 9
70768: PUSH
70769: LD_VAR 0 11
70773: PPUSH
70774: CALL_OW 313
70778: ST_TO_ADDR
// if tmp2 then
70779: LD_VAR 0 9
70783: IFFALSE 70825
// for x in tmp2 do
70785: LD_ADDR_VAR 0 7
70789: PUSH
70790: LD_VAR 0 9
70794: PUSH
70795: FOR_IN
70796: IFFALSE 70823
// begin ComExitBuilding ( x ) ;
70798: LD_VAR 0 7
70802: PPUSH
70803: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70807: LD_VAR 0 7
70811: PPUSH
70812: LD_VAR 0 3
70816: PPUSH
70817: CALL_OW 180
// end ;
70821: GO 70795
70823: POP
70824: POP
// idle_lab := 0 ;
70825: LD_ADDR_VAR 0 11
70829: PUSH
70830: LD_INT 0
70832: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
70833: LD_ADDR_VAR 0 5
70837: PUSH
70838: LD_EXP 96
70842: PUSH
70843: LD_VAR 0 4
70847: ARRAY
70848: PUSH
70849: FOR_IN
70850: IFFALSE 70910
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
70852: LD_VAR 0 3
70856: PPUSH
70857: LD_VAR 0 5
70861: PPUSH
70862: CALL_OW 430
70866: PUSH
70867: LD_VAR 0 4
70871: PPUSH
70872: LD_VAR 0 5
70876: PPUSH
70877: CALL 14458 0 2
70881: AND
70882: IFFALSE 70908
// begin researching := true ;
70884: LD_ADDR_VAR 0 10
70888: PUSH
70889: LD_INT 1
70891: ST_TO_ADDR
// ComResearch ( j , t ) ;
70892: LD_VAR 0 3
70896: PPUSH
70897: LD_VAR 0 5
70901: PPUSH
70902: CALL_OW 124
// break ;
70906: GO 70910
// end ;
70908: GO 70849
70910: POP
70911: POP
// if not researching then
70912: LD_VAR 0 10
70916: NOT
70917: IFFALSE 70929
// idle_lab := j ;
70919: LD_ADDR_VAR 0 11
70923: PUSH
70924: LD_VAR 0 3
70928: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
70929: LD_VAR 0 3
70933: PPUSH
70934: CALL_OW 461
70938: PUSH
70939: LD_INT 10
70941: EQUAL
70942: IFFALSE 71530
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
70944: LD_EXP 98
70948: PUSH
70949: LD_VAR 0 2
70953: ARRAY
70954: NOT
70955: PUSH
70956: LD_EXP 99
70960: PUSH
70961: LD_VAR 0 2
70965: ARRAY
70966: NOT
70967: AND
70968: PUSH
70969: LD_EXP 96
70973: PUSH
70974: LD_VAR 0 4
70978: ARRAY
70979: PUSH
70980: LD_INT 1
70982: GREATER
70983: AND
70984: IFFALSE 71115
// begin ComCancel ( j ) ;
70986: LD_VAR 0 3
70990: PPUSH
70991: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
70995: LD_ADDR_EXP 96
70999: PUSH
71000: LD_EXP 96
71004: PPUSH
71005: LD_VAR 0 4
71009: PPUSH
71010: LD_EXP 96
71014: PUSH
71015: LD_VAR 0 4
71019: ARRAY
71020: PPUSH
71021: LD_EXP 96
71025: PUSH
71026: LD_VAR 0 4
71030: ARRAY
71031: PUSH
71032: LD_INT 1
71034: MINUS
71035: PPUSH
71036: LD_EXP 96
71040: PUSH
71041: LD_VAR 0 4
71045: ARRAY
71046: PPUSH
71047: LD_INT 0
71049: PPUSH
71050: CALL 18006 0 4
71054: PPUSH
71055: CALL_OW 1
71059: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
71060: LD_ADDR_EXP 96
71064: PUSH
71065: LD_EXP 96
71069: PPUSH
71070: LD_VAR 0 4
71074: PPUSH
71075: LD_EXP 96
71079: PUSH
71080: LD_VAR 0 4
71084: ARRAY
71085: PPUSH
71086: LD_EXP 96
71090: PUSH
71091: LD_VAR 0 4
71095: ARRAY
71096: PPUSH
71097: LD_INT 1
71099: PPUSH
71100: LD_INT 0
71102: PPUSH
71103: CALL 18006 0 4
71107: PPUSH
71108: CALL_OW 1
71112: ST_TO_ADDR
// continue ;
71113: GO 70687
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
71115: LD_EXP 98
71119: PUSH
71120: LD_VAR 0 2
71124: ARRAY
71125: PUSH
71126: LD_EXP 99
71130: PUSH
71131: LD_VAR 0 2
71135: ARRAY
71136: NOT
71137: AND
71138: IFFALSE 71265
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
71140: LD_ADDR_EXP 99
71144: PUSH
71145: LD_EXP 99
71149: PPUSH
71150: LD_VAR 0 2
71154: PUSH
71155: LD_EXP 99
71159: PUSH
71160: LD_VAR 0 2
71164: ARRAY
71165: PUSH
71166: LD_INT 1
71168: PLUS
71169: PUSH
71170: EMPTY
71171: LIST
71172: LIST
71173: PPUSH
71174: LD_EXP 98
71178: PUSH
71179: LD_VAR 0 2
71183: ARRAY
71184: PUSH
71185: LD_INT 1
71187: ARRAY
71188: PPUSH
71189: CALL 18588 0 3
71193: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
71194: LD_EXP 98
71198: PUSH
71199: LD_VAR 0 2
71203: ARRAY
71204: PUSH
71205: LD_INT 1
71207: ARRAY
71208: PPUSH
71209: LD_INT 112
71211: PPUSH
71212: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
71216: LD_ADDR_VAR 0 9
71220: PUSH
71221: LD_EXP 98
71225: PUSH
71226: LD_VAR 0 2
71230: ARRAY
71231: PPUSH
71232: LD_INT 1
71234: PPUSH
71235: CALL_OW 3
71239: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
71240: LD_ADDR_EXP 98
71244: PUSH
71245: LD_EXP 98
71249: PPUSH
71250: LD_VAR 0 2
71254: PPUSH
71255: LD_VAR 0 9
71259: PPUSH
71260: CALL_OW 1
71264: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
71265: LD_EXP 98
71269: PUSH
71270: LD_VAR 0 2
71274: ARRAY
71275: PUSH
71276: LD_EXP 99
71280: PUSH
71281: LD_VAR 0 2
71285: ARRAY
71286: AND
71287: PUSH
71288: LD_EXP 99
71292: PUSH
71293: LD_VAR 0 2
71297: ARRAY
71298: PUSH
71299: LD_INT 1
71301: ARRAY
71302: PPUSH
71303: CALL_OW 310
71307: NOT
71308: AND
71309: PUSH
71310: LD_VAR 0 3
71314: PPUSH
71315: CALL_OW 313
71319: PUSH
71320: LD_INT 6
71322: EQUAL
71323: AND
71324: IFFALSE 71380
// begin tmp2 := UnitsInside ( j ) ;
71326: LD_ADDR_VAR 0 9
71330: PUSH
71331: LD_VAR 0 3
71335: PPUSH
71336: CALL_OW 313
71340: ST_TO_ADDR
// if tmp2 = 6 then
71341: LD_VAR 0 9
71345: PUSH
71346: LD_INT 6
71348: EQUAL
71349: IFFALSE 71380
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
71351: LD_VAR 0 9
71355: PUSH
71356: LD_INT 1
71358: ARRAY
71359: PPUSH
71360: LD_INT 112
71362: PPUSH
71363: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
71367: LD_VAR 0 9
71371: PUSH
71372: LD_INT 1
71374: ARRAY
71375: PPUSH
71376: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
71380: LD_EXP 99
71384: PUSH
71385: LD_VAR 0 2
71389: ARRAY
71390: PUSH
71391: LD_EXP 99
71395: PUSH
71396: LD_VAR 0 2
71400: ARRAY
71401: PUSH
71402: LD_INT 1
71404: ARRAY
71405: PPUSH
71406: CALL_OW 314
71410: NOT
71411: AND
71412: PUSH
71413: LD_EXP 99
71417: PUSH
71418: LD_VAR 0 2
71422: ARRAY
71423: PUSH
71424: LD_INT 1
71426: ARRAY
71427: PPUSH
71428: CALL_OW 310
71432: NOT
71433: AND
71434: IFFALSE 71460
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
71436: LD_EXP 99
71440: PUSH
71441: LD_VAR 0 2
71445: ARRAY
71446: PUSH
71447: LD_INT 1
71449: ARRAY
71450: PPUSH
71451: LD_VAR 0 3
71455: PPUSH
71456: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
71460: LD_EXP 99
71464: PUSH
71465: LD_VAR 0 2
71469: ARRAY
71470: PUSH
71471: LD_INT 1
71473: ARRAY
71474: PPUSH
71475: CALL_OW 310
71479: PUSH
71480: LD_EXP 99
71484: PUSH
71485: LD_VAR 0 2
71489: ARRAY
71490: PUSH
71491: LD_INT 1
71493: ARRAY
71494: PPUSH
71495: CALL_OW 310
71499: PPUSH
71500: CALL_OW 461
71504: PUSH
71505: LD_INT 3
71507: NONEQUAL
71508: AND
71509: IFFALSE 71530
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
71511: LD_EXP 99
71515: PUSH
71516: LD_VAR 0 2
71520: ARRAY
71521: PUSH
71522: LD_INT 1
71524: ARRAY
71525: PPUSH
71526: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
71530: LD_VAR 0 3
71534: PPUSH
71535: CALL_OW 461
71539: PUSH
71540: LD_INT 6
71542: EQUAL
71543: PUSH
71544: LD_VAR 0 6
71548: PUSH
71549: LD_INT 1
71551: GREATER
71552: AND
71553: IFFALSE 71705
// begin sci := [ ] ;
71555: LD_ADDR_VAR 0 8
71559: PUSH
71560: EMPTY
71561: ST_TO_ADDR
// for x in ( tmp diff j ) do
71562: LD_ADDR_VAR 0 7
71566: PUSH
71567: LD_VAR 0 6
71571: PUSH
71572: LD_VAR 0 3
71576: DIFF
71577: PUSH
71578: FOR_IN
71579: IFFALSE 71631
// begin if sci = 6 then
71581: LD_VAR 0 8
71585: PUSH
71586: LD_INT 6
71588: EQUAL
71589: IFFALSE 71593
// break ;
71591: GO 71631
// if BuildingStatus ( x ) = bs_idle then
71593: LD_VAR 0 7
71597: PPUSH
71598: CALL_OW 461
71602: PUSH
71603: LD_INT 2
71605: EQUAL
71606: IFFALSE 71629
// sci := sci ^ UnitsInside ( x ) ;
71608: LD_ADDR_VAR 0 8
71612: PUSH
71613: LD_VAR 0 8
71617: PUSH
71618: LD_VAR 0 7
71622: PPUSH
71623: CALL_OW 313
71627: ADD
71628: ST_TO_ADDR
// end ;
71629: GO 71578
71631: POP
71632: POP
// if not sci then
71633: LD_VAR 0 8
71637: NOT
71638: IFFALSE 71642
// continue ;
71640: GO 70687
// for x in sci do
71642: LD_ADDR_VAR 0 7
71646: PUSH
71647: LD_VAR 0 8
71651: PUSH
71652: FOR_IN
71653: IFFALSE 71703
// if IsInUnit ( x ) and not HasTask ( x ) then
71655: LD_VAR 0 7
71659: PPUSH
71660: CALL_OW 310
71664: PUSH
71665: LD_VAR 0 7
71669: PPUSH
71670: CALL_OW 314
71674: NOT
71675: AND
71676: IFFALSE 71701
// begin ComExitBuilding ( x ) ;
71678: LD_VAR 0 7
71682: PPUSH
71683: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71687: LD_VAR 0 7
71691: PPUSH
71692: LD_VAR 0 3
71696: PPUSH
71697: CALL_OW 180
// end ;
71701: GO 71652
71703: POP
71704: POP
// end ; end ;
71705: GO 70687
71707: POP
71708: POP
// end ;
71709: GO 70641
71711: POP
71712: POP
// end ;
71713: LD_VAR 0 1
71717: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
71718: LD_INT 0
71720: PPUSH
71721: PPUSH
// if not mc_bases then
71722: LD_EXP 69
71726: NOT
71727: IFFALSE 71731
// exit ;
71729: GO 71812
// for i = 1 to mc_bases do
71731: LD_ADDR_VAR 0 2
71735: PUSH
71736: DOUBLE
71737: LD_INT 1
71739: DEC
71740: ST_TO_ADDR
71741: LD_EXP 69
71745: PUSH
71746: FOR_TO
71747: IFFALSE 71810
// if mc_mines [ i ] and mc_miners [ i ] then
71749: LD_EXP 82
71753: PUSH
71754: LD_VAR 0 2
71758: ARRAY
71759: PUSH
71760: LD_EXP 83
71764: PUSH
71765: LD_VAR 0 2
71769: ARRAY
71770: AND
71771: IFFALSE 71808
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
71773: LD_EXP 83
71777: PUSH
71778: LD_VAR 0 2
71782: ARRAY
71783: PUSH
71784: LD_INT 1
71786: ARRAY
71787: PPUSH
71788: CALL_OW 255
71792: PPUSH
71793: LD_EXP 82
71797: PUSH
71798: LD_VAR 0 2
71802: ARRAY
71803: PPUSH
71804: CALL 15541 0 2
71808: GO 71746
71810: POP
71811: POP
// end ;
71812: LD_VAR 0 1
71816: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
71817: LD_INT 0
71819: PPUSH
71820: PPUSH
71821: PPUSH
71822: PPUSH
71823: PPUSH
71824: PPUSH
71825: PPUSH
71826: PPUSH
// if not mc_bases or not mc_parking then
71827: LD_EXP 69
71831: NOT
71832: PUSH
71833: LD_EXP 93
71837: NOT
71838: OR
71839: IFFALSE 71843
// exit ;
71841: GO 72553
// for i = 1 to mc_bases do
71843: LD_ADDR_VAR 0 2
71847: PUSH
71848: DOUBLE
71849: LD_INT 1
71851: DEC
71852: ST_TO_ADDR
71853: LD_EXP 69
71857: PUSH
71858: FOR_TO
71859: IFFALSE 72551
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
71861: LD_EXP 69
71865: PUSH
71866: LD_VAR 0 2
71870: ARRAY
71871: NOT
71872: PUSH
71873: LD_EXP 93
71877: PUSH
71878: LD_VAR 0 2
71882: ARRAY
71883: NOT
71884: OR
71885: IFFALSE 71889
// continue ;
71887: GO 71858
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
71889: LD_ADDR_VAR 0 5
71893: PUSH
71894: LD_EXP 69
71898: PUSH
71899: LD_VAR 0 2
71903: ARRAY
71904: PUSH
71905: LD_INT 1
71907: ARRAY
71908: PPUSH
71909: CALL_OW 255
71913: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71914: LD_ADDR_VAR 0 6
71918: PUSH
71919: LD_EXP 69
71923: PUSH
71924: LD_VAR 0 2
71928: ARRAY
71929: PPUSH
71930: LD_INT 30
71932: PUSH
71933: LD_INT 3
71935: PUSH
71936: EMPTY
71937: LIST
71938: LIST
71939: PPUSH
71940: CALL_OW 72
71944: ST_TO_ADDR
// if not fac then
71945: LD_VAR 0 6
71949: NOT
71950: IFFALSE 72001
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71952: LD_ADDR_VAR 0 6
71956: PUSH
71957: LD_EXP 69
71961: PUSH
71962: LD_VAR 0 2
71966: ARRAY
71967: PPUSH
71968: LD_INT 2
71970: PUSH
71971: LD_INT 30
71973: PUSH
71974: LD_INT 0
71976: PUSH
71977: EMPTY
71978: LIST
71979: LIST
71980: PUSH
71981: LD_INT 30
71983: PUSH
71984: LD_INT 1
71986: PUSH
71987: EMPTY
71988: LIST
71989: LIST
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: LIST
71995: PPUSH
71996: CALL_OW 72
72000: ST_TO_ADDR
// if not fac then
72001: LD_VAR 0 6
72005: NOT
72006: IFFALSE 72010
// continue ;
72008: GO 71858
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72010: LD_ADDR_VAR 0 7
72014: PUSH
72015: LD_EXP 93
72019: PUSH
72020: LD_VAR 0 2
72024: ARRAY
72025: PPUSH
72026: LD_INT 22
72028: PUSH
72029: LD_VAR 0 5
72033: PUSH
72034: EMPTY
72035: LIST
72036: LIST
72037: PUSH
72038: LD_INT 21
72040: PUSH
72041: LD_INT 2
72043: PUSH
72044: EMPTY
72045: LIST
72046: LIST
72047: PUSH
72048: LD_INT 3
72050: PUSH
72051: LD_INT 24
72053: PUSH
72054: LD_INT 1000
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: PUSH
72061: EMPTY
72062: LIST
72063: LIST
72064: PUSH
72065: EMPTY
72066: LIST
72067: LIST
72068: LIST
72069: PPUSH
72070: CALL_OW 70
72074: ST_TO_ADDR
// for j in fac do
72075: LD_ADDR_VAR 0 3
72079: PUSH
72080: LD_VAR 0 6
72084: PUSH
72085: FOR_IN
72086: IFFALSE 72167
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72088: LD_ADDR_VAR 0 7
72092: PUSH
72093: LD_VAR 0 7
72097: PUSH
72098: LD_INT 22
72100: PUSH
72101: LD_VAR 0 5
72105: PUSH
72106: EMPTY
72107: LIST
72108: LIST
72109: PUSH
72110: LD_INT 91
72112: PUSH
72113: LD_VAR 0 3
72117: PUSH
72118: LD_INT 15
72120: PUSH
72121: EMPTY
72122: LIST
72123: LIST
72124: LIST
72125: PUSH
72126: LD_INT 21
72128: PUSH
72129: LD_INT 2
72131: PUSH
72132: EMPTY
72133: LIST
72134: LIST
72135: PUSH
72136: LD_INT 3
72138: PUSH
72139: LD_INT 24
72141: PUSH
72142: LD_INT 1000
72144: PUSH
72145: EMPTY
72146: LIST
72147: LIST
72148: PUSH
72149: EMPTY
72150: LIST
72151: LIST
72152: PUSH
72153: EMPTY
72154: LIST
72155: LIST
72156: LIST
72157: LIST
72158: PPUSH
72159: CALL_OW 69
72163: UNION
72164: ST_TO_ADDR
72165: GO 72085
72167: POP
72168: POP
// if not vehs then
72169: LD_VAR 0 7
72173: NOT
72174: IFFALSE 72200
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72176: LD_ADDR_EXP 81
72180: PUSH
72181: LD_EXP 81
72185: PPUSH
72186: LD_VAR 0 2
72190: PPUSH
72191: EMPTY
72192: PPUSH
72193: CALL_OW 1
72197: ST_TO_ADDR
// continue ;
72198: GO 71858
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72200: LD_ADDR_VAR 0 8
72204: PUSH
72205: LD_EXP 69
72209: PUSH
72210: LD_VAR 0 2
72214: ARRAY
72215: PPUSH
72216: LD_INT 30
72218: PUSH
72219: LD_INT 3
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PPUSH
72226: CALL_OW 72
72230: ST_TO_ADDR
// if tmp then
72231: LD_VAR 0 8
72235: IFFALSE 72338
// begin for j in tmp do
72237: LD_ADDR_VAR 0 3
72241: PUSH
72242: LD_VAR 0 8
72246: PUSH
72247: FOR_IN
72248: IFFALSE 72336
// for k in UnitsInside ( j ) do
72250: LD_ADDR_VAR 0 4
72254: PUSH
72255: LD_VAR 0 3
72259: PPUSH
72260: CALL_OW 313
72264: PUSH
72265: FOR_IN
72266: IFFALSE 72332
// if k then
72268: LD_VAR 0 4
72272: IFFALSE 72330
// if not k in mc_repair_vehicle [ i ] then
72274: LD_VAR 0 4
72278: PUSH
72279: LD_EXP 81
72283: PUSH
72284: LD_VAR 0 2
72288: ARRAY
72289: IN
72290: NOT
72291: IFFALSE 72330
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
72293: LD_ADDR_EXP 81
72297: PUSH
72298: LD_EXP 81
72302: PPUSH
72303: LD_VAR 0 2
72307: PPUSH
72308: LD_EXP 81
72312: PUSH
72313: LD_VAR 0 2
72317: ARRAY
72318: PUSH
72319: LD_VAR 0 4
72323: UNION
72324: PPUSH
72325: CALL_OW 1
72329: ST_TO_ADDR
72330: GO 72265
72332: POP
72333: POP
72334: GO 72247
72336: POP
72337: POP
// end ; if not mc_repair_vehicle [ i ] then
72338: LD_EXP 81
72342: PUSH
72343: LD_VAR 0 2
72347: ARRAY
72348: NOT
72349: IFFALSE 72353
// continue ;
72351: GO 71858
// for j in mc_repair_vehicle [ i ] do
72353: LD_ADDR_VAR 0 3
72357: PUSH
72358: LD_EXP 81
72362: PUSH
72363: LD_VAR 0 2
72367: ARRAY
72368: PUSH
72369: FOR_IN
72370: IFFALSE 72547
// begin if GetClass ( j ) <> 3 then
72372: LD_VAR 0 3
72376: PPUSH
72377: CALL_OW 257
72381: PUSH
72382: LD_INT 3
72384: NONEQUAL
72385: IFFALSE 72426
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
72387: LD_ADDR_EXP 81
72391: PUSH
72392: LD_EXP 81
72396: PPUSH
72397: LD_VAR 0 2
72401: PPUSH
72402: LD_EXP 81
72406: PUSH
72407: LD_VAR 0 2
72411: ARRAY
72412: PUSH
72413: LD_VAR 0 3
72417: DIFF
72418: PPUSH
72419: CALL_OW 1
72423: ST_TO_ADDR
// continue ;
72424: GO 72369
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72426: LD_VAR 0 3
72430: PPUSH
72431: CALL_OW 311
72435: NOT
72436: PUSH
72437: LD_VAR 0 3
72441: PUSH
72442: LD_EXP 72
72446: PUSH
72447: LD_VAR 0 2
72451: ARRAY
72452: PUSH
72453: LD_INT 1
72455: ARRAY
72456: IN
72457: NOT
72458: AND
72459: PUSH
72460: LD_VAR 0 3
72464: PUSH
72465: LD_EXP 72
72469: PUSH
72470: LD_VAR 0 2
72474: ARRAY
72475: PUSH
72476: LD_INT 2
72478: ARRAY
72479: IN
72480: NOT
72481: AND
72482: IFFALSE 72545
// begin if IsInUnit ( j ) then
72484: LD_VAR 0 3
72488: PPUSH
72489: CALL_OW 310
72493: IFFALSE 72506
// ComExitBuilding ( j ) else
72495: LD_VAR 0 3
72499: PPUSH
72500: CALL_OW 122
72504: GO 72545
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
72506: LD_VAR 0 3
72510: PPUSH
72511: LD_VAR 0 7
72515: PUSH
72516: LD_INT 1
72518: ARRAY
72519: PPUSH
72520: CALL 52396 0 2
72524: NOT
72525: IFFALSE 72545
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
72527: LD_VAR 0 3
72531: PPUSH
72532: LD_VAR 0 7
72536: PUSH
72537: LD_INT 1
72539: ARRAY
72540: PPUSH
72541: CALL_OW 129
// end ; end ;
72545: GO 72369
72547: POP
72548: POP
// end ;
72549: GO 71858
72551: POP
72552: POP
// end ;
72553: LD_VAR 0 1
72557: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
72558: LD_INT 0
72560: PPUSH
72561: PPUSH
72562: PPUSH
72563: PPUSH
72564: PPUSH
72565: PPUSH
72566: PPUSH
72567: PPUSH
72568: PPUSH
72569: PPUSH
72570: PPUSH
// if not mc_bases then
72571: LD_EXP 69
72575: NOT
72576: IFFALSE 72580
// exit ;
72578: GO 73382
// for i = 1 to mc_bases do
72580: LD_ADDR_VAR 0 2
72584: PUSH
72585: DOUBLE
72586: LD_INT 1
72588: DEC
72589: ST_TO_ADDR
72590: LD_EXP 69
72594: PUSH
72595: FOR_TO
72596: IFFALSE 73380
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
72598: LD_EXP 97
72602: PUSH
72603: LD_VAR 0 2
72607: ARRAY
72608: NOT
72609: PUSH
72610: LD_EXP 72
72614: PUSH
72615: LD_VAR 0 2
72619: ARRAY
72620: PUSH
72621: LD_INT 1
72623: ARRAY
72624: OR
72625: PUSH
72626: LD_EXP 72
72630: PUSH
72631: LD_VAR 0 2
72635: ARRAY
72636: PUSH
72637: LD_INT 2
72639: ARRAY
72640: OR
72641: PUSH
72642: LD_EXP 95
72646: PUSH
72647: LD_VAR 0 2
72651: ARRAY
72652: PPUSH
72653: LD_INT 1
72655: PPUSH
72656: CALL_OW 325
72660: NOT
72661: OR
72662: PUSH
72663: LD_EXP 92
72667: PUSH
72668: LD_VAR 0 2
72672: ARRAY
72673: OR
72674: IFFALSE 72678
// continue ;
72676: GO 72595
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
72678: LD_ADDR_VAR 0 8
72682: PUSH
72683: LD_EXP 69
72687: PUSH
72688: LD_VAR 0 2
72692: ARRAY
72693: PPUSH
72694: LD_INT 25
72696: PUSH
72697: LD_INT 4
72699: PUSH
72700: EMPTY
72701: LIST
72702: LIST
72703: PUSH
72704: LD_INT 50
72706: PUSH
72707: EMPTY
72708: LIST
72709: PUSH
72710: LD_INT 3
72712: PUSH
72713: LD_INT 60
72715: PUSH
72716: EMPTY
72717: LIST
72718: PUSH
72719: EMPTY
72720: LIST
72721: LIST
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: LIST
72727: PPUSH
72728: CALL_OW 72
72732: PUSH
72733: LD_EXP 73
72737: PUSH
72738: LD_VAR 0 2
72742: ARRAY
72743: DIFF
72744: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72745: LD_ADDR_VAR 0 9
72749: PUSH
72750: LD_EXP 69
72754: PUSH
72755: LD_VAR 0 2
72759: ARRAY
72760: PPUSH
72761: LD_INT 2
72763: PUSH
72764: LD_INT 30
72766: PUSH
72767: LD_INT 0
72769: PUSH
72770: EMPTY
72771: LIST
72772: LIST
72773: PUSH
72774: LD_INT 30
72776: PUSH
72777: LD_INT 1
72779: PUSH
72780: EMPTY
72781: LIST
72782: LIST
72783: PUSH
72784: EMPTY
72785: LIST
72786: LIST
72787: LIST
72788: PPUSH
72789: CALL_OW 72
72793: ST_TO_ADDR
// if not tmp or not dep then
72794: LD_VAR 0 8
72798: NOT
72799: PUSH
72800: LD_VAR 0 9
72804: NOT
72805: OR
72806: IFFALSE 72810
// continue ;
72808: GO 72595
// side := GetSide ( tmp [ 1 ] ) ;
72810: LD_ADDR_VAR 0 11
72814: PUSH
72815: LD_VAR 0 8
72819: PUSH
72820: LD_INT 1
72822: ARRAY
72823: PPUSH
72824: CALL_OW 255
72828: ST_TO_ADDR
// dep := dep [ 1 ] ;
72829: LD_ADDR_VAR 0 9
72833: PUSH
72834: LD_VAR 0 9
72838: PUSH
72839: LD_INT 1
72841: ARRAY
72842: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
72843: LD_ADDR_VAR 0 7
72847: PUSH
72848: LD_EXP 97
72852: PUSH
72853: LD_VAR 0 2
72857: ARRAY
72858: PPUSH
72859: LD_INT 22
72861: PUSH
72862: LD_INT 0
72864: PUSH
72865: EMPTY
72866: LIST
72867: LIST
72868: PUSH
72869: LD_INT 25
72871: PUSH
72872: LD_INT 12
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: PPUSH
72883: CALL_OW 70
72887: PUSH
72888: LD_INT 22
72890: PUSH
72891: LD_INT 0
72893: PUSH
72894: EMPTY
72895: LIST
72896: LIST
72897: PUSH
72898: LD_INT 25
72900: PUSH
72901: LD_INT 12
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 91
72910: PUSH
72911: LD_VAR 0 9
72915: PUSH
72916: LD_INT 20
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: LIST
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: LIST
72928: PPUSH
72929: CALL_OW 69
72933: UNION
72934: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
72935: LD_ADDR_VAR 0 10
72939: PUSH
72940: LD_EXP 97
72944: PUSH
72945: LD_VAR 0 2
72949: ARRAY
72950: PPUSH
72951: LD_INT 81
72953: PUSH
72954: LD_VAR 0 11
72958: PUSH
72959: EMPTY
72960: LIST
72961: LIST
72962: PPUSH
72963: CALL_OW 70
72967: ST_TO_ADDR
// if not apes or danger_at_area then
72968: LD_VAR 0 7
72972: NOT
72973: PUSH
72974: LD_VAR 0 10
72978: OR
72979: IFFALSE 73029
// begin if mc_taming [ i ] then
72981: LD_EXP 100
72985: PUSH
72986: LD_VAR 0 2
72990: ARRAY
72991: IFFALSE 73027
// begin MC_Reset ( i , 121 ) ;
72993: LD_VAR 0 2
72997: PPUSH
72998: LD_INT 121
73000: PPUSH
73001: CALL 58015 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
73005: LD_ADDR_EXP 100
73009: PUSH
73010: LD_EXP 100
73014: PPUSH
73015: LD_VAR 0 2
73019: PPUSH
73020: EMPTY
73021: PPUSH
73022: CALL_OW 1
73026: ST_TO_ADDR
// end ; continue ;
73027: GO 72595
// end ; for j in tmp do
73029: LD_ADDR_VAR 0 3
73033: PUSH
73034: LD_VAR 0 8
73038: PUSH
73039: FOR_IN
73040: IFFALSE 73376
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
73042: LD_VAR 0 3
73046: PUSH
73047: LD_EXP 100
73051: PUSH
73052: LD_VAR 0 2
73056: ARRAY
73057: IN
73058: NOT
73059: PUSH
73060: LD_EXP 100
73064: PUSH
73065: LD_VAR 0 2
73069: ARRAY
73070: PUSH
73071: LD_INT 3
73073: LESS
73074: AND
73075: IFFALSE 73133
// begin SetTag ( j , 121 ) ;
73077: LD_VAR 0 3
73081: PPUSH
73082: LD_INT 121
73084: PPUSH
73085: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
73089: LD_ADDR_EXP 100
73093: PUSH
73094: LD_EXP 100
73098: PPUSH
73099: LD_VAR 0 2
73103: PUSH
73104: LD_EXP 100
73108: PUSH
73109: LD_VAR 0 2
73113: ARRAY
73114: PUSH
73115: LD_INT 1
73117: PLUS
73118: PUSH
73119: EMPTY
73120: LIST
73121: LIST
73122: PPUSH
73123: LD_VAR 0 3
73127: PPUSH
73128: CALL 18588 0 3
73132: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
73133: LD_VAR 0 3
73137: PUSH
73138: LD_EXP 100
73142: PUSH
73143: LD_VAR 0 2
73147: ARRAY
73148: IN
73149: IFFALSE 73374
// begin if GetClass ( j ) <> 4 then
73151: LD_VAR 0 3
73155: PPUSH
73156: CALL_OW 257
73160: PUSH
73161: LD_INT 4
73163: NONEQUAL
73164: IFFALSE 73217
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
73166: LD_ADDR_EXP 100
73170: PUSH
73171: LD_EXP 100
73175: PPUSH
73176: LD_VAR 0 2
73180: PPUSH
73181: LD_EXP 100
73185: PUSH
73186: LD_VAR 0 2
73190: ARRAY
73191: PUSH
73192: LD_VAR 0 3
73196: DIFF
73197: PPUSH
73198: CALL_OW 1
73202: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73203: LD_VAR 0 3
73207: PPUSH
73208: LD_INT 0
73210: PPUSH
73211: CALL_OW 109
// continue ;
73215: GO 73039
// end ; if IsInUnit ( j ) then
73217: LD_VAR 0 3
73221: PPUSH
73222: CALL_OW 310
73226: IFFALSE 73237
// ComExitBuilding ( j ) ;
73228: LD_VAR 0 3
73232: PPUSH
73233: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
73237: LD_ADDR_VAR 0 6
73241: PUSH
73242: LD_VAR 0 7
73246: PPUSH
73247: LD_VAR 0 3
73251: PPUSH
73252: CALL_OW 74
73256: ST_TO_ADDR
// if not ape then
73257: LD_VAR 0 6
73261: NOT
73262: IFFALSE 73266
// break ;
73264: GO 73376
// x := GetX ( ape ) ;
73266: LD_ADDR_VAR 0 4
73270: PUSH
73271: LD_VAR 0 6
73275: PPUSH
73276: CALL_OW 250
73280: ST_TO_ADDR
// y := GetY ( ape ) ;
73281: LD_ADDR_VAR 0 5
73285: PUSH
73286: LD_VAR 0 6
73290: PPUSH
73291: CALL_OW 251
73295: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
73296: LD_VAR 0 4
73300: PPUSH
73301: LD_VAR 0 5
73305: PPUSH
73306: CALL_OW 488
73310: NOT
73311: PUSH
73312: LD_VAR 0 11
73316: PPUSH
73317: LD_VAR 0 4
73321: PPUSH
73322: LD_VAR 0 5
73326: PPUSH
73327: LD_INT 20
73329: PPUSH
73330: CALL 19484 0 4
73334: PUSH
73335: LD_INT 4
73337: ARRAY
73338: OR
73339: IFFALSE 73343
// break ;
73341: GO 73376
// if not HasTask ( j ) then
73343: LD_VAR 0 3
73347: PPUSH
73348: CALL_OW 314
73352: NOT
73353: IFFALSE 73374
// ComTameXY ( j , x , y ) ;
73355: LD_VAR 0 3
73359: PPUSH
73360: LD_VAR 0 4
73364: PPUSH
73365: LD_VAR 0 5
73369: PPUSH
73370: CALL_OW 131
// end ; end ;
73374: GO 73039
73376: POP
73377: POP
// end ;
73378: GO 72595
73380: POP
73381: POP
// end ;
73382: LD_VAR 0 1
73386: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
73387: LD_INT 0
73389: PPUSH
73390: PPUSH
73391: PPUSH
73392: PPUSH
73393: PPUSH
73394: PPUSH
73395: PPUSH
73396: PPUSH
// if not mc_bases then
73397: LD_EXP 69
73401: NOT
73402: IFFALSE 73406
// exit ;
73404: GO 74032
// for i = 1 to mc_bases do
73406: LD_ADDR_VAR 0 2
73410: PUSH
73411: DOUBLE
73412: LD_INT 1
73414: DEC
73415: ST_TO_ADDR
73416: LD_EXP 69
73420: PUSH
73421: FOR_TO
73422: IFFALSE 74030
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
73424: LD_EXP 98
73428: PUSH
73429: LD_VAR 0 2
73433: ARRAY
73434: NOT
73435: PUSH
73436: LD_EXP 98
73440: PUSH
73441: LD_VAR 0 2
73445: ARRAY
73446: PPUSH
73447: LD_INT 25
73449: PUSH
73450: LD_INT 12
73452: PUSH
73453: EMPTY
73454: LIST
73455: LIST
73456: PPUSH
73457: CALL_OW 72
73461: NOT
73462: OR
73463: IFFALSE 73467
// continue ;
73465: GO 73421
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
73467: LD_ADDR_VAR 0 5
73471: PUSH
73472: LD_EXP 98
73476: PUSH
73477: LD_VAR 0 2
73481: ARRAY
73482: PUSH
73483: LD_INT 1
73485: ARRAY
73486: PPUSH
73487: CALL_OW 255
73491: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
73492: LD_VAR 0 5
73496: PPUSH
73497: LD_INT 2
73499: PPUSH
73500: CALL_OW 325
73504: IFFALSE 73757
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73506: LD_ADDR_VAR 0 4
73510: PUSH
73511: LD_EXP 98
73515: PUSH
73516: LD_VAR 0 2
73520: ARRAY
73521: PPUSH
73522: LD_INT 25
73524: PUSH
73525: LD_INT 16
73527: PUSH
73528: EMPTY
73529: LIST
73530: LIST
73531: PPUSH
73532: CALL_OW 72
73536: ST_TO_ADDR
// if tmp < 6 then
73537: LD_VAR 0 4
73541: PUSH
73542: LD_INT 6
73544: LESS
73545: IFFALSE 73757
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73547: LD_ADDR_VAR 0 6
73551: PUSH
73552: LD_EXP 69
73556: PUSH
73557: LD_VAR 0 2
73561: ARRAY
73562: PPUSH
73563: LD_INT 2
73565: PUSH
73566: LD_INT 30
73568: PUSH
73569: LD_INT 0
73571: PUSH
73572: EMPTY
73573: LIST
73574: LIST
73575: PUSH
73576: LD_INT 30
73578: PUSH
73579: LD_INT 1
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: PUSH
73586: EMPTY
73587: LIST
73588: LIST
73589: LIST
73590: PPUSH
73591: CALL_OW 72
73595: ST_TO_ADDR
// if depot then
73596: LD_VAR 0 6
73600: IFFALSE 73757
// begin selected := 0 ;
73602: LD_ADDR_VAR 0 7
73606: PUSH
73607: LD_INT 0
73609: ST_TO_ADDR
// for j in depot do
73610: LD_ADDR_VAR 0 3
73614: PUSH
73615: LD_VAR 0 6
73619: PUSH
73620: FOR_IN
73621: IFFALSE 73652
// begin if UnitsInside ( j ) < 6 then
73623: LD_VAR 0 3
73627: PPUSH
73628: CALL_OW 313
73632: PUSH
73633: LD_INT 6
73635: LESS
73636: IFFALSE 73650
// begin selected := j ;
73638: LD_ADDR_VAR 0 7
73642: PUSH
73643: LD_VAR 0 3
73647: ST_TO_ADDR
// break ;
73648: GO 73652
// end ; end ;
73650: GO 73620
73652: POP
73653: POP
// if selected then
73654: LD_VAR 0 7
73658: IFFALSE 73757
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73660: LD_ADDR_VAR 0 3
73664: PUSH
73665: LD_EXP 98
73669: PUSH
73670: LD_VAR 0 2
73674: ARRAY
73675: PPUSH
73676: LD_INT 25
73678: PUSH
73679: LD_INT 12
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: PPUSH
73686: CALL_OW 72
73690: PUSH
73691: FOR_IN
73692: IFFALSE 73755
// if not HasTask ( j ) then
73694: LD_VAR 0 3
73698: PPUSH
73699: CALL_OW 314
73703: NOT
73704: IFFALSE 73753
// begin if not IsInUnit ( j ) then
73706: LD_VAR 0 3
73710: PPUSH
73711: CALL_OW 310
73715: NOT
73716: IFFALSE 73732
// ComEnterUnit ( j , selected ) ;
73718: LD_VAR 0 3
73722: PPUSH
73723: LD_VAR 0 7
73727: PPUSH
73728: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
73732: LD_VAR 0 3
73736: PPUSH
73737: LD_INT 16
73739: PPUSH
73740: CALL_OW 183
// AddComExitBuilding ( j ) ;
73744: LD_VAR 0 3
73748: PPUSH
73749: CALL_OW 182
// end ;
73753: GO 73691
73755: POP
73756: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
73757: LD_VAR 0 5
73761: PPUSH
73762: LD_INT 11
73764: PPUSH
73765: CALL_OW 325
73769: IFFALSE 74028
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73771: LD_ADDR_VAR 0 4
73775: PUSH
73776: LD_EXP 98
73780: PUSH
73781: LD_VAR 0 2
73785: ARRAY
73786: PPUSH
73787: LD_INT 25
73789: PUSH
73790: LD_INT 16
73792: PUSH
73793: EMPTY
73794: LIST
73795: LIST
73796: PPUSH
73797: CALL_OW 72
73801: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
73802: LD_VAR 0 4
73806: PUSH
73807: LD_INT 6
73809: GREATEREQUAL
73810: PUSH
73811: LD_VAR 0 5
73815: PPUSH
73816: LD_INT 2
73818: PPUSH
73819: CALL_OW 325
73823: NOT
73824: OR
73825: IFFALSE 74028
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
73827: LD_ADDR_VAR 0 8
73831: PUSH
73832: LD_EXP 69
73836: PUSH
73837: LD_VAR 0 2
73841: ARRAY
73842: PPUSH
73843: LD_INT 2
73845: PUSH
73846: LD_INT 30
73848: PUSH
73849: LD_INT 4
73851: PUSH
73852: EMPTY
73853: LIST
73854: LIST
73855: PUSH
73856: LD_INT 30
73858: PUSH
73859: LD_INT 5
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: LIST
73870: PPUSH
73871: CALL_OW 72
73875: ST_TO_ADDR
// if barracks then
73876: LD_VAR 0 8
73880: IFFALSE 74028
// begin selected := 0 ;
73882: LD_ADDR_VAR 0 7
73886: PUSH
73887: LD_INT 0
73889: ST_TO_ADDR
// for j in barracks do
73890: LD_ADDR_VAR 0 3
73894: PUSH
73895: LD_VAR 0 8
73899: PUSH
73900: FOR_IN
73901: IFFALSE 73932
// begin if UnitsInside ( j ) < 6 then
73903: LD_VAR 0 3
73907: PPUSH
73908: CALL_OW 313
73912: PUSH
73913: LD_INT 6
73915: LESS
73916: IFFALSE 73930
// begin selected := j ;
73918: LD_ADDR_VAR 0 7
73922: PUSH
73923: LD_VAR 0 3
73927: ST_TO_ADDR
// break ;
73928: GO 73932
// end ; end ;
73930: GO 73900
73932: POP
73933: POP
// if selected then
73934: LD_VAR 0 7
73938: IFFALSE 74028
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73940: LD_ADDR_VAR 0 3
73944: PUSH
73945: LD_EXP 98
73949: PUSH
73950: LD_VAR 0 2
73954: ARRAY
73955: PPUSH
73956: LD_INT 25
73958: PUSH
73959: LD_INT 12
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PPUSH
73966: CALL_OW 72
73970: PUSH
73971: FOR_IN
73972: IFFALSE 74026
// if not IsInUnit ( j ) and not HasTask ( j ) then
73974: LD_VAR 0 3
73978: PPUSH
73979: CALL_OW 310
73983: NOT
73984: PUSH
73985: LD_VAR 0 3
73989: PPUSH
73990: CALL_OW 314
73994: NOT
73995: AND
73996: IFFALSE 74024
// begin ComEnterUnit ( j , selected ) ;
73998: LD_VAR 0 3
74002: PPUSH
74003: LD_VAR 0 7
74007: PPUSH
74008: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
74012: LD_VAR 0 3
74016: PPUSH
74017: LD_INT 15
74019: PPUSH
74020: CALL_OW 183
// end ;
74024: GO 73971
74026: POP
74027: POP
// end ; end ; end ; end ; end ;
74028: GO 73421
74030: POP
74031: POP
// end ;
74032: LD_VAR 0 1
74036: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
74037: LD_INT 0
74039: PPUSH
74040: PPUSH
74041: PPUSH
74042: PPUSH
// if not mc_bases then
74043: LD_EXP 69
74047: NOT
74048: IFFALSE 74052
// exit ;
74050: GO 74230
// for i = 1 to mc_bases do
74052: LD_ADDR_VAR 0 2
74056: PUSH
74057: DOUBLE
74058: LD_INT 1
74060: DEC
74061: ST_TO_ADDR
74062: LD_EXP 69
74066: PUSH
74067: FOR_TO
74068: IFFALSE 74228
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
74070: LD_ADDR_VAR 0 4
74074: PUSH
74075: LD_EXP 69
74079: PUSH
74080: LD_VAR 0 2
74084: ARRAY
74085: PPUSH
74086: LD_INT 25
74088: PUSH
74089: LD_INT 9
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PPUSH
74096: CALL_OW 72
74100: ST_TO_ADDR
// if not tmp then
74101: LD_VAR 0 4
74105: NOT
74106: IFFALSE 74110
// continue ;
74108: GO 74067
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
74110: LD_EXP 95
74114: PUSH
74115: LD_VAR 0 2
74119: ARRAY
74120: PPUSH
74121: LD_INT 29
74123: PPUSH
74124: CALL_OW 325
74128: NOT
74129: PUSH
74130: LD_EXP 95
74134: PUSH
74135: LD_VAR 0 2
74139: ARRAY
74140: PPUSH
74141: LD_INT 28
74143: PPUSH
74144: CALL_OW 325
74148: NOT
74149: AND
74150: IFFALSE 74154
// continue ;
74152: GO 74067
// for j in tmp do
74154: LD_ADDR_VAR 0 3
74158: PUSH
74159: LD_VAR 0 4
74163: PUSH
74164: FOR_IN
74165: IFFALSE 74224
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74167: LD_VAR 0 3
74171: PUSH
74172: LD_EXP 72
74176: PUSH
74177: LD_VAR 0 2
74181: ARRAY
74182: PUSH
74183: LD_INT 1
74185: ARRAY
74186: IN
74187: NOT
74188: PUSH
74189: LD_VAR 0 3
74193: PUSH
74194: LD_EXP 72
74198: PUSH
74199: LD_VAR 0 2
74203: ARRAY
74204: PUSH
74205: LD_INT 2
74207: ARRAY
74208: IN
74209: NOT
74210: AND
74211: IFFALSE 74222
// ComSpaceTimeShoot ( j ) ;
74213: LD_VAR 0 3
74217: PPUSH
74218: CALL 14549 0 1
74222: GO 74164
74224: POP
74225: POP
// end ;
74226: GO 74067
74228: POP
74229: POP
// end ;
74230: LD_VAR 0 1
74234: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
74235: LD_INT 0
74237: PPUSH
74238: PPUSH
74239: PPUSH
74240: PPUSH
74241: PPUSH
74242: PPUSH
74243: PPUSH
74244: PPUSH
74245: PPUSH
// if not mc_bases then
74246: LD_EXP 69
74250: NOT
74251: IFFALSE 74255
// exit ;
74253: GO 74877
// for i = 1 to mc_bases do
74255: LD_ADDR_VAR 0 2
74259: PUSH
74260: DOUBLE
74261: LD_INT 1
74263: DEC
74264: ST_TO_ADDR
74265: LD_EXP 69
74269: PUSH
74270: FOR_TO
74271: IFFALSE 74875
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
74273: LD_EXP 104
74277: PUSH
74278: LD_VAR 0 2
74282: ARRAY
74283: NOT
74284: PUSH
74285: LD_INT 38
74287: PPUSH
74288: LD_EXP 95
74292: PUSH
74293: LD_VAR 0 2
74297: ARRAY
74298: PPUSH
74299: CALL_OW 321
74303: PUSH
74304: LD_INT 2
74306: NONEQUAL
74307: OR
74308: IFFALSE 74312
// continue ;
74310: GO 74270
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
74312: LD_ADDR_VAR 0 8
74316: PUSH
74317: LD_EXP 69
74321: PUSH
74322: LD_VAR 0 2
74326: ARRAY
74327: PPUSH
74328: LD_INT 30
74330: PUSH
74331: LD_INT 34
74333: PUSH
74334: EMPTY
74335: LIST
74336: LIST
74337: PPUSH
74338: CALL_OW 72
74342: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
74343: LD_ADDR_VAR 0 9
74347: PUSH
74348: LD_EXP 69
74352: PUSH
74353: LD_VAR 0 2
74357: ARRAY
74358: PPUSH
74359: LD_INT 25
74361: PUSH
74362: LD_INT 4
74364: PUSH
74365: EMPTY
74366: LIST
74367: LIST
74368: PPUSH
74369: CALL_OW 72
74373: PPUSH
74374: LD_INT 0
74376: PPUSH
74377: CALL 47857 0 2
74381: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
74382: LD_VAR 0 9
74386: NOT
74387: PUSH
74388: LD_VAR 0 8
74392: NOT
74393: OR
74394: PUSH
74395: LD_EXP 69
74399: PUSH
74400: LD_VAR 0 2
74404: ARRAY
74405: PPUSH
74406: LD_INT 124
74408: PPUSH
74409: CALL 47857 0 2
74413: OR
74414: IFFALSE 74418
// continue ;
74416: GO 74270
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
74418: LD_EXP 105
74422: PUSH
74423: LD_VAR 0 2
74427: ARRAY
74428: PUSH
74429: LD_EXP 104
74433: PUSH
74434: LD_VAR 0 2
74438: ARRAY
74439: LESS
74440: PUSH
74441: LD_EXP 105
74445: PUSH
74446: LD_VAR 0 2
74450: ARRAY
74451: PUSH
74452: LD_VAR 0 8
74456: LESS
74457: AND
74458: IFFALSE 74873
// begin tmp := sci [ 1 ] ;
74460: LD_ADDR_VAR 0 7
74464: PUSH
74465: LD_VAR 0 9
74469: PUSH
74470: LD_INT 1
74472: ARRAY
74473: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
74474: LD_VAR 0 7
74478: PPUSH
74479: LD_INT 124
74481: PPUSH
74482: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
74486: LD_ADDR_VAR 0 3
74490: PUSH
74491: DOUBLE
74492: LD_EXP 104
74496: PUSH
74497: LD_VAR 0 2
74501: ARRAY
74502: INC
74503: ST_TO_ADDR
74504: LD_EXP 104
74508: PUSH
74509: LD_VAR 0 2
74513: ARRAY
74514: PUSH
74515: FOR_DOWNTO
74516: IFFALSE 74859
// begin if IsInUnit ( tmp ) then
74518: LD_VAR 0 7
74522: PPUSH
74523: CALL_OW 310
74527: IFFALSE 74538
// ComExitBuilding ( tmp ) ;
74529: LD_VAR 0 7
74533: PPUSH
74534: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
74538: LD_INT 35
74540: PPUSH
74541: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
74545: LD_VAR 0 7
74549: PPUSH
74550: CALL_OW 310
74554: NOT
74555: PUSH
74556: LD_VAR 0 7
74560: PPUSH
74561: CALL_OW 314
74565: NOT
74566: AND
74567: IFFALSE 74538
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
74569: LD_ADDR_VAR 0 6
74573: PUSH
74574: LD_VAR 0 7
74578: PPUSH
74579: CALL_OW 250
74583: PUSH
74584: LD_VAR 0 7
74588: PPUSH
74589: CALL_OW 251
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74598: LD_INT 35
74600: PPUSH
74601: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
74605: LD_ADDR_VAR 0 4
74609: PUSH
74610: LD_EXP 104
74614: PUSH
74615: LD_VAR 0 2
74619: ARRAY
74620: PUSH
74621: LD_VAR 0 3
74625: ARRAY
74626: PUSH
74627: LD_INT 1
74629: ARRAY
74630: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
74631: LD_ADDR_VAR 0 5
74635: PUSH
74636: LD_EXP 104
74640: PUSH
74641: LD_VAR 0 2
74645: ARRAY
74646: PUSH
74647: LD_VAR 0 3
74651: ARRAY
74652: PUSH
74653: LD_INT 2
74655: ARRAY
74656: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
74657: LD_VAR 0 7
74661: PPUSH
74662: LD_INT 10
74664: PPUSH
74665: CALL 21187 0 2
74669: PUSH
74670: LD_INT 4
74672: ARRAY
74673: IFFALSE 74711
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
74675: LD_VAR 0 7
74679: PPUSH
74680: LD_VAR 0 6
74684: PUSH
74685: LD_INT 1
74687: ARRAY
74688: PPUSH
74689: LD_VAR 0 6
74693: PUSH
74694: LD_INT 2
74696: ARRAY
74697: PPUSH
74698: CALL_OW 111
// wait ( 0 0$10 ) ;
74702: LD_INT 350
74704: PPUSH
74705: CALL_OW 67
// end else
74709: GO 74737
// begin ComMoveXY ( tmp , x , y ) ;
74711: LD_VAR 0 7
74715: PPUSH
74716: LD_VAR 0 4
74720: PPUSH
74721: LD_VAR 0 5
74725: PPUSH
74726: CALL_OW 111
// wait ( 0 0$3 ) ;
74730: LD_INT 105
74732: PPUSH
74733: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
74737: LD_VAR 0 7
74741: PPUSH
74742: LD_VAR 0 4
74746: PPUSH
74747: LD_VAR 0 5
74751: PPUSH
74752: CALL_OW 307
74756: IFFALSE 74598
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
74758: LD_VAR 0 7
74762: PPUSH
74763: LD_VAR 0 4
74767: PPUSH
74768: LD_VAR 0 5
74772: PPUSH
74773: LD_VAR 0 8
74777: PUSH
74778: LD_VAR 0 3
74782: ARRAY
74783: PPUSH
74784: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
74788: LD_INT 35
74790: PPUSH
74791: CALL_OW 67
// until not HasTask ( tmp ) ;
74795: LD_VAR 0 7
74799: PPUSH
74800: CALL_OW 314
74804: NOT
74805: IFFALSE 74788
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
74807: LD_ADDR_EXP 105
74811: PUSH
74812: LD_EXP 105
74816: PPUSH
74817: LD_VAR 0 2
74821: PUSH
74822: LD_EXP 105
74826: PUSH
74827: LD_VAR 0 2
74831: ARRAY
74832: PUSH
74833: LD_INT 1
74835: PLUS
74836: PUSH
74837: EMPTY
74838: LIST
74839: LIST
74840: PPUSH
74841: LD_VAR 0 8
74845: PUSH
74846: LD_VAR 0 3
74850: ARRAY
74851: PPUSH
74852: CALL 18588 0 3
74856: ST_TO_ADDR
// end ;
74857: GO 74515
74859: POP
74860: POP
// MC_Reset ( i , 124 ) ;
74861: LD_VAR 0 2
74865: PPUSH
74866: LD_INT 124
74868: PPUSH
74869: CALL 58015 0 2
// end ; end ;
74873: GO 74270
74875: POP
74876: POP
// end ;
74877: LD_VAR 0 1
74881: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
74882: LD_INT 0
74884: PPUSH
74885: PPUSH
74886: PPUSH
// if not mc_bases then
74887: LD_EXP 69
74891: NOT
74892: IFFALSE 74896
// exit ;
74894: GO 75502
// for i = 1 to mc_bases do
74896: LD_ADDR_VAR 0 2
74900: PUSH
74901: DOUBLE
74902: LD_INT 1
74904: DEC
74905: ST_TO_ADDR
74906: LD_EXP 69
74910: PUSH
74911: FOR_TO
74912: IFFALSE 75500
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
74914: LD_ADDR_VAR 0 3
74918: PUSH
74919: LD_EXP 69
74923: PUSH
74924: LD_VAR 0 2
74928: ARRAY
74929: PPUSH
74930: LD_INT 25
74932: PUSH
74933: LD_INT 4
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: PPUSH
74940: CALL_OW 72
74944: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
74945: LD_VAR 0 3
74949: NOT
74950: PUSH
74951: LD_EXP 106
74955: PUSH
74956: LD_VAR 0 2
74960: ARRAY
74961: NOT
74962: OR
74963: PUSH
74964: LD_EXP 69
74968: PUSH
74969: LD_VAR 0 2
74973: ARRAY
74974: PPUSH
74975: LD_INT 2
74977: PUSH
74978: LD_INT 30
74980: PUSH
74981: LD_INT 0
74983: PUSH
74984: EMPTY
74985: LIST
74986: LIST
74987: PUSH
74988: LD_INT 30
74990: PUSH
74991: LD_INT 1
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: PUSH
74998: EMPTY
74999: LIST
75000: LIST
75001: LIST
75002: PPUSH
75003: CALL_OW 72
75007: NOT
75008: OR
75009: IFFALSE 75059
// begin if mc_deposits_finder [ i ] then
75011: LD_EXP 107
75015: PUSH
75016: LD_VAR 0 2
75020: ARRAY
75021: IFFALSE 75057
// begin MC_Reset ( i , 125 ) ;
75023: LD_VAR 0 2
75027: PPUSH
75028: LD_INT 125
75030: PPUSH
75031: CALL 58015 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75035: LD_ADDR_EXP 107
75039: PUSH
75040: LD_EXP 107
75044: PPUSH
75045: LD_VAR 0 2
75049: PPUSH
75050: EMPTY
75051: PPUSH
75052: CALL_OW 1
75056: ST_TO_ADDR
// end ; continue ;
75057: GO 74911
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
75059: LD_EXP 106
75063: PUSH
75064: LD_VAR 0 2
75068: ARRAY
75069: PUSH
75070: LD_INT 1
75072: ARRAY
75073: PUSH
75074: LD_INT 3
75076: ARRAY
75077: PUSH
75078: LD_INT 1
75080: EQUAL
75081: PUSH
75082: LD_INT 20
75084: PPUSH
75085: LD_EXP 95
75089: PUSH
75090: LD_VAR 0 2
75094: ARRAY
75095: PPUSH
75096: CALL_OW 321
75100: PUSH
75101: LD_INT 2
75103: NONEQUAL
75104: AND
75105: IFFALSE 75155
// begin if mc_deposits_finder [ i ] then
75107: LD_EXP 107
75111: PUSH
75112: LD_VAR 0 2
75116: ARRAY
75117: IFFALSE 75153
// begin MC_Reset ( i , 125 ) ;
75119: LD_VAR 0 2
75123: PPUSH
75124: LD_INT 125
75126: PPUSH
75127: CALL 58015 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75131: LD_ADDR_EXP 107
75135: PUSH
75136: LD_EXP 107
75140: PPUSH
75141: LD_VAR 0 2
75145: PPUSH
75146: EMPTY
75147: PPUSH
75148: CALL_OW 1
75152: ST_TO_ADDR
// end ; continue ;
75153: GO 74911
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
75155: LD_EXP 106
75159: PUSH
75160: LD_VAR 0 2
75164: ARRAY
75165: PUSH
75166: LD_INT 1
75168: ARRAY
75169: PUSH
75170: LD_INT 1
75172: ARRAY
75173: PPUSH
75174: LD_EXP 106
75178: PUSH
75179: LD_VAR 0 2
75183: ARRAY
75184: PUSH
75185: LD_INT 1
75187: ARRAY
75188: PUSH
75189: LD_INT 2
75191: ARRAY
75192: PPUSH
75193: LD_EXP 95
75197: PUSH
75198: LD_VAR 0 2
75202: ARRAY
75203: PPUSH
75204: CALL_OW 440
75208: IFFALSE 75251
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
75210: LD_ADDR_EXP 106
75214: PUSH
75215: LD_EXP 106
75219: PPUSH
75220: LD_VAR 0 2
75224: PPUSH
75225: LD_EXP 106
75229: PUSH
75230: LD_VAR 0 2
75234: ARRAY
75235: PPUSH
75236: LD_INT 1
75238: PPUSH
75239: CALL_OW 3
75243: PPUSH
75244: CALL_OW 1
75248: ST_TO_ADDR
75249: GO 75498
// begin if not mc_deposits_finder [ i ] then
75251: LD_EXP 107
75255: PUSH
75256: LD_VAR 0 2
75260: ARRAY
75261: NOT
75262: IFFALSE 75314
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
75264: LD_ADDR_EXP 107
75268: PUSH
75269: LD_EXP 107
75273: PPUSH
75274: LD_VAR 0 2
75278: PPUSH
75279: LD_VAR 0 3
75283: PUSH
75284: LD_INT 1
75286: ARRAY
75287: PUSH
75288: EMPTY
75289: LIST
75290: PPUSH
75291: CALL_OW 1
75295: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
75296: LD_VAR 0 3
75300: PUSH
75301: LD_INT 1
75303: ARRAY
75304: PPUSH
75305: LD_INT 125
75307: PPUSH
75308: CALL_OW 109
// end else
75312: GO 75498
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
75314: LD_EXP 107
75318: PUSH
75319: LD_VAR 0 2
75323: ARRAY
75324: PUSH
75325: LD_INT 1
75327: ARRAY
75328: PPUSH
75329: CALL_OW 310
75333: IFFALSE 75356
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
75335: LD_EXP 107
75339: PUSH
75340: LD_VAR 0 2
75344: ARRAY
75345: PUSH
75346: LD_INT 1
75348: ARRAY
75349: PPUSH
75350: CALL_OW 122
75354: GO 75498
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
75356: LD_EXP 107
75360: PUSH
75361: LD_VAR 0 2
75365: ARRAY
75366: PUSH
75367: LD_INT 1
75369: ARRAY
75370: PPUSH
75371: CALL_OW 314
75375: NOT
75376: PUSH
75377: LD_EXP 107
75381: PUSH
75382: LD_VAR 0 2
75386: ARRAY
75387: PUSH
75388: LD_INT 1
75390: ARRAY
75391: PPUSH
75392: LD_EXP 106
75396: PUSH
75397: LD_VAR 0 2
75401: ARRAY
75402: PUSH
75403: LD_INT 1
75405: ARRAY
75406: PUSH
75407: LD_INT 1
75409: ARRAY
75410: PPUSH
75411: LD_EXP 106
75415: PUSH
75416: LD_VAR 0 2
75420: ARRAY
75421: PUSH
75422: LD_INT 1
75424: ARRAY
75425: PUSH
75426: LD_INT 2
75428: ARRAY
75429: PPUSH
75430: CALL_OW 297
75434: PUSH
75435: LD_INT 6
75437: GREATER
75438: AND
75439: IFFALSE 75498
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
75441: LD_EXP 107
75445: PUSH
75446: LD_VAR 0 2
75450: ARRAY
75451: PUSH
75452: LD_INT 1
75454: ARRAY
75455: PPUSH
75456: LD_EXP 106
75460: PUSH
75461: LD_VAR 0 2
75465: ARRAY
75466: PUSH
75467: LD_INT 1
75469: ARRAY
75470: PUSH
75471: LD_INT 1
75473: ARRAY
75474: PPUSH
75475: LD_EXP 106
75479: PUSH
75480: LD_VAR 0 2
75484: ARRAY
75485: PUSH
75486: LD_INT 1
75488: ARRAY
75489: PUSH
75490: LD_INT 2
75492: ARRAY
75493: PPUSH
75494: CALL_OW 111
// end ; end ; end ;
75498: GO 74911
75500: POP
75501: POP
// end ;
75502: LD_VAR 0 1
75506: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
75507: LD_INT 0
75509: PPUSH
75510: PPUSH
75511: PPUSH
75512: PPUSH
75513: PPUSH
75514: PPUSH
75515: PPUSH
75516: PPUSH
75517: PPUSH
75518: PPUSH
75519: PPUSH
// if not mc_bases then
75520: LD_EXP 69
75524: NOT
75525: IFFALSE 75529
// exit ;
75527: GO 76469
// for i = 1 to mc_bases do
75529: LD_ADDR_VAR 0 2
75533: PUSH
75534: DOUBLE
75535: LD_INT 1
75537: DEC
75538: ST_TO_ADDR
75539: LD_EXP 69
75543: PUSH
75544: FOR_TO
75545: IFFALSE 76467
// begin if not mc_bases [ i ] or mc_scan [ i ] then
75547: LD_EXP 69
75551: PUSH
75552: LD_VAR 0 2
75556: ARRAY
75557: NOT
75558: PUSH
75559: LD_EXP 92
75563: PUSH
75564: LD_VAR 0 2
75568: ARRAY
75569: OR
75570: IFFALSE 75574
// continue ;
75572: GO 75544
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
75574: LD_ADDR_VAR 0 7
75578: PUSH
75579: LD_EXP 69
75583: PUSH
75584: LD_VAR 0 2
75588: ARRAY
75589: PUSH
75590: LD_INT 1
75592: ARRAY
75593: PPUSH
75594: CALL_OW 248
75598: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
75599: LD_VAR 0 7
75603: PUSH
75604: LD_INT 3
75606: EQUAL
75607: PUSH
75608: LD_EXP 88
75612: PUSH
75613: LD_VAR 0 2
75617: ARRAY
75618: PUSH
75619: LD_EXP 91
75623: PUSH
75624: LD_VAR 0 2
75628: ARRAY
75629: UNION
75630: PPUSH
75631: LD_INT 33
75633: PUSH
75634: LD_INT 2
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PPUSH
75641: CALL_OW 72
75645: NOT
75646: OR
75647: IFFALSE 75651
// continue ;
75649: GO 75544
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
75651: LD_ADDR_VAR 0 9
75655: PUSH
75656: LD_EXP 69
75660: PUSH
75661: LD_VAR 0 2
75665: ARRAY
75666: PPUSH
75667: LD_INT 30
75669: PUSH
75670: LD_INT 36
75672: PUSH
75673: EMPTY
75674: LIST
75675: LIST
75676: PPUSH
75677: CALL_OW 72
75681: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
75682: LD_ADDR_VAR 0 10
75686: PUSH
75687: LD_EXP 88
75691: PUSH
75692: LD_VAR 0 2
75696: ARRAY
75697: PPUSH
75698: LD_INT 34
75700: PUSH
75701: LD_INT 31
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: PPUSH
75708: CALL_OW 72
75712: ST_TO_ADDR
// if not cts and not mcts then
75713: LD_VAR 0 9
75717: NOT
75718: PUSH
75719: LD_VAR 0 10
75723: NOT
75724: AND
75725: IFFALSE 75729
// continue ;
75727: GO 75544
// x := cts ;
75729: LD_ADDR_VAR 0 11
75733: PUSH
75734: LD_VAR 0 9
75738: ST_TO_ADDR
// if not x then
75739: LD_VAR 0 11
75743: NOT
75744: IFFALSE 75756
// x := mcts ;
75746: LD_ADDR_VAR 0 11
75750: PUSH
75751: LD_VAR 0 10
75755: ST_TO_ADDR
// if not x then
75756: LD_VAR 0 11
75760: NOT
75761: IFFALSE 75765
// continue ;
75763: GO 75544
// if mc_remote_driver [ i ] then
75765: LD_EXP 109
75769: PUSH
75770: LD_VAR 0 2
75774: ARRAY
75775: IFFALSE 76162
// for j in mc_remote_driver [ i ] do
75777: LD_ADDR_VAR 0 3
75781: PUSH
75782: LD_EXP 109
75786: PUSH
75787: LD_VAR 0 2
75791: ARRAY
75792: PUSH
75793: FOR_IN
75794: IFFALSE 76160
// begin if GetClass ( j ) <> 3 then
75796: LD_VAR 0 3
75800: PPUSH
75801: CALL_OW 257
75805: PUSH
75806: LD_INT 3
75808: NONEQUAL
75809: IFFALSE 75862
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
75811: LD_ADDR_EXP 109
75815: PUSH
75816: LD_EXP 109
75820: PPUSH
75821: LD_VAR 0 2
75825: PPUSH
75826: LD_EXP 109
75830: PUSH
75831: LD_VAR 0 2
75835: ARRAY
75836: PUSH
75837: LD_VAR 0 3
75841: DIFF
75842: PPUSH
75843: CALL_OW 1
75847: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75848: LD_VAR 0 3
75852: PPUSH
75853: LD_INT 0
75855: PPUSH
75856: CALL_OW 109
// continue ;
75860: GO 75793
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
75862: LD_EXP 88
75866: PUSH
75867: LD_VAR 0 2
75871: ARRAY
75872: PPUSH
75873: LD_INT 34
75875: PUSH
75876: LD_INT 31
75878: PUSH
75879: EMPTY
75880: LIST
75881: LIST
75882: PUSH
75883: LD_INT 58
75885: PUSH
75886: EMPTY
75887: LIST
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: PPUSH
75893: CALL_OW 72
75897: PUSH
75898: LD_VAR 0 3
75902: PPUSH
75903: CALL 47945 0 1
75907: NOT
75908: AND
75909: IFFALSE 75980
// begin if IsInUnit ( j ) then
75911: LD_VAR 0 3
75915: PPUSH
75916: CALL_OW 310
75920: IFFALSE 75931
// ComExitBuilding ( j ) ;
75922: LD_VAR 0 3
75926: PPUSH
75927: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
75931: LD_VAR 0 3
75935: PPUSH
75936: LD_EXP 88
75940: PUSH
75941: LD_VAR 0 2
75945: ARRAY
75946: PPUSH
75947: LD_INT 34
75949: PUSH
75950: LD_INT 31
75952: PUSH
75953: EMPTY
75954: LIST
75955: LIST
75956: PUSH
75957: LD_INT 58
75959: PUSH
75960: EMPTY
75961: LIST
75962: PUSH
75963: EMPTY
75964: LIST
75965: LIST
75966: PPUSH
75967: CALL_OW 72
75971: PUSH
75972: LD_INT 1
75974: ARRAY
75975: PPUSH
75976: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
75980: LD_VAR 0 3
75984: PPUSH
75985: CALL_OW 310
75989: NOT
75990: PUSH
75991: LD_VAR 0 3
75995: PPUSH
75996: CALL_OW 310
76000: PPUSH
76001: CALL_OW 266
76005: PUSH
76006: LD_INT 36
76008: NONEQUAL
76009: PUSH
76010: LD_VAR 0 3
76014: PPUSH
76015: CALL 47945 0 1
76019: NOT
76020: AND
76021: OR
76022: IFFALSE 76158
// begin if IsInUnit ( j ) then
76024: LD_VAR 0 3
76028: PPUSH
76029: CALL_OW 310
76033: IFFALSE 76044
// ComExitBuilding ( j ) ;
76035: LD_VAR 0 3
76039: PPUSH
76040: CALL_OW 122
// ct := 0 ;
76044: LD_ADDR_VAR 0 8
76048: PUSH
76049: LD_INT 0
76051: ST_TO_ADDR
// for k in x do
76052: LD_ADDR_VAR 0 4
76056: PUSH
76057: LD_VAR 0 11
76061: PUSH
76062: FOR_IN
76063: IFFALSE 76136
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
76065: LD_VAR 0 4
76069: PPUSH
76070: CALL_OW 264
76074: PUSH
76075: LD_INT 31
76077: EQUAL
76078: PUSH
76079: LD_VAR 0 4
76083: PPUSH
76084: CALL_OW 311
76088: NOT
76089: AND
76090: PUSH
76091: LD_VAR 0 4
76095: PPUSH
76096: CALL_OW 266
76100: PUSH
76101: LD_INT 36
76103: EQUAL
76104: PUSH
76105: LD_VAR 0 4
76109: PPUSH
76110: CALL_OW 313
76114: PUSH
76115: LD_INT 3
76117: LESS
76118: AND
76119: OR
76120: IFFALSE 76134
// begin ct := k ;
76122: LD_ADDR_VAR 0 8
76126: PUSH
76127: LD_VAR 0 4
76131: ST_TO_ADDR
// break ;
76132: GO 76136
// end ;
76134: GO 76062
76136: POP
76137: POP
// if ct then
76138: LD_VAR 0 8
76142: IFFALSE 76158
// ComEnterUnit ( j , ct ) ;
76144: LD_VAR 0 3
76148: PPUSH
76149: LD_VAR 0 8
76153: PPUSH
76154: CALL_OW 120
// end ; end ;
76158: GO 75793
76160: POP
76161: POP
// places := 0 ;
76162: LD_ADDR_VAR 0 5
76166: PUSH
76167: LD_INT 0
76169: ST_TO_ADDR
// for j = 1 to x do
76170: LD_ADDR_VAR 0 3
76174: PUSH
76175: DOUBLE
76176: LD_INT 1
76178: DEC
76179: ST_TO_ADDR
76180: LD_VAR 0 11
76184: PUSH
76185: FOR_TO
76186: IFFALSE 76262
// if GetWeapon ( x [ j ] ) = ar_control_tower then
76188: LD_VAR 0 11
76192: PUSH
76193: LD_VAR 0 3
76197: ARRAY
76198: PPUSH
76199: CALL_OW 264
76203: PUSH
76204: LD_INT 31
76206: EQUAL
76207: IFFALSE 76225
// places := places + 1 else
76209: LD_ADDR_VAR 0 5
76213: PUSH
76214: LD_VAR 0 5
76218: PUSH
76219: LD_INT 1
76221: PLUS
76222: ST_TO_ADDR
76223: GO 76260
// if GetBType ( x [ j ] ) = b_control_tower then
76225: LD_VAR 0 11
76229: PUSH
76230: LD_VAR 0 3
76234: ARRAY
76235: PPUSH
76236: CALL_OW 266
76240: PUSH
76241: LD_INT 36
76243: EQUAL
76244: IFFALSE 76260
// places := places + 3 ;
76246: LD_ADDR_VAR 0 5
76250: PUSH
76251: LD_VAR 0 5
76255: PUSH
76256: LD_INT 3
76258: PLUS
76259: ST_TO_ADDR
76260: GO 76185
76262: POP
76263: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
76264: LD_VAR 0 5
76268: PUSH
76269: LD_INT 0
76271: EQUAL
76272: PUSH
76273: LD_VAR 0 5
76277: PUSH
76278: LD_EXP 109
76282: PUSH
76283: LD_VAR 0 2
76287: ARRAY
76288: LESSEQUAL
76289: OR
76290: IFFALSE 76294
// continue ;
76292: GO 75544
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
76294: LD_ADDR_VAR 0 6
76298: PUSH
76299: LD_EXP 69
76303: PUSH
76304: LD_VAR 0 2
76308: ARRAY
76309: PPUSH
76310: LD_INT 25
76312: PUSH
76313: LD_INT 3
76315: PUSH
76316: EMPTY
76317: LIST
76318: LIST
76319: PPUSH
76320: CALL_OW 72
76324: PUSH
76325: LD_EXP 109
76329: PUSH
76330: LD_VAR 0 2
76334: ARRAY
76335: DIFF
76336: PPUSH
76337: LD_INT 3
76339: PPUSH
76340: CALL 48845 0 2
76344: ST_TO_ADDR
// for j in tmp do
76345: LD_ADDR_VAR 0 3
76349: PUSH
76350: LD_VAR 0 6
76354: PUSH
76355: FOR_IN
76356: IFFALSE 76391
// if GetTag ( j ) > 0 then
76358: LD_VAR 0 3
76362: PPUSH
76363: CALL_OW 110
76367: PUSH
76368: LD_INT 0
76370: GREATER
76371: IFFALSE 76389
// tmp := tmp diff j ;
76373: LD_ADDR_VAR 0 6
76377: PUSH
76378: LD_VAR 0 6
76382: PUSH
76383: LD_VAR 0 3
76387: DIFF
76388: ST_TO_ADDR
76389: GO 76355
76391: POP
76392: POP
// if not tmp then
76393: LD_VAR 0 6
76397: NOT
76398: IFFALSE 76402
// continue ;
76400: GO 75544
// if places then
76402: LD_VAR 0 5
76406: IFFALSE 76465
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
76408: LD_ADDR_EXP 109
76412: PUSH
76413: LD_EXP 109
76417: PPUSH
76418: LD_VAR 0 2
76422: PPUSH
76423: LD_EXP 109
76427: PUSH
76428: LD_VAR 0 2
76432: ARRAY
76433: PUSH
76434: LD_VAR 0 6
76438: PUSH
76439: LD_INT 1
76441: ARRAY
76442: UNION
76443: PPUSH
76444: CALL_OW 1
76448: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
76449: LD_VAR 0 6
76453: PUSH
76454: LD_INT 1
76456: ARRAY
76457: PPUSH
76458: LD_INT 126
76460: PPUSH
76461: CALL_OW 109
// end ; end ;
76465: GO 75544
76467: POP
76468: POP
// end ;
76469: LD_VAR 0 1
76473: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
76474: LD_INT 0
76476: PPUSH
76477: PPUSH
76478: PPUSH
76479: PPUSH
76480: PPUSH
76481: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
76482: LD_VAR 0 1
76486: NOT
76487: PUSH
76488: LD_VAR 0 2
76492: NOT
76493: OR
76494: PUSH
76495: LD_VAR 0 3
76499: NOT
76500: OR
76501: PUSH
76502: LD_VAR 0 4
76506: PUSH
76507: LD_INT 1
76509: PUSH
76510: LD_INT 2
76512: PUSH
76513: LD_INT 3
76515: PUSH
76516: LD_INT 4
76518: PUSH
76519: LD_INT 5
76521: PUSH
76522: LD_INT 8
76524: PUSH
76525: LD_INT 9
76527: PUSH
76528: LD_INT 15
76530: PUSH
76531: LD_INT 16
76533: PUSH
76534: EMPTY
76535: LIST
76536: LIST
76537: LIST
76538: LIST
76539: LIST
76540: LIST
76541: LIST
76542: LIST
76543: LIST
76544: IN
76545: NOT
76546: OR
76547: IFFALSE 76551
// exit ;
76549: GO 77451
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
76551: LD_ADDR_VAR 0 2
76555: PUSH
76556: LD_VAR 0 2
76560: PPUSH
76561: LD_INT 21
76563: PUSH
76564: LD_INT 3
76566: PUSH
76567: EMPTY
76568: LIST
76569: LIST
76570: PUSH
76571: LD_INT 24
76573: PUSH
76574: LD_INT 250
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: PPUSH
76585: CALL_OW 72
76589: ST_TO_ADDR
// case class of 1 , 15 :
76590: LD_VAR 0 4
76594: PUSH
76595: LD_INT 1
76597: DOUBLE
76598: EQUAL
76599: IFTRUE 76609
76601: LD_INT 15
76603: DOUBLE
76604: EQUAL
76605: IFTRUE 76609
76607: GO 76694
76609: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
76610: LD_ADDR_VAR 0 8
76614: PUSH
76615: LD_VAR 0 2
76619: PPUSH
76620: LD_INT 2
76622: PUSH
76623: LD_INT 30
76625: PUSH
76626: LD_INT 32
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 30
76635: PUSH
76636: LD_INT 31
76638: PUSH
76639: EMPTY
76640: LIST
76641: LIST
76642: PUSH
76643: EMPTY
76644: LIST
76645: LIST
76646: LIST
76647: PPUSH
76648: CALL_OW 72
76652: PUSH
76653: LD_VAR 0 2
76657: PPUSH
76658: LD_INT 2
76660: PUSH
76661: LD_INT 30
76663: PUSH
76664: LD_INT 4
76666: PUSH
76667: EMPTY
76668: LIST
76669: LIST
76670: PUSH
76671: LD_INT 30
76673: PUSH
76674: LD_INT 5
76676: PUSH
76677: EMPTY
76678: LIST
76679: LIST
76680: PUSH
76681: EMPTY
76682: LIST
76683: LIST
76684: LIST
76685: PPUSH
76686: CALL_OW 72
76690: ADD
76691: ST_TO_ADDR
76692: GO 76940
76694: LD_INT 2
76696: DOUBLE
76697: EQUAL
76698: IFTRUE 76708
76700: LD_INT 16
76702: DOUBLE
76703: EQUAL
76704: IFTRUE 76708
76706: GO 76754
76708: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
76709: LD_ADDR_VAR 0 8
76713: PUSH
76714: LD_VAR 0 2
76718: PPUSH
76719: LD_INT 2
76721: PUSH
76722: LD_INT 30
76724: PUSH
76725: LD_INT 0
76727: PUSH
76728: EMPTY
76729: LIST
76730: LIST
76731: PUSH
76732: LD_INT 30
76734: PUSH
76735: LD_INT 1
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: PUSH
76742: EMPTY
76743: LIST
76744: LIST
76745: LIST
76746: PPUSH
76747: CALL_OW 72
76751: ST_TO_ADDR
76752: GO 76940
76754: LD_INT 3
76756: DOUBLE
76757: EQUAL
76758: IFTRUE 76762
76760: GO 76808
76762: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
76763: LD_ADDR_VAR 0 8
76767: PUSH
76768: LD_VAR 0 2
76772: PPUSH
76773: LD_INT 2
76775: PUSH
76776: LD_INT 30
76778: PUSH
76779: LD_INT 2
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: LD_INT 30
76788: PUSH
76789: LD_INT 3
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: PUSH
76796: EMPTY
76797: LIST
76798: LIST
76799: LIST
76800: PPUSH
76801: CALL_OW 72
76805: ST_TO_ADDR
76806: GO 76940
76808: LD_INT 4
76810: DOUBLE
76811: EQUAL
76812: IFTRUE 76816
76814: GO 76873
76816: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
76817: LD_ADDR_VAR 0 8
76821: PUSH
76822: LD_VAR 0 2
76826: PPUSH
76827: LD_INT 2
76829: PUSH
76830: LD_INT 30
76832: PUSH
76833: LD_INT 6
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: PUSH
76840: LD_INT 30
76842: PUSH
76843: LD_INT 7
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: LD_INT 30
76852: PUSH
76853: LD_INT 8
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: PUSH
76860: EMPTY
76861: LIST
76862: LIST
76863: LIST
76864: LIST
76865: PPUSH
76866: CALL_OW 72
76870: ST_TO_ADDR
76871: GO 76940
76873: LD_INT 5
76875: DOUBLE
76876: EQUAL
76877: IFTRUE 76893
76879: LD_INT 8
76881: DOUBLE
76882: EQUAL
76883: IFTRUE 76893
76885: LD_INT 9
76887: DOUBLE
76888: EQUAL
76889: IFTRUE 76893
76891: GO 76939
76893: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
76894: LD_ADDR_VAR 0 8
76898: PUSH
76899: LD_VAR 0 2
76903: PPUSH
76904: LD_INT 2
76906: PUSH
76907: LD_INT 30
76909: PUSH
76910: LD_INT 4
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: LD_INT 30
76919: PUSH
76920: LD_INT 5
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: EMPTY
76928: LIST
76929: LIST
76930: LIST
76931: PPUSH
76932: CALL_OW 72
76936: ST_TO_ADDR
76937: GO 76940
76939: POP
// if not tmp then
76940: LD_VAR 0 8
76944: NOT
76945: IFFALSE 76949
// exit ;
76947: GO 77451
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
76949: LD_VAR 0 4
76953: PUSH
76954: LD_INT 1
76956: PUSH
76957: LD_INT 15
76959: PUSH
76960: EMPTY
76961: LIST
76962: LIST
76963: IN
76964: PUSH
76965: LD_EXP 78
76969: PUSH
76970: LD_VAR 0 1
76974: ARRAY
76975: AND
76976: IFFALSE 77132
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
76978: LD_ADDR_VAR 0 9
76982: PUSH
76983: LD_EXP 78
76987: PUSH
76988: LD_VAR 0 1
76992: ARRAY
76993: PUSH
76994: LD_INT 1
76996: ARRAY
76997: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
76998: LD_VAR 0 9
77002: PUSH
77003: LD_EXP 79
77007: PUSH
77008: LD_VAR 0 1
77012: ARRAY
77013: IN
77014: NOT
77015: IFFALSE 77130
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
77017: LD_ADDR_EXP 79
77021: PUSH
77022: LD_EXP 79
77026: PPUSH
77027: LD_VAR 0 1
77031: PUSH
77032: LD_EXP 79
77036: PUSH
77037: LD_VAR 0 1
77041: ARRAY
77042: PUSH
77043: LD_INT 1
77045: PLUS
77046: PUSH
77047: EMPTY
77048: LIST
77049: LIST
77050: PPUSH
77051: LD_VAR 0 9
77055: PPUSH
77056: CALL 18588 0 3
77060: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
77061: LD_ADDR_EXP 78
77065: PUSH
77066: LD_EXP 78
77070: PPUSH
77071: LD_VAR 0 1
77075: PPUSH
77076: LD_EXP 78
77080: PUSH
77081: LD_VAR 0 1
77085: ARRAY
77086: PUSH
77087: LD_VAR 0 9
77091: DIFF
77092: PPUSH
77093: CALL_OW 1
77097: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
77098: LD_VAR 0 3
77102: PPUSH
77103: LD_EXP 79
77107: PUSH
77108: LD_VAR 0 1
77112: ARRAY
77113: PUSH
77114: LD_EXP 79
77118: PUSH
77119: LD_VAR 0 1
77123: ARRAY
77124: ARRAY
77125: PPUSH
77126: CALL_OW 120
// end ; exit ;
77130: GO 77451
// end ; if tmp > 1 then
77132: LD_VAR 0 8
77136: PUSH
77137: LD_INT 1
77139: GREATER
77140: IFFALSE 77244
// for i = 2 to tmp do
77142: LD_ADDR_VAR 0 6
77146: PUSH
77147: DOUBLE
77148: LD_INT 2
77150: DEC
77151: ST_TO_ADDR
77152: LD_VAR 0 8
77156: PUSH
77157: FOR_TO
77158: IFFALSE 77242
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
77160: LD_VAR 0 8
77164: PUSH
77165: LD_VAR 0 6
77169: ARRAY
77170: PPUSH
77171: CALL_OW 461
77175: PUSH
77176: LD_INT 6
77178: EQUAL
77179: IFFALSE 77240
// begin x := tmp [ i ] ;
77181: LD_ADDR_VAR 0 9
77185: PUSH
77186: LD_VAR 0 8
77190: PUSH
77191: LD_VAR 0 6
77195: ARRAY
77196: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
77197: LD_ADDR_VAR 0 8
77201: PUSH
77202: LD_VAR 0 8
77206: PPUSH
77207: LD_VAR 0 6
77211: PPUSH
77212: CALL_OW 3
77216: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
77217: LD_ADDR_VAR 0 8
77221: PUSH
77222: LD_VAR 0 8
77226: PPUSH
77227: LD_INT 1
77229: PPUSH
77230: LD_VAR 0 9
77234: PPUSH
77235: CALL_OW 2
77239: ST_TO_ADDR
// end ;
77240: GO 77157
77242: POP
77243: POP
// for i in tmp do
77244: LD_ADDR_VAR 0 6
77248: PUSH
77249: LD_VAR 0 8
77253: PUSH
77254: FOR_IN
77255: IFFALSE 77324
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
77257: LD_VAR 0 6
77261: PPUSH
77262: CALL_OW 313
77266: PUSH
77267: LD_INT 6
77269: LESS
77270: PUSH
77271: LD_VAR 0 6
77275: PPUSH
77276: CALL_OW 266
77280: PUSH
77281: LD_INT 31
77283: PUSH
77284: LD_INT 32
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: IN
77291: NOT
77292: AND
77293: PUSH
77294: LD_VAR 0 6
77298: PPUSH
77299: CALL_OW 313
77303: PUSH
77304: LD_INT 0
77306: EQUAL
77307: OR
77308: IFFALSE 77322
// begin j := i ;
77310: LD_ADDR_VAR 0 7
77314: PUSH
77315: LD_VAR 0 6
77319: ST_TO_ADDR
// break ;
77320: GO 77324
// end ; end ;
77322: GO 77254
77324: POP
77325: POP
// if j then
77326: LD_VAR 0 7
77330: IFFALSE 77348
// ComEnterUnit ( unit , j ) else
77332: LD_VAR 0 3
77336: PPUSH
77337: LD_VAR 0 7
77341: PPUSH
77342: CALL_OW 120
77346: GO 77451
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77348: LD_ADDR_VAR 0 10
77352: PUSH
77353: LD_VAR 0 2
77357: PPUSH
77358: LD_INT 2
77360: PUSH
77361: LD_INT 30
77363: PUSH
77364: LD_INT 0
77366: PUSH
77367: EMPTY
77368: LIST
77369: LIST
77370: PUSH
77371: LD_INT 30
77373: PUSH
77374: LD_INT 1
77376: PUSH
77377: EMPTY
77378: LIST
77379: LIST
77380: PUSH
77381: EMPTY
77382: LIST
77383: LIST
77384: LIST
77385: PPUSH
77386: CALL_OW 72
77390: ST_TO_ADDR
// if depot then
77391: LD_VAR 0 10
77395: IFFALSE 77451
// begin depot := NearestUnitToUnit ( depot , unit ) ;
77397: LD_ADDR_VAR 0 10
77401: PUSH
77402: LD_VAR 0 10
77406: PPUSH
77407: LD_VAR 0 3
77411: PPUSH
77412: CALL_OW 74
77416: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
77417: LD_VAR 0 3
77421: PPUSH
77422: LD_VAR 0 10
77426: PPUSH
77427: CALL_OW 296
77431: PUSH
77432: LD_INT 10
77434: GREATER
77435: IFFALSE 77451
// ComStandNearbyBuilding ( unit , depot ) ;
77437: LD_VAR 0 3
77441: PPUSH
77442: LD_VAR 0 10
77446: PPUSH
77447: CALL 15166 0 2
// end ; end ; end ;
77451: LD_VAR 0 5
77455: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
77456: LD_INT 0
77458: PPUSH
77459: PPUSH
77460: PPUSH
77461: PPUSH
// if not mc_bases then
77462: LD_EXP 69
77466: NOT
77467: IFFALSE 77471
// exit ;
77469: GO 77710
// for i = 1 to mc_bases do
77471: LD_ADDR_VAR 0 2
77475: PUSH
77476: DOUBLE
77477: LD_INT 1
77479: DEC
77480: ST_TO_ADDR
77481: LD_EXP 69
77485: PUSH
77486: FOR_TO
77487: IFFALSE 77708
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
77489: LD_ADDR_VAR 0 4
77493: PUSH
77494: LD_EXP 69
77498: PUSH
77499: LD_VAR 0 2
77503: ARRAY
77504: PPUSH
77505: LD_INT 21
77507: PUSH
77508: LD_INT 1
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: PPUSH
77515: CALL_OW 72
77519: PUSH
77520: LD_EXP 98
77524: PUSH
77525: LD_VAR 0 2
77529: ARRAY
77530: UNION
77531: ST_TO_ADDR
// if not tmp then
77532: LD_VAR 0 4
77536: NOT
77537: IFFALSE 77541
// continue ;
77539: GO 77486
// for j in tmp do
77541: LD_ADDR_VAR 0 3
77545: PUSH
77546: LD_VAR 0 4
77550: PUSH
77551: FOR_IN
77552: IFFALSE 77704
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
77554: LD_VAR 0 3
77558: PPUSH
77559: CALL_OW 110
77563: NOT
77564: PUSH
77565: LD_VAR 0 3
77569: PPUSH
77570: CALL_OW 314
77574: NOT
77575: AND
77576: PUSH
77577: LD_VAR 0 3
77581: PPUSH
77582: CALL_OW 311
77586: NOT
77587: AND
77588: PUSH
77589: LD_VAR 0 3
77593: PPUSH
77594: CALL_OW 310
77598: NOT
77599: AND
77600: PUSH
77601: LD_VAR 0 3
77605: PUSH
77606: LD_EXP 72
77610: PUSH
77611: LD_VAR 0 2
77615: ARRAY
77616: PUSH
77617: LD_INT 1
77619: ARRAY
77620: IN
77621: NOT
77622: AND
77623: PUSH
77624: LD_VAR 0 3
77628: PUSH
77629: LD_EXP 72
77633: PUSH
77634: LD_VAR 0 2
77638: ARRAY
77639: PUSH
77640: LD_INT 2
77642: ARRAY
77643: IN
77644: NOT
77645: AND
77646: PUSH
77647: LD_VAR 0 3
77651: PUSH
77652: LD_EXP 81
77656: PUSH
77657: LD_VAR 0 2
77661: ARRAY
77662: IN
77663: NOT
77664: AND
77665: IFFALSE 77702
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
77667: LD_VAR 0 2
77671: PPUSH
77672: LD_EXP 69
77676: PUSH
77677: LD_VAR 0 2
77681: ARRAY
77682: PPUSH
77683: LD_VAR 0 3
77687: PPUSH
77688: LD_VAR 0 3
77692: PPUSH
77693: CALL_OW 257
77697: PPUSH
77698: CALL 76474 0 4
// end ;
77702: GO 77551
77704: POP
77705: POP
// end ;
77706: GO 77486
77708: POP
77709: POP
// end ;
77710: LD_VAR 0 1
77714: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
77715: LD_INT 0
77717: PPUSH
77718: PPUSH
77719: PPUSH
77720: PPUSH
77721: PPUSH
77722: PPUSH
// if not mc_bases [ base ] then
77723: LD_EXP 69
77727: PUSH
77728: LD_VAR 0 1
77732: ARRAY
77733: NOT
77734: IFFALSE 77738
// exit ;
77736: GO 77920
// tmp := [ ] ;
77738: LD_ADDR_VAR 0 6
77742: PUSH
77743: EMPTY
77744: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
77745: LD_ADDR_VAR 0 7
77749: PUSH
77750: LD_VAR 0 3
77754: PPUSH
77755: LD_INT 0
77757: PPUSH
77758: CALL_OW 517
77762: ST_TO_ADDR
// if not list then
77763: LD_VAR 0 7
77767: NOT
77768: IFFALSE 77772
// exit ;
77770: GO 77920
// for i = 1 to amount do
77772: LD_ADDR_VAR 0 5
77776: PUSH
77777: DOUBLE
77778: LD_INT 1
77780: DEC
77781: ST_TO_ADDR
77782: LD_VAR 0 2
77786: PUSH
77787: FOR_TO
77788: IFFALSE 77868
// begin x := rand ( 1 , list [ 1 ] ) ;
77790: LD_ADDR_VAR 0 8
77794: PUSH
77795: LD_INT 1
77797: PPUSH
77798: LD_VAR 0 7
77802: PUSH
77803: LD_INT 1
77805: ARRAY
77806: PPUSH
77807: CALL_OW 12
77811: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
77812: LD_ADDR_VAR 0 6
77816: PUSH
77817: LD_VAR 0 6
77821: PPUSH
77822: LD_VAR 0 5
77826: PPUSH
77827: LD_VAR 0 7
77831: PUSH
77832: LD_INT 1
77834: ARRAY
77835: PUSH
77836: LD_VAR 0 8
77840: ARRAY
77841: PUSH
77842: LD_VAR 0 7
77846: PUSH
77847: LD_INT 2
77849: ARRAY
77850: PUSH
77851: LD_VAR 0 8
77855: ARRAY
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PPUSH
77861: CALL_OW 1
77865: ST_TO_ADDR
// end ;
77866: GO 77787
77868: POP
77869: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
77870: LD_ADDR_EXP 82
77874: PUSH
77875: LD_EXP 82
77879: PPUSH
77880: LD_VAR 0 1
77884: PPUSH
77885: LD_VAR 0 6
77889: PPUSH
77890: CALL_OW 1
77894: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
77895: LD_ADDR_EXP 84
77899: PUSH
77900: LD_EXP 84
77904: PPUSH
77905: LD_VAR 0 1
77909: PPUSH
77910: LD_VAR 0 3
77914: PPUSH
77915: CALL_OW 1
77919: ST_TO_ADDR
// end ;
77920: LD_VAR 0 4
77924: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
77925: LD_INT 0
77927: PPUSH
// if not mc_bases [ base ] then
77928: LD_EXP 69
77932: PUSH
77933: LD_VAR 0 1
77937: ARRAY
77938: NOT
77939: IFFALSE 77943
// exit ;
77941: GO 77968
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
77943: LD_ADDR_EXP 74
77947: PUSH
77948: LD_EXP 74
77952: PPUSH
77953: LD_VAR 0 1
77957: PPUSH
77958: LD_VAR 0 2
77962: PPUSH
77963: CALL_OW 1
77967: ST_TO_ADDR
// end ;
77968: LD_VAR 0 3
77972: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
77973: LD_INT 0
77975: PPUSH
// if not mc_bases [ base ] then
77976: LD_EXP 69
77980: PUSH
77981: LD_VAR 0 1
77985: ARRAY
77986: NOT
77987: IFFALSE 77991
// exit ;
77989: GO 78028
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
77991: LD_ADDR_EXP 74
77995: PUSH
77996: LD_EXP 74
78000: PPUSH
78001: LD_VAR 0 1
78005: PPUSH
78006: LD_EXP 74
78010: PUSH
78011: LD_VAR 0 1
78015: ARRAY
78016: PUSH
78017: LD_VAR 0 2
78021: UNION
78022: PPUSH
78023: CALL_OW 1
78027: ST_TO_ADDR
// end ;
78028: LD_VAR 0 3
78032: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
78033: LD_INT 0
78035: PPUSH
// if not mc_bases [ base ] then
78036: LD_EXP 69
78040: PUSH
78041: LD_VAR 0 1
78045: ARRAY
78046: NOT
78047: IFFALSE 78051
// exit ;
78049: GO 78076
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
78051: LD_ADDR_EXP 90
78055: PUSH
78056: LD_EXP 90
78060: PPUSH
78061: LD_VAR 0 1
78065: PPUSH
78066: LD_VAR 0 2
78070: PPUSH
78071: CALL_OW 1
78075: ST_TO_ADDR
// end ;
78076: LD_VAR 0 3
78080: RET
// export function MC_InsertProduceList ( base , components ) ; begin
78081: LD_INT 0
78083: PPUSH
// if not mc_bases [ base ] then
78084: LD_EXP 69
78088: PUSH
78089: LD_VAR 0 1
78093: ARRAY
78094: NOT
78095: IFFALSE 78099
// exit ;
78097: GO 78136
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
78099: LD_ADDR_EXP 90
78103: PUSH
78104: LD_EXP 90
78108: PPUSH
78109: LD_VAR 0 1
78113: PPUSH
78114: LD_EXP 90
78118: PUSH
78119: LD_VAR 0 1
78123: ARRAY
78124: PUSH
78125: LD_VAR 0 2
78129: ADD
78130: PPUSH
78131: CALL_OW 1
78135: ST_TO_ADDR
// end ;
78136: LD_VAR 0 3
78140: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
78141: LD_INT 0
78143: PPUSH
// if not mc_bases [ base ] then
78144: LD_EXP 69
78148: PUSH
78149: LD_VAR 0 1
78153: ARRAY
78154: NOT
78155: IFFALSE 78159
// exit ;
78157: GO 78213
// mc_defender := Replace ( mc_defender , base , deflist ) ;
78159: LD_ADDR_EXP 91
78163: PUSH
78164: LD_EXP 91
78168: PPUSH
78169: LD_VAR 0 1
78173: PPUSH
78174: LD_VAR 0 2
78178: PPUSH
78179: CALL_OW 1
78183: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
78184: LD_ADDR_EXP 80
78188: PUSH
78189: LD_EXP 80
78193: PPUSH
78194: LD_VAR 0 1
78198: PPUSH
78199: LD_VAR 0 2
78203: PUSH
78204: LD_INT 0
78206: PLUS
78207: PPUSH
78208: CALL_OW 1
78212: ST_TO_ADDR
// end ;
78213: LD_VAR 0 3
78217: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
78218: LD_INT 0
78220: PPUSH
// if not mc_bases [ base ] then
78221: LD_EXP 69
78225: PUSH
78226: LD_VAR 0 1
78230: ARRAY
78231: NOT
78232: IFFALSE 78236
// exit ;
78234: GO 78261
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
78236: LD_ADDR_EXP 80
78240: PUSH
78241: LD_EXP 80
78245: PPUSH
78246: LD_VAR 0 1
78250: PPUSH
78251: LD_VAR 0 2
78255: PPUSH
78256: CALL_OW 1
78260: ST_TO_ADDR
// end ;
78261: LD_VAR 0 3
78265: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
78266: LD_INT 0
78268: PPUSH
78269: PPUSH
78270: PPUSH
78271: PPUSH
// if not mc_bases [ base ] then
78272: LD_EXP 69
78276: PUSH
78277: LD_VAR 0 1
78281: ARRAY
78282: NOT
78283: IFFALSE 78287
// exit ;
78285: GO 78352
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
78287: LD_ADDR_EXP 89
78291: PUSH
78292: LD_EXP 89
78296: PPUSH
78297: LD_VAR 0 1
78301: PUSH
78302: LD_EXP 89
78306: PUSH
78307: LD_VAR 0 1
78311: ARRAY
78312: PUSH
78313: LD_INT 1
78315: PLUS
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: PPUSH
78321: LD_VAR 0 1
78325: PUSH
78326: LD_VAR 0 2
78330: PUSH
78331: LD_VAR 0 3
78335: PUSH
78336: LD_VAR 0 4
78340: PUSH
78341: EMPTY
78342: LIST
78343: LIST
78344: LIST
78345: LIST
78346: PPUSH
78347: CALL 18588 0 3
78351: ST_TO_ADDR
// end ;
78352: LD_VAR 0 5
78356: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
78357: LD_INT 0
78359: PPUSH
// if not mc_bases [ base ] then
78360: LD_EXP 69
78364: PUSH
78365: LD_VAR 0 1
78369: ARRAY
78370: NOT
78371: IFFALSE 78375
// exit ;
78373: GO 78400
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
78375: LD_ADDR_EXP 106
78379: PUSH
78380: LD_EXP 106
78384: PPUSH
78385: LD_VAR 0 1
78389: PPUSH
78390: LD_VAR 0 2
78394: PPUSH
78395: CALL_OW 1
78399: ST_TO_ADDR
// end ;
78400: LD_VAR 0 3
78404: RET
// export function MC_GetMinesField ( base ) ; begin
78405: LD_INT 0
78407: PPUSH
// result := mc_mines [ base ] ;
78408: LD_ADDR_VAR 0 2
78412: PUSH
78413: LD_EXP 82
78417: PUSH
78418: LD_VAR 0 1
78422: ARRAY
78423: ST_TO_ADDR
// end ;
78424: LD_VAR 0 2
78428: RET
// export function MC_GetProduceList ( base ) ; begin
78429: LD_INT 0
78431: PPUSH
// result := mc_produce [ base ] ;
78432: LD_ADDR_VAR 0 2
78436: PUSH
78437: LD_EXP 90
78441: PUSH
78442: LD_VAR 0 1
78446: ARRAY
78447: ST_TO_ADDR
// end ;
78448: LD_VAR 0 2
78452: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
78453: LD_INT 0
78455: PPUSH
78456: PPUSH
// if not mc_bases then
78457: LD_EXP 69
78461: NOT
78462: IFFALSE 78466
// exit ;
78464: GO 78531
// if mc_bases [ base ] then
78466: LD_EXP 69
78470: PUSH
78471: LD_VAR 0 1
78475: ARRAY
78476: IFFALSE 78531
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78478: LD_ADDR_VAR 0 3
78482: PUSH
78483: LD_EXP 69
78487: PUSH
78488: LD_VAR 0 1
78492: ARRAY
78493: PPUSH
78494: LD_INT 30
78496: PUSH
78497: LD_VAR 0 2
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PPUSH
78506: CALL_OW 72
78510: ST_TO_ADDR
// if result then
78511: LD_VAR 0 3
78515: IFFALSE 78531
// result := result [ 1 ] ;
78517: LD_ADDR_VAR 0 3
78521: PUSH
78522: LD_VAR 0 3
78526: PUSH
78527: LD_INT 1
78529: ARRAY
78530: ST_TO_ADDR
// end ; end ;
78531: LD_VAR 0 3
78535: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
78536: LD_INT 0
78538: PPUSH
78539: PPUSH
// if not mc_bases then
78540: LD_EXP 69
78544: NOT
78545: IFFALSE 78549
// exit ;
78547: GO 78594
// if mc_bases [ base ] then
78549: LD_EXP 69
78553: PUSH
78554: LD_VAR 0 1
78558: ARRAY
78559: IFFALSE 78594
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78561: LD_ADDR_VAR 0 3
78565: PUSH
78566: LD_EXP 69
78570: PUSH
78571: LD_VAR 0 1
78575: ARRAY
78576: PPUSH
78577: LD_INT 30
78579: PUSH
78580: LD_VAR 0 2
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PPUSH
78589: CALL_OW 72
78593: ST_TO_ADDR
// end ;
78594: LD_VAR 0 3
78598: RET
// export function MC_SetTame ( base , area ) ; begin
78599: LD_INT 0
78601: PPUSH
// if not mc_bases or not base then
78602: LD_EXP 69
78606: NOT
78607: PUSH
78608: LD_VAR 0 1
78612: NOT
78613: OR
78614: IFFALSE 78618
// exit ;
78616: GO 78643
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
78618: LD_ADDR_EXP 97
78622: PUSH
78623: LD_EXP 97
78627: PPUSH
78628: LD_VAR 0 1
78632: PPUSH
78633: LD_VAR 0 2
78637: PPUSH
78638: CALL_OW 1
78642: ST_TO_ADDR
// end ;
78643: LD_VAR 0 3
78647: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
78648: LD_INT 0
78650: PPUSH
78651: PPUSH
// if not mc_bases or not base then
78652: LD_EXP 69
78656: NOT
78657: PUSH
78658: LD_VAR 0 1
78662: NOT
78663: OR
78664: IFFALSE 78668
// exit ;
78666: GO 78770
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78668: LD_ADDR_VAR 0 4
78672: PUSH
78673: LD_EXP 69
78677: PUSH
78678: LD_VAR 0 1
78682: ARRAY
78683: PPUSH
78684: LD_INT 30
78686: PUSH
78687: LD_VAR 0 2
78691: PUSH
78692: EMPTY
78693: LIST
78694: LIST
78695: PPUSH
78696: CALL_OW 72
78700: ST_TO_ADDR
// if not tmp then
78701: LD_VAR 0 4
78705: NOT
78706: IFFALSE 78710
// exit ;
78708: GO 78770
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
78710: LD_ADDR_EXP 101
78714: PUSH
78715: LD_EXP 101
78719: PPUSH
78720: LD_VAR 0 1
78724: PPUSH
78725: LD_EXP 101
78729: PUSH
78730: LD_VAR 0 1
78734: ARRAY
78735: PPUSH
78736: LD_EXP 101
78740: PUSH
78741: LD_VAR 0 1
78745: ARRAY
78746: PUSH
78747: LD_INT 1
78749: PLUS
78750: PPUSH
78751: LD_VAR 0 4
78755: PUSH
78756: LD_INT 1
78758: ARRAY
78759: PPUSH
78760: CALL_OW 2
78764: PPUSH
78765: CALL_OW 1
78769: ST_TO_ADDR
// end ;
78770: LD_VAR 0 3
78774: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
78775: LD_INT 0
78777: PPUSH
78778: PPUSH
// if not mc_bases or not base or not kinds then
78779: LD_EXP 69
78783: NOT
78784: PUSH
78785: LD_VAR 0 1
78789: NOT
78790: OR
78791: PUSH
78792: LD_VAR 0 2
78796: NOT
78797: OR
78798: IFFALSE 78802
// exit ;
78800: GO 78863
// for i in kinds do
78802: LD_ADDR_VAR 0 4
78806: PUSH
78807: LD_VAR 0 2
78811: PUSH
78812: FOR_IN
78813: IFFALSE 78861
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
78815: LD_ADDR_EXP 103
78819: PUSH
78820: LD_EXP 103
78824: PPUSH
78825: LD_VAR 0 1
78829: PUSH
78830: LD_EXP 103
78834: PUSH
78835: LD_VAR 0 1
78839: ARRAY
78840: PUSH
78841: LD_INT 1
78843: PLUS
78844: PUSH
78845: EMPTY
78846: LIST
78847: LIST
78848: PPUSH
78849: LD_VAR 0 4
78853: PPUSH
78854: CALL 18588 0 3
78858: ST_TO_ADDR
78859: GO 78812
78861: POP
78862: POP
// end ;
78863: LD_VAR 0 3
78867: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
78868: LD_INT 0
78870: PPUSH
// if not mc_bases or not base or not areas then
78871: LD_EXP 69
78875: NOT
78876: PUSH
78877: LD_VAR 0 1
78881: NOT
78882: OR
78883: PUSH
78884: LD_VAR 0 2
78888: NOT
78889: OR
78890: IFFALSE 78894
// exit ;
78892: GO 78919
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
78894: LD_ADDR_EXP 87
78898: PUSH
78899: LD_EXP 87
78903: PPUSH
78904: LD_VAR 0 1
78908: PPUSH
78909: LD_VAR 0 2
78913: PPUSH
78914: CALL_OW 1
78918: ST_TO_ADDR
// end ;
78919: LD_VAR 0 3
78923: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
78924: LD_INT 0
78926: PPUSH
// if not mc_bases or not base or not teleports_exit then
78927: LD_EXP 69
78931: NOT
78932: PUSH
78933: LD_VAR 0 1
78937: NOT
78938: OR
78939: PUSH
78940: LD_VAR 0 2
78944: NOT
78945: OR
78946: IFFALSE 78950
// exit ;
78948: GO 78975
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
78950: LD_ADDR_EXP 104
78954: PUSH
78955: LD_EXP 104
78959: PPUSH
78960: LD_VAR 0 1
78964: PPUSH
78965: LD_VAR 0 2
78969: PPUSH
78970: CALL_OW 1
78974: ST_TO_ADDR
// end ;
78975: LD_VAR 0 3
78979: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
78980: LD_INT 0
78982: PPUSH
78983: PPUSH
78984: PPUSH
// if not mc_bases or not base or not ext_list then
78985: LD_EXP 69
78989: NOT
78990: PUSH
78991: LD_VAR 0 1
78995: NOT
78996: OR
78997: PUSH
78998: LD_VAR 0 5
79002: NOT
79003: OR
79004: IFFALSE 79008
// exit ;
79006: GO 79181
// tmp := GetFacExtXYD ( x , y , d ) ;
79008: LD_ADDR_VAR 0 8
79012: PUSH
79013: LD_VAR 0 2
79017: PPUSH
79018: LD_VAR 0 3
79022: PPUSH
79023: LD_VAR 0 4
79027: PPUSH
79028: CALL 47975 0 3
79032: ST_TO_ADDR
// if not tmp then
79033: LD_VAR 0 8
79037: NOT
79038: IFFALSE 79042
// exit ;
79040: GO 79181
// for i in tmp do
79042: LD_ADDR_VAR 0 7
79046: PUSH
79047: LD_VAR 0 8
79051: PUSH
79052: FOR_IN
79053: IFFALSE 79179
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
79055: LD_ADDR_EXP 74
79059: PUSH
79060: LD_EXP 74
79064: PPUSH
79065: LD_VAR 0 1
79069: PPUSH
79070: LD_EXP 74
79074: PUSH
79075: LD_VAR 0 1
79079: ARRAY
79080: PPUSH
79081: LD_EXP 74
79085: PUSH
79086: LD_VAR 0 1
79090: ARRAY
79091: PUSH
79092: LD_INT 1
79094: PLUS
79095: PPUSH
79096: LD_VAR 0 5
79100: PUSH
79101: LD_INT 1
79103: ARRAY
79104: PUSH
79105: LD_VAR 0 7
79109: PUSH
79110: LD_INT 1
79112: ARRAY
79113: PUSH
79114: LD_VAR 0 7
79118: PUSH
79119: LD_INT 2
79121: ARRAY
79122: PUSH
79123: LD_VAR 0 7
79127: PUSH
79128: LD_INT 3
79130: ARRAY
79131: PUSH
79132: EMPTY
79133: LIST
79134: LIST
79135: LIST
79136: LIST
79137: PPUSH
79138: CALL_OW 2
79142: PPUSH
79143: CALL_OW 1
79147: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
79148: LD_ADDR_VAR 0 5
79152: PUSH
79153: LD_VAR 0 5
79157: PPUSH
79158: LD_INT 1
79160: PPUSH
79161: CALL_OW 3
79165: ST_TO_ADDR
// if not ext_list then
79166: LD_VAR 0 5
79170: NOT
79171: IFFALSE 79177
// exit ;
79173: POP
79174: POP
79175: GO 79181
// end ;
79177: GO 79052
79179: POP
79180: POP
// end ;
79181: LD_VAR 0 6
79185: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
79186: LD_INT 0
79188: PPUSH
// if not mc_bases or not base or not weapon_list then
79189: LD_EXP 69
79193: NOT
79194: PUSH
79195: LD_VAR 0 1
79199: NOT
79200: OR
79201: PUSH
79202: LD_VAR 0 2
79206: NOT
79207: OR
79208: IFFALSE 79212
// exit ;
79210: GO 79237
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
79212: LD_ADDR_EXP 108
79216: PUSH
79217: LD_EXP 108
79221: PPUSH
79222: LD_VAR 0 1
79226: PPUSH
79227: LD_VAR 0 2
79231: PPUSH
79232: CALL_OW 1
79236: ST_TO_ADDR
// end ;
79237: LD_VAR 0 3
79241: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
79242: LD_INT 0
79244: PPUSH
// if not mc_bases or not base or not tech_list then
79245: LD_EXP 69
79249: NOT
79250: PUSH
79251: LD_VAR 0 1
79255: NOT
79256: OR
79257: PUSH
79258: LD_VAR 0 2
79262: NOT
79263: OR
79264: IFFALSE 79268
// exit ;
79266: GO 79293
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
79268: LD_ADDR_EXP 96
79272: PUSH
79273: LD_EXP 96
79277: PPUSH
79278: LD_VAR 0 1
79282: PPUSH
79283: LD_VAR 0 2
79287: PPUSH
79288: CALL_OW 1
79292: ST_TO_ADDR
// end ;
79293: LD_VAR 0 3
79297: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
79298: LD_INT 0
79300: PPUSH
// if not mc_bases or not parking_area or not base then
79301: LD_EXP 69
79305: NOT
79306: PUSH
79307: LD_VAR 0 2
79311: NOT
79312: OR
79313: PUSH
79314: LD_VAR 0 1
79318: NOT
79319: OR
79320: IFFALSE 79324
// exit ;
79322: GO 79349
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
79324: LD_ADDR_EXP 93
79328: PUSH
79329: LD_EXP 93
79333: PPUSH
79334: LD_VAR 0 1
79338: PPUSH
79339: LD_VAR 0 2
79343: PPUSH
79344: CALL_OW 1
79348: ST_TO_ADDR
// end ;
79349: LD_VAR 0 3
79353: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
79354: LD_INT 0
79356: PPUSH
// if not mc_bases or not base or not scan_area then
79357: LD_EXP 69
79361: NOT
79362: PUSH
79363: LD_VAR 0 1
79367: NOT
79368: OR
79369: PUSH
79370: LD_VAR 0 2
79374: NOT
79375: OR
79376: IFFALSE 79380
// exit ;
79378: GO 79405
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
79380: LD_ADDR_EXP 94
79384: PUSH
79385: LD_EXP 94
79389: PPUSH
79390: LD_VAR 0 1
79394: PPUSH
79395: LD_VAR 0 2
79399: PPUSH
79400: CALL_OW 1
79404: ST_TO_ADDR
// end ;
79405: LD_VAR 0 3
79409: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
79410: LD_INT 0
79412: PPUSH
79413: PPUSH
// if not mc_bases or not base then
79414: LD_EXP 69
79418: NOT
79419: PUSH
79420: LD_VAR 0 1
79424: NOT
79425: OR
79426: IFFALSE 79430
// exit ;
79428: GO 79494
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
79430: LD_ADDR_VAR 0 3
79434: PUSH
79435: LD_INT 1
79437: PUSH
79438: LD_INT 2
79440: PUSH
79441: LD_INT 3
79443: PUSH
79444: LD_INT 4
79446: PUSH
79447: LD_INT 11
79449: PUSH
79450: EMPTY
79451: LIST
79452: LIST
79453: LIST
79454: LIST
79455: LIST
79456: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
79457: LD_ADDR_EXP 96
79461: PUSH
79462: LD_EXP 96
79466: PPUSH
79467: LD_VAR 0 1
79471: PPUSH
79472: LD_EXP 96
79476: PUSH
79477: LD_VAR 0 1
79481: ARRAY
79482: PUSH
79483: LD_VAR 0 3
79487: DIFF
79488: PPUSH
79489: CALL_OW 1
79493: ST_TO_ADDR
// end ;
79494: LD_VAR 0 2
79498: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
79499: LD_INT 0
79501: PPUSH
// result := mc_vehicles [ base ] ;
79502: LD_ADDR_VAR 0 3
79506: PUSH
79507: LD_EXP 88
79511: PUSH
79512: LD_VAR 0 1
79516: ARRAY
79517: ST_TO_ADDR
// if onlyCombat then
79518: LD_VAR 0 2
79522: IFFALSE 79700
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
79524: LD_ADDR_VAR 0 3
79528: PUSH
79529: LD_VAR 0 3
79533: PUSH
79534: LD_VAR 0 3
79538: PPUSH
79539: LD_INT 2
79541: PUSH
79542: LD_INT 34
79544: PUSH
79545: LD_INT 12
79547: PUSH
79548: EMPTY
79549: LIST
79550: LIST
79551: PUSH
79552: LD_INT 34
79554: PUSH
79555: LD_INT 51
79557: PUSH
79558: EMPTY
79559: LIST
79560: LIST
79561: PUSH
79562: LD_INT 34
79564: PUSH
79565: LD_EXP 49
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: LD_INT 34
79576: PUSH
79577: LD_INT 32
79579: PUSH
79580: EMPTY
79581: LIST
79582: LIST
79583: PUSH
79584: LD_INT 34
79586: PUSH
79587: LD_INT 13
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PUSH
79594: LD_INT 34
79596: PUSH
79597: LD_INT 52
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: PUSH
79604: LD_INT 34
79606: PUSH
79607: LD_EXP 54
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 34
79618: PUSH
79619: LD_INT 14
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: PUSH
79626: LD_INT 34
79628: PUSH
79629: LD_INT 53
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: PUSH
79636: LD_INT 34
79638: PUSH
79639: LD_EXP 48
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 34
79650: PUSH
79651: LD_INT 31
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 34
79660: PUSH
79661: LD_INT 48
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: PUSH
79668: LD_INT 34
79670: PUSH
79671: LD_INT 8
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: PUSH
79678: EMPTY
79679: LIST
79680: LIST
79681: LIST
79682: LIST
79683: LIST
79684: LIST
79685: LIST
79686: LIST
79687: LIST
79688: LIST
79689: LIST
79690: LIST
79691: LIST
79692: LIST
79693: PPUSH
79694: CALL_OW 72
79698: DIFF
79699: ST_TO_ADDR
// end ; end_of_file
79700: LD_VAR 0 3
79704: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
79705: LD_INT 0
79707: PPUSH
79708: PPUSH
79709: PPUSH
// if not mc_bases or not skirmish then
79710: LD_EXP 69
79714: NOT
79715: PUSH
79716: LD_EXP 67
79720: NOT
79721: OR
79722: IFFALSE 79726
// exit ;
79724: GO 79891
// for i = 1 to mc_bases do
79726: LD_ADDR_VAR 0 4
79730: PUSH
79731: DOUBLE
79732: LD_INT 1
79734: DEC
79735: ST_TO_ADDR
79736: LD_EXP 69
79740: PUSH
79741: FOR_TO
79742: IFFALSE 79889
// begin if sci in mc_bases [ i ] then
79744: LD_VAR 0 2
79748: PUSH
79749: LD_EXP 69
79753: PUSH
79754: LD_VAR 0 4
79758: ARRAY
79759: IN
79760: IFFALSE 79887
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
79762: LD_ADDR_EXP 98
79766: PUSH
79767: LD_EXP 98
79771: PPUSH
79772: LD_VAR 0 4
79776: PUSH
79777: LD_EXP 98
79781: PUSH
79782: LD_VAR 0 4
79786: ARRAY
79787: PUSH
79788: LD_INT 1
79790: PLUS
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: PPUSH
79796: LD_VAR 0 1
79800: PPUSH
79801: CALL 18588 0 3
79805: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
79806: LD_ADDR_VAR 0 5
79810: PUSH
79811: LD_EXP 69
79815: PUSH
79816: LD_VAR 0 4
79820: ARRAY
79821: PPUSH
79822: LD_INT 2
79824: PUSH
79825: LD_INT 30
79827: PUSH
79828: LD_INT 0
79830: PUSH
79831: EMPTY
79832: LIST
79833: LIST
79834: PUSH
79835: LD_INT 30
79837: PUSH
79838: LD_INT 1
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: LIST
79849: PPUSH
79850: CALL_OW 72
79854: PPUSH
79855: LD_VAR 0 1
79859: PPUSH
79860: CALL_OW 74
79864: ST_TO_ADDR
// if tmp then
79865: LD_VAR 0 5
79869: IFFALSE 79885
// ComStandNearbyBuilding ( ape , tmp ) ;
79871: LD_VAR 0 1
79875: PPUSH
79876: LD_VAR 0 5
79880: PPUSH
79881: CALL 15166 0 2
// break ;
79885: GO 79889
// end ; end ;
79887: GO 79741
79889: POP
79890: POP
// end ;
79891: LD_VAR 0 3
79895: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
79896: LD_INT 0
79898: PPUSH
79899: PPUSH
79900: PPUSH
// if not mc_bases or not skirmish then
79901: LD_EXP 69
79905: NOT
79906: PUSH
79907: LD_EXP 67
79911: NOT
79912: OR
79913: IFFALSE 79917
// exit ;
79915: GO 80006
// for i = 1 to mc_bases do
79917: LD_ADDR_VAR 0 4
79921: PUSH
79922: DOUBLE
79923: LD_INT 1
79925: DEC
79926: ST_TO_ADDR
79927: LD_EXP 69
79931: PUSH
79932: FOR_TO
79933: IFFALSE 80004
// begin if building in mc_busy_turret_list [ i ] then
79935: LD_VAR 0 1
79939: PUSH
79940: LD_EXP 79
79944: PUSH
79945: LD_VAR 0 4
79949: ARRAY
79950: IN
79951: IFFALSE 80002
// begin tmp := mc_busy_turret_list [ i ] diff building ;
79953: LD_ADDR_VAR 0 5
79957: PUSH
79958: LD_EXP 79
79962: PUSH
79963: LD_VAR 0 4
79967: ARRAY
79968: PUSH
79969: LD_VAR 0 1
79973: DIFF
79974: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
79975: LD_ADDR_EXP 79
79979: PUSH
79980: LD_EXP 79
79984: PPUSH
79985: LD_VAR 0 4
79989: PPUSH
79990: LD_VAR 0 5
79994: PPUSH
79995: CALL_OW 1
79999: ST_TO_ADDR
// break ;
80000: GO 80004
// end ; end ;
80002: GO 79932
80004: POP
80005: POP
// end ;
80006: LD_VAR 0 3
80010: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
80011: LD_INT 0
80013: PPUSH
80014: PPUSH
80015: PPUSH
// if not mc_bases or not skirmish then
80016: LD_EXP 69
80020: NOT
80021: PUSH
80022: LD_EXP 67
80026: NOT
80027: OR
80028: IFFALSE 80032
// exit ;
80030: GO 80231
// for i = 1 to mc_bases do
80032: LD_ADDR_VAR 0 5
80036: PUSH
80037: DOUBLE
80038: LD_INT 1
80040: DEC
80041: ST_TO_ADDR
80042: LD_EXP 69
80046: PUSH
80047: FOR_TO
80048: IFFALSE 80229
// if building in mc_bases [ i ] then
80050: LD_VAR 0 1
80054: PUSH
80055: LD_EXP 69
80059: PUSH
80060: LD_VAR 0 5
80064: ARRAY
80065: IN
80066: IFFALSE 80227
// begin tmp := mc_bases [ i ] diff building ;
80068: LD_ADDR_VAR 0 6
80072: PUSH
80073: LD_EXP 69
80077: PUSH
80078: LD_VAR 0 5
80082: ARRAY
80083: PUSH
80084: LD_VAR 0 1
80088: DIFF
80089: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
80090: LD_ADDR_EXP 69
80094: PUSH
80095: LD_EXP 69
80099: PPUSH
80100: LD_VAR 0 5
80104: PPUSH
80105: LD_VAR 0 6
80109: PPUSH
80110: CALL_OW 1
80114: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
80115: LD_VAR 0 1
80119: PUSH
80120: LD_EXP 77
80124: PUSH
80125: LD_VAR 0 5
80129: ARRAY
80130: IN
80131: IFFALSE 80170
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
80133: LD_ADDR_EXP 77
80137: PUSH
80138: LD_EXP 77
80142: PPUSH
80143: LD_VAR 0 5
80147: PPUSH
80148: LD_EXP 77
80152: PUSH
80153: LD_VAR 0 5
80157: ARRAY
80158: PUSH
80159: LD_VAR 0 1
80163: DIFF
80164: PPUSH
80165: CALL_OW 1
80169: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
80170: LD_VAR 0 1
80174: PUSH
80175: LD_EXP 78
80179: PUSH
80180: LD_VAR 0 5
80184: ARRAY
80185: IN
80186: IFFALSE 80225
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
80188: LD_ADDR_EXP 78
80192: PUSH
80193: LD_EXP 78
80197: PPUSH
80198: LD_VAR 0 5
80202: PPUSH
80203: LD_EXP 78
80207: PUSH
80208: LD_VAR 0 5
80212: ARRAY
80213: PUSH
80214: LD_VAR 0 1
80218: DIFF
80219: PPUSH
80220: CALL_OW 1
80224: ST_TO_ADDR
// break ;
80225: GO 80229
// end ;
80227: GO 80047
80229: POP
80230: POP
// end ;
80231: LD_VAR 0 4
80235: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
80236: LD_INT 0
80238: PPUSH
80239: PPUSH
80240: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
80241: LD_EXP 69
80245: NOT
80246: PUSH
80247: LD_EXP 67
80251: NOT
80252: OR
80253: PUSH
80254: LD_VAR 0 3
80258: PUSH
80259: LD_EXP 95
80263: IN
80264: NOT
80265: OR
80266: IFFALSE 80270
// exit ;
80268: GO 80393
// for i = 1 to mc_vehicles do
80270: LD_ADDR_VAR 0 6
80274: PUSH
80275: DOUBLE
80276: LD_INT 1
80278: DEC
80279: ST_TO_ADDR
80280: LD_EXP 88
80284: PUSH
80285: FOR_TO
80286: IFFALSE 80391
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
80288: LD_VAR 0 2
80292: PUSH
80293: LD_EXP 88
80297: PUSH
80298: LD_VAR 0 6
80302: ARRAY
80303: IN
80304: PUSH
80305: LD_VAR 0 1
80309: PUSH
80310: LD_EXP 88
80314: PUSH
80315: LD_VAR 0 6
80319: ARRAY
80320: IN
80321: OR
80322: IFFALSE 80389
// begin tmp := mc_vehicles [ i ] diff old ;
80324: LD_ADDR_VAR 0 7
80328: PUSH
80329: LD_EXP 88
80333: PUSH
80334: LD_VAR 0 6
80338: ARRAY
80339: PUSH
80340: LD_VAR 0 2
80344: DIFF
80345: ST_TO_ADDR
// tmp := tmp diff new ;
80346: LD_ADDR_VAR 0 7
80350: PUSH
80351: LD_VAR 0 7
80355: PUSH
80356: LD_VAR 0 1
80360: DIFF
80361: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
80362: LD_ADDR_EXP 88
80366: PUSH
80367: LD_EXP 88
80371: PPUSH
80372: LD_VAR 0 6
80376: PPUSH
80377: LD_VAR 0 7
80381: PPUSH
80382: CALL_OW 1
80386: ST_TO_ADDR
// break ;
80387: GO 80391
// end ;
80389: GO 80285
80391: POP
80392: POP
// end ;
80393: LD_VAR 0 5
80397: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
80398: LD_INT 0
80400: PPUSH
80401: PPUSH
80402: PPUSH
80403: PPUSH
// if not mc_bases or not skirmish then
80404: LD_EXP 69
80408: NOT
80409: PUSH
80410: LD_EXP 67
80414: NOT
80415: OR
80416: IFFALSE 80420
// exit ;
80418: GO 80812
// side := GetSide ( vehicle ) ;
80420: LD_ADDR_VAR 0 5
80424: PUSH
80425: LD_VAR 0 1
80429: PPUSH
80430: CALL_OW 255
80434: ST_TO_ADDR
// for i = 1 to mc_bases do
80435: LD_ADDR_VAR 0 4
80439: PUSH
80440: DOUBLE
80441: LD_INT 1
80443: DEC
80444: ST_TO_ADDR
80445: LD_EXP 69
80449: PUSH
80450: FOR_TO
80451: IFFALSE 80810
// begin if factory in mc_bases [ i ] then
80453: LD_VAR 0 2
80457: PUSH
80458: LD_EXP 69
80462: PUSH
80463: LD_VAR 0 4
80467: ARRAY
80468: IN
80469: IFFALSE 80808
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
80471: LD_EXP 91
80475: PUSH
80476: LD_VAR 0 4
80480: ARRAY
80481: PUSH
80482: LD_EXP 80
80486: PUSH
80487: LD_VAR 0 4
80491: ARRAY
80492: LESS
80493: PUSH
80494: LD_VAR 0 1
80498: PPUSH
80499: CALL_OW 264
80503: PUSH
80504: LD_INT 31
80506: PUSH
80507: LD_INT 32
80509: PUSH
80510: LD_INT 51
80512: PUSH
80513: LD_EXP 49
80517: PUSH
80518: LD_INT 12
80520: PUSH
80521: LD_INT 30
80523: PUSH
80524: LD_EXP 48
80528: PUSH
80529: LD_INT 11
80531: PUSH
80532: LD_INT 53
80534: PUSH
80535: LD_INT 14
80537: PUSH
80538: LD_EXP 52
80542: PUSH
80543: LD_INT 29
80545: PUSH
80546: LD_EXP 50
80550: PUSH
80551: LD_INT 13
80553: PUSH
80554: LD_INT 52
80556: PUSH
80557: LD_EXP 54
80561: PUSH
80562: LD_INT 48
80564: PUSH
80565: LD_INT 8
80567: PUSH
80568: EMPTY
80569: LIST
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: LIST
80576: LIST
80577: LIST
80578: LIST
80579: LIST
80580: LIST
80581: LIST
80582: LIST
80583: LIST
80584: LIST
80585: LIST
80586: LIST
80587: IN
80588: NOT
80589: AND
80590: IFFALSE 80638
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
80592: LD_ADDR_EXP 91
80596: PUSH
80597: LD_EXP 91
80601: PPUSH
80602: LD_VAR 0 4
80606: PUSH
80607: LD_EXP 91
80611: PUSH
80612: LD_VAR 0 4
80616: ARRAY
80617: PUSH
80618: LD_INT 1
80620: PLUS
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: PPUSH
80626: LD_VAR 0 1
80630: PPUSH
80631: CALL 18588 0 3
80635: ST_TO_ADDR
80636: GO 80682
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
80638: LD_ADDR_EXP 88
80642: PUSH
80643: LD_EXP 88
80647: PPUSH
80648: LD_VAR 0 4
80652: PUSH
80653: LD_EXP 88
80657: PUSH
80658: LD_VAR 0 4
80662: ARRAY
80663: PUSH
80664: LD_INT 1
80666: PLUS
80667: PUSH
80668: EMPTY
80669: LIST
80670: LIST
80671: PPUSH
80672: LD_VAR 0 1
80676: PPUSH
80677: CALL 18588 0 3
80681: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
80682: LD_VAR 0 1
80686: PPUSH
80687: CALL_OW 263
80691: PUSH
80692: LD_INT 2
80694: EQUAL
80695: IFFALSE 80724
// begin repeat wait ( 0 0$3 ) ;
80697: LD_INT 105
80699: PPUSH
80700: CALL_OW 67
// Connect ( vehicle ) ;
80704: LD_VAR 0 1
80708: PPUSH
80709: CALL 21559 0 1
// until IsControledBy ( vehicle ) ;
80713: LD_VAR 0 1
80717: PPUSH
80718: CALL_OW 312
80722: IFFALSE 80697
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
80724: LD_VAR 0 1
80728: PPUSH
80729: LD_EXP 93
80733: PUSH
80734: LD_VAR 0 4
80738: ARRAY
80739: PPUSH
80740: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
80744: LD_VAR 0 1
80748: PPUSH
80749: CALL_OW 263
80753: PUSH
80754: LD_INT 1
80756: NONEQUAL
80757: IFFALSE 80761
// break ;
80759: GO 80810
// repeat wait ( 0 0$1 ) ;
80761: LD_INT 35
80763: PPUSH
80764: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
80768: LD_VAR 0 1
80772: PPUSH
80773: LD_EXP 93
80777: PUSH
80778: LD_VAR 0 4
80782: ARRAY
80783: PPUSH
80784: CALL_OW 308
80788: IFFALSE 80761
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
80790: LD_VAR 0 1
80794: PPUSH
80795: CALL_OW 311
80799: PPUSH
80800: CALL_OW 121
// exit ;
80804: POP
80805: POP
80806: GO 80812
// end ; end ;
80808: GO 80450
80810: POP
80811: POP
// end ;
80812: LD_VAR 0 3
80816: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
80817: LD_INT 0
80819: PPUSH
80820: PPUSH
80821: PPUSH
80822: PPUSH
// if not mc_bases or not skirmish then
80823: LD_EXP 69
80827: NOT
80828: PUSH
80829: LD_EXP 67
80833: NOT
80834: OR
80835: IFFALSE 80839
// exit ;
80837: GO 81192
// repeat wait ( 0 0$1 ) ;
80839: LD_INT 35
80841: PPUSH
80842: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
80846: LD_VAR 0 2
80850: PPUSH
80851: LD_VAR 0 3
80855: PPUSH
80856: CALL_OW 284
80860: IFFALSE 80839
// if GetResourceTypeXY ( x , y ) = mat_artefact then
80862: LD_VAR 0 2
80866: PPUSH
80867: LD_VAR 0 3
80871: PPUSH
80872: CALL_OW 283
80876: PUSH
80877: LD_INT 4
80879: EQUAL
80880: IFFALSE 80884
// exit ;
80882: GO 81192
// for i = 1 to mc_bases do
80884: LD_ADDR_VAR 0 7
80888: PUSH
80889: DOUBLE
80890: LD_INT 1
80892: DEC
80893: ST_TO_ADDR
80894: LD_EXP 69
80898: PUSH
80899: FOR_TO
80900: IFFALSE 81190
// begin if mc_crates_area [ i ] then
80902: LD_EXP 87
80906: PUSH
80907: LD_VAR 0 7
80911: ARRAY
80912: IFFALSE 81023
// for j in mc_crates_area [ i ] do
80914: LD_ADDR_VAR 0 8
80918: PUSH
80919: LD_EXP 87
80923: PUSH
80924: LD_VAR 0 7
80928: ARRAY
80929: PUSH
80930: FOR_IN
80931: IFFALSE 81021
// if InArea ( x , y , j ) then
80933: LD_VAR 0 2
80937: PPUSH
80938: LD_VAR 0 3
80942: PPUSH
80943: LD_VAR 0 8
80947: PPUSH
80948: CALL_OW 309
80952: IFFALSE 81019
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80954: LD_ADDR_EXP 85
80958: PUSH
80959: LD_EXP 85
80963: PPUSH
80964: LD_VAR 0 7
80968: PUSH
80969: LD_EXP 85
80973: PUSH
80974: LD_VAR 0 7
80978: ARRAY
80979: PUSH
80980: LD_INT 1
80982: PLUS
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PPUSH
80988: LD_VAR 0 4
80992: PUSH
80993: LD_VAR 0 2
80997: PUSH
80998: LD_VAR 0 3
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: LIST
81007: PPUSH
81008: CALL 18588 0 3
81012: ST_TO_ADDR
// exit ;
81013: POP
81014: POP
81015: POP
81016: POP
81017: GO 81192
// end ;
81019: GO 80930
81021: POP
81022: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81023: LD_ADDR_VAR 0 9
81027: PUSH
81028: LD_EXP 69
81032: PUSH
81033: LD_VAR 0 7
81037: ARRAY
81038: PPUSH
81039: LD_INT 2
81041: PUSH
81042: LD_INT 30
81044: PUSH
81045: LD_INT 0
81047: PUSH
81048: EMPTY
81049: LIST
81050: LIST
81051: PUSH
81052: LD_INT 30
81054: PUSH
81055: LD_INT 1
81057: PUSH
81058: EMPTY
81059: LIST
81060: LIST
81061: PUSH
81062: EMPTY
81063: LIST
81064: LIST
81065: LIST
81066: PPUSH
81067: CALL_OW 72
81071: ST_TO_ADDR
// if not depot then
81072: LD_VAR 0 9
81076: NOT
81077: IFFALSE 81081
// continue ;
81079: GO 80899
// for j in depot do
81081: LD_ADDR_VAR 0 8
81085: PUSH
81086: LD_VAR 0 9
81090: PUSH
81091: FOR_IN
81092: IFFALSE 81186
// if GetDistUnitXY ( j , x , y ) < 30 then
81094: LD_VAR 0 8
81098: PPUSH
81099: LD_VAR 0 2
81103: PPUSH
81104: LD_VAR 0 3
81108: PPUSH
81109: CALL_OW 297
81113: PUSH
81114: LD_INT 30
81116: LESS
81117: IFFALSE 81184
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81119: LD_ADDR_EXP 85
81123: PUSH
81124: LD_EXP 85
81128: PPUSH
81129: LD_VAR 0 7
81133: PUSH
81134: LD_EXP 85
81138: PUSH
81139: LD_VAR 0 7
81143: ARRAY
81144: PUSH
81145: LD_INT 1
81147: PLUS
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PPUSH
81153: LD_VAR 0 4
81157: PUSH
81158: LD_VAR 0 2
81162: PUSH
81163: LD_VAR 0 3
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: LIST
81172: PPUSH
81173: CALL 18588 0 3
81177: ST_TO_ADDR
// exit ;
81178: POP
81179: POP
81180: POP
81181: POP
81182: GO 81192
// end ;
81184: GO 81091
81186: POP
81187: POP
// end ;
81188: GO 80899
81190: POP
81191: POP
// end ;
81192: LD_VAR 0 6
81196: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
81197: LD_INT 0
81199: PPUSH
81200: PPUSH
81201: PPUSH
81202: PPUSH
// if not mc_bases or not skirmish then
81203: LD_EXP 69
81207: NOT
81208: PUSH
81209: LD_EXP 67
81213: NOT
81214: OR
81215: IFFALSE 81219
// exit ;
81217: GO 81496
// side := GetSide ( lab ) ;
81219: LD_ADDR_VAR 0 4
81223: PUSH
81224: LD_VAR 0 2
81228: PPUSH
81229: CALL_OW 255
81233: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
81234: LD_VAR 0 4
81238: PUSH
81239: LD_EXP 95
81243: IN
81244: NOT
81245: PUSH
81246: LD_EXP 96
81250: NOT
81251: OR
81252: PUSH
81253: LD_EXP 69
81257: NOT
81258: OR
81259: IFFALSE 81263
// exit ;
81261: GO 81496
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
81263: LD_ADDR_EXP 96
81267: PUSH
81268: LD_EXP 96
81272: PPUSH
81273: LD_VAR 0 4
81277: PPUSH
81278: LD_EXP 96
81282: PUSH
81283: LD_VAR 0 4
81287: ARRAY
81288: PUSH
81289: LD_VAR 0 1
81293: DIFF
81294: PPUSH
81295: CALL_OW 1
81299: ST_TO_ADDR
// for i = 1 to mc_bases do
81300: LD_ADDR_VAR 0 5
81304: PUSH
81305: DOUBLE
81306: LD_INT 1
81308: DEC
81309: ST_TO_ADDR
81310: LD_EXP 69
81314: PUSH
81315: FOR_TO
81316: IFFALSE 81494
// begin if lab in mc_bases [ i ] then
81318: LD_VAR 0 2
81322: PUSH
81323: LD_EXP 69
81327: PUSH
81328: LD_VAR 0 5
81332: ARRAY
81333: IN
81334: IFFALSE 81492
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
81336: LD_VAR 0 1
81340: PUSH
81341: LD_INT 11
81343: PUSH
81344: LD_INT 4
81346: PUSH
81347: LD_INT 3
81349: PUSH
81350: LD_INT 2
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: LIST
81357: LIST
81358: IN
81359: PUSH
81360: LD_EXP 99
81364: PUSH
81365: LD_VAR 0 5
81369: ARRAY
81370: AND
81371: IFFALSE 81492
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
81373: LD_ADDR_VAR 0 6
81377: PUSH
81378: LD_EXP 99
81382: PUSH
81383: LD_VAR 0 5
81387: ARRAY
81388: PUSH
81389: LD_INT 1
81391: ARRAY
81392: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81393: LD_ADDR_EXP 99
81397: PUSH
81398: LD_EXP 99
81402: PPUSH
81403: LD_VAR 0 5
81407: PPUSH
81408: EMPTY
81409: PPUSH
81410: CALL_OW 1
81414: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
81415: LD_VAR 0 6
81419: PPUSH
81420: LD_INT 0
81422: PPUSH
81423: CALL_OW 109
// ComExitBuilding ( tmp ) ;
81427: LD_VAR 0 6
81431: PPUSH
81432: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
81436: LD_ADDR_EXP 98
81440: PUSH
81441: LD_EXP 98
81445: PPUSH
81446: LD_VAR 0 5
81450: PPUSH
81451: LD_EXP 98
81455: PUSH
81456: LD_VAR 0 5
81460: ARRAY
81461: PPUSH
81462: LD_INT 1
81464: PPUSH
81465: LD_VAR 0 6
81469: PPUSH
81470: CALL_OW 2
81474: PPUSH
81475: CALL_OW 1
81479: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
81480: LD_VAR 0 5
81484: PPUSH
81485: LD_INT 112
81487: PPUSH
81488: CALL 58015 0 2
// end ; end ; end ;
81492: GO 81315
81494: POP
81495: POP
// end ;
81496: LD_VAR 0 3
81500: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
81501: LD_INT 0
81503: PPUSH
81504: PPUSH
81505: PPUSH
81506: PPUSH
81507: PPUSH
81508: PPUSH
81509: PPUSH
81510: PPUSH
// if not mc_bases or not skirmish then
81511: LD_EXP 69
81515: NOT
81516: PUSH
81517: LD_EXP 67
81521: NOT
81522: OR
81523: IFFALSE 81527
// exit ;
81525: GO 82898
// for i = 1 to mc_bases do
81527: LD_ADDR_VAR 0 3
81531: PUSH
81532: DOUBLE
81533: LD_INT 1
81535: DEC
81536: ST_TO_ADDR
81537: LD_EXP 69
81541: PUSH
81542: FOR_TO
81543: IFFALSE 82896
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
81545: LD_VAR 0 1
81549: PUSH
81550: LD_EXP 69
81554: PUSH
81555: LD_VAR 0 3
81559: ARRAY
81560: IN
81561: PUSH
81562: LD_VAR 0 1
81566: PUSH
81567: LD_EXP 76
81571: PUSH
81572: LD_VAR 0 3
81576: ARRAY
81577: IN
81578: OR
81579: PUSH
81580: LD_VAR 0 1
81584: PUSH
81585: LD_EXP 91
81589: PUSH
81590: LD_VAR 0 3
81594: ARRAY
81595: IN
81596: OR
81597: PUSH
81598: LD_VAR 0 1
81602: PUSH
81603: LD_EXP 88
81607: PUSH
81608: LD_VAR 0 3
81612: ARRAY
81613: IN
81614: OR
81615: PUSH
81616: LD_VAR 0 1
81620: PUSH
81621: LD_EXP 98
81625: PUSH
81626: LD_VAR 0 3
81630: ARRAY
81631: IN
81632: OR
81633: PUSH
81634: LD_VAR 0 1
81638: PUSH
81639: LD_EXP 99
81643: PUSH
81644: LD_VAR 0 3
81648: ARRAY
81649: IN
81650: OR
81651: IFFALSE 82894
// begin if un in mc_ape [ i ] then
81653: LD_VAR 0 1
81657: PUSH
81658: LD_EXP 98
81662: PUSH
81663: LD_VAR 0 3
81667: ARRAY
81668: IN
81669: IFFALSE 81708
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
81671: LD_ADDR_EXP 98
81675: PUSH
81676: LD_EXP 98
81680: PPUSH
81681: LD_VAR 0 3
81685: PPUSH
81686: LD_EXP 98
81690: PUSH
81691: LD_VAR 0 3
81695: ARRAY
81696: PUSH
81697: LD_VAR 0 1
81701: DIFF
81702: PPUSH
81703: CALL_OW 1
81707: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
81708: LD_VAR 0 1
81712: PUSH
81713: LD_EXP 99
81717: PUSH
81718: LD_VAR 0 3
81722: ARRAY
81723: IN
81724: IFFALSE 81748
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81726: LD_ADDR_EXP 99
81730: PUSH
81731: LD_EXP 99
81735: PPUSH
81736: LD_VAR 0 3
81740: PPUSH
81741: EMPTY
81742: PPUSH
81743: CALL_OW 1
81747: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
81748: LD_VAR 0 1
81752: PPUSH
81753: CALL_OW 247
81757: PUSH
81758: LD_INT 2
81760: EQUAL
81761: PUSH
81762: LD_VAR 0 1
81766: PPUSH
81767: CALL_OW 110
81771: PUSH
81772: LD_INT 20
81774: EQUAL
81775: PUSH
81776: LD_VAR 0 1
81780: PUSH
81781: LD_EXP 91
81785: PUSH
81786: LD_VAR 0 3
81790: ARRAY
81791: IN
81792: OR
81793: PUSH
81794: LD_VAR 0 1
81798: PPUSH
81799: CALL_OW 264
81803: PUSH
81804: LD_INT 12
81806: PUSH
81807: LD_INT 51
81809: PUSH
81810: LD_EXP 49
81814: PUSH
81815: LD_INT 32
81817: PUSH
81818: LD_INT 13
81820: PUSH
81821: LD_INT 52
81823: PUSH
81824: LD_INT 31
81826: PUSH
81827: EMPTY
81828: LIST
81829: LIST
81830: LIST
81831: LIST
81832: LIST
81833: LIST
81834: LIST
81835: IN
81836: OR
81837: AND
81838: IFFALSE 82146
// begin if un in mc_defender [ i ] then
81840: LD_VAR 0 1
81844: PUSH
81845: LD_EXP 91
81849: PUSH
81850: LD_VAR 0 3
81854: ARRAY
81855: IN
81856: IFFALSE 81895
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81858: LD_ADDR_EXP 91
81862: PUSH
81863: LD_EXP 91
81867: PPUSH
81868: LD_VAR 0 3
81872: PPUSH
81873: LD_EXP 91
81877: PUSH
81878: LD_VAR 0 3
81882: ARRAY
81883: PUSH
81884: LD_VAR 0 1
81888: DIFF
81889: PPUSH
81890: CALL_OW 1
81894: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
81895: LD_ADDR_VAR 0 8
81899: PUSH
81900: LD_VAR 0 3
81904: PPUSH
81905: LD_INT 3
81907: PPUSH
81908: CALL 78536 0 2
81912: ST_TO_ADDR
// if fac then
81913: LD_VAR 0 8
81917: IFFALSE 82146
// begin for j in fac do
81919: LD_ADDR_VAR 0 4
81923: PUSH
81924: LD_VAR 0 8
81928: PUSH
81929: FOR_IN
81930: IFFALSE 82144
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
81932: LD_ADDR_VAR 0 9
81936: PUSH
81937: LD_VAR 0 8
81941: PPUSH
81942: LD_VAR 0 1
81946: PPUSH
81947: CALL_OW 265
81951: PPUSH
81952: LD_VAR 0 1
81956: PPUSH
81957: CALL_OW 262
81961: PPUSH
81962: LD_VAR 0 1
81966: PPUSH
81967: CALL_OW 263
81971: PPUSH
81972: LD_VAR 0 1
81976: PPUSH
81977: CALL_OW 264
81981: PPUSH
81982: CALL 16084 0 5
81986: ST_TO_ADDR
// if components then
81987: LD_VAR 0 9
81991: IFFALSE 82142
// begin if GetWeapon ( un ) = ar_control_tower then
81993: LD_VAR 0 1
81997: PPUSH
81998: CALL_OW 264
82002: PUSH
82003: LD_INT 31
82005: EQUAL
82006: IFFALSE 82123
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
82008: LD_VAR 0 1
82012: PPUSH
82013: CALL_OW 311
82017: PPUSH
82018: LD_INT 0
82020: PPUSH
82021: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
82025: LD_ADDR_EXP 109
82029: PUSH
82030: LD_EXP 109
82034: PPUSH
82035: LD_VAR 0 3
82039: PPUSH
82040: LD_EXP 109
82044: PUSH
82045: LD_VAR 0 3
82049: ARRAY
82050: PUSH
82051: LD_VAR 0 1
82055: PPUSH
82056: CALL_OW 311
82060: DIFF
82061: PPUSH
82062: CALL_OW 1
82066: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
82067: LD_ADDR_VAR 0 7
82071: PUSH
82072: LD_EXP 90
82076: PUSH
82077: LD_VAR 0 3
82081: ARRAY
82082: PPUSH
82083: LD_INT 1
82085: PPUSH
82086: LD_VAR 0 9
82090: PPUSH
82091: CALL_OW 2
82095: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
82096: LD_ADDR_EXP 90
82100: PUSH
82101: LD_EXP 90
82105: PPUSH
82106: LD_VAR 0 3
82110: PPUSH
82111: LD_VAR 0 7
82115: PPUSH
82116: CALL_OW 1
82120: ST_TO_ADDR
// end else
82121: GO 82140
// MC_InsertProduceList ( i , [ components ] ) ;
82123: LD_VAR 0 3
82127: PPUSH
82128: LD_VAR 0 9
82132: PUSH
82133: EMPTY
82134: LIST
82135: PPUSH
82136: CALL 78081 0 2
// break ;
82140: GO 82144
// end ; end ;
82142: GO 81929
82144: POP
82145: POP
// end ; end ; if GetType ( un ) = unit_building then
82146: LD_VAR 0 1
82150: PPUSH
82151: CALL_OW 247
82155: PUSH
82156: LD_INT 3
82158: EQUAL
82159: IFFALSE 82562
// begin btype := GetBType ( un ) ;
82161: LD_ADDR_VAR 0 5
82165: PUSH
82166: LD_VAR 0 1
82170: PPUSH
82171: CALL_OW 266
82175: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
82176: LD_VAR 0 5
82180: PUSH
82181: LD_INT 29
82183: PUSH
82184: LD_INT 30
82186: PUSH
82187: EMPTY
82188: LIST
82189: LIST
82190: IN
82191: IFFALSE 82264
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
82193: LD_VAR 0 1
82197: PPUSH
82198: CALL_OW 250
82202: PPUSH
82203: LD_VAR 0 1
82207: PPUSH
82208: CALL_OW 251
82212: PPUSH
82213: LD_VAR 0 1
82217: PPUSH
82218: CALL_OW 255
82222: PPUSH
82223: CALL_OW 440
82227: NOT
82228: IFFALSE 82264
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
82230: LD_VAR 0 1
82234: PPUSH
82235: CALL_OW 250
82239: PPUSH
82240: LD_VAR 0 1
82244: PPUSH
82245: CALL_OW 251
82249: PPUSH
82250: LD_VAR 0 1
82254: PPUSH
82255: CALL_OW 255
82259: PPUSH
82260: CALL_OW 441
// end ; if btype = b_warehouse then
82264: LD_VAR 0 5
82268: PUSH
82269: LD_INT 1
82271: EQUAL
82272: IFFALSE 82290
// begin btype := b_depot ;
82274: LD_ADDR_VAR 0 5
82278: PUSH
82279: LD_INT 0
82281: ST_TO_ADDR
// pos := 1 ;
82282: LD_ADDR_VAR 0 6
82286: PUSH
82287: LD_INT 1
82289: ST_TO_ADDR
// end ; if btype = b_factory then
82290: LD_VAR 0 5
82294: PUSH
82295: LD_INT 3
82297: EQUAL
82298: IFFALSE 82316
// begin btype := b_workshop ;
82300: LD_ADDR_VAR 0 5
82304: PUSH
82305: LD_INT 2
82307: ST_TO_ADDR
// pos := 1 ;
82308: LD_ADDR_VAR 0 6
82312: PUSH
82313: LD_INT 1
82315: ST_TO_ADDR
// end ; if btype = b_barracks then
82316: LD_VAR 0 5
82320: PUSH
82321: LD_INT 5
82323: EQUAL
82324: IFFALSE 82334
// btype := b_armoury ;
82326: LD_ADDR_VAR 0 5
82330: PUSH
82331: LD_INT 4
82333: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
82334: LD_VAR 0 5
82338: PUSH
82339: LD_INT 7
82341: PUSH
82342: LD_INT 8
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: IN
82349: IFFALSE 82359
// btype := b_lab ;
82351: LD_ADDR_VAR 0 5
82355: PUSH
82356: LD_INT 6
82358: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
82359: LD_ADDR_EXP 74
82363: PUSH
82364: LD_EXP 74
82368: PPUSH
82369: LD_VAR 0 3
82373: PUSH
82374: LD_EXP 74
82378: PUSH
82379: LD_VAR 0 3
82383: ARRAY
82384: PUSH
82385: LD_INT 1
82387: PLUS
82388: PUSH
82389: EMPTY
82390: LIST
82391: LIST
82392: PPUSH
82393: LD_VAR 0 5
82397: PUSH
82398: LD_VAR 0 1
82402: PPUSH
82403: CALL_OW 250
82407: PUSH
82408: LD_VAR 0 1
82412: PPUSH
82413: CALL_OW 251
82417: PUSH
82418: LD_VAR 0 1
82422: PPUSH
82423: CALL_OW 254
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: LIST
82432: LIST
82433: PPUSH
82434: CALL 18588 0 3
82438: ST_TO_ADDR
// if pos = 1 then
82439: LD_VAR 0 6
82443: PUSH
82444: LD_INT 1
82446: EQUAL
82447: IFFALSE 82562
// begin tmp := mc_build_list [ i ] ;
82449: LD_ADDR_VAR 0 7
82453: PUSH
82454: LD_EXP 74
82458: PUSH
82459: LD_VAR 0 3
82463: ARRAY
82464: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82465: LD_VAR 0 7
82469: PPUSH
82470: LD_INT 2
82472: PUSH
82473: LD_INT 30
82475: PUSH
82476: LD_INT 0
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: PUSH
82483: LD_INT 30
82485: PUSH
82486: LD_INT 1
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: LIST
82497: PPUSH
82498: CALL_OW 72
82502: IFFALSE 82512
// pos := 2 ;
82504: LD_ADDR_VAR 0 6
82508: PUSH
82509: LD_INT 2
82511: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
82512: LD_ADDR_VAR 0 7
82516: PUSH
82517: LD_VAR 0 7
82521: PPUSH
82522: LD_VAR 0 6
82526: PPUSH
82527: LD_VAR 0 7
82531: PPUSH
82532: CALL 18914 0 3
82536: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
82537: LD_ADDR_EXP 74
82541: PUSH
82542: LD_EXP 74
82546: PPUSH
82547: LD_VAR 0 3
82551: PPUSH
82552: LD_VAR 0 7
82556: PPUSH
82557: CALL_OW 1
82561: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
82562: LD_VAR 0 1
82566: PUSH
82567: LD_EXP 69
82571: PUSH
82572: LD_VAR 0 3
82576: ARRAY
82577: IN
82578: IFFALSE 82617
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
82580: LD_ADDR_EXP 69
82584: PUSH
82585: LD_EXP 69
82589: PPUSH
82590: LD_VAR 0 3
82594: PPUSH
82595: LD_EXP 69
82599: PUSH
82600: LD_VAR 0 3
82604: ARRAY
82605: PUSH
82606: LD_VAR 0 1
82610: DIFF
82611: PPUSH
82612: CALL_OW 1
82616: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
82617: LD_VAR 0 1
82621: PUSH
82622: LD_EXP 76
82626: PUSH
82627: LD_VAR 0 3
82631: ARRAY
82632: IN
82633: IFFALSE 82672
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
82635: LD_ADDR_EXP 76
82639: PUSH
82640: LD_EXP 76
82644: PPUSH
82645: LD_VAR 0 3
82649: PPUSH
82650: LD_EXP 76
82654: PUSH
82655: LD_VAR 0 3
82659: ARRAY
82660: PUSH
82661: LD_VAR 0 1
82665: DIFF
82666: PPUSH
82667: CALL_OW 1
82671: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
82672: LD_VAR 0 1
82676: PUSH
82677: LD_EXP 88
82681: PUSH
82682: LD_VAR 0 3
82686: ARRAY
82687: IN
82688: IFFALSE 82727
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
82690: LD_ADDR_EXP 88
82694: PUSH
82695: LD_EXP 88
82699: PPUSH
82700: LD_VAR 0 3
82704: PPUSH
82705: LD_EXP 88
82709: PUSH
82710: LD_VAR 0 3
82714: ARRAY
82715: PUSH
82716: LD_VAR 0 1
82720: DIFF
82721: PPUSH
82722: CALL_OW 1
82726: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
82727: LD_VAR 0 1
82731: PUSH
82732: LD_EXP 91
82736: PUSH
82737: LD_VAR 0 3
82741: ARRAY
82742: IN
82743: IFFALSE 82782
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82745: LD_ADDR_EXP 91
82749: PUSH
82750: LD_EXP 91
82754: PPUSH
82755: LD_VAR 0 3
82759: PPUSH
82760: LD_EXP 91
82764: PUSH
82765: LD_VAR 0 3
82769: ARRAY
82770: PUSH
82771: LD_VAR 0 1
82775: DIFF
82776: PPUSH
82777: CALL_OW 1
82781: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
82782: LD_VAR 0 1
82786: PUSH
82787: LD_EXP 78
82791: PUSH
82792: LD_VAR 0 3
82796: ARRAY
82797: IN
82798: IFFALSE 82837
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
82800: LD_ADDR_EXP 78
82804: PUSH
82805: LD_EXP 78
82809: PPUSH
82810: LD_VAR 0 3
82814: PPUSH
82815: LD_EXP 78
82819: PUSH
82820: LD_VAR 0 3
82824: ARRAY
82825: PUSH
82826: LD_VAR 0 1
82830: DIFF
82831: PPUSH
82832: CALL_OW 1
82836: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
82837: LD_VAR 0 1
82841: PUSH
82842: LD_EXP 77
82846: PUSH
82847: LD_VAR 0 3
82851: ARRAY
82852: IN
82853: IFFALSE 82892
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
82855: LD_ADDR_EXP 77
82859: PUSH
82860: LD_EXP 77
82864: PPUSH
82865: LD_VAR 0 3
82869: PPUSH
82870: LD_EXP 77
82874: PUSH
82875: LD_VAR 0 3
82879: ARRAY
82880: PUSH
82881: LD_VAR 0 1
82885: DIFF
82886: PPUSH
82887: CALL_OW 1
82891: ST_TO_ADDR
// end ; break ;
82892: GO 82896
// end ;
82894: GO 81542
82896: POP
82897: POP
// end ;
82898: LD_VAR 0 2
82902: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
82903: LD_INT 0
82905: PPUSH
82906: PPUSH
82907: PPUSH
// if not mc_bases or not skirmish then
82908: LD_EXP 69
82912: NOT
82913: PUSH
82914: LD_EXP 67
82918: NOT
82919: OR
82920: IFFALSE 82924
// exit ;
82922: GO 83139
// for i = 1 to mc_bases do
82924: LD_ADDR_VAR 0 3
82928: PUSH
82929: DOUBLE
82930: LD_INT 1
82932: DEC
82933: ST_TO_ADDR
82934: LD_EXP 69
82938: PUSH
82939: FOR_TO
82940: IFFALSE 83137
// begin if building in mc_construct_list [ i ] then
82942: LD_VAR 0 1
82946: PUSH
82947: LD_EXP 76
82951: PUSH
82952: LD_VAR 0 3
82956: ARRAY
82957: IN
82958: IFFALSE 83135
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82960: LD_ADDR_EXP 76
82964: PUSH
82965: LD_EXP 76
82969: PPUSH
82970: LD_VAR 0 3
82974: PPUSH
82975: LD_EXP 76
82979: PUSH
82980: LD_VAR 0 3
82984: ARRAY
82985: PUSH
82986: LD_VAR 0 1
82990: DIFF
82991: PPUSH
82992: CALL_OW 1
82996: ST_TO_ADDR
// if building in mc_lab [ i ] then
82997: LD_VAR 0 1
83001: PUSH
83002: LD_EXP 102
83006: PUSH
83007: LD_VAR 0 3
83011: ARRAY
83012: IN
83013: IFFALSE 83068
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
83015: LD_ADDR_EXP 103
83019: PUSH
83020: LD_EXP 103
83024: PPUSH
83025: LD_VAR 0 3
83029: PPUSH
83030: LD_EXP 103
83034: PUSH
83035: LD_VAR 0 3
83039: ARRAY
83040: PPUSH
83041: LD_INT 1
83043: PPUSH
83044: LD_EXP 103
83048: PUSH
83049: LD_VAR 0 3
83053: ARRAY
83054: PPUSH
83055: LD_INT 0
83057: PPUSH
83058: CALL 18006 0 4
83062: PPUSH
83063: CALL_OW 1
83067: ST_TO_ADDR
// if not building in mc_bases [ i ] then
83068: LD_VAR 0 1
83072: PUSH
83073: LD_EXP 69
83077: PUSH
83078: LD_VAR 0 3
83082: ARRAY
83083: IN
83084: NOT
83085: IFFALSE 83131
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83087: LD_ADDR_EXP 69
83091: PUSH
83092: LD_EXP 69
83096: PPUSH
83097: LD_VAR 0 3
83101: PUSH
83102: LD_EXP 69
83106: PUSH
83107: LD_VAR 0 3
83111: ARRAY
83112: PUSH
83113: LD_INT 1
83115: PLUS
83116: PUSH
83117: EMPTY
83118: LIST
83119: LIST
83120: PPUSH
83121: LD_VAR 0 1
83125: PPUSH
83126: CALL 18588 0 3
83130: ST_TO_ADDR
// exit ;
83131: POP
83132: POP
83133: GO 83139
// end ; end ;
83135: GO 82939
83137: POP
83138: POP
// end ;
83139: LD_VAR 0 2
83143: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
83144: LD_INT 0
83146: PPUSH
83147: PPUSH
83148: PPUSH
83149: PPUSH
83150: PPUSH
83151: PPUSH
83152: PPUSH
// if not mc_bases or not skirmish then
83153: LD_EXP 69
83157: NOT
83158: PUSH
83159: LD_EXP 67
83163: NOT
83164: OR
83165: IFFALSE 83169
// exit ;
83167: GO 83830
// for i = 1 to mc_bases do
83169: LD_ADDR_VAR 0 3
83173: PUSH
83174: DOUBLE
83175: LD_INT 1
83177: DEC
83178: ST_TO_ADDR
83179: LD_EXP 69
83183: PUSH
83184: FOR_TO
83185: IFFALSE 83828
// begin if building in mc_construct_list [ i ] then
83187: LD_VAR 0 1
83191: PUSH
83192: LD_EXP 76
83196: PUSH
83197: LD_VAR 0 3
83201: ARRAY
83202: IN
83203: IFFALSE 83826
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83205: LD_ADDR_EXP 76
83209: PUSH
83210: LD_EXP 76
83214: PPUSH
83215: LD_VAR 0 3
83219: PPUSH
83220: LD_EXP 76
83224: PUSH
83225: LD_VAR 0 3
83229: ARRAY
83230: PUSH
83231: LD_VAR 0 1
83235: DIFF
83236: PPUSH
83237: CALL_OW 1
83241: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83242: LD_ADDR_EXP 69
83246: PUSH
83247: LD_EXP 69
83251: PPUSH
83252: LD_VAR 0 3
83256: PUSH
83257: LD_EXP 69
83261: PUSH
83262: LD_VAR 0 3
83266: ARRAY
83267: PUSH
83268: LD_INT 1
83270: PLUS
83271: PUSH
83272: EMPTY
83273: LIST
83274: LIST
83275: PPUSH
83276: LD_VAR 0 1
83280: PPUSH
83281: CALL 18588 0 3
83285: ST_TO_ADDR
// btype := GetBType ( building ) ;
83286: LD_ADDR_VAR 0 5
83290: PUSH
83291: LD_VAR 0 1
83295: PPUSH
83296: CALL_OW 266
83300: ST_TO_ADDR
// side := GetSide ( building ) ;
83301: LD_ADDR_VAR 0 8
83305: PUSH
83306: LD_VAR 0 1
83310: PPUSH
83311: CALL_OW 255
83315: ST_TO_ADDR
// if btype = b_lab then
83316: LD_VAR 0 5
83320: PUSH
83321: LD_INT 6
83323: EQUAL
83324: IFFALSE 83374
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
83326: LD_ADDR_EXP 102
83330: PUSH
83331: LD_EXP 102
83335: PPUSH
83336: LD_VAR 0 3
83340: PUSH
83341: LD_EXP 102
83345: PUSH
83346: LD_VAR 0 3
83350: ARRAY
83351: PUSH
83352: LD_INT 1
83354: PLUS
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: PPUSH
83360: LD_VAR 0 1
83364: PPUSH
83365: CALL 18588 0 3
83369: ST_TO_ADDR
// exit ;
83370: POP
83371: POP
83372: GO 83830
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
83374: LD_VAR 0 5
83378: PUSH
83379: LD_INT 0
83381: PUSH
83382: LD_INT 2
83384: PUSH
83385: LD_INT 4
83387: PUSH
83388: EMPTY
83389: LIST
83390: LIST
83391: LIST
83392: IN
83393: IFFALSE 83517
// begin if btype = b_armoury then
83395: LD_VAR 0 5
83399: PUSH
83400: LD_INT 4
83402: EQUAL
83403: IFFALSE 83413
// btype := b_barracks ;
83405: LD_ADDR_VAR 0 5
83409: PUSH
83410: LD_INT 5
83412: ST_TO_ADDR
// if btype = b_depot then
83413: LD_VAR 0 5
83417: PUSH
83418: LD_INT 0
83420: EQUAL
83421: IFFALSE 83431
// btype := b_warehouse ;
83423: LD_ADDR_VAR 0 5
83427: PUSH
83428: LD_INT 1
83430: ST_TO_ADDR
// if btype = b_workshop then
83431: LD_VAR 0 5
83435: PUSH
83436: LD_INT 2
83438: EQUAL
83439: IFFALSE 83449
// btype := b_factory ;
83441: LD_ADDR_VAR 0 5
83445: PUSH
83446: LD_INT 3
83448: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
83449: LD_VAR 0 5
83453: PPUSH
83454: LD_VAR 0 8
83458: PPUSH
83459: CALL_OW 323
83463: PUSH
83464: LD_INT 1
83466: EQUAL
83467: IFFALSE 83513
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
83469: LD_ADDR_EXP 101
83473: PUSH
83474: LD_EXP 101
83478: PPUSH
83479: LD_VAR 0 3
83483: PUSH
83484: LD_EXP 101
83488: PUSH
83489: LD_VAR 0 3
83493: ARRAY
83494: PUSH
83495: LD_INT 1
83497: PLUS
83498: PUSH
83499: EMPTY
83500: LIST
83501: LIST
83502: PPUSH
83503: LD_VAR 0 1
83507: PPUSH
83508: CALL 18588 0 3
83512: ST_TO_ADDR
// exit ;
83513: POP
83514: POP
83515: GO 83830
// end ; if btype in [ b_bunker , b_turret ] then
83517: LD_VAR 0 5
83521: PUSH
83522: LD_INT 32
83524: PUSH
83525: LD_INT 33
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: IN
83532: IFFALSE 83822
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
83534: LD_ADDR_EXP 77
83538: PUSH
83539: LD_EXP 77
83543: PPUSH
83544: LD_VAR 0 3
83548: PUSH
83549: LD_EXP 77
83553: PUSH
83554: LD_VAR 0 3
83558: ARRAY
83559: PUSH
83560: LD_INT 1
83562: PLUS
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: PPUSH
83568: LD_VAR 0 1
83572: PPUSH
83573: CALL 18588 0 3
83577: ST_TO_ADDR
// if btype = b_bunker then
83578: LD_VAR 0 5
83582: PUSH
83583: LD_INT 32
83585: EQUAL
83586: IFFALSE 83822
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83588: LD_ADDR_EXP 78
83592: PUSH
83593: LD_EXP 78
83597: PPUSH
83598: LD_VAR 0 3
83602: PUSH
83603: LD_EXP 78
83607: PUSH
83608: LD_VAR 0 3
83612: ARRAY
83613: PUSH
83614: LD_INT 1
83616: PLUS
83617: PUSH
83618: EMPTY
83619: LIST
83620: LIST
83621: PPUSH
83622: LD_VAR 0 1
83626: PPUSH
83627: CALL 18588 0 3
83631: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
83632: LD_ADDR_VAR 0 6
83636: PUSH
83637: LD_EXP 69
83641: PUSH
83642: LD_VAR 0 3
83646: ARRAY
83647: PPUSH
83648: LD_INT 25
83650: PUSH
83651: LD_INT 1
83653: PUSH
83654: EMPTY
83655: LIST
83656: LIST
83657: PUSH
83658: LD_INT 3
83660: PUSH
83661: LD_INT 54
83663: PUSH
83664: EMPTY
83665: LIST
83666: PUSH
83667: EMPTY
83668: LIST
83669: LIST
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PPUSH
83675: CALL_OW 72
83679: ST_TO_ADDR
// if tmp then
83680: LD_VAR 0 6
83684: IFFALSE 83690
// exit ;
83686: POP
83687: POP
83688: GO 83830
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
83690: LD_ADDR_VAR 0 6
83694: PUSH
83695: LD_EXP 69
83699: PUSH
83700: LD_VAR 0 3
83704: ARRAY
83705: PPUSH
83706: LD_INT 2
83708: PUSH
83709: LD_INT 30
83711: PUSH
83712: LD_INT 4
83714: PUSH
83715: EMPTY
83716: LIST
83717: LIST
83718: PUSH
83719: LD_INT 30
83721: PUSH
83722: LD_INT 5
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PUSH
83729: EMPTY
83730: LIST
83731: LIST
83732: LIST
83733: PPUSH
83734: CALL_OW 72
83738: ST_TO_ADDR
// if not tmp then
83739: LD_VAR 0 6
83743: NOT
83744: IFFALSE 83750
// exit ;
83746: POP
83747: POP
83748: GO 83830
// for j in tmp do
83750: LD_ADDR_VAR 0 4
83754: PUSH
83755: LD_VAR 0 6
83759: PUSH
83760: FOR_IN
83761: IFFALSE 83820
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
83763: LD_ADDR_VAR 0 7
83767: PUSH
83768: LD_VAR 0 4
83772: PPUSH
83773: CALL_OW 313
83777: PPUSH
83778: LD_INT 25
83780: PUSH
83781: LD_INT 1
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: PPUSH
83788: CALL_OW 72
83792: ST_TO_ADDR
// if units then
83793: LD_VAR 0 7
83797: IFFALSE 83818
// begin ComExitBuilding ( units [ 1 ] ) ;
83799: LD_VAR 0 7
83803: PUSH
83804: LD_INT 1
83806: ARRAY
83807: PPUSH
83808: CALL_OW 122
// exit ;
83812: POP
83813: POP
83814: POP
83815: POP
83816: GO 83830
// end ; end ;
83818: GO 83760
83820: POP
83821: POP
// end ; end ; exit ;
83822: POP
83823: POP
83824: GO 83830
// end ; end ;
83826: GO 83184
83828: POP
83829: POP
// end ;
83830: LD_VAR 0 2
83834: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
83835: LD_INT 0
83837: PPUSH
83838: PPUSH
83839: PPUSH
83840: PPUSH
83841: PPUSH
83842: PPUSH
83843: PPUSH
// if not mc_bases or not skirmish then
83844: LD_EXP 69
83848: NOT
83849: PUSH
83850: LD_EXP 67
83854: NOT
83855: OR
83856: IFFALSE 83860
// exit ;
83858: GO 84125
// btype := GetBType ( building ) ;
83860: LD_ADDR_VAR 0 6
83864: PUSH
83865: LD_VAR 0 1
83869: PPUSH
83870: CALL_OW 266
83874: ST_TO_ADDR
// x := GetX ( building ) ;
83875: LD_ADDR_VAR 0 7
83879: PUSH
83880: LD_VAR 0 1
83884: PPUSH
83885: CALL_OW 250
83889: ST_TO_ADDR
// y := GetY ( building ) ;
83890: LD_ADDR_VAR 0 8
83894: PUSH
83895: LD_VAR 0 1
83899: PPUSH
83900: CALL_OW 251
83904: ST_TO_ADDR
// d := GetDir ( building ) ;
83905: LD_ADDR_VAR 0 9
83909: PUSH
83910: LD_VAR 0 1
83914: PPUSH
83915: CALL_OW 254
83919: ST_TO_ADDR
// for i = 1 to mc_bases do
83920: LD_ADDR_VAR 0 4
83924: PUSH
83925: DOUBLE
83926: LD_INT 1
83928: DEC
83929: ST_TO_ADDR
83930: LD_EXP 69
83934: PUSH
83935: FOR_TO
83936: IFFALSE 84123
// begin if not mc_build_list [ i ] then
83938: LD_EXP 74
83942: PUSH
83943: LD_VAR 0 4
83947: ARRAY
83948: NOT
83949: IFFALSE 83953
// continue ;
83951: GO 83935
// for j := 1 to mc_build_list [ i ] do
83953: LD_ADDR_VAR 0 5
83957: PUSH
83958: DOUBLE
83959: LD_INT 1
83961: DEC
83962: ST_TO_ADDR
83963: LD_EXP 74
83967: PUSH
83968: LD_VAR 0 4
83972: ARRAY
83973: PUSH
83974: FOR_TO
83975: IFFALSE 84119
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
83977: LD_VAR 0 6
83981: PUSH
83982: LD_VAR 0 7
83986: PUSH
83987: LD_VAR 0 8
83991: PUSH
83992: LD_VAR 0 9
83996: PUSH
83997: EMPTY
83998: LIST
83999: LIST
84000: LIST
84001: LIST
84002: PPUSH
84003: LD_EXP 74
84007: PUSH
84008: LD_VAR 0 4
84012: ARRAY
84013: PUSH
84014: LD_VAR 0 5
84018: ARRAY
84019: PPUSH
84020: CALL 24770 0 2
84024: IFFALSE 84117
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
84026: LD_ADDR_EXP 74
84030: PUSH
84031: LD_EXP 74
84035: PPUSH
84036: LD_VAR 0 4
84040: PPUSH
84041: LD_EXP 74
84045: PUSH
84046: LD_VAR 0 4
84050: ARRAY
84051: PPUSH
84052: LD_VAR 0 5
84056: PPUSH
84057: CALL_OW 3
84061: PPUSH
84062: CALL_OW 1
84066: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
84067: LD_ADDR_EXP 76
84071: PUSH
84072: LD_EXP 76
84076: PPUSH
84077: LD_VAR 0 4
84081: PUSH
84082: LD_EXP 76
84086: PUSH
84087: LD_VAR 0 4
84091: ARRAY
84092: PUSH
84093: LD_INT 1
84095: PLUS
84096: PUSH
84097: EMPTY
84098: LIST
84099: LIST
84100: PPUSH
84101: LD_VAR 0 1
84105: PPUSH
84106: CALL 18588 0 3
84110: ST_TO_ADDR
// exit ;
84111: POP
84112: POP
84113: POP
84114: POP
84115: GO 84125
// end ;
84117: GO 83974
84119: POP
84120: POP
// end ;
84121: GO 83935
84123: POP
84124: POP
// end ;
84125: LD_VAR 0 3
84129: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
84130: LD_INT 0
84132: PPUSH
84133: PPUSH
84134: PPUSH
// if not mc_bases or not skirmish then
84135: LD_EXP 69
84139: NOT
84140: PUSH
84141: LD_EXP 67
84145: NOT
84146: OR
84147: IFFALSE 84151
// exit ;
84149: GO 84341
// for i = 1 to mc_bases do
84151: LD_ADDR_VAR 0 4
84155: PUSH
84156: DOUBLE
84157: LD_INT 1
84159: DEC
84160: ST_TO_ADDR
84161: LD_EXP 69
84165: PUSH
84166: FOR_TO
84167: IFFALSE 84254
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
84169: LD_VAR 0 1
84173: PUSH
84174: LD_EXP 77
84178: PUSH
84179: LD_VAR 0 4
84183: ARRAY
84184: IN
84185: PUSH
84186: LD_VAR 0 1
84190: PUSH
84191: LD_EXP 78
84195: PUSH
84196: LD_VAR 0 4
84200: ARRAY
84201: IN
84202: NOT
84203: AND
84204: IFFALSE 84252
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84206: LD_ADDR_EXP 78
84210: PUSH
84211: LD_EXP 78
84215: PPUSH
84216: LD_VAR 0 4
84220: PUSH
84221: LD_EXP 78
84225: PUSH
84226: LD_VAR 0 4
84230: ARRAY
84231: PUSH
84232: LD_INT 1
84234: PLUS
84235: PUSH
84236: EMPTY
84237: LIST
84238: LIST
84239: PPUSH
84240: LD_VAR 0 1
84244: PPUSH
84245: CALL 18588 0 3
84249: ST_TO_ADDR
// break ;
84250: GO 84254
// end ; end ;
84252: GO 84166
84254: POP
84255: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
84256: LD_VAR 0 1
84260: PPUSH
84261: CALL_OW 257
84265: PUSH
84266: LD_EXP 95
84270: IN
84271: PUSH
84272: LD_VAR 0 1
84276: PPUSH
84277: CALL_OW 266
84281: PUSH
84282: LD_INT 5
84284: EQUAL
84285: AND
84286: PUSH
84287: LD_VAR 0 2
84291: PPUSH
84292: CALL_OW 110
84296: PUSH
84297: LD_INT 18
84299: NONEQUAL
84300: AND
84301: IFFALSE 84341
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
84303: LD_VAR 0 2
84307: PPUSH
84308: CALL_OW 257
84312: PUSH
84313: LD_INT 5
84315: PUSH
84316: LD_INT 8
84318: PUSH
84319: LD_INT 9
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: LIST
84326: IN
84327: IFFALSE 84341
// SetClass ( unit , 1 ) ;
84329: LD_VAR 0 2
84333: PPUSH
84334: LD_INT 1
84336: PPUSH
84337: CALL_OW 336
// end ;
84341: LD_VAR 0 3
84345: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
84346: LD_INT 0
84348: PPUSH
84349: PPUSH
// if not mc_bases or not skirmish then
84350: LD_EXP 69
84354: NOT
84355: PUSH
84356: LD_EXP 67
84360: NOT
84361: OR
84362: IFFALSE 84366
// exit ;
84364: GO 84482
// if GetLives ( abandoned_vehicle ) > 250 then
84366: LD_VAR 0 2
84370: PPUSH
84371: CALL_OW 256
84375: PUSH
84376: LD_INT 250
84378: GREATER
84379: IFFALSE 84383
// exit ;
84381: GO 84482
// for i = 1 to mc_bases do
84383: LD_ADDR_VAR 0 6
84387: PUSH
84388: DOUBLE
84389: LD_INT 1
84391: DEC
84392: ST_TO_ADDR
84393: LD_EXP 69
84397: PUSH
84398: FOR_TO
84399: IFFALSE 84480
// begin if driver in mc_bases [ i ] then
84401: LD_VAR 0 1
84405: PUSH
84406: LD_EXP 69
84410: PUSH
84411: LD_VAR 0 6
84415: ARRAY
84416: IN
84417: IFFALSE 84478
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
84419: LD_VAR 0 1
84423: PPUSH
84424: LD_EXP 69
84428: PUSH
84429: LD_VAR 0 6
84433: ARRAY
84434: PPUSH
84435: LD_INT 2
84437: PUSH
84438: LD_INT 30
84440: PUSH
84441: LD_INT 0
84443: PUSH
84444: EMPTY
84445: LIST
84446: LIST
84447: PUSH
84448: LD_INT 30
84450: PUSH
84451: LD_INT 1
84453: PUSH
84454: EMPTY
84455: LIST
84456: LIST
84457: PUSH
84458: EMPTY
84459: LIST
84460: LIST
84461: LIST
84462: PPUSH
84463: CALL_OW 72
84467: PUSH
84468: LD_INT 1
84470: ARRAY
84471: PPUSH
84472: CALL 51206 0 2
// break ;
84476: GO 84480
// end ; end ;
84478: GO 84398
84480: POP
84481: POP
// end ; end_of_file end_of_file
84482: LD_VAR 0 5
84486: RET
// every 0 0$1 do
84487: GO 84489
84489: DISABLE
// begin enable ;
84490: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
84491: LD_STRING updateTimer(
84493: PUSH
84494: LD_OWVAR 1
84498: STR
84499: PUSH
84500: LD_STRING );
84502: STR
84503: PPUSH
84504: CALL_OW 559
// end ;
84508: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
84509: LD_INT 0
84511: PPUSH
// if p2 = 100 then
84512: LD_VAR 0 2
84516: PUSH
84517: LD_INT 100
84519: EQUAL
84520: IFFALSE 85523
// begin if not StreamModeActive then
84522: LD_EXP 113
84526: NOT
84527: IFFALSE 84537
// StreamModeActive := true ;
84529: LD_ADDR_EXP 113
84533: PUSH
84534: LD_INT 1
84536: ST_TO_ADDR
// if p3 = 0 then
84537: LD_VAR 0 3
84541: PUSH
84542: LD_INT 0
84544: EQUAL
84545: IFFALSE 84551
// InitStreamMode ;
84547: CALL 85683 0 0
// if p3 = 1 then
84551: LD_VAR 0 3
84555: PUSH
84556: LD_INT 1
84558: EQUAL
84559: IFFALSE 84569
// sRocket := true ;
84561: LD_ADDR_EXP 118
84565: PUSH
84566: LD_INT 1
84568: ST_TO_ADDR
// if p3 = 2 then
84569: LD_VAR 0 3
84573: PUSH
84574: LD_INT 2
84576: EQUAL
84577: IFFALSE 84587
// sSpeed := true ;
84579: LD_ADDR_EXP 117
84583: PUSH
84584: LD_INT 1
84586: ST_TO_ADDR
// if p3 = 3 then
84587: LD_VAR 0 3
84591: PUSH
84592: LD_INT 3
84594: EQUAL
84595: IFFALSE 84605
// sEngine := true ;
84597: LD_ADDR_EXP 119
84601: PUSH
84602: LD_INT 1
84604: ST_TO_ADDR
// if p3 = 4 then
84605: LD_VAR 0 3
84609: PUSH
84610: LD_INT 4
84612: EQUAL
84613: IFFALSE 84623
// sSpec := true ;
84615: LD_ADDR_EXP 116
84619: PUSH
84620: LD_INT 1
84622: ST_TO_ADDR
// if p3 = 5 then
84623: LD_VAR 0 3
84627: PUSH
84628: LD_INT 5
84630: EQUAL
84631: IFFALSE 84641
// sLevel := true ;
84633: LD_ADDR_EXP 120
84637: PUSH
84638: LD_INT 1
84640: ST_TO_ADDR
// if p3 = 6 then
84641: LD_VAR 0 3
84645: PUSH
84646: LD_INT 6
84648: EQUAL
84649: IFFALSE 84659
// sArmoury := true ;
84651: LD_ADDR_EXP 121
84655: PUSH
84656: LD_INT 1
84658: ST_TO_ADDR
// if p3 = 7 then
84659: LD_VAR 0 3
84663: PUSH
84664: LD_INT 7
84666: EQUAL
84667: IFFALSE 84677
// sRadar := true ;
84669: LD_ADDR_EXP 122
84673: PUSH
84674: LD_INT 1
84676: ST_TO_ADDR
// if p3 = 8 then
84677: LD_VAR 0 3
84681: PUSH
84682: LD_INT 8
84684: EQUAL
84685: IFFALSE 84695
// sBunker := true ;
84687: LD_ADDR_EXP 123
84691: PUSH
84692: LD_INT 1
84694: ST_TO_ADDR
// if p3 = 9 then
84695: LD_VAR 0 3
84699: PUSH
84700: LD_INT 9
84702: EQUAL
84703: IFFALSE 84713
// sHack := true ;
84705: LD_ADDR_EXP 124
84709: PUSH
84710: LD_INT 1
84712: ST_TO_ADDR
// if p3 = 10 then
84713: LD_VAR 0 3
84717: PUSH
84718: LD_INT 10
84720: EQUAL
84721: IFFALSE 84731
// sFire := true ;
84723: LD_ADDR_EXP 125
84727: PUSH
84728: LD_INT 1
84730: ST_TO_ADDR
// if p3 = 11 then
84731: LD_VAR 0 3
84735: PUSH
84736: LD_INT 11
84738: EQUAL
84739: IFFALSE 84749
// sRefresh := true ;
84741: LD_ADDR_EXP 126
84745: PUSH
84746: LD_INT 1
84748: ST_TO_ADDR
// if p3 = 12 then
84749: LD_VAR 0 3
84753: PUSH
84754: LD_INT 12
84756: EQUAL
84757: IFFALSE 84767
// sExp := true ;
84759: LD_ADDR_EXP 127
84763: PUSH
84764: LD_INT 1
84766: ST_TO_ADDR
// if p3 = 13 then
84767: LD_VAR 0 3
84771: PUSH
84772: LD_INT 13
84774: EQUAL
84775: IFFALSE 84785
// sDepot := true ;
84777: LD_ADDR_EXP 128
84781: PUSH
84782: LD_INT 1
84784: ST_TO_ADDR
// if p3 = 14 then
84785: LD_VAR 0 3
84789: PUSH
84790: LD_INT 14
84792: EQUAL
84793: IFFALSE 84803
// sFlag := true ;
84795: LD_ADDR_EXP 129
84799: PUSH
84800: LD_INT 1
84802: ST_TO_ADDR
// if p3 = 15 then
84803: LD_VAR 0 3
84807: PUSH
84808: LD_INT 15
84810: EQUAL
84811: IFFALSE 84821
// sKamikadze := true ;
84813: LD_ADDR_EXP 137
84817: PUSH
84818: LD_INT 1
84820: ST_TO_ADDR
// if p3 = 16 then
84821: LD_VAR 0 3
84825: PUSH
84826: LD_INT 16
84828: EQUAL
84829: IFFALSE 84839
// sTroll := true ;
84831: LD_ADDR_EXP 138
84835: PUSH
84836: LD_INT 1
84838: ST_TO_ADDR
// if p3 = 17 then
84839: LD_VAR 0 3
84843: PUSH
84844: LD_INT 17
84846: EQUAL
84847: IFFALSE 84857
// sSlow := true ;
84849: LD_ADDR_EXP 139
84853: PUSH
84854: LD_INT 1
84856: ST_TO_ADDR
// if p3 = 18 then
84857: LD_VAR 0 3
84861: PUSH
84862: LD_INT 18
84864: EQUAL
84865: IFFALSE 84875
// sLack := true ;
84867: LD_ADDR_EXP 140
84871: PUSH
84872: LD_INT 1
84874: ST_TO_ADDR
// if p3 = 19 then
84875: LD_VAR 0 3
84879: PUSH
84880: LD_INT 19
84882: EQUAL
84883: IFFALSE 84893
// sTank := true ;
84885: LD_ADDR_EXP 142
84889: PUSH
84890: LD_INT 1
84892: ST_TO_ADDR
// if p3 = 20 then
84893: LD_VAR 0 3
84897: PUSH
84898: LD_INT 20
84900: EQUAL
84901: IFFALSE 84911
// sRemote := true ;
84903: LD_ADDR_EXP 143
84907: PUSH
84908: LD_INT 1
84910: ST_TO_ADDR
// if p3 = 21 then
84911: LD_VAR 0 3
84915: PUSH
84916: LD_INT 21
84918: EQUAL
84919: IFFALSE 84929
// sPowell := true ;
84921: LD_ADDR_EXP 144
84925: PUSH
84926: LD_INT 1
84928: ST_TO_ADDR
// if p3 = 22 then
84929: LD_VAR 0 3
84933: PUSH
84934: LD_INT 22
84936: EQUAL
84937: IFFALSE 84947
// sTeleport := true ;
84939: LD_ADDR_EXP 147
84943: PUSH
84944: LD_INT 1
84946: ST_TO_ADDR
// if p3 = 23 then
84947: LD_VAR 0 3
84951: PUSH
84952: LD_INT 23
84954: EQUAL
84955: IFFALSE 84965
// sOilTower := true ;
84957: LD_ADDR_EXP 149
84961: PUSH
84962: LD_INT 1
84964: ST_TO_ADDR
// if p3 = 24 then
84965: LD_VAR 0 3
84969: PUSH
84970: LD_INT 24
84972: EQUAL
84973: IFFALSE 84983
// sShovel := true ;
84975: LD_ADDR_EXP 150
84979: PUSH
84980: LD_INT 1
84982: ST_TO_ADDR
// if p3 = 25 then
84983: LD_VAR 0 3
84987: PUSH
84988: LD_INT 25
84990: EQUAL
84991: IFFALSE 85001
// sSheik := true ;
84993: LD_ADDR_EXP 151
84997: PUSH
84998: LD_INT 1
85000: ST_TO_ADDR
// if p3 = 26 then
85001: LD_VAR 0 3
85005: PUSH
85006: LD_INT 26
85008: EQUAL
85009: IFFALSE 85019
// sEarthquake := true ;
85011: LD_ADDR_EXP 153
85015: PUSH
85016: LD_INT 1
85018: ST_TO_ADDR
// if p3 = 27 then
85019: LD_VAR 0 3
85023: PUSH
85024: LD_INT 27
85026: EQUAL
85027: IFFALSE 85037
// sAI := true ;
85029: LD_ADDR_EXP 154
85033: PUSH
85034: LD_INT 1
85036: ST_TO_ADDR
// if p3 = 28 then
85037: LD_VAR 0 3
85041: PUSH
85042: LD_INT 28
85044: EQUAL
85045: IFFALSE 85055
// sCargo := true ;
85047: LD_ADDR_EXP 157
85051: PUSH
85052: LD_INT 1
85054: ST_TO_ADDR
// if p3 = 29 then
85055: LD_VAR 0 3
85059: PUSH
85060: LD_INT 29
85062: EQUAL
85063: IFFALSE 85073
// sDLaser := true ;
85065: LD_ADDR_EXP 158
85069: PUSH
85070: LD_INT 1
85072: ST_TO_ADDR
// if p3 = 30 then
85073: LD_VAR 0 3
85077: PUSH
85078: LD_INT 30
85080: EQUAL
85081: IFFALSE 85091
// sExchange := true ;
85083: LD_ADDR_EXP 159
85087: PUSH
85088: LD_INT 1
85090: ST_TO_ADDR
// if p3 = 31 then
85091: LD_VAR 0 3
85095: PUSH
85096: LD_INT 31
85098: EQUAL
85099: IFFALSE 85109
// sFac := true ;
85101: LD_ADDR_EXP 160
85105: PUSH
85106: LD_INT 1
85108: ST_TO_ADDR
// if p3 = 32 then
85109: LD_VAR 0 3
85113: PUSH
85114: LD_INT 32
85116: EQUAL
85117: IFFALSE 85127
// sPower := true ;
85119: LD_ADDR_EXP 161
85123: PUSH
85124: LD_INT 1
85126: ST_TO_ADDR
// if p3 = 33 then
85127: LD_VAR 0 3
85131: PUSH
85132: LD_INT 33
85134: EQUAL
85135: IFFALSE 85145
// sRandom := true ;
85137: LD_ADDR_EXP 162
85141: PUSH
85142: LD_INT 1
85144: ST_TO_ADDR
// if p3 = 34 then
85145: LD_VAR 0 3
85149: PUSH
85150: LD_INT 34
85152: EQUAL
85153: IFFALSE 85163
// sShield := true ;
85155: LD_ADDR_EXP 163
85159: PUSH
85160: LD_INT 1
85162: ST_TO_ADDR
// if p3 = 35 then
85163: LD_VAR 0 3
85167: PUSH
85168: LD_INT 35
85170: EQUAL
85171: IFFALSE 85181
// sTime := true ;
85173: LD_ADDR_EXP 164
85177: PUSH
85178: LD_INT 1
85180: ST_TO_ADDR
// if p3 = 36 then
85181: LD_VAR 0 3
85185: PUSH
85186: LD_INT 36
85188: EQUAL
85189: IFFALSE 85199
// sTools := true ;
85191: LD_ADDR_EXP 165
85195: PUSH
85196: LD_INT 1
85198: ST_TO_ADDR
// if p3 = 101 then
85199: LD_VAR 0 3
85203: PUSH
85204: LD_INT 101
85206: EQUAL
85207: IFFALSE 85217
// sSold := true ;
85209: LD_ADDR_EXP 130
85213: PUSH
85214: LD_INT 1
85216: ST_TO_ADDR
// if p3 = 102 then
85217: LD_VAR 0 3
85221: PUSH
85222: LD_INT 102
85224: EQUAL
85225: IFFALSE 85235
// sDiff := true ;
85227: LD_ADDR_EXP 131
85231: PUSH
85232: LD_INT 1
85234: ST_TO_ADDR
// if p3 = 103 then
85235: LD_VAR 0 3
85239: PUSH
85240: LD_INT 103
85242: EQUAL
85243: IFFALSE 85253
// sFog := true ;
85245: LD_ADDR_EXP 134
85249: PUSH
85250: LD_INT 1
85252: ST_TO_ADDR
// if p3 = 104 then
85253: LD_VAR 0 3
85257: PUSH
85258: LD_INT 104
85260: EQUAL
85261: IFFALSE 85271
// sReset := true ;
85263: LD_ADDR_EXP 135
85267: PUSH
85268: LD_INT 1
85270: ST_TO_ADDR
// if p3 = 105 then
85271: LD_VAR 0 3
85275: PUSH
85276: LD_INT 105
85278: EQUAL
85279: IFFALSE 85289
// sSun := true ;
85281: LD_ADDR_EXP 136
85285: PUSH
85286: LD_INT 1
85288: ST_TO_ADDR
// if p3 = 106 then
85289: LD_VAR 0 3
85293: PUSH
85294: LD_INT 106
85296: EQUAL
85297: IFFALSE 85307
// sTiger := true ;
85299: LD_ADDR_EXP 132
85303: PUSH
85304: LD_INT 1
85306: ST_TO_ADDR
// if p3 = 107 then
85307: LD_VAR 0 3
85311: PUSH
85312: LD_INT 107
85314: EQUAL
85315: IFFALSE 85325
// sBomb := true ;
85317: LD_ADDR_EXP 133
85321: PUSH
85322: LD_INT 1
85324: ST_TO_ADDR
// if p3 = 108 then
85325: LD_VAR 0 3
85329: PUSH
85330: LD_INT 108
85332: EQUAL
85333: IFFALSE 85343
// sWound := true ;
85335: LD_ADDR_EXP 141
85339: PUSH
85340: LD_INT 1
85342: ST_TO_ADDR
// if p3 = 109 then
85343: LD_VAR 0 3
85347: PUSH
85348: LD_INT 109
85350: EQUAL
85351: IFFALSE 85361
// sBetray := true ;
85353: LD_ADDR_EXP 145
85357: PUSH
85358: LD_INT 1
85360: ST_TO_ADDR
// if p3 = 110 then
85361: LD_VAR 0 3
85365: PUSH
85366: LD_INT 110
85368: EQUAL
85369: IFFALSE 85379
// sContamin := true ;
85371: LD_ADDR_EXP 146
85375: PUSH
85376: LD_INT 1
85378: ST_TO_ADDR
// if p3 = 111 then
85379: LD_VAR 0 3
85383: PUSH
85384: LD_INT 111
85386: EQUAL
85387: IFFALSE 85397
// sOil := true ;
85389: LD_ADDR_EXP 148
85393: PUSH
85394: LD_INT 1
85396: ST_TO_ADDR
// if p3 = 112 then
85397: LD_VAR 0 3
85401: PUSH
85402: LD_INT 112
85404: EQUAL
85405: IFFALSE 85415
// sStu := true ;
85407: LD_ADDR_EXP 152
85411: PUSH
85412: LD_INT 1
85414: ST_TO_ADDR
// if p3 = 113 then
85415: LD_VAR 0 3
85419: PUSH
85420: LD_INT 113
85422: EQUAL
85423: IFFALSE 85433
// sBazooka := true ;
85425: LD_ADDR_EXP 155
85429: PUSH
85430: LD_INT 1
85432: ST_TO_ADDR
// if p3 = 114 then
85433: LD_VAR 0 3
85437: PUSH
85438: LD_INT 114
85440: EQUAL
85441: IFFALSE 85451
// sMortar := true ;
85443: LD_ADDR_EXP 156
85447: PUSH
85448: LD_INT 1
85450: ST_TO_ADDR
// if p3 = 115 then
85451: LD_VAR 0 3
85455: PUSH
85456: LD_INT 115
85458: EQUAL
85459: IFFALSE 85469
// sRanger := true ;
85461: LD_ADDR_EXP 166
85465: PUSH
85466: LD_INT 1
85468: ST_TO_ADDR
// if p3 = 116 then
85469: LD_VAR 0 3
85473: PUSH
85474: LD_INT 116
85476: EQUAL
85477: IFFALSE 85487
// sComputer := true ;
85479: LD_ADDR_EXP 167
85483: PUSH
85484: LD_INT 1
85486: ST_TO_ADDR
// if p3 = 117 then
85487: LD_VAR 0 3
85491: PUSH
85492: LD_INT 117
85494: EQUAL
85495: IFFALSE 85505
// s30 := true ;
85497: LD_ADDR_EXP 168
85501: PUSH
85502: LD_INT 1
85504: ST_TO_ADDR
// if p3 = 118 then
85505: LD_VAR 0 3
85509: PUSH
85510: LD_INT 118
85512: EQUAL
85513: IFFALSE 85523
// s60 := true ;
85515: LD_ADDR_EXP 169
85519: PUSH
85520: LD_INT 1
85522: ST_TO_ADDR
// end ; if p2 = 101 then
85523: LD_VAR 0 2
85527: PUSH
85528: LD_INT 101
85530: EQUAL
85531: IFFALSE 85659
// begin case p3 of 1 :
85533: LD_VAR 0 3
85537: PUSH
85538: LD_INT 1
85540: DOUBLE
85541: EQUAL
85542: IFTRUE 85546
85544: GO 85553
85546: POP
// hHackUnlimitedResources ; 2 :
85547: CALL 97255 0 0
85551: GO 85659
85553: LD_INT 2
85555: DOUBLE
85556: EQUAL
85557: IFTRUE 85561
85559: GO 85568
85561: POP
// hHackSetLevel10 ; 3 :
85562: CALL 97388 0 0
85566: GO 85659
85568: LD_INT 3
85570: DOUBLE
85571: EQUAL
85572: IFTRUE 85576
85574: GO 85583
85576: POP
// hHackSetLevel10YourUnits ; 4 :
85577: CALL 97473 0 0
85581: GO 85659
85583: LD_INT 4
85585: DOUBLE
85586: EQUAL
85587: IFTRUE 85591
85589: GO 85598
85591: POP
// hHackInvincible ; 5 :
85592: CALL 97921 0 0
85596: GO 85659
85598: LD_INT 5
85600: DOUBLE
85601: EQUAL
85602: IFTRUE 85606
85604: GO 85613
85606: POP
// hHackInvisible ; 6 :
85607: CALL 98032 0 0
85611: GO 85659
85613: LD_INT 6
85615: DOUBLE
85616: EQUAL
85617: IFTRUE 85621
85619: GO 85628
85621: POP
// hHackChangeYourSide ; 7 :
85622: CALL 98089 0 0
85626: GO 85659
85628: LD_INT 7
85630: DOUBLE
85631: EQUAL
85632: IFTRUE 85636
85634: GO 85643
85636: POP
// hHackChangeUnitSide ; 8 :
85637: CALL 98131 0 0
85641: GO 85659
85643: LD_INT 8
85645: DOUBLE
85646: EQUAL
85647: IFTRUE 85651
85649: GO 85658
85651: POP
// hHackFog ; end ;
85652: CALL 98232 0 0
85656: GO 85659
85658: POP
// end ; end ;
85659: LD_VAR 0 7
85663: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
85664: GO 85666
85666: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
85667: LD_STRING initStreamRollete();
85669: PPUSH
85670: CALL_OW 559
// InitStreamMode ;
85674: CALL 85683 0 0
// DefineStreamItems ( ) ;
85678: CALL 86147 0 0
// end ;
85682: END
// function InitStreamMode ; begin
85683: LD_INT 0
85685: PPUSH
// streamModeActive := false ;
85686: LD_ADDR_EXP 113
85690: PUSH
85691: LD_INT 0
85693: ST_TO_ADDR
// normalCounter := 36 ;
85694: LD_ADDR_EXP 114
85698: PUSH
85699: LD_INT 36
85701: ST_TO_ADDR
// hardcoreCounter := 16 ;
85702: LD_ADDR_EXP 115
85706: PUSH
85707: LD_INT 16
85709: ST_TO_ADDR
// sRocket := false ;
85710: LD_ADDR_EXP 118
85714: PUSH
85715: LD_INT 0
85717: ST_TO_ADDR
// sSpeed := false ;
85718: LD_ADDR_EXP 117
85722: PUSH
85723: LD_INT 0
85725: ST_TO_ADDR
// sEngine := false ;
85726: LD_ADDR_EXP 119
85730: PUSH
85731: LD_INT 0
85733: ST_TO_ADDR
// sSpec := false ;
85734: LD_ADDR_EXP 116
85738: PUSH
85739: LD_INT 0
85741: ST_TO_ADDR
// sLevel := false ;
85742: LD_ADDR_EXP 120
85746: PUSH
85747: LD_INT 0
85749: ST_TO_ADDR
// sArmoury := false ;
85750: LD_ADDR_EXP 121
85754: PUSH
85755: LD_INT 0
85757: ST_TO_ADDR
// sRadar := false ;
85758: LD_ADDR_EXP 122
85762: PUSH
85763: LD_INT 0
85765: ST_TO_ADDR
// sBunker := false ;
85766: LD_ADDR_EXP 123
85770: PUSH
85771: LD_INT 0
85773: ST_TO_ADDR
// sHack := false ;
85774: LD_ADDR_EXP 124
85778: PUSH
85779: LD_INT 0
85781: ST_TO_ADDR
// sFire := false ;
85782: LD_ADDR_EXP 125
85786: PUSH
85787: LD_INT 0
85789: ST_TO_ADDR
// sRefresh := false ;
85790: LD_ADDR_EXP 126
85794: PUSH
85795: LD_INT 0
85797: ST_TO_ADDR
// sExp := false ;
85798: LD_ADDR_EXP 127
85802: PUSH
85803: LD_INT 0
85805: ST_TO_ADDR
// sDepot := false ;
85806: LD_ADDR_EXP 128
85810: PUSH
85811: LD_INT 0
85813: ST_TO_ADDR
// sFlag := false ;
85814: LD_ADDR_EXP 129
85818: PUSH
85819: LD_INT 0
85821: ST_TO_ADDR
// sKamikadze := false ;
85822: LD_ADDR_EXP 137
85826: PUSH
85827: LD_INT 0
85829: ST_TO_ADDR
// sTroll := false ;
85830: LD_ADDR_EXP 138
85834: PUSH
85835: LD_INT 0
85837: ST_TO_ADDR
// sSlow := false ;
85838: LD_ADDR_EXP 139
85842: PUSH
85843: LD_INT 0
85845: ST_TO_ADDR
// sLack := false ;
85846: LD_ADDR_EXP 140
85850: PUSH
85851: LD_INT 0
85853: ST_TO_ADDR
// sTank := false ;
85854: LD_ADDR_EXP 142
85858: PUSH
85859: LD_INT 0
85861: ST_TO_ADDR
// sRemote := false ;
85862: LD_ADDR_EXP 143
85866: PUSH
85867: LD_INT 0
85869: ST_TO_ADDR
// sPowell := false ;
85870: LD_ADDR_EXP 144
85874: PUSH
85875: LD_INT 0
85877: ST_TO_ADDR
// sTeleport := false ;
85878: LD_ADDR_EXP 147
85882: PUSH
85883: LD_INT 0
85885: ST_TO_ADDR
// sOilTower := false ;
85886: LD_ADDR_EXP 149
85890: PUSH
85891: LD_INT 0
85893: ST_TO_ADDR
// sShovel := false ;
85894: LD_ADDR_EXP 150
85898: PUSH
85899: LD_INT 0
85901: ST_TO_ADDR
// sSheik := false ;
85902: LD_ADDR_EXP 151
85906: PUSH
85907: LD_INT 0
85909: ST_TO_ADDR
// sEarthquake := false ;
85910: LD_ADDR_EXP 153
85914: PUSH
85915: LD_INT 0
85917: ST_TO_ADDR
// sAI := false ;
85918: LD_ADDR_EXP 154
85922: PUSH
85923: LD_INT 0
85925: ST_TO_ADDR
// sCargo := false ;
85926: LD_ADDR_EXP 157
85930: PUSH
85931: LD_INT 0
85933: ST_TO_ADDR
// sDLaser := false ;
85934: LD_ADDR_EXP 158
85938: PUSH
85939: LD_INT 0
85941: ST_TO_ADDR
// sExchange := false ;
85942: LD_ADDR_EXP 159
85946: PUSH
85947: LD_INT 0
85949: ST_TO_ADDR
// sFac := false ;
85950: LD_ADDR_EXP 160
85954: PUSH
85955: LD_INT 0
85957: ST_TO_ADDR
// sPower := false ;
85958: LD_ADDR_EXP 161
85962: PUSH
85963: LD_INT 0
85965: ST_TO_ADDR
// sRandom := false ;
85966: LD_ADDR_EXP 162
85970: PUSH
85971: LD_INT 0
85973: ST_TO_ADDR
// sShield := false ;
85974: LD_ADDR_EXP 163
85978: PUSH
85979: LD_INT 0
85981: ST_TO_ADDR
// sTime := false ;
85982: LD_ADDR_EXP 164
85986: PUSH
85987: LD_INT 0
85989: ST_TO_ADDR
// sTools := false ;
85990: LD_ADDR_EXP 165
85994: PUSH
85995: LD_INT 0
85997: ST_TO_ADDR
// sSold := false ;
85998: LD_ADDR_EXP 130
86002: PUSH
86003: LD_INT 0
86005: ST_TO_ADDR
// sDiff := false ;
86006: LD_ADDR_EXP 131
86010: PUSH
86011: LD_INT 0
86013: ST_TO_ADDR
// sFog := false ;
86014: LD_ADDR_EXP 134
86018: PUSH
86019: LD_INT 0
86021: ST_TO_ADDR
// sReset := false ;
86022: LD_ADDR_EXP 135
86026: PUSH
86027: LD_INT 0
86029: ST_TO_ADDR
// sSun := false ;
86030: LD_ADDR_EXP 136
86034: PUSH
86035: LD_INT 0
86037: ST_TO_ADDR
// sTiger := false ;
86038: LD_ADDR_EXP 132
86042: PUSH
86043: LD_INT 0
86045: ST_TO_ADDR
// sBomb := false ;
86046: LD_ADDR_EXP 133
86050: PUSH
86051: LD_INT 0
86053: ST_TO_ADDR
// sWound := false ;
86054: LD_ADDR_EXP 141
86058: PUSH
86059: LD_INT 0
86061: ST_TO_ADDR
// sBetray := false ;
86062: LD_ADDR_EXP 145
86066: PUSH
86067: LD_INT 0
86069: ST_TO_ADDR
// sContamin := false ;
86070: LD_ADDR_EXP 146
86074: PUSH
86075: LD_INT 0
86077: ST_TO_ADDR
// sOil := false ;
86078: LD_ADDR_EXP 148
86082: PUSH
86083: LD_INT 0
86085: ST_TO_ADDR
// sStu := false ;
86086: LD_ADDR_EXP 152
86090: PUSH
86091: LD_INT 0
86093: ST_TO_ADDR
// sBazooka := false ;
86094: LD_ADDR_EXP 155
86098: PUSH
86099: LD_INT 0
86101: ST_TO_ADDR
// sMortar := false ;
86102: LD_ADDR_EXP 156
86106: PUSH
86107: LD_INT 0
86109: ST_TO_ADDR
// sRanger := false ;
86110: LD_ADDR_EXP 166
86114: PUSH
86115: LD_INT 0
86117: ST_TO_ADDR
// sComputer := false ;
86118: LD_ADDR_EXP 167
86122: PUSH
86123: LD_INT 0
86125: ST_TO_ADDR
// s30 := false ;
86126: LD_ADDR_EXP 168
86130: PUSH
86131: LD_INT 0
86133: ST_TO_ADDR
// s60 := false ;
86134: LD_ADDR_EXP 169
86138: PUSH
86139: LD_INT 0
86141: ST_TO_ADDR
// end ;
86142: LD_VAR 0 1
86146: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
86147: LD_INT 0
86149: PPUSH
86150: PPUSH
86151: PPUSH
86152: PPUSH
86153: PPUSH
// result := [ ] ;
86154: LD_ADDR_VAR 0 1
86158: PUSH
86159: EMPTY
86160: ST_TO_ADDR
// if campaign_id = 1 then
86161: LD_OWVAR 69
86165: PUSH
86166: LD_INT 1
86168: EQUAL
86169: IFFALSE 89335
// begin case mission_number of 1 :
86171: LD_OWVAR 70
86175: PUSH
86176: LD_INT 1
86178: DOUBLE
86179: EQUAL
86180: IFTRUE 86184
86182: GO 86260
86184: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
86185: LD_ADDR_VAR 0 1
86189: PUSH
86190: LD_INT 2
86192: PUSH
86193: LD_INT 4
86195: PUSH
86196: LD_INT 11
86198: PUSH
86199: LD_INT 12
86201: PUSH
86202: LD_INT 15
86204: PUSH
86205: LD_INT 16
86207: PUSH
86208: LD_INT 22
86210: PUSH
86211: LD_INT 23
86213: PUSH
86214: LD_INT 26
86216: PUSH
86217: EMPTY
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: LIST
86224: LIST
86225: LIST
86226: LIST
86227: PUSH
86228: LD_INT 101
86230: PUSH
86231: LD_INT 102
86233: PUSH
86234: LD_INT 106
86236: PUSH
86237: LD_INT 116
86239: PUSH
86240: LD_INT 117
86242: PUSH
86243: LD_INT 118
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: LIST
86250: LIST
86251: LIST
86252: LIST
86253: PUSH
86254: EMPTY
86255: LIST
86256: LIST
86257: ST_TO_ADDR
86258: GO 89333
86260: LD_INT 2
86262: DOUBLE
86263: EQUAL
86264: IFTRUE 86268
86266: GO 86352
86268: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
86269: LD_ADDR_VAR 0 1
86273: PUSH
86274: LD_INT 2
86276: PUSH
86277: LD_INT 4
86279: PUSH
86280: LD_INT 11
86282: PUSH
86283: LD_INT 12
86285: PUSH
86286: LD_INT 15
86288: PUSH
86289: LD_INT 16
86291: PUSH
86292: LD_INT 22
86294: PUSH
86295: LD_INT 23
86297: PUSH
86298: LD_INT 26
86300: PUSH
86301: EMPTY
86302: LIST
86303: LIST
86304: LIST
86305: LIST
86306: LIST
86307: LIST
86308: LIST
86309: LIST
86310: LIST
86311: PUSH
86312: LD_INT 101
86314: PUSH
86315: LD_INT 102
86317: PUSH
86318: LD_INT 105
86320: PUSH
86321: LD_INT 106
86323: PUSH
86324: LD_INT 108
86326: PUSH
86327: LD_INT 116
86329: PUSH
86330: LD_INT 117
86332: PUSH
86333: LD_INT 118
86335: PUSH
86336: EMPTY
86337: LIST
86338: LIST
86339: LIST
86340: LIST
86341: LIST
86342: LIST
86343: LIST
86344: LIST
86345: PUSH
86346: EMPTY
86347: LIST
86348: LIST
86349: ST_TO_ADDR
86350: GO 89333
86352: LD_INT 3
86354: DOUBLE
86355: EQUAL
86356: IFTRUE 86360
86358: GO 86448
86360: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
86361: LD_ADDR_VAR 0 1
86365: PUSH
86366: LD_INT 2
86368: PUSH
86369: LD_INT 4
86371: PUSH
86372: LD_INT 5
86374: PUSH
86375: LD_INT 11
86377: PUSH
86378: LD_INT 12
86380: PUSH
86381: LD_INT 15
86383: PUSH
86384: LD_INT 16
86386: PUSH
86387: LD_INT 22
86389: PUSH
86390: LD_INT 26
86392: PUSH
86393: LD_INT 36
86395: PUSH
86396: EMPTY
86397: LIST
86398: LIST
86399: LIST
86400: LIST
86401: LIST
86402: LIST
86403: LIST
86404: LIST
86405: LIST
86406: LIST
86407: PUSH
86408: LD_INT 101
86410: PUSH
86411: LD_INT 102
86413: PUSH
86414: LD_INT 105
86416: PUSH
86417: LD_INT 106
86419: PUSH
86420: LD_INT 108
86422: PUSH
86423: LD_INT 116
86425: PUSH
86426: LD_INT 117
86428: PUSH
86429: LD_INT 118
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: LIST
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: ST_TO_ADDR
86446: GO 89333
86448: LD_INT 4
86450: DOUBLE
86451: EQUAL
86452: IFTRUE 86456
86454: GO 86552
86456: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
86457: LD_ADDR_VAR 0 1
86461: PUSH
86462: LD_INT 2
86464: PUSH
86465: LD_INT 4
86467: PUSH
86468: LD_INT 5
86470: PUSH
86471: LD_INT 8
86473: PUSH
86474: LD_INT 11
86476: PUSH
86477: LD_INT 12
86479: PUSH
86480: LD_INT 15
86482: PUSH
86483: LD_INT 16
86485: PUSH
86486: LD_INT 22
86488: PUSH
86489: LD_INT 23
86491: PUSH
86492: LD_INT 26
86494: PUSH
86495: LD_INT 36
86497: PUSH
86498: EMPTY
86499: LIST
86500: LIST
86501: LIST
86502: LIST
86503: LIST
86504: LIST
86505: LIST
86506: LIST
86507: LIST
86508: LIST
86509: LIST
86510: LIST
86511: PUSH
86512: LD_INT 101
86514: PUSH
86515: LD_INT 102
86517: PUSH
86518: LD_INT 105
86520: PUSH
86521: LD_INT 106
86523: PUSH
86524: LD_INT 108
86526: PUSH
86527: LD_INT 116
86529: PUSH
86530: LD_INT 117
86532: PUSH
86533: LD_INT 118
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: LIST
86540: LIST
86541: LIST
86542: LIST
86543: LIST
86544: LIST
86545: PUSH
86546: EMPTY
86547: LIST
86548: LIST
86549: ST_TO_ADDR
86550: GO 89333
86552: LD_INT 5
86554: DOUBLE
86555: EQUAL
86556: IFTRUE 86560
86558: GO 86672
86560: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
86561: LD_ADDR_VAR 0 1
86565: PUSH
86566: LD_INT 2
86568: PUSH
86569: LD_INT 4
86571: PUSH
86572: LD_INT 5
86574: PUSH
86575: LD_INT 6
86577: PUSH
86578: LD_INT 8
86580: PUSH
86581: LD_INT 11
86583: PUSH
86584: LD_INT 12
86586: PUSH
86587: LD_INT 15
86589: PUSH
86590: LD_INT 16
86592: PUSH
86593: LD_INT 22
86595: PUSH
86596: LD_INT 23
86598: PUSH
86599: LD_INT 25
86601: PUSH
86602: LD_INT 26
86604: PUSH
86605: LD_INT 36
86607: PUSH
86608: EMPTY
86609: LIST
86610: LIST
86611: LIST
86612: LIST
86613: LIST
86614: LIST
86615: LIST
86616: LIST
86617: LIST
86618: LIST
86619: LIST
86620: LIST
86621: LIST
86622: LIST
86623: PUSH
86624: LD_INT 101
86626: PUSH
86627: LD_INT 102
86629: PUSH
86630: LD_INT 105
86632: PUSH
86633: LD_INT 106
86635: PUSH
86636: LD_INT 108
86638: PUSH
86639: LD_INT 109
86641: PUSH
86642: LD_INT 112
86644: PUSH
86645: LD_INT 116
86647: PUSH
86648: LD_INT 117
86650: PUSH
86651: LD_INT 118
86653: PUSH
86654: EMPTY
86655: LIST
86656: LIST
86657: LIST
86658: LIST
86659: LIST
86660: LIST
86661: LIST
86662: LIST
86663: LIST
86664: LIST
86665: PUSH
86666: EMPTY
86667: LIST
86668: LIST
86669: ST_TO_ADDR
86670: GO 89333
86672: LD_INT 6
86674: DOUBLE
86675: EQUAL
86676: IFTRUE 86680
86678: GO 86812
86680: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
86681: LD_ADDR_VAR 0 1
86685: PUSH
86686: LD_INT 2
86688: PUSH
86689: LD_INT 4
86691: PUSH
86692: LD_INT 5
86694: PUSH
86695: LD_INT 6
86697: PUSH
86698: LD_INT 8
86700: PUSH
86701: LD_INT 11
86703: PUSH
86704: LD_INT 12
86706: PUSH
86707: LD_INT 15
86709: PUSH
86710: LD_INT 16
86712: PUSH
86713: LD_INT 20
86715: PUSH
86716: LD_INT 21
86718: PUSH
86719: LD_INT 22
86721: PUSH
86722: LD_INT 23
86724: PUSH
86725: LD_INT 25
86727: PUSH
86728: LD_INT 26
86730: PUSH
86731: LD_INT 30
86733: PUSH
86734: LD_INT 31
86736: PUSH
86737: LD_INT 32
86739: PUSH
86740: LD_INT 36
86742: PUSH
86743: EMPTY
86744: LIST
86745: LIST
86746: LIST
86747: LIST
86748: LIST
86749: LIST
86750: LIST
86751: LIST
86752: LIST
86753: LIST
86754: LIST
86755: LIST
86756: LIST
86757: LIST
86758: LIST
86759: LIST
86760: LIST
86761: LIST
86762: LIST
86763: PUSH
86764: LD_INT 101
86766: PUSH
86767: LD_INT 102
86769: PUSH
86770: LD_INT 105
86772: PUSH
86773: LD_INT 106
86775: PUSH
86776: LD_INT 108
86778: PUSH
86779: LD_INT 109
86781: PUSH
86782: LD_INT 112
86784: PUSH
86785: LD_INT 116
86787: PUSH
86788: LD_INT 117
86790: PUSH
86791: LD_INT 118
86793: PUSH
86794: EMPTY
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: LIST
86800: LIST
86801: LIST
86802: LIST
86803: LIST
86804: LIST
86805: PUSH
86806: EMPTY
86807: LIST
86808: LIST
86809: ST_TO_ADDR
86810: GO 89333
86812: LD_INT 7
86814: DOUBLE
86815: EQUAL
86816: IFTRUE 86820
86818: GO 86932
86820: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
86821: LD_ADDR_VAR 0 1
86825: PUSH
86826: LD_INT 2
86828: PUSH
86829: LD_INT 4
86831: PUSH
86832: LD_INT 5
86834: PUSH
86835: LD_INT 7
86837: PUSH
86838: LD_INT 11
86840: PUSH
86841: LD_INT 12
86843: PUSH
86844: LD_INT 15
86846: PUSH
86847: LD_INT 16
86849: PUSH
86850: LD_INT 20
86852: PUSH
86853: LD_INT 21
86855: PUSH
86856: LD_INT 22
86858: PUSH
86859: LD_INT 23
86861: PUSH
86862: LD_INT 25
86864: PUSH
86865: LD_INT 26
86867: PUSH
86868: EMPTY
86869: LIST
86870: LIST
86871: LIST
86872: LIST
86873: LIST
86874: LIST
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: PUSH
86884: LD_INT 101
86886: PUSH
86887: LD_INT 102
86889: PUSH
86890: LD_INT 103
86892: PUSH
86893: LD_INT 105
86895: PUSH
86896: LD_INT 106
86898: PUSH
86899: LD_INT 108
86901: PUSH
86902: LD_INT 112
86904: PUSH
86905: LD_INT 116
86907: PUSH
86908: LD_INT 117
86910: PUSH
86911: LD_INT 118
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: LIST
86918: LIST
86919: LIST
86920: LIST
86921: LIST
86922: LIST
86923: LIST
86924: LIST
86925: PUSH
86926: EMPTY
86927: LIST
86928: LIST
86929: ST_TO_ADDR
86930: GO 89333
86932: LD_INT 8
86934: DOUBLE
86935: EQUAL
86936: IFTRUE 86940
86938: GO 87080
86940: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
86941: LD_ADDR_VAR 0 1
86945: PUSH
86946: LD_INT 2
86948: PUSH
86949: LD_INT 4
86951: PUSH
86952: LD_INT 5
86954: PUSH
86955: LD_INT 6
86957: PUSH
86958: LD_INT 7
86960: PUSH
86961: LD_INT 8
86963: PUSH
86964: LD_INT 11
86966: PUSH
86967: LD_INT 12
86969: PUSH
86970: LD_INT 15
86972: PUSH
86973: LD_INT 16
86975: PUSH
86976: LD_INT 20
86978: PUSH
86979: LD_INT 21
86981: PUSH
86982: LD_INT 22
86984: PUSH
86985: LD_INT 23
86987: PUSH
86988: LD_INT 25
86990: PUSH
86991: LD_INT 26
86993: PUSH
86994: LD_INT 30
86996: PUSH
86997: LD_INT 31
86999: PUSH
87000: LD_INT 32
87002: PUSH
87003: LD_INT 36
87005: PUSH
87006: EMPTY
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: LIST
87020: LIST
87021: LIST
87022: LIST
87023: LIST
87024: LIST
87025: LIST
87026: LIST
87027: PUSH
87028: LD_INT 101
87030: PUSH
87031: LD_INT 102
87033: PUSH
87034: LD_INT 103
87036: PUSH
87037: LD_INT 105
87039: PUSH
87040: LD_INT 106
87042: PUSH
87043: LD_INT 108
87045: PUSH
87046: LD_INT 109
87048: PUSH
87049: LD_INT 112
87051: PUSH
87052: LD_INT 116
87054: PUSH
87055: LD_INT 117
87057: PUSH
87058: LD_INT 118
87060: PUSH
87061: EMPTY
87062: LIST
87063: LIST
87064: LIST
87065: LIST
87066: LIST
87067: LIST
87068: LIST
87069: LIST
87070: LIST
87071: LIST
87072: LIST
87073: PUSH
87074: EMPTY
87075: LIST
87076: LIST
87077: ST_TO_ADDR
87078: GO 89333
87080: LD_INT 9
87082: DOUBLE
87083: EQUAL
87084: IFTRUE 87088
87086: GO 87236
87088: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
87089: LD_ADDR_VAR 0 1
87093: PUSH
87094: LD_INT 2
87096: PUSH
87097: LD_INT 4
87099: PUSH
87100: LD_INT 5
87102: PUSH
87103: LD_INT 6
87105: PUSH
87106: LD_INT 7
87108: PUSH
87109: LD_INT 8
87111: PUSH
87112: LD_INT 11
87114: PUSH
87115: LD_INT 12
87117: PUSH
87118: LD_INT 15
87120: PUSH
87121: LD_INT 16
87123: PUSH
87124: LD_INT 20
87126: PUSH
87127: LD_INT 21
87129: PUSH
87130: LD_INT 22
87132: PUSH
87133: LD_INT 23
87135: PUSH
87136: LD_INT 25
87138: PUSH
87139: LD_INT 26
87141: PUSH
87142: LD_INT 28
87144: PUSH
87145: LD_INT 30
87147: PUSH
87148: LD_INT 31
87150: PUSH
87151: LD_INT 32
87153: PUSH
87154: LD_INT 36
87156: PUSH
87157: EMPTY
87158: LIST
87159: LIST
87160: LIST
87161: LIST
87162: LIST
87163: LIST
87164: LIST
87165: LIST
87166: LIST
87167: LIST
87168: LIST
87169: LIST
87170: LIST
87171: LIST
87172: LIST
87173: LIST
87174: LIST
87175: LIST
87176: LIST
87177: LIST
87178: LIST
87179: PUSH
87180: LD_INT 101
87182: PUSH
87183: LD_INT 102
87185: PUSH
87186: LD_INT 103
87188: PUSH
87189: LD_INT 105
87191: PUSH
87192: LD_INT 106
87194: PUSH
87195: LD_INT 108
87197: PUSH
87198: LD_INT 109
87200: PUSH
87201: LD_INT 112
87203: PUSH
87204: LD_INT 114
87206: PUSH
87207: LD_INT 116
87209: PUSH
87210: LD_INT 117
87212: PUSH
87213: LD_INT 118
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: LIST
87220: LIST
87221: LIST
87222: LIST
87223: LIST
87224: LIST
87225: LIST
87226: LIST
87227: LIST
87228: LIST
87229: PUSH
87230: EMPTY
87231: LIST
87232: LIST
87233: ST_TO_ADDR
87234: GO 89333
87236: LD_INT 10
87238: DOUBLE
87239: EQUAL
87240: IFTRUE 87244
87242: GO 87440
87244: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
87245: LD_ADDR_VAR 0 1
87249: PUSH
87250: LD_INT 2
87252: PUSH
87253: LD_INT 4
87255: PUSH
87256: LD_INT 5
87258: PUSH
87259: LD_INT 6
87261: PUSH
87262: LD_INT 7
87264: PUSH
87265: LD_INT 8
87267: PUSH
87268: LD_INT 9
87270: PUSH
87271: LD_INT 10
87273: PUSH
87274: LD_INT 11
87276: PUSH
87277: LD_INT 12
87279: PUSH
87280: LD_INT 13
87282: PUSH
87283: LD_INT 14
87285: PUSH
87286: LD_INT 15
87288: PUSH
87289: LD_INT 16
87291: PUSH
87292: LD_INT 17
87294: PUSH
87295: LD_INT 18
87297: PUSH
87298: LD_INT 19
87300: PUSH
87301: LD_INT 20
87303: PUSH
87304: LD_INT 21
87306: PUSH
87307: LD_INT 22
87309: PUSH
87310: LD_INT 23
87312: PUSH
87313: LD_INT 24
87315: PUSH
87316: LD_INT 25
87318: PUSH
87319: LD_INT 26
87321: PUSH
87322: LD_INT 28
87324: PUSH
87325: LD_INT 30
87327: PUSH
87328: LD_INT 31
87330: PUSH
87331: LD_INT 32
87333: PUSH
87334: LD_INT 36
87336: PUSH
87337: EMPTY
87338: LIST
87339: LIST
87340: LIST
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: LIST
87346: LIST
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: LIST
87361: LIST
87362: LIST
87363: LIST
87364: LIST
87365: LIST
87366: LIST
87367: PUSH
87368: LD_INT 101
87370: PUSH
87371: LD_INT 102
87373: PUSH
87374: LD_INT 103
87376: PUSH
87377: LD_INT 104
87379: PUSH
87380: LD_INT 105
87382: PUSH
87383: LD_INT 106
87385: PUSH
87386: LD_INT 107
87388: PUSH
87389: LD_INT 108
87391: PUSH
87392: LD_INT 109
87394: PUSH
87395: LD_INT 110
87397: PUSH
87398: LD_INT 111
87400: PUSH
87401: LD_INT 112
87403: PUSH
87404: LD_INT 114
87406: PUSH
87407: LD_INT 116
87409: PUSH
87410: LD_INT 117
87412: PUSH
87413: LD_INT 118
87415: PUSH
87416: EMPTY
87417: LIST
87418: LIST
87419: LIST
87420: LIST
87421: LIST
87422: LIST
87423: LIST
87424: LIST
87425: LIST
87426: LIST
87427: LIST
87428: LIST
87429: LIST
87430: LIST
87431: LIST
87432: LIST
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: ST_TO_ADDR
87438: GO 89333
87440: LD_INT 11
87442: DOUBLE
87443: EQUAL
87444: IFTRUE 87448
87446: GO 87652
87448: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
87449: LD_ADDR_VAR 0 1
87453: PUSH
87454: LD_INT 2
87456: PUSH
87457: LD_INT 3
87459: PUSH
87460: LD_INT 4
87462: PUSH
87463: LD_INT 5
87465: PUSH
87466: LD_INT 6
87468: PUSH
87469: LD_INT 7
87471: PUSH
87472: LD_INT 8
87474: PUSH
87475: LD_INT 9
87477: PUSH
87478: LD_INT 10
87480: PUSH
87481: LD_INT 11
87483: PUSH
87484: LD_INT 12
87486: PUSH
87487: LD_INT 13
87489: PUSH
87490: LD_INT 14
87492: PUSH
87493: LD_INT 15
87495: PUSH
87496: LD_INT 16
87498: PUSH
87499: LD_INT 17
87501: PUSH
87502: LD_INT 18
87504: PUSH
87505: LD_INT 19
87507: PUSH
87508: LD_INT 20
87510: PUSH
87511: LD_INT 21
87513: PUSH
87514: LD_INT 22
87516: PUSH
87517: LD_INT 23
87519: PUSH
87520: LD_INT 24
87522: PUSH
87523: LD_INT 25
87525: PUSH
87526: LD_INT 26
87528: PUSH
87529: LD_INT 28
87531: PUSH
87532: LD_INT 30
87534: PUSH
87535: LD_INT 31
87537: PUSH
87538: LD_INT 32
87540: PUSH
87541: LD_INT 34
87543: PUSH
87544: LD_INT 36
87546: PUSH
87547: EMPTY
87548: LIST
87549: LIST
87550: LIST
87551: LIST
87552: LIST
87553: LIST
87554: LIST
87555: LIST
87556: LIST
87557: LIST
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: LIST
87564: LIST
87565: LIST
87566: LIST
87567: LIST
87568: LIST
87569: LIST
87570: LIST
87571: LIST
87572: LIST
87573: LIST
87574: LIST
87575: LIST
87576: LIST
87577: LIST
87578: LIST
87579: PUSH
87580: LD_INT 101
87582: PUSH
87583: LD_INT 102
87585: PUSH
87586: LD_INT 103
87588: PUSH
87589: LD_INT 104
87591: PUSH
87592: LD_INT 105
87594: PUSH
87595: LD_INT 106
87597: PUSH
87598: LD_INT 107
87600: PUSH
87601: LD_INT 108
87603: PUSH
87604: LD_INT 109
87606: PUSH
87607: LD_INT 110
87609: PUSH
87610: LD_INT 111
87612: PUSH
87613: LD_INT 112
87615: PUSH
87616: LD_INT 114
87618: PUSH
87619: LD_INT 116
87621: PUSH
87622: LD_INT 117
87624: PUSH
87625: LD_INT 118
87627: PUSH
87628: EMPTY
87629: LIST
87630: LIST
87631: LIST
87632: LIST
87633: LIST
87634: LIST
87635: LIST
87636: LIST
87637: LIST
87638: LIST
87639: LIST
87640: LIST
87641: LIST
87642: LIST
87643: LIST
87644: LIST
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: ST_TO_ADDR
87650: GO 89333
87652: LD_INT 12
87654: DOUBLE
87655: EQUAL
87656: IFTRUE 87660
87658: GO 87880
87660: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
87661: LD_ADDR_VAR 0 1
87665: PUSH
87666: LD_INT 1
87668: PUSH
87669: LD_INT 2
87671: PUSH
87672: LD_INT 3
87674: PUSH
87675: LD_INT 4
87677: PUSH
87678: LD_INT 5
87680: PUSH
87681: LD_INT 6
87683: PUSH
87684: LD_INT 7
87686: PUSH
87687: LD_INT 8
87689: PUSH
87690: LD_INT 9
87692: PUSH
87693: LD_INT 10
87695: PUSH
87696: LD_INT 11
87698: PUSH
87699: LD_INT 12
87701: PUSH
87702: LD_INT 13
87704: PUSH
87705: LD_INT 14
87707: PUSH
87708: LD_INT 15
87710: PUSH
87711: LD_INT 16
87713: PUSH
87714: LD_INT 17
87716: PUSH
87717: LD_INT 18
87719: PUSH
87720: LD_INT 19
87722: PUSH
87723: LD_INT 20
87725: PUSH
87726: LD_INT 21
87728: PUSH
87729: LD_INT 22
87731: PUSH
87732: LD_INT 23
87734: PUSH
87735: LD_INT 24
87737: PUSH
87738: LD_INT 25
87740: PUSH
87741: LD_INT 26
87743: PUSH
87744: LD_INT 27
87746: PUSH
87747: LD_INT 28
87749: PUSH
87750: LD_INT 30
87752: PUSH
87753: LD_INT 31
87755: PUSH
87756: LD_INT 32
87758: PUSH
87759: LD_INT 33
87761: PUSH
87762: LD_INT 34
87764: PUSH
87765: LD_INT 36
87767: PUSH
87768: EMPTY
87769: LIST
87770: LIST
87771: LIST
87772: LIST
87773: LIST
87774: LIST
87775: LIST
87776: LIST
87777: LIST
87778: LIST
87779: LIST
87780: LIST
87781: LIST
87782: LIST
87783: LIST
87784: LIST
87785: LIST
87786: LIST
87787: LIST
87788: LIST
87789: LIST
87790: LIST
87791: LIST
87792: LIST
87793: LIST
87794: LIST
87795: LIST
87796: LIST
87797: LIST
87798: LIST
87799: LIST
87800: LIST
87801: LIST
87802: LIST
87803: PUSH
87804: LD_INT 101
87806: PUSH
87807: LD_INT 102
87809: PUSH
87810: LD_INT 103
87812: PUSH
87813: LD_INT 104
87815: PUSH
87816: LD_INT 105
87818: PUSH
87819: LD_INT 106
87821: PUSH
87822: LD_INT 107
87824: PUSH
87825: LD_INT 108
87827: PUSH
87828: LD_INT 109
87830: PUSH
87831: LD_INT 110
87833: PUSH
87834: LD_INT 111
87836: PUSH
87837: LD_INT 112
87839: PUSH
87840: LD_INT 113
87842: PUSH
87843: LD_INT 114
87845: PUSH
87846: LD_INT 116
87848: PUSH
87849: LD_INT 117
87851: PUSH
87852: LD_INT 118
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: LIST
87862: LIST
87863: LIST
87864: LIST
87865: LIST
87866: LIST
87867: LIST
87868: LIST
87869: LIST
87870: LIST
87871: LIST
87872: LIST
87873: PUSH
87874: EMPTY
87875: LIST
87876: LIST
87877: ST_TO_ADDR
87878: GO 89333
87880: LD_INT 13
87882: DOUBLE
87883: EQUAL
87884: IFTRUE 87888
87886: GO 88096
87888: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
87889: LD_ADDR_VAR 0 1
87893: PUSH
87894: LD_INT 1
87896: PUSH
87897: LD_INT 2
87899: PUSH
87900: LD_INT 3
87902: PUSH
87903: LD_INT 4
87905: PUSH
87906: LD_INT 5
87908: PUSH
87909: LD_INT 8
87911: PUSH
87912: LD_INT 9
87914: PUSH
87915: LD_INT 10
87917: PUSH
87918: LD_INT 11
87920: PUSH
87921: LD_INT 12
87923: PUSH
87924: LD_INT 14
87926: PUSH
87927: LD_INT 15
87929: PUSH
87930: LD_INT 16
87932: PUSH
87933: LD_INT 17
87935: PUSH
87936: LD_INT 18
87938: PUSH
87939: LD_INT 19
87941: PUSH
87942: LD_INT 20
87944: PUSH
87945: LD_INT 21
87947: PUSH
87948: LD_INT 22
87950: PUSH
87951: LD_INT 23
87953: PUSH
87954: LD_INT 24
87956: PUSH
87957: LD_INT 25
87959: PUSH
87960: LD_INT 26
87962: PUSH
87963: LD_INT 27
87965: PUSH
87966: LD_INT 28
87968: PUSH
87969: LD_INT 30
87971: PUSH
87972: LD_INT 31
87974: PUSH
87975: LD_INT 32
87977: PUSH
87978: LD_INT 33
87980: PUSH
87981: LD_INT 34
87983: PUSH
87984: LD_INT 36
87986: PUSH
87987: EMPTY
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: LIST
87996: LIST
87997: LIST
87998: LIST
87999: LIST
88000: LIST
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: LIST
88011: LIST
88012: LIST
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: PUSH
88020: LD_INT 101
88022: PUSH
88023: LD_INT 102
88025: PUSH
88026: LD_INT 103
88028: PUSH
88029: LD_INT 104
88031: PUSH
88032: LD_INT 105
88034: PUSH
88035: LD_INT 106
88037: PUSH
88038: LD_INT 107
88040: PUSH
88041: LD_INT 108
88043: PUSH
88044: LD_INT 109
88046: PUSH
88047: LD_INT 110
88049: PUSH
88050: LD_INT 111
88052: PUSH
88053: LD_INT 112
88055: PUSH
88056: LD_INT 113
88058: PUSH
88059: LD_INT 114
88061: PUSH
88062: LD_INT 116
88064: PUSH
88065: LD_INT 117
88067: PUSH
88068: LD_INT 118
88070: PUSH
88071: EMPTY
88072: LIST
88073: LIST
88074: LIST
88075: LIST
88076: LIST
88077: LIST
88078: LIST
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: LIST
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: ST_TO_ADDR
88094: GO 89333
88096: LD_INT 14
88098: DOUBLE
88099: EQUAL
88100: IFTRUE 88104
88102: GO 88328
88104: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
88105: LD_ADDR_VAR 0 1
88109: PUSH
88110: LD_INT 1
88112: PUSH
88113: LD_INT 2
88115: PUSH
88116: LD_INT 3
88118: PUSH
88119: LD_INT 4
88121: PUSH
88122: LD_INT 5
88124: PUSH
88125: LD_INT 6
88127: PUSH
88128: LD_INT 7
88130: PUSH
88131: LD_INT 8
88133: PUSH
88134: LD_INT 9
88136: PUSH
88137: LD_INT 10
88139: PUSH
88140: LD_INT 11
88142: PUSH
88143: LD_INT 12
88145: PUSH
88146: LD_INT 13
88148: PUSH
88149: LD_INT 14
88151: PUSH
88152: LD_INT 15
88154: PUSH
88155: LD_INT 16
88157: PUSH
88158: LD_INT 17
88160: PUSH
88161: LD_INT 18
88163: PUSH
88164: LD_INT 19
88166: PUSH
88167: LD_INT 20
88169: PUSH
88170: LD_INT 21
88172: PUSH
88173: LD_INT 22
88175: PUSH
88176: LD_INT 23
88178: PUSH
88179: LD_INT 24
88181: PUSH
88182: LD_INT 25
88184: PUSH
88185: LD_INT 26
88187: PUSH
88188: LD_INT 27
88190: PUSH
88191: LD_INT 28
88193: PUSH
88194: LD_INT 29
88196: PUSH
88197: LD_INT 30
88199: PUSH
88200: LD_INT 31
88202: PUSH
88203: LD_INT 32
88205: PUSH
88206: LD_INT 33
88208: PUSH
88209: LD_INT 34
88211: PUSH
88212: LD_INT 36
88214: PUSH
88215: EMPTY
88216: LIST
88217: LIST
88218: LIST
88219: LIST
88220: LIST
88221: LIST
88222: LIST
88223: LIST
88224: LIST
88225: LIST
88226: LIST
88227: LIST
88228: LIST
88229: LIST
88230: LIST
88231: LIST
88232: LIST
88233: LIST
88234: LIST
88235: LIST
88236: LIST
88237: LIST
88238: LIST
88239: LIST
88240: LIST
88241: LIST
88242: LIST
88243: LIST
88244: LIST
88245: LIST
88246: LIST
88247: LIST
88248: LIST
88249: LIST
88250: LIST
88251: PUSH
88252: LD_INT 101
88254: PUSH
88255: LD_INT 102
88257: PUSH
88258: LD_INT 103
88260: PUSH
88261: LD_INT 104
88263: PUSH
88264: LD_INT 105
88266: PUSH
88267: LD_INT 106
88269: PUSH
88270: LD_INT 107
88272: PUSH
88273: LD_INT 108
88275: PUSH
88276: LD_INT 109
88278: PUSH
88279: LD_INT 110
88281: PUSH
88282: LD_INT 111
88284: PUSH
88285: LD_INT 112
88287: PUSH
88288: LD_INT 113
88290: PUSH
88291: LD_INT 114
88293: PUSH
88294: LD_INT 116
88296: PUSH
88297: LD_INT 117
88299: PUSH
88300: LD_INT 118
88302: PUSH
88303: EMPTY
88304: LIST
88305: LIST
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: LIST
88313: LIST
88314: LIST
88315: LIST
88316: LIST
88317: LIST
88318: LIST
88319: LIST
88320: LIST
88321: PUSH
88322: EMPTY
88323: LIST
88324: LIST
88325: ST_TO_ADDR
88326: GO 89333
88328: LD_INT 15
88330: DOUBLE
88331: EQUAL
88332: IFTRUE 88336
88334: GO 88560
88336: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
88337: LD_ADDR_VAR 0 1
88341: PUSH
88342: LD_INT 1
88344: PUSH
88345: LD_INT 2
88347: PUSH
88348: LD_INT 3
88350: PUSH
88351: LD_INT 4
88353: PUSH
88354: LD_INT 5
88356: PUSH
88357: LD_INT 6
88359: PUSH
88360: LD_INT 7
88362: PUSH
88363: LD_INT 8
88365: PUSH
88366: LD_INT 9
88368: PUSH
88369: LD_INT 10
88371: PUSH
88372: LD_INT 11
88374: PUSH
88375: LD_INT 12
88377: PUSH
88378: LD_INT 13
88380: PUSH
88381: LD_INT 14
88383: PUSH
88384: LD_INT 15
88386: PUSH
88387: LD_INT 16
88389: PUSH
88390: LD_INT 17
88392: PUSH
88393: LD_INT 18
88395: PUSH
88396: LD_INT 19
88398: PUSH
88399: LD_INT 20
88401: PUSH
88402: LD_INT 21
88404: PUSH
88405: LD_INT 22
88407: PUSH
88408: LD_INT 23
88410: PUSH
88411: LD_INT 24
88413: PUSH
88414: LD_INT 25
88416: PUSH
88417: LD_INT 26
88419: PUSH
88420: LD_INT 27
88422: PUSH
88423: LD_INT 28
88425: PUSH
88426: LD_INT 29
88428: PUSH
88429: LD_INT 30
88431: PUSH
88432: LD_INT 31
88434: PUSH
88435: LD_INT 32
88437: PUSH
88438: LD_INT 33
88440: PUSH
88441: LD_INT 34
88443: PUSH
88444: LD_INT 36
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: LIST
88454: LIST
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: LIST
88466: LIST
88467: LIST
88468: LIST
88469: LIST
88470: LIST
88471: LIST
88472: LIST
88473: LIST
88474: LIST
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: LIST
88480: LIST
88481: LIST
88482: LIST
88483: PUSH
88484: LD_INT 101
88486: PUSH
88487: LD_INT 102
88489: PUSH
88490: LD_INT 103
88492: PUSH
88493: LD_INT 104
88495: PUSH
88496: LD_INT 105
88498: PUSH
88499: LD_INT 106
88501: PUSH
88502: LD_INT 107
88504: PUSH
88505: LD_INT 108
88507: PUSH
88508: LD_INT 109
88510: PUSH
88511: LD_INT 110
88513: PUSH
88514: LD_INT 111
88516: PUSH
88517: LD_INT 112
88519: PUSH
88520: LD_INT 113
88522: PUSH
88523: LD_INT 114
88525: PUSH
88526: LD_INT 116
88528: PUSH
88529: LD_INT 117
88531: PUSH
88532: LD_INT 118
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: LIST
88539: LIST
88540: LIST
88541: LIST
88542: LIST
88543: LIST
88544: LIST
88545: LIST
88546: LIST
88547: LIST
88548: LIST
88549: LIST
88550: LIST
88551: LIST
88552: LIST
88553: PUSH
88554: EMPTY
88555: LIST
88556: LIST
88557: ST_TO_ADDR
88558: GO 89333
88560: LD_INT 16
88562: DOUBLE
88563: EQUAL
88564: IFTRUE 88568
88566: GO 88704
88568: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
88569: LD_ADDR_VAR 0 1
88573: PUSH
88574: LD_INT 2
88576: PUSH
88577: LD_INT 4
88579: PUSH
88580: LD_INT 5
88582: PUSH
88583: LD_INT 7
88585: PUSH
88586: LD_INT 11
88588: PUSH
88589: LD_INT 12
88591: PUSH
88592: LD_INT 15
88594: PUSH
88595: LD_INT 16
88597: PUSH
88598: LD_INT 20
88600: PUSH
88601: LD_INT 21
88603: PUSH
88604: LD_INT 22
88606: PUSH
88607: LD_INT 23
88609: PUSH
88610: LD_INT 25
88612: PUSH
88613: LD_INT 26
88615: PUSH
88616: LD_INT 30
88618: PUSH
88619: LD_INT 31
88621: PUSH
88622: LD_INT 32
88624: PUSH
88625: LD_INT 33
88627: PUSH
88628: LD_INT 34
88630: PUSH
88631: EMPTY
88632: LIST
88633: LIST
88634: LIST
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: LIST
88651: PUSH
88652: LD_INT 101
88654: PUSH
88655: LD_INT 102
88657: PUSH
88658: LD_INT 103
88660: PUSH
88661: LD_INT 106
88663: PUSH
88664: LD_INT 108
88666: PUSH
88667: LD_INT 112
88669: PUSH
88670: LD_INT 113
88672: PUSH
88673: LD_INT 114
88675: PUSH
88676: LD_INT 116
88678: PUSH
88679: LD_INT 117
88681: PUSH
88682: LD_INT 118
88684: PUSH
88685: EMPTY
88686: LIST
88687: LIST
88688: LIST
88689: LIST
88690: LIST
88691: LIST
88692: LIST
88693: LIST
88694: LIST
88695: LIST
88696: LIST
88697: PUSH
88698: EMPTY
88699: LIST
88700: LIST
88701: ST_TO_ADDR
88702: GO 89333
88704: LD_INT 17
88706: DOUBLE
88707: EQUAL
88708: IFTRUE 88712
88710: GO 88936
88712: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
88713: LD_ADDR_VAR 0 1
88717: PUSH
88718: LD_INT 1
88720: PUSH
88721: LD_INT 2
88723: PUSH
88724: LD_INT 3
88726: PUSH
88727: LD_INT 4
88729: PUSH
88730: LD_INT 5
88732: PUSH
88733: LD_INT 6
88735: PUSH
88736: LD_INT 7
88738: PUSH
88739: LD_INT 8
88741: PUSH
88742: LD_INT 9
88744: PUSH
88745: LD_INT 10
88747: PUSH
88748: LD_INT 11
88750: PUSH
88751: LD_INT 12
88753: PUSH
88754: LD_INT 13
88756: PUSH
88757: LD_INT 14
88759: PUSH
88760: LD_INT 15
88762: PUSH
88763: LD_INT 16
88765: PUSH
88766: LD_INT 17
88768: PUSH
88769: LD_INT 18
88771: PUSH
88772: LD_INT 19
88774: PUSH
88775: LD_INT 20
88777: PUSH
88778: LD_INT 21
88780: PUSH
88781: LD_INT 22
88783: PUSH
88784: LD_INT 23
88786: PUSH
88787: LD_INT 24
88789: PUSH
88790: LD_INT 25
88792: PUSH
88793: LD_INT 26
88795: PUSH
88796: LD_INT 27
88798: PUSH
88799: LD_INT 28
88801: PUSH
88802: LD_INT 29
88804: PUSH
88805: LD_INT 30
88807: PUSH
88808: LD_INT 31
88810: PUSH
88811: LD_INT 32
88813: PUSH
88814: LD_INT 33
88816: PUSH
88817: LD_INT 34
88819: PUSH
88820: LD_INT 36
88822: PUSH
88823: EMPTY
88824: LIST
88825: LIST
88826: LIST
88827: LIST
88828: LIST
88829: LIST
88830: LIST
88831: LIST
88832: LIST
88833: LIST
88834: LIST
88835: LIST
88836: LIST
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: PUSH
88860: LD_INT 101
88862: PUSH
88863: LD_INT 102
88865: PUSH
88866: LD_INT 103
88868: PUSH
88869: LD_INT 104
88871: PUSH
88872: LD_INT 105
88874: PUSH
88875: LD_INT 106
88877: PUSH
88878: LD_INT 107
88880: PUSH
88881: LD_INT 108
88883: PUSH
88884: LD_INT 109
88886: PUSH
88887: LD_INT 110
88889: PUSH
88890: LD_INT 111
88892: PUSH
88893: LD_INT 112
88895: PUSH
88896: LD_INT 113
88898: PUSH
88899: LD_INT 114
88901: PUSH
88902: LD_INT 116
88904: PUSH
88905: LD_INT 117
88907: PUSH
88908: LD_INT 118
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: LIST
88915: LIST
88916: LIST
88917: LIST
88918: LIST
88919: LIST
88920: LIST
88921: LIST
88922: LIST
88923: LIST
88924: LIST
88925: LIST
88926: LIST
88927: LIST
88928: LIST
88929: PUSH
88930: EMPTY
88931: LIST
88932: LIST
88933: ST_TO_ADDR
88934: GO 89333
88936: LD_INT 18
88938: DOUBLE
88939: EQUAL
88940: IFTRUE 88944
88942: GO 89092
88944: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
88945: LD_ADDR_VAR 0 1
88949: PUSH
88950: LD_INT 2
88952: PUSH
88953: LD_INT 4
88955: PUSH
88956: LD_INT 5
88958: PUSH
88959: LD_INT 7
88961: PUSH
88962: LD_INT 11
88964: PUSH
88965: LD_INT 12
88967: PUSH
88968: LD_INT 15
88970: PUSH
88971: LD_INT 16
88973: PUSH
88974: LD_INT 20
88976: PUSH
88977: LD_INT 21
88979: PUSH
88980: LD_INT 22
88982: PUSH
88983: LD_INT 23
88985: PUSH
88986: LD_INT 25
88988: PUSH
88989: LD_INT 26
88991: PUSH
88992: LD_INT 30
88994: PUSH
88995: LD_INT 31
88997: PUSH
88998: LD_INT 32
89000: PUSH
89001: LD_INT 33
89003: PUSH
89004: LD_INT 34
89006: PUSH
89007: LD_INT 35
89009: PUSH
89010: LD_INT 36
89012: PUSH
89013: EMPTY
89014: LIST
89015: LIST
89016: LIST
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: LIST
89027: LIST
89028: LIST
89029: LIST
89030: LIST
89031: LIST
89032: LIST
89033: LIST
89034: LIST
89035: PUSH
89036: LD_INT 101
89038: PUSH
89039: LD_INT 102
89041: PUSH
89042: LD_INT 103
89044: PUSH
89045: LD_INT 106
89047: PUSH
89048: LD_INT 108
89050: PUSH
89051: LD_INT 112
89053: PUSH
89054: LD_INT 113
89056: PUSH
89057: LD_INT 114
89059: PUSH
89060: LD_INT 115
89062: PUSH
89063: LD_INT 116
89065: PUSH
89066: LD_INT 117
89068: PUSH
89069: LD_INT 118
89071: PUSH
89072: EMPTY
89073: LIST
89074: LIST
89075: LIST
89076: LIST
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: LIST
89083: LIST
89084: LIST
89085: PUSH
89086: EMPTY
89087: LIST
89088: LIST
89089: ST_TO_ADDR
89090: GO 89333
89092: LD_INT 19
89094: DOUBLE
89095: EQUAL
89096: IFTRUE 89100
89098: GO 89332
89100: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
89101: LD_ADDR_VAR 0 1
89105: PUSH
89106: LD_INT 1
89108: PUSH
89109: LD_INT 2
89111: PUSH
89112: LD_INT 3
89114: PUSH
89115: LD_INT 4
89117: PUSH
89118: LD_INT 5
89120: PUSH
89121: LD_INT 6
89123: PUSH
89124: LD_INT 7
89126: PUSH
89127: LD_INT 8
89129: PUSH
89130: LD_INT 9
89132: PUSH
89133: LD_INT 10
89135: PUSH
89136: LD_INT 11
89138: PUSH
89139: LD_INT 12
89141: PUSH
89142: LD_INT 13
89144: PUSH
89145: LD_INT 14
89147: PUSH
89148: LD_INT 15
89150: PUSH
89151: LD_INT 16
89153: PUSH
89154: LD_INT 17
89156: PUSH
89157: LD_INT 18
89159: PUSH
89160: LD_INT 19
89162: PUSH
89163: LD_INT 20
89165: PUSH
89166: LD_INT 21
89168: PUSH
89169: LD_INT 22
89171: PUSH
89172: LD_INT 23
89174: PUSH
89175: LD_INT 24
89177: PUSH
89178: LD_INT 25
89180: PUSH
89181: LD_INT 26
89183: PUSH
89184: LD_INT 27
89186: PUSH
89187: LD_INT 28
89189: PUSH
89190: LD_INT 29
89192: PUSH
89193: LD_INT 30
89195: PUSH
89196: LD_INT 31
89198: PUSH
89199: LD_INT 32
89201: PUSH
89202: LD_INT 33
89204: PUSH
89205: LD_INT 34
89207: PUSH
89208: LD_INT 35
89210: PUSH
89211: LD_INT 36
89213: PUSH
89214: EMPTY
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: LIST
89229: LIST
89230: LIST
89231: LIST
89232: LIST
89233: LIST
89234: LIST
89235: LIST
89236: LIST
89237: LIST
89238: LIST
89239: LIST
89240: LIST
89241: LIST
89242: LIST
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: PUSH
89252: LD_INT 101
89254: PUSH
89255: LD_INT 102
89257: PUSH
89258: LD_INT 103
89260: PUSH
89261: LD_INT 104
89263: PUSH
89264: LD_INT 105
89266: PUSH
89267: LD_INT 106
89269: PUSH
89270: LD_INT 107
89272: PUSH
89273: LD_INT 108
89275: PUSH
89276: LD_INT 109
89278: PUSH
89279: LD_INT 110
89281: PUSH
89282: LD_INT 111
89284: PUSH
89285: LD_INT 112
89287: PUSH
89288: LD_INT 113
89290: PUSH
89291: LD_INT 114
89293: PUSH
89294: LD_INT 115
89296: PUSH
89297: LD_INT 116
89299: PUSH
89300: LD_INT 117
89302: PUSH
89303: LD_INT 118
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: LIST
89310: LIST
89311: LIST
89312: LIST
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: LIST
89320: LIST
89321: LIST
89322: LIST
89323: LIST
89324: LIST
89325: PUSH
89326: EMPTY
89327: LIST
89328: LIST
89329: ST_TO_ADDR
89330: GO 89333
89332: POP
// end else
89333: GO 89564
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
89335: LD_ADDR_VAR 0 1
89339: PUSH
89340: LD_INT 1
89342: PUSH
89343: LD_INT 2
89345: PUSH
89346: LD_INT 3
89348: PUSH
89349: LD_INT 4
89351: PUSH
89352: LD_INT 5
89354: PUSH
89355: LD_INT 6
89357: PUSH
89358: LD_INT 7
89360: PUSH
89361: LD_INT 8
89363: PUSH
89364: LD_INT 9
89366: PUSH
89367: LD_INT 10
89369: PUSH
89370: LD_INT 11
89372: PUSH
89373: LD_INT 12
89375: PUSH
89376: LD_INT 13
89378: PUSH
89379: LD_INT 14
89381: PUSH
89382: LD_INT 15
89384: PUSH
89385: LD_INT 16
89387: PUSH
89388: LD_INT 17
89390: PUSH
89391: LD_INT 18
89393: PUSH
89394: LD_INT 19
89396: PUSH
89397: LD_INT 20
89399: PUSH
89400: LD_INT 21
89402: PUSH
89403: LD_INT 22
89405: PUSH
89406: LD_INT 23
89408: PUSH
89409: LD_INT 24
89411: PUSH
89412: LD_INT 25
89414: PUSH
89415: LD_INT 26
89417: PUSH
89418: LD_INT 27
89420: PUSH
89421: LD_INT 28
89423: PUSH
89424: LD_INT 29
89426: PUSH
89427: LD_INT 30
89429: PUSH
89430: LD_INT 31
89432: PUSH
89433: LD_INT 32
89435: PUSH
89436: LD_INT 33
89438: PUSH
89439: LD_INT 34
89441: PUSH
89442: LD_INT 35
89444: PUSH
89445: LD_INT 36
89447: PUSH
89448: EMPTY
89449: LIST
89450: LIST
89451: LIST
89452: LIST
89453: LIST
89454: LIST
89455: LIST
89456: LIST
89457: LIST
89458: LIST
89459: LIST
89460: LIST
89461: LIST
89462: LIST
89463: LIST
89464: LIST
89465: LIST
89466: LIST
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: LIST
89472: LIST
89473: LIST
89474: LIST
89475: LIST
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: LIST
89484: LIST
89485: PUSH
89486: LD_INT 101
89488: PUSH
89489: LD_INT 102
89491: PUSH
89492: LD_INT 103
89494: PUSH
89495: LD_INT 104
89497: PUSH
89498: LD_INT 105
89500: PUSH
89501: LD_INT 106
89503: PUSH
89504: LD_INT 107
89506: PUSH
89507: LD_INT 108
89509: PUSH
89510: LD_INT 109
89512: PUSH
89513: LD_INT 110
89515: PUSH
89516: LD_INT 111
89518: PUSH
89519: LD_INT 112
89521: PUSH
89522: LD_INT 113
89524: PUSH
89525: LD_INT 114
89527: PUSH
89528: LD_INT 115
89530: PUSH
89531: LD_INT 116
89533: PUSH
89534: LD_INT 117
89536: PUSH
89537: LD_INT 118
89539: PUSH
89540: EMPTY
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: PUSH
89560: EMPTY
89561: LIST
89562: LIST
89563: ST_TO_ADDR
// if result then
89564: LD_VAR 0 1
89568: IFFALSE 89857
// begin normal :=  ;
89570: LD_ADDR_VAR 0 3
89574: PUSH
89575: LD_STRING 
89577: ST_TO_ADDR
// hardcore :=  ;
89578: LD_ADDR_VAR 0 4
89582: PUSH
89583: LD_STRING 
89585: ST_TO_ADDR
// for i = 1 to normalCounter do
89586: LD_ADDR_VAR 0 5
89590: PUSH
89591: DOUBLE
89592: LD_INT 1
89594: DEC
89595: ST_TO_ADDR
89596: LD_EXP 114
89600: PUSH
89601: FOR_TO
89602: IFFALSE 89703
// begin tmp := 0 ;
89604: LD_ADDR_VAR 0 2
89608: PUSH
89609: LD_STRING 0
89611: ST_TO_ADDR
// if result [ 1 ] then
89612: LD_VAR 0 1
89616: PUSH
89617: LD_INT 1
89619: ARRAY
89620: IFFALSE 89685
// if result [ 1 ] [ 1 ] = i then
89622: LD_VAR 0 1
89626: PUSH
89627: LD_INT 1
89629: ARRAY
89630: PUSH
89631: LD_INT 1
89633: ARRAY
89634: PUSH
89635: LD_VAR 0 5
89639: EQUAL
89640: IFFALSE 89685
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
89642: LD_ADDR_VAR 0 1
89646: PUSH
89647: LD_VAR 0 1
89651: PPUSH
89652: LD_INT 1
89654: PPUSH
89655: LD_VAR 0 1
89659: PUSH
89660: LD_INT 1
89662: ARRAY
89663: PPUSH
89664: LD_INT 1
89666: PPUSH
89667: CALL_OW 3
89671: PPUSH
89672: CALL_OW 1
89676: ST_TO_ADDR
// tmp := 1 ;
89677: LD_ADDR_VAR 0 2
89681: PUSH
89682: LD_STRING 1
89684: ST_TO_ADDR
// end ; normal := normal & tmp ;
89685: LD_ADDR_VAR 0 3
89689: PUSH
89690: LD_VAR 0 3
89694: PUSH
89695: LD_VAR 0 2
89699: STR
89700: ST_TO_ADDR
// end ;
89701: GO 89601
89703: POP
89704: POP
// for i = 1 to hardcoreCounter do
89705: LD_ADDR_VAR 0 5
89709: PUSH
89710: DOUBLE
89711: LD_INT 1
89713: DEC
89714: ST_TO_ADDR
89715: LD_EXP 115
89719: PUSH
89720: FOR_TO
89721: IFFALSE 89826
// begin tmp := 0 ;
89723: LD_ADDR_VAR 0 2
89727: PUSH
89728: LD_STRING 0
89730: ST_TO_ADDR
// if result [ 2 ] then
89731: LD_VAR 0 1
89735: PUSH
89736: LD_INT 2
89738: ARRAY
89739: IFFALSE 89808
// if result [ 2 ] [ 1 ] = 100 + i then
89741: LD_VAR 0 1
89745: PUSH
89746: LD_INT 2
89748: ARRAY
89749: PUSH
89750: LD_INT 1
89752: ARRAY
89753: PUSH
89754: LD_INT 100
89756: PUSH
89757: LD_VAR 0 5
89761: PLUS
89762: EQUAL
89763: IFFALSE 89808
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
89765: LD_ADDR_VAR 0 1
89769: PUSH
89770: LD_VAR 0 1
89774: PPUSH
89775: LD_INT 2
89777: PPUSH
89778: LD_VAR 0 1
89782: PUSH
89783: LD_INT 2
89785: ARRAY
89786: PPUSH
89787: LD_INT 1
89789: PPUSH
89790: CALL_OW 3
89794: PPUSH
89795: CALL_OW 1
89799: ST_TO_ADDR
// tmp := 1 ;
89800: LD_ADDR_VAR 0 2
89804: PUSH
89805: LD_STRING 1
89807: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
89808: LD_ADDR_VAR 0 4
89812: PUSH
89813: LD_VAR 0 4
89817: PUSH
89818: LD_VAR 0 2
89822: STR
89823: ST_TO_ADDR
// end ;
89824: GO 89720
89826: POP
89827: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
89828: LD_STRING getStreamItemsFromMission("
89830: PUSH
89831: LD_VAR 0 3
89835: STR
89836: PUSH
89837: LD_STRING ","
89839: STR
89840: PUSH
89841: LD_VAR 0 4
89845: STR
89846: PUSH
89847: LD_STRING ")
89849: STR
89850: PPUSH
89851: CALL_OW 559
// end else
89855: GO 89864
// ToLua ( getStreamItemsFromMission("","") ) ;
89857: LD_STRING getStreamItemsFromMission("","")
89859: PPUSH
89860: CALL_OW 559
// end ;
89864: LD_VAR 0 1
89868: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
89869: LD_EXP 113
89873: PUSH
89874: LD_EXP 118
89878: AND
89879: IFFALSE 90003
89881: GO 89883
89883: DISABLE
89884: LD_INT 0
89886: PPUSH
89887: PPUSH
// begin enable ;
89888: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
89889: LD_ADDR_VAR 0 2
89893: PUSH
89894: LD_INT 22
89896: PUSH
89897: LD_OWVAR 2
89901: PUSH
89902: EMPTY
89903: LIST
89904: LIST
89905: PUSH
89906: LD_INT 2
89908: PUSH
89909: LD_INT 34
89911: PUSH
89912: LD_INT 7
89914: PUSH
89915: EMPTY
89916: LIST
89917: LIST
89918: PUSH
89919: LD_INT 34
89921: PUSH
89922: LD_INT 45
89924: PUSH
89925: EMPTY
89926: LIST
89927: LIST
89928: PUSH
89929: LD_INT 34
89931: PUSH
89932: LD_INT 28
89934: PUSH
89935: EMPTY
89936: LIST
89937: LIST
89938: PUSH
89939: LD_INT 34
89941: PUSH
89942: LD_INT 47
89944: PUSH
89945: EMPTY
89946: LIST
89947: LIST
89948: PUSH
89949: EMPTY
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: PUSH
89956: EMPTY
89957: LIST
89958: LIST
89959: PPUSH
89960: CALL_OW 69
89964: ST_TO_ADDR
// if not tmp then
89965: LD_VAR 0 2
89969: NOT
89970: IFFALSE 89974
// exit ;
89972: GO 90003
// for i in tmp do
89974: LD_ADDR_VAR 0 1
89978: PUSH
89979: LD_VAR 0 2
89983: PUSH
89984: FOR_IN
89985: IFFALSE 90001
// begin SetLives ( i , 0 ) ;
89987: LD_VAR 0 1
89991: PPUSH
89992: LD_INT 0
89994: PPUSH
89995: CALL_OW 234
// end ;
89999: GO 89984
90001: POP
90002: POP
// end ;
90003: PPOPN 2
90005: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
90006: LD_EXP 113
90010: PUSH
90011: LD_EXP 119
90015: AND
90016: IFFALSE 90100
90018: GO 90020
90020: DISABLE
90021: LD_INT 0
90023: PPUSH
90024: PPUSH
// begin enable ;
90025: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
90026: LD_ADDR_VAR 0 2
90030: PUSH
90031: LD_INT 22
90033: PUSH
90034: LD_OWVAR 2
90038: PUSH
90039: EMPTY
90040: LIST
90041: LIST
90042: PUSH
90043: LD_INT 32
90045: PUSH
90046: LD_INT 3
90048: PUSH
90049: EMPTY
90050: LIST
90051: LIST
90052: PUSH
90053: EMPTY
90054: LIST
90055: LIST
90056: PPUSH
90057: CALL_OW 69
90061: ST_TO_ADDR
// if not tmp then
90062: LD_VAR 0 2
90066: NOT
90067: IFFALSE 90071
// exit ;
90069: GO 90100
// for i in tmp do
90071: LD_ADDR_VAR 0 1
90075: PUSH
90076: LD_VAR 0 2
90080: PUSH
90081: FOR_IN
90082: IFFALSE 90098
// begin SetLives ( i , 0 ) ;
90084: LD_VAR 0 1
90088: PPUSH
90089: LD_INT 0
90091: PPUSH
90092: CALL_OW 234
// end ;
90096: GO 90081
90098: POP
90099: POP
// end ;
90100: PPOPN 2
90102: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
90103: LD_EXP 113
90107: PUSH
90108: LD_EXP 116
90112: AND
90113: IFFALSE 90206
90115: GO 90117
90117: DISABLE
90118: LD_INT 0
90120: PPUSH
// begin enable ;
90121: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
90122: LD_ADDR_VAR 0 1
90126: PUSH
90127: LD_INT 22
90129: PUSH
90130: LD_OWVAR 2
90134: PUSH
90135: EMPTY
90136: LIST
90137: LIST
90138: PUSH
90139: LD_INT 2
90141: PUSH
90142: LD_INT 25
90144: PUSH
90145: LD_INT 5
90147: PUSH
90148: EMPTY
90149: LIST
90150: LIST
90151: PUSH
90152: LD_INT 25
90154: PUSH
90155: LD_INT 9
90157: PUSH
90158: EMPTY
90159: LIST
90160: LIST
90161: PUSH
90162: LD_INT 25
90164: PUSH
90165: LD_INT 8
90167: PUSH
90168: EMPTY
90169: LIST
90170: LIST
90171: PUSH
90172: EMPTY
90173: LIST
90174: LIST
90175: LIST
90176: LIST
90177: PUSH
90178: EMPTY
90179: LIST
90180: LIST
90181: PPUSH
90182: CALL_OW 69
90186: PUSH
90187: FOR_IN
90188: IFFALSE 90204
// begin SetClass ( i , 1 ) ;
90190: LD_VAR 0 1
90194: PPUSH
90195: LD_INT 1
90197: PPUSH
90198: CALL_OW 336
// end ;
90202: GO 90187
90204: POP
90205: POP
// end ;
90206: PPOPN 1
90208: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
90209: LD_EXP 113
90213: PUSH
90214: LD_EXP 117
90218: AND
90219: PUSH
90220: LD_OWVAR 65
90224: PUSH
90225: LD_INT 7
90227: LESS
90228: AND
90229: IFFALSE 90243
90231: GO 90233
90233: DISABLE
// begin enable ;
90234: ENABLE
// game_speed := 7 ;
90235: LD_ADDR_OWVAR 65
90239: PUSH
90240: LD_INT 7
90242: ST_TO_ADDR
// end ;
90243: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
90244: LD_EXP 113
90248: PUSH
90249: LD_EXP 120
90253: AND
90254: IFFALSE 90456
90256: GO 90258
90258: DISABLE
90259: LD_INT 0
90261: PPUSH
90262: PPUSH
90263: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
90264: LD_ADDR_VAR 0 3
90268: PUSH
90269: LD_INT 81
90271: PUSH
90272: LD_OWVAR 2
90276: PUSH
90277: EMPTY
90278: LIST
90279: LIST
90280: PUSH
90281: LD_INT 21
90283: PUSH
90284: LD_INT 1
90286: PUSH
90287: EMPTY
90288: LIST
90289: LIST
90290: PUSH
90291: EMPTY
90292: LIST
90293: LIST
90294: PPUSH
90295: CALL_OW 69
90299: ST_TO_ADDR
// if not tmp then
90300: LD_VAR 0 3
90304: NOT
90305: IFFALSE 90309
// exit ;
90307: GO 90456
// if tmp > 5 then
90309: LD_VAR 0 3
90313: PUSH
90314: LD_INT 5
90316: GREATER
90317: IFFALSE 90329
// k := 5 else
90319: LD_ADDR_VAR 0 2
90323: PUSH
90324: LD_INT 5
90326: ST_TO_ADDR
90327: GO 90339
// k := tmp ;
90329: LD_ADDR_VAR 0 2
90333: PUSH
90334: LD_VAR 0 3
90338: ST_TO_ADDR
// for i := 1 to k do
90339: LD_ADDR_VAR 0 1
90343: PUSH
90344: DOUBLE
90345: LD_INT 1
90347: DEC
90348: ST_TO_ADDR
90349: LD_VAR 0 2
90353: PUSH
90354: FOR_TO
90355: IFFALSE 90454
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
90357: LD_VAR 0 3
90361: PUSH
90362: LD_VAR 0 1
90366: ARRAY
90367: PPUSH
90368: LD_VAR 0 1
90372: PUSH
90373: LD_INT 4
90375: MOD
90376: PUSH
90377: LD_INT 1
90379: PLUS
90380: PPUSH
90381: CALL_OW 259
90385: PUSH
90386: LD_INT 10
90388: LESS
90389: IFFALSE 90452
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
90391: LD_VAR 0 3
90395: PUSH
90396: LD_VAR 0 1
90400: ARRAY
90401: PPUSH
90402: LD_VAR 0 1
90406: PUSH
90407: LD_INT 4
90409: MOD
90410: PUSH
90411: LD_INT 1
90413: PLUS
90414: PPUSH
90415: LD_VAR 0 3
90419: PUSH
90420: LD_VAR 0 1
90424: ARRAY
90425: PPUSH
90426: LD_VAR 0 1
90430: PUSH
90431: LD_INT 4
90433: MOD
90434: PUSH
90435: LD_INT 1
90437: PLUS
90438: PPUSH
90439: CALL_OW 259
90443: PUSH
90444: LD_INT 1
90446: PLUS
90447: PPUSH
90448: CALL_OW 237
90452: GO 90354
90454: POP
90455: POP
// end ;
90456: PPOPN 3
90458: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
90459: LD_EXP 113
90463: PUSH
90464: LD_EXP 121
90468: AND
90469: IFFALSE 90489
90471: GO 90473
90473: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
90474: LD_INT 4
90476: PPUSH
90477: LD_OWVAR 2
90481: PPUSH
90482: LD_INT 0
90484: PPUSH
90485: CALL_OW 324
90489: END
// every 0 0$1 trigger StreamModeActive and sShovel do
90490: LD_EXP 113
90494: PUSH
90495: LD_EXP 150
90499: AND
90500: IFFALSE 90520
90502: GO 90504
90504: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
90505: LD_INT 19
90507: PPUSH
90508: LD_OWVAR 2
90512: PPUSH
90513: LD_INT 0
90515: PPUSH
90516: CALL_OW 324
90520: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
90521: LD_EXP 113
90525: PUSH
90526: LD_EXP 122
90530: AND
90531: IFFALSE 90633
90533: GO 90535
90535: DISABLE
90536: LD_INT 0
90538: PPUSH
90539: PPUSH
// begin enable ;
90540: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
90541: LD_ADDR_VAR 0 2
90545: PUSH
90546: LD_INT 22
90548: PUSH
90549: LD_OWVAR 2
90553: PUSH
90554: EMPTY
90555: LIST
90556: LIST
90557: PUSH
90558: LD_INT 2
90560: PUSH
90561: LD_INT 34
90563: PUSH
90564: LD_INT 11
90566: PUSH
90567: EMPTY
90568: LIST
90569: LIST
90570: PUSH
90571: LD_INT 34
90573: PUSH
90574: LD_INT 30
90576: PUSH
90577: EMPTY
90578: LIST
90579: LIST
90580: PUSH
90581: EMPTY
90582: LIST
90583: LIST
90584: LIST
90585: PUSH
90586: EMPTY
90587: LIST
90588: LIST
90589: PPUSH
90590: CALL_OW 69
90594: ST_TO_ADDR
// if not tmp then
90595: LD_VAR 0 2
90599: NOT
90600: IFFALSE 90604
// exit ;
90602: GO 90633
// for i in tmp do
90604: LD_ADDR_VAR 0 1
90608: PUSH
90609: LD_VAR 0 2
90613: PUSH
90614: FOR_IN
90615: IFFALSE 90631
// begin SetLives ( i , 0 ) ;
90617: LD_VAR 0 1
90621: PPUSH
90622: LD_INT 0
90624: PPUSH
90625: CALL_OW 234
// end ;
90629: GO 90614
90631: POP
90632: POP
// end ;
90633: PPOPN 2
90635: END
// every 0 0$1 trigger StreamModeActive and sBunker do
90636: LD_EXP 113
90640: PUSH
90641: LD_EXP 123
90645: AND
90646: IFFALSE 90666
90648: GO 90650
90650: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
90651: LD_INT 32
90653: PPUSH
90654: LD_OWVAR 2
90658: PPUSH
90659: LD_INT 0
90661: PPUSH
90662: CALL_OW 324
90666: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
90667: LD_EXP 113
90671: PUSH
90672: LD_EXP 124
90676: AND
90677: IFFALSE 90858
90679: GO 90681
90681: DISABLE
90682: LD_INT 0
90684: PPUSH
90685: PPUSH
90686: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
90687: LD_ADDR_VAR 0 2
90691: PUSH
90692: LD_INT 22
90694: PUSH
90695: LD_OWVAR 2
90699: PUSH
90700: EMPTY
90701: LIST
90702: LIST
90703: PUSH
90704: LD_INT 33
90706: PUSH
90707: LD_INT 3
90709: PUSH
90710: EMPTY
90711: LIST
90712: LIST
90713: PUSH
90714: EMPTY
90715: LIST
90716: LIST
90717: PPUSH
90718: CALL_OW 69
90722: ST_TO_ADDR
// if not tmp then
90723: LD_VAR 0 2
90727: NOT
90728: IFFALSE 90732
// exit ;
90730: GO 90858
// side := 0 ;
90732: LD_ADDR_VAR 0 3
90736: PUSH
90737: LD_INT 0
90739: ST_TO_ADDR
// for i := 1 to 8 do
90740: LD_ADDR_VAR 0 1
90744: PUSH
90745: DOUBLE
90746: LD_INT 1
90748: DEC
90749: ST_TO_ADDR
90750: LD_INT 8
90752: PUSH
90753: FOR_TO
90754: IFFALSE 90802
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
90756: LD_OWVAR 2
90760: PUSH
90761: LD_VAR 0 1
90765: NONEQUAL
90766: PUSH
90767: LD_OWVAR 2
90771: PPUSH
90772: LD_VAR 0 1
90776: PPUSH
90777: CALL_OW 81
90781: PUSH
90782: LD_INT 2
90784: EQUAL
90785: AND
90786: IFFALSE 90800
// begin side := i ;
90788: LD_ADDR_VAR 0 3
90792: PUSH
90793: LD_VAR 0 1
90797: ST_TO_ADDR
// break ;
90798: GO 90802
// end ;
90800: GO 90753
90802: POP
90803: POP
// if not side then
90804: LD_VAR 0 3
90808: NOT
90809: IFFALSE 90813
// exit ;
90811: GO 90858
// for i := 1 to tmp do
90813: LD_ADDR_VAR 0 1
90817: PUSH
90818: DOUBLE
90819: LD_INT 1
90821: DEC
90822: ST_TO_ADDR
90823: LD_VAR 0 2
90827: PUSH
90828: FOR_TO
90829: IFFALSE 90856
// if Prob ( 60 ) then
90831: LD_INT 60
90833: PPUSH
90834: CALL_OW 13
90838: IFFALSE 90854
// SetSide ( i , side ) ;
90840: LD_VAR 0 1
90844: PPUSH
90845: LD_VAR 0 3
90849: PPUSH
90850: CALL_OW 235
90854: GO 90828
90856: POP
90857: POP
// end ;
90858: PPOPN 3
90860: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
90861: LD_EXP 113
90865: PUSH
90866: LD_EXP 126
90870: AND
90871: IFFALSE 90990
90873: GO 90875
90875: DISABLE
90876: LD_INT 0
90878: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
90879: LD_ADDR_VAR 0 1
90883: PUSH
90884: LD_INT 22
90886: PUSH
90887: LD_OWVAR 2
90891: PUSH
90892: EMPTY
90893: LIST
90894: LIST
90895: PUSH
90896: LD_INT 21
90898: PUSH
90899: LD_INT 1
90901: PUSH
90902: EMPTY
90903: LIST
90904: LIST
90905: PUSH
90906: LD_INT 3
90908: PUSH
90909: LD_INT 23
90911: PUSH
90912: LD_INT 0
90914: PUSH
90915: EMPTY
90916: LIST
90917: LIST
90918: PUSH
90919: EMPTY
90920: LIST
90921: LIST
90922: PUSH
90923: EMPTY
90924: LIST
90925: LIST
90926: LIST
90927: PPUSH
90928: CALL_OW 69
90932: PUSH
90933: FOR_IN
90934: IFFALSE 90988
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
90936: LD_VAR 0 1
90940: PPUSH
90941: CALL_OW 257
90945: PUSH
90946: LD_INT 1
90948: PUSH
90949: LD_INT 2
90951: PUSH
90952: LD_INT 3
90954: PUSH
90955: LD_INT 4
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: LIST
90962: LIST
90963: IN
90964: IFFALSE 90986
// SetClass ( un , rand ( 1 , 4 ) ) ;
90966: LD_VAR 0 1
90970: PPUSH
90971: LD_INT 1
90973: PPUSH
90974: LD_INT 4
90976: PPUSH
90977: CALL_OW 12
90981: PPUSH
90982: CALL_OW 336
90986: GO 90933
90988: POP
90989: POP
// end ;
90990: PPOPN 1
90992: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
90993: LD_EXP 113
90997: PUSH
90998: LD_EXP 125
91002: AND
91003: IFFALSE 91082
91005: GO 91007
91007: DISABLE
91008: LD_INT 0
91010: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91011: LD_ADDR_VAR 0 1
91015: PUSH
91016: LD_INT 22
91018: PUSH
91019: LD_OWVAR 2
91023: PUSH
91024: EMPTY
91025: LIST
91026: LIST
91027: PUSH
91028: LD_INT 21
91030: PUSH
91031: LD_INT 3
91033: PUSH
91034: EMPTY
91035: LIST
91036: LIST
91037: PUSH
91038: EMPTY
91039: LIST
91040: LIST
91041: PPUSH
91042: CALL_OW 69
91046: ST_TO_ADDR
// if not tmp then
91047: LD_VAR 0 1
91051: NOT
91052: IFFALSE 91056
// exit ;
91054: GO 91082
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
91056: LD_VAR 0 1
91060: PUSH
91061: LD_INT 1
91063: PPUSH
91064: LD_VAR 0 1
91068: PPUSH
91069: CALL_OW 12
91073: ARRAY
91074: PPUSH
91075: LD_INT 100
91077: PPUSH
91078: CALL_OW 234
// end ;
91082: PPOPN 1
91084: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
91085: LD_EXP 113
91089: PUSH
91090: LD_EXP 127
91094: AND
91095: IFFALSE 91193
91097: GO 91099
91099: DISABLE
91100: LD_INT 0
91102: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91103: LD_ADDR_VAR 0 1
91107: PUSH
91108: LD_INT 22
91110: PUSH
91111: LD_OWVAR 2
91115: PUSH
91116: EMPTY
91117: LIST
91118: LIST
91119: PUSH
91120: LD_INT 21
91122: PUSH
91123: LD_INT 1
91125: PUSH
91126: EMPTY
91127: LIST
91128: LIST
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: PPUSH
91134: CALL_OW 69
91138: ST_TO_ADDR
// if not tmp then
91139: LD_VAR 0 1
91143: NOT
91144: IFFALSE 91148
// exit ;
91146: GO 91193
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
91148: LD_VAR 0 1
91152: PUSH
91153: LD_INT 1
91155: PPUSH
91156: LD_VAR 0 1
91160: PPUSH
91161: CALL_OW 12
91165: ARRAY
91166: PPUSH
91167: LD_INT 1
91169: PPUSH
91170: LD_INT 4
91172: PPUSH
91173: CALL_OW 12
91177: PPUSH
91178: LD_INT 3000
91180: PPUSH
91181: LD_INT 9000
91183: PPUSH
91184: CALL_OW 12
91188: PPUSH
91189: CALL_OW 492
// end ;
91193: PPOPN 1
91195: END
// every 0 0$1 trigger StreamModeActive and sDepot do
91196: LD_EXP 113
91200: PUSH
91201: LD_EXP 128
91205: AND
91206: IFFALSE 91226
91208: GO 91210
91210: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
91211: LD_INT 1
91213: PPUSH
91214: LD_OWVAR 2
91218: PPUSH
91219: LD_INT 0
91221: PPUSH
91222: CALL_OW 324
91226: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
91227: LD_EXP 113
91231: PUSH
91232: LD_EXP 129
91236: AND
91237: IFFALSE 91320
91239: GO 91241
91241: DISABLE
91242: LD_INT 0
91244: PPUSH
91245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91246: LD_ADDR_VAR 0 2
91250: PUSH
91251: LD_INT 22
91253: PUSH
91254: LD_OWVAR 2
91258: PUSH
91259: EMPTY
91260: LIST
91261: LIST
91262: PUSH
91263: LD_INT 21
91265: PUSH
91266: LD_INT 3
91268: PUSH
91269: EMPTY
91270: LIST
91271: LIST
91272: PUSH
91273: EMPTY
91274: LIST
91275: LIST
91276: PPUSH
91277: CALL_OW 69
91281: ST_TO_ADDR
// if not tmp then
91282: LD_VAR 0 2
91286: NOT
91287: IFFALSE 91291
// exit ;
91289: GO 91320
// for i in tmp do
91291: LD_ADDR_VAR 0 1
91295: PUSH
91296: LD_VAR 0 2
91300: PUSH
91301: FOR_IN
91302: IFFALSE 91318
// SetBLevel ( i , 10 ) ;
91304: LD_VAR 0 1
91308: PPUSH
91309: LD_INT 10
91311: PPUSH
91312: CALL_OW 241
91316: GO 91301
91318: POP
91319: POP
// end ;
91320: PPOPN 2
91322: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
91323: LD_EXP 113
91327: PUSH
91328: LD_EXP 130
91332: AND
91333: IFFALSE 91444
91335: GO 91337
91337: DISABLE
91338: LD_INT 0
91340: PPUSH
91341: PPUSH
91342: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91343: LD_ADDR_VAR 0 3
91347: PUSH
91348: LD_INT 22
91350: PUSH
91351: LD_OWVAR 2
91355: PUSH
91356: EMPTY
91357: LIST
91358: LIST
91359: PUSH
91360: LD_INT 25
91362: PUSH
91363: LD_INT 1
91365: PUSH
91366: EMPTY
91367: LIST
91368: LIST
91369: PUSH
91370: EMPTY
91371: LIST
91372: LIST
91373: PPUSH
91374: CALL_OW 69
91378: ST_TO_ADDR
// if not tmp then
91379: LD_VAR 0 3
91383: NOT
91384: IFFALSE 91388
// exit ;
91386: GO 91444
// un := tmp [ rand ( 1 , tmp ) ] ;
91388: LD_ADDR_VAR 0 2
91392: PUSH
91393: LD_VAR 0 3
91397: PUSH
91398: LD_INT 1
91400: PPUSH
91401: LD_VAR 0 3
91405: PPUSH
91406: CALL_OW 12
91410: ARRAY
91411: ST_TO_ADDR
// if Crawls ( un ) then
91412: LD_VAR 0 2
91416: PPUSH
91417: CALL_OW 318
91421: IFFALSE 91432
// ComWalk ( un ) ;
91423: LD_VAR 0 2
91427: PPUSH
91428: CALL_OW 138
// SetClass ( un , class_sniper ) ;
91432: LD_VAR 0 2
91436: PPUSH
91437: LD_INT 5
91439: PPUSH
91440: CALL_OW 336
// end ;
91444: PPOPN 3
91446: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
91447: LD_EXP 113
91451: PUSH
91452: LD_EXP 131
91456: AND
91457: PUSH
91458: LD_OWVAR 67
91462: PUSH
91463: LD_INT 4
91465: LESS
91466: AND
91467: IFFALSE 91486
91469: GO 91471
91471: DISABLE
// begin Difficulty := Difficulty + 1 ;
91472: LD_ADDR_OWVAR 67
91476: PUSH
91477: LD_OWVAR 67
91481: PUSH
91482: LD_INT 1
91484: PLUS
91485: ST_TO_ADDR
// end ;
91486: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
91487: LD_EXP 113
91491: PUSH
91492: LD_EXP 132
91496: AND
91497: IFFALSE 91600
91499: GO 91501
91501: DISABLE
91502: LD_INT 0
91504: PPUSH
// begin for i := 1 to 5 do
91505: LD_ADDR_VAR 0 1
91509: PUSH
91510: DOUBLE
91511: LD_INT 1
91513: DEC
91514: ST_TO_ADDR
91515: LD_INT 5
91517: PUSH
91518: FOR_TO
91519: IFFALSE 91598
// begin uc_nation := nation_nature ;
91521: LD_ADDR_OWVAR 21
91525: PUSH
91526: LD_INT 0
91528: ST_TO_ADDR
// uc_side := 0 ;
91529: LD_ADDR_OWVAR 20
91533: PUSH
91534: LD_INT 0
91536: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
91537: LD_ADDR_OWVAR 29
91541: PUSH
91542: LD_INT 12
91544: PUSH
91545: LD_INT 12
91547: PUSH
91548: EMPTY
91549: LIST
91550: LIST
91551: ST_TO_ADDR
// hc_agressivity := 20 ;
91552: LD_ADDR_OWVAR 35
91556: PUSH
91557: LD_INT 20
91559: ST_TO_ADDR
// hc_class := class_tiger ;
91560: LD_ADDR_OWVAR 28
91564: PUSH
91565: LD_INT 14
91567: ST_TO_ADDR
// hc_gallery :=  ;
91568: LD_ADDR_OWVAR 33
91572: PUSH
91573: LD_STRING 
91575: ST_TO_ADDR
// hc_name :=  ;
91576: LD_ADDR_OWVAR 26
91580: PUSH
91581: LD_STRING 
91583: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
91584: CALL_OW 44
91588: PPUSH
91589: LD_INT 0
91591: PPUSH
91592: CALL_OW 51
// end ;
91596: GO 91518
91598: POP
91599: POP
// end ;
91600: PPOPN 1
91602: END
// every 0 0$1 trigger StreamModeActive and sBomb do
91603: LD_EXP 113
91607: PUSH
91608: LD_EXP 133
91612: AND
91613: IFFALSE 91622
91615: GO 91617
91617: DISABLE
// StreamSibBomb ;
91618: CALL 91623 0 0
91622: END
// export function StreamSibBomb ; var i , x , y ; begin
91623: LD_INT 0
91625: PPUSH
91626: PPUSH
91627: PPUSH
91628: PPUSH
// result := false ;
91629: LD_ADDR_VAR 0 1
91633: PUSH
91634: LD_INT 0
91636: ST_TO_ADDR
// for i := 1 to 16 do
91637: LD_ADDR_VAR 0 2
91641: PUSH
91642: DOUBLE
91643: LD_INT 1
91645: DEC
91646: ST_TO_ADDR
91647: LD_INT 16
91649: PUSH
91650: FOR_TO
91651: IFFALSE 91850
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91653: LD_ADDR_VAR 0 3
91657: PUSH
91658: LD_INT 10
91660: PUSH
91661: LD_INT 20
91663: PUSH
91664: LD_INT 30
91666: PUSH
91667: LD_INT 40
91669: PUSH
91670: LD_INT 50
91672: PUSH
91673: LD_INT 60
91675: PUSH
91676: LD_INT 70
91678: PUSH
91679: LD_INT 80
91681: PUSH
91682: LD_INT 90
91684: PUSH
91685: LD_INT 100
91687: PUSH
91688: LD_INT 110
91690: PUSH
91691: LD_INT 120
91693: PUSH
91694: LD_INT 130
91696: PUSH
91697: LD_INT 140
91699: PUSH
91700: LD_INT 150
91702: PUSH
91703: EMPTY
91704: LIST
91705: LIST
91706: LIST
91707: LIST
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: LIST
91719: PUSH
91720: LD_INT 1
91722: PPUSH
91723: LD_INT 15
91725: PPUSH
91726: CALL_OW 12
91730: ARRAY
91731: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91732: LD_ADDR_VAR 0 4
91736: PUSH
91737: LD_INT 10
91739: PUSH
91740: LD_INT 20
91742: PUSH
91743: LD_INT 30
91745: PUSH
91746: LD_INT 40
91748: PUSH
91749: LD_INT 50
91751: PUSH
91752: LD_INT 60
91754: PUSH
91755: LD_INT 70
91757: PUSH
91758: LD_INT 80
91760: PUSH
91761: LD_INT 90
91763: PUSH
91764: LD_INT 100
91766: PUSH
91767: LD_INT 110
91769: PUSH
91770: LD_INT 120
91772: PUSH
91773: LD_INT 130
91775: PUSH
91776: LD_INT 140
91778: PUSH
91779: LD_INT 150
91781: PUSH
91782: EMPTY
91783: LIST
91784: LIST
91785: LIST
91786: LIST
91787: LIST
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: LIST
91794: LIST
91795: LIST
91796: LIST
91797: LIST
91798: PUSH
91799: LD_INT 1
91801: PPUSH
91802: LD_INT 15
91804: PPUSH
91805: CALL_OW 12
91809: ARRAY
91810: ST_TO_ADDR
// if ValidHex ( x , y ) then
91811: LD_VAR 0 3
91815: PPUSH
91816: LD_VAR 0 4
91820: PPUSH
91821: CALL_OW 488
91825: IFFALSE 91848
// begin result := [ x , y ] ;
91827: LD_ADDR_VAR 0 1
91831: PUSH
91832: LD_VAR 0 3
91836: PUSH
91837: LD_VAR 0 4
91841: PUSH
91842: EMPTY
91843: LIST
91844: LIST
91845: ST_TO_ADDR
// break ;
91846: GO 91850
// end ; end ;
91848: GO 91650
91850: POP
91851: POP
// if result then
91852: LD_VAR 0 1
91856: IFFALSE 91916
// begin ToLua ( playSibBomb() ) ;
91858: LD_STRING playSibBomb()
91860: PPUSH
91861: CALL_OW 559
// wait ( 0 0$14 ) ;
91865: LD_INT 490
91867: PPUSH
91868: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
91872: LD_VAR 0 1
91876: PUSH
91877: LD_INT 1
91879: ARRAY
91880: PPUSH
91881: LD_VAR 0 1
91885: PUSH
91886: LD_INT 2
91888: ARRAY
91889: PPUSH
91890: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
91894: LD_VAR 0 1
91898: PUSH
91899: LD_INT 1
91901: ARRAY
91902: PPUSH
91903: LD_VAR 0 1
91907: PUSH
91908: LD_INT 2
91910: ARRAY
91911: PPUSH
91912: CALL_OW 429
// end ; end ;
91916: LD_VAR 0 1
91920: RET
// every 0 0$1 trigger StreamModeActive and sReset do
91921: LD_EXP 113
91925: PUSH
91926: LD_EXP 135
91930: AND
91931: IFFALSE 91943
91933: GO 91935
91935: DISABLE
// YouLost (  ) ;
91936: LD_STRING 
91938: PPUSH
91939: CALL_OW 104
91943: END
// every 0 0$1 trigger StreamModeActive and sFog do
91944: LD_EXP 113
91948: PUSH
91949: LD_EXP 134
91953: AND
91954: IFFALSE 91968
91956: GO 91958
91958: DISABLE
// FogOff ( your_side ) ;
91959: LD_OWVAR 2
91963: PPUSH
91964: CALL_OW 344
91968: END
// every 0 0$1 trigger StreamModeActive and sSun do
91969: LD_EXP 113
91973: PUSH
91974: LD_EXP 136
91978: AND
91979: IFFALSE 92007
91981: GO 91983
91983: DISABLE
// begin solar_recharge_percent := 0 ;
91984: LD_ADDR_OWVAR 79
91988: PUSH
91989: LD_INT 0
91991: ST_TO_ADDR
// wait ( 5 5$00 ) ;
91992: LD_INT 10500
91994: PPUSH
91995: CALL_OW 67
// solar_recharge_percent := 100 ;
91999: LD_ADDR_OWVAR 79
92003: PUSH
92004: LD_INT 100
92006: ST_TO_ADDR
// end ;
92007: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
92008: LD_EXP 113
92012: PUSH
92013: LD_EXP 137
92017: AND
92018: IFFALSE 92257
92020: GO 92022
92022: DISABLE
92023: LD_INT 0
92025: PPUSH
92026: PPUSH
92027: PPUSH
// begin tmp := [ ] ;
92028: LD_ADDR_VAR 0 3
92032: PUSH
92033: EMPTY
92034: ST_TO_ADDR
// for i := 1 to 6 do
92035: LD_ADDR_VAR 0 1
92039: PUSH
92040: DOUBLE
92041: LD_INT 1
92043: DEC
92044: ST_TO_ADDR
92045: LD_INT 6
92047: PUSH
92048: FOR_TO
92049: IFFALSE 92154
// begin uc_nation := nation_nature ;
92051: LD_ADDR_OWVAR 21
92055: PUSH
92056: LD_INT 0
92058: ST_TO_ADDR
// uc_side := 0 ;
92059: LD_ADDR_OWVAR 20
92063: PUSH
92064: LD_INT 0
92066: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
92067: LD_ADDR_OWVAR 29
92071: PUSH
92072: LD_INT 12
92074: PUSH
92075: LD_INT 12
92077: PUSH
92078: EMPTY
92079: LIST
92080: LIST
92081: ST_TO_ADDR
// hc_agressivity := 20 ;
92082: LD_ADDR_OWVAR 35
92086: PUSH
92087: LD_INT 20
92089: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
92090: LD_ADDR_OWVAR 28
92094: PUSH
92095: LD_INT 17
92097: ST_TO_ADDR
// hc_gallery :=  ;
92098: LD_ADDR_OWVAR 33
92102: PUSH
92103: LD_STRING 
92105: ST_TO_ADDR
// hc_name :=  ;
92106: LD_ADDR_OWVAR 26
92110: PUSH
92111: LD_STRING 
92113: ST_TO_ADDR
// un := CreateHuman ;
92114: LD_ADDR_VAR 0 2
92118: PUSH
92119: CALL_OW 44
92123: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
92124: LD_VAR 0 2
92128: PPUSH
92129: LD_INT 1
92131: PPUSH
92132: CALL_OW 51
// tmp := tmp ^ un ;
92136: LD_ADDR_VAR 0 3
92140: PUSH
92141: LD_VAR 0 3
92145: PUSH
92146: LD_VAR 0 2
92150: ADD
92151: ST_TO_ADDR
// end ;
92152: GO 92048
92154: POP
92155: POP
// repeat wait ( 0 0$1 ) ;
92156: LD_INT 35
92158: PPUSH
92159: CALL_OW 67
// for un in tmp do
92163: LD_ADDR_VAR 0 2
92167: PUSH
92168: LD_VAR 0 3
92172: PUSH
92173: FOR_IN
92174: IFFALSE 92248
// begin if IsDead ( un ) then
92176: LD_VAR 0 2
92180: PPUSH
92181: CALL_OW 301
92185: IFFALSE 92205
// begin tmp := tmp diff un ;
92187: LD_ADDR_VAR 0 3
92191: PUSH
92192: LD_VAR 0 3
92196: PUSH
92197: LD_VAR 0 2
92201: DIFF
92202: ST_TO_ADDR
// continue ;
92203: GO 92173
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
92205: LD_VAR 0 2
92209: PPUSH
92210: LD_INT 3
92212: PUSH
92213: LD_INT 22
92215: PUSH
92216: LD_INT 0
92218: PUSH
92219: EMPTY
92220: LIST
92221: LIST
92222: PUSH
92223: EMPTY
92224: LIST
92225: LIST
92226: PPUSH
92227: CALL_OW 69
92231: PPUSH
92232: LD_VAR 0 2
92236: PPUSH
92237: CALL_OW 74
92241: PPUSH
92242: CALL_OW 115
// end ;
92246: GO 92173
92248: POP
92249: POP
// until not tmp ;
92250: LD_VAR 0 3
92254: NOT
92255: IFFALSE 92156
// end ;
92257: PPOPN 3
92259: END
// every 0 0$1 trigger StreamModeActive and sTroll do
92260: LD_EXP 113
92264: PUSH
92265: LD_EXP 138
92269: AND
92270: IFFALSE 92324
92272: GO 92274
92274: DISABLE
// begin ToLua ( displayTroll(); ) ;
92275: LD_STRING displayTroll();
92277: PPUSH
92278: CALL_OW 559
// wait ( 3 3$00 ) ;
92282: LD_INT 6300
92284: PPUSH
92285: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92289: LD_STRING hideTroll();
92291: PPUSH
92292: CALL_OW 559
// wait ( 1 1$00 ) ;
92296: LD_INT 2100
92298: PPUSH
92299: CALL_OW 67
// ToLua ( displayTroll(); ) ;
92303: LD_STRING displayTroll();
92305: PPUSH
92306: CALL_OW 559
// wait ( 1 1$00 ) ;
92310: LD_INT 2100
92312: PPUSH
92313: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92317: LD_STRING hideTroll();
92319: PPUSH
92320: CALL_OW 559
// end ;
92324: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
92325: LD_EXP 113
92329: PUSH
92330: LD_EXP 139
92334: AND
92335: IFFALSE 92398
92337: GO 92339
92339: DISABLE
92340: LD_INT 0
92342: PPUSH
// begin p := 0 ;
92343: LD_ADDR_VAR 0 1
92347: PUSH
92348: LD_INT 0
92350: ST_TO_ADDR
// repeat game_speed := 1 ;
92351: LD_ADDR_OWVAR 65
92355: PUSH
92356: LD_INT 1
92358: ST_TO_ADDR
// wait ( 0 0$1 ) ;
92359: LD_INT 35
92361: PPUSH
92362: CALL_OW 67
// p := p + 1 ;
92366: LD_ADDR_VAR 0 1
92370: PUSH
92371: LD_VAR 0 1
92375: PUSH
92376: LD_INT 1
92378: PLUS
92379: ST_TO_ADDR
// until p >= 60 ;
92380: LD_VAR 0 1
92384: PUSH
92385: LD_INT 60
92387: GREATEREQUAL
92388: IFFALSE 92351
// game_speed := 4 ;
92390: LD_ADDR_OWVAR 65
92394: PUSH
92395: LD_INT 4
92397: ST_TO_ADDR
// end ;
92398: PPOPN 1
92400: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
92401: LD_EXP 113
92405: PUSH
92406: LD_EXP 140
92410: AND
92411: IFFALSE 92557
92413: GO 92415
92415: DISABLE
92416: LD_INT 0
92418: PPUSH
92419: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92420: LD_ADDR_VAR 0 1
92424: PUSH
92425: LD_INT 22
92427: PUSH
92428: LD_OWVAR 2
92432: PUSH
92433: EMPTY
92434: LIST
92435: LIST
92436: PUSH
92437: LD_INT 2
92439: PUSH
92440: LD_INT 30
92442: PUSH
92443: LD_INT 0
92445: PUSH
92446: EMPTY
92447: LIST
92448: LIST
92449: PUSH
92450: LD_INT 30
92452: PUSH
92453: LD_INT 1
92455: PUSH
92456: EMPTY
92457: LIST
92458: LIST
92459: PUSH
92460: EMPTY
92461: LIST
92462: LIST
92463: LIST
92464: PUSH
92465: EMPTY
92466: LIST
92467: LIST
92468: PPUSH
92469: CALL_OW 69
92473: ST_TO_ADDR
// if not depot then
92474: LD_VAR 0 1
92478: NOT
92479: IFFALSE 92483
// exit ;
92481: GO 92557
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
92483: LD_ADDR_VAR 0 2
92487: PUSH
92488: LD_VAR 0 1
92492: PUSH
92493: LD_INT 1
92495: PPUSH
92496: LD_VAR 0 1
92500: PPUSH
92501: CALL_OW 12
92505: ARRAY
92506: PPUSH
92507: CALL_OW 274
92511: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
92512: LD_VAR 0 2
92516: PPUSH
92517: LD_INT 1
92519: PPUSH
92520: LD_INT 0
92522: PPUSH
92523: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
92527: LD_VAR 0 2
92531: PPUSH
92532: LD_INT 2
92534: PPUSH
92535: LD_INT 0
92537: PPUSH
92538: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
92542: LD_VAR 0 2
92546: PPUSH
92547: LD_INT 3
92549: PPUSH
92550: LD_INT 0
92552: PPUSH
92553: CALL_OW 277
// end ;
92557: PPOPN 2
92559: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
92560: LD_EXP 113
92564: PUSH
92565: LD_EXP 141
92569: AND
92570: IFFALSE 92667
92572: GO 92574
92574: DISABLE
92575: LD_INT 0
92577: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92578: LD_ADDR_VAR 0 1
92582: PUSH
92583: LD_INT 22
92585: PUSH
92586: LD_OWVAR 2
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 21
92597: PUSH
92598: LD_INT 1
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: PUSH
92605: LD_INT 3
92607: PUSH
92608: LD_INT 23
92610: PUSH
92611: LD_INT 0
92613: PUSH
92614: EMPTY
92615: LIST
92616: LIST
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: PUSH
92622: EMPTY
92623: LIST
92624: LIST
92625: LIST
92626: PPUSH
92627: CALL_OW 69
92631: ST_TO_ADDR
// if not tmp then
92632: LD_VAR 0 1
92636: NOT
92637: IFFALSE 92641
// exit ;
92639: GO 92667
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
92641: LD_VAR 0 1
92645: PUSH
92646: LD_INT 1
92648: PPUSH
92649: LD_VAR 0 1
92653: PPUSH
92654: CALL_OW 12
92658: ARRAY
92659: PPUSH
92660: LD_INT 200
92662: PPUSH
92663: CALL_OW 234
// end ;
92667: PPOPN 1
92669: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
92670: LD_EXP 113
92674: PUSH
92675: LD_EXP 142
92679: AND
92680: IFFALSE 92759
92682: GO 92684
92684: DISABLE
92685: LD_INT 0
92687: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
92688: LD_ADDR_VAR 0 1
92692: PUSH
92693: LD_INT 22
92695: PUSH
92696: LD_OWVAR 2
92700: PUSH
92701: EMPTY
92702: LIST
92703: LIST
92704: PUSH
92705: LD_INT 21
92707: PUSH
92708: LD_INT 2
92710: PUSH
92711: EMPTY
92712: LIST
92713: LIST
92714: PUSH
92715: EMPTY
92716: LIST
92717: LIST
92718: PPUSH
92719: CALL_OW 69
92723: ST_TO_ADDR
// if not tmp then
92724: LD_VAR 0 1
92728: NOT
92729: IFFALSE 92733
// exit ;
92731: GO 92759
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
92733: LD_VAR 0 1
92737: PUSH
92738: LD_INT 1
92740: PPUSH
92741: LD_VAR 0 1
92745: PPUSH
92746: CALL_OW 12
92750: ARRAY
92751: PPUSH
92752: LD_INT 60
92754: PPUSH
92755: CALL_OW 234
// end ;
92759: PPOPN 1
92761: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
92762: LD_EXP 113
92766: PUSH
92767: LD_EXP 143
92771: AND
92772: IFFALSE 92871
92774: GO 92776
92776: DISABLE
92777: LD_INT 0
92779: PPUSH
92780: PPUSH
// begin enable ;
92781: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
92782: LD_ADDR_VAR 0 1
92786: PUSH
92787: LD_INT 22
92789: PUSH
92790: LD_OWVAR 2
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 61
92801: PUSH
92802: EMPTY
92803: LIST
92804: PUSH
92805: LD_INT 33
92807: PUSH
92808: LD_INT 2
92810: PUSH
92811: EMPTY
92812: LIST
92813: LIST
92814: PUSH
92815: EMPTY
92816: LIST
92817: LIST
92818: LIST
92819: PPUSH
92820: CALL_OW 69
92824: ST_TO_ADDR
// if not tmp then
92825: LD_VAR 0 1
92829: NOT
92830: IFFALSE 92834
// exit ;
92832: GO 92871
// for i in tmp do
92834: LD_ADDR_VAR 0 2
92838: PUSH
92839: LD_VAR 0 1
92843: PUSH
92844: FOR_IN
92845: IFFALSE 92869
// if IsControledBy ( i ) then
92847: LD_VAR 0 2
92851: PPUSH
92852: CALL_OW 312
92856: IFFALSE 92867
// ComUnlink ( i ) ;
92858: LD_VAR 0 2
92862: PPUSH
92863: CALL_OW 136
92867: GO 92844
92869: POP
92870: POP
// end ;
92871: PPOPN 2
92873: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
92874: LD_EXP 113
92878: PUSH
92879: LD_EXP 144
92883: AND
92884: IFFALSE 93024
92886: GO 92888
92888: DISABLE
92889: LD_INT 0
92891: PPUSH
92892: PPUSH
// begin ToLua ( displayPowell(); ) ;
92893: LD_STRING displayPowell();
92895: PPUSH
92896: CALL_OW 559
// uc_side := 0 ;
92900: LD_ADDR_OWVAR 20
92904: PUSH
92905: LD_INT 0
92907: ST_TO_ADDR
// uc_nation := 2 ;
92908: LD_ADDR_OWVAR 21
92912: PUSH
92913: LD_INT 2
92915: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
92916: LD_ADDR_OWVAR 37
92920: PUSH
92921: LD_INT 14
92923: ST_TO_ADDR
// vc_engine := engine_siberite ;
92924: LD_ADDR_OWVAR 39
92928: PUSH
92929: LD_INT 3
92931: ST_TO_ADDR
// vc_control := control_apeman ;
92932: LD_ADDR_OWVAR 38
92936: PUSH
92937: LD_INT 5
92939: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
92940: LD_ADDR_OWVAR 40
92944: PUSH
92945: LD_INT 29
92947: ST_TO_ADDR
// un := CreateVehicle ;
92948: LD_ADDR_VAR 0 2
92952: PUSH
92953: CALL_OW 45
92957: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92958: LD_VAR 0 2
92962: PPUSH
92963: LD_INT 1
92965: PPUSH
92966: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
92970: LD_INT 35
92972: PPUSH
92973: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
92977: LD_VAR 0 2
92981: PPUSH
92982: LD_INT 22
92984: PUSH
92985: LD_OWVAR 2
92989: PUSH
92990: EMPTY
92991: LIST
92992: LIST
92993: PPUSH
92994: CALL_OW 69
92998: PPUSH
92999: LD_VAR 0 2
93003: PPUSH
93004: CALL_OW 74
93008: PPUSH
93009: CALL_OW 115
// until IsDead ( un ) ;
93013: LD_VAR 0 2
93017: PPUSH
93018: CALL_OW 301
93022: IFFALSE 92970
// end ;
93024: PPOPN 2
93026: END
// every 0 0$1 trigger StreamModeActive and sStu do
93027: LD_EXP 113
93031: PUSH
93032: LD_EXP 152
93036: AND
93037: IFFALSE 93053
93039: GO 93041
93041: DISABLE
// begin ToLua ( displayStucuk(); ) ;
93042: LD_STRING displayStucuk();
93044: PPUSH
93045: CALL_OW 559
// ResetFog ;
93049: CALL_OW 335
// end ;
93053: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
93054: LD_EXP 113
93058: PUSH
93059: LD_EXP 145
93063: AND
93064: IFFALSE 93205
93066: GO 93068
93068: DISABLE
93069: LD_INT 0
93071: PPUSH
93072: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93073: LD_ADDR_VAR 0 2
93077: PUSH
93078: LD_INT 22
93080: PUSH
93081: LD_OWVAR 2
93085: PUSH
93086: EMPTY
93087: LIST
93088: LIST
93089: PUSH
93090: LD_INT 21
93092: PUSH
93093: LD_INT 1
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: PUSH
93100: EMPTY
93101: LIST
93102: LIST
93103: PPUSH
93104: CALL_OW 69
93108: ST_TO_ADDR
// if not tmp then
93109: LD_VAR 0 2
93113: NOT
93114: IFFALSE 93118
// exit ;
93116: GO 93205
// un := tmp [ rand ( 1 , tmp ) ] ;
93118: LD_ADDR_VAR 0 1
93122: PUSH
93123: LD_VAR 0 2
93127: PUSH
93128: LD_INT 1
93130: PPUSH
93131: LD_VAR 0 2
93135: PPUSH
93136: CALL_OW 12
93140: ARRAY
93141: ST_TO_ADDR
// SetSide ( un , 0 ) ;
93142: LD_VAR 0 1
93146: PPUSH
93147: LD_INT 0
93149: PPUSH
93150: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
93154: LD_VAR 0 1
93158: PPUSH
93159: LD_OWVAR 3
93163: PUSH
93164: LD_VAR 0 1
93168: DIFF
93169: PPUSH
93170: LD_VAR 0 1
93174: PPUSH
93175: CALL_OW 74
93179: PPUSH
93180: CALL_OW 115
// wait ( 0 0$20 ) ;
93184: LD_INT 700
93186: PPUSH
93187: CALL_OW 67
// SetSide ( un , your_side ) ;
93191: LD_VAR 0 1
93195: PPUSH
93196: LD_OWVAR 2
93200: PPUSH
93201: CALL_OW 235
// end ;
93205: PPOPN 2
93207: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
93208: LD_EXP 113
93212: PUSH
93213: LD_EXP 146
93217: AND
93218: IFFALSE 93324
93220: GO 93222
93222: DISABLE
93223: LD_INT 0
93225: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93226: LD_ADDR_VAR 0 1
93230: PUSH
93231: LD_INT 22
93233: PUSH
93234: LD_OWVAR 2
93238: PUSH
93239: EMPTY
93240: LIST
93241: LIST
93242: PUSH
93243: LD_INT 2
93245: PUSH
93246: LD_INT 30
93248: PUSH
93249: LD_INT 0
93251: PUSH
93252: EMPTY
93253: LIST
93254: LIST
93255: PUSH
93256: LD_INT 30
93258: PUSH
93259: LD_INT 1
93261: PUSH
93262: EMPTY
93263: LIST
93264: LIST
93265: PUSH
93266: EMPTY
93267: LIST
93268: LIST
93269: LIST
93270: PUSH
93271: EMPTY
93272: LIST
93273: LIST
93274: PPUSH
93275: CALL_OW 69
93279: ST_TO_ADDR
// if not depot then
93280: LD_VAR 0 1
93284: NOT
93285: IFFALSE 93289
// exit ;
93287: GO 93324
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
93289: LD_VAR 0 1
93293: PUSH
93294: LD_INT 1
93296: ARRAY
93297: PPUSH
93298: CALL_OW 250
93302: PPUSH
93303: LD_VAR 0 1
93307: PUSH
93308: LD_INT 1
93310: ARRAY
93311: PPUSH
93312: CALL_OW 251
93316: PPUSH
93317: LD_INT 70
93319: PPUSH
93320: CALL_OW 495
// end ;
93324: PPOPN 1
93326: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
93327: LD_EXP 113
93331: PUSH
93332: LD_EXP 147
93336: AND
93337: IFFALSE 93548
93339: GO 93341
93341: DISABLE
93342: LD_INT 0
93344: PPUSH
93345: PPUSH
93346: PPUSH
93347: PPUSH
93348: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93349: LD_ADDR_VAR 0 5
93353: PUSH
93354: LD_INT 22
93356: PUSH
93357: LD_OWVAR 2
93361: PUSH
93362: EMPTY
93363: LIST
93364: LIST
93365: PUSH
93366: LD_INT 21
93368: PUSH
93369: LD_INT 1
93371: PUSH
93372: EMPTY
93373: LIST
93374: LIST
93375: PUSH
93376: EMPTY
93377: LIST
93378: LIST
93379: PPUSH
93380: CALL_OW 69
93384: ST_TO_ADDR
// if not tmp then
93385: LD_VAR 0 5
93389: NOT
93390: IFFALSE 93394
// exit ;
93392: GO 93548
// for i in tmp do
93394: LD_ADDR_VAR 0 1
93398: PUSH
93399: LD_VAR 0 5
93403: PUSH
93404: FOR_IN
93405: IFFALSE 93546
// begin d := rand ( 0 , 5 ) ;
93407: LD_ADDR_VAR 0 4
93411: PUSH
93412: LD_INT 0
93414: PPUSH
93415: LD_INT 5
93417: PPUSH
93418: CALL_OW 12
93422: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
93423: LD_ADDR_VAR 0 2
93427: PUSH
93428: LD_VAR 0 1
93432: PPUSH
93433: CALL_OW 250
93437: PPUSH
93438: LD_VAR 0 4
93442: PPUSH
93443: LD_INT 3
93445: PPUSH
93446: LD_INT 12
93448: PPUSH
93449: CALL_OW 12
93453: PPUSH
93454: CALL_OW 272
93458: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
93459: LD_ADDR_VAR 0 3
93463: PUSH
93464: LD_VAR 0 1
93468: PPUSH
93469: CALL_OW 251
93473: PPUSH
93474: LD_VAR 0 4
93478: PPUSH
93479: LD_INT 3
93481: PPUSH
93482: LD_INT 12
93484: PPUSH
93485: CALL_OW 12
93489: PPUSH
93490: CALL_OW 273
93494: ST_TO_ADDR
// if ValidHex ( x , y ) then
93495: LD_VAR 0 2
93499: PPUSH
93500: LD_VAR 0 3
93504: PPUSH
93505: CALL_OW 488
93509: IFFALSE 93544
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
93511: LD_VAR 0 1
93515: PPUSH
93516: LD_VAR 0 2
93520: PPUSH
93521: LD_VAR 0 3
93525: PPUSH
93526: LD_INT 3
93528: PPUSH
93529: LD_INT 6
93531: PPUSH
93532: CALL_OW 12
93536: PPUSH
93537: LD_INT 1
93539: PPUSH
93540: CALL_OW 483
// end ;
93544: GO 93404
93546: POP
93547: POP
// end ;
93548: PPOPN 5
93550: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
93551: LD_EXP 113
93555: PUSH
93556: LD_EXP 148
93560: AND
93561: IFFALSE 93655
93563: GO 93565
93565: DISABLE
93566: LD_INT 0
93568: PPUSH
93569: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
93570: LD_ADDR_VAR 0 2
93574: PUSH
93575: LD_INT 22
93577: PUSH
93578: LD_OWVAR 2
93582: PUSH
93583: EMPTY
93584: LIST
93585: LIST
93586: PUSH
93587: LD_INT 32
93589: PUSH
93590: LD_INT 1
93592: PUSH
93593: EMPTY
93594: LIST
93595: LIST
93596: PUSH
93597: LD_INT 21
93599: PUSH
93600: LD_INT 2
93602: PUSH
93603: EMPTY
93604: LIST
93605: LIST
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: LIST
93611: PPUSH
93612: CALL_OW 69
93616: ST_TO_ADDR
// if not tmp then
93617: LD_VAR 0 2
93621: NOT
93622: IFFALSE 93626
// exit ;
93624: GO 93655
// for i in tmp do
93626: LD_ADDR_VAR 0 1
93630: PUSH
93631: LD_VAR 0 2
93635: PUSH
93636: FOR_IN
93637: IFFALSE 93653
// SetFuel ( i , 0 ) ;
93639: LD_VAR 0 1
93643: PPUSH
93644: LD_INT 0
93646: PPUSH
93647: CALL_OW 240
93651: GO 93636
93653: POP
93654: POP
// end ;
93655: PPOPN 2
93657: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
93658: LD_EXP 113
93662: PUSH
93663: LD_EXP 149
93667: AND
93668: IFFALSE 93734
93670: GO 93672
93672: DISABLE
93673: LD_INT 0
93675: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
93676: LD_ADDR_VAR 0 1
93680: PUSH
93681: LD_INT 22
93683: PUSH
93684: LD_OWVAR 2
93688: PUSH
93689: EMPTY
93690: LIST
93691: LIST
93692: PUSH
93693: LD_INT 30
93695: PUSH
93696: LD_INT 29
93698: PUSH
93699: EMPTY
93700: LIST
93701: LIST
93702: PUSH
93703: EMPTY
93704: LIST
93705: LIST
93706: PPUSH
93707: CALL_OW 69
93711: ST_TO_ADDR
// if not tmp then
93712: LD_VAR 0 1
93716: NOT
93717: IFFALSE 93721
// exit ;
93719: GO 93734
// DestroyUnit ( tmp [ 1 ] ) ;
93721: LD_VAR 0 1
93725: PUSH
93726: LD_INT 1
93728: ARRAY
93729: PPUSH
93730: CALL_OW 65
// end ;
93734: PPOPN 1
93736: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
93737: LD_EXP 113
93741: PUSH
93742: LD_EXP 151
93746: AND
93747: IFFALSE 93876
93749: GO 93751
93751: DISABLE
93752: LD_INT 0
93754: PPUSH
// begin uc_side := 0 ;
93755: LD_ADDR_OWVAR 20
93759: PUSH
93760: LD_INT 0
93762: ST_TO_ADDR
// uc_nation := nation_arabian ;
93763: LD_ADDR_OWVAR 21
93767: PUSH
93768: LD_INT 2
93770: ST_TO_ADDR
// hc_gallery :=  ;
93771: LD_ADDR_OWVAR 33
93775: PUSH
93776: LD_STRING 
93778: ST_TO_ADDR
// hc_name :=  ;
93779: LD_ADDR_OWVAR 26
93783: PUSH
93784: LD_STRING 
93786: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
93787: LD_INT 1
93789: PPUSH
93790: LD_INT 11
93792: PPUSH
93793: LD_INT 10
93795: PPUSH
93796: CALL_OW 380
// un := CreateHuman ;
93800: LD_ADDR_VAR 0 1
93804: PUSH
93805: CALL_OW 44
93809: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93810: LD_VAR 0 1
93814: PPUSH
93815: LD_INT 1
93817: PPUSH
93818: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
93822: LD_INT 35
93824: PPUSH
93825: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
93829: LD_VAR 0 1
93833: PPUSH
93834: LD_INT 22
93836: PUSH
93837: LD_OWVAR 2
93841: PUSH
93842: EMPTY
93843: LIST
93844: LIST
93845: PPUSH
93846: CALL_OW 69
93850: PPUSH
93851: LD_VAR 0 1
93855: PPUSH
93856: CALL_OW 74
93860: PPUSH
93861: CALL_OW 115
// until IsDead ( un ) ;
93865: LD_VAR 0 1
93869: PPUSH
93870: CALL_OW 301
93874: IFFALSE 93822
// end ;
93876: PPOPN 1
93878: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
93879: LD_EXP 113
93883: PUSH
93884: LD_EXP 153
93888: AND
93889: IFFALSE 93901
93891: GO 93893
93893: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
93894: LD_STRING earthquake(getX(game), 0, 32)
93896: PPUSH
93897: CALL_OW 559
93901: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
93902: LD_EXP 113
93906: PUSH
93907: LD_EXP 154
93911: AND
93912: IFFALSE 94003
93914: GO 93916
93916: DISABLE
93917: LD_INT 0
93919: PPUSH
// begin enable ;
93920: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
93921: LD_ADDR_VAR 0 1
93925: PUSH
93926: LD_INT 22
93928: PUSH
93929: LD_OWVAR 2
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: LD_INT 21
93940: PUSH
93941: LD_INT 2
93943: PUSH
93944: EMPTY
93945: LIST
93946: LIST
93947: PUSH
93948: LD_INT 33
93950: PUSH
93951: LD_INT 3
93953: PUSH
93954: EMPTY
93955: LIST
93956: LIST
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: LIST
93962: PPUSH
93963: CALL_OW 69
93967: ST_TO_ADDR
// if not tmp then
93968: LD_VAR 0 1
93972: NOT
93973: IFFALSE 93977
// exit ;
93975: GO 94003
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
93977: LD_VAR 0 1
93981: PUSH
93982: LD_INT 1
93984: PPUSH
93985: LD_VAR 0 1
93989: PPUSH
93990: CALL_OW 12
93994: ARRAY
93995: PPUSH
93996: LD_INT 1
93998: PPUSH
93999: CALL_OW 234
// end ;
94003: PPOPN 1
94005: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
94006: LD_EXP 113
94010: PUSH
94011: LD_EXP 155
94015: AND
94016: IFFALSE 94157
94018: GO 94020
94020: DISABLE
94021: LD_INT 0
94023: PPUSH
94024: PPUSH
94025: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94026: LD_ADDR_VAR 0 3
94030: PUSH
94031: LD_INT 22
94033: PUSH
94034: LD_OWVAR 2
94038: PUSH
94039: EMPTY
94040: LIST
94041: LIST
94042: PUSH
94043: LD_INT 25
94045: PUSH
94046: LD_INT 1
94048: PUSH
94049: EMPTY
94050: LIST
94051: LIST
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: PPUSH
94057: CALL_OW 69
94061: ST_TO_ADDR
// if not tmp then
94062: LD_VAR 0 3
94066: NOT
94067: IFFALSE 94071
// exit ;
94069: GO 94157
// un := tmp [ rand ( 1 , tmp ) ] ;
94071: LD_ADDR_VAR 0 2
94075: PUSH
94076: LD_VAR 0 3
94080: PUSH
94081: LD_INT 1
94083: PPUSH
94084: LD_VAR 0 3
94088: PPUSH
94089: CALL_OW 12
94093: ARRAY
94094: ST_TO_ADDR
// if Crawls ( un ) then
94095: LD_VAR 0 2
94099: PPUSH
94100: CALL_OW 318
94104: IFFALSE 94115
// ComWalk ( un ) ;
94106: LD_VAR 0 2
94110: PPUSH
94111: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
94115: LD_VAR 0 2
94119: PPUSH
94120: LD_INT 9
94122: PPUSH
94123: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
94127: LD_INT 28
94129: PPUSH
94130: LD_OWVAR 2
94134: PPUSH
94135: LD_INT 2
94137: PPUSH
94138: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
94142: LD_INT 29
94144: PPUSH
94145: LD_OWVAR 2
94149: PPUSH
94150: LD_INT 2
94152: PPUSH
94153: CALL_OW 322
// end ;
94157: PPOPN 3
94159: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
94160: LD_EXP 113
94164: PUSH
94165: LD_EXP 156
94169: AND
94170: IFFALSE 94281
94172: GO 94174
94174: DISABLE
94175: LD_INT 0
94177: PPUSH
94178: PPUSH
94179: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94180: LD_ADDR_VAR 0 3
94184: PUSH
94185: LD_INT 22
94187: PUSH
94188: LD_OWVAR 2
94192: PUSH
94193: EMPTY
94194: LIST
94195: LIST
94196: PUSH
94197: LD_INT 25
94199: PUSH
94200: LD_INT 1
94202: PUSH
94203: EMPTY
94204: LIST
94205: LIST
94206: PUSH
94207: EMPTY
94208: LIST
94209: LIST
94210: PPUSH
94211: CALL_OW 69
94215: ST_TO_ADDR
// if not tmp then
94216: LD_VAR 0 3
94220: NOT
94221: IFFALSE 94225
// exit ;
94223: GO 94281
// un := tmp [ rand ( 1 , tmp ) ] ;
94225: LD_ADDR_VAR 0 2
94229: PUSH
94230: LD_VAR 0 3
94234: PUSH
94235: LD_INT 1
94237: PPUSH
94238: LD_VAR 0 3
94242: PPUSH
94243: CALL_OW 12
94247: ARRAY
94248: ST_TO_ADDR
// if Crawls ( un ) then
94249: LD_VAR 0 2
94253: PPUSH
94254: CALL_OW 318
94258: IFFALSE 94269
// ComWalk ( un ) ;
94260: LD_VAR 0 2
94264: PPUSH
94265: CALL_OW 138
// SetClass ( un , class_mortar ) ;
94269: LD_VAR 0 2
94273: PPUSH
94274: LD_INT 8
94276: PPUSH
94277: CALL_OW 336
// end ;
94281: PPOPN 3
94283: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
94284: LD_EXP 113
94288: PUSH
94289: LD_EXP 157
94293: AND
94294: IFFALSE 94438
94296: GO 94298
94298: DISABLE
94299: LD_INT 0
94301: PPUSH
94302: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
94303: LD_ADDR_VAR 0 2
94307: PUSH
94308: LD_INT 22
94310: PUSH
94311: LD_OWVAR 2
94315: PUSH
94316: EMPTY
94317: LIST
94318: LIST
94319: PUSH
94320: LD_INT 21
94322: PUSH
94323: LD_INT 2
94325: PUSH
94326: EMPTY
94327: LIST
94328: LIST
94329: PUSH
94330: LD_INT 2
94332: PUSH
94333: LD_INT 34
94335: PUSH
94336: LD_INT 12
94338: PUSH
94339: EMPTY
94340: LIST
94341: LIST
94342: PUSH
94343: LD_INT 34
94345: PUSH
94346: LD_INT 51
94348: PUSH
94349: EMPTY
94350: LIST
94351: LIST
94352: PUSH
94353: LD_INT 34
94355: PUSH
94356: LD_INT 32
94358: PUSH
94359: EMPTY
94360: LIST
94361: LIST
94362: PUSH
94363: EMPTY
94364: LIST
94365: LIST
94366: LIST
94367: LIST
94368: PUSH
94369: EMPTY
94370: LIST
94371: LIST
94372: LIST
94373: PPUSH
94374: CALL_OW 69
94378: ST_TO_ADDR
// if not tmp then
94379: LD_VAR 0 2
94383: NOT
94384: IFFALSE 94388
// exit ;
94386: GO 94438
// for i in tmp do
94388: LD_ADDR_VAR 0 1
94392: PUSH
94393: LD_VAR 0 2
94397: PUSH
94398: FOR_IN
94399: IFFALSE 94436
// if GetCargo ( i , mat_artifact ) = 0 then
94401: LD_VAR 0 1
94405: PPUSH
94406: LD_INT 4
94408: PPUSH
94409: CALL_OW 289
94413: PUSH
94414: LD_INT 0
94416: EQUAL
94417: IFFALSE 94434
// SetCargo ( i , mat_siberit , 100 ) ;
94419: LD_VAR 0 1
94423: PPUSH
94424: LD_INT 3
94426: PPUSH
94427: LD_INT 100
94429: PPUSH
94430: CALL_OW 290
94434: GO 94398
94436: POP
94437: POP
// end ;
94438: PPOPN 2
94440: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
94441: LD_EXP 113
94445: PUSH
94446: LD_EXP 158
94450: AND
94451: IFFALSE 94634
94453: GO 94455
94455: DISABLE
94456: LD_INT 0
94458: PPUSH
94459: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
94460: LD_ADDR_VAR 0 2
94464: PUSH
94465: LD_INT 22
94467: PUSH
94468: LD_OWVAR 2
94472: PUSH
94473: EMPTY
94474: LIST
94475: LIST
94476: PPUSH
94477: CALL_OW 69
94481: ST_TO_ADDR
// if not tmp then
94482: LD_VAR 0 2
94486: NOT
94487: IFFALSE 94491
// exit ;
94489: GO 94634
// for i := 1 to 2 do
94491: LD_ADDR_VAR 0 1
94495: PUSH
94496: DOUBLE
94497: LD_INT 1
94499: DEC
94500: ST_TO_ADDR
94501: LD_INT 2
94503: PUSH
94504: FOR_TO
94505: IFFALSE 94632
// begin uc_side := your_side ;
94507: LD_ADDR_OWVAR 20
94511: PUSH
94512: LD_OWVAR 2
94516: ST_TO_ADDR
// uc_nation := nation_american ;
94517: LD_ADDR_OWVAR 21
94521: PUSH
94522: LD_INT 1
94524: ST_TO_ADDR
// vc_chassis := us_morphling ;
94525: LD_ADDR_OWVAR 37
94529: PUSH
94530: LD_INT 5
94532: ST_TO_ADDR
// vc_engine := engine_siberite ;
94533: LD_ADDR_OWVAR 39
94537: PUSH
94538: LD_INT 3
94540: ST_TO_ADDR
// vc_control := control_computer ;
94541: LD_ADDR_OWVAR 38
94545: PUSH
94546: LD_INT 3
94548: ST_TO_ADDR
// vc_weapon := us_double_laser ;
94549: LD_ADDR_OWVAR 40
94553: PUSH
94554: LD_INT 10
94556: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
94557: LD_VAR 0 2
94561: PUSH
94562: LD_INT 1
94564: ARRAY
94565: PPUSH
94566: CALL_OW 310
94570: NOT
94571: IFFALSE 94618
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
94573: CALL_OW 45
94577: PPUSH
94578: LD_VAR 0 2
94582: PUSH
94583: LD_INT 1
94585: ARRAY
94586: PPUSH
94587: CALL_OW 250
94591: PPUSH
94592: LD_VAR 0 2
94596: PUSH
94597: LD_INT 1
94599: ARRAY
94600: PPUSH
94601: CALL_OW 251
94605: PPUSH
94606: LD_INT 12
94608: PPUSH
94609: LD_INT 1
94611: PPUSH
94612: CALL_OW 50
94616: GO 94630
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
94618: CALL_OW 45
94622: PPUSH
94623: LD_INT 1
94625: PPUSH
94626: CALL_OW 51
// end ;
94630: GO 94504
94632: POP
94633: POP
// end ;
94634: PPOPN 2
94636: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
94637: LD_EXP 113
94641: PUSH
94642: LD_EXP 159
94646: AND
94647: IFFALSE 94869
94649: GO 94651
94651: DISABLE
94652: LD_INT 0
94654: PPUSH
94655: PPUSH
94656: PPUSH
94657: PPUSH
94658: PPUSH
94659: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94660: LD_ADDR_VAR 0 6
94664: PUSH
94665: LD_INT 22
94667: PUSH
94668: LD_OWVAR 2
94672: PUSH
94673: EMPTY
94674: LIST
94675: LIST
94676: PUSH
94677: LD_INT 21
94679: PUSH
94680: LD_INT 1
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: PUSH
94687: LD_INT 3
94689: PUSH
94690: LD_INT 23
94692: PUSH
94693: LD_INT 0
94695: PUSH
94696: EMPTY
94697: LIST
94698: LIST
94699: PUSH
94700: EMPTY
94701: LIST
94702: LIST
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: LIST
94708: PPUSH
94709: CALL_OW 69
94713: ST_TO_ADDR
// if not tmp then
94714: LD_VAR 0 6
94718: NOT
94719: IFFALSE 94723
// exit ;
94721: GO 94869
// s1 := rand ( 1 , 4 ) ;
94723: LD_ADDR_VAR 0 2
94727: PUSH
94728: LD_INT 1
94730: PPUSH
94731: LD_INT 4
94733: PPUSH
94734: CALL_OW 12
94738: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
94739: LD_ADDR_VAR 0 4
94743: PUSH
94744: LD_VAR 0 6
94748: PUSH
94749: LD_INT 1
94751: ARRAY
94752: PPUSH
94753: LD_VAR 0 2
94757: PPUSH
94758: CALL_OW 259
94762: ST_TO_ADDR
// if s1 = 1 then
94763: LD_VAR 0 2
94767: PUSH
94768: LD_INT 1
94770: EQUAL
94771: IFFALSE 94791
// s2 := rand ( 2 , 4 ) else
94773: LD_ADDR_VAR 0 3
94777: PUSH
94778: LD_INT 2
94780: PPUSH
94781: LD_INT 4
94783: PPUSH
94784: CALL_OW 12
94788: ST_TO_ADDR
94789: GO 94799
// s2 := 1 ;
94791: LD_ADDR_VAR 0 3
94795: PUSH
94796: LD_INT 1
94798: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
94799: LD_ADDR_VAR 0 5
94803: PUSH
94804: LD_VAR 0 6
94808: PUSH
94809: LD_INT 1
94811: ARRAY
94812: PPUSH
94813: LD_VAR 0 3
94817: PPUSH
94818: CALL_OW 259
94822: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
94823: LD_VAR 0 6
94827: PUSH
94828: LD_INT 1
94830: ARRAY
94831: PPUSH
94832: LD_VAR 0 2
94836: PPUSH
94837: LD_VAR 0 5
94841: PPUSH
94842: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
94846: LD_VAR 0 6
94850: PUSH
94851: LD_INT 1
94853: ARRAY
94854: PPUSH
94855: LD_VAR 0 3
94859: PPUSH
94860: LD_VAR 0 4
94864: PPUSH
94865: CALL_OW 237
// end ;
94869: PPOPN 6
94871: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
94872: LD_EXP 113
94876: PUSH
94877: LD_EXP 160
94881: AND
94882: IFFALSE 94961
94884: GO 94886
94886: DISABLE
94887: LD_INT 0
94889: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
94890: LD_ADDR_VAR 0 1
94894: PUSH
94895: LD_INT 22
94897: PUSH
94898: LD_OWVAR 2
94902: PUSH
94903: EMPTY
94904: LIST
94905: LIST
94906: PUSH
94907: LD_INT 30
94909: PUSH
94910: LD_INT 3
94912: PUSH
94913: EMPTY
94914: LIST
94915: LIST
94916: PUSH
94917: EMPTY
94918: LIST
94919: LIST
94920: PPUSH
94921: CALL_OW 69
94925: ST_TO_ADDR
// if not tmp then
94926: LD_VAR 0 1
94930: NOT
94931: IFFALSE 94935
// exit ;
94933: GO 94961
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
94935: LD_VAR 0 1
94939: PUSH
94940: LD_INT 1
94942: PPUSH
94943: LD_VAR 0 1
94947: PPUSH
94948: CALL_OW 12
94952: ARRAY
94953: PPUSH
94954: LD_INT 1
94956: PPUSH
94957: CALL_OW 234
// end ;
94961: PPOPN 1
94963: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
94964: LD_EXP 113
94968: PUSH
94969: LD_EXP 161
94973: AND
94974: IFFALSE 95086
94976: GO 94978
94978: DISABLE
94979: LD_INT 0
94981: PPUSH
94982: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
94983: LD_ADDR_VAR 0 2
94987: PUSH
94988: LD_INT 22
94990: PUSH
94991: LD_OWVAR 2
94995: PUSH
94996: EMPTY
94997: LIST
94998: LIST
94999: PUSH
95000: LD_INT 2
95002: PUSH
95003: LD_INT 30
95005: PUSH
95006: LD_INT 27
95008: PUSH
95009: EMPTY
95010: LIST
95011: LIST
95012: PUSH
95013: LD_INT 30
95015: PUSH
95016: LD_INT 26
95018: PUSH
95019: EMPTY
95020: LIST
95021: LIST
95022: PUSH
95023: LD_INT 30
95025: PUSH
95026: LD_INT 28
95028: PUSH
95029: EMPTY
95030: LIST
95031: LIST
95032: PUSH
95033: EMPTY
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: PUSH
95039: EMPTY
95040: LIST
95041: LIST
95042: PPUSH
95043: CALL_OW 69
95047: ST_TO_ADDR
// if not tmp then
95048: LD_VAR 0 2
95052: NOT
95053: IFFALSE 95057
// exit ;
95055: GO 95086
// for i in tmp do
95057: LD_ADDR_VAR 0 1
95061: PUSH
95062: LD_VAR 0 2
95066: PUSH
95067: FOR_IN
95068: IFFALSE 95084
// SetLives ( i , 1 ) ;
95070: LD_VAR 0 1
95074: PPUSH
95075: LD_INT 1
95077: PPUSH
95078: CALL_OW 234
95082: GO 95067
95084: POP
95085: POP
// end ;
95086: PPOPN 2
95088: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
95089: LD_EXP 113
95093: PUSH
95094: LD_EXP 162
95098: AND
95099: IFFALSE 95386
95101: GO 95103
95103: DISABLE
95104: LD_INT 0
95106: PPUSH
95107: PPUSH
95108: PPUSH
// begin i := rand ( 1 , 7 ) ;
95109: LD_ADDR_VAR 0 1
95113: PUSH
95114: LD_INT 1
95116: PPUSH
95117: LD_INT 7
95119: PPUSH
95120: CALL_OW 12
95124: ST_TO_ADDR
// case i of 1 :
95125: LD_VAR 0 1
95129: PUSH
95130: LD_INT 1
95132: DOUBLE
95133: EQUAL
95134: IFTRUE 95138
95136: GO 95148
95138: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
95139: LD_STRING earthquake(getX(game), 0, 32)
95141: PPUSH
95142: CALL_OW 559
95146: GO 95386
95148: LD_INT 2
95150: DOUBLE
95151: EQUAL
95152: IFTRUE 95156
95154: GO 95170
95156: POP
// begin ToLua ( displayStucuk(); ) ;
95157: LD_STRING displayStucuk();
95159: PPUSH
95160: CALL_OW 559
// ResetFog ;
95164: CALL_OW 335
// end ; 3 :
95168: GO 95386
95170: LD_INT 3
95172: DOUBLE
95173: EQUAL
95174: IFTRUE 95178
95176: GO 95282
95178: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95179: LD_ADDR_VAR 0 2
95183: PUSH
95184: LD_INT 22
95186: PUSH
95187: LD_OWVAR 2
95191: PUSH
95192: EMPTY
95193: LIST
95194: LIST
95195: PUSH
95196: LD_INT 25
95198: PUSH
95199: LD_INT 1
95201: PUSH
95202: EMPTY
95203: LIST
95204: LIST
95205: PUSH
95206: EMPTY
95207: LIST
95208: LIST
95209: PPUSH
95210: CALL_OW 69
95214: ST_TO_ADDR
// if not tmp then
95215: LD_VAR 0 2
95219: NOT
95220: IFFALSE 95224
// exit ;
95222: GO 95386
// un := tmp [ rand ( 1 , tmp ) ] ;
95224: LD_ADDR_VAR 0 3
95228: PUSH
95229: LD_VAR 0 2
95233: PUSH
95234: LD_INT 1
95236: PPUSH
95237: LD_VAR 0 2
95241: PPUSH
95242: CALL_OW 12
95246: ARRAY
95247: ST_TO_ADDR
// if Crawls ( un ) then
95248: LD_VAR 0 3
95252: PPUSH
95253: CALL_OW 318
95257: IFFALSE 95268
// ComWalk ( un ) ;
95259: LD_VAR 0 3
95263: PPUSH
95264: CALL_OW 138
// SetClass ( un , class_mortar ) ;
95268: LD_VAR 0 3
95272: PPUSH
95273: LD_INT 8
95275: PPUSH
95276: CALL_OW 336
// end ; 4 :
95280: GO 95386
95282: LD_INT 4
95284: DOUBLE
95285: EQUAL
95286: IFTRUE 95290
95288: GO 95364
95290: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95291: LD_ADDR_VAR 0 2
95295: PUSH
95296: LD_INT 22
95298: PUSH
95299: LD_OWVAR 2
95303: PUSH
95304: EMPTY
95305: LIST
95306: LIST
95307: PUSH
95308: LD_INT 30
95310: PUSH
95311: LD_INT 29
95313: PUSH
95314: EMPTY
95315: LIST
95316: LIST
95317: PUSH
95318: EMPTY
95319: LIST
95320: LIST
95321: PPUSH
95322: CALL_OW 69
95326: ST_TO_ADDR
// if not tmp then
95327: LD_VAR 0 2
95331: NOT
95332: IFFALSE 95336
// exit ;
95334: GO 95386
// CenterNowOnUnits ( tmp [ 1 ] ) ;
95336: LD_VAR 0 2
95340: PUSH
95341: LD_INT 1
95343: ARRAY
95344: PPUSH
95345: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
95349: LD_VAR 0 2
95353: PUSH
95354: LD_INT 1
95356: ARRAY
95357: PPUSH
95358: CALL_OW 65
// end ; 5 .. 7 :
95362: GO 95386
95364: LD_INT 5
95366: DOUBLE
95367: GREATEREQUAL
95368: IFFALSE 95376
95370: LD_INT 7
95372: DOUBLE
95373: LESSEQUAL
95374: IFTRUE 95378
95376: GO 95385
95378: POP
// StreamSibBomb ; end ;
95379: CALL 91623 0 0
95383: GO 95386
95385: POP
// end ;
95386: PPOPN 3
95388: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
95389: LD_EXP 113
95393: PUSH
95394: LD_EXP 163
95398: AND
95399: IFFALSE 95555
95401: GO 95403
95403: DISABLE
95404: LD_INT 0
95406: PPUSH
95407: PPUSH
95408: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
95409: LD_ADDR_VAR 0 2
95413: PUSH
95414: LD_INT 81
95416: PUSH
95417: LD_OWVAR 2
95421: PUSH
95422: EMPTY
95423: LIST
95424: LIST
95425: PUSH
95426: LD_INT 2
95428: PUSH
95429: LD_INT 21
95431: PUSH
95432: LD_INT 1
95434: PUSH
95435: EMPTY
95436: LIST
95437: LIST
95438: PUSH
95439: LD_INT 21
95441: PUSH
95442: LD_INT 2
95444: PUSH
95445: EMPTY
95446: LIST
95447: LIST
95448: PUSH
95449: EMPTY
95450: LIST
95451: LIST
95452: LIST
95453: PUSH
95454: EMPTY
95455: LIST
95456: LIST
95457: PPUSH
95458: CALL_OW 69
95462: ST_TO_ADDR
// if not tmp then
95463: LD_VAR 0 2
95467: NOT
95468: IFFALSE 95472
// exit ;
95470: GO 95555
// p := 0 ;
95472: LD_ADDR_VAR 0 3
95476: PUSH
95477: LD_INT 0
95479: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
95480: LD_INT 35
95482: PPUSH
95483: CALL_OW 67
// p := p + 1 ;
95487: LD_ADDR_VAR 0 3
95491: PUSH
95492: LD_VAR 0 3
95496: PUSH
95497: LD_INT 1
95499: PLUS
95500: ST_TO_ADDR
// for i in tmp do
95501: LD_ADDR_VAR 0 1
95505: PUSH
95506: LD_VAR 0 2
95510: PUSH
95511: FOR_IN
95512: IFFALSE 95543
// if GetLives ( i ) < 1000 then
95514: LD_VAR 0 1
95518: PPUSH
95519: CALL_OW 256
95523: PUSH
95524: LD_INT 1000
95526: LESS
95527: IFFALSE 95541
// SetLives ( i , 1000 ) ;
95529: LD_VAR 0 1
95533: PPUSH
95534: LD_INT 1000
95536: PPUSH
95537: CALL_OW 234
95541: GO 95511
95543: POP
95544: POP
// until p > 20 ;
95545: LD_VAR 0 3
95549: PUSH
95550: LD_INT 20
95552: GREATER
95553: IFFALSE 95480
// end ;
95555: PPOPN 3
95557: END
// every 0 0$1 trigger StreamModeActive and sTime do
95558: LD_EXP 113
95562: PUSH
95563: LD_EXP 164
95567: AND
95568: IFFALSE 95603
95570: GO 95572
95572: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
95573: LD_INT 28
95575: PPUSH
95576: LD_OWVAR 2
95580: PPUSH
95581: LD_INT 2
95583: PPUSH
95584: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
95588: LD_INT 30
95590: PPUSH
95591: LD_OWVAR 2
95595: PPUSH
95596: LD_INT 2
95598: PPUSH
95599: CALL_OW 322
// end ;
95603: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
95604: LD_EXP 113
95608: PUSH
95609: LD_EXP 165
95613: AND
95614: IFFALSE 95735
95616: GO 95618
95618: DISABLE
95619: LD_INT 0
95621: PPUSH
95622: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95623: LD_ADDR_VAR 0 2
95627: PUSH
95628: LD_INT 22
95630: PUSH
95631: LD_OWVAR 2
95635: PUSH
95636: EMPTY
95637: LIST
95638: LIST
95639: PUSH
95640: LD_INT 21
95642: PUSH
95643: LD_INT 1
95645: PUSH
95646: EMPTY
95647: LIST
95648: LIST
95649: PUSH
95650: LD_INT 3
95652: PUSH
95653: LD_INT 23
95655: PUSH
95656: LD_INT 0
95658: PUSH
95659: EMPTY
95660: LIST
95661: LIST
95662: PUSH
95663: EMPTY
95664: LIST
95665: LIST
95666: PUSH
95667: EMPTY
95668: LIST
95669: LIST
95670: LIST
95671: PPUSH
95672: CALL_OW 69
95676: ST_TO_ADDR
// if not tmp then
95677: LD_VAR 0 2
95681: NOT
95682: IFFALSE 95686
// exit ;
95684: GO 95735
// for i in tmp do
95686: LD_ADDR_VAR 0 1
95690: PUSH
95691: LD_VAR 0 2
95695: PUSH
95696: FOR_IN
95697: IFFALSE 95733
// begin if Crawls ( i ) then
95699: LD_VAR 0 1
95703: PPUSH
95704: CALL_OW 318
95708: IFFALSE 95719
// ComWalk ( i ) ;
95710: LD_VAR 0 1
95714: PPUSH
95715: CALL_OW 138
// SetClass ( i , 2 ) ;
95719: LD_VAR 0 1
95723: PPUSH
95724: LD_INT 2
95726: PPUSH
95727: CALL_OW 336
// end ;
95731: GO 95696
95733: POP
95734: POP
// end ;
95735: PPOPN 2
95737: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
95738: LD_EXP 113
95742: PUSH
95743: LD_EXP 166
95747: AND
95748: IFFALSE 96036
95750: GO 95752
95752: DISABLE
95753: LD_INT 0
95755: PPUSH
95756: PPUSH
95757: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
95758: LD_OWVAR 2
95762: PPUSH
95763: LD_INT 9
95765: PPUSH
95766: LD_INT 1
95768: PPUSH
95769: LD_INT 1
95771: PPUSH
95772: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
95776: LD_INT 9
95778: PPUSH
95779: LD_OWVAR 2
95783: PPUSH
95784: CALL_OW 343
// uc_side := 9 ;
95788: LD_ADDR_OWVAR 20
95792: PUSH
95793: LD_INT 9
95795: ST_TO_ADDR
// uc_nation := 2 ;
95796: LD_ADDR_OWVAR 21
95800: PUSH
95801: LD_INT 2
95803: ST_TO_ADDR
// hc_name := Dark Warrior ;
95804: LD_ADDR_OWVAR 26
95808: PUSH
95809: LD_STRING Dark Warrior
95811: ST_TO_ADDR
// hc_gallery :=  ;
95812: LD_ADDR_OWVAR 33
95816: PUSH
95817: LD_STRING 
95819: ST_TO_ADDR
// hc_noskilllimit := true ;
95820: LD_ADDR_OWVAR 76
95824: PUSH
95825: LD_INT 1
95827: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
95828: LD_ADDR_OWVAR 31
95832: PUSH
95833: LD_INT 30
95835: PUSH
95836: LD_INT 30
95838: PUSH
95839: LD_INT 30
95841: PUSH
95842: LD_INT 30
95844: PUSH
95845: EMPTY
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: ST_TO_ADDR
// un := CreateHuman ;
95851: LD_ADDR_VAR 0 3
95855: PUSH
95856: CALL_OW 44
95860: ST_TO_ADDR
// hc_noskilllimit := false ;
95861: LD_ADDR_OWVAR 76
95865: PUSH
95866: LD_INT 0
95868: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95869: LD_VAR 0 3
95873: PPUSH
95874: LD_INT 1
95876: PPUSH
95877: CALL_OW 51
// ToLua ( playRanger() ) ;
95881: LD_STRING playRanger()
95883: PPUSH
95884: CALL_OW 559
// p := 0 ;
95888: LD_ADDR_VAR 0 2
95892: PUSH
95893: LD_INT 0
95895: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
95896: LD_INT 35
95898: PPUSH
95899: CALL_OW 67
// p := p + 1 ;
95903: LD_ADDR_VAR 0 2
95907: PUSH
95908: LD_VAR 0 2
95912: PUSH
95913: LD_INT 1
95915: PLUS
95916: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
95917: LD_VAR 0 3
95921: PPUSH
95922: CALL_OW 256
95926: PUSH
95927: LD_INT 1000
95929: LESS
95930: IFFALSE 95944
// SetLives ( un , 1000 ) ;
95932: LD_VAR 0 3
95936: PPUSH
95937: LD_INT 1000
95939: PPUSH
95940: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
95944: LD_VAR 0 3
95948: PPUSH
95949: LD_INT 81
95951: PUSH
95952: LD_OWVAR 2
95956: PUSH
95957: EMPTY
95958: LIST
95959: LIST
95960: PUSH
95961: LD_INT 91
95963: PUSH
95964: LD_VAR 0 3
95968: PUSH
95969: LD_INT 30
95971: PUSH
95972: EMPTY
95973: LIST
95974: LIST
95975: LIST
95976: PUSH
95977: EMPTY
95978: LIST
95979: LIST
95980: PPUSH
95981: CALL_OW 69
95985: PPUSH
95986: LD_VAR 0 3
95990: PPUSH
95991: CALL_OW 74
95995: PPUSH
95996: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
96000: LD_VAR 0 2
96004: PUSH
96005: LD_INT 80
96007: GREATER
96008: PUSH
96009: LD_VAR 0 3
96013: PPUSH
96014: CALL_OW 301
96018: OR
96019: IFFALSE 95896
// if un then
96021: LD_VAR 0 3
96025: IFFALSE 96036
// RemoveUnit ( un ) ;
96027: LD_VAR 0 3
96031: PPUSH
96032: CALL_OW 64
// end ;
96036: PPOPN 3
96038: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
96039: LD_EXP 167
96043: IFFALSE 96159
96045: GO 96047
96047: DISABLE
96048: LD_INT 0
96050: PPUSH
96051: PPUSH
96052: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96053: LD_ADDR_VAR 0 2
96057: PUSH
96058: LD_INT 81
96060: PUSH
96061: LD_OWVAR 2
96065: PUSH
96066: EMPTY
96067: LIST
96068: LIST
96069: PUSH
96070: LD_INT 21
96072: PUSH
96073: LD_INT 1
96075: PUSH
96076: EMPTY
96077: LIST
96078: LIST
96079: PUSH
96080: EMPTY
96081: LIST
96082: LIST
96083: PPUSH
96084: CALL_OW 69
96088: ST_TO_ADDR
// ToLua ( playComputer() ) ;
96089: LD_STRING playComputer()
96091: PPUSH
96092: CALL_OW 559
// if not tmp then
96096: LD_VAR 0 2
96100: NOT
96101: IFFALSE 96105
// exit ;
96103: GO 96159
// for i in tmp do
96105: LD_ADDR_VAR 0 1
96109: PUSH
96110: LD_VAR 0 2
96114: PUSH
96115: FOR_IN
96116: IFFALSE 96157
// for j := 1 to 4 do
96118: LD_ADDR_VAR 0 3
96122: PUSH
96123: DOUBLE
96124: LD_INT 1
96126: DEC
96127: ST_TO_ADDR
96128: LD_INT 4
96130: PUSH
96131: FOR_TO
96132: IFFALSE 96153
// SetSkill ( i , j , 10 ) ;
96134: LD_VAR 0 1
96138: PPUSH
96139: LD_VAR 0 3
96143: PPUSH
96144: LD_INT 10
96146: PPUSH
96147: CALL_OW 237
96151: GO 96131
96153: POP
96154: POP
96155: GO 96115
96157: POP
96158: POP
// end ;
96159: PPOPN 3
96161: END
// every 0 0$1 trigger s30 do var i , tmp ;
96162: LD_EXP 168
96166: IFFALSE 96235
96168: GO 96170
96170: DISABLE
96171: LD_INT 0
96173: PPUSH
96174: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96175: LD_ADDR_VAR 0 2
96179: PUSH
96180: LD_INT 22
96182: PUSH
96183: LD_OWVAR 2
96187: PUSH
96188: EMPTY
96189: LIST
96190: LIST
96191: PPUSH
96192: CALL_OW 69
96196: ST_TO_ADDR
// if not tmp then
96197: LD_VAR 0 2
96201: NOT
96202: IFFALSE 96206
// exit ;
96204: GO 96235
// for i in tmp do
96206: LD_ADDR_VAR 0 1
96210: PUSH
96211: LD_VAR 0 2
96215: PUSH
96216: FOR_IN
96217: IFFALSE 96233
// SetLives ( i , 300 ) ;
96219: LD_VAR 0 1
96223: PPUSH
96224: LD_INT 300
96226: PPUSH
96227: CALL_OW 234
96231: GO 96216
96233: POP
96234: POP
// end ;
96235: PPOPN 2
96237: END
// every 0 0$1 trigger s60 do var i , tmp ;
96238: LD_EXP 169
96242: IFFALSE 96311
96244: GO 96246
96246: DISABLE
96247: LD_INT 0
96249: PPUSH
96250: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96251: LD_ADDR_VAR 0 2
96255: PUSH
96256: LD_INT 22
96258: PUSH
96259: LD_OWVAR 2
96263: PUSH
96264: EMPTY
96265: LIST
96266: LIST
96267: PPUSH
96268: CALL_OW 69
96272: ST_TO_ADDR
// if not tmp then
96273: LD_VAR 0 2
96277: NOT
96278: IFFALSE 96282
// exit ;
96280: GO 96311
// for i in tmp do
96282: LD_ADDR_VAR 0 1
96286: PUSH
96287: LD_VAR 0 2
96291: PUSH
96292: FOR_IN
96293: IFFALSE 96309
// SetLives ( i , 600 ) ;
96295: LD_VAR 0 1
96299: PPUSH
96300: LD_INT 600
96302: PPUSH
96303: CALL_OW 234
96307: GO 96292
96309: POP
96310: POP
// end ;
96311: PPOPN 2
96313: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
96314: LD_INT 0
96316: PPUSH
// case cmd of 301 :
96317: LD_VAR 0 1
96321: PUSH
96322: LD_INT 301
96324: DOUBLE
96325: EQUAL
96326: IFTRUE 96330
96328: GO 96362
96330: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
96331: LD_VAR 0 6
96335: PPUSH
96336: LD_VAR 0 7
96340: PPUSH
96341: LD_VAR 0 8
96345: PPUSH
96346: LD_VAR 0 4
96350: PPUSH
96351: LD_VAR 0 5
96355: PPUSH
96356: CALL 97563 0 5
96360: GO 96483
96362: LD_INT 302
96364: DOUBLE
96365: EQUAL
96366: IFTRUE 96370
96368: GO 96407
96370: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
96371: LD_VAR 0 6
96375: PPUSH
96376: LD_VAR 0 7
96380: PPUSH
96381: LD_VAR 0 8
96385: PPUSH
96386: LD_VAR 0 9
96390: PPUSH
96391: LD_VAR 0 4
96395: PPUSH
96396: LD_VAR 0 5
96400: PPUSH
96401: CALL 97654 0 6
96405: GO 96483
96407: LD_INT 303
96409: DOUBLE
96410: EQUAL
96411: IFTRUE 96415
96413: GO 96452
96415: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
96416: LD_VAR 0 6
96420: PPUSH
96421: LD_VAR 0 7
96425: PPUSH
96426: LD_VAR 0 8
96430: PPUSH
96431: LD_VAR 0 9
96435: PPUSH
96436: LD_VAR 0 4
96440: PPUSH
96441: LD_VAR 0 5
96445: PPUSH
96446: CALL 96488 0 6
96450: GO 96483
96452: LD_INT 304
96454: DOUBLE
96455: EQUAL
96456: IFTRUE 96460
96458: GO 96482
96460: POP
// hHackTeleport ( unit , x , y ) ; end ;
96461: LD_VAR 0 2
96465: PPUSH
96466: LD_VAR 0 4
96470: PPUSH
96471: LD_VAR 0 5
96475: PPUSH
96476: CALL 98247 0 3
96480: GO 96483
96482: POP
// end ;
96483: LD_VAR 0 12
96487: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
96488: LD_INT 0
96490: PPUSH
96491: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
96492: LD_VAR 0 1
96496: PUSH
96497: LD_INT 1
96499: LESS
96500: PUSH
96501: LD_VAR 0 1
96505: PUSH
96506: LD_INT 3
96508: GREATER
96509: OR
96510: PUSH
96511: LD_VAR 0 5
96515: PPUSH
96516: LD_VAR 0 6
96520: PPUSH
96521: CALL_OW 428
96525: OR
96526: IFFALSE 96530
// exit ;
96528: GO 97250
// uc_side := your_side ;
96530: LD_ADDR_OWVAR 20
96534: PUSH
96535: LD_OWVAR 2
96539: ST_TO_ADDR
// uc_nation := nation ;
96540: LD_ADDR_OWVAR 21
96544: PUSH
96545: LD_VAR 0 1
96549: ST_TO_ADDR
// bc_level = 1 ;
96550: LD_ADDR_OWVAR 43
96554: PUSH
96555: LD_INT 1
96557: ST_TO_ADDR
// case btype of 1 :
96558: LD_VAR 0 2
96562: PUSH
96563: LD_INT 1
96565: DOUBLE
96566: EQUAL
96567: IFTRUE 96571
96569: GO 96582
96571: POP
// bc_type := b_depot ; 2 :
96572: LD_ADDR_OWVAR 42
96576: PUSH
96577: LD_INT 0
96579: ST_TO_ADDR
96580: GO 97194
96582: LD_INT 2
96584: DOUBLE
96585: EQUAL
96586: IFTRUE 96590
96588: GO 96601
96590: POP
// bc_type := b_warehouse ; 3 :
96591: LD_ADDR_OWVAR 42
96595: PUSH
96596: LD_INT 1
96598: ST_TO_ADDR
96599: GO 97194
96601: LD_INT 3
96603: DOUBLE
96604: EQUAL
96605: IFTRUE 96609
96607: GO 96620
96609: POP
// bc_type := b_lab ; 4 .. 9 :
96610: LD_ADDR_OWVAR 42
96614: PUSH
96615: LD_INT 6
96617: ST_TO_ADDR
96618: GO 97194
96620: LD_INT 4
96622: DOUBLE
96623: GREATEREQUAL
96624: IFFALSE 96632
96626: LD_INT 9
96628: DOUBLE
96629: LESSEQUAL
96630: IFTRUE 96634
96632: GO 96686
96634: POP
// begin bc_type := b_lab_half ;
96635: LD_ADDR_OWVAR 42
96639: PUSH
96640: LD_INT 7
96642: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
96643: LD_ADDR_OWVAR 44
96647: PUSH
96648: LD_INT 10
96650: PUSH
96651: LD_INT 11
96653: PUSH
96654: LD_INT 12
96656: PUSH
96657: LD_INT 15
96659: PUSH
96660: LD_INT 14
96662: PUSH
96663: LD_INT 13
96665: PUSH
96666: EMPTY
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: PUSH
96674: LD_VAR 0 2
96678: PUSH
96679: LD_INT 3
96681: MINUS
96682: ARRAY
96683: ST_TO_ADDR
// end ; 10 .. 13 :
96684: GO 97194
96686: LD_INT 10
96688: DOUBLE
96689: GREATEREQUAL
96690: IFFALSE 96698
96692: LD_INT 13
96694: DOUBLE
96695: LESSEQUAL
96696: IFTRUE 96700
96698: GO 96777
96700: POP
// begin bc_type := b_lab_full ;
96701: LD_ADDR_OWVAR 42
96705: PUSH
96706: LD_INT 8
96708: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
96709: LD_ADDR_OWVAR 44
96713: PUSH
96714: LD_INT 10
96716: PUSH
96717: LD_INT 12
96719: PUSH
96720: LD_INT 14
96722: PUSH
96723: LD_INT 13
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: PUSH
96732: LD_VAR 0 2
96736: PUSH
96737: LD_INT 9
96739: MINUS
96740: ARRAY
96741: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
96742: LD_ADDR_OWVAR 45
96746: PUSH
96747: LD_INT 11
96749: PUSH
96750: LD_INT 15
96752: PUSH
96753: LD_INT 12
96755: PUSH
96756: LD_INT 15
96758: PUSH
96759: EMPTY
96760: LIST
96761: LIST
96762: LIST
96763: LIST
96764: PUSH
96765: LD_VAR 0 2
96769: PUSH
96770: LD_INT 9
96772: MINUS
96773: ARRAY
96774: ST_TO_ADDR
// end ; 14 :
96775: GO 97194
96777: LD_INT 14
96779: DOUBLE
96780: EQUAL
96781: IFTRUE 96785
96783: GO 96796
96785: POP
// bc_type := b_workshop ; 15 :
96786: LD_ADDR_OWVAR 42
96790: PUSH
96791: LD_INT 2
96793: ST_TO_ADDR
96794: GO 97194
96796: LD_INT 15
96798: DOUBLE
96799: EQUAL
96800: IFTRUE 96804
96802: GO 96815
96804: POP
// bc_type := b_factory ; 16 :
96805: LD_ADDR_OWVAR 42
96809: PUSH
96810: LD_INT 3
96812: ST_TO_ADDR
96813: GO 97194
96815: LD_INT 16
96817: DOUBLE
96818: EQUAL
96819: IFTRUE 96823
96821: GO 96834
96823: POP
// bc_type := b_ext_gun ; 17 :
96824: LD_ADDR_OWVAR 42
96828: PUSH
96829: LD_INT 17
96831: ST_TO_ADDR
96832: GO 97194
96834: LD_INT 17
96836: DOUBLE
96837: EQUAL
96838: IFTRUE 96842
96840: GO 96870
96842: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
96843: LD_ADDR_OWVAR 42
96847: PUSH
96848: LD_INT 19
96850: PUSH
96851: LD_INT 23
96853: PUSH
96854: LD_INT 19
96856: PUSH
96857: EMPTY
96858: LIST
96859: LIST
96860: LIST
96861: PUSH
96862: LD_VAR 0 1
96866: ARRAY
96867: ST_TO_ADDR
96868: GO 97194
96870: LD_INT 18
96872: DOUBLE
96873: EQUAL
96874: IFTRUE 96878
96876: GO 96889
96878: POP
// bc_type := b_ext_radar ; 19 :
96879: LD_ADDR_OWVAR 42
96883: PUSH
96884: LD_INT 20
96886: ST_TO_ADDR
96887: GO 97194
96889: LD_INT 19
96891: DOUBLE
96892: EQUAL
96893: IFTRUE 96897
96895: GO 96908
96897: POP
// bc_type := b_ext_radio ; 20 :
96898: LD_ADDR_OWVAR 42
96902: PUSH
96903: LD_INT 22
96905: ST_TO_ADDR
96906: GO 97194
96908: LD_INT 20
96910: DOUBLE
96911: EQUAL
96912: IFTRUE 96916
96914: GO 96927
96916: POP
// bc_type := b_ext_siberium ; 21 :
96917: LD_ADDR_OWVAR 42
96921: PUSH
96922: LD_INT 21
96924: ST_TO_ADDR
96925: GO 97194
96927: LD_INT 21
96929: DOUBLE
96930: EQUAL
96931: IFTRUE 96935
96933: GO 96946
96935: POP
// bc_type := b_ext_computer ; 22 :
96936: LD_ADDR_OWVAR 42
96940: PUSH
96941: LD_INT 24
96943: ST_TO_ADDR
96944: GO 97194
96946: LD_INT 22
96948: DOUBLE
96949: EQUAL
96950: IFTRUE 96954
96952: GO 96965
96954: POP
// bc_type := b_ext_track ; 23 :
96955: LD_ADDR_OWVAR 42
96959: PUSH
96960: LD_INT 16
96962: ST_TO_ADDR
96963: GO 97194
96965: LD_INT 23
96967: DOUBLE
96968: EQUAL
96969: IFTRUE 96973
96971: GO 96984
96973: POP
// bc_type := b_ext_laser ; 24 :
96974: LD_ADDR_OWVAR 42
96978: PUSH
96979: LD_INT 25
96981: ST_TO_ADDR
96982: GO 97194
96984: LD_INT 24
96986: DOUBLE
96987: EQUAL
96988: IFTRUE 96992
96990: GO 97003
96992: POP
// bc_type := b_control_tower ; 25 :
96993: LD_ADDR_OWVAR 42
96997: PUSH
96998: LD_INT 36
97000: ST_TO_ADDR
97001: GO 97194
97003: LD_INT 25
97005: DOUBLE
97006: EQUAL
97007: IFTRUE 97011
97009: GO 97022
97011: POP
// bc_type := b_breastwork ; 26 :
97012: LD_ADDR_OWVAR 42
97016: PUSH
97017: LD_INT 31
97019: ST_TO_ADDR
97020: GO 97194
97022: LD_INT 26
97024: DOUBLE
97025: EQUAL
97026: IFTRUE 97030
97028: GO 97041
97030: POP
// bc_type := b_bunker ; 27 :
97031: LD_ADDR_OWVAR 42
97035: PUSH
97036: LD_INT 32
97038: ST_TO_ADDR
97039: GO 97194
97041: LD_INT 27
97043: DOUBLE
97044: EQUAL
97045: IFTRUE 97049
97047: GO 97060
97049: POP
// bc_type := b_turret ; 28 :
97050: LD_ADDR_OWVAR 42
97054: PUSH
97055: LD_INT 33
97057: ST_TO_ADDR
97058: GO 97194
97060: LD_INT 28
97062: DOUBLE
97063: EQUAL
97064: IFTRUE 97068
97066: GO 97079
97068: POP
// bc_type := b_armoury ; 29 :
97069: LD_ADDR_OWVAR 42
97073: PUSH
97074: LD_INT 4
97076: ST_TO_ADDR
97077: GO 97194
97079: LD_INT 29
97081: DOUBLE
97082: EQUAL
97083: IFTRUE 97087
97085: GO 97098
97087: POP
// bc_type := b_barracks ; 30 :
97088: LD_ADDR_OWVAR 42
97092: PUSH
97093: LD_INT 5
97095: ST_TO_ADDR
97096: GO 97194
97098: LD_INT 30
97100: DOUBLE
97101: EQUAL
97102: IFTRUE 97106
97104: GO 97117
97106: POP
// bc_type := b_solar_power ; 31 :
97107: LD_ADDR_OWVAR 42
97111: PUSH
97112: LD_INT 27
97114: ST_TO_ADDR
97115: GO 97194
97117: LD_INT 31
97119: DOUBLE
97120: EQUAL
97121: IFTRUE 97125
97123: GO 97136
97125: POP
// bc_type := b_oil_power ; 32 :
97126: LD_ADDR_OWVAR 42
97130: PUSH
97131: LD_INT 26
97133: ST_TO_ADDR
97134: GO 97194
97136: LD_INT 32
97138: DOUBLE
97139: EQUAL
97140: IFTRUE 97144
97142: GO 97155
97144: POP
// bc_type := b_siberite_power ; 33 :
97145: LD_ADDR_OWVAR 42
97149: PUSH
97150: LD_INT 28
97152: ST_TO_ADDR
97153: GO 97194
97155: LD_INT 33
97157: DOUBLE
97158: EQUAL
97159: IFTRUE 97163
97161: GO 97174
97163: POP
// bc_type := b_oil_mine ; 34 :
97164: LD_ADDR_OWVAR 42
97168: PUSH
97169: LD_INT 29
97171: ST_TO_ADDR
97172: GO 97194
97174: LD_INT 34
97176: DOUBLE
97177: EQUAL
97178: IFTRUE 97182
97180: GO 97193
97182: POP
// bc_type := b_siberite_mine ; end ;
97183: LD_ADDR_OWVAR 42
97187: PUSH
97188: LD_INT 30
97190: ST_TO_ADDR
97191: GO 97194
97193: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
97194: LD_ADDR_VAR 0 8
97198: PUSH
97199: LD_VAR 0 5
97203: PPUSH
97204: LD_VAR 0 6
97208: PPUSH
97209: LD_VAR 0 3
97213: PPUSH
97214: CALL_OW 47
97218: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
97219: LD_OWVAR 42
97223: PUSH
97224: LD_INT 32
97226: PUSH
97227: LD_INT 33
97229: PUSH
97230: EMPTY
97231: LIST
97232: LIST
97233: IN
97234: IFFALSE 97250
// PlaceWeaponTurret ( b , weapon ) ;
97236: LD_VAR 0 8
97240: PPUSH
97241: LD_VAR 0 4
97245: PPUSH
97246: CALL_OW 431
// end ;
97250: LD_VAR 0 7
97254: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
97255: LD_INT 0
97257: PPUSH
97258: PPUSH
97259: PPUSH
97260: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97261: LD_ADDR_VAR 0 4
97265: PUSH
97266: LD_INT 22
97268: PUSH
97269: LD_OWVAR 2
97273: PUSH
97274: EMPTY
97275: LIST
97276: LIST
97277: PUSH
97278: LD_INT 2
97280: PUSH
97281: LD_INT 30
97283: PUSH
97284: LD_INT 0
97286: PUSH
97287: EMPTY
97288: LIST
97289: LIST
97290: PUSH
97291: LD_INT 30
97293: PUSH
97294: LD_INT 1
97296: PUSH
97297: EMPTY
97298: LIST
97299: LIST
97300: PUSH
97301: EMPTY
97302: LIST
97303: LIST
97304: LIST
97305: PUSH
97306: EMPTY
97307: LIST
97308: LIST
97309: PPUSH
97310: CALL_OW 69
97314: ST_TO_ADDR
// if not tmp then
97315: LD_VAR 0 4
97319: NOT
97320: IFFALSE 97324
// exit ;
97322: GO 97383
// for i in tmp do
97324: LD_ADDR_VAR 0 2
97328: PUSH
97329: LD_VAR 0 4
97333: PUSH
97334: FOR_IN
97335: IFFALSE 97381
// for j = 1 to 3 do
97337: LD_ADDR_VAR 0 3
97341: PUSH
97342: DOUBLE
97343: LD_INT 1
97345: DEC
97346: ST_TO_ADDR
97347: LD_INT 3
97349: PUSH
97350: FOR_TO
97351: IFFALSE 97377
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
97353: LD_VAR 0 2
97357: PPUSH
97358: CALL_OW 274
97362: PPUSH
97363: LD_VAR 0 3
97367: PPUSH
97368: LD_INT 99999
97370: PPUSH
97371: CALL_OW 277
97375: GO 97350
97377: POP
97378: POP
97379: GO 97334
97381: POP
97382: POP
// end ;
97383: LD_VAR 0 1
97387: RET
// export function hHackSetLevel10 ; var i , j ; begin
97388: LD_INT 0
97390: PPUSH
97391: PPUSH
97392: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
97393: LD_ADDR_VAR 0 2
97397: PUSH
97398: LD_INT 21
97400: PUSH
97401: LD_INT 1
97403: PUSH
97404: EMPTY
97405: LIST
97406: LIST
97407: PPUSH
97408: CALL_OW 69
97412: PUSH
97413: FOR_IN
97414: IFFALSE 97466
// if IsSelected ( i ) then
97416: LD_VAR 0 2
97420: PPUSH
97421: CALL_OW 306
97425: IFFALSE 97464
// begin for j := 1 to 4 do
97427: LD_ADDR_VAR 0 3
97431: PUSH
97432: DOUBLE
97433: LD_INT 1
97435: DEC
97436: ST_TO_ADDR
97437: LD_INT 4
97439: PUSH
97440: FOR_TO
97441: IFFALSE 97462
// SetSkill ( i , j , 10 ) ;
97443: LD_VAR 0 2
97447: PPUSH
97448: LD_VAR 0 3
97452: PPUSH
97453: LD_INT 10
97455: PPUSH
97456: CALL_OW 237
97460: GO 97440
97462: POP
97463: POP
// end ;
97464: GO 97413
97466: POP
97467: POP
// end ;
97468: LD_VAR 0 1
97472: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
97473: LD_INT 0
97475: PPUSH
97476: PPUSH
97477: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
97478: LD_ADDR_VAR 0 2
97482: PUSH
97483: LD_INT 22
97485: PUSH
97486: LD_OWVAR 2
97490: PUSH
97491: EMPTY
97492: LIST
97493: LIST
97494: PUSH
97495: LD_INT 21
97497: PUSH
97498: LD_INT 1
97500: PUSH
97501: EMPTY
97502: LIST
97503: LIST
97504: PUSH
97505: EMPTY
97506: LIST
97507: LIST
97508: PPUSH
97509: CALL_OW 69
97513: PUSH
97514: FOR_IN
97515: IFFALSE 97556
// begin for j := 1 to 4 do
97517: LD_ADDR_VAR 0 3
97521: PUSH
97522: DOUBLE
97523: LD_INT 1
97525: DEC
97526: ST_TO_ADDR
97527: LD_INT 4
97529: PUSH
97530: FOR_TO
97531: IFFALSE 97552
// SetSkill ( i , j , 10 ) ;
97533: LD_VAR 0 2
97537: PPUSH
97538: LD_VAR 0 3
97542: PPUSH
97543: LD_INT 10
97545: PPUSH
97546: CALL_OW 237
97550: GO 97530
97552: POP
97553: POP
// end ;
97554: GO 97514
97556: POP
97557: POP
// end ;
97558: LD_VAR 0 1
97562: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
97563: LD_INT 0
97565: PPUSH
// uc_side := your_side ;
97566: LD_ADDR_OWVAR 20
97570: PUSH
97571: LD_OWVAR 2
97575: ST_TO_ADDR
// uc_nation := nation ;
97576: LD_ADDR_OWVAR 21
97580: PUSH
97581: LD_VAR 0 1
97585: ST_TO_ADDR
// InitHc ;
97586: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
97590: LD_INT 0
97592: PPUSH
97593: LD_VAR 0 2
97597: PPUSH
97598: LD_VAR 0 3
97602: PPUSH
97603: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
97607: LD_VAR 0 4
97611: PPUSH
97612: LD_VAR 0 5
97616: PPUSH
97617: CALL_OW 428
97621: PUSH
97622: LD_INT 0
97624: EQUAL
97625: IFFALSE 97649
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
97627: CALL_OW 44
97631: PPUSH
97632: LD_VAR 0 4
97636: PPUSH
97637: LD_VAR 0 5
97641: PPUSH
97642: LD_INT 1
97644: PPUSH
97645: CALL_OW 48
// end ;
97649: LD_VAR 0 6
97653: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
97654: LD_INT 0
97656: PPUSH
97657: PPUSH
// uc_side := your_side ;
97658: LD_ADDR_OWVAR 20
97662: PUSH
97663: LD_OWVAR 2
97667: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
97668: LD_VAR 0 1
97672: PUSH
97673: LD_INT 1
97675: PUSH
97676: LD_INT 2
97678: PUSH
97679: LD_INT 3
97681: PUSH
97682: LD_INT 4
97684: PUSH
97685: LD_INT 5
97687: PUSH
97688: EMPTY
97689: LIST
97690: LIST
97691: LIST
97692: LIST
97693: LIST
97694: IN
97695: IFFALSE 97707
// uc_nation := nation_american else
97697: LD_ADDR_OWVAR 21
97701: PUSH
97702: LD_INT 1
97704: ST_TO_ADDR
97705: GO 97750
// if chassis in [ 11 , 12 , 13 , 14 ] then
97707: LD_VAR 0 1
97711: PUSH
97712: LD_INT 11
97714: PUSH
97715: LD_INT 12
97717: PUSH
97718: LD_INT 13
97720: PUSH
97721: LD_INT 14
97723: PUSH
97724: EMPTY
97725: LIST
97726: LIST
97727: LIST
97728: LIST
97729: IN
97730: IFFALSE 97742
// uc_nation := nation_arabian else
97732: LD_ADDR_OWVAR 21
97736: PUSH
97737: LD_INT 2
97739: ST_TO_ADDR
97740: GO 97750
// uc_nation := nation_russian ;
97742: LD_ADDR_OWVAR 21
97746: PUSH
97747: LD_INT 3
97749: ST_TO_ADDR
// vc_chassis := chassis ;
97750: LD_ADDR_OWVAR 37
97754: PUSH
97755: LD_VAR 0 1
97759: ST_TO_ADDR
// vc_engine := engine ;
97760: LD_ADDR_OWVAR 39
97764: PUSH
97765: LD_VAR 0 2
97769: ST_TO_ADDR
// vc_control := control ;
97770: LD_ADDR_OWVAR 38
97774: PUSH
97775: LD_VAR 0 3
97779: ST_TO_ADDR
// vc_weapon := weapon ;
97780: LD_ADDR_OWVAR 40
97784: PUSH
97785: LD_VAR 0 4
97789: ST_TO_ADDR
// un := CreateVehicle ;
97790: LD_ADDR_VAR 0 8
97794: PUSH
97795: CALL_OW 45
97799: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
97800: LD_VAR 0 8
97804: PPUSH
97805: LD_INT 0
97807: PPUSH
97808: LD_INT 5
97810: PPUSH
97811: CALL_OW 12
97815: PPUSH
97816: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
97820: LD_VAR 0 8
97824: PPUSH
97825: LD_VAR 0 5
97829: PPUSH
97830: LD_VAR 0 6
97834: PPUSH
97835: LD_INT 1
97837: PPUSH
97838: CALL_OW 48
// end ;
97842: LD_VAR 0 7
97846: RET
// export hInvincible ; every 1 do
97847: GO 97849
97849: DISABLE
// hInvincible := [ ] ;
97850: LD_ADDR_EXP 170
97854: PUSH
97855: EMPTY
97856: ST_TO_ADDR
97857: END
// every 10 do var i ;
97858: GO 97860
97860: DISABLE
97861: LD_INT 0
97863: PPUSH
// begin enable ;
97864: ENABLE
// if not hInvincible then
97865: LD_EXP 170
97869: NOT
97870: IFFALSE 97874
// exit ;
97872: GO 97918
// for i in hInvincible do
97874: LD_ADDR_VAR 0 1
97878: PUSH
97879: LD_EXP 170
97883: PUSH
97884: FOR_IN
97885: IFFALSE 97916
// if GetLives ( i ) < 1000 then
97887: LD_VAR 0 1
97891: PPUSH
97892: CALL_OW 256
97896: PUSH
97897: LD_INT 1000
97899: LESS
97900: IFFALSE 97914
// SetLives ( i , 1000 ) ;
97902: LD_VAR 0 1
97906: PPUSH
97907: LD_INT 1000
97909: PPUSH
97910: CALL_OW 234
97914: GO 97884
97916: POP
97917: POP
// end ;
97918: PPOPN 1
97920: END
// export function hHackInvincible ; var i ; begin
97921: LD_INT 0
97923: PPUSH
97924: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
97925: LD_ADDR_VAR 0 2
97929: PUSH
97930: LD_INT 2
97932: PUSH
97933: LD_INT 21
97935: PUSH
97936: LD_INT 1
97938: PUSH
97939: EMPTY
97940: LIST
97941: LIST
97942: PUSH
97943: LD_INT 21
97945: PUSH
97946: LD_INT 2
97948: PUSH
97949: EMPTY
97950: LIST
97951: LIST
97952: PUSH
97953: EMPTY
97954: LIST
97955: LIST
97956: LIST
97957: PPUSH
97958: CALL_OW 69
97962: PUSH
97963: FOR_IN
97964: IFFALSE 98025
// if IsSelected ( i ) then
97966: LD_VAR 0 2
97970: PPUSH
97971: CALL_OW 306
97975: IFFALSE 98023
// begin if i in hInvincible then
97977: LD_VAR 0 2
97981: PUSH
97982: LD_EXP 170
97986: IN
97987: IFFALSE 98007
// hInvincible := hInvincible diff i else
97989: LD_ADDR_EXP 170
97993: PUSH
97994: LD_EXP 170
97998: PUSH
97999: LD_VAR 0 2
98003: DIFF
98004: ST_TO_ADDR
98005: GO 98023
// hInvincible := hInvincible union i ;
98007: LD_ADDR_EXP 170
98011: PUSH
98012: LD_EXP 170
98016: PUSH
98017: LD_VAR 0 2
98021: UNION
98022: ST_TO_ADDR
// end ;
98023: GO 97963
98025: POP
98026: POP
// end ;
98027: LD_VAR 0 1
98031: RET
// export function hHackInvisible ; var i , j ; begin
98032: LD_INT 0
98034: PPUSH
98035: PPUSH
98036: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
98037: LD_ADDR_VAR 0 2
98041: PUSH
98042: LD_INT 21
98044: PUSH
98045: LD_INT 1
98047: PUSH
98048: EMPTY
98049: LIST
98050: LIST
98051: PPUSH
98052: CALL_OW 69
98056: PUSH
98057: FOR_IN
98058: IFFALSE 98082
// if IsSelected ( i ) then
98060: LD_VAR 0 2
98064: PPUSH
98065: CALL_OW 306
98069: IFFALSE 98080
// ComForceInvisible ( i ) ;
98071: LD_VAR 0 2
98075: PPUSH
98076: CALL_OW 496
98080: GO 98057
98082: POP
98083: POP
// end ;
98084: LD_VAR 0 1
98088: RET
// export function hHackChangeYourSide ; begin
98089: LD_INT 0
98091: PPUSH
// if your_side = 8 then
98092: LD_OWVAR 2
98096: PUSH
98097: LD_INT 8
98099: EQUAL
98100: IFFALSE 98112
// your_side := 0 else
98102: LD_ADDR_OWVAR 2
98106: PUSH
98107: LD_INT 0
98109: ST_TO_ADDR
98110: GO 98126
// your_side := your_side + 1 ;
98112: LD_ADDR_OWVAR 2
98116: PUSH
98117: LD_OWVAR 2
98121: PUSH
98122: LD_INT 1
98124: PLUS
98125: ST_TO_ADDR
// end ;
98126: LD_VAR 0 1
98130: RET
// export function hHackChangeUnitSide ; var i , j ; begin
98131: LD_INT 0
98133: PPUSH
98134: PPUSH
98135: PPUSH
// for i in all_units do
98136: LD_ADDR_VAR 0 2
98140: PUSH
98141: LD_OWVAR 3
98145: PUSH
98146: FOR_IN
98147: IFFALSE 98225
// if IsSelected ( i ) then
98149: LD_VAR 0 2
98153: PPUSH
98154: CALL_OW 306
98158: IFFALSE 98223
// begin j := GetSide ( i ) ;
98160: LD_ADDR_VAR 0 3
98164: PUSH
98165: LD_VAR 0 2
98169: PPUSH
98170: CALL_OW 255
98174: ST_TO_ADDR
// if j = 8 then
98175: LD_VAR 0 3
98179: PUSH
98180: LD_INT 8
98182: EQUAL
98183: IFFALSE 98195
// j := 0 else
98185: LD_ADDR_VAR 0 3
98189: PUSH
98190: LD_INT 0
98192: ST_TO_ADDR
98193: GO 98209
// j := j + 1 ;
98195: LD_ADDR_VAR 0 3
98199: PUSH
98200: LD_VAR 0 3
98204: PUSH
98205: LD_INT 1
98207: PLUS
98208: ST_TO_ADDR
// SetSide ( i , j ) ;
98209: LD_VAR 0 2
98213: PPUSH
98214: LD_VAR 0 3
98218: PPUSH
98219: CALL_OW 235
// end ;
98223: GO 98146
98225: POP
98226: POP
// end ;
98227: LD_VAR 0 1
98231: RET
// export function hHackFog ; begin
98232: LD_INT 0
98234: PPUSH
// FogOff ( true ) ;
98235: LD_INT 1
98237: PPUSH
98238: CALL_OW 344
// end ;
98242: LD_VAR 0 1
98246: RET
// export function hHackTeleport ( unit , x , y ) ; begin
98247: LD_INT 0
98249: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
98250: LD_VAR 0 1
98254: PPUSH
98255: LD_VAR 0 2
98259: PPUSH
98260: LD_VAR 0 3
98264: PPUSH
98265: LD_INT 1
98267: PPUSH
98268: LD_INT 1
98270: PPUSH
98271: CALL_OW 483
// CenterOnXY ( x , y ) ;
98275: LD_VAR 0 2
98279: PPUSH
98280: LD_VAR 0 3
98284: PPUSH
98285: CALL_OW 84
// end ; end_of_file
98289: LD_VAR 0 4
98293: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
98294: LD_INT 0
98296: PPUSH
98297: PPUSH
98298: PPUSH
98299: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
98300: LD_VAR 0 1
98304: PPUSH
98305: CALL_OW 264
98309: PUSH
98310: LD_EXP 52
98314: EQUAL
98315: IFFALSE 98387
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
98317: LD_INT 68
98319: PPUSH
98320: LD_VAR 0 1
98324: PPUSH
98325: CALL_OW 255
98329: PPUSH
98330: CALL_OW 321
98334: PUSH
98335: LD_INT 2
98337: EQUAL
98338: IFFALSE 98350
// eff := 70 else
98340: LD_ADDR_VAR 0 4
98344: PUSH
98345: LD_INT 70
98347: ST_TO_ADDR
98348: GO 98358
// eff := 30 ;
98350: LD_ADDR_VAR 0 4
98354: PUSH
98355: LD_INT 30
98357: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
98358: LD_VAR 0 1
98362: PPUSH
98363: CALL_OW 250
98367: PPUSH
98368: LD_VAR 0 1
98372: PPUSH
98373: CALL_OW 251
98377: PPUSH
98378: LD_VAR 0 4
98382: PPUSH
98383: CALL_OW 495
// end ; end ;
98387: LD_VAR 0 2
98391: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
98392: LD_INT 0
98394: PPUSH
// end ;
98395: LD_VAR 0 4
98399: RET
// export function SOS_Command ( cmd ) ; begin
98400: LD_INT 0
98402: PPUSH
// end ;
98403: LD_VAR 0 2
98407: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
98408: LD_INT 0
98410: PPUSH
// end ;
98411: LD_VAR 0 6
98415: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
98416: LD_INT 0
98418: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
98419: LD_VAR 0 1
98423: PUSH
98424: LD_INT 250
98426: EQUAL
98427: PUSH
98428: LD_VAR 0 2
98432: PPUSH
98433: CALL_OW 264
98437: PUSH
98438: LD_EXP 55
98442: EQUAL
98443: AND
98444: IFFALSE 98465
// MinerPlaceMine ( unit , x , y ) ;
98446: LD_VAR 0 2
98450: PPUSH
98451: LD_VAR 0 4
98455: PPUSH
98456: LD_VAR 0 5
98460: PPUSH
98461: CALL 100814 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
98465: LD_VAR 0 1
98469: PUSH
98470: LD_INT 251
98472: EQUAL
98473: PUSH
98474: LD_VAR 0 2
98478: PPUSH
98479: CALL_OW 264
98483: PUSH
98484: LD_EXP 55
98488: EQUAL
98489: AND
98490: IFFALSE 98511
// MinerDetonateMine ( unit , x , y ) ;
98492: LD_VAR 0 2
98496: PPUSH
98497: LD_VAR 0 4
98501: PPUSH
98502: LD_VAR 0 5
98506: PPUSH
98507: CALL 101091 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
98511: LD_VAR 0 1
98515: PUSH
98516: LD_INT 252
98518: EQUAL
98519: PUSH
98520: LD_VAR 0 2
98524: PPUSH
98525: CALL_OW 264
98529: PUSH
98530: LD_EXP 55
98534: EQUAL
98535: AND
98536: IFFALSE 98557
// MinerCreateMinefield ( unit , x , y ) ;
98538: LD_VAR 0 2
98542: PPUSH
98543: LD_VAR 0 4
98547: PPUSH
98548: LD_VAR 0 5
98552: PPUSH
98553: CALL 101508 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
98557: LD_VAR 0 1
98561: PUSH
98562: LD_INT 253
98564: EQUAL
98565: PUSH
98566: LD_VAR 0 2
98570: PPUSH
98571: CALL_OW 257
98575: PUSH
98576: LD_INT 5
98578: EQUAL
98579: AND
98580: IFFALSE 98601
// ComBinocular ( unit , x , y ) ;
98582: LD_VAR 0 2
98586: PPUSH
98587: LD_VAR 0 4
98591: PPUSH
98592: LD_VAR 0 5
98596: PPUSH
98597: CALL 101879 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
98601: LD_VAR 0 1
98605: PUSH
98606: LD_INT 254
98608: EQUAL
98609: PUSH
98610: LD_VAR 0 2
98614: PPUSH
98615: CALL_OW 264
98619: PUSH
98620: LD_EXP 50
98624: EQUAL
98625: AND
98626: PUSH
98627: LD_VAR 0 3
98631: PPUSH
98632: CALL_OW 263
98636: PUSH
98637: LD_INT 3
98639: EQUAL
98640: AND
98641: IFFALSE 98657
// HackDestroyVehicle ( unit , selectedUnit ) ;
98643: LD_VAR 0 2
98647: PPUSH
98648: LD_VAR 0 3
98652: PPUSH
98653: CALL 100174 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
98657: LD_VAR 0 1
98661: PUSH
98662: LD_INT 255
98664: EQUAL
98665: PUSH
98666: LD_VAR 0 2
98670: PPUSH
98671: CALL_OW 264
98675: PUSH
98676: LD_INT 14
98678: PUSH
98679: LD_INT 53
98681: PUSH
98682: EMPTY
98683: LIST
98684: LIST
98685: IN
98686: AND
98687: PUSH
98688: LD_VAR 0 4
98692: PPUSH
98693: LD_VAR 0 5
98697: PPUSH
98698: CALL_OW 488
98702: AND
98703: IFFALSE 98727
// CutTreeXYR ( unit , x , y , 12 ) ;
98705: LD_VAR 0 2
98709: PPUSH
98710: LD_VAR 0 4
98714: PPUSH
98715: LD_VAR 0 5
98719: PPUSH
98720: LD_INT 12
98722: PPUSH
98723: CALL 98740 0 4
// end ;
98727: LD_VAR 0 6
98731: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
98732: LD_INT 0
98734: PPUSH
// end ;
98735: LD_VAR 0 4
98739: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
98740: LD_INT 0
98742: PPUSH
98743: PPUSH
98744: PPUSH
98745: PPUSH
98746: PPUSH
98747: PPUSH
98748: PPUSH
98749: PPUSH
98750: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
98751: LD_VAR 0 1
98755: NOT
98756: PUSH
98757: LD_VAR 0 2
98761: PPUSH
98762: LD_VAR 0 3
98766: PPUSH
98767: CALL_OW 488
98771: NOT
98772: OR
98773: PUSH
98774: LD_VAR 0 4
98778: NOT
98779: OR
98780: IFFALSE 98784
// exit ;
98782: GO 99124
// list := [ ] ;
98784: LD_ADDR_VAR 0 13
98788: PUSH
98789: EMPTY
98790: ST_TO_ADDR
// if x - r < 0 then
98791: LD_VAR 0 2
98795: PUSH
98796: LD_VAR 0 4
98800: MINUS
98801: PUSH
98802: LD_INT 0
98804: LESS
98805: IFFALSE 98817
// min_x := 0 else
98807: LD_ADDR_VAR 0 7
98811: PUSH
98812: LD_INT 0
98814: ST_TO_ADDR
98815: GO 98833
// min_x := x - r ;
98817: LD_ADDR_VAR 0 7
98821: PUSH
98822: LD_VAR 0 2
98826: PUSH
98827: LD_VAR 0 4
98831: MINUS
98832: ST_TO_ADDR
// if y - r < 0 then
98833: LD_VAR 0 3
98837: PUSH
98838: LD_VAR 0 4
98842: MINUS
98843: PUSH
98844: LD_INT 0
98846: LESS
98847: IFFALSE 98859
// min_y := 0 else
98849: LD_ADDR_VAR 0 8
98853: PUSH
98854: LD_INT 0
98856: ST_TO_ADDR
98857: GO 98875
// min_y := y - r ;
98859: LD_ADDR_VAR 0 8
98863: PUSH
98864: LD_VAR 0 3
98868: PUSH
98869: LD_VAR 0 4
98873: MINUS
98874: ST_TO_ADDR
// max_x := x + r ;
98875: LD_ADDR_VAR 0 9
98879: PUSH
98880: LD_VAR 0 2
98884: PUSH
98885: LD_VAR 0 4
98889: PLUS
98890: ST_TO_ADDR
// max_y := y + r ;
98891: LD_ADDR_VAR 0 10
98895: PUSH
98896: LD_VAR 0 3
98900: PUSH
98901: LD_VAR 0 4
98905: PLUS
98906: ST_TO_ADDR
// for _x = min_x to max_x do
98907: LD_ADDR_VAR 0 11
98911: PUSH
98912: DOUBLE
98913: LD_VAR 0 7
98917: DEC
98918: ST_TO_ADDR
98919: LD_VAR 0 9
98923: PUSH
98924: FOR_TO
98925: IFFALSE 99042
// for _y = min_y to max_y do
98927: LD_ADDR_VAR 0 12
98931: PUSH
98932: DOUBLE
98933: LD_VAR 0 8
98937: DEC
98938: ST_TO_ADDR
98939: LD_VAR 0 10
98943: PUSH
98944: FOR_TO
98945: IFFALSE 99038
// begin if not ValidHex ( _x , _y ) then
98947: LD_VAR 0 11
98951: PPUSH
98952: LD_VAR 0 12
98956: PPUSH
98957: CALL_OW 488
98961: NOT
98962: IFFALSE 98966
// continue ;
98964: GO 98944
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
98966: LD_VAR 0 11
98970: PPUSH
98971: LD_VAR 0 12
98975: PPUSH
98976: CALL_OW 351
98980: PUSH
98981: LD_VAR 0 11
98985: PPUSH
98986: LD_VAR 0 12
98990: PPUSH
98991: CALL_OW 554
98995: AND
98996: IFFALSE 99036
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
98998: LD_ADDR_VAR 0 13
99002: PUSH
99003: LD_VAR 0 13
99007: PPUSH
99008: LD_VAR 0 13
99012: PUSH
99013: LD_INT 1
99015: PLUS
99016: PPUSH
99017: LD_VAR 0 11
99021: PUSH
99022: LD_VAR 0 12
99026: PUSH
99027: EMPTY
99028: LIST
99029: LIST
99030: PPUSH
99031: CALL_OW 2
99035: ST_TO_ADDR
// end ;
99036: GO 98944
99038: POP
99039: POP
99040: GO 98924
99042: POP
99043: POP
// if not list then
99044: LD_VAR 0 13
99048: NOT
99049: IFFALSE 99053
// exit ;
99051: GO 99124
// for i in list do
99053: LD_ADDR_VAR 0 6
99057: PUSH
99058: LD_VAR 0 13
99062: PUSH
99063: FOR_IN
99064: IFFALSE 99122
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
99066: LD_VAR 0 1
99070: PPUSH
99071: LD_STRING M
99073: PUSH
99074: LD_VAR 0 6
99078: PUSH
99079: LD_INT 1
99081: ARRAY
99082: PUSH
99083: LD_VAR 0 6
99087: PUSH
99088: LD_INT 2
99090: ARRAY
99091: PUSH
99092: LD_INT 0
99094: PUSH
99095: LD_INT 0
99097: PUSH
99098: LD_INT 0
99100: PUSH
99101: LD_INT 0
99103: PUSH
99104: EMPTY
99105: LIST
99106: LIST
99107: LIST
99108: LIST
99109: LIST
99110: LIST
99111: LIST
99112: PUSH
99113: EMPTY
99114: LIST
99115: PPUSH
99116: CALL_OW 447
99120: GO 99063
99122: POP
99123: POP
// end ;
99124: LD_VAR 0 5
99128: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
99129: LD_EXP 173
99133: NOT
99134: IFFALSE 99184
99136: GO 99138
99138: DISABLE
// begin initHack := true ;
99139: LD_ADDR_EXP 173
99143: PUSH
99144: LD_INT 1
99146: ST_TO_ADDR
// hackTanks := [ ] ;
99147: LD_ADDR_EXP 174
99151: PUSH
99152: EMPTY
99153: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
99154: LD_ADDR_EXP 175
99158: PUSH
99159: EMPTY
99160: ST_TO_ADDR
// hackLimit := 3 ;
99161: LD_ADDR_EXP 176
99165: PUSH
99166: LD_INT 3
99168: ST_TO_ADDR
// hackDist := 12 ;
99169: LD_ADDR_EXP 177
99173: PUSH
99174: LD_INT 12
99176: ST_TO_ADDR
// hackCounter := [ ] ;
99177: LD_ADDR_EXP 178
99181: PUSH
99182: EMPTY
99183: ST_TO_ADDR
// end ;
99184: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
99185: LD_EXP 173
99189: PUSH
99190: LD_INT 34
99192: PUSH
99193: LD_EXP 50
99197: PUSH
99198: EMPTY
99199: LIST
99200: LIST
99201: PPUSH
99202: CALL_OW 69
99206: AND
99207: IFFALSE 99462
99209: GO 99211
99211: DISABLE
99212: LD_INT 0
99214: PPUSH
99215: PPUSH
// begin enable ;
99216: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
99217: LD_ADDR_VAR 0 1
99221: PUSH
99222: LD_INT 34
99224: PUSH
99225: LD_EXP 50
99229: PUSH
99230: EMPTY
99231: LIST
99232: LIST
99233: PPUSH
99234: CALL_OW 69
99238: PUSH
99239: FOR_IN
99240: IFFALSE 99460
// begin if not i in hackTanks then
99242: LD_VAR 0 1
99246: PUSH
99247: LD_EXP 174
99251: IN
99252: NOT
99253: IFFALSE 99336
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
99255: LD_ADDR_EXP 174
99259: PUSH
99260: LD_EXP 174
99264: PPUSH
99265: LD_EXP 174
99269: PUSH
99270: LD_INT 1
99272: PLUS
99273: PPUSH
99274: LD_VAR 0 1
99278: PPUSH
99279: CALL_OW 1
99283: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
99284: LD_ADDR_EXP 175
99288: PUSH
99289: LD_EXP 175
99293: PPUSH
99294: LD_EXP 175
99298: PUSH
99299: LD_INT 1
99301: PLUS
99302: PPUSH
99303: EMPTY
99304: PPUSH
99305: CALL_OW 1
99309: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
99310: LD_ADDR_EXP 178
99314: PUSH
99315: LD_EXP 178
99319: PPUSH
99320: LD_EXP 178
99324: PUSH
99325: LD_INT 1
99327: PLUS
99328: PPUSH
99329: EMPTY
99330: PPUSH
99331: CALL_OW 1
99335: ST_TO_ADDR
// end ; if not IsOk ( i ) then
99336: LD_VAR 0 1
99340: PPUSH
99341: CALL_OW 302
99345: NOT
99346: IFFALSE 99359
// begin HackUnlinkAll ( i ) ;
99348: LD_VAR 0 1
99352: PPUSH
99353: CALL 99465 0 1
// continue ;
99357: GO 99239
// end ; HackCheckCapturedStatus ( i ) ;
99359: LD_VAR 0 1
99363: PPUSH
99364: CALL 99908 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
99368: LD_ADDR_VAR 0 2
99372: PUSH
99373: LD_INT 81
99375: PUSH
99376: LD_VAR 0 1
99380: PPUSH
99381: CALL_OW 255
99385: PUSH
99386: EMPTY
99387: LIST
99388: LIST
99389: PUSH
99390: LD_INT 33
99392: PUSH
99393: LD_INT 3
99395: PUSH
99396: EMPTY
99397: LIST
99398: LIST
99399: PUSH
99400: LD_INT 91
99402: PUSH
99403: LD_VAR 0 1
99407: PUSH
99408: LD_EXP 177
99412: PUSH
99413: EMPTY
99414: LIST
99415: LIST
99416: LIST
99417: PUSH
99418: LD_INT 50
99420: PUSH
99421: EMPTY
99422: LIST
99423: PUSH
99424: EMPTY
99425: LIST
99426: LIST
99427: LIST
99428: LIST
99429: PPUSH
99430: CALL_OW 69
99434: ST_TO_ADDR
// if not tmp then
99435: LD_VAR 0 2
99439: NOT
99440: IFFALSE 99444
// continue ;
99442: GO 99239
// HackLink ( i , tmp ) ;
99444: LD_VAR 0 1
99448: PPUSH
99449: LD_VAR 0 2
99453: PPUSH
99454: CALL 99601 0 2
// end ;
99458: GO 99239
99460: POP
99461: POP
// end ;
99462: PPOPN 2
99464: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
99465: LD_INT 0
99467: PPUSH
99468: PPUSH
99469: PPUSH
// if not hack in hackTanks then
99470: LD_VAR 0 1
99474: PUSH
99475: LD_EXP 174
99479: IN
99480: NOT
99481: IFFALSE 99485
// exit ;
99483: GO 99596
// index := GetElementIndex ( hackTanks , hack ) ;
99485: LD_ADDR_VAR 0 4
99489: PUSH
99490: LD_EXP 174
99494: PPUSH
99495: LD_VAR 0 1
99499: PPUSH
99500: CALL 18373 0 2
99504: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
99505: LD_EXP 175
99509: PUSH
99510: LD_VAR 0 4
99514: ARRAY
99515: IFFALSE 99596
// begin for i in hackTanksCaptured [ index ] do
99517: LD_ADDR_VAR 0 3
99521: PUSH
99522: LD_EXP 175
99526: PUSH
99527: LD_VAR 0 4
99531: ARRAY
99532: PUSH
99533: FOR_IN
99534: IFFALSE 99560
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
99536: LD_VAR 0 3
99540: PUSH
99541: LD_INT 1
99543: ARRAY
99544: PPUSH
99545: LD_VAR 0 3
99549: PUSH
99550: LD_INT 2
99552: ARRAY
99553: PPUSH
99554: CALL_OW 235
99558: GO 99533
99560: POP
99561: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
99562: LD_ADDR_EXP 175
99566: PUSH
99567: LD_EXP 175
99571: PPUSH
99572: LD_VAR 0 4
99576: PPUSH
99577: EMPTY
99578: PPUSH
99579: CALL_OW 1
99583: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
99584: LD_VAR 0 1
99588: PPUSH
99589: LD_INT 0
99591: PPUSH
99592: CALL_OW 505
// end ; end ;
99596: LD_VAR 0 2
99600: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
99601: LD_INT 0
99603: PPUSH
99604: PPUSH
99605: PPUSH
// if not hack in hackTanks or not vehicles then
99606: LD_VAR 0 1
99610: PUSH
99611: LD_EXP 174
99615: IN
99616: NOT
99617: PUSH
99618: LD_VAR 0 2
99622: NOT
99623: OR
99624: IFFALSE 99628
// exit ;
99626: GO 99903
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
99628: LD_ADDR_VAR 0 2
99632: PUSH
99633: LD_VAR 0 1
99637: PPUSH
99638: LD_VAR 0 2
99642: PPUSH
99643: LD_INT 1
99645: PPUSH
99646: LD_INT 1
99648: PPUSH
99649: CALL 19023 0 4
99653: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
99654: LD_ADDR_VAR 0 5
99658: PUSH
99659: LD_EXP 174
99663: PPUSH
99664: LD_VAR 0 1
99668: PPUSH
99669: CALL 18373 0 2
99673: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
99674: LD_EXP 175
99678: PUSH
99679: LD_VAR 0 5
99683: ARRAY
99684: PUSH
99685: LD_EXP 176
99689: LESS
99690: IFFALSE 99879
// begin for i := 1 to vehicles do
99692: LD_ADDR_VAR 0 4
99696: PUSH
99697: DOUBLE
99698: LD_INT 1
99700: DEC
99701: ST_TO_ADDR
99702: LD_VAR 0 2
99706: PUSH
99707: FOR_TO
99708: IFFALSE 99877
// begin if hackTanksCaptured [ index ] = hackLimit then
99710: LD_EXP 175
99714: PUSH
99715: LD_VAR 0 5
99719: ARRAY
99720: PUSH
99721: LD_EXP 176
99725: EQUAL
99726: IFFALSE 99730
// break ;
99728: GO 99877
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
99730: LD_ADDR_EXP 178
99734: PUSH
99735: LD_EXP 178
99739: PPUSH
99740: LD_VAR 0 5
99744: PPUSH
99745: LD_EXP 178
99749: PUSH
99750: LD_VAR 0 5
99754: ARRAY
99755: PUSH
99756: LD_INT 1
99758: PLUS
99759: PPUSH
99760: CALL_OW 1
99764: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
99765: LD_ADDR_EXP 175
99769: PUSH
99770: LD_EXP 175
99774: PPUSH
99775: LD_VAR 0 5
99779: PUSH
99780: LD_EXP 175
99784: PUSH
99785: LD_VAR 0 5
99789: ARRAY
99790: PUSH
99791: LD_INT 1
99793: PLUS
99794: PUSH
99795: EMPTY
99796: LIST
99797: LIST
99798: PPUSH
99799: LD_VAR 0 2
99803: PUSH
99804: LD_VAR 0 4
99808: ARRAY
99809: PUSH
99810: LD_VAR 0 2
99814: PUSH
99815: LD_VAR 0 4
99819: ARRAY
99820: PPUSH
99821: CALL_OW 255
99825: PUSH
99826: EMPTY
99827: LIST
99828: LIST
99829: PPUSH
99830: CALL 18588 0 3
99834: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
99835: LD_VAR 0 2
99839: PUSH
99840: LD_VAR 0 4
99844: ARRAY
99845: PPUSH
99846: LD_VAR 0 1
99850: PPUSH
99851: CALL_OW 255
99855: PPUSH
99856: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
99860: LD_VAR 0 2
99864: PUSH
99865: LD_VAR 0 4
99869: ARRAY
99870: PPUSH
99871: CALL_OW 141
// end ;
99875: GO 99707
99877: POP
99878: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
99879: LD_VAR 0 1
99883: PPUSH
99884: LD_EXP 175
99888: PUSH
99889: LD_VAR 0 5
99893: ARRAY
99894: PUSH
99895: LD_INT 0
99897: PLUS
99898: PPUSH
99899: CALL_OW 505
// end ;
99903: LD_VAR 0 3
99907: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
99908: LD_INT 0
99910: PPUSH
99911: PPUSH
99912: PPUSH
99913: PPUSH
// if not hack in hackTanks then
99914: LD_VAR 0 1
99918: PUSH
99919: LD_EXP 174
99923: IN
99924: NOT
99925: IFFALSE 99929
// exit ;
99927: GO 100169
// index := GetElementIndex ( hackTanks , hack ) ;
99929: LD_ADDR_VAR 0 4
99933: PUSH
99934: LD_EXP 174
99938: PPUSH
99939: LD_VAR 0 1
99943: PPUSH
99944: CALL 18373 0 2
99948: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
99949: LD_ADDR_VAR 0 3
99953: PUSH
99954: DOUBLE
99955: LD_EXP 175
99959: PUSH
99960: LD_VAR 0 4
99964: ARRAY
99965: INC
99966: ST_TO_ADDR
99967: LD_INT 1
99969: PUSH
99970: FOR_DOWNTO
99971: IFFALSE 100143
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
99973: LD_ADDR_VAR 0 5
99977: PUSH
99978: LD_EXP 175
99982: PUSH
99983: LD_VAR 0 4
99987: ARRAY
99988: PUSH
99989: LD_VAR 0 3
99993: ARRAY
99994: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
99995: LD_VAR 0 5
99999: PUSH
100000: LD_INT 1
100002: ARRAY
100003: PPUSH
100004: CALL_OW 302
100008: NOT
100009: PUSH
100010: LD_VAR 0 5
100014: PUSH
100015: LD_INT 1
100017: ARRAY
100018: PPUSH
100019: CALL_OW 255
100023: PUSH
100024: LD_VAR 0 1
100028: PPUSH
100029: CALL_OW 255
100033: NONEQUAL
100034: OR
100035: IFFALSE 100141
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
100037: LD_VAR 0 5
100041: PUSH
100042: LD_INT 1
100044: ARRAY
100045: PPUSH
100046: CALL_OW 305
100050: PUSH
100051: LD_VAR 0 5
100055: PUSH
100056: LD_INT 1
100058: ARRAY
100059: PPUSH
100060: CALL_OW 255
100064: PUSH
100065: LD_VAR 0 1
100069: PPUSH
100070: CALL_OW 255
100074: EQUAL
100075: AND
100076: IFFALSE 100100
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
100078: LD_VAR 0 5
100082: PUSH
100083: LD_INT 1
100085: ARRAY
100086: PPUSH
100087: LD_VAR 0 5
100091: PUSH
100092: LD_INT 2
100094: ARRAY
100095: PPUSH
100096: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
100100: LD_ADDR_EXP 175
100104: PUSH
100105: LD_EXP 175
100109: PPUSH
100110: LD_VAR 0 4
100114: PPUSH
100115: LD_EXP 175
100119: PUSH
100120: LD_VAR 0 4
100124: ARRAY
100125: PPUSH
100126: LD_VAR 0 3
100130: PPUSH
100131: CALL_OW 3
100135: PPUSH
100136: CALL_OW 1
100140: ST_TO_ADDR
// end ; end ;
100141: GO 99970
100143: POP
100144: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
100145: LD_VAR 0 1
100149: PPUSH
100150: LD_EXP 175
100154: PUSH
100155: LD_VAR 0 4
100159: ARRAY
100160: PUSH
100161: LD_INT 0
100163: PLUS
100164: PPUSH
100165: CALL_OW 505
// end ;
100169: LD_VAR 0 2
100173: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
100174: LD_INT 0
100176: PPUSH
100177: PPUSH
100178: PPUSH
100179: PPUSH
// if not hack in hackTanks then
100180: LD_VAR 0 1
100184: PUSH
100185: LD_EXP 174
100189: IN
100190: NOT
100191: IFFALSE 100195
// exit ;
100193: GO 100280
// index := GetElementIndex ( hackTanks , hack ) ;
100195: LD_ADDR_VAR 0 5
100199: PUSH
100200: LD_EXP 174
100204: PPUSH
100205: LD_VAR 0 1
100209: PPUSH
100210: CALL 18373 0 2
100214: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
100215: LD_ADDR_VAR 0 4
100219: PUSH
100220: DOUBLE
100221: LD_INT 1
100223: DEC
100224: ST_TO_ADDR
100225: LD_EXP 175
100229: PUSH
100230: LD_VAR 0 5
100234: ARRAY
100235: PUSH
100236: FOR_TO
100237: IFFALSE 100278
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
100239: LD_EXP 175
100243: PUSH
100244: LD_VAR 0 5
100248: ARRAY
100249: PUSH
100250: LD_VAR 0 4
100254: ARRAY
100255: PUSH
100256: LD_INT 1
100258: ARRAY
100259: PUSH
100260: LD_VAR 0 2
100264: EQUAL
100265: IFFALSE 100276
// KillUnit ( vehicle ) ;
100267: LD_VAR 0 2
100271: PPUSH
100272: CALL_OW 66
100276: GO 100236
100278: POP
100279: POP
// end ;
100280: LD_VAR 0 3
100284: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
100285: LD_EXP 179
100289: NOT
100290: IFFALSE 100325
100292: GO 100294
100294: DISABLE
// begin initMiner := true ;
100295: LD_ADDR_EXP 179
100299: PUSH
100300: LD_INT 1
100302: ST_TO_ADDR
// minersList := [ ] ;
100303: LD_ADDR_EXP 180
100307: PUSH
100308: EMPTY
100309: ST_TO_ADDR
// minerMinesList := [ ] ;
100310: LD_ADDR_EXP 181
100314: PUSH
100315: EMPTY
100316: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
100317: LD_ADDR_EXP 182
100321: PUSH
100322: LD_INT 5
100324: ST_TO_ADDR
// end ;
100325: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
100326: LD_EXP 179
100330: PUSH
100331: LD_INT 34
100333: PUSH
100334: LD_EXP 55
100338: PUSH
100339: EMPTY
100340: LIST
100341: LIST
100342: PPUSH
100343: CALL_OW 69
100347: AND
100348: IFFALSE 100811
100350: GO 100352
100352: DISABLE
100353: LD_INT 0
100355: PPUSH
100356: PPUSH
100357: PPUSH
100358: PPUSH
// begin enable ;
100359: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
100360: LD_ADDR_VAR 0 1
100364: PUSH
100365: LD_INT 34
100367: PUSH
100368: LD_EXP 55
100372: PUSH
100373: EMPTY
100374: LIST
100375: LIST
100376: PPUSH
100377: CALL_OW 69
100381: PUSH
100382: FOR_IN
100383: IFFALSE 100455
// begin if not i in minersList then
100385: LD_VAR 0 1
100389: PUSH
100390: LD_EXP 180
100394: IN
100395: NOT
100396: IFFALSE 100453
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
100398: LD_ADDR_EXP 180
100402: PUSH
100403: LD_EXP 180
100407: PPUSH
100408: LD_EXP 180
100412: PUSH
100413: LD_INT 1
100415: PLUS
100416: PPUSH
100417: LD_VAR 0 1
100421: PPUSH
100422: CALL_OW 1
100426: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
100427: LD_ADDR_EXP 181
100431: PUSH
100432: LD_EXP 181
100436: PPUSH
100437: LD_EXP 181
100441: PUSH
100442: LD_INT 1
100444: PLUS
100445: PPUSH
100446: EMPTY
100447: PPUSH
100448: CALL_OW 1
100452: ST_TO_ADDR
// end end ;
100453: GO 100382
100455: POP
100456: POP
// for i := minerMinesList downto 1 do
100457: LD_ADDR_VAR 0 1
100461: PUSH
100462: DOUBLE
100463: LD_EXP 181
100467: INC
100468: ST_TO_ADDR
100469: LD_INT 1
100471: PUSH
100472: FOR_DOWNTO
100473: IFFALSE 100809
// begin if IsLive ( minersList [ i ] ) then
100475: LD_EXP 180
100479: PUSH
100480: LD_VAR 0 1
100484: ARRAY
100485: PPUSH
100486: CALL_OW 300
100490: IFFALSE 100518
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
100492: LD_EXP 180
100496: PUSH
100497: LD_VAR 0 1
100501: ARRAY
100502: PPUSH
100503: LD_EXP 181
100507: PUSH
100508: LD_VAR 0 1
100512: ARRAY
100513: PPUSH
100514: CALL_OW 505
// if not minerMinesList [ i ] then
100518: LD_EXP 181
100522: PUSH
100523: LD_VAR 0 1
100527: ARRAY
100528: NOT
100529: IFFALSE 100533
// continue ;
100531: GO 100472
// for j := minerMinesList [ i ] downto 1 do
100533: LD_ADDR_VAR 0 2
100537: PUSH
100538: DOUBLE
100539: LD_EXP 181
100543: PUSH
100544: LD_VAR 0 1
100548: ARRAY
100549: INC
100550: ST_TO_ADDR
100551: LD_INT 1
100553: PUSH
100554: FOR_DOWNTO
100555: IFFALSE 100805
// begin side := GetSide ( minersList [ i ] ) ;
100557: LD_ADDR_VAR 0 3
100561: PUSH
100562: LD_EXP 180
100566: PUSH
100567: LD_VAR 0 1
100571: ARRAY
100572: PPUSH
100573: CALL_OW 255
100577: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
100578: LD_ADDR_VAR 0 4
100582: PUSH
100583: LD_EXP 181
100587: PUSH
100588: LD_VAR 0 1
100592: ARRAY
100593: PUSH
100594: LD_VAR 0 2
100598: ARRAY
100599: PUSH
100600: LD_INT 1
100602: ARRAY
100603: PPUSH
100604: LD_EXP 181
100608: PUSH
100609: LD_VAR 0 1
100613: ARRAY
100614: PUSH
100615: LD_VAR 0 2
100619: ARRAY
100620: PUSH
100621: LD_INT 2
100623: ARRAY
100624: PPUSH
100625: CALL_OW 428
100629: ST_TO_ADDR
// if not tmp then
100630: LD_VAR 0 4
100634: NOT
100635: IFFALSE 100639
// continue ;
100637: GO 100554
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
100639: LD_VAR 0 4
100643: PUSH
100644: LD_INT 81
100646: PUSH
100647: LD_VAR 0 3
100651: PUSH
100652: EMPTY
100653: LIST
100654: LIST
100655: PPUSH
100656: CALL_OW 69
100660: IN
100661: PUSH
100662: LD_EXP 181
100666: PUSH
100667: LD_VAR 0 1
100671: ARRAY
100672: PUSH
100673: LD_VAR 0 2
100677: ARRAY
100678: PUSH
100679: LD_INT 1
100681: ARRAY
100682: PPUSH
100683: LD_EXP 181
100687: PUSH
100688: LD_VAR 0 1
100692: ARRAY
100693: PUSH
100694: LD_VAR 0 2
100698: ARRAY
100699: PUSH
100700: LD_INT 2
100702: ARRAY
100703: PPUSH
100704: CALL_OW 458
100708: AND
100709: IFFALSE 100803
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
100711: LD_EXP 181
100715: PUSH
100716: LD_VAR 0 1
100720: ARRAY
100721: PUSH
100722: LD_VAR 0 2
100726: ARRAY
100727: PUSH
100728: LD_INT 1
100730: ARRAY
100731: PPUSH
100732: LD_EXP 181
100736: PUSH
100737: LD_VAR 0 1
100741: ARRAY
100742: PUSH
100743: LD_VAR 0 2
100747: ARRAY
100748: PUSH
100749: LD_INT 2
100751: ARRAY
100752: PPUSH
100753: LD_VAR 0 3
100757: PPUSH
100758: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
100762: LD_ADDR_EXP 181
100766: PUSH
100767: LD_EXP 181
100771: PPUSH
100772: LD_VAR 0 1
100776: PPUSH
100777: LD_EXP 181
100781: PUSH
100782: LD_VAR 0 1
100786: ARRAY
100787: PPUSH
100788: LD_VAR 0 2
100792: PPUSH
100793: CALL_OW 3
100797: PPUSH
100798: CALL_OW 1
100802: ST_TO_ADDR
// end ; end ;
100803: GO 100554
100805: POP
100806: POP
// end ;
100807: GO 100472
100809: POP
100810: POP
// end ;
100811: PPOPN 4
100813: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
100814: LD_INT 0
100816: PPUSH
100817: PPUSH
// result := false ;
100818: LD_ADDR_VAR 0 4
100822: PUSH
100823: LD_INT 0
100825: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
100826: LD_VAR 0 1
100830: PPUSH
100831: CALL_OW 264
100835: PUSH
100836: LD_EXP 55
100840: EQUAL
100841: NOT
100842: IFFALSE 100846
// exit ;
100844: GO 101086
// index := GetElementIndex ( minersList , unit ) ;
100846: LD_ADDR_VAR 0 5
100850: PUSH
100851: LD_EXP 180
100855: PPUSH
100856: LD_VAR 0 1
100860: PPUSH
100861: CALL 18373 0 2
100865: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
100866: LD_EXP 181
100870: PUSH
100871: LD_VAR 0 5
100875: ARRAY
100876: PUSH
100877: LD_EXP 182
100881: GREATEREQUAL
100882: IFFALSE 100886
// exit ;
100884: GO 101086
// ComMoveXY ( unit , x , y ) ;
100886: LD_VAR 0 1
100890: PPUSH
100891: LD_VAR 0 2
100895: PPUSH
100896: LD_VAR 0 3
100900: PPUSH
100901: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
100905: LD_INT 35
100907: PPUSH
100908: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
100912: LD_VAR 0 1
100916: PPUSH
100917: LD_VAR 0 2
100921: PPUSH
100922: LD_VAR 0 3
100926: PPUSH
100927: CALL 49145 0 3
100931: NOT
100932: PUSH
100933: LD_VAR 0 1
100937: PPUSH
100938: CALL_OW 314
100942: AND
100943: IFFALSE 100947
// exit ;
100945: GO 101086
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
100947: LD_VAR 0 2
100951: PPUSH
100952: LD_VAR 0 3
100956: PPUSH
100957: CALL_OW 428
100961: PUSH
100962: LD_VAR 0 1
100966: EQUAL
100967: PUSH
100968: LD_VAR 0 1
100972: PPUSH
100973: CALL_OW 314
100977: NOT
100978: AND
100979: IFFALSE 100905
// PlaySoundXY ( x , y , PlantMine ) ;
100981: LD_VAR 0 2
100985: PPUSH
100986: LD_VAR 0 3
100990: PPUSH
100991: LD_STRING PlantMine
100993: PPUSH
100994: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
100998: LD_VAR 0 2
101002: PPUSH
101003: LD_VAR 0 3
101007: PPUSH
101008: LD_VAR 0 1
101012: PPUSH
101013: CALL_OW 255
101017: PPUSH
101018: LD_INT 0
101020: PPUSH
101021: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
101025: LD_ADDR_EXP 181
101029: PUSH
101030: LD_EXP 181
101034: PPUSH
101035: LD_VAR 0 5
101039: PUSH
101040: LD_EXP 181
101044: PUSH
101045: LD_VAR 0 5
101049: ARRAY
101050: PUSH
101051: LD_INT 1
101053: PLUS
101054: PUSH
101055: EMPTY
101056: LIST
101057: LIST
101058: PPUSH
101059: LD_VAR 0 2
101063: PUSH
101064: LD_VAR 0 3
101068: PUSH
101069: EMPTY
101070: LIST
101071: LIST
101072: PPUSH
101073: CALL 18588 0 3
101077: ST_TO_ADDR
// result := true ;
101078: LD_ADDR_VAR 0 4
101082: PUSH
101083: LD_INT 1
101085: ST_TO_ADDR
// end ;
101086: LD_VAR 0 4
101090: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
101091: LD_INT 0
101093: PPUSH
101094: PPUSH
101095: PPUSH
// if not unit in minersList then
101096: LD_VAR 0 1
101100: PUSH
101101: LD_EXP 180
101105: IN
101106: NOT
101107: IFFALSE 101111
// exit ;
101109: GO 101503
// index := GetElementIndex ( minersList , unit ) ;
101111: LD_ADDR_VAR 0 6
101115: PUSH
101116: LD_EXP 180
101120: PPUSH
101121: LD_VAR 0 1
101125: PPUSH
101126: CALL 18373 0 2
101130: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
101131: LD_ADDR_VAR 0 5
101135: PUSH
101136: DOUBLE
101137: LD_EXP 181
101141: PUSH
101142: LD_VAR 0 6
101146: ARRAY
101147: INC
101148: ST_TO_ADDR
101149: LD_INT 1
101151: PUSH
101152: FOR_DOWNTO
101153: IFFALSE 101314
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
101155: LD_EXP 181
101159: PUSH
101160: LD_VAR 0 6
101164: ARRAY
101165: PUSH
101166: LD_VAR 0 5
101170: ARRAY
101171: PUSH
101172: LD_INT 1
101174: ARRAY
101175: PUSH
101176: LD_VAR 0 2
101180: EQUAL
101181: PUSH
101182: LD_EXP 181
101186: PUSH
101187: LD_VAR 0 6
101191: ARRAY
101192: PUSH
101193: LD_VAR 0 5
101197: ARRAY
101198: PUSH
101199: LD_INT 2
101201: ARRAY
101202: PUSH
101203: LD_VAR 0 3
101207: EQUAL
101208: AND
101209: IFFALSE 101312
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
101211: LD_EXP 181
101215: PUSH
101216: LD_VAR 0 6
101220: ARRAY
101221: PUSH
101222: LD_VAR 0 5
101226: ARRAY
101227: PUSH
101228: LD_INT 1
101230: ARRAY
101231: PPUSH
101232: LD_EXP 181
101236: PUSH
101237: LD_VAR 0 6
101241: ARRAY
101242: PUSH
101243: LD_VAR 0 5
101247: ARRAY
101248: PUSH
101249: LD_INT 2
101251: ARRAY
101252: PPUSH
101253: LD_VAR 0 1
101257: PPUSH
101258: CALL_OW 255
101262: PPUSH
101263: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
101267: LD_ADDR_EXP 181
101271: PUSH
101272: LD_EXP 181
101276: PPUSH
101277: LD_VAR 0 6
101281: PPUSH
101282: LD_EXP 181
101286: PUSH
101287: LD_VAR 0 6
101291: ARRAY
101292: PPUSH
101293: LD_VAR 0 5
101297: PPUSH
101298: CALL_OW 3
101302: PPUSH
101303: CALL_OW 1
101307: ST_TO_ADDR
// exit ;
101308: POP
101309: POP
101310: GO 101503
// end ; end ;
101312: GO 101152
101314: POP
101315: POP
// for i := minerMinesList [ index ] downto 1 do
101316: LD_ADDR_VAR 0 5
101320: PUSH
101321: DOUBLE
101322: LD_EXP 181
101326: PUSH
101327: LD_VAR 0 6
101331: ARRAY
101332: INC
101333: ST_TO_ADDR
101334: LD_INT 1
101336: PUSH
101337: FOR_DOWNTO
101338: IFFALSE 101501
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
101340: LD_EXP 181
101344: PUSH
101345: LD_VAR 0 6
101349: ARRAY
101350: PUSH
101351: LD_VAR 0 5
101355: ARRAY
101356: PUSH
101357: LD_INT 1
101359: ARRAY
101360: PPUSH
101361: LD_EXP 181
101365: PUSH
101366: LD_VAR 0 6
101370: ARRAY
101371: PUSH
101372: LD_VAR 0 5
101376: ARRAY
101377: PUSH
101378: LD_INT 2
101380: ARRAY
101381: PPUSH
101382: LD_VAR 0 2
101386: PPUSH
101387: LD_VAR 0 3
101391: PPUSH
101392: CALL_OW 298
101396: PUSH
101397: LD_INT 6
101399: LESS
101400: IFFALSE 101499
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
101402: LD_EXP 181
101406: PUSH
101407: LD_VAR 0 6
101411: ARRAY
101412: PUSH
101413: LD_VAR 0 5
101417: ARRAY
101418: PUSH
101419: LD_INT 1
101421: ARRAY
101422: PPUSH
101423: LD_EXP 181
101427: PUSH
101428: LD_VAR 0 6
101432: ARRAY
101433: PUSH
101434: LD_VAR 0 5
101438: ARRAY
101439: PUSH
101440: LD_INT 2
101442: ARRAY
101443: PPUSH
101444: LD_VAR 0 1
101448: PPUSH
101449: CALL_OW 255
101453: PPUSH
101454: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
101458: LD_ADDR_EXP 181
101462: PUSH
101463: LD_EXP 181
101467: PPUSH
101468: LD_VAR 0 6
101472: PPUSH
101473: LD_EXP 181
101477: PUSH
101478: LD_VAR 0 6
101482: ARRAY
101483: PPUSH
101484: LD_VAR 0 5
101488: PPUSH
101489: CALL_OW 3
101493: PPUSH
101494: CALL_OW 1
101498: ST_TO_ADDR
// end ; end ;
101499: GO 101337
101501: POP
101502: POP
// end ;
101503: LD_VAR 0 4
101507: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
101508: LD_INT 0
101510: PPUSH
101511: PPUSH
101512: PPUSH
101513: PPUSH
101514: PPUSH
101515: PPUSH
101516: PPUSH
101517: PPUSH
101518: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
101519: LD_VAR 0 1
101523: PPUSH
101524: CALL_OW 264
101528: PUSH
101529: LD_EXP 55
101533: EQUAL
101534: NOT
101535: PUSH
101536: LD_VAR 0 1
101540: PUSH
101541: LD_EXP 180
101545: IN
101546: NOT
101547: OR
101548: IFFALSE 101552
// exit ;
101550: GO 101874
// index := GetElementIndex ( minersList , unit ) ;
101552: LD_ADDR_VAR 0 6
101556: PUSH
101557: LD_EXP 180
101561: PPUSH
101562: LD_VAR 0 1
101566: PPUSH
101567: CALL 18373 0 2
101571: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
101572: LD_ADDR_VAR 0 8
101576: PUSH
101577: LD_EXP 182
101581: PUSH
101582: LD_EXP 181
101586: PUSH
101587: LD_VAR 0 6
101591: ARRAY
101592: MINUS
101593: ST_TO_ADDR
// if not minesFreeAmount then
101594: LD_VAR 0 8
101598: NOT
101599: IFFALSE 101603
// exit ;
101601: GO 101874
// tmp := [ ] ;
101603: LD_ADDR_VAR 0 7
101607: PUSH
101608: EMPTY
101609: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
101610: LD_ADDR_VAR 0 5
101614: PUSH
101615: DOUBLE
101616: LD_INT 1
101618: DEC
101619: ST_TO_ADDR
101620: LD_VAR 0 8
101624: PUSH
101625: FOR_TO
101626: IFFALSE 101821
// begin _d := rand ( 0 , 5 ) ;
101628: LD_ADDR_VAR 0 11
101632: PUSH
101633: LD_INT 0
101635: PPUSH
101636: LD_INT 5
101638: PPUSH
101639: CALL_OW 12
101643: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
101644: LD_ADDR_VAR 0 12
101648: PUSH
101649: LD_INT 2
101651: PPUSH
101652: LD_INT 6
101654: PPUSH
101655: CALL_OW 12
101659: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
101660: LD_ADDR_VAR 0 9
101664: PUSH
101665: LD_VAR 0 2
101669: PPUSH
101670: LD_VAR 0 11
101674: PPUSH
101675: LD_VAR 0 12
101679: PPUSH
101680: CALL_OW 272
101684: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
101685: LD_ADDR_VAR 0 10
101689: PUSH
101690: LD_VAR 0 3
101694: PPUSH
101695: LD_VAR 0 11
101699: PPUSH
101700: LD_VAR 0 12
101704: PPUSH
101705: CALL_OW 273
101709: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
101710: LD_VAR 0 9
101714: PPUSH
101715: LD_VAR 0 10
101719: PPUSH
101720: CALL_OW 488
101724: PUSH
101725: LD_VAR 0 9
101729: PUSH
101730: LD_VAR 0 10
101734: PUSH
101735: EMPTY
101736: LIST
101737: LIST
101738: PUSH
101739: LD_VAR 0 7
101743: IN
101744: NOT
101745: AND
101746: PUSH
101747: LD_VAR 0 9
101751: PPUSH
101752: LD_VAR 0 10
101756: PPUSH
101757: CALL_OW 458
101761: NOT
101762: AND
101763: IFFALSE 101805
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
101765: LD_ADDR_VAR 0 7
101769: PUSH
101770: LD_VAR 0 7
101774: PPUSH
101775: LD_VAR 0 7
101779: PUSH
101780: LD_INT 1
101782: PLUS
101783: PPUSH
101784: LD_VAR 0 9
101788: PUSH
101789: LD_VAR 0 10
101793: PUSH
101794: EMPTY
101795: LIST
101796: LIST
101797: PPUSH
101798: CALL_OW 1
101802: ST_TO_ADDR
101803: GO 101819
// i := i - 1 ;
101805: LD_ADDR_VAR 0 5
101809: PUSH
101810: LD_VAR 0 5
101814: PUSH
101815: LD_INT 1
101817: MINUS
101818: ST_TO_ADDR
// end ;
101819: GO 101625
101821: POP
101822: POP
// for i in tmp do
101823: LD_ADDR_VAR 0 5
101827: PUSH
101828: LD_VAR 0 7
101832: PUSH
101833: FOR_IN
101834: IFFALSE 101872
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
101836: LD_VAR 0 1
101840: PPUSH
101841: LD_VAR 0 5
101845: PUSH
101846: LD_INT 1
101848: ARRAY
101849: PPUSH
101850: LD_VAR 0 5
101854: PUSH
101855: LD_INT 2
101857: ARRAY
101858: PPUSH
101859: CALL 100814 0 3
101863: NOT
101864: IFFALSE 101870
// exit ;
101866: POP
101867: POP
101868: GO 101874
101870: GO 101833
101872: POP
101873: POP
// end ;
101874: LD_VAR 0 4
101878: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
101879: LD_INT 0
101881: PPUSH
101882: PPUSH
101883: PPUSH
101884: PPUSH
101885: PPUSH
101886: PPUSH
101887: PPUSH
// if not GetClass ( unit ) = class_sniper then
101888: LD_VAR 0 1
101892: PPUSH
101893: CALL_OW 257
101897: PUSH
101898: LD_INT 5
101900: EQUAL
101901: NOT
101902: IFFALSE 101906
// exit ;
101904: GO 102294
// dist := 8 ;
101906: LD_ADDR_VAR 0 5
101910: PUSH
101911: LD_INT 8
101913: ST_TO_ADDR
// viewRange := 12 ;
101914: LD_ADDR_VAR 0 7
101918: PUSH
101919: LD_INT 12
101921: ST_TO_ADDR
// side := GetSide ( unit ) ;
101922: LD_ADDR_VAR 0 6
101926: PUSH
101927: LD_VAR 0 1
101931: PPUSH
101932: CALL_OW 255
101936: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
101937: LD_INT 61
101939: PPUSH
101940: LD_VAR 0 6
101944: PPUSH
101945: CALL_OW 321
101949: PUSH
101950: LD_INT 2
101952: EQUAL
101953: IFFALSE 101963
// viewRange := 16 ;
101955: LD_ADDR_VAR 0 7
101959: PUSH
101960: LD_INT 16
101962: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
101963: LD_VAR 0 1
101967: PPUSH
101968: LD_VAR 0 2
101972: PPUSH
101973: LD_VAR 0 3
101977: PPUSH
101978: CALL_OW 297
101982: PUSH
101983: LD_VAR 0 5
101987: GREATER
101988: IFFALSE 102067
// begin ComMoveXY ( unit , x , y ) ;
101990: LD_VAR 0 1
101994: PPUSH
101995: LD_VAR 0 2
101999: PPUSH
102000: LD_VAR 0 3
102004: PPUSH
102005: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
102009: LD_INT 35
102011: PPUSH
102012: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
102016: LD_VAR 0 1
102020: PPUSH
102021: LD_VAR 0 2
102025: PPUSH
102026: LD_VAR 0 3
102030: PPUSH
102031: CALL 49145 0 3
102035: NOT
102036: IFFALSE 102040
// exit ;
102038: GO 102294
// until GetDistUnitXY ( unit , x , y ) < dist ;
102040: LD_VAR 0 1
102044: PPUSH
102045: LD_VAR 0 2
102049: PPUSH
102050: LD_VAR 0 3
102054: PPUSH
102055: CALL_OW 297
102059: PUSH
102060: LD_VAR 0 5
102064: LESS
102065: IFFALSE 102009
// end ; ComTurnXY ( unit , x , y ) ;
102067: LD_VAR 0 1
102071: PPUSH
102072: LD_VAR 0 2
102076: PPUSH
102077: LD_VAR 0 3
102081: PPUSH
102082: CALL_OW 118
// wait ( 5 ) ;
102086: LD_INT 5
102088: PPUSH
102089: CALL_OW 67
// _d := GetDir ( unit ) ;
102093: LD_ADDR_VAR 0 10
102097: PUSH
102098: LD_VAR 0 1
102102: PPUSH
102103: CALL_OW 254
102107: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
102108: LD_ADDR_VAR 0 8
102112: PUSH
102113: LD_VAR 0 1
102117: PPUSH
102118: CALL_OW 250
102122: PPUSH
102123: LD_VAR 0 10
102127: PPUSH
102128: LD_VAR 0 5
102132: PPUSH
102133: CALL_OW 272
102137: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
102138: LD_ADDR_VAR 0 9
102142: PUSH
102143: LD_VAR 0 1
102147: PPUSH
102148: CALL_OW 251
102152: PPUSH
102153: LD_VAR 0 10
102157: PPUSH
102158: LD_VAR 0 5
102162: PPUSH
102163: CALL_OW 273
102167: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
102168: LD_VAR 0 8
102172: PPUSH
102173: LD_VAR 0 9
102177: PPUSH
102178: CALL_OW 488
102182: NOT
102183: IFFALSE 102187
// exit ;
102185: GO 102294
// ComAnimCustom ( unit , 1 ) ;
102187: LD_VAR 0 1
102191: PPUSH
102192: LD_INT 1
102194: PPUSH
102195: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
102199: LD_VAR 0 8
102203: PPUSH
102204: LD_VAR 0 9
102208: PPUSH
102209: LD_VAR 0 6
102213: PPUSH
102214: LD_VAR 0 7
102218: PPUSH
102219: CALL_OW 330
// repeat wait ( 1 ) ;
102223: LD_INT 1
102225: PPUSH
102226: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
102230: LD_VAR 0 1
102234: PPUSH
102235: CALL_OW 316
102239: PUSH
102240: LD_VAR 0 1
102244: PPUSH
102245: CALL_OW 314
102249: OR
102250: PUSH
102251: LD_VAR 0 1
102255: PPUSH
102256: CALL_OW 302
102260: NOT
102261: OR
102262: PUSH
102263: LD_VAR 0 1
102267: PPUSH
102268: CALL_OW 301
102272: OR
102273: IFFALSE 102223
// RemoveSeeing ( _x , _y , side ) ;
102275: LD_VAR 0 8
102279: PPUSH
102280: LD_VAR 0 9
102284: PPUSH
102285: LD_VAR 0 6
102289: PPUSH
102290: CALL_OW 331
// end ; end_of_file
102294: LD_VAR 0 4
102298: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
102299: LD_INT 0
102301: PPUSH
102302: PPUSH
102303: PPUSH
102304: PPUSH
102305: PPUSH
102306: PPUSH
102307: PPUSH
102308: PPUSH
102309: PPUSH
102310: PPUSH
102311: PPUSH
102312: PPUSH
102313: PPUSH
102314: PPUSH
102315: PPUSH
102316: PPUSH
102317: PPUSH
102318: PPUSH
102319: PPUSH
102320: PPUSH
102321: PPUSH
102322: PPUSH
102323: PPUSH
102324: PPUSH
102325: PPUSH
102326: PPUSH
102327: PPUSH
102328: PPUSH
102329: PPUSH
102330: PPUSH
102331: PPUSH
102332: PPUSH
102333: PPUSH
102334: PPUSH
// if not list then
102335: LD_VAR 0 1
102339: NOT
102340: IFFALSE 102344
// exit ;
102342: GO 107003
// base := list [ 1 ] ;
102344: LD_ADDR_VAR 0 3
102348: PUSH
102349: LD_VAR 0 1
102353: PUSH
102354: LD_INT 1
102356: ARRAY
102357: ST_TO_ADDR
// group := list [ 2 ] ;
102358: LD_ADDR_VAR 0 4
102362: PUSH
102363: LD_VAR 0 1
102367: PUSH
102368: LD_INT 2
102370: ARRAY
102371: ST_TO_ADDR
// path := list [ 3 ] ;
102372: LD_ADDR_VAR 0 5
102376: PUSH
102377: LD_VAR 0 1
102381: PUSH
102382: LD_INT 3
102384: ARRAY
102385: ST_TO_ADDR
// flags := list [ 4 ] ;
102386: LD_ADDR_VAR 0 6
102390: PUSH
102391: LD_VAR 0 1
102395: PUSH
102396: LD_INT 4
102398: ARRAY
102399: ST_TO_ADDR
// mined := [ ] ;
102400: LD_ADDR_VAR 0 27
102404: PUSH
102405: EMPTY
102406: ST_TO_ADDR
// bombed := [ ] ;
102407: LD_ADDR_VAR 0 28
102411: PUSH
102412: EMPTY
102413: ST_TO_ADDR
// healers := [ ] ;
102414: LD_ADDR_VAR 0 31
102418: PUSH
102419: EMPTY
102420: ST_TO_ADDR
// to_heal := [ ] ;
102421: LD_ADDR_VAR 0 30
102425: PUSH
102426: EMPTY
102427: ST_TO_ADDR
// repairs := [ ] ;
102428: LD_ADDR_VAR 0 33
102432: PUSH
102433: EMPTY
102434: ST_TO_ADDR
// to_repair := [ ] ;
102435: LD_ADDR_VAR 0 32
102439: PUSH
102440: EMPTY
102441: ST_TO_ADDR
// if not group or not path then
102442: LD_VAR 0 4
102446: NOT
102447: PUSH
102448: LD_VAR 0 5
102452: NOT
102453: OR
102454: IFFALSE 102458
// exit ;
102456: GO 107003
// side := GetSide ( group [ 1 ] ) ;
102458: LD_ADDR_VAR 0 35
102462: PUSH
102463: LD_VAR 0 4
102467: PUSH
102468: LD_INT 1
102470: ARRAY
102471: PPUSH
102472: CALL_OW 255
102476: ST_TO_ADDR
// if flags then
102477: LD_VAR 0 6
102481: IFFALSE 102625
// begin f_ignore_area := flags [ 1 ] ;
102483: LD_ADDR_VAR 0 17
102487: PUSH
102488: LD_VAR 0 6
102492: PUSH
102493: LD_INT 1
102495: ARRAY
102496: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
102497: LD_ADDR_VAR 0 18
102501: PUSH
102502: LD_VAR 0 6
102506: PUSH
102507: LD_INT 2
102509: ARRAY
102510: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
102511: LD_ADDR_VAR 0 19
102515: PUSH
102516: LD_VAR 0 6
102520: PUSH
102521: LD_INT 3
102523: ARRAY
102524: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
102525: LD_ADDR_VAR 0 20
102529: PUSH
102530: LD_VAR 0 6
102534: PUSH
102535: LD_INT 4
102537: ARRAY
102538: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
102539: LD_ADDR_VAR 0 21
102543: PUSH
102544: LD_VAR 0 6
102548: PUSH
102549: LD_INT 5
102551: ARRAY
102552: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
102553: LD_ADDR_VAR 0 22
102557: PUSH
102558: LD_VAR 0 6
102562: PUSH
102563: LD_INT 6
102565: ARRAY
102566: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
102567: LD_ADDR_VAR 0 23
102571: PUSH
102572: LD_VAR 0 6
102576: PUSH
102577: LD_INT 7
102579: ARRAY
102580: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
102581: LD_ADDR_VAR 0 24
102585: PUSH
102586: LD_VAR 0 6
102590: PUSH
102591: LD_INT 8
102593: ARRAY
102594: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
102595: LD_ADDR_VAR 0 25
102599: PUSH
102600: LD_VAR 0 6
102604: PUSH
102605: LD_INT 9
102607: ARRAY
102608: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
102609: LD_ADDR_VAR 0 26
102613: PUSH
102614: LD_VAR 0 6
102618: PUSH
102619: LD_INT 10
102621: ARRAY
102622: ST_TO_ADDR
// end else
102623: GO 102705
// begin f_ignore_area := false ;
102625: LD_ADDR_VAR 0 17
102629: PUSH
102630: LD_INT 0
102632: ST_TO_ADDR
// f_capture := false ;
102633: LD_ADDR_VAR 0 18
102637: PUSH
102638: LD_INT 0
102640: ST_TO_ADDR
// f_ignore_civ := false ;
102641: LD_ADDR_VAR 0 19
102645: PUSH
102646: LD_INT 0
102648: ST_TO_ADDR
// f_murder := false ;
102649: LD_ADDR_VAR 0 20
102653: PUSH
102654: LD_INT 0
102656: ST_TO_ADDR
// f_mines := false ;
102657: LD_ADDR_VAR 0 21
102661: PUSH
102662: LD_INT 0
102664: ST_TO_ADDR
// f_repair := false ;
102665: LD_ADDR_VAR 0 22
102669: PUSH
102670: LD_INT 0
102672: ST_TO_ADDR
// f_heal := false ;
102673: LD_ADDR_VAR 0 23
102677: PUSH
102678: LD_INT 0
102680: ST_TO_ADDR
// f_spacetime := false ;
102681: LD_ADDR_VAR 0 24
102685: PUSH
102686: LD_INT 0
102688: ST_TO_ADDR
// f_attack_depot := false ;
102689: LD_ADDR_VAR 0 25
102693: PUSH
102694: LD_INT 0
102696: ST_TO_ADDR
// f_crawl := false ;
102697: LD_ADDR_VAR 0 26
102701: PUSH
102702: LD_INT 0
102704: ST_TO_ADDR
// end ; if f_heal then
102705: LD_VAR 0 23
102709: IFFALSE 102736
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
102711: LD_ADDR_VAR 0 31
102715: PUSH
102716: LD_VAR 0 4
102720: PPUSH
102721: LD_INT 25
102723: PUSH
102724: LD_INT 4
102726: PUSH
102727: EMPTY
102728: LIST
102729: LIST
102730: PPUSH
102731: CALL_OW 72
102735: ST_TO_ADDR
// if f_repair then
102736: LD_VAR 0 22
102740: IFFALSE 102767
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
102742: LD_ADDR_VAR 0 33
102746: PUSH
102747: LD_VAR 0 4
102751: PPUSH
102752: LD_INT 25
102754: PUSH
102755: LD_INT 3
102757: PUSH
102758: EMPTY
102759: LIST
102760: LIST
102761: PPUSH
102762: CALL_OW 72
102766: ST_TO_ADDR
// units_path := [ ] ;
102767: LD_ADDR_VAR 0 16
102771: PUSH
102772: EMPTY
102773: ST_TO_ADDR
// for i = 1 to group do
102774: LD_ADDR_VAR 0 7
102778: PUSH
102779: DOUBLE
102780: LD_INT 1
102782: DEC
102783: ST_TO_ADDR
102784: LD_VAR 0 4
102788: PUSH
102789: FOR_TO
102790: IFFALSE 102819
// units_path := Replace ( units_path , i , path ) ;
102792: LD_ADDR_VAR 0 16
102796: PUSH
102797: LD_VAR 0 16
102801: PPUSH
102802: LD_VAR 0 7
102806: PPUSH
102807: LD_VAR 0 5
102811: PPUSH
102812: CALL_OW 1
102816: ST_TO_ADDR
102817: GO 102789
102819: POP
102820: POP
// repeat for i = group downto 1 do
102821: LD_ADDR_VAR 0 7
102825: PUSH
102826: DOUBLE
102827: LD_VAR 0 4
102831: INC
102832: ST_TO_ADDR
102833: LD_INT 1
102835: PUSH
102836: FOR_DOWNTO
102837: IFFALSE 106959
// begin wait ( 5 ) ;
102839: LD_INT 5
102841: PPUSH
102842: CALL_OW 67
// tmp := [ ] ;
102846: LD_ADDR_VAR 0 14
102850: PUSH
102851: EMPTY
102852: ST_TO_ADDR
// attacking := false ;
102853: LD_ADDR_VAR 0 29
102857: PUSH
102858: LD_INT 0
102860: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
102861: LD_VAR 0 4
102865: PUSH
102866: LD_VAR 0 7
102870: ARRAY
102871: PPUSH
102872: CALL_OW 301
102876: PUSH
102877: LD_VAR 0 4
102881: PUSH
102882: LD_VAR 0 7
102886: ARRAY
102887: NOT
102888: OR
102889: IFFALSE 102998
// begin if GetType ( group [ i ] ) = unit_human then
102891: LD_VAR 0 4
102895: PUSH
102896: LD_VAR 0 7
102900: ARRAY
102901: PPUSH
102902: CALL_OW 247
102906: PUSH
102907: LD_INT 1
102909: EQUAL
102910: IFFALSE 102956
// begin to_heal := to_heal diff group [ i ] ;
102912: LD_ADDR_VAR 0 30
102916: PUSH
102917: LD_VAR 0 30
102921: PUSH
102922: LD_VAR 0 4
102926: PUSH
102927: LD_VAR 0 7
102931: ARRAY
102932: DIFF
102933: ST_TO_ADDR
// healers := healers diff group [ i ] ;
102934: LD_ADDR_VAR 0 31
102938: PUSH
102939: LD_VAR 0 31
102943: PUSH
102944: LD_VAR 0 4
102948: PUSH
102949: LD_VAR 0 7
102953: ARRAY
102954: DIFF
102955: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
102956: LD_ADDR_VAR 0 4
102960: PUSH
102961: LD_VAR 0 4
102965: PPUSH
102966: LD_VAR 0 7
102970: PPUSH
102971: CALL_OW 3
102975: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
102976: LD_ADDR_VAR 0 16
102980: PUSH
102981: LD_VAR 0 16
102985: PPUSH
102986: LD_VAR 0 7
102990: PPUSH
102991: CALL_OW 3
102995: ST_TO_ADDR
// continue ;
102996: GO 102836
// end ; if f_repair then
102998: LD_VAR 0 22
103002: IFFALSE 103491
// begin if GetType ( group [ i ] ) = unit_vehicle then
103004: LD_VAR 0 4
103008: PUSH
103009: LD_VAR 0 7
103013: ARRAY
103014: PPUSH
103015: CALL_OW 247
103019: PUSH
103020: LD_INT 2
103022: EQUAL
103023: IFFALSE 103213
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
103025: LD_VAR 0 4
103029: PUSH
103030: LD_VAR 0 7
103034: ARRAY
103035: PPUSH
103036: CALL_OW 256
103040: PUSH
103041: LD_INT 700
103043: LESS
103044: PUSH
103045: LD_VAR 0 4
103049: PUSH
103050: LD_VAR 0 7
103054: ARRAY
103055: PUSH
103056: LD_VAR 0 32
103060: IN
103061: NOT
103062: AND
103063: IFFALSE 103087
// to_repair := to_repair union group [ i ] ;
103065: LD_ADDR_VAR 0 32
103069: PUSH
103070: LD_VAR 0 32
103074: PUSH
103075: LD_VAR 0 4
103079: PUSH
103080: LD_VAR 0 7
103084: ARRAY
103085: UNION
103086: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
103087: LD_VAR 0 4
103091: PUSH
103092: LD_VAR 0 7
103096: ARRAY
103097: PPUSH
103098: CALL_OW 256
103102: PUSH
103103: LD_INT 1000
103105: EQUAL
103106: PUSH
103107: LD_VAR 0 4
103111: PUSH
103112: LD_VAR 0 7
103116: ARRAY
103117: PUSH
103118: LD_VAR 0 32
103122: IN
103123: AND
103124: IFFALSE 103148
// to_repair := to_repair diff group [ i ] ;
103126: LD_ADDR_VAR 0 32
103130: PUSH
103131: LD_VAR 0 32
103135: PUSH
103136: LD_VAR 0 4
103140: PUSH
103141: LD_VAR 0 7
103145: ARRAY
103146: DIFF
103147: ST_TO_ADDR
// if group [ i ] in to_repair then
103148: LD_VAR 0 4
103152: PUSH
103153: LD_VAR 0 7
103157: ARRAY
103158: PUSH
103159: LD_VAR 0 32
103163: IN
103164: IFFALSE 103211
// begin if not IsInArea ( group [ i ] , f_repair ) then
103166: LD_VAR 0 4
103170: PUSH
103171: LD_VAR 0 7
103175: ARRAY
103176: PPUSH
103177: LD_VAR 0 22
103181: PPUSH
103182: CALL_OW 308
103186: NOT
103187: IFFALSE 103209
// ComMoveToArea ( group [ i ] , f_repair ) ;
103189: LD_VAR 0 4
103193: PUSH
103194: LD_VAR 0 7
103198: ARRAY
103199: PPUSH
103200: LD_VAR 0 22
103204: PPUSH
103205: CALL_OW 113
// continue ;
103209: GO 102836
// end ; end else
103211: GO 103491
// if group [ i ] in repairs then
103213: LD_VAR 0 4
103217: PUSH
103218: LD_VAR 0 7
103222: ARRAY
103223: PUSH
103224: LD_VAR 0 33
103228: IN
103229: IFFALSE 103491
// begin if IsInUnit ( group [ i ] ) then
103231: LD_VAR 0 4
103235: PUSH
103236: LD_VAR 0 7
103240: ARRAY
103241: PPUSH
103242: CALL_OW 310
103246: IFFALSE 103314
// begin z := IsInUnit ( group [ i ] ) ;
103248: LD_ADDR_VAR 0 13
103252: PUSH
103253: LD_VAR 0 4
103257: PUSH
103258: LD_VAR 0 7
103262: ARRAY
103263: PPUSH
103264: CALL_OW 310
103268: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
103269: LD_VAR 0 13
103273: PUSH
103274: LD_VAR 0 32
103278: IN
103279: PUSH
103280: LD_VAR 0 13
103284: PPUSH
103285: LD_VAR 0 22
103289: PPUSH
103290: CALL_OW 308
103294: AND
103295: IFFALSE 103312
// ComExitVehicle ( group [ i ] ) ;
103297: LD_VAR 0 4
103301: PUSH
103302: LD_VAR 0 7
103306: ARRAY
103307: PPUSH
103308: CALL_OW 121
// end else
103312: GO 103491
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
103314: LD_ADDR_VAR 0 13
103318: PUSH
103319: LD_VAR 0 4
103323: PPUSH
103324: LD_INT 95
103326: PUSH
103327: LD_VAR 0 22
103331: PUSH
103332: EMPTY
103333: LIST
103334: LIST
103335: PUSH
103336: LD_INT 58
103338: PUSH
103339: EMPTY
103340: LIST
103341: PUSH
103342: EMPTY
103343: LIST
103344: LIST
103345: PPUSH
103346: CALL_OW 72
103350: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
103351: LD_VAR 0 4
103355: PUSH
103356: LD_VAR 0 7
103360: ARRAY
103361: PPUSH
103362: CALL_OW 314
103366: NOT
103367: IFFALSE 103489
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
103369: LD_ADDR_VAR 0 10
103373: PUSH
103374: LD_VAR 0 13
103378: PPUSH
103379: LD_VAR 0 4
103383: PUSH
103384: LD_VAR 0 7
103388: ARRAY
103389: PPUSH
103390: CALL_OW 74
103394: ST_TO_ADDR
// if not x then
103395: LD_VAR 0 10
103399: NOT
103400: IFFALSE 103404
// continue ;
103402: GO 102836
// if GetLives ( x ) < 1000 then
103404: LD_VAR 0 10
103408: PPUSH
103409: CALL_OW 256
103413: PUSH
103414: LD_INT 1000
103416: LESS
103417: IFFALSE 103441
// ComRepairVehicle ( group [ i ] , x ) else
103419: LD_VAR 0 4
103423: PUSH
103424: LD_VAR 0 7
103428: ARRAY
103429: PPUSH
103430: LD_VAR 0 10
103434: PPUSH
103435: CALL_OW 129
103439: GO 103489
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
103441: LD_VAR 0 23
103445: PUSH
103446: LD_VAR 0 4
103450: PUSH
103451: LD_VAR 0 7
103455: ARRAY
103456: PPUSH
103457: CALL_OW 256
103461: PUSH
103462: LD_INT 1000
103464: LESS
103465: AND
103466: NOT
103467: IFFALSE 103489
// ComEnterUnit ( group [ i ] , x ) ;
103469: LD_VAR 0 4
103473: PUSH
103474: LD_VAR 0 7
103478: ARRAY
103479: PPUSH
103480: LD_VAR 0 10
103484: PPUSH
103485: CALL_OW 120
// end ; continue ;
103489: GO 102836
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
103491: LD_VAR 0 23
103495: PUSH
103496: LD_VAR 0 4
103500: PUSH
103501: LD_VAR 0 7
103505: ARRAY
103506: PPUSH
103507: CALL_OW 247
103511: PUSH
103512: LD_INT 1
103514: EQUAL
103515: AND
103516: IFFALSE 103994
// begin if group [ i ] in healers then
103518: LD_VAR 0 4
103522: PUSH
103523: LD_VAR 0 7
103527: ARRAY
103528: PUSH
103529: LD_VAR 0 31
103533: IN
103534: IFFALSE 103807
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
103536: LD_VAR 0 4
103540: PUSH
103541: LD_VAR 0 7
103545: ARRAY
103546: PPUSH
103547: LD_VAR 0 23
103551: PPUSH
103552: CALL_OW 308
103556: NOT
103557: PUSH
103558: LD_VAR 0 4
103562: PUSH
103563: LD_VAR 0 7
103567: ARRAY
103568: PPUSH
103569: CALL_OW 314
103573: NOT
103574: AND
103575: IFFALSE 103599
// ComMoveToArea ( group [ i ] , f_heal ) else
103577: LD_VAR 0 4
103581: PUSH
103582: LD_VAR 0 7
103586: ARRAY
103587: PPUSH
103588: LD_VAR 0 23
103592: PPUSH
103593: CALL_OW 113
103597: GO 103805
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
103599: LD_VAR 0 4
103603: PUSH
103604: LD_VAR 0 7
103608: ARRAY
103609: PPUSH
103610: CALL 47668 0 1
103614: PPUSH
103615: CALL_OW 256
103619: PUSH
103620: LD_INT 1000
103622: EQUAL
103623: IFFALSE 103642
// ComStop ( group [ i ] ) else
103625: LD_VAR 0 4
103629: PUSH
103630: LD_VAR 0 7
103634: ARRAY
103635: PPUSH
103636: CALL_OW 141
103640: GO 103805
// if not HasTask ( group [ i ] ) and to_heal then
103642: LD_VAR 0 4
103646: PUSH
103647: LD_VAR 0 7
103651: ARRAY
103652: PPUSH
103653: CALL_OW 314
103657: NOT
103658: PUSH
103659: LD_VAR 0 30
103663: AND
103664: IFFALSE 103805
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
103666: LD_ADDR_VAR 0 13
103670: PUSH
103671: LD_VAR 0 30
103675: PPUSH
103676: LD_INT 3
103678: PUSH
103679: LD_INT 54
103681: PUSH
103682: EMPTY
103683: LIST
103684: PUSH
103685: EMPTY
103686: LIST
103687: LIST
103688: PPUSH
103689: CALL_OW 72
103693: PPUSH
103694: LD_VAR 0 4
103698: PUSH
103699: LD_VAR 0 7
103703: ARRAY
103704: PPUSH
103705: CALL_OW 74
103709: ST_TO_ADDR
// if z then
103710: LD_VAR 0 13
103714: IFFALSE 103805
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
103716: LD_INT 91
103718: PUSH
103719: LD_VAR 0 13
103723: PUSH
103724: LD_INT 10
103726: PUSH
103727: EMPTY
103728: LIST
103729: LIST
103730: LIST
103731: PUSH
103732: LD_INT 81
103734: PUSH
103735: LD_VAR 0 13
103739: PPUSH
103740: CALL_OW 255
103744: PUSH
103745: EMPTY
103746: LIST
103747: LIST
103748: PUSH
103749: EMPTY
103750: LIST
103751: LIST
103752: PPUSH
103753: CALL_OW 69
103757: PUSH
103758: LD_INT 0
103760: EQUAL
103761: IFFALSE 103785
// ComHeal ( group [ i ] , z ) else
103763: LD_VAR 0 4
103767: PUSH
103768: LD_VAR 0 7
103772: ARRAY
103773: PPUSH
103774: LD_VAR 0 13
103778: PPUSH
103779: CALL_OW 128
103783: GO 103805
// ComMoveToArea ( group [ i ] , f_heal ) ;
103785: LD_VAR 0 4
103789: PUSH
103790: LD_VAR 0 7
103794: ARRAY
103795: PPUSH
103796: LD_VAR 0 23
103800: PPUSH
103801: CALL_OW 113
// end ; continue ;
103805: GO 102836
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
103807: LD_VAR 0 4
103811: PUSH
103812: LD_VAR 0 7
103816: ARRAY
103817: PPUSH
103818: CALL_OW 256
103822: PUSH
103823: LD_INT 700
103825: LESS
103826: PUSH
103827: LD_VAR 0 4
103831: PUSH
103832: LD_VAR 0 7
103836: ARRAY
103837: PUSH
103838: LD_VAR 0 30
103842: IN
103843: NOT
103844: AND
103845: IFFALSE 103869
// to_heal := to_heal union group [ i ] ;
103847: LD_ADDR_VAR 0 30
103851: PUSH
103852: LD_VAR 0 30
103856: PUSH
103857: LD_VAR 0 4
103861: PUSH
103862: LD_VAR 0 7
103866: ARRAY
103867: UNION
103868: ST_TO_ADDR
// if group [ i ] in to_heal then
103869: LD_VAR 0 4
103873: PUSH
103874: LD_VAR 0 7
103878: ARRAY
103879: PUSH
103880: LD_VAR 0 30
103884: IN
103885: IFFALSE 103994
// begin if GetLives ( group [ i ] ) = 1000 then
103887: LD_VAR 0 4
103891: PUSH
103892: LD_VAR 0 7
103896: ARRAY
103897: PPUSH
103898: CALL_OW 256
103902: PUSH
103903: LD_INT 1000
103905: EQUAL
103906: IFFALSE 103932
// to_heal := to_heal diff group [ i ] else
103908: LD_ADDR_VAR 0 30
103912: PUSH
103913: LD_VAR 0 30
103917: PUSH
103918: LD_VAR 0 4
103922: PUSH
103923: LD_VAR 0 7
103927: ARRAY
103928: DIFF
103929: ST_TO_ADDR
103930: GO 103994
// begin if not IsInArea ( group [ i ] , to_heal ) then
103932: LD_VAR 0 4
103936: PUSH
103937: LD_VAR 0 7
103941: ARRAY
103942: PPUSH
103943: LD_VAR 0 30
103947: PPUSH
103948: CALL_OW 308
103952: NOT
103953: IFFALSE 103977
// ComMoveToArea ( group [ i ] , f_heal ) else
103955: LD_VAR 0 4
103959: PUSH
103960: LD_VAR 0 7
103964: ARRAY
103965: PPUSH
103966: LD_VAR 0 23
103970: PPUSH
103971: CALL_OW 113
103975: GO 103992
// ComHold ( group [ i ] ) ;
103977: LD_VAR 0 4
103981: PUSH
103982: LD_VAR 0 7
103986: ARRAY
103987: PPUSH
103988: CALL_OW 140
// continue ;
103992: GO 102836
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
103994: LD_VAR 0 4
103998: PUSH
103999: LD_VAR 0 7
104003: ARRAY
104004: PPUSH
104005: LD_INT 10
104007: PPUSH
104008: CALL 46088 0 2
104012: NOT
104013: PUSH
104014: LD_VAR 0 16
104018: PUSH
104019: LD_VAR 0 7
104023: ARRAY
104024: PUSH
104025: EMPTY
104026: EQUAL
104027: NOT
104028: AND
104029: IFFALSE 104295
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
104031: LD_VAR 0 4
104035: PUSH
104036: LD_VAR 0 7
104040: ARRAY
104041: PPUSH
104042: CALL_OW 262
104046: PUSH
104047: LD_INT 1
104049: PUSH
104050: LD_INT 2
104052: PUSH
104053: EMPTY
104054: LIST
104055: LIST
104056: IN
104057: IFFALSE 104098
// if GetFuel ( group [ i ] ) < 10 then
104059: LD_VAR 0 4
104063: PUSH
104064: LD_VAR 0 7
104068: ARRAY
104069: PPUSH
104070: CALL_OW 261
104074: PUSH
104075: LD_INT 10
104077: LESS
104078: IFFALSE 104098
// SetFuel ( group [ i ] , 12 ) ;
104080: LD_VAR 0 4
104084: PUSH
104085: LD_VAR 0 7
104089: ARRAY
104090: PPUSH
104091: LD_INT 12
104093: PPUSH
104094: CALL_OW 240
// if units_path [ i ] then
104098: LD_VAR 0 16
104102: PUSH
104103: LD_VAR 0 7
104107: ARRAY
104108: IFFALSE 104293
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
104110: LD_VAR 0 4
104114: PUSH
104115: LD_VAR 0 7
104119: ARRAY
104120: PPUSH
104121: LD_VAR 0 16
104125: PUSH
104126: LD_VAR 0 7
104130: ARRAY
104131: PUSH
104132: LD_INT 1
104134: ARRAY
104135: PUSH
104136: LD_INT 1
104138: ARRAY
104139: PPUSH
104140: LD_VAR 0 16
104144: PUSH
104145: LD_VAR 0 7
104149: ARRAY
104150: PUSH
104151: LD_INT 1
104153: ARRAY
104154: PUSH
104155: LD_INT 2
104157: ARRAY
104158: PPUSH
104159: CALL_OW 297
104163: PUSH
104164: LD_INT 6
104166: GREATER
104167: IFFALSE 104242
// begin if not HasTask ( group [ i ] ) then
104169: LD_VAR 0 4
104173: PUSH
104174: LD_VAR 0 7
104178: ARRAY
104179: PPUSH
104180: CALL_OW 314
104184: NOT
104185: IFFALSE 104240
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
104187: LD_VAR 0 4
104191: PUSH
104192: LD_VAR 0 7
104196: ARRAY
104197: PPUSH
104198: LD_VAR 0 16
104202: PUSH
104203: LD_VAR 0 7
104207: ARRAY
104208: PUSH
104209: LD_INT 1
104211: ARRAY
104212: PUSH
104213: LD_INT 1
104215: ARRAY
104216: PPUSH
104217: LD_VAR 0 16
104221: PUSH
104222: LD_VAR 0 7
104226: ARRAY
104227: PUSH
104228: LD_INT 1
104230: ARRAY
104231: PUSH
104232: LD_INT 2
104234: ARRAY
104235: PPUSH
104236: CALL_OW 114
// end else
104240: GO 104293
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
104242: LD_ADDR_VAR 0 15
104246: PUSH
104247: LD_VAR 0 16
104251: PUSH
104252: LD_VAR 0 7
104256: ARRAY
104257: PPUSH
104258: LD_INT 1
104260: PPUSH
104261: CALL_OW 3
104265: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
104266: LD_ADDR_VAR 0 16
104270: PUSH
104271: LD_VAR 0 16
104275: PPUSH
104276: LD_VAR 0 7
104280: PPUSH
104281: LD_VAR 0 15
104285: PPUSH
104286: CALL_OW 1
104290: ST_TO_ADDR
// continue ;
104291: GO 102836
// end ; end ; end else
104293: GO 106957
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
104295: LD_ADDR_VAR 0 14
104299: PUSH
104300: LD_INT 81
104302: PUSH
104303: LD_VAR 0 4
104307: PUSH
104308: LD_VAR 0 7
104312: ARRAY
104313: PPUSH
104314: CALL_OW 255
104318: PUSH
104319: EMPTY
104320: LIST
104321: LIST
104322: PPUSH
104323: CALL_OW 69
104327: ST_TO_ADDR
// if not tmp then
104328: LD_VAR 0 14
104332: NOT
104333: IFFALSE 104337
// continue ;
104335: GO 102836
// if f_ignore_area then
104337: LD_VAR 0 17
104341: IFFALSE 104429
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
104343: LD_ADDR_VAR 0 15
104347: PUSH
104348: LD_VAR 0 14
104352: PPUSH
104353: LD_INT 3
104355: PUSH
104356: LD_INT 92
104358: PUSH
104359: LD_VAR 0 17
104363: PUSH
104364: LD_INT 1
104366: ARRAY
104367: PUSH
104368: LD_VAR 0 17
104372: PUSH
104373: LD_INT 2
104375: ARRAY
104376: PUSH
104377: LD_VAR 0 17
104381: PUSH
104382: LD_INT 3
104384: ARRAY
104385: PUSH
104386: EMPTY
104387: LIST
104388: LIST
104389: LIST
104390: LIST
104391: PUSH
104392: EMPTY
104393: LIST
104394: LIST
104395: PPUSH
104396: CALL_OW 72
104400: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
104401: LD_VAR 0 14
104405: PUSH
104406: LD_VAR 0 15
104410: DIFF
104411: IFFALSE 104429
// tmp := tmp diff tmp2 ;
104413: LD_ADDR_VAR 0 14
104417: PUSH
104418: LD_VAR 0 14
104422: PUSH
104423: LD_VAR 0 15
104427: DIFF
104428: ST_TO_ADDR
// end ; if not f_murder then
104429: LD_VAR 0 20
104433: NOT
104434: IFFALSE 104492
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
104436: LD_ADDR_VAR 0 15
104440: PUSH
104441: LD_VAR 0 14
104445: PPUSH
104446: LD_INT 3
104448: PUSH
104449: LD_INT 50
104451: PUSH
104452: EMPTY
104453: LIST
104454: PUSH
104455: EMPTY
104456: LIST
104457: LIST
104458: PPUSH
104459: CALL_OW 72
104463: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
104464: LD_VAR 0 14
104468: PUSH
104469: LD_VAR 0 15
104473: DIFF
104474: IFFALSE 104492
// tmp := tmp diff tmp2 ;
104476: LD_ADDR_VAR 0 14
104480: PUSH
104481: LD_VAR 0 14
104485: PUSH
104486: LD_VAR 0 15
104490: DIFF
104491: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
104492: LD_ADDR_VAR 0 14
104496: PUSH
104497: LD_VAR 0 4
104501: PUSH
104502: LD_VAR 0 7
104506: ARRAY
104507: PPUSH
104508: LD_VAR 0 14
104512: PPUSH
104513: LD_INT 1
104515: PPUSH
104516: LD_INT 1
104518: PPUSH
104519: CALL 19023 0 4
104523: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
104524: LD_VAR 0 4
104528: PUSH
104529: LD_VAR 0 7
104533: ARRAY
104534: PPUSH
104535: CALL_OW 257
104539: PUSH
104540: LD_INT 1
104542: EQUAL
104543: IFFALSE 104991
// begin if WantPlant ( group [ i ] ) then
104545: LD_VAR 0 4
104549: PUSH
104550: LD_VAR 0 7
104554: ARRAY
104555: PPUSH
104556: CALL 18524 0 1
104560: IFFALSE 104564
// continue ;
104562: GO 102836
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
104564: LD_VAR 0 18
104568: PUSH
104569: LD_VAR 0 4
104573: PUSH
104574: LD_VAR 0 7
104578: ARRAY
104579: PPUSH
104580: CALL_OW 310
104584: NOT
104585: AND
104586: PUSH
104587: LD_VAR 0 14
104591: PUSH
104592: LD_INT 1
104594: ARRAY
104595: PUSH
104596: LD_VAR 0 14
104600: PPUSH
104601: LD_INT 21
104603: PUSH
104604: LD_INT 2
104606: PUSH
104607: EMPTY
104608: LIST
104609: LIST
104610: PUSH
104611: LD_INT 58
104613: PUSH
104614: EMPTY
104615: LIST
104616: PUSH
104617: EMPTY
104618: LIST
104619: LIST
104620: PPUSH
104621: CALL_OW 72
104625: IN
104626: AND
104627: IFFALSE 104663
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
104629: LD_VAR 0 4
104633: PUSH
104634: LD_VAR 0 7
104638: ARRAY
104639: PPUSH
104640: LD_VAR 0 14
104644: PUSH
104645: LD_INT 1
104647: ARRAY
104648: PPUSH
104649: CALL_OW 120
// attacking := true ;
104653: LD_ADDR_VAR 0 29
104657: PUSH
104658: LD_INT 1
104660: ST_TO_ADDR
// continue ;
104661: GO 102836
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
104663: LD_VAR 0 26
104667: PUSH
104668: LD_VAR 0 4
104672: PUSH
104673: LD_VAR 0 7
104677: ARRAY
104678: PPUSH
104679: CALL_OW 257
104683: PUSH
104684: LD_INT 1
104686: EQUAL
104687: AND
104688: PUSH
104689: LD_VAR 0 4
104693: PUSH
104694: LD_VAR 0 7
104698: ARRAY
104699: PPUSH
104700: CALL_OW 256
104704: PUSH
104705: LD_INT 800
104707: LESS
104708: AND
104709: PUSH
104710: LD_VAR 0 4
104714: PUSH
104715: LD_VAR 0 7
104719: ARRAY
104720: PPUSH
104721: CALL_OW 318
104725: NOT
104726: AND
104727: IFFALSE 104744
// ComCrawl ( group [ i ] ) ;
104729: LD_VAR 0 4
104733: PUSH
104734: LD_VAR 0 7
104738: ARRAY
104739: PPUSH
104740: CALL_OW 137
// if f_mines then
104744: LD_VAR 0 21
104748: IFFALSE 104991
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
104750: LD_VAR 0 14
104754: PUSH
104755: LD_INT 1
104757: ARRAY
104758: PPUSH
104759: CALL_OW 247
104763: PUSH
104764: LD_INT 3
104766: EQUAL
104767: PUSH
104768: LD_VAR 0 14
104772: PUSH
104773: LD_INT 1
104775: ARRAY
104776: PUSH
104777: LD_VAR 0 27
104781: IN
104782: NOT
104783: AND
104784: IFFALSE 104991
// begin x := GetX ( tmp [ 1 ] ) ;
104786: LD_ADDR_VAR 0 10
104790: PUSH
104791: LD_VAR 0 14
104795: PUSH
104796: LD_INT 1
104798: ARRAY
104799: PPUSH
104800: CALL_OW 250
104804: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
104805: LD_ADDR_VAR 0 11
104809: PUSH
104810: LD_VAR 0 14
104814: PUSH
104815: LD_INT 1
104817: ARRAY
104818: PPUSH
104819: CALL_OW 251
104823: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
104824: LD_ADDR_VAR 0 12
104828: PUSH
104829: LD_VAR 0 4
104833: PUSH
104834: LD_VAR 0 7
104838: ARRAY
104839: PPUSH
104840: CALL 46173 0 1
104844: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
104845: LD_VAR 0 4
104849: PUSH
104850: LD_VAR 0 7
104854: ARRAY
104855: PPUSH
104856: LD_VAR 0 10
104860: PPUSH
104861: LD_VAR 0 11
104865: PPUSH
104866: LD_VAR 0 14
104870: PUSH
104871: LD_INT 1
104873: ARRAY
104874: PPUSH
104875: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
104879: LD_VAR 0 4
104883: PUSH
104884: LD_VAR 0 7
104888: ARRAY
104889: PPUSH
104890: LD_VAR 0 10
104894: PPUSH
104895: LD_VAR 0 12
104899: PPUSH
104900: LD_INT 7
104902: PPUSH
104903: CALL_OW 272
104907: PPUSH
104908: LD_VAR 0 11
104912: PPUSH
104913: LD_VAR 0 12
104917: PPUSH
104918: LD_INT 7
104920: PPUSH
104921: CALL_OW 273
104925: PPUSH
104926: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
104930: LD_VAR 0 4
104934: PUSH
104935: LD_VAR 0 7
104939: ARRAY
104940: PPUSH
104941: LD_INT 71
104943: PPUSH
104944: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
104948: LD_ADDR_VAR 0 27
104952: PUSH
104953: LD_VAR 0 27
104957: PPUSH
104958: LD_VAR 0 27
104962: PUSH
104963: LD_INT 1
104965: PLUS
104966: PPUSH
104967: LD_VAR 0 14
104971: PUSH
104972: LD_INT 1
104974: ARRAY
104975: PPUSH
104976: CALL_OW 1
104980: ST_TO_ADDR
// attacking := true ;
104981: LD_ADDR_VAR 0 29
104985: PUSH
104986: LD_INT 1
104988: ST_TO_ADDR
// continue ;
104989: GO 102836
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
104991: LD_VAR 0 4
104995: PUSH
104996: LD_VAR 0 7
105000: ARRAY
105001: PPUSH
105002: CALL_OW 257
105006: PUSH
105007: LD_INT 17
105009: EQUAL
105010: PUSH
105011: LD_VAR 0 4
105015: PUSH
105016: LD_VAR 0 7
105020: ARRAY
105021: PPUSH
105022: CALL_OW 110
105026: PUSH
105027: LD_INT 71
105029: EQUAL
105030: NOT
105031: AND
105032: IFFALSE 105178
// begin attacking := false ;
105034: LD_ADDR_VAR 0 29
105038: PUSH
105039: LD_INT 0
105041: ST_TO_ADDR
// k := 5 ;
105042: LD_ADDR_VAR 0 9
105046: PUSH
105047: LD_INT 5
105049: ST_TO_ADDR
// if tmp < k then
105050: LD_VAR 0 14
105054: PUSH
105055: LD_VAR 0 9
105059: LESS
105060: IFFALSE 105072
// k := tmp ;
105062: LD_ADDR_VAR 0 9
105066: PUSH
105067: LD_VAR 0 14
105071: ST_TO_ADDR
// for j = 1 to k do
105072: LD_ADDR_VAR 0 8
105076: PUSH
105077: DOUBLE
105078: LD_INT 1
105080: DEC
105081: ST_TO_ADDR
105082: LD_VAR 0 9
105086: PUSH
105087: FOR_TO
105088: IFFALSE 105176
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
105090: LD_VAR 0 14
105094: PUSH
105095: LD_VAR 0 8
105099: ARRAY
105100: PUSH
105101: LD_VAR 0 14
105105: PPUSH
105106: LD_INT 58
105108: PUSH
105109: EMPTY
105110: LIST
105111: PPUSH
105112: CALL_OW 72
105116: IN
105117: NOT
105118: IFFALSE 105174
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105120: LD_VAR 0 4
105124: PUSH
105125: LD_VAR 0 7
105129: ARRAY
105130: PPUSH
105131: LD_VAR 0 14
105135: PUSH
105136: LD_VAR 0 8
105140: ARRAY
105141: PPUSH
105142: CALL_OW 115
// attacking := true ;
105146: LD_ADDR_VAR 0 29
105150: PUSH
105151: LD_INT 1
105153: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
105154: LD_VAR 0 4
105158: PUSH
105159: LD_VAR 0 7
105163: ARRAY
105164: PPUSH
105165: LD_INT 71
105167: PPUSH
105168: CALL_OW 109
// continue ;
105172: GO 105087
// end ; end ;
105174: GO 105087
105176: POP
105177: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
105178: LD_VAR 0 4
105182: PUSH
105183: LD_VAR 0 7
105187: ARRAY
105188: PPUSH
105189: CALL_OW 257
105193: PUSH
105194: LD_INT 8
105196: EQUAL
105197: PUSH
105198: LD_VAR 0 4
105202: PUSH
105203: LD_VAR 0 7
105207: ARRAY
105208: PPUSH
105209: CALL_OW 264
105213: PUSH
105214: LD_INT 28
105216: PUSH
105217: LD_INT 45
105219: PUSH
105220: LD_INT 7
105222: PUSH
105223: LD_INT 47
105225: PUSH
105226: EMPTY
105227: LIST
105228: LIST
105229: LIST
105230: LIST
105231: IN
105232: OR
105233: IFFALSE 105489
// begin attacking := false ;
105235: LD_ADDR_VAR 0 29
105239: PUSH
105240: LD_INT 0
105242: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
105243: LD_VAR 0 14
105247: PUSH
105248: LD_INT 1
105250: ARRAY
105251: PPUSH
105252: CALL_OW 266
105256: PUSH
105257: LD_INT 32
105259: PUSH
105260: LD_INT 31
105262: PUSH
105263: LD_INT 33
105265: PUSH
105266: LD_INT 4
105268: PUSH
105269: LD_INT 5
105271: PUSH
105272: EMPTY
105273: LIST
105274: LIST
105275: LIST
105276: LIST
105277: LIST
105278: IN
105279: IFFALSE 105465
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
105281: LD_ADDR_VAR 0 9
105285: PUSH
105286: LD_VAR 0 14
105290: PUSH
105291: LD_INT 1
105293: ARRAY
105294: PPUSH
105295: CALL_OW 266
105299: PPUSH
105300: LD_VAR 0 14
105304: PUSH
105305: LD_INT 1
105307: ARRAY
105308: PPUSH
105309: CALL_OW 250
105313: PPUSH
105314: LD_VAR 0 14
105318: PUSH
105319: LD_INT 1
105321: ARRAY
105322: PPUSH
105323: CALL_OW 251
105327: PPUSH
105328: LD_VAR 0 14
105332: PUSH
105333: LD_INT 1
105335: ARRAY
105336: PPUSH
105337: CALL_OW 254
105341: PPUSH
105342: LD_VAR 0 14
105346: PUSH
105347: LD_INT 1
105349: ARRAY
105350: PPUSH
105351: CALL_OW 248
105355: PPUSH
105356: LD_INT 0
105358: PPUSH
105359: CALL 27543 0 6
105363: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
105364: LD_ADDR_VAR 0 8
105368: PUSH
105369: LD_VAR 0 4
105373: PUSH
105374: LD_VAR 0 7
105378: ARRAY
105379: PPUSH
105380: LD_VAR 0 9
105384: PPUSH
105385: CALL 46213 0 2
105389: ST_TO_ADDR
// if j then
105390: LD_VAR 0 8
105394: IFFALSE 105463
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
105396: LD_VAR 0 8
105400: PUSH
105401: LD_INT 1
105403: ARRAY
105404: PPUSH
105405: LD_VAR 0 8
105409: PUSH
105410: LD_INT 2
105412: ARRAY
105413: PPUSH
105414: CALL_OW 488
105418: IFFALSE 105463
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
105420: LD_VAR 0 4
105424: PUSH
105425: LD_VAR 0 7
105429: ARRAY
105430: PPUSH
105431: LD_VAR 0 8
105435: PUSH
105436: LD_INT 1
105438: ARRAY
105439: PPUSH
105440: LD_VAR 0 8
105444: PUSH
105445: LD_INT 2
105447: ARRAY
105448: PPUSH
105449: CALL_OW 116
// attacking := true ;
105453: LD_ADDR_VAR 0 29
105457: PUSH
105458: LD_INT 1
105460: ST_TO_ADDR
// continue ;
105461: GO 102836
// end ; end else
105463: GO 105489
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105465: LD_VAR 0 4
105469: PUSH
105470: LD_VAR 0 7
105474: ARRAY
105475: PPUSH
105476: LD_VAR 0 14
105480: PUSH
105481: LD_INT 1
105483: ARRAY
105484: PPUSH
105485: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
105489: LD_VAR 0 4
105493: PUSH
105494: LD_VAR 0 7
105498: ARRAY
105499: PPUSH
105500: CALL_OW 265
105504: PUSH
105505: LD_INT 11
105507: EQUAL
105508: IFFALSE 105786
// begin k := 10 ;
105510: LD_ADDR_VAR 0 9
105514: PUSH
105515: LD_INT 10
105517: ST_TO_ADDR
// x := 0 ;
105518: LD_ADDR_VAR 0 10
105522: PUSH
105523: LD_INT 0
105525: ST_TO_ADDR
// if tmp < k then
105526: LD_VAR 0 14
105530: PUSH
105531: LD_VAR 0 9
105535: LESS
105536: IFFALSE 105548
// k := tmp ;
105538: LD_ADDR_VAR 0 9
105542: PUSH
105543: LD_VAR 0 14
105547: ST_TO_ADDR
// for j = k downto 1 do
105548: LD_ADDR_VAR 0 8
105552: PUSH
105553: DOUBLE
105554: LD_VAR 0 9
105558: INC
105559: ST_TO_ADDR
105560: LD_INT 1
105562: PUSH
105563: FOR_DOWNTO
105564: IFFALSE 105639
// begin if GetType ( tmp [ j ] ) = unit_human then
105566: LD_VAR 0 14
105570: PUSH
105571: LD_VAR 0 8
105575: ARRAY
105576: PPUSH
105577: CALL_OW 247
105581: PUSH
105582: LD_INT 1
105584: EQUAL
105585: IFFALSE 105637
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
105587: LD_VAR 0 4
105591: PUSH
105592: LD_VAR 0 7
105596: ARRAY
105597: PPUSH
105598: LD_VAR 0 14
105602: PUSH
105603: LD_VAR 0 8
105607: ARRAY
105608: PPUSH
105609: CALL 46484 0 2
// x := tmp [ j ] ;
105613: LD_ADDR_VAR 0 10
105617: PUSH
105618: LD_VAR 0 14
105622: PUSH
105623: LD_VAR 0 8
105627: ARRAY
105628: ST_TO_ADDR
// attacking := true ;
105629: LD_ADDR_VAR 0 29
105633: PUSH
105634: LD_INT 1
105636: ST_TO_ADDR
// end ; end ;
105637: GO 105563
105639: POP
105640: POP
// if not x then
105641: LD_VAR 0 10
105645: NOT
105646: IFFALSE 105786
// begin attacking := true ;
105648: LD_ADDR_VAR 0 29
105652: PUSH
105653: LD_INT 1
105655: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
105656: LD_VAR 0 4
105660: PUSH
105661: LD_VAR 0 7
105665: ARRAY
105666: PPUSH
105667: CALL_OW 250
105671: PPUSH
105672: LD_VAR 0 4
105676: PUSH
105677: LD_VAR 0 7
105681: ARRAY
105682: PPUSH
105683: CALL_OW 251
105687: PPUSH
105688: CALL_OW 546
105692: PUSH
105693: LD_INT 2
105695: ARRAY
105696: PUSH
105697: LD_VAR 0 14
105701: PUSH
105702: LD_INT 1
105704: ARRAY
105705: PPUSH
105706: CALL_OW 250
105710: PPUSH
105711: LD_VAR 0 14
105715: PUSH
105716: LD_INT 1
105718: ARRAY
105719: PPUSH
105720: CALL_OW 251
105724: PPUSH
105725: CALL_OW 546
105729: PUSH
105730: LD_INT 2
105732: ARRAY
105733: EQUAL
105734: IFFALSE 105762
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
105736: LD_VAR 0 4
105740: PUSH
105741: LD_VAR 0 7
105745: ARRAY
105746: PPUSH
105747: LD_VAR 0 14
105751: PUSH
105752: LD_INT 1
105754: ARRAY
105755: PPUSH
105756: CALL 46484 0 2
105760: GO 105786
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105762: LD_VAR 0 4
105766: PUSH
105767: LD_VAR 0 7
105771: ARRAY
105772: PPUSH
105773: LD_VAR 0 14
105777: PUSH
105778: LD_INT 1
105780: ARRAY
105781: PPUSH
105782: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
105786: LD_VAR 0 4
105790: PUSH
105791: LD_VAR 0 7
105795: ARRAY
105796: PPUSH
105797: CALL_OW 264
105801: PUSH
105802: LD_INT 29
105804: EQUAL
105805: IFFALSE 106171
// begin if WantsToAttack ( group [ i ] ) in bombed then
105807: LD_VAR 0 4
105811: PUSH
105812: LD_VAR 0 7
105816: ARRAY
105817: PPUSH
105818: CALL_OW 319
105822: PUSH
105823: LD_VAR 0 28
105827: IN
105828: IFFALSE 105832
// continue ;
105830: GO 102836
// k := 8 ;
105832: LD_ADDR_VAR 0 9
105836: PUSH
105837: LD_INT 8
105839: ST_TO_ADDR
// x := 0 ;
105840: LD_ADDR_VAR 0 10
105844: PUSH
105845: LD_INT 0
105847: ST_TO_ADDR
// if tmp < k then
105848: LD_VAR 0 14
105852: PUSH
105853: LD_VAR 0 9
105857: LESS
105858: IFFALSE 105870
// k := tmp ;
105860: LD_ADDR_VAR 0 9
105864: PUSH
105865: LD_VAR 0 14
105869: ST_TO_ADDR
// for j = 1 to k do
105870: LD_ADDR_VAR 0 8
105874: PUSH
105875: DOUBLE
105876: LD_INT 1
105878: DEC
105879: ST_TO_ADDR
105880: LD_VAR 0 9
105884: PUSH
105885: FOR_TO
105886: IFFALSE 106018
// begin if GetType ( tmp [ j ] ) = unit_building then
105888: LD_VAR 0 14
105892: PUSH
105893: LD_VAR 0 8
105897: ARRAY
105898: PPUSH
105899: CALL_OW 247
105903: PUSH
105904: LD_INT 3
105906: EQUAL
105907: IFFALSE 106016
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
105909: LD_VAR 0 14
105913: PUSH
105914: LD_VAR 0 8
105918: ARRAY
105919: PUSH
105920: LD_VAR 0 28
105924: IN
105925: NOT
105926: PUSH
105927: LD_VAR 0 14
105931: PUSH
105932: LD_VAR 0 8
105936: ARRAY
105937: PPUSH
105938: CALL_OW 313
105942: AND
105943: IFFALSE 106016
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105945: LD_VAR 0 4
105949: PUSH
105950: LD_VAR 0 7
105954: ARRAY
105955: PPUSH
105956: LD_VAR 0 14
105960: PUSH
105961: LD_VAR 0 8
105965: ARRAY
105966: PPUSH
105967: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
105971: LD_ADDR_VAR 0 28
105975: PUSH
105976: LD_VAR 0 28
105980: PPUSH
105981: LD_VAR 0 28
105985: PUSH
105986: LD_INT 1
105988: PLUS
105989: PPUSH
105990: LD_VAR 0 14
105994: PUSH
105995: LD_VAR 0 8
105999: ARRAY
106000: PPUSH
106001: CALL_OW 1
106005: ST_TO_ADDR
// attacking := true ;
106006: LD_ADDR_VAR 0 29
106010: PUSH
106011: LD_INT 1
106013: ST_TO_ADDR
// break ;
106014: GO 106018
// end ; end ;
106016: GO 105885
106018: POP
106019: POP
// if not attacking and f_attack_depot then
106020: LD_VAR 0 29
106024: NOT
106025: PUSH
106026: LD_VAR 0 25
106030: AND
106031: IFFALSE 106126
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
106033: LD_ADDR_VAR 0 13
106037: PUSH
106038: LD_VAR 0 14
106042: PPUSH
106043: LD_INT 2
106045: PUSH
106046: LD_INT 30
106048: PUSH
106049: LD_INT 0
106051: PUSH
106052: EMPTY
106053: LIST
106054: LIST
106055: PUSH
106056: LD_INT 30
106058: PUSH
106059: LD_INT 1
106061: PUSH
106062: EMPTY
106063: LIST
106064: LIST
106065: PUSH
106066: EMPTY
106067: LIST
106068: LIST
106069: LIST
106070: PPUSH
106071: CALL_OW 72
106075: ST_TO_ADDR
// if z then
106076: LD_VAR 0 13
106080: IFFALSE 106126
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
106082: LD_VAR 0 4
106086: PUSH
106087: LD_VAR 0 7
106091: ARRAY
106092: PPUSH
106093: LD_VAR 0 13
106097: PPUSH
106098: LD_VAR 0 4
106102: PUSH
106103: LD_VAR 0 7
106107: ARRAY
106108: PPUSH
106109: CALL_OW 74
106113: PPUSH
106114: CALL_OW 115
// attacking := true ;
106118: LD_ADDR_VAR 0 29
106122: PUSH
106123: LD_INT 1
106125: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
106126: LD_VAR 0 4
106130: PUSH
106131: LD_VAR 0 7
106135: ARRAY
106136: PPUSH
106137: CALL_OW 256
106141: PUSH
106142: LD_INT 500
106144: LESS
106145: IFFALSE 106171
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106147: LD_VAR 0 4
106151: PUSH
106152: LD_VAR 0 7
106156: ARRAY
106157: PPUSH
106158: LD_VAR 0 14
106162: PUSH
106163: LD_INT 1
106165: ARRAY
106166: PPUSH
106167: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
106171: LD_VAR 0 4
106175: PUSH
106176: LD_VAR 0 7
106180: ARRAY
106181: PPUSH
106182: CALL_OW 264
106186: PUSH
106187: LD_INT 49
106189: EQUAL
106190: IFFALSE 106311
// begin if not HasTask ( group [ i ] ) then
106192: LD_VAR 0 4
106196: PUSH
106197: LD_VAR 0 7
106201: ARRAY
106202: PPUSH
106203: CALL_OW 314
106207: NOT
106208: IFFALSE 106311
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
106210: LD_ADDR_VAR 0 9
106214: PUSH
106215: LD_INT 81
106217: PUSH
106218: LD_VAR 0 4
106222: PUSH
106223: LD_VAR 0 7
106227: ARRAY
106228: PPUSH
106229: CALL_OW 255
106233: PUSH
106234: EMPTY
106235: LIST
106236: LIST
106237: PPUSH
106238: CALL_OW 69
106242: PPUSH
106243: LD_VAR 0 4
106247: PUSH
106248: LD_VAR 0 7
106252: ARRAY
106253: PPUSH
106254: CALL_OW 74
106258: ST_TO_ADDR
// if k then
106259: LD_VAR 0 9
106263: IFFALSE 106311
// if GetDistUnits ( group [ i ] , k ) > 10 then
106265: LD_VAR 0 4
106269: PUSH
106270: LD_VAR 0 7
106274: ARRAY
106275: PPUSH
106276: LD_VAR 0 9
106280: PPUSH
106281: CALL_OW 296
106285: PUSH
106286: LD_INT 10
106288: GREATER
106289: IFFALSE 106311
// ComMoveUnit ( group [ i ] , k ) ;
106291: LD_VAR 0 4
106295: PUSH
106296: LD_VAR 0 7
106300: ARRAY
106301: PPUSH
106302: LD_VAR 0 9
106306: PPUSH
106307: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
106311: LD_VAR 0 4
106315: PUSH
106316: LD_VAR 0 7
106320: ARRAY
106321: PPUSH
106322: CALL_OW 256
106326: PUSH
106327: LD_INT 250
106329: LESS
106330: PUSH
106331: LD_VAR 0 4
106335: PUSH
106336: LD_VAR 0 7
106340: ARRAY
106341: PUSH
106342: LD_INT 21
106344: PUSH
106345: LD_INT 2
106347: PUSH
106348: EMPTY
106349: LIST
106350: LIST
106351: PUSH
106352: LD_INT 23
106354: PUSH
106355: LD_INT 2
106357: PUSH
106358: EMPTY
106359: LIST
106360: LIST
106361: PUSH
106362: EMPTY
106363: LIST
106364: LIST
106365: PPUSH
106366: CALL_OW 69
106370: IN
106371: AND
106372: IFFALSE 106497
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
106374: LD_ADDR_VAR 0 9
106378: PUSH
106379: LD_OWVAR 3
106383: PUSH
106384: LD_VAR 0 4
106388: PUSH
106389: LD_VAR 0 7
106393: ARRAY
106394: DIFF
106395: PPUSH
106396: LD_VAR 0 4
106400: PUSH
106401: LD_VAR 0 7
106405: ARRAY
106406: PPUSH
106407: CALL_OW 74
106411: ST_TO_ADDR
// if not k then
106412: LD_VAR 0 9
106416: NOT
106417: IFFALSE 106421
// continue ;
106419: GO 102836
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
106421: LD_VAR 0 9
106425: PUSH
106426: LD_INT 81
106428: PUSH
106429: LD_VAR 0 4
106433: PUSH
106434: LD_VAR 0 7
106438: ARRAY
106439: PPUSH
106440: CALL_OW 255
106444: PUSH
106445: EMPTY
106446: LIST
106447: LIST
106448: PPUSH
106449: CALL_OW 69
106453: IN
106454: PUSH
106455: LD_VAR 0 9
106459: PPUSH
106460: LD_VAR 0 4
106464: PUSH
106465: LD_VAR 0 7
106469: ARRAY
106470: PPUSH
106471: CALL_OW 296
106475: PUSH
106476: LD_INT 5
106478: LESS
106479: AND
106480: IFFALSE 106497
// ComAutodestruct ( group [ i ] ) ;
106482: LD_VAR 0 4
106486: PUSH
106487: LD_VAR 0 7
106491: ARRAY
106492: PPUSH
106493: CALL 46382 0 1
// end ; if f_attack_depot then
106497: LD_VAR 0 25
106501: IFFALSE 106613
// begin k := 6 ;
106503: LD_ADDR_VAR 0 9
106507: PUSH
106508: LD_INT 6
106510: ST_TO_ADDR
// if tmp < k then
106511: LD_VAR 0 14
106515: PUSH
106516: LD_VAR 0 9
106520: LESS
106521: IFFALSE 106533
// k := tmp ;
106523: LD_ADDR_VAR 0 9
106527: PUSH
106528: LD_VAR 0 14
106532: ST_TO_ADDR
// for j = 1 to k do
106533: LD_ADDR_VAR 0 8
106537: PUSH
106538: DOUBLE
106539: LD_INT 1
106541: DEC
106542: ST_TO_ADDR
106543: LD_VAR 0 9
106547: PUSH
106548: FOR_TO
106549: IFFALSE 106611
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
106551: LD_VAR 0 8
106555: PPUSH
106556: CALL_OW 266
106560: PUSH
106561: LD_INT 0
106563: PUSH
106564: LD_INT 1
106566: PUSH
106567: EMPTY
106568: LIST
106569: LIST
106570: IN
106571: IFFALSE 106609
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
106573: LD_VAR 0 4
106577: PUSH
106578: LD_VAR 0 7
106582: ARRAY
106583: PPUSH
106584: LD_VAR 0 14
106588: PUSH
106589: LD_VAR 0 8
106593: ARRAY
106594: PPUSH
106595: CALL_OW 115
// attacking := true ;
106599: LD_ADDR_VAR 0 29
106603: PUSH
106604: LD_INT 1
106606: ST_TO_ADDR
// break ;
106607: GO 106611
// end ;
106609: GO 106548
106611: POP
106612: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
106613: LD_VAR 0 4
106617: PUSH
106618: LD_VAR 0 7
106622: ARRAY
106623: PPUSH
106624: CALL_OW 302
106628: PUSH
106629: LD_VAR 0 29
106633: NOT
106634: AND
106635: IFFALSE 106957
// begin if GetTag ( group [ i ] ) = 71 then
106637: LD_VAR 0 4
106641: PUSH
106642: LD_VAR 0 7
106646: ARRAY
106647: PPUSH
106648: CALL_OW 110
106652: PUSH
106653: LD_INT 71
106655: EQUAL
106656: IFFALSE 106697
// begin if HasTask ( group [ i ] ) then
106658: LD_VAR 0 4
106662: PUSH
106663: LD_VAR 0 7
106667: ARRAY
106668: PPUSH
106669: CALL_OW 314
106673: IFFALSE 106679
// continue else
106675: GO 102836
106677: GO 106697
// SetTag ( group [ i ] , 0 ) ;
106679: LD_VAR 0 4
106683: PUSH
106684: LD_VAR 0 7
106688: ARRAY
106689: PPUSH
106690: LD_INT 0
106692: PPUSH
106693: CALL_OW 109
// end ; k := 8 ;
106697: LD_ADDR_VAR 0 9
106701: PUSH
106702: LD_INT 8
106704: ST_TO_ADDR
// x := 0 ;
106705: LD_ADDR_VAR 0 10
106709: PUSH
106710: LD_INT 0
106712: ST_TO_ADDR
// if tmp < k then
106713: LD_VAR 0 14
106717: PUSH
106718: LD_VAR 0 9
106722: LESS
106723: IFFALSE 106735
// k := tmp ;
106725: LD_ADDR_VAR 0 9
106729: PUSH
106730: LD_VAR 0 14
106734: ST_TO_ADDR
// for j = 1 to k do
106735: LD_ADDR_VAR 0 8
106739: PUSH
106740: DOUBLE
106741: LD_INT 1
106743: DEC
106744: ST_TO_ADDR
106745: LD_VAR 0 9
106749: PUSH
106750: FOR_TO
106751: IFFALSE 106849
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
106753: LD_VAR 0 14
106757: PUSH
106758: LD_VAR 0 8
106762: ARRAY
106763: PPUSH
106764: CALL_OW 247
106768: PUSH
106769: LD_INT 1
106771: EQUAL
106772: PUSH
106773: LD_VAR 0 14
106777: PUSH
106778: LD_VAR 0 8
106782: ARRAY
106783: PPUSH
106784: CALL_OW 256
106788: PUSH
106789: LD_INT 250
106791: LESS
106792: PUSH
106793: LD_VAR 0 20
106797: AND
106798: PUSH
106799: LD_VAR 0 20
106803: NOT
106804: PUSH
106805: LD_VAR 0 14
106809: PUSH
106810: LD_VAR 0 8
106814: ARRAY
106815: PPUSH
106816: CALL_OW 256
106820: PUSH
106821: LD_INT 250
106823: GREATEREQUAL
106824: AND
106825: OR
106826: AND
106827: IFFALSE 106847
// begin x := tmp [ j ] ;
106829: LD_ADDR_VAR 0 10
106833: PUSH
106834: LD_VAR 0 14
106838: PUSH
106839: LD_VAR 0 8
106843: ARRAY
106844: ST_TO_ADDR
// break ;
106845: GO 106849
// end ;
106847: GO 106750
106849: POP
106850: POP
// if x then
106851: LD_VAR 0 10
106855: IFFALSE 106879
// ComAttackUnit ( group [ i ] , x ) else
106857: LD_VAR 0 4
106861: PUSH
106862: LD_VAR 0 7
106866: ARRAY
106867: PPUSH
106868: LD_VAR 0 10
106872: PPUSH
106873: CALL_OW 115
106877: GO 106903
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106879: LD_VAR 0 4
106883: PUSH
106884: LD_VAR 0 7
106888: ARRAY
106889: PPUSH
106890: LD_VAR 0 14
106894: PUSH
106895: LD_INT 1
106897: ARRAY
106898: PPUSH
106899: CALL_OW 115
// if not HasTask ( group [ i ] ) then
106903: LD_VAR 0 4
106907: PUSH
106908: LD_VAR 0 7
106912: ARRAY
106913: PPUSH
106914: CALL_OW 314
106918: NOT
106919: IFFALSE 106957
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
106921: LD_VAR 0 4
106925: PUSH
106926: LD_VAR 0 7
106930: ARRAY
106931: PPUSH
106932: LD_VAR 0 14
106936: PPUSH
106937: LD_VAR 0 4
106941: PUSH
106942: LD_VAR 0 7
106946: ARRAY
106947: PPUSH
106948: CALL_OW 74
106952: PPUSH
106953: CALL_OW 115
// end ; end ; end ;
106957: GO 102836
106959: POP
106960: POP
// wait ( 0 0$2 ) ;
106961: LD_INT 70
106963: PPUSH
106964: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
106968: LD_VAR 0 4
106972: NOT
106973: PUSH
106974: LD_VAR 0 4
106978: PUSH
106979: EMPTY
106980: EQUAL
106981: OR
106982: PUSH
106983: LD_INT 81
106985: PUSH
106986: LD_VAR 0 35
106990: PUSH
106991: EMPTY
106992: LIST
106993: LIST
106994: PPUSH
106995: CALL_OW 69
106999: NOT
107000: OR
107001: IFFALSE 102821
// end ;
107003: LD_VAR 0 2
107007: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
107008: LD_INT 0
107010: PPUSH
107011: PPUSH
107012: PPUSH
107013: PPUSH
107014: PPUSH
107015: PPUSH
// if not base or not mc_bases [ base ] or not solds then
107016: LD_VAR 0 1
107020: NOT
107021: PUSH
107022: LD_EXP 69
107026: PUSH
107027: LD_VAR 0 1
107031: ARRAY
107032: NOT
107033: OR
107034: PUSH
107035: LD_VAR 0 2
107039: NOT
107040: OR
107041: IFFALSE 107045
// exit ;
107043: GO 107599
// side := mc_sides [ base ] ;
107045: LD_ADDR_VAR 0 6
107049: PUSH
107050: LD_EXP 95
107054: PUSH
107055: LD_VAR 0 1
107059: ARRAY
107060: ST_TO_ADDR
// if not side then
107061: LD_VAR 0 6
107065: NOT
107066: IFFALSE 107070
// exit ;
107068: GO 107599
// for i in solds do
107070: LD_ADDR_VAR 0 7
107074: PUSH
107075: LD_VAR 0 2
107079: PUSH
107080: FOR_IN
107081: IFFALSE 107142
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
107083: LD_VAR 0 7
107087: PPUSH
107088: CALL_OW 310
107092: PPUSH
107093: CALL_OW 266
107097: PUSH
107098: LD_INT 32
107100: PUSH
107101: LD_INT 31
107103: PUSH
107104: EMPTY
107105: LIST
107106: LIST
107107: IN
107108: IFFALSE 107128
// solds := solds diff i else
107110: LD_ADDR_VAR 0 2
107114: PUSH
107115: LD_VAR 0 2
107119: PUSH
107120: LD_VAR 0 7
107124: DIFF
107125: ST_TO_ADDR
107126: GO 107140
// SetTag ( i , 18 ) ;
107128: LD_VAR 0 7
107132: PPUSH
107133: LD_INT 18
107135: PPUSH
107136: CALL_OW 109
107140: GO 107080
107142: POP
107143: POP
// if not solds then
107144: LD_VAR 0 2
107148: NOT
107149: IFFALSE 107153
// exit ;
107151: GO 107599
// repeat wait ( 0 0$2 ) ;
107153: LD_INT 70
107155: PPUSH
107156: CALL_OW 67
// enemy := mc_scan [ base ] ;
107160: LD_ADDR_VAR 0 4
107164: PUSH
107165: LD_EXP 92
107169: PUSH
107170: LD_VAR 0 1
107174: ARRAY
107175: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107176: LD_EXP 69
107180: PUSH
107181: LD_VAR 0 1
107185: ARRAY
107186: NOT
107187: PUSH
107188: LD_EXP 69
107192: PUSH
107193: LD_VAR 0 1
107197: ARRAY
107198: PUSH
107199: EMPTY
107200: EQUAL
107201: OR
107202: IFFALSE 107239
// begin for i in solds do
107204: LD_ADDR_VAR 0 7
107208: PUSH
107209: LD_VAR 0 2
107213: PUSH
107214: FOR_IN
107215: IFFALSE 107228
// ComStop ( i ) ;
107217: LD_VAR 0 7
107221: PPUSH
107222: CALL_OW 141
107226: GO 107214
107228: POP
107229: POP
// solds := [ ] ;
107230: LD_ADDR_VAR 0 2
107234: PUSH
107235: EMPTY
107236: ST_TO_ADDR
// exit ;
107237: GO 107599
// end ; for i in solds do
107239: LD_ADDR_VAR 0 7
107243: PUSH
107244: LD_VAR 0 2
107248: PUSH
107249: FOR_IN
107250: IFFALSE 107571
// begin if IsInUnit ( i ) then
107252: LD_VAR 0 7
107256: PPUSH
107257: CALL_OW 310
107261: IFFALSE 107272
// ComExitBuilding ( i ) ;
107263: LD_VAR 0 7
107267: PPUSH
107268: CALL_OW 122
// if GetLives ( i ) > 500 then
107272: LD_VAR 0 7
107276: PPUSH
107277: CALL_OW 256
107281: PUSH
107282: LD_INT 500
107284: GREATER
107285: IFFALSE 107338
// begin e := NearestUnitToUnit ( enemy , i ) ;
107287: LD_ADDR_VAR 0 5
107291: PUSH
107292: LD_VAR 0 4
107296: PPUSH
107297: LD_VAR 0 7
107301: PPUSH
107302: CALL_OW 74
107306: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
107307: LD_VAR 0 7
107311: PPUSH
107312: LD_VAR 0 5
107316: PPUSH
107317: CALL_OW 250
107321: PPUSH
107322: LD_VAR 0 5
107326: PPUSH
107327: CALL_OW 251
107331: PPUSH
107332: CALL_OW 114
// end else
107336: GO 107569
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
107338: LD_VAR 0 7
107342: PPUSH
107343: LD_EXP 69
107347: PUSH
107348: LD_VAR 0 1
107352: ARRAY
107353: PPUSH
107354: LD_INT 2
107356: PUSH
107357: LD_INT 30
107359: PUSH
107360: LD_INT 0
107362: PUSH
107363: EMPTY
107364: LIST
107365: LIST
107366: PUSH
107367: LD_INT 30
107369: PUSH
107370: LD_INT 1
107372: PUSH
107373: EMPTY
107374: LIST
107375: LIST
107376: PUSH
107377: LD_INT 30
107379: PUSH
107380: LD_INT 6
107382: PUSH
107383: EMPTY
107384: LIST
107385: LIST
107386: PUSH
107387: EMPTY
107388: LIST
107389: LIST
107390: LIST
107391: LIST
107392: PPUSH
107393: CALL_OW 72
107397: PPUSH
107398: LD_VAR 0 7
107402: PPUSH
107403: CALL_OW 74
107407: PPUSH
107408: CALL_OW 296
107412: PUSH
107413: LD_INT 10
107415: GREATER
107416: IFFALSE 107569
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
107418: LD_ADDR_VAR 0 8
107422: PUSH
107423: LD_EXP 69
107427: PUSH
107428: LD_VAR 0 1
107432: ARRAY
107433: PPUSH
107434: LD_INT 2
107436: PUSH
107437: LD_INT 30
107439: PUSH
107440: LD_INT 0
107442: PUSH
107443: EMPTY
107444: LIST
107445: LIST
107446: PUSH
107447: LD_INT 30
107449: PUSH
107450: LD_INT 1
107452: PUSH
107453: EMPTY
107454: LIST
107455: LIST
107456: PUSH
107457: LD_INT 30
107459: PUSH
107460: LD_INT 6
107462: PUSH
107463: EMPTY
107464: LIST
107465: LIST
107466: PUSH
107467: EMPTY
107468: LIST
107469: LIST
107470: LIST
107471: LIST
107472: PPUSH
107473: CALL_OW 72
107477: PPUSH
107478: LD_VAR 0 7
107482: PPUSH
107483: CALL_OW 74
107487: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
107488: LD_VAR 0 7
107492: PPUSH
107493: LD_VAR 0 8
107497: PPUSH
107498: CALL_OW 250
107502: PPUSH
107503: LD_INT 3
107505: PPUSH
107506: LD_INT 5
107508: PPUSH
107509: CALL_OW 272
107513: PPUSH
107514: LD_VAR 0 8
107518: PPUSH
107519: CALL_OW 251
107523: PPUSH
107524: LD_INT 3
107526: PPUSH
107527: LD_INT 5
107529: PPUSH
107530: CALL_OW 273
107534: PPUSH
107535: CALL_OW 111
// SetTag ( i , 0 ) ;
107539: LD_VAR 0 7
107543: PPUSH
107544: LD_INT 0
107546: PPUSH
107547: CALL_OW 109
// solds := solds diff i ;
107551: LD_ADDR_VAR 0 2
107555: PUSH
107556: LD_VAR 0 2
107560: PUSH
107561: LD_VAR 0 7
107565: DIFF
107566: ST_TO_ADDR
// continue ;
107567: GO 107249
// end ; end ;
107569: GO 107249
107571: POP
107572: POP
// until not solds or not enemy ;
107573: LD_VAR 0 2
107577: NOT
107578: PUSH
107579: LD_VAR 0 4
107583: NOT
107584: OR
107585: IFFALSE 107153
// MC_Reset ( base , 18 ) ;
107587: LD_VAR 0 1
107591: PPUSH
107592: LD_INT 18
107594: PPUSH
107595: CALL 58015 0 2
// end ;
107599: LD_VAR 0 3
107603: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
107604: LD_INT 0
107606: PPUSH
107607: PPUSH
107608: PPUSH
107609: PPUSH
107610: PPUSH
107611: PPUSH
107612: PPUSH
107613: PPUSH
107614: PPUSH
107615: PPUSH
107616: PPUSH
107617: PPUSH
107618: PPUSH
107619: PPUSH
107620: PPUSH
107621: PPUSH
107622: PPUSH
107623: PPUSH
107624: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
107625: LD_ADDR_VAR 0 12
107629: PUSH
107630: LD_EXP 69
107634: PUSH
107635: LD_VAR 0 1
107639: ARRAY
107640: PPUSH
107641: LD_INT 25
107643: PUSH
107644: LD_INT 3
107646: PUSH
107647: EMPTY
107648: LIST
107649: LIST
107650: PPUSH
107651: CALL_OW 72
107655: ST_TO_ADDR
// if mc_remote_driver [ base ] then
107656: LD_EXP 109
107660: PUSH
107661: LD_VAR 0 1
107665: ARRAY
107666: IFFALSE 107690
// mechs := mechs diff mc_remote_driver [ base ] ;
107668: LD_ADDR_VAR 0 12
107672: PUSH
107673: LD_VAR 0 12
107677: PUSH
107678: LD_EXP 109
107682: PUSH
107683: LD_VAR 0 1
107687: ARRAY
107688: DIFF
107689: ST_TO_ADDR
// for i in mechs do
107690: LD_ADDR_VAR 0 4
107694: PUSH
107695: LD_VAR 0 12
107699: PUSH
107700: FOR_IN
107701: IFFALSE 107736
// if GetTag ( i ) > 0 then
107703: LD_VAR 0 4
107707: PPUSH
107708: CALL_OW 110
107712: PUSH
107713: LD_INT 0
107715: GREATER
107716: IFFALSE 107734
// mechs := mechs diff i ;
107718: LD_ADDR_VAR 0 12
107722: PUSH
107723: LD_VAR 0 12
107727: PUSH
107728: LD_VAR 0 4
107732: DIFF
107733: ST_TO_ADDR
107734: GO 107700
107736: POP
107737: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
107738: LD_ADDR_VAR 0 8
107742: PUSH
107743: LD_EXP 69
107747: PUSH
107748: LD_VAR 0 1
107752: ARRAY
107753: PPUSH
107754: LD_INT 2
107756: PUSH
107757: LD_INT 25
107759: PUSH
107760: LD_INT 1
107762: PUSH
107763: EMPTY
107764: LIST
107765: LIST
107766: PUSH
107767: LD_INT 25
107769: PUSH
107770: LD_INT 5
107772: PUSH
107773: EMPTY
107774: LIST
107775: LIST
107776: PUSH
107777: LD_INT 25
107779: PUSH
107780: LD_INT 8
107782: PUSH
107783: EMPTY
107784: LIST
107785: LIST
107786: PUSH
107787: LD_INT 25
107789: PUSH
107790: LD_INT 9
107792: PUSH
107793: EMPTY
107794: LIST
107795: LIST
107796: PUSH
107797: EMPTY
107798: LIST
107799: LIST
107800: LIST
107801: LIST
107802: LIST
107803: PPUSH
107804: CALL_OW 72
107808: ST_TO_ADDR
// if not defenders and not solds then
107809: LD_VAR 0 2
107813: NOT
107814: PUSH
107815: LD_VAR 0 8
107819: NOT
107820: AND
107821: IFFALSE 107825
// exit ;
107823: GO 109595
// depot_under_attack := false ;
107825: LD_ADDR_VAR 0 16
107829: PUSH
107830: LD_INT 0
107832: ST_TO_ADDR
// sold_defenders := [ ] ;
107833: LD_ADDR_VAR 0 17
107837: PUSH
107838: EMPTY
107839: ST_TO_ADDR
// if mechs then
107840: LD_VAR 0 12
107844: IFFALSE 107997
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
107846: LD_ADDR_VAR 0 4
107850: PUSH
107851: LD_VAR 0 2
107855: PPUSH
107856: LD_INT 21
107858: PUSH
107859: LD_INT 2
107861: PUSH
107862: EMPTY
107863: LIST
107864: LIST
107865: PPUSH
107866: CALL_OW 72
107870: PUSH
107871: FOR_IN
107872: IFFALSE 107995
// begin if GetTag ( i ) <> 20 then
107874: LD_VAR 0 4
107878: PPUSH
107879: CALL_OW 110
107883: PUSH
107884: LD_INT 20
107886: NONEQUAL
107887: IFFALSE 107901
// SetTag ( i , 20 ) ;
107889: LD_VAR 0 4
107893: PPUSH
107894: LD_INT 20
107896: PPUSH
107897: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
107901: LD_VAR 0 4
107905: PPUSH
107906: CALL_OW 263
107910: PUSH
107911: LD_INT 1
107913: EQUAL
107914: PUSH
107915: LD_VAR 0 4
107919: PPUSH
107920: CALL_OW 311
107924: NOT
107925: AND
107926: IFFALSE 107993
// begin un := mechs [ 1 ] ;
107928: LD_ADDR_VAR 0 10
107932: PUSH
107933: LD_VAR 0 12
107937: PUSH
107938: LD_INT 1
107940: ARRAY
107941: ST_TO_ADDR
// ComExit ( un ) ;
107942: LD_VAR 0 10
107946: PPUSH
107947: CALL 50727 0 1
// AddComEnterUnit ( un , i ) ;
107951: LD_VAR 0 10
107955: PPUSH
107956: LD_VAR 0 4
107960: PPUSH
107961: CALL_OW 180
// SetTag ( un , 19 ) ;
107965: LD_VAR 0 10
107969: PPUSH
107970: LD_INT 19
107972: PPUSH
107973: CALL_OW 109
// mechs := mechs diff un ;
107977: LD_ADDR_VAR 0 12
107981: PUSH
107982: LD_VAR 0 12
107986: PUSH
107987: LD_VAR 0 10
107991: DIFF
107992: ST_TO_ADDR
// end ; end ;
107993: GO 107871
107995: POP
107996: POP
// if solds then
107997: LD_VAR 0 8
108001: IFFALSE 108060
// for i in solds do
108003: LD_ADDR_VAR 0 4
108007: PUSH
108008: LD_VAR 0 8
108012: PUSH
108013: FOR_IN
108014: IFFALSE 108058
// if not GetTag ( i ) then
108016: LD_VAR 0 4
108020: PPUSH
108021: CALL_OW 110
108025: NOT
108026: IFFALSE 108056
// begin defenders := defenders union i ;
108028: LD_ADDR_VAR 0 2
108032: PUSH
108033: LD_VAR 0 2
108037: PUSH
108038: LD_VAR 0 4
108042: UNION
108043: ST_TO_ADDR
// SetTag ( i , 18 ) ;
108044: LD_VAR 0 4
108048: PPUSH
108049: LD_INT 18
108051: PPUSH
108052: CALL_OW 109
// end ;
108056: GO 108013
108058: POP
108059: POP
// repeat wait ( 0 0$2 ) ;
108060: LD_INT 70
108062: PPUSH
108063: CALL_OW 67
// enemy := mc_scan [ base ] ;
108067: LD_ADDR_VAR 0 21
108071: PUSH
108072: LD_EXP 92
108076: PUSH
108077: LD_VAR 0 1
108081: ARRAY
108082: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
108083: LD_EXP 69
108087: PUSH
108088: LD_VAR 0 1
108092: ARRAY
108093: NOT
108094: PUSH
108095: LD_EXP 69
108099: PUSH
108100: LD_VAR 0 1
108104: ARRAY
108105: PUSH
108106: EMPTY
108107: EQUAL
108108: OR
108109: IFFALSE 108146
// begin for i in defenders do
108111: LD_ADDR_VAR 0 4
108115: PUSH
108116: LD_VAR 0 2
108120: PUSH
108121: FOR_IN
108122: IFFALSE 108135
// ComStop ( i ) ;
108124: LD_VAR 0 4
108128: PPUSH
108129: CALL_OW 141
108133: GO 108121
108135: POP
108136: POP
// defenders := [ ] ;
108137: LD_ADDR_VAR 0 2
108141: PUSH
108142: EMPTY
108143: ST_TO_ADDR
// exit ;
108144: GO 109595
// end ; for i in defenders do
108146: LD_ADDR_VAR 0 4
108150: PUSH
108151: LD_VAR 0 2
108155: PUSH
108156: FOR_IN
108157: IFFALSE 109055
// begin e := NearestUnitToUnit ( enemy , i ) ;
108159: LD_ADDR_VAR 0 13
108163: PUSH
108164: LD_VAR 0 21
108168: PPUSH
108169: LD_VAR 0 4
108173: PPUSH
108174: CALL_OW 74
108178: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108179: LD_ADDR_VAR 0 7
108183: PUSH
108184: LD_EXP 69
108188: PUSH
108189: LD_VAR 0 1
108193: ARRAY
108194: PPUSH
108195: LD_INT 2
108197: PUSH
108198: LD_INT 30
108200: PUSH
108201: LD_INT 0
108203: PUSH
108204: EMPTY
108205: LIST
108206: LIST
108207: PUSH
108208: LD_INT 30
108210: PUSH
108211: LD_INT 1
108213: PUSH
108214: EMPTY
108215: LIST
108216: LIST
108217: PUSH
108218: EMPTY
108219: LIST
108220: LIST
108221: LIST
108222: PPUSH
108223: CALL_OW 72
108227: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
108228: LD_ADDR_VAR 0 16
108232: PUSH
108233: LD_VAR 0 7
108237: NOT
108238: PUSH
108239: LD_VAR 0 7
108243: PPUSH
108244: LD_INT 3
108246: PUSH
108247: LD_INT 24
108249: PUSH
108250: LD_INT 600
108252: PUSH
108253: EMPTY
108254: LIST
108255: LIST
108256: PUSH
108257: EMPTY
108258: LIST
108259: LIST
108260: PPUSH
108261: CALL_OW 72
108265: OR
108266: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
108267: LD_VAR 0 4
108271: PPUSH
108272: CALL_OW 247
108276: PUSH
108277: LD_INT 2
108279: DOUBLE
108280: EQUAL
108281: IFTRUE 108285
108283: GO 108681
108285: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
108286: LD_VAR 0 4
108290: PPUSH
108291: CALL_OW 256
108295: PUSH
108296: LD_INT 1000
108298: EQUAL
108299: PUSH
108300: LD_VAR 0 4
108304: PPUSH
108305: LD_VAR 0 13
108309: PPUSH
108310: CALL_OW 296
108314: PUSH
108315: LD_INT 40
108317: LESS
108318: PUSH
108319: LD_VAR 0 13
108323: PPUSH
108324: LD_EXP 94
108328: PUSH
108329: LD_VAR 0 1
108333: ARRAY
108334: PPUSH
108335: CALL_OW 308
108339: OR
108340: AND
108341: IFFALSE 108463
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
108343: LD_VAR 0 4
108347: PPUSH
108348: CALL_OW 262
108352: PUSH
108353: LD_INT 1
108355: EQUAL
108356: PUSH
108357: LD_VAR 0 4
108361: PPUSH
108362: CALL_OW 261
108366: PUSH
108367: LD_INT 30
108369: LESS
108370: AND
108371: PUSH
108372: LD_VAR 0 7
108376: AND
108377: IFFALSE 108447
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
108379: LD_VAR 0 4
108383: PPUSH
108384: LD_VAR 0 7
108388: PPUSH
108389: LD_VAR 0 4
108393: PPUSH
108394: CALL_OW 74
108398: PPUSH
108399: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
108403: LD_VAR 0 4
108407: PPUSH
108408: LD_VAR 0 7
108412: PPUSH
108413: LD_VAR 0 4
108417: PPUSH
108418: CALL_OW 74
108422: PPUSH
108423: CALL_OW 296
108427: PUSH
108428: LD_INT 6
108430: LESS
108431: IFFALSE 108445
// SetFuel ( i , 100 ) ;
108433: LD_VAR 0 4
108437: PPUSH
108438: LD_INT 100
108440: PPUSH
108441: CALL_OW 240
// end else
108445: GO 108461
// ComAttackUnit ( i , e ) ;
108447: LD_VAR 0 4
108451: PPUSH
108452: LD_VAR 0 13
108456: PPUSH
108457: CALL_OW 115
// end else
108461: GO 108564
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
108463: LD_VAR 0 13
108467: PPUSH
108468: LD_EXP 94
108472: PUSH
108473: LD_VAR 0 1
108477: ARRAY
108478: PPUSH
108479: CALL_OW 308
108483: NOT
108484: PUSH
108485: LD_VAR 0 4
108489: PPUSH
108490: LD_VAR 0 13
108494: PPUSH
108495: CALL_OW 296
108499: PUSH
108500: LD_INT 40
108502: GREATEREQUAL
108503: AND
108504: PUSH
108505: LD_VAR 0 4
108509: PPUSH
108510: CALL_OW 256
108514: PUSH
108515: LD_INT 650
108517: LESSEQUAL
108518: OR
108519: PUSH
108520: LD_VAR 0 4
108524: PPUSH
108525: LD_EXP 93
108529: PUSH
108530: LD_VAR 0 1
108534: ARRAY
108535: PPUSH
108536: CALL_OW 308
108540: NOT
108541: AND
108542: IFFALSE 108564
// ComMoveToArea ( i , mc_parking [ base ] ) ;
108544: LD_VAR 0 4
108548: PPUSH
108549: LD_EXP 93
108553: PUSH
108554: LD_VAR 0 1
108558: ARRAY
108559: PPUSH
108560: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
108564: LD_VAR 0 4
108568: PPUSH
108569: CALL_OW 256
108573: PUSH
108574: LD_INT 1000
108576: LESS
108577: PUSH
108578: LD_VAR 0 4
108582: PPUSH
108583: CALL_OW 263
108587: PUSH
108588: LD_INT 1
108590: EQUAL
108591: AND
108592: PUSH
108593: LD_VAR 0 4
108597: PPUSH
108598: CALL_OW 311
108602: AND
108603: PUSH
108604: LD_VAR 0 4
108608: PPUSH
108609: LD_EXP 93
108613: PUSH
108614: LD_VAR 0 1
108618: ARRAY
108619: PPUSH
108620: CALL_OW 308
108624: AND
108625: IFFALSE 108679
// begin mech := IsDrivenBy ( i ) ;
108627: LD_ADDR_VAR 0 9
108631: PUSH
108632: LD_VAR 0 4
108636: PPUSH
108637: CALL_OW 311
108641: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
108642: LD_VAR 0 9
108646: PPUSH
108647: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
108651: LD_VAR 0 9
108655: PPUSH
108656: LD_VAR 0 4
108660: PPUSH
108661: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
108665: LD_VAR 0 9
108669: PPUSH
108670: LD_VAR 0 4
108674: PPUSH
108675: CALL_OW 180
// end ; end ; unit_human :
108679: GO 109026
108681: LD_INT 1
108683: DOUBLE
108684: EQUAL
108685: IFTRUE 108689
108687: GO 109025
108689: POP
// begin b := IsInUnit ( i ) ;
108690: LD_ADDR_VAR 0 18
108694: PUSH
108695: LD_VAR 0 4
108699: PPUSH
108700: CALL_OW 310
108704: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
108705: LD_ADDR_VAR 0 19
108709: PUSH
108710: LD_VAR 0 18
108714: NOT
108715: PUSH
108716: LD_VAR 0 18
108720: PPUSH
108721: CALL_OW 266
108725: PUSH
108726: LD_INT 32
108728: PUSH
108729: LD_INT 31
108731: PUSH
108732: EMPTY
108733: LIST
108734: LIST
108735: IN
108736: OR
108737: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
108738: LD_VAR 0 18
108742: PPUSH
108743: CALL_OW 266
108747: PUSH
108748: LD_INT 5
108750: EQUAL
108751: PUSH
108752: LD_VAR 0 4
108756: PPUSH
108757: CALL_OW 257
108761: PUSH
108762: LD_INT 1
108764: PUSH
108765: LD_INT 2
108767: PUSH
108768: LD_INT 3
108770: PUSH
108771: LD_INT 4
108773: PUSH
108774: EMPTY
108775: LIST
108776: LIST
108777: LIST
108778: LIST
108779: IN
108780: AND
108781: IFFALSE 108818
// begin class := AllowSpecClass ( i ) ;
108783: LD_ADDR_VAR 0 20
108787: PUSH
108788: LD_VAR 0 4
108792: PPUSH
108793: CALL 15388 0 1
108797: ST_TO_ADDR
// if class then
108798: LD_VAR 0 20
108802: IFFALSE 108818
// ComChangeProfession ( i , class ) ;
108804: LD_VAR 0 4
108808: PPUSH
108809: LD_VAR 0 20
108813: PPUSH
108814: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
108818: LD_VAR 0 16
108822: PUSH
108823: LD_VAR 0 2
108827: PPUSH
108828: LD_INT 21
108830: PUSH
108831: LD_INT 2
108833: PUSH
108834: EMPTY
108835: LIST
108836: LIST
108837: PPUSH
108838: CALL_OW 72
108842: PUSH
108843: LD_INT 1
108845: LESSEQUAL
108846: OR
108847: PUSH
108848: LD_VAR 0 19
108852: AND
108853: PUSH
108854: LD_VAR 0 4
108858: PUSH
108859: LD_VAR 0 17
108863: IN
108864: NOT
108865: AND
108866: IFFALSE 108959
// begin if b then
108868: LD_VAR 0 18
108872: IFFALSE 108921
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
108874: LD_VAR 0 18
108878: PPUSH
108879: LD_VAR 0 21
108883: PPUSH
108884: LD_VAR 0 18
108888: PPUSH
108889: CALL_OW 74
108893: PPUSH
108894: CALL_OW 296
108898: PUSH
108899: LD_INT 10
108901: LESS
108902: PUSH
108903: LD_VAR 0 18
108907: PPUSH
108908: CALL_OW 461
108912: PUSH
108913: LD_INT 7
108915: NONEQUAL
108916: AND
108917: IFFALSE 108921
// continue ;
108919: GO 108156
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
108921: LD_ADDR_VAR 0 17
108925: PUSH
108926: LD_VAR 0 17
108930: PPUSH
108931: LD_VAR 0 17
108935: PUSH
108936: LD_INT 1
108938: PLUS
108939: PPUSH
108940: LD_VAR 0 4
108944: PPUSH
108945: CALL_OW 1
108949: ST_TO_ADDR
// ComExitBuilding ( i ) ;
108950: LD_VAR 0 4
108954: PPUSH
108955: CALL_OW 122
// end ; if sold_defenders then
108959: LD_VAR 0 17
108963: IFFALSE 109023
// if i in sold_defenders then
108965: LD_VAR 0 4
108969: PUSH
108970: LD_VAR 0 17
108974: IN
108975: IFFALSE 109023
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
108977: LD_VAR 0 4
108981: PPUSH
108982: CALL_OW 314
108986: NOT
108987: PUSH
108988: LD_VAR 0 4
108992: PPUSH
108993: LD_VAR 0 13
108997: PPUSH
108998: CALL_OW 296
109002: PUSH
109003: LD_INT 30
109005: LESS
109006: AND
109007: IFFALSE 109023
// ComAttackUnit ( i , e ) ;
109009: LD_VAR 0 4
109013: PPUSH
109014: LD_VAR 0 13
109018: PPUSH
109019: CALL_OW 115
// end ; end ; end ;
109023: GO 109026
109025: POP
// if IsDead ( i ) then
109026: LD_VAR 0 4
109030: PPUSH
109031: CALL_OW 301
109035: IFFALSE 109053
// defenders := defenders diff i ;
109037: LD_ADDR_VAR 0 2
109041: PUSH
109042: LD_VAR 0 2
109046: PUSH
109047: LD_VAR 0 4
109051: DIFF
109052: ST_TO_ADDR
// end ;
109053: GO 108156
109055: POP
109056: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
109057: LD_VAR 0 21
109061: NOT
109062: PUSH
109063: LD_VAR 0 2
109067: NOT
109068: OR
109069: PUSH
109070: LD_EXP 69
109074: PUSH
109075: LD_VAR 0 1
109079: ARRAY
109080: NOT
109081: OR
109082: IFFALSE 108060
// MC_Reset ( base , 18 ) ;
109084: LD_VAR 0 1
109088: PPUSH
109089: LD_INT 18
109091: PPUSH
109092: CALL 58015 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
109096: LD_ADDR_VAR 0 2
109100: PUSH
109101: LD_VAR 0 2
109105: PUSH
109106: LD_VAR 0 2
109110: PPUSH
109111: LD_INT 2
109113: PUSH
109114: LD_INT 25
109116: PUSH
109117: LD_INT 1
109119: PUSH
109120: EMPTY
109121: LIST
109122: LIST
109123: PUSH
109124: LD_INT 25
109126: PUSH
109127: LD_INT 5
109129: PUSH
109130: EMPTY
109131: LIST
109132: LIST
109133: PUSH
109134: LD_INT 25
109136: PUSH
109137: LD_INT 8
109139: PUSH
109140: EMPTY
109141: LIST
109142: LIST
109143: PUSH
109144: LD_INT 25
109146: PUSH
109147: LD_INT 9
109149: PUSH
109150: EMPTY
109151: LIST
109152: LIST
109153: PUSH
109154: EMPTY
109155: LIST
109156: LIST
109157: LIST
109158: LIST
109159: LIST
109160: PPUSH
109161: CALL_OW 72
109165: DIFF
109166: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
109167: LD_VAR 0 21
109171: NOT
109172: PUSH
109173: LD_VAR 0 2
109177: PPUSH
109178: LD_INT 21
109180: PUSH
109181: LD_INT 2
109183: PUSH
109184: EMPTY
109185: LIST
109186: LIST
109187: PPUSH
109188: CALL_OW 72
109192: AND
109193: IFFALSE 109531
// begin tmp := FilterByTag ( defenders , 19 ) ;
109195: LD_ADDR_VAR 0 11
109199: PUSH
109200: LD_VAR 0 2
109204: PPUSH
109205: LD_INT 19
109207: PPUSH
109208: CALL 47857 0 2
109212: ST_TO_ADDR
// if tmp then
109213: LD_VAR 0 11
109217: IFFALSE 109287
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
109219: LD_ADDR_VAR 0 11
109223: PUSH
109224: LD_VAR 0 11
109228: PPUSH
109229: LD_INT 25
109231: PUSH
109232: LD_INT 3
109234: PUSH
109235: EMPTY
109236: LIST
109237: LIST
109238: PPUSH
109239: CALL_OW 72
109243: ST_TO_ADDR
// if tmp then
109244: LD_VAR 0 11
109248: IFFALSE 109287
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
109250: LD_ADDR_EXP 81
109254: PUSH
109255: LD_EXP 81
109259: PPUSH
109260: LD_VAR 0 1
109264: PPUSH
109265: LD_EXP 81
109269: PUSH
109270: LD_VAR 0 1
109274: ARRAY
109275: PUSH
109276: LD_VAR 0 11
109280: UNION
109281: PPUSH
109282: CALL_OW 1
109286: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
109287: LD_VAR 0 1
109291: PPUSH
109292: LD_INT 19
109294: PPUSH
109295: CALL 58015 0 2
// repeat wait ( 0 0$1 ) ;
109299: LD_INT 35
109301: PPUSH
109302: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
109306: LD_EXP 69
109310: PUSH
109311: LD_VAR 0 1
109315: ARRAY
109316: NOT
109317: PUSH
109318: LD_EXP 69
109322: PUSH
109323: LD_VAR 0 1
109327: ARRAY
109328: PUSH
109329: EMPTY
109330: EQUAL
109331: OR
109332: IFFALSE 109369
// begin for i in defenders do
109334: LD_ADDR_VAR 0 4
109338: PUSH
109339: LD_VAR 0 2
109343: PUSH
109344: FOR_IN
109345: IFFALSE 109358
// ComStop ( i ) ;
109347: LD_VAR 0 4
109351: PPUSH
109352: CALL_OW 141
109356: GO 109344
109358: POP
109359: POP
// defenders := [ ] ;
109360: LD_ADDR_VAR 0 2
109364: PUSH
109365: EMPTY
109366: ST_TO_ADDR
// exit ;
109367: GO 109595
// end ; for i in defenders do
109369: LD_ADDR_VAR 0 4
109373: PUSH
109374: LD_VAR 0 2
109378: PUSH
109379: FOR_IN
109380: IFFALSE 109469
// begin if not IsInArea ( i , mc_parking [ base ] ) then
109382: LD_VAR 0 4
109386: PPUSH
109387: LD_EXP 93
109391: PUSH
109392: LD_VAR 0 1
109396: ARRAY
109397: PPUSH
109398: CALL_OW 308
109402: NOT
109403: IFFALSE 109427
// ComMoveToArea ( i , mc_parking [ base ] ) else
109405: LD_VAR 0 4
109409: PPUSH
109410: LD_EXP 93
109414: PUSH
109415: LD_VAR 0 1
109419: ARRAY
109420: PPUSH
109421: CALL_OW 113
109425: GO 109467
// if GetControl ( i ) = control_manual then
109427: LD_VAR 0 4
109431: PPUSH
109432: CALL_OW 263
109436: PUSH
109437: LD_INT 1
109439: EQUAL
109440: IFFALSE 109467
// if IsDrivenBy ( i ) then
109442: LD_VAR 0 4
109446: PPUSH
109447: CALL_OW 311
109451: IFFALSE 109467
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
109453: LD_VAR 0 4
109457: PPUSH
109458: CALL_OW 311
109462: PPUSH
109463: CALL_OW 121
// end ;
109467: GO 109379
109469: POP
109470: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
109471: LD_VAR 0 2
109475: PPUSH
109476: LD_INT 95
109478: PUSH
109479: LD_EXP 93
109483: PUSH
109484: LD_VAR 0 1
109488: ARRAY
109489: PUSH
109490: EMPTY
109491: LIST
109492: LIST
109493: PPUSH
109494: CALL_OW 72
109498: PUSH
109499: LD_VAR 0 2
109503: EQUAL
109504: PUSH
109505: LD_EXP 92
109509: PUSH
109510: LD_VAR 0 1
109514: ARRAY
109515: OR
109516: PUSH
109517: LD_EXP 69
109521: PUSH
109522: LD_VAR 0 1
109526: ARRAY
109527: NOT
109528: OR
109529: IFFALSE 109299
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
109531: LD_ADDR_EXP 91
109535: PUSH
109536: LD_EXP 91
109540: PPUSH
109541: LD_VAR 0 1
109545: PPUSH
109546: LD_VAR 0 2
109550: PPUSH
109551: LD_INT 21
109553: PUSH
109554: LD_INT 2
109556: PUSH
109557: EMPTY
109558: LIST
109559: LIST
109560: PPUSH
109561: CALL_OW 72
109565: PPUSH
109566: CALL_OW 1
109570: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
109571: LD_VAR 0 1
109575: PPUSH
109576: LD_INT 19
109578: PPUSH
109579: CALL 58015 0 2
// MC_Reset ( base , 20 ) ;
109583: LD_VAR 0 1
109587: PPUSH
109588: LD_INT 20
109590: PPUSH
109591: CALL 58015 0 2
// end ; end_of_file
109595: LD_VAR 0 3
109599: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
109600: LD_VAR 0 1
109604: PUSH
109605: LD_INT 200
109607: DOUBLE
109608: GREATEREQUAL
109609: IFFALSE 109617
109611: LD_INT 299
109613: DOUBLE
109614: LESSEQUAL
109615: IFTRUE 109619
109617: GO 109651
109619: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
109620: LD_VAR 0 1
109624: PPUSH
109625: LD_VAR 0 2
109629: PPUSH
109630: LD_VAR 0 3
109634: PPUSH
109635: LD_VAR 0 4
109639: PPUSH
109640: LD_VAR 0 5
109644: PPUSH
109645: CALL 98416 0 5
109649: GO 109728
109651: LD_INT 300
109653: DOUBLE
109654: GREATEREQUAL
109655: IFFALSE 109663
109657: LD_INT 399
109659: DOUBLE
109660: LESSEQUAL
109661: IFTRUE 109665
109663: GO 109727
109665: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
109666: LD_VAR 0 1
109670: PPUSH
109671: LD_VAR 0 2
109675: PPUSH
109676: LD_VAR 0 3
109680: PPUSH
109681: LD_VAR 0 4
109685: PPUSH
109686: LD_VAR 0 5
109690: PPUSH
109691: LD_VAR 0 6
109695: PPUSH
109696: LD_VAR 0 7
109700: PPUSH
109701: LD_VAR 0 8
109705: PPUSH
109706: LD_VAR 0 9
109710: PPUSH
109711: LD_VAR 0 10
109715: PPUSH
109716: LD_VAR 0 11
109720: PPUSH
109721: CALL 96314 0 11
109725: GO 109728
109727: POP
// end ;
109728: PPOPN 11
109730: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
109731: LD_VAR 0 1
109735: PPUSH
109736: LD_VAR 0 2
109740: PPUSH
109741: LD_VAR 0 3
109745: PPUSH
109746: LD_VAR 0 4
109750: PPUSH
109751: LD_VAR 0 5
109755: PPUSH
109756: CALL 98408 0 5
// end ; end_of_file
109760: PPOPN 5
109762: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
109763: LD_VAR 0 1
109767: PPUSH
109768: LD_VAR 0 2
109772: PPUSH
109773: LD_VAR 0 3
109777: PPUSH
109778: LD_VAR 0 4
109782: PPUSH
109783: LD_VAR 0 5
109787: PPUSH
109788: LD_VAR 0 6
109792: PPUSH
109793: CALL 84509 0 6
// end ;
109797: PPOPN 6
109799: END
