// export MissionStart ; starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  11: LD_INT 1
  13: PPUSH
  14: LD_INT 8
  16: PPUSH
  17: CALL_OW 332
// GameType ;
  21: CALL 5228 0 0
// SetBName ( BetaA , beta ) ;
  25: LD_INT 1
  27: PPUSH
  28: LD_STRING beta
  30: PPUSH
  31: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  35: LD_INT 3
  37: PPUSH
  38: LD_STRING beta
  40: PPUSH
  41: CALL_OW 500
// PrepareHeroes ;
  45: CALL 2391 0 0
// PrepareBeta ;
  49: CALL 2780 0 0
// InGameOn ;
  53: CALL_OW 8
// CenterNowOnUnits ( Brighton ) ;
  57: LD_EXP 8
  61: PPUSH
  62: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
  66: LD_EXP 10
  70: PPUSH
  71: LD_INT 50
  73: PPUSH
  74: LD_INT 42
  76: PPUSH
  77: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
  81: LD_INT 35
  83: PPUSH
  84: CALL_OW 67
  88: LD_EXP 10
  92: PPUSH
  93: LD_EXP 8
  97: PPUSH
  98: CALL_OW 296
 102: PUSH
 103: LD_INT 3
 105: LESS
 106: IFFALSE 81
// ComTurnUnit ( Megan , Brighton ) ;
 108: LD_EXP 10
 112: PPUSH
 113: LD_EXP 8
 117: PPUSH
 118: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 122: LD_EXP 10
 126: PPUSH
 127: LD_STRING DMegan-1a
 129: PPUSH
 130: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 134: LD_INT 10
 136: PPUSH
 137: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 141: LD_EXP 8
 145: PPUSH
 146: LD_EXP 10
 150: PPUSH
 151: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 155: LD_EXP 8
 159: PPUSH
 160: LD_STRING DBrighton-1a
 162: PPUSH
 163: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 167: LD_EXP 10
 171: PPUSH
 172: LD_STRING DMegan-2a
 174: PPUSH
 175: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 179: LD_EXP 8
 183: PPUSH
 184: LD_STRING DBrighton-2a
 186: PPUSH
 187: CALL_OW 88
// Say ( Megan , DMegan-3a ) ;
 191: LD_EXP 10
 195: PPUSH
 196: LD_STRING DMegan-3a
 198: PPUSH
 199: CALL_OW 88
// Say ( Brighton , DBrighton-3a ) ;
 203: LD_EXP 8
 207: PPUSH
 208: LD_STRING DBrighton-3a
 210: PPUSH
 211: CALL_OW 88
// Say ( Megan , DMegan-4a ) ;
 215: LD_EXP 10
 219: PPUSH
 220: LD_STRING DMegan-4a
 222: PPUSH
 223: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 227: LD_EXP 10
 231: PPUSH
 232: LD_INT 40
 234: PPUSH
 235: LD_INT 37
 237: PPUSH
 238: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 242: LD_EXP 10
 246: PPUSH
 247: LD_EXP 8
 251: PPUSH
 252: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 256: LD_EXP 9
 260: PPUSH
 261: LD_INT 50
 263: PPUSH
 264: LD_INT 42
 266: PPUSH
 267: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 271: LD_INT 35
 273: PPUSH
 274: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 278: LD_EXP 8
 282: PPUSH
 283: LD_EXP 9
 287: PPUSH
 288: CALL_OW 296
 292: PUSH
 293: LD_INT 6
 295: LESS
 296: IFFALSE 271
// ComTurnUnit ( Brighton , Palmer ) ;
 298: LD_EXP 8
 302: PPUSH
 303: LD_EXP 9
 307: PPUSH
 308: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 312: LD_EXP 9
 316: PPUSH
 317: LD_EXP 8
 321: PPUSH
 322: CALL_OW 119
// Say ( Megan , DMegan-5a ) ;
 326: LD_EXP 10
 330: PPUSH
 331: LD_STRING DMegan-5a
 333: PPUSH
 334: CALL_OW 88
// Say ( Palmer , DPalmer-1 ) ;
 338: LD_EXP 9
 342: PPUSH
 343: LD_STRING DPalmer-1
 345: PPUSH
 346: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 350: LD_EXP 8
 354: PPUSH
 355: LD_STRING DBrighton-1
 357: PPUSH
 358: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 362: LD_EXP 9
 366: PPUSH
 367: LD_STRING DPalmer-2
 369: PPUSH
 370: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 374: LD_EXP 8
 378: PPUSH
 379: LD_STRING DBrighton-2
 381: PPUSH
 382: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 386: LD_EXP 9
 390: PPUSH
 391: LD_STRING DPalmer-3
 393: PPUSH
 394: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 398: LD_EXP 8
 402: PPUSH
 403: LD_STRING DBrighton-3
 405: PPUSH
 406: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 410: LD_EXP 9
 414: PPUSH
 415: LD_STRING DPalmer-4
 417: PPUSH
 418: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 422: LD_EXP 9
 426: PPUSH
 427: LD_INT 6
 429: PPUSH
 430: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 434: LD_INT 35
 436: PPUSH
 437: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 441: LD_EXP 9
 445: PPUSH
 446: CALL_OW 310
 450: PUSH
 451: LD_INT 6
 453: EQUAL
 454: IFFALSE 434
// SayRadio ( Palmer , DPalmer-5 ) ;
 456: LD_EXP 9
 460: PPUSH
 461: LD_STRING DPalmer-5
 463: PPUSH
 464: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 468: LD_EXP 8
 472: PPUSH
 473: LD_INT 59
 475: PPUSH
 476: LD_INT 36
 478: PPUSH
 479: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_INT 60
 490: PPUSH
 491: LD_INT 35
 493: PPUSH
 494: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 498: LD_EXP 9
 502: PPUSH
 503: LD_INT 60
 505: PPUSH
 506: LD_INT 34
 508: PPUSH
 509: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 513: LD_EXP 8
 517: PPUSH
 518: LD_INT 99
 520: PPUSH
 521: LD_INT 37
 523: PPUSH
 524: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 528: LD_EXP 10
 532: PPUSH
 533: LD_EXP 8
 537: PPUSH
 538: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 542: LD_EXP 9
 546: PPUSH
 547: LD_EXP 8
 551: PPUSH
 552: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 556: LD_INT 64
 558: PPUSH
 559: LD_INT 40
 561: PPUSH
 562: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 566: LD_EXP 11
 570: PPUSH
 571: LD_INT 13
 573: PPUSH
 574: CALL 11035 0 2
// wait ( 0 0$30 ) ;
 578: LD_INT 1050
 580: PPUSH
 581: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 585: LD_EXP 8
 589: PPUSH
 590: LD_STRING DBrighton-4
 592: PPUSH
 593: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 597: LD_EXP 8
 601: PPUSH
 602: LD_STRING DBrighton-5
 604: PPUSH
 605: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 609: LD_EXP 8
 613: PPUSH
 614: LD_EXP 10
 618: PPUSH
 619: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 623: LD_EXP 8
 627: PPUSH
 628: LD_STRING DBrighton-6
 630: PPUSH
 631: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 635: LD_EXP 10
 639: PPUSH
 640: LD_STRING DMegan-1
 642: PPUSH
 643: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 647: LD_EXP 8
 651: PPUSH
 652: LD_STRING DBrighton-7
 654: PPUSH
 655: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 659: LD_EXP 8
 663: PPUSH
 664: LD_INT 99
 666: PPUSH
 667: LD_INT 37
 669: PPUSH
 670: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 674: LD_EXP 8
 678: PPUSH
 679: LD_STRING DBrighton-8
 681: PPUSH
 682: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 686: LD_STRING C1
 688: PPUSH
 689: CALL_OW 337
// InGameOff ;
 693: CALL_OW 9
// SaveForQuickRestart ;
 697: CALL_OW 22
// MissionStart := true ;
 701: LD_ADDR_EXP 1
 705: PUSH
 706: LD_INT 1
 708: ST_TO_ADDR
// music_nat := 1 ;
 709: LD_ADDR_OWVAR 71
 713: PUSH
 714: LD_INT 1
 716: ST_TO_ADDR
// end ;
 717: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var tmp , i ;
 718: LD_EXP 1
 722: IFFALSE 1917
 724: GO 726
 726: DISABLE
 727: LD_INT 0
 729: PPUSH
 730: PPUSH
// begin wait ( ruArrival ) ;
 731: LD_EXP 41
 735: PPUSH
 736: CALL_OW 67
// PrepareRUArmada ;
 740: CALL 3362 0 0
// wait ( 0 0$3 ) ;
 744: LD_INT 105
 746: PPUSH
 747: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 751: LD_ADDR_VAR 0 1
 755: PUSH
 756: LD_INT 15
 758: PPUSH
 759: LD_INT 0
 761: PPUSH
 762: CALL_OW 517
 766: ST_TO_ADDR
// for i = 1 to RUArmada do
 767: LD_ADDR_VAR 0 2
 771: PUSH
 772: DOUBLE
 773: LD_INT 1
 775: DEC
 776: ST_TO_ADDR
 777: LD_EXP 16
 781: PUSH
 782: FOR_TO
 783: IFFALSE 832
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 785: LD_EXP 16
 789: PUSH
 790: LD_VAR 0 2
 794: ARRAY
 795: PPUSH
 796: LD_VAR 0 1
 800: PUSH
 801: LD_INT 1
 803: ARRAY
 804: PUSH
 805: LD_VAR 0 2
 809: ARRAY
 810: PPUSH
 811: LD_VAR 0 1
 815: PUSH
 816: LD_INT 2
 818: ARRAY
 819: PUSH
 820: LD_VAR 0 2
 824: ARRAY
 825: PPUSH
 826: CALL_OW 111
 830: GO 782
 832: POP
 833: POP
// ArmadaArrived := true ;
 834: LD_ADDR_EXP 2
 838: PUSH
 839: LD_INT 1
 841: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 842: LD_EXP 9
 846: PPUSH
 847: LD_STRING DPalmer-A1
 849: PPUSH
 850: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 854: LD_EXP 8
 858: PPUSH
 859: LD_STRING DBrighton-A1
 861: PPUSH
 862: CALL_OW 88
// wait ( 0 0$20 ) ;
 866: LD_INT 700
 868: PPUSH
 869: CALL_OW 67
// PrepareRUBase ;
 873: CALL 4087 0 0
// PrepareRUBase_v2 ;
 877: CALL 4503 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 881: LD_ADDR_EXP 52
 885: PUSH
 886: LD_EXP 52
 890: PPUSH
 891: LD_INT 1
 893: PPUSH
 894: LD_INT 22
 896: PUSH
 897: LD_INT 3
 899: PUSH
 900: EMPTY
 901: LIST
 902: LIST
 903: PPUSH
 904: CALL_OW 69
 908: PPUSH
 909: CALL_OW 1
 913: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 914: LD_ADDR_EXP 52
 918: PUSH
 919: LD_EXP 52
 923: PPUSH
 924: LD_INT 2
 926: PPUSH
 927: LD_EXP 35
 931: PPUSH
 932: CALL_OW 1
 936: ST_TO_ADDR
// MC_Start ( ) ;
 937: CALL 56510 0 0
// wait ( 0 0$30 ) ;
 941: LD_INT 1050
 943: PPUSH
 944: CALL_OW 67
// PrepareRUBulldozers ;
 948: CALL 3974 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 952: LD_EXP 17
 956: PUSH
 957: LD_INT 1
 959: ARRAY
 960: PPUSH
 961: LD_INT 9
 963: PPUSH
 964: CALL 10892 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 968: LD_EXP 17
 972: PUSH
 973: LD_INT 2
 975: ARRAY
 976: PPUSH
 977: LD_INT 11
 979: PPUSH
 980: CALL 10892 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
 984: LD_INT 1
 986: PPUSH
 987: LD_EXP 17
 991: PUSH
 992: LD_INT 1
 994: ARRAY
 995: PPUSH
 996: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1000: LD_INT 1
1002: PPUSH
1003: LD_EXP 17
1007: PUSH
1008: LD_INT 2
1010: ARRAY
1011: PPUSH
1012: CALL_OW 471
// wait ( 0 0$30 ) ;
1016: LD_INT 1050
1018: PPUSH
1019: CALL_OW 67
// InGameOn ;
1023: CALL_OW 8
// PlaceSeeing ( 95 , 93 , 1 , - 30 ) ;
1027: LD_INT 95
1029: PPUSH
1030: LD_INT 93
1032: PPUSH
1033: LD_INT 1
1035: PPUSH
1036: LD_INT 30
1038: NEG
1039: PPUSH
1040: CALL_OW 330
// ComMoveXY ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) , 63 , 39 ) ;
1044: LD_INT 10
1046: PPUSH
1047: LD_INT 22
1049: PUSH
1050: LD_INT 1
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: PPUSH
1057: CALL_OW 70
1061: PPUSH
1062: LD_INT 63
1064: PPUSH
1065: LD_INT 39
1067: PPUSH
1068: CALL_OW 111
// CenterOnXY ( 95 , 93 ) ;
1072: LD_INT 95
1074: PPUSH
1075: LD_INT 93
1077: PPUSH
1078: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
1082: LD_INT 35
1084: PPUSH
1085: CALL_OW 67
// if not HasTask ( Bulldozers [ 1 ] ) then
1089: LD_EXP 17
1093: PUSH
1094: LD_INT 1
1096: ARRAY
1097: PPUSH
1098: CALL_OW 314
1102: NOT
1103: IFFALSE 1121
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
1105: LD_EXP 17
1109: PUSH
1110: LD_INT 1
1112: ARRAY
1113: PPUSH
1114: LD_INT 9
1116: PPUSH
1117: CALL 10892 0 2
// if not HasTask ( Bulldozers [ 2 ] ) then
1121: LD_EXP 17
1125: PUSH
1126: LD_INT 2
1128: ARRAY
1129: PPUSH
1130: CALL_OW 314
1134: NOT
1135: IFFALSE 1153
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
1137: LD_EXP 17
1141: PUSH
1142: LD_INT 2
1144: ARRAY
1145: PPUSH
1146: LD_INT 11
1148: PPUSH
1149: CALL 10892 0 2
// until ListEnvironmentArea ( BulldozerArea ) < 2 or ListEnvironmentArea ( BulldozerArea2 ) < 2 or IsDead ( Bulldozers [ 1 ] ) ;
1153: LD_INT 9
1155: PPUSH
1156: CALL_OW 353
1160: PUSH
1161: LD_INT 2
1163: LESS
1164: PUSH
1165: LD_INT 11
1167: PPUSH
1168: CALL_OW 353
1172: PUSH
1173: LD_INT 2
1175: LESS
1176: OR
1177: PUSH
1178: LD_EXP 17
1182: PUSH
1183: LD_INT 1
1185: ARRAY
1186: PPUSH
1187: CALL_OW 301
1191: OR
1192: IFFALSE 1082
// if UnitFilter ( Bulldozers , [ f_ok ] ) then
1194: LD_EXP 17
1198: PPUSH
1199: LD_INT 50
1201: PUSH
1202: EMPTY
1203: LIST
1204: PPUSH
1205: CALL_OW 72
1209: IFFALSE 1262
// begin wait ( 0 0$10 ) ;
1211: LD_INT 350
1213: PPUSH
1214: CALL_OW 67
// ComMoveXY ( Bulldozers , 120 , 131 ) ;
1218: LD_EXP 17
1222: PPUSH
1223: LD_INT 120
1225: PPUSH
1226: LD_INT 131
1228: PPUSH
1229: CALL_OW 111
// for i in Bulldozers do
1233: LD_ADDR_VAR 0 2
1237: PUSH
1238: LD_EXP 17
1242: PUSH
1243: FOR_IN
1244: IFFALSE 1260
// NormalAttack ( 1 , i ) ;
1246: LD_INT 1
1248: PPUSH
1249: LD_VAR 0 2
1253: PPUSH
1254: CALL_OW 472
1258: GO 1243
1260: POP
1261: POP
// end ; wait ( 0 0$10 ) ;
1262: LD_INT 350
1264: PPUSH
1265: CALL_OW 67
// RemoveSeeing ( 95 , 93 , 1 ) ;
1269: LD_INT 95
1271: PPUSH
1272: LD_INT 93
1274: PPUSH
1275: LD_INT 1
1277: PPUSH
1278: CALL_OW 331
// Say ( Yashin , DDeath-Yas-1 ) ;
1282: LD_EXP 12
1286: PPUSH
1287: LD_STRING DDeath-Yas-1
1289: PPUSH
1290: CALL_OW 88
// SayEffect ( DRuSol-A1 ) ;
1294: LD_STRING DRuSol-A1
1296: PPUSH
1297: CALL_OW 96
// wait ( 0 0$2 ) ;
1301: LD_INT 70
1303: PPUSH
1304: CALL_OW 67
// InGameOff ;
1308: CALL_OW 9
// ComMoveXY ( RUArmada , 66 , 40 ) ;
1312: LD_EXP 16
1316: PPUSH
1317: LD_INT 66
1319: PPUSH
1320: LD_INT 40
1322: PPUSH
1323: CALL_OW 111
// wait ( 0 0$2 ) ;
1327: LD_INT 70
1329: PPUSH
1330: CALL_OW 67
// Say ( Gaydar , DDeath-Gay-2 ) ;
1334: LD_EXP 14
1338: PPUSH
1339: LD_STRING DDeath-Gay-2
1341: PPUSH
1342: CALL_OW 88
// wait ( 0 0$20 ) ;
1346: LD_INT 700
1348: PPUSH
1349: CALL_OW 67
// AssaultStarted := true ;
1353: LD_ADDR_EXP 7
1357: PUSH
1358: LD_INT 1
1360: ST_TO_ADDR
// Say ( Popov , DDeath-Pop-1 ) ;
1361: LD_EXP 13
1365: PPUSH
1366: LD_STRING DDeath-Pop-1
1368: PPUSH
1369: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1373: LD_EXP 14
1377: PPUSH
1378: LD_STRING DDeath-Gay-1
1380: PPUSH
1381: CALL_OW 88
// wait ( 0 0$5 ) ;
1385: LD_INT 175
1387: PPUSH
1388: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1392: LD_EXP 15
1396: PPUSH
1397: LD_STRING DDeath-Vse-1
1399: PPUSH
1400: CALL_OW 88
// PriorityAttack ( 6 , BetaA ) ;
1404: LD_INT 6
1406: PPUSH
1407: LD_INT 1
1409: PPUSH
1410: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1414: LD_INT 6
1416: PPUSH
1417: LD_INT 3
1419: PPUSH
1420: CALL_OW 470
// repeat for i in RuArmada do
1424: LD_ADDR_VAR 0 2
1428: PUSH
1429: LD_EXP 16
1433: PUSH
1434: FOR_IN
1435: IFFALSE 1485
// if not HasTask ( i ) then
1437: LD_VAR 0 2
1441: PPUSH
1442: CALL_OW 314
1446: NOT
1447: IFFALSE 1483
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1449: LD_VAR 0 2
1453: PPUSH
1454: LD_INT 22
1456: PUSH
1457: LD_INT 1
1459: PUSH
1460: EMPTY
1461: LIST
1462: LIST
1463: PPUSH
1464: CALL_OW 69
1468: PPUSH
1469: LD_VAR 0 2
1473: PPUSH
1474: CALL_OW 74
1478: PPUSH
1479: CALL_OW 115
1483: GO 1434
1485: POP
1486: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1487: LD_INT 35
1489: PPUSH
1490: CALL_OW 67
1494: LD_INT 1
1496: PUSH
1497: LD_INT 22
1499: PUSH
1500: LD_INT 6
1502: PUSH
1503: EMPTY
1504: LIST
1505: LIST
1506: PUSH
1507: LD_INT 21
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: PPUSH
1522: CALL_OW 69
1526: PUSH
1527: LD_INT 10
1529: LESS
1530: PUSH
1531: LD_EXP 12
1535: PPUSH
1536: CALL_OW 301
1540: AND
1541: PUSH
1542: LD_EXP 13
1546: PPUSH
1547: CALL_OW 301
1551: AND
1552: PUSH
1553: LD_EXP 14
1557: PPUSH
1558: CALL_OW 301
1562: AND
1563: PUSH
1564: LD_EXP 15
1568: PPUSH
1569: CALL_OW 301
1573: AND
1574: IFFALSE 1424
// AssaultStarted := false ;
1576: LD_ADDR_EXP 7
1580: PUSH
1581: LD_INT 0
1583: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 6 ] ) , 120 , 131 ) ;
1584: LD_INT 22
1586: PUSH
1587: LD_INT 6
1589: PUSH
1590: EMPTY
1591: LIST
1592: LIST
1593: PPUSH
1594: CALL_OW 69
1598: PPUSH
1599: LD_INT 120
1601: PPUSH
1602: LD_INT 131
1604: PPUSH
1605: CALL_OW 111
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1609: LD_ADDR_EXP 4
1613: PUSH
1614: LD_INT 1
1616: PUSH
1617: LD_INT 22
1619: PUSH
1620: LD_INT 6
1622: PUSH
1623: EMPTY
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 26
1629: PUSH
1630: LD_INT 1
1632: PUSH
1633: EMPTY
1634: LIST
1635: LIST
1636: PUSH
1637: LD_INT 21
1639: PUSH
1640: LD_INT 1
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: LD_INT 24
1649: PUSH
1650: LD_INT 500
1652: PUSH
1653: EMPTY
1654: LIST
1655: LIST
1656: PUSH
1657: EMPTY
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: PPUSH
1664: CALL_OW 69
1668: ST_TO_ADDR
// if RuSpeaker then
1669: LD_EXP 4
1673: IFFALSE 1691
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1675: LD_EXP 4
1679: PUSH
1680: LD_INT 1
1682: ARRAY
1683: PPUSH
1684: LD_STRING DRuSol-A2
1686: PPUSH
1687: CALL_OW 88
// wait ( 0 0$30 ) ;
1691: LD_INT 1050
1693: PPUSH
1694: CALL_OW 67
// DialogueOn ;
1698: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1702: LD_EXP 8
1706: PPUSH
1707: LD_STRING DBrighton-B1
1709: PPUSH
1710: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1714: LD_EXP 9
1718: PPUSH
1719: LD_STRING DPalmer-B1
1721: PPUSH
1722: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1726: LD_EXP 8
1730: PPUSH
1731: LD_STRING DBrighton-B2
1733: PPUSH
1734: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1738: LD_EXP 18
1742: PPUSH
1743: LD_STRING DBurlak-B1
1745: PPUSH
1746: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1750: LD_EXP 8
1754: PPUSH
1755: LD_STRING DBrighton-B3
1757: PPUSH
1758: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1762: LD_EXP 9
1766: PPUSH
1767: LD_STRING DPalmer-B2
1769: PPUSH
1770: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1774: LD_EXP 8
1778: PPUSH
1779: LD_STRING DBrighton-B4
1781: PPUSH
1782: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1786: LD_EXP 8
1790: PPUSH
1791: LD_STRING DBrighton-B5
1793: PPUSH
1794: CALL_OW 88
// DialogueOff ;
1798: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1802: LD_STRING C2
1804: PPUSH
1805: CALL_OW 337
// FirstAssaultRepelled := true ;
1809: LD_ADDR_EXP 3
1813: PUSH
1814: LD_INT 1
1816: ST_TO_ADDR
// RemoveUnit ( Bulldozers [ 1 ] ) ;
1817: LD_EXP 17
1821: PUSH
1822: LD_INT 1
1824: ARRAY
1825: PPUSH
1826: CALL_OW 64
// RemoveUnit ( Bulldozers [ 2 ] ) ;
1830: LD_EXP 17
1834: PUSH
1835: LD_INT 2
1837: ARRAY
1838: PPUSH
1839: CALL_OW 64
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1843: LD_INT 22
1845: PUSH
1846: LD_INT 6
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: PPUSH
1853: CALL_OW 69
1857: PPUSH
1858: CALL_OW 181
// SetSide ( FilterAllUnits ( [ f_side , 6 ] ) , 3 ) ;
1862: LD_INT 22
1864: PUSH
1865: LD_INT 6
1867: PUSH
1868: EMPTY
1869: LIST
1870: LIST
1871: PPUSH
1872: CALL_OW 69
1876: PPUSH
1877: LD_INT 3
1879: PPUSH
1880: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
1884: LD_ADDR_EXP 52
1888: PUSH
1889: LD_EXP 52
1893: PPUSH
1894: LD_INT 1
1896: PPUSH
1897: LD_INT 22
1899: PUSH
1900: LD_INT 3
1902: PUSH
1903: EMPTY
1904: LIST
1905: LIST
1906: PPUSH
1907: CALL_OW 69
1911: PPUSH
1912: CALL_OW 1
1916: ST_TO_ADDR
// end ;
1917: PPOPN 2
1919: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
1920: LD_EXP 3
1924: PUSH
1925: LD_EXP 40
1929: PUSH
1930: LD_INT 0
1932: GREATER
1933: AND
1934: IFFALSE 1954
1936: GO 1938
1938: DISABLE
// begin enable ;
1939: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
1940: LD_ADDR_EXP 40
1944: PUSH
1945: LD_EXP 40
1949: PUSH
1950: LD_INT 35
1952: MINUS
1953: ST_TO_ADDR
// end ;
1954: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
1955: LD_EXP 40
1959: PUSH
1960: LD_INT 0
1962: EQUAL
1963: IFFALSE 2069
1965: GO 1967
1967: DISABLE
// begin JMMReinforcement ;
1968: CALL 4831 0 0
// DialogueOn ;
1972: CALL_OW 6
// CenterOnUnits ( JMM ) ;
1976: LD_EXP 36
1980: PPUSH
1981: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
1985: LD_EXP 36
1989: PPUSH
1990: LD_STRING DJMM-F1
1992: PPUSH
1993: CALL_OW 88
// if RussiansDefeated then
1997: LD_EXP 42
2001: IFFALSE 2027
// begin AddMedal ( Russians , 1 ) ;
2003: LD_STRING Russians
2005: PPUSH
2006: LD_INT 1
2008: PPUSH
2009: CALL_OW 101
// Say ( Brighton , DBrighton-F1a ) ;
2013: LD_EXP 8
2017: PPUSH
2018: LD_STRING DBrighton-F1a
2020: PPUSH
2021: CALL_OW 88
// end else
2025: GO 2057
// begin AddMedal ( Russians , - 1 ) ;
2027: LD_STRING Russians
2029: PPUSH
2030: LD_INT 1
2032: NEG
2033: PPUSH
2034: CALL_OW 101
// Say ( Brighton , DBrighton-F1 ) ;
2038: LD_EXP 8
2042: PPUSH
2043: LD_STRING DBrighton-F1
2045: PPUSH
2046: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2050: LD_STRING C3
2052: PPUSH
2053: CALL_OW 337
// end ; DialogueOff ;
2057: CALL_OW 7
// JMM_Arrived := true ;
2061: LD_ADDR_EXP 5
2065: PUSH
2066: LD_INT 1
2068: ST_TO_ADDR
// end ;
2069: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2070: LD_EXP 5
2074: PUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_EXP 18
2082: PPUSH
2083: CALL_OW 292
2087: AND
2088: IFFALSE 2117
2090: GO 2092
2092: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2093: LD_EXP 18
2097: PPUSH
2098: LD_STRING DBurlak
2100: PPUSH
2101: CALL_OW 88
// Say ( JMM , DJMM ) ;
2105: LD_EXP 36
2109: PPUSH
2110: LD_STRING DJMM
2112: PPUSH
2113: CALL_OW 88
// end ;
2117: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2118: LD_INT 1
2120: PUSH
2121: LD_INT 22
2123: PUSH
2124: LD_INT 1
2126: PUSH
2127: EMPTY
2128: LIST
2129: LIST
2130: PUSH
2131: LD_INT 2
2133: PUSH
2134: LD_INT 34
2136: PUSH
2137: LD_INT 9
2139: PUSH
2140: EMPTY
2141: LIST
2142: LIST
2143: PUSH
2144: LD_INT 35
2146: PUSH
2147: LD_INT 9
2149: PUSH
2150: EMPTY
2151: LIST
2152: LIST
2153: PUSH
2154: EMPTY
2155: LIST
2156: LIST
2157: LIST
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: LIST
2163: PPUSH
2164: CALL_OW 69
2168: PUSH
2169: LD_INT 1
2171: GREATER
2172: IFFALSE 2185
2174: GO 2176
2176: DISABLE
// begin LaserBuilt := true ;
2177: LD_ADDR_EXP 6
2181: PUSH
2182: LD_INT 1
2184: ST_TO_ADDR
// end ;
2185: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2186: LD_EXP 7
2190: PUSH
2191: LD_INT 6
2193: PPUSH
2194: LD_INT 1
2196: PUSH
2197: LD_INT 22
2199: PUSH
2200: LD_INT 1
2202: PUSH
2203: EMPTY
2204: LIST
2205: LIST
2206: PUSH
2207: LD_INT 35
2209: PUSH
2210: LD_INT 9
2212: PUSH
2213: EMPTY
2214: LIST
2215: LIST
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PUSH
2221: EMPTY
2222: LIST
2223: LIST
2224: PPUSH
2225: CALL_OW 69
2229: PPUSH
2230: LD_EXP 15
2234: PPUSH
2235: CALL_OW 310
2239: PPUSH
2240: CALL_OW 74
2244: PPUSH
2245: CALL_OW 292
2249: AND
2250: IFFALSE 2286
2252: GO 2254
2254: DISABLE
// begin wait ( 0 0$5 ) ;
2255: LD_INT 175
2257: PPUSH
2258: CALL_OW 67
// Say ( Sevi , DDeath-Vse-2 ) ;
2262: LD_EXP 15
2266: PPUSH
2267: LD_STRING DDeath-Vse-2
2269: PPUSH
2270: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2274: LD_EXP 12
2278: PPUSH
2279: LD_STRING DDeath-Yas-2
2281: PPUSH
2282: CALL_OW 88
// end ;
2286: END
// every 0 0$1 trigger AssaultStarted do
2287: LD_EXP 7
2291: IFFALSE 2315
2293: GO 2295
2295: DISABLE
// begin wait ( 0 0$20 ) ;
2296: LD_INT 700
2298: PPUSH
2299: CALL_OW 67
// Say ( Popov , DDeath-Pop-2 ) ;
2303: LD_EXP 13
2307: PPUSH
2308: LD_STRING DDeath-Pop-2
2310: PPUSH
2311: CALL_OW 88
// end ;
2315: END
// every 0 0$1 trigger MissionStart do
2316: LD_EXP 1
2320: IFFALSE 2362
2322: GO 2324
2324: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2325: LD_INT 1750
2327: PPUSH
2328: LD_INT 4900
2330: PPUSH
2331: CALL_OW 12
2335: PPUSH
2336: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2340: LD_INT 2
2342: PPUSH
2343: LD_INT 5
2345: PPUSH
2346: CALL_OW 12
2350: PPUSH
2351: LD_INT 12
2353: PPUSH
2354: LD_INT 1
2356: PPUSH
2357: CALL_OW 55
// enable ;
2361: ENABLE
// end ;
2362: END
// every 0 0$1 trigger MissionStart do
2363: LD_EXP 1
2367: IFFALSE 2390
2369: GO 2371
2371: DISABLE
// begin enable ;
2372: ENABLE
// display_Strings := [ #tick , tick ] ;
2373: LD_ADDR_OWVAR 47
2377: PUSH
2378: LD_STRING #tick
2380: PUSH
2381: LD_OWVAR 1
2385: PUSH
2386: EMPTY
2387: LIST
2388: LIST
2389: ST_TO_ADDR
// end ; end_of_file
2390: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2391: LD_INT 0
2393: PPUSH
// uc_side := 1 ;
2394: LD_ADDR_OWVAR 20
2398: PUSH
2399: LD_INT 1
2401: ST_TO_ADDR
// hc_class = class_soldier ;
2402: LD_ADDR_OWVAR 28
2406: PUSH
2407: LD_INT 1
2409: ST_TO_ADDR
// uc_nation := nation_american ;
2410: LD_ADDR_OWVAR 21
2414: PUSH
2415: LD_INT 1
2417: ST_TO_ADDR
// hc_sex = sex_male ;
2418: LD_ADDR_OWVAR 27
2422: PUSH
2423: LD_INT 1
2425: ST_TO_ADDR
// hc_importance = 110 ;
2426: LD_ADDR_OWVAR 32
2430: PUSH
2431: LD_INT 110
2433: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2434: LD_ADDR_OWVAR 30
2438: PUSH
2439: LD_INT 5
2441: PUSH
2442: LD_INT 4
2444: PUSH
2445: LD_INT 5
2447: PUSH
2448: LD_INT 3
2450: PUSH
2451: EMPTY
2452: LIST
2453: LIST
2454: LIST
2455: LIST
2456: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2457: LD_ADDR_OWVAR 31
2461: PUSH
2462: LD_INT 9
2464: PUSH
2465: LD_INT 6
2467: PUSH
2468: LD_INT 7
2470: PUSH
2471: LD_INT 6
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: LIST
2478: LIST
2479: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2480: LD_ADDR_OWVAR 29
2484: PUSH
2485: LD_INT 12
2487: PUSH
2488: LD_INT 10
2490: PUSH
2491: EMPTY
2492: LIST
2493: LIST
2494: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2495: LD_ADDR_OWVAR 26
2499: PUSH
2500: LD_STRING Gerard Brighton
2502: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2503: LD_ADDR_OWVAR 33
2507: PUSH
2508: LD_STRING Beta_Skirmish
2510: ST_TO_ADDR
// hc_face_number := 1 ;
2511: LD_ADDR_OWVAR 34
2515: PUSH
2516: LD_INT 1
2518: ST_TO_ADDR
// Brighton := CreateHuman ;
2519: LD_ADDR_EXP 8
2523: PUSH
2524: CALL_OW 44
2528: ST_TO_ADDR
// uc_nation := nation_american ;
2529: LD_ADDR_OWVAR 21
2533: PUSH
2534: LD_INT 1
2536: ST_TO_ADDR
// hc_importance = 80 ;
2537: LD_ADDR_OWVAR 32
2541: PUSH
2542: LD_INT 80
2544: ST_TO_ADDR
// hc_sex = sex_male ;
2545: LD_ADDR_OWVAR 27
2549: PUSH
2550: LD_INT 1
2552: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2553: LD_ADDR_OWVAR 30
2557: PUSH
2558: LD_INT 5
2560: PUSH
2561: LD_INT 5
2563: PUSH
2564: LD_INT 3
2566: PUSH
2567: LD_INT 1
2569: PUSH
2570: EMPTY
2571: LIST
2572: LIST
2573: LIST
2574: LIST
2575: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2576: LD_ADDR_OWVAR 31
2580: PUSH
2581: LD_INT 7
2583: PUSH
2584: LD_INT 6
2586: PUSH
2587: LD_INT 5
2589: PUSH
2590: LD_INT 3
2592: PUSH
2593: EMPTY
2594: LIST
2595: LIST
2596: LIST
2597: LIST
2598: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2599: LD_ADDR_OWVAR 29
2603: PUSH
2604: LD_INT 10
2606: PUSH
2607: LD_INT 10
2609: PUSH
2610: EMPTY
2611: LIST
2612: LIST
2613: ST_TO_ADDR
// hc_name := Brian Palmer ;
2614: LD_ADDR_OWVAR 26
2618: PUSH
2619: LD_STRING Brian Palmer
2621: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2622: LD_ADDR_OWVAR 33
2626: PUSH
2627: LD_STRING Beta_Skirmish
2629: ST_TO_ADDR
// hc_face_number := 3 ;
2630: LD_ADDR_OWVAR 34
2634: PUSH
2635: LD_INT 3
2637: ST_TO_ADDR
// Palmer := CreateHuman ;
2638: LD_ADDR_EXP 9
2642: PUSH
2643: CALL_OW 44
2647: ST_TO_ADDR
// hc_class = class_scientistic ;
2648: LD_ADDR_OWVAR 28
2652: PUSH
2653: LD_INT 4
2655: ST_TO_ADDR
// uc_nation := nation_american ;
2656: LD_ADDR_OWVAR 21
2660: PUSH
2661: LD_INT 1
2663: ST_TO_ADDR
// hc_importance = 70 ;
2664: LD_ADDR_OWVAR 32
2668: PUSH
2669: LD_INT 70
2671: ST_TO_ADDR
// hc_sex = sex_female ;
2672: LD_ADDR_OWVAR 27
2676: PUSH
2677: LD_INT 2
2679: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2680: LD_ADDR_OWVAR 30
2684: PUSH
2685: LD_INT 3
2687: PUSH
2688: LD_INT 2
2690: PUSH
2691: LD_INT 4
2693: PUSH
2694: LD_INT 6
2696: PUSH
2697: EMPTY
2698: LIST
2699: LIST
2700: LIST
2701: LIST
2702: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2703: LD_ADDR_OWVAR 31
2707: PUSH
2708: LD_INT 4
2710: PUSH
2711: LD_INT 2
2713: PUSH
2714: LD_INT 5
2716: PUSH
2717: LD_INT 8
2719: PUSH
2720: EMPTY
2721: LIST
2722: LIST
2723: LIST
2724: LIST
2725: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2726: LD_ADDR_OWVAR 29
2730: PUSH
2731: LD_INT 10
2733: PUSH
2734: LD_INT 10
2736: PUSH
2737: EMPTY
2738: LIST
2739: LIST
2740: ST_TO_ADDR
// hc_name := Megan Armitage ;
2741: LD_ADDR_OWVAR 26
2745: PUSH
2746: LD_STRING Megan Armitage
2748: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2749: LD_ADDR_OWVAR 33
2753: PUSH
2754: LD_STRING Beta_Skirmish
2756: ST_TO_ADDR
// hc_face_number := 4 ;
2757: LD_ADDR_OWVAR 34
2761: PUSH
2762: LD_INT 4
2764: ST_TO_ADDR
// Megan := CreateHuman ;
2765: LD_ADDR_EXP 10
2769: PUSH
2770: CALL_OW 44
2774: ST_TO_ADDR
// end ;
2775: LD_VAR 0 1
2779: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
2780: LD_INT 0
2782: PPUSH
2783: PPUSH
2784: PPUSH
2785: PPUSH
2786: PPUSH
// uc_side := 1 ;
2787: LD_ADDR_OWVAR 20
2791: PUSH
2792: LD_INT 1
2794: ST_TO_ADDR
// uc_nation := nation_american ;
2795: LD_ADDR_OWVAR 21
2799: PUSH
2800: LD_INT 1
2802: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
2803: LD_ADDR_VAR 0 2
2807: PUSH
2808: LD_INT 22
2810: PUSH
2811: LD_INT 1
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: PUSH
2818: LD_INT 30
2820: PUSH
2821: LD_INT 32
2823: PUSH
2824: EMPTY
2825: LIST
2826: LIST
2827: PUSH
2828: EMPTY
2829: LIST
2830: LIST
2831: PPUSH
2832: CALL_OW 69
2836: PUSH
2837: FOR_IN
2838: IFFALSE 2893
// PlaceWeaponTurret ( i , [ us_light_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
2840: LD_VAR 0 2
2844: PPUSH
2845: LD_INT 3
2847: PUSH
2848: LD_INT 3
2850: PUSH
2851: LD_INT 4
2853: PUSH
2854: LD_INT 5
2856: PUSH
2857: LD_INT 11
2859: PUSH
2860: LD_INT 3
2862: PUSH
2863: LD_INT 4
2865: PUSH
2866: EMPTY
2867: LIST
2868: LIST
2869: LIST
2870: LIST
2871: LIST
2872: LIST
2873: LIST
2874: PUSH
2875: LD_INT 1
2877: PPUSH
2878: LD_INT 7
2880: PPUSH
2881: CALL_OW 12
2885: ARRAY
2886: PPUSH
2887: CALL_OW 431
2891: GO 2837
2893: POP
2894: POP
// hc_name :=  ;
2895: LD_ADDR_OWVAR 26
2899: PUSH
2900: LD_STRING 
2902: ST_TO_ADDR
// hc_gallery :=  ;
2903: LD_ADDR_OWVAR 33
2907: PUSH
2908: LD_STRING 
2910: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
2911: LD_ADDR_VAR 0 2
2915: PUSH
2916: DOUBLE
2917: LD_INT 1
2919: DEC
2920: ST_TO_ADDR
2921: LD_INT 6
2923: PUSH
2924: LD_INT 5
2926: PUSH
2927: LD_INT 5
2929: PUSH
2930: EMPTY
2931: LIST
2932: LIST
2933: LIST
2934: PUSH
2935: LD_OWVAR 67
2939: ARRAY
2940: PUSH
2941: FOR_TO
2942: IFFALSE 3000
// begin PrepareSoldier ( 1 , game_skill ) ;
2944: LD_INT 1
2946: PPUSH
2947: LD_EXP 38
2951: PPUSH
2952: CALL_OW 381
// un := CreateHuman ;
2956: LD_ADDR_VAR 0 4
2960: PUSH
2961: CALL_OW 44
2965: ST_TO_ADDR
// filter := filter ^ un ;
2966: LD_ADDR_VAR 0 3
2970: PUSH
2971: LD_VAR 0 3
2975: PUSH
2976: LD_VAR 0 4
2980: ADD
2981: ST_TO_ADDR
// soldiers := soldiers ^ un ;
2982: LD_ADDR_VAR 0 5
2986: PUSH
2987: LD_VAR 0 5
2991: PUSH
2992: LD_VAR 0 4
2996: ADD
2997: ST_TO_ADDR
// end ;
2998: GO 2941
3000: POP
3001: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
3002: LD_ADDR_VAR 0 2
3006: PUSH
3007: DOUBLE
3008: LD_INT 1
3010: DEC
3011: ST_TO_ADDR
3012: LD_INT 3
3014: PUSH
3015: LD_INT 2
3017: PUSH
3018: LD_INT 2
3020: PUSH
3021: EMPTY
3022: LIST
3023: LIST
3024: LIST
3025: PUSH
3026: LD_OWVAR 67
3030: ARRAY
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3087
// begin PrepareEngineer ( 0 , game_skill ) ;
3035: LD_INT 0
3037: PPUSH
3038: LD_EXP 38
3042: PPUSH
3043: CALL_OW 382
// un := CreateHuman ;
3047: LD_ADDR_VAR 0 4
3051: PUSH
3052: CALL_OW 44
3056: ST_TO_ADDR
// filter := filter ^ un ;
3057: LD_ADDR_VAR 0 3
3061: PUSH
3062: LD_VAR 0 3
3066: PUSH
3067: LD_VAR 0 4
3071: ADD
3072: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3073: LD_VAR 0 4
3077: PPUSH
3078: LD_INT 3
3080: PPUSH
3081: CALL_OW 52
// end ;
3085: GO 3032
3087: POP
3088: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3089: LD_ADDR_VAR 0 2
3093: PUSH
3094: DOUBLE
3095: LD_INT 1
3097: DEC
3098: ST_TO_ADDR
3099: LD_INT 4
3101: PUSH
3102: LD_INT 3
3104: PUSH
3105: LD_INT 3
3107: PUSH
3108: EMPTY
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PUSH
3119: FOR_TO
3120: IFFALSE 3174
// begin PrepareMechanic ( 0 , game_skill ) ;
3122: LD_INT 0
3124: PPUSH
3125: LD_EXP 38
3129: PPUSH
3130: CALL_OW 383
// un := CreateHuman ;
3134: LD_ADDR_VAR 0 4
3138: PUSH
3139: CALL_OW 44
3143: ST_TO_ADDR
// filter := filter ^ un ;
3144: LD_ADDR_VAR 0 3
3148: PUSH
3149: LD_VAR 0 3
3153: PUSH
3154: LD_VAR 0 4
3158: ADD
3159: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3160: LD_VAR 0 4
3164: PPUSH
3165: LD_INT 8
3167: PPUSH
3168: CALL_OW 52
// end ;
3172: GO 3119
3174: POP
3175: POP
// for i = 1 to 2 do
3176: LD_ADDR_VAR 0 2
3180: PUSH
3181: DOUBLE
3182: LD_INT 1
3184: DEC
3185: ST_TO_ADDR
3186: LD_INT 2
3188: PUSH
3189: FOR_TO
3190: IFFALSE 3244
// begin PrepareScientist ( 0 , game_skill ) ;
3192: LD_INT 0
3194: PPUSH
3195: LD_EXP 38
3199: PPUSH
3200: CALL_OW 384
// un := CreateHuman ;
3204: LD_ADDR_VAR 0 4
3208: PUSH
3209: CALL_OW 44
3213: ST_TO_ADDR
// filter := filter ^ un ;
3214: LD_ADDR_VAR 0 3
3218: PUSH
3219: LD_VAR 0 3
3223: PUSH
3224: LD_VAR 0 4
3228: ADD
3229: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3230: LD_VAR 0 4
3234: PPUSH
3235: LD_INT 14
3237: PPUSH
3238: CALL_OW 52
// end ;
3242: GO 3189
3244: POP
3245: POP
// for i = 1 to soldiers do
3246: LD_ADDR_VAR 0 2
3250: PUSH
3251: DOUBLE
3252: LD_INT 1
3254: DEC
3255: ST_TO_ADDR
3256: LD_VAR 0 5
3260: PUSH
3261: FOR_TO
3262: IFFALSE 3287
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3264: LD_VAR 0 5
3268: PUSH
3269: LD_VAR 0 2
3273: ARRAY
3274: PPUSH
3275: LD_INT 1
3277: PPUSH
3278: LD_INT 0
3280: PPUSH
3281: CALL_OW 49
3285: GO 3261
3287: POP
3288: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3289: LD_EXP 8
3293: PPUSH
3294: LD_INT 51
3296: PPUSH
3297: LD_INT 43
3299: PPUSH
3300: LD_INT 0
3302: PPUSH
3303: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3307: LD_EXP 9
3311: PPUSH
3312: LD_INT 55
3314: PPUSH
3315: LD_INT 58
3317: PPUSH
3318: LD_INT 0
3320: PPUSH
3321: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3325: LD_EXP 10
3329: PPUSH
3330: LD_INT 39
3332: PPUSH
3333: LD_INT 36
3335: PPUSH
3336: LD_INT 0
3338: PPUSH
3339: CALL_OW 48
// BetaSquad := filter diff 0 ;
3343: LD_ADDR_EXP 11
3347: PUSH
3348: LD_VAR 0 3
3352: PUSH
3353: LD_INT 0
3355: DIFF
3356: ST_TO_ADDR
// end ;
3357: LD_VAR 0 1
3361: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3362: LD_INT 0
3364: PPUSH
3365: PPUSH
3366: PPUSH
3367: PPUSH
3368: PPUSH
3369: PPUSH
// uc_side := 6 ;
3370: LD_ADDR_OWVAR 20
3374: PUSH
3375: LD_INT 6
3377: ST_TO_ADDR
// uc_nation := nation_russian ;
3378: LD_ADDR_OWVAR 21
3382: PUSH
3383: LD_INT 3
3385: ST_TO_ADDR
// soldiers := [ ] ;
3386: LD_ADDR_VAR 0 4
3390: PUSH
3391: EMPTY
3392: ST_TO_ADDR
// vehs := [ ] ;
3393: LD_ADDR_VAR 0 6
3397: PUSH
3398: EMPTY
3399: ST_TO_ADDR
// RUArmada := [ ] ;
3400: LD_ADDR_EXP 16
3404: PUSH
3405: EMPTY
3406: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3407: LD_ADDR_EXP 12
3411: PUSH
3412: LD_STRING Yashin
3414: PPUSH
3415: CALL_OW 25
3419: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3420: LD_ADDR_EXP 13
3424: PUSH
3425: LD_STRING Popov
3427: PPUSH
3428: CALL_OW 25
3432: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3433: LD_ADDR_EXP 14
3437: PUSH
3438: LD_STRING Gaydar
3440: PPUSH
3441: CALL_OW 25
3445: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3446: LD_ADDR_EXP 15
3450: PUSH
3451: LD_STRING Vsevolod
3453: PPUSH
3454: CALL_OW 25
3458: ST_TO_ADDR
// for i = 1 to 16 do
3459: LD_ADDR_VAR 0 2
3463: PUSH
3464: DOUBLE
3465: LD_INT 1
3467: DEC
3468: ST_TO_ADDR
3469: LD_INT 16
3471: PUSH
3472: FOR_TO
3473: IFFALSE 3515
// begin PrepareSoldier ( 0 , game_eskill ) ;
3475: LD_INT 0
3477: PPUSH
3478: LD_EXP 39
3482: PPUSH
3483: CALL_OW 381
// un := CreateHuman ;
3487: LD_ADDR_VAR 0 5
3491: PUSH
3492: CALL_OW 44
3496: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3497: LD_ADDR_VAR 0 4
3501: PUSH
3502: LD_VAR 0 4
3506: PUSH
3507: LD_VAR 0 5
3511: ADD
3512: ST_TO_ADDR
// end ;
3513: GO 3472
3515: POP
3516: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3517: LD_ADDR_VAR 0 4
3521: PUSH
3522: LD_EXP 12
3526: PUSH
3527: LD_EXP 13
3531: ADD
3532: PUSH
3533: LD_EXP 14
3537: ADD
3538: PUSH
3539: LD_EXP 15
3543: ADD
3544: PUSH
3545: LD_VAR 0 4
3549: ADD
3550: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3551: LD_INT 24
3553: PPUSH
3554: LD_INT 3
3556: PPUSH
3557: LD_INT 1
3559: PPUSH
3560: LD_INT 46
3562: PPUSH
3563: LD_INT 100
3565: PPUSH
3566: CALL 18297 0 5
// for i = 1 to 8 do
3570: LD_ADDR_VAR 0 2
3574: PUSH
3575: DOUBLE
3576: LD_INT 1
3578: DEC
3579: ST_TO_ADDR
3580: LD_INT 8
3582: PUSH
3583: FOR_TO
3584: IFFALSE 3667
// begin vehicle := CreateVehicle ;
3586: LD_ADDR_VAR 0 3
3590: PUSH
3591: CALL_OW 45
3595: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3596: LD_VAR 0 4
3600: PUSH
3601: LD_INT 1
3603: ARRAY
3604: PPUSH
3605: LD_VAR 0 3
3609: PPUSH
3610: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3614: LD_ADDR_VAR 0 4
3618: PUSH
3619: LD_VAR 0 4
3623: PUSH
3624: LD_VAR 0 4
3628: PUSH
3629: LD_INT 1
3631: ARRAY
3632: DIFF
3633: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3634: LD_VAR 0 3
3638: PPUSH
3639: LD_INT 5
3641: PPUSH
3642: LD_INT 0
3644: PPUSH
3645: CALL_OW 49
// vehs := vehs ^ vehicle ;
3649: LD_ADDR_VAR 0 6
3653: PUSH
3654: LD_VAR 0 6
3658: PUSH
3659: LD_VAR 0 3
3663: ADD
3664: ST_TO_ADDR
// end ;
3665: GO 3583
3667: POP
3668: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3669: LD_INT 24
3671: PPUSH
3672: LD_INT 3
3674: PPUSH
3675: LD_INT 1
3677: PPUSH
3678: LD_INT 43
3680: PPUSH
3681: LD_INT 100
3683: PPUSH
3684: CALL 18297 0 5
// for i = 1 to 8 do
3688: LD_ADDR_VAR 0 2
3692: PUSH
3693: DOUBLE
3694: LD_INT 1
3696: DEC
3697: ST_TO_ADDR
3698: LD_INT 8
3700: PUSH
3701: FOR_TO
3702: IFFALSE 3785
// begin vehicle := CreateVehicle ;
3704: LD_ADDR_VAR 0 3
3708: PUSH
3709: CALL_OW 45
3713: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3714: LD_VAR 0 4
3718: PUSH
3719: LD_INT 1
3721: ARRAY
3722: PPUSH
3723: LD_VAR 0 3
3727: PPUSH
3728: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3732: LD_ADDR_VAR 0 4
3736: PUSH
3737: LD_VAR 0 4
3741: PUSH
3742: LD_VAR 0 4
3746: PUSH
3747: LD_INT 1
3749: ARRAY
3750: DIFF
3751: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3752: LD_VAR 0 3
3756: PPUSH
3757: LD_INT 5
3759: PPUSH
3760: LD_INT 0
3762: PPUSH
3763: CALL_OW 49
// vehs := vehs ^ vehicle ;
3767: LD_ADDR_VAR 0 6
3771: PUSH
3772: LD_VAR 0 6
3776: PUSH
3777: LD_VAR 0 3
3781: ADD
3782: ST_TO_ADDR
// end ;
3783: GO 3701
3785: POP
3786: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
3787: LD_INT 22
3789: PPUSH
3790: LD_INT 3
3792: PPUSH
3793: LD_INT 1
3795: PPUSH
3796: LD_INT 44
3798: PPUSH
3799: LD_INT 100
3801: PPUSH
3802: CALL 18297 0 5
// for i = 1 to 4 do
3806: LD_ADDR_VAR 0 2
3810: PUSH
3811: DOUBLE
3812: LD_INT 1
3814: DEC
3815: ST_TO_ADDR
3816: LD_INT 4
3818: PUSH
3819: FOR_TO
3820: IFFALSE 3903
// begin vehicle := CreateVehicle ;
3822: LD_ADDR_VAR 0 3
3826: PUSH
3827: CALL_OW 45
3831: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3832: LD_VAR 0 4
3836: PUSH
3837: LD_INT 1
3839: ARRAY
3840: PPUSH
3841: LD_VAR 0 3
3845: PPUSH
3846: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3850: LD_ADDR_VAR 0 4
3854: PUSH
3855: LD_VAR 0 4
3859: PUSH
3860: LD_VAR 0 4
3864: PUSH
3865: LD_INT 1
3867: ARRAY
3868: DIFF
3869: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3870: LD_VAR 0 3
3874: PPUSH
3875: LD_INT 5
3877: PPUSH
3878: LD_INT 0
3880: PPUSH
3881: CALL_OW 49
// vehs := vehs ^ vehicle ;
3885: LD_ADDR_VAR 0 6
3889: PUSH
3890: LD_VAR 0 6
3894: PUSH
3895: LD_VAR 0 3
3899: ADD
3900: ST_TO_ADDR
// end ;
3901: GO 3819
3903: POP
3904: POP
// RUArmada := vehs ;
3905: LD_ADDR_EXP 16
3909: PUSH
3910: LD_VAR 0 6
3914: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
3915: LD_EXP 12
3919: PPUSH
3920: CALL_OW 310
3924: PUSH
3925: LD_EXP 13
3929: PPUSH
3930: CALL_OW 310
3934: PUSH
3935: LD_EXP 14
3939: PPUSH
3940: CALL_OW 310
3944: PUSH
3945: LD_EXP 15
3949: PPUSH
3950: CALL_OW 310
3954: PUSH
3955: EMPTY
3956: LIST
3957: LIST
3958: LIST
3959: LIST
3960: PPUSH
3961: LD_INT 6
3963: NEG
3964: PPUSH
3965: CALL_OW 242
// end ;
3969: LD_VAR 0 1
3973: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
3974: LD_INT 0
3976: PPUSH
3977: PPUSH
3978: PPUSH
// uc_side := 6 ;
3979: LD_ADDR_OWVAR 20
3983: PUSH
3984: LD_INT 6
3986: ST_TO_ADDR
// uc_nation := nation_russian ;
3987: LD_ADDR_OWVAR 21
3991: PUSH
3992: LD_INT 3
3994: ST_TO_ADDR
// Bulldozers := [ ] ;
3995: LD_ADDR_EXP 17
3999: PUSH
4000: EMPTY
4001: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
4002: LD_INT 24
4004: PPUSH
4005: LD_INT 3
4007: PPUSH
4008: LD_INT 3
4010: PPUSH
4011: LD_INT 53
4013: PPUSH
4014: LD_INT 100
4016: PPUSH
4017: CALL 18297 0 5
// for i = 1 to 2 do
4021: LD_ADDR_VAR 0 2
4025: PUSH
4026: DOUBLE
4027: LD_INT 1
4029: DEC
4030: ST_TO_ADDR
4031: LD_INT 2
4033: PUSH
4034: FOR_TO
4035: IFFALSE 4080
// begin vehicle := CreateVehicle ;
4037: LD_ADDR_VAR 0 3
4041: PUSH
4042: CALL_OW 45
4046: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4047: LD_VAR 0 3
4051: PPUSH
4052: LD_INT 5
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4062: LD_ADDR_EXP 17
4066: PUSH
4067: LD_EXP 17
4071: PUSH
4072: LD_VAR 0 3
4076: ADD
4077: ST_TO_ADDR
// end ;
4078: GO 4034
4080: POP
4081: POP
// end ;
4082: LD_VAR 0 1
4086: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4087: LD_INT 0
4089: PPUSH
4090: PPUSH
4091: PPUSH
4092: PPUSH
// uc_side := 3 ;
4093: LD_ADDR_OWVAR 20
4097: PUSH
4098: LD_INT 3
4100: ST_TO_ADDR
// uc_nation := nation_russian ;
4101: LD_ADDR_OWVAR 21
4105: PUSH
4106: LD_INT 3
4108: ST_TO_ADDR
// hc_name :=  ;
4109: LD_ADDR_OWVAR 26
4113: PUSH
4114: LD_STRING 
4116: ST_TO_ADDR
// hc_gallery :=  ;
4117: LD_ADDR_OWVAR 33
4121: PUSH
4122: LD_STRING 
4124: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4125: LD_ADDR_EXP 18
4129: PUSH
4130: LD_STRING Burlak
4132: PPUSH
4133: CALL_OW 25
4137: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4138: LD_ADDR_EXP 19
4142: PUSH
4143: LD_STRING Gleb
4145: PPUSH
4146: CALL_OW 25
4150: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4151: LD_ADDR_EXP 20
4155: PUSH
4156: LD_STRING Furmanov
4158: PPUSH
4159: CALL_OW 25
4163: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4164: LD_ADDR_EXP 21
4168: PUSH
4169: LD_STRING Titov
4171: PPUSH
4172: CALL_OW 25
4176: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4177: LD_ADDR_EXP 22
4181: PUSH
4182: LD_STRING Scholtze
4184: PPUSH
4185: CALL_OW 25
4189: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4190: LD_ADDR_EXP 23
4194: PUSH
4195: LD_STRING Dolgov
4197: PPUSH
4198: CALL_OW 25
4202: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4203: LD_ADDR_EXP 24
4207: PUSH
4208: LD_STRING Kapitsova
4210: PPUSH
4211: CALL_OW 25
4215: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4216: LD_ADDR_EXP 25
4220: PUSH
4221: LD_STRING Karamazov
4223: PPUSH
4224: CALL_OW 25
4228: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4229: LD_ADDR_EXP 26
4233: PUSH
4234: LD_STRING Kirlenkova
4236: PPUSH
4237: CALL_OW 25
4241: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4242: LD_ADDR_EXP 27
4246: PUSH
4247: LD_STRING Kovalyuk
4249: PPUSH
4250: CALL_OW 25
4254: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4255: LD_ADDR_EXP 28
4259: PUSH
4260: LD_STRING Kozlov
4262: PPUSH
4263: CALL_OW 25
4267: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4268: LD_ADDR_EXP 29
4272: PUSH
4273: LD_STRING Kuzmov
4275: PPUSH
4276: CALL_OW 25
4280: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4281: LD_ADDR_EXP 30
4285: PUSH
4286: LD_STRING Lipshchin
4288: PPUSH
4289: CALL_OW 25
4293: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4294: LD_ADDR_EXP 31
4298: PUSH
4299: LD_STRING Oblukov
4301: PPUSH
4302: CALL_OW 25
4306: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4307: LD_ADDR_EXP 32
4311: PUSH
4312: LD_STRING Xavier2
4314: PPUSH
4315: CALL_OW 25
4319: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4320: LD_ADDR_EXP 33
4324: PUSH
4325: LD_STRING Gnyevko
4327: PPUSH
4328: CALL_OW 25
4332: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4333: LD_ADDR_EXP 34
4337: PUSH
4338: LD_STRING Belkov
4340: PPUSH
4341: CALL_OW 25
4345: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4346: LD_ADDR_VAR 0 3
4350: PUSH
4351: LD_EXP 18
4355: PUSH
4356: LD_EXP 19
4360: PUSH
4361: LD_EXP 20
4365: PUSH
4366: LD_EXP 21
4370: PUSH
4371: LD_EXP 22
4375: PUSH
4376: LD_EXP 23
4380: PUSH
4381: LD_EXP 24
4385: PUSH
4386: LD_EXP 25
4390: PUSH
4391: LD_EXP 26
4395: PUSH
4396: LD_EXP 27
4400: PUSH
4401: LD_EXP 28
4405: PUSH
4406: LD_EXP 29
4410: PUSH
4411: LD_EXP 30
4415: PUSH
4416: LD_EXP 31
4420: PUSH
4421: LD_EXP 32
4425: PUSH
4426: LD_EXP 33
4430: PUSH
4431: LD_EXP 34
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: LIST
4442: LIST
4443: LIST
4444: LIST
4445: LIST
4446: LIST
4447: LIST
4448: LIST
4449: LIST
4450: LIST
4451: LIST
4452: LIST
4453: LIST
4454: ST_TO_ADDR
// for i = 1 to filter do
4455: LD_ADDR_VAR 0 2
4459: PUSH
4460: DOUBLE
4461: LD_INT 1
4463: DEC
4464: ST_TO_ADDR
4465: LD_VAR 0 3
4469: PUSH
4470: FOR_TO
4471: IFFALSE 4496
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4473: LD_VAR 0 3
4477: PUSH
4478: LD_VAR 0 2
4482: ARRAY
4483: PPUSH
4484: LD_INT 6
4486: PPUSH
4487: LD_INT 0
4489: PPUSH
4490: CALL_OW 49
4494: GO 4470
4496: POP
4497: POP
// end ;
4498: LD_VAR 0 1
4502: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4503: LD_INT 0
4505: PPUSH
4506: PPUSH
4507: PPUSH
4508: PPUSH
// uc_side := 3 ;
4509: LD_ADDR_OWVAR 20
4513: PUSH
4514: LD_INT 3
4516: ST_TO_ADDR
// uc_nation := nation_russian ;
4517: LD_ADDR_OWVAR 21
4521: PUSH
4522: LD_INT 3
4524: ST_TO_ADDR
// hc_name :=  ;
4525: LD_ADDR_OWVAR 26
4529: PUSH
4530: LD_STRING 
4532: ST_TO_ADDR
// hc_gallery :=  ;
4533: LD_ADDR_OWVAR 33
4537: PUSH
4538: LD_STRING 
4540: ST_TO_ADDR
// for i = 1 to 8 do
4541: LD_ADDR_VAR 0 2
4545: PUSH
4546: DOUBLE
4547: LD_INT 1
4549: DEC
4550: ST_TO_ADDR
4551: LD_INT 8
4553: PUSH
4554: FOR_TO
4555: IFFALSE 4597
// begin PrepareSoldier ( 0 , game_eskill ) ;
4557: LD_INT 0
4559: PPUSH
4560: LD_EXP 39
4564: PPUSH
4565: CALL_OW 381
// un := CreateHuman ;
4569: LD_ADDR_VAR 0 4
4573: PUSH
4574: CALL_OW 44
4578: ST_TO_ADDR
// filter := filter ^ un ;
4579: LD_ADDR_VAR 0 3
4583: PUSH
4584: LD_VAR 0 3
4588: PUSH
4589: LD_VAR 0 4
4593: ADD
4594: ST_TO_ADDR
// end ;
4595: GO 4554
4597: POP
4598: POP
// for i = 1 to 4 do
4599: LD_ADDR_VAR 0 2
4603: PUSH
4604: DOUBLE
4605: LD_INT 1
4607: DEC
4608: ST_TO_ADDR
4609: LD_INT 4
4611: PUSH
4612: FOR_TO
4613: IFFALSE 4655
// begin PrepareEngineer ( 0 , game_eskill ) ;
4615: LD_INT 0
4617: PPUSH
4618: LD_EXP 39
4622: PPUSH
4623: CALL_OW 382
// un := CreateHuman ;
4627: LD_ADDR_VAR 0 4
4631: PUSH
4632: CALL_OW 44
4636: ST_TO_ADDR
// filter := filter ^ un ;
4637: LD_ADDR_VAR 0 3
4641: PUSH
4642: LD_VAR 0 3
4646: PUSH
4647: LD_VAR 0 4
4651: ADD
4652: ST_TO_ADDR
// end ;
4653: GO 4612
4655: POP
4656: POP
// for i = 1 to 6 do
4657: LD_ADDR_VAR 0 2
4661: PUSH
4662: DOUBLE
4663: LD_INT 1
4665: DEC
4666: ST_TO_ADDR
4667: LD_INT 6
4669: PUSH
4670: FOR_TO
4671: IFFALSE 4713
// begin PrepareMechanic ( 0 , game_eskill ) ;
4673: LD_INT 0
4675: PPUSH
4676: LD_EXP 39
4680: PPUSH
4681: CALL_OW 383
// un := CreateHuman ;
4685: LD_ADDR_VAR 0 4
4689: PUSH
4690: CALL_OW 44
4694: ST_TO_ADDR
// filter := filter ^ un ;
4695: LD_ADDR_VAR 0 3
4699: PUSH
4700: LD_VAR 0 3
4704: PUSH
4705: LD_VAR 0 4
4709: ADD
4710: ST_TO_ADDR
// end ;
4711: GO 4670
4713: POP
4714: POP
// for i = 1 to 4 do
4715: LD_ADDR_VAR 0 2
4719: PUSH
4720: DOUBLE
4721: LD_INT 1
4723: DEC
4724: ST_TO_ADDR
4725: LD_INT 4
4727: PUSH
4728: FOR_TO
4729: IFFALSE 4771
// begin PrepareScientist ( 0 , game_eskill ) ;
4731: LD_INT 0
4733: PPUSH
4734: LD_EXP 39
4738: PPUSH
4739: CALL_OW 384
// un := CreateHuman ;
4743: LD_ADDR_VAR 0 4
4747: PUSH
4748: CALL_OW 44
4752: ST_TO_ADDR
// filter := filter ^ un ;
4753: LD_ADDR_VAR 0 3
4757: PUSH
4758: LD_VAR 0 3
4762: PUSH
4763: LD_VAR 0 4
4767: ADD
4768: ST_TO_ADDR
// end ;
4769: GO 4728
4771: POP
4772: POP
// for i = 1 to filter do
4773: LD_ADDR_VAR 0 2
4777: PUSH
4778: DOUBLE
4779: LD_INT 1
4781: DEC
4782: ST_TO_ADDR
4783: LD_VAR 0 3
4787: PUSH
4788: FOR_TO
4789: IFFALSE 4814
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4791: LD_VAR 0 3
4795: PUSH
4796: LD_VAR 0 2
4800: ARRAY
4801: PPUSH
4802: LD_INT 6
4804: PPUSH
4805: LD_INT 0
4807: PPUSH
4808: CALL_OW 49
4812: GO 4788
4814: POP
4815: POP
// RU_SecondPersonnel := filter ;
4816: LD_ADDR_EXP 35
4820: PUSH
4821: LD_VAR 0 3
4825: ST_TO_ADDR
// end ;
4826: LD_VAR 0 1
4830: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
4831: LD_INT 0
4833: PPUSH
4834: PPUSH
4835: PPUSH
4836: PPUSH
4837: PPUSH
4838: PPUSH
4839: PPUSH
// uc_side := 1 ;
4840: LD_ADDR_OWVAR 20
4844: PUSH
4845: LD_INT 1
4847: ST_TO_ADDR
// uc_nation := nation_american ;
4848: LD_ADDR_OWVAR 21
4852: PUSH
4853: LD_INT 1
4855: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
4856: LD_ADDR_EXP 36
4860: PUSH
4861: LD_STRING JMM
4863: PPUSH
4864: CALL_OW 25
4868: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
4869: LD_EXP 36
4873: PPUSH
4874: LD_INT 1
4876: PPUSH
4877: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
4881: LD_EXP 36
4885: PPUSH
4886: LD_INT 7
4888: PPUSH
4889: LD_INT 0
4891: PPUSH
4892: CALL_OW 49
// mechs := [ ] ;
4896: LD_ADDR_VAR 0 7
4900: PUSH
4901: EMPTY
4902: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
4903: LD_ADDR_VAR 0 2
4907: PUSH
4908: DOUBLE
4909: LD_INT 1
4911: DEC
4912: ST_TO_ADDR
4913: LD_INT 4
4915: PUSH
4916: LD_INT 3
4918: PUSH
4919: LD_INT 3
4921: PUSH
4922: EMPTY
4923: LIST
4924: LIST
4925: LIST
4926: PUSH
4927: LD_OWVAR 67
4931: ARRAY
4932: PUSH
4933: FOR_TO
4934: IFFALSE 4995
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
4936: LD_INT 0
4938: PPUSH
4939: LD_EXP 38
4943: PUSH
4944: LD_INT 1
4946: PLUS
4947: PPUSH
4948: CALL_OW 381
// un := CreateHuman ;
4952: LD_ADDR_VAR 0 4
4956: PUSH
4957: CALL_OW 44
4961: ST_TO_ADDR
// soldiers := soldiers ^ un ;
4962: LD_ADDR_VAR 0 3
4966: PUSH
4967: LD_VAR 0 3
4971: PUSH
4972: LD_VAR 0 4
4976: ADD
4977: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
4978: LD_VAR 0 4
4982: PPUSH
4983: LD_INT 7
4985: PPUSH
4986: LD_INT 0
4988: PPUSH
4989: CALL_OW 49
// end ;
4993: GO 4933
4995: POP
4996: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
4997: LD_ADDR_VAR 0 2
5001: PUSH
5002: DOUBLE
5003: LD_INT 1
5005: DEC
5006: ST_TO_ADDR
5007: LD_INT 7
5009: PUSH
5010: LD_INT 6
5012: PUSH
5013: LD_INT 4
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: LIST
5020: PUSH
5021: LD_OWVAR 67
5025: ARRAY
5026: PUSH
5027: FOR_TO
5028: IFFALSE 5074
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5030: LD_INT 0
5032: PPUSH
5033: LD_EXP 38
5037: PUSH
5038: LD_INT 1
5040: PLUS
5041: PPUSH
5042: CALL_OW 383
// un := CreateHuman ;
5046: LD_ADDR_VAR 0 4
5050: PUSH
5051: CALL_OW 44
5055: ST_TO_ADDR
// mechs := mechs ^ un ;
5056: LD_ADDR_VAR 0 7
5060: PUSH
5061: LD_VAR 0 7
5065: PUSH
5066: LD_VAR 0 4
5070: ADD
5071: ST_TO_ADDR
// end ;
5072: GO 5027
5074: POP
5075: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5076: LD_INT 3
5078: PPUSH
5079: LD_INT 3
5081: PPUSH
5082: LD_INT 1
5084: PPUSH
5085: LD_INT 5
5087: PPUSH
5088: LD_INT 100
5090: PPUSH
5091: CALL 18297 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5095: LD_ADDR_VAR 0 2
5099: PUSH
5100: DOUBLE
5101: LD_INT 1
5103: DEC
5104: ST_TO_ADDR
5105: LD_INT 7
5107: PUSH
5108: LD_INT 6
5110: PUSH
5111: LD_INT 4
5113: PUSH
5114: EMPTY
5115: LIST
5116: LIST
5117: LIST
5118: PUSH
5119: LD_OWVAR 67
5123: ARRAY
5124: PUSH
5125: FOR_TO
5126: IFFALSE 5221
// begin vehicle := CreateVehicle ;
5128: LD_ADDR_VAR 0 6
5132: PUSH
5133: CALL_OW 45
5137: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5138: LD_VAR 0 7
5142: PUSH
5143: LD_INT 1
5145: ARRAY
5146: PPUSH
5147: LD_VAR 0 6
5151: PPUSH
5152: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5156: LD_ADDR_VAR 0 7
5160: PUSH
5161: LD_VAR 0 7
5165: PUSH
5166: LD_VAR 0 7
5170: PUSH
5171: LD_INT 1
5173: ARRAY
5174: DIFF
5175: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5176: LD_VAR 0 6
5180: PPUSH
5181: LD_INT 1
5183: PPUSH
5184: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5188: LD_VAR 0 6
5192: PPUSH
5193: LD_INT 7
5195: PPUSH
5196: LD_INT 0
5198: PPUSH
5199: CALL_OW 49
// vehs := vehs ^ vehicle ;
5203: LD_ADDR_VAR 0 5
5207: PUSH
5208: LD_VAR 0 5
5212: PUSH
5213: LD_VAR 0 6
5217: ADD
5218: ST_TO_ADDR
// end ;
5219: GO 5125
5221: POP
5222: POP
// end ; end_of_file
5223: LD_VAR 0 1
5227: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export function GameType ; begin
5228: LD_INT 0
5230: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5231: LD_ADDR_OWVAR 67
5235: PUSH
5236: LD_INT 0
5238: PPUSH
5239: CALL_OW 426
5243: ST_TO_ADDR
// game_diff := Difficulty ;
5244: LD_ADDR_EXP 37
5248: PUSH
5249: LD_OWVAR 67
5253: ST_TO_ADDR
// game_skill := [ 7 , 6 , 6 ] [ game_diff ] ;
5254: LD_ADDR_EXP 38
5258: PUSH
5259: LD_INT 7
5261: PUSH
5262: LD_INT 6
5264: PUSH
5265: LD_INT 6
5267: PUSH
5268: EMPTY
5269: LIST
5270: LIST
5271: LIST
5272: PUSH
5273: LD_EXP 37
5277: ARRAY
5278: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5279: LD_ADDR_EXP 39
5283: PUSH
5284: LD_INT 6
5286: PUSH
5287: LD_INT 7
5289: PUSH
5290: LD_INT 8
5292: PUSH
5293: EMPTY
5294: LIST
5295: LIST
5296: LIST
5297: PUSH
5298: LD_EXP 37
5302: ARRAY
5303: ST_TO_ADDR
// ruArrival := [ 5 5$00 , 3 3$00 , 2 2$00 ] [ game_diff ] ;
5304: LD_ADDR_EXP 41
5308: PUSH
5309: LD_INT 10500
5311: PUSH
5312: LD_INT 6300
5314: PUSH
5315: LD_INT 4200
5317: PUSH
5318: EMPTY
5319: LIST
5320: LIST
5321: LIST
5322: PUSH
5323: LD_EXP 37
5327: ARRAY
5328: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5329: LD_ADDR_EXP 40
5333: PUSH
5334: LD_INT 73500
5336: PUSH
5337: LD_INT 94500
5339: PUSH
5340: LD_INT 115500
5342: PUSH
5343: EMPTY
5344: LIST
5345: LIST
5346: LIST
5347: PUSH
5348: LD_EXP 37
5352: ARRAY
5353: ST_TO_ADDR
// end ; end_of_file
5354: LD_VAR 0 1
5358: RET
// export function CustomEvent ( event ) ; begin
5359: LD_INT 0
5361: PPUSH
// end ;
5362: LD_VAR 0 2
5366: RET
// export function CustomInitMacro ( ) ; begin
5367: LD_INT 0
5369: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5370: LD_INT 1
5372: PPUSH
5373: LD_INT 3
5375: PPUSH
5376: CALL 79366 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5380: LD_INT 1
5382: PPUSH
5383: LD_INT 4
5385: PPUSH
5386: CALL 79310 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5390: LD_INT 1
5392: PPUSH
5393: LD_INT 136
5395: PUSH
5396: LD_INT 130
5398: PUSH
5399: LD_INT 0
5401: PUSH
5402: EMPTY
5403: LIST
5404: LIST
5405: LIST
5406: PUSH
5407: LD_INT 145
5409: PUSH
5410: LD_INT 123
5412: PUSH
5413: LD_INT 0
5415: PUSH
5416: EMPTY
5417: LIST
5418: LIST
5419: LIST
5420: PUSH
5421: EMPTY
5422: LIST
5423: LIST
5424: PPUSH
5425: CALL 78369 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5429: LD_INT 1
5431: PPUSH
5432: LD_INT 43
5434: PUSH
5435: LD_INT 46
5437: PUSH
5438: LD_INT 45
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: LIST
5445: PPUSH
5446: CALL 79198 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5450: LD_INT 1
5452: PPUSH
5453: LD_INT 3
5455: PPUSH
5456: CALL 78880 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5460: LD_INT 1
5462: PPUSH
5463: LD_INT 3
5465: PPUSH
5466: CALL 78611 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5470: LD_INT 1
5472: PPUSH
5473: LD_INT 8
5475: PPUSH
5476: CALL 78230 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5480: LD_INT 1
5482: PPUSH
5483: LD_INT 22
5485: PUSH
5486: LD_INT 1
5488: PUSH
5489: LD_INT 3
5491: PUSH
5492: LD_INT 43
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: LIST
5499: LIST
5500: PUSH
5501: LD_INT 22
5503: PUSH
5504: LD_INT 1
5506: PUSH
5507: LD_INT 3
5509: PUSH
5510: LD_INT 44
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 22
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: LD_INT 3
5527: PUSH
5528: LD_INT 45
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: LIST
5536: PUSH
5537: LD_INT 24
5539: PUSH
5540: LD_INT 1
5542: PUSH
5543: LD_INT 3
5545: PUSH
5546: LD_INT 43
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: PUSH
5555: LD_INT 24
5557: PUSH
5558: LD_INT 1
5560: PUSH
5561: LD_INT 3
5563: PUSH
5564: LD_INT 43
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: LIST
5571: LIST
5572: PUSH
5573: LD_INT 24
5575: PUSH
5576: LD_INT 1
5578: PUSH
5579: LD_INT 3
5581: PUSH
5582: LD_INT 46
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: LIST
5589: LIST
5590: PUSH
5591: LD_INT 22
5593: PUSH
5594: LD_INT 1
5596: PUSH
5597: LD_INT 3
5599: PUSH
5600: LD_INT 43
5602: PUSH
5603: EMPTY
5604: LIST
5605: LIST
5606: LIST
5607: LIST
5608: PUSH
5609: LD_INT 22
5611: PUSH
5612: LD_INT 1
5614: PUSH
5615: LD_INT 3
5617: PUSH
5618: LD_INT 44
5620: PUSH
5621: EMPTY
5622: LIST
5623: LIST
5624: LIST
5625: LIST
5626: PUSH
5627: EMPTY
5628: LIST
5629: LIST
5630: LIST
5631: LIST
5632: LIST
5633: LIST
5634: LIST
5635: LIST
5636: PPUSH
5637: CALL 78045 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
5641: LD_INT 1
5643: PPUSH
5644: LD_INT 0
5646: PUSH
5647: LD_INT 127
5649: PUSH
5650: LD_INT 125
5652: PUSH
5653: LD_INT 5
5655: PUSH
5656: EMPTY
5657: LIST
5658: LIST
5659: LIST
5660: LIST
5661: PUSH
5662: LD_INT 6
5664: PUSH
5665: LD_INT 124
5667: PUSH
5668: LD_INT 132
5670: PUSH
5671: LD_INT 0
5673: PUSH
5674: EMPTY
5675: LIST
5676: LIST
5677: LIST
5678: LIST
5679: PUSH
5680: LD_INT 29
5682: PUSH
5683: LD_INT 136
5685: PUSH
5686: LD_INT 130
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: EMPTY
5693: LIST
5694: LIST
5695: LIST
5696: LIST
5697: PUSH
5698: LD_INT 4
5700: PUSH
5701: LD_INT 118
5703: PUSH
5704: LD_INT 114
5706: PUSH
5707: LD_INT 2
5709: PUSH
5710: EMPTY
5711: LIST
5712: LIST
5713: LIST
5714: LIST
5715: PUSH
5716: LD_INT 29
5718: PUSH
5719: LD_INT 145
5721: PUSH
5722: LD_INT 123
5724: PUSH
5725: LD_INT 1
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: LIST
5733: PUSH
5734: LD_INT 26
5736: PUSH
5737: LD_INT 150
5739: PUSH
5740: LD_INT 135
5742: PUSH
5743: LD_INT 1
5745: PUSH
5746: EMPTY
5747: LIST
5748: LIST
5749: LIST
5750: LIST
5751: PUSH
5752: LD_INT 26
5754: PUSH
5755: LD_INT 140
5757: PUSH
5758: LD_INT 134
5760: PUSH
5761: LD_INT 2
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: LIST
5768: LIST
5769: PUSH
5770: LD_INT 26
5772: PUSH
5773: LD_INT 137
5775: PUSH
5776: LD_INT 121
5778: PUSH
5779: LD_INT 5
5781: PUSH
5782: EMPTY
5783: LIST
5784: LIST
5785: LIST
5786: LIST
5787: PUSH
5788: LD_INT 2
5790: PUSH
5791: LD_INT 155
5793: PUSH
5794: LD_INT 130
5796: PUSH
5797: LD_INT 0
5799: PUSH
5800: EMPTY
5801: LIST
5802: LIST
5803: LIST
5804: LIST
5805: PUSH
5806: LD_INT 32
5808: PUSH
5809: LD_INT 155
5811: PUSH
5812: LD_INT 130
5814: PUSH
5815: LD_INT 0
5817: PUSH
5818: EMPTY
5819: LIST
5820: LIST
5821: LIST
5822: LIST
5823: PUSH
5824: LD_INT 32
5826: PUSH
5827: LD_INT 130
5829: PUSH
5830: LD_INT 114
5832: PUSH
5833: LD_INT 3
5835: PUSH
5836: EMPTY
5837: LIST
5838: LIST
5839: LIST
5840: LIST
5841: PUSH
5842: LD_INT 32
5844: PUSH
5845: LD_INT 142
5847: PUSH
5848: LD_INT 115
5850: PUSH
5851: LD_INT 3
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: LIST
5858: LIST
5859: PUSH
5860: LD_INT 32
5862: PUSH
5863: LD_INT 153
5865: PUSH
5866: LD_INT 120
5868: PUSH
5869: LD_INT 3
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: LIST
5876: LIST
5877: PUSH
5878: EMPTY
5879: LIST
5880: LIST
5881: LIST
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: LIST
5887: LIST
5888: LIST
5889: LIST
5890: LIST
5891: LIST
5892: PPUSH
5893: CALL 77937 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
5897: LD_INT 1
5899: PPUSH
5900: LD_INT 10
5902: PUSH
5903: LD_INT 12
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: PPUSH
5910: CALL 78787 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
5914: LD_INT 1
5916: PPUSH
5917: LD_INT 155
5919: PPUSH
5920: LD_INT 130
5922: PPUSH
5923: LD_INT 0
5925: PPUSH
5926: LD_INT 24
5928: PUSH
5929: LD_INT 16
5931: PUSH
5932: LD_INT 17
5934: PUSH
5935: LD_INT 18
5937: PUSH
5938: LD_INT 21
5940: PUSH
5941: EMPTY
5942: LIST
5943: LIST
5944: LIST
5945: LIST
5946: LIST
5947: PPUSH
5948: CALL 78992 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
5952: LD_INT 2
5954: PPUSH
5955: LD_INT 3
5957: PPUSH
5958: CALL 79366 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
5962: LD_INT 2
5964: PPUSH
5965: LD_INT 4
5967: PPUSH
5968: CALL 79310 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
5972: LD_INT 2
5974: PPUSH
5975: LD_INT 84
5977: PUSH
5978: LD_INT 125
5980: PUSH
5981: LD_INT 1
5983: PUSH
5984: EMPTY
5985: LIST
5986: LIST
5987: LIST
5988: PUSH
5989: EMPTY
5990: LIST
5991: PPUSH
5992: CALL 78369 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5996: LD_INT 2
5998: PPUSH
5999: LD_INT 43
6001: PUSH
6002: LD_INT 46
6004: PUSH
6005: LD_INT 45
6007: PUSH
6008: EMPTY
6009: LIST
6010: LIST
6011: LIST
6012: PPUSH
6013: CALL 79198 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
6017: LD_INT 2
6019: PPUSH
6020: LD_INT 3
6022: PPUSH
6023: CALL 78880 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6027: LD_INT 2
6029: PPUSH
6030: LD_INT 3
6032: PPUSH
6033: CALL 78611 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6037: LD_INT 2
6039: PPUSH
6040: LD_INT 8
6042: PPUSH
6043: CALL 78230 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6047: LD_INT 2
6049: PPUSH
6050: LD_INT 22
6052: PUSH
6053: LD_INT 3
6055: PUSH
6056: LD_INT 3
6058: PUSH
6059: LD_INT 43
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: PUSH
6068: LD_INT 22
6070: PUSH
6071: LD_INT 3
6073: PUSH
6074: LD_INT 3
6076: PUSH
6077: LD_INT 44
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: LIST
6084: LIST
6085: PUSH
6086: LD_INT 22
6088: PUSH
6089: LD_INT 3
6091: PUSH
6092: LD_INT 3
6094: PUSH
6095: LD_INT 45
6097: PUSH
6098: EMPTY
6099: LIST
6100: LIST
6101: LIST
6102: LIST
6103: PUSH
6104: LD_INT 24
6106: PUSH
6107: LD_INT 3
6109: PUSH
6110: LD_INT 3
6112: PUSH
6113: LD_INT 43
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: PUSH
6122: LD_INT 24
6124: PUSH
6125: LD_INT 3
6127: PUSH
6128: LD_INT 3
6130: PUSH
6131: LD_INT 43
6133: PUSH
6134: EMPTY
6135: LIST
6136: LIST
6137: LIST
6138: LIST
6139: PUSH
6140: LD_INT 24
6142: PUSH
6143: LD_INT 3
6145: PUSH
6146: LD_INT 3
6148: PUSH
6149: LD_INT 46
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: LIST
6156: LIST
6157: PUSH
6158: LD_INT 22
6160: PUSH
6161: LD_INT 3
6163: PUSH
6164: LD_INT 3
6166: PUSH
6167: LD_INT 43
6169: PUSH
6170: EMPTY
6171: LIST
6172: LIST
6173: LIST
6174: LIST
6175: PUSH
6176: LD_INT 22
6178: PUSH
6179: LD_INT 3
6181: PUSH
6182: LD_INT 3
6184: PUSH
6185: LD_INT 44
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: LIST
6192: LIST
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: LIST
6202: LIST
6203: PPUSH
6204: CALL 78045 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6208: LD_INT 2
6210: PPUSH
6211: LD_INT 0
6213: PUSH
6214: LD_INT 96
6216: PUSH
6217: LD_INT 125
6219: PUSH
6220: LD_INT 0
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: LIST
6227: LIST
6228: PUSH
6229: LD_INT 6
6231: PUSH
6232: LD_INT 74
6234: PUSH
6235: LD_INT 122
6237: PUSH
6238: LD_INT 1
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: LIST
6245: LIST
6246: PUSH
6247: LD_INT 30
6249: PUSH
6250: LD_INT 84
6252: PUSH
6253: LD_INT 125
6255: PUSH
6256: LD_INT 1
6258: PUSH
6259: EMPTY
6260: LIST
6261: LIST
6262: LIST
6263: LIST
6264: PUSH
6265: LD_INT 28
6267: PUSH
6268: LD_INT 86
6270: PUSH
6271: LD_INT 128
6273: PUSH
6274: LD_INT 1
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: LIST
6281: LIST
6282: PUSH
6283: LD_INT 28
6285: PUSH
6286: LD_INT 85
6288: PUSH
6289: LD_INT 130
6291: PUSH
6292: LD_INT 2
6294: PUSH
6295: EMPTY
6296: LIST
6297: LIST
6298: LIST
6299: LIST
6300: PUSH
6301: LD_INT 28
6303: PUSH
6304: LD_INT 88
6306: PUSH
6307: LD_INT 132
6309: PUSH
6310: LD_INT 5
6312: PUSH
6313: EMPTY
6314: LIST
6315: LIST
6316: LIST
6317: LIST
6318: PUSH
6319: LD_INT 2
6321: PUSH
6322: LD_INT 106
6324: PUSH
6325: LD_INT 130
6327: PUSH
6328: LD_INT 0
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: PUSH
6337: LD_INT 4
6339: PUSH
6340: LD_INT 99
6342: PUSH
6343: LD_INT 114
6345: PUSH
6346: LD_INT 3
6348: PUSH
6349: EMPTY
6350: LIST
6351: LIST
6352: LIST
6353: LIST
6354: PUSH
6355: LD_INT 32
6357: PUSH
6358: LD_INT 72
6360: PUSH
6361: LD_INT 112
6363: PUSH
6364: LD_INT 2
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: LIST
6371: LIST
6372: PUSH
6373: LD_INT 32
6375: PUSH
6376: LD_INT 78
6378: PUSH
6379: LD_INT 110
6381: PUSH
6382: LD_INT 3
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: LIST
6389: LIST
6390: PUSH
6391: LD_INT 32
6393: PUSH
6394: LD_INT 84
6396: PUSH
6397: LD_INT 110
6399: PUSH
6400: LD_INT 2
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: PUSH
6409: LD_INT 32
6411: PUSH
6412: LD_INT 105
6414: PUSH
6415: LD_INT 117
6417: PUSH
6418: LD_INT 3
6420: PUSH
6421: EMPTY
6422: LIST
6423: LIST
6424: LIST
6425: LIST
6426: PUSH
6427: EMPTY
6428: LIST
6429: LIST
6430: LIST
6431: LIST
6432: LIST
6433: LIST
6434: LIST
6435: LIST
6436: LIST
6437: LIST
6438: LIST
6439: LIST
6440: PPUSH
6441: CALL 77937 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6445: LD_INT 2
6447: PPUSH
6448: LD_INT 14
6450: PUSH
6451: LD_INT 11
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: PPUSH
6458: CALL 78787 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6462: LD_INT 2
6464: PPUSH
6465: LD_INT 106
6467: PPUSH
6468: LD_INT 130
6470: PPUSH
6471: LD_INT 0
6473: PPUSH
6474: LD_INT 24
6476: PUSH
6477: LD_INT 16
6479: PUSH
6480: LD_INT 17
6482: PUSH
6483: LD_INT 18
6485: PUSH
6486: LD_INT 21
6488: PUSH
6489: EMPTY
6490: LIST
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: PPUSH
6496: CALL 78992 0 5
// end ;
6500: LD_VAR 0 1
6504: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6505: LD_INT 22
6507: PUSH
6508: LD_INT 3
6510: PUSH
6511: EMPTY
6512: LIST
6513: LIST
6514: PUSH
6515: LD_INT 30
6517: PUSH
6518: LD_INT 3
6520: PUSH
6521: EMPTY
6522: LIST
6523: LIST
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: PPUSH
6529: CALL_OW 69
6533: IFFALSE 7389
6535: GO 6537
6537: DISABLE
6538: LD_INT 0
6540: PPUSH
6541: PPUSH
6542: PPUSH
6543: PPUSH
6544: PPUSH
6545: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
6546: LD_INT 6300
6548: PUSH
6549: LD_INT 4200
6551: PUSH
6552: LD_INT 2100
6554: PUSH
6555: EMPTY
6556: LIST
6557: LIST
6558: LIST
6559: PUSH
6560: LD_OWVAR 67
6564: ARRAY
6565: PPUSH
6566: CALL_OW 67
// base := 2 ;
6570: LD_ADDR_VAR 0 2
6574: PUSH
6575: LD_INT 2
6577: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
6578: LD_INT 22
6580: PUSH
6581: LD_INT 3
6583: PUSH
6584: EMPTY
6585: LIST
6586: LIST
6587: PUSH
6588: LD_INT 30
6590: PUSH
6591: LD_INT 3
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: PUSH
6598: EMPTY
6599: LIST
6600: LIST
6601: PPUSH
6602: CALL_OW 69
6606: NOT
6607: IFFALSE 6611
// continue ;
6609: GO 6546
// case Rand ( 1 , 3 ) of 1 :
6611: LD_INT 1
6613: PPUSH
6614: LD_INT 3
6616: PPUSH
6617: CALL_OW 12
6621: PUSH
6622: LD_INT 1
6624: DOUBLE
6625: EQUAL
6626: IFTRUE 6630
6628: GO 6806
6630: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
6631: LD_ADDR_VAR 0 3
6635: PUSH
6636: LD_INT 22
6638: PUSH
6639: LD_INT 3
6641: PUSH
6642: LD_INT 3
6644: PUSH
6645: LD_INT 43
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 24
6656: PUSH
6657: LD_INT 3
6659: PUSH
6660: LD_INT 3
6662: PUSH
6663: LD_INT 46
6665: PUSH
6666: EMPTY
6667: LIST
6668: LIST
6669: LIST
6670: LIST
6671: PUSH
6672: LD_INT 24
6674: PUSH
6675: LD_INT 3
6677: PUSH
6678: LD_INT 3
6680: PUSH
6681: LD_INT 43
6683: PUSH
6684: EMPTY
6685: LIST
6686: LIST
6687: LIST
6688: LIST
6689: PUSH
6690: LD_INT 24
6692: PUSH
6693: LD_INT 3
6695: PUSH
6696: LD_INT 3
6698: PUSH
6699: LD_INT 46
6701: PUSH
6702: EMPTY
6703: LIST
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: LD_INT 22
6710: PUSH
6711: LD_INT 3
6713: PUSH
6714: LD_INT 3
6716: PUSH
6717: LD_INT 45
6719: PUSH
6720: EMPTY
6721: LIST
6722: LIST
6723: LIST
6724: LIST
6725: PUSH
6726: LD_INT 22
6728: PUSH
6729: LD_INT 3
6731: PUSH
6732: LD_INT 3
6734: PUSH
6735: LD_INT 43
6737: PUSH
6738: EMPTY
6739: LIST
6740: LIST
6741: LIST
6742: LIST
6743: PUSH
6744: LD_INT 24
6746: PUSH
6747: LD_INT 3
6749: PUSH
6750: LD_INT 3
6752: PUSH
6753: LD_INT 46
6755: PUSH
6756: EMPTY
6757: LIST
6758: LIST
6759: LIST
6760: LIST
6761: PUSH
6762: LD_INT 22
6764: PUSH
6765: LD_INT 3
6767: PUSH
6768: LD_INT 3
6770: PUSH
6771: LD_INT 45
6773: PUSH
6774: EMPTY
6775: LIST
6776: LIST
6777: LIST
6778: LIST
6779: PUSH
6780: EMPTY
6781: LIST
6782: LIST
6783: LIST
6784: LIST
6785: LIST
6786: LIST
6787: LIST
6788: LIST
6789: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6790: LD_VAR 0 2
6794: PPUSH
6795: LD_VAR 0 3
6799: PPUSH
6800: CALL 78093 0 2
// end ; 2 :
6804: GO 7137
6806: LD_INT 2
6808: DOUBLE
6809: EQUAL
6810: IFTRUE 6814
6812: GO 6952
6814: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
6815: LD_ADDR_VAR 0 3
6819: PUSH
6820: LD_INT 24
6822: PUSH
6823: LD_INT 3
6825: PUSH
6826: LD_INT 3
6828: PUSH
6829: LD_INT 43
6831: PUSH
6832: EMPTY
6833: LIST
6834: LIST
6835: LIST
6836: LIST
6837: PUSH
6838: LD_INT 24
6840: PUSH
6841: LD_INT 3
6843: PUSH
6844: LD_INT 3
6846: PUSH
6847: LD_INT 46
6849: PUSH
6850: EMPTY
6851: LIST
6852: LIST
6853: LIST
6854: LIST
6855: PUSH
6856: LD_INT 24
6858: PUSH
6859: LD_INT 3
6861: PUSH
6862: LD_INT 3
6864: PUSH
6865: LD_INT 43
6867: PUSH
6868: EMPTY
6869: LIST
6870: LIST
6871: LIST
6872: LIST
6873: PUSH
6874: LD_INT 24
6876: PUSH
6877: LD_INT 3
6879: PUSH
6880: LD_INT 3
6882: PUSH
6883: LD_INT 46
6885: PUSH
6886: EMPTY
6887: LIST
6888: LIST
6889: LIST
6890: LIST
6891: PUSH
6892: LD_INT 22
6894: PUSH
6895: LD_INT 3
6897: PUSH
6898: LD_INT 3
6900: PUSH
6901: LD_INT 45
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: LIST
6908: LIST
6909: PUSH
6910: LD_INT 22
6912: PUSH
6913: LD_INT 3
6915: PUSH
6916: LD_INT 3
6918: PUSH
6919: LD_INT 45
6921: PUSH
6922: EMPTY
6923: LIST
6924: LIST
6925: LIST
6926: LIST
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6936: LD_VAR 0 2
6940: PPUSH
6941: LD_VAR 0 3
6945: PPUSH
6946: CALL 78093 0 2
// end ; 3 :
6950: GO 7137
6952: LD_INT 3
6954: DOUBLE
6955: EQUAL
6956: IFTRUE 6960
6958: GO 7136
6960: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
6961: LD_ADDR_VAR 0 3
6965: PUSH
6966: LD_INT 22
6968: PUSH
6969: LD_INT 3
6971: PUSH
6972: LD_INT 3
6974: PUSH
6975: LD_INT 43
6977: PUSH
6978: EMPTY
6979: LIST
6980: LIST
6981: LIST
6982: LIST
6983: PUSH
6984: LD_INT 24
6986: PUSH
6987: LD_INT 3
6989: PUSH
6990: LD_INT 3
6992: PUSH
6993: LD_INT 46
6995: PUSH
6996: EMPTY
6997: LIST
6998: LIST
6999: LIST
7000: LIST
7001: PUSH
7002: LD_INT 22
7004: PUSH
7005: LD_INT 3
7007: PUSH
7008: LD_INT 3
7010: PUSH
7011: LD_INT 43
7013: PUSH
7014: EMPTY
7015: LIST
7016: LIST
7017: LIST
7018: LIST
7019: PUSH
7020: LD_INT 24
7022: PUSH
7023: LD_INT 3
7025: PUSH
7026: LD_INT 3
7028: PUSH
7029: LD_INT 46
7031: PUSH
7032: EMPTY
7033: LIST
7034: LIST
7035: LIST
7036: LIST
7037: PUSH
7038: LD_INT 22
7040: PUSH
7041: LD_INT 3
7043: PUSH
7044: LD_INT 3
7046: PUSH
7047: LD_INT 45
7049: PUSH
7050: EMPTY
7051: LIST
7052: LIST
7053: LIST
7054: LIST
7055: PUSH
7056: LD_INT 22
7058: PUSH
7059: LD_INT 3
7061: PUSH
7062: LD_INT 3
7064: PUSH
7065: LD_INT 43
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: LIST
7072: LIST
7073: PUSH
7074: LD_INT 24
7076: PUSH
7077: LD_INT 3
7079: PUSH
7080: LD_INT 3
7082: PUSH
7083: LD_INT 46
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: LIST
7090: LIST
7091: PUSH
7092: LD_INT 22
7094: PUSH
7095: LD_INT 3
7097: PUSH
7098: LD_INT 3
7100: PUSH
7101: LD_INT 45
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: LIST
7108: LIST
7109: PUSH
7110: EMPTY
7111: LIST
7112: LIST
7113: LIST
7114: LIST
7115: LIST
7116: LIST
7117: LIST
7118: LIST
7119: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7120: LD_VAR 0 2
7124: PPUSH
7125: LD_VAR 0 3
7129: PPUSH
7130: CALL 78093 0 2
// end ; end ;
7134: GO 7137
7136: POP
// repeat wait ( 0 0$1 ) ;
7137: LD_INT 35
7139: PPUSH
7140: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7144: LD_VAR 0 2
7148: PPUSH
7149: CALL 78441 0 1
7153: PUSH
7154: LD_INT 0
7156: EQUAL
7157: IFFALSE 7137
// wait ( 0 0$30 ) ;
7159: LD_INT 1050
7161: PPUSH
7162: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7166: LD_ADDR_VAR 0 5
7170: PUSH
7171: LD_INT 86
7173: PUSH
7174: LD_INT 77
7176: PUSH
7177: EMPTY
7178: LIST
7179: LIST
7180: PUSH
7181: LD_INT 63
7183: PUSH
7184: LD_INT 38
7186: PUSH
7187: EMPTY
7188: LIST
7189: LIST
7190: PUSH
7191: EMPTY
7192: LIST
7193: LIST
7194: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7195: LD_ADDR_VAR 0 4
7199: PUSH
7200: LD_INT 0
7202: PUSH
7203: LD_INT 0
7205: PUSH
7206: LD_INT 0
7208: PUSH
7209: LD_INT 1
7211: PUSH
7212: LD_INT 0
7214: PUSH
7215: LD_INT 0
7217: PUSH
7218: LD_INT 0
7220: PUSH
7221: LD_INT 0
7223: PUSH
7224: LD_INT 1
7226: PUSH
7227: LD_INT 0
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: LIST
7234: LIST
7235: LIST
7236: LIST
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7242: LD_ADDR_VAR 0 6
7246: PUSH
7247: LD_EXP 71
7251: PUSH
7252: LD_VAR 0 2
7256: ARRAY
7257: PUSH
7258: LD_EXP 74
7262: PUSH
7263: LD_VAR 0 2
7267: ARRAY
7268: DIFF
7269: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7270: LD_ADDR_EXP 71
7274: PUSH
7275: LD_EXP 71
7279: PPUSH
7280: LD_VAR 0 2
7284: PPUSH
7285: LD_EXP 71
7289: PUSH
7290: LD_VAR 0 2
7294: ARRAY
7295: PUSH
7296: LD_VAR 0 6
7300: DIFF
7301: PPUSH
7302: CALL_OW 1
7306: ST_TO_ADDR
// if not attackers then
7307: LD_VAR 0 6
7311: NOT
7312: IFFALSE 7316
// continue ;
7314: GO 6546
// repeat wait ( 0 0$1 ) ;
7316: LD_INT 35
7318: PPUSH
7319: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7323: LD_VAR 0 6
7327: PPUSH
7328: LD_INT 60
7330: PUSH
7331: EMPTY
7332: LIST
7333: PPUSH
7334: CALL_OW 72
7338: NOT
7339: IFFALSE 7316
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
7341: LD_VAR 0 2
7345: PPUSH
7346: LD_VAR 0 6
7350: PPUSH
7351: LD_VAR 0 5
7355: PPUSH
7356: LD_VAR 0 4
7360: PPUSH
7361: CALL 78278 0 4
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
7365: LD_EXP 52
7369: PUSH
7370: LD_VAR 0 2
7374: ARRAY
7375: PPUSH
7376: LD_INT 50
7378: PUSH
7379: EMPTY
7380: LIST
7381: PPUSH
7382: CALL_OW 72
7386: NOT
7387: IFFALSE 6546
// end ;
7389: PPOPN 6
7391: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
7392: LD_INT 22
7394: PUSH
7395: LD_INT 3
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: PUSH
7402: LD_INT 30
7404: PUSH
7405: LD_INT 3
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: PUSH
7412: EMPTY
7413: LIST
7414: LIST
7415: PPUSH
7416: CALL_OW 69
7420: IFFALSE 8317
7422: GO 7424
7424: DISABLE
7425: LD_INT 0
7427: PPUSH
7428: PPUSH
7429: PPUSH
7430: PPUSH
7431: PPUSH
7432: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
7433: LD_INT 6300
7435: PUSH
7436: LD_INT 4200
7438: PUSH
7439: LD_INT 2100
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: PUSH
7447: LD_OWVAR 67
7451: ARRAY
7452: PPUSH
7453: CALL_OW 67
// base := 1 ;
7457: LD_ADDR_VAR 0 2
7461: PUSH
7462: LD_INT 1
7464: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
7465: LD_INT 22
7467: PUSH
7468: LD_INT 3
7470: PUSH
7471: EMPTY
7472: LIST
7473: LIST
7474: PUSH
7475: LD_INT 30
7477: PUSH
7478: LD_INT 3
7480: PUSH
7481: EMPTY
7482: LIST
7483: LIST
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PPUSH
7489: CALL_OW 69
7493: NOT
7494: IFFALSE 7498
// continue ;
7496: GO 7433
// case Rand ( 1 , 3 ) of 1 :
7498: LD_INT 1
7500: PPUSH
7501: LD_INT 3
7503: PPUSH
7504: CALL_OW 12
7508: PUSH
7509: LD_INT 1
7511: DOUBLE
7512: EQUAL
7513: IFTRUE 7517
7515: GO 7693
7517: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
7518: LD_ADDR_VAR 0 3
7522: PUSH
7523: LD_INT 22
7525: PUSH
7526: LD_INT 1
7528: PUSH
7529: LD_INT 3
7531: PUSH
7532: LD_INT 43
7534: PUSH
7535: EMPTY
7536: LIST
7537: LIST
7538: LIST
7539: LIST
7540: PUSH
7541: LD_INT 24
7543: PUSH
7544: LD_INT 1
7546: PUSH
7547: LD_INT 3
7549: PUSH
7550: LD_INT 46
7552: PUSH
7553: EMPTY
7554: LIST
7555: LIST
7556: LIST
7557: LIST
7558: PUSH
7559: LD_INT 24
7561: PUSH
7562: LD_INT 1
7564: PUSH
7565: LD_INT 3
7567: PUSH
7568: LD_INT 43
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: LIST
7575: LIST
7576: PUSH
7577: LD_INT 24
7579: PUSH
7580: LD_INT 1
7582: PUSH
7583: LD_INT 3
7585: PUSH
7586: LD_INT 46
7588: PUSH
7589: EMPTY
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: PUSH
7595: LD_INT 22
7597: PUSH
7598: LD_INT 1
7600: PUSH
7601: LD_INT 3
7603: PUSH
7604: LD_INT 45
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: PUSH
7613: LD_INT 22
7615: PUSH
7616: LD_INT 1
7618: PUSH
7619: LD_INT 3
7621: PUSH
7622: LD_INT 43
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: LIST
7629: LIST
7630: PUSH
7631: LD_INT 24
7633: PUSH
7634: LD_INT 1
7636: PUSH
7637: LD_INT 3
7639: PUSH
7640: LD_INT 46
7642: PUSH
7643: EMPTY
7644: LIST
7645: LIST
7646: LIST
7647: LIST
7648: PUSH
7649: LD_INT 22
7651: PUSH
7652: LD_INT 1
7654: PUSH
7655: LD_INT 3
7657: PUSH
7658: LD_INT 45
7660: PUSH
7661: EMPTY
7662: LIST
7663: LIST
7664: LIST
7665: LIST
7666: PUSH
7667: EMPTY
7668: LIST
7669: LIST
7670: LIST
7671: LIST
7672: LIST
7673: LIST
7674: LIST
7675: LIST
7676: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7677: LD_VAR 0 2
7681: PPUSH
7682: LD_VAR 0 3
7686: PPUSH
7687: CALL 78093 0 2
// end ; 2 :
7691: GO 8062
7693: LD_INT 2
7695: DOUBLE
7696: EQUAL
7697: IFTRUE 7701
7699: GO 7877
7701: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
7702: LD_ADDR_VAR 0 3
7706: PUSH
7707: LD_INT 24
7709: PUSH
7710: LD_INT 1
7712: PUSH
7713: LD_INT 3
7715: PUSH
7716: LD_INT 43
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 24
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 3
7733: PUSH
7734: LD_INT 46
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: LD_INT 24
7745: PUSH
7746: LD_INT 1
7748: PUSH
7749: LD_INT 3
7751: PUSH
7752: LD_INT 43
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: PUSH
7761: LD_INT 24
7763: PUSH
7764: LD_INT 1
7766: PUSH
7767: LD_INT 3
7769: PUSH
7770: LD_INT 46
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: LIST
7777: LIST
7778: PUSH
7779: LD_INT 22
7781: PUSH
7782: LD_INT 1
7784: PUSH
7785: LD_INT 3
7787: PUSH
7788: LD_INT 45
7790: PUSH
7791: EMPTY
7792: LIST
7793: LIST
7794: LIST
7795: LIST
7796: PUSH
7797: LD_INT 22
7799: PUSH
7800: LD_INT 1
7802: PUSH
7803: LD_INT 3
7805: PUSH
7806: LD_INT 45
7808: PUSH
7809: EMPTY
7810: LIST
7811: LIST
7812: LIST
7813: LIST
7814: PUSH
7815: LD_INT 22
7817: PUSH
7818: LD_INT 1
7820: PUSH
7821: LD_INT 3
7823: PUSH
7824: LD_INT 45
7826: PUSH
7827: EMPTY
7828: LIST
7829: LIST
7830: LIST
7831: LIST
7832: PUSH
7833: LD_INT 22
7835: PUSH
7836: LD_INT 1
7838: PUSH
7839: LD_INT 3
7841: PUSH
7842: LD_INT 45
7844: PUSH
7845: EMPTY
7846: LIST
7847: LIST
7848: LIST
7849: LIST
7850: PUSH
7851: EMPTY
7852: LIST
7853: LIST
7854: LIST
7855: LIST
7856: LIST
7857: LIST
7858: LIST
7859: LIST
7860: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7861: LD_VAR 0 2
7865: PPUSH
7866: LD_VAR 0 3
7870: PPUSH
7871: CALL 78093 0 2
// end ; 3 :
7875: GO 8062
7877: LD_INT 3
7879: DOUBLE
7880: EQUAL
7881: IFTRUE 7885
7883: GO 8061
7885: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
7886: LD_ADDR_VAR 0 3
7890: PUSH
7891: LD_INT 22
7893: PUSH
7894: LD_INT 1
7896: PUSH
7897: LD_INT 3
7899: PUSH
7900: LD_INT 43
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: LIST
7907: LIST
7908: PUSH
7909: LD_INT 24
7911: PUSH
7912: LD_INT 1
7914: PUSH
7915: LD_INT 3
7917: PUSH
7918: LD_INT 46
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: LIST
7925: LIST
7926: PUSH
7927: LD_INT 22
7929: PUSH
7930: LD_INT 1
7932: PUSH
7933: LD_INT 3
7935: PUSH
7936: LD_INT 43
7938: PUSH
7939: EMPTY
7940: LIST
7941: LIST
7942: LIST
7943: LIST
7944: PUSH
7945: LD_INT 24
7947: PUSH
7948: LD_INT 1
7950: PUSH
7951: LD_INT 3
7953: PUSH
7954: LD_INT 46
7956: PUSH
7957: EMPTY
7958: LIST
7959: LIST
7960: LIST
7961: LIST
7962: PUSH
7963: LD_INT 22
7965: PUSH
7966: LD_INT 1
7968: PUSH
7969: LD_INT 3
7971: PUSH
7972: LD_INT 45
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: LIST
7979: LIST
7980: PUSH
7981: LD_INT 22
7983: PUSH
7984: LD_INT 1
7986: PUSH
7987: LD_INT 3
7989: PUSH
7990: LD_INT 43
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: PUSH
7999: LD_INT 24
8001: PUSH
8002: LD_INT 1
8004: PUSH
8005: LD_INT 3
8007: PUSH
8008: LD_INT 46
8010: PUSH
8011: EMPTY
8012: LIST
8013: LIST
8014: LIST
8015: LIST
8016: PUSH
8017: LD_INT 22
8019: PUSH
8020: LD_INT 1
8022: PUSH
8023: LD_INT 3
8025: PUSH
8026: LD_INT 45
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: LIST
8033: LIST
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: LIST
8039: LIST
8040: LIST
8041: LIST
8042: LIST
8043: LIST
8044: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8045: LD_VAR 0 2
8049: PPUSH
8050: LD_VAR 0 3
8054: PPUSH
8055: CALL 78093 0 2
// end ; end ;
8059: GO 8062
8061: POP
// repeat wait ( 0 0$1 ) ;
8062: LD_INT 35
8064: PPUSH
8065: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8069: LD_VAR 0 2
8073: PPUSH
8074: LD_INT 1
8076: PPUSH
8077: CALL 79511 0 2
8081: PUSH
8082: LD_INT 8
8084: GREATEREQUAL
8085: IFFALSE 8062
// wait ( 0 0$30 ) ;
8087: LD_INT 1050
8089: PPUSH
8090: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8094: LD_ADDR_VAR 0 5
8098: PUSH
8099: LD_INT 144
8101: PUSH
8102: LD_INT 65
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: PUSH
8109: LD_INT 63
8111: PUSH
8112: LD_INT 38
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PUSH
8119: EMPTY
8120: LIST
8121: LIST
8122: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8123: LD_ADDR_VAR 0 4
8127: PUSH
8128: LD_INT 0
8130: PUSH
8131: LD_INT 0
8133: PUSH
8134: LD_INT 0
8136: PUSH
8137: LD_INT 1
8139: PUSH
8140: LD_INT 0
8142: PUSH
8143: LD_INT 0
8145: PUSH
8146: LD_INT 0
8148: PUSH
8149: LD_INT 0
8151: PUSH
8152: LD_INT 1
8154: PUSH
8155: LD_INT 0
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: LIST
8162: LIST
8163: LIST
8164: LIST
8165: LIST
8166: LIST
8167: LIST
8168: LIST
8169: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8170: LD_ADDR_VAR 0 6
8174: PUSH
8175: LD_EXP 71
8179: PUSH
8180: LD_VAR 0 2
8184: ARRAY
8185: PUSH
8186: LD_EXP 74
8190: PUSH
8191: LD_VAR 0 2
8195: ARRAY
8196: DIFF
8197: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8198: LD_ADDR_EXP 71
8202: PUSH
8203: LD_EXP 71
8207: PPUSH
8208: LD_VAR 0 2
8212: PPUSH
8213: LD_EXP 71
8217: PUSH
8218: LD_VAR 0 2
8222: ARRAY
8223: PUSH
8224: LD_VAR 0 6
8228: DIFF
8229: PPUSH
8230: CALL_OW 1
8234: ST_TO_ADDR
// if not attackers then
8235: LD_VAR 0 6
8239: NOT
8240: IFFALSE 8244
// continue ;
8242: GO 7433
// repeat wait ( 0 0$1 ) ;
8244: LD_INT 35
8246: PPUSH
8247: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8251: LD_VAR 0 6
8255: PPUSH
8256: LD_INT 60
8258: PUSH
8259: EMPTY
8260: LIST
8261: PPUSH
8262: CALL_OW 72
8266: NOT
8267: IFFALSE 8244
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
8269: LD_VAR 0 2
8273: PPUSH
8274: LD_VAR 0 6
8278: PPUSH
8279: LD_VAR 0 5
8283: PPUSH
8284: LD_VAR 0 4
8288: PPUSH
8289: CALL 78278 0 4
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8293: LD_EXP 52
8297: PUSH
8298: LD_VAR 0 2
8302: ARRAY
8303: PPUSH
8304: LD_INT 50
8306: PUSH
8307: EMPTY
8308: LIST
8309: PPUSH
8310: CALL_OW 72
8314: NOT
8315: IFFALSE 7433
// end ;
8317: PPOPN 6
8319: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
8320: LD_EXP 3
8324: PUSH
8325: LD_INT 22
8327: PUSH
8328: LD_INT 3
8330: PUSH
8331: EMPTY
8332: LIST
8333: LIST
8334: PUSH
8335: LD_INT 21
8337: PUSH
8338: LD_INT 1
8340: PUSH
8341: EMPTY
8342: LIST
8343: LIST
8344: PUSH
8345: EMPTY
8346: LIST
8347: LIST
8348: PPUSH
8349: CALL_OW 69
8353: PUSH
8354: LD_INT 0
8356: EQUAL
8357: AND
8358: IFFALSE 8371
8360: GO 8362
8362: DISABLE
// begin RussiansDefeated := true ;
8363: LD_ADDR_EXP 42
8367: PUSH
8368: LD_INT 1
8370: ST_TO_ADDR
// end ;
8371: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
8372: LD_EXP 3
8376: PUSH
8377: LD_EXP 5
8381: NOT
8382: AND
8383: IFFALSE 9356
8385: GO 8387
8387: DISABLE
8388: LD_INT 0
8390: PPUSH
8391: PPUSH
8392: PPUSH
8393: PPUSH
8394: PPUSH
8395: PPUSH
8396: PPUSH
8397: PPUSH
8398: PPUSH
8399: PPUSH
8400: PPUSH
8401: PPUSH
// begin wait ( [ Rand ( 5 5$00 , 6 6$30 ) , Rand ( 4 4$30 , 5 5$30 ) , Rand ( 4 4$00 , 5 5$00 ) ] [ Difficulty ] ) ;
8402: LD_INT 10500
8404: PPUSH
8405: LD_INT 13650
8407: PPUSH
8408: CALL_OW 12
8412: PUSH
8413: LD_INT 9450
8415: PPUSH
8416: LD_INT 11550
8418: PPUSH
8419: CALL_OW 12
8423: PUSH
8424: LD_INT 8400
8426: PPUSH
8427: LD_INT 10500
8429: PPUSH
8430: CALL_OW 12
8434: PUSH
8435: EMPTY
8436: LIST
8437: LIST
8438: LIST
8439: PUSH
8440: LD_OWVAR 67
8444: ARRAY
8445: PPUSH
8446: CALL_OW 67
// filter := [ ] ;
8450: LD_ADDR_VAR 0 3
8454: PUSH
8455: EMPTY
8456: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
8457: LD_ADDR_VAR 0 4
8461: PUSH
8462: LD_INT 2
8464: PPUSH
8465: LD_INT 3
8467: PPUSH
8468: CALL_OW 12
8472: PUSH
8473: LD_INT 3
8475: PPUSH
8476: LD_INT 4
8478: PPUSH
8479: CALL_OW 12
8483: PUSH
8484: LD_INT 3
8486: PPUSH
8487: LD_INT 5
8489: PPUSH
8490: CALL_OW 12
8494: PUSH
8495: EMPTY
8496: LIST
8497: LIST
8498: LIST
8499: PUSH
8500: LD_OWVAR 67
8504: ARRAY
8505: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
8506: LD_ADDR_VAR 0 5
8510: PUSH
8511: LD_INT 1
8513: PUSH
8514: LD_INT 1
8516: PPUSH
8517: LD_INT 2
8519: PPUSH
8520: CALL_OW 12
8524: PUSH
8525: LD_INT 2
8527: PPUSH
8528: LD_INT 3
8530: PPUSH
8531: CALL_OW 12
8535: PUSH
8536: EMPTY
8537: LIST
8538: LIST
8539: LIST
8540: PUSH
8541: LD_OWVAR 67
8545: ARRAY
8546: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
8547: LD_ADDR_VAR 0 6
8551: PUSH
8552: LD_INT 2
8554: PPUSH
8555: LD_INT 3
8557: PPUSH
8558: CALL_OW 12
8562: PUSH
8563: LD_INT 2
8565: PPUSH
8566: LD_INT 4
8568: PPUSH
8569: CALL_OW 12
8573: PUSH
8574: LD_INT 3
8576: PPUSH
8577: LD_INT 5
8579: PPUSH
8580: CALL_OW 12
8584: PUSH
8585: EMPTY
8586: LIST
8587: LIST
8588: LIST
8589: PUSH
8590: LD_OWVAR 67
8594: ARRAY
8595: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
8596: LD_ADDR_VAR 0 8
8600: PUSH
8601: LD_INT 1
8603: PUSH
8604: LD_INT 2
8606: PUSH
8607: LD_INT 2
8609: PUSH
8610: EMPTY
8611: LIST
8612: LIST
8613: LIST
8614: PUSH
8615: LD_OWVAR 67
8619: ARRAY
8620: ST_TO_ADDR
// uc_side := 3 ;
8621: LD_ADDR_OWVAR 20
8625: PUSH
8626: LD_INT 3
8628: ST_TO_ADDR
// uc_nation := nation_russian ;
8629: LD_ADDR_OWVAR 21
8633: PUSH
8634: LD_INT 3
8636: ST_TO_ADDR
// for i = 1 to soldiers do
8637: LD_ADDR_VAR 0 1
8641: PUSH
8642: DOUBLE
8643: LD_INT 1
8645: DEC
8646: ST_TO_ADDR
8647: LD_VAR 0 4
8651: PUSH
8652: FOR_TO
8653: IFFALSE 8695
// begin PrepareSoldier ( 0 , game_eskill ) ;
8655: LD_INT 0
8657: PPUSH
8658: LD_EXP 39
8662: PPUSH
8663: CALL_OW 381
// un := CreateHuman ;
8667: LD_ADDR_VAR 0 2
8671: PUSH
8672: CALL_OW 44
8676: ST_TO_ADDR
// filter := filter ^ un ;
8677: LD_ADDR_VAR 0 3
8681: PUSH
8682: LD_VAR 0 3
8686: PUSH
8687: LD_VAR 0 2
8691: ADD
8692: ST_TO_ADDR
// end ;
8693: GO 8652
8695: POP
8696: POP
// for i = 1 to bazookas do
8697: LD_ADDR_VAR 0 1
8701: PUSH
8702: DOUBLE
8703: LD_INT 1
8705: DEC
8706: ST_TO_ADDR
8707: LD_VAR 0 5
8711: PUSH
8712: FOR_TO
8713: IFFALSE 8763
// begin PrepareSoldier ( 0 , game_eskill ) ;
8715: LD_INT 0
8717: PPUSH
8718: LD_EXP 39
8722: PPUSH
8723: CALL_OW 381
// hc_class := class_bazooker ;
8727: LD_ADDR_OWVAR 28
8731: PUSH
8732: LD_INT 9
8734: ST_TO_ADDR
// un := CreateHuman ;
8735: LD_ADDR_VAR 0 2
8739: PUSH
8740: CALL_OW 44
8744: ST_TO_ADDR
// filter := filter ^ un ;
8745: LD_ADDR_VAR 0 3
8749: PUSH
8750: LD_VAR 0 3
8754: PUSH
8755: LD_VAR 0 2
8759: ADD
8760: ST_TO_ADDR
// end ;
8761: GO 8712
8763: POP
8764: POP
// for i = 1 to medics do
8765: LD_ADDR_VAR 0 1
8769: PUSH
8770: DOUBLE
8771: LD_INT 1
8773: DEC
8774: ST_TO_ADDR
8775: LD_VAR 0 8
8779: PUSH
8780: FOR_TO
8781: IFFALSE 8823
// begin PrepareScientist ( 0 , game_eskill ) ;
8783: LD_INT 0
8785: PPUSH
8786: LD_EXP 39
8790: PPUSH
8791: CALL_OW 384
// un := CreateHuman ;
8795: LD_ADDR_VAR 0 2
8799: PUSH
8800: CALL_OW 44
8804: ST_TO_ADDR
// filter := filter ^ un ;
8805: LD_ADDR_VAR 0 3
8809: PUSH
8810: LD_VAR 0 3
8814: PUSH
8815: LD_VAR 0 2
8819: ADD
8820: ST_TO_ADDR
// end ;
8821: GO 8780
8823: POP
8824: POP
// for i = 1 to vehs do
8825: LD_ADDR_VAR 0 1
8829: PUSH
8830: DOUBLE
8831: LD_INT 1
8833: DEC
8834: ST_TO_ADDR
8835: LD_VAR 0 6
8839: PUSH
8840: FOR_TO
8841: IFFALSE 9033
// begin case Rand ( 1 , 5 ) of 1 :
8843: LD_INT 1
8845: PPUSH
8846: LD_INT 5
8848: PPUSH
8849: CALL_OW 12
8853: PUSH
8854: LD_INT 1
8856: DOUBLE
8857: EQUAL
8858: IFTRUE 8862
8860: GO 8884
8862: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
8863: LD_INT 22
8865: PPUSH
8866: LD_INT 3
8868: PPUSH
8869: LD_INT 3
8871: PPUSH
8872: LD_INT 43
8874: PPUSH
8875: LD_INT 100
8877: PPUSH
8878: CALL 18297 0 5
8882: GO 9005
8884: LD_INT 2
8886: DOUBLE
8887: EQUAL
8888: IFTRUE 8892
8890: GO 8914
8892: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
8893: LD_INT 22
8895: PPUSH
8896: LD_INT 3
8898: PPUSH
8899: LD_INT 3
8901: PPUSH
8902: LD_INT 44
8904: PPUSH
8905: LD_INT 100
8907: PPUSH
8908: CALL 18297 0 5
8912: GO 9005
8914: LD_INT 3
8916: DOUBLE
8917: EQUAL
8918: IFTRUE 8922
8920: GO 8944
8922: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
8923: LD_INT 22
8925: PPUSH
8926: LD_INT 3
8928: PPUSH
8929: LD_INT 3
8931: PPUSH
8932: LD_INT 45
8934: PPUSH
8935: LD_INT 100
8937: PPUSH
8938: CALL 18297 0 5
8942: GO 9005
8944: LD_INT 4
8946: DOUBLE
8947: EQUAL
8948: IFTRUE 8952
8950: GO 8974
8952: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
8953: LD_INT 24
8955: PPUSH
8956: LD_INT 3
8958: PPUSH
8959: LD_INT 3
8961: PPUSH
8962: LD_INT 43
8964: PPUSH
8965: LD_INT 100
8967: PPUSH
8968: CALL 18297 0 5
8972: GO 9005
8974: LD_INT 5
8976: DOUBLE
8977: EQUAL
8978: IFTRUE 8982
8980: GO 9004
8982: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
8983: LD_INT 24
8985: PPUSH
8986: LD_INT 3
8988: PPUSH
8989: LD_INT 3
8991: PPUSH
8992: LD_INT 46
8994: PPUSH
8995: LD_INT 100
8997: PPUSH
8998: CALL 18297 0 5
9002: GO 9005
9004: POP
// vehicle := CreateVehicle ;
9005: LD_ADDR_VAR 0 7
9009: PUSH
9010: CALL_OW 45
9014: ST_TO_ADDR
// filter := filter ^ vehicle ;
9015: LD_ADDR_VAR 0 3
9019: PUSH
9020: LD_VAR 0 3
9024: PUSH
9025: LD_VAR 0 7
9029: ADD
9030: ST_TO_ADDR
// end ;
9031: GO 8840
9033: POP
9034: POP
// for i = 1 to filter do
9035: LD_ADDR_VAR 0 1
9039: PUSH
9040: DOUBLE
9041: LD_INT 1
9043: DEC
9044: ST_TO_ADDR
9045: LD_VAR 0 3
9049: PUSH
9050: FOR_TO
9051: IFFALSE 9076
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
9053: LD_VAR 0 3
9057: PUSH
9058: LD_VAR 0 1
9062: ARRAY
9063: PPUSH
9064: LD_INT 14
9066: PPUSH
9067: LD_INT 0
9069: PPUSH
9070: CALL_OW 49
9074: GO 9050
9076: POP
9077: POP
// case Rand ( 1 , 3 ) of 1 :
9078: LD_INT 1
9080: PPUSH
9081: LD_INT 3
9083: PPUSH
9084: CALL_OW 12
9088: PUSH
9089: LD_INT 1
9091: DOUBLE
9092: EQUAL
9093: IFTRUE 9097
9095: GO 9151
9097: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
9098: LD_ADDR_VAR 0 11
9102: PUSH
9103: LD_INT 165
9105: PUSH
9106: LD_INT 114
9108: PUSH
9109: EMPTY
9110: LIST
9111: LIST
9112: PUSH
9113: LD_INT 104
9115: PUSH
9116: LD_INT 108
9118: PUSH
9119: EMPTY
9120: LIST
9121: LIST
9122: PUSH
9123: LD_INT 86
9125: PUSH
9126: LD_INT 77
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: PUSH
9133: LD_INT 63
9135: PUSH
9136: LD_INT 38
9138: PUSH
9139: EMPTY
9140: LIST
9141: LIST
9142: PUSH
9143: EMPTY
9144: LIST
9145: LIST
9146: LIST
9147: LIST
9148: ST_TO_ADDR
9149: GO 9276
9151: LD_INT 2
9153: DOUBLE
9154: EQUAL
9155: IFTRUE 9159
9157: GO 9213
9159: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
9160: LD_ADDR_VAR 0 11
9164: PUSH
9165: LD_INT 165
9167: PUSH
9168: LD_INT 114
9170: PUSH
9171: EMPTY
9172: LIST
9173: LIST
9174: PUSH
9175: LD_INT 146
9177: PUSH
9178: LD_INT 71
9180: PUSH
9181: EMPTY
9182: LIST
9183: LIST
9184: PUSH
9185: LD_INT 112
9187: PUSH
9188: LD_INT 41
9190: PUSH
9191: EMPTY
9192: LIST
9193: LIST
9194: PUSH
9195: LD_INT 63
9197: PUSH
9198: LD_INT 38
9200: PUSH
9201: EMPTY
9202: LIST
9203: LIST
9204: PUSH
9205: EMPTY
9206: LIST
9207: LIST
9208: LIST
9209: LIST
9210: ST_TO_ADDR
9211: GO 9276
9213: LD_INT 3
9215: DOUBLE
9216: EQUAL
9217: IFTRUE 9221
9219: GO 9275
9221: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
9222: LD_ADDR_VAR 0 11
9226: PUSH
9227: LD_INT 165
9229: PUSH
9230: LD_INT 114
9232: PUSH
9233: EMPTY
9234: LIST
9235: LIST
9236: PUSH
9237: LD_INT 63
9239: PUSH
9240: LD_INT 99
9242: PUSH
9243: EMPTY
9244: LIST
9245: LIST
9246: PUSH
9247: LD_INT 55
9249: PUSH
9250: LD_INT 77
9252: PUSH
9253: EMPTY
9254: LIST
9255: LIST
9256: PUSH
9257: LD_INT 63
9259: PUSH
9260: LD_INT 38
9262: PUSH
9263: EMPTY
9264: LIST
9265: LIST
9266: PUSH
9267: EMPTY
9268: LIST
9269: LIST
9270: LIST
9271: LIST
9272: ST_TO_ADDR
9273: GO 9276
9275: POP
// attackers := filter ;
9276: LD_ADDR_VAR 0 10
9280: PUSH
9281: LD_VAR 0 3
9285: ST_TO_ADDR
// flags := [ 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 ] ;
9286: LD_ADDR_VAR 0 12
9290: PUSH
9291: LD_INT 0
9293: PUSH
9294: LD_INT 1
9296: PUSH
9297: LD_INT 0
9299: PUSH
9300: LD_INT 1
9302: PUSH
9303: LD_INT 1
9305: PUSH
9306: LD_INT 0
9308: PUSH
9309: LD_INT 0
9311: PUSH
9312: LD_INT 0
9314: PUSH
9315: LD_INT 1
9317: PUSH
9318: LD_INT 1
9320: PUSH
9321: EMPTY
9322: LIST
9323: LIST
9324: LIST
9325: LIST
9326: LIST
9327: LIST
9328: LIST
9329: LIST
9330: LIST
9331: LIST
9332: ST_TO_ADDR
// MC_PrepareAttack ( 1 , attackers , _target , flags ) ;
9333: LD_INT 1
9335: PPUSH
9336: LD_VAR 0 10
9340: PPUSH
9341: LD_VAR 0 11
9345: PPUSH
9346: LD_VAR 0 12
9350: PPUSH
9351: CALL 78278 0 4
// enable ;
9355: ENABLE
// end ;
9356: PPOPN 12
9358: END
// every 0 0$1 do var i , tmp ;
9359: GO 9361
9361: DISABLE
9362: LD_INT 0
9364: PPUSH
9365: PPUSH
// begin enable ;
9366: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
9367: LD_ADDR_VAR 0 2
9371: PUSH
9372: LD_INT 3
9374: PUSH
9375: LD_INT 22
9377: PUSH
9378: LD_INT 1
9380: PUSH
9381: EMPTY
9382: LIST
9383: LIST
9384: PUSH
9385: EMPTY
9386: LIST
9387: LIST
9388: PUSH
9389: LD_INT 32
9391: PUSH
9392: LD_INT 1
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: PUSH
9399: EMPTY
9400: LIST
9401: LIST
9402: PPUSH
9403: CALL_OW 69
9407: ST_TO_ADDR
// if tmp then
9408: LD_VAR 0 2
9412: IFFALSE 9458
// for i in tmp do
9414: LD_ADDR_VAR 0 1
9418: PUSH
9419: LD_VAR 0 2
9423: PUSH
9424: FOR_IN
9425: IFFALSE 9456
// if GetFuel ( i ) < 3 then
9427: LD_VAR 0 1
9431: PPUSH
9432: CALL_OW 261
9436: PUSH
9437: LD_INT 3
9439: LESS
9440: IFFALSE 9454
// SetFuel ( i , 3 ) ;
9442: LD_VAR 0 1
9446: PPUSH
9447: LD_INT 3
9449: PPUSH
9450: CALL_OW 240
9454: GO 9424
9456: POP
9457: POP
// end ;
9458: PPOPN 2
9460: END
// every 0 0$1 trigger ( FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) and not JMMArrival ) or ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) and not FirstAssaultRepelled ) do var i , veh , tmp ;
9461: LD_INT 3
9463: PPUSH
9464: LD_INT 22
9466: PUSH
9467: LD_INT 1
9469: PUSH
9470: EMPTY
9471: LIST
9472: LIST
9473: PPUSH
9474: CALL_OW 70
9478: PUSH
9479: LD_EXP 40
9483: NOT
9484: AND
9485: PUSH
9486: LD_INT 10
9488: PPUSH
9489: LD_INT 22
9491: PUSH
9492: LD_INT 1
9494: PUSH
9495: EMPTY
9496: LIST
9497: LIST
9498: PPUSH
9499: CALL_OW 70
9503: PUSH
9504: LD_EXP 3
9508: NOT
9509: AND
9510: OR
9511: IFFALSE 9525
9513: GO 9515
9515: DISABLE
9516: LD_INT 0
9518: PPUSH
9519: PPUSH
9520: PPUSH
// begin Antirush ;
9521: CALL 9528 0 0
// end ;
9525: PPOPN 3
9527: END
// export function Antirush ; var i , veh , tmp , num ; begin
9528: LD_INT 0
9530: PPUSH
9531: PPUSH
9532: PPUSH
9533: PPUSH
9534: PPUSH
// tmp := [ ] ;
9535: LD_ADDR_VAR 0 4
9539: PUSH
9540: EMPTY
9541: ST_TO_ADDR
// if not FirstAssaultRepelled then
9542: LD_EXP 3
9546: NOT
9547: IFFALSE 9559
// num := 18 else
9549: LD_ADDR_VAR 0 5
9553: PUSH
9554: LD_INT 18
9556: ST_TO_ADDR
9557: GO 9567
// num := 12 ;
9559: LD_ADDR_VAR 0 5
9563: PUSH
9564: LD_INT 12
9566: ST_TO_ADDR
// num := num - [ 4 , 2 , 0 ] [ Difficulty ] ;
9567: LD_ADDR_VAR 0 5
9571: PUSH
9572: LD_VAR 0 5
9576: PUSH
9577: LD_INT 4
9579: PUSH
9580: LD_INT 2
9582: PUSH
9583: LD_INT 0
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: LIST
9590: PUSH
9591: LD_OWVAR 67
9595: ARRAY
9596: MINUS
9597: ST_TO_ADDR
// for i := 1 to num do
9598: LD_ADDR_VAR 0 2
9602: PUSH
9603: DOUBLE
9604: LD_INT 1
9606: DEC
9607: ST_TO_ADDR
9608: LD_VAR 0 5
9612: PUSH
9613: FOR_TO
9614: IFFALSE 9753
// begin uc_side := 3 ;
9616: LD_ADDR_OWVAR 20
9620: PUSH
9621: LD_INT 3
9623: ST_TO_ADDR
// uc_nation := 3 ;
9624: LD_ADDR_OWVAR 21
9628: PUSH
9629: LD_INT 3
9631: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
9632: LD_INT 23
9634: PPUSH
9635: LD_INT 3
9637: PPUSH
9638: LD_INT 3
9640: PPUSH
9641: LD_INT 46
9643: PUSH
9644: LD_INT 43
9646: PUSH
9647: EMPTY
9648: LIST
9649: LIST
9650: PUSH
9651: LD_INT 1
9653: PPUSH
9654: LD_INT 2
9656: PPUSH
9657: CALL_OW 12
9661: ARRAY
9662: PPUSH
9663: LD_INT 100
9665: PPUSH
9666: CALL 18297 0 5
// veh := CreateVehicle ;
9670: LD_ADDR_VAR 0 3
9674: PUSH
9675: CALL_OW 45
9679: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
9680: LD_VAR 0 3
9684: PPUSH
9685: LD_INT 5
9687: PPUSH
9688: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
9692: LD_VAR 0 3
9696: PPUSH
9697: LD_INT 199
9699: PPUSH
9700: LD_INT 135
9702: PPUSH
9703: LD_INT 3
9705: PPUSH
9706: LD_INT 0
9708: PPUSH
9709: CALL_OW 50
// tmp := tmp ^ veh ;
9713: LD_ADDR_VAR 0 4
9717: PUSH
9718: LD_VAR 0 4
9722: PUSH
9723: LD_VAR 0 3
9727: ADD
9728: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
9729: LD_VAR 0 3
9733: PPUSH
9734: LD_INT 173
9736: PPUSH
9737: LD_INT 118
9739: PPUSH
9740: CALL_OW 111
// wait ( 0 0$2 ) ;
9744: LD_INT 70
9746: PPUSH
9747: CALL_OW 67
// end ;
9751: GO 9613
9753: POP
9754: POP
// repeat wait ( 0 0$1 ) ;
9755: LD_INT 35
9757: PPUSH
9758: CALL_OW 67
// for i in tmp do
9762: LD_ADDR_VAR 0 2
9766: PUSH
9767: LD_VAR 0 4
9771: PUSH
9772: FOR_IN
9773: IFFALSE 9840
// if IsDead ( i ) then
9775: LD_VAR 0 2
9779: PPUSH
9780: CALL_OW 301
9784: IFFALSE 9804
// tmp := tmp diff i else
9786: LD_ADDR_VAR 0 4
9790: PUSH
9791: LD_VAR 0 4
9795: PUSH
9796: LD_VAR 0 2
9800: DIFF
9801: ST_TO_ADDR
9802: GO 9838
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
9804: LD_VAR 0 2
9808: PPUSH
9809: LD_INT 22
9811: PUSH
9812: LD_INT 1
9814: PUSH
9815: EMPTY
9816: LIST
9817: LIST
9818: PPUSH
9819: CALL_OW 69
9823: PPUSH
9824: LD_VAR 0 2
9828: PPUSH
9829: CALL_OW 74
9833: PPUSH
9834: CALL_OW 115
9838: GO 9772
9840: POP
9841: POP
// until not tmp ;
9842: LD_VAR 0 4
9846: NOT
9847: IFFALSE 9755
// end ; end_of_file
9849: LD_VAR 0 1
9853: RET
// export Losses ; on UnitDestroyed ( un ) do begin if un = Brighton then
9854: LD_VAR 0 1
9858: PUSH
9859: LD_EXP 8
9863: EQUAL
9864: IFFALSE 9880
// begin wait ( 0 0$1 ) ;
9866: LD_INT 35
9868: PPUSH
9869: CALL_OW 67
// YouLost ( Brighton ) ;
9873: LD_STRING Brighton
9875: PPUSH
9876: CALL_OW 104
// end ; if un = JMM then
9880: LD_VAR 0 1
9884: PUSH
9885: LD_EXP 36
9889: EQUAL
9890: IFFALSE 9906
// begin wait ( 0 0$1 ) ;
9892: LD_INT 35
9894: PPUSH
9895: CALL_OW 67
// YouLost ( JMM ) ;
9899: LD_STRING JMM
9901: PPUSH
9902: CALL_OW 104
// end ; if un = Megan then
9906: LD_VAR 0 1
9910: PUSH
9911: LD_EXP 10
9915: EQUAL
9916: IFFALSE 9930
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
9918: LD_EXP 8
9922: PPUSH
9923: LD_STRING DBrighton-MeganDeath
9925: PPUSH
9926: CALL_OW 88
// end ; if un = Palmer then
9930: LD_VAR 0 1
9934: PUSH
9935: LD_EXP 9
9939: EQUAL
9940: IFFALSE 9954
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
9942: LD_EXP 8
9946: PPUSH
9947: LD_STRING DBrighton-PalmerDeath
9949: PPUSH
9950: CALL_OW 88
// end ; if un = Burlak then
9954: LD_VAR 0 1
9958: PUSH
9959: LD_EXP 18
9963: EQUAL
9964: IFFALSE 9996
// begin if JMM_Arrived then
9966: LD_EXP 5
9970: IFFALSE 9984
// Say ( JMM , DJMM-BurlakDead ) ;
9972: LD_EXP 36
9976: PPUSH
9977: LD_STRING DJMM-BurlakDead
9979: PPUSH
9980: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
9984: LD_EXP 9
9988: PPUSH
9989: LD_STRING DSol-BurlakDead
9991: PPUSH
9992: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
9996: LD_VAR 0 1
10000: PUSH
10001: LD_INT 1
10003: EQUAL
10004: PUSH
10005: LD_VAR 0 1
10009: PUSH
10010: LD_INT 3
10012: EQUAL
10013: OR
10014: IFFALSE 10030
// begin wait ( 0 0$1 ) ;
10016: LD_INT 35
10018: PPUSH
10019: CALL_OW 67
// YouLost ( Depot ) ;
10023: LD_STRING Depot
10025: PPUSH
10026: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
10030: LD_VAR 0 1
10034: PPUSH
10035: CALL_OW 255
10039: PUSH
10040: LD_INT 1
10042: EQUAL
10043: PUSH
10044: LD_VAR 0 1
10048: PPUSH
10049: CALL_OW 247
10053: PUSH
10054: LD_INT 1
10056: EQUAL
10057: AND
10058: IFFALSE 10074
// Losses := Losses + 1 ;
10060: LD_ADDR_EXP 43
10064: PUSH
10065: LD_EXP 43
10069: PUSH
10070: LD_INT 1
10072: PLUS
10073: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10074: LD_VAR 0 1
10078: PPUSH
10079: CALL 81485 0 1
// end ;
10083: PPOPN 1
10085: END
// on UnitGoesToRed ( un ) do begin if un = Yashin then
10086: LD_VAR 0 1
10090: PUSH
10091: LD_EXP 12
10095: EQUAL
10096: IFFALSE 10110
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
10098: LD_EXP 12
10102: PPUSH
10103: LD_STRING DDeath-Yas-3
10105: PPUSH
10106: CALL_OW 91
// if un = Popov then
10110: LD_VAR 0 1
10114: PUSH
10115: LD_EXP 13
10119: EQUAL
10120: IFFALSE 10134
// ForceSay ( Popov , DDeath-Pop-3 ) ;
10122: LD_EXP 13
10126: PPUSH
10127: LD_STRING DDeath-Pop-3
10129: PPUSH
10130: CALL_OW 91
// if un = Gaydar then
10134: LD_VAR 0 1
10138: PUSH
10139: LD_EXP 14
10143: EQUAL
10144: IFFALSE 10158
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
10146: LD_EXP 14
10150: PPUSH
10151: LD_STRING DDeath-Gay-3
10153: PPUSH
10154: CALL_OW 91
// if un = Sevi then
10158: LD_VAR 0 1
10162: PUSH
10163: LD_EXP 15
10167: EQUAL
10168: IFFALSE 10182
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
10170: LD_EXP 15
10174: PPUSH
10175: LD_STRING DDeath-Vse-3
10177: PPUSH
10178: CALL_OW 91
// end ;
10182: PPOPN 1
10184: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
10185: LD_VAR 0 1
10189: PUSH
10190: LD_INT 10
10192: EQUAL
10193: IFFALSE 10231
// begin Say ( Brighton , DBrighton-C1 ) ;
10195: LD_EXP 8
10199: PPUSH
10200: LD_STRING DBrighton-C1
10202: PPUSH
10203: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
10207: LD_EXP 10
10211: PPUSH
10212: LD_STRING DMegan-C1
10214: PPUSH
10215: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
10219: LD_EXP 8
10223: PPUSH
10224: LD_STRING DBrighton-C2
10226: PPUSH
10227: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
10231: LD_VAR 0 1
10235: PPUSH
10236: LD_VAR 0 2
10240: PPUSH
10241: CALL 81181 0 2
// end ;
10245: PPOPN 2
10247: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10248: LD_VAR 0 1
10252: PPUSH
10253: LD_VAR 0 2
10257: PPUSH
10258: CALL 83819 0 2
// end ;
10262: PPOPN 2
10264: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10265: LD_VAR 0 1
10269: PPUSH
10270: CALL 82887 0 1
// end ;
10274: PPOPN 1
10276: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
10277: LD_VAR 0 1
10281: PPUSH
10282: CALL_OW 266
10286: PUSH
10287: LD_INT 0
10289: EQUAL
10290: PUSH
10291: LD_VAR 0 1
10295: PPUSH
10296: CALL_OW 255
10300: PUSH
10301: LD_INT 3
10303: EQUAL
10304: AND
10305: IFFALSE 10367
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
10307: LD_VAR 0 1
10311: PPUSH
10312: CALL_OW 274
10316: PPUSH
10317: LD_INT 1
10319: PPUSH
10320: LD_INT 10000
10322: PPUSH
10323: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
10327: LD_VAR 0 1
10331: PPUSH
10332: CALL_OW 274
10336: PPUSH
10337: LD_INT 2
10339: PPUSH
10340: LD_INT 250
10342: PPUSH
10343: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
10347: LD_VAR 0 1
10351: PPUSH
10352: CALL_OW 274
10356: PPUSH
10357: LD_INT 3
10359: PPUSH
10360: LD_INT 100
10362: PPUSH
10363: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
10367: LD_VAR 0 1
10371: PPUSH
10372: CALL 83128 0 1
// end ;
10376: PPOPN 1
10378: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10379: LD_VAR 0 1
10383: PPUSH
10384: LD_VAR 0 2
10388: PPUSH
10389: LD_VAR 0 3
10393: PPUSH
10394: LD_VAR 0 4
10398: PPUSH
10399: LD_VAR 0 5
10403: PPUSH
10404: CALL 80801 0 5
// end ;
10408: PPOPN 5
10410: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10411: LD_VAR 0 1
10415: PPUSH
10416: LD_VAR 0 2
10420: PPUSH
10421: CALL 80397 0 2
// end ;
10425: PPOPN 2
10427: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10428: LD_VAR 0 1
10432: PPUSH
10433: LD_VAR 0 2
10437: PPUSH
10438: LD_VAR 0 3
10442: PPUSH
10443: LD_VAR 0 4
10447: PPUSH
10448: CALL 80235 0 4
// end ;
10452: PPOPN 4
10454: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10455: LD_VAR 0 1
10459: PPUSH
10460: LD_VAR 0 2
10464: PPUSH
10465: LD_VAR 0 3
10469: PPUSH
10470: CALL 80010 0 3
// end ;
10474: PPOPN 3
10476: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10477: LD_VAR 0 1
10481: PPUSH
10482: LD_VAR 0 2
10486: PPUSH
10487: CALL 79895 0 2
// end ;
10491: PPOPN 2
10493: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10494: LD_VAR 0 1
10498: PPUSH
10499: LD_VAR 0 2
10503: PPUSH
10504: CALL 84080 0 2
// end ;
10508: PPOPN 2
10510: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
10511: LD_VAR 0 1
10515: PPUSH
10516: CALL_OW 255
10520: PUSH
10521: LD_INT 6
10523: EQUAL
10524: IFFALSE 10654
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
10526: LD_VAR 0 1
10530: PUSH
10531: LD_EXP 12
10535: PUSH
10536: LD_EXP 15
10540: PUSH
10541: LD_EXP 14
10545: PUSH
10546: LD_EXP 13
10550: PUSH
10551: EMPTY
10552: LIST
10553: LIST
10554: LIST
10555: LIST
10556: IN
10557: IFFALSE 10561
// exit ;
10559: GO 10678
// if AssaultStarted then
10561: LD_EXP 7
10565: IFFALSE 10639
// case Rand ( 1 , 4 ) of 1 .. 3 :
10567: LD_INT 1
10569: PPUSH
10570: LD_INT 4
10572: PPUSH
10573: CALL_OW 12
10577: PUSH
10578: LD_INT 1
10580: DOUBLE
10581: GREATEREQUAL
10582: IFFALSE 10590
10584: LD_INT 3
10586: DOUBLE
10587: LESSEQUAL
10588: IFTRUE 10592
10590: GO 10610
10592: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
10593: LD_VAR 0 1
10597: PPUSH
10598: LD_INT 67
10600: PPUSH
10601: LD_INT 37
10603: PPUSH
10604: CALL_OW 114
10608: GO 10637
10610: LD_INT 4
10612: DOUBLE
10613: EQUAL
10614: IFTRUE 10618
10616: GO 10636
10618: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
10619: LD_VAR 0 1
10623: PPUSH
10624: LD_INT 120
10626: PPUSH
10627: LD_INT 131
10629: PPUSH
10630: CALL_OW 111
10634: GO 10637
10636: POP
10637: GO 10654
// ComMoveXY ( driver , 120 , 131 ) ;
10639: LD_VAR 0 1
10643: PPUSH
10644: LD_INT 120
10646: PPUSH
10647: LD_INT 131
10649: PPUSH
10650: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10654: LD_VAR 0 1
10658: PPUSH
10659: LD_VAR 0 2
10663: PPUSH
10664: LD_VAR 0 3
10668: PPUSH
10669: LD_VAR 0 4
10673: PPUSH
10674: CALL 84296 0 4
// end ;
10678: PPOPN 4
10680: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10681: LD_VAR 0 1
10685: PPUSH
10686: LD_VAR 0 2
10690: PPUSH
10691: CALL 79704 0 2
// end ;
10695: PPOPN 2
10697: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10698: LD_VAR 0 1
10702: PPUSH
10703: CALL 86799 0 1
// end ; end_of_file
10707: PPOPN 1
10709: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
10710: LD_EXP 5
10714: PUSH
10715: LD_EXP 42
10719: AND
10720: IFFALSE 10891
10722: GO 10724
10724: DISABLE
// begin wait ( 0 0$2 ) ;
10725: LD_INT 70
10727: PPUSH
10728: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
10732: LD_EXP 8
10736: PPUSH
10737: LD_STRING DBrighton-G1
10739: PPUSH
10740: CALL_OW 88
// if Losses < 1 then
10744: LD_EXP 43
10748: PUSH
10749: LD_INT 1
10751: LESS
10752: IFFALSE 10766
// AddMedal ( Losses , 1 ) else
10754: LD_STRING Losses
10756: PPUSH
10757: LD_INT 1
10759: PPUSH
10760: CALL_OW 101
10764: GO 10799
// if Losses < 5 then
10766: LD_EXP 43
10770: PUSH
10771: LD_INT 5
10773: LESS
10774: IFFALSE 10788
// AddMedal ( Losses , 2 ) else
10776: LD_STRING Losses
10778: PPUSH
10779: LD_INT 2
10781: PPUSH
10782: CALL_OW 101
10786: GO 10799
// AddMedal ( Losses , - 1 ) ;
10788: LD_STRING Losses
10790: PPUSH
10791: LD_INT 1
10793: NEG
10794: PPUSH
10795: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
10799: LD_EXP 6
10803: PUSH
10804: LD_INT 10
10806: PPUSH
10807: LD_INT 1
10809: PPUSH
10810: CALL_OW 321
10814: PUSH
10815: LD_INT 2
10817: EQUAL
10818: AND
10819: IFFALSE 10833
// AddMedal ( Laser , 1 ) else
10821: LD_STRING Laser
10823: PPUSH
10824: LD_INT 1
10826: PPUSH
10827: CALL_OW 101
10831: GO 10880
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
10833: LD_EXP 6
10837: NOT
10838: PUSH
10839: LD_INT 10
10841: PPUSH
10842: LD_INT 1
10844: PPUSH
10845: CALL_OW 321
10849: PUSH
10850: LD_INT 2
10852: EQUAL
10853: AND
10854: IFFALSE 10869
// AddMedal ( Laser , - 1 ) else
10856: LD_STRING Laser
10858: PPUSH
10859: LD_INT 1
10861: NEG
10862: PPUSH
10863: CALL_OW 101
10867: GO 10880
// AddMedal ( Laser , - 2 ) ;
10869: LD_STRING Laser
10871: PPUSH
10872: LD_INT 2
10874: NEG
10875: PPUSH
10876: CALL_OW 101
// GiveMedals ( BaseMain ) ;
10880: LD_STRING BaseMain
10882: PPUSH
10883: CALL_OW 102
// YouWin ;
10887: CALL_OW 103
// end ; end_of_file
10891: END
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
10892: LD_INT 0
10894: PPUSH
10895: PPUSH
// area = ListEnvironmentArea ( area ) ;
10896: LD_ADDR_VAR 0 2
10900: PUSH
10901: LD_VAR 0 2
10905: PPUSH
10906: CALL_OW 353
10910: ST_TO_ADDR
// if bulldozer > 0 then
10911: LD_VAR 0 1
10915: PUSH
10916: LD_INT 0
10918: GREATER
10919: IFFALSE 11030
// for i = area downto 1 do
10921: LD_ADDR_VAR 0 4
10925: PUSH
10926: DOUBLE
10927: LD_VAR 0 2
10931: INC
10932: ST_TO_ADDR
10933: LD_INT 1
10935: PUSH
10936: FOR_DOWNTO
10937: IFFALSE 11028
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
10939: LD_VAR 0 2
10943: PUSH
10944: LD_VAR 0 4
10948: ARRAY
10949: PUSH
10950: LD_INT 1
10952: ARRAY
10953: PPUSH
10954: LD_VAR 0 2
10958: PUSH
10959: LD_VAR 0 4
10963: ARRAY
10964: PUSH
10965: LD_INT 2
10967: ARRAY
10968: PPUSH
10969: CALL_OW 351
10973: IFFALSE 11026
// if not HasTask ( bulldozer ) then
10975: LD_VAR 0 1
10979: PPUSH
10980: CALL_OW 314
10984: NOT
10985: IFFALSE 11026
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
10987: LD_VAR 0 1
10991: PPUSH
10992: LD_VAR 0 2
10996: PUSH
10997: LD_VAR 0 4
11001: ARRAY
11002: PUSH
11003: LD_INT 1
11005: ARRAY
11006: PPUSH
11007: LD_VAR 0 2
11011: PUSH
11012: LD_VAR 0 4
11016: ARRAY
11017: PUSH
11018: LD_INT 2
11020: ARRAY
11021: PPUSH
11022: CALL_OW 171
11026: GO 10936
11028: POP
11029: POP
// end ;
11030: LD_VAR 0 3
11034: RET
// export function ComMeeting ( team , area ) ; var i , tmp ; begin
11035: LD_INT 0
11037: PPUSH
11038: PPUSH
11039: PPUSH
// tmp := AreaToList ( area , 0 ) ;
11040: LD_ADDR_VAR 0 5
11044: PUSH
11045: LD_VAR 0 2
11049: PPUSH
11050: LD_INT 0
11052: PPUSH
11053: CALL_OW 517
11057: ST_TO_ADDR
// for i = 1 to team do
11058: LD_ADDR_VAR 0 4
11062: PUSH
11063: DOUBLE
11064: LD_INT 1
11066: DEC
11067: ST_TO_ADDR
11068: LD_VAR 0 1
11072: PUSH
11073: FOR_TO
11074: IFFALSE 11175
// begin if IsInUnit ( team [ i ] ) then
11076: LD_VAR 0 1
11080: PUSH
11081: LD_VAR 0 4
11085: ARRAY
11086: PPUSH
11087: CALL_OW 310
11091: IFFALSE 11108
// ComExitBuilding ( team [ i ] ) ;
11093: LD_VAR 0 1
11097: PUSH
11098: LD_VAR 0 4
11102: ARRAY
11103: PPUSH
11104: CALL_OW 122
// AddComMoveXY ( team [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
11108: LD_VAR 0 1
11112: PUSH
11113: LD_VAR 0 4
11117: ARRAY
11118: PPUSH
11119: LD_VAR 0 5
11123: PUSH
11124: LD_INT 1
11126: ARRAY
11127: PUSH
11128: LD_VAR 0 4
11132: ARRAY
11133: PPUSH
11134: LD_VAR 0 5
11138: PUSH
11139: LD_INT 2
11141: ARRAY
11142: PUSH
11143: LD_VAR 0 4
11147: ARRAY
11148: PPUSH
11149: CALL_OW 171
// AddComTurnUnit ( team [ i ] , Brighton ) ;
11153: LD_VAR 0 1
11157: PUSH
11158: LD_VAR 0 4
11162: ARRAY
11163: PPUSH
11164: LD_EXP 8
11168: PPUSH
11169: CALL_OW 179
// end ;
11173: GO 11073
11175: POP
11176: POP
// end ; end_of_file
11177: LD_VAR 0 3
11181: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11182: LD_INT 0
11184: PPUSH
11185: PPUSH
// if exist_mode then
11186: LD_VAR 0 2
11190: IFFALSE 11215
// unit := CreateCharacter ( prefix & ident ) else
11192: LD_ADDR_VAR 0 5
11196: PUSH
11197: LD_VAR 0 3
11201: PUSH
11202: LD_VAR 0 1
11206: STR
11207: PPUSH
11208: CALL_OW 34
11212: ST_TO_ADDR
11213: GO 11230
// unit := NewCharacter ( ident ) ;
11215: LD_ADDR_VAR 0 5
11219: PUSH
11220: LD_VAR 0 1
11224: PPUSH
11225: CALL_OW 25
11229: ST_TO_ADDR
// result := unit ;
11230: LD_ADDR_VAR 0 4
11234: PUSH
11235: LD_VAR 0 5
11239: ST_TO_ADDR
// end ;
11240: LD_VAR 0 4
11244: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11245: LD_INT 0
11247: PPUSH
11248: PPUSH
// if not side or not nation then
11249: LD_VAR 0 1
11253: NOT
11254: PUSH
11255: LD_VAR 0 2
11259: NOT
11260: OR
11261: IFFALSE 11265
// exit ;
11263: GO 11909
// case nation of nation_american :
11265: LD_VAR 0 2
11269: PUSH
11270: LD_INT 1
11272: DOUBLE
11273: EQUAL
11274: IFTRUE 11278
11276: GO 11452
11278: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
11279: LD_ADDR_VAR 0 4
11283: PUSH
11284: LD_INT 35
11286: PUSH
11287: LD_INT 45
11289: PUSH
11290: LD_INT 46
11292: PUSH
11293: LD_INT 47
11295: PUSH
11296: LD_INT 1
11298: PUSH
11299: LD_INT 2
11301: PUSH
11302: LD_INT 6
11304: PUSH
11305: LD_INT 15
11307: PUSH
11308: LD_INT 16
11310: PUSH
11311: LD_INT 7
11313: PUSH
11314: LD_INT 12
11316: PUSH
11317: LD_INT 13
11319: PUSH
11320: LD_INT 10
11322: PUSH
11323: LD_INT 14
11325: PUSH
11326: LD_INT 20
11328: PUSH
11329: LD_INT 21
11331: PUSH
11332: LD_INT 22
11334: PUSH
11335: LD_INT 25
11337: PUSH
11338: LD_INT 32
11340: PUSH
11341: LD_INT 27
11343: PUSH
11344: LD_INT 36
11346: PUSH
11347: LD_INT 69
11349: PUSH
11350: LD_INT 39
11352: PUSH
11353: LD_INT 34
11355: PUSH
11356: LD_INT 40
11358: PUSH
11359: LD_INT 48
11361: PUSH
11362: LD_INT 49
11364: PUSH
11365: LD_INT 50
11367: PUSH
11368: LD_INT 51
11370: PUSH
11371: LD_INT 52
11373: PUSH
11374: LD_INT 53
11376: PUSH
11377: LD_INT 54
11379: PUSH
11380: LD_INT 55
11382: PUSH
11383: LD_INT 56
11385: PUSH
11386: LD_INT 57
11388: PUSH
11389: LD_INT 58
11391: PUSH
11392: LD_INT 59
11394: PUSH
11395: LD_INT 60
11397: PUSH
11398: LD_INT 61
11400: PUSH
11401: LD_INT 62
11403: PUSH
11404: LD_INT 80
11406: PUSH
11407: EMPTY
11408: LIST
11409: LIST
11410: LIST
11411: LIST
11412: LIST
11413: LIST
11414: LIST
11415: LIST
11416: LIST
11417: LIST
11418: LIST
11419: LIST
11420: LIST
11421: LIST
11422: LIST
11423: LIST
11424: LIST
11425: LIST
11426: LIST
11427: LIST
11428: LIST
11429: LIST
11430: LIST
11431: LIST
11432: LIST
11433: LIST
11434: LIST
11435: LIST
11436: LIST
11437: LIST
11438: LIST
11439: LIST
11440: LIST
11441: LIST
11442: LIST
11443: LIST
11444: LIST
11445: LIST
11446: LIST
11447: LIST
11448: LIST
11449: ST_TO_ADDR
11450: GO 11833
11452: LD_INT 2
11454: DOUBLE
11455: EQUAL
11456: IFTRUE 11460
11458: GO 11642
11460: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
11461: LD_ADDR_VAR 0 4
11465: PUSH
11466: LD_INT 35
11468: PUSH
11469: LD_INT 45
11471: PUSH
11472: LD_INT 46
11474: PUSH
11475: LD_INT 47
11477: PUSH
11478: LD_INT 70
11480: PUSH
11481: LD_INT 1
11483: PUSH
11484: LD_INT 11
11486: PUSH
11487: LD_INT 3
11489: PUSH
11490: LD_INT 4
11492: PUSH
11493: LD_INT 5
11495: PUSH
11496: LD_INT 6
11498: PUSH
11499: LD_INT 15
11501: PUSH
11502: LD_INT 18
11504: PUSH
11505: LD_INT 7
11507: PUSH
11508: LD_INT 17
11510: PUSH
11511: LD_INT 8
11513: PUSH
11514: LD_INT 20
11516: PUSH
11517: LD_INT 21
11519: PUSH
11520: LD_INT 22
11522: PUSH
11523: LD_INT 72
11525: PUSH
11526: LD_INT 26
11528: PUSH
11529: LD_INT 69
11531: PUSH
11532: LD_INT 39
11534: PUSH
11535: LD_INT 40
11537: PUSH
11538: LD_INT 41
11540: PUSH
11541: LD_INT 42
11543: PUSH
11544: LD_INT 43
11546: PUSH
11547: LD_INT 48
11549: PUSH
11550: LD_INT 49
11552: PUSH
11553: LD_INT 50
11555: PUSH
11556: LD_INT 51
11558: PUSH
11559: LD_INT 52
11561: PUSH
11562: LD_INT 53
11564: PUSH
11565: LD_INT 54
11567: PUSH
11568: LD_INT 55
11570: PUSH
11571: LD_INT 56
11573: PUSH
11574: LD_INT 60
11576: PUSH
11577: LD_INT 61
11579: PUSH
11580: LD_INT 62
11582: PUSH
11583: LD_INT 66
11585: PUSH
11586: LD_INT 67
11588: PUSH
11589: LD_INT 68
11591: PUSH
11592: LD_INT 81
11594: PUSH
11595: EMPTY
11596: LIST
11597: LIST
11598: LIST
11599: LIST
11600: LIST
11601: LIST
11602: LIST
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: LIST
11612: LIST
11613: LIST
11614: LIST
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: LIST
11622: LIST
11623: LIST
11624: LIST
11625: LIST
11626: LIST
11627: LIST
11628: LIST
11629: LIST
11630: LIST
11631: LIST
11632: LIST
11633: LIST
11634: LIST
11635: LIST
11636: LIST
11637: LIST
11638: LIST
11639: ST_TO_ADDR
11640: GO 11833
11642: LD_INT 3
11644: DOUBLE
11645: EQUAL
11646: IFTRUE 11650
11648: GO 11832
11650: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
11651: LD_ADDR_VAR 0 4
11655: PUSH
11656: LD_INT 46
11658: PUSH
11659: LD_INT 47
11661: PUSH
11662: LD_INT 1
11664: PUSH
11665: LD_INT 2
11667: PUSH
11668: LD_INT 11
11670: PUSH
11671: LD_INT 9
11673: PUSH
11674: LD_INT 20
11676: PUSH
11677: LD_INT 19
11679: PUSH
11680: LD_INT 21
11682: PUSH
11683: LD_INT 24
11685: PUSH
11686: LD_INT 22
11688: PUSH
11689: LD_INT 25
11691: PUSH
11692: LD_INT 28
11694: PUSH
11695: LD_INT 29
11697: PUSH
11698: LD_INT 30
11700: PUSH
11701: LD_INT 31
11703: PUSH
11704: LD_INT 37
11706: PUSH
11707: LD_INT 38
11709: PUSH
11710: LD_INT 32
11712: PUSH
11713: LD_INT 27
11715: PUSH
11716: LD_INT 33
11718: PUSH
11719: LD_INT 69
11721: PUSH
11722: LD_INT 39
11724: PUSH
11725: LD_INT 34
11727: PUSH
11728: LD_INT 40
11730: PUSH
11731: LD_INT 71
11733: PUSH
11734: LD_INT 23
11736: PUSH
11737: LD_INT 44
11739: PUSH
11740: LD_INT 48
11742: PUSH
11743: LD_INT 49
11745: PUSH
11746: LD_INT 50
11748: PUSH
11749: LD_INT 51
11751: PUSH
11752: LD_INT 52
11754: PUSH
11755: LD_INT 53
11757: PUSH
11758: LD_INT 54
11760: PUSH
11761: LD_INT 55
11763: PUSH
11764: LD_INT 56
11766: PUSH
11767: LD_INT 57
11769: PUSH
11770: LD_INT 58
11772: PUSH
11773: LD_INT 59
11775: PUSH
11776: LD_INT 63
11778: PUSH
11779: LD_INT 64
11781: PUSH
11782: LD_INT 65
11784: PUSH
11785: EMPTY
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: LIST
11792: LIST
11793: LIST
11794: LIST
11795: LIST
11796: LIST
11797: LIST
11798: LIST
11799: LIST
11800: LIST
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: LIST
11812: LIST
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: ST_TO_ADDR
11830: GO 11833
11832: POP
// if state > - 1 and state < 3 then
11833: LD_VAR 0 3
11837: PUSH
11838: LD_INT 1
11840: NEG
11841: GREATER
11842: PUSH
11843: LD_VAR 0 3
11847: PUSH
11848: LD_INT 3
11850: LESS
11851: AND
11852: IFFALSE 11909
// for i in result do
11854: LD_ADDR_VAR 0 5
11858: PUSH
11859: LD_VAR 0 4
11863: PUSH
11864: FOR_IN
11865: IFFALSE 11907
// if GetTech ( i , side ) <> state then
11867: LD_VAR 0 5
11871: PPUSH
11872: LD_VAR 0 1
11876: PPUSH
11877: CALL_OW 321
11881: PUSH
11882: LD_VAR 0 3
11886: NONEQUAL
11887: IFFALSE 11905
// result := result diff i ;
11889: LD_ADDR_VAR 0 4
11893: PUSH
11894: LD_VAR 0 4
11898: PUSH
11899: LD_VAR 0 5
11903: DIFF
11904: ST_TO_ADDR
11905: GO 11864
11907: POP
11908: POP
// end ;
11909: LD_VAR 0 4
11913: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11914: LD_INT 0
11916: PPUSH
11917: PPUSH
11918: PPUSH
// result := true ;
11919: LD_ADDR_VAR 0 3
11923: PUSH
11924: LD_INT 1
11926: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11927: LD_ADDR_VAR 0 5
11931: PUSH
11932: LD_VAR 0 2
11936: PPUSH
11937: CALL_OW 480
11941: ST_TO_ADDR
// if not tmp then
11942: LD_VAR 0 5
11946: NOT
11947: IFFALSE 11951
// exit ;
11949: GO 12000
// for i in tmp do
11951: LD_ADDR_VAR 0 4
11955: PUSH
11956: LD_VAR 0 5
11960: PUSH
11961: FOR_IN
11962: IFFALSE 11998
// if GetTech ( i , side ) <> state_researched then
11964: LD_VAR 0 4
11968: PPUSH
11969: LD_VAR 0 1
11973: PPUSH
11974: CALL_OW 321
11978: PUSH
11979: LD_INT 2
11981: NONEQUAL
11982: IFFALSE 11996
// begin result := false ;
11984: LD_ADDR_VAR 0 3
11988: PUSH
11989: LD_INT 0
11991: ST_TO_ADDR
// exit ;
11992: POP
11993: POP
11994: GO 12000
// end ;
11996: GO 11961
11998: POP
11999: POP
// end ;
12000: LD_VAR 0 3
12004: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
12005: LD_INT 0
12007: PPUSH
12008: PPUSH
12009: PPUSH
12010: PPUSH
12011: PPUSH
12012: PPUSH
12013: PPUSH
12014: PPUSH
12015: PPUSH
12016: PPUSH
12017: PPUSH
12018: PPUSH
12019: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
12020: LD_VAR 0 1
12024: NOT
12025: PUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: CALL_OW 257
12035: PUSH
12036: LD_INT 9
12038: NONEQUAL
12039: OR
12040: IFFALSE 12044
// exit ;
12042: GO 12617
// side := GetSide ( unit ) ;
12044: LD_ADDR_VAR 0 9
12048: PUSH
12049: LD_VAR 0 1
12053: PPUSH
12054: CALL_OW 255
12058: ST_TO_ADDR
// tech_space := tech_spacanom ;
12059: LD_ADDR_VAR 0 12
12063: PUSH
12064: LD_INT 29
12066: ST_TO_ADDR
// tech_time := tech_taurad ;
12067: LD_ADDR_VAR 0 13
12071: PUSH
12072: LD_INT 28
12074: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12075: LD_ADDR_VAR 0 11
12079: PUSH
12080: LD_VAR 0 1
12084: PPUSH
12085: CALL_OW 310
12089: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12090: LD_VAR 0 11
12094: PPUSH
12095: CALL_OW 247
12099: PUSH
12100: LD_INT 2
12102: EQUAL
12103: IFFALSE 12107
// exit ;
12105: GO 12617
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12107: LD_ADDR_VAR 0 8
12111: PUSH
12112: LD_INT 81
12114: PUSH
12115: LD_VAR 0 9
12119: PUSH
12120: EMPTY
12121: LIST
12122: LIST
12123: PUSH
12124: LD_INT 3
12126: PUSH
12127: LD_INT 21
12129: PUSH
12130: LD_INT 3
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: PUSH
12137: EMPTY
12138: LIST
12139: LIST
12140: PUSH
12141: EMPTY
12142: LIST
12143: LIST
12144: PPUSH
12145: CALL_OW 69
12149: ST_TO_ADDR
// if not tmp then
12150: LD_VAR 0 8
12154: NOT
12155: IFFALSE 12159
// exit ;
12157: GO 12617
// if in_unit then
12159: LD_VAR 0 11
12163: IFFALSE 12187
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12165: LD_ADDR_VAR 0 10
12169: PUSH
12170: LD_VAR 0 8
12174: PPUSH
12175: LD_VAR 0 11
12179: PPUSH
12180: CALL_OW 74
12184: ST_TO_ADDR
12185: GO 12207
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12187: LD_ADDR_VAR 0 10
12191: PUSH
12192: LD_VAR 0 8
12196: PPUSH
12197: LD_VAR 0 1
12201: PPUSH
12202: CALL_OW 74
12206: ST_TO_ADDR
// if not enemy then
12207: LD_VAR 0 10
12211: NOT
12212: IFFALSE 12216
// exit ;
12214: GO 12617
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12216: LD_VAR 0 11
12220: PUSH
12221: LD_VAR 0 11
12225: PPUSH
12226: LD_VAR 0 10
12230: PPUSH
12231: CALL_OW 296
12235: PUSH
12236: LD_INT 13
12238: GREATER
12239: AND
12240: PUSH
12241: LD_VAR 0 1
12245: PPUSH
12246: LD_VAR 0 10
12250: PPUSH
12251: CALL_OW 296
12255: PUSH
12256: LD_INT 12
12258: GREATER
12259: OR
12260: IFFALSE 12264
// exit ;
12262: GO 12617
// missile := [ 1 ] ;
12264: LD_ADDR_VAR 0 14
12268: PUSH
12269: LD_INT 1
12271: PUSH
12272: EMPTY
12273: LIST
12274: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12275: LD_VAR 0 9
12279: PPUSH
12280: LD_VAR 0 12
12284: PPUSH
12285: CALL_OW 325
12289: IFFALSE 12318
// missile := Insert ( missile , missile + 1 , 2 ) ;
12291: LD_ADDR_VAR 0 14
12295: PUSH
12296: LD_VAR 0 14
12300: PPUSH
12301: LD_VAR 0 14
12305: PUSH
12306: LD_INT 1
12308: PLUS
12309: PPUSH
12310: LD_INT 2
12312: PPUSH
12313: CALL_OW 2
12317: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12318: LD_VAR 0 9
12322: PPUSH
12323: LD_VAR 0 13
12327: PPUSH
12328: CALL_OW 325
12332: PUSH
12333: LD_VAR 0 10
12337: PPUSH
12338: CALL_OW 255
12342: PPUSH
12343: LD_VAR 0 13
12347: PPUSH
12348: CALL_OW 325
12352: NOT
12353: AND
12354: IFFALSE 12383
// missile := Insert ( missile , missile + 1 , 3 ) ;
12356: LD_ADDR_VAR 0 14
12360: PUSH
12361: LD_VAR 0 14
12365: PPUSH
12366: LD_VAR 0 14
12370: PUSH
12371: LD_INT 1
12373: PLUS
12374: PPUSH
12375: LD_INT 3
12377: PPUSH
12378: CALL_OW 2
12382: ST_TO_ADDR
// if missile < 2 then
12383: LD_VAR 0 14
12387: PUSH
12388: LD_INT 2
12390: LESS
12391: IFFALSE 12395
// exit ;
12393: GO 12617
// x := GetX ( enemy ) ;
12395: LD_ADDR_VAR 0 4
12399: PUSH
12400: LD_VAR 0 10
12404: PPUSH
12405: CALL_OW 250
12409: ST_TO_ADDR
// y := GetY ( enemy ) ;
12410: LD_ADDR_VAR 0 5
12414: PUSH
12415: LD_VAR 0 10
12419: PPUSH
12420: CALL_OW 251
12424: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12425: LD_ADDR_VAR 0 6
12429: PUSH
12430: LD_VAR 0 4
12434: PUSH
12435: LD_INT 1
12437: NEG
12438: PPUSH
12439: LD_INT 1
12441: PPUSH
12442: CALL_OW 12
12446: PLUS
12447: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12448: LD_ADDR_VAR 0 7
12452: PUSH
12453: LD_VAR 0 5
12457: PUSH
12458: LD_INT 1
12460: NEG
12461: PPUSH
12462: LD_INT 1
12464: PPUSH
12465: CALL_OW 12
12469: PLUS
12470: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12471: LD_VAR 0 6
12475: PPUSH
12476: LD_VAR 0 7
12480: PPUSH
12481: CALL_OW 488
12485: NOT
12486: IFFALSE 12508
// begin _x := x ;
12488: LD_ADDR_VAR 0 6
12492: PUSH
12493: LD_VAR 0 4
12497: ST_TO_ADDR
// _y := y ;
12498: LD_ADDR_VAR 0 7
12502: PUSH
12503: LD_VAR 0 5
12507: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12508: LD_ADDR_VAR 0 3
12512: PUSH
12513: LD_INT 1
12515: PPUSH
12516: LD_VAR 0 14
12520: PPUSH
12521: CALL_OW 12
12525: ST_TO_ADDR
// case i of 1 :
12526: LD_VAR 0 3
12530: PUSH
12531: LD_INT 1
12533: DOUBLE
12534: EQUAL
12535: IFTRUE 12539
12537: GO 12556
12539: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12540: LD_VAR 0 1
12544: PPUSH
12545: LD_VAR 0 10
12549: PPUSH
12550: CALL_OW 115
12554: GO 12617
12556: LD_INT 2
12558: DOUBLE
12559: EQUAL
12560: IFTRUE 12564
12562: GO 12586
12564: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12565: LD_VAR 0 1
12569: PPUSH
12570: LD_VAR 0 6
12574: PPUSH
12575: LD_VAR 0 7
12579: PPUSH
12580: CALL_OW 153
12584: GO 12617
12586: LD_INT 3
12588: DOUBLE
12589: EQUAL
12590: IFTRUE 12594
12592: GO 12616
12594: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12595: LD_VAR 0 1
12599: PPUSH
12600: LD_VAR 0 6
12604: PPUSH
12605: LD_VAR 0 7
12609: PPUSH
12610: CALL_OW 154
12614: GO 12617
12616: POP
// end ;
12617: LD_VAR 0 2
12621: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12622: LD_INT 0
12624: PPUSH
12625: PPUSH
12626: PPUSH
12627: PPUSH
12628: PPUSH
12629: PPUSH
// if not unit or not building then
12630: LD_VAR 0 1
12634: NOT
12635: PUSH
12636: LD_VAR 0 2
12640: NOT
12641: OR
12642: IFFALSE 12646
// exit ;
12644: GO 12804
// x := GetX ( building ) ;
12646: LD_ADDR_VAR 0 5
12650: PUSH
12651: LD_VAR 0 2
12655: PPUSH
12656: CALL_OW 250
12660: ST_TO_ADDR
// y := GetY ( building ) ;
12661: LD_ADDR_VAR 0 6
12665: PUSH
12666: LD_VAR 0 2
12670: PPUSH
12671: CALL_OW 251
12675: ST_TO_ADDR
// for i = 0 to 5 do
12676: LD_ADDR_VAR 0 4
12680: PUSH
12681: DOUBLE
12682: LD_INT 0
12684: DEC
12685: ST_TO_ADDR
12686: LD_INT 5
12688: PUSH
12689: FOR_TO
12690: IFFALSE 12802
// begin _x := ShiftX ( x , i , 3 ) ;
12692: LD_ADDR_VAR 0 7
12696: PUSH
12697: LD_VAR 0 5
12701: PPUSH
12702: LD_VAR 0 4
12706: PPUSH
12707: LD_INT 3
12709: PPUSH
12710: CALL_OW 272
12714: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12715: LD_ADDR_VAR 0 8
12719: PUSH
12720: LD_VAR 0 6
12724: PPUSH
12725: LD_VAR 0 4
12729: PPUSH
12730: LD_INT 3
12732: PPUSH
12733: CALL_OW 273
12737: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12738: LD_VAR 0 7
12742: PPUSH
12743: LD_VAR 0 8
12747: PPUSH
12748: CALL_OW 488
12752: NOT
12753: IFFALSE 12757
// continue ;
12755: GO 12689
// if HexInfo ( _x , _y ) = 0 then
12757: LD_VAR 0 7
12761: PPUSH
12762: LD_VAR 0 8
12766: PPUSH
12767: CALL_OW 428
12771: PUSH
12772: LD_INT 0
12774: EQUAL
12775: IFFALSE 12800
// begin ComMoveXY ( unit , _x , _y ) ;
12777: LD_VAR 0 1
12781: PPUSH
12782: LD_VAR 0 7
12786: PPUSH
12787: LD_VAR 0 8
12791: PPUSH
12792: CALL_OW 111
// exit ;
12796: POP
12797: POP
12798: GO 12804
// end ; end ;
12800: GO 12689
12802: POP
12803: POP
// end ;
12804: LD_VAR 0 3
12808: RET
// export function ScanBase ( side , base_area ) ; begin
12809: LD_INT 0
12811: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12812: LD_ADDR_VAR 0 3
12816: PUSH
12817: LD_VAR 0 2
12821: PPUSH
12822: LD_INT 81
12824: PUSH
12825: LD_VAR 0 1
12829: PUSH
12830: EMPTY
12831: LIST
12832: LIST
12833: PPUSH
12834: CALL_OW 70
12838: ST_TO_ADDR
// end ;
12839: LD_VAR 0 3
12843: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
12844: LD_INT 0
12846: PPUSH
12847: PPUSH
12848: PPUSH
12849: PPUSH
12850: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
12851: LD_VAR 0 1
12855: NOT
12856: PUSH
12857: LD_EXP 52
12861: PUSH
12862: LD_VAR 0 1
12866: ARRAY
12867: NOT
12868: OR
12869: PUSH
12870: LD_VAR 0 2
12874: NOT
12875: OR
12876: PUSH
12877: LD_VAR 0 3
12881: NOT
12882: OR
12883: IFFALSE 12887
// exit ;
12885: GO 13400
// side := mc_sides [ base ] ;
12887: LD_ADDR_VAR 0 6
12891: PUSH
12892: LD_EXP 78
12896: PUSH
12897: LD_VAR 0 1
12901: ARRAY
12902: ST_TO_ADDR
// if not side then
12903: LD_VAR 0 6
12907: NOT
12908: IFFALSE 12912
// exit ;
12910: GO 13400
// for i in solds do
12912: LD_ADDR_VAR 0 7
12916: PUSH
12917: LD_VAR 0 2
12921: PUSH
12922: FOR_IN
12923: IFFALSE 12984
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
12925: LD_VAR 0 7
12929: PPUSH
12930: CALL_OW 310
12934: PPUSH
12935: CALL_OW 266
12939: PUSH
12940: LD_INT 32
12942: PUSH
12943: LD_INT 31
12945: PUSH
12946: EMPTY
12947: LIST
12948: LIST
12949: IN
12950: IFFALSE 12970
// solds := solds diff i else
12952: LD_ADDR_VAR 0 2
12956: PUSH
12957: LD_VAR 0 2
12961: PUSH
12962: LD_VAR 0 7
12966: DIFF
12967: ST_TO_ADDR
12968: GO 12982
// SetTag ( i , 18 ) ;
12970: LD_VAR 0 7
12974: PPUSH
12975: LD_INT 18
12977: PPUSH
12978: CALL_OW 109
12982: GO 12922
12984: POP
12985: POP
// if not solds then
12986: LD_VAR 0 2
12990: NOT
12991: IFFALSE 12995
// exit ;
12993: GO 13400
// repeat wait ( 0 0$1 ) ;
12995: LD_INT 35
12997: PPUSH
12998: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
13002: LD_ADDR_VAR 0 5
13006: PUSH
13007: LD_VAR 0 6
13011: PPUSH
13012: LD_VAR 0 3
13016: PPUSH
13017: CALL 12809 0 2
13021: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
13022: LD_EXP 52
13026: PUSH
13027: LD_VAR 0 1
13031: ARRAY
13032: NOT
13033: PUSH
13034: LD_EXP 52
13038: PUSH
13039: LD_VAR 0 1
13043: ARRAY
13044: PUSH
13045: EMPTY
13046: EQUAL
13047: OR
13048: IFFALSE 13085
// begin for i in solds do
13050: LD_ADDR_VAR 0 7
13054: PUSH
13055: LD_VAR 0 2
13059: PUSH
13060: FOR_IN
13061: IFFALSE 13074
// ComStop ( i ) ;
13063: LD_VAR 0 7
13067: PPUSH
13068: CALL_OW 141
13072: GO 13060
13074: POP
13075: POP
// solds := [ ] ;
13076: LD_ADDR_VAR 0 2
13080: PUSH
13081: EMPTY
13082: ST_TO_ADDR
// exit ;
13083: GO 13400
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
13085: LD_VAR 0 5
13089: NOT
13090: PUSH
13091: LD_VAR 0 5
13095: PUSH
13096: LD_INT 3
13098: GREATER
13099: OR
13100: PUSH
13101: LD_EXP 74
13105: PUSH
13106: LD_VAR 0 1
13110: ARRAY
13111: OR
13112: IFFALSE 13153
// begin for i in solds do
13114: LD_ADDR_VAR 0 7
13118: PUSH
13119: LD_VAR 0 2
13123: PUSH
13124: FOR_IN
13125: IFFALSE 13149
// if HasTask ( i ) then
13127: LD_VAR 0 7
13131: PPUSH
13132: CALL_OW 314
13136: IFFALSE 13147
// ComStop ( i ) ;
13138: LD_VAR 0 7
13142: PPUSH
13143: CALL_OW 141
13147: GO 13124
13149: POP
13150: POP
// break ;
13151: GO 13388
// end ; for i in solds do
13153: LD_ADDR_VAR 0 7
13157: PUSH
13158: LD_VAR 0 2
13162: PUSH
13163: FOR_IN
13164: IFFALSE 13380
// begin if IsInUnit ( i ) then
13166: LD_VAR 0 7
13170: PPUSH
13171: CALL_OW 310
13175: IFFALSE 13186
// ComExitBuilding ( i ) ;
13177: LD_VAR 0 7
13181: PPUSH
13182: CALL_OW 122
// if GetLives ( i ) > 333 then
13186: LD_VAR 0 7
13190: PPUSH
13191: CALL_OW 256
13195: PUSH
13196: LD_INT 333
13198: GREATER
13199: IFFALSE 13227
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
13201: LD_VAR 0 7
13205: PPUSH
13206: LD_VAR 0 5
13210: PPUSH
13211: LD_VAR 0 7
13215: PPUSH
13216: CALL_OW 74
13220: PPUSH
13221: CALL_OW 115
13225: GO 13378
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
13227: LD_ADDR_VAR 0 8
13231: PUSH
13232: LD_EXP 52
13236: PUSH
13237: LD_VAR 0 1
13241: ARRAY
13242: PPUSH
13243: LD_INT 2
13245: PUSH
13246: LD_INT 30
13248: PUSH
13249: LD_INT 0
13251: PUSH
13252: EMPTY
13253: LIST
13254: LIST
13255: PUSH
13256: LD_INT 30
13258: PUSH
13259: LD_INT 1
13261: PUSH
13262: EMPTY
13263: LIST
13264: LIST
13265: PUSH
13266: LD_INT 30
13268: PUSH
13269: LD_INT 6
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: PUSH
13276: EMPTY
13277: LIST
13278: LIST
13279: LIST
13280: LIST
13281: PPUSH
13282: CALL_OW 72
13286: PPUSH
13287: LD_VAR 0 7
13291: PPUSH
13292: CALL_OW 74
13296: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
13297: LD_VAR 0 7
13301: PPUSH
13302: LD_VAR 0 8
13306: PPUSH
13307: CALL_OW 250
13311: PPUSH
13312: LD_INT 3
13314: PPUSH
13315: LD_INT 5
13317: PPUSH
13318: CALL_OW 272
13322: PPUSH
13323: LD_VAR 0 8
13327: PPUSH
13328: CALL_OW 251
13332: PPUSH
13333: LD_INT 3
13335: PPUSH
13336: LD_INT 5
13338: PPUSH
13339: CALL_OW 273
13343: PPUSH
13344: CALL_OW 111
// SetTag ( i , 0 ) ;
13348: LD_VAR 0 7
13352: PPUSH
13353: LD_INT 0
13355: PPUSH
13356: CALL_OW 109
// solds := solds diff i ;
13360: LD_ADDR_VAR 0 2
13364: PUSH
13365: LD_VAR 0 2
13369: PUSH
13370: LD_VAR 0 7
13374: DIFF
13375: ST_TO_ADDR
// continue ;
13376: GO 13163
// end ; end ;
13378: GO 13163
13380: POP
13381: POP
// until solds ;
13382: LD_VAR 0 2
13386: IFFALSE 12995
// MC_Reset ( base , 18 ) ;
13388: LD_VAR 0 1
13392: PPUSH
13393: LD_INT 18
13395: PPUSH
13396: CALL 58476 0 2
// end ;
13400: LD_VAR 0 4
13404: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
13405: LD_INT 0
13407: PPUSH
13408: PPUSH
13409: PPUSH
13410: PPUSH
13411: PPUSH
13412: PPUSH
13413: PPUSH
13414: PPUSH
13415: PPUSH
13416: PPUSH
13417: PPUSH
13418: PPUSH
13419: PPUSH
13420: PPUSH
13421: PPUSH
13422: PPUSH
13423: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
13424: LD_ADDR_VAR 0 13
13428: PUSH
13429: LD_EXP 52
13433: PUSH
13434: LD_VAR 0 1
13438: ARRAY
13439: PPUSH
13440: LD_INT 25
13442: PUSH
13443: LD_INT 3
13445: PUSH
13446: EMPTY
13447: LIST
13448: LIST
13449: PPUSH
13450: CALL_OW 72
13454: ST_TO_ADDR
// if mc_remote_driver [ base ] then
13455: LD_EXP 92
13459: PUSH
13460: LD_VAR 0 1
13464: ARRAY
13465: IFFALSE 13489
// mechs := mechs diff mc_remote_driver [ base ] ;
13467: LD_ADDR_VAR 0 13
13471: PUSH
13472: LD_VAR 0 13
13476: PUSH
13477: LD_EXP 92
13481: PUSH
13482: LD_VAR 0 1
13486: ARRAY
13487: DIFF
13488: ST_TO_ADDR
// for i in mechs do
13489: LD_ADDR_VAR 0 5
13493: PUSH
13494: LD_VAR 0 13
13498: PUSH
13499: FOR_IN
13500: IFFALSE 13535
// if GetTag ( i ) > 0 then
13502: LD_VAR 0 5
13506: PPUSH
13507: CALL_OW 110
13511: PUSH
13512: LD_INT 0
13514: GREATER
13515: IFFALSE 13533
// mechs := mechs diff i ;
13517: LD_ADDR_VAR 0 13
13521: PUSH
13522: LD_VAR 0 13
13526: PUSH
13527: LD_VAR 0 5
13531: DIFF
13532: ST_TO_ADDR
13533: GO 13499
13535: POP
13536: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
13537: LD_ADDR_VAR 0 9
13541: PUSH
13542: LD_EXP 52
13546: PUSH
13547: LD_VAR 0 1
13551: ARRAY
13552: PPUSH
13553: LD_INT 2
13555: PUSH
13556: LD_INT 25
13558: PUSH
13559: LD_INT 1
13561: PUSH
13562: EMPTY
13563: LIST
13564: LIST
13565: PUSH
13566: LD_INT 25
13568: PUSH
13569: LD_INT 5
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: PUSH
13576: LD_INT 25
13578: PUSH
13579: LD_INT 8
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: PUSH
13586: LD_INT 25
13588: PUSH
13589: LD_INT 9
13591: PUSH
13592: EMPTY
13593: LIST
13594: LIST
13595: PUSH
13596: EMPTY
13597: LIST
13598: LIST
13599: LIST
13600: LIST
13601: LIST
13602: PPUSH
13603: CALL_OW 72
13607: ST_TO_ADDR
// if not defenders and not solds then
13608: LD_VAR 0 2
13612: NOT
13613: PUSH
13614: LD_VAR 0 9
13618: NOT
13619: AND
13620: IFFALSE 13624
// exit ;
13622: GO 15250
// depot_under_attack := false ;
13624: LD_ADDR_VAR 0 17
13628: PUSH
13629: LD_INT 0
13631: ST_TO_ADDR
// sold_defenders := [ ] ;
13632: LD_ADDR_VAR 0 18
13636: PUSH
13637: EMPTY
13638: ST_TO_ADDR
// if mechs then
13639: LD_VAR 0 13
13643: IFFALSE 13772
// for i in defenders do
13645: LD_ADDR_VAR 0 5
13649: PUSH
13650: LD_VAR 0 2
13654: PUSH
13655: FOR_IN
13656: IFFALSE 13770
// begin SetTag ( i , 20 ) ;
13658: LD_VAR 0 5
13662: PPUSH
13663: LD_INT 20
13665: PPUSH
13666: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
13670: LD_VAR 0 5
13674: PPUSH
13675: CALL_OW 263
13679: PUSH
13680: LD_INT 1
13682: EQUAL
13683: PUSH
13684: LD_VAR 0 5
13688: PPUSH
13689: CALL_OW 311
13693: NOT
13694: AND
13695: PUSH
13696: LD_VAR 0 13
13700: AND
13701: IFFALSE 13768
// begin un := mechs [ 1 ] ;
13703: LD_ADDR_VAR 0 11
13707: PUSH
13708: LD_VAR 0 13
13712: PUSH
13713: LD_INT 1
13715: ARRAY
13716: ST_TO_ADDR
// ComExitBuilding ( un ) ;
13717: LD_VAR 0 11
13721: PPUSH
13722: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
13726: LD_VAR 0 11
13730: PPUSH
13731: LD_VAR 0 5
13735: PPUSH
13736: CALL_OW 180
// SetTag ( un , 19 ) ;
13740: LD_VAR 0 11
13744: PPUSH
13745: LD_INT 19
13747: PPUSH
13748: CALL_OW 109
// mechs := mechs diff un ;
13752: LD_ADDR_VAR 0 13
13756: PUSH
13757: LD_VAR 0 13
13761: PUSH
13762: LD_VAR 0 11
13766: DIFF
13767: ST_TO_ADDR
// end ; end ;
13768: GO 13655
13770: POP
13771: POP
// if solds then
13772: LD_VAR 0 9
13776: IFFALSE 13835
// for i in solds do
13778: LD_ADDR_VAR 0 5
13782: PUSH
13783: LD_VAR 0 9
13787: PUSH
13788: FOR_IN
13789: IFFALSE 13833
// if not GetTag ( i ) then
13791: LD_VAR 0 5
13795: PPUSH
13796: CALL_OW 110
13800: NOT
13801: IFFALSE 13831
// begin defenders := defenders union i ;
13803: LD_ADDR_VAR 0 2
13807: PUSH
13808: LD_VAR 0 2
13812: PUSH
13813: LD_VAR 0 5
13817: UNION
13818: ST_TO_ADDR
// SetTag ( i , 18 ) ;
13819: LD_VAR 0 5
13823: PPUSH
13824: LD_INT 18
13826: PPUSH
13827: CALL_OW 109
// end ;
13831: GO 13788
13833: POP
13834: POP
// repeat wait ( 0 0$1 ) ;
13835: LD_INT 35
13837: PPUSH
13838: CALL_OW 67
// enemy := mc_scan [ base ] ;
13842: LD_ADDR_VAR 0 3
13846: PUSH
13847: LD_EXP 75
13851: PUSH
13852: LD_VAR 0 1
13856: ARRAY
13857: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
13858: LD_EXP 52
13862: PUSH
13863: LD_VAR 0 1
13867: ARRAY
13868: NOT
13869: PUSH
13870: LD_EXP 52
13874: PUSH
13875: LD_VAR 0 1
13879: ARRAY
13880: PUSH
13881: EMPTY
13882: EQUAL
13883: OR
13884: IFFALSE 13921
// begin for i in defenders do
13886: LD_ADDR_VAR 0 5
13890: PUSH
13891: LD_VAR 0 2
13895: PUSH
13896: FOR_IN
13897: IFFALSE 13910
// ComStop ( i ) ;
13899: LD_VAR 0 5
13903: PPUSH
13904: CALL_OW 141
13908: GO 13896
13910: POP
13911: POP
// defenders := [ ] ;
13912: LD_ADDR_VAR 0 2
13916: PUSH
13917: EMPTY
13918: ST_TO_ADDR
// exit ;
13919: GO 15250
// end ; for i in defenders do
13921: LD_ADDR_VAR 0 5
13925: PUSH
13926: LD_VAR 0 2
13930: PUSH
13931: FOR_IN
13932: IFFALSE 14750
// begin e := NearestUnitToUnit ( enemy , i ) ;
13934: LD_ADDR_VAR 0 14
13938: PUSH
13939: LD_VAR 0 3
13943: PPUSH
13944: LD_VAR 0 5
13948: PPUSH
13949: CALL_OW 74
13953: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
13954: LD_ADDR_VAR 0 8
13958: PUSH
13959: LD_EXP 52
13963: PUSH
13964: LD_VAR 0 1
13968: ARRAY
13969: PPUSH
13970: LD_INT 2
13972: PUSH
13973: LD_INT 30
13975: PUSH
13976: LD_INT 0
13978: PUSH
13979: EMPTY
13980: LIST
13981: LIST
13982: PUSH
13983: LD_INT 30
13985: PUSH
13986: LD_INT 1
13988: PUSH
13989: EMPTY
13990: LIST
13991: LIST
13992: PUSH
13993: EMPTY
13994: LIST
13995: LIST
13996: LIST
13997: PPUSH
13998: CALL_OW 72
14002: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
14003: LD_ADDR_VAR 0 17
14007: PUSH
14008: LD_VAR 0 8
14012: NOT
14013: PUSH
14014: LD_VAR 0 8
14018: PPUSH
14019: LD_INT 3
14021: PUSH
14022: LD_INT 24
14024: PUSH
14025: LD_INT 600
14027: PUSH
14028: EMPTY
14029: LIST
14030: LIST
14031: PUSH
14032: EMPTY
14033: LIST
14034: LIST
14035: PPUSH
14036: CALL_OW 72
14040: OR
14041: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
14042: LD_VAR 0 5
14046: PPUSH
14047: CALL_OW 247
14051: PUSH
14052: LD_INT 2
14054: DOUBLE
14055: EQUAL
14056: IFTRUE 14060
14058: GO 14456
14060: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
14061: LD_VAR 0 5
14065: PPUSH
14066: CALL_OW 256
14070: PUSH
14071: LD_INT 650
14073: GREATER
14074: PUSH
14075: LD_VAR 0 5
14079: PPUSH
14080: LD_VAR 0 14
14084: PPUSH
14085: CALL_OW 296
14089: PUSH
14090: LD_INT 40
14092: LESS
14093: PUSH
14094: LD_VAR 0 14
14098: PPUSH
14099: LD_EXP 77
14103: PUSH
14104: LD_VAR 0 1
14108: ARRAY
14109: PPUSH
14110: CALL_OW 308
14114: OR
14115: AND
14116: IFFALSE 14238
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
14118: LD_VAR 0 5
14122: PPUSH
14123: CALL_OW 262
14127: PUSH
14128: LD_INT 1
14130: EQUAL
14131: PUSH
14132: LD_VAR 0 5
14136: PPUSH
14137: CALL_OW 261
14141: PUSH
14142: LD_INT 30
14144: LESS
14145: AND
14146: PUSH
14147: LD_VAR 0 8
14151: AND
14152: IFFALSE 14222
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
14154: LD_VAR 0 5
14158: PPUSH
14159: LD_VAR 0 8
14163: PPUSH
14164: LD_VAR 0 5
14168: PPUSH
14169: CALL_OW 74
14173: PPUSH
14174: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
14178: LD_VAR 0 5
14182: PPUSH
14183: LD_VAR 0 8
14187: PPUSH
14188: LD_VAR 0 5
14192: PPUSH
14193: CALL_OW 74
14197: PPUSH
14198: CALL_OW 296
14202: PUSH
14203: LD_INT 6
14205: LESS
14206: IFFALSE 14220
// SetFuel ( i , 100 ) ;
14208: LD_VAR 0 5
14212: PPUSH
14213: LD_INT 100
14215: PPUSH
14216: CALL_OW 240
// end else
14220: GO 14236
// ComAttackUnit ( i , e ) ;
14222: LD_VAR 0 5
14226: PPUSH
14227: LD_VAR 0 14
14231: PPUSH
14232: CALL_OW 115
// end else
14236: GO 14339
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
14238: LD_VAR 0 14
14242: PPUSH
14243: LD_EXP 77
14247: PUSH
14248: LD_VAR 0 1
14252: ARRAY
14253: PPUSH
14254: CALL_OW 308
14258: NOT
14259: PUSH
14260: LD_VAR 0 5
14264: PPUSH
14265: LD_VAR 0 14
14269: PPUSH
14270: CALL_OW 296
14274: PUSH
14275: LD_INT 40
14277: GREATEREQUAL
14278: AND
14279: PUSH
14280: LD_VAR 0 5
14284: PPUSH
14285: CALL_OW 256
14289: PUSH
14290: LD_INT 650
14292: LESSEQUAL
14293: OR
14294: PUSH
14295: LD_VAR 0 5
14299: PPUSH
14300: LD_EXP 76
14304: PUSH
14305: LD_VAR 0 1
14309: ARRAY
14310: PPUSH
14311: CALL_OW 308
14315: NOT
14316: AND
14317: IFFALSE 14339
// ComMoveToArea ( i , mc_parking [ base ] ) ;
14319: LD_VAR 0 5
14323: PPUSH
14324: LD_EXP 76
14328: PUSH
14329: LD_VAR 0 1
14333: ARRAY
14334: PPUSH
14335: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
14339: LD_VAR 0 5
14343: PPUSH
14344: CALL_OW 256
14348: PUSH
14349: LD_INT 998
14351: LESS
14352: PUSH
14353: LD_VAR 0 5
14357: PPUSH
14358: CALL_OW 263
14362: PUSH
14363: LD_INT 1
14365: EQUAL
14366: AND
14367: PUSH
14368: LD_VAR 0 5
14372: PPUSH
14373: CALL_OW 311
14377: AND
14378: PUSH
14379: LD_VAR 0 5
14383: PPUSH
14384: LD_EXP 76
14388: PUSH
14389: LD_VAR 0 1
14393: ARRAY
14394: PPUSH
14395: CALL_OW 308
14399: AND
14400: IFFALSE 14454
// begin mech := IsDrivenBy ( i ) ;
14402: LD_ADDR_VAR 0 10
14406: PUSH
14407: LD_VAR 0 5
14411: PPUSH
14412: CALL_OW 311
14416: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
14417: LD_VAR 0 10
14421: PPUSH
14422: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
14426: LD_VAR 0 10
14430: PPUSH
14431: LD_VAR 0 5
14435: PPUSH
14436: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
14440: LD_VAR 0 10
14444: PPUSH
14445: LD_VAR 0 5
14449: PPUSH
14450: CALL_OW 180
// end ; end ; unit_human :
14454: GO 14721
14456: LD_INT 1
14458: DOUBLE
14459: EQUAL
14460: IFTRUE 14464
14462: GO 14720
14464: POP
// begin b := IsInUnit ( i ) ;
14465: LD_ADDR_VAR 0 19
14469: PUSH
14470: LD_VAR 0 5
14474: PPUSH
14475: CALL_OW 310
14479: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
14480: LD_ADDR_VAR 0 20
14484: PUSH
14485: LD_VAR 0 19
14489: NOT
14490: PUSH
14491: LD_VAR 0 19
14495: PPUSH
14496: CALL_OW 266
14500: PUSH
14501: LD_INT 32
14503: PUSH
14504: LD_INT 31
14506: PUSH
14507: EMPTY
14508: LIST
14509: LIST
14510: IN
14511: OR
14512: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
14513: LD_VAR 0 17
14517: PUSH
14518: LD_VAR 0 2
14522: PPUSH
14523: LD_INT 21
14525: PUSH
14526: LD_INT 2
14528: PUSH
14529: EMPTY
14530: LIST
14531: LIST
14532: PPUSH
14533: CALL_OW 72
14537: PUSH
14538: LD_INT 1
14540: LESSEQUAL
14541: OR
14542: PUSH
14543: LD_VAR 0 20
14547: AND
14548: PUSH
14549: LD_VAR 0 5
14553: PUSH
14554: LD_VAR 0 18
14558: IN
14559: NOT
14560: AND
14561: IFFALSE 14654
// begin if b then
14563: LD_VAR 0 19
14567: IFFALSE 14616
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
14569: LD_VAR 0 19
14573: PPUSH
14574: LD_VAR 0 3
14578: PPUSH
14579: LD_VAR 0 19
14583: PPUSH
14584: CALL_OW 74
14588: PPUSH
14589: CALL_OW 296
14593: PUSH
14594: LD_INT 10
14596: LESS
14597: PUSH
14598: LD_VAR 0 19
14602: PPUSH
14603: CALL_OW 461
14607: PUSH
14608: LD_INT 7
14610: NONEQUAL
14611: AND
14612: IFFALSE 14616
// continue ;
14614: GO 13931
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
14616: LD_ADDR_VAR 0 18
14620: PUSH
14621: LD_VAR 0 18
14625: PPUSH
14626: LD_VAR 0 18
14630: PUSH
14631: LD_INT 1
14633: PLUS
14634: PPUSH
14635: LD_VAR 0 5
14639: PPUSH
14640: CALL_OW 1
14644: ST_TO_ADDR
// ComExitBuilding ( i ) ;
14645: LD_VAR 0 5
14649: PPUSH
14650: CALL_OW 122
// end ; if sold_defenders then
14654: LD_VAR 0 18
14658: IFFALSE 14718
// if i in sold_defenders then
14660: LD_VAR 0 5
14664: PUSH
14665: LD_VAR 0 18
14669: IN
14670: IFFALSE 14718
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
14672: LD_VAR 0 5
14676: PPUSH
14677: CALL_OW 314
14681: NOT
14682: PUSH
14683: LD_VAR 0 5
14687: PPUSH
14688: LD_VAR 0 14
14692: PPUSH
14693: CALL_OW 296
14697: PUSH
14698: LD_INT 30
14700: LESS
14701: AND
14702: IFFALSE 14718
// ComAttackUnit ( i , e ) ;
14704: LD_VAR 0 5
14708: PPUSH
14709: LD_VAR 0 14
14713: PPUSH
14714: CALL_OW 115
// end ; end ; end ;
14718: GO 14721
14720: POP
// if IsDead ( i ) then
14721: LD_VAR 0 5
14725: PPUSH
14726: CALL_OW 301
14730: IFFALSE 14748
// defenders := defenders diff i ;
14732: LD_ADDR_VAR 0 2
14736: PUSH
14737: LD_VAR 0 2
14741: PUSH
14742: LD_VAR 0 5
14746: DIFF
14747: ST_TO_ADDR
// end ;
14748: GO 13931
14750: POP
14751: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
14752: LD_VAR 0 3
14756: NOT
14757: PUSH
14758: LD_VAR 0 2
14762: NOT
14763: OR
14764: PUSH
14765: LD_EXP 52
14769: PUSH
14770: LD_VAR 0 1
14774: ARRAY
14775: NOT
14776: OR
14777: IFFALSE 13835
// MC_Reset ( base , 18 ) ;
14779: LD_VAR 0 1
14783: PPUSH
14784: LD_INT 18
14786: PPUSH
14787: CALL 58476 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
14791: LD_ADDR_VAR 0 2
14795: PUSH
14796: LD_VAR 0 2
14800: PUSH
14801: LD_VAR 0 2
14805: PPUSH
14806: LD_INT 2
14808: PUSH
14809: LD_INT 25
14811: PUSH
14812: LD_INT 1
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: PUSH
14819: LD_INT 25
14821: PUSH
14822: LD_INT 5
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: PUSH
14829: LD_INT 25
14831: PUSH
14832: LD_INT 8
14834: PUSH
14835: EMPTY
14836: LIST
14837: LIST
14838: PUSH
14839: LD_INT 25
14841: PUSH
14842: LD_INT 9
14844: PUSH
14845: EMPTY
14846: LIST
14847: LIST
14848: PUSH
14849: EMPTY
14850: LIST
14851: LIST
14852: LIST
14853: LIST
14854: LIST
14855: PPUSH
14856: CALL_OW 72
14860: DIFF
14861: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
14862: LD_VAR 0 3
14866: NOT
14867: PUSH
14868: LD_VAR 0 2
14872: PPUSH
14873: LD_INT 21
14875: PUSH
14876: LD_INT 2
14878: PUSH
14879: EMPTY
14880: LIST
14881: LIST
14882: PPUSH
14883: CALL_OW 72
14887: AND
14888: IFFALSE 15226
// begin tmp := FilterByTag ( defenders , 19 ) ;
14890: LD_ADDR_VAR 0 12
14894: PUSH
14895: LD_VAR 0 2
14899: PPUSH
14900: LD_INT 19
14902: PPUSH
14903: CALL 51689 0 2
14907: ST_TO_ADDR
// if tmp then
14908: LD_VAR 0 12
14912: IFFALSE 14982
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
14914: LD_ADDR_VAR 0 12
14918: PUSH
14919: LD_VAR 0 12
14923: PPUSH
14924: LD_INT 25
14926: PUSH
14927: LD_INT 3
14929: PUSH
14930: EMPTY
14931: LIST
14932: LIST
14933: PPUSH
14934: CALL_OW 72
14938: ST_TO_ADDR
// if tmp then
14939: LD_VAR 0 12
14943: IFFALSE 14982
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
14945: LD_ADDR_EXP 64
14949: PUSH
14950: LD_EXP 64
14954: PPUSH
14955: LD_VAR 0 1
14959: PPUSH
14960: LD_EXP 64
14964: PUSH
14965: LD_VAR 0 1
14969: ARRAY
14970: PUSH
14971: LD_VAR 0 12
14975: UNION
14976: PPUSH
14977: CALL_OW 1
14981: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
14982: LD_VAR 0 1
14986: PPUSH
14987: LD_INT 19
14989: PPUSH
14990: CALL 58476 0 2
// repeat wait ( 0 0$1 ) ;
14994: LD_INT 35
14996: PPUSH
14997: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
15001: LD_EXP 52
15005: PUSH
15006: LD_VAR 0 1
15010: ARRAY
15011: NOT
15012: PUSH
15013: LD_EXP 52
15017: PUSH
15018: LD_VAR 0 1
15022: ARRAY
15023: PUSH
15024: EMPTY
15025: EQUAL
15026: OR
15027: IFFALSE 15064
// begin for i in defenders do
15029: LD_ADDR_VAR 0 5
15033: PUSH
15034: LD_VAR 0 2
15038: PUSH
15039: FOR_IN
15040: IFFALSE 15053
// ComStop ( i ) ;
15042: LD_VAR 0 5
15046: PPUSH
15047: CALL_OW 141
15051: GO 15039
15053: POP
15054: POP
// defenders := [ ] ;
15055: LD_ADDR_VAR 0 2
15059: PUSH
15060: EMPTY
15061: ST_TO_ADDR
// exit ;
15062: GO 15250
// end ; for i in defenders do
15064: LD_ADDR_VAR 0 5
15068: PUSH
15069: LD_VAR 0 2
15073: PUSH
15074: FOR_IN
15075: IFFALSE 15164
// begin if not IsInArea ( i , mc_parking [ base ] ) then
15077: LD_VAR 0 5
15081: PPUSH
15082: LD_EXP 76
15086: PUSH
15087: LD_VAR 0 1
15091: ARRAY
15092: PPUSH
15093: CALL_OW 308
15097: NOT
15098: IFFALSE 15122
// ComMoveToArea ( i , mc_parking [ base ] ) else
15100: LD_VAR 0 5
15104: PPUSH
15105: LD_EXP 76
15109: PUSH
15110: LD_VAR 0 1
15114: ARRAY
15115: PPUSH
15116: CALL_OW 113
15120: GO 15162
// if GetControl ( i ) = control_manual then
15122: LD_VAR 0 5
15126: PPUSH
15127: CALL_OW 263
15131: PUSH
15132: LD_INT 1
15134: EQUAL
15135: IFFALSE 15162
// if IsDrivenBy ( i ) then
15137: LD_VAR 0 5
15141: PPUSH
15142: CALL_OW 311
15146: IFFALSE 15162
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
15148: LD_VAR 0 5
15152: PPUSH
15153: CALL_OW 311
15157: PPUSH
15158: CALL_OW 121
// end ;
15162: GO 15074
15164: POP
15165: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
15166: LD_VAR 0 2
15170: PPUSH
15171: LD_INT 95
15173: PUSH
15174: LD_EXP 76
15178: PUSH
15179: LD_VAR 0 1
15183: ARRAY
15184: PUSH
15185: EMPTY
15186: LIST
15187: LIST
15188: PPUSH
15189: CALL_OW 72
15193: PUSH
15194: LD_VAR 0 2
15198: EQUAL
15199: PUSH
15200: LD_EXP 75
15204: PUSH
15205: LD_VAR 0 1
15209: ARRAY
15210: OR
15211: PUSH
15212: LD_EXP 52
15216: PUSH
15217: LD_VAR 0 1
15221: ARRAY
15222: NOT
15223: OR
15224: IFFALSE 14994
// end ; MC_Reset ( base , 19 ) ;
15226: LD_VAR 0 1
15230: PPUSH
15231: LD_INT 19
15233: PPUSH
15234: CALL 58476 0 2
// MC_Reset ( base , 20 ) ;
15238: LD_VAR 0 1
15242: PPUSH
15243: LD_INT 20
15245: PPUSH
15246: CALL 58476 0 2
// end ;
15250: LD_VAR 0 4
15254: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15255: LD_INT 0
15257: PPUSH
15258: PPUSH
15259: PPUSH
15260: PPUSH
// result := false ;
15261: LD_ADDR_VAR 0 2
15265: PUSH
15266: LD_INT 0
15268: ST_TO_ADDR
// side := GetSide ( unit ) ;
15269: LD_ADDR_VAR 0 3
15273: PUSH
15274: LD_VAR 0 1
15278: PPUSH
15279: CALL_OW 255
15283: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15284: LD_ADDR_VAR 0 4
15288: PUSH
15289: LD_VAR 0 1
15293: PPUSH
15294: CALL_OW 248
15298: ST_TO_ADDR
// case nat of 1 :
15299: LD_VAR 0 4
15303: PUSH
15304: LD_INT 1
15306: DOUBLE
15307: EQUAL
15308: IFTRUE 15312
15310: GO 15323
15312: POP
// tech := tech_lassight ; 2 :
15313: LD_ADDR_VAR 0 5
15317: PUSH
15318: LD_INT 12
15320: ST_TO_ADDR
15321: GO 15362
15323: LD_INT 2
15325: DOUBLE
15326: EQUAL
15327: IFTRUE 15331
15329: GO 15342
15331: POP
// tech := tech_mortar ; 3 :
15332: LD_ADDR_VAR 0 5
15336: PUSH
15337: LD_INT 41
15339: ST_TO_ADDR
15340: GO 15362
15342: LD_INT 3
15344: DOUBLE
15345: EQUAL
15346: IFTRUE 15350
15348: GO 15361
15350: POP
// tech := tech_bazooka ; end ;
15351: LD_ADDR_VAR 0 5
15355: PUSH
15356: LD_INT 44
15358: ST_TO_ADDR
15359: GO 15362
15361: POP
// if Researched ( side , tech ) then
15362: LD_VAR 0 3
15366: PPUSH
15367: LD_VAR 0 5
15371: PPUSH
15372: CALL_OW 325
15376: IFFALSE 15403
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15378: LD_ADDR_VAR 0 2
15382: PUSH
15383: LD_INT 5
15385: PUSH
15386: LD_INT 8
15388: PUSH
15389: LD_INT 9
15391: PUSH
15392: EMPTY
15393: LIST
15394: LIST
15395: LIST
15396: PUSH
15397: LD_VAR 0 4
15401: ARRAY
15402: ST_TO_ADDR
// end ;
15403: LD_VAR 0 2
15407: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15408: LD_INT 0
15410: PPUSH
15411: PPUSH
15412: PPUSH
// if not mines then
15413: LD_VAR 0 2
15417: NOT
15418: IFFALSE 15422
// exit ;
15420: GO 15566
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15422: LD_ADDR_VAR 0 5
15426: PUSH
15427: LD_INT 81
15429: PUSH
15430: LD_VAR 0 1
15434: PUSH
15435: EMPTY
15436: LIST
15437: LIST
15438: PUSH
15439: LD_INT 3
15441: PUSH
15442: LD_INT 21
15444: PUSH
15445: LD_INT 3
15447: PUSH
15448: EMPTY
15449: LIST
15450: LIST
15451: PUSH
15452: EMPTY
15453: LIST
15454: LIST
15455: PUSH
15456: EMPTY
15457: LIST
15458: LIST
15459: PPUSH
15460: CALL_OW 69
15464: ST_TO_ADDR
// for i in mines do
15465: LD_ADDR_VAR 0 4
15469: PUSH
15470: LD_VAR 0 2
15474: PUSH
15475: FOR_IN
15476: IFFALSE 15564
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15478: LD_VAR 0 4
15482: PUSH
15483: LD_INT 1
15485: ARRAY
15486: PPUSH
15487: LD_VAR 0 4
15491: PUSH
15492: LD_INT 2
15494: ARRAY
15495: PPUSH
15496: CALL_OW 458
15500: NOT
15501: IFFALSE 15505
// continue ;
15503: GO 15475
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15505: LD_VAR 0 4
15509: PUSH
15510: LD_INT 1
15512: ARRAY
15513: PPUSH
15514: LD_VAR 0 4
15518: PUSH
15519: LD_INT 2
15521: ARRAY
15522: PPUSH
15523: CALL_OW 428
15527: PUSH
15528: LD_VAR 0 5
15532: IN
15533: IFFALSE 15562
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15535: LD_VAR 0 4
15539: PUSH
15540: LD_INT 1
15542: ARRAY
15543: PPUSH
15544: LD_VAR 0 4
15548: PUSH
15549: LD_INT 2
15551: ARRAY
15552: PPUSH
15553: LD_VAR 0 1
15557: PPUSH
15558: CALL_OW 456
// end ;
15562: GO 15475
15564: POP
15565: POP
// end ;
15566: LD_VAR 0 3
15570: RET
// export function Count ( array ) ; var i ; begin
15571: LD_INT 0
15573: PPUSH
15574: PPUSH
// result := 0 ;
15575: LD_ADDR_VAR 0 2
15579: PUSH
15580: LD_INT 0
15582: ST_TO_ADDR
// for i in array do
15583: LD_ADDR_VAR 0 3
15587: PUSH
15588: LD_VAR 0 1
15592: PUSH
15593: FOR_IN
15594: IFFALSE 15618
// if i then
15596: LD_VAR 0 3
15600: IFFALSE 15616
// result := result + 1 ;
15602: LD_ADDR_VAR 0 2
15606: PUSH
15607: LD_VAR 0 2
15611: PUSH
15612: LD_INT 1
15614: PLUS
15615: ST_TO_ADDR
15616: GO 15593
15618: POP
15619: POP
// end ;
15620: LD_VAR 0 2
15624: RET
// export function IsEmpty ( building ) ; begin
15625: LD_INT 0
15627: PPUSH
// if not building then
15628: LD_VAR 0 1
15632: NOT
15633: IFFALSE 15637
// exit ;
15635: GO 15680
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15637: LD_ADDR_VAR 0 2
15641: PUSH
15642: LD_VAR 0 1
15646: PUSH
15647: LD_INT 22
15649: PUSH
15650: LD_VAR 0 1
15654: PPUSH
15655: CALL_OW 255
15659: PUSH
15660: EMPTY
15661: LIST
15662: LIST
15663: PUSH
15664: LD_INT 58
15666: PUSH
15667: EMPTY
15668: LIST
15669: PUSH
15670: EMPTY
15671: LIST
15672: LIST
15673: PPUSH
15674: CALL_OW 69
15678: IN
15679: ST_TO_ADDR
// end ;
15680: LD_VAR 0 2
15684: RET
// export function IsNotFull ( building ) ; begin
15685: LD_INT 0
15687: PPUSH
// if not building then
15688: LD_VAR 0 1
15692: NOT
15693: IFFALSE 15697
// exit ;
15695: GO 15716
// result := UnitsInside ( building ) < 6 ;
15697: LD_ADDR_VAR 0 2
15701: PUSH
15702: LD_VAR 0 1
15706: PPUSH
15707: CALL_OW 313
15711: PUSH
15712: LD_INT 6
15714: LESS
15715: ST_TO_ADDR
// end ;
15716: LD_VAR 0 2
15720: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
15721: LD_INT 0
15723: PPUSH
15724: PPUSH
15725: PPUSH
15726: PPUSH
// tmp := [ ] ;
15727: LD_ADDR_VAR 0 3
15731: PUSH
15732: EMPTY
15733: ST_TO_ADDR
// list := [ ] ;
15734: LD_ADDR_VAR 0 5
15738: PUSH
15739: EMPTY
15740: ST_TO_ADDR
// for i = 16 to 25 do
15741: LD_ADDR_VAR 0 4
15745: PUSH
15746: DOUBLE
15747: LD_INT 16
15749: DEC
15750: ST_TO_ADDR
15751: LD_INT 25
15753: PUSH
15754: FOR_TO
15755: IFFALSE 15828
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
15757: LD_ADDR_VAR 0 3
15761: PUSH
15762: LD_VAR 0 3
15766: PUSH
15767: LD_INT 22
15769: PUSH
15770: LD_VAR 0 1
15774: PPUSH
15775: CALL_OW 255
15779: PUSH
15780: EMPTY
15781: LIST
15782: LIST
15783: PUSH
15784: LD_INT 91
15786: PUSH
15787: LD_VAR 0 1
15791: PUSH
15792: LD_INT 6
15794: PUSH
15795: EMPTY
15796: LIST
15797: LIST
15798: LIST
15799: PUSH
15800: LD_INT 30
15802: PUSH
15803: LD_VAR 0 4
15807: PUSH
15808: EMPTY
15809: LIST
15810: LIST
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: LIST
15816: PUSH
15817: EMPTY
15818: LIST
15819: PPUSH
15820: CALL_OW 69
15824: ADD
15825: ST_TO_ADDR
15826: GO 15754
15828: POP
15829: POP
// for i = 1 to tmp do
15830: LD_ADDR_VAR 0 4
15834: PUSH
15835: DOUBLE
15836: LD_INT 1
15838: DEC
15839: ST_TO_ADDR
15840: LD_VAR 0 3
15844: PUSH
15845: FOR_TO
15846: IFFALSE 15934
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
15848: LD_ADDR_VAR 0 5
15852: PUSH
15853: LD_VAR 0 5
15857: PUSH
15858: LD_VAR 0 3
15862: PUSH
15863: LD_VAR 0 4
15867: ARRAY
15868: PPUSH
15869: CALL_OW 266
15873: PUSH
15874: LD_VAR 0 3
15878: PUSH
15879: LD_VAR 0 4
15883: ARRAY
15884: PPUSH
15885: CALL_OW 250
15889: PUSH
15890: LD_VAR 0 3
15894: PUSH
15895: LD_VAR 0 4
15899: ARRAY
15900: PPUSH
15901: CALL_OW 251
15905: PUSH
15906: LD_VAR 0 3
15910: PUSH
15911: LD_VAR 0 4
15915: ARRAY
15916: PPUSH
15917: CALL_OW 254
15921: PUSH
15922: EMPTY
15923: LIST
15924: LIST
15925: LIST
15926: LIST
15927: PUSH
15928: EMPTY
15929: LIST
15930: ADD
15931: ST_TO_ADDR
15932: GO 15845
15934: POP
15935: POP
// result := list ;
15936: LD_ADDR_VAR 0 2
15940: PUSH
15941: LD_VAR 0 5
15945: ST_TO_ADDR
// end ;
15946: LD_VAR 0 2
15950: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
15951: LD_INT 0
15953: PPUSH
15954: PPUSH
15955: PPUSH
15956: PPUSH
15957: PPUSH
15958: PPUSH
15959: PPUSH
// if not factory then
15960: LD_VAR 0 1
15964: NOT
15965: IFFALSE 15969
// exit ;
15967: GO 16562
// if control = control_apeman then
15969: LD_VAR 0 4
15973: PUSH
15974: LD_INT 5
15976: EQUAL
15977: IFFALSE 16086
// begin tmp := UnitsInside ( factory ) ;
15979: LD_ADDR_VAR 0 8
15983: PUSH
15984: LD_VAR 0 1
15988: PPUSH
15989: CALL_OW 313
15993: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
15994: LD_VAR 0 8
15998: PPUSH
15999: LD_INT 25
16001: PUSH
16002: LD_INT 12
16004: PUSH
16005: EMPTY
16006: LIST
16007: LIST
16008: PPUSH
16009: CALL_OW 72
16013: NOT
16014: IFFALSE 16024
// control := control_manual ;
16016: LD_ADDR_VAR 0 4
16020: PUSH
16021: LD_INT 1
16023: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16024: LD_ADDR_VAR 0 8
16028: PUSH
16029: LD_VAR 0 1
16033: PPUSH
16034: CALL 15721 0 1
16038: ST_TO_ADDR
// if tmp then
16039: LD_VAR 0 8
16043: IFFALSE 16086
// begin for i in tmp do
16045: LD_ADDR_VAR 0 7
16049: PUSH
16050: LD_VAR 0 8
16054: PUSH
16055: FOR_IN
16056: IFFALSE 16084
// if i [ 1 ] = b_ext_radio then
16058: LD_VAR 0 7
16062: PUSH
16063: LD_INT 1
16065: ARRAY
16066: PUSH
16067: LD_INT 22
16069: EQUAL
16070: IFFALSE 16082
// begin control := control_remote ;
16072: LD_ADDR_VAR 0 4
16076: PUSH
16077: LD_INT 2
16079: ST_TO_ADDR
// break ;
16080: GO 16084
// end ;
16082: GO 16055
16084: POP
16085: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16086: LD_VAR 0 1
16090: PPUSH
16091: LD_VAR 0 2
16095: PPUSH
16096: LD_VAR 0 3
16100: PPUSH
16101: LD_VAR 0 4
16105: PPUSH
16106: LD_VAR 0 5
16110: PPUSH
16111: CALL_OW 448
16115: IFFALSE 16150
// begin result := [ chassis , engine , control , weapon ] ;
16117: LD_ADDR_VAR 0 6
16121: PUSH
16122: LD_VAR 0 2
16126: PUSH
16127: LD_VAR 0 3
16131: PUSH
16132: LD_VAR 0 4
16136: PUSH
16137: LD_VAR 0 5
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: LIST
16146: LIST
16147: ST_TO_ADDR
// exit ;
16148: GO 16562
// end ; _chassis := AvailableChassisList ( factory ) ;
16150: LD_ADDR_VAR 0 9
16154: PUSH
16155: LD_VAR 0 1
16159: PPUSH
16160: CALL_OW 475
16164: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16165: LD_ADDR_VAR 0 11
16169: PUSH
16170: LD_VAR 0 1
16174: PPUSH
16175: CALL_OW 476
16179: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16180: LD_ADDR_VAR 0 12
16184: PUSH
16185: LD_VAR 0 1
16189: PPUSH
16190: CALL_OW 477
16194: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
16195: LD_ADDR_VAR 0 10
16199: PUSH
16200: LD_VAR 0 1
16204: PPUSH
16205: CALL_OW 478
16209: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
16210: LD_VAR 0 9
16214: NOT
16215: PUSH
16216: LD_VAR 0 11
16220: NOT
16221: OR
16222: PUSH
16223: LD_VAR 0 12
16227: NOT
16228: OR
16229: PUSH
16230: LD_VAR 0 10
16234: NOT
16235: OR
16236: IFFALSE 16271
// begin result := [ chassis , engine , control , weapon ] ;
16238: LD_ADDR_VAR 0 6
16242: PUSH
16243: LD_VAR 0 2
16247: PUSH
16248: LD_VAR 0 3
16252: PUSH
16253: LD_VAR 0 4
16257: PUSH
16258: LD_VAR 0 5
16262: PUSH
16263: EMPTY
16264: LIST
16265: LIST
16266: LIST
16267: LIST
16268: ST_TO_ADDR
// exit ;
16269: GO 16562
// end ; if not chassis in _chassis then
16271: LD_VAR 0 2
16275: PUSH
16276: LD_VAR 0 9
16280: IN
16281: NOT
16282: IFFALSE 16308
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16284: LD_ADDR_VAR 0 2
16288: PUSH
16289: LD_VAR 0 9
16293: PUSH
16294: LD_INT 1
16296: PPUSH
16297: LD_VAR 0 9
16301: PPUSH
16302: CALL_OW 12
16306: ARRAY
16307: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16308: LD_VAR 0 2
16312: PPUSH
16313: LD_VAR 0 3
16317: PPUSH
16318: CALL 16567 0 2
16322: NOT
16323: IFFALSE 16382
// repeat engine := _engine [ 1 ] ;
16325: LD_ADDR_VAR 0 3
16329: PUSH
16330: LD_VAR 0 11
16334: PUSH
16335: LD_INT 1
16337: ARRAY
16338: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16339: LD_ADDR_VAR 0 11
16343: PUSH
16344: LD_VAR 0 11
16348: PPUSH
16349: LD_INT 1
16351: PPUSH
16352: CALL_OW 3
16356: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16357: LD_VAR 0 2
16361: PPUSH
16362: LD_VAR 0 3
16366: PPUSH
16367: CALL 16567 0 2
16371: PUSH
16372: LD_VAR 0 11
16376: PUSH
16377: EMPTY
16378: EQUAL
16379: OR
16380: IFFALSE 16325
// if not control in _control then
16382: LD_VAR 0 4
16386: PUSH
16387: LD_VAR 0 12
16391: IN
16392: NOT
16393: IFFALSE 16419
// control := _control [ rand ( 1 , _control ) ] ;
16395: LD_ADDR_VAR 0 4
16399: PUSH
16400: LD_VAR 0 12
16404: PUSH
16405: LD_INT 1
16407: PPUSH
16408: LD_VAR 0 12
16412: PPUSH
16413: CALL_OW 12
16417: ARRAY
16418: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16419: LD_VAR 0 2
16423: PPUSH
16424: LD_VAR 0 5
16428: PPUSH
16429: CALL 16787 0 2
16433: NOT
16434: IFFALSE 16493
// repeat weapon := _weapon [ 1 ] ;
16436: LD_ADDR_VAR 0 5
16440: PUSH
16441: LD_VAR 0 10
16445: PUSH
16446: LD_INT 1
16448: ARRAY
16449: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16450: LD_ADDR_VAR 0 10
16454: PUSH
16455: LD_VAR 0 10
16459: PPUSH
16460: LD_INT 1
16462: PPUSH
16463: CALL_OW 3
16467: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16468: LD_VAR 0 2
16472: PPUSH
16473: LD_VAR 0 5
16477: PPUSH
16478: CALL 16787 0 2
16482: PUSH
16483: LD_VAR 0 10
16487: PUSH
16488: EMPTY
16489: EQUAL
16490: OR
16491: IFFALSE 16436
// result := [ ] ;
16493: LD_ADDR_VAR 0 6
16497: PUSH
16498: EMPTY
16499: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16500: LD_VAR 0 1
16504: PPUSH
16505: LD_VAR 0 2
16509: PPUSH
16510: LD_VAR 0 3
16514: PPUSH
16515: LD_VAR 0 4
16519: PPUSH
16520: LD_VAR 0 5
16524: PPUSH
16525: CALL_OW 448
16529: IFFALSE 16562
// result := [ chassis , engine , control , weapon ] ;
16531: LD_ADDR_VAR 0 6
16535: PUSH
16536: LD_VAR 0 2
16540: PUSH
16541: LD_VAR 0 3
16545: PUSH
16546: LD_VAR 0 4
16550: PUSH
16551: LD_VAR 0 5
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: LIST
16560: LIST
16561: ST_TO_ADDR
// end ;
16562: LD_VAR 0 6
16566: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16567: LD_INT 0
16569: PPUSH
// if not chassis or not engine then
16570: LD_VAR 0 1
16574: NOT
16575: PUSH
16576: LD_VAR 0 2
16580: NOT
16581: OR
16582: IFFALSE 16586
// exit ;
16584: GO 16782
// case engine of engine_solar :
16586: LD_VAR 0 2
16590: PUSH
16591: LD_INT 2
16593: DOUBLE
16594: EQUAL
16595: IFTRUE 16599
16597: GO 16637
16599: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16600: LD_ADDR_VAR 0 3
16604: PUSH
16605: LD_INT 11
16607: PUSH
16608: LD_INT 12
16610: PUSH
16611: LD_INT 13
16613: PUSH
16614: LD_INT 14
16616: PUSH
16617: LD_INT 1
16619: PUSH
16620: LD_INT 2
16622: PUSH
16623: LD_INT 3
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: LIST
16630: LIST
16631: LIST
16632: LIST
16633: LIST
16634: ST_TO_ADDR
16635: GO 16766
16637: LD_INT 1
16639: DOUBLE
16640: EQUAL
16641: IFTRUE 16645
16643: GO 16707
16645: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16646: LD_ADDR_VAR 0 3
16650: PUSH
16651: LD_INT 11
16653: PUSH
16654: LD_INT 12
16656: PUSH
16657: LD_INT 13
16659: PUSH
16660: LD_INT 14
16662: PUSH
16663: LD_INT 1
16665: PUSH
16666: LD_INT 2
16668: PUSH
16669: LD_INT 3
16671: PUSH
16672: LD_INT 4
16674: PUSH
16675: LD_INT 5
16677: PUSH
16678: LD_INT 21
16680: PUSH
16681: LD_INT 23
16683: PUSH
16684: LD_INT 22
16686: PUSH
16687: LD_INT 24
16689: PUSH
16690: EMPTY
16691: LIST
16692: LIST
16693: LIST
16694: LIST
16695: LIST
16696: LIST
16697: LIST
16698: LIST
16699: LIST
16700: LIST
16701: LIST
16702: LIST
16703: LIST
16704: ST_TO_ADDR
16705: GO 16766
16707: LD_INT 3
16709: DOUBLE
16710: EQUAL
16711: IFTRUE 16715
16713: GO 16765
16715: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
16716: LD_ADDR_VAR 0 3
16720: PUSH
16721: LD_INT 13
16723: PUSH
16724: LD_INT 14
16726: PUSH
16727: LD_INT 2
16729: PUSH
16730: LD_INT 3
16732: PUSH
16733: LD_INT 4
16735: PUSH
16736: LD_INT 5
16738: PUSH
16739: LD_INT 21
16741: PUSH
16742: LD_INT 22
16744: PUSH
16745: LD_INT 23
16747: PUSH
16748: LD_INT 24
16750: PUSH
16751: EMPTY
16752: LIST
16753: LIST
16754: LIST
16755: LIST
16756: LIST
16757: LIST
16758: LIST
16759: LIST
16760: LIST
16761: LIST
16762: ST_TO_ADDR
16763: GO 16766
16765: POP
// result := ( chassis in result ) ;
16766: LD_ADDR_VAR 0 3
16770: PUSH
16771: LD_VAR 0 1
16775: PUSH
16776: LD_VAR 0 3
16780: IN
16781: ST_TO_ADDR
// end ;
16782: LD_VAR 0 3
16786: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
16787: LD_INT 0
16789: PPUSH
// if not chassis or not weapon then
16790: LD_VAR 0 1
16794: NOT
16795: PUSH
16796: LD_VAR 0 2
16800: NOT
16801: OR
16802: IFFALSE 16806
// exit ;
16804: GO 17832
// case weapon of us_machine_gun :
16806: LD_VAR 0 2
16810: PUSH
16811: LD_INT 2
16813: DOUBLE
16814: EQUAL
16815: IFTRUE 16819
16817: GO 16849
16819: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
16820: LD_ADDR_VAR 0 3
16824: PUSH
16825: LD_INT 1
16827: PUSH
16828: LD_INT 2
16830: PUSH
16831: LD_INT 3
16833: PUSH
16834: LD_INT 4
16836: PUSH
16837: LD_INT 5
16839: PUSH
16840: EMPTY
16841: LIST
16842: LIST
16843: LIST
16844: LIST
16845: LIST
16846: ST_TO_ADDR
16847: GO 17816
16849: LD_INT 3
16851: DOUBLE
16852: EQUAL
16853: IFTRUE 16857
16855: GO 16887
16857: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
16858: LD_ADDR_VAR 0 3
16862: PUSH
16863: LD_INT 1
16865: PUSH
16866: LD_INT 2
16868: PUSH
16869: LD_INT 3
16871: PUSH
16872: LD_INT 4
16874: PUSH
16875: LD_INT 5
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: LIST
16882: LIST
16883: LIST
16884: ST_TO_ADDR
16885: GO 17816
16887: LD_INT 11
16889: DOUBLE
16890: EQUAL
16891: IFTRUE 16895
16893: GO 16925
16895: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
16896: LD_ADDR_VAR 0 3
16900: PUSH
16901: LD_INT 1
16903: PUSH
16904: LD_INT 2
16906: PUSH
16907: LD_INT 3
16909: PUSH
16910: LD_INT 4
16912: PUSH
16913: LD_INT 5
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: LIST
16920: LIST
16921: LIST
16922: ST_TO_ADDR
16923: GO 17816
16925: LD_INT 4
16927: DOUBLE
16928: EQUAL
16929: IFTRUE 16933
16931: GO 16959
16933: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
16934: LD_ADDR_VAR 0 3
16938: PUSH
16939: LD_INT 2
16941: PUSH
16942: LD_INT 3
16944: PUSH
16945: LD_INT 4
16947: PUSH
16948: LD_INT 5
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: ST_TO_ADDR
16957: GO 17816
16959: LD_INT 5
16961: DOUBLE
16962: EQUAL
16963: IFTRUE 16967
16965: GO 16993
16967: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
16968: LD_ADDR_VAR 0 3
16972: PUSH
16973: LD_INT 2
16975: PUSH
16976: LD_INT 3
16978: PUSH
16979: LD_INT 4
16981: PUSH
16982: LD_INT 5
16984: PUSH
16985: EMPTY
16986: LIST
16987: LIST
16988: LIST
16989: LIST
16990: ST_TO_ADDR
16991: GO 17816
16993: LD_INT 9
16995: DOUBLE
16996: EQUAL
16997: IFTRUE 17001
16999: GO 17027
17001: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17002: LD_ADDR_VAR 0 3
17006: PUSH
17007: LD_INT 2
17009: PUSH
17010: LD_INT 3
17012: PUSH
17013: LD_INT 4
17015: PUSH
17016: LD_INT 5
17018: PUSH
17019: EMPTY
17020: LIST
17021: LIST
17022: LIST
17023: LIST
17024: ST_TO_ADDR
17025: GO 17816
17027: LD_INT 7
17029: DOUBLE
17030: EQUAL
17031: IFTRUE 17035
17033: GO 17061
17035: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17036: LD_ADDR_VAR 0 3
17040: PUSH
17041: LD_INT 2
17043: PUSH
17044: LD_INT 3
17046: PUSH
17047: LD_INT 4
17049: PUSH
17050: LD_INT 5
17052: PUSH
17053: EMPTY
17054: LIST
17055: LIST
17056: LIST
17057: LIST
17058: ST_TO_ADDR
17059: GO 17816
17061: LD_INT 12
17063: DOUBLE
17064: EQUAL
17065: IFTRUE 17069
17067: GO 17095
17069: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17070: LD_ADDR_VAR 0 3
17074: PUSH
17075: LD_INT 2
17077: PUSH
17078: LD_INT 3
17080: PUSH
17081: LD_INT 4
17083: PUSH
17084: LD_INT 5
17086: PUSH
17087: EMPTY
17088: LIST
17089: LIST
17090: LIST
17091: LIST
17092: ST_TO_ADDR
17093: GO 17816
17095: LD_INT 13
17097: DOUBLE
17098: EQUAL
17099: IFTRUE 17103
17101: GO 17129
17103: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17104: LD_ADDR_VAR 0 3
17108: PUSH
17109: LD_INT 2
17111: PUSH
17112: LD_INT 3
17114: PUSH
17115: LD_INT 4
17117: PUSH
17118: LD_INT 5
17120: PUSH
17121: EMPTY
17122: LIST
17123: LIST
17124: LIST
17125: LIST
17126: ST_TO_ADDR
17127: GO 17816
17129: LD_INT 14
17131: DOUBLE
17132: EQUAL
17133: IFTRUE 17137
17135: GO 17155
17137: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17138: LD_ADDR_VAR 0 3
17142: PUSH
17143: LD_INT 4
17145: PUSH
17146: LD_INT 5
17148: PUSH
17149: EMPTY
17150: LIST
17151: LIST
17152: ST_TO_ADDR
17153: GO 17816
17155: LD_INT 6
17157: DOUBLE
17158: EQUAL
17159: IFTRUE 17163
17161: GO 17181
17163: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17164: LD_ADDR_VAR 0 3
17168: PUSH
17169: LD_INT 4
17171: PUSH
17172: LD_INT 5
17174: PUSH
17175: EMPTY
17176: LIST
17177: LIST
17178: ST_TO_ADDR
17179: GO 17816
17181: LD_INT 10
17183: DOUBLE
17184: EQUAL
17185: IFTRUE 17189
17187: GO 17207
17189: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
17190: LD_ADDR_VAR 0 3
17194: PUSH
17195: LD_INT 4
17197: PUSH
17198: LD_INT 5
17200: PUSH
17201: EMPTY
17202: LIST
17203: LIST
17204: ST_TO_ADDR
17205: GO 17816
17207: LD_INT 22
17209: DOUBLE
17210: EQUAL
17211: IFTRUE 17215
17213: GO 17241
17215: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
17216: LD_ADDR_VAR 0 3
17220: PUSH
17221: LD_INT 11
17223: PUSH
17224: LD_INT 12
17226: PUSH
17227: LD_INT 13
17229: PUSH
17230: LD_INT 14
17232: PUSH
17233: EMPTY
17234: LIST
17235: LIST
17236: LIST
17237: LIST
17238: ST_TO_ADDR
17239: GO 17816
17241: LD_INT 23
17243: DOUBLE
17244: EQUAL
17245: IFTRUE 17249
17247: GO 17275
17249: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
17250: LD_ADDR_VAR 0 3
17254: PUSH
17255: LD_INT 11
17257: PUSH
17258: LD_INT 12
17260: PUSH
17261: LD_INT 13
17263: PUSH
17264: LD_INT 14
17266: PUSH
17267: EMPTY
17268: LIST
17269: LIST
17270: LIST
17271: LIST
17272: ST_TO_ADDR
17273: GO 17816
17275: LD_INT 24
17277: DOUBLE
17278: EQUAL
17279: IFTRUE 17283
17281: GO 17309
17283: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17284: LD_ADDR_VAR 0 3
17288: PUSH
17289: LD_INT 11
17291: PUSH
17292: LD_INT 12
17294: PUSH
17295: LD_INT 13
17297: PUSH
17298: LD_INT 14
17300: PUSH
17301: EMPTY
17302: LIST
17303: LIST
17304: LIST
17305: LIST
17306: ST_TO_ADDR
17307: GO 17816
17309: LD_INT 30
17311: DOUBLE
17312: EQUAL
17313: IFTRUE 17317
17315: GO 17343
17317: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17318: LD_ADDR_VAR 0 3
17322: PUSH
17323: LD_INT 11
17325: PUSH
17326: LD_INT 12
17328: PUSH
17329: LD_INT 13
17331: PUSH
17332: LD_INT 14
17334: PUSH
17335: EMPTY
17336: LIST
17337: LIST
17338: LIST
17339: LIST
17340: ST_TO_ADDR
17341: GO 17816
17343: LD_INT 25
17345: DOUBLE
17346: EQUAL
17347: IFTRUE 17351
17349: GO 17369
17351: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17352: LD_ADDR_VAR 0 3
17356: PUSH
17357: LD_INT 13
17359: PUSH
17360: LD_INT 14
17362: PUSH
17363: EMPTY
17364: LIST
17365: LIST
17366: ST_TO_ADDR
17367: GO 17816
17369: LD_INT 27
17371: DOUBLE
17372: EQUAL
17373: IFTRUE 17377
17375: GO 17395
17377: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17378: LD_ADDR_VAR 0 3
17382: PUSH
17383: LD_INT 13
17385: PUSH
17386: LD_INT 14
17388: PUSH
17389: EMPTY
17390: LIST
17391: LIST
17392: ST_TO_ADDR
17393: GO 17816
17395: LD_INT 28
17397: DOUBLE
17398: EQUAL
17399: IFTRUE 17403
17401: GO 17421
17403: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17404: LD_ADDR_VAR 0 3
17408: PUSH
17409: LD_INT 13
17411: PUSH
17412: LD_INT 14
17414: PUSH
17415: EMPTY
17416: LIST
17417: LIST
17418: ST_TO_ADDR
17419: GO 17816
17421: LD_INT 29
17423: DOUBLE
17424: EQUAL
17425: IFTRUE 17429
17427: GO 17447
17429: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17430: LD_ADDR_VAR 0 3
17434: PUSH
17435: LD_INT 13
17437: PUSH
17438: LD_INT 14
17440: PUSH
17441: EMPTY
17442: LIST
17443: LIST
17444: ST_TO_ADDR
17445: GO 17816
17447: LD_INT 31
17449: DOUBLE
17450: EQUAL
17451: IFTRUE 17455
17453: GO 17473
17455: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17456: LD_ADDR_VAR 0 3
17460: PUSH
17461: LD_INT 13
17463: PUSH
17464: LD_INT 14
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: ST_TO_ADDR
17471: GO 17816
17473: LD_INT 26
17475: DOUBLE
17476: EQUAL
17477: IFTRUE 17481
17479: GO 17499
17481: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17482: LD_ADDR_VAR 0 3
17486: PUSH
17487: LD_INT 13
17489: PUSH
17490: LD_INT 14
17492: PUSH
17493: EMPTY
17494: LIST
17495: LIST
17496: ST_TO_ADDR
17497: GO 17816
17499: LD_INT 42
17501: DOUBLE
17502: EQUAL
17503: IFTRUE 17507
17505: GO 17533
17507: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17508: LD_ADDR_VAR 0 3
17512: PUSH
17513: LD_INT 21
17515: PUSH
17516: LD_INT 22
17518: PUSH
17519: LD_INT 23
17521: PUSH
17522: LD_INT 24
17524: PUSH
17525: EMPTY
17526: LIST
17527: LIST
17528: LIST
17529: LIST
17530: ST_TO_ADDR
17531: GO 17816
17533: LD_INT 43
17535: DOUBLE
17536: EQUAL
17537: IFTRUE 17541
17539: GO 17567
17541: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17542: LD_ADDR_VAR 0 3
17546: PUSH
17547: LD_INT 21
17549: PUSH
17550: LD_INT 22
17552: PUSH
17553: LD_INT 23
17555: PUSH
17556: LD_INT 24
17558: PUSH
17559: EMPTY
17560: LIST
17561: LIST
17562: LIST
17563: LIST
17564: ST_TO_ADDR
17565: GO 17816
17567: LD_INT 44
17569: DOUBLE
17570: EQUAL
17571: IFTRUE 17575
17573: GO 17601
17575: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17576: LD_ADDR_VAR 0 3
17580: PUSH
17581: LD_INT 21
17583: PUSH
17584: LD_INT 22
17586: PUSH
17587: LD_INT 23
17589: PUSH
17590: LD_INT 24
17592: PUSH
17593: EMPTY
17594: LIST
17595: LIST
17596: LIST
17597: LIST
17598: ST_TO_ADDR
17599: GO 17816
17601: LD_INT 45
17603: DOUBLE
17604: EQUAL
17605: IFTRUE 17609
17607: GO 17635
17609: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17610: LD_ADDR_VAR 0 3
17614: PUSH
17615: LD_INT 21
17617: PUSH
17618: LD_INT 22
17620: PUSH
17621: LD_INT 23
17623: PUSH
17624: LD_INT 24
17626: PUSH
17627: EMPTY
17628: LIST
17629: LIST
17630: LIST
17631: LIST
17632: ST_TO_ADDR
17633: GO 17816
17635: LD_INT 49
17637: DOUBLE
17638: EQUAL
17639: IFTRUE 17643
17641: GO 17669
17643: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17644: LD_ADDR_VAR 0 3
17648: PUSH
17649: LD_INT 21
17651: PUSH
17652: LD_INT 22
17654: PUSH
17655: LD_INT 23
17657: PUSH
17658: LD_INT 24
17660: PUSH
17661: EMPTY
17662: LIST
17663: LIST
17664: LIST
17665: LIST
17666: ST_TO_ADDR
17667: GO 17816
17669: LD_INT 51
17671: DOUBLE
17672: EQUAL
17673: IFTRUE 17677
17675: GO 17703
17677: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
17678: LD_ADDR_VAR 0 3
17682: PUSH
17683: LD_INT 21
17685: PUSH
17686: LD_INT 22
17688: PUSH
17689: LD_INT 23
17691: PUSH
17692: LD_INT 24
17694: PUSH
17695: EMPTY
17696: LIST
17697: LIST
17698: LIST
17699: LIST
17700: ST_TO_ADDR
17701: GO 17816
17703: LD_INT 52
17705: DOUBLE
17706: EQUAL
17707: IFTRUE 17711
17709: GO 17737
17711: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
17712: LD_ADDR_VAR 0 3
17716: PUSH
17717: LD_INT 21
17719: PUSH
17720: LD_INT 22
17722: PUSH
17723: LD_INT 23
17725: PUSH
17726: LD_INT 24
17728: PUSH
17729: EMPTY
17730: LIST
17731: LIST
17732: LIST
17733: LIST
17734: ST_TO_ADDR
17735: GO 17816
17737: LD_INT 53
17739: DOUBLE
17740: EQUAL
17741: IFTRUE 17745
17743: GO 17763
17745: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
17746: LD_ADDR_VAR 0 3
17750: PUSH
17751: LD_INT 23
17753: PUSH
17754: LD_INT 24
17756: PUSH
17757: EMPTY
17758: LIST
17759: LIST
17760: ST_TO_ADDR
17761: GO 17816
17763: LD_INT 46
17765: DOUBLE
17766: EQUAL
17767: IFTRUE 17771
17769: GO 17789
17771: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
17772: LD_ADDR_VAR 0 3
17776: PUSH
17777: LD_INT 23
17779: PUSH
17780: LD_INT 24
17782: PUSH
17783: EMPTY
17784: LIST
17785: LIST
17786: ST_TO_ADDR
17787: GO 17816
17789: LD_INT 47
17791: DOUBLE
17792: EQUAL
17793: IFTRUE 17797
17795: GO 17815
17797: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17798: LD_ADDR_VAR 0 3
17802: PUSH
17803: LD_INT 23
17805: PUSH
17806: LD_INT 24
17808: PUSH
17809: EMPTY
17810: LIST
17811: LIST
17812: ST_TO_ADDR
17813: GO 17816
17815: POP
// result := ( chassis in result ) ;
17816: LD_ADDR_VAR 0 3
17820: PUSH
17821: LD_VAR 0 1
17825: PUSH
17826: LD_VAR 0 3
17830: IN
17831: ST_TO_ADDR
// end ;
17832: LD_VAR 0 3
17836: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
17837: LD_INT 0
17839: PPUSH
17840: PPUSH
17841: PPUSH
17842: PPUSH
17843: PPUSH
17844: PPUSH
17845: PPUSH
// result := array ;
17846: LD_ADDR_VAR 0 5
17850: PUSH
17851: LD_VAR 0 1
17855: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
17856: LD_VAR 0 1
17860: NOT
17861: PUSH
17862: LD_VAR 0 2
17866: NOT
17867: OR
17868: PUSH
17869: LD_VAR 0 3
17873: NOT
17874: OR
17875: PUSH
17876: LD_VAR 0 2
17880: PUSH
17881: LD_VAR 0 1
17885: GREATER
17886: OR
17887: PUSH
17888: LD_VAR 0 3
17892: PUSH
17893: LD_VAR 0 1
17897: GREATER
17898: OR
17899: IFFALSE 17903
// exit ;
17901: GO 18199
// if direction then
17903: LD_VAR 0 4
17907: IFFALSE 17971
// begin d := 1 ;
17909: LD_ADDR_VAR 0 9
17913: PUSH
17914: LD_INT 1
17916: ST_TO_ADDR
// if i_from > i_to then
17917: LD_VAR 0 2
17921: PUSH
17922: LD_VAR 0 3
17926: GREATER
17927: IFFALSE 17953
// length := ( array - i_from ) + i_to else
17929: LD_ADDR_VAR 0 11
17933: PUSH
17934: LD_VAR 0 1
17938: PUSH
17939: LD_VAR 0 2
17943: MINUS
17944: PUSH
17945: LD_VAR 0 3
17949: PLUS
17950: ST_TO_ADDR
17951: GO 17969
// length := i_to - i_from ;
17953: LD_ADDR_VAR 0 11
17957: PUSH
17958: LD_VAR 0 3
17962: PUSH
17963: LD_VAR 0 2
17967: MINUS
17968: ST_TO_ADDR
// end else
17969: GO 18032
// begin d := - 1 ;
17971: LD_ADDR_VAR 0 9
17975: PUSH
17976: LD_INT 1
17978: NEG
17979: ST_TO_ADDR
// if i_from > i_to then
17980: LD_VAR 0 2
17984: PUSH
17985: LD_VAR 0 3
17989: GREATER
17990: IFFALSE 18010
// length := i_from - i_to else
17992: LD_ADDR_VAR 0 11
17996: PUSH
17997: LD_VAR 0 2
18001: PUSH
18002: LD_VAR 0 3
18006: MINUS
18007: ST_TO_ADDR
18008: GO 18032
// length := ( array - i_to ) + i_from ;
18010: LD_ADDR_VAR 0 11
18014: PUSH
18015: LD_VAR 0 1
18019: PUSH
18020: LD_VAR 0 3
18024: MINUS
18025: PUSH
18026: LD_VAR 0 2
18030: PLUS
18031: ST_TO_ADDR
// end ; if not length then
18032: LD_VAR 0 11
18036: NOT
18037: IFFALSE 18041
// exit ;
18039: GO 18199
// tmp := array ;
18041: LD_ADDR_VAR 0 10
18045: PUSH
18046: LD_VAR 0 1
18050: ST_TO_ADDR
// for i = 1 to length do
18051: LD_ADDR_VAR 0 6
18055: PUSH
18056: DOUBLE
18057: LD_INT 1
18059: DEC
18060: ST_TO_ADDR
18061: LD_VAR 0 11
18065: PUSH
18066: FOR_TO
18067: IFFALSE 18187
// begin for j = 1 to array do
18069: LD_ADDR_VAR 0 7
18073: PUSH
18074: DOUBLE
18075: LD_INT 1
18077: DEC
18078: ST_TO_ADDR
18079: LD_VAR 0 1
18083: PUSH
18084: FOR_TO
18085: IFFALSE 18173
// begin k := j + d ;
18087: LD_ADDR_VAR 0 8
18091: PUSH
18092: LD_VAR 0 7
18096: PUSH
18097: LD_VAR 0 9
18101: PLUS
18102: ST_TO_ADDR
// if k > array then
18103: LD_VAR 0 8
18107: PUSH
18108: LD_VAR 0 1
18112: GREATER
18113: IFFALSE 18123
// k := 1 ;
18115: LD_ADDR_VAR 0 8
18119: PUSH
18120: LD_INT 1
18122: ST_TO_ADDR
// if not k then
18123: LD_VAR 0 8
18127: NOT
18128: IFFALSE 18140
// k := array ;
18130: LD_ADDR_VAR 0 8
18134: PUSH
18135: LD_VAR 0 1
18139: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18140: LD_ADDR_VAR 0 10
18144: PUSH
18145: LD_VAR 0 10
18149: PPUSH
18150: LD_VAR 0 8
18154: PPUSH
18155: LD_VAR 0 1
18159: PUSH
18160: LD_VAR 0 7
18164: ARRAY
18165: PPUSH
18166: CALL_OW 1
18170: ST_TO_ADDR
// end ;
18171: GO 18084
18173: POP
18174: POP
// array := tmp ;
18175: LD_ADDR_VAR 0 1
18179: PUSH
18180: LD_VAR 0 10
18184: ST_TO_ADDR
// end ;
18185: GO 18066
18187: POP
18188: POP
// result := array ;
18189: LD_ADDR_VAR 0 5
18193: PUSH
18194: LD_VAR 0 1
18198: ST_TO_ADDR
// end ;
18199: LD_VAR 0 5
18203: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
18204: LD_INT 0
18206: PPUSH
18207: PPUSH
// result := 0 ;
18208: LD_ADDR_VAR 0 3
18212: PUSH
18213: LD_INT 0
18215: ST_TO_ADDR
// if not array or not value in array then
18216: LD_VAR 0 1
18220: NOT
18221: PUSH
18222: LD_VAR 0 2
18226: PUSH
18227: LD_VAR 0 1
18231: IN
18232: NOT
18233: OR
18234: IFFALSE 18238
// exit ;
18236: GO 18292
// for i = 1 to array do
18238: LD_ADDR_VAR 0 4
18242: PUSH
18243: DOUBLE
18244: LD_INT 1
18246: DEC
18247: ST_TO_ADDR
18248: LD_VAR 0 1
18252: PUSH
18253: FOR_TO
18254: IFFALSE 18290
// if value = array [ i ] then
18256: LD_VAR 0 2
18260: PUSH
18261: LD_VAR 0 1
18265: PUSH
18266: LD_VAR 0 4
18270: ARRAY
18271: EQUAL
18272: IFFALSE 18288
// begin result := i ;
18274: LD_ADDR_VAR 0 3
18278: PUSH
18279: LD_VAR 0 4
18283: ST_TO_ADDR
// exit ;
18284: POP
18285: POP
18286: GO 18292
// end ;
18288: GO 18253
18290: POP
18291: POP
// end ;
18292: LD_VAR 0 3
18296: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18297: LD_INT 0
18299: PPUSH
// vc_chassis := chassis ;
18300: LD_ADDR_OWVAR 37
18304: PUSH
18305: LD_VAR 0 1
18309: ST_TO_ADDR
// vc_engine := engine ;
18310: LD_ADDR_OWVAR 39
18314: PUSH
18315: LD_VAR 0 2
18319: ST_TO_ADDR
// vc_control := control ;
18320: LD_ADDR_OWVAR 38
18324: PUSH
18325: LD_VAR 0 3
18329: ST_TO_ADDR
// vc_weapon := weapon ;
18330: LD_ADDR_OWVAR 40
18334: PUSH
18335: LD_VAR 0 4
18339: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18340: LD_ADDR_OWVAR 41
18344: PUSH
18345: LD_VAR 0 5
18349: ST_TO_ADDR
// end ;
18350: LD_VAR 0 6
18354: RET
// export function WantPlant ( unit ) ; var task ; begin
18355: LD_INT 0
18357: PPUSH
18358: PPUSH
// result := false ;
18359: LD_ADDR_VAR 0 2
18363: PUSH
18364: LD_INT 0
18366: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18367: LD_ADDR_VAR 0 3
18371: PUSH
18372: LD_VAR 0 1
18376: PPUSH
18377: CALL_OW 437
18381: ST_TO_ADDR
// if task then
18382: LD_VAR 0 3
18386: IFFALSE 18414
// if task [ 1 ] [ 1 ] = p then
18388: LD_VAR 0 3
18392: PUSH
18393: LD_INT 1
18395: ARRAY
18396: PUSH
18397: LD_INT 1
18399: ARRAY
18400: PUSH
18401: LD_STRING p
18403: EQUAL
18404: IFFALSE 18414
// result := true ;
18406: LD_ADDR_VAR 0 2
18410: PUSH
18411: LD_INT 1
18413: ST_TO_ADDR
// end ;
18414: LD_VAR 0 2
18418: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18419: LD_INT 0
18421: PPUSH
18422: PPUSH
18423: PPUSH
18424: PPUSH
// if pos < 1 then
18425: LD_VAR 0 2
18429: PUSH
18430: LD_INT 1
18432: LESS
18433: IFFALSE 18437
// exit ;
18435: GO 18740
// if pos = 1 then
18437: LD_VAR 0 2
18441: PUSH
18442: LD_INT 1
18444: EQUAL
18445: IFFALSE 18478
// result := Replace ( arr , pos [ 1 ] , value ) else
18447: LD_ADDR_VAR 0 4
18451: PUSH
18452: LD_VAR 0 1
18456: PPUSH
18457: LD_VAR 0 2
18461: PUSH
18462: LD_INT 1
18464: ARRAY
18465: PPUSH
18466: LD_VAR 0 3
18470: PPUSH
18471: CALL_OW 1
18475: ST_TO_ADDR
18476: GO 18740
// begin tmp := arr ;
18478: LD_ADDR_VAR 0 6
18482: PUSH
18483: LD_VAR 0 1
18487: ST_TO_ADDR
// s_arr := [ tmp ] ;
18488: LD_ADDR_VAR 0 7
18492: PUSH
18493: LD_VAR 0 6
18497: PUSH
18498: EMPTY
18499: LIST
18500: ST_TO_ADDR
// for i = 1 to pos - 1 do
18501: LD_ADDR_VAR 0 5
18505: PUSH
18506: DOUBLE
18507: LD_INT 1
18509: DEC
18510: ST_TO_ADDR
18511: LD_VAR 0 2
18515: PUSH
18516: LD_INT 1
18518: MINUS
18519: PUSH
18520: FOR_TO
18521: IFFALSE 18566
// begin tmp := tmp [ pos [ i ] ] ;
18523: LD_ADDR_VAR 0 6
18527: PUSH
18528: LD_VAR 0 6
18532: PUSH
18533: LD_VAR 0 2
18537: PUSH
18538: LD_VAR 0 5
18542: ARRAY
18543: ARRAY
18544: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18545: LD_ADDR_VAR 0 7
18549: PUSH
18550: LD_VAR 0 7
18554: PUSH
18555: LD_VAR 0 6
18559: PUSH
18560: EMPTY
18561: LIST
18562: ADD
18563: ST_TO_ADDR
// end ;
18564: GO 18520
18566: POP
18567: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18568: LD_ADDR_VAR 0 6
18572: PUSH
18573: LD_VAR 0 6
18577: PPUSH
18578: LD_VAR 0 2
18582: PUSH
18583: LD_VAR 0 2
18587: ARRAY
18588: PPUSH
18589: LD_VAR 0 3
18593: PPUSH
18594: CALL_OW 1
18598: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18599: LD_ADDR_VAR 0 7
18603: PUSH
18604: LD_VAR 0 7
18608: PPUSH
18609: LD_VAR 0 7
18613: PPUSH
18614: LD_VAR 0 6
18618: PPUSH
18619: CALL_OW 1
18623: ST_TO_ADDR
// for i = s_arr downto 2 do
18624: LD_ADDR_VAR 0 5
18628: PUSH
18629: DOUBLE
18630: LD_VAR 0 7
18634: INC
18635: ST_TO_ADDR
18636: LD_INT 2
18638: PUSH
18639: FOR_DOWNTO
18640: IFFALSE 18724
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18642: LD_ADDR_VAR 0 6
18646: PUSH
18647: LD_VAR 0 7
18651: PUSH
18652: LD_VAR 0 5
18656: PUSH
18657: LD_INT 1
18659: MINUS
18660: ARRAY
18661: PPUSH
18662: LD_VAR 0 2
18666: PUSH
18667: LD_VAR 0 5
18671: PUSH
18672: LD_INT 1
18674: MINUS
18675: ARRAY
18676: PPUSH
18677: LD_VAR 0 7
18681: PUSH
18682: LD_VAR 0 5
18686: ARRAY
18687: PPUSH
18688: CALL_OW 1
18692: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
18693: LD_ADDR_VAR 0 7
18697: PUSH
18698: LD_VAR 0 7
18702: PPUSH
18703: LD_VAR 0 5
18707: PUSH
18708: LD_INT 1
18710: MINUS
18711: PPUSH
18712: LD_VAR 0 6
18716: PPUSH
18717: CALL_OW 1
18721: ST_TO_ADDR
// end ;
18722: GO 18639
18724: POP
18725: POP
// result := s_arr [ 1 ] ;
18726: LD_ADDR_VAR 0 4
18730: PUSH
18731: LD_VAR 0 7
18735: PUSH
18736: LD_INT 1
18738: ARRAY
18739: ST_TO_ADDR
// end ; end ;
18740: LD_VAR 0 4
18744: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
18745: LD_INT 0
18747: PPUSH
18748: PPUSH
// if not list then
18749: LD_VAR 0 1
18753: NOT
18754: IFFALSE 18758
// exit ;
18756: GO 18849
// i := list [ pos1 ] ;
18758: LD_ADDR_VAR 0 5
18762: PUSH
18763: LD_VAR 0 1
18767: PUSH
18768: LD_VAR 0 2
18772: ARRAY
18773: ST_TO_ADDR
// if not i then
18774: LD_VAR 0 5
18778: NOT
18779: IFFALSE 18783
// exit ;
18781: GO 18849
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
18783: LD_ADDR_VAR 0 1
18787: PUSH
18788: LD_VAR 0 1
18792: PPUSH
18793: LD_VAR 0 2
18797: PPUSH
18798: LD_VAR 0 1
18802: PUSH
18803: LD_VAR 0 3
18807: ARRAY
18808: PPUSH
18809: CALL_OW 1
18813: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
18814: LD_ADDR_VAR 0 1
18818: PUSH
18819: LD_VAR 0 1
18823: PPUSH
18824: LD_VAR 0 3
18828: PPUSH
18829: LD_VAR 0 5
18833: PPUSH
18834: CALL_OW 1
18838: ST_TO_ADDR
// result := list ;
18839: LD_ADDR_VAR 0 4
18843: PUSH
18844: LD_VAR 0 1
18848: ST_TO_ADDR
// end ;
18849: LD_VAR 0 4
18853: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
18854: LD_INT 0
18856: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
18857: LD_ADDR_VAR 0 5
18861: PUSH
18862: LD_VAR 0 1
18866: PPUSH
18867: CALL_OW 250
18871: PPUSH
18872: LD_VAR 0 1
18876: PPUSH
18877: CALL_OW 251
18881: PPUSH
18882: LD_VAR 0 2
18886: PPUSH
18887: LD_VAR 0 3
18891: PPUSH
18892: LD_VAR 0 4
18896: PPUSH
18897: CALL 18907 0 5
18901: ST_TO_ADDR
// end ;
18902: LD_VAR 0 5
18906: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
18907: LD_INT 0
18909: PPUSH
18910: PPUSH
18911: PPUSH
18912: PPUSH
// if not list then
18913: LD_VAR 0 3
18917: NOT
18918: IFFALSE 18922
// exit ;
18920: GO 19310
// result := [ ] ;
18922: LD_ADDR_VAR 0 6
18926: PUSH
18927: EMPTY
18928: ST_TO_ADDR
// for i in list do
18929: LD_ADDR_VAR 0 7
18933: PUSH
18934: LD_VAR 0 3
18938: PUSH
18939: FOR_IN
18940: IFFALSE 19142
// begin tmp := GetDistUnitXY ( i , x , y ) ;
18942: LD_ADDR_VAR 0 9
18946: PUSH
18947: LD_VAR 0 7
18951: PPUSH
18952: LD_VAR 0 1
18956: PPUSH
18957: LD_VAR 0 2
18961: PPUSH
18962: CALL_OW 297
18966: ST_TO_ADDR
// if not result then
18967: LD_VAR 0 6
18971: NOT
18972: IFFALSE 18998
// result := [ [ i , tmp ] ] else
18974: LD_ADDR_VAR 0 6
18978: PUSH
18979: LD_VAR 0 7
18983: PUSH
18984: LD_VAR 0 9
18988: PUSH
18989: EMPTY
18990: LIST
18991: LIST
18992: PUSH
18993: EMPTY
18994: LIST
18995: ST_TO_ADDR
18996: GO 19140
// begin if result [ result ] [ 2 ] < tmp then
18998: LD_VAR 0 6
19002: PUSH
19003: LD_VAR 0 6
19007: ARRAY
19008: PUSH
19009: LD_INT 2
19011: ARRAY
19012: PUSH
19013: LD_VAR 0 9
19017: LESS
19018: IFFALSE 19060
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19020: LD_ADDR_VAR 0 6
19024: PUSH
19025: LD_VAR 0 6
19029: PPUSH
19030: LD_VAR 0 6
19034: PUSH
19035: LD_INT 1
19037: PLUS
19038: PPUSH
19039: LD_VAR 0 7
19043: PUSH
19044: LD_VAR 0 9
19048: PUSH
19049: EMPTY
19050: LIST
19051: LIST
19052: PPUSH
19053: CALL_OW 2
19057: ST_TO_ADDR
19058: GO 19140
// for j = 1 to result do
19060: LD_ADDR_VAR 0 8
19064: PUSH
19065: DOUBLE
19066: LD_INT 1
19068: DEC
19069: ST_TO_ADDR
19070: LD_VAR 0 6
19074: PUSH
19075: FOR_TO
19076: IFFALSE 19138
// begin if tmp < result [ j ] [ 2 ] then
19078: LD_VAR 0 9
19082: PUSH
19083: LD_VAR 0 6
19087: PUSH
19088: LD_VAR 0 8
19092: ARRAY
19093: PUSH
19094: LD_INT 2
19096: ARRAY
19097: LESS
19098: IFFALSE 19136
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19100: LD_ADDR_VAR 0 6
19104: PUSH
19105: LD_VAR 0 6
19109: PPUSH
19110: LD_VAR 0 8
19114: PPUSH
19115: LD_VAR 0 7
19119: PUSH
19120: LD_VAR 0 9
19124: PUSH
19125: EMPTY
19126: LIST
19127: LIST
19128: PPUSH
19129: CALL_OW 2
19133: ST_TO_ADDR
// break ;
19134: GO 19138
// end ; end ;
19136: GO 19075
19138: POP
19139: POP
// end ; end ;
19140: GO 18939
19142: POP
19143: POP
// if result and not asc then
19144: LD_VAR 0 6
19148: PUSH
19149: LD_VAR 0 4
19153: NOT
19154: AND
19155: IFFALSE 19230
// begin tmp := result ;
19157: LD_ADDR_VAR 0 9
19161: PUSH
19162: LD_VAR 0 6
19166: ST_TO_ADDR
// for i = tmp downto 1 do
19167: LD_ADDR_VAR 0 7
19171: PUSH
19172: DOUBLE
19173: LD_VAR 0 9
19177: INC
19178: ST_TO_ADDR
19179: LD_INT 1
19181: PUSH
19182: FOR_DOWNTO
19183: IFFALSE 19228
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
19185: LD_ADDR_VAR 0 6
19189: PUSH
19190: LD_VAR 0 6
19194: PPUSH
19195: LD_VAR 0 9
19199: PUSH
19200: LD_VAR 0 7
19204: MINUS
19205: PUSH
19206: LD_INT 1
19208: PLUS
19209: PPUSH
19210: LD_VAR 0 9
19214: PUSH
19215: LD_VAR 0 7
19219: ARRAY
19220: PPUSH
19221: CALL_OW 1
19225: ST_TO_ADDR
19226: GO 19182
19228: POP
19229: POP
// end ; tmp := [ ] ;
19230: LD_ADDR_VAR 0 9
19234: PUSH
19235: EMPTY
19236: ST_TO_ADDR
// if mode then
19237: LD_VAR 0 5
19241: IFFALSE 19310
// begin for i = 1 to result do
19243: LD_ADDR_VAR 0 7
19247: PUSH
19248: DOUBLE
19249: LD_INT 1
19251: DEC
19252: ST_TO_ADDR
19253: LD_VAR 0 6
19257: PUSH
19258: FOR_TO
19259: IFFALSE 19298
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19261: LD_ADDR_VAR 0 9
19265: PUSH
19266: LD_VAR 0 9
19270: PPUSH
19271: LD_VAR 0 7
19275: PPUSH
19276: LD_VAR 0 6
19280: PUSH
19281: LD_VAR 0 7
19285: ARRAY
19286: PUSH
19287: LD_INT 1
19289: ARRAY
19290: PPUSH
19291: CALL_OW 1
19295: ST_TO_ADDR
19296: GO 19258
19298: POP
19299: POP
// result := tmp ;
19300: LD_ADDR_VAR 0 6
19304: PUSH
19305: LD_VAR 0 9
19309: ST_TO_ADDR
// end ; end ;
19310: LD_VAR 0 6
19314: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19315: LD_INT 0
19317: PPUSH
19318: PPUSH
19319: PPUSH
19320: PPUSH
19321: PPUSH
19322: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19323: LD_ADDR_VAR 0 5
19327: PUSH
19328: LD_INT 0
19330: PUSH
19331: LD_INT 0
19333: PUSH
19334: LD_INT 0
19336: PUSH
19337: EMPTY
19338: PUSH
19339: EMPTY
19340: LIST
19341: LIST
19342: LIST
19343: LIST
19344: ST_TO_ADDR
// if not x or not y then
19345: LD_VAR 0 2
19349: NOT
19350: PUSH
19351: LD_VAR 0 3
19355: NOT
19356: OR
19357: IFFALSE 19361
// exit ;
19359: GO 21007
// if not range then
19361: LD_VAR 0 4
19365: NOT
19366: IFFALSE 19376
// range := 10 ;
19368: LD_ADDR_VAR 0 4
19372: PUSH
19373: LD_INT 10
19375: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19376: LD_ADDR_VAR 0 8
19380: PUSH
19381: LD_INT 81
19383: PUSH
19384: LD_VAR 0 1
19388: PUSH
19389: EMPTY
19390: LIST
19391: LIST
19392: PUSH
19393: LD_INT 92
19395: PUSH
19396: LD_VAR 0 2
19400: PUSH
19401: LD_VAR 0 3
19405: PUSH
19406: LD_VAR 0 4
19410: PUSH
19411: EMPTY
19412: LIST
19413: LIST
19414: LIST
19415: LIST
19416: PUSH
19417: LD_INT 3
19419: PUSH
19420: LD_INT 21
19422: PUSH
19423: LD_INT 3
19425: PUSH
19426: EMPTY
19427: LIST
19428: LIST
19429: PUSH
19430: EMPTY
19431: LIST
19432: LIST
19433: PUSH
19434: EMPTY
19435: LIST
19436: LIST
19437: LIST
19438: PPUSH
19439: CALL_OW 69
19443: ST_TO_ADDR
// if not tmp then
19444: LD_VAR 0 8
19448: NOT
19449: IFFALSE 19453
// exit ;
19451: GO 21007
// for i in tmp do
19453: LD_ADDR_VAR 0 6
19457: PUSH
19458: LD_VAR 0 8
19462: PUSH
19463: FOR_IN
19464: IFFALSE 20982
// begin points := [ 0 , 0 , 0 ] ;
19466: LD_ADDR_VAR 0 9
19470: PUSH
19471: LD_INT 0
19473: PUSH
19474: LD_INT 0
19476: PUSH
19477: LD_INT 0
19479: PUSH
19480: EMPTY
19481: LIST
19482: LIST
19483: LIST
19484: ST_TO_ADDR
// bpoints := 1 ;
19485: LD_ADDR_VAR 0 10
19489: PUSH
19490: LD_INT 1
19492: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19493: LD_VAR 0 6
19497: PPUSH
19498: CALL_OW 247
19502: PUSH
19503: LD_INT 1
19505: DOUBLE
19506: EQUAL
19507: IFTRUE 19511
19509: GO 20089
19511: POP
// begin if GetClass ( i ) = 1 then
19512: LD_VAR 0 6
19516: PPUSH
19517: CALL_OW 257
19521: PUSH
19522: LD_INT 1
19524: EQUAL
19525: IFFALSE 19546
// points := [ 10 , 5 , 3 ] ;
19527: LD_ADDR_VAR 0 9
19531: PUSH
19532: LD_INT 10
19534: PUSH
19535: LD_INT 5
19537: PUSH
19538: LD_INT 3
19540: PUSH
19541: EMPTY
19542: LIST
19543: LIST
19544: LIST
19545: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19546: LD_VAR 0 6
19550: PPUSH
19551: CALL_OW 257
19555: PUSH
19556: LD_INT 2
19558: PUSH
19559: LD_INT 3
19561: PUSH
19562: LD_INT 4
19564: PUSH
19565: EMPTY
19566: LIST
19567: LIST
19568: LIST
19569: IN
19570: IFFALSE 19591
// points := [ 3 , 2 , 1 ] ;
19572: LD_ADDR_VAR 0 9
19576: PUSH
19577: LD_INT 3
19579: PUSH
19580: LD_INT 2
19582: PUSH
19583: LD_INT 1
19585: PUSH
19586: EMPTY
19587: LIST
19588: LIST
19589: LIST
19590: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19591: LD_VAR 0 6
19595: PPUSH
19596: CALL_OW 257
19600: PUSH
19601: LD_INT 5
19603: EQUAL
19604: IFFALSE 19625
// points := [ 130 , 5 , 2 ] ;
19606: LD_ADDR_VAR 0 9
19610: PUSH
19611: LD_INT 130
19613: PUSH
19614: LD_INT 5
19616: PUSH
19617: LD_INT 2
19619: PUSH
19620: EMPTY
19621: LIST
19622: LIST
19623: LIST
19624: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19625: LD_VAR 0 6
19629: PPUSH
19630: CALL_OW 257
19634: PUSH
19635: LD_INT 8
19637: EQUAL
19638: IFFALSE 19659
// points := [ 35 , 35 , 30 ] ;
19640: LD_ADDR_VAR 0 9
19644: PUSH
19645: LD_INT 35
19647: PUSH
19648: LD_INT 35
19650: PUSH
19651: LD_INT 30
19653: PUSH
19654: EMPTY
19655: LIST
19656: LIST
19657: LIST
19658: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19659: LD_VAR 0 6
19663: PPUSH
19664: CALL_OW 257
19668: PUSH
19669: LD_INT 9
19671: EQUAL
19672: IFFALSE 19693
// points := [ 20 , 55 , 40 ] ;
19674: LD_ADDR_VAR 0 9
19678: PUSH
19679: LD_INT 20
19681: PUSH
19682: LD_INT 55
19684: PUSH
19685: LD_INT 40
19687: PUSH
19688: EMPTY
19689: LIST
19690: LIST
19691: LIST
19692: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
19693: LD_VAR 0 6
19697: PPUSH
19698: CALL_OW 257
19702: PUSH
19703: LD_INT 12
19705: PUSH
19706: LD_INT 16
19708: PUSH
19709: EMPTY
19710: LIST
19711: LIST
19712: IN
19713: IFFALSE 19734
// points := [ 5 , 3 , 2 ] ;
19715: LD_ADDR_VAR 0 9
19719: PUSH
19720: LD_INT 5
19722: PUSH
19723: LD_INT 3
19725: PUSH
19726: LD_INT 2
19728: PUSH
19729: EMPTY
19730: LIST
19731: LIST
19732: LIST
19733: ST_TO_ADDR
// if GetClass ( i ) = 17 then
19734: LD_VAR 0 6
19738: PPUSH
19739: CALL_OW 257
19743: PUSH
19744: LD_INT 17
19746: EQUAL
19747: IFFALSE 19768
// points := [ 100 , 50 , 75 ] ;
19749: LD_ADDR_VAR 0 9
19753: PUSH
19754: LD_INT 100
19756: PUSH
19757: LD_INT 50
19759: PUSH
19760: LD_INT 75
19762: PUSH
19763: EMPTY
19764: LIST
19765: LIST
19766: LIST
19767: ST_TO_ADDR
// if GetClass ( i ) = 15 then
19768: LD_VAR 0 6
19772: PPUSH
19773: CALL_OW 257
19777: PUSH
19778: LD_INT 15
19780: EQUAL
19781: IFFALSE 19802
// points := [ 10 , 5 , 3 ] ;
19783: LD_ADDR_VAR 0 9
19787: PUSH
19788: LD_INT 10
19790: PUSH
19791: LD_INT 5
19793: PUSH
19794: LD_INT 3
19796: PUSH
19797: EMPTY
19798: LIST
19799: LIST
19800: LIST
19801: ST_TO_ADDR
// if GetClass ( i ) = 14 then
19802: LD_VAR 0 6
19806: PPUSH
19807: CALL_OW 257
19811: PUSH
19812: LD_INT 14
19814: EQUAL
19815: IFFALSE 19836
// points := [ 10 , 0 , 0 ] ;
19817: LD_ADDR_VAR 0 9
19821: PUSH
19822: LD_INT 10
19824: PUSH
19825: LD_INT 0
19827: PUSH
19828: LD_INT 0
19830: PUSH
19831: EMPTY
19832: LIST
19833: LIST
19834: LIST
19835: ST_TO_ADDR
// if GetClass ( i ) = 11 then
19836: LD_VAR 0 6
19840: PPUSH
19841: CALL_OW 257
19845: PUSH
19846: LD_INT 11
19848: EQUAL
19849: IFFALSE 19870
// points := [ 30 , 10 , 5 ] ;
19851: LD_ADDR_VAR 0 9
19855: PUSH
19856: LD_INT 30
19858: PUSH
19859: LD_INT 10
19861: PUSH
19862: LD_INT 5
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: LIST
19869: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
19870: LD_VAR 0 1
19874: PPUSH
19875: LD_INT 5
19877: PPUSH
19878: CALL_OW 321
19882: PUSH
19883: LD_INT 2
19885: EQUAL
19886: IFFALSE 19903
// bpoints := bpoints * 1.8 ;
19888: LD_ADDR_VAR 0 10
19892: PUSH
19893: LD_VAR 0 10
19897: PUSH
19898: LD_REAL  1.80000000000000E+0000
19901: MUL
19902: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
19903: LD_VAR 0 6
19907: PPUSH
19908: CALL_OW 257
19912: PUSH
19913: LD_INT 1
19915: PUSH
19916: LD_INT 2
19918: PUSH
19919: LD_INT 3
19921: PUSH
19922: LD_INT 4
19924: PUSH
19925: EMPTY
19926: LIST
19927: LIST
19928: LIST
19929: LIST
19930: IN
19931: PUSH
19932: LD_VAR 0 1
19936: PPUSH
19937: LD_INT 51
19939: PPUSH
19940: CALL_OW 321
19944: PUSH
19945: LD_INT 2
19947: EQUAL
19948: AND
19949: IFFALSE 19966
// bpoints := bpoints * 1.2 ;
19951: LD_ADDR_VAR 0 10
19955: PUSH
19956: LD_VAR 0 10
19960: PUSH
19961: LD_REAL  1.20000000000000E+0000
19964: MUL
19965: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
19966: LD_VAR 0 6
19970: PPUSH
19971: CALL_OW 257
19975: PUSH
19976: LD_INT 5
19978: PUSH
19979: LD_INT 7
19981: PUSH
19982: LD_INT 9
19984: PUSH
19985: EMPTY
19986: LIST
19987: LIST
19988: LIST
19989: IN
19990: PUSH
19991: LD_VAR 0 1
19995: PPUSH
19996: LD_INT 52
19998: PPUSH
19999: CALL_OW 321
20003: PUSH
20004: LD_INT 2
20006: EQUAL
20007: AND
20008: IFFALSE 20025
// bpoints := bpoints * 1.5 ;
20010: LD_ADDR_VAR 0 10
20014: PUSH
20015: LD_VAR 0 10
20019: PUSH
20020: LD_REAL  1.50000000000000E+0000
20023: MUL
20024: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20025: LD_VAR 0 1
20029: PPUSH
20030: LD_INT 66
20032: PPUSH
20033: CALL_OW 321
20037: PUSH
20038: LD_INT 2
20040: EQUAL
20041: IFFALSE 20058
// bpoints := bpoints * 1.1 ;
20043: LD_ADDR_VAR 0 10
20047: PUSH
20048: LD_VAR 0 10
20052: PUSH
20053: LD_REAL  1.10000000000000E+0000
20056: MUL
20057: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20058: LD_ADDR_VAR 0 10
20062: PUSH
20063: LD_VAR 0 10
20067: PUSH
20068: LD_VAR 0 6
20072: PPUSH
20073: LD_INT 1
20075: PPUSH
20076: CALL_OW 259
20080: PUSH
20081: LD_REAL  1.15000000000000E+0000
20084: MUL
20085: MUL
20086: ST_TO_ADDR
// end ; unit_vehicle :
20087: GO 20911
20089: LD_INT 2
20091: DOUBLE
20092: EQUAL
20093: IFTRUE 20097
20095: GO 20899
20097: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20098: LD_VAR 0 6
20102: PPUSH
20103: CALL_OW 264
20107: PUSH
20108: LD_INT 2
20110: PUSH
20111: LD_INT 42
20113: PUSH
20114: LD_INT 24
20116: PUSH
20117: EMPTY
20118: LIST
20119: LIST
20120: LIST
20121: IN
20122: IFFALSE 20143
// points := [ 25 , 5 , 3 ] ;
20124: LD_ADDR_VAR 0 9
20128: PUSH
20129: LD_INT 25
20131: PUSH
20132: LD_INT 5
20134: PUSH
20135: LD_INT 3
20137: PUSH
20138: EMPTY
20139: LIST
20140: LIST
20141: LIST
20142: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20143: LD_VAR 0 6
20147: PPUSH
20148: CALL_OW 264
20152: PUSH
20153: LD_INT 4
20155: PUSH
20156: LD_INT 43
20158: PUSH
20159: LD_INT 25
20161: PUSH
20162: EMPTY
20163: LIST
20164: LIST
20165: LIST
20166: IN
20167: IFFALSE 20188
// points := [ 40 , 15 , 5 ] ;
20169: LD_ADDR_VAR 0 9
20173: PUSH
20174: LD_INT 40
20176: PUSH
20177: LD_INT 15
20179: PUSH
20180: LD_INT 5
20182: PUSH
20183: EMPTY
20184: LIST
20185: LIST
20186: LIST
20187: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
20188: LD_VAR 0 6
20192: PPUSH
20193: CALL_OW 264
20197: PUSH
20198: LD_INT 3
20200: PUSH
20201: LD_INT 23
20203: PUSH
20204: EMPTY
20205: LIST
20206: LIST
20207: IN
20208: IFFALSE 20229
// points := [ 7 , 25 , 8 ] ;
20210: LD_ADDR_VAR 0 9
20214: PUSH
20215: LD_INT 7
20217: PUSH
20218: LD_INT 25
20220: PUSH
20221: LD_INT 8
20223: PUSH
20224: EMPTY
20225: LIST
20226: LIST
20227: LIST
20228: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
20229: LD_VAR 0 6
20233: PPUSH
20234: CALL_OW 264
20238: PUSH
20239: LD_INT 5
20241: PUSH
20242: LD_INT 27
20244: PUSH
20245: LD_INT 44
20247: PUSH
20248: EMPTY
20249: LIST
20250: LIST
20251: LIST
20252: IN
20253: IFFALSE 20274
// points := [ 14 , 50 , 16 ] ;
20255: LD_ADDR_VAR 0 9
20259: PUSH
20260: LD_INT 14
20262: PUSH
20263: LD_INT 50
20265: PUSH
20266: LD_INT 16
20268: PUSH
20269: EMPTY
20270: LIST
20271: LIST
20272: LIST
20273: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20274: LD_VAR 0 6
20278: PPUSH
20279: CALL_OW 264
20283: PUSH
20284: LD_INT 6
20286: PUSH
20287: LD_INT 46
20289: PUSH
20290: EMPTY
20291: LIST
20292: LIST
20293: IN
20294: IFFALSE 20315
// points := [ 32 , 120 , 70 ] ;
20296: LD_ADDR_VAR 0 9
20300: PUSH
20301: LD_INT 32
20303: PUSH
20304: LD_INT 120
20306: PUSH
20307: LD_INT 70
20309: PUSH
20310: EMPTY
20311: LIST
20312: LIST
20313: LIST
20314: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
20315: LD_VAR 0 6
20319: PPUSH
20320: CALL_OW 264
20324: PUSH
20325: LD_INT 7
20327: PUSH
20328: LD_INT 28
20330: PUSH
20331: LD_INT 45
20333: PUSH
20334: EMPTY
20335: LIST
20336: LIST
20337: LIST
20338: IN
20339: IFFALSE 20360
// points := [ 35 , 20 , 45 ] ;
20341: LD_ADDR_VAR 0 9
20345: PUSH
20346: LD_INT 35
20348: PUSH
20349: LD_INT 20
20351: PUSH
20352: LD_INT 45
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: LIST
20359: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20360: LD_VAR 0 6
20364: PPUSH
20365: CALL_OW 264
20369: PUSH
20370: LD_INT 47
20372: PUSH
20373: EMPTY
20374: LIST
20375: IN
20376: IFFALSE 20397
// points := [ 67 , 45 , 75 ] ;
20378: LD_ADDR_VAR 0 9
20382: PUSH
20383: LD_INT 67
20385: PUSH
20386: LD_INT 45
20388: PUSH
20389: LD_INT 75
20391: PUSH
20392: EMPTY
20393: LIST
20394: LIST
20395: LIST
20396: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20397: LD_VAR 0 6
20401: PPUSH
20402: CALL_OW 264
20406: PUSH
20407: LD_INT 26
20409: PUSH
20410: EMPTY
20411: LIST
20412: IN
20413: IFFALSE 20434
// points := [ 120 , 30 , 80 ] ;
20415: LD_ADDR_VAR 0 9
20419: PUSH
20420: LD_INT 120
20422: PUSH
20423: LD_INT 30
20425: PUSH
20426: LD_INT 80
20428: PUSH
20429: EMPTY
20430: LIST
20431: LIST
20432: LIST
20433: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20434: LD_VAR 0 6
20438: PPUSH
20439: CALL_OW 264
20443: PUSH
20444: LD_INT 22
20446: PUSH
20447: EMPTY
20448: LIST
20449: IN
20450: IFFALSE 20471
// points := [ 40 , 1 , 1 ] ;
20452: LD_ADDR_VAR 0 9
20456: PUSH
20457: LD_INT 40
20459: PUSH
20460: LD_INT 1
20462: PUSH
20463: LD_INT 1
20465: PUSH
20466: EMPTY
20467: LIST
20468: LIST
20469: LIST
20470: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20471: LD_VAR 0 6
20475: PPUSH
20476: CALL_OW 264
20480: PUSH
20481: LD_INT 29
20483: PUSH
20484: EMPTY
20485: LIST
20486: IN
20487: IFFALSE 20508
// points := [ 70 , 200 , 400 ] ;
20489: LD_ADDR_VAR 0 9
20493: PUSH
20494: LD_INT 70
20496: PUSH
20497: LD_INT 200
20499: PUSH
20500: LD_INT 400
20502: PUSH
20503: EMPTY
20504: LIST
20505: LIST
20506: LIST
20507: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20508: LD_VAR 0 6
20512: PPUSH
20513: CALL_OW 264
20517: PUSH
20518: LD_INT 14
20520: PUSH
20521: LD_INT 53
20523: PUSH
20524: EMPTY
20525: LIST
20526: LIST
20527: IN
20528: IFFALSE 20549
// points := [ 40 , 10 , 20 ] ;
20530: LD_ADDR_VAR 0 9
20534: PUSH
20535: LD_INT 40
20537: PUSH
20538: LD_INT 10
20540: PUSH
20541: LD_INT 20
20543: PUSH
20544: EMPTY
20545: LIST
20546: LIST
20547: LIST
20548: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20549: LD_VAR 0 6
20553: PPUSH
20554: CALL_OW 264
20558: PUSH
20559: LD_INT 9
20561: PUSH
20562: EMPTY
20563: LIST
20564: IN
20565: IFFALSE 20586
// points := [ 5 , 70 , 20 ] ;
20567: LD_ADDR_VAR 0 9
20571: PUSH
20572: LD_INT 5
20574: PUSH
20575: LD_INT 70
20577: PUSH
20578: LD_INT 20
20580: PUSH
20581: EMPTY
20582: LIST
20583: LIST
20584: LIST
20585: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20586: LD_VAR 0 6
20590: PPUSH
20591: CALL_OW 264
20595: PUSH
20596: LD_INT 10
20598: PUSH
20599: EMPTY
20600: LIST
20601: IN
20602: IFFALSE 20623
// points := [ 35 , 110 , 70 ] ;
20604: LD_ADDR_VAR 0 9
20608: PUSH
20609: LD_INT 35
20611: PUSH
20612: LD_INT 110
20614: PUSH
20615: LD_INT 70
20617: PUSH
20618: EMPTY
20619: LIST
20620: LIST
20621: LIST
20622: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20623: LD_VAR 0 6
20627: PPUSH
20628: CALL_OW 265
20632: PUSH
20633: LD_INT 25
20635: EQUAL
20636: IFFALSE 20657
// points := [ 80 , 65 , 100 ] ;
20638: LD_ADDR_VAR 0 9
20642: PUSH
20643: LD_INT 80
20645: PUSH
20646: LD_INT 65
20648: PUSH
20649: LD_INT 100
20651: PUSH
20652: EMPTY
20653: LIST
20654: LIST
20655: LIST
20656: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20657: LD_VAR 0 6
20661: PPUSH
20662: CALL_OW 263
20666: PUSH
20667: LD_INT 1
20669: EQUAL
20670: IFFALSE 20705
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
20672: LD_ADDR_VAR 0 10
20676: PUSH
20677: LD_VAR 0 10
20681: PUSH
20682: LD_VAR 0 6
20686: PPUSH
20687: CALL_OW 311
20691: PPUSH
20692: LD_INT 3
20694: PPUSH
20695: CALL_OW 259
20699: PUSH
20700: LD_INT 4
20702: MUL
20703: MUL
20704: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
20705: LD_VAR 0 6
20709: PPUSH
20710: CALL_OW 263
20714: PUSH
20715: LD_INT 2
20717: EQUAL
20718: IFFALSE 20769
// begin j := IsControledBy ( i ) ;
20720: LD_ADDR_VAR 0 7
20724: PUSH
20725: LD_VAR 0 6
20729: PPUSH
20730: CALL_OW 312
20734: ST_TO_ADDR
// if j then
20735: LD_VAR 0 7
20739: IFFALSE 20769
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
20741: LD_ADDR_VAR 0 10
20745: PUSH
20746: LD_VAR 0 10
20750: PUSH
20751: LD_VAR 0 7
20755: PPUSH
20756: LD_INT 3
20758: PPUSH
20759: CALL_OW 259
20763: PUSH
20764: LD_INT 3
20766: MUL
20767: MUL
20768: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
20769: LD_VAR 0 6
20773: PPUSH
20774: CALL_OW 264
20778: PUSH
20779: LD_INT 5
20781: PUSH
20782: LD_INT 6
20784: PUSH
20785: LD_INT 46
20787: PUSH
20788: LD_INT 44
20790: PUSH
20791: LD_INT 47
20793: PUSH
20794: LD_INT 45
20796: PUSH
20797: LD_INT 28
20799: PUSH
20800: LD_INT 7
20802: PUSH
20803: LD_INT 27
20805: PUSH
20806: LD_INT 29
20808: PUSH
20809: EMPTY
20810: LIST
20811: LIST
20812: LIST
20813: LIST
20814: LIST
20815: LIST
20816: LIST
20817: LIST
20818: LIST
20819: LIST
20820: IN
20821: PUSH
20822: LD_VAR 0 1
20826: PPUSH
20827: LD_INT 52
20829: PPUSH
20830: CALL_OW 321
20834: PUSH
20835: LD_INT 2
20837: EQUAL
20838: AND
20839: IFFALSE 20856
// bpoints := bpoints * 1.2 ;
20841: LD_ADDR_VAR 0 10
20845: PUSH
20846: LD_VAR 0 10
20850: PUSH
20851: LD_REAL  1.20000000000000E+0000
20854: MUL
20855: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
20856: LD_VAR 0 6
20860: PPUSH
20861: CALL_OW 264
20865: PUSH
20866: LD_INT 6
20868: PUSH
20869: LD_INT 46
20871: PUSH
20872: LD_INT 47
20874: PUSH
20875: EMPTY
20876: LIST
20877: LIST
20878: LIST
20879: IN
20880: IFFALSE 20897
// bpoints := bpoints * 1.2 ;
20882: LD_ADDR_VAR 0 10
20886: PUSH
20887: LD_VAR 0 10
20891: PUSH
20892: LD_REAL  1.20000000000000E+0000
20895: MUL
20896: ST_TO_ADDR
// end ; unit_building :
20897: GO 20911
20899: LD_INT 3
20901: DOUBLE
20902: EQUAL
20903: IFTRUE 20907
20905: GO 20910
20907: POP
// ; end ;
20908: GO 20911
20910: POP
// for j = 1 to 3 do
20911: LD_ADDR_VAR 0 7
20915: PUSH
20916: DOUBLE
20917: LD_INT 1
20919: DEC
20920: ST_TO_ADDR
20921: LD_INT 3
20923: PUSH
20924: FOR_TO
20925: IFFALSE 20978
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
20927: LD_ADDR_VAR 0 5
20931: PUSH
20932: LD_VAR 0 5
20936: PPUSH
20937: LD_VAR 0 7
20941: PPUSH
20942: LD_VAR 0 5
20946: PUSH
20947: LD_VAR 0 7
20951: ARRAY
20952: PUSH
20953: LD_VAR 0 9
20957: PUSH
20958: LD_VAR 0 7
20962: ARRAY
20963: PUSH
20964: LD_VAR 0 10
20968: MUL
20969: PLUS
20970: PPUSH
20971: CALL_OW 1
20975: ST_TO_ADDR
20976: GO 20924
20978: POP
20979: POP
// end ;
20980: GO 19463
20982: POP
20983: POP
// result := Replace ( result , 4 , tmp ) ;
20984: LD_ADDR_VAR 0 5
20988: PUSH
20989: LD_VAR 0 5
20993: PPUSH
20994: LD_INT 4
20996: PPUSH
20997: LD_VAR 0 8
21001: PPUSH
21002: CALL_OW 1
21006: ST_TO_ADDR
// end ;
21007: LD_VAR 0 5
21011: RET
// export function DangerAtRange ( unit , range ) ; begin
21012: LD_INT 0
21014: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21015: LD_ADDR_VAR 0 3
21019: PUSH
21020: LD_VAR 0 1
21024: PPUSH
21025: CALL_OW 255
21029: PPUSH
21030: LD_VAR 0 1
21034: PPUSH
21035: CALL_OW 250
21039: PPUSH
21040: LD_VAR 0 1
21044: PPUSH
21045: CALL_OW 251
21049: PPUSH
21050: LD_VAR 0 2
21054: PPUSH
21055: CALL 19315 0 4
21059: ST_TO_ADDR
// end ;
21060: LD_VAR 0 3
21064: RET
// export function DangerInArea ( side , area ) ; begin
21065: LD_INT 0
21067: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21068: LD_ADDR_VAR 0 3
21072: PUSH
21073: LD_VAR 0 2
21077: PPUSH
21078: LD_INT 81
21080: PUSH
21081: LD_VAR 0 1
21085: PUSH
21086: EMPTY
21087: LIST
21088: LIST
21089: PPUSH
21090: CALL_OW 70
21094: ST_TO_ADDR
// end ;
21095: LD_VAR 0 3
21099: RET
// export function IsExtension ( b ) ; begin
21100: LD_INT 0
21102: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21103: LD_ADDR_VAR 0 2
21107: PUSH
21108: LD_VAR 0 1
21112: PUSH
21113: LD_INT 23
21115: PUSH
21116: LD_INT 20
21118: PUSH
21119: LD_INT 22
21121: PUSH
21122: LD_INT 17
21124: PUSH
21125: LD_INT 24
21127: PUSH
21128: LD_INT 21
21130: PUSH
21131: LD_INT 19
21133: PUSH
21134: LD_INT 16
21136: PUSH
21137: LD_INT 25
21139: PUSH
21140: LD_INT 18
21142: PUSH
21143: EMPTY
21144: LIST
21145: LIST
21146: LIST
21147: LIST
21148: LIST
21149: LIST
21150: LIST
21151: LIST
21152: LIST
21153: LIST
21154: IN
21155: ST_TO_ADDR
// end ;
21156: LD_VAR 0 2
21160: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
21161: LD_INT 0
21163: PPUSH
21164: PPUSH
21165: PPUSH
// result := [ ] ;
21166: LD_ADDR_VAR 0 3
21170: PUSH
21171: EMPTY
21172: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21173: LD_ADDR_VAR 0 4
21177: PUSH
21178: LD_VAR 0 2
21182: PPUSH
21183: LD_INT 21
21185: PUSH
21186: LD_INT 3
21188: PUSH
21189: EMPTY
21190: LIST
21191: LIST
21192: PPUSH
21193: CALL_OW 70
21197: ST_TO_ADDR
// if not tmp then
21198: LD_VAR 0 4
21202: NOT
21203: IFFALSE 21207
// exit ;
21205: GO 21265
// for i in tmp do
21207: LD_ADDR_VAR 0 5
21211: PUSH
21212: LD_VAR 0 4
21216: PUSH
21217: FOR_IN
21218: IFFALSE 21253
// if GetBase ( i ) <> base then
21220: LD_VAR 0 5
21224: PPUSH
21225: CALL_OW 274
21229: PUSH
21230: LD_VAR 0 1
21234: NONEQUAL
21235: IFFALSE 21251
// ComLinkToBase ( base , i ) ;
21237: LD_VAR 0 1
21241: PPUSH
21242: LD_VAR 0 5
21246: PPUSH
21247: CALL_OW 169
21251: GO 21217
21253: POP
21254: POP
// result := tmp ;
21255: LD_ADDR_VAR 0 3
21259: PUSH
21260: LD_VAR 0 4
21264: ST_TO_ADDR
// end ;
21265: LD_VAR 0 3
21269: RET
// export function ComComplete ( unit , b ) ; var i ; begin
21270: LD_INT 0
21272: PPUSH
21273: PPUSH
// if BuildingStatus ( b ) = bs_build then
21274: LD_VAR 0 2
21278: PPUSH
21279: CALL_OW 461
21283: PUSH
21284: LD_INT 1
21286: EQUAL
21287: IFFALSE 21347
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21289: LD_VAR 0 1
21293: PPUSH
21294: LD_STRING h
21296: PUSH
21297: LD_VAR 0 2
21301: PPUSH
21302: CALL_OW 250
21306: PUSH
21307: LD_VAR 0 2
21311: PPUSH
21312: CALL_OW 251
21316: PUSH
21317: LD_VAR 0 2
21321: PUSH
21322: LD_INT 0
21324: PUSH
21325: LD_INT 0
21327: PUSH
21328: LD_INT 0
21330: PUSH
21331: EMPTY
21332: LIST
21333: LIST
21334: LIST
21335: LIST
21336: LIST
21337: LIST
21338: LIST
21339: PUSH
21340: EMPTY
21341: LIST
21342: PPUSH
21343: CALL_OW 446
// end ;
21347: LD_VAR 0 3
21351: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21352: LD_INT 0
21354: PPUSH
21355: PPUSH
21356: PPUSH
21357: PPUSH
21358: PPUSH
21359: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
21360: LD_VAR 0 1
21364: NOT
21365: PUSH
21366: LD_VAR 0 1
21370: PPUSH
21371: CALL_OW 263
21375: PUSH
21376: LD_INT 2
21378: EQUAL
21379: NOT
21380: OR
21381: IFFALSE 21385
// exit ;
21383: GO 21701
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21385: LD_ADDR_VAR 0 6
21389: PUSH
21390: LD_INT 22
21392: PUSH
21393: LD_VAR 0 1
21397: PPUSH
21398: CALL_OW 255
21402: PUSH
21403: EMPTY
21404: LIST
21405: LIST
21406: PUSH
21407: LD_INT 2
21409: PUSH
21410: LD_INT 30
21412: PUSH
21413: LD_INT 36
21415: PUSH
21416: EMPTY
21417: LIST
21418: LIST
21419: PUSH
21420: LD_INT 34
21422: PUSH
21423: LD_INT 31
21425: PUSH
21426: EMPTY
21427: LIST
21428: LIST
21429: PUSH
21430: EMPTY
21431: LIST
21432: LIST
21433: LIST
21434: PUSH
21435: EMPTY
21436: LIST
21437: LIST
21438: PPUSH
21439: CALL_OW 69
21443: ST_TO_ADDR
// if not tmp then
21444: LD_VAR 0 6
21448: NOT
21449: IFFALSE 21453
// exit ;
21451: GO 21701
// result := [ ] ;
21453: LD_ADDR_VAR 0 2
21457: PUSH
21458: EMPTY
21459: ST_TO_ADDR
// for i in tmp do
21460: LD_ADDR_VAR 0 3
21464: PUSH
21465: LD_VAR 0 6
21469: PUSH
21470: FOR_IN
21471: IFFALSE 21542
// begin t := UnitsInside ( i ) ;
21473: LD_ADDR_VAR 0 4
21477: PUSH
21478: LD_VAR 0 3
21482: PPUSH
21483: CALL_OW 313
21487: ST_TO_ADDR
// if t then
21488: LD_VAR 0 4
21492: IFFALSE 21540
// for j in t do
21494: LD_ADDR_VAR 0 7
21498: PUSH
21499: LD_VAR 0 4
21503: PUSH
21504: FOR_IN
21505: IFFALSE 21538
// result := Insert ( result , result + 1 , j ) ;
21507: LD_ADDR_VAR 0 2
21511: PUSH
21512: LD_VAR 0 2
21516: PPUSH
21517: LD_VAR 0 2
21521: PUSH
21522: LD_INT 1
21524: PLUS
21525: PPUSH
21526: LD_VAR 0 7
21530: PPUSH
21531: CALL_OW 2
21535: ST_TO_ADDR
21536: GO 21504
21538: POP
21539: POP
// end ;
21540: GO 21470
21542: POP
21543: POP
// if not result then
21544: LD_VAR 0 2
21548: NOT
21549: IFFALSE 21553
// exit ;
21551: GO 21701
// mech := result [ 1 ] ;
21553: LD_ADDR_VAR 0 5
21557: PUSH
21558: LD_VAR 0 2
21562: PUSH
21563: LD_INT 1
21565: ARRAY
21566: ST_TO_ADDR
// if result > 1 then
21567: LD_VAR 0 2
21571: PUSH
21572: LD_INT 1
21574: GREATER
21575: IFFALSE 21687
// for i = 2 to result do
21577: LD_ADDR_VAR 0 3
21581: PUSH
21582: DOUBLE
21583: LD_INT 2
21585: DEC
21586: ST_TO_ADDR
21587: LD_VAR 0 2
21591: PUSH
21592: FOR_TO
21593: IFFALSE 21685
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21595: LD_ADDR_VAR 0 4
21599: PUSH
21600: LD_VAR 0 2
21604: PUSH
21605: LD_VAR 0 3
21609: ARRAY
21610: PPUSH
21611: LD_INT 3
21613: PPUSH
21614: CALL_OW 259
21618: PUSH
21619: LD_VAR 0 2
21623: PUSH
21624: LD_VAR 0 3
21628: ARRAY
21629: PPUSH
21630: CALL_OW 432
21634: MINUS
21635: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
21636: LD_VAR 0 4
21640: PUSH
21641: LD_VAR 0 5
21645: PPUSH
21646: LD_INT 3
21648: PPUSH
21649: CALL_OW 259
21653: PUSH
21654: LD_VAR 0 5
21658: PPUSH
21659: CALL_OW 432
21663: MINUS
21664: GREATEREQUAL
21665: IFFALSE 21683
// mech := result [ i ] ;
21667: LD_ADDR_VAR 0 5
21671: PUSH
21672: LD_VAR 0 2
21676: PUSH
21677: LD_VAR 0 3
21681: ARRAY
21682: ST_TO_ADDR
// end ;
21683: GO 21592
21685: POP
21686: POP
// ComLinkTo ( vehicle , mech ) ;
21687: LD_VAR 0 1
21691: PPUSH
21692: LD_VAR 0 5
21696: PPUSH
21697: CALL_OW 135
// end ;
21701: LD_VAR 0 2
21705: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
21706: LD_INT 0
21708: PPUSH
21709: PPUSH
21710: PPUSH
21711: PPUSH
21712: PPUSH
21713: PPUSH
21714: PPUSH
21715: PPUSH
21716: PPUSH
21717: PPUSH
21718: PPUSH
21719: PPUSH
21720: PPUSH
// result := [ ] ;
21721: LD_ADDR_VAR 0 7
21725: PUSH
21726: EMPTY
21727: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
21728: LD_VAR 0 1
21732: PPUSH
21733: CALL_OW 266
21737: PUSH
21738: LD_INT 0
21740: PUSH
21741: LD_INT 1
21743: PUSH
21744: EMPTY
21745: LIST
21746: LIST
21747: IN
21748: NOT
21749: IFFALSE 21753
// exit ;
21751: GO 23384
// if name then
21753: LD_VAR 0 3
21757: IFFALSE 21773
// SetBName ( base_dep , name ) ;
21759: LD_VAR 0 1
21763: PPUSH
21764: LD_VAR 0 3
21768: PPUSH
21769: CALL_OW 500
// base := GetBase ( base_dep ) ;
21773: LD_ADDR_VAR 0 15
21777: PUSH
21778: LD_VAR 0 1
21782: PPUSH
21783: CALL_OW 274
21787: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
21788: LD_ADDR_VAR 0 16
21792: PUSH
21793: LD_VAR 0 1
21797: PPUSH
21798: CALL_OW 255
21802: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
21803: LD_ADDR_VAR 0 17
21807: PUSH
21808: LD_VAR 0 1
21812: PPUSH
21813: CALL_OW 248
21817: ST_TO_ADDR
// if sources then
21818: LD_VAR 0 5
21822: IFFALSE 21869
// for i = 1 to 3 do
21824: LD_ADDR_VAR 0 8
21828: PUSH
21829: DOUBLE
21830: LD_INT 1
21832: DEC
21833: ST_TO_ADDR
21834: LD_INT 3
21836: PUSH
21837: FOR_TO
21838: IFFALSE 21867
// AddResourceType ( base , i , sources [ i ] ) ;
21840: LD_VAR 0 15
21844: PPUSH
21845: LD_VAR 0 8
21849: PPUSH
21850: LD_VAR 0 5
21854: PUSH
21855: LD_VAR 0 8
21859: ARRAY
21860: PPUSH
21861: CALL_OW 276
21865: GO 21837
21867: POP
21868: POP
// buildings := GetBaseBuildings ( base , area ) ;
21869: LD_ADDR_VAR 0 18
21873: PUSH
21874: LD_VAR 0 15
21878: PPUSH
21879: LD_VAR 0 2
21883: PPUSH
21884: CALL 21161 0 2
21888: ST_TO_ADDR
// InitHc ;
21889: CALL_OW 19
// InitUc ;
21893: CALL_OW 18
// uc_side := side ;
21897: LD_ADDR_OWVAR 20
21901: PUSH
21902: LD_VAR 0 16
21906: ST_TO_ADDR
// uc_nation := nation ;
21907: LD_ADDR_OWVAR 21
21911: PUSH
21912: LD_VAR 0 17
21916: ST_TO_ADDR
// if buildings then
21917: LD_VAR 0 18
21921: IFFALSE 23243
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
21923: LD_ADDR_VAR 0 19
21927: PUSH
21928: LD_VAR 0 18
21932: PPUSH
21933: LD_INT 2
21935: PUSH
21936: LD_INT 30
21938: PUSH
21939: LD_INT 29
21941: PUSH
21942: EMPTY
21943: LIST
21944: LIST
21945: PUSH
21946: LD_INT 30
21948: PUSH
21949: LD_INT 30
21951: PUSH
21952: EMPTY
21953: LIST
21954: LIST
21955: PUSH
21956: EMPTY
21957: LIST
21958: LIST
21959: LIST
21960: PPUSH
21961: CALL_OW 72
21965: ST_TO_ADDR
// if tmp then
21966: LD_VAR 0 19
21970: IFFALSE 22018
// for i in tmp do
21972: LD_ADDR_VAR 0 8
21976: PUSH
21977: LD_VAR 0 19
21981: PUSH
21982: FOR_IN
21983: IFFALSE 22016
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
21985: LD_VAR 0 8
21989: PPUSH
21990: CALL_OW 250
21994: PPUSH
21995: LD_VAR 0 8
21999: PPUSH
22000: CALL_OW 251
22004: PPUSH
22005: LD_VAR 0 16
22009: PPUSH
22010: CALL_OW 441
22014: GO 21982
22016: POP
22017: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22018: LD_VAR 0 18
22022: PPUSH
22023: LD_INT 2
22025: PUSH
22026: LD_INT 30
22028: PUSH
22029: LD_INT 32
22031: PUSH
22032: EMPTY
22033: LIST
22034: LIST
22035: PUSH
22036: LD_INT 30
22038: PUSH
22039: LD_INT 33
22041: PUSH
22042: EMPTY
22043: LIST
22044: LIST
22045: PUSH
22046: EMPTY
22047: LIST
22048: LIST
22049: LIST
22050: PPUSH
22051: CALL_OW 72
22055: IFFALSE 22143
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22057: LD_ADDR_VAR 0 8
22061: PUSH
22062: LD_VAR 0 18
22066: PPUSH
22067: LD_INT 2
22069: PUSH
22070: LD_INT 30
22072: PUSH
22073: LD_INT 32
22075: PUSH
22076: EMPTY
22077: LIST
22078: LIST
22079: PUSH
22080: LD_INT 30
22082: PUSH
22083: LD_INT 33
22085: PUSH
22086: EMPTY
22087: LIST
22088: LIST
22089: PUSH
22090: EMPTY
22091: LIST
22092: LIST
22093: LIST
22094: PPUSH
22095: CALL_OW 72
22099: PUSH
22100: FOR_IN
22101: IFFALSE 22141
// begin if not GetBWeapon ( i ) then
22103: LD_VAR 0 8
22107: PPUSH
22108: CALL_OW 269
22112: NOT
22113: IFFALSE 22139
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22115: LD_VAR 0 8
22119: PPUSH
22120: LD_VAR 0 8
22124: PPUSH
22125: LD_VAR 0 2
22129: PPUSH
22130: CALL 23389 0 2
22134: PPUSH
22135: CALL_OW 431
// end ;
22139: GO 22100
22141: POP
22142: POP
// end ; for i = 1 to personel do
22143: LD_ADDR_VAR 0 8
22147: PUSH
22148: DOUBLE
22149: LD_INT 1
22151: DEC
22152: ST_TO_ADDR
22153: LD_VAR 0 6
22157: PUSH
22158: FOR_TO
22159: IFFALSE 23223
// begin if i > 4 then
22161: LD_VAR 0 8
22165: PUSH
22166: LD_INT 4
22168: GREATER
22169: IFFALSE 22173
// break ;
22171: GO 23223
// case i of 1 :
22173: LD_VAR 0 8
22177: PUSH
22178: LD_INT 1
22180: DOUBLE
22181: EQUAL
22182: IFTRUE 22186
22184: GO 22266
22186: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
22187: LD_ADDR_VAR 0 12
22191: PUSH
22192: LD_VAR 0 18
22196: PPUSH
22197: LD_INT 22
22199: PUSH
22200: LD_VAR 0 16
22204: PUSH
22205: EMPTY
22206: LIST
22207: LIST
22208: PUSH
22209: LD_INT 58
22211: PUSH
22212: EMPTY
22213: LIST
22214: PUSH
22215: LD_INT 2
22217: PUSH
22218: LD_INT 30
22220: PUSH
22221: LD_INT 32
22223: PUSH
22224: EMPTY
22225: LIST
22226: LIST
22227: PUSH
22228: LD_INT 30
22230: PUSH
22231: LD_INT 4
22233: PUSH
22234: EMPTY
22235: LIST
22236: LIST
22237: PUSH
22238: LD_INT 30
22240: PUSH
22241: LD_INT 5
22243: PUSH
22244: EMPTY
22245: LIST
22246: LIST
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: LIST
22252: LIST
22253: PUSH
22254: EMPTY
22255: LIST
22256: LIST
22257: LIST
22258: PPUSH
22259: CALL_OW 72
22263: ST_TO_ADDR
22264: GO 22488
22266: LD_INT 2
22268: DOUBLE
22269: EQUAL
22270: IFTRUE 22274
22272: GO 22336
22274: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22275: LD_ADDR_VAR 0 12
22279: PUSH
22280: LD_VAR 0 18
22284: PPUSH
22285: LD_INT 22
22287: PUSH
22288: LD_VAR 0 16
22292: PUSH
22293: EMPTY
22294: LIST
22295: LIST
22296: PUSH
22297: LD_INT 2
22299: PUSH
22300: LD_INT 30
22302: PUSH
22303: LD_INT 0
22305: PUSH
22306: EMPTY
22307: LIST
22308: LIST
22309: PUSH
22310: LD_INT 30
22312: PUSH
22313: LD_INT 1
22315: PUSH
22316: EMPTY
22317: LIST
22318: LIST
22319: PUSH
22320: EMPTY
22321: LIST
22322: LIST
22323: LIST
22324: PUSH
22325: EMPTY
22326: LIST
22327: LIST
22328: PPUSH
22329: CALL_OW 72
22333: ST_TO_ADDR
22334: GO 22488
22336: LD_INT 3
22338: DOUBLE
22339: EQUAL
22340: IFTRUE 22344
22342: GO 22406
22344: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22345: LD_ADDR_VAR 0 12
22349: PUSH
22350: LD_VAR 0 18
22354: PPUSH
22355: LD_INT 22
22357: PUSH
22358: LD_VAR 0 16
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: PUSH
22367: LD_INT 2
22369: PUSH
22370: LD_INT 30
22372: PUSH
22373: LD_INT 2
22375: PUSH
22376: EMPTY
22377: LIST
22378: LIST
22379: PUSH
22380: LD_INT 30
22382: PUSH
22383: LD_INT 3
22385: PUSH
22386: EMPTY
22387: LIST
22388: LIST
22389: PUSH
22390: EMPTY
22391: LIST
22392: LIST
22393: LIST
22394: PUSH
22395: EMPTY
22396: LIST
22397: LIST
22398: PPUSH
22399: CALL_OW 72
22403: ST_TO_ADDR
22404: GO 22488
22406: LD_INT 4
22408: DOUBLE
22409: EQUAL
22410: IFTRUE 22414
22412: GO 22487
22414: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22415: LD_ADDR_VAR 0 12
22419: PUSH
22420: LD_VAR 0 18
22424: PPUSH
22425: LD_INT 22
22427: PUSH
22428: LD_VAR 0 16
22432: PUSH
22433: EMPTY
22434: LIST
22435: LIST
22436: PUSH
22437: LD_INT 2
22439: PUSH
22440: LD_INT 30
22442: PUSH
22443: LD_INT 6
22445: PUSH
22446: EMPTY
22447: LIST
22448: LIST
22449: PUSH
22450: LD_INT 30
22452: PUSH
22453: LD_INT 7
22455: PUSH
22456: EMPTY
22457: LIST
22458: LIST
22459: PUSH
22460: LD_INT 30
22462: PUSH
22463: LD_INT 8
22465: PUSH
22466: EMPTY
22467: LIST
22468: LIST
22469: PUSH
22470: EMPTY
22471: LIST
22472: LIST
22473: LIST
22474: LIST
22475: PUSH
22476: EMPTY
22477: LIST
22478: LIST
22479: PPUSH
22480: CALL_OW 72
22484: ST_TO_ADDR
22485: GO 22488
22487: POP
// if i = 1 then
22488: LD_VAR 0 8
22492: PUSH
22493: LD_INT 1
22495: EQUAL
22496: IFFALSE 22607
// begin tmp := [ ] ;
22498: LD_ADDR_VAR 0 19
22502: PUSH
22503: EMPTY
22504: ST_TO_ADDR
// for j in f do
22505: LD_ADDR_VAR 0 9
22509: PUSH
22510: LD_VAR 0 12
22514: PUSH
22515: FOR_IN
22516: IFFALSE 22589
// if GetBType ( j ) = b_bunker then
22518: LD_VAR 0 9
22522: PPUSH
22523: CALL_OW 266
22527: PUSH
22528: LD_INT 32
22530: EQUAL
22531: IFFALSE 22558
// tmp := Insert ( tmp , 1 , j ) else
22533: LD_ADDR_VAR 0 19
22537: PUSH
22538: LD_VAR 0 19
22542: PPUSH
22543: LD_INT 1
22545: PPUSH
22546: LD_VAR 0 9
22550: PPUSH
22551: CALL_OW 2
22555: ST_TO_ADDR
22556: GO 22587
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22558: LD_ADDR_VAR 0 19
22562: PUSH
22563: LD_VAR 0 19
22567: PPUSH
22568: LD_VAR 0 19
22572: PUSH
22573: LD_INT 1
22575: PLUS
22576: PPUSH
22577: LD_VAR 0 9
22581: PPUSH
22582: CALL_OW 2
22586: ST_TO_ADDR
22587: GO 22515
22589: POP
22590: POP
// if tmp then
22591: LD_VAR 0 19
22595: IFFALSE 22607
// f := tmp ;
22597: LD_ADDR_VAR 0 12
22601: PUSH
22602: LD_VAR 0 19
22606: ST_TO_ADDR
// end ; x := personel [ i ] ;
22607: LD_ADDR_VAR 0 13
22611: PUSH
22612: LD_VAR 0 6
22616: PUSH
22617: LD_VAR 0 8
22621: ARRAY
22622: ST_TO_ADDR
// if x = - 1 then
22623: LD_VAR 0 13
22627: PUSH
22628: LD_INT 1
22630: NEG
22631: EQUAL
22632: IFFALSE 22841
// begin for j in f do
22634: LD_ADDR_VAR 0 9
22638: PUSH
22639: LD_VAR 0 12
22643: PUSH
22644: FOR_IN
22645: IFFALSE 22837
// repeat InitHc ;
22647: CALL_OW 19
// if GetBType ( j ) = b_barracks then
22651: LD_VAR 0 9
22655: PPUSH
22656: CALL_OW 266
22660: PUSH
22661: LD_INT 5
22663: EQUAL
22664: IFFALSE 22734
// begin if UnitsInside ( j ) < 3 then
22666: LD_VAR 0 9
22670: PPUSH
22671: CALL_OW 313
22675: PUSH
22676: LD_INT 3
22678: LESS
22679: IFFALSE 22715
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22681: LD_INT 0
22683: PPUSH
22684: LD_INT 5
22686: PUSH
22687: LD_INT 8
22689: PUSH
22690: LD_INT 9
22692: PUSH
22693: EMPTY
22694: LIST
22695: LIST
22696: LIST
22697: PUSH
22698: LD_VAR 0 17
22702: ARRAY
22703: PPUSH
22704: LD_VAR 0 4
22708: PPUSH
22709: CALL_OW 380
22713: GO 22732
// PrepareHuman ( false , i , skill ) ;
22715: LD_INT 0
22717: PPUSH
22718: LD_VAR 0 8
22722: PPUSH
22723: LD_VAR 0 4
22727: PPUSH
22728: CALL_OW 380
// end else
22732: GO 22751
// PrepareHuman ( false , i , skill ) ;
22734: LD_INT 0
22736: PPUSH
22737: LD_VAR 0 8
22741: PPUSH
22742: LD_VAR 0 4
22746: PPUSH
22747: CALL_OW 380
// un := CreateHuman ;
22751: LD_ADDR_VAR 0 14
22755: PUSH
22756: CALL_OW 44
22760: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22761: LD_ADDR_VAR 0 7
22765: PUSH
22766: LD_VAR 0 7
22770: PPUSH
22771: LD_INT 1
22773: PPUSH
22774: LD_VAR 0 14
22778: PPUSH
22779: CALL_OW 2
22783: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
22784: LD_VAR 0 14
22788: PPUSH
22789: LD_VAR 0 9
22793: PPUSH
22794: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
22798: LD_VAR 0 9
22802: PPUSH
22803: CALL_OW 313
22807: PUSH
22808: LD_INT 6
22810: EQUAL
22811: PUSH
22812: LD_VAR 0 9
22816: PPUSH
22817: CALL_OW 266
22821: PUSH
22822: LD_INT 32
22824: PUSH
22825: LD_INT 31
22827: PUSH
22828: EMPTY
22829: LIST
22830: LIST
22831: IN
22832: OR
22833: IFFALSE 22647
22835: GO 22644
22837: POP
22838: POP
// end else
22839: GO 23221
// for j = 1 to x do
22841: LD_ADDR_VAR 0 9
22845: PUSH
22846: DOUBLE
22847: LD_INT 1
22849: DEC
22850: ST_TO_ADDR
22851: LD_VAR 0 13
22855: PUSH
22856: FOR_TO
22857: IFFALSE 23219
// begin InitHc ;
22859: CALL_OW 19
// if not f then
22863: LD_VAR 0 12
22867: NOT
22868: IFFALSE 22957
// begin PrepareHuman ( false , i , skill ) ;
22870: LD_INT 0
22872: PPUSH
22873: LD_VAR 0 8
22877: PPUSH
22878: LD_VAR 0 4
22882: PPUSH
22883: CALL_OW 380
// un := CreateHuman ;
22887: LD_ADDR_VAR 0 14
22891: PUSH
22892: CALL_OW 44
22896: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22897: LD_ADDR_VAR 0 7
22901: PUSH
22902: LD_VAR 0 7
22906: PPUSH
22907: LD_INT 1
22909: PPUSH
22910: LD_VAR 0 14
22914: PPUSH
22915: CALL_OW 2
22919: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
22920: LD_VAR 0 14
22924: PPUSH
22925: LD_VAR 0 1
22929: PPUSH
22930: CALL_OW 250
22934: PPUSH
22935: LD_VAR 0 1
22939: PPUSH
22940: CALL_OW 251
22944: PPUSH
22945: LD_INT 10
22947: PPUSH
22948: LD_INT 0
22950: PPUSH
22951: CALL_OW 50
// continue ;
22955: GO 22856
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
22957: LD_VAR 0 12
22961: PUSH
22962: LD_INT 1
22964: ARRAY
22965: PPUSH
22966: CALL_OW 313
22970: PUSH
22971: LD_VAR 0 12
22975: PUSH
22976: LD_INT 1
22978: ARRAY
22979: PPUSH
22980: CALL_OW 266
22984: PUSH
22985: LD_INT 32
22987: PUSH
22988: LD_INT 31
22990: PUSH
22991: EMPTY
22992: LIST
22993: LIST
22994: IN
22995: AND
22996: PUSH
22997: LD_VAR 0 12
23001: PUSH
23002: LD_INT 1
23004: ARRAY
23005: PPUSH
23006: CALL_OW 313
23010: PUSH
23011: LD_INT 6
23013: EQUAL
23014: OR
23015: IFFALSE 23035
// f := Delete ( f , 1 ) ;
23017: LD_ADDR_VAR 0 12
23021: PUSH
23022: LD_VAR 0 12
23026: PPUSH
23027: LD_INT 1
23029: PPUSH
23030: CALL_OW 3
23034: ST_TO_ADDR
// if not f then
23035: LD_VAR 0 12
23039: NOT
23040: IFFALSE 23058
// begin x := x + 2 ;
23042: LD_ADDR_VAR 0 13
23046: PUSH
23047: LD_VAR 0 13
23051: PUSH
23052: LD_INT 2
23054: PLUS
23055: ST_TO_ADDR
// continue ;
23056: GO 22856
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23058: LD_VAR 0 12
23062: PUSH
23063: LD_INT 1
23065: ARRAY
23066: PPUSH
23067: CALL_OW 266
23071: PUSH
23072: LD_INT 5
23074: EQUAL
23075: IFFALSE 23149
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23077: LD_VAR 0 12
23081: PUSH
23082: LD_INT 1
23084: ARRAY
23085: PPUSH
23086: CALL_OW 313
23090: PUSH
23091: LD_INT 3
23093: LESS
23094: IFFALSE 23130
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23096: LD_INT 0
23098: PPUSH
23099: LD_INT 5
23101: PUSH
23102: LD_INT 8
23104: PUSH
23105: LD_INT 9
23107: PUSH
23108: EMPTY
23109: LIST
23110: LIST
23111: LIST
23112: PUSH
23113: LD_VAR 0 17
23117: ARRAY
23118: PPUSH
23119: LD_VAR 0 4
23123: PPUSH
23124: CALL_OW 380
23128: GO 23147
// PrepareHuman ( false , i , skill ) ;
23130: LD_INT 0
23132: PPUSH
23133: LD_VAR 0 8
23137: PPUSH
23138: LD_VAR 0 4
23142: PPUSH
23143: CALL_OW 380
// end else
23147: GO 23166
// PrepareHuman ( false , i , skill ) ;
23149: LD_INT 0
23151: PPUSH
23152: LD_VAR 0 8
23156: PPUSH
23157: LD_VAR 0 4
23161: PPUSH
23162: CALL_OW 380
// un := CreateHuman ;
23166: LD_ADDR_VAR 0 14
23170: PUSH
23171: CALL_OW 44
23175: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23176: LD_ADDR_VAR 0 7
23180: PUSH
23181: LD_VAR 0 7
23185: PPUSH
23186: LD_INT 1
23188: PPUSH
23189: LD_VAR 0 14
23193: PPUSH
23194: CALL_OW 2
23198: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
23199: LD_VAR 0 14
23203: PPUSH
23204: LD_VAR 0 12
23208: PUSH
23209: LD_INT 1
23211: ARRAY
23212: PPUSH
23213: CALL_OW 52
// end ;
23217: GO 22856
23219: POP
23220: POP
// end ;
23221: GO 22158
23223: POP
23224: POP
// result := result ^ buildings ;
23225: LD_ADDR_VAR 0 7
23229: PUSH
23230: LD_VAR 0 7
23234: PUSH
23235: LD_VAR 0 18
23239: ADD
23240: ST_TO_ADDR
// end else
23241: GO 23384
// begin for i = 1 to personel do
23243: LD_ADDR_VAR 0 8
23247: PUSH
23248: DOUBLE
23249: LD_INT 1
23251: DEC
23252: ST_TO_ADDR
23253: LD_VAR 0 6
23257: PUSH
23258: FOR_TO
23259: IFFALSE 23382
// begin if i > 4 then
23261: LD_VAR 0 8
23265: PUSH
23266: LD_INT 4
23268: GREATER
23269: IFFALSE 23273
// break ;
23271: GO 23382
// x := personel [ i ] ;
23273: LD_ADDR_VAR 0 13
23277: PUSH
23278: LD_VAR 0 6
23282: PUSH
23283: LD_VAR 0 8
23287: ARRAY
23288: ST_TO_ADDR
// if x = - 1 then
23289: LD_VAR 0 13
23293: PUSH
23294: LD_INT 1
23296: NEG
23297: EQUAL
23298: IFFALSE 23302
// continue ;
23300: GO 23258
// PrepareHuman ( false , i , skill ) ;
23302: LD_INT 0
23304: PPUSH
23305: LD_VAR 0 8
23309: PPUSH
23310: LD_VAR 0 4
23314: PPUSH
23315: CALL_OW 380
// un := CreateHuman ;
23319: LD_ADDR_VAR 0 14
23323: PUSH
23324: CALL_OW 44
23328: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23329: LD_VAR 0 14
23333: PPUSH
23334: LD_VAR 0 1
23338: PPUSH
23339: CALL_OW 250
23343: PPUSH
23344: LD_VAR 0 1
23348: PPUSH
23349: CALL_OW 251
23353: PPUSH
23354: LD_INT 10
23356: PPUSH
23357: LD_INT 0
23359: PPUSH
23360: CALL_OW 50
// result := result ^ un ;
23364: LD_ADDR_VAR 0 7
23368: PUSH
23369: LD_VAR 0 7
23373: PUSH
23374: LD_VAR 0 14
23378: ADD
23379: ST_TO_ADDR
// end ;
23380: GO 23258
23382: POP
23383: POP
// end ; end ;
23384: LD_VAR 0 7
23388: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23389: LD_INT 0
23391: PPUSH
23392: PPUSH
23393: PPUSH
23394: PPUSH
23395: PPUSH
23396: PPUSH
23397: PPUSH
23398: PPUSH
23399: PPUSH
23400: PPUSH
23401: PPUSH
23402: PPUSH
23403: PPUSH
23404: PPUSH
23405: PPUSH
23406: PPUSH
// result := false ;
23407: LD_ADDR_VAR 0 3
23411: PUSH
23412: LD_INT 0
23414: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23415: LD_VAR 0 1
23419: NOT
23420: PUSH
23421: LD_VAR 0 1
23425: PPUSH
23426: CALL_OW 266
23430: PUSH
23431: LD_INT 32
23433: PUSH
23434: LD_INT 33
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: IN
23441: NOT
23442: OR
23443: IFFALSE 23447
// exit ;
23445: GO 24583
// nat := GetNation ( tower ) ;
23447: LD_ADDR_VAR 0 12
23451: PUSH
23452: LD_VAR 0 1
23456: PPUSH
23457: CALL_OW 248
23461: ST_TO_ADDR
// side := GetSide ( tower ) ;
23462: LD_ADDR_VAR 0 16
23466: PUSH
23467: LD_VAR 0 1
23471: PPUSH
23472: CALL_OW 255
23476: ST_TO_ADDR
// x := GetX ( tower ) ;
23477: LD_ADDR_VAR 0 10
23481: PUSH
23482: LD_VAR 0 1
23486: PPUSH
23487: CALL_OW 250
23491: ST_TO_ADDR
// y := GetY ( tower ) ;
23492: LD_ADDR_VAR 0 11
23496: PUSH
23497: LD_VAR 0 1
23501: PPUSH
23502: CALL_OW 251
23506: ST_TO_ADDR
// if not x or not y then
23507: LD_VAR 0 10
23511: NOT
23512: PUSH
23513: LD_VAR 0 11
23517: NOT
23518: OR
23519: IFFALSE 23523
// exit ;
23521: GO 24583
// weapon := 0 ;
23523: LD_ADDR_VAR 0 18
23527: PUSH
23528: LD_INT 0
23530: ST_TO_ADDR
// fac_list := [ ] ;
23531: LD_ADDR_VAR 0 17
23535: PUSH
23536: EMPTY
23537: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
23538: LD_ADDR_VAR 0 6
23542: PUSH
23543: LD_VAR 0 1
23547: PPUSH
23548: CALL_OW 274
23552: PPUSH
23553: LD_VAR 0 2
23557: PPUSH
23558: CALL 21161 0 2
23562: PPUSH
23563: LD_INT 30
23565: PUSH
23566: LD_INT 3
23568: PUSH
23569: EMPTY
23570: LIST
23571: LIST
23572: PPUSH
23573: CALL_OW 72
23577: ST_TO_ADDR
// if not factories then
23578: LD_VAR 0 6
23582: NOT
23583: IFFALSE 23587
// exit ;
23585: GO 24583
// for i in factories do
23587: LD_ADDR_VAR 0 8
23591: PUSH
23592: LD_VAR 0 6
23596: PUSH
23597: FOR_IN
23598: IFFALSE 23623
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23600: LD_ADDR_VAR 0 17
23604: PUSH
23605: LD_VAR 0 17
23609: PUSH
23610: LD_VAR 0 8
23614: PPUSH
23615: CALL_OW 478
23619: UNION
23620: ST_TO_ADDR
23621: GO 23597
23623: POP
23624: POP
// if not fac_list then
23625: LD_VAR 0 17
23629: NOT
23630: IFFALSE 23634
// exit ;
23632: GO 24583
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
23634: LD_ADDR_VAR 0 5
23638: PUSH
23639: LD_INT 4
23641: PUSH
23642: LD_INT 5
23644: PUSH
23645: LD_INT 9
23647: PUSH
23648: LD_INT 10
23650: PUSH
23651: LD_INT 6
23653: PUSH
23654: LD_INT 7
23656: PUSH
23657: LD_INT 11
23659: PUSH
23660: EMPTY
23661: LIST
23662: LIST
23663: LIST
23664: LIST
23665: LIST
23666: LIST
23667: LIST
23668: PUSH
23669: LD_INT 27
23671: PUSH
23672: LD_INT 28
23674: PUSH
23675: LD_INT 26
23677: PUSH
23678: LD_INT 30
23680: PUSH
23681: EMPTY
23682: LIST
23683: LIST
23684: LIST
23685: LIST
23686: PUSH
23687: LD_INT 43
23689: PUSH
23690: LD_INT 44
23692: PUSH
23693: LD_INT 46
23695: PUSH
23696: LD_INT 45
23698: PUSH
23699: LD_INT 47
23701: PUSH
23702: LD_INT 49
23704: PUSH
23705: EMPTY
23706: LIST
23707: LIST
23708: LIST
23709: LIST
23710: LIST
23711: LIST
23712: PUSH
23713: EMPTY
23714: LIST
23715: LIST
23716: LIST
23717: PUSH
23718: LD_VAR 0 12
23722: ARRAY
23723: ST_TO_ADDR
// for i in list do
23724: LD_ADDR_VAR 0 8
23728: PUSH
23729: LD_VAR 0 5
23733: PUSH
23734: FOR_IN
23735: IFFALSE 23768
// if not i in fac_list then
23737: LD_VAR 0 8
23741: PUSH
23742: LD_VAR 0 17
23746: IN
23747: NOT
23748: IFFALSE 23766
// list := list diff i ;
23750: LD_ADDR_VAR 0 5
23754: PUSH
23755: LD_VAR 0 5
23759: PUSH
23760: LD_VAR 0 8
23764: DIFF
23765: ST_TO_ADDR
23766: GO 23734
23768: POP
23769: POP
// if not list then
23770: LD_VAR 0 5
23774: NOT
23775: IFFALSE 23779
// exit ;
23777: GO 24583
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
23779: LD_VAR 0 12
23783: PUSH
23784: LD_INT 3
23786: EQUAL
23787: PUSH
23788: LD_INT 49
23790: PUSH
23791: LD_VAR 0 5
23795: IN
23796: AND
23797: PUSH
23798: LD_INT 31
23800: PPUSH
23801: LD_VAR 0 16
23805: PPUSH
23806: CALL_OW 321
23810: PUSH
23811: LD_INT 2
23813: EQUAL
23814: AND
23815: IFFALSE 23875
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
23817: LD_INT 22
23819: PUSH
23820: LD_VAR 0 16
23824: PUSH
23825: EMPTY
23826: LIST
23827: LIST
23828: PUSH
23829: LD_INT 35
23831: PUSH
23832: LD_INT 49
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: PUSH
23839: LD_INT 91
23841: PUSH
23842: LD_VAR 0 1
23846: PUSH
23847: LD_INT 10
23849: PUSH
23850: EMPTY
23851: LIST
23852: LIST
23853: LIST
23854: PUSH
23855: EMPTY
23856: LIST
23857: LIST
23858: LIST
23859: PPUSH
23860: CALL_OW 69
23864: NOT
23865: IFFALSE 23875
// weapon := ru_time_lapser ;
23867: LD_ADDR_VAR 0 18
23871: PUSH
23872: LD_INT 49
23874: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
23875: LD_VAR 0 12
23879: PUSH
23880: LD_INT 1
23882: PUSH
23883: LD_INT 2
23885: PUSH
23886: EMPTY
23887: LIST
23888: LIST
23889: IN
23890: PUSH
23891: LD_INT 11
23893: PUSH
23894: LD_VAR 0 5
23898: IN
23899: PUSH
23900: LD_INT 30
23902: PUSH
23903: LD_VAR 0 5
23907: IN
23908: OR
23909: AND
23910: PUSH
23911: LD_INT 6
23913: PPUSH
23914: LD_VAR 0 16
23918: PPUSH
23919: CALL_OW 321
23923: PUSH
23924: LD_INT 2
23926: EQUAL
23927: AND
23928: IFFALSE 24093
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
23930: LD_INT 22
23932: PUSH
23933: LD_VAR 0 16
23937: PUSH
23938: EMPTY
23939: LIST
23940: LIST
23941: PUSH
23942: LD_INT 2
23944: PUSH
23945: LD_INT 35
23947: PUSH
23948: LD_INT 11
23950: PUSH
23951: EMPTY
23952: LIST
23953: LIST
23954: PUSH
23955: LD_INT 35
23957: PUSH
23958: LD_INT 30
23960: PUSH
23961: EMPTY
23962: LIST
23963: LIST
23964: PUSH
23965: EMPTY
23966: LIST
23967: LIST
23968: LIST
23969: PUSH
23970: LD_INT 91
23972: PUSH
23973: LD_VAR 0 1
23977: PUSH
23978: LD_INT 18
23980: PUSH
23981: EMPTY
23982: LIST
23983: LIST
23984: LIST
23985: PUSH
23986: EMPTY
23987: LIST
23988: LIST
23989: LIST
23990: PPUSH
23991: CALL_OW 69
23995: NOT
23996: PUSH
23997: LD_INT 22
23999: PUSH
24000: LD_VAR 0 16
24004: PUSH
24005: EMPTY
24006: LIST
24007: LIST
24008: PUSH
24009: LD_INT 2
24011: PUSH
24012: LD_INT 30
24014: PUSH
24015: LD_INT 32
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: PUSH
24022: LD_INT 30
24024: PUSH
24025: LD_INT 33
24027: PUSH
24028: EMPTY
24029: LIST
24030: LIST
24031: PUSH
24032: EMPTY
24033: LIST
24034: LIST
24035: LIST
24036: PUSH
24037: LD_INT 91
24039: PUSH
24040: LD_VAR 0 1
24044: PUSH
24045: LD_INT 12
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: LIST
24052: PUSH
24053: EMPTY
24054: LIST
24055: LIST
24056: LIST
24057: PUSH
24058: EMPTY
24059: LIST
24060: PPUSH
24061: CALL_OW 69
24065: PUSH
24066: LD_INT 2
24068: GREATER
24069: AND
24070: IFFALSE 24093
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24072: LD_ADDR_VAR 0 18
24076: PUSH
24077: LD_INT 11
24079: PUSH
24080: LD_INT 30
24082: PUSH
24083: EMPTY
24084: LIST
24085: LIST
24086: PUSH
24087: LD_VAR 0 12
24091: ARRAY
24092: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24093: LD_VAR 0 18
24097: NOT
24098: PUSH
24099: LD_INT 40
24101: PPUSH
24102: LD_VAR 0 16
24106: PPUSH
24107: CALL_OW 321
24111: PUSH
24112: LD_INT 2
24114: EQUAL
24115: AND
24116: PUSH
24117: LD_INT 7
24119: PUSH
24120: LD_VAR 0 5
24124: IN
24125: PUSH
24126: LD_INT 28
24128: PUSH
24129: LD_VAR 0 5
24133: IN
24134: OR
24135: PUSH
24136: LD_INT 45
24138: PUSH
24139: LD_VAR 0 5
24143: IN
24144: OR
24145: AND
24146: IFFALSE 24400
// begin hex := GetHexInfo ( x , y ) ;
24148: LD_ADDR_VAR 0 4
24152: PUSH
24153: LD_VAR 0 10
24157: PPUSH
24158: LD_VAR 0 11
24162: PPUSH
24163: CALL_OW 546
24167: ST_TO_ADDR
// if hex [ 1 ] then
24168: LD_VAR 0 4
24172: PUSH
24173: LD_INT 1
24175: ARRAY
24176: IFFALSE 24180
// exit ;
24178: GO 24583
// height := hex [ 2 ] ;
24180: LD_ADDR_VAR 0 15
24184: PUSH
24185: LD_VAR 0 4
24189: PUSH
24190: LD_INT 2
24192: ARRAY
24193: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
24194: LD_ADDR_VAR 0 14
24198: PUSH
24199: LD_INT 0
24201: PUSH
24202: LD_INT 2
24204: PUSH
24205: LD_INT 3
24207: PUSH
24208: LD_INT 5
24210: PUSH
24211: EMPTY
24212: LIST
24213: LIST
24214: LIST
24215: LIST
24216: ST_TO_ADDR
// for i in tmp do
24217: LD_ADDR_VAR 0 8
24221: PUSH
24222: LD_VAR 0 14
24226: PUSH
24227: FOR_IN
24228: IFFALSE 24398
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
24230: LD_ADDR_VAR 0 9
24234: PUSH
24235: LD_VAR 0 10
24239: PPUSH
24240: LD_VAR 0 8
24244: PPUSH
24245: LD_INT 5
24247: PPUSH
24248: CALL_OW 272
24252: PUSH
24253: LD_VAR 0 11
24257: PPUSH
24258: LD_VAR 0 8
24262: PPUSH
24263: LD_INT 5
24265: PPUSH
24266: CALL_OW 273
24270: PUSH
24271: EMPTY
24272: LIST
24273: LIST
24274: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24275: LD_VAR 0 9
24279: PUSH
24280: LD_INT 1
24282: ARRAY
24283: PPUSH
24284: LD_VAR 0 9
24288: PUSH
24289: LD_INT 2
24291: ARRAY
24292: PPUSH
24293: CALL_OW 488
24297: IFFALSE 24396
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24299: LD_ADDR_VAR 0 4
24303: PUSH
24304: LD_VAR 0 9
24308: PUSH
24309: LD_INT 1
24311: ARRAY
24312: PPUSH
24313: LD_VAR 0 9
24317: PUSH
24318: LD_INT 2
24320: ARRAY
24321: PPUSH
24322: CALL_OW 546
24326: ST_TO_ADDR
// if hex [ 1 ] then
24327: LD_VAR 0 4
24331: PUSH
24332: LD_INT 1
24334: ARRAY
24335: IFFALSE 24339
// continue ;
24337: GO 24227
// h := hex [ 2 ] ;
24339: LD_ADDR_VAR 0 13
24343: PUSH
24344: LD_VAR 0 4
24348: PUSH
24349: LD_INT 2
24351: ARRAY
24352: ST_TO_ADDR
// if h + 7 < height then
24353: LD_VAR 0 13
24357: PUSH
24358: LD_INT 7
24360: PLUS
24361: PUSH
24362: LD_VAR 0 15
24366: LESS
24367: IFFALSE 24396
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24369: LD_ADDR_VAR 0 18
24373: PUSH
24374: LD_INT 7
24376: PUSH
24377: LD_INT 28
24379: PUSH
24380: LD_INT 45
24382: PUSH
24383: EMPTY
24384: LIST
24385: LIST
24386: LIST
24387: PUSH
24388: LD_VAR 0 12
24392: ARRAY
24393: ST_TO_ADDR
// break ;
24394: GO 24398
// end ; end ; end ;
24396: GO 24227
24398: POP
24399: POP
// end ; if not weapon then
24400: LD_VAR 0 18
24404: NOT
24405: IFFALSE 24465
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24407: LD_ADDR_VAR 0 5
24411: PUSH
24412: LD_VAR 0 5
24416: PUSH
24417: LD_INT 11
24419: PUSH
24420: LD_INT 30
24422: PUSH
24423: LD_INT 49
24425: PUSH
24426: EMPTY
24427: LIST
24428: LIST
24429: LIST
24430: DIFF
24431: ST_TO_ADDR
// if not list then
24432: LD_VAR 0 5
24436: NOT
24437: IFFALSE 24441
// exit ;
24439: GO 24583
// weapon := list [ rand ( 1 , list ) ] ;
24441: LD_ADDR_VAR 0 18
24445: PUSH
24446: LD_VAR 0 5
24450: PUSH
24451: LD_INT 1
24453: PPUSH
24454: LD_VAR 0 5
24458: PPUSH
24459: CALL_OW 12
24463: ARRAY
24464: ST_TO_ADDR
// end ; if weapon then
24465: LD_VAR 0 18
24469: IFFALSE 24583
// begin tmp := CostOfWeapon ( weapon ) ;
24471: LD_ADDR_VAR 0 14
24475: PUSH
24476: LD_VAR 0 18
24480: PPUSH
24481: CALL_OW 451
24485: ST_TO_ADDR
// j := GetBase ( tower ) ;
24486: LD_ADDR_VAR 0 9
24490: PUSH
24491: LD_VAR 0 1
24495: PPUSH
24496: CALL_OW 274
24500: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24501: LD_VAR 0 9
24505: PPUSH
24506: LD_INT 1
24508: PPUSH
24509: CALL_OW 275
24513: PUSH
24514: LD_VAR 0 14
24518: PUSH
24519: LD_INT 1
24521: ARRAY
24522: GREATEREQUAL
24523: PUSH
24524: LD_VAR 0 9
24528: PPUSH
24529: LD_INT 2
24531: PPUSH
24532: CALL_OW 275
24536: PUSH
24537: LD_VAR 0 14
24541: PUSH
24542: LD_INT 2
24544: ARRAY
24545: GREATEREQUAL
24546: AND
24547: PUSH
24548: LD_VAR 0 9
24552: PPUSH
24553: LD_INT 3
24555: PPUSH
24556: CALL_OW 275
24560: PUSH
24561: LD_VAR 0 14
24565: PUSH
24566: LD_INT 3
24568: ARRAY
24569: GREATEREQUAL
24570: AND
24571: IFFALSE 24583
// result := weapon ;
24573: LD_ADDR_VAR 0 3
24577: PUSH
24578: LD_VAR 0 18
24582: ST_TO_ADDR
// end ; end ;
24583: LD_VAR 0 3
24587: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24588: LD_INT 0
24590: PPUSH
24591: PPUSH
// result := true ;
24592: LD_ADDR_VAR 0 3
24596: PUSH
24597: LD_INT 1
24599: ST_TO_ADDR
// if array1 = array2 then
24600: LD_VAR 0 1
24604: PUSH
24605: LD_VAR 0 2
24609: EQUAL
24610: IFFALSE 24670
// begin for i = 1 to array1 do
24612: LD_ADDR_VAR 0 4
24616: PUSH
24617: DOUBLE
24618: LD_INT 1
24620: DEC
24621: ST_TO_ADDR
24622: LD_VAR 0 1
24626: PUSH
24627: FOR_TO
24628: IFFALSE 24666
// if array1 [ i ] <> array2 [ i ] then
24630: LD_VAR 0 1
24634: PUSH
24635: LD_VAR 0 4
24639: ARRAY
24640: PUSH
24641: LD_VAR 0 2
24645: PUSH
24646: LD_VAR 0 4
24650: ARRAY
24651: NONEQUAL
24652: IFFALSE 24664
// begin result := false ;
24654: LD_ADDR_VAR 0 3
24658: PUSH
24659: LD_INT 0
24661: ST_TO_ADDR
// break ;
24662: GO 24666
// end ;
24664: GO 24627
24666: POP
24667: POP
// end else
24668: GO 24678
// result := false ;
24670: LD_ADDR_VAR 0 3
24674: PUSH
24675: LD_INT 0
24677: ST_TO_ADDR
// end ;
24678: LD_VAR 0 3
24682: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
24683: LD_INT 0
24685: PPUSH
24686: PPUSH
24687: PPUSH
// pom := GetBase ( fac ) ;
24688: LD_ADDR_VAR 0 5
24692: PUSH
24693: LD_VAR 0 1
24697: PPUSH
24698: CALL_OW 274
24702: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24703: LD_ADDR_VAR 0 4
24707: PUSH
24708: LD_VAR 0 2
24712: PUSH
24713: LD_INT 1
24715: ARRAY
24716: PPUSH
24717: LD_VAR 0 2
24721: PUSH
24722: LD_INT 2
24724: ARRAY
24725: PPUSH
24726: LD_VAR 0 2
24730: PUSH
24731: LD_INT 3
24733: ARRAY
24734: PPUSH
24735: LD_VAR 0 2
24739: PUSH
24740: LD_INT 4
24742: ARRAY
24743: PPUSH
24744: CALL_OW 449
24748: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
24749: LD_ADDR_VAR 0 3
24753: PUSH
24754: LD_VAR 0 5
24758: PPUSH
24759: LD_INT 1
24761: PPUSH
24762: CALL_OW 275
24766: PUSH
24767: LD_VAR 0 4
24771: PUSH
24772: LD_INT 1
24774: ARRAY
24775: GREATEREQUAL
24776: PUSH
24777: LD_VAR 0 5
24781: PPUSH
24782: LD_INT 2
24784: PPUSH
24785: CALL_OW 275
24789: PUSH
24790: LD_VAR 0 4
24794: PUSH
24795: LD_INT 2
24797: ARRAY
24798: GREATEREQUAL
24799: AND
24800: PUSH
24801: LD_VAR 0 5
24805: PPUSH
24806: LD_INT 3
24808: PPUSH
24809: CALL_OW 275
24813: PUSH
24814: LD_VAR 0 4
24818: PUSH
24819: LD_INT 3
24821: ARRAY
24822: GREATEREQUAL
24823: AND
24824: ST_TO_ADDR
// end ;
24825: LD_VAR 0 3
24829: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
24830: LD_INT 0
24832: PPUSH
24833: PPUSH
24834: PPUSH
24835: PPUSH
// pom := GetBase ( building ) ;
24836: LD_ADDR_VAR 0 3
24840: PUSH
24841: LD_VAR 0 1
24845: PPUSH
24846: CALL_OW 274
24850: ST_TO_ADDR
// if not pom then
24851: LD_VAR 0 3
24855: NOT
24856: IFFALSE 24860
// exit ;
24858: GO 25030
// btype := GetBType ( building ) ;
24860: LD_ADDR_VAR 0 5
24864: PUSH
24865: LD_VAR 0 1
24869: PPUSH
24870: CALL_OW 266
24874: ST_TO_ADDR
// if btype = b_armoury then
24875: LD_VAR 0 5
24879: PUSH
24880: LD_INT 4
24882: EQUAL
24883: IFFALSE 24893
// btype := b_barracks ;
24885: LD_ADDR_VAR 0 5
24889: PUSH
24890: LD_INT 5
24892: ST_TO_ADDR
// if btype = b_depot then
24893: LD_VAR 0 5
24897: PUSH
24898: LD_INT 0
24900: EQUAL
24901: IFFALSE 24911
// btype := b_warehouse ;
24903: LD_ADDR_VAR 0 5
24907: PUSH
24908: LD_INT 1
24910: ST_TO_ADDR
// if btype = b_workshop then
24911: LD_VAR 0 5
24915: PUSH
24916: LD_INT 2
24918: EQUAL
24919: IFFALSE 24929
// btype := b_factory ;
24921: LD_ADDR_VAR 0 5
24925: PUSH
24926: LD_INT 3
24928: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
24929: LD_ADDR_VAR 0 4
24933: PUSH
24934: LD_VAR 0 5
24938: PPUSH
24939: LD_VAR 0 1
24943: PPUSH
24944: CALL_OW 248
24948: PPUSH
24949: CALL_OW 450
24953: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
24954: LD_ADDR_VAR 0 2
24958: PUSH
24959: LD_VAR 0 3
24963: PPUSH
24964: LD_INT 1
24966: PPUSH
24967: CALL_OW 275
24971: PUSH
24972: LD_VAR 0 4
24976: PUSH
24977: LD_INT 1
24979: ARRAY
24980: GREATEREQUAL
24981: PUSH
24982: LD_VAR 0 3
24986: PPUSH
24987: LD_INT 2
24989: PPUSH
24990: CALL_OW 275
24994: PUSH
24995: LD_VAR 0 4
24999: PUSH
25000: LD_INT 2
25002: ARRAY
25003: GREATEREQUAL
25004: AND
25005: PUSH
25006: LD_VAR 0 3
25010: PPUSH
25011: LD_INT 3
25013: PPUSH
25014: CALL_OW 275
25018: PUSH
25019: LD_VAR 0 4
25023: PUSH
25024: LD_INT 3
25026: ARRAY
25027: GREATEREQUAL
25028: AND
25029: ST_TO_ADDR
// end ;
25030: LD_VAR 0 2
25034: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25035: LD_INT 0
25037: PPUSH
25038: PPUSH
25039: PPUSH
// pom := GetBase ( building ) ;
25040: LD_ADDR_VAR 0 4
25044: PUSH
25045: LD_VAR 0 1
25049: PPUSH
25050: CALL_OW 274
25054: ST_TO_ADDR
// if not pom then
25055: LD_VAR 0 4
25059: NOT
25060: IFFALSE 25064
// exit ;
25062: GO 25165
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25064: LD_ADDR_VAR 0 5
25068: PUSH
25069: LD_VAR 0 2
25073: PPUSH
25074: LD_VAR 0 1
25078: PPUSH
25079: CALL_OW 248
25083: PPUSH
25084: CALL_OW 450
25088: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25089: LD_ADDR_VAR 0 3
25093: PUSH
25094: LD_VAR 0 4
25098: PPUSH
25099: LD_INT 1
25101: PPUSH
25102: CALL_OW 275
25106: PUSH
25107: LD_VAR 0 5
25111: PUSH
25112: LD_INT 1
25114: ARRAY
25115: GREATEREQUAL
25116: PUSH
25117: LD_VAR 0 4
25121: PPUSH
25122: LD_INT 2
25124: PPUSH
25125: CALL_OW 275
25129: PUSH
25130: LD_VAR 0 5
25134: PUSH
25135: LD_INT 2
25137: ARRAY
25138: GREATEREQUAL
25139: AND
25140: PUSH
25141: LD_VAR 0 4
25145: PPUSH
25146: LD_INT 3
25148: PPUSH
25149: CALL_OW 275
25153: PUSH
25154: LD_VAR 0 5
25158: PUSH
25159: LD_INT 3
25161: ARRAY
25162: GREATEREQUAL
25163: AND
25164: ST_TO_ADDR
// end ;
25165: LD_VAR 0 3
25169: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
25170: LD_INT 0
25172: PPUSH
25173: PPUSH
25174: PPUSH
25175: PPUSH
25176: PPUSH
25177: PPUSH
25178: PPUSH
25179: PPUSH
25180: PPUSH
25181: PPUSH
// result := false ;
25182: LD_ADDR_VAR 0 6
25186: PUSH
25187: LD_INT 0
25189: ST_TO_ADDR
// if not base or not btype or not x or not y then
25190: LD_VAR 0 1
25194: NOT
25195: PUSH
25196: LD_VAR 0 2
25200: NOT
25201: OR
25202: PUSH
25203: LD_VAR 0 3
25207: NOT
25208: OR
25209: PUSH
25210: LD_VAR 0 4
25214: NOT
25215: OR
25216: IFFALSE 25220
// exit ;
25218: GO 25829
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
25220: LD_ADDR_VAR 0 12
25224: PUSH
25225: LD_VAR 0 2
25229: PPUSH
25230: LD_VAR 0 3
25234: PPUSH
25235: LD_VAR 0 4
25239: PPUSH
25240: LD_VAR 0 5
25244: PPUSH
25245: LD_VAR 0 1
25249: PUSH
25250: LD_INT 1
25252: ARRAY
25253: PPUSH
25254: CALL_OW 248
25258: PPUSH
25259: LD_INT 0
25261: PPUSH
25262: CALL 26666 0 6
25266: ST_TO_ADDR
// if not hexes then
25267: LD_VAR 0 12
25271: NOT
25272: IFFALSE 25276
// exit ;
25274: GO 25829
// for i = 1 to hexes do
25276: LD_ADDR_VAR 0 7
25280: PUSH
25281: DOUBLE
25282: LD_INT 1
25284: DEC
25285: ST_TO_ADDR
25286: LD_VAR 0 12
25290: PUSH
25291: FOR_TO
25292: IFFALSE 25827
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25294: LD_ADDR_VAR 0 11
25298: PUSH
25299: LD_VAR 0 12
25303: PUSH
25304: LD_VAR 0 7
25308: ARRAY
25309: PUSH
25310: LD_INT 1
25312: ARRAY
25313: PPUSH
25314: LD_VAR 0 12
25318: PUSH
25319: LD_VAR 0 7
25323: ARRAY
25324: PUSH
25325: LD_INT 2
25327: ARRAY
25328: PPUSH
25329: CALL_OW 428
25333: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25334: LD_VAR 0 12
25338: PUSH
25339: LD_VAR 0 7
25343: ARRAY
25344: PUSH
25345: LD_INT 1
25347: ARRAY
25348: PPUSH
25349: LD_VAR 0 12
25353: PUSH
25354: LD_VAR 0 7
25358: ARRAY
25359: PUSH
25360: LD_INT 2
25362: ARRAY
25363: PPUSH
25364: CALL_OW 351
25368: PUSH
25369: LD_VAR 0 12
25373: PUSH
25374: LD_VAR 0 7
25378: ARRAY
25379: PUSH
25380: LD_INT 1
25382: ARRAY
25383: PPUSH
25384: LD_VAR 0 12
25388: PUSH
25389: LD_VAR 0 7
25393: ARRAY
25394: PUSH
25395: LD_INT 2
25397: ARRAY
25398: PPUSH
25399: CALL_OW 488
25403: NOT
25404: OR
25405: PUSH
25406: LD_VAR 0 11
25410: PPUSH
25411: CALL_OW 247
25415: PUSH
25416: LD_INT 3
25418: EQUAL
25419: OR
25420: IFFALSE 25426
// exit ;
25422: POP
25423: POP
25424: GO 25829
// if not tmp or not tmp in base then
25426: LD_VAR 0 11
25430: NOT
25431: PUSH
25432: LD_VAR 0 11
25436: PUSH
25437: LD_VAR 0 1
25441: IN
25442: NOT
25443: OR
25444: IFFALSE 25448
// continue ;
25446: GO 25291
// result := true ;
25448: LD_ADDR_VAR 0 6
25452: PUSH
25453: LD_INT 1
25455: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25456: LD_ADDR_VAR 0 15
25460: PUSH
25461: LD_VAR 0 1
25465: PPUSH
25466: LD_INT 22
25468: PUSH
25469: LD_VAR 0 11
25473: PPUSH
25474: CALL_OW 255
25478: PUSH
25479: EMPTY
25480: LIST
25481: LIST
25482: PUSH
25483: LD_INT 2
25485: PUSH
25486: LD_INT 30
25488: PUSH
25489: LD_INT 0
25491: PUSH
25492: EMPTY
25493: LIST
25494: LIST
25495: PUSH
25496: LD_INT 30
25498: PUSH
25499: LD_INT 1
25501: PUSH
25502: EMPTY
25503: LIST
25504: LIST
25505: PUSH
25506: EMPTY
25507: LIST
25508: LIST
25509: LIST
25510: PUSH
25511: EMPTY
25512: LIST
25513: LIST
25514: PPUSH
25515: CALL_OW 72
25519: ST_TO_ADDR
// if dep then
25520: LD_VAR 0 15
25524: IFFALSE 25660
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
25526: LD_ADDR_VAR 0 14
25530: PUSH
25531: LD_VAR 0 15
25535: PUSH
25536: LD_INT 1
25538: ARRAY
25539: PPUSH
25540: CALL_OW 250
25544: PPUSH
25545: LD_VAR 0 15
25549: PUSH
25550: LD_INT 1
25552: ARRAY
25553: PPUSH
25554: CALL_OW 254
25558: PPUSH
25559: LD_INT 5
25561: PPUSH
25562: CALL_OW 272
25566: PUSH
25567: LD_VAR 0 15
25571: PUSH
25572: LD_INT 1
25574: ARRAY
25575: PPUSH
25576: CALL_OW 251
25580: PPUSH
25581: LD_VAR 0 15
25585: PUSH
25586: LD_INT 1
25588: ARRAY
25589: PPUSH
25590: CALL_OW 254
25594: PPUSH
25595: LD_INT 5
25597: PPUSH
25598: CALL_OW 273
25602: PUSH
25603: EMPTY
25604: LIST
25605: LIST
25606: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
25607: LD_VAR 0 14
25611: PUSH
25612: LD_INT 1
25614: ARRAY
25615: PPUSH
25616: LD_VAR 0 14
25620: PUSH
25621: LD_INT 2
25623: ARRAY
25624: PPUSH
25625: CALL_OW 488
25629: IFFALSE 25660
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
25631: LD_VAR 0 11
25635: PPUSH
25636: LD_VAR 0 14
25640: PUSH
25641: LD_INT 1
25643: ARRAY
25644: PPUSH
25645: LD_VAR 0 14
25649: PUSH
25650: LD_INT 2
25652: ARRAY
25653: PPUSH
25654: CALL_OW 111
// continue ;
25658: GO 25291
// end ; end ; r := GetDir ( tmp ) ;
25660: LD_ADDR_VAR 0 13
25664: PUSH
25665: LD_VAR 0 11
25669: PPUSH
25670: CALL_OW 254
25674: ST_TO_ADDR
// if r = 5 then
25675: LD_VAR 0 13
25679: PUSH
25680: LD_INT 5
25682: EQUAL
25683: IFFALSE 25693
// r := 0 ;
25685: LD_ADDR_VAR 0 13
25689: PUSH
25690: LD_INT 0
25692: ST_TO_ADDR
// for j = r to 5 do
25693: LD_ADDR_VAR 0 8
25697: PUSH
25698: DOUBLE
25699: LD_VAR 0 13
25703: DEC
25704: ST_TO_ADDR
25705: LD_INT 5
25707: PUSH
25708: FOR_TO
25709: IFFALSE 25823
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
25711: LD_ADDR_VAR 0 9
25715: PUSH
25716: LD_VAR 0 11
25720: PPUSH
25721: CALL_OW 250
25725: PPUSH
25726: LD_VAR 0 8
25730: PPUSH
25731: LD_INT 2
25733: PPUSH
25734: CALL_OW 272
25738: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
25739: LD_ADDR_VAR 0 10
25743: PUSH
25744: LD_VAR 0 11
25748: PPUSH
25749: CALL_OW 251
25753: PPUSH
25754: LD_VAR 0 8
25758: PPUSH
25759: LD_INT 2
25761: PPUSH
25762: CALL_OW 273
25766: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
25767: LD_VAR 0 9
25771: PPUSH
25772: LD_VAR 0 10
25776: PPUSH
25777: CALL_OW 488
25781: PUSH
25782: LD_VAR 0 9
25786: PPUSH
25787: LD_VAR 0 10
25791: PPUSH
25792: CALL_OW 428
25796: NOT
25797: AND
25798: IFFALSE 25821
// begin ComMoveXY ( tmp , _x , _y ) ;
25800: LD_VAR 0 11
25804: PPUSH
25805: LD_VAR 0 9
25809: PPUSH
25810: LD_VAR 0 10
25814: PPUSH
25815: CALL_OW 111
// break ;
25819: GO 25823
// end ; end ;
25821: GO 25708
25823: POP
25824: POP
// end ;
25825: GO 25291
25827: POP
25828: POP
// end ;
25829: LD_VAR 0 6
25833: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
25834: LD_INT 0
25836: PPUSH
25837: PPUSH
25838: PPUSH
25839: PPUSH
25840: PPUSH
25841: PPUSH
25842: PPUSH
25843: PPUSH
25844: PPUSH
25845: PPUSH
// result := false ;
25846: LD_ADDR_VAR 0 6
25850: PUSH
25851: LD_INT 0
25853: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
25854: LD_VAR 0 1
25858: NOT
25859: PUSH
25860: LD_VAR 0 1
25864: PPUSH
25865: CALL_OW 266
25869: PUSH
25870: LD_INT 0
25872: PUSH
25873: LD_INT 1
25875: PUSH
25876: EMPTY
25877: LIST
25878: LIST
25879: IN
25880: NOT
25881: OR
25882: PUSH
25883: LD_VAR 0 2
25887: NOT
25888: OR
25889: PUSH
25890: LD_VAR 0 5
25894: PUSH
25895: LD_INT 0
25897: PUSH
25898: LD_INT 1
25900: PUSH
25901: LD_INT 2
25903: PUSH
25904: LD_INT 3
25906: PUSH
25907: LD_INT 4
25909: PUSH
25910: LD_INT 5
25912: PUSH
25913: EMPTY
25914: LIST
25915: LIST
25916: LIST
25917: LIST
25918: LIST
25919: LIST
25920: IN
25921: NOT
25922: OR
25923: PUSH
25924: LD_VAR 0 3
25928: PPUSH
25929: LD_VAR 0 4
25933: PPUSH
25934: CALL_OW 488
25938: NOT
25939: OR
25940: IFFALSE 25944
// exit ;
25942: GO 26661
// pom := GetBase ( depot ) ;
25944: LD_ADDR_VAR 0 10
25948: PUSH
25949: LD_VAR 0 1
25953: PPUSH
25954: CALL_OW 274
25958: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
25959: LD_ADDR_VAR 0 11
25963: PUSH
25964: LD_VAR 0 2
25968: PPUSH
25969: LD_VAR 0 1
25973: PPUSH
25974: CALL_OW 248
25978: PPUSH
25979: CALL_OW 450
25983: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
25984: LD_VAR 0 10
25988: PPUSH
25989: LD_INT 1
25991: PPUSH
25992: CALL_OW 275
25996: PUSH
25997: LD_VAR 0 11
26001: PUSH
26002: LD_INT 1
26004: ARRAY
26005: GREATEREQUAL
26006: PUSH
26007: LD_VAR 0 10
26011: PPUSH
26012: LD_INT 2
26014: PPUSH
26015: CALL_OW 275
26019: PUSH
26020: LD_VAR 0 11
26024: PUSH
26025: LD_INT 2
26027: ARRAY
26028: GREATEREQUAL
26029: AND
26030: PUSH
26031: LD_VAR 0 10
26035: PPUSH
26036: LD_INT 3
26038: PPUSH
26039: CALL_OW 275
26043: PUSH
26044: LD_VAR 0 11
26048: PUSH
26049: LD_INT 3
26051: ARRAY
26052: GREATEREQUAL
26053: AND
26054: NOT
26055: IFFALSE 26059
// exit ;
26057: GO 26661
// if GetBType ( depot ) = b_depot then
26059: LD_VAR 0 1
26063: PPUSH
26064: CALL_OW 266
26068: PUSH
26069: LD_INT 0
26071: EQUAL
26072: IFFALSE 26084
// dist := 28 else
26074: LD_ADDR_VAR 0 14
26078: PUSH
26079: LD_INT 28
26081: ST_TO_ADDR
26082: GO 26092
// dist := 36 ;
26084: LD_ADDR_VAR 0 14
26088: PUSH
26089: LD_INT 36
26091: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26092: LD_VAR 0 1
26096: PPUSH
26097: LD_VAR 0 3
26101: PPUSH
26102: LD_VAR 0 4
26106: PPUSH
26107: CALL_OW 297
26111: PUSH
26112: LD_VAR 0 14
26116: GREATER
26117: IFFALSE 26121
// exit ;
26119: GO 26661
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
26121: LD_ADDR_VAR 0 12
26125: PUSH
26126: LD_VAR 0 2
26130: PPUSH
26131: LD_VAR 0 3
26135: PPUSH
26136: LD_VAR 0 4
26140: PPUSH
26141: LD_VAR 0 5
26145: PPUSH
26146: LD_VAR 0 1
26150: PPUSH
26151: CALL_OW 248
26155: PPUSH
26156: LD_INT 0
26158: PPUSH
26159: CALL 26666 0 6
26163: ST_TO_ADDR
// if not hexes then
26164: LD_VAR 0 12
26168: NOT
26169: IFFALSE 26173
// exit ;
26171: GO 26661
// hex := GetHexInfo ( x , y ) ;
26173: LD_ADDR_VAR 0 15
26177: PUSH
26178: LD_VAR 0 3
26182: PPUSH
26183: LD_VAR 0 4
26187: PPUSH
26188: CALL_OW 546
26192: ST_TO_ADDR
// if hex [ 1 ] then
26193: LD_VAR 0 15
26197: PUSH
26198: LD_INT 1
26200: ARRAY
26201: IFFALSE 26205
// exit ;
26203: GO 26661
// height := hex [ 2 ] ;
26205: LD_ADDR_VAR 0 13
26209: PUSH
26210: LD_VAR 0 15
26214: PUSH
26215: LD_INT 2
26217: ARRAY
26218: ST_TO_ADDR
// for i = 1 to hexes do
26219: LD_ADDR_VAR 0 7
26223: PUSH
26224: DOUBLE
26225: LD_INT 1
26227: DEC
26228: ST_TO_ADDR
26229: LD_VAR 0 12
26233: PUSH
26234: FOR_TO
26235: IFFALSE 26565
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
26237: LD_VAR 0 12
26241: PUSH
26242: LD_VAR 0 7
26246: ARRAY
26247: PUSH
26248: LD_INT 1
26250: ARRAY
26251: PPUSH
26252: LD_VAR 0 12
26256: PUSH
26257: LD_VAR 0 7
26261: ARRAY
26262: PUSH
26263: LD_INT 2
26265: ARRAY
26266: PPUSH
26267: CALL_OW 488
26271: NOT
26272: PUSH
26273: LD_VAR 0 12
26277: PUSH
26278: LD_VAR 0 7
26282: ARRAY
26283: PUSH
26284: LD_INT 1
26286: ARRAY
26287: PPUSH
26288: LD_VAR 0 12
26292: PUSH
26293: LD_VAR 0 7
26297: ARRAY
26298: PUSH
26299: LD_INT 2
26301: ARRAY
26302: PPUSH
26303: CALL_OW 428
26307: PUSH
26308: LD_INT 0
26310: GREATER
26311: OR
26312: PUSH
26313: LD_VAR 0 12
26317: PUSH
26318: LD_VAR 0 7
26322: ARRAY
26323: PUSH
26324: LD_INT 1
26326: ARRAY
26327: PPUSH
26328: LD_VAR 0 12
26332: PUSH
26333: LD_VAR 0 7
26337: ARRAY
26338: PUSH
26339: LD_INT 2
26341: ARRAY
26342: PPUSH
26343: CALL_OW 351
26347: OR
26348: IFFALSE 26354
// exit ;
26350: POP
26351: POP
26352: GO 26661
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26354: LD_ADDR_VAR 0 8
26358: PUSH
26359: LD_VAR 0 12
26363: PUSH
26364: LD_VAR 0 7
26368: ARRAY
26369: PUSH
26370: LD_INT 1
26372: ARRAY
26373: PPUSH
26374: LD_VAR 0 12
26378: PUSH
26379: LD_VAR 0 7
26383: ARRAY
26384: PUSH
26385: LD_INT 2
26387: ARRAY
26388: PPUSH
26389: CALL_OW 546
26393: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
26394: LD_VAR 0 8
26398: PUSH
26399: LD_INT 1
26401: ARRAY
26402: PUSH
26403: LD_VAR 0 8
26407: PUSH
26408: LD_INT 2
26410: ARRAY
26411: PUSH
26412: LD_VAR 0 13
26416: PUSH
26417: LD_INT 2
26419: PLUS
26420: GREATER
26421: OR
26422: PUSH
26423: LD_VAR 0 8
26427: PUSH
26428: LD_INT 2
26430: ARRAY
26431: PUSH
26432: LD_VAR 0 13
26436: PUSH
26437: LD_INT 2
26439: MINUS
26440: LESS
26441: OR
26442: PUSH
26443: LD_VAR 0 8
26447: PUSH
26448: LD_INT 3
26450: ARRAY
26451: PUSH
26452: LD_INT 0
26454: PUSH
26455: LD_INT 8
26457: PUSH
26458: LD_INT 9
26460: PUSH
26461: LD_INT 10
26463: PUSH
26464: LD_INT 11
26466: PUSH
26467: LD_INT 12
26469: PUSH
26470: LD_INT 13
26472: PUSH
26473: LD_INT 16
26475: PUSH
26476: LD_INT 17
26478: PUSH
26479: LD_INT 18
26481: PUSH
26482: LD_INT 19
26484: PUSH
26485: LD_INT 20
26487: PUSH
26488: LD_INT 21
26490: PUSH
26491: EMPTY
26492: LIST
26493: LIST
26494: LIST
26495: LIST
26496: LIST
26497: LIST
26498: LIST
26499: LIST
26500: LIST
26501: LIST
26502: LIST
26503: LIST
26504: LIST
26505: IN
26506: NOT
26507: OR
26508: PUSH
26509: LD_VAR 0 8
26513: PUSH
26514: LD_INT 5
26516: ARRAY
26517: NOT
26518: OR
26519: PUSH
26520: LD_VAR 0 8
26524: PUSH
26525: LD_INT 6
26527: ARRAY
26528: PUSH
26529: LD_INT 1
26531: PUSH
26532: LD_INT 2
26534: PUSH
26535: LD_INT 7
26537: PUSH
26538: LD_INT 9
26540: PUSH
26541: LD_INT 10
26543: PUSH
26544: LD_INT 11
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: LIST
26551: LIST
26552: LIST
26553: LIST
26554: IN
26555: NOT
26556: OR
26557: IFFALSE 26563
// exit ;
26559: POP
26560: POP
26561: GO 26661
// end ;
26563: GO 26234
26565: POP
26566: POP
// side := GetSide ( depot ) ;
26567: LD_ADDR_VAR 0 9
26571: PUSH
26572: LD_VAR 0 1
26576: PPUSH
26577: CALL_OW 255
26581: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
26582: LD_VAR 0 9
26586: PPUSH
26587: LD_VAR 0 3
26591: PPUSH
26592: LD_VAR 0 4
26596: PPUSH
26597: LD_INT 20
26599: PPUSH
26600: CALL 19315 0 4
26604: PUSH
26605: LD_INT 4
26607: ARRAY
26608: IFFALSE 26612
// exit ;
26610: GO 26661
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
26612: LD_VAR 0 2
26616: PUSH
26617: LD_INT 29
26619: PUSH
26620: LD_INT 30
26622: PUSH
26623: EMPTY
26624: LIST
26625: LIST
26626: IN
26627: PUSH
26628: LD_VAR 0 3
26632: PPUSH
26633: LD_VAR 0 4
26637: PPUSH
26638: LD_VAR 0 9
26642: PPUSH
26643: CALL_OW 440
26647: NOT
26648: AND
26649: IFFALSE 26653
// exit ;
26651: GO 26661
// result := true ;
26653: LD_ADDR_VAR 0 6
26657: PUSH
26658: LD_INT 1
26660: ST_TO_ADDR
// end ;
26661: LD_VAR 0 6
26665: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
26666: LD_INT 0
26668: PPUSH
26669: PPUSH
26670: PPUSH
26671: PPUSH
26672: PPUSH
26673: PPUSH
26674: PPUSH
26675: PPUSH
26676: PPUSH
26677: PPUSH
26678: PPUSH
26679: PPUSH
26680: PPUSH
26681: PPUSH
26682: PPUSH
26683: PPUSH
26684: PPUSH
26685: PPUSH
26686: PPUSH
26687: PPUSH
26688: PPUSH
26689: PPUSH
26690: PPUSH
26691: PPUSH
26692: PPUSH
26693: PPUSH
26694: PPUSH
26695: PPUSH
26696: PPUSH
26697: PPUSH
26698: PPUSH
26699: PPUSH
26700: PPUSH
26701: PPUSH
26702: PPUSH
26703: PPUSH
26704: PPUSH
26705: PPUSH
26706: PPUSH
26707: PPUSH
26708: PPUSH
26709: PPUSH
26710: PPUSH
26711: PPUSH
26712: PPUSH
26713: PPUSH
26714: PPUSH
26715: PPUSH
26716: PPUSH
26717: PPUSH
26718: PPUSH
26719: PPUSH
26720: PPUSH
26721: PPUSH
26722: PPUSH
26723: PPUSH
26724: PPUSH
26725: PPUSH
// result = [ ] ;
26726: LD_ADDR_VAR 0 7
26730: PUSH
26731: EMPTY
26732: ST_TO_ADDR
// temp_list = [ ] ;
26733: LD_ADDR_VAR 0 9
26737: PUSH
26738: EMPTY
26739: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
26740: LD_VAR 0 4
26744: PUSH
26745: LD_INT 0
26747: PUSH
26748: LD_INT 1
26750: PUSH
26751: LD_INT 2
26753: PUSH
26754: LD_INT 3
26756: PUSH
26757: LD_INT 4
26759: PUSH
26760: LD_INT 5
26762: PUSH
26763: EMPTY
26764: LIST
26765: LIST
26766: LIST
26767: LIST
26768: LIST
26769: LIST
26770: IN
26771: NOT
26772: PUSH
26773: LD_VAR 0 1
26777: PUSH
26778: LD_INT 0
26780: PUSH
26781: LD_INT 1
26783: PUSH
26784: EMPTY
26785: LIST
26786: LIST
26787: IN
26788: PUSH
26789: LD_VAR 0 5
26793: PUSH
26794: LD_INT 1
26796: PUSH
26797: LD_INT 2
26799: PUSH
26800: LD_INT 3
26802: PUSH
26803: EMPTY
26804: LIST
26805: LIST
26806: LIST
26807: IN
26808: NOT
26809: AND
26810: OR
26811: IFFALSE 26815
// exit ;
26813: GO 45206
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
26815: LD_VAR 0 1
26819: PUSH
26820: LD_INT 6
26822: PUSH
26823: LD_INT 7
26825: PUSH
26826: LD_INT 8
26828: PUSH
26829: LD_INT 13
26831: PUSH
26832: LD_INT 12
26834: PUSH
26835: LD_INT 15
26837: PUSH
26838: LD_INT 11
26840: PUSH
26841: LD_INT 14
26843: PUSH
26844: LD_INT 10
26846: PUSH
26847: EMPTY
26848: LIST
26849: LIST
26850: LIST
26851: LIST
26852: LIST
26853: LIST
26854: LIST
26855: LIST
26856: LIST
26857: IN
26858: IFFALSE 26868
// btype = b_lab ;
26860: LD_ADDR_VAR 0 1
26864: PUSH
26865: LD_INT 6
26867: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
26868: LD_VAR 0 6
26872: PUSH
26873: LD_INT 0
26875: PUSH
26876: LD_INT 1
26878: PUSH
26879: LD_INT 2
26881: PUSH
26882: EMPTY
26883: LIST
26884: LIST
26885: LIST
26886: IN
26887: NOT
26888: PUSH
26889: LD_VAR 0 1
26893: PUSH
26894: LD_INT 0
26896: PUSH
26897: LD_INT 1
26899: PUSH
26900: LD_INT 2
26902: PUSH
26903: LD_INT 3
26905: PUSH
26906: LD_INT 6
26908: PUSH
26909: LD_INT 36
26911: PUSH
26912: LD_INT 4
26914: PUSH
26915: LD_INT 5
26917: PUSH
26918: LD_INT 31
26920: PUSH
26921: LD_INT 32
26923: PUSH
26924: LD_INT 33
26926: PUSH
26927: EMPTY
26928: LIST
26929: LIST
26930: LIST
26931: LIST
26932: LIST
26933: LIST
26934: LIST
26935: LIST
26936: LIST
26937: LIST
26938: LIST
26939: IN
26940: NOT
26941: PUSH
26942: LD_VAR 0 6
26946: PUSH
26947: LD_INT 1
26949: EQUAL
26950: AND
26951: OR
26952: PUSH
26953: LD_VAR 0 1
26957: PUSH
26958: LD_INT 2
26960: PUSH
26961: LD_INT 3
26963: PUSH
26964: EMPTY
26965: LIST
26966: LIST
26967: IN
26968: NOT
26969: PUSH
26970: LD_VAR 0 6
26974: PUSH
26975: LD_INT 2
26977: EQUAL
26978: AND
26979: OR
26980: IFFALSE 26990
// mode = 0 ;
26982: LD_ADDR_VAR 0 6
26986: PUSH
26987: LD_INT 0
26989: ST_TO_ADDR
// case mode of 0 :
26990: LD_VAR 0 6
26994: PUSH
26995: LD_INT 0
26997: DOUBLE
26998: EQUAL
26999: IFTRUE 27003
27001: GO 38456
27003: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27004: LD_ADDR_VAR 0 11
27008: PUSH
27009: LD_INT 0
27011: PUSH
27012: LD_INT 0
27014: PUSH
27015: EMPTY
27016: LIST
27017: LIST
27018: PUSH
27019: LD_INT 0
27021: PUSH
27022: LD_INT 1
27024: NEG
27025: PUSH
27026: EMPTY
27027: LIST
27028: LIST
27029: PUSH
27030: LD_INT 1
27032: PUSH
27033: LD_INT 0
27035: PUSH
27036: EMPTY
27037: LIST
27038: LIST
27039: PUSH
27040: LD_INT 1
27042: PUSH
27043: LD_INT 1
27045: PUSH
27046: EMPTY
27047: LIST
27048: LIST
27049: PUSH
27050: LD_INT 0
27052: PUSH
27053: LD_INT 1
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: PUSH
27060: LD_INT 1
27062: NEG
27063: PUSH
27064: LD_INT 0
27066: PUSH
27067: EMPTY
27068: LIST
27069: LIST
27070: PUSH
27071: LD_INT 1
27073: NEG
27074: PUSH
27075: LD_INT 1
27077: NEG
27078: PUSH
27079: EMPTY
27080: LIST
27081: LIST
27082: PUSH
27083: LD_INT 1
27085: NEG
27086: PUSH
27087: LD_INT 2
27089: NEG
27090: PUSH
27091: EMPTY
27092: LIST
27093: LIST
27094: PUSH
27095: LD_INT 0
27097: PUSH
27098: LD_INT 2
27100: NEG
27101: PUSH
27102: EMPTY
27103: LIST
27104: LIST
27105: PUSH
27106: LD_INT 1
27108: PUSH
27109: LD_INT 1
27111: NEG
27112: PUSH
27113: EMPTY
27114: LIST
27115: LIST
27116: PUSH
27117: LD_INT 1
27119: PUSH
27120: LD_INT 2
27122: PUSH
27123: EMPTY
27124: LIST
27125: LIST
27126: PUSH
27127: LD_INT 0
27129: PUSH
27130: LD_INT 2
27132: PUSH
27133: EMPTY
27134: LIST
27135: LIST
27136: PUSH
27137: LD_INT 1
27139: NEG
27140: PUSH
27141: LD_INT 1
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PUSH
27148: LD_INT 1
27150: PUSH
27151: LD_INT 3
27153: PUSH
27154: EMPTY
27155: LIST
27156: LIST
27157: PUSH
27158: LD_INT 0
27160: PUSH
27161: LD_INT 3
27163: PUSH
27164: EMPTY
27165: LIST
27166: LIST
27167: PUSH
27168: LD_INT 1
27170: NEG
27171: PUSH
27172: LD_INT 2
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: PUSH
27179: EMPTY
27180: LIST
27181: LIST
27182: LIST
27183: LIST
27184: LIST
27185: LIST
27186: LIST
27187: LIST
27188: LIST
27189: LIST
27190: LIST
27191: LIST
27192: LIST
27193: LIST
27194: LIST
27195: LIST
27196: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
27197: LD_ADDR_VAR 0 12
27201: PUSH
27202: LD_INT 0
27204: PUSH
27205: LD_INT 0
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: PUSH
27212: LD_INT 0
27214: PUSH
27215: LD_INT 1
27217: NEG
27218: PUSH
27219: EMPTY
27220: LIST
27221: LIST
27222: PUSH
27223: LD_INT 1
27225: PUSH
27226: LD_INT 0
27228: PUSH
27229: EMPTY
27230: LIST
27231: LIST
27232: PUSH
27233: LD_INT 1
27235: PUSH
27236: LD_INT 1
27238: PUSH
27239: EMPTY
27240: LIST
27241: LIST
27242: PUSH
27243: LD_INT 0
27245: PUSH
27246: LD_INT 1
27248: PUSH
27249: EMPTY
27250: LIST
27251: LIST
27252: PUSH
27253: LD_INT 1
27255: NEG
27256: PUSH
27257: LD_INT 0
27259: PUSH
27260: EMPTY
27261: LIST
27262: LIST
27263: PUSH
27264: LD_INT 1
27266: NEG
27267: PUSH
27268: LD_INT 1
27270: NEG
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: PUSH
27276: LD_INT 1
27278: PUSH
27279: LD_INT 1
27281: NEG
27282: PUSH
27283: EMPTY
27284: LIST
27285: LIST
27286: PUSH
27287: LD_INT 2
27289: PUSH
27290: LD_INT 0
27292: PUSH
27293: EMPTY
27294: LIST
27295: LIST
27296: PUSH
27297: LD_INT 2
27299: PUSH
27300: LD_INT 1
27302: PUSH
27303: EMPTY
27304: LIST
27305: LIST
27306: PUSH
27307: LD_INT 1
27309: NEG
27310: PUSH
27311: LD_INT 1
27313: PUSH
27314: EMPTY
27315: LIST
27316: LIST
27317: PUSH
27318: LD_INT 2
27320: NEG
27321: PUSH
27322: LD_INT 0
27324: PUSH
27325: EMPTY
27326: LIST
27327: LIST
27328: PUSH
27329: LD_INT 2
27331: NEG
27332: PUSH
27333: LD_INT 1
27335: NEG
27336: PUSH
27337: EMPTY
27338: LIST
27339: LIST
27340: PUSH
27341: LD_INT 2
27343: NEG
27344: PUSH
27345: LD_INT 1
27347: PUSH
27348: EMPTY
27349: LIST
27350: LIST
27351: PUSH
27352: LD_INT 3
27354: NEG
27355: PUSH
27356: LD_INT 0
27358: PUSH
27359: EMPTY
27360: LIST
27361: LIST
27362: PUSH
27363: LD_INT 3
27365: NEG
27366: PUSH
27367: LD_INT 1
27369: NEG
27370: PUSH
27371: EMPTY
27372: LIST
27373: LIST
27374: PUSH
27375: EMPTY
27376: LIST
27377: LIST
27378: LIST
27379: LIST
27380: LIST
27381: LIST
27382: LIST
27383: LIST
27384: LIST
27385: LIST
27386: LIST
27387: LIST
27388: LIST
27389: LIST
27390: LIST
27391: LIST
27392: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
27393: LD_ADDR_VAR 0 13
27397: PUSH
27398: LD_INT 0
27400: PUSH
27401: LD_INT 0
27403: PUSH
27404: EMPTY
27405: LIST
27406: LIST
27407: PUSH
27408: LD_INT 0
27410: PUSH
27411: LD_INT 1
27413: NEG
27414: PUSH
27415: EMPTY
27416: LIST
27417: LIST
27418: PUSH
27419: LD_INT 1
27421: PUSH
27422: LD_INT 0
27424: PUSH
27425: EMPTY
27426: LIST
27427: LIST
27428: PUSH
27429: LD_INT 1
27431: PUSH
27432: LD_INT 1
27434: PUSH
27435: EMPTY
27436: LIST
27437: LIST
27438: PUSH
27439: LD_INT 0
27441: PUSH
27442: LD_INT 1
27444: PUSH
27445: EMPTY
27446: LIST
27447: LIST
27448: PUSH
27449: LD_INT 1
27451: NEG
27452: PUSH
27453: LD_INT 0
27455: PUSH
27456: EMPTY
27457: LIST
27458: LIST
27459: PUSH
27460: LD_INT 1
27462: NEG
27463: PUSH
27464: LD_INT 1
27466: NEG
27467: PUSH
27468: EMPTY
27469: LIST
27470: LIST
27471: PUSH
27472: LD_INT 1
27474: NEG
27475: PUSH
27476: LD_INT 2
27478: NEG
27479: PUSH
27480: EMPTY
27481: LIST
27482: LIST
27483: PUSH
27484: LD_INT 2
27486: PUSH
27487: LD_INT 1
27489: PUSH
27490: EMPTY
27491: LIST
27492: LIST
27493: PUSH
27494: LD_INT 2
27496: PUSH
27497: LD_INT 2
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: LD_INT 1
27506: PUSH
27507: LD_INT 2
27509: PUSH
27510: EMPTY
27511: LIST
27512: LIST
27513: PUSH
27514: LD_INT 2
27516: NEG
27517: PUSH
27518: LD_INT 1
27520: NEG
27521: PUSH
27522: EMPTY
27523: LIST
27524: LIST
27525: PUSH
27526: LD_INT 2
27528: NEG
27529: PUSH
27530: LD_INT 2
27532: NEG
27533: PUSH
27534: EMPTY
27535: LIST
27536: LIST
27537: PUSH
27538: LD_INT 2
27540: NEG
27541: PUSH
27542: LD_INT 3
27544: NEG
27545: PUSH
27546: EMPTY
27547: LIST
27548: LIST
27549: PUSH
27550: LD_INT 3
27552: NEG
27553: PUSH
27554: LD_INT 2
27556: NEG
27557: PUSH
27558: EMPTY
27559: LIST
27560: LIST
27561: PUSH
27562: LD_INT 3
27564: NEG
27565: PUSH
27566: LD_INT 3
27568: NEG
27569: PUSH
27570: EMPTY
27571: LIST
27572: LIST
27573: PUSH
27574: EMPTY
27575: LIST
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: LIST
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: LIST
27589: LIST
27590: LIST
27591: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
27592: LD_ADDR_VAR 0 14
27596: PUSH
27597: LD_INT 0
27599: PUSH
27600: LD_INT 0
27602: PUSH
27603: EMPTY
27604: LIST
27605: LIST
27606: PUSH
27607: LD_INT 0
27609: PUSH
27610: LD_INT 1
27612: NEG
27613: PUSH
27614: EMPTY
27615: LIST
27616: LIST
27617: PUSH
27618: LD_INT 1
27620: PUSH
27621: LD_INT 0
27623: PUSH
27624: EMPTY
27625: LIST
27626: LIST
27627: PUSH
27628: LD_INT 1
27630: PUSH
27631: LD_INT 1
27633: PUSH
27634: EMPTY
27635: LIST
27636: LIST
27637: PUSH
27638: LD_INT 0
27640: PUSH
27641: LD_INT 1
27643: PUSH
27644: EMPTY
27645: LIST
27646: LIST
27647: PUSH
27648: LD_INT 1
27650: NEG
27651: PUSH
27652: LD_INT 0
27654: PUSH
27655: EMPTY
27656: LIST
27657: LIST
27658: PUSH
27659: LD_INT 1
27661: NEG
27662: PUSH
27663: LD_INT 1
27665: NEG
27666: PUSH
27667: EMPTY
27668: LIST
27669: LIST
27670: PUSH
27671: LD_INT 1
27673: NEG
27674: PUSH
27675: LD_INT 2
27677: NEG
27678: PUSH
27679: EMPTY
27680: LIST
27681: LIST
27682: PUSH
27683: LD_INT 0
27685: PUSH
27686: LD_INT 2
27688: NEG
27689: PUSH
27690: EMPTY
27691: LIST
27692: LIST
27693: PUSH
27694: LD_INT 1
27696: PUSH
27697: LD_INT 1
27699: NEG
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: PUSH
27705: LD_INT 1
27707: PUSH
27708: LD_INT 2
27710: PUSH
27711: EMPTY
27712: LIST
27713: LIST
27714: PUSH
27715: LD_INT 0
27717: PUSH
27718: LD_INT 2
27720: PUSH
27721: EMPTY
27722: LIST
27723: LIST
27724: PUSH
27725: LD_INT 1
27727: NEG
27728: PUSH
27729: LD_INT 1
27731: PUSH
27732: EMPTY
27733: LIST
27734: LIST
27735: PUSH
27736: LD_INT 1
27738: NEG
27739: PUSH
27740: LD_INT 3
27742: NEG
27743: PUSH
27744: EMPTY
27745: LIST
27746: LIST
27747: PUSH
27748: LD_INT 0
27750: PUSH
27751: LD_INT 3
27753: NEG
27754: PUSH
27755: EMPTY
27756: LIST
27757: LIST
27758: PUSH
27759: LD_INT 1
27761: PUSH
27762: LD_INT 2
27764: NEG
27765: PUSH
27766: EMPTY
27767: LIST
27768: LIST
27769: PUSH
27770: EMPTY
27771: LIST
27772: LIST
27773: LIST
27774: LIST
27775: LIST
27776: LIST
27777: LIST
27778: LIST
27779: LIST
27780: LIST
27781: LIST
27782: LIST
27783: LIST
27784: LIST
27785: LIST
27786: LIST
27787: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
27788: LD_ADDR_VAR 0 15
27792: PUSH
27793: LD_INT 0
27795: PUSH
27796: LD_INT 0
27798: PUSH
27799: EMPTY
27800: LIST
27801: LIST
27802: PUSH
27803: LD_INT 0
27805: PUSH
27806: LD_INT 1
27808: NEG
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: PUSH
27814: LD_INT 1
27816: PUSH
27817: LD_INT 0
27819: PUSH
27820: EMPTY
27821: LIST
27822: LIST
27823: PUSH
27824: LD_INT 1
27826: PUSH
27827: LD_INT 1
27829: PUSH
27830: EMPTY
27831: LIST
27832: LIST
27833: PUSH
27834: LD_INT 0
27836: PUSH
27837: LD_INT 1
27839: PUSH
27840: EMPTY
27841: LIST
27842: LIST
27843: PUSH
27844: LD_INT 1
27846: NEG
27847: PUSH
27848: LD_INT 0
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PUSH
27855: LD_INT 1
27857: NEG
27858: PUSH
27859: LD_INT 1
27861: NEG
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PUSH
27867: LD_INT 1
27869: PUSH
27870: LD_INT 1
27872: NEG
27873: PUSH
27874: EMPTY
27875: LIST
27876: LIST
27877: PUSH
27878: LD_INT 2
27880: PUSH
27881: LD_INT 0
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: LD_INT 2
27890: PUSH
27891: LD_INT 1
27893: PUSH
27894: EMPTY
27895: LIST
27896: LIST
27897: PUSH
27898: LD_INT 1
27900: NEG
27901: PUSH
27902: LD_INT 1
27904: PUSH
27905: EMPTY
27906: LIST
27907: LIST
27908: PUSH
27909: LD_INT 2
27911: NEG
27912: PUSH
27913: LD_INT 0
27915: PUSH
27916: EMPTY
27917: LIST
27918: LIST
27919: PUSH
27920: LD_INT 2
27922: NEG
27923: PUSH
27924: LD_INT 1
27926: NEG
27927: PUSH
27928: EMPTY
27929: LIST
27930: LIST
27931: PUSH
27932: LD_INT 2
27934: PUSH
27935: LD_INT 1
27937: NEG
27938: PUSH
27939: EMPTY
27940: LIST
27941: LIST
27942: PUSH
27943: LD_INT 3
27945: PUSH
27946: LD_INT 0
27948: PUSH
27949: EMPTY
27950: LIST
27951: LIST
27952: PUSH
27953: LD_INT 3
27955: PUSH
27956: LD_INT 1
27958: PUSH
27959: EMPTY
27960: LIST
27961: LIST
27962: PUSH
27963: EMPTY
27964: LIST
27965: LIST
27966: LIST
27967: LIST
27968: LIST
27969: LIST
27970: LIST
27971: LIST
27972: LIST
27973: LIST
27974: LIST
27975: LIST
27976: LIST
27977: LIST
27978: LIST
27979: LIST
27980: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
27981: LD_ADDR_VAR 0 16
27985: PUSH
27986: LD_INT 0
27988: PUSH
27989: LD_INT 0
27991: PUSH
27992: EMPTY
27993: LIST
27994: LIST
27995: PUSH
27996: LD_INT 0
27998: PUSH
27999: LD_INT 1
28001: NEG
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: PUSH
28007: LD_INT 1
28009: PUSH
28010: LD_INT 0
28012: PUSH
28013: EMPTY
28014: LIST
28015: LIST
28016: PUSH
28017: LD_INT 1
28019: PUSH
28020: LD_INT 1
28022: PUSH
28023: EMPTY
28024: LIST
28025: LIST
28026: PUSH
28027: LD_INT 0
28029: PUSH
28030: LD_INT 1
28032: PUSH
28033: EMPTY
28034: LIST
28035: LIST
28036: PUSH
28037: LD_INT 1
28039: NEG
28040: PUSH
28041: LD_INT 0
28043: PUSH
28044: EMPTY
28045: LIST
28046: LIST
28047: PUSH
28048: LD_INT 1
28050: NEG
28051: PUSH
28052: LD_INT 1
28054: NEG
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: PUSH
28060: LD_INT 1
28062: NEG
28063: PUSH
28064: LD_INT 2
28066: NEG
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: PUSH
28072: LD_INT 2
28074: PUSH
28075: LD_INT 1
28077: PUSH
28078: EMPTY
28079: LIST
28080: LIST
28081: PUSH
28082: LD_INT 2
28084: PUSH
28085: LD_INT 2
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: PUSH
28092: LD_INT 1
28094: PUSH
28095: LD_INT 2
28097: PUSH
28098: EMPTY
28099: LIST
28100: LIST
28101: PUSH
28102: LD_INT 2
28104: NEG
28105: PUSH
28106: LD_INT 1
28108: NEG
28109: PUSH
28110: EMPTY
28111: LIST
28112: LIST
28113: PUSH
28114: LD_INT 2
28116: NEG
28117: PUSH
28118: LD_INT 2
28120: NEG
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 3
28128: PUSH
28129: LD_INT 2
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: LD_INT 3
28138: PUSH
28139: LD_INT 3
28141: PUSH
28142: EMPTY
28143: LIST
28144: LIST
28145: PUSH
28146: LD_INT 2
28148: PUSH
28149: LD_INT 3
28151: PUSH
28152: EMPTY
28153: LIST
28154: LIST
28155: PUSH
28156: EMPTY
28157: LIST
28158: LIST
28159: LIST
28160: LIST
28161: LIST
28162: LIST
28163: LIST
28164: LIST
28165: LIST
28166: LIST
28167: LIST
28168: LIST
28169: LIST
28170: LIST
28171: LIST
28172: LIST
28173: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28174: LD_ADDR_VAR 0 17
28178: PUSH
28179: LD_INT 0
28181: PUSH
28182: LD_INT 0
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PUSH
28189: LD_INT 0
28191: PUSH
28192: LD_INT 1
28194: NEG
28195: PUSH
28196: EMPTY
28197: LIST
28198: LIST
28199: PUSH
28200: LD_INT 1
28202: PUSH
28203: LD_INT 0
28205: PUSH
28206: EMPTY
28207: LIST
28208: LIST
28209: PUSH
28210: LD_INT 1
28212: PUSH
28213: LD_INT 1
28215: PUSH
28216: EMPTY
28217: LIST
28218: LIST
28219: PUSH
28220: LD_INT 0
28222: PUSH
28223: LD_INT 1
28225: PUSH
28226: EMPTY
28227: LIST
28228: LIST
28229: PUSH
28230: LD_INT 1
28232: NEG
28233: PUSH
28234: LD_INT 0
28236: PUSH
28237: EMPTY
28238: LIST
28239: LIST
28240: PUSH
28241: LD_INT 1
28243: NEG
28244: PUSH
28245: LD_INT 1
28247: NEG
28248: PUSH
28249: EMPTY
28250: LIST
28251: LIST
28252: PUSH
28253: LD_INT 1
28255: NEG
28256: PUSH
28257: LD_INT 2
28259: NEG
28260: PUSH
28261: EMPTY
28262: LIST
28263: LIST
28264: PUSH
28265: LD_INT 0
28267: PUSH
28268: LD_INT 2
28270: NEG
28271: PUSH
28272: EMPTY
28273: LIST
28274: LIST
28275: PUSH
28276: LD_INT 1
28278: PUSH
28279: LD_INT 1
28281: NEG
28282: PUSH
28283: EMPTY
28284: LIST
28285: LIST
28286: PUSH
28287: LD_INT 2
28289: PUSH
28290: LD_INT 0
28292: PUSH
28293: EMPTY
28294: LIST
28295: LIST
28296: PUSH
28297: LD_INT 2
28299: PUSH
28300: LD_INT 1
28302: PUSH
28303: EMPTY
28304: LIST
28305: LIST
28306: PUSH
28307: LD_INT 2
28309: PUSH
28310: LD_INT 2
28312: PUSH
28313: EMPTY
28314: LIST
28315: LIST
28316: PUSH
28317: LD_INT 1
28319: PUSH
28320: LD_INT 2
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: PUSH
28327: LD_INT 0
28329: PUSH
28330: LD_INT 2
28332: PUSH
28333: EMPTY
28334: LIST
28335: LIST
28336: PUSH
28337: LD_INT 1
28339: NEG
28340: PUSH
28341: LD_INT 1
28343: PUSH
28344: EMPTY
28345: LIST
28346: LIST
28347: PUSH
28348: LD_INT 2
28350: NEG
28351: PUSH
28352: LD_INT 0
28354: PUSH
28355: EMPTY
28356: LIST
28357: LIST
28358: PUSH
28359: LD_INT 2
28361: NEG
28362: PUSH
28363: LD_INT 1
28365: NEG
28366: PUSH
28367: EMPTY
28368: LIST
28369: LIST
28370: PUSH
28371: LD_INT 2
28373: NEG
28374: PUSH
28375: LD_INT 2
28377: NEG
28378: PUSH
28379: EMPTY
28380: LIST
28381: LIST
28382: PUSH
28383: EMPTY
28384: LIST
28385: LIST
28386: LIST
28387: LIST
28388: LIST
28389: LIST
28390: LIST
28391: LIST
28392: LIST
28393: LIST
28394: LIST
28395: LIST
28396: LIST
28397: LIST
28398: LIST
28399: LIST
28400: LIST
28401: LIST
28402: LIST
28403: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28404: LD_ADDR_VAR 0 18
28408: PUSH
28409: LD_INT 0
28411: PUSH
28412: LD_INT 0
28414: PUSH
28415: EMPTY
28416: LIST
28417: LIST
28418: PUSH
28419: LD_INT 0
28421: PUSH
28422: LD_INT 1
28424: NEG
28425: PUSH
28426: EMPTY
28427: LIST
28428: LIST
28429: PUSH
28430: LD_INT 1
28432: PUSH
28433: LD_INT 0
28435: PUSH
28436: EMPTY
28437: LIST
28438: LIST
28439: PUSH
28440: LD_INT 1
28442: PUSH
28443: LD_INT 1
28445: PUSH
28446: EMPTY
28447: LIST
28448: LIST
28449: PUSH
28450: LD_INT 0
28452: PUSH
28453: LD_INT 1
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: PUSH
28460: LD_INT 1
28462: NEG
28463: PUSH
28464: LD_INT 0
28466: PUSH
28467: EMPTY
28468: LIST
28469: LIST
28470: PUSH
28471: LD_INT 1
28473: NEG
28474: PUSH
28475: LD_INT 1
28477: NEG
28478: PUSH
28479: EMPTY
28480: LIST
28481: LIST
28482: PUSH
28483: LD_INT 1
28485: NEG
28486: PUSH
28487: LD_INT 2
28489: NEG
28490: PUSH
28491: EMPTY
28492: LIST
28493: LIST
28494: PUSH
28495: LD_INT 0
28497: PUSH
28498: LD_INT 2
28500: NEG
28501: PUSH
28502: EMPTY
28503: LIST
28504: LIST
28505: PUSH
28506: LD_INT 1
28508: PUSH
28509: LD_INT 1
28511: NEG
28512: PUSH
28513: EMPTY
28514: LIST
28515: LIST
28516: PUSH
28517: LD_INT 2
28519: PUSH
28520: LD_INT 0
28522: PUSH
28523: EMPTY
28524: LIST
28525: LIST
28526: PUSH
28527: LD_INT 2
28529: PUSH
28530: LD_INT 1
28532: PUSH
28533: EMPTY
28534: LIST
28535: LIST
28536: PUSH
28537: LD_INT 2
28539: PUSH
28540: LD_INT 2
28542: PUSH
28543: EMPTY
28544: LIST
28545: LIST
28546: PUSH
28547: LD_INT 1
28549: PUSH
28550: LD_INT 2
28552: PUSH
28553: EMPTY
28554: LIST
28555: LIST
28556: PUSH
28557: LD_INT 0
28559: PUSH
28560: LD_INT 2
28562: PUSH
28563: EMPTY
28564: LIST
28565: LIST
28566: PUSH
28567: LD_INT 1
28569: NEG
28570: PUSH
28571: LD_INT 1
28573: PUSH
28574: EMPTY
28575: LIST
28576: LIST
28577: PUSH
28578: LD_INT 2
28580: NEG
28581: PUSH
28582: LD_INT 0
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: LD_INT 2
28591: NEG
28592: PUSH
28593: LD_INT 1
28595: NEG
28596: PUSH
28597: EMPTY
28598: LIST
28599: LIST
28600: PUSH
28601: LD_INT 2
28603: NEG
28604: PUSH
28605: LD_INT 2
28607: NEG
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: LIST
28617: LIST
28618: LIST
28619: LIST
28620: LIST
28621: LIST
28622: LIST
28623: LIST
28624: LIST
28625: LIST
28626: LIST
28627: LIST
28628: LIST
28629: LIST
28630: LIST
28631: LIST
28632: LIST
28633: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28634: LD_ADDR_VAR 0 19
28638: PUSH
28639: LD_INT 0
28641: PUSH
28642: LD_INT 0
28644: PUSH
28645: EMPTY
28646: LIST
28647: LIST
28648: PUSH
28649: LD_INT 0
28651: PUSH
28652: LD_INT 1
28654: NEG
28655: PUSH
28656: EMPTY
28657: LIST
28658: LIST
28659: PUSH
28660: LD_INT 1
28662: PUSH
28663: LD_INT 0
28665: PUSH
28666: EMPTY
28667: LIST
28668: LIST
28669: PUSH
28670: LD_INT 1
28672: PUSH
28673: LD_INT 1
28675: PUSH
28676: EMPTY
28677: LIST
28678: LIST
28679: PUSH
28680: LD_INT 0
28682: PUSH
28683: LD_INT 1
28685: PUSH
28686: EMPTY
28687: LIST
28688: LIST
28689: PUSH
28690: LD_INT 1
28692: NEG
28693: PUSH
28694: LD_INT 0
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: LD_INT 1
28703: NEG
28704: PUSH
28705: LD_INT 1
28707: NEG
28708: PUSH
28709: EMPTY
28710: LIST
28711: LIST
28712: PUSH
28713: LD_INT 1
28715: NEG
28716: PUSH
28717: LD_INT 2
28719: NEG
28720: PUSH
28721: EMPTY
28722: LIST
28723: LIST
28724: PUSH
28725: LD_INT 0
28727: PUSH
28728: LD_INT 2
28730: NEG
28731: PUSH
28732: EMPTY
28733: LIST
28734: LIST
28735: PUSH
28736: LD_INT 1
28738: PUSH
28739: LD_INT 1
28741: NEG
28742: PUSH
28743: EMPTY
28744: LIST
28745: LIST
28746: PUSH
28747: LD_INT 2
28749: PUSH
28750: LD_INT 0
28752: PUSH
28753: EMPTY
28754: LIST
28755: LIST
28756: PUSH
28757: LD_INT 2
28759: PUSH
28760: LD_INT 1
28762: PUSH
28763: EMPTY
28764: LIST
28765: LIST
28766: PUSH
28767: LD_INT 2
28769: PUSH
28770: LD_INT 2
28772: PUSH
28773: EMPTY
28774: LIST
28775: LIST
28776: PUSH
28777: LD_INT 1
28779: PUSH
28780: LD_INT 2
28782: PUSH
28783: EMPTY
28784: LIST
28785: LIST
28786: PUSH
28787: LD_INT 0
28789: PUSH
28790: LD_INT 2
28792: PUSH
28793: EMPTY
28794: LIST
28795: LIST
28796: PUSH
28797: LD_INT 1
28799: NEG
28800: PUSH
28801: LD_INT 1
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 2
28810: NEG
28811: PUSH
28812: LD_INT 0
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: LD_INT 2
28821: NEG
28822: PUSH
28823: LD_INT 1
28825: NEG
28826: PUSH
28827: EMPTY
28828: LIST
28829: LIST
28830: PUSH
28831: LD_INT 2
28833: NEG
28834: PUSH
28835: LD_INT 2
28837: NEG
28838: PUSH
28839: EMPTY
28840: LIST
28841: LIST
28842: PUSH
28843: EMPTY
28844: LIST
28845: LIST
28846: LIST
28847: LIST
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: LIST
28862: LIST
28863: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28864: LD_ADDR_VAR 0 20
28868: PUSH
28869: LD_INT 0
28871: PUSH
28872: LD_INT 0
28874: PUSH
28875: EMPTY
28876: LIST
28877: LIST
28878: PUSH
28879: LD_INT 0
28881: PUSH
28882: LD_INT 1
28884: NEG
28885: PUSH
28886: EMPTY
28887: LIST
28888: LIST
28889: PUSH
28890: LD_INT 1
28892: PUSH
28893: LD_INT 0
28895: PUSH
28896: EMPTY
28897: LIST
28898: LIST
28899: PUSH
28900: LD_INT 1
28902: PUSH
28903: LD_INT 1
28905: PUSH
28906: EMPTY
28907: LIST
28908: LIST
28909: PUSH
28910: LD_INT 0
28912: PUSH
28913: LD_INT 1
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: PUSH
28920: LD_INT 1
28922: NEG
28923: PUSH
28924: LD_INT 0
28926: PUSH
28927: EMPTY
28928: LIST
28929: LIST
28930: PUSH
28931: LD_INT 1
28933: NEG
28934: PUSH
28935: LD_INT 1
28937: NEG
28938: PUSH
28939: EMPTY
28940: LIST
28941: LIST
28942: PUSH
28943: LD_INT 1
28945: NEG
28946: PUSH
28947: LD_INT 2
28949: NEG
28950: PUSH
28951: EMPTY
28952: LIST
28953: LIST
28954: PUSH
28955: LD_INT 0
28957: PUSH
28958: LD_INT 2
28960: NEG
28961: PUSH
28962: EMPTY
28963: LIST
28964: LIST
28965: PUSH
28966: LD_INT 1
28968: PUSH
28969: LD_INT 1
28971: NEG
28972: PUSH
28973: EMPTY
28974: LIST
28975: LIST
28976: PUSH
28977: LD_INT 2
28979: PUSH
28980: LD_INT 0
28982: PUSH
28983: EMPTY
28984: LIST
28985: LIST
28986: PUSH
28987: LD_INT 2
28989: PUSH
28990: LD_INT 1
28992: PUSH
28993: EMPTY
28994: LIST
28995: LIST
28996: PUSH
28997: LD_INT 2
28999: PUSH
29000: LD_INT 2
29002: PUSH
29003: EMPTY
29004: LIST
29005: LIST
29006: PUSH
29007: LD_INT 1
29009: PUSH
29010: LD_INT 2
29012: PUSH
29013: EMPTY
29014: LIST
29015: LIST
29016: PUSH
29017: LD_INT 0
29019: PUSH
29020: LD_INT 2
29022: PUSH
29023: EMPTY
29024: LIST
29025: LIST
29026: PUSH
29027: LD_INT 1
29029: NEG
29030: PUSH
29031: LD_INT 1
29033: PUSH
29034: EMPTY
29035: LIST
29036: LIST
29037: PUSH
29038: LD_INT 2
29040: NEG
29041: PUSH
29042: LD_INT 0
29044: PUSH
29045: EMPTY
29046: LIST
29047: LIST
29048: PUSH
29049: LD_INT 2
29051: NEG
29052: PUSH
29053: LD_INT 1
29055: NEG
29056: PUSH
29057: EMPTY
29058: LIST
29059: LIST
29060: PUSH
29061: LD_INT 2
29063: NEG
29064: PUSH
29065: LD_INT 2
29067: NEG
29068: PUSH
29069: EMPTY
29070: LIST
29071: LIST
29072: PUSH
29073: EMPTY
29074: LIST
29075: LIST
29076: LIST
29077: LIST
29078: LIST
29079: LIST
29080: LIST
29081: LIST
29082: LIST
29083: LIST
29084: LIST
29085: LIST
29086: LIST
29087: LIST
29088: LIST
29089: LIST
29090: LIST
29091: LIST
29092: LIST
29093: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29094: LD_ADDR_VAR 0 21
29098: PUSH
29099: LD_INT 0
29101: PUSH
29102: LD_INT 0
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PUSH
29109: LD_INT 0
29111: PUSH
29112: LD_INT 1
29114: NEG
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PUSH
29120: LD_INT 1
29122: PUSH
29123: LD_INT 0
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 1
29132: PUSH
29133: LD_INT 1
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: LD_INT 0
29142: PUSH
29143: LD_INT 1
29145: PUSH
29146: EMPTY
29147: LIST
29148: LIST
29149: PUSH
29150: LD_INT 1
29152: NEG
29153: PUSH
29154: LD_INT 0
29156: PUSH
29157: EMPTY
29158: LIST
29159: LIST
29160: PUSH
29161: LD_INT 1
29163: NEG
29164: PUSH
29165: LD_INT 1
29167: NEG
29168: PUSH
29169: EMPTY
29170: LIST
29171: LIST
29172: PUSH
29173: LD_INT 1
29175: NEG
29176: PUSH
29177: LD_INT 2
29179: NEG
29180: PUSH
29181: EMPTY
29182: LIST
29183: LIST
29184: PUSH
29185: LD_INT 0
29187: PUSH
29188: LD_INT 2
29190: NEG
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PUSH
29196: LD_INT 1
29198: PUSH
29199: LD_INT 1
29201: NEG
29202: PUSH
29203: EMPTY
29204: LIST
29205: LIST
29206: PUSH
29207: LD_INT 2
29209: PUSH
29210: LD_INT 0
29212: PUSH
29213: EMPTY
29214: LIST
29215: LIST
29216: PUSH
29217: LD_INT 2
29219: PUSH
29220: LD_INT 1
29222: PUSH
29223: EMPTY
29224: LIST
29225: LIST
29226: PUSH
29227: LD_INT 2
29229: PUSH
29230: LD_INT 2
29232: PUSH
29233: EMPTY
29234: LIST
29235: LIST
29236: PUSH
29237: LD_INT 1
29239: PUSH
29240: LD_INT 2
29242: PUSH
29243: EMPTY
29244: LIST
29245: LIST
29246: PUSH
29247: LD_INT 0
29249: PUSH
29250: LD_INT 2
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: LD_INT 1
29259: NEG
29260: PUSH
29261: LD_INT 1
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: PUSH
29268: LD_INT 2
29270: NEG
29271: PUSH
29272: LD_INT 0
29274: PUSH
29275: EMPTY
29276: LIST
29277: LIST
29278: PUSH
29279: LD_INT 2
29281: NEG
29282: PUSH
29283: LD_INT 1
29285: NEG
29286: PUSH
29287: EMPTY
29288: LIST
29289: LIST
29290: PUSH
29291: LD_INT 2
29293: NEG
29294: PUSH
29295: LD_INT 2
29297: NEG
29298: PUSH
29299: EMPTY
29300: LIST
29301: LIST
29302: PUSH
29303: EMPTY
29304: LIST
29305: LIST
29306: LIST
29307: LIST
29308: LIST
29309: LIST
29310: LIST
29311: LIST
29312: LIST
29313: LIST
29314: LIST
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29324: LD_ADDR_VAR 0 22
29328: PUSH
29329: LD_INT 0
29331: PUSH
29332: LD_INT 0
29334: PUSH
29335: EMPTY
29336: LIST
29337: LIST
29338: PUSH
29339: LD_INT 0
29341: PUSH
29342: LD_INT 1
29344: NEG
29345: PUSH
29346: EMPTY
29347: LIST
29348: LIST
29349: PUSH
29350: LD_INT 1
29352: PUSH
29353: LD_INT 0
29355: PUSH
29356: EMPTY
29357: LIST
29358: LIST
29359: PUSH
29360: LD_INT 1
29362: PUSH
29363: LD_INT 1
29365: PUSH
29366: EMPTY
29367: LIST
29368: LIST
29369: PUSH
29370: LD_INT 0
29372: PUSH
29373: LD_INT 1
29375: PUSH
29376: EMPTY
29377: LIST
29378: LIST
29379: PUSH
29380: LD_INT 1
29382: NEG
29383: PUSH
29384: LD_INT 0
29386: PUSH
29387: EMPTY
29388: LIST
29389: LIST
29390: PUSH
29391: LD_INT 1
29393: NEG
29394: PUSH
29395: LD_INT 1
29397: NEG
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PUSH
29403: LD_INT 1
29405: NEG
29406: PUSH
29407: LD_INT 2
29409: NEG
29410: PUSH
29411: EMPTY
29412: LIST
29413: LIST
29414: PUSH
29415: LD_INT 0
29417: PUSH
29418: LD_INT 2
29420: NEG
29421: PUSH
29422: EMPTY
29423: LIST
29424: LIST
29425: PUSH
29426: LD_INT 1
29428: PUSH
29429: LD_INT 1
29431: NEG
29432: PUSH
29433: EMPTY
29434: LIST
29435: LIST
29436: PUSH
29437: LD_INT 2
29439: PUSH
29440: LD_INT 0
29442: PUSH
29443: EMPTY
29444: LIST
29445: LIST
29446: PUSH
29447: LD_INT 2
29449: PUSH
29450: LD_INT 1
29452: PUSH
29453: EMPTY
29454: LIST
29455: LIST
29456: PUSH
29457: LD_INT 2
29459: PUSH
29460: LD_INT 2
29462: PUSH
29463: EMPTY
29464: LIST
29465: LIST
29466: PUSH
29467: LD_INT 1
29469: PUSH
29470: LD_INT 2
29472: PUSH
29473: EMPTY
29474: LIST
29475: LIST
29476: PUSH
29477: LD_INT 0
29479: PUSH
29480: LD_INT 2
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PUSH
29487: LD_INT 1
29489: NEG
29490: PUSH
29491: LD_INT 1
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: PUSH
29498: LD_INT 2
29500: NEG
29501: PUSH
29502: LD_INT 0
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PUSH
29509: LD_INT 2
29511: NEG
29512: PUSH
29513: LD_INT 1
29515: NEG
29516: PUSH
29517: EMPTY
29518: LIST
29519: LIST
29520: PUSH
29521: LD_INT 2
29523: NEG
29524: PUSH
29525: LD_INT 2
29527: NEG
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PUSH
29533: EMPTY
29534: LIST
29535: LIST
29536: LIST
29537: LIST
29538: LIST
29539: LIST
29540: LIST
29541: LIST
29542: LIST
29543: LIST
29544: LIST
29545: LIST
29546: LIST
29547: LIST
29548: LIST
29549: LIST
29550: LIST
29551: LIST
29552: LIST
29553: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
29554: LD_ADDR_VAR 0 23
29558: PUSH
29559: LD_INT 0
29561: PUSH
29562: LD_INT 0
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 0
29571: PUSH
29572: LD_INT 1
29574: NEG
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 1
29582: PUSH
29583: LD_INT 0
29585: PUSH
29586: EMPTY
29587: LIST
29588: LIST
29589: PUSH
29590: LD_INT 1
29592: PUSH
29593: LD_INT 1
29595: PUSH
29596: EMPTY
29597: LIST
29598: LIST
29599: PUSH
29600: LD_INT 0
29602: PUSH
29603: LD_INT 1
29605: PUSH
29606: EMPTY
29607: LIST
29608: LIST
29609: PUSH
29610: LD_INT 1
29612: NEG
29613: PUSH
29614: LD_INT 0
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PUSH
29621: LD_INT 1
29623: NEG
29624: PUSH
29625: LD_INT 1
29627: NEG
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PUSH
29633: LD_INT 1
29635: NEG
29636: PUSH
29637: LD_INT 2
29639: NEG
29640: PUSH
29641: EMPTY
29642: LIST
29643: LIST
29644: PUSH
29645: LD_INT 0
29647: PUSH
29648: LD_INT 2
29650: NEG
29651: PUSH
29652: EMPTY
29653: LIST
29654: LIST
29655: PUSH
29656: LD_INT 1
29658: PUSH
29659: LD_INT 1
29661: NEG
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 2
29669: PUSH
29670: LD_INT 0
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 2
29679: PUSH
29680: LD_INT 1
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: PUSH
29687: LD_INT 2
29689: PUSH
29690: LD_INT 2
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PUSH
29697: LD_INT 1
29699: PUSH
29700: LD_INT 2
29702: PUSH
29703: EMPTY
29704: LIST
29705: LIST
29706: PUSH
29707: LD_INT 0
29709: PUSH
29710: LD_INT 2
29712: PUSH
29713: EMPTY
29714: LIST
29715: LIST
29716: PUSH
29717: LD_INT 1
29719: NEG
29720: PUSH
29721: LD_INT 1
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: PUSH
29728: LD_INT 2
29730: NEG
29731: PUSH
29732: LD_INT 0
29734: PUSH
29735: EMPTY
29736: LIST
29737: LIST
29738: PUSH
29739: LD_INT 2
29741: NEG
29742: PUSH
29743: LD_INT 1
29745: NEG
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: PUSH
29751: LD_INT 2
29753: NEG
29754: PUSH
29755: LD_INT 2
29757: NEG
29758: PUSH
29759: EMPTY
29760: LIST
29761: LIST
29762: PUSH
29763: LD_INT 2
29765: NEG
29766: PUSH
29767: LD_INT 3
29769: NEG
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: PUSH
29775: LD_INT 1
29777: NEG
29778: PUSH
29779: LD_INT 3
29781: NEG
29782: PUSH
29783: EMPTY
29784: LIST
29785: LIST
29786: PUSH
29787: LD_INT 1
29789: PUSH
29790: LD_INT 2
29792: NEG
29793: PUSH
29794: EMPTY
29795: LIST
29796: LIST
29797: PUSH
29798: LD_INT 2
29800: PUSH
29801: LD_INT 1
29803: NEG
29804: PUSH
29805: EMPTY
29806: LIST
29807: LIST
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: LIST
29813: LIST
29814: LIST
29815: LIST
29816: LIST
29817: LIST
29818: LIST
29819: LIST
29820: LIST
29821: LIST
29822: LIST
29823: LIST
29824: LIST
29825: LIST
29826: LIST
29827: LIST
29828: LIST
29829: LIST
29830: LIST
29831: LIST
29832: LIST
29833: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
29834: LD_ADDR_VAR 0 24
29838: PUSH
29839: LD_INT 0
29841: PUSH
29842: LD_INT 0
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: PUSH
29849: LD_INT 0
29851: PUSH
29852: LD_INT 1
29854: NEG
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: LD_INT 1
29862: PUSH
29863: LD_INT 0
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: PUSH
29870: LD_INT 1
29872: PUSH
29873: LD_INT 1
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: PUSH
29880: LD_INT 0
29882: PUSH
29883: LD_INT 1
29885: PUSH
29886: EMPTY
29887: LIST
29888: LIST
29889: PUSH
29890: LD_INT 1
29892: NEG
29893: PUSH
29894: LD_INT 0
29896: PUSH
29897: EMPTY
29898: LIST
29899: LIST
29900: PUSH
29901: LD_INT 1
29903: NEG
29904: PUSH
29905: LD_INT 1
29907: NEG
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PUSH
29913: LD_INT 1
29915: NEG
29916: PUSH
29917: LD_INT 2
29919: NEG
29920: PUSH
29921: EMPTY
29922: LIST
29923: LIST
29924: PUSH
29925: LD_INT 0
29927: PUSH
29928: LD_INT 2
29930: NEG
29931: PUSH
29932: EMPTY
29933: LIST
29934: LIST
29935: PUSH
29936: LD_INT 1
29938: PUSH
29939: LD_INT 1
29941: NEG
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 2
29949: PUSH
29950: LD_INT 0
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: LD_INT 2
29959: PUSH
29960: LD_INT 1
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: PUSH
29967: LD_INT 2
29969: PUSH
29970: LD_INT 2
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: PUSH
29977: LD_INT 1
29979: PUSH
29980: LD_INT 2
29982: PUSH
29983: EMPTY
29984: LIST
29985: LIST
29986: PUSH
29987: LD_INT 0
29989: PUSH
29990: LD_INT 2
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 1
29999: NEG
30000: PUSH
30001: LD_INT 1
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 2
30010: NEG
30011: PUSH
30012: LD_INT 0
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: PUSH
30019: LD_INT 2
30021: NEG
30022: PUSH
30023: LD_INT 1
30025: NEG
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PUSH
30031: LD_INT 2
30033: NEG
30034: PUSH
30035: LD_INT 2
30037: NEG
30038: PUSH
30039: EMPTY
30040: LIST
30041: LIST
30042: PUSH
30043: LD_INT 1
30045: PUSH
30046: LD_INT 2
30048: NEG
30049: PUSH
30050: EMPTY
30051: LIST
30052: LIST
30053: PUSH
30054: LD_INT 2
30056: PUSH
30057: LD_INT 1
30059: NEG
30060: PUSH
30061: EMPTY
30062: LIST
30063: LIST
30064: PUSH
30065: LD_INT 3
30067: PUSH
30068: LD_INT 1
30070: PUSH
30071: EMPTY
30072: LIST
30073: LIST
30074: PUSH
30075: LD_INT 3
30077: PUSH
30078: LD_INT 2
30080: PUSH
30081: EMPTY
30082: LIST
30083: LIST
30084: PUSH
30085: EMPTY
30086: LIST
30087: LIST
30088: LIST
30089: LIST
30090: LIST
30091: LIST
30092: LIST
30093: LIST
30094: LIST
30095: LIST
30096: LIST
30097: LIST
30098: LIST
30099: LIST
30100: LIST
30101: LIST
30102: LIST
30103: LIST
30104: LIST
30105: LIST
30106: LIST
30107: LIST
30108: LIST
30109: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30110: LD_ADDR_VAR 0 25
30114: PUSH
30115: LD_INT 0
30117: PUSH
30118: LD_INT 0
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: LD_INT 0
30127: PUSH
30128: LD_INT 1
30130: NEG
30131: PUSH
30132: EMPTY
30133: LIST
30134: LIST
30135: PUSH
30136: LD_INT 1
30138: PUSH
30139: LD_INT 0
30141: PUSH
30142: EMPTY
30143: LIST
30144: LIST
30145: PUSH
30146: LD_INT 1
30148: PUSH
30149: LD_INT 1
30151: PUSH
30152: EMPTY
30153: LIST
30154: LIST
30155: PUSH
30156: LD_INT 0
30158: PUSH
30159: LD_INT 1
30161: PUSH
30162: EMPTY
30163: LIST
30164: LIST
30165: PUSH
30166: LD_INT 1
30168: NEG
30169: PUSH
30170: LD_INT 0
30172: PUSH
30173: EMPTY
30174: LIST
30175: LIST
30176: PUSH
30177: LD_INT 1
30179: NEG
30180: PUSH
30181: LD_INT 1
30183: NEG
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PUSH
30189: LD_INT 1
30191: NEG
30192: PUSH
30193: LD_INT 2
30195: NEG
30196: PUSH
30197: EMPTY
30198: LIST
30199: LIST
30200: PUSH
30201: LD_INT 0
30203: PUSH
30204: LD_INT 2
30206: NEG
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PUSH
30212: LD_INT 1
30214: PUSH
30215: LD_INT 1
30217: NEG
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: LD_INT 2
30225: PUSH
30226: LD_INT 0
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: LD_INT 2
30235: PUSH
30236: LD_INT 1
30238: PUSH
30239: EMPTY
30240: LIST
30241: LIST
30242: PUSH
30243: LD_INT 2
30245: PUSH
30246: LD_INT 2
30248: PUSH
30249: EMPTY
30250: LIST
30251: LIST
30252: PUSH
30253: LD_INT 1
30255: PUSH
30256: LD_INT 2
30258: PUSH
30259: EMPTY
30260: LIST
30261: LIST
30262: PUSH
30263: LD_INT 0
30265: PUSH
30266: LD_INT 2
30268: PUSH
30269: EMPTY
30270: LIST
30271: LIST
30272: PUSH
30273: LD_INT 1
30275: NEG
30276: PUSH
30277: LD_INT 1
30279: PUSH
30280: EMPTY
30281: LIST
30282: LIST
30283: PUSH
30284: LD_INT 2
30286: NEG
30287: PUSH
30288: LD_INT 0
30290: PUSH
30291: EMPTY
30292: LIST
30293: LIST
30294: PUSH
30295: LD_INT 2
30297: NEG
30298: PUSH
30299: LD_INT 1
30301: NEG
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: PUSH
30307: LD_INT 2
30309: NEG
30310: PUSH
30311: LD_INT 2
30313: NEG
30314: PUSH
30315: EMPTY
30316: LIST
30317: LIST
30318: PUSH
30319: LD_INT 3
30321: PUSH
30322: LD_INT 1
30324: PUSH
30325: EMPTY
30326: LIST
30327: LIST
30328: PUSH
30329: LD_INT 3
30331: PUSH
30332: LD_INT 2
30334: PUSH
30335: EMPTY
30336: LIST
30337: LIST
30338: PUSH
30339: LD_INT 2
30341: PUSH
30342: LD_INT 3
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: LD_INT 1
30351: PUSH
30352: LD_INT 3
30354: PUSH
30355: EMPTY
30356: LIST
30357: LIST
30358: PUSH
30359: EMPTY
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: LIST
30368: LIST
30369: LIST
30370: LIST
30371: LIST
30372: LIST
30373: LIST
30374: LIST
30375: LIST
30376: LIST
30377: LIST
30378: LIST
30379: LIST
30380: LIST
30381: LIST
30382: LIST
30383: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
30384: LD_ADDR_VAR 0 26
30388: PUSH
30389: LD_INT 0
30391: PUSH
30392: LD_INT 0
30394: PUSH
30395: EMPTY
30396: LIST
30397: LIST
30398: PUSH
30399: LD_INT 0
30401: PUSH
30402: LD_INT 1
30404: NEG
30405: PUSH
30406: EMPTY
30407: LIST
30408: LIST
30409: PUSH
30410: LD_INT 1
30412: PUSH
30413: LD_INT 0
30415: PUSH
30416: EMPTY
30417: LIST
30418: LIST
30419: PUSH
30420: LD_INT 1
30422: PUSH
30423: LD_INT 1
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: PUSH
30430: LD_INT 0
30432: PUSH
30433: LD_INT 1
30435: PUSH
30436: EMPTY
30437: LIST
30438: LIST
30439: PUSH
30440: LD_INT 1
30442: NEG
30443: PUSH
30444: LD_INT 0
30446: PUSH
30447: EMPTY
30448: LIST
30449: LIST
30450: PUSH
30451: LD_INT 1
30453: NEG
30454: PUSH
30455: LD_INT 1
30457: NEG
30458: PUSH
30459: EMPTY
30460: LIST
30461: LIST
30462: PUSH
30463: LD_INT 1
30465: NEG
30466: PUSH
30467: LD_INT 2
30469: NEG
30470: PUSH
30471: EMPTY
30472: LIST
30473: LIST
30474: PUSH
30475: LD_INT 0
30477: PUSH
30478: LD_INT 2
30480: NEG
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: PUSH
30486: LD_INT 1
30488: PUSH
30489: LD_INT 1
30491: NEG
30492: PUSH
30493: EMPTY
30494: LIST
30495: LIST
30496: PUSH
30497: LD_INT 2
30499: PUSH
30500: LD_INT 0
30502: PUSH
30503: EMPTY
30504: LIST
30505: LIST
30506: PUSH
30507: LD_INT 2
30509: PUSH
30510: LD_INT 1
30512: PUSH
30513: EMPTY
30514: LIST
30515: LIST
30516: PUSH
30517: LD_INT 2
30519: PUSH
30520: LD_INT 2
30522: PUSH
30523: EMPTY
30524: LIST
30525: LIST
30526: PUSH
30527: LD_INT 1
30529: PUSH
30530: LD_INT 2
30532: PUSH
30533: EMPTY
30534: LIST
30535: LIST
30536: PUSH
30537: LD_INT 0
30539: PUSH
30540: LD_INT 2
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: LD_INT 1
30549: NEG
30550: PUSH
30551: LD_INT 1
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: LD_INT 2
30560: NEG
30561: PUSH
30562: LD_INT 0
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: LD_INT 2
30571: NEG
30572: PUSH
30573: LD_INT 1
30575: NEG
30576: PUSH
30577: EMPTY
30578: LIST
30579: LIST
30580: PUSH
30581: LD_INT 2
30583: NEG
30584: PUSH
30585: LD_INT 2
30587: NEG
30588: PUSH
30589: EMPTY
30590: LIST
30591: LIST
30592: PUSH
30593: LD_INT 2
30595: PUSH
30596: LD_INT 3
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: PUSH
30603: LD_INT 1
30605: PUSH
30606: LD_INT 3
30608: PUSH
30609: EMPTY
30610: LIST
30611: LIST
30612: PUSH
30613: LD_INT 1
30615: NEG
30616: PUSH
30617: LD_INT 2
30619: PUSH
30620: EMPTY
30621: LIST
30622: LIST
30623: PUSH
30624: LD_INT 2
30626: NEG
30627: PUSH
30628: LD_INT 1
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PUSH
30635: EMPTY
30636: LIST
30637: LIST
30638: LIST
30639: LIST
30640: LIST
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: LIST
30646: LIST
30647: LIST
30648: LIST
30649: LIST
30650: LIST
30651: LIST
30652: LIST
30653: LIST
30654: LIST
30655: LIST
30656: LIST
30657: LIST
30658: LIST
30659: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
30660: LD_ADDR_VAR 0 27
30664: PUSH
30665: LD_INT 0
30667: PUSH
30668: LD_INT 0
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: PUSH
30675: LD_INT 0
30677: PUSH
30678: LD_INT 1
30680: NEG
30681: PUSH
30682: EMPTY
30683: LIST
30684: LIST
30685: PUSH
30686: LD_INT 1
30688: PUSH
30689: LD_INT 0
30691: PUSH
30692: EMPTY
30693: LIST
30694: LIST
30695: PUSH
30696: LD_INT 1
30698: PUSH
30699: LD_INT 1
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: PUSH
30706: LD_INT 0
30708: PUSH
30709: LD_INT 1
30711: PUSH
30712: EMPTY
30713: LIST
30714: LIST
30715: PUSH
30716: LD_INT 1
30718: NEG
30719: PUSH
30720: LD_INT 0
30722: PUSH
30723: EMPTY
30724: LIST
30725: LIST
30726: PUSH
30727: LD_INT 1
30729: NEG
30730: PUSH
30731: LD_INT 1
30733: NEG
30734: PUSH
30735: EMPTY
30736: LIST
30737: LIST
30738: PUSH
30739: LD_INT 1
30741: NEG
30742: PUSH
30743: LD_INT 2
30745: NEG
30746: PUSH
30747: EMPTY
30748: LIST
30749: LIST
30750: PUSH
30751: LD_INT 0
30753: PUSH
30754: LD_INT 2
30756: NEG
30757: PUSH
30758: EMPTY
30759: LIST
30760: LIST
30761: PUSH
30762: LD_INT 1
30764: PUSH
30765: LD_INT 1
30767: NEG
30768: PUSH
30769: EMPTY
30770: LIST
30771: LIST
30772: PUSH
30773: LD_INT 2
30775: PUSH
30776: LD_INT 0
30778: PUSH
30779: EMPTY
30780: LIST
30781: LIST
30782: PUSH
30783: LD_INT 2
30785: PUSH
30786: LD_INT 1
30788: PUSH
30789: EMPTY
30790: LIST
30791: LIST
30792: PUSH
30793: LD_INT 2
30795: PUSH
30796: LD_INT 2
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: PUSH
30803: LD_INT 1
30805: PUSH
30806: LD_INT 2
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PUSH
30813: LD_INT 0
30815: PUSH
30816: LD_INT 2
30818: PUSH
30819: EMPTY
30820: LIST
30821: LIST
30822: PUSH
30823: LD_INT 1
30825: NEG
30826: PUSH
30827: LD_INT 1
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: PUSH
30834: LD_INT 2
30836: NEG
30837: PUSH
30838: LD_INT 0
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: LD_INT 2
30847: NEG
30848: PUSH
30849: LD_INT 1
30851: NEG
30852: PUSH
30853: EMPTY
30854: LIST
30855: LIST
30856: PUSH
30857: LD_INT 2
30859: NEG
30860: PUSH
30861: LD_INT 2
30863: NEG
30864: PUSH
30865: EMPTY
30866: LIST
30867: LIST
30868: PUSH
30869: LD_INT 1
30871: NEG
30872: PUSH
30873: LD_INT 2
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: LD_INT 2
30882: NEG
30883: PUSH
30884: LD_INT 1
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: PUSH
30891: LD_INT 3
30893: NEG
30894: PUSH
30895: LD_INT 1
30897: NEG
30898: PUSH
30899: EMPTY
30900: LIST
30901: LIST
30902: PUSH
30903: LD_INT 3
30905: NEG
30906: PUSH
30907: LD_INT 2
30909: NEG
30910: PUSH
30911: EMPTY
30912: LIST
30913: LIST
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: LIST
30923: LIST
30924: LIST
30925: LIST
30926: LIST
30927: LIST
30928: LIST
30929: LIST
30930: LIST
30931: LIST
30932: LIST
30933: LIST
30934: LIST
30935: LIST
30936: LIST
30937: LIST
30938: LIST
30939: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
30940: LD_ADDR_VAR 0 28
30944: PUSH
30945: LD_INT 0
30947: PUSH
30948: LD_INT 0
30950: PUSH
30951: EMPTY
30952: LIST
30953: LIST
30954: PUSH
30955: LD_INT 0
30957: PUSH
30958: LD_INT 1
30960: NEG
30961: PUSH
30962: EMPTY
30963: LIST
30964: LIST
30965: PUSH
30966: LD_INT 1
30968: PUSH
30969: LD_INT 0
30971: PUSH
30972: EMPTY
30973: LIST
30974: LIST
30975: PUSH
30976: LD_INT 1
30978: PUSH
30979: LD_INT 1
30981: PUSH
30982: EMPTY
30983: LIST
30984: LIST
30985: PUSH
30986: LD_INT 0
30988: PUSH
30989: LD_INT 1
30991: PUSH
30992: EMPTY
30993: LIST
30994: LIST
30995: PUSH
30996: LD_INT 1
30998: NEG
30999: PUSH
31000: LD_INT 0
31002: PUSH
31003: EMPTY
31004: LIST
31005: LIST
31006: PUSH
31007: LD_INT 1
31009: NEG
31010: PUSH
31011: LD_INT 1
31013: NEG
31014: PUSH
31015: EMPTY
31016: LIST
31017: LIST
31018: PUSH
31019: LD_INT 1
31021: NEG
31022: PUSH
31023: LD_INT 2
31025: NEG
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 0
31033: PUSH
31034: LD_INT 2
31036: NEG
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PUSH
31042: LD_INT 1
31044: PUSH
31045: LD_INT 1
31047: NEG
31048: PUSH
31049: EMPTY
31050: LIST
31051: LIST
31052: PUSH
31053: LD_INT 2
31055: PUSH
31056: LD_INT 0
31058: PUSH
31059: EMPTY
31060: LIST
31061: LIST
31062: PUSH
31063: LD_INT 2
31065: PUSH
31066: LD_INT 1
31068: PUSH
31069: EMPTY
31070: LIST
31071: LIST
31072: PUSH
31073: LD_INT 2
31075: PUSH
31076: LD_INT 2
31078: PUSH
31079: EMPTY
31080: LIST
31081: LIST
31082: PUSH
31083: LD_INT 1
31085: PUSH
31086: LD_INT 2
31088: PUSH
31089: EMPTY
31090: LIST
31091: LIST
31092: PUSH
31093: LD_INT 0
31095: PUSH
31096: LD_INT 2
31098: PUSH
31099: EMPTY
31100: LIST
31101: LIST
31102: PUSH
31103: LD_INT 1
31105: NEG
31106: PUSH
31107: LD_INT 1
31109: PUSH
31110: EMPTY
31111: LIST
31112: LIST
31113: PUSH
31114: LD_INT 2
31116: NEG
31117: PUSH
31118: LD_INT 0
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: PUSH
31125: LD_INT 2
31127: NEG
31128: PUSH
31129: LD_INT 1
31131: NEG
31132: PUSH
31133: EMPTY
31134: LIST
31135: LIST
31136: PUSH
31137: LD_INT 2
31139: NEG
31140: PUSH
31141: LD_INT 2
31143: NEG
31144: PUSH
31145: EMPTY
31146: LIST
31147: LIST
31148: PUSH
31149: LD_INT 2
31151: NEG
31152: PUSH
31153: LD_INT 3
31155: NEG
31156: PUSH
31157: EMPTY
31158: LIST
31159: LIST
31160: PUSH
31161: LD_INT 1
31163: NEG
31164: PUSH
31165: LD_INT 3
31167: NEG
31168: PUSH
31169: EMPTY
31170: LIST
31171: LIST
31172: PUSH
31173: LD_INT 3
31175: NEG
31176: PUSH
31177: LD_INT 1
31179: NEG
31180: PUSH
31181: EMPTY
31182: LIST
31183: LIST
31184: PUSH
31185: LD_INT 3
31187: NEG
31188: PUSH
31189: LD_INT 2
31191: NEG
31192: PUSH
31193: EMPTY
31194: LIST
31195: LIST
31196: PUSH
31197: EMPTY
31198: LIST
31199: LIST
31200: LIST
31201: LIST
31202: LIST
31203: LIST
31204: LIST
31205: LIST
31206: LIST
31207: LIST
31208: LIST
31209: LIST
31210: LIST
31211: LIST
31212: LIST
31213: LIST
31214: LIST
31215: LIST
31216: LIST
31217: LIST
31218: LIST
31219: LIST
31220: LIST
31221: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31222: LD_ADDR_VAR 0 29
31226: PUSH
31227: LD_INT 0
31229: PUSH
31230: LD_INT 0
31232: PUSH
31233: EMPTY
31234: LIST
31235: LIST
31236: PUSH
31237: LD_INT 0
31239: PUSH
31240: LD_INT 1
31242: NEG
31243: PUSH
31244: EMPTY
31245: LIST
31246: LIST
31247: PUSH
31248: LD_INT 1
31250: PUSH
31251: LD_INT 0
31253: PUSH
31254: EMPTY
31255: LIST
31256: LIST
31257: PUSH
31258: LD_INT 1
31260: PUSH
31261: LD_INT 1
31263: PUSH
31264: EMPTY
31265: LIST
31266: LIST
31267: PUSH
31268: LD_INT 0
31270: PUSH
31271: LD_INT 1
31273: PUSH
31274: EMPTY
31275: LIST
31276: LIST
31277: PUSH
31278: LD_INT 1
31280: NEG
31281: PUSH
31282: LD_INT 0
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 1
31291: NEG
31292: PUSH
31293: LD_INT 1
31295: NEG
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: PUSH
31301: LD_INT 1
31303: NEG
31304: PUSH
31305: LD_INT 2
31307: NEG
31308: PUSH
31309: EMPTY
31310: LIST
31311: LIST
31312: PUSH
31313: LD_INT 0
31315: PUSH
31316: LD_INT 2
31318: NEG
31319: PUSH
31320: EMPTY
31321: LIST
31322: LIST
31323: PUSH
31324: LD_INT 1
31326: PUSH
31327: LD_INT 1
31329: NEG
31330: PUSH
31331: EMPTY
31332: LIST
31333: LIST
31334: PUSH
31335: LD_INT 2
31337: PUSH
31338: LD_INT 0
31340: PUSH
31341: EMPTY
31342: LIST
31343: LIST
31344: PUSH
31345: LD_INT 2
31347: PUSH
31348: LD_INT 1
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 1
31357: PUSH
31358: LD_INT 2
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: LD_INT 0
31367: PUSH
31368: LD_INT 2
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 1
31377: NEG
31378: PUSH
31379: LD_INT 1
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: LD_INT 2
31388: NEG
31389: PUSH
31390: LD_INT 1
31392: NEG
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PUSH
31398: LD_INT 2
31400: NEG
31401: PUSH
31402: LD_INT 2
31404: NEG
31405: PUSH
31406: EMPTY
31407: LIST
31408: LIST
31409: PUSH
31410: LD_INT 2
31412: NEG
31413: PUSH
31414: LD_INT 3
31416: NEG
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 2
31424: PUSH
31425: LD_INT 1
31427: NEG
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 3
31435: PUSH
31436: LD_INT 1
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 1
31445: PUSH
31446: LD_INT 3
31448: PUSH
31449: EMPTY
31450: LIST
31451: LIST
31452: PUSH
31453: LD_INT 1
31455: NEG
31456: PUSH
31457: LD_INT 2
31459: PUSH
31460: EMPTY
31461: LIST
31462: LIST
31463: PUSH
31464: LD_INT 3
31466: NEG
31467: PUSH
31468: LD_INT 2
31470: NEG
31471: PUSH
31472: EMPTY
31473: LIST
31474: LIST
31475: PUSH
31476: EMPTY
31477: LIST
31478: LIST
31479: LIST
31480: LIST
31481: LIST
31482: LIST
31483: LIST
31484: LIST
31485: LIST
31486: LIST
31487: LIST
31488: LIST
31489: LIST
31490: LIST
31491: LIST
31492: LIST
31493: LIST
31494: LIST
31495: LIST
31496: LIST
31497: LIST
31498: LIST
31499: LIST
31500: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31501: LD_ADDR_VAR 0 30
31505: PUSH
31506: LD_INT 0
31508: PUSH
31509: LD_INT 0
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PUSH
31516: LD_INT 0
31518: PUSH
31519: LD_INT 1
31521: NEG
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: LD_INT 1
31529: PUSH
31530: LD_INT 0
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: LD_INT 1
31539: PUSH
31540: LD_INT 1
31542: PUSH
31543: EMPTY
31544: LIST
31545: LIST
31546: PUSH
31547: LD_INT 0
31549: PUSH
31550: LD_INT 1
31552: PUSH
31553: EMPTY
31554: LIST
31555: LIST
31556: PUSH
31557: LD_INT 1
31559: NEG
31560: PUSH
31561: LD_INT 0
31563: PUSH
31564: EMPTY
31565: LIST
31566: LIST
31567: PUSH
31568: LD_INT 1
31570: NEG
31571: PUSH
31572: LD_INT 1
31574: NEG
31575: PUSH
31576: EMPTY
31577: LIST
31578: LIST
31579: PUSH
31580: LD_INT 1
31582: NEG
31583: PUSH
31584: LD_INT 2
31586: NEG
31587: PUSH
31588: EMPTY
31589: LIST
31590: LIST
31591: PUSH
31592: LD_INT 0
31594: PUSH
31595: LD_INT 2
31597: NEG
31598: PUSH
31599: EMPTY
31600: LIST
31601: LIST
31602: PUSH
31603: LD_INT 1
31605: PUSH
31606: LD_INT 1
31608: NEG
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: LD_INT 2
31616: PUSH
31617: LD_INT 0
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 2
31626: PUSH
31627: LD_INT 1
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: LD_INT 2
31636: PUSH
31637: LD_INT 2
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PUSH
31644: LD_INT 1
31646: PUSH
31647: LD_INT 2
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: LD_INT 1
31656: NEG
31657: PUSH
31658: LD_INT 1
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 2
31667: NEG
31668: PUSH
31669: LD_INT 0
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PUSH
31676: LD_INT 2
31678: NEG
31679: PUSH
31680: LD_INT 1
31682: NEG
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 1
31690: NEG
31691: PUSH
31692: LD_INT 3
31694: NEG
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 1
31702: PUSH
31703: LD_INT 2
31705: NEG
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 3
31713: PUSH
31714: LD_INT 2
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 2
31723: PUSH
31724: LD_INT 3
31726: PUSH
31727: EMPTY
31728: LIST
31729: LIST
31730: PUSH
31731: LD_INT 2
31733: NEG
31734: PUSH
31735: LD_INT 1
31737: PUSH
31738: EMPTY
31739: LIST
31740: LIST
31741: PUSH
31742: LD_INT 3
31744: NEG
31745: PUSH
31746: LD_INT 1
31748: NEG
31749: PUSH
31750: EMPTY
31751: LIST
31752: LIST
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: LIST
31758: LIST
31759: LIST
31760: LIST
31761: LIST
31762: LIST
31763: LIST
31764: LIST
31765: LIST
31766: LIST
31767: LIST
31768: LIST
31769: LIST
31770: LIST
31771: LIST
31772: LIST
31773: LIST
31774: LIST
31775: LIST
31776: LIST
31777: LIST
31778: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31779: LD_ADDR_VAR 0 31
31783: PUSH
31784: LD_INT 0
31786: PUSH
31787: LD_INT 0
31789: PUSH
31790: EMPTY
31791: LIST
31792: LIST
31793: PUSH
31794: LD_INT 0
31796: PUSH
31797: LD_INT 1
31799: NEG
31800: PUSH
31801: EMPTY
31802: LIST
31803: LIST
31804: PUSH
31805: LD_INT 1
31807: PUSH
31808: LD_INT 0
31810: PUSH
31811: EMPTY
31812: LIST
31813: LIST
31814: PUSH
31815: LD_INT 1
31817: PUSH
31818: LD_INT 1
31820: PUSH
31821: EMPTY
31822: LIST
31823: LIST
31824: PUSH
31825: LD_INT 0
31827: PUSH
31828: LD_INT 1
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: PUSH
31835: LD_INT 1
31837: NEG
31838: PUSH
31839: LD_INT 0
31841: PUSH
31842: EMPTY
31843: LIST
31844: LIST
31845: PUSH
31846: LD_INT 1
31848: NEG
31849: PUSH
31850: LD_INT 1
31852: NEG
31853: PUSH
31854: EMPTY
31855: LIST
31856: LIST
31857: PUSH
31858: LD_INT 1
31860: NEG
31861: PUSH
31862: LD_INT 2
31864: NEG
31865: PUSH
31866: EMPTY
31867: LIST
31868: LIST
31869: PUSH
31870: LD_INT 1
31872: PUSH
31873: LD_INT 1
31875: NEG
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: LD_INT 2
31883: PUSH
31884: LD_INT 0
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 2
31893: PUSH
31894: LD_INT 1
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 2
31903: PUSH
31904: LD_INT 2
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 1
31913: PUSH
31914: LD_INT 2
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 0
31923: PUSH
31924: LD_INT 2
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: LD_INT 1
31933: NEG
31934: PUSH
31935: LD_INT 1
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: PUSH
31942: LD_INT 2
31944: NEG
31945: PUSH
31946: LD_INT 1
31948: NEG
31949: PUSH
31950: EMPTY
31951: LIST
31952: LIST
31953: PUSH
31954: LD_INT 2
31956: NEG
31957: PUSH
31958: LD_INT 2
31960: NEG
31961: PUSH
31962: EMPTY
31963: LIST
31964: LIST
31965: PUSH
31966: LD_INT 2
31968: NEG
31969: PUSH
31970: LD_INT 3
31972: NEG
31973: PUSH
31974: EMPTY
31975: LIST
31976: LIST
31977: PUSH
31978: LD_INT 2
31980: PUSH
31981: LD_INT 1
31983: NEG
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 3
31991: PUSH
31992: LD_INT 1
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 1
32001: PUSH
32002: LD_INT 3
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 1
32011: NEG
32012: PUSH
32013: LD_INT 2
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 3
32022: NEG
32023: PUSH
32024: LD_INT 2
32026: NEG
32027: PUSH
32028: EMPTY
32029: LIST
32030: LIST
32031: PUSH
32032: EMPTY
32033: LIST
32034: LIST
32035: LIST
32036: LIST
32037: LIST
32038: LIST
32039: LIST
32040: LIST
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32057: LD_ADDR_VAR 0 32
32061: PUSH
32062: LD_INT 0
32064: PUSH
32065: LD_INT 0
32067: PUSH
32068: EMPTY
32069: LIST
32070: LIST
32071: PUSH
32072: LD_INT 0
32074: PUSH
32075: LD_INT 1
32077: NEG
32078: PUSH
32079: EMPTY
32080: LIST
32081: LIST
32082: PUSH
32083: LD_INT 1
32085: PUSH
32086: LD_INT 0
32088: PUSH
32089: EMPTY
32090: LIST
32091: LIST
32092: PUSH
32093: LD_INT 1
32095: PUSH
32096: LD_INT 1
32098: PUSH
32099: EMPTY
32100: LIST
32101: LIST
32102: PUSH
32103: LD_INT 0
32105: PUSH
32106: LD_INT 1
32108: PUSH
32109: EMPTY
32110: LIST
32111: LIST
32112: PUSH
32113: LD_INT 1
32115: NEG
32116: PUSH
32117: LD_INT 0
32119: PUSH
32120: EMPTY
32121: LIST
32122: LIST
32123: PUSH
32124: LD_INT 1
32126: NEG
32127: PUSH
32128: LD_INT 1
32130: NEG
32131: PUSH
32132: EMPTY
32133: LIST
32134: LIST
32135: PUSH
32136: LD_INT 1
32138: NEG
32139: PUSH
32140: LD_INT 2
32142: NEG
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: LD_INT 0
32150: PUSH
32151: LD_INT 2
32153: NEG
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 1
32161: PUSH
32162: LD_INT 1
32164: NEG
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: LD_INT 2
32172: PUSH
32173: LD_INT 1
32175: PUSH
32176: EMPTY
32177: LIST
32178: LIST
32179: PUSH
32180: LD_INT 2
32182: PUSH
32183: LD_INT 2
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 1
32192: PUSH
32193: LD_INT 2
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 0
32202: PUSH
32203: LD_INT 2
32205: PUSH
32206: EMPTY
32207: LIST
32208: LIST
32209: PUSH
32210: LD_INT 1
32212: NEG
32213: PUSH
32214: LD_INT 1
32216: PUSH
32217: EMPTY
32218: LIST
32219: LIST
32220: PUSH
32221: LD_INT 2
32223: NEG
32224: PUSH
32225: LD_INT 0
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 2
32234: NEG
32235: PUSH
32236: LD_INT 1
32238: NEG
32239: PUSH
32240: EMPTY
32241: LIST
32242: LIST
32243: PUSH
32244: LD_INT 1
32246: NEG
32247: PUSH
32248: LD_INT 3
32250: NEG
32251: PUSH
32252: EMPTY
32253: LIST
32254: LIST
32255: PUSH
32256: LD_INT 1
32258: PUSH
32259: LD_INT 2
32261: NEG
32262: PUSH
32263: EMPTY
32264: LIST
32265: LIST
32266: PUSH
32267: LD_INT 3
32269: PUSH
32270: LD_INT 2
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 2
32279: PUSH
32280: LD_INT 3
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 2
32289: NEG
32290: PUSH
32291: LD_INT 1
32293: PUSH
32294: EMPTY
32295: LIST
32296: LIST
32297: PUSH
32298: LD_INT 3
32300: NEG
32301: PUSH
32302: LD_INT 1
32304: NEG
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: EMPTY
32311: LIST
32312: LIST
32313: LIST
32314: LIST
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: LIST
32320: LIST
32321: LIST
32322: LIST
32323: LIST
32324: LIST
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: LIST
32332: LIST
32333: LIST
32334: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32335: LD_ADDR_VAR 0 33
32339: PUSH
32340: LD_INT 0
32342: PUSH
32343: LD_INT 0
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 0
32352: PUSH
32353: LD_INT 1
32355: NEG
32356: PUSH
32357: EMPTY
32358: LIST
32359: LIST
32360: PUSH
32361: LD_INT 1
32363: PUSH
32364: LD_INT 0
32366: PUSH
32367: EMPTY
32368: LIST
32369: LIST
32370: PUSH
32371: LD_INT 1
32373: PUSH
32374: LD_INT 1
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: PUSH
32381: LD_INT 0
32383: PUSH
32384: LD_INT 1
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: LD_INT 1
32393: NEG
32394: PUSH
32395: LD_INT 0
32397: PUSH
32398: EMPTY
32399: LIST
32400: LIST
32401: PUSH
32402: LD_INT 1
32404: NEG
32405: PUSH
32406: LD_INT 1
32408: NEG
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 1
32416: NEG
32417: PUSH
32418: LD_INT 2
32420: NEG
32421: PUSH
32422: EMPTY
32423: LIST
32424: LIST
32425: PUSH
32426: LD_INT 1
32428: PUSH
32429: LD_INT 1
32431: NEG
32432: PUSH
32433: EMPTY
32434: LIST
32435: LIST
32436: PUSH
32437: LD_INT 2
32439: PUSH
32440: LD_INT 0
32442: PUSH
32443: EMPTY
32444: LIST
32445: LIST
32446: PUSH
32447: LD_INT 2
32449: PUSH
32450: LD_INT 1
32452: PUSH
32453: EMPTY
32454: LIST
32455: LIST
32456: PUSH
32457: LD_INT 1
32459: PUSH
32460: LD_INT 2
32462: PUSH
32463: EMPTY
32464: LIST
32465: LIST
32466: PUSH
32467: LD_INT 0
32469: PUSH
32470: LD_INT 2
32472: PUSH
32473: EMPTY
32474: LIST
32475: LIST
32476: PUSH
32477: LD_INT 1
32479: NEG
32480: PUSH
32481: LD_INT 1
32483: PUSH
32484: EMPTY
32485: LIST
32486: LIST
32487: PUSH
32488: LD_INT 2
32490: NEG
32491: PUSH
32492: LD_INT 0
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: PUSH
32499: LD_INT 2
32501: NEG
32502: PUSH
32503: LD_INT 1
32505: NEG
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 2
32513: NEG
32514: PUSH
32515: LD_INT 2
32517: NEG
32518: PUSH
32519: EMPTY
32520: LIST
32521: LIST
32522: PUSH
32523: LD_INT 2
32525: NEG
32526: PUSH
32527: LD_INT 3
32529: NEG
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 2
32537: PUSH
32538: LD_INT 1
32540: NEG
32541: PUSH
32542: EMPTY
32543: LIST
32544: LIST
32545: PUSH
32546: LD_INT 3
32548: PUSH
32549: LD_INT 1
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: PUSH
32556: LD_INT 1
32558: PUSH
32559: LD_INT 3
32561: PUSH
32562: EMPTY
32563: LIST
32564: LIST
32565: PUSH
32566: LD_INT 1
32568: NEG
32569: PUSH
32570: LD_INT 2
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: PUSH
32577: LD_INT 3
32579: NEG
32580: PUSH
32581: LD_INT 2
32583: NEG
32584: PUSH
32585: EMPTY
32586: LIST
32587: LIST
32588: PUSH
32589: EMPTY
32590: LIST
32591: LIST
32592: LIST
32593: LIST
32594: LIST
32595: LIST
32596: LIST
32597: LIST
32598: LIST
32599: LIST
32600: LIST
32601: LIST
32602: LIST
32603: LIST
32604: LIST
32605: LIST
32606: LIST
32607: LIST
32608: LIST
32609: LIST
32610: LIST
32611: LIST
32612: LIST
32613: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32614: LD_ADDR_VAR 0 34
32618: PUSH
32619: LD_INT 0
32621: PUSH
32622: LD_INT 0
32624: PUSH
32625: EMPTY
32626: LIST
32627: LIST
32628: PUSH
32629: LD_INT 0
32631: PUSH
32632: LD_INT 1
32634: NEG
32635: PUSH
32636: EMPTY
32637: LIST
32638: LIST
32639: PUSH
32640: LD_INT 1
32642: PUSH
32643: LD_INT 0
32645: PUSH
32646: EMPTY
32647: LIST
32648: LIST
32649: PUSH
32650: LD_INT 1
32652: PUSH
32653: LD_INT 1
32655: PUSH
32656: EMPTY
32657: LIST
32658: LIST
32659: PUSH
32660: LD_INT 0
32662: PUSH
32663: LD_INT 1
32665: PUSH
32666: EMPTY
32667: LIST
32668: LIST
32669: PUSH
32670: LD_INT 1
32672: NEG
32673: PUSH
32674: LD_INT 0
32676: PUSH
32677: EMPTY
32678: LIST
32679: LIST
32680: PUSH
32681: LD_INT 1
32683: NEG
32684: PUSH
32685: LD_INT 1
32687: NEG
32688: PUSH
32689: EMPTY
32690: LIST
32691: LIST
32692: PUSH
32693: LD_INT 1
32695: NEG
32696: PUSH
32697: LD_INT 2
32699: NEG
32700: PUSH
32701: EMPTY
32702: LIST
32703: LIST
32704: PUSH
32705: LD_INT 0
32707: PUSH
32708: LD_INT 2
32710: NEG
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: PUSH
32716: LD_INT 1
32718: PUSH
32719: LD_INT 1
32721: NEG
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: LD_INT 2
32729: PUSH
32730: LD_INT 1
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 2
32739: PUSH
32740: LD_INT 2
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 1
32749: PUSH
32750: LD_INT 2
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: LD_INT 1
32759: NEG
32760: PUSH
32761: LD_INT 1
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PUSH
32768: LD_INT 2
32770: NEG
32771: PUSH
32772: LD_INT 0
32774: PUSH
32775: EMPTY
32776: LIST
32777: LIST
32778: PUSH
32779: LD_INT 2
32781: NEG
32782: PUSH
32783: LD_INT 1
32785: NEG
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: PUSH
32791: LD_INT 2
32793: NEG
32794: PUSH
32795: LD_INT 2
32797: NEG
32798: PUSH
32799: EMPTY
32800: LIST
32801: LIST
32802: PUSH
32803: LD_INT 1
32805: NEG
32806: PUSH
32807: LD_INT 3
32809: NEG
32810: PUSH
32811: EMPTY
32812: LIST
32813: LIST
32814: PUSH
32815: LD_INT 1
32817: PUSH
32818: LD_INT 2
32820: NEG
32821: PUSH
32822: EMPTY
32823: LIST
32824: LIST
32825: PUSH
32826: LD_INT 3
32828: PUSH
32829: LD_INT 2
32831: PUSH
32832: EMPTY
32833: LIST
32834: LIST
32835: PUSH
32836: LD_INT 2
32838: PUSH
32839: LD_INT 3
32841: PUSH
32842: EMPTY
32843: LIST
32844: LIST
32845: PUSH
32846: LD_INT 2
32848: NEG
32849: PUSH
32850: LD_INT 1
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 3
32859: NEG
32860: PUSH
32861: LD_INT 1
32863: NEG
32864: PUSH
32865: EMPTY
32866: LIST
32867: LIST
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: LIST
32893: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
32894: LD_ADDR_VAR 0 35
32898: PUSH
32899: LD_INT 0
32901: PUSH
32902: LD_INT 0
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 0
32911: PUSH
32912: LD_INT 1
32914: NEG
32915: PUSH
32916: EMPTY
32917: LIST
32918: LIST
32919: PUSH
32920: LD_INT 1
32922: PUSH
32923: LD_INT 0
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PUSH
32930: LD_INT 1
32932: PUSH
32933: LD_INT 1
32935: PUSH
32936: EMPTY
32937: LIST
32938: LIST
32939: PUSH
32940: LD_INT 0
32942: PUSH
32943: LD_INT 1
32945: PUSH
32946: EMPTY
32947: LIST
32948: LIST
32949: PUSH
32950: LD_INT 1
32952: NEG
32953: PUSH
32954: LD_INT 0
32956: PUSH
32957: EMPTY
32958: LIST
32959: LIST
32960: PUSH
32961: LD_INT 1
32963: NEG
32964: PUSH
32965: LD_INT 1
32967: NEG
32968: PUSH
32969: EMPTY
32970: LIST
32971: LIST
32972: PUSH
32973: LD_INT 2
32975: PUSH
32976: LD_INT 1
32978: PUSH
32979: EMPTY
32980: LIST
32981: LIST
32982: PUSH
32983: LD_INT 2
32985: NEG
32986: PUSH
32987: LD_INT 1
32989: NEG
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: EMPTY
32996: LIST
32997: LIST
32998: LIST
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: LIST
33004: LIST
33005: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33006: LD_ADDR_VAR 0 36
33010: PUSH
33011: LD_INT 0
33013: PUSH
33014: LD_INT 0
33016: PUSH
33017: EMPTY
33018: LIST
33019: LIST
33020: PUSH
33021: LD_INT 0
33023: PUSH
33024: LD_INT 1
33026: NEG
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PUSH
33032: LD_INT 1
33034: PUSH
33035: LD_INT 0
33037: PUSH
33038: EMPTY
33039: LIST
33040: LIST
33041: PUSH
33042: LD_INT 1
33044: PUSH
33045: LD_INT 1
33047: PUSH
33048: EMPTY
33049: LIST
33050: LIST
33051: PUSH
33052: LD_INT 0
33054: PUSH
33055: LD_INT 1
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 1
33064: NEG
33065: PUSH
33066: LD_INT 0
33068: PUSH
33069: EMPTY
33070: LIST
33071: LIST
33072: PUSH
33073: LD_INT 1
33075: NEG
33076: PUSH
33077: LD_INT 1
33079: NEG
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: LD_INT 1
33087: NEG
33088: PUSH
33089: LD_INT 2
33091: NEG
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: LD_INT 1
33099: PUSH
33100: LD_INT 2
33102: PUSH
33103: EMPTY
33104: LIST
33105: LIST
33106: PUSH
33107: EMPTY
33108: LIST
33109: LIST
33110: LIST
33111: LIST
33112: LIST
33113: LIST
33114: LIST
33115: LIST
33116: LIST
33117: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33118: LD_ADDR_VAR 0 37
33122: PUSH
33123: LD_INT 0
33125: PUSH
33126: LD_INT 0
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: PUSH
33133: LD_INT 0
33135: PUSH
33136: LD_INT 1
33138: NEG
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: LD_INT 1
33146: PUSH
33147: LD_INT 0
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: PUSH
33154: LD_INT 1
33156: PUSH
33157: LD_INT 1
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: PUSH
33164: LD_INT 0
33166: PUSH
33167: LD_INT 1
33169: PUSH
33170: EMPTY
33171: LIST
33172: LIST
33173: PUSH
33174: LD_INT 1
33176: NEG
33177: PUSH
33178: LD_INT 0
33180: PUSH
33181: EMPTY
33182: LIST
33183: LIST
33184: PUSH
33185: LD_INT 1
33187: NEG
33188: PUSH
33189: LD_INT 1
33191: NEG
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 1
33199: PUSH
33200: LD_INT 1
33202: NEG
33203: PUSH
33204: EMPTY
33205: LIST
33206: LIST
33207: PUSH
33208: LD_INT 1
33210: NEG
33211: PUSH
33212: LD_INT 1
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: EMPTY
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33230: LD_ADDR_VAR 0 38
33234: PUSH
33235: LD_INT 0
33237: PUSH
33238: LD_INT 0
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 0
33247: PUSH
33248: LD_INT 1
33250: NEG
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 1
33258: PUSH
33259: LD_INT 0
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 1
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 0
33278: PUSH
33279: LD_INT 1
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 1
33288: NEG
33289: PUSH
33290: LD_INT 0
33292: PUSH
33293: EMPTY
33294: LIST
33295: LIST
33296: PUSH
33297: LD_INT 1
33299: NEG
33300: PUSH
33301: LD_INT 1
33303: NEG
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: LD_INT 2
33311: PUSH
33312: LD_INT 1
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 2
33321: NEG
33322: PUSH
33323: LD_INT 1
33325: NEG
33326: PUSH
33327: EMPTY
33328: LIST
33329: LIST
33330: PUSH
33331: EMPTY
33332: LIST
33333: LIST
33334: LIST
33335: LIST
33336: LIST
33337: LIST
33338: LIST
33339: LIST
33340: LIST
33341: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33342: LD_ADDR_VAR 0 39
33346: PUSH
33347: LD_INT 0
33349: PUSH
33350: LD_INT 0
33352: PUSH
33353: EMPTY
33354: LIST
33355: LIST
33356: PUSH
33357: LD_INT 0
33359: PUSH
33360: LD_INT 1
33362: NEG
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 1
33370: PUSH
33371: LD_INT 0
33373: PUSH
33374: EMPTY
33375: LIST
33376: LIST
33377: PUSH
33378: LD_INT 1
33380: PUSH
33381: LD_INT 1
33383: PUSH
33384: EMPTY
33385: LIST
33386: LIST
33387: PUSH
33388: LD_INT 0
33390: PUSH
33391: LD_INT 1
33393: PUSH
33394: EMPTY
33395: LIST
33396: LIST
33397: PUSH
33398: LD_INT 1
33400: NEG
33401: PUSH
33402: LD_INT 0
33404: PUSH
33405: EMPTY
33406: LIST
33407: LIST
33408: PUSH
33409: LD_INT 1
33411: NEG
33412: PUSH
33413: LD_INT 1
33415: NEG
33416: PUSH
33417: EMPTY
33418: LIST
33419: LIST
33420: PUSH
33421: LD_INT 1
33423: NEG
33424: PUSH
33425: LD_INT 2
33427: NEG
33428: PUSH
33429: EMPTY
33430: LIST
33431: LIST
33432: PUSH
33433: LD_INT 1
33435: PUSH
33436: LD_INT 2
33438: PUSH
33439: EMPTY
33440: LIST
33441: LIST
33442: PUSH
33443: EMPTY
33444: LIST
33445: LIST
33446: LIST
33447: LIST
33448: LIST
33449: LIST
33450: LIST
33451: LIST
33452: LIST
33453: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33454: LD_ADDR_VAR 0 40
33458: PUSH
33459: LD_INT 0
33461: PUSH
33462: LD_INT 0
33464: PUSH
33465: EMPTY
33466: LIST
33467: LIST
33468: PUSH
33469: LD_INT 0
33471: PUSH
33472: LD_INT 1
33474: NEG
33475: PUSH
33476: EMPTY
33477: LIST
33478: LIST
33479: PUSH
33480: LD_INT 1
33482: PUSH
33483: LD_INT 0
33485: PUSH
33486: EMPTY
33487: LIST
33488: LIST
33489: PUSH
33490: LD_INT 1
33492: PUSH
33493: LD_INT 1
33495: PUSH
33496: EMPTY
33497: LIST
33498: LIST
33499: PUSH
33500: LD_INT 0
33502: PUSH
33503: LD_INT 1
33505: PUSH
33506: EMPTY
33507: LIST
33508: LIST
33509: PUSH
33510: LD_INT 1
33512: NEG
33513: PUSH
33514: LD_INT 0
33516: PUSH
33517: EMPTY
33518: LIST
33519: LIST
33520: PUSH
33521: LD_INT 1
33523: NEG
33524: PUSH
33525: LD_INT 1
33527: NEG
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: PUSH
33533: LD_INT 1
33535: PUSH
33536: LD_INT 1
33538: NEG
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: PUSH
33544: LD_INT 1
33546: NEG
33547: PUSH
33548: LD_INT 1
33550: PUSH
33551: EMPTY
33552: LIST
33553: LIST
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: LIST
33559: LIST
33560: LIST
33561: LIST
33562: LIST
33563: LIST
33564: LIST
33565: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33566: LD_ADDR_VAR 0 41
33570: PUSH
33571: LD_INT 0
33573: PUSH
33574: LD_INT 0
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: LD_INT 0
33583: PUSH
33584: LD_INT 1
33586: NEG
33587: PUSH
33588: EMPTY
33589: LIST
33590: LIST
33591: PUSH
33592: LD_INT 1
33594: PUSH
33595: LD_INT 0
33597: PUSH
33598: EMPTY
33599: LIST
33600: LIST
33601: PUSH
33602: LD_INT 1
33604: PUSH
33605: LD_INT 1
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 0
33614: PUSH
33615: LD_INT 1
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: PUSH
33622: LD_INT 1
33624: NEG
33625: PUSH
33626: LD_INT 0
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PUSH
33633: LD_INT 1
33635: NEG
33636: PUSH
33637: LD_INT 1
33639: NEG
33640: PUSH
33641: EMPTY
33642: LIST
33643: LIST
33644: PUSH
33645: LD_INT 1
33647: NEG
33648: PUSH
33649: LD_INT 2
33651: NEG
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 1
33659: PUSH
33660: LD_INT 1
33662: NEG
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 2
33670: PUSH
33671: LD_INT 0
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: LD_INT 2
33680: PUSH
33681: LD_INT 1
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 2
33690: PUSH
33691: LD_INT 2
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 1
33700: PUSH
33701: LD_INT 2
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: PUSH
33708: LD_INT 1
33710: NEG
33711: PUSH
33712: LD_INT 1
33714: PUSH
33715: EMPTY
33716: LIST
33717: LIST
33718: PUSH
33719: LD_INT 2
33721: NEG
33722: PUSH
33723: LD_INT 0
33725: PUSH
33726: EMPTY
33727: LIST
33728: LIST
33729: PUSH
33730: LD_INT 2
33732: NEG
33733: PUSH
33734: LD_INT 1
33736: NEG
33737: PUSH
33738: EMPTY
33739: LIST
33740: LIST
33741: PUSH
33742: LD_INT 2
33744: NEG
33745: PUSH
33746: LD_INT 2
33748: NEG
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: LD_INT 2
33756: NEG
33757: PUSH
33758: LD_INT 3
33760: NEG
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PUSH
33766: LD_INT 2
33768: PUSH
33769: LD_INT 1
33771: NEG
33772: PUSH
33773: EMPTY
33774: LIST
33775: LIST
33776: PUSH
33777: LD_INT 3
33779: PUSH
33780: LD_INT 0
33782: PUSH
33783: EMPTY
33784: LIST
33785: LIST
33786: PUSH
33787: LD_INT 3
33789: PUSH
33790: LD_INT 1
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 3
33799: PUSH
33800: LD_INT 2
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: LD_INT 3
33809: PUSH
33810: LD_INT 3
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 2
33819: PUSH
33820: LD_INT 3
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 2
33829: NEG
33830: PUSH
33831: LD_INT 1
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 3
33840: NEG
33841: PUSH
33842: LD_INT 0
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 3
33851: NEG
33852: PUSH
33853: LD_INT 1
33855: NEG
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 3
33863: NEG
33864: PUSH
33865: LD_INT 2
33867: NEG
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: PUSH
33873: LD_INT 3
33875: NEG
33876: PUSH
33877: LD_INT 3
33879: NEG
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: EMPTY
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: LIST
33892: LIST
33893: LIST
33894: LIST
33895: LIST
33896: LIST
33897: LIST
33898: LIST
33899: LIST
33900: LIST
33901: LIST
33902: LIST
33903: LIST
33904: LIST
33905: LIST
33906: LIST
33907: LIST
33908: LIST
33909: LIST
33910: LIST
33911: LIST
33912: LIST
33913: LIST
33914: LIST
33915: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33916: LD_ADDR_VAR 0 42
33920: PUSH
33921: LD_INT 0
33923: PUSH
33924: LD_INT 0
33926: PUSH
33927: EMPTY
33928: LIST
33929: LIST
33930: PUSH
33931: LD_INT 0
33933: PUSH
33934: LD_INT 1
33936: NEG
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 1
33944: PUSH
33945: LD_INT 0
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: LD_INT 1
33954: PUSH
33955: LD_INT 1
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 0
33964: PUSH
33965: LD_INT 1
33967: PUSH
33968: EMPTY
33969: LIST
33970: LIST
33971: PUSH
33972: LD_INT 1
33974: NEG
33975: PUSH
33976: LD_INT 0
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 1
33985: NEG
33986: PUSH
33987: LD_INT 1
33989: NEG
33990: PUSH
33991: EMPTY
33992: LIST
33993: LIST
33994: PUSH
33995: LD_INT 1
33997: NEG
33998: PUSH
33999: LD_INT 2
34001: NEG
34002: PUSH
34003: EMPTY
34004: LIST
34005: LIST
34006: PUSH
34007: LD_INT 0
34009: PUSH
34010: LD_INT 2
34012: NEG
34013: PUSH
34014: EMPTY
34015: LIST
34016: LIST
34017: PUSH
34018: LD_INT 1
34020: PUSH
34021: LD_INT 1
34023: NEG
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: PUSH
34029: LD_INT 2
34031: PUSH
34032: LD_INT 1
34034: PUSH
34035: EMPTY
34036: LIST
34037: LIST
34038: PUSH
34039: LD_INT 2
34041: PUSH
34042: LD_INT 2
34044: PUSH
34045: EMPTY
34046: LIST
34047: LIST
34048: PUSH
34049: LD_INT 1
34051: PUSH
34052: LD_INT 2
34054: PUSH
34055: EMPTY
34056: LIST
34057: LIST
34058: PUSH
34059: LD_INT 0
34061: PUSH
34062: LD_INT 2
34064: PUSH
34065: EMPTY
34066: LIST
34067: LIST
34068: PUSH
34069: LD_INT 1
34071: NEG
34072: PUSH
34073: LD_INT 1
34075: PUSH
34076: EMPTY
34077: LIST
34078: LIST
34079: PUSH
34080: LD_INT 2
34082: NEG
34083: PUSH
34084: LD_INT 1
34086: NEG
34087: PUSH
34088: EMPTY
34089: LIST
34090: LIST
34091: PUSH
34092: LD_INT 2
34094: NEG
34095: PUSH
34096: LD_INT 2
34098: NEG
34099: PUSH
34100: EMPTY
34101: LIST
34102: LIST
34103: PUSH
34104: LD_INT 2
34106: NEG
34107: PUSH
34108: LD_INT 3
34110: NEG
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: LD_INT 3
34122: NEG
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 0
34130: PUSH
34131: LD_INT 3
34133: NEG
34134: PUSH
34135: EMPTY
34136: LIST
34137: LIST
34138: PUSH
34139: LD_INT 1
34141: PUSH
34142: LD_INT 2
34144: NEG
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: LD_INT 3
34152: PUSH
34153: LD_INT 2
34155: PUSH
34156: EMPTY
34157: LIST
34158: LIST
34159: PUSH
34160: LD_INT 3
34162: PUSH
34163: LD_INT 3
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 2
34172: PUSH
34173: LD_INT 3
34175: PUSH
34176: EMPTY
34177: LIST
34178: LIST
34179: PUSH
34180: LD_INT 1
34182: PUSH
34183: LD_INT 3
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: PUSH
34190: LD_INT 0
34192: PUSH
34193: LD_INT 3
34195: PUSH
34196: EMPTY
34197: LIST
34198: LIST
34199: PUSH
34200: LD_INT 1
34202: NEG
34203: PUSH
34204: LD_INT 2
34206: PUSH
34207: EMPTY
34208: LIST
34209: LIST
34210: PUSH
34211: LD_INT 3
34213: NEG
34214: PUSH
34215: LD_INT 2
34217: NEG
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 3
34225: NEG
34226: PUSH
34227: LD_INT 3
34229: NEG
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: LIST
34242: LIST
34243: LIST
34244: LIST
34245: LIST
34246: LIST
34247: LIST
34248: LIST
34249: LIST
34250: LIST
34251: LIST
34252: LIST
34253: LIST
34254: LIST
34255: LIST
34256: LIST
34257: LIST
34258: LIST
34259: LIST
34260: LIST
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34266: LD_ADDR_VAR 0 43
34270: PUSH
34271: LD_INT 0
34273: PUSH
34274: LD_INT 0
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 0
34283: PUSH
34284: LD_INT 1
34286: NEG
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: PUSH
34292: LD_INT 1
34294: PUSH
34295: LD_INT 0
34297: PUSH
34298: EMPTY
34299: LIST
34300: LIST
34301: PUSH
34302: LD_INT 1
34304: PUSH
34305: LD_INT 1
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: PUSH
34312: LD_INT 0
34314: PUSH
34315: LD_INT 1
34317: PUSH
34318: EMPTY
34319: LIST
34320: LIST
34321: PUSH
34322: LD_INT 1
34324: NEG
34325: PUSH
34326: LD_INT 0
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 1
34335: NEG
34336: PUSH
34337: LD_INT 1
34339: NEG
34340: PUSH
34341: EMPTY
34342: LIST
34343: LIST
34344: PUSH
34345: LD_INT 1
34347: NEG
34348: PUSH
34349: LD_INT 2
34351: NEG
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 0
34359: PUSH
34360: LD_INT 2
34362: NEG
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 1
34370: PUSH
34371: LD_INT 1
34373: NEG
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: PUSH
34379: LD_INT 2
34381: PUSH
34382: LD_INT 0
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: LD_INT 2
34391: PUSH
34392: LD_INT 1
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 1
34401: PUSH
34402: LD_INT 2
34404: PUSH
34405: EMPTY
34406: LIST
34407: LIST
34408: PUSH
34409: LD_INT 0
34411: PUSH
34412: LD_INT 2
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 1
34421: NEG
34422: PUSH
34423: LD_INT 1
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: PUSH
34430: LD_INT 2
34432: NEG
34433: PUSH
34434: LD_INT 0
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 2
34443: NEG
34444: PUSH
34445: LD_INT 1
34447: NEG
34448: PUSH
34449: EMPTY
34450: LIST
34451: LIST
34452: PUSH
34453: LD_INT 1
34455: NEG
34456: PUSH
34457: LD_INT 3
34459: NEG
34460: PUSH
34461: EMPTY
34462: LIST
34463: LIST
34464: PUSH
34465: LD_INT 0
34467: PUSH
34468: LD_INT 3
34470: NEG
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 1
34478: PUSH
34479: LD_INT 2
34481: NEG
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: PUSH
34487: LD_INT 2
34489: PUSH
34490: LD_INT 1
34492: NEG
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: LD_INT 3
34500: PUSH
34501: LD_INT 0
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 3
34510: PUSH
34511: LD_INT 1
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: LD_INT 1
34520: PUSH
34521: LD_INT 3
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: LD_INT 0
34530: PUSH
34531: LD_INT 3
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 1
34540: NEG
34541: PUSH
34542: LD_INT 2
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 2
34551: NEG
34552: PUSH
34553: LD_INT 1
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 3
34562: NEG
34563: PUSH
34564: LD_INT 0
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: LD_INT 3
34573: NEG
34574: PUSH
34575: LD_INT 1
34577: NEG
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PUSH
34583: EMPTY
34584: LIST
34585: LIST
34586: LIST
34587: LIST
34588: LIST
34589: LIST
34590: LIST
34591: LIST
34592: LIST
34593: LIST
34594: LIST
34595: LIST
34596: LIST
34597: LIST
34598: LIST
34599: LIST
34600: LIST
34601: LIST
34602: LIST
34603: LIST
34604: LIST
34605: LIST
34606: LIST
34607: LIST
34608: LIST
34609: LIST
34610: LIST
34611: LIST
34612: LIST
34613: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34614: LD_ADDR_VAR 0 44
34618: PUSH
34619: LD_INT 0
34621: PUSH
34622: LD_INT 0
34624: PUSH
34625: EMPTY
34626: LIST
34627: LIST
34628: PUSH
34629: LD_INT 0
34631: PUSH
34632: LD_INT 1
34634: NEG
34635: PUSH
34636: EMPTY
34637: LIST
34638: LIST
34639: PUSH
34640: LD_INT 1
34642: PUSH
34643: LD_INT 0
34645: PUSH
34646: EMPTY
34647: LIST
34648: LIST
34649: PUSH
34650: LD_INT 1
34652: PUSH
34653: LD_INT 1
34655: PUSH
34656: EMPTY
34657: LIST
34658: LIST
34659: PUSH
34660: LD_INT 0
34662: PUSH
34663: LD_INT 1
34665: PUSH
34666: EMPTY
34667: LIST
34668: LIST
34669: PUSH
34670: LD_INT 1
34672: NEG
34673: PUSH
34674: LD_INT 0
34676: PUSH
34677: EMPTY
34678: LIST
34679: LIST
34680: PUSH
34681: LD_INT 1
34683: NEG
34684: PUSH
34685: LD_INT 1
34687: NEG
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 1
34695: NEG
34696: PUSH
34697: LD_INT 2
34699: NEG
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 1
34707: PUSH
34708: LD_INT 1
34710: NEG
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: LD_INT 2
34718: PUSH
34719: LD_INT 0
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PUSH
34726: LD_INT 2
34728: PUSH
34729: LD_INT 1
34731: PUSH
34732: EMPTY
34733: LIST
34734: LIST
34735: PUSH
34736: LD_INT 2
34738: PUSH
34739: LD_INT 2
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: LD_INT 1
34748: PUSH
34749: LD_INT 2
34751: PUSH
34752: EMPTY
34753: LIST
34754: LIST
34755: PUSH
34756: LD_INT 1
34758: NEG
34759: PUSH
34760: LD_INT 1
34762: PUSH
34763: EMPTY
34764: LIST
34765: LIST
34766: PUSH
34767: LD_INT 2
34769: NEG
34770: PUSH
34771: LD_INT 0
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: PUSH
34778: LD_INT 2
34780: NEG
34781: PUSH
34782: LD_INT 1
34784: NEG
34785: PUSH
34786: EMPTY
34787: LIST
34788: LIST
34789: PUSH
34790: LD_INT 2
34792: NEG
34793: PUSH
34794: LD_INT 2
34796: NEG
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: PUSH
34802: LD_INT 2
34804: NEG
34805: PUSH
34806: LD_INT 3
34808: NEG
34809: PUSH
34810: EMPTY
34811: LIST
34812: LIST
34813: PUSH
34814: LD_INT 2
34816: PUSH
34817: LD_INT 1
34819: NEG
34820: PUSH
34821: EMPTY
34822: LIST
34823: LIST
34824: PUSH
34825: LD_INT 3
34827: PUSH
34828: LD_INT 0
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PUSH
34835: LD_INT 3
34837: PUSH
34838: LD_INT 1
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: PUSH
34845: LD_INT 3
34847: PUSH
34848: LD_INT 2
34850: PUSH
34851: EMPTY
34852: LIST
34853: LIST
34854: PUSH
34855: LD_INT 3
34857: PUSH
34858: LD_INT 3
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: PUSH
34865: LD_INT 2
34867: PUSH
34868: LD_INT 3
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 2
34877: NEG
34878: PUSH
34879: LD_INT 1
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: PUSH
34886: LD_INT 3
34888: NEG
34889: PUSH
34890: LD_INT 0
34892: PUSH
34893: EMPTY
34894: LIST
34895: LIST
34896: PUSH
34897: LD_INT 3
34899: NEG
34900: PUSH
34901: LD_INT 1
34903: NEG
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: PUSH
34909: LD_INT 3
34911: NEG
34912: PUSH
34913: LD_INT 2
34915: NEG
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: PUSH
34921: LD_INT 3
34923: NEG
34924: PUSH
34925: LD_INT 3
34927: NEG
34928: PUSH
34929: EMPTY
34930: LIST
34931: LIST
34932: PUSH
34933: EMPTY
34934: LIST
34935: LIST
34936: LIST
34937: LIST
34938: LIST
34939: LIST
34940: LIST
34941: LIST
34942: LIST
34943: LIST
34944: LIST
34945: LIST
34946: LIST
34947: LIST
34948: LIST
34949: LIST
34950: LIST
34951: LIST
34952: LIST
34953: LIST
34954: LIST
34955: LIST
34956: LIST
34957: LIST
34958: LIST
34959: LIST
34960: LIST
34961: LIST
34962: LIST
34963: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34964: LD_ADDR_VAR 0 45
34968: PUSH
34969: LD_INT 0
34971: PUSH
34972: LD_INT 0
34974: PUSH
34975: EMPTY
34976: LIST
34977: LIST
34978: PUSH
34979: LD_INT 0
34981: PUSH
34982: LD_INT 1
34984: NEG
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: PUSH
34990: LD_INT 1
34992: PUSH
34993: LD_INT 0
34995: PUSH
34996: EMPTY
34997: LIST
34998: LIST
34999: PUSH
35000: LD_INT 1
35002: PUSH
35003: LD_INT 1
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: LD_INT 0
35012: PUSH
35013: LD_INT 1
35015: PUSH
35016: EMPTY
35017: LIST
35018: LIST
35019: PUSH
35020: LD_INT 1
35022: NEG
35023: PUSH
35024: LD_INT 0
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 1
35033: NEG
35034: PUSH
35035: LD_INT 1
35037: NEG
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 1
35045: NEG
35046: PUSH
35047: LD_INT 2
35049: NEG
35050: PUSH
35051: EMPTY
35052: LIST
35053: LIST
35054: PUSH
35055: LD_INT 0
35057: PUSH
35058: LD_INT 2
35060: NEG
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: PUSH
35066: LD_INT 1
35068: PUSH
35069: LD_INT 1
35071: NEG
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 2
35079: PUSH
35080: LD_INT 1
35082: PUSH
35083: EMPTY
35084: LIST
35085: LIST
35086: PUSH
35087: LD_INT 2
35089: PUSH
35090: LD_INT 2
35092: PUSH
35093: EMPTY
35094: LIST
35095: LIST
35096: PUSH
35097: LD_INT 1
35099: PUSH
35100: LD_INT 2
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 0
35109: PUSH
35110: LD_INT 2
35112: PUSH
35113: EMPTY
35114: LIST
35115: LIST
35116: PUSH
35117: LD_INT 1
35119: NEG
35120: PUSH
35121: LD_INT 1
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 2
35130: NEG
35131: PUSH
35132: LD_INT 1
35134: NEG
35135: PUSH
35136: EMPTY
35137: LIST
35138: LIST
35139: PUSH
35140: LD_INT 2
35142: NEG
35143: PUSH
35144: LD_INT 2
35146: NEG
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 2
35154: NEG
35155: PUSH
35156: LD_INT 3
35158: NEG
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 1
35166: NEG
35167: PUSH
35168: LD_INT 3
35170: NEG
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: PUSH
35176: LD_INT 0
35178: PUSH
35179: LD_INT 3
35181: NEG
35182: PUSH
35183: EMPTY
35184: LIST
35185: LIST
35186: PUSH
35187: LD_INT 1
35189: PUSH
35190: LD_INT 2
35192: NEG
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 3
35200: PUSH
35201: LD_INT 2
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 3
35210: PUSH
35211: LD_INT 3
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 2
35220: PUSH
35221: LD_INT 3
35223: PUSH
35224: EMPTY
35225: LIST
35226: LIST
35227: PUSH
35228: LD_INT 1
35230: PUSH
35231: LD_INT 3
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PUSH
35238: LD_INT 0
35240: PUSH
35241: LD_INT 3
35243: PUSH
35244: EMPTY
35245: LIST
35246: LIST
35247: PUSH
35248: LD_INT 1
35250: NEG
35251: PUSH
35252: LD_INT 2
35254: PUSH
35255: EMPTY
35256: LIST
35257: LIST
35258: PUSH
35259: LD_INT 3
35261: NEG
35262: PUSH
35263: LD_INT 2
35265: NEG
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: PUSH
35271: LD_INT 3
35273: NEG
35274: PUSH
35275: LD_INT 3
35277: NEG
35278: PUSH
35279: EMPTY
35280: LIST
35281: LIST
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: LIST
35299: LIST
35300: LIST
35301: LIST
35302: LIST
35303: LIST
35304: LIST
35305: LIST
35306: LIST
35307: LIST
35308: LIST
35309: LIST
35310: LIST
35311: LIST
35312: LIST
35313: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35314: LD_ADDR_VAR 0 46
35318: PUSH
35319: LD_INT 0
35321: PUSH
35322: LD_INT 0
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PUSH
35329: LD_INT 0
35331: PUSH
35332: LD_INT 1
35334: NEG
35335: PUSH
35336: EMPTY
35337: LIST
35338: LIST
35339: PUSH
35340: LD_INT 1
35342: PUSH
35343: LD_INT 0
35345: PUSH
35346: EMPTY
35347: LIST
35348: LIST
35349: PUSH
35350: LD_INT 1
35352: PUSH
35353: LD_INT 1
35355: PUSH
35356: EMPTY
35357: LIST
35358: LIST
35359: PUSH
35360: LD_INT 0
35362: PUSH
35363: LD_INT 1
35365: PUSH
35366: EMPTY
35367: LIST
35368: LIST
35369: PUSH
35370: LD_INT 1
35372: NEG
35373: PUSH
35374: LD_INT 0
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: PUSH
35381: LD_INT 1
35383: NEG
35384: PUSH
35385: LD_INT 1
35387: NEG
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: LD_INT 1
35395: NEG
35396: PUSH
35397: LD_INT 2
35399: NEG
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: PUSH
35405: LD_INT 0
35407: PUSH
35408: LD_INT 2
35410: NEG
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: PUSH
35416: LD_INT 1
35418: PUSH
35419: LD_INT 1
35421: NEG
35422: PUSH
35423: EMPTY
35424: LIST
35425: LIST
35426: PUSH
35427: LD_INT 2
35429: PUSH
35430: LD_INT 0
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 2
35439: PUSH
35440: LD_INT 1
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: LD_INT 1
35449: PUSH
35450: LD_INT 2
35452: PUSH
35453: EMPTY
35454: LIST
35455: LIST
35456: PUSH
35457: LD_INT 0
35459: PUSH
35460: LD_INT 2
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PUSH
35467: LD_INT 1
35469: NEG
35470: PUSH
35471: LD_INT 1
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: PUSH
35478: LD_INT 2
35480: NEG
35481: PUSH
35482: LD_INT 0
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 2
35491: NEG
35492: PUSH
35493: LD_INT 1
35495: NEG
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 1
35503: NEG
35504: PUSH
35505: LD_INT 3
35507: NEG
35508: PUSH
35509: EMPTY
35510: LIST
35511: LIST
35512: PUSH
35513: LD_INT 0
35515: PUSH
35516: LD_INT 3
35518: NEG
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 1
35526: PUSH
35527: LD_INT 2
35529: NEG
35530: PUSH
35531: EMPTY
35532: LIST
35533: LIST
35534: PUSH
35535: LD_INT 2
35537: PUSH
35538: LD_INT 1
35540: NEG
35541: PUSH
35542: EMPTY
35543: LIST
35544: LIST
35545: PUSH
35546: LD_INT 3
35548: PUSH
35549: LD_INT 0
35551: PUSH
35552: EMPTY
35553: LIST
35554: LIST
35555: PUSH
35556: LD_INT 3
35558: PUSH
35559: LD_INT 1
35561: PUSH
35562: EMPTY
35563: LIST
35564: LIST
35565: PUSH
35566: LD_INT 1
35568: PUSH
35569: LD_INT 3
35571: PUSH
35572: EMPTY
35573: LIST
35574: LIST
35575: PUSH
35576: LD_INT 0
35578: PUSH
35579: LD_INT 3
35581: PUSH
35582: EMPTY
35583: LIST
35584: LIST
35585: PUSH
35586: LD_INT 1
35588: NEG
35589: PUSH
35590: LD_INT 2
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: PUSH
35597: LD_INT 2
35599: NEG
35600: PUSH
35601: LD_INT 1
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 3
35610: NEG
35611: PUSH
35612: LD_INT 0
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 3
35621: NEG
35622: PUSH
35623: LD_INT 1
35625: NEG
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: EMPTY
35632: LIST
35633: LIST
35634: LIST
35635: LIST
35636: LIST
35637: LIST
35638: LIST
35639: LIST
35640: LIST
35641: LIST
35642: LIST
35643: LIST
35644: LIST
35645: LIST
35646: LIST
35647: LIST
35648: LIST
35649: LIST
35650: LIST
35651: LIST
35652: LIST
35653: LIST
35654: LIST
35655: LIST
35656: LIST
35657: LIST
35658: LIST
35659: LIST
35660: LIST
35661: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35662: LD_ADDR_VAR 0 47
35666: PUSH
35667: LD_INT 0
35669: PUSH
35670: LD_INT 0
35672: PUSH
35673: EMPTY
35674: LIST
35675: LIST
35676: PUSH
35677: LD_INT 0
35679: PUSH
35680: LD_INT 1
35682: NEG
35683: PUSH
35684: EMPTY
35685: LIST
35686: LIST
35687: PUSH
35688: LD_INT 1
35690: PUSH
35691: LD_INT 0
35693: PUSH
35694: EMPTY
35695: LIST
35696: LIST
35697: PUSH
35698: LD_INT 1
35700: PUSH
35701: LD_INT 1
35703: PUSH
35704: EMPTY
35705: LIST
35706: LIST
35707: PUSH
35708: LD_INT 0
35710: PUSH
35711: LD_INT 1
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: LD_INT 1
35720: NEG
35721: PUSH
35722: LD_INT 0
35724: PUSH
35725: EMPTY
35726: LIST
35727: LIST
35728: PUSH
35729: LD_INT 1
35731: NEG
35732: PUSH
35733: LD_INT 1
35735: NEG
35736: PUSH
35737: EMPTY
35738: LIST
35739: LIST
35740: PUSH
35741: LD_INT 1
35743: NEG
35744: PUSH
35745: LD_INT 2
35747: NEG
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 0
35755: PUSH
35756: LD_INT 2
35758: NEG
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 1
35766: PUSH
35767: LD_INT 1
35769: NEG
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 2
35777: NEG
35778: PUSH
35779: LD_INT 1
35781: NEG
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 2
35789: NEG
35790: PUSH
35791: LD_INT 2
35793: NEG
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: EMPTY
35800: LIST
35801: LIST
35802: LIST
35803: LIST
35804: LIST
35805: LIST
35806: LIST
35807: LIST
35808: LIST
35809: LIST
35810: LIST
35811: LIST
35812: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
35813: LD_ADDR_VAR 0 48
35817: PUSH
35818: LD_INT 0
35820: PUSH
35821: LD_INT 0
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: PUSH
35828: LD_INT 0
35830: PUSH
35831: LD_INT 1
35833: NEG
35834: PUSH
35835: EMPTY
35836: LIST
35837: LIST
35838: PUSH
35839: LD_INT 1
35841: PUSH
35842: LD_INT 0
35844: PUSH
35845: EMPTY
35846: LIST
35847: LIST
35848: PUSH
35849: LD_INT 1
35851: PUSH
35852: LD_INT 1
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 0
35861: PUSH
35862: LD_INT 1
35864: PUSH
35865: EMPTY
35866: LIST
35867: LIST
35868: PUSH
35869: LD_INT 1
35871: NEG
35872: PUSH
35873: LD_INT 0
35875: PUSH
35876: EMPTY
35877: LIST
35878: LIST
35879: PUSH
35880: LD_INT 1
35882: NEG
35883: PUSH
35884: LD_INT 1
35886: NEG
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 1
35894: NEG
35895: PUSH
35896: LD_INT 2
35898: NEG
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: PUSH
35904: LD_INT 0
35906: PUSH
35907: LD_INT 2
35909: NEG
35910: PUSH
35911: EMPTY
35912: LIST
35913: LIST
35914: PUSH
35915: LD_INT 1
35917: PUSH
35918: LD_INT 1
35920: NEG
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 2
35928: PUSH
35929: LD_INT 0
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 2
35938: PUSH
35939: LD_INT 1
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: EMPTY
35947: LIST
35948: LIST
35949: LIST
35950: LIST
35951: LIST
35952: LIST
35953: LIST
35954: LIST
35955: LIST
35956: LIST
35957: LIST
35958: LIST
35959: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
35960: LD_ADDR_VAR 0 49
35964: PUSH
35965: LD_INT 0
35967: PUSH
35968: LD_INT 0
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: PUSH
35975: LD_INT 0
35977: PUSH
35978: LD_INT 1
35980: NEG
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 1
35988: PUSH
35989: LD_INT 0
35991: PUSH
35992: EMPTY
35993: LIST
35994: LIST
35995: PUSH
35996: LD_INT 1
35998: PUSH
35999: LD_INT 1
36001: PUSH
36002: EMPTY
36003: LIST
36004: LIST
36005: PUSH
36006: LD_INT 0
36008: PUSH
36009: LD_INT 1
36011: PUSH
36012: EMPTY
36013: LIST
36014: LIST
36015: PUSH
36016: LD_INT 1
36018: NEG
36019: PUSH
36020: LD_INT 0
36022: PUSH
36023: EMPTY
36024: LIST
36025: LIST
36026: PUSH
36027: LD_INT 1
36029: NEG
36030: PUSH
36031: LD_INT 1
36033: NEG
36034: PUSH
36035: EMPTY
36036: LIST
36037: LIST
36038: PUSH
36039: LD_INT 1
36041: PUSH
36042: LD_INT 1
36044: NEG
36045: PUSH
36046: EMPTY
36047: LIST
36048: LIST
36049: PUSH
36050: LD_INT 2
36052: PUSH
36053: LD_INT 0
36055: PUSH
36056: EMPTY
36057: LIST
36058: LIST
36059: PUSH
36060: LD_INT 2
36062: PUSH
36063: LD_INT 1
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: LD_INT 2
36072: PUSH
36073: LD_INT 2
36075: PUSH
36076: EMPTY
36077: LIST
36078: LIST
36079: PUSH
36080: LD_INT 1
36082: PUSH
36083: LD_INT 2
36085: PUSH
36086: EMPTY
36087: LIST
36088: LIST
36089: PUSH
36090: EMPTY
36091: LIST
36092: LIST
36093: LIST
36094: LIST
36095: LIST
36096: LIST
36097: LIST
36098: LIST
36099: LIST
36100: LIST
36101: LIST
36102: LIST
36103: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36104: LD_ADDR_VAR 0 50
36108: PUSH
36109: LD_INT 0
36111: PUSH
36112: LD_INT 0
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 0
36121: PUSH
36122: LD_INT 1
36124: NEG
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 1
36132: PUSH
36133: LD_INT 0
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: PUSH
36140: LD_INT 1
36142: PUSH
36143: LD_INT 1
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: PUSH
36150: LD_INT 0
36152: PUSH
36153: LD_INT 1
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 1
36162: NEG
36163: PUSH
36164: LD_INT 0
36166: PUSH
36167: EMPTY
36168: LIST
36169: LIST
36170: PUSH
36171: LD_INT 1
36173: NEG
36174: PUSH
36175: LD_INT 1
36177: NEG
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: LD_INT 2
36185: PUSH
36186: LD_INT 1
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: PUSH
36193: LD_INT 2
36195: PUSH
36196: LD_INT 2
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 1
36205: PUSH
36206: LD_INT 2
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 0
36215: PUSH
36216: LD_INT 2
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PUSH
36223: LD_INT 1
36225: NEG
36226: PUSH
36227: LD_INT 1
36229: PUSH
36230: EMPTY
36231: LIST
36232: LIST
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: LIST
36238: LIST
36239: LIST
36240: LIST
36241: LIST
36242: LIST
36243: LIST
36244: LIST
36245: LIST
36246: LIST
36247: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
36248: LD_ADDR_VAR 0 51
36252: PUSH
36253: LD_INT 0
36255: PUSH
36256: LD_INT 0
36258: PUSH
36259: EMPTY
36260: LIST
36261: LIST
36262: PUSH
36263: LD_INT 0
36265: PUSH
36266: LD_INT 1
36268: NEG
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 1
36276: PUSH
36277: LD_INT 0
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 1
36286: PUSH
36287: LD_INT 1
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PUSH
36294: LD_INT 0
36296: PUSH
36297: LD_INT 1
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PUSH
36304: LD_INT 1
36306: NEG
36307: PUSH
36308: LD_INT 0
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 1
36317: NEG
36318: PUSH
36319: LD_INT 1
36321: NEG
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PUSH
36327: LD_INT 1
36329: PUSH
36330: LD_INT 2
36332: PUSH
36333: EMPTY
36334: LIST
36335: LIST
36336: PUSH
36337: LD_INT 0
36339: PUSH
36340: LD_INT 2
36342: PUSH
36343: EMPTY
36344: LIST
36345: LIST
36346: PUSH
36347: LD_INT 1
36349: NEG
36350: PUSH
36351: LD_INT 1
36353: PUSH
36354: EMPTY
36355: LIST
36356: LIST
36357: PUSH
36358: LD_INT 2
36360: NEG
36361: PUSH
36362: LD_INT 0
36364: PUSH
36365: EMPTY
36366: LIST
36367: LIST
36368: PUSH
36369: LD_INT 2
36371: NEG
36372: PUSH
36373: LD_INT 1
36375: NEG
36376: PUSH
36377: EMPTY
36378: LIST
36379: LIST
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: LIST
36385: LIST
36386: LIST
36387: LIST
36388: LIST
36389: LIST
36390: LIST
36391: LIST
36392: LIST
36393: LIST
36394: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36395: LD_ADDR_VAR 0 52
36399: PUSH
36400: LD_INT 0
36402: PUSH
36403: LD_INT 0
36405: PUSH
36406: EMPTY
36407: LIST
36408: LIST
36409: PUSH
36410: LD_INT 0
36412: PUSH
36413: LD_INT 1
36415: NEG
36416: PUSH
36417: EMPTY
36418: LIST
36419: LIST
36420: PUSH
36421: LD_INT 1
36423: PUSH
36424: LD_INT 0
36426: PUSH
36427: EMPTY
36428: LIST
36429: LIST
36430: PUSH
36431: LD_INT 1
36433: PUSH
36434: LD_INT 1
36436: PUSH
36437: EMPTY
36438: LIST
36439: LIST
36440: PUSH
36441: LD_INT 0
36443: PUSH
36444: LD_INT 1
36446: PUSH
36447: EMPTY
36448: LIST
36449: LIST
36450: PUSH
36451: LD_INT 1
36453: NEG
36454: PUSH
36455: LD_INT 0
36457: PUSH
36458: EMPTY
36459: LIST
36460: LIST
36461: PUSH
36462: LD_INT 1
36464: NEG
36465: PUSH
36466: LD_INT 1
36468: NEG
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: PUSH
36474: LD_INT 1
36476: NEG
36477: PUSH
36478: LD_INT 2
36480: NEG
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: LD_INT 1
36488: NEG
36489: PUSH
36490: LD_INT 1
36492: PUSH
36493: EMPTY
36494: LIST
36495: LIST
36496: PUSH
36497: LD_INT 2
36499: NEG
36500: PUSH
36501: LD_INT 0
36503: PUSH
36504: EMPTY
36505: LIST
36506: LIST
36507: PUSH
36508: LD_INT 2
36510: NEG
36511: PUSH
36512: LD_INT 1
36514: NEG
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: LD_INT 2
36522: NEG
36523: PUSH
36524: LD_INT 2
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: LIST
36536: LIST
36537: LIST
36538: LIST
36539: LIST
36540: LIST
36541: LIST
36542: LIST
36543: LIST
36544: LIST
36545: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36546: LD_ADDR_VAR 0 53
36550: PUSH
36551: LD_INT 0
36553: PUSH
36554: LD_INT 0
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 0
36563: PUSH
36564: LD_INT 1
36566: NEG
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 1
36574: PUSH
36575: LD_INT 0
36577: PUSH
36578: EMPTY
36579: LIST
36580: LIST
36581: PUSH
36582: LD_INT 1
36584: PUSH
36585: LD_INT 1
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 0
36594: PUSH
36595: LD_INT 1
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 1
36604: NEG
36605: PUSH
36606: LD_INT 0
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 1
36615: NEG
36616: PUSH
36617: LD_INT 1
36619: NEG
36620: PUSH
36621: EMPTY
36622: LIST
36623: LIST
36624: PUSH
36625: LD_INT 1
36627: NEG
36628: PUSH
36629: LD_INT 2
36631: NEG
36632: PUSH
36633: EMPTY
36634: LIST
36635: LIST
36636: PUSH
36637: LD_INT 0
36639: PUSH
36640: LD_INT 2
36642: NEG
36643: PUSH
36644: EMPTY
36645: LIST
36646: LIST
36647: PUSH
36648: LD_INT 1
36650: PUSH
36651: LD_INT 1
36653: NEG
36654: PUSH
36655: EMPTY
36656: LIST
36657: LIST
36658: PUSH
36659: LD_INT 2
36661: PUSH
36662: LD_INT 0
36664: PUSH
36665: EMPTY
36666: LIST
36667: LIST
36668: PUSH
36669: LD_INT 2
36671: PUSH
36672: LD_INT 1
36674: PUSH
36675: EMPTY
36676: LIST
36677: LIST
36678: PUSH
36679: LD_INT 2
36681: PUSH
36682: LD_INT 2
36684: PUSH
36685: EMPTY
36686: LIST
36687: LIST
36688: PUSH
36689: LD_INT 1
36691: PUSH
36692: LD_INT 2
36694: PUSH
36695: EMPTY
36696: LIST
36697: LIST
36698: PUSH
36699: LD_INT 0
36701: PUSH
36702: LD_INT 2
36704: PUSH
36705: EMPTY
36706: LIST
36707: LIST
36708: PUSH
36709: LD_INT 1
36711: NEG
36712: PUSH
36713: LD_INT 1
36715: PUSH
36716: EMPTY
36717: LIST
36718: LIST
36719: PUSH
36720: LD_INT 2
36722: NEG
36723: PUSH
36724: LD_INT 0
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: PUSH
36731: LD_INT 2
36733: NEG
36734: PUSH
36735: LD_INT 1
36737: NEG
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 2
36745: NEG
36746: PUSH
36747: LD_INT 2
36749: NEG
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: LIST
36759: LIST
36760: LIST
36761: LIST
36762: LIST
36763: LIST
36764: LIST
36765: LIST
36766: LIST
36767: LIST
36768: LIST
36769: LIST
36770: LIST
36771: LIST
36772: LIST
36773: LIST
36774: LIST
36775: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36776: LD_ADDR_VAR 0 54
36780: PUSH
36781: LD_INT 0
36783: PUSH
36784: LD_INT 0
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_INT 0
36793: PUSH
36794: LD_INT 1
36796: NEG
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: LD_INT 1
36804: PUSH
36805: LD_INT 0
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: LD_INT 1
36814: PUSH
36815: LD_INT 1
36817: PUSH
36818: EMPTY
36819: LIST
36820: LIST
36821: PUSH
36822: LD_INT 0
36824: PUSH
36825: LD_INT 1
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: PUSH
36832: LD_INT 1
36834: NEG
36835: PUSH
36836: LD_INT 0
36838: PUSH
36839: EMPTY
36840: LIST
36841: LIST
36842: PUSH
36843: LD_INT 1
36845: NEG
36846: PUSH
36847: LD_INT 1
36849: NEG
36850: PUSH
36851: EMPTY
36852: LIST
36853: LIST
36854: PUSH
36855: LD_INT 1
36857: NEG
36858: PUSH
36859: LD_INT 2
36861: NEG
36862: PUSH
36863: EMPTY
36864: LIST
36865: LIST
36866: PUSH
36867: LD_INT 0
36869: PUSH
36870: LD_INT 2
36872: NEG
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 1
36880: PUSH
36881: LD_INT 1
36883: NEG
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 2
36891: PUSH
36892: LD_INT 0
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 2
36901: PUSH
36902: LD_INT 1
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 2
36911: PUSH
36912: LD_INT 2
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: LD_INT 1
36921: PUSH
36922: LD_INT 2
36924: PUSH
36925: EMPTY
36926: LIST
36927: LIST
36928: PUSH
36929: LD_INT 0
36931: PUSH
36932: LD_INT 2
36934: PUSH
36935: EMPTY
36936: LIST
36937: LIST
36938: PUSH
36939: LD_INT 1
36941: NEG
36942: PUSH
36943: LD_INT 1
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: LD_INT 2
36952: NEG
36953: PUSH
36954: LD_INT 0
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 2
36963: NEG
36964: PUSH
36965: LD_INT 1
36967: NEG
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 2
36975: NEG
36976: PUSH
36977: LD_INT 2
36979: NEG
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: EMPTY
36986: LIST
36987: LIST
36988: LIST
36989: LIST
36990: LIST
36991: LIST
36992: LIST
36993: LIST
36994: LIST
36995: LIST
36996: LIST
36997: LIST
36998: LIST
36999: LIST
37000: LIST
37001: LIST
37002: LIST
37003: LIST
37004: LIST
37005: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37006: LD_ADDR_VAR 0 55
37010: PUSH
37011: LD_INT 0
37013: PUSH
37014: LD_INT 0
37016: PUSH
37017: EMPTY
37018: LIST
37019: LIST
37020: PUSH
37021: LD_INT 0
37023: PUSH
37024: LD_INT 1
37026: NEG
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: PUSH
37032: LD_INT 1
37034: PUSH
37035: LD_INT 0
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 1
37044: PUSH
37045: LD_INT 1
37047: PUSH
37048: EMPTY
37049: LIST
37050: LIST
37051: PUSH
37052: LD_INT 0
37054: PUSH
37055: LD_INT 1
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PUSH
37062: LD_INT 1
37064: NEG
37065: PUSH
37066: LD_INT 0
37068: PUSH
37069: EMPTY
37070: LIST
37071: LIST
37072: PUSH
37073: LD_INT 1
37075: NEG
37076: PUSH
37077: LD_INT 1
37079: NEG
37080: PUSH
37081: EMPTY
37082: LIST
37083: LIST
37084: PUSH
37085: LD_INT 1
37087: NEG
37088: PUSH
37089: LD_INT 2
37091: NEG
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: PUSH
37097: LD_INT 0
37099: PUSH
37100: LD_INT 2
37102: NEG
37103: PUSH
37104: EMPTY
37105: LIST
37106: LIST
37107: PUSH
37108: LD_INT 1
37110: PUSH
37111: LD_INT 1
37113: NEG
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 2
37121: PUSH
37122: LD_INT 0
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: PUSH
37129: LD_INT 2
37131: PUSH
37132: LD_INT 1
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 2
37141: PUSH
37142: LD_INT 2
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 1
37151: PUSH
37152: LD_INT 2
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 0
37161: PUSH
37162: LD_INT 2
37164: PUSH
37165: EMPTY
37166: LIST
37167: LIST
37168: PUSH
37169: LD_INT 1
37171: NEG
37172: PUSH
37173: LD_INT 1
37175: PUSH
37176: EMPTY
37177: LIST
37178: LIST
37179: PUSH
37180: LD_INT 2
37182: NEG
37183: PUSH
37184: LD_INT 0
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 2
37193: NEG
37194: PUSH
37195: LD_INT 1
37197: NEG
37198: PUSH
37199: EMPTY
37200: LIST
37201: LIST
37202: PUSH
37203: LD_INT 2
37205: NEG
37206: PUSH
37207: LD_INT 2
37209: NEG
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: EMPTY
37216: LIST
37217: LIST
37218: LIST
37219: LIST
37220: LIST
37221: LIST
37222: LIST
37223: LIST
37224: LIST
37225: LIST
37226: LIST
37227: LIST
37228: LIST
37229: LIST
37230: LIST
37231: LIST
37232: LIST
37233: LIST
37234: LIST
37235: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37236: LD_ADDR_VAR 0 56
37240: PUSH
37241: LD_INT 0
37243: PUSH
37244: LD_INT 0
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: LD_INT 0
37253: PUSH
37254: LD_INT 1
37256: NEG
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 1
37264: PUSH
37265: LD_INT 0
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: PUSH
37272: LD_INT 1
37274: PUSH
37275: LD_INT 1
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 0
37284: PUSH
37285: LD_INT 1
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 1
37294: NEG
37295: PUSH
37296: LD_INT 0
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: PUSH
37303: LD_INT 1
37305: NEG
37306: PUSH
37307: LD_INT 1
37309: NEG
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: PUSH
37315: LD_INT 1
37317: NEG
37318: PUSH
37319: LD_INT 2
37321: NEG
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 0
37329: PUSH
37330: LD_INT 2
37332: NEG
37333: PUSH
37334: EMPTY
37335: LIST
37336: LIST
37337: PUSH
37338: LD_INT 1
37340: PUSH
37341: LD_INT 1
37343: NEG
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: PUSH
37349: LD_INT 2
37351: PUSH
37352: LD_INT 0
37354: PUSH
37355: EMPTY
37356: LIST
37357: LIST
37358: PUSH
37359: LD_INT 2
37361: PUSH
37362: LD_INT 1
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: LD_INT 2
37371: PUSH
37372: LD_INT 2
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 1
37381: PUSH
37382: LD_INT 2
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: LD_INT 0
37391: PUSH
37392: LD_INT 2
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: LD_INT 1
37401: NEG
37402: PUSH
37403: LD_INT 1
37405: PUSH
37406: EMPTY
37407: LIST
37408: LIST
37409: PUSH
37410: LD_INT 2
37412: NEG
37413: PUSH
37414: LD_INT 0
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: PUSH
37421: LD_INT 2
37423: NEG
37424: PUSH
37425: LD_INT 1
37427: NEG
37428: PUSH
37429: EMPTY
37430: LIST
37431: LIST
37432: PUSH
37433: LD_INT 2
37435: NEG
37436: PUSH
37437: LD_INT 2
37439: NEG
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: LIST
37449: LIST
37450: LIST
37451: LIST
37452: LIST
37453: LIST
37454: LIST
37455: LIST
37456: LIST
37457: LIST
37458: LIST
37459: LIST
37460: LIST
37461: LIST
37462: LIST
37463: LIST
37464: LIST
37465: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37466: LD_ADDR_VAR 0 57
37470: PUSH
37471: LD_INT 0
37473: PUSH
37474: LD_INT 0
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: LD_INT 0
37483: PUSH
37484: LD_INT 1
37486: NEG
37487: PUSH
37488: EMPTY
37489: LIST
37490: LIST
37491: PUSH
37492: LD_INT 1
37494: PUSH
37495: LD_INT 0
37497: PUSH
37498: EMPTY
37499: LIST
37500: LIST
37501: PUSH
37502: LD_INT 1
37504: PUSH
37505: LD_INT 1
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: PUSH
37512: LD_INT 0
37514: PUSH
37515: LD_INT 1
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: LD_INT 1
37524: NEG
37525: PUSH
37526: LD_INT 0
37528: PUSH
37529: EMPTY
37530: LIST
37531: LIST
37532: PUSH
37533: LD_INT 1
37535: NEG
37536: PUSH
37537: LD_INT 1
37539: NEG
37540: PUSH
37541: EMPTY
37542: LIST
37543: LIST
37544: PUSH
37545: LD_INT 1
37547: NEG
37548: PUSH
37549: LD_INT 2
37551: NEG
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 0
37559: PUSH
37560: LD_INT 2
37562: NEG
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 1
37570: PUSH
37571: LD_INT 1
37573: NEG
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: PUSH
37579: LD_INT 2
37581: PUSH
37582: LD_INT 0
37584: PUSH
37585: EMPTY
37586: LIST
37587: LIST
37588: PUSH
37589: LD_INT 2
37591: PUSH
37592: LD_INT 1
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: LD_INT 2
37601: PUSH
37602: LD_INT 2
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 1
37611: PUSH
37612: LD_INT 2
37614: PUSH
37615: EMPTY
37616: LIST
37617: LIST
37618: PUSH
37619: LD_INT 0
37621: PUSH
37622: LD_INT 2
37624: PUSH
37625: EMPTY
37626: LIST
37627: LIST
37628: PUSH
37629: LD_INT 1
37631: NEG
37632: PUSH
37633: LD_INT 1
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 2
37642: NEG
37643: PUSH
37644: LD_INT 0
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 2
37653: NEG
37654: PUSH
37655: LD_INT 1
37657: NEG
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PUSH
37663: LD_INT 2
37665: NEG
37666: PUSH
37667: LD_INT 2
37669: NEG
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: LIST
37679: LIST
37680: LIST
37681: LIST
37682: LIST
37683: LIST
37684: LIST
37685: LIST
37686: LIST
37687: LIST
37688: LIST
37689: LIST
37690: LIST
37691: LIST
37692: LIST
37693: LIST
37694: LIST
37695: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37696: LD_ADDR_VAR 0 58
37700: PUSH
37701: LD_INT 0
37703: PUSH
37704: LD_INT 0
37706: PUSH
37707: EMPTY
37708: LIST
37709: LIST
37710: PUSH
37711: LD_INT 0
37713: PUSH
37714: LD_INT 1
37716: NEG
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: PUSH
37722: LD_INT 1
37724: PUSH
37725: LD_INT 0
37727: PUSH
37728: EMPTY
37729: LIST
37730: LIST
37731: PUSH
37732: LD_INT 1
37734: PUSH
37735: LD_INT 1
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: PUSH
37742: LD_INT 0
37744: PUSH
37745: LD_INT 1
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: LD_INT 1
37754: NEG
37755: PUSH
37756: LD_INT 0
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: LD_INT 1
37765: NEG
37766: PUSH
37767: LD_INT 1
37769: NEG
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 1
37777: NEG
37778: PUSH
37779: LD_INT 2
37781: NEG
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PUSH
37787: LD_INT 0
37789: PUSH
37790: LD_INT 2
37792: NEG
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: PUSH
37798: LD_INT 1
37800: PUSH
37801: LD_INT 1
37803: NEG
37804: PUSH
37805: EMPTY
37806: LIST
37807: LIST
37808: PUSH
37809: LD_INT 2
37811: PUSH
37812: LD_INT 0
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 2
37821: PUSH
37822: LD_INT 1
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: LD_INT 2
37831: PUSH
37832: LD_INT 2
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: PUSH
37839: LD_INT 1
37841: PUSH
37842: LD_INT 2
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: LD_INT 0
37851: PUSH
37852: LD_INT 2
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: LD_INT 1
37861: NEG
37862: PUSH
37863: LD_INT 1
37865: PUSH
37866: EMPTY
37867: LIST
37868: LIST
37869: PUSH
37870: LD_INT 2
37872: NEG
37873: PUSH
37874: LD_INT 0
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 2
37883: NEG
37884: PUSH
37885: LD_INT 1
37887: NEG
37888: PUSH
37889: EMPTY
37890: LIST
37891: LIST
37892: PUSH
37893: LD_INT 2
37895: NEG
37896: PUSH
37897: LD_INT 2
37899: NEG
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: LIST
37909: LIST
37910: LIST
37911: LIST
37912: LIST
37913: LIST
37914: LIST
37915: LIST
37916: LIST
37917: LIST
37918: LIST
37919: LIST
37920: LIST
37921: LIST
37922: LIST
37923: LIST
37924: LIST
37925: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37926: LD_ADDR_VAR 0 59
37930: PUSH
37931: LD_INT 0
37933: PUSH
37934: LD_INT 0
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: LD_INT 1
37946: NEG
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 1
37954: PUSH
37955: LD_INT 0
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 1
37964: PUSH
37965: LD_INT 1
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: LD_INT 0
37974: PUSH
37975: LD_INT 1
37977: PUSH
37978: EMPTY
37979: LIST
37980: LIST
37981: PUSH
37982: LD_INT 1
37984: NEG
37985: PUSH
37986: LD_INT 0
37988: PUSH
37989: EMPTY
37990: LIST
37991: LIST
37992: PUSH
37993: LD_INT 1
37995: NEG
37996: PUSH
37997: LD_INT 1
37999: NEG
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: LIST
38009: LIST
38010: LIST
38011: LIST
38012: LIST
38013: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38014: LD_ADDR_VAR 0 60
38018: PUSH
38019: LD_INT 0
38021: PUSH
38022: LD_INT 0
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: LD_INT 0
38031: PUSH
38032: LD_INT 1
38034: NEG
38035: PUSH
38036: EMPTY
38037: LIST
38038: LIST
38039: PUSH
38040: LD_INT 1
38042: PUSH
38043: LD_INT 0
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: PUSH
38050: LD_INT 1
38052: PUSH
38053: LD_INT 1
38055: PUSH
38056: EMPTY
38057: LIST
38058: LIST
38059: PUSH
38060: LD_INT 0
38062: PUSH
38063: LD_INT 1
38065: PUSH
38066: EMPTY
38067: LIST
38068: LIST
38069: PUSH
38070: LD_INT 1
38072: NEG
38073: PUSH
38074: LD_INT 0
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 1
38083: NEG
38084: PUSH
38085: LD_INT 1
38087: NEG
38088: PUSH
38089: EMPTY
38090: LIST
38091: LIST
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: LIST
38097: LIST
38098: LIST
38099: LIST
38100: LIST
38101: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38102: LD_ADDR_VAR 0 61
38106: PUSH
38107: LD_INT 0
38109: PUSH
38110: LD_INT 0
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 0
38119: PUSH
38120: LD_INT 1
38122: NEG
38123: PUSH
38124: EMPTY
38125: LIST
38126: LIST
38127: PUSH
38128: LD_INT 1
38130: PUSH
38131: LD_INT 0
38133: PUSH
38134: EMPTY
38135: LIST
38136: LIST
38137: PUSH
38138: LD_INT 1
38140: PUSH
38141: LD_INT 1
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: LD_INT 0
38150: PUSH
38151: LD_INT 1
38153: PUSH
38154: EMPTY
38155: LIST
38156: LIST
38157: PUSH
38158: LD_INT 1
38160: NEG
38161: PUSH
38162: LD_INT 0
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: LD_INT 1
38171: NEG
38172: PUSH
38173: LD_INT 1
38175: NEG
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: EMPTY
38182: LIST
38183: LIST
38184: LIST
38185: LIST
38186: LIST
38187: LIST
38188: LIST
38189: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38190: LD_ADDR_VAR 0 62
38194: PUSH
38195: LD_INT 0
38197: PUSH
38198: LD_INT 0
38200: PUSH
38201: EMPTY
38202: LIST
38203: LIST
38204: PUSH
38205: LD_INT 0
38207: PUSH
38208: LD_INT 1
38210: NEG
38211: PUSH
38212: EMPTY
38213: LIST
38214: LIST
38215: PUSH
38216: LD_INT 1
38218: PUSH
38219: LD_INT 0
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: PUSH
38226: LD_INT 1
38228: PUSH
38229: LD_INT 1
38231: PUSH
38232: EMPTY
38233: LIST
38234: LIST
38235: PUSH
38236: LD_INT 0
38238: PUSH
38239: LD_INT 1
38241: PUSH
38242: EMPTY
38243: LIST
38244: LIST
38245: PUSH
38246: LD_INT 1
38248: NEG
38249: PUSH
38250: LD_INT 0
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PUSH
38257: LD_INT 1
38259: NEG
38260: PUSH
38261: LD_INT 1
38263: NEG
38264: PUSH
38265: EMPTY
38266: LIST
38267: LIST
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: LIST
38275: LIST
38276: LIST
38277: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38278: LD_ADDR_VAR 0 63
38282: PUSH
38283: LD_INT 0
38285: PUSH
38286: LD_INT 0
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: PUSH
38293: LD_INT 0
38295: PUSH
38296: LD_INT 1
38298: NEG
38299: PUSH
38300: EMPTY
38301: LIST
38302: LIST
38303: PUSH
38304: LD_INT 1
38306: PUSH
38307: LD_INT 0
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: LD_INT 1
38316: PUSH
38317: LD_INT 1
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: LD_INT 0
38326: PUSH
38327: LD_INT 1
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: PUSH
38334: LD_INT 1
38336: NEG
38337: PUSH
38338: LD_INT 0
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: PUSH
38345: LD_INT 1
38347: NEG
38348: PUSH
38349: LD_INT 1
38351: NEG
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: PUSH
38357: EMPTY
38358: LIST
38359: LIST
38360: LIST
38361: LIST
38362: LIST
38363: LIST
38364: LIST
38365: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38366: LD_ADDR_VAR 0 64
38370: PUSH
38371: LD_INT 0
38373: PUSH
38374: LD_INT 0
38376: PUSH
38377: EMPTY
38378: LIST
38379: LIST
38380: PUSH
38381: LD_INT 0
38383: PUSH
38384: LD_INT 1
38386: NEG
38387: PUSH
38388: EMPTY
38389: LIST
38390: LIST
38391: PUSH
38392: LD_INT 1
38394: PUSH
38395: LD_INT 0
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: PUSH
38402: LD_INT 1
38404: PUSH
38405: LD_INT 1
38407: PUSH
38408: EMPTY
38409: LIST
38410: LIST
38411: PUSH
38412: LD_INT 0
38414: PUSH
38415: LD_INT 1
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 1
38424: NEG
38425: PUSH
38426: LD_INT 0
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: PUSH
38433: LD_INT 1
38435: NEG
38436: PUSH
38437: LD_INT 1
38439: NEG
38440: PUSH
38441: EMPTY
38442: LIST
38443: LIST
38444: PUSH
38445: EMPTY
38446: LIST
38447: LIST
38448: LIST
38449: LIST
38450: LIST
38451: LIST
38452: LIST
38453: ST_TO_ADDR
// end ; 1 :
38454: GO 44351
38456: LD_INT 1
38458: DOUBLE
38459: EQUAL
38460: IFTRUE 38464
38462: GO 41087
38464: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38465: LD_ADDR_VAR 0 11
38469: PUSH
38470: LD_INT 1
38472: NEG
38473: PUSH
38474: LD_INT 3
38476: NEG
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 0
38484: PUSH
38485: LD_INT 3
38487: NEG
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: PUSH
38493: LD_INT 1
38495: PUSH
38496: LD_INT 2
38498: NEG
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: PUSH
38504: EMPTY
38505: LIST
38506: LIST
38507: LIST
38508: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38509: LD_ADDR_VAR 0 12
38513: PUSH
38514: LD_INT 2
38516: PUSH
38517: LD_INT 1
38519: NEG
38520: PUSH
38521: EMPTY
38522: LIST
38523: LIST
38524: PUSH
38525: LD_INT 3
38527: PUSH
38528: LD_INT 0
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: PUSH
38535: LD_INT 3
38537: PUSH
38538: LD_INT 1
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: EMPTY
38546: LIST
38547: LIST
38548: LIST
38549: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38550: LD_ADDR_VAR 0 13
38554: PUSH
38555: LD_INT 3
38557: PUSH
38558: LD_INT 2
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: PUSH
38565: LD_INT 3
38567: PUSH
38568: LD_INT 3
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: PUSH
38575: LD_INT 2
38577: PUSH
38578: LD_INT 3
38580: PUSH
38581: EMPTY
38582: LIST
38583: LIST
38584: PUSH
38585: EMPTY
38586: LIST
38587: LIST
38588: LIST
38589: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38590: LD_ADDR_VAR 0 14
38594: PUSH
38595: LD_INT 1
38597: PUSH
38598: LD_INT 3
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 0
38607: PUSH
38608: LD_INT 3
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: LD_INT 1
38617: NEG
38618: PUSH
38619: LD_INT 2
38621: PUSH
38622: EMPTY
38623: LIST
38624: LIST
38625: PUSH
38626: EMPTY
38627: LIST
38628: LIST
38629: LIST
38630: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38631: LD_ADDR_VAR 0 15
38635: PUSH
38636: LD_INT 2
38638: NEG
38639: PUSH
38640: LD_INT 1
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 3
38649: NEG
38650: PUSH
38651: LD_INT 0
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 3
38660: NEG
38661: PUSH
38662: LD_INT 1
38664: NEG
38665: PUSH
38666: EMPTY
38667: LIST
38668: LIST
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: LIST
38674: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38675: LD_ADDR_VAR 0 16
38679: PUSH
38680: LD_INT 2
38682: NEG
38683: PUSH
38684: LD_INT 3
38686: NEG
38687: PUSH
38688: EMPTY
38689: LIST
38690: LIST
38691: PUSH
38692: LD_INT 3
38694: NEG
38695: PUSH
38696: LD_INT 2
38698: NEG
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: LD_INT 3
38706: NEG
38707: PUSH
38708: LD_INT 3
38710: NEG
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: EMPTY
38717: LIST
38718: LIST
38719: LIST
38720: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38721: LD_ADDR_VAR 0 17
38725: PUSH
38726: LD_INT 1
38728: NEG
38729: PUSH
38730: LD_INT 3
38732: NEG
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: LD_INT 0
38740: PUSH
38741: LD_INT 3
38743: NEG
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: PUSH
38749: LD_INT 1
38751: PUSH
38752: LD_INT 2
38754: NEG
38755: PUSH
38756: EMPTY
38757: LIST
38758: LIST
38759: PUSH
38760: EMPTY
38761: LIST
38762: LIST
38763: LIST
38764: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38765: LD_ADDR_VAR 0 18
38769: PUSH
38770: LD_INT 2
38772: PUSH
38773: LD_INT 1
38775: NEG
38776: PUSH
38777: EMPTY
38778: LIST
38779: LIST
38780: PUSH
38781: LD_INT 3
38783: PUSH
38784: LD_INT 0
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: PUSH
38791: LD_INT 3
38793: PUSH
38794: LD_INT 1
38796: PUSH
38797: EMPTY
38798: LIST
38799: LIST
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: LIST
38805: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38806: LD_ADDR_VAR 0 19
38810: PUSH
38811: LD_INT 3
38813: PUSH
38814: LD_INT 2
38816: PUSH
38817: EMPTY
38818: LIST
38819: LIST
38820: PUSH
38821: LD_INT 3
38823: PUSH
38824: LD_INT 3
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 2
38833: PUSH
38834: LD_INT 3
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: LIST
38845: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38846: LD_ADDR_VAR 0 20
38850: PUSH
38851: LD_INT 1
38853: PUSH
38854: LD_INT 3
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: LD_INT 0
38863: PUSH
38864: LD_INT 3
38866: PUSH
38867: EMPTY
38868: LIST
38869: LIST
38870: PUSH
38871: LD_INT 1
38873: NEG
38874: PUSH
38875: LD_INT 2
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: LIST
38886: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38887: LD_ADDR_VAR 0 21
38891: PUSH
38892: LD_INT 2
38894: NEG
38895: PUSH
38896: LD_INT 1
38898: PUSH
38899: EMPTY
38900: LIST
38901: LIST
38902: PUSH
38903: LD_INT 3
38905: NEG
38906: PUSH
38907: LD_INT 0
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: LD_INT 3
38916: NEG
38917: PUSH
38918: LD_INT 1
38920: NEG
38921: PUSH
38922: EMPTY
38923: LIST
38924: LIST
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: LIST
38930: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38931: LD_ADDR_VAR 0 22
38935: PUSH
38936: LD_INT 2
38938: NEG
38939: PUSH
38940: LD_INT 3
38942: NEG
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 3
38950: NEG
38951: PUSH
38952: LD_INT 2
38954: NEG
38955: PUSH
38956: EMPTY
38957: LIST
38958: LIST
38959: PUSH
38960: LD_INT 3
38962: NEG
38963: PUSH
38964: LD_INT 3
38966: NEG
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: EMPTY
38973: LIST
38974: LIST
38975: LIST
38976: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
38977: LD_ADDR_VAR 0 23
38981: PUSH
38982: LD_INT 0
38984: PUSH
38985: LD_INT 3
38987: NEG
38988: PUSH
38989: EMPTY
38990: LIST
38991: LIST
38992: PUSH
38993: LD_INT 1
38995: NEG
38996: PUSH
38997: LD_INT 4
38999: NEG
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: LD_INT 1
39007: PUSH
39008: LD_INT 3
39010: NEG
39011: PUSH
39012: EMPTY
39013: LIST
39014: LIST
39015: PUSH
39016: EMPTY
39017: LIST
39018: LIST
39019: LIST
39020: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39021: LD_ADDR_VAR 0 24
39025: PUSH
39026: LD_INT 3
39028: PUSH
39029: LD_INT 0
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: LD_INT 3
39038: PUSH
39039: LD_INT 1
39041: NEG
39042: PUSH
39043: EMPTY
39044: LIST
39045: LIST
39046: PUSH
39047: LD_INT 4
39049: PUSH
39050: LD_INT 1
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: LIST
39061: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39062: LD_ADDR_VAR 0 25
39066: PUSH
39067: LD_INT 3
39069: PUSH
39070: LD_INT 3
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 4
39079: PUSH
39080: LD_INT 3
39082: PUSH
39083: EMPTY
39084: LIST
39085: LIST
39086: PUSH
39087: LD_INT 3
39089: PUSH
39090: LD_INT 4
39092: PUSH
39093: EMPTY
39094: LIST
39095: LIST
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: LIST
39101: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39102: LD_ADDR_VAR 0 26
39106: PUSH
39107: LD_INT 0
39109: PUSH
39110: LD_INT 3
39112: PUSH
39113: EMPTY
39114: LIST
39115: LIST
39116: PUSH
39117: LD_INT 1
39119: PUSH
39120: LD_INT 4
39122: PUSH
39123: EMPTY
39124: LIST
39125: LIST
39126: PUSH
39127: LD_INT 1
39129: NEG
39130: PUSH
39131: LD_INT 3
39133: PUSH
39134: EMPTY
39135: LIST
39136: LIST
39137: PUSH
39138: EMPTY
39139: LIST
39140: LIST
39141: LIST
39142: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
39143: LD_ADDR_VAR 0 27
39147: PUSH
39148: LD_INT 3
39150: NEG
39151: PUSH
39152: LD_INT 0
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 3
39161: NEG
39162: PUSH
39163: LD_INT 1
39165: PUSH
39166: EMPTY
39167: LIST
39168: LIST
39169: PUSH
39170: LD_INT 4
39172: NEG
39173: PUSH
39174: LD_INT 1
39176: NEG
39177: PUSH
39178: EMPTY
39179: LIST
39180: LIST
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: LIST
39186: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
39187: LD_ADDR_VAR 0 28
39191: PUSH
39192: LD_INT 3
39194: NEG
39195: PUSH
39196: LD_INT 3
39198: NEG
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PUSH
39204: LD_INT 3
39206: NEG
39207: PUSH
39208: LD_INT 4
39210: NEG
39211: PUSH
39212: EMPTY
39213: LIST
39214: LIST
39215: PUSH
39216: LD_INT 4
39218: NEG
39219: PUSH
39220: LD_INT 3
39222: NEG
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: LIST
39232: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
39233: LD_ADDR_VAR 0 29
39237: PUSH
39238: LD_INT 1
39240: NEG
39241: PUSH
39242: LD_INT 3
39244: NEG
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: PUSH
39250: LD_INT 0
39252: PUSH
39253: LD_INT 3
39255: NEG
39256: PUSH
39257: EMPTY
39258: LIST
39259: LIST
39260: PUSH
39261: LD_INT 1
39263: PUSH
39264: LD_INT 2
39266: NEG
39267: PUSH
39268: EMPTY
39269: LIST
39270: LIST
39271: PUSH
39272: LD_INT 1
39274: NEG
39275: PUSH
39276: LD_INT 4
39278: NEG
39279: PUSH
39280: EMPTY
39281: LIST
39282: LIST
39283: PUSH
39284: LD_INT 0
39286: PUSH
39287: LD_INT 4
39289: NEG
39290: PUSH
39291: EMPTY
39292: LIST
39293: LIST
39294: PUSH
39295: LD_INT 1
39297: PUSH
39298: LD_INT 3
39300: NEG
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: PUSH
39306: LD_INT 1
39308: NEG
39309: PUSH
39310: LD_INT 5
39312: NEG
39313: PUSH
39314: EMPTY
39315: LIST
39316: LIST
39317: PUSH
39318: LD_INT 0
39320: PUSH
39321: LD_INT 5
39323: NEG
39324: PUSH
39325: EMPTY
39326: LIST
39327: LIST
39328: PUSH
39329: LD_INT 1
39331: PUSH
39332: LD_INT 4
39334: NEG
39335: PUSH
39336: EMPTY
39337: LIST
39338: LIST
39339: PUSH
39340: LD_INT 1
39342: NEG
39343: PUSH
39344: LD_INT 6
39346: NEG
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: PUSH
39352: LD_INT 0
39354: PUSH
39355: LD_INT 6
39357: NEG
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: PUSH
39363: LD_INT 1
39365: PUSH
39366: LD_INT 5
39368: NEG
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: LIST
39386: LIST
39387: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
39388: LD_ADDR_VAR 0 30
39392: PUSH
39393: LD_INT 2
39395: PUSH
39396: LD_INT 1
39398: NEG
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: LD_INT 3
39406: PUSH
39407: LD_INT 0
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 3
39416: PUSH
39417: LD_INT 1
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: PUSH
39424: LD_INT 3
39426: PUSH
39427: LD_INT 1
39429: NEG
39430: PUSH
39431: EMPTY
39432: LIST
39433: LIST
39434: PUSH
39435: LD_INT 4
39437: PUSH
39438: LD_INT 0
39440: PUSH
39441: EMPTY
39442: LIST
39443: LIST
39444: PUSH
39445: LD_INT 4
39447: PUSH
39448: LD_INT 1
39450: PUSH
39451: EMPTY
39452: LIST
39453: LIST
39454: PUSH
39455: LD_INT 4
39457: PUSH
39458: LD_INT 1
39460: NEG
39461: PUSH
39462: EMPTY
39463: LIST
39464: LIST
39465: PUSH
39466: LD_INT 5
39468: PUSH
39469: LD_INT 0
39471: PUSH
39472: EMPTY
39473: LIST
39474: LIST
39475: PUSH
39476: LD_INT 5
39478: PUSH
39479: LD_INT 1
39481: PUSH
39482: EMPTY
39483: LIST
39484: LIST
39485: PUSH
39486: LD_INT 5
39488: PUSH
39489: LD_INT 1
39491: NEG
39492: PUSH
39493: EMPTY
39494: LIST
39495: LIST
39496: PUSH
39497: LD_INT 6
39499: PUSH
39500: LD_INT 0
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 6
39509: PUSH
39510: LD_INT 1
39512: PUSH
39513: EMPTY
39514: LIST
39515: LIST
39516: PUSH
39517: EMPTY
39518: LIST
39519: LIST
39520: LIST
39521: LIST
39522: LIST
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: LIST
39528: LIST
39529: LIST
39530: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
39531: LD_ADDR_VAR 0 31
39535: PUSH
39536: LD_INT 3
39538: PUSH
39539: LD_INT 2
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 3
39548: PUSH
39549: LD_INT 3
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PUSH
39556: LD_INT 2
39558: PUSH
39559: LD_INT 3
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 4
39568: PUSH
39569: LD_INT 3
39571: PUSH
39572: EMPTY
39573: LIST
39574: LIST
39575: PUSH
39576: LD_INT 4
39578: PUSH
39579: LD_INT 4
39581: PUSH
39582: EMPTY
39583: LIST
39584: LIST
39585: PUSH
39586: LD_INT 3
39588: PUSH
39589: LD_INT 4
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 5
39598: PUSH
39599: LD_INT 4
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: PUSH
39606: LD_INT 5
39608: PUSH
39609: LD_INT 5
39611: PUSH
39612: EMPTY
39613: LIST
39614: LIST
39615: PUSH
39616: LD_INT 4
39618: PUSH
39619: LD_INT 5
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: LD_INT 6
39628: PUSH
39629: LD_INT 5
39631: PUSH
39632: EMPTY
39633: LIST
39634: LIST
39635: PUSH
39636: LD_INT 6
39638: PUSH
39639: LD_INT 6
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 5
39648: PUSH
39649: LD_INT 6
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: EMPTY
39657: LIST
39658: LIST
39659: LIST
39660: LIST
39661: LIST
39662: LIST
39663: LIST
39664: LIST
39665: LIST
39666: LIST
39667: LIST
39668: LIST
39669: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
39670: LD_ADDR_VAR 0 32
39674: PUSH
39675: LD_INT 1
39677: PUSH
39678: LD_INT 3
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 0
39687: PUSH
39688: LD_INT 3
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 1
39697: NEG
39698: PUSH
39699: LD_INT 2
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: LD_INT 1
39708: PUSH
39709: LD_INT 4
39711: PUSH
39712: EMPTY
39713: LIST
39714: LIST
39715: PUSH
39716: LD_INT 0
39718: PUSH
39719: LD_INT 4
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: LD_INT 1
39728: NEG
39729: PUSH
39730: LD_INT 3
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: PUSH
39737: LD_INT 1
39739: PUSH
39740: LD_INT 5
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 0
39749: PUSH
39750: LD_INT 5
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: LD_INT 1
39759: NEG
39760: PUSH
39761: LD_INT 4
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 1
39770: PUSH
39771: LD_INT 6
39773: PUSH
39774: EMPTY
39775: LIST
39776: LIST
39777: PUSH
39778: LD_INT 0
39780: PUSH
39781: LD_INT 6
39783: PUSH
39784: EMPTY
39785: LIST
39786: LIST
39787: PUSH
39788: LD_INT 1
39790: NEG
39791: PUSH
39792: LD_INT 5
39794: PUSH
39795: EMPTY
39796: LIST
39797: LIST
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: LIST
39803: LIST
39804: LIST
39805: LIST
39806: LIST
39807: LIST
39808: LIST
39809: LIST
39810: LIST
39811: LIST
39812: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
39813: LD_ADDR_VAR 0 33
39817: PUSH
39818: LD_INT 2
39820: NEG
39821: PUSH
39822: LD_INT 1
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 3
39831: NEG
39832: PUSH
39833: LD_INT 0
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: PUSH
39840: LD_INT 3
39842: NEG
39843: PUSH
39844: LD_INT 1
39846: NEG
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 3
39854: NEG
39855: PUSH
39856: LD_INT 1
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: LD_INT 4
39865: NEG
39866: PUSH
39867: LD_INT 0
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 4
39876: NEG
39877: PUSH
39878: LD_INT 1
39880: NEG
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 4
39888: NEG
39889: PUSH
39890: LD_INT 1
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 5
39899: NEG
39900: PUSH
39901: LD_INT 0
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 5
39910: NEG
39911: PUSH
39912: LD_INT 1
39914: NEG
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: LD_INT 5
39922: NEG
39923: PUSH
39924: LD_INT 1
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: PUSH
39931: LD_INT 6
39933: NEG
39934: PUSH
39935: LD_INT 0
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: LD_INT 6
39944: NEG
39945: PUSH
39946: LD_INT 1
39948: NEG
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: LIST
39958: LIST
39959: LIST
39960: LIST
39961: LIST
39962: LIST
39963: LIST
39964: LIST
39965: LIST
39966: LIST
39967: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
39968: LD_ADDR_VAR 0 34
39972: PUSH
39973: LD_INT 2
39975: NEG
39976: PUSH
39977: LD_INT 3
39979: NEG
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: PUSH
39985: LD_INT 3
39987: NEG
39988: PUSH
39989: LD_INT 2
39991: NEG
39992: PUSH
39993: EMPTY
39994: LIST
39995: LIST
39996: PUSH
39997: LD_INT 3
39999: NEG
40000: PUSH
40001: LD_INT 3
40003: NEG
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 3
40011: NEG
40012: PUSH
40013: LD_INT 4
40015: NEG
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: LD_INT 4
40023: NEG
40024: PUSH
40025: LD_INT 3
40027: NEG
40028: PUSH
40029: EMPTY
40030: LIST
40031: LIST
40032: PUSH
40033: LD_INT 4
40035: NEG
40036: PUSH
40037: LD_INT 4
40039: NEG
40040: PUSH
40041: EMPTY
40042: LIST
40043: LIST
40044: PUSH
40045: LD_INT 4
40047: NEG
40048: PUSH
40049: LD_INT 5
40051: NEG
40052: PUSH
40053: EMPTY
40054: LIST
40055: LIST
40056: PUSH
40057: LD_INT 5
40059: NEG
40060: PUSH
40061: LD_INT 4
40063: NEG
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 5
40071: NEG
40072: PUSH
40073: LD_INT 5
40075: NEG
40076: PUSH
40077: EMPTY
40078: LIST
40079: LIST
40080: PUSH
40081: LD_INT 5
40083: NEG
40084: PUSH
40085: LD_INT 6
40087: NEG
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 6
40095: NEG
40096: PUSH
40097: LD_INT 5
40099: NEG
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: LD_INT 6
40107: NEG
40108: PUSH
40109: LD_INT 6
40111: NEG
40112: PUSH
40113: EMPTY
40114: LIST
40115: LIST
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: LIST
40121: LIST
40122: LIST
40123: LIST
40124: LIST
40125: LIST
40126: LIST
40127: LIST
40128: LIST
40129: LIST
40130: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
40131: LD_ADDR_VAR 0 41
40135: PUSH
40136: LD_INT 0
40138: PUSH
40139: LD_INT 2
40141: NEG
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 1
40149: NEG
40150: PUSH
40151: LD_INT 3
40153: NEG
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: PUSH
40159: LD_INT 1
40161: PUSH
40162: LD_INT 2
40164: NEG
40165: PUSH
40166: EMPTY
40167: LIST
40168: LIST
40169: PUSH
40170: EMPTY
40171: LIST
40172: LIST
40173: LIST
40174: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
40175: LD_ADDR_VAR 0 42
40179: PUSH
40180: LD_INT 2
40182: PUSH
40183: LD_INT 0
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: LD_INT 2
40192: PUSH
40193: LD_INT 1
40195: NEG
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: PUSH
40201: LD_INT 3
40203: PUSH
40204: LD_INT 1
40206: PUSH
40207: EMPTY
40208: LIST
40209: LIST
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: LIST
40215: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
40216: LD_ADDR_VAR 0 43
40220: PUSH
40221: LD_INT 2
40223: PUSH
40224: LD_INT 2
40226: PUSH
40227: EMPTY
40228: LIST
40229: LIST
40230: PUSH
40231: LD_INT 3
40233: PUSH
40234: LD_INT 2
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 2
40243: PUSH
40244: LD_INT 3
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: LIST
40255: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
40256: LD_ADDR_VAR 0 44
40260: PUSH
40261: LD_INT 0
40263: PUSH
40264: LD_INT 2
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: PUSH
40271: LD_INT 1
40273: PUSH
40274: LD_INT 3
40276: PUSH
40277: EMPTY
40278: LIST
40279: LIST
40280: PUSH
40281: LD_INT 1
40283: NEG
40284: PUSH
40285: LD_INT 2
40287: PUSH
40288: EMPTY
40289: LIST
40290: LIST
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: LIST
40296: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
40297: LD_ADDR_VAR 0 45
40301: PUSH
40302: LD_INT 2
40304: NEG
40305: PUSH
40306: LD_INT 0
40308: PUSH
40309: EMPTY
40310: LIST
40311: LIST
40312: PUSH
40313: LD_INT 2
40315: NEG
40316: PUSH
40317: LD_INT 1
40319: PUSH
40320: EMPTY
40321: LIST
40322: LIST
40323: PUSH
40324: LD_INT 3
40326: NEG
40327: PUSH
40328: LD_INT 1
40330: NEG
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: LIST
40340: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
40341: LD_ADDR_VAR 0 46
40345: PUSH
40346: LD_INT 2
40348: NEG
40349: PUSH
40350: LD_INT 2
40352: NEG
40353: PUSH
40354: EMPTY
40355: LIST
40356: LIST
40357: PUSH
40358: LD_INT 2
40360: NEG
40361: PUSH
40362: LD_INT 3
40364: NEG
40365: PUSH
40366: EMPTY
40367: LIST
40368: LIST
40369: PUSH
40370: LD_INT 3
40372: NEG
40373: PUSH
40374: LD_INT 2
40376: NEG
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: PUSH
40382: EMPTY
40383: LIST
40384: LIST
40385: LIST
40386: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
40387: LD_ADDR_VAR 0 47
40391: PUSH
40392: LD_INT 2
40394: NEG
40395: PUSH
40396: LD_INT 3
40398: NEG
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: LD_INT 1
40406: NEG
40407: PUSH
40408: LD_INT 3
40410: NEG
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
40420: LD_ADDR_VAR 0 48
40424: PUSH
40425: LD_INT 1
40427: PUSH
40428: LD_INT 2
40430: NEG
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: LD_INT 2
40438: PUSH
40439: LD_INT 1
40441: NEG
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
40451: LD_ADDR_VAR 0 49
40455: PUSH
40456: LD_INT 3
40458: PUSH
40459: LD_INT 1
40461: PUSH
40462: EMPTY
40463: LIST
40464: LIST
40465: PUSH
40466: LD_INT 3
40468: PUSH
40469: LD_INT 2
40471: PUSH
40472: EMPTY
40473: LIST
40474: LIST
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
40480: LD_ADDR_VAR 0 50
40484: PUSH
40485: LD_INT 2
40487: PUSH
40488: LD_INT 3
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: LD_INT 1
40497: PUSH
40498: LD_INT 3
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: EMPTY
40506: LIST
40507: LIST
40508: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
40509: LD_ADDR_VAR 0 51
40513: PUSH
40514: LD_INT 1
40516: NEG
40517: PUSH
40518: LD_INT 2
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 2
40527: NEG
40528: PUSH
40529: LD_INT 1
40531: PUSH
40532: EMPTY
40533: LIST
40534: LIST
40535: PUSH
40536: EMPTY
40537: LIST
40538: LIST
40539: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
40540: LD_ADDR_VAR 0 52
40544: PUSH
40545: LD_INT 3
40547: NEG
40548: PUSH
40549: LD_INT 1
40551: NEG
40552: PUSH
40553: EMPTY
40554: LIST
40555: LIST
40556: PUSH
40557: LD_INT 3
40559: NEG
40560: PUSH
40561: LD_INT 2
40563: NEG
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40573: LD_ADDR_VAR 0 53
40577: PUSH
40578: LD_INT 1
40580: NEG
40581: PUSH
40582: LD_INT 3
40584: NEG
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: LD_INT 0
40592: PUSH
40593: LD_INT 3
40595: NEG
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: PUSH
40601: LD_INT 1
40603: PUSH
40604: LD_INT 2
40606: NEG
40607: PUSH
40608: EMPTY
40609: LIST
40610: LIST
40611: PUSH
40612: EMPTY
40613: LIST
40614: LIST
40615: LIST
40616: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40617: LD_ADDR_VAR 0 54
40621: PUSH
40622: LD_INT 2
40624: PUSH
40625: LD_INT 1
40627: NEG
40628: PUSH
40629: EMPTY
40630: LIST
40631: LIST
40632: PUSH
40633: LD_INT 3
40635: PUSH
40636: LD_INT 0
40638: PUSH
40639: EMPTY
40640: LIST
40641: LIST
40642: PUSH
40643: LD_INT 3
40645: PUSH
40646: LD_INT 1
40648: PUSH
40649: EMPTY
40650: LIST
40651: LIST
40652: PUSH
40653: EMPTY
40654: LIST
40655: LIST
40656: LIST
40657: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40658: LD_ADDR_VAR 0 55
40662: PUSH
40663: LD_INT 3
40665: PUSH
40666: LD_INT 2
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: LD_INT 3
40675: PUSH
40676: LD_INT 3
40678: PUSH
40679: EMPTY
40680: LIST
40681: LIST
40682: PUSH
40683: LD_INT 2
40685: PUSH
40686: LD_INT 3
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: EMPTY
40694: LIST
40695: LIST
40696: LIST
40697: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40698: LD_ADDR_VAR 0 56
40702: PUSH
40703: LD_INT 1
40705: PUSH
40706: LD_INT 3
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: LD_INT 0
40715: PUSH
40716: LD_INT 3
40718: PUSH
40719: EMPTY
40720: LIST
40721: LIST
40722: PUSH
40723: LD_INT 1
40725: NEG
40726: PUSH
40727: LD_INT 2
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: EMPTY
40735: LIST
40736: LIST
40737: LIST
40738: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40739: LD_ADDR_VAR 0 57
40743: PUSH
40744: LD_INT 2
40746: NEG
40747: PUSH
40748: LD_INT 1
40750: PUSH
40751: EMPTY
40752: LIST
40753: LIST
40754: PUSH
40755: LD_INT 3
40757: NEG
40758: PUSH
40759: LD_INT 0
40761: PUSH
40762: EMPTY
40763: LIST
40764: LIST
40765: PUSH
40766: LD_INT 3
40768: NEG
40769: PUSH
40770: LD_INT 1
40772: NEG
40773: PUSH
40774: EMPTY
40775: LIST
40776: LIST
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: LIST
40782: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40783: LD_ADDR_VAR 0 58
40787: PUSH
40788: LD_INT 2
40790: NEG
40791: PUSH
40792: LD_INT 3
40794: NEG
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: PUSH
40800: LD_INT 3
40802: NEG
40803: PUSH
40804: LD_INT 2
40806: NEG
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 3
40814: NEG
40815: PUSH
40816: LD_INT 3
40818: NEG
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: LIST
40828: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
40829: LD_ADDR_VAR 0 59
40833: PUSH
40834: LD_INT 1
40836: NEG
40837: PUSH
40838: LD_INT 2
40840: NEG
40841: PUSH
40842: EMPTY
40843: LIST
40844: LIST
40845: PUSH
40846: LD_INT 0
40848: PUSH
40849: LD_INT 2
40851: NEG
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: LD_INT 1
40859: PUSH
40860: LD_INT 1
40862: NEG
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: EMPTY
40869: LIST
40870: LIST
40871: LIST
40872: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
40873: LD_ADDR_VAR 0 60
40877: PUSH
40878: LD_INT 1
40880: PUSH
40881: LD_INT 1
40883: NEG
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 2
40891: PUSH
40892: LD_INT 0
40894: PUSH
40895: EMPTY
40896: LIST
40897: LIST
40898: PUSH
40899: LD_INT 2
40901: PUSH
40902: LD_INT 1
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: LIST
40913: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
40914: LD_ADDR_VAR 0 61
40918: PUSH
40919: LD_INT 2
40921: PUSH
40922: LD_INT 1
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: PUSH
40929: LD_INT 2
40931: PUSH
40932: LD_INT 2
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: LD_INT 1
40941: PUSH
40942: LD_INT 2
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: LIST
40953: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
40954: LD_ADDR_VAR 0 62
40958: PUSH
40959: LD_INT 1
40961: PUSH
40962: LD_INT 2
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: PUSH
40969: LD_INT 0
40971: PUSH
40972: LD_INT 2
40974: PUSH
40975: EMPTY
40976: LIST
40977: LIST
40978: PUSH
40979: LD_INT 1
40981: NEG
40982: PUSH
40983: LD_INT 1
40985: PUSH
40986: EMPTY
40987: LIST
40988: LIST
40989: PUSH
40990: EMPTY
40991: LIST
40992: LIST
40993: LIST
40994: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
40995: LD_ADDR_VAR 0 63
40999: PUSH
41000: LD_INT 1
41002: NEG
41003: PUSH
41004: LD_INT 1
41006: PUSH
41007: EMPTY
41008: LIST
41009: LIST
41010: PUSH
41011: LD_INT 2
41013: NEG
41014: PUSH
41015: LD_INT 0
41017: PUSH
41018: EMPTY
41019: LIST
41020: LIST
41021: PUSH
41022: LD_INT 2
41024: NEG
41025: PUSH
41026: LD_INT 1
41028: NEG
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: LIST
41038: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41039: LD_ADDR_VAR 0 64
41043: PUSH
41044: LD_INT 1
41046: NEG
41047: PUSH
41048: LD_INT 2
41050: NEG
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PUSH
41056: LD_INT 2
41058: NEG
41059: PUSH
41060: LD_INT 1
41062: NEG
41063: PUSH
41064: EMPTY
41065: LIST
41066: LIST
41067: PUSH
41068: LD_INT 2
41070: NEG
41071: PUSH
41072: LD_INT 2
41074: NEG
41075: PUSH
41076: EMPTY
41077: LIST
41078: LIST
41079: PUSH
41080: EMPTY
41081: LIST
41082: LIST
41083: LIST
41084: ST_TO_ADDR
// end ; 2 :
41085: GO 44351
41087: LD_INT 2
41089: DOUBLE
41090: EQUAL
41091: IFTRUE 41095
41093: GO 44350
41095: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41096: LD_ADDR_VAR 0 29
41100: PUSH
41101: LD_INT 4
41103: PUSH
41104: LD_INT 0
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: LD_INT 4
41113: PUSH
41114: LD_INT 1
41116: NEG
41117: PUSH
41118: EMPTY
41119: LIST
41120: LIST
41121: PUSH
41122: LD_INT 5
41124: PUSH
41125: LD_INT 0
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 5
41134: PUSH
41135: LD_INT 1
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 4
41144: PUSH
41145: LD_INT 1
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 3
41154: PUSH
41155: LD_INT 0
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 3
41164: PUSH
41165: LD_INT 1
41167: NEG
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: PUSH
41173: LD_INT 3
41175: PUSH
41176: LD_INT 2
41178: NEG
41179: PUSH
41180: EMPTY
41181: LIST
41182: LIST
41183: PUSH
41184: LD_INT 5
41186: PUSH
41187: LD_INT 2
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PUSH
41194: LD_INT 3
41196: PUSH
41197: LD_INT 3
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: LD_INT 3
41206: PUSH
41207: LD_INT 2
41209: PUSH
41210: EMPTY
41211: LIST
41212: LIST
41213: PUSH
41214: LD_INT 4
41216: PUSH
41217: LD_INT 3
41219: PUSH
41220: EMPTY
41221: LIST
41222: LIST
41223: PUSH
41224: LD_INT 4
41226: PUSH
41227: LD_INT 4
41229: PUSH
41230: EMPTY
41231: LIST
41232: LIST
41233: PUSH
41234: LD_INT 3
41236: PUSH
41237: LD_INT 4
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PUSH
41244: LD_INT 2
41246: PUSH
41247: LD_INT 3
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: LD_INT 2
41256: PUSH
41257: LD_INT 2
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: LD_INT 4
41266: PUSH
41267: LD_INT 2
41269: PUSH
41270: EMPTY
41271: LIST
41272: LIST
41273: PUSH
41274: LD_INT 2
41276: PUSH
41277: LD_INT 4
41279: PUSH
41280: EMPTY
41281: LIST
41282: LIST
41283: PUSH
41284: LD_INT 0
41286: PUSH
41287: LD_INT 4
41289: PUSH
41290: EMPTY
41291: LIST
41292: LIST
41293: PUSH
41294: LD_INT 0
41296: PUSH
41297: LD_INT 3
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 1
41306: PUSH
41307: LD_INT 4
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: LD_INT 1
41316: PUSH
41317: LD_INT 5
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: LD_INT 0
41326: PUSH
41327: LD_INT 5
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: PUSH
41334: LD_INT 1
41336: NEG
41337: PUSH
41338: LD_INT 4
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: PUSH
41345: LD_INT 1
41347: NEG
41348: PUSH
41349: LD_INT 3
41351: PUSH
41352: EMPTY
41353: LIST
41354: LIST
41355: PUSH
41356: LD_INT 2
41358: PUSH
41359: LD_INT 5
41361: PUSH
41362: EMPTY
41363: LIST
41364: LIST
41365: PUSH
41366: LD_INT 2
41368: NEG
41369: PUSH
41370: LD_INT 3
41372: PUSH
41373: EMPTY
41374: LIST
41375: LIST
41376: PUSH
41377: LD_INT 3
41379: NEG
41380: PUSH
41381: LD_INT 0
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: LD_INT 3
41390: NEG
41391: PUSH
41392: LD_INT 1
41394: NEG
41395: PUSH
41396: EMPTY
41397: LIST
41398: LIST
41399: PUSH
41400: LD_INT 2
41402: NEG
41403: PUSH
41404: LD_INT 0
41406: PUSH
41407: EMPTY
41408: LIST
41409: LIST
41410: PUSH
41411: LD_INT 2
41413: NEG
41414: PUSH
41415: LD_INT 1
41417: PUSH
41418: EMPTY
41419: LIST
41420: LIST
41421: PUSH
41422: LD_INT 3
41424: NEG
41425: PUSH
41426: LD_INT 1
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: LD_INT 4
41435: NEG
41436: PUSH
41437: LD_INT 0
41439: PUSH
41440: EMPTY
41441: LIST
41442: LIST
41443: PUSH
41444: LD_INT 4
41446: NEG
41447: PUSH
41448: LD_INT 1
41450: NEG
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: LD_INT 4
41458: NEG
41459: PUSH
41460: LD_INT 2
41462: NEG
41463: PUSH
41464: EMPTY
41465: LIST
41466: LIST
41467: PUSH
41468: LD_INT 2
41470: NEG
41471: PUSH
41472: LD_INT 2
41474: PUSH
41475: EMPTY
41476: LIST
41477: LIST
41478: PUSH
41479: LD_INT 4
41481: NEG
41482: PUSH
41483: LD_INT 4
41485: NEG
41486: PUSH
41487: EMPTY
41488: LIST
41489: LIST
41490: PUSH
41491: LD_INT 4
41493: NEG
41494: PUSH
41495: LD_INT 5
41497: NEG
41498: PUSH
41499: EMPTY
41500: LIST
41501: LIST
41502: PUSH
41503: LD_INT 3
41505: NEG
41506: PUSH
41507: LD_INT 4
41509: NEG
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: LD_INT 3
41517: NEG
41518: PUSH
41519: LD_INT 3
41521: NEG
41522: PUSH
41523: EMPTY
41524: LIST
41525: LIST
41526: PUSH
41527: LD_INT 4
41529: NEG
41530: PUSH
41531: LD_INT 3
41533: NEG
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: PUSH
41539: LD_INT 5
41541: NEG
41542: PUSH
41543: LD_INT 4
41545: NEG
41546: PUSH
41547: EMPTY
41548: LIST
41549: LIST
41550: PUSH
41551: LD_INT 5
41553: NEG
41554: PUSH
41555: LD_INT 5
41557: NEG
41558: PUSH
41559: EMPTY
41560: LIST
41561: LIST
41562: PUSH
41563: LD_INT 3
41565: NEG
41566: PUSH
41567: LD_INT 5
41569: NEG
41570: PUSH
41571: EMPTY
41572: LIST
41573: LIST
41574: PUSH
41575: LD_INT 5
41577: NEG
41578: PUSH
41579: LD_INT 3
41581: NEG
41582: PUSH
41583: EMPTY
41584: LIST
41585: LIST
41586: PUSH
41587: EMPTY
41588: LIST
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: LIST
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: LIST
41608: LIST
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: LIST
41618: LIST
41619: LIST
41620: LIST
41621: LIST
41622: LIST
41623: LIST
41624: LIST
41625: LIST
41626: LIST
41627: LIST
41628: LIST
41629: LIST
41630: LIST
41631: LIST
41632: LIST
41633: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
41634: LD_ADDR_VAR 0 30
41638: PUSH
41639: LD_INT 4
41641: PUSH
41642: LD_INT 4
41644: PUSH
41645: EMPTY
41646: LIST
41647: LIST
41648: PUSH
41649: LD_INT 4
41651: PUSH
41652: LD_INT 3
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PUSH
41659: LD_INT 5
41661: PUSH
41662: LD_INT 4
41664: PUSH
41665: EMPTY
41666: LIST
41667: LIST
41668: PUSH
41669: LD_INT 5
41671: PUSH
41672: LD_INT 5
41674: PUSH
41675: EMPTY
41676: LIST
41677: LIST
41678: PUSH
41679: LD_INT 4
41681: PUSH
41682: LD_INT 5
41684: PUSH
41685: EMPTY
41686: LIST
41687: LIST
41688: PUSH
41689: LD_INT 3
41691: PUSH
41692: LD_INT 4
41694: PUSH
41695: EMPTY
41696: LIST
41697: LIST
41698: PUSH
41699: LD_INT 3
41701: PUSH
41702: LD_INT 3
41704: PUSH
41705: EMPTY
41706: LIST
41707: LIST
41708: PUSH
41709: LD_INT 5
41711: PUSH
41712: LD_INT 3
41714: PUSH
41715: EMPTY
41716: LIST
41717: LIST
41718: PUSH
41719: LD_INT 3
41721: PUSH
41722: LD_INT 5
41724: PUSH
41725: EMPTY
41726: LIST
41727: LIST
41728: PUSH
41729: LD_INT 0
41731: PUSH
41732: LD_INT 3
41734: PUSH
41735: EMPTY
41736: LIST
41737: LIST
41738: PUSH
41739: LD_INT 0
41741: PUSH
41742: LD_INT 2
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 1
41751: PUSH
41752: LD_INT 3
41754: PUSH
41755: EMPTY
41756: LIST
41757: LIST
41758: PUSH
41759: LD_INT 1
41761: PUSH
41762: LD_INT 4
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: PUSH
41769: LD_INT 0
41771: PUSH
41772: LD_INT 4
41774: PUSH
41775: EMPTY
41776: LIST
41777: LIST
41778: PUSH
41779: LD_INT 1
41781: NEG
41782: PUSH
41783: LD_INT 3
41785: PUSH
41786: EMPTY
41787: LIST
41788: LIST
41789: PUSH
41790: LD_INT 1
41792: NEG
41793: PUSH
41794: LD_INT 2
41796: PUSH
41797: EMPTY
41798: LIST
41799: LIST
41800: PUSH
41801: LD_INT 2
41803: PUSH
41804: LD_INT 4
41806: PUSH
41807: EMPTY
41808: LIST
41809: LIST
41810: PUSH
41811: LD_INT 2
41813: NEG
41814: PUSH
41815: LD_INT 2
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: PUSH
41822: LD_INT 4
41824: NEG
41825: PUSH
41826: LD_INT 0
41828: PUSH
41829: EMPTY
41830: LIST
41831: LIST
41832: PUSH
41833: LD_INT 4
41835: NEG
41836: PUSH
41837: LD_INT 1
41839: NEG
41840: PUSH
41841: EMPTY
41842: LIST
41843: LIST
41844: PUSH
41845: LD_INT 3
41847: NEG
41848: PUSH
41849: LD_INT 0
41851: PUSH
41852: EMPTY
41853: LIST
41854: LIST
41855: PUSH
41856: LD_INT 3
41858: NEG
41859: PUSH
41860: LD_INT 1
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PUSH
41867: LD_INT 4
41869: NEG
41870: PUSH
41871: LD_INT 1
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: LD_INT 5
41880: NEG
41881: PUSH
41882: LD_INT 0
41884: PUSH
41885: EMPTY
41886: LIST
41887: LIST
41888: PUSH
41889: LD_INT 5
41891: NEG
41892: PUSH
41893: LD_INT 1
41895: NEG
41896: PUSH
41897: EMPTY
41898: LIST
41899: LIST
41900: PUSH
41901: LD_INT 5
41903: NEG
41904: PUSH
41905: LD_INT 2
41907: NEG
41908: PUSH
41909: EMPTY
41910: LIST
41911: LIST
41912: PUSH
41913: LD_INT 3
41915: NEG
41916: PUSH
41917: LD_INT 2
41919: PUSH
41920: EMPTY
41921: LIST
41922: LIST
41923: PUSH
41924: LD_INT 3
41926: NEG
41927: PUSH
41928: LD_INT 3
41930: NEG
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: LD_INT 3
41938: NEG
41939: PUSH
41940: LD_INT 4
41942: NEG
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: LD_INT 2
41950: NEG
41951: PUSH
41952: LD_INT 3
41954: NEG
41955: PUSH
41956: EMPTY
41957: LIST
41958: LIST
41959: PUSH
41960: LD_INT 2
41962: NEG
41963: PUSH
41964: LD_INT 2
41966: NEG
41967: PUSH
41968: EMPTY
41969: LIST
41970: LIST
41971: PUSH
41972: LD_INT 3
41974: NEG
41975: PUSH
41976: LD_INT 2
41978: NEG
41979: PUSH
41980: EMPTY
41981: LIST
41982: LIST
41983: PUSH
41984: LD_INT 4
41986: NEG
41987: PUSH
41988: LD_INT 3
41990: NEG
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: LD_INT 4
41998: NEG
41999: PUSH
42000: LD_INT 4
42002: NEG
42003: PUSH
42004: EMPTY
42005: LIST
42006: LIST
42007: PUSH
42008: LD_INT 2
42010: NEG
42011: PUSH
42012: LD_INT 4
42014: NEG
42015: PUSH
42016: EMPTY
42017: LIST
42018: LIST
42019: PUSH
42020: LD_INT 4
42022: NEG
42023: PUSH
42024: LD_INT 2
42026: NEG
42027: PUSH
42028: EMPTY
42029: LIST
42030: LIST
42031: PUSH
42032: LD_INT 0
42034: PUSH
42035: LD_INT 4
42037: NEG
42038: PUSH
42039: EMPTY
42040: LIST
42041: LIST
42042: PUSH
42043: LD_INT 0
42045: PUSH
42046: LD_INT 5
42048: NEG
42049: PUSH
42050: EMPTY
42051: LIST
42052: LIST
42053: PUSH
42054: LD_INT 1
42056: PUSH
42057: LD_INT 4
42059: NEG
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PUSH
42065: LD_INT 1
42067: PUSH
42068: LD_INT 3
42070: NEG
42071: PUSH
42072: EMPTY
42073: LIST
42074: LIST
42075: PUSH
42076: LD_INT 0
42078: PUSH
42079: LD_INT 3
42081: NEG
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 1
42089: NEG
42090: PUSH
42091: LD_INT 4
42093: NEG
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: LD_INT 1
42101: NEG
42102: PUSH
42103: LD_INT 5
42105: NEG
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 2
42113: PUSH
42114: LD_INT 3
42116: NEG
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: PUSH
42122: LD_INT 2
42124: NEG
42125: PUSH
42126: LD_INT 5
42128: NEG
42129: PUSH
42130: EMPTY
42131: LIST
42132: LIST
42133: PUSH
42134: EMPTY
42135: LIST
42136: LIST
42137: LIST
42138: LIST
42139: LIST
42140: LIST
42141: LIST
42142: LIST
42143: LIST
42144: LIST
42145: LIST
42146: LIST
42147: LIST
42148: LIST
42149: LIST
42150: LIST
42151: LIST
42152: LIST
42153: LIST
42154: LIST
42155: LIST
42156: LIST
42157: LIST
42158: LIST
42159: LIST
42160: LIST
42161: LIST
42162: LIST
42163: LIST
42164: LIST
42165: LIST
42166: LIST
42167: LIST
42168: LIST
42169: LIST
42170: LIST
42171: LIST
42172: LIST
42173: LIST
42174: LIST
42175: LIST
42176: LIST
42177: LIST
42178: LIST
42179: LIST
42180: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
42181: LD_ADDR_VAR 0 31
42185: PUSH
42186: LD_INT 0
42188: PUSH
42189: LD_INT 4
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 0
42198: PUSH
42199: LD_INT 3
42201: PUSH
42202: EMPTY
42203: LIST
42204: LIST
42205: PUSH
42206: LD_INT 1
42208: PUSH
42209: LD_INT 4
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PUSH
42216: LD_INT 1
42218: PUSH
42219: LD_INT 5
42221: PUSH
42222: EMPTY
42223: LIST
42224: LIST
42225: PUSH
42226: LD_INT 0
42228: PUSH
42229: LD_INT 5
42231: PUSH
42232: EMPTY
42233: LIST
42234: LIST
42235: PUSH
42236: LD_INT 1
42238: NEG
42239: PUSH
42240: LD_INT 4
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: LD_INT 1
42249: NEG
42250: PUSH
42251: LD_INT 3
42253: PUSH
42254: EMPTY
42255: LIST
42256: LIST
42257: PUSH
42258: LD_INT 2
42260: PUSH
42261: LD_INT 5
42263: PUSH
42264: EMPTY
42265: LIST
42266: LIST
42267: PUSH
42268: LD_INT 2
42270: NEG
42271: PUSH
42272: LD_INT 3
42274: PUSH
42275: EMPTY
42276: LIST
42277: LIST
42278: PUSH
42279: LD_INT 3
42281: NEG
42282: PUSH
42283: LD_INT 0
42285: PUSH
42286: EMPTY
42287: LIST
42288: LIST
42289: PUSH
42290: LD_INT 3
42292: NEG
42293: PUSH
42294: LD_INT 1
42296: NEG
42297: PUSH
42298: EMPTY
42299: LIST
42300: LIST
42301: PUSH
42302: LD_INT 2
42304: NEG
42305: PUSH
42306: LD_INT 0
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: PUSH
42313: LD_INT 2
42315: NEG
42316: PUSH
42317: LD_INT 1
42319: PUSH
42320: EMPTY
42321: LIST
42322: LIST
42323: PUSH
42324: LD_INT 3
42326: NEG
42327: PUSH
42328: LD_INT 1
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 4
42337: NEG
42338: PUSH
42339: LD_INT 0
42341: PUSH
42342: EMPTY
42343: LIST
42344: LIST
42345: PUSH
42346: LD_INT 4
42348: NEG
42349: PUSH
42350: LD_INT 1
42352: NEG
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 4
42360: NEG
42361: PUSH
42362: LD_INT 2
42364: NEG
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 2
42372: NEG
42373: PUSH
42374: LD_INT 2
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 4
42383: NEG
42384: PUSH
42385: LD_INT 4
42387: NEG
42388: PUSH
42389: EMPTY
42390: LIST
42391: LIST
42392: PUSH
42393: LD_INT 4
42395: NEG
42396: PUSH
42397: LD_INT 5
42399: NEG
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 3
42407: NEG
42408: PUSH
42409: LD_INT 4
42411: NEG
42412: PUSH
42413: EMPTY
42414: LIST
42415: LIST
42416: PUSH
42417: LD_INT 3
42419: NEG
42420: PUSH
42421: LD_INT 3
42423: NEG
42424: PUSH
42425: EMPTY
42426: LIST
42427: LIST
42428: PUSH
42429: LD_INT 4
42431: NEG
42432: PUSH
42433: LD_INT 3
42435: NEG
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PUSH
42441: LD_INT 5
42443: NEG
42444: PUSH
42445: LD_INT 4
42447: NEG
42448: PUSH
42449: EMPTY
42450: LIST
42451: LIST
42452: PUSH
42453: LD_INT 5
42455: NEG
42456: PUSH
42457: LD_INT 5
42459: NEG
42460: PUSH
42461: EMPTY
42462: LIST
42463: LIST
42464: PUSH
42465: LD_INT 3
42467: NEG
42468: PUSH
42469: LD_INT 5
42471: NEG
42472: PUSH
42473: EMPTY
42474: LIST
42475: LIST
42476: PUSH
42477: LD_INT 5
42479: NEG
42480: PUSH
42481: LD_INT 3
42483: NEG
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 0
42491: PUSH
42492: LD_INT 3
42494: NEG
42495: PUSH
42496: EMPTY
42497: LIST
42498: LIST
42499: PUSH
42500: LD_INT 0
42502: PUSH
42503: LD_INT 4
42505: NEG
42506: PUSH
42507: EMPTY
42508: LIST
42509: LIST
42510: PUSH
42511: LD_INT 1
42513: PUSH
42514: LD_INT 3
42516: NEG
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 1
42524: PUSH
42525: LD_INT 2
42527: NEG
42528: PUSH
42529: EMPTY
42530: LIST
42531: LIST
42532: PUSH
42533: LD_INT 0
42535: PUSH
42536: LD_INT 2
42538: NEG
42539: PUSH
42540: EMPTY
42541: LIST
42542: LIST
42543: PUSH
42544: LD_INT 1
42546: NEG
42547: PUSH
42548: LD_INT 3
42550: NEG
42551: PUSH
42552: EMPTY
42553: LIST
42554: LIST
42555: PUSH
42556: LD_INT 1
42558: NEG
42559: PUSH
42560: LD_INT 4
42562: NEG
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: PUSH
42568: LD_INT 2
42570: PUSH
42571: LD_INT 2
42573: NEG
42574: PUSH
42575: EMPTY
42576: LIST
42577: LIST
42578: PUSH
42579: LD_INT 2
42581: NEG
42582: PUSH
42583: LD_INT 4
42585: NEG
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: PUSH
42591: LD_INT 4
42593: PUSH
42594: LD_INT 0
42596: PUSH
42597: EMPTY
42598: LIST
42599: LIST
42600: PUSH
42601: LD_INT 4
42603: PUSH
42604: LD_INT 1
42606: NEG
42607: PUSH
42608: EMPTY
42609: LIST
42610: LIST
42611: PUSH
42612: LD_INT 5
42614: PUSH
42615: LD_INT 0
42617: PUSH
42618: EMPTY
42619: LIST
42620: LIST
42621: PUSH
42622: LD_INT 5
42624: PUSH
42625: LD_INT 1
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: LD_INT 4
42634: PUSH
42635: LD_INT 1
42637: PUSH
42638: EMPTY
42639: LIST
42640: LIST
42641: PUSH
42642: LD_INT 3
42644: PUSH
42645: LD_INT 0
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: PUSH
42652: LD_INT 3
42654: PUSH
42655: LD_INT 1
42657: NEG
42658: PUSH
42659: EMPTY
42660: LIST
42661: LIST
42662: PUSH
42663: LD_INT 3
42665: PUSH
42666: LD_INT 2
42668: NEG
42669: PUSH
42670: EMPTY
42671: LIST
42672: LIST
42673: PUSH
42674: LD_INT 5
42676: PUSH
42677: LD_INT 2
42679: PUSH
42680: EMPTY
42681: LIST
42682: LIST
42683: PUSH
42684: EMPTY
42685: LIST
42686: LIST
42687: LIST
42688: LIST
42689: LIST
42690: LIST
42691: LIST
42692: LIST
42693: LIST
42694: LIST
42695: LIST
42696: LIST
42697: LIST
42698: LIST
42699: LIST
42700: LIST
42701: LIST
42702: LIST
42703: LIST
42704: LIST
42705: LIST
42706: LIST
42707: LIST
42708: LIST
42709: LIST
42710: LIST
42711: LIST
42712: LIST
42713: LIST
42714: LIST
42715: LIST
42716: LIST
42717: LIST
42718: LIST
42719: LIST
42720: LIST
42721: LIST
42722: LIST
42723: LIST
42724: LIST
42725: LIST
42726: LIST
42727: LIST
42728: LIST
42729: LIST
42730: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
42731: LD_ADDR_VAR 0 32
42735: PUSH
42736: LD_INT 4
42738: NEG
42739: PUSH
42740: LD_INT 0
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PUSH
42747: LD_INT 4
42749: NEG
42750: PUSH
42751: LD_INT 1
42753: NEG
42754: PUSH
42755: EMPTY
42756: LIST
42757: LIST
42758: PUSH
42759: LD_INT 3
42761: NEG
42762: PUSH
42763: LD_INT 0
42765: PUSH
42766: EMPTY
42767: LIST
42768: LIST
42769: PUSH
42770: LD_INT 3
42772: NEG
42773: PUSH
42774: LD_INT 1
42776: PUSH
42777: EMPTY
42778: LIST
42779: LIST
42780: PUSH
42781: LD_INT 4
42783: NEG
42784: PUSH
42785: LD_INT 1
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: LD_INT 5
42794: NEG
42795: PUSH
42796: LD_INT 0
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 5
42805: NEG
42806: PUSH
42807: LD_INT 1
42809: NEG
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 5
42817: NEG
42818: PUSH
42819: LD_INT 2
42821: NEG
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: PUSH
42827: LD_INT 3
42829: NEG
42830: PUSH
42831: LD_INT 2
42833: PUSH
42834: EMPTY
42835: LIST
42836: LIST
42837: PUSH
42838: LD_INT 3
42840: NEG
42841: PUSH
42842: LD_INT 3
42844: NEG
42845: PUSH
42846: EMPTY
42847: LIST
42848: LIST
42849: PUSH
42850: LD_INT 3
42852: NEG
42853: PUSH
42854: LD_INT 4
42856: NEG
42857: PUSH
42858: EMPTY
42859: LIST
42860: LIST
42861: PUSH
42862: LD_INT 2
42864: NEG
42865: PUSH
42866: LD_INT 3
42868: NEG
42869: PUSH
42870: EMPTY
42871: LIST
42872: LIST
42873: PUSH
42874: LD_INT 2
42876: NEG
42877: PUSH
42878: LD_INT 2
42880: NEG
42881: PUSH
42882: EMPTY
42883: LIST
42884: LIST
42885: PUSH
42886: LD_INT 3
42888: NEG
42889: PUSH
42890: LD_INT 2
42892: NEG
42893: PUSH
42894: EMPTY
42895: LIST
42896: LIST
42897: PUSH
42898: LD_INT 4
42900: NEG
42901: PUSH
42902: LD_INT 3
42904: NEG
42905: PUSH
42906: EMPTY
42907: LIST
42908: LIST
42909: PUSH
42910: LD_INT 4
42912: NEG
42913: PUSH
42914: LD_INT 4
42916: NEG
42917: PUSH
42918: EMPTY
42919: LIST
42920: LIST
42921: PUSH
42922: LD_INT 2
42924: NEG
42925: PUSH
42926: LD_INT 4
42928: NEG
42929: PUSH
42930: EMPTY
42931: LIST
42932: LIST
42933: PUSH
42934: LD_INT 4
42936: NEG
42937: PUSH
42938: LD_INT 2
42940: NEG
42941: PUSH
42942: EMPTY
42943: LIST
42944: LIST
42945: PUSH
42946: LD_INT 0
42948: PUSH
42949: LD_INT 4
42951: NEG
42952: PUSH
42953: EMPTY
42954: LIST
42955: LIST
42956: PUSH
42957: LD_INT 0
42959: PUSH
42960: LD_INT 5
42962: NEG
42963: PUSH
42964: EMPTY
42965: LIST
42966: LIST
42967: PUSH
42968: LD_INT 1
42970: PUSH
42971: LD_INT 4
42973: NEG
42974: PUSH
42975: EMPTY
42976: LIST
42977: LIST
42978: PUSH
42979: LD_INT 1
42981: PUSH
42982: LD_INT 3
42984: NEG
42985: PUSH
42986: EMPTY
42987: LIST
42988: LIST
42989: PUSH
42990: LD_INT 0
42992: PUSH
42993: LD_INT 3
42995: NEG
42996: PUSH
42997: EMPTY
42998: LIST
42999: LIST
43000: PUSH
43001: LD_INT 1
43003: NEG
43004: PUSH
43005: LD_INT 4
43007: NEG
43008: PUSH
43009: EMPTY
43010: LIST
43011: LIST
43012: PUSH
43013: LD_INT 1
43015: NEG
43016: PUSH
43017: LD_INT 5
43019: NEG
43020: PUSH
43021: EMPTY
43022: LIST
43023: LIST
43024: PUSH
43025: LD_INT 2
43027: PUSH
43028: LD_INT 3
43030: NEG
43031: PUSH
43032: EMPTY
43033: LIST
43034: LIST
43035: PUSH
43036: LD_INT 2
43038: NEG
43039: PUSH
43040: LD_INT 5
43042: NEG
43043: PUSH
43044: EMPTY
43045: LIST
43046: LIST
43047: PUSH
43048: LD_INT 3
43050: PUSH
43051: LD_INT 0
43053: PUSH
43054: EMPTY
43055: LIST
43056: LIST
43057: PUSH
43058: LD_INT 3
43060: PUSH
43061: LD_INT 1
43063: NEG
43064: PUSH
43065: EMPTY
43066: LIST
43067: LIST
43068: PUSH
43069: LD_INT 4
43071: PUSH
43072: LD_INT 0
43074: PUSH
43075: EMPTY
43076: LIST
43077: LIST
43078: PUSH
43079: LD_INT 4
43081: PUSH
43082: LD_INT 1
43084: PUSH
43085: EMPTY
43086: LIST
43087: LIST
43088: PUSH
43089: LD_INT 3
43091: PUSH
43092: LD_INT 1
43094: PUSH
43095: EMPTY
43096: LIST
43097: LIST
43098: PUSH
43099: LD_INT 2
43101: PUSH
43102: LD_INT 0
43104: PUSH
43105: EMPTY
43106: LIST
43107: LIST
43108: PUSH
43109: LD_INT 2
43111: PUSH
43112: LD_INT 1
43114: NEG
43115: PUSH
43116: EMPTY
43117: LIST
43118: LIST
43119: PUSH
43120: LD_INT 2
43122: PUSH
43123: LD_INT 2
43125: NEG
43126: PUSH
43127: EMPTY
43128: LIST
43129: LIST
43130: PUSH
43131: LD_INT 4
43133: PUSH
43134: LD_INT 2
43136: PUSH
43137: EMPTY
43138: LIST
43139: LIST
43140: PUSH
43141: LD_INT 4
43143: PUSH
43144: LD_INT 4
43146: PUSH
43147: EMPTY
43148: LIST
43149: LIST
43150: PUSH
43151: LD_INT 4
43153: PUSH
43154: LD_INT 3
43156: PUSH
43157: EMPTY
43158: LIST
43159: LIST
43160: PUSH
43161: LD_INT 5
43163: PUSH
43164: LD_INT 4
43166: PUSH
43167: EMPTY
43168: LIST
43169: LIST
43170: PUSH
43171: LD_INT 5
43173: PUSH
43174: LD_INT 5
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: PUSH
43181: LD_INT 4
43183: PUSH
43184: LD_INT 5
43186: PUSH
43187: EMPTY
43188: LIST
43189: LIST
43190: PUSH
43191: LD_INT 3
43193: PUSH
43194: LD_INT 4
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PUSH
43201: LD_INT 3
43203: PUSH
43204: LD_INT 3
43206: PUSH
43207: EMPTY
43208: LIST
43209: LIST
43210: PUSH
43211: LD_INT 5
43213: PUSH
43214: LD_INT 3
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: LD_INT 3
43223: PUSH
43224: LD_INT 5
43226: PUSH
43227: EMPTY
43228: LIST
43229: LIST
43230: PUSH
43231: EMPTY
43232: LIST
43233: LIST
43234: LIST
43235: LIST
43236: LIST
43237: LIST
43238: LIST
43239: LIST
43240: LIST
43241: LIST
43242: LIST
43243: LIST
43244: LIST
43245: LIST
43246: LIST
43247: LIST
43248: LIST
43249: LIST
43250: LIST
43251: LIST
43252: LIST
43253: LIST
43254: LIST
43255: LIST
43256: LIST
43257: LIST
43258: LIST
43259: LIST
43260: LIST
43261: LIST
43262: LIST
43263: LIST
43264: LIST
43265: LIST
43266: LIST
43267: LIST
43268: LIST
43269: LIST
43270: LIST
43271: LIST
43272: LIST
43273: LIST
43274: LIST
43275: LIST
43276: LIST
43277: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
43278: LD_ADDR_VAR 0 33
43282: PUSH
43283: LD_INT 4
43285: NEG
43286: PUSH
43287: LD_INT 4
43289: NEG
43290: PUSH
43291: EMPTY
43292: LIST
43293: LIST
43294: PUSH
43295: LD_INT 4
43297: NEG
43298: PUSH
43299: LD_INT 5
43301: NEG
43302: PUSH
43303: EMPTY
43304: LIST
43305: LIST
43306: PUSH
43307: LD_INT 3
43309: NEG
43310: PUSH
43311: LD_INT 4
43313: NEG
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: PUSH
43319: LD_INT 3
43321: NEG
43322: PUSH
43323: LD_INT 3
43325: NEG
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: LD_INT 4
43333: NEG
43334: PUSH
43335: LD_INT 3
43337: NEG
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: LD_INT 5
43345: NEG
43346: PUSH
43347: LD_INT 4
43349: NEG
43350: PUSH
43351: EMPTY
43352: LIST
43353: LIST
43354: PUSH
43355: LD_INT 5
43357: NEG
43358: PUSH
43359: LD_INT 5
43361: NEG
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: PUSH
43367: LD_INT 3
43369: NEG
43370: PUSH
43371: LD_INT 5
43373: NEG
43374: PUSH
43375: EMPTY
43376: LIST
43377: LIST
43378: PUSH
43379: LD_INT 5
43381: NEG
43382: PUSH
43383: LD_INT 3
43385: NEG
43386: PUSH
43387: EMPTY
43388: LIST
43389: LIST
43390: PUSH
43391: LD_INT 0
43393: PUSH
43394: LD_INT 3
43396: NEG
43397: PUSH
43398: EMPTY
43399: LIST
43400: LIST
43401: PUSH
43402: LD_INT 0
43404: PUSH
43405: LD_INT 4
43407: NEG
43408: PUSH
43409: EMPTY
43410: LIST
43411: LIST
43412: PUSH
43413: LD_INT 1
43415: PUSH
43416: LD_INT 3
43418: NEG
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PUSH
43424: LD_INT 1
43426: PUSH
43427: LD_INT 2
43429: NEG
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PUSH
43435: LD_INT 0
43437: PUSH
43438: LD_INT 2
43440: NEG
43441: PUSH
43442: EMPTY
43443: LIST
43444: LIST
43445: PUSH
43446: LD_INT 1
43448: NEG
43449: PUSH
43450: LD_INT 3
43452: NEG
43453: PUSH
43454: EMPTY
43455: LIST
43456: LIST
43457: PUSH
43458: LD_INT 1
43460: NEG
43461: PUSH
43462: LD_INT 4
43464: NEG
43465: PUSH
43466: EMPTY
43467: LIST
43468: LIST
43469: PUSH
43470: LD_INT 2
43472: PUSH
43473: LD_INT 2
43475: NEG
43476: PUSH
43477: EMPTY
43478: LIST
43479: LIST
43480: PUSH
43481: LD_INT 2
43483: NEG
43484: PUSH
43485: LD_INT 4
43487: NEG
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: PUSH
43493: LD_INT 4
43495: PUSH
43496: LD_INT 0
43498: PUSH
43499: EMPTY
43500: LIST
43501: LIST
43502: PUSH
43503: LD_INT 4
43505: PUSH
43506: LD_INT 1
43508: NEG
43509: PUSH
43510: EMPTY
43511: LIST
43512: LIST
43513: PUSH
43514: LD_INT 5
43516: PUSH
43517: LD_INT 0
43519: PUSH
43520: EMPTY
43521: LIST
43522: LIST
43523: PUSH
43524: LD_INT 5
43526: PUSH
43527: LD_INT 1
43529: PUSH
43530: EMPTY
43531: LIST
43532: LIST
43533: PUSH
43534: LD_INT 4
43536: PUSH
43537: LD_INT 1
43539: PUSH
43540: EMPTY
43541: LIST
43542: LIST
43543: PUSH
43544: LD_INT 3
43546: PUSH
43547: LD_INT 0
43549: PUSH
43550: EMPTY
43551: LIST
43552: LIST
43553: PUSH
43554: LD_INT 3
43556: PUSH
43557: LD_INT 1
43559: NEG
43560: PUSH
43561: EMPTY
43562: LIST
43563: LIST
43564: PUSH
43565: LD_INT 3
43567: PUSH
43568: LD_INT 2
43570: NEG
43571: PUSH
43572: EMPTY
43573: LIST
43574: LIST
43575: PUSH
43576: LD_INT 5
43578: PUSH
43579: LD_INT 2
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: PUSH
43586: LD_INT 3
43588: PUSH
43589: LD_INT 3
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: PUSH
43596: LD_INT 3
43598: PUSH
43599: LD_INT 2
43601: PUSH
43602: EMPTY
43603: LIST
43604: LIST
43605: PUSH
43606: LD_INT 4
43608: PUSH
43609: LD_INT 3
43611: PUSH
43612: EMPTY
43613: LIST
43614: LIST
43615: PUSH
43616: LD_INT 4
43618: PUSH
43619: LD_INT 4
43621: PUSH
43622: EMPTY
43623: LIST
43624: LIST
43625: PUSH
43626: LD_INT 3
43628: PUSH
43629: LD_INT 4
43631: PUSH
43632: EMPTY
43633: LIST
43634: LIST
43635: PUSH
43636: LD_INT 2
43638: PUSH
43639: LD_INT 3
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: LD_INT 2
43648: PUSH
43649: LD_INT 2
43651: PUSH
43652: EMPTY
43653: LIST
43654: LIST
43655: PUSH
43656: LD_INT 4
43658: PUSH
43659: LD_INT 2
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: PUSH
43666: LD_INT 2
43668: PUSH
43669: LD_INT 4
43671: PUSH
43672: EMPTY
43673: LIST
43674: LIST
43675: PUSH
43676: LD_INT 0
43678: PUSH
43679: LD_INT 4
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: LD_INT 0
43688: PUSH
43689: LD_INT 3
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: LD_INT 1
43698: PUSH
43699: LD_INT 4
43701: PUSH
43702: EMPTY
43703: LIST
43704: LIST
43705: PUSH
43706: LD_INT 1
43708: PUSH
43709: LD_INT 5
43711: PUSH
43712: EMPTY
43713: LIST
43714: LIST
43715: PUSH
43716: LD_INT 0
43718: PUSH
43719: LD_INT 5
43721: PUSH
43722: EMPTY
43723: LIST
43724: LIST
43725: PUSH
43726: LD_INT 1
43728: NEG
43729: PUSH
43730: LD_INT 4
43732: PUSH
43733: EMPTY
43734: LIST
43735: LIST
43736: PUSH
43737: LD_INT 1
43739: NEG
43740: PUSH
43741: LD_INT 3
43743: PUSH
43744: EMPTY
43745: LIST
43746: LIST
43747: PUSH
43748: LD_INT 2
43750: PUSH
43751: LD_INT 5
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: PUSH
43758: LD_INT 2
43760: NEG
43761: PUSH
43762: LD_INT 3
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: EMPTY
43770: LIST
43771: LIST
43772: LIST
43773: LIST
43774: LIST
43775: LIST
43776: LIST
43777: LIST
43778: LIST
43779: LIST
43780: LIST
43781: LIST
43782: LIST
43783: LIST
43784: LIST
43785: LIST
43786: LIST
43787: LIST
43788: LIST
43789: LIST
43790: LIST
43791: LIST
43792: LIST
43793: LIST
43794: LIST
43795: LIST
43796: LIST
43797: LIST
43798: LIST
43799: LIST
43800: LIST
43801: LIST
43802: LIST
43803: LIST
43804: LIST
43805: LIST
43806: LIST
43807: LIST
43808: LIST
43809: LIST
43810: LIST
43811: LIST
43812: LIST
43813: LIST
43814: LIST
43815: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
43816: LD_ADDR_VAR 0 34
43820: PUSH
43821: LD_INT 0
43823: PUSH
43824: LD_INT 4
43826: NEG
43827: PUSH
43828: EMPTY
43829: LIST
43830: LIST
43831: PUSH
43832: LD_INT 0
43834: PUSH
43835: LD_INT 5
43837: NEG
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PUSH
43843: LD_INT 1
43845: PUSH
43846: LD_INT 4
43848: NEG
43849: PUSH
43850: EMPTY
43851: LIST
43852: LIST
43853: PUSH
43854: LD_INT 1
43856: PUSH
43857: LD_INT 3
43859: NEG
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 0
43867: PUSH
43868: LD_INT 3
43870: NEG
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 1
43878: NEG
43879: PUSH
43880: LD_INT 4
43882: NEG
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: LD_INT 1
43890: NEG
43891: PUSH
43892: LD_INT 5
43894: NEG
43895: PUSH
43896: EMPTY
43897: LIST
43898: LIST
43899: PUSH
43900: LD_INT 2
43902: PUSH
43903: LD_INT 3
43905: NEG
43906: PUSH
43907: EMPTY
43908: LIST
43909: LIST
43910: PUSH
43911: LD_INT 2
43913: NEG
43914: PUSH
43915: LD_INT 5
43917: NEG
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PUSH
43923: LD_INT 3
43925: PUSH
43926: LD_INT 0
43928: PUSH
43929: EMPTY
43930: LIST
43931: LIST
43932: PUSH
43933: LD_INT 3
43935: PUSH
43936: LD_INT 1
43938: NEG
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 4
43946: PUSH
43947: LD_INT 0
43949: PUSH
43950: EMPTY
43951: LIST
43952: LIST
43953: PUSH
43954: LD_INT 4
43956: PUSH
43957: LD_INT 1
43959: PUSH
43960: EMPTY
43961: LIST
43962: LIST
43963: PUSH
43964: LD_INT 3
43966: PUSH
43967: LD_INT 1
43969: PUSH
43970: EMPTY
43971: LIST
43972: LIST
43973: PUSH
43974: LD_INT 2
43976: PUSH
43977: LD_INT 0
43979: PUSH
43980: EMPTY
43981: LIST
43982: LIST
43983: PUSH
43984: LD_INT 2
43986: PUSH
43987: LD_INT 1
43989: NEG
43990: PUSH
43991: EMPTY
43992: LIST
43993: LIST
43994: PUSH
43995: LD_INT 2
43997: PUSH
43998: LD_INT 2
44000: NEG
44001: PUSH
44002: EMPTY
44003: LIST
44004: LIST
44005: PUSH
44006: LD_INT 4
44008: PUSH
44009: LD_INT 2
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: PUSH
44016: LD_INT 4
44018: PUSH
44019: LD_INT 4
44021: PUSH
44022: EMPTY
44023: LIST
44024: LIST
44025: PUSH
44026: LD_INT 4
44028: PUSH
44029: LD_INT 3
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: LD_INT 5
44038: PUSH
44039: LD_INT 4
44041: PUSH
44042: EMPTY
44043: LIST
44044: LIST
44045: PUSH
44046: LD_INT 5
44048: PUSH
44049: LD_INT 5
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: LD_INT 4
44058: PUSH
44059: LD_INT 5
44061: PUSH
44062: EMPTY
44063: LIST
44064: LIST
44065: PUSH
44066: LD_INT 3
44068: PUSH
44069: LD_INT 4
44071: PUSH
44072: EMPTY
44073: LIST
44074: LIST
44075: PUSH
44076: LD_INT 3
44078: PUSH
44079: LD_INT 3
44081: PUSH
44082: EMPTY
44083: LIST
44084: LIST
44085: PUSH
44086: LD_INT 5
44088: PUSH
44089: LD_INT 3
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: PUSH
44096: LD_INT 3
44098: PUSH
44099: LD_INT 5
44101: PUSH
44102: EMPTY
44103: LIST
44104: LIST
44105: PUSH
44106: LD_INT 0
44108: PUSH
44109: LD_INT 3
44111: PUSH
44112: EMPTY
44113: LIST
44114: LIST
44115: PUSH
44116: LD_INT 0
44118: PUSH
44119: LD_INT 2
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: PUSH
44126: LD_INT 1
44128: PUSH
44129: LD_INT 3
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: LD_INT 1
44138: PUSH
44139: LD_INT 4
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: PUSH
44146: LD_INT 0
44148: PUSH
44149: LD_INT 4
44151: PUSH
44152: EMPTY
44153: LIST
44154: LIST
44155: PUSH
44156: LD_INT 1
44158: NEG
44159: PUSH
44160: LD_INT 3
44162: PUSH
44163: EMPTY
44164: LIST
44165: LIST
44166: PUSH
44167: LD_INT 1
44169: NEG
44170: PUSH
44171: LD_INT 2
44173: PUSH
44174: EMPTY
44175: LIST
44176: LIST
44177: PUSH
44178: LD_INT 2
44180: PUSH
44181: LD_INT 4
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PUSH
44188: LD_INT 2
44190: NEG
44191: PUSH
44192: LD_INT 2
44194: PUSH
44195: EMPTY
44196: LIST
44197: LIST
44198: PUSH
44199: LD_INT 4
44201: NEG
44202: PUSH
44203: LD_INT 0
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 4
44212: NEG
44213: PUSH
44214: LD_INT 1
44216: NEG
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: PUSH
44222: LD_INT 3
44224: NEG
44225: PUSH
44226: LD_INT 0
44228: PUSH
44229: EMPTY
44230: LIST
44231: LIST
44232: PUSH
44233: LD_INT 3
44235: NEG
44236: PUSH
44237: LD_INT 1
44239: PUSH
44240: EMPTY
44241: LIST
44242: LIST
44243: PUSH
44244: LD_INT 4
44246: NEG
44247: PUSH
44248: LD_INT 1
44250: PUSH
44251: EMPTY
44252: LIST
44253: LIST
44254: PUSH
44255: LD_INT 5
44257: NEG
44258: PUSH
44259: LD_INT 0
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: PUSH
44266: LD_INT 5
44268: NEG
44269: PUSH
44270: LD_INT 1
44272: NEG
44273: PUSH
44274: EMPTY
44275: LIST
44276: LIST
44277: PUSH
44278: LD_INT 5
44280: NEG
44281: PUSH
44282: LD_INT 2
44284: NEG
44285: PUSH
44286: EMPTY
44287: LIST
44288: LIST
44289: PUSH
44290: LD_INT 3
44292: NEG
44293: PUSH
44294: LD_INT 2
44296: PUSH
44297: EMPTY
44298: LIST
44299: LIST
44300: PUSH
44301: EMPTY
44302: LIST
44303: LIST
44304: LIST
44305: LIST
44306: LIST
44307: LIST
44308: LIST
44309: LIST
44310: LIST
44311: LIST
44312: LIST
44313: LIST
44314: LIST
44315: LIST
44316: LIST
44317: LIST
44318: LIST
44319: LIST
44320: LIST
44321: LIST
44322: LIST
44323: LIST
44324: LIST
44325: LIST
44326: LIST
44327: LIST
44328: LIST
44329: LIST
44330: LIST
44331: LIST
44332: LIST
44333: LIST
44334: LIST
44335: LIST
44336: LIST
44337: LIST
44338: LIST
44339: LIST
44340: LIST
44341: LIST
44342: LIST
44343: LIST
44344: LIST
44345: LIST
44346: LIST
44347: ST_TO_ADDR
// end ; end ;
44348: GO 44351
44350: POP
// case btype of b_depot , b_warehouse :
44351: LD_VAR 0 1
44355: PUSH
44356: LD_INT 0
44358: DOUBLE
44359: EQUAL
44360: IFTRUE 44370
44362: LD_INT 1
44364: DOUBLE
44365: EQUAL
44366: IFTRUE 44370
44368: GO 44571
44370: POP
// case nation of nation_american :
44371: LD_VAR 0 5
44375: PUSH
44376: LD_INT 1
44378: DOUBLE
44379: EQUAL
44380: IFTRUE 44384
44382: GO 44440
44384: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
44385: LD_ADDR_VAR 0 9
44389: PUSH
44390: LD_VAR 0 11
44394: PUSH
44395: LD_VAR 0 12
44399: PUSH
44400: LD_VAR 0 13
44404: PUSH
44405: LD_VAR 0 14
44409: PUSH
44410: LD_VAR 0 15
44414: PUSH
44415: LD_VAR 0 16
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: LIST
44424: LIST
44425: LIST
44426: LIST
44427: PUSH
44428: LD_VAR 0 4
44432: PUSH
44433: LD_INT 1
44435: PLUS
44436: ARRAY
44437: ST_TO_ADDR
44438: GO 44569
44440: LD_INT 2
44442: DOUBLE
44443: EQUAL
44444: IFTRUE 44448
44446: GO 44504
44448: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
44449: LD_ADDR_VAR 0 9
44453: PUSH
44454: LD_VAR 0 17
44458: PUSH
44459: LD_VAR 0 18
44463: PUSH
44464: LD_VAR 0 19
44468: PUSH
44469: LD_VAR 0 20
44473: PUSH
44474: LD_VAR 0 21
44478: PUSH
44479: LD_VAR 0 22
44483: PUSH
44484: EMPTY
44485: LIST
44486: LIST
44487: LIST
44488: LIST
44489: LIST
44490: LIST
44491: PUSH
44492: LD_VAR 0 4
44496: PUSH
44497: LD_INT 1
44499: PLUS
44500: ARRAY
44501: ST_TO_ADDR
44502: GO 44569
44504: LD_INT 3
44506: DOUBLE
44507: EQUAL
44508: IFTRUE 44512
44510: GO 44568
44512: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
44513: LD_ADDR_VAR 0 9
44517: PUSH
44518: LD_VAR 0 23
44522: PUSH
44523: LD_VAR 0 24
44527: PUSH
44528: LD_VAR 0 25
44532: PUSH
44533: LD_VAR 0 26
44537: PUSH
44538: LD_VAR 0 27
44542: PUSH
44543: LD_VAR 0 28
44547: PUSH
44548: EMPTY
44549: LIST
44550: LIST
44551: LIST
44552: LIST
44553: LIST
44554: LIST
44555: PUSH
44556: LD_VAR 0 4
44560: PUSH
44561: LD_INT 1
44563: PLUS
44564: ARRAY
44565: ST_TO_ADDR
44566: GO 44569
44568: POP
44569: GO 45124
44571: LD_INT 2
44573: DOUBLE
44574: EQUAL
44575: IFTRUE 44585
44577: LD_INT 3
44579: DOUBLE
44580: EQUAL
44581: IFTRUE 44585
44583: GO 44641
44585: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
44586: LD_ADDR_VAR 0 9
44590: PUSH
44591: LD_VAR 0 29
44595: PUSH
44596: LD_VAR 0 30
44600: PUSH
44601: LD_VAR 0 31
44605: PUSH
44606: LD_VAR 0 32
44610: PUSH
44611: LD_VAR 0 33
44615: PUSH
44616: LD_VAR 0 34
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: LIST
44625: LIST
44626: LIST
44627: LIST
44628: PUSH
44629: LD_VAR 0 4
44633: PUSH
44634: LD_INT 1
44636: PLUS
44637: ARRAY
44638: ST_TO_ADDR
44639: GO 45124
44641: LD_INT 16
44643: DOUBLE
44644: EQUAL
44645: IFTRUE 44703
44647: LD_INT 17
44649: DOUBLE
44650: EQUAL
44651: IFTRUE 44703
44653: LD_INT 18
44655: DOUBLE
44656: EQUAL
44657: IFTRUE 44703
44659: LD_INT 19
44661: DOUBLE
44662: EQUAL
44663: IFTRUE 44703
44665: LD_INT 22
44667: DOUBLE
44668: EQUAL
44669: IFTRUE 44703
44671: LD_INT 20
44673: DOUBLE
44674: EQUAL
44675: IFTRUE 44703
44677: LD_INT 21
44679: DOUBLE
44680: EQUAL
44681: IFTRUE 44703
44683: LD_INT 23
44685: DOUBLE
44686: EQUAL
44687: IFTRUE 44703
44689: LD_INT 24
44691: DOUBLE
44692: EQUAL
44693: IFTRUE 44703
44695: LD_INT 25
44697: DOUBLE
44698: EQUAL
44699: IFTRUE 44703
44701: GO 44759
44703: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
44704: LD_ADDR_VAR 0 9
44708: PUSH
44709: LD_VAR 0 35
44713: PUSH
44714: LD_VAR 0 36
44718: PUSH
44719: LD_VAR 0 37
44723: PUSH
44724: LD_VAR 0 38
44728: PUSH
44729: LD_VAR 0 39
44733: PUSH
44734: LD_VAR 0 40
44738: PUSH
44739: EMPTY
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: LIST
44746: PUSH
44747: LD_VAR 0 4
44751: PUSH
44752: LD_INT 1
44754: PLUS
44755: ARRAY
44756: ST_TO_ADDR
44757: GO 45124
44759: LD_INT 6
44761: DOUBLE
44762: EQUAL
44763: IFTRUE 44815
44765: LD_INT 7
44767: DOUBLE
44768: EQUAL
44769: IFTRUE 44815
44771: LD_INT 8
44773: DOUBLE
44774: EQUAL
44775: IFTRUE 44815
44777: LD_INT 13
44779: DOUBLE
44780: EQUAL
44781: IFTRUE 44815
44783: LD_INT 12
44785: DOUBLE
44786: EQUAL
44787: IFTRUE 44815
44789: LD_INT 15
44791: DOUBLE
44792: EQUAL
44793: IFTRUE 44815
44795: LD_INT 11
44797: DOUBLE
44798: EQUAL
44799: IFTRUE 44815
44801: LD_INT 14
44803: DOUBLE
44804: EQUAL
44805: IFTRUE 44815
44807: LD_INT 10
44809: DOUBLE
44810: EQUAL
44811: IFTRUE 44815
44813: GO 44871
44815: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
44816: LD_ADDR_VAR 0 9
44820: PUSH
44821: LD_VAR 0 41
44825: PUSH
44826: LD_VAR 0 42
44830: PUSH
44831: LD_VAR 0 43
44835: PUSH
44836: LD_VAR 0 44
44840: PUSH
44841: LD_VAR 0 45
44845: PUSH
44846: LD_VAR 0 46
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: LIST
44855: LIST
44856: LIST
44857: LIST
44858: PUSH
44859: LD_VAR 0 4
44863: PUSH
44864: LD_INT 1
44866: PLUS
44867: ARRAY
44868: ST_TO_ADDR
44869: GO 45124
44871: LD_INT 36
44873: DOUBLE
44874: EQUAL
44875: IFTRUE 44879
44877: GO 44935
44879: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
44880: LD_ADDR_VAR 0 9
44884: PUSH
44885: LD_VAR 0 47
44889: PUSH
44890: LD_VAR 0 48
44894: PUSH
44895: LD_VAR 0 49
44899: PUSH
44900: LD_VAR 0 50
44904: PUSH
44905: LD_VAR 0 51
44909: PUSH
44910: LD_VAR 0 52
44914: PUSH
44915: EMPTY
44916: LIST
44917: LIST
44918: LIST
44919: LIST
44920: LIST
44921: LIST
44922: PUSH
44923: LD_VAR 0 4
44927: PUSH
44928: LD_INT 1
44930: PLUS
44931: ARRAY
44932: ST_TO_ADDR
44933: GO 45124
44935: LD_INT 4
44937: DOUBLE
44938: EQUAL
44939: IFTRUE 44961
44941: LD_INT 5
44943: DOUBLE
44944: EQUAL
44945: IFTRUE 44961
44947: LD_INT 34
44949: DOUBLE
44950: EQUAL
44951: IFTRUE 44961
44953: LD_INT 37
44955: DOUBLE
44956: EQUAL
44957: IFTRUE 44961
44959: GO 45017
44961: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
44962: LD_ADDR_VAR 0 9
44966: PUSH
44967: LD_VAR 0 53
44971: PUSH
44972: LD_VAR 0 54
44976: PUSH
44977: LD_VAR 0 55
44981: PUSH
44982: LD_VAR 0 56
44986: PUSH
44987: LD_VAR 0 57
44991: PUSH
44992: LD_VAR 0 58
44996: PUSH
44997: EMPTY
44998: LIST
44999: LIST
45000: LIST
45001: LIST
45002: LIST
45003: LIST
45004: PUSH
45005: LD_VAR 0 4
45009: PUSH
45010: LD_INT 1
45012: PLUS
45013: ARRAY
45014: ST_TO_ADDR
45015: GO 45124
45017: LD_INT 31
45019: DOUBLE
45020: EQUAL
45021: IFTRUE 45067
45023: LD_INT 32
45025: DOUBLE
45026: EQUAL
45027: IFTRUE 45067
45029: LD_INT 33
45031: DOUBLE
45032: EQUAL
45033: IFTRUE 45067
45035: LD_INT 27
45037: DOUBLE
45038: EQUAL
45039: IFTRUE 45067
45041: LD_INT 26
45043: DOUBLE
45044: EQUAL
45045: IFTRUE 45067
45047: LD_INT 28
45049: DOUBLE
45050: EQUAL
45051: IFTRUE 45067
45053: LD_INT 29
45055: DOUBLE
45056: EQUAL
45057: IFTRUE 45067
45059: LD_INT 30
45061: DOUBLE
45062: EQUAL
45063: IFTRUE 45067
45065: GO 45123
45067: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
45068: LD_ADDR_VAR 0 9
45072: PUSH
45073: LD_VAR 0 59
45077: PUSH
45078: LD_VAR 0 60
45082: PUSH
45083: LD_VAR 0 61
45087: PUSH
45088: LD_VAR 0 62
45092: PUSH
45093: LD_VAR 0 63
45097: PUSH
45098: LD_VAR 0 64
45102: PUSH
45103: EMPTY
45104: LIST
45105: LIST
45106: LIST
45107: LIST
45108: LIST
45109: LIST
45110: PUSH
45111: LD_VAR 0 4
45115: PUSH
45116: LD_INT 1
45118: PLUS
45119: ARRAY
45120: ST_TO_ADDR
45121: GO 45124
45123: POP
// temp_list2 = [ ] ;
45124: LD_ADDR_VAR 0 10
45128: PUSH
45129: EMPTY
45130: ST_TO_ADDR
// for i in temp_list do
45131: LD_ADDR_VAR 0 8
45135: PUSH
45136: LD_VAR 0 9
45140: PUSH
45141: FOR_IN
45142: IFFALSE 45194
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
45144: LD_ADDR_VAR 0 10
45148: PUSH
45149: LD_VAR 0 10
45153: PUSH
45154: LD_VAR 0 8
45158: PUSH
45159: LD_INT 1
45161: ARRAY
45162: PUSH
45163: LD_VAR 0 2
45167: PLUS
45168: PUSH
45169: LD_VAR 0 8
45173: PUSH
45174: LD_INT 2
45176: ARRAY
45177: PUSH
45178: LD_VAR 0 3
45182: PLUS
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: PUSH
45188: EMPTY
45189: LIST
45190: ADD
45191: ST_TO_ADDR
45192: GO 45141
45194: POP
45195: POP
// result = temp_list2 ;
45196: LD_ADDR_VAR 0 7
45200: PUSH
45201: LD_VAR 0 10
45205: ST_TO_ADDR
// end ;
45206: LD_VAR 0 7
45210: RET
// export function EnemyInRange ( unit , dist ) ; begin
45211: LD_INT 0
45213: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
45214: LD_ADDR_VAR 0 3
45218: PUSH
45219: LD_VAR 0 1
45223: PPUSH
45224: CALL_OW 255
45228: PPUSH
45229: LD_VAR 0 1
45233: PPUSH
45234: CALL_OW 250
45238: PPUSH
45239: LD_VAR 0 1
45243: PPUSH
45244: CALL_OW 251
45248: PPUSH
45249: LD_VAR 0 2
45253: PPUSH
45254: CALL 19315 0 4
45258: PUSH
45259: LD_INT 4
45261: ARRAY
45262: ST_TO_ADDR
// end ;
45263: LD_VAR 0 3
45267: RET
// export function PlayerSeeMe ( unit ) ; begin
45268: LD_INT 0
45270: PPUSH
// result := See ( your_side , unit ) ;
45271: LD_ADDR_VAR 0 2
45275: PUSH
45276: LD_OWVAR 2
45280: PPUSH
45281: LD_VAR 0 1
45285: PPUSH
45286: CALL_OW 292
45290: ST_TO_ADDR
// end ;
45291: LD_VAR 0 2
45295: RET
// export function ReverseDir ( unit ) ; begin
45296: LD_INT 0
45298: PPUSH
// if not unit then
45299: LD_VAR 0 1
45303: NOT
45304: IFFALSE 45308
// exit ;
45306: GO 45331
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
45308: LD_ADDR_VAR 0 2
45312: PUSH
45313: LD_VAR 0 1
45317: PPUSH
45318: CALL_OW 254
45322: PUSH
45323: LD_INT 3
45325: PLUS
45326: PUSH
45327: LD_INT 6
45329: MOD
45330: ST_TO_ADDR
// end ;
45331: LD_VAR 0 2
45335: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
45336: LD_INT 0
45338: PPUSH
45339: PPUSH
45340: PPUSH
45341: PPUSH
45342: PPUSH
// if not hexes then
45343: LD_VAR 0 2
45347: NOT
45348: IFFALSE 45352
// exit ;
45350: GO 45500
// dist := 9999 ;
45352: LD_ADDR_VAR 0 5
45356: PUSH
45357: LD_INT 9999
45359: ST_TO_ADDR
// for i = 1 to hexes do
45360: LD_ADDR_VAR 0 4
45364: PUSH
45365: DOUBLE
45366: LD_INT 1
45368: DEC
45369: ST_TO_ADDR
45370: LD_VAR 0 2
45374: PUSH
45375: FOR_TO
45376: IFFALSE 45488
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
45378: LD_VAR 0 1
45382: PPUSH
45383: LD_VAR 0 2
45387: PUSH
45388: LD_VAR 0 4
45392: ARRAY
45393: PUSH
45394: LD_INT 1
45396: ARRAY
45397: PPUSH
45398: LD_VAR 0 2
45402: PUSH
45403: LD_VAR 0 4
45407: ARRAY
45408: PUSH
45409: LD_INT 2
45411: ARRAY
45412: PPUSH
45413: CALL_OW 297
45417: PUSH
45418: LD_VAR 0 5
45422: LESS
45423: IFFALSE 45486
// begin hex := hexes [ i ] ;
45425: LD_ADDR_VAR 0 7
45429: PUSH
45430: LD_VAR 0 2
45434: PUSH
45435: LD_VAR 0 4
45439: ARRAY
45440: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
45441: LD_ADDR_VAR 0 5
45445: PUSH
45446: LD_VAR 0 1
45450: PPUSH
45451: LD_VAR 0 2
45455: PUSH
45456: LD_VAR 0 4
45460: ARRAY
45461: PUSH
45462: LD_INT 1
45464: ARRAY
45465: PPUSH
45466: LD_VAR 0 2
45470: PUSH
45471: LD_VAR 0 4
45475: ARRAY
45476: PUSH
45477: LD_INT 2
45479: ARRAY
45480: PPUSH
45481: CALL_OW 297
45485: ST_TO_ADDR
// end ; end ;
45486: GO 45375
45488: POP
45489: POP
// result := hex ;
45490: LD_ADDR_VAR 0 3
45494: PUSH
45495: LD_VAR 0 7
45499: ST_TO_ADDR
// end ;
45500: LD_VAR 0 3
45504: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
45505: LD_INT 0
45507: PPUSH
45508: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
45509: LD_VAR 0 1
45513: NOT
45514: PUSH
45515: LD_VAR 0 1
45519: PUSH
45520: LD_INT 21
45522: PUSH
45523: LD_INT 2
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: PUSH
45530: LD_INT 23
45532: PUSH
45533: LD_INT 2
45535: PUSH
45536: EMPTY
45537: LIST
45538: LIST
45539: PUSH
45540: EMPTY
45541: LIST
45542: LIST
45543: PPUSH
45544: CALL_OW 69
45548: IN
45549: NOT
45550: OR
45551: IFFALSE 45555
// exit ;
45553: GO 45602
// for i = 1 to 3 do
45555: LD_ADDR_VAR 0 3
45559: PUSH
45560: DOUBLE
45561: LD_INT 1
45563: DEC
45564: ST_TO_ADDR
45565: LD_INT 3
45567: PUSH
45568: FOR_TO
45569: IFFALSE 45600
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
45571: LD_VAR 0 1
45575: PPUSH
45576: CALL_OW 250
45580: PPUSH
45581: LD_VAR 0 1
45585: PPUSH
45586: CALL_OW 251
45590: PPUSH
45591: LD_INT 1
45593: PPUSH
45594: CALL_OW 453
45598: GO 45568
45600: POP
45601: POP
// end ;
45602: LD_VAR 0 2
45606: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
45607: LD_INT 0
45609: PPUSH
45610: PPUSH
45611: PPUSH
45612: PPUSH
45613: PPUSH
45614: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
45615: LD_VAR 0 1
45619: NOT
45620: PUSH
45621: LD_VAR 0 2
45625: NOT
45626: OR
45627: PUSH
45628: LD_VAR 0 1
45632: PPUSH
45633: CALL_OW 314
45637: OR
45638: IFFALSE 45642
// exit ;
45640: GO 46083
// x := GetX ( enemy_unit ) ;
45642: LD_ADDR_VAR 0 7
45646: PUSH
45647: LD_VAR 0 2
45651: PPUSH
45652: CALL_OW 250
45656: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
45657: LD_ADDR_VAR 0 8
45661: PUSH
45662: LD_VAR 0 2
45666: PPUSH
45667: CALL_OW 251
45671: ST_TO_ADDR
// if not x or not y then
45672: LD_VAR 0 7
45676: NOT
45677: PUSH
45678: LD_VAR 0 8
45682: NOT
45683: OR
45684: IFFALSE 45688
// exit ;
45686: GO 46083
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
45688: LD_ADDR_VAR 0 6
45692: PUSH
45693: LD_VAR 0 7
45697: PPUSH
45698: LD_INT 0
45700: PPUSH
45701: LD_INT 4
45703: PPUSH
45704: CALL_OW 272
45708: PUSH
45709: LD_VAR 0 8
45713: PPUSH
45714: LD_INT 0
45716: PPUSH
45717: LD_INT 4
45719: PPUSH
45720: CALL_OW 273
45724: PUSH
45725: EMPTY
45726: LIST
45727: LIST
45728: PUSH
45729: LD_VAR 0 7
45733: PPUSH
45734: LD_INT 1
45736: PPUSH
45737: LD_INT 4
45739: PPUSH
45740: CALL_OW 272
45744: PUSH
45745: LD_VAR 0 8
45749: PPUSH
45750: LD_INT 1
45752: PPUSH
45753: LD_INT 4
45755: PPUSH
45756: CALL_OW 273
45760: PUSH
45761: EMPTY
45762: LIST
45763: LIST
45764: PUSH
45765: LD_VAR 0 7
45769: PPUSH
45770: LD_INT 2
45772: PPUSH
45773: LD_INT 4
45775: PPUSH
45776: CALL_OW 272
45780: PUSH
45781: LD_VAR 0 8
45785: PPUSH
45786: LD_INT 2
45788: PPUSH
45789: LD_INT 4
45791: PPUSH
45792: CALL_OW 273
45796: PUSH
45797: EMPTY
45798: LIST
45799: LIST
45800: PUSH
45801: LD_VAR 0 7
45805: PPUSH
45806: LD_INT 3
45808: PPUSH
45809: LD_INT 4
45811: PPUSH
45812: CALL_OW 272
45816: PUSH
45817: LD_VAR 0 8
45821: PPUSH
45822: LD_INT 3
45824: PPUSH
45825: LD_INT 4
45827: PPUSH
45828: CALL_OW 273
45832: PUSH
45833: EMPTY
45834: LIST
45835: LIST
45836: PUSH
45837: LD_VAR 0 7
45841: PPUSH
45842: LD_INT 4
45844: PPUSH
45845: LD_INT 4
45847: PPUSH
45848: CALL_OW 272
45852: PUSH
45853: LD_VAR 0 8
45857: PPUSH
45858: LD_INT 4
45860: PPUSH
45861: LD_INT 4
45863: PPUSH
45864: CALL_OW 273
45868: PUSH
45869: EMPTY
45870: LIST
45871: LIST
45872: PUSH
45873: LD_VAR 0 7
45877: PPUSH
45878: LD_INT 5
45880: PPUSH
45881: LD_INT 4
45883: PPUSH
45884: CALL_OW 272
45888: PUSH
45889: LD_VAR 0 8
45893: PPUSH
45894: LD_INT 5
45896: PPUSH
45897: LD_INT 4
45899: PPUSH
45900: CALL_OW 273
45904: PUSH
45905: EMPTY
45906: LIST
45907: LIST
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: LIST
45913: LIST
45914: LIST
45915: LIST
45916: ST_TO_ADDR
// for i = tmp downto 1 do
45917: LD_ADDR_VAR 0 4
45921: PUSH
45922: DOUBLE
45923: LD_VAR 0 6
45927: INC
45928: ST_TO_ADDR
45929: LD_INT 1
45931: PUSH
45932: FOR_DOWNTO
45933: IFFALSE 46034
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
45935: LD_VAR 0 6
45939: PUSH
45940: LD_VAR 0 4
45944: ARRAY
45945: PUSH
45946: LD_INT 1
45948: ARRAY
45949: PPUSH
45950: LD_VAR 0 6
45954: PUSH
45955: LD_VAR 0 4
45959: ARRAY
45960: PUSH
45961: LD_INT 2
45963: ARRAY
45964: PPUSH
45965: CALL_OW 488
45969: NOT
45970: PUSH
45971: LD_VAR 0 6
45975: PUSH
45976: LD_VAR 0 4
45980: ARRAY
45981: PUSH
45982: LD_INT 1
45984: ARRAY
45985: PPUSH
45986: LD_VAR 0 6
45990: PUSH
45991: LD_VAR 0 4
45995: ARRAY
45996: PUSH
45997: LD_INT 2
45999: ARRAY
46000: PPUSH
46001: CALL_OW 428
46005: PUSH
46006: LD_INT 0
46008: NONEQUAL
46009: OR
46010: IFFALSE 46032
// tmp := Delete ( tmp , i ) ;
46012: LD_ADDR_VAR 0 6
46016: PUSH
46017: LD_VAR 0 6
46021: PPUSH
46022: LD_VAR 0 4
46026: PPUSH
46027: CALL_OW 3
46031: ST_TO_ADDR
46032: GO 45932
46034: POP
46035: POP
// j := GetClosestHex ( unit , tmp ) ;
46036: LD_ADDR_VAR 0 5
46040: PUSH
46041: LD_VAR 0 1
46045: PPUSH
46046: LD_VAR 0 6
46050: PPUSH
46051: CALL 45336 0 2
46055: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46056: LD_VAR 0 1
46060: PPUSH
46061: LD_VAR 0 5
46065: PUSH
46066: LD_INT 1
46068: ARRAY
46069: PPUSH
46070: LD_VAR 0 5
46074: PUSH
46075: LD_INT 2
46077: ARRAY
46078: PPUSH
46079: CALL_OW 111
// end ;
46083: LD_VAR 0 3
46087: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46088: LD_INT 0
46090: PPUSH
46091: PPUSH
46092: PPUSH
// uc_side = 0 ;
46093: LD_ADDR_OWVAR 20
46097: PUSH
46098: LD_INT 0
46100: ST_TO_ADDR
// uc_nation = 0 ;
46101: LD_ADDR_OWVAR 21
46105: PUSH
46106: LD_INT 0
46108: ST_TO_ADDR
// InitHc ;
46109: CALL_OW 19
// InitVc ;
46113: CALL_OW 20
// if mastodonts then
46117: LD_VAR 0 6
46121: IFFALSE 46188
// for i = 1 to mastodonts do
46123: LD_ADDR_VAR 0 11
46127: PUSH
46128: DOUBLE
46129: LD_INT 1
46131: DEC
46132: ST_TO_ADDR
46133: LD_VAR 0 6
46137: PUSH
46138: FOR_TO
46139: IFFALSE 46186
// begin vc_chassis := 31 ;
46141: LD_ADDR_OWVAR 37
46145: PUSH
46146: LD_INT 31
46148: ST_TO_ADDR
// vc_control := control_rider ;
46149: LD_ADDR_OWVAR 38
46153: PUSH
46154: LD_INT 4
46156: ST_TO_ADDR
// animal := CreateVehicle ;
46157: LD_ADDR_VAR 0 12
46161: PUSH
46162: CALL_OW 45
46166: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46167: LD_VAR 0 12
46171: PPUSH
46172: LD_VAR 0 8
46176: PPUSH
46177: LD_INT 0
46179: PPUSH
46180: CALL 52966 0 3
// end ;
46184: GO 46138
46186: POP
46187: POP
// if horses then
46188: LD_VAR 0 5
46192: IFFALSE 46259
// for i = 1 to horses do
46194: LD_ADDR_VAR 0 11
46198: PUSH
46199: DOUBLE
46200: LD_INT 1
46202: DEC
46203: ST_TO_ADDR
46204: LD_VAR 0 5
46208: PUSH
46209: FOR_TO
46210: IFFALSE 46257
// begin hc_class := 21 ;
46212: LD_ADDR_OWVAR 28
46216: PUSH
46217: LD_INT 21
46219: ST_TO_ADDR
// hc_gallery :=  ;
46220: LD_ADDR_OWVAR 33
46224: PUSH
46225: LD_STRING 
46227: ST_TO_ADDR
// animal := CreateHuman ;
46228: LD_ADDR_VAR 0 12
46232: PUSH
46233: CALL_OW 44
46237: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46238: LD_VAR 0 12
46242: PPUSH
46243: LD_VAR 0 8
46247: PPUSH
46248: LD_INT 0
46250: PPUSH
46251: CALL 52966 0 3
// end ;
46255: GO 46209
46257: POP
46258: POP
// if birds then
46259: LD_VAR 0 1
46263: IFFALSE 46330
// for i = 1 to birds do
46265: LD_ADDR_VAR 0 11
46269: PUSH
46270: DOUBLE
46271: LD_INT 1
46273: DEC
46274: ST_TO_ADDR
46275: LD_VAR 0 1
46279: PUSH
46280: FOR_TO
46281: IFFALSE 46328
// begin hc_class = 18 ;
46283: LD_ADDR_OWVAR 28
46287: PUSH
46288: LD_INT 18
46290: ST_TO_ADDR
// hc_gallery =  ;
46291: LD_ADDR_OWVAR 33
46295: PUSH
46296: LD_STRING 
46298: ST_TO_ADDR
// animal := CreateHuman ;
46299: LD_ADDR_VAR 0 12
46303: PUSH
46304: CALL_OW 44
46308: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46309: LD_VAR 0 12
46313: PPUSH
46314: LD_VAR 0 8
46318: PPUSH
46319: LD_INT 0
46321: PPUSH
46322: CALL 52966 0 3
// end ;
46326: GO 46280
46328: POP
46329: POP
// if tigers then
46330: LD_VAR 0 2
46334: IFFALSE 46418
// for i = 1 to tigers do
46336: LD_ADDR_VAR 0 11
46340: PUSH
46341: DOUBLE
46342: LD_INT 1
46344: DEC
46345: ST_TO_ADDR
46346: LD_VAR 0 2
46350: PUSH
46351: FOR_TO
46352: IFFALSE 46416
// begin hc_class = class_tiger ;
46354: LD_ADDR_OWVAR 28
46358: PUSH
46359: LD_INT 14
46361: ST_TO_ADDR
// hc_gallery =  ;
46362: LD_ADDR_OWVAR 33
46366: PUSH
46367: LD_STRING 
46369: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
46370: LD_ADDR_OWVAR 35
46374: PUSH
46375: LD_INT 7
46377: NEG
46378: PPUSH
46379: LD_INT 7
46381: PPUSH
46382: CALL_OW 12
46386: ST_TO_ADDR
// animal := CreateHuman ;
46387: LD_ADDR_VAR 0 12
46391: PUSH
46392: CALL_OW 44
46396: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46397: LD_VAR 0 12
46401: PPUSH
46402: LD_VAR 0 8
46406: PPUSH
46407: LD_INT 0
46409: PPUSH
46410: CALL 52966 0 3
// end ;
46414: GO 46351
46416: POP
46417: POP
// if apemans then
46418: LD_VAR 0 3
46422: IFFALSE 46545
// for i = 1 to apemans do
46424: LD_ADDR_VAR 0 11
46428: PUSH
46429: DOUBLE
46430: LD_INT 1
46432: DEC
46433: ST_TO_ADDR
46434: LD_VAR 0 3
46438: PUSH
46439: FOR_TO
46440: IFFALSE 46543
// begin hc_class = class_apeman ;
46442: LD_ADDR_OWVAR 28
46446: PUSH
46447: LD_INT 12
46449: ST_TO_ADDR
// hc_gallery =  ;
46450: LD_ADDR_OWVAR 33
46454: PUSH
46455: LD_STRING 
46457: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
46458: LD_ADDR_OWVAR 35
46462: PUSH
46463: LD_INT 5
46465: NEG
46466: PPUSH
46467: LD_INT 5
46469: PPUSH
46470: CALL_OW 12
46474: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
46475: LD_ADDR_OWVAR 31
46479: PUSH
46480: LD_INT 1
46482: PPUSH
46483: LD_INT 3
46485: PPUSH
46486: CALL_OW 12
46490: PUSH
46491: LD_INT 1
46493: PPUSH
46494: LD_INT 3
46496: PPUSH
46497: CALL_OW 12
46501: PUSH
46502: LD_INT 0
46504: PUSH
46505: LD_INT 0
46507: PUSH
46508: EMPTY
46509: LIST
46510: LIST
46511: LIST
46512: LIST
46513: ST_TO_ADDR
// animal := CreateHuman ;
46514: LD_ADDR_VAR 0 12
46518: PUSH
46519: CALL_OW 44
46523: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46524: LD_VAR 0 12
46528: PPUSH
46529: LD_VAR 0 8
46533: PPUSH
46534: LD_INT 0
46536: PPUSH
46537: CALL 52966 0 3
// end ;
46541: GO 46439
46543: POP
46544: POP
// if enchidnas then
46545: LD_VAR 0 4
46549: IFFALSE 46616
// for i = 1 to enchidnas do
46551: LD_ADDR_VAR 0 11
46555: PUSH
46556: DOUBLE
46557: LD_INT 1
46559: DEC
46560: ST_TO_ADDR
46561: LD_VAR 0 4
46565: PUSH
46566: FOR_TO
46567: IFFALSE 46614
// begin hc_class = 13 ;
46569: LD_ADDR_OWVAR 28
46573: PUSH
46574: LD_INT 13
46576: ST_TO_ADDR
// hc_gallery =  ;
46577: LD_ADDR_OWVAR 33
46581: PUSH
46582: LD_STRING 
46584: ST_TO_ADDR
// animal := CreateHuman ;
46585: LD_ADDR_VAR 0 12
46589: PUSH
46590: CALL_OW 44
46594: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46595: LD_VAR 0 12
46599: PPUSH
46600: LD_VAR 0 8
46604: PPUSH
46605: LD_INT 0
46607: PPUSH
46608: CALL 52966 0 3
// end ;
46612: GO 46566
46614: POP
46615: POP
// if fishes then
46616: LD_VAR 0 7
46620: IFFALSE 46687
// for i = 1 to fishes do
46622: LD_ADDR_VAR 0 11
46626: PUSH
46627: DOUBLE
46628: LD_INT 1
46630: DEC
46631: ST_TO_ADDR
46632: LD_VAR 0 7
46636: PUSH
46637: FOR_TO
46638: IFFALSE 46685
// begin hc_class = 20 ;
46640: LD_ADDR_OWVAR 28
46644: PUSH
46645: LD_INT 20
46647: ST_TO_ADDR
// hc_gallery =  ;
46648: LD_ADDR_OWVAR 33
46652: PUSH
46653: LD_STRING 
46655: ST_TO_ADDR
// animal := CreateHuman ;
46656: LD_ADDR_VAR 0 12
46660: PUSH
46661: CALL_OW 44
46665: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
46666: LD_VAR 0 12
46670: PPUSH
46671: LD_VAR 0 9
46675: PPUSH
46676: LD_INT 0
46678: PPUSH
46679: CALL 52966 0 3
// end ;
46683: GO 46637
46685: POP
46686: POP
// end ;
46687: LD_VAR 0 10
46691: RET
// export function WantHeal ( sci , unit ) ; begin
46692: LD_INT 0
46694: PPUSH
// if GetTaskList ( sci ) > 0 then
46695: LD_VAR 0 1
46699: PPUSH
46700: CALL_OW 437
46704: PUSH
46705: LD_INT 0
46707: GREATER
46708: IFFALSE 46778
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
46710: LD_VAR 0 1
46714: PPUSH
46715: CALL_OW 437
46719: PUSH
46720: LD_INT 1
46722: ARRAY
46723: PUSH
46724: LD_INT 1
46726: ARRAY
46727: PUSH
46728: LD_STRING l
46730: EQUAL
46731: PUSH
46732: LD_VAR 0 1
46736: PPUSH
46737: CALL_OW 437
46741: PUSH
46742: LD_INT 1
46744: ARRAY
46745: PUSH
46746: LD_INT 4
46748: ARRAY
46749: PUSH
46750: LD_VAR 0 2
46754: EQUAL
46755: AND
46756: IFFALSE 46768
// result := true else
46758: LD_ADDR_VAR 0 3
46762: PUSH
46763: LD_INT 1
46765: ST_TO_ADDR
46766: GO 46776
// result := false ;
46768: LD_ADDR_VAR 0 3
46772: PUSH
46773: LD_INT 0
46775: ST_TO_ADDR
// end else
46776: GO 46786
// result := false ;
46778: LD_ADDR_VAR 0 3
46782: PUSH
46783: LD_INT 0
46785: ST_TO_ADDR
// end ;
46786: LD_VAR 0 3
46790: RET
// export function HealTarget ( sci ) ; begin
46791: LD_INT 0
46793: PPUSH
// if not sci then
46794: LD_VAR 0 1
46798: NOT
46799: IFFALSE 46803
// exit ;
46801: GO 46868
// result := 0 ;
46803: LD_ADDR_VAR 0 2
46807: PUSH
46808: LD_INT 0
46810: ST_TO_ADDR
// if GetTaskList ( sci ) then
46811: LD_VAR 0 1
46815: PPUSH
46816: CALL_OW 437
46820: IFFALSE 46868
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
46822: LD_VAR 0 1
46826: PPUSH
46827: CALL_OW 437
46831: PUSH
46832: LD_INT 1
46834: ARRAY
46835: PUSH
46836: LD_INT 1
46838: ARRAY
46839: PUSH
46840: LD_STRING l
46842: EQUAL
46843: IFFALSE 46868
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
46845: LD_ADDR_VAR 0 2
46849: PUSH
46850: LD_VAR 0 1
46854: PPUSH
46855: CALL_OW 437
46859: PUSH
46860: LD_INT 1
46862: ARRAY
46863: PUSH
46864: LD_INT 4
46866: ARRAY
46867: ST_TO_ADDR
// end ;
46868: LD_VAR 0 2
46872: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
46873: LD_INT 0
46875: PPUSH
46876: PPUSH
46877: PPUSH
46878: PPUSH
46879: PPUSH
46880: PPUSH
46881: PPUSH
46882: PPUSH
46883: PPUSH
46884: PPUSH
46885: PPUSH
46886: PPUSH
46887: PPUSH
46888: PPUSH
46889: PPUSH
46890: PPUSH
46891: PPUSH
46892: PPUSH
46893: PPUSH
46894: PPUSH
46895: PPUSH
46896: PPUSH
46897: PPUSH
46898: PPUSH
46899: PPUSH
46900: PPUSH
46901: PPUSH
46902: PPUSH
46903: PPUSH
46904: PPUSH
46905: PPUSH
46906: PPUSH
46907: PPUSH
46908: PPUSH
// if not list then
46909: LD_VAR 0 1
46913: NOT
46914: IFFALSE 46918
// exit ;
46916: GO 51577
// base := list [ 1 ] ;
46918: LD_ADDR_VAR 0 3
46922: PUSH
46923: LD_VAR 0 1
46927: PUSH
46928: LD_INT 1
46930: ARRAY
46931: ST_TO_ADDR
// group := list [ 2 ] ;
46932: LD_ADDR_VAR 0 4
46936: PUSH
46937: LD_VAR 0 1
46941: PUSH
46942: LD_INT 2
46944: ARRAY
46945: ST_TO_ADDR
// path := list [ 3 ] ;
46946: LD_ADDR_VAR 0 5
46950: PUSH
46951: LD_VAR 0 1
46955: PUSH
46956: LD_INT 3
46958: ARRAY
46959: ST_TO_ADDR
// flags := list [ 4 ] ;
46960: LD_ADDR_VAR 0 6
46964: PUSH
46965: LD_VAR 0 1
46969: PUSH
46970: LD_INT 4
46972: ARRAY
46973: ST_TO_ADDR
// mined := [ ] ;
46974: LD_ADDR_VAR 0 27
46978: PUSH
46979: EMPTY
46980: ST_TO_ADDR
// bombed := [ ] ;
46981: LD_ADDR_VAR 0 28
46985: PUSH
46986: EMPTY
46987: ST_TO_ADDR
// healers := [ ] ;
46988: LD_ADDR_VAR 0 31
46992: PUSH
46993: EMPTY
46994: ST_TO_ADDR
// to_heal := [ ] ;
46995: LD_ADDR_VAR 0 30
46999: PUSH
47000: EMPTY
47001: ST_TO_ADDR
// repairs := [ ] ;
47002: LD_ADDR_VAR 0 33
47006: PUSH
47007: EMPTY
47008: ST_TO_ADDR
// to_repair := [ ] ;
47009: LD_ADDR_VAR 0 32
47013: PUSH
47014: EMPTY
47015: ST_TO_ADDR
// if not group or not path then
47016: LD_VAR 0 4
47020: NOT
47021: PUSH
47022: LD_VAR 0 5
47026: NOT
47027: OR
47028: IFFALSE 47032
// exit ;
47030: GO 51577
// side := GetSide ( group [ 1 ] ) ;
47032: LD_ADDR_VAR 0 35
47036: PUSH
47037: LD_VAR 0 4
47041: PUSH
47042: LD_INT 1
47044: ARRAY
47045: PPUSH
47046: CALL_OW 255
47050: ST_TO_ADDR
// if flags then
47051: LD_VAR 0 6
47055: IFFALSE 47199
// begin f_ignore_area := flags [ 1 ] ;
47057: LD_ADDR_VAR 0 17
47061: PUSH
47062: LD_VAR 0 6
47066: PUSH
47067: LD_INT 1
47069: ARRAY
47070: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
47071: LD_ADDR_VAR 0 18
47075: PUSH
47076: LD_VAR 0 6
47080: PUSH
47081: LD_INT 2
47083: ARRAY
47084: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
47085: LD_ADDR_VAR 0 19
47089: PUSH
47090: LD_VAR 0 6
47094: PUSH
47095: LD_INT 3
47097: ARRAY
47098: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
47099: LD_ADDR_VAR 0 20
47103: PUSH
47104: LD_VAR 0 6
47108: PUSH
47109: LD_INT 4
47111: ARRAY
47112: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
47113: LD_ADDR_VAR 0 21
47117: PUSH
47118: LD_VAR 0 6
47122: PUSH
47123: LD_INT 5
47125: ARRAY
47126: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
47127: LD_ADDR_VAR 0 22
47131: PUSH
47132: LD_VAR 0 6
47136: PUSH
47137: LD_INT 6
47139: ARRAY
47140: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
47141: LD_ADDR_VAR 0 23
47145: PUSH
47146: LD_VAR 0 6
47150: PUSH
47151: LD_INT 7
47153: ARRAY
47154: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
47155: LD_ADDR_VAR 0 24
47159: PUSH
47160: LD_VAR 0 6
47164: PUSH
47165: LD_INT 8
47167: ARRAY
47168: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
47169: LD_ADDR_VAR 0 25
47173: PUSH
47174: LD_VAR 0 6
47178: PUSH
47179: LD_INT 9
47181: ARRAY
47182: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
47183: LD_ADDR_VAR 0 26
47187: PUSH
47188: LD_VAR 0 6
47192: PUSH
47193: LD_INT 10
47195: ARRAY
47196: ST_TO_ADDR
// end else
47197: GO 47279
// begin f_ignore_area := false ;
47199: LD_ADDR_VAR 0 17
47203: PUSH
47204: LD_INT 0
47206: ST_TO_ADDR
// f_capture := false ;
47207: LD_ADDR_VAR 0 18
47211: PUSH
47212: LD_INT 0
47214: ST_TO_ADDR
// f_ignore_civ := false ;
47215: LD_ADDR_VAR 0 19
47219: PUSH
47220: LD_INT 0
47222: ST_TO_ADDR
// f_murder := false ;
47223: LD_ADDR_VAR 0 20
47227: PUSH
47228: LD_INT 0
47230: ST_TO_ADDR
// f_mines := false ;
47231: LD_ADDR_VAR 0 21
47235: PUSH
47236: LD_INT 0
47238: ST_TO_ADDR
// f_repair := false ;
47239: LD_ADDR_VAR 0 22
47243: PUSH
47244: LD_INT 0
47246: ST_TO_ADDR
// f_heal := false ;
47247: LD_ADDR_VAR 0 23
47251: PUSH
47252: LD_INT 0
47254: ST_TO_ADDR
// f_spacetime := false ;
47255: LD_ADDR_VAR 0 24
47259: PUSH
47260: LD_INT 0
47262: ST_TO_ADDR
// f_attack_depot := false ;
47263: LD_ADDR_VAR 0 25
47267: PUSH
47268: LD_INT 0
47270: ST_TO_ADDR
// f_crawl := false ;
47271: LD_ADDR_VAR 0 26
47275: PUSH
47276: LD_INT 0
47278: ST_TO_ADDR
// end ; if f_heal then
47279: LD_VAR 0 23
47283: IFFALSE 47310
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
47285: LD_ADDR_VAR 0 31
47289: PUSH
47290: LD_VAR 0 4
47294: PPUSH
47295: LD_INT 25
47297: PUSH
47298: LD_INT 4
47300: PUSH
47301: EMPTY
47302: LIST
47303: LIST
47304: PPUSH
47305: CALL_OW 72
47309: ST_TO_ADDR
// if f_repair then
47310: LD_VAR 0 22
47314: IFFALSE 47341
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
47316: LD_ADDR_VAR 0 33
47320: PUSH
47321: LD_VAR 0 4
47325: PPUSH
47326: LD_INT 25
47328: PUSH
47329: LD_INT 3
47331: PUSH
47332: EMPTY
47333: LIST
47334: LIST
47335: PPUSH
47336: CALL_OW 72
47340: ST_TO_ADDR
// units_path := [ ] ;
47341: LD_ADDR_VAR 0 16
47345: PUSH
47346: EMPTY
47347: ST_TO_ADDR
// for i = 1 to group do
47348: LD_ADDR_VAR 0 7
47352: PUSH
47353: DOUBLE
47354: LD_INT 1
47356: DEC
47357: ST_TO_ADDR
47358: LD_VAR 0 4
47362: PUSH
47363: FOR_TO
47364: IFFALSE 47393
// units_path := Replace ( units_path , i , path ) ;
47366: LD_ADDR_VAR 0 16
47370: PUSH
47371: LD_VAR 0 16
47375: PPUSH
47376: LD_VAR 0 7
47380: PPUSH
47381: LD_VAR 0 5
47385: PPUSH
47386: CALL_OW 1
47390: ST_TO_ADDR
47391: GO 47363
47393: POP
47394: POP
// repeat for i = group downto 1 do
47395: LD_ADDR_VAR 0 7
47399: PUSH
47400: DOUBLE
47401: LD_VAR 0 4
47405: INC
47406: ST_TO_ADDR
47407: LD_INT 1
47409: PUSH
47410: FOR_DOWNTO
47411: IFFALSE 51533
// begin wait ( 5 ) ;
47413: LD_INT 5
47415: PPUSH
47416: CALL_OW 67
// tmp := [ ] ;
47420: LD_ADDR_VAR 0 14
47424: PUSH
47425: EMPTY
47426: ST_TO_ADDR
// attacking := false ;
47427: LD_ADDR_VAR 0 29
47431: PUSH
47432: LD_INT 0
47434: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
47435: LD_VAR 0 4
47439: PUSH
47440: LD_VAR 0 7
47444: ARRAY
47445: PPUSH
47446: CALL_OW 301
47450: PUSH
47451: LD_VAR 0 4
47455: PUSH
47456: LD_VAR 0 7
47460: ARRAY
47461: NOT
47462: OR
47463: IFFALSE 47572
// begin if GetType ( group [ i ] ) = unit_human then
47465: LD_VAR 0 4
47469: PUSH
47470: LD_VAR 0 7
47474: ARRAY
47475: PPUSH
47476: CALL_OW 247
47480: PUSH
47481: LD_INT 1
47483: EQUAL
47484: IFFALSE 47530
// begin to_heal := to_heal diff group [ i ] ;
47486: LD_ADDR_VAR 0 30
47490: PUSH
47491: LD_VAR 0 30
47495: PUSH
47496: LD_VAR 0 4
47500: PUSH
47501: LD_VAR 0 7
47505: ARRAY
47506: DIFF
47507: ST_TO_ADDR
// healers := healers diff group [ i ] ;
47508: LD_ADDR_VAR 0 31
47512: PUSH
47513: LD_VAR 0 31
47517: PUSH
47518: LD_VAR 0 4
47522: PUSH
47523: LD_VAR 0 7
47527: ARRAY
47528: DIFF
47529: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
47530: LD_ADDR_VAR 0 4
47534: PUSH
47535: LD_VAR 0 4
47539: PPUSH
47540: LD_VAR 0 7
47544: PPUSH
47545: CALL_OW 3
47549: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
47550: LD_ADDR_VAR 0 16
47554: PUSH
47555: LD_VAR 0 16
47559: PPUSH
47560: LD_VAR 0 7
47564: PPUSH
47565: CALL_OW 3
47569: ST_TO_ADDR
// continue ;
47570: GO 47410
// end ; if f_repair then
47572: LD_VAR 0 22
47576: IFFALSE 48065
// begin if GetType ( group [ i ] ) = unit_vehicle then
47578: LD_VAR 0 4
47582: PUSH
47583: LD_VAR 0 7
47587: ARRAY
47588: PPUSH
47589: CALL_OW 247
47593: PUSH
47594: LD_INT 2
47596: EQUAL
47597: IFFALSE 47787
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
47599: LD_VAR 0 4
47603: PUSH
47604: LD_VAR 0 7
47608: ARRAY
47609: PPUSH
47610: CALL_OW 256
47614: PUSH
47615: LD_INT 700
47617: LESS
47618: PUSH
47619: LD_VAR 0 4
47623: PUSH
47624: LD_VAR 0 7
47628: ARRAY
47629: PUSH
47630: LD_VAR 0 32
47634: IN
47635: NOT
47636: AND
47637: IFFALSE 47661
// to_repair := to_repair union group [ i ] ;
47639: LD_ADDR_VAR 0 32
47643: PUSH
47644: LD_VAR 0 32
47648: PUSH
47649: LD_VAR 0 4
47653: PUSH
47654: LD_VAR 0 7
47658: ARRAY
47659: UNION
47660: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
47661: LD_VAR 0 4
47665: PUSH
47666: LD_VAR 0 7
47670: ARRAY
47671: PPUSH
47672: CALL_OW 256
47676: PUSH
47677: LD_INT 1000
47679: EQUAL
47680: PUSH
47681: LD_VAR 0 4
47685: PUSH
47686: LD_VAR 0 7
47690: ARRAY
47691: PUSH
47692: LD_VAR 0 32
47696: IN
47697: AND
47698: IFFALSE 47722
// to_repair := to_repair diff group [ i ] ;
47700: LD_ADDR_VAR 0 32
47704: PUSH
47705: LD_VAR 0 32
47709: PUSH
47710: LD_VAR 0 4
47714: PUSH
47715: LD_VAR 0 7
47719: ARRAY
47720: DIFF
47721: ST_TO_ADDR
// if group [ i ] in to_repair then
47722: LD_VAR 0 4
47726: PUSH
47727: LD_VAR 0 7
47731: ARRAY
47732: PUSH
47733: LD_VAR 0 32
47737: IN
47738: IFFALSE 47785
// begin if not IsInArea ( group [ i ] , f_repair ) then
47740: LD_VAR 0 4
47744: PUSH
47745: LD_VAR 0 7
47749: ARRAY
47750: PPUSH
47751: LD_VAR 0 22
47755: PPUSH
47756: CALL_OW 308
47760: NOT
47761: IFFALSE 47783
// ComMoveToArea ( group [ i ] , f_repair ) ;
47763: LD_VAR 0 4
47767: PUSH
47768: LD_VAR 0 7
47772: ARRAY
47773: PPUSH
47774: LD_VAR 0 22
47778: PPUSH
47779: CALL_OW 113
// continue ;
47783: GO 47410
// end ; end else
47785: GO 48065
// if group [ i ] in repairs then
47787: LD_VAR 0 4
47791: PUSH
47792: LD_VAR 0 7
47796: ARRAY
47797: PUSH
47798: LD_VAR 0 33
47802: IN
47803: IFFALSE 48065
// begin if IsInUnit ( group [ i ] ) then
47805: LD_VAR 0 4
47809: PUSH
47810: LD_VAR 0 7
47814: ARRAY
47815: PPUSH
47816: CALL_OW 310
47820: IFFALSE 47888
// begin z := IsInUnit ( group [ i ] ) ;
47822: LD_ADDR_VAR 0 13
47826: PUSH
47827: LD_VAR 0 4
47831: PUSH
47832: LD_VAR 0 7
47836: ARRAY
47837: PPUSH
47838: CALL_OW 310
47842: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
47843: LD_VAR 0 13
47847: PUSH
47848: LD_VAR 0 32
47852: IN
47853: PUSH
47854: LD_VAR 0 13
47858: PPUSH
47859: LD_VAR 0 22
47863: PPUSH
47864: CALL_OW 308
47868: AND
47869: IFFALSE 47886
// ComExitVehicle ( group [ i ] ) ;
47871: LD_VAR 0 4
47875: PUSH
47876: LD_VAR 0 7
47880: ARRAY
47881: PPUSH
47882: CALL_OW 121
// end else
47886: GO 48065
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
47888: LD_ADDR_VAR 0 13
47892: PUSH
47893: LD_VAR 0 4
47897: PPUSH
47898: LD_INT 95
47900: PUSH
47901: LD_VAR 0 22
47905: PUSH
47906: EMPTY
47907: LIST
47908: LIST
47909: PUSH
47910: LD_INT 58
47912: PUSH
47913: EMPTY
47914: LIST
47915: PUSH
47916: EMPTY
47917: LIST
47918: LIST
47919: PPUSH
47920: CALL_OW 72
47924: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
47925: LD_VAR 0 4
47929: PUSH
47930: LD_VAR 0 7
47934: ARRAY
47935: PPUSH
47936: CALL_OW 314
47940: NOT
47941: IFFALSE 48063
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
47943: LD_ADDR_VAR 0 10
47947: PUSH
47948: LD_VAR 0 13
47952: PPUSH
47953: LD_VAR 0 4
47957: PUSH
47958: LD_VAR 0 7
47962: ARRAY
47963: PPUSH
47964: CALL_OW 74
47968: ST_TO_ADDR
// if not x then
47969: LD_VAR 0 10
47973: NOT
47974: IFFALSE 47978
// continue ;
47976: GO 47410
// if GetLives ( x ) < 1000 then
47978: LD_VAR 0 10
47982: PPUSH
47983: CALL_OW 256
47987: PUSH
47988: LD_INT 1000
47990: LESS
47991: IFFALSE 48015
// ComRepairVehicle ( group [ i ] , x ) else
47993: LD_VAR 0 4
47997: PUSH
47998: LD_VAR 0 7
48002: ARRAY
48003: PPUSH
48004: LD_VAR 0 10
48008: PPUSH
48009: CALL_OW 129
48013: GO 48063
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
48015: LD_VAR 0 23
48019: PUSH
48020: LD_VAR 0 4
48024: PUSH
48025: LD_VAR 0 7
48029: ARRAY
48030: PPUSH
48031: CALL_OW 256
48035: PUSH
48036: LD_INT 1000
48038: LESS
48039: AND
48040: NOT
48041: IFFALSE 48063
// ComEnterUnit ( group [ i ] , x ) ;
48043: LD_VAR 0 4
48047: PUSH
48048: LD_VAR 0 7
48052: ARRAY
48053: PPUSH
48054: LD_VAR 0 10
48058: PPUSH
48059: CALL_OW 120
// end ; continue ;
48063: GO 47410
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
48065: LD_VAR 0 23
48069: PUSH
48070: LD_VAR 0 4
48074: PUSH
48075: LD_VAR 0 7
48079: ARRAY
48080: PPUSH
48081: CALL_OW 247
48085: PUSH
48086: LD_INT 1
48088: EQUAL
48089: AND
48090: IFFALSE 48568
// begin if group [ i ] in healers then
48092: LD_VAR 0 4
48096: PUSH
48097: LD_VAR 0 7
48101: ARRAY
48102: PUSH
48103: LD_VAR 0 31
48107: IN
48108: IFFALSE 48381
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
48110: LD_VAR 0 4
48114: PUSH
48115: LD_VAR 0 7
48119: ARRAY
48120: PPUSH
48121: LD_VAR 0 23
48125: PPUSH
48126: CALL_OW 308
48130: NOT
48131: PUSH
48132: LD_VAR 0 4
48136: PUSH
48137: LD_VAR 0 7
48141: ARRAY
48142: PPUSH
48143: CALL_OW 314
48147: NOT
48148: AND
48149: IFFALSE 48173
// ComMoveToArea ( group [ i ] , f_heal ) else
48151: LD_VAR 0 4
48155: PUSH
48156: LD_VAR 0 7
48160: ARRAY
48161: PPUSH
48162: LD_VAR 0 23
48166: PPUSH
48167: CALL_OW 113
48171: GO 48379
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
48173: LD_VAR 0 4
48177: PUSH
48178: LD_VAR 0 7
48182: ARRAY
48183: PPUSH
48184: CALL 46791 0 1
48188: PPUSH
48189: CALL_OW 256
48193: PUSH
48194: LD_INT 1000
48196: EQUAL
48197: IFFALSE 48216
// ComStop ( group [ i ] ) else
48199: LD_VAR 0 4
48203: PUSH
48204: LD_VAR 0 7
48208: ARRAY
48209: PPUSH
48210: CALL_OW 141
48214: GO 48379
// if not HasTask ( group [ i ] ) and to_heal then
48216: LD_VAR 0 4
48220: PUSH
48221: LD_VAR 0 7
48225: ARRAY
48226: PPUSH
48227: CALL_OW 314
48231: NOT
48232: PUSH
48233: LD_VAR 0 30
48237: AND
48238: IFFALSE 48379
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
48240: LD_ADDR_VAR 0 13
48244: PUSH
48245: LD_VAR 0 30
48249: PPUSH
48250: LD_INT 3
48252: PUSH
48253: LD_INT 54
48255: PUSH
48256: EMPTY
48257: LIST
48258: PUSH
48259: EMPTY
48260: LIST
48261: LIST
48262: PPUSH
48263: CALL_OW 72
48267: PPUSH
48268: LD_VAR 0 4
48272: PUSH
48273: LD_VAR 0 7
48277: ARRAY
48278: PPUSH
48279: CALL_OW 74
48283: ST_TO_ADDR
// if z then
48284: LD_VAR 0 13
48288: IFFALSE 48379
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
48290: LD_INT 91
48292: PUSH
48293: LD_VAR 0 13
48297: PUSH
48298: LD_INT 10
48300: PUSH
48301: EMPTY
48302: LIST
48303: LIST
48304: LIST
48305: PUSH
48306: LD_INT 81
48308: PUSH
48309: LD_VAR 0 13
48313: PPUSH
48314: CALL_OW 255
48318: PUSH
48319: EMPTY
48320: LIST
48321: LIST
48322: PUSH
48323: EMPTY
48324: LIST
48325: LIST
48326: PPUSH
48327: CALL_OW 69
48331: PUSH
48332: LD_INT 0
48334: EQUAL
48335: IFFALSE 48359
// ComHeal ( group [ i ] , z ) else
48337: LD_VAR 0 4
48341: PUSH
48342: LD_VAR 0 7
48346: ARRAY
48347: PPUSH
48348: LD_VAR 0 13
48352: PPUSH
48353: CALL_OW 128
48357: GO 48379
// ComMoveToArea ( group [ i ] , f_heal ) ;
48359: LD_VAR 0 4
48363: PUSH
48364: LD_VAR 0 7
48368: ARRAY
48369: PPUSH
48370: LD_VAR 0 23
48374: PPUSH
48375: CALL_OW 113
// end ; continue ;
48379: GO 47410
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
48381: LD_VAR 0 4
48385: PUSH
48386: LD_VAR 0 7
48390: ARRAY
48391: PPUSH
48392: CALL_OW 256
48396: PUSH
48397: LD_INT 700
48399: LESS
48400: PUSH
48401: LD_VAR 0 4
48405: PUSH
48406: LD_VAR 0 7
48410: ARRAY
48411: PUSH
48412: LD_VAR 0 30
48416: IN
48417: NOT
48418: AND
48419: IFFALSE 48443
// to_heal := to_heal union group [ i ] ;
48421: LD_ADDR_VAR 0 30
48425: PUSH
48426: LD_VAR 0 30
48430: PUSH
48431: LD_VAR 0 4
48435: PUSH
48436: LD_VAR 0 7
48440: ARRAY
48441: UNION
48442: ST_TO_ADDR
// if group [ i ] in to_heal then
48443: LD_VAR 0 4
48447: PUSH
48448: LD_VAR 0 7
48452: ARRAY
48453: PUSH
48454: LD_VAR 0 30
48458: IN
48459: IFFALSE 48568
// begin if GetLives ( group [ i ] ) = 1000 then
48461: LD_VAR 0 4
48465: PUSH
48466: LD_VAR 0 7
48470: ARRAY
48471: PPUSH
48472: CALL_OW 256
48476: PUSH
48477: LD_INT 1000
48479: EQUAL
48480: IFFALSE 48506
// to_heal := to_heal diff group [ i ] else
48482: LD_ADDR_VAR 0 30
48486: PUSH
48487: LD_VAR 0 30
48491: PUSH
48492: LD_VAR 0 4
48496: PUSH
48497: LD_VAR 0 7
48501: ARRAY
48502: DIFF
48503: ST_TO_ADDR
48504: GO 48568
// begin if not IsInArea ( group [ i ] , to_heal ) then
48506: LD_VAR 0 4
48510: PUSH
48511: LD_VAR 0 7
48515: ARRAY
48516: PPUSH
48517: LD_VAR 0 30
48521: PPUSH
48522: CALL_OW 308
48526: NOT
48527: IFFALSE 48551
// ComMoveToArea ( group [ i ] , f_heal ) else
48529: LD_VAR 0 4
48533: PUSH
48534: LD_VAR 0 7
48538: ARRAY
48539: PPUSH
48540: LD_VAR 0 23
48544: PPUSH
48545: CALL_OW 113
48549: GO 48566
// ComHold ( group [ i ] ) ;
48551: LD_VAR 0 4
48555: PUSH
48556: LD_VAR 0 7
48560: ARRAY
48561: PPUSH
48562: CALL_OW 140
// continue ;
48566: GO 47410
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
48568: LD_VAR 0 4
48572: PUSH
48573: LD_VAR 0 7
48577: ARRAY
48578: PPUSH
48579: LD_INT 10
48581: PPUSH
48582: CALL 45211 0 2
48586: NOT
48587: PUSH
48588: LD_VAR 0 16
48592: PUSH
48593: LD_VAR 0 7
48597: ARRAY
48598: PUSH
48599: EMPTY
48600: EQUAL
48601: NOT
48602: AND
48603: IFFALSE 48869
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
48605: LD_VAR 0 4
48609: PUSH
48610: LD_VAR 0 7
48614: ARRAY
48615: PPUSH
48616: CALL_OW 262
48620: PUSH
48621: LD_INT 1
48623: PUSH
48624: LD_INT 2
48626: PUSH
48627: EMPTY
48628: LIST
48629: LIST
48630: IN
48631: IFFALSE 48672
// if GetFuel ( group [ i ] ) < 10 then
48633: LD_VAR 0 4
48637: PUSH
48638: LD_VAR 0 7
48642: ARRAY
48643: PPUSH
48644: CALL_OW 261
48648: PUSH
48649: LD_INT 10
48651: LESS
48652: IFFALSE 48672
// SetFuel ( group [ i ] , 12 ) ;
48654: LD_VAR 0 4
48658: PUSH
48659: LD_VAR 0 7
48663: ARRAY
48664: PPUSH
48665: LD_INT 12
48667: PPUSH
48668: CALL_OW 240
// if units_path [ i ] then
48672: LD_VAR 0 16
48676: PUSH
48677: LD_VAR 0 7
48681: ARRAY
48682: IFFALSE 48867
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
48684: LD_VAR 0 4
48688: PUSH
48689: LD_VAR 0 7
48693: ARRAY
48694: PPUSH
48695: LD_VAR 0 16
48699: PUSH
48700: LD_VAR 0 7
48704: ARRAY
48705: PUSH
48706: LD_INT 1
48708: ARRAY
48709: PUSH
48710: LD_INT 1
48712: ARRAY
48713: PPUSH
48714: LD_VAR 0 16
48718: PUSH
48719: LD_VAR 0 7
48723: ARRAY
48724: PUSH
48725: LD_INT 1
48727: ARRAY
48728: PUSH
48729: LD_INT 2
48731: ARRAY
48732: PPUSH
48733: CALL_OW 297
48737: PUSH
48738: LD_INT 6
48740: GREATER
48741: IFFALSE 48816
// begin if not HasTask ( group [ i ] ) then
48743: LD_VAR 0 4
48747: PUSH
48748: LD_VAR 0 7
48752: ARRAY
48753: PPUSH
48754: CALL_OW 314
48758: NOT
48759: IFFALSE 48814
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
48761: LD_VAR 0 4
48765: PUSH
48766: LD_VAR 0 7
48770: ARRAY
48771: PPUSH
48772: LD_VAR 0 16
48776: PUSH
48777: LD_VAR 0 7
48781: ARRAY
48782: PUSH
48783: LD_INT 1
48785: ARRAY
48786: PUSH
48787: LD_INT 1
48789: ARRAY
48790: PPUSH
48791: LD_VAR 0 16
48795: PUSH
48796: LD_VAR 0 7
48800: ARRAY
48801: PUSH
48802: LD_INT 1
48804: ARRAY
48805: PUSH
48806: LD_INT 2
48808: ARRAY
48809: PPUSH
48810: CALL_OW 114
// end else
48814: GO 48867
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
48816: LD_ADDR_VAR 0 15
48820: PUSH
48821: LD_VAR 0 16
48825: PUSH
48826: LD_VAR 0 7
48830: ARRAY
48831: PPUSH
48832: LD_INT 1
48834: PPUSH
48835: CALL_OW 3
48839: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
48840: LD_ADDR_VAR 0 16
48844: PUSH
48845: LD_VAR 0 16
48849: PPUSH
48850: LD_VAR 0 7
48854: PPUSH
48855: LD_VAR 0 15
48859: PPUSH
48860: CALL_OW 1
48864: ST_TO_ADDR
// continue ;
48865: GO 47410
// end ; end ; end else
48867: GO 51531
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
48869: LD_ADDR_VAR 0 14
48873: PUSH
48874: LD_INT 81
48876: PUSH
48877: LD_VAR 0 4
48881: PUSH
48882: LD_VAR 0 7
48886: ARRAY
48887: PPUSH
48888: CALL_OW 255
48892: PUSH
48893: EMPTY
48894: LIST
48895: LIST
48896: PPUSH
48897: CALL_OW 69
48901: ST_TO_ADDR
// if not tmp then
48902: LD_VAR 0 14
48906: NOT
48907: IFFALSE 48911
// continue ;
48909: GO 47410
// if f_ignore_area then
48911: LD_VAR 0 17
48915: IFFALSE 49003
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
48917: LD_ADDR_VAR 0 15
48921: PUSH
48922: LD_VAR 0 14
48926: PPUSH
48927: LD_INT 3
48929: PUSH
48930: LD_INT 92
48932: PUSH
48933: LD_VAR 0 17
48937: PUSH
48938: LD_INT 1
48940: ARRAY
48941: PUSH
48942: LD_VAR 0 17
48946: PUSH
48947: LD_INT 2
48949: ARRAY
48950: PUSH
48951: LD_VAR 0 17
48955: PUSH
48956: LD_INT 3
48958: ARRAY
48959: PUSH
48960: EMPTY
48961: LIST
48962: LIST
48963: LIST
48964: LIST
48965: PUSH
48966: EMPTY
48967: LIST
48968: LIST
48969: PPUSH
48970: CALL_OW 72
48974: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
48975: LD_VAR 0 14
48979: PUSH
48980: LD_VAR 0 15
48984: DIFF
48985: IFFALSE 49003
// tmp := tmp diff tmp2 ;
48987: LD_ADDR_VAR 0 14
48991: PUSH
48992: LD_VAR 0 14
48996: PUSH
48997: LD_VAR 0 15
49001: DIFF
49002: ST_TO_ADDR
// end ; if not f_murder then
49003: LD_VAR 0 20
49007: NOT
49008: IFFALSE 49066
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
49010: LD_ADDR_VAR 0 15
49014: PUSH
49015: LD_VAR 0 14
49019: PPUSH
49020: LD_INT 3
49022: PUSH
49023: LD_INT 50
49025: PUSH
49026: EMPTY
49027: LIST
49028: PUSH
49029: EMPTY
49030: LIST
49031: LIST
49032: PPUSH
49033: CALL_OW 72
49037: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
49038: LD_VAR 0 14
49042: PUSH
49043: LD_VAR 0 15
49047: DIFF
49048: IFFALSE 49066
// tmp := tmp diff tmp2 ;
49050: LD_ADDR_VAR 0 14
49054: PUSH
49055: LD_VAR 0 14
49059: PUSH
49060: LD_VAR 0 15
49064: DIFF
49065: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
49066: LD_ADDR_VAR 0 14
49070: PUSH
49071: LD_VAR 0 4
49075: PUSH
49076: LD_VAR 0 7
49080: ARRAY
49081: PPUSH
49082: LD_VAR 0 14
49086: PPUSH
49087: LD_INT 1
49089: PPUSH
49090: LD_INT 1
49092: PPUSH
49093: CALL 18854 0 4
49097: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
49098: LD_VAR 0 4
49102: PUSH
49103: LD_VAR 0 7
49107: ARRAY
49108: PPUSH
49109: CALL_OW 257
49113: PUSH
49114: LD_INT 1
49116: EQUAL
49117: IFFALSE 49565
// begin if WantPlant ( group [ i ] ) then
49119: LD_VAR 0 4
49123: PUSH
49124: LD_VAR 0 7
49128: ARRAY
49129: PPUSH
49130: CALL 18355 0 1
49134: IFFALSE 49138
// continue ;
49136: GO 47410
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
49138: LD_VAR 0 18
49142: PUSH
49143: LD_VAR 0 4
49147: PUSH
49148: LD_VAR 0 7
49152: ARRAY
49153: PPUSH
49154: CALL_OW 310
49158: NOT
49159: AND
49160: PUSH
49161: LD_VAR 0 14
49165: PUSH
49166: LD_INT 1
49168: ARRAY
49169: PUSH
49170: LD_VAR 0 14
49174: PPUSH
49175: LD_INT 21
49177: PUSH
49178: LD_INT 2
49180: PUSH
49181: EMPTY
49182: LIST
49183: LIST
49184: PUSH
49185: LD_INT 58
49187: PUSH
49188: EMPTY
49189: LIST
49190: PUSH
49191: EMPTY
49192: LIST
49193: LIST
49194: PPUSH
49195: CALL_OW 72
49199: IN
49200: AND
49201: IFFALSE 49237
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
49203: LD_VAR 0 4
49207: PUSH
49208: LD_VAR 0 7
49212: ARRAY
49213: PPUSH
49214: LD_VAR 0 14
49218: PUSH
49219: LD_INT 1
49221: ARRAY
49222: PPUSH
49223: CALL_OW 120
// attacking := true ;
49227: LD_ADDR_VAR 0 29
49231: PUSH
49232: LD_INT 1
49234: ST_TO_ADDR
// continue ;
49235: GO 47410
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
49237: LD_VAR 0 26
49241: PUSH
49242: LD_VAR 0 4
49246: PUSH
49247: LD_VAR 0 7
49251: ARRAY
49252: PPUSH
49253: CALL_OW 257
49257: PUSH
49258: LD_INT 1
49260: EQUAL
49261: AND
49262: PUSH
49263: LD_VAR 0 4
49267: PUSH
49268: LD_VAR 0 7
49272: ARRAY
49273: PPUSH
49274: CALL_OW 256
49278: PUSH
49279: LD_INT 800
49281: LESS
49282: AND
49283: PUSH
49284: LD_VAR 0 4
49288: PUSH
49289: LD_VAR 0 7
49293: ARRAY
49294: PPUSH
49295: CALL_OW 318
49299: NOT
49300: AND
49301: IFFALSE 49318
// ComCrawl ( group [ i ] ) ;
49303: LD_VAR 0 4
49307: PUSH
49308: LD_VAR 0 7
49312: ARRAY
49313: PPUSH
49314: CALL_OW 137
// if f_mines then
49318: LD_VAR 0 21
49322: IFFALSE 49565
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
49324: LD_VAR 0 14
49328: PUSH
49329: LD_INT 1
49331: ARRAY
49332: PPUSH
49333: CALL_OW 247
49337: PUSH
49338: LD_INT 3
49340: EQUAL
49341: PUSH
49342: LD_VAR 0 14
49346: PUSH
49347: LD_INT 1
49349: ARRAY
49350: PUSH
49351: LD_VAR 0 27
49355: IN
49356: NOT
49357: AND
49358: IFFALSE 49565
// begin x := GetX ( tmp [ 1 ] ) ;
49360: LD_ADDR_VAR 0 10
49364: PUSH
49365: LD_VAR 0 14
49369: PUSH
49370: LD_INT 1
49372: ARRAY
49373: PPUSH
49374: CALL_OW 250
49378: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
49379: LD_ADDR_VAR 0 11
49383: PUSH
49384: LD_VAR 0 14
49388: PUSH
49389: LD_INT 1
49391: ARRAY
49392: PPUSH
49393: CALL_OW 251
49397: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
49398: LD_ADDR_VAR 0 12
49402: PUSH
49403: LD_VAR 0 4
49407: PUSH
49408: LD_VAR 0 7
49412: ARRAY
49413: PPUSH
49414: CALL 45296 0 1
49418: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
49419: LD_VAR 0 4
49423: PUSH
49424: LD_VAR 0 7
49428: ARRAY
49429: PPUSH
49430: LD_VAR 0 10
49434: PPUSH
49435: LD_VAR 0 11
49439: PPUSH
49440: LD_VAR 0 14
49444: PUSH
49445: LD_INT 1
49447: ARRAY
49448: PPUSH
49449: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
49453: LD_VAR 0 4
49457: PUSH
49458: LD_VAR 0 7
49462: ARRAY
49463: PPUSH
49464: LD_VAR 0 10
49468: PPUSH
49469: LD_VAR 0 12
49473: PPUSH
49474: LD_INT 7
49476: PPUSH
49477: CALL_OW 272
49481: PPUSH
49482: LD_VAR 0 11
49486: PPUSH
49487: LD_VAR 0 12
49491: PPUSH
49492: LD_INT 7
49494: PPUSH
49495: CALL_OW 273
49499: PPUSH
49500: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
49504: LD_VAR 0 4
49508: PUSH
49509: LD_VAR 0 7
49513: ARRAY
49514: PPUSH
49515: LD_INT 71
49517: PPUSH
49518: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
49522: LD_ADDR_VAR 0 27
49526: PUSH
49527: LD_VAR 0 27
49531: PPUSH
49532: LD_VAR 0 27
49536: PUSH
49537: LD_INT 1
49539: PLUS
49540: PPUSH
49541: LD_VAR 0 14
49545: PUSH
49546: LD_INT 1
49548: ARRAY
49549: PPUSH
49550: CALL_OW 1
49554: ST_TO_ADDR
// attacking := true ;
49555: LD_ADDR_VAR 0 29
49559: PUSH
49560: LD_INT 1
49562: ST_TO_ADDR
// continue ;
49563: GO 47410
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
49565: LD_VAR 0 4
49569: PUSH
49570: LD_VAR 0 7
49574: ARRAY
49575: PPUSH
49576: CALL_OW 257
49580: PUSH
49581: LD_INT 17
49583: EQUAL
49584: PUSH
49585: LD_VAR 0 4
49589: PUSH
49590: LD_VAR 0 7
49594: ARRAY
49595: PPUSH
49596: CALL_OW 110
49600: PUSH
49601: LD_INT 71
49603: EQUAL
49604: NOT
49605: AND
49606: IFFALSE 49752
// begin attacking := false ;
49608: LD_ADDR_VAR 0 29
49612: PUSH
49613: LD_INT 0
49615: ST_TO_ADDR
// k := 5 ;
49616: LD_ADDR_VAR 0 9
49620: PUSH
49621: LD_INT 5
49623: ST_TO_ADDR
// if tmp < k then
49624: LD_VAR 0 14
49628: PUSH
49629: LD_VAR 0 9
49633: LESS
49634: IFFALSE 49646
// k := tmp ;
49636: LD_ADDR_VAR 0 9
49640: PUSH
49641: LD_VAR 0 14
49645: ST_TO_ADDR
// for j = 1 to k do
49646: LD_ADDR_VAR 0 8
49650: PUSH
49651: DOUBLE
49652: LD_INT 1
49654: DEC
49655: ST_TO_ADDR
49656: LD_VAR 0 9
49660: PUSH
49661: FOR_TO
49662: IFFALSE 49750
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
49664: LD_VAR 0 14
49668: PUSH
49669: LD_VAR 0 8
49673: ARRAY
49674: PUSH
49675: LD_VAR 0 14
49679: PPUSH
49680: LD_INT 58
49682: PUSH
49683: EMPTY
49684: LIST
49685: PPUSH
49686: CALL_OW 72
49690: IN
49691: NOT
49692: IFFALSE 49748
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
49694: LD_VAR 0 4
49698: PUSH
49699: LD_VAR 0 7
49703: ARRAY
49704: PPUSH
49705: LD_VAR 0 14
49709: PUSH
49710: LD_VAR 0 8
49714: ARRAY
49715: PPUSH
49716: CALL_OW 115
// attacking := true ;
49720: LD_ADDR_VAR 0 29
49724: PUSH
49725: LD_INT 1
49727: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
49728: LD_VAR 0 4
49732: PUSH
49733: LD_VAR 0 7
49737: ARRAY
49738: PPUSH
49739: LD_INT 71
49741: PPUSH
49742: CALL_OW 109
// continue ;
49746: GO 49661
// end ; end ;
49748: GO 49661
49750: POP
49751: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
49752: LD_VAR 0 4
49756: PUSH
49757: LD_VAR 0 7
49761: ARRAY
49762: PPUSH
49763: CALL_OW 257
49767: PUSH
49768: LD_INT 8
49770: EQUAL
49771: PUSH
49772: LD_VAR 0 4
49776: PUSH
49777: LD_VAR 0 7
49781: ARRAY
49782: PPUSH
49783: CALL_OW 264
49787: PUSH
49788: LD_INT 28
49790: PUSH
49791: LD_INT 45
49793: PUSH
49794: LD_INT 7
49796: PUSH
49797: LD_INT 47
49799: PUSH
49800: EMPTY
49801: LIST
49802: LIST
49803: LIST
49804: LIST
49805: IN
49806: OR
49807: IFFALSE 50063
// begin attacking := false ;
49809: LD_ADDR_VAR 0 29
49813: PUSH
49814: LD_INT 0
49816: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
49817: LD_VAR 0 14
49821: PUSH
49822: LD_INT 1
49824: ARRAY
49825: PPUSH
49826: CALL_OW 266
49830: PUSH
49831: LD_INT 32
49833: PUSH
49834: LD_INT 31
49836: PUSH
49837: LD_INT 33
49839: PUSH
49840: LD_INT 4
49842: PUSH
49843: LD_INT 5
49845: PUSH
49846: EMPTY
49847: LIST
49848: LIST
49849: LIST
49850: LIST
49851: LIST
49852: IN
49853: IFFALSE 50039
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
49855: LD_ADDR_VAR 0 9
49859: PUSH
49860: LD_VAR 0 14
49864: PUSH
49865: LD_INT 1
49867: ARRAY
49868: PPUSH
49869: CALL_OW 266
49873: PPUSH
49874: LD_VAR 0 14
49878: PUSH
49879: LD_INT 1
49881: ARRAY
49882: PPUSH
49883: CALL_OW 250
49887: PPUSH
49888: LD_VAR 0 14
49892: PUSH
49893: LD_INT 1
49895: ARRAY
49896: PPUSH
49897: CALL_OW 251
49901: PPUSH
49902: LD_VAR 0 14
49906: PUSH
49907: LD_INT 1
49909: ARRAY
49910: PPUSH
49911: CALL_OW 254
49915: PPUSH
49916: LD_VAR 0 14
49920: PUSH
49921: LD_INT 1
49923: ARRAY
49924: PPUSH
49925: CALL_OW 248
49929: PPUSH
49930: LD_INT 0
49932: PPUSH
49933: CALL 26666 0 6
49937: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
49938: LD_ADDR_VAR 0 8
49942: PUSH
49943: LD_VAR 0 4
49947: PUSH
49948: LD_VAR 0 7
49952: ARRAY
49953: PPUSH
49954: LD_VAR 0 9
49958: PPUSH
49959: CALL 45336 0 2
49963: ST_TO_ADDR
// if j then
49964: LD_VAR 0 8
49968: IFFALSE 50037
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
49970: LD_VAR 0 8
49974: PUSH
49975: LD_INT 1
49977: ARRAY
49978: PPUSH
49979: LD_VAR 0 8
49983: PUSH
49984: LD_INT 2
49986: ARRAY
49987: PPUSH
49988: CALL_OW 488
49992: IFFALSE 50037
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
49994: LD_VAR 0 4
49998: PUSH
49999: LD_VAR 0 7
50003: ARRAY
50004: PPUSH
50005: LD_VAR 0 8
50009: PUSH
50010: LD_INT 1
50012: ARRAY
50013: PPUSH
50014: LD_VAR 0 8
50018: PUSH
50019: LD_INT 2
50021: ARRAY
50022: PPUSH
50023: CALL_OW 116
// attacking := true ;
50027: LD_ADDR_VAR 0 29
50031: PUSH
50032: LD_INT 1
50034: ST_TO_ADDR
// continue ;
50035: GO 47410
// end ; end else
50037: GO 50063
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
50039: LD_VAR 0 4
50043: PUSH
50044: LD_VAR 0 7
50048: ARRAY
50049: PPUSH
50050: LD_VAR 0 14
50054: PUSH
50055: LD_INT 1
50057: ARRAY
50058: PPUSH
50059: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
50063: LD_VAR 0 4
50067: PUSH
50068: LD_VAR 0 7
50072: ARRAY
50073: PPUSH
50074: CALL_OW 265
50078: PUSH
50079: LD_INT 11
50081: EQUAL
50082: IFFALSE 50360
// begin k := 10 ;
50084: LD_ADDR_VAR 0 9
50088: PUSH
50089: LD_INT 10
50091: ST_TO_ADDR
// x := 0 ;
50092: LD_ADDR_VAR 0 10
50096: PUSH
50097: LD_INT 0
50099: ST_TO_ADDR
// if tmp < k then
50100: LD_VAR 0 14
50104: PUSH
50105: LD_VAR 0 9
50109: LESS
50110: IFFALSE 50122
// k := tmp ;
50112: LD_ADDR_VAR 0 9
50116: PUSH
50117: LD_VAR 0 14
50121: ST_TO_ADDR
// for j = k downto 1 do
50122: LD_ADDR_VAR 0 8
50126: PUSH
50127: DOUBLE
50128: LD_VAR 0 9
50132: INC
50133: ST_TO_ADDR
50134: LD_INT 1
50136: PUSH
50137: FOR_DOWNTO
50138: IFFALSE 50213
// begin if GetType ( tmp [ j ] ) = unit_human then
50140: LD_VAR 0 14
50144: PUSH
50145: LD_VAR 0 8
50149: ARRAY
50150: PPUSH
50151: CALL_OW 247
50155: PUSH
50156: LD_INT 1
50158: EQUAL
50159: IFFALSE 50211
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
50161: LD_VAR 0 4
50165: PUSH
50166: LD_VAR 0 7
50170: ARRAY
50171: PPUSH
50172: LD_VAR 0 14
50176: PUSH
50177: LD_VAR 0 8
50181: ARRAY
50182: PPUSH
50183: CALL 45607 0 2
// x := tmp [ j ] ;
50187: LD_ADDR_VAR 0 10
50191: PUSH
50192: LD_VAR 0 14
50196: PUSH
50197: LD_VAR 0 8
50201: ARRAY
50202: ST_TO_ADDR
// attacking := true ;
50203: LD_ADDR_VAR 0 29
50207: PUSH
50208: LD_INT 1
50210: ST_TO_ADDR
// end ; end ;
50211: GO 50137
50213: POP
50214: POP
// if not x then
50215: LD_VAR 0 10
50219: NOT
50220: IFFALSE 50360
// begin attacking := true ;
50222: LD_ADDR_VAR 0 29
50226: PUSH
50227: LD_INT 1
50229: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
50230: LD_VAR 0 4
50234: PUSH
50235: LD_VAR 0 7
50239: ARRAY
50240: PPUSH
50241: CALL_OW 250
50245: PPUSH
50246: LD_VAR 0 4
50250: PUSH
50251: LD_VAR 0 7
50255: ARRAY
50256: PPUSH
50257: CALL_OW 251
50261: PPUSH
50262: CALL_OW 546
50266: PUSH
50267: LD_INT 2
50269: ARRAY
50270: PUSH
50271: LD_VAR 0 14
50275: PUSH
50276: LD_INT 1
50278: ARRAY
50279: PPUSH
50280: CALL_OW 250
50284: PPUSH
50285: LD_VAR 0 14
50289: PUSH
50290: LD_INT 1
50292: ARRAY
50293: PPUSH
50294: CALL_OW 251
50298: PPUSH
50299: CALL_OW 546
50303: PUSH
50304: LD_INT 2
50306: ARRAY
50307: EQUAL
50308: IFFALSE 50336
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
50310: LD_VAR 0 4
50314: PUSH
50315: LD_VAR 0 7
50319: ARRAY
50320: PPUSH
50321: LD_VAR 0 14
50325: PUSH
50326: LD_INT 1
50328: ARRAY
50329: PPUSH
50330: CALL 45607 0 2
50334: GO 50360
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
50336: LD_VAR 0 4
50340: PUSH
50341: LD_VAR 0 7
50345: ARRAY
50346: PPUSH
50347: LD_VAR 0 14
50351: PUSH
50352: LD_INT 1
50354: ARRAY
50355: PPUSH
50356: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
50360: LD_VAR 0 4
50364: PUSH
50365: LD_VAR 0 7
50369: ARRAY
50370: PPUSH
50371: CALL_OW 264
50375: PUSH
50376: LD_INT 29
50378: EQUAL
50379: IFFALSE 50745
// begin if WantsToAttack ( group [ i ] ) in bombed then
50381: LD_VAR 0 4
50385: PUSH
50386: LD_VAR 0 7
50390: ARRAY
50391: PPUSH
50392: CALL_OW 319
50396: PUSH
50397: LD_VAR 0 28
50401: IN
50402: IFFALSE 50406
// continue ;
50404: GO 47410
// k := 8 ;
50406: LD_ADDR_VAR 0 9
50410: PUSH
50411: LD_INT 8
50413: ST_TO_ADDR
// x := 0 ;
50414: LD_ADDR_VAR 0 10
50418: PUSH
50419: LD_INT 0
50421: ST_TO_ADDR
// if tmp < k then
50422: LD_VAR 0 14
50426: PUSH
50427: LD_VAR 0 9
50431: LESS
50432: IFFALSE 50444
// k := tmp ;
50434: LD_ADDR_VAR 0 9
50438: PUSH
50439: LD_VAR 0 14
50443: ST_TO_ADDR
// for j = 1 to k do
50444: LD_ADDR_VAR 0 8
50448: PUSH
50449: DOUBLE
50450: LD_INT 1
50452: DEC
50453: ST_TO_ADDR
50454: LD_VAR 0 9
50458: PUSH
50459: FOR_TO
50460: IFFALSE 50592
// begin if GetType ( tmp [ j ] ) = unit_building then
50462: LD_VAR 0 14
50466: PUSH
50467: LD_VAR 0 8
50471: ARRAY
50472: PPUSH
50473: CALL_OW 247
50477: PUSH
50478: LD_INT 3
50480: EQUAL
50481: IFFALSE 50590
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
50483: LD_VAR 0 14
50487: PUSH
50488: LD_VAR 0 8
50492: ARRAY
50493: PUSH
50494: LD_VAR 0 28
50498: IN
50499: NOT
50500: PUSH
50501: LD_VAR 0 14
50505: PUSH
50506: LD_VAR 0 8
50510: ARRAY
50511: PPUSH
50512: CALL_OW 313
50516: AND
50517: IFFALSE 50590
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
50519: LD_VAR 0 4
50523: PUSH
50524: LD_VAR 0 7
50528: ARRAY
50529: PPUSH
50530: LD_VAR 0 14
50534: PUSH
50535: LD_VAR 0 8
50539: ARRAY
50540: PPUSH
50541: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
50545: LD_ADDR_VAR 0 28
50549: PUSH
50550: LD_VAR 0 28
50554: PPUSH
50555: LD_VAR 0 28
50559: PUSH
50560: LD_INT 1
50562: PLUS
50563: PPUSH
50564: LD_VAR 0 14
50568: PUSH
50569: LD_VAR 0 8
50573: ARRAY
50574: PPUSH
50575: CALL_OW 1
50579: ST_TO_ADDR
// attacking := true ;
50580: LD_ADDR_VAR 0 29
50584: PUSH
50585: LD_INT 1
50587: ST_TO_ADDR
// break ;
50588: GO 50592
// end ; end ;
50590: GO 50459
50592: POP
50593: POP
// if not attacking and f_attack_depot then
50594: LD_VAR 0 29
50598: NOT
50599: PUSH
50600: LD_VAR 0 25
50604: AND
50605: IFFALSE 50700
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50607: LD_ADDR_VAR 0 13
50611: PUSH
50612: LD_VAR 0 14
50616: PPUSH
50617: LD_INT 2
50619: PUSH
50620: LD_INT 30
50622: PUSH
50623: LD_INT 0
50625: PUSH
50626: EMPTY
50627: LIST
50628: LIST
50629: PUSH
50630: LD_INT 30
50632: PUSH
50633: LD_INT 1
50635: PUSH
50636: EMPTY
50637: LIST
50638: LIST
50639: PUSH
50640: EMPTY
50641: LIST
50642: LIST
50643: LIST
50644: PPUSH
50645: CALL_OW 72
50649: ST_TO_ADDR
// if z then
50650: LD_VAR 0 13
50654: IFFALSE 50700
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
50656: LD_VAR 0 4
50660: PUSH
50661: LD_VAR 0 7
50665: ARRAY
50666: PPUSH
50667: LD_VAR 0 13
50671: PPUSH
50672: LD_VAR 0 4
50676: PUSH
50677: LD_VAR 0 7
50681: ARRAY
50682: PPUSH
50683: CALL_OW 74
50687: PPUSH
50688: CALL_OW 115
// attacking := true ;
50692: LD_ADDR_VAR 0 29
50696: PUSH
50697: LD_INT 1
50699: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
50700: LD_VAR 0 4
50704: PUSH
50705: LD_VAR 0 7
50709: ARRAY
50710: PPUSH
50711: CALL_OW 256
50715: PUSH
50716: LD_INT 500
50718: LESS
50719: IFFALSE 50745
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
50721: LD_VAR 0 4
50725: PUSH
50726: LD_VAR 0 7
50730: ARRAY
50731: PPUSH
50732: LD_VAR 0 14
50736: PUSH
50737: LD_INT 1
50739: ARRAY
50740: PPUSH
50741: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
50745: LD_VAR 0 4
50749: PUSH
50750: LD_VAR 0 7
50754: ARRAY
50755: PPUSH
50756: CALL_OW 264
50760: PUSH
50761: LD_INT 49
50763: EQUAL
50764: IFFALSE 50885
// begin if not HasTask ( group [ i ] ) then
50766: LD_VAR 0 4
50770: PUSH
50771: LD_VAR 0 7
50775: ARRAY
50776: PPUSH
50777: CALL_OW 314
50781: NOT
50782: IFFALSE 50885
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
50784: LD_ADDR_VAR 0 9
50788: PUSH
50789: LD_INT 81
50791: PUSH
50792: LD_VAR 0 4
50796: PUSH
50797: LD_VAR 0 7
50801: ARRAY
50802: PPUSH
50803: CALL_OW 255
50807: PUSH
50808: EMPTY
50809: LIST
50810: LIST
50811: PPUSH
50812: CALL_OW 69
50816: PPUSH
50817: LD_VAR 0 4
50821: PUSH
50822: LD_VAR 0 7
50826: ARRAY
50827: PPUSH
50828: CALL_OW 74
50832: ST_TO_ADDR
// if k then
50833: LD_VAR 0 9
50837: IFFALSE 50885
// if GetDistUnits ( group [ i ] , k ) > 10 then
50839: LD_VAR 0 4
50843: PUSH
50844: LD_VAR 0 7
50848: ARRAY
50849: PPUSH
50850: LD_VAR 0 9
50854: PPUSH
50855: CALL_OW 296
50859: PUSH
50860: LD_INT 10
50862: GREATER
50863: IFFALSE 50885
// ComMoveUnit ( group [ i ] , k ) ;
50865: LD_VAR 0 4
50869: PUSH
50870: LD_VAR 0 7
50874: ARRAY
50875: PPUSH
50876: LD_VAR 0 9
50880: PPUSH
50881: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
50885: LD_VAR 0 4
50889: PUSH
50890: LD_VAR 0 7
50894: ARRAY
50895: PPUSH
50896: CALL_OW 256
50900: PUSH
50901: LD_INT 250
50903: LESS
50904: PUSH
50905: LD_VAR 0 4
50909: PUSH
50910: LD_VAR 0 7
50914: ARRAY
50915: PUSH
50916: LD_INT 21
50918: PUSH
50919: LD_INT 2
50921: PUSH
50922: EMPTY
50923: LIST
50924: LIST
50925: PUSH
50926: LD_INT 23
50928: PUSH
50929: LD_INT 2
50931: PUSH
50932: EMPTY
50933: LIST
50934: LIST
50935: PUSH
50936: EMPTY
50937: LIST
50938: LIST
50939: PPUSH
50940: CALL_OW 69
50944: IN
50945: AND
50946: IFFALSE 51071
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
50948: LD_ADDR_VAR 0 9
50952: PUSH
50953: LD_OWVAR 3
50957: PUSH
50958: LD_VAR 0 4
50962: PUSH
50963: LD_VAR 0 7
50967: ARRAY
50968: DIFF
50969: PPUSH
50970: LD_VAR 0 4
50974: PUSH
50975: LD_VAR 0 7
50979: ARRAY
50980: PPUSH
50981: CALL_OW 74
50985: ST_TO_ADDR
// if not k then
50986: LD_VAR 0 9
50990: NOT
50991: IFFALSE 50995
// continue ;
50993: GO 47410
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
50995: LD_VAR 0 9
50999: PUSH
51000: LD_INT 81
51002: PUSH
51003: LD_VAR 0 4
51007: PUSH
51008: LD_VAR 0 7
51012: ARRAY
51013: PPUSH
51014: CALL_OW 255
51018: PUSH
51019: EMPTY
51020: LIST
51021: LIST
51022: PPUSH
51023: CALL_OW 69
51027: IN
51028: PUSH
51029: LD_VAR 0 9
51033: PPUSH
51034: LD_VAR 0 4
51038: PUSH
51039: LD_VAR 0 7
51043: ARRAY
51044: PPUSH
51045: CALL_OW 296
51049: PUSH
51050: LD_INT 5
51052: LESS
51053: AND
51054: IFFALSE 51071
// ComAutodestruct ( group [ i ] ) ;
51056: LD_VAR 0 4
51060: PUSH
51061: LD_VAR 0 7
51065: ARRAY
51066: PPUSH
51067: CALL 45505 0 1
// end ; if f_attack_depot then
51071: LD_VAR 0 25
51075: IFFALSE 51187
// begin k := 6 ;
51077: LD_ADDR_VAR 0 9
51081: PUSH
51082: LD_INT 6
51084: ST_TO_ADDR
// if tmp < k then
51085: LD_VAR 0 14
51089: PUSH
51090: LD_VAR 0 9
51094: LESS
51095: IFFALSE 51107
// k := tmp ;
51097: LD_ADDR_VAR 0 9
51101: PUSH
51102: LD_VAR 0 14
51106: ST_TO_ADDR
// for j = 1 to k do
51107: LD_ADDR_VAR 0 8
51111: PUSH
51112: DOUBLE
51113: LD_INT 1
51115: DEC
51116: ST_TO_ADDR
51117: LD_VAR 0 9
51121: PUSH
51122: FOR_TO
51123: IFFALSE 51185
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
51125: LD_VAR 0 8
51129: PPUSH
51130: CALL_OW 266
51134: PUSH
51135: LD_INT 0
51137: PUSH
51138: LD_INT 1
51140: PUSH
51141: EMPTY
51142: LIST
51143: LIST
51144: IN
51145: IFFALSE 51183
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
51147: LD_VAR 0 4
51151: PUSH
51152: LD_VAR 0 7
51156: ARRAY
51157: PPUSH
51158: LD_VAR 0 14
51162: PUSH
51163: LD_VAR 0 8
51167: ARRAY
51168: PPUSH
51169: CALL_OW 115
// attacking := true ;
51173: LD_ADDR_VAR 0 29
51177: PUSH
51178: LD_INT 1
51180: ST_TO_ADDR
// break ;
51181: GO 51185
// end ;
51183: GO 51122
51185: POP
51186: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
51187: LD_VAR 0 4
51191: PUSH
51192: LD_VAR 0 7
51196: ARRAY
51197: PPUSH
51198: CALL_OW 302
51202: PUSH
51203: LD_VAR 0 29
51207: NOT
51208: AND
51209: IFFALSE 51531
// begin if GetTag ( group [ i ] ) = 71 then
51211: LD_VAR 0 4
51215: PUSH
51216: LD_VAR 0 7
51220: ARRAY
51221: PPUSH
51222: CALL_OW 110
51226: PUSH
51227: LD_INT 71
51229: EQUAL
51230: IFFALSE 51271
// begin if HasTask ( group [ i ] ) then
51232: LD_VAR 0 4
51236: PUSH
51237: LD_VAR 0 7
51241: ARRAY
51242: PPUSH
51243: CALL_OW 314
51247: IFFALSE 51253
// continue else
51249: GO 47410
51251: GO 51271
// SetTag ( group [ i ] , 0 ) ;
51253: LD_VAR 0 4
51257: PUSH
51258: LD_VAR 0 7
51262: ARRAY
51263: PPUSH
51264: LD_INT 0
51266: PPUSH
51267: CALL_OW 109
// end ; k := 8 ;
51271: LD_ADDR_VAR 0 9
51275: PUSH
51276: LD_INT 8
51278: ST_TO_ADDR
// x := 0 ;
51279: LD_ADDR_VAR 0 10
51283: PUSH
51284: LD_INT 0
51286: ST_TO_ADDR
// if tmp < k then
51287: LD_VAR 0 14
51291: PUSH
51292: LD_VAR 0 9
51296: LESS
51297: IFFALSE 51309
// k := tmp ;
51299: LD_ADDR_VAR 0 9
51303: PUSH
51304: LD_VAR 0 14
51308: ST_TO_ADDR
// for j = 1 to k do
51309: LD_ADDR_VAR 0 8
51313: PUSH
51314: DOUBLE
51315: LD_INT 1
51317: DEC
51318: ST_TO_ADDR
51319: LD_VAR 0 9
51323: PUSH
51324: FOR_TO
51325: IFFALSE 51423
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
51327: LD_VAR 0 14
51331: PUSH
51332: LD_VAR 0 8
51336: ARRAY
51337: PPUSH
51338: CALL_OW 247
51342: PUSH
51343: LD_INT 1
51345: EQUAL
51346: PUSH
51347: LD_VAR 0 14
51351: PUSH
51352: LD_VAR 0 8
51356: ARRAY
51357: PPUSH
51358: CALL_OW 256
51362: PUSH
51363: LD_INT 250
51365: LESS
51366: PUSH
51367: LD_VAR 0 20
51371: AND
51372: PUSH
51373: LD_VAR 0 20
51377: NOT
51378: PUSH
51379: LD_VAR 0 14
51383: PUSH
51384: LD_VAR 0 8
51388: ARRAY
51389: PPUSH
51390: CALL_OW 256
51394: PUSH
51395: LD_INT 250
51397: GREATEREQUAL
51398: AND
51399: OR
51400: AND
51401: IFFALSE 51421
// begin x := tmp [ j ] ;
51403: LD_ADDR_VAR 0 10
51407: PUSH
51408: LD_VAR 0 14
51412: PUSH
51413: LD_VAR 0 8
51417: ARRAY
51418: ST_TO_ADDR
// break ;
51419: GO 51423
// end ;
51421: GO 51324
51423: POP
51424: POP
// if x then
51425: LD_VAR 0 10
51429: IFFALSE 51453
// ComAttackUnit ( group [ i ] , x ) else
51431: LD_VAR 0 4
51435: PUSH
51436: LD_VAR 0 7
51440: ARRAY
51441: PPUSH
51442: LD_VAR 0 10
51446: PPUSH
51447: CALL_OW 115
51451: GO 51477
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
51453: LD_VAR 0 4
51457: PUSH
51458: LD_VAR 0 7
51462: ARRAY
51463: PPUSH
51464: LD_VAR 0 14
51468: PUSH
51469: LD_INT 1
51471: ARRAY
51472: PPUSH
51473: CALL_OW 115
// if not HasTask ( group [ i ] ) then
51477: LD_VAR 0 4
51481: PUSH
51482: LD_VAR 0 7
51486: ARRAY
51487: PPUSH
51488: CALL_OW 314
51492: NOT
51493: IFFALSE 51531
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
51495: LD_VAR 0 4
51499: PUSH
51500: LD_VAR 0 7
51504: ARRAY
51505: PPUSH
51506: LD_VAR 0 14
51510: PPUSH
51511: LD_VAR 0 4
51515: PUSH
51516: LD_VAR 0 7
51520: ARRAY
51521: PPUSH
51522: CALL_OW 74
51526: PPUSH
51527: CALL_OW 115
// end ; end ; end ;
51531: GO 47410
51533: POP
51534: POP
// wait ( 0 0$2 ) ;
51535: LD_INT 70
51537: PPUSH
51538: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
51542: LD_VAR 0 4
51546: NOT
51547: PUSH
51548: LD_VAR 0 4
51552: PUSH
51553: EMPTY
51554: EQUAL
51555: OR
51556: PUSH
51557: LD_INT 81
51559: PUSH
51560: LD_VAR 0 35
51564: PUSH
51565: EMPTY
51566: LIST
51567: LIST
51568: PPUSH
51569: CALL_OW 69
51573: NOT
51574: OR
51575: IFFALSE 47395
// end ;
51577: LD_VAR 0 2
51581: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
51582: LD_INT 0
51584: PPUSH
51585: PPUSH
51586: PPUSH
51587: PPUSH
// if not base_units then
51588: LD_VAR 0 1
51592: NOT
51593: IFFALSE 51597
// exit ;
51595: GO 51684
// result := false ;
51597: LD_ADDR_VAR 0 2
51601: PUSH
51602: LD_INT 0
51604: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
51605: LD_ADDR_VAR 0 5
51609: PUSH
51610: LD_VAR 0 1
51614: PPUSH
51615: LD_INT 21
51617: PUSH
51618: LD_INT 3
51620: PUSH
51621: EMPTY
51622: LIST
51623: LIST
51624: PPUSH
51625: CALL_OW 72
51629: ST_TO_ADDR
// if not tmp then
51630: LD_VAR 0 5
51634: NOT
51635: IFFALSE 51639
// exit ;
51637: GO 51684
// for i in tmp do
51639: LD_ADDR_VAR 0 3
51643: PUSH
51644: LD_VAR 0 5
51648: PUSH
51649: FOR_IN
51650: IFFALSE 51682
// begin result := EnemyInRange ( i , 22 ) ;
51652: LD_ADDR_VAR 0 2
51656: PUSH
51657: LD_VAR 0 3
51661: PPUSH
51662: LD_INT 22
51664: PPUSH
51665: CALL 45211 0 2
51669: ST_TO_ADDR
// if result then
51670: LD_VAR 0 2
51674: IFFALSE 51680
// exit ;
51676: POP
51677: POP
51678: GO 51684
// end ;
51680: GO 51649
51682: POP
51683: POP
// end ;
51684: LD_VAR 0 2
51688: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
51689: LD_INT 0
51691: PPUSH
51692: PPUSH
// if not units then
51693: LD_VAR 0 1
51697: NOT
51698: IFFALSE 51702
// exit ;
51700: GO 51772
// result := [ ] ;
51702: LD_ADDR_VAR 0 3
51706: PUSH
51707: EMPTY
51708: ST_TO_ADDR
// for i in units do
51709: LD_ADDR_VAR 0 4
51713: PUSH
51714: LD_VAR 0 1
51718: PUSH
51719: FOR_IN
51720: IFFALSE 51770
// if GetTag ( i ) = tag then
51722: LD_VAR 0 4
51726: PPUSH
51727: CALL_OW 110
51731: PUSH
51732: LD_VAR 0 2
51736: EQUAL
51737: IFFALSE 51768
// result := Insert ( result , result + 1 , i ) ;
51739: LD_ADDR_VAR 0 3
51743: PUSH
51744: LD_VAR 0 3
51748: PPUSH
51749: LD_VAR 0 3
51753: PUSH
51754: LD_INT 1
51756: PLUS
51757: PPUSH
51758: LD_VAR 0 4
51762: PPUSH
51763: CALL_OW 2
51767: ST_TO_ADDR
51768: GO 51719
51770: POP
51771: POP
// end ;
51772: LD_VAR 0 3
51776: RET
// export function IsDriver ( un ) ; begin
51777: LD_INT 0
51779: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
51780: LD_ADDR_VAR 0 2
51784: PUSH
51785: LD_VAR 0 1
51789: PUSH
51790: LD_INT 55
51792: PUSH
51793: EMPTY
51794: LIST
51795: PPUSH
51796: CALL_OW 69
51800: IN
51801: ST_TO_ADDR
// end ;
51802: LD_VAR 0 2
51806: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
51807: LD_INT 0
51809: PPUSH
51810: PPUSH
// list := [ ] ;
51811: LD_ADDR_VAR 0 5
51815: PUSH
51816: EMPTY
51817: ST_TO_ADDR
// case d of 0 :
51818: LD_VAR 0 3
51822: PUSH
51823: LD_INT 0
51825: DOUBLE
51826: EQUAL
51827: IFTRUE 51831
51829: GO 51964
51831: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
51832: LD_ADDR_VAR 0 5
51836: PUSH
51837: LD_VAR 0 1
51841: PUSH
51842: LD_INT 4
51844: MINUS
51845: PUSH
51846: LD_VAR 0 2
51850: PUSH
51851: LD_INT 4
51853: MINUS
51854: PUSH
51855: LD_INT 2
51857: PUSH
51858: EMPTY
51859: LIST
51860: LIST
51861: LIST
51862: PUSH
51863: LD_VAR 0 1
51867: PUSH
51868: LD_INT 3
51870: MINUS
51871: PUSH
51872: LD_VAR 0 2
51876: PUSH
51877: LD_INT 1
51879: PUSH
51880: EMPTY
51881: LIST
51882: LIST
51883: LIST
51884: PUSH
51885: LD_VAR 0 1
51889: PUSH
51890: LD_INT 4
51892: PLUS
51893: PUSH
51894: LD_VAR 0 2
51898: PUSH
51899: LD_INT 4
51901: PUSH
51902: EMPTY
51903: LIST
51904: LIST
51905: LIST
51906: PUSH
51907: LD_VAR 0 1
51911: PUSH
51912: LD_INT 3
51914: PLUS
51915: PUSH
51916: LD_VAR 0 2
51920: PUSH
51921: LD_INT 3
51923: PLUS
51924: PUSH
51925: LD_INT 5
51927: PUSH
51928: EMPTY
51929: LIST
51930: LIST
51931: LIST
51932: PUSH
51933: LD_VAR 0 1
51937: PUSH
51938: LD_VAR 0 2
51942: PUSH
51943: LD_INT 4
51945: PLUS
51946: PUSH
51947: LD_INT 0
51949: PUSH
51950: EMPTY
51951: LIST
51952: LIST
51953: LIST
51954: PUSH
51955: EMPTY
51956: LIST
51957: LIST
51958: LIST
51959: LIST
51960: LIST
51961: ST_TO_ADDR
// end ; 1 :
51962: GO 52662
51964: LD_INT 1
51966: DOUBLE
51967: EQUAL
51968: IFTRUE 51972
51970: GO 52105
51972: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
51973: LD_ADDR_VAR 0 5
51977: PUSH
51978: LD_VAR 0 1
51982: PUSH
51983: LD_VAR 0 2
51987: PUSH
51988: LD_INT 4
51990: MINUS
51991: PUSH
51992: LD_INT 3
51994: PUSH
51995: EMPTY
51996: LIST
51997: LIST
51998: LIST
51999: PUSH
52000: LD_VAR 0 1
52004: PUSH
52005: LD_INT 3
52007: MINUS
52008: PUSH
52009: LD_VAR 0 2
52013: PUSH
52014: LD_INT 3
52016: MINUS
52017: PUSH
52018: LD_INT 2
52020: PUSH
52021: EMPTY
52022: LIST
52023: LIST
52024: LIST
52025: PUSH
52026: LD_VAR 0 1
52030: PUSH
52031: LD_INT 4
52033: MINUS
52034: PUSH
52035: LD_VAR 0 2
52039: PUSH
52040: LD_INT 1
52042: PUSH
52043: EMPTY
52044: LIST
52045: LIST
52046: LIST
52047: PUSH
52048: LD_VAR 0 1
52052: PUSH
52053: LD_VAR 0 2
52057: PUSH
52058: LD_INT 3
52060: PLUS
52061: PUSH
52062: LD_INT 0
52064: PUSH
52065: EMPTY
52066: LIST
52067: LIST
52068: LIST
52069: PUSH
52070: LD_VAR 0 1
52074: PUSH
52075: LD_INT 4
52077: PLUS
52078: PUSH
52079: LD_VAR 0 2
52083: PUSH
52084: LD_INT 4
52086: PLUS
52087: PUSH
52088: LD_INT 5
52090: PUSH
52091: EMPTY
52092: LIST
52093: LIST
52094: LIST
52095: PUSH
52096: EMPTY
52097: LIST
52098: LIST
52099: LIST
52100: LIST
52101: LIST
52102: ST_TO_ADDR
// end ; 2 :
52103: GO 52662
52105: LD_INT 2
52107: DOUBLE
52108: EQUAL
52109: IFTRUE 52113
52111: GO 52242
52113: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
52114: LD_ADDR_VAR 0 5
52118: PUSH
52119: LD_VAR 0 1
52123: PUSH
52124: LD_VAR 0 2
52128: PUSH
52129: LD_INT 3
52131: MINUS
52132: PUSH
52133: LD_INT 3
52135: PUSH
52136: EMPTY
52137: LIST
52138: LIST
52139: LIST
52140: PUSH
52141: LD_VAR 0 1
52145: PUSH
52146: LD_INT 4
52148: PLUS
52149: PUSH
52150: LD_VAR 0 2
52154: PUSH
52155: LD_INT 4
52157: PUSH
52158: EMPTY
52159: LIST
52160: LIST
52161: LIST
52162: PUSH
52163: LD_VAR 0 1
52167: PUSH
52168: LD_VAR 0 2
52172: PUSH
52173: LD_INT 4
52175: PLUS
52176: PUSH
52177: LD_INT 0
52179: PUSH
52180: EMPTY
52181: LIST
52182: LIST
52183: LIST
52184: PUSH
52185: LD_VAR 0 1
52189: PUSH
52190: LD_INT 3
52192: MINUS
52193: PUSH
52194: LD_VAR 0 2
52198: PUSH
52199: LD_INT 1
52201: PUSH
52202: EMPTY
52203: LIST
52204: LIST
52205: LIST
52206: PUSH
52207: LD_VAR 0 1
52211: PUSH
52212: LD_INT 4
52214: MINUS
52215: PUSH
52216: LD_VAR 0 2
52220: PUSH
52221: LD_INT 4
52223: MINUS
52224: PUSH
52225: LD_INT 2
52227: PUSH
52228: EMPTY
52229: LIST
52230: LIST
52231: LIST
52232: PUSH
52233: EMPTY
52234: LIST
52235: LIST
52236: LIST
52237: LIST
52238: LIST
52239: ST_TO_ADDR
// end ; 3 :
52240: GO 52662
52242: LD_INT 3
52244: DOUBLE
52245: EQUAL
52246: IFTRUE 52250
52248: GO 52383
52250: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
52251: LD_ADDR_VAR 0 5
52255: PUSH
52256: LD_VAR 0 1
52260: PUSH
52261: LD_INT 3
52263: PLUS
52264: PUSH
52265: LD_VAR 0 2
52269: PUSH
52270: LD_INT 4
52272: PUSH
52273: EMPTY
52274: LIST
52275: LIST
52276: LIST
52277: PUSH
52278: LD_VAR 0 1
52282: PUSH
52283: LD_INT 4
52285: PLUS
52286: PUSH
52287: LD_VAR 0 2
52291: PUSH
52292: LD_INT 4
52294: PLUS
52295: PUSH
52296: LD_INT 5
52298: PUSH
52299: EMPTY
52300: LIST
52301: LIST
52302: LIST
52303: PUSH
52304: LD_VAR 0 1
52308: PUSH
52309: LD_INT 4
52311: MINUS
52312: PUSH
52313: LD_VAR 0 2
52317: PUSH
52318: LD_INT 1
52320: PUSH
52321: EMPTY
52322: LIST
52323: LIST
52324: LIST
52325: PUSH
52326: LD_VAR 0 1
52330: PUSH
52331: LD_VAR 0 2
52335: PUSH
52336: LD_INT 4
52338: MINUS
52339: PUSH
52340: LD_INT 3
52342: PUSH
52343: EMPTY
52344: LIST
52345: LIST
52346: LIST
52347: PUSH
52348: LD_VAR 0 1
52352: PUSH
52353: LD_INT 3
52355: MINUS
52356: PUSH
52357: LD_VAR 0 2
52361: PUSH
52362: LD_INT 3
52364: MINUS
52365: PUSH
52366: LD_INT 2
52368: PUSH
52369: EMPTY
52370: LIST
52371: LIST
52372: LIST
52373: PUSH
52374: EMPTY
52375: LIST
52376: LIST
52377: LIST
52378: LIST
52379: LIST
52380: ST_TO_ADDR
// end ; 4 :
52381: GO 52662
52383: LD_INT 4
52385: DOUBLE
52386: EQUAL
52387: IFTRUE 52391
52389: GO 52524
52391: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
52392: LD_ADDR_VAR 0 5
52396: PUSH
52397: LD_VAR 0 1
52401: PUSH
52402: LD_VAR 0 2
52406: PUSH
52407: LD_INT 4
52409: PLUS
52410: PUSH
52411: LD_INT 0
52413: PUSH
52414: EMPTY
52415: LIST
52416: LIST
52417: LIST
52418: PUSH
52419: LD_VAR 0 1
52423: PUSH
52424: LD_INT 3
52426: PLUS
52427: PUSH
52428: LD_VAR 0 2
52432: PUSH
52433: LD_INT 3
52435: PLUS
52436: PUSH
52437: LD_INT 5
52439: PUSH
52440: EMPTY
52441: LIST
52442: LIST
52443: LIST
52444: PUSH
52445: LD_VAR 0 1
52449: PUSH
52450: LD_INT 4
52452: PLUS
52453: PUSH
52454: LD_VAR 0 2
52458: PUSH
52459: LD_INT 4
52461: PUSH
52462: EMPTY
52463: LIST
52464: LIST
52465: LIST
52466: PUSH
52467: LD_VAR 0 1
52471: PUSH
52472: LD_VAR 0 2
52476: PUSH
52477: LD_INT 3
52479: MINUS
52480: PUSH
52481: LD_INT 3
52483: PUSH
52484: EMPTY
52485: LIST
52486: LIST
52487: LIST
52488: PUSH
52489: LD_VAR 0 1
52493: PUSH
52494: LD_INT 4
52496: MINUS
52497: PUSH
52498: LD_VAR 0 2
52502: PUSH
52503: LD_INT 4
52505: MINUS
52506: PUSH
52507: LD_INT 2
52509: PUSH
52510: EMPTY
52511: LIST
52512: LIST
52513: LIST
52514: PUSH
52515: EMPTY
52516: LIST
52517: LIST
52518: LIST
52519: LIST
52520: LIST
52521: ST_TO_ADDR
// end ; 5 :
52522: GO 52662
52524: LD_INT 5
52526: DOUBLE
52527: EQUAL
52528: IFTRUE 52532
52530: GO 52661
52532: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
52533: LD_ADDR_VAR 0 5
52537: PUSH
52538: LD_VAR 0 1
52542: PUSH
52543: LD_INT 4
52545: MINUS
52546: PUSH
52547: LD_VAR 0 2
52551: PUSH
52552: LD_INT 1
52554: PUSH
52555: EMPTY
52556: LIST
52557: LIST
52558: LIST
52559: PUSH
52560: LD_VAR 0 1
52564: PUSH
52565: LD_VAR 0 2
52569: PUSH
52570: LD_INT 4
52572: MINUS
52573: PUSH
52574: LD_INT 3
52576: PUSH
52577: EMPTY
52578: LIST
52579: LIST
52580: LIST
52581: PUSH
52582: LD_VAR 0 1
52586: PUSH
52587: LD_INT 4
52589: PLUS
52590: PUSH
52591: LD_VAR 0 2
52595: PUSH
52596: LD_INT 4
52598: PLUS
52599: PUSH
52600: LD_INT 5
52602: PUSH
52603: EMPTY
52604: LIST
52605: LIST
52606: LIST
52607: PUSH
52608: LD_VAR 0 1
52612: PUSH
52613: LD_INT 3
52615: PLUS
52616: PUSH
52617: LD_VAR 0 2
52621: PUSH
52622: LD_INT 4
52624: PUSH
52625: EMPTY
52626: LIST
52627: LIST
52628: LIST
52629: PUSH
52630: LD_VAR 0 1
52634: PUSH
52635: LD_VAR 0 2
52639: PUSH
52640: LD_INT 3
52642: PLUS
52643: PUSH
52644: LD_INT 0
52646: PUSH
52647: EMPTY
52648: LIST
52649: LIST
52650: LIST
52651: PUSH
52652: EMPTY
52653: LIST
52654: LIST
52655: LIST
52656: LIST
52657: LIST
52658: ST_TO_ADDR
// end ; end ;
52659: GO 52662
52661: POP
// result := list ;
52662: LD_ADDR_VAR 0 4
52666: PUSH
52667: LD_VAR 0 5
52671: ST_TO_ADDR
// end ;
52672: LD_VAR 0 4
52676: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
52677: LD_INT 0
52679: PPUSH
52680: PPUSH
52681: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
52682: LD_VAR 0 1
52686: NOT
52687: PUSH
52688: LD_VAR 0 2
52692: PUSH
52693: LD_INT 1
52695: PUSH
52696: LD_INT 2
52698: PUSH
52699: LD_INT 3
52701: PUSH
52702: LD_INT 4
52704: PUSH
52705: EMPTY
52706: LIST
52707: LIST
52708: LIST
52709: LIST
52710: IN
52711: NOT
52712: OR
52713: IFFALSE 52717
// exit ;
52715: GO 52809
// tmp := [ ] ;
52717: LD_ADDR_VAR 0 5
52721: PUSH
52722: EMPTY
52723: ST_TO_ADDR
// for i in units do
52724: LD_ADDR_VAR 0 4
52728: PUSH
52729: LD_VAR 0 1
52733: PUSH
52734: FOR_IN
52735: IFFALSE 52778
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
52737: LD_ADDR_VAR 0 5
52741: PUSH
52742: LD_VAR 0 5
52746: PPUSH
52747: LD_VAR 0 5
52751: PUSH
52752: LD_INT 1
52754: PLUS
52755: PPUSH
52756: LD_VAR 0 4
52760: PPUSH
52761: LD_VAR 0 2
52765: PPUSH
52766: CALL_OW 259
52770: PPUSH
52771: CALL_OW 2
52775: ST_TO_ADDR
52776: GO 52734
52778: POP
52779: POP
// if not tmp then
52780: LD_VAR 0 5
52784: NOT
52785: IFFALSE 52789
// exit ;
52787: GO 52809
// result := SortListByListDesc ( units , tmp ) ;
52789: LD_ADDR_VAR 0 3
52793: PUSH
52794: LD_VAR 0 1
52798: PPUSH
52799: LD_VAR 0 5
52803: PPUSH
52804: CALL_OW 77
52808: ST_TO_ADDR
// end ;
52809: LD_VAR 0 3
52813: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
52814: LD_INT 0
52816: PPUSH
52817: PPUSH
52818: PPUSH
// x := GetX ( building ) ;
52819: LD_ADDR_VAR 0 4
52823: PUSH
52824: LD_VAR 0 2
52828: PPUSH
52829: CALL_OW 250
52833: ST_TO_ADDR
// y := GetY ( building ) ;
52834: LD_ADDR_VAR 0 5
52838: PUSH
52839: LD_VAR 0 2
52843: PPUSH
52844: CALL_OW 251
52848: ST_TO_ADDR
// if GetTaskList ( unit ) then
52849: LD_VAR 0 1
52853: PPUSH
52854: CALL_OW 437
52858: IFFALSE 52953
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52860: LD_STRING e
52862: PUSH
52863: LD_VAR 0 1
52867: PPUSH
52868: CALL_OW 437
52872: PUSH
52873: LD_INT 1
52875: ARRAY
52876: PUSH
52877: LD_INT 1
52879: ARRAY
52880: EQUAL
52881: PUSH
52882: LD_VAR 0 4
52886: PUSH
52887: LD_VAR 0 1
52891: PPUSH
52892: CALL_OW 437
52896: PUSH
52897: LD_INT 1
52899: ARRAY
52900: PUSH
52901: LD_INT 2
52903: ARRAY
52904: EQUAL
52905: AND
52906: PUSH
52907: LD_VAR 0 5
52911: PUSH
52912: LD_VAR 0 1
52916: PPUSH
52917: CALL_OW 437
52921: PUSH
52922: LD_INT 1
52924: ARRAY
52925: PUSH
52926: LD_INT 3
52928: ARRAY
52929: EQUAL
52930: AND
52931: IFFALSE 52943
// result := true else
52933: LD_ADDR_VAR 0 3
52937: PUSH
52938: LD_INT 1
52940: ST_TO_ADDR
52941: GO 52951
// result := false ;
52943: LD_ADDR_VAR 0 3
52947: PUSH
52948: LD_INT 0
52950: ST_TO_ADDR
// end else
52951: GO 52961
// result := false ;
52953: LD_ADDR_VAR 0 3
52957: PUSH
52958: LD_INT 0
52960: ST_TO_ADDR
// end ;
52961: LD_VAR 0 3
52965: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
52966: LD_INT 0
52968: PPUSH
52969: PPUSH
52970: PPUSH
52971: PPUSH
// if not unit or not area then
52972: LD_VAR 0 1
52976: NOT
52977: PUSH
52978: LD_VAR 0 2
52982: NOT
52983: OR
52984: IFFALSE 52988
// exit ;
52986: GO 53152
// tmp := AreaToList ( area , i ) ;
52988: LD_ADDR_VAR 0 6
52992: PUSH
52993: LD_VAR 0 2
52997: PPUSH
52998: LD_VAR 0 5
53002: PPUSH
53003: CALL_OW 517
53007: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
53008: LD_ADDR_VAR 0 5
53012: PUSH
53013: DOUBLE
53014: LD_INT 1
53016: DEC
53017: ST_TO_ADDR
53018: LD_VAR 0 6
53022: PUSH
53023: LD_INT 1
53025: ARRAY
53026: PUSH
53027: FOR_TO
53028: IFFALSE 53150
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
53030: LD_ADDR_VAR 0 7
53034: PUSH
53035: LD_VAR 0 6
53039: PUSH
53040: LD_INT 1
53042: ARRAY
53043: PUSH
53044: LD_VAR 0 5
53048: ARRAY
53049: PUSH
53050: LD_VAR 0 6
53054: PUSH
53055: LD_INT 2
53057: ARRAY
53058: PUSH
53059: LD_VAR 0 5
53063: ARRAY
53064: PUSH
53065: EMPTY
53066: LIST
53067: LIST
53068: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
53069: LD_VAR 0 7
53073: PUSH
53074: LD_INT 1
53076: ARRAY
53077: PPUSH
53078: LD_VAR 0 7
53082: PUSH
53083: LD_INT 2
53085: ARRAY
53086: PPUSH
53087: CALL_OW 428
53091: PUSH
53092: LD_INT 0
53094: EQUAL
53095: IFFALSE 53148
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
53097: LD_VAR 0 1
53101: PPUSH
53102: LD_VAR 0 7
53106: PUSH
53107: LD_INT 1
53109: ARRAY
53110: PPUSH
53111: LD_VAR 0 7
53115: PUSH
53116: LD_INT 2
53118: ARRAY
53119: PPUSH
53120: LD_VAR 0 3
53124: PPUSH
53125: CALL_OW 48
// result := IsPlaced ( unit ) ;
53129: LD_ADDR_VAR 0 4
53133: PUSH
53134: LD_VAR 0 1
53138: PPUSH
53139: CALL_OW 305
53143: ST_TO_ADDR
// exit ;
53144: POP
53145: POP
53146: GO 53152
// end ; end ;
53148: GO 53027
53150: POP
53151: POP
// end ;
53152: LD_VAR 0 4
53156: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
53157: LD_INT 0
53159: PPUSH
53160: PPUSH
53161: PPUSH
// if not side or side > 8 then
53162: LD_VAR 0 1
53166: NOT
53167: PUSH
53168: LD_VAR 0 1
53172: PUSH
53173: LD_INT 8
53175: GREATER
53176: OR
53177: IFFALSE 53181
// exit ;
53179: GO 53368
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
53181: LD_ADDR_VAR 0 4
53185: PUSH
53186: LD_INT 22
53188: PUSH
53189: LD_VAR 0 1
53193: PUSH
53194: EMPTY
53195: LIST
53196: LIST
53197: PUSH
53198: LD_INT 21
53200: PUSH
53201: LD_INT 3
53203: PUSH
53204: EMPTY
53205: LIST
53206: LIST
53207: PUSH
53208: EMPTY
53209: LIST
53210: LIST
53211: PPUSH
53212: CALL_OW 69
53216: ST_TO_ADDR
// if not tmp then
53217: LD_VAR 0 4
53221: NOT
53222: IFFALSE 53226
// exit ;
53224: GO 53368
// enable_addtolog := true ;
53226: LD_ADDR_OWVAR 81
53230: PUSH
53231: LD_INT 1
53233: ST_TO_ADDR
// AddToLog ( [ ) ;
53234: LD_STRING [
53236: PPUSH
53237: CALL_OW 561
// for i in tmp do
53241: LD_ADDR_VAR 0 3
53245: PUSH
53246: LD_VAR 0 4
53250: PUSH
53251: FOR_IN
53252: IFFALSE 53359
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
53254: LD_STRING [
53256: PUSH
53257: LD_VAR 0 3
53261: PPUSH
53262: CALL_OW 266
53266: STR
53267: PUSH
53268: LD_STRING , 
53270: STR
53271: PUSH
53272: LD_VAR 0 3
53276: PPUSH
53277: CALL_OW 250
53281: STR
53282: PUSH
53283: LD_STRING , 
53285: STR
53286: PUSH
53287: LD_VAR 0 3
53291: PPUSH
53292: CALL_OW 251
53296: STR
53297: PUSH
53298: LD_STRING , 
53300: STR
53301: PUSH
53302: LD_VAR 0 3
53306: PPUSH
53307: CALL_OW 254
53311: STR
53312: PUSH
53313: LD_STRING , 
53315: STR
53316: PUSH
53317: LD_VAR 0 3
53321: PPUSH
53322: LD_INT 1
53324: PPUSH
53325: CALL_OW 268
53329: STR
53330: PUSH
53331: LD_STRING , 
53333: STR
53334: PUSH
53335: LD_VAR 0 3
53339: PPUSH
53340: LD_INT 2
53342: PPUSH
53343: CALL_OW 268
53347: STR
53348: PUSH
53349: LD_STRING ],
53351: STR
53352: PPUSH
53353: CALL_OW 561
// end ;
53357: GO 53251
53359: POP
53360: POP
// AddToLog ( ]; ) ;
53361: LD_STRING ];
53363: PPUSH
53364: CALL_OW 561
// end ;
53368: LD_VAR 0 2
53372: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
53373: LD_INT 0
53375: PPUSH
53376: PPUSH
53377: PPUSH
53378: PPUSH
53379: PPUSH
// if not area or not rate or not max then
53380: LD_VAR 0 1
53384: NOT
53385: PUSH
53386: LD_VAR 0 2
53390: NOT
53391: OR
53392: PUSH
53393: LD_VAR 0 4
53397: NOT
53398: OR
53399: IFFALSE 53403
// exit ;
53401: GO 53595
// while 1 do
53403: LD_INT 1
53405: IFFALSE 53595
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
53407: LD_ADDR_VAR 0 9
53411: PUSH
53412: LD_VAR 0 1
53416: PPUSH
53417: LD_INT 1
53419: PPUSH
53420: CALL_OW 287
53424: PUSH
53425: LD_INT 10
53427: MUL
53428: ST_TO_ADDR
// r := rate / 10 ;
53429: LD_ADDR_VAR 0 7
53433: PUSH
53434: LD_VAR 0 2
53438: PUSH
53439: LD_INT 10
53441: DIVREAL
53442: ST_TO_ADDR
// time := 1 1$00 ;
53443: LD_ADDR_VAR 0 8
53447: PUSH
53448: LD_INT 2100
53450: ST_TO_ADDR
// if amount < min then
53451: LD_VAR 0 9
53455: PUSH
53456: LD_VAR 0 3
53460: LESS
53461: IFFALSE 53479
// r := r * 2 else
53463: LD_ADDR_VAR 0 7
53467: PUSH
53468: LD_VAR 0 7
53472: PUSH
53473: LD_INT 2
53475: MUL
53476: ST_TO_ADDR
53477: GO 53505
// if amount > max then
53479: LD_VAR 0 9
53483: PUSH
53484: LD_VAR 0 4
53488: GREATER
53489: IFFALSE 53505
// r := r / 2 ;
53491: LD_ADDR_VAR 0 7
53495: PUSH
53496: LD_VAR 0 7
53500: PUSH
53501: LD_INT 2
53503: DIVREAL
53504: ST_TO_ADDR
// time := time / r ;
53505: LD_ADDR_VAR 0 8
53509: PUSH
53510: LD_VAR 0 8
53514: PUSH
53515: LD_VAR 0 7
53519: DIVREAL
53520: ST_TO_ADDR
// if time < 0 then
53521: LD_VAR 0 8
53525: PUSH
53526: LD_INT 0
53528: LESS
53529: IFFALSE 53546
// time := time * - 1 ;
53531: LD_ADDR_VAR 0 8
53535: PUSH
53536: LD_VAR 0 8
53540: PUSH
53541: LD_INT 1
53543: NEG
53544: MUL
53545: ST_TO_ADDR
// wait ( time ) ;
53546: LD_VAR 0 8
53550: PPUSH
53551: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
53555: LD_INT 35
53557: PPUSH
53558: LD_INT 875
53560: PPUSH
53561: CALL_OW 12
53565: PPUSH
53566: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
53570: LD_INT 1
53572: PPUSH
53573: LD_INT 5
53575: PPUSH
53576: CALL_OW 12
53580: PPUSH
53581: LD_VAR 0 1
53585: PPUSH
53586: LD_INT 1
53588: PPUSH
53589: CALL_OW 55
// end ;
53593: GO 53403
// end ;
53595: LD_VAR 0 5
53599: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
53600: LD_INT 0
53602: PPUSH
53603: PPUSH
53604: PPUSH
53605: PPUSH
53606: PPUSH
53607: PPUSH
53608: PPUSH
53609: PPUSH
// if not turrets or not factories then
53610: LD_VAR 0 1
53614: NOT
53615: PUSH
53616: LD_VAR 0 2
53620: NOT
53621: OR
53622: IFFALSE 53626
// exit ;
53624: GO 53933
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
53626: LD_ADDR_VAR 0 10
53630: PUSH
53631: LD_INT 5
53633: PUSH
53634: LD_INT 6
53636: PUSH
53637: EMPTY
53638: LIST
53639: LIST
53640: PUSH
53641: LD_INT 2
53643: PUSH
53644: LD_INT 4
53646: PUSH
53647: EMPTY
53648: LIST
53649: LIST
53650: PUSH
53651: LD_INT 3
53653: PUSH
53654: LD_INT 5
53656: PUSH
53657: EMPTY
53658: LIST
53659: LIST
53660: PUSH
53661: EMPTY
53662: LIST
53663: LIST
53664: LIST
53665: PUSH
53666: LD_INT 24
53668: PUSH
53669: LD_INT 25
53671: PUSH
53672: EMPTY
53673: LIST
53674: LIST
53675: PUSH
53676: LD_INT 23
53678: PUSH
53679: LD_INT 27
53681: PUSH
53682: EMPTY
53683: LIST
53684: LIST
53685: PUSH
53686: EMPTY
53687: LIST
53688: LIST
53689: PUSH
53690: LD_INT 42
53692: PUSH
53693: LD_INT 43
53695: PUSH
53696: EMPTY
53697: LIST
53698: LIST
53699: PUSH
53700: LD_INT 44
53702: PUSH
53703: LD_INT 46
53705: PUSH
53706: EMPTY
53707: LIST
53708: LIST
53709: PUSH
53710: LD_INT 45
53712: PUSH
53713: LD_INT 47
53715: PUSH
53716: EMPTY
53717: LIST
53718: LIST
53719: PUSH
53720: EMPTY
53721: LIST
53722: LIST
53723: LIST
53724: PUSH
53725: EMPTY
53726: LIST
53727: LIST
53728: LIST
53729: ST_TO_ADDR
// result := [ ] ;
53730: LD_ADDR_VAR 0 3
53734: PUSH
53735: EMPTY
53736: ST_TO_ADDR
// for i in turrets do
53737: LD_ADDR_VAR 0 4
53741: PUSH
53742: LD_VAR 0 1
53746: PUSH
53747: FOR_IN
53748: IFFALSE 53931
// begin nat := GetNation ( i ) ;
53750: LD_ADDR_VAR 0 7
53754: PUSH
53755: LD_VAR 0 4
53759: PPUSH
53760: CALL_OW 248
53764: ST_TO_ADDR
// weapon := 0 ;
53765: LD_ADDR_VAR 0 8
53769: PUSH
53770: LD_INT 0
53772: ST_TO_ADDR
// if not nat then
53773: LD_VAR 0 7
53777: NOT
53778: IFFALSE 53782
// continue ;
53780: GO 53747
// for j in list [ nat ] do
53782: LD_ADDR_VAR 0 5
53786: PUSH
53787: LD_VAR 0 10
53791: PUSH
53792: LD_VAR 0 7
53796: ARRAY
53797: PUSH
53798: FOR_IN
53799: IFFALSE 53840
// if GetBWeapon ( i ) = j [ 1 ] then
53801: LD_VAR 0 4
53805: PPUSH
53806: CALL_OW 269
53810: PUSH
53811: LD_VAR 0 5
53815: PUSH
53816: LD_INT 1
53818: ARRAY
53819: EQUAL
53820: IFFALSE 53838
// begin weapon := j [ 2 ] ;
53822: LD_ADDR_VAR 0 8
53826: PUSH
53827: LD_VAR 0 5
53831: PUSH
53832: LD_INT 2
53834: ARRAY
53835: ST_TO_ADDR
// break ;
53836: GO 53840
// end ;
53838: GO 53798
53840: POP
53841: POP
// if not weapon then
53842: LD_VAR 0 8
53846: NOT
53847: IFFALSE 53851
// continue ;
53849: GO 53747
// for k in factories do
53851: LD_ADDR_VAR 0 6
53855: PUSH
53856: LD_VAR 0 2
53860: PUSH
53861: FOR_IN
53862: IFFALSE 53927
// begin weapons := AvailableWeaponList ( k ) ;
53864: LD_ADDR_VAR 0 9
53868: PUSH
53869: LD_VAR 0 6
53873: PPUSH
53874: CALL_OW 478
53878: ST_TO_ADDR
// if not weapons then
53879: LD_VAR 0 9
53883: NOT
53884: IFFALSE 53888
// continue ;
53886: GO 53861
// if weapon in weapons then
53888: LD_VAR 0 8
53892: PUSH
53893: LD_VAR 0 9
53897: IN
53898: IFFALSE 53925
// begin result := [ i , weapon ] ;
53900: LD_ADDR_VAR 0 3
53904: PUSH
53905: LD_VAR 0 4
53909: PUSH
53910: LD_VAR 0 8
53914: PUSH
53915: EMPTY
53916: LIST
53917: LIST
53918: ST_TO_ADDR
// exit ;
53919: POP
53920: POP
53921: POP
53922: POP
53923: GO 53933
// end ; end ;
53925: GO 53861
53927: POP
53928: POP
// end ;
53929: GO 53747
53931: POP
53932: POP
// end ;
53933: LD_VAR 0 3
53937: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
53938: LD_INT 0
53940: PPUSH
// if not side or side > 8 then
53941: LD_VAR 0 3
53945: NOT
53946: PUSH
53947: LD_VAR 0 3
53951: PUSH
53952: LD_INT 8
53954: GREATER
53955: OR
53956: IFFALSE 53960
// exit ;
53958: GO 54019
// if not range then
53960: LD_VAR 0 4
53964: NOT
53965: IFFALSE 53976
// range := - 12 ;
53967: LD_ADDR_VAR 0 4
53971: PUSH
53972: LD_INT 12
53974: NEG
53975: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
53976: LD_VAR 0 1
53980: PPUSH
53981: LD_VAR 0 2
53985: PPUSH
53986: LD_VAR 0 3
53990: PPUSH
53991: LD_VAR 0 4
53995: PPUSH
53996: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
54000: LD_VAR 0 1
54004: PPUSH
54005: LD_VAR 0 2
54009: PPUSH
54010: LD_VAR 0 3
54014: PPUSH
54015: CALL_OW 331
// end ;
54019: LD_VAR 0 5
54023: RET
// export function Video ( mode ) ; begin
54024: LD_INT 0
54026: PPUSH
// ingame_video = mode ;
54027: LD_ADDR_OWVAR 52
54031: PUSH
54032: LD_VAR 0 1
54036: ST_TO_ADDR
// interface_hidden = mode ;
54037: LD_ADDR_OWVAR 54
54041: PUSH
54042: LD_VAR 0 1
54046: ST_TO_ADDR
// end ;
54047: LD_VAR 0 2
54051: RET
// export function Join ( array , element ) ; begin
54052: LD_INT 0
54054: PPUSH
// result := array ^ element ;
54055: LD_ADDR_VAR 0 3
54059: PUSH
54060: LD_VAR 0 1
54064: PUSH
54065: LD_VAR 0 2
54069: ADD
54070: ST_TO_ADDR
// end ;
54071: LD_VAR 0 3
54075: RET
// export function JoinUnion ( array , element ) ; begin
54076: LD_INT 0
54078: PPUSH
// result := array union element ;
54079: LD_ADDR_VAR 0 3
54083: PUSH
54084: LD_VAR 0 1
54088: PUSH
54089: LD_VAR 0 2
54093: UNION
54094: ST_TO_ADDR
// end ;
54095: LD_VAR 0 3
54099: RET
// export function GetBehemoths ( side ) ; begin
54100: LD_INT 0
54102: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
54103: LD_ADDR_VAR 0 2
54107: PUSH
54108: LD_INT 22
54110: PUSH
54111: LD_VAR 0 1
54115: PUSH
54116: EMPTY
54117: LIST
54118: LIST
54119: PUSH
54120: LD_INT 31
54122: PUSH
54123: LD_INT 25
54125: PUSH
54126: EMPTY
54127: LIST
54128: LIST
54129: PUSH
54130: EMPTY
54131: LIST
54132: LIST
54133: PPUSH
54134: CALL_OW 69
54138: ST_TO_ADDR
// end ;
54139: LD_VAR 0 2
54143: RET
// export function Shuffle ( array ) ; var i , index ; begin
54144: LD_INT 0
54146: PPUSH
54147: PPUSH
54148: PPUSH
// result := [ ] ;
54149: LD_ADDR_VAR 0 2
54153: PUSH
54154: EMPTY
54155: ST_TO_ADDR
// if not array then
54156: LD_VAR 0 1
54160: NOT
54161: IFFALSE 54165
// exit ;
54163: GO 54264
// Randomize ;
54165: CALL_OW 10
// for i = array downto 1 do
54169: LD_ADDR_VAR 0 3
54173: PUSH
54174: DOUBLE
54175: LD_VAR 0 1
54179: INC
54180: ST_TO_ADDR
54181: LD_INT 1
54183: PUSH
54184: FOR_DOWNTO
54185: IFFALSE 54262
// begin index := rand ( 1 , array ) ;
54187: LD_ADDR_VAR 0 4
54191: PUSH
54192: LD_INT 1
54194: PPUSH
54195: LD_VAR 0 1
54199: PPUSH
54200: CALL_OW 12
54204: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
54205: LD_ADDR_VAR 0 2
54209: PUSH
54210: LD_VAR 0 2
54214: PPUSH
54215: LD_VAR 0 2
54219: PUSH
54220: LD_INT 1
54222: PLUS
54223: PPUSH
54224: LD_VAR 0 1
54228: PUSH
54229: LD_VAR 0 4
54233: ARRAY
54234: PPUSH
54235: CALL_OW 2
54239: ST_TO_ADDR
// array := Delete ( array , index ) ;
54240: LD_ADDR_VAR 0 1
54244: PUSH
54245: LD_VAR 0 1
54249: PPUSH
54250: LD_VAR 0 4
54254: PPUSH
54255: CALL_OW 3
54259: ST_TO_ADDR
// end ;
54260: GO 54184
54262: POP
54263: POP
// end ;
54264: LD_VAR 0 2
54268: RET
// export function GetBaseMaterials ( base ) ; begin
54269: LD_INT 0
54271: PPUSH
// result := [ 0 , 0 , 0 ] ;
54272: LD_ADDR_VAR 0 2
54276: PUSH
54277: LD_INT 0
54279: PUSH
54280: LD_INT 0
54282: PUSH
54283: LD_INT 0
54285: PUSH
54286: EMPTY
54287: LIST
54288: LIST
54289: LIST
54290: ST_TO_ADDR
// if not base then
54291: LD_VAR 0 1
54295: NOT
54296: IFFALSE 54300
// exit ;
54298: GO 54349
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
54300: LD_ADDR_VAR 0 2
54304: PUSH
54305: LD_VAR 0 1
54309: PPUSH
54310: LD_INT 1
54312: PPUSH
54313: CALL_OW 275
54317: PUSH
54318: LD_VAR 0 1
54322: PPUSH
54323: LD_INT 2
54325: PPUSH
54326: CALL_OW 275
54330: PUSH
54331: LD_VAR 0 1
54335: PPUSH
54336: LD_INT 3
54338: PPUSH
54339: CALL_OW 275
54343: PUSH
54344: EMPTY
54345: LIST
54346: LIST
54347: LIST
54348: ST_TO_ADDR
// end ; end_of_file
54349: LD_VAR 0 2
54353: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
54354: GO 54356
54356: DISABLE
// begin ru_radar := 98 ;
54357: LD_ADDR_EXP 45
54361: PUSH
54362: LD_INT 98
54364: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
54365: LD_ADDR_EXP 46
54369: PUSH
54370: LD_INT 89
54372: ST_TO_ADDR
// us_hack := 99 ;
54373: LD_ADDR_EXP 47
54377: PUSH
54378: LD_INT 99
54380: ST_TO_ADDR
// us_artillery := 97 ;
54381: LD_ADDR_EXP 48
54385: PUSH
54386: LD_INT 97
54388: ST_TO_ADDR
// ar_bio_bomb := 91 ;
54389: LD_ADDR_EXP 49
54393: PUSH
54394: LD_INT 91
54396: ST_TO_ADDR
// end ; end_of_file
54397: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
54398: LD_INT 0
54400: PPUSH
54401: PPUSH
// skirmish := false ;
54402: LD_ADDR_EXP 50
54406: PUSH
54407: LD_INT 0
54409: ST_TO_ADDR
// debug_mc := false ;
54410: LD_ADDR_EXP 51
54414: PUSH
54415: LD_INT 0
54417: ST_TO_ADDR
// mc_bases := [ ] ;
54418: LD_ADDR_EXP 52
54422: PUSH
54423: EMPTY
54424: ST_TO_ADDR
// mc_sides := [ ] ;
54425: LD_ADDR_EXP 78
54429: PUSH
54430: EMPTY
54431: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
54432: LD_ADDR_EXP 53
54436: PUSH
54437: EMPTY
54438: ST_TO_ADDR
// mc_building_repairs := [ ] ;
54439: LD_ADDR_EXP 54
54443: PUSH
54444: EMPTY
54445: ST_TO_ADDR
// mc_need_heal := [ ] ;
54446: LD_ADDR_EXP 55
54450: PUSH
54451: EMPTY
54452: ST_TO_ADDR
// mc_healers := [ ] ;
54453: LD_ADDR_EXP 56
54457: PUSH
54458: EMPTY
54459: ST_TO_ADDR
// mc_build_list := [ ] ;
54460: LD_ADDR_EXP 57
54464: PUSH
54465: EMPTY
54466: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
54467: LD_ADDR_EXP 84
54471: PUSH
54472: EMPTY
54473: ST_TO_ADDR
// mc_builders := [ ] ;
54474: LD_ADDR_EXP 58
54478: PUSH
54479: EMPTY
54480: ST_TO_ADDR
// mc_construct_list := [ ] ;
54481: LD_ADDR_EXP 59
54485: PUSH
54486: EMPTY
54487: ST_TO_ADDR
// mc_turret_list := [ ] ;
54488: LD_ADDR_EXP 60
54492: PUSH
54493: EMPTY
54494: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
54495: LD_ADDR_EXP 61
54499: PUSH
54500: EMPTY
54501: ST_TO_ADDR
// mc_miners := [ ] ;
54502: LD_ADDR_EXP 66
54506: PUSH
54507: EMPTY
54508: ST_TO_ADDR
// mc_mines := [ ] ;
54509: LD_ADDR_EXP 65
54513: PUSH
54514: EMPTY
54515: ST_TO_ADDR
// mc_minefields := [ ] ;
54516: LD_ADDR_EXP 67
54520: PUSH
54521: EMPTY
54522: ST_TO_ADDR
// mc_crates := [ ] ;
54523: LD_ADDR_EXP 68
54527: PUSH
54528: EMPTY
54529: ST_TO_ADDR
// mc_crates_collector := [ ] ;
54530: LD_ADDR_EXP 69
54534: PUSH
54535: EMPTY
54536: ST_TO_ADDR
// mc_crates_area := [ ] ;
54537: LD_ADDR_EXP 70
54541: PUSH
54542: EMPTY
54543: ST_TO_ADDR
// mc_vehicles := [ ] ;
54544: LD_ADDR_EXP 71
54548: PUSH
54549: EMPTY
54550: ST_TO_ADDR
// mc_attack := [ ] ;
54551: LD_ADDR_EXP 72
54555: PUSH
54556: EMPTY
54557: ST_TO_ADDR
// mc_produce := [ ] ;
54558: LD_ADDR_EXP 73
54562: PUSH
54563: EMPTY
54564: ST_TO_ADDR
// mc_defender := [ ] ;
54565: LD_ADDR_EXP 74
54569: PUSH
54570: EMPTY
54571: ST_TO_ADDR
// mc_parking := [ ] ;
54572: LD_ADDR_EXP 76
54576: PUSH
54577: EMPTY
54578: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
54579: LD_ADDR_EXP 62
54583: PUSH
54584: EMPTY
54585: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
54586: LD_ADDR_EXP 64
54590: PUSH
54591: EMPTY
54592: ST_TO_ADDR
// mc_scan := [ ] ;
54593: LD_ADDR_EXP 75
54597: PUSH
54598: EMPTY
54599: ST_TO_ADDR
// mc_scan_area := [ ] ;
54600: LD_ADDR_EXP 77
54604: PUSH
54605: EMPTY
54606: ST_TO_ADDR
// mc_tech := [ ] ;
54607: LD_ADDR_EXP 79
54611: PUSH
54612: EMPTY
54613: ST_TO_ADDR
// mc_class := [ ] ;
54614: LD_ADDR_EXP 93
54618: PUSH
54619: EMPTY
54620: ST_TO_ADDR
// mc_class_case_use := [ ] ;
54621: LD_ADDR_EXP 94
54625: PUSH
54626: EMPTY
54627: ST_TO_ADDR
// end ;
54628: LD_VAR 0 1
54632: RET
// export function MC_Kill ( base ) ; begin
54633: LD_INT 0
54635: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
54636: LD_ADDR_EXP 52
54640: PUSH
54641: LD_EXP 52
54645: PPUSH
54646: LD_VAR 0 1
54650: PPUSH
54651: EMPTY
54652: PPUSH
54653: CALL_OW 1
54657: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
54658: LD_ADDR_EXP 53
54662: PUSH
54663: LD_EXP 53
54667: PPUSH
54668: LD_VAR 0 1
54672: PPUSH
54673: EMPTY
54674: PPUSH
54675: CALL_OW 1
54679: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
54680: LD_ADDR_EXP 54
54684: PUSH
54685: LD_EXP 54
54689: PPUSH
54690: LD_VAR 0 1
54694: PPUSH
54695: EMPTY
54696: PPUSH
54697: CALL_OW 1
54701: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
54702: LD_ADDR_EXP 55
54706: PUSH
54707: LD_EXP 55
54711: PPUSH
54712: LD_VAR 0 1
54716: PPUSH
54717: EMPTY
54718: PPUSH
54719: CALL_OW 1
54723: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
54724: LD_ADDR_EXP 56
54728: PUSH
54729: LD_EXP 56
54733: PPUSH
54734: LD_VAR 0 1
54738: PPUSH
54739: EMPTY
54740: PPUSH
54741: CALL_OW 1
54745: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
54746: LD_ADDR_EXP 57
54750: PUSH
54751: LD_EXP 57
54755: PPUSH
54756: LD_VAR 0 1
54760: PPUSH
54761: EMPTY
54762: PPUSH
54763: CALL_OW 1
54767: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
54768: LD_ADDR_EXP 58
54772: PUSH
54773: LD_EXP 58
54777: PPUSH
54778: LD_VAR 0 1
54782: PPUSH
54783: EMPTY
54784: PPUSH
54785: CALL_OW 1
54789: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
54790: LD_ADDR_EXP 59
54794: PUSH
54795: LD_EXP 59
54799: PPUSH
54800: LD_VAR 0 1
54804: PPUSH
54805: EMPTY
54806: PPUSH
54807: CALL_OW 1
54811: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
54812: LD_ADDR_EXP 60
54816: PUSH
54817: LD_EXP 60
54821: PPUSH
54822: LD_VAR 0 1
54826: PPUSH
54827: EMPTY
54828: PPUSH
54829: CALL_OW 1
54833: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
54834: LD_ADDR_EXP 61
54838: PUSH
54839: LD_EXP 61
54843: PPUSH
54844: LD_VAR 0 1
54848: PPUSH
54849: EMPTY
54850: PPUSH
54851: CALL_OW 1
54855: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
54856: LD_ADDR_EXP 62
54860: PUSH
54861: LD_EXP 62
54865: PPUSH
54866: LD_VAR 0 1
54870: PPUSH
54871: EMPTY
54872: PPUSH
54873: CALL_OW 1
54877: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
54878: LD_ADDR_EXP 63
54882: PUSH
54883: LD_EXP 63
54887: PPUSH
54888: LD_VAR 0 1
54892: PPUSH
54893: LD_INT 0
54895: PPUSH
54896: CALL_OW 1
54900: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
54901: LD_ADDR_EXP 64
54905: PUSH
54906: LD_EXP 64
54910: PPUSH
54911: LD_VAR 0 1
54915: PPUSH
54916: EMPTY
54917: PPUSH
54918: CALL_OW 1
54922: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
54923: LD_ADDR_EXP 65
54927: PUSH
54928: LD_EXP 65
54932: PPUSH
54933: LD_VAR 0 1
54937: PPUSH
54938: EMPTY
54939: PPUSH
54940: CALL_OW 1
54944: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
54945: LD_ADDR_EXP 66
54949: PUSH
54950: LD_EXP 66
54954: PPUSH
54955: LD_VAR 0 1
54959: PPUSH
54960: EMPTY
54961: PPUSH
54962: CALL_OW 1
54966: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
54967: LD_ADDR_EXP 67
54971: PUSH
54972: LD_EXP 67
54976: PPUSH
54977: LD_VAR 0 1
54981: PPUSH
54982: EMPTY
54983: PPUSH
54984: CALL_OW 1
54988: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
54989: LD_ADDR_EXP 68
54993: PUSH
54994: LD_EXP 68
54998: PPUSH
54999: LD_VAR 0 1
55003: PPUSH
55004: EMPTY
55005: PPUSH
55006: CALL_OW 1
55010: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55011: LD_ADDR_EXP 69
55015: PUSH
55016: LD_EXP 69
55020: PPUSH
55021: LD_VAR 0 1
55025: PPUSH
55026: EMPTY
55027: PPUSH
55028: CALL_OW 1
55032: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55033: LD_ADDR_EXP 70
55037: PUSH
55038: LD_EXP 70
55042: PPUSH
55043: LD_VAR 0 1
55047: PPUSH
55048: EMPTY
55049: PPUSH
55050: CALL_OW 1
55054: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55055: LD_ADDR_EXP 71
55059: PUSH
55060: LD_EXP 71
55064: PPUSH
55065: LD_VAR 0 1
55069: PPUSH
55070: EMPTY
55071: PPUSH
55072: CALL_OW 1
55076: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55077: LD_ADDR_EXP 72
55081: PUSH
55082: LD_EXP 72
55086: PPUSH
55087: LD_VAR 0 1
55091: PPUSH
55092: EMPTY
55093: PPUSH
55094: CALL_OW 1
55098: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55099: LD_ADDR_EXP 73
55103: PUSH
55104: LD_EXP 73
55108: PPUSH
55109: LD_VAR 0 1
55113: PPUSH
55114: EMPTY
55115: PPUSH
55116: CALL_OW 1
55120: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55121: LD_ADDR_EXP 74
55125: PUSH
55126: LD_EXP 74
55130: PPUSH
55131: LD_VAR 0 1
55135: PPUSH
55136: EMPTY
55137: PPUSH
55138: CALL_OW 1
55142: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55143: LD_ADDR_EXP 75
55147: PUSH
55148: LD_EXP 75
55152: PPUSH
55153: LD_VAR 0 1
55157: PPUSH
55158: EMPTY
55159: PPUSH
55160: CALL_OW 1
55164: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55165: LD_ADDR_EXP 76
55169: PUSH
55170: LD_EXP 76
55174: PPUSH
55175: LD_VAR 0 1
55179: PPUSH
55180: EMPTY
55181: PPUSH
55182: CALL_OW 1
55186: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55187: LD_ADDR_EXP 77
55191: PUSH
55192: LD_EXP 77
55196: PPUSH
55197: LD_VAR 0 1
55201: PPUSH
55202: EMPTY
55203: PPUSH
55204: CALL_OW 1
55208: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55209: LD_ADDR_EXP 79
55213: PUSH
55214: LD_EXP 79
55218: PPUSH
55219: LD_VAR 0 1
55223: PPUSH
55224: EMPTY
55225: PPUSH
55226: CALL_OW 1
55230: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55231: LD_ADDR_EXP 81
55235: PUSH
55236: LD_EXP 81
55240: PPUSH
55241: LD_VAR 0 1
55245: PPUSH
55246: EMPTY
55247: PPUSH
55248: CALL_OW 1
55252: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55253: LD_ADDR_EXP 82
55257: PUSH
55258: LD_EXP 82
55262: PPUSH
55263: LD_VAR 0 1
55267: PPUSH
55268: EMPTY
55269: PPUSH
55270: CALL_OW 1
55274: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55275: LD_ADDR_EXP 83
55279: PUSH
55280: LD_EXP 83
55284: PPUSH
55285: LD_VAR 0 1
55289: PPUSH
55290: EMPTY
55291: PPUSH
55292: CALL_OW 1
55296: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55297: LD_ADDR_EXP 84
55301: PUSH
55302: LD_EXP 84
55306: PPUSH
55307: LD_VAR 0 1
55311: PPUSH
55312: EMPTY
55313: PPUSH
55314: CALL_OW 1
55318: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55319: LD_ADDR_EXP 85
55323: PUSH
55324: LD_EXP 85
55328: PPUSH
55329: LD_VAR 0 1
55333: PPUSH
55334: EMPTY
55335: PPUSH
55336: CALL_OW 1
55340: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55341: LD_ADDR_EXP 86
55345: PUSH
55346: LD_EXP 86
55350: PPUSH
55351: LD_VAR 0 1
55355: PPUSH
55356: EMPTY
55357: PPUSH
55358: CALL_OW 1
55362: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55363: LD_ADDR_EXP 87
55367: PUSH
55368: LD_EXP 87
55372: PPUSH
55373: LD_VAR 0 1
55377: PPUSH
55378: EMPTY
55379: PPUSH
55380: CALL_OW 1
55384: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55385: LD_ADDR_EXP 88
55389: PUSH
55390: LD_EXP 88
55394: PPUSH
55395: LD_VAR 0 1
55399: PPUSH
55400: EMPTY
55401: PPUSH
55402: CALL_OW 1
55406: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55407: LD_ADDR_EXP 89
55411: PUSH
55412: LD_EXP 89
55416: PPUSH
55417: LD_VAR 0 1
55421: PPUSH
55422: EMPTY
55423: PPUSH
55424: CALL_OW 1
55428: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55429: LD_ADDR_EXP 90
55433: PUSH
55434: LD_EXP 90
55438: PPUSH
55439: LD_VAR 0 1
55443: PPUSH
55444: EMPTY
55445: PPUSH
55446: CALL_OW 1
55450: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55451: LD_ADDR_EXP 91
55455: PUSH
55456: LD_EXP 91
55460: PPUSH
55461: LD_VAR 0 1
55465: PPUSH
55466: EMPTY
55467: PPUSH
55468: CALL_OW 1
55472: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55473: LD_ADDR_EXP 92
55477: PUSH
55478: LD_EXP 92
55482: PPUSH
55483: LD_VAR 0 1
55487: PPUSH
55488: EMPTY
55489: PPUSH
55490: CALL_OW 1
55494: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55495: LD_ADDR_EXP 93
55499: PUSH
55500: LD_EXP 93
55504: PPUSH
55505: LD_VAR 0 1
55509: PPUSH
55510: EMPTY
55511: PPUSH
55512: CALL_OW 1
55516: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55517: LD_ADDR_EXP 94
55521: PUSH
55522: LD_EXP 94
55526: PPUSH
55527: LD_VAR 0 1
55531: PPUSH
55532: LD_INT 0
55534: PPUSH
55535: CALL_OW 1
55539: ST_TO_ADDR
// end ;
55540: LD_VAR 0 2
55544: RET
// export function MC_Add ( side , units ) ; var base ; begin
55545: LD_INT 0
55547: PPUSH
55548: PPUSH
// base := mc_bases + 1 ;
55549: LD_ADDR_VAR 0 4
55553: PUSH
55554: LD_EXP 52
55558: PUSH
55559: LD_INT 1
55561: PLUS
55562: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
55563: LD_ADDR_EXP 78
55567: PUSH
55568: LD_EXP 78
55572: PPUSH
55573: LD_VAR 0 4
55577: PPUSH
55578: LD_VAR 0 1
55582: PPUSH
55583: CALL_OW 1
55587: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
55588: LD_ADDR_EXP 52
55592: PUSH
55593: LD_EXP 52
55597: PPUSH
55598: LD_VAR 0 4
55602: PPUSH
55603: LD_VAR 0 2
55607: PPUSH
55608: CALL_OW 1
55612: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55613: LD_ADDR_EXP 53
55617: PUSH
55618: LD_EXP 53
55622: PPUSH
55623: LD_VAR 0 4
55627: PPUSH
55628: EMPTY
55629: PPUSH
55630: CALL_OW 1
55634: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55635: LD_ADDR_EXP 54
55639: PUSH
55640: LD_EXP 54
55644: PPUSH
55645: LD_VAR 0 4
55649: PPUSH
55650: EMPTY
55651: PPUSH
55652: CALL_OW 1
55656: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55657: LD_ADDR_EXP 55
55661: PUSH
55662: LD_EXP 55
55666: PPUSH
55667: LD_VAR 0 4
55671: PPUSH
55672: EMPTY
55673: PPUSH
55674: CALL_OW 1
55678: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55679: LD_ADDR_EXP 56
55683: PUSH
55684: LD_EXP 56
55688: PPUSH
55689: LD_VAR 0 4
55693: PPUSH
55694: EMPTY
55695: PPUSH
55696: CALL_OW 1
55700: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55701: LD_ADDR_EXP 57
55705: PUSH
55706: LD_EXP 57
55710: PPUSH
55711: LD_VAR 0 4
55715: PPUSH
55716: EMPTY
55717: PPUSH
55718: CALL_OW 1
55722: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55723: LD_ADDR_EXP 58
55727: PUSH
55728: LD_EXP 58
55732: PPUSH
55733: LD_VAR 0 4
55737: PPUSH
55738: EMPTY
55739: PPUSH
55740: CALL_OW 1
55744: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55745: LD_ADDR_EXP 59
55749: PUSH
55750: LD_EXP 59
55754: PPUSH
55755: LD_VAR 0 4
55759: PPUSH
55760: EMPTY
55761: PPUSH
55762: CALL_OW 1
55766: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55767: LD_ADDR_EXP 60
55771: PUSH
55772: LD_EXP 60
55776: PPUSH
55777: LD_VAR 0 4
55781: PPUSH
55782: EMPTY
55783: PPUSH
55784: CALL_OW 1
55788: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55789: LD_ADDR_EXP 61
55793: PUSH
55794: LD_EXP 61
55798: PPUSH
55799: LD_VAR 0 4
55803: PPUSH
55804: EMPTY
55805: PPUSH
55806: CALL_OW 1
55810: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55811: LD_ADDR_EXP 62
55815: PUSH
55816: LD_EXP 62
55820: PPUSH
55821: LD_VAR 0 4
55825: PPUSH
55826: EMPTY
55827: PPUSH
55828: CALL_OW 1
55832: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55833: LD_ADDR_EXP 63
55837: PUSH
55838: LD_EXP 63
55842: PPUSH
55843: LD_VAR 0 4
55847: PPUSH
55848: LD_INT 0
55850: PPUSH
55851: CALL_OW 1
55855: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55856: LD_ADDR_EXP 64
55860: PUSH
55861: LD_EXP 64
55865: PPUSH
55866: LD_VAR 0 4
55870: PPUSH
55871: EMPTY
55872: PPUSH
55873: CALL_OW 1
55877: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55878: LD_ADDR_EXP 65
55882: PUSH
55883: LD_EXP 65
55887: PPUSH
55888: LD_VAR 0 4
55892: PPUSH
55893: EMPTY
55894: PPUSH
55895: CALL_OW 1
55899: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55900: LD_ADDR_EXP 66
55904: PUSH
55905: LD_EXP 66
55909: PPUSH
55910: LD_VAR 0 4
55914: PPUSH
55915: EMPTY
55916: PPUSH
55917: CALL_OW 1
55921: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55922: LD_ADDR_EXP 67
55926: PUSH
55927: LD_EXP 67
55931: PPUSH
55932: LD_VAR 0 4
55936: PPUSH
55937: EMPTY
55938: PPUSH
55939: CALL_OW 1
55943: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55944: LD_ADDR_EXP 68
55948: PUSH
55949: LD_EXP 68
55953: PPUSH
55954: LD_VAR 0 4
55958: PPUSH
55959: EMPTY
55960: PPUSH
55961: CALL_OW 1
55965: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55966: LD_ADDR_EXP 69
55970: PUSH
55971: LD_EXP 69
55975: PPUSH
55976: LD_VAR 0 4
55980: PPUSH
55981: EMPTY
55982: PPUSH
55983: CALL_OW 1
55987: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55988: LD_ADDR_EXP 70
55992: PUSH
55993: LD_EXP 70
55997: PPUSH
55998: LD_VAR 0 4
56002: PPUSH
56003: EMPTY
56004: PPUSH
56005: CALL_OW 1
56009: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56010: LD_ADDR_EXP 71
56014: PUSH
56015: LD_EXP 71
56019: PPUSH
56020: LD_VAR 0 4
56024: PPUSH
56025: EMPTY
56026: PPUSH
56027: CALL_OW 1
56031: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56032: LD_ADDR_EXP 72
56036: PUSH
56037: LD_EXP 72
56041: PPUSH
56042: LD_VAR 0 4
56046: PPUSH
56047: EMPTY
56048: PPUSH
56049: CALL_OW 1
56053: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56054: LD_ADDR_EXP 73
56058: PUSH
56059: LD_EXP 73
56063: PPUSH
56064: LD_VAR 0 4
56068: PPUSH
56069: EMPTY
56070: PPUSH
56071: CALL_OW 1
56075: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56076: LD_ADDR_EXP 74
56080: PUSH
56081: LD_EXP 74
56085: PPUSH
56086: LD_VAR 0 4
56090: PPUSH
56091: EMPTY
56092: PPUSH
56093: CALL_OW 1
56097: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56098: LD_ADDR_EXP 75
56102: PUSH
56103: LD_EXP 75
56107: PPUSH
56108: LD_VAR 0 4
56112: PPUSH
56113: EMPTY
56114: PPUSH
56115: CALL_OW 1
56119: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56120: LD_ADDR_EXP 76
56124: PUSH
56125: LD_EXP 76
56129: PPUSH
56130: LD_VAR 0 4
56134: PPUSH
56135: EMPTY
56136: PPUSH
56137: CALL_OW 1
56141: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56142: LD_ADDR_EXP 77
56146: PUSH
56147: LD_EXP 77
56151: PPUSH
56152: LD_VAR 0 4
56156: PPUSH
56157: EMPTY
56158: PPUSH
56159: CALL_OW 1
56163: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56164: LD_ADDR_EXP 79
56168: PUSH
56169: LD_EXP 79
56173: PPUSH
56174: LD_VAR 0 4
56178: PPUSH
56179: EMPTY
56180: PPUSH
56181: CALL_OW 1
56185: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56186: LD_ADDR_EXP 81
56190: PUSH
56191: LD_EXP 81
56195: PPUSH
56196: LD_VAR 0 4
56200: PPUSH
56201: EMPTY
56202: PPUSH
56203: CALL_OW 1
56207: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56208: LD_ADDR_EXP 82
56212: PUSH
56213: LD_EXP 82
56217: PPUSH
56218: LD_VAR 0 4
56222: PPUSH
56223: EMPTY
56224: PPUSH
56225: CALL_OW 1
56229: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56230: LD_ADDR_EXP 83
56234: PUSH
56235: LD_EXP 83
56239: PPUSH
56240: LD_VAR 0 4
56244: PPUSH
56245: EMPTY
56246: PPUSH
56247: CALL_OW 1
56251: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56252: LD_ADDR_EXP 84
56256: PUSH
56257: LD_EXP 84
56261: PPUSH
56262: LD_VAR 0 4
56266: PPUSH
56267: EMPTY
56268: PPUSH
56269: CALL_OW 1
56273: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56274: LD_ADDR_EXP 85
56278: PUSH
56279: LD_EXP 85
56283: PPUSH
56284: LD_VAR 0 4
56288: PPUSH
56289: EMPTY
56290: PPUSH
56291: CALL_OW 1
56295: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56296: LD_ADDR_EXP 86
56300: PUSH
56301: LD_EXP 86
56305: PPUSH
56306: LD_VAR 0 4
56310: PPUSH
56311: EMPTY
56312: PPUSH
56313: CALL_OW 1
56317: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56318: LD_ADDR_EXP 87
56322: PUSH
56323: LD_EXP 87
56327: PPUSH
56328: LD_VAR 0 4
56332: PPUSH
56333: EMPTY
56334: PPUSH
56335: CALL_OW 1
56339: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56340: LD_ADDR_EXP 88
56344: PUSH
56345: LD_EXP 88
56349: PPUSH
56350: LD_VAR 0 4
56354: PPUSH
56355: EMPTY
56356: PPUSH
56357: CALL_OW 1
56361: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56362: LD_ADDR_EXP 89
56366: PUSH
56367: LD_EXP 89
56371: PPUSH
56372: LD_VAR 0 4
56376: PPUSH
56377: EMPTY
56378: PPUSH
56379: CALL_OW 1
56383: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56384: LD_ADDR_EXP 90
56388: PUSH
56389: LD_EXP 90
56393: PPUSH
56394: LD_VAR 0 4
56398: PPUSH
56399: EMPTY
56400: PPUSH
56401: CALL_OW 1
56405: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56406: LD_ADDR_EXP 91
56410: PUSH
56411: LD_EXP 91
56415: PPUSH
56416: LD_VAR 0 4
56420: PPUSH
56421: EMPTY
56422: PPUSH
56423: CALL_OW 1
56427: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56428: LD_ADDR_EXP 92
56432: PUSH
56433: LD_EXP 92
56437: PPUSH
56438: LD_VAR 0 4
56442: PPUSH
56443: EMPTY
56444: PPUSH
56445: CALL_OW 1
56449: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56450: LD_ADDR_EXP 93
56454: PUSH
56455: LD_EXP 93
56459: PPUSH
56460: LD_VAR 0 4
56464: PPUSH
56465: EMPTY
56466: PPUSH
56467: CALL_OW 1
56471: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56472: LD_ADDR_EXP 94
56476: PUSH
56477: LD_EXP 94
56481: PPUSH
56482: LD_VAR 0 4
56486: PPUSH
56487: LD_INT 0
56489: PPUSH
56490: CALL_OW 1
56494: ST_TO_ADDR
// result := base ;
56495: LD_ADDR_VAR 0 3
56499: PUSH
56500: LD_VAR 0 4
56504: ST_TO_ADDR
// end ;
56505: LD_VAR 0 3
56509: RET
// export function MC_Start ( ) ; var i ; begin
56510: LD_INT 0
56512: PPUSH
56513: PPUSH
// for i = 1 to mc_bases do
56514: LD_ADDR_VAR 0 2
56518: PUSH
56519: DOUBLE
56520: LD_INT 1
56522: DEC
56523: ST_TO_ADDR
56524: LD_EXP 52
56528: PUSH
56529: FOR_TO
56530: IFFALSE 57607
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
56532: LD_ADDR_EXP 52
56536: PUSH
56537: LD_EXP 52
56541: PPUSH
56542: LD_VAR 0 2
56546: PPUSH
56547: LD_EXP 52
56551: PUSH
56552: LD_VAR 0 2
56556: ARRAY
56557: PUSH
56558: LD_INT 0
56560: DIFF
56561: PPUSH
56562: CALL_OW 1
56566: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
56567: LD_ADDR_EXP 53
56571: PUSH
56572: LD_EXP 53
56576: PPUSH
56577: LD_VAR 0 2
56581: PPUSH
56582: EMPTY
56583: PPUSH
56584: CALL_OW 1
56588: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56589: LD_ADDR_EXP 54
56593: PUSH
56594: LD_EXP 54
56598: PPUSH
56599: LD_VAR 0 2
56603: PPUSH
56604: EMPTY
56605: PPUSH
56606: CALL_OW 1
56610: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
56611: LD_ADDR_EXP 55
56615: PUSH
56616: LD_EXP 55
56620: PPUSH
56621: LD_VAR 0 2
56625: PPUSH
56626: EMPTY
56627: PPUSH
56628: CALL_OW 1
56632: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
56633: LD_ADDR_EXP 56
56637: PUSH
56638: LD_EXP 56
56642: PPUSH
56643: LD_VAR 0 2
56647: PPUSH
56648: EMPTY
56649: PUSH
56650: EMPTY
56651: PUSH
56652: EMPTY
56653: LIST
56654: LIST
56655: PPUSH
56656: CALL_OW 1
56660: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
56661: LD_ADDR_EXP 57
56665: PUSH
56666: LD_EXP 57
56670: PPUSH
56671: LD_VAR 0 2
56675: PPUSH
56676: EMPTY
56677: PPUSH
56678: CALL_OW 1
56682: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
56683: LD_ADDR_EXP 84
56687: PUSH
56688: LD_EXP 84
56692: PPUSH
56693: LD_VAR 0 2
56697: PPUSH
56698: EMPTY
56699: PPUSH
56700: CALL_OW 1
56704: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
56705: LD_ADDR_EXP 58
56709: PUSH
56710: LD_EXP 58
56714: PPUSH
56715: LD_VAR 0 2
56719: PPUSH
56720: EMPTY
56721: PPUSH
56722: CALL_OW 1
56726: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
56727: LD_ADDR_EXP 59
56731: PUSH
56732: LD_EXP 59
56736: PPUSH
56737: LD_VAR 0 2
56741: PPUSH
56742: EMPTY
56743: PPUSH
56744: CALL_OW 1
56748: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
56749: LD_ADDR_EXP 60
56753: PUSH
56754: LD_EXP 60
56758: PPUSH
56759: LD_VAR 0 2
56763: PPUSH
56764: LD_EXP 52
56768: PUSH
56769: LD_VAR 0 2
56773: ARRAY
56774: PPUSH
56775: LD_INT 2
56777: PUSH
56778: LD_INT 30
56780: PUSH
56781: LD_INT 32
56783: PUSH
56784: EMPTY
56785: LIST
56786: LIST
56787: PUSH
56788: LD_INT 30
56790: PUSH
56791: LD_INT 33
56793: PUSH
56794: EMPTY
56795: LIST
56796: LIST
56797: PUSH
56798: EMPTY
56799: LIST
56800: LIST
56801: LIST
56802: PPUSH
56803: CALL_OW 72
56807: PPUSH
56808: CALL_OW 1
56812: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
56813: LD_ADDR_EXP 61
56817: PUSH
56818: LD_EXP 61
56822: PPUSH
56823: LD_VAR 0 2
56827: PPUSH
56828: LD_EXP 52
56832: PUSH
56833: LD_VAR 0 2
56837: ARRAY
56838: PPUSH
56839: LD_INT 2
56841: PUSH
56842: LD_INT 30
56844: PUSH
56845: LD_INT 32
56847: PUSH
56848: EMPTY
56849: LIST
56850: LIST
56851: PUSH
56852: LD_INT 30
56854: PUSH
56855: LD_INT 31
56857: PUSH
56858: EMPTY
56859: LIST
56860: LIST
56861: PUSH
56862: EMPTY
56863: LIST
56864: LIST
56865: LIST
56866: PUSH
56867: LD_INT 58
56869: PUSH
56870: EMPTY
56871: LIST
56872: PUSH
56873: EMPTY
56874: LIST
56875: LIST
56876: PPUSH
56877: CALL_OW 72
56881: PPUSH
56882: CALL_OW 1
56886: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
56887: LD_ADDR_EXP 62
56891: PUSH
56892: LD_EXP 62
56896: PPUSH
56897: LD_VAR 0 2
56901: PPUSH
56902: EMPTY
56903: PPUSH
56904: CALL_OW 1
56908: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
56909: LD_ADDR_EXP 66
56913: PUSH
56914: LD_EXP 66
56918: PPUSH
56919: LD_VAR 0 2
56923: PPUSH
56924: EMPTY
56925: PPUSH
56926: CALL_OW 1
56930: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
56931: LD_ADDR_EXP 65
56935: PUSH
56936: LD_EXP 65
56940: PPUSH
56941: LD_VAR 0 2
56945: PPUSH
56946: EMPTY
56947: PPUSH
56948: CALL_OW 1
56952: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
56953: LD_ADDR_EXP 67
56957: PUSH
56958: LD_EXP 67
56962: PPUSH
56963: LD_VAR 0 2
56967: PPUSH
56968: EMPTY
56969: PPUSH
56970: CALL_OW 1
56974: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
56975: LD_ADDR_EXP 68
56979: PUSH
56980: LD_EXP 68
56984: PPUSH
56985: LD_VAR 0 2
56989: PPUSH
56990: EMPTY
56991: PPUSH
56992: CALL_OW 1
56996: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
56997: LD_ADDR_EXP 69
57001: PUSH
57002: LD_EXP 69
57006: PPUSH
57007: LD_VAR 0 2
57011: PPUSH
57012: EMPTY
57013: PPUSH
57014: CALL_OW 1
57018: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57019: LD_ADDR_EXP 70
57023: PUSH
57024: LD_EXP 70
57028: PPUSH
57029: LD_VAR 0 2
57033: PPUSH
57034: EMPTY
57035: PPUSH
57036: CALL_OW 1
57040: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57041: LD_ADDR_EXP 71
57045: PUSH
57046: LD_EXP 71
57050: PPUSH
57051: LD_VAR 0 2
57055: PPUSH
57056: EMPTY
57057: PPUSH
57058: CALL_OW 1
57062: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57063: LD_ADDR_EXP 72
57067: PUSH
57068: LD_EXP 72
57072: PPUSH
57073: LD_VAR 0 2
57077: PPUSH
57078: EMPTY
57079: PPUSH
57080: CALL_OW 1
57084: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57085: LD_ADDR_EXP 73
57089: PUSH
57090: LD_EXP 73
57094: PPUSH
57095: LD_VAR 0 2
57099: PPUSH
57100: EMPTY
57101: PPUSH
57102: CALL_OW 1
57106: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57107: LD_ADDR_EXP 74
57111: PUSH
57112: LD_EXP 74
57116: PPUSH
57117: LD_VAR 0 2
57121: PPUSH
57122: EMPTY
57123: PPUSH
57124: CALL_OW 1
57128: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57129: LD_ADDR_EXP 63
57133: PUSH
57134: LD_EXP 63
57138: PPUSH
57139: LD_VAR 0 2
57143: PPUSH
57144: LD_INT 0
57146: PPUSH
57147: CALL_OW 1
57151: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57152: LD_ADDR_EXP 76
57156: PUSH
57157: LD_EXP 76
57161: PPUSH
57162: LD_VAR 0 2
57166: PPUSH
57167: LD_INT 0
57169: PPUSH
57170: CALL_OW 1
57174: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57175: LD_ADDR_EXP 64
57179: PUSH
57180: LD_EXP 64
57184: PPUSH
57185: LD_VAR 0 2
57189: PPUSH
57190: EMPTY
57191: PPUSH
57192: CALL_OW 1
57196: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
57197: LD_ADDR_EXP 75
57201: PUSH
57202: LD_EXP 75
57206: PPUSH
57207: LD_VAR 0 2
57211: PPUSH
57212: LD_INT 0
57214: PPUSH
57215: CALL_OW 1
57219: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
57220: LD_ADDR_EXP 77
57224: PUSH
57225: LD_EXP 77
57229: PPUSH
57230: LD_VAR 0 2
57234: PPUSH
57235: EMPTY
57236: PPUSH
57237: CALL_OW 1
57241: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
57242: LD_ADDR_EXP 80
57246: PUSH
57247: LD_EXP 80
57251: PPUSH
57252: LD_VAR 0 2
57256: PPUSH
57257: LD_INT 0
57259: PPUSH
57260: CALL_OW 1
57264: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57265: LD_ADDR_EXP 81
57269: PUSH
57270: LD_EXP 81
57274: PPUSH
57275: LD_VAR 0 2
57279: PPUSH
57280: EMPTY
57281: PPUSH
57282: CALL_OW 1
57286: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57287: LD_ADDR_EXP 82
57291: PUSH
57292: LD_EXP 82
57296: PPUSH
57297: LD_VAR 0 2
57301: PPUSH
57302: EMPTY
57303: PPUSH
57304: CALL_OW 1
57308: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57309: LD_ADDR_EXP 83
57313: PUSH
57314: LD_EXP 83
57318: PPUSH
57319: LD_VAR 0 2
57323: PPUSH
57324: EMPTY
57325: PPUSH
57326: CALL_OW 1
57330: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
57331: LD_ADDR_EXP 85
57335: PUSH
57336: LD_EXP 85
57340: PPUSH
57341: LD_VAR 0 2
57345: PPUSH
57346: LD_EXP 52
57350: PUSH
57351: LD_VAR 0 2
57355: ARRAY
57356: PPUSH
57357: LD_INT 2
57359: PUSH
57360: LD_INT 30
57362: PUSH
57363: LD_INT 6
57365: PUSH
57366: EMPTY
57367: LIST
57368: LIST
57369: PUSH
57370: LD_INT 30
57372: PUSH
57373: LD_INT 7
57375: PUSH
57376: EMPTY
57377: LIST
57378: LIST
57379: PUSH
57380: LD_INT 30
57382: PUSH
57383: LD_INT 8
57385: PUSH
57386: EMPTY
57387: LIST
57388: LIST
57389: PUSH
57390: EMPTY
57391: LIST
57392: LIST
57393: LIST
57394: LIST
57395: PPUSH
57396: CALL_OW 72
57400: PPUSH
57401: CALL_OW 1
57405: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
57406: LD_ADDR_EXP 86
57410: PUSH
57411: LD_EXP 86
57415: PPUSH
57416: LD_VAR 0 2
57420: PPUSH
57421: EMPTY
57422: PPUSH
57423: CALL_OW 1
57427: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
57428: LD_ADDR_EXP 87
57432: PUSH
57433: LD_EXP 87
57437: PPUSH
57438: LD_VAR 0 2
57442: PPUSH
57443: EMPTY
57444: PPUSH
57445: CALL_OW 1
57449: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
57450: LD_ADDR_EXP 88
57454: PUSH
57455: LD_EXP 88
57459: PPUSH
57460: LD_VAR 0 2
57464: PPUSH
57465: EMPTY
57466: PPUSH
57467: CALL_OW 1
57471: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
57472: LD_ADDR_EXP 89
57476: PUSH
57477: LD_EXP 89
57481: PPUSH
57482: LD_VAR 0 2
57486: PPUSH
57487: EMPTY
57488: PPUSH
57489: CALL_OW 1
57493: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57494: LD_ADDR_EXP 90
57498: PUSH
57499: LD_EXP 90
57503: PPUSH
57504: LD_VAR 0 2
57508: PPUSH
57509: EMPTY
57510: PPUSH
57511: CALL_OW 1
57515: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
57516: LD_ADDR_EXP 91
57520: PUSH
57521: LD_EXP 91
57525: PPUSH
57526: LD_VAR 0 2
57530: PPUSH
57531: EMPTY
57532: PPUSH
57533: CALL_OW 1
57537: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
57538: LD_ADDR_EXP 92
57542: PUSH
57543: LD_EXP 92
57547: PPUSH
57548: LD_VAR 0 2
57552: PPUSH
57553: EMPTY
57554: PPUSH
57555: CALL_OW 1
57559: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
57560: LD_ADDR_EXP 93
57564: PUSH
57565: LD_EXP 93
57569: PPUSH
57570: LD_VAR 0 2
57574: PPUSH
57575: EMPTY
57576: PPUSH
57577: CALL_OW 1
57581: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
57582: LD_ADDR_EXP 94
57586: PUSH
57587: LD_EXP 94
57591: PPUSH
57592: LD_VAR 0 2
57596: PPUSH
57597: LD_INT 0
57599: PPUSH
57600: CALL_OW 1
57604: ST_TO_ADDR
// end ;
57605: GO 56529
57607: POP
57608: POP
// MC_InitSides ( ) ;
57609: CALL 57895 0 0
// MC_InitResearch ( ) ;
57613: CALL 57634 0 0
// CustomInitMacro ( ) ;
57617: CALL 5367 0 0
// skirmish := true ;
57621: LD_ADDR_EXP 50
57625: PUSH
57626: LD_INT 1
57628: ST_TO_ADDR
// end ;
57629: LD_VAR 0 1
57633: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
57634: LD_INT 0
57636: PPUSH
57637: PPUSH
57638: PPUSH
57639: PPUSH
57640: PPUSH
57641: PPUSH
// if not mc_bases then
57642: LD_EXP 52
57646: NOT
57647: IFFALSE 57651
// exit ;
57649: GO 57890
// for i = 1 to 8 do
57651: LD_ADDR_VAR 0 2
57655: PUSH
57656: DOUBLE
57657: LD_INT 1
57659: DEC
57660: ST_TO_ADDR
57661: LD_INT 8
57663: PUSH
57664: FOR_TO
57665: IFFALSE 57691
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
57667: LD_ADDR_EXP 79
57671: PUSH
57672: LD_EXP 79
57676: PPUSH
57677: LD_VAR 0 2
57681: PPUSH
57682: EMPTY
57683: PPUSH
57684: CALL_OW 1
57688: ST_TO_ADDR
57689: GO 57664
57691: POP
57692: POP
// tmp := [ ] ;
57693: LD_ADDR_VAR 0 5
57697: PUSH
57698: EMPTY
57699: ST_TO_ADDR
// for i = 1 to mc_sides do
57700: LD_ADDR_VAR 0 2
57704: PUSH
57705: DOUBLE
57706: LD_INT 1
57708: DEC
57709: ST_TO_ADDR
57710: LD_EXP 78
57714: PUSH
57715: FOR_TO
57716: IFFALSE 57774
// if not mc_sides [ i ] in tmp then
57718: LD_EXP 78
57722: PUSH
57723: LD_VAR 0 2
57727: ARRAY
57728: PUSH
57729: LD_VAR 0 5
57733: IN
57734: NOT
57735: IFFALSE 57772
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
57737: LD_ADDR_VAR 0 5
57741: PUSH
57742: LD_VAR 0 5
57746: PPUSH
57747: LD_VAR 0 5
57751: PUSH
57752: LD_INT 1
57754: PLUS
57755: PPUSH
57756: LD_EXP 78
57760: PUSH
57761: LD_VAR 0 2
57765: ARRAY
57766: PPUSH
57767: CALL_OW 2
57771: ST_TO_ADDR
57772: GO 57715
57774: POP
57775: POP
// if not tmp then
57776: LD_VAR 0 5
57780: NOT
57781: IFFALSE 57785
// exit ;
57783: GO 57890
// for j in tmp do
57785: LD_ADDR_VAR 0 3
57789: PUSH
57790: LD_VAR 0 5
57794: PUSH
57795: FOR_IN
57796: IFFALSE 57888
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
57798: LD_ADDR_VAR 0 6
57802: PUSH
57803: LD_INT 22
57805: PUSH
57806: LD_VAR 0 3
57810: PUSH
57811: EMPTY
57812: LIST
57813: LIST
57814: PPUSH
57815: CALL_OW 69
57819: ST_TO_ADDR
// if not un then
57820: LD_VAR 0 6
57824: NOT
57825: IFFALSE 57829
// continue ;
57827: GO 57795
// nation := GetNation ( un [ 1 ] ) ;
57829: LD_ADDR_VAR 0 4
57833: PUSH
57834: LD_VAR 0 6
57838: PUSH
57839: LD_INT 1
57841: ARRAY
57842: PPUSH
57843: CALL_OW 248
57847: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
57848: LD_ADDR_EXP 79
57852: PUSH
57853: LD_EXP 79
57857: PPUSH
57858: LD_VAR 0 3
57862: PPUSH
57863: LD_VAR 0 3
57867: PPUSH
57868: LD_VAR 0 4
57872: PPUSH
57873: LD_INT 1
57875: PPUSH
57876: CALL 11245 0 3
57880: PPUSH
57881: CALL_OW 1
57885: ST_TO_ADDR
// end ;
57886: GO 57795
57888: POP
57889: POP
// end ;
57890: LD_VAR 0 1
57894: RET
// export function MC_InitSides ( ) ; var i ; begin
57895: LD_INT 0
57897: PPUSH
57898: PPUSH
// if not mc_bases then
57899: LD_EXP 52
57903: NOT
57904: IFFALSE 57908
// exit ;
57906: GO 57982
// for i = 1 to mc_bases do
57908: LD_ADDR_VAR 0 2
57912: PUSH
57913: DOUBLE
57914: LD_INT 1
57916: DEC
57917: ST_TO_ADDR
57918: LD_EXP 52
57922: PUSH
57923: FOR_TO
57924: IFFALSE 57980
// if mc_bases [ i ] then
57926: LD_EXP 52
57930: PUSH
57931: LD_VAR 0 2
57935: ARRAY
57936: IFFALSE 57978
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
57938: LD_ADDR_EXP 78
57942: PUSH
57943: LD_EXP 78
57947: PPUSH
57948: LD_VAR 0 2
57952: PPUSH
57953: LD_EXP 52
57957: PUSH
57958: LD_VAR 0 2
57962: ARRAY
57963: PUSH
57964: LD_INT 1
57966: ARRAY
57967: PPUSH
57968: CALL_OW 255
57972: PPUSH
57973: CALL_OW 1
57977: ST_TO_ADDR
57978: GO 57923
57980: POP
57981: POP
// end ;
57982: LD_VAR 0 1
57986: RET
// every 0 0$01 trigger skirmish do
57987: LD_EXP 50
57991: IFFALSE 58145
57993: GO 57995
57995: DISABLE
// begin enable ;
57996: ENABLE
// MC_CheckBuildings ( ) ;
57997: CALL 62643 0 0
// MC_CheckPeopleLife ( ) ;
58001: CALL 62768 0 0
// RaiseSailEvent ( 100 ) ;
58005: LD_INT 100
58007: PPUSH
58008: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58012: LD_INT 103
58014: PPUSH
58015: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58019: LD_INT 104
58021: PPUSH
58022: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58026: LD_INT 105
58028: PPUSH
58029: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58033: LD_INT 106
58035: PPUSH
58036: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58040: LD_INT 107
58042: PPUSH
58043: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58047: LD_INT 108
58049: PPUSH
58050: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58054: LD_INT 109
58056: PPUSH
58057: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58061: LD_INT 110
58063: PPUSH
58064: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58068: LD_INT 111
58070: PPUSH
58071: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58075: LD_INT 112
58077: PPUSH
58078: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58082: LD_INT 113
58084: PPUSH
58085: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58089: LD_INT 120
58091: PPUSH
58092: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58096: LD_INT 121
58098: PPUSH
58099: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58103: LD_INT 122
58105: PPUSH
58106: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58110: LD_INT 123
58112: PPUSH
58113: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58117: LD_INT 124
58119: PPUSH
58120: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58124: LD_INT 125
58126: PPUSH
58127: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58131: LD_INT 126
58133: PPUSH
58134: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58138: LD_INT 200
58140: PPUSH
58141: CALL_OW 427
// end ;
58145: END
// on SailEvent ( event ) do begin if event < 100 then
58146: LD_VAR 0 1
58150: PUSH
58151: LD_INT 100
58153: LESS
58154: IFFALSE 58165
// CustomEvent ( event ) ;
58156: LD_VAR 0 1
58160: PPUSH
58161: CALL 5359 0 1
// if event = 100 then
58165: LD_VAR 0 1
58169: PUSH
58170: LD_INT 100
58172: EQUAL
58173: IFFALSE 58179
// MC_ClassManager ( ) ;
58175: CALL 58571 0 0
// if event = 101 then
58179: LD_VAR 0 1
58183: PUSH
58184: LD_INT 101
58186: EQUAL
58187: IFFALSE 58193
// MC_RepairBuildings ( ) ;
58189: CALL 63364 0 0
// if event = 102 then
58193: LD_VAR 0 1
58197: PUSH
58198: LD_INT 102
58200: EQUAL
58201: IFFALSE 58207
// MC_Heal ( ) ;
58203: CALL 64228 0 0
// if event = 103 then
58207: LD_VAR 0 1
58211: PUSH
58212: LD_INT 103
58214: EQUAL
58215: IFFALSE 58221
// MC_Build ( ) ;
58217: CALL 64650 0 0
// if event = 104 then
58221: LD_VAR 0 1
58225: PUSH
58226: LD_INT 104
58228: EQUAL
58229: IFFALSE 58235
// MC_TurretWeapon ( ) ;
58231: CALL 66263 0 0
// if event = 105 then
58235: LD_VAR 0 1
58239: PUSH
58240: LD_INT 105
58242: EQUAL
58243: IFFALSE 58249
// MC_BuildUpgrade ( ) ;
58245: CALL 65814 0 0
// if event = 106 then
58249: LD_VAR 0 1
58253: PUSH
58254: LD_INT 106
58256: EQUAL
58257: IFFALSE 58263
// MC_PlantMines ( ) ;
58259: CALL 66693 0 0
// if event = 107 then
58263: LD_VAR 0 1
58267: PUSH
58268: LD_INT 107
58270: EQUAL
58271: IFFALSE 58277
// MC_CollectCrates ( ) ;
58273: CALL 67491 0 0
// if event = 108 then
58277: LD_VAR 0 1
58281: PUSH
58282: LD_INT 108
58284: EQUAL
58285: IFFALSE 58291
// MC_LinkRemoteControl ( ) ;
58287: CALL 69267 0 0
// if event = 109 then
58291: LD_VAR 0 1
58295: PUSH
58296: LD_INT 109
58298: EQUAL
58299: IFFALSE 58305
// MC_ProduceVehicle ( ) ;
58301: CALL 69448 0 0
// if event = 110 then
58305: LD_VAR 0 1
58309: PUSH
58310: LD_INT 110
58312: EQUAL
58313: IFFALSE 58319
// MC_SendAttack ( ) ;
58315: CALL 69914 0 0
// if event = 111 then
58319: LD_VAR 0 1
58323: PUSH
58324: LD_INT 111
58326: EQUAL
58327: IFFALSE 58333
// MC_Defend ( ) ;
58329: CALL 70022 0 0
// if event = 112 then
58333: LD_VAR 0 1
58337: PUSH
58338: LD_INT 112
58340: EQUAL
58341: IFFALSE 58347
// MC_Research ( ) ;
58343: CALL 70627 0 0
// if event = 113 then
58347: LD_VAR 0 1
58351: PUSH
58352: LD_INT 113
58354: EQUAL
58355: IFFALSE 58361
// MC_MinesTrigger ( ) ;
58357: CALL 71741 0 0
// if event = 120 then
58361: LD_VAR 0 1
58365: PUSH
58366: LD_INT 120
58368: EQUAL
58369: IFFALSE 58375
// MC_RepairVehicle ( ) ;
58371: CALL 71840 0 0
// if event = 121 then
58375: LD_VAR 0 1
58379: PUSH
58380: LD_INT 121
58382: EQUAL
58383: IFFALSE 58389
// MC_TameApe ( ) ;
58385: CALL 72570 0 0
// if event = 122 then
58389: LD_VAR 0 1
58393: PUSH
58394: LD_INT 122
58396: EQUAL
58397: IFFALSE 58403
// MC_ChangeApeClass ( ) ;
58399: CALL 73399 0 0
// if event = 123 then
58403: LD_VAR 0 1
58407: PUSH
58408: LD_INT 123
58410: EQUAL
58411: IFFALSE 58417
// MC_Bazooka ( ) ;
58413: CALL 74049 0 0
// if event = 124 then
58417: LD_VAR 0 1
58421: PUSH
58422: LD_INT 124
58424: EQUAL
58425: IFFALSE 58431
// MC_TeleportExit ( ) ;
58427: CALL 74247 0 0
// if event = 125 then
58431: LD_VAR 0 1
58435: PUSH
58436: LD_INT 125
58438: EQUAL
58439: IFFALSE 58445
// MC_Deposits ( ) ;
58441: CALL 74894 0 0
// if event = 126 then
58445: LD_VAR 0 1
58449: PUSH
58450: LD_INT 126
58452: EQUAL
58453: IFFALSE 58459
// MC_RemoteDriver ( ) ;
58455: CALL 75519 0 0
// if event = 200 then
58459: LD_VAR 0 1
58463: PUSH
58464: LD_INT 200
58466: EQUAL
58467: IFFALSE 58473
// MC_Idle ( ) ;
58469: CALL 77468 0 0
// end ;
58473: PPOPN 1
58475: END
// export function MC_Reset ( base , tag ) ; var i ; begin
58476: LD_INT 0
58478: PPUSH
58479: PPUSH
// if not mc_bases [ base ] or not tag then
58480: LD_EXP 52
58484: PUSH
58485: LD_VAR 0 1
58489: ARRAY
58490: NOT
58491: PUSH
58492: LD_VAR 0 2
58496: NOT
58497: OR
58498: IFFALSE 58502
// exit ;
58500: GO 58566
// for i in mc_bases [ base ] union mc_ape [ base ] do
58502: LD_ADDR_VAR 0 4
58506: PUSH
58507: LD_EXP 52
58511: PUSH
58512: LD_VAR 0 1
58516: ARRAY
58517: PUSH
58518: LD_EXP 81
58522: PUSH
58523: LD_VAR 0 1
58527: ARRAY
58528: UNION
58529: PUSH
58530: FOR_IN
58531: IFFALSE 58564
// if GetTag ( i ) = tag then
58533: LD_VAR 0 4
58537: PPUSH
58538: CALL_OW 110
58542: PUSH
58543: LD_VAR 0 2
58547: EQUAL
58548: IFFALSE 58562
// SetTag ( i , 0 ) ;
58550: LD_VAR 0 4
58554: PPUSH
58555: LD_INT 0
58557: PPUSH
58558: CALL_OW 109
58562: GO 58530
58564: POP
58565: POP
// end ;
58566: LD_VAR 0 3
58570: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
58571: LD_INT 0
58573: PPUSH
58574: PPUSH
58575: PPUSH
58576: PPUSH
58577: PPUSH
58578: PPUSH
58579: PPUSH
58580: PPUSH
// if not mc_bases then
58581: LD_EXP 52
58585: NOT
58586: IFFALSE 58590
// exit ;
58588: GO 59048
// for i = 1 to mc_bases do
58590: LD_ADDR_VAR 0 2
58594: PUSH
58595: DOUBLE
58596: LD_INT 1
58598: DEC
58599: ST_TO_ADDR
58600: LD_EXP 52
58604: PUSH
58605: FOR_TO
58606: IFFALSE 59046
// begin tmp := MC_ClassCheckReq ( i ) ;
58608: LD_ADDR_VAR 0 4
58612: PUSH
58613: LD_VAR 0 2
58617: PPUSH
58618: CALL 59053 0 1
58622: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
58623: LD_ADDR_EXP 93
58627: PUSH
58628: LD_EXP 93
58632: PPUSH
58633: LD_VAR 0 2
58637: PPUSH
58638: LD_VAR 0 4
58642: PPUSH
58643: CALL_OW 1
58647: ST_TO_ADDR
// if not tmp then
58648: LD_VAR 0 4
58652: NOT
58653: IFFALSE 58657
// continue ;
58655: GO 58605
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
58657: LD_ADDR_VAR 0 6
58661: PUSH
58662: LD_EXP 52
58666: PUSH
58667: LD_VAR 0 2
58671: ARRAY
58672: PPUSH
58673: LD_INT 2
58675: PUSH
58676: LD_INT 30
58678: PUSH
58679: LD_INT 4
58681: PUSH
58682: EMPTY
58683: LIST
58684: LIST
58685: PUSH
58686: LD_INT 30
58688: PUSH
58689: LD_INT 5
58691: PUSH
58692: EMPTY
58693: LIST
58694: LIST
58695: PUSH
58696: EMPTY
58697: LIST
58698: LIST
58699: LIST
58700: PPUSH
58701: CALL_OW 72
58705: PUSH
58706: LD_EXP 52
58710: PUSH
58711: LD_VAR 0 2
58715: ARRAY
58716: PPUSH
58717: LD_INT 2
58719: PUSH
58720: LD_INT 30
58722: PUSH
58723: LD_INT 0
58725: PUSH
58726: EMPTY
58727: LIST
58728: LIST
58729: PUSH
58730: LD_INT 30
58732: PUSH
58733: LD_INT 1
58735: PUSH
58736: EMPTY
58737: LIST
58738: LIST
58739: PUSH
58740: EMPTY
58741: LIST
58742: LIST
58743: LIST
58744: PPUSH
58745: CALL_OW 72
58749: PUSH
58750: LD_EXP 52
58754: PUSH
58755: LD_VAR 0 2
58759: ARRAY
58760: PPUSH
58761: LD_INT 30
58763: PUSH
58764: LD_INT 3
58766: PUSH
58767: EMPTY
58768: LIST
58769: LIST
58770: PPUSH
58771: CALL_OW 72
58775: PUSH
58776: LD_EXP 52
58780: PUSH
58781: LD_VAR 0 2
58785: ARRAY
58786: PPUSH
58787: LD_INT 2
58789: PUSH
58790: LD_INT 30
58792: PUSH
58793: LD_INT 6
58795: PUSH
58796: EMPTY
58797: LIST
58798: LIST
58799: PUSH
58800: LD_INT 30
58802: PUSH
58803: LD_INT 7
58805: PUSH
58806: EMPTY
58807: LIST
58808: LIST
58809: PUSH
58810: LD_INT 30
58812: PUSH
58813: LD_INT 8
58815: PUSH
58816: EMPTY
58817: LIST
58818: LIST
58819: PUSH
58820: EMPTY
58821: LIST
58822: LIST
58823: LIST
58824: LIST
58825: PPUSH
58826: CALL_OW 72
58830: PUSH
58831: EMPTY
58832: LIST
58833: LIST
58834: LIST
58835: LIST
58836: ST_TO_ADDR
// for j = 1 to 4 do
58837: LD_ADDR_VAR 0 3
58841: PUSH
58842: DOUBLE
58843: LD_INT 1
58845: DEC
58846: ST_TO_ADDR
58847: LD_INT 4
58849: PUSH
58850: FOR_TO
58851: IFFALSE 59042
// begin if not tmp [ j ] then
58853: LD_VAR 0 4
58857: PUSH
58858: LD_VAR 0 3
58862: ARRAY
58863: NOT
58864: IFFALSE 58868
// continue ;
58866: GO 58850
// for p in tmp [ j ] do
58868: LD_ADDR_VAR 0 5
58872: PUSH
58873: LD_VAR 0 4
58877: PUSH
58878: LD_VAR 0 3
58882: ARRAY
58883: PUSH
58884: FOR_IN
58885: IFFALSE 59038
// begin if not b [ j ] then
58887: LD_VAR 0 6
58891: PUSH
58892: LD_VAR 0 3
58896: ARRAY
58897: NOT
58898: IFFALSE 58902
// break ;
58900: GO 59038
// e := 0 ;
58902: LD_ADDR_VAR 0 7
58906: PUSH
58907: LD_INT 0
58909: ST_TO_ADDR
// for k in b [ j ] do
58910: LD_ADDR_VAR 0 8
58914: PUSH
58915: LD_VAR 0 6
58919: PUSH
58920: LD_VAR 0 3
58924: ARRAY
58925: PUSH
58926: FOR_IN
58927: IFFALSE 58954
// if IsNotFull ( k ) then
58929: LD_VAR 0 8
58933: PPUSH
58934: CALL 15685 0 1
58938: IFFALSE 58952
// begin e := k ;
58940: LD_ADDR_VAR 0 7
58944: PUSH
58945: LD_VAR 0 8
58949: ST_TO_ADDR
// break ;
58950: GO 58954
// end ;
58952: GO 58926
58954: POP
58955: POP
// if e and not UnitGoingToBuilding ( p , e ) then
58956: LD_VAR 0 7
58960: PUSH
58961: LD_VAR 0 5
58965: PPUSH
58966: LD_VAR 0 7
58970: PPUSH
58971: CALL 52814 0 2
58975: NOT
58976: AND
58977: IFFALSE 59036
// begin if IsInUnit ( p ) then
58979: LD_VAR 0 5
58983: PPUSH
58984: CALL_OW 310
58988: IFFALSE 58999
// ComExitBuilding ( p ) ;
58990: LD_VAR 0 5
58994: PPUSH
58995: CALL_OW 122
// ComEnterUnit ( p , e ) ;
58999: LD_VAR 0 5
59003: PPUSH
59004: LD_VAR 0 7
59008: PPUSH
59009: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59013: LD_VAR 0 5
59017: PPUSH
59018: LD_VAR 0 3
59022: PPUSH
59023: CALL_OW 183
// AddComExitBuilding ( p ) ;
59027: LD_VAR 0 5
59031: PPUSH
59032: CALL_OW 182
// end ; end ;
59036: GO 58884
59038: POP
59039: POP
// end ;
59040: GO 58850
59042: POP
59043: POP
// end ;
59044: GO 58605
59046: POP
59047: POP
// end ;
59048: LD_VAR 0 1
59052: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59053: LD_INT 0
59055: PPUSH
59056: PPUSH
59057: PPUSH
59058: PPUSH
59059: PPUSH
59060: PPUSH
59061: PPUSH
59062: PPUSH
59063: PPUSH
59064: PPUSH
59065: PPUSH
59066: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59067: LD_VAR 0 1
59071: NOT
59072: PUSH
59073: LD_EXP 52
59077: PUSH
59078: LD_VAR 0 1
59082: ARRAY
59083: NOT
59084: OR
59085: PUSH
59086: LD_EXP 52
59090: PUSH
59091: LD_VAR 0 1
59095: ARRAY
59096: PPUSH
59097: LD_INT 2
59099: PUSH
59100: LD_INT 30
59102: PUSH
59103: LD_INT 0
59105: PUSH
59106: EMPTY
59107: LIST
59108: LIST
59109: PUSH
59110: LD_INT 30
59112: PUSH
59113: LD_INT 1
59115: PUSH
59116: EMPTY
59117: LIST
59118: LIST
59119: PUSH
59120: EMPTY
59121: LIST
59122: LIST
59123: LIST
59124: PPUSH
59125: CALL_OW 72
59129: NOT
59130: OR
59131: IFFALSE 59135
// exit ;
59133: GO 62638
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59135: LD_ADDR_VAR 0 4
59139: PUSH
59140: LD_EXP 52
59144: PUSH
59145: LD_VAR 0 1
59149: ARRAY
59150: PPUSH
59151: LD_INT 2
59153: PUSH
59154: LD_INT 25
59156: PUSH
59157: LD_INT 1
59159: PUSH
59160: EMPTY
59161: LIST
59162: LIST
59163: PUSH
59164: LD_INT 25
59166: PUSH
59167: LD_INT 2
59169: PUSH
59170: EMPTY
59171: LIST
59172: LIST
59173: PUSH
59174: LD_INT 25
59176: PUSH
59177: LD_INT 3
59179: PUSH
59180: EMPTY
59181: LIST
59182: LIST
59183: PUSH
59184: LD_INT 25
59186: PUSH
59187: LD_INT 4
59189: PUSH
59190: EMPTY
59191: LIST
59192: LIST
59193: PUSH
59194: LD_INT 25
59196: PUSH
59197: LD_INT 5
59199: PUSH
59200: EMPTY
59201: LIST
59202: LIST
59203: PUSH
59204: LD_INT 25
59206: PUSH
59207: LD_INT 8
59209: PUSH
59210: EMPTY
59211: LIST
59212: LIST
59213: PUSH
59214: LD_INT 25
59216: PUSH
59217: LD_INT 9
59219: PUSH
59220: EMPTY
59221: LIST
59222: LIST
59223: PUSH
59224: EMPTY
59225: LIST
59226: LIST
59227: LIST
59228: LIST
59229: LIST
59230: LIST
59231: LIST
59232: LIST
59233: PPUSH
59234: CALL_OW 72
59238: ST_TO_ADDR
// if not tmp then
59239: LD_VAR 0 4
59243: NOT
59244: IFFALSE 59248
// exit ;
59246: GO 62638
// for i in tmp do
59248: LD_ADDR_VAR 0 3
59252: PUSH
59253: LD_VAR 0 4
59257: PUSH
59258: FOR_IN
59259: IFFALSE 59290
// if GetTag ( i ) then
59261: LD_VAR 0 3
59265: PPUSH
59266: CALL_OW 110
59270: IFFALSE 59288
// tmp := tmp diff i ;
59272: LD_ADDR_VAR 0 4
59276: PUSH
59277: LD_VAR 0 4
59281: PUSH
59282: LD_VAR 0 3
59286: DIFF
59287: ST_TO_ADDR
59288: GO 59258
59290: POP
59291: POP
// if not tmp then
59292: LD_VAR 0 4
59296: NOT
59297: IFFALSE 59301
// exit ;
59299: GO 62638
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59301: LD_ADDR_VAR 0 5
59305: PUSH
59306: LD_EXP 52
59310: PUSH
59311: LD_VAR 0 1
59315: ARRAY
59316: PPUSH
59317: LD_INT 2
59319: PUSH
59320: LD_INT 25
59322: PUSH
59323: LD_INT 1
59325: PUSH
59326: EMPTY
59327: LIST
59328: LIST
59329: PUSH
59330: LD_INT 25
59332: PUSH
59333: LD_INT 5
59335: PUSH
59336: EMPTY
59337: LIST
59338: LIST
59339: PUSH
59340: LD_INT 25
59342: PUSH
59343: LD_INT 8
59345: PUSH
59346: EMPTY
59347: LIST
59348: LIST
59349: PUSH
59350: LD_INT 25
59352: PUSH
59353: LD_INT 9
59355: PUSH
59356: EMPTY
59357: LIST
59358: LIST
59359: PUSH
59360: EMPTY
59361: LIST
59362: LIST
59363: LIST
59364: LIST
59365: LIST
59366: PPUSH
59367: CALL_OW 72
59371: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
59372: LD_ADDR_VAR 0 6
59376: PUSH
59377: LD_EXP 52
59381: PUSH
59382: LD_VAR 0 1
59386: ARRAY
59387: PPUSH
59388: LD_INT 25
59390: PUSH
59391: LD_INT 2
59393: PUSH
59394: EMPTY
59395: LIST
59396: LIST
59397: PPUSH
59398: CALL_OW 72
59402: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
59403: LD_ADDR_VAR 0 7
59407: PUSH
59408: LD_EXP 52
59412: PUSH
59413: LD_VAR 0 1
59417: ARRAY
59418: PPUSH
59419: LD_INT 25
59421: PUSH
59422: LD_INT 3
59424: PUSH
59425: EMPTY
59426: LIST
59427: LIST
59428: PPUSH
59429: CALL_OW 72
59433: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
59434: LD_ADDR_VAR 0 8
59438: PUSH
59439: LD_EXP 52
59443: PUSH
59444: LD_VAR 0 1
59448: ARRAY
59449: PPUSH
59450: LD_INT 25
59452: PUSH
59453: LD_INT 4
59455: PUSH
59456: EMPTY
59457: LIST
59458: LIST
59459: PUSH
59460: LD_INT 24
59462: PUSH
59463: LD_INT 251
59465: PUSH
59466: EMPTY
59467: LIST
59468: LIST
59469: PUSH
59470: EMPTY
59471: LIST
59472: LIST
59473: PPUSH
59474: CALL_OW 72
59478: ST_TO_ADDR
// if mc_scan [ base ] then
59479: LD_EXP 75
59483: PUSH
59484: LD_VAR 0 1
59488: ARRAY
59489: IFFALSE 59950
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
59491: LD_ADDR_EXP 94
59495: PUSH
59496: LD_EXP 94
59500: PPUSH
59501: LD_VAR 0 1
59505: PPUSH
59506: LD_INT 4
59508: PPUSH
59509: CALL_OW 1
59513: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59514: LD_ADDR_VAR 0 12
59518: PUSH
59519: LD_EXP 52
59523: PUSH
59524: LD_VAR 0 1
59528: ARRAY
59529: PPUSH
59530: LD_INT 2
59532: PUSH
59533: LD_INT 30
59535: PUSH
59536: LD_INT 4
59538: PUSH
59539: EMPTY
59540: LIST
59541: LIST
59542: PUSH
59543: LD_INT 30
59545: PUSH
59546: LD_INT 5
59548: PUSH
59549: EMPTY
59550: LIST
59551: LIST
59552: PUSH
59553: EMPTY
59554: LIST
59555: LIST
59556: LIST
59557: PPUSH
59558: CALL_OW 72
59562: ST_TO_ADDR
// if not b then
59563: LD_VAR 0 12
59567: NOT
59568: IFFALSE 59572
// exit ;
59570: GO 62638
// p := [ ] ;
59572: LD_ADDR_VAR 0 11
59576: PUSH
59577: EMPTY
59578: ST_TO_ADDR
// if sci >= 2 then
59579: LD_VAR 0 8
59583: PUSH
59584: LD_INT 2
59586: GREATEREQUAL
59587: IFFALSE 59618
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
59589: LD_ADDR_VAR 0 8
59593: PUSH
59594: LD_VAR 0 8
59598: PUSH
59599: LD_INT 1
59601: ARRAY
59602: PUSH
59603: LD_VAR 0 8
59607: PUSH
59608: LD_INT 2
59610: ARRAY
59611: PUSH
59612: EMPTY
59613: LIST
59614: LIST
59615: ST_TO_ADDR
59616: GO 59679
// if sci = 1 then
59618: LD_VAR 0 8
59622: PUSH
59623: LD_INT 1
59625: EQUAL
59626: IFFALSE 59647
// sci := [ sci [ 1 ] ] else
59628: LD_ADDR_VAR 0 8
59632: PUSH
59633: LD_VAR 0 8
59637: PUSH
59638: LD_INT 1
59640: ARRAY
59641: PUSH
59642: EMPTY
59643: LIST
59644: ST_TO_ADDR
59645: GO 59679
// if sci = 0 then
59647: LD_VAR 0 8
59651: PUSH
59652: LD_INT 0
59654: EQUAL
59655: IFFALSE 59679
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
59657: LD_ADDR_VAR 0 11
59661: PUSH
59662: LD_VAR 0 4
59666: PPUSH
59667: LD_INT 4
59669: PPUSH
59670: CALL 52677 0 2
59674: PUSH
59675: LD_INT 1
59677: ARRAY
59678: ST_TO_ADDR
// if eng > 4 then
59679: LD_VAR 0 6
59683: PUSH
59684: LD_INT 4
59686: GREATER
59687: IFFALSE 59733
// for i = eng downto 4 do
59689: LD_ADDR_VAR 0 3
59693: PUSH
59694: DOUBLE
59695: LD_VAR 0 6
59699: INC
59700: ST_TO_ADDR
59701: LD_INT 4
59703: PUSH
59704: FOR_DOWNTO
59705: IFFALSE 59731
// eng := eng diff eng [ i ] ;
59707: LD_ADDR_VAR 0 6
59711: PUSH
59712: LD_VAR 0 6
59716: PUSH
59717: LD_VAR 0 6
59721: PUSH
59722: LD_VAR 0 3
59726: ARRAY
59727: DIFF
59728: ST_TO_ADDR
59729: GO 59704
59731: POP
59732: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
59733: LD_ADDR_VAR 0 4
59737: PUSH
59738: LD_VAR 0 4
59742: PUSH
59743: LD_VAR 0 5
59747: PUSH
59748: LD_VAR 0 6
59752: UNION
59753: PUSH
59754: LD_VAR 0 7
59758: UNION
59759: PUSH
59760: LD_VAR 0 8
59764: UNION
59765: DIFF
59766: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
59767: LD_ADDR_VAR 0 13
59771: PUSH
59772: LD_EXP 52
59776: PUSH
59777: LD_VAR 0 1
59781: ARRAY
59782: PPUSH
59783: LD_INT 2
59785: PUSH
59786: LD_INT 30
59788: PUSH
59789: LD_INT 32
59791: PUSH
59792: EMPTY
59793: LIST
59794: LIST
59795: PUSH
59796: LD_INT 30
59798: PUSH
59799: LD_INT 31
59801: PUSH
59802: EMPTY
59803: LIST
59804: LIST
59805: PUSH
59806: EMPTY
59807: LIST
59808: LIST
59809: LIST
59810: PPUSH
59811: CALL_OW 72
59815: PUSH
59816: LD_EXP 52
59820: PUSH
59821: LD_VAR 0 1
59825: ARRAY
59826: PPUSH
59827: LD_INT 2
59829: PUSH
59830: LD_INT 30
59832: PUSH
59833: LD_INT 4
59835: PUSH
59836: EMPTY
59837: LIST
59838: LIST
59839: PUSH
59840: LD_INT 30
59842: PUSH
59843: LD_INT 5
59845: PUSH
59846: EMPTY
59847: LIST
59848: LIST
59849: PUSH
59850: EMPTY
59851: LIST
59852: LIST
59853: LIST
59854: PPUSH
59855: CALL_OW 72
59859: PUSH
59860: LD_INT 6
59862: MUL
59863: PLUS
59864: ST_TO_ADDR
// if bcount < tmp then
59865: LD_VAR 0 13
59869: PUSH
59870: LD_VAR 0 4
59874: LESS
59875: IFFALSE 59921
// for i = tmp downto bcount do
59877: LD_ADDR_VAR 0 3
59881: PUSH
59882: DOUBLE
59883: LD_VAR 0 4
59887: INC
59888: ST_TO_ADDR
59889: LD_VAR 0 13
59893: PUSH
59894: FOR_DOWNTO
59895: IFFALSE 59919
// tmp := Delete ( tmp , tmp ) ;
59897: LD_ADDR_VAR 0 4
59901: PUSH
59902: LD_VAR 0 4
59906: PPUSH
59907: LD_VAR 0 4
59911: PPUSH
59912: CALL_OW 3
59916: ST_TO_ADDR
59917: GO 59894
59919: POP
59920: POP
// result := [ tmp , 0 , 0 , p ] ;
59921: LD_ADDR_VAR 0 2
59925: PUSH
59926: LD_VAR 0 4
59930: PUSH
59931: LD_INT 0
59933: PUSH
59934: LD_INT 0
59936: PUSH
59937: LD_VAR 0 11
59941: PUSH
59942: EMPTY
59943: LIST
59944: LIST
59945: LIST
59946: LIST
59947: ST_TO_ADDR
// exit ;
59948: GO 62638
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59950: LD_EXP 52
59954: PUSH
59955: LD_VAR 0 1
59959: ARRAY
59960: PPUSH
59961: LD_INT 2
59963: PUSH
59964: LD_INT 30
59966: PUSH
59967: LD_INT 6
59969: PUSH
59970: EMPTY
59971: LIST
59972: LIST
59973: PUSH
59974: LD_INT 30
59976: PUSH
59977: LD_INT 7
59979: PUSH
59980: EMPTY
59981: LIST
59982: LIST
59983: PUSH
59984: LD_INT 30
59986: PUSH
59987: LD_INT 8
59989: PUSH
59990: EMPTY
59991: LIST
59992: LIST
59993: PUSH
59994: EMPTY
59995: LIST
59996: LIST
59997: LIST
59998: LIST
59999: PPUSH
60000: CALL_OW 72
60004: NOT
60005: PUSH
60006: LD_EXP 52
60010: PUSH
60011: LD_VAR 0 1
60015: ARRAY
60016: PPUSH
60017: LD_INT 30
60019: PUSH
60020: LD_INT 3
60022: PUSH
60023: EMPTY
60024: LIST
60025: LIST
60026: PPUSH
60027: CALL_OW 72
60031: NOT
60032: AND
60033: IFFALSE 60105
// begin if eng = tmp then
60035: LD_VAR 0 6
60039: PUSH
60040: LD_VAR 0 4
60044: EQUAL
60045: IFFALSE 60049
// exit ;
60047: GO 62638
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60049: LD_ADDR_EXP 94
60053: PUSH
60054: LD_EXP 94
60058: PPUSH
60059: LD_VAR 0 1
60063: PPUSH
60064: LD_INT 1
60066: PPUSH
60067: CALL_OW 1
60071: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60072: LD_ADDR_VAR 0 2
60076: PUSH
60077: LD_INT 0
60079: PUSH
60080: LD_VAR 0 4
60084: PUSH
60085: LD_VAR 0 6
60089: DIFF
60090: PUSH
60091: LD_INT 0
60093: PUSH
60094: LD_INT 0
60096: PUSH
60097: EMPTY
60098: LIST
60099: LIST
60100: LIST
60101: LIST
60102: ST_TO_ADDR
// exit ;
60103: GO 62638
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60105: LD_EXP 79
60109: PUSH
60110: LD_EXP 78
60114: PUSH
60115: LD_VAR 0 1
60119: ARRAY
60120: ARRAY
60121: PUSH
60122: LD_EXP 52
60126: PUSH
60127: LD_VAR 0 1
60131: ARRAY
60132: PPUSH
60133: LD_INT 2
60135: PUSH
60136: LD_INT 30
60138: PUSH
60139: LD_INT 6
60141: PUSH
60142: EMPTY
60143: LIST
60144: LIST
60145: PUSH
60146: LD_INT 30
60148: PUSH
60149: LD_INT 7
60151: PUSH
60152: EMPTY
60153: LIST
60154: LIST
60155: PUSH
60156: LD_INT 30
60158: PUSH
60159: LD_INT 8
60161: PUSH
60162: EMPTY
60163: LIST
60164: LIST
60165: PUSH
60166: EMPTY
60167: LIST
60168: LIST
60169: LIST
60170: LIST
60171: PPUSH
60172: CALL_OW 72
60176: AND
60177: PUSH
60178: LD_EXP 52
60182: PUSH
60183: LD_VAR 0 1
60187: ARRAY
60188: PPUSH
60189: LD_INT 30
60191: PUSH
60192: LD_INT 3
60194: PUSH
60195: EMPTY
60196: LIST
60197: LIST
60198: PPUSH
60199: CALL_OW 72
60203: NOT
60204: AND
60205: IFFALSE 60419
// begin if sci >= 6 then
60207: LD_VAR 0 8
60211: PUSH
60212: LD_INT 6
60214: GREATEREQUAL
60215: IFFALSE 60219
// exit ;
60217: GO 62638
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
60219: LD_ADDR_EXP 94
60223: PUSH
60224: LD_EXP 94
60228: PPUSH
60229: LD_VAR 0 1
60233: PPUSH
60234: LD_INT 2
60236: PPUSH
60237: CALL_OW 1
60241: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
60242: LD_ADDR_VAR 0 9
60246: PUSH
60247: LD_VAR 0 4
60251: PUSH
60252: LD_VAR 0 8
60256: DIFF
60257: PPUSH
60258: LD_INT 4
60260: PPUSH
60261: CALL 52677 0 2
60265: ST_TO_ADDR
// p := [ ] ;
60266: LD_ADDR_VAR 0 11
60270: PUSH
60271: EMPTY
60272: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60273: LD_VAR 0 8
60277: PUSH
60278: LD_INT 6
60280: LESS
60281: PUSH
60282: LD_VAR 0 9
60286: PUSH
60287: LD_INT 6
60289: GREATER
60290: AND
60291: IFFALSE 60372
// begin for i = 1 to 6 - sci do
60293: LD_ADDR_VAR 0 3
60297: PUSH
60298: DOUBLE
60299: LD_INT 1
60301: DEC
60302: ST_TO_ADDR
60303: LD_INT 6
60305: PUSH
60306: LD_VAR 0 8
60310: MINUS
60311: PUSH
60312: FOR_TO
60313: IFFALSE 60368
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
60315: LD_ADDR_VAR 0 11
60319: PUSH
60320: LD_VAR 0 11
60324: PPUSH
60325: LD_VAR 0 11
60329: PUSH
60330: LD_INT 1
60332: PLUS
60333: PPUSH
60334: LD_VAR 0 9
60338: PUSH
60339: LD_INT 1
60341: ARRAY
60342: PPUSH
60343: CALL_OW 2
60347: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
60348: LD_ADDR_VAR 0 9
60352: PUSH
60353: LD_VAR 0 9
60357: PPUSH
60358: LD_INT 1
60360: PPUSH
60361: CALL_OW 3
60365: ST_TO_ADDR
// end ;
60366: GO 60312
60368: POP
60369: POP
// end else
60370: GO 60392
// if sort then
60372: LD_VAR 0 9
60376: IFFALSE 60392
// p := sort [ 1 ] ;
60378: LD_ADDR_VAR 0 11
60382: PUSH
60383: LD_VAR 0 9
60387: PUSH
60388: LD_INT 1
60390: ARRAY
60391: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
60392: LD_ADDR_VAR 0 2
60396: PUSH
60397: LD_INT 0
60399: PUSH
60400: LD_INT 0
60402: PUSH
60403: LD_INT 0
60405: PUSH
60406: LD_VAR 0 11
60410: PUSH
60411: EMPTY
60412: LIST
60413: LIST
60414: LIST
60415: LIST
60416: ST_TO_ADDR
// exit ;
60417: GO 62638
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60419: LD_EXP 79
60423: PUSH
60424: LD_EXP 78
60428: PUSH
60429: LD_VAR 0 1
60433: ARRAY
60434: ARRAY
60435: PUSH
60436: LD_EXP 52
60440: PUSH
60441: LD_VAR 0 1
60445: ARRAY
60446: PPUSH
60447: LD_INT 2
60449: PUSH
60450: LD_INT 30
60452: PUSH
60453: LD_INT 6
60455: PUSH
60456: EMPTY
60457: LIST
60458: LIST
60459: PUSH
60460: LD_INT 30
60462: PUSH
60463: LD_INT 7
60465: PUSH
60466: EMPTY
60467: LIST
60468: LIST
60469: PUSH
60470: LD_INT 30
60472: PUSH
60473: LD_INT 8
60475: PUSH
60476: EMPTY
60477: LIST
60478: LIST
60479: PUSH
60480: EMPTY
60481: LIST
60482: LIST
60483: LIST
60484: LIST
60485: PPUSH
60486: CALL_OW 72
60490: AND
60491: PUSH
60492: LD_EXP 52
60496: PUSH
60497: LD_VAR 0 1
60501: ARRAY
60502: PPUSH
60503: LD_INT 30
60505: PUSH
60506: LD_INT 3
60508: PUSH
60509: EMPTY
60510: LIST
60511: LIST
60512: PPUSH
60513: CALL_OW 72
60517: AND
60518: IFFALSE 61252
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
60520: LD_ADDR_EXP 94
60524: PUSH
60525: LD_EXP 94
60529: PPUSH
60530: LD_VAR 0 1
60534: PPUSH
60535: LD_INT 3
60537: PPUSH
60538: CALL_OW 1
60542: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60543: LD_ADDR_VAR 0 2
60547: PUSH
60548: LD_INT 0
60550: PUSH
60551: LD_INT 0
60553: PUSH
60554: LD_INT 0
60556: PUSH
60557: LD_INT 0
60559: PUSH
60560: EMPTY
60561: LIST
60562: LIST
60563: LIST
60564: LIST
60565: ST_TO_ADDR
// if not eng then
60566: LD_VAR 0 6
60570: NOT
60571: IFFALSE 60634
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
60573: LD_ADDR_VAR 0 11
60577: PUSH
60578: LD_VAR 0 4
60582: PPUSH
60583: LD_INT 2
60585: PPUSH
60586: CALL 52677 0 2
60590: PUSH
60591: LD_INT 1
60593: ARRAY
60594: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
60595: LD_ADDR_VAR 0 2
60599: PUSH
60600: LD_VAR 0 2
60604: PPUSH
60605: LD_INT 2
60607: PPUSH
60608: LD_VAR 0 11
60612: PPUSH
60613: CALL_OW 1
60617: ST_TO_ADDR
// tmp := tmp diff p ;
60618: LD_ADDR_VAR 0 4
60622: PUSH
60623: LD_VAR 0 4
60627: PUSH
60628: LD_VAR 0 11
60632: DIFF
60633: ST_TO_ADDR
// end ; if tmp and sci < 6 then
60634: LD_VAR 0 4
60638: PUSH
60639: LD_VAR 0 8
60643: PUSH
60644: LD_INT 6
60646: LESS
60647: AND
60648: IFFALSE 60836
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
60650: LD_ADDR_VAR 0 9
60654: PUSH
60655: LD_VAR 0 4
60659: PUSH
60660: LD_VAR 0 8
60664: PUSH
60665: LD_VAR 0 7
60669: UNION
60670: DIFF
60671: PPUSH
60672: LD_INT 4
60674: PPUSH
60675: CALL 52677 0 2
60679: ST_TO_ADDR
// p := [ ] ;
60680: LD_ADDR_VAR 0 11
60684: PUSH
60685: EMPTY
60686: ST_TO_ADDR
// if sort then
60687: LD_VAR 0 9
60691: IFFALSE 60807
// for i = 1 to 6 - sci do
60693: LD_ADDR_VAR 0 3
60697: PUSH
60698: DOUBLE
60699: LD_INT 1
60701: DEC
60702: ST_TO_ADDR
60703: LD_INT 6
60705: PUSH
60706: LD_VAR 0 8
60710: MINUS
60711: PUSH
60712: FOR_TO
60713: IFFALSE 60805
// begin if i = sort then
60715: LD_VAR 0 3
60719: PUSH
60720: LD_VAR 0 9
60724: EQUAL
60725: IFFALSE 60729
// break ;
60727: GO 60805
// if GetClass ( i ) = 4 then
60729: LD_VAR 0 3
60733: PPUSH
60734: CALL_OW 257
60738: PUSH
60739: LD_INT 4
60741: EQUAL
60742: IFFALSE 60746
// continue ;
60744: GO 60712
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60746: LD_ADDR_VAR 0 11
60750: PUSH
60751: LD_VAR 0 11
60755: PPUSH
60756: LD_VAR 0 11
60760: PUSH
60761: LD_INT 1
60763: PLUS
60764: PPUSH
60765: LD_VAR 0 9
60769: PUSH
60770: LD_VAR 0 3
60774: ARRAY
60775: PPUSH
60776: CALL_OW 2
60780: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60781: LD_ADDR_VAR 0 4
60785: PUSH
60786: LD_VAR 0 4
60790: PUSH
60791: LD_VAR 0 9
60795: PUSH
60796: LD_VAR 0 3
60800: ARRAY
60801: DIFF
60802: ST_TO_ADDR
// end ;
60803: GO 60712
60805: POP
60806: POP
// if p then
60807: LD_VAR 0 11
60811: IFFALSE 60836
// result := Replace ( result , 4 , p ) ;
60813: LD_ADDR_VAR 0 2
60817: PUSH
60818: LD_VAR 0 2
60822: PPUSH
60823: LD_INT 4
60825: PPUSH
60826: LD_VAR 0 11
60830: PPUSH
60831: CALL_OW 1
60835: ST_TO_ADDR
// end ; if tmp and mech < 6 then
60836: LD_VAR 0 4
60840: PUSH
60841: LD_VAR 0 7
60845: PUSH
60846: LD_INT 6
60848: LESS
60849: AND
60850: IFFALSE 61038
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
60852: LD_ADDR_VAR 0 9
60856: PUSH
60857: LD_VAR 0 4
60861: PUSH
60862: LD_VAR 0 8
60866: PUSH
60867: LD_VAR 0 7
60871: UNION
60872: DIFF
60873: PPUSH
60874: LD_INT 3
60876: PPUSH
60877: CALL 52677 0 2
60881: ST_TO_ADDR
// p := [ ] ;
60882: LD_ADDR_VAR 0 11
60886: PUSH
60887: EMPTY
60888: ST_TO_ADDR
// if sort then
60889: LD_VAR 0 9
60893: IFFALSE 61009
// for i = 1 to 6 - mech do
60895: LD_ADDR_VAR 0 3
60899: PUSH
60900: DOUBLE
60901: LD_INT 1
60903: DEC
60904: ST_TO_ADDR
60905: LD_INT 6
60907: PUSH
60908: LD_VAR 0 7
60912: MINUS
60913: PUSH
60914: FOR_TO
60915: IFFALSE 61007
// begin if i = sort then
60917: LD_VAR 0 3
60921: PUSH
60922: LD_VAR 0 9
60926: EQUAL
60927: IFFALSE 60931
// break ;
60929: GO 61007
// if GetClass ( i ) = 3 then
60931: LD_VAR 0 3
60935: PPUSH
60936: CALL_OW 257
60940: PUSH
60941: LD_INT 3
60943: EQUAL
60944: IFFALSE 60948
// continue ;
60946: GO 60914
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60948: LD_ADDR_VAR 0 11
60952: PUSH
60953: LD_VAR 0 11
60957: PPUSH
60958: LD_VAR 0 11
60962: PUSH
60963: LD_INT 1
60965: PLUS
60966: PPUSH
60967: LD_VAR 0 9
60971: PUSH
60972: LD_VAR 0 3
60976: ARRAY
60977: PPUSH
60978: CALL_OW 2
60982: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60983: LD_ADDR_VAR 0 4
60987: PUSH
60988: LD_VAR 0 4
60992: PUSH
60993: LD_VAR 0 9
60997: PUSH
60998: LD_VAR 0 3
61002: ARRAY
61003: DIFF
61004: ST_TO_ADDR
// end ;
61005: GO 60914
61007: POP
61008: POP
// if p then
61009: LD_VAR 0 11
61013: IFFALSE 61038
// result := Replace ( result , 3 , p ) ;
61015: LD_ADDR_VAR 0 2
61019: PUSH
61020: LD_VAR 0 2
61024: PPUSH
61025: LD_INT 3
61027: PPUSH
61028: LD_VAR 0 11
61032: PPUSH
61033: CALL_OW 1
61037: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
61038: LD_VAR 0 4
61042: PUSH
61043: LD_INT 6
61045: GREATER
61046: PUSH
61047: LD_VAR 0 6
61051: PUSH
61052: LD_INT 6
61054: LESS
61055: AND
61056: IFFALSE 61250
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61058: LD_ADDR_VAR 0 9
61062: PUSH
61063: LD_VAR 0 4
61067: PUSH
61068: LD_VAR 0 8
61072: PUSH
61073: LD_VAR 0 7
61077: UNION
61078: PUSH
61079: LD_VAR 0 6
61083: UNION
61084: DIFF
61085: PPUSH
61086: LD_INT 2
61088: PPUSH
61089: CALL 52677 0 2
61093: ST_TO_ADDR
// p := [ ] ;
61094: LD_ADDR_VAR 0 11
61098: PUSH
61099: EMPTY
61100: ST_TO_ADDR
// if sort then
61101: LD_VAR 0 9
61105: IFFALSE 61221
// for i = 1 to 6 - eng do
61107: LD_ADDR_VAR 0 3
61111: PUSH
61112: DOUBLE
61113: LD_INT 1
61115: DEC
61116: ST_TO_ADDR
61117: LD_INT 6
61119: PUSH
61120: LD_VAR 0 6
61124: MINUS
61125: PUSH
61126: FOR_TO
61127: IFFALSE 61219
// begin if i = sort then
61129: LD_VAR 0 3
61133: PUSH
61134: LD_VAR 0 9
61138: EQUAL
61139: IFFALSE 61143
// break ;
61141: GO 61219
// if GetClass ( i ) = 2 then
61143: LD_VAR 0 3
61147: PPUSH
61148: CALL_OW 257
61152: PUSH
61153: LD_INT 2
61155: EQUAL
61156: IFFALSE 61160
// continue ;
61158: GO 61126
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61160: LD_ADDR_VAR 0 11
61164: PUSH
61165: LD_VAR 0 11
61169: PPUSH
61170: LD_VAR 0 11
61174: PUSH
61175: LD_INT 1
61177: PLUS
61178: PPUSH
61179: LD_VAR 0 9
61183: PUSH
61184: LD_VAR 0 3
61188: ARRAY
61189: PPUSH
61190: CALL_OW 2
61194: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61195: LD_ADDR_VAR 0 4
61199: PUSH
61200: LD_VAR 0 4
61204: PUSH
61205: LD_VAR 0 9
61209: PUSH
61210: LD_VAR 0 3
61214: ARRAY
61215: DIFF
61216: ST_TO_ADDR
// end ;
61217: GO 61126
61219: POP
61220: POP
// if p then
61221: LD_VAR 0 11
61225: IFFALSE 61250
// result := Replace ( result , 2 , p ) ;
61227: LD_ADDR_VAR 0 2
61231: PUSH
61232: LD_VAR 0 2
61236: PPUSH
61237: LD_INT 2
61239: PPUSH
61240: LD_VAR 0 11
61244: PPUSH
61245: CALL_OW 1
61249: ST_TO_ADDR
// end ; exit ;
61250: GO 62638
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
61252: LD_EXP 79
61256: PUSH
61257: LD_EXP 78
61261: PUSH
61262: LD_VAR 0 1
61266: ARRAY
61267: ARRAY
61268: NOT
61269: PUSH
61270: LD_EXP 52
61274: PUSH
61275: LD_VAR 0 1
61279: ARRAY
61280: PPUSH
61281: LD_INT 30
61283: PUSH
61284: LD_INT 3
61286: PUSH
61287: EMPTY
61288: LIST
61289: LIST
61290: PPUSH
61291: CALL_OW 72
61295: AND
61296: PUSH
61297: LD_EXP 57
61301: PUSH
61302: LD_VAR 0 1
61306: ARRAY
61307: AND
61308: IFFALSE 61916
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
61310: LD_ADDR_EXP 94
61314: PUSH
61315: LD_EXP 94
61319: PPUSH
61320: LD_VAR 0 1
61324: PPUSH
61325: LD_INT 5
61327: PPUSH
61328: CALL_OW 1
61332: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61333: LD_ADDR_VAR 0 2
61337: PUSH
61338: LD_INT 0
61340: PUSH
61341: LD_INT 0
61343: PUSH
61344: LD_INT 0
61346: PUSH
61347: LD_INT 0
61349: PUSH
61350: EMPTY
61351: LIST
61352: LIST
61353: LIST
61354: LIST
61355: ST_TO_ADDR
// if sci > 1 then
61356: LD_VAR 0 8
61360: PUSH
61361: LD_INT 1
61363: GREATER
61364: IFFALSE 61392
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
61366: LD_ADDR_VAR 0 4
61370: PUSH
61371: LD_VAR 0 4
61375: PUSH
61376: LD_VAR 0 8
61380: PUSH
61381: LD_VAR 0 8
61385: PUSH
61386: LD_INT 1
61388: ARRAY
61389: DIFF
61390: DIFF
61391: ST_TO_ADDR
// if tmp and not sci then
61392: LD_VAR 0 4
61396: PUSH
61397: LD_VAR 0 8
61401: NOT
61402: AND
61403: IFFALSE 61472
// begin sort := SortBySkill ( tmp , 4 ) ;
61405: LD_ADDR_VAR 0 9
61409: PUSH
61410: LD_VAR 0 4
61414: PPUSH
61415: LD_INT 4
61417: PPUSH
61418: CALL 52677 0 2
61422: ST_TO_ADDR
// if sort then
61423: LD_VAR 0 9
61427: IFFALSE 61443
// p := sort [ 1 ] ;
61429: LD_ADDR_VAR 0 11
61433: PUSH
61434: LD_VAR 0 9
61438: PUSH
61439: LD_INT 1
61441: ARRAY
61442: ST_TO_ADDR
// if p then
61443: LD_VAR 0 11
61447: IFFALSE 61472
// result := Replace ( result , 4 , p ) ;
61449: LD_ADDR_VAR 0 2
61453: PUSH
61454: LD_VAR 0 2
61458: PPUSH
61459: LD_INT 4
61461: PPUSH
61462: LD_VAR 0 11
61466: PPUSH
61467: CALL_OW 1
61471: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61472: LD_ADDR_VAR 0 4
61476: PUSH
61477: LD_VAR 0 4
61481: PUSH
61482: LD_VAR 0 7
61486: DIFF
61487: ST_TO_ADDR
// if tmp and mech < 6 then
61488: LD_VAR 0 4
61492: PUSH
61493: LD_VAR 0 7
61497: PUSH
61498: LD_INT 6
61500: LESS
61501: AND
61502: IFFALSE 61690
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61504: LD_ADDR_VAR 0 9
61508: PUSH
61509: LD_VAR 0 4
61513: PUSH
61514: LD_VAR 0 8
61518: PUSH
61519: LD_VAR 0 7
61523: UNION
61524: DIFF
61525: PPUSH
61526: LD_INT 3
61528: PPUSH
61529: CALL 52677 0 2
61533: ST_TO_ADDR
// p := [ ] ;
61534: LD_ADDR_VAR 0 11
61538: PUSH
61539: EMPTY
61540: ST_TO_ADDR
// if sort then
61541: LD_VAR 0 9
61545: IFFALSE 61661
// for i = 1 to 6 - mech do
61547: LD_ADDR_VAR 0 3
61551: PUSH
61552: DOUBLE
61553: LD_INT 1
61555: DEC
61556: ST_TO_ADDR
61557: LD_INT 6
61559: PUSH
61560: LD_VAR 0 7
61564: MINUS
61565: PUSH
61566: FOR_TO
61567: IFFALSE 61659
// begin if i = sort then
61569: LD_VAR 0 3
61573: PUSH
61574: LD_VAR 0 9
61578: EQUAL
61579: IFFALSE 61583
// break ;
61581: GO 61659
// if GetClass ( i ) = 3 then
61583: LD_VAR 0 3
61587: PPUSH
61588: CALL_OW 257
61592: PUSH
61593: LD_INT 3
61595: EQUAL
61596: IFFALSE 61600
// continue ;
61598: GO 61566
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61600: LD_ADDR_VAR 0 11
61604: PUSH
61605: LD_VAR 0 11
61609: PPUSH
61610: LD_VAR 0 11
61614: PUSH
61615: LD_INT 1
61617: PLUS
61618: PPUSH
61619: LD_VAR 0 9
61623: PUSH
61624: LD_VAR 0 3
61628: ARRAY
61629: PPUSH
61630: CALL_OW 2
61634: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61635: LD_ADDR_VAR 0 4
61639: PUSH
61640: LD_VAR 0 4
61644: PUSH
61645: LD_VAR 0 9
61649: PUSH
61650: LD_VAR 0 3
61654: ARRAY
61655: DIFF
61656: ST_TO_ADDR
// end ;
61657: GO 61566
61659: POP
61660: POP
// if p then
61661: LD_VAR 0 11
61665: IFFALSE 61690
// result := Replace ( result , 3 , p ) ;
61667: LD_ADDR_VAR 0 2
61671: PUSH
61672: LD_VAR 0 2
61676: PPUSH
61677: LD_INT 3
61679: PPUSH
61680: LD_VAR 0 11
61684: PPUSH
61685: CALL_OW 1
61689: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61690: LD_ADDR_VAR 0 4
61694: PUSH
61695: LD_VAR 0 4
61699: PUSH
61700: LD_VAR 0 6
61704: DIFF
61705: ST_TO_ADDR
// if tmp and eng < 6 then
61706: LD_VAR 0 4
61710: PUSH
61711: LD_VAR 0 6
61715: PUSH
61716: LD_INT 6
61718: LESS
61719: AND
61720: IFFALSE 61914
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61722: LD_ADDR_VAR 0 9
61726: PUSH
61727: LD_VAR 0 4
61731: PUSH
61732: LD_VAR 0 8
61736: PUSH
61737: LD_VAR 0 7
61741: UNION
61742: PUSH
61743: LD_VAR 0 6
61747: UNION
61748: DIFF
61749: PPUSH
61750: LD_INT 2
61752: PPUSH
61753: CALL 52677 0 2
61757: ST_TO_ADDR
// p := [ ] ;
61758: LD_ADDR_VAR 0 11
61762: PUSH
61763: EMPTY
61764: ST_TO_ADDR
// if sort then
61765: LD_VAR 0 9
61769: IFFALSE 61885
// for i = 1 to 6 - eng do
61771: LD_ADDR_VAR 0 3
61775: PUSH
61776: DOUBLE
61777: LD_INT 1
61779: DEC
61780: ST_TO_ADDR
61781: LD_INT 6
61783: PUSH
61784: LD_VAR 0 6
61788: MINUS
61789: PUSH
61790: FOR_TO
61791: IFFALSE 61883
// begin if i = sort then
61793: LD_VAR 0 3
61797: PUSH
61798: LD_VAR 0 9
61802: EQUAL
61803: IFFALSE 61807
// break ;
61805: GO 61883
// if GetClass ( i ) = 2 then
61807: LD_VAR 0 3
61811: PPUSH
61812: CALL_OW 257
61816: PUSH
61817: LD_INT 2
61819: EQUAL
61820: IFFALSE 61824
// continue ;
61822: GO 61790
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61824: LD_ADDR_VAR 0 11
61828: PUSH
61829: LD_VAR 0 11
61833: PPUSH
61834: LD_VAR 0 11
61838: PUSH
61839: LD_INT 1
61841: PLUS
61842: PPUSH
61843: LD_VAR 0 9
61847: PUSH
61848: LD_VAR 0 3
61852: ARRAY
61853: PPUSH
61854: CALL_OW 2
61858: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61859: LD_ADDR_VAR 0 4
61863: PUSH
61864: LD_VAR 0 4
61868: PUSH
61869: LD_VAR 0 9
61873: PUSH
61874: LD_VAR 0 3
61878: ARRAY
61879: DIFF
61880: ST_TO_ADDR
// end ;
61881: GO 61790
61883: POP
61884: POP
// if p then
61885: LD_VAR 0 11
61889: IFFALSE 61914
// result := Replace ( result , 2 , p ) ;
61891: LD_ADDR_VAR 0 2
61895: PUSH
61896: LD_VAR 0 2
61900: PPUSH
61901: LD_INT 2
61903: PPUSH
61904: LD_VAR 0 11
61908: PPUSH
61909: CALL_OW 1
61913: ST_TO_ADDR
// end ; exit ;
61914: GO 62638
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
61916: LD_EXP 79
61920: PUSH
61921: LD_EXP 78
61925: PUSH
61926: LD_VAR 0 1
61930: ARRAY
61931: ARRAY
61932: NOT
61933: PUSH
61934: LD_EXP 52
61938: PUSH
61939: LD_VAR 0 1
61943: ARRAY
61944: PPUSH
61945: LD_INT 30
61947: PUSH
61948: LD_INT 3
61950: PUSH
61951: EMPTY
61952: LIST
61953: LIST
61954: PPUSH
61955: CALL_OW 72
61959: AND
61960: PUSH
61961: LD_EXP 57
61965: PUSH
61966: LD_VAR 0 1
61970: ARRAY
61971: NOT
61972: AND
61973: IFFALSE 62638
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
61975: LD_ADDR_EXP 94
61979: PUSH
61980: LD_EXP 94
61984: PPUSH
61985: LD_VAR 0 1
61989: PPUSH
61990: LD_INT 6
61992: PPUSH
61993: CALL_OW 1
61997: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61998: LD_ADDR_VAR 0 2
62002: PUSH
62003: LD_INT 0
62005: PUSH
62006: LD_INT 0
62008: PUSH
62009: LD_INT 0
62011: PUSH
62012: LD_INT 0
62014: PUSH
62015: EMPTY
62016: LIST
62017: LIST
62018: LIST
62019: LIST
62020: ST_TO_ADDR
// if sci >= 1 then
62021: LD_VAR 0 8
62025: PUSH
62026: LD_INT 1
62028: GREATEREQUAL
62029: IFFALSE 62051
// tmp := tmp diff sci [ 1 ] ;
62031: LD_ADDR_VAR 0 4
62035: PUSH
62036: LD_VAR 0 4
62040: PUSH
62041: LD_VAR 0 8
62045: PUSH
62046: LD_INT 1
62048: ARRAY
62049: DIFF
62050: ST_TO_ADDR
// if tmp and not sci then
62051: LD_VAR 0 4
62055: PUSH
62056: LD_VAR 0 8
62060: NOT
62061: AND
62062: IFFALSE 62131
// begin sort := SortBySkill ( tmp , 4 ) ;
62064: LD_ADDR_VAR 0 9
62068: PUSH
62069: LD_VAR 0 4
62073: PPUSH
62074: LD_INT 4
62076: PPUSH
62077: CALL 52677 0 2
62081: ST_TO_ADDR
// if sort then
62082: LD_VAR 0 9
62086: IFFALSE 62102
// p := sort [ 1 ] ;
62088: LD_ADDR_VAR 0 11
62092: PUSH
62093: LD_VAR 0 9
62097: PUSH
62098: LD_INT 1
62100: ARRAY
62101: ST_TO_ADDR
// if p then
62102: LD_VAR 0 11
62106: IFFALSE 62131
// result := Replace ( result , 4 , p ) ;
62108: LD_ADDR_VAR 0 2
62112: PUSH
62113: LD_VAR 0 2
62117: PPUSH
62118: LD_INT 4
62120: PPUSH
62121: LD_VAR 0 11
62125: PPUSH
62126: CALL_OW 1
62130: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62131: LD_ADDR_VAR 0 4
62135: PUSH
62136: LD_VAR 0 4
62140: PUSH
62141: LD_VAR 0 7
62145: DIFF
62146: ST_TO_ADDR
// if tmp and mech < 6 then
62147: LD_VAR 0 4
62151: PUSH
62152: LD_VAR 0 7
62156: PUSH
62157: LD_INT 6
62159: LESS
62160: AND
62161: IFFALSE 62343
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
62163: LD_ADDR_VAR 0 9
62167: PUSH
62168: LD_VAR 0 4
62172: PUSH
62173: LD_VAR 0 7
62177: DIFF
62178: PPUSH
62179: LD_INT 3
62181: PPUSH
62182: CALL 52677 0 2
62186: ST_TO_ADDR
// p := [ ] ;
62187: LD_ADDR_VAR 0 11
62191: PUSH
62192: EMPTY
62193: ST_TO_ADDR
// if sort then
62194: LD_VAR 0 9
62198: IFFALSE 62314
// for i = 1 to 6 - mech do
62200: LD_ADDR_VAR 0 3
62204: PUSH
62205: DOUBLE
62206: LD_INT 1
62208: DEC
62209: ST_TO_ADDR
62210: LD_INT 6
62212: PUSH
62213: LD_VAR 0 7
62217: MINUS
62218: PUSH
62219: FOR_TO
62220: IFFALSE 62312
// begin if i = sort then
62222: LD_VAR 0 3
62226: PUSH
62227: LD_VAR 0 9
62231: EQUAL
62232: IFFALSE 62236
// break ;
62234: GO 62312
// if GetClass ( i ) = 3 then
62236: LD_VAR 0 3
62240: PPUSH
62241: CALL_OW 257
62245: PUSH
62246: LD_INT 3
62248: EQUAL
62249: IFFALSE 62253
// continue ;
62251: GO 62219
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62253: LD_ADDR_VAR 0 11
62257: PUSH
62258: LD_VAR 0 11
62262: PPUSH
62263: LD_VAR 0 11
62267: PUSH
62268: LD_INT 1
62270: PLUS
62271: PPUSH
62272: LD_VAR 0 9
62276: PUSH
62277: LD_VAR 0 3
62281: ARRAY
62282: PPUSH
62283: CALL_OW 2
62287: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62288: LD_ADDR_VAR 0 4
62292: PUSH
62293: LD_VAR 0 4
62297: PUSH
62298: LD_VAR 0 9
62302: PUSH
62303: LD_VAR 0 3
62307: ARRAY
62308: DIFF
62309: ST_TO_ADDR
// end ;
62310: GO 62219
62312: POP
62313: POP
// if p then
62314: LD_VAR 0 11
62318: IFFALSE 62343
// result := Replace ( result , 3 , p ) ;
62320: LD_ADDR_VAR 0 2
62324: PUSH
62325: LD_VAR 0 2
62329: PPUSH
62330: LD_INT 3
62332: PPUSH
62333: LD_VAR 0 11
62337: PPUSH
62338: CALL_OW 1
62342: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62343: LD_ADDR_VAR 0 4
62347: PUSH
62348: LD_VAR 0 4
62352: PUSH
62353: LD_VAR 0 6
62357: DIFF
62358: ST_TO_ADDR
// if tmp and eng < 4 then
62359: LD_VAR 0 4
62363: PUSH
62364: LD_VAR 0 6
62368: PUSH
62369: LD_INT 4
62371: LESS
62372: AND
62373: IFFALSE 62563
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
62375: LD_ADDR_VAR 0 9
62379: PUSH
62380: LD_VAR 0 4
62384: PUSH
62385: LD_VAR 0 7
62389: PUSH
62390: LD_VAR 0 6
62394: UNION
62395: DIFF
62396: PPUSH
62397: LD_INT 2
62399: PPUSH
62400: CALL 52677 0 2
62404: ST_TO_ADDR
// p := [ ] ;
62405: LD_ADDR_VAR 0 11
62409: PUSH
62410: EMPTY
62411: ST_TO_ADDR
// if sort then
62412: LD_VAR 0 9
62416: IFFALSE 62532
// for i = 1 to 4 - eng do
62418: LD_ADDR_VAR 0 3
62422: PUSH
62423: DOUBLE
62424: LD_INT 1
62426: DEC
62427: ST_TO_ADDR
62428: LD_INT 4
62430: PUSH
62431: LD_VAR 0 6
62435: MINUS
62436: PUSH
62437: FOR_TO
62438: IFFALSE 62530
// begin if i = sort then
62440: LD_VAR 0 3
62444: PUSH
62445: LD_VAR 0 9
62449: EQUAL
62450: IFFALSE 62454
// break ;
62452: GO 62530
// if GetClass ( i ) = 2 then
62454: LD_VAR 0 3
62458: PPUSH
62459: CALL_OW 257
62463: PUSH
62464: LD_INT 2
62466: EQUAL
62467: IFFALSE 62471
// continue ;
62469: GO 62437
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62471: LD_ADDR_VAR 0 11
62475: PUSH
62476: LD_VAR 0 11
62480: PPUSH
62481: LD_VAR 0 11
62485: PUSH
62486: LD_INT 1
62488: PLUS
62489: PPUSH
62490: LD_VAR 0 9
62494: PUSH
62495: LD_VAR 0 3
62499: ARRAY
62500: PPUSH
62501: CALL_OW 2
62505: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62506: LD_ADDR_VAR 0 4
62510: PUSH
62511: LD_VAR 0 4
62515: PUSH
62516: LD_VAR 0 9
62520: PUSH
62521: LD_VAR 0 3
62525: ARRAY
62526: DIFF
62527: ST_TO_ADDR
// end ;
62528: GO 62437
62530: POP
62531: POP
// if p then
62532: LD_VAR 0 11
62536: IFFALSE 62561
// result := Replace ( result , 2 , p ) ;
62538: LD_ADDR_VAR 0 2
62542: PUSH
62543: LD_VAR 0 2
62547: PPUSH
62548: LD_INT 2
62550: PPUSH
62551: LD_VAR 0 11
62555: PPUSH
62556: CALL_OW 1
62560: ST_TO_ADDR
// end else
62561: GO 62607
// for i = eng downto 5 do
62563: LD_ADDR_VAR 0 3
62567: PUSH
62568: DOUBLE
62569: LD_VAR 0 6
62573: INC
62574: ST_TO_ADDR
62575: LD_INT 5
62577: PUSH
62578: FOR_DOWNTO
62579: IFFALSE 62605
// tmp := tmp union eng [ i ] ;
62581: LD_ADDR_VAR 0 4
62585: PUSH
62586: LD_VAR 0 4
62590: PUSH
62591: LD_VAR 0 6
62595: PUSH
62596: LD_VAR 0 3
62600: ARRAY
62601: UNION
62602: ST_TO_ADDR
62603: GO 62578
62605: POP
62606: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
62607: LD_ADDR_VAR 0 2
62611: PUSH
62612: LD_VAR 0 2
62616: PPUSH
62617: LD_INT 1
62619: PPUSH
62620: LD_VAR 0 4
62624: PUSH
62625: LD_VAR 0 5
62629: DIFF
62630: PPUSH
62631: CALL_OW 1
62635: ST_TO_ADDR
// exit ;
62636: GO 62638
// end ; end ;
62638: LD_VAR 0 2
62642: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
62643: LD_INT 0
62645: PPUSH
62646: PPUSH
62647: PPUSH
// if not mc_bases then
62648: LD_EXP 52
62652: NOT
62653: IFFALSE 62657
// exit ;
62655: GO 62763
// for i = 1 to mc_bases do
62657: LD_ADDR_VAR 0 2
62661: PUSH
62662: DOUBLE
62663: LD_INT 1
62665: DEC
62666: ST_TO_ADDR
62667: LD_EXP 52
62671: PUSH
62672: FOR_TO
62673: IFFALSE 62754
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
62675: LD_ADDR_VAR 0 3
62679: PUSH
62680: LD_EXP 52
62684: PUSH
62685: LD_VAR 0 2
62689: ARRAY
62690: PPUSH
62691: LD_INT 21
62693: PUSH
62694: LD_INT 3
62696: PUSH
62697: EMPTY
62698: LIST
62699: LIST
62700: PUSH
62701: LD_INT 3
62703: PUSH
62704: LD_INT 24
62706: PUSH
62707: LD_INT 1000
62709: PUSH
62710: EMPTY
62711: LIST
62712: LIST
62713: PUSH
62714: EMPTY
62715: LIST
62716: LIST
62717: PUSH
62718: EMPTY
62719: LIST
62720: LIST
62721: PPUSH
62722: CALL_OW 72
62726: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
62727: LD_ADDR_EXP 53
62731: PUSH
62732: LD_EXP 53
62736: PPUSH
62737: LD_VAR 0 2
62741: PPUSH
62742: LD_VAR 0 3
62746: PPUSH
62747: CALL_OW 1
62751: ST_TO_ADDR
// end ;
62752: GO 62672
62754: POP
62755: POP
// RaiseSailEvent ( 101 ) ;
62756: LD_INT 101
62758: PPUSH
62759: CALL_OW 427
// end ;
62763: LD_VAR 0 1
62767: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
62768: LD_INT 0
62770: PPUSH
62771: PPUSH
62772: PPUSH
62773: PPUSH
62774: PPUSH
62775: PPUSH
62776: PPUSH
// if not mc_bases then
62777: LD_EXP 52
62781: NOT
62782: IFFALSE 62786
// exit ;
62784: GO 63359
// for i = 1 to mc_bases do
62786: LD_ADDR_VAR 0 2
62790: PUSH
62791: DOUBLE
62792: LD_INT 1
62794: DEC
62795: ST_TO_ADDR
62796: LD_EXP 52
62800: PUSH
62801: FOR_TO
62802: IFFALSE 63350
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
62804: LD_ADDR_VAR 0 5
62808: PUSH
62809: LD_EXP 52
62813: PUSH
62814: LD_VAR 0 2
62818: ARRAY
62819: PUSH
62820: LD_EXP 81
62824: PUSH
62825: LD_VAR 0 2
62829: ARRAY
62830: UNION
62831: PPUSH
62832: LD_INT 21
62834: PUSH
62835: LD_INT 1
62837: PUSH
62838: EMPTY
62839: LIST
62840: LIST
62841: PUSH
62842: LD_INT 1
62844: PUSH
62845: LD_INT 3
62847: PUSH
62848: LD_INT 54
62850: PUSH
62851: EMPTY
62852: LIST
62853: PUSH
62854: EMPTY
62855: LIST
62856: LIST
62857: PUSH
62858: LD_INT 3
62860: PUSH
62861: LD_INT 24
62863: PUSH
62864: LD_INT 800
62866: PUSH
62867: EMPTY
62868: LIST
62869: LIST
62870: PUSH
62871: EMPTY
62872: LIST
62873: LIST
62874: PUSH
62875: EMPTY
62876: LIST
62877: LIST
62878: LIST
62879: PUSH
62880: EMPTY
62881: LIST
62882: LIST
62883: PPUSH
62884: CALL_OW 72
62888: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
62889: LD_ADDR_VAR 0 6
62893: PUSH
62894: LD_EXP 52
62898: PUSH
62899: LD_VAR 0 2
62903: ARRAY
62904: PPUSH
62905: LD_INT 21
62907: PUSH
62908: LD_INT 1
62910: PUSH
62911: EMPTY
62912: LIST
62913: LIST
62914: PUSH
62915: LD_INT 1
62917: PUSH
62918: LD_INT 3
62920: PUSH
62921: LD_INT 54
62923: PUSH
62924: EMPTY
62925: LIST
62926: PUSH
62927: EMPTY
62928: LIST
62929: LIST
62930: PUSH
62931: LD_INT 3
62933: PUSH
62934: LD_INT 24
62936: PUSH
62937: LD_INT 250
62939: PUSH
62940: EMPTY
62941: LIST
62942: LIST
62943: PUSH
62944: EMPTY
62945: LIST
62946: LIST
62947: PUSH
62948: EMPTY
62949: LIST
62950: LIST
62951: LIST
62952: PUSH
62953: EMPTY
62954: LIST
62955: LIST
62956: PPUSH
62957: CALL_OW 72
62961: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
62962: LD_ADDR_VAR 0 7
62966: PUSH
62967: LD_VAR 0 5
62971: PUSH
62972: LD_VAR 0 6
62976: DIFF
62977: ST_TO_ADDR
// if not need_heal_1 then
62978: LD_VAR 0 6
62982: NOT
62983: IFFALSE 63016
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
62985: LD_ADDR_EXP 55
62989: PUSH
62990: LD_EXP 55
62994: PPUSH
62995: LD_VAR 0 2
62999: PUSH
63000: LD_INT 1
63002: PUSH
63003: EMPTY
63004: LIST
63005: LIST
63006: PPUSH
63007: EMPTY
63008: PPUSH
63009: CALL 18419 0 3
63013: ST_TO_ADDR
63014: GO 63086
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63016: LD_ADDR_EXP 55
63020: PUSH
63021: LD_EXP 55
63025: PPUSH
63026: LD_VAR 0 2
63030: PUSH
63031: LD_INT 1
63033: PUSH
63034: EMPTY
63035: LIST
63036: LIST
63037: PPUSH
63038: LD_EXP 55
63042: PUSH
63043: LD_VAR 0 2
63047: ARRAY
63048: PUSH
63049: LD_INT 1
63051: ARRAY
63052: PPUSH
63053: LD_INT 3
63055: PUSH
63056: LD_INT 24
63058: PUSH
63059: LD_INT 1000
63061: PUSH
63062: EMPTY
63063: LIST
63064: LIST
63065: PUSH
63066: EMPTY
63067: LIST
63068: LIST
63069: PPUSH
63070: CALL_OW 72
63074: PUSH
63075: LD_VAR 0 6
63079: UNION
63080: PPUSH
63081: CALL 18419 0 3
63085: ST_TO_ADDR
// if not need_heal_2 then
63086: LD_VAR 0 7
63090: NOT
63091: IFFALSE 63124
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
63093: LD_ADDR_EXP 55
63097: PUSH
63098: LD_EXP 55
63102: PPUSH
63103: LD_VAR 0 2
63107: PUSH
63108: LD_INT 2
63110: PUSH
63111: EMPTY
63112: LIST
63113: LIST
63114: PPUSH
63115: EMPTY
63116: PPUSH
63117: CALL 18419 0 3
63121: ST_TO_ADDR
63122: GO 63156
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
63124: LD_ADDR_EXP 55
63128: PUSH
63129: LD_EXP 55
63133: PPUSH
63134: LD_VAR 0 2
63138: PUSH
63139: LD_INT 2
63141: PUSH
63142: EMPTY
63143: LIST
63144: LIST
63145: PPUSH
63146: LD_VAR 0 7
63150: PPUSH
63151: CALL 18419 0 3
63155: ST_TO_ADDR
// if need_heal_2 then
63156: LD_VAR 0 7
63160: IFFALSE 63332
// for j in need_heal_2 do
63162: LD_ADDR_VAR 0 3
63166: PUSH
63167: LD_VAR 0 7
63171: PUSH
63172: FOR_IN
63173: IFFALSE 63330
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
63175: LD_ADDR_VAR 0 5
63179: PUSH
63180: LD_EXP 52
63184: PUSH
63185: LD_VAR 0 2
63189: ARRAY
63190: PPUSH
63191: LD_INT 2
63193: PUSH
63194: LD_INT 30
63196: PUSH
63197: LD_INT 6
63199: PUSH
63200: EMPTY
63201: LIST
63202: LIST
63203: PUSH
63204: LD_INT 30
63206: PUSH
63207: LD_INT 7
63209: PUSH
63210: EMPTY
63211: LIST
63212: LIST
63213: PUSH
63214: LD_INT 30
63216: PUSH
63217: LD_INT 8
63219: PUSH
63220: EMPTY
63221: LIST
63222: LIST
63223: PUSH
63224: LD_INT 30
63226: PUSH
63227: LD_INT 0
63229: PUSH
63230: EMPTY
63231: LIST
63232: LIST
63233: PUSH
63234: LD_INT 30
63236: PUSH
63237: LD_INT 1
63239: PUSH
63240: EMPTY
63241: LIST
63242: LIST
63243: PUSH
63244: LD_INT 25
63246: PUSH
63247: LD_INT 4
63249: PUSH
63250: EMPTY
63251: LIST
63252: LIST
63253: PUSH
63254: EMPTY
63255: LIST
63256: LIST
63257: LIST
63258: LIST
63259: LIST
63260: LIST
63261: LIST
63262: PPUSH
63263: CALL_OW 72
63267: ST_TO_ADDR
// if tmp then
63268: LD_VAR 0 5
63272: IFFALSE 63328
// begin k := NearestUnitToUnit ( tmp , j ) ;
63274: LD_ADDR_VAR 0 4
63278: PUSH
63279: LD_VAR 0 5
63283: PPUSH
63284: LD_VAR 0 3
63288: PPUSH
63289: CALL_OW 74
63293: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
63294: LD_VAR 0 3
63298: PPUSH
63299: LD_VAR 0 4
63303: PPUSH
63304: CALL_OW 296
63308: PUSH
63309: LD_INT 7
63311: GREATER
63312: IFFALSE 63328
// ComMoveUnit ( j , k ) ;
63314: LD_VAR 0 3
63318: PPUSH
63319: LD_VAR 0 4
63323: PPUSH
63324: CALL_OW 112
// end ; end ;
63328: GO 63172
63330: POP
63331: POP
// if not need_heal_1 and not need_heal_2 then
63332: LD_VAR 0 6
63336: NOT
63337: PUSH
63338: LD_VAR 0 7
63342: NOT
63343: AND
63344: IFFALSE 63348
// continue ;
63346: GO 62801
// end ;
63348: GO 62801
63350: POP
63351: POP
// RaiseSailEvent ( 102 ) ;
63352: LD_INT 102
63354: PPUSH
63355: CALL_OW 427
// end ;
63359: LD_VAR 0 1
63363: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
63364: LD_INT 0
63366: PPUSH
63367: PPUSH
63368: PPUSH
63369: PPUSH
63370: PPUSH
63371: PPUSH
63372: PPUSH
63373: PPUSH
// if not mc_bases then
63374: LD_EXP 52
63378: NOT
63379: IFFALSE 63383
// exit ;
63381: GO 64223
// for i = 1 to mc_bases do
63383: LD_ADDR_VAR 0 2
63387: PUSH
63388: DOUBLE
63389: LD_INT 1
63391: DEC
63392: ST_TO_ADDR
63393: LD_EXP 52
63397: PUSH
63398: FOR_TO
63399: IFFALSE 64221
// begin if not mc_building_need_repair [ i ] then
63401: LD_EXP 53
63405: PUSH
63406: LD_VAR 0 2
63410: ARRAY
63411: NOT
63412: IFFALSE 63586
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
63414: LD_ADDR_VAR 0 6
63418: PUSH
63419: LD_EXP 71
63423: PUSH
63424: LD_VAR 0 2
63428: ARRAY
63429: PPUSH
63430: LD_INT 3
63432: PUSH
63433: LD_INT 24
63435: PUSH
63436: LD_INT 1000
63438: PUSH
63439: EMPTY
63440: LIST
63441: LIST
63442: PUSH
63443: EMPTY
63444: LIST
63445: LIST
63446: PUSH
63447: LD_INT 2
63449: PUSH
63450: LD_INT 34
63452: PUSH
63453: LD_INT 13
63455: PUSH
63456: EMPTY
63457: LIST
63458: LIST
63459: PUSH
63460: LD_INT 34
63462: PUSH
63463: LD_INT 52
63465: PUSH
63466: EMPTY
63467: LIST
63468: LIST
63469: PUSH
63470: EMPTY
63471: LIST
63472: LIST
63473: LIST
63474: PUSH
63475: EMPTY
63476: LIST
63477: LIST
63478: PPUSH
63479: CALL_OW 72
63483: ST_TO_ADDR
// if cranes then
63484: LD_VAR 0 6
63488: IFFALSE 63550
// for j in cranes do
63490: LD_ADDR_VAR 0 3
63494: PUSH
63495: LD_VAR 0 6
63499: PUSH
63500: FOR_IN
63501: IFFALSE 63548
// if not IsInArea ( j , mc_parking [ i ] ) then
63503: LD_VAR 0 3
63507: PPUSH
63508: LD_EXP 76
63512: PUSH
63513: LD_VAR 0 2
63517: ARRAY
63518: PPUSH
63519: CALL_OW 308
63523: NOT
63524: IFFALSE 63546
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63526: LD_VAR 0 3
63530: PPUSH
63531: LD_EXP 76
63535: PUSH
63536: LD_VAR 0 2
63540: ARRAY
63541: PPUSH
63542: CALL_OW 113
63546: GO 63500
63548: POP
63549: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63550: LD_ADDR_EXP 54
63554: PUSH
63555: LD_EXP 54
63559: PPUSH
63560: LD_VAR 0 2
63564: PPUSH
63565: EMPTY
63566: PPUSH
63567: CALL_OW 1
63571: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
63572: LD_VAR 0 2
63576: PPUSH
63577: LD_INT 101
63579: PPUSH
63580: CALL 58476 0 2
// continue ;
63584: GO 63398
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
63586: LD_ADDR_EXP 58
63590: PUSH
63591: LD_EXP 58
63595: PPUSH
63596: LD_VAR 0 2
63600: PPUSH
63601: EMPTY
63602: PPUSH
63603: CALL_OW 1
63607: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63608: LD_VAR 0 2
63612: PPUSH
63613: LD_INT 103
63615: PPUSH
63616: CALL 58476 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
63620: LD_ADDR_VAR 0 5
63624: PUSH
63625: LD_EXP 52
63629: PUSH
63630: LD_VAR 0 2
63634: ARRAY
63635: PUSH
63636: LD_EXP 81
63640: PUSH
63641: LD_VAR 0 2
63645: ARRAY
63646: UNION
63647: PPUSH
63648: LD_INT 2
63650: PUSH
63651: LD_INT 25
63653: PUSH
63654: LD_INT 2
63656: PUSH
63657: EMPTY
63658: LIST
63659: LIST
63660: PUSH
63661: LD_INT 25
63663: PUSH
63664: LD_INT 16
63666: PUSH
63667: EMPTY
63668: LIST
63669: LIST
63670: PUSH
63671: EMPTY
63672: LIST
63673: LIST
63674: LIST
63675: PUSH
63676: EMPTY
63677: LIST
63678: PPUSH
63679: CALL_OW 72
63683: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
63684: LD_ADDR_VAR 0 6
63688: PUSH
63689: LD_EXP 71
63693: PUSH
63694: LD_VAR 0 2
63698: ARRAY
63699: PPUSH
63700: LD_INT 2
63702: PUSH
63703: LD_INT 34
63705: PUSH
63706: LD_INT 13
63708: PUSH
63709: EMPTY
63710: LIST
63711: LIST
63712: PUSH
63713: LD_INT 34
63715: PUSH
63716: LD_INT 52
63718: PUSH
63719: EMPTY
63720: LIST
63721: LIST
63722: PUSH
63723: EMPTY
63724: LIST
63725: LIST
63726: LIST
63727: PPUSH
63728: CALL_OW 72
63732: ST_TO_ADDR
// if cranes then
63733: LD_VAR 0 6
63737: IFFALSE 63873
// begin for j in cranes do
63739: LD_ADDR_VAR 0 3
63743: PUSH
63744: LD_VAR 0 6
63748: PUSH
63749: FOR_IN
63750: IFFALSE 63871
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
63752: LD_VAR 0 3
63756: PPUSH
63757: CALL_OW 256
63761: PUSH
63762: LD_INT 500
63764: GREATEREQUAL
63765: PUSH
63766: LD_VAR 0 3
63770: PPUSH
63771: CALL_OW 314
63775: NOT
63776: AND
63777: IFFALSE 63811
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
63779: LD_VAR 0 3
63783: PPUSH
63784: LD_EXP 53
63788: PUSH
63789: LD_VAR 0 2
63793: ARRAY
63794: PPUSH
63795: LD_VAR 0 3
63799: PPUSH
63800: CALL_OW 74
63804: PPUSH
63805: CALL_OW 130
63809: GO 63869
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
63811: LD_VAR 0 3
63815: PPUSH
63816: CALL_OW 256
63820: PUSH
63821: LD_INT 500
63823: LESS
63824: PUSH
63825: LD_VAR 0 3
63829: PPUSH
63830: LD_EXP 76
63834: PUSH
63835: LD_VAR 0 2
63839: ARRAY
63840: PPUSH
63841: CALL_OW 308
63845: NOT
63846: AND
63847: IFFALSE 63869
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63849: LD_VAR 0 3
63853: PPUSH
63854: LD_EXP 76
63858: PUSH
63859: LD_VAR 0 2
63863: ARRAY
63864: PPUSH
63865: CALL_OW 113
63869: GO 63749
63871: POP
63872: POP
// end ; if not tmp then
63873: LD_VAR 0 5
63877: NOT
63878: IFFALSE 63882
// continue ;
63880: GO 63398
// for j in tmp do
63882: LD_ADDR_VAR 0 3
63886: PUSH
63887: LD_VAR 0 5
63891: PUSH
63892: FOR_IN
63893: IFFALSE 64217
// begin if mc_need_heal [ i ] then
63895: LD_EXP 55
63899: PUSH
63900: LD_VAR 0 2
63904: ARRAY
63905: IFFALSE 63953
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
63907: LD_VAR 0 3
63911: PUSH
63912: LD_EXP 55
63916: PUSH
63917: LD_VAR 0 2
63921: ARRAY
63922: PUSH
63923: LD_INT 1
63925: ARRAY
63926: IN
63927: PUSH
63928: LD_VAR 0 3
63932: PUSH
63933: LD_EXP 55
63937: PUSH
63938: LD_VAR 0 2
63942: ARRAY
63943: PUSH
63944: LD_INT 2
63946: ARRAY
63947: IN
63948: OR
63949: IFFALSE 63953
// continue ;
63951: GO 63892
// if IsInUnit ( j ) then
63953: LD_VAR 0 3
63957: PPUSH
63958: CALL_OW 310
63962: IFFALSE 63973
// ComExitBuilding ( j ) ;
63964: LD_VAR 0 3
63968: PPUSH
63969: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
63973: LD_VAR 0 3
63977: PUSH
63978: LD_EXP 54
63982: PUSH
63983: LD_VAR 0 2
63987: ARRAY
63988: IN
63989: NOT
63990: IFFALSE 64048
// begin SetTag ( j , 101 ) ;
63992: LD_VAR 0 3
63996: PPUSH
63997: LD_INT 101
63999: PPUSH
64000: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64004: LD_ADDR_EXP 54
64008: PUSH
64009: LD_EXP 54
64013: PPUSH
64014: LD_VAR 0 2
64018: PUSH
64019: LD_EXP 54
64023: PUSH
64024: LD_VAR 0 2
64028: ARRAY
64029: PUSH
64030: LD_INT 1
64032: PLUS
64033: PUSH
64034: EMPTY
64035: LIST
64036: LIST
64037: PPUSH
64038: LD_VAR 0 3
64042: PPUSH
64043: CALL 18419 0 3
64047: ST_TO_ADDR
// end ; wait ( 1 ) ;
64048: LD_INT 1
64050: PPUSH
64051: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
64055: LD_ADDR_VAR 0 7
64059: PUSH
64060: LD_EXP 53
64064: PUSH
64065: LD_VAR 0 2
64069: ARRAY
64070: ST_TO_ADDR
// if mc_scan [ i ] then
64071: LD_EXP 75
64075: PUSH
64076: LD_VAR 0 2
64080: ARRAY
64081: IFFALSE 64150
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
64083: LD_ADDR_VAR 0 7
64087: PUSH
64088: LD_EXP 53
64092: PUSH
64093: LD_VAR 0 2
64097: ARRAY
64098: PPUSH
64099: LD_INT 3
64101: PUSH
64102: LD_INT 2
64104: PUSH
64105: LD_INT 30
64107: PUSH
64108: LD_INT 32
64110: PUSH
64111: EMPTY
64112: LIST
64113: LIST
64114: PUSH
64115: LD_INT 30
64117: PUSH
64118: LD_INT 33
64120: PUSH
64121: EMPTY
64122: LIST
64123: LIST
64124: PUSH
64125: LD_INT 30
64127: PUSH
64128: LD_INT 31
64130: PUSH
64131: EMPTY
64132: LIST
64133: LIST
64134: PUSH
64135: EMPTY
64136: LIST
64137: LIST
64138: LIST
64139: LIST
64140: PUSH
64141: EMPTY
64142: LIST
64143: LIST
64144: PPUSH
64145: CALL_OW 72
64149: ST_TO_ADDR
// if not to_repair_tmp then
64150: LD_VAR 0 7
64154: NOT
64155: IFFALSE 64159
// continue ;
64157: GO 63892
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
64159: LD_ADDR_VAR 0 8
64163: PUSH
64164: LD_VAR 0 7
64168: PPUSH
64169: LD_VAR 0 3
64173: PPUSH
64174: CALL_OW 74
64178: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
64179: LD_VAR 0 8
64183: PPUSH
64184: LD_INT 14
64186: PPUSH
64187: CALL 21012 0 2
64191: PUSH
64192: LD_INT 4
64194: ARRAY
64195: PUSH
64196: LD_INT 5
64198: LESS
64199: IFFALSE 64215
// ComRepairBuilding ( j , to_repair ) ;
64201: LD_VAR 0 3
64205: PPUSH
64206: LD_VAR 0 8
64210: PPUSH
64211: CALL_OW 130
// end ;
64215: GO 63892
64217: POP
64218: POP
// end ;
64219: GO 63398
64221: POP
64222: POP
// end ;
64223: LD_VAR 0 1
64227: RET
// export function MC_Heal ; var i , j , tmp ; begin
64228: LD_INT 0
64230: PPUSH
64231: PPUSH
64232: PPUSH
64233: PPUSH
// if not mc_bases then
64234: LD_EXP 52
64238: NOT
64239: IFFALSE 64243
// exit ;
64241: GO 64645
// for i = 1 to mc_bases do
64243: LD_ADDR_VAR 0 2
64247: PUSH
64248: DOUBLE
64249: LD_INT 1
64251: DEC
64252: ST_TO_ADDR
64253: LD_EXP 52
64257: PUSH
64258: FOR_TO
64259: IFFALSE 64643
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
64261: LD_EXP 55
64265: PUSH
64266: LD_VAR 0 2
64270: ARRAY
64271: PUSH
64272: LD_INT 1
64274: ARRAY
64275: NOT
64276: PUSH
64277: LD_EXP 55
64281: PUSH
64282: LD_VAR 0 2
64286: ARRAY
64287: PUSH
64288: LD_INT 2
64290: ARRAY
64291: NOT
64292: AND
64293: IFFALSE 64331
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
64295: LD_ADDR_EXP 56
64299: PUSH
64300: LD_EXP 56
64304: PPUSH
64305: LD_VAR 0 2
64309: PPUSH
64310: EMPTY
64311: PPUSH
64312: CALL_OW 1
64316: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
64317: LD_VAR 0 2
64321: PPUSH
64322: LD_INT 102
64324: PPUSH
64325: CALL 58476 0 2
// continue ;
64329: GO 64258
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
64331: LD_ADDR_VAR 0 4
64335: PUSH
64336: LD_EXP 52
64340: PUSH
64341: LD_VAR 0 2
64345: ARRAY
64346: PPUSH
64347: LD_INT 25
64349: PUSH
64350: LD_INT 4
64352: PUSH
64353: EMPTY
64354: LIST
64355: LIST
64356: PPUSH
64357: CALL_OW 72
64361: ST_TO_ADDR
// if not tmp then
64362: LD_VAR 0 4
64366: NOT
64367: IFFALSE 64371
// continue ;
64369: GO 64258
// if mc_taming [ i ] then
64371: LD_EXP 83
64375: PUSH
64376: LD_VAR 0 2
64380: ARRAY
64381: IFFALSE 64405
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64383: LD_ADDR_EXP 83
64387: PUSH
64388: LD_EXP 83
64392: PPUSH
64393: LD_VAR 0 2
64397: PPUSH
64398: EMPTY
64399: PPUSH
64400: CALL_OW 1
64404: ST_TO_ADDR
// for j in tmp do
64405: LD_ADDR_VAR 0 3
64409: PUSH
64410: LD_VAR 0 4
64414: PUSH
64415: FOR_IN
64416: IFFALSE 64639
// begin if IsInUnit ( j ) then
64418: LD_VAR 0 3
64422: PPUSH
64423: CALL_OW 310
64427: IFFALSE 64438
// ComExitBuilding ( j ) ;
64429: LD_VAR 0 3
64433: PPUSH
64434: CALL_OW 122
// if not j in mc_healers [ i ] then
64438: LD_VAR 0 3
64442: PUSH
64443: LD_EXP 56
64447: PUSH
64448: LD_VAR 0 2
64452: ARRAY
64453: IN
64454: NOT
64455: IFFALSE 64501
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
64457: LD_ADDR_EXP 56
64461: PUSH
64462: LD_EXP 56
64466: PPUSH
64467: LD_VAR 0 2
64471: PUSH
64472: LD_EXP 56
64476: PUSH
64477: LD_VAR 0 2
64481: ARRAY
64482: PUSH
64483: LD_INT 1
64485: PLUS
64486: PUSH
64487: EMPTY
64488: LIST
64489: LIST
64490: PPUSH
64491: LD_VAR 0 3
64495: PPUSH
64496: CALL 18419 0 3
64500: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
64501: LD_VAR 0 3
64505: PPUSH
64506: CALL_OW 110
64510: PUSH
64511: LD_INT 102
64513: NONEQUAL
64514: IFFALSE 64528
// SetTag ( j , 102 ) ;
64516: LD_VAR 0 3
64520: PPUSH
64521: LD_INT 102
64523: PPUSH
64524: CALL_OW 109
// Wait ( 3 ) ;
64528: LD_INT 3
64530: PPUSH
64531: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
64535: LD_EXP 55
64539: PUSH
64540: LD_VAR 0 2
64544: ARRAY
64545: PUSH
64546: LD_INT 1
64548: ARRAY
64549: IFFALSE 64581
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
64551: LD_VAR 0 3
64555: PPUSH
64556: LD_EXP 55
64560: PUSH
64561: LD_VAR 0 2
64565: ARRAY
64566: PUSH
64567: LD_INT 1
64569: ARRAY
64570: PUSH
64571: LD_INT 1
64573: ARRAY
64574: PPUSH
64575: CALL_OW 128
64579: GO 64637
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
64581: LD_VAR 0 3
64585: PPUSH
64586: CALL_OW 314
64590: NOT
64591: PUSH
64592: LD_EXP 55
64596: PUSH
64597: LD_VAR 0 2
64601: ARRAY
64602: PUSH
64603: LD_INT 2
64605: ARRAY
64606: AND
64607: IFFALSE 64637
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
64609: LD_VAR 0 3
64613: PPUSH
64614: LD_EXP 55
64618: PUSH
64619: LD_VAR 0 2
64623: ARRAY
64624: PUSH
64625: LD_INT 2
64627: ARRAY
64628: PUSH
64629: LD_INT 1
64631: ARRAY
64632: PPUSH
64633: CALL_OW 128
// end ;
64637: GO 64415
64639: POP
64640: POP
// end ;
64641: GO 64258
64643: POP
64644: POP
// end ;
64645: LD_VAR 0 1
64649: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
64650: LD_INT 0
64652: PPUSH
64653: PPUSH
64654: PPUSH
64655: PPUSH
64656: PPUSH
// if not mc_bases then
64657: LD_EXP 52
64661: NOT
64662: IFFALSE 64666
// exit ;
64664: GO 65809
// for i = 1 to mc_bases do
64666: LD_ADDR_VAR 0 2
64670: PUSH
64671: DOUBLE
64672: LD_INT 1
64674: DEC
64675: ST_TO_ADDR
64676: LD_EXP 52
64680: PUSH
64681: FOR_TO
64682: IFFALSE 65807
// begin if mc_scan [ i ] then
64684: LD_EXP 75
64688: PUSH
64689: LD_VAR 0 2
64693: ARRAY
64694: IFFALSE 64698
// continue ;
64696: GO 64681
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
64698: LD_EXP 57
64702: PUSH
64703: LD_VAR 0 2
64707: ARRAY
64708: NOT
64709: PUSH
64710: LD_EXP 59
64714: PUSH
64715: LD_VAR 0 2
64719: ARRAY
64720: NOT
64721: AND
64722: PUSH
64723: LD_EXP 58
64727: PUSH
64728: LD_VAR 0 2
64732: ARRAY
64733: AND
64734: IFFALSE 64772
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
64736: LD_ADDR_EXP 58
64740: PUSH
64741: LD_EXP 58
64745: PPUSH
64746: LD_VAR 0 2
64750: PPUSH
64751: EMPTY
64752: PPUSH
64753: CALL_OW 1
64757: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64758: LD_VAR 0 2
64762: PPUSH
64763: LD_INT 103
64765: PPUSH
64766: CALL 58476 0 2
// continue ;
64770: GO 64681
// end ; if mc_construct_list [ i ] then
64772: LD_EXP 59
64776: PUSH
64777: LD_VAR 0 2
64781: ARRAY
64782: IFFALSE 65002
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64784: LD_ADDR_VAR 0 4
64788: PUSH
64789: LD_EXP 52
64793: PUSH
64794: LD_VAR 0 2
64798: ARRAY
64799: PPUSH
64800: LD_INT 25
64802: PUSH
64803: LD_INT 2
64805: PUSH
64806: EMPTY
64807: LIST
64808: LIST
64809: PPUSH
64810: CALL_OW 72
64814: PUSH
64815: LD_EXP 54
64819: PUSH
64820: LD_VAR 0 2
64824: ARRAY
64825: DIFF
64826: ST_TO_ADDR
// if not tmp then
64827: LD_VAR 0 4
64831: NOT
64832: IFFALSE 64836
// continue ;
64834: GO 64681
// for j in tmp do
64836: LD_ADDR_VAR 0 3
64840: PUSH
64841: LD_VAR 0 4
64845: PUSH
64846: FOR_IN
64847: IFFALSE 64998
// begin if not mc_builders [ i ] then
64849: LD_EXP 58
64853: PUSH
64854: LD_VAR 0 2
64858: ARRAY
64859: NOT
64860: IFFALSE 64918
// begin SetTag ( j , 103 ) ;
64862: LD_VAR 0 3
64866: PPUSH
64867: LD_INT 103
64869: PPUSH
64870: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64874: LD_ADDR_EXP 58
64878: PUSH
64879: LD_EXP 58
64883: PPUSH
64884: LD_VAR 0 2
64888: PUSH
64889: LD_EXP 58
64893: PUSH
64894: LD_VAR 0 2
64898: ARRAY
64899: PUSH
64900: LD_INT 1
64902: PLUS
64903: PUSH
64904: EMPTY
64905: LIST
64906: LIST
64907: PPUSH
64908: LD_VAR 0 3
64912: PPUSH
64913: CALL 18419 0 3
64917: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64918: LD_VAR 0 3
64922: PPUSH
64923: CALL_OW 310
64927: IFFALSE 64938
// ComExitBuilding ( j ) ;
64929: LD_VAR 0 3
64933: PPUSH
64934: CALL_OW 122
// wait ( 3 ) ;
64938: LD_INT 3
64940: PPUSH
64941: CALL_OW 67
// if not mc_construct_list [ i ] then
64945: LD_EXP 59
64949: PUSH
64950: LD_VAR 0 2
64954: ARRAY
64955: NOT
64956: IFFALSE 64960
// break ;
64958: GO 64998
// if not HasTask ( j ) then
64960: LD_VAR 0 3
64964: PPUSH
64965: CALL_OW 314
64969: NOT
64970: IFFALSE 64996
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
64972: LD_VAR 0 3
64976: PPUSH
64977: LD_EXP 59
64981: PUSH
64982: LD_VAR 0 2
64986: ARRAY
64987: PUSH
64988: LD_INT 1
64990: ARRAY
64991: PPUSH
64992: CALL 21270 0 2
// end ;
64996: GO 64846
64998: POP
64999: POP
// end else
65000: GO 65805
// if mc_build_list [ i ] then
65002: LD_EXP 57
65006: PUSH
65007: LD_VAR 0 2
65011: ARRAY
65012: IFFALSE 65805
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65014: LD_ADDR_VAR 0 5
65018: PUSH
65019: LD_EXP 52
65023: PUSH
65024: LD_VAR 0 2
65028: ARRAY
65029: PPUSH
65030: LD_INT 2
65032: PUSH
65033: LD_INT 30
65035: PUSH
65036: LD_INT 0
65038: PUSH
65039: EMPTY
65040: LIST
65041: LIST
65042: PUSH
65043: LD_INT 30
65045: PUSH
65046: LD_INT 1
65048: PUSH
65049: EMPTY
65050: LIST
65051: LIST
65052: PUSH
65053: EMPTY
65054: LIST
65055: LIST
65056: LIST
65057: PPUSH
65058: CALL_OW 72
65062: ST_TO_ADDR
// if depot then
65063: LD_VAR 0 5
65067: IFFALSE 65085
// depot := depot [ 1 ] else
65069: LD_ADDR_VAR 0 5
65073: PUSH
65074: LD_VAR 0 5
65078: PUSH
65079: LD_INT 1
65081: ARRAY
65082: ST_TO_ADDR
65083: GO 65093
// depot := 0 ;
65085: LD_ADDR_VAR 0 5
65089: PUSH
65090: LD_INT 0
65092: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
65093: LD_EXP 57
65097: PUSH
65098: LD_VAR 0 2
65102: ARRAY
65103: PUSH
65104: LD_INT 1
65106: ARRAY
65107: PUSH
65108: LD_INT 1
65110: ARRAY
65111: PPUSH
65112: CALL 21100 0 1
65116: PUSH
65117: LD_EXP 52
65121: PUSH
65122: LD_VAR 0 2
65126: ARRAY
65127: PPUSH
65128: LD_INT 2
65130: PUSH
65131: LD_INT 30
65133: PUSH
65134: LD_INT 2
65136: PUSH
65137: EMPTY
65138: LIST
65139: LIST
65140: PUSH
65141: LD_INT 30
65143: PUSH
65144: LD_INT 3
65146: PUSH
65147: EMPTY
65148: LIST
65149: LIST
65150: PUSH
65151: EMPTY
65152: LIST
65153: LIST
65154: LIST
65155: PPUSH
65156: CALL_OW 72
65160: NOT
65161: AND
65162: IFFALSE 65267
// begin for j = 1 to mc_build_list [ i ] do
65164: LD_ADDR_VAR 0 3
65168: PUSH
65169: DOUBLE
65170: LD_INT 1
65172: DEC
65173: ST_TO_ADDR
65174: LD_EXP 57
65178: PUSH
65179: LD_VAR 0 2
65183: ARRAY
65184: PUSH
65185: FOR_TO
65186: IFFALSE 65265
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
65188: LD_EXP 57
65192: PUSH
65193: LD_VAR 0 2
65197: ARRAY
65198: PUSH
65199: LD_VAR 0 3
65203: ARRAY
65204: PUSH
65205: LD_INT 1
65207: ARRAY
65208: PUSH
65209: LD_INT 2
65211: EQUAL
65212: IFFALSE 65263
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
65214: LD_ADDR_EXP 57
65218: PUSH
65219: LD_EXP 57
65223: PPUSH
65224: LD_VAR 0 2
65228: PPUSH
65229: LD_EXP 57
65233: PUSH
65234: LD_VAR 0 2
65238: ARRAY
65239: PPUSH
65240: LD_VAR 0 3
65244: PPUSH
65245: LD_INT 1
65247: PPUSH
65248: LD_INT 0
65250: PPUSH
65251: CALL 17837 0 4
65255: PPUSH
65256: CALL_OW 1
65260: ST_TO_ADDR
// break ;
65261: GO 65265
// end ;
65263: GO 65185
65265: POP
65266: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
65267: LD_EXP 57
65271: PUSH
65272: LD_VAR 0 2
65276: ARRAY
65277: PUSH
65278: LD_INT 1
65280: ARRAY
65281: PUSH
65282: LD_INT 1
65284: ARRAY
65285: PUSH
65286: LD_INT 0
65288: EQUAL
65289: PUSH
65290: LD_VAR 0 5
65294: PUSH
65295: LD_VAR 0 5
65299: PPUSH
65300: LD_EXP 57
65304: PUSH
65305: LD_VAR 0 2
65309: ARRAY
65310: PUSH
65311: LD_INT 1
65313: ARRAY
65314: PUSH
65315: LD_INT 1
65317: ARRAY
65318: PPUSH
65319: LD_EXP 57
65323: PUSH
65324: LD_VAR 0 2
65328: ARRAY
65329: PUSH
65330: LD_INT 1
65332: ARRAY
65333: PUSH
65334: LD_INT 2
65336: ARRAY
65337: PPUSH
65338: LD_EXP 57
65342: PUSH
65343: LD_VAR 0 2
65347: ARRAY
65348: PUSH
65349: LD_INT 1
65351: ARRAY
65352: PUSH
65353: LD_INT 3
65355: ARRAY
65356: PPUSH
65357: LD_EXP 57
65361: PUSH
65362: LD_VAR 0 2
65366: ARRAY
65367: PUSH
65368: LD_INT 1
65370: ARRAY
65371: PUSH
65372: LD_INT 4
65374: ARRAY
65375: PPUSH
65376: CALL 25834 0 5
65380: AND
65381: OR
65382: IFFALSE 65663
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65384: LD_ADDR_VAR 0 4
65388: PUSH
65389: LD_EXP 52
65393: PUSH
65394: LD_VAR 0 2
65398: ARRAY
65399: PPUSH
65400: LD_INT 25
65402: PUSH
65403: LD_INT 2
65405: PUSH
65406: EMPTY
65407: LIST
65408: LIST
65409: PPUSH
65410: CALL_OW 72
65414: PUSH
65415: LD_EXP 54
65419: PUSH
65420: LD_VAR 0 2
65424: ARRAY
65425: DIFF
65426: ST_TO_ADDR
// if not tmp then
65427: LD_VAR 0 4
65431: NOT
65432: IFFALSE 65436
// continue ;
65434: GO 64681
// for j in tmp do
65436: LD_ADDR_VAR 0 3
65440: PUSH
65441: LD_VAR 0 4
65445: PUSH
65446: FOR_IN
65447: IFFALSE 65659
// begin if not mc_builders [ i ] then
65449: LD_EXP 58
65453: PUSH
65454: LD_VAR 0 2
65458: ARRAY
65459: NOT
65460: IFFALSE 65518
// begin SetTag ( j , 103 ) ;
65462: LD_VAR 0 3
65466: PPUSH
65467: LD_INT 103
65469: PPUSH
65470: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65474: LD_ADDR_EXP 58
65478: PUSH
65479: LD_EXP 58
65483: PPUSH
65484: LD_VAR 0 2
65488: PUSH
65489: LD_EXP 58
65493: PUSH
65494: LD_VAR 0 2
65498: ARRAY
65499: PUSH
65500: LD_INT 1
65502: PLUS
65503: PUSH
65504: EMPTY
65505: LIST
65506: LIST
65507: PPUSH
65508: LD_VAR 0 3
65512: PPUSH
65513: CALL 18419 0 3
65517: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65518: LD_VAR 0 3
65522: PPUSH
65523: CALL_OW 310
65527: IFFALSE 65538
// ComExitBuilding ( j ) ;
65529: LD_VAR 0 3
65533: PPUSH
65534: CALL_OW 122
// wait ( 3 ) ;
65538: LD_INT 3
65540: PPUSH
65541: CALL_OW 67
// if not mc_build_list [ i ] then
65545: LD_EXP 57
65549: PUSH
65550: LD_VAR 0 2
65554: ARRAY
65555: NOT
65556: IFFALSE 65560
// break ;
65558: GO 65659
// if not HasTask ( j ) then
65560: LD_VAR 0 3
65564: PPUSH
65565: CALL_OW 314
65569: NOT
65570: IFFALSE 65657
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
65572: LD_VAR 0 3
65576: PPUSH
65577: LD_EXP 57
65581: PUSH
65582: LD_VAR 0 2
65586: ARRAY
65587: PUSH
65588: LD_INT 1
65590: ARRAY
65591: PUSH
65592: LD_INT 1
65594: ARRAY
65595: PPUSH
65596: LD_EXP 57
65600: PUSH
65601: LD_VAR 0 2
65605: ARRAY
65606: PUSH
65607: LD_INT 1
65609: ARRAY
65610: PUSH
65611: LD_INT 2
65613: ARRAY
65614: PPUSH
65615: LD_EXP 57
65619: PUSH
65620: LD_VAR 0 2
65624: ARRAY
65625: PUSH
65626: LD_INT 1
65628: ARRAY
65629: PUSH
65630: LD_INT 3
65632: ARRAY
65633: PPUSH
65634: LD_EXP 57
65638: PUSH
65639: LD_VAR 0 2
65643: ARRAY
65644: PUSH
65645: LD_INT 1
65647: ARRAY
65648: PUSH
65649: LD_INT 4
65651: ARRAY
65652: PPUSH
65653: CALL_OW 145
// end ;
65657: GO 65446
65659: POP
65660: POP
// end else
65661: GO 65805
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
65663: LD_EXP 52
65667: PUSH
65668: LD_VAR 0 2
65672: ARRAY
65673: PPUSH
65674: LD_EXP 57
65678: PUSH
65679: LD_VAR 0 2
65683: ARRAY
65684: PUSH
65685: LD_INT 1
65687: ARRAY
65688: PUSH
65689: LD_INT 1
65691: ARRAY
65692: PPUSH
65693: LD_EXP 57
65697: PUSH
65698: LD_VAR 0 2
65702: ARRAY
65703: PUSH
65704: LD_INT 1
65706: ARRAY
65707: PUSH
65708: LD_INT 2
65710: ARRAY
65711: PPUSH
65712: LD_EXP 57
65716: PUSH
65717: LD_VAR 0 2
65721: ARRAY
65722: PUSH
65723: LD_INT 1
65725: ARRAY
65726: PUSH
65727: LD_INT 3
65729: ARRAY
65730: PPUSH
65731: LD_EXP 57
65735: PUSH
65736: LD_VAR 0 2
65740: ARRAY
65741: PUSH
65742: LD_INT 1
65744: ARRAY
65745: PUSH
65746: LD_INT 4
65748: ARRAY
65749: PPUSH
65750: CALL 25170 0 5
65754: NOT
65755: IFFALSE 65805
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
65757: LD_ADDR_EXP 57
65761: PUSH
65762: LD_EXP 57
65766: PPUSH
65767: LD_VAR 0 2
65771: PPUSH
65772: LD_EXP 57
65776: PUSH
65777: LD_VAR 0 2
65781: ARRAY
65782: PPUSH
65783: LD_INT 1
65785: PPUSH
65786: LD_INT 1
65788: NEG
65789: PPUSH
65790: LD_INT 0
65792: PPUSH
65793: CALL 17837 0 4
65797: PPUSH
65798: CALL_OW 1
65802: ST_TO_ADDR
// continue ;
65803: GO 64681
// end ; end ; end ;
65805: GO 64681
65807: POP
65808: POP
// end ;
65809: LD_VAR 0 1
65813: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
65814: LD_INT 0
65816: PPUSH
65817: PPUSH
65818: PPUSH
65819: PPUSH
65820: PPUSH
65821: PPUSH
// if not mc_bases then
65822: LD_EXP 52
65826: NOT
65827: IFFALSE 65831
// exit ;
65829: GO 66258
// for i = 1 to mc_bases do
65831: LD_ADDR_VAR 0 2
65835: PUSH
65836: DOUBLE
65837: LD_INT 1
65839: DEC
65840: ST_TO_ADDR
65841: LD_EXP 52
65845: PUSH
65846: FOR_TO
65847: IFFALSE 66256
// begin tmp := mc_build_upgrade [ i ] ;
65849: LD_ADDR_VAR 0 4
65853: PUSH
65854: LD_EXP 84
65858: PUSH
65859: LD_VAR 0 2
65863: ARRAY
65864: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
65865: LD_ADDR_VAR 0 6
65869: PUSH
65870: LD_EXP 85
65874: PUSH
65875: LD_VAR 0 2
65879: ARRAY
65880: PPUSH
65881: LD_INT 2
65883: PUSH
65884: LD_INT 30
65886: PUSH
65887: LD_INT 6
65889: PUSH
65890: EMPTY
65891: LIST
65892: LIST
65893: PUSH
65894: LD_INT 30
65896: PUSH
65897: LD_INT 7
65899: PUSH
65900: EMPTY
65901: LIST
65902: LIST
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: LIST
65908: PPUSH
65909: CALL_OW 72
65913: ST_TO_ADDR
// if not tmp and not lab then
65914: LD_VAR 0 4
65918: NOT
65919: PUSH
65920: LD_VAR 0 6
65924: NOT
65925: AND
65926: IFFALSE 65930
// continue ;
65928: GO 65846
// if tmp then
65930: LD_VAR 0 4
65934: IFFALSE 66054
// for j in tmp do
65936: LD_ADDR_VAR 0 3
65940: PUSH
65941: LD_VAR 0 4
65945: PUSH
65946: FOR_IN
65947: IFFALSE 66052
// begin if UpgradeCost ( j ) then
65949: LD_VAR 0 3
65953: PPUSH
65954: CALL 24830 0 1
65958: IFFALSE 66050
// begin ComUpgrade ( j ) ;
65960: LD_VAR 0 3
65964: PPUSH
65965: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
65969: LD_ADDR_EXP 84
65973: PUSH
65974: LD_EXP 84
65978: PPUSH
65979: LD_VAR 0 2
65983: PPUSH
65984: LD_EXP 84
65988: PUSH
65989: LD_VAR 0 2
65993: ARRAY
65994: PUSH
65995: LD_VAR 0 3
65999: DIFF
66000: PPUSH
66001: CALL_OW 1
66005: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66006: LD_ADDR_EXP 59
66010: PUSH
66011: LD_EXP 59
66015: PPUSH
66016: LD_VAR 0 2
66020: PUSH
66021: LD_EXP 59
66025: PUSH
66026: LD_VAR 0 2
66030: ARRAY
66031: PUSH
66032: LD_INT 1
66034: PLUS
66035: PUSH
66036: EMPTY
66037: LIST
66038: LIST
66039: PPUSH
66040: LD_VAR 0 3
66044: PPUSH
66045: CALL 18419 0 3
66049: ST_TO_ADDR
// end ; end ;
66050: GO 65946
66052: POP
66053: POP
// if not lab or not mc_lab_upgrade [ i ] then
66054: LD_VAR 0 6
66058: NOT
66059: PUSH
66060: LD_EXP 86
66064: PUSH
66065: LD_VAR 0 2
66069: ARRAY
66070: NOT
66071: OR
66072: IFFALSE 66076
// continue ;
66074: GO 65846
// for j in lab do
66076: LD_ADDR_VAR 0 3
66080: PUSH
66081: LD_VAR 0 6
66085: PUSH
66086: FOR_IN
66087: IFFALSE 66252
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
66089: LD_VAR 0 3
66093: PPUSH
66094: CALL_OW 266
66098: PUSH
66099: LD_INT 6
66101: PUSH
66102: LD_INT 7
66104: PUSH
66105: EMPTY
66106: LIST
66107: LIST
66108: IN
66109: PUSH
66110: LD_VAR 0 3
66114: PPUSH
66115: CALL_OW 461
66119: PUSH
66120: LD_INT 1
66122: NONEQUAL
66123: AND
66124: IFFALSE 66250
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
66126: LD_VAR 0 3
66130: PPUSH
66131: LD_EXP 86
66135: PUSH
66136: LD_VAR 0 2
66140: ARRAY
66141: PUSH
66142: LD_INT 1
66144: ARRAY
66145: PPUSH
66146: CALL 25035 0 2
66150: IFFALSE 66250
// begin ComCancel ( j ) ;
66152: LD_VAR 0 3
66156: PPUSH
66157: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
66161: LD_VAR 0 3
66165: PPUSH
66166: LD_EXP 86
66170: PUSH
66171: LD_VAR 0 2
66175: ARRAY
66176: PUSH
66177: LD_INT 1
66179: ARRAY
66180: PPUSH
66181: CALL_OW 207
// if not j in mc_construct_list [ i ] then
66185: LD_VAR 0 3
66189: PUSH
66190: LD_EXP 59
66194: PUSH
66195: LD_VAR 0 2
66199: ARRAY
66200: IN
66201: NOT
66202: IFFALSE 66248
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66204: LD_ADDR_EXP 59
66208: PUSH
66209: LD_EXP 59
66213: PPUSH
66214: LD_VAR 0 2
66218: PUSH
66219: LD_EXP 59
66223: PUSH
66224: LD_VAR 0 2
66228: ARRAY
66229: PUSH
66230: LD_INT 1
66232: PLUS
66233: PUSH
66234: EMPTY
66235: LIST
66236: LIST
66237: PPUSH
66238: LD_VAR 0 3
66242: PPUSH
66243: CALL 18419 0 3
66247: ST_TO_ADDR
// break ;
66248: GO 66252
// end ; end ; end ;
66250: GO 66086
66252: POP
66253: POP
// end ;
66254: GO 65846
66256: POP
66257: POP
// end ;
66258: LD_VAR 0 1
66262: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
66263: LD_INT 0
66265: PPUSH
66266: PPUSH
66267: PPUSH
66268: PPUSH
66269: PPUSH
66270: PPUSH
66271: PPUSH
66272: PPUSH
66273: PPUSH
// if not mc_bases then
66274: LD_EXP 52
66278: NOT
66279: IFFALSE 66283
// exit ;
66281: GO 66688
// for i = 1 to mc_bases do
66283: LD_ADDR_VAR 0 2
66287: PUSH
66288: DOUBLE
66289: LD_INT 1
66291: DEC
66292: ST_TO_ADDR
66293: LD_EXP 52
66297: PUSH
66298: FOR_TO
66299: IFFALSE 66686
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
66301: LD_EXP 60
66305: PUSH
66306: LD_VAR 0 2
66310: ARRAY
66311: NOT
66312: PUSH
66313: LD_EXP 52
66317: PUSH
66318: LD_VAR 0 2
66322: ARRAY
66323: PPUSH
66324: LD_INT 30
66326: PUSH
66327: LD_INT 3
66329: PUSH
66330: EMPTY
66331: LIST
66332: LIST
66333: PPUSH
66334: CALL_OW 72
66338: NOT
66339: OR
66340: IFFALSE 66344
// continue ;
66342: GO 66298
// busy := false ;
66344: LD_ADDR_VAR 0 8
66348: PUSH
66349: LD_INT 0
66351: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66352: LD_ADDR_VAR 0 4
66356: PUSH
66357: LD_EXP 52
66361: PUSH
66362: LD_VAR 0 2
66366: ARRAY
66367: PPUSH
66368: LD_INT 30
66370: PUSH
66371: LD_INT 3
66373: PUSH
66374: EMPTY
66375: LIST
66376: LIST
66377: PPUSH
66378: CALL_OW 72
66382: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66383: LD_ADDR_VAR 0 6
66387: PUSH
66388: LD_EXP 60
66392: PUSH
66393: LD_VAR 0 2
66397: ARRAY
66398: PPUSH
66399: LD_INT 2
66401: PUSH
66402: LD_INT 30
66404: PUSH
66405: LD_INT 32
66407: PUSH
66408: EMPTY
66409: LIST
66410: LIST
66411: PUSH
66412: LD_INT 30
66414: PUSH
66415: LD_INT 33
66417: PUSH
66418: EMPTY
66419: LIST
66420: LIST
66421: PUSH
66422: EMPTY
66423: LIST
66424: LIST
66425: LIST
66426: PPUSH
66427: CALL_OW 72
66431: ST_TO_ADDR
// if not t then
66432: LD_VAR 0 6
66436: NOT
66437: IFFALSE 66441
// continue ;
66439: GO 66298
// for j in tmp do
66441: LD_ADDR_VAR 0 3
66445: PUSH
66446: LD_VAR 0 4
66450: PUSH
66451: FOR_IN
66452: IFFALSE 66482
// if not BuildingStatus ( j ) = bs_idle then
66454: LD_VAR 0 3
66458: PPUSH
66459: CALL_OW 461
66463: PUSH
66464: LD_INT 2
66466: EQUAL
66467: NOT
66468: IFFALSE 66480
// begin busy := true ;
66470: LD_ADDR_VAR 0 8
66474: PUSH
66475: LD_INT 1
66477: ST_TO_ADDR
// break ;
66478: GO 66482
// end ;
66480: GO 66451
66482: POP
66483: POP
// if busy then
66484: LD_VAR 0 8
66488: IFFALSE 66492
// continue ;
66490: GO 66298
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
66492: LD_ADDR_VAR 0 7
66496: PUSH
66497: LD_VAR 0 6
66501: PPUSH
66502: LD_INT 35
66504: PUSH
66505: LD_INT 0
66507: PUSH
66508: EMPTY
66509: LIST
66510: LIST
66511: PPUSH
66512: CALL_OW 72
66516: ST_TO_ADDR
// if tw then
66517: LD_VAR 0 7
66521: IFFALSE 66598
// begin tw := tw [ 1 ] ;
66523: LD_ADDR_VAR 0 7
66527: PUSH
66528: LD_VAR 0 7
66532: PUSH
66533: LD_INT 1
66535: ARRAY
66536: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
66537: LD_ADDR_VAR 0 9
66541: PUSH
66542: LD_VAR 0 7
66546: PPUSH
66547: LD_EXP 77
66551: PUSH
66552: LD_VAR 0 2
66556: ARRAY
66557: PPUSH
66558: CALL 23389 0 2
66562: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
66563: LD_EXP 91
66567: PUSH
66568: LD_VAR 0 2
66572: ARRAY
66573: IFFALSE 66596
// if not weapon in mc_allowed_tower_weapons [ i ] then
66575: LD_VAR 0 9
66579: PUSH
66580: LD_EXP 91
66584: PUSH
66585: LD_VAR 0 2
66589: ARRAY
66590: IN
66591: NOT
66592: IFFALSE 66596
// continue ;
66594: GO 66298
// end else
66596: GO 66661
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
66598: LD_ADDR_VAR 0 5
66602: PUSH
66603: LD_EXP 60
66607: PUSH
66608: LD_VAR 0 2
66612: ARRAY
66613: PPUSH
66614: LD_VAR 0 4
66618: PPUSH
66619: CALL 53600 0 2
66623: ST_TO_ADDR
// if not tmp2 then
66624: LD_VAR 0 5
66628: NOT
66629: IFFALSE 66633
// continue ;
66631: GO 66298
// tw := tmp2 [ 1 ] ;
66633: LD_ADDR_VAR 0 7
66637: PUSH
66638: LD_VAR 0 5
66642: PUSH
66643: LD_INT 1
66645: ARRAY
66646: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
66647: LD_ADDR_VAR 0 9
66651: PUSH
66652: LD_VAR 0 5
66656: PUSH
66657: LD_INT 2
66659: ARRAY
66660: ST_TO_ADDR
// end ; if not weapon then
66661: LD_VAR 0 9
66665: NOT
66666: IFFALSE 66670
// continue ;
66668: GO 66298
// ComPlaceWeapon ( tw , weapon ) ;
66670: LD_VAR 0 7
66674: PPUSH
66675: LD_VAR 0 9
66679: PPUSH
66680: CALL_OW 148
// end ;
66684: GO 66298
66686: POP
66687: POP
// end ;
66688: LD_VAR 0 1
66692: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
66693: LD_INT 0
66695: PPUSH
66696: PPUSH
66697: PPUSH
66698: PPUSH
66699: PPUSH
66700: PPUSH
// if not mc_bases then
66701: LD_EXP 52
66705: NOT
66706: IFFALSE 66710
// exit ;
66708: GO 67486
// for i = 1 to mc_bases do
66710: LD_ADDR_VAR 0 2
66714: PUSH
66715: DOUBLE
66716: LD_INT 1
66718: DEC
66719: ST_TO_ADDR
66720: LD_EXP 52
66724: PUSH
66725: FOR_TO
66726: IFFALSE 67484
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
66728: LD_EXP 65
66732: PUSH
66733: LD_VAR 0 2
66737: ARRAY
66738: NOT
66739: PUSH
66740: LD_EXP 65
66744: PUSH
66745: LD_VAR 0 2
66749: ARRAY
66750: PUSH
66751: LD_EXP 66
66755: PUSH
66756: LD_VAR 0 2
66760: ARRAY
66761: EQUAL
66762: OR
66763: PUSH
66764: LD_EXP 75
66768: PUSH
66769: LD_VAR 0 2
66773: ARRAY
66774: OR
66775: IFFALSE 66779
// continue ;
66777: GO 66725
// if mc_miners [ i ] then
66779: LD_EXP 66
66783: PUSH
66784: LD_VAR 0 2
66788: ARRAY
66789: IFFALSE 67171
// begin for j = mc_miners [ i ] downto 1 do
66791: LD_ADDR_VAR 0 3
66795: PUSH
66796: DOUBLE
66797: LD_EXP 66
66801: PUSH
66802: LD_VAR 0 2
66806: ARRAY
66807: INC
66808: ST_TO_ADDR
66809: LD_INT 1
66811: PUSH
66812: FOR_DOWNTO
66813: IFFALSE 67169
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
66815: LD_EXP 66
66819: PUSH
66820: LD_VAR 0 2
66824: ARRAY
66825: PUSH
66826: LD_VAR 0 3
66830: ARRAY
66831: PPUSH
66832: CALL_OW 301
66836: PUSH
66837: LD_EXP 66
66841: PUSH
66842: LD_VAR 0 2
66846: ARRAY
66847: PUSH
66848: LD_VAR 0 3
66852: ARRAY
66853: PPUSH
66854: CALL_OW 257
66858: PUSH
66859: LD_INT 1
66861: NONEQUAL
66862: OR
66863: IFFALSE 66926
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
66865: LD_ADDR_VAR 0 5
66869: PUSH
66870: LD_EXP 66
66874: PUSH
66875: LD_VAR 0 2
66879: ARRAY
66880: PUSH
66881: LD_EXP 66
66885: PUSH
66886: LD_VAR 0 2
66890: ARRAY
66891: PUSH
66892: LD_VAR 0 3
66896: ARRAY
66897: DIFF
66898: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
66899: LD_ADDR_EXP 66
66903: PUSH
66904: LD_EXP 66
66908: PPUSH
66909: LD_VAR 0 2
66913: PPUSH
66914: LD_VAR 0 5
66918: PPUSH
66919: CALL_OW 1
66923: ST_TO_ADDR
// continue ;
66924: GO 66812
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
66926: LD_EXP 66
66930: PUSH
66931: LD_VAR 0 2
66935: ARRAY
66936: PUSH
66937: LD_VAR 0 3
66941: ARRAY
66942: PPUSH
66943: CALL_OW 257
66947: PUSH
66948: LD_INT 1
66950: EQUAL
66951: PUSH
66952: LD_EXP 66
66956: PUSH
66957: LD_VAR 0 2
66961: ARRAY
66962: PUSH
66963: LD_VAR 0 3
66967: ARRAY
66968: PPUSH
66969: CALL_OW 459
66973: NOT
66974: AND
66975: PUSH
66976: LD_EXP 66
66980: PUSH
66981: LD_VAR 0 2
66985: ARRAY
66986: PUSH
66987: LD_VAR 0 3
66991: ARRAY
66992: PPUSH
66993: CALL_OW 314
66997: NOT
66998: AND
66999: IFFALSE 67167
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67001: LD_EXP 66
67005: PUSH
67006: LD_VAR 0 2
67010: ARRAY
67011: PUSH
67012: LD_VAR 0 3
67016: ARRAY
67017: PPUSH
67018: CALL_OW 310
67022: IFFALSE 67045
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67024: LD_EXP 66
67028: PUSH
67029: LD_VAR 0 2
67033: ARRAY
67034: PUSH
67035: LD_VAR 0 3
67039: ARRAY
67040: PPUSH
67041: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67045: LD_EXP 66
67049: PUSH
67050: LD_VAR 0 2
67054: ARRAY
67055: PUSH
67056: LD_VAR 0 3
67060: ARRAY
67061: PPUSH
67062: CALL_OW 314
67066: NOT
67067: IFFALSE 67167
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
67069: LD_EXP 66
67073: PUSH
67074: LD_VAR 0 2
67078: ARRAY
67079: PUSH
67080: LD_VAR 0 3
67084: ARRAY
67085: PPUSH
67086: LD_EXP 65
67090: PUSH
67091: LD_VAR 0 2
67095: ARRAY
67096: PUSH
67097: LD_VAR 0 3
67101: PUSH
67102: LD_EXP 65
67106: PUSH
67107: LD_VAR 0 2
67111: ARRAY
67112: MOD
67113: PUSH
67114: LD_INT 1
67116: PLUS
67117: ARRAY
67118: PUSH
67119: LD_INT 1
67121: ARRAY
67122: PPUSH
67123: LD_EXP 65
67127: PUSH
67128: LD_VAR 0 2
67132: ARRAY
67133: PUSH
67134: LD_VAR 0 3
67138: PUSH
67139: LD_EXP 65
67143: PUSH
67144: LD_VAR 0 2
67148: ARRAY
67149: MOD
67150: PUSH
67151: LD_INT 1
67153: PLUS
67154: ARRAY
67155: PUSH
67156: LD_INT 2
67158: ARRAY
67159: PPUSH
67160: LD_INT 0
67162: PPUSH
67163: CALL_OW 193
// end ; end ;
67167: GO 66812
67169: POP
67170: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67171: LD_ADDR_VAR 0 5
67175: PUSH
67176: LD_EXP 52
67180: PUSH
67181: LD_VAR 0 2
67185: ARRAY
67186: PPUSH
67187: LD_INT 2
67189: PUSH
67190: LD_INT 30
67192: PUSH
67193: LD_INT 4
67195: PUSH
67196: EMPTY
67197: LIST
67198: LIST
67199: PUSH
67200: LD_INT 30
67202: PUSH
67203: LD_INT 5
67205: PUSH
67206: EMPTY
67207: LIST
67208: LIST
67209: PUSH
67210: LD_INT 30
67212: PUSH
67213: LD_INT 32
67215: PUSH
67216: EMPTY
67217: LIST
67218: LIST
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: LIST
67224: LIST
67225: PPUSH
67226: CALL_OW 72
67230: ST_TO_ADDR
// if not tmp then
67231: LD_VAR 0 5
67235: NOT
67236: IFFALSE 67240
// continue ;
67238: GO 66725
// list := [ ] ;
67240: LD_ADDR_VAR 0 6
67244: PUSH
67245: EMPTY
67246: ST_TO_ADDR
// for j in tmp do
67247: LD_ADDR_VAR 0 3
67251: PUSH
67252: LD_VAR 0 5
67256: PUSH
67257: FOR_IN
67258: IFFALSE 67327
// begin for k in UnitsInside ( j ) do
67260: LD_ADDR_VAR 0 4
67264: PUSH
67265: LD_VAR 0 3
67269: PPUSH
67270: CALL_OW 313
67274: PUSH
67275: FOR_IN
67276: IFFALSE 67323
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
67278: LD_VAR 0 4
67282: PPUSH
67283: CALL_OW 257
67287: PUSH
67288: LD_INT 1
67290: EQUAL
67291: PUSH
67292: LD_VAR 0 4
67296: PPUSH
67297: CALL_OW 459
67301: NOT
67302: AND
67303: IFFALSE 67321
// list := list ^ k ;
67305: LD_ADDR_VAR 0 6
67309: PUSH
67310: LD_VAR 0 6
67314: PUSH
67315: LD_VAR 0 4
67319: ADD
67320: ST_TO_ADDR
67321: GO 67275
67323: POP
67324: POP
// end ;
67325: GO 67257
67327: POP
67328: POP
// list := list diff mc_miners [ i ] ;
67329: LD_ADDR_VAR 0 6
67333: PUSH
67334: LD_VAR 0 6
67338: PUSH
67339: LD_EXP 66
67343: PUSH
67344: LD_VAR 0 2
67348: ARRAY
67349: DIFF
67350: ST_TO_ADDR
// if not list then
67351: LD_VAR 0 6
67355: NOT
67356: IFFALSE 67360
// continue ;
67358: GO 66725
// k := mc_mines [ i ] - mc_miners [ i ] ;
67360: LD_ADDR_VAR 0 4
67364: PUSH
67365: LD_EXP 65
67369: PUSH
67370: LD_VAR 0 2
67374: ARRAY
67375: PUSH
67376: LD_EXP 66
67380: PUSH
67381: LD_VAR 0 2
67385: ARRAY
67386: MINUS
67387: ST_TO_ADDR
// if k > list then
67388: LD_VAR 0 4
67392: PUSH
67393: LD_VAR 0 6
67397: GREATER
67398: IFFALSE 67410
// k := list ;
67400: LD_ADDR_VAR 0 4
67404: PUSH
67405: LD_VAR 0 6
67409: ST_TO_ADDR
// for j = 1 to k do
67410: LD_ADDR_VAR 0 3
67414: PUSH
67415: DOUBLE
67416: LD_INT 1
67418: DEC
67419: ST_TO_ADDR
67420: LD_VAR 0 4
67424: PUSH
67425: FOR_TO
67426: IFFALSE 67480
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
67428: LD_ADDR_EXP 66
67432: PUSH
67433: LD_EXP 66
67437: PPUSH
67438: LD_VAR 0 2
67442: PUSH
67443: LD_EXP 66
67447: PUSH
67448: LD_VAR 0 2
67452: ARRAY
67453: PUSH
67454: LD_INT 1
67456: PLUS
67457: PUSH
67458: EMPTY
67459: LIST
67460: LIST
67461: PPUSH
67462: LD_VAR 0 6
67466: PUSH
67467: LD_VAR 0 3
67471: ARRAY
67472: PPUSH
67473: CALL 18419 0 3
67477: ST_TO_ADDR
67478: GO 67425
67480: POP
67481: POP
// end ;
67482: GO 66725
67484: POP
67485: POP
// end ;
67486: LD_VAR 0 1
67490: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
67491: LD_INT 0
67493: PPUSH
67494: PPUSH
67495: PPUSH
67496: PPUSH
67497: PPUSH
67498: PPUSH
67499: PPUSH
67500: PPUSH
67501: PPUSH
67502: PPUSH
// if not mc_bases then
67503: LD_EXP 52
67507: NOT
67508: IFFALSE 67512
// exit ;
67510: GO 69262
// for i = 1 to mc_bases do
67512: LD_ADDR_VAR 0 2
67516: PUSH
67517: DOUBLE
67518: LD_INT 1
67520: DEC
67521: ST_TO_ADDR
67522: LD_EXP 52
67526: PUSH
67527: FOR_TO
67528: IFFALSE 69260
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
67530: LD_EXP 52
67534: PUSH
67535: LD_VAR 0 2
67539: ARRAY
67540: NOT
67541: PUSH
67542: LD_EXP 59
67546: PUSH
67547: LD_VAR 0 2
67551: ARRAY
67552: OR
67553: IFFALSE 67557
// continue ;
67555: GO 67527
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
67557: LD_EXP 68
67561: PUSH
67562: LD_VAR 0 2
67566: ARRAY
67567: NOT
67568: PUSH
67569: LD_EXP 69
67573: PUSH
67574: LD_VAR 0 2
67578: ARRAY
67579: AND
67580: IFFALSE 67618
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
67582: LD_ADDR_EXP 69
67586: PUSH
67587: LD_EXP 69
67591: PPUSH
67592: LD_VAR 0 2
67596: PPUSH
67597: EMPTY
67598: PPUSH
67599: CALL_OW 1
67603: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
67604: LD_VAR 0 2
67608: PPUSH
67609: LD_INT 107
67611: PPUSH
67612: CALL 58476 0 2
// continue ;
67616: GO 67527
// end ; target := [ ] ;
67618: LD_ADDR_VAR 0 6
67622: PUSH
67623: EMPTY
67624: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
67625: LD_ADDR_VAR 0 3
67629: PUSH
67630: DOUBLE
67631: LD_EXP 68
67635: PUSH
67636: LD_VAR 0 2
67640: ARRAY
67641: INC
67642: ST_TO_ADDR
67643: LD_INT 1
67645: PUSH
67646: FOR_DOWNTO
67647: IFFALSE 67907
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
67649: LD_EXP 68
67653: PUSH
67654: LD_VAR 0 2
67658: ARRAY
67659: PUSH
67660: LD_VAR 0 3
67664: ARRAY
67665: PUSH
67666: LD_INT 2
67668: ARRAY
67669: PPUSH
67670: LD_EXP 68
67674: PUSH
67675: LD_VAR 0 2
67679: ARRAY
67680: PUSH
67681: LD_VAR 0 3
67685: ARRAY
67686: PUSH
67687: LD_INT 3
67689: ARRAY
67690: PPUSH
67691: CALL_OW 488
67695: PUSH
67696: LD_EXP 68
67700: PUSH
67701: LD_VAR 0 2
67705: ARRAY
67706: PUSH
67707: LD_VAR 0 3
67711: ARRAY
67712: PUSH
67713: LD_INT 2
67715: ARRAY
67716: PPUSH
67717: LD_EXP 68
67721: PUSH
67722: LD_VAR 0 2
67726: ARRAY
67727: PUSH
67728: LD_VAR 0 3
67732: ARRAY
67733: PUSH
67734: LD_INT 3
67736: ARRAY
67737: PPUSH
67738: CALL_OW 284
67742: PUSH
67743: LD_INT 0
67745: EQUAL
67746: AND
67747: IFFALSE 67802
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
67749: LD_ADDR_VAR 0 5
67753: PUSH
67754: LD_EXP 68
67758: PUSH
67759: LD_VAR 0 2
67763: ARRAY
67764: PPUSH
67765: LD_VAR 0 3
67769: PPUSH
67770: CALL_OW 3
67774: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
67775: LD_ADDR_EXP 68
67779: PUSH
67780: LD_EXP 68
67784: PPUSH
67785: LD_VAR 0 2
67789: PPUSH
67790: LD_VAR 0 5
67794: PPUSH
67795: CALL_OW 1
67799: ST_TO_ADDR
// continue ;
67800: GO 67646
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
67802: LD_EXP 52
67806: PUSH
67807: LD_VAR 0 2
67811: ARRAY
67812: PUSH
67813: LD_INT 1
67815: ARRAY
67816: PPUSH
67817: CALL_OW 255
67821: PPUSH
67822: LD_EXP 68
67826: PUSH
67827: LD_VAR 0 2
67831: ARRAY
67832: PUSH
67833: LD_VAR 0 3
67837: ARRAY
67838: PUSH
67839: LD_INT 2
67841: ARRAY
67842: PPUSH
67843: LD_EXP 68
67847: PUSH
67848: LD_VAR 0 2
67852: ARRAY
67853: PUSH
67854: LD_VAR 0 3
67858: ARRAY
67859: PUSH
67860: LD_INT 3
67862: ARRAY
67863: PPUSH
67864: LD_INT 30
67866: PPUSH
67867: CALL 19315 0 4
67871: PUSH
67872: LD_INT 4
67874: ARRAY
67875: PUSH
67876: LD_INT 0
67878: EQUAL
67879: IFFALSE 67905
// begin target := mc_crates [ i ] [ j ] ;
67881: LD_ADDR_VAR 0 6
67885: PUSH
67886: LD_EXP 68
67890: PUSH
67891: LD_VAR 0 2
67895: ARRAY
67896: PUSH
67897: LD_VAR 0 3
67901: ARRAY
67902: ST_TO_ADDR
// break ;
67903: GO 67907
// end ; end ;
67905: GO 67646
67907: POP
67908: POP
// if not target then
67909: LD_VAR 0 6
67913: NOT
67914: IFFALSE 67918
// continue ;
67916: GO 67527
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
67918: LD_ADDR_VAR 0 7
67922: PUSH
67923: LD_EXP 71
67927: PUSH
67928: LD_VAR 0 2
67932: ARRAY
67933: PPUSH
67934: LD_INT 2
67936: PUSH
67937: LD_INT 3
67939: PUSH
67940: LD_INT 58
67942: PUSH
67943: EMPTY
67944: LIST
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: LD_INT 61
67952: PUSH
67953: EMPTY
67954: LIST
67955: PUSH
67956: LD_INT 33
67958: PUSH
67959: LD_INT 5
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: LD_INT 33
67968: PUSH
67969: LD_INT 3
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: PUSH
67976: EMPTY
67977: LIST
67978: LIST
67979: LIST
67980: LIST
67981: LIST
67982: PUSH
67983: LD_INT 2
67985: PUSH
67986: LD_INT 34
67988: PUSH
67989: LD_INT 32
67991: PUSH
67992: EMPTY
67993: LIST
67994: LIST
67995: PUSH
67996: LD_INT 34
67998: PUSH
67999: LD_INT 51
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: PUSH
68006: LD_INT 34
68008: PUSH
68009: LD_INT 12
68011: PUSH
68012: EMPTY
68013: LIST
68014: LIST
68015: PUSH
68016: EMPTY
68017: LIST
68018: LIST
68019: LIST
68020: LIST
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: PPUSH
68026: CALL_OW 72
68030: ST_TO_ADDR
// if not cargo then
68031: LD_VAR 0 7
68035: NOT
68036: IFFALSE 68679
// begin if mc_crates_collector [ i ] < 5 then
68038: LD_EXP 69
68042: PUSH
68043: LD_VAR 0 2
68047: ARRAY
68048: PUSH
68049: LD_INT 5
68051: LESS
68052: IFFALSE 68418
// begin if mc_ape [ i ] then
68054: LD_EXP 81
68058: PUSH
68059: LD_VAR 0 2
68063: ARRAY
68064: IFFALSE 68111
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68066: LD_ADDR_VAR 0 5
68070: PUSH
68071: LD_EXP 81
68075: PUSH
68076: LD_VAR 0 2
68080: ARRAY
68081: PPUSH
68082: LD_INT 25
68084: PUSH
68085: LD_INT 16
68087: PUSH
68088: EMPTY
68089: LIST
68090: LIST
68091: PUSH
68092: LD_INT 24
68094: PUSH
68095: LD_INT 750
68097: PUSH
68098: EMPTY
68099: LIST
68100: LIST
68101: PUSH
68102: EMPTY
68103: LIST
68104: LIST
68105: PPUSH
68106: CALL_OW 72
68110: ST_TO_ADDR
// if not tmp then
68111: LD_VAR 0 5
68115: NOT
68116: IFFALSE 68163
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68118: LD_ADDR_VAR 0 5
68122: PUSH
68123: LD_EXP 52
68127: PUSH
68128: LD_VAR 0 2
68132: ARRAY
68133: PPUSH
68134: LD_INT 25
68136: PUSH
68137: LD_INT 2
68139: PUSH
68140: EMPTY
68141: LIST
68142: LIST
68143: PUSH
68144: LD_INT 24
68146: PUSH
68147: LD_INT 750
68149: PUSH
68150: EMPTY
68151: LIST
68152: LIST
68153: PUSH
68154: EMPTY
68155: LIST
68156: LIST
68157: PPUSH
68158: CALL_OW 72
68162: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
68163: LD_EXP 81
68167: PUSH
68168: LD_VAR 0 2
68172: ARRAY
68173: PUSH
68174: LD_EXP 52
68178: PUSH
68179: LD_VAR 0 2
68183: ARRAY
68184: PPUSH
68185: LD_INT 25
68187: PUSH
68188: LD_INT 2
68190: PUSH
68191: EMPTY
68192: LIST
68193: LIST
68194: PUSH
68195: LD_INT 24
68197: PUSH
68198: LD_INT 750
68200: PUSH
68201: EMPTY
68202: LIST
68203: LIST
68204: PUSH
68205: EMPTY
68206: LIST
68207: LIST
68208: PPUSH
68209: CALL_OW 72
68213: AND
68214: PUSH
68215: LD_VAR 0 5
68219: PUSH
68220: LD_INT 5
68222: LESS
68223: AND
68224: IFFALSE 68306
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
68226: LD_ADDR_VAR 0 3
68230: PUSH
68231: LD_EXP 52
68235: PUSH
68236: LD_VAR 0 2
68240: ARRAY
68241: PPUSH
68242: LD_INT 25
68244: PUSH
68245: LD_INT 2
68247: PUSH
68248: EMPTY
68249: LIST
68250: LIST
68251: PUSH
68252: LD_INT 24
68254: PUSH
68255: LD_INT 750
68257: PUSH
68258: EMPTY
68259: LIST
68260: LIST
68261: PUSH
68262: EMPTY
68263: LIST
68264: LIST
68265: PPUSH
68266: CALL_OW 72
68270: PUSH
68271: FOR_IN
68272: IFFALSE 68304
// begin tmp := tmp union j ;
68274: LD_ADDR_VAR 0 5
68278: PUSH
68279: LD_VAR 0 5
68283: PUSH
68284: LD_VAR 0 3
68288: UNION
68289: ST_TO_ADDR
// if tmp >= 5 then
68290: LD_VAR 0 5
68294: PUSH
68295: LD_INT 5
68297: GREATEREQUAL
68298: IFFALSE 68302
// break ;
68300: GO 68304
// end ;
68302: GO 68271
68304: POP
68305: POP
// end ; if not tmp then
68306: LD_VAR 0 5
68310: NOT
68311: IFFALSE 68315
// continue ;
68313: GO 67527
// for j in tmp do
68315: LD_ADDR_VAR 0 3
68319: PUSH
68320: LD_VAR 0 5
68324: PUSH
68325: FOR_IN
68326: IFFALSE 68416
// if not GetTag ( j ) then
68328: LD_VAR 0 3
68332: PPUSH
68333: CALL_OW 110
68337: NOT
68338: IFFALSE 68414
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
68340: LD_ADDR_EXP 69
68344: PUSH
68345: LD_EXP 69
68349: PPUSH
68350: LD_VAR 0 2
68354: PUSH
68355: LD_EXP 69
68359: PUSH
68360: LD_VAR 0 2
68364: ARRAY
68365: PUSH
68366: LD_INT 1
68368: PLUS
68369: PUSH
68370: EMPTY
68371: LIST
68372: LIST
68373: PPUSH
68374: LD_VAR 0 3
68378: PPUSH
68379: CALL 18419 0 3
68383: ST_TO_ADDR
// SetTag ( j , 107 ) ;
68384: LD_VAR 0 3
68388: PPUSH
68389: LD_INT 107
68391: PPUSH
68392: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
68396: LD_EXP 69
68400: PUSH
68401: LD_VAR 0 2
68405: ARRAY
68406: PUSH
68407: LD_INT 5
68409: GREATEREQUAL
68410: IFFALSE 68414
// break ;
68412: GO 68416
// end ;
68414: GO 68325
68416: POP
68417: POP
// end ; if mc_crates_collector [ i ] and target then
68418: LD_EXP 69
68422: PUSH
68423: LD_VAR 0 2
68427: ARRAY
68428: PUSH
68429: LD_VAR 0 6
68433: AND
68434: IFFALSE 68677
// begin if mc_crates_collector [ i ] < target [ 1 ] then
68436: LD_EXP 69
68440: PUSH
68441: LD_VAR 0 2
68445: ARRAY
68446: PUSH
68447: LD_VAR 0 6
68451: PUSH
68452: LD_INT 1
68454: ARRAY
68455: LESS
68456: IFFALSE 68476
// tmp := mc_crates_collector [ i ] else
68458: LD_ADDR_VAR 0 5
68462: PUSH
68463: LD_EXP 69
68467: PUSH
68468: LD_VAR 0 2
68472: ARRAY
68473: ST_TO_ADDR
68474: GO 68490
// tmp := target [ 1 ] ;
68476: LD_ADDR_VAR 0 5
68480: PUSH
68481: LD_VAR 0 6
68485: PUSH
68486: LD_INT 1
68488: ARRAY
68489: ST_TO_ADDR
// k := 0 ;
68490: LD_ADDR_VAR 0 4
68494: PUSH
68495: LD_INT 0
68497: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
68498: LD_ADDR_VAR 0 3
68502: PUSH
68503: LD_EXP 69
68507: PUSH
68508: LD_VAR 0 2
68512: ARRAY
68513: PUSH
68514: FOR_IN
68515: IFFALSE 68675
// begin k := k + 1 ;
68517: LD_ADDR_VAR 0 4
68521: PUSH
68522: LD_VAR 0 4
68526: PUSH
68527: LD_INT 1
68529: PLUS
68530: ST_TO_ADDR
// if k > tmp then
68531: LD_VAR 0 4
68535: PUSH
68536: LD_VAR 0 5
68540: GREATER
68541: IFFALSE 68545
// break ;
68543: GO 68675
// if not GetClass ( j ) in [ 2 , 16 ] then
68545: LD_VAR 0 3
68549: PPUSH
68550: CALL_OW 257
68554: PUSH
68555: LD_INT 2
68557: PUSH
68558: LD_INT 16
68560: PUSH
68561: EMPTY
68562: LIST
68563: LIST
68564: IN
68565: NOT
68566: IFFALSE 68619
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
68568: LD_ADDR_EXP 69
68572: PUSH
68573: LD_EXP 69
68577: PPUSH
68578: LD_VAR 0 2
68582: PPUSH
68583: LD_EXP 69
68587: PUSH
68588: LD_VAR 0 2
68592: ARRAY
68593: PUSH
68594: LD_VAR 0 3
68598: DIFF
68599: PPUSH
68600: CALL_OW 1
68604: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68605: LD_VAR 0 3
68609: PPUSH
68610: LD_INT 0
68612: PPUSH
68613: CALL_OW 109
// continue ;
68617: GO 68514
// end ; if IsInUnit ( j ) then
68619: LD_VAR 0 3
68623: PPUSH
68624: CALL_OW 310
68628: IFFALSE 68639
// ComExitBuilding ( j ) ;
68630: LD_VAR 0 3
68634: PPUSH
68635: CALL_OW 122
// wait ( 3 ) ;
68639: LD_INT 3
68641: PPUSH
68642: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68646: LD_VAR 0 3
68650: PPUSH
68651: LD_VAR 0 6
68655: PUSH
68656: LD_INT 2
68658: ARRAY
68659: PPUSH
68660: LD_VAR 0 6
68664: PUSH
68665: LD_INT 3
68667: ARRAY
68668: PPUSH
68669: CALL_OW 117
// end ;
68673: GO 68514
68675: POP
68676: POP
// end ; end else
68677: GO 69258
// begin for j in cargo do
68679: LD_ADDR_VAR 0 3
68683: PUSH
68684: LD_VAR 0 7
68688: PUSH
68689: FOR_IN
68690: IFFALSE 69256
// begin if GetTag ( j ) <> 0 then
68692: LD_VAR 0 3
68696: PPUSH
68697: CALL_OW 110
68701: PUSH
68702: LD_INT 0
68704: NONEQUAL
68705: IFFALSE 68709
// continue ;
68707: GO 68689
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
68709: LD_VAR 0 3
68713: PPUSH
68714: CALL_OW 256
68718: PUSH
68719: LD_INT 1000
68721: LESS
68722: PUSH
68723: LD_VAR 0 3
68727: PPUSH
68728: LD_EXP 76
68732: PUSH
68733: LD_VAR 0 2
68737: ARRAY
68738: PPUSH
68739: CALL_OW 308
68743: NOT
68744: AND
68745: IFFALSE 68767
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68747: LD_VAR 0 3
68751: PPUSH
68752: LD_EXP 76
68756: PUSH
68757: LD_VAR 0 2
68761: ARRAY
68762: PPUSH
68763: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
68767: LD_VAR 0 3
68771: PPUSH
68772: CALL_OW 256
68776: PUSH
68777: LD_INT 1000
68779: LESS
68780: PUSH
68781: LD_VAR 0 3
68785: PPUSH
68786: LD_EXP 76
68790: PUSH
68791: LD_VAR 0 2
68795: ARRAY
68796: PPUSH
68797: CALL_OW 308
68801: AND
68802: IFFALSE 68806
// continue ;
68804: GO 68689
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
68806: LD_VAR 0 3
68810: PPUSH
68811: CALL_OW 262
68815: PUSH
68816: LD_INT 2
68818: EQUAL
68819: PUSH
68820: LD_VAR 0 3
68824: PPUSH
68825: CALL_OW 261
68829: PUSH
68830: LD_INT 15
68832: LESS
68833: AND
68834: IFFALSE 68838
// continue ;
68836: GO 68689
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
68838: LD_VAR 0 3
68842: PPUSH
68843: CALL_OW 262
68847: PUSH
68848: LD_INT 1
68850: EQUAL
68851: PUSH
68852: LD_VAR 0 3
68856: PPUSH
68857: CALL_OW 261
68861: PUSH
68862: LD_INT 10
68864: LESS
68865: AND
68866: IFFALSE 69195
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68868: LD_ADDR_VAR 0 8
68872: PUSH
68873: LD_EXP 52
68877: PUSH
68878: LD_VAR 0 2
68882: ARRAY
68883: PPUSH
68884: LD_INT 2
68886: PUSH
68887: LD_INT 30
68889: PUSH
68890: LD_INT 0
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: PUSH
68897: LD_INT 30
68899: PUSH
68900: LD_INT 1
68902: PUSH
68903: EMPTY
68904: LIST
68905: LIST
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: LIST
68911: PPUSH
68912: CALL_OW 72
68916: ST_TO_ADDR
// if not depot then
68917: LD_VAR 0 8
68921: NOT
68922: IFFALSE 68926
// continue ;
68924: GO 68689
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
68926: LD_VAR 0 3
68930: PPUSH
68931: LD_VAR 0 8
68935: PPUSH
68936: LD_VAR 0 3
68940: PPUSH
68941: CALL_OW 74
68945: PPUSH
68946: CALL_OW 296
68950: PUSH
68951: LD_INT 6
68953: LESS
68954: IFFALSE 68970
// SetFuel ( j , 100 ) else
68956: LD_VAR 0 3
68960: PPUSH
68961: LD_INT 100
68963: PPUSH
68964: CALL_OW 240
68968: GO 69195
// if GetFuel ( j ) = 0 then
68970: LD_VAR 0 3
68974: PPUSH
68975: CALL_OW 261
68979: PUSH
68980: LD_INT 0
68982: EQUAL
68983: IFFALSE 69195
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
68985: LD_ADDR_EXP 71
68989: PUSH
68990: LD_EXP 71
68994: PPUSH
68995: LD_VAR 0 2
68999: PPUSH
69000: LD_EXP 71
69004: PUSH
69005: LD_VAR 0 2
69009: ARRAY
69010: PUSH
69011: LD_VAR 0 3
69015: DIFF
69016: PPUSH
69017: CALL_OW 1
69021: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69022: LD_VAR 0 3
69026: PPUSH
69027: CALL_OW 263
69031: PUSH
69032: LD_INT 1
69034: EQUAL
69035: IFFALSE 69051
// ComExitVehicle ( IsInUnit ( j ) ) ;
69037: LD_VAR 0 3
69041: PPUSH
69042: CALL_OW 310
69046: PPUSH
69047: CALL_OW 121
// if GetControl ( j ) = control_remote then
69051: LD_VAR 0 3
69055: PPUSH
69056: CALL_OW 263
69060: PUSH
69061: LD_INT 2
69063: EQUAL
69064: IFFALSE 69075
// ComUnlink ( j ) ;
69066: LD_VAR 0 3
69070: PPUSH
69071: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
69075: LD_ADDR_VAR 0 9
69079: PUSH
69080: LD_VAR 0 2
69084: PPUSH
69085: LD_INT 3
69087: PPUSH
69088: CALL 78548 0 2
69092: ST_TO_ADDR
// if fac then
69093: LD_VAR 0 9
69097: IFFALSE 69193
// begin for k in fac do
69099: LD_ADDR_VAR 0 4
69103: PUSH
69104: LD_VAR 0 9
69108: PUSH
69109: FOR_IN
69110: IFFALSE 69191
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
69112: LD_ADDR_VAR 0 10
69116: PUSH
69117: LD_VAR 0 9
69121: PPUSH
69122: LD_VAR 0 3
69126: PPUSH
69127: CALL_OW 265
69131: PPUSH
69132: LD_VAR 0 3
69136: PPUSH
69137: CALL_OW 262
69141: PPUSH
69142: LD_VAR 0 3
69146: PPUSH
69147: CALL_OW 263
69151: PPUSH
69152: LD_VAR 0 3
69156: PPUSH
69157: CALL_OW 264
69161: PPUSH
69162: CALL 15951 0 5
69166: ST_TO_ADDR
// if components then
69167: LD_VAR 0 10
69171: IFFALSE 69189
// begin MC_InsertProduceList ( i , components ) ;
69173: LD_VAR 0 2
69177: PPUSH
69178: LD_VAR 0 10
69182: PPUSH
69183: CALL 78093 0 2
// break ;
69187: GO 69191
// end ; end ;
69189: GO 69109
69191: POP
69192: POP
// end ; continue ;
69193: GO 68689
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
69195: LD_VAR 0 3
69199: PPUSH
69200: LD_INT 1
69202: PPUSH
69203: CALL_OW 289
69207: PUSH
69208: LD_INT 100
69210: LESS
69211: PUSH
69212: LD_VAR 0 3
69216: PPUSH
69217: CALL_OW 314
69221: NOT
69222: AND
69223: IFFALSE 69252
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69225: LD_VAR 0 3
69229: PPUSH
69230: LD_VAR 0 6
69234: PUSH
69235: LD_INT 2
69237: ARRAY
69238: PPUSH
69239: LD_VAR 0 6
69243: PUSH
69244: LD_INT 3
69246: ARRAY
69247: PPUSH
69248: CALL_OW 117
// break ;
69252: GO 69256
// end ;
69254: GO 68689
69256: POP
69257: POP
// end ; end ;
69258: GO 67527
69260: POP
69261: POP
// end ;
69262: LD_VAR 0 1
69266: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
69267: LD_INT 0
69269: PPUSH
69270: PPUSH
69271: PPUSH
69272: PPUSH
// if not mc_bases then
69273: LD_EXP 52
69277: NOT
69278: IFFALSE 69282
// exit ;
69280: GO 69443
// for i = 1 to mc_bases do
69282: LD_ADDR_VAR 0 2
69286: PUSH
69287: DOUBLE
69288: LD_INT 1
69290: DEC
69291: ST_TO_ADDR
69292: LD_EXP 52
69296: PUSH
69297: FOR_TO
69298: IFFALSE 69441
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
69300: LD_ADDR_VAR 0 4
69304: PUSH
69305: LD_EXP 71
69309: PUSH
69310: LD_VAR 0 2
69314: ARRAY
69315: PUSH
69316: LD_EXP 74
69320: PUSH
69321: LD_VAR 0 2
69325: ARRAY
69326: UNION
69327: PPUSH
69328: LD_INT 33
69330: PUSH
69331: LD_INT 2
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PPUSH
69338: CALL_OW 72
69342: ST_TO_ADDR
// if tmp then
69343: LD_VAR 0 4
69347: IFFALSE 69439
// for j in tmp do
69349: LD_ADDR_VAR 0 3
69353: PUSH
69354: LD_VAR 0 4
69358: PUSH
69359: FOR_IN
69360: IFFALSE 69437
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
69362: LD_VAR 0 3
69366: PPUSH
69367: CALL_OW 312
69371: NOT
69372: PUSH
69373: LD_VAR 0 3
69377: PPUSH
69378: CALL_OW 256
69382: PUSH
69383: LD_INT 250
69385: GREATEREQUAL
69386: AND
69387: IFFALSE 69400
// Connect ( j ) else
69389: LD_VAR 0 3
69393: PPUSH
69394: CALL 21352 0 1
69398: GO 69435
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
69400: LD_VAR 0 3
69404: PPUSH
69405: CALL_OW 256
69409: PUSH
69410: LD_INT 250
69412: LESS
69413: PUSH
69414: LD_VAR 0 3
69418: PPUSH
69419: CALL_OW 312
69423: AND
69424: IFFALSE 69435
// ComUnlink ( j ) ;
69426: LD_VAR 0 3
69430: PPUSH
69431: CALL_OW 136
69435: GO 69359
69437: POP
69438: POP
// end ;
69439: GO 69297
69441: POP
69442: POP
// end ;
69443: LD_VAR 0 1
69447: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
69448: LD_INT 0
69450: PPUSH
69451: PPUSH
69452: PPUSH
69453: PPUSH
69454: PPUSH
// if not mc_bases then
69455: LD_EXP 52
69459: NOT
69460: IFFALSE 69464
// exit ;
69462: GO 69909
// for i = 1 to mc_bases do
69464: LD_ADDR_VAR 0 2
69468: PUSH
69469: DOUBLE
69470: LD_INT 1
69472: DEC
69473: ST_TO_ADDR
69474: LD_EXP 52
69478: PUSH
69479: FOR_TO
69480: IFFALSE 69907
// begin if not mc_produce [ i ] then
69482: LD_EXP 73
69486: PUSH
69487: LD_VAR 0 2
69491: ARRAY
69492: NOT
69493: IFFALSE 69497
// continue ;
69495: GO 69479
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69497: LD_ADDR_VAR 0 5
69501: PUSH
69502: LD_EXP 52
69506: PUSH
69507: LD_VAR 0 2
69511: ARRAY
69512: PPUSH
69513: LD_INT 30
69515: PUSH
69516: LD_INT 3
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: PPUSH
69523: CALL_OW 72
69527: ST_TO_ADDR
// if not fac then
69528: LD_VAR 0 5
69532: NOT
69533: IFFALSE 69537
// continue ;
69535: GO 69479
// for j in fac do
69537: LD_ADDR_VAR 0 3
69541: PUSH
69542: LD_VAR 0 5
69546: PUSH
69547: FOR_IN
69548: IFFALSE 69903
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
69550: LD_VAR 0 3
69554: PPUSH
69555: CALL_OW 461
69559: PUSH
69560: LD_INT 2
69562: NONEQUAL
69563: PUSH
69564: LD_VAR 0 3
69568: PPUSH
69569: LD_INT 15
69571: PPUSH
69572: CALL 21012 0 2
69576: PUSH
69577: LD_INT 4
69579: ARRAY
69580: OR
69581: IFFALSE 69585
// continue ;
69583: GO 69547
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
69585: LD_VAR 0 3
69589: PPUSH
69590: LD_EXP 73
69594: PUSH
69595: LD_VAR 0 2
69599: ARRAY
69600: PUSH
69601: LD_INT 1
69603: ARRAY
69604: PUSH
69605: LD_INT 1
69607: ARRAY
69608: PPUSH
69609: LD_EXP 73
69613: PUSH
69614: LD_VAR 0 2
69618: ARRAY
69619: PUSH
69620: LD_INT 1
69622: ARRAY
69623: PUSH
69624: LD_INT 2
69626: ARRAY
69627: PPUSH
69628: LD_EXP 73
69632: PUSH
69633: LD_VAR 0 2
69637: ARRAY
69638: PUSH
69639: LD_INT 1
69641: ARRAY
69642: PUSH
69643: LD_INT 3
69645: ARRAY
69646: PPUSH
69647: LD_EXP 73
69651: PUSH
69652: LD_VAR 0 2
69656: ARRAY
69657: PUSH
69658: LD_INT 1
69660: ARRAY
69661: PUSH
69662: LD_INT 4
69664: ARRAY
69665: PPUSH
69666: CALL_OW 448
69670: PUSH
69671: LD_VAR 0 3
69675: PPUSH
69676: LD_EXP 73
69680: PUSH
69681: LD_VAR 0 2
69685: ARRAY
69686: PUSH
69687: LD_INT 1
69689: ARRAY
69690: PUSH
69691: LD_INT 1
69693: ARRAY
69694: PUSH
69695: LD_EXP 73
69699: PUSH
69700: LD_VAR 0 2
69704: ARRAY
69705: PUSH
69706: LD_INT 1
69708: ARRAY
69709: PUSH
69710: LD_INT 2
69712: ARRAY
69713: PUSH
69714: LD_EXP 73
69718: PUSH
69719: LD_VAR 0 2
69723: ARRAY
69724: PUSH
69725: LD_INT 1
69727: ARRAY
69728: PUSH
69729: LD_INT 3
69731: ARRAY
69732: PUSH
69733: LD_EXP 73
69737: PUSH
69738: LD_VAR 0 2
69742: ARRAY
69743: PUSH
69744: LD_INT 1
69746: ARRAY
69747: PUSH
69748: LD_INT 4
69750: ARRAY
69751: PUSH
69752: EMPTY
69753: LIST
69754: LIST
69755: LIST
69756: LIST
69757: PPUSH
69758: CALL 24683 0 2
69762: AND
69763: IFFALSE 69901
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
69765: LD_VAR 0 3
69769: PPUSH
69770: LD_EXP 73
69774: PUSH
69775: LD_VAR 0 2
69779: ARRAY
69780: PUSH
69781: LD_INT 1
69783: ARRAY
69784: PUSH
69785: LD_INT 1
69787: ARRAY
69788: PPUSH
69789: LD_EXP 73
69793: PUSH
69794: LD_VAR 0 2
69798: ARRAY
69799: PUSH
69800: LD_INT 1
69802: ARRAY
69803: PUSH
69804: LD_INT 2
69806: ARRAY
69807: PPUSH
69808: LD_EXP 73
69812: PUSH
69813: LD_VAR 0 2
69817: ARRAY
69818: PUSH
69819: LD_INT 1
69821: ARRAY
69822: PUSH
69823: LD_INT 3
69825: ARRAY
69826: PPUSH
69827: LD_EXP 73
69831: PUSH
69832: LD_VAR 0 2
69836: ARRAY
69837: PUSH
69838: LD_INT 1
69840: ARRAY
69841: PUSH
69842: LD_INT 4
69844: ARRAY
69845: PPUSH
69846: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
69850: LD_ADDR_VAR 0 4
69854: PUSH
69855: LD_EXP 73
69859: PUSH
69860: LD_VAR 0 2
69864: ARRAY
69865: PPUSH
69866: LD_INT 1
69868: PPUSH
69869: CALL_OW 3
69873: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
69874: LD_ADDR_EXP 73
69878: PUSH
69879: LD_EXP 73
69883: PPUSH
69884: LD_VAR 0 2
69888: PPUSH
69889: LD_VAR 0 4
69893: PPUSH
69894: CALL_OW 1
69898: ST_TO_ADDR
// break ;
69899: GO 69903
// end ; end ;
69901: GO 69547
69903: POP
69904: POP
// end ;
69905: GO 69479
69907: POP
69908: POP
// end ;
69909: LD_VAR 0 1
69913: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
69914: LD_INT 0
69916: PPUSH
69917: PPUSH
69918: PPUSH
// if not mc_bases then
69919: LD_EXP 52
69923: NOT
69924: IFFALSE 69928
// exit ;
69926: GO 70017
// for i = 1 to mc_bases do
69928: LD_ADDR_VAR 0 2
69932: PUSH
69933: DOUBLE
69934: LD_INT 1
69936: DEC
69937: ST_TO_ADDR
69938: LD_EXP 52
69942: PUSH
69943: FOR_TO
69944: IFFALSE 70015
// begin if mc_attack [ i ] then
69946: LD_EXP 72
69950: PUSH
69951: LD_VAR 0 2
69955: ARRAY
69956: IFFALSE 70013
// begin tmp := mc_attack [ i ] [ 1 ] ;
69958: LD_ADDR_VAR 0 3
69962: PUSH
69963: LD_EXP 72
69967: PUSH
69968: LD_VAR 0 2
69972: ARRAY
69973: PUSH
69974: LD_INT 1
69976: ARRAY
69977: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
69978: LD_ADDR_EXP 72
69982: PUSH
69983: LD_EXP 72
69987: PPUSH
69988: LD_VAR 0 2
69992: PPUSH
69993: EMPTY
69994: PPUSH
69995: CALL_OW 1
69999: ST_TO_ADDR
// Attack ( tmp ) ;
70000: LD_VAR 0 3
70004: PPUSH
70005: CALL 46873 0 1
// exit ;
70009: POP
70010: POP
70011: GO 70017
// end ; end ;
70013: GO 69943
70015: POP
70016: POP
// end ;
70017: LD_VAR 0 1
70021: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70022: LD_INT 0
70024: PPUSH
70025: PPUSH
70026: PPUSH
70027: PPUSH
70028: PPUSH
70029: PPUSH
70030: PPUSH
// if not mc_bases then
70031: LD_EXP 52
70035: NOT
70036: IFFALSE 70040
// exit ;
70038: GO 70622
// for i = 1 to mc_bases do
70040: LD_ADDR_VAR 0 2
70044: PUSH
70045: DOUBLE
70046: LD_INT 1
70048: DEC
70049: ST_TO_ADDR
70050: LD_EXP 52
70054: PUSH
70055: FOR_TO
70056: IFFALSE 70620
// begin if not mc_bases [ i ] then
70058: LD_EXP 52
70062: PUSH
70063: LD_VAR 0 2
70067: ARRAY
70068: NOT
70069: IFFALSE 70073
// continue ;
70071: GO 70055
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70073: LD_ADDR_VAR 0 7
70077: PUSH
70078: LD_EXP 52
70082: PUSH
70083: LD_VAR 0 2
70087: ARRAY
70088: PUSH
70089: LD_INT 1
70091: ARRAY
70092: PPUSH
70093: CALL 15255 0 1
70097: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70098: LD_ADDR_EXP 75
70102: PUSH
70103: LD_EXP 75
70107: PPUSH
70108: LD_VAR 0 2
70112: PPUSH
70113: LD_EXP 52
70117: PUSH
70118: LD_VAR 0 2
70122: ARRAY
70123: PUSH
70124: LD_INT 1
70126: ARRAY
70127: PPUSH
70128: CALL_OW 255
70132: PPUSH
70133: LD_EXP 77
70137: PUSH
70138: LD_VAR 0 2
70142: ARRAY
70143: PPUSH
70144: CALL 12809 0 2
70148: PPUSH
70149: CALL_OW 1
70153: ST_TO_ADDR
// if not mc_scan [ i ] then
70154: LD_EXP 75
70158: PUSH
70159: LD_VAR 0 2
70163: ARRAY
70164: NOT
70165: IFFALSE 70320
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70167: LD_ADDR_VAR 0 4
70171: PUSH
70172: LD_EXP 52
70176: PUSH
70177: LD_VAR 0 2
70181: ARRAY
70182: PPUSH
70183: LD_INT 2
70185: PUSH
70186: LD_INT 25
70188: PUSH
70189: LD_INT 5
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 25
70198: PUSH
70199: LD_INT 8
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: PUSH
70206: LD_INT 25
70208: PUSH
70209: LD_INT 9
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: EMPTY
70217: LIST
70218: LIST
70219: LIST
70220: LIST
70221: PPUSH
70222: CALL_OW 72
70226: ST_TO_ADDR
// if not tmp then
70227: LD_VAR 0 4
70231: NOT
70232: IFFALSE 70236
// continue ;
70234: GO 70055
// for j in tmp do
70236: LD_ADDR_VAR 0 3
70240: PUSH
70241: LD_VAR 0 4
70245: PUSH
70246: FOR_IN
70247: IFFALSE 70318
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
70249: LD_VAR 0 3
70253: PPUSH
70254: CALL_OW 310
70258: PPUSH
70259: CALL_OW 266
70263: PUSH
70264: LD_INT 5
70266: EQUAL
70267: PUSH
70268: LD_VAR 0 3
70272: PPUSH
70273: CALL_OW 257
70277: PUSH
70278: LD_INT 1
70280: EQUAL
70281: AND
70282: PUSH
70283: LD_VAR 0 3
70287: PPUSH
70288: CALL_OW 459
70292: NOT
70293: AND
70294: PUSH
70295: LD_VAR 0 7
70299: AND
70300: IFFALSE 70316
// ComChangeProfession ( j , class ) ;
70302: LD_VAR 0 3
70306: PPUSH
70307: LD_VAR 0 7
70311: PPUSH
70312: CALL_OW 123
70316: GO 70246
70318: POP
70319: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
70320: LD_EXP 75
70324: PUSH
70325: LD_VAR 0 2
70329: ARRAY
70330: PUSH
70331: LD_EXP 74
70335: PUSH
70336: LD_VAR 0 2
70340: ARRAY
70341: NOT
70342: AND
70343: PUSH
70344: LD_EXP 52
70348: PUSH
70349: LD_VAR 0 2
70353: ARRAY
70354: PPUSH
70355: LD_INT 30
70357: PUSH
70358: LD_INT 32
70360: PUSH
70361: EMPTY
70362: LIST
70363: LIST
70364: PPUSH
70365: CALL_OW 72
70369: NOT
70370: AND
70371: PUSH
70372: LD_EXP 52
70376: PUSH
70377: LD_VAR 0 2
70381: ARRAY
70382: PPUSH
70383: LD_INT 2
70385: PUSH
70386: LD_INT 30
70388: PUSH
70389: LD_INT 4
70391: PUSH
70392: EMPTY
70393: LIST
70394: LIST
70395: PUSH
70396: LD_INT 30
70398: PUSH
70399: LD_INT 5
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: PUSH
70406: EMPTY
70407: LIST
70408: LIST
70409: LIST
70410: PPUSH
70411: CALL_OW 72
70415: NOT
70416: AND
70417: IFFALSE 70549
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70419: LD_ADDR_VAR 0 4
70423: PUSH
70424: LD_EXP 52
70428: PUSH
70429: LD_VAR 0 2
70433: ARRAY
70434: PPUSH
70435: LD_INT 2
70437: PUSH
70438: LD_INT 25
70440: PUSH
70441: LD_INT 1
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 25
70450: PUSH
70451: LD_INT 5
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: PUSH
70458: LD_INT 25
70460: PUSH
70461: LD_INT 8
70463: PUSH
70464: EMPTY
70465: LIST
70466: LIST
70467: PUSH
70468: LD_INT 25
70470: PUSH
70471: LD_INT 9
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: PUSH
70478: EMPTY
70479: LIST
70480: LIST
70481: LIST
70482: LIST
70483: LIST
70484: PPUSH
70485: CALL_OW 72
70489: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
70490: LD_ADDR_VAR 0 4
70494: PUSH
70495: LD_VAR 0 4
70499: PUSH
70500: LD_VAR 0 4
70504: PPUSH
70505: LD_INT 18
70507: PPUSH
70508: CALL 51689 0 2
70512: DIFF
70513: ST_TO_ADDR
// if tmp then
70514: LD_VAR 0 4
70518: IFFALSE 70549
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
70520: LD_VAR 0 2
70524: PPUSH
70525: LD_VAR 0 4
70529: PPUSH
70530: LD_EXP 77
70534: PUSH
70535: LD_VAR 0 2
70539: ARRAY
70540: PPUSH
70541: CALL 12844 0 3
// exit ;
70545: POP
70546: POP
70547: GO 70622
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
70549: LD_EXP 75
70553: PUSH
70554: LD_VAR 0 2
70558: ARRAY
70559: PUSH
70560: LD_EXP 74
70564: PUSH
70565: LD_VAR 0 2
70569: ARRAY
70570: AND
70571: IFFALSE 70618
// begin tmp := mc_defender [ i ] ;
70573: LD_ADDR_VAR 0 4
70577: PUSH
70578: LD_EXP 74
70582: PUSH
70583: LD_VAR 0 2
70587: ARRAY
70588: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
70589: LD_VAR 0 2
70593: PPUSH
70594: LD_VAR 0 4
70598: PPUSH
70599: LD_EXP 75
70603: PUSH
70604: LD_VAR 0 2
70608: ARRAY
70609: PPUSH
70610: CALL 13405 0 3
// exit ;
70614: POP
70615: POP
70616: GO 70622
// end ; end ;
70618: GO 70055
70620: POP
70621: POP
// end ;
70622: LD_VAR 0 1
70626: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
70627: LD_INT 0
70629: PPUSH
70630: PPUSH
70631: PPUSH
70632: PPUSH
70633: PPUSH
70634: PPUSH
70635: PPUSH
70636: PPUSH
70637: PPUSH
70638: PPUSH
70639: PPUSH
// if not mc_bases then
70640: LD_EXP 52
70644: NOT
70645: IFFALSE 70649
// exit ;
70647: GO 71736
// for i = 1 to mc_bases do
70649: LD_ADDR_VAR 0 2
70653: PUSH
70654: DOUBLE
70655: LD_INT 1
70657: DEC
70658: ST_TO_ADDR
70659: LD_EXP 52
70663: PUSH
70664: FOR_TO
70665: IFFALSE 71734
// begin tmp := mc_lab [ i ] ;
70667: LD_ADDR_VAR 0 6
70671: PUSH
70672: LD_EXP 85
70676: PUSH
70677: LD_VAR 0 2
70681: ARRAY
70682: ST_TO_ADDR
// if not tmp then
70683: LD_VAR 0 6
70687: NOT
70688: IFFALSE 70692
// continue ;
70690: GO 70664
// idle_lab := 0 ;
70692: LD_ADDR_VAR 0 11
70696: PUSH
70697: LD_INT 0
70699: ST_TO_ADDR
// for j in tmp do
70700: LD_ADDR_VAR 0 3
70704: PUSH
70705: LD_VAR 0 6
70709: PUSH
70710: FOR_IN
70711: IFFALSE 71730
// begin researching := false ;
70713: LD_ADDR_VAR 0 10
70717: PUSH
70718: LD_INT 0
70720: ST_TO_ADDR
// side := GetSide ( j ) ;
70721: LD_ADDR_VAR 0 4
70725: PUSH
70726: LD_VAR 0 3
70730: PPUSH
70731: CALL_OW 255
70735: ST_TO_ADDR
// if not mc_tech [ side ] then
70736: LD_EXP 79
70740: PUSH
70741: LD_VAR 0 4
70745: ARRAY
70746: NOT
70747: IFFALSE 70751
// continue ;
70749: GO 70710
// if BuildingStatus ( j ) = bs_idle then
70751: LD_VAR 0 3
70755: PPUSH
70756: CALL_OW 461
70760: PUSH
70761: LD_INT 2
70763: EQUAL
70764: IFFALSE 70952
// begin if idle_lab and UnitsInside ( j ) < 6 then
70766: LD_VAR 0 11
70770: PUSH
70771: LD_VAR 0 3
70775: PPUSH
70776: CALL_OW 313
70780: PUSH
70781: LD_INT 6
70783: LESS
70784: AND
70785: IFFALSE 70856
// begin tmp2 := UnitsInside ( idle_lab ) ;
70787: LD_ADDR_VAR 0 9
70791: PUSH
70792: LD_VAR 0 11
70796: PPUSH
70797: CALL_OW 313
70801: ST_TO_ADDR
// if tmp2 then
70802: LD_VAR 0 9
70806: IFFALSE 70848
// for x in tmp2 do
70808: LD_ADDR_VAR 0 7
70812: PUSH
70813: LD_VAR 0 9
70817: PUSH
70818: FOR_IN
70819: IFFALSE 70846
// begin ComExitBuilding ( x ) ;
70821: LD_VAR 0 7
70825: PPUSH
70826: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70830: LD_VAR 0 7
70834: PPUSH
70835: LD_VAR 0 3
70839: PPUSH
70840: CALL_OW 180
// end ;
70844: GO 70818
70846: POP
70847: POP
// idle_lab := 0 ;
70848: LD_ADDR_VAR 0 11
70852: PUSH
70853: LD_INT 0
70855: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
70856: LD_ADDR_VAR 0 5
70860: PUSH
70861: LD_EXP 79
70865: PUSH
70866: LD_VAR 0 4
70870: ARRAY
70871: PUSH
70872: FOR_IN
70873: IFFALSE 70933
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
70875: LD_VAR 0 3
70879: PPUSH
70880: LD_VAR 0 5
70884: PPUSH
70885: CALL_OW 430
70889: PUSH
70890: LD_VAR 0 4
70894: PPUSH
70895: LD_VAR 0 5
70899: PPUSH
70900: CALL 11914 0 2
70904: AND
70905: IFFALSE 70931
// begin researching := true ;
70907: LD_ADDR_VAR 0 10
70911: PUSH
70912: LD_INT 1
70914: ST_TO_ADDR
// ComResearch ( j , t ) ;
70915: LD_VAR 0 3
70919: PPUSH
70920: LD_VAR 0 5
70924: PPUSH
70925: CALL_OW 124
// break ;
70929: GO 70933
// end ;
70931: GO 70872
70933: POP
70934: POP
// if not researching then
70935: LD_VAR 0 10
70939: NOT
70940: IFFALSE 70952
// idle_lab := j ;
70942: LD_ADDR_VAR 0 11
70946: PUSH
70947: LD_VAR 0 3
70951: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
70952: LD_VAR 0 3
70956: PPUSH
70957: CALL_OW 461
70961: PUSH
70962: LD_INT 10
70964: EQUAL
70965: IFFALSE 71553
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
70967: LD_EXP 81
70971: PUSH
70972: LD_VAR 0 2
70976: ARRAY
70977: NOT
70978: PUSH
70979: LD_EXP 82
70983: PUSH
70984: LD_VAR 0 2
70988: ARRAY
70989: NOT
70990: AND
70991: PUSH
70992: LD_EXP 79
70996: PUSH
70997: LD_VAR 0 4
71001: ARRAY
71002: PUSH
71003: LD_INT 1
71005: GREATER
71006: AND
71007: IFFALSE 71138
// begin ComCancel ( j ) ;
71009: LD_VAR 0 3
71013: PPUSH
71014: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
71018: LD_ADDR_EXP 79
71022: PUSH
71023: LD_EXP 79
71027: PPUSH
71028: LD_VAR 0 4
71032: PPUSH
71033: LD_EXP 79
71037: PUSH
71038: LD_VAR 0 4
71042: ARRAY
71043: PPUSH
71044: LD_EXP 79
71048: PUSH
71049: LD_VAR 0 4
71053: ARRAY
71054: PUSH
71055: LD_INT 1
71057: MINUS
71058: PPUSH
71059: LD_EXP 79
71063: PUSH
71064: LD_VAR 0 4
71068: ARRAY
71069: PPUSH
71070: LD_INT 0
71072: PPUSH
71073: CALL 17837 0 4
71077: PPUSH
71078: CALL_OW 1
71082: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
71083: LD_ADDR_EXP 79
71087: PUSH
71088: LD_EXP 79
71092: PPUSH
71093: LD_VAR 0 4
71097: PPUSH
71098: LD_EXP 79
71102: PUSH
71103: LD_VAR 0 4
71107: ARRAY
71108: PPUSH
71109: LD_EXP 79
71113: PUSH
71114: LD_VAR 0 4
71118: ARRAY
71119: PPUSH
71120: LD_INT 1
71122: PPUSH
71123: LD_INT 0
71125: PPUSH
71126: CALL 17837 0 4
71130: PPUSH
71131: CALL_OW 1
71135: ST_TO_ADDR
// continue ;
71136: GO 70710
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
71138: LD_EXP 81
71142: PUSH
71143: LD_VAR 0 2
71147: ARRAY
71148: PUSH
71149: LD_EXP 82
71153: PUSH
71154: LD_VAR 0 2
71158: ARRAY
71159: NOT
71160: AND
71161: IFFALSE 71288
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
71163: LD_ADDR_EXP 82
71167: PUSH
71168: LD_EXP 82
71172: PPUSH
71173: LD_VAR 0 2
71177: PUSH
71178: LD_EXP 82
71182: PUSH
71183: LD_VAR 0 2
71187: ARRAY
71188: PUSH
71189: LD_INT 1
71191: PLUS
71192: PUSH
71193: EMPTY
71194: LIST
71195: LIST
71196: PPUSH
71197: LD_EXP 81
71201: PUSH
71202: LD_VAR 0 2
71206: ARRAY
71207: PUSH
71208: LD_INT 1
71210: ARRAY
71211: PPUSH
71212: CALL 18419 0 3
71216: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
71217: LD_EXP 81
71221: PUSH
71222: LD_VAR 0 2
71226: ARRAY
71227: PUSH
71228: LD_INT 1
71230: ARRAY
71231: PPUSH
71232: LD_INT 112
71234: PPUSH
71235: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
71239: LD_ADDR_VAR 0 9
71243: PUSH
71244: LD_EXP 81
71248: PUSH
71249: LD_VAR 0 2
71253: ARRAY
71254: PPUSH
71255: LD_INT 1
71257: PPUSH
71258: CALL_OW 3
71262: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
71263: LD_ADDR_EXP 81
71267: PUSH
71268: LD_EXP 81
71272: PPUSH
71273: LD_VAR 0 2
71277: PPUSH
71278: LD_VAR 0 9
71282: PPUSH
71283: CALL_OW 1
71287: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
71288: LD_EXP 81
71292: PUSH
71293: LD_VAR 0 2
71297: ARRAY
71298: PUSH
71299: LD_EXP 82
71303: PUSH
71304: LD_VAR 0 2
71308: ARRAY
71309: AND
71310: PUSH
71311: LD_EXP 82
71315: PUSH
71316: LD_VAR 0 2
71320: ARRAY
71321: PUSH
71322: LD_INT 1
71324: ARRAY
71325: PPUSH
71326: CALL_OW 310
71330: NOT
71331: AND
71332: PUSH
71333: LD_VAR 0 3
71337: PPUSH
71338: CALL_OW 313
71342: PUSH
71343: LD_INT 6
71345: EQUAL
71346: AND
71347: IFFALSE 71403
// begin tmp2 := UnitsInside ( j ) ;
71349: LD_ADDR_VAR 0 9
71353: PUSH
71354: LD_VAR 0 3
71358: PPUSH
71359: CALL_OW 313
71363: ST_TO_ADDR
// if tmp2 = 6 then
71364: LD_VAR 0 9
71368: PUSH
71369: LD_INT 6
71371: EQUAL
71372: IFFALSE 71403
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
71374: LD_VAR 0 9
71378: PUSH
71379: LD_INT 1
71381: ARRAY
71382: PPUSH
71383: LD_INT 112
71385: PPUSH
71386: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
71390: LD_VAR 0 9
71394: PUSH
71395: LD_INT 1
71397: ARRAY
71398: PPUSH
71399: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
71403: LD_EXP 82
71407: PUSH
71408: LD_VAR 0 2
71412: ARRAY
71413: PUSH
71414: LD_EXP 82
71418: PUSH
71419: LD_VAR 0 2
71423: ARRAY
71424: PUSH
71425: LD_INT 1
71427: ARRAY
71428: PPUSH
71429: CALL_OW 314
71433: NOT
71434: AND
71435: PUSH
71436: LD_EXP 82
71440: PUSH
71441: LD_VAR 0 2
71445: ARRAY
71446: PUSH
71447: LD_INT 1
71449: ARRAY
71450: PPUSH
71451: CALL_OW 310
71455: NOT
71456: AND
71457: IFFALSE 71483
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
71459: LD_EXP 82
71463: PUSH
71464: LD_VAR 0 2
71468: ARRAY
71469: PUSH
71470: LD_INT 1
71472: ARRAY
71473: PPUSH
71474: LD_VAR 0 3
71478: PPUSH
71479: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
71483: LD_EXP 82
71487: PUSH
71488: LD_VAR 0 2
71492: ARRAY
71493: PUSH
71494: LD_INT 1
71496: ARRAY
71497: PPUSH
71498: CALL_OW 310
71502: PUSH
71503: LD_EXP 82
71507: PUSH
71508: LD_VAR 0 2
71512: ARRAY
71513: PUSH
71514: LD_INT 1
71516: ARRAY
71517: PPUSH
71518: CALL_OW 310
71522: PPUSH
71523: CALL_OW 461
71527: PUSH
71528: LD_INT 3
71530: NONEQUAL
71531: AND
71532: IFFALSE 71553
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
71534: LD_EXP 82
71538: PUSH
71539: LD_VAR 0 2
71543: ARRAY
71544: PUSH
71545: LD_INT 1
71547: ARRAY
71548: PPUSH
71549: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
71553: LD_VAR 0 3
71557: PPUSH
71558: CALL_OW 461
71562: PUSH
71563: LD_INT 6
71565: EQUAL
71566: PUSH
71567: LD_VAR 0 6
71571: PUSH
71572: LD_INT 1
71574: GREATER
71575: AND
71576: IFFALSE 71728
// begin sci := [ ] ;
71578: LD_ADDR_VAR 0 8
71582: PUSH
71583: EMPTY
71584: ST_TO_ADDR
// for x in ( tmp diff j ) do
71585: LD_ADDR_VAR 0 7
71589: PUSH
71590: LD_VAR 0 6
71594: PUSH
71595: LD_VAR 0 3
71599: DIFF
71600: PUSH
71601: FOR_IN
71602: IFFALSE 71654
// begin if sci = 6 then
71604: LD_VAR 0 8
71608: PUSH
71609: LD_INT 6
71611: EQUAL
71612: IFFALSE 71616
// break ;
71614: GO 71654
// if BuildingStatus ( x ) = bs_idle then
71616: LD_VAR 0 7
71620: PPUSH
71621: CALL_OW 461
71625: PUSH
71626: LD_INT 2
71628: EQUAL
71629: IFFALSE 71652
// sci := sci ^ UnitsInside ( x ) ;
71631: LD_ADDR_VAR 0 8
71635: PUSH
71636: LD_VAR 0 8
71640: PUSH
71641: LD_VAR 0 7
71645: PPUSH
71646: CALL_OW 313
71650: ADD
71651: ST_TO_ADDR
// end ;
71652: GO 71601
71654: POP
71655: POP
// if not sci then
71656: LD_VAR 0 8
71660: NOT
71661: IFFALSE 71665
// continue ;
71663: GO 70710
// for x in sci do
71665: LD_ADDR_VAR 0 7
71669: PUSH
71670: LD_VAR 0 8
71674: PUSH
71675: FOR_IN
71676: IFFALSE 71726
// if IsInUnit ( x ) and not HasTask ( x ) then
71678: LD_VAR 0 7
71682: PPUSH
71683: CALL_OW 310
71687: PUSH
71688: LD_VAR 0 7
71692: PPUSH
71693: CALL_OW 314
71697: NOT
71698: AND
71699: IFFALSE 71724
// begin ComExitBuilding ( x ) ;
71701: LD_VAR 0 7
71705: PPUSH
71706: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71710: LD_VAR 0 7
71714: PPUSH
71715: LD_VAR 0 3
71719: PPUSH
71720: CALL_OW 180
// end ;
71724: GO 71675
71726: POP
71727: POP
// end ; end ;
71728: GO 70710
71730: POP
71731: POP
// end ;
71732: GO 70664
71734: POP
71735: POP
// end ;
71736: LD_VAR 0 1
71740: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
71741: LD_INT 0
71743: PPUSH
71744: PPUSH
// if not mc_bases then
71745: LD_EXP 52
71749: NOT
71750: IFFALSE 71754
// exit ;
71752: GO 71835
// for i = 1 to mc_bases do
71754: LD_ADDR_VAR 0 2
71758: PUSH
71759: DOUBLE
71760: LD_INT 1
71762: DEC
71763: ST_TO_ADDR
71764: LD_EXP 52
71768: PUSH
71769: FOR_TO
71770: IFFALSE 71833
// if mc_mines [ i ] and mc_miners [ i ] then
71772: LD_EXP 65
71776: PUSH
71777: LD_VAR 0 2
71781: ARRAY
71782: PUSH
71783: LD_EXP 66
71787: PUSH
71788: LD_VAR 0 2
71792: ARRAY
71793: AND
71794: IFFALSE 71831
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
71796: LD_EXP 66
71800: PUSH
71801: LD_VAR 0 2
71805: ARRAY
71806: PUSH
71807: LD_INT 1
71809: ARRAY
71810: PPUSH
71811: CALL_OW 255
71815: PPUSH
71816: LD_EXP 65
71820: PUSH
71821: LD_VAR 0 2
71825: ARRAY
71826: PPUSH
71827: CALL 15408 0 2
71831: GO 71769
71833: POP
71834: POP
// end ;
71835: LD_VAR 0 1
71839: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
71840: LD_INT 0
71842: PPUSH
71843: PPUSH
71844: PPUSH
71845: PPUSH
71846: PPUSH
71847: PPUSH
71848: PPUSH
71849: PPUSH
// if not mc_bases or not mc_parking then
71850: LD_EXP 52
71854: NOT
71855: PUSH
71856: LD_EXP 76
71860: NOT
71861: OR
71862: IFFALSE 71866
// exit ;
71864: GO 72565
// for i = 1 to mc_bases do
71866: LD_ADDR_VAR 0 2
71870: PUSH
71871: DOUBLE
71872: LD_INT 1
71874: DEC
71875: ST_TO_ADDR
71876: LD_EXP 52
71880: PUSH
71881: FOR_TO
71882: IFFALSE 72563
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
71884: LD_EXP 52
71888: PUSH
71889: LD_VAR 0 2
71893: ARRAY
71894: NOT
71895: PUSH
71896: LD_EXP 76
71900: PUSH
71901: LD_VAR 0 2
71905: ARRAY
71906: NOT
71907: OR
71908: IFFALSE 71912
// continue ;
71910: GO 71881
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
71912: LD_ADDR_VAR 0 5
71916: PUSH
71917: LD_EXP 52
71921: PUSH
71922: LD_VAR 0 2
71926: ARRAY
71927: PUSH
71928: LD_INT 1
71930: ARRAY
71931: PPUSH
71932: CALL_OW 255
71936: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71937: LD_ADDR_VAR 0 6
71941: PUSH
71942: LD_EXP 52
71946: PUSH
71947: LD_VAR 0 2
71951: ARRAY
71952: PPUSH
71953: LD_INT 30
71955: PUSH
71956: LD_INT 3
71958: PUSH
71959: EMPTY
71960: LIST
71961: LIST
71962: PPUSH
71963: CALL_OW 72
71967: ST_TO_ADDR
// if not fac then
71968: LD_VAR 0 6
71972: NOT
71973: IFFALSE 72024
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71975: LD_ADDR_VAR 0 6
71979: PUSH
71980: LD_EXP 52
71984: PUSH
71985: LD_VAR 0 2
71989: ARRAY
71990: PPUSH
71991: LD_INT 2
71993: PUSH
71994: LD_INT 30
71996: PUSH
71997: LD_INT 0
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: PUSH
72004: LD_INT 30
72006: PUSH
72007: LD_INT 1
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: LIST
72018: PPUSH
72019: CALL_OW 72
72023: ST_TO_ADDR
// if not fac then
72024: LD_VAR 0 6
72028: NOT
72029: IFFALSE 72033
// continue ;
72031: GO 71881
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72033: LD_ADDR_VAR 0 7
72037: PUSH
72038: LD_EXP 76
72042: PUSH
72043: LD_VAR 0 2
72047: ARRAY
72048: PPUSH
72049: LD_INT 22
72051: PUSH
72052: LD_VAR 0 5
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: PUSH
72061: LD_INT 21
72063: PUSH
72064: LD_INT 2
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: PUSH
72071: LD_INT 3
72073: PUSH
72074: LD_INT 24
72076: PUSH
72077: LD_INT 1000
72079: PUSH
72080: EMPTY
72081: LIST
72082: LIST
72083: PUSH
72084: EMPTY
72085: LIST
72086: LIST
72087: PUSH
72088: EMPTY
72089: LIST
72090: LIST
72091: LIST
72092: PPUSH
72093: CALL_OW 70
72097: ST_TO_ADDR
// for j in fac do
72098: LD_ADDR_VAR 0 3
72102: PUSH
72103: LD_VAR 0 6
72107: PUSH
72108: FOR_IN
72109: IFFALSE 72190
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72111: LD_ADDR_VAR 0 7
72115: PUSH
72116: LD_VAR 0 7
72120: PUSH
72121: LD_INT 22
72123: PUSH
72124: LD_VAR 0 5
72128: PUSH
72129: EMPTY
72130: LIST
72131: LIST
72132: PUSH
72133: LD_INT 91
72135: PUSH
72136: LD_VAR 0 3
72140: PUSH
72141: LD_INT 15
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: LIST
72148: PUSH
72149: LD_INT 21
72151: PUSH
72152: LD_INT 2
72154: PUSH
72155: EMPTY
72156: LIST
72157: LIST
72158: PUSH
72159: LD_INT 3
72161: PUSH
72162: LD_INT 24
72164: PUSH
72165: LD_INT 1000
72167: PUSH
72168: EMPTY
72169: LIST
72170: LIST
72171: PUSH
72172: EMPTY
72173: LIST
72174: LIST
72175: PUSH
72176: EMPTY
72177: LIST
72178: LIST
72179: LIST
72180: LIST
72181: PPUSH
72182: CALL_OW 69
72186: UNION
72187: ST_TO_ADDR
72188: GO 72108
72190: POP
72191: POP
// if not vehs then
72192: LD_VAR 0 7
72196: NOT
72197: IFFALSE 72223
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72199: LD_ADDR_EXP 64
72203: PUSH
72204: LD_EXP 64
72208: PPUSH
72209: LD_VAR 0 2
72213: PPUSH
72214: EMPTY
72215: PPUSH
72216: CALL_OW 1
72220: ST_TO_ADDR
// continue ;
72221: GO 71881
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72223: LD_ADDR_VAR 0 8
72227: PUSH
72228: LD_EXP 52
72232: PUSH
72233: LD_VAR 0 2
72237: ARRAY
72238: PPUSH
72239: LD_INT 30
72241: PUSH
72242: LD_INT 3
72244: PUSH
72245: EMPTY
72246: LIST
72247: LIST
72248: PPUSH
72249: CALL_OW 72
72253: ST_TO_ADDR
// if tmp then
72254: LD_VAR 0 8
72258: IFFALSE 72361
// begin for j in tmp do
72260: LD_ADDR_VAR 0 3
72264: PUSH
72265: LD_VAR 0 8
72269: PUSH
72270: FOR_IN
72271: IFFALSE 72359
// for k in UnitsInside ( j ) do
72273: LD_ADDR_VAR 0 4
72277: PUSH
72278: LD_VAR 0 3
72282: PPUSH
72283: CALL_OW 313
72287: PUSH
72288: FOR_IN
72289: IFFALSE 72355
// if k then
72291: LD_VAR 0 4
72295: IFFALSE 72353
// if not k in mc_repair_vehicle [ i ] then
72297: LD_VAR 0 4
72301: PUSH
72302: LD_EXP 64
72306: PUSH
72307: LD_VAR 0 2
72311: ARRAY
72312: IN
72313: NOT
72314: IFFALSE 72353
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
72316: LD_ADDR_EXP 64
72320: PUSH
72321: LD_EXP 64
72325: PPUSH
72326: LD_VAR 0 2
72330: PPUSH
72331: LD_EXP 64
72335: PUSH
72336: LD_VAR 0 2
72340: ARRAY
72341: PUSH
72342: LD_VAR 0 4
72346: UNION
72347: PPUSH
72348: CALL_OW 1
72352: ST_TO_ADDR
72353: GO 72288
72355: POP
72356: POP
72357: GO 72270
72359: POP
72360: POP
// end ; if not mc_repair_vehicle [ i ] then
72361: LD_EXP 64
72365: PUSH
72366: LD_VAR 0 2
72370: ARRAY
72371: NOT
72372: IFFALSE 72376
// continue ;
72374: GO 71881
// for j in mc_repair_vehicle [ i ] do
72376: LD_ADDR_VAR 0 3
72380: PUSH
72381: LD_EXP 64
72385: PUSH
72386: LD_VAR 0 2
72390: ARRAY
72391: PUSH
72392: FOR_IN
72393: IFFALSE 72559
// begin if GetClass ( j ) <> 3 then
72395: LD_VAR 0 3
72399: PPUSH
72400: CALL_OW 257
72404: PUSH
72405: LD_INT 3
72407: NONEQUAL
72408: IFFALSE 72449
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
72410: LD_ADDR_EXP 64
72414: PUSH
72415: LD_EXP 64
72419: PPUSH
72420: LD_VAR 0 2
72424: PPUSH
72425: LD_EXP 64
72429: PUSH
72430: LD_VAR 0 2
72434: ARRAY
72435: PUSH
72436: LD_VAR 0 3
72440: DIFF
72441: PPUSH
72442: CALL_OW 1
72446: ST_TO_ADDR
// continue ;
72447: GO 72392
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72449: LD_VAR 0 3
72453: PPUSH
72454: CALL_OW 311
72458: NOT
72459: PUSH
72460: LD_VAR 0 3
72464: PUSH
72465: LD_EXP 55
72469: PUSH
72470: LD_VAR 0 2
72474: ARRAY
72475: PUSH
72476: LD_INT 1
72478: ARRAY
72479: IN
72480: NOT
72481: AND
72482: PUSH
72483: LD_VAR 0 3
72487: PUSH
72488: LD_EXP 55
72492: PUSH
72493: LD_VAR 0 2
72497: ARRAY
72498: PUSH
72499: LD_INT 2
72501: ARRAY
72502: IN
72503: NOT
72504: AND
72505: IFFALSE 72557
// begin if IsInUnit ( j ) then
72507: LD_VAR 0 3
72511: PPUSH
72512: CALL_OW 310
72516: IFFALSE 72527
// ComExitBuilding ( j ) ;
72518: LD_VAR 0 3
72522: PPUSH
72523: CALL_OW 122
// if not HasTask ( j ) then
72527: LD_VAR 0 3
72531: PPUSH
72532: CALL_OW 314
72536: NOT
72537: IFFALSE 72557
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
72539: LD_VAR 0 3
72543: PPUSH
72544: LD_VAR 0 7
72548: PUSH
72549: LD_INT 1
72551: ARRAY
72552: PPUSH
72553: CALL_OW 189
// end ; end ;
72557: GO 72392
72559: POP
72560: POP
// end ;
72561: GO 71881
72563: POP
72564: POP
// end ;
72565: LD_VAR 0 1
72569: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
72570: LD_INT 0
72572: PPUSH
72573: PPUSH
72574: PPUSH
72575: PPUSH
72576: PPUSH
72577: PPUSH
72578: PPUSH
72579: PPUSH
72580: PPUSH
72581: PPUSH
72582: PPUSH
// if not mc_bases then
72583: LD_EXP 52
72587: NOT
72588: IFFALSE 72592
// exit ;
72590: GO 73394
// for i = 1 to mc_bases do
72592: LD_ADDR_VAR 0 2
72596: PUSH
72597: DOUBLE
72598: LD_INT 1
72600: DEC
72601: ST_TO_ADDR
72602: LD_EXP 52
72606: PUSH
72607: FOR_TO
72608: IFFALSE 73392
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
72610: LD_EXP 80
72614: PUSH
72615: LD_VAR 0 2
72619: ARRAY
72620: NOT
72621: PUSH
72622: LD_EXP 55
72626: PUSH
72627: LD_VAR 0 2
72631: ARRAY
72632: PUSH
72633: LD_INT 1
72635: ARRAY
72636: OR
72637: PUSH
72638: LD_EXP 55
72642: PUSH
72643: LD_VAR 0 2
72647: ARRAY
72648: PUSH
72649: LD_INT 2
72651: ARRAY
72652: OR
72653: PUSH
72654: LD_EXP 78
72658: PUSH
72659: LD_VAR 0 2
72663: ARRAY
72664: PPUSH
72665: LD_INT 1
72667: PPUSH
72668: CALL_OW 325
72672: NOT
72673: OR
72674: PUSH
72675: LD_EXP 75
72679: PUSH
72680: LD_VAR 0 2
72684: ARRAY
72685: OR
72686: IFFALSE 72690
// continue ;
72688: GO 72607
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
72690: LD_ADDR_VAR 0 8
72694: PUSH
72695: LD_EXP 52
72699: PUSH
72700: LD_VAR 0 2
72704: ARRAY
72705: PPUSH
72706: LD_INT 25
72708: PUSH
72709: LD_INT 4
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: PUSH
72716: LD_INT 50
72718: PUSH
72719: EMPTY
72720: LIST
72721: PUSH
72722: LD_INT 3
72724: PUSH
72725: LD_INT 60
72727: PUSH
72728: EMPTY
72729: LIST
72730: PUSH
72731: EMPTY
72732: LIST
72733: LIST
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: LIST
72739: PPUSH
72740: CALL_OW 72
72744: PUSH
72745: LD_EXP 56
72749: PUSH
72750: LD_VAR 0 2
72754: ARRAY
72755: DIFF
72756: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72757: LD_ADDR_VAR 0 9
72761: PUSH
72762: LD_EXP 52
72766: PUSH
72767: LD_VAR 0 2
72771: ARRAY
72772: PPUSH
72773: LD_INT 2
72775: PUSH
72776: LD_INT 30
72778: PUSH
72779: LD_INT 0
72781: PUSH
72782: EMPTY
72783: LIST
72784: LIST
72785: PUSH
72786: LD_INT 30
72788: PUSH
72789: LD_INT 1
72791: PUSH
72792: EMPTY
72793: LIST
72794: LIST
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: LIST
72800: PPUSH
72801: CALL_OW 72
72805: ST_TO_ADDR
// if not tmp or not dep then
72806: LD_VAR 0 8
72810: NOT
72811: PUSH
72812: LD_VAR 0 9
72816: NOT
72817: OR
72818: IFFALSE 72822
// continue ;
72820: GO 72607
// side := GetSide ( tmp [ 1 ] ) ;
72822: LD_ADDR_VAR 0 11
72826: PUSH
72827: LD_VAR 0 8
72831: PUSH
72832: LD_INT 1
72834: ARRAY
72835: PPUSH
72836: CALL_OW 255
72840: ST_TO_ADDR
// dep := dep [ 1 ] ;
72841: LD_ADDR_VAR 0 9
72845: PUSH
72846: LD_VAR 0 9
72850: PUSH
72851: LD_INT 1
72853: ARRAY
72854: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
72855: LD_ADDR_VAR 0 7
72859: PUSH
72860: LD_EXP 80
72864: PUSH
72865: LD_VAR 0 2
72869: ARRAY
72870: PPUSH
72871: LD_INT 22
72873: PUSH
72874: LD_INT 0
72876: PUSH
72877: EMPTY
72878: LIST
72879: LIST
72880: PUSH
72881: LD_INT 25
72883: PUSH
72884: LD_INT 12
72886: PUSH
72887: EMPTY
72888: LIST
72889: LIST
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: PPUSH
72895: CALL_OW 70
72899: PUSH
72900: LD_INT 22
72902: PUSH
72903: LD_INT 0
72905: PUSH
72906: EMPTY
72907: LIST
72908: LIST
72909: PUSH
72910: LD_INT 25
72912: PUSH
72913: LD_INT 12
72915: PUSH
72916: EMPTY
72917: LIST
72918: LIST
72919: PUSH
72920: LD_INT 91
72922: PUSH
72923: LD_VAR 0 9
72927: PUSH
72928: LD_INT 20
72930: PUSH
72931: EMPTY
72932: LIST
72933: LIST
72934: LIST
72935: PUSH
72936: EMPTY
72937: LIST
72938: LIST
72939: LIST
72940: PPUSH
72941: CALL_OW 69
72945: UNION
72946: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
72947: LD_ADDR_VAR 0 10
72951: PUSH
72952: LD_EXP 80
72956: PUSH
72957: LD_VAR 0 2
72961: ARRAY
72962: PPUSH
72963: LD_INT 81
72965: PUSH
72966: LD_VAR 0 11
72970: PUSH
72971: EMPTY
72972: LIST
72973: LIST
72974: PPUSH
72975: CALL_OW 70
72979: ST_TO_ADDR
// if not apes or danger_at_area then
72980: LD_VAR 0 7
72984: NOT
72985: PUSH
72986: LD_VAR 0 10
72990: OR
72991: IFFALSE 73041
// begin if mc_taming [ i ] then
72993: LD_EXP 83
72997: PUSH
72998: LD_VAR 0 2
73002: ARRAY
73003: IFFALSE 73039
// begin MC_Reset ( i , 121 ) ;
73005: LD_VAR 0 2
73009: PPUSH
73010: LD_INT 121
73012: PPUSH
73013: CALL 58476 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
73017: LD_ADDR_EXP 83
73021: PUSH
73022: LD_EXP 83
73026: PPUSH
73027: LD_VAR 0 2
73031: PPUSH
73032: EMPTY
73033: PPUSH
73034: CALL_OW 1
73038: ST_TO_ADDR
// end ; continue ;
73039: GO 72607
// end ; for j in tmp do
73041: LD_ADDR_VAR 0 3
73045: PUSH
73046: LD_VAR 0 8
73050: PUSH
73051: FOR_IN
73052: IFFALSE 73388
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
73054: LD_VAR 0 3
73058: PUSH
73059: LD_EXP 83
73063: PUSH
73064: LD_VAR 0 2
73068: ARRAY
73069: IN
73070: NOT
73071: PUSH
73072: LD_EXP 83
73076: PUSH
73077: LD_VAR 0 2
73081: ARRAY
73082: PUSH
73083: LD_INT 3
73085: LESS
73086: AND
73087: IFFALSE 73145
// begin SetTag ( j , 121 ) ;
73089: LD_VAR 0 3
73093: PPUSH
73094: LD_INT 121
73096: PPUSH
73097: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
73101: LD_ADDR_EXP 83
73105: PUSH
73106: LD_EXP 83
73110: PPUSH
73111: LD_VAR 0 2
73115: PUSH
73116: LD_EXP 83
73120: PUSH
73121: LD_VAR 0 2
73125: ARRAY
73126: PUSH
73127: LD_INT 1
73129: PLUS
73130: PUSH
73131: EMPTY
73132: LIST
73133: LIST
73134: PPUSH
73135: LD_VAR 0 3
73139: PPUSH
73140: CALL 18419 0 3
73144: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
73145: LD_VAR 0 3
73149: PUSH
73150: LD_EXP 83
73154: PUSH
73155: LD_VAR 0 2
73159: ARRAY
73160: IN
73161: IFFALSE 73386
// begin if GetClass ( j ) <> 4 then
73163: LD_VAR 0 3
73167: PPUSH
73168: CALL_OW 257
73172: PUSH
73173: LD_INT 4
73175: NONEQUAL
73176: IFFALSE 73229
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
73178: LD_ADDR_EXP 83
73182: PUSH
73183: LD_EXP 83
73187: PPUSH
73188: LD_VAR 0 2
73192: PPUSH
73193: LD_EXP 83
73197: PUSH
73198: LD_VAR 0 2
73202: ARRAY
73203: PUSH
73204: LD_VAR 0 3
73208: DIFF
73209: PPUSH
73210: CALL_OW 1
73214: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73215: LD_VAR 0 3
73219: PPUSH
73220: LD_INT 0
73222: PPUSH
73223: CALL_OW 109
// continue ;
73227: GO 73051
// end ; if IsInUnit ( j ) then
73229: LD_VAR 0 3
73233: PPUSH
73234: CALL_OW 310
73238: IFFALSE 73249
// ComExitBuilding ( j ) ;
73240: LD_VAR 0 3
73244: PPUSH
73245: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
73249: LD_ADDR_VAR 0 6
73253: PUSH
73254: LD_VAR 0 7
73258: PPUSH
73259: LD_VAR 0 3
73263: PPUSH
73264: CALL_OW 74
73268: ST_TO_ADDR
// if not ape then
73269: LD_VAR 0 6
73273: NOT
73274: IFFALSE 73278
// break ;
73276: GO 73388
// x := GetX ( ape ) ;
73278: LD_ADDR_VAR 0 4
73282: PUSH
73283: LD_VAR 0 6
73287: PPUSH
73288: CALL_OW 250
73292: ST_TO_ADDR
// y := GetY ( ape ) ;
73293: LD_ADDR_VAR 0 5
73297: PUSH
73298: LD_VAR 0 6
73302: PPUSH
73303: CALL_OW 251
73307: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
73308: LD_VAR 0 4
73312: PPUSH
73313: LD_VAR 0 5
73317: PPUSH
73318: CALL_OW 488
73322: NOT
73323: PUSH
73324: LD_VAR 0 11
73328: PPUSH
73329: LD_VAR 0 4
73333: PPUSH
73334: LD_VAR 0 5
73338: PPUSH
73339: LD_INT 20
73341: PPUSH
73342: CALL 19315 0 4
73346: PUSH
73347: LD_INT 4
73349: ARRAY
73350: OR
73351: IFFALSE 73355
// break ;
73353: GO 73388
// if not HasTask ( j ) then
73355: LD_VAR 0 3
73359: PPUSH
73360: CALL_OW 314
73364: NOT
73365: IFFALSE 73386
// ComTameXY ( j , x , y ) ;
73367: LD_VAR 0 3
73371: PPUSH
73372: LD_VAR 0 4
73376: PPUSH
73377: LD_VAR 0 5
73381: PPUSH
73382: CALL_OW 131
// end ; end ;
73386: GO 73051
73388: POP
73389: POP
// end ;
73390: GO 72607
73392: POP
73393: POP
// end ;
73394: LD_VAR 0 1
73398: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
73399: LD_INT 0
73401: PPUSH
73402: PPUSH
73403: PPUSH
73404: PPUSH
73405: PPUSH
73406: PPUSH
73407: PPUSH
73408: PPUSH
// if not mc_bases then
73409: LD_EXP 52
73413: NOT
73414: IFFALSE 73418
// exit ;
73416: GO 74044
// for i = 1 to mc_bases do
73418: LD_ADDR_VAR 0 2
73422: PUSH
73423: DOUBLE
73424: LD_INT 1
73426: DEC
73427: ST_TO_ADDR
73428: LD_EXP 52
73432: PUSH
73433: FOR_TO
73434: IFFALSE 74042
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
73436: LD_EXP 81
73440: PUSH
73441: LD_VAR 0 2
73445: ARRAY
73446: NOT
73447: PUSH
73448: LD_EXP 81
73452: PUSH
73453: LD_VAR 0 2
73457: ARRAY
73458: PPUSH
73459: LD_INT 25
73461: PUSH
73462: LD_INT 12
73464: PUSH
73465: EMPTY
73466: LIST
73467: LIST
73468: PPUSH
73469: CALL_OW 72
73473: NOT
73474: OR
73475: IFFALSE 73479
// continue ;
73477: GO 73433
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
73479: LD_ADDR_VAR 0 5
73483: PUSH
73484: LD_EXP 81
73488: PUSH
73489: LD_VAR 0 2
73493: ARRAY
73494: PUSH
73495: LD_INT 1
73497: ARRAY
73498: PPUSH
73499: CALL_OW 255
73503: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
73504: LD_VAR 0 5
73508: PPUSH
73509: LD_INT 2
73511: PPUSH
73512: CALL_OW 325
73516: IFFALSE 73769
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73518: LD_ADDR_VAR 0 4
73522: PUSH
73523: LD_EXP 81
73527: PUSH
73528: LD_VAR 0 2
73532: ARRAY
73533: PPUSH
73534: LD_INT 25
73536: PUSH
73537: LD_INT 16
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: PPUSH
73544: CALL_OW 72
73548: ST_TO_ADDR
// if tmp < 6 then
73549: LD_VAR 0 4
73553: PUSH
73554: LD_INT 6
73556: LESS
73557: IFFALSE 73769
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73559: LD_ADDR_VAR 0 6
73563: PUSH
73564: LD_EXP 52
73568: PUSH
73569: LD_VAR 0 2
73573: ARRAY
73574: PPUSH
73575: LD_INT 2
73577: PUSH
73578: LD_INT 30
73580: PUSH
73581: LD_INT 0
73583: PUSH
73584: EMPTY
73585: LIST
73586: LIST
73587: PUSH
73588: LD_INT 30
73590: PUSH
73591: LD_INT 1
73593: PUSH
73594: EMPTY
73595: LIST
73596: LIST
73597: PUSH
73598: EMPTY
73599: LIST
73600: LIST
73601: LIST
73602: PPUSH
73603: CALL_OW 72
73607: ST_TO_ADDR
// if depot then
73608: LD_VAR 0 6
73612: IFFALSE 73769
// begin selected := 0 ;
73614: LD_ADDR_VAR 0 7
73618: PUSH
73619: LD_INT 0
73621: ST_TO_ADDR
// for j in depot do
73622: LD_ADDR_VAR 0 3
73626: PUSH
73627: LD_VAR 0 6
73631: PUSH
73632: FOR_IN
73633: IFFALSE 73664
// begin if UnitsInside ( j ) < 6 then
73635: LD_VAR 0 3
73639: PPUSH
73640: CALL_OW 313
73644: PUSH
73645: LD_INT 6
73647: LESS
73648: IFFALSE 73662
// begin selected := j ;
73650: LD_ADDR_VAR 0 7
73654: PUSH
73655: LD_VAR 0 3
73659: ST_TO_ADDR
// break ;
73660: GO 73664
// end ; end ;
73662: GO 73632
73664: POP
73665: POP
// if selected then
73666: LD_VAR 0 7
73670: IFFALSE 73769
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73672: LD_ADDR_VAR 0 3
73676: PUSH
73677: LD_EXP 81
73681: PUSH
73682: LD_VAR 0 2
73686: ARRAY
73687: PPUSH
73688: LD_INT 25
73690: PUSH
73691: LD_INT 12
73693: PUSH
73694: EMPTY
73695: LIST
73696: LIST
73697: PPUSH
73698: CALL_OW 72
73702: PUSH
73703: FOR_IN
73704: IFFALSE 73767
// if not HasTask ( j ) then
73706: LD_VAR 0 3
73710: PPUSH
73711: CALL_OW 314
73715: NOT
73716: IFFALSE 73765
// begin if not IsInUnit ( j ) then
73718: LD_VAR 0 3
73722: PPUSH
73723: CALL_OW 310
73727: NOT
73728: IFFALSE 73744
// ComEnterUnit ( j , selected ) ;
73730: LD_VAR 0 3
73734: PPUSH
73735: LD_VAR 0 7
73739: PPUSH
73740: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
73744: LD_VAR 0 3
73748: PPUSH
73749: LD_INT 16
73751: PPUSH
73752: CALL_OW 183
// AddComExitBuilding ( j ) ;
73756: LD_VAR 0 3
73760: PPUSH
73761: CALL_OW 182
// end ;
73765: GO 73703
73767: POP
73768: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
73769: LD_VAR 0 5
73773: PPUSH
73774: LD_INT 11
73776: PPUSH
73777: CALL_OW 325
73781: IFFALSE 74040
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73783: LD_ADDR_VAR 0 4
73787: PUSH
73788: LD_EXP 81
73792: PUSH
73793: LD_VAR 0 2
73797: ARRAY
73798: PPUSH
73799: LD_INT 25
73801: PUSH
73802: LD_INT 16
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PPUSH
73809: CALL_OW 72
73813: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
73814: LD_VAR 0 4
73818: PUSH
73819: LD_INT 6
73821: GREATEREQUAL
73822: PUSH
73823: LD_VAR 0 5
73827: PPUSH
73828: LD_INT 2
73830: PPUSH
73831: CALL_OW 325
73835: NOT
73836: OR
73837: IFFALSE 74040
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
73839: LD_ADDR_VAR 0 8
73843: PUSH
73844: LD_EXP 52
73848: PUSH
73849: LD_VAR 0 2
73853: ARRAY
73854: PPUSH
73855: LD_INT 2
73857: PUSH
73858: LD_INT 30
73860: PUSH
73861: LD_INT 4
73863: PUSH
73864: EMPTY
73865: LIST
73866: LIST
73867: PUSH
73868: LD_INT 30
73870: PUSH
73871: LD_INT 5
73873: PUSH
73874: EMPTY
73875: LIST
73876: LIST
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: LIST
73882: PPUSH
73883: CALL_OW 72
73887: ST_TO_ADDR
// if barracks then
73888: LD_VAR 0 8
73892: IFFALSE 74040
// begin selected := 0 ;
73894: LD_ADDR_VAR 0 7
73898: PUSH
73899: LD_INT 0
73901: ST_TO_ADDR
// for j in barracks do
73902: LD_ADDR_VAR 0 3
73906: PUSH
73907: LD_VAR 0 8
73911: PUSH
73912: FOR_IN
73913: IFFALSE 73944
// begin if UnitsInside ( j ) < 6 then
73915: LD_VAR 0 3
73919: PPUSH
73920: CALL_OW 313
73924: PUSH
73925: LD_INT 6
73927: LESS
73928: IFFALSE 73942
// begin selected := j ;
73930: LD_ADDR_VAR 0 7
73934: PUSH
73935: LD_VAR 0 3
73939: ST_TO_ADDR
// break ;
73940: GO 73944
// end ; end ;
73942: GO 73912
73944: POP
73945: POP
// if selected then
73946: LD_VAR 0 7
73950: IFFALSE 74040
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73952: LD_ADDR_VAR 0 3
73956: PUSH
73957: LD_EXP 81
73961: PUSH
73962: LD_VAR 0 2
73966: ARRAY
73967: PPUSH
73968: LD_INT 25
73970: PUSH
73971: LD_INT 12
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: PPUSH
73978: CALL_OW 72
73982: PUSH
73983: FOR_IN
73984: IFFALSE 74038
// if not IsInUnit ( j ) and not HasTask ( j ) then
73986: LD_VAR 0 3
73990: PPUSH
73991: CALL_OW 310
73995: NOT
73996: PUSH
73997: LD_VAR 0 3
74001: PPUSH
74002: CALL_OW 314
74006: NOT
74007: AND
74008: IFFALSE 74036
// begin ComEnterUnit ( j , selected ) ;
74010: LD_VAR 0 3
74014: PPUSH
74015: LD_VAR 0 7
74019: PPUSH
74020: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
74024: LD_VAR 0 3
74028: PPUSH
74029: LD_INT 15
74031: PPUSH
74032: CALL_OW 183
// end ;
74036: GO 73983
74038: POP
74039: POP
// end ; end ; end ; end ; end ;
74040: GO 73433
74042: POP
74043: POP
// end ;
74044: LD_VAR 0 1
74048: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
74049: LD_INT 0
74051: PPUSH
74052: PPUSH
74053: PPUSH
74054: PPUSH
// if not mc_bases then
74055: LD_EXP 52
74059: NOT
74060: IFFALSE 74064
// exit ;
74062: GO 74242
// for i = 1 to mc_bases do
74064: LD_ADDR_VAR 0 2
74068: PUSH
74069: DOUBLE
74070: LD_INT 1
74072: DEC
74073: ST_TO_ADDR
74074: LD_EXP 52
74078: PUSH
74079: FOR_TO
74080: IFFALSE 74240
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
74082: LD_ADDR_VAR 0 4
74086: PUSH
74087: LD_EXP 52
74091: PUSH
74092: LD_VAR 0 2
74096: ARRAY
74097: PPUSH
74098: LD_INT 25
74100: PUSH
74101: LD_INT 9
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: PPUSH
74108: CALL_OW 72
74112: ST_TO_ADDR
// if not tmp then
74113: LD_VAR 0 4
74117: NOT
74118: IFFALSE 74122
// continue ;
74120: GO 74079
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
74122: LD_EXP 78
74126: PUSH
74127: LD_VAR 0 2
74131: ARRAY
74132: PPUSH
74133: LD_INT 29
74135: PPUSH
74136: CALL_OW 325
74140: NOT
74141: PUSH
74142: LD_EXP 78
74146: PUSH
74147: LD_VAR 0 2
74151: ARRAY
74152: PPUSH
74153: LD_INT 28
74155: PPUSH
74156: CALL_OW 325
74160: NOT
74161: AND
74162: IFFALSE 74166
// continue ;
74164: GO 74079
// for j in tmp do
74166: LD_ADDR_VAR 0 3
74170: PUSH
74171: LD_VAR 0 4
74175: PUSH
74176: FOR_IN
74177: IFFALSE 74236
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74179: LD_VAR 0 3
74183: PUSH
74184: LD_EXP 55
74188: PUSH
74189: LD_VAR 0 2
74193: ARRAY
74194: PUSH
74195: LD_INT 1
74197: ARRAY
74198: IN
74199: NOT
74200: PUSH
74201: LD_VAR 0 3
74205: PUSH
74206: LD_EXP 55
74210: PUSH
74211: LD_VAR 0 2
74215: ARRAY
74216: PUSH
74217: LD_INT 2
74219: ARRAY
74220: IN
74221: NOT
74222: AND
74223: IFFALSE 74234
// ComSpaceTimeShoot ( j ) ;
74225: LD_VAR 0 3
74229: PPUSH
74230: CALL 12005 0 1
74234: GO 74176
74236: POP
74237: POP
// end ;
74238: GO 74079
74240: POP
74241: POP
// end ;
74242: LD_VAR 0 1
74246: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
74247: LD_INT 0
74249: PPUSH
74250: PPUSH
74251: PPUSH
74252: PPUSH
74253: PPUSH
74254: PPUSH
74255: PPUSH
74256: PPUSH
74257: PPUSH
// if not mc_bases then
74258: LD_EXP 52
74262: NOT
74263: IFFALSE 74267
// exit ;
74265: GO 74889
// for i = 1 to mc_bases do
74267: LD_ADDR_VAR 0 2
74271: PUSH
74272: DOUBLE
74273: LD_INT 1
74275: DEC
74276: ST_TO_ADDR
74277: LD_EXP 52
74281: PUSH
74282: FOR_TO
74283: IFFALSE 74887
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
74285: LD_EXP 87
74289: PUSH
74290: LD_VAR 0 2
74294: ARRAY
74295: NOT
74296: PUSH
74297: LD_INT 38
74299: PPUSH
74300: LD_EXP 78
74304: PUSH
74305: LD_VAR 0 2
74309: ARRAY
74310: PPUSH
74311: CALL_OW 321
74315: PUSH
74316: LD_INT 2
74318: NONEQUAL
74319: OR
74320: IFFALSE 74324
// continue ;
74322: GO 74282
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
74324: LD_ADDR_VAR 0 8
74328: PUSH
74329: LD_EXP 52
74333: PUSH
74334: LD_VAR 0 2
74338: ARRAY
74339: PPUSH
74340: LD_INT 30
74342: PUSH
74343: LD_INT 34
74345: PUSH
74346: EMPTY
74347: LIST
74348: LIST
74349: PPUSH
74350: CALL_OW 72
74354: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
74355: LD_ADDR_VAR 0 9
74359: PUSH
74360: LD_EXP 52
74364: PUSH
74365: LD_VAR 0 2
74369: ARRAY
74370: PPUSH
74371: LD_INT 25
74373: PUSH
74374: LD_INT 4
74376: PUSH
74377: EMPTY
74378: LIST
74379: LIST
74380: PPUSH
74381: CALL_OW 72
74385: PPUSH
74386: LD_INT 0
74388: PPUSH
74389: CALL 51689 0 2
74393: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
74394: LD_VAR 0 9
74398: NOT
74399: PUSH
74400: LD_VAR 0 8
74404: NOT
74405: OR
74406: PUSH
74407: LD_EXP 52
74411: PUSH
74412: LD_VAR 0 2
74416: ARRAY
74417: PPUSH
74418: LD_INT 124
74420: PPUSH
74421: CALL 51689 0 2
74425: OR
74426: IFFALSE 74430
// continue ;
74428: GO 74282
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
74430: LD_EXP 88
74434: PUSH
74435: LD_VAR 0 2
74439: ARRAY
74440: PUSH
74441: LD_EXP 87
74445: PUSH
74446: LD_VAR 0 2
74450: ARRAY
74451: LESS
74452: PUSH
74453: LD_EXP 88
74457: PUSH
74458: LD_VAR 0 2
74462: ARRAY
74463: PUSH
74464: LD_VAR 0 8
74468: LESS
74469: AND
74470: IFFALSE 74885
// begin tmp := sci [ 1 ] ;
74472: LD_ADDR_VAR 0 7
74476: PUSH
74477: LD_VAR 0 9
74481: PUSH
74482: LD_INT 1
74484: ARRAY
74485: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
74486: LD_VAR 0 7
74490: PPUSH
74491: LD_INT 124
74493: PPUSH
74494: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
74498: LD_ADDR_VAR 0 3
74502: PUSH
74503: DOUBLE
74504: LD_EXP 87
74508: PUSH
74509: LD_VAR 0 2
74513: ARRAY
74514: INC
74515: ST_TO_ADDR
74516: LD_EXP 87
74520: PUSH
74521: LD_VAR 0 2
74525: ARRAY
74526: PUSH
74527: FOR_DOWNTO
74528: IFFALSE 74871
// begin if IsInUnit ( tmp ) then
74530: LD_VAR 0 7
74534: PPUSH
74535: CALL_OW 310
74539: IFFALSE 74550
// ComExitBuilding ( tmp ) ;
74541: LD_VAR 0 7
74545: PPUSH
74546: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
74550: LD_INT 35
74552: PPUSH
74553: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
74557: LD_VAR 0 7
74561: PPUSH
74562: CALL_OW 310
74566: NOT
74567: PUSH
74568: LD_VAR 0 7
74572: PPUSH
74573: CALL_OW 314
74577: NOT
74578: AND
74579: IFFALSE 74550
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
74581: LD_ADDR_VAR 0 6
74585: PUSH
74586: LD_VAR 0 7
74590: PPUSH
74591: CALL_OW 250
74595: PUSH
74596: LD_VAR 0 7
74600: PPUSH
74601: CALL_OW 251
74605: PUSH
74606: EMPTY
74607: LIST
74608: LIST
74609: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74610: LD_INT 35
74612: PPUSH
74613: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
74617: LD_ADDR_VAR 0 4
74621: PUSH
74622: LD_EXP 87
74626: PUSH
74627: LD_VAR 0 2
74631: ARRAY
74632: PUSH
74633: LD_VAR 0 3
74637: ARRAY
74638: PUSH
74639: LD_INT 1
74641: ARRAY
74642: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
74643: LD_ADDR_VAR 0 5
74647: PUSH
74648: LD_EXP 87
74652: PUSH
74653: LD_VAR 0 2
74657: ARRAY
74658: PUSH
74659: LD_VAR 0 3
74663: ARRAY
74664: PUSH
74665: LD_INT 2
74667: ARRAY
74668: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
74669: LD_VAR 0 7
74673: PPUSH
74674: LD_INT 10
74676: PPUSH
74677: CALL 21012 0 2
74681: PUSH
74682: LD_INT 4
74684: ARRAY
74685: IFFALSE 74723
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
74687: LD_VAR 0 7
74691: PPUSH
74692: LD_VAR 0 6
74696: PUSH
74697: LD_INT 1
74699: ARRAY
74700: PPUSH
74701: LD_VAR 0 6
74705: PUSH
74706: LD_INT 2
74708: ARRAY
74709: PPUSH
74710: CALL_OW 111
// wait ( 0 0$10 ) ;
74714: LD_INT 350
74716: PPUSH
74717: CALL_OW 67
// end else
74721: GO 74749
// begin ComMoveXY ( tmp , x , y ) ;
74723: LD_VAR 0 7
74727: PPUSH
74728: LD_VAR 0 4
74732: PPUSH
74733: LD_VAR 0 5
74737: PPUSH
74738: CALL_OW 111
// wait ( 0 0$3 ) ;
74742: LD_INT 105
74744: PPUSH
74745: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
74749: LD_VAR 0 7
74753: PPUSH
74754: LD_VAR 0 4
74758: PPUSH
74759: LD_VAR 0 5
74763: PPUSH
74764: CALL_OW 307
74768: IFFALSE 74610
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
74770: LD_VAR 0 7
74774: PPUSH
74775: LD_VAR 0 4
74779: PPUSH
74780: LD_VAR 0 5
74784: PPUSH
74785: LD_VAR 0 8
74789: PUSH
74790: LD_VAR 0 3
74794: ARRAY
74795: PPUSH
74796: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
74800: LD_INT 35
74802: PPUSH
74803: CALL_OW 67
// until not HasTask ( tmp ) ;
74807: LD_VAR 0 7
74811: PPUSH
74812: CALL_OW 314
74816: NOT
74817: IFFALSE 74800
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
74819: LD_ADDR_EXP 88
74823: PUSH
74824: LD_EXP 88
74828: PPUSH
74829: LD_VAR 0 2
74833: PUSH
74834: LD_EXP 88
74838: PUSH
74839: LD_VAR 0 2
74843: ARRAY
74844: PUSH
74845: LD_INT 1
74847: PLUS
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PPUSH
74853: LD_VAR 0 8
74857: PUSH
74858: LD_VAR 0 3
74862: ARRAY
74863: PPUSH
74864: CALL 18419 0 3
74868: ST_TO_ADDR
// end ;
74869: GO 74527
74871: POP
74872: POP
// MC_Reset ( i , 124 ) ;
74873: LD_VAR 0 2
74877: PPUSH
74878: LD_INT 124
74880: PPUSH
74881: CALL 58476 0 2
// end ; end ;
74885: GO 74282
74887: POP
74888: POP
// end ;
74889: LD_VAR 0 1
74893: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
74894: LD_INT 0
74896: PPUSH
74897: PPUSH
74898: PPUSH
// if not mc_bases then
74899: LD_EXP 52
74903: NOT
74904: IFFALSE 74908
// exit ;
74906: GO 75514
// for i = 1 to mc_bases do
74908: LD_ADDR_VAR 0 2
74912: PUSH
74913: DOUBLE
74914: LD_INT 1
74916: DEC
74917: ST_TO_ADDR
74918: LD_EXP 52
74922: PUSH
74923: FOR_TO
74924: IFFALSE 75512
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
74926: LD_ADDR_VAR 0 3
74930: PUSH
74931: LD_EXP 52
74935: PUSH
74936: LD_VAR 0 2
74940: ARRAY
74941: PPUSH
74942: LD_INT 25
74944: PUSH
74945: LD_INT 4
74947: PUSH
74948: EMPTY
74949: LIST
74950: LIST
74951: PPUSH
74952: CALL_OW 72
74956: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
74957: LD_VAR 0 3
74961: NOT
74962: PUSH
74963: LD_EXP 89
74967: PUSH
74968: LD_VAR 0 2
74972: ARRAY
74973: NOT
74974: OR
74975: PUSH
74976: LD_EXP 52
74980: PUSH
74981: LD_VAR 0 2
74985: ARRAY
74986: PPUSH
74987: LD_INT 2
74989: PUSH
74990: LD_INT 30
74992: PUSH
74993: LD_INT 0
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: PUSH
75000: LD_INT 30
75002: PUSH
75003: LD_INT 1
75005: PUSH
75006: EMPTY
75007: LIST
75008: LIST
75009: PUSH
75010: EMPTY
75011: LIST
75012: LIST
75013: LIST
75014: PPUSH
75015: CALL_OW 72
75019: NOT
75020: OR
75021: IFFALSE 75071
// begin if mc_deposits_finder [ i ] then
75023: LD_EXP 90
75027: PUSH
75028: LD_VAR 0 2
75032: ARRAY
75033: IFFALSE 75069
// begin MC_Reset ( i , 125 ) ;
75035: LD_VAR 0 2
75039: PPUSH
75040: LD_INT 125
75042: PPUSH
75043: CALL 58476 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75047: LD_ADDR_EXP 90
75051: PUSH
75052: LD_EXP 90
75056: PPUSH
75057: LD_VAR 0 2
75061: PPUSH
75062: EMPTY
75063: PPUSH
75064: CALL_OW 1
75068: ST_TO_ADDR
// end ; continue ;
75069: GO 74923
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
75071: LD_EXP 89
75075: PUSH
75076: LD_VAR 0 2
75080: ARRAY
75081: PUSH
75082: LD_INT 1
75084: ARRAY
75085: PUSH
75086: LD_INT 3
75088: ARRAY
75089: PUSH
75090: LD_INT 1
75092: EQUAL
75093: PUSH
75094: LD_INT 20
75096: PPUSH
75097: LD_EXP 78
75101: PUSH
75102: LD_VAR 0 2
75106: ARRAY
75107: PPUSH
75108: CALL_OW 321
75112: PUSH
75113: LD_INT 2
75115: NONEQUAL
75116: AND
75117: IFFALSE 75167
// begin if mc_deposits_finder [ i ] then
75119: LD_EXP 90
75123: PUSH
75124: LD_VAR 0 2
75128: ARRAY
75129: IFFALSE 75165
// begin MC_Reset ( i , 125 ) ;
75131: LD_VAR 0 2
75135: PPUSH
75136: LD_INT 125
75138: PPUSH
75139: CALL 58476 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75143: LD_ADDR_EXP 90
75147: PUSH
75148: LD_EXP 90
75152: PPUSH
75153: LD_VAR 0 2
75157: PPUSH
75158: EMPTY
75159: PPUSH
75160: CALL_OW 1
75164: ST_TO_ADDR
// end ; continue ;
75165: GO 74923
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
75167: LD_EXP 89
75171: PUSH
75172: LD_VAR 0 2
75176: ARRAY
75177: PUSH
75178: LD_INT 1
75180: ARRAY
75181: PUSH
75182: LD_INT 1
75184: ARRAY
75185: PPUSH
75186: LD_EXP 89
75190: PUSH
75191: LD_VAR 0 2
75195: ARRAY
75196: PUSH
75197: LD_INT 1
75199: ARRAY
75200: PUSH
75201: LD_INT 2
75203: ARRAY
75204: PPUSH
75205: LD_EXP 78
75209: PUSH
75210: LD_VAR 0 2
75214: ARRAY
75215: PPUSH
75216: CALL_OW 440
75220: IFFALSE 75263
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
75222: LD_ADDR_EXP 89
75226: PUSH
75227: LD_EXP 89
75231: PPUSH
75232: LD_VAR 0 2
75236: PPUSH
75237: LD_EXP 89
75241: PUSH
75242: LD_VAR 0 2
75246: ARRAY
75247: PPUSH
75248: LD_INT 1
75250: PPUSH
75251: CALL_OW 3
75255: PPUSH
75256: CALL_OW 1
75260: ST_TO_ADDR
75261: GO 75510
// begin if not mc_deposits_finder [ i ] then
75263: LD_EXP 90
75267: PUSH
75268: LD_VAR 0 2
75272: ARRAY
75273: NOT
75274: IFFALSE 75326
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
75276: LD_ADDR_EXP 90
75280: PUSH
75281: LD_EXP 90
75285: PPUSH
75286: LD_VAR 0 2
75290: PPUSH
75291: LD_VAR 0 3
75295: PUSH
75296: LD_INT 1
75298: ARRAY
75299: PUSH
75300: EMPTY
75301: LIST
75302: PPUSH
75303: CALL_OW 1
75307: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
75308: LD_VAR 0 3
75312: PUSH
75313: LD_INT 1
75315: ARRAY
75316: PPUSH
75317: LD_INT 125
75319: PPUSH
75320: CALL_OW 109
// end else
75324: GO 75510
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
75326: LD_EXP 90
75330: PUSH
75331: LD_VAR 0 2
75335: ARRAY
75336: PUSH
75337: LD_INT 1
75339: ARRAY
75340: PPUSH
75341: CALL_OW 310
75345: IFFALSE 75368
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
75347: LD_EXP 90
75351: PUSH
75352: LD_VAR 0 2
75356: ARRAY
75357: PUSH
75358: LD_INT 1
75360: ARRAY
75361: PPUSH
75362: CALL_OW 122
75366: GO 75510
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
75368: LD_EXP 90
75372: PUSH
75373: LD_VAR 0 2
75377: ARRAY
75378: PUSH
75379: LD_INT 1
75381: ARRAY
75382: PPUSH
75383: CALL_OW 314
75387: NOT
75388: PUSH
75389: LD_EXP 90
75393: PUSH
75394: LD_VAR 0 2
75398: ARRAY
75399: PUSH
75400: LD_INT 1
75402: ARRAY
75403: PPUSH
75404: LD_EXP 89
75408: PUSH
75409: LD_VAR 0 2
75413: ARRAY
75414: PUSH
75415: LD_INT 1
75417: ARRAY
75418: PUSH
75419: LD_INT 1
75421: ARRAY
75422: PPUSH
75423: LD_EXP 89
75427: PUSH
75428: LD_VAR 0 2
75432: ARRAY
75433: PUSH
75434: LD_INT 1
75436: ARRAY
75437: PUSH
75438: LD_INT 2
75440: ARRAY
75441: PPUSH
75442: CALL_OW 297
75446: PUSH
75447: LD_INT 6
75449: GREATER
75450: AND
75451: IFFALSE 75510
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
75453: LD_EXP 90
75457: PUSH
75458: LD_VAR 0 2
75462: ARRAY
75463: PUSH
75464: LD_INT 1
75466: ARRAY
75467: PPUSH
75468: LD_EXP 89
75472: PUSH
75473: LD_VAR 0 2
75477: ARRAY
75478: PUSH
75479: LD_INT 1
75481: ARRAY
75482: PUSH
75483: LD_INT 1
75485: ARRAY
75486: PPUSH
75487: LD_EXP 89
75491: PUSH
75492: LD_VAR 0 2
75496: ARRAY
75497: PUSH
75498: LD_INT 1
75500: ARRAY
75501: PUSH
75502: LD_INT 2
75504: ARRAY
75505: PPUSH
75506: CALL_OW 111
// end ; end ; end ;
75510: GO 74923
75512: POP
75513: POP
// end ;
75514: LD_VAR 0 1
75518: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
75519: LD_INT 0
75521: PPUSH
75522: PPUSH
75523: PPUSH
75524: PPUSH
75525: PPUSH
75526: PPUSH
75527: PPUSH
75528: PPUSH
75529: PPUSH
75530: PPUSH
75531: PPUSH
// if not mc_bases then
75532: LD_EXP 52
75536: NOT
75537: IFFALSE 75541
// exit ;
75539: GO 76481
// for i = 1 to mc_bases do
75541: LD_ADDR_VAR 0 2
75545: PUSH
75546: DOUBLE
75547: LD_INT 1
75549: DEC
75550: ST_TO_ADDR
75551: LD_EXP 52
75555: PUSH
75556: FOR_TO
75557: IFFALSE 76479
// begin if not mc_bases [ i ] or mc_scan [ i ] then
75559: LD_EXP 52
75563: PUSH
75564: LD_VAR 0 2
75568: ARRAY
75569: NOT
75570: PUSH
75571: LD_EXP 75
75575: PUSH
75576: LD_VAR 0 2
75580: ARRAY
75581: OR
75582: IFFALSE 75586
// continue ;
75584: GO 75556
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
75586: LD_ADDR_VAR 0 7
75590: PUSH
75591: LD_EXP 52
75595: PUSH
75596: LD_VAR 0 2
75600: ARRAY
75601: PUSH
75602: LD_INT 1
75604: ARRAY
75605: PPUSH
75606: CALL_OW 248
75610: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
75611: LD_VAR 0 7
75615: PUSH
75616: LD_INT 3
75618: EQUAL
75619: PUSH
75620: LD_EXP 71
75624: PUSH
75625: LD_VAR 0 2
75629: ARRAY
75630: PUSH
75631: LD_EXP 74
75635: PUSH
75636: LD_VAR 0 2
75640: ARRAY
75641: UNION
75642: PPUSH
75643: LD_INT 33
75645: PUSH
75646: LD_INT 2
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PPUSH
75653: CALL_OW 72
75657: NOT
75658: OR
75659: IFFALSE 75663
// continue ;
75661: GO 75556
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
75663: LD_ADDR_VAR 0 9
75667: PUSH
75668: LD_EXP 52
75672: PUSH
75673: LD_VAR 0 2
75677: ARRAY
75678: PPUSH
75679: LD_INT 30
75681: PUSH
75682: LD_INT 36
75684: PUSH
75685: EMPTY
75686: LIST
75687: LIST
75688: PPUSH
75689: CALL_OW 72
75693: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
75694: LD_ADDR_VAR 0 10
75698: PUSH
75699: LD_EXP 71
75703: PUSH
75704: LD_VAR 0 2
75708: ARRAY
75709: PPUSH
75710: LD_INT 34
75712: PUSH
75713: LD_INT 31
75715: PUSH
75716: EMPTY
75717: LIST
75718: LIST
75719: PPUSH
75720: CALL_OW 72
75724: ST_TO_ADDR
// if not cts and not mcts then
75725: LD_VAR 0 9
75729: NOT
75730: PUSH
75731: LD_VAR 0 10
75735: NOT
75736: AND
75737: IFFALSE 75741
// continue ;
75739: GO 75556
// x := cts ;
75741: LD_ADDR_VAR 0 11
75745: PUSH
75746: LD_VAR 0 9
75750: ST_TO_ADDR
// if not x then
75751: LD_VAR 0 11
75755: NOT
75756: IFFALSE 75768
// x := mcts ;
75758: LD_ADDR_VAR 0 11
75762: PUSH
75763: LD_VAR 0 10
75767: ST_TO_ADDR
// if not x then
75768: LD_VAR 0 11
75772: NOT
75773: IFFALSE 75777
// continue ;
75775: GO 75556
// if mc_remote_driver [ i ] then
75777: LD_EXP 92
75781: PUSH
75782: LD_VAR 0 2
75786: ARRAY
75787: IFFALSE 76174
// for j in mc_remote_driver [ i ] do
75789: LD_ADDR_VAR 0 3
75793: PUSH
75794: LD_EXP 92
75798: PUSH
75799: LD_VAR 0 2
75803: ARRAY
75804: PUSH
75805: FOR_IN
75806: IFFALSE 76172
// begin if GetClass ( j ) <> 3 then
75808: LD_VAR 0 3
75812: PPUSH
75813: CALL_OW 257
75817: PUSH
75818: LD_INT 3
75820: NONEQUAL
75821: IFFALSE 75874
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
75823: LD_ADDR_EXP 92
75827: PUSH
75828: LD_EXP 92
75832: PPUSH
75833: LD_VAR 0 2
75837: PPUSH
75838: LD_EXP 92
75842: PUSH
75843: LD_VAR 0 2
75847: ARRAY
75848: PUSH
75849: LD_VAR 0 3
75853: DIFF
75854: PPUSH
75855: CALL_OW 1
75859: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75860: LD_VAR 0 3
75864: PPUSH
75865: LD_INT 0
75867: PPUSH
75868: CALL_OW 109
// continue ;
75872: GO 75805
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
75874: LD_EXP 71
75878: PUSH
75879: LD_VAR 0 2
75883: ARRAY
75884: PPUSH
75885: LD_INT 34
75887: PUSH
75888: LD_INT 31
75890: PUSH
75891: EMPTY
75892: LIST
75893: LIST
75894: PUSH
75895: LD_INT 58
75897: PUSH
75898: EMPTY
75899: LIST
75900: PUSH
75901: EMPTY
75902: LIST
75903: LIST
75904: PPUSH
75905: CALL_OW 72
75909: PUSH
75910: LD_VAR 0 3
75914: PPUSH
75915: CALL 51777 0 1
75919: NOT
75920: AND
75921: IFFALSE 75992
// begin if IsInUnit ( j ) then
75923: LD_VAR 0 3
75927: PPUSH
75928: CALL_OW 310
75932: IFFALSE 75943
// ComExitBuilding ( j ) ;
75934: LD_VAR 0 3
75938: PPUSH
75939: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
75943: LD_VAR 0 3
75947: PPUSH
75948: LD_EXP 71
75952: PUSH
75953: LD_VAR 0 2
75957: ARRAY
75958: PPUSH
75959: LD_INT 34
75961: PUSH
75962: LD_INT 31
75964: PUSH
75965: EMPTY
75966: LIST
75967: LIST
75968: PUSH
75969: LD_INT 58
75971: PUSH
75972: EMPTY
75973: LIST
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: PPUSH
75979: CALL_OW 72
75983: PUSH
75984: LD_INT 1
75986: ARRAY
75987: PPUSH
75988: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
75992: LD_VAR 0 3
75996: PPUSH
75997: CALL_OW 310
76001: NOT
76002: PUSH
76003: LD_VAR 0 3
76007: PPUSH
76008: CALL_OW 310
76012: PPUSH
76013: CALL_OW 266
76017: PUSH
76018: LD_INT 36
76020: NONEQUAL
76021: PUSH
76022: LD_VAR 0 3
76026: PPUSH
76027: CALL 51777 0 1
76031: NOT
76032: AND
76033: OR
76034: IFFALSE 76170
// begin if IsInUnit ( j ) then
76036: LD_VAR 0 3
76040: PPUSH
76041: CALL_OW 310
76045: IFFALSE 76056
// ComExitBuilding ( j ) ;
76047: LD_VAR 0 3
76051: PPUSH
76052: CALL_OW 122
// ct := 0 ;
76056: LD_ADDR_VAR 0 8
76060: PUSH
76061: LD_INT 0
76063: ST_TO_ADDR
// for k in x do
76064: LD_ADDR_VAR 0 4
76068: PUSH
76069: LD_VAR 0 11
76073: PUSH
76074: FOR_IN
76075: IFFALSE 76148
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
76077: LD_VAR 0 4
76081: PPUSH
76082: CALL_OW 264
76086: PUSH
76087: LD_INT 31
76089: EQUAL
76090: PUSH
76091: LD_VAR 0 4
76095: PPUSH
76096: CALL_OW 311
76100: NOT
76101: AND
76102: PUSH
76103: LD_VAR 0 4
76107: PPUSH
76108: CALL_OW 266
76112: PUSH
76113: LD_INT 36
76115: EQUAL
76116: PUSH
76117: LD_VAR 0 4
76121: PPUSH
76122: CALL_OW 313
76126: PUSH
76127: LD_INT 3
76129: LESS
76130: AND
76131: OR
76132: IFFALSE 76146
// begin ct := k ;
76134: LD_ADDR_VAR 0 8
76138: PUSH
76139: LD_VAR 0 4
76143: ST_TO_ADDR
// break ;
76144: GO 76148
// end ;
76146: GO 76074
76148: POP
76149: POP
// if ct then
76150: LD_VAR 0 8
76154: IFFALSE 76170
// ComEnterUnit ( j , ct ) ;
76156: LD_VAR 0 3
76160: PPUSH
76161: LD_VAR 0 8
76165: PPUSH
76166: CALL_OW 120
// end ; end ;
76170: GO 75805
76172: POP
76173: POP
// places := 0 ;
76174: LD_ADDR_VAR 0 5
76178: PUSH
76179: LD_INT 0
76181: ST_TO_ADDR
// for j = 1 to x do
76182: LD_ADDR_VAR 0 3
76186: PUSH
76187: DOUBLE
76188: LD_INT 1
76190: DEC
76191: ST_TO_ADDR
76192: LD_VAR 0 11
76196: PUSH
76197: FOR_TO
76198: IFFALSE 76274
// if GetWeapon ( x [ j ] ) = ar_control_tower then
76200: LD_VAR 0 11
76204: PUSH
76205: LD_VAR 0 3
76209: ARRAY
76210: PPUSH
76211: CALL_OW 264
76215: PUSH
76216: LD_INT 31
76218: EQUAL
76219: IFFALSE 76237
// places := places + 1 else
76221: LD_ADDR_VAR 0 5
76225: PUSH
76226: LD_VAR 0 5
76230: PUSH
76231: LD_INT 1
76233: PLUS
76234: ST_TO_ADDR
76235: GO 76272
// if GetBType ( x [ j ] ) = b_control_tower then
76237: LD_VAR 0 11
76241: PUSH
76242: LD_VAR 0 3
76246: ARRAY
76247: PPUSH
76248: CALL_OW 266
76252: PUSH
76253: LD_INT 36
76255: EQUAL
76256: IFFALSE 76272
// places := places + 3 ;
76258: LD_ADDR_VAR 0 5
76262: PUSH
76263: LD_VAR 0 5
76267: PUSH
76268: LD_INT 3
76270: PLUS
76271: ST_TO_ADDR
76272: GO 76197
76274: POP
76275: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
76276: LD_VAR 0 5
76280: PUSH
76281: LD_INT 0
76283: EQUAL
76284: PUSH
76285: LD_VAR 0 5
76289: PUSH
76290: LD_EXP 92
76294: PUSH
76295: LD_VAR 0 2
76299: ARRAY
76300: LESSEQUAL
76301: OR
76302: IFFALSE 76306
// continue ;
76304: GO 75556
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
76306: LD_ADDR_VAR 0 6
76310: PUSH
76311: LD_EXP 52
76315: PUSH
76316: LD_VAR 0 2
76320: ARRAY
76321: PPUSH
76322: LD_INT 25
76324: PUSH
76325: LD_INT 3
76327: PUSH
76328: EMPTY
76329: LIST
76330: LIST
76331: PPUSH
76332: CALL_OW 72
76336: PUSH
76337: LD_EXP 92
76341: PUSH
76342: LD_VAR 0 2
76346: ARRAY
76347: DIFF
76348: PPUSH
76349: LD_INT 3
76351: PPUSH
76352: CALL 52677 0 2
76356: ST_TO_ADDR
// for j in tmp do
76357: LD_ADDR_VAR 0 3
76361: PUSH
76362: LD_VAR 0 6
76366: PUSH
76367: FOR_IN
76368: IFFALSE 76403
// if GetTag ( j ) > 0 then
76370: LD_VAR 0 3
76374: PPUSH
76375: CALL_OW 110
76379: PUSH
76380: LD_INT 0
76382: GREATER
76383: IFFALSE 76401
// tmp := tmp diff j ;
76385: LD_ADDR_VAR 0 6
76389: PUSH
76390: LD_VAR 0 6
76394: PUSH
76395: LD_VAR 0 3
76399: DIFF
76400: ST_TO_ADDR
76401: GO 76367
76403: POP
76404: POP
// if not tmp then
76405: LD_VAR 0 6
76409: NOT
76410: IFFALSE 76414
// continue ;
76412: GO 75556
// if places then
76414: LD_VAR 0 5
76418: IFFALSE 76477
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
76420: LD_ADDR_EXP 92
76424: PUSH
76425: LD_EXP 92
76429: PPUSH
76430: LD_VAR 0 2
76434: PPUSH
76435: LD_EXP 92
76439: PUSH
76440: LD_VAR 0 2
76444: ARRAY
76445: PUSH
76446: LD_VAR 0 6
76450: PUSH
76451: LD_INT 1
76453: ARRAY
76454: UNION
76455: PPUSH
76456: CALL_OW 1
76460: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
76461: LD_VAR 0 6
76465: PUSH
76466: LD_INT 1
76468: ARRAY
76469: PPUSH
76470: LD_INT 126
76472: PPUSH
76473: CALL_OW 109
// end ; end ;
76477: GO 75556
76479: POP
76480: POP
// end ;
76481: LD_VAR 0 1
76485: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
76486: LD_INT 0
76488: PPUSH
76489: PPUSH
76490: PPUSH
76491: PPUSH
76492: PPUSH
76493: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
76494: LD_VAR 0 1
76498: NOT
76499: PUSH
76500: LD_VAR 0 2
76504: NOT
76505: OR
76506: PUSH
76507: LD_VAR 0 3
76511: NOT
76512: OR
76513: PUSH
76514: LD_VAR 0 4
76518: PUSH
76519: LD_INT 1
76521: PUSH
76522: LD_INT 2
76524: PUSH
76525: LD_INT 3
76527: PUSH
76528: LD_INT 4
76530: PUSH
76531: LD_INT 5
76533: PUSH
76534: LD_INT 8
76536: PUSH
76537: LD_INT 9
76539: PUSH
76540: LD_INT 15
76542: PUSH
76543: LD_INT 16
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: LIST
76550: LIST
76551: LIST
76552: LIST
76553: LIST
76554: LIST
76555: LIST
76556: IN
76557: NOT
76558: OR
76559: IFFALSE 76563
// exit ;
76561: GO 77463
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
76563: LD_ADDR_VAR 0 2
76567: PUSH
76568: LD_VAR 0 2
76572: PPUSH
76573: LD_INT 21
76575: PUSH
76576: LD_INT 3
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: PUSH
76583: LD_INT 24
76585: PUSH
76586: LD_INT 250
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: PUSH
76593: EMPTY
76594: LIST
76595: LIST
76596: PPUSH
76597: CALL_OW 72
76601: ST_TO_ADDR
// case class of 1 , 15 :
76602: LD_VAR 0 4
76606: PUSH
76607: LD_INT 1
76609: DOUBLE
76610: EQUAL
76611: IFTRUE 76621
76613: LD_INT 15
76615: DOUBLE
76616: EQUAL
76617: IFTRUE 76621
76619: GO 76706
76621: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
76622: LD_ADDR_VAR 0 8
76626: PUSH
76627: LD_VAR 0 2
76631: PPUSH
76632: LD_INT 2
76634: PUSH
76635: LD_INT 30
76637: PUSH
76638: LD_INT 32
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PUSH
76645: LD_INT 30
76647: PUSH
76648: LD_INT 31
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: PUSH
76655: EMPTY
76656: LIST
76657: LIST
76658: LIST
76659: PPUSH
76660: CALL_OW 72
76664: PUSH
76665: LD_VAR 0 2
76669: PPUSH
76670: LD_INT 2
76672: PUSH
76673: LD_INT 30
76675: PUSH
76676: LD_INT 4
76678: PUSH
76679: EMPTY
76680: LIST
76681: LIST
76682: PUSH
76683: LD_INT 30
76685: PUSH
76686: LD_INT 5
76688: PUSH
76689: EMPTY
76690: LIST
76691: LIST
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: LIST
76697: PPUSH
76698: CALL_OW 72
76702: ADD
76703: ST_TO_ADDR
76704: GO 76952
76706: LD_INT 2
76708: DOUBLE
76709: EQUAL
76710: IFTRUE 76720
76712: LD_INT 16
76714: DOUBLE
76715: EQUAL
76716: IFTRUE 76720
76718: GO 76766
76720: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
76721: LD_ADDR_VAR 0 8
76725: PUSH
76726: LD_VAR 0 2
76730: PPUSH
76731: LD_INT 2
76733: PUSH
76734: LD_INT 30
76736: PUSH
76737: LD_INT 0
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 30
76746: PUSH
76747: LD_INT 1
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: LIST
76758: PPUSH
76759: CALL_OW 72
76763: ST_TO_ADDR
76764: GO 76952
76766: LD_INT 3
76768: DOUBLE
76769: EQUAL
76770: IFTRUE 76774
76772: GO 76820
76774: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
76775: LD_ADDR_VAR 0 8
76779: PUSH
76780: LD_VAR 0 2
76784: PPUSH
76785: LD_INT 2
76787: PUSH
76788: LD_INT 30
76790: PUSH
76791: LD_INT 2
76793: PUSH
76794: EMPTY
76795: LIST
76796: LIST
76797: PUSH
76798: LD_INT 30
76800: PUSH
76801: LD_INT 3
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: EMPTY
76809: LIST
76810: LIST
76811: LIST
76812: PPUSH
76813: CALL_OW 72
76817: ST_TO_ADDR
76818: GO 76952
76820: LD_INT 4
76822: DOUBLE
76823: EQUAL
76824: IFTRUE 76828
76826: GO 76885
76828: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
76829: LD_ADDR_VAR 0 8
76833: PUSH
76834: LD_VAR 0 2
76838: PPUSH
76839: LD_INT 2
76841: PUSH
76842: LD_INT 30
76844: PUSH
76845: LD_INT 6
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: PUSH
76852: LD_INT 30
76854: PUSH
76855: LD_INT 7
76857: PUSH
76858: EMPTY
76859: LIST
76860: LIST
76861: PUSH
76862: LD_INT 30
76864: PUSH
76865: LD_INT 8
76867: PUSH
76868: EMPTY
76869: LIST
76870: LIST
76871: PUSH
76872: EMPTY
76873: LIST
76874: LIST
76875: LIST
76876: LIST
76877: PPUSH
76878: CALL_OW 72
76882: ST_TO_ADDR
76883: GO 76952
76885: LD_INT 5
76887: DOUBLE
76888: EQUAL
76889: IFTRUE 76905
76891: LD_INT 8
76893: DOUBLE
76894: EQUAL
76895: IFTRUE 76905
76897: LD_INT 9
76899: DOUBLE
76900: EQUAL
76901: IFTRUE 76905
76903: GO 76951
76905: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
76906: LD_ADDR_VAR 0 8
76910: PUSH
76911: LD_VAR 0 2
76915: PPUSH
76916: LD_INT 2
76918: PUSH
76919: LD_INT 30
76921: PUSH
76922: LD_INT 4
76924: PUSH
76925: EMPTY
76926: LIST
76927: LIST
76928: PUSH
76929: LD_INT 30
76931: PUSH
76932: LD_INT 5
76934: PUSH
76935: EMPTY
76936: LIST
76937: LIST
76938: PUSH
76939: EMPTY
76940: LIST
76941: LIST
76942: LIST
76943: PPUSH
76944: CALL_OW 72
76948: ST_TO_ADDR
76949: GO 76952
76951: POP
// if not tmp then
76952: LD_VAR 0 8
76956: NOT
76957: IFFALSE 76961
// exit ;
76959: GO 77463
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
76961: LD_VAR 0 4
76965: PUSH
76966: LD_INT 1
76968: PUSH
76969: LD_INT 15
76971: PUSH
76972: EMPTY
76973: LIST
76974: LIST
76975: IN
76976: PUSH
76977: LD_EXP 61
76981: PUSH
76982: LD_VAR 0 1
76986: ARRAY
76987: AND
76988: IFFALSE 77144
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
76990: LD_ADDR_VAR 0 9
76994: PUSH
76995: LD_EXP 61
76999: PUSH
77000: LD_VAR 0 1
77004: ARRAY
77005: PUSH
77006: LD_INT 1
77008: ARRAY
77009: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
77010: LD_VAR 0 9
77014: PUSH
77015: LD_EXP 62
77019: PUSH
77020: LD_VAR 0 1
77024: ARRAY
77025: IN
77026: NOT
77027: IFFALSE 77142
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
77029: LD_ADDR_EXP 62
77033: PUSH
77034: LD_EXP 62
77038: PPUSH
77039: LD_VAR 0 1
77043: PUSH
77044: LD_EXP 62
77048: PUSH
77049: LD_VAR 0 1
77053: ARRAY
77054: PUSH
77055: LD_INT 1
77057: PLUS
77058: PUSH
77059: EMPTY
77060: LIST
77061: LIST
77062: PPUSH
77063: LD_VAR 0 9
77067: PPUSH
77068: CALL 18419 0 3
77072: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
77073: LD_ADDR_EXP 61
77077: PUSH
77078: LD_EXP 61
77082: PPUSH
77083: LD_VAR 0 1
77087: PPUSH
77088: LD_EXP 61
77092: PUSH
77093: LD_VAR 0 1
77097: ARRAY
77098: PUSH
77099: LD_VAR 0 9
77103: DIFF
77104: PPUSH
77105: CALL_OW 1
77109: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
77110: LD_VAR 0 3
77114: PPUSH
77115: LD_EXP 62
77119: PUSH
77120: LD_VAR 0 1
77124: ARRAY
77125: PUSH
77126: LD_EXP 62
77130: PUSH
77131: LD_VAR 0 1
77135: ARRAY
77136: ARRAY
77137: PPUSH
77138: CALL_OW 120
// end ; exit ;
77142: GO 77463
// end ; if tmp > 1 then
77144: LD_VAR 0 8
77148: PUSH
77149: LD_INT 1
77151: GREATER
77152: IFFALSE 77256
// for i = 2 to tmp do
77154: LD_ADDR_VAR 0 6
77158: PUSH
77159: DOUBLE
77160: LD_INT 2
77162: DEC
77163: ST_TO_ADDR
77164: LD_VAR 0 8
77168: PUSH
77169: FOR_TO
77170: IFFALSE 77254
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
77172: LD_VAR 0 8
77176: PUSH
77177: LD_VAR 0 6
77181: ARRAY
77182: PPUSH
77183: CALL_OW 461
77187: PUSH
77188: LD_INT 6
77190: EQUAL
77191: IFFALSE 77252
// begin x := tmp [ i ] ;
77193: LD_ADDR_VAR 0 9
77197: PUSH
77198: LD_VAR 0 8
77202: PUSH
77203: LD_VAR 0 6
77207: ARRAY
77208: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
77209: LD_ADDR_VAR 0 8
77213: PUSH
77214: LD_VAR 0 8
77218: PPUSH
77219: LD_VAR 0 6
77223: PPUSH
77224: CALL_OW 3
77228: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
77229: LD_ADDR_VAR 0 8
77233: PUSH
77234: LD_VAR 0 8
77238: PPUSH
77239: LD_INT 1
77241: PPUSH
77242: LD_VAR 0 9
77246: PPUSH
77247: CALL_OW 2
77251: ST_TO_ADDR
// end ;
77252: GO 77169
77254: POP
77255: POP
// for i in tmp do
77256: LD_ADDR_VAR 0 6
77260: PUSH
77261: LD_VAR 0 8
77265: PUSH
77266: FOR_IN
77267: IFFALSE 77336
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
77269: LD_VAR 0 6
77273: PPUSH
77274: CALL_OW 313
77278: PUSH
77279: LD_INT 6
77281: LESS
77282: PUSH
77283: LD_VAR 0 6
77287: PPUSH
77288: CALL_OW 266
77292: PUSH
77293: LD_INT 31
77295: PUSH
77296: LD_INT 32
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: IN
77303: NOT
77304: AND
77305: PUSH
77306: LD_VAR 0 6
77310: PPUSH
77311: CALL_OW 313
77315: PUSH
77316: LD_INT 0
77318: EQUAL
77319: OR
77320: IFFALSE 77334
// begin j := i ;
77322: LD_ADDR_VAR 0 7
77326: PUSH
77327: LD_VAR 0 6
77331: ST_TO_ADDR
// break ;
77332: GO 77336
// end ; end ;
77334: GO 77266
77336: POP
77337: POP
// if j then
77338: LD_VAR 0 7
77342: IFFALSE 77360
// ComEnterUnit ( unit , j ) else
77344: LD_VAR 0 3
77348: PPUSH
77349: LD_VAR 0 7
77353: PPUSH
77354: CALL_OW 120
77358: GO 77463
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77360: LD_ADDR_VAR 0 10
77364: PUSH
77365: LD_VAR 0 2
77369: PPUSH
77370: LD_INT 2
77372: PUSH
77373: LD_INT 30
77375: PUSH
77376: LD_INT 0
77378: PUSH
77379: EMPTY
77380: LIST
77381: LIST
77382: PUSH
77383: LD_INT 30
77385: PUSH
77386: LD_INT 1
77388: PUSH
77389: EMPTY
77390: LIST
77391: LIST
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: LIST
77397: PPUSH
77398: CALL_OW 72
77402: ST_TO_ADDR
// if depot then
77403: LD_VAR 0 10
77407: IFFALSE 77463
// begin depot := NearestUnitToUnit ( depot , unit ) ;
77409: LD_ADDR_VAR 0 10
77413: PUSH
77414: LD_VAR 0 10
77418: PPUSH
77419: LD_VAR 0 3
77423: PPUSH
77424: CALL_OW 74
77428: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
77429: LD_VAR 0 3
77433: PPUSH
77434: LD_VAR 0 10
77438: PPUSH
77439: CALL_OW 296
77443: PUSH
77444: LD_INT 10
77446: GREATER
77447: IFFALSE 77463
// ComStandNearbyBuilding ( unit , depot ) ;
77449: LD_VAR 0 3
77453: PPUSH
77454: LD_VAR 0 10
77458: PPUSH
77459: CALL 12622 0 2
// end ; end ; end ;
77463: LD_VAR 0 5
77467: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
77468: LD_INT 0
77470: PPUSH
77471: PPUSH
77472: PPUSH
77473: PPUSH
// if not mc_bases then
77474: LD_EXP 52
77478: NOT
77479: IFFALSE 77483
// exit ;
77481: GO 77722
// for i = 1 to mc_bases do
77483: LD_ADDR_VAR 0 2
77487: PUSH
77488: DOUBLE
77489: LD_INT 1
77491: DEC
77492: ST_TO_ADDR
77493: LD_EXP 52
77497: PUSH
77498: FOR_TO
77499: IFFALSE 77720
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
77501: LD_ADDR_VAR 0 4
77505: PUSH
77506: LD_EXP 52
77510: PUSH
77511: LD_VAR 0 2
77515: ARRAY
77516: PPUSH
77517: LD_INT 21
77519: PUSH
77520: LD_INT 1
77522: PUSH
77523: EMPTY
77524: LIST
77525: LIST
77526: PPUSH
77527: CALL_OW 72
77531: PUSH
77532: LD_EXP 81
77536: PUSH
77537: LD_VAR 0 2
77541: ARRAY
77542: UNION
77543: ST_TO_ADDR
// if not tmp then
77544: LD_VAR 0 4
77548: NOT
77549: IFFALSE 77553
// continue ;
77551: GO 77498
// for j in tmp do
77553: LD_ADDR_VAR 0 3
77557: PUSH
77558: LD_VAR 0 4
77562: PUSH
77563: FOR_IN
77564: IFFALSE 77716
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
77566: LD_VAR 0 3
77570: PPUSH
77571: CALL_OW 110
77575: NOT
77576: PUSH
77577: LD_VAR 0 3
77581: PPUSH
77582: CALL_OW 314
77586: NOT
77587: AND
77588: PUSH
77589: LD_VAR 0 3
77593: PPUSH
77594: CALL_OW 311
77598: NOT
77599: AND
77600: PUSH
77601: LD_VAR 0 3
77605: PPUSH
77606: CALL_OW 310
77610: NOT
77611: AND
77612: PUSH
77613: LD_VAR 0 3
77617: PUSH
77618: LD_EXP 55
77622: PUSH
77623: LD_VAR 0 2
77627: ARRAY
77628: PUSH
77629: LD_INT 1
77631: ARRAY
77632: IN
77633: NOT
77634: AND
77635: PUSH
77636: LD_VAR 0 3
77640: PUSH
77641: LD_EXP 55
77645: PUSH
77646: LD_VAR 0 2
77650: ARRAY
77651: PUSH
77652: LD_INT 2
77654: ARRAY
77655: IN
77656: NOT
77657: AND
77658: PUSH
77659: LD_VAR 0 3
77663: PUSH
77664: LD_EXP 64
77668: PUSH
77669: LD_VAR 0 2
77673: ARRAY
77674: IN
77675: NOT
77676: AND
77677: IFFALSE 77714
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
77679: LD_VAR 0 2
77683: PPUSH
77684: LD_EXP 52
77688: PUSH
77689: LD_VAR 0 2
77693: ARRAY
77694: PPUSH
77695: LD_VAR 0 3
77699: PPUSH
77700: LD_VAR 0 3
77704: PPUSH
77705: CALL_OW 257
77709: PPUSH
77710: CALL 76486 0 4
// end ;
77714: GO 77563
77716: POP
77717: POP
// end ;
77718: GO 77498
77720: POP
77721: POP
// end ;
77722: LD_VAR 0 1
77726: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
77727: LD_INT 0
77729: PPUSH
77730: PPUSH
77731: PPUSH
77732: PPUSH
77733: PPUSH
77734: PPUSH
// if not mc_bases [ base ] then
77735: LD_EXP 52
77739: PUSH
77740: LD_VAR 0 1
77744: ARRAY
77745: NOT
77746: IFFALSE 77750
// exit ;
77748: GO 77932
// tmp := [ ] ;
77750: LD_ADDR_VAR 0 6
77754: PUSH
77755: EMPTY
77756: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
77757: LD_ADDR_VAR 0 7
77761: PUSH
77762: LD_VAR 0 3
77766: PPUSH
77767: LD_INT 0
77769: PPUSH
77770: CALL_OW 517
77774: ST_TO_ADDR
// if not list then
77775: LD_VAR 0 7
77779: NOT
77780: IFFALSE 77784
// exit ;
77782: GO 77932
// for i = 1 to amount do
77784: LD_ADDR_VAR 0 5
77788: PUSH
77789: DOUBLE
77790: LD_INT 1
77792: DEC
77793: ST_TO_ADDR
77794: LD_VAR 0 2
77798: PUSH
77799: FOR_TO
77800: IFFALSE 77880
// begin x := rand ( 1 , list [ 1 ] ) ;
77802: LD_ADDR_VAR 0 8
77806: PUSH
77807: LD_INT 1
77809: PPUSH
77810: LD_VAR 0 7
77814: PUSH
77815: LD_INT 1
77817: ARRAY
77818: PPUSH
77819: CALL_OW 12
77823: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
77824: LD_ADDR_VAR 0 6
77828: PUSH
77829: LD_VAR 0 6
77833: PPUSH
77834: LD_VAR 0 5
77838: PPUSH
77839: LD_VAR 0 7
77843: PUSH
77844: LD_INT 1
77846: ARRAY
77847: PUSH
77848: LD_VAR 0 8
77852: ARRAY
77853: PUSH
77854: LD_VAR 0 7
77858: PUSH
77859: LD_INT 2
77861: ARRAY
77862: PUSH
77863: LD_VAR 0 8
77867: ARRAY
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PPUSH
77873: CALL_OW 1
77877: ST_TO_ADDR
// end ;
77878: GO 77799
77880: POP
77881: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
77882: LD_ADDR_EXP 65
77886: PUSH
77887: LD_EXP 65
77891: PPUSH
77892: LD_VAR 0 1
77896: PPUSH
77897: LD_VAR 0 6
77901: PPUSH
77902: CALL_OW 1
77906: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
77907: LD_ADDR_EXP 67
77911: PUSH
77912: LD_EXP 67
77916: PPUSH
77917: LD_VAR 0 1
77921: PPUSH
77922: LD_VAR 0 3
77926: PPUSH
77927: CALL_OW 1
77931: ST_TO_ADDR
// end ;
77932: LD_VAR 0 4
77936: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
77937: LD_INT 0
77939: PPUSH
// if not mc_bases [ base ] then
77940: LD_EXP 52
77944: PUSH
77945: LD_VAR 0 1
77949: ARRAY
77950: NOT
77951: IFFALSE 77955
// exit ;
77953: GO 77980
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
77955: LD_ADDR_EXP 57
77959: PUSH
77960: LD_EXP 57
77964: PPUSH
77965: LD_VAR 0 1
77969: PPUSH
77970: LD_VAR 0 2
77974: PPUSH
77975: CALL_OW 1
77979: ST_TO_ADDR
// end ;
77980: LD_VAR 0 3
77984: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
77985: LD_INT 0
77987: PPUSH
// if not mc_bases [ base ] then
77988: LD_EXP 52
77992: PUSH
77993: LD_VAR 0 1
77997: ARRAY
77998: NOT
77999: IFFALSE 78003
// exit ;
78001: GO 78040
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
78003: LD_ADDR_EXP 57
78007: PUSH
78008: LD_EXP 57
78012: PPUSH
78013: LD_VAR 0 1
78017: PPUSH
78018: LD_EXP 57
78022: PUSH
78023: LD_VAR 0 1
78027: ARRAY
78028: PUSH
78029: LD_VAR 0 2
78033: UNION
78034: PPUSH
78035: CALL_OW 1
78039: ST_TO_ADDR
// end ;
78040: LD_VAR 0 3
78044: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
78045: LD_INT 0
78047: PPUSH
// if not mc_bases [ base ] then
78048: LD_EXP 52
78052: PUSH
78053: LD_VAR 0 1
78057: ARRAY
78058: NOT
78059: IFFALSE 78063
// exit ;
78061: GO 78088
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
78063: LD_ADDR_EXP 73
78067: PUSH
78068: LD_EXP 73
78072: PPUSH
78073: LD_VAR 0 1
78077: PPUSH
78078: LD_VAR 0 2
78082: PPUSH
78083: CALL_OW 1
78087: ST_TO_ADDR
// end ;
78088: LD_VAR 0 3
78092: RET
// export function MC_InsertProduceList ( base , components ) ; begin
78093: LD_INT 0
78095: PPUSH
// if not mc_bases [ base ] then
78096: LD_EXP 52
78100: PUSH
78101: LD_VAR 0 1
78105: ARRAY
78106: NOT
78107: IFFALSE 78111
// exit ;
78109: GO 78148
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
78111: LD_ADDR_EXP 73
78115: PUSH
78116: LD_EXP 73
78120: PPUSH
78121: LD_VAR 0 1
78125: PPUSH
78126: LD_EXP 73
78130: PUSH
78131: LD_VAR 0 1
78135: ARRAY
78136: PUSH
78137: LD_VAR 0 2
78141: ADD
78142: PPUSH
78143: CALL_OW 1
78147: ST_TO_ADDR
// end ;
78148: LD_VAR 0 3
78152: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
78153: LD_INT 0
78155: PPUSH
// if not mc_bases [ base ] then
78156: LD_EXP 52
78160: PUSH
78161: LD_VAR 0 1
78165: ARRAY
78166: NOT
78167: IFFALSE 78171
// exit ;
78169: GO 78225
// mc_defender := Replace ( mc_defender , base , deflist ) ;
78171: LD_ADDR_EXP 74
78175: PUSH
78176: LD_EXP 74
78180: PPUSH
78181: LD_VAR 0 1
78185: PPUSH
78186: LD_VAR 0 2
78190: PPUSH
78191: CALL_OW 1
78195: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
78196: LD_ADDR_EXP 63
78200: PUSH
78201: LD_EXP 63
78205: PPUSH
78206: LD_VAR 0 1
78210: PPUSH
78211: LD_VAR 0 2
78215: PUSH
78216: LD_INT 0
78218: PLUS
78219: PPUSH
78220: CALL_OW 1
78224: ST_TO_ADDR
// end ;
78225: LD_VAR 0 3
78229: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
78230: LD_INT 0
78232: PPUSH
// if not mc_bases [ base ] then
78233: LD_EXP 52
78237: PUSH
78238: LD_VAR 0 1
78242: ARRAY
78243: NOT
78244: IFFALSE 78248
// exit ;
78246: GO 78273
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
78248: LD_ADDR_EXP 63
78252: PUSH
78253: LD_EXP 63
78257: PPUSH
78258: LD_VAR 0 1
78262: PPUSH
78263: LD_VAR 0 2
78267: PPUSH
78268: CALL_OW 1
78272: ST_TO_ADDR
// end ;
78273: LD_VAR 0 3
78277: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
78278: LD_INT 0
78280: PPUSH
78281: PPUSH
78282: PPUSH
78283: PPUSH
// if not mc_bases [ base ] then
78284: LD_EXP 52
78288: PUSH
78289: LD_VAR 0 1
78293: ARRAY
78294: NOT
78295: IFFALSE 78299
// exit ;
78297: GO 78364
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
78299: LD_ADDR_EXP 72
78303: PUSH
78304: LD_EXP 72
78308: PPUSH
78309: LD_VAR 0 1
78313: PUSH
78314: LD_EXP 72
78318: PUSH
78319: LD_VAR 0 1
78323: ARRAY
78324: PUSH
78325: LD_INT 1
78327: PLUS
78328: PUSH
78329: EMPTY
78330: LIST
78331: LIST
78332: PPUSH
78333: LD_VAR 0 1
78337: PUSH
78338: LD_VAR 0 2
78342: PUSH
78343: LD_VAR 0 3
78347: PUSH
78348: LD_VAR 0 4
78352: PUSH
78353: EMPTY
78354: LIST
78355: LIST
78356: LIST
78357: LIST
78358: PPUSH
78359: CALL 18419 0 3
78363: ST_TO_ADDR
// end ;
78364: LD_VAR 0 5
78368: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
78369: LD_INT 0
78371: PPUSH
// if not mc_bases [ base ] then
78372: LD_EXP 52
78376: PUSH
78377: LD_VAR 0 1
78381: ARRAY
78382: NOT
78383: IFFALSE 78387
// exit ;
78385: GO 78412
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
78387: LD_ADDR_EXP 89
78391: PUSH
78392: LD_EXP 89
78396: PPUSH
78397: LD_VAR 0 1
78401: PPUSH
78402: LD_VAR 0 2
78406: PPUSH
78407: CALL_OW 1
78411: ST_TO_ADDR
// end ;
78412: LD_VAR 0 3
78416: RET
// export function MC_GetMinesField ( base ) ; begin
78417: LD_INT 0
78419: PPUSH
// result := mc_mines [ base ] ;
78420: LD_ADDR_VAR 0 2
78424: PUSH
78425: LD_EXP 65
78429: PUSH
78430: LD_VAR 0 1
78434: ARRAY
78435: ST_TO_ADDR
// end ;
78436: LD_VAR 0 2
78440: RET
// export function MC_GetProduceList ( base ) ; begin
78441: LD_INT 0
78443: PPUSH
// result := mc_produce [ base ] ;
78444: LD_ADDR_VAR 0 2
78448: PUSH
78449: LD_EXP 73
78453: PUSH
78454: LD_VAR 0 1
78458: ARRAY
78459: ST_TO_ADDR
// end ;
78460: LD_VAR 0 2
78464: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
78465: LD_INT 0
78467: PPUSH
78468: PPUSH
// if not mc_bases then
78469: LD_EXP 52
78473: NOT
78474: IFFALSE 78478
// exit ;
78476: GO 78543
// if mc_bases [ base ] then
78478: LD_EXP 52
78482: PUSH
78483: LD_VAR 0 1
78487: ARRAY
78488: IFFALSE 78543
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78490: LD_ADDR_VAR 0 3
78494: PUSH
78495: LD_EXP 52
78499: PUSH
78500: LD_VAR 0 1
78504: ARRAY
78505: PPUSH
78506: LD_INT 30
78508: PUSH
78509: LD_VAR 0 2
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: PPUSH
78518: CALL_OW 72
78522: ST_TO_ADDR
// if result then
78523: LD_VAR 0 3
78527: IFFALSE 78543
// result := result [ 1 ] ;
78529: LD_ADDR_VAR 0 3
78533: PUSH
78534: LD_VAR 0 3
78538: PUSH
78539: LD_INT 1
78541: ARRAY
78542: ST_TO_ADDR
// end ; end ;
78543: LD_VAR 0 3
78547: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
78548: LD_INT 0
78550: PPUSH
78551: PPUSH
// if not mc_bases then
78552: LD_EXP 52
78556: NOT
78557: IFFALSE 78561
// exit ;
78559: GO 78606
// if mc_bases [ base ] then
78561: LD_EXP 52
78565: PUSH
78566: LD_VAR 0 1
78570: ARRAY
78571: IFFALSE 78606
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78573: LD_ADDR_VAR 0 3
78577: PUSH
78578: LD_EXP 52
78582: PUSH
78583: LD_VAR 0 1
78587: ARRAY
78588: PPUSH
78589: LD_INT 30
78591: PUSH
78592: LD_VAR 0 2
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: PPUSH
78601: CALL_OW 72
78605: ST_TO_ADDR
// end ;
78606: LD_VAR 0 3
78610: RET
// export function MC_SetTame ( base , area ) ; begin
78611: LD_INT 0
78613: PPUSH
// if not mc_bases or not base then
78614: LD_EXP 52
78618: NOT
78619: PUSH
78620: LD_VAR 0 1
78624: NOT
78625: OR
78626: IFFALSE 78630
// exit ;
78628: GO 78655
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
78630: LD_ADDR_EXP 80
78634: PUSH
78635: LD_EXP 80
78639: PPUSH
78640: LD_VAR 0 1
78644: PPUSH
78645: LD_VAR 0 2
78649: PPUSH
78650: CALL_OW 1
78654: ST_TO_ADDR
// end ;
78655: LD_VAR 0 3
78659: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
78660: LD_INT 0
78662: PPUSH
78663: PPUSH
// if not mc_bases or not base then
78664: LD_EXP 52
78668: NOT
78669: PUSH
78670: LD_VAR 0 1
78674: NOT
78675: OR
78676: IFFALSE 78680
// exit ;
78678: GO 78782
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78680: LD_ADDR_VAR 0 4
78684: PUSH
78685: LD_EXP 52
78689: PUSH
78690: LD_VAR 0 1
78694: ARRAY
78695: PPUSH
78696: LD_INT 30
78698: PUSH
78699: LD_VAR 0 2
78703: PUSH
78704: EMPTY
78705: LIST
78706: LIST
78707: PPUSH
78708: CALL_OW 72
78712: ST_TO_ADDR
// if not tmp then
78713: LD_VAR 0 4
78717: NOT
78718: IFFALSE 78722
// exit ;
78720: GO 78782
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
78722: LD_ADDR_EXP 84
78726: PUSH
78727: LD_EXP 84
78731: PPUSH
78732: LD_VAR 0 1
78736: PPUSH
78737: LD_EXP 84
78741: PUSH
78742: LD_VAR 0 1
78746: ARRAY
78747: PPUSH
78748: LD_EXP 84
78752: PUSH
78753: LD_VAR 0 1
78757: ARRAY
78758: PUSH
78759: LD_INT 1
78761: PLUS
78762: PPUSH
78763: LD_VAR 0 4
78767: PUSH
78768: LD_INT 1
78770: ARRAY
78771: PPUSH
78772: CALL_OW 2
78776: PPUSH
78777: CALL_OW 1
78781: ST_TO_ADDR
// end ;
78782: LD_VAR 0 3
78786: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
78787: LD_INT 0
78789: PPUSH
78790: PPUSH
// if not mc_bases or not base or not kinds then
78791: LD_EXP 52
78795: NOT
78796: PUSH
78797: LD_VAR 0 1
78801: NOT
78802: OR
78803: PUSH
78804: LD_VAR 0 2
78808: NOT
78809: OR
78810: IFFALSE 78814
// exit ;
78812: GO 78875
// for i in kinds do
78814: LD_ADDR_VAR 0 4
78818: PUSH
78819: LD_VAR 0 2
78823: PUSH
78824: FOR_IN
78825: IFFALSE 78873
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
78827: LD_ADDR_EXP 86
78831: PUSH
78832: LD_EXP 86
78836: PPUSH
78837: LD_VAR 0 1
78841: PUSH
78842: LD_EXP 86
78846: PUSH
78847: LD_VAR 0 1
78851: ARRAY
78852: PUSH
78853: LD_INT 1
78855: PLUS
78856: PUSH
78857: EMPTY
78858: LIST
78859: LIST
78860: PPUSH
78861: LD_VAR 0 4
78865: PPUSH
78866: CALL 18419 0 3
78870: ST_TO_ADDR
78871: GO 78824
78873: POP
78874: POP
// end ;
78875: LD_VAR 0 3
78879: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
78880: LD_INT 0
78882: PPUSH
// if not mc_bases or not base or not areas then
78883: LD_EXP 52
78887: NOT
78888: PUSH
78889: LD_VAR 0 1
78893: NOT
78894: OR
78895: PUSH
78896: LD_VAR 0 2
78900: NOT
78901: OR
78902: IFFALSE 78906
// exit ;
78904: GO 78931
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
78906: LD_ADDR_EXP 70
78910: PUSH
78911: LD_EXP 70
78915: PPUSH
78916: LD_VAR 0 1
78920: PPUSH
78921: LD_VAR 0 2
78925: PPUSH
78926: CALL_OW 1
78930: ST_TO_ADDR
// end ;
78931: LD_VAR 0 3
78935: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
78936: LD_INT 0
78938: PPUSH
// if not mc_bases or not base or not teleports_exit then
78939: LD_EXP 52
78943: NOT
78944: PUSH
78945: LD_VAR 0 1
78949: NOT
78950: OR
78951: PUSH
78952: LD_VAR 0 2
78956: NOT
78957: OR
78958: IFFALSE 78962
// exit ;
78960: GO 78987
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
78962: LD_ADDR_EXP 87
78966: PUSH
78967: LD_EXP 87
78971: PPUSH
78972: LD_VAR 0 1
78976: PPUSH
78977: LD_VAR 0 2
78981: PPUSH
78982: CALL_OW 1
78986: ST_TO_ADDR
// end ;
78987: LD_VAR 0 3
78991: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
78992: LD_INT 0
78994: PPUSH
78995: PPUSH
78996: PPUSH
// if not mc_bases or not base or not ext_list then
78997: LD_EXP 52
79001: NOT
79002: PUSH
79003: LD_VAR 0 1
79007: NOT
79008: OR
79009: PUSH
79010: LD_VAR 0 5
79014: NOT
79015: OR
79016: IFFALSE 79020
// exit ;
79018: GO 79193
// tmp := GetFacExtXYD ( x , y , d ) ;
79020: LD_ADDR_VAR 0 8
79024: PUSH
79025: LD_VAR 0 2
79029: PPUSH
79030: LD_VAR 0 3
79034: PPUSH
79035: LD_VAR 0 4
79039: PPUSH
79040: CALL 51807 0 3
79044: ST_TO_ADDR
// if not tmp then
79045: LD_VAR 0 8
79049: NOT
79050: IFFALSE 79054
// exit ;
79052: GO 79193
// for i in tmp do
79054: LD_ADDR_VAR 0 7
79058: PUSH
79059: LD_VAR 0 8
79063: PUSH
79064: FOR_IN
79065: IFFALSE 79191
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
79067: LD_ADDR_EXP 57
79071: PUSH
79072: LD_EXP 57
79076: PPUSH
79077: LD_VAR 0 1
79081: PPUSH
79082: LD_EXP 57
79086: PUSH
79087: LD_VAR 0 1
79091: ARRAY
79092: PPUSH
79093: LD_EXP 57
79097: PUSH
79098: LD_VAR 0 1
79102: ARRAY
79103: PUSH
79104: LD_INT 1
79106: PLUS
79107: PPUSH
79108: LD_VAR 0 5
79112: PUSH
79113: LD_INT 1
79115: ARRAY
79116: PUSH
79117: LD_VAR 0 7
79121: PUSH
79122: LD_INT 1
79124: ARRAY
79125: PUSH
79126: LD_VAR 0 7
79130: PUSH
79131: LD_INT 2
79133: ARRAY
79134: PUSH
79135: LD_VAR 0 7
79139: PUSH
79140: LD_INT 3
79142: ARRAY
79143: PUSH
79144: EMPTY
79145: LIST
79146: LIST
79147: LIST
79148: LIST
79149: PPUSH
79150: CALL_OW 2
79154: PPUSH
79155: CALL_OW 1
79159: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
79160: LD_ADDR_VAR 0 5
79164: PUSH
79165: LD_VAR 0 5
79169: PPUSH
79170: LD_INT 1
79172: PPUSH
79173: CALL_OW 3
79177: ST_TO_ADDR
// if not ext_list then
79178: LD_VAR 0 5
79182: NOT
79183: IFFALSE 79189
// exit ;
79185: POP
79186: POP
79187: GO 79193
// end ;
79189: GO 79064
79191: POP
79192: POP
// end ;
79193: LD_VAR 0 6
79197: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
79198: LD_INT 0
79200: PPUSH
// if not mc_bases or not base or not weapon_list then
79201: LD_EXP 52
79205: NOT
79206: PUSH
79207: LD_VAR 0 1
79211: NOT
79212: OR
79213: PUSH
79214: LD_VAR 0 2
79218: NOT
79219: OR
79220: IFFALSE 79224
// exit ;
79222: GO 79249
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
79224: LD_ADDR_EXP 91
79228: PUSH
79229: LD_EXP 91
79233: PPUSH
79234: LD_VAR 0 1
79238: PPUSH
79239: LD_VAR 0 2
79243: PPUSH
79244: CALL_OW 1
79248: ST_TO_ADDR
// end ;
79249: LD_VAR 0 3
79253: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
79254: LD_INT 0
79256: PPUSH
// if not mc_bases or not base or not tech_list then
79257: LD_EXP 52
79261: NOT
79262: PUSH
79263: LD_VAR 0 1
79267: NOT
79268: OR
79269: PUSH
79270: LD_VAR 0 2
79274: NOT
79275: OR
79276: IFFALSE 79280
// exit ;
79278: GO 79305
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
79280: LD_ADDR_EXP 79
79284: PUSH
79285: LD_EXP 79
79289: PPUSH
79290: LD_VAR 0 1
79294: PPUSH
79295: LD_VAR 0 2
79299: PPUSH
79300: CALL_OW 1
79304: ST_TO_ADDR
// end ;
79305: LD_VAR 0 3
79309: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
79310: LD_INT 0
79312: PPUSH
// if not mc_bases or not parking_area or not base then
79313: LD_EXP 52
79317: NOT
79318: PUSH
79319: LD_VAR 0 2
79323: NOT
79324: OR
79325: PUSH
79326: LD_VAR 0 1
79330: NOT
79331: OR
79332: IFFALSE 79336
// exit ;
79334: GO 79361
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
79336: LD_ADDR_EXP 76
79340: PUSH
79341: LD_EXP 76
79345: PPUSH
79346: LD_VAR 0 1
79350: PPUSH
79351: LD_VAR 0 2
79355: PPUSH
79356: CALL_OW 1
79360: ST_TO_ADDR
// end ;
79361: LD_VAR 0 3
79365: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
79366: LD_INT 0
79368: PPUSH
// if not mc_bases or not base or not scan_area then
79369: LD_EXP 52
79373: NOT
79374: PUSH
79375: LD_VAR 0 1
79379: NOT
79380: OR
79381: PUSH
79382: LD_VAR 0 2
79386: NOT
79387: OR
79388: IFFALSE 79392
// exit ;
79390: GO 79417
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
79392: LD_ADDR_EXP 77
79396: PUSH
79397: LD_EXP 77
79401: PPUSH
79402: LD_VAR 0 1
79406: PPUSH
79407: LD_VAR 0 2
79411: PPUSH
79412: CALL_OW 1
79416: ST_TO_ADDR
// end ;
79417: LD_VAR 0 3
79421: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
79422: LD_INT 0
79424: PPUSH
79425: PPUSH
// if not mc_bases or not base then
79426: LD_EXP 52
79430: NOT
79431: PUSH
79432: LD_VAR 0 1
79436: NOT
79437: OR
79438: IFFALSE 79442
// exit ;
79440: GO 79506
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
79442: LD_ADDR_VAR 0 3
79446: PUSH
79447: LD_INT 1
79449: PUSH
79450: LD_INT 2
79452: PUSH
79453: LD_INT 3
79455: PUSH
79456: LD_INT 4
79458: PUSH
79459: LD_INT 11
79461: PUSH
79462: EMPTY
79463: LIST
79464: LIST
79465: LIST
79466: LIST
79467: LIST
79468: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
79469: LD_ADDR_EXP 79
79473: PUSH
79474: LD_EXP 79
79478: PPUSH
79479: LD_VAR 0 1
79483: PPUSH
79484: LD_EXP 79
79488: PUSH
79489: LD_VAR 0 1
79493: ARRAY
79494: PUSH
79495: LD_VAR 0 3
79499: DIFF
79500: PPUSH
79501: CALL_OW 1
79505: ST_TO_ADDR
// end ;
79506: LD_VAR 0 2
79510: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
79511: LD_INT 0
79513: PPUSH
// result := mc_vehicles [ base ] ;
79514: LD_ADDR_VAR 0 3
79518: PUSH
79519: LD_EXP 71
79523: PUSH
79524: LD_VAR 0 1
79528: ARRAY
79529: ST_TO_ADDR
// if onlyCombat then
79530: LD_VAR 0 2
79534: IFFALSE 79699
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
79536: LD_ADDR_VAR 0 3
79540: PUSH
79541: LD_VAR 0 3
79545: PUSH
79546: LD_VAR 0 3
79550: PPUSH
79551: LD_INT 2
79553: PUSH
79554: LD_INT 34
79556: PUSH
79557: LD_INT 12
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: PUSH
79564: LD_INT 34
79566: PUSH
79567: LD_INT 51
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: LD_INT 34
79576: PUSH
79577: LD_EXP 46
79581: PUSH
79582: EMPTY
79583: LIST
79584: LIST
79585: PUSH
79586: LD_INT 34
79588: PUSH
79589: LD_INT 32
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: PUSH
79596: LD_INT 34
79598: PUSH
79599: LD_INT 13
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: LD_INT 34
79608: PUSH
79609: LD_INT 52
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 34
79618: PUSH
79619: LD_INT 14
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: PUSH
79626: LD_INT 34
79628: PUSH
79629: LD_INT 53
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: PUSH
79636: LD_INT 34
79638: PUSH
79639: LD_EXP 45
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 34
79650: PUSH
79651: LD_INT 31
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 34
79660: PUSH
79661: LD_INT 48
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: PUSH
79668: LD_INT 34
79670: PUSH
79671: LD_INT 8
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: PUSH
79678: EMPTY
79679: LIST
79680: LIST
79681: LIST
79682: LIST
79683: LIST
79684: LIST
79685: LIST
79686: LIST
79687: LIST
79688: LIST
79689: LIST
79690: LIST
79691: LIST
79692: PPUSH
79693: CALL_OW 72
79697: DIFF
79698: ST_TO_ADDR
// end ; end_of_file
79699: LD_VAR 0 3
79703: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
79704: LD_INT 0
79706: PPUSH
79707: PPUSH
79708: PPUSH
// if not mc_bases or not skirmish then
79709: LD_EXP 52
79713: NOT
79714: PUSH
79715: LD_EXP 50
79719: NOT
79720: OR
79721: IFFALSE 79725
// exit ;
79723: GO 79890
// for i = 1 to mc_bases do
79725: LD_ADDR_VAR 0 4
79729: PUSH
79730: DOUBLE
79731: LD_INT 1
79733: DEC
79734: ST_TO_ADDR
79735: LD_EXP 52
79739: PUSH
79740: FOR_TO
79741: IFFALSE 79888
// begin if sci in mc_bases [ i ] then
79743: LD_VAR 0 2
79747: PUSH
79748: LD_EXP 52
79752: PUSH
79753: LD_VAR 0 4
79757: ARRAY
79758: IN
79759: IFFALSE 79886
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
79761: LD_ADDR_EXP 81
79765: PUSH
79766: LD_EXP 81
79770: PPUSH
79771: LD_VAR 0 4
79775: PUSH
79776: LD_EXP 81
79780: PUSH
79781: LD_VAR 0 4
79785: ARRAY
79786: PUSH
79787: LD_INT 1
79789: PLUS
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PPUSH
79795: LD_VAR 0 1
79799: PPUSH
79800: CALL 18419 0 3
79804: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
79805: LD_ADDR_VAR 0 5
79809: PUSH
79810: LD_EXP 52
79814: PUSH
79815: LD_VAR 0 4
79819: ARRAY
79820: PPUSH
79821: LD_INT 2
79823: PUSH
79824: LD_INT 30
79826: PUSH
79827: LD_INT 0
79829: PUSH
79830: EMPTY
79831: LIST
79832: LIST
79833: PUSH
79834: LD_INT 30
79836: PUSH
79837: LD_INT 1
79839: PUSH
79840: EMPTY
79841: LIST
79842: LIST
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: LIST
79848: PPUSH
79849: CALL_OW 72
79853: PPUSH
79854: LD_VAR 0 1
79858: PPUSH
79859: CALL_OW 74
79863: ST_TO_ADDR
// if tmp then
79864: LD_VAR 0 5
79868: IFFALSE 79884
// ComStandNearbyBuilding ( ape , tmp ) ;
79870: LD_VAR 0 1
79874: PPUSH
79875: LD_VAR 0 5
79879: PPUSH
79880: CALL 12622 0 2
// break ;
79884: GO 79888
// end ; end ;
79886: GO 79740
79888: POP
79889: POP
// end ;
79890: LD_VAR 0 3
79894: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
79895: LD_INT 0
79897: PPUSH
79898: PPUSH
79899: PPUSH
// if not mc_bases or not skirmish then
79900: LD_EXP 52
79904: NOT
79905: PUSH
79906: LD_EXP 50
79910: NOT
79911: OR
79912: IFFALSE 79916
// exit ;
79914: GO 80005
// for i = 1 to mc_bases do
79916: LD_ADDR_VAR 0 4
79920: PUSH
79921: DOUBLE
79922: LD_INT 1
79924: DEC
79925: ST_TO_ADDR
79926: LD_EXP 52
79930: PUSH
79931: FOR_TO
79932: IFFALSE 80003
// begin if building in mc_busy_turret_list [ i ] then
79934: LD_VAR 0 1
79938: PUSH
79939: LD_EXP 62
79943: PUSH
79944: LD_VAR 0 4
79948: ARRAY
79949: IN
79950: IFFALSE 80001
// begin tmp := mc_busy_turret_list [ i ] diff building ;
79952: LD_ADDR_VAR 0 5
79956: PUSH
79957: LD_EXP 62
79961: PUSH
79962: LD_VAR 0 4
79966: ARRAY
79967: PUSH
79968: LD_VAR 0 1
79972: DIFF
79973: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
79974: LD_ADDR_EXP 62
79978: PUSH
79979: LD_EXP 62
79983: PPUSH
79984: LD_VAR 0 4
79988: PPUSH
79989: LD_VAR 0 5
79993: PPUSH
79994: CALL_OW 1
79998: ST_TO_ADDR
// break ;
79999: GO 80003
// end ; end ;
80001: GO 79931
80003: POP
80004: POP
// end ;
80005: LD_VAR 0 3
80009: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
80010: LD_INT 0
80012: PPUSH
80013: PPUSH
80014: PPUSH
// if not mc_bases or not skirmish then
80015: LD_EXP 52
80019: NOT
80020: PUSH
80021: LD_EXP 50
80025: NOT
80026: OR
80027: IFFALSE 80031
// exit ;
80029: GO 80230
// for i = 1 to mc_bases do
80031: LD_ADDR_VAR 0 5
80035: PUSH
80036: DOUBLE
80037: LD_INT 1
80039: DEC
80040: ST_TO_ADDR
80041: LD_EXP 52
80045: PUSH
80046: FOR_TO
80047: IFFALSE 80228
// if building in mc_bases [ i ] then
80049: LD_VAR 0 1
80053: PUSH
80054: LD_EXP 52
80058: PUSH
80059: LD_VAR 0 5
80063: ARRAY
80064: IN
80065: IFFALSE 80226
// begin tmp := mc_bases [ i ] diff building ;
80067: LD_ADDR_VAR 0 6
80071: PUSH
80072: LD_EXP 52
80076: PUSH
80077: LD_VAR 0 5
80081: ARRAY
80082: PUSH
80083: LD_VAR 0 1
80087: DIFF
80088: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
80089: LD_ADDR_EXP 52
80093: PUSH
80094: LD_EXP 52
80098: PPUSH
80099: LD_VAR 0 5
80103: PPUSH
80104: LD_VAR 0 6
80108: PPUSH
80109: CALL_OW 1
80113: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
80114: LD_VAR 0 1
80118: PUSH
80119: LD_EXP 60
80123: PUSH
80124: LD_VAR 0 5
80128: ARRAY
80129: IN
80130: IFFALSE 80169
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
80132: LD_ADDR_EXP 60
80136: PUSH
80137: LD_EXP 60
80141: PPUSH
80142: LD_VAR 0 5
80146: PPUSH
80147: LD_EXP 60
80151: PUSH
80152: LD_VAR 0 5
80156: ARRAY
80157: PUSH
80158: LD_VAR 0 1
80162: DIFF
80163: PPUSH
80164: CALL_OW 1
80168: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
80169: LD_VAR 0 1
80173: PUSH
80174: LD_EXP 61
80178: PUSH
80179: LD_VAR 0 5
80183: ARRAY
80184: IN
80185: IFFALSE 80224
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
80187: LD_ADDR_EXP 61
80191: PUSH
80192: LD_EXP 61
80196: PPUSH
80197: LD_VAR 0 5
80201: PPUSH
80202: LD_EXP 61
80206: PUSH
80207: LD_VAR 0 5
80211: ARRAY
80212: PUSH
80213: LD_VAR 0 1
80217: DIFF
80218: PPUSH
80219: CALL_OW 1
80223: ST_TO_ADDR
// break ;
80224: GO 80228
// end ;
80226: GO 80046
80228: POP
80229: POP
// end ;
80230: LD_VAR 0 4
80234: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
80235: LD_INT 0
80237: PPUSH
80238: PPUSH
80239: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
80240: LD_EXP 52
80244: NOT
80245: PUSH
80246: LD_EXP 50
80250: NOT
80251: OR
80252: PUSH
80253: LD_VAR 0 3
80257: PUSH
80258: LD_EXP 78
80262: IN
80263: NOT
80264: OR
80265: IFFALSE 80269
// exit ;
80267: GO 80392
// for i = 1 to mc_vehicles do
80269: LD_ADDR_VAR 0 6
80273: PUSH
80274: DOUBLE
80275: LD_INT 1
80277: DEC
80278: ST_TO_ADDR
80279: LD_EXP 71
80283: PUSH
80284: FOR_TO
80285: IFFALSE 80390
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
80287: LD_VAR 0 2
80291: PUSH
80292: LD_EXP 71
80296: PUSH
80297: LD_VAR 0 6
80301: ARRAY
80302: IN
80303: PUSH
80304: LD_VAR 0 1
80308: PUSH
80309: LD_EXP 71
80313: PUSH
80314: LD_VAR 0 6
80318: ARRAY
80319: IN
80320: OR
80321: IFFALSE 80388
// begin tmp := mc_vehicles [ i ] diff old ;
80323: LD_ADDR_VAR 0 7
80327: PUSH
80328: LD_EXP 71
80332: PUSH
80333: LD_VAR 0 6
80337: ARRAY
80338: PUSH
80339: LD_VAR 0 2
80343: DIFF
80344: ST_TO_ADDR
// tmp := tmp diff new ;
80345: LD_ADDR_VAR 0 7
80349: PUSH
80350: LD_VAR 0 7
80354: PUSH
80355: LD_VAR 0 1
80359: DIFF
80360: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
80361: LD_ADDR_EXP 71
80365: PUSH
80366: LD_EXP 71
80370: PPUSH
80371: LD_VAR 0 6
80375: PPUSH
80376: LD_VAR 0 7
80380: PPUSH
80381: CALL_OW 1
80385: ST_TO_ADDR
// break ;
80386: GO 80390
// end ;
80388: GO 80284
80390: POP
80391: POP
// end ;
80392: LD_VAR 0 5
80396: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
80397: LD_INT 0
80399: PPUSH
80400: PPUSH
80401: PPUSH
80402: PPUSH
// if not mc_bases or not skirmish then
80403: LD_EXP 52
80407: NOT
80408: PUSH
80409: LD_EXP 50
80413: NOT
80414: OR
80415: IFFALSE 80419
// exit ;
80417: GO 80796
// side := GetSide ( vehicle ) ;
80419: LD_ADDR_VAR 0 5
80423: PUSH
80424: LD_VAR 0 1
80428: PPUSH
80429: CALL_OW 255
80433: ST_TO_ADDR
// for i = 1 to mc_bases do
80434: LD_ADDR_VAR 0 4
80438: PUSH
80439: DOUBLE
80440: LD_INT 1
80442: DEC
80443: ST_TO_ADDR
80444: LD_EXP 52
80448: PUSH
80449: FOR_TO
80450: IFFALSE 80794
// begin if factory in mc_bases [ i ] then
80452: LD_VAR 0 2
80456: PUSH
80457: LD_EXP 52
80461: PUSH
80462: LD_VAR 0 4
80466: ARRAY
80467: IN
80468: IFFALSE 80792
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
80470: LD_EXP 74
80474: PUSH
80475: LD_VAR 0 4
80479: ARRAY
80480: PUSH
80481: LD_EXP 63
80485: PUSH
80486: LD_VAR 0 4
80490: ARRAY
80491: LESS
80492: PUSH
80493: LD_VAR 0 1
80497: PPUSH
80498: CALL_OW 264
80502: PUSH
80503: LD_INT 31
80505: PUSH
80506: LD_INT 32
80508: PUSH
80509: LD_INT 51
80511: PUSH
80512: LD_EXP 46
80516: PUSH
80517: LD_INT 12
80519: PUSH
80520: LD_INT 30
80522: PUSH
80523: LD_EXP 45
80527: PUSH
80528: LD_INT 11
80530: PUSH
80531: LD_INT 53
80533: PUSH
80534: LD_INT 14
80536: PUSH
80537: LD_EXP 49
80541: PUSH
80542: LD_INT 29
80544: PUSH
80545: LD_EXP 47
80549: PUSH
80550: LD_INT 13
80552: PUSH
80553: LD_INT 52
80555: PUSH
80556: LD_INT 48
80558: PUSH
80559: LD_INT 8
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: LIST
80566: LIST
80567: LIST
80568: LIST
80569: LIST
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: LIST
80576: LIST
80577: LIST
80578: LIST
80579: LIST
80580: IN
80581: NOT
80582: AND
80583: IFFALSE 80631
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
80585: LD_ADDR_EXP 74
80589: PUSH
80590: LD_EXP 74
80594: PPUSH
80595: LD_VAR 0 4
80599: PUSH
80600: LD_EXP 74
80604: PUSH
80605: LD_VAR 0 4
80609: ARRAY
80610: PUSH
80611: LD_INT 1
80613: PLUS
80614: PUSH
80615: EMPTY
80616: LIST
80617: LIST
80618: PPUSH
80619: LD_VAR 0 1
80623: PPUSH
80624: CALL 18419 0 3
80628: ST_TO_ADDR
80629: GO 80675
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
80631: LD_ADDR_EXP 71
80635: PUSH
80636: LD_EXP 71
80640: PPUSH
80641: LD_VAR 0 4
80645: PUSH
80646: LD_EXP 71
80650: PUSH
80651: LD_VAR 0 4
80655: ARRAY
80656: PUSH
80657: LD_INT 1
80659: PLUS
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PPUSH
80665: LD_VAR 0 1
80669: PPUSH
80670: CALL 18419 0 3
80674: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
80675: LD_VAR 0 1
80679: PPUSH
80680: CALL_OW 263
80684: PUSH
80685: LD_INT 2
80687: EQUAL
80688: IFFALSE 80708
// begin repeat wait ( 0 0$1 ) ;
80690: LD_INT 35
80692: PPUSH
80693: CALL_OW 67
// until IsControledBy ( vehicle ) ;
80697: LD_VAR 0 1
80701: PPUSH
80702: CALL_OW 312
80706: IFFALSE 80690
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
80708: LD_VAR 0 1
80712: PPUSH
80713: LD_EXP 76
80717: PUSH
80718: LD_VAR 0 4
80722: ARRAY
80723: PPUSH
80724: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
80728: LD_VAR 0 1
80732: PPUSH
80733: CALL_OW 263
80737: PUSH
80738: LD_INT 1
80740: NONEQUAL
80741: IFFALSE 80745
// break ;
80743: GO 80794
// repeat wait ( 0 0$1 ) ;
80745: LD_INT 35
80747: PPUSH
80748: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
80752: LD_VAR 0 1
80756: PPUSH
80757: LD_EXP 76
80761: PUSH
80762: LD_VAR 0 4
80766: ARRAY
80767: PPUSH
80768: CALL_OW 308
80772: IFFALSE 80745
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
80774: LD_VAR 0 1
80778: PPUSH
80779: CALL_OW 311
80783: PPUSH
80784: CALL_OW 121
// exit ;
80788: POP
80789: POP
80790: GO 80796
// end ; end ;
80792: GO 80449
80794: POP
80795: POP
// end ;
80796: LD_VAR 0 3
80800: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
80801: LD_INT 0
80803: PPUSH
80804: PPUSH
80805: PPUSH
80806: PPUSH
// if not mc_bases or not skirmish then
80807: LD_EXP 52
80811: NOT
80812: PUSH
80813: LD_EXP 50
80817: NOT
80818: OR
80819: IFFALSE 80823
// exit ;
80821: GO 81176
// repeat wait ( 0 0$1 ) ;
80823: LD_INT 35
80825: PPUSH
80826: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
80830: LD_VAR 0 2
80834: PPUSH
80835: LD_VAR 0 3
80839: PPUSH
80840: CALL_OW 284
80844: IFFALSE 80823
// if GetResourceTypeXY ( x , y ) = mat_artefact then
80846: LD_VAR 0 2
80850: PPUSH
80851: LD_VAR 0 3
80855: PPUSH
80856: CALL_OW 283
80860: PUSH
80861: LD_INT 4
80863: EQUAL
80864: IFFALSE 80868
// exit ;
80866: GO 81176
// for i = 1 to mc_bases do
80868: LD_ADDR_VAR 0 7
80872: PUSH
80873: DOUBLE
80874: LD_INT 1
80876: DEC
80877: ST_TO_ADDR
80878: LD_EXP 52
80882: PUSH
80883: FOR_TO
80884: IFFALSE 81174
// begin if mc_crates_area [ i ] then
80886: LD_EXP 70
80890: PUSH
80891: LD_VAR 0 7
80895: ARRAY
80896: IFFALSE 81007
// for j in mc_crates_area [ i ] do
80898: LD_ADDR_VAR 0 8
80902: PUSH
80903: LD_EXP 70
80907: PUSH
80908: LD_VAR 0 7
80912: ARRAY
80913: PUSH
80914: FOR_IN
80915: IFFALSE 81005
// if InArea ( x , y , j ) then
80917: LD_VAR 0 2
80921: PPUSH
80922: LD_VAR 0 3
80926: PPUSH
80927: LD_VAR 0 8
80931: PPUSH
80932: CALL_OW 309
80936: IFFALSE 81003
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80938: LD_ADDR_EXP 68
80942: PUSH
80943: LD_EXP 68
80947: PPUSH
80948: LD_VAR 0 7
80952: PUSH
80953: LD_EXP 68
80957: PUSH
80958: LD_VAR 0 7
80962: ARRAY
80963: PUSH
80964: LD_INT 1
80966: PLUS
80967: PUSH
80968: EMPTY
80969: LIST
80970: LIST
80971: PPUSH
80972: LD_VAR 0 4
80976: PUSH
80977: LD_VAR 0 2
80981: PUSH
80982: LD_VAR 0 3
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: LIST
80991: PPUSH
80992: CALL 18419 0 3
80996: ST_TO_ADDR
// exit ;
80997: POP
80998: POP
80999: POP
81000: POP
81001: GO 81176
// end ;
81003: GO 80914
81005: POP
81006: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81007: LD_ADDR_VAR 0 9
81011: PUSH
81012: LD_EXP 52
81016: PUSH
81017: LD_VAR 0 7
81021: ARRAY
81022: PPUSH
81023: LD_INT 2
81025: PUSH
81026: LD_INT 30
81028: PUSH
81029: LD_INT 0
81031: PUSH
81032: EMPTY
81033: LIST
81034: LIST
81035: PUSH
81036: LD_INT 30
81038: PUSH
81039: LD_INT 1
81041: PUSH
81042: EMPTY
81043: LIST
81044: LIST
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: LIST
81050: PPUSH
81051: CALL_OW 72
81055: ST_TO_ADDR
// if not depot then
81056: LD_VAR 0 9
81060: NOT
81061: IFFALSE 81065
// continue ;
81063: GO 80883
// for j in depot do
81065: LD_ADDR_VAR 0 8
81069: PUSH
81070: LD_VAR 0 9
81074: PUSH
81075: FOR_IN
81076: IFFALSE 81170
// if GetDistUnitXY ( j , x , y ) < 30 then
81078: LD_VAR 0 8
81082: PPUSH
81083: LD_VAR 0 2
81087: PPUSH
81088: LD_VAR 0 3
81092: PPUSH
81093: CALL_OW 297
81097: PUSH
81098: LD_INT 30
81100: LESS
81101: IFFALSE 81168
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81103: LD_ADDR_EXP 68
81107: PUSH
81108: LD_EXP 68
81112: PPUSH
81113: LD_VAR 0 7
81117: PUSH
81118: LD_EXP 68
81122: PUSH
81123: LD_VAR 0 7
81127: ARRAY
81128: PUSH
81129: LD_INT 1
81131: PLUS
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: PPUSH
81137: LD_VAR 0 4
81141: PUSH
81142: LD_VAR 0 2
81146: PUSH
81147: LD_VAR 0 3
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: LIST
81156: PPUSH
81157: CALL 18419 0 3
81161: ST_TO_ADDR
// exit ;
81162: POP
81163: POP
81164: POP
81165: POP
81166: GO 81176
// end ;
81168: GO 81075
81170: POP
81171: POP
// end ;
81172: GO 80883
81174: POP
81175: POP
// end ;
81176: LD_VAR 0 6
81180: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
81181: LD_INT 0
81183: PPUSH
81184: PPUSH
81185: PPUSH
81186: PPUSH
// if not mc_bases or not skirmish then
81187: LD_EXP 52
81191: NOT
81192: PUSH
81193: LD_EXP 50
81197: NOT
81198: OR
81199: IFFALSE 81203
// exit ;
81201: GO 81480
// side := GetSide ( lab ) ;
81203: LD_ADDR_VAR 0 4
81207: PUSH
81208: LD_VAR 0 2
81212: PPUSH
81213: CALL_OW 255
81217: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
81218: LD_VAR 0 4
81222: PUSH
81223: LD_EXP 78
81227: IN
81228: NOT
81229: PUSH
81230: LD_EXP 79
81234: NOT
81235: OR
81236: PUSH
81237: LD_EXP 52
81241: NOT
81242: OR
81243: IFFALSE 81247
// exit ;
81245: GO 81480
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
81247: LD_ADDR_EXP 79
81251: PUSH
81252: LD_EXP 79
81256: PPUSH
81257: LD_VAR 0 4
81261: PPUSH
81262: LD_EXP 79
81266: PUSH
81267: LD_VAR 0 4
81271: ARRAY
81272: PUSH
81273: LD_VAR 0 1
81277: DIFF
81278: PPUSH
81279: CALL_OW 1
81283: ST_TO_ADDR
// for i = 1 to mc_bases do
81284: LD_ADDR_VAR 0 5
81288: PUSH
81289: DOUBLE
81290: LD_INT 1
81292: DEC
81293: ST_TO_ADDR
81294: LD_EXP 52
81298: PUSH
81299: FOR_TO
81300: IFFALSE 81478
// begin if lab in mc_bases [ i ] then
81302: LD_VAR 0 2
81306: PUSH
81307: LD_EXP 52
81311: PUSH
81312: LD_VAR 0 5
81316: ARRAY
81317: IN
81318: IFFALSE 81476
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
81320: LD_VAR 0 1
81324: PUSH
81325: LD_INT 11
81327: PUSH
81328: LD_INT 4
81330: PUSH
81331: LD_INT 3
81333: PUSH
81334: LD_INT 2
81336: PUSH
81337: EMPTY
81338: LIST
81339: LIST
81340: LIST
81341: LIST
81342: IN
81343: PUSH
81344: LD_EXP 82
81348: PUSH
81349: LD_VAR 0 5
81353: ARRAY
81354: AND
81355: IFFALSE 81476
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
81357: LD_ADDR_VAR 0 6
81361: PUSH
81362: LD_EXP 82
81366: PUSH
81367: LD_VAR 0 5
81371: ARRAY
81372: PUSH
81373: LD_INT 1
81375: ARRAY
81376: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81377: LD_ADDR_EXP 82
81381: PUSH
81382: LD_EXP 82
81386: PPUSH
81387: LD_VAR 0 5
81391: PPUSH
81392: EMPTY
81393: PPUSH
81394: CALL_OW 1
81398: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
81399: LD_VAR 0 6
81403: PPUSH
81404: LD_INT 0
81406: PPUSH
81407: CALL_OW 109
// ComExitBuilding ( tmp ) ;
81411: LD_VAR 0 6
81415: PPUSH
81416: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
81420: LD_ADDR_EXP 81
81424: PUSH
81425: LD_EXP 81
81429: PPUSH
81430: LD_VAR 0 5
81434: PPUSH
81435: LD_EXP 81
81439: PUSH
81440: LD_VAR 0 5
81444: ARRAY
81445: PPUSH
81446: LD_INT 1
81448: PPUSH
81449: LD_VAR 0 6
81453: PPUSH
81454: CALL_OW 2
81458: PPUSH
81459: CALL_OW 1
81463: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
81464: LD_VAR 0 5
81468: PPUSH
81469: LD_INT 112
81471: PPUSH
81472: CALL 58476 0 2
// end ; end ; end ;
81476: GO 81299
81478: POP
81479: POP
// end ;
81480: LD_VAR 0 3
81484: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
81485: LD_INT 0
81487: PPUSH
81488: PPUSH
81489: PPUSH
81490: PPUSH
81491: PPUSH
81492: PPUSH
81493: PPUSH
81494: PPUSH
// if not mc_bases or not skirmish then
81495: LD_EXP 52
81499: NOT
81500: PUSH
81501: LD_EXP 50
81505: NOT
81506: OR
81507: IFFALSE 81511
// exit ;
81509: GO 82882
// for i = 1 to mc_bases do
81511: LD_ADDR_VAR 0 3
81515: PUSH
81516: DOUBLE
81517: LD_INT 1
81519: DEC
81520: ST_TO_ADDR
81521: LD_EXP 52
81525: PUSH
81526: FOR_TO
81527: IFFALSE 82880
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
81529: LD_VAR 0 1
81533: PUSH
81534: LD_EXP 52
81538: PUSH
81539: LD_VAR 0 3
81543: ARRAY
81544: IN
81545: PUSH
81546: LD_VAR 0 1
81550: PUSH
81551: LD_EXP 59
81555: PUSH
81556: LD_VAR 0 3
81560: ARRAY
81561: IN
81562: OR
81563: PUSH
81564: LD_VAR 0 1
81568: PUSH
81569: LD_EXP 74
81573: PUSH
81574: LD_VAR 0 3
81578: ARRAY
81579: IN
81580: OR
81581: PUSH
81582: LD_VAR 0 1
81586: PUSH
81587: LD_EXP 71
81591: PUSH
81592: LD_VAR 0 3
81596: ARRAY
81597: IN
81598: OR
81599: PUSH
81600: LD_VAR 0 1
81604: PUSH
81605: LD_EXP 81
81609: PUSH
81610: LD_VAR 0 3
81614: ARRAY
81615: IN
81616: OR
81617: PUSH
81618: LD_VAR 0 1
81622: PUSH
81623: LD_EXP 82
81627: PUSH
81628: LD_VAR 0 3
81632: ARRAY
81633: IN
81634: OR
81635: IFFALSE 82878
// begin if un in mc_ape [ i ] then
81637: LD_VAR 0 1
81641: PUSH
81642: LD_EXP 81
81646: PUSH
81647: LD_VAR 0 3
81651: ARRAY
81652: IN
81653: IFFALSE 81692
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
81655: LD_ADDR_EXP 81
81659: PUSH
81660: LD_EXP 81
81664: PPUSH
81665: LD_VAR 0 3
81669: PPUSH
81670: LD_EXP 81
81674: PUSH
81675: LD_VAR 0 3
81679: ARRAY
81680: PUSH
81681: LD_VAR 0 1
81685: DIFF
81686: PPUSH
81687: CALL_OW 1
81691: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
81692: LD_VAR 0 1
81696: PUSH
81697: LD_EXP 82
81701: PUSH
81702: LD_VAR 0 3
81706: ARRAY
81707: IN
81708: IFFALSE 81732
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81710: LD_ADDR_EXP 82
81714: PUSH
81715: LD_EXP 82
81719: PPUSH
81720: LD_VAR 0 3
81724: PPUSH
81725: EMPTY
81726: PPUSH
81727: CALL_OW 1
81731: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
81732: LD_VAR 0 1
81736: PPUSH
81737: CALL_OW 247
81741: PUSH
81742: LD_INT 2
81744: EQUAL
81745: PUSH
81746: LD_VAR 0 1
81750: PPUSH
81751: CALL_OW 110
81755: PUSH
81756: LD_INT 20
81758: EQUAL
81759: PUSH
81760: LD_VAR 0 1
81764: PUSH
81765: LD_EXP 74
81769: PUSH
81770: LD_VAR 0 3
81774: ARRAY
81775: IN
81776: OR
81777: PUSH
81778: LD_VAR 0 1
81782: PPUSH
81783: CALL_OW 264
81787: PUSH
81788: LD_INT 12
81790: PUSH
81791: LD_INT 51
81793: PUSH
81794: LD_EXP 46
81798: PUSH
81799: LD_INT 32
81801: PUSH
81802: LD_INT 13
81804: PUSH
81805: LD_INT 52
81807: PUSH
81808: LD_INT 31
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: LIST
81815: LIST
81816: LIST
81817: LIST
81818: LIST
81819: IN
81820: OR
81821: AND
81822: IFFALSE 82130
// begin if un in mc_defender [ i ] then
81824: LD_VAR 0 1
81828: PUSH
81829: LD_EXP 74
81833: PUSH
81834: LD_VAR 0 3
81838: ARRAY
81839: IN
81840: IFFALSE 81879
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81842: LD_ADDR_EXP 74
81846: PUSH
81847: LD_EXP 74
81851: PPUSH
81852: LD_VAR 0 3
81856: PPUSH
81857: LD_EXP 74
81861: PUSH
81862: LD_VAR 0 3
81866: ARRAY
81867: PUSH
81868: LD_VAR 0 1
81872: DIFF
81873: PPUSH
81874: CALL_OW 1
81878: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
81879: LD_ADDR_VAR 0 8
81883: PUSH
81884: LD_VAR 0 3
81888: PPUSH
81889: LD_INT 3
81891: PPUSH
81892: CALL 78548 0 2
81896: ST_TO_ADDR
// if fac then
81897: LD_VAR 0 8
81901: IFFALSE 82130
// begin for j in fac do
81903: LD_ADDR_VAR 0 4
81907: PUSH
81908: LD_VAR 0 8
81912: PUSH
81913: FOR_IN
81914: IFFALSE 82128
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
81916: LD_ADDR_VAR 0 9
81920: PUSH
81921: LD_VAR 0 8
81925: PPUSH
81926: LD_VAR 0 1
81930: PPUSH
81931: CALL_OW 265
81935: PPUSH
81936: LD_VAR 0 1
81940: PPUSH
81941: CALL_OW 262
81945: PPUSH
81946: LD_VAR 0 1
81950: PPUSH
81951: CALL_OW 263
81955: PPUSH
81956: LD_VAR 0 1
81960: PPUSH
81961: CALL_OW 264
81965: PPUSH
81966: CALL 15951 0 5
81970: ST_TO_ADDR
// if components then
81971: LD_VAR 0 9
81975: IFFALSE 82126
// begin if GetWeapon ( un ) = ar_control_tower then
81977: LD_VAR 0 1
81981: PPUSH
81982: CALL_OW 264
81986: PUSH
81987: LD_INT 31
81989: EQUAL
81990: IFFALSE 82107
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
81992: LD_VAR 0 1
81996: PPUSH
81997: CALL_OW 311
82001: PPUSH
82002: LD_INT 0
82004: PPUSH
82005: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
82009: LD_ADDR_EXP 92
82013: PUSH
82014: LD_EXP 92
82018: PPUSH
82019: LD_VAR 0 3
82023: PPUSH
82024: LD_EXP 92
82028: PUSH
82029: LD_VAR 0 3
82033: ARRAY
82034: PUSH
82035: LD_VAR 0 1
82039: PPUSH
82040: CALL_OW 311
82044: DIFF
82045: PPUSH
82046: CALL_OW 1
82050: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
82051: LD_ADDR_VAR 0 7
82055: PUSH
82056: LD_EXP 73
82060: PUSH
82061: LD_VAR 0 3
82065: ARRAY
82066: PPUSH
82067: LD_INT 1
82069: PPUSH
82070: LD_VAR 0 9
82074: PPUSH
82075: CALL_OW 2
82079: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
82080: LD_ADDR_EXP 73
82084: PUSH
82085: LD_EXP 73
82089: PPUSH
82090: LD_VAR 0 3
82094: PPUSH
82095: LD_VAR 0 7
82099: PPUSH
82100: CALL_OW 1
82104: ST_TO_ADDR
// end else
82105: GO 82124
// MC_InsertProduceList ( i , [ components ] ) ;
82107: LD_VAR 0 3
82111: PPUSH
82112: LD_VAR 0 9
82116: PUSH
82117: EMPTY
82118: LIST
82119: PPUSH
82120: CALL 78093 0 2
// break ;
82124: GO 82128
// end ; end ;
82126: GO 81913
82128: POP
82129: POP
// end ; end ; if GetType ( un ) = unit_building then
82130: LD_VAR 0 1
82134: PPUSH
82135: CALL_OW 247
82139: PUSH
82140: LD_INT 3
82142: EQUAL
82143: IFFALSE 82546
// begin btype := GetBType ( un ) ;
82145: LD_ADDR_VAR 0 5
82149: PUSH
82150: LD_VAR 0 1
82154: PPUSH
82155: CALL_OW 266
82159: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
82160: LD_VAR 0 5
82164: PUSH
82165: LD_INT 29
82167: PUSH
82168: LD_INT 30
82170: PUSH
82171: EMPTY
82172: LIST
82173: LIST
82174: IN
82175: IFFALSE 82248
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
82177: LD_VAR 0 1
82181: PPUSH
82182: CALL_OW 250
82186: PPUSH
82187: LD_VAR 0 1
82191: PPUSH
82192: CALL_OW 251
82196: PPUSH
82197: LD_VAR 0 1
82201: PPUSH
82202: CALL_OW 255
82206: PPUSH
82207: CALL_OW 440
82211: NOT
82212: IFFALSE 82248
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
82214: LD_VAR 0 1
82218: PPUSH
82219: CALL_OW 250
82223: PPUSH
82224: LD_VAR 0 1
82228: PPUSH
82229: CALL_OW 251
82233: PPUSH
82234: LD_VAR 0 1
82238: PPUSH
82239: CALL_OW 255
82243: PPUSH
82244: CALL_OW 441
// end ; if btype = b_warehouse then
82248: LD_VAR 0 5
82252: PUSH
82253: LD_INT 1
82255: EQUAL
82256: IFFALSE 82274
// begin btype := b_depot ;
82258: LD_ADDR_VAR 0 5
82262: PUSH
82263: LD_INT 0
82265: ST_TO_ADDR
// pos := 1 ;
82266: LD_ADDR_VAR 0 6
82270: PUSH
82271: LD_INT 1
82273: ST_TO_ADDR
// end ; if btype = b_factory then
82274: LD_VAR 0 5
82278: PUSH
82279: LD_INT 3
82281: EQUAL
82282: IFFALSE 82300
// begin btype := b_workshop ;
82284: LD_ADDR_VAR 0 5
82288: PUSH
82289: LD_INT 2
82291: ST_TO_ADDR
// pos := 1 ;
82292: LD_ADDR_VAR 0 6
82296: PUSH
82297: LD_INT 1
82299: ST_TO_ADDR
// end ; if btype = b_barracks then
82300: LD_VAR 0 5
82304: PUSH
82305: LD_INT 5
82307: EQUAL
82308: IFFALSE 82318
// btype := b_armoury ;
82310: LD_ADDR_VAR 0 5
82314: PUSH
82315: LD_INT 4
82317: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
82318: LD_VAR 0 5
82322: PUSH
82323: LD_INT 7
82325: PUSH
82326: LD_INT 8
82328: PUSH
82329: EMPTY
82330: LIST
82331: LIST
82332: IN
82333: IFFALSE 82343
// btype := b_lab ;
82335: LD_ADDR_VAR 0 5
82339: PUSH
82340: LD_INT 6
82342: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
82343: LD_ADDR_EXP 57
82347: PUSH
82348: LD_EXP 57
82352: PPUSH
82353: LD_VAR 0 3
82357: PUSH
82358: LD_EXP 57
82362: PUSH
82363: LD_VAR 0 3
82367: ARRAY
82368: PUSH
82369: LD_INT 1
82371: PLUS
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: PPUSH
82377: LD_VAR 0 5
82381: PUSH
82382: LD_VAR 0 1
82386: PPUSH
82387: CALL_OW 250
82391: PUSH
82392: LD_VAR 0 1
82396: PPUSH
82397: CALL_OW 251
82401: PUSH
82402: LD_VAR 0 1
82406: PPUSH
82407: CALL_OW 254
82411: PUSH
82412: EMPTY
82413: LIST
82414: LIST
82415: LIST
82416: LIST
82417: PPUSH
82418: CALL 18419 0 3
82422: ST_TO_ADDR
// if pos = 1 then
82423: LD_VAR 0 6
82427: PUSH
82428: LD_INT 1
82430: EQUAL
82431: IFFALSE 82546
// begin tmp := mc_build_list [ i ] ;
82433: LD_ADDR_VAR 0 7
82437: PUSH
82438: LD_EXP 57
82442: PUSH
82443: LD_VAR 0 3
82447: ARRAY
82448: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82449: LD_VAR 0 7
82453: PPUSH
82454: LD_INT 2
82456: PUSH
82457: LD_INT 30
82459: PUSH
82460: LD_INT 0
82462: PUSH
82463: EMPTY
82464: LIST
82465: LIST
82466: PUSH
82467: LD_INT 30
82469: PUSH
82470: LD_INT 1
82472: PUSH
82473: EMPTY
82474: LIST
82475: LIST
82476: PUSH
82477: EMPTY
82478: LIST
82479: LIST
82480: LIST
82481: PPUSH
82482: CALL_OW 72
82486: IFFALSE 82496
// pos := 2 ;
82488: LD_ADDR_VAR 0 6
82492: PUSH
82493: LD_INT 2
82495: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
82496: LD_ADDR_VAR 0 7
82500: PUSH
82501: LD_VAR 0 7
82505: PPUSH
82506: LD_VAR 0 6
82510: PPUSH
82511: LD_VAR 0 7
82515: PPUSH
82516: CALL 18745 0 3
82520: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
82521: LD_ADDR_EXP 57
82525: PUSH
82526: LD_EXP 57
82530: PPUSH
82531: LD_VAR 0 3
82535: PPUSH
82536: LD_VAR 0 7
82540: PPUSH
82541: CALL_OW 1
82545: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
82546: LD_VAR 0 1
82550: PUSH
82551: LD_EXP 52
82555: PUSH
82556: LD_VAR 0 3
82560: ARRAY
82561: IN
82562: IFFALSE 82601
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
82564: LD_ADDR_EXP 52
82568: PUSH
82569: LD_EXP 52
82573: PPUSH
82574: LD_VAR 0 3
82578: PPUSH
82579: LD_EXP 52
82583: PUSH
82584: LD_VAR 0 3
82588: ARRAY
82589: PUSH
82590: LD_VAR 0 1
82594: DIFF
82595: PPUSH
82596: CALL_OW 1
82600: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
82601: LD_VAR 0 1
82605: PUSH
82606: LD_EXP 59
82610: PUSH
82611: LD_VAR 0 3
82615: ARRAY
82616: IN
82617: IFFALSE 82656
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
82619: LD_ADDR_EXP 59
82623: PUSH
82624: LD_EXP 59
82628: PPUSH
82629: LD_VAR 0 3
82633: PPUSH
82634: LD_EXP 59
82638: PUSH
82639: LD_VAR 0 3
82643: ARRAY
82644: PUSH
82645: LD_VAR 0 1
82649: DIFF
82650: PPUSH
82651: CALL_OW 1
82655: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
82656: LD_VAR 0 1
82660: PUSH
82661: LD_EXP 71
82665: PUSH
82666: LD_VAR 0 3
82670: ARRAY
82671: IN
82672: IFFALSE 82711
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
82674: LD_ADDR_EXP 71
82678: PUSH
82679: LD_EXP 71
82683: PPUSH
82684: LD_VAR 0 3
82688: PPUSH
82689: LD_EXP 71
82693: PUSH
82694: LD_VAR 0 3
82698: ARRAY
82699: PUSH
82700: LD_VAR 0 1
82704: DIFF
82705: PPUSH
82706: CALL_OW 1
82710: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
82711: LD_VAR 0 1
82715: PUSH
82716: LD_EXP 74
82720: PUSH
82721: LD_VAR 0 3
82725: ARRAY
82726: IN
82727: IFFALSE 82766
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82729: LD_ADDR_EXP 74
82733: PUSH
82734: LD_EXP 74
82738: PPUSH
82739: LD_VAR 0 3
82743: PPUSH
82744: LD_EXP 74
82748: PUSH
82749: LD_VAR 0 3
82753: ARRAY
82754: PUSH
82755: LD_VAR 0 1
82759: DIFF
82760: PPUSH
82761: CALL_OW 1
82765: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
82766: LD_VAR 0 1
82770: PUSH
82771: LD_EXP 61
82775: PUSH
82776: LD_VAR 0 3
82780: ARRAY
82781: IN
82782: IFFALSE 82821
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
82784: LD_ADDR_EXP 61
82788: PUSH
82789: LD_EXP 61
82793: PPUSH
82794: LD_VAR 0 3
82798: PPUSH
82799: LD_EXP 61
82803: PUSH
82804: LD_VAR 0 3
82808: ARRAY
82809: PUSH
82810: LD_VAR 0 1
82814: DIFF
82815: PPUSH
82816: CALL_OW 1
82820: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
82821: LD_VAR 0 1
82825: PUSH
82826: LD_EXP 60
82830: PUSH
82831: LD_VAR 0 3
82835: ARRAY
82836: IN
82837: IFFALSE 82876
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
82839: LD_ADDR_EXP 60
82843: PUSH
82844: LD_EXP 60
82848: PPUSH
82849: LD_VAR 0 3
82853: PPUSH
82854: LD_EXP 60
82858: PUSH
82859: LD_VAR 0 3
82863: ARRAY
82864: PUSH
82865: LD_VAR 0 1
82869: DIFF
82870: PPUSH
82871: CALL_OW 1
82875: ST_TO_ADDR
// end ; break ;
82876: GO 82880
// end ;
82878: GO 81526
82880: POP
82881: POP
// end ;
82882: LD_VAR 0 2
82886: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
82887: LD_INT 0
82889: PPUSH
82890: PPUSH
82891: PPUSH
// if not mc_bases or not skirmish then
82892: LD_EXP 52
82896: NOT
82897: PUSH
82898: LD_EXP 50
82902: NOT
82903: OR
82904: IFFALSE 82908
// exit ;
82906: GO 83123
// for i = 1 to mc_bases do
82908: LD_ADDR_VAR 0 3
82912: PUSH
82913: DOUBLE
82914: LD_INT 1
82916: DEC
82917: ST_TO_ADDR
82918: LD_EXP 52
82922: PUSH
82923: FOR_TO
82924: IFFALSE 83121
// begin if building in mc_construct_list [ i ] then
82926: LD_VAR 0 1
82930: PUSH
82931: LD_EXP 59
82935: PUSH
82936: LD_VAR 0 3
82940: ARRAY
82941: IN
82942: IFFALSE 83119
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82944: LD_ADDR_EXP 59
82948: PUSH
82949: LD_EXP 59
82953: PPUSH
82954: LD_VAR 0 3
82958: PPUSH
82959: LD_EXP 59
82963: PUSH
82964: LD_VAR 0 3
82968: ARRAY
82969: PUSH
82970: LD_VAR 0 1
82974: DIFF
82975: PPUSH
82976: CALL_OW 1
82980: ST_TO_ADDR
// if building in mc_lab [ i ] then
82981: LD_VAR 0 1
82985: PUSH
82986: LD_EXP 85
82990: PUSH
82991: LD_VAR 0 3
82995: ARRAY
82996: IN
82997: IFFALSE 83052
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
82999: LD_ADDR_EXP 86
83003: PUSH
83004: LD_EXP 86
83008: PPUSH
83009: LD_VAR 0 3
83013: PPUSH
83014: LD_EXP 86
83018: PUSH
83019: LD_VAR 0 3
83023: ARRAY
83024: PPUSH
83025: LD_INT 1
83027: PPUSH
83028: LD_EXP 86
83032: PUSH
83033: LD_VAR 0 3
83037: ARRAY
83038: PPUSH
83039: LD_INT 0
83041: PPUSH
83042: CALL 17837 0 4
83046: PPUSH
83047: CALL_OW 1
83051: ST_TO_ADDR
// if not building in mc_bases [ i ] then
83052: LD_VAR 0 1
83056: PUSH
83057: LD_EXP 52
83061: PUSH
83062: LD_VAR 0 3
83066: ARRAY
83067: IN
83068: NOT
83069: IFFALSE 83115
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83071: LD_ADDR_EXP 52
83075: PUSH
83076: LD_EXP 52
83080: PPUSH
83081: LD_VAR 0 3
83085: PUSH
83086: LD_EXP 52
83090: PUSH
83091: LD_VAR 0 3
83095: ARRAY
83096: PUSH
83097: LD_INT 1
83099: PLUS
83100: PUSH
83101: EMPTY
83102: LIST
83103: LIST
83104: PPUSH
83105: LD_VAR 0 1
83109: PPUSH
83110: CALL 18419 0 3
83114: ST_TO_ADDR
// exit ;
83115: POP
83116: POP
83117: GO 83123
// end ; end ;
83119: GO 82923
83121: POP
83122: POP
// end ;
83123: LD_VAR 0 2
83127: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
83128: LD_INT 0
83130: PPUSH
83131: PPUSH
83132: PPUSH
83133: PPUSH
83134: PPUSH
83135: PPUSH
83136: PPUSH
// if not mc_bases or not skirmish then
83137: LD_EXP 52
83141: NOT
83142: PUSH
83143: LD_EXP 50
83147: NOT
83148: OR
83149: IFFALSE 83153
// exit ;
83151: GO 83814
// for i = 1 to mc_bases do
83153: LD_ADDR_VAR 0 3
83157: PUSH
83158: DOUBLE
83159: LD_INT 1
83161: DEC
83162: ST_TO_ADDR
83163: LD_EXP 52
83167: PUSH
83168: FOR_TO
83169: IFFALSE 83812
// begin if building in mc_construct_list [ i ] then
83171: LD_VAR 0 1
83175: PUSH
83176: LD_EXP 59
83180: PUSH
83181: LD_VAR 0 3
83185: ARRAY
83186: IN
83187: IFFALSE 83810
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83189: LD_ADDR_EXP 59
83193: PUSH
83194: LD_EXP 59
83198: PPUSH
83199: LD_VAR 0 3
83203: PPUSH
83204: LD_EXP 59
83208: PUSH
83209: LD_VAR 0 3
83213: ARRAY
83214: PUSH
83215: LD_VAR 0 1
83219: DIFF
83220: PPUSH
83221: CALL_OW 1
83225: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83226: LD_ADDR_EXP 52
83230: PUSH
83231: LD_EXP 52
83235: PPUSH
83236: LD_VAR 0 3
83240: PUSH
83241: LD_EXP 52
83245: PUSH
83246: LD_VAR 0 3
83250: ARRAY
83251: PUSH
83252: LD_INT 1
83254: PLUS
83255: PUSH
83256: EMPTY
83257: LIST
83258: LIST
83259: PPUSH
83260: LD_VAR 0 1
83264: PPUSH
83265: CALL 18419 0 3
83269: ST_TO_ADDR
// btype := GetBType ( building ) ;
83270: LD_ADDR_VAR 0 5
83274: PUSH
83275: LD_VAR 0 1
83279: PPUSH
83280: CALL_OW 266
83284: ST_TO_ADDR
// side := GetSide ( building ) ;
83285: LD_ADDR_VAR 0 8
83289: PUSH
83290: LD_VAR 0 1
83294: PPUSH
83295: CALL_OW 255
83299: ST_TO_ADDR
// if btype = b_lab then
83300: LD_VAR 0 5
83304: PUSH
83305: LD_INT 6
83307: EQUAL
83308: IFFALSE 83358
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
83310: LD_ADDR_EXP 85
83314: PUSH
83315: LD_EXP 85
83319: PPUSH
83320: LD_VAR 0 3
83324: PUSH
83325: LD_EXP 85
83329: PUSH
83330: LD_VAR 0 3
83334: ARRAY
83335: PUSH
83336: LD_INT 1
83338: PLUS
83339: PUSH
83340: EMPTY
83341: LIST
83342: LIST
83343: PPUSH
83344: LD_VAR 0 1
83348: PPUSH
83349: CALL 18419 0 3
83353: ST_TO_ADDR
// exit ;
83354: POP
83355: POP
83356: GO 83814
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
83358: LD_VAR 0 5
83362: PUSH
83363: LD_INT 0
83365: PUSH
83366: LD_INT 2
83368: PUSH
83369: LD_INT 4
83371: PUSH
83372: EMPTY
83373: LIST
83374: LIST
83375: LIST
83376: IN
83377: IFFALSE 83501
// begin if btype = b_armoury then
83379: LD_VAR 0 5
83383: PUSH
83384: LD_INT 4
83386: EQUAL
83387: IFFALSE 83397
// btype := b_barracks ;
83389: LD_ADDR_VAR 0 5
83393: PUSH
83394: LD_INT 5
83396: ST_TO_ADDR
// if btype = b_depot then
83397: LD_VAR 0 5
83401: PUSH
83402: LD_INT 0
83404: EQUAL
83405: IFFALSE 83415
// btype := b_warehouse ;
83407: LD_ADDR_VAR 0 5
83411: PUSH
83412: LD_INT 1
83414: ST_TO_ADDR
// if btype = b_workshop then
83415: LD_VAR 0 5
83419: PUSH
83420: LD_INT 2
83422: EQUAL
83423: IFFALSE 83433
// btype := b_factory ;
83425: LD_ADDR_VAR 0 5
83429: PUSH
83430: LD_INT 3
83432: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
83433: LD_VAR 0 5
83437: PPUSH
83438: LD_VAR 0 8
83442: PPUSH
83443: CALL_OW 323
83447: PUSH
83448: LD_INT 1
83450: EQUAL
83451: IFFALSE 83497
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
83453: LD_ADDR_EXP 84
83457: PUSH
83458: LD_EXP 84
83462: PPUSH
83463: LD_VAR 0 3
83467: PUSH
83468: LD_EXP 84
83472: PUSH
83473: LD_VAR 0 3
83477: ARRAY
83478: PUSH
83479: LD_INT 1
83481: PLUS
83482: PUSH
83483: EMPTY
83484: LIST
83485: LIST
83486: PPUSH
83487: LD_VAR 0 1
83491: PPUSH
83492: CALL 18419 0 3
83496: ST_TO_ADDR
// exit ;
83497: POP
83498: POP
83499: GO 83814
// end ; if btype in [ b_bunker , b_turret ] then
83501: LD_VAR 0 5
83505: PUSH
83506: LD_INT 32
83508: PUSH
83509: LD_INT 33
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: IN
83516: IFFALSE 83806
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
83518: LD_ADDR_EXP 60
83522: PUSH
83523: LD_EXP 60
83527: PPUSH
83528: LD_VAR 0 3
83532: PUSH
83533: LD_EXP 60
83537: PUSH
83538: LD_VAR 0 3
83542: ARRAY
83543: PUSH
83544: LD_INT 1
83546: PLUS
83547: PUSH
83548: EMPTY
83549: LIST
83550: LIST
83551: PPUSH
83552: LD_VAR 0 1
83556: PPUSH
83557: CALL 18419 0 3
83561: ST_TO_ADDR
// if btype = b_bunker then
83562: LD_VAR 0 5
83566: PUSH
83567: LD_INT 32
83569: EQUAL
83570: IFFALSE 83806
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83572: LD_ADDR_EXP 61
83576: PUSH
83577: LD_EXP 61
83581: PPUSH
83582: LD_VAR 0 3
83586: PUSH
83587: LD_EXP 61
83591: PUSH
83592: LD_VAR 0 3
83596: ARRAY
83597: PUSH
83598: LD_INT 1
83600: PLUS
83601: PUSH
83602: EMPTY
83603: LIST
83604: LIST
83605: PPUSH
83606: LD_VAR 0 1
83610: PPUSH
83611: CALL 18419 0 3
83615: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
83616: LD_ADDR_VAR 0 6
83620: PUSH
83621: LD_EXP 52
83625: PUSH
83626: LD_VAR 0 3
83630: ARRAY
83631: PPUSH
83632: LD_INT 25
83634: PUSH
83635: LD_INT 1
83637: PUSH
83638: EMPTY
83639: LIST
83640: LIST
83641: PUSH
83642: LD_INT 3
83644: PUSH
83645: LD_INT 54
83647: PUSH
83648: EMPTY
83649: LIST
83650: PUSH
83651: EMPTY
83652: LIST
83653: LIST
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PPUSH
83659: CALL_OW 72
83663: ST_TO_ADDR
// if tmp then
83664: LD_VAR 0 6
83668: IFFALSE 83674
// exit ;
83670: POP
83671: POP
83672: GO 83814
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
83674: LD_ADDR_VAR 0 6
83678: PUSH
83679: LD_EXP 52
83683: PUSH
83684: LD_VAR 0 3
83688: ARRAY
83689: PPUSH
83690: LD_INT 2
83692: PUSH
83693: LD_INT 30
83695: PUSH
83696: LD_INT 4
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: PUSH
83703: LD_INT 30
83705: PUSH
83706: LD_INT 5
83708: PUSH
83709: EMPTY
83710: LIST
83711: LIST
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: LIST
83717: PPUSH
83718: CALL_OW 72
83722: ST_TO_ADDR
// if not tmp then
83723: LD_VAR 0 6
83727: NOT
83728: IFFALSE 83734
// exit ;
83730: POP
83731: POP
83732: GO 83814
// for j in tmp do
83734: LD_ADDR_VAR 0 4
83738: PUSH
83739: LD_VAR 0 6
83743: PUSH
83744: FOR_IN
83745: IFFALSE 83804
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
83747: LD_ADDR_VAR 0 7
83751: PUSH
83752: LD_VAR 0 4
83756: PPUSH
83757: CALL_OW 313
83761: PPUSH
83762: LD_INT 25
83764: PUSH
83765: LD_INT 1
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: PPUSH
83772: CALL_OW 72
83776: ST_TO_ADDR
// if units then
83777: LD_VAR 0 7
83781: IFFALSE 83802
// begin ComExitBuilding ( units [ 1 ] ) ;
83783: LD_VAR 0 7
83787: PUSH
83788: LD_INT 1
83790: ARRAY
83791: PPUSH
83792: CALL_OW 122
// exit ;
83796: POP
83797: POP
83798: POP
83799: POP
83800: GO 83814
// end ; end ;
83802: GO 83744
83804: POP
83805: POP
// end ; end ; exit ;
83806: POP
83807: POP
83808: GO 83814
// end ; end ;
83810: GO 83168
83812: POP
83813: POP
// end ;
83814: LD_VAR 0 2
83818: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
83819: LD_INT 0
83821: PPUSH
83822: PPUSH
83823: PPUSH
83824: PPUSH
83825: PPUSH
83826: PPUSH
83827: PPUSH
// if not mc_bases or not skirmish then
83828: LD_EXP 52
83832: NOT
83833: PUSH
83834: LD_EXP 50
83838: NOT
83839: OR
83840: IFFALSE 83844
// exit ;
83842: GO 84075
// btype := GetBType ( building ) ;
83844: LD_ADDR_VAR 0 6
83848: PUSH
83849: LD_VAR 0 1
83853: PPUSH
83854: CALL_OW 266
83858: ST_TO_ADDR
// x := GetX ( building ) ;
83859: LD_ADDR_VAR 0 7
83863: PUSH
83864: LD_VAR 0 1
83868: PPUSH
83869: CALL_OW 250
83873: ST_TO_ADDR
// y := GetY ( building ) ;
83874: LD_ADDR_VAR 0 8
83878: PUSH
83879: LD_VAR 0 1
83883: PPUSH
83884: CALL_OW 251
83888: ST_TO_ADDR
// d := GetDir ( building ) ;
83889: LD_ADDR_VAR 0 9
83893: PUSH
83894: LD_VAR 0 1
83898: PPUSH
83899: CALL_OW 254
83903: ST_TO_ADDR
// for i = 1 to mc_bases do
83904: LD_ADDR_VAR 0 4
83908: PUSH
83909: DOUBLE
83910: LD_INT 1
83912: DEC
83913: ST_TO_ADDR
83914: LD_EXP 52
83918: PUSH
83919: FOR_TO
83920: IFFALSE 84073
// begin if not mc_build_list [ i ] then
83922: LD_EXP 57
83926: PUSH
83927: LD_VAR 0 4
83931: ARRAY
83932: NOT
83933: IFFALSE 83937
// continue ;
83935: GO 83919
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
83937: LD_VAR 0 6
83941: PUSH
83942: LD_VAR 0 7
83946: PUSH
83947: LD_VAR 0 8
83951: PUSH
83952: LD_VAR 0 9
83956: PUSH
83957: EMPTY
83958: LIST
83959: LIST
83960: LIST
83961: LIST
83962: PPUSH
83963: LD_EXP 57
83967: PUSH
83968: LD_VAR 0 4
83972: ARRAY
83973: PUSH
83974: LD_INT 1
83976: ARRAY
83977: PPUSH
83978: CALL 24588 0 2
83982: IFFALSE 84071
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
83984: LD_ADDR_EXP 57
83988: PUSH
83989: LD_EXP 57
83993: PPUSH
83994: LD_VAR 0 4
83998: PPUSH
83999: LD_EXP 57
84003: PUSH
84004: LD_VAR 0 4
84008: ARRAY
84009: PPUSH
84010: LD_INT 1
84012: PPUSH
84013: CALL_OW 3
84017: PPUSH
84018: CALL_OW 1
84022: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
84023: LD_ADDR_EXP 59
84027: PUSH
84028: LD_EXP 59
84032: PPUSH
84033: LD_VAR 0 4
84037: PUSH
84038: LD_EXP 59
84042: PUSH
84043: LD_VAR 0 4
84047: ARRAY
84048: PUSH
84049: LD_INT 1
84051: PLUS
84052: PUSH
84053: EMPTY
84054: LIST
84055: LIST
84056: PPUSH
84057: LD_VAR 0 1
84061: PPUSH
84062: CALL 18419 0 3
84066: ST_TO_ADDR
// exit ;
84067: POP
84068: POP
84069: GO 84075
// end ; end ;
84071: GO 83919
84073: POP
84074: POP
// end ;
84075: LD_VAR 0 3
84079: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
84080: LD_INT 0
84082: PPUSH
84083: PPUSH
84084: PPUSH
// if not mc_bases or not skirmish then
84085: LD_EXP 52
84089: NOT
84090: PUSH
84091: LD_EXP 50
84095: NOT
84096: OR
84097: IFFALSE 84101
// exit ;
84099: GO 84291
// for i = 1 to mc_bases do
84101: LD_ADDR_VAR 0 4
84105: PUSH
84106: DOUBLE
84107: LD_INT 1
84109: DEC
84110: ST_TO_ADDR
84111: LD_EXP 52
84115: PUSH
84116: FOR_TO
84117: IFFALSE 84204
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
84119: LD_VAR 0 1
84123: PUSH
84124: LD_EXP 60
84128: PUSH
84129: LD_VAR 0 4
84133: ARRAY
84134: IN
84135: PUSH
84136: LD_VAR 0 1
84140: PUSH
84141: LD_EXP 61
84145: PUSH
84146: LD_VAR 0 4
84150: ARRAY
84151: IN
84152: NOT
84153: AND
84154: IFFALSE 84202
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84156: LD_ADDR_EXP 61
84160: PUSH
84161: LD_EXP 61
84165: PPUSH
84166: LD_VAR 0 4
84170: PUSH
84171: LD_EXP 61
84175: PUSH
84176: LD_VAR 0 4
84180: ARRAY
84181: PUSH
84182: LD_INT 1
84184: PLUS
84185: PUSH
84186: EMPTY
84187: LIST
84188: LIST
84189: PPUSH
84190: LD_VAR 0 1
84194: PPUSH
84195: CALL 18419 0 3
84199: ST_TO_ADDR
// break ;
84200: GO 84204
// end ; end ;
84202: GO 84116
84204: POP
84205: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
84206: LD_VAR 0 1
84210: PPUSH
84211: CALL_OW 257
84215: PUSH
84216: LD_EXP 78
84220: IN
84221: PUSH
84222: LD_VAR 0 1
84226: PPUSH
84227: CALL_OW 266
84231: PUSH
84232: LD_INT 5
84234: EQUAL
84235: AND
84236: PUSH
84237: LD_VAR 0 2
84241: PPUSH
84242: CALL_OW 110
84246: PUSH
84247: LD_INT 18
84249: NONEQUAL
84250: AND
84251: IFFALSE 84291
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
84253: LD_VAR 0 2
84257: PPUSH
84258: CALL_OW 257
84262: PUSH
84263: LD_INT 5
84265: PUSH
84266: LD_INT 8
84268: PUSH
84269: LD_INT 9
84271: PUSH
84272: EMPTY
84273: LIST
84274: LIST
84275: LIST
84276: IN
84277: IFFALSE 84291
// SetClass ( unit , 1 ) ;
84279: LD_VAR 0 2
84283: PPUSH
84284: LD_INT 1
84286: PPUSH
84287: CALL_OW 336
// end ;
84291: LD_VAR 0 3
84295: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
84296: LD_INT 0
84298: PPUSH
84299: PPUSH
// if not mc_bases or not skirmish then
84300: LD_EXP 52
84304: NOT
84305: PUSH
84306: LD_EXP 50
84310: NOT
84311: OR
84312: IFFALSE 84316
// exit ;
84314: GO 84432
// if GetLives ( abandoned_vehicle ) > 250 then
84316: LD_VAR 0 2
84320: PPUSH
84321: CALL_OW 256
84325: PUSH
84326: LD_INT 250
84328: GREATER
84329: IFFALSE 84333
// exit ;
84331: GO 84432
// for i = 1 to mc_bases do
84333: LD_ADDR_VAR 0 6
84337: PUSH
84338: DOUBLE
84339: LD_INT 1
84341: DEC
84342: ST_TO_ADDR
84343: LD_EXP 52
84347: PUSH
84348: FOR_TO
84349: IFFALSE 84430
// begin if driver in mc_bases [ i ] then
84351: LD_VAR 0 1
84355: PUSH
84356: LD_EXP 52
84360: PUSH
84361: LD_VAR 0 6
84365: ARRAY
84366: IN
84367: IFFALSE 84428
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
84369: LD_VAR 0 1
84373: PPUSH
84374: LD_EXP 52
84378: PUSH
84379: LD_VAR 0 6
84383: ARRAY
84384: PPUSH
84385: LD_INT 2
84387: PUSH
84388: LD_INT 30
84390: PUSH
84391: LD_INT 0
84393: PUSH
84394: EMPTY
84395: LIST
84396: LIST
84397: PUSH
84398: LD_INT 30
84400: PUSH
84401: LD_INT 1
84403: PUSH
84404: EMPTY
84405: LIST
84406: LIST
84407: PUSH
84408: EMPTY
84409: LIST
84410: LIST
84411: LIST
84412: PPUSH
84413: CALL_OW 72
84417: PUSH
84418: LD_INT 1
84420: ARRAY
84421: PPUSH
84422: CALL_OW 112
// break ;
84426: GO 84430
// end ; end ;
84428: GO 84348
84430: POP
84431: POP
// end ; end_of_file end_of_file
84432: LD_VAR 0 5
84436: RET
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun ; every 0 0$1 do
84437: GO 84439
84439: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
84440: LD_STRING initStreamRollete();
84442: PPUSH
84443: CALL_OW 559
// InitStreamMode ;
84447: CALL 84452 0 0
// end ;
84451: END
// function InitStreamMode ; begin
84452: LD_INT 0
84454: PPUSH
// streamModeActive := false ;
84455: LD_ADDR_EXP 95
84459: PUSH
84460: LD_INT 0
84462: ST_TO_ADDR
// sRocket := false ;
84463: LD_ADDR_EXP 98
84467: PUSH
84468: LD_INT 0
84470: ST_TO_ADDR
// sSpeed := false ;
84471: LD_ADDR_EXP 97
84475: PUSH
84476: LD_INT 0
84478: ST_TO_ADDR
// sEngine := false ;
84479: LD_ADDR_EXP 99
84483: PUSH
84484: LD_INT 0
84486: ST_TO_ADDR
// sSpec := false ;
84487: LD_ADDR_EXP 96
84491: PUSH
84492: LD_INT 0
84494: ST_TO_ADDR
// sLevel := false ;
84495: LD_ADDR_EXP 100
84499: PUSH
84500: LD_INT 0
84502: ST_TO_ADDR
// sArmoury := false ;
84503: LD_ADDR_EXP 101
84507: PUSH
84508: LD_INT 0
84510: ST_TO_ADDR
// sRadar := false ;
84511: LD_ADDR_EXP 102
84515: PUSH
84516: LD_INT 0
84518: ST_TO_ADDR
// sBunker := false ;
84519: LD_ADDR_EXP 103
84523: PUSH
84524: LD_INT 0
84526: ST_TO_ADDR
// sHack := false ;
84527: LD_ADDR_EXP 104
84531: PUSH
84532: LD_INT 0
84534: ST_TO_ADDR
// sFire := false ;
84535: LD_ADDR_EXP 105
84539: PUSH
84540: LD_INT 0
84542: ST_TO_ADDR
// sRefresh := false ;
84543: LD_ADDR_EXP 106
84547: PUSH
84548: LD_INT 0
84550: ST_TO_ADDR
// sExp := false ;
84551: LD_ADDR_EXP 107
84555: PUSH
84556: LD_INT 0
84558: ST_TO_ADDR
// sDepot := false ;
84559: LD_ADDR_EXP 108
84563: PUSH
84564: LD_INT 0
84566: ST_TO_ADDR
// sFlag := false ;
84567: LD_ADDR_EXP 109
84571: PUSH
84572: LD_INT 0
84574: ST_TO_ADDR
// sSold := false ;
84575: LD_ADDR_EXP 110
84579: PUSH
84580: LD_INT 0
84582: ST_TO_ADDR
// sDiff := false ;
84583: LD_ADDR_EXP 111
84587: PUSH
84588: LD_INT 0
84590: ST_TO_ADDR
// sTiger := false ;
84591: LD_ADDR_EXP 112
84595: PUSH
84596: LD_INT 0
84598: ST_TO_ADDR
// sBomb := false ;
84599: LD_ADDR_EXP 113
84603: PUSH
84604: LD_INT 0
84606: ST_TO_ADDR
// sFog := false ;
84607: LD_ADDR_EXP 114
84611: PUSH
84612: LD_INT 0
84614: ST_TO_ADDR
// sReset := false ;
84615: LD_ADDR_EXP 115
84619: PUSH
84620: LD_INT 0
84622: ST_TO_ADDR
// sSun := false ;
84623: LD_ADDR_EXP 116
84627: PUSH
84628: LD_INT 0
84630: ST_TO_ADDR
// end ;
84631: LD_VAR 0 1
84635: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
84636: LD_VAR 0 2
84640: PUSH
84641: LD_INT 100
84643: EQUAL
84644: IFFALSE 85053
// begin if not StreamModeActive then
84646: LD_EXP 95
84650: NOT
84651: IFFALSE 84661
// StreamModeActive := true ;
84653: LD_ADDR_EXP 95
84657: PUSH
84658: LD_INT 1
84660: ST_TO_ADDR
// if p3 = 0 then
84661: LD_VAR 0 3
84665: PUSH
84666: LD_INT 0
84668: EQUAL
84669: IFFALSE 84675
// InitStreamMode ;
84671: CALL 84452 0 0
// if p3 = 1 then
84675: LD_VAR 0 3
84679: PUSH
84680: LD_INT 1
84682: EQUAL
84683: IFFALSE 84693
// sRocket := true ;
84685: LD_ADDR_EXP 98
84689: PUSH
84690: LD_INT 1
84692: ST_TO_ADDR
// if p3 = 2 then
84693: LD_VAR 0 3
84697: PUSH
84698: LD_INT 2
84700: EQUAL
84701: IFFALSE 84711
// sSpeed := true ;
84703: LD_ADDR_EXP 97
84707: PUSH
84708: LD_INT 1
84710: ST_TO_ADDR
// if p3 = 3 then
84711: LD_VAR 0 3
84715: PUSH
84716: LD_INT 3
84718: EQUAL
84719: IFFALSE 84729
// sEngine := true ;
84721: LD_ADDR_EXP 99
84725: PUSH
84726: LD_INT 1
84728: ST_TO_ADDR
// if p3 = 4 then
84729: LD_VAR 0 3
84733: PUSH
84734: LD_INT 4
84736: EQUAL
84737: IFFALSE 84747
// sSpec := true ;
84739: LD_ADDR_EXP 96
84743: PUSH
84744: LD_INT 1
84746: ST_TO_ADDR
// if p3 = 5 then
84747: LD_VAR 0 3
84751: PUSH
84752: LD_INT 5
84754: EQUAL
84755: IFFALSE 84765
// sLevel := true ;
84757: LD_ADDR_EXP 100
84761: PUSH
84762: LD_INT 1
84764: ST_TO_ADDR
// if p3 = 6 then
84765: LD_VAR 0 3
84769: PUSH
84770: LD_INT 6
84772: EQUAL
84773: IFFALSE 84783
// sArmoury := true ;
84775: LD_ADDR_EXP 101
84779: PUSH
84780: LD_INT 1
84782: ST_TO_ADDR
// if p3 = 7 then
84783: LD_VAR 0 3
84787: PUSH
84788: LD_INT 7
84790: EQUAL
84791: IFFALSE 84801
// sRadar := true ;
84793: LD_ADDR_EXP 102
84797: PUSH
84798: LD_INT 1
84800: ST_TO_ADDR
// if p3 = 8 then
84801: LD_VAR 0 3
84805: PUSH
84806: LD_INT 8
84808: EQUAL
84809: IFFALSE 84819
// sBunker := true ;
84811: LD_ADDR_EXP 103
84815: PUSH
84816: LD_INT 1
84818: ST_TO_ADDR
// if p3 = 9 then
84819: LD_VAR 0 3
84823: PUSH
84824: LD_INT 9
84826: EQUAL
84827: IFFALSE 84837
// sHack := true ;
84829: LD_ADDR_EXP 104
84833: PUSH
84834: LD_INT 1
84836: ST_TO_ADDR
// if p3 = 10 then
84837: LD_VAR 0 3
84841: PUSH
84842: LD_INT 10
84844: EQUAL
84845: IFFALSE 84855
// sFire := true ;
84847: LD_ADDR_EXP 105
84851: PUSH
84852: LD_INT 1
84854: ST_TO_ADDR
// if p3 = 11 then
84855: LD_VAR 0 3
84859: PUSH
84860: LD_INT 11
84862: EQUAL
84863: IFFALSE 84873
// sRefresh := true ;
84865: LD_ADDR_EXP 106
84869: PUSH
84870: LD_INT 1
84872: ST_TO_ADDR
// if p3 = 12 then
84873: LD_VAR 0 3
84877: PUSH
84878: LD_INT 12
84880: EQUAL
84881: IFFALSE 84891
// sExp := true ;
84883: LD_ADDR_EXP 107
84887: PUSH
84888: LD_INT 1
84890: ST_TO_ADDR
// if p3 = 13 then
84891: LD_VAR 0 3
84895: PUSH
84896: LD_INT 13
84898: EQUAL
84899: IFFALSE 84909
// sDepot := true ;
84901: LD_ADDR_EXP 108
84905: PUSH
84906: LD_INT 1
84908: ST_TO_ADDR
// if p3 = 14 then
84909: LD_VAR 0 3
84913: PUSH
84914: LD_INT 14
84916: EQUAL
84917: IFFALSE 84927
// sFlag := true ;
84919: LD_ADDR_EXP 109
84923: PUSH
84924: LD_INT 1
84926: ST_TO_ADDR
// if p3 = 101 then
84927: LD_VAR 0 3
84931: PUSH
84932: LD_INT 101
84934: EQUAL
84935: IFFALSE 84945
// sSold := true ;
84937: LD_ADDR_EXP 110
84941: PUSH
84942: LD_INT 1
84944: ST_TO_ADDR
// if p3 = 102 then
84945: LD_VAR 0 3
84949: PUSH
84950: LD_INT 102
84952: EQUAL
84953: IFFALSE 84963
// sDiff := true ;
84955: LD_ADDR_EXP 111
84959: PUSH
84960: LD_INT 1
84962: ST_TO_ADDR
// if p3 = 103 then
84963: LD_VAR 0 3
84967: PUSH
84968: LD_INT 103
84970: EQUAL
84971: IFFALSE 84981
// sFog := true ;
84973: LD_ADDR_EXP 114
84977: PUSH
84978: LD_INT 1
84980: ST_TO_ADDR
// if p3 = 104 then
84981: LD_VAR 0 3
84985: PUSH
84986: LD_INT 104
84988: EQUAL
84989: IFFALSE 84999
// sReset := true ;
84991: LD_ADDR_EXP 115
84995: PUSH
84996: LD_INT 1
84998: ST_TO_ADDR
// if p3 = 105 then
84999: LD_VAR 0 3
85003: PUSH
85004: LD_INT 105
85006: EQUAL
85007: IFFALSE 85017
// sSun := true ;
85009: LD_ADDR_EXP 116
85013: PUSH
85014: LD_INT 1
85016: ST_TO_ADDR
// if p3 = 106 then
85017: LD_VAR 0 3
85021: PUSH
85022: LD_INT 106
85024: EQUAL
85025: IFFALSE 85035
// sTiger := true ;
85027: LD_ADDR_EXP 112
85031: PUSH
85032: LD_INT 1
85034: ST_TO_ADDR
// if p3 = 107 then
85035: LD_VAR 0 3
85039: PUSH
85040: LD_INT 107
85042: EQUAL
85043: IFFALSE 85053
// sBomb := true ;
85045: LD_ADDR_EXP 113
85049: PUSH
85050: LD_INT 1
85052: ST_TO_ADDR
// end ; end ;
85053: PPOPN 6
85055: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
85056: LD_EXP 95
85060: PUSH
85061: LD_EXP 98
85065: AND
85066: IFFALSE 85187
85068: GO 85070
85070: DISABLE
85071: LD_INT 0
85073: PPUSH
85074: PPUSH
// begin enable ;
85075: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
85076: LD_ADDR_VAR 0 2
85080: PUSH
85081: LD_INT 22
85083: PUSH
85084: LD_OWVAR 2
85088: PUSH
85089: EMPTY
85090: LIST
85091: LIST
85092: PUSH
85093: LD_INT 2
85095: PUSH
85096: LD_INT 34
85098: PUSH
85099: LD_INT 7
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: PUSH
85106: LD_INT 34
85108: PUSH
85109: LD_INT 45
85111: PUSH
85112: EMPTY
85113: LIST
85114: LIST
85115: PUSH
85116: LD_INT 34
85118: PUSH
85119: LD_INT 28
85121: PUSH
85122: EMPTY
85123: LIST
85124: LIST
85125: PUSH
85126: LD_INT 34
85128: PUSH
85129: LD_INT 47
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: LIST
85140: LIST
85141: LIST
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: PPUSH
85147: CALL_OW 69
85151: ST_TO_ADDR
// if not tmp then
85152: LD_VAR 0 2
85156: NOT
85157: IFFALSE 85161
// exit ;
85159: GO 85187
// for i in tmp do
85161: LD_ADDR_VAR 0 1
85165: PUSH
85166: LD_VAR 0 2
85170: PUSH
85171: FOR_IN
85172: IFFALSE 85185
// begin DestroyUnit ( i ) ;
85174: LD_VAR 0 1
85178: PPUSH
85179: CALL_OW 65
// end ;
85183: GO 85171
85185: POP
85186: POP
// end ;
85187: PPOPN 2
85189: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
85190: LD_EXP 95
85194: PUSH
85195: LD_EXP 99
85199: AND
85200: IFFALSE 85281
85202: GO 85204
85204: DISABLE
85205: LD_INT 0
85207: PPUSH
85208: PPUSH
// begin enable ;
85209: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
85210: LD_ADDR_VAR 0 2
85214: PUSH
85215: LD_INT 22
85217: PUSH
85218: LD_OWVAR 2
85222: PUSH
85223: EMPTY
85224: LIST
85225: LIST
85226: PUSH
85227: LD_INT 32
85229: PUSH
85230: LD_INT 3
85232: PUSH
85233: EMPTY
85234: LIST
85235: LIST
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: PPUSH
85241: CALL_OW 69
85245: ST_TO_ADDR
// if not tmp then
85246: LD_VAR 0 2
85250: NOT
85251: IFFALSE 85255
// exit ;
85253: GO 85281
// for i in tmp do
85255: LD_ADDR_VAR 0 1
85259: PUSH
85260: LD_VAR 0 2
85264: PUSH
85265: FOR_IN
85266: IFFALSE 85279
// begin DestroyUnit ( i ) ;
85268: LD_VAR 0 1
85272: PPUSH
85273: CALL_OW 65
// end ;
85277: GO 85265
85279: POP
85280: POP
// end ;
85281: PPOPN 2
85283: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
85284: LD_EXP 95
85288: PUSH
85289: LD_EXP 96
85293: AND
85294: IFFALSE 85387
85296: GO 85298
85298: DISABLE
85299: LD_INT 0
85301: PPUSH
// begin enable ;
85302: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
85303: LD_ADDR_VAR 0 1
85307: PUSH
85308: LD_INT 22
85310: PUSH
85311: LD_OWVAR 2
85315: PUSH
85316: EMPTY
85317: LIST
85318: LIST
85319: PUSH
85320: LD_INT 2
85322: PUSH
85323: LD_INT 25
85325: PUSH
85326: LD_INT 5
85328: PUSH
85329: EMPTY
85330: LIST
85331: LIST
85332: PUSH
85333: LD_INT 25
85335: PUSH
85336: LD_INT 9
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: PUSH
85343: LD_INT 25
85345: PUSH
85346: LD_INT 8
85348: PUSH
85349: EMPTY
85350: LIST
85351: LIST
85352: PUSH
85353: EMPTY
85354: LIST
85355: LIST
85356: LIST
85357: LIST
85358: PUSH
85359: EMPTY
85360: LIST
85361: LIST
85362: PPUSH
85363: CALL_OW 69
85367: PUSH
85368: FOR_IN
85369: IFFALSE 85385
// begin SetClass ( i , 1 ) ;
85371: LD_VAR 0 1
85375: PPUSH
85376: LD_INT 1
85378: PPUSH
85379: CALL_OW 336
// end ;
85383: GO 85368
85385: POP
85386: POP
// end ;
85387: PPOPN 1
85389: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
85390: LD_EXP 95
85394: PUSH
85395: LD_EXP 97
85399: AND
85400: PUSH
85401: LD_OWVAR 65
85405: PUSH
85406: LD_INT 7
85408: LESS
85409: AND
85410: IFFALSE 85424
85412: GO 85414
85414: DISABLE
// begin enable ;
85415: ENABLE
// game_speed := 7 ;
85416: LD_ADDR_OWVAR 65
85420: PUSH
85421: LD_INT 7
85423: ST_TO_ADDR
// end ;
85424: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
85425: LD_EXP 95
85429: PUSH
85430: LD_EXP 100
85434: AND
85435: IFFALSE 85637
85437: GO 85439
85439: DISABLE
85440: LD_INT 0
85442: PPUSH
85443: PPUSH
85444: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
85445: LD_ADDR_VAR 0 3
85449: PUSH
85450: LD_INT 81
85452: PUSH
85453: LD_OWVAR 2
85457: PUSH
85458: EMPTY
85459: LIST
85460: LIST
85461: PUSH
85462: LD_INT 21
85464: PUSH
85465: LD_INT 1
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PUSH
85472: EMPTY
85473: LIST
85474: LIST
85475: PPUSH
85476: CALL_OW 69
85480: ST_TO_ADDR
// if not tmp then
85481: LD_VAR 0 3
85485: NOT
85486: IFFALSE 85490
// exit ;
85488: GO 85637
// if tmp > 5 then
85490: LD_VAR 0 3
85494: PUSH
85495: LD_INT 5
85497: GREATER
85498: IFFALSE 85510
// k := 5 else
85500: LD_ADDR_VAR 0 2
85504: PUSH
85505: LD_INT 5
85507: ST_TO_ADDR
85508: GO 85520
// k := tmp ;
85510: LD_ADDR_VAR 0 2
85514: PUSH
85515: LD_VAR 0 3
85519: ST_TO_ADDR
// for i := 1 to k do
85520: LD_ADDR_VAR 0 1
85524: PUSH
85525: DOUBLE
85526: LD_INT 1
85528: DEC
85529: ST_TO_ADDR
85530: LD_VAR 0 2
85534: PUSH
85535: FOR_TO
85536: IFFALSE 85635
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
85538: LD_VAR 0 3
85542: PUSH
85543: LD_VAR 0 1
85547: ARRAY
85548: PPUSH
85549: LD_VAR 0 1
85553: PUSH
85554: LD_INT 4
85556: MOD
85557: PUSH
85558: LD_INT 1
85560: PLUS
85561: PPUSH
85562: CALL_OW 259
85566: PUSH
85567: LD_INT 10
85569: LESS
85570: IFFALSE 85633
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
85572: LD_VAR 0 3
85576: PUSH
85577: LD_VAR 0 1
85581: ARRAY
85582: PPUSH
85583: LD_VAR 0 1
85587: PUSH
85588: LD_INT 4
85590: MOD
85591: PUSH
85592: LD_INT 1
85594: PLUS
85595: PPUSH
85596: LD_VAR 0 3
85600: PUSH
85601: LD_VAR 0 1
85605: ARRAY
85606: PPUSH
85607: LD_VAR 0 1
85611: PUSH
85612: LD_INT 4
85614: MOD
85615: PUSH
85616: LD_INT 1
85618: PLUS
85619: PPUSH
85620: CALL_OW 259
85624: PUSH
85625: LD_INT 1
85627: PLUS
85628: PPUSH
85629: CALL_OW 237
85633: GO 85535
85635: POP
85636: POP
// end ;
85637: PPOPN 3
85639: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
85640: LD_EXP 95
85644: PUSH
85645: LD_EXP 101
85649: AND
85650: IFFALSE 85670
85652: GO 85654
85654: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
85655: LD_INT 4
85657: PPUSH
85658: LD_OWVAR 2
85662: PPUSH
85663: LD_INT 0
85665: PPUSH
85666: CALL_OW 324
85670: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
85671: LD_EXP 95
85675: PUSH
85676: LD_EXP 102
85680: AND
85681: IFFALSE 85780
85683: GO 85685
85685: DISABLE
85686: LD_INT 0
85688: PPUSH
85689: PPUSH
// begin enable ;
85690: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
85691: LD_ADDR_VAR 0 2
85695: PUSH
85696: LD_INT 22
85698: PUSH
85699: LD_OWVAR 2
85703: PUSH
85704: EMPTY
85705: LIST
85706: LIST
85707: PUSH
85708: LD_INT 2
85710: PUSH
85711: LD_INT 34
85713: PUSH
85714: LD_INT 11
85716: PUSH
85717: EMPTY
85718: LIST
85719: LIST
85720: PUSH
85721: LD_INT 34
85723: PUSH
85724: LD_INT 30
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: PUSH
85731: EMPTY
85732: LIST
85733: LIST
85734: LIST
85735: PUSH
85736: EMPTY
85737: LIST
85738: LIST
85739: PPUSH
85740: CALL_OW 69
85744: ST_TO_ADDR
// if not tmp then
85745: LD_VAR 0 2
85749: NOT
85750: IFFALSE 85754
// exit ;
85752: GO 85780
// for i in tmp do
85754: LD_ADDR_VAR 0 1
85758: PUSH
85759: LD_VAR 0 2
85763: PUSH
85764: FOR_IN
85765: IFFALSE 85778
// begin DestroyUnit ( i ) ;
85767: LD_VAR 0 1
85771: PPUSH
85772: CALL_OW 65
// end ;
85776: GO 85764
85778: POP
85779: POP
// end ;
85780: PPOPN 2
85782: END
// every 0 0$1 trigger StreamModeActive and sBunker do
85783: LD_EXP 95
85787: PUSH
85788: LD_EXP 103
85792: AND
85793: IFFALSE 85813
85795: GO 85797
85797: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
85798: LD_INT 32
85800: PPUSH
85801: LD_OWVAR 2
85805: PPUSH
85806: LD_INT 0
85808: PPUSH
85809: CALL_OW 324
85813: END
// every 0 0$1 trigger StreamModeActive and sHack do
85814: LD_EXP 95
85818: PUSH
85819: LD_EXP 104
85823: AND
85824: IFFALSE 85844
85826: GO 85828
85828: DISABLE
// SetTech ( tech_Virus , your_side , state_disabled ) ;
85829: LD_INT 33
85831: PPUSH
85832: LD_OWVAR 2
85836: PPUSH
85837: LD_INT 0
85839: PPUSH
85840: CALL_OW 322
85844: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
85845: LD_EXP 95
85849: PUSH
85850: LD_EXP 105
85854: AND
85855: IFFALSE 85934
85857: GO 85859
85859: DISABLE
85860: LD_INT 0
85862: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
85863: LD_ADDR_VAR 0 1
85867: PUSH
85868: LD_INT 22
85870: PUSH
85871: LD_OWVAR 2
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: PUSH
85880: LD_INT 21
85882: PUSH
85883: LD_INT 3
85885: PUSH
85886: EMPTY
85887: LIST
85888: LIST
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: PPUSH
85894: CALL_OW 69
85898: ST_TO_ADDR
// if not tmp then
85899: LD_VAR 0 1
85903: NOT
85904: IFFALSE 85908
// exit ;
85906: GO 85934
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
85908: LD_VAR 0 1
85912: PUSH
85913: LD_INT 1
85915: PPUSH
85916: LD_VAR 0 1
85920: PPUSH
85921: CALL_OW 12
85925: ARRAY
85926: PPUSH
85927: LD_INT 100
85929: PPUSH
85930: CALL_OW 234
// end ;
85934: PPOPN 1
85936: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
85937: LD_EXP 95
85941: PUSH
85942: LD_EXP 107
85946: AND
85947: IFFALSE 86045
85949: GO 85951
85951: DISABLE
85952: LD_INT 0
85954: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
85955: LD_ADDR_VAR 0 1
85959: PUSH
85960: LD_INT 22
85962: PUSH
85963: LD_OWVAR 2
85967: PUSH
85968: EMPTY
85969: LIST
85970: LIST
85971: PUSH
85972: LD_INT 21
85974: PUSH
85975: LD_INT 1
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: PPUSH
85986: CALL_OW 69
85990: ST_TO_ADDR
// if not tmp then
85991: LD_VAR 0 1
85995: NOT
85996: IFFALSE 86000
// exit ;
85998: GO 86045
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
86000: LD_VAR 0 1
86004: PUSH
86005: LD_INT 1
86007: PPUSH
86008: LD_VAR 0 1
86012: PPUSH
86013: CALL_OW 12
86017: ARRAY
86018: PPUSH
86019: LD_INT 1
86021: PPUSH
86022: LD_INT 4
86024: PPUSH
86025: CALL_OW 12
86029: PPUSH
86030: LD_INT 3000
86032: PPUSH
86033: LD_INT 9000
86035: PPUSH
86036: CALL_OW 12
86040: PPUSH
86041: CALL_OW 492
// end ;
86045: PPOPN 1
86047: END
// every 0 0$1 trigger StreamModeActive and sDepot do
86048: LD_EXP 95
86052: PUSH
86053: LD_EXP 108
86057: AND
86058: IFFALSE 86078
86060: GO 86062
86062: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
86063: LD_INT 1
86065: PPUSH
86066: LD_OWVAR 2
86070: PPUSH
86071: LD_INT 0
86073: PPUSH
86074: CALL_OW 324
86078: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
86079: LD_EXP 95
86083: PUSH
86084: LD_EXP 109
86088: AND
86089: IFFALSE 86172
86091: GO 86093
86093: DISABLE
86094: LD_INT 0
86096: PPUSH
86097: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
86098: LD_ADDR_VAR 0 2
86102: PUSH
86103: LD_INT 22
86105: PUSH
86106: LD_OWVAR 2
86110: PUSH
86111: EMPTY
86112: LIST
86113: LIST
86114: PUSH
86115: LD_INT 21
86117: PUSH
86118: LD_INT 3
86120: PUSH
86121: EMPTY
86122: LIST
86123: LIST
86124: PUSH
86125: EMPTY
86126: LIST
86127: LIST
86128: PPUSH
86129: CALL_OW 69
86133: ST_TO_ADDR
// if not tmp then
86134: LD_VAR 0 2
86138: NOT
86139: IFFALSE 86143
// exit ;
86141: GO 86172
// for i in tmp do
86143: LD_ADDR_VAR 0 1
86147: PUSH
86148: LD_VAR 0 2
86152: PUSH
86153: FOR_IN
86154: IFFALSE 86170
// SetBLevel ( i , 10 ) ;
86156: LD_VAR 0 1
86160: PPUSH
86161: LD_INT 10
86163: PPUSH
86164: CALL_OW 241
86168: GO 86153
86170: POP
86171: POP
// end ;
86172: PPOPN 2
86174: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
86175: LD_EXP 95
86179: PUSH
86180: LD_EXP 110
86184: AND
86185: IFFALSE 86268
86187: GO 86189
86189: DISABLE
86190: LD_INT 0
86192: PPUSH
86193: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
86194: LD_ADDR_VAR 0 2
86198: PUSH
86199: LD_INT 22
86201: PUSH
86202: LD_OWVAR 2
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PUSH
86211: LD_INT 25
86213: PUSH
86214: LD_INT 1
86216: PUSH
86217: EMPTY
86218: LIST
86219: LIST
86220: PUSH
86221: EMPTY
86222: LIST
86223: LIST
86224: PPUSH
86225: CALL_OW 69
86229: ST_TO_ADDR
// if not tmp then
86230: LD_VAR 0 2
86234: NOT
86235: IFFALSE 86239
// exit ;
86237: GO 86268
// for i in tmp do
86239: LD_ADDR_VAR 0 1
86243: PUSH
86244: LD_VAR 0 2
86248: PUSH
86249: FOR_IN
86250: IFFALSE 86266
// SetClass ( i , 4 ) ;
86252: LD_VAR 0 1
86256: PPUSH
86257: LD_INT 4
86259: PPUSH
86260: CALL_OW 336
86264: GO 86249
86266: POP
86267: POP
// end ;
86268: PPOPN 2
86270: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
86271: LD_EXP 95
86275: PUSH
86276: LD_EXP 111
86280: AND
86281: PUSH
86282: LD_OWVAR 67
86286: PUSH
86287: LD_INT 3
86289: LESS
86290: AND
86291: IFFALSE 86310
86293: GO 86295
86295: DISABLE
// Difficulty := Difficulty + 1 ;
86296: LD_ADDR_OWVAR 67
86300: PUSH
86301: LD_OWVAR 67
86305: PUSH
86306: LD_INT 1
86308: PLUS
86309: ST_TO_ADDR
86310: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
86311: LD_EXP 95
86315: PUSH
86316: LD_EXP 112
86320: AND
86321: IFFALSE 86424
86323: GO 86325
86325: DISABLE
86326: LD_INT 0
86328: PPUSH
// begin for i := 1 to 5 do
86329: LD_ADDR_VAR 0 1
86333: PUSH
86334: DOUBLE
86335: LD_INT 1
86337: DEC
86338: ST_TO_ADDR
86339: LD_INT 5
86341: PUSH
86342: FOR_TO
86343: IFFALSE 86422
// begin uc_nation := nation_nature ;
86345: LD_ADDR_OWVAR 21
86349: PUSH
86350: LD_INT 0
86352: ST_TO_ADDR
// uc_side := 0 ;
86353: LD_ADDR_OWVAR 20
86357: PUSH
86358: LD_INT 0
86360: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
86361: LD_ADDR_OWVAR 29
86365: PUSH
86366: LD_INT 12
86368: PUSH
86369: LD_INT 12
86371: PUSH
86372: EMPTY
86373: LIST
86374: LIST
86375: ST_TO_ADDR
// hc_agressivity := 20 ;
86376: LD_ADDR_OWVAR 35
86380: PUSH
86381: LD_INT 20
86383: ST_TO_ADDR
// hc_class := class_tiger ;
86384: LD_ADDR_OWVAR 28
86388: PUSH
86389: LD_INT 14
86391: ST_TO_ADDR
// hc_gallery :=  ;
86392: LD_ADDR_OWVAR 33
86396: PUSH
86397: LD_STRING 
86399: ST_TO_ADDR
// hc_name :=  ;
86400: LD_ADDR_OWVAR 26
86404: PUSH
86405: LD_STRING 
86407: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
86408: CALL_OW 44
86412: PPUSH
86413: LD_INT 0
86415: PPUSH
86416: CALL_OW 51
// end ;
86420: GO 86342
86422: POP
86423: POP
// end ;
86424: PPOPN 1
86426: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
86427: LD_EXP 95
86431: PUSH
86432: LD_EXP 113
86436: AND
86437: IFFALSE 86611
86439: GO 86441
86441: DISABLE
86442: LD_INT 0
86444: PPUSH
86445: PPUSH
86446: PPUSH
86447: PPUSH
// begin result := false ;
86448: LD_ADDR_VAR 0 4
86452: PUSH
86453: LD_INT 0
86455: ST_TO_ADDR
// for i := 1 to 8 do
86456: LD_ADDR_VAR 0 1
86460: PUSH
86461: DOUBLE
86462: LD_INT 1
86464: DEC
86465: ST_TO_ADDR
86466: LD_INT 8
86468: PUSH
86469: FOR_TO
86470: IFFALSE 86581
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
86472: LD_ADDR_VAR 0 2
86476: PUSH
86477: LD_INT 10
86479: PUSH
86480: LD_INT 50
86482: PUSH
86483: LD_INT 90
86485: PUSH
86486: LD_INT 140
86488: PUSH
86489: EMPTY
86490: LIST
86491: LIST
86492: LIST
86493: LIST
86494: PUSH
86495: LD_INT 1
86497: PPUSH
86498: LD_INT 4
86500: PPUSH
86501: CALL_OW 12
86505: ARRAY
86506: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
86507: LD_ADDR_VAR 0 3
86511: PUSH
86512: LD_INT 10
86514: PUSH
86515: LD_INT 50
86517: PUSH
86518: LD_INT 90
86520: PUSH
86521: LD_INT 140
86523: PUSH
86524: EMPTY
86525: LIST
86526: LIST
86527: LIST
86528: LIST
86529: PUSH
86530: LD_INT 1
86532: PPUSH
86533: LD_INT 4
86535: PPUSH
86536: CALL_OW 12
86540: ARRAY
86541: ST_TO_ADDR
// if ValidHex ( x , y ) then
86542: LD_VAR 0 2
86546: PPUSH
86547: LD_VAR 0 3
86551: PPUSH
86552: CALL_OW 488
86556: IFFALSE 86579
// begin result := [ x , y ] ;
86558: LD_ADDR_VAR 0 4
86562: PUSH
86563: LD_VAR 0 2
86567: PUSH
86568: LD_VAR 0 3
86572: PUSH
86573: EMPTY
86574: LIST
86575: LIST
86576: ST_TO_ADDR
// break ;
86577: GO 86581
// end ; end ;
86579: GO 86469
86581: POP
86582: POP
// if result then
86583: LD_VAR 0 4
86587: IFFALSE 86611
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
86589: LD_VAR 0 4
86593: PUSH
86594: LD_INT 1
86596: ARRAY
86597: PPUSH
86598: LD_VAR 0 4
86602: PUSH
86603: LD_INT 2
86605: ARRAY
86606: PPUSH
86607: CALL_OW 429
// end ;
86611: PPOPN 4
86613: END
// every 0 0$1 trigger StreamModeActive and sReset do
86614: LD_EXP 95
86618: PUSH
86619: LD_EXP 115
86623: AND
86624: IFFALSE 86636
86626: GO 86628
86628: DISABLE
// YouLost (  ) ;
86629: LD_STRING 
86631: PPUSH
86632: CALL_OW 104
86636: END
// every 0 0$1 trigger StreamModeActive and sFog do
86637: LD_EXP 95
86641: PUSH
86642: LD_EXP 114
86646: AND
86647: IFFALSE 86661
86649: GO 86651
86651: DISABLE
// FogOff ( your_side ) ;
86652: LD_OWVAR 2
86656: PPUSH
86657: CALL_OW 344
86661: END
// every 0 0$1 trigger StreamModeActive and sSun do
86662: LD_EXP 95
86666: PUSH
86667: LD_EXP 116
86671: AND
86672: IFFALSE 86700
86674: GO 86676
86676: DISABLE
// begin solar_recharge_percent := 0 ;
86677: LD_ADDR_OWVAR 79
86681: PUSH
86682: LD_INT 0
86684: ST_TO_ADDR
// wait ( 5 5$00 ) ;
86685: LD_INT 10500
86687: PPUSH
86688: CALL_OW 67
// solar_recharge_percent := 100 ;
86692: LD_ADDR_OWVAR 79
86696: PUSH
86697: LD_INT 100
86699: ST_TO_ADDR
// end ; end_of_file
86700: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
86701: LD_INT 0
86703: PPUSH
86704: PPUSH
86705: PPUSH
86706: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
86707: LD_VAR 0 1
86711: PPUSH
86712: CALL_OW 264
86716: PUSH
86717: LD_EXP 49
86721: EQUAL
86722: IFFALSE 86794
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
86724: LD_INT 68
86726: PPUSH
86727: LD_VAR 0 1
86731: PPUSH
86732: CALL_OW 255
86736: PPUSH
86737: CALL_OW 321
86741: PUSH
86742: LD_INT 2
86744: EQUAL
86745: IFFALSE 86757
// eff := 70 else
86747: LD_ADDR_VAR 0 6
86751: PUSH
86752: LD_INT 70
86754: ST_TO_ADDR
86755: GO 86765
// eff := 30 ;
86757: LD_ADDR_VAR 0 6
86761: PUSH
86762: LD_INT 30
86764: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
86765: LD_VAR 0 1
86769: PPUSH
86770: CALL_OW 250
86774: PPUSH
86775: LD_VAR 0 1
86779: PPUSH
86780: CALL_OW 251
86784: PPUSH
86785: LD_VAR 0 6
86789: PPUSH
86790: CALL_OW 495
// end ; end ;
86794: LD_VAR 0 4
86798: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
86799: LD_INT 0
86801: PPUSH
86802: PPUSH
86803: PPUSH
86804: PPUSH
86805: PPUSH
86806: PPUSH
// if cmd = 124 then
86807: LD_VAR 0 1
86811: PUSH
86812: LD_INT 124
86814: EQUAL
86815: IFFALSE 87021
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
86817: LD_ADDR_VAR 0 5
86821: PUSH
86822: LD_INT 2
86824: PUSH
86825: LD_INT 34
86827: PUSH
86828: LD_INT 53
86830: PUSH
86831: EMPTY
86832: LIST
86833: LIST
86834: PUSH
86835: LD_INT 34
86837: PUSH
86838: LD_INT 14
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: LIST
86849: PPUSH
86850: CALL_OW 69
86854: ST_TO_ADDR
// if not tmp then
86855: LD_VAR 0 5
86859: NOT
86860: IFFALSE 86864
// exit ;
86862: GO 87021
// for i in tmp do
86864: LD_ADDR_VAR 0 3
86868: PUSH
86869: LD_VAR 0 5
86873: PUSH
86874: FOR_IN
86875: IFFALSE 87019
// begin taskList := GetTaskList ( i ) ;
86877: LD_ADDR_VAR 0 6
86881: PUSH
86882: LD_VAR 0 3
86886: PPUSH
86887: CALL_OW 437
86891: ST_TO_ADDR
// if not taskList then
86892: LD_VAR 0 6
86896: NOT
86897: IFFALSE 86901
// continue ;
86899: GO 86874
// for j = 1 to taskList do
86901: LD_ADDR_VAR 0 4
86905: PUSH
86906: DOUBLE
86907: LD_INT 1
86909: DEC
86910: ST_TO_ADDR
86911: LD_VAR 0 6
86915: PUSH
86916: FOR_TO
86917: IFFALSE 87015
// if taskList [ j ] [ 1 ] = | then
86919: LD_VAR 0 6
86923: PUSH
86924: LD_VAR 0 4
86928: ARRAY
86929: PUSH
86930: LD_INT 1
86932: ARRAY
86933: PUSH
86934: LD_STRING |
86936: EQUAL
86937: IFFALSE 87013
// begin _taskList := Delete ( taskList , 1 ) ;
86939: LD_ADDR_VAR 0 7
86943: PUSH
86944: LD_VAR 0 6
86948: PPUSH
86949: LD_INT 1
86951: PPUSH
86952: CALL_OW 3
86956: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
86957: LD_VAR 0 3
86961: PPUSH
86962: LD_VAR 0 7
86966: PPUSH
86967: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
86971: LD_VAR 0 3
86975: PPUSH
86976: LD_VAR 0 6
86980: PUSH
86981: LD_VAR 0 4
86985: ARRAY
86986: PUSH
86987: LD_INT 2
86989: ARRAY
86990: PPUSH
86991: LD_VAR 0 6
86995: PUSH
86996: LD_VAR 0 4
87000: ARRAY
87001: PUSH
87002: LD_INT 3
87004: ARRAY
87005: PPUSH
87006: LD_INT 8
87008: PPUSH
87009: CALL 87026 0 4
// end ;
87013: GO 86916
87015: POP
87016: POP
// end ;
87017: GO 86874
87019: POP
87020: POP
// end ; end ;
87021: LD_VAR 0 2
87025: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
87026: LD_INT 0
87028: PPUSH
87029: PPUSH
87030: PPUSH
87031: PPUSH
87032: PPUSH
87033: PPUSH
87034: PPUSH
87035: PPUSH
87036: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
87037: LD_VAR 0 1
87041: NOT
87042: PUSH
87043: LD_VAR 0 2
87047: PPUSH
87048: LD_VAR 0 3
87052: PPUSH
87053: CALL_OW 488
87057: NOT
87058: OR
87059: PUSH
87060: LD_VAR 0 4
87064: NOT
87065: OR
87066: IFFALSE 87070
// exit ;
87068: GO 87410
// list := [ ] ;
87070: LD_ADDR_VAR 0 13
87074: PUSH
87075: EMPTY
87076: ST_TO_ADDR
// if x - r < 0 then
87077: LD_VAR 0 2
87081: PUSH
87082: LD_VAR 0 4
87086: MINUS
87087: PUSH
87088: LD_INT 0
87090: LESS
87091: IFFALSE 87103
// min_x := 0 else
87093: LD_ADDR_VAR 0 7
87097: PUSH
87098: LD_INT 0
87100: ST_TO_ADDR
87101: GO 87119
// min_x := x - r ;
87103: LD_ADDR_VAR 0 7
87107: PUSH
87108: LD_VAR 0 2
87112: PUSH
87113: LD_VAR 0 4
87117: MINUS
87118: ST_TO_ADDR
// if y - r < 0 then
87119: LD_VAR 0 3
87123: PUSH
87124: LD_VAR 0 4
87128: MINUS
87129: PUSH
87130: LD_INT 0
87132: LESS
87133: IFFALSE 87145
// min_y := 0 else
87135: LD_ADDR_VAR 0 8
87139: PUSH
87140: LD_INT 0
87142: ST_TO_ADDR
87143: GO 87161
// min_y := y - r ;
87145: LD_ADDR_VAR 0 8
87149: PUSH
87150: LD_VAR 0 3
87154: PUSH
87155: LD_VAR 0 4
87159: MINUS
87160: ST_TO_ADDR
// max_x := x + r ;
87161: LD_ADDR_VAR 0 9
87165: PUSH
87166: LD_VAR 0 2
87170: PUSH
87171: LD_VAR 0 4
87175: PLUS
87176: ST_TO_ADDR
// max_y := y + r ;
87177: LD_ADDR_VAR 0 10
87181: PUSH
87182: LD_VAR 0 3
87186: PUSH
87187: LD_VAR 0 4
87191: PLUS
87192: ST_TO_ADDR
// for _x = min_x to max_x do
87193: LD_ADDR_VAR 0 11
87197: PUSH
87198: DOUBLE
87199: LD_VAR 0 7
87203: DEC
87204: ST_TO_ADDR
87205: LD_VAR 0 9
87209: PUSH
87210: FOR_TO
87211: IFFALSE 87328
// for _y = min_y to max_y do
87213: LD_ADDR_VAR 0 12
87217: PUSH
87218: DOUBLE
87219: LD_VAR 0 8
87223: DEC
87224: ST_TO_ADDR
87225: LD_VAR 0 10
87229: PUSH
87230: FOR_TO
87231: IFFALSE 87324
// begin if not ValidHex ( _x , _y ) then
87233: LD_VAR 0 11
87237: PPUSH
87238: LD_VAR 0 12
87242: PPUSH
87243: CALL_OW 488
87247: NOT
87248: IFFALSE 87252
// continue ;
87250: GO 87230
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
87252: LD_VAR 0 11
87256: PPUSH
87257: LD_VAR 0 12
87261: PPUSH
87262: CALL_OW 351
87266: PUSH
87267: LD_VAR 0 11
87271: PPUSH
87272: LD_VAR 0 12
87276: PPUSH
87277: CALL_OW 554
87281: AND
87282: IFFALSE 87322
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
87284: LD_ADDR_VAR 0 13
87288: PUSH
87289: LD_VAR 0 13
87293: PPUSH
87294: LD_VAR 0 13
87298: PUSH
87299: LD_INT 1
87301: PLUS
87302: PPUSH
87303: LD_VAR 0 11
87307: PUSH
87308: LD_VAR 0 12
87312: PUSH
87313: EMPTY
87314: LIST
87315: LIST
87316: PPUSH
87317: CALL_OW 2
87321: ST_TO_ADDR
// end ;
87322: GO 87230
87324: POP
87325: POP
87326: GO 87210
87328: POP
87329: POP
// if not list then
87330: LD_VAR 0 13
87334: NOT
87335: IFFALSE 87339
// exit ;
87337: GO 87410
// for i in list do
87339: LD_ADDR_VAR 0 6
87343: PUSH
87344: LD_VAR 0 13
87348: PUSH
87349: FOR_IN
87350: IFFALSE 87408
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
87352: LD_VAR 0 1
87356: PPUSH
87357: LD_STRING M
87359: PUSH
87360: LD_VAR 0 6
87364: PUSH
87365: LD_INT 1
87367: ARRAY
87368: PUSH
87369: LD_VAR 0 6
87373: PUSH
87374: LD_INT 2
87376: ARRAY
87377: PUSH
87378: LD_INT 0
87380: PUSH
87381: LD_INT 0
87383: PUSH
87384: LD_INT 0
87386: PUSH
87387: LD_INT 0
87389: PUSH
87390: EMPTY
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: LIST
87397: LIST
87398: PUSH
87399: EMPTY
87400: LIST
87401: PPUSH
87402: CALL_OW 447
87406: GO 87349
87408: POP
87409: POP
// end ;
87410: LD_VAR 0 5
87414: RET
